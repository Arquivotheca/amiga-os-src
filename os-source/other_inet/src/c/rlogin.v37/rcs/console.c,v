head     38.0;
branch   ;
access   ;
symbols  Release1:1.11;
locks    ; strict;
comment  @ * @;


38.0
date     93.04.08.15.24.46;  author bj;  state Exp;
branches ;
next     37.26;

37.26
date     93.02.11.17.46.54;  author bj;  state Exp;
branches ;
next     37.22;

37.22
date     93.02.08.14.05.32;  author bj;  state Exp;
branches ;
next     37.21;

37.21
date     92.09.11.16.26.33;  author bj;  state Exp;
branches ;
next     37.20;

37.20
date     92.08.11.11.19.13;  author bj;  state Exp;
branches ;
next     37.19;

37.19
date     92.08.08.19.44.18;  author bj;  state Exp;
branches ;
next     37.17;

37.17
date     92.05.27.15.52.37;  author bj;  state Exp;
branches ;
next     37.16;

37.16
date     92.05.27.15.38.23;  author bj;  state Exp;
branches ;
next     1.17;

1.17
date     91.08.07.15.20.09;  author bj;  state Exp;
branches ;
next     1.16;

1.16
date     91.08.06.13.26.20;  author bj;  state Exp;
branches ;
next     1.15;

1.15
date     91.08.05.13.57.04;  author bj;  state Exp;
branches ;
next     1.14;

1.14
date     91.06.19.12.36.47;  author bj;  state Exp;
branches ;
next     1.13;

1.13
date     91.04.24.15.36.34;  author bj;  state Exp;
branches ;
next     1.12;

1.12
date     91.04.12.14.13.56;  author bj;  state Exp;
branches ;
next     1.11;

1.11
date     91.02.14.16.16.37;  author bj;  state Exp;
branches ;
next     1.10;

1.10
date     90.12.06.15.36.45;  author bj;  state Exp;
branches ;
next     1.9;

1.9
date     90.12.05.16.12.35;  author bj;  state Exp;
branches ;
next     1.8;

1.8
date     90.12.02.06.00.48;  author martin;  state Exp;
branches ;
next     1.7;

1.7
date     90.12.01.22.00.18;  author martin;  state Exp;
branches ;
next     1.6;

1.6
date     90.11.29.15.11.23;  author bj;  state Exp;
branches ;
next     1.5;

1.5
date     90.11.29.10.27.13;  author bj;  state Exp;
branches ;
next     1.4;

1.4
date     90.11.13.15.27.31;  author bj;  state Exp;
branches ;
next     1.3;

1.3
date     90.11.13.15.26.29;  author bj;  state Exp;
branches ;
next     1.2;

1.2
date     90.11.13.15.23.14;  author bj;  state Exp;
branches ;
next     1.1;

1.1
date     90.11.02.16.01.09;  author bj;  state Exp;
branches ;
next     ;


desc
@36.3 console module for rlogin
@


38.0
log
@This is the complete rewrite of rlogin (version number 38.xx.)
These are the console routines.
@
text
@/* -----------------------------------------------------------------------
 * console.c    rlogin 38   rewrite
 *
 * $Locker:$
 *
 * $Id:$
 *
 * $Revision:$
 *
 * $Log:$
 *
 * $Header:$
 *
 *------------------------------------------------------------------------
 */

#define CON 1

#include "rl.h"

/* ==============================================================
 * This function gets a character from the console and restarts 
 * the io request.
 * ==============================================================
 */

BYTE
console_getchar( struct glob *g )
{
	REGISTER SYSBASE ;
	REGISTER struct IOStdReq *readreq = g->g_ConReadReq ;
	BYTE rtn;


	if(!CheckIO((struct IORequest *)readreq))
	{
		WaitIO((struct IORequest *)readreq);
	}

	// get existing character then send request for the next //

	rtn = g->g_inchar ; 
	readreq->io_Command = CMD_READ;
	readreq->io_Data    = (APTR)&g->g_inchar ;
	readreq->io_Length  = sizeof(g->g_inchar);

	SendIO((struct IORequest *)readreq);
	return( rtn ) ;
}


/* ==============================================================
 * SetUpConsole()
 *
 * This function sets up the console device for both reading
 * and writing and *STARTS THE READ PROCESS !!!* via a call
 * to console_getchar() 
 * ==============================================================
 */


BOOL SetUpConsole(struct glob *g)
{
	DOSBASE(g) ;
	SYSBASE ;
	struct IOStdReq *cr, *cw ;
	struct MsgPort *crp, *cwp ;
	REGISTER struct glob *gl = g ;
	LONG error ;
 
	g->g_error = ERR_GETCONSOLE ;
	if(crp = CreateMsgPort())
	{
		if(cwp = CreateMsgPort())
		{
			if(cr  = CreateIORequest(crp, (long)sizeof(struct IOStdReq)))
			{
				if(cw  = CreateIORequest(cwp, (long)sizeof(struct IOStdReq)))
				{
					cw->io_Data         = (APTR)gl->g_Window ;
					cw->io_Length       = sizeof(struct Window) ;
					if((error = OpenDevice("console.device", gl->g_user_conunit, (struct IORequest *)cw, CONFLAG_DEFAULT)) != 0)
					{
						PutStr("error: console open.\n") ;
					}
					else
					{
						gl->g_ConReadPort     = crp ;
						gl->g_ConWritePort    = cwp ;
						gl->g_ConReadReq      = cr ;
						gl->g_ConWriteReq     = cw ;
						gl->g_ConUnit         = (struct ConUnit *)cw->io_Unit ;
						gl->g_console_is_open = 1 ;

						*cr = *cw;
						cr->io_Message.mn_ReplyPort = crp;
						cr->io_Message.mn_Node.ln_Type = NT_REPLYMSG;
							// start the read //
						(void)console_getchar(g) ;
						gl->g_conread_was_used = 1 ;
						return(TRUE) ;
					}
					DeleteIORequest((struct IORequest *)cw) ;
				}
				DeleteIORequest((struct IORequest *)cr) ;
			}
			DeleteMsgPort(cwp) ;
		}
		DeleteMsgPort(crp) ;
	}
	return(FALSE) ;
}

/**************************************************************
 * KillConsole
 *************************************************************
 */

VOID
KillConsole(struct glob *g) 
{
	REGISTER SYSBASE ;
	REGISTER struct glob *gl = g ;
		
	if(gl->g_conwrite_was_used)
	{
		AbortIO((struct IORequest *)gl->g_ConWriteReq) ;
		WaitIO((struct IORequest *)gl->g_ConWriteReq) ;
	}

	if(gl->g_conread_was_used)
	{
		AbortIO((struct IORequest *)gl->g_ConReadReq) ;
		WaitIO((struct IORequest *)gl->g_ConReadReq) ;
	}

	if( gl->g_console_is_open)
	{
		CloseDevice((struct IORequest *)gl->g_ConWriteReq) ;
//		gl->g_console_is_open = 0 ;
	}
	
	if( gl->g_ConWriteReq )
	{
		DeleteIORequest((struct IORequest *)gl->g_ConWriteReq) ;
//		gl->g_ConWriteReq = NULL ;
	}

	if( gl->g_ConReadReq )
	{
		DeleteIORequest((struct IORequest *)gl->g_ConReadReq) ;
//		gl->g_ConReadReq = NULL ;
	}

	if( gl->g_ConWritePort ) ;
	{
		DeleteMsgPort(gl->g_ConWritePort) ;
//		gl->g_ConWritePort = NULL ;
	}

	if( gl->g_ConReadPort ) ;
	{
		DeleteMsgPort(gl->g_ConReadPort) ;
//		gl->g_ConReadPort = NULL ;
	}
}


/***************************************************************
 * CON_WRITE
 ***************************************************************
 */

VOID 
con_write(unsigned char *buf, ULONG len, struct glob *g)
{
	REGISTER struct IOStdReq *c = g->g_ConWriteReq ;
	REGISTER SYSBASE ;

		/* break big buffers into small pieces */

	
	while ( len > 80 ) 
	{
		c->io_Command = CMD_WRITE;
		c->io_Data    = (APTR)buf;
		c->io_Length  = 80L ;
		DoIO((struct IORequest *)c);
		buf += 80;
		len -= 80;
	}
	
	if( len ) 
	{
		c->io_Command = CMD_WRITE;
		c->io_Data    = (APTR)buf;
		c->io_Length  = (LONG)len; 
		DoIO((struct IORequest *)c);
	}
}

/* =============================================================
 * console_char_ready(void)
 *
 * returns TRUE if a keypress or has occurred,
 * and returns FALSE if not. Called in mainloop() function
 * =============================================================
 */

BOOL
console_char_ready( struct glob *g )
{
	SYSBASE ;

	return(CheckIO((struct IORequest *)g->g_ConReadReq)) ;
}

/* end */
@


37.26
log
@Added support for global data structures (future)
@
text
@d1 2
a2 2
/* ==========================================================================
 * console.c  for rlogin   Lattice 5.10
d4 1
a4 1
 * $Locker: bj $
d6 19
a24 243
 * $Id: console.c,v 37.22 93/02/08 14:05:32 bj Exp Locker: bj $
 *
 * $Revision: 37.22 $
 *                                                              
 * $Log:	console.c,v $
 * Revision 37.22  93/02/08  14:05:32  bj
 * Binary 37.24
 * 
 * Fixed bug where console cut/paste didn't work when rlogin
 * was opened on a custom screen.
 * 
 * Added SA_Interleaved=TRUE tag to OpenScreen() call.
 * 
 * Revision 37.21  92/09/11  16:26:33  bj
 * Changes in rlogin.c. New revision.
 * 
 * Revision 37.20  92/08/11  11:19:13  bj
 * 1. "include/proto/*.h" replaced by "include:clib/*.h" 
 * 2. Menus changed to (a) remove spaces (b) change titles.
 * 3. menufont_attr variable removed (used in LayoutMenus())
 * 4. Both NewWindow and NewScreen structs changed to ExtNew*
 *    to support newlook menus and title bars.
 *    (custom screen code really screwed and has needed to
 *     be fixed forever.  Someday soon ... )
 * 5. taglists for both ExtNew*
 * 
 * Revision 37.19  92/08/08  19:44:18  bj
 * Fixed enforcer hits in AlterMenu() (strcmp(NULL, "string")).
 * 
 * 37.18 was an internal version. AS225 R2
 * 
 * Revision 37.17  92/05/27  15:52:37  bj
 * No changes from 37.16. Revision bump.
 * 
 * Revision 37.16  92/05/27  15:38:23  bj
 * Mostly detail changes to support changes in rlogin.c v37.16
 * 
 * Revision 1.17  91/08/07  15:20:09  bj
 * details.
 * 
 * Revision 1.16  91/08/06  13:26:20  bj
 * Changed to the global variabl structure (glob).
 * Added the About() function (finally!)
 * 
 * Revision 1.14  91/06/19  12:36:47  bj
 * Conclip support. Font bug fixed. Assorted details.
 * This is now 2.0x ONLY!
 * 
 * Revision 1.13  91/04/24  15:36:34  bj
 * Fixes and additions to give rlogin complete PAL mode compatibility
 * under 2.0. Does DisplayInfoData now to see what the text_oscan
 * values are.
 * 
 * Revision 1.12  91/04/12  14:13:56  bj
 * Added code to handle overscanned screens under 2.0. Bug #B13712. 
 * The window on a custom screen opens to the max of the oscan_txt
 * as set by the overscan preferences. User can override with the
 * -h and -w flags out to a max of the screen size. Default is
 * oscan_text.
 *
 * 
 * Revision 1.11  91/02/14  16:16:37  bj
 * Added ability to specify max window width even if on a
 * custom screen. Gives user ability to deal with "display
 * too wide" errors in vi, emacs, etc.
 *  
 * Tightened some code here and there. Details. etc.
 * 
 * Revision 1.10  90/12/06  15:36:45  bj
 * Fixed (for good, hopefully) the problems with calculating
 * the proper window sizes upon opening. This. Thanks to
 * Peter, the SIZEBBOTTOM thing is solved.
 * 
 * 
 * Revision 1.9  90/12/05  16:12:35  bj
 * fixed the value that rlogin sent to the host regarding
 * how many columns it could see. It was reporting one less
 * than was really there.
 * 
 * Revision 1.8  90/12/02  06:00:48  martin
 * fixed my previous fix for computing min win size under 2.0
 * 
 * Revision 1.7  90/12/01  22:00:18  martin
 * fixed bug that caused unpredictable window sizes under 2.0
 * 
 * Revision 1.6  90/11/29  15:11:23  bj
 * backed up to 5.05 to deter some odd crashes upon exit.
 * 
 * Revision 1.5  90/11/29  10:27:13  bj
 * rev 36.8 rlogin.  Fixes bad call to UnlockPubScreen that kept
 * the lock so any suqsequent attepts to resize screens with Prefs
 * editors, etc., would fail.
 * 
 * Revision 1.4  90/11/13  15:27:31  bj
 * no changes. test.
 * 
 * Revision 1.3  90/11/13  15:26:29  bj
 * Headers fixes.
 * 
 *
 *  $Header: AS225:src/c/rlogin/RCS/console.c,v 37.22 93/02/08 14:05:32 bj Exp Locker: bj $
 *
 * ==========================================================================
 */

#define CONSOLE_C 1


// #define DEBUG 1 

#ifdef DEBUG
#define DB(x)  KPrintF((x)) ;
#else
#define DB(x) ;
#endif

#include <stdio.h>
#include <exec/types.h>
#include <exec/io.h>
#include <exec/memory.h>
#include <exec/libraries.h>
#include <intuition/intuition.h>
#include <graphics/gfxbase.h>
#include <intuition/screens.h>
#include <graphics/displayinfo.h>
#include <libraries/gadtools.h>
#include <devices/conunit.h>
#include <utility/tagitem.h>

 //////////////////////////////////////////////

#include        <clib/alib_protos.h>
#include        <clib/asl_protos.h>
#include        <clib/console_protos.h>
#include        <clib/diskfont_protos.h>
#include        <clib/dos_protos.h>
#include        <clib/exec_protos.h>
#include        <clib/gadtools_protos.h>
#include        <clib/graphics_protos.h>
#include        <clib/intuition_protos.h>
#include        <clib/misc_protos.h>
#include        <clib/timer_protos.h>
#include        <clib/utility_protos.h>
#include        <clib/wb_protos.h>


 //////////////////////////////////////////////


#include <ss/socket.h>

#include "rlglobal.h"


 /* =====================================================================
  * BOTTOM BORDER HEIGHT IS A CONSTANT !!
  *
  * Up thru OS 2.0x the bottom border height of a window with the 
  * SIZEBBOTTOM flag set is calc'd based upon the height of the tallest
  * gadget in the window's bottom border. Same under 1.3.  The 
  * constants for these values are located in the file
  * "intuition/images.h".  The LOWRES height value is '10' while
  * the value for the HIRES is '9' so I am setting the standard
  * define for this as '10 + 1' to minimize the chance that font
  * extenders will hit the border.
  * ====================================================================
  */
  
// BYTE wtitle[128] = "Rlogin:" ;

#ifdef FOO
extern struct IOStdReq *CreateStdIO();
extern struct MsgPort  *CreatePort();
extern struct Library  *OpenLibrary();
extern struct Screen   *OpenScreen() ;
extern struct Window   *OpenWindow() ;
#endif


int cons_kybd_sigF;

struct IntuitionBase *IntuitionBase;
struct GfxBase       *GfxBase;
struct Library       *GadToolsBase ;
struct Library       *DiskfontBase ;
struct Library       *SockBase ;

STATIC LONG console_is_open = 0L ;

STATIC struct MsgPort  *crp, *cwp;
STATIC struct IOStdReq *cw,  *cr;
STATIC struct Screen   *scr = NULL , *myscreen = NULL ;

int min_wide = 640 ;     /* to start, we assume font width = 8. Can change!   */
int min_high = 200 ;   


struct ConUnit *conunit ;
struct Window *win;

int showtitle = 0 ;

	/* these next two are optionally set by the user to request maximum */
	/* column or row counts */
extern LONG max_window_cols_user ;  
extern LONG max_window_rows_user ;


STATIC struct TextFont *textfont ;    /* we use this to extract the current */
                                      /* workbench screen's font            */

	/* the menus */

extern struct Menu *menu ;

struct NewMenu rlnewmenu[] = {
	{ NM_TITLE, (STRPTR)"Project",0,0,0,0 },
	{   NM_ITEM, (STRPTR)"About",(STRPTR)"A",0,0,(APTR)"ABOUT" },
	{   NM_ITEM, (STRPTR)"Quit",(STRPTR)"Q",0,0,(APTR)"QUIT" },
	{ NM_TITLE, (STRPTR)"Paste Timing",0,0,0,0 },
	{   NM_ITEM, (STRPTR)"00/00 Seconds",(STRPTR)"0",CHECKIT|CHECKED,(~1),(APTR)"PT00" },
	{   NM_ITEM, (STRPTR)"10/50 Seconds",(STRPTR)"1",CHECKIT,(~2),(APTR)"PT10" },
	{   NM_ITEM, (STRPTR)"20/50 Seconds",(STRPTR)"2",CHECKIT,(~4),(APTR)"PT20" },
	{   NM_ITEM, (STRPTR)"30/50 Seconds",(STRPTR)"3",CHECKIT,(~8),(APTR)"PT30" },
	{   NM_ITEM, (STRPTR)"40/50 Seconds",(STRPTR)"4",CHECKIT,(~16),(APTR)"PT40" },
	{   NM_ITEM, (STRPTR)"50/50 Seconds",(STRPTR)"5",CHECKIT,(~32),(APTR)"PT50" },
	{ NM_TITLE, (STRPTR)"Settings",0,0,0,0 },
	{   NM_ITEM, (STRPTR)"Line Wrap",(STRPTR)"W",CHECKIT|CHECKED|MENUTOGGLE,0,(APTR)"LWRAP" },
	{   NM_ITEM, (STRPTR)"Jump Scroll",(STRPTR)"J",CHECKIT|CHECKED|MENUTOGGLE,0,(APTR)"JSC" },
	{ NM_TITLE, (STRPTR)"Display",0,0,0,0 },
	{   NM_ITEM, (STRPTR)"Reset Console",(STRPTR)"R",0,0,(APTR)"RESET" },
		/*** ALL ITEMS BELOW THIS POINT WILL BE NOT BE SEEN ON CUSTOM SCREENS */
	{   NM_ITEM, (STRPTR)"24 Rows x 80 Cols",(STRPTR)"M",0,0,(APTR)"MIN" },
	{   NM_ITEM, (STRPTR)"80 Columns",(STRPTR)"8",0,0,(APTR)"W80" },
	{ NM_END,NULL,NULL,0,0L,NULL }
	} ;

/****************** NOTE NOTE NOTE !!!!!!! **********************************
 * Currently, when the user asks for a custom screen we nuke all the window
 * sizing menus. V37.17+ did this by poking NM_END into the nm_Type field
 * of it's NewMenu structure (Can't do this on pure version!). Because of this
 * it is important that thought be given to how the menus are altered. 
 ****************************************************************************
a26 29
APTR vi ;   /* visualinfo ptr */
int menu_is_set = 0 ;	
	

/* =============================================================
 * console_char_ready()
 *
 * returns true if a keypress or intuition action has occurred,
 * and returns FALSE if not. Used in main even loop.
 * =============================================================
 */

LONG
console_char_ready( VOID )
{
	return( (LONG)CheckIO((struct IORequest *)cr)) ;
}

/* ============================================================= 
 * console_getchar()
 *
 * gets keypresses, intuition actions, etc. froom the console
 * device a character at a time. Multi-byte reads are not really
 * required here. While it might speed things up on one end, the
 * fact is that we have to parse the stream one-byte-at-a-time
 * anyway (in the main event loop)
 * =============================================================
 */

d28 1
a28 1
console_getchar( VOID )
d30 2
a31 1
	STATIC BYTE c;
d34 2
a35 1
	if(!CheckIO((struct IORequest *)cr))
d37 1
a37 1
		WaitIO((struct IORequest *)cr);
d40 6
a45 4
	rtn = c;
	cr->io_Command = CMD_READ;
	cr->io_Data    = (APTR)&c;
	cr->io_Length  = sizeof(c);
d47 1
a47 1
	SendIO((struct IORequest *)cr);
d52 2
a53 2
/* =============================================================
 * console_init()
d55 18
a72 79
 * initializes everything
 *
 * NEEDS TO BE COMPLETELY REDONE !!!
 * =============================================================
 */

LONG
console_init( struct RLGlobal *glob )
{
	unsigned max_w, max_h ;
    struct IBox box;
    int max_text_w ;
    int max_text_h ;
    struct DimensionInfo di ;
    struct Rectangle *rect ;
    struct IBox ibox ;
    ULONG vpmodeID ;
    ULONG ws_delta_x = 0L , ws_delta_y = 0L ;
    UWORD penarray = ~0 ;


#define DK(x) kprintf(x)

/* DK("doing lib bases\n") ;  */

	IntuitionBase = (struct IntuitionBase *)OpenLibrary("intuition.library", 36L) ;
	GfxBase       = (struct GfxBase *)OpenLibrary("graphics.library", 36L) ;
	DiskfontBase  = OpenLibrary("diskfont.library",  36L ) ;
	GadToolsBase  = OpenLibrary("gadtools.library",  36L ) ;
	
	if(!IntuitionBase || !GfxBase || !DiskfontBase || !GadToolsBase ) 
	{
		Write(Output(),"OpenLibrary Failure\n", NULL) ;
		Write(Output(),"This rlogin requires the 2.0 Operating System\n",46L) ;
		return( -1L ) ;
	}

	if( glob->rl_Unit == 100L )
	{
		glob->rl_Unit = 3L ;
	}

	crp = CreatePort(0L, 0) ;
	cwp = CreatePort(0L, 0) ;
	cr  = CreateStdIO(crp) ;
	cw  = CreateStdIO(cwp) ;
	strcpy(glob->rl_wtitle, "Rlogin:" ) ;
	strcat(glob->rl_wtitle, glob->rl_hostptr) ;
	nw.Title = glob->rl_wtitle ;

/*-----------------------------------------------------------------------
 * The way this works needs to be rethought !!!
 *
 * The user specified he wants a screen. Under 2.0 we can use the "Display
 * Database" to tell us about the current state of the user's setup. Most
 * importantly, we can see  what size he has set for the "viewable" area of
 * his monitor (overscan Prefs editor.)  As of 4-12-91 this worked like
 * this:
 *       ( o the custom screen is *always* opened full size. It's the )
 *       (   window that is really 'sized'                            )
 *
 *      1. If the user specifies a screen but does NOT specify a width
 *         and/or a height, the program will open the screen to either
 *         the size of the WB screen or the size of the 'overscan text'
 *         area, whichever is *smaller*.
 *      
 *      2. If the user specifies a screen and DOES specify a width and/or
 *         a height, the screen will be opened to either the size of the
 *         WorkBench screen or the dimensions that the user requested,
 *         whichever is smaller.
 *         
 *      3. The program will not allow you to request a window size smaller
 *         than what is needed for a 80 column by 25 line display (if
 *         indeed the display can even handle that large a display)
 *         ( this is not always true)
 *-----------------------------------------------------------------------
 */

	if( scr = (struct Screen *)LockPubScreen( "Workbench" ))
d74 1
a74 1
		if( glob->rl_UseScreen != 1L )
d76 1
a76 2
			if(((vi = (APTR)GetVisualInfo( scr, TAG_DONE )) == NULL) ||
			  ((menu = (struct Menu *)CreateMenus(rlnewmenu, TAG_DONE ))==NULL))
d78 1
a78 1
				if( vi )
d80 24
a103 2
					FreeVisualInfo( vi ) ;
					vi = NULL ;
d105 1
a105 303
				UnlockPubScreen( NULL, scr ) ;
				return(-1L) ;
			}
			
			if( !LayoutMenus( menu, vi, GTMN_NewLookMenus, TRUE,TAG_DONE))
			{
				FreeVisualInfo( vi ) ;
				vi = NULL ;
				UnlockPubScreen( NULL, scr ) ;
				return(-1L) ;
			}
			FreeVisualInfo( vi ) ;
			vi = NULL ;
		}

		max_h       = scr->Height ;
		max_w       = scr->Width ;
		textfont    = GfxBase->DefaultFont ;
		glob->rl_fonthigh    = (LONG)textfont->tf_YSize ;
		glob->rl_fontwide    = (LONG)textfont->tf_XSize ;
		min_wide    = ((80 * glob->rl_fontwide) + scr->WBorLeft + scr->WBorRight) ;
		min_high    = ((24 * glob->rl_fonthigh) + scr->WBorTop + scr->WBorBottom + scr->Font->ta_YSize + 1) ;
		box.Left    = box.Top = 0 ;   
		if((vpmodeID = GetDisplayDims( scr, &box ))) /* workbench display info */
		{
			rect = &di.TxtOScan ;
			box.Width  = max_text_w = (rect->MaxX - rect->MinX + 1) ;
			box.Height = max_text_h = (rect->MaxY - rect->MinY + 1) ;
			box.Left   = (scr->LeftEdge < 0) ? -scr->LeftEdge : 0 ;
			box.Top    = (scr->TopEdge < 0)  ? -scr->TopEdge : 0 ;
		}
		else
		{
			VPrintf("Can't get Display Info Data.\n", NULL) ;
			return( -1L ) ;
		} 
		UnlockPubScreen((BYTE *)NULL,  scr ) ;
		scr = NULL ;
	}
	else
	{
		VPrintf("Can't Lock Workbench screen\n", NULL) ;
		return( -1L ) ;
	}

	if( glob->rl_resize )
	{
		min_high += SIZEGADHEIGHT ;
	}

	if( min_wide > max_w ) 
	{
		min_wide = max_w ;           /* careful! */
	}

	if( min_high > max_h )
	{
		min_high = max_h ;
	}


/*-----------------------------------------------------------------------
 * *** IF IF IF IF IF IF IF *** 
 *
 * ... user specified a screen, Under 2.0 we can use the "Display
 * Database" to tell us about the current state of the user's setup. Most
 * importantly, we can see  what size he has set for the "viewable" area of
 * his monitor (overscan Prefs editor.)  As of 4-12-91 this worked like
 * this:
 *       ( o the custom screen is *always* opened full size. It's the )
 *       (   window that is really 'sized'                            )
 *       (  this needs to be fixed! )
 *
 *      1. If the user specifies a screen but does NOT specify a width
 *         and/or a height, the program will open the screen to either
 *         the size of the WB screen or the size of the 'overscan text'
 *         area, whichever is *smaller*.
 *      
 *      2. If the user specifies a screen and DOES specify a width and/or
 *         a height, the screen will be opened to either the size of the
 *         WorkBench screen or the dimensions that the user requested,
 *         whichever is smaller.
 *         
 *  *** 3. The program will not allow you to request a window size smaller
 *         than what is needed for a 80 column by 25 line display (if
 *         indeed the display can even handle that large a display)
 *
 *  *** The __PV version does allow this !!
 *-----------------------------------------------------------------------
 */         

	if (glob->rl_UseScreen == 1) 
	{
		DB("console: rl_UseScreen == 1\n") ;
		showtitle = 1 ;
		scrdef.Width  = bbwin.Width  = max_w ;   /* max_w */
		scrdef.Height = bbwin.Height = max_h ;   /* max_h */
		if( vpmodeID & A2024_MONITOR_ID)
		{
			scrdef.ViewModes = LACE|HIRES ;
		}
		else
		{
			scrdef.ViewModes = (max_w>=640 ? HIRES : 0) | (max_h>=300 ? LACE : 0) ;
		}
		scrdef.DefaultTitle = showtitle ? (UBYTE *)glob->rl_wtitle : NULL ;
		                                                                                                
/*		screentags[0].ti_Tag  = TAG_IGNORE ;  */
		screentags[0].ti_Tag  = SA_Pens ;
		screentags[0].ti_Data = (LONG)&penarray ;
		


		scrdef.Extension = &screentags[0] ;
		DB("Calling openscreen()\n") ;
		if(myscreen = OpenScreen((struct NewScreen *)&scrdef))
		{
			DB("Openscreen success\n") ;	
				/* custom screen display info */
				
			(VOID)GetDisplayDims( myscreen, &ibox ) ;
			DB("GetDisplayDims success\n") ;
			max_text_w  = ibox.Width ;  /* these are the visible display   */
			max_text_h  = ibox.Height ; /* width & height variables        */
			if((vi = (APTR)GetVisualInfo( myscreen, TAG_DONE )) == NULL)
			{
				return(-1L) ;
			}
			DB("GetVisualInfo success\n") ;	
			
				/* kill the 24x80 menu item */

			AlterMenu( "MIN", NM_END, 0, 0 ) ;
			DB("AlterMenu success\n") ;	

			menu = (struct Menu *)CreateMenus(rlnewmenu, GTMN_FrontPen,1,TAG_DONE ) ;
			if( ! menu )
			{
				return(-1L) ;
			}
			if( !LayoutMenus( menu, vi, GTMN_NewLookMenus, TRUE,TAG_DONE))
			{
				return(-1L) ;
			}
		}
		else
		{
			return( -1 ) ;
		}

		

		bbwin.Screen = myscreen ;  

		bbwin.Width  = (max_w > max_text_w) ? max_text_w : max_w ;
		bbwin.Height = (max_h > max_text_h) ? max_text_h : max_h ;

		/* this allows the user to specify a max window width even when on
		 * a custom screen.  This is because things like vi and such will
		 * freak if they see a column width that is too large. (2-14-90)
		 */
		
		if( glob->rl_Width )  /* user asked for a width */ 
		{
			if( glob->rl_Width >= max_w )        
			{                               
				bbwin.Width = max_w ;           
			}                               
			else if( glob->rl_Width <= min_wide )
			{                               
				bbwin.Width = min_wide ;        
			}                               
			else
			{                               
				bbwin.Width = glob->rl_Width ;      
			}                               
		}

		if( glob->rl_Height ) /* user asked for a height */               
		{     
			/* if __PV and glob->rl_Height ... */	   
			min_high    = ((5 * glob->rl_fonthigh) + myscreen->WBorTop + myscreen->WBorBottom + glob->rl_fonthigh + 1) ;
			if( glob->rl_Height >= max_h )        
			{                               
				bbwin.Height = max_h ;           
			}                               
			else if( glob->rl_Height <= min_high )
			{                               
				bbwin.Height = min_high ;        
			}                               
			else
			{                               
				bbwin.Height = glob->rl_Height ;      
			}       
			if( showtitle && ( bbwin.Height > (myscreen->Height- (myscreen->BarHeight - 6))))                        
			{
				bbwin.Height = myscreen->Height - (myscreen->BarHeight - 6 ) ;
			}
		}

/******************* OpenScreen() -should- go here *************************/

		DB("showtitle()\n") ;
		if( showtitle )
		{
			ShowTitle(myscreen,TRUE) ;
			bbwin.TopEdge = myscreen->BarHeight + 2 ;
			bbwin.Height -= myscreen->BarHeight + 2 ;
		}
		else
		{
			ShowTitle(myscreen, FALSE) ;
		}
		
		bbwin.Extension = &windowtags[0] ;

		bbwin.Flags |= SIMPLE_REFRESH ;   

		DB("calling openwindow()\n") ;
		win = OpenWindow((struct NewWindow *)&bbwin) ;

	} 
	else      /* else we're in a window on WBscreen */ 
	{         
		nw.Width = min_wide ;   /* default width */

		if( glob->rl_Width ) 
		{                    /* user asked for a width */
			if( glob->rl_Width >= max_w ) 
			{
				glob->rl_Width = max_w ;
			}
			else if( glob->rl_Width <= min_wide ) 
			{
				glob->rl_Width = min_wide ;
			}
			else
			{
				nw.Width = glob->rl_Width ;
			}
		}
		if( glob->rl_Left )    /* user wants a different X position */ 
		{
			if( glob->rl_Left + nw.Width <= max_w ) 
			{
				nw.LeftEdge = glob->rl_Left ;
			}
		}
		nw.Height = min_high ;       /* default height */
		if( glob->rl_Height )      /* user asked for a height */
		{
			if( glob->rl_Height >= max_h ) 
			{
				nw.Height = max_h ;
			}
			else if( glob->rl_Height > 200 ) 
			{
				nw.Height = glob->rl_Height ;
			}
			else if( glob->rl_Height < (3 * glob->rl_fonthigh)) 
			{
				nw.Height = (3 * glob->rl_fonthigh) ;
			}
		}

		if( glob->rl_Top )   /* user wants a different Y position */ 
		{
			if( glob->rl_Top + nw.Height <= max_h ) 
			{
				nw.TopEdge = glob->rl_Top ;
			}
		}

		if( nw.Height > max_h) 
		{
			nw.Height = max_h ;     /* necessary !! */
		}
		if( nw.Width  > max_w ) 
		{
			nw.Width = max_w ;    /* necessary !! */
		}
		
		if(glob->rl_resize) 
		{
			nw.Flags |= ( WINDOWSIZING|SIZEBBOTTOM ) ;
		}

		if( (glob->rl_Unit == 1L) || (glob->rl_Unit == 3L )) 
		{
			nw.Flags |= SIMPLE_REFRESH ;
		}

		nw.Extension = &windowtags[0] ;

		if( (win = OpenWindow((struct NewWindow *)&nw)) && (max_window_cols_user || max_window_rows_user))
		{
			if( max_window_cols_user )
			{
				ws_delta_x = (LONG)(min_wide + (glob->rl_fontwide * (max_window_cols_user - 80))) ;
			}
			if( max_window_rows_user )
			{
				ws_delta_y = (LONG)(min_high + (glob->rl_fonthigh * (max_window_rows_user - 24))) ;
d107 1
d109 8
a116 48
	}

	if(!cr || !cw || !cwp || !crp || !win) 
	{
		return( -1L ) ;
	}
	
	glob->rl_Window = win ;
	
	if( myscreen ) 
	{
		(VOID)GetDisplayDims( myscreen, &ibox ) ;
		glob->rl_Screen = myscreen ;
	}
	
 	SetMenuStrip( win, menu ) ;
	menu_is_set = 1 ;
 
	cons_kybd_sigF = 1L << crp->mp_SigBit;
	cw->io_Data    = (APTR)win;
	cw->io_Length  = sizeof(*win);

	if(OpenDevice("console.device", glob->rl_Unit, (struct IORequest *)cw, 0L)) 
	{
		return( -1L ) ;
	}

	conunit = (struct ConUnit *)cw->io_Unit ;

	if( glob->rl_UseScreen != 1L ) 
	{
		WindowLimits( win, (20L * glob->rl_fontwide), (5L * glob->rl_fonthigh), ws_delta_x, ws_delta_y) ;
	}

	console_is_open = 1L ;
	*cr = *cw;
	cr->io_Message.mn_ReplyPort = crp;
	cr->io_Message.mn_Node.ln_Type = NT_REPLYMSG;
	console_getchar();

	return( 0L ) ;
}

/* =============================================================
 * console_write()
 *
 * sends text to the window.
 * =============================================================
d119 2
a120 2
LONG
console_write(UBYTE *buf, LONG len)
d122 4
a125 36
	REGISTER UBYTE *src, *dest ;
	REGISTER LONG x, realcount ;
	REGISTER LONG doflash = 0L  ;
	UBYTE cwarray[88] ;

		/* break buf into small pieces */ 
	while ( len > 80L )       /* strip extra bells */
	{

		for( src = buf, dest = cwarray, doflash = realcount = x = 0L ; x < 80L ; src++, x++ ) 
		{
			*dest = *src ;
			if( *dest != 0x07 ) 
			{
				dest++ ;
				realcount++ ;
			}
			else 
			{
				doflash++ ;
			}
		}
		cw->io_Data    = (APTR)cwarray ;
		cw->io_Length  = realcount ;
		cw->io_Command = CMD_WRITE;
		DoIO((struct IORequest *)cw);
		buf += 80L ;
		len -= 80L ;
	}
	
	if(doflash) 
	{
		FlashBar() ;
	}

	if (len)         /* strip extra bells */
d127 2
a128 18

		for( src = buf, dest = cwarray, doflash = realcount = x = 0 ; x < len ; src++, x++ )
		{
			*dest = *src ;
			if( *dest != 0x07 ) 
			{
				dest++ ;
				realcount++ ;
			}
			else 
			{
				doflash++ ;
			}
		}
		cw->io_Data    = (APTR)cwarray ;
		cw->io_Length  = realcount ;
		cw->io_Command = CMD_WRITE ;
		DoIO((struct IORequest *)cw) ;
d130 69
a198 4
	
	if(doflash) 
	{
		FlashBar() ;
a199 1
	return( len ) ;
d203 1
a203 1
 * console_close()
d205 2
a206 1
 * this routine shuts down everything - releases resources, etc
d210 2
a211 187
LONG
console_close( VOID )
{
	if(cw) 
	{
		AbortIO((struct IORequest *)cw);
		WaitIO((struct IORequest *)cw);
	}

	if(cr) 
	{ 
		AbortIO((struct IORequest *)cr);
		WaitIO((struct IORequest *)cr);
	}

	if( menu_is_set )
	{
		ClearMenuStrip( win ) ;
		menu_is_set = 0L ;
	}

	if(console_is_open)
	{
		CloseDevice((struct IORequest *)cw);
		console_is_open = 0L ;
	}

	if(win)
	{
		CloseWindow(win);
		win = NULL;
	}

	if( vi != NULL )
	{
		FreeVisualInfo( vi ) ;
		vi = NULL ;
	}

	if(myscreen)
	{
		CloseScreen(myscreen);
		myscreen = NULL;
	}

	if(cw)
	{
		DeleteStdIO(cw);
		cw = NULL;
	}

	if(cr)
	{
		DeleteStdIO(cr);
		cr = NULL;
	}

	if(cwp)
	{
		DeletePort(cwp);
		cwp = NULL;
	}
    
	if(crp)
	{
		DeletePort(crp);
		crp = NULL;
	}

	if(GadToolsBase)
	{        
		FreeMenus( menu ) ;
		CloseLibrary(GadToolsBase) ;
		GadToolsBase = NULL ;  
	}

	if(DiskfontBase)
	{
		CloseLibrary(DiskfontBase) ;
		DiskfontBase = NULL ; 
	}

	if(IntuitionBase)
	{
		CloseLibrary((struct Library *)IntuitionBase);
		IntuitionBase = NULL;
	}

	if(GfxBase) 
	{
		CloseLibrary((struct Library *)GfxBase);
		GfxBase = NULL ;
	}

	return( 0L ) ;
}

/* ===================================================================
 * This function calculates the window size in pixels as well as the  
 * values for rows and columns as calculated from the FONT being used 
 * Returns the values in place !  You can pass a NULL value in any/all
 * of the 'width, height, rows, cols' arguments and that arg will not
 * be processed.
 * ===================================================================
 */
 
VOID
console_get_window_sizes(int *width, int *height, int *cols, int *rows,  \
                           	LONG fontwidth, LONG fontheight )
{
	if(width)
	{
		*width = win->Width;
	}

	if(height)
	{
		*height = win->Height;
	}

/* #define OLDSTYLE 1 */
#ifdef OLDSTYLE /* <= 36.14 */
	if(cols)
	{
		*cols = (int)((((win->Width) - (win->BorderLeft *2)) / (int)fontwidth) ) ;     
	}

	if(rows)
	{
		*rows = (int)((win->Height) - ((int)(win->BorderTop + win->BorderBottom))) ;
		*rows = *rows / (int)fontheight ;
	}
#else

	if( cols )
	{
		*cols = (int)conunit->cu_XMax + 1 ;
	}
	if( rows )
	{
		*rows = (int)conunit->cu_YMax + 1 ;
	}

#endif
	
}

/* ===================================================================
 * This function calculates the position and size of the screen's 
 * visible area (the area between the bezels. This is what the user sets
 * up with the OverScan Preferences Editor.
 *
 * We use this only under 2.0 !!
 * ===================================================================
 */

ULONG 
GetDisplayDims( struct Screen *scrn, struct IBox *box )
{
	ULONG vpmid ;
	struct DimensionInfo di ;
	struct DisplayInfo displayinfo ;
	REGISTER struct Rectangle *rect ;

    box->Left = box->Top = 0 ;
 	    
    if ((vpmid = GetVPModeID( &scrn->ViewPort )) != INVALID_ID)
    {
        GetDisplayInfoData( 0, (UBYTE *)&di, sizeof(di), DTAG_DIMS, vpmid ) ;
        rect = &di.TxtOScan ;
        box->Width  = rect->MaxX - rect->MinX + 1 ;
        box->Height = rect->MaxY - rect->MinY + 1 ;
        box->Left   = scrn->LeftEdge < 0 ? -scrn->LeftEdge : 0 ;
        box->Top    = scrn->TopEdge < 0 ? -scrn->TopEdge : 0 ;
		GetDisplayInfoData(0, (UBYTE *)&displayinfo, sizeof(displayinfo), DTAG_DISP, vpmid ) ;
    }
    return( vpmid ) ;
}

/***********************************************************************/
/* AlterMenu                                                           */
/*                                                                     */
/* 'type' argument must be either valid or "NO_TYPE" (127) !!!!!!!     */
/***********************************************************************/

VOID
AlterMenu( APTR userdata, UBYTE type, UWORD flags_on, UWORD flags_off )
d213 1
a213 1
	struct NewMenu *nm = &rlnewmenu[0] ;
d215 1
a215 26
	if( nm && (menu_is_set == 0) )
	{
		if( userdata )
		{
			while( nm->nm_Type != NM_END )
			{
				if( nm->nm_UserData && (strcmp( nm->nm_UserData, userdata ) ==0))
				{
					if( type != NO_TYPE )
					{
						nm->nm_Type = type ;
					}
					if( flags_on )
					{
						nm->nm_Flags |= flags_on ;
					}
					if( flags_off )
					{
						nm->nm_Flags &= ~flags_off ;
					}
					break ;
				}
				nm++ ;
			}
		}
	}
d218 1
a218 3

/****** end *****/
                
@


37.22
log
@Binary 37.24

Fixed bug where console cut/paste didn't work when rlogin
was opened on a custom screen.

Added SA_Interleaved=TRUE tag to OpenScreen() call.
@
text
@d4 1
a4 1
 * $Locker:  $
d6 1
a6 1
 * $Id: console.c,v 37.21 92/09/11 16:26:33 bj Exp $
d8 1
a8 1
 * $Revision: 37.21 $
d11 8
d106 1
a106 1
 *  $Header: AS225:src/c/rlogin/RCS/console.c,v 37.21 92/09/11 16:26:33 bj Exp $
d114 1
a114 1
 #define DEBUG 1 
d174 1
a174 1
BYTE wtitle[128] = "Rlogin:" ;
d350 3
a352 2
	strcat(wtitle, glob->rl_hostptr) ;
	nw.Title = wtitle ;
a484 1
	DB("everything is working\n") ;
d499 1
a499 1
		scrdef.DefaultTitle = showtitle ? (UBYTE *)wtitle : NULL ;
d706 2
d711 1
@


37.21
log
@Changes in rlogin.c. New revision.
@
text
@d4 1
a4 1
 * $Locker: bj $
d6 1
a6 1
 * $Id: console.c,v 37.20 92/08/11 11:19:13 bj Exp Locker: bj $
d8 2
a9 2
 * $Revision: 37.20 $
 *
d11 3
d98 1
a98 1
 *  $Header: AS225:src/c/rlogin/RCS/console.c,v 37.20 92/08/11 11:19:13 bj Exp Locker: bj $
d106 1
a106 1
/* #define DEBUG 1 */
d476 1
d492 1
a492 1
		
d497 2
d503 1
a503 1
			
d507 1
d514 1
d519 1
d536 1
d588 1
d602 3
d1032 1
@


37.20
log
@1. "include/proto/*.h" replaced by "include:clib/*.h" 
2. Menus changed to (a) remove spaces (b) change titles.
3. menufont_attr variable removed (used in LayoutMenus())
4. Both NewWindow and NewScreen structs changed to ExtNew*
   to support newlook menus and title bars.
   (custom screen code really screwed and has needed to
    be fixed forever.  Someday soon ... )
5. taglists for both ExtNew*
@
text
@d4 1
a4 1
 * $Locker:  $
d6 1
a6 1
 * $Id: console.c,v 37.19 92/08/08 19:44:18 bj Exp $
d8 1
a8 1
 * $Revision: 37.19 $
d11 10
d95 1
a95 1
 *  $Header: AS225:src/c/rlogin/RCS/console.c,v 37.19 92/08/08 19:44:18 bj Exp $
@


37.19
log
@Fixed enforcer hits in AlterMenu() (strcmp(NULL, "string")).

37.18 was an internal version. AS225 R2
@
text
@d6 1
a6 1
 * $Id: console.c,v 37.17 92/05/27 15:52:37 bj Exp $
d8 1
a8 1
 * $Revision: 37.17 $
d11 5
d85 1
a85 1
 *  $Header: AS225:src/c/rlogin/RCS/console.c,v 37.17 92/05/27 15:52:37 bj Exp $
d113 21
a133 1
#include <proto/all.h>
d199 1
a199 1
struct TextAttr *menufont_attr ;
d201 15
a215 15
	{ NM_TITLE, (STRPTR)" Project ",0,0,0,0 },
	{   NM_ITEM, (STRPTR)" About ",(STRPTR)"A",0,0,(APTR)"ABOUT" },
	{   NM_ITEM, (STRPTR)" Quit ",(STRPTR)"Q",0,0,(APTR)"QUIT" },
	{ NM_TITLE, (STRPTR)" Paste Timing ",0,0,0,0 },
	{   NM_ITEM, (STRPTR)" 00/00 Seconds ",(STRPTR)"0",CHECKIT|CHECKED,(~1),(APTR)"PT00" },
	{   NM_ITEM, (STRPTR)" 10/50 Seconds ",(STRPTR)"1",CHECKIT,(~2),(APTR)"PT10" },
	{   NM_ITEM, (STRPTR)" 20/50 Seconds ",(STRPTR)"2",CHECKIT,(~4),(APTR)"PT20" },
	{   NM_ITEM, (STRPTR)" 30/50 Seconds ",(STRPTR)"3",CHECKIT,(~8),(APTR)"PT30" },
	{   NM_ITEM, (STRPTR)" 40/50 Seconds ",(STRPTR)"4",CHECKIT,(~16),(APTR)"PT40" },
	{   NM_ITEM, (STRPTR)" 50/50 Seconds ",(STRPTR)"5",CHECKIT,(~32),(APTR)"PT50" },
	{ NM_TITLE, (STRPTR)" Settings ",0,0,0,0 },
	{   NM_ITEM, (STRPTR)" Line Wrap   ",(STRPTR)"W",CHECKIT|CHECKED|MENUTOGGLE,0,(APTR)"LWRAP" },
	{   NM_ITEM, (STRPTR)" Jump Scroll ",(STRPTR)"J",CHECKIT|CHECKED|MENUTOGGLE,0,(APTR)"JSC" },
	{ NM_TITLE, (STRPTR)" Tools ",0,0,0,0 },
	{   NM_ITEM, (STRPTR)" Reset Console ",(STRPTR)"R",0,0,(APTR)"RESET" },
d217 2
a218 2
	{   NM_ITEM, (STRPTR)" 24x80 Window  ",(STRPTR)"M",0,0,(APTR)"MIN" },
	{   NM_ITEM, (STRPTR)" - x80 Window  ",(STRPTR)"8",0,0,(APTR)"W80" },
d224 1
a224 1
 * sizing menus. V37.17 did this by poking NM_END into the nm_Type field
d301 1
a374 1
			menufont_attr = scr->Font ;
d376 1
a376 1
			if( !LayoutMenus( menu, vi, GTMN_TextAttr, menufont_attr, TAG_DONE))
d479 5
a496 1
			menufont_attr = myscreen->Font ;
d507 1
a507 1
			if( !LayoutMenus( menu, vi, GTMN_TextAttr, menufont_attr, TAG_DONE))
d566 1
a566 1
/******************* OpenScreen() should go here *************************/
d579 1
d581 1
a581 1
		win = OpenWindow(&bbwin) ;
d654 3
a656 1
		if( (win = OpenWindow(&nw)) && (max_window_cols_user || max_window_rows_user))
@


37.17
log
@No changes from 37.16. Revision bump.
@
text
@d4 1
a4 1
 * $Locker: bj $
d6 1
a6 1
 * $Id: console.c,v 37.16 92/05/27 15:38:23 bj Exp Locker: bj $
d8 1
a8 1
 * $Revision: 37.16 $
d11 3
d80 1
a80 1
 *  $Header: AS225:src/c/rlogin/RCS/console.c,v 37.16 92/05/27 15:38:23 bj Exp Locker: bj $
d156 1
d162 6
d191 1
d193 2
a194 1
	{ NM_END,0,0,0,0,0 }
d198 4
a201 3
 * The 24x80 window option MUST be last in the menu list !!!!!  This is because
 * we currently delete this option from the menus if the user is on a custom
 * screen of his own request.  
a204 1

d275 2
a276 1
    struct NewMenu *nm ;
d440 1
d453 3
a455 1
		if(!(myscreen = OpenScreen((struct NewScreen *)&scrdef)))
d457 1
a457 4
			return( -1L ) ;
		}
		else
		{
d459 1
d470 3
a472 9
			for( nm = &rlnewmenu[0] ; nm->nm_Type != NM_END ; nm++ )
			{
				if(strcmp(nm->nm_UserData, "MIN") == 0)
				{
					nm->nm_Type = NM_END ;
					break ;
				}
			}
			
d483 4
a492 1
		
a514 1
	
d537 1
d624 11
a634 2
		win = OpenWindow(&nw);
		
d663 1
a663 1
		WindowLimits( win, (20L * glob->rl_fontwide), (5L * glob->rl_fonthigh), -1L, -1L) ;
d935 38
@


37.16
log
@Mostly detail changes to support changes in rlogin.c v37.16
@
text
@d4 1
a4 1
 * $Locker:  $
d6 1
a6 1
 * $Id: console.c,v 1.17 91/08/07 15:20:09 bj Exp $
d8 1
a8 1
 * $Revision: 1.17 $
d11 3
d77 1
a77 1
 *  $Header: HOG:Other/inet/src/c/rlogin/RCS/console.c,v 1.17 91/08/07 15:20:09 bj Exp $
@


1.17
log
@details.
@
text
@d4 1
a4 1
 * $Locker: bj $
d6 1
a6 1
 * $Id: console.c,v 1.16 91/08/06 13:26:20 bj Exp Locker: bj $
d8 1
a8 1
 * $Revision: 1.16 $
d11 3
d74 1
a74 1
 *  $Header: HOG:Other/inet/src/c/rlogin/RCS/console.c,v 1.16 91/08/06 13:26:20 bj Exp Locker: bj $
d79 3
d85 1
a85 2
#define DB(x)  kprintf((x)) ; \
                Delay(10L) 
d100 2
a101 2

#ifdef LATTICE
a102 2
#endif

a106 1
#define OUTPUT(x)  VPrintf((x),NULL)
a107 1

d122 1
a122 3
#define SIZEGADHEIGHT (10 + 1)

BYTE wtitle[128] = "rlogin:" ;
d124 1
d130 1
d132 1
d134 1
a148 1
int barfonthigh ;
d150 1
a154 29
ULONG GetDisplayDims( struct Screen *scrn, struct IBox *box ) ;

		/* NewWindow used for wbscreen rlogin */
STATIC struct NewWindow nw = {
	0, 0, 640, 200, -1, -1, 
	0L,                                            /* IDCMP */
	WINDOWDRAG|WINDOWDEPTH|ACTIVATE|WINDOWCLOSE,   /* flags */
	0, 0, NULL, 0, 0, 640, 100, -1, -1, WBENCHSCREEN
	};

		/* this is the screen used if screen mode is selected */
STATIC struct NewScreen scrdef = { 0,0,0,0,
	2,	/* bit planes */
	0,1,	/* pens */
	0,CUSTOMSCREEN,NULL,NULL,NULL,NULL
	};


		/* NewWindow used for custom screen rlogin */
STATIC struct NewWindow bbwin = { 0,0,0,0,
	1,0,
	NULL,
	ACTIVATE | NOCAREREFRESH | BORDERLESS | BACKDROP,
	NULL,		/* pointer to first gadget */
	NULL, NULL, NULL, NULL, 0,0,-1,-1,
	CUSTOMSCREEN
	};


d163 4
a166 4
	{ NM_TITLE, (STRPTR)" PROJECT ",0,0,0,0 },
	{   NM_ITEM, (STRPTR)" ABOUT ",0,0,0,(APTR)"ABOUT" },
	{   NM_ITEM, (STRPTR)" QUIT ",(STRPTR)"Q",0,0,(APTR)"QUIT" },
	{ NM_TITLE, (STRPTR)" PASTE TIMING ",0,0,0,0 },
d173 6
a178 2
	{ NM_TITLE, (STRPTR)" RESET ",0,0,0,0 },
	{   NM_ITEM, (STRPTR)" Reset ",(STRPTR)"R",0,0,(APTR)"RESET" },
d182 9
a190 1
extern APTR vi ;   /* visualinfo ptr */
d195 5
d205 1
a205 1
	return( (CheckIO((struct IORequest *)cr)) ? 1L : 0L ) ;
d208 10
a217 1
/* ============================================================= */
d240 8
a247 1
	/* ============================================================= */
d254 2
a255 2
    int max_text_w = 640 ;
    int max_text_h = 200 ;
d260 1
d266 1
a266 1
	IntuitionBase = OpenLibrary("intuition.library", 36L) ;
a350 1
		barfonthigh = (int)scr->Font->ta_YSize ;
d352 1
a352 1
		min_high    = ((24 * glob->rl_fonthigh) + scr->WBorTop + scr->WBorBottom + glob->rl_fonthigh + 1) ;
d452 10
d636 2
d653 4
d664 1
a664 1
	REGISTER LONG doflash = 0L ;
d670 2
a671 1
		for( src = buf, dest = cwarray, realcount = x = 0L ; x < 80L ; src++, x++ ) 
a694 1
		doflash = 0L ;
d699 2
a700 1
		for( src = buf, dest = cwarray, realcount = x = 0 ; x < len ; src++, x++ )
a721 1
		doflash = 0L ;
d727 4
a732 3

/* #define DEBUG 1 */

d853 2
d865 13
d892 1
a892 1
	ULONG vpmid = 0L ;
d901 1
a901 1
        GetDisplayInfoData( 0, &di, sizeof(di), DTAG_DIMS, vpmid ) ;
d907 1
a907 1
		GetDisplayInfoData(0, &displayinfo, sizeof(displayinfo), DTAG_DISP, vpmid ) ;
@


1.16
log
@Changed to the global variabl structure (glob).
Added the About() function (finally!)
@
text
@d4 1
a4 1
 * $Locker:  $
d6 1
a6 1
 * $Id: console.c,v 1.14 91/06/19 12:36:47 bj Exp $
d8 1
a8 1
 * $Revision: 1.14 $
d11 4
d71 1
a71 1
 *  $Header: HOG:Other/inet/src/c/rlogin/RCS/console.c,v 1.14 91/06/19 12:36:47 bj Exp $
@


1.15
log
@no change.
@
text
@d4 1
a4 1
 * $Locker: bj $
d6 1
a6 1
 * $Id: console.c,v 1.14 91/06/19 12:36:47 bj Exp Locker: bj $
d67 1
a67 1
 *  $Header: HOG:Other/inet/src/c/rlogin/RCS/console.c,v 1.14 91/06/19 12:36:47 bj Exp Locker: bj $
d74 7
d96 4
a120 3
extern int user_width, user_height ;
extern int top_x, top_y ;

d132 1
d134 1
a134 1
STATIC int console_is_open;
d138 1
a138 1
STATIC struct Screen   *scr = NULL ;
a139 10
extern int  fontwide ;   /* needed to pass proper display size params to host */
extern int  fonthigh ;   /* via 'send_window_size()' call in rlogin.c         */
extern int  resize ;

extern int useborder ;   /* user want border around screen backdrop win?      */

extern LONG conunit ;

int w80      = 640 ;     /* this variable hold the pixel width of a window */
                         /* that holds exactly 80 columns of text */
d148 1
a148 1
ULONG GetDisplayDims( struct Screen *scrn, struct IBox *box, ULONG *dp ) ;
d160 1
a160 1
	1,	/* bit planes */
d186 1
a186 1
	{   NM_ITEM, (STRPTR)" ABOUT ",0,NM_ITEMDISABLED,0,(APTR)"ABOUT" },
d200 1
a200 1
extern APTR *vi ;   /* visualinfo ptr */
d207 2
a208 2
int
console_char_ready( void )
d210 1
a210 1
	return( (CheckIO((struct IORequest *)cr)) ? 1 : 0 ) ;
d216 1
a216 1
console_getchar( void )
d238 2
a239 2
int
console_init( UBYTE *title, int screen, struct RLGlobal *glob )
a246 1
	ULONG displayproperties = NULL ;
d250 4
d263 1
a263 2
		console_close( );
		return( -1 ) ;
d266 1
a266 1
	if( conunit == 100L )
d268 1
a268 1
		conunit = 3L ;
d275 1
a275 1
	strcat(wtitle, title) ;
d308 1
a308 1
		if( screen != 1 )
d313 5
d319 1
a319 2
				console_close( ) ;
				return(-1) ;
d325 2
d328 1
a328 2
				console_close(  ) ;
				return(-1) ;
d330 2
a333 1

d337 2
a338 2
		fonthigh    = textfont->tf_YSize ;
		fontwide    = textfont->tf_XSize ;
d340 2
a341 2
		min_wide    = ((80 * fontwide) + scr->WBorLeft + scr->WBorRight) ;
		min_high    = ((24 * fonthigh) + scr->WBorTop + scr->WBorBottom + fonthigh + 1) ;
d343 1
a343 1
		if((vpmodeID = GetDisplayDims( scr, &box, &displayproperties ))) /* workbench display info */
d354 1
a354 2
			console_close(  );
			return( -1 ) ;
d357 1
d362 1
a362 2
		console_close(  ) ;
		return( -1 ) ;
d365 1
a365 5
    w80 = min_wide ;  /* w80 now holds 80 col window width */

	scr = NULL ;    /* we use this again so clear it! <<<<<<<<<<<<<<<<<<<<<<< */

	if( resize )
d380 1
d411 1
a411 1
	if (screen == 1) 
d415 1
a415 1
		scrdef.Height = bbwin.Height = max_h ;      /* max_h */
a417 1
			OUTPUT("A2024: using NO viewmodes\n") ;
d425 1
a425 1
		if(!(scr = OpenScreen((struct NewScreen *)&scrdef)))
d427 1
a427 2
			console_close( ) ; 
			return( -1 ) ;
d432 1
a432 1
			(void)GetDisplayDims( scr, &ibox, &displayproperties ) ;
d435 1
a435 1
			if((vi = (APTR)GetVisualInfo( scr, TAG_DONE )) == NULL)
d437 1
a437 2
				console_close(  ) ;
				return(-1) ;
d439 1
a439 1
			menufont_attr = scr->Font ;
d444 1
a444 2
				console_close(  ) ;
				return(-1) ;
d448 1
a448 2
				console_close( ) ;
				return(-1) ;
d452 2
a453 1
		bbwin.Screen = scr ;  
d458 1
d464 3
a466 3
		if( user_width )  /* user asked for a width */ 
		{       
			if( user_width >= max_w )        
d470 1
a470 1
			else if( user_width <= min_wide )
d476 1
a476 1
				bbwin.Width = user_width ;      
d480 2
a481 1
		if( user_height ) /* user asked for a height */               
d483 3
a485 3
			/* if __PV and user_height ... */	   
			min_high    = ((5 * fonthigh) + scr->WBorTop + scr->WBorBottom + fonthigh + 1) ;
			if( user_height >= max_h )        
d489 1
a489 1
			else if( user_height <= min_high )
d495 1
a495 1
				bbwin.Height = user_height ;      
d497 1
a497 1
			if( showtitle && ( bbwin.Height > (scr->Height- (scr->BarHeight - 6))))                        
d499 1
a499 1
				bbwin.Height = scr->Height - (scr->BarHeight - 6 ) ;
d503 1
d506 3
a508 3
			ShowTitle(scr,TRUE) ;
			bbwin.TopEdge = scr->BarHeight + 2 ;
			bbwin.Height -= scr->BarHeight + 2 ;
d512 1
a512 1
			ShowTitle(scr, FALSE) ;
a514 4
		if( useborder )
		{
			bbwin.Flags &= ~BORDERLESS ;
		}
d517 1
d523 1
a523 1
		if( user_width ) 
d525 1
a525 1
			if( user_width >= max_w ) 
d527 1
a527 1
				nw.Width = max_w ;
d529 1
a529 1
			else if( user_width <= min_wide ) 
d531 1
a531 1
				nw.Width = min_wide ;
d533 1
a533 1
			else 
d535 1
a535 1
				nw.Width = user_width ;
d538 1
a538 1
		if( top_x )    /* user wants a different X position */ 
d540 1
a540 1
			if( top_x + nw.Width <= max_w ) 
d542 1
a542 1
				nw.LeftEdge = top_x ;
d546 1
a546 2

		if( user_height )      /* user asked for a height */
d548 1
a548 1
			if( user_height >= max_h ) 
d552 1
a552 1
			else if( user_height > 200 ) 
d554 1
a554 1
				nw.Height = user_height ;
d556 1
a556 1
			else if( user_height < (3 * fonthigh)) 
d558 1
a558 1
				nw.Height = (3 * fonthigh) ;
d562 1
a562 1
		if( top_y )   /* user wants a different Y position */ 
d564 1
a564 1
			if( top_y + nw.Height <= max_h ) 
d566 1
a566 1
				nw.TopEdge = top_y ;
d576 1
a576 1
			nw.Height = max_w ;    /* necessary !! */
d579 1
a579 1
		if(resize) 
d584 1
a584 1
		if( (conunit == 1L) || (conunit == 3L )) 
d590 1
d595 1
a595 2
		console_close( );
		return( -1 ) ;
d597 2
a598 1
	if( scr ) 
d600 1
a600 1
		(void)GetDisplayDims( scr, &ibox, &displayproperties ) ;
d610 1
a610 1
	if(OpenDevice("console.device", conunit, (struct IORequest *)cw, 0L)) 
d612 1
a612 2
		console_close( );
		return( -1 ) ;
d614 2
a615 2

	if( screen != 1 ) 
d617 1
a617 1
		WindowLimits( win, (LONG)(20 * fontwide), (LONG)(5 * fonthigh), -1L, -1L) ;
d620 1
a620 1
	console_is_open++;
d626 1
a626 1
	return( 0 ) ;
d632 2
a633 2
int 
console_write(UBYTE *buf, int len)
d636 2
a637 2
	REGISTER int x, realcount ;
	REGISTER int doflash = 0 ;
d641 1
a641 1
	while ( len > 80 )       /* strip extra bells */
d643 1
a643 1
		for( src = buf, dest = cwarray, realcount = x = 0 ; x < 80 ; src++, x++ ) 
d656 2
a657 2
		cw->io_Data = (APTR)cwarray ;
		cw->io_Length = realcount ;
d660 2
a661 2
		buf += 80;
		len -= 80;
d667 1
a667 1
		doflash = 0 ;
d685 2
a686 2
		cw->io_Data = (APTR)cwarray ;
		cw->io_Length = realcount ;
d694 1
a694 1
		doflash = 0 ;
d702 5
a706 2
int
console_close( void )
d723 1
a723 1
		menu_is_set = 0 ;
d729 1
a729 1
		console_is_open = 0;
d738 7
a744 1
	if(scr)
d746 2
a747 2
		CloseScreen(scr);
		scr=NULL;
d775 1
a775 1
	{
a776 1
		FreeVisualInfo( vi ) ;
d778 1
a778 1
		GadToolsBase = NULL ;
d784 1
a784 1
		DiskfontBase = NULL ;
a786 1

d799 1
a799 1
	return( 0 ) ;
d811 1
a811 1
void
d813 1
a813 1
                           	int fontwidth, int fontheight )
d827 1
a827 1
		*cols = (int)((((win->Width) - (win->BorderLeft *2)) / fontwidth) ) ;     
d847 1
a847 1
GetDisplayDims( struct Screen *scrn, struct IBox *box, ULONG *propflags )
a864 1
		*propflags = (ULONG)displayinfo.PropertyFlags ;
@


1.14
log
@Conclip support. Font bug fixed. Assorted details.
This is now 2.0x ONLY!
@
text
@d4 1
a4 1
 * $Locker:  $
d6 1
a6 1
 * $Id: console.c,v 1.13 91/04/24 15:36:34 bj Exp $
d8 1
a8 1
 * $Revision: 1.13 $
d11 4
d67 1
a67 1
 *  $Header: HOG:Other/inet/src/c/rlogin/RCS/console.c,v 1.13 91/04/24 15:36:34 bj Exp $
@


1.13
log
@Fixes and additions to give rlogin complete PAL mode compatibility
under 2.0. Does DisplayInfoData now to see what the text_oscan
values are.
@
text
@d6 1
a6 1
 * $Id: console.c,v 1.12 91/04/12 14:13:56 bj Exp $
d8 1
a8 1
 * $Revision: 1.12 $
d11 5
d22 1
a22 1
 * 
d63 1
a63 1
 *  $Header: HOG:Other/inet/src/c/rlogin/RCS/console.c,v 1.12 91/04/12 14:13:56 bj Exp $
d79 1
d82 1
a82 2
#include <proto/intuition.h>
#include <proto/exec.h>
d85 3
d104 1
a104 1
char wtitle[128] = "rlogin:" ;
a107 1
extern BOOL V20 ;
d118 2
d121 1
a121 1
static int    console_is_open;
d123 3
a125 3
static struct MsgPort  *crp, *cwp;
static struct IOStdReq *cw,  *cr;
static struct Screen   *scr = NULL ;
a129 1
extern long conunit ;
d131 6
d143 1
a143 1
struct Library *lptr ;
d148 1
a148 1
static struct NewWindow nw = {
d156 1
a156 1
static struct NewScreen scrdef = { 0,0,0,0,
d158 1
a158 1
	1,0,	/* pens */
d164 1
a164 1
static struct NewWindow bbwin = { 0,0,0,0,
d174 1
a174 1
static struct TextFont *textfont ;    /* we use this to extract the current */
d177 24
d210 1
a210 2
/* =============================================================
 */
d212 1
a212 1
char
d215 2
a216 2
	static char c;
	char rtn;
d233 1
a233 2
/* =============================================================
 */
d236 1
a236 1
console_init( UBYTE *title, int screen )
a238 2
	struct Screen wbscr ;
/*    ULONG vpmid;  */
d246 1
d248 6
a253 3
	IntuitionBase = OpenLibrary("intuition.library", 0L) ;
	GfxBase = (struct GfxBase *)OpenLibrary("graphics.library",0L) ;
	if(!IntuitionBase || !GfxBase) 
d255 3
a257 1
		console_close();
d260 2
a261 7
		
	lptr = (struct Library *)GfxBase ;
	if( lptr->lib_Version < 36 )
	{
		conunit = 0L ;
	} 
	else
d263 1
a263 5
		V20 = TRUE ;
		if( conunit == 100L )
		{
			conunit = 3L ;
		}
d268 2
a269 2
	cr = CreateStdIO(crp) ;
	cw = CreateStdIO(cwp) ;
d274 2
d297 1
d299 1
a299 1
 */         
d301 1
a301 1
	if( V20 && ((scr = (struct Screen *)LockPubScreen( "Workbench" )) != NULL))
d303 20
d331 2
a332 3

		box.Left = box.Top = 0 ;   
		if(GetDisplayDims( scr, &box, &displayproperties )) /* workbench display info */ 
d343 1
a343 1
			console_close();
d346 1
a346 1
		UnlockPubScreen( (char *)NULL,  scr ) ;
d350 3
a352 9
		GetScreenData((char *)&wbscr,sizeof(wbscr),WBENCHSCREEN,NULL) ; 
		max_h       = wbscr.Height ;
		max_w       = wbscr.Width ;
		textfont    = wbscr.RastPort.Font ;
		fonthigh    = textfont->tf_YSize ;
		fontwide    = textfont->tf_XSize ;
		barfonthigh = (int)wbscr.Font->ta_YSize ;
		min_wide    = ((80 * fontwide) + wbscr.WBorLeft + wbscr.WBorRight) ;
		min_high    = ((24 * fonthigh) + wbscr.WBorTop + wbscr.WBorBottom + barfonthigh + 1) ;
d355 2
d384 1
d396 1
a396 1
 *      3. The program will not allow you to request a window size smaller
d399 2
a403 1

d406 9
a414 5
		conunit = 0L ;
		scrdef.Width = bbwin.Width = max_w ; 
		scrdef.Height = bbwin.Height = max_h ;
		scrdef.ViewModes = (max_w>=640 ? HIRES : 0) | (max_h>=300 ? LACE : 0) ;
		if(!(scr = (struct Screen *)OpenScreen((struct NewScreen *)&scrdef)))
d416 6
a421 1
			console_close() ; 
d430 18
a449 1
		ShowTitle(scr,(BOOL)0) ;
d460 2
a461 2
		if( user_width )
		{    /* user asked for a width */    
d476 4
a479 2
		if( user_height )                
		{    /* user asked for a width */    
d491 21
a511 1
			}                               
d513 2
a514 1
	win = OpenWindow(&bbwin) ;
d516 2
a517 2
	else 
	{         /* else we're in a window on WBscreen */
d519 1
d543 1
d568 8
a575 2
		if( nw.Height > max_h) nw.Height = max_h ;     /* necessary !! */
		if( nw.Width  > max_w ) nw.Height = max_w ;    /* necessary !! */
d582 1
a582 1
		if( ((conunit == 1L) || (conunit == 3L ))  && screen != 1) 
d592 1
a592 1
		console_close();
a597 23
#ifdef DEBUG
		printf("&displayproperties = %08lx\n", (long)&displayproperties) ;
		printf("displayproperties  = %08lx\n", displayproperties) ;

		if( displayproperties & DIPF_IS_LACE )
			VPrintf("Display is Interlaced\n", NULL ) ;
		if( displayproperties & DIPF_IS_ECS)
			VPrintf("Display is using ECS chips\n", NULL ) ;
		if( displayproperties & DIPF_IS_PAL )
			VPrintf("Display is in PAL mode\n", NULL ) ;
		if( displayproperties & DIPF_IS_WB )
			VPrintf("Display is workbench\n", NULL ) ;
		if( displayproperties & DIPF_IS_DRAGGABLE )
			VPrintf("Display is draggable\n", NULL ) ;
		if( displayproperties & DIPF_IS_PANELLED )
			VPrintf("Display is Panelled\n", NULL ) ;

		printf("screen->Width  = %ld\n", scr->Width ) ;
		printf("screen->Height = %ld\n", scr->Height ) ;
		printf("win->Width     = %ld\n", win->Width ) ;
		printf("win->Height    = %ld\n", win->Height ) ;
		printf("fontwide       = %ld\n", (long)fontwide) ;
#endif DEBUG
d600 2
d604 2
a605 2
	cw->io_Data = (APTR)win;
	cw->io_Length = sizeof(*win);
d609 1
a609 1
		console_close();
d613 1
a613 1
	if( conunit != 0L ) 
d615 1
a615 1
		WindowLimits( win, (long)(20 * fontwide), (long)(5 * fonthigh), -1L, -1L) ;
d631 1
a631 1
console_write(unsigned char *buf, int len)
d633 4
a636 4
	register unsigned char *src, *dest ;
	register int x, realcount ;
	register int doflash = 0 ;
	unsigned char cwarray[88] ;
d715 6
d763 15
d843 1
a843 1
	register struct Rectangle *rect ;
d861 3
@


1.12
log
@Added code to handle overscanned screens under 2.0. Bug #B13712. 
The window on a custom screen opens to the max of the oscan_txt
as set by the overscan preferences. User can override with the
-h and -w flags out to a max of the screen size. Default is
oscan_text.

@
text
@d2 1
a2 1
 * console.c  for rlogin   Lattice 5.05
d6 1
a6 1
 * $Id: console.c,v 1.11 91/02/14 16:16:37 bj Exp $
d8 1
a8 1
 * $Revision: 1.11 $
d11 8
d58 1
a58 1
 *  $Header: HOG:Other/inet/src/c/rlogin/RCS/console.c,v 1.11 91/02/14 16:16:37 bj Exp $
d63 1
a63 2

#define DEBUG 1
a79 1

d131 2
d182 1
a182 1
		{
d184 1
a184 1
		}
a191 1

d195 1
d204 1
a204 1
    ULONG vpmid;
d210 2
a211 1
    
d216 1
a216 1
		{
d219 1
a219 1
		}
d223 1
a223 1
		{
d225 1
a225 1
		} 
d227 1
a227 1
		{
d230 1
d233 1
a266 1

d268 1
a268 1
		{
d277 16
a292 12
		if ((vpmid = GetVPModeID( &scr->ViewPort )) != INVALID_ID)
			{
			box.Left = box.Top = 0 ;
			GetDisplayInfoData( 0, &di, sizeof(di), DTAG_DIMS, vpmid ) ;
			rect = &di.TxtOScan ;   /* we are interested only in oscan */
			box.Width  = max_text_w = rect->MaxX - rect->MinX + 1 ;
			box.Height = max_text_h = rect->MaxY - rect->MinY + 1 ;
			box.Left   = scr->LeftEdge < 0 ? -scr->LeftEdge : 0 ;
			box.Top    = scr->TopEdge < 0 ? -scr->TopEdge : 0 ;
			max_text_w  = box.Width ;  /* these are the visible display   */
			max_text_h  = box.Height ; /* width & height variables        */
			}                         /* Used 2 keep text in the display */
d294 1
a294 1
		}
d296 1
a296 1
		{
d306 1
a306 1
		}
d311 1
a311 1
		{
d313 1
a313 1
		}
d316 1
a316 1
		{
d318 1
a318 1
		}
d321 1
a321 1
		{
d323 1
a323 1
		}
d354 1
a354 1
		{
d358 1
a358 1
		scrdef.ViewModes = (max_w>=640 ? HIRES : 0) | (max_h>300 ? LACE : 0) ;
d360 1
a360 1
			{
d363 8
a370 1
			}
d383 2
a384 2
		if( user_width )                
			{    /* user asked for a width */    
d386 1
a386 1
				{                               
d388 1
a388 1
				}                               
d390 1
a390 1
				{                               
d392 1
a392 1
				}                               
d394 1
a394 1
				{                               
d396 3
a398 2
				}                               
			}
d400 1
a400 1
			{    /* user asked for a width */    
d402 1
a402 1
				{                               
d404 1
a404 1
				}                               
d406 1
a406 1
				{                               
d408 1
a408 1
				}                               
d410 1
a410 1
				{                               
d412 4
a415 4
				}                               
			}
		win = OpenWindow(&bbwin) ;
		} 
d417 1
a417 1
		{         /* else we're in a window on WBscreen */
d420 1
a420 1
			{      /* user asked for a width */
d422 1
a422 1
				{
d424 3
a426 3
				}
			else if( user_width <= min_wide )
				{
d428 3
a430 3
				}
			else
				{
a431 1
				}
d433 5
a437 4
		if( top_x ) 
			{   /* user wants a different X position */ 
			if( top_x + nw.Width <= max_w )
				{
a438 1
				}
d440 1
d442 2
a443 2
		if( user_height ) 
			{     /* user asked for a height */
d445 1
a445 1
				{
d447 1
a447 1
				}
d449 1
a449 1
				{
d451 3
a453 3
				}
			else if( user_height < (3 * fonthigh))
				{
a454 1
				}
d456 1
d458 4
a461 4
		if( top_y ) 
			{  /* user wants a different Y position */ 
			if( top_y + nw.Height <= max_h )
				{
a462 1
				}
d464 1
d470 1
a470 1
			{
d472 1
a472 1
			}
d474 2
a475 2
		if( ((conunit == 1L) || (conunit == 3L ))  && screen != 1)
			{
d477 1
a477 1
			}
d480 1
a480 1
		}
d482 2
a483 2
	if(!cr || !cw || !cwp || !crp || !win)
		{
d486 30
a515 2
		}

d520 2
a521 2
	if(OpenDevice("console.device", conunit, (struct IORequest *)cw, 0L))
		{
d524 1
a524 1
		}
d527 1
a527 1
		{
d529 1
a529 1
		}
a539 1

a542 2
unsigned char cwarray[88] ;

a545 2


d549 1
d551 7
a557 5
	/* break buf into small pieces */ 

	while ( len > 80 ) 
		{                   /* strip extra bells */
		for( src = buf, dest = cwarray, realcount = x = 0 ; x < 80 ; src++, x++ )
a558 3
			*dest = *src ;
			if( *dest != 0x07 )
				{
d561 3
a563 3
				}
			else
				{
a564 1
				}
d566 1
d573 1
a573 1
		}
d576 1
a576 1
		{
d579 1
a579 1
		}
d581 2
a582 2
	if (len) 
		{               /* strip extra bells */
d584 3
a587 3
			*dest = *src ;
			if( *dest != 0x07 )
				{
d590 3
a592 3
				}
			else
				{
a593 1
				}
d595 1
d600 1
a600 1
		}
d603 1
a603 1
		{
d606 1
a606 1
		}
a615 1

d617 1
a617 1
		{
d620 1
a620 1
		}
d623 1
a623 1
		{ 
d626 1
a626 1
		}
d629 1
a629 1
		{
d632 1
a632 1
		}
d635 1
a635 1
		{
d638 1
a638 1
		}
d641 1
a641 1
		{
d644 1
a644 1
		}
d647 1
a647 1
		{
d650 1
a650 1
		}
d653 1
a653 1
		{
d656 1
a656 1
		}
d659 1
a659 1
		{
d662 1
a662 1
		}
d665 1
a665 1
		{
d668 1
a668 1
		}
d671 1
a671 1
		{
d674 1
a674 1
		}
d677 1
a677 1
		{
d680 1
a680 1
		}
a697 2
	int tmp ;

d699 1
a699 1
		{
d701 2
a702 1
		}
d704 1
a704 1
		{
d706 1
a706 1
		}
d709 4
a712 3
		{
		*cols = (int)((((win->Width) - (win->BorderLeft *2)) / fontwidth) ) ;
		}                                        
d714 4
a717 6
		{
		tmp = (int)(win->BorderTop + win->BorderBottom) ;
		tmp = win->Height - tmp ;
		tmp = tmp / fontheight ;
		*rows = tmp ;
		}
a727 2
 
#ifdef FOOBAR
d730 1
a730 1
GetDisplayDims( struct Screen *scrn, struct IBox *box )
d732 4
a735 4
  ULONG vpmid ;
  struct IBox ibox ;
  struct DimensionInfo di ;
  struct Rectangle *rect ;
d738 1
a738 1
    
d740 1
a740 1
        {
d742 1
a742 1
        rect = &di.TxtOScan ;   /* we are interested onlg in oscan */
d747 3
a749 1
        }
a752 1
#endif /* foobar */
@


1.11
log
@Added ability to specify max window width even if on a
custom screen. Gives user ability to deal with "display
too wide" errors in vi, emacs, etc.
 
Tightened some code here and there. Details. etc.
@
text
@d6 1
a6 1
 * $Id: console.c,v 1.10 90/12/06 15:36:45 bj Exp $
d8 1
a8 1
 * $Revision: 1.10 $
d11 7
d50 1
a50 1
 *  $Header: HOG:Other/inet/src/c/rlogin/RCS/console.c,v 1.10 90/12/06 15:36:45 bj Exp $
d65 2
a161 6
	
	/****************************************************
		if( !CheckIO((struct IORequest *)cr ))
			return( 0 ) ;
		return(1) ;
	*******************************************************/
d196 7
d211 1
d216 1
a216 1
		}
d231 26
d267 12
d294 1
a294 1
	scr = NULL ;    /* we use this again so clear it! */
d311 28
a338 1
        /* user specified he wants a screen!  */
d353 38
a390 16
		                                                 /* ==================== */
		bbwin.Width = max_w ;      /* default width */   /*                      */ 
		if( user_width )                                 /* this allows the      */
			{      /* user asked for a width */          /* user to specify      */ 
			if( user_width >= max_w )                    /* a max window         */
				{                                        /* windth even when     */
				bbwin.Width = max_w ;                    /* on a custom screen   */
				}                                        /* so that vi and such  */
			else if( user_width <= min_wide )            /* won't flip when      */
				{                                        /* they get a "too      */
				bbwin.Width = min_wide ;                 /* many columns error.  */
				}                                        /*                      */
			else                                         /*                      */
				{                                        /* 2-14-90              */
				bbwin.Width = user_width ;               /*                      */
				}                                        /* ==================== */
d644 3
a653 1

d678 34
@


1.10
log
@Fixed (for good, hopefully) the problems with calculating
the proper window sizes upon opening. This. Thanks to
Peter, the SIZEBBOTTOM thing is solved.

@
text
@d1 1
a1 1
/* -----------------------------------------------------------------------
d6 1
a6 1
 * $Id: console.c,v 1.9 90/12/05 16:12:35 bj Exp $
d8 1
a8 1
 * $Revision: 1.9 $
d11 6
d43 1
a43 1
 *  $Header: HOG:Other/inet/src/c/rlogin/RCS/console.c,v 1.9 90/12/05 16:12:35 bj Exp $
d45 1
a45 1
 *------------------------------------------------------------------------
d48 3
d65 1
a65 1
 /* ----------------------------------------------------------------
d75 2
a76 2
  * extenders don't hit the border.
  * ---------------------------------------------------------------
d88 4
a91 4
extern struct MsgPort *CreatePort();
extern struct Library *OpenLibrary();
extern struct Screen *OpenScreen() ;
extern struct Window *OpenWindow() ;
d95 1
a95 2
struct GfxBase *GfxBase;
static int console_is_open;
d97 10
a106 3
static struct MsgPort *crp, *cwp;
static struct IOStdReq *cw, *cr;
static struct Screen *scr = NULL ;
d108 1
a108 3
extern int fontwide ;   /* needed to pass proper display size params to host */
extern int fonthigh ;   /* via 'send_window_size()' call in rlogin.c         */
int min_wide = 640 ;    /* to start we assume font width = 8. Can change!    */
a113 3
extern int resize ;

extern long conunit ;
d116 1
d124 1
a124 1
/* this is the screen used if screen mode is selected */
d132 1
a132 3
static struct TextFont *textfont ;    /* we use this to extract the current */
                                      /* workbench screen's font            */

d142 22
d165 1
a165 1
console_getchar( )
d177 3
a179 2
	cr->io_Data = (APTR)&c;
	cr->io_Length = sizeof(c);
d185 3
d189 1
a189 1
console_init( UBYTE *title, int screen)
d222 5
a226 5
		max_h = scr->Height ;
		max_w = scr->Width ;
		textfont = GfxBase->DefaultFont ;
		fonthigh = textfont->tf_YSize ;
		fontwide = textfont->tf_XSize ;
d228 2
a229 2
		min_wide = ((80 * fontwide) + scr->WBorLeft + scr->WBorRight) ;
		min_high = ((24 * fonthigh) + scr->WBorTop + scr->WBorBottom + fonthigh + 1) ;
d233 1
a233 1
		{		
d235 5
a239 5
		max_h = wbscr.Height ;
		max_w = wbscr.Width ;
		textfont = wbscr.RastPort.Font ;
		fonthigh = textfont->tf_YSize ;
		fontwide = textfont->tf_XSize ;
d241 2
a242 2
		min_wide = ((80 * fontwide) + wbscr.WBorLeft + wbscr.WBorRight) ;
		min_high = ((24 * fonthigh) + wbscr.WBorTop + wbscr.WBorBottom + barfonthigh + 1) ;
d244 2
a245 1
	scr = NULL ;
d251 1
a251 1
		
d261 1
a261 1
		
d269 1
a269 3
		scr = (struct Screen *)OpenScreen((struct NewScreen *)&scrdef) ;

		if (!scr) 
d274 1
a274 1
			
d276 18
a293 1
		bbwin.Screen = scr ;
d392 4
d407 1
a407 1
	/* break buf into small pieces */       /* WHY ??? */
a463 2


d467 2
d543 6
a548 5
/* -------------------------------------------------------------------*/
/* This function calculates the window size in pixels as well as the  */
/* values for rows and columns as calculated from the FONT being used */
/* -------------------------------------------------------------------*/

d555 1
a555 1
	
a576 5





@


1.9
log
@fixed the value that rlogin sent to the host regarding
how many columns it could see. It was reporting one less
than was really there.
@
text
@d4 1
a4 1
 * $Locker: bj $
d6 1
a6 1
 * $Id: console.c,v 1.8 90/12/02 06:00:48 martin Exp Locker: bj $
d8 1
a8 1
 * $Revision: 1.8 $
d11 5
d37 1
a37 1
 *  $Header: HOG:Other/inet/src/c/rlogin/RCS/console.c,v 1.8 90/12/02 06:00:48 martin Exp Locker: bj $
d55 17
d96 2
d178 4
a181 4
	crp = CreatePort(0L, 0);
	cwp = CreatePort(0L, 0);
	cr = CreateStdIO(crp);
	cw = CreateStdIO(cwp);
d183 1
a183 1
	nw.Title = wtitle;
d189 2
a190 1
		textfont = GfxBase->DefaultFont;
d192 3
a194 1
		min_wide = ((80 * fontwide) + scr->WBorLeft + scr->WBorRight);
d199 1
a199 1
		GetScreenData((char *)&wbscr,sizeof(wbscr),WBENCHSCREEN,NULL);
d202 2
a203 1
		textfont = wbscr.RastPort.Font;
d205 3
a207 1
		min_wide = ((80 * fontwide) + wbscr.WBorLeft + wbscr.WBorRight) ; 
d211 5
a215 3
	fonthigh = textfont->tf_YSize ;


d221 5
d232 2
a233 2
		scrdef.ViewModes = (max_w>=640 ? HIRES : 0) | (max_h>300 ? LACE : 0);
		scr = (struct Screen *)OpenScreen((struct NewScreen *)&scrdef);
d237 2
a238 2
			console_close();
			return( -1 );
d241 3
a243 3
		ShowTitle(scr,(BOOL)0);
		bbwin.Screen = scr;
		win = OpenWindow(&bbwin);
d270 1
a270 1
		nw.Height = 200 ;       /* default height */
d280 4
@


1.8
log
@fixed my previous fix for computing min win size under 2.0
@
text
@d4 1
a4 1
 * $Locker:  $
d6 1
a6 1
 * $Id: console.c,v 1.7 90/12/01 22:00:18 martin Exp $
d8 1
a8 1
 * $Revision: 1.7 $
d11 3
d32 1
a32 1
 *  $Header: inet2:src/c/rlogin/RCS/console.c,v 1.7 90/12/01 22:00:18 martin Exp $
d470 1
a470 1
		*cols = (int)((((win->Width) - (win->BorderLeft *2)) / fontwidth) -1) ;
@


1.7
log
@fixed bug that caused unpredictable window sizes under 2.0
@
text
@d6 1
a6 1
 * $Id: console.c,v 1.6 90/11/29 15:11:23 bj Exp $
d8 1
a8 1
 * $Revision: 1.6 $
d11 3
d29 1
a29 1
 *  $Header: inet2:src/c/rlogin/RCS/console.c,v 1.6 90/11/29 15:11:23 bj Exp $
a138 1

d157 1
d162 3
d172 3
d177 1
a177 2
	textfont = V20 ? GfxBase->DefaultFont : wbscr.RastPort.Font ;
	fontwide = textfont->tf_XSize ;
d179 1
a179 10
	
       /* new min window size */ 
	if (V20)
		{
		min_wide = ((80 * fontwide) + scr->WBorLeft + scr->WBorRight) ; 
		}
	else
		{
		min_wide = ((80 * fontwide) + wbscr.WBorLeft + wbscr.WBorRight) ; 
		}
d186 1
a186 1
                /* user specified he wants a screen!  */
d194 1
@


1.6
log
@backed up to 5.05 to deter some odd crashes upon exit.
@
text
@d6 1
a6 1
 * $Id: console.c,v 1.5 90/11/29 10:27:13 bj Exp $
d8 1
a8 1
 * $Revision: 1.5 $
d11 3
d26 1
a26 1
 *  $Header: HOG:Other/inet/src/c/rlogin/RCS/console.c,v 1.5 90/11/29 10:27:13 bj Exp $
d167 1
a167 1
	scr = NULL ;	
d173 9
a181 1
	min_wide = ((80 * fontwide) + wbscr.WBorLeft + wbscr.WBorRight) ; 
@


1.5
log
@rev 36.8 rlogin.  Fixes bad call to UnlockPubScreen that kept
the lock so any suqsequent attepts to resize screens with Prefs
editors, etc., would fail.
@
text
@d2 1
a2 1
 * console.c  for rlogin   Lattice 5.10
d4 1
a4 1
 * $Locker: bj $
d6 1
a6 1
 * $Id: console.c,v 1.4 90/11/13 15:27:31 bj Exp Locker: bj $
d8 1
a8 1
 * $Revision: 1.4 $
d11 5
d23 1
a23 1
 *  $Header: HOG:Other/inet/src/c/rlogin/RCS/console.c,v 1.4 90/11/13 15:27:31 bj Exp Locker: bj $
d156 1
a156 1
		UnlockPubScreen( NULL,  scr ) ;
@


1.4
log
@no changes. test.
@
text
@d2 1
a2 1
 * console.c  for rlogin   Lattice 5.05
d6 1
a6 1
 * $Id: console.c,v 1.3 90/11/13 15:26:29 bj Exp Locker: bj $
d8 1
a8 1
 * $Revision: 1.3 $
d11 3
d18 1
a18 1
 *  $Header: HOG:Other/inet/src/c/rlogin/RCS/console.c,v 1.3 90/11/13 15:26:29 bj Exp Locker: bj $
d151 1
a151 1
		UnlockPubScreen( scr ) ;
@


1.3
log
@Headers fixes.
@
text
@d6 1
a6 1
 * $Id: console.c,v 1.2 90/11/13 15:23:14 bj Exp Locker: bj $
d8 1
a8 1
 * $Revision: 1.2 $
d10 4
a13 1
 * $Log$
d15 1
a15 1
 *  $Header: HOG:Other/inet/src/c/rlogin/RCS/console.c,v 1.2 90/11/13 15:23:14 bj Exp Locker: bj $
@


1.2
log
@Added code to allow t
the use of LockPubScreen under 2.0 so that proper screen
size information could be used.
@
text
@d4 1
a4 1
 * $Locker$
d6 1
a6 1
 * $Id$
d8 1
a8 1
 * $Revision$
d10 3
a12 1
 *  $Header: HOG:Other/inet/src/c/rlogin/RCS/console.c,v 1.1 90/11/02 16:01:09 bj Exp $
@


1.1
log
@Initial revision
@
text
@d1 13
a13 6
/*
** Amiga screen handling for rlogin/telnet, etc.
*
*  $Header$
*
*/
d47 1
a47 1
static struct Screen *scr;
d139 13
a151 4
	GetScreenData((char *)&wbscr,sizeof(wbscr),WBENCHSCREEN,NULL);
	max_h = wbscr.Height ;
	max_w = wbscr.Width ;
		
@
