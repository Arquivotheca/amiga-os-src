head     37.26;
branch   ;
access   ;
symbols  Release1:1.10;
locks    ; strict;
comment  @ * @;


37.26
date     93.02.11.17.48.52;  author bj;  state Exp;
branches ;
next     37.25;

37.25
date     93.02.11.16.59.42;  author bj;  state Exp;
branches ;
next     37.22;

37.22
date     92.12.16.16.12.05;  author bj;  state Exp;
branches ;
next     37.21;

37.21
date     92.09.11.16.28.04;  author bj;  state Exp;
branches ;
next     37.20;

37.20
date     92.08.11.11.14.18;  author bj;  state Exp;
branches ;
next     37.19;

37.19
date     92.08.08.19.37.29;  author bj;  state Exp;
branches ;
next     37.17;

37.17
date     92.05.27.15.53.45;  author bj;  state Exp;
branches ;
next     37.16;

37.16
date     92.05.27.15.28.21;  author bj;  state Exp;
branches ;
next     1.14;

1.14
date     91.08.09.14.20.47;  author bj;  state Exp;
branches ;
next     1.13;

1.13
date     91.08.06.13.29.35;  author bj;  state Exp;
branches ;
next     1.12;

1.12
date     91.06.19.12.25.13;  author bj;  state Exp;
branches ;
next     1.11;

1.11
date     91.04.24.15.20.40;  author bj;  state Exp;
branches ;
next     1.10;

1.10
date     91.02.14.16.13.01;  author bj;  state Exp;
branches ;
next     1.9;

1.9
date     91.02.13.16.44.11;  author bj;  state Exp;
branches ;
next     1.8;

1.8
date     91.01.31.13.42.58;  author bj;  state Exp;
branches ;
next     1.7;

1.7
date     91.01.31.12.06.18;  author bj;  state Exp;
branches ;
next     1.6;

1.6
date     90.12.07.13.47.39;  author bj;  state Exp;
branches ;
next     1.5;

1.5
date     90.12.02.06.02.54;  author martin;  state Exp;
branches ;
next     1.4;

1.4
date     90.11.29.15.09.34;  author bj;  state Exp;
branches ;
next     1.3;

1.3
date     90.11.28.00.32.20;  author bj;  state Exp;
branches ;
next     1.2;

1.2
date     90.11.13.15.18.27;  author bj;  state Exp;
branches ;
next     1.1;

1.1
date     90.11.02.15.56.31;  author bj;  state Exp;
branches ;
next     ;


desc
@Initial release version with Intuition additions. 36.3.
@


37.26
log
@Fixes bad interaction between close gadget in window and
'About' menu. Selecting the 'quit' froom the menu and then
deciding not to quit would leave the close gadget console stream
turned off.
@
text
@/* -----------------------------------------------------------------------
 * RLOGIN.C  (Lattice 5.10 )
 *
 * $Locker:  $
 *
 * $Id: rlogin.c,v 37.25 93/02/11 16:59:42 bj Exp $
 *
 * $Revision: 37.25 $
 *
 * $Log:	rlogin.c,v $
 * Revision 37.25  93/02/11  16:59:42  bj
 * Code details & cleanup. Slowly converting to global data structure.
 * 
 * Revision 37.22  92/12/16  16:12:05  bj
 * Fixed problem with Gontowski's rlogind. Incoming data bytes with values
 * >= 128 and <= 160 were having their high bits stripped. The escape
 * character from rlogind is the 0x9b.  Rlogin was initially written for
 * use with a termcap/terminfo file so this was never a problem.
 * 
 * This is the ONLY change in binary 37.22
 * 
 * Revision 37.21  92/09/11  16:28:04  bj
 * 1. Newlook menus.
 * 2. 'rlamiga' as lower case.
 * 3. DisplayBeep() replaces FlashBar().
 * 
 * Revision 37.20  92/08/11  11:14:18  bj
 * V39 includes.  Extra comments for AlterMenu() function usage.
 * "include:proto/*" changed to "include:clib/*".  Main change this rev
 * was in console.c.
 * 
 * Revision 37.19  92/08/08  19:37:29  bj
 * Fixed enforcer hits when starting up on a custom screen (B17426).
 * 
 * Added new menu/hotkey option to size the window to 80 columns while
 * leaving the window height alone.
 * 
 * Added several ReadArgs options to control the initial startup
 * configuration of rlogin. JumpScroll, LineWrap, MaxCols, MaxRows and
 * PasteDelay are all now command line options.
 * 
 * Proper error message if rlogin started with no args.
 * 
 * V37.18 was an internal version that was never released no checked
 * out/in.
 * 
 * AS225 R2
 * 
 * Revision 37.17  92/05/27  15:53:45  bj
 * No changes from 37.16. Revision bump.
 * 
 * Revision 37.16  92/05/27  15:28:21  bj
 * 1. Added jump scrolling.
 * 2. Menus to toggle jump scroll and line wrap.
 * 3. Finally really fixed default window open size so
 *    that the user gets 24 rows by 80 columns even with
 *    a large screen title bar font.
 * 4. Now gets row and column count directly from the
 *    ConUnit structure (used to calculate them.)
 * 5. Moved much header info from the .c file into rlglobal.h
 * 6. Changed AskExit() to use EasyRequest().
 * 
 * New rev numbers to match the actual version string in the
 * binary (what a concept.)
 * 
 * 6. New menu item allows user to quickly return to a
 *    24 row by 80 column window.
 *    (This feature is currently removed if user specifies that
 *     he wants a custom screen.)
 * 
 * Revision 1.14  91/08/09  14:20:47  bj
 * fixed TEMPLATE bug ('rlogin ?' would display template twice.)
 * First round of support for different background colors (alpha
 *   source code and NOT functional in this 37.13 exe file.
 *   Commented out.)
 * 
 * Revision 1.13  91/08/06  13:29:35  bj
 * V 37.11
 * Added ReadArgs support.
 * Global data structure.
 * About() function.
 * Shared Socket Library version !!!!!
 * 
 * Revision 1.12  91/06/19  12:25:13  bj
 * Added conclip support.  Fixed font bug. assorted details.
 * This version commences the 2.0x ONLY versions of rlogin.
 * This will NOT run under 1.x
 * 
 * Revision 1.11  91/04/24  15:20:40  bj
 * Fixed all PAL/NTSC display mode incompatibilities. Now works
 * in all PAL modes whether on the WBench screen or on a custom
 * screen.
 * 
 * Revision 1.10  91/02/14  16:13:01  bj
 * Details and formatting. Nothing functional.
 * 
 * Revision 1.9  91/02/13  16:44:11  bj
 * Fixed Ctrl-C fixes. 
 * Fixed loss of escape sequences in vi and emacs.
 * Different OOB Data handling.
 * 
 * Revision 1.8  91/01/31  13:42:58  bj
 * details of no functional value.
 * 
 * Revision 1.7  91/01/31  12:06:18  bj
 * Switched to Lattice 5.10
 * Fixes to allow better (faster) control-c handling when
 *   aborting something on the net (like ls).
 * Fixed handling of command line completion.
 * version # bumped to 37 to match the OS stuff.
 * 
 * Revision 1.6  90/12/07  13:47:39  bj
 * Changed termtype default from 'network' to 'RLamiga'
 * to support a unique termcap entry on large systems.
 * The only change made for v14.
 *
 * Revision 1.5  90/12/02  06:02:54  martin
 * replaced selectwait() with Wait() call
 * made async, fixed occassional pauses
 * faster and 3.5K smaller
 * 
 * Revision 1.4  90/11/29  15:09:34  bj
 * Had to go back to 5.05 Lattice to get rid of a crash
 * caused by unknown 5.10x artifacts (still unknown)
 * 
 * Revision 1.3  90/11/28  00:32:20  bj
 * Fixed bug whereby rlogin would crash on 68000 machines. This was due to a non-word
 * aligned array in the hostent structure used in gethostent() in the socket library.
 * Made this array a global under rlogin and extracted the gethostenet() code from
 * the socket library to be used here in rlogin.  Seems to work ok now.
 *          
 *
 * $Header: AS225:src/c/rlogin/RCS/rlogin.c,v 37.25 93/02/11 16:59:42 bj Exp $ 
 *
 *------------------------------------------------------------------------
 */


/* #define BETA_COPY 1 */
#define MAIN 1


/* #define BG2 1 */   /* do this if you want background color to be color #2 */
                    /* this requires a matching termcap !!!!!!!  */

/* #define DEBUG 1 */
#ifdef DEBUG
	#define DB1(x)  PutStr(x)
#else
	#define DB1(x) ;
#endif

#define ESC 0x1b

#include "rlogin_rev.h"

#include <exec/types.h>
#include <ss/socket.h>
#include <sys/socket.h>
#include <exec/libraries.h>
#include <exec/memory.h>
#include <devices/conunit.h>
#include <sys/ioctl.h>
#include <netdb.h>
#include <signal.h>

#include <intuition/intuition.h>
#include <libraries/dos.h>
#include <graphics/gfxbase.h>
#include <graphics/text.h>                                                
#include <exec/ports.h>              
#include <ctype.h>
#include <string.h>

#include <libraries/gadtools.h>
#include <utility/tagitem.h>

#include <ios1.h>

 //////////////////////////////////////////////

#include        <clib/alib_protos.h>
#include        <clib/asl_protos.h>
#include        <clib/console_protos.h>
#include        <clib/diskfont_protos.h>
#include        <clib/dos_protos.h>
#include        <clib/exec_protos.h>
#include        <clib/gadtools_protos.h>
#include        <clib/graphics_protos.h>
#include        <clib/intuition_protos.h>
#include        <clib/misc_protos.h>
#include        <clib/timer_protos.h>
#include        <clib/utility_protos.h>
#include        <clib/wb_protos.h>


 //////////////////////////////////////////////


#include <ctype.h>

#ifdef min
   #undef min
#endif

#include <stdio.h>   /* after the #undef min */
#include <errno.h>

#include "rlglobal.h"

BYTE *version = VERSTAG ;
BYTE clipbuffer[CLIPBUFSIZE] ;
STATIC BYTE buf[INBUFFSIZE] ;  /* buffer for incoming data from net */

/********************************************************
 * this is the stuff that allows jump scrolling
 *******************************************************
 */


ULONG jumpscroll = TRUE ;
ULONG linewrap = TRUE ;
WORD chars_in_blockbuf ;
BYTE *blockptr ;
WORD block_count ;
#define MAXINBLOCKS 10
#define INBUFFSIZE 256
BYTE blockbuf[(INBUFFSIZE * MAXINBLOCKS) + 10] ;  /* buffer to hold incoming */
                                                  /* while we calc scroll jumps */

BYTE *con_stream_delim = ";\n\r\t" ;
WORD oldwin_y ;        /* holds window height for resize op */

extern struct ConUnit *conunit ;

extern struct Window  *win ;

extern struct GfxBase *GfxBase ;
extern struct Library *GadToolsBase ;
extern struct Library *DiskfontBase ;
extern struct Library *SockBase ;
struct MsgPort *userport = NULL ;

struct Menu *menu = NULL ;

ULONG PT_delay = 0L ;
LONG exiting = FALSE ;
struct Task *myself ;


	/* these next two are optionally set by the user to request maximum */
	/* column or row counts */
LONG max_window_cols_user ;  
LONG max_window_rows_user ;

/* ==========================================================================
 * void main(void)
 * ==========================================================================
 */ 

extern struct UFB _ufbs[] ;
extern int min_wide ;
extern int min_high ;

UBYTE *pt_str = "PT00" ;

VOID main(VOID) ;

VOID 
main(VOID)
{
	LONG waitmask ;
	extern int cons_kybd_sigF ;
	extern int socket_sigio, socket_sigurg ;
	int cc ;
	ULONG event, netevent, urgevent;
	UBYTE hbuf[256] ;
	int bcnt = 0 ;
	int incontrol = 0 ;
	int cnt ;
    UBYTE clipchar ;
	UBYTE *bp ;
	UBYTE c ;

	struct RLGlobal *glob ;
	LONG opts[OPT_COUNT] ;

	int dobreak   = 0 ;
    if((glob = (struct RLGlobal *)AllocVec((LONG)sizeof(struct RLGlobal),MEMF_PUBLIC|MEMF_CLEAR))==NULL)
    {
    	Getout("Insufficient memory\n", NULL) ;
    }
    
    glob->rl_glob_ptr = glob ;

		/* set up non-zero/null default values in the global structure */
	glob->rl_UseScreen = 100L ;
    glob->rl_Unit      = 3L ;
    glob->rl_rows      = 24L ;
    glob->rl_cols      = 80L ;
    glob->rl_resize    = 1L ;
    glob->rl_80wide    = 640L ;
    glob->rl_fontwide  = 8L ;
    glob->rl_fonthigh  = 8L ;
    glob->rl_sockets_are_setup = 0L ;

    CopyMem( "rlamiga/9600", glob->rl_TermType, 12L) ;
    memset((BYTE *)opts,0,sizeof(opts)) ;    
    memset((BYTE *)blockbuf,0,sizeof(blockbuf)) ;    
    
    if((glob->rl_RDargs=(struct RDArgs *)ReadArgs(TEMPLATE,opts,NULL))==NULL)
	{
		Getout("required argument missing\n", glob) ;
	}
	else
	{
		if( opts[OPT_HOST] )
		{
			strncpy( glob->rl_Host, (BYTE *)opts[OPT_HOST], MAXHOST ) ; 
			glob->rl_hostptr = &glob->rl_Host[0] ;
		}
		if( opts[OPT_USER] )
		{
			strncpy( glob->rl_User, (BYTE *)opts[OPT_USER], MAXUSER ) ; 
			glob->rl_userptr = &glob->rl_User[0] ;
		}
		if( opts[OPT_SCREEN] )
		{
			glob->rl_UseScreen = 1L ;
		}
		if( opts[OPT_LEFT] )
		{
			glob->rl_Left = *((LONG *)opts[OPT_LEFT]) ;
		}
		if( opts[OPT_TOP] )
		{
			glob->rl_Top = *((LONG *)opts[OPT_TOP]) ;
		}
		if( opts[OPT_WIDTH] )
		{
			glob->rl_Width = *((LONG *)opts[OPT_WIDTH]) ;
		}
		if( opts[OPT_HEIGHT] )
		{
			glob->rl_Height = *((LONG *)opts[OPT_HEIGHT]) ;
		}
		if( opts[OPT_CONUNIT] )
		{
			glob->rl_Unit = *((LONG *)opts[OPT_CONUNIT]) ;
		}
		if( opts[OPT_NORESIZE] )
		{
			glob->rl_resize = 0L ;
		}
		if( opts[OPT_TERMTYPE] )
		{
			strncpy( glob->rl_TermType, (BYTE *)opts[OPT_TERMTYPE], MAXTERMTYPE ) ; 
			*(glob->rl_TermType + MAXTERMTYPE - 1) = '\0' ;
		}
		glob->rl_termtypeptr = &glob->rl_TermType[0] ;
		if( opts[OPT_JUMP] )
		{
			AlterMenu( "JSC", NO_TYPE, 0, CHECKED ) ;
			jumpscroll = FALSE ;
		}
		if( opts[OPT_WRAP] )
		{
			AlterMenu( "LWRAP", NO_TYPE, 0, CHECKED ) ;
			linewrap = FALSE ;
		}
		if(opts[OPT_MAXWIDTH])
		{
			max_window_cols_user = *((LONG *)(opts[OPT_MAXWIDTH])) ;
		}
		if(opts[OPT_MAXHEIGHT])
		{
			max_window_rows_user = *((LONG *)(opts[OPT_MAXHEIGHT])) ;
		}
		if( opts[OPT_PASTE] )
		{
			PT_delay = *((LONG *)opts[OPT_PASTE]) ;
			if( PT_delay >= 0L && PT_delay <= 5L)
			{
					/* turn off check for currently set delay */  
				AlterMenu( pt_str, NO_TYPE,0,CHECKED ) ; 
					/* now we alter in place the 'tens' digit of pt_str */
					/* can't do this and be pure ... */
				*(pt_str + 2) = (UBYTE) ('0' + (UBYTE)PT_delay) ;
					/* ... and turn THAT checkmark on */
				AlterMenu(pt_str,NO_TYPE,CHECKED,0) ;
			}
			else
			{
				PT_delay = 0L ;
			}
		}

		FreeArgs( glob->rl_RDargs ) ;

		if( glob->rl_Top || glob->rl_Left || glob->rl_Width || glob->rl_Height || glob->rl_resize == 0L )
		{
 			if( glob->rl_UseScreen == 100L )
			{
				glob->rl_UseScreen = 0L ;
			}
		}

		if( glob->rl_Unit == 2L || glob->rl_Unit > 3L)
		{
			glob->rl_Unit = 100L ;
		}
	}


	if((SockBase = OpenLibrary( "inet:libs/socket.library", 0L )) == NULL) 
	{
		Getout("Error opening inet:libs/socket.library\n", glob) ;
	}

	setup_sockets( MAXSOCKS, &errno );
	glob->rl_sockets_are_setup = 1L ;


	if( glob->rl_userptr == NULL )   /* done only if  '-l' option was omitted */ 
	{
		glob->rl_userptr = getlogin() ;
	}

	glob->rl_remuserptr = glob->rl_userptr ;

	if((clipsig = (UBYTE)AllocSignal(-1L)) == -1 )
	{
		Getout("AllocSignal Failed\n", glob) ;
	}
	clipevent = 1L << clipsig ;

	myself = FindTask( NULL ) ;

	if((glob->rl_socket = rcmd(&glob->rl_hostptr, 513, glob->rl_userptr, glob->rl_remuserptr, glob->rl_termtypeptr,(int	*)NULL))<0L)
	{
		Getout("RCMD: Unknown host.\n", glob) ;
	}

	cc = -1 ;
	if(s_ioctl(glob->rl_socket, FIONBIO, (BYTE *)&cc)<0 || s_ioctl(glob->rl_socket, FIOASYNC, (BYTE *)&cc)<0)
	{
		PutStr("ioctl\n") ;
	}

	netevent = (ULONG)(1L << s_getsignal( SIGIO )) ;
	urgevent = (ULONG)(1L << s_getsignal( SIGURG )) ;

	if( netevent == 0L || urgevent == 0L )
	{
		Getout("Could not initialize signals\n", glob) ;
	}


	if(console_init( glob ) < 0)
	{
		Getout("Could not initialize console\n", glob) ;
	}

	if( linewrap == FALSE )
	{
		LINEWRAP_OFF ;
	}
	
	CLOSEGAD_ON ;
	MENU_ON ;

	if( glob->rl_resize )
	{
		RESIZE_ON ;
	}

	oldwin_y = win->Height ;


#ifdef BETA_COPY
	console_write("*** THIS IS AN INTERMEDIATE RLOGIN. THIS IS A BETA AND IS NOT FOR RELEASE ***\n",78L) ;
	console_write("*** THIS IS AN INTERMEDIATE RLOGIN. THIS IS A BETA AND IS NOT FOR RELEASE ***\n",78L) ;
#endif

#ifdef BG2
	console_write("\n   *** THIS REQUIRES A SPECIAL TERMCAP!! ***\n", 46L ) ;
	console_write( displaycolors, 13 ) ;
#endif

	NewList( (struct List *)&paste ) ;

	waitmask = netevent | urgevent | cons_kybd_sigF | clipevent | SIGBREAKF_CTRL_C ;

	do 
	{
		event = Wait( waitmask ) ;
		if( event & SIGBREAKF_CTRL_C )
		{
			exiting = TRUE ;
		}

		if(event & cons_kybd_sigF)
		{
			c = (UBYTE)(console_getchar() & 0xff) ;

					/* if we are grabbing a ctrl sequence */
			if( incontrol ) 
			{
				hbuf[bcnt] = c ;
				bcnt++ ;
					/* valid ESC sequence terminator? then end & send */
				if( ESC_SEQ_TERMINATOR(c) )
				{
					if( c == CON_IDCMP_REPORT ) 
					{
						if( CON_CLOSEGAD( hbuf ))
						{
							CLOSEGAD_OFF ;
							if((exiting = AskExit(glob)) == 0L)
							{
								CLOSEGAD_ON ;
							}
						}
						else if( CON_GOTMENU( hbuf ))
						{
							HandleMenu( glob, hbuf ) ;
						}
						else if( CON_RESIZE( hbuf ))
						{
							send_window_size( glob ) ;
							if( glob->rl_Unit == 0L )
							{
								if( win->Height < oldwin_y )
								{
									send(glob->rl_socket, "\r", 1, 0) ;
								}
							}
							oldwin_y = win->Height ;
						}
					}

#ifdef SPECIAL  
                /* ---------------------------------------------- */
                /* -- THIS CODE IS WRONG -- THIS CODE IS WRONG -- */
                /* BE CAREFUL THAT YOU ALLOW FUNCTION KEY STRINGS */
                /* TO GET THROUGH !!                              */
                /*                                                */
                /*  else if( c == CON_SPECIAL_KEY)                */
                /*  {                                             */
                /*      if( hbuf[3] == TILDE )                    */
                /*      {                                         */
                /*          if( hbuf[2] == QUESTION_MARK)         */
                /*          {                                     */
                /*              /* VPrintf("HELP KEY\n",  NULL) ;*/ */
                /*          }                                     */
                /*      }                                         */
                /*  }                                             */
                /*                                                */
                /* ---------------------------------------------- */
#endif
					else if( c == CONCLIP_TERM && CONCLIP_PENDING(hbuf))
					{
						if(MakeClipMine())
						{
							Signal(myself, clipevent) ;
						}
					}
					else 
					{
						send( glob->rl_socket, &hbuf[0], bcnt, 0 ) ;
					}
					bcnt = incontrol = 0 ;
				}
			}
			else if( c == 0x9b )    /* start of a control sequence ? */
			{
				incontrol = 1 ;
				hbuf[bcnt] = 0x1b ;
				bcnt++ ;
				hbuf[bcnt] = '[' ;
				bcnt++ ;
			}
			else 
			{
				if( c == 3 && clip_in_progress )
				{
					KillPaste() ;
					clip_in_progress = 0 ;
				}
				else
				{
					send(glob->rl_socket, &c, 1, 0);
					bcnt = incontrol = 0 ;
				}
			}
		}

		if( event & urgevent )
		{
			handle_oob( glob ) ;
		}

		if( event & netevent)
		{
					/* ============================================= */
					/* check for any keypresses in this loop so that */
					/* any control-Cs can get handled. If the user   */
					/* hits ANY key while this loop is in effect, we */
					/* break out so that the keypress gets handled   */
					/* in a timely fashion                           */
					/* ============================================= */

            block_count = chars_in_blockbuf = 0 ;
            blockptr = blockbuf ;
			while( (cc = recv(glob->rl_socket, buf, sizeof(buf), 0)) > 0)
			{
				if((SetSignal(0L,0L)) & urgevent )
				{
					dobreak = 1 ;
				}
				if(console_char_ready())
				{
					dobreak = 1 ;
				}                   

				for( cnt = 0, bp = (UBYTE *)&buf ; cnt < cc ; cnt++, bp++  )
				{
					if( (*bp > 127) && (*bp < 160) && (*bp != 155 /* escape */))
					{
						*bp &= 0x7f ;
					}
				}

				if( jumpscroll == FALSE )
				{
                   /* handle CTRL-G separately so it is less obnoxious  */
                   /* console wants to DisplayBeep( NULL )              */
                   /* This is more than cosmetic with systems that      */
                   /* fight you and send multiple bells. Can bog system */

					if( (*buf != 0x07 ) || (glob->rl_UseScreen == 1) )
					{
						console_write( buf, (int)(cc) ) ;
					}
					else
					{
						FlashBar() ;
						if( cc > 1 )
						{
							console_write( &buf[1], cc-1 ) ;
						}
					}
				}
				else
				{
					CopyMem(buf,blockptr,(ULONG)cc) ;
					block_count++ ;
					blockptr += cc ;
					chars_in_blockbuf += cc ;

					if( (cc < sizeof(buf)) || (block_count >= MAXINBLOCKS ) )
					{
						flush_buffered_blocks( blockbuf, (ULONG)chars_in_blockbuf) ;
						Signal( myself, netevent ) ; 
						block_count = chars_in_blockbuf = 0 ;
						blockptr = blockbuf ;
					}
				}

				if( dobreak )
				{
					Signal( myself, netevent ) ; 
					dobreak = 0 ;
					break ;
				}
			}

			if( jumpscroll == TRUE )
			{
				flush_buffered_blocks( blockbuf, (ULONG)chars_in_blockbuf) ;
				block_count = chars_in_blockbuf = 0 ;
				blockptr = blockbuf ;
			}

			if(errno != EWOULDBLOCK)
			{
				if( errno == 0 && cc <= 0 )
				{
					exiting = TRUE ;
				}
			} 
		}

		if( event & clipevent) 
		{
			if( GetClipChar(&clipchar) == 0L )
			{
				if( clipchar )
				{
					send(glob->rl_socket, &clipchar, 1, 0) ;
					if( clipchar <= 13 )
					{
						Delay(PT_delay) ;
					}
				}
				Signal(myself, clipevent) ; /* set the signal again ! */
			}
			else
			{
				clip_in_progress = 0 ;
				KillPaste() ;
			}
		}
	} while ( exiting == FALSE ) ;

	Getout(NULL, glob) ;
}

/* ==========================================================================
 * flush_buffered_blocks( UBYTE *buffer, ULONG charcount )
 *
 * this function controls the output of the buffered text. This is
 * for jump scrolling.
 *
 * bp2 - points to the start of the next write you will make.
 * bp  - the 'work' buffer pointer
 * ctrlstart - the start of the working control sequence
 * ==========================================================================
 */


VOID
flush_buffered_blocks( UBYTE *buffer, REGISTER ULONG charcount )
{
	REGISTER WORD linefeeds ;
	REGISTER ULONG x ;
	REGISTER UBYTE *bp ;
	REGISTER LONG xmax = (LONG)conunit->cu_XMax + 1 ;
	REGISTER LONG ymax = (LONG)conunit->cu_YMax + 1 ;


	linefeeds  = countlfs(buffer,charcount, xmax) ;
	
	if( linefeeds > ymax )
	{
		bp = buffer ;
		x = 0 ;
		while((charcount >= INBUFFSIZE) && (x < MAXINBLOCKS))
		{
			doscroll( countlfs( bp,(LONG)INBUFFSIZE,(ULONG)xmax)) ;
			console_write(bp,INBUFFSIZE) ;
			bp += INBUFFSIZE ;
			charcount -= INBUFFSIZE ;
			x++ ;
		}
		doscroll(countlfs(bp,charcount,xmax)) ;
		console_write(bp,charcount) ;
	}
	else
	{
		doscroll(linefeeds) ;
		console_write(buffer,charcount) ;
	}
}

/* ======================================================================
 * countlfs( UBYTE *buffer, ULONG charcount, ULONG max_width)
 *                     
 * This returns the number of "line feeds" in a given block of text.
 * In this case "line feed" means either a true ascii 10 -or- a "virtual
 * line feed" which means that any line that is longer than the display
 * is wide will cause the console device to scroll if the cursor is
 * at the bottom of thedisplay. Example :  if the current console
 * window is 80 chars wide and we send a line to it that is 166 chars
 * long, it will want three (3) actual line feeds.
 * ====================================================================== 
 */

ULONG
countlfs(REGISTER UBYTE *b, REGISTER ULONG cnt, REGISTER ULONG wide )
{
	REGISTER UBYTE *bp1 ;
	REGISTER ULONG x,lfs, llen ;

	for( bp1 = b, lfs = llen = x = 0L; x < cnt ; x++, bp1++)
	{
		if( *bp1 == 10 )
		{
			lfs++ ;
			llen = 0L ;
		}
		if( linewrap && (llen > wide) )
		{
			lfs++ ;
			llen =  0L ;
		}
	}
	return(lfs) ;
}

VOID
doscroll(REGISTER ULONG lines)
{

	REGISTER LONG xpos = (LONG)conunit->cu_XCP + 1 ;
	REGISTER LONG ypos = (LONG)conunit->cu_YCP + 1 ;
	REGISTER LONG ymax = (LONG)conunit->cu_YMax + 1 ;

	REGISTER LONG scrollup ;
	REGISTER LONG jump ;
	UBYTE textbuffer[128] ;

	scrollup = (ypos + lines) - ymax ;
	jump = (long)(ypos-scrollup) ; 

	if( (ypos + lines) > ymax + 1 )
	{
        mysprintf( textbuffer, "\x1b[%ld;%ldH",jump,(LONG)xpos) ;
		console_write( textbuffer, (LONG)strlen(textbuffer)) ;
       
			/* scroll */
		mysprintf(textbuffer,"\x1b[%ldS\0", (LONG)scrollup) ; 
		console_write( textbuffer, (LONG)strlen(textbuffer)) ;
	}
}


/* ==========================================================================
 * send_window_size()
 * ==========================================================================
 */

VOID 
send_window_size( struct RLGlobal *g )
{
	struct {
		BYTE  ws_magic[4] ;         /* magic escape sequence */
		UWORD ws_row, ws_col ;      /* screen size in chars  */
		UWORD ws_width, ws_height ; /* screen size in pixels */
	} ws;

	int rows, cols, width, height ;

	console_get_window_sizes(&width, &height, &cols, &rows, g->rl_fontwide, g->rl_fonthigh ) ;

	ws.ws_magic[0] = 0377 ;
	ws.ws_magic[1] = 0377 ;
	ws.ws_magic[2] = 's' ;
	ws.ws_magic[3] = 's' ;
	ws.ws_row      = htons(rows) ;
	ws.ws_col      = htons(cols) ;
	ws.ws_width    = htons(width) ;
	ws.ws_height   = htons(height) ;
	send(g->rl_socket, (BYTE *)&ws, sizeof(ws), 0) ;
}

/* ==========================================================================
 * handle_oob()
 * ==========================================================================
 */

VOID
handle_oob( struct RLGlobal *g )
{
	BYTE c ;
	STATIC BYTE waste[1024] ;

	while(recv(g->rl_socket, &c, sizeof(c), MSG_OOB) < 0)
	{ 
		DB1("oob: recv msg_oob\n") ;
		if (errno != EWOULDBLOCK) 
		{
			return ;
		}
		recv(g->rl_socket,waste,sizeof(waste),0) ;
	}

	if(c & TIOCPKT_WINDOW)
	{
		send_window_size( g ) ;
	}

	if(c & TIOCPKT_FLUSHWRITE)
	{
		for (;;) 
		{
			LONG atmark ;
			int n ;

			atmark = 0; 
			if (s_ioctl(g->rl_socket, SIOCATMARK, (BYTE *)&atmark) < 0) 
			{
				DB1("ioctl\n") ;
				break ;
			}
			if (atmark)
			{
				break ;
			}

			if((n = recv(g->rl_socket, waste, sizeof(waste),0)) <= 0)
			{
				break ;
			}
		}
	}
	if(c & TIOCPKT_NOSTOP)
	{
		DB1("oob: nostop\n") ;
		/* Not implemented */
	}
	if(c & TIOCPKT_DOSTOP)
	{
		DB1("oob: dostop\n") ;
		/* Not implemented */
	}
	if(c & TIOCPKT_FLUSHREAD)
	{
		DB1("oob: flushread\n") ;
		/* Not implemented */
	}
	if(c & TIOCPKT_STOP)
	{
		DB1("oob: stop\n") ;
		/* Not implemented */
	}

	if(c & TIOCPKT_START)
	{
		DB1("oob: start\n") ;
		/* Not implemented */
	}
}


/* ========================================================================
 * flash the menu bar as a replacement for the highly obnoxious 
 * DisplayBeep( NULL ) that the console device does when it's fed a CTRL-G
 * ========================================================================
 */

VOID
FlashBar( VOID )
{
#ifdef OLDWAY
	REGISTER struct RastPort *rp = win->RPort ;
	REGISTER LONG w = (LONG)win->Width ;
	REGISTER LONG h = (LONG)win->BorderTop ;

	ClipBlit(rp,0L, 0L, rp, 0L, 0L, w, h, 0x50L ) ;
	Delay(10L) ;
	ClipBlit(rp,0L, 0L, rp, 0L, 0L, w, h, 0x50L ) ;
#else
	DisplayBeep((struct Screen *)win->WScreen) ;
#endif	
}


/* ========================================================================
 * replacement CXBRK() for Lattice 
 * ========================================================================
 */

int
CXBRK(VOID)
{
	return(0);
}



/* ================================================================
 * DoConClipStuff()
 * ===============================================================
 */

#define TYPE_READ   25
#define TYPE_REPLY  27

LONG
MakeClipMine(VOID)
{
	REGISTER struct MsgPort *pasteport ;
	REGISTER struct MsgPort *conclipport ;
	REGISTER struct MinNode *node ;
	LONG retval = 0L ;

	if(pasteport = CreateMsgPort()) ;
	{
		cm.cm_Msg.mn_Node.ln_Type = 0 ;
		cm.cm_Msg.mn_Length       = (LONG)sizeof( struct cmdMsg ) ;
		cm.cm_Msg.mn_ReplyPort    = pasteport ;
		cm.cm_type                = TYPE_READ ;

		Forbid() ;
		if( conclipport = FindPort("ConClip.rendezvous"))
		{
			PutMsg(conclipport,(struct Message *)&cm) ;
			Permit() ;
			WaitPort(pasteport) ;
			if(cm.cm_error == 0 && cm.cm_type == TYPE_REPLY)
			{
				/* pull pastenodes off conclip list & add them to ours */
				node = (struct MinNode *)RemHead((struct List *)&cm.cm_Chunks) ;
				while( node )
				{
					AddTail((struct List *)&paste,(struct Node *)node) ;
					node = (struct MinNode *)RemHead((struct List *)&cm.cm_Chunks) ;
				}
				pastenode=(struct MinNode *)RemHead((struct List *)&paste) ;
				clip_in_progress = 1 ;
				retval = 1L ;
			}
		}
		else
		{
			Permit() ;
			clip_in_progress = 0 ;
		}
		DeleteMsgPort( pasteport ) ;
	}                         
	return( retval ) ;
}

/* =========================================================================
 * GetClipChar()
 *
 * This function is called only by main() when the clipevent signal
 * gets set. 
 * =========================================================================
 */

LONG
GetClipChar( UBYTE *thechar )
{
	UBYTE ch ;

	if( pastenode )
	{
		ch = ((struct CHRSChunk *)pastenode)->text[pcount++] ;
		if( pcount > ((struct CHRSChunk *)pastenode)->size )
		{
			if(((struct CHRSChunk *)pastenode)->freeme)
			{
				FreeVec(((struct CHRSChunk *)pastenode)->freeme) ;
			}
			FreeVec(pastenode) ;
			pastenode = (struct MinNode*)RemHead((struct List *)&paste) ;
			pcount = 0L ;
		}
		*thechar = ch ;
		return(0L) ;
	}
	*thechar = 0 ;
	return(1L) ;
}

/* =====================================================================
 * KillPaste( VOID )
 * =====================================================================
 */

VOID
KillPaste(VOID)
{
	while(pastenode)
	{
		if(((struct CHRSChunk *)pastenode)->freeme)
		{
			FreeVec(((struct CHRSChunk *)pastenode)->freeme) ;
		}
		FreeVec(pastenode) ;
		pastenode = (struct MinNode*)RemHead((struct List *)&paste) ;
	}
	pcount = 0L ;
	clip_in_progress = 0 ;
}

/* ==========================================================
 * HandleMenu()
 * =======================================================
 */

VOID
HandleMenu( struct RLGlobal *g, UBYTE *data )
{
	REGISTER BYTE   *command ;
	REGISTER struct MenuItem *item ;
	REGISTER ULONG  class ;
	REGISTER UWORD  subclass ;
	REGISTER UWORD  code ;

  /* --------not currently used -------------------------------------- */
    class    = (ULONG )atol(strtok((BYTE *)&data[2], con_stream_delim)) ;
    subclass = (UWORD)atol(strtok( NULL, con_stream_delim)) ; 
  /* ----------------------------------------------------------------- */
   
	code = (UWORD)atol(strtok( NULL, con_stream_delim)) ;

	while( code != MENUNULL )
	{
		item = (struct MenuItem *)ItemAddress( menu, (LONG)code ) ;
		command = (BYTE *)GTMENUITEM_USERDATA( item ) ;

		if( ! strncmp(command, "PT", 2 ))
		{
			PT_delay = atol( &command[2] ) ;
		}
		else if( (strcmp( command, "RESET" )) == 0)
		{
			console_write( "\xF", 1 ) ;
		}
		else if( (strcmp( command, "LWRAP" )) == 0)
		{
			if(linewrap)
			{
				LINEWRAP_OFF ;
				linewrap = FALSE ;
			}
			else
			{
				LINEWRAP_ON ;
				linewrap = TRUE ;
			}
		}
		else if( (strcmp( command, "JSC" )) == 0)
		{
			jumpscroll = jumpscroll ? FALSE : TRUE ;
		}
		else if( (strcmp( command, "ABOUT" )) == 0)
		{
			About(g) ;
		}
		else if( (strcmp( command, "QUIT" )) == 0)
		{

			CLOSEGAD_OFF ;
			if((exiting = AskExit(g)) == 0L )
			{
				CLOSEGAD_ON ;
			}
		}
		else if( (strcmp( command, "MIN")) == 0)
		{
			SizeWindow( win,(LONG)(((WORD)min_wide) - win->Width),
	                   (LONG)(((WORD)min_high) - win->Height)) ;
		}
			/* make window 80 cols wide. Leave height alone */
		else if( (strcmp( command, "W80")) == 0)
		{
			SizeWindow( win,(LONG)(((WORD)min_wide) - win->Width),0L) ;
		}
		code = item->NextSelect ;
	}
}

/* ---------------------------------------------------
 * Getout( BYTE *msg, struct RLGlobal *g )
 * ---------------------------------------------------
 */

extern APTR stderr_console_task ;

VOID
Getout( BYTE *msg, struct RLGlobal *g )
{
	struct Process *proc = (struct Process *)FindTask(NULL) ;
	APTR console_task ;
	
	if( (g != NULL) && (g->rl_sockets_are_setup == 1L) )
	{
		cleanup_sockets() ;
	}
	if( SockBase )
	{
		CloseLibrary( SockBase ) ;
		SockBase = NULL ;
	}

	console_close( ) ;

	if( g )
	{
		FreeVec( g ) ;
	}
	if( clipsig != -1 )
	{
		FreeSignal((LONG)clipsig) ;
	}
	if( msg )  /* no message means no error so we */
	{          /* we return to fall off the end of main() */
		
#ifdef OLD_STYLE_EXIT  /* <= 37.14 */
		Close(_ufbs[2].ufbfh) ;
		_ufbs[2].ufbflg = 0L ;
		exit(VPrintf(msg,NULL) ? 20 : 0) ;
#else
		console_task = (APTR)proc->pr_ConsoleTask ;
		proc->pr_ConsoleTask=stderr_console_task ;
		Close(_ufbs[2].ufbfh) ;
		_ufbs[2].ufbflg = 0L ;
		proc->pr_ConsoleTask = console_task ;
		exit(VPrintf(msg,NULL) ? 20 : 0) ;
#endif

	}
}


/* -------------------------------------------------
 * About
 * -------------------------------------------------
 */

#define NAME "RLOGIN"

VOID
About(struct RLGlobal *g)
{
	struct EasyStruct es = {
		(LONG)sizeof(struct EasyStruct),
		0L,
		(UBYTE *)"  About",
		(UBYTE *)"%s Version %ld.%02ld (%s)",
		(UBYTE *)"  Continue  "
		} ;

	EasyRequest( g->rl_Window, &es, NULL, NAME,VERSION,REVISION,DATE) ;
}

/* -------------------------------------------------
 * AskExit
 * --------------------------------------------------
 */

LONG
AskExit(struct RLGlobal *g)
{

	struct EasyStruct askes = {
		(LONG)sizeof(struct EasyStruct),
		0L,
		(UBYTE *)"  Rlogin",
		(UBYTE *)"%s\nAre You Sure You Want To Quit?",
		(UBYTE *)"  Yes  |  No  "
		} ;

	return(EasyRequest( g->rl_Window, &askes, NULL,(APTR)g->rl_wtitle,NULL,NULL,NULL)) ;
}

@


37.25
log
@Code details & cleanup. Slowly converting to global data structure.
@
text
@d6 1
a6 1
 * $Id: rlogin.c,v 37.22 92/12/16 16:12:05 bj Exp $
d8 1
a8 1
 * $Revision: 37.22 $
d11 3
d133 1
a133 1
 * $Header: AS225:src/c/rlogin/RCS/rlogin.c,v 37.22 92/12/16 16:12:05 bj Exp $ 
d1138 1
a1138 1
			if((exiting = AskExit(g)) == 1L )
@


37.22
log
@Fixed problem with Gontowski's rlogind. Incoming data bytes with values
>= 128 and <= 160 were having their high bits stripped. The escape
character from rlogind is the 0x9b.  Rlogin was initially written for
use with a termcap/terminfo file so this was never a problem.

This is the ONLY change in binary 37.22
@
text
@d4 1
a4 1
 * $Locker: bj $
d6 1
a6 1
 * $Id: rlogin.c,v 37.21 92/09/11 16:28:04 bj Exp Locker: bj $
d8 1
a8 1
 * $Revision: 37.21 $
d11 8
d130 1
a130 1
 * $Header: AS225:src/c/rlogin/RCS/rlogin.c,v 37.21 92/09/11 16:28:04 bj Exp Locker: bj $ 
d516 1
a516 1
							if((exiting = AskExit()) == 0L)
d1129 1
a1129 1
			About() ;
d1135 1
a1135 1
			if((exiting = AskExit()) == 1L )
d1215 1
a1215 1
About(VOID)
d1225 1
a1225 1
	EasyRequest( win, &es, NULL, NAME,VERSION,REVISION,DATE) ;
d1234 1
a1234 1
AskExit(VOID)
a1235 1
	extern BYTE wtitle[] ;
d1245 1
a1245 1
	return(EasyRequest( win, &askes, NULL,(APTR)wtitle,NULL,NULL,NULL)) ;
@


37.21
log
@1. Newlook menus.
2. 'rlamiga' as lower case.
3. DisplayBeep() replaces FlashBar().
@
text
@d6 1
a6 1
 * $Id: rlogin.c,v 37.20 92/08/11 11:14:18 bj Exp Locker: bj $
d8 1
a8 1
 * $Revision: 37.20 $
d11 5
d122 1
a122 1
 * $Header: AS225:src/c/rlogin/RCS/rlogin.c,v 37.20 92/08/11 11:14:18 bj Exp Locker: bj $ 
d617 1
a617 1
					if( (*bp > 127) && (*bp < 160) )
@


37.20
log
@V39 includes.  Extra comments for AlterMenu() function usage.
"include:proto/*" changed to "include:clib/*".  Main change this rev
was in console.c.
@
text
@d4 1
a4 1
 * $Locker:  $
d6 1
a6 1
 * $Id: rlogin.c,v 37.19 92/08/08 19:37:29 bj Exp $
d8 1
a8 1
 * $Revision: 37.19 $
d11 5
d117 1
a117 1
 * $Header: AS225:src/c/rlogin/RCS/rlogin.c,v 37.19 92/08/08 19:37:29 bj Exp $ 
d123 1
a123 1
#define BETA_COPY 1
d291 1
a291 1
    CopyMem( "RLamiga/9600", glob->rl_TermType, 12L) ;
a463 4
#ifdef CONTEST
	console_write("CONSOLE_TEST_VERSION!!!!\n",25L) ;
#endif	

d929 1
d937 3
d1199 1
a1199 1
#define NAME "        RLOGIN        "
d1208 1
a1208 1
		(UBYTE *)"%s\nVersion %ld.%02ld (%s)",
@


37.19
log
@Fixed enforcer hits when starting up on a custom screen (B17426).

Added new menu/hotkey option to size the window to 80 columns while
leaving the window height alone.

Added several ReadArgs options to control the initial startup
configuration of rlogin. JumpScroll, LineWrap, MaxCols, MaxRows and
PasteDelay are all now command line options.

Proper error message if rlogin started with no args.

V37.18 was an internal version that was never released no checked
out/in.

AS225 R2
@
text
@d6 1
a6 1
 * $Id: rlogin.c,v 37.17 92/05/27 15:53:45 bj Exp $
d8 1
a8 1
 * $Revision: 37.17 $
d11 17
d45 1
a45 1
 * 7. New menu item allows user to quickly return to a
d96 1
a96 1
 * Revision 1.5  90/12/02  06:02:54  bj
d112 1
a112 1
 * $Header: AS225:src/c/rlogin/RCS/rlogin.c,v 37.17 92/05/27 15:53:45 bj Exp $ 
d158 21
a178 1
#include <proto/all.h>
d363 4
a366 1
				AlterMenu( pt_str, NO_TYPE,0,CHECKED ) ;
d368 1
@


37.17
log
@No changes from 37.16. Revision bump.
@
text
@d4 1
a4 1
 * $Locker: bj $
d6 1
a6 1
 * $Id: rlogin.c,v 37.16 92/05/27 15:28:21 bj Exp Locker: bj $
d8 1
a8 1
 * $Revision: 37.16 $
d11 3
d95 1
a95 1
 * $Header: AS225:src/c/rlogin/RCS/rlogin.c,v 37.16 92/05/27 15:28:21 bj Exp Locker: bj $ 
d100 2
a101 1
/* #define BETA_COPY 1 */
a103 1
/* #define DEBUG 1 */
d105 1
a105 1
/* #define BG2 1 */    /* do this if you want background color to be color #2 */
d108 1
a108 2
#define RDARGS_VERSION 1

d115 2
d142 1
d192 6
d207 2
d255 1
a255 1
		Getout("\n", glob) ;
d275 1
a275 1
			glob->rl_Left = atol((BYTE *)opts[OPT_LEFT]) ;
d279 1
a279 1
			glob->rl_Top = atol((BYTE *)opts[OPT_TOP]) ;
d283 1
a283 1
			glob->rl_Width = atol((BYTE *)opts[OPT_WIDTH]) ;
d287 1
a287 1
			glob->rl_Height = atol((BYTE *)opts[OPT_HEIGHT]) ;
d291 1
a291 1
			glob->rl_Unit = atol((BYTE *)opts[OPT_CONUNIT]) ;
d303 32
d346 1
a346 1
		if( glob->rl_Unit != 1L && glob->rl_Unit != 3L && glob->rl_Unit != 0L ) 
d379 1
a379 1
		Getout("RCMD failure!\n", glob) ;
d402 5
d418 4
d428 1
a428 3
	console_write("\n=========================================\n", 43L ) ;
	console_write("*** THIS REQUIRES A SPECIAL TERMCAP!! ***\n", 42L ) ;
	console_write("=========================================\n", 42L ) ;
d484 2
a485 1
#ifdef SPECIAL  /* ---------------------------------------------- */
d501 2
a502 2
#endif          /* ---------------------------------------------- */

a608 1

d666 4
d673 1
d684 3
a686 3
	linefeeds = countlfs(buffer,charcount, xmax) ;

	if(linefeeds > ymax)
d710 1
a710 1
 *
d715 1
a715 1
 * at the bottom of the display. Example :  if the current console
d1085 5
@


37.16
log
@1. Added jump scrolling.
2. Menus to toggle jump scroll and line wrap.
3. Finally really fixed default window open size so
   that the user gets 24 rows by 80 columns even with
   a large screen title bar font.
4. Now gets row and column count directly from the
   ConUnit structure (used to calculate them.)
5. Moved much header info from the .c file into rlglobal.h
6. Changed AskExit() to use EasyRequest().

New rev numbers to match the actual version string in the
binary (what a concept.)

6. New menu item allows user to quickly return to a
   24 row by 80 column window.
   (This feature is currently removed if user specifies that
    he wants a custom screen.)
@
text
@d6 1
a6 1
 * $Id: rlogin.c,v 1.14 91/08/09 14:20:47 bj Exp Locker: bj $
d8 1
a8 1
 * $Revision: 1.14 $
d11 19
d92 1
a92 1
 * $Header: HOG:Other/inet/src/c/rlogin/RCS/rlogin.c,v 1.13 91/08/06 13:29:35 bj Exp Locker: bj $ 
@


1.14
log
@fixed TEMPLATE bug ('rlogin ?' would display template twice.)
First round of support for different background colors (alpha
  source code and NOT functional in this 37.13 exe file.
  Commented out.)
@
text
@d6 1
a6 1
 * $Id: rlogin.c,v 1.13 91/08/06 13:29:35 bj Exp Locker: bj $
d8 1
a8 1
 * $Revision: 1.13 $
d11 6
d78 3
d83 1
a83 1
/* define BG2 1 */  /* do this is you want background color to be color #2 */
d89 1
a89 1
	#define DB1(x)  printf(x)
d101 1
d117 2
a118 5

#ifdef LATTICE
 #include <ios1.h>
 #include <proto/all.h>
#endif
a123 2
#define MAXSOCKS 10L

a125 2
 
   /* ------------  conclip stuff */  /* ----------- */
a126 44
struct CHRSChunk {
    struct MinNode mn;
    BYTE  *text;        /* pointer to start of text */
    BYTE * freeme;      /* if non-zero, call FreeVec() with this pointer */
    ULONG  size;        /* total # of characters in this block */
    ULONG  flags;       /* may end up needing this at some time */
    ULONG  UserLink;
    BYTE  data[1];      /* really 'n' # of bytes */
};

struct cmdMsg {
    struct Message cm_Msg;
    LONG   cm_type;     /* type of message, and return validation */
    LONG   cm_error;    /* error code return */
    struct MinList	cm_Chunks;
};

struct MinList paste ;
struct MinNode *pastenode ;
struct cmdMsg cm = {0} ;
struct MinList ClipList ;

BOOL   clip_in_progress ;
BYTE   clipsig = -1 ;
ULONG  clipevent ;
ULONG  pcount = 0L ;


VOID   About(VOID) ;
LONG   MakeClipMine(VOID) ;
struct MsgPort *CreateMsgPort(VOID) ;
VOID   DoConClipStuff(int s) ;
LONG   GetClipChar( UBYTE *thechar ) ;
VOID   KillPaste(VOID) ;
VOID   HandleMenu( struct RLGlobal *g, UBYTE *data ) ;
VOID   handle_oob( struct RLGlobal *g ) ;
int    send_window_size( struct RLGlobal *g ) ;
VOID   FlashBar( VOID ) ;
BOOL   AskExit( LONG wide, LONG high ) ;
VOID   Getout( BYTE *msg, struct RLGlobal *g ) ;

BYTE clipbuffer[256] ;


a128 49
 /* Messages sent via out-of-band data. */
#define TIOCPKT_FLUSHREAD    0x01    /* flush pending kybd data    */
#define TIOCPKT_FLUSHWRITE   0x02    /* flush all data to mark     */
#define TIOCPKT_STOP         0x04
#define TIOCPKT_START        0x08
#define TIOCPKT_NOSTOP       0x10
#define TIOCPKT_DOSTOP       0x20
#define TIOCPKT_WINDOW       0x80    /* request window size        */

#define ASKEXIT(x) (AskExit((LONG)(20 + 20 +(((x)->rl_fontwide) * 29)), 50L ))
#define ESC_SEQ_TERMINATOR(x) (((x) >= 0x40) && ((x) <= 0x7e)) 

	/* if using a sole '9b' as the escape then these values */
	/* need to be reduced by one */

#define CON_CLOSEGAD(b) (((b)[2] == 0x31 && (b)[3] == 0x31))
#define CON_RESIZE(b)   (((b)[2] == 0x31 && (b)[3] == 0x32))
#define CON_GOTMENU(b)  (((b)[2] == 0x31 && (b)[3] == 0x30))
#define CONCLIP_TERM    0x76  /* 'v'  */
#define CONCLIP_PENDING(b) (((b)[2] == 0x30 && (b)[3] == 0x20 && (b)[4] == 0x76))

    /* -------------------------------------------------------*/
	/* for gethostent - using this local version rather than  */
	/* the libray version.  Library version was crashing on   */
	/* 68000 machines. This was caused by the                 */
	/*                                                        */
	/*          char ghe_hostaddr[MAXADDRSIZE];               */
	/*                                                        */
	/* array being NOT word-aligned. When gethostent() tried  */
	/* write a LONG value into (LONG *)ghe_hostaddr, BANG!    */
	/* Solved (for now) by making the ghe_hostaddr[] array a  */
	/* global for RLOGIN.  The question remains as to why the */
	/* compiler is not aligning this.                         */
	/* -------------------------------------------------------*/

#define	MAX_ALIASES	35
#define	MAXADDRSIZE	14

BYTE ghe_hostaddr[MAXADDRSIZE] ; /* the fix ! */

#define OUTPUT(x) (VPrintf((x),NULL))

#define CSI               0x9b
#define CON_IDCMP_REPORT  0x7c
#define CON_OPTION_ON     0x68  /* lower case 'h' */
#define CON_OPTION_OFF    0x6c  /* lower case 'l' */
#define CON_SPECIAL_KEY   0x7e  /* tilde */
#define TILDE             0x7e  /* tilde */

d130 2
a131 5

UBYTE menu_on[]         = { '\x9b', '1','0','{', } ;
UBYTE closegad_on[]     = { '\x9b', '1','1','{','\0' } ;
UBYTE closegad_off[]    = { '\x9b', '1','1','}','\0' } ;
UBYTE gimme_resize[]    = { '\x9b', '1','2','{','\0' } ;
d133 15
a147 7
UBYTE linewrap_on[]     = { '\x9b', '\x3f', '\x37', '\x68' } ;
UBYTE linewrap_off[]    = { '\x9b', '\x3f', '\x37', '\x6c' } ;
UBYTE lfmode_on[]       = { '\x9b', '\x32', '\x30', '\x68' } ; 
UBYTE lfmode_off[]      = { '\x9b', '\x32', '\x30', '\x6c' } ; 
UBYTE cursor_off[]      = { '\x9b', '\x30','\x20', '\x70' } ;
UBYTE cursor_on[]       = { '\x9b', '\x20', '\x70'} ;
UBYTE displaycolors[]   = { '\x9b', '\x33','\x30',';','\x34','\x32',';','\x32','\x32',';','>','\x32','m' } ;
a148 2
STATIC BYTE buf[256];

d152 2
a159 1

a161 1
APTR vi = NULL ;   /* visualinfo pointer */
d165 1
a165 1
BOOL exiting = FALSE ;
d169 1
a169 1
 * main()
d174 2
d177 4
a180 1
main(int argc, BYTE **argv)
d182 1
a182 1
	LONG waitmask = 0L ;
d194 2
a195 2
	
	struct RLGlobal *glob = NULL ;
d197 2
a198 3
	
	int dobreak = 0 ;
    
d217 1
a217 1
    CopyMem( "RLamiga/9600", glob->rl_TermType, 12L ) ;
d219 1
d281 1
a281 1
			
d293 1
a293 1
	
d310 1
a310 1
	
a311 7
	
#ifdef FOOBAR
	printf("&rl_hostptr    = %ld\n", (LONG)(&glob->rl_hostptr) ) ;
	printf("rl_userptr     = %ld\n", (long)glob->rl_userptr) ;
	printf("rl_remuserptr  = %ld\n", (long)glob->rl_remuserptr) ;
	printf("rl_termtypeptr = %ld\n", (long)glob->rl_termtypeptr) ;
#endif	
d314 1
a314 1
	{	
d321 1
a321 1
		OUTPUT("ioctl\n") ;
d326 1
a326 1
	
d330 1
a330 1
	}		
d338 3
a340 5
	console_write( closegad_on, 4 ) ;
	console_write( menu_on, 4 ) ;
#ifdef BG2	
	console_write( displaycolors, 13 ) ;
#endif
d343 1
a343 1
		console_write( gimme_resize, 4 ) ;
d345 1
d349 12
d372 1
d376 2
a377 2
			
					/* if we're grabbing a ctrl sequence */
d379 1
a379 1
			{              
d389 2
a390 2
							console_write( closegad_off, 4 ) ;
							if((exiting = ASKEXIT(glob)) == FALSE)
d392 1
a392 1
								console_write( closegad_on, 4 ) ;
d412 19
a430 14
					
#ifdef SPECIALCHAR /* ---------------------------------------------- */
	/* BE CAREFUL THAT YOU ALLOW FUNCTION KEY STRINGS TO GET THROUGH !! */
					else if( c == CON_SPECIAL_KEY)
					{
						if( hbuf[3] == TILDE )
						{
							if( hbuf[2] == '?' )
							{
								/* VPrintf("HELP KEY\n",  NULL) ; */
							}
						}
					}
#endif /* ------------------------------------------------ */					
d467 1
a467 1
			
d470 1
a470 1
			(VOID)handle_oob( glob ) ;
d472 1
a472 1
			
d477 1
a477 1
					/* any control-C's can get handled. If the user  */
d479 1
a479 1
					/* break out so that the keypress get's handled  */
d483 2
d504 1
a504 3
					/* handle CTRL-G separately so it's less obnoxious */
					/* console wants to DisplayBeep( NULL ) */
				if( (*buf != 0x07 ) || (glob->rl_UseScreen == 1) )
d506 17
a522 1
					console_write( buf, (int)(cc) ) ;
d526 12
a537 4
					FlashBar() ;
					if( cc > 1 )
					{
						console_write( &buf[1], cc-1 ) ;
d549 7
d591 104
d699 1
a699 1
int 
d707 1
a707 1
	
d720 1
a720 1
	return((int)send(g->rl_socket, (BYTE *)&ws, sizeof(ws), 0) != sizeof(ws) ? -1 : 0) ;
d733 1
a733 1
	
d793 1
a793 1
	
d807 1
a807 1
 
a821 34
 *  Build & Display an AutoRequestor. Works as written under 2.0 and 1.3
 *  Return BOOLEAN  1 for 'yes', 0 for 'no'
 * ========================================================================
 */

#define BODYLEFTOFFSET 20

BOOL
AskExit(  LONG wide, LONG high )
{

	STATIC struct IntuiText pos = {
		0, 1, JAM1, 2, 3, NULL,
		(UBYTE *)" YES",
		NULL
		} ;

	STATIC struct IntuiText neg = {
		0, 1, JAM1, 6, 3, NULL,
		(UBYTE *)"NO",
		NULL
		} ;

	STATIC struct IntuiText body = {
		0, 1, JAM1, BODYLEFTOFFSET, 6, NULL,
		(UBYTE *)" YOU SURE YOU WANT TO QUIT ? ",
		NULL
		} ;

	return((AutoRequest(win,&body,&pos, &neg, 0L,0L, wide, high)) ? TRUE : FALSE) ;
}


/* ========================================================================
d841 1
a841 1
	
d849 1
a849 1
			
d856 1
a856 1
		
d883 1
a883 1
	}	                         
d899 1
a899 1
	
d915 1
a915 1
	}					
d928 1
a928 1
	while(pastenode)	
d952 2
a953 2
	REGISTER USHORT subclass ;
	REGISTER USHORT code ;
d955 6
a960 3
	class    = (ULONG )atol(strtok((BYTE *)&data[2], con_stream_delim)) ;
	subclass = (USHORT)atol(strtok( NULL, con_stream_delim)) ; 
	code     = (USHORT)atol(strtok( NULL, con_stream_delim)) ;
d975 17
d998 3
a1000 2
			console_write( closegad_off, 4 ) ;
			if((exiting = ASKEXIT(g)) == FALSE)
d1002 1
a1002 1
				console_write( closegad_on, 4) ;
d1005 5
d1019 2
d1024 3
d1036 1
a1036 1
	
d1049 8
d1059 1
d1061 2
d1080 1
a1080 1
		(UBYTE *)"  About  ",
d1084 1
a1084 1
	
d1087 22
@


1.13
log
@V 37.11
Added ReadArgs support.
Global data structure.
About() function.
Shared Socket Library version !!!!!
@
text
@d4 1
a4 1
 * $Locker:  $
d6 1
a6 1
 * $Id: rlogin.c,v 1.12 91/06/19 12:25:13 bj Exp $
d8 1
a8 1
 * $Revision: 1.12 $
d11 7
d67 1
a67 1
 * $Header: HOG:Other/inet/src/c/rlogin/RCS/rlogin.c,v 1.12 91/06/19 12:25:13 bj Exp $ 
d74 3
d232 1
a304 1
		VPrintf( TEMPLATE ,NULL) ;
d429 3
a431 1

@


1.12
log
@Added conclip support.  Fixed font bug. assorted details.
This version commences the 2.0x ONLY versions of rlogin.
This will NOT run under 1.x
@
text
@d6 1
a6 1
 * $Id: rlogin.c,v 1.11 91/04/24 15:20:40 bj Exp $
d8 1
a8 1
 * $Revision: 1.11 $
d11 5
d58 1
a58 1
 * 
d60 1
a60 1
 * $Header: HOG:Other/inet/src/c/rlogin/RCS/rlogin.c,v 1.11 91/04/24 15:20:40 bj Exp $ 
d67 2
a74 2


a76 2
#include <netdb.h>

d78 1
a78 2
#include<exec/memory.h>
#include <sys/types.h>
d80 2
d83 2
a84 2
#include <netinet/in.h>
#include <config.h>
d97 1
d99 1
d107 1
d109 1
a109 1
#include <stdio.h>
d112 2
a113 1
	/* ------------ */	/* conclip stuff */  /* ----------- */
d116 4
a119 4
    BYTE *text;			/* pointer to start of text */
    BYTE *freeme;		/* if non-zero, call FreeVec() with this pointer */
    ULONG  size;		/* total # of characters in this block */
    ULONG  flags;		/* may end up needing this at some time */
d121 1
a121 1
    BYTE  data[1];		/* really 'n' # of bytes		*/
d126 2
a127 2
    LONG 		cm_type;	/* type of message, and return validation */
    LONG 		cm_error;	/* error code return */
a128 1

d140 3
d146 1
a146 1
int    GetClipChar( UBYTE *thechar ) ;
d148 6
a153 1
VOID   HandleMenu( UBYTE *data, int socketnum ) ;
a156 55
#define MAXHOST 128L
#define MAXUSER 64L
#define MAXFILE 128L
#define MAXNAME 64L

#define TEMPLATE "HOST/A,-L=USER,-C=SCREEN,-X=LEFT,-Y=TOP,-W=WIDTH,\
-H=HEIGHT,-T=TERM,-U=UNIT,NORESIZE/S,COLOR1,COLOR2,FILE"

     /* screen color stuff */
#define COLORCOUNT 2  /* one bit plane in the screen */
#define R_G_B_COUNT 3

struct RLGlobal {                           /* default*/
	LONG  rl_UseScreen ;                    /*   0    */
	LONG  rl_Width ;                        /*   640  */
	LONG  rl_Height ;                       /*   200  */
	LONG  rl_Unit ;                         /*   3    */
	LONG  rl_Left ;                         /*   0    */
	LONG  rl_Top ;                          /*   0    */
	LONG  rl_Color1 ;                       /*  wb    */
	LONG  rl_Color2 ;                       /*  wb    */
	ULONG rl_vpmid ;                        /*  0     */
	LONG  rl_wbscr_wide ;                   /*  0     */
	LONG  rl_wbscr_high ;                   /*  0     */
	LONG  rl_fontwide ;                     /*  8     */
	LONG  rl_fonthigh ;                     /*  8     */
	LONG  rl_80wide ;                       /*  640   */
	LONG  rl_24high ;                       /*  0     */
	LONG  rl_48high ;                       /*  0     */
	LONG  rl_rows ;                         /*  24    */
	LONG  rl_cols ;                         /*  80   */ 
	LONG  rl_borderwidth ;                  /*   0    */
	LONG  rl_bordertop ;                    /*   0    */
	LONG  rl_borderbottom ;                 /*   0    */
	LONG  rl_backdrop ;                     /*   0    */
	LONG  rl_isA2024 ;                      /*   0    */
	LONG  rl_useA2024 ;                     /*   0    */
	LONG  rl_docolor ;                      /*   0    */
	LONG  rl_resize ;                       /*   1    */
	int   rl_colors[COLORCOUNT][R_G_B_COUNT]/*   0    */ ;
	VOID *rl_glob_ptr ;                     /*   0    */
	struct RDargs   *rl_RDargs ;            /*   0    */
	struct Rectangle rl_oscan_txt ;         /*   0    */
	struct Rectangle rl_oscan_std ;         /*   0    */
	struct Rectangle rl_oscan_max ;         /*   0    */
	struct Rectangle rl_oscan_vid ;         /*   0    */
	struct Screen   *rl_Screen ;            /*   0    */
	struct Window   *rl_Window ;            /*   0    */
	struct TextFont *rl_TextFont ;          /*   0    */
	struct TextAttr *rl_TextAttr ;          /*   0    */
	BYTE rl_Host[MAXHOST+8L] ;              /*   0    */
	BYTE rl_User[MAXUSER+8L] ;              /*   0    */
	BYTE rl_File[MAXFILE+8L] ;              /*   0    */
	BYTE rl_Name[MAXNAME+8L] ;              /*   0    */
	} ;
d158 1
d161 7
a167 7
#define TIOCPKT_FLUSHREAD 	0x01	/* flush pending kybd data	*/
#define TIOCPKT_FLUSHWRITE 	0x02	/* flush all data to mark 	*/
#define TIOCPKT_STOP		0x04
#define TIOCPKT_START		0x08
#define TIOCPKT_NOSTOP		0x10
#define TIOCPKT_DOSTOP		0x20
#define TIOCPKT_WINDOW		0x80	/* request window size		*/
d169 1
a169 1
#define ASKEXIT (AskExit((LONG)(20 + 20 +(fontwide * 29)), 50L ))
d195 1
a195 1
#define	MAXALIASES	35
a201 1

a208 1

a227 1
LONG conunit = 100L ;
d229 1
d233 2
a234 1
int fontwide = 8, fonthigh = 8 ; /* defaults. proper vals set in con_init() */
d237 1
a237 21
BYTE *use = " usage:\n rlogin host [-l id] [-x #] [-y #] [-w #] [-h #] [-r] [-c] [-t t/b ] [-u #]\n" ;
int user_width = 0, user_height = 0 ;

int useborder = 0 ;  /* if user is on a custom screen and wants */
                     /* borders on the window...   -B flag      */

int screen = 100 ;

VOID handle_oob( int ) ;
VOID FlashBar( VOID ) ;
BOOL AskExit( LONG wide, LONG high ) ;
STATIC BYTE *any( BYTE *p, BYTE *match ) ;
VOID sendstring( int socket, BYTE *string ) ;

int resize = 1 ;
int top_x  = 0 ;
int top_y  = 0 ;

BYTE *nullstring = "\0";

APTR *vi = NULL ;   /* visualinfo pointer */
a239 11
VOID DrawBevelBox(struct RastPort *r,WORD l, WORD t, WORD w, WORD h, Tag t1, ...) ;
BOOL LayoutMenus( struct Menu *first, APTR vi, Tag tag1, ...) ;
VOID FreeMenus( struct Menu *m ) ;
VOID FreeVisualInfo( APTR vi ) ;
APTR GetVisualInfo( struct Screen *s, Tag tag1, ...) ;
struct Menu *CreateMenus( struct NewMenu *nm, Tag tag1, ... ) ;
struct Screen *LockPubScreen( UBYTE *name ) ;
VOID UnlockPubScreen( UBYTE *name, struct Screen *scr ) ;
struct Window *OpenWindowTags( struct NewWindow *nw, Tag tag1, ... ) ;
struct Global *SetThingsUp(VOID) ;

a243 15

/* ==========================================================================
 * usage()
 * ==========================================================================
 */

VOID 
usage( VOID )
{
	OUTPUT(use) ;
	OUTPUT(TEMPLATE) ;
	exit(RETURN_WARN) ;
}


d249 2
d253 1
a253 2
	UBYTE c ;
	BYTE *hostname = NULL, *remuser, *localuser = NULL ;
d256 2
a257 5
	struct config *cf;
	int s, cc;
	LONG event, netevent, urgevent;
	int argcount ;
	BYTE *termtype = "RLamiga/9600" ;   /* must have */
d264 2
a265 1
	int cnt2 ;
d267 1
d271 1
a271 2
    glob = (struct RLGlobal *)AllocVec((LONG)sizeof(struct RLGlobal),MEMF_PUBLIC|MEMF_CLEAR) ;
    if( glob == NULL )
d273 1
a273 2
    	OUTPUT("AllocVec failure\n") ;
    	exit(20) ;
a275 1
#ifdef RDARGS_VERSION    
d277 14
a290 7
    glob->rl_Width    = 640L ;
    glob->rl_Height   = 200L ;
    glob->rl_Unit     = 3L ;
    glob->rl_rows     = 24L ;
    glob->rl_cols     = 80L ;
    glob->rl_resize   = 1L ;
    glob->rl_80wide   = 640 ;
d292 1
a292 2
		/* init the color array to all -1's */
	for( cnt = 0 ; cnt < COLORCOUNT ; cnt++ )
d294 61
a354 1
		for( cnt2 = 0 ; cnt2 < 3 ; cnt2++ )
d356 1
a356 1
			glob->rl_colors[cnt][cnt2] = 255 ;
d359 1
a359 2
			
#endif    
d361 4
a364 8
    if(( argc<2 ) || (argv[1][0] == '?') || ((argv[1][0] == '-') && (argv[1][1] == '?')) )
    {
            usage() ;
    }
    else 
    {
            hostname = argv[1] ;
    }
d366 2
a367 37
	for( argcount = 2 ; argcount < argc ; argcount++) 
	{
		if( argv[argcount][0] == '-' )
		{
			switch( toupper(argv[argcount][1] )) 
			{
				case 'C' :
					screen = 1 ;
					break ;
				case 'T' :            /* define term type - internal */
				                      /* vt-100, SUN, etc            */
					argcount++ ;  
					if( argv[argcount] && argv[argcount][0] != '-' ) 
					{
						termtype = argv[argcount] ;
					} 
					else 
					{        
						usage() ;
					}
					break ;
                                  
				case 'U':
					argcount++ ;
					if( argv[argcount] && argv[argcount][0] != '-' ) 
					{
						conunit = atol( argv[argcount] ) ;
						if( conunit != 1L && conunit != 3L && conunit != 0L ) 
						{
							conunit = 100L ;
						}
					} 
					else 
					{        
						usage() ;
					}
					break ;
a368 16
				case 'S':    
				case 'R':
					argcount++ ;
					if( argv[argcount] && isdigit(c = argv[argcount][0]))
					{
						resize = ( c == '0' || c == '1' ) ? ( c - '0' ) : 1 ;
					}
					else
					{
						argcount-- ;
					}
					if (screen == 100) 
					{
						screen = 0 ;
					}
					break ;
d370 3
a372 95
				case 'X' :   /* window top x position */
					argcount++ ;
					if( argv[argcount] ) 
					{
						top_x = (int) atoi( argv[argcount] ) ;
						if (screen == 100) 
							screen = 0 ;
						break ;
					}
					else
					{
						usage() ;
					}
				case 'W' :     /* window width */
					argcount++ ;
					if( argv[argcount] )
					{
						if( screen == 100 )
							screen = 0 ;
						user_width = (int)atoi( argv[argcount ] ) ;
						break ;
					}
					else
					{
						usage() ;
					}
					break ;
				case 'H' :
					argcount++ ;
					if( argv[argcount] ) 
					{
						user_height = (int) atoi( argv[argcount] ) ;
						if( screen == 100) 
							screen = 0 ;
						break ;
					}
					else
					{
						usage() ;
					}
				case 'Y' :
					argcount++ ;
					if( argv[argcount] )
					{
						if( screen == 100 ) 
							screen = 0 ;
						top_y = (int)atoi( argv[argcount] ) ;
						break ;
					}
					else
					{
						usage() ;
					}
					break ;
				case 'L' :	
					argcount++ ;
					if( argv[argcount] )
					{
						localuser = argv[argcount] ;
						break ;
					}
					else
					{
						usage() ;
					}
					break ;	
				case 'B' :
					useborder = 1 ;
					break ;
				case '?':	
					usage() ;
					break ;
					
				default:
					usage() ;
					break ;		
				break ;
			}
		}
	/****************************
		else if (argv[argcount][0] == '?') 
		{
			usage() ;
		}
	*************************/
		else 
		{
			usage() ;
		}
	}

	if( localuser == NULL )   /* done only if  '-l' option was omitted */ 
	{
		GETCONFIG(cf);
		localuser = cf ? cf->username : nullstring ;
d375 1
a375 1
	remuser = localuser;
d379 1
a379 2
		OUTPUT("AllocSignal() failure\n") ;
		exit(RETURN_FAIL) ;
d382 1
d385 8
a392 1
	if((s = rcmd(&hostname, 513, localuser, remuser, termtype,(int *)NULL))<0)
d394 1
a394 2
		OUTPUT("RCMD failure!\n") ;
		exit(RETURN_FAIL);
d397 2
a398 2
	cc = -1;
	if(ioctl(s, FIONBIO, &cc)<0 || ioctl(s, FIOASYNC, &cc)<0)
d403 4
a406 1
	if(console_init(hostname,screen, glob ) < 0)
d408 7
a414 3
		OUTPUT("Could not initialize console\n") ;
		close( s ) ;
		exit(RETURN_FAIL);
d416 1
d419 2
a420 1
	if( resize )
a425 2
	netevent = 1L << socket_sigio ;
	urgevent = 1L << socket_sigurg ;
d429 2
d433 1
a433 1
		event = Wait( netevent | urgevent | cons_kybd_sigF | clipevent | SIGBREAKF_CTRL_C);
d455 1
a455 1
							if((exiting = ASKEXIT) == FALSE)
d462 1
a462 1
							HandleMenu( hbuf, s ) ;
d466 2
a467 2
							send_window_size( s ) ;
							if( conunit == 0L )
d471 1
a471 1
									send(s, "\r", 1, 0) ;
d477 3
d490 1
d500 1
a500 1
						send( s, &hbuf[0], bcnt, 0 ) ;
d522 1
a522 1
					send(s, &c, 1, 0);
d530 1
a530 1
			(VOID)handle_oob(s) ;
d543 1
a543 1
			while( (cc = recv(s, buf, sizeof(buf), 0)) > 0)
d545 5
a549 1
				if(((SetSignal(0L,0L)) & urgevent ) || (console_char_ready()))
d564 1
a564 1
				if( (*buf != 0x07 ) || (screen == 1) )
d566 1
a566 1
					console_write( buf, cc ) ;
d576 1
d579 1
d596 1
a596 1
			if( GetClipChar(&clipchar) == 0 )
d600 1
a600 1
					send(s, &clipchar, 1, 0) ;
d616 1
a616 4
	close( s ) ;
	console_close( ) ;
	FreeVec( glob->rl_glob_ptr ) ; 
	exit(0) ;
d624 2
a625 2
STATIC 
send_window_size( int s )
d635 1
a635 1
	console_get_window_sizes(&width, &height, &cols, &rows, fontwide, fonthigh ) ;
d645 1
a645 1
	return(send(s, &ws, sizeof(ws), 0) != sizeof(ws) ? -1 : 0) ;
d654 1
a654 1
handle_oob( int s )
d659 1
a659 1
	while(recv(s, &c, sizeof(c), MSG_OOB) < 0)
d666 1
a666 1
		recv(s,waste,sizeof(waste),0) ;
d671 1
a671 1
		send_window_size(s ) ;
d682 1
a682 1
			if (ioctl(s, SIOCATMARK, &atmark) < 0) 
d692 1
a692 1
			if((n = recv(s, waste, sizeof(waste),0)) <= 0)
d755 1
a755 1
AskExit( LONG wide, LONG high )
a791 14
/* ============================================================
 * SendString
 * ============================================================
 */

VOID
sendstring( int sock, BYTE *string )
{
    if( string )
    {
		send(sock, string, strlen(string), 0) ;
	}
}

d854 1
a854 1
int
d870 1
d873 1
a873 1
		return(0) ;
d876 1
a876 1
	return(1) ;
d896 1
a896 1
	pcount = 0 ;
d906 1
a906 1
HandleMenu( UBYTE *data, int sock )
d908 1
a908 1
	REGISTER BYTE *command ;
d927 1
a927 1
		else if( (strcmp( command, "ABOUT" )) == 0)
d929 1
d931 1
a931 1
		else if( (strcmp( command, "RESET" )) == 0)
d933 1
a933 2
			console_write( "\xF", 1 ) ;
			send(sock, "\r", 1, 0) ;
d938 1
a938 1
			if((exiting = ASKEXIT) == FALSE)
d947 57
@


1.11
log
@Fixed all PAL/NTSC display mode incompatibilities. Now works
in all PAL modes whether on the WBench screen or on a custom
screen.
@
text
@d6 1
a6 1
 * $Id: rlogin.c,v 1.10 91/02/14 16:13:01 bj Exp $
d8 1
a8 1
 * $Revision: 1.10 $
d11 5
d55 1
a55 1
 * $Header: HOG:Other/inet/src/c/rlogin/RCS/rlogin.c,v 1.10 91/02/14 16:13:01 bj Exp $ 
d60 1
a60 1
#define DEBUG 0
d62 1
a62 1
#if DEBUG != 0
d74 2
d85 1
a85 1
#include <graphics/text.h>
d87 9
d97 5
d105 93
a197 3
/*
 * Messages sent via out-of-band data.
 */
d199 1
d208 1
a208 1
#define ASKEXIT (AskExit((long)(20 + 20 +(fontwide * 29)), 50L ))
d211 1
a211 1
	/* if using a sole '9b' as the escape then these values *
d213 1
d216 3
d228 1
a228 1
	/* write a LONG value into (long *)ghe_hostaddr, BANG!    */
d237 4
a240 1
char ghe_hostaddr[MAXADDRSIZE] ; /* the fix ! */
a248 1
char *version = VERSTAG ;
d250 1
a250 14
unsigned char closegad_on[]     = { '\x9b', '1','1','{','\0' } ;
unsigned char closegad_off[]    = { '\x9b', '1','1','}','\0' } ;
unsigned char gimme_resize[]    = { '\x9b', '1','2','{','\0' } ;

unsigned char linewrap_on[]     = { '\x9b', '\x3f', '\x37', '\x68' } ;
unsigned char linewrap_off[]    = { '\x9b', '\x3f', '\x37', '\x6c' } ;
unsigned char lfmode_on[]       = { '\x9b', '\x32', '\x30', '\x68' } ; 
unsigned char lfmode_off[]      = { '\x9b', '\x32', '\x30', '\x6c' } ; 
unsigned char cursor_off[]      = { '\x9b', '\x30','\x20', '\x70' } ;
unsigned char cursor_on[]       = { '\x9b', '\x20', '\x70'} ;

static char buf[256];

int oldwin_y ;        /* holds window height for resize op */
d252 19
a270 3
BOOL V20 = FALSE ;    /* true if OS version >= 2.0 */
long conunit = 100L ;
extern struct Window *win ;
d272 3
a274 1
int fontwide = 8, fonthigh = 8 ;
d277 1
a277 1
const char *use = " usage:\n rlogin host [-l id] [-x #] [-y #] [-w #] [-h #] [-r] [-c] [-t t/b ] [-u #]\n" ;
d280 6
a285 1
void handle_oob( int ) ;
d287 3
a289 2
int AskExit( long wide, long high ) ;
static char *any( char *p, char *match ) ;
d295 4
a298 1
char *nullstring = "\0";
d300 14
d321 2
a322 2
void 
usage( void )
d324 3
a326 2
	Write((long)Output(), use, (long)strlen(use)) ;
	exit(RETURN_WARN);
d333 1
a333 1
 */
d335 1
a335 1
main(int argc, char **argv)
d337 4
a340 4
	unsigned char c ;
	char *hostname = NULL, *remuser, *localuser = NULL ;
	extern int cons_kybd_sigF;
	extern int socket_sigio, socket_sigurg;
d343 1
a343 2
	int screen = 100 ;
	long event, netevent, urgevent;
d345 2
a346 3
	char *termtype = "RLamiga/9600" ;   /* must have */
    
	unsigned char hbuf[256] ;
a348 1
	int exiting = 0 ;
d350 4
a353 1
	register unsigned char *bp ;
d357 21
a377 31
/*  args.c   -   argument handler for rlogin 
 *
 *  Oct 17-90  -bj 
 * 
 *	argv[0] = program name
 *	argv[1] = host name
 *	argv[2] - argv[6] =
 *
 *    flag     arg          meaning
 *  -----------------------------------
 *		-l  username        your login id
 *		-c     -            use a screen instead of a window
 *		-x X position       X position of the top left edge of the window
 *		-w window_width     how wide your window
 *		-y Y position       Y position of the top left edge of the window
 *		-h window_height    how high your window
 *       ?     -            usage message
 *		-r     -            resize gadget
 *		-u     -            console unit (either 1 or 3)
 *      -t terminal/baud    set terminal type & baud rate
 *
 *	-w or -x or -y automatically toggles the use of a window
 *	instead of a screen.
 *
 *  width takes precedence over X pos
 *  height takes precedence over Y pos
 *  --------------------------------------
 */

 
	if(( argc<2 ) || (argv[1][0] == '?') || ((argv[1][0] == '-') && (argv[1][1] == '?')) )
d379 1
a379 1
		usage() ;
d381 3
a383 4
	else 
		{
		hostname = argv[1] ;
		}
d385 9
d395 2
d398 1
a398 1
		if( argv[argcount][0] == '-' )
a399 2
			switch( toupper(argv[argcount][1] )) 
				{
a402 1
					
d407 1
a407 1
						{
d409 1
a409 1
						} 
d411 1
a411 1
						{        
d413 1
a413 1
						}
d419 1
a419 1
						{
d422 1
a422 1
							{
d424 2
a425 2
							}
						} 
d427 1
a427 1
						{        
d429 1
a429 1
						}
d436 1
a436 1
						{
d438 1
a438 1
						}
d440 1
a440 1
						{
d442 1
a442 1
						}
d444 1
a444 1
						{
d446 1
a446 1
						}
d452 1
a452 1
						{
d457 1
a457 1
						}
d459 1
a459 1
						{
d461 1
a461 1
						}
d465 1
a465 1
						{
d470 1
a470 1
						}
d472 1
a472 1
						{
d474 1
a474 1
						}
d479 1
a479 1
						{
d484 1
a484 1
						}
d486 1
a486 1
						{
d488 1
a488 1
						}
d492 1
a492 1
						{
d497 1
a497 1
						}
d499 1
a499 1
						{
d501 1
a501 1
						}
d506 1
a506 1
						{
d509 1
a509 1
						}
d511 1
a511 1
						{
d513 1
a513 1
						}
d515 3
a525 1
				}
d527 2
d530 1
a530 1
			{
d532 2
a533 1
			}
d535 1
a535 1
			{
a536 1
			}
d538 1
a538 1

d541 1
a541 1
		{
d543 2
a544 5
		if(!cf)
			localuser=nullstring;
		else
			localuser=cf->username;
		}
d548 11
a558 3
	s = rcmd(&hostname, 513, localuser, remuser, termtype, (int *)NULL); 
	if(s < 0)
		{
d560 1
a560 2
		}

d564 7
a570 6
		{
		Write((ULONG)Output(),"ioctl\n", 6L);
		}
	if(console_init(hostname,screen) < 0)
		{
		Write((long)Output(), "Could not initialize console\n", 29L);
d573 1
a573 1
		}
d575 1
d577 1
a577 1
		{
d579 2
a580 2
        }
	oldwin_y = (int)win->Height ;
d582 2
a583 2
	netevent = 1L << socket_sigio;
	urgevent = 1L << socket_sigurg;
d585 2
d588 3
d592 2
a593 3
		event = Wait( netevent | urgevent | cons_kybd_sigF | SIGBREAKF_CTRL_C);
		if( event & SIGBREAKF_CTRL_C )
			exiting = 1 ;
d595 2
a596 2
			{
			c = (unsigned char)(console_getchar() & 0xff) ;
d600 1
a600 1
				{              
d605 2
d608 1
a608 1
					if( c == CON_IDCMP_REPORT ) 
d610 2
a611 1
						if( CON_CLOSEGAD( hbuf ))
a612 2
							console_write( closegad_off, 4 ) ;
							if((exiting = ASKEXIT) == 0)
d615 5
d621 1
a621 1
							{
d624 2
a626 2
								if( win->Height < oldwin_y )
									{
a627 1
									}
d629 11
a639 1
							oldwin_y = (int)win->Height ;
d642 8
d651 1
a651 1
						{
a652 3
						}
					bcnt = 0 ;
					incontrol = 0 ;
d654 1
d656 1
d658 1
a658 1
				{
d664 7
d672 1
a672 1
			else 
d674 2
a675 3
				send(s, &c, 1, 0);
				bcnt = 0 ;
				incontrol = 0 ;
d678 1
d681 3
a683 3
			{
			(void)handle_oob(s) ;
			}
d686 1
a686 1
			{
d696 2
a698 6

				/* handle CTRL-G separately so it's less obnoxious */
				/* console wants to DisplayBeep( NULL ) */

				if((SetSignal(0L,0L)) & urgevent )
					{
d700 1
a700 1
					}                   
d702 3
a704 6
				if( console_char_ready() )
					{
					dobreak = 1 ;
					}

				for( cnt = 0, bp = (unsigned char *)&buf ; cnt < cc ; cnt++, bp++  )
a705 2
					if( (*bp > 127) && (*bp < 160) )
						{
a706 1
						}
d708 1
d710 2
d713 1
a713 1
					{
d715 1
a715 1
					}
d717 1
a717 1
					{
d720 1
a720 1
						{
a721 1
						}
d723 1
d725 1
a725 1
					{
a727 1
					}
d729 1
d732 2
d735 23
a757 3
				if( errno == 0 && cc <= 0 )
					exiting = 1 ;
				} 
d759 2
a760 2

	} while ( !exiting ) ;
d763 3
a765 2
	console_close() ;
	exit(RETURN_OK) ;
d773 1
a773 1
static 
d777 3
a779 3
		char ws_magic[4] ;                   /* magic escape sequence */
		unsigned short ws_row, ws_col ;      /* screen size in chars  */
		unsigned short ws_width, ws_height ; /* screen size in pixels */
d790 4
a793 4
	ws.ws_row = htons(rows) ;
	ws.ws_col = htons(cols) ;
	ws.ws_width = htons(width) ;
	ws.ws_height = htons(height) ;
d802 2
a803 2
void
handle_oob( int s)
d805 2
a806 2
	char c;
	static char waste[1024];
d809 1
a809 1
		{ 
d812 1
a812 1
			{
d814 1
a814 1
			}
d816 1
a816 1
		}
d819 1
a819 1
		{
d821 1
a821 1
		}
d823 2
a824 2
	if(c & TIOCPKT_FLUSHWRITE){

d826 2
a827 2
			{
			long atmark ;
d832 1
a832 1
				{
d835 1
a835 1
				}
d837 1
a837 1
				{
d839 1
a839 1
				}
d842 1
a842 1
				{
a843 1
				}
d846 1
d848 1
a848 1
		{
d851 1
a851 1
		}
d853 1
a853 1
		{
d856 1
a856 1
		}
d858 1
a858 1
		{
d861 1
a861 1
		}
d863 1
a863 1
		{
d866 1
a866 1
		}
d869 1
a869 1
		{
d872 1
a872 1
		}
a875 1

d882 2
a883 2
void
FlashBar( void )
d885 3
a887 3
	struct RastPort *rp = win->RPort ;
	long w = (long)win->Width ;
	long h = (long)win->BorderTop ;
d903 2
a904 2
int
AskExit( long wide, long high )
d907 1
a907 4
	STATIC struct TextAttr ta ;
	register struct TextFont *tfptr ;

	static struct IntuiText pos = {
d913 1
a913 1
	static struct IntuiText neg = {
d919 1
a919 1
	static struct IntuiText body = {
d925 1
a925 89
	if( V20 == 0 ) 
		{
		tfptr         = win->RPort->Font ;
		ta.ta_Name    = tfptr->tf_Message.mn_Node.ln_Name ;
		ta.ta_YSize   = tfptr->tf_YSize ; 
		ta.ta_Style   = tfptr->tf_Style ;                             
		ta.ta_Flags   = tfptr->tf_Flags ;
		pos.ITextFont = neg.ITextFont = body.ITextFont = &ta ;
		body.TopEdge  = 4 ;
		wide = (long)(IntuiTextLength( &body ) + (3 * BODYLEFTOFFSET)) ;                 
		high = (long)(6 * tfptr->tf_YSize ) ;                              
		}

	return(AutoRequest(win,&body,&pos, &neg, 0L,0L, wide, high)) ;
}


/* ======================================================================
 * gethostent()
 *
 * This code is cloned from the socket library for the purpose
 * of controlling the hostent structure's variable alignments.
 * Should be removed if the library code is ok.
 *
 *   11-27-90
 * ======================================================================
 */
 
char    *_host_file = HOSTFILE ;
FILE    *rlhostf = NULL;
char    gheline[BUFSIZ+1];
struct  hostent host;
char    *host_aliases[MAXALIASES];
char    *host_addrs[] = { &ghe_hostaddr[0], NULL } ;

struct hostent *
gethostent()
{
	char *p;
	register char *cp, **q;

	if (rlhostf == NULL && (rlhostf = fopen(_host_file, "r" )) == NULL)
		{
		return (NULL);
        }
again:
	if ((p = fgets(gheline, BUFSIZ, rlhostf)) == NULL)
		{
		return (NULL);
		}
	if (*p == '#')
		goto again;
	cp = any(p, "#\n");
	if (cp == NULL)
		goto again;
	*cp = '\0';
	cp = any(p, " \t");
	if (cp == NULL)
		goto again;
	*cp++ = '\0';
	/* THIS STUFF IS INTERNET SPECIFIC */
	
	host.h_addr_list = host_addrs;
	
		/* 68000 will explode if dest here is not word aligned! */
	*((u_long *)host.h_addr) = (u_long)inet_addr(p) ;   /* <<<<<----  */
	
	host.h_length = sizeof (u_long);
	host.h_addrtype = AF_INET;
	while (*cp == ' ' || *cp == '\t')
		cp++;
	host.h_name = cp ;
	q = host.h_aliases = host_aliases ;
	cp = any(cp, " \t");
	if (cp != NULL) 
		*cp++ = '\0';
	while (cp && *cp) {
		if (*cp == ' ' || *cp == '\t') {
			cp++;
			continue;
		}
		if (q < &host_aliases[MAXALIASES - 1])
			*q++ = cp;
		cp = any(cp, " \t");
		if (cp != NULL)
			*cp++ = '\0';
	}
	*q = NULL;
	return (&host);
d928 1
d930 1
d934 2
a935 2
static char *
any( char *cp, char *match)
d937 8
a944 1
	register char *mp, c;
d946 6
a951 5
	while (c = *cp) {
		for (mp = match; *mp; mp++)
			if (*mp == c)
				return (cp);
		cp++;
a952 1
	return ((char *)0);
d955 4
a958 3
/* ========================================================================
 * replacement CXBRK() for Lattice and _abort() for Manx
 * ========================================================================
d961 55
a1015 1
#ifdef LATTICE
d1018 1
a1018 1
CXBRK(void)
d1020 40
a1059 1
	return(0);
d1062 45
a1106 6
#else /* manx */

int
_abort(void)
{
	return(0) ;
a1107 2

#endif
@


1.10
log
@Details and formatting. Nothing functional.
@
text
@d6 1
a6 1
 * $Id: rlogin.c,v 1.9 91/02/13 16:44:11 bj Exp $
d8 1
a8 1
 * $Revision: 1.9 $
d11 3
d50 1
a50 1
 * $Header: HOG:Other/inet/src/c/rlogin/RCS/rlogin.c,v 1.9 91/02/13 16:44:11 bj Exp $ 
d430 1
a499 1

a512 1

@


1.9
log
@Fixed Ctrl-C fixes. 
Fixed loss of escape sequences in vi and emacs.
Different OOB Data handling.
@
text
@d6 1
a6 1
 * $Id: rlogin.c,v 1.8 91/01/31 13:42:58 bj Exp $
d8 1
a8 1
 * $Revision: 1.8 $
d11 5
d47 1
a47 1
 * $Header: HOG:Other/inet/src/c/rlogin/RCS/rlogin.c,v 1.8 91/01/31 13:42:58 bj Exp $ 
d159 6
d166 6
a178 3
int resize = 1 ;
int top_x  = 0 ;
int top_y  = 0 ;
d180 4
a183 1
char *nullstring = "\0";
a239 1
		exit(0) ;
a253 1
					
d259 2
a260 1
					if( argv[argcount] && argv[argcount][0] != '-' ) {
d262 3
a264 1
					} else {        
a265 1
						exit( 10 ) ;
a281 1
						exit( 10 ) ;
a313 1
						exit(10) ;
a326 1
						exit( 10 ) ;
a340 1
						exit(10) ;
a353 1
						exit( 10 ) ;
a365 1
						exit( 10 ) ;
a369 1
					exit(0) ;
a373 1
					exit(10) ;
a380 1
			exit(10) ;
a384 1
			exit(10) ;
d497 1
a497 1
					/* --------------------------------------------- */
d503 1
a503 1
					/* --------------------------------------------- */
a514 1
				    break ;
a518 1
					Delay( 3L ) ;
d530 1
a530 1
				if( (*buf != 0x07 ) || (screen == 1))
d556 1
a556 1
	} while ( exiting == 0 ) ;
d563 5
d592 5
d605 1
d607 4
a610 2
			return;
		recv(s,waste,sizeof(waste),0);
d617 1
d622 2
a623 2
			long atmark;
			int n;
d625 1
a625 1
			atmark = 0;
d629 1
a629 1
				break;
d633 1
a633 1
				break;
d638 1
a638 1
				break;
d672 4
a675 6
/* ------------------------------------------
 * flash the menu bar as a replacement for 
 * the highly obnoxious DisplayBeep( NULL )
 * that the console device does when it's fed
 * a CTRL-G
 * -----------------------------------------
d703 2
a704 2
STATIC struct TextAttr ta ;
register struct TextFont *tfptr ;
d726 1
a726 1
		tfptr = win->RPort->Font ;
d741 1
a741 9
char	*_host_file = HOSTFILE ;
FILE *rlhostf = NULL;
char gheline[BUFSIZ+1];
/* char ghe_hostaddr[MAXADDRSIZE];   NO! compiler doesn't word align!*/
struct hostent host;
char *host_aliases[MAXALIASES];
char *host_addrs[] = {	&ghe_hostaddr[0], NULL } ;

/* -------------------------------------------------------
d746 2
d749 1
a749 1
 * -------------------------------------------------------
d752 7
d815 3
a818 1

d833 6
d843 9
a851 1
return(0);
d853 3
@


1.8
log
@details of no functional value.
@
text
@d6 1
a6 1
 * $Id: rlogin.c,v 1.7 91/01/31 12:06:18 bj Exp $
d8 1
a8 1
 * $Revision: 1.7 $
d11 3
d42 1
a42 1
 * $Header: HOG:Other/inet/src/c/rlogin/RCS/rlogin.c,v 1.7 91/01/31 12:06:18 bj Exp $ 
d179 1
a179 1
	char *termtype = "network/9600" ;   /* must have */
d187 2
a503 5
				if((SetSignal(0L,0L)) & SIGBREAKF_CTRL_C )
					{
					SetSignal(0L,SIGBREAKF_CTRL_C) ;
					break ;
					}                   
d507 2
a508 1
					break ;
d514 1
a514 1
					continue ;
d537 5
d586 57
a642 1

d644 1
a644 1
	if(recv(s, &c, sizeof(c), MSG_OOB) > 0)
d646 2
a647 54
		if(c & TIOCPKT_WINDOW)
			{
			send_window_size(s ) ;
			}
		if(c & TIOCPKT_FLUSHWRITE){
			for (;;) 
				{
				static char waste[512];
				long atmark;
				int n;

				atmark = 0;
				if (ioctl(s, SIOCATMARK, &atmark) < 0) 
					{
					Write((LONG)Output(),"ioctl\n", 6L);
					break;
					}
				if (atmark)
					{
					break;
					}

				if((n = read(s, waste, sizeof(waste))) <= 0)
					{
					break;
					}
				}
			}
		if(c & TIOCPKT_NOSTOP)
			{
			DB1("oob: nostop\n") ;
			/* Not implemented */
			}
		if(c & TIOCPKT_DOSTOP)
			{
			DB1("oob: dostop\n") ;
			/* Not implemented */
			}
		if(c & TIOCPKT_FLUSHREAD)
			{
			DB1("oob: flushread\n") ;
			/* Not implemented */
			}
		if(c & TIOCPKT_STOP)
			{
			DB1("oob: stop\n") ;
			/* Not implemented */
			}
		
		if(c & TIOCPKT_START)
			{
			DB1("oob: start\n") ;
			/* Not implemented */
			}
d651 2
d811 7
@


1.7
log
@Switched to Lattice 5.10
Fixes to allow better (faster) control-c handling when
aborting something on the net (like ls).
Fixed handling of command line completion.
@
text
@d6 1
a6 1
 * $Id: rlogin.c,v 1.5 90/12/02 06:02:54 bj Exp $
d8 1
a8 1
 * $Revision: 1.5 $
d11 12
d39 1
a39 1
 * $Header: inet2:src/c/rlogin/RCS/rlogin.c,v 1.5 90/12/02 06:02:54 bj Exp $ 
@


1.6
log
@Changed termtype default from 'network' to 'RLamiga'
to support a unique termcap entry on large systems.
The only change made for v14.
@
text
@d2 1
a2 1
 * RLOGIN.C  (Lattice 5.05 )
d4 1
a4 1
 * $Locker: bj $
d6 1
a6 1
 * $Id: rlogin.c,v 1.5 90/12/02 06:02:54 bj Exp Locker: bj $
d27 1
a27 1
 * $Header: HOG:Other/inet/src/c/rlogin/RCS/rlogin.c,v 1.5 90/12/02 06:02:54 bj Exp Locker: bj $ 
d32 10
d120 1
a120 1
static char buf[1024];
d164 1
a164 1
	char *termtype = "RLamiga/9600" ;   /* must have */
d169 3
a171 1
    int exiting = 0 ;
d194 1
a194 1
 *	-w or -x or -y automatically toggles the use of a window  	
d208 2
a209 1
	else {
d406 2
d472 9
d483 1
d486 26
d527 4
a530 4
					{
					console_close();
					event |= SIGBREAKF_CTRL_C;
					} 
d533 1
a533 2

	} while ( (!(event & SIGBREAKF_CTRL_C)) && exiting == 0);
d594 1
a594 1
   				if((n = read(s, waste, sizeof(waste))) <= 0)
d602 1
d607 1
d612 1
d617 1
d623 1
@


1.5
log
@replaced selectwait() with Wait() call
made async, fixed occassional pauses
faster and 3.5K smaller
@
text
@d4 1
a4 1
 * $Locker:  $
d6 1
a6 1
 * $Id: rlogin.c,v 1.4 90/11/29 15:09:34 bj Exp $
d8 1
a8 1
 * $Revision: 1.4 $
d11 5
d27 1
a27 1
 * $Header: inet2:src/c/rlogin/RCS/rlogin.c,v 1.4 90/11/29 15:09:34 bj Exp $ 
d154 1
a154 1
	char *termtype = "network/9600" ;   /* must have */
@


1.4
log
@Had to go back to 5.05 Lattice to get rid of a crash
caused by unknown 5.10x artifacts (still unknown)
@
text
@d6 1
a6 1
 * $Id: rlogin.c,v 1.3 90/11/28 00:32:20 bj Exp $
d8 1
a8 1
 * $Revision: 1.3 $
d11 4
d22 1
a22 1
 * $Header: HOG:Other/inet/src/c/rlogin/RCS/rlogin.c,v 1.3 90/11/28 00:32:20 bj Exp $ 
d116 1
a116 1
char *use = " usage:\n rlogin host [-l id] [-x #] [-y #] [-w #] [-h #] [-r] [-c] [-t t/b ] [-u #]\n" ;
d143 1
a143 1
	fd_set ibits, ebits;
d145 1
a145 1
	int s, cc, ns;
d147 1
a147 1
	long event;
a185 1

a357 1

d366 1
a366 1
	if(ioctl(s, FIONBIO, &cc) < 0)
a369 1

a375 1

d383 5
a387 10

	do {
		FD_ZERO(&ibits);
		FD_ZERO(&ebits);
		FD_SET(s, &ibits);
		FD_SET(s, &ebits);
		event = cons_kybd_sigF | SIGBREAKF_CTRL_C ;

		ns = selectwait(s+1, &ibits, 0L, &ebits, 0L, &event);

d445 1
a445 1
		if(FD_ISSET(s, &ebits))
d450 1
a450 1
		if(FD_ISSET(s, &ibits))
d452 1
a452 10
			if((cc = recv(s, buf, sizeof(buf), 0)) <= 0)
				{
				if((cc < 0) && (errno == EWOULDBLOCK))
					{
					continue;
					}
				console_close();
				event |= SIGBREAKF_CTRL_C;
				} 
			else 
d469 6
d476 1
@


1.3
log
@Fixed bug whereby rlogin would crash on 68000 machines. This was due to a non-word
aligned array in the hostent structure used in gethostent() in the socket library.
Made this array a global under rlogin and extracted the gethostenet() code from
the socket library to be used here in rlogin.  Seems to work ok now.
@
text
@d2 1
a2 1
 * RLOGIN.C  (Lattice 5.05)
d6 1
a6 1
 * $Id: rlogin.c,v 1.2 90/11/13 15:18:27 bj Exp $
d8 1
a8 1
 * $Revision: 1.2 $
d10 7
a16 1
 * $Log$
d18 1
a18 1
 * $Header: HOG:Other/inet/src/c/rlogin/RCS/rlogin.c,v 1.2 90/11/13 15:18:27 bj Exp $ 
d24 1
a24 1
		
d68 7
a74 7
    /*                                                        */
    /* array being NOT word-aligned. When gethostent() tried  */
    /* write a LONG value into (long *)ghe_hostaddr, BANG!    */
    /* Solved (for now) by making the ghe_hostaddr[] array a  */
    /* global for RLOGIN.  The question remains as to why the */
    /* compiler is not aligning this.                         */
    /* -------------------------------------------------------*/
a116 1
int AskExit20( void ) ;
d410 1
a410 2
							exiting = ASKEXIT ;
							if( exiting == 0 )
d457 1
a457 2
			cc = recv(s, buf, sizeof(buf), 0);
			if(cc <= 0)
d459 1
a459 1
				if(cc < 0 && errno == EWOULDBLOCK)
d546 1
a546 2
   				n = read(s, waste, sizeof(waste));
				if(n <= 0)
@


1.2
log
@Changed console escape code handing to convert Amiga console's
0X9b escape codes to 'standard' "0x1b 0x5b" escapes. 
@
text
@d4 1
a4 1
 * $Locker$
d6 1
a6 1
 * $Id$
d8 1
a8 1
 * $Revision$
d10 1
a10 1
 * $Header: HOG:Other/inet/src/c/rlogin/RCS/rlogin.c,v 1.1 90/11/02 15:56:31 bj Exp Locker: bj $ 
d12 2
d18 2
d56 18
d113 1
a115 1

d132 1
a132 1
	char *host = NULL, *remuser, *localuser = NULL ;
d177 1
d184 1
a184 1
		host = argv[1] ;
d186 1
d338 1
d350 2
a351 1
	s = rcmd(&host, 513, localuser, remuser, termtype, (int *)NULL); 
d357 1
d364 1
a364 1
	if(console_init(host,screen) < 0)
d378 1
d645 88
@


1.1
log
@Initial revision
@
text
@d1 10
a10 2
/*
 * rlogin.c - simple rlogin protocol client.
d12 1
a12 1
 *   $Header$ 
d31 1
a31 1

a44 2
#define CON_CLOSEGAD(b) (((b)[1] == 0x31 && (b)[2] == 0x31))
#define CON_RESIZE(b)   (((b)[1] == 0x31 && (b)[2] == 0x32))
d47 6
d407 2
d490 1
@
