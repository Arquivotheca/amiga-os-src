head     2.2;
branch   ;
access   ;
symbols  Release1:1.1;
locks    ; strict;
comment  @ * @;


2.2
date     92.11.10.16.20.15;  author bj;  state Exp;
branches ;
next     2.1;

2.1
date     92.10.30.11.25.26;  author bj;  state Exp;
branches ;
next     2.0;

2.0
date     92.07.20.12.51.33;  author bj;  state Exp;
branches ;
next     1.1;

1.1
date     90.11.06.18.03.54;  author bj;  state Exp;
branches ;
next     ;


desc
@cmds.c file for FTP (Manx 3.6)
@


2.2
log
@Binary 2.6

Changed buffer 'temp' in remglob() to static. Added conditional debug code.
@
text
@/* -----------------------------------------------------------------------
 * cmds.c    SAS C version   
 *
 * $Locker:  $
 *
 * $Id: cmds.c,v 2.1 92/10/30 11:25:26 bj Exp $
 *
 * $Revision: 2.1 $
 *
 * $Log:	cmds.c,v $
 * Revision 2.1  92/10/30  11:25:26  bj
 * Binary 2.3
 * 
 * Removed extra copyright notice
 * 
 * Revision 2.0  92/07/20  12:51:33  bj
 * This is the first SAS c version. This is the first release to PA & BIX
 * for the new AS225 R2 release testing.  Straight from Martin. Rewritten
 * from scratch.
 * 
 *
 * $Header: AS225:src/c/ftp/RCS/cmds.c,v 2.1 92/10/30 11:25:26 bj Exp $
 *
 *------------------------------------------------------------------------
 */
/*
 * Copyright (c) 1985, 1989 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

// #define DEBUG 1
#ifdef DEBUG
	#define DB1(x,y) kprintf((x),(y))
#else
	#define DB1(x,y) ;
#endif
	


/*
 * FTP User Program -- Command Routines.
 */
#include <sys/param.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/socket.h>

#include <arpa/ftp.h>

#include <signal.h>
#include <stdio.h>
#include <errno.h>
#include <netdb.h>
#include <ctype.h>
#include <time.h>
#include <netinet/in.h>

#include "ftp.h"
#include "pathnames.h"

extern	char *globerr;
extern	char **ftpglob();
extern	char *home;
extern	char *remglob();
extern	char *getenv();
extern	int  errno;
extern off_t restart_point;
extern char reply_string[];

char *mname;
jmp_buf jabort;

/* prototypes for functions in cmds.c */
int another(int *, char ***, char *);
void settype(int argc, char *argv[]);
void changetype(int newtype, int show);
void setbinary(void);
void setascii(void);
void settenex(void);
void setmode(int, char **);
void setform(int, char **);
void setstruct(int, char **);
void put(int, char **);
void mput(int, char **);
int getit(int argc, char *argv[], int restartit, char *mode);
void mabort(void);
void mget(int, char **);
char *remglob(char **, int);
char *onoff(int);
void status(int, char **);
void setbell(void);
void settrace(void);
void sethash(void);
void setverbose(void);
void setport(void);
void setprompt(void);
void setglob(void);
void setdebug(int, char **);
void cd(int, char **);
void lcd(int, char **);
void delete(int, char **);
void mdelete(int, char **);
void renamefile(int, char **);
void ls(int, char **);
void mls(int, char **);
void shell(int, char **);
int  user(int, char **);
void pwd(void);
void makedir(int, char **);
void removedir(int, char **);
void quote(int, char **);
void site(int, char **);
void quote1(char *,int, char **);
void do_chmod(int, char **);
void do_umask(int, char **);
void idle(int, char **);
void rmthelp(int, char **);
void quit(void);
void disconnect(void);
int confirm(char *, char *);
void fatal(char *);
int globulize(char **);
void account(int, char **);
void proxabort(void);
void doproxy(int, char **);
void setcase(void);
void setcr(void);
void setntrans(int, char **);
char *dotrans(char *);
void setnmap(int, char **);
char *domap(char *);
void setsunique(void);
void setrunique(void);
void cdup(void);
void restrat(int, char **);
void syst(void);
void macdef(int, char **);
void sizecmd(int, char **);
void modtime(int, char **);
void rmtstatus(int, char **);
void newer(int, char **);


/*
 * `Another' gets another argument, and stores the new argc and argv.
 * It reverts to the top level (via main.c's intr()) on EOF/error.
 *
 * Returns false if no new arguments have been added.
 */
another(pargc, pargv, prompt)
	int *pargc;
	char ***pargv;
	char *prompt;
{
	int len = strlen(line), ret;
	extern sig_t intr();

	if (len >= sizeof(line) - 3) {
		printf("sorry, arguments too long\n");
		intr();
	}
	printf("(%s) ", prompt);
	line[len++] = ' ';
	if (fgets(&line[len], sizeof(line) - len, stdin) == NULL)
		intr();
	len += strlen(&line[len]);
	if (len > 0 && line[len - 1] == '\n')
		line[len - 1] = '\0';
	makeargv();
	ret = margc > *pargc;
	*pargc = margc;
	*pargv = margv;
	return (ret);
}

/*
 * Connect to peer server and
 * auto-login, if possible.
 */
void setpeer(argc, argv)
	int argc;
	char *argv[];
{
	char *host, *hookup();
	short port;

	if (connected) {
		printf("Already connected to %s, use close first.\n",
			hostname);
		code = -1;
		return;
	}
	if (argc < 2)
		(void) another(&argc, &argv, "to");
	if (argc < 2 || argc > 3) {
		printf("usage: %s host-name [port]\n", argv[0]);
		code = -1;
		return;
	}
	port = sp->s_port;
	if (argc > 2) {
		port = atoi(argv[2]);
		if (port <= 0) {
			printf("%s: bad port number-- %s\n", argv[1], argv[2]);
			printf ("usage: %s host-name [port]\n", argv[0]);
			code = -1;
			return;
		}
		port = htons(port);
	}
	host = hookup(argv[1], port);
	if (host) {
		int overbose;

		connected = 1;
		/*
		 * Set up defaults for FTP.
		 */
		(void) strcpy(typename, "ascii"), type = TYPE_A;
		curtype = TYPE_A;
		(void) strcpy(formname, "non-print"), form = FORM_N;
		(void) strcpy(modename, "stream"), mode = MODE_S;
		(void) strcpy(structname, "file"), stru = STRU_F;
		(void) strcpy(bytename, "8"), bytesize = 8;
		if (autologin)
			(void) login(argv[1]);

#if defined(unix) && NBBY == 8
/*
 * this ifdef is to keep someone form "porting" this to an incompatible
 * system and not checking this out. This way they have to think about it.
 */
		overbose = verbose;
		if (debug == 0)
			verbose = -1;
		if (command("SYST") == COMPLETE && overbose) {
			register char *cp, c;
			cp = index(reply_string+4, ' ');
			if (cp == NULL)
				cp = index(reply_string+4, '\r');
			if (cp) {
				if (cp[-1] == '.')
					cp--;
				c = *cp;
				*cp = '\0';
			}

			printf("Remote system type is %s.\n",
				reply_string+4);
			if (cp)
				*cp = c;
		}
		if (!strncmp(reply_string, "215 UNIX Type: L8", 17)) {
			if (proxy)
				unix_proxy = 1;
			else
				unix_server = 1;
			/*
			 * Set type to 0 (not specified by user),
			 * meaning binary by default, but don't bother
			 * telling server.  We can use binary
			 * for text files unless changed by the user.
			 */
			type = 0;
			(void) strcpy(typename, "binary");
			if (overbose)
			    printf("Using %s mode to transfer files.\n",
				typename);
		} else {
			if (proxy)
				unix_proxy = 0;
			else
				unix_server = 0;
			if (overbose && 
			    !strncmp(reply_string, "215 TOPS20", 10))
				printf(
"Remember to set tenex mode when transfering binary files from this machine.\n");
		}
		verbose = overbose;
#endif /* unix */
	}
}

struct	types {
	char	*t_name;
	char	*t_mode;
	int	t_type;
	char	*t_arg;
} types[] = {
	{ "ascii",	"A",	TYPE_A,	0 },
	{ "binary",	"I",	TYPE_I,	0 },
	{ "image",	"I",	TYPE_I,	0 },
	{ "ebcdic",	"E",	TYPE_E,	0 },
	{ "tenex",	"L",	TYPE_L,	bytename },
	0
};

/*
 * Set transfer type.
 */
void settype(argc, argv)
	int argc;
	char *argv[];
{
	register struct types *p;
	int comret;

	if (argc > 2) {
		char *sep;

		printf("usage: %s [", argv[0]);
		sep = " ";
		for (p = types; p->t_name; p++) {
			printf("%s%s", sep, p->t_name);
			sep = " | ";
		}
		printf(" ]\n");
		code = -1;
		return;
	}
	if (argc < 2) {
		printf("Using %s mode to transfer files.\n", typename);
		code = 0;
		return;
	}
	for (p = types; p->t_name; p++)
		if (strcmp(argv[1], p->t_name) == 0)
			break;
	if (p->t_name == 0) {
		printf("%s: unknown mode\n", argv[1]);
		code = -1;
		return;
	}
	if ((p->t_arg != NULL) && (*(p->t_arg) != '\0'))
		comret = command ("TYPE %s %s", p->t_mode, p->t_arg);
	else
		comret = command("TYPE %s", p->t_mode);
	if (comret == COMPLETE) {
		(void) strcpy(typename, p->t_name);
		curtype = type = p->t_type;
	}
}

/*
 * Internal form of settype; changes current type in use with server
 * without changing our notion of the type for data transfers.
 * Used to change to and from ascii for listings.
 */
void changetype(newtype, show)
	int newtype, show;
{
	register struct types *p;
	int comret, oldverbose = verbose;

	if (newtype == 0)
		newtype = TYPE_I;
	if (newtype == curtype)
		return;
	if (debug == 0 && show == 0)
		verbose = 0;
	for (p = types; p->t_name; p++)
		if (newtype == p->t_type)
			break;
	if (p->t_name == 0) {
		printf("ftp: internal error: unknown type %d\n", newtype);
		return;
	}
	if (newtype == TYPE_L && bytename[0] != '\0')
		comret = command("TYPE %s %s", p->t_mode, bytename);
	else
		comret = command("TYPE %s", p->t_mode);
	if (comret == COMPLETE)
		curtype = newtype;
	verbose = oldverbose;
}

char *stype[] = {
	"type",
	"",
	0
};

/*
 * Set binary transfer type.
 */
/*VARARGS*/
void setbinary()
{
	stype[1] = "binary";
	settype(2, stype);
}

/*
 * Set ascii transfer type.
 */
/*VARARGS*/
void setascii()
{
	stype[1] = "ascii";
	settype(2, stype);
}

/*
 * Set tenex transfer type.
 */
/*VARARGS*/
void settenex()
{
	stype[1] = "tenex";
	settype(2, stype);
}

/*
 * Set file transfer mode.
 */
/*ARGSUSED*/
void setmode(argc, argv)
	int argc;
	char *argv[];
{

	printf("We only support %s mode, sorry.\n", modename);
	code = -1;
}

/*
 * Set file transfer format.
 */
/*ARGSUSED*/
void setform(argc, argv)
	int argc;
	char *argv[];
{

	printf("We only support %s format, sorry.\n", formname);
	code = -1;
}

/*
 * Set file transfer structure.
 */
/*ARGSUSED*/
void setstruct(argc, argv)
	int argc;
	char *argv[];
{

	printf("We only support %s structure, sorry.\n", structname);
	code = -1;
}

/*
 * Send a single file.
 */
void put(argc, argv)
	int argc;
	char *argv[];
{
	char *cmd;
	int loc = 0;
	char *oldargv1, *oldargv2;

	if (argc == 2) {
		argc++;
		argv[2] = argv[1];
		loc++;
	}
	if (argc < 2 && !another(&argc, &argv, "local-file"))
		goto usage;
	if (argc < 3 && !another(&argc, &argv, "remote-file")) {
usage:
		printf("usage: %s local-file remote-file\n", argv[0]);
		code = -1;
		return;
	}
	oldargv1 = argv[1];
	oldargv2 = argv[2];
	if (!globulize(&argv[1])) {
		code = -1;
		return;
	}
	/*
	 * If "globulize" modifies argv[1], and argv[2] is a copy of
	 * the old argv[1], make it a copy of the new argv[1].
	 */
	if (argv[1] != oldargv1 && argv[2] == oldargv1) {
		argv[2] = argv[1];
	}
	cmd = (argv[0][0] == 'a') ? "APPE" : ((sunique) ? "STOU" : "STOR");
	if (loc && ntflag) {
		argv[2] = dotrans(argv[2]);
	}
	if (loc && mapflag) {
		argv[2] = domap(argv[2]);
	}
	sendrequest(cmd, argv[1], argv[2],
	    argv[1] != oldargv1 || argv[2] != oldargv2);
}

/*
 * Send multiple files.
 */
void mput(argc, argv)
	int argc;
	char **argv;
{
	extern jmp_buf jabort;
	register int i;
	sig_t oldintr;
	int ointer;
	char *tp;
	void mabort();

	if (argc < 2 && !another(&argc, &argv, "local-files")) {
		printf("usage: %s local-files\n", argv[0]);
		code = -1;
		return;
	}
	mname = argv[0];
	mflag = 1;
//	oldintr = signal(SIGINT, mabort);
	(void) setjmp(jabort);
	if (proxy) {
		char *cp, *tp2, tmpbuf[MAXPATHLEN];

		while ((cp = remglob(argv,0)) != NULL) {
			if (*cp == 0) {
				mflag = 0;
				continue;
			}
			if (mflag && confirm(argv[0], cp)) {
				tp = cp;
				if (mcase) {
					while (*tp && !islower(*tp)) {
						tp++;
					}
					if (!*tp) {
						tp = cp;
						tp2 = tmpbuf;
						while ((*tp2 = *tp) != NULL) {
						     if (isupper(*tp2)) {
						        *tp2 = 'a' + *tp2 - 'A';
						     }
						     tp++;
						     tp2++;
						}
					}
					tp = tmpbuf;
				}
				if (ntflag) {
					tp = dotrans(tp);
				}
				if (mapflag) {
					tp = domap(tp);
				}
				sendrequest((sunique) ? "STOU" : "STOR",
				    cp, tp, cp != tp || !interactive);
				if (!mflag && fromatty) {
					ointer = interactive;
					interactive = 1;
					if (confirm("Continue with","mput")) {
						mflag++;
					}
					interactive = ointer;
				}
			}
		}
//		(void) signal(SIGINT, oldintr);
		mflag = 0;
		return;
	}
	for (i = 1; i < argc; i++) {
		register char **cpp, **gargs;

		if (!doglob) {
			if (mflag && confirm(argv[0], argv[i])) {
				tp = (ntflag) ? dotrans(argv[i]) : argv[i];
				tp = (mapflag) ? domap(tp) : tp;
				sendrequest((sunique) ? "STOU" : "STOR",
				    argv[i], tp, tp != argv[i] || !interactive);
				if (!mflag && fromatty) {
					ointer = interactive;
					interactive = 1;
					if (confirm("Continue with","mput")) {
						mflag++;
					}
					interactive = ointer;
				}
			}
			continue;
		}
		gargs = ftpglob(argv[i]);
		if (globerr != NULL) {
			printf("%s\n", globerr);
			if (gargs) {
				blkfree(gargs);
				free((char *)gargs);
			}
			continue;
		}
		for (cpp = gargs; cpp && *cpp != NULL; cpp++) {
			if (mflag && confirm(argv[0], *cpp)) {
				tp = (ntflag) ? dotrans(*cpp) : *cpp;
				tp = (mapflag) ? domap(tp) : tp;
				sendrequest((sunique) ? "STOU" : "STOR",
				    *cpp, tp, *cpp != tp || !interactive);
				if (!mflag && fromatty) {
					ointer = interactive;
					interactive = 1;
					if (confirm("Continue with","mput")) {
						mflag++;
					}
					interactive = ointer;
				}
			}
		}
		if (gargs != NULL) {
			blkfree(gargs);
			free((char *)gargs);
		}
	}
//	(void) signal(SIGINT, oldintr);
	mflag = 0;
}

void reget(argc, argv)
	int argc;
	char *argv[];
{
	(void) getit(argc, argv, 1, "r+w");
}

void get(argc, argv)
	int argc;
	char *argv[];
{
	(void) getit(argc, argv, 0, restart_point ? "r+w" : "w" );
}

/*
 * Receive one file.
 */
int getit(argc, argv, restartit, mode)
	int argc;
	char *argv[];
	char *mode;
{
	int loc = 0;
	char *oldargv1, *oldargv2;

	if (argc == 2) {
		argc++;
		argv[2] = argv[1];
		loc++;
	}
	if (argc < 2 && !another(&argc, &argv, "remote-file"))
		goto usage;
	if (argc < 3 && !another(&argc, &argv, "local-file")) {
usage:
		printf("usage: %s remote-file [ local-file ]\n", argv[0]);
		code = -1;
		return (0);
	}
	oldargv1 = argv[1];
	oldargv2 = argv[2];
	if (!globulize(&argv[2])) {
		code = -1;
		return (0);
	}
	if (loc && mcase) {
		char *tp = argv[1], *tp2, tmpbuf[MAXPATHLEN];

		while (*tp && !islower(*tp)) {
			tp++;
		}
		if (!*tp) {
			tp = argv[2];
			tp2 = tmpbuf;
			while ((*tp2 = *tp) != NULL) {
				if (isupper(*tp2)) {
					*tp2 = 'a' + *tp2 - 'A';
				}
				tp++;
				tp2++;
			}
			argv[2] = tmpbuf;
		}
	}
	if (loc && ntflag)
		argv[2] = dotrans(argv[2]);
	if (loc && mapflag)
		argv[2] = domap(argv[2]);
	if (restartit) {
		struct stat stbuf;
		int ret;
		ret = stat(argv[2], &stbuf);
		if (restartit == 1) {
			if (ret < 0) {
				fprintf(stderr, "local: %s: %s\n", argv[2],
					strerror(errno));
				return (0);
			}
			restart_point = stbuf.st_size;
		} else {
			if (ret == 0) {
				int overbose;

				overbose = verbose;
				if (debug == 0)
					verbose = -1;
				if (command("MDTM %s", argv[1]) == COMPLETE) {
					int yy, mo, day, hour, min, sec;
					struct tm *tm;
					verbose = overbose;
					sscanf(reply_string,
					    "%*s %04d%02d%02d%02d%02d%02d",
					    &yy, &mo, &day, &hour, &min, &sec);
					tm = gmtime(&stbuf.st_mtime);
					tm->tm_mon++;
					if (tm->tm_year > yy%100)
						return (1);
					else if (tm->tm_year == yy%100) {
						if (tm->tm_mon > mo)
							return (1);
					} else if (tm->tm_mon == mo) {
						if (tm->tm_mday > day)
							return (1);
					} else if (tm->tm_mday == day) {
						if (tm->tm_hour > hour)
							return (1);
					} else if (tm->tm_hour == hour) {
						if (tm->tm_min > min)
							return (1);
					} else if (tm->tm_min == min) {
						if (tm->tm_sec > sec)
							return (1);
					}
				} else {
					printf("%s\n", reply_string);
					verbose = overbose;
					return (0);
				}
			}
		}
	}

	recvrequest("RETR", argv[2], argv[1], mode,
	    argv[1] != oldargv1 || argv[2] != oldargv2);
	restart_point = 0;
	return (0);
}

void
mabort()
{
	int ointer;
	extern jmp_buf jabort;

	printf("\n");
	(void) fflush(stdout);
	if (mflag && fromatty) {
		ointer = interactive;
		interactive = 1;
		if (confirm("Continue with", mname)) {
			interactive = ointer;
			longjmp(jabort,0);
		}
		interactive = ointer;
	}
	mflag = 0;
	longjmp(jabort,0);
}

/*
 * Get multiple files.
 */
void mget(argc, argv)
	int argc;
	char **argv;
{
	extern jmp_buf jabort;
	sig_t oldintr;
	int i, ointer;
	char *cp, *tp, *tp2, tmpbuf[MAXPATHLEN];
	void mabort();

	if (argc < 2 && !another(&argc, &argv, "remote-files")) {
		printf("usage: %s remote-files\n", argv[0]);
		code = -1;
		return;
	}
	mname = argv[0];
	mflag = 1;
//	oldintr = signal(SIGINT,mabort);
	(void) setjmp(jabort);
	while ((cp = remglob(argv,proxy)) != NULL) {
		DB1("\xFFTP/mget A : *argv = %s\n", *argv) ;
		if (*cp == '\0') {
			mflag = 0;
			continue;
		}
		if (mflag && (i=confirm(argv[0],cp))) {
			if (i==2) mabort(); 
			tp = cp;
			if (mcase) {
				while (*tp && !islower(*tp)) {
					tp++;
				}
				if (!*tp) {
					tp = cp;
					tp2 = tmpbuf;
					while ((*tp2 = *tp) != NULL) {
						if (isupper(*tp2)) {
							*tp2 = 'a' + *tp2 - 'A';
						}
						tp++;
						tp2++;
					}
				}
				tp = tmpbuf;
			}
			if (ntflag) {
				tp = dotrans(tp);
			}
			if (mapflag) {
				tp = domap(tp);
			}
			recvrequest("RETR", tp, cp, "w",
			    tp != cp || !interactive);
			if (!mflag && fromatty) {
				ointer = interactive;
				interactive = 1;
				if (confirm("Continue with","mget")) {
					mflag++;
				}
				interactive = ointer;
			}
		}
	}
//	(void) signal(SIGINT,oldintr);
	mflag = 0;
}
              
char *
remglob(argv,doswitch)
	char *argv[];
	int doswitch;
{
	static char temp[64];
	static char buf[MAXPATHLEN];
	static FILE *ftemp = NULL;
	static char **args;
	int oldverbose, oldhash;
	char *cp, *mode;

	if (!mflag) {
		DB1("\xFFTP/remglob: mflag = 0\n", NULL) ;
		if (!doglob) {
			args = NULL;
		}
		else {
			DB1("\xFFTP/remglob: mflag = %ld\n", (long)mflag) ;
			if (ftemp) {
				(void) fclose(ftemp);
				ftemp = NULL;
			}
		}
		return(NULL);
	}
	if (!doglob) {
		DB1("\xFFTP/remglob: doglob = %ld\n", (long)doglob) ;	
		if (args == NULL)
			args = argv;
		if ((cp = *++args) == NULL)
			args = NULL;
		return (cp);
	}
	if (ftemp == NULL) {
		DB1("FTP/remglob: ftemp = NULL\n", NULL) ;
		(void) strcpy(temp, "t:ftp");
		sprintf(buf,"%ld",(ULONG)FindTask(0));
		strcat(temp,buf);
		
		oldverbose = verbose, verbose = 0;
		oldhash = hash, hash = 0;
		if (doswitch) {
			pswitch(!proxy);
		}
		for (mode = "w"; *++argv != NULL; mode = "a")
			recvrequest ("NLST", temp, *argv, mode, 0);
		if (doswitch) {
			pswitch(!proxy);
		}
		verbose = oldverbose; hash = oldhash;
		ftemp = fopen(temp, "r");
		if (ftemp == NULL) {
			printf("can't find list of remote files, oops\n");
			(void)unlink(temp);
			DB1("Funlink #1 : \xF%s\n", temp) ; /*** debug  ***/
			return (NULL);
		}
	}
	else
	{
		DB1("\xFFTP/remglob: ftemp NOT NULL\n", NULL) ;
	}
	if (fgets(buf, sizeof (buf), ftemp) == NULL) {
		(void) fclose(ftemp) ;
		ftemp = NULL;
		(void)unlink(temp);
		DB1("\xFunlink #2: %s\n", temp) ;  /*** DEBUG ***/
		return (NULL);
	}
	DB1("\xFFTP/remglob: buf = %s\n", buf) ;
	if ((cp = index(buf, '\n')) != NULL)
		*cp = '\0';

	(void)unlink(temp);
	DB1("\xFunlink #3 : %s\n", temp) ;
	return (buf);
}

char *
onoff(bool)
	int bool;
{

	return (bool ? "on" : "off");
}

/*
 * Show status.
 */
/*ARGSUSED*/
void status(argc, argv)
	int argc;
	char *argv[];
{
	int i;

	if (connected)
		printf("Connected to %s.\n", hostname);
	else
		printf("Not connected.\n");
	if (!proxy) {
		pswitch(1);
		if (connected) {
			printf("Connected for proxy commands to %s.\n", hostname);
		}
		else {
			printf("No proxy connection.\n");
		}
		pswitch(0);
	}
	printf("Mode: %s; Type: %s; Form: %s; Structure: %s\n",
		modename, typename, formname, structname);
	printf("Verbose: %s; Bell: %s; Prompting: %s; Globbing: %s\n", 
		onoff(verbose), onoff(bell), onoff(interactive),
		onoff(doglob));
	printf("Store unique: %s; Receive unique: %s\n", onoff(sunique),
		onoff(runique));
	printf("Case: %s; CR stripping: %s\n",onoff(mcase),onoff(crflag));
	if (ntflag) {
		printf("Ntrans: (in) %s (out) %s\n", ntin,ntout);
	}
	else {
		printf("Ntrans: off\n");
	}
	if (mapflag) {
		printf("Nmap: (in) %s (out) %s\n", mapin, mapout);
	}
	else {
		printf("Nmap: off\n");
	}
	printf("Hash mark printing: %s; Use of PORT cmds: %s\n",
		onoff(hash), onoff(sendport));
	if (macnum > 0) {
		printf("Macros:\n");
		for (i=0; i<macnum; i++) {
			printf("\t%s\n",macros[i].mac_name);
		}
	}
	code = 0;
}

/*
 * Set beep on cmd completed mode.
 */
/*VARARGS*/
void setbell()
{

	bell = !bell;
	printf("Bell mode %s.\n", onoff(bell));
	code = bell;
}

/*
 * Turn on packet tracing.
 */
/*VARARGS*/
void settrace()
{

	trace = !trace;
	printf("Packet tracing %s.\n", onoff(trace));
	code = trace;
}

/*
 * Toggle hash mark printing during transfers.
 */
/*VARARGS*/
void sethash()
{

	hash = !hash;
	printf("Hash mark printing %s", onoff(hash));
	code = hash;
	if (hash)
		printf(" (%d bytes/hash mark)", 1024);
	printf(".\n");
}

/*
 * Turn on printing of server echo's.
 */
/*VARARGS*/
void setverbose()
{

	verbose = !verbose;
	printf("Verbose mode %s.\n", onoff(verbose));
	code = verbose;
}

/*
 * Toggle PORT cmd use before each data connection.
 */
/*VARARGS*/
void setport()
{

	sendport = !sendport;
	printf("Use of PORT cmds %s.\n", onoff(sendport));
	code = sendport;
}

/*
 * Turn on interactive prompting
 * during mget, mput, and mdelete.
 */
/*VARARGS*/
void setprompt()
{

	interactive = !interactive;
	printf("Interactive mode %s.\n", onoff(interactive));
	code = interactive;
}

/*
 * Toggle metacharacter interpretation
 * on local file names.
 */
/*VARARGS*/
void setglob()
{
	
	doglob = !doglob;
	printf("Globbing %s.\n", onoff(doglob));
	code = doglob;
}

/*
 * Set debugging mode on/off and/or
 * set level of debugging.
 */
/*VARARGS*/
void setdebug(argc, argv)
	int argc;
	char *argv[];
{
	int val;

	if (argc > 1) {
		val = atoi(argv[1]);
		if (val < 0) {
			printf("%s: bad debugging value.\n", argv[1]);
			code = -1;
			return;
		}
	} else
		val = !debug;
	debug = val;
	if (debug)
		options |= SO_DEBUG;
	else
		options &= ~SO_DEBUG;
	printf("Debugging %s (debug=%d).\n", onoff(debug), debug);
	code = debug > 0;
}

/*
 * Set current working directory
 * on remote machine.
 */
void cd(argc, argv)
	int argc;
	char *argv[];
{

	if (argc < 2 && !another(&argc, &argv, "remote-directory")) {
		printf("usage: %s remote-directory\n", argv[0]);
		code = -1;
		return;
	}
	if (command("CWD %s", argv[1]) == ERROR && code == 500) {
		if (verbose)
			printf("CWD command not recognized, trying XCWD\n");
		(void) command("XCWD %s", argv[1]);
	}
}

/*
 * Set current working directory
 * on local machine.
 */
void lcd(argc, argv)
	int argc;
	char *argv[];
{
	char buf[MAXPATHLEN];
	extern char *getwd();

	if (argc < 2)
		argc++, argv[1] = home;
	if (argc != 2) {
		printf("usage: %s local-directory\n", argv[0]);
		code = -1;
		return;
	}
	if (!globulize(&argv[1])) {
		code = -1;
		return;
	}
	if (chdir(argv[1]) < 0) {
		fprintf(stderr, "local: %s: %s\n", argv[1], strerror(errno));
		code = -1;
		return;
	}
	printf("Local directory now %s\n", getwd(buf));
	code = 0;
}

/*
 * Delete a single file.
 */
void delete(argc, argv)
	int argc;
	char *argv[];
{

	if (argc < 2 && !another(&argc, &argv, "remote-file")) {
		printf("usage: %s remote-file\n", argv[0]);
		code = -1;
		return;
	}
	(void) command("DELE %s", argv[1]);
}

/*
 * Delete multiple files.
 */
void mdelete(argc, argv)
	int argc;
	char **argv;
{
	extern jmp_buf jabort;
	sig_t oldintr;
	int ointer;
	char *cp;
	void mabort();

	if (argc < 2 && !another(&argc, &argv, "remote-files")) {
		printf("usage: %s remote-files\n", argv[0]);
		code = -1;
		return;
	}
	mname = argv[0];
	mflag = 1;
//	oldintr = signal(SIGINT, mabort);
	(void) setjmp(jabort);
	while ((cp = remglob(argv,0)) != NULL) {
		if (*cp == '\0') {
			mflag = 0;
			continue;
		}
		if (mflag && confirm(argv[0], cp)) {
			(void) command("DELE %s", cp);
			if (!mflag && fromatty) {
				ointer = interactive;
				interactive = 1;
				if (confirm("Continue with", "mdelete")) {
					mflag++;
				}
				interactive = ointer;
			}
		}
	}
//	(void) signal(SIGINT, oldintr);
	mflag = 0;
}

/*
 * Rename a remote file.
 */
void renamefile(argc, argv)
	int argc;
	char *argv[];
{

	if (argc < 2 && !another(&argc, &argv, "from-name"))
		goto usage;
	if (argc < 3 && !another(&argc, &argv, "to-name")) {
usage:
		printf("%s from-name to-name\n", argv[0]);
		code = -1;
		return;
	}
	if (command("RNFR %s", argv[1]) == CONTINUE)
		(void) command("RNTO %s", argv[2]);
}

/*
 * Get a directory listing
 * of remote files.
 */
void ls(argc, argv)
	int argc;
	char *argv[];
{
	char *cmd;

	if (argc < 2)
		argc++, argv[1] = NULL;
	if (argc < 3)
		argc++, argv[2] = "-";
	if (argc > 3) {
		printf("usage: %s remote-directory local-file\n", argv[0]);
		code = -1;
		return;
	}
	cmd = argv[0][0] == 'n' ? "NLST" : "LIST";
	if (strcmp(argv[2], "-") && !globulize(&argv[2])) {
		code = -1;
		return;
	}
	if (strcmp(argv[2], "-") && *argv[2] != '|')
		if (!globulize(&argv[2]) || !confirm("output to local-file:", argv[2])) {
			code = -1;
			return;
	}
	recvrequest(cmd, argv[2], argv[1], "w", 0);
}

/*
 * Get a directory listing
 * of multiple remote files.
 */
void mls(argc, argv)
	int argc;
	char **argv;
{
	extern jmp_buf jabort;
	sig_t oldintr;
	int ointer, i;
	char *cmd, mode[1], *dest;
	void mabort();

	if (argc < 2 && !another(&argc, &argv, "remote-files"))
		goto usage;
	if (argc < 3 && !another(&argc, &argv, "local-file")) {
usage:
		printf("usage: %s remote-files local-file\n", argv[0]);
		code = -1;
		return;
	}
	dest = argv[argc - 1];
	argv[argc - 1] = NULL;
	if (strcmp(dest, "-") && *dest != '|')
		if (!globulize(&dest) ||
		    !confirm("output to local-file:", dest)) {
			code = -1;
			return;
	}
	cmd = argv[0][1] == 'l' ? "NLST" : "LIST";
	mname = argv[0];
	mflag = 1;
//	oldintr = signal(SIGINT, mabort);
	(void) setjmp(jabort);
	for (i = 1; mflag && i < argc-1; ++i) {
		*mode = (i == 1) ? 'w' : 'a';
		recvrequest(cmd, dest, argv[i], mode, 0);
		if (!mflag && fromatty) {
			ointer = interactive;
			interactive = 1;
			if (confirm("Continue with", argv[0])) {
				mflag ++;
			}
			interactive = ointer;
		}
	}
//	(void) signal(SIGINT, oldintr);
	mflag = 0;
}

/*
 * Do a shell escape
 */
/*ARGSUSED*/

void shell(argc, argv)
	int argc;
	char **argv;
{
        (void)System(altarg,NULL);
}

/*
 * Send new user information (re-login)
 */
int user(argc, argv)
	int argc;
	char **argv;
{
	char acct[80], *getpass();
	int n, aflag = 0;

	if (argc < 2)
		(void) another(&argc, &argv, "username");
	if (argc < 2 || argc > 4) {
		printf("usage: %s username [password] [account]\n", argv[0]);
		code = -1;
		return (0);
	}
	n = command("USER %s", argv[1]);
	if (n == CONTINUE) {
		if (argc < 3 )
			argv[2] = getpass("Password: "), argc++;
		n = command("PASS %s", argv[2]);
	}
	if (n == CONTINUE) {
		if (argc < 4) {
			printf("Account: "); (void) fflush(stdout);
			(void) fgets(acct, sizeof(acct) - 1, stdin);
			acct[strlen(acct) - 1] = '\0';
			argv[3] = acct; argc++;
		}
		n = command("ACCT %s", argv[3]);
		aflag++;
	}
	if (n != COMPLETE) {
		fprintf(stdout, "Login failed.\n");
		return (0);
	}
	if (!aflag && argc == 4) {
		(void) command("ACCT %s", argv[3]);
	}
	return (1);
}

/*
 * Print working directory.
 */
/*VARARGS*/
void pwd()
{
	int oldverbose = verbose;

	/*
	 * If we aren't verbose, this doesn't do anything!
	 */
	verbose = 1;
	if (command("PWD") == ERROR && code == 500) {
		printf("PWD command not recognized, trying XPWD\n");
		(void) command("XPWD");
	}
	verbose = oldverbose;
}

/*
 * Make a directory.
 */
void makedir(argc, argv)
	int argc;
	char *argv[];
{

	if (argc < 2 && !another(&argc, &argv, "directory-name")) {
		printf("usage: %s directory-name\n", argv[0]);
		code = -1;
		return;
	}
	if (command("MKD %s", argv[1]) == ERROR && code == 500) {
		if (verbose)
			printf("MKD command not recognized, trying XMKD\n");
		(void) command("XMKD %s", argv[1]);
	}
}

/*
 * Remove a directory.
 */
void removedir(argc, argv)
	int argc;
	char *argv[];
{

	if (argc < 2 && !another(&argc, &argv, "directory-name")) {
		printf("usage: %s directory-name\n", argv[0]);
		code = -1;
		return;
	}
	if (command("RMD %s", argv[1]) == ERROR && code == 500) {
		if (verbose)
			printf("RMD command not recognized, trying XRMD\n");
		(void) command("XRMD %s", argv[1]);
	}
}

/*
 * Send a line, verbatim, to the remote machine.
 */
void quote(argc, argv)
	int argc;
	char *argv[];
{

	if (argc < 2 && !another(&argc, &argv, "command line to send")) {
		printf("usage: %s line-to-send\n", argv[0]);
		code = -1;
		return;
	}
	quote1("", argc, argv);
}

/*
 * Send a SITE command to the remote machine.  The line
 * is sent verbatim to the remote machine, except that the
 * word "SITE" is added at the front.
 */
void site(argc, argv)
	int argc;
	char *argv[];
{

	if (argc < 2 && !another(&argc, &argv, "arguments to SITE command")) {
		printf("usage: %s line-to-send\n", argv[0]);
		code = -1;
		return;
	}
	quote1("SITE ", argc, argv);
}

/*
 * Turn argv[1..argc) into a space-separated string, then prepend initial text.
 * Send the result as a one-line command and get response.
 */
void quote1(initial, argc, argv)
	char *initial;
	int argc;
	char **argv;
{
	register int i, len;
	char buf[BUFSIZ];		/* must be >= sizeof(line) */

	(void) strcpy(buf, initial);
	if (argc > 1) {
		len = strlen(buf);
		len += strlen(strcpy(&buf[len], argv[1]));
		for (i = 2; i < argc; i++) {
			buf[len++] = ' ';
			len += strlen(strcpy(&buf[len], argv[i]));
		}
	}
	if (command(buf) == PRELIM) {
		while (getreply(0) == PRELIM);
	}
}

void do_chmod(argc, argv)
	int argc;
	char *argv[];
{

	if (argc < 2 && !another(&argc, &argv, "mode"))
		goto usage;
	if (argc < 3 && !another(&argc, &argv, "file-name")) {
usage:
		printf("usage: %s mode file-name\n", argv[0]);
		code = -1;
		return;
	}
	(void) command("SITE CHMOD %s %s", argv[1], argv[2]);
}

void do_umask(argc, argv)
	int argc;
	char *argv[];
{
	int oldverbose = verbose;

	verbose = 1;
	(void) command(argc == 1 ? "SITE UMASK" : "SITE UMASK %s", argv[1]);
	verbose = oldverbose;
}

void idle(argc, argv)
	int argc;
	char *argv[];
{
	int oldverbose = verbose;

	verbose = 1;
	(void) command(argc == 1 ? "SITE IDLE" : "SITE IDLE %s", argv[1]);
	verbose = oldverbose;
}

/*
 * Ask the other side for help.
 */
void rmthelp(argc, argv)
	int argc;
	char *argv[];
{
	int oldverbose = verbose;

	verbose = 1;
	(void) command(argc == 1 ? "HELP" : "HELP %s", argv[1]);
	verbose = oldverbose;
}

/*
 * Terminate session and exit.
 */
/*VARARGS*/
void quit()
{

	if (connected)
		disconnect();
	pswitch(1);
	if (connected) {
		disconnect();
	}
	exit(0);
}

/*
 * Terminate session, but don't exit.
 */
void disconnect()
{
	extern FILE *cout;
	extern int data;

	if (!connected)
		return;
	(void) command("QUIT");
	if (cout) {
		(void) fclose(cout);
	}
	cout = NULL;
	connected = 0;
	data = -1;
	if (!proxy) {
		macnum = 0;
	}
}

int confirm(cmd, file)
	char *cmd, *file;
{
	char line[BUFSIZ];

	if (!interactive)
		return (1);
	printf("%s %s? ", cmd, file);
	(void) fflush(stdout);
	if (fgets(line, sizeof line, stdin) == NULL)
		return (0);

	/* modified by MMH to allow 'Q' to quit mgets */
	*line = tolower(*line);
	if (*line == 'q')
		return 2;
	if (*line == 'n')
		return 0;
	return 1; 
}

void fatal(msg)
	char *msg;
{

	fprintf(stderr, "ftp: %s\n", msg);
	exit(1);
}

/*
 * Glob a local file name specification with
 * the expectation of a single return value.
 * Can't control multiple values being expanded
 * from the expression, we return only the first.
 */
int globulize(cpp)
	char **cpp;
{
	char **globbed;

	if (!doglob)
		return (1);
	globbed = ftpglob(*cpp);
	if (globerr != NULL) {
		printf("%s: %s\n", *cpp, globerr);
		if (globbed) {
			blkfree(globbed);
			free((char *)globbed);
		}
		return (0);
	}
	if (globbed) {
		*cpp = *globbed++;
		/* don't waste too much memory */
		if (*globbed) {
			blkfree(globbed);
			free((char *)globbed);
		}
	}
	return (1);
}

void account(argc,argv)
	int argc;
	char **argv;
{
	char acct[50], *getpass(), *ap;

	if (argc > 1) {
		++argv;
		--argc;
		(void) strncpy(acct,*argv,49);
		acct[49] = '\0';
		while (argc > 1) {
			--argc;
			++argv;
			(void) strncat(acct,*argv, 49-strlen(acct));
		}
		ap = acct;
	}
	else {
		ap = getpass("Account:");
	}
	(void) command("ACCT %s", ap);
}

jmp_buf abortprox;

void
proxabort()
{
	extern int proxy;

	if (!proxy) {
		pswitch(1);
	}
	if (connected) {
		proxflag = 1;
	}
	else {
		proxflag = 0;
	}
	pswitch(0);
	longjmp(abortprox,1);
}

void doproxy(argc,argv)
	int argc;
	char *argv[];
{
	extern struct cmd cmdtab[];
	extern jmp_buf abortprox;
	register struct cmd *c;
	struct cmd *getcmd();
	sig_t oldintr;
	void proxabort();

	if (argc < 2 && !another(&argc, &argv, "command")) {
		printf("usage: %s command\n", argv[0]);
		code = -1;
		return;
	}
	c = getcmd(argv[1]);
	if (c == (struct cmd *) -1) {
		printf("?Ambiguous command\n");
		(void) fflush(stdout);
		code = -1;
		return;
	}
	if (c == 0) {
		printf("?Invalid command\n");
		(void) fflush(stdout);
		code = -1;
		return;
	}
	if (!c->c_proxy) {
		printf("?Invalid proxy command\n");
		(void) fflush(stdout);
		code = -1;
		return;
	}
	if (setjmp(abortprox)) {
		code = -1;
		return;
	}
//	oldintr = signal(SIGINT, proxabort);
	pswitch(1);
	if (c->c_conn && !connected) {
		printf("Not connected\n");
		(void) fflush(stdout);
		pswitch(0);
//		(void) signal(SIGINT, oldintr);
		code = -1;
		return;
	}
	(*c->c_handler)(argc-1, argv+1);
	if (connected) {
		proxflag = 1;
	}
	else {
		proxflag = 0;
	}
	pswitch(0);
//	(void) signal(SIGINT, oldintr);
}

void setcase()
{
	mcase = !mcase;
	printf("Case mapping %s.\n", onoff(mcase));
	code = mcase;
}

void setcr()
{
	crflag = !crflag;
	printf("Carriage Return stripping %s.\n", onoff(crflag));
	code = crflag;
}

void setntrans(argc,argv)
	int argc;
	char *argv[];
{
	if (argc == 1) {
		ntflag = 0;
		printf("Ntrans off.\n");
		code = ntflag;
		return;
	}
	ntflag++;
	code = ntflag;
	(void) strncpy(ntin, argv[1], 16);
	ntin[16] = '\0';
	if (argc == 2) {
		ntout[0] = '\0';
		return;
	}
	(void) strncpy(ntout, argv[2], 16);
	ntout[16] = '\0';
}

char *
dotrans(name)
	char *name;
{
	static char new[MAXPATHLEN];
	char *cp1, *cp2 = new;
	register int i, ostop, found;

	for (ostop = 0; *(ntout + ostop) && ostop < 16; ostop++);
	for (cp1 = name; *cp1; cp1++) {
		found = 0;
		for (i = 0; *(ntin + i) && i < 16; i++) {
			if (*cp1 == *(ntin + i)) {
				found++;
				if (i < ostop) {
					*cp2++ = *(ntout + i);
				}
				break;
			}
		}
		if (!found) {
			*cp2++ = *cp1;
		}
	}
	*cp2 = '\0';
	return(new);
}

void setnmap(argc, argv)
	int argc;
	char *argv[];
{
	char *cp;

	if (argc == 1) {
		mapflag = 0;
		printf("Nmap off.\n");
		code = mapflag;
		return;
	}
	if (argc < 3 && !another(&argc, &argv, "mapout")) {
		printf("Usage: %s [mapin mapout]\n",argv[0]);
		code = -1;
		return;
	}
	mapflag = 1;
	code = 1;
	cp = index(altarg, ' ');
	if (proxy) {
		while(*++cp == ' ');
		altarg = cp;
		cp = index(altarg, ' ');
	}
	*cp = '\0';
	(void) strncpy(mapin, altarg, MAXPATHLEN - 1);
	while (*++cp == ' ');
	(void) strncpy(mapout, cp, MAXPATHLEN - 1);
}

char *
domap(name)
	char *name;
{
	static char new[MAXPATHLEN];
	register char *cp1 = name, *cp2 = mapin;
	char *tp[9], *te[9];
	int i, toks[9], toknum = 0, match = 1;

	for (i=0; i < 9; ++i) {
		toks[i] = 0;
	}
	while (match && *cp1 && *cp2) {
		switch (*cp2) {
			case '\\':
				if (*++cp2 != *cp1) {
					match = 0;
				}
				break;
			case '$':
				if (*(cp2+1) >= '1' && (*cp2+1) <= '9') {
					if (*cp1 != *(++cp2+1)) {
						toks[toknum = *cp2 - '1']++;
						tp[toknum] = cp1;
						while (*++cp1 && *(cp2+1)
							!= *cp1);
						te[toknum] = cp1;
					}
					cp2++;
					break;
				}
				/* FALLTHROUGH */
			default:
				if (*cp2 != *cp1) {
					match = 0;
				}
				break;
		}
		if (match && *cp1) {
			cp1++;
		}
		if (match && *cp2) {
			cp2++;
		}
	}
	if (!match && *cp1) /* last token mismatch */
	{
		toks[toknum] = 0;
	}
	cp1 = new;
	*cp1 = '\0';
	cp2 = mapout;
	while (*cp2) {
		match = 0;
		switch (*cp2) {
			case '\\':
				if (*(cp2 + 1)) {
					*cp1++ = *++cp2;
				}
				break;
			case '[':
LOOP:
				if (*++cp2 == '$' && isdigit(*(cp2+1))) { 
					if (*++cp2 == '0') {
						char *cp3 = name;

						while (*cp3) {
							*cp1++ = *cp3++;
						}
						match = 1;
					}
					else if (toks[toknum = *cp2 - '1']) {
						char *cp3 = tp[toknum];

						while (cp3 != te[toknum]) {
							*cp1++ = *cp3++;
						}
						match = 1;
					}
				}
				else {
					while (*cp2 && *cp2 != ',' && 
					    *cp2 != ']') {
						if (*cp2 == '\\') {
							cp2++;
						}
						else if (*cp2 == '$' &&
   						        isdigit(*(cp2+1))) {
							if (*++cp2 == '0') {
							   char *cp3 = name;

							   while (*cp3) {
								*cp1++ = *cp3++;
							   }
							}
							else if (toks[toknum =
							    *cp2 - '1']) {
							   char *cp3=tp[toknum];

							   while (cp3 !=
								  te[toknum]) {
								*cp1++ = *cp3++;
							   }
							}
						}
						else if (*cp2) {
							*cp1++ = *cp2++;
						}
					}
					if (!*cp2) {
						printf("nmap: unbalanced brackets\n");
						return(name);
					}
					match = 1;
					cp2--;
				}
				if (match) {
					while (*++cp2 && *cp2 != ']') {
					      if (*cp2 == '\\' && *(cp2 + 1)) {
							cp2++;
					      }
					}
					if (!*cp2) {
						printf("nmap: unbalanced brackets\n");
						return(name);
					}
					break;
				}
				switch (*++cp2) {
					case ',':
						goto LOOP;
					case ']':
						break;
					default:
						cp2--;
						goto LOOP;
				}
				break;
			case '$':
				if (isdigit(*(cp2 + 1))) {
					if (*++cp2 == '0') {
						char *cp3 = name;

						while (*cp3) {
							*cp1++ = *cp3++;
						}
					}
					else if (toks[toknum = *cp2 - '1']) {
						char *cp3 = tp[toknum];

						while (cp3 != te[toknum]) {
							*cp1++ = *cp3++;
						}
					}
					break;
				}
				/* intentional drop through */
			default:
				*cp1++ = *cp2;
				break;
		}
		cp2++;
	}
	*cp1 = '\0';
	if (!*new) {
		return(name);
	}
	return(new);
}

void setsunique()
{
	sunique = !sunique;
	printf("Store unique %s.\n", onoff(sunique));
	code = sunique;
}

void setrunique()
{
	runique = !runique;
	printf("Receive unique %s.\n", onoff(runique));
	code = runique;
}

/* change directory to perent directory */
void cdup()
{
	if (command("CDUP") == ERROR && code == 500) {
		if (verbose)
			printf("CDUP command not recognized, trying XCUP\n");
		(void) command("XCUP");
	}
}

/* restart transfer at specific point */
void restart(argc, argv)
	int argc;
	char *argv[];
{
	extern long atol();
	if (argc != 2)
		printf("restart: offset not specified\n");
	else {
		restart_point = atol(argv[1]);
		printf("restarting at %ld. %s\n", restart_point,
		    "execute get, put or append to initiate transfer");
	}
}

/* show remote system type */
void syst()
{
	(void) command("SYST");
}

void macdef(argc, argv)
	int argc;
	char *argv[];
{
	char *tmp;
	int c;

	if (macnum == 16) {
		printf("Limit of 16 macros have already been defined\n");
		code = -1;
		return;
	}
	if (argc < 2 && !another(&argc, &argv, "macro name")) {
		printf("Usage: %s macro_name\n",argv[0]);
		code = -1;
		return;
	}
	if (interactive) {
		printf("Enter macro line by line, terminating it with a null line\n");
	}
	(void) strncpy(macros[macnum].mac_name, argv[1], 8);
	if (macnum == 0) {
		macros[macnum].mac_start = macbuf;
	}
	else {
		macros[macnum].mac_start = macros[macnum - 1].mac_end + 1;
	}
	tmp = macros[macnum].mac_start;
	while (tmp != macbuf+4096) {
		if ((c = getchar()) == EOF) {
			printf("macdef:end of file encountered\n");
			code = -1;
			return;
		}
		if ((*tmp = c) == '\n') {
			if (tmp == macros[macnum].mac_start) {
				macros[macnum++].mac_end = tmp;
				code = 0;
				return;
			}
			if (*(tmp-1) == '\0') {
				macros[macnum++].mac_end = tmp - 1;
				code = 0;
				return;
			}
			*tmp = '\0';
		}
		tmp++;
	}
	while (1) {
		while ((c = getchar()) != '\n' && c != EOF)
			/* LOOP */;
		if (c == EOF || getchar() == '\n') {
			printf("Macro not defined - 4k buffer exceeded\n");
			code = -1;
			return;
		}
	}
}

/*
 * get size of file on remote machine
 */
void sizecmd(argc, argv)
	int argc;
	char *argv[];
{

	if (argc < 2 && !another(&argc, &argv, "filename")) {
		printf("usage: %s filename\n", argv[0]);
		code = -1;
		return;
	}
	(void) command("SIZE %s", argv[1]);
}

/*
 * get last modification time of file on remote machine
 */
void modtime(argc, argv)
	int argc;
	char *argv[];
{
	int overbose;

	if (argc < 2 && !another(&argc, &argv, "filename")) {
		printf("usage: %s filename\n", argv[0]);
		code = -1;
		return;
	}
	overbose = verbose;
	if (debug == 0)
		verbose = -1;
	if (command("MDTM %s", argv[1]) == COMPLETE) {
		int yy, mo, day, hour, min, sec;
		sscanf(reply_string, "%*s %04d%02d%02d%02d%02d%02d", &yy, &mo,
			&day, &hour, &min, &sec);
		/* might want to print this in local time */
		printf("%s\t%02d/%02d/%04d %02d:%02d:%02d GMT\n", argv[1],
			mo, day, yy, hour, min, sec);
	} else
		printf("%s\n", reply_string);
	verbose = overbose;
}

/*
 * show status on reomte machine
 */
void rmtstatus(argc, argv)
	int argc;
	char *argv[];
{
	(void) command(argc > 1 ? "STAT %s" : "STAT" , argv[1]);
}

/*
 * get file if modtime is more recent than current file
 */
void newer(argc, argv)
	int argc;
	char *argv[];
{
	if (getit(argc, argv, -1, "w"))
		printf("Local file \"%s\" is newer than remote file \"%s\"\n",
			argv[1], argv[2]);
}

/**********
#include <stdarg.h>
BPTR debugfh=NULL;

void Dprintf(char *fmt, ...)
{
    va_list args;

    if (debugfh==NULL) {
		debugfh = Open("con:0/0/640/100/FTPD/AUTO/WAIT", MODE_NEWFILE);
    }

    va_start(args,fmt);
	VFPrintf(debugfh,fmt,(LONG *)args);

    va_end(args);

}
**********/@


2.1
log
@Binary 2.3

Removed extra copyright notice
@
text
@d6 1
a6 1
 * $Id: cmds.c,v 2.0 92/07/20 12:51:33 bj Exp $
d8 1
a8 1
 * $Revision: 2.0 $
d11 5
d22 1
a22 1
 * $Header: AS225:src/c/ftp/RCS/cmds.c,v 2.0 92/07/20 12:51:33 bj Exp $
d59 9
d825 1
d871 1
a871 1

d877 1
a877 1
	char temp[16];
d885 1
d890 1
d899 1
d907 1
d927 1
d931 4
d936 2
a937 1
		(void) fclose(ftemp), ftemp = NULL;
d939 1
d942 1
d947 1
@


2.0
log
@This is the first SAS c version. This is the first release to PA & BIX
for the new AS225 R2 release testing.  Straight from Martin. Rewritten
from scratch.
@
text
@d4 1
a4 1
 * $Locker:$
d6 1
a6 1
 * $Id:$
d8 8
a15 1
 * $Revision:$
d17 1
a17 1
 * $Log:$
a18 2
 * $Header:$
 *
a52 4

#ifndef lint
static char sccsid[] = "@@(#)cmds.c	5.26 (Berkeley) 3/5/91";
#endif /* not lint */
@


1.1
log
@Initial revision
@
text
@d1 2
a2 2
/* ---------------------------------------------------------------------------------
 * cmds.c (ftp)  manx 3.6
d4 1
a4 1
 * $Locker$
d6 7
a12 1
 * $Id$
d14 1
a14 5
 * $Revision$
 *
 * $Header$
 *
 *-----------------------------------------------------------------------------------
a15 4




d20 32
a51 12
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */
a52 1

a56 1
#ifndef AMIGA
a57 1
#endif
a59 1
#include <netinet/in.h>
d69 1
a69 2

#include "ftp_var.h"
d71 2
a72 1
#include <libraries/dosextens.h>
d75 1
a75 1
extern	char **glob();
d79 3
a81 3
extern	char *index();
extern	char *rindex();
extern  char reply_string[];
a82 2
extern struct FileLock *originaldir, *CurrentDir() ;

d85 103
a187 1
char *dotrans(), *domap();
d193 1
a193 1
setpeer(argc, argv)
d198 1
a198 1
	int port;
d206 3
a208 9
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(to) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc > 3) {
d226 2
d229 11
a239 2
		if (autologin) {
			int overbose;
d241 1
a241 3
			(void) login(argv[1]);
#ifdef UNIX
/* #if defined(unix) && NBBY == 8 */
d246 43
a288 27
			overbose = verbose;
			if (debug == 0)
				verbose = -1;
			if (command("SYST") == COMPLETE && overbose) {
				register char *cp, c;
				cp = index(reply_string+4, ' ');
				if (cp == NULL)
					cp = index(reply_string+4, '\r');
				if (cp) {
					if (cp[-1] == '.')
						cp--;
					c = *cp;
					*cp = '\0';
				}

				printf("Remote system type is %s.\n",
					reply_string+4);
				if (cp)
					*cp = c;
			}
			if (!strncmp(reply_string, "215 UNIX Type: L8", 17)) {
				setbinary();
				if (overbose)
				    printf("Using %s mode to transfer files.\n",
					typename);
			} else if (overbose && 
			    !strncmp(reply_string, "215 TOPS20", 10)) {
d291 2
a292 2
			}
			verbose = overbose;
a293 1
		}
d314 2
a315 1
settype(argc, argv)
d328 1
a328 2
			if (*sep == ' ')
				sep = " | ";
d353 1
a353 1
		type = p->t_type;
d358 3
a360 1
 * Set binary transfer type.
d362 2
a363 2
/*VARARGS*/
setbinary()
d365 2
d368 20
a387 1
	call(settype, "type", "binary", 0);
d390 6
d397 1
a397 1
 * Set ascii transfer type.
d400 1
a400 1
setascii()
d402 2
a403 2

	call(settype, "type", "ascii", 0);
d407 1
a407 1
 * Set tenex transfer type.
d410 1
a410 1
settenex()
d412 2
a413 2

	call(settype, "type", "tenex", 0);
d417 1
a417 1
 * Set ebcdic transfer type.
d420 1
a420 1
setebcdic()
d422 2
a423 2

	call(settype, "type", "ebcdic", 0);
d430 2
a431 1
setmode(argc, argv)
d443 2
a444 1
setform(argc, argv)
d456 2
a457 1
setstruct(argc, argv)
d468 1
a468 1
put(argc, argv)
d474 1
a474 1
	char *oldargv1;
d481 3
a483 9
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(local-file) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
d485 1
a485 1
		printf("usage:%s local-file remote-file\n", argv[0]);
a488 10
	if (argc < 3) {
		(void) strcat(line, " ");
		printf("(remote-file) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 3) 
		goto usage;
d490 1
d509 2
a510 1
	sendrequest(cmd, argv[1], argv[2]);
d516 3
a518 2
mput(argc, argv)
	char *argv[];
d520 1
d522 2
a523 2
	int ointer, (*oldintr)(), mabort();
	extern jmp_buf jabort;
d525 1
d527 2
a528 10
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(local-files) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage:%s local-files\n", argv[0]);
d534 1
a534 1
	oldintr = signal(SIGINT, mabort);
d569 2
a570 1
				sendrequest((sunique) ? "STOU" : "STOR", cp,tp);
d581 1
a581 1
		(void) signal(SIGINT, oldintr);
d593 1
a593 1
				            argv[i], tp);
d605 1
a605 1
		gargs = glob(argv[i]);
d610 1
a610 1
				free(gargs);
d619 1
a619 1
					   *cpp, tp);
d632 1
a632 1
			free(gargs);
d635 1
a635 1
	(void) signal(SIGINT, oldintr);
d639 13
d656 2
a657 1
get(argc, argv)
d659 1
d662 1
d669 3
a671 9
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(remote-file) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
d675 1
a675 1
		return;
d677 2
a678 10
	if (argc < 3) {
		(void) strcat(line, " ");
		printf("(local-file) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 3) 
		goto usage;
d681 1
a681 1
		return;
d706 58
a763 1
	recvrequest("RETR", argv[2], argv[1], "w");
d766 1
d790 3
a792 2
mget(argc, argv)
	char *argv[];
d794 3
d798 1
a798 2
	int ointer, (*oldintr)(), mabort();
	extern jmp_buf jabort;
d800 2
a801 10
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(remote-files) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage:%s remote-files\n", argv[0]);
d807 1
a807 1
	oldintr = signal(SIGINT,mabort);
d814 2
a815 1
		if (mflag && confirm(argv[0], cp)) {
d840 2
a841 1
			recvrequest("RETR", tp, cp, "w");
d852 1
a852 1
	(void) signal(SIGINT,oldintr);
d888 4
a891 6
#ifdef AMIGA
		(void) strcpy(temp, "t:ftpXXXXXX");
#else
		(void) strcpy(temp, "/tmp/ftpXXXXXX");
#endif
		(void) mktemp(temp);
d898 1
a898 1
			recvrequest ("NLST", temp, *argv, mode);
a903 1
		(void) unlink(temp);
d906 1
d912 1
d917 2
d934 2
a935 1
status(argc, argv)
d989 1
a989 1
setbell()
d1001 1
a1001 1
settrace()
d1013 1
a1013 1
sethash()
d1020 1
a1020 1
		printf(" (%d bytes/hash mark)", BUFSIZ);
d1028 1
a1028 1
setverbose()
d1040 1
a1040 1
setport()
d1053 1
a1053 1
setprompt()
d1066 1
a1066 1
setglob()
d1079 2
a1080 1
setdebug(argc, argv)
d1107 2
a1108 1
cd(argc, argv)
d1112 2
a1113 10
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(remote-directory) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage:%s remote-directory\n", argv[0]);
d1117 5
a1121 1
	(void) command("CWD %s", argv[1]);
d1128 2
a1129 1
lcd(argc, argv)
d1133 1
d1138 1
a1138 1
		printf("usage:%s local-directory\n", argv[0]);
d1147 1
a1147 1
		perror(argv[1]);
d1158 2
a1159 1
delete(argc, argv)
d1163 2
a1164 10
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(remote-file) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage:%s remote-file\n", argv[0]);
d1174 3
a1176 2
mdelete(argc, argv)
	char *argv[];
d1178 3
d1182 1
a1182 2
	int ointer, (*oldintr)(), mabort();
	extern jmp_buf jabort;
d1184 2
a1185 10
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(remote-files) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage:%s remote-files\n", argv[0]);
d1191 1
a1191 1
	oldintr = signal(SIGINT, mabort);
d1210 1
a1210 1
	(void) signal(SIGINT, oldintr);
d1217 2
a1218 1
renamefile(argc, argv)
d1222 3
a1224 9
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(from-name) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
a1229 10
	if (argc < 3) {
		(void) strcat(line, " ");
		printf("(to-name) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 3) 
		goto usage;
d1238 2
a1239 1
ls(argc, argv)
d1263 1
a1263 1
	recvrequest(cmd, argv[2], argv[1], "w");
d1270 3
a1272 2
mls(argc, argv)
	char *argv[];
d1274 3
d1278 1
a1278 2
	int ointer, i, (*oldintr)(), mabort();
	extern jmp_buf jabort;
d1280 5
a1284 18
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(remote-files) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 3) {
		(void) strcat(line, " ");
		printf("(local-file) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 3) {
		printf("usage:%s remote-files local-file\n", argv[0]);
d1291 2
a1292 1
		if (!globulize(&dest) || !confirm("output to local-file:", dest)) {
d1299 1
a1299 1
	oldintr = signal(SIGINT, mabort);
d1303 1
a1303 1
		recvrequest(cmd, dest, argv[i], mode);
d1313 1
a1313 1
	(void) signal(SIGINT, oldintr);
d1321 4
a1324 2
shell(argc, argv)
	char *argv[];
d1326 1
a1326 51
#ifdef AMIGA
#else
	int pid, (*old1)(), (*old2)();
	char shellnam[40], *shell, *namep; 
	union wait status;

	old1 = signal (SIGINT, SIG_IGN);
	old2 = signal (SIGQUIT, SIG_IGN);
	if ((pid = fork()) == 0) {
		for (pid = 3; pid < 20; pid++)
			(void) close(pid);
		(void) signal(SIGINT, SIG_DFL);
		(void) signal(SIGQUIT, SIG_DFL);
		shell = getenv("SHELL");
		if (shell == NULL)
			shell = "/bin/sh";
		namep = rindex(shell,'/');
		if (namep == NULL)
			namep = shell;
		(void) strcpy(shellnam,"-");
		(void) strcat(shellnam, ++namep);
		if (strcmp(namep, "sh") != 0)
			shellnam[0] = '+';
		if (debug) {
			printf ("%s\n", shell);
			(void) fflush (stdout);
		}
		if (argc > 1) {
			execl(shell,shellnam,"-c",altarg,(char *)0);
		}
		else {
			execl(shell,shellnam,(char *)0);
		}
		perror(shell);
		code = -1;
		exit(1);
		}
	if (pid > 0)
		while (wait(&status) != pid)
			;
	(void) signal(SIGINT, old1);
	(void) signal(SIGQUIT, old2);
	if (pid == -1) {
		perror("Try again later");
		code = -1;
	}
	else {
		code = 0;
	}
	return (0);
#endif
d1332 1
a1332 1
user(argc, argv)
d1339 3
a1341 9
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(username) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc > 4) {
d1376 1
a1376 1
pwd()
d1378 1
d1380 9
a1388 1
	(void) command("PWD");
d1394 2
a1395 1
makedir(argc, argv)
d1399 1
a1399 9
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(directory-name) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
d1404 5
a1408 1
	(void) command("MKD %s", argv[1]);
d1414 2
a1415 1
removedir(argc, argv)
d1419 1
a1419 9
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(directory-name) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
d1424 5
a1428 1
	(void) command("RMD %s", argv[1]);
d1434 2
a1435 1
quote(argc, argv)
a1437 2
	int i;
	char buf[BUFSIZ];
d1439 4
a1442 7
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(command line to send) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
d1444 14
a1457 1
	if (argc < 2) {
d1462 23
a1484 4
	(void) strcpy(buf, argv[1]);
	for (i = 2; i < argc; i++) {
		(void) strcat(buf, " ");
		(void) strcat(buf, argv[i]);
d1491 38
d1532 2
a1533 1
rmthelp(argc, argv)
d1547 1
a1547 1
quit()
a1555 2

	if( originaldir ) CurrentDir( originaldir ) ;
d1562 1
a1562 1
disconnect()
d1581 1
a1581 1
confirm(cmd, file)
d1590 10
a1599 2
	(void) gets(line);
	return (*line != 'n' && *line != 'N');
d1602 1
a1602 1
fatal(msg)
d1616 1
a1616 1
globulize(cpp)
d1623 1
a1623 1
	globbed = glob(*cpp);
d1628 1
a1628 1
			free(globbed);
d1637 1
a1637 1
			free(globbed);
d1643 1
a1643 1
account(argc,argv)
d1669 1
d1687 1
a1687 1
doproxy(argc,argv)
d1691 2
a1692 1
	int proxabort(), (*oldintr)();
d1695 2
a1696 2
	extern struct cmd cmdtab[];
	extern jmp_buf abortprox;
d1698 2
a1699 10
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(command) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage:%s command\n", argv[0]);
d1726 1
a1726 1
	oldintr = signal(SIGINT, proxabort);
d1732 1
a1732 1
		(void) signal(SIGINT, oldintr);
d1744 1
a1744 1
	(void) signal(SIGINT, oldintr);
d1747 1
a1747 1
setcase()
d1754 1
a1754 1
setcr()
d1761 1
a1761 1
setntrans(argc,argv)
d1811 1
a1811 1
setnmap(argc, argv)
d1823 1
a1823 9
	if (argc < 3) {
		(void) strcat(line, " ");
		printf("(mapout) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 3) {
d2012 1
a2012 1
setsunique()
d2019 1
a2019 1
setrunique()
d2027 1
a2027 1
cdup()
d2029 20
a2048 1
	(void) command("CDUP");
a2050 1

d2052 1
a2052 1
syst()
d2057 1
a2057 1
macdef(argc, argv)
d2069 1
a2069 9
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(macro name) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc != 2) {
d2120 2
a2121 1
sizecmd(argc, argv)
d2125 2
a2126 10
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(filename) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage:%s filename\n", argv[0]);
d2136 2
a2137 1
modtime(argc, argv)
d2142 2
a2143 10
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(filename) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage:%s filename\n", argv[0]);
d2158 1
a2158 1
		fputs(reply_string, stdout);
d2163 1
a2163 1
 * show status on remote machine
d2165 2
a2166 1
rmtstatus(argc, argv)
d2171 32
@
