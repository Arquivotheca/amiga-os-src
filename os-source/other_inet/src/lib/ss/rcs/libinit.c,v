head     1.5;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.5
date     93.12.13.11.30.41;  author kcd;  state Exp;
branches ;
next     1.4;

1.4
date     92.08.21.19.18.50;  author kcd;  state Exp;
branches ;
next     1.3;

1.3
date     92.07.21.16.39.39;  author bj;  state Exp;
branches ;
next     1.2;

1.2
date     91.08.07.13.00.53;  author bj;  state Exp;
branches ;
next     1.1;

1.1
date     91.07.02.12.14.32;  author martin;  state Exp;
branches ;
next     ;


desc
@@


1.5
log
@""
@
text
@/* -----------------------------------------------------------------------
 * libinit.c
 *
 * $Locker:  $
 *
 * $Id: libinit.c,v 1.4 92/08/21 19:18:50 kcd Exp $
 *
 * $Revision: 1.4 $
 *
 * $Log:	libinit.c,v $
 * Revision 1.4  92/08/21  19:18:50  kcd
 * Commented out useless code in the library init routine.  Most of this
 * is being handled by libent.asm anyway.  This also fixes the version
 * string problems.
 *
 * Revision 1.2  91/08/07  13:00:53  bj
 * Added Semaphores to lib base. SyslogSemaphore
 * and ConfigSemaphore. For use by the config and
 * syslof routines.
 * Also added routine to close the SyslogWindowFH if
 * it has been opened.
 *
 *
 * $Header: AS225:src/lib/ss/RCS/libinit.c,v 1.4 92/08/21 19:18:50 kcd Exp $
 *
 *------------------------------------------------------------------------
 */

#include "sslib.h"
#include <string.h>
#include <exec/nodes.h>
#include <exec/memory.h>
#include <exec/resident.h>

/* Prototypes */
ULONG __saveds __asm _LibExpunge( register __a6 struct SocketLibrary *);
ULONG __saveds __asm _LibInit( register __a0 APTR,register __d0 struct SocketLibrary *);
ULONG __saveds __asm _LibClose( register __a6 struct SocketLibrary *);

BOOL __saveds __asm CustomLibOpen(register __a6 struct SocketLibrary *);
void __saveds __asm CustomLibClose(register __a6 struct SocketLibrary *);

typedef LONG (*PFL)();   /* pointer to function returning 32-bit int        */

/* library initialization table, used for AUTOINIT libraries                */
struct InitTable {
        ULONG        *it_DataSize;       /* library data space size         */
        PFL          *it_FuncTable;      /* table of entry points           */
        APTR         it_DataInit;        /* table of data initializers      */
        PFL          it_InitFunc;        /* initialization function to run  */
};


/* symbols generated by blink */
extern char __far _LibID[];             /* ID string                        */
extern char __far _LibName[];           /* Name string                      */
extern char __far _BSSLEN;              /* size of uinit BSS                */
extern char __far RESLEN;               /* size of init data                */
extern long __far NEWDATAL;             /* size of global data              */
extern PFL _LibFuncTab[];               /* my function table                */
#define DATAWORDS ((long)&NEWDATAL)     /* magic to get right tpye of reloc */
#define LENGTH_DATA_BSS ((long)(((long)&NEWDATAL+(long)&_BSSLEN)*4))
#define SIZEJMPTAB ((long)libbase->ml_origbase->ml_numjmps)
                                        /* size in bytes of jmp table       */
#include "socket_rev.h"			/* version and revision number      */

/* Supplied as part of our libent.a */
extern char __far _VerString[];

/* From libent.o, needed to determine where data is loaded by loadseg       */
extern long far _Libmergeddata;

#define SysBase ((struct ExecBase *)(*((ULONG *)4)))

struct InitTable __far _LibInitTab =  {
        (long *)(&RESLEN+sizeof(struct SocketLibrary)),
        _LibFuncTab,
        NULL,                        /* will initialize my own data */
        _LibInit
};


/**********************************************
 * LIBINIT
 **********************************************
 */


ULONG __saveds __asm _LibInit( register __a0 APTR seglist,  register __d0 struct SocketLibrary *libbase )
{
	long *sdata;
	char *ddata;
	long nrelocs;


	libbase->ml_SegList = (ULONG) seglist;

	    /* init. library structure (since I don't do automatic data init.) */
/*	libbase->ml_Lib.lib_Node.ln_Type = NT_LIBRARY;*/
/*	libbase->ml_Lib.lib_Node.ln_Name =  _LibName; */
	libbase->ml_Lib.lib_Flags = LIBF_SUMUSED | LIBF_CHANGED;
/*	libbase->ml_Lib.lib_Version = VERSION; */
	libbase->ml_Lib.lib_Revision = REVISION;
/*	libbase->ml_Lib.lib_IdString = (APTR) _VerString; */
	libbase->ml_relocs = NULL;
	libbase->ml_origbase = libbase;
	libbase->configured = 0;
	libbase->ml_SyslogWindowFH = NULL ; /* gets filled in at first libopen */

	libbase->ml_SyslogSemaphore = AllocMem((long)sizeof(struct SignalSemaphore),MEMF_PUBLIC|MEMF_CLEAR) ;
	if(libbase->ml_SyslogSemaphore == NULL)
	{
		return(0) ;
	}
	InitSemaphore(libbase->ml_SyslogSemaphore) ;

	libbase->ml_ConfigSemaphore = AllocMem((long)sizeof(struct SignalSemaphore),MEMF_PUBLIC|MEMF_CLEAR) ;
	if(libbase->ml_ConfigSemaphore == NULL)
	{
		FreeMem(libbase->ml_SyslogSemaphore, (long)sizeof(struct SignalSemaphore)) ;
		return(0) ;
	}
	InitSemaphore(libbase->ml_ConfigSemaphore) ;

	sdata = (long *)_LibInitTab.it_FuncTable;

	libbase->ml_numjmps = 0;
	while (*sdata != -1)
	{
		libbase->ml_numjmps += 6;
		sdata++;
	}



		/* Start of copy of global data after structure */
	ddata = (char *)libbase + sizeof(struct SocketLibrary);

	sdata = (long *)&_Libmergeddata; /* where loadseg loaded the data */
	memcpy(ddata, (void *)sdata, DATAWORDS*4);

		/* perform relocs if we want one global section for all programs */
		/* that have this lib open. If we want a global section for each */
		/* open, copy the relocs, and do them on each open call.         */

	sdata = sdata + DATAWORDS;
	nrelocs = *sdata;
	if (nrelocs)
	{
		if ((libbase->ml_relocs = AllocMem((nrelocs * 4) + 4, MEMF_PUBLIC)) == NULL)
		{
			FreeMem(libbase->ml_ConfigSemaphore, (long)sizeof(struct SignalSemaphore)) ;
			FreeMem(libbase->ml_SyslogSemaphore, (long)sizeof(struct SignalSemaphore)) ;
			return 0;
		}
		memcpy((void *)libbase->ml_relocs, (void *)sdata, (nrelocs * 4) + 4);
	}

		/* need this for 68040 */
	CacheClearU();

	return ( (ULONG) libbase );
}

/**********************************************
 * LIBOPEN
 **********************************************
 */

LONG __saveds __asm
_LibOpen( register __a6 struct SocketLibrary *libbase )
{
	char *newlib;
	long *sdata, *ddata, *reloc;
	long nrelocs;

	    /* mark us as having another customer */
	libbase->ml_Lib.lib_OpenCnt++;

    	/* clear delayed expunges (standard procedure)                */
	libbase->ml_Lib.lib_Flags &= ~LIBF_DELEXP;

	    /* Allocate new lib base */
	newlib = AllocMem((long)(sizeof(struct SocketLibrary) +
                             LENGTH_DATA_BSS + SIZEJMPTAB),
                             MEMF_PUBLIC);

	if (newlib == NULL) return 0;

	    /* copy over data */
	memcpy(newlib, (char *)libbase - SIZEJMPTAB,
	       (long)(sizeof (struct SocketLibrary) + DATAWORDS*4 + SIZEJMPTAB));

	libbase = (struct SocketLibrary *)(newlib+SIZEJMPTAB);
	libbase->ml_relocs = NULL;


		/* perform relocs */
	ddata = (long *)((char *)libbase + sizeof(struct SocketLibrary));
	sdata = libbase->ml_origbase->ml_relocs;
	if (sdata)
	{
		nrelocs = *sdata++;
		while (nrelocs > 0)
		{
			reloc = (long *)((long)ddata + *sdata++);
			*reloc += (long)ddata;
			nrelocs--;
			}
		}
	if (CustomLibOpen(libbase) == FALSE) {
		_LibClose(libbase);
		return ( NULL );
	}
	CacheClearU();
	return ( (LONG) libbase );
}

/**********************************************
 * LIBCLOSE
 **********************************************
 */

ULONG __saveds __asm
_LibClose( register __a6 struct SocketLibrary *libbase )
{
	ULONG retval = 0;

	struct SocketLibrary *origbase;
	if (libbase != libbase->ml_origbase)
	{
		CustomLibClose(libbase);
		origbase = libbase->ml_origbase;
		FreeMem((char *)libbase-SIZEJMPTAB,
		       (long)(sizeof(struct SocketLibrary) + LENGTH_DATA_BSS +SIZEJMPTAB));
		libbase = origbase;
	}

	if (( --libbase->ml_Lib.lib_OpenCnt == 0 ) &&
	                    ( libbase->ml_Lib.lib_Flags & LIBF_DELEXP ))
	{
	    /* no more people have me open,
	     * and I have a delayed expunge pending
	     */
		retval = _LibExpunge( libbase ); /* return segment list        */
	}

	return (retval);
}

/**********************************************
 * EXPUNGE
 **********************************************
 */


ULONG __saveds __asm
_LibExpunge( register __a6 struct SocketLibrary *libbase )
{
	ULONG seglist = 0;
	LONG  libsize;
	struct DosLibrary *DOSBase ;

	libbase = libbase->ml_origbase;

	libbase->ml_Lib.lib_Flags |= LIBF_DELEXP;
	if ( libbase->ml_Lib.lib_OpenCnt == 0 )
	{
		unconfig(libbase);

	        /* really expunge: remove libbase and freemem */
		if (libbase->ml_relocs)
		{
			if( libbase->ml_SyslogWindowFH)
			{
				if(DOSBase = (struct DosLibrary *)OpenLibrary("dos.library", 37L ))
				{
					Close(libbase->ml_SyslogWindowFH) ;
					libbase->ml_SyslogWindowFH = NULL ;
					CloseLibrary((struct Library *)DOSBase) ;
				}
			}
			FreeMem(libbase->ml_ConfigSemaphore, (long)sizeof(struct SignalSemaphore)) ;
			FreeMem(libbase->ml_SyslogSemaphore, (long)sizeof(struct SignalSemaphore)) ;
			FreeMem(libbase->ml_relocs, (*libbase->ml_relocs * 4) + 4);
			seglist = libbase->ml_SegList;
			Remove( (struct Node *) libbase);
			libsize = libbase->ml_Lib.lib_NegSize + libbase->ml_Lib.lib_PosSize;
			FreeMem( (char *) libbase - libbase->ml_Lib.lib_NegSize,(LONG) libsize );
		}
    }
		/* return NULL or real seglist */
	return ( (ULONG) seglist );
}

@


1.4
log
@Commented out useless code in the library init routine.  Most of this
is being handled by libent.asm anyway.  This also fixes the version
string problems.
@
text
@d6 1
a6 1
 * $Id: libinit.c,v 1.2 91/08/07 13:00:53 bj Exp $
d8 1
a8 1
 * $Revision: 1.2 $
d11 5
d24 1
a24 1
 * $Header: NW:src/lib/ss/RCS/libinit.c,v 1.2 91/08/07 13:00:53 bj Exp $
d79 1
a79 1
        _LibInit,
d89 1
a89 2
__saveds __asm
ULONG _LibInit( register __a0 APTR seglist,  register __d0 struct SocketLibrary *libbase )
d126 1
d160 1
a160 1
	if(((struct ExecBase *)(*((ULONG *)4)))->LibNode.lib_Version >= 37) CacheClearU();
d215 1
@


1.3
log
@Socket.library 4.0
details on prototypes (nothing functional.)
added check for failure of CustomLibOpen(libbase).
@
text
@a16 1
 * 
d18 1
d60 1
a60 1
#include "socklib_rev.h"				/* version and revision number                  */
d90 1
a90 1
	
d95 2
a96 2
	libbase->ml_Lib.lib_Node.ln_Type = NT_LIBRARY;
	libbase->ml_Lib.lib_Node.ln_Name =  _LibName;
d98 1
a98 1
	libbase->ml_Lib.lib_Version = VERSION;
d100 1
a100 1
	libbase->ml_Lib.lib_IdString = (APTR) _VerString;
@


1.2
log
@Added Semaphores to lib base. SyslogSemaphore
and ConfigSemaphore. For use by the config and
syslof routines.
Also added routine to close the SyslogWindowFH if
it has been opened.
@
text
@d4 1
a4 1
 * $Locker:$
d6 1
a6 1
 * $Id:$
d8 1
a8 1
 * $Revision:$
d10 8
a17 1
 * $Log:$
d19 1
a19 1
 * $Header:$
d23 3
a25 3
#define  _USEOLDEXEC_ 1
#define INTERNAL_USE 1
#include <exec/types.h>
a28 7
#include <exec/libraries.h>
#include <exec/execbase.h>
#include <libraries/dos.h>
#include <proto/exec.h>
#include <proto/dos.h>
#include <string.h>
#include "sslib.h"
d30 4
d35 2
a36 6
/* Prototypes */
ULONG __saveds __asm _LibExpunge( register __a6 struct SocketLibrary *libbase );
ULONG __saveds __asm _LibInit( register __a0 APTR seglist,
                                register __d0 struct SocketLibrary *);
BOOL __saveds __asm CustomLibOpen(register __a6 struct SocketLibrary *libbase);
void __saveds __asm CustomLibClose(register __a6 struct SocketLibrary *libbase);
d155 1
a155 1
	if(SysBase->LibNode.lib_Version >= 37) CacheClearU();
d206 4
a209 1
	CustomLibOpen(libbase);
@


1.1
log
@Initial revision
@
text
@d1 15
d17 1
d30 1
d77 7
d85 1
a85 2
ULONG _LibInit( register __a0 APTR seglist,
        register __d0 struct SocketLibrary *libbase )
d87 4
a90 32
#ifdef ONE_GLOBAL_SECTION
    long *reloc;
#endif
    long *sdata;
    char *ddata;
    long nrelocs;


    libbase->ml_SegList = (ULONG) seglist;

    /* init. library structure (since I don't do automatic data init.) */
    libbase->ml_Lib.lib_Node.ln_Type = NT_LIBRARY;
    libbase->ml_Lib.lib_Node.ln_Name =  _LibName;
    libbase->ml_Lib.lib_Flags = LIBF_SUMUSED | LIBF_CHANGED;
    libbase->ml_Lib.lib_Version = VERSION;
    libbase->ml_Lib.lib_Revision = REVISION;
    libbase->ml_Lib.lib_IdString = (APTR) _VerString;
#ifndef ONE_GLOBAL_SECTION
    libbase->ml_relocs = NULL;
    libbase->ml_origbase = libbase;
    libbase->configured = 0;
    sdata = (long *)_LibInitTab.it_FuncTable;
    libbase->ml_numjmps = 0;
    while (*sdata != -1)
    {
      libbase->ml_numjmps += 6;
      sdata++;
    }
#endif

     /* Start of copy of global data after structure */
    ddata = (char *)libbase + sizeof(struct SocketLibrary);
d92 61
a152 25
    sdata = (long *)&_Libmergeddata; /* where loadseg loaded the data */
    memcpy(ddata, (void *)sdata, DATAWORDS*4);

    /* perform relocs if we want one global section for all programs */
    /* that have this lib open. If we want a global section for each */
    /* open, copy the relocs, and do them on each open call.         */
    sdata = sdata + DATAWORDS;
    nrelocs = *sdata;
#ifdef ONE_GLOBAL_SECTION
    sdata++;
    while (nrelocs > 0)
    {
       reloc = (long *)((long)ddata + *sdata++);
       *reloc += (long)ddata;
       nrelocs--;
    }
    user_init(libbase);
#else
    if (nrelocs)
    {
      if ((libbase->ml_relocs = AllocMem((nrelocs * 4) + 4, MEMF_PUBLIC)) == NULL)
        return 0;
      memcpy((void *)libbase->ml_relocs, (void *)sdata, (nrelocs * 4) + 4);
    }
#endif
d154 2
a155 2
	/* need this for 68040 */
    if(SysBase->LibNode.lib_Version >= 37) CacheClearU();
d157 1
a157 1
    return ( (ULONG) libbase );
d160 5
d168 3
a170 11
#ifndef ONE_GLOBAL_SECTION
    char *newlib;
    long *sdata, *ddata, *reloc;
    long nrelocs;
#endif

    /* mark us as having another customer */
    libbase->ml_Lib.lib_OpenCnt++;

    /* clear delayed expunges (standard procedure)                */
    libbase->ml_Lib.lib_Flags &= ~LIBF_DELEXP;
d172 8
a179 3
#ifndef ONE_GLOBAL_SECTION
    /* Allocate new lib base */
    newlib = AllocMem((long)(sizeof(struct SocketLibrary) +
d183 1
a183 1
    if (newlib == NULL) return 0;
d185 24
a208 21
    /* copy over data */
    memcpy(newlib, (char *)libbase - SIZEJMPTAB,
           (long)(sizeof (struct SocketLibrary) + DATAWORDS*4 + SIZEJMPTAB));

    libbase = (struct SocketLibrary *)(newlib+SIZEJMPTAB);
    libbase->ml_relocs = NULL;


    /* perform relocs */
    ddata = (long *)((char *)libbase + sizeof(struct SocketLibrary));
    sdata = libbase->ml_origbase->ml_relocs;
    if (sdata)
    {
       nrelocs = *sdata++;
       while (nrelocs > 0)
       {
          reloc = (long *)((long)ddata + *sdata++);
          *reloc += (long)ddata;
          nrelocs--;
       }
    }
d210 4
a213 2
    CustomLibOpen(libbase);
#endif
a214 3
    return ( (LONG) libbase );
}

d218 20
a237 1
    ULONG retval = 0;
d239 2
a240 11
#ifndef ONE_GLOBAL_SECTION
    struct SocketLibrary *origbase;
    if (libbase != libbase->ml_origbase)
    {
       CustomLibClose(libbase);
       origbase = libbase->ml_origbase;
       FreeMem((char *)libbase-SIZEJMPTAB,
               (long)(sizeof(struct SocketLibrary) + LENGTH_DATA_BSS +SIZEJMPTAB));
       libbase = origbase;
    }
#endif
d242 4
a245 8
    if (( --libbase->ml_Lib.lib_OpenCnt == 0 ) &&
                        ( libbase->ml_Lib.lib_Flags & LIBF_DELEXP ))
    {
        /* no more people have me open,
         * and I have a delayed expunge pending
         */
         retval = _LibExpunge( libbase ); /* return segment list        */
    }
a246 2
    return (retval);
}
d251 3
a253 21
    ULONG seglist = 0;
    LONG  libsize;

#ifndef ONE_GLOBAL_SECTION
    libbase = libbase->ml_origbase;
#endif

    libbase->ml_Lib.lib_Flags |= LIBF_DELEXP;
    if ( libbase->ml_Lib.lib_OpenCnt == 0 )
    {
    	unconfig(libbase);

        /* really expunge: remove libbase and freemem        */
#ifndef ONE_GLOBAL_SECTION
        if (libbase->ml_relocs)
           FreeMem(libbase->ml_relocs, (*libbase->ml_relocs * 4) + 4);
#endif

        seglist = libbase->ml_SegList;

        Remove( (struct Node *) libbase);
d255 27
a281 2
        libsize = libbase->ml_Lib.lib_NegSize + libbase->ml_Lib.lib_PosSize;
        FreeMem( (char *) libbase - libbase->ml_Lib.lib_NegSize,(LONG) libsize );
d283 3
a286 3
    /* return NULL or real seglist                                */
    return ( (ULONG) seglist );
}
@
