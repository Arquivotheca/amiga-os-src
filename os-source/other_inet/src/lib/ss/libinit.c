/* -----------------------------------------------------------------------
 * libinit.c
 *
 * $Locker:  $
 *
 * $Id: libinit.c,v 1.4 92/08/21 19:18:50 kcd Exp $
 *
 * $Revision: 1.4 $
 *
 * $Log:	libinit.c,v $
 * Revision 1.4  92/08/21  19:18:50  kcd
 * Commented out useless code in the library init routine.  Most of this
 * is being handled by libent.asm anyway.  This also fixes the version
 * string problems.
 *
 * Revision 1.2  91/08/07  13:00:53  bj
 * Added Semaphores to lib base. SyslogSemaphore
 * and ConfigSemaphore. For use by the config and
 * syslof routines.
 * Also added routine to close the SyslogWindowFH if
 * it has been opened.
 *
 *
 * $Header: AS225:src/lib/ss/RCS/libinit.c,v 1.4 92/08/21 19:18:50 kcd Exp $
 *
 *------------------------------------------------------------------------
 */

#include "sslib.h"
#include <string.h>
#include <exec/nodes.h>
#include <exec/memory.h>
#include <exec/resident.h>

/* Prototypes */
ULONG __saveds __asm _LibExpunge( register __a6 struct SocketLibrary *);
ULONG __saveds __asm _LibInit( register __a0 APTR,register __d0 struct SocketLibrary *);
ULONG __saveds __asm _LibClose( register __a6 struct SocketLibrary *);

BOOL __saveds __asm CustomLibOpen(register __a6 struct SocketLibrary *);
void __saveds __asm CustomLibClose(register __a6 struct SocketLibrary *);

typedef LONG (*PFL)();   /* pointer to function returning 32-bit int        */

/* library initialization table, used for AUTOINIT libraries                */
struct InitTable {
        ULONG        *it_DataSize;       /* library data space size         */
        PFL          *it_FuncTable;      /* table of entry points           */
        APTR         it_DataInit;        /* table of data initializers      */
        PFL          it_InitFunc;        /* initialization function to run  */
};


/* symbols generated by blink */
extern char __far _LibID[];             /* ID string                        */
extern char __far _LibName[];           /* Name string                      */
extern char __far _BSSLEN;              /* size of uinit BSS                */
extern char __far RESLEN;               /* size of init data                */
extern long __far NEWDATAL;             /* size of global data              */
extern PFL _LibFuncTab[];               /* my function table                */
#define DATAWORDS ((long)&NEWDATAL)     /* magic to get right tpye of reloc */
#define LENGTH_DATA_BSS ((long)(((long)&NEWDATAL+(long)&_BSSLEN)*4))
#define SIZEJMPTAB ((long)libbase->ml_origbase->ml_numjmps)
                                        /* size in bytes of jmp table       */
#include "socket_rev.h"			/* version and revision number      */

/* Supplied as part of our libent.a */
extern char __far _VerString[];

/* From libent.o, needed to determine where data is loaded by loadseg       */
extern long far _Libmergeddata;

#define SysBase ((struct ExecBase *)(*((ULONG *)4)))

struct InitTable __far _LibInitTab =  {
        (long *)(&RESLEN+sizeof(struct SocketLibrary)),
        _LibFuncTab,
        NULL,                        /* will initialize my own data */
        _LibInit
};


/**********************************************
 * LIBINIT
 **********************************************
 */


ULONG __saveds __asm _LibInit( register __a0 APTR seglist,  register __d0 struct SocketLibrary *libbase )
{
	long *sdata;
	char *ddata;
	long nrelocs;


	libbase->ml_SegList = (ULONG) seglist;

	    /* init. library structure (since I don't do automatic data init.) */
/*	libbase->ml_Lib.lib_Node.ln_Type = NT_LIBRARY;*/
/*	libbase->ml_Lib.lib_Node.ln_Name =  _LibName; */
	libbase->ml_Lib.lib_Flags = LIBF_SUMUSED | LIBF_CHANGED;
/*	libbase->ml_Lib.lib_Version = VERSION; */
	libbase->ml_Lib.lib_Revision = REVISION;
/*	libbase->ml_Lib.lib_IdString = (APTR) _VerString; */
	libbase->ml_relocs = NULL;
	libbase->ml_origbase = libbase;
	libbase->configured = 0;
	libbase->ml_SyslogWindowFH = NULL ; /* gets filled in at first libopen */

	libbase->ml_SyslogSemaphore = AllocMem((long)sizeof(struct SignalSemaphore),MEMF_PUBLIC|MEMF_CLEAR) ;
	if(libbase->ml_SyslogSemaphore == NULL)
	{
		return(0) ;
	}
	InitSemaphore(libbase->ml_SyslogSemaphore) ;

	libbase->ml_ConfigSemaphore = AllocMem((long)sizeof(struct SignalSemaphore),MEMF_PUBLIC|MEMF_CLEAR) ;
	if(libbase->ml_ConfigSemaphore == NULL)
	{
		FreeMem(libbase->ml_SyslogSemaphore, (long)sizeof(struct SignalSemaphore)) ;
		return(0) ;
	}
	InitSemaphore(libbase->ml_ConfigSemaphore) ;

	sdata = (long *)_LibInitTab.it_FuncTable;

	libbase->ml_numjmps = 0;
	while (*sdata != -1)
	{
		libbase->ml_numjmps += 6;
		sdata++;
	}



		/* Start of copy of global data after structure */
	ddata = (char *)libbase + sizeof(struct SocketLibrary);

	sdata = (long *)&_Libmergeddata; /* where loadseg loaded the data */
	memcpy(ddata, (void *)sdata, DATAWORDS*4);

		/* perform relocs if we want one global section for all programs */
		/* that have this lib open. If we want a global section for each */
		/* open, copy the relocs, and do them on each open call.         */

	sdata = sdata + DATAWORDS;
	nrelocs = *sdata;
	if (nrelocs)
	{
		if ((libbase->ml_relocs = AllocMem((nrelocs * 4) + 4, MEMF_PUBLIC)) == NULL)
		{
			FreeMem(libbase->ml_ConfigSemaphore, (long)sizeof(struct SignalSemaphore)) ;
			FreeMem(libbase->ml_SyslogSemaphore, (long)sizeof(struct SignalSemaphore)) ;
			return 0;
		}
		memcpy((void *)libbase->ml_relocs, (void *)sdata, (nrelocs * 4) + 4);
	}

		/* need this for 68040 */
	CacheClearU();

	return ( (ULONG) libbase );
}

/**********************************************
 * LIBOPEN
 **********************************************
 */

LONG __saveds __asm
_LibOpen( register __a6 struct SocketLibrary *libbase )
{
	char *newlib;
	long *sdata, *ddata, *reloc;
	long nrelocs;

	    /* mark us as having another customer */
	libbase->ml_Lib.lib_OpenCnt++;

    	/* clear delayed expunges (standard procedure)                */
	libbase->ml_Lib.lib_Flags &= ~LIBF_DELEXP;

	    /* Allocate new lib base */
	newlib = AllocMem((long)(sizeof(struct SocketLibrary) +
                             LENGTH_DATA_BSS + SIZEJMPTAB),
                             MEMF_PUBLIC);

	if (newlib == NULL) return 0;

	    /* copy over data */
	memcpy(newlib, (char *)libbase - SIZEJMPTAB,
	       (long)(sizeof (struct SocketLibrary) + DATAWORDS*4 + SIZEJMPTAB));

	libbase = (struct SocketLibrary *)(newlib+SIZEJMPTAB);
	libbase->ml_relocs = NULL;


		/* perform relocs */
	ddata = (long *)((char *)libbase + sizeof(struct SocketLibrary));
	sdata = libbase->ml_origbase->ml_relocs;
	if (sdata)
	{
		nrelocs = *sdata++;
		while (nrelocs > 0)
		{
			reloc = (long *)((long)ddata + *sdata++);
			*reloc += (long)ddata;
			nrelocs--;
			}
		}
	if (CustomLibOpen(libbase) == FALSE) {
		_LibClose(libbase);
		return ( NULL );
	}
	CacheClearU();
	return ( (LONG) libbase );
}

/**********************************************
 * LIBCLOSE
 **********************************************
 */

ULONG __saveds __asm
_LibClose( register __a6 struct SocketLibrary *libbase )
{
	ULONG retval = 0;

	struct SocketLibrary *origbase;
	if (libbase != libbase->ml_origbase)
	{
		CustomLibClose(libbase);
		origbase = libbase->ml_origbase;
		FreeMem((char *)libbase-SIZEJMPTAB,
		       (long)(sizeof(struct SocketLibrary) + LENGTH_DATA_BSS +SIZEJMPTAB));
		libbase = origbase;
	}

	if (( --libbase->ml_Lib.lib_OpenCnt == 0 ) &&
	                    ( libbase->ml_Lib.lib_Flags & LIBF_DELEXP ))
	{
	    /* no more people have me open,
	     * and I have a delayed expunge pending
	     */
		retval = _LibExpunge( libbase ); /* return segment list        */
	}

	return (retval);
}

/**********************************************
 * EXPUNGE
 **********************************************
 */


ULONG __saveds __asm
_LibExpunge( register __a6 struct SocketLibrary *libbase )
{
	ULONG seglist = 0;
	LONG  libsize;
	struct DosLibrary *DOSBase ;

	libbase = libbase->ml_origbase;

	libbase->ml_Lib.lib_Flags |= LIBF_DELEXP;
	if ( libbase->ml_Lib.lib_OpenCnt == 0 )
	{
		unconfig(libbase);

	        /* really expunge: remove libbase and freemem */
		if (libbase->ml_relocs)
		{
			if( libbase->ml_SyslogWindowFH)
			{
				if(DOSBase = (struct DosLibrary *)OpenLibrary("dos.library", 37L ))
				{
					Close(libbase->ml_SyslogWindowFH) ;
					libbase->ml_SyslogWindowFH = NULL ;
					CloseLibrary((struct Library *)DOSBase) ;
				}
			}
			FreeMem(libbase->ml_ConfigSemaphore, (long)sizeof(struct SignalSemaphore)) ;
			FreeMem(libbase->ml_SyslogSemaphore, (long)sizeof(struct SignalSemaphore)) ;
			FreeMem(libbase->ml_relocs, (*libbase->ml_relocs * 4) + 4);
			seglist = libbase->ml_SegList;
			Remove( (struct Node *) libbase);
			libsize = libbase->ml_Lib.lib_NegSize + libbase->ml_Lib.lib_PosSize;
			FreeMem( (char *) libbase - libbase->ml_Lib.lib_NegSize,(LONG) libsize );
		}
    }
		/* return NULL or real seglist */
	return ( (ULONG) seglist );
}

