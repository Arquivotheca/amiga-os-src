TABLE OF CONTENTS

socket/accept
socket/access
socket/basename
socket/bind
socket/bindresvport
socket/bstring
socket/byteorder
socket/chdir
socket/close
socket/closedir
socket/connect
socket/crypt
socket/endhostent
socket/endnetent
socket/endpwent
socket/exit
socket/ffs
socket/fstat
socket/getdomainname
socket/getdtablesize
socket/getegid
socket/getgid
socket/getgroups
socket/gethostbyaddr
socket/gethostbyname
socket/gethostent
socket/gethostname
socket/getlogin
socket/getnetbyaddr
socket/getnetbyname
socket/getnetent
socket/getpass
socket/getpeername
socket/getpwent
socket/getpwname
socket/getpwuid
socket/getsockname
socket/getsockopt
socket/index
socket/inet_addr
socket/inet_lnaof
socket/inet_makeaddr
socket/inet_netof
socket/inet_network
socket/inet_ntoa
socket/listen
socket/opendir
socket/perror
socket/rcmd
socket/read
socket/readdir
socket/readv
socket/recv
socket/rewinddir
socket/ruserok
socket/select
socket/selectwait
socket/send
socket/setegid
socket/seteuid
socket/setgid
socket/setgroups
socket/sethostent
socket/sethostfile
socket/setnetent
socket/setpwent
socket/setsockopt
socket/setuid
socket/socket
socket/stat.c
socket/write
socket/writev
socket/accept                                                   socket/accept

   NAME
        accept -- accept new connection from socket

   SYNOPSIS
        ns = accept( s, name, len)

        int accept (int, struct sockaddr *, int *); 

   FUNCTION
        After a server executes the listen() call, a connection from 
        some client process is waited for by having the server execute
        the accept() call.  

    INPUTS
        s        socket descriptor

        name    pointer to the sockaddr struct that is returned

        len        pointer to the length of the sockaddr struct
                the value returned will be the actual size of the
                sockaddr struct that was returned


   RESULT
        ns        new socket descriptor or -1 on error

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

socket/access                                                   socket/access

   NAME
        access -- Check the accessibility of a file

   SYNOPSIS
        return = access( filename, mode)

        int access (char *, int); 

   FUNCTION
        Checks to see if a file can be accessed with a certain mode.
        Returns true (0) if mode is write and file is not found.

    INPUTS
        filename    name of the file

        mode        file mode

   RESULT
        0 is returned if successful.  -1 is returned on error.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

socket/basename                                               socket/basename

   NAME
        basename -- get the filename from the pathname

   SYNOPSIS
        name = basename( pathname )

        char *basename (char *); 

   FUNCTION
        Returns pointer to basename in the input string.

    INPUTS
        pathname    string containing pathname of file.

   RESULT
        name        pointer to basename in string

   EXAMPLE
        name = basename("dh0:graphics/pics/car.iff");
        name points to "car.iff"

   NOTES

   BUGS

   SEE ALSO

socket/bind                                                       socket/bind

   NAME
        bind -- bind a name to a socket

   SYNOPSIS
        return = bind (s, name, namelen)

        int bind (int, struct sockaddr *, int); 

   FUNCTION
        bind() assigns a name to an unnamed socket

    INPUTS
        s            
        name
        namelen

   RESULT
        0 is returned if successful.  -1 is returned on error.
        errno will contain the specific error.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

socket/bindresvport                                       socket/bindresvport

   NAME
        bindresvport -- Bind a socket to a privileged IP port

   SYNOPSIS
        return = bindresvport ( sd, sin )

        int bindresvport ( int, struct sockaddr_in *);

   FUNCTION
        bindresvport is used to bind a socket descriptor to a 
        priveleged IP port (in the range 0-1023).
        

    INPUTS
        sd    

        sin

   RESULT
        0 is returned if successful.  -1 is returned on error.
        errno will be set to the specific error code.

   EXAMPLE

   NOTES
        rresvport() is equivalent to bindresvport() except that
        rresvport() only works for TCP sockets.

   BUGS

   SEE ALSO

socket/bstring                                                 socket/bstring

   NAME
        bstring -- bit and byte string operations

   SYNOPSIS
        bcopy (src , dest, num)
        bmov  (src, dest, num)
        return = bcmp  (b1, b2, num)
        bset (src, num, c)
        bzero (src, num)

        void bcopy (void *, void *, int);
        void bmov (void *, void *, int);
        int bcmp (void *, void *, int);
        void bset (void *, int, char);
        void bzero(void *, int); 

   FUNCTION
        bcopy() and bmov() copy 'num' bytes from 'src' to 'dest'.  
        The two functions are identical. 

        bcmp() compares the two strings 'b1' and 'b2' for 'num' bytes.

        bset() sets 'num' bytes to 'c' starting at location 'src'.
        bzero() is a special case of bset() where 'c'=0.

   RESULT
        For bcmp(), 0 is returned if the two strings are identical,
        non-zero otherwise. 

   NOTES
        bcmp() and bcopy() are similar to memcpy() and memmove() except
        the parameters are in reverse order.

   BUGS

   SEE ALSO

socket/byteorder                                             socket/byteorder

   NAME
        byteorder -- macros to convert between host and network byte order

   SYNOPSIS
        #include <sys/types.h>
        #include <netinet/in.h>

        netlong   = htonl ( hostlong ); 
        netshort  = htons ( hostshort);
        hostlong  = ntohl ( netlong );
        hostshort = ntohs ( netshort);

   FUNCTION
        These routines convert between host byte order to network byte
        order.  This is necessary because not all CPUs store words and
        longs in the same manner.  Some CPUs, called "Big Endian" store
        words as high byte followed by low byte.  Others, called "Little
        Endian" store a word as low byte followed by high byte.

        Big endian machines include IBM mainframes and Motorola 68000
        family machines.  Little endian machines include DEC VAXen and
        Intel 80x86 family CPUs.

        Network order is big endian.  Therefore, on big endian machines,
        these functions are null macros.

   EXAMPLE

   NOTES
        These macros are provided for portability.
        They are null macros on the Amiga.

        #define htons(x)    (x)
        #define ntohs(x)    (x)
        #define htonl(x)    (x)
        #define ntohl(x)    (x)

   SEE ALSO

socket/chdir                                                     socket/chdir

   NAME
        chdir -- change directory

   SYNOPSIS
        return = chdir( path )

        int chdir (char *); 

   FUNCTION
        chdir() changes the current working directory to the
        specified path.

    INPUTS
        path    pathname

   RESULT
        0 is returned if successful.  -1 is returned on error.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

socket/close                                                     socket/close

   NAME
        close -- close a file

   SYNOPSIS
        status = close ( unit );

        int  = close ( int ); 

   FUNCTION
        This function closes a file.

    INPUTS
        unit        unit number

   RESULT
        status        = 0 if successful
                    = -1 if error occurred

   EXAMPLE

   NOTES
        This replaces the normal compiler close() function.

   BUGS

   SEE ALSO
        read(), write()

socket/closedir                                               socket/closedir

   NAME
        closedir -- closes a directory stream

   SYNOPSIS
        #include <sys/types.h>
        #include <sys/dir.h>

        result = closedir( dirp )

        int closedir (DIR *); 

   FUNCTION
        Closes the named directory stream.

    INPUTS
        dirp    directory stream from opendir().

   RESULT
        Returns 0.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        readdir(), rewinddir(), opendir()

socket/connect                                                 socket/connect

   NAME
        connect -- connect to socket

   SYNOPSIS
        return = connect( s, name, namelen)

        int connect (int, struct sockaddr *, int); 

   FUNCTION
        *
    INPUTS
        s        socket

        name    

        namelen    

   RESULT
        0 is returned if successful.  -1 is returned on error.
        errno will be set to the specific error code.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

socket/crypt                                                     socket/crypt

    NAME
        crypt - encryption of password

    SYNOPSIS
        crypt_string = crypt( password, username )

        char *crypt( char *, char * )

    FUNCTION
        Encrypt a password, using the the user's name in the mix so as to
        provide a unique passwd even if two users should select the same
       passwd.

    INPUTS
        password - pointer to the user's password entry.
        username - the user's login name.

    RESULT
        Pointer to the encrypted result string.  This string is always
        eleven (11) characters long.

   
socket/endhostent                                           socket/endhostent

   NAME
        endhostent -- closes the inet:db/hosts file

   SYNOPSIS
        endhostent ()

        void endhostent (void); 

   FUNCTION
        Closes the host file if it is open.

    INPUTS

   RESULT

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        gethostent(), gethostbyname(), gethostbyaddr(), sethostent()

socket/endnetent                                             socket/endnetent

   NAME
        endnetent -- closes the inet:db/networks file

   SYNOPSIS
        endnetent ()

        void endnetent (void); 

   FUNCTION
        Closes the host file if it is open.

    INPUTS

   RESULT

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        getnetent(), getnetbyname(), getnetbyaddr(), setnetent()

socket/endpwent                                               socket/endpwent

    NAME
        endpwent - Closes the passwd file.

    SYNOPSIS
        success = endpwent()

        int endpwent( void )

    FUNCTION
        endpwent closes the passwd file.

    INPUTS
        none


    RESULT
        success - integer 0 (zero) upon success.  (-1) upon failure.


    NOTES


    SEE ALSO
        setpwent()
   
socket/exit                                                       socket/exit

   NAME
        exit -- cleanup and exit program

   SYNOPSIS
        exit( status )

        void exit (int); 

   FUNCTION
        This function flushes all buffers and closes all files.
        The BSD return codes are then mapped to AmigaDOS return
        codes.

    INPUTS
        status        integer -  mapped as follows

        BSD            AmigaDOS
        1            RETURN_FAIL (20)
        0            RETURN_OK    (0)
        -1          RETURN_WARN    (5)

   NOTES

   BUGS

   SEE ALSO

socket/ffs                                                         socket/ffs

   NAME
        ffs -- find the first bit set

   SYNOPSIS
        return = ffs(i)

        int ffs (int); 

   FUNCTION
        returns the index of the first bit set in i.
        Bits are numbered starting with 1 from the right.

    INPUTS
        i    integer

   RESULT
        1-32 will be returned if successful.  
        -1 is returned if the input is zero.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

socket/fstat                                                     socket/fstat

   NAME
        fstat -- obtain information about an open file

   SYNOPSIS
        #include <sys/types.h>
        #include <sys/stat.h>

        return = fstat( fd, buf )

        int fstat (int , struct stat *); 

   FUNCTION
        This function is only partially implemented.  A full
        implementation will be available in the future.

        Fills out the stat structure pointer to by buf.  The following
        fields are filled in:
        
        u_short        st_mode;    always S_IFREG
        short        st_uid;         see notes
        short        st_gid;         see notes
        long        st_size;
        long        st_mtime;     always 0
        long        st_atime;     always 0
        short        st_nlink;     always 1
        short        st_blksize;     always 8192     

    INPUTS
        fd        file descriptor returned from open().

        buf        pointer to stat structure.

   RESULT
        0 is returned if successful.  -1 is returned on error.
        errno will be set to the specific error code.

   EXAMPLE

   NOTES
         st_uid and st_gid will be set to that of the local user.  
        The networking software must have been started or -1 will 
        be returned for both.

   BUGS

   SEE ALSO

socket/getdomainname                                     socket/getdomainname

   NAME
        getdomainname -- get domain name

   SYNOPSIS
        return = getdomainname( name, namelen)

        int getdomainname (char *, int); 

   FUNCTION
        Returns the name of the domain into the pointer specified.
        Name will be null-terminated if sufficient space is available.

    INPUTS
        name        pointer to character buffer
    
        namelen        space available in name

   RESULT
        0 is returned if successful.  -1 is returned on error.
        errno will be set to the specific error code.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

socket/getdtablesize                                     socket/getdtablesize

   NAME
        getdtablesize -- get descriptor table size

   SYNOPSIS
        numfds = getdtablesize()

        int getdtablesize(); 

   FUNCTION
        Returns the size of the descriptor table. 

    INPUTS

   RESULT
        numfds    number of descriptors;

   EXAMPLE

   NOTES
        In Manx, this is fixed at MAXSTREAM in stdio.h.
        
   BUGS

   SEE ALSO

socket/getegid                                                 socket/getegid

   NAME
        getegid -- get effective group id

   SYNOPSIS
        gid = getegid()

        int getegid (); 

   FUNCTION
        returns the group id 

    INPUTS

   RESULT
        gid        group id
        if not found, gid will be -1.

   EXAMPLE

   NOTES
        gid is read by config from inet:s/inet.config.
        It is then stored in a global memory location.

        getegid() is equivalent to getgid() on the Amiga

   BUGS

   SEE ALSO
        getgid(), getgroups(), getuid()

socket/getgid                                                   socket/getgid

   NAME
        getgid -- get group id

   SYNOPSIS
        gid = getgid()

        int getgid (); 

   FUNCTION
        returns the group id 

    INPUTS

   RESULT
        gid        group id
        if not found, gid will be -1.

   EXAMPLE

   NOTES
        gid is read by config from inet:s/inet.config.
        It is then stored in a global memory location.

        getegid() is equivalent to getgid() on the Amiga

   BUGS

   SEE ALSO
        getegid(), getgroups(), getuid()

socket/getgroups                                             socket/getgroups

   NAME
        getgroups -- get group access list

   SYNOPSIS
        num = getgroups(max_gids, gids)

        int getgroups (int, int *); 

   FUNCTION
        The array "gids" is filled with the group ids that the current
        user belongs to.  The list may be up to "max_gids" long.  
        The actual number of gids is returned by the function.

    INPUTS
        max_gids    length of gids array
        gids        integer array

   RESULT
        The number of gids is returned if successful.  
        -1 is returned on error.
        errno will be set to the specific error code.

   EXAMPLE

   NOTES
        The gids are read by config from inet:s/inet.config.
        They are then stored in a global memory location.

   BUGS

   SEE ALSO
        getgid()

socket/gethostbyaddr                                     socket/gethostbyaddr

   NAME
        gethostbyaddr -- get host entry from the inet:db/hosts file

   SYNOPSIS
        #include <sys/socket.h>
        #include <netdb.h>

        host = gethostbyaddr ( addr, len, type )

        struct hostent *gethostbyaddr ( char *, int, int ); 

   FUNCTION
        Opens the host file if necessary.  Finds the entry for "name"
        and returns it in a hostent structure.

        struct    hostent {
            char    *h_name;            official name of host
            char    **h_aliases;        alias list
            int    h_addrtype;                host address type
            int    h_length;                length of address
            char    **h_addr_list;        list of addresses from name server
        #define    h_addr    h_addr_list[0]    messed up for historical reaso
ns
        };

    INPUTS
        addr    internet address, in network byte order
                this is really a long

        len        sizeof(addr), usually 4
        type    usually AF_INET

   RESULT
        Returns NULL on EOF or failure to open hosts file.

   EXAMPLE

   NOTES
        The only type currently in use is AF_INET

   BUGS

   SEE ALSO
        sethostent(), gethostent(), gethostbyaddr(), endhostent()

socket/gethostbyname                                     socket/gethostbyname

   NAME
        gethostbyname -- get host entry from the inet:db/hosts file

   SYNOPSIS
        #include <sys/socket.h>
        #include <netdb.h>

        host = gethostbyname ( name )

        struct hostent *gethostbyname ( char * ); 

   FUNCTION
        Opens the host file if necessary.  Finds the entry for "name"
        and returns it in a hostent structure.

        struct    hostent {
            char    *h_name;        official name of host
            char    **h_aliases;    alias list
            int    h_addrtype;            host address type
            int    h_length;            length of address
            char    **h_addr_list;    list of addresses from name server
        #define    h_addr    h_addr_list[0]    
        };

    INPUTS

   RESULT
        Returns NULL on EOF or failure to open hosts file.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        sethostent(), gethostent(), gethostbyaddr(), endhostent()

socket/gethostent                                           socket/gethostent

   NAME
        gethostent -- get host entry from the inet:db/hosts file

   SYNOPSIS
        #include <sys/socket.h>
        #include <netdb.h>

        host = gethostent ( )

        struct hostent *gethostent ( void ); 

   FUNCTION
        Opens the host file if necessary.  Returns the next entry
        in the file in a hostent structure.

        struct    hostent {
            char    *h_name;        official name of host
            char    **h_aliases;    alias list
            int    h_addrtype;            host address type
            int    h_length;            length of address
            char    **h_addr_list;    list of addresses from name server
        #define    h_addr    h_addr_list[0]    
        };

    INPUTS

   RESULT
        Returns NULL on EOF or failure to open hosts file.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        sethostent(), gethostbyname(), gethostbyaddr(), endhostent()

socket/gethostname                                         socket/gethostname

   NAME
        gethostname -- get the hostname of your Amiga

   SYNOPSIS
        return = gethostname( name, length )

        int gethostname (char *, int); 

   FUNCTION
        Returns a null-terminated hostname in "name".

    INPUTS
        name    pointer to character array

        length    size of character array

   RESULT
        0 is returned if successful.  -1 is returned on error.
        errno will be set to the specific error code.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        sethostname()

socket/getlogin                                               socket/getlogin

    NAME
        getlogin - gets the current login name

    SYNOPSIS
        name = getlogin()

        char * getlogin( void )

    FUNCTION
        Returns a pointer to the current login name. In the Amiga's case
        this function always returns NULL.


    INPUTS
        none


    RESULT
        pointer to a string


    NOTES
        As currently implemented, this function always returns a NULL.
        The correct procedure is to call getlogin() and if it returns
        NULL, call getpwuid().

socket/getnetbyaddr                                       socket/getnetbyaddr

   NAME
        getnetbyaddr -- get net entry from the inet:db/networks file

   SYNOPSIS
        #include <netdb.h>

        net = getnetbyaddr ( net, type )

        struct netent *getnetent ( long, int ); 

   FUNCTION
        Opens the networks file if necessary.  Returns the entry
        with a matching address in a nettent structure.

        struct    netent {
            char        *n_name;        official name of net 
            char        **n_aliases;    alias list
            int            n_addrtype;        net address type
            unsigned long    n_net;        network #
        };

    INPUTS
        net        network number
        type    network number type, currently AF_INET

   RESULT
        Returns NULL if no match.
        Returns NULL on EOF or failure to open networks file.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        setnetent(), getnetbyname(), getnetent(), endnetent()

socket/getnetbyname                                       socket/getnetbyname

   NAME
        getnetbyname -- get net entry from the inet:db/networks file

   SYNOPSIS
        #include <netdb.h>

        net = getnetbyname ( name )

        struct netent *getnetbyname ( char * ); 

   FUNCTION
        Opens the networks file if necessary.  Returns the entry
        with a matching name in a nettent structure.

        struct    netent {
            char        *n_name;        official name of net
            char        **n_aliases;    alias list
            int        n_addrtype;            net address type
            unsigned long    n_net;        network #
        };

    INPUTS
        name        network name

   RESULT
        Returns NULL if no match.
        Returns NULL on EOF or failure to open networks file.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        setnetent(), getnetbyaddr(), getnetent(), endnetent()

socket/getnetent                                             socket/getnetent

   NAME
        getnetent -- get net entry from the inet:db/networks file

   SYNOPSIS
        #include <netdb.h>

        net = getnetent ( )

        struct netent *getnetent ( void ); 

   FUNCTION
        Opens the networks file if necessary.  Returns the next entry
        in the file in a nettent structure.

        struct    netent {
            char        *n_name;        official name of net
            char        **n_aliases;    alias list
            int        n_addrtype;            net address type
            unsigned long    n_net;        network #
        };

    INPUTS

   RESULT
        Returns NULL on EOF or failure to open networks file.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        setnetent(), getnetbyname(), getnetbyaddr(), endnetent()

socket/getpass                                                 socket/getpass

    NAME
        getpass - Get a password entry from the user 

    SYNOPSIS
        password = getpass( prompt )

        char *getpass( char * )

    FUNCTION
        Gets a password string from the user. 


    INPUTS
        prompt - A string which will prompt the user.

    RESULT
        password - A pointer to the string.

    NOTES
        Control-X clears the line and starts over.

    BUGS
        (1) There are currently no checks on the length (max == 32) of the
            string entered by the user. 

socket/getpeername                                         socket/getpeername

   NAME
        getpeername -- get name of connected peer

   SYNOPSIS
        return = getpeername( s, name, namelen )

        int getpeername ( int, struct sockaddr *, int * ); 

   FUNCTION
        Returns the name of the peer connected to a socket.

    INPUTS
        s        socket descriptor
        name    pointer to a struct sockaddr
        namelen    initialized to sizeof(name). On return this contains
                the actual sizeof(name)

   RESULT
        0 is returned if successful.  -1 is returned on error.
        errno will be set to the specific error code.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        bind(), socket(), getsockname()

socket/getpwent                                               socket/getpwent

    NAME
        getpwent - Read the next line in the passwd file.

    SYNOPSIS
        passwd = getpwent()

        struct passwd *getpwent( void ) ;

    FUNCTION
        getpwent read the next line of the passwd file, filling the
        fields in the passwd structure with the fields the line.


    INPUTS
        None


    RESULT
        passwd - a pointer to a filled in passwd structure if successful,
                 NULL upon failure.
    SEE ALSO

   
socket/getpwname                                             socket/getpwname

    NAME
        getpwname - Fill in a password structure with a line from from the
                    password file using the user name as the key.

    SYNOPSIS
        passwd = getpwname( name )

        struct passwd *getpwname( char * ) 

    FUNCTION
        Getpwname returns a pointer to a passwd structure. The passwd
        structure fields are filled in from the fields contained in
        one line of the passwd file (inet:db/passwd)

    INPUTS
        name - a pointer to the user name

    RESULT
        passwd - A pointer to a passwd struct with it's elements filled in
                 from the passwd file.

    NOTES

            #include <sys/types.h>
            
            struct passwd {
                char    *pw_name;
                char    *pw_dir;
                char    *pw_passwd;
                char    *pw_gecos;
                uid_t    pw_uid, pw_gid;
                char    *pw_shell;          
                char    *pw_comment;    
            };

   
socket/getpwuid                                               socket/getpwuid

    NAME
        getpwuid - Fill in a password structure with a line from from the
                   password file using the user ID as the key.

    SYNOPSIS
        passwd = getpwuid( uid )

        struct passwd *getpwuid( int ) 

    FUNCTION
        Getpwuid returns a pointer to a passwd structure. The passwd
        structure fields are filled in from the fields contained in
        one line of the passwd file (inet:db/passwd)

    INPUTS
        uid - an integer representing the current user id

    RESULT
        passwd - A pointer to a passwd struct with it's elements filled in
                 from the passwd file.

    NOTES

            #include <sys/types.h>
            
            struct passwd {
                char    *pw_name;
                char    *pw_dir;
                char    *pw_passwd;
                char    *pw_gecos;
                uid_t    pw_uid, pw_gid;
                char    *pw_shell;         
                char    *pw_comment;    
            };

   
socket/getsockname                                         socket/getsockname

   NAME
        getsockname -- get the name of a socket

   SYNOPSIS
        return = getsockname( s, name, namelen )

        int getsockname ( int, struct sockaddr *, int * ); 

   FUNCTION
        Returns the name of the specified socket.  Namelen should be
        initialized to the amount of space pointed to by name.  The
        actual size of name will be returned.

    INPUTS
        s        socket descriptor
        name    socket name
        namelen    sizeof(name)

   RESULT
        0 is returned if successful.  -1 is returned on error.
        errno will be set to the specific error code.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

socket/getsockopt                                           socket/getsockopt

   NAME
        getsockopt -- get socket options

   SYNOPSIS
        return = getsockopt( s, level, optname, optval, optlen )

        int getsockopt ( int, int, int, char *, int * ); 

   FUNCTION
        Returns the option specified by optname for socket s.

    INPUTS
        s        socket descriptor

        level    protocol level.  valid levels are
                IPPROTO_IP        IP options
                IPPROTO_TCP        TCP options
                SOL_SOCKET        socket options

        optname    option name

        optval    pointer to the buffer which gets the value

        optlen    initially sizeof(optval). reset to proper value on return

        mode        file mode

   RESULT
        0 is returned if successful.  -1 is returned on error.
        errno will be set to the specific error code.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

socket/index                                                     socket/index

   NAME
        index -- find a character in a string

   SYNOPSIS
        ptr = index( s, c )

        char *index ( char *, char ); 

   FUNCTION
        Returns a pointer to the first occurrence of the character c
        in string s.

    INPUTS
        s    input string

        c    character to find

   RESULT
        ptr        pointer to first character c in string s

        Will return NULL if c is not found.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

socket/inet_addr                                             socket/inet_addr

   NAME
        inet_addr -- make internet address from string

   SYNOPSIS
        #include <sys/types.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>

        addr = inet_addr( string )

        u_long inet_addr ( char * ); 

   FUNCTION
        Converts a string to an internet address. All internet addresses
        are in network order.

    INPUTS
        string        address string. "123.45.67.89" for example

   RESULT
        INADDR_NONE is returned if input is invalid.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

socket/inet_lnaof                                           socket/inet_lnaof

   NAME
        inet_lnaof -- give the local network address

   SYNOPSIS
        #include <sys/types.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>

        addr = inet_lnaof( in )

        u_long inet_lnaof ( struct in_addr ); 

   FUNCTION
        Returns the local network address

    INPUTS
        in    

   RESULT

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

socket/inet_makeaddr                                     socket/inet_makeaddr

   NAME
        inet_makeaddr -- make internet address from network and host

   SYNOPSIS
        #include <sys/types.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>

        addr = inet_makeaddr( net, lna )

        struct in_addr inet_addr ( int, int ); 

   FUNCTION
         Formulate an Internet address from network + host.  Used in
        building addresses stored in the ifnet structure.

    INPUTS

   RESULT

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

socket/inet_netof                                           socket/inet_netof

   NAME
        inet_netof -- give the network number

   SYNOPSIS
        #include <sys/types.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>

        net = inet_netof( in )

        u_long inet_netof ( struct in_addr ); 

   FUNCTION
        Returns the network number

    INPUTS
        in    

   RESULT

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        inet_addr(), inet_makeaddr(), inet_lnaof()

socket/inet_network                                       socket/inet_network

   NAME
        inet_network -- make network number from string

   SYNOPSIS
        #include <sys/types.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>

        net = inet_network( string )

        u_long inet_network ( char * ); 

   FUNCTION
        Converts a string to an network number. All network numbers
        are in network order.

    INPUTS
        string        network string. "123.45.67.89" for example

   RESULT
        INADDR_NONE is returned if input is invalid.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

socket/inet_ntoa                                             socket/inet_ntoa

   NAME
        inet_ntoa -- turn internet address into string

   SYNOPSIS
        #include <sys/types.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>

        string = inet_ntoa( in )

        char *inet_addr ( struct in_addr ); 

   FUNCTION
        Converts an internet address to s string.

    INPUTS

   RESULT
        pointer to a string

   EXAMPLE

   NOTES
        The result points to a static buffer that is overwritten
        with each call.

   BUGS

   SEE ALSO

socket/listen                                                   socket/listen

   NAME
        listen -- wait for connections

   SYNOPSIS
        return = listen( s, backlog)

        int listen (int , int); 

   FUNCTION
        This function is used on a connection-oriented server (TCP)
        to indicate it is waiting to receive connections.  It is usually
        executed after socket() and bind(), and before accept().
        
    INPUTS
        s        - socket descriptor
        backlog    - max number of connection requests to que (usually 5)

   RESULT
        0 is returned if successful.  -1 is returned on error.
        On error, errno will be set to one of the following:

        EBADF        - s is not a valid descriptor
        ENOTSOCK    - s is not a socket
        ECONNREFUSED- connection refused, normally because the queue is full 
           
        EOPNOTSUPP    - s is a socket type which does not support this 
                        operation.  s must be type SOCK_STREAM.

   BUGS
        backlog is currently limited to 5

   SEE ALSO
        accept(), bind(), connect(), socket()
socket/opendir                                                 socket/opendir

   NAME
        opendir -- opens a directory

   SYNOPSIS
        #include <sys/types.h>
        #include <sys/dir.h>

        dirp = opendir( dirname )

        DIR *opendir (char *); 

   FUNCTION
        Opens the named directory and returns a pointer to the
        directory stream.  

    INPUTS
        dirname        name of the directory

   RESULT
        Returns a pointer to the directory stream if successful.
        Returns NULL if dirname cannot be accessed.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        readdir(), rewinddir(), closedir()

socket/perror                                                   socket/perror

    NAME
        perror - print to stderr the string associated with the current
        value of the global int 'errno'.

    SYNOPSIS
        perror( error_message )

        void perror( const char * )        (Manx version)
        int perror ( char * )            (SAS version) 

    FUNCTION

        The perror subroutine produces a short error message on the
        standard error file describing the last error encountered
        during a call to the system. First the argument string s is
        printed, then a colon, then the message and a new line. 

    INPUTS
        
        error_message - a string normally used to identify the source of
        the error. Often the file name is used.

    RESULT

        The SAS version always return 0.
       
socket/rcmd                                                       socket/rcmd

    NAME
        rcmd - Allow superuser to execute commands on remote machines

    SYNOPSIS
        rem = rcmd( ahost, inport, luser, ruser, cmd, fd2p )

        int rcmd( char **, u_short, char *, char *, char *, int )

    FUNCTION

        The rcmd subroutine looks up the host *ahost using gethostbyname,
        returning (-1) if the host does not exist. Otherwise *ahost is
        set to the standard name of the host and a connection is
        established to a server residing at the well-known Internet port 
        inport.
        
        If the call succeeds, a socket of type SOCK_STREAM is returned to
        the caller and given to the remote command as stdin and stdout.
        If fd2p is nonzero, then an auxiliary channel to a control
        process will be set up, and a descriptor for it will be placed in
        *fd2p. The control process will return diagnostic output from the
        command (unit 2) on this channel, and will also accept bytes on
        this channel as being UNIX signal numbers, to be forwarded to the
        process group of the command. If fd2p is 0, then the stderr (unit
        2 of the remote command) will be made the same as the stdout and
        no provision is made for sending arbitrary signals to the remote
        process, although you may be able to get its attention by using
        out-of-band data. 


    INPUTS
        ahost  - pointer to host name.
        inport - an Internet port
        luser  - the local user's name
        ruser  - the remote user's name
        cmd    - the command string to be executed
       fd2p   - a flag telling whether to use an auxillary channel

    RESULT
        
       rem = A socket of type SOCK_STREAM if successful. (-1) upon failure.

   
socket/read                                                       socket/read

   NAME
        read -- read a file

   SYNOPSIS
        status = read ( unit, buffer, length);

        int  = read ( int, char *, unsigned); 

   FUNCTION
        This function reads the next set of bytes from a file
        that has been activated via a previous open call.

    INPUTS
        unit        unit number
        buffer        input buffer
        length        buffer length in bytes

   RESULT
        status        = number of bytes actually read
                    = 0 if end of file
                    = -1 if error occurred

   EXAMPLE

   NOTES
        This replaces the normal compiler read() function.

   BUGS

   SEE ALSO
        write(), close()

socket/readdir                                                 socket/readdir

   NAME
        readdir -- reads a directory

   SYNOPSIS
        #include <sys/types.h>
        #include <sys/dir.h>

        next_dir = readdir( dirp )

        struct direct *readdir (DIR *); 

   FUNCTION
        returns a pointer to the next directory entry.

    INPUTS
        dirp    directory stream from opendir().

   RESULT
        Returns a pointer to the next directory entry if successful.
        Returns NULL on end of directory.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        opendir(), rewinddir(), closedir()

socket/readv                                                     socket/readv

    NAME
        readv - read data from a file into multiple buffers

    SYNOPSIS
        bytes = readv( file, iovec, count )

        int  readv( int, struct iovec *, int )

    FUNCTION
        Readv() attempts to read nbytes of data from the object 
        referenced by the file descriptor, scattering the input
        data into the buffers specified by the members of the 
        iovec following array: iov[0], iov[1], ..., iov[iovcnt-1].

        The iovec structure:

        struct iovec {
            caddr_t   iov_base;
            int  iov_len;
        };

        Each iovec entry specifies the base address and length of an
        area in memory where data should be placed. The readv system
        call fills an area completely before proceeding to the next
        area.

    INPUTS
        file  - a socket or file descriptor
        iovec - a pointer to an array of iovec structures
        count - the number of iovec structures in iovec

    RESULT
        success - number of bytes read is successful
                - (-1) upon failure with the global integer 'errno'
                  set to EOI (as defined in <errno.h>)

    SEE ALSO
        writev()
   
socket/recv                                                       socket/recv

    NAME
        recv, recvfrom, recvmsg - receive a message from a socket

    SYNOPSIS
        #include <sys/types.h>
        #include <sys/socket.h>

        numbytes = recv( s, buf, len, flags )
        numbytes = recvfrom(s, buf, len, flags, from, fromlen )
        numbytes = recvmsg(s, msg, flags)

        int recv(int, caddr_t, int, int)
       int recvfrom( int, caddr_t, int, int, struct sockaddr *, int* )
        int recvmsg(int, struct msghdr *, int)

    FUNCTION
        This function is used to receive messages on an already connected
        socket. 

        Recvfrom receives data from a socket whether it is in a connected
        state or not.

    INPUTS
        s         - a socket descriptor
        buf     - the buffer into which the incoming data will be placed
        len     - the size of the buffer
        flags   - select options (MSG_OOB, MSG_PEEK)
        from    - a pointer to a sockaddr structure
        fromlen - Length of the 'from' buffer.
        msg        - pointer to a struct msghdr, defined in sys/socket.h

    RESULT
        numbytes - number of bytes read if successful or (-1) upon failure.

    NOTES
        fromlen is passed with the length of the 'from' buffer.  If 'from' 
        is non-zero, the structure will be filled with the source address
        and fromlen will be filled in to represent the size of the actual
        address stored in 'from'.

   
socket/rewinddir                                             socket/rewinddir

   NAME
        rewinddir -- set position in directory back to beginning.

   SYNOPSIS
        #include <sys/types.h>
        #include <sys/dir.h>

        result = rewinddir( dirp )

        int rewinddir (DIR *); 

   FUNCTION
        Sets the position in the directory stream back to the beginning.

    INPUTS
        dirp    directory stream from opendir().

   RESULT
        Returns -1 if unsuccessful.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        readdir(), opendir(), closedir()

socket/ruserok                                                 socket/ruserok

    NAME
        ruserok - authenticate clients requesting service with rcmd.

    SYNOPSIS
        valid = ruserok( rhost, superuser, ruser, luser )

        int = ruser( char *, int, char *, char * )

    FUNCTION

        The ruserok subroutine takes a remote host's name, as          
        returned by a gethostent(3n) routine, two user names and a     
        flag indicating if the local user's name is the superuser.     
        It then checks the files /etc/hosts.equiv and .rhosts in the   
        user's home directory to see if the request for service is     
        allowed.  A 1 is returned if the machine name is listed in     
        the hosts.equiv file, or the host and remote user name are     
        found in the .rhosts file. Otherwise ruserok returns -1. If  
        the superuser flag is 1, the checking of the hosts.equiv       
        file is bypassed.                                              

    INPUT

        rhost     - The desired remote hosts name
        suoeruser - Flag telling if local user's name is superuser.
        ruser     - The remote user's name.
        luser     - The local user's name.

    RESULT
        valid - (-1) on error or invalid user. Zero (0) upon success.



    SEE ALSO

   
socket/select                                                   socket/select

    NAME
        select - Examines the specified file descriptors for read, 
                 write or exception status.

    SYNOPSIS
        num = select( numfds, readfds, writefds, exceptfds, timeout)

        int select( int, int *, int *, int *, struct timeval * )    

    FUNCTION
        The select call examines the I/O descriptors specified by 
        the bit masks readfds, writefds, and execptfds to see if 
        they are ready for reading, writing, or have an exceptional
        condition pending, respectively. The I/O descriptors can be
        pointers to arrays of integers if multiple fd's are required
        to be selected. File descriptor f is represented by the bit 
        "1<<f" in the mask. The nfds descriptors are checked, that is
        the bits from 0 through nfds-1 in the masks are examined. The
        select system call returns, in place, a mask of those 
        descriptors which are ready. The total number of ready 
        descriptors is returned in nfound.

        If timeout is a nonzero pointer, it specifies a maximum 
        interval to wait for the selection to complete. If timeout is
        a zero pointer, the select blocks indefinitely. To affect a 
        poll, the timeout argument should be nonzero, pointing to a 
        zero valued timeval structure. ** SEE BUGS NOTE BELOW ! **

        Any of readfds, writefds, and execptfds may be given as 0 if 
        no descriptors are of interest.

    RESULT
        The select system call returns the number of descriptors 
        which are contained in the bit masks, or -1 if an error 
        occurred. If the time limit expires then select returns 0.

    NOTES
        If a process is blocked on a select waiting for input from a
        socket and the sending process closes the socket, the select
        notes this as an exception rather than as data.  Hence, if
        the select is not currently looking for exceptions, it will
        wait forever.

        The descriptor masks are always modified on return, even if
        the call returns as the result of the timeout.

         The current version of this function calls selectwait()
        with a control-C option in the umask field.

    INPUTS
        numfds    - Maximum number of bits in the masks that
                    represent valid file descriptors.
        readfds   - 32 bit mask representing read file descriptors
        writefds  - 32 bit mask representing write file descriptors 
        exceptfds - 32 bit mask representing except file descriptors 
        timeout   - Pointer to a timeval structure which holds the
                    maximum amount of time to wait for the selection 
                    to complete.
                    
        file descriptor 'f' is represented in the masks as bit "1 << f"
        in the mask.

    RESULT
        num       - The number of ready file descriptors if 
                    successful. Zero (0) is a timeout occurred.
                    (-1) upon error. 
        readfds   - A mask of the ready file descriptors
        writefds  -      "      "     "     "      "
        exceptfds -      "      "     "     "      "        

    BUGS
        The timer device in Amiga OS versions <= 1.3 has a bug that
        can cause system problems if a request is made for a timer 
        return in under 5 microseconds. So, to effect a polled call 
        to select() the timeval structure should be:

            struct timeval *tvp ;
                tvp->tv_secs = 0L ;
                tvp->tv_secs = 5L ;    <<<<<---- not ZERO !

        This will avoid the problem. Failure to do this can cause 
        system errors.

    SEE ALSO
        selectwait()
   
socket/selectwait                                           socket/selectwait

    NAME
        selectwait - Examines the specified file descriptors for read, 
                     write or exception status with an optional, task-
                     specific signal mask.

    SYNOPSIS
        num = selectwait(numfds, rfds, wfds, exfds, time, umask)

        int selectwait
            (int, int *, int *, int *, struct timeval *, long *) 

    FUNCTION
        The select call examines the I/O descriptors specified by 
        the bit masks readfds, writefds, and execptfds to see if 
        they are ready for reading, writing, or have an exceptional
        condition pending, respectively. The I/O descriptors can be
        pointers to arrays of integers if multiple fd's are required
        to be selected. File descriptor f is represented by the bit 
        "1<<f" in the mask. The nfds descriptors are checked, that is
        the bits from 0 through nfds-1 in the masks are examined. The
        select system call returns, in place, a mask of those 
        descriptors which are ready. The total number of ready 
        descriptors is returned in nfound.

        If timeout is a nonzero pointer, it specifies a maximum 
        interval to wait for the selection to complete. If timeout is
        a zero pointer, the select blocks indefinitely. To affect a 
        poll, the timeout argument should be nonzero, pointing to a 
        zero valued timeval structure. ** SEE BUGS NOTE BELOW ! **

        The umask argument should contain either a ZERO or a mask
        of the desired task-specific signal bits that will be tested
        along with the file descriptors. Selectwait() does a standard
        Amiga Exec Wait() call and adds the supplied mask value to
        Wait() argument.

        Any of readfds, writefds, and execptfds may be given as 0 if 
        no descriptors are of interest.

    INPUTS
        numfds    - The maximum number of bits in the masks that
                    represent valid file descriptors.
        readfds   - 32 bit mask representing read file descriptors
        writefds  - 32 bit mask representing write file descriptors 
        exceptfds - 32 bit mask representing except file descriptors 
        timeout   - A pointer to a timeval structure which holds the
                    maximum amount of time to wait for the selection
                    to complete.
        umask     - A mask of the task's signal bits that will be
                    used (in addition to the standard select() call 
                    return options) to have the call return. This can
                    be SIGBREAKF signals, Intuition userport signals, 
                    console port signals, etc. Any mask that you would
                    pass to the the Exec Wait() call is ok here.

    RESULT
        num       - The number of ready file descriptors if 
                    successful. Zero (0) is a timeout occurred.
                    (-1) upon error. 
        readfds   - A mask of the ready file descriptors
        writefds  -      "      "     "     "      "
        exceptfds -      "      "     "     "      "        

        umask     - A mask of the bits in the originally passed 'umask'
                    variable that have actually occured.  

    EXAMPLE
        long umask = SIGBREAKF_CTRL_D | 1L << myport->mp_SigBit ;

        numfds = selectwait(n, r, w, e, time, &umask) ;
        if( event & SIGBREAKF_CTRL_D ) {
            printf("user hit CTRL-D\n") ;
        }
        if( event & 1L << myport->mp_SigBit ) {
            printf( "myport got a message\n" ) ;
        }

    BUGS
        The timer device in Amiga OS versions <= 1.3 has a bug that
        can cause system problems if a request is made fof a timer 
        return in under 5 microseconds. So, to effect a polled call 
        to select() the timeval structure should be:

            struct timeval *tvp ;
                tvp->tv_secs = 0L ;
                tvp->tv_secs = 5L ;    <<<<<---- not ZERO !

        This will avoid the problem. Failure to do this can cause 
        system errors.


    SEE ALSO
        select()
   
socket/send                                                       socket/send

   NAME
        send, sendto, sendmsg -- send data from a socket

   SYNOPSIS
        #include <sys/types.h>
        #include <sys/socket.h>

        cc = send   ( s, buf, len, flags)
        cc = sendto ( s, buf, len, flags, to, to_len)
        cc = sendmsg( s, msg, flags)

        int send (int, char *, int, int);
        int sendto (int, char *, int, int, struct sockaddr *, int);
        int sendmsg (int, struct msghdr *, int); 

   FUNCTION
        send(), sendto(), and sendmsg() transmit data from a socket.
        send() must be used with a connected socket because it has no
        destination parameter.  

    INPUTS
        s        - socket descriptor
        buf        - pointer to message buffer
        len        - length of message to transmit
        flags    - 0 or MSG_OOB to send out-of-band data
        to        - pointer to a sockaddr containing the destination
        to_len    - sizeof(struct sockaddr)
        msg        - pointer to a struct msghdr, defined in sys/socket.h     
           

   RESULT
        Returns the number of bytes sent. This does not imply the bytes
        were recieved.  -1 is returned on a local error.
        errno will be set to the specific error code. Possible errors are

        EBADF          an invalid descriptor was used

        ENOTSOCK      's' is not a socket

        EMSGSIZE      the socket requires that the message be sent
        atomically and the size of the message prevents that.

        EWOULDBLOCK   requested operation would block    

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        recv(), socket()

socket/setegid                                                 socket/setegid

    NAME
        setegid - Set the effective group ID

    SYNOPSIS
        success = setegid( gid )

        int setegid( uid_t gid )

    FUNCTION
        Sets the the effective group ID to the specified value        

    INPUTS
        gid - the desired ID value

    RESULT
        success - 0 (zero) upon success, -1 upon failure

    NOTES
        setgid() and setegid() are equivilent on the Amiga 

    SEE ALSO
        setegid, setuid, seteuid

   
   
socket/seteuid                                                 socket/seteuid

    NAME
        seteuid - set the effective user ID

    SYNOPSIS
        success = seteuid( uid )

        int seteuid( uid_t uid )

    FUNCTION
        Sets the effective user ID as specified

    INPUTS
        uid - The desired ID value

    RESULT
        success - 0 (zero) upon success and -1 upon failure


    SEE ALSO
        setuid, setegid
   
socket/setgid                                                   socket/setgid

    NAME
        setgid - Set the group ID and the effective group ID

    SYNOPSIS
        success = setgid( gid )

        int setgid( uid_t gid )

    FUNCTION
        Sets the the group ID and the effective group ID to the 
        specified value        

    INPUTS
        gid - the desired ID value

    RESULT
        success - 0 (zero) upon success, -1 upon failure

    NOTES
        setgid() and setegid() are equivilent on the Amiga 

    SEE ALSO
        setegid, setuid, seteuid
   
socket/setgroups                                             socket/setgroups

    NAME
        setgroups -  Set the group access list.

    SYNOPSIS
        success = setgroups( count, gidlist )

        int  setgroups( int, uid_t * )

    FUNCTION
        Setgroups() sets the group access list. 
        process according to the array gidset. The parameter
        ngroups indicates the number of entries in the array and
        must be no more than NGROUPS, as defined in <sys/param.h>.

    INPUTS
        count1  - An integer representing the number if groups in
                  the gidlist. No more than NGROUPS as defined in
                  <sys/param.h> will be used.
        gidlist - An array in pointers to type uid_t which hold
                  the desired group IDs.


    RESULT
        success - 0 (zero) opon success, -1 upon failure
   
socket/sethostent                                           socket/sethostent

   NAME
        sethostent -- rewind the inet:db/hosts file

   SYNOPSIS
        sethostent ( stayopen )

        void sethostent ( int ); 

   FUNCTION
        Rewinds the host file if it is open.
        If the stayopen flag is zero, the host file will be
        closed after each call to gethostent().

    INPUTS
        stayopen    integer flag

   RESULT

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        gethostent(), gethostbyname(), gethostbyaddr(), endhostent()

socket/sethostfile                                         socket/sethostfile

   NAME
        sethostfile -- changes the name of the host file

   SYNOPSIS
        sethostfile ( filename )

        void sethostfile ( char * ); 

   FUNCTION
        Changes the name of the hosts file.  The default is
        inet:db/hosts.

    INPUTS
        filename    name of the new hosts file

   RESULT

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        gethostent(), gethostbyname(), gethostent(), endhostent()

socket/setnetent                                             socket/setnetent

   NAME
        setnetent -- open or rewind the inet:db/networks file

   SYNOPSIS
        setnetent ( stayopen )

        void setnetent ( int ); 

   FUNCTION
        Rewinds the network file if it is open.
        If the stayopen flag is zero, the network file will be
        closed after each call to getnetent().

    INPUTS
        stayopen    integer flag

   RESULT

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        getnetent(), getnetbyname(), getnetbyaddr(), endnetent()

socket/setpwent                                               socket/setpwent

    NAME
        setpwent - Opens the passwd file.

    SYNOPSIS
        success = setpwent()

        int setpwent( void )

    FUNCTION
        if the file is already open the file is rewound. Otherwise the
        file is opened.

    INPUTS
        none

    RESULT
        success - integer 0 (zero) upon success.  (-1) upon failure.

    SEE ALSO
        endpwent()
   
socket/setsockopt                                           socket/setsockopt

   NAME
        setsockopt -- set socket options

   SYNOPSIS
        return = setsockopt( s, level, optname, optval, optlen )

        int setsockopt ( int, int, int, char *, int * ); 

   FUNCTION
        Sets the option specified by optname for socket s.

    INPUTS
        s        socket descriptor

        level    protocol level.  valid levels are
                IPPROTO_IP        IP options
                IPPROTO_TCP        TCP options
                SOL_SOCKET        socket options

        optname    option name

        optval    pointer to the buffer with the new value

        optlen    initially sizeof(optval). reset to new value on return

   RESULT
        0 is returned if successful.  -1 is returned on error.
        errno will be set to the specific error code.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
        getsockopt()

socket/setuid                                                   socket/setuid

    NAME
        setuid - set the real and effective user ID 


    SYNOPSIS
        success = setuid( uid ) 

        int setuid( uid_t uid )

    FUNCTION
        Sets the user ID to the value specified.

    INPUTS
        uid - the desired user id value

    RESULT
        success - 0 (zero) upon success, -1 upon failure.

    NOTES
        setuid() and seteuid() are equivilent on the Amiga

    SEE ALSO
        seteuid, setgid, setegid
   
socket/socket                                                   socket/socket

    NAME
        socket - create an endpoint for communication.

    SYNOPSIS
        s = socket( family, type, protocol )

        int socket( int, int, int )

    FUNCTION
        socket() returns a small integer representing a socket
        descriptor. 


    INPUTS
        family   - This specifies an address format with which
                   addresses specified in later operations using
                   socket should be interpreted.
        type     - Specifies the semantice of communication.
        protocol - Specifies a particular protocol to be used with the
                   socket.

    RESULT
        s        - Returns a (-1) upon failure ; a socket descriptor
                   upon success. 

   
socket/stat.c                                                   socket/stat.c

   NAME
        stat -- get file status

   SYNOPSIS
        #include <sys/types.h>
        #include <sys/stat.h>

        return = stat( filename, buf)

        int stat (char *, struct stat *); 

   FUNCTION
        obtains information about the named file

        Fills out the stat structure pointer to by buf.  The following
        fields are filled in:
        
        u_short        st_mode;
        short        st_uid;
        short        st_gid;
        long        st_size;
        long        st_mtime;
        long        st_atime;     same as st_mtime 
        short        st_nlink;     always 1 

    INPUTS
        filename    full or relative pathname of file

        buf            pointer to a stat structure which is filled in by stat
()

   RESULT
        0 is returned if successful.  -1 is returned on error.
        errno will be set to the specific error code.

   EXAMPLE
        struct stat buf;

        if (stat("devs:foo",&buf)==-1) {
            printf("Error: file not found\n");
            exit(1);
        }
        
   NOTES
        On Amiga files, st_uid and st_gid will be set to that
        of the local user.  The networking software must have been
        started or -1 will be returned for both.

   BUGS

   SEE ALSO
        fstat()

socket/write                                                     socket/write

   NAME
        write -- write to a file

   SYNOPSIS
        status = write ( unit, buffer, length);

        int  = write ( int, char *, unsigned); 

   FUNCTION
        This function writes a set of bytes to the current file
        position.

    INPUTS
        unit        unit number
        buffer        output buffer
        length        buffer length in bytes

   RESULT
        status        = number of bytes actually written
                    = -1 if error occurred

   EXAMPLE

   NOTES
        This replaces the normal compiler write() function.

   BUGS

   SEE ALSO
        read(), close()

socket/writev                                                   socket/writev

    NAME
        writev - write multiple buffers as an atomic operation.

    SYNOPSIS
        bytes_written = writev(file_descriptor, iovec, count)

        int writev(int , iovec *, int )

    FUNCTION
        Encapsulates multiple data buffers and writes the buffer
        to the named file descriptor.

    INPUTS
        file  - A file descriptor or socket.
        iovec - A pointer to the base of a structure array holding 
            the data and length of data to be written.
        count - The number of iovec structures in the array.

    RESULT
        Number of bytes written if sucessful.
        (-1) upon failure with global int 'errno' set to 'EIO' as
        defined in <errno.h>

    NOTES
        Errors in midwrite will return a -1 but the real status of things
        is unknown. IE, you could pass 10 iovec entries and have the
        call fail after three have been written.

    SEE ALSO
        readv()
   
