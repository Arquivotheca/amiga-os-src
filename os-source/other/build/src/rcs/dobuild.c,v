head     40.5;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


40.5
date     93.10.12.10.59.26;  author darren;  state Exp;
branches ;
next     40.4;

40.4
date     93.03.10.10.46.58;  author mks;  state Exp;
branches ;
next     40.3;

40.3
date     93.03.04.11.52.41;  author mks;  state Exp;
branches ;
next     40.2;

40.2
date     93.02.25.15.26.57;  author mks;  state Exp;
branches ;
next     40.1;

40.1
date     93.02.18.15.40.15;  author mks;  state Exp;
branches ;
next     1.20;

1.20
date     92.06.06.11.34.18;  author mks;  state Exp;
branches ;
next     1.19;

1.19
date     92.03.05.10.58.58;  author mks;  state Exp;
branches ;
next     1.18;

1.18
date     92.02.28.15.24.00;  author mks;  state Exp;
branches ;
next     1.17;

1.17
date     92.02.28.11.27.39;  author mks;  state Exp;
branches ;
next     1.16;

1.16
date     92.02.04.12.33.14;  author mks;  state Exp;
branches ;
next     1.15;

1.15
date     91.12.06.08.41.04;  author mks;  state Exp;
branches ;
next     1.14;

1.14
date     91.12.06.07.18.58;  author mks;  state Exp;
branches ;
next     1.13;

1.13
date     91.11.15.10.42.52;  author mks;  state Exp;
branches ;
next     1.12;

1.12
date     91.11.14.19.38.13;  author mks;  state Exp;
branches ;
next     1.11;

1.11
date     91.10.28.12.19.42;  author mks;  state Exp;
branches ;
next     1.10;

1.10
date     91.10.25.18.48.56;  author mks;  state Exp;
branches ;
next     1.9;

1.9
date     91.10.18.18.40.00;  author mks;  state Exp;
branches ;
next     1.8;

1.8
date     91.10.18.17.16.42;  author mks;  state Exp;
branches ;
next     1.7;

1.7
date     91.10.18.15.36.12;  author mks;  state Exp;
branches ;
next     1.6;

1.6
date     91.10.17.10.23.56;  author mks;  state Exp;
branches ;
next     1.5;

1.5
date     91.10.15.10.19.08;  author mks;  state Exp;
branches ;
next     1.4;

1.4
date     91.10.15.09.45.22;  author mks;  state Exp;
branches ;
next     1.3;

1.3
date     91.10.15.09.21.11;  author mks;  state Exp;
branches ;
next     1.2;

1.2
date     91.10.14.15.22.35;  author mks;  state Exp;
branches ;
next     1.1;

1.1
date     91.10.14.14.29.58;  author mks;  state Exp;
branches ;
next     ;


desc
@Master build control
@


40.5
log
@NOCHECKSUM switch added - used for building a resolved ROM image
which has no exec, and no need for checksum info.
@
text
@/*
 * $Id: dobuild.c,v 40.4 93/03/10 10:46:58 mks Exp Locker: darren $
 *
 * $Log:	dobuild.c,v $
 * Revision 40.4  93/03/10  10:46:58  mks
 * Added INTERLEAVE option to Word Interleave the kickstart
 * for the strange 16-bit in 32-bit system ROM hardware
 * 
 * Revision 40.3  93/03/04  11:52:41  mks
 * Added code needed to deal with 1Meg builds...
 * Requires the up-to-date build tools.
 *
 * Revision 40.2  93/02/25  15:26:57  mks
 * No longer uses the internal (private) include
 *
 * Revision 40.1  93/02/18  15:40:15  mks
 * CleanUp for SAS/C 6 compile
 *
 * Revision 1.20  92/06/06  11:34:18  mks
 * Added REKICK option and changed the way REKICK/FKICK work...
 *
 * Revision 1.19  92/03/05  10:58:58  mks
 * Fixed FKICK keyword
 *
 * Revision 1.18  92/02/28  15:24:00  mks
 * Added the BUMPREV option for AUTOREV
 *
 * Revision 1.17  92/02/28  11:27:39  mks
 * Added the AUTOREV and FKICK options...
 *
 * Revision 1.16  92/02/04  12:33:14  mks
 * Cleaned up the output from the QUICK option
 *
 * Revision 1.15  91/12/06  08:41:04  mks
 * Fixed typecast error.
 *
 * Revision 1.14  91/12/06  07:18:58  mks
 * Added CDTV_E and DIRECT support
 *
 * Revision 1.13  91/11/15  10:42:52  mks
 * Removed the ADD/REPLACE/REMOVE keywords and changed that to the
 * multi-arg CHANGE keyword
 *
 * Revision 1.12  91/11/14  19:38:13  mks
 * Now does revision 0 and CDTV:
 *
 * Revision 1.11  91/10/28  12:19:42  mks
 * Added the REMOVE and ADD options and change the REPLACE option
 *
 * Revision 1.10  91/10/25  18:48:56  mks
 * Added comment features to build lists and the ability to
 * offer replacement .ld files.  (Only replacements)
 *
 * Revision 1.9  91/10/18  18:40:00  mks
 * Added KickIt support
 *
 * Revision 1.8  91/10/18  17:16:42  mks
 * Added the CDTV: part of the CDTV switch.
 * Added the DIR switch
 * Added the TO switch
 *
 * Revision 1.7  91/10/18  15:36:12  mks
 * Added CDTV option and RELOC option
 *
 * Revision 1.6  91/10/17  10:23:56  mks
 * Cleaned up formatting so it will print nice
 *
 * Revision 1.5  91/10/15  10:19:08  mks
 * Added standard version string to the commands
 *
 * Revision 1.4  91/10/15  09:45:22  mks
 * Made the script generated with the SCRIPT keyword a bit better
 *
 * Revision 1.3  91/10/15  09:21:11  mks
 * Added the script file creation feature
 *
 * Revision 1.2  91/10/14  15:22:35  mks
 * Fixed log file output...
 *
 * Revision 1.1  91/10/14  14:29:58  mks
 * Initial revision
 *
 */

#include <exec/types.h>
#include <exec/execbase.h>
#include <exec/tasks.h>
#include <exec/memory.h>
#include <exec/alerts.h>

#include <string.h>

#include <clib/exec_protos.h>
#include <pragmas/exec_pragmas.h>

#include <clib/dos_protos.h>
#include <pragmas/dos_pragmas.h>

#include <utility/tagitem.h>
#include <clib/utility_protos.h>
#include <pragmas/utility_pragmas.h>

#include <dos/dosextens.h>
#include <dos/datetime.h>
#include <dos/dosasl.h>
#include <dos/rdargs.h>

#define DOSLIB	   "dos.library"
#define DOSVER	   37L

#define OPENFAIL { Result2(ERROR_INVALID_RESIDENT_LIBRARY); }
#define EXECBASE (*(struct ExecBase **)4)

#define THISPROC    ((struct Process *)(EXECBASE->ThisTask))
#define Result2(x)  THISPROC->pr_Result2 = x

/******************************************************************************/

#include	<exec/ports.h>
#include	<exec/libraries.h>

#include	<dos/dos.h>
#include	<dos/dosextens.h>
#include	<dos/datetime.h>
#include	<dos/dostags.h>

#include	<string.h>

#include	"dobuild_rev.h"

/******************************************************************************/

/*
 * This command runs the build process...
 *
 * The command line will take a BUILDLIST file which contains
 * the files to be build in the order that they need to be built
 * it will also take major and minor version which will be
 * used to generate the path to the .ld files.  (V37:, V39:, etc)
 * For CDTV, the directory is CDTV:  (No version, they did not want it)
 *
 * The build list file name will also be used to generate the
 * sub-names for the kickstart and symbol files.
 *
 * This assumes that the build commands are available in the path.
 *
 * The names of the files:
 *
 * <BUILDLIST>			This is a simple file containing the complete
 *				kickstart build list
 *
 * kick.<build>.<rev>		This is the kickstart file produced
 *
 * log.<build>.<rev>		This is the log file produced
 *
 * sym.<build>.<rev>.ld		This is the .ld symbol file produced
 *
 * sym.<build>.<rev>.map	This is the .map sumbol file produced
 */

/* This is the command template. */
#define TEMPLATE  "BUILDLIST/A,VERSION/N/A,REVISION/N/A,AUTOREV/K,BUMPREV/S,RELOC/K,SPLIT/S,1MEG/S,SUPERKICK/K,REKICK/S,FKICK/S,INTERLEAVE/S,QUICK/S,DIRECT/S,SCRIPT/K,CDTV/S,CDTV_E/S,DIR/K,TO/K,CHANGE/K/M,NOCHECKSUM/S" VERSTAG

#define	OPT_BUILDLIST	0
#define	OPT_VERSION	1
#define	OPT_REVISION	2
#define	OPT_AUTOREV	3
#define	OPT_BUMPREV	4
#define	OPT_RELOC	5
#define	OPT_SPLIT	6
#define	OPT_1MEG	7
#define	OPT_SUPERKICK	8
#define	OPT_REKICK	9
#define	OPT_FKICK	10
#define	OPT_INTERLEAVE	11
#define	OPT_QUICK	12
#define	OPT_DIRECT	13
#define	OPT_SCRIPT	14
#define	OPT_CDTV	15
#define	OPT_CDTV_E	16
#define	OPT_DIR		17
#define	OPT_TO		18
#define	OPT_CHANGE	19
#define OPT_NOCHECKSUM	20
#define	OPT_COUNT	21

struct	BuildStrings
{
	char	*reloc;
	char	version[16];
	char	revision[16];
	char	kick[256];
	char	log[256];
	char	ld[256];
	char	map[256];
};

void long_to_string(long,char *);
void SetUp_Load(char *,struct BuildStrings *,LONG *);

#define DO_COMMAND	if (script) VFPrintf(script,"%s\n",(VOID *)&vbuf); else if (System(vbuf,tags)) rc=RETURN_FAIL

LONG cmd_dobuild(void)
{
struct	Library		*SysBase = (*((struct Library **) 4));
struct	DosLibrary	*DOSBase;
struct	RDArgs		*rdargs;
struct	BuildStrings	*strings;
	LONG		opts[OPT_COUNT];
	LONG		rc;
	char		*tmp;
	char		buf[1024];
struct	TagItem		tags[] =
			{
				{SYS_Asynch, FALSE},
				{SYS_UserShell, TRUE},
				{TAG_DONE, NULL}
			};

	rc=RETURN_FAIL;
	if (DOSBase = (struct DosLibrary *)OpenLibrary(DOSLIB,DOSVER))
	{
		memset((char *)opts, 0, sizeof(opts));
		rdargs = ReadArgs(TEMPLATE, opts, NULL);

		if (rdargs == NULL)
		{
			PrintFault(IoErr(),NULL);
		}
		else if (strings=AllocVec(sizeof(struct BuildStrings),MEMF_PUBLIC|MEMF_CLEAR))
		{
		BPTR	build_file;
		BPTR	script=NULL;
		ULONG	revision;
		char	*name;

			/*
			 * Set "Default" reloc
			 */
			strings->reloc=NULL;

			/*
			 * Check for CDTV switch and set
			 * the name to CDTV ROM from kickstart...
			 */
			name="kickstart";
			if (opts[OPT_CDTV] || opts[OPT_CDTV_E]) name="CDTV ROM";

			/*
			 * If FKick, we need to relocate to 00F00000
			 */
			if (opts[OPT_FKICK]) strings->reloc="00F00000";

			/*
			 * If ReKick, we need to relocate to 00200000
			 */
			if (opts[OPT_REKICK]) strings->reloc="00200000";

			/*
			 * Check if we have a relocation key word
			 */
			if (opts[OPT_RELOC]) strings->reloc=(char *)opts[OPT_RELOC];

			/*
			 * Check for the script keyword
			 */
			if (opts[OPT_SCRIPT]) script=Open((char *)opts[OPT_SCRIPT],MODE_NEWFILE);

			/*
			 * Now check for auto AutoRev feature...
			 */
			revision=*(ULONG *)opts[OPT_REVISION];	/* Get command line revision */

			if (opts[OPT_AUTOREV])
			{
			BPTR	rev_file;

				if (rev_file=Open((char *)opts[OPT_AUTOREV],MODE_OLDFILE))
				{
				char	num[32];

					Read(rev_file,num,30);
					Close(rev_file);

					StrToLong(num,&revision);
					if (opts[OPT_BUMPREV]) revision++;
				}

				if (rev_file=Open((char *)opts[OPT_AUTOREV],MODE_NEWFILE))
				{
					VFPrintf(rev_file,"%ld\n",&revision);
					Close(rev_file);
				}
			}

			/*
			 * Build the version and revision strings...
			 */
			long_to_string(*(ULONG *)opts[OPT_VERSION],strings->version);
			long_to_string(revision,strings->revision);

			tmp=(char *)opts[OPT_BUILDLIST];
			if (build_file=Open(tmp,MODE_OLDFILE))
			{
				tmp=FilePart(tmp);
				if (opts[OPT_DIR]) if (strlen((char *)opts[OPT_DIR])>32) tmp=(char *)opts[OPT_DIR];
				if (opts[OPT_TO]) if (strlen((char *)opts[OPT_TO])>32) tmp=(char *)opts[OPT_TO];
				if (strlen(tmp)<32)
				{
				struct	DateTime	ds;
					char		*vbuf=buf;
					VOID		*args[6];	/* For VPrintf() */
					BPTR		tmp_fh=NULL;

					rc=RETURN_OK;

					strcpy(buf,".");
					strcat(buf,tmp);
					strcat(buf,".");
					strcat(buf,strings->version);
					strcat(buf,".");
					strcat(buf,strings->revision);

					/* Now build the names... */
					if (opts[OPT_TO])
					{
						/*
						 * We have a destination drawer
						 */
						strcpy(strings->kick,(char *)opts[OPT_TO]);
						strcpy(strings->log,(char *)opts[OPT_TO]);
						strcpy(strings->ld,(char *)opts[OPT_TO]);
					}
					if (opts[OPT_CDTV] || opts[OPT_CDTV_E]) strcat(strings->kick,"cdtv");
					else strcat(strings->kick,"kick");
					strcat(strings->kick,buf);

					strcat(strings->log,"log");
					strcat(strings->log,buf);

					strcat(strings->ld,"sym");
					strcat(strings->ld,buf);
					strcpy(strings->map,strings->ld);
					strcat(strings->ld,".ld");
					strcat(strings->map,".map");

					/*
					 * Now, make sure that the symbol files are empty
					 */
					if (script)
					{
						args[0]=strings->ld;
						VFPrintf(script,"Delete >NIL: %s\n",(VOID *)args);
						args[0]=strings->map;
						VFPrintf(script,"Delete >NIL: %s\n",(VOID *)args);
						args[0]=strings->kick;
						VFPrintf(script,"Delete >NIL: %s\n",(VOID *)args);
						args[0]=strings->log;
						VFPrintf(script,"Delete >NIL: %s\n",(VOID *)args);
					}
					else
					{
						DeleteFile(strings->ld);
						DeleteFile(strings->map);
						DeleteFile(strings->kick);
						DeleteFile(strings->log);
					}

					/*
					 * Now write the log file header
					 */
					if ((!script) && (!opts[OPT_QUICK])) tmp_fh=Open(strings->log,MODE_NEWFILE);

					DateStamp(&(ds.dat_Stamp));
					ds.dat_Format=FORMAT_DOS;
					ds.dat_Flags=0;
					ds.dat_StrDay=NULL;
					ds.dat_StrDate=buf;
					ds.dat_StrTime=&buf[32];
					DateToStr(&ds);

					args[0]=name;
					args[1]=strings->version;
					args[2]=strings->revision;
					args[3]=FilePart((char *)opts[OPT_BUILDLIST]);
					args[4]=buf;
					args[5]=&buf[32];
					if (script)
					{
						if (!opts[OPT_QUICK])
						{
							tmp=(char *)opts[OPT_SCRIPT];
							args[3]=tmp;
							VPrintf("Building a BUILD script in %s\n",(VOID *)&tmp);

							VFPrintf(script,"Echo \"*n",NULL);
							VFPrintf(script,"Building %s %s.%s from script <%s>",(VOID *)args);
							VFPrintf(script,"*n\"\n",NULL);

							tmp=strings->log;
							VFPrintf(script,"Echo >%s \"",(VOID *)&tmp);
							VFPrintf(script,"Building %s %s.%s from script <%s>",(VOID *)args);
							VFPrintf(script," : \" NOLINE\nDate >>%s\n",(VOID *)&tmp);
							VFPrintf(script,"Echo >>%s \" \"\n",(VOID *)&tmp);
						}
					}
					else VPrintf("Building %s %s.%s from BuildList <%s> : %s %s\n\n",(VOID *)args);

					if (tmp_fh)
					{
						VFPrintf(tmp_fh,"Building %s %s.%s from BuildList <%s> : %s %s\n\n",(VOID *)args);
						Close(tmp_fh);
					}

					/*
					 * If we have a 1MEG build, we will need to pre-split the build list
					 * into two 512K parts...  This is not put into the build script.
					 */
					if (opts[OPT_1MEG])
					{
					char	*p;

						Close(build_file);
						build_file=NULL;

						strcpy(vbuf,"Split DIR ");
						if (opts[OPT_DIR]) strcat(buf,(char *)opts[OPT_DIR]);
						else
						{
							strcat(buf,"V");
							strcat(buf,strings->version);
							strcat(buf,":");
						}							/* The 512K line, but we adjust it */
						p=&vbuf[strlen(vbuf)];					/* to fit in the extra stuff...    */
													/*   SPLIT 524288 SIZE 1048576     */
						strcat(vbuf," FIRSTHALF T:BuildPart0 SECONDHALF T:BuildPart1 SPLIT 524200 SIZE 1048000 ANYFIT BUILDLIST ");
						strcat(vbuf,(char *)opts[OPT_BUILDLIST]);

						if (System(vbuf,tags)) rc=RETURN_FAIL;
						else if (opts[OPT_SPLIT])
						{
							strcpy(p," BUILDLIST T:BuildPart0 TO T:BuildPart0 ANYFIT");
							if (System(vbuf,tags)) rc=RETURN_FAIL;
						}
					}

					/*
					 * Now, we need to start doing the build...
					 */
					strcpy(vbuf,"MakeVF CLEAR");
					if (opts[OPT_DIRECT]) strcat(vbuf," DIRECT");
					if (opts[OPT_1MEG]) strcat(vbuf," TAG");
					DO_COMMAND;

					if (rc==RETURN_OK)
					{
					char	*newstuff;
					ULONG	buildpart=1;
					ULONG	split_Remember=opts[OPT_SPLIT];

						vbuf=buf;
						strcpy(buf,"LoadVF ");

						if (opts[OPT_DIR]) strcat(buf,(char *)opts[OPT_DIR]);
						else
						{
							/*
							 * If CDTV is set, we should use CDTVxx:
							 */
							if (opts[OPT_CDTV] || opts[OPT_CDTV_E]) strcat(buf,"CDTV");
							else
							{
								strcat(buf,"V");
								strcat(buf,strings->version);
							}
							strcat(buf,":");
						}
						newstuff=&buf[strlen(buf)];

						if (opts[OPT_1MEG]) buildpart=2;

						while (buildpart--)
						{
							if (rc==RETURN_OK)
							{
								if (opts[OPT_1MEG])
								{
								char	*p;

									vbuf=newstuff;

									if (build_file) Close(build_file);

									if (buildpart==1)
									{
										p="T:BuildPart1";
										strings->reloc="00E00000";
										opts[OPT_SPLIT]=FALSE;
									}
									else if (buildpart==0)
									{
										p="T:BuildPart0";
										strings->reloc=NULL;
										opts[OPT_SPLIT]=split_Remember;

										/*
										 * Now, we need to save this part and
										 * build the next part...
										 */

										if(opts[OPT_NOCHECKSUM]==0L)
										{
											strcpy(vbuf,"CheckSumVF VERSION ");
											strcat(vbuf,strings->version);
											strcat(vbuf," REVISION ");
											strcat(vbuf,strings->revision);
											DO_COMMAND;
										}

										strcpy(vbuf,"SaveVF ");
										strcat(vbuf,strings->kick);
										DO_COMMAND;

										strcpy(vbuf,"MakeVF APPEND");
										DO_COMMAND;
									}

									if (!(build_file=Open(p,MODE_OLDFILE))) rc=RETURN_FAIL;

									vbuf=buf;
								}
							}

							while ((rc==RETURN_OK) && (tmp=FGets(build_file,newstuff,256)))
							{
							char	*mystuff;
							char	*t;

								t=newstuff;
								mystuff=newstuff;
								while (*mystuff==' ' || *mystuff=='\t') mystuff++;

								while (*t=*mystuff)
								{
									switch (*mystuff)
									{
									case ' ':
									case ';':
									case '\t':
									case '\n':	*mystuff='\0';
											break;
									default:	mystuff++;
											t++;
											break;
									}
								}

								if (newstuff != &buf[strlen(buf)])
								{
								char	**rep;
								char	*new;

									/*
									 * Ok, so we have a command...  We really should check to see if
									 * it is one we will replace...
									 */
									mystuff=FilePart(newstuff);
									if (rep=(char **)opts[OPT_CHANGE]) while ((new=*rep) && (mystuff) && (vbuf))
									{
										if (*new=='-')
										{
											/*
											 * We have a delete match
											 */
											new++;
											if (!strcmp(FilePart(new),mystuff)) vbuf=NULL;
										}
										else if (*new!='+')
										{
											if (!strcmp(FilePart(new),mystuff))
											{
												/*
												 * We have a replacement match!!!
												 */
												vbuf=newstuff;
												strcpy(vbuf,"LoadVF ");
												strcat(vbuf,new);
												mystuff=NULL;
											}
										}
										rep++;
									}

									if (vbuf)
									{
										SetUp_Load(vbuf,strings,opts);
										DO_COMMAND;
									}

									vbuf=buf;
								}
							}

							if (!tmp) if (IoErr())
							{
								rc=RETURN_FAIL;
								PrintFault(IoErr(),NULL);
							}
						}

						if (rc==RETURN_OK)
						{
						char	**rep;
						char	*new;

							/*
							 * Now, process all of the ADD commands...
							 */
							if (rep=(char **)opts[OPT_CHANGE]) while ((new=*rep) && (rc==RETURN_OK))
							{
								if (*new++=='+')
								{
									vbuf=newstuff;
									strcpy(vbuf,"LoadVF ");
									strcat(vbuf,new);

									SetUp_Load(vbuf,strings,opts);

									DO_COMMAND;
									vbuf=buf;
								}
								rep++;
							}
						}

						if (rc==RETURN_OK)
						{
							/* Now checksum the kickstart */
							if(opts[OPT_NOCHECKSUM]==0L)
							{
								strcpy(vbuf,"CheckSumVF VERSION ");
								strcat(vbuf,strings->version);
								strcat(vbuf," REVISION ");
								strcat(vbuf,strings->revision);
								if (opts[OPT_CDTV] || opts[OPT_CDTV_E]) strcat(vbuf," CDTV");
								if (opts[OPT_SUPERKICK]) strcat(vbuf," SUPERKICK");

								DO_COMMAND;
							}
						}

						if (rc==RETURN_OK)
						{
							/* Now save the kickstart */
							strcpy(vbuf,"SaveVF ");
							strcat(vbuf,strings->kick);

							if (opts[OPT_1MEG]) strcat(vbuf," APPEND");

							if (opts[OPT_SUPERKICK])
							{
								strcat(vbuf," SUPERKICK ");
								strcat(vbuf,(char *)opts[OPT_SUPERKICK]);
							}

							if (opts[OPT_REKICK]) strcat(vbuf," REKICK");
							if (opts[OPT_FKICK]) strcat(vbuf," FKICK");

							if (!opts[OPT_QUICK])
							{
								strcat(vbuf," SYMBOL ");
								strcat(vbuf,strings->ld);
							}

							DO_COMMAND;
						}

						strcpy(vbuf,"MakeVF REMOVE");
						DO_COMMAND;

						if (opts[OPT_INTERLEAVE])
						{
							strcpy(vbuf,"KickWordMix ");
							strcat(vbuf,strings->kick);
							DO_COMMAND;
						}

						if ((!script) && (!opts[OPT_QUICK])) if (tmp_fh=Open(strings->log,MODE_OLDFILE))
						{
							Seek(tmp_fh,0,OFFSET_END);
						}

						DateStamp(&(ds.dat_Stamp));
						ds.dat_Format=FORMAT_DOS;
						ds.dat_Flags=0;
						ds.dat_StrDay=NULL;
						ds.dat_StrDate=buf;
						ds.dat_StrTime=&buf[32];
						DateToStr(&ds);

						args[0]=name;
						args[1]=strings->version;
						args[2]=strings->revision;
						args[3]="completed";	if (rc!=RETURN_OK) args[3]="failed";
						args[4]=buf;
						args[5]=&buf[32];
						if (script)
						{
							if (!opts[OPT_QUICK])
							{
								tmp=(char *)opts[OPT_SCRIPT];
								args[3]=tmp;
								VPrintf("BUILD script %s is complete.\n",(VOID *)&tmp);
								tmp=strings->log;
								VFPrintf(script,"Echo >>%s \"*n",(VOID *)&tmp);
								VFPrintf(script,"Built %s %s.%s from script <%s> : ",(VOID *)args);
								VFPrintf(script,"\" NOLINE\nDate >>%s\n",(VOID *)&tmp);
								VFPrintf(script,"Echo \"*nBuild from script done.\"\n",NULL);
							}
						}
						else VPrintf("\nBuild of %s %s.%s %s at : %s %s\n",(VOID *)args);

						if (tmp_fh)
						{
							VFPrintf(tmp_fh,"\nBuild of %s %s.%s %s at : %s %s\n",(VOID *)args);
							Close(tmp_fh);
						}
					}
				}
				else PrintFault(ERROR_INVALID_COMPONENT_NAME,NULL);

				if (build_file) Close(build_file);
			}
			else PrintFault(IoErr(),"Can not open BUILDLIST");

			/*
			 * Clean up the temp build list splits...
			 */
			if (opts[OPT_1MEG])
			{
				DeleteFile("T:BuildPart1");
				DeleteFile("T:BuildPart0");
			}

			if (script) Close(script);
			FreeVec(strings);
		}

		if (rdargs) FreeArgs(rdargs);

		CloseLibrary((struct Library *)DOSBase);
	}
	else
	{
		OPENFAIL;
	}
	return(rc);
}

void long_to_string(long num,char *buf)
{
char	tmp[16];
char	*p;

	p=&tmp[15];
	*p='\0';

	if (!num)
	{
		p--;
		*p='0';
	}
	else while (num)
	{
		p--;
		*p='0'+(num%10);
		num=num/10;
	}
	strcpy(buf,p);
}

void SetUp_Load(char *vbuf,struct BuildStrings *strings,LONG *opts)
{
	if (!opts[OPT_QUICK])
	{
		strcat(vbuf," SYMBOL ");
		strcat(vbuf,strings->ld);
		strcat(vbuf," MAP ");
		strcat(vbuf,strings->map);
		strcat(vbuf," LOG ");
		strcat(vbuf,strings->log);
	}

	if (strings->reloc)
	{
		strcat(vbuf," RELOC ");
		strcat(vbuf,strings->reloc);
	}

	if (opts[OPT_SPLIT]) strcat(vbuf," SPLIT");
	if (opts[OPT_CDTV]) strcat(vbuf," CDTV");
	if (opts[OPT_CDTV_E]) strcat(vbuf," CDTV_E");
}
@


40.4
log
@Added INTERLEAVE option to Word Interleave the kickstart
for the strange 16-bit in 32-bit system ROM hardware
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 40.3 93/03/04 11:52:41 mks Exp Locker: mks $
d4 5
a8 1
 * $Log:	DoBuild.c,v $
d162 1
a162 1
#define TEMPLATE  "BUILDLIST/A,VERSION/N/A,REVISION/N/A,AUTOREV/K,BUMPREV/S,RELOC/K,SPLIT/S,1MEG/S,SUPERKICK/K,REKICK/S,FKICK/S,INTERLEAVE/S,QUICK/S,DIRECT/S,SCRIPT/K,CDTV/S,CDTV_E/S,DIR/K,TO/K,CHANGE/K/M" VERSTAG
d184 2
a185 1
#define	OPT_COUNT	20
d511 8
a518 5
										strcpy(vbuf,"CheckSumVF VERSION ");
										strcat(vbuf,strings->version);
										strcat(vbuf," REVISION ");
										strcat(vbuf,strings->revision);
										DO_COMMAND;
d639 8
a646 6
							strcpy(vbuf,"CheckSumVF VERSION ");
							strcat(vbuf,strings->version);
							strcat(vbuf," REVISION ");
							strcat(vbuf,strings->revision);
							if (opts[OPT_CDTV] || opts[OPT_CDTV_E]) strcat(vbuf," CDTV");
							if (opts[OPT_SUPERKICK]) strcat(vbuf," SUPERKICK");
d648 2
a649 1
							DO_COMMAND;
@


40.3
log
@Added code needed to deal with 1Meg builds...
Requires the up-to-date build tools.
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 40.2 93/02/25 15:26:57 mks Exp Locker: mks $
d5 4
d158 1
a158 1
#define TEMPLATE  "BUILDLIST/A,VERSION/N/A,REVISION/N/A,AUTOREV/K,BUMPREV/S,RELOC/K,SPLIT/S,1MEG/S,SUPERKICK/K,REKICK/S,FKICK/S,QUICK/S,DIRECT/S,SCRIPT/K,CDTV/S,CDTV_E/S,DIR/K,TO/K,CHANGE/K/M" VERSTAG
d171 10
a180 9
#define	OPT_QUICK	11
#define	OPT_DIRECT	12
#define	OPT_SCRIPT	13
#define	OPT_CDTV	14
#define	OPT_CDTV_E	15
#define	OPT_DIR		16
#define	OPT_TO		17
#define	OPT_CHANGE	18
#define	OPT_COUNT	19
d669 7
@


40.2
log
@No longer uses the internal (private) include
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 40.1 93/02/18 15:40:15 mks Exp Locker: mks $
d5 3
d154 1
a154 1
#define TEMPLATE  "BUILDLIST/A,VERSION/N/A,REVISION/N/A,AUTOREV/K,BUMPREV/S,RELOC/K,SPLIT/S,SUPERKICK/K,REKICK/S,FKICK/S,QUICK/S,DIRECT/S,SCRIPT/K,CDTV/S,CDTV_E/S,DIR/K,TO/K,CHANGE/K/M" VERSTAG
d163 13
a175 12
#define	OPT_SUPERKICK	7
#define	OPT_REKICK	8
#define	OPT_FKICK	9
#define	OPT_QUICK	10
#define	OPT_DIRECT	11
#define	OPT_SCRIPT	12
#define	OPT_CDTV	13
#define	OPT_CDTV_E	14
#define	OPT_DIR		15
#define	OPT_TO		16
#define	OPT_CHANGE	17
#define	OPT_COUNT	18
d191 2
d301 1
d305 2
d406 2
a407 1
					 * Now, we need to start doing the build...
d409 3
a411 2
					strcpy(buf,"MakeVF CLEAR");
					if (opts[OPT_DIRECT]) strcat(buf," DIRECT");
d413 22
a434 5
					if (script)
					{
						tmp=buf;
						VFPrintf(script,"%s\n",(VOID *)&tmp);
						rc=RETURN_OK;
d436 8
a443 1
					else if (!System(buf,tags)) rc=RETURN_OK;
d448 2
a449 1
					char	*vbuf;
d470 3
a472 1
						while ((rc==RETURN_OK) && (tmp=FGets(build_file,newstuff,256)))
d474 26
a499 2
						short	t=strlen(buf);
						char	*mystuff;
d501 13
a513 6
							if (buf[t-1]=='\n') buf[t-1]='\0';
							/*
							 * Skip past the leading whitespace
							 */
							mystuff=newstuff;
							while ((*mystuff==' ') || (*mystuff=='\t')) mystuff++;
d515 1
a515 4
							/*
							 * Handle comment lines
							 */
							if (*mystuff==';') *newstuff='\0';
d517 1
a517 12
							/*
							 * Compress out the leading spaces
							 * and chop after a space in the line...
							 */
							t=0;
							while (newstuff[t]=*mystuff)
							{
								if ((*mystuff==' ') || (*mystuff=='\t')) *mystuff='\0';
								else
								{
									mystuff++;
									t++;
d521 1
a521 1
							if (newstuff != &buf[strlen(buf)])
d523 6
a528 2
							char	**rep;
							char	*new;
d530 1
a530 6
								/*
								 * Ok, so we have a command...  We really should check to see if
								 * it is one we will replace...
								 */
								mystuff=FilePart(newstuff);
								if (rep=(char **)opts[OPT_CHANGE]) while ((new=*rep) && (mystuff) && (vbuf))
d532 1
a532 1
									if (*new=='-')
d534 8
a541 5
										/*
										 * We have a delete match
										 */
										new++;
										if (!strcmp(FilePart(new),mystuff)) vbuf=NULL;
d543 13
a555 1
									else if (*new!='+')
d557 1
a557 1
										if (!strcmp(FilePart(new),mystuff))
d560 1
a560 1
											 * We have a replacement match!!!
d562 15
a576 4
											vbuf=newstuff;
											strcpy(vbuf,"LoadVF ");
											strcat(vbuf,new);
											mystuff=NULL;
d578 1
a579 2
									rep++;
								}
d581 5
a585 3
								if (vbuf)
								{
									SetUp_Load(vbuf,strings,opts);
d587 1
a587 2
									if (script) VFPrintf(script,"%s\n",(VOID *)&vbuf);
									else if (System(vbuf,tags)) rc=RETURN_FAIL;
a589 2
							vbuf=buf;
						}
d591 5
a595 4
						if (!tmp) if (IoErr())
						{
							rc=RETURN_FAIL;
							PrintFault(IoErr(),NULL);
d616 2
a617 2
									if (script) VFPrintf(script,"%s\n",(VOID *)&vbuf);
									else if (System(vbuf,tags)) rc=RETURN_FAIL;
d626 6
a631 6
							strcpy(buf,"CheckSumVF VERSION ");
							strcat(buf,strings->version);
							strcat(buf," REVISION ");
							strcat(buf,strings->revision);
							if (opts[OPT_CDTV] || opts[OPT_CDTV_E]) strcat(buf," CDTV");
							if (opts[OPT_SUPERKICK]) strcat(buf," SUPERKICK");
d633 1
a633 2
							if (script) VFPrintf(script,"%s\n",(VOID *)&vbuf);
							else if (System(buf,tags)) rc=RETURN_FAIL;
d639 2
a640 2
							strcpy(buf,"SaveVF ");
							strcat(buf,strings->kick);
d642 2
d646 2
a647 2
								strcat(buf," SUPERKICK ");
								strcat(buf,(char *)opts[OPT_SUPERKICK]);
d650 2
a651 2
							if (opts[OPT_REKICK]) strcat(buf," REKICK");
							if (opts[OPT_FKICK]) strcat(buf," FKICK");
d655 2
a656 2
								strcat(buf," SYMBOL ");
								strcat(buf,strings->ld);
d659 1
a659 2
							if (script) VFPrintf(script,"%s\n",(VOID *)&vbuf);
							else if (System(buf,tags)) rc=RETURN_FAIL;
d662 2
a663 2
						if (script) VFPrintf(script,"MakeVF REMOVE\n",NULL);
						else if (System("MakeVF REMOVE",tags)) rc=RETURN_FAIL;
d709 1
a709 1
				Close(build_file);
d712 9
@


40.1
log
@CleanUp for SAS/C 6 compile
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.20 92/06/06 11:34:18 mks Exp Locker: mks $
d5 3
d74 31
a104 1
#include <internal/commands.h>
@


1.20
log
@Added REKICK option and changed the way REKICK/FKICK work...
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.19 92/03/05 10:58:58 mks Exp Locker: mks $
d5 3
d158 1
a158 1
struct	RDargs		*rdargs;
@


1.19
log
@Fixed FKICK keyword
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.18 92/02/28 15:24:00 mks Exp Locker: mks $
d5 3
d115 1
a115 1
#define TEMPLATE  "BUILDLIST/A,VERSION/N/A,REVISION/N/A,AUTOREV/K,BUMPREV/S,RELOC/K,SPLIT/S,SUPERKICK/K,KICKIT/S,FKICK/S,QUICK/S,DIRECT/S,SCRIPT/K,CDTV/S,CDTV_E/S,DIR/K,TO/K,CHANGE/K/M" VERSTAG
d125 1
a125 1
#define	OPT_KICKIT	8
d203 1
a203 1
			 * If KickIt, we need to relocate to 00200000
d205 1
a205 1
			if (opts[OPT_KICKIT]) strings->reloc="00200000";
d534 2
a535 1
							if (opts[OPT_KICKIT] || opts[OPT_FKICK]) strcat(buf," KICKIT");
@


1.18
log
@Added the BUMPREV option for AUTOREV
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.17 92/02/28 11:27:39 mks Exp Locker: mks $
d5 3
d197 1
a197 1
			if (opts[OPT_KICKIT]) strings->reloc="00F00000";
@


1.17
log
@Added the AUTOREV and FKICK options...
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.16 92/02/04 12:33:14 mks Exp Locker: mks $
d5 3
d109 1
a109 1
#define TEMPLATE  "BUILDLIST/A,VERSION/N/A,REVISION/N/A,AUTOREV/K,RELOC/K,SPLIT/S,SUPERKICK/K,KICKIT/S,FKICK/S,QUICK/S,DIRECT/S,SCRIPT/K,CDTV/S,CDTV_E/S,DIR/K,TO/K,CHANGE/K/M" VERSTAG
d115 15
a129 14
#define	OPT_RELOC	4
#define	OPT_SPLIT	5
#define	OPT_SUPERKICK	6
#define	OPT_KICKIT	7
#define	OPT_FKICK	8
#define	OPT_QUICK	9
#define	OPT_DIRECT	10
#define	OPT_SCRIPT	11
#define	OPT_CDTV	12
#define	OPT_CDTV_E	13
#define	OPT_DIR		14
#define	OPT_TO		15
#define	OPT_CHANGE	16
#define	OPT_COUNT	17
d228 1
a228 1
					revision++;
@


1.16
log
@Cleaned up the output from the QUICK option
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.15 91/12/06 08:41:04 mks Exp Locker: mks $
d5 3
d106 1
a106 1
#define TEMPLATE  "BUILDLIST/A,VERSION/N/A,REVISION/N/A,RELOC/K,SPLIT/S,SUPERKICK/K,KICKIT/S,QUICK/S,DIRECT/S,SCRIPT/K,CDTV/S,CDTV_E/S,DIR/K,TO/K,CHANGE/K/M" VERSTAG
d111 15
a125 13
#define	OPT_RELOC	3
#define	OPT_SPLIT	4
#define	OPT_SUPERKICK	5
#define	OPT_KICKIT	6
#define	OPT_QUICK	7
#define	OPT_DIRECT	8
#define	OPT_SCRIPT	9
#define	OPT_CDTV	10
#define	OPT_CDTV_E	11
#define	OPT_DIR		12
#define	OPT_TO		13
#define	OPT_CHANGE	14
#define	OPT_COUNT	15
d172 1
d188 5
d207 30
d238 1
a238 1
			long_to_string(*(ULONG *)opts[OPT_REVISION],strings->revision);
d320 1
a320 1
					args[3]=(char *)opts[OPT_BUILDLIST];
a326 2
						char	*tmp;

a357 2
					char	*tmp;

d524 1
a524 1
							if (opts[OPT_KICKIT]) strcat(buf," KICKIT");
a561 2
							char	*tmp;

@


1.15
log
@Fixed typecast error.
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.14 91/12/06 07:18:58 mks Exp Locker: mks $
d5 3
d282 1
a282 1
					if (script) if (!opts[OPT_QUICK])
d284 7
a290 1
					char	*tmp;
d292 3
a294 3
						tmp=(char *)opts[OPT_SCRIPT];
						args[3]=tmp;
						VPrintf("Building a BUILD script in %s\n",(VOID *)&tmp);
d296 6
a301 9
						VFPrintf(script,"Echo \"*n",NULL);
						VFPrintf(script,"Building %s %s.%s from script <%s>",(VOID *)args);
						VFPrintf(script,"*n\"\n",NULL);

						tmp=strings->log;
						VFPrintf(script,"Echo >%s \"",(VOID *)&tmp);
						VFPrintf(script,"Building %s %s.%s from script <%s>",(VOID *)args);
						VFPrintf(script," : \" NOLINE\nDate >>%s\n",(VOID *)&tmp);
						VFPrintf(script,"Echo >>%s \" \"\n",(VOID *)&tmp);
d521 1
a521 1
						if (script) if (!opts[OPT_QUICK])
d523 3
a525 1
						char	*tmp;
d527 9
a535 8
							tmp=(char *)opts[OPT_SCRIPT];
							args[3]=tmp;
							VPrintf("BUILD script %s is complete.\n",(VOID *)&tmp);
							tmp=strings->log;
							VFPrintf(script,"Echo >>%s \"*n",(VOID *)&tmp);
							VFPrintf(script,"Built %s %s.%s from script <%s> : ",(VOID *)args);
							VFPrintf(script,"\" NOLINE\nDate >>%s\n",(VOID *)&tmp);
							VFPrintf(script,"Echo \"*nBuild from script done.\"\n",NULL);
@


1.14
log
@Added CDTV_E and DIRECT support
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.13 91/11/15 10:42:52 mks Exp Locker: mks $
d5 3
d316 1
a316 1
						VFPrintf(script,"%s\n",&tmp);
@


1.13
log
@Removed the ADD/REPLACE/REMOVE keywords and changed that to the
multi-arg CHANGE keyword
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.12 91/11/14 19:38:13 mks Exp Locker: mks $
d5 4
d97 1
a97 1
#define TEMPLATE  "BUILDLIST/A,VERSION/N/A,REVISION/N/A,RELOC/K,SPLIT/S,SUPERKICK/K,KICKIT/S,QUICK/S,SCRIPT/K,CDTV/S,DIR/K,TO/K,CHANGE/K/M" VERSTAG
d107 8
a114 6
#define	OPT_SCRIPT	8
#define	OPT_CDTV	9
#define	OPT_DIR		10
#define	OPT_TO		11
#define	OPT_CHANGE	12
#define	OPT_COUNT	13
d173 1
a173 1
			if (opts[OPT_CDTV]) name="CDTV ROM";
d222 1
a222 1
					if (opts[OPT_CDTV]) strcat(strings->kick,"cdtv");
d305 3
d310 4
a313 1
						VFPrintf(script,"MakeVF CLEAR\n",NULL);
d316 1
a316 1
					else if (!System("MakeVF CLEAR",tags)) rc=RETURN_OK;
d332 1
a332 1
							if (opts[OPT_CDTV]) strcat(buf,"CDTV");
d459 1
a459 1
							if (opts[OPT_CDTV]) strcat(buf," CDTV");
d597 1
@


1.12
log
@Now does revision 0 and CDTV:
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.11 91/10/28 12:19:42 mks Exp Locker: mks $
d5 3
d93 1
a93 1
#define TEMPLATE  "BUILDLIST/A,VERSION/N/A,REVISION/N/A,RELOC/K,SPLIT/S,SUPERKICK/K,KICKIT/S,QUICK/S,SCRIPT/K,CDTV/S,DIR/K,TO/K,REMOVE/K,REPLACE/K,ADD/K/M" VERSTAG
d107 2
a108 4
#define	OPT_REMOVE	12
#define	OPT_REPLACE	13
#define	OPT_ADD		14
#define	OPT_COUNT	15
d112 1
d122 1
a154 1
		char	*reloc=NULL;
d158 5
d172 1
a172 1
			if (opts[OPT_KICKIT]) reloc="00200000";
d177 1
a177 1
			if (opts[OPT_RELOC]) reloc=(char *)opts[OPT_RELOC];
d364 3
d372 1
a372 1
								if (opts[OPT_REPLACE])
d374 1
a374 1
									if (!strcmp(FilePart((char *)opts[OPT_REPLACE]),mystuff))
d377 1
a377 1
										 * We have a match so we make a new string...
d379 2
a380 3
										vbuf=newstuff;
										strcpy(vbuf,"LoadVF ");
										strcat(vbuf,(char *)opts[OPT_REPLACE]);
d382 14
a395 5
								}

								if (opts[OPT_REMOVE])
								{
									if (!strcmp(FilePart((char *)opts[OPT_REMOVE]),mystuff)) vbuf=NULL;
d400 1
a400 17
									if (!opts[OPT_QUICK])
									{
										strcat(vbuf," SYMBOL ");
										strcat(vbuf,strings->ld);
										strcat(vbuf," MAP ");
										strcat(vbuf,strings->map);
										strcat(vbuf," LOG ");
										strcat(vbuf,strings->log);
									}

									if (reloc)
									{
										strcat(vbuf," RELOC ");
										strcat(vbuf,reloc);
									}
									if (opts[OPT_SPLIT]) strcat(vbuf," SPLIT");
									if (opts[OPT_CDTV]) strcat(vbuf," CDTV");
d408 1
d418 1
d420 4
a423 3
							/* Now do the ADD modules */
							rep=(char **)opts[OPT_ADD];
							while ((rep) && (*rep) && (rc==RETURN_OK))
d425 5
a429 3
								vbuf=newstuff;
								strcpy(vbuf,"LoadVF ");
								strcat(vbuf,*rep);
d431 1
a431 9
								if (!opts[OPT_QUICK])
								{
									strcat(vbuf," SYMBOL ");
									strcat(vbuf,strings->ld);
									strcat(vbuf," MAP ");
									strcat(vbuf,strings->map);
									strcat(vbuf," LOG ");
									strcat(vbuf,strings->log);
								}
d433 2
a434 4
								if (reloc)
								{
									strcat(vbuf," RELOC ");
									strcat(vbuf,reloc);
a435 6
								if (opts[OPT_SPLIT]) strcat(vbuf," SPLIT");
								if (opts[OPT_CDTV]) strcat(vbuf," CDTV");

								if (script) VFPrintf(script,"%s\n",(VOID *)&vbuf);
								else if (System(vbuf,tags)) rc=RETURN_FAIL;

d563 22
@


1.11
log
@Added the REMOVE and ADD options and change the REPLACE option
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.10 91/10/25 18:48:56 mks Exp Locker: mks $
d5 3
d68 1
a68 1
 * For CDTV, the directories are CDTVxx:  (CDTV37:, CDTV39:, etc)
d209 2
a210 2
					strcat(strings->kick,"kick");
					if (opts[OPT_CDTV]) strcpy(strings->kick,"cdtv");
d313 6
a318 3
							if (opts[OPT_CDTV]) strcat(buf,"CDT");
							strcat(buf,"V");
							strcat(buf,strings->version);
d560 6
a565 1
	while (num)
@


1.10
log
@Added comment features to build lists and the ability to
offer replacement .ld files.  (Only replacements)
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.9 91/10/18 18:40:00 mks Exp Locker: mks $
d5 4
d87 1
a87 1
#define TEMPLATE  "BUILDLIST/A,VERSION/N/A,REVISION/N/A,RELOC/K,SPLIT/S,SUPERKICK/K,KICKIT/S,QUICK/S,SCRIPT/K,CDTV/S,DIR/K,TO/K,REPLACE/K/M" VERSTAG
d101 4
a104 2
#define	OPT_REPLACE	12
#define	OPT_COUNT	13
a350 2
							char	**rep;

d356 1
a356 2
								rep=(char **)opts[OPT_REPLACE];
								while ((rep) && (*rep))
d358 1
a358 2
									if (strcmp(FilePart(*rep),mystuff)) rep++;
									else
d365 25
a389 2
										strcat(vbuf,*rep);
										rep=NULL;
d391 5
d397 20
d438 2
a440 6
							vbuf=buf;
						}
						if (!tmp) if (IoErr())
						{
							rc=RETURN_FAIL;
							PrintFault(IoErr(),NULL);
@


1.9
log
@Added KickIt support
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.8 91/10/18 17:16:42 mks Exp Locker: mks $
d5 3
d83 1
a83 1
#define TEMPLATE  "BUILDLIST/A,VERSION/N/A,REVISION/N/A,RELOC/K,SPLIT/S,SUPERKICK/K,KICKIT/S,QUICK/S,SCRIPT/K,CDTV/S,DIR/K,TO/K" VERSTAG
d97 2
a98 1
#define	OPT_COUNT	12
d222 4
d231 2
d314 1
d317 25
d345 23
d370 6
a375 6
									strcat(buf," SYMBOL ");
									strcat(buf,strings->ld);
									strcat(buf," MAP ");
									strcat(buf,strings->map);
									strcat(buf," LOG ");
									strcat(buf,strings->log);
d380 2
a381 2
									strcat(buf," RELOC ");
									strcat(buf,reloc);
d383 2
a384 2
								if (opts[OPT_SPLIT]) strcat(buf," SPLIT");
								if (opts[OPT_CDTV]) strcat(buf," CDTV");
d387 1
a387 1
								else if (System(buf,tags)) rc=RETURN_FAIL;
d389 1
@


1.8
log
@Added the CDTV: part of the CDTV switch.
Added the DIR switch
Added the TO switch
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.7 91/10/18 15:36:12 mks Exp Locker: mks $
d5 5
d80 1
a80 1
#define TEMPLATE  "BUILDLIST/A,VERSION/N/A,REVISION/N/A,RELOC/K,SPLIT/S,SUPERKICK/K,QUICK/S,SCRIPT/K,CDTV/S,DIR/K,TO/K" VERSTAG
d88 7
a94 6
#define	OPT_QUICK	6
#define	OPT_SCRIPT	7
#define	OPT_CDTV	8
#define	OPT_DIR		9
#define	OPT_TO		10
#define	OPT_COUNT	11
d150 5
d362 2
@


1.7
log
@Added CDTV option and RELOC option
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.6 91/10/17 10:23:56 mks Exp Locker: mks $
d5 3
d53 1
d75 1
a75 1
#define TEMPLATE  "BUILDLIST/A,VERSION/N/A,REVISION/N/A,RELOC/K,SPLIT/S,SUPERKICK/K,QUICK/S,SCRIPT/K,CDTV/S" VERSTAG
d86 3
a88 1
#define	OPT_COUNT	9
d160 2
d176 10
a185 1
					strcpy(strings->kick,"kick");
d189 1
a189 1
					strcpy(strings->log,"log");
d192 1
a192 1
					strcpy(strings->ld,"sym");
d275 13
a287 3
						strcpy(buf,"LoadVF V");
						strcat(buf,strings->version);
						strcat(buf,":");
@


1.6
log
@Cleaned up formatting so it will print nice
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.5 91/10/15 10:19:08 mks Exp Locker: mks $
d5 3
d71 1
a71 1
#define TEMPLATE  "BUILDLIST/A,VERSION/N/A,REVISION/N/A,SPLIT/S,SUPERKICK/K,QUICK/S,SCRIPT/K" VERSTAG
d76 7
a82 5
#define	OPT_SPLIT	3
#define	OPT_SUPERKICK	4
#define	OPT_QUICK	5
#define	OPT_SCRIPT	6
#define	OPT_COUNT	7
d96 1
a96 1
LONG cmd_loadwb(void)
d127 14
d142 3
d157 1
a157 1
					VOID		*args[5];	/* For VPrintf() */
d169 1
d210 6
a215 5
					args[0]=strings->version;
					args[1]=strings->revision;
					args[2]=(char *)opts[OPT_BUILDLIST];
					args[3]=buf;
					args[4]=&buf[32];
d221 1
a221 1
						args[2]=tmp;
d225 1
a225 1
						VFPrintf(script,"Building kickstart %s.%s from script <%s>",(VOID *)args);
d230 1
a230 1
						VFPrintf(script,"Building kickstart %s.%s from script <%s>",(VOID *)args);
d234 1
a234 1
					else VPrintf("Building kickstart %s.%s from BuildList <%s> : %s %s\n\n",(VOID *)args);
d238 1
a238 1
						VFPrintf(tmp_fh,"Building kickstart %s.%s from BuildList <%s> : %s %s\n\n",(VOID *)args);
d281 5
d287 1
d306 1
d351 6
a356 5
						args[0]=strings->version;
						args[1]=strings->revision;
						args[2]="completed";	if (rc!=RETURN_OK) args[2]="failed";
						args[3]=buf;
						args[4]=&buf[32];
d362 1
a362 1
							args[2]=tmp;
d366 1
a366 1
							VFPrintf(script,"Building kickstart %s.%s from script <%s> done : ",(VOID *)args);
d370 1
a370 1
						else VPrintf("\nBuild of kickstart %s.%s %s at : %s %s\n",(VOID *)args);
d374 1
a374 1
							VFPrintf(tmp_fh,"\nBuild of kickstart %s.%s %s at : %s %s\n",(VOID *)args);
@


1.5
log
@Added standard version string to the commands
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.4 91/10/15 09:45:22 mks Exp Locker: mks $
d5 3
d26 2
a27 2
#include        <exec/ports.h>
#include        <exec/libraries.h>
d29 2
a30 2
#include        <dos/dos.h>
#include        <dos/dosextens.h>
@


1.4
log
@Made the script generated with the SCRIPT keyword a bit better
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.3 91/10/15 09:21:11 mks Exp Locker: mks $
d5 3
d33 2
d65 1
a65 1
#define TEMPLATE  "BUILDLIST/A,VERSION/N/A,REVISION/N/A,SPLIT/S,SUPERKICK/K,QUICK/S,SCRIPT/K"
@


1.3
log
@Added the script file creation feature
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.2 91/10/14 15:22:35 mks Exp Locker: mks $
d5 3
d153 12
a164 2
					DeleteFile(strings->ld);
					DeleteFile(strings->map);
d184 1
a184 1
					if (script)
d191 5
d198 3
a200 2
						VFPrintf(script,"Building kickstart %s.%s from script <%s> : ",(VOID *)args);
						VFPrintf(script,"\" NOLINE\nDate\nEcho \"  \"\n",NULL);
d317 1
a317 1
						if (script)
d325 1
a325 1
							VFPrintf(script,"Echo >%s \"",(VOID *)&tmp);
d327 2
a328 1
							VFPrintf(script,"\" NOLINE\nDate\n",NULL);
@


1.2
log
@Fixed log file output...
@
text
@d2 1
a2 1
 * $Id: DoBuild.c,v 1.1 91/10/14 14:29:58 mks Exp Locker: mks $
d5 3
d57 1
a57 1
#define TEMPLATE  "BUILDLIST/A,VERSION/N/A,REVISION/N/A,SPLIT/S,SUPERKICK/K,QUICK/S"
d65 2
a66 1
#define	OPT_COUNT	6
d110 3
d156 1
a156 1
					if (!opts[OPT_QUICK]) tmp_fh=Open(strings->log,MODE_NEWFILE);
d171 13
a183 1
					VPrintf("Building kickstart %s.%s from BuildList <%s> : %s %s\n\n",(VOID *)args);
d194 8
a201 1
					if (!System("MakeVF CLEAR",tags))
d204 1
d206 1
a206 1
						rc=RETURN_OK;
d231 3
a233 1
								if (System(buf,tags)) rc=RETURN_FAIL;
d250 3
a252 1
							if (System(buf,tags)) rc=RETURN_FAIL;
d272 3
a274 1
							if (System(buf,tags)) rc=RETURN_FAIL;
d277 2
a278 1
						if (System("MakeVF REMOVE",tags)) rc=RETURN_FAIL;
d280 1
a280 1
						if (!opts[OPT_QUICK]) if (tmp_fh=Open(strings->log,MODE_OLDFILE))
d298 13
a310 1
						VPrintf("\nBuild of kickstart %s.%s %s at : %s %s\n",(VOID *)args);
d325 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id$
d4 4
a7 1
 * $Log$
d246 4
a249 1
						if (!opts[OPT_QUICK]) tmp_fh=Open(strings->log,MODE_NEWFILE);
@
