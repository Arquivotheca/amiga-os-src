head     1.33;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @* @;


1.33
date     93.05.06.21.52.17;  author jesup;  state Exp;
branches ;
next     1.32;

1.32
date     92.08.05.16.53.06;  author jesup;  state Exp;
branches ;
next     1.31;

1.31
date     92.06.17.22.51.31;  author jesup;  state Exp;
branches ;
next     1.30;

1.30
date     92.06.10.12.27.18;  author jesup;  state Exp;
branches ;
next     1.29;

1.29
date     92.06.01.17.31.22;  author jesup;  state Exp;
branches ;
next     1.28;

1.28
date     92.06.01.16.57.07;  author jesup;  state Exp;
branches ;
next     1.27;

1.27
date     92.06.01.16.15.23;  author jesup;  state Exp;
branches ;
next     1.26;

1.26
date     92.05.31.23.10.18;  author jesup;  state Exp;
branches ;
next     1.25;

1.25
date     92.05.26.23.47.47;  author jesup;  state Exp;
branches ;
next     1.24;

1.24
date     92.05.26.23.26.09;  author jesup;  state Exp;
branches ;
next     1.23;

1.23
date     92.04.15.12.47.59;  author jesup;  state Exp;
branches ;
next     1.22;

1.22
date     92.04.14.20.05.25;  author jesup;  state Exp;
branches ;
next     1.21;

1.21
date     92.04.14.15.13.06;  author jesup;  state Exp;
branches ;
next     1.20;

1.20
date     92.03.24.16.16.29;  author jesup;  state Exp;
branches ;
next     1.19;

1.19
date     92.03.24.14.31.38;  author jesup;  state Exp;
branches ;
next     1.18;

1.18
date     92.03.19.20.09.11;  author jesup;  state Exp;
branches ;
next     1.17;

1.17
date     92.03.16.23.36.55;  author jesup;  state Exp;
branches ;
next     1.16;

1.16
date     92.03.13.14.18.37;  author jesup;  state Exp;
branches ;
next     1.15;

1.15
date     92.03.12.19.06.56;  author jesup;  state Exp;
branches ;
next     1.14;

1.14
date     92.02.19.01.47.11;  author jesup;  state Exp;
branches ;
next     1.13;

1.13
date     92.01.31.18.17.02;  author jesup;  state Exp;
branches ;
next     1.12;

1.12
date     92.01.22.20.11.53;  author jesup;  state Exp;
branches ;
next     1.11;

1.11
date     92.01.21.14.57.21;  author jesup;  state Exp;
branches ;
next     1.10;

1.10
date     92.01.09.16.37.53;  author jesup;  state Exp;
branches ;
next     1.9;

1.9
date     92.01.02.21.20.45;  author jesup;  state Exp;
branches ;
next     1.8;

1.8
date     91.12.30.20.31.30;  author jesup;  state Exp;
branches ;
next     1.7;

1.7
date     91.11.26.01.11.38;  author jesup;  state Exp;
branches ;
next     1.6;

1.6
date     91.10.18.19.34.41;  author jesup;  state KS_V37_300;
branches ;
next     1.5;

1.5
date     91.10.14.15.47.49;  author jesup;  state Exp;
branches ;
next     1.4;

1.4
date     91.10.14.15.30.44;  author jesup;  state Exp;
branches ;
next     1.3;

1.3
date     91.10.03.12.12.41;  author jesup;  state Exp;
branches ;
next     1.2;

1.2
date     91.10.03.11.32.56;  author jesup;  state Exp;
branches ;
next     1.1;

1.1
date     91.06.04.19.35.02;  author jesup;  state Exp;
branches ;
next     ;


desc
@scsi task stuff (not needed for ide)
@


1.33
log
@A4091 checkin
Added 4091 interrupt and quick int handlers
Changes to handle structure changes
Code for butt-board IDE on CDGS
@
text
@	OPT p=68020

		SECTION	driver,CODE

;==============================================================================
; This module handles all the hardware specific operations for sending command
; blocks to the controller and interpreting returned interrupts.  Threading of
; requests to different units and the disconnect/reconnect stuff is here too.
;
; This version is for the A590/A2091 with DMA driven SCSI and XT controllers.
;==============================================================================
		NOLIST
		INCLUDE	"exec/types.i"
		INCLUDE	"exec/interrupts.i"
		INCLUDE	"exec/lists.i"
		INCLUDE	"exec/ports.i"
		INCLUDE	"exec/tasks.i"
		INCLUDE	"exec/execbase.i"
		INCLUDE	"devices/scsidisk.i"
		INCLUDE	"devices/hardblocks.i"
		INCLUDE	"resources/battmembitsshared.i"
		INCLUDE	"resources/battmembitsamiga.i"
		INCLUDE	"resources/battmem.i"
		INCLUDE "hardware/cia.i"

		INCLUDE	"modifiers.i"
		INCLUDE	"device.i"
		INCLUDE "iotask.i"
		INCLUDE	"scsitask.i"
		INCLUDE	"board.i"

		INCLUDE	"printf.mac"
		LIST

;		DEBUGENABLE
;INT_DEBUG	EQU	1
;SYNC_DEBUG	EQU	1

		XREF	_LVOSignal
  IFND NCR53C710
		XDEF	SCSITask,FakeSelect,FakeDisconnect,FakeTimeout
		XDEF	OneTaskEntry
	IFD IS_A1000
		XDEF	BattName
	ENDC
		XREF	_LVOSignal,_LVOWait,_LVOGetMsg,_LVOReplyMsg
		XREF	_LVOAllocSignal,_LVOAddIntServer,_LVOFindTask
		XREF	_LVOSupervisor,_LVOCachePreDMA,_LVOCachePostDMA
		XREF	_LVOReadBattMem,_LVOOpenResource

		XREF	GetPubMem,WaitASecond

		XREF	XTSelect,XTSendCommand,XTAddressBad,XTCommandDone

		XREF	_ciaa
		XREF	_ciapra

iprintf		MACRO
	IFD INT_DEBUG
		printf	\1
	ENDC
		ENDM

;==============================================================================
; These macros provide safe access to the WDC registers from within SCSITask.
; Before accessing a WDC register, the register number is put in st_WDCRegister
; so the interrupt routine can restore the tasks idea of the current register
; if it happens to interrupt SCSITask between the loading of SASR and the
; subsequent access of SCMD.  Not all uses are nescessary (because an interrupt
; cannot happen at that time) but I'm using this nearly everywhere for safety.
;==============================================================================
; added a new fix.  Musts always write SASR as longword at $40 (can still read
; as a byte at $41 though).
JAMREG		MACRO				;JAMREG operand,register,[base]
	IFGE	NARG-3
	IFD SASRW
		move.l	#\2,SASRW(\3)		select a register
	ENDIF
	IFND SASRW
		move.b	#\2,SASR(\3)		select a register
	ENDIF
		move.b	\1,SCMD(\3)		and store the value
	ENDC
	IFLT	NARG-3
	IFD SASRW
		move.l	#\2,SASRW(a4)		select a register
	ENDIF
	IFND SASRW
		move.b	#\2,SASR(a4)		select a register
	ENDIF
		move.b	\1,SCMD(a4)		and store the value
	ENDC
		ENDM				use for non-critical sections

GRABREG		MACRO				;GRABREG register,dest,[base]
	IFGE	NARG-3
	IFD SASRW
		move.l	#\1,SASRW(\3)		select a register
	ENDIF
	IFND SASRW
		move.b	#\1,SASR(\3)		select a register
	ENDIF
		move.b	SCMD(\3),\2		and get the value
	ENDC
	IFLT	NARG-3
	IFD SASRW
		move.l	#\1,SASRW(a4)		select a register
	ENDIF
	IFND SASRW
		move.b	#\1,SASR(a4)		select a register
	ENDIF
		move.b	SCMD(a4),\2		and get the value
	ENDC
		ENDM				use for non-critical sections

PUTREG		MACRO				;PUTREG operand,register
		move.b	#\2,st_WDCRegister(a5)	stash register being accessed
		JAMREG	\1,\2
		ENDM

GETREG		MACRO				;GETREG register,operand
		move.b	#\1,st_WDCRegister(a5)	stash register being accessed
		GRABREG \1,\2
		ENDM

	IFD SCSI_SUPPORTED
;==============================================================================
; Interrupt server used to signal the SCSI/XT task that an interrupt occurred
; on our board.  On entry a1 holds a ptr to the globals of the SCSI/XT task.
;==============================================================================
BoardServer
		moveq.l	#0,d0			assume it's not our interrupt
		movea.l	st_BoardAddress(a1),a0	point to the board
		btst.b	#DMAB_PEND,ISTR(a0)	are any interrupts pending ?
		beq	BoardServed		nope, exit immediately

; we can't let the main SCSITask clear the interrupts because if we don't do
; it here, we'll get another one the moment we exit from this interrupt code
; I think the maximum possible number of interrupts is 3 in a row (without
; any diddling of the registers between interrupts).  We'll maintain a simple
; circular list of the appropriate register contents when the interrupt occurs
		movem.l	d2/a6,-(sp)
		btst.b	#DMAB_EOP,ISTR(a0)	was there an EOP
		beq.s	10$			no, don't clear the int
		move.b	#0,CINT(a0)		clear int status

; we don't bother telling the main SCSITask about terminal count interrupts
10$		btst.b	#DMAB_PINT,ISTR(a0)	did we get peripheral int ?
		beq.s	20$			no, so don't read anything

		; MUST get SASR BEFORE getting SCSI_STATUS - it clears the int!
		move.w	st_IntPointer(a1),d2	get current int pointer
		move.b	ISTR(a0),st_IntData(a1,d2.w)	save ISTR status
		move.b	SASR(a0),st_IntData+1(a1,d2.w)  save status reg
		GRABREG	SCSI_STATUS,d0,a0	read the SCSI status
		move.b	d0,st_IntData+2(a1,d2.w) and save it for SCSITask
G2_0000 EQU 1
    IFD G2_0000
		cmp.b	#$20,d0			is it g2.0000?
		bne.s	13$
		btst.b	#STB_NoSignalG2,st_Flags(a1)
		beq.s	14$			he wants ints for g2.0000

;	printf <'Ignored g2.0000'>
		; don't signal him, but let him negate ack
		bset.b	#STB_IgnoredG2,st_Flags(a1)	always non-0
		bra.s	20$

		; if we get a msg in interrupt, the scsitask is going to
		; be reading the message as a single byte at a time, and
		; will be checking for g2.0000 ints before waiting again.
		; start ignoring g2.0000 ints since it'll come in before
		; the task can set the ignore bit.
13$:
		moveq	#$0f,d1
		and.b	d0,d1			mask off group
		cmp.b	#$0F,d1			gX.1111 - message in
		bne.s	14$
		bset.b	#STB_NoSignalG2,st_Flags(a1)
14$
    ENDC G2_0000

	IFD XT_SUPPORTED
		; if there's no XT drive, this always looks like the cause!
		btst.b	#5,XTPORT1(a0)		did the XT interrupt us ?
		beq.s	15$			nope
		move.b	XTPORT1(a0),st_IntData+3(a1,d2.w)  save XT status too
		move.b	#0,XTPORT3(a0)		clear XT interrupt status
	ENDC

15$		move.w	d2,d0			save original pointer
		addq.w	#4,d2			bump int pointer
		andi.w	#$1f,d2			range is 0-31
		move.w	d2,st_IntPointer(a1)	save new value

; we've cleared all the interrupt status stuff, so signal IOTask about it.  We
; do a test to see if the task pointer is the same as the int pointer first. If
; it is, then we'll signal the task, if it isn't we won't bother because the
; task will continue processing interrupts until the pointers are the same.
; This has the effect of cutting down on task switching a little (hence we
; can process more commands per second).  We also reload SASR with the value
; in st_WDCRegister.  This is because the interrupt could happen just as
; SCSITask loaded SASR but before it read or wrote SCMD.

***fixed to write SASR as a longword
	IFD SASRW
		move.l	d0,-(sp)
		moveq.l	#0,d0
		move.b	st_WDCRegister(a1),d0
		move.l	d0,SASRW(a0)  restore tasks register
		move.l	(sp)+,d0
	ENDC
	IFND SASRW
		move.b	st_WDCRegister(a1),SASR(a0)
	ENDC
		cmp.w	st_TaskPointer(a1),d0	are these the same ?
		bne.s	20$			nope, task has been signalled
		movea.l	st_SysLib(a1),a6	we have a new interrupt
		move.l	st_IntPendMask(a1),d0	so signal the SCSI task
		movea.l	st_ThisTask(a1),a1	that an interrupt has occurred
		jsr	_LVOSignal(a6)
20$		moveq.l	#1,d0			we handled the interrupt
		movem.l	(sp)+,d2/a6
BoardServed	rts
	ENDC SCSI_SUPPORTED

	IFD IS_A300
;============================================================================
; AT IDE interface interrupt handler
;
; The silly GAYLE hardware notices dropping signals, sets change, and 
; generates an interrupt.  Most drives take their time to drop the int,
; since PC ints are non-shared and edge sensitive (as opposed to shared
; level-sensitive interrupts).  So, verify that the int has gone away
; before clearing the interrupt from GAYLE, so it doesn't re-interrupt us.
;============================================================================
BoardServer
		moveq.l	#0,d0			assume it's not our interrupt
		movea.l	st_IntAddress(a1),a0	point to the board
		move.b	GAYLE_IntChange(a0),d1	check for int!
		bpl.s	exit			not ours

		move.l	a6,-(sp)

		; our interrupt, clear it
		; must clear drive first, then gayle
		move.l	st_BoardAddress(a1),a6
		move.b	AT_Status(a6),d1		clears interrupt (IDE)

; from testing no drive has shown problems with int latency
;		; wait for int to go away
;1$		tst.b	GAYLE_IntStatus(a0)
;		bmi.s	1$				still asserted

		; now we can safely clear GAYLE
		; MUST lock out other modifiers of GAYLE, since we must RMR
		; to avoid killing two bottom bits - Silly Hardware Designers.
		; We raise the int level to lock out level 6 Gayle ints -
		; or <ea>,sr is far faster than Disable()/Enable().
		move.w	SR,d0			save current SR
		ori.w	#$0700,SR		raise int priority to level 7
		move.b	GAYLE_IntChange(a0),d1
		and.b	#$03,d1			leave low two bits alone
		or.b	#$7c,d1			clear IDE int, leave the rest
		move.b	d1,GAYLE_IntChange(a0)	clear latch in Gayle
		move.w	d0,SR			re-enable normal int level

		; signal task
		movea.l	st_SysLib(a1),a6	we have a new interrupt
		move.l	st_IntPendMask(a1),d0	so signal the task
		movea.l	st_ThisTask(a1),a1	that an interrupt has occurred
		jsr	_LVOSignal(a6)
		move.l	(sp)+,a6
		moveq	#1,d0			we handled it, stop chain
exit:
		tst.l	d0			make sure cc's are set
		rts
	ENDC IS_A300

	IFD IS_GAME
;============================================================================
; AT IDE interface interrupt handler
;
; No gayle.
;============================================================================
BoardServer
		moveq.l	#0,d0			assume it's not our interrupt
		movea.l	st_IntAddress(a1),a0	point to the board
		move.b	GAYLE_IntChange(a0),d1	check for int!
		bpl.s	exit			not ours

		move.l	a6,-(sp)

		; our interrupt, clear it
		; must clear drive first, then gayle
		move.l	st_BoardAddress(a1),a6
		move.b	AT_Status(a6),d1		clears interrupt (IDE)

; from testing no drive has shown problems with int latency
;		; wait for int to go away
;1$		tst.b	GAYLE_IntStatus(a0)
;		bmi.s	1$				still asserted
;
		; now we can safely clear GAYLE
		; MUST lock out other modifiers of GAYLE, since we must RMR
		; to avoid killing two bottom bits - Silly Hardware Designers.
		; We raise the int level to lock out level 6 Gayle ints -
		; or <ea>,sr is far faster than Disable()/Enable().
		move.w	SR,d0			save current SR
		ori.w	#$0700,SR		raise int priority to level 7
		move.b	GAYLE_IntChange(a0),d1
		and.b	#$03,d1			leave low two bits alone
		or.b	#$7c,d1			clear IDE int, leave the rest
		move.b	d1,GAYLE_IntChange(a0)	clear latch in Gayle
		move.w	d0,SR			re-enable normal int level

		; signal task
		movea.l	st_SysLib(a1),a6	we have a new interrupt
		move.l	st_IntPendMask(a1),d0	so signal the task
		movea.l	st_ThisTask(a1),a1	that an interrupt has occurred
		jsr	_LVOSignal(a6)
		move.l	(sp)+,a6
		moveq	#1,d0			we handled it, stop chain
exit:
		tst.l	d0			make sure cc's are set
		rts
	ENDC IS_GAME

	IFD IS_CDTVCR
;============================================================================
; AT IDE interface interrupt handler for CDTVCR
;
; We don't have the alt status register or the digital IO register.
; We have a single int status bit: 1 for active, 0 for inactive.
;============================================================================
BoardServer
		moveq.l	#0,d0			assume it's not our interrupt
		movea.l	st_IntAddress(a1),a0	point to the board
		move.b	(a0),d1			check for int!
		btst.b	#CDTVB_IDE,d1
		beq.s	exit			not ours

		move.l	a6,-(sp)

		; our interrupt, clear it
		; must clear drive first, then gayle
		move.l	st_BoardAddress(a1),a6
		move.b	AT_Status(a6),d1		clears interrupt (IDE)

; from testing no drive has shown problems with int latency
;		; wait for int to go away
;1$		move.b	(a0),d1
;		btst.b	#CDTVB_IDE,d1
;		bne.s	1$				still asserted

		; signal task
		movea.l	st_SysLib(a1),a6	we have a new interrupt
		move.l	st_IntPendMask(a1),d0	so signal the task
		movea.l	st_ThisTask(a1),a1	that an interrupt has occurred
		jsr	_LVOSignal(a6)
		move.l	(sp)+,a6
		moveq	#1,d0			we handled it, stop chain
exit:
		tst.l	d0			make sure cc's are set
		rts
	ENDC IS_CDTVCR

	IFD IS_A1000
;============================================================================
; AT IDE interface interrupt handler for A1000+ jr/sr
;
; We have a single int status bit: 1 for active, 0 for inactive.
;============================================================================
BoardServer
		moveq.l	#0,d0			assume it's not our interrupt
		movea.l	st_BoardAddress(a1),a0	point to the board
		move.w	AT_IntStatus(a0),d1	check for int!
		bpl.s	exit			not ours

		; our interrupt, clear it
		move.b	AT_Status(a0),d1	clears interrupt (IDE)

; from testing no drive has shown problems with int latency
;		; wait for int to go away
;1$		move.w	AT_IntStatus(a0),d1
;		btst.b	#A1000_IDE,d1
;		bmi.s	1$				still asserted

;	printf <'got A1000 int'>
		; signal task
		move.l	a6,-(sp)
		movea.l	st_SysLib(a1),a6	we have a new interrupt
		move.l	st_IntPendMask(a1),d0	so signal the task
		movea.l	st_ThisTask(a1),a1	that an interrupt has occurred
		jsr	_LVOSignal(a6)
		move.l	(sp)+,a6
		moveq	#1,d0			we handled it, stop chain
exit:		tst.l	d0			cc's must be set here!!!
		rts
	ENDC IS_A1000

	IFD XT_SUPPORTED
IntName		DC.B	'SCSI/XT',0
		CNOP	0,2
	ENDC

	IFD IS_IDE
IntName		DC.B	'AT-IDE',0
		CNOP	0,2
	ENDC

	IFND XT_OR_AT_IDE
IntName		DC.B	'SCSI',0
		CNOP	0,2
	ENDC

	IFND IS_GAME
	IFND IS_A300
	IFND IS_CDTVCR
BattName	BATTMEMNAME
	ENDC
	ENDC
	ENDC

;==============================================================================
; This task gets started by the main IORequest handler task.  It's responsible
; for initialising the passed message port (for receiving device commands) and
; firing up the interrupt server that signals this task when interrupts arrive.
;
; ExecBase, BoardAddress, ParentTask and MsgPort are passed on the stack so we
; don't have to do lots of messaging gyrations in the parent task to find this
; port or worry about memory allocation problems.  All memory allocations are
; assumed to work OK (but I may need to fix this later).
;
; Stack on entry:
;	 4(sp)  = BoardAddress		the physical address of our board
;	 8(sp)	= ParentTask		the task that created us
;	12(sp)	= MessagePort		the port it wants to PutMsg to
;	16(sp)	= Terminal Count flag	(low byte only valid) do we require TC?
;	20(sp)	= HDDevice		device address (for hd_IOGlobals)
;
; Register usage:
;	a6	= execbase		always... (except calls to battmem)
;	a5	= SCSIGlobals (st_xxx)	scsitask globals
;	a4	= hardware address	address of control registers/board
;	a3	= hu_CurrentCmd		always holds hu_CurrentCmd value
;	a2	= st_RunningUnit	always holds st_RunningUnit value
;
; careful: the ide drivers depend on only Address regs being live - see iotask
;
;==============================================================================
SCSITask
	printf <'In SCSITask...\n'>
		movea.l	4,a6			get Exec library
		moveq.l	#st_SIZEOF,d0		get our global memory area
		bsr	GetPubMem		(I will assume that this works)
		movea.l	d0,a5			a5 always points to the globals
		move.l	a6,st_SysLib(a5)		stash Exec base
		move.l	4(sp),st_BoardAddress(a5)	and board address
	IFD IS_A300
		move.l	#GAYLE_ADDR,st_IntAddress(a5)	and int address
	ENDC
	IFD IS_GAME
		move.l	#GAYLE_ADDR,st_IntAddress(a5)	and int address
	ENDC
	IFD IS_CDTVCR
		move.l	#CDTV_ADDR,st_IntAddress(a5)	and int address
	ENDC
	; A1000 uses BoardAddress
		move.l	12(sp),st_CmdPort(a5)		and port address
	IFD A590_A2091_ONLY
		move.b	16+3(sp),st_TerminalCount(a5)	and terminal count flag
	ENDC
		move.l	20(sp),a0		HDDevice *
		move.l	a5,hd_STGlobals(a0)	only really needed for 3090

		movea.l	st_BoardAddress(a5),a4	a4 always points at the board
	printf <'got parms, board at $%lx'>,a4

		moveq.l	#0,d0
		move.l	d0,a3			no current command (paranoia)
	IFD SCSI_SUPPORTED
	    IFD XT_SUPPORTED
		; why?  I dunno.  A590 driver did it.
		move.b	#DMAF_XTEOP,CNTR(a4)	
		; what the H*LL is this anyways!!!!?????  FIX!????
		move.b	#0,DAWR(a4)		data acknowledge width
	    ENDC
	    IFND XT_SUPPORTED
		move.b	d0,CNTR(a4)		steve set it to 0 (a3000)
		move.b	#3,DAWR(a4)		data acknowledge width
	    ENDC
		move.b	d0,SRST(a4)		make sure DMA is off
		move.b	d0,CINT(a4)		clear pending interrupts
	ENDC

	IFD IS_SCSIDISK
; we need to detect if we are using a Boyer DMA chip (which can only DMA to
; longword aligned addresses) or a new DMA chip.  The new chip doesn't
; support word transfer count so we can use this to determine which chip
		bclr.b	#STB_FixBoyer,st_Flags(a5) assume not Boyer chip
		move.w	d0,WTCL(a4)		not using word xfer count
		cmp.w	WTCL(a4),d0
		bne.s	NotBoyer
		subq.w	#1,d0
		move.w	d0,WTCL(a4)
		cmp.w	WTCL(a4),d0
		bne.s	NotBoyer
		move.w	#$5555,d0
		move.w	d0,WTCL(a4)
		cmp.w	WTCL(a4),d0
		bne.s	NotBoyer
		bset.b	#STB_FixBoyer,st_Flags(a5)	got a boyer chip
NotBoyer:
	ENDC IS_SCSIDISK

		suba.l	a1,a1			find this task
		jsr	_LVOFindTask(a6)
		move.l	d0,st_ThisTask(a5)	for use by interrupt routine

		moveq.l	#-1,d0			get a signal for the interrupt
		jsr	_LVOAllocSignal(a6)
		move.b	d0,st_IntPendSig(a5)	save the signal number
		moveq.l	#0,d1			and store as a mask too
		bset.l	d0,d1
		move.l	d1,st_IntPendMask(a5)

	IFND ONE_TASK
		move.l	d1,st_WaitMask(a5)

; IDE uses one task, "scsitask" is called from ide instead of waiting
; also should help performance slightly

; fix - if we need ROM space
; could wipe out for IS_IDE, not really worth it unless strapped for bytes.
		moveq.l	#-1,d0			get a signal for the CmdPort
		jsr	_LVOAllocSignal(a6)
		move.b	d0,st_CmdPendSig(a5)	save the signal number
		moveq.l	#0,d1			and store as a mask too
		bset.l	d0,d1
		or.l	d1,st_WaitMask(a5)
	ENDC

		movea.l	st_CmdPort(a5),a1	initialise the message port
	IFND ONE_TASK
; more...
		move.b	d0,MP_SIGBIT(a1)	it uses this signal bit
		move.l	st_ThisTask(a5),MP_SIGTASK(a1)	it signals us
	ENDC
	IFD ONE_TASK
		move.b	#PA_IGNORE,MP_FLAGS(a1)	ignore incoming messages
	ENDC
		move.b	#NT_MSGPORT,LN_TYPE(a1)	it's a simple message port
		lea.l	MP_MSGLIST(a1),a1
		NEWLIST	a1			it's empty (and not public)

		moveq.l	#IS_SIZE,d0		get interrupt server memory
		bsr	GetPubMem
		move.l	d0,st_IntServer(a5)	stash addr (maybe for cleanup)
		movea.l	d0,a1
		move.b	#NT_INTERRUPT,LN_TYPE(a1)
		move.b	#INTPRI,LN_PRI(a1)	this is our priority
		move.l	a5,IS_DATA(a1)		server can see our globals
		lea.l	BoardServer(pc),a0	where the code is
		move.l	a0,IS_CODE(a1)
		lea.l	IntName(pc),a0
		move.l	a0,LN_NAME(a1)
		moveq.l	#INTNUM,d0		hook to this handler chain
		jsr	_LVOAddIntServer(a6)	add our interrupt server
	printf <'added int server'>

	IFD IS_A300
		; enable IDE interrupt at Gayle
		move.l	st_IntAddress(a5),a0
		move.b	GAYLE_IntEnable(a0),d0
		or.b	#$80,d0			FIX! use equate!
		move.b	d0,GAYLE_IntEnable(a0)
	ENDC
	IFD IS_GAME
		; enable IDE interrupt at Gayle
		move.l	st_IntAddress(a5),a0
		move.b	GAYLE_IntEnable(a0),d0
		or.b	#$80,d0			FIX! use equate!
		move.b	d0,GAYLE_IntEnable(a0)
	ENDC
		; interrupt always enabled for CDTV!

		lea.l	st_WaitingUnits(a5),a0	initialise WaitingUnits queue
		NEWLIST	a0
		lea.l	st_WorkingUnits(a5),a0	initialise WorkingUnits queue
		NEWLIST	a0

	; support it everywhere if battmem opens
	; this is a3000, a590 (why not), a2091
	IFND IS_GAME
	IFND IS_A300
	IFND IS_CDTVCR

	    IFD SCSI_SUPPORTED
		; one byte per scsi address
		move.l	#$40404040,st_SyncValues(a5)    init sync xfer values
		move.l	#$40404040,st_SyncValues+4(a5)  for asynchronous mode

; New addition for 2.0, check the battmem bits for our required jumper values
; and set up the defaults if battmem.resource is not present or memory corrupt
*******************************************************************************
		clr.b	st_MaxLUN(a5)		assume no LUNS >0
		move.b	#$10,st_SelTimeout(a5)	assume quick timeout
		move.b	#7,st_OwnID(a5)		assume host ID = 7
	    ENDC

		; no need to check for version >= 36, if it's there, use it
		lea.l	BattName(pc),a1
		jsr	_LVOOpenResource(a6)	get battmem resource
		tst.l	d0			did we get it ?
		beq	BattMemDone		nope, so not using 2.0 ^
		movea.l	d0,a6

	printf <'Reading battmem'>
		lea.l	st_SelTimeout(a5),a0	get required timeout
		moveq.l	#BATTMEM_SCSI_TIMEOUT_ADDR,d0
		moveq.l	#BATTMEM_SCSI_TIMEOUT_LEN,d1
		jsr	_LVOReadBattMem(a6)
	    IFD SCSI_SUPPORTED
		tst.b	st_SelTimeout(a5)	long or short ?
		bne.s	10$			long
		move.b	#TIMEOUT_VAL,st_SelTimeout(a5)	short 250ms
		bra.s	20$
10$		move.b	#LONG_TIMEOUT_VAL,st_SelTimeout(a5)
	    ENDC
	printf <'Long timeout'>

	    IFND IS_A1000
		; wait a few seconds...  (see discussion below)
		movem.l	d2/a6,-(sp)
		moveq	#LONG_SPINUP_DELAY,d2
	    ENDC
	    IFD IS_A1000
		; apparently, most IDE drives miss the spec, and take
		; a couple of seconds to come up.  The A1000 is fast enough
		; to hit them before they set BUSY (they should set it in
		; 400us).  We'll delay an
		; additional 2 seconds if the slow-boot bit is set.
		; We'll add a 1-second delay in init.
		; tst.b	st_SelTimeout(a5)	long or short ?
		; beq.s	17$			short

		; I solved the above problem with some modifications to
		; find hardware.  We do need to wait longer if there is
		; likely to be a second drive on status=0.  Normal time
		; to look for the second drive is 0 seconds, full time is
		; 30 seconds.  If an open is ever done, we find a drive 1,
		; and this is not set, we'll modify battmem to set this
		; bit.
	    ENDC
	    IFND IS_A1000
		move.l	st_SysLib(a5),a6	get execbase back
15$		bsr	WaitASecond		a6=execbase
		dbra	d2,15$
17$		movem.l	(sp)+,d2/a6
	    ENDC

20$
	    IFD SCSI_SUPPORTED
		lea.l	st_MaxLUN(a5),a0	get required LUN behaviour
		moveq.l	#BATTMEM_SCSI_LUNS_ADDR,d0
		moveq.l	#BATTMEM_SCSI_LUNS_LEN,d1
		jsr	_LVOReadBattMem(a6)
		tst.b	st_MaxLUN(a5)		supporting luns > 0?
		beq.s	30$			nope, only support 0
		move.b	#7,st_MaxLUN(a5)	yes, support all LUNs
	printf <'support luns'>

30$		lea.l	st_OwnID(a5),a0		get ID for host adaptor
		moveq.l	#BATTMEM_SCSI_HOST_ID_ADDR,d0
		moveq.l	#BATTMEM_SCSI_HOST_ID_LEN,d1
		jsr	_LVOReadBattMem(a6)
		eori.b	#7,st_OwnID(a5)		value is complemented
	IFD DEBUG_CODE
	moveq #0,d0
	move.b st_OwnID(a5),d0
	printf <'ownid = %ld'>,d0
	ENDC

		lea.l	st_SendSync(a5),a0	Should we initiate sync?
		moveq.l	#BATTMEM_SCSI_SYNC_XFER_ADDR,d0
		moveq.l	#BATTMEM_SCSI_SYNC_XFER_LEN,d1
		jsr	_LVOReadBattMem(a6)
		; default of 0 means don't send sync
	IFD DEBUG_CODE
	moveq #0,d0
	move.b st_SendSync(a5),d0
	printf <'sendsync = %ld'>,d0
	ENDC
	    ENDC

		move.l	st_SysLib(a5),a6	restore execbase
BattMemDone:

	IFD FORCE_SYNC
		move.b	#1,st_SendSync(a5)
	ENDC
	printf <'battmem read'>

*******************************************************************************
	ENDC !IS_CDTVCR
	ENDC !IS_A300
	ENDC !IS_GAME

	IFND ONE_TASK
		moveq.l	#SIGF_SINGLE,d0		tell parent we are ready now
		movea.l	8(sp),a1		(it's waiting on SIGF_SINGLE)
		jsr	_LVOSignal(a6)
	ENDC
	IFD ONE_TASK
; for the IDE driver, we will only use one task since we don't share the
; hardware, even if two drives are hooked up.  If we had IDE and SCSI, or
; if we had "reselectable IDE", ala Randy Hilton, we wouldn't do this - we'd
; use the normal scsi-like setup.

	printf <'Returning from SCSITask...\n'>
;		rts				exit back!
;		fall through to SCSIEventLoop, which does an rts for us!

	ENDC

	IFND A2090
	IFD SCSI_SUPPORTED
		move.b	#DMAF_INTENA!DMAF_PMODE,CNTR(a4)
	ENDC
	ENDC

;==============================================================================
; Here's where all the real low level work gets done.  This task waits on two
; possible events; an interrupt occured or a new command arrived at the message
; port.  If an interrupt occured then we jump to the appropriate routines to
; handle that specific kind of interrupt.  This is documented with the handler
; routines themselves.  If a message arrived, then we'll queue it on the
; appropriate unit.  If that unit is not on one of our queues when the message
; arrives, it will be added to the WaitingUnits queue pending selection. If the
; unit is on one of our queues, then it's busy or waiting already so it will
; just stay where it is until it's time to service it again.
;==============================================================================
SCSIEventLoop
	IFND ONE_TASK
		move.l	st_WaitMask(a5),d0	get the sigs we are waiting for
		jsr	_LVOWait(a6)		wait for something to happen
	ENDC

	IFD ONE_TASK
; for the IDE driver, we will only use one task since we don't share the
; hardware, even if two drives are hooked up.  If we had IDE and SCSI, or
; if we had "reselectable IDE", ala Randy Hilton, we wouldn't do this - we'd
; use the normal scsi-like setup.
;
; The iotask will call HandleCommand directly.  It exits by branching to
; scsieventloop.  Also, the init code above falls through to here.
;
		rts
	ENDC
	IFD SCSI_SUPPORTED
; we got a signal from the interrupt routine.  See what really interrupted us.
OneTaskEntry
;	printf <'iotask called scsitask'>
	IFD ONE_TASK
		move.l	st_RunningUnit(a5),a2	really only needed for ide here
		move.l	hu_CurrentCmd(a2),a3	need to keep current cmd in a3
;						(because iotask bsr's here)
	ENDC
IntEventLoop
;	printf <'IntEventLoop'>
		move.w	st_TaskPointer(a5),d0	get our interrupt frame pointer
		cmp.w	st_IntPointer(a5),d0	any ints outstanding ?
		beq	HandleCommand		nope, go look for a command
		move.w	d0,d2			save the current frame pointer
		addq.w	#4,d0			bump frame pointer for next
		andi.w	#$1f,d0
		move.w	d0,st_TaskPointer(a5)	and save for next time through
	ENDC

;==============================================================================
; We got a peripheral interrupt.  Here we have to determine if it was SCSI or
; XT that finished something.  Since XT commands only occur in the absence of
; working/current SCSI commands it's safe to test for SCSI and assume XT if
; it wasn't.  We can never get both interrupts at the same time.  (We use the
; WDC for XT address translation but that won't cause an XT interrupt anyway).
;==============================================================================
	IFD XT_SUPPORTED
		btst.b	#WDCB_INT,st_IntData+1(a5,d2.w)	SCSI int pending ?
		bne.s	SCSIService		yes, get status and handle it

; we got an XT interrupt, see which unit the interrupt occured on and handle it
		bsr	XTCommandDone		maybe finished an XT operation
		bra.s	IntEventLoop		look for another interrupt
	ENDC

	IFD SCSI_SUPPORTED
;==============================================================================
; The main SCSI service dispatch point.  Nearly all WDC interrupts imply that
; some action is required by us so we'll use one of four possible branch tables
; to dispatch to the correct code based on the Status group of the interrupt.
; It's generally safe to bang on the WDC registers because we won't get another
; interrupt until we do.  Disconnect is an exception to this because another
; target device can re-select us immediately.  This is tested first in DoSelect
;==============================================================================
SCSIService
; dispatch a normal SCSI interrupt to the appropriate handler for that phase
;	IFD DEBUG_CODE
;	move.l	a3,d1	do we have a command block?
;	beq.s	1$
;	addq.l	#1,cb_NumFlush(a3)
;1$
;	ENDC
		move.b	st_IntData+2(a5,d2.w),d0 get the saved status byte
		moveq.l	#$0f,d1			mask off the lower 4 bits
		and.b	d0,d1			d1 holds the error code
		andi.w	#$00f0,d0		d0 upper 4 bits are group code
		lsr.w	#3,d0			d0 now holds GroupCode<<1
		lea.l	Group_Table(pc),a0	get table address for this group
		adda.w	0(a0,d0.w),a0		a0 now points to dispatch table
		lsl.w	#1,d1			accessing table of word offsets
		move.w	0(a0,d1.w),d1		get offset from table to code
		jsr	0(a0,d1.w)		and call the correct routine
		bra	IntEventLoop
	ENDC SCSI_SUPPORTED

; IS_IDE falls through into here
;
;==============================================================================
; If we didn't get an interrupt signal or we got one and handled it already,
; we'll drop into this code.  It checks to see if a command signal came in
; and fetches it for queueing on the appropriate unit if one did.  The units
; are on their own list (hanging off the device base) and are pointed to by
; the IORequest that's stashed in our command blocks.  We can check the
; QueueType field of the unit to determine which queue we have it on (if any)
; and must add it to the WaitingUnits queue if it's not already active.  The
; queues maintained by this task are in addition to the normal unit list and
; are not touched by any other task.  We don't have to worry about race con-
; ditions this way and can forget about units that have no work pending.  This
; also makes it very simple to single thread commands to the same unit.
;==============================================================================
	IFD IS_IDE
OneTaskEntry
	IFD ONE_TASK
 		move.l	st_RunningUnit(a5),a2	; because iotask bsr's here
	ENDC
	ENDC
HandleCommand
		bsr.s	DoSelect		maybe select another unit
		movea.l	st_CmdPort(a5),a0	fetching from this port
		jsr	_LVOGetMsg(a6)		get any queued messages
;	printf <'In handlecommand, msg = $%lx'>,d0
		tst.l	d0			did we get one ?
		beq	SCSIEventLoop		no, so wait for something

; we have a valid command block, queue it on this unit then look for more
;	IFD DEBUG_CODE
;	tst.b	st_WasteSpace(a5)
;	beq.s	NMTO
;	printf <'Received more than one command\n'>
;NMTO	addq.b	#1,st_WasteSpace(a5)
;	ENDC

		movea.l	d0,a1			stash command block address
	IFND IS_IDE
		clr.b	cb_DidCacheStuff(a1)	no CachePreDMA call performed
		clr.b	cb_Programmed(a1)	DMA is OK so far
	ENDC
;	IFD DEBUG_CODE
;		clr.l	cb_NumDisconnects(a1)
;		clr.l	cb_NumFlush(a1)
;	ENDC
		movea.l	cb_IORequest(a1),a0	fetch the IORequest
		move.l	a2,-(sp)		save st_RunningUnit
		movea.l	IO_UNIT(a0),a2		and fetch pointer to Unit
		lea.l	hu_CmdList(a2),a0	point to command list header
		ADDTAIL				add cmd to end of command queue
		tst.b	hu_QueueType(a2)	is unit on one of our queues ?
		bne.s	NextCommand		yes, don't queue unit again

; The unit is currently inactive.  Since we just got a request for this unit
; we must add it onto our queue of units waiting for selection (WaitingUnits)
; If there's no RunningUnit currently active and no Select is pending we'll
; start a select sequence for this unit; this is done in DoSelect().
		lea.l	st_WaitingUnits(a5),a0	add to end of WaitingUnits
		lea.l	hu_SCSIQueue(a2),a1	SCSI list node for linkage
		ADDTAIL
		move.b	#UNIT_WAITING,hu_QueueType(a2)	it's on this queue
NextCommand:
		move.l	(sp)+,a2		restore st_RunningUnit
		bra.s	HandleCommand		may select last unit now

;==============================================================================
; DoSelect()
;
; If there is no RunningUnit and SelectPending is false then a select command
; is issued for the first unit on the WaitingUnits queue.  We will always do a
; select with ATN since some devices will do a message phase after selection
; even if we say we don't support reselection (by selecting without ATN).
; The unit is left on the WaitingUnits queue until a "select complete" occurs.
; Added a test: if a SCSI int is pending there's no point trying a select cmd.
;
; There's special case code in here to prevent simultaneous use of XT and SCSI.
;
; Extra bug fix for WD33C93A, have to disable SBIC interrupts while selecting.
;==============================================================================
DoSelect
	IFD SCSI_SUPPORTED
		tst.b	st_SelectPending(a5)	is a selection pending ?
		bne	NoSelect		yes, so don't try another
	ENDC
;	printf <'DoSelect: RunningUnit %lx\n'>,st_RunningUnit(a5)
		move.l	a2,d0			is a unit connected right now ?
		bne	NoSelect		yes, can't do a selection

		lea.l	st_WaitingUnits(a5),a0	are there any units waiting ?
		TSTLIST	a0
		beq.s	NoSelect		nope, so no work

	IFD SCSI_SUPPORTED
		move.w	st_IntPointer(a5),d0	check if an int is pending
		cmp.w	st_TaskPointer(a5),d0
		bne.s	NoSelect		yep, select will fail anyway
	ENDC
		movea.l	LH_HEAD(a0),a0		fetch the units queue ptr
		lea.l	-hu_SCSIQueue(a0),a0	adjust to start of unit struct

; XT units never support reselection so we can't allow an XT device to become
; active until ALL other SCSI devices have finished their operations.  If the
; first unit on the WaitingUnits queue is an XT device then we must make sure
; there are no other units on the WorkingUnits queue before we start the XT
	IFD XT_OR_AT_IDE
	  IFD SCSI_SUPPORTED
		tst.b	hu_Type(a0)		is this XT/AT or SCSI
		bne.s	SCSISelect		no problem, its SCSI
	  ENDC
		lea.l	st_WorkingUnits(a5),a1	make sure no one else running
		TSTLIST	a1
		beq	XTSelect		fine, we can start the XT
;	printf <'some unit active, can't start xt/at operation\n'>
	  IFND SCSI_SUPPORTED
NoSelect:					; so we have a destination
	  ENDC
		rts				else we have to quit now
	ENDC XT_OR_AT_IDE

	IFD SCSI_SUPPORTED
; We have a pointer in a0 to the SCSI unit that we want to start selection on.
; Check if we are supporting logical units above 0 and time it out if we're not
SCSISelect	tst.b	st_MaxLUN(a5)		should we check the LUN ?
		bne.s	TrySelect		nope, we support them
; bug fix. can`t allow further selects to happen until we fake timeout this one
		move.b	#1,st_SelectPending(a5)	can't allow selects to happen
		tst.b	hu_LUN(a0)		yes, so only allow 0
		bne	FakeTimeout		not 0, make like timeout

TrySelect:	move.b	CNTR(a4),d0		get control register
		bclr.l	#DMAB_INTENA,d0		turn off interrupts from SBIC
		move.b	d0,CNTR(a4)

		PUTREG	hu_Unit(a0),DEST_ID	the unit # we want to select
		PUTREG	#wd_SELECT_WITH_ATN,COMMAND	issue select with ATN
		move.b	#1,st_SelectPending(a5)	can't allow selects to happen

20$		bset.l	#DMAB_INTENA,d0		turn interrupts from SBIC on
		move.b	d0,CNTR(a4)

; command may or may not have been issued, wait for next interrupt to come in.
NoSelect	rts

;==============================================================================
; Unit = FindWorking( unit, LUN )
;  d0		       d0    d1
;
; Attempts to find the given unit on the WorkingUnits queue and returns a ptr
; to the Unit structure.  The unit will NOT have been removed from the queue
; if it was found.  A LUN value of -1 will cause this routine to only compare
; physical unit numbers and return the first one it finds.  This routine will
; only look at SCSI units since we never allow XT and SCSI units to be on the
; WorkingUnits queue at the same time.  Returns 0 if the unit wasn't found.
;
; NOTE: the returned pointer is to the head of the unit structure not to the
;       SCSIQueue entry of the unit structure.  Must adjust ptr before REMOVE
;==============================================================================
FindWorking	move.l	d2,-(sp)
		move.b	d0,d2			stash unit code
		move.l	st_WorkingUnits(a5),d0	fetch the first node

10$		movea.l	d0,a0			node pointer to a0
		move.l	(a0),d0			look ahead to next node
		beq.s	30$			end of list, return 0
; possible to do "cmp.b hu_Unit-hu_SCSIQueue(a0),d2" but it's not as readable
		lea.l	-hu_SCSIQueue(a0),a1	point to start of unit struct
		cmp.b	hu_Unit(a1),d2		does unit match ?
		bne.s	10$			nope, scan the next
		tst.b	d1			are we checking LUNS too ?
		bmi.s	20$			no, so we found a match
		cmp.b	hu_LUN(a1),d1		yes, does LUN match
		bne.s	10$			nope, scan the next
20$		move.l	a1,d0			return ptr to unit struct
30$		move.l	(sp)+,d2
		rts

;==============================================================================
; success and byte = SCSIGetByte(),BoardAddress
;    d1	       d0			a4
;
; Fetch a pending byte of data in single byte transfer mode.  I had to add the
; success flag in d1 because the WDC chip sometimes behaves wierdly on a msg
; in transfer after a reselection.  Occasionally, an invalid command interrupt
; will come in right after issuing the transfer command with SBT true.  I dont
; know why this happens, but the WDC recovers OK and just re-issues the msg in
; interrupt again (right after the invalid command int has been serviced).
;
; (I hope this doesn't ever happen on any other commands, or I'm broken!!!!)
;==============================================================================
SCSIGetByte	move.w	st_TaskPointer(a5),d0	get current interrupt ptr
		PUTREG	#0,CONTROL		turn off DMA mode
		PUTREG	#WDCF_SBT!wd_TRANSFER_INFO,COMMAND  issue command
		moveq.l	#-1,d1			assume success
GetLoop		cmp.w	st_IntPointer(a5),d0	did an interrupt occur
		bne.s	BadGet			yes, return failure
		btst.b	#WDCB_DBR,SASR(a4)	is data buffer ready ?
		beq.s	GetLoop			nope, wait
		GETREG	DATA_REG,d0		yep, fetch the data byte
		rts				return d1=TRUE, d0=data

; added a test to see if the interrupt was a bad command interrupt.  If it
; was then it was caused by a selection failing due to an incoming reselect.
; Since we`re usually fetching the identify message when this happens we
; just ignore it and carry on polling for data.
BadGet:
		move.w	st_TaskPointer(a5),d0	get current interrupt ptr
		move.b	st_IntData+2(a5,d0.w),d0 get what caused interrupt
		cmpi.b	#$40,d0			was it bad command int ?
		bne.s	ReallyBadGet		nope, so bail out
		move.w	st_IntPointer(a5),d0	use new pointer
		bra.s	GetLoop

ReallyBadGet	moveq.l	#0,d1			got unexpected interrupt
		rts				return d1=FALSE

;==============================================================================
; SCSIPutByte( byte ),BoardAddress
;		d0	   a4
;
; Send a byte of data to the SCSI bus in single byte transfer mode.  The target
; MUST be requesting data out when this command is called or we'll lock up.
; This routine only affects d0.  All calls to this routine depend on this fact!
;==============================================================================
SCSIPutByte	PUTREG	#0,CONTROL		turn off DMA mode
		PUTREG	#WDCF_SBT!wd_TRANSFER_INFO,COMMAND  issue command
10$		btst.b	#WDCB_DBR,SASR(a4)	is data buffer ready ?
		beq.s	10$			nope, wait
		PUTREG	d0,DATA_REG		send the data byte
		rts

;==============================================================================
; SCSIGetBytes( count, buffer)
; 		 d0	 a0
;
; This driver does any I/O that is less than 256 bytes using programmed I/O.
; The reason is that these are usually variable length transfers that may
; terminate on an odd boundary which would kill the DMA engine.
;
; Fetches count or less bytes and stores them in buffer.  If an interrupt is
; asserted after a byte has been transferred then an unexpected phase has
; just occured.  This routine will terminate immediately and we'll fix up
; the appropriate pointers using the residual left in the transfer count
; registers of the WDC.  If it wasn't an unexpected phase interrupt then
; something is wrong anyway.  Also exits when count bytes have been fetched.
;
; This should only be used during a Data In phase, not for messages.  If a
; parity error occurs on the data then an Initiator Detected Error message
; will be initialised and ATN asserted on the last data byte.
;
; Modified this routine to cope with arbitrary length transfers (Boyer DMA fix)
;==============================================================================
SCSIGetBytes:	; could share this bit with PutBytes, but that might be
		; performance critical (sends commands)
		move.l	d0,d1
		swap	d1
		PUTREG	d1,TRANSFER_MSB		using transfer count register
		swap	d1
		PUTREG	d1,TRANSFER_LSB
		lsr.w	#8,d1
		PUTREG	d1,TRANSFER_MB

		move.w	st_TaskPointer(a5),d1	stash current int index
		PUTREG	#0,CONTROL		not using DMA
		PUTREG	#wd_TRANSFER_INFO,COMMAND	start the command
		move.b	#DATA_REG,st_WDCRegister(a5)
	IFD SASRW
		move.l	#DATA_REG,SASRW(a4)	select the data register
	ENDIF
	IFND SASRW
		move.b	#DATA_REG,SASR(a4)	select the data register
	ENDIF

GetBytesLoop	btst.b	#WDCB_DBR,SASR(a4)	is data buffer ready ?
		bne.s	GotAByte		yes, fetch a byte
		cmp.w	st_IntPointer(a5),d1	no byte, check for interrupt
		beq.s	GetBytesLoop		no interrupt, wait for a byte
		rts				interrupt occured, exit now

GotAByte	move.b	SCMD(a4),(a0)+		transfer the byte
		subq.l	#1,d0
		bgt.s	GetBytesLoop		go for the next byte
		btst.b	#WDCB_PE,SASR(a4)	was parity OK ?
		beq.s	NoPE			yes

; got a parity error on the last transfer, assert ATN and initialise message
		bsr	AssertATN
		lea.l	cb_MessageOut(a3),a1
		move.b	#$05,(a1)		initiator detected error
		move.w	#1,cb_MsgOutLen(a3)	message is this long
		move.l	a1,cb_MsgOutPtr(a3)	initialise the pointer
NoPE		rts

;==============================================================================
; SCSIPutBytes( count, buffer)
; 		 d0	 a0
;
; This driver does any I/O that is less than 256 bytes using programmed I/O.
; The reason is that these are usually variable length transfers that may
; terminate on an odd boundary which would kill the DMA engine.
;
; Sends count or less bytes from buffer to the target.  If an interrupt is
; asserted after a byte has been transferred then an unexpected phase has
; just occured.  This routine will terminate immediately and we'll fix up
; the appropriate pointers using the residual left in the transfer count
; registers of the WDC.  If it wasn't an unexpected phase interrupt then
; something is wrong anyway.  Also exits when count bytes have been sent
;
; This should only be used during a Data Out or Command or Message out phase.
; The target is supposed to detect any parity errors here and ask for the
; command block or data bytes again (using a Restore Pointers message)
;
; Modified this routine to cope with arbitrary length transfers (Boyer DMA fix)
;==============================================================================
SCSIPutBytes	move.l	d0,d1
		swap	d1
		PUTREG	d1,TRANSFER_MSB		using transfer count register
		swap	d1
		PUTREG	d1,TRANSFER_LSB
		lsr.w	#8,d1
		PUTREG	d1,TRANSFER_MB

		move.w	st_TaskPointer(a5),d1	stash current int index

		PUTREG	#0,CONTROL		not using DMA
		PUTREG	#wd_TRANSFER_INFO,COMMAND	start the command
		move.b	#DATA_REG,st_WDCRegister(a5)
	IFD SASRW
		move.l	#DATA_REG,SASRW(a4)	select the data register
	ENDC
	IFND SASRW
		move.b	#DATA_REG,SASR(a4)	select the data register
	ENDC

PutBytesLoop	btst.b	#WDCB_DBR,SASR(a4)	is data buffer ready ?
		bne.s	PutAByte		yes, send a byte
		cmp.w	st_IntPointer(a5),d1	has an interrupt occured
		beq.s	PutBytesLoop		nope, wait for DBR ready
		rts				yes, exit right away

PutAByte	move.b	(a0)+,SCMD(a4)		transfer the byte
		subq.l	#1,d0
		bgt.s	PutBytesLoop		go for the next byte
30$		rts

;==============================================================================
; FlushDMA()
;
; Ensures that the last DMA operation doesn't leave words in the FIFO.  We're
; using a trick with EOP to make this work.  All DMA is performed with EOP int
; and function disabled (because it has a 2meg limit).  Since word transfer
; count is always set to 0, the moment we enable the EOP function the DMA will
; determine that it's time to do a flush of it's FIFO.  This really only
; matters for the read direction (peripheral to memory) but this will be called
; for the write direction too.
;
; OOPS! Latest rev of the DMA chip doesn't support this function so we have to
; use Terminal Count all the time.  This means disconnect/reselect won't work!
;
; DOUBLE OOPS!  Now we have a flush DMA register (added to the B and C chips)
;==============================================================================
FlushDMA	tst.b	st_DMAGoing(a5)		was DMA started
		beq.s	NoFlushNeeded		no, so no flush needed

	IFD A590_A2091_ONLY
		tst.b	st_TerminalCount(a5)	did we use Terminal Count?
		bne.s	20$			if so, no flush
	ENDC
		move.b	#$00,FDMA(a4)		flush DMA out
10$		btst.b	#DMAB_FIFOE,ISTR(a4)	make sure FIFO is empty
		beq.s	10$
20$
		clr.b	st_DMAGoing(a5)		dma not going now
		move.b	#0,SRST(a4)		come to a full stop
NoFlushNeeded	rts

;==============================================================================
; These are the dispatch tables that are used to call the correct routines
; based on the SCSI status codes when we get a SCSI interrupt.  Each table
; corresponds to a certain status group and contains a word offset (from the
; table to the routine) for each of the error codes.  Some never occur and
; point to BadStat.  Routines marked with an asterix are target mode only and
; aren't supported by this driver.  Routines that are commented but are marked
; with an asterix are Initiator mode but just plain useless or not supported.
; The format Gn.nnnn corresponds directly to the WD33C93 interrupt status bits.
;
; This first table allows us to use the group code (upper 4 bits) to get the
; address of the relevant Group dispatch table for use with the error code.
;==============================================================================
Group_Table	DC.W	Group_0-Group_Table	0 reset
		DC.W	Group_1-Group_Table	1 Successful completion
		DC.W	Group_2-Group_Table	2 Paused or Aborted
		DC.W	0			3
		DC.W	Group_3-Group_Table	4 Terminated
		DC.W	0			5
		DC.W	0			6
		DC.W	0			7
		DC.W	Group_4-Group_Table	8 Service required

;================================================================
; group 0 status codes signify a reset (only 0000 and 0001 are valid!)
;================================================================
Group_0		DC.W	G0.0000-Group_0	wd33c93 reset
		DC.W	G0.0001-Group_0	wd33c93a reset
		DC.W	BadStat-Group_0	paranoia about future parts
		DC.W	BadStat-Group_0 ditto
		DC.W	BadStat-Group_0 ditto
		DC.W	BadStat-Group_0 ditto
		DC.W	BadStat-Group_0 ditto
		DC.W	BadStat-Group_0 ditto
		DC.W	BadStat-Group_0 ditto
		DC.W	BadStat-Group_0 ditto
		DC.W	BadStat-Group_0 ditto
		DC.W	BadStat-Group_0 ditto
		DC.W	BadStat-Group_0 ditto
		DC.W	BadStat-Group_0 ditto
		DC.W	BadStat-Group_0 ditto
		DC.W	BadStat-Group_0 ditto

;================================================================
; group 1 status codes signify a successful completion interrupt
;================================================================
Group_1		DC.W	G1.0000-Group_1	* can never get this
		DC.W	G1.0001-Group_1	select completed
		DC.W	BadStat-Group_1
		DC.W	G1.0011-Group_1	*
		DC.W	G1.0100-Group_1	*
		DC.W	G1.0101-Group_1	translate address completed
		DC.W	G1.0110-Group_1	* select and transfer completed
		DC.W	BadStat-Group_1
; all of these imply a prior transfer completed OK. Now switch to given phase
		DC.W	G1.1000-Group_1	data out phase request
		DC.W	G1.1001-Group_1	data in phase request
		DC.W	G1.1010-Group_1	command phase request
		DC.W	G1.1011-Group_1	status phase request
		DC.W	BadStat-Group_1
		DC.W	BadStat-Group_1
		DC.W	G1.1110-Group_1 message out phase request
		DC.W	G1.1111-Group_1 message in phase request

;================================================================
; group 2 status codes signify a paused or aborted interrupt
;================================================================
Group_2		DC.W	G2.0000-Group_2	Transfer paused with ack asrtd (msg in)
		DC.W	G2.0001-Group_2	* save data ptrs during sel and trans
		DC.W	G2.0010-Group_2 * Select/reselect aborted (t/o disabled)
		DC.W	G2.0011-Group_2	*
		DC.W	G2.0100-Group_2	*
		DC.W	BadStat-Group_2
		DC.W	BadStat-Group_2
		DC.W	BadStat-Group_2
; all of these mean a prior transfer was aborted by the WDC abort command
		DC.W	G2.1000-Group_2	data out phase request
		DC.W	G2.1001-Group_2	data in phase request
		DC.W	G2.1010-Group_2	command phase request
		DC.W	G2.1011-Group_2	status phase request
		DC.W	BadStat-Group_2
		DC.W	BadStat-Group_2
		DC.W	G2.1110-Group_2 message out phase request
		DC.W	G2.1111-Group_2 message in phase request

;================================================================
; group 3 status codes signify a terminated interrupt
;================================================================
Group_3		DC.W	G3.0000-Group_3	an invalid command was issued
		DC.W	G3.0001-Group_3	unexpected disconnect caused termination
		DC.W	G3.0010-Group_3 timeout during select or reselect
		DC.W	G3.0011-Group_3	* parity error (ATN not asserted)
		DC.W	G3.0100-Group_3	* parity error (ATN asserted)
		DC.W	G3.0101-Group_3 address exceeded disk boundaries
		DC.W	G3.0110-Group_3 * wrong target device reselected
		DC.W	G3.0111-Group_3 incorrect message, status or cmd recvd
; all of these imply an unexpected information phase was requested.  Usually
; during a Transfer command when transfer didn't reach 0. switch to new phase
		DC.W	G3.1000-Group_3	data out phase request
		DC.W	G3.1001-Group_3	data in phase request
		DC.W	G3.1010-Group_3	command phase requdst
		DC.W	G3.1011-Group_3	status phase request
		DC.W	BadStat-Group_3
		DC.W	BadStat-Group_3
		DC.W	G3.1110-Group_3 message out phase request
		DC.W	G3.1111-Group_3 message in phase request

;================================================================
; Group 4 codes signify a service required interrupt
;================================================================
Group_4		DC.W	G4.0000-Group_4	WDC has been reselected
		DC.W	G4.0001-Group_4 WDC reselected (advanced feature, -93a)
		DC.W	G4.0010-Group_4 *
		DC.W	G4.0011-Group_4	*
		DC.W	G4.0100-Group_4	* ATN has been asserted
		DC.W	G4.0101-Group_4 a disconnect has occured
		DC.W	BadStat-Group_4
		DC.W	BadStat-Group_4
; all of these imply that the REQ signal has been asserted following a connect
; (thru selection or reselection).  This tells us what phase we are expecting.
		DC.W	G4.1000-Group_4	data out phase request
		DC.W	G4.1001-Group_4	data in phase request
		DC.W	G4.1010-Group_4	command phase request
		DC.W	G4.1011-Group_4	status phase request
		DC.W	BadStat-Group_4
		DC.W	BadStat-Group_4
		DC.W	G4.1110-Group_4 message out phase request
		DC.W	G4.1111-Group_4 message in phase request

;=========================================================================
; list of routines not supported. Simply return immediately if we get them
G1.0000:
G1.0011:
G1.0100:
	IFND XT_SUPPORTED
G1.0101:
	ENDC
G2.0001:
G2.0010:
G2.0011:
G2.0100:

G3.0011:
G3.0100:
G3.0110:
	IFND XT_SUPPORTED
G3.0101:
	ENDC

	IFND ADVANCED_FEATURES
G4.0001:
	ENDC
G4.0010:
G4.0011:
G4.0100:
BadStat		printf <'UNSUPPORTED INTERRUPT !!!\n'>
		rts
;=========================================================================

;==============================================================================
; the WD SCSI controller has been reset by a command or power up.  We should
; initialise some registers to reasonable defaults.  If own ID is not set to 7
; we'll issue another reset command with the correct ID in the OWNID register.
; A590 and A2091 have three jumpers which can be used to modify the drivers
; behaviour.  These are not present on the A2090 board.
; To tell the A part from the non-A part, we have to use the "Advanced
; Features" mode.  However, this seems to give us problems AND hurt our
; performance, plus I just don't trust it given the past problems with WD.
; Therefore, we'll reset A parts a second time without advanced features.
;==============================================================================
G0.0001:	bset.b	#STB_33c93a,st_Flags(a5)  An 'A' part
		moveq	#1,d0			flag that we got an AF reset
		bra.s	reset_common
G0.0000:	moveq	#0,d0			non-advanced-features reset
reset_common:	printf  <'Got reset\n'>
		GETREG	OWN_ID,d1		get the current own ID value
		andi.b	#7,d1			mask off clock bits
		cmp.b	st_OwnID(a5),d1		have we already set it ?
		beq.s	IDSet			yep, so no work to do

	IFD A590_A2091_ONLY
; jumpers are inverted so we have to read the second XT port and invert it
; NOTE! The boyer chip can't read these registers unless the XT/EOP bit in
; CNTR is set.  Of course, we don't want it set normally (we want to flush
; DMA with it).  Steve didn't document this (and you have to read between
; the lines of boyer's docs).  - REJ
; XTEOP is set here.  It'll be disabled when we get around to doing DMA.
		bset.b	#DMAB_XTEOP,CNTR(a4)	disable everything
		move.b	XTPORT0+$20(a4),d0	uses second XT unit register
		eori.b	#$07,d0
;	printf <'jumpers are 0x%lx'>,d0

; jumper 0 enables selection of LUNs greater than 0 (lotsa things screw up)
		clr.b	st_MaxLUN(a5)		assume highest LUN is 0
		lsr.b	#1,d0
		bcc.s	10$			correct
		move.b	#7,st_MaxLUN(a5)	nope, we support LUNs
10$
; jumper 1 sets the timeout on selection to 250ms (no jumper) or 3 seconds
; (1.5 on A3000's)
; Seagate 225N has problems with ignoring parity msgs, jumper disables the
; parity error handling (on message phase) too.
; 
; To improve startup, we'll instead wait 15 seconds if the bit is set
; before searching for drives.  We'll bump the timeout a little (say 300ms)
; in case someone is slightly out of spec and was counting on this.  15
; seconds should allow time for any drive to come up.  - REJ

		move.b	#TIMEOUT_VAL,st_SelTimeout(a5)	assume quick timeout
		clr.b	st_ParityCheck(a5)	and checking parity
		lsr.b	#1,d0
		bcc.s	20$			correct
		move.b	#LONG_TIMEOUT_VAL,st_SelTimeout(a5)
		move.b	#1,st_ParityCheck(a5)	and ignore message parity

		; wait 15 seconds...
		movem.l	d0/d2,-(sp)
		moveq	#LONG_SPINUP_DELAY,d2
15$		bsr	WaitASecond
		dbra	d2,15$
		movem.l	(sp)+,d0/d2
20$
; jumper 2 enables our initiating Sync negotiations
		lsr.b	#1,d0
		bcc.s	30$
		move.b	#1,st_SendSync(a5)	Initiate Sync after inquiry
;	printf <'Sync jumper\n'>
30$
	ENDC A590_A2091_ONLY

; set the input frequency divisor to 3 as well
; enable advanced features for the A part, which allows us to tell them apart
; if IDSet comes here to re-reset the chip, it won't use the advanced features

		moveq.b	#WDCF_EAF,d1
Reset_WD:	or.b	st_OwnID(a5),d1		get required ID

	IFD CLOCK_14MHZ
		; a3000 has 14Mhz clock, uses 3.  A590/2091 have 7Mhz, use 2
		; $00 causes a divisor of 2, $40 causes a divisor of 3
		ori.b	#$40,d1			input clock divisor=3
	ENDC
		JAMREG	d1,OWN_ID		set the ID...
		JAMREG	#wd_RESET,COMMAND	and issue a reset command
		move.b	#1,st_SelectPending(a5)	can't allow selects to happen
		rts				look for another interrupt


; we issued a reset command so the OWN_ID register got sampled, do other regs.
IDSet	printf <'In IDSet'>
		; do we need to turn off advanced features? (d0 is AF flag)
		moveq	#0,d1			no advanced features this time
		tst.b	d0
		bne.s	Reset_WD		AF is set - reset again

		; set up chip-specific values
		move.b	#MAX_OFFSET,st_MaxOffset(a5)
		move.b	#MIN_XFER_PERIOD,st_MinXferPeriod(a5)
		move.b	#MIN_MSG_PERIOD,st_MinMsgPeriod(a5)

		btst.b	#STB_33c93a,st_Flags(a5)
		beq.s	non_A

	printf  <'We have a WD33c93A\n'>
		; we have an 'A' part
		move.b	#MAX_OFFSET_A,st_MaxOffset(a5)
		move.b	#MIN_XFER_PERIOD_A,st_MinXferPeriod(a5)
		move.b	#MIN_MSG_PERIOD_A,st_MinMsgPeriod(a5)

non_A		clr.b	st_SelectPending(a5)	selects are OK now
		JAMREG	#0,CONTROL		DMA mode disabled
		JAMREG	st_SelTimeout(a5),TIMEOUT  set timeout period
		JAMREG	#$40,SYNC_TRANSFER	asynchronous + req/ack=300ns
		JAMREG	#WDCF_ER,SOURCE_ID	enable reselection
		rts				and that's all


;==============================================================================
; Bug fix, I am now using resume select and transfer to fetch status and
; command complete bytes.  When sel trans completes fetch the target status
; byte from the Target LUN register and mark the command block as complete.
;==============================================================================
G1.0110		iprintf <'g1.0110'>
		move.b	#UNIT_WAITING,hu_WhatNext(a2)	all completed
		movea.l	cb_WStatus(a3),a1	fetch status storage pointer
		GETREG	TARGET_LUN,d0
		move.b	d0,(a1)			and save it
		beq.s	1$			was the status 0?
		cmpi.b	#CHECK_CONDITION,d0
		bne.s	1$			only check_cond for 6/29

	IFD DEBUG_CODE
	move.l	cb_WCommand(a3),a0
	printf <'got CHECK_CONDITION, cmd = $%lx'>,(a0)
	ENDC
		; since we got a check_condition, the unit _may_ have been
		; reset.  Since it should be rare to get, and a power-up
		; or reset will lose sync info, we must reset our sync state
		; on ANY check_condition.  We'll set things to force a
		; renegotiation on the next message out phase (normally
		; identify, usually for REQUEST_SENSE).  Of course, if we
		; hadn't set up sync we'll ignore this.
		moveq.w	#0,d0
		move.b	hu_Unit(a2),d0
		move.b	st_SyncValues(a5,d0.w),d1
		cmpi.b	#$40,d1			never changed sync for unit
		beq.s	1$
		move.b	#$40,d1			300ns, async
		move.b	d1,st_SyncValues(a5,d0.w)	reset to async
		PUTREG	d1,SYNC_TRANSFER	paranoia, probably not needed
		move.l	hu_Addr(a2),a0		SCSI address struct
		clr.b	ha_DoneSync(a0)		make us retry sync negotiations
1$		rts
	ENDC SCSI_SUPPORTED

; we need this for all drives - REJ
;==============================================================================
; A select command just completed successfully.  This will be for the first
; unit on the WaitingUnits queue.  Since it is now selected (and working OK)
; we should move it to the RunningUnit slot and wait for the Message Out REQ
; to come in because we selected with ATN asserted and want to do an Identify
; We also set up current command on this unit and initialise the SCSI pointers.
;
; This routine is also called to fake up an XT selection.  It does a lot more
; work than required for XT's but I don't want to compromise SCSI performance
;==============================================================================
FakeSelect:
G1.0001:
	iprintf <'g1.0001'>
G1.0001entry	lea.l	st_WaitingUnits(a5),a0	unlink unit from waiting queue
		REMHEAD				returns ptr to SCSIQueue entry
		movea.l	d0,a2			so we adjust it to point ...
		lea.l	-hu_SCSIQueue(a2),a2	... to start of unit struct
		move.l	a2,st_RunningUnit(a5)	make this the running unit
;						a2 is always the same as
;						st_RunningUnit...
		move.b	#UNIT_RUNNING,hu_QueueType(a2)	what queue we're on
		move.b	#UNIT_GOT_ERROR,hu_WhatNext(a2)	disconnection state

		lea.l	hu_CmdList(a2),a0	get first command on this unit
		REMHEAD
;	printf <'new CurrentCmd: $%lx\n'>,d0
		move.l	d0,hu_CurrentCmd(a2)	save it as the current cmd
		move.l	d0,a3			a3 ALWAYS holds hu_CurrentCmd!

;						set up the SCSI working ptrs
		movea.l	cb_SCSICmd(a3),a1	from the SCSICmd struct
		move.l	a1,cb_LinkedCmd(a3)	we're using the first cmd block
		move.l	scsi_Data(a1),cb_WData(a3)
		move.l	scsi_Command(a1),cb_WCommand(a3)

		clr.l	scsi_Actual(a1)		no data transferred yet
		clr.w	scsi_CmdActual(a1)	and no command either

		lea.l	scsi_Status(a1),a1	set up status area address
		move.l	a1,cb_WStatus(a3)	only one status byte

	IFD SCSI_SUPPORTED
		; only scsi does messaging...
		move.l	cb_WData(a3),cb_SData(a3)	copy working ptrs...
		move.l	cb_WCommand(a3),cb_SCommand(a3)	...to saved pointers
		move.l	cb_WStatus(a3),cb_SStatus(a3)

		; set up the sync register values for this unit now that
		; we selected it
		bsr	SetTransfer

; We did a select with ATN so the target is going to request a message out
; next.  We're going to send an identify with the reselection bit set unless
; the flags on this unit tell us not to support reselection.  This is usually
; the case if there is only a single disk unit because there's no need for all
; the disconnect/reconnect overhead if no other units need servicing.  The
; message system is effectively initialised here but is maintained by the
; message in and out handlers on a unit by unit basis.  This is unnescessary
; for the XT unit but I've left it in because I don't want to compromise SCSI
		lea.l	cb_MessageIn(a3),a1	initialise msg in for 1 byte
		move.l	a1,cb_MsgInPtr(a3)
		move.w	#1,cb_MsgInLeft(a3)
		clr.w	cb_MsgInLen(a3)		no message received yet

		lea.l	cb_MessageOut(a3),a1	and msg out is 1 byte too
		move.l	a1,cb_MsgOutPtr(a3)
		move.w	#1,cb_MsgOutLen(a3)	we're sending a 1 byte message

		move.b	#$80,d0			IDENTIFY
		or.b	hu_LUN(a2),d0		plus the logical unit number

	IFD A590_A2091_ONLY
		tst.b	st_TerminalCount(a5)	do we need Terminal Count?
		bne.s	NoDisconnect		if so, no reselect allowed
	ENDC
		tst.b	hu_IsDisk(a2)
		beq.s	CanDisconnect		always enable for non-disks
		btst.b	#RDBFB_NORESELECT,hu_Flags(a2) reselection disabled?
		bne.s	NoDisconnect		yes, don`t enable it
CanDisconnect	move.l	hu_Addr(a2),a0
		or.b	ha_Reselect(a0),d0	($40 or $00) enable reselection

NoDisconnect	move.b	d0,(a1)			save the message byte
	ENDC SCSI_SUPPORTED
;						a2 has been modified...
		rts

	IFD SCSI_SUPPORTED
;==============================================================================
; A translate address completed successfully.  Now it's time to send XT cmds.
; This interrupt only happens when we used the translate address function of
; the WDC to figure out which head/track/cylinder a logical offset was on.
;==============================================================================
	IFD XT_SUPPORTED
G1.0101:
		bra	XTSendCommand
	ENDC

;==============================================================================
; A previous transfer command completed OK.  Target is requesting data out now.
; All even length transfers are performed using DMA mode and the transfer count
; register (so we know how much was done if the command is aborted).  If an odd
; byte is left over at the end of the DMA transfers we will use the single byte
; transfer mode and jam the data byte directly into the WDC data register. This
; is nescessary because the DMA engine is word oriented.
;==============================================================================
G1.1000		iprintf <'g1.1000'>
		clr.b	st_LastPhase(a5)	we're in a data phase
		movea.l	cb_LinkedCmd(a3),a1	and corresponding SCSICmd

		move.l	scsi_Length(a1),d0	get length left to do
		sub.l	scsi_Actual(a1),d0	by subtracting what's done
		bne.s	NotPaddedOut

; twit caller didn't expect this many bytes to go out, transmit zeros
	printf <'SCSI: transferring %ld pad bytes out\n'>,d0
	printf <'scsi_Length = %ld\n'>,scsi_Length(a1)
	printf <'scsi_Actual = %ld\n'>,scsi_Actual(a1)
		move.b	#PAD_LAST,st_LastPhase(a5)	what we're doing
		move.b	#$00,d0
		bra	SCSIPutByte
		rts

; there's some data left to transfer, do some tests to see what mode we use
NotPaddedOut	btst.l	#0,d0			is this an odd length xfer ?
		beq.s	20$			nope, do normal DMA xfer
		subq.l	#1,d0			get rid of the odd byte
		bne.s	20$			some work left to do

; We're left with a single byte to send so we'll do it in single byte mode.
; Also comes back to here if the source data address is on an odd boundary.
; The WDC has interrupted us because a REQ is pending so we should send the
; data byte through the WDC data register right away using a TRANSFER_INFO
; command with the single byte transfer bit set to 1.
10$		addq.l	#1,scsi_Actual(a1)	one more to actual count
		movea.l	cb_WData(a3),a1		get data address
		addq.l	#1,cb_WData(a3)		and bump the data pointer
		move.b	(a1),d0			fetch byte to send
		bra	SCSIPutByte		and send it

; before doing DMA make sure address and length is OK (may translate virtual)
20$		move.l	cb_WData(a3),d1		get source data pointer
		bsr	CheckPreDMA
		tst.b	cb_Programmed(a3)	programmed I/O needed ?
		beq.s	30$			nope, DMA is OK

; something exceeds the capabilities of the DMAC, so we're using programmed I/O
		add.l	d0,cb_WData(a3)		bump the ptr for next time
		add.l	d0,scsi_Actual(a1)	and update the actual count
		movea.l	d1,a0			initialise ptr for pgmd I/O
		bra	SCSIPutBytes		and send the bytes

; we have some data left to transfer in DMA mode so set up the DMA chip for
; output to a SCSI unit with interrupts enabled (we only see SCSI interrupts)
30$	IFD A590_A2091_ONLY
		tst.b	st_TerminalCount(a5)	do we need Terminal Count?
		bne.s	40$			if so, no flush
	ENDC
		; flush ok
		move.b	#DMAF_PMODE!DMAF_INTENA!DMAF_DDIR,CNTR(a4)
		bra	DoDataXFER		common code (at end of G1.1001)

; must use terminal count if the DMA doesn't support the Flush trickery
	IFD A590_A2091_ONLY
40$	move.b	#DMAF_TCE!DMAF_PMODE!DMAF_INTENA!DMAF_DDIR!DMAF_XTEOP,CNTR(a4)
	bra	DoDataXFER		common code (at end of G1.1001)
	ENDC

;==============================================================================
; A previous transfer command completed OK.  Target is requesting data in now.
; All even length transfers are performed using DMA mode and the transfer count
; register (so we know how much was done if the command is aborted).  If an odd
; byte is left over at the end of the DMA transfers we will use the single byte
; transfer mode and get the data byte directly from the WDC data register. This
; is nescessary because the DMA engine is word oriented.
;==============================================================================
G1.1001		iprintf <'g1.1001'>
		clr.b	st_LastPhase(a5)	we're in a data phase
		movea.l	cb_LinkedCmd(a3),a1	and corresponding SCSICmd

		move.l	scsi_Length(a1),d0	get length left to read
		sub.l	scsi_Actual(a1),d0	by subtracting what's done
		bne.s	NotPaddedIn		some data left to go

; twit caller didn't expect this many bytes to come in, just eat them up
	printf <'SCSI: transferring pad %ld bytes in\n'>,d0
	printf <'scsi_Length = %ld\n'>,scsi_Length(a1)
	printf <'scsi_Actual = %ld\n'>,scsi_Actual(a1)
		move.b	#PAD_LAST,st_LastPhase(a5)	what we're doing
		bra	SCSIGetByte		fetch a byte (and trash it)

; there's some data left to transfer, do some tests to see what mode we use
; V37, if CachePreDMA caused us to split a block transfer across different
; addresses we must make sure that DMA is flushed and stopped before attempting
; to start it all up again.
NotPaddedIn	btst.l	#0,d0			is this an odd length xfer ?
		beq.s	20$			nope, do normal DMA xfer
		subq.l	#1,d0			get rid of the odd byte
		bne.s	20$			some work left to do

; We're left with a single byte to read so we'll do it in single byte mode.
; Also comes back to here if the destination address is on an odd boundary.
; The WDC has interrupted us because a REQ is pending so we should read the
; data byte through the WDC data register right away using a TRANSFER_INFO
; command with the single byte transfer bit set to 1.
10$		bsr	SCSIGetByte		fetch the byte of data
		tst.w	d1
		beq.s	15$			didn't get the data
		addq.l	#1,scsi_Actual(a1)	one more to actual count
		movea.l	cb_WData(a3),a1		get data address
		move.b	d0,(a1)+		store and bump pointer
		move.l	a1,cb_WData(a3)		save the bumped pointer
15$		rts

; before doing DMA make sure address and length is OK (may translate virtual)
20$		move.l	cb_WData(a3),d1		get destination address
		bsr	CheckPreDMA
		tst.b	cb_Programmed(a3)	programmed I/O needed ?
		beq.s	30$			nope, DMA is OK

	printf <'Using programmed IO, size = %ld'>,d0
; something exceeds the capabilities of the DMAC, so we're using programmed I/O
		add.l	d0,cb_WData(a3)		bump the ptr for next time
		add.l	d0,scsi_Actual(a1)	and update the actual count
		movea.l	d1,a0			initialise ptr for pgmd I/O
		bra	SCSIGetBytes		and get the bytes

; we have some data left to transfer in DMA mode so set up the DMA chip for
; input from a SCSI unit with interrupts enabled (we only see SCSI interrupts)
30$	IFD A590_A2091_ONLY
		tst.b	st_TerminalCount(a5)	do we need Terminal Count?
		bne.s	40$			if so, no flush
	ENDC
		; flush ok
		move.b	#DMAF_PMODE!DMAF_INTENA,CNTR(a4)

; must use terminal count if the DMA doesn't support the Flush trickery
	IFD A590_A2091_ONLY
		bra.s	DoDataXFER

40$		move.b	#DMAF_TCE!DMAF_PMODE!DMAF_INTENA!DMAF_XTEOP,CNTR(a4)
	ENDC 

; this code is common to both read and write, so we call it from the write code
DoDataXFER	move.l	d1,SACH(a4)		set source data pointer
		add.l	d0,cb_WData(a3)		bump the ptr for next time
		add.l	d0,scsi_Actual(a1)	and update the actual count

; Yet another DMA flush fix.  It seems that we must enable Terminal Count for
; the flush logic to work properly.  I'm setting WTC to the maximum value (2M)
;	IFD DMA_FLUSH_OK
;		move.l	#$ffffff,WTCH(a4)
;	ENDC DMA_FLUSH_OK

; if we're using terminal count then we're required to use WTCH too
	IFD A590_A2091_ONLY
		tst.b	st_TerminalCount(a5)	do we need Terminal Count?
		beq.s	10$

		move.l	d0,d1			stick word count in WTCH
		lsr.l	#1,d1
		move.l	d1,WTCH(a4)
10$
	ENDC

		move.b	#1,st_DMAGoing(a5)	flag that DMA is running
		move.b	#0,SDMA(a4)		DMA is now waiting to go

;	printf <'Setting transfer to %ld'>,d0
		move.l	d0,-(sp)		set up transfer count in WDC
		PUTREG	1(sp),TRANSFER_MSB
		PUTREG	2(sp),TRANSFER_MB
		PUTREG	3(sp),TRANSFER_LSB
		addq.l	#4,sp
						; this is byte-acked DMA
		PUTREG	#WDCF_DMA,CONTROL	using DMA mode for data xfer
		PUTREG	#wd_TRANSFER_INFO,COMMAND	issue transfer command
		rts

;==============================================================================
; The target is requesting the next byte of the command block (a previous
; transfer command completed OK).  We can't use DMA for this so I'm going to
; send multiple bytes using the SCSIPutBytes routine.  CmdActual is fixed up
; if we get an unexpected phase interrupt after sending this command block.
;==============================================================================
G1.1010		iprintf <'g1.1010'>
		move.b	#1,st_LastPhase(a5)	we're in command phase
		movea.l	cb_LinkedCmd(a3),a0	and the direct scsi_Cmd
		move.w	scsi_CmdLength(a0),d0	get length to send
		move.w	d0,scsi_CmdActual(a0)	make it actual (may be altered)
		ext.l	d0
		movea.l	cb_WCommand(a3),a0	get command block pointer
		bra	SCSIPutBytes		and send the bytes

;==============================================================================
; The target has entered the status phase and wants to send us a status byte
; for the command just completed.  Since we're only ever expecting a single
; status byte we'll store the data at cb_WStatus but never bump the pointer.
; We'll be using programmed I/O to fetch this byte over the SCSI bus too.
;==============================================================================
G1.1011:
		iprintf <'g1.1011'>
; New addition:  The WD33C93A has a problem where the interrupt for the
; command complete message comes in before the status byte has been fetched.
; There doesn't seem to be a workaround so I'm changing this to do a
; Resume Select and Transfer which will transfer the status byte and the
; command complete message and give a Select and Transfer complete interrupt
; instead.
		PUTREG	#$46,COMMAND_PHASE	status fetch imminent
		PUTREG	#wd_SELECT_TRANS,COMMAND	restart sel and trans
		rts
;		movea.l	cb_WStatus(a3),a1	fetch status storage pointer
;		bsr	SCSIGetByte		transfer the byte
; no need to test here (at least I have never had a bad command int on status)
;		tst.w	d1			did we get it ?
;		beq.s	10$			nope
;		move.b	d0,(a1)			and save it
;	FIX! if this code is re-enabled, it must match the g1.0110 code
;	concerning sync and check_condition!
;10$		rts

;==============================================================================
; A previous transfer completed OK and the target wants us to send it a message
; The message to be sent is held in cb_MessageOut of the current command while
; cb_MsgOutLen tells us how much is to be sent.  We have to use SCSIPutBytes
; because all of the message bytes must be contained within the same assertion
; of ATN.  Transferring single bytes would only have ATN asserted on the first
; byte of an extended message.  We don't affect the message out pointers.
;
; We also check here if we want to send a Sync message and haven't yet.  If
; so, we tack on the sync message to the (probable) identify.  Target should
; go MsgIn, and send a response, then continue on it's way.
;
; SCSI-2 5.5 (and table 5-2) show that identify doesn't require us to negate
; ATN after the message (Sync messages do).  We'll make sure we only add them
; to identify messages.
;==============================================================================
G1.1110:	iprintf <'g1.1110'>
		; Check for Sync OK to use
		move.l	hu_Addr(a2),a0
		tst.b	ha_DoneSync(a0)		initially 0
		bne.s	1$
		tst.b	st_SendSync(a5)		Are we initing Sync negotiation?
		beq.s	1$			no - won't get here again

		; make sure we can add it to this message
		movea.l	cb_MsgOutPtr(a3),a0	fetch next message byte ptr
;	IFD DEBUG_CODE
;	moveq	#0,d0
;	moveq	#0,d1
;	move.b	(a0),d0
;	move.w	cb_MsgOutLen(a3),d1
;	printf <'bar %lx(%ld)'>,d0,d1
;	ENDC
		tst.b	(a0)			only add to identify msgs
		bpl.s	1$			$80-$ff are identify msgs
		; this test is probably only paranoia...
		cmp.w	#1,cb_MsgOutLen(a3)	is that all?
		bne.s	1$			no, probably has sync already

		; send our Sync message.  Clear SendSync so we don't try again.
		move.l	hu_Addr(a2),a0
		move.b	#1,ha_DoneSync(a0)	don't try again
		move.b	#1,ha_SentSync(a0)	so we know we started this
		bsr	AddSyncMsg		set up MsgOut with Sync msg

1$		movea.l	cb_MsgOutPtr(a3),a0	fetch next message byte ptr
		move.w	cb_MsgOutLen(a3),d0	how big is the message ?
		cmpi.w	#1,d0			is it single byte ?
		beq.s	NotSync			yep, do it

; if this was a multi byte message out, then it's a sync transfer reply and we
; should use the negotiated value (probably less than the targets) right after
; we have sent the message.  Target will immediately switch to new values.
; We must not commit to the new sync value until the target has ok'd it!
	printf <'SCSI: sent sync xfer msg\n'>
;	moveq.l	#-1,d1
;10$	nop			this was for Micropolis, not needed now
;	nop
;	dbra	d1,10$
		ext.l	d0			***fix for new SCSIPutBytes
		bsr	SCSIPutBytes		no, use multi byte xfer
	IFD DEBUG_CODE
		tst.l	d0
		beq.s	15$
		printf <'ERROR sending msg: %ld(+1?) bytes not transferred'>,d0
15$
	ENDC
		move.l	hu_Addr(a2),a0
		tst.b	ha_SentSync(a0)		did we initiate?
		beq.s	20$			no, we're responding - done
		rts				target will respond w/MsgIn
20$
SYNCDELAY EQU $1000
	move.w	#SYNCDELAY,d0
30$	move.b	_ciaa+ciapra,d1			>= 1us per access
	dbra	d0,30$

		moveq	#0,d1
		move.l	hu_Addr(a2),a0
		move.b	hu_Unit(a2),d1		store new SyncValue in array
		move.b	ha_SyncNegotiated(a0),st_SyncValues(a5,d1.w)
		bra	SetTransfer

NotSync		move.b	(a0)+,d0		fetch the byte
		bra	SCSIPutByte		send it to the target

;==============================================================================
; AssertATN()
;
; Does just that.  There should be a target connected before calling though.
;==============================================================================
AssertATN	PUTREG	#wd_ASSERT_ATN,COMMAND	issue an assert ATN command
		rts

;==============================================================================
; MessageReject( unit )
;		  a0
;
; Asserts ATN and initialises the MessageOut buffer of the given command block
; ready for the next message out request when the Message Reject will get sent.
;==============================================================================
MessageReject	bsr.s	AssertATN		yoohoo, we have a message 4 u
		move.b	#$07,cb_MessageOut(a3)	this message byte
		move.w	#1,cb_MsgOutLen(a3)	message is this long
		lea.l	cb_MessageOut(a3),a0
		move.l	a0,cb_MsgOutPtr(a3)	initialise the pointer
		rts

;==============================================================================
; A previous transfer completed OK, the target is now requesting a message in
; phase.  This is a biggie.  We support quite a lot of the SCSI messages so
; we use a small dispatch table to do the appropriate things.  Some of these
; messages would not be received after a transfer command (Identify for one)
; but we call this code for all the message in phases so we include them all
; here.  Have to be careful here because if we are about to receive an Identify
; then the unit in the RunningUnit slot could be the wrong one and may need
; to be exchanged for a different logical unit (though physical is the same)
;
; When this routine has completed, we are guaranteed to get a transfer paused
; with ACK asserted int next.  Since all the screwball stuff is handled here
; there will be nothing to do other than negating ACK.  A parity check is also
; performed and if a message byte is bad, this fact is flagged and all other
; message bytes are just wasted until we perform a message out phase. (We'll
; have asserted ATN when we got the bad byte).
;
; Extended messages are handled a little wierdly. When we get the first byte
; of an extended msg, we'll detect that not all bytes have come in (cb_MsgInLen
; will still be set to 1) so we'll set cb_MsgInLeft to -1 which makes the top
; of this routine interpret the next message byte as the number to follow.
;
; Normally, except during the actual reception of a message or extended 
; message, cb_MsgInLeft will be 1.  This routine after handling any message
; resets it to 1 for the next message that comes along.
;
; All message handlers are entered with a0=unit.  Identify is
; additionally entered with d0=Identify message
;
; We want to avoid excessive g2.0000 interrupts (mainly the signals and
; task switches, which kill us if other tasks are around).
; Since we need to reject (or otherwise respond with ATN before dropping
; ACK, like for Sync response), we'll test a global set by the interrupt
; routine on receipt of a g2.0000 interrupt.  If set (g2.0000 has happened),
; we'll negate ACK (after having decided on the fate of the message).  If
; not set, we'll indicate that the interrupt handler should signal us when
; it comes in.  NOTE: this test and setting of the flag to the int routine
; do NOT have to be done under disable IF the setting of the flag is done
; first, and the test afterwards.  
;==============================================================================
G1.1111:	iprintf <'g1.1111'>
		; don't signal on g2.0000 interrupts
		bsr	SCSIGetByte		fetch the message byte
		tst.w	d1			did it come in OK ?
		bne.s	5$			yep
		bra	MsgInExit		got a bad command interrupt

5$		tst.b	cb_MsgParity(a3)	was parity already bad ?
		bne	MsgInExit		already bad, exit immediately

		btst.b	#WDCB_PE,SASR(a4)	was there a msg parity error
		beq.s	ParityOK		nope, carry on as normal

; a message parity error occured, flag it and assert ATN to let the target
; know which byte the error occured on.  We'll also set up the MsgOutPtr on
; the current command block ready to send a Message Parity Error message
; We also re-initialise the Message In buffers for the next message.

		move.b	#-1,cb_MsgParity(a3)	flag that an error occured
		tst.b	st_ParityCheck(a5)	are we checking parity
		bne.s	ParityOK		nope, ignore it

		bsr	AssertATN		and assert ATN on this byte
		lea.l	cb_MessageOut(a3),a0	initialise message out
		move.b	#$09,(a0)		to send Message Parity Error
		move.l	a0,cb_MsgOutPtr(a3)
		move.w	#1,cb_MsgOutLen(a3)
		bra.s	ResetMsgIn		reset message in pointers too

; didn't get any errors so store the message at the next point in msg buffer
; the normal case here is this is the only byte (no extended message)
ParityOK	movea.l	cb_MsgInPtr(a3),a0	fetch next message pointer
;	printf <'got msg byte $%lx ($%lx,$%lx)'>,d0,a0,a3
		move.b	d0,(a0)+		store in message area
		move.l	a0,cb_MsgInPtr(a3)	save the new message ptr
		addq.w	#1,cb_MsgInLen(a3)	and bump the current msg len
		tst.w	cb_MsgInLeft(a3)	are we fetching Extended msgs ?
		bpl.s	10$			no, do the normal stuff

; we just received the length byte of an extended message.  Use it to set up
; a new value for MsgInLeft so we expect the right amount of message bytes
		ext.w	d0
		move.w	d0,cb_MsgInLeft(a3)	how many more we're expecting
		bra.s	MsgInExit

; we're not doing anything special so decrement cb_MsgInLeft and handle if 0
10$		subq.w	#1,cb_MsgInLeft(a3)	one less byte to expect
		bne.s	MsgInExit		we need more bytes

; we've received all message bytes for this message in phase.  call a handler.
		clr.w	d0			use whole word for indexing
		move.b	cb_MessageIn(a3),d0	fetch first message byte
		bpl.s	40$			its a normal message type
		bsr	IdentifyIn		identify after reselection
		bra.s	MsgInDone		reset for next message in

; the message we are about to fetch is definitely for the currently active unit
40$		cmpi.b	#$0c,d0			is message in range
		ble.s	50$			yes, dispatch to msg handler
		bsr	MessageReject		no, arbitrarily reject this msg
		bra.s	MsgInDone

; the message was for the current unit and was a valid message byte
50$		lsl.w	#1,d0			accessing table of word offsets
		move.w	Msgs(pc,d0.w),d0
		jsr	Msgs(pc,d0.w)		call the right routine
		tst.w	cb_MsgInLeft(a3)	make sure not an extended msg
		bmi.s	MsgInExit		extended, more bytes to come

; This message in phase has been completed, reset pointers ready for the next
MsgInDone	clr.b	cb_MsgParity(a3)	no parity errors now
ResetMsgIn	lea.l	cb_MessageIn(a3),a0	reset the msg in buffers
		move.l	a0,cb_MsgInPtr(a3)
		move.w	#1,cb_MsgInLeft(a3)
		clr.w	cb_MsgInLen(a3)

; reset the hold on g2 interrupt signalling, and drop ack if one had come in
; all g1.1111 exits must come here!
MsgInExit:
		; delay in hopes that the g2.0000 int will come in
		; actually makes things much faster, avoids task switch
		moveq	#40,d0			around 64 us.
		bra.s	4$			avoid cia if possible
3$		nop				doesn't hurt, really
		nop
		move.b	_ciaa+ciapra,d1		to force it to take time
4$		btst.b	#STB_IgnoredG2,st_Flags(a5)	did the int come in??
		dbne	d0,3$

		bclr.b	#STB_NoSignalG2,st_Flags(a5) if one happens, signal me
;	printf <'Signal on g2.0000'>
		btst.b	#STB_IgnoredG2,st_Flags(a5)	ah, we saw it already
		beq.s	1$
		bsr	G2.0000			handle it directly
		bclr.b	#STB_IgnoredG2,st_Flags(a5)	reset for next time
1$		rts				can't do anything else now

; simple word offset table to call the correct routine based on a message #
Msgs		DC.W	CmdComplete-Msgs	0 command complete
		DC.W	Extended-Msgs		1 extended message follows
		DC.W	SaveData-Msgs		2 save data pointer
		DC.W	RestorePtrs-Msgs	3 restore pointers
		DC.W	Disconnect-Msgs		4 disconnect
		DC.W	MessageReject-Msgs	5 initiator detected error
		DC.W	MessageReject-Msgs	6 abort
		DC.W	Rejected-Msgs		7 message reject
		DC.W	MessageReject-Msgs	8 no operation
		DC.W	MessageReject-Msgs	9 message parity error
		DC.W	LCmdComplete-Msgs	a linked command complete
		DC.W	LCmdComplete-Msgs	b linked cmd complete with flag
		DC.W	MessageReject-Msgs	c bus device reset


;------------------------------------------------------------------------------
; IdentifyIn( message, unit)
;		d0	a2
;
; a target re-selected us and we marked the first physical unit we could find
; that matched the source ID on reselection.  It's possible that there are
; many logical units at that physical address so the Identify message we just
; received will be used to ensure that we really picked up the correct unit
; to be made active.  If we were wrong, then we'll fix the mistake here.
;------------------------------------------------------------------------------
IdentifyIn	andi.b	#$07,d0			mask off LUN bits in message
		cmp.b	hu_LUN(a2),d0		did we get the correct one ?
		bne.s	10$			no, find the one we want
		rts


; OOPS! we made the wrong unit active when we got an earlier re-selection so
; attempt to find the logical unit that the target is talking about.  If we
; find it then the current RunningUnit will go back on the WorkingUnits queue
; and the one we found will be made the new RunningUnit.  If we don't find
; it then the target screwed up on the identify so we'll reject the message.
10$		move.b	d0,d1			stash the LUN
		move.b	hu_Unit(a2),d0		physical was correct
		bsr	FindWorking		see if we can find this unit
	printf <'SCSI: adjusted to unit at 0x%lx\n'>,d0
		tst.l	d0
		beq	MessageReject		didn't find it, reject Identify

; we found the unit we really wanted so make that one the running unit instead
; The incorrectly chosen unit must go back on the WorkingUnits queue because
; that's where we got it from in the first place.  Another reselect will occur
; for that unit when it's current command has completed.
		movea.l	a2,a1			put old one on WorkingUnits
		move.l	d0,a2			new runningunit
		move.l	d0,st_RunningUnit(a5)	it's running (connected) now
		move.b	#UNIT_WORKING,hu_QueueType(a1)
		lea.l	hu_SCSIQueue(a1),a1	SCSI list node for linkage
		lea.l	st_WorkingUnits(a5),a0	put back on WorkingUnits queue
		ADDHEAD				will probably reselect quickly

		move.b	#UNIT_RUNNING,hu_QueueType(a2)
		move.b	#UNIT_GOT_ERROR,hu_WhatNext(a2)	no disconnect w/o msg

		movea.l	hu_CurrentCmd(a2),a3	restore working ptrs
		move.l	cb_SData(a3),cb_WData(a3)
		move.l	cb_SCommand(a3),cb_WCommand(a3)

		lea.l	hu_SCSIQueue(a2),a1	remove from WorkingUnits queue
		REMOVE
		rts

;------------------------------------------------------------------------------
; "Command complete"  we'll accept this message and mark the unit for moving
; onto the WaitingUnits queue when the disconnect occurs
;------------------------------------------------------------------------------
CmdComplete
		move.b	#UNIT_WAITING,hu_WhatNext(a2)	all completed
		rts

;------------------------------------------------------------------------------
; "Extended message follows"  We check cb_MsgInLen to see if we only got the
; first byte of this message.  If we did, then we'll set cb_MsgInLeft to -1
; which forces the Message In handler to interpret the next message byte as a
; count of the remaining message bytes to be sent.  If cb_MsgInLen is greater
; than 1 then we've already done this and have a complete extended message in
; cb_MessageIn.  The only extended message we support is synchronous transfer.
;------------------------------------------------------------------------------
Extended	move.w	cb_MsgInLen(a3),d0	how much message is there ?
		cmpi.w	#1,d0
		bne.s	GotExtended		all of it
		move.w	#-1,cb_MsgInLeft(a3)	flag that next byte is a count
		rts				and return to main routine

GotExtended	move.b	cb_MessageIn+2(a3),d0	get extended message code
		cmpi.b	#1,d0			only support sync transfer msgs
		bne	MessageReject		assert ATN and reject this msg

; we got a Synchronous Transfer Request from the target.  If they're good we'll
; use the values supplied by the target which will remain in effect for this
; unit until BUS DEVICE RESET or a hard reset condition occurs.  In this setup
; a SCSI bus cycle time is 100-150ns, we'll assume 100 so we err on the safe
; side.  Allowable WDC transfer periods using DMA are:-
;
; 3=200ns   4=300ns   5 = 400ns   6=500ns   7=600ns
;
; REQ/ACK offset can range from 0 (asynchronous) to 4

;==========================================================================
; REJ - The SCSI bus cycle time is ~105ns (104 actually) for 14Mhz input,
; 				   ~140ns (139 actually) for 7Mhz input.
; From page 14, wd33c93a manual:
; 14Mhz: 2=210ns  3=315ns   4=420ns   5=525ns   6=630ns   7=735ns
; 7Mhz:  2=280ns  3=420ns   4=560ns   5=700ns   6=840ns   7=980ns
;
; transfer time of #2 (fastest) would give 4.8MT/s for 14Mhz, 3.6MT/s for 7Mhz.
; Steve's values were 3.2MT/s for 14Mhz, 2.4MT/s for 7Mhz (TPx of %011).
;
; For the 33c93 (not A), you CANNOT use a transfer time of 2 for SCSI.
; The 33c93 also had no clock divisor.  The offset was 0 to 4.
;
; The 33c93A supports offsets of 0 (asynch) to 12.
;
; minimum transfer period is Tcyc-10 + Tcyc-25, or 175ns for 14Mhz,
; 						   245ns for 7Mhz.
; (from WD 33c93A manual, pages 57-59).  Doesn't really matter, min is really
; 2*CLOCK_PERIOD (210 or 280ns).
;
; The SCSI-2 spec says that req/ack must be 90ns asserted and 90ns negated,
; which implies a min cycle of 180ns (5.5MT/s).  I suspect a cable skew or
; two is being slipped in to bring it to (effective) 200ns (5 MT/s).  The
; ENDL SCSI-2 Bench Reference says 200ns.
;
; The SCSI-2 spec (in 5.6.21) states first that data values not required to
; be changed be returned unchanged, but second states that each sends
; to the other using the values received from the other, which implies that
; you can always return the fastest values you can take.  This sounds better.
; We still need to parse the incoming message to set up our output rate.
; Update: I'm wrong, or the quantum LPS gets it wrong.  In any case, if I
; use my values, it barfs.  So we'll be safe and use their values in the
; return message.
;
; We can't assume the Sync negotiation was successful until the target goes
; to something other than msg in for a reject message (if he started it).
;
	IFD SYNC_DEBUG
	printf <'SCSI: got sync xfer req (0x%lx)\n'>,cb_MessageIn+2(a3)
	ENDC
		clr.w	cb_MsgOutLen(a3)	so it doesn't think one's there
		bsr	AddSyncMsg		leaves a0 alone!!!!
		; returns address of sync message in a0!!!!
	IFD SYNC_DEBUG
	printf <'default sync reply is 0x%lx'>,2(a0)
	ENDC
		; get Addr structure pointer... a1 unused
		move.l	hu_Addr(a2),a1

		; set up our preferred sync values
		move.b	st_MinXferPeriod(a5),d0
		move.b	cb_MessageIn+3(a3),d1
		cmp.b	st_MinMsgPeriod(a5),d1	can we handle it ?
		bls.s	CheckOffset		nope, use our values
	IFD SYNC_DEBUG
	andi.l	#$ff,d0
	andi.l	#$ff,d1
	printf <'our period too small, using %ld'>,d1
	printf <'MinXferPeriod is %ld'>,d0
	ENDC
		moveq	#0,d0			make sure upper bits are 0
		move.b	d1,d0			get transfer period/4

		move.b	d0,3(a0)		agree to that xfer period
		lsl.w	#2,d0			(value * 4) = X ns
		add.w	#CLOCK_PERIOD-1,d0	force it to round up the calc
		divu.w	#CLOCK_PERIOD,d0	our clock is 7.16 or 14.32 MHz
		; rounded up, so we won't transfer faster than they can handle

		; FIX? should check for result >= 8!!!

		; xfer period is in d0
CheckOffset
	IFD SYNC_DEBUG
	andi.l	#$ff,d0
	printf <'final period TPx value %ld\n'>,d0
	moveq	#0,d1	; for later...
	ENDC
		lsl.b	#4,d0			move period to upper nybble
		move.b	st_MaxOffset(a5),d1	default offset
		cmp.b	cb_MessageIn+4(a3),d1	is offset OK ?
		bls.s	GotOffset		Yes, ours <= theirs (unsigned)
	IFD SYNC_DEBUG
	printf <'Our offset %ld'>,d1
	ENDC
		move.b	cb_MessageIn+4(a3),d1	No, ours > theirs - use theirs
	IFD SYNC_DEBUG
	printf <'   is too big, using %ld'>,d1
	ENDC
		move.b	d1,4(a0)		agree to theirs

GotOffset:	or.b	d1,d0			merge REQ/ACK offset into TPx.
		move.b	d0,ha_DoneSync(a1)	flag sync negotiated (never 0)
	IFD SYNC_DEBUG
	printf <'SCSI: hu_SyncValue = 0x%lx, sending back 0x%lx'>,d0,2(a0)
	ENDC

		; if we started it, set up the SYNC_TRANSFER register
		tst.b	ha_SentSync(a1)
		beq.s	SyncResponse		we didn't start it

	move.w	d0,-(sp)
	move.w	#SYNCDELAY,d0
10$	move.b	_ciaa+ciapra,d1			>= 1us per access
	dbra	d0,10$
	move.w	(sp)+,d0

		; we received the sync message
		clr.w	cb_MsgOutLen(a3)	no message to send
		clr.b	ha_SentSync(a1)		in case he sends one
		moveq	#0,d1
		move.b	hu_Unit(a2),d1		store new SyncValue in array
		move.b	d0,st_SyncValues(a5,d1.w)
		PUTREG	d0,SYNC_TRANSFER	set up WDC sync value
		rts

SyncResponse	; we've done a sync negotiation
		move.b	#2,ha_DoneSync(a1)	don't start one
		move.b	d0,ha_SyncNegotiated(a1) remember what we negotiated

		; FIX! WHY did steve have spin-loops here???!!!
		; steve had moveq #-1,dn, N$, nop, nop, dbra dn,N$ here
		; quantums LOCK UP if I don't do this!!!!!!! REJ

		; $1000 is a comprimise.  I don't want it to take a really
		; long time on slow 68000's.  That should give close to
		; 1/100th second even on a fast CPU.

	move.w	#SYNCDELAY,d0
10$	move.b	_ciaa+ciapra,d1			>= 1us per access
	dbra	d0,10$
		bsr	AssertATN		we have a message pending
	move.w	#SYNCDELAY,d0
20$	move.b	_ciaa+ciapra,d1			>= 1us per access
	dbra	d0,20$

		; steve had moveq #-1,dn, M$, nop, nop, dbra dn,M$ here

		; the target will change to MsgOut, and the message we set
		; up will be sent.
		; the msg send code sets the SYNC_TRANSFER reg after sending
		; any multi-byte message response
		rts

AddSyncMsg:	; Assumes there may be a message in the buffer!  Len must
		; be set to the number of bytes in the buffer! (ALWAYS 1)
		; returns address of Sync message in a0
		; msg = extended msg, 3 bytes, sync msg, XX/4ns xfer, offset
	IFD SYNC_DEBUG
	printf <'adding sync message'>
	ENDC
		lea.l	cb_MessageOut(a3),a0	initialise message out
		add.w	cb_MsgOutLen(a3),a0	skip past existing msg if any
		add.w	#5,cb_MsgOutLen(a3)	how long message is

		move.b	#$01,(a0)+		extended msg
		move.b	#$03,(a0)+		3 bytes
		move.b	#$01,(a0)+		sync msg
		move.b	st_MinMsgPeriod(a5),(a0)+	message period
		move.b	st_MaxOffset(a5),(a0)		req/ack offset
		lea	-4(a0),a0		reset a0 for return
		; a0 is a return!
		rts

;------------------------------------------------------------------------------
; "Save data pointer" we'll accept this message and move the working data
; pointer into the saved data pointer in the current command block.  Does
; not affect hu_WhatNext as this is driven by the disconnect message.
; Only has to save the Data ptr (see SCSI-2 section 5.4).
;------------------------------------------------------------------------------
SaveData	move.l	cb_WData(a3),cb_SData(a3)	save data pointer
		rts

;------------------------------------------------------------------------------
; "Restore pointers"  restore previously saved pointers and accept the message
; Since we've already bumped the actual transfer count, we must adjust it back
; by the difference between the saved and working data pointers.
;------------------------------------------------------------------------------
RestorePtrs	move.l	cb_WData(a3),d0		how much difference
		sub.l	cb_SData(a3),d0

		movea.l	cb_SCSICmd(a3),a0	subtract difference from...
		sub.l	d0,scsi_Actual(a0)	..amount already done

		move.l	cb_SData(a3),cb_WData(a3)
		move.l	cb_SCommand(a3),cb_WCommand(a3)
		move.l	cb_SStatus(a3),cb_WStatus(a3)
		rts

;------------------------------------------------------------------------------
; "Disconnect"  accept this message and mark the unit for moving onto the
; WorkingUnits queue when a disconnect occurs.  We'll need at least one more
; reselection to complete the current command.  If the unit has already been
; marked with ht_WhatNext==UNIT_WAITING then we got a command complete already
; so this disconnect message shouldn't be here, must check if this is true.
;------------------------------------------------------------------------------
Disconnect	; printf <'Got a disconnect message\n'>
		move.b	#UNIT_WORKING,hu_WhatNext(a2)
		rts

;------------------------------------------------------------------------------
; "Message reject" the target rejected last message that we sent.  There aren't
; many messages we send that could be rejected, if it's not a Synchronous
; Transfer request that was rejected, we'll just ignore the condition anyway.
;------------------------------------------------------------------------------
Rejected	move.b	cb_MessageOut(a3),d0	what message was rejected ?
		bmi.s	WhoCares		get check condition if identify

		cmpi.b	#1,d0			was it our extended msg
		bne.s	WhoCares		nope, so ignore rejection
		move.b	cb_MessageOut+2(a3),d0	make sure correct extended msg
		cmpi.b	#1,d0			sync transfer request ?
		bne.s	WhoCares		nope, ignore rejection

; we sent a sync transfer request but the unit couldn't do it or support it so
; default to asynchronous mode with a REQ/ACK offset of 250-300ns
		moveq.l	#0,d0
		move.b	#$40,st_SyncValues(a5,d0.w)
		PUTREG	#$40,SYNC_TRANSFER	and set up WDC with this value
WhoCares	rts

;------------------------------------------------------------------------------
; "Linked command complete (might be with flag too)"
;
; A linked command has completed but the unit has remained selected ready for
; us to send the next command block.  Initialise everything ready for the next
; command phase, (ie. link to the next SCSIDirect command block).  This will
; have no effect on the hu_WhatNext flag (unit should remain connected anyway).
;
;	****** may have to handle the case of no linked command ******
; FIX!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
; If no linked command, send test unit ready (easy)?  Or just try to throw
; an ABORT message.
;------------------------------------------------------------------------------
LCmdComplete	movea.l	cb_LinkedCmd(a3),a0	fetch current SCSI command
		movea.l	scsi_NextLinked(a0),a0	and link to the next one
		move.l	a0,cb_LinkedCmd(a3)	this is the one we're using now

		move.l	scsi_Data(a0),cb_WData(a3)
		move.l	scsi_Command(a0),cb_WCommand(a3)
		clr.l	scsi_Actual(a0)		no data transferred yet
		clr.w	scsi_CmdActual(a0)	and no command either
		lea.l	scsi_Status(a0),a0	set up status area address
		move.l	a0,cb_WStatus(a3)	only one status byte
		move.l	cb_WData(a3),cb_SData(a3)	copy working ptrs...
		move.l	cb_WCommand(a3),cb_SCommand(a3)	...to saved pointers
		move.l	cb_WStatus(a3),cb_SStatus(a3)
		rts


;==============================================================================
; A transfer command (message in phase) paused with ack asserted.  This really
; means that we just fetched a message byte for the currently active unit.  If
; anything weird happened (Parity error or message was rejected) ATN will have
; already been asserted in the Message In handler.  All we have to do here is
; negate ACK to say we received the message byte and are ready for more stuff.
;==============================================================================
G2.0000		iprintf <'g2.0000'>
		PUTREG	#wd_NEGATE_ACK,COMMAND	issue a negate ack command
		rts

;==============================================================================
; All of these codes are for an aborted transfer (we used the abort command).
; Since I'm not doing this yet there's no need to support the interrupts either
;==============================================================================
G2.1000:
G2.1001:
G2.1010:
G2.1011:
G2.1110:
G2.1111:

;==============================================================================
; Invalid command was issued.  Gimme a break! I'll never issue bad commands :-)
;==============================================================================
G3.0000	printf <'BAD COMMAND INTERRUPT\n'>
		rts

;==============================================================================
; An unexpected disconnect caused the last command to terminate.  This will be
; for the current RunningUnit and its hu_WhatNext flag will probably be set to
; UNIT_GOT_ERROR by now (since a disconnect without a message wasn't expected)
; Therefore, it's reasonable to treat this the same as a normal disconnection.
;==============================================================================
G3.0001		bra	G4.0101			handle as a normal disconnect
	ENDC SCSI_SUPPORTED

;==============================================================================
; A timeout occured during select or re-select.  Since we're an initiator and
; we're using the timeout feature of the WDC, we can assume this to mean that
; a timeout occured on a selection.  The unit that this pertains to has not
; yet been moved off the WaitingUnits queue (it was waiting to be selected when
; this interrupt came in).  To make things easy, we'll move the unit off the
; WaitingUnits queue and into the Running slot and set hu_WhatNext to
; UNIT_TIMED_OUT.  We'll then call G4.0101 (disconnect occured) directly so
; it sends back the appropriate message to the original caller.
;
; This is also called by the XTSelect routine if it found there wasn't a unit
;==============================================================================
; we need this for at ide driver
FakeTimeout:
G3.0010		bsr	FakeSelect		make like select worked
		move.b	#UNIT_TIMED_OUT,hu_WhatNext(a2)	mark as timed out
		bra	FakeDisconnect		and handle like a disconnect

	IFD SCSI_SUPPORTED
;==============================================================================
; The logical address exceeded the disk boundaries.  Used by XT devices only.
;==============================================================================
	IFD XT_SUPPORTED
G3.0101:
		bra	XTAddressBad		abort current XT command
	ENDC

;==============================================================================
; An incorrect message/status or command byte was received (target mode only??)
;==============================================================================
G3.0111		rts				dunno how to handle this anyway

;==============================================================================
; The rest of these G3.xxxx codes mean that a data transfer with transfer count
; set to non-zero and SBT=FALSE was terminated because a different phase was
; requested by the target before the transfer count reached zero.  In all cases
; we just subtract the number left in the WDC transfer count register from the
; actual count in the SCSIDirect command and from the working address and call
; the correct G1.xxxx equivalent to carry on doing the next transfer phase.
;
; One case where an error may occur is if we just did the Command out phase.
; we were expecting to send more bytes than the target requested so we have to
; fix up scsi_CmdActual instead of the data pointers.  hu_LastPhase flags which
;==============================================================================
G3.1000		bsr.s	G3.PhaseChange
		bra	G1.1000			go do data out phase

G3.1001		bsr.s	G3.PhaseChange
		bra	G1.1001			go do data in phase

G3.1010		bsr.s	G3.PhaseChange
		bra	G1.1010			go do command phase

G3.1011		bsr.s	G3.PhaseChange
		bra	G1.1011			go do status phase

G3.1110		bsr.s	G3.PhaseChange
		bra	G1.1110			go do message in phase

G3.1111		bsr.s	G3.PhaseChange
		bra	G1.1111			go do message out phase

G3.PhaseChange	iprintf <'g3.phase change'>
		bsr	FlushDMA		make sure DMA finished
		moveq.l	#0,d0			get bytes left over
		GETREG	TRANSFER_MSB,d0		get most significant byte
		swap	d0			move to upper word
		GETREG	TRANSFER_MB,d0		get middle byte
		lsl.w	#8,d0			move to top of lower word
		GETREG	TRANSFER_LSB,d0		get least significant byte
		movea.l	cb_LinkedCmd(a3),a1	and corresponding SCSICmd

		move.b	st_LastPhase(a5),d1	what phase was terminated ?
		beq.s	10$			it was a data phase

		cmpi.b	#PAD_LAST,d1		were we eating bytes ?
		beq.s	20$			yep, so nothing to adjust

		sub.w	d0,scsi_CmdActual(a1)	we were transferring cmd bytes
		bra.s	20$

10$		sub.l	d0,scsi_Actual(a1)	subtract leftover from actual
		sub.l	d0,cb_WData(a3)		and adjust DMA address too
	IFD DEBUG_CODE
;	btst.b	#SCSIB_READ_WRITE,scsi_Flags(a1)
;	beq.s	1$
;	printf <'Write:'>
1$	printf <'WD says we have %ld bytes left (%ld done) of %ld'>,d0,scsi_Actual(a1),scsi_Length(a1)
	move.l	scsi_Command(a1),a0
	printf <'Command was $%lx'>,(a0)
	ENDC
20$		PUTREG	#0,TRANSFER_MSB		clear transfer count to be safe
		PUTREG	#0,TRANSFER_MB
		PUTREG	#0,TRANSFER_LSB
		rts

;==============================================================================
; We've been reselected by some unit.  Search the WorkingUnits queue and find
; the first physical that matches the WDC source ID register.  This may be the
; wrong logical unit but we'll fix this up when an identify message comes in
; and tells us which LUN we really wanted.  Normally, LUNS are 0 anyway.  The
; unit found is put into the RunningUnit slot in the hopes that we were right.
;
; To make life easier, we'll reset the WD sync register now.  All the
; G4.1MCI ints did this before anyways, and that was too late if the drive
; was very fast about setting up.  We don't care if this is the wrong LUN,
; since we have one set of sync values for each SCSI address.
;
; FIX! there's a problem lurking here with hu_SyncDone/etc for real live
; multi-LUN devices running sync!  We need an st_SyncDone[addr] array instead!
;==============================================================================
G4.0000:
	iprintf <'g4.0000'>
retrysiv	GETREG	SOURCE_ID,d0
		btst.b	#WDCB_SIV,d0		source ID better be valid
		beq.s	SIVBad			what the hell do we do now ?
		andi.b	#$07,d0			mask off other garbage
		moveq.l	#-1,d1			match first/any LUN
		bsr	FindWorking		see if we can find this unit
		move.l	d0,a2			always store in a2 as well
		move.l	d0,st_RunningUnit(a5)	it's running (connected) now
		beq.s	SIVBad			failed, SIV must be bad
		move.b	#UNIT_RUNNING,hu_QueueType(a2)
		move.b	#UNIT_GOT_ERROR,hu_WhatNext(a2)	no disconnect w/o msg

		bsr.s	SetTransfer

		movea.l	hu_CurrentCmd(a2),a3	restore working ptrs
		move.l	cb_SData(a3),cb_WData(a3)
		move.l	cb_SCommand(a3),cb_WCommand(a3)
	IFD DEBUG_CODE
	move.l	cb_LinkedCmd(a3),a1
	tst.l	scsi_Actual(a1)
	beq.s	1$
;	btst.b	#SCSIB_READ_WRITE,scsi_Flags(a1)
;	beq.s	1$
	printf <'reselect: %ld done of %ld'>,scsi_Actual(a1),scsi_Length(a1)
1$:
	ENDC

		lea.l	hu_SCSIQueue(a2),a1	remove from WorkingUnits queue
		REMOVE
		rts

; These are in here to handle a small bug in the WDC SCSI chip.  Sometimes
; the source id bit will not get set, a small delay seems to fix things up
SIVBad		moveq.l	#-1,d0
10$		dbra	d0,10$
	IFD DEBUG_CODE
		bra	retrysiv
	ENDC
	IFND DEBUG_CODE
		bra.s	retrysiv
	ENDC

;==============================================================================
; Whenever a target responds to selection or re-selects us, we have to set up
; the WDC into the correct transfer mode/timings for this unit.  Some devices
; don't support synchronous transfers so we'll use asynchronous mode.  Other
; devices do support it (via the messaging system) and we will have already
; determined the REQ/ACK offset for that unit and must store the value in the
; WDC SYNC_TRANSFER register before we attempt any DATA phase transfers. The
; synchronous mode applies to physical units not the individual LUNs !!!!!!
;==============================================================================
SetTransfer	iprintf <'g4.SetTransfer'>
		moveq.l	#0,d0
		move.b	hu_Unit(a2),d0
		move.b	st_SyncValues(a5,d0.w),d0
		PUTREG	d0,SYNC_TRANSFER	set sync xfer value
		rts


	IFD ADVANCED_FEATURES
;==============================================================================
; We've been reselected by some unit.  Search the WorkingUnits queue and find
; the first unit that matches the WDC source ID and data registers.  This int
; is only for the 33c93A part, and means that it fetched the identify message
; for us (it's in the data reg).  The unit found is put into the RunningUnit
; slot.
; Note: we know it's in the data reg, since we never use Select-And-Transfer.
; If we did, we'd have to check the status register to see which one we were
; doing, so we could fetch the message from Data or from Target LUN.
; It appears that if the message was fetched this way, we don't get a
; g2.0000 interrupt like we normally do.
;==============================================================================
G4.0001:
	iprintf <'g4.0001'>
retrysiv_a	GETREG	SOURCE_ID,d0
		btst.b	#WDCB_SIV,d0		source ID better be valid
		beq.s	SIVBad_a		what the hell do we do now ?
		andi.b	#$07,d0			mask off other garbage
		GETREG	DATA_REG,d1		has identify message in it
		andi.b	#$07,d1			mask off other garbage
		bsr	FindWorking		see if we can find this unit
		move.l	d0,a2			always store in a2 as well
		move.l	d0,st_RunningUnit(a5)	it's running (connected) now
		bne.s	good_unit
		bsr	MessageReject		failed, bad addr/unit
		; we come back so we can force ACK to be dropped - no g2.0000
		bra.s	drop_ack
good_unit:
	IFD DEBUG_CODE
;	moveq	#0,d0
;	moveq	#0,d1
;	move.b hu_Unit(a2),d0
;	move.b hu_LUN(a2),d1
	printf <'good addr/lun\n'>	; - %ld/%ld'>,d0,d1
	ENDC
		move.b	#UNIT_RUNNING,hu_QueueType(a2)
		move.b	#UNIT_GOT_ERROR,hu_WhatNext(a2)	no disconnect w/o msg

		bsr	SetTransfer

		movea.l	hu_CurrentCmd(a2),a3	restore working ptrs
		move.l	cb_SData(a3),cb_WData(a3)
		move.l	cb_SCommand(a3),cb_WCommand(a3)

		lea.l	hu_SCSIQueue(a2),a1	remove from WorkingUnits queue
		REMOVE

		; now drop ack to indicate message accepted or rejected
drop_ack:	bra	G2.0000			drops ack, shorter than inline

; These are in here to handle a small bug in the WDC SCSI chip.  Sometimes
; the source id bit will not get set, a small delay seems to fix things up
; probably not needed for the A part, but we'll keep it anyways
SIVBad_a	moveq.l	#-1,d0
10$		dbra	d0,10$
		bra	retrysiv_a
	ENDC ADVANCED_FEATURES

;==============================================================================
; A disconnect has occurred.  This is for the unit in the RunningUnit slot (it
; had better be anyway).  Based on the contents of hu_WhatNext we'll take the
; following actions:-
;
; UNIT_TIMED_OUT	we got a timeout during a selection so the unit was
;			made active anyway just so we could return the cmd
;			with a seltimeout error.
;
; UNIT_GOT_ERROR	an unexpected disconnect occured.  Consider this
;			catastrophic error and return the current command
;			with a bad failure error (whatever that is).
;
; UNIT_WORKING		we got a disconnect message earlier so this unit will
;			be doing a reselection later.  Hang it on WorkingUnits
;			but don't reply the command block yet.
;
; UNIT_WAITING		we got a command complete message earlier so the cmd
;			has completed and we can reply the command block.  If
;			there are more commands on this unit then it will be
;			added to the WaitingUnits queue else we'll forget it.
;
; Whichever of the above actions is taken, we'll attempt to select the next
; unit (which is at the head of the WaitingUnits queue) when we're finished.
;
; This is also called by the XT routines when a command has completed.
;==============================================================================
G4.0101	; printf <'A disconnect occured ... '>
	iprintf <'g4.0101'>
		bsr	FlushDMA		someone else is gonna use it
	ENDC SCSI_SUPPORTED

	; need this for AT ide drives - REJ
FakeDisconnect:
	IFD SCSI_SUPPORTED
		clr.b	st_SelectPending(a5)	selects are OK to do now
	ENDC
		movea.l	st_RunningUnit(a5),a1	get the unit that disconnected
		clr.l	st_RunningUnit(a5)	none are active now
		lea	0,a2			clear a2 as well
		move.b	hu_WhatNext(a1),d0	get status byte
		cmpi.b	#UNIT_WORKING,d0	destined for the Working queue?
		bne.s	SummatElse		no, must be something else

; this unit is doing a disconnect but will be reselecting the WDC later
	; printf <'intermediate\n'>
;	IFD DEBUG_CODE
;	add.l	#1,cb_NumDisconnects(a3)
;	ENDC
		move.b	d0,hu_QueueType(a1)	set the new queue type
		lea.l	st_WorkingUnits(a5),a0	adding to WorkingUnits queue
		lea.l	hu_SCSIQueue(a1),a1	SCSI list node for linkage
		ADDHEAD				will probably reselect quickly
;	IFD DEBUG_CODE
;	cmpi.b #1,st_WasteSpace(a5)
;	beq.s nowt
;	printf <'Another command is pending too....\n'>
;nowt	nop
;	ENDC
		bra	DoSelect		maybe select another unit

; all other disconnect types are terminal; we must reply the command block
; a3 points to hu_CurrentCmd of st_WorkingUnit in a1 still
SummatElse	; printf <'terminal\n'>
;	IFD DEBUG_CODE
;	cmp.l	#1,cb_NumDisconnects(a3)
;	ble.s	1$
;	printf	<'disconnects=%ld, flush=%ld'>,cb_NumDisconnects(a3),cb_NumFlush(a3)
;1$
;	ENDC
		move.l	a1,-(sp)		save unit pointer
		clr.b	cb_ErrorCode(a3)	assume no errors
		cmpi.b	#UNIT_GOT_ERROR,d0	really bad error ?
		bne.s	20$
		move.b	#HFERR_Phase,cb_ErrorCode(a3)	*** cop out error
		bra.s	CheckFlush
20$		cmpi.b	#UNIT_TIMED_OUT,d0	was it a timeout ?
		bne.s	CheckFlush
		move.b	#HFERR_SelTimeout,cb_ErrorCode(a3)

; if we did a DMA read or write op then we need to finish the cache management
CheckFlush:

	IFND BONUS
	IFND IS_IDE
		tst.b	cb_DidCacheStuff(a3)	did we do CachePreDMA() ?
		beq.s	NoDataFlush		nope, skip the tests

		move.l	cb_OrigCacheData(a3),a0	  get start address we used
		lea.l	cb_OrigCacheLength(a3),a1 point at length we used

		; KLUDGE to work around bug in 37.175-37.300: CachePostDMA
		; crashes on < 68020 (no MOVEC instruction).  However, it
		; doesn't if you set the NoModify bit (see CachePostDMA docs).
		moveq.l	#0,d0
		btst.b	#AFB_68020,AttnFlags+1(a6)
		bne.s	1$
		moveq.l	#DMAF_NoModify,d0
1$:
		jsr	_LVOCachePostDMA(a6)	do the stuff
	ENDC
	ENDC

NoDataFlush	move.l	a3,a1			get command ptr
		move.l	a2,a3			make a3 NULL as well
		jsr	_LVOReplyMsg(a6)	reply the command block
		movea.l	(sp)+,a1		retrieve the unit pointer
;	IFD DEBUG_CODE
;	subq.b #1,st_WasteSpace(a5)
;	ENDC

; we've replied the command so now we see if the unit should be forgotten
; about or added back to the end of the WaitingUnits queue.  If there are
; commands left on the hu_CmdList then we hang on to the unit, else we
; change its type to UNIT_QUIET and just forget it. (Not put on our queues)
		clr.b	hu_QueueType(a1)	assume we're forgetting it
		lea.l	hu_CmdList(a1),a0	are there any commands ?
		TSTLIST	a0
		beq	DoSelect		no, so just select another

	iprintf <'Got more commands, adding back to waitingunits\n'>
		move.b	#UNIT_WAITING,hu_QueueType(a1)  yes, go to waiting
		lea.l	st_WaitingUnits(a5),a0	adding to Waiting queue
		lea.l	hu_SCSIQueue(a1),a1	SCSI list node for linkage
		ADDTAIL
		bra	DoSelect		maybe select another unit

	IFD SCSI_SUPPORTED
;==============================================================================
; The rest of these G4.xxxx commands imply that a data/msg/cmd or status phase
; has been requested following connection.  Since all the fancy stuff was done
; when the reselection interrupt came in, we can treat these requests the same
; as if they were following a previously successful transfer command.  The only
; exception to this is setting up the WDC synchronous transfer register to
; match the unit that is now connected.  We'll do it for all phase requests.
; The same thing must be done if an identify comes in and we had the wrong unit
;
; The sync setup is now handled in g4.0000 (reslect) and g1.0001 (select).
; We could move these symbols to save 4 bytes each.
;==============================================================================
G4.1000		bra	G1.1000			data out request

G4.1001		bra	G1.1001			data in request

G4.1010		bra	G1.1010			command request

G4.1011		bra	G1.1011			status request

G4.1110		bra	G1.1110			message out request

G4.1111		bra	G1.1111			message in request

;==============================================================================
; length/address = CheckPreDMA( length, address, scsicmd )
;   d0	   d1			  d0	  d1	    a1
;
; Added 020/030/040 cache support.  Call CachePreDMA to maybe translate virtual
; addresses to physical ones and possibly shorten the length of a transfer if
; the chunk of virtual memory is spread over separate pieces of physical mem
; If CachePreDMA changes the length of a transfer then we switch unconditionally
; to programmed I/O.  This prevents problems with splitting block DMA across
; different adresses (the Boyer DMAC screws up when you try this).
;
; Folded in some of the other tests for programmed I/O to save doing them in
; both the read and write routines.  Transfers less than 256 bytes or to odd
; addresses get done with the CPU.  If we're using the older boyer DMAC then
; transfers to odd word addresses must be programmed too.
;
; It is important that cb_DidCacheStuff and cb_Programmed are cleared when
; the command block is received.  They are only set by this routine.
;
; This routine preserves a0/a1 but may modify d0 and d1 (length and address)
;==============================================================================
CheckPreDMA
	IFD KS_1_3
		; no need to do this for CachePostDMA - it uses cb_DidCache...
		cmp.w	#37,LIB_VERSION(a6)
		blt.s	NoCacheCalls		Not supported until 37.xxx
	ENDC
	IFND BONUS
		movem.l	a0/a1,-(sp)		save cmd and scsi pointers
		move.l	d0,-(sp)		stash length
		move.l	d1,-(sp)		setup address we are using
; printf <'checkpredma $%lx, %ld bytes, actual $%lx, cmd $%lx'>,d1,d0,scsi_Actual(a1),a1

		move.l	scsi_Actual(a1),d0	is this first time through ?
		bne.s	10$			yes, no flags needed (d0=0)

		; save original pointers for CachePostDMA - REALLY needs to
		; be handled by BeginIO, in which case this code (for the
		; non-continue case) goes away, since there will be no
		; non-continue case, and PostDMA will use the scsi_Data/Length
		; values.
		move.l	(sp),cb_OrigCacheData(a3) save start address
		move.l	4(sp),cb_OrigCacheLength(a3) and length we want to do
		bra.s	20$

10$		moveq.l	#DMAF_Continue,d0	no, we're continuing a request

20$		move.l	(sp),cb_CacheData(a3)	save start address
		move.l	4(sp),cb_CacheLength(a3)   and length we want to do
		move.b	#1,cb_DidCacheStuff(a3)	flag that we did cache stuff

		movea.l	(sp)+,a0		get address we are using
		movea.l	sp,a1			point to saved length
		jsr	_LVOCachePreDMA(a6)	set everything up
		move.l	d0,d1			d1=actual address to use
		move.l	(sp)+,d0		get new length
		movem.l	(sp)+,a0/a1		restore pointers

	; if bonus, d0/d1/a0/a1 are still set up right
	ENDC

	IFD NODMA
		bra.s	do_PIO			unconditional programmed I/O
	ENDC

		tst.b	cb_Programmed(a3)	already doing programmed I/O ?
		bne.s	use_Virtual		yes, no need to check anymore

	IFND BONUS
		cmp.l	cb_CacheLength(a3),d0	is length the same
		bne.s	do_PIO			nope, switch to programmed I/O
	ENDC
NoCacheCalls

		cmpi.l	#256,d0			is transfer >= 256 bytes
		blt.s	do_PIO			nope, switch to programmed I/O
	IFD DMA_24_BIT
		; handle controllers with 24-bit addressing
		; ugly code due to no free regs
		move.l	d1,-(sp)		no free regs!
		and.l	#$ff000000,(sp)		drop low bytes
		tst.l	(sp)+			test and drop
		bne.s	do_PIO
	ENDC
		btst.l	#0,d1			is transfer to an even address
		bne	do_PIO			nope, switch to programmed I/O

	IFD IS_SCSIDISK
**** software fix for hardware bug.  If WTCH is writeable then we have the
**** A3000 Boyer DMA chip which can't DMA to word aligned addresses, it has to
**** be longword aligned.  If we are doing a transfer to an odd word address
**** then we have to use programmed I/O.
		btst.b	#STB_FixBoyer,st_Flags(a5) need to test for odd word?
		beq.s	use_Physical		nope
		btst.l	#1,d1			is address an odd word
		beq.s	use_Physical		nope, DMA is OK
	ENDC
	IFND IS_SCSIDISK
		bra.s	use_Physical
	ENDC
do_PIO:		addq.b	#1,cb_Programmed(a3)	use programmed I/O from now on
use_Virtual:	move.l	cb_WData(a3),d1		use virtual address not physical
use_Physical:	rts

	ENDC SCSI_SUPPORTED
  ENDC !NCR53C710

;*****************************************************************************

  IFD NCR53C710
		XDEF	SCSITask
		XREF	_SCSITask,GetPubMem

; A3090 SCSITask - allocate globals, get st_SysLib, call _SCSITask
SCSITask:	move.l	4,a6
 IFD DEBUG_CODE
 move.l #st_SIZEOF,d0
 move.l #DSA_entry_SIZEOF,d1
 move.l #CBSZ,d2
 move.l #cb_SIZEOF,d3
 move.l #Scheduler_SIZEOF,d4
 move.l #Sched_entry_SIZEOF,d5
 printf <'st_SIZEOF %ld, DSA_entry %ld, IOCB %ld'>,d0,d1,d2
 printf <'cb_sizeof %ld, scheduler %ld, sched_entry %ld'>,d3,d4,d5
 ENDC
		move.l	#st_SIZEOF,d0		get our global memory area
		bsr	GetPubMem		(I will assume that this works)
		move.l	d0,a0
		move.l	a6,st_SysLib(a0)
		move.l	(sp),d0			our return addr
		move.l	a0,(sp)			put SCSIGlobals there
		move.l	d0,-(sp)		and put return addr back on top
		bra	_SCSITask

		XREF	_temp_53c710_int
		XREF	_intenar

	INCLUDE "hardware/intbits.i"

	; no quick ints on motherboard...
	IFD IS_A3090
		XDEF	@@quick_int
		XDEF	_quick_global

; access pc-relative...  DOESN'T WORK IN ROM!
_quick_global	dc.l	0

@@quick_int:
		; taken from exec docs...
		move.l	d0,-(sp)	; Save d0...
		move.w	_intenar,d0	; Get interrupt enable state
		btst.l	#INTB_INTEN,d0	; Check if pending disable
		bne.s	realInt		; If not, do real one...
exitInt:	move.l	(sp)+,d0	; Restore d0
		rte			; Return from int...
;
realInt:	; Now do your int code...  d0 is already saved
		; ALL other registers need to be saved if needed
		; This includes a0/a1/d0/d1 as this is an interrupt
		; and not a function call...
		;
		movem.l	d1/a0-a1,-(sp)
		move.l	_quick_global(pc),a1	; load g into a1...
		bsr	_ncr53c710_int
		movem.l	(sp)+,d1/a0-a1

		bra.s	exitInt		; Exit interrupt...
	ENDC ; IS_A3090
	IFND USE_C_INT_HANDLER

*********************************************************************
*// Must be callable as a quick or non-quick int
*
*LONG INTERRUPT ASM
*temp_53c710_int(REG(a1) struct SCSIGlobals *g)
*{
*	LONG handled = 0;		// for non-quick
*	UBYTE istat;
*	ULONG status;
*	volatile struct ncr710 *b = g->st_BoardAddress;
*
*	// make sure we _really_ got an interrupt
*// FIX!!!!!!!!!!! NCR chip generates continuous $81 $00000090 ints if we
*// loop back!  Seems to work if we use an 'if' and don't loop back.  Also
*// seems to be sensitive to the speed - the exact length of the loop.
*// That's an ABRT interrupt - it never clears....
*//
*//	while ((istat = b->istat) & (ISTATF_SIP | ISTATF_DIP))
*	if ((istat = b->istat) & (ISTATF_SIP | ISTATF_DIP))
*	{
*		handled = 1;
*		status = *((volatile ULONG *) &(b->sstat2));
*
*
*		g->st_IntData[g->st_IntPointer]   = status;
*		g->st_ISTATData[g->st_IntPointer] = istat;
*
*		// wake him up if needed (only signal once for multiple ints)
*		if (g->st_IntPointer == g->st_TaskPointer)
*			Signal(g->st_ThisTask,g->st_IntPendMask);
*
*		g->st_IntPointer++;
*		if (g->st_IntPointer == SIZEOF(g->st_IntData))
*			g->st_IntPointer = 0;
*
*ignore_int:	;
*	} // while or if...
*
*	return handled;
*}
*
***************************************************************************
ISTATF_SIP	EQU	2
ISTATF_DIP	EQU	1

	XDEF	_ncr53c710_int

_ncr53c710_int:
	movem.l	d2-d3/a2-a3/a6,-(sp)
	move.l	a1,a2			; g (from quick_global or is_Data)
	move.l	st_BoardAddress(a2),a3	; b = g->st_BoardAddress
	moveq	#0,d2			; handled = 0

	; head of loop
10$:	move.b	istat(a3),d0		; istat = b->istat
	moveq	#ISTATF_SIP!ISTATF_DIP,d1	; 3
	and.b	d0,d1			; is this ours?
	beq.s	40$			; all done

	moveq	#1,d2			; handled = 1
	move.l	sstat2(a3),d1		; status = b->sstat2
 IFD DEBUG_CODE
 and.l #$ff,d0
 lea sstat2(a3),a0
 move.l dsp(a3),a1
 printf <'int: $%lx $%08lx (@@$%lx) dsp = $%lx'>,d0,d1,a0,a1
 ENDC
	move.w	st_IntPointer(a2),d3	; g->st_IntPointer
	lea.l	st_ISTATData(a2),a0
	move.b	d0,0(a0,d3.w)		; g->st_ISTATData[g->st_IntPointer] = istat
	lea.l	st_IntData(a2),a0
	move.l	d1,(a0,d3.W*4)		; g->st_IntData[g->st_IntPointer] = status
	cmp.w	st_TaskPointer(a2),d3
	bne.s	20$			; do we need to wake up the task?
	move.l	st_ThisTask(a2),a1
	move.l	st_IntPendMask(a2),d0
	move.l	st_SysLib(a2),a6
	jsr	_LVOSignal(a6)		; Signal(g->st_ThisTask,g->st_IntPendMask)

20$	addq.w	#1,d3			; g->st_IntPointer++
	cmp.w	#8,d3
	bne.s	30$
	moveq	#0,d3			; if (g->st_IntPointer == 8) g->st_IntPointer = 0
30$	move.w	d3,st_IntPointer(a2)
; FIX!!!!!!!!!!! NCR chip generates continuous $81 $00000090 ints if we
; loop back!  Seems to work if we use an 'if' and don't loop back.  Also
; seems to be sensitive to the speed - the exact length of the loop.
; That's an ABRT interrupt - it never clears....
;	bra.s	10$			; end of while

40$:	move.l	d2,d0			; return handled (sets cc's)
	movem.l (sp)+,d2-d3/a2-a3/a6	; doesn't affect cc's
	rts
		ENDC  ; USE_C_INT_HANDLER

	  ENDC ; NCR53C710

		END

@


1.32
log
@Change handling of scsi timeout for A1000.
Open battmem for a1000 to check timeout bit (really "have we
found a second drive" bit)
export battname for attask
@
text
@d1 2
d28 1
d39 2
d280 49
d417 1
d423 1
d440 1
d463 3
d474 3
d478 1
d570 1
d579 7
d595 1
d616 1
a616 1
		beq.s	BattMemDone		nope, so not using 2.0
d619 1
d631 1
d672 1
d679 5
d690 5
d703 1
d708 1
d1513 2
a1514 1
		clr.b	hu_SyncDone(a2)		make us retry sync negotiations
d1598 2
a1599 1
CanDisconnect	or.b	hu_Reselect(a2),d0	($40 or $00) enable reselection
d1858 2
a1859 1
		tst.b	hu_SyncDone(a2)		initially 0
d1880 3
a1882 2
		move.b	#1,hu_SyncDone(a2)	don't try again
		move.b	#1,hu_SentSync(a2)	so we know we started this
d1907 2
a1908 1
		tst.b	hu_SentSync(a2)		did we initiate?
d1918 1
d1920 1
a1920 1
		move.b	hu_SyncNegotiated(a2),st_SyncValues(a5,d1.w)
d2199 1
a2199 1
; The 33c93 also had no clock divisor.  The offset was 0 to 5 (NOT 4).
d2234 3
d2280 1
a2280 1
		move.b	d0,hu_SyncDone(a2)	flag sync negotiated (never 0)
d2286 1
a2286 1
		tst.b	hu_SentSync(a2)
d2297 1
a2297 1
		clr.b	hu_SentSync(a2)		in case he sends one
d2305 2
a2306 2
		move.b	#2,hu_SyncDone(a2)	don't start one
		move.b	d0,hu_SyncNegotiated(a2) remember what we negotiated
d2418 3
d2963 3
d2967 158
d3126 1
@


1.31
log
@Fixed DMA for 2091's
Fixed IDE drives (a2=running unit wasn't being done after my ONE_TASK
mods were added for IDE)
@
text
@d38 3
a40 1

a364 1
	IFND IS_A1000
a367 1
	ENDC
a524 1
	IFND IS_A1000
d544 1
a545 1
		movea.l	d0,a6
d558 1
d562 1
d570 10
a579 2
		tst.b	st_SelTimeout(a5)	long or short ?
		beq.s	17$			short
d581 1
d586 1
d619 1
a620 2
	ENDC !IS_CDTVCR
	ENDC !IS_A1000
@


1.30
log
@Fixed branch in CachePreDMA test (oops)
@
text
@d746 2
d749 1
d2779 1
a2779 1
;	printf <'checkpredma $%lx, %ld bytes, cmd $%lx'>,d1,d0,a1
d2845 3
a2847 1

@


1.29
log
@Stupid Quantums lock up if I don't put delays before setting the sync reg
@
text
@d2779 1
a2779 1
		beq.s	10$			yes, no flags needed (d0=0)
@


1.28
log
@Send the right number of bytes on AddSyncMsg
@
text
@d1805 7
a1811 1
20$		moveq	#0,d1
d2179 6
a2204 2

SYNCDELAY EQU $1000
@


1.27
log
@The code for adding sync messages was losing the last byte of the sync
message (len was wrong).  Also it wouldn't work on a 68000 (odd-
address error).
In addition, added temp storage of negotiated value until the other side
agrees, to be fully in compliance with the spec.
Found bug where cb_MsgOutLen was being set as a byte instead of word
on parity errors.
@
text
@d1803 1
a1803 1
		beq	20$			no, we're responding - done
d2221 1
a2221 1
		move.w	#1+5,cb_MsgOutLen(a3)	how long message is
d2500 4
d2505 1
@


1.26
log
@made certain we never tack a sync message onto something other than
an identify message!
@
text
@d1015 1
a1015 1
		move.b	#1,cb_MsgOutLen(a3)	message is this long
d1393 4
a1756 1
		move.b	#1,hu_SyncDone(a2)	don't try again
d1762 7
d1772 1
a1772 1
		cmp.b	#1,cb_MsgOutLen(a3)	is that all?
d1776 1
d1788 1
d1796 6
d1803 1
a1803 1
		beq	SetTransfer		no, we're responding - done
d1805 4
a2163 3
		moveq	#0,d1
		move.b	hu_Unit(a2),d1		store new SyncValue in array
		move.b	d0,st_SyncValues(a5,d1.w)
d2173 6
a2178 8
SYNCDELAY EQU $1000

	; WHY is this needed????
	move.w	#SYNCDELAY,d0
10$	move.b	_ciaa+ciapra,d1			>= 1us per access
	dbra	d0,10$

		clr.b	hu_SentSync(a2)		paranoia, in case he sends one
d2184 1
d2194 2
d2213 1
a2213 1
		; be set to the number of bytes in the buffer!
d2216 3
d2221 8
a2228 7
		move.l	a0,cb_MsgOutPtr(a3)	where msg is
		move.w	#5,cb_MsgOutLen(a3)	how long message is
		moveq	#0,d0
		move.b	st_MinMsgPeriod(a5),d0	get our message period
		or.l	#$01030100,d0		the rest of the message
		move.l	d0,(a0)			put it in the buffer
		move.b	st_MaxOffset(a5),4(a0)	req/ack offset
@


1.25
log
@needed onetask for ide drives as well
@
text
@d603 4
d1742 6
a1747 2
; so, we tack on the sync message to the identify.  Target should go MsgIn,
; and send a response, then continue on it's way
d1757 8
d2154 2
d2157 1
a2157 1
	move.w	#$1000,d0
d2176 1
a2176 1
	move.w	#$1000,d0
d2180 1
a2180 1
	move.w	#$1000,d0
@


1.24
log
@Made single-task a seperate define (no longer restricted to IDE).  No
big win for SCSI.
Moved setting of sync xfer register.  had to add ANOTHER timing loop to
keep quantums working in sync!
bunch of comment/debug changes.
Saved a few bytes.
@
text
@d37 1
a37 1
		XDEF	HandleCommand,OneTaskEntry
d740 3
@


1.23
log
@got a test backwards in the cache/pio check code
@
text
@d34 1
d37 1
a37 1
		XDEF	HandleCommand
d333 1
a333 1
	printf <'got A1000 int'>
d464 1
a464 1
	IFND IS_IDE
d481 1
a481 1
	IFND IS_IDE
d486 1
a486 1
	IFD IS_IDE
d602 1
d608 1
a608 1
	IFND IS_IDE
d612 2
a613 2
	ENDC !IS_IDE
	IFD IS_IDE
d623 1
a623 1
	ENDC IS_IDE
d626 1
a626 1
	IFND IS_IDE
d643 1
a643 1
	IFND IS_IDE
d646 1
d648 12
d661 7
d669 1
a676 11
	ENDC !IS_IDE
	IFD IS_IDE
; for the IDE driver, we will only use one task since we don't share the
; hardware, even if two drives are hooked up.  If we had IDE and SCSI, or
; if we had "reselectable IDE", ala Randy Hilton, we wouldn't do this - we'd
; use the normal scsi-like setup.
;
; The iotask will call HandleCommand directly.  It exits by branching to
; scsieventloop.  Also, the init code above falls through to here.
;
		rts
d695 1
a695 1
	IFND IS_IDE
d723 1
a723 1
	ENDC !IS_IDE
a740 4
	IFD IS_IDE
		move.l	st_RunningUnit(a5),a2	really only needed for ide here
;						(because iotask bsr's here)
	ENDC
d744 1
d812 1
a812 1
	IFND IS_IDE
d1453 4
d1673 1
d1765 3
a1767 6
		moveq.l	#0,d0
		move.b	hu_Unit(a2),d0
		move.b	st_SyncValues(a5,d0.w),d0
		; FIX! should really wait for the target to respond!
		PUTREG	d0,SYNC_TRANSFER	set up WDC sync value
		rts
d1866 1
d1960 1
a1960 1
		rts				unit was already set up
d1962 1
d1996 1
a1996 1
		bra	SetTransfer		set up transfer mode for unit
d2002 2
a2003 1
CmdComplete	move.b	#UNIT_WAITING,hu_WhatNext(a2)	all completed
d2071 1
d2073 1
d2077 3
a2079 1

d2084 2
a2085 2
		blt.s	CheckOffset		nope, use our values
	IFD DEBUG_CODE
d2104 1
a2104 1
	IFD DEBUG_CODE
a2105 1
	moveq	#0,d1
d2107 1
d2113 1
d2115 1
d2117 1
d2119 1
d2127 1
d2129 1
a2129 2
		; the msg send code sets the SYNC_TRANSFER reg after sending
		; any multi-byte message response
d2134 6
d2155 1
a2155 1
	move.l	#$1000,d0
d2159 1
a2159 1
	move.l	#$1000,d0
d2167 2
d2390 8
a2397 1

d2409 8
d2432 2
d2437 9
d2457 17
d2513 2
d2669 3
d2673 1
a2673 2
G4.1000		bsr.s	SetTransfer
		bra	G1.1000			data out request
d2675 7
a2681 30
G4.1001		bsr.s	SetTransfer
		bra	G1.1001			data in request

G4.1010		bsr.s	SetTransfer
		bra	G1.1010			command request

G4.1011		bsr.s	SetTransfer
		bra	G1.1011			status request

G4.1110		bsr.s	SetTransfer
		bra	G1.1110			message out request

G4.1111		bsr.s	SetTransfer
		bra	G1.1111			message in request

;==============================================================================
; Whenever a target responds to selection or re-selects us, we have to set up
; the WDC into the correct transfer mode/timings for this unit.  Some devices
; don't support synchronous transfers so we'll use asynchronous mode.  Other
; devices do support it (via the messaging system) and we will have already
; determined the REQ/ACK offset for that unit and must store the value in the
; WDC SYNC_TRANSFER register before we attempt any DATA phase transfers. The
; synchronous mode applies to physical units not the individual LUNs !!!!!!
;==============================================================================
SetTransfer	iprintf <'g4.SetTransfer'>
		moveq.l	#0,d0
		move.b	hu_Unit(a2),d0
		move.b	st_SyncValues(a5,d0.w),d0
		PUTREG	d0,SYNC_TRANSFER	set sync xfer value
		rts
d2683 1
d2716 1
@


1.22
log
@Attempted fix for the A2091's on A3000's.
@
text
@d2714 1
a2714 1
		beq	do_PIO			nope, switch to programmed I/O
@


1.21
log
@Move 24-bit dma test to where it will get used.
Remove A1000 battmem delay code
@
text
@d2714 1
a2714 1
		bne.s	do_PIO			nope, switch to programmed I/O
@


1.20
log
@ARGH!  Fixed another stupid bug in the A1000 WaitASecond call.  I'm too tired.
@
text
@d362 1
d366 1
d521 1
a521 1
	; this is a3000, a590 (why not), a2091, a1000
d524 1
d604 1
d2705 8
d2726 1
a2726 8
	IFD DMA_24_BIT
		; handle controllers with 24-bit addressing
		; ugly code due to no free regs
		move.l	d1,-(sp)		no free regs!
		and.l	#$ff000000,(sp)		drop low bytes
		tst.l	(sp)+			test and drop
		beq.s	use_Physical
	ENDC
@


1.19
log
@Removed 1-second wait for ide (needs to go in init).
Fixed wait code to really have execbase in a6!
@
text
@d564 1
a564 1
		; We'll add a 1-second delay in iotask.
d566 1
a566 1
		beq.s	20$			short
d571 1
a571 1
		movem.l	(sp)+,d2/a6
@


1.18
log
@WaitASecond needs execbase!
@
text
@d389 2
a541 1
		move.l	a6,-(sp)		stash exec
d562 1
a562 1
		; 400us).  We'll delay 1 second for all drives, and an
d564 1
d566 1
a566 2
		bne.s	15$			long (3 secs)
		moveq	#0,d2			short (1 sec)
d568 1
a568 1
		move.l	(sp),a6			get execbase back
d596 1
a596 1
		move.l	(sp)+,a6		restore exec
@


1.17
log
@We don't get execbase passed in, but we do get the DMAC type flag
@
text
@d555 1
a555 1
		move.l	d2,-(sp)
d567 2
a568 1
15$		bsr	WaitASecond
d570 1
a570 1
		move.l	(sp)+,d2
@


1.16
log
@Fixed some stuff for A1000 with battmem
@
text
@d377 4
a380 5
;	 4(sp)  = SysBase		not really needed
;	 8(sp)  = BoardAddress		the physical address of our board
;	12(sp)	= ParentTask		the task that created us
;	16(sp)	= MessagePort		the port it wants to PutMsg to
;	20(sp)	= Terminal Count flag	(low byte only valid) do we require TC?
d392 1
a392 1
		movea.l	4(sp),a6		get Exec library
d397 1
a397 1
		move.l	8(sp),st_BoardAddress(a5)	and board address
d405 1
a405 1
		move.l	16(sp),st_CmdPort(a5)		and port address
d407 1
a407 1
		move.b	20+3(sp),st_TerminalCount(a5)	and terminal count flag
d602 1
a602 1
		movea.l	12(sp),a1		(it's waiting on SIGF_SINGLE)
d1306 1
a1306 1
	printf <'Sync jumper\n'>
@


1.15
log
@Added support for conditional terminal count handling (for Rev B A590 dmacs).
Make the slow-startup (seagate) jumper delay 15 seconds, then do a normal-
speed scan, with only slightly extended selection timeout (300ms)
@
text
@d360 2
a361 1
	IFND IS_IDE
d364 1
d518 5
a522 2
	; A1000+ has battmem, but no bits apply to IDE drives
	IFND IS_IDE
d533 1
d547 1
d553 1
d555 1
a555 1
		; wait 15 seconds...  (see discussion below)
d558 10
d572 3
a574 1
20$		lea.l	st_MaxLUN(a5),a0	get required LUN behaviour
d593 1
d596 1
d598 2
a599 1
	ENDC !IS_IDE
d602 1
a602 1
BattMemDone	moveq.l	#SIGF_SINGLE,d0		tell parent we are ready now
@


1.14
log
@Fixed interrupt loop for XT drives.
CHanged some init code (DAWR, etc).  Don't know _why_ I did this, but I
wanted it to match the a590 driver.  Asked steve for info, none yet.
Made it forget sync values on check_condition (since the drive may have
been reset, and we can't read the sense data if we have the wrong values.
Nasty.
Fixed some ints that we shouldn't get without XT - they would fall
through.  Now they go to the bad int code.
@
text
@d43 1
a43 1
		XREF	GetPubMem
d311 34
d379 1
d403 1
d405 3
d516 1
a528 1
; FIX! A1000+ has battmem!
d543 1
a543 1
		move.b	#$25,st_SelTimeout(a5)	short 250ms
d545 1
a545 1
10$		move.b	#$ff,st_SelTimeout(a5)
d547 7
d1046 4
a1049 1
	IFD DMA_FLUSH_OK
d1053 1
a1053 1
	ENDC
d1260 6
d1270 1
a1270 1
		move.b	#$ff,st_SelTimeout(a5)	nope, use 2 second timeout
d1272 7
d1436 4
a1439 1
	IFD DMA_FLUSH_OK
a1444 1
	ENDC
d1518 7
a1524 3
30$	IFD DMA_FLUSH_OK
	move.b	#DMAF_PMODE!DMAF_INTENA!DMAF_DDIR,CNTR(a4)
	ENDC DMA_FLUSH_OK
d1527 4
a1530 4
	IFND DMA_FLUSH_OK
	move.b	#DMAF_TCE!DMAF_PMODE!DMAF_INTENA!DMAF_DDIR!DMAF_XTEOP,CNTR(a4)
	ENDC DMA_FLUSH_OK
		bra	DoDataXFER		common code (at end of G1.1001)
d1593 5
a1597 1
30$	IFD DMA_FLUSH_OK
a1598 1
	ENDC DMA_FLUSH_OK
d1601 2
a1602 3
	IFND DMA_FLUSH_OK
		move.b	#DMAF_TCE!DMAF_PMODE!DMAF_INTENA!DMAF_XTEOP,CNTR(a4)
	ENDC !DMA_FLUSH_OK
d1604 3
d1619 4
a1622 1
	IFND DMA_FLUSH_OK
d1626 2
a1627 1
	ENDC !DMA_FLUSH_OK
d1637 1
@


1.13
log
@Fixed sync (wasn't clearing high bits before word ops)
@
text
@d143 4
d148 1
a170 1
;	printf <'Ignore on g2.0000'>
a173 4
		move.w	st_IntPointer(a1),d2	get current int pointer
		move.b	ISTR(a0),st_IntData(a1,d2.w)	save ISTR status
		move.b	SASR(a0),st_IntData+1(a1,d2.w)  save status reg
		move.b	d0,st_IntData+2(a1,d2.w) and save it for SCSITask
d176 1
d374 10
a383 1
		move.b	d0,CNTR(a4)		steve set it to 0
a384 1
		move.b	#3,DAWR(a4)		data acknowledge width
d749 1
a749 1
	printf <'some unit active, can't start xt/at operation\n'>
d1143 3
a1145 1

d1154 3
d1199 1
a1199 1
	printf <'jumpers are 0x%lx'>,d0
d1283 21
a1303 1
		rts
d1393 1
a1394 1
	IFD XT_SUPPORTED
d1602 2
d2193 1
a2194 1
	IFD XT_SUPPORTED
@


1.12
log
@nops in the spin-loop may help a bit
@
text
@d1931 1
d1953 1
a1953 1
	printf <'%ld '>,d1
d1955 1
a1955 1
	printf <'offset too big, using %ld'>,d1
d1963 1
a1963 2
	printf <'SCSI: hu_SyncValue = 0x%lx'>,d0
	printf <'sending back sync value 0x%lx'>,2(a0)
@


1.11
log
@Added A300 conditionals, CDTV int server, and double-reset of A parts
@
text
@d1733 1
a1733 1
		bsr.s	IdentifyIn		identify after reselection
d1761 1
a1761 1
		moveq	#40,d0
d1763 3
a1765 1
3$		move.b	_ciaa+ciapra,d1		to force it to take time
@


1.10
log
@the g4.0001 int (Advanced feature of the A part) must accept or reject
the identify message - no g2.0000 int will be sent.
@
text
@d118 1
a118 1
	IFND IS_IDE
d216 1
a216 1
	ENDC IS_IDE
d218 1
a218 1
	IFD IS_IDE
d269 28
a296 1
	ENDC IS_IDE
d298 11
d361 1
a361 1
	IFD IS_IDE
d364 3
d453 1
a453 1
	IFD IS_IDE
d460 2
d1144 3
d1160 4
d1166 4
a1169 1
G0.0000:	printf  <'Got reset\n'>
d1214 4
a1217 1
		move.b	st_OwnID(a5),d1		get required ID
d1222 1
a1222 1
		ori.b	#$40!WDCF_EAF,d1	input clock divisor=3
a1223 4
	IFD CLOCK_7MHZ
		; just set the advanced features bit
		bset.b	#WDCB_EAF,d1
	ENDC
d1232 5
d2257 1
d2312 1
@


1.9
log
@Use the advanced features bit to reset the WD chip, and vector through the
normal int tables to determine which one it is (0-non-A, 1-A).  Added
entries for the full g0.xxxx just in case.  Added G4.0001 since we might
get it with advanced features on.  Made a few things bits in a flags
field, and made the Max Offset and MinXferPeriod variables.
Fixed the 2091/590 read jumpers code (you MUST set the XTEOP before reading
it).
@
text
@d2206 5
d2223 5
a2227 2
		beq	MessageReject		failed, bad addr/unit

d2229 5
a2233 5
	moveq	#0,d0
	moveq	#0,d1
	move.b hu_Unit(a2),d0
	move.b hu_LUN(a2),d1
	printf <'g4.0001 - addr/lun %ld/%ld'>,d0,d1
d2244 3
a2246 1
		rts
d2253 1
a2253 1
		bra.s	retrysiv_a
@


1.8
log
@Removed a bunch of debug code
Made cache stuff work on 68000's.
Changed a bunch of local labels to real ones in the cache stuff
@
text
@d148 1
a148 1
		tst.b	st_NoSignalG2_0000(a1)
d153 1
a153 1
		move.b	#1,st_IgnoredG2_0000(a1)	always non-0
d167 1
a167 1
		move.b	#1,st_NoSignalG2_0000(a1)
a328 1
	IFD IS_SCSIDISK
d331 2
a332 1
		move.b	d0,CNTR(a4)		disable everything
d336 1
d338 1
d342 1
a342 1
		clr.b	st_FixBoyer(a5)		assume not Boyer chip
d354 1
a354 1
		move.b	#1,st_FixBoyer(a5)	got a boyer chip
d566 1
a566 56
SCSIService	move.b	st_IntData+2(a5,d2.w),d0 get the saved status byte
		bne	NormalSCSI		it's a normal SCSI interrupt

; the WD SCSI controller has been reset by a command or power up.  We should
; initialise some registers to reasonable defaults.  If own ID is not set to 7
; we'll issue another reset command with the correct ID in the OWNID register.
; A590 and A2091 have three jumpers which can be used to modify the drivers
; behaviour.  These are not present on the A2090 board.
		GETREG	OWN_ID,d1		get the current own ID value
		andi.b	#7,d1			mask off clock bits
		cmp.b	st_OwnID(a5),d1		have we already set it ?
		beq.s	IDSet			yep, so no work to do

	IFD A590_A2091_ONLY
; jumpers are inverted so we have to read the second XT port and invert it
		move.b	XTPORT0+$20(a4),d0	uses second XT unit register
		eori.b	#$07,d0

; jumper 0 enables selection of LUNs greater than 0 (lotsa things screw up)
		clr.b	st_MaxLUN(a5)		assume highest LUN is 0
		lsr.b	#1,d0
		bcc.s	10$			correct
		move.b	#7,st_MaxLUN(a5)	nope, we support LUNs

; jumper 1 sets the timeout on selection to 250ms (no jumper) or 3 seconds
; (1.5 on A3000's)
; Seagate 225N has problems with ignoring parity msgs, jumper disables the
; parity error handling (on message phase) too.
10$		move.b	#TIMEOUT_VAL,st_SelTimeout(a5)	assume quick timeout
		clr.b	st_ParityCheck(a5)	and checking parity
		lsr.b	#1,d0
		bcc.s	20$			correct
		move.b	#$ff,st_SelTimeout(a5)	nope, use 2 second timeout
		move.b	#1,st_ParityCheck(a5)	and ignore message parity
	ENDC A590_A2091_ONLY

; set the input frequency divisor to 3 as well
20$		move.b	st_OwnID(a5),d1		get required ID
	IFD CLOCK_14MHZ
		; a3000 has 14Mhz clock, uses 3.  A590/2091 have 7Mhz, use 2
		; $00 causes a divisor of 2, $40 causes a divisor of 3
		ori.b	#$40,d1			input clock divisor=3
	ENDC
		JAMREG	d1,OWN_ID		set the ID...
		JAMREG	#wd_RESET,COMMAND	and issue a reset command
		move.b	#1,st_SelectPending(a5)	can't allow selects to happen
		bra	IntEventLoop		look for another interrupt

; we issued a reset command so the OWN_ID register got sampled, do other regs.
IDSet		clr.b	st_SelectPending(a5)	selects are OK now
		JAMREG	#0,CONTROL		DMA mode disabled
		JAMREG	st_SelTimeout(a5),TIMEOUT  set timeout period
		JAMREG	#$40,SYNC_TRANSFER	asynchronous + req/ack=300ns
		JAMREG	#WDCF_ER,SOURCE_ID	enable reselection
		bra	IntEventLoop		and that's all

a567 1
NormalSCSI
d574 1
d970 1
a970 1
Group_Table	DC.W	0			0
d981 20
d1068 1
a1068 1
		DC.W	BadStat-Group_4
d1109 94
d1707 1
a1707 1
4$		tst.b	st_IgnoredG2_0000(a5)	did the int come in??
d1710 1
a1710 1
		clr.b	st_NoSignalG2_0000(a5)	if one happens, signal me
d1712 1
a1712 1
		tst.b	st_IgnoredG2_0000(a5)	ah, we saw it already
d1715 1
a1715 1
		clr.b	st_IgnoredG2_0000(a5)	reset for next time
d1862 3
a1864 3
		moveq.l	#MIN_XFER_PERIOD,d0
		cmpi.b	#(MIN_XFER_PERIOD*CLOCK_PERIOD)/4,cb_MessageIn+3(a3)
						; can we handle it ?
a1865 1
		move.b	cb_MessageIn+3(a3),d0	get transfer period/4
d1868 3
a1870 1
	printf <'our period too small, using %ld'>,d0
d1872 2
d1884 3
d1888 1
d1890 1
a1890 1
		moveq	#MAX_OFFSET,d1		default offset
d1892 2
a1893 1
		ble.s	GotOffset		Yes, ours <= theirs
d1895 1
a1895 1
	printf <'%ld offset too big, using %ld'>,#MAX_OFFSET,d1
d1922 5
a1926 1
	move.l	#-1,d0
d1930 1
a1930 1
	move.l	#-1,d0
d1948 5
a1952 2
		move.l	#$01030100!((MIN_XFER_PERIOD*CLOCK_PERIOD)/4),(a0)
		move.b	#MAX_OFFSET,4(a0)	req/ack offset
d2176 1
a2176 1
		beq.s	SIVBad0			what the hell do we do now ?
d2182 1
a2182 1
		beq.s	SIVBad1			failed, SIV must be bad
d2196 1
a2196 1
SIVBad0		moveq.l	#-1,d0
d2200 42
a2241 1
SIVBad1		moveq.l	#-1,d0
d2243 1
a2243 1
		bra	retrysiv
d2500 1
a2500 1
		tst.b	st_FixBoyer(a5)		do we need to test for odd word
@


1.7
log
@Many changes.  Supports sync, fixes the CachePreDMA bug, faster
handling of messages (g2.0000 ints), sync messages handled properly,
etc, etc.
@
text
@d622 6
a627 6
	IFD DEBUG_CODE
	move.l	a3,d1	do we have a command block?
	beq.s	1$
	addq.l	#1,cb_NumFlush(a3)
1$
	ENDC
d679 4
a682 4
	IFD DEBUG_CODE
		clr.l	cb_NumDisconnects(a1)
		clr.l	cb_NumFlush(a1)
	ENDC
d2174 3
a2176 3
	IFD DEBUG_CODE
	add.l	#1,cb_NumDisconnects(a3)
	ENDC
d2192 6
a2197 6
	IFD DEBUG_CODE
	cmp.l	#1,cb_NumDisconnects(a3)
	ble.s	1$
	printf	<'disconnects=%ld, flush=%ld'>,cb_NumDisconnects(a3),cb_NumFlush(a3)
1$
	ENDC
d2216 6
a2221 2
		movea.l	cb_CacheData(a3),a0	get start address we used
		lea.l	cb_CacheLength(a3),a1	point at length we used
d2223 4
d2322 5
d2334 11
a2344 1
		moveq.l	#DMAF_Continue,d0	no, we're continuing a request
d2346 1
a2346 1
10$		move.l	(sp),cb_CacheData(a3)	save start address
d2350 1
a2350 1
20$		movea.l	(sp)+,a0		get address we are using
d2361 1
a2361 1
		bra.s	30$			unconditional programmed I/O
d2365 1
a2365 1
		bne.s	35$			yes, no need to check anymore
d2369 1
a2369 1
		bne.s	30$			nope, switch to programmed I/O
d2371 1
d2374 1
a2374 1
		blt.s	30$			nope, switch to programmed I/O
d2376 1
a2376 1
		bne.s	30$			nope, switch to programmed I/O
d2384 1
a2384 1
		beq.s	40$			nope
d2386 1
a2386 1
		beq.s	40$			nope, DMA is OK
d2394 1
a2394 1
		beq.s	40$
d2396 3
a2398 3
30$		addq.b	#1,cb_Programmed(a3)	use programmed I/O from now on
35$		move.l	cb_WData(a3),d1		use virtual address not physical
40$		rts
@


1.6
log
@optimizations (don't need to signal on the command port)
@
text
@d22 1
d33 1
d47 9
d66 2
a67 2
PUTREG		MACRO				;PUTREG operand,register
		move.b	#\2,st_WDCRegister(a5)	stash register being accessed
d69 1
a69 1
		move.l	#\2,SASRW(a4)		select that register
d71 2
a72 2
	IFND SASRW
		move.b	#\2,SASR(a4)		select that register
d74 3
a76 4
		move.b	\1,SCMD(a4)		and store the value
		ENDM

JAMREG		MACRO				;JAMREG operand,register
d84 1
d87 2
a88 2
GETREG		MACRO				;GETREG register,operand
		move.b	#\1,st_WDCRegister(a5)	stash register being accessed
d90 1
a90 1
		move.l	#\1,SASRW(a4)		select that register
d93 10
a102 1
		move.b	#\1,SASR(a4)		select that register
d104 12
a115 1
		move.b	SCMD(a4),\2		and fetch the contents
d118 1
a122 1
	IFND IS_IDE
d127 1
a127 1
		beq.s	BoardServed		nope, exit immediately
d143 27
a172 8

	IFD SASRW
		move.l	#SCSI_STATUS,SASRW(a0)	read the SCSI status
	ENDIF
	IFND SASRW
		move.b	#SCSI_STATUS,SASR(a0)	read the SCSI status
	ENDIF
		move.b	SCMD(a0),d0
d283 1
a283 1
IntName		DC.B	'_SCSI_',0
d302 1
a302 1
;	 4(sp)  = ExecBase		not nescessary really
d329 5
a333 4
	IFND IS_IDE
	IFND A2090
		move.b	#0,CNTR(a4)		disable everything
		move.b	#0,SRST(a4)		make sure DMA is off
d335 1
a335 1
		move.b	#0,CINT(a4)		clear pending interrupts
a340 1
		moveq.l	#0,d0
a352 1

d354 1
a354 7
	ENDC A2090
	ENDC !IS_IDE

	IFD A2090
		nop
		nop
	ENDC A2090
d368 2
d380 1
a380 1
		move.l	d1,st_CmdPendMask(a5)
d422 1
d424 1
d436 1
a436 4
		move.w	LIB_VERSION(a6),d0	if <V36
		cmpi.w	#36,d0			then no battclock
		blt.s	BattMemDone		(not one that works anyway)

d467 7
a500 4
	IFD A2090
		nop
	ENDC

d514 1
a514 2
		move.l	st_IntPendMask(a5),d0	get the sigs we are waiting for
		or.l	st_CmdPendMask(a5),d0
a525 2
		btst.b	#DMAB_PINT,st_IntData(a5,d2.w)	was it peripheral int ?
		beq.s	IntEventLoop		nope, EOP or spurious
a536 5
;
;		move.l	st_CmdPendMask(a5),d0	get the sigs we are waiting for
;		jsr	_LVOWait(a6)		wait for something to happen
;		bra	HandleCommand
		; fall through to HandleCommand!!!
d588 2
a589 1
; jumper 1 sets the timeout on selection to 128ms (no jumper) or 2 seconds
d592 1
a592 1
10$		move.b	#$10,st_SelTimeout(a5)	assume quick timeout
d602 3
d606 1
d621 8
a628 1
NormalSCSI	moveq.l	#$0f,d1			mask off the lower 4 bits
d655 3
a657 1
HandleCommand	move.l	st_RunningUnit(a5),a2	really only needed for ide here
d659 1
d679 4
a682 1

d701 1
a701 1
		bra	HandleCommand		may select last unit now
d767 1
a767 2
TrySelect:
		move.b	CNTR(a4),d0		get control register
d889 2
a890 1
SCSIGetBytes:
d924 2
a925 1
		move.b	#$05,cb_MessageOut(a3)	initiator detected error
d927 1
a927 2
		pea.l	cb_MessageOut(a3)
		move.l	(sp)+,cb_MsgOutPtr(a3)	initialise the pointer
a982 22
; AssertATN()
;
; Does just that.  There should be a target connected before calling though.
;==============================================================================
AssertATN	PUTREG	#wd_ASSERT_ATN,COMMAND	issue an assert ATN command
		rts

;==============================================================================
; MessageReject( unit )
;		  a0
;
; Asserts ATN and initialises the MessageOut buffer of the given command block
; ready for the next message out request when the Message Reject will get sent.
;==============================================================================
MessageReject	bsr.s	AssertATN		yoohoo, we have a message 4 u
		move.b	#$07,cb_MessageOut(a3)	this message byte
		move.w	#1,cb_MsgOutLen(a3)	message is this long
		lea.l	cb_MessageOut(a3),a0
		move.l	a0,cb_MsgOutPtr(a3)	initialise the pointer
		rts

;==============================================================================
d1146 2
a1147 1
G1.0110		move.b	#UNIT_WAITING,hu_WhatNext(a2)	all completed
d1167 1
d1227 1
a1227 1
CanDisconnect	bset.b	#6,d0			enable reselection
d1254 2
a1255 1
G1.1000		clr.b	st_LastPhase(a5)	we're in a data phase
d1310 1
a1310 1
		bra.s	DoDataXFER		common code (at end of G1.1001)
d1320 2
a1321 1
G1.1001		clr.b	st_LastPhase(a5)	we're in a data phase
d1364 1
d1402 1
a1402 6
	IFD SASRW
		move.l	#TRANSFER_MSB,SASR(a4) set transfer count in WDC
	ENDC
	IFND SASRW
		move.b	#TRANSFER_MSB,SASR(a4) set transfer count in WDC
	ENDC
d1418 2
a1419 1
G1.1010		move.b	#1,st_LastPhase(a5)	we're in command phase
d1434 1
d1459 4
d1464 13
a1476 2
G1.1110:
		movea.l	cb_MsgOutPtr(a3),a0	fetch next message byte ptr
d1494 1
d1502 22
d1545 4
d1551 11
d1563 2
a1564 1
G1.1111:
d1568 1
a1568 1
		rts				got a bad command interrupt
d1571 1
a1571 2
		beq.s	10$			no, check parity on this byte
		rts				already bad, exit immediately
d1573 1
a1573 1
10$		btst.b	#WDCB_PE,SASR(a4)	was there a msg parity error
d1593 1
d1605 1
a1605 1
		rts
d1609 1
a1609 2
		beq.s	30$			got all bytes we were expecting
		rts				we need more bytes
d1612 1
a1612 1
30$		clr.w	d0			use whole word for indexing
d1629 1
a1629 2
		bpl.s	MsgInDone		it wasn't
		rts				extended, more bytes to come
a1636 1
		rts				can't do anything else now
d1638 19
d1757 38
d1796 49
d1846 2
a1847 17
;		moveq.l	#0,d0
;		move.b	cb_MessageIn+3(a3),d0	get transfer period/4
;		cmpi.b	#$46,d0			can we handle it ?
;		blt.s	SyncResponse		nope, use our values
;		lsl.w	#2,d0
;		divu.w	#140,d0			our clock is 7.5 MHz
;		addq.w	#1,d0			d0 holds WDC TP0-TP2
;		lsl.b	#4,d0			move to upper nybble
;		cmpi.b	#4,cb_MessageIn+4(a3)	is offset OK ?
;		bgt.s	SyncResponse

;		or.b	cb_MessageIn+4(a3),d0	merge in REQ/ACK offset
;		move.b	d0,hu_SyncValue(a2)	and save in the unit
;		move.b	#1,hu_SyncDone(a2)	flag sync negotiated
;	printf <'SCSI: hu_SyncValue = 0x%x\n'>,d0
;		PUTREG	d0,SYNC_TRANSFER	set up WDC sync value
;		rts
d1849 6
a1854 7
SyncResponse	moveq.l	#0,d0
		move.b	hu_Unit(a2),d0
		move.b	#$34,st_SyncValues(a5,d0.w)
; FIX!!!!!?????
	moveq.l	#-1,d0
10$	nop
	nop
d1857 2
a1858 3
	moveq.l	#-1,d0
20$	nop
	nop
d1860 11
d1872 1
d1875 3
a1877 2
		move.l	#$01030146,(a0)+	transfer period = 280ns
		move.b	#4,(a0)			req/ack offset = 4
d1881 1
a1881 1
; "Save data qointer" we'll accept this message and move the working data
d1884 1
d1912 1
a1912 1
Disconnect	printf <'Got a disconnect message\n'>
d1970 2
a1971 1
G2.0000		PUTREG	#wd_NEGATE_ACK,COMMAND	issue a negate ack command
d2062 2
a2063 1
G3.PhaseChange	bsr	FlushDMA		make sure DMA finished
d2097 1
d2155 2
a2156 1
G4.0101	printf <'A disconnect occured ... '>
d2173 4
a2176 1
	printf <'intermediate\n'>
d2191 7
a2197 1
SummatElse	printf <'terminal\n'>
d2240 1
a2240 1
	printf <'Got more commands, adding back to waitingunits\n'>
d2284 2
a2285 1
SetTransfer	moveq.l	#0,d0
a2321 1
		bra.s	20$			don't set address
d2324 2
a2325 2
		move.l	4(sp),cb_CacheLength(a3)	and length we want to do
		addq.b	#1,cb_DidCacheStuff(a3)	flag that we did cache stuff
@


1.5
log
@Couldn't make one of them a bra.s, A590 pukes.  Need a macro
@
text
@d324 4
d336 1
d339 2
d343 4
@


1.4
log
@bra -> bra.s
@
text
@d656 1
a656 1
		bne.s	NoSelect		yes, can't do a selection
@


1.3
log
@Fixed include file issues (use include: files instead of private ones)
@
text
@d656 1
a656 1
		bne	NoSelect		yes, can't do a selection
d660 1
a660 1
		beq	NoSelect		nope, so no work
@


1.2
log
@First major checkin
Integrated all the different drivers (A590 to A3000 to IDE).  Merged
all mods with ifd's.  Major changes to save space/time (mainly use of
global register variables).  A number of minor bug fixes.

@
text
@a10 1
		INCLUDE	"modifiers.i"
d17 7
a26 6
		INCLUDE	"scsidirect.i"
		INCLUDE	"hardblocks.i"

		INCLUDE	"resources/battmembitsshared.i"
		INCLUDE	"resources/battmembitsamiga.i"
		INCLUDE	"resources/battmem.i"
@


1.1
log
@Initial revision
@
text
@d2 1
d34 1
d91 3
a93 1
BoardServer	moveq.l	#0,d0			assume it's not our interrupt
d166 55
d227 6
a232 1
	IFND XT_SUPPORTED
d237 1
d239 1
d256 8
d265 3
a267 1
SCSITask	movea.l	4(sp),a6		get Exec library
d273 3
d279 2
a280 1
	IFD A590
d305 2
a306 1
	ENDC A590
d324 2
d354 7
d366 1
d377 1
a412 1

d414 1
d416 1
d420 10
d431 4
a434 1
	IFD A590
d437 1
d454 3
a456 1
SCSIEventLoop	move.l	st_IntPendMask(a5),d0	get the sigs we are waiting for
d461 2
a462 1
IntEventLoop	move.w	st_TaskPointer(a5),d0	get our interrupt frame pointer
d471 17
d505 1
d527 1
a527 1
	IFD A590
d529 2
a530 2
;		move.b	XTPORT0+$20(a4),d0	uses second XT unit register
;		eori.b	#$07,d0
d533 4
a536 4
;		clr.b	st_MaxLUN(a5)		assume highest LUN is 0
;		lsr.b	#1,d0
;		bcc.s	10$			correct
;		move.b	#7,st_MaxLUN(a5)	nope, we support LUNs
d541 5
a545 5
;10$		move.b	#$10,st_SelTimeout(a5)	assume quick timeout
;		clr.b	st_ParityCheck(a5)	and checking parity
;		lsr.b	#1,d0
;		bcc.s	20$			correct
;		move.b	#$ff,st_SelTimeout(a5)	nope, use 2 second timeout
d547 1
a547 1
	ENDC A590
d576 1
d578 2
d593 3
a595 1
HandleCommand	bsr.s	DoSelect		maybe select another unit
d602 6
a607 6
	IFD DEBUG_CODE
	tst.b	st_WasteSpace(a5)
	beq.s	NMTO
	printf <'Received more than one command\n'>
NMTO	addq.b	#1,st_WasteSpace(a5)
	ENDC
d610 1
d613 1
d616 1
d621 1
a621 1
		bne.s	HandleCommand		yes, don't queue unit again
d631 2
d649 8
a656 5
DoSelect	tst.b	st_SelectPending(a5)	is a selection pending ?
		bne.s	NoSelect		yes, so don't try another

		tst.l	st_RunningUnit(a5)	is a unit connected right now ?
		bne.s	NoSelect		yes, can't do a selection
d660 1
a660 1
		beq.s	NoSelect		nope, so no work
d662 1
d666 1
a666 1

d674 3
a676 2
	IFD XT_SUPPORTED
		tst.b	hu_Type(a0)		is this XT or SCSI
d678 1
d682 4
d687 1
a687 1
	ENDC
d689 1
d802 2
a803 2
; SCSIGetBytes( count, buffer, CommandBlock )
; 		 d0	 a0	    a1
d856 4
a859 4
		move.b	#$05,cb_MessageOut(a1)	initiator detected error
		move.b	#1,cb_MsgOutLen(a1)	message is this long
		pea.l	cb_MessageOut(a1)
		move.l	(sp)+,cb_MsgOutPtr(a1)	initialise the pointer
d863 2
a864 2
; SCSIPutBytes( count, buffer, CommandBlock )
; 		 d0	 a0	    a1
d923 2
a924 2
; MessageReject( unit, commandblock )
;		  a0	   a1
d930 4
a933 4
		move.b	#$07,cb_MessageOut(a1)	this message byte
		move.w	#1,cb_MsgOutLen(a1)	message is this long
		lea.l	cb_MessageOut(a1),a0
		move.l	a0,cb_MsgOutPtr(a1)	initialise the pointer
d1100 2
a1101 4
G1.0110		movea.l	st_RunningUnit(a5),a0	fetch currently active unit
		move.b	#UNIT_WAITING,hu_WhatNext(a0)	all completed
		movea.l	hu_CurrentCmd(a0),a0	fetch current command block
		movea.l	cb_WStatus(a0),a1	fetch status storage pointer
d1105 1
d1107 1
d1120 1
a1120 2
G1.0001entry	move.l	a2,-(sp)
		lea.l	st_WaitingUnits(a5),a0	unlink unit from waiting queue
d1124 3
d1129 1
a1129 1
		move.l	a2,st_RunningUnit(a5)	make this the running unit
d1132 1
d1134 1
d1136 5
a1140 5
		movea.l	d0,a0			set up the SCSI working ptrs
		movea.l	cb_SCSICmd(a0),a1	from the SCSICmd struct
		move.l	a1,cb_LinkedCmd(a0)	we're using the first cmd block
		move.l	scsi_Data(a1),cb_WData(a0)
		move.l	scsi_Command(a1),cb_WCommand(a0)
d1146 7
a1152 4
		move.l	a1,cb_WStatus(a0)	only one status byte
		move.l	cb_WData(a0),cb_SData(a0)	copy working ptrs...
		move.l	cb_WCommand(a0),cb_SCommand(a0)	...to saved pointers
		move.l	cb_WStatus(a0),cb_SStatus(a0)
d1162 4
a1165 4
		lea.l	cb_MessageIn(a0),a1	initialise msg in for 1 byte
		move.l	a1,cb_MsgInPtr(a0)
		move.w	#1,cb_MsgInLeft(a0)
		clr.w	cb_MsgInLen(a0)		no message received yet
d1167 3
a1169 3
		lea.l	cb_MessageOut(a0),a1	and msg out is 1 byte too
		move.l	a1,cb_MsgOutPtr(a0)
		move.w	#1,cb_MsgOutLen(a0)	we're sending a 1 byte message
d1183 2
a1184 1
		movea.l	(sp)+,a2		we'll get msg or cmd phase next
d1187 1
d1207 1
a1207 3
		movea.l	st_RunningUnit(a5),a0	fetch currently active unit
		movea.l	hu_CurrentCmd(a0),a0	fetch current command block
		movea.l	cb_LinkedCmd(a0),a1	and corresponding SCSICmd
d1234 2
a1235 2
		movea.l	cb_WData(a0),a1		get data address
		addq.l	#1,cb_WData(a0)		and bump the data pointer
d1240 1
a1240 1
20$		move.l	cb_WData(a0),d1		get source data pointer
d1242 1
a1242 1
		tst.b	cb_Programmed(a0)	programmed I/O needed ?
d1246 1
a1246 1
		add.l	d0,cb_WData(a0)		bump the ptr for next time
a1247 1
		movea.l	a0,a1			command block to a1
d1272 1
a1272 3
		movea.l	st_RunningUnit(a5),a0	fetch currently active unit
		movea.l	hu_CurrentCmd(a0),a0	fetch current command block
		movea.l	cb_LinkedCmd(a0),a1	and corresponding SCSICmd
d1303 1
a1303 1
		movea.l	cb_WData(a0),a1		get data address
d1305 1
a1305 1
		move.l	a1,cb_WData(a0)		save the bumped pointer
d1309 1
a1309 1
20$		move.l	cb_WData(a0),d1		get destination address
d1311 1
a1311 1
		tst.b	cb_Programmed(a0)	programmed I/O needed ?
d1315 1
a1315 1
		add.l	d0,cb_WData(a0)		bump the ptr for next time
a1316 1
		movea.l	a0,a1			command block to a1
d1333 1
a1333 1
		add.l	d0,cb_WData(a0)		bump the ptr for next time
d1373 1
a1373 3
		movea.l	st_RunningUnit(a5),a0	fetch currently active unit
		movea.l	hu_CurrentCmd(a0),a1
		movea.l	cb_LinkedCmd(a1),a0	and the direct scsi_Cmd
d1377 1
a1377 1
		movea.l	cb_WCommand(a1),a0	get command block pointer
d1396 1
a1396 3
;		movea.l	st_RunningUnit(a5),a0	fetch currently active unit
;		movea.l	hu_CurrentCmd(a0),a0	fetch current command block
;		movea.l	cb_WStatus(a0),a1	fetch status storage pointer
d1413 2
a1414 4
		movea.l	st_RunningUnit(a5),a0	fetch currently active unit
		movea.l	hu_CurrentCmd(a0),a1	fetch current command block
		movea.l	cb_MsgOutPtr(a1),a0	fetch next message byte ptr
		move.w	cb_MsgOutLen(a1),d0	how big is the message ?
a1427 1
		movea.l	st_RunningUnit(a5),a0
d1429 1
a1429 1
		move.b	hu_Unit(a0),d0
d1459 1
a1459 1
; All message handlers are entered with a0=unit, a1=command.  Identify is
a1462 2
		movea.l	st_RunningUnit(a5),a0	fetch currently active unit
		movea.l	hu_CurrentCmd(a0),a1	fetch current command block
d1468 1
a1468 1
5$		tst.b	cb_MsgParity(a1)	was parity already bad ?
d1480 1
a1480 1
		move.b	#-1,cb_MsgParity(a1)	flag that an error occured
d1485 1
a1485 1
		lea.l	cb_MessageOut(a1),a0	initialise message out
d1487 2
a1488 2
		move.l	a0,cb_MsgOutPtr(a1)
		move.w	#1,cb_MsgOutLen(a1)
d1492 1
a1492 1
ParityOK	movea.l	cb_MsgInPtr(a1),a0	fetch next message pointer
d1494 3
a1496 3
		move.l	a0,cb_MsgInPtr(a1)	save the new message ptr
		addq.w	#1,cb_MsgInLen(a1)	and bump the current msg len
		tst.w	cb_MsgInLeft(a1)	are we fetching Extended msgs ?
d1502 1
a1502 1
		move.w	d0,cb_MsgInLeft(a1)	how many more we're expecting
d1506 1
a1506 1
10$		subq.w	#1,cb_MsgInLeft(a1)	one less byte to expect
d1511 2
a1512 3
30$		movea.l	st_RunningUnit(a5),a0	get unit ptr for msg handlers
		clr.w	d0			use whole word for indexing
		move.b	cb_MessageIn(a1),d0	fetch first message byte
a1520 2
		movea.l	st_RunningUnit(a5),a0	in case routine clobbered ptrs
		movea.l	hu_CurrentCmd(a0),a1
d1527 1
a1527 3
		movea.l	st_RunningUnit(a5),a0	in case routine clobbered ptrs
		movea.l	hu_CurrentCmd(a0),a1
		tst.w	cb_MsgInLeft(a1)	make sure not an extended msg
d1532 5
a1536 5
MsgInDone	clr.b	cb_MsgParity(a1)	no parity errors now
ResetMsgIn	lea.l	cb_MessageIn(a1),a0	reset the msg in buffers
		move.l	a0,cb_MsgInPtr(a1)
		move.w	#1,cb_MsgInLeft(a1)
		clr.w	cb_MsgInLen(a1)
d1556 2
a1557 2
; IdentifyIn( message, unit, command )
;		d0	a0	a1
d1566 1
a1566 1
		cmp.b	hu_LUN(a0),d0		did we get the correct one ?
d1576 1
a1576 1
		move.b	hu_Unit(a0),d0		physical was correct
d1586 3
a1588 2
		move.l	d0,-(sp)		stash the one we found
		movea.l	st_RunningUnit(a5),a1	put old one on WorkingUnits
d1594 2
a1595 4
		movea.l	(sp)+,a0		get the new unit
		move.l	a0,st_RunningUnit(a5)	it's running (connected) now
		move.b	#UNIT_RUNNING,hu_QueueType(a0)
		move.b	#UNIT_GOT_ERROR,hu_WhatNext(a0)	no disconnect w/o msg
d1597 3
a1599 3
		movea.l	hu_CurrentCmd(a0),a1	restore working ptrs
		move.l	cb_SData(a1),cb_WData(a1)
		move.l	cb_SCommand(a1),cb_WCommand(a1)
d1601 1
a1601 1
		lea.l	hu_SCSIQueue(a0),a1	remove from WorkingUnits queue
d1609 1
a1609 1
CmdComplete	move.b	#UNIT_WAITING,hu_WhatNext(a0)	all completed
d1620 1
a1620 1
Extended	move.w	cb_MsgInLen(a1),d0	how much message is there ?
d1623 1
a1623 1
		move.w	#-1,cb_MsgInLeft(a1)	flag that next byte is a count
d1626 1
a1626 1
GotExtended	move.b	cb_MessageIn+2(a1),d0	get extended message code
d1639 1
a1639 1
	printf <'SCSI: got sync xfer req (0x%lx)\n'>,cb_MessageIn+2(a1)
d1642 1
a1642 1
;		move.b	cb_MessageIn+3(a1),d0	get transfer period/4
d1649 1
a1649 1
;		cmpi.b	#4,cb_MessageIn+4(a1)	is offset OK ?
d1652 3
a1654 3
;		or.b	cb_MessageIn+4(a1),d0	merge in REQ/ACK offset
;		move.b	d0,hu_SyncValue(a0)	and save in the unit
;		move.b	#1,hu_SyncDone(a0)	flag sync negotiated
d1660 1
a1660 1
		move.b	hu_Unit(a0),d0
d1662 1
d1672 3
a1674 3
		lea.l	cb_MessageOut(a1),a0	initialise message out
		move.l	a0,cb_MsgOutPtr(a1)	where msg is
		move.w	#5,cb_MsgOutLen(a1)	how long message is
d1684 1
a1684 1
SaveData	move.l	cb_WData(a1),cb_SData(a1)	save data pointer
d1692 2
a1693 2
RestorePtrs	move.l	cb_WData(a1),d0		how much difference
		sub.l	cb_SData(a1),d0
d1695 1
a1695 1
		movea.l	cb_SCSICmd(a1),a0	subtract difference from...
d1698 3
a1700 3
		move.l	cb_SData(a1),cb_WData(a1)
		move.l	cb_SCommand(a1),cb_WCommand(a1)
		move.l	cb_SStatus(a1),cb_WStatus(a1)
d1711 1
a1711 1
		move.b	#UNIT_WORKING,hu_WhatNext(a0)
d1719 1
a1719 1
Rejected	move.b	cb_MessageOut(a1),d0	what message was rejected ?
d1724 1
a1724 1
		move.b	cb_MessageOut+2(a1),d0	make sure correct extended msg
d1745 1
a1745 1
LCmdComplete	movea.l	cb_LinkedCmd(a1),a0	fetch current SCSI command
d1747 1
a1747 1
		move.l	a0,cb_LinkedCmd(a1)	this is the one we're using now
d1749 2
a1750 2
		move.l	scsi_Data(a0),cb_WData(a1)
		move.l	scsi_Command(a0),cb_WCommand(a1)
d1754 4
a1757 4
		move.l	a0,cb_WStatus(a1)	only one status byte
		move.l	cb_WData(a1),cb_SData(a1)	copy working ptrs...
		move.l	cb_WCommand(a1),cb_SCommand(a1)	...to saved pointers
		move.l	cb_WStatus(a1),cb_SStatus(a1)
d1795 1
d1809 1
d1812 1
a1812 2
		movea.l	st_RunningUnit(a5),a0	fetch the unit pointer
		move.b	#UNIT_TIMED_OUT,hu_WhatNext(a0)	mark as timed out
d1815 1
d1866 1
a1866 3
		movea.l	st_RunningUnit(a5),a0	get the current unit
		movea.l	hu_CurrentCmd(a0),a0	fetch current command block
		movea.l	cb_LinkedCmd(a0),a1	and corresponding SCSICmd
d1878 1
a1878 1
		sub.l	d0,cb_WData(a0)		and adjust DMA address too
d1899 1
d1902 2
a1903 3
		movea.l	d0,a0
		move.b	#UNIT_RUNNING,hu_QueueType(a0)
		move.b	#UNIT_GOT_ERROR,hu_WhatNext(a0)	no disconnect w/o msg
d1905 3
a1907 3
		movea.l	hu_CurrentCmd(a0),a1	restore working ptrs
		move.l	cb_SData(a1),cb_WData(a1)
		move.l	cb_SCommand(a1),cb_WCommand(a1)
d1909 1
a1909 1
		lea.l	hu_SCSIQueue(a0),a1	remove from WorkingUnits queue
d1952 7
a1958 1
FakeDisconnect	clr.b	st_SelectPending(a5)	selects are OK to do now
d1961 1
d1972 6
a1977 6
	IFD DEBUG_CODE
	cmpi.b #1,st_WasteSpace(a5)
	beq.s nowt
	printf <'Another command is pending too....\n'>
nowt	nop
	ENDC
d1981 1
d1984 1
a1984 2
		movea.l	hu_CurrentCmd(a1),a1	fetch the command block
		clr.b	cb_ErrorCode(a1)	assume no errors
d1987 1
a1987 1
		move.b	#HFERR_Phase,cb_ErrorCode(a1)	*** cop out error
d1991 1
a1991 1
		move.b	#HFERR_SelTimeout,cb_ErrorCode(a1)
d1997 2
a1998 1
		tst.b	cb_DidCacheStuff(a1)	did we do CachePreDMA() ?
d2001 2
a2002 3
		move.l	a1,-(sp)		save cmd pointer
		movea.l	cb_CacheData(a1),a0	get start address we used
		lea.l	cb_CacheLength(a1),a1	point at length we used
d2005 1
a2005 1
		move.l	(sp)+,a1		restore command ptr
d2008 3
a2010 1
NoDataFlush	jsr	_LVOReplyMsg(a6)	reply the command block
d2012 3
a2014 3
	IFD DEBUG_CODE
	subq.b #1,st_WasteSpace(a5)
	ENDC
d2032 1
d2069 2
a2070 3
SetTransfer	movea.l	st_RunningUnit(a5),a0
		moveq.l	#0,d0
		move.b	hu_Unit(a0),d0
d2077 2
a2078 2
; length/address = CheckPreDMA( length, address, cmdblock, scsicmd )
;   d0	   d1			  d0	  d1	    a0	      a1
d2108 3
a2110 3
10$		move.l	(sp),cb_CacheData(a0)	save start address
		move.l	4(sp),cb_CacheLength(a0)	and length we want to do
		addq.b	#1,cb_DidCacheStuff(a0)	flag that we did cache stuff
d2126 1
a2126 1
		tst.b	cb_Programmed(a0)	already doing programmed I/O ?
d2130 1
a2130 1
		cmp.l	cb_CacheLength(a0),d0	is length the same
d2139 1
d2141 2
a2142 2
**** Boyer DMA chip which can't DMA to word aligned addresses, it has to be
**** longword aligned.  If we are doing a transfer to an odd word address
d2148 12
d2161 1
a2161 3
30$		addq.b	#1,cb_Programmed(a0)	use programmed I/O from now on
35$		move.l	cb_WData(a0),d1		use virtual address not physical
40$		rts
@
