head     1.16;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @* @;


1.16
date     93.05.21.16.09.26;  author jerryh;  state Exp;
branches ;
next     1.15;

1.15
date     93.05.06.15.11.25;  author jerryh;  state Exp;
branches ;
next     1.14;

1.14
date     93.04.19.14.43.45;  author jerryh;  state Exp;
branches ;
next     1.13;

1.13
date     93.04.13.11.04.14;  author jerryh;  state Exp;
branches ;
next     1.12;

1.12
date     93.03.29.13.40.44;  author jerryh;  state Exp;
branches ;
next     1.11;

1.11
date     93.03.23.11.01.22;  author jerryh;  state Exp;
branches ;
next     1.10;

1.10
date     93.03.18.14.46.54;  author jerryh;  state Exp;
branches ;
next     1.9;

1.9
date     93.03.16.13.18.24;  author jerryh;  state Exp;
branches ;
next     1.8;

1.8
date     93.03.08.15.15.41;  author jerryh;  state Exp;
branches ;
next     1.7;

1.7
date     93.03.01.14.48.10;  author jerryh;  state Exp;
branches ;
next     1.6;

1.6
date     93.02.25.11.05.28;  author jerryh;  state Exp;
branches ;
next     1.5;

1.5
date     93.02.24.16.25.26;  author jerryh;  state Exp;
branches ;
next     1.4;

1.4
date     93.01.22.12.04.25;  author jerryh;  state Exp;
branches ;
next     1.3;

1.3
date     93.01.15.15.48.28;  author jerryh;  state Exp;
branches ;
next     1.2;

1.2
date     93.01.11.16.44.29;  author jerryh;  state Exp;
branches ;
next     1.1;

1.1
date     92.11.20.16.24.03;  author jerryh;  state Exp;
branches ;
next     ;


desc
@command processor for cdtv.device.
@


1.16
log
@IORequest was not being loaded before opendevice() of timer.device.
@
text
@************************************************************************
***                                                                  ***
***                    -= CDTV DEVICE DRIVER =-                      ***
***                                                                  ***
************************************************************************
***                                                                  ***
***     CONFIDENTIAL and PROPRIETARY                                 ***
***     Copyright (c) 1990 by Commodore-Amiga, Inc.                  ***
***     Created by Carl Sassenrath, Sassenrath Research, Ukiah, CA   ***
***                                                                  ***
***     Modified 6/1/91: Jerry Horanoff                              ***
***                                                                  ***
************************************************************************

        INCLUDE "include:exec/types.i"
        INCLUDE "include:exec/nodes.i"
        INCLUDE "include:exec/lists.i"
        INCLUDE "include:exec/ports.i"
        INCLUDE "include:exec/libraries.i"
        INCLUDE "include:exec/tasks.i"
        INCLUDE "include:exec/devices.i"
        INCLUDE "include:exec/memory.i"
        INCLUDE "include:exec/interrupts.i"
        INCLUDE "include:exec/resident.i"
        INCLUDE "include:exec/io.i"
        INCLUDE "include:exec/errors.i"
        INCLUDE "include:exec/execbase.i"
        INCLUDE "include:hardware/intbits.i"
        INCLUDE "include:devices/trackdisk.i"
        INCLUDE "include:devices/timer.i"
        INCLUDE "include:exec/ables.i"
        INCLUDE "gs:cd/cd.i"
        INCLUDE "cdtv.i"
        INCLUDE "cdtv:src/playerlibrary/playerlibrary.i"
        INCLUDE "defs.i"
        INCLUDE "cddev.i"

        OPT     p=68020

************************************************************************
***
***  External References
***
************************************************************************

        XREF    GenStatus
        XREF    GetROMTrack        
        XREF    GetClass1Error
        XREF    GetClass2Error
        XREF    MSFtoLSN
        XREF    LSNtoMSF
        XREF    MSFtoLSNPOS
        XREF    LSNtoMSFPOS
        XREF    BCDtoBIN
        XREF    Attenuate
        XREF    Open
        XREF    Close
        XREF    Expunge
        XREF    Freserved
        XREF    MakeXL
        XREF    StartXL
        XREF    GetQCode
        XREF    SetSQStat
        XREF    DevName
        XREF    InitIntr

        XREF    Enable
        XREF    Disable

        XREF    PutStr
        XREF    PutChar
        XREF    PutHex

        INT_ABLES

*
************************************************************************
***
***  Internal Macros
***
************************************************************************

DEVFUN          macro
                dc.l    \1
                endm

DEVCOM          macro
MAX_CMD         set     MAX_CMD+1
                dc.l    \1
                endm

MAX_CMD         set     0


 STRUCTURE XXX,LIB_SIZE           ; Fake device base for cd.device

        ALIGNLONG
        APTR        db_CDROMPage  ; Hardware buffer pointers
        APTR        db_CDCOMRXPage
        APTR        db_CDCOMTXPage
        APTR        db_CDSUBPage
                                  ;                                Default  
        UWORD  xxx_PlaySpeed      ; Audio play speed               (75)        
        UWORD  xxx_ReadSpeed      ; Data-rate of CD_READ command   (Max)       
        UWORD  xxx_ReadXLSpeed    ; Data-rate of CD_READXL command (75)        
        UWORD  xxx_SectorSize     ; Number of bytes per sector     (2048)   
        UWORD  xxx_XLECC          ; CDXL ECC enabled/disabled               
        UWORD  xxx_EjectReset     ; Reset on eject enabled/disabled         
        STRUCT xxx_Reserved1,8    ; Reserved for future expansion           
                                                                           
        UWORD  xxx_MaxSpeed       ; Maximum speed drive can handle (75, 150)
        UWORD  xxx_AudioPrecision ; 0 = no attenuator, 1 = mute only,       
                                  ; other = (# levels - 1)                  
        UWORD  CDStatus

        LABEL  XXX_SIZE

*
************************************************************************
***
***  DEVICE FUNCTION/COMMAND ADDRESS TABLE
***
***     This table contains the addresses for device functions
***     and command functions.  It is used by MakeLibrary to
***     initialize the device node.
***
***     This table could be smaller (word size) but MANX
***     does not like the word size for some reason!!!
***
************************************************************************

        XDEF DevFuncs

DevFuncs
                DEVFUN  Open             ; -6
                DEVFUN  Close            ; -12
                DEVFUN  Expunge          ; -18
                DEVFUN  Freserved        ; -24
                DEVFUN  BeginIO          ; -30
                DEVFUN  AbortIO          ; -36
                DEVFUN  PerformIO        ; -42
                DEVFUN  Freserved        ; -48

                DEVCOM  CmdReset         ; 1 (-54)
                DEVCOM  CmdRead          ; 2
                DEVCOM  CmdWrite         ; 3
                DEVCOM  CmdUpdate        ; 4
                DEVCOM  CmdClear         ; 5
                DEVCOM  CmdStop          ; 6
                DEVCOM  CmdStart         ; 7
                DEVCOM  CmdFlush         ; 8
                DEVCOM  CmdMotor         ; 9
                DEVCOM  CmdSeek          ; 10
                DEVCOM  CmdFormat        ; 11
                DEVCOM  CmdRemove        ; 12
                DEVCOM  CmdChangeNum     ; 13
                DEVCOM  CmdChangeState   ; 14
                DEVCOM  CmdProtStatus    ; 15
                DEVCOM  NoCommand        ; 16
                DEVCOM  NoCommand        ; 17
                DEVCOM  CmdGetDriveType  ; 18
                DEVCOM  CmdGetNumTracks  ; 19
                DEVCOM  CmdAddChangeInt  ; 20
                DEVCOM  CmdRemChangeInt  ; 21
                DEVCOM  CmdGetGeometry   ; 22
                DEVCOM  CmdEject         ; 23

*
                DEVCOM  NoCommand        ; 24
                DEVCOM  NoCommand        ; 25
                DEVCOM  NoCommand        ; 26
                DEVCOM  NoCommand        ; 27
                DEVCOM  NoCommand        ; 28  (SCSI)
                DEVCOM  NoCommand        ; 29
                DEVCOM  NoCommand        ; 30
                DEVCOM  NoCommand        ; 31

                DEVCOM  NoCommand        ; 32   I
                DEVCOM  CmdStatus        ; 33   I
                DEVCOM  CmdQuickStatus   ; 34   I
                DEVCOM  CmdInfo          ; 35
                DEVCOM  CmdErrorInfo     ; 36   I
                DEVCOM  CmdIsROM         ; 37
                DEVCOM  CmdOptions       ; 38   
                DEVCOM  CmdFrontPanel    ; 39   I
                DEVCOM  CmdFrameCall     ; 40
                DEVCOM  CmdFrameCount    ; 41

                DEVCOM  CmdReadXL        ; 42

                DEVCOM  CmdPlayTrack     ; 43   I

                DEVCOM  CmdPlayLSN       ; 44   I T
                DEVCOM  CmdPlayMSF       ; 45   I T

                DEVCOM  CmdPlaySegsLSN   ; 46
                DEVCOM  CmdPlaySegsMSF   ; 47

                DEVCOM  CmdTOCLSN        ; 48   I T
                DEVCOM  CmdTOCMSF        ; 49   I T

                DEVCOM  CmdSubQLSN       ; 50   I T
                DEVCOM  CmdSubQMSF       ; 51   I T

                DEVCOM  CmdPause         ; 52   I T
                DEVCOM  CmdStopPlay      ; 53   I T

                DEVCOM  CmdPokeSegLSN    ; 54
                DEVCOM  CmdPokeSegMSF    ; 55

                DEVCOM  CmdMute          ; 56
                DEVCOM  CmdFade          ; 57

                DEVCOM  CmdPokePlayLSN   ; 58
                DEVCOM  CmdPokePlayMSF   ; 59

                DEVCOM  CmdGenLock       ; 60

                DEVCOM  CmdPlayMode      ; 61
                DEVCOM  CmdReadMode      ; 62

                dc.l    -1               ; end of list

*
************************************************************************
***
***  DEVICE COMMAND OPTION TABLE
***
***     This table contains bits to indicate valid options for
***     each of the device command functions.  Options are:
***
***     NODISK  - execute command even when no disk present
***     QUEUE   - serialize (queue) the command for execution
***
************************************************************************

        XDEF CmdOpts

CmdOpts:
        dc.w  OF_INVALID
        dc.w  OF_NODISK|OF_QUEUE|OF_DISKACCESS                          ; Reset
        dc.w  OF_QUEUE|OF_DISKACCESS|OF_ROM|OF_ABT3                     ; Read
        dc.w  OF_NODISK                                                 ; Write
        dc.w  OF_NODISK                                                 ; Update
        dc.w  OF_NODISK                                                 ; Clear
        dc.w  OF_NODISK                                                 ; Stop
        dc.w  OF_NODISK                                                 ; Start
        dc.w  OF_NODISK                                                 ; Flush
        dc.w  OF_NODISK|OF_QUEUE|OF_DISKACCESS                          ; Motor
        dc.w  OF_QUEUE|OF_DISKACCESS                                    ; Seek
        dc.w  OF_INVALID                                                ; Format
        dc.w  OF_INVALID                                                ; Remove
        dc.w  OF_NODISK                                                 ; ChangeNum
        dc.w  OF_NODISK                                                 ; ChangeState
        dc.w  0                                                         ; ProtStatus
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_NODISK                                                 ; CmdGetDriveType
        dc.w  0                                                         ; CmdGetNumTracks
        dc.w  OF_NODISK|OF_NOREPLY                                      ; CmdAddChangeInt
        dc.w  OF_NODISK                                                 ; CmdRemChangeInt
        dc.w  0                                                         ; CmdGetGeometry
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdEject
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_INVALID                                                ; NoCommand
*
        dc.w  OF_INVALID                                                ; CmdDirect               (no longer supported)
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdStatus
        dc.w  OF_NODISK                                                 ; CmdQuickStatus
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdInfo
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdErrorInfo
        dc.w  OF_QUEUE                                                  ; CmdIsROM
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdOptions
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdFrontPanel
        dc.w  OF_NODISK|OF_NOREPLY|OF_ABT1                              ; CmdFrameCall
        dc.w  OF_NODISK                                                 ; CmdFrameCount
        dc.w  OF_QUEUE|OF_DISKACCESS|OF_ROM|OF_ABT3                     ; CmdReadXL
        dc.w  OF_QUEUE|OF_DISKACCESS|OF_ASYNC|OF_ABT2                   ; CmdPlayTrack
        dc.w  OF_QUEUE|OF_DISKACCESS|OF_ASYNC|OF_ABT2                   ; CmdPlayLSN
        dc.w  OF_QUEUE|OF_DISKACCESS|OF_ASYNC|OF_ABT2                   ; CmdPlayMSF
        dc.w  OF_QUEUE|OF_DISKACCESS|OF_ASYNC|OF_ABT2                   ; CmdPlaySegsLSN
        dc.w  OF_QUEUE|OF_DISKACCESS|OF_ASYNC|OF_ABT2                   ; CmdPlaySegsMSF
        dc.w  OF_QUEUE                                                  ; CmdTOCLSN
        dc.w  OF_QUEUE                                                  ; CmdTOCMSF
        dc.w  OF_QUEUE                                                  ; CmdSubQLSN
        dc.w  OF_QUEUE                                                  ; CmdSubQMSF
        dc.w  OF_QUEUE                                                  ; CmdPause
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdStopPlay
        dc.w  0                                                         ; CmdPokeSegLSN
        dc.w  0                                                         ; CmdPokeSegMSF
        dc.w  OF_NODISK                                                 ; CmdMute
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdFade
        dc.w  OF_QUEUE                                                  ; CmdPokePlayLSN
        dc.w  OF_QUEUE                                                  ; CmdPokePlayMSF
        dc.w  OF_NODISK                                                 ; CmdGenLock

        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdPlayMode
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdReadMode

        dc.w  0




CmdPorts:
        dc.w  0
        dc.w  0     ; Reset
        dc.w  1     ; Read
        dc.w  0     ; Write
        dc.w  0     ; Update
        dc.w  0     ; Clear
        dc.w  0     ; Stop
        dc.w  0     ; Start
        dc.w  0     ; Flush
        dc.w  1     ; Motor
        dc.w  1     ; Seek
        dc.w  0     ; Format
        dc.w  0     ; Remove
        dc.w  0     ; ChangeNum
        dc.w  0     ; ChangeState
        dc.w  0     ; ProtStatus
        dc.w  0     ; NoCommand
        dc.w  0     ; NoCommand
        dc.w  0     ; CmdGetDriveType
        dc.w  0     ; CmdGetNumTracks
        dc.w  2     ; CmdAddChangeInt
        dc.w  2     ; CmdRemChangeInt
        dc.w  0     ; CmdGetGeometry
        dc.w  0     ; CmdEject
        dc.w  0     ; NoCommand
        dc.w  0     ; NoCommand
        dc.w  0     ; NoCommand
        dc.w  0     ; NoCommand
        dc.w  0     ; NoCommand
        dc.w  0     ; NoCommand
        dc.w  0     ; NoCommand
        dc.w  0     ; NoCommand
*
        dc.w  -1    ; CmdDirect
        dc.w  -1    ; CmdStatus
        dc.w  -1    ; CmdQuickStatus
        dc.w  -1    ; CmdInfo
        dc.w  -1    ; CmdErrorInfo
        dc.w  -1    ; CmdIsROM
        dc.w  -1    ; CmdOptions
        dc.w  -1    ; CmdFrontPanel
        dc.w  3     ; CmdFrameCall
        dc.w  -1    ; CmdFrameCount
        dc.w  1     ; CmdReadXL
        dc.w  1     ; CmdPlayTrack
        dc.w  1     ; CmdPlayLSN
        dc.w  1     ; CmdPlayMSF
        dc.w  1     ; CmdPlaySegsLSN
        dc.w  1     ; CmdPlaySegsMSF
        dc.w  -1    ; CmdTOCLSN
        dc.w  -1    ; CmdTOCMSF
        dc.w  0     ; CmdSubQLSN
        dc.w  0     ; CmdSubQMSF
        dc.w  -1    ; CmdPause
        dc.w  -1    ; CmdStopPlay
        dc.w  1     ; CmdPokeSegLSN
        dc.w  1     ; CmdPokeSegMSF
        dc.w  -1    ; CmdMute
        dc.w  -1    ; CmdFade
        dc.w  1     ; CmdPokePlayLSN
        dc.w  1     ; CmdPokePlayMSF
        dc.w  -1    ; CmdGenLock

        dc.w  -1    ; CmdPlayMode
        dc.w  -1    ; CmdReadMode

        dc.w  0


TimerDevName:   dc.b    "timer.device",0,0



 FUNCTION CDBeginIO

                save    d0-d1/a1/a2                                     ; Get device base to cdtv.device
                save    a1
                move.l  $4,a0
                lea     DeviceList(a0),a0
                lea     DevName(pc),a1
                exec    FindName
                move.l  d0,a2
                restore a1

                cmp.w   #CD_READ,IO_COMMAND(a1)                         ; If this is a Read command, is a Play command active?
                bne     2$
                move.l  db_IORD(a2),a1
                move.w  IO_COMMAND(a1),d0
                cmp.w   #CD_PLAYTRACK,d0
                beq     1$
                cmp.w   #CD_PLAYMSF,d0
                beq     1$
                cmp.w   #CD_PLAYLSN,d0
                bne     2$
1$              exec    AbortIO                                         ; - Abort the Play command
2$
                move.l  a2,a0
                restore d0-d1/a1/a2

                move.l  db_CDBeginIO(a0),a0                             ; Jump to CD's BeginIO
                jmp     (a0)









*
************************************************************************
***
***  BEGINIO
***
***     Process an I/O request.
***
***     This function is called with:
***             A1 -> IO Request Structure
***             A6 -> Device Node
***
************************************************************************

BeginIO:
                save    a1/a2/ior
                move.l  a1,ior

                jsr     PERFORMIO(db)                                   ; Execute the command now and reply (return)
                restore a1/a2/ior
                rts

*
************************************************************************
***
***  ABORTIO
***
***     Abort an IO Request that is queued or in progress.
***
************************************************************************

AbortIO:
                save    ior
                move.l  a1,ior

;                PRINT   51$,52$,"***CDTV:_ABORTIO"

                move.w  IO_COMMAND(a1),d0                               ; It ain't pretty, but it works.
                cmp.w   #CDTV_FRAMECALL,d0
                bne     2$
                move.l  #-1,db_CallAddress(db)
1$              tst.l   db_CallAddress(db)
                bne     1$

                move.l  ior,a1
                exec    ReplyMsg
                bra     99$
2$
                lsl.l   #1,d0
                lea     CmdPorts(pc),a0
                move.w  0(a0,d0.w),d0

                move.l  IO_UNIT(a1),a1

                tst.w   d0
                bmi     99$

                bne     3$
                move.l  UNIT_IORA(a1),a1
                bra     9$
3$
                cmp.w   #1,d0
                bne     4$
                move.l  db_IORD(db),a1
                bra     9$
4$
                cmp.w   #2,d0
                bne     9$
                move.l  UNIT_IORChg(a1),a1
9$
                exec    AbortIO
99$
                restore ior
                rts

************************************************************************
***
***  PERFORMIO
***
***     Dispatch to the appropriate command handling code.
***
************************************************************************

PerformIO:

;                jsr     PrintCommand

                clr.l   d0                                              ; Execute Command
                move.w  IO_COMMAND(ior),d0

                addq.l  #8,d0
                muls    #-6,d0
                jsr     0(db,d0.w)

;                clr.l   d0
;                move.b  IO_ERROR(ior),d0
;                beq     1$
;                jsr     PutHex
;1$
;                move.b  #10,d0
;                jsr     PutChar
                rts




PrintCommand:
                move.b  #'*',d0
                jsr     PutChar
                jsr     PutChar
                jsr     PutChar
                move.b  #'C',d0
                jsr     PutChar
                move.b  #'D',d0
                jsr     PutChar
                move.b  #'T',d0
                jsr     PutChar
                move.b  #'V',d0
                jsr     PutChar
                move.b  #':',d0
                jsr     PutChar
                move.b  #' ',d0
                jsr     PutChar

                clr.l   d0
                move.w  IO_COMMAND(ior),d0
                jsr     PutHex
                move.l  IO_OFFSET(ior),d0
                jsr     PutHex
                move.l  IO_LENGTH(ior),d0
                jsr     PutHex
                move.l  IO_DATA(ior),d0
                jsr     PutHex

                rts

*
************************************************************************
***
***  DEVICE COMMANDS
***
***     Primary functions to support drive commands.  These are
***     ordered in logical groups below.
***
************************************************************************

******* Reset **********************************************************

CmdReset:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                clr.l   IO_ACTUAL(ior)                                  ; Return results
                clr.b   IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts


*
******* Read ***********************************************************

CmdRead:
                move.l  db_IORD(db),a1
                move.w  IO_COMMAND(a1),d0
                cmp.w   #CD_PLAYTRACK,d0
                beq     1$
                cmp.w   #CD_PLAYMSF,d0
                beq     1$
                cmp.w   #CD_PLAYLSN,d0
                bne     2$
1$
                bset    #0,db_abortedflags(db)
                exec    AbortIO
2$
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  db_IORD(db),a2                                  ; Send new IORequest

                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                move.b  IO_FLAGS(ior),IO_FLAGS(a2)

                lea     db_DiskPort(db),a0
                move.l  ior,a1
                exec    PutMsg
                rts


*
******* ReadXL *********************************************************

CmdReadXL:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                lea     db_DiskPort(db),a0
                move.l  ior,a1
                exec    PutMsg
                rts


*
******* Seek ***********************************************************

CmdSeek:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  db_IORD(db),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)

                lea     db_DiskPort(db),a0
                move.l  ior,a1
                exec    PutMsg
                rts



******* Motor **********************************************************

CmdMotor:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                clr.l   IO_ACTUAL(ior)                                  ; Return results
                clr.b   IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts



*
******* ChangeNum ******************************************************

CmdChangeNum:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts


******* ChangeState ****************************************************

CmdChangeState:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts


******* AddChangeInt ***************************************************

NoResetRemove:
                dc.l    TAGCD_EJECTRESET,0
                dc.l    TAG_END,0

ResetRemove:
                dc.l    TAGCD_EJECTRESET,1
                dc.l    TAG_END,0


CmdAddChangeInt:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                ; Send new IORequest

                move.w  #CD_CONFIG,IO_COMMAND(a2)
                lea     NoResetRemove(pc),a0
                move.l  a0,IO_DATA(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORChg(a2),a2                              ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    SendIO

                move.b  IO_ERROR(a2),IO_ERROR(ior)
                rts


******* RemChangeInt ***************************************************

CmdRemChangeInt:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                ; Send new IORequest

                move.w  #CD_CONFIG,IO_COMMAND(a2)
                lea     ResetRemove(pc),a0
                move.l  a0,IO_DATA(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORChg(a2),a2                              ; Send new IORequest
                move.w  #CD_REMCHANGEINT,IO_COMMAND(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  ior,a1
                exec    ReplyMsg
                rts



******* ProtStatus *****************************************************

CmdProtStatus:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts


******* GetDriveType ***************************************************

CmdGetDriveType:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts


******* GetNumTracks ***************************************************

CmdGetNumTracks:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts


******* GetGeometry ****************************************************

CmdGetGeometry:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts

*
******* PlayTrack ******************************************************

CmdPlayTrack:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  db_IORD(db),a2                                  ; Send new IORequest

                move.w  #CD_PLAYTRACK,IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),d0
                bne     1$
                move.l  IO_OFFSET(ior),d0
                add.l   #1,d0
1$              sub.l   IO_OFFSET(ior),d0
                move.l  d0,IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)

                lea     db_DiskPort(db),a0
                move.l  ior,a1
                exec    PutMsg
                rts

*
******* PlayLSN ********************************************************

CmdPlayLSN:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  db_IORD(db),a2                                  ; Send new IORequest
                move.w  #CD_PLAYLSN,IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)

                lea     db_DiskPort(db),a0
                move.l  ior,a1
                exec    PutMsg
                rts


******* PlayMSF ********************************************************

CmdPlayMSF:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  db_IORD(db),a2                                  ; Send new IORequest

                move.w  #CD_PLAYLSN,IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),d0
                jsr     MSFtoLSN
                move.l  d0,d1
                move.l  IO_OFFSET(ior),d0
                jsr     MSFtoLSN
                sub.l   d0,d1
                move.l  d1,IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),d0
                jsr     MSFtoLSNPOS
                move.l  d0,IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)

                lea     db_DiskPort(db),a0
                move.l  ior,a1
                exec    PutMsg
                rts



******* PokePlayLSN ****************************************************

CmdPokePlayLSN:
                move.l  db_IORD(db),a1
                exec    AbortIO

                bra     CmdPlayLSN



******* PokePlayMSF ****************************************************

CmdPokePlayMSF:
                move.l  db_IORD(db),a1
                exec    AbortIO

                bra     CmdPlayMSF

*
******* StopPlay *******************************************************

CmdStopPlay:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  db_IORD(db),a1
                exec    AbortIO

                clr.l   IO_ACTUAL(ior)                                  ; Return results
                clr.b   IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts


******* PlaySegsLSN ****************************************************

CmdPlaySegsLSN:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  ior,a1
                exec    ReplyMsg
                rts



******* PlaySegsMSF ****************************************************

CmdPlaySegsMSF:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  ior,a1
                exec    ReplyMsg
                rts


*
******* PokeSegLSN *****************************************************

CmdPokeSegLSN:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  ior,a1
                exec    ReplyMsg
                rts


******* PokeSegMSF *****************************************************

CmdPokeSegMSF:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  ior,a1
                exec    ReplyMsg
                rts


*
******* CmdTOCLSN ******************************************************

CmdTOCLSN:
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  #CD_TOCLSN,IO_COMMAND(a2)
                bra     CmdTOC


******* CmdTOCMSF ******************************************************

CmdTOCMSF:
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  #CD_TOCMSF,IO_COMMAND(a2)
CmdTOC:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                          ; Clear IOB_QUICK

                lea     db_TOC(db),a1
                move.l  a1,IO_DATA(a2)
                move.l  IO_LENGTH(ior),d0
                cmp.l   #100,d0
                bls     0$
                move.l  #100,d0
0$              move.l  d0,IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                tst.b   IO_ERROR(a2)
                bne     91$

                save    d2
                move.l  IO_ACTUAL(a2),d2
                beq     90$

                lea     db_TOC(db),a0
                move.l  IO_DATA(ior),a1
1$
                cmp.l   IO_ACTUAL(a2),d2                                ; Is this summary information?
                bne     3$
                tst.l   IO_OFFSET(ior)
                bne     3$

                clr.w   (a1)+                                           ; Copy summary information
                move.b  (a0)+,(a1)+
                move.b  (a0)+,(a1)+
                move.l  (a0)+,(a1)+
                bra     4$
3$
                clr.b   (a1)+                                           ; Copy entry information
                move.b  (a0),d0
                lsr.b   #4,d0
                and.b   #$0f,d0
                move.b  (a0)+,d1
                lsl.b   #4,d1
                and.b   #$f0,d1
                or.b    d1,d0
                move.b  d0,(a1)+
                move.b  (a0)+,(a1)+
                clr.b   (a1)+
                move.l  (a0)+,(a1)+
4$
                sub.l   #1,d2
                bne     1$
                restore d2
90$
                move.l  IO_ACTUAL(a2),d0                                ; Calculate IO_ACTUAL

                tst.l   IO_OFFSET(ior)                                  ; Subtract 1 if summary information was returned
                bne     91$
                subq.l  #1,d0

                cmp.l   #1,IO_LENGTH(ior)                               ; If only summary info was requested, return 1
                bne     91$
                move.l  #1,d0
91$
                move.l  d0,IO_ACTUAL(ior)
                move.b  IO_ERROR(a2),IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts



*
******* SubQLSN ********************************************************

CmdSubQLSN:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  #CD_QCODELSN,IO_COMMAND(a2)
                lea     db_QCode(db),a0
                move.l  a0,IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_DATA(ior),a0
                move.b  #$11,0(a0)
                clr.l   d0
                move.b  db_QCode(db),d0
                move.b  d0,d1
                lsr.w   #4,d1
                lsl.w   #4,d0
                or.b    d0,d1
                move.b  d1,1(a0)
                move.b  db_QCode+1(db),2(a0)
                move.b  db_QCode+2(db),3(a0)
                move.l  db_QCode+4(db),8(a0)
                move.l  db_QCode+8(db),4(a0)
                clr.l   $c(a0)

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts


******* SubQMSF ********************************************************

CmdSubQMSF:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest

                move.w  #CD_QCODEMSF,IO_COMMAND(a2)
                lea     db_QCode(db),a0
                move.l  a0,IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_DATA(ior),a0
                move.b  #$11,0(a0)
                clr.l   d0
                move.b  db_QCode(db),d0
                move.b  d0,d1
                lsr.w   #4,d1
                lsl.w   #4,d0
                or.b    d0,d1
                move.b  d1,1(a0)
                move.b  db_QCode+1(db),2(a0)
                move.b  db_QCode+2(db),3(a0)
                move.l  db_QCode+4(db),8(a0)
                move.l  db_QCode+8(db),4(a0)
                clr.l   $c(a0)

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts


*
******* FrameCall ******************************************************

CmdFrameCall:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  IO_DATA(ior),db_CallAddress(db)

                tst.l   db_IORFrm(db)
                bne     97$

                moveq.l #0,d1                                           ; Init interrupt server
                lea     FrameInt(pc),a0
                lea     db_FrameIntStruct(db),a1
                bsr     InitIntr

                exec    CreateMsgPort                                   ; Create msg port Frm
                move.l  d0,db_PortFrm(db)
                beq     98$

                move.l  d0,a1
                lea     db_FrameIntStruct(db),a0
                move.l  a0,MP_SIGTASK(a1)
                move.b  #PA_SOFTINT,MP_FLAGS(a1)

                move.l  db_PortFrm(db),a0                               ; Create I/O request Frm
                move.l  #IOTV_SIZE,d0
                exec    CreateIORequest
                move.l  d0,db_IORFrm(db)
                beq     98$

                lea     TimerDevName(pc),a0
                move.l  #UNIT_MICROHZ,d0
                move.l  db_IORFrm(db),a1
                clr.l   d1
                exec    OpenDevice
                tst.b   d0
                bne     98$
97$
                jsr     SendTimerReq
98$
                rts




************************************************************************
*                                                                      *
*   FrameInt - Frame call interrupt processor                          *
*                                                                      *
************************************************************************

 FUNCTION FrameInt
                save    d2/ior/db                                       ; Load up registers

                move.l  a1,db
                move.l  db_IORFrm(db),ior

                lea     db_PortFrm(db),a0                               ; Remove the request
                exec    GetMsg

                move.l  db_CallAddress(db),d2                           ; This is a bogus way of doing it, but who cares for this
                beq     99$
                cmp.l   #-1,d2
                bne     1$
                clr.l   db_CallAddress(db)
                bra     99$
1$
                add.l   #1,db_FrameCount(db)

                jsr     SendTimerReq                                    ; Start new request

                move.l  d2,a0                                           ; Call interrupt with IOReq in A2
                save    a2
                move.l  ior,a2
                jsr     (a0)
                restore a2
99$
                restore d2/ior/db
                clr.w   d0                                              ; Clear server chain
                rts


************************************************************************
*                                                                      *
*   SendTimerReq - Send a timer interrupt request                      *
*                                                                      *
************************************************************************

 FUNCTION SendTimerReq

                move.l  db_IORFrm(db),a1
                clr.l   IOTV_TIME+TV_SECS(a1)
                move.l  #13333,IOTV_TIME+TV_MICRO(a1)
                move.w  #TR_ADDREQUEST,IO_COMMAND(a1)
                clr.b   IO_ERROR(a1)

                exec    SendIO
                rts



******* FrameCount *****************************************************

CmdFrameCount:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  db_FrameCount(db),IO_ACTUAL(ior)                ; Return results
                clr.b   IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts


*
******* Pause **********************************************************

CmdPause:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  #CD_PAUSE,IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts


******* Fade ***********************************************************

CmdFade:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  #CD_ATTENUATE,IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts


*
******* Mute ***********************************************************

CmdMute:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                ; Send new IORequest
                move.w  #CD_ATTENUATE,IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                clr.l   IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                tst.l   IO_LENGTH(ior)
                bne     1$
                move.l  #-1,IO_OFFSET(a2)
1$              clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts




******* Status *********************************************************

CmdStatus:
CmdQuickStatus:
                move.l  db_IORD(db),a0                                  ; Get drive status
                move.l  IO_DEVICE(a0),a0
                move.w  CDStatus(a0),d1

                move.l  #$09,d0

                btst    #CDSTSB_DISK,d1
                beq     1$
                or.l    #QSF_DISK,d0
1$
                btst    #CDSTSB_SPIN,d1
                beq     2$
                or.l    #QSF_SPIN,d0
2$
                btst    #CDSTSB_PLAYING,d1
                beq     3$
                or.l    #QSF_AUDIO,d0
3$
                move.l  d0,IO_ACTUAL(ior)                                  ; Return results
                clr.b   IO_ERROR(ior)

                btst.b  #IOB_QUICK,IO_FLAGS(ior)
                bne     4$
                move.l  ior,a1
                exec    ReplyMsg
4$
                rts


******* ErrorInfo ******************************************************

CmdErrorInfo:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                clr.l   IO_ACTUAL(ior)                                  ; Return results
                clr.b   IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg

                rts


*
******* Info ***********************************************************

CmdInfo:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                cmp.l   #CDTV_INFO_BLOCK_SIZE,IO_OFFSET(ior)
                bne     1$
                move.l  #2048,IO_ACTUAL(ior)
1$
                cmp.l   #CDTV_INFO_FRAME_RATE,IO_OFFSET(ior)
                bne     2$
                move.l  #75,IO_ACTUAL(ior)
2$
                clr.b   IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts



******* Eject **********************************************************

CmdEject:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                clr.l   IO_ACTUAL(ior)                                  ; Return results
                clr.b   IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts



******* IsROM **********************************************************

CmdIsROM:
                clr.l   IO_ACTUAL(ior)                                  ; Return results
                clr.b   IO_ERROR(ior)

                move.l  db_IORD(db),a0                                  ; Get drive status
                move.l  IO_DEVICE(a0),a0
                move.w  CDStatus(a0),d0
                btst    #CDSTSB_CDROM,d0
                beq     1$
                move.l  #-1,IO_ACTUAL(ior)
1$
                btst.b  #IOB_QUICK,IO_FLAGS(ior)
                bne     2$
                move.l  ior,a1
                exec    ReplyMsg
2$
                rts


*
******* FrontPanel *****************************************************

CmdFrontPanel:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                clr.l   IO_ACTUAL(ior)                                  ; Return results
                clr.b   IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts


******** CmdGenLock ****************************************************

CmdGenLock:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                clr.l   IO_ACTUAL(ior)                                  ; Return results
                clr.b   IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts


*
******* PlayMode *******************************************************

CmdPlayMode:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                clr.l   IO_ACTUAL(ior)                                  ; Return results
                clr.b   IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts


*
******* ReadMode *******************************************************

CmdReadMode:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                clr.l   IO_ACTUAL(ior)                                  ; Return results
                clr.b   IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts



******* Illegal Commands ***********************************************

CmdFormat:
CmdWrite:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.b  #CDERR_WriteProt,IO_ERROR(ior)                  ; All disks are write protected

                move.l  ior,a1
                exec    ReplyMsg
                rts



TagList2048:
                dc.l    TAGCD_SECTORSIZE,2048
                dc.l    TAG_END,0

TagList2336:
                dc.l    TAGCD_SECTORSIZE,2336
                dc.l    TAG_END,0


CmdOptions:
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest

                move.l  IO_OFFSET(ior),d0
                bne.s   co_bs
                bra.s   co_exit

        ;------ If 1: set block size
co_bs:          subq.w  #1,d0
                bne.s   co_er
                move.l  IO_LENGTH(ior),d0

                cmp.l   #2336,d0
                blo     1$
                lea     TagList2336(pc),a0
                move.l  #2336,d0
                bra     2$
1$
                lea     TagList2048(pc),a0
                move.l  #2048,d0
2$
                move.l  d0,db_BlockSize(db)
                move.w  #CD_CONFIG,IO_COMMAND(a2)
                move.l  a0,IO_DATA(a2)
                move.l  a2,a1
                exec    DoIO

                bra.s   co_exit

        ;------ If 2: set error recovery
co_er:          subq.w  #1,d0
co_exit:
                rts


******* Dummy Commands *************************************************

CmdUpdate:                                                              ; These commands do nothing
CmdClear:
CmdStop:
CmdStart:
CmdFlush:
CmdRemove:
NoCommand:

                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Choose a port and queue the command
                move.l  ior,a1
                exec    ReplyMsg
                rts


@


1.15
log
@Changed frame interrupt stuff to used unadded intserver.
Fixed TOCMSF leadout time.
@
text
@d1208 1
@


1.14
log
@CDTV_TOC commands now do not crash when a disk is not in the drive.
@
text
@d1056 1
a1056 5
                move.l  (a0)+,d0
                cmp.w   #CDTV_TOCLSN,IO_COMMAND(ior)
                bne     2$
                jsr     LSNtoMSFPOS
2$              move.l  d0,(a1)+
d1184 1
a1184 3
                bne     99$

                move.l  ior,db_FrameReq(db)                             ; This is our IOR
d1186 1
a1186 2
                moveq.l #INTB_PORTS,d0                                  ; Initialize and add interrupt server
                moveq.l #32,d1
d1192 1
d1194 6
a1199 2
                move.l  d0,db_PortFrm(db)
                
a1201 1

d1203 1
a1204 6
                move.l  d0,db_IORFrm(db)

                move.l  db_IORFrm(db),a1
                lea     db_FrameIntStruct(db),a0
                move.l  a0,MN_REPLYPORT(a1)
                move.b  #PA_SOFTINT,IO_FLAGS(a1)
d1210 1
d1212 1
a1212 1

d1215 1
a1215 2
                move.b  IO_ERROR(a1),IO_ERROR(ior)
99$             rts
d1253 1
a1253 1
                move.w  #1,d0                                           ; Clear server chain
@


1.13
log
@TOCMSF returned in IO_ACTUAL what the documentation said it
should and not what cdtv.device actually did.
@
text
@d1037 3
@


1.12
log
@IOB_QUICK IO now supported for QuickStatus and ROMData.

Reset on disk removal disable when a change interrupt is installed.
CMD_RESET does not do IO anymore.
@
text
@d1024 1
a1024 1
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK
d1040 1
a1040 1
                beq     99$
d1076 11
a1086 3
99$
                move.l  IO_ACTUAL(a2),d0                                ; Return results
                add.l   IO_OFFSET(ior),d0
@


1.11
log
@Read abort play fix.
@
text
@d94 24
d572 2
a573 11
                move.l  db_IORD(db),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)
d707 9
d720 10
a729 1
                move.l  UNIT_IORChg(a2),a2                                ; Send new IORequest
d748 10
a757 1
                move.l  UNIT_IORChg(a2),a2                                ; Send new IORequest
d1366 3
a1368 3
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                jsr     GetInfo
a1371 1
                move.w  db_Info+CDINFO_Status(db),d1
d1387 2
d1391 1
a1447 4
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                jsr     GetInfo

d1451 3
a1453 1
                move.w  db_Info+CDINFO_Status(db),d0
d1458 2
d1462 1
a1596 15
******* Do a CD_INFO command *******************************************

GetInfo:
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                ; Send new IORequest
1$
                move.w  #CD_INFO,IO_COMMAND(a2)
                lea     db_Info(db),a0
                move.l  a0,IO_DATA(a2)
                move.l  #CDINFO_SIZE,IO_LENGTH(a2)
                clr.l   IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO
                rts
@


1.10
log
@Added options command.
@
text
@d569 12
@


1.9
log
@Fixed Mute command.
@
text
@a590 2
                move.l  db_IORD(db),a2                                  ; Send new IORequest

d1477 47
a1531 1
CmdOptions:
@


1.8
log
@no effective change.
@
text
@d976 5
a980 1
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
d1288 1
a1288 1
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
d1292 5
a1296 2
                clr.l   IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
@


1.7
log
@Implemented READXL command.
@
text
@d491 5
@


1.6
log
@Modified PlayTrack to accept 0 length.
StopPlay should now actually abort play.
@
text
@d52 2
d432 1
a432 1
                PRINT   51$,52$,"***CDTV:_ABORTIO"
d482 1
a482 1
                jsr     PrintCommand
d491 2
a492 2
                move.b  #10,d0
                jsr     PutChar
a586 12
                move.w  #CD_READ,IO_COMMAND(a2)
                move.l  IO_DATA(ior),a0
                move.l  LN_SUCC(a0),IO_DATA(a2)



                clr.l   IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),d0
                asl.l   #8,d0
                asl.l   #3,d0
                move.l  d0,IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
d852 1
a852 1
                move.w  #CD_PLAYMSF,IO_COMMAND(a2)
d860 4
a863 4
                move.l  d1,d0
                jsr     LSNtoMSF
                move.l  d0,IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
d984 3
a986 1
                cmp.l   IO_ACTUAL(a2),d2
d989 1
a989 1
                clr.w   (a1)+
d995 1
a995 1
                jsr     LSNtoMSF
d999 1
a999 1
                clr.b   (a1)+
d1016 3
a1018 1
                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
d1074 1
a1074 1
1$
a1083 3
                tst.b   IO_ERROR(a2)
                bne     1$

a1098 8
                clr.l   d1
                clr.l   d0
2$              move.b  0(a0,d1),d0
                jsr     PutHex
                addq.l  #1,d1
                cmp.l   #16,d1
                bne     2$

a1101 3
                clr.l   IO_ACTUAL(ior)                    ; Return results
                clr.b   IO_ERROR(ior)

d1233 1
a1233 1
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
@


1.5
log
@Added frame interrupts.
Fixed TOC commands (not completely).
@
text
@d823 4
a826 1
                sub.l   IO_OFFSET(ior),d0
d906 3
@


1.4
log
@added code for READXL (don't know if it works).
@
text
@d30 1
d63 1
d284 1
d355 1
a355 1

d427 3
d432 6
a437 2
                move.l  a1,d0
                jsr     PutHex
d439 4
a442 1
                move.w  IO_COMMAND(a1),d0
a448 2
                jsr     PutHex

d452 1
a452 1
                bne     1$
d455 1
a455 1
1$
d457 1
a457 1
                bne     2$
d460 1
a460 1
2$
d462 1
a462 1
                bne     3$
a463 3
                bra     9$
3$
                move.l  UNIT_IORFrm(a1),a1
a464 3
                move.l  a1,d0
                jsr     PutHex

d466 3
a468 1
99$             rts
d585 1
a585 1
                move.w  #CD_READXL,IO_COMMAND(a2)
d588 3
d711 1
d713 1
a713 1
                exec    AbortIO
d883 2
a884 8
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  db_IORD(db),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
d886 1
a886 4
                lea     db_DiskPort(db),a0
                move.l  ior,a1
                exec    PutMsg
                rts
d893 2
a894 8
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

                move.l  db_IORD(db),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
d896 1
a896 4
                lea     db_DiskPort(db),a0
                move.l  ior,a1
                exec    PutMsg
                rts
a916 8
                move.l  db_IORD(db),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)

                lea     db_DiskPort(db),a0
d918 1
a918 1
                exec    PutMsg
a927 8
                move.l  db_IORD(db),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)

                lea     db_DiskPort(db),a0
d929 1
a929 1
                exec    PutMsg
a932 1

a938 8
                move.l  db_IORD(db),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)

                lea     db_DiskPort(db),a0
d940 1
a940 1
                exec    PutMsg
a943 1

a948 8
                move.l  db_IORD(db),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)

                lea     db_DiskPort(db),a0
d950 1
a950 1
                exec    PutMsg
a953 1

a957 2
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Clear IOB_QUICK

d960 2
a961 14
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

                move.l  ior,a1
                exec    ReplyMsg
                rts
a963 1

d967 4
d973 17
a989 9
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO
d991 27
d1026 1
d1127 94
a1220 5
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORFrm(a2),a2                                ; Send new IORequest
                move.l  IO_DEVICE(a2),IO_DEVICE(ior)
                move.l  IO_UNIT(a2),IO_UNIT(ior)
                move.l  ior,a1
d1231 2
a1232 12
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)
d1290 14
a1303 1
                clr.l   IO_ACTUAL(ior)
a1304 2
                btst.b  #IOB_QUICK,IO_FLAGS(ior)
                bne     1$
a1306 1
1$
d1311 1
d1318 18
a1335 1
                clr.l   IO_ACTUAL(ior)                                  ; Return results
d1398 2
d1403 5
d1498 15
@


1.3
log
@Mods made to make disk commands work better.
@
text
@d473 1
a473 1
;                jsr     PrintCommand
d482 2
a483 2
;                move.b  #10,d0
;                jsr     PutChar
d579 2
a580 4
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),d0
                asl.l   #8,d0
                asl.l   #3,d0
@


1.2
log
@all kinds of changes.  This module basically works now (where as before it didn't).
@
text
@d358 1
a358 1
                save    d0-d7/a1-a6                                     ; Get device base to cdtv.device
d364 1
a364 1
                move.l  d0,db
d369 1
a369 1
                move.l  db_IORD(db),a1
d379 2
a380 2
                move.l  db,a0
                restore d0-d7/a1-a6
a406 2
                PRINT   1$,2$,"CDTV_BEGIN_IO"

d461 1
a461 3
99$
                PRINT   53$,54$,"***CDTV:_ABORTED"
                rts
d473 1
a473 1
                jsr     PrintCommand
d482 2
a483 2
                move.b  #10,d0
                jsr     PutChar
a556 11
                move.l  db_IORD(db),a1                                  ; Abort any outstanding Play Request
                move.w  IO_COMMAND(a1),d0
                cmp.w   #CDTV_PLAYTRACK,d0
                beq     1$
                cmp.w   #CDTV_PLAYMSF,d0
                beq     1$
                cmp.w   #CDTV_PLAYLSN,d0
                beq     1$
                bra     2$
1$              jsr     AbortIO
2$
d558 1
a563 2
                move.l  a2,a1
                exec    DoIO
d565 1
a565 3
                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

d567 1
a567 1
                exec    ReplyMsg
a588 2
                move.l  a2,a1
                exec    DoIO
d590 1
a590 3
                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

d592 1
a592 1
                exec    ReplyMsg
a607 2
                move.l  a2,a1
                exec    DoIO
d609 3
a611 2
                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)
d621 2
a622 11
                move.l  db_IORD(db),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)
a931 2
                move.l  a2,a1
                exec    DoIO
d933 1
a933 3
                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

d935 1
a935 1
                exec    ReplyMsg
a950 2
                move.l  a2,a1
                exec    DoIO
d952 1
a952 3
                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

d954 1
a954 1
                exec    ReplyMsg
a970 2
                move.l  a2,a1
                exec    DoIO
d972 1
a972 3
                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

d974 1
a974 1
                exec    ReplyMsg
a989 2
                move.l  a2,a1
                exec    DoIO
d991 1
a991 3
                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

d993 1
a993 1
                exec    ReplyMsg
@


1.1
log
@Initial revision
@
text
@d31 2
d36 2
a37 1
        INCLUDE "cdtv.i"
d56 1
a56 1
        XREF    Reserved
d61 1
d67 1
d110 1
a110 1
                DEVFUN  Reserved         ; -24
d114 1
a114 1
                DEVFUN  Reserved         ; -48
d282 111
d407 2
d411 1
d426 36
d463 2
d476 3
a481 2
                jsr     PutHex

d486 34
a519 1
                PRINT   1$,2$,":Done"
d538 1
a538 2
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORD(a2),a2                                  ; Send new IORequest
d561 12
a572 2
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORD(a2),a2                                  ; Send new IORequest
d595 2
a596 3
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORD(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
d598 8
a605 2
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
d624 1
a624 2
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORD(a2),a2                                  ; Send new IORequest
d644 1
a644 2
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORD(a2),a2                                  ; Send new IORequest
d841 3
a843 3
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORD(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
d845 9
a853 13
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  MN_REPLYPORT(a1),MN_REPLYPORT(a2)

                move.l  a2,a1
                exec    SendIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

;                move.l  ior,a1
;                exec    ReplyMsg
d862 2
a863 3
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORD(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
a867 1
                move.l  MN_REPLYPORT(a1),MN_REPLYPORT(a2)
d869 3
a871 8
                move.l  a2,a1
                exec    SendIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

;                move.l  ior,a1
;                exec    ReplyMsg
d880 3
a882 3
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORD(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
d884 15
a898 13
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  MN_REPLYPORT(a1),MN_REPLYPORT(a2)

                move.l  a2,a1
                exec    SendIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

;                move.l  ior,a1
;                exec    ReplyMsg
d908 1
a908 2
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORD(a2),a2                                  ; Send new IORequest
a913 1
                move.l  MN_REPLYPORT(a1),MN_REPLYPORT(a2)
d915 3
a917 8
                move.l  a2,a1
                exec    SendIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

;                move.l  ior,a1
;                exec    ReplyMsg
d927 1
a927 2
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORD(a2),a2                                  ; Send new IORequest
a932 1
                move.l  MN_REPLYPORT(a1),MN_REPLYPORT(a2)
d934 3
a936 8
                move.l  a2,a1
                exec    SendIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

;                move.l  ior,a1
;                exec    ReplyMsg
d945 2
a946 12
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)
d958 1
a958 2
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
d981 1
a981 2
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
d1005 1
a1005 2
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
d1028 1
a1028 2
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
d1102 3
a1104 2
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
d1107 22
a1128 7
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

d1141 4
a1144 2
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
d1151 26
d1180 3
a1187 1

a1199 1

d1258 1
a1258 1
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
d1295 2
a1296 12
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)
d1308 2
a1309 12
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)
d1323 11
a1333 14
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)

                move.l  ior,a1
d1344 2
a1345 12
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)
d1358 2
a1359 12
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)
d1372 2
a1373 12
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)
d1385 2
a1386 12
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)
d1399 2
a1400 12
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)
d1413 2
a1414 12
                move.l  IO_UNIT(ior),a2
                move.l  UNIT_IORA(a2),a2                                  ; Send new IORequest
                move.w  IO_COMMAND(ior),IO_COMMAND(a2)
                move.l  IO_DATA(ior),IO_DATA(a2)
                move.l  IO_LENGTH(ior),IO_LENGTH(a2)
                move.l  IO_OFFSET(ior),IO_OFFSET(a2)
                clr.b   IO_FLAGS(a2)
                move.l  a2,a1
                exec    DoIO

                move.l  IO_ACTUAL(a2),IO_ACTUAL(ior)                    ; Return results
                move.b  IO_ERROR(a2),IO_ERROR(ior)
@
