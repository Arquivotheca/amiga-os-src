head     1.47;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.47
date     94.03.22.10.29.25;  author jerryh;  state Exp;
branches ;
next     1.46;

1.46
date     94.03.22.10.10.30;  author jerryh;  state Exp;
branches ;
next     1.45;

1.45
date     94.03.22.09.15.55;  author jerryh;  state Exp;
branches ;
next     1.44;

1.44
date     94.03.14.10.43.52;  author jerryh;  state Exp;
branches ;
next     1.43;

1.43
date     94.02.04.14.52.32;  author jerryh;  state Exp;
branches ;
next     1.42;

1.42
date     94.01.26.11.08.14;  author jerryh;  state Exp;
branches ;
next     1.41;

1.41
date     94.01.26.11.06.14;  author jerryh;  state Exp;
branches ;
next     1.40;

1.40
date     94.01.26.10.49.52;  author jerryh;  state Exp;
branches ;
next     1.39;

1.39
date     93.11.15.16.25.56;  author jerryh;  state Exp;
branches ;
next     1.38;

1.38
date     93.11.03.13.35.58;  author jerryh;  state Exp;
branches ;
next     1.37;

1.37
date     93.10.20.11.07.54;  author jerryh;  state Exp;
branches ;
next     1.36;

1.36
date     93.10.20.10.36.12;  author jerryh;  state Exp;
branches ;
next     1.35;

1.35
date     93.10.14.13.46.08;  author jerryh;  state Exp;
branches ;
next     1.34;

1.34
date     93.10.14.09.46.51;  author jerryh;  state Exp;
branches ;
next     1.33;

1.33
date     93.09.16.14.28.20;  author jerryh;  state Exp;
branches ;
next     1.32;

1.32
date     93.05.18.15.48.35;  author jerryh;  state Exp;
branches ;
next     1.31;

1.31
date     93.05.18.11.56.49;  author jerryh;  state Exp;
branches ;
next     1.30;

1.30
date     93.05.18.11.28.23;  author jerryh;  state Exp;
branches ;
next     1.29;

1.29
date     93.05.12.14.23.35;  author jerryh;  state Exp;
branches ;
next     1.28;

1.28
date     93.04.19.14.16.41;  author jerryh;  state Exp;
branches ;
next     1.27;

1.27
date     93.04.16.12.04.15;  author jerryh;  state Exp;
branches ;
next     1.26;

1.26
date     93.04.12.11.26.20;  author jerryh;  state Exp;
branches ;
next     1.25;

1.25
date     93.04.08.10.59.51;  author jerryh;  state Exp;
branches ;
next     1.24;

1.24
date     93.04.08.10.39.35;  author jerryh;  state Exp;
branches ;
next     1.23;

1.23
date     93.03.23.13.50.09;  author jerryh;  state Exp;
branches ;
next     1.22;

1.22
date     93.03.23.13.28.11;  author jerryh;  state Exp;
branches ;
next     1.21;

1.21
date     93.03.22.10.24.18;  author jerryh;  state Exp;
branches ;
next     1.20;

1.20
date     93.03.19.11.07.17;  author jerryh;  state Exp;
branches ;
next     1.19;

1.19
date     93.03.17.16.58.10;  author jerryh;  state Exp;
branches ;
next     1.18;

1.18
date     93.03.17.13.29.32;  author jerryh;  state Exp;
branches ;
next     1.17;

1.17
date     93.03.15.11.55.15;  author jerryh;  state Exp;
branches ;
next     1.16;

1.16
date     93.03.15.11.52.58;  author jerryh;  state Exp;
branches ;
next     1.15;

1.15
date     93.03.15.10.34.21;  author jerryh;  state Exp;
branches ;
next     1.14;

1.14
date     93.03.12.16.53.35;  author jerryh;  state Exp;
branches ;
next     1.13;

1.13
date     93.03.12.10.21.15;  author jerryh;  state Exp;
branches ;
next     1.12;

1.12
date     93.03.10.13.15.00;  author jerryh;  state Exp;
branches ;
next     1.11;

1.11
date     93.03.10.11.28.20;  author jerryh;  state Exp;
branches ;
next     1.10;

1.10
date     93.02.24.14.16.18;  author jerryh;  state Exp;
branches ;
next     1.9;

1.9
date     93.02.23.11.09.28;  author jerryh;  state Exp;
branches ;
next     1.8;

1.8
date     93.02.19.16.30.12;  author jerryh;  state Exp;
branches ;
next     1.7;

1.7
date     93.02.09.16.22.37;  author jerryh;  state Exp;
branches ;
next     1.6;

1.6
date     93.01.22.11.58.08;  author jerryh;  state Exp;
branches ;
next     1.5;

1.5
date     92.12.18.11.39.45;  author jerryh;  state Exp;
branches ;
next     1.4;

1.4
date     92.11.20.12.06.30;  author jerryh;  state Exp;
branches ;
next     1.3;

1.3
date     92.11.17.16.50.15;  author jerryh;  state Exp;
branches ;
next     1.2;

1.2
date     92.11.16.13.25.23;  author jerryh;  state Exp;
branches ;
next     1.1;

1.1
date     92.08.20.14.04.18;  author jerryh;  state Exp;
branches ;
next     ;


desc
@main strap module.  Only boots from CD (no floppy, no hd).
@


1.47
log
@*** empty log message ***
@
text
@
#include <exec/types.h>
#include <exec/execbase.h>
#include <exec/memory.h>
#include <exec/io.h>
#include <exec/interrupts.h>
#include <libraries/dos.h>
#include <libraries/expansion.h>
#include <libraries/expansionbase.h>
#include <intuition/preferences.h>
#include <graphics/gfx.h>
#include <graphics/gfxbase.h>
#include <graphics/view.h>
#include <graphics/modeid.h>
#include <hardware/intbits.h>
#include <hardware/custom.h>
#include <devices/input.h>
#include <devices/inputevent.h>
#include <devices/audio.h>
#include <devices/trackdisk.h>
#include <dos/filehandler.h>
#include <internal/iprefs.h>
#include <utility/utility.h>
#include <internal/cdui.h>
#include <libraries/lowlevel.h>

#define EXEC_PRIVATE_PRAGMAS

#include <pragmas/exec_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include "pragmas/cardres_pragmas.h"
#include "pragmas/playerprefs_private_pragmas.h"
#include "pragmas/cdfs_pragmas.h"
#include "pragmas/debox_pragmas.h"
#include "pragmas/utility_pragmas.h"
#include "pragmas/nonvolatile_pragmas.h"
#include "pragmas/lowlevel_pragmas.h"
#include "cdgs:include/pragmas/videocd_pragmas.h"
#include "cdui/cdui_pragmas.h"
#include "/nofastmem/nofastmem_pragmas.h"

#include <clib/exec_protos.h>
#include <clib/graphics_protos.h>
#include <clib/dos_protos.h>
#include <clib/intuition_protos.h>
#include "clib/cardres_protos.h"
#include "clib/playerprefs_protos.h"
#include "clib/cdfs_protos.h"
#include "clib/debox_protos.h"
#include "clib/utility_protos.h"
#include "clib/nonvolatile_protos.h"
#include "clib/lowlevel_protos.h"
#include "cdgs:include/clib/videocd_protos.h"
#include "cdui/cdui_protos.h"
#include "/nofastmem/nofastmem_protos.h"

#include "gs:cd/cd.h"
#include "cdtv/cdtvprefs.h"
#include "gs:pplibrary/playerprefsbase.h"
#include "cdgs:include/libraries/videocd.h"
#include "cdtv:include/internal/card.h"
#include <cdtv/debox.h>

#include "cdstrap.h"
#include "functions.h"
#include "animation.h"

#pragma libcall IntuitionBase SetIPrefs 240 10803
APTR SetIPrefs(APTR ptr, LONG size, LONG type );

#pragma libcall CDUIBase StartCDUI 1e 00
struct MsgPort *StartCDUI(void);

#pragma libcall MPEGPlayerBase CDPlayer 1e 0
BOOL CDPlayer( void );


#define BUFF_SIZE (512*2)

extern char              __far ModIdent[];
extern struct CompHeader __far trademark;
extern struct CompHeader __far cdtvtm;
extern UBYTE *           __far picture;

int         Main(void);
int         MainLoop(struct V *V);
int         CheckTM(struct V *V);
int         PollXIPCard(struct V *V);
int         ScanBootList(struct V *V);
ULONG       OpenCDUI(struct V *V);
void        StripDevices(struct V *V);
void        StripMemory(struct V *V);
void        CenterScreen(struct V *V);
void        SendAnimMessage(int Msg);
void        RemoveReqZapper(struct V *V);

extern int  StartAnimation(void);
extern int  EjectReset(int Flag, struct V *V);
extern int  ChkSumFD(char *);

VOID __asm UnlinkRomTag(register __a0 struct Resident *kt);

extern struct Custom __far custom;

ULONG ReadGayle(void);

/*******************************************************************************************
 *                                                                                         *
 *  Main - CDStrap entry point.  Initializes/Frees CDStrap resources.                      *
 *                                                                                         *
 *  I'm not at all happy with the way this module works.  We really need to integrate this *
 *  in with strap.                                                                         *
 *                                                                                         *
 *******************************************************************************************/

int Main(void) {

struct V            Variables;
struct V           *V = &Variables;
struct UtilityBase *UtilityBase;
struct Library     *NVBase;
char               *ReservedArea;
ULONG               PortLong;

struct TagItem ConfigList[] = {

    { TAGCD_EJECTRESET,  1   },
    { TAG_END,           0   }
    };


struct TagItem ConfigDS[] = {

    { TAGCD_READSPEED,   150 },
    { TAG_END,           0   }
    };



    V->ExecBase          = *((struct ExecBase **)0x00000004L);                              /* Effectively open exec.library    */

#define SysBase (*((struct ExecBase **)0x00000004L))                                        /* Redirect exec calls through this */

    V->ExpansionBase    = (struct ExpansionBase *)OpenLibrary("expansion.library", 0L);     /* Open all relevant libraries      */
    V->GfxBase          = (struct GfxBase *)OpenLibrary("graphics.library", 0L);
    V->DeBoxBase        = (struct DeBoxBase *)OpenLibrary("debox.library", 0L);
    V->IntuitionBase    = (struct IntuitionBase *)OpenLibrary("intuition.library", 0L);
    V->CDFSBase         = (struct CDFSBase *)OpenLibrary("cdfs.library", 0L);
    V->CardResource     = (struct Library *)OpenResource((STRPTR)CARDRESNAME);
    V->PlayerPrefsBase  = (struct PlayerPrefsBase *)OpenLibrary("playerprefs.library", 0L);
    V->CDUIBase         = NULL;
    V->LowLevelBase     = OpenLibrary("lowlevel.library", 0);

#define ExpansionBase   V->ExpansionBase                                                    /* Redirect library calls           */
#define GfxBase         V->GfxBase
#define DeBoxBase       V->DeBoxBase
#define IntuitionBase   V->IntuitionBase
#define CDFSBase        V->CDFSBase
#define CardResource    V->CardResource
#define PlayerPrefsBase V->PlayerPrefsBase
#define CDUIBase        V->CDUIBase
#define LowLevelBase    V->LowLevelBase

    if (ExpansionBase && GfxBase && DeBoxBase && IntuitionBase && PlayerPrefsBase) {        /* Make sure all libraries openned  */

        if (UtilityBase = (struct UtilityBase *)OpenLibrary("utility.library", 0)) {        /* Open utility.library             */

            if (NVBase = OpenLibrary("nonvolatile.library", 0)) {                           /* Open nonvolatile.library         */

                if (ReservedArea = GetCopyNV("", "", TRUE)) {                               /* Get reserved nonvolatile memory  */

                    V->AudioBoot = ((ReservedArea[1] & 0x01) == 0);                         /* Go to player if audio disk here? */

                    UtilityBase->ub_Language = ReservedArea[0];                             /* First byte of reserved=language  */
                    FreeNVData(ReservedArea);
                    }

                CloseLibrary(NVBase);                                                       /* Done with nonvolaitle.library    */
                }

            CloseLibrary(UtilityBase);                                                      /* Done with utility.library        */
            }

        V->IOPort.mp_Flags     = 0;                                                         /* Init MsgPort and add to system   */
        V->IOPort.mp_SigBit    = AllocSignal(-1);
        V->IOPort.mp_SigTask   = FindTask(NULL);

        V->IOPort.mp_MsgList.lh_Head     = (struct Node *)&V->IOPort.mp_MsgList.lh_Tail;    /* NewList                          */
        V->IOPort.mp_MsgList.lh_Tail     = 0;
        V->IOPort.mp_MsgList.lh_TailPred = (struct Node *)&V->IOPort.mp_MsgList.lh_Head;

        V->IOReq.io_Message.mn_Node.ln_Type = NT_MESSAGE;                                   /* Init an I/O request              */
        V->IOReq.io_Message.mn_ReplyPort    = &V->IOPort;
        V->IOReq.io_Device                  = NULL;

        V->CDReq          = V->IOReq;                                                       /* Make 2 copies of the request     */
        V->SReq.iotd_Req  = V->IOReq;
        
        V->CardHandle = (struct CardHandle *)AllocMem((ULONG)sizeof(struct CardHandle),     /* Allocate card handle             */
                                                      MEMF_CLEAR);

        V->CardPolled = FALSE;                                                              /* Card has not yet been polled     */

        V->BootPri    = -32768;                                                             /* BootList not yet scanned         */

        V->CDChgCnt    = V->CardChgCnt  = -1;                                               /* Each device gets checked once    */
        V->TDChgCnt[0] = V->TDChgCnt[1] = V->TDChgCnt[2] = V->TDChgCnt[3] = -1;

        V->Animating = 0;

        if (!(PortLong = ReadJoyPort(1) & ~JP_TYPE_MASK))
              PortLong = ReadJoyPort(0) & ~JP_TYPE_MASK;

        if      (PortLong & JPF_BTN1) {

            CenterScreen(V);                                                                /* and make sure screen is centered */                            
 
            if (OpenCDUI(V)) {                                                              /* Don't allow animation to come up */

                SendAnimMessage(ANIMMSG_BLUE_BUTTON);
                SendAnimMessage(ANIMMSG_SHUTDOWN);
                ColdReboot();
                }
            }

        else if (PortLong & JPF_BTN2) {

            CenterScreen(V);                                                                /* and make sure screen is centered */                            
 
            if (OpenCDUI(V)) {                                                              /* Don't allow animation to come up */

                SendAnimMessage(ANIMMSG_RED_BUTTON);
                SendAnimMessage(ANIMMSG_SHUTDOWN);
                ColdReboot();
                }
            }

        if (!OpenDevice("cd.device", 0, &V->CDReq, 0)) {                                    /* cd.device better work            */

            switch (MainLoop(V)) {

                case -32766: /* AmigaCD Title */

                        if (ScanBootList(V) <= 2) {                                         /* Higher boot device present?      */

                            DoIOR(&V->CDReq, CD_CONFIG, 0, 0,                               /* Reset on disk removal            */
                                (UWORD *)&ConfigList[0], V);

                            if (!V->Animating) {

                                CenterScreen(V);                                            /* and make sure screen is centered */                            
                                if (!OpenCDUI(V)) break;                                    /* Do disk insertion Animation      */
                                }

                            if (!(ExpansionBase->Flags & EBF_DOSFLAG)) {

                                SendAnimMessage(ANIMMSG_HOLDOFFANIM);                       /* Booting an AmigaCD title         */
                                SendAnimMessage(ANIMMSG_BOOTING);
                                StripDevices(V);                                            /* Strip unneeded devices for memory*/
                                }

                            else SendAnimMessage(ANIMMSG_SHUTDOWN);

                            SysBase->LastAlert[3] = 0;                                      /* Turn off guru msgs otherwise     */
                            }

                        else {

                            RemoveReqZapper(V);                                             /* Remove request zapper            */
                            DoIOR(&V->CDReq, CD_CONFIG, 0, 0, (UWORD *)&ConfigDS[0], V);    /* Double speed when booting non CD */
                            }

                        break;

                case -32765: /* CDTV Title */

                        RemoveReqZapper(V);                                                 /* Remove request zapper            */

                        if (ScanBootList(V) <= 2) {                                         /* Higher boot device present?      */

                            if (V->Animating) {                                             /* Reboot if animation is present   */

                                SendAnimMessage(ANIMMSG_SHUTDOWN);                          /* Free animation now               */
                                ColdReboot();
                                }

                            else {                                                          /* Do CDTV kludges                  */

                                DoIOR(&V->CDReq, CD_CONFIG, 0, 0,                           /* Reset on disk removal            */
                                   (UWORD*)&ConfigList[0], V);

                                if (!(ExpansionBase->Flags & EBF_DOSFLAG)) InitScreen(V);   /* Perform kludges                  */
                                Kludges(V);
                                }

                            SysBase->LastAlert[3] = 0;                                      /* Turn off guru msgs.              */
                            }

                        else {

                            DoIOR(&V->CDReq, CD_CONFIG, 0, 0, (UWORD *)&ConfigDS[0], V);    /* Double speed when booting non CD */
                            }

                        break;

                default: /* Anything Else */

                        RemoveReqZapper(V);                                                 /* Remove request zapper            */
                        DoIOR(&V->CDReq, CD_CONFIG, 0, 0, (UWORD *)&ConfigDS[0], V);        /* Double speed when booting non CD */

                        if (V->Animating) {

                            SendAnimMessage(ANIMMSG_SHUTDOWN);                              /* Free animation now               */
                            ColdReboot();
                            }

                        break;
                }

            MountFS();                                                                      /* Start the file system            */
            }

        if (V->CardHandle) FreeMem(V->CardHandle, (ULONG)sizeof(struct CardHandle));

        FreeSignal(V->IOPort.mp_SigBit);
        }

    CloseLibrary((struct Library *)LowLevelBase);                                           /* Close openned libraries          */
    CloseLibrary((struct Library *)PlayerPrefsBase);
    CloseLibrary((struct Library *)CDFSBase);
    CloseLibrary((struct Library *)IntuitionBase);
    CloseLibrary((struct Library *)DeBoxBase);
    CloseLibrary((struct Library *)GfxBase);
    CloseLibrary((struct Library *)ExpansionBase);

    if (CDUIBase) CloseLibrary((struct Library *)CDUIBase);

    return(0);                                                                              /* All done                         */
    }



void StartCDPlayer1(struct V *V) {

    if (V->Animating) SendAnimMessage(ANIMMSG_SHUTDOWN);                                    /* Fade to black for player screen  */
    else              CenterScreen(V);                                                      /* Center the screen.               */

    InitAudio(V);                                                                           /* Do that vodo that you do so well */
    OwnBlitter();
    WaitBlit();
    custom.intena = INTF_BLIT;
    DisownBlitter();

    DoPlayer();                                                                             /* Ok, just run the old player      */
    }


void StartCDPlayer2(struct V *V) {

struct Library  *MPEGPlayerBase;
struct Resident *Resident;

    if (V->Animating) SendAnimMessage(ANIMMSG_SHUTDOWN);                                    /* Fade to black for player screen  */
    else              CenterScreen(V);                                                      /* Center the screen.               */

    InitAudio(V);                                                                           /* Do that vodo that you do so well */
    OwnBlitter();
    WaitBlit();
    custom.intena = INTF_BLIT;
    DisownBlitter();

    if (MPEGPlayerBase = OpenLibrary("mpegplayer.library", 0)) CDPlayer();                  /* Run the MPEG player              */

    else if (Resident = FindResident("mpegplayer.library")) {                               /* If not present, try finding it   */

        InitResident(Resident, 0);                                                          /* Found it, init it.               */

        if (MPEGPlayerBase = OpenLibrary("mpegplayer.library", 0)) CDPlayer();              /* Try running it now               */
        }

    DoPlayer();                                                                             /* Ok, just run the old player      */
    }

/***************************************************************************************
 *                                                                                     *
 *  Main boot device scanning loop.  Checks floppy drives, CD-ROM drives, and devices  *
 *  in the BootList for a device to boot off of.  When one is found, this loop         *
 *  terminates and returns.                                                            *
 *                                                                                     *
 *  out:  -32767 = XIP Card                                                            *
 *        -32766 = CDGS title present                                                  *
 *        -32765 = CDTV title present                                                  *
 *        else   = BootNode pri                                                        *
 *                                                                                     *
 ***************************************************************************************/

int MainLoop(struct V *V) {

struct CDInfo   CDInfo;
UWORD           Status, LastStatus = CDSTSF_CLOSED, AnimHeldOff = 0;
int             BootPri;
LONG            CDType, cnt;
struct Library *VideoCDBase;

    while (1) {                                                                         /* Loop forever.  return() gets us out  */

        if (PollXIPCard(V)) return(-32767);                                             /* poll for a execute-in-place card     */

        if ((Status = GetStatus(&V->CDReq, V)) != LastStatus) {                         /* Check for door close                 */

            if ((Status & CDSTSF_CLOSED) && !(LastStatus & CDSTSF_CLOSED)) {            /* Has door just been closed?           */

                SendAnimMessage(ANIMMSG_HOLDOFFANIM);                                   /* Tell animation task to not animate   */
                AnimHeldOff = 1;
                }

            LastStatus = Status;                                                        /* Remember our current state           */
            }

        if ((cnt = GetIOActual(&V->CDReq, CD_CHANGENUM, V)) > V->CDChgCnt) {            /* See if a CD change event has occured */

            V->CDChgCnt = cnt;                                                          /* Event being handled                  */

            if (!GetIOActual(&V->CDReq, CD_CHANGESTATE, V)) {                           /* Is there a disk now?                 */

                DoIOR(&V->CDReq, CD_INFO, 0, sizeof(struct CDInfo), (UWORD *)&CDInfo, V);

                if (!V->CDReq.io_Error && (CDInfo.Status & CDSTSF_CDROM)) {             /* Data disk?                           */

                    switch (CheckTM(V)) {                                               /* Check disk validity                  */

                        case 0:
                                if (VideoCDBase = OpenLibrary("videocd.library", 0)) {  /* No trademark, check disk type        */

                                    CDType = GetCDTypeA(NULL, NULL);                    /* Get type                             */

                                    if (  (CDType == CDT_KARAOKE)                       /* MPEG disk?                           */
                                       || (CDType == CDT_CDIFMV)
                                       || (CDType == CDT_VIDEOCD)) {

                                        CloseLibrary(VideoCDBase);                      /* Done with VideoCD library            */

                                        if ((ScanBootList(V) <= 2) || V->AudioBoot) {   /* Does audio player have priority?     */

                                            StartCDPlayer2(V);                          /* Start CD Player                      */
                                            }
                                        }

                                    CloseLibrary(VideoCDBase);                          /* Close VideoCD library                */
                                    }

                                if (AnimHeldOff) {                                      /* Not a valid disk                     */

                                    SendAnimMessage(ANIMMSG_FALSEALARM);                /* False alarm                          */
                                    AnimHeldOff = 0;
                                    }

                                break;

                        case 1: return(-32766);
                        case 2: return(-32765);
                        }
                    }

                else if ((ScanBootList(V) <= 2) || V->AudioBoot) StartCDPlayer1(V);     /* Run player if it has priority        */
                }

            else if (AnimHeldOff) {                                                     /* No disk, resume animation            */

                SendAnimMessage(ANIMMSG_FALSEALARM);
                AnimHeldOff = 0;
                }
            }

        if ((BootPri = ScanBootList(V)) != -32768) return(BootPri);                     /* BootList device present              */

        if (!V->Animating) {                                                            /* If we didn't start booting something,*/

            CenterScreen(V);                                                            /* center the screen...                 */
            if (OpenCDUI(V)) SendAnimMessage(ANIMMSG_STARTUP);                          /* and start animation                  */
            }

        WaitTOF();                                                                      /* Give animation some time to run      */
        }
    }



/*******************************************************************************************
 *                                                                                         *
 *  CheckTM - Check for trademark information on CDs.                                      *
 *                                                                                         *
 *  out:    result = 0 - no trademark, 1 = CDGS trademark, 2 = CDTV trademark              *
 *                                                                                         *
 *******************************************************************************************/

int CheckTM(struct V *V) {

struct TMStruct {

    ULONG   Size;
    ULONG   Sectors[4];
    };

struct TMStruct   *TMInfo;
struct CompHeader *Header;
UBYTE              Buff[2048], *TMBuff;
int                result = 0;

    if (ValidDisk()) {                                                                      /* Valid CD-ROM disk in drive?      */

        TMInfo = (struct TMStruct *)GetTMInfo();                                            /* Get sector where trademark is    */

        if (TMInfo->Sectors[0]) {                                                           /* Does a trademark exist?          */

            if (!DoIOR(&V->CDReq, CD_READ, TMInfo->Sectors[0]*2048, 2048,                   /* Read a sector of trademark info  */
                      (UWORD *)Buff, V)) {

                Header = &trademark;                                                        /* We are going to compare with TM  */

                if (TMBuff = AllocMem(Header->ci_Size, MEMF_PUBLIC)) {                      /* Allocate memory to decompress TM */

                    if (DecompData(NULL, Header, TMBuff)) {                                 /* Decompress trademark             */

                        if (Compare((ULONG *)Buff, (ULONG *)TMBuff, 2048)) result = 1;      /* Does disk have a valid TM?       */
                        }

                    FreeMem(TMBuff, Header->ci_Size);                                       /* Free trademark buffer            */
                    }

                if (!result) {                                                              /* Does a CDGS trademark exist?     */

                    Header = &cdtvtm;                                                       /* We are going to compare with TM  */

                    if (TMBuff = AllocMem(Header->ci_Size, MEMF_PUBLIC)) {                  /* Allocate memory to decompress TM */

                        if (DecompData(NULL, Header, TMBuff)) {                             /* Decompress trademark             */

                            if (Compare((ULONG *)Buff, (ULONG *)TMBuff, 2048)) result = 2;  /* Does disk have a valid TM?       */
                            }

                        FreeMem(TMBuff, Header->ci_Size);                                   /* Free trademark buffer            */
                        }
                    }
                }
            }
        }

    return(result);                                                                         /* Return result of TM search       */
    }



/***************************************************************************
 *                                                                         *
 *  PollXIPCard - See if an eXecute In Place card is inserted              *
 *                                                                         *
 ***************************************************************************/

int PollXIPCard(struct V *V) {

int   foundXIP;
int   cardfree;
ULONG cardcount;

struct Resident *rc;

    foundXIP = FALSE;                                                       /* Initialize state flags                       */
    cardfree = TRUE;

    if (CardResource && V->CardHandle) {                                    /* Does a credit card port exist?               */

        V->CardHandle->cah_CardFlags = CARDF_IFAVAILABLE;                   /* Reinit CardFlags before calling OwnCard()    */
        
        if (!(OwnCard(V->CardHandle))) {                                    /* Allocate the credit card                     */

            if ((cardcount = CardChangeCount()) != V->CardChgCnt) {         /* Don't check again if count hasn't changed    */

                V->CardChgCnt = cardcount;                                  /* The event is now recognized                  */

                if (rc = IfAmigaXIP(V->CardHandle)) {                       /* Is this an XIP card?                         */

                    foundXIP = TRUE;                                        /* ... Yep, it sure is                          */

                    if (V->CardPolled == FALSE) {                           /* Have we already recognized the card?         */

                        foundXIP = FALSE;                                   /* Don't do it again                            */

                        if (CardResetRemove(V->CardHandle, TRUE)) {         /* Make the computer reboot if card is removed  */

                            if (BeginCardAccess(V->CardHandle)) {           /* Turn on CC light                             */

                                if (InitResident(rc, NULL)) {               /* Allow credit card to insert a BootNode       */

                                    cardfree        = FALSE;                /* In use forever                               */
                                    CardResource    = NULL;

                                    V->CardHandle   = NULL;                 /* DO NOT FREE HANDLE!                          */
                                    }
                                }
                            }
                        }
                    }
                }

            if (cardfree) ReleaseCard(V->CardHandle, CARDF_REMOVEHANDLE);   /* reset state (light off, & reset-remove off)  */
            }
        }

    V->CardPolled = TRUE;                                                   /* Indicate we have run this code at least once */

    return(foundXIP);                                                       /* Return result                                */
    }




/***************************************************************************
 *                                                                         *
 *  ScanBootList - Check for a boot device on the Mount List               *
 *                                                                         *
 *      out:  Boot priority or -32768 if no boot device present            *
 *                                                                         *
 ***************************************************************************/

int ScanBootList(struct V *V) {

struct BootNode          *ln;
struct DeviceNode        *dn;
struct FileSysStartupMsg *fssm;

char   *devname;
LONG    devunit;
LONG   *envec;
int     boot, Poll;
UBYTE   Buff[BUFF_SIZE];
LONG    cnt;


    if (V->BootPri != -32768) return(V->BootPri);                                   /* If scanned twice, return same result */

    ln = (struct BootNode *)ExpansionBase->MountList.lh_Head;

    if (ln->bn_Node.ln_Succ) {                                                      /* Anything on the list ?               */

         while (ln) {                                                               /* Traverse whole device list           */

            if (ln->bn_Node.ln_Type == NT_BOOTNODE) {                               /* Only look at boot nodes on list      */

                boot = 1;                                                           /* If everything goes well, should boot */

                fssm=NULL;                                                          /* Try and find a FSSM                  */

                if (dn = (struct DeviceNode *)                                      /* Get device node pointer              */
                    ((struct BootNode *)ln->bn_DeviceNode)) {

                    if (fssm = BADDR(dn->dn_Startup)) {                             /* Get file system startup message      */

                        devname = (char *)BADDR(fssm->fssm_Device)+1;               /* Get FSSM info                        */
                        devunit = fssm->fssm_Unit;
                        envec   = (LONG *)(BADDR(fssm->fssm_Environ));
                        }
                    }

                if (fssm && ((envec[0] >= DE_BOOTBLOCKS))) {                        /* Is it a bootblock device ?           */

                    if (!OpenDevice(devname, devunit, &V->SReq, 0)) {               /* opened it                            */

                        Poll = 0;

                        if (Compare((ULONG *)devname,                               /* Are we scanning trackdisk.device?    */
                                    (ULONG *)"trackdisk.device", 16)) {

                            if ((cnt = GetIOActual(&V->SReq, TD_CHANGENUM, V))      /* See if a floppy change event occured */
                                                          > V->TDChgCnt[devunit]) {

                                V->TDChgCnt[devunit] = cnt;                         /* Event being handled                  */

                                if (!GetIOActual(&V->SReq, TD_CHANGESTATE, V)) {    /* See if a floppy change event occured */

                                    Poll = 1;                                       /* Only poll floppy drive after change  */
                                    }
                                }
                            }

                        else Poll = 1;

                        if (Poll) {

                            DoIOR(&V->SReq, CMD_CLEAR, 0, 0, 0, V);                 /* Clear cache!                         */

                            if (DoIOR(&V->SReq, CMD_READ, 0, BUFF_SIZE,             /* Read boot information                */
                               (UWORD *)Buff, V))
                                boot = 0;

                            DoIOR(&V->SReq, TD_MOTOR, 0, 0, 0, V);                  /* Motor off                            */

                            if (boot && (((*((LONG *)Buff) & 0xFFF0)                /* Is this a recognizible boot disk?    */
                                == (ID_DOS_DISK&0xFFF0))) || (*((LONG *)Buff)
                                == 'BOOT')) {

                                if (ChkSumFD(Buff)) boot = 0;                       /* Bad checksum.  Don't boot            */
                                }

                            else boot = 0;
                            }

                        else boot = 0;

                        CloseDevice(&V->SReq);
                        }
                    }

                if (boot) return(V->BootPri = ln->bn_Node.ln_Pri);                  /* Is the disk bootable?                */
                }

            ln = (struct BootNode *)ln->bn_Node.ln_Succ;                            /* Next node                            */
            }
        }

    return(-32768);                                                                 /* No boot device present               */
    }



/***************************************************************************
 *                                                                         *
 *  StripMemory - Remove all but CHIP memory                               *
 *                                                                         *
 ***************************************************************************/

void StripMemory(struct V *V) {

#define NoFastMemBase V->NoFastMemBase

    if (NoFastMemBase = OpenResource("nofastmem.resource")) RemoveFastMem();        /* Remove fast RAM from system          */
    }



/***************************************************************************
 *                                                                         *
 *  StripDevices - Remove unused devices (trackdisk and/or ide)            *
 *                                                                         *
 ***************************************************************************/

void StripDevices(struct V *V) {

struct BootNode          *ln;
struct DeviceNode        *dn;
struct FileSysStartupMsg *fssm;
char                     *devname;
LONG                      devunit;
UBYTE                     Buff[BUFF_SIZE];
int                       boot;

    Forbid();                                                                       /* Let's get started                    */
    ln = (struct BootNode *)ExpansionBase->MountList.lh_Head;

    if (ln->bn_Node.ln_Succ) {                                                      /* Anything on the list?                */

         while (ln) {                                                               /* Traverse whole device list           */

            if (dn = (struct DeviceNode *)                                          /* Get device node pointer              */
                ((struct BootNode *)ln->bn_DeviceNode)) {

                if (fssm = BADDR(dn->dn_Startup)) {                                 /* Get file system startup message      */

                    devname = (char *)BADDR(fssm->fssm_Device)+1;                   /* Get FSSM info                        */
                    devunit = fssm->fssm_Unit;

                    if (Compare((ULONG *)devname,                                   /* Remove all references to trackdisk   */
                                (ULONG *)"trackdisk.device", 16)) {

                        boot = 0;

                        if (!OpenDevice(devname, devunit, &V->SReq, 0)) {           /* opened it                            */

                            DoIOR(&V->SReq, CMD_CLEAR, 0, 0, 0, V);                 /* Clear cache!                         */

                            if (!DoIOR(&V->SReq, CMD_READ, 0, BUFF_SIZE,            /* Read boot information                */
                               (UWORD *)Buff, V))
                               boot = 1;

                            DoIOR(&V->SReq, TD_MOTOR, 0, 0, 0, V);                  /* Motor off                            */

                            CloseDevice(&V->SReq);
                            }

                        if (!boot) Remove((struct Node *)ln);                       /* Remove the device                    */
                        }

                    else if (Compare((ULONG *)devname,                              /* Remove all references to scsi.device */
                                     (ULONG *)"scsi.device", 11)) {

                        Remove((struct Node *)ln);                                  /* Remove the device                    */
                        }
                    }
                }

            ln = (struct BootNode *)ln->bn_Node.ln_Succ;                            /* Next node                            */
            }
        }

    Permit();                                                                       /* All done                             */
    }





/***************************************************************************
 *                                                                         *
 *  CenterScreen - Center the screen                                       *
 *                                                                         *
 ***************************************************************************/

#define TV_VIEW_X   120
#define ORIG_VIEW_X 129
#define ORIG_VIEW_Y 44

void CenterScreen(struct V *V) {

struct IOverscanPrefs ios;
struct DimensionInfo  diminfo;
ULONG  ModeID;

    if (GfxBase->DisplayFlags & PAL) ModeID = PAL_MONITOR_ID  | HIRES_KEY;          /* Read current dimensions of MODE_ID   */
    else                             ModeID = NTSC_MONITOR_ID | HIRES_KEY;

    if (GetDisplayInfoData(NULL, (UBYTE *)&diminfo,                                 /* Get display information              */
            sizeof(struct DimensionInfo), DTAG_DIMS, ModeID)) {

        ios.ios_ViewPos.x = TV_VIEW_X;                                              /* Center the X coordinate              */
        ios.ios_ViewPos.y = ORIG_VIEW_Y;

        ios.ios_DisplayID = ModeID;                                                 /* Proper mode                          */

        ios.ios_Text.x    = diminfo.TxtOScan.MaxX - diminfo.TxtOScan.MinX + 1;      /* Leave all this unchanged             */
        ios.ios_Text.y    = diminfo.TxtOScan.MaxY - diminfo.TxtOScan.MinY + 1;
        ios.ios_Standard  = diminfo.StdOScan;

        SetIPrefs(&ios, sizeof(struct IOverscanPrefs), IP_OVERSCAN);                /* Center the screen                    */
        }
    }




/*******************************************************************************
 *                                                                             *
 * SendAnimMessage - Send a message to animation task                          *
 *                                                                             *
 *******************************************************************************/

void SendAnimMessage(int Msg) {

struct MsgPort *AnimPort;
struct MsgPort *ReplyPort;
struct Message *ShutdownMsg;

    if (AnimPort = FindPort("Startup Animation")) {                             /* See if animation is running */

        if (ReplyPort = CreateMsgPort()) {                                      /* Create a message reply port */

            if (ShutdownMsg = (struct Message *)                                /* Allocate a message to send  */
                AllocMem(sizeof(struct Message), MEMF_PUBLIC | MEMF_CLEAR)) {

                ShutdownMsg->mn_Length    = Msg;                                /* Send this message to anim   */
                ShutdownMsg->mn_ReplyPort = ReplyPort;
                PutMsg(AnimPort, ShutdownMsg);

                WaitPort(ReplyPort);                                            /* Wait for message to return  */
                while(GetMsg(ReplyPort));

                FreeMem(ShutdownMsg, sizeof(struct Message));                   /* Free the message            */
                }

            DeleteMsgPort(ReplyPort);                                           /* Delete MsgPort              */
            }
        }
    }



/*******************************************************************************
 *                                                                             *
 * RemoveReqZapper - Turn on gurus and task held requesters.                   *
 *                                                                             *
 *******************************************************************************/

void RemoveReqZapper(struct V *V) {

struct Resident *res;

    Forbid();

    if (res = FindResident("reqzapper")) {                                      /* Find request zapper         */

        UnlinkRomTag(res);                                                      /* Remove request zapper       */

        V->ExecBase->KickCheckSum = (APTR)SumKickData();                        /* Rechecksum ROMTag stuff     */
        }

    Permit();
    }



/*******************************************************************************
 *                                                                             *
 * OpenCDUI - Start up CDUI library                                            *
 *                                                                             *
 *******************************************************************************/

ULONG OpenCDUI(struct V *V) {

        StripMemory(V);                                                         /* Remove all but CHIP memory   */

#undef  CDUIBase                                                                /* Open CDUI                    */
    if (V->CDUIBase = OpenLibrary("cdui.library", 0)) {
#define CDUIBase        V->CDUIBase

        StartCDUI();                                                            /* Start CDUI                   */
        V->Animating = 1;
        }

    return((ULONG)CDUIBase);                                                    /* Return result                */
    }
@


1.46
log
@StripMemory now performed when CDUI openned.
@
text
@d152 2
a153 1
    V->PlayerPrefsBase  = (struct PlayerPrefsBase *)OpenLibrary("playerprefs.library", 0L); /* Initialize playerprefs           */
@


1.45
log
@Removes fast memory when starting animation now.
@
text
@d92 1
a152 1
    V->CDUIBase         = OpenLibrary("cdui.library", 0);
d219 6
a224 5
            StartCDUI();
            V->Animating = 1;
            SendAnimMessage(ANIMMSG_BLUE_BUTTON);
            SendAnimMessage(ANIMMSG_SHUTDOWN);                                              /* Don't allow animation to come up */
            ColdReboot();
d231 6
a236 5
            StartCDUI();
            V->Animating = 1;
            SendAnimMessage(ANIMMSG_RED_BUTTON);
            SendAnimMessage(ANIMMSG_SHUTDOWN);                                              /* Don't allow animation to come up */
            ColdReboot();
d253 1
a253 4
 
                                StripMemory(V);                                             /* Remove all but CHIP memory       */
                                StartCDUI();                                                /* Do disk insertion Animation      */
                                V->Animating = 1;
d329 1
a329 2
    CloseLibrary((struct Library *)LowLevelBase);
    CloseLibrary((struct Library *)CDUIBase);                                               /* Close openned libraries          */
d337 2
d481 1
a481 5

            StripMemory(V);                                                             /* Remove all but CHIP memory       */
            StartCDUI();                                                                /* and start animation                  */
            SendAnimMessage(ANIMMSG_STARTUP);
            V->Animating = 1;
d909 22
@


1.44
log
@*** empty log message ***
@
text
@d252 1
a261 1
                                StripMemory(V);                                             /* Remove all but CHIP memory       */
a295 1
                                StripMemory(V);                                             /* Remove all but CHIP memory       */
d482 1
@


1.43
log
@Only look at bit 0 of byte 1 of reserved area of NVRAM.
@
text
@a154 1

d165 1
a165 2
    if (!ExpansionBase || !GfxBase || !DeBoxBase || !IntuitionBase || !PlayerPrefsBase)     /* Make sure all libraries openned  */
        ColdReboot();
d167 1
a167 1
    if (UtilityBase = (struct UtilityBase *)OpenLibrary("utility.library", 0)) {            /* Open utility.library             */
d169 27
a195 27
        if (NVBase = OpenLibrary("nonvolatile.library", 0)) {                               /* Open nonvolatile.library         */

            if (ReservedArea = GetCopyNV("", "", TRUE)) {                                   /* Get reserved nonvolatile memory  */

                V->AudioBoot = ((ReservedArea[1] & 0x01) == 0);                             /* Go to player if audio disk here? */

                UtilityBase->ub_Language = ReservedArea[0];                                 /* First byte of reserved=language  */
                FreeNVData(ReservedArea);
                }

            CloseLibrary(NVBase);                                                           /* Done with nonvolaitle.library    */
            }

        CloseLibrary(UtilityBase);                                                          /* Done with utility.library        */
        }

    V->IOPort.mp_Flags     = 0;                                                             /* Init MsgPort and add to system   */
    V->IOPort.mp_SigBit    = AllocSignal(-1);
    V->IOPort.mp_SigTask   = FindTask(NULL);

    V->IOPort.mp_MsgList.lh_Head     = (struct Node *)&V->IOPort.mp_MsgList.lh_Tail;        /* NewList                          */
    V->IOPort.mp_MsgList.lh_Tail     = 0;
    V->IOPort.mp_MsgList.lh_TailPred = (struct Node *)&V->IOPort.mp_MsgList.lh_Head;

    V->IOReq.io_Message.mn_Node.ln_Type = NT_MESSAGE;                                       /* Init an I/O request              */
    V->IOReq.io_Message.mn_ReplyPort    = &V->IOPort;
    V->IOReq.io_Device                  = NULL;
d197 2
a198 2
    V->CDReq          = V->IOReq;                                                           /* Make 2 copies of the request     */
    V->SReq.iotd_Req  = V->IOReq;
d200 2
a201 2
    V->CardHandle = (struct CardHandle *)AllocMem((ULONG)sizeof(struct CardHandle),         /* Allocate card handle             */
                    MEMF_CLEAR);
d203 1
a203 1
    V->CardPolled = FALSE;                                                                  /* Card has not yet been polled     */
d205 9
a213 9
    V->BootPri    = -32768;                                                                 /* BootList not yet scanned         */

    V->CDChgCnt    = V->CardChgCnt  = -1;                                                   /* Each device gets checked once    */
    V->TDChgCnt[0] = V->TDChgCnt[1] = V->TDChgCnt[2] = V->TDChgCnt[3] = -1;

    V->Animating = 0;

    if (!(PortLong = ReadJoyPort(1) & ~JP_TYPE_MASK))
          PortLong = ReadJoyPort(0) & ~JP_TYPE_MASK;
d215 1
a215 1
    if      (PortLong & JPF_BTN1) {
d217 1
a217 1
        CenterScreen(V);                                                                    /* and make sure screen is centered */                            
d219 6
a224 6
        StartCDUI();
        V->Animating = 1;
        SendAnimMessage(ANIMMSG_BLUE_BUTTON);
        SendAnimMessage(ANIMMSG_SHUTDOWN);                                                  /* Don't allow animation to come up */
        ColdReboot();
        }
d226 1
a226 1
    else if (PortLong & JPF_BTN2) {
d228 1
a228 1
        CenterScreen(V);                                                                    /* and make sure screen is centered */                            
d230 8
a237 8
        StartCDUI();
        V->Animating = 1;
        SendAnimMessage(ANIMMSG_RED_BUTTON);
        SendAnimMessage(ANIMMSG_SHUTDOWN);                                                  /* Don't allow animation to come up */
        ColdReboot();
        }

    if (!OpenDevice("cd.device", 0, &V->CDReq, 0)) {                                        /* cd.device better work            */
d239 1
a239 1
        switch (MainLoop(V)) {
d241 1
a241 1
            case -32766: /* AmigaCD Title */
d277 1
a277 1
            case -32765: /* CDTV Title */
d309 1
a309 1
            default: /* Anything Else */
d321 3
d326 3
a328 1
        MountFS();                                                                          /* Start the file system            */
a330 4
    if (V->CardHandle) FreeMem(V->CardHandle, (ULONG)sizeof(struct CardHandle));

    FreeSignal(V->IOPort.mp_SigBit);

d741 1
a741 1
    if (NoFastMemBase = OpenResource("nofastmem.resource")) RemoveFastMem();
d762 1
d765 1
a765 1
    if (ln->bn_Node.ln_Succ) {                                                      /* Anything on the list ?               */
d809 2
@


1.42
log
@CD Strap now does the following for CD1200:

Enables double-speed if not booting off of CD
Removes FAST RAM before bootinf off of CD
Removes trackdisk.device and scsi.device boot nodes if booting a CD32 title.
Allows going into NV-RAM editor or language selector with buttons before booting.
Looks for NV flag for disabling booting of audio disks.
@
text
@d175 1
a175 1
                V->AudioBoot = (ReservedArea[1] == 0);                                      /* Go to player if audio disk here? */
@


1.41
log
@*** empty log message ***
@
text
@d742 1
a742 5
    if (NoFastMemBase = OpenResource("nofastmem.resource")) {

        kprintf("Openned nofastmem.resource\n");
        RemoveFastMem();
        }
@


1.40
log
@Added features for CD1200:

Enables double-speed on CD-ROM if not booting off of CD.
Removes fast RAM before booting a CD32 or CDTV title.
@
text
@d298 1
@


1.39
log
@Added CDI_FMV type.
@
text
@d25 1
d39 1
d42 1
d54 1
d57 1
d92 2
d124 1
d132 9
d153 2
d164 1
d175 3
a177 1
                UtilityBase->ub_Language = *ReservedArea;                                   /* First byte of reserved=language  */
d214 25
d262 2
d271 5
a275 1
                        else RemoveReqZapper(V);                                            /* Remove request zapper            */
d303 5
d313 1
d331 1
d443 6
a448 2
                                        CloseLibrary(VideoCDBase);                      /* Start CD Player                      */
                                        if (ScanBootList(V) <= 2) StartCDPlayer2(V);
d467 1
a467 1
                else if (ScanBootList(V) <= 2) StartCDPlayer1(V);                       /* Run player if no boot disk present   */
a702 2
                            CloseDevice(&V->SReq);

d710 1
a710 1
                            else boot = 0;                                          /* Can't open device.  Not good         */
d714 2
d719 23
a741 1
                if (boot) {                                                         /* Is the disk bootable?                */
d743 63
a805 1
                    return(V->BootPri = ln->bn_Node.ln_Pri);
d812 3
a815 2
    return(-32768);                                                                 /* No boot device present               */
    }
d818 5
@


1.38
log
@If an audio disk is present, then the old player is now run even if there
is an mpeg card present.
@
text
@d380 1
@


1.37
log
@Added check for other boot devices before running mpeg player.
@
text
@d285 1
a285 1
void StartCDPlayer(struct V *V) {
d287 15
d383 1
a383 1
                                        if (ScanBootList(V) <= 2) StartCDPlayer(V);
d402 1
a402 1
                else if (ScanBootList(V) <= 2) StartCDPlayer(V);                        /* Run player if no boot disk present   */
@


1.36
log
@Added code to findresident on mpegplayer.library
,
@
text
@d368 1
a368 1
                                        StartCDPlayer(V);
@


1.35
log
@Now checks for CDT_VIDEOCD as well.
@
text
@d287 2
a288 1
struct Library *MPEGPlayerBase;
d290 2
a291 2
    if (V->Animating) SendAnimMessage(ANIMMSG_SHUTDOWN);            /* Fade to black for player screen      */
    else              CenterScreen(V);                              /* Center the screen.                   */
d293 1
a293 1
    InitAudio(V);
d299 1
a299 1
    if (MPEGPlayerBase = OpenLibrary("mpegplayer.library", 0)) {
d301 5
a305 2
        CDPlayer();
        CloseLibrary(MPEGPlayerBase);
d308 1
a308 1
    else DoPlayer();
@


1.34
log
@When running the audio player, cdstrap now calls
CDPlayer() if mpegplayer.library is present, otherwise
the old player is run.
@
text
@d325 1
a325 1
LONG            cnt;
d356 1
a356 1
                                if (VideoCDBase = OpenLibrary("videocd.library", 0)) {
d358 4
a361 1
                                    if (GetCDTypeA(NULL, NULL) == CDT_KARAOKE) {        /* MPEG disk?                           */
@


1.33
log
@Added check for Karaoke CDs.  If one is present, the Audio player
will be run.

@
text
@d68 1
d70 4
a73 1
#pragma libcall CDUIBase StartCDUI 1e 00
d287 2
d297 8
a304 1
    DoPlayer();
@


1.32
log
@no effective change.
@
text
@d38 1
d51 1
d57 1
d281 13
d309 5
a313 4
struct CDInfo CDInfo;
UWORD         Status, LastStatus = CDSTSF_CLOSED, AnimHeldOff = 0;
int           BootPri;
LONG          cnt;
d343 11
d356 1
a356 1
                                    SendAnimMessage(ANIMMSG_FALSEALARM);
d367 1
a367 15
                else {                                                                  /* Must be an Audio Disk                */

                    if (ScanBootList(V) <= 2) {                                         /* Higher boot device present?          */

                        if (V->Animating) SendAnimMessage(ANIMMSG_SHUTDOWN);            /* Fade to black for player screen      */
                        else              CenterScreen(V);                              /* Center the screen.                   */

                        InitAudio(V);
                        OwnBlitter();
                        WaitBlit();
                        custom.intena = INTF_BLIT;
                        DisownBlitter();
                        DoPlayer();
                        }
                    }
@


1.31
log
@Gurus are always disabled when booting off of a CD now.
Requesters are not zapped only when booting off of an AmigaCD.
@
text
@d341 1
a341 1
                    if (ScanBootList(V) <= 2) {                                         /* Higher boot device present?      */
@


1.30
log
@Does not start animation if startup-sequence
is disabled on CD.

Disables guru messages as before.  Only when booting off of cd.
Only removes request zapper when booting CDGS title without
computer module.
@
text
@d212 1
a212 2
                            if (ReadGayle()) RemoveReqZapper(V);                            /* Enable requesters if comp. mod.  */
                            else             SysBase->LastAlert[3] = 0;                     /* Turn off guru msgs otherwise     */
d240 1
a240 1
                            if (!ReadGayle()) SysBase->LastAlert[3] = 0;                    /* Turn off guru msgs if not comp.  */
@


1.29
log
@Reworked to enable alerts when not booting off of a CD or
if a computer module is attached.
@
text
@d82 1
a82 1
void        EnableGurus(struct V *V);
d204 1
a204 2
                            SendAnimMessage(ANIMMSG_HOLDOFFANIM);                           /* Booting an AmigaCD title         */
                            SendAnimMessage(ANIMMSG_BOOTING);
d206 8
a213 1
                            if (ReadGayle()) EnableGurus(V);                                /* Enable gurus if comp. mod. pres. */
d216 1
a216 1
                        else EnableGurus(V);
d222 2
d237 1
a237 1
                                InitScreen(V);                                              /* Perform kludges                  */
d241 1
a241 1
                            if (ReadGayle()) EnableGurus(V);                                /* Enable gurus if comp. mod. pres. */
a243 2
                        else EnableGurus(V);

d248 2
a255 2
                        else EnableGurus(V);

d691 1
a691 1
 * EnableGurus - Turn on gurus and task held requesters.                       *
d695 1
a695 1
void EnableGurus(struct V *V) {
a697 2

    SysBase->LastAlert[3] = 9*60;                                               /* Turn on guru messages       */
@


1.28
log
@Sending a "HOLDOFFANIM" message always before sending a BOOTING message
now.  HOLDOFFANIM will now most likely be sent twice, but that's ok.

@
text
@d82 1
d88 2
d117 1
a117 1
    V->SysBase          = *((struct ExecBase **)0x00000004L);                               /* Effectively open exec.library    */
d207 1
a207 2
                            if (SysBase->LibNode.lib_Version >= 40)                         /* Turn off guru msgs on AmigaCD    */
                                if (!ReadGayle()) SysBase->LastAlert[3] = 0;
d210 2
a225 3
                                if (SysBase->LibNode.lib_Version >= 40)                     /* Turn off guru msgs on CDTV       */
                                    if (!ReadGayle()) SysBase->LastAlert[3] = 0;

d232 2
d236 2
d248 2
d681 25
@


1.27
log
@Removed an unnecessary addport.
Changed PresentCDUI(ULONG) to StartCDUI(void).
@
text
@d201 2
a202 1
                            SendAnimMessage(ANIMMSG_BOOTING);                               /* Booting an AmigaCD title         */
d212 1
a212 1
                        if (ScanBootList(V) <= 2) {
@


1.26
log
@Boots every title in single-speed now.
@
text
@d65 2
a66 1
void PresentCDUI(ULONG);
a162 2
    AddPort(&V->IOPort);

d197 1
a197 1
                                PresentCDUI(CDUI_STARTUP_ANIM);                             /* Do disk insertion Animation      */
a249 1
    RemPort(&V->IOPort);                                                                    /* Free MsgPort                     */
d356 1
a356 1
            PresentCDUI(CDUI_STARTUP_ANIM);                                             /* and start animation                  */
@


1.25
log
@Kicks CDGS to double-speed instead of kicking CDTV to single-speed.
@
text
@a109 1
    { TAGCD_READSPEED,   150 },
a112 6
struct TagItem ConfigListCDTV[] = {

    { TAGCD_EJECTRESET,  1 },
    { TAG_END,           0 }
    };

d226 1
a226 1
                                   (UWORD*)&ConfigListCDTV[0], V);
@


1.24
log
@now kicks CDTV titles to normal-speed.
@
text
@d109 3
a111 2
    { TAGCD_EJECTRESET,  1 },
    { TAG_END,           0 }
d116 2
a117 3
    { TAGCD_EJECTRESET,  1  },
    { TAGCD_READSPEED,   75 },
    { TAG_END,           0  }
@


1.23
log
@removed my startup-anim code.
Incorporates read startup-anim.
@
text
@d113 7
d233 1
a233 1
                                   (UWORD*)&ConfigList[0], V);
@


1.22
log
@version 40.8.
@
text
@d24 1
d38 1
d50 1
d65 2
d124 1
d133 1
d194 1
a194 1
                            if (V->Animating) SendAnimMessage(ANIMMSG_BOOTING);             /* Do disk insertion Animation      */
d196 5
a200 1
                            else {
d202 1
a202 3
                                SetChipRev(SETCHIPREV_BEST);                                /* Go into AA mode...               */
                                CenterScreen(V);                                            /* and make sure screen is centered */
                                }
d254 2
a255 1
    CloseLibrary((struct Library *)PlayerPrefsBase);                                        /* Close openned libraries          */
d357 4
a360 1
            V->Animating = StartAnimation();                                            /* and start animation                  */
d518 1
@


1.21
log
@Preliminary rework for incorporating startup anim.
@
text
@d169 2
d506 2
d582 1
a582 1
                    return(ln->bn_Node.ln_Pri);
@


1.20
log
@Removed debug messages.
Properly screen centering now according to Peter.
@
text
@d75 1
a77 1
extern void SendAnimMessage(UWORD Msg);
d110 1
a110 1
#define SysBase V->SysBase                                                                  /* Redirect exec calls through this */
d169 2
a170 1
    V->CDChgCnt = V->CardChgCnt = -1;                                                       /* Each device gets checked once    */
d238 1
a238 1
    if (V->CardHandle) FreeMem(V->CardHandle,(ULONG)sizeof(struct CardHandle));
d303 6
a308 2
                                SendAnimMessage(ANIMMSG_FALSEALARM);                    /* Not a valid disk                     */
                                AnimHeldOff = 0;
d310 1
a502 1
LONG    TDChgCnt[4] = { -1, -1, -1, -1 };
d537 1
a537 1
                                                          > TDChgCnt[devunit]) {
d539 1
a539 1
                                TDChgCnt[devunit] = cnt;                            /* Event being handled                  */
d620 36
@


1.19
log
@Now rebooting if the animation is up and a Non-AmigaCD disk
is inserted into any device.
@
text
@a180 1
                            kprintf("\n**** CDGS ****\n");
a201 2
                            kprintf("\n**** CDTV ****\n");

a313 2
                        kprintf("\n**** Audio ****\n");

d603 1
a603 1
        ios.ios_ViewPos.y = diminfo.TxtOScan.MinY;
@


1.18
log
@added screen centering.
@
text
@d74 1
a74 1
void        CenterScreen(BOOL Center, struct V *V);
d177 1
a177 1
            case -32766:
d190 1
a190 1
                                CenterScreen(TRUE, V);                                      /* and make sure screen is centered */
d199 1
a199 1
            case -32765:
d226 2
a227 1
            default:
d231 1
a231 1
                            CenterScreen(FALSE, V);
d315 1
a315 1
                    kprintf("\n**** Audio ****\n");
d317 1
a317 2
                    if (V->Animating) SendAnimMessage(ANIMMSG_SHUTDOWN);                /* Fade to black for player screen      */
                    else              CenterScreen(TRUE, V);                            /* Center the screen.                   */
d319 10
a328 6
                    InitAudio(V);
                    OwnBlitter();
                    WaitBlit();
                    custom.intena = INTF_BLIT;
                    DisownBlitter();
                    DoPlayer();
d343 1
a343 1
            CenterScreen(TRUE, V);                                                      /* center the screen...                 */
d595 1
a595 1
void CenterScreen(BOOL Center, struct V *V) {
d607 2
a608 11
        if (Center) {

            ios.ios_ViewPos.x = TV_VIEW_X;                                          /* Center the X coordinate              */
            ios.ios_ViewPos.y = diminfo.TxtOScan.MinY;
            }

        else {

            ios.ios_ViewPos.x = ORIG_VIEW_X;                                        /* Set original defaults                */
            ios.ios_ViewPos.y = ORIG_VIEW_Y;
            }
@


1.17
log
@no effective change.
@
text
@d74 1
d179 1
a179 1
                         if (ScanBootList(V) <= 2) {                                        /* Higher boot device present?      */
d181 5
a185 10
                              kprintf("\n**** CDGS ****\n");
                              DoIOR(&V->CDReq, CD_CONFIG, 0, 0,                             /* Reset on disk removal            */
                                   (UWORD *)&ConfigList[0], V);

                              if (V->Animating) SendAnimMessage(ANIMMSG_BOOTING);           /* Do disk insertion Animation      */
                              else              SetChipRev(SETCHIPREV_BEST);                /* Go into AA mode                  */

                              if (SysBase->LibNode.lib_Version >= 40)                       /* Turn off guru msgs on AmigaCD    */
                                  if (!ReadGayle()) SysBase->LastAlert[3] = 0;
                              }
d187 1
a187 1
                         break;
d189 10
d201 24
a224 1
                         if (ScanBootList(V) <= 2) {
d226 2
a227 2
                              kprintf("\n**** CDTV ****\n");
                              SendAnimMessage(ANIMMSG_SHUTDOWN);                            /* Free animation now               */
d229 3
a231 14
                              if (V->Animating) ColdReboot();                               /* Reboot if animation is present   */

                              else {                                                        /* Do CDTV kludges                  */

                                  if (SysBase->LibNode.lib_Version >= 40)                   /* Turn off guru msgs on CDTV       */
                                      if (!ReadGayle()) SysBase->LastAlert[3] = 0;

                                  DoIOR(&V->CDReq, CD_CONFIG, 0, 0,
                                       (UWORD*)&ConfigList[0], V);

                                  InitScreen(V);
                                  Kludges(V);
                                  }
                              }
d233 1
a233 1
                         break;
d316 3
a318 1
                    SendAnimMessage(ANIMMSG_SHUTDOWN);                                  /* Fade to player screen                */
d337 6
a342 2
        if (!V->Animating) V->Animating = StartAnimation();                             /* If we didn't start booting something,*/
                                                                                        /* start animation                      */
d582 1
a582 1
    return(-32768);
d587 35
a621 11
void CenterScreen(struct V *V) {

struct IOverscanPrefs iop;

        if (GfxBase->DisplayFlags & PAL) iop.ios_DisplayID = PAL_MONITOR_ID;
        else                             iop.ios_DisplayID = NTSC_MONITOR_ID;

//        iop.ios_ViewPos   = op.os_ViewPos;
//        iop.ios_Text      = op.os_Text;
//        iop.ios_Standard  = op.os_Standard;
        SetIPrefs(&iop,(LONG)sizeof iop, (LONG)IP_OVERSCAN);
d623 2
@


1.16
log
@forgot some break;s in the case statement.
@
text
@d215 1
a215 1
                          break;
@


1.15
log
@Had to modify to get a better idea of which device was
really going to boot.  This is really ugly code and I
wish we had enough time to do this properly.
@
text
@d191 2
d214 2
@


1.14
log
@make sure trackdisk scan will take place on entry.
@
text
@d70 1
a70 1
void        MainLoop(struct V *V);
d73 1
d88 3
d101 6
d170 2
d174 39
a212 1
        MainLoop(V);                                                                        /* Wait for a disk and start anim.  */
d240 5
d247 1
a247 8
void MainLoop(struct V *V) {

struct BootNode          *ln;
struct DeviceNode        *dn;
struct FileSysStartupMsg *fssm;
struct CDInfo             CDInfo;

struct TagItem ConfigList[] = {
d249 4
a252 3
    { TAGCD_EJECTRESET,  1 },
    { TAG_END,           0 }
    };
d254 1
a254 8
char   *devname;
LONG    devunit;
LONG   *envec;
int     boot, Animating = 0, Poll;
UBYTE   Buff[BUFF_SIZE];
LONG    cnt;
UWORD   Status, LastStatus = CDSTSF_CLOSED, AnimHeldOff = 0;
LONG    TDChgCnt[4] = { -1, -1, -1, -1 };
d256 1
a256 1
    while (1) {                                                                         /* Loop forever.  return() gets us out  */
d285 2
a286 30
                        case 1:
                                kprintf("\n**** CDGS ****\n");
                                DoIOR(&V->CDReq, CD_CONFIG, 0, 0,
                                     (UWORD *)&ConfigList[0], V);

                                if (Animating) SendAnimMessage(ANIMMSG_BOOTING);        /* Do disk insertion Animation          */
                                else           SetChipRev(SETCHIPREV_BEST);             /* Go into AA mode                      */

                                if (SysBase->LibNode.lib_Version >= 40)                 /* Turn off guru msgs on AmigaCD        */
                                    if (!ReadGayle()) SysBase->LastAlert[3] = 0;

                                return;
                        case 2:                                                         /* Boot old CDTV title                  */
                                kprintf("\n**** CDTV ****\n");
                                SendAnimMessage(ANIMMSG_SHUTDOWN);

                                if (Animating) ColdReboot();                            /* Reboot if animation is present       */

                                else {                                                  /* Do CDTV kludges                      */

                                    if (SysBase->LibNode.lib_Version >= 40)             /* Turn off guru msgs on CDTV           */
                                        if (!ReadGayle()) SysBase->LastAlert[3] = 0;

                                    DoIOR(&V->CDReq, CD_CONFIG, 0, 0,
                                         (UWORD*)&ConfigList[0], V);

                                    InitScreen(V);
                                    Kludges(V);
                                    return;
                                    }
d304 1
a304 1
            else if (AnimHeldOff) {                                                     /* No disk, resume animation */
d311 1
a311 84
        if (PollXIPCard(V)) return;                                                     /* poll for a execute-in-place card     */

        ln = (struct BootNode *)ExpansionBase->MountList.lh_Head;

        if (ln->bn_Node.ln_Succ) {                                                      /* Anything on the list ?               */

             while (ln) {                                                               /* Traverse whole device list           */

                if (ln->bn_Node.ln_Type == NT_BOOTNODE) {                               /* Only look at boot nodes on list      */

                    boot = 1;                                                           /* If everything goes well, should boot */

                    fssm=NULL;                                                          /* Try and find a FSSM                  */

                    if (dn = (struct DeviceNode *)                                      /* Get device node pointer              */
                        ((struct BootNode *)ln->bn_DeviceNode)) {

                        if (fssm = BADDR(dn->dn_Startup)) {                             /* Get file system startup message      */

                            devname = (char *)BADDR(fssm->fssm_Device)+1;               /* Get FSSM info                        */
                            devunit = fssm->fssm_Unit;
                            envec   = (LONG *)(BADDR(fssm->fssm_Environ));
                            }
                        }

                    if (fssm && ((envec[0] >= DE_BOOTBLOCKS))) {                        /* Is it a bootblock device ?           */

                        if (!OpenDevice(devname, devunit, &V->SReq, 0)) {               /* opened it                            */

                            Poll = 0;

                            if (Compare((ULONG *)devname,                               /* Are we scanning trackdisk.device?    */
                                        (ULONG *)"trackdisk.device", 16)) {

                                if ((cnt = GetIOActual(&V->SReq, TD_CHANGENUM, V))      /* See if a floppy change event occured */
                                                              > TDChgCnt[devunit]) {

                                    TDChgCnt[devunit] = cnt;                            /* Event being handled                  */

                                    if (!GetIOActual(&V->SReq, TD_CHANGESTATE, V)) {    /* See if a floppy change event occured */

                                        Poll = 1;                                       /* Only poll floppy drive after change  */
                                        }
                                    }
                                }

                            else Poll = 1;

                            if (Poll) {

                                DoIOR(&V->SReq, CMD_CLEAR, 0, 0, 0, V);                 /* Clear cache!                         */

                                if (DoIOR(&V->SReq, CMD_READ, 0, BUFF_SIZE,             /* Read boot information                */
                                   (UWORD *)Buff, V))
                                    boot = 0;

                                DoIOR(&V->SReq, TD_MOTOR, 0, 0, 0, V);                  /* Motor off                            */

                                CloseDevice(&V->SReq);

                                if (boot && (((*((LONG *)Buff) & 0xFFF0)                /* Is this a recognizible boot disk?    */
                                    == (ID_DOS_DISK&0xFFF0))) || (*((LONG *)Buff)
                                    == 'BOOT')) {

                                    if (ChkSumFD(Buff)) boot = 0;                       /* Bad checksum.  Don't boot            */
                                    }

                                else boot = 0;                                          /* Can't open device.  Not good         */
                                }

                            else boot = 0;
                            }
                        }

                    if (boot) {                                                         /* Is the disk bootable?                */

                        SendAnimMessage(ANIMMSG_SHUTDOWN);                              /* Start booting it                     */
                        return;
                        }
                    }

                ln = (struct BootNode *)ln->bn_Node.ln_Succ;                            /* Next node                            */
                }
            }
d313 1
a313 1
        if (!Animating) Animating = StartAnimation();                                   /* If we didn't start booting something,*/
d447 109
@


1.13
log
@Added language selection setting.
Bumped priority to just under strap.
Trackdisk checking moved to standard boot list scan.
Preliminary screen centering coded added.
@
text
@d212 1
a212 1
ULONG   TDChgCnt[4] = { 0, 0, 0, 0 };
@


1.12
log
@removed some kprintfs.
@
text
@d14 1
d23 1
d35 2
d46 2
d91 5
a95 2
struct V  Variables;
struct V *V = &Variables;
d107 1
a107 1
    V->PlayerPrefsBase  = (struct PlayerPrefsBase *)OpenLibrary("playerprefs.library", 0L); /* Initialize playerprefs               */
d120 16
d150 1
a150 1
    V->CDReq          = V->IOReq;                                                           /* Make 3 copies of the request     */
a151 1
    V->TDReq.iotd_Req = V->IOReq;
d158 1
a158 1
    V->CDChgCnt = V->TDChgCnt = V->CardChgCnt = -1;                                         /* Each device gets checked once    */
a161 4
        OpenDevice("trackdisk.device", 0, &V->TDReq, 0);                                    /* Try openning unit 0              */

        if (!V->TDReq.iotd_Req.io_Device) OpenDevice("trackdisk.device", 1, &V->TDReq, 0);  /* If unit 0 failed, try unit 1     */

a164 4

        if (V->TDReq.iotd_Req.io_Device) CloseDevice(&V->TDReq);                            /* Close trackdisk if openned       */

        CloseDevice(&V->CDReq);                                                             /* Close cd.device                  */
d208 1
a208 1
int     boot, Animating = 0;
d212 1
a215 17
        if (V->TDReq.iotd_Req.io_Device) {                                              /* Poll floppy drive if device exists   */

            if ((cnt = GetIOActual(&V->TDReq, TD_CHANGENUM, V)) > V->TDChgCnt) {        /* See if a floppy change event occured */

                V->TDChgCnt = cnt;                                                      /* Event being handled                  */

                if (!GetIOActual(&V->TDReq, TD_CHANGESTATE, V)) {                       /* Is there a disk now?                 */

                    if (ValidFloppy(V) == 1) {                                          /* Valid boot disk?                     */

                        SendAnimMessage(ANIMMSG_SHUTDOWN);                              /* Boot this disk                       */
                        return;
                        }
                    }
                }       
            }

d326 34
a359 1
                            DoIOR(&V->SReq, CD_CLEAR, 0, 0, 0, V);                      /* Clear cache!                         */
d361 2
a362 10
                            if (DoIOR(&V->SReq, CD_READ, 0, BUFF_SIZE,                  /* Read boot information                */
                               (UWORD *)Buff, V))
                                boot = 0;

                            DoIOR(&V->SReq, CD_MOTOR, 0, 0, 0, V);                      /* Motor off                            */
                            CloseDevice(&V->SReq);

                            if (boot && (((*((LONG *)Buff) & 0xFFF0)                    /* Is this a recognizible boot disk?    */
                                == (ID_DOS_DISK&0xFFF0))) || (*((LONG *)Buff)
                                == 'BOOT')) {
d364 1
a364 1
                                if (ChkSumFD(Buff)) boot = 0;                           /* Bad checksum.  Don't boot            */
d367 1
a367 1
                            else boot = 0;                                              /* Can't open device.  Not good         */
a518 8
//struct IOverscanPrefs {
//
//    ULONG                     ios_DisplayID;  /* display id   */
//    Point                     ios_ViewPos;    /* View origin in ViewRes */
//    Point                     ios_Text;       /* TxtOScan in DisplayID-res */
//    struct Rectangle          ios_Standard;   /* StdOScan in DisplayID-res */
//    };

d523 3
a525 1
//        iop.ios_DisplayID = op.os_DisplayID;
a530 1

@


1.11
log
@Trying to add screen centering.
@
text
@a91 2
    kprintf("CDStrap\n");

a107 3
    kprintf("Libraries Openned\n");


a140 2

        kprintf("MainLoop\n");
@


1.10
log
@Reworked for sas 6.2
@
text
@d21 1
a31 1
#include "pragmas/game_pragmas.h"
a40 1
#include "clib/game_protos.h"
a46 1
#include "cdgs:src/game/gamebase.h"
d53 3
d92 1
a92 2
    if (SysBase->LibNode.lib_Version >= 40)                                                 /* Turn off guru msgs on AmigaCD    */
        if (ReadGayle()) SysBase->LastAlert[3] = 0;
a97 1
    V->PlayerPrefsBase  = (struct PlayerPrefsBase *)OpenLibrary("playerprefs.library", 0L);
a98 1
    V->GameBase         = (struct GameBase *)OpenLibrary("game.library", 0L);
d100 1
a105 1
#define PlayerPrefsBase V->PlayerPrefsBase
a106 1
#define GameBase        V->GameBase
d108 1
d110 3
d114 1
a114 1
        ColdReboot();                  
d147 2
d163 1
a163 1
    CloseLibrary((struct Library *)GameBase);                                               /* Close openned libraries          */
a164 1
    CloseLibrary((struct Library *)PlayerPrefsBase);
d246 4
a249 1
                        case 0: break;                                                  /* Cannot boot from this disk           */
d258 3
d270 3
d275 2
a276 2
                                    PrepareTM();
                                    DisplayTM();
a287 1
//                    InitScreen(V);       
d499 20
@


1.9
log
@Removed guru messages when no computer module.
@
text
@a21 10
#include "gs:cd/cd.h"
#include "cdtv/cdtvprefs.h"

#include "gs:pplibrary/playerprefsbase.h"
#include "gs:pplibrary/playerprefs_private_pragmas.h"
#include "cdtv:include/internal/cdfs_pragmas.h"

#include <cdtv/debox.h>
#include <cdtv/debox_protos.h>

d28 6
d35 1
d38 12
d52 1
a54 8
#include "cdtv:include/internal/card.h"
#include "clib/cardres_protos.h"
#include "pragmas/cardres_pragmas.h"

#include "cdgs:src/game/gamebase.h"
#include "cdgs:src/game/game_pragmas.h"
#include "cdgs:src/game/game_protos.h"

d62 1
d64 2
d70 1
d82 1
a82 1
Main() {
d118 4
a121 1
    NewList(&V->IOPort.mp_MsgList);
d160 7
a166 7
    CloseLibrary(GameBase);
    CloseLibrary(CDFSBase);                                                                 /* Close openned libraries          */
    CloseLibrary(PlayerPrefsBase);
    CloseLibrary(IntuitionBase);
    CloseLibrary(DeBoxBase);
    CloseLibrary(GfxBase);
    CloseLibrary(ExpansionBase);
d238 1
a238 1
                DoIOR(&V->CDReq, CD_INFO, 0, sizeof(struct CDInfo), &CDInfo, V);
d247 2
a248 1
                                DoIOR(&V->CDReq, CD_CONFIG, 0, 0, &ConfigList[0], V);
d262 2
a263 1
                                    DoIOR(&V->CDReq, CD_CONFIG, 0, 0, &ConfigList[0], V);
d325 2
a326 1
                            if (DoIOR(&V->SReq, CD_READ, 0, BUFF_SIZE, Buff, V))        /* Read boot information                */
a382 2
extern struct TMStruct *GetTMInfo();

d385 1
a385 1
        TMInfo = GetTMInfo();                                                               /* Get sector where trademark is    */
d389 2
a390 1
            if (!DoIOR(&V->CDReq, CD_READ, TMInfo->Sectors[0]*2048, 2048, Buff, V)) {       /* Read a sector of trademark info  */
d398 1
a398 1
                        if (Compare(Buff, TMBuff, 2048)) result = 1;                        /* Does disk have a valid TM?       */
d412 1
a412 1
                            if (Compare(Buff, TMBuff, 2048)) result = 2;                    /* Does disk have a valid TM?       */
@


1.8
log
@Added door closed messages.
@
text
@a23 1
#include "cddev.h"
d32 2
d68 2
d85 3
a108 2
    SysBase->LastAlert[3] = NULL;                                                           /* Turn off GURU messages           */

d266 1
a266 1
                    InitScreen(V);       
@


1.7
log
@game.library openned.
@
text
@d42 1
d61 2
a62 3
extern int  StartAnimation(struct V *V);
extern void ShutDownAnimation(struct V *V);
extern void InsertDiskAnimation(struct V *V);
d187 1
d193 1
a193 1
            if ((cnt = GetIOActual(&V->TDReq, CD_CHANGENUM, V)) > V->TDChgCnt) {        /* See if a floppy change event occured */
d197 1
a197 1
                if (!GetIOActual(&V->TDReq, CD_CHANGESTATE, V)) {                       /* Is there a disk now?                 */
d201 1
a201 1
                        ShutDownAnimation(V);                                           /* Boot this disk                       */
d208 11
d236 1
a236 1
                                if (Animating) InsertDiskAnimation(V);                  /* Do disk insertion Animation          */
d242 1
a242 1
                                ShutDownAnimation(V);
d244 1
a244 1
                                if (Animating) ColdReboot();
d246 1
a246 1
                                else {
d261 1
a261 1
                    ShutDownAnimation(V);                                               /* Fade to player screen                */
d271 6
d329 1
a329 1
                        ShutDownAnimation(V);                                           /* Start booting it                     */
d338 1
a338 1
        if (!Animating) Animating = StartAnimation(V);                                  /* If we didn't start booting something,*/
@


1.6
log
@Removed some debugs.  Changed reboot code.
@
text
@d47 4
d88 1
d97 1
d147 1
@


1.5
log
@boots cdtv titles, and properly runs audio panel.
@
text
@d95 1
a95 1
        REBOOT();                       
d163 4
a166 4
struct  BootNode          *ln;
struct  DeviceNode        *dn;
struct  FileSysStartupMsg *fssm;
struct  CDInfo             CDInfo;
d216 4
a219 1
                                InsertDiskAnimation(V);
a222 1
                                DoIOR(&V->CDReq, CD_CONFIG, 0, 0, &ConfigList[0], V);
d224 11
a234 4
                                PrepareTM();
                                DisplayTM();
                                Kludges(V);
                                return;
a343 2
    kprintf(" CheckTM\n");

a345 2
        kprintf(" ValidDisk\n");

a349 2
            kprintf(" Read\n");

a351 2
                kprintf(" DecompData1\n");

a357 2
                        kprintf(" Compare1\n");

a363 2
                kprintf(" DecompData2\n");

a371 2
                            kprintf(" Compare2\n");

a380 2

    kprintf(" result = %ld\n", result);
@


1.4
log
@seriously cleaned up and added XIP card support.
@
text
@d22 1
a22 1
#include "cdtv/cdtv.h"
d59 1
a152 2


d166 7
d183 1
a183 1
        if (V->TDReq.iotd_Req.io_Device) {
d206 3
a208 1
                if (GetIOActual(&V->CDReq, CD_ISROM, V)) {                              /* Data disk?                           */
d213 4
a216 1
                        case 1: InsertDiskAnimation(V);                                 /* Boot CDGS title                      */
d219 2
d231 2
d234 1
a246 1
        Forbid();
d295 1
a295 2
                        Permit();                                                       /* Start booting it                     */
                        ShutDownAnimation(V);
d335 2
d339 2
d345 2
d349 2
d357 2
d365 2
d375 2
d386 2
@


1.3
log
@Serious clean up.
@
text
@d43 4
d58 1
d60 1
d83 1
d91 1
d113 4
a116 1
    V->CDChgCnt = V->TDChgCnt = -1;                                                         /* Each device gets checked once    */
d118 1
a118 1
    if (!OpenDevice("cdtv.device", 0, &V->CDReq, 0)) {                                      /* cd.device better work            */
d120 2
d135 2
d152 2
d205 2
a206 1
                        case 1: return;                                                 /* Boot CDGS title                      */
d219 5
d229 2
d236 1
a236 1
             while (ln) {
d238 1
a238 1
                if (ln->bn_Node.ln_Type == NT_BOOTNODE) {
d242 1
a242 1
                    fssm=NULL;
d298 7
a304 8
/***************************************************************************************
 *                                                                                     *
 *  CheckTM - Check for trademark information on CDs.                                  *
 *                                                                                     *
 *                                                                                     *
 *  out:    result = 0 - no trademark, 1 = CDGS trademark, 2 = CDTV trademark          *
 *                                                                                     *
 ***************************************************************************************/
d319 5
a323 1
ULONG   i, j;
d325 5
a329 1
extern struct TMStruct *GetTMInfo();
d331 1
a331 1
    if (ValidDisk()) {
d333 1
a333 1
        TMInfo = GetTMInfo();
d335 1
a335 11
        if (TMInfo->Sectors[0]) {

            if (!DoIOR(&V->CDReq, CD_READ, TMInfo->Sectors[0]*2048, 2048, Buff, V)) {

                Header = &trademark;

                if (TMBuff = AllocMem(Header->ci_Size, MEMF_PUBLIC)) {

                    if (DecompData(NULL, Header, TMBuff)) {

                        if (Compare(Buff, TMBuff, 2048)) result = 1;
d338 1
a338 1
                    FreeMem(TMBuff, Header->ci_Size);
d340 15
d357 4
a361 1
        if (!result) {
a362 1
            TMInfo = GetTMInfo();
d364 16
a379 7
            if (TMInfo->Sectors[0]) {

                if (!DoIOR(&V->CDReq, CD_READ, TMInfo->Sectors[0]*2048, 2048, Buff, V)) {

                    Header = &cdtvtm;

                    if (TMBuff = AllocMem(Header->ci_Size, MEMF_PUBLIC)) {
d381 1
a381 1
                        if (DecompData(NULL, Header, TMBuff)) {
d383 28
a410 1
                            if (Compare(Buff, TMBuff, 2048)) result = 2;
a411 2

                        FreeMem(TMBuff, Header->ci_Size);
d415 2
d420 3
a422 1
    return(result);
d424 4
@


1.2
log
@main routines for cdstrap.
@
text
@d10 1
d36 2
d39 1
d43 1
d45 1
a45 15
#define CDROM_PRIORITY  2

#define BUF_SIZE        (512*2)

extern  struct TMStruct *GetTMInfo();

extern  void    *AllocMem();
extern  void    *GetA4();
extern  void    InputHandler();
extern  struct  Task   *FindTask();
extern  char    __far ModIdent[];

void    AddHand(void);
void    RemHand(void);

d47 1
a49 6
#define ERR_TIMEOUT 2000
#define HANG        REBOOT()
#define MUST(e)     if (!(e)) return FALSE;

/* prototypes */

a50 9
void        FindChain(struct V *V);
void        FixBlitInt(struct V *V);
void        Kludges(struct V *V);
void        InitAudio(struct V *V);
void        Init(struct V *V);
void        Quit(struct V *V);
void        OpenDevs(struct V *V);
void        CloseDevs(struct V *V);
void        CheckDevs(struct V *V);
a54 17
/***********************************************************************
***
***  GLOBALS
***
*** These are allocated and set to zero during boot init.
*** Do not set globals to preinitialized values... there
*** is no such data segment in ROM.
***
***********************************************************************/
APTR    StackBase;

struct  TMStruct {          /* Trademark file locations */

    ULONG   Size;
    ULONG   Sectors[4];
    };

d56 5
a60 5
/***********************************************************************
***
***  Main
***
***********************************************************************/
d65 1
a65 3
struct V *V;

    V = &Variables;
d67 1
a67 1
    V->SysBase          = *((struct ExecBase **)0x00000004L);
d69 1
a69 1
#define SysBase V->SysBase
d71 1
a71 2
    V->ExpansionBase    = (struct ExpansionBase *)OpenLibrary("expansion.library", 0L);
    V->CDFSBase         = (struct Library *)OpenLibrary("cdfs.library", 0L);
a72 2
    V->PlayerPrefsBase  = (struct PlayerPrefsBase *)OpenLibrary("playerprefs.library", 0L);
    V->DOSBase          = (struct DosBase *)OpenLibrary("dos.library", 0L);
d75 2
d78 1
a78 3
#define CDFSBase        V->CDFSBase
#define PlayerPrefsBase V->PlayerPrefsBase
#define ExpansionBase   V->ExpansionBase
a79 1
#define DOSBase         V->DOSBase
d82 2
d85 2
a86 2
    if (!SysBase || !ExpansionBase || !CDFSBase || !GfxBase
        || !DeBoxBase || !PlayerPrefsBase || !IntuitionBase) HANG;
d88 1
a88 1
    Init(V);
d90 4
a93 9
    V->boot=0;

    if (GetIOActual(&V->CDReq, CD_ISROM, V)) V->boot = ValidDisk();

    MainLoop(V);

    MountFS();                              /* Make certain something comes up for CDFS */

    DoIOR(&V->CDReq, CD_STOP, 0, 0, 0, V);  /* Stop CD while booting */
d95 1
a95 1
    Quit(V);
d97 3
a99 2
    return(0);
    }
d101 5
d107 1
a107 6
/***********************************************************************
***
***  MainLoop
***
***********************************************************************/
void MainLoop(struct V *V) {
d109 12
a120 8
struct  BootNode *ln;
struct  DeviceNode *dn;
struct  FileSysStartupMsg *fssm;
char   *devname;
LONG    devunit;
LONG   *envec;
int     err, Animating = 0;
UBYTE   Buf[BUF_SIZE];
d122 2
a123 17
    V->ErrCycle = 0;
    while (V->ErrCycle < ERR_TIMEOUT) {                                                 /* don't wait forever on an error */

        CheckDevs(V);

        if (V->TDReady) {

            switch (ValidFloppy(V)) {

                case 0:
                    V->ErrorOn = -1;
                    break;
                case 1:
                    return;
                case 2:
                    break;
                }
d125 6
a130 2
            V->TDReady = FALSE;                                                         /* prevent read cycling */
            }
d132 2
a133 2
        Forbid();
        ln = (struct BootNode *)ExpansionBase->MountList.lh_Head;
a134 1
        if(ln->bn_Node.ln_Succ) {                                                       /* anything on the list ? */
a135 1
             while (ln) {
d137 7
a143 2
                dn= (struct DeviceNode *)((struct BootNode *)ln->bn_DeviceNode);
                fssm=NULL;                                                              /* use this as the error check */
d145 1
a145 1
                if(dn) {
d147 3
a149 13
                    fssm = BADDR(dn->dn_Startup);

                    if(fssm) {
                        devname = (char *)BADDR(fssm->fssm_Device)+1;
                        devunit = fssm->fssm_Unit;
                        envec = (LONG *)(BADDR(fssm->fssm_Environ));
                        }
                    }

                /* don't check if we didn't find its startup message */
                /* and don't check if its not a bootnode */
                /* if there's a cd inserted, treat its */
                /* priority as 2 */
d151 6
a156 9
                if (ln->bn_Node.ln_Type == NT_BOOTNODE) {
                    if(fssm && ((envec[0] >= DE_BOOTPRI) && (envec[DE_BOOTPRI] > CDROM_PRIORITY))) { /* is it a bootblock device ? */
                        if(envec[0] >= DE_BOOTBLOCKS) {                                              /* looks like it */
                          OpenDevice(devname,devunit,&V->SReq,0);
                          if(V->SReq.iotd_Req.io_Device) {                                           /* opened it */

                            DoIOR(&V->SReq,CD_CLEAR,0,0,0, V);                                       /* clear cache! */

                            err = DoIOR(&V->SReq,CD_READ,0,BUF_SIZE,Buf, V);
d158 9
a166 13
                            DoIOR(&V->SReq,CD_MOTOR,0,0,0, V);                                       /* Motor off */
                            CloseDevice(&V->SReq);
                            if(!err&&(((*((LONG *)Buf)&0xFFF0) == (ID_DOS_DISK&0xFFF0))) ||
                                (*((LONG *)Buf) == (('B'<<24)|('O'<<16)|('O'<<8)|'T'))) {

                                if (!ChkSumFD(Buf)) {                                                /* bootable */

                                    Permit();
                                    return;
                                    }
                                }
                              }
                            }
d168 1
a168 6
                        else {
                            /* assume its a bootpoint for now */
                            Permit();
                            return;
                            }
                        }
d170 1
a170 3
                    else if (!V->boot) {

                        Permit();
d174 1
a174 3

                ln = (struct BootNode *)ln->bn_Node.ln_Succ;
                }
d177 1
a177 3
        if (V->CDReady) {

            if (GetIOActual(&V->CDReq, CD_ISROM, V)) {
d179 7
a185 3
                if (ValidDisk()) {

                    switch (CheckTM(V)) {
d187 4
a190 4
                        case 0: break;
                        case 1: return;                                     /* Boot CDGS title */
                        case 2:
                                ShutDownAnimation(V);                       /* Boot old CDTV title */
d193 1
a193 1
                                Kludges(V);                                 /* apply kludges for selected titles */
a196 1
                }
d198 1
a198 1
            else {                          /* must be an Audio Disk */
d200 3
a202 2
                ShutDownAnimation(V);
                DoPlayer();
a203 3
    
            V->ErrorOn = -1;
            V->CDReady = FALSE;             /* prevent boot cycling */
d206 2
a207 1
        if (!Animating) Animating = StartAnimation(V);
d209 1
a209 2
        WaitTOF();
        }
d211 1
a211 1
    if (V->ErrorOn) {                       /* Did error timeout? */
d213 1
a213 4
        ShutDownAnimation(V);
        REBOOT();
        }
    }
d215 1
d217 1
a217 13
/***********************************************************************
***
***  Init -- initialize strap program
***
***********************************************************************/
void Init(struct V *V) {

UWORD   *point = (UWORD *)0xF0000C;
int      i, j=0;

    /* read the rom version number from the beginning of the rom */

    i = *point++;   
d219 4
a222 1
    if (i>9) {
d224 5
a228 6
        V->vstorage[j++]=div10(i)+'0';
        i -= div10(i)*10;
        }
    
    V->vstorage[j++]=i+'0';
    V->vstorage[j++]='.';
d230 1
a230 1
    i = *point;
d232 1
a232 1
    if(i>9) {
d234 1
a234 3
        V->vstorage[j++]=div10(i)+'0';
        i -= div10(i)*10;
        }
d236 2
a237 2
    V->vstorage[j++]=i+'0';
    V->vstorage[j]=0;
d239 2
a240 1
    SetVersionStr(V->vstorage);
d242 3
a244 5
    OpenDevs(V);

    InitAudio(V);                                   /* patches */
    FixBlitInt(V);
    FindChain(V);
d246 2
a247 2
    V->CDChgCnt = -1;
    }
d249 3
d253 1
d255 5
a259 1
int div10(int i) {
d261 3
a263 1
int j=0;
d265 16
a280 1
    while(i > 10) {
d282 1
a282 6
        i -= 10;
        j++;
        }

    return(j);
    }
d284 1
d286 3
a288 49

/***********************************************************************
***
***  Quit -- cleanup the strap program
***
***********************************************************************/
void Quit(struct V *V) {

    CloseDevs(V);

    CloseLibrary(DeBoxBase);
    CloseLibrary(DOSBase);
    CloseLibrary(PlayerPrefsBase);
    CloseLibrary(CDFSBase);
    CloseLibrary(ExpansionBase);
    }


/***********************************************************************
***
***  OpenDevs -- open and setup devices and device I/O requests
***
***********************************************************************/
void OpenDevs(struct V *V) {

    V->IOPort.mp_Flags     = 0;
    V->IOPort.mp_SigBit    = AllocSignal(-1);
    V->IOPort.mp_SigTask   = FindTask(NULL);

    NewList(&V->IOPort.mp_MsgList);

    V->IOReq.io_Message.mn_Node.ln_Type = NT_MESSAGE;
    V->IOReq.io_Message.mn_ReplyPort    = &V->IOPort;
    V->IOReq.io_Device                  = NULL;                               /* test if it opened will need this */

    V->CDReq = V->IOReq;                                                      /* struct copy */
    V->IRReq = V->IOReq;                                                      /* struct copy */

    V->SReq.iotd_Req  = V->IOReq;                                             /* struct copy */
    V->TDReq.iotd_Req = V->IOReq;                                             /* struct copy */
        
    OpenDevice("cdtv.device", 0, &V->CDReq, 0);

    OpenDevice("trackdisk.device", 0, &V->TDReq, 0);

    if(!V->TDReq.iotd_Req.io_Device) {                                        /* if unit 0 open failed, try unit 1 */

        OpenDevice("trackdisk.device" ,1, &V->TDReq, 0);
        }
d290 1
a290 53
    V->CDChgCnt = V->TDChgCnt = -1;
    }

/***********************************************************************
***
***  CloseDevs -- close devices
***
************************************************************************/
void CloseDevs(struct V *V) {
    
    if (V->CDReq.io_Device)          CloseDevice(&V->CDReq);             /* opendev zaps io_device fail */
    if (V->TDReq.iotd_Req.io_Device) CloseDevice(&V->TDReq);
    if (V->IOPort.mp_SigBit != (-1)) FreeSignal(V->IOPort.mp_SigBit);
    }


/***********************************************************************
***
***  CheckDevs -- check for a change in device states
***
***********************************************************************/
void CheckDevs(struct V *V) {

register LONG cnt;

    cnt = GetIOActual(&V->CDReq,CD_CHANGENUM, V);

    if (cnt > V->CDChgCnt) {

        V->CDChgCnt = cnt;
        V->CDReady = !GetIOActual(&V->CDReq, CD_CHANGESTATE, V);
        }

    if (V->TDReq.iotd_Req.io_Device) {

        cnt = GetIOActual(&V->TDReq,CD_CHANGENUM, V); 

        if (cnt > V->TDChgCnt) {

            V->TDChgCnt = cnt; 
            V->TDReady = !GetIOActual(&V->TDReq, CD_CHANGESTATE, V);  
            }       
        }
    }

/***********************************************************************
***
***  CheckTM -- check trade mark
***
***********************************************************************/
int CheckTM(struct V *V) {

UWORD             *ReadTMBuff, *TMBuff;
d292 1
a292 1
BPTR               ItemFile;
d295 1
a295 1
    return(2);
d297 1
a297 1
    if (ReadTMBuff = AllocMem(2048, MEMF_PUBLIC)) {
d299 7
a305 3
        Header = &trademark;

        if (TMBuff = AllocMem(Header->ci_Size, MEMF_PUBLIC)) {
d307 1
a307 1
            if (ItemFile = Open("CD0:TRADEMARK", MODE_OLDFILE)) {
d309 1
a309 1
                if (Read(ItemFile, ReadTMBuff, 2048) == 2048) {
d313 1
a313 1
                        if (Compare(ReadTMBuff, TMBuff, 2048)) result = 1;
d315 2
a317 2

                Close(ItemFile);
a318 2

            FreeMem(TMBuff, Header->ci_Size);
d323 3
a325 1
            Header = &trademark;
d327 1
a327 1
            if (TMBuff = AllocMem(Header->ci_Size, MEMF_PUBLIC)) {
d329 1
a329 1
                if (ItemFile = Open("CD0:CDTV.TM", MODE_OLDFILE)) {
d331 1
a331 1
                    if (Read(ItemFile, ReadTMBuff, 2048) == 2048) {
d335 1
a335 1
                            if (Compare(ReadTMBuff, TMBuff, 2048)) result = 2;
d337 2
a339 2

                    Close(ItemFile);
a340 2

                FreeMem(TMBuff, Header->ci_Size);
a342 2

        FreeMem(ReadTMBuff, 2048);
a346 41

#if 0

struct TMStruct *TMInfo;
ULONG            sector;
ULONG            size;
int              i;

    TMInfo = GetTMInfo();
    if ((size = TMInfo->Size) == 0) return FALSE;
    size += 8;                                                          /* safety margin */

    TMBuff = AllocMem(size,0);
    if (!TMBuff) return FALSE;

    for (i = 0; i < 4; i++) {

        if ((sector = TMInfo->Sectors[i]) == 0) break;

        if (!DoIOR(&V->CDReq, CD_READ, sector*2048, size, TMBuff, V)) {

            if (PrepareTM()) {

                ShutDownAnimation(V);

                if (DisplayTM()) {

                    FreeMem(TMBuff,size);
                    return TRUE;
                    }
                }
            }
        }

    FreeMem(TMBuff, size);
    return FALSE;
    }

#endif


@


1.1
log
@Initial revision
@
text
@a0 9
 /***********************************************************************
***
***  CDTV Strap
***
*** CONFIDENTIAL and PROPRIETARY
*** Copyright (c) 1991 by Commodore-Amiga, Inc.
*** Created by Carl Sassenrath, Sassenrath Research, Ukiah, CA
***
***********************************************************************/
a12 3
#include <exec/io.h>
#include <exec/interrupts.h>

a14 1

a17 1

a18 1

d23 1
a23 1
#include "internal/cdtvkeys.h"
d25 3
a27 2
#include "internal/cdtv_cr_hw.h"
#include "cddev.h"
d29 2
a30 3
#include "internal/playerprefsbase.h"
#include "internal/playerprefs_private_pragmas.h"
#include "internal/cdfs_pragmas.h"
d35 1
d37 1
a38 1
#include "cdstrap.h"
a39 1
#define EMPTY(n)    ((ULONG)(n)->lh_Head == (ULONG)&n->lh_Tail)
d42 4
d55 2
a56 2
extern  char __far CDBOOT[];

a73 3
void        ShowBootImage(struct V *V);
void        EraseBootImage(struct V *V);
void        EraseError(struct V *V);
d75 2
d101 1
d117 3
d125 3
d129 2
a130 1
    if (!SysBase || !ExpansionBase || !CDFSBase || !GfxBase || !PlayerPrefsBase) HANG;
d134 4
d157 9
d167 1
a167 1
    while (V->ErrCycle < ERR_TIMEOUT) { /* don't wait forever on an error */
d170 85
d261 1
a261 1
                    if (CheckTM(V)) {       /* turn on rotating light if we have CDTV */
d263 8
a270 2
                        Kludges(V);         /* apply kludges for selected titles */
                        return;
d277 1
a277 1
                EraseBootImage(V);
d285 3
a287 1
        ShowBootImage(V);
d292 1
a292 1
        EraseBootImage(V);
a297 16
DoIOR(struct IOStdReq *Req, UWORD cmd, ULONG Offset, ULONG Length, UWORD *Data, struct V *V) {

    if (Req->io_Device) {

        Req->io_Command = cmd;
        Req->io_Offset  = Offset;
        Req->io_Length  = Length;
        Req->io_Data    = (APTR)Data;

        return(DoIO(Req));
        }

    return(0);
    }


d336 1
a336 3
    /* patches */

    InitAudio(V);
d343 17
a366 2
    EraseBootImage(V);

d369 2
d401 9
a439 1
        EraseError(V);
d442 10
d459 46
a504 1
CheckTM(struct V *V) {
d506 14
a519 1
extern  struct TMStruct *GetTMInfo();
a521 1
UWORD           *TMBuff;
d539 1
a539 1
            if (PrepareTM(TMBuff, size-8)) {
d541 1
a541 1
                EraseBootImage(V);
d556 1
a556 113
/***********************************************************************
***
***  ShowBootImage -- bring up CDTV title screen
***
***********************************************************************/
void ShowBootImage(struct V *V) {

    if (V->ErrorOn < 0) {

        V->ErrorOn = 1;
        V->ErrCycle = 0;
        V->TitleOn = TRUE;
        CDTVTitle(TITLESTATUS_ERROR);
        }

    if (V->TitleOn) return;

    V->TitleOn = TRUE;
    CDTVTitle(TITLESTATUS_NORMAL);
    }

/***********************************************************************
***
***  EraseBootImage -- erase the CDTV title screen
***
***********************************************************************/
void EraseBootImage(struct V *V) {

    if (!V->TitleOn) return;
    V->TitleOn = FALSE;
    CDTVTitle(TITLESTATUS_LEAVE);
    }

/***********************************************************************
***
***  EraseError -- return error screen to normal screen
***
***********************************************************************/
void EraseError(struct V *V) {

    if (!V->ErrorOn) return;
    V->ErrorOn = 0;
    CDTVTitle(TITLESTATUS_NORMAL);
    }

/***********************************************************************
***
***  GetIOActual -- do an I/O and return IO_ACTUAL field
***
***********************************************************************/
int GetIOActual(register struct IOStdReq *req, LONG cmd, struct V *V) {

    DoIOR(req, cmd, 0, 0, 0, V);
    return((int)req->io_Actual);
    }


/***********************************************************************
***
***  InitAudio
***  fires up the audio.device under 2.0 for cdtv apps
***********************************************************************/

void InitAudio(struct V *V) {

struct Resident *Res;
struct ExecBase *EB = SysBase;

    if (EB->LibNode.lib_Version < 36) return;

    if (!FindName((struct List *)&EB->DeviceList, "audio.device")) {

        if (Res = (struct Resident *)FindResident("audio.device")) InitResident(Res, 0L);
        }
    }



/* a kludge for the 2.0 cia priority problem */

void ChangeServer(struct List *slist, struct V *V) {

struct Node *cd;

    if (EMPTY(slist)) return;

    Disable();

    if (cd = (struct Node *)FindName((struct List *)slist, (UBYTE *)"ciaa.resource")) {

        if(cd->ln_Pri <= 0) {                                                           /* CIA got dropped to -100 in 2.0! */

            Remove(cd);
            cd->ln_Pri = 100;
            Enqueue(slist, cd);
            }
        }

    Enable();
    }


void FindChain(struct V *V) {

register struct IntVector   *iv = &SysBase->IntVects[3];
VOID                        *sc = (APTR)SysBase->IntVects[3].iv_Code;

    if (iv->iv_Code == sc) {

        ChangeServer(iv->iv_Data, V);
        }
    }

a558 1
void Kludges(struct V *V) {
a559 32
register struct MsgPort *mp;

    if (mp = (struct MsgPort *)AllocMem(sizeof(struct MsgPort),MEMF_CLEAR|MEMF_PUBLIC)) {

        /* no signal/task stuff needed or allowed */

        mp->mp_Node.ln_Type = NT_MSGPORT;
        mp->mp_Node.ln_Name = &CDBOOT[0];

        AddPort(mp);

        /* let SetPatch module find it, and free it later */
        }   
    }



int div10(int i) {

int j=0;

    while(i > 10) {

        i -= 10;
        j++;
        }

    return(j);
    }


    
@
