head     1.28;
branch   ;
access   ;
symbols  ;
locks    peter:1.28; strict;
comment  @ * @;


1.28
date     93.04.07.23.37.36;  author peter;  state Exp;
branches ;
next     1.27;

1.27
date     93.04.07.16.57.07;  author peter;  state Exp;
branches ;
next     1.26;

1.26
date     93.04.06.15.22.19;  author peter;  state Exp;
branches ;
next     1.25;

1.25
date     93.03.31.18.01.29;  author peter;  state Exp;
branches ;
next     1.24;

1.24
date     93.03.31.15.16.44;  author peter;  state Exp;
branches ;
next     1.23;

1.23
date     93.03.25.23.02.02;  author peter;  state Exp;
branches ;
next     1.22;

1.22
date     93.03.25.19.36.45;  author peter;  state Exp;
branches ;
next     1.21;

1.21
date     93.03.23.10.35.13;  author peter;  state Exp;
branches ;
next     1.20;

1.20
date     93.03.19.19.18.31;  author peter;  state Exp;
branches ;
next     1.19;

1.19
date     93.03.19.18.57.39;  author peter;  state Exp;
branches ;
next     1.18;

1.18
date     93.03.17.16.55.18;  author peter;  state Exp;
branches ;
next     1.17;

1.17
date     93.03.11.18.44.47;  author peter;  state Exp;
branches ;
next     1.16;

1.16
date     93.03.08.18.23.35;  author peter;  state Exp;
branches ;
next     1.15;

1.15
date     93.03.03.13.31.52;  author peter;  state Exp;
branches ;
next     1.14;

1.14
date     93.02.26.19.03.51;  author peter;  state Exp;
branches ;
next     1.13;

1.13
date     93.02.23.15.38.12;  author peter;  state Exp;
branches ;
next     1.12;

1.12
date     93.02.05.13.22.49;  author jerryh;  state Exp;
branches ;
next     1.11;

1.11
date     93.02.01.15.32.42;  author jerryh;  state Exp;
branches ;
next     1.10;

1.10
date     93.02.01.15.29.20;  author jerryh;  state Exp;
branches ;
next     1.9;

1.9
date     93.01.22.11.50.42;  author jerryh;  state Exp;
branches ;
next     1.8;

1.8
date     93.01.07.11.02.08;  author jerryh;  state Exp;
branches ;
next     1.7;

1.7
date     92.12.18.11.42.22;  author jerryh;  state Exp;
branches ;
next     1.6;

1.6
date     92.09.21.13.48.43;  author jerryh;  state Exp;
branches ;
next     1.5;

1.5
date     92.08.03.09.52.46;  author jerryh;  state Exp;
branches ;
next     1.4;

1.4
date     92.07.31.14.10.16;  author jerryh;  state Exp;
branches ;
next     1.3;

1.3
date     92.07.30.13.18.39;  author jerryh;  state Exp;
branches ;
next     1.2;

1.2
date     92.07.29.10.10.46;  author jerryh;  state Exp;
branches ;
next     1.1;

1.1
date     92.07.23.11.36.18;  author jerryh;  state Exp;
branches ;
next     ;


desc
@main module for player program.  This is basically a flow
control module.
@


1.28
log
@Now rely on playerlibrary to manage the state of the time-display's
minus sign.  Now also PreparePlayList() when hitting FF or RW when
stopped.  We need this to allow start-track selection with these
keys, since we changed the default state of the tracks to all dim.
@
text
@/* $Id: player.c,v 1.27 93/04/07 16:57:07 peter Exp Locker: peter $ */

#include <exec/types.h>
#include <exec/io.h>
#include <exec/execbase.h>
#include <exec/memory.h>

#include <graphics/gfxbase.h>
#include <devices/input.h>
#include <devices/inputevent.h>

#include <cd/cd.h>

#include <cdtv/cdtvprefs.h>
#include <libraries/debox.h>

#include "/screensaver/screensaver.h"

#include "/screencoords.h"
#include "/playerprefs.h"
#include "/display.h"
#include "/playerprefsbase.h"

#include "/playerprefs_pragmas.h"
#include "/playerprefs_protos.h"
#include "/display_protos.h"
#include "/other_protos.h"

#include <clib/alib_protos.h>
#include <clib/exec_protos.h>
#include <clib/dos_protos.h>
#include <clib/graphics_protos.h>
#include <clib/intuition_protos.h>
#include <clib/debox_protos.h>
#include <cdg/cdg_cr_protos.h>

#include <pragmas/exec_old_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/debox_pragmas.h>
#include <cdg/cdg_cr_pragmas.h>

#include <cdg/cdgprefs.h>

#include <libraries/lowlevel.h>
#include <clib/lowlevel_protos.h>
#include <pragmas/lowlevel_pragmas.h>

#include <internal/playerlibrary.h>
#include <clib/player_protos.h>
#include <pragmas/player_pragmas.h>

#include <string.h>

/*************************** External Functions ****************************/

extern BOOL             CDGBegin();
extern VOID             CDGEnd();
extern VOID             CDGChannel(ULONG);
extern VOID             EndPPScreen(VOID);
extern VOID             InitVarBase(struct PlayerPrefsBase *ppb);
extern UWORD *          DoAnimation(UWORD *ins, ULONG update );
extern ULONG NOOP(void);

/********************* External Structures/Variables ***********************/

extern struct GfxBase          *GfxBase;
extern struct Library          *IntuitionBase;
extern struct DeBoxBase        *DeBoxBase;
extern struct ExecBase         *SysBase;
extern struct PlayerPrefsBase  *PlayerPrefsBase;
extern struct Library          *LowLevelBase;

extern struct IBuffer          *CurrentIB;
extern struct IBuffer          *WorkIB;
extern struct IBuffer          *MasterIB;

extern UWORD volatile __far     vhposr;                     /* Custom chip register. */
extern char __far               TimerDeviceName[];

extern UBYTE __far              scrdata[];

/******************************* Functions *********************************/

static void  PlayerLoop(struct CDGPrefs *);
static void  DoKeyStroke(UWORD);
void  UpdateGadgets(void);
static UWORD *SetupPlayer(void);
static void  ShutDown(void);
static void  DoReset(void);
static void  AbortQCode(void);
static int SubmitKeys(UWORD event);
static void SetPlayList( ULONG enable );
static void PreparePlayList( void );
static void UnpreparePlayList( void );

/************************* Structures/Variables ****************************/

struct BuildBg_Info __far PlayerBg =
{
    NULL,		/* struct Header *BackHeader */
    NULL,		/* UBYTE *BackData (strip) */
    NULL,		/* struct Header *ForHeader */
    scrdata,		/* UBYTE *ForData (foreground image) */
    320, 200, 6,	/* Width, Height, Depth */
    0, 0,		/* ForXOff, ForYOff */
    NULL		/* Flags */
};

UBYTE  IntroLastTrack = 0;
UWORD  IntroCount;
WORD  IntroFlashTicks = 0;
WORD noscrolltracks = 0;
UBYTE  LastPlayState, LastPlayMode;
LONG ShuffleMode = 0;
LONG StopCount = 0;
LONG haveCD = 0;
LONG playertofront = 0;
extern ULONG randomseed;
UBYTE TotalMinutes = 100;
UBYTE TotalSeconds = 100;
ULONG NumSelectedTracks = 0;

union  CDTOC         *TOC;
struct QCode          qcode, copyqcode;
int                   qvalid, qoutstanding, toutstanding;
struct MsgPort       *cdreply, *qcodereply, *TimeReplyPort;
struct IOStdReq      *cdio, *cdqcode;
struct timerequest   *TimeReq;

struct PlayerOptions  PlayerOptions, OptionsSet;
struct PlayerState    PlayerState;
struct PlayList      *PlayList;
struct PlayList      *UndoPlayList;

struct Library       *CDGBase;
struct PlayerBase    *PlayerBase;

/* CDGstate definitions.  The values form a progression, with
 * each state implying the previous (except CDG_UNAVAILABLE is not
 * implied, of course).
 * CDG_UNAVAIABLE means CDGBegin() failed, and we're not to try
 *	any CDG...() calls.
 * CDG_AVAILABLE means CDGBegin() succeeded, but we have not turned
 *	on subcode processing (by calling CDGPlay()), or that we
 *	have turned it off (by calling CDGStop()).
 * CDG_SUBCODES means that CDGPlay() has been called, and therefore
 *	subcodes are being processed by cdg.library.  This state
 *	indicates that we don't have (or don't yet know that we have)
 *	CD+G packets in those subcodes.
 * CDG_HAVEGRAPHICS means we know that CD+G packets are coming off
 *	this disk.
 * CDG_SHOWGRAPHICS means that CD+G packets are coming in, and we
 *	have the CD+G screen frontmost.
 */

#define CDG_UNAVAILABLE		0
#define CDG_AVAILABLE		1
#define CDG_SUBCODES		2
#define CDG_HAVEGRAPHICS	3
#define CDG_SHOWGRAPHICS	4
int CDGstate;

UBYTE  CDGchannel = 1;

ULONG  currsec;

UBYTE  KeyPressed = PKSF_RELEASE;

/********************************* Tables **********************************/

UWORD IntroData[] =
{
    PLGAD_DISK,24, 0xffff,
    PLGAD_DISK,23, PLGAD_COUNTER, COUNTER_FLYING + 0, 0xffff,
    PLGAD_DISK,22, PLGAD_COUNTER, COUNTER_FLYING + 1, 0xffff,
    PLGAD_DISK,21, PLGAD_COUNTER, COUNTER_FLYING + 2, 0xffff,
    PLGAD_DISK,20, PLGAD_COUNTER, COUNTER_FLYING + 3, 0xffff,
    PLGAD_DISK,19, PLGAD_COUNTER, COUNTER_FLYING + 4, 0xffff,
    PLGAD_DISK,18, PLGAD_COUNTER, COUNTER_FLYING + 5, 0xffff,
    PLGAD_DISK,17, PLGAD_COUNTER, COUNTER_FLYING + 6, 0xffff,
    PLGAD_DISK,16, PLGAD_COUNTER, COUNTER_FLYING + 7, 0xffff,
    PLGAD_DISK,15, PLGAD_COUNTER, COUNTER_FLYING + 8, 0xffff,
    PLGAD_DISK,14, PLGAD_COUNTER, COUNTER_FLYING + 9, 0xffff,
    PLGAD_DISK,13, PLGAD_COUNTER, COUNTER_FLYING +10, 0xffff,
    PLGAD_DISK,12, PLGAD_COUNTER, COUNTER_FLYING +11, 0xffff,
    PLGAD_DISK,11, PLGAD_COUNTER, COUNTER_FLYING +12, 0xffff,
    PLGAD_DISK,10, PLGAD_COUNTER, COUNTER_FLYING +13, 0xffff,
    PLGAD_DISK, 9, PLGAD_COUNTER, COUNTER_FLYING +14, 0xffff,
    PLGAD_DISK, 8, PLGAD_COUNTER, COUNTER_FLYING +15, 0xffff,
    PLGAD_DISK, 7, PLGAD_COUNTER, COUNTER_FLYING +16, 0xffff,
    PLGAD_DISK, 6, PLGAD_COUNTER, COUNTER_FLYING +17, 0xffff,
    PLGAD_DISK, 5, PLGAD_COUNTER, COUNTER_FLYING +18, 0xffff,
    PLGAD_DISK, 4, PLGAD_COUNTER, COUNTER_FLYING +19, 0xffff,
    PLGAD_DISK, 3, PLGAD_COUNTER, COUNTER_FLYING +20, 0xffff,
    PLGAD_DISK, 2, PLGAD_COUNTER, COUNTER_FLYING +21, 0xffff,
    PLGAD_DISK, 1, PLGAD_COUNTER, 0,         0xffff,
    0xffff
};


UWORD ShutdownAnim[] =
{
    PLGAD_STOP,0,PLGAD_REV,0,PLGAD_PLAY,0,PLGAD_FF,0,
    PLGAD_SHUFF,0,PLGAD_CDG,0, PLGAD_COLON, 0, PLGAD_MIN, 100, PLGAD_SEC, 100, PLGAD_NEG, 0, 0xffff,
    PLGAD_20, 0, 0xffff,
    PLGAD_19, 0, 0xffff,
    PLGAD_18, 0, 0xffff,
    PLGAD_17, 0, 0xffff,
    PLGAD_16, 0, 0xffff,
    PLGAD_15, 0, 0xffff,
    PLGAD_14, 0, 0xffff,
    PLGAD_13, 0, 0xffff,
    PLGAD_12, 0, 0xffff,
    PLGAD_11, 0, 0xffff,
    PLGAD_10, 0, 0xffff,
    PLGAD_9 , 0, 0xffff,
    PLGAD_8 , 0, 0xffff,
    PLGAD_7 , 0, 0xffff,
    PLGAD_6 , 0, 0xffff,
    PLGAD_5 , 0, 0xffff,
    PLGAD_4 , 0, 0xffff,
    PLGAD_3 , 0, 0xffff,
    PLGAD_2 , 0, 0xffff,
    PLGAD_1 , 0, 0xffff,
    0xffff
};


UWORD DiskOutAnim[] =
{
    PLGAD_DISK, 1, 0xffff,
    PLGAD_DISK, 2, 0xffff,
    PLGAD_DISK, 3, 0xffff,
    PLGAD_DISK, 4, 0xffff,
    PLGAD_DISK, 5, 0xffff,
    PLGAD_DISK, 6, 0xffff,
    PLGAD_DISK, 7, 0xffff,
    PLGAD_DISK, 8, 0xffff,
    PLGAD_DISK, 9, 0xffff,
    PLGAD_DISK,10, 0xffff,
    PLGAD_DISK,11, 0xffff,
    PLGAD_DISK,12, 0xffff,
    PLGAD_DISK,13, 0xffff,
    PLGAD_DISK,14, 0xffff,
    PLGAD_DISK,15, 0xffff,
    PLGAD_DISK,16, PLGAD_COUNTER,COUNTER_FLYING +21, 0xffff,
    PLGAD_DISK,17, PLGAD_COUNTER,COUNTER_FLYING +20, 0xffff,
    PLGAD_DISK,18, PLGAD_COUNTER,COUNTER_FLYING +19, 0xffff,
    PLGAD_DISK,19, PLGAD_COUNTER,COUNTER_FLYING +18, 0xffff,
    PLGAD_DISK,20, PLGAD_COUNTER,COUNTER_FLYING +17, 0xffff,
    PLGAD_DISK,21, PLGAD_COUNTER,COUNTER_FLYING +16, 0xffff,
    PLGAD_DISK,22, PLGAD_COUNTER,COUNTER_FLYING +15, 0xffff,
    PLGAD_DISK,23, PLGAD_COUNTER,COUNTER_FLYING +14, 0xffff,
    PLGAD_DISK,24, PLGAD_COUNTER,COUNTER_FLYING +13, 0xffff,
    PLGAD_COUNTER,COUNTER_FLYING +12, 0xffff,
    PLGAD_COUNTER,COUNTER_FLYING +11, 0xffff,
    PLGAD_COUNTER,COUNTER_FLYING +10, 0xffff,
    PLGAD_COUNTER,COUNTER_FLYING + 9, 0xffff,
    PLGAD_COUNTER,COUNTER_FLYING + 8, 0xffff,
    PLGAD_COUNTER,COUNTER_FLYING + 7, 0xffff,
    PLGAD_COUNTER,COUNTER_FLYING + 6, 0xffff,
    PLGAD_COUNTER,COUNTER_FLYING + 5, 0xffff,
    PLGAD_COUNTER,COUNTER_FLYING + 4, 0xffff,
    PLGAD_COUNTER,COUNTER_FLYING + 3, 0xffff,
    PLGAD_COUNTER,COUNTER_FLYING + 2, 0xffff,
    PLGAD_COUNTER,COUNTER_FLYING + 1, 0xffff,
    PLGAD_COUNTER,COUNTER_FLYING + 0, 0xffff,
    0xffff
};


/****** playerprefs.library/DoPlayer ****************************************
*
*   NAME
*   DoPlayer -- Start CD audio control panel.
*
*   SYNOPSIS
*   DoPlayer();
*
*   VOID DoPlayer(void);
*
*   FUNCTION
*   Starts the CD audio control panel.  This function never returns.
*
*   RESULT
*   Like the fabled DETONATE instruction, the function returning
*   indicates an error.
*
*   EXAMPLE
*   DoPlayer();
*   error_exit();
*
*   NOTES
*
*   BUGS
*   Yes.
*
*   SEE ALSO
*
*****************************************************************************
*/


#ifdef INCLUDE_CLEANUP
LONG __asm
DoPlayer(register __a6 struct PlayerPrefsBase *ppb)
#else
void __asm
DoPlayer(register __a6 struct PlayerPrefsBase *ppb)
#endif
{
extern struct GadDir                PlayGADList[];
extern UBYTE  __far                 scrbuttons[];
extern struct BuildBg_Info __far    PlayerBg;
#define LVOScreenDepth -0x312

struct CDGPrefs     cdp;
int                 i;

    /* Initilize the variables */
    InitVarBase(ppb);
    SetChipRev( SETCHIPREV_BEST );

    /* Patching ScreenDepth() to fail prevents Amiga-M/N from having
     * any effect.  This is required to support CD+G.  We could
     * alternately apply an input-handler to catch those keys.
     * An input handler is easier to remove, but the SetFunction()
     * is easier to apply.  Since we exit through reboot, this
     * seems good enough.
     */
    SetFunction( IntuitionBase, LVOScreenDepth, NOOP );

    randomseed = (-vhposr & 0x7fff) ^ 0x1D6539A3;

    if (!StartPPScreen(PlayGADList, &PlayerBg, scrbuttons))
    {
	for ( i=PLGAD_FIRSTBUTTON; i<=PLGAD_LASTBUTTON; i++ )
	{
	    WorkIB->ib_GState[i] = CurrentIB->ib_GState[i] = (UWORD) ~0;
	}
	WorkIB->ib_GState[PLGAD_MIN] = CurrentIB->ib_GState[PLGAD_MIN] = 100;
	WorkIB->ib_GState[PLGAD_SEC] = CurrentIB->ib_GState[PLGAD_SEC] = 100;

	if (cdreply = (struct MsgPort *)CreateMsgPort())
	{
	    if (qcodereply = (struct MsgPort *)CreateMsgPort())
	    {
		if (cdio = (struct IOStdReq *)CreateStdIO(cdreply))
		{
		    if (cdqcode = (struct IOStdReq *)CreateStdIO(qcodereply))
		    {
			if (!OpenDevice("cd.device", 0, cdio, 0))
			{
			    CopyMem(cdio, cdqcode, sizeof(*cdio));

			    cdio->io_Message.mn_ReplyPort   = cdreply;
			    cdqcode->io_Message.mn_ReplyPort = qcodereply;
			    qoutstanding = toutstanding = qvalid = 0;

			    if (TOC = AllocMem(sizeof(union CDTOC) * NENTRIES, MEMF_PUBLIC))
			    {
				if (UndoPlayList = AllocMem(sizeof(struct PlayList), MEMF_PUBLIC))
				{
				    if (TimeReplyPort = CreateMsgPort())
				    {
					if (TimeReq = (struct timerequest *)
					    CreateExtIO(TimeReplyPort, sizeof(struct timerequest)))
					{
					    if (!OpenDevice("timer.device", UNIT_VBLANK, TimeReq, 0))
					    {
						if (PlayerBase = (struct PlayerBase *)OpenLibrary("player.library", NULL))
						{
						    struct TagItem add_createkeys[] =
						    {
							SCON_AddCreateKeys, 0,
							SCON_AddCreateKeys, 1,
							TAG_DONE,
						    };

						    if ( !SystemControlA( add_createkeys ) )
						    {

							if (CDG_Open(&cdp))
							{
							    if (UnpackSprites(&cdp))
							    {
								PlayerLoop(&cdp);
/* Don't bother cleaning up since we exit via reboot
 * The CLEAN() macro selectively includes or excludes the code,
 * based on the state of the INCLUDE_CLEANUP definition.
 */
#ifdef INCLUDE_CLEANUP
#define CLEAN(x)	x
#else
#define CLEAN(x)	;
#endif
								CLEAN( CDG_Close() );
							    }
							}
#ifdef INCLUDE_CLEANUP
							{
							    struct TagItem rem_createkeys[] =
							    {
								SCON_RemCreateKeys, 0,
								SCON_RemCreateKeys, 1,
								TAG_DONE,
							    };

							    SystemControlA( remove_createkeys );
							}
#endif
						    }

						    CLEAN( CloseLibrary(PlayerBase) );
						}

						CLEAN( CloseDevice(TimeReq) );
					    }

					    CLEAN( DeleteExtIO(TimeReq) );
					}

					CLEAN( DeleteMsgPort(TimeReplyPort) );
				    }
				    CLEAN( FreeMem(UndoPlayList, sizeof(struct PlayList)) );
				}

				CLEAN( FreeMem(TOC, sizeof(union CDTOC) * NENTRIES) );
			    }

			    CLEAN( AbortQCode() );

			    CLEAN( CloseDevice(cdio) );
			}

			CLEAN( DeleteStdIO(cdqcode) );
		    }

		    CLEAN( DeleteStdIO(cdio) );
		}

		CLEAN( DeleteMsgPort(qcodereply) );
	    }

	    CLEAN( DeleteMsgPort(cdreply) );
	}

	CLEAN( EndPPScreen() );
    }


#ifdef INCLUDE_CLEANUP
    return(20);
#else
    /* If we get here, it's because we failed to init, so let's die */
    ColdReboot();
#endif
}




/************************ Main Player Event Loop ***************************/

static void
PlayerLoop(struct CDGPrefs *cdp)
{

ULONG event;
UWORD *anim;

    CDGstate = CDG_UNAVAILABLE;
    if ( CDGBegin( cdp ) )
    {
	CDGstate = CDG_AVAILABLE;
    }

    anim = SetupPlayer();

    while(1)
    {
	if ( haveCD )
	{
	    while( event = GetIDCMPEvent() )
	    {
		DoKeyStroke( event );
	    }

	    /* -1 indicates a non-audio disk.  Let's not reboot if
	     * the user is changing audio disks.
	     */
	    if ( PlayerState.AudioDisk != 1 )
	    {
		/* If the intro animation was in progress, it's best
		 * to let it complete before we shut down.
		 */
		while ( anim )
		{
		    anim = DoAnimation( anim, 1 );
		}
		ShutDown();
		if ( PlayerState.AudioDisk == ~0 )
		{
		    DoReset();
		}
	    }
	    else
	    {
		/* We scroll the track table to put the currently
		 * playing track into view.  However, if the
		 * user is visiting the track table while the disk
		 * is playing, we don't want to fight over who gets
		 * to control the scrolling, the user's movements or
		 * the desire to put the current track into view.
		 * Here we decrement the counter, which, while non-zero,
		 * prevents auto-scrolling of the track table.
		 * If we're not playing or paused, nuke the variable.
		 */
		if ( noscrolltracks )
		{
		    noscrolltracks--;
		}
		if ( PlayerState.PlayState < PLS_PLAYING )
		{
		    noscrolltracks = 0;
		}

		UpdateGadgets();

		/* Since the state is really controlled by player.library,
		 * we do this little thing to detect whenever we transition
		 * to stopped state.  We count off a few VBlanks for
		 * safety, horrible though that is.
		 */
		if ( PlayerState.PlayState != PLS_STOPPED )
		{
		    StopCount = 5;
		}
		else if ( ( StopCount ) && ( --StopCount == 0 ) )
		{
		    if ( ShuffleMode )
		    {
			UnShuffleGrid();
			ShuffleMode = 0;
		    }
		    UnpreparePlayList();
		}

		/* If subcodes are on, then call CDGDraw() */
		if ( CDGstate >= CDG_SUBCODES )
		{
		    MasterIB->ib_GState[PLGAD_CDG] = CDGDraw( CDGF_GRAPHICS|CDGF_MIDI );
		}

		/* Did CD+G just turn itself on? */
		if ( ( MasterIB->ib_GState[PLGAD_CDG] & CDGF_GRAPHICS ) &&
		    ( CDGstate == CDG_SUBCODES ) )
		{
		    CDGClearScreen();

		    if ( PlayerState.PlayState == PLS_PAUSED )
		    {
			CDGPause();
		    }

		    AbleColorChanger( FALSE );
		    CDGFront();
		    CDGstate = CDG_SHOWGRAPHICS;

		    if ( ( PlayerState.PlayMode == PLM_FFWD ) || ( PlayerState.PlayMode == PLM_SKIPFWD ) )
		    {
			CDGFastForward();
		    }
		    else if ( ( PlayerState.PlayMode == PLM_FREV ) || ( PlayerState.PlayMode == PLM_SKIPREV ) )
		    {
			CDGRewind();
		    }
		}

		if ( CDGstate != CDG_SHOWGRAPHICS )
		{
		    UpdateDisplay();
		    if ( playertofront )
		    {
			playertofront = 0;
			RethinkDisplay();
			AbleColorChanger( TRUE );
		    }
		}
	    }
	}
	else	/* ( haveCD == FALSE ) */
	{
	    /* This function just strips IntuiMessages.  The function
	     * only strips events older than a few seconds.  The benefit
	     * is that we get a kind of "type-ahead", in that if
	     * the user selects play a second or two before the
	     * player.library tells us about the insertion of the
	     * disk, the play event is still queued for processing
	     * in the normal (audio disk is present) part of this
	     * event loop.
	     */
	    StripIDCMPEvents();
	    {
	    }
	    /* Waiting for a CD to be inserted into the drive */
	    GetPlayerState(&PlayerState);
	    if ( PlayerState.AudioDisk == 1 )
	    {
		anim = SetupPlayer();
	    }
	    else if ( PlayerState.AudioDisk == ~0 )
	    {
		DoReset();
	    }
	}

	if ( anim )
	{
	    anim = DoAnimation( anim, 0 );
	}
	else
	{
	    WaitTOF();
	}
    }
}





/*********************** Interpret KeyStroke Event *************************/

static void
DoKeyStroke(UWORD event)
{
    if ( CDGstate != CDG_SHOWGRAPHICS )
    {
	/* If it's an up or down stroke of the select button, then
	 * figure out what event current gadget would like to send
	 * instead.
	 */
	if ( ( event == KEY_SELECT ) || ( event == ( KEY_SELECT | IECODE_UP_PREFIX ) ) ||
	    ( event == GC0_SELECT ) || ( event == ( GC0_SELECT | IECODE_UP_PREFIX ) ) ||
	    ( event == GC1_SELECT ) || ( event == ( GC1_SELECT | IECODE_UP_PREFIX ) ) )
	{
	    event = GetBoxKey( MasterIB, event );
	}

	if (!SubmitKeys(event)) switch (event)
	{
	    case KEY_UP:
	    case GC0_UP:
	    case GC1_UP:
		DoBoxMove(KEY_UP);
		break;

	    case KEY_DOWN:
	    case GC0_DOWN:
	    case GC1_DOWN:
		DoBoxMove(KEY_DOWN);
		break;

	    case KEY_LEFT:
	    case GC0_LEFT:
	    case GC1_LEFT:
		DoBoxMove(KEY_LEFT);
		break;

	    case KEY_RIGHT:
	    case GC0_RIGHT:
	    case GC1_RIGHT:
		DoBoxMove(KEY_RIGHT);
		break;

	    case KEY_GBUTTON:
		togglegnum();
		break;

	    case KEY_SHUFFLE:
	    case GC0_SHUFFLE:
	    case GC1_SHUFFLE:
		/* We want shuffle to scramble the tracks and
		 * initiate a fresh play.  The ShuffleGrid()
		 * function does call UpdatePlayTime(), which
		 * sends a stop key, so we need not worry here.
		 */
		ShuffleGrid( ShuffleMode );
		ShuffleMode = 1;
		if ( PlayerState.PlayState == PLS_STOPPED )
		{
		    /* PKS_EJECT actually is absolute play,
		     * i.e. never toggle to pause.
		     */
		    PreparePlayList();
		    SubmitKeyStroke(KeyPressed = PKS_EJECT|PKSF_PRESS);
		    SubmitKeyStroke(KeyPressed = PKS_EJECT|PKSF_RELEASE);
		}
		break;

	    /* Change time display mode. */
	    case KEY_TIMEMODE:
		{
		    static const UBYTE NextTime[ 4 ] =
		    {
			1,	/* track elapsed -> track remaining */
			3,	/* track remaining -> disk remaining */
			0,	/* disk elapsed -> track elapsed */
			2,	/* disk remaining -> disk elapsed */
		    };

		    GetOptions(&OptionsSet);
		    OptionsSet.TimeMode = NextTime[ OptionsSet.TimeMode ];
		    OptionsSet.Loop = OptionsSet.Intro = OptionsSet.Subcode = -1;
		    SetOptions(&OptionsSet);
		}
		break;

	    /* Playlist loop */
	    case KEY_REPEAT:
	    case GC0_REPEAT:
	    case GC1_REPEAT:
		GetOptions(&OptionsSet);
		OptionsSet.Loop = !OptionsSet.Loop;
		OptionsSet.TimeMode = OptionsSet.Intro = OptionsSet.Subcode = -1;
		SetOptions(&OptionsSet);
		break;

	    /* Intro mode */
	    case KEY_INTRO:
		GetOptions(&OptionsSet);
		OptionsSet.Intro = !OptionsSet.Intro;
		IntroFlashTicks = ~0;	/* Signifies initial */
		OptionsSet.Loop = OptionsSet.TimeMode = OptionsSet.Subcode = -1;
		SetOptions(&OptionsSet);

		IntroLastTrack  = 0;
		IntroCount = ((UWORD) ~0);

		if (OptionsSet.Intro && PlayerState.PlayState == PLS_STOPPED)
		{
		    /* PKS_EJECT actually is absolute play,
		     * i.e. never toggle to pause
		     */
		    PreparePlayList();
		    SubmitKeyStroke(KeyPressed = PKS_EJECT|PKSF_PRESS);
		    SubmitKeyStroke(KeyPressed = PKS_EJECT|PKSF_RELEASE);
		}

		break;

	    /* Keystroke echoed by player.library */
	    case ECHOKEY_PREVTRAK:
		MasterIB->ib_GState[PLGAD_REV] = 1;
		if ( CDGstate >= CDG_HAVEGRAPHICS )
		{
		    CDGClearScreen();
		}
		break;

	    /* Keystroke echoed by player.library */
	    case ECHOKEY_NEXTTRAK:
		MasterIB->ib_GState[PLGAD_FF] = 1;
		if ( CDGstate >= CDG_HAVEGRAPHICS )
		{
		    CDGClearScreen();
		}
		break;

	    /* Keystroke echoed by player.library */
	    case (ECHOKEY_PREVTRAK | IECODE_UP_PREFIX):
		MasterIB->ib_GState[PLGAD_REV] = 0;
		break;

	    /* Keystroke echoed by player.library */
	    case (ECHOKEY_NEXTTRAK | IECODE_UP_PREFIX):
		MasterIB->ib_GState[PLGAD_FF] = 0;
		break;

	    case KEY_GOCDG:
		if ( CDGstate == CDG_HAVEGRAPHICS )
		{
		    CDGstate = CDG_SHOWGRAPHICS;
		    AbleColorChanger( FALSE );
		    CDGFront();
		    if (PlayerState.PlayState == PLS_PAUSED)
		    {
			CDGPause();
		    }

		    if ( ( PlayerState.PlayMode == PLM_FFWD ) || ( PlayerState.PlayMode == PLM_SKIPFWD ) )
		    {
			CDGFastForward();
		    }
		    else if ( ( PlayerState.PlayMode == PLM_FREV ) || ( PlayerState.PlayMode == PLM_SKIPREV ) )
		    {
			CDGRewind();
		    }
		}
		break;

#if DEBUGGING
	    case RAWKEY_ESC:
		{
		    int i;
		    static char *modes[] =
		    {
			"Normal",
			"FFwd",
			"FRev",
			"SkipFwd",
			"SkipRev",
		    };
		    static char *states[] =
		    {
			"Stopped",
			"Selected",
			"NumEntry",
			"Playing",
			"Paused",
		    };

		    kprintf("Debugging:\n");
		    kprintf("State: %s, Mode: %s\n", states[ PlayerState.PlayState ], modes[ PlayerState.PlayMode ] );
		    kprintf("Disk: %ld, Tracks: %ld, ListIndex: %ld, Track: %ld, Time: %ld:%ld\n",
			PlayerState.AudioDisk, PlayerState.Tracks, PlayerState.ListIndex,
			PlayerState.Track, PlayerState.Minute, PlayerState.Second );
		    kprintf("PlayList EntryCount %ld", PlayList->EntryCount );
		    for ( i = 0; i < PlayList->EntryCount; i++ )
		    {
			if ( ( i % 10 ) == 0 )
			{
			     kprintf("\n    ");
			}
			kprintf("%s%2ld%s ",
			PlayList->Entry[ i ] & PLEF_ENABLE ? " " : "(",
			PlayList->Entry[ i ] & PLEF_TRACK,
			PlayList->Entry[ i ] & PLEF_ENABLE ? " " : ")" );
		    }
		    kprintf("\nShuffleMode: %ld\n\n", ShuffleMode);

		    {
			struct MinNode *node;
			struct PlayerLibrary
			{

			    struct Library          PlayerLib;

			    APTR                    SegList;

			    struct Task            *PlayerTask;
			    struct MsgPort         *TaskMsgPort;
			    struct MsgPort         *TaskReplyPort;

			    struct PlayerOptions    PlayerOptions;
			    struct PlayerState      PlayerState;
			    struct PlayList         PlayList;

			    struct SignalSemaphore  PlayListSemaphore;
			    struct SignalSemaphore  PlayStateSemaphore;
			} *pl = (struct PlayerLibrary *) PlayerBase;
			kprintf("PlayerTask: %lx\n", pl->PlayerTask);
			kprintf("PlayListSem: \"%s\"\n    Owner %lx, NestCount %ld, QueueCount %ld\n",
				pl->PlayListSemaphore.ss_Link.ln_Name,
				pl->PlayListSemaphore.ss_Owner, pl->PlayListSemaphore.ss_NestCount,
				pl->PlayListSemaphore.ss_QueueCount );
			for ( node = pl->PlayListSemaphore.ss_WaitQueue.mlh_Head;
			    node->mln_Succ; node = node->mln_Succ )
			{
			    kprintf("%lx ", ((struct SemaphoreRequest *)node)->sr_Waiter );
			}
			kprintf("PlayStateSem: \"%s\"\n    Owner %lx, NestCount %ld, QueueCount %ld\n",
				pl->PlayStateSemaphore.ss_Link.ln_Name,
				pl->PlayStateSemaphore.ss_Owner, pl->PlayStateSemaphore.ss_NestCount,
				pl->PlayStateSemaphore.ss_QueueCount );
			for ( node = pl->PlayStateSemaphore.ss_WaitQueue.mlh_Head;
			    node->mln_Succ; node = node->mln_Succ )
			{
			    kprintf("%lx ", ((struct SemaphoreRequest *)node)->sr_Waiter );
			}
		    }
		}
		break;
#endif /* DEBUGGING */

	    /* Numeric keypad */
	    case KEY_ADVANCE:
		if ( ( MasterIB->ib_BoxNo >= PLGAD_1 ) &&
		    ( MasterIB->ib_BoxNo <= PLGAD_20 ) )
		{
		    DoBoxMove(KEY_RIGHT);
		}

		break;

	    default:
		break;
	}
    }
    else /* ( CDGstate == CDG_SHOWGRAPHICS ) */
    {
	if (!SubmitKeys(event)) switch (event)
	{
	    /* Playlist loop */
	    case KEY_REPEAT:
	    case GC0_REPEAT:
	    case GC1_REPEAT:
		GetOptions(&OptionsSet);
		OptionsSet.Loop = !OptionsSet.Loop;
		OptionsSet.TimeMode = OptionsSet.Intro = OptionsSet.Subcode = -1;
		SetOptions(&OptionsSet);
		break;

	    /* Intro mode */
	    case KEY_INTRO:
		GetOptions(&OptionsSet);
		OptionsSet.Intro = !OptionsSet.Intro;
		OptionsSet.Loop = OptionsSet.TimeMode = OptionsSet.Subcode = -1;
		SetOptions(&OptionsSet);

		IntroLastTrack  = 0;
		IntroCount = ((UWORD) ~0);
		break;

	    case KEY_SHUFFLE:
	    case GC0_SHUFFLE:
	    case GC1_SHUFFLE:
		/* We want shuffle to scramble the tracks and
		 * initiate a fresh play.  The ShuffleGrid()
		 * function does call UpdatePlayTime(), which
		 * sends a stop key, so we need not worry here.
		 */
		ShuffleGrid( ShuffleMode );
		ShuffleMode = 1;
		if ( PlayerState.PlayState == PLS_STOPPED )
		{
		    /* PKS_EJECT actually is absolute play,
		     * i.e. never toggle to pause.
		     */
		    PreparePlayList();
		    SubmitKeyStroke(KeyPressed = PKS_EJECT|PKSF_PRESS);
		    SubmitKeyStroke(KeyPressed = PKS_EJECT|PKSF_RELEASE);
		}
		break;

	    /* Keystroke echoed by player.library */
	    case ECHOKEY_PREVTRAK:
		CDGRewind();
		break;

	    /* Keystroke echoed by player.library */
	    case ECHOKEY_NEXTTRAK:
		CDGFastForward();
		break;

	    /* Keystroke echoed by player.library */
	    case (ECHOKEY_PREVTRAK | IECODE_UP_PREFIX):
		if (PlayerState.PlayState == PLS_PAUSED)
		{
		    CDGPause();
		}
		else
		{
		    CDGPrevTrack();
		}
		break;

	    /* Keystroke echoed by player.library */
	    case (ECHOKEY_NEXTTRAK | IECODE_UP_PREFIX):
		if (PlayerState.PlayState == PLS_PAUSED)
		{
		    CDGPause();
		}
		else
		{
		    CDGNextTrack();
		}
		break;

	    case KEY_SELECT:
	    case KEY_GOCDG:
	    case GC0_SELECT:
	    case GC1_SELECT:
		CDGstate = CDG_HAVEGRAPHICS;
		MasterIB->ib_BoxNo = PLGAD_GOCDG;
		/* Since IntroFlashTicks doesn't count down when CD+G
		 * graphics are being displayed, we don't want to set
		 * it then either.  If we did, the flash would be "saved up"
		 * until the user exited the CD+G screen.
		 */
		IntroLastTrack = PlayerState.Track;
		IntroFlashTicks = 0;
		CDGBack();
		SetTrackCounter(1);
		playertofront = 1;
		break;

	    case KEY_UP:
	    case GC0_UP:
	    case GC1_UP:
		if ( CDGchannel++ == 15 )
		{
		    CDGchannel = 1;
		}
		CDGChannel( CDGchannel );
		break;

	    case KEY_DOWN:
	    case GC0_DOWN:
	    case GC1_DOWN:
		if ( --CDGchannel == 0 )
		{
		    CDGchannel = 15;
		}
		CDGChannel( CDGchannel );
		break;

	    case ( KEY_UP | IECODE_UP_PREFIX ):
	    case ( GC0_UP | IECODE_UP_PREFIX ):
	    case ( GC1_UP | IECODE_UP_PREFIX ):
	    case ( KEY_DOWN | IECODE_UP_PREFIX ):
	    case ( GC0_DOWN | IECODE_UP_PREFIX ):
	    case ( GC1_DOWN | IECODE_UP_PREFIX ):
		/* For some reason, if the last keystroke sent was a downstroke
		 * we send the corresponding upstroke.  This was here before,
		 * so I'm loath to delete it even though I don't see why
		 * it's here...
		 */
		if ((KeyPressed & PKSF_STROKEDIR) == PKSF_PRESS)
		    SubmitKeyStroke(KeyPressed = ((KeyPressed & PKSF_KEY) | PKSF_RELEASE));
		break;
	}
    }
}



/* Returns non-zero to indicate the event is consumed, zero if the
 * event is not consumed.  Transport control keys are consumed, since
 * player.library will echo them back to us.  We act on the echoes,
 * not the actual keystrokes.
 */
static int
SubmitKeys(UWORD event)
{
    switch(event)
    {
	case KEY_PLAYPAUSE:
	case GC0_PLAYPAUSE:
	case GC1_PLAYPAUSE:
	    PreparePlayList();
	    SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_PRESS);
	    SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_RELEASE);
	    return(1);

	case KEY_STOP:
	case GC0_STOP:
	case GC1_STOP:
	    if ( ShuffleMode )
	    {
		UnShuffleGrid();
		ShuffleMode = 0;
	    }

	    /* If the stop key is pressed while we're well and
	     * truly stopped, then reset the play list, to
	     * dim up any selected tracks.
	     * StopCount hits zero after five consective vblanks
	     * of being stopped.  That should protect us against
	     * brief transitions to stop mode which can occur
	     * when shuffling while playing, for example.
	     * (Ok, so I know it's ugly...)
	     */
	    if ( ( PlayerState.PlayState == PLS_STOPPED ) && ( !StopCount ) )
	    {
		MasterIB->ib_GState[PLGAD_SHUFF] = 0;
		SetPlayList(0);
		UpdateGadgets();
	    }

	    SubmitKeyStroke(KeyPressed = PKS_STOP|PKSF_PRESS);
	    SubmitKeyStroke(KeyPressed = PKS_STOP|PKSF_RELEASE);
	    return(1);

	case KEY_BACK:
	case GC0_BACK:
	case GC1_BACK:
	    /* Since now by default all tracks are off, but that's taken to mean
	     * OK to play all, we must call PreparePlayList() here if stopped.
	     * That function lights all tracks if all tracks are dim.
	     */
	    if ( PlayerState.PlayState == PLS_STOPPED )
	    {
		PreparePlayList();
	    }
	    MasterIB->ib_GState[PLGAD_REV]  = 1;
	    SubmitKeyStroke(KeyPressed = PKS_REVERSE|PKSF_PRESS);
 	    return(1);

	case KEY_FWD:
	case GC0_FWD:
	case GC1_FWD:
	    /* Since now by default all tracks are off, but that's taken to mean
	     * OK to play all, we must call PreparePlayList() here if stopped.
	     * That function lights all tracks if all tracks are dim.
	     */
	    if ( PlayerState.PlayState == PLS_STOPPED )
	    {
		PreparePlayList();
	    }
	    MasterIB->ib_GState[PLGAD_FF]   = 1;
	    SubmitKeyStroke(KeyPressed = PKS_FORWARD|PKSF_PRESS);
	    return(1);

	case (KEY_BACK|IECODE_UP_PREFIX):
	case (GC0_BACK|IECODE_UP_PREFIX):
	case (GC1_BACK|IECODE_UP_PREFIX):
	    MasterIB->ib_GState[PLGAD_REV]  = 0;
	    SubmitKeyStroke(KeyPressed = PKS_REVERSE|PKSF_RELEASE);
	    AbortQCode();
	    return(1);

	case (KEY_FWD|IECODE_UP_PREFIX):
	case (GC0_FWD|IECODE_UP_PREFIX):
	case (GC1_FWD|IECODE_UP_PREFIX):
	    MasterIB->ib_GState[PLGAD_FF]   = 0;
	    SubmitKeyStroke(KeyPressed = PKS_FORWARD|PKSF_RELEASE);
	    AbortQCode();
	    return(1);

	default:
	    return(0);
    }
}


/************** Update Screen Gadgets Based on Current State ***************/

void
UpdateGadgets()
{
    GetPlayerState(&PlayerState);

    if (PlayerState.PlayState >= PLS_PLAYING)
    {
	if (toutstanding)
	{
	    if (CheckIO(TimeReq))
	    {
		if (!qoutstanding)
		{
		    SendIO(cdqcode);
		    qoutstanding = 1;
		}

		if (CheckIO(cdqcode))
		{
		    WaitIO(cdqcode);
		    qoutstanding = 0;

		    if (!cdqcode->io_Error)
		    {
			copyqcode = qcode;
			qvalid = 1;
		    }

		    WaitIO(TimeReq);

#if DEBUGGING
		    if (TimeReq->tr_node.io_Error) kprintf("Error %d\n", TimeReq->tr_node.io_Error);
#endif

		    TimeReq->tr_time.tv_secs    = 1;
		    TimeReq->tr_time.tv_micro   = 0;
		    SendIO(TimeReq);
		}
	    }
	}
    }
    if ( ( CDGstate == CDG_SHOWGRAPHICS ) &&
	( LastPlayMode == PlayerState.PlayMode ) &&
	( LastPlayState == PlayerState.PlayState ) )
    {
	return;
    }

    if ( ( CDGstate ) && ( LastPlayState != PlayerState.PlayState ) )
    {
	switch ( PlayerState.PlayState )
	{
	    case PLS_STOPPED:
		if ( CDGstate == CDG_SHOWGRAPHICS )
		{
		    playertofront = 1;
		}
		CDGStop();
		CDGBack();
		CDGstate = CDG_AVAILABLE;
		MasterIB->ib_GState[PLGAD_REV] = MasterIB->ib_GState[PLGAD_FF]  = 0;
		/* Since IntroFlashTicks doesn't count down when CD+G
		 * graphics are being displayed, we don't want to set
		 * it then either.  If we did, the flash would be "saved up"
		 * until the user exited the CD+G screen.
		 */
		IntroLastTrack = PlayerState.Track;
		IntroFlashTicks = 0;
		break;

	    case PLS_PLAYING:
		/* Show the play glyph if we're unpausing */
		if ( LastPlayState == PLS_PAUSED )
		{
		    CDGPlay( 1 );
		}
		else
		{
		    CDGPlay( 0 );
		    CDGstate = CDG_SUBCODES;
		}
		break;

	    case PLS_PAUSED:
		CDGPause();
		break;
	}
    }

    if ( ( CDGstate == CDG_HAVEGRAPHICS ) && ( PlayerState.PlayState >= PLS_PLAYING ) )
    {
	/* We want the GOCDG gadget enabled, so slide the cover off
	 * until it's fully off
	 */
	if ( MasterIB->ib_GState[PLGAD_GOCDG] < GOCDGSTATES )
	{
	    MasterIB->ib_GState[PLGAD_GOCDG]++;
	}
    }
    else
    {
	/* We want the GOCDG gadget disabled, so slide the cover up
	 * until it's fully up.  If the highlight is over the GOCDG
	 * gadget, kick it off as soon as it's fully covered.
	 */
	if ( MasterIB->ib_GState[PLGAD_GOCDG] > 0 )
	{
	    MasterIB->ib_GState[PLGAD_GOCDG]--;
	    if ( ( MasterIB->ib_GState[PLGAD_GOCDG] == 0 ) &&
		( MasterIB->ib_BoxNo == PLGAD_GOCDG ) )
	    {
		MasterIB->ib_BoxNo = PLGAD_TIME;
	    }
	}
    }

    switch ( PlayerState.PlayState )
    {
	case PLS_STOPPED:

	    AbortQCode();
	    break;

	case PLS_PLAYING:
	case PLS_PAUSED:
	    if (!toutstanding)
	    {
		TimeReq->tr_time.tv_secs    = 1;
		TimeReq->tr_time.tv_micro   = 0;
		SendIO(TimeReq);
		toutstanding = 1;
	    }

	    break;
    }

    if ( PlayerState.PlayState == PLS_STOPPED )
    {
	MasterIB->ib_GState[PLGAD_TTRACK] = 0;
    }
    else
    {
	MasterIB->ib_GState[PLGAD_TTRACK] = PlayerState.Track;

	if (PlayerState.Track != IntroLastTrack)
	{
	    if (PlayerState.PlayMode == PLM_SKIPREV) --IntroCount;
	    else                                     IntroCount++;

	    IntroLastTrack = PlayerState.Track;

	    /* The Intro gadget has two primary states: off and on.
	     * When it's on, the whole thing is yellow.  But whenever
	     * we change tracks, we want to wink one of the arrows
	     * for FLASHLENGTH vblanks.  IntroFlashTicks counts that down.
	     * Note that we get here the first time Intro is
	     * turned on, and we don't want to wink the gadget
	     * in that case.  We handle that by detecting
	     * IntroFlashTicks of ~0.
	     */
	    if ( IntroFlashTicks == ~0 )
	    {
		IntroFlashTicks = 0;
	    }
	    else
	    {
		IntroFlashTicks = FLASHLENGTH;
	    }
	}
    }

    if ( PlayerState.AudioDisk == 1 )
    {
	MasterIB->ib_GState[PLGAD_MIN] = PlayerState.Minute;
	MasterIB->ib_GState[PLGAD_SEC] = PlayerState.Second;
	MasterIB->ib_GState[PLGAD_NEG] = PlayerState.Minus;

	if ( ( NumSelectedTracks == 0 ) && ( PlayerState.PlayState < PLS_PLAYING ) )
	{
	    MasterIB->ib_GState[PLGAD_MIN] = TotalMinutes;
	    MasterIB->ib_GState[PLGAD_SEC] = TotalSeconds;
	    MasterIB->ib_GState[PLGAD_NEG] = 0;
	}
	MasterIB->ib_GState[PLGAD_COLON] = 1;
    }
    else
    {
	MasterIB->ib_GState[PLGAD_TTRACK] = 0;
    }

    /* Never set PLGAD_TTRACK if the head gadget is moving */
    if ( MasterIB->ib_GState[PLGAD_COUNTER] & COUNTER_FLYING )
    {
	MasterIB->ib_GState[PLGAD_TTRACK] = 0;
    }

    if ( PlayerState.PlayMode == PLM_NORMAL )
    {
	MasterIB->ib_GState[PLGAD_STOP]  =  (PlayerState.PlayState == PLS_STOPPED)
				    || (PlayerState.PlayState == PLS_SELECTED)
				    || (PlayerState.PlayState == PLS_NUMENTRY);

	if ( PlayerState.PlayState == PLS_PAUSED )
	{
	    MasterIB->ib_GState[PLGAD_PLAY] = 1;
	}
	else if ( PlayerState.PlayState == PLS_PLAYING )
	{
	    MasterIB->ib_GState[PLGAD_PLAY] = 2;
	}
	else
	{
	    MasterIB->ib_GState[PLGAD_PLAY] = 0;
	}
    }

    GetOptions(&PlayerOptions);

    MasterIB->ib_GState[PLGAD_TIME]   = PlayerOptions.TimeMode;

    MasterIB->ib_GState[PLGAD_REPEAT] = PlayerOptions.Loop;
    if ( PlayerOptions.Intro )
    {
	if ( IntroFlashTicks )
	{
	    MasterIB->ib_GState[PLGAD_INTRO] = ( 0x03 & IntroCount ) + 1;
	    IntroFlashTicks--;
	}
	else
	{
	    MasterIB->ib_GState[PLGAD_INTRO] = 5;
	}
    }
    else
    {
	MasterIB->ib_GState[PLGAD_INTRO] = 0;
    }

    if (PlayerState.LastModify) MasterIB->ib_GState[PLGAD_SHUFF] = 0;

    SetTrackCounter(0);

    if (PlayerState.AudioDisk == 1) DisplayGrid();

    LastPlayMode  = PlayerState.PlayMode;
    LastPlayState = PlayerState.PlayState;
}


/**************** Initialize Structures/Variables/Gadgets ******************/

static UWORD *
SetupPlayer(void)
{
extern UWORD     IntroData[];

    static int firstinit = 1;

    OptionsSet.Loop     = -1;
    OptionsSet.Intro    = -1;
    OptionsSet.TimeMode = -1;
    OptionsSet.Subcode  = 1;
    SetOptions(&OptionsSet);

    MasterIB->ib_GState[PLGAD_STOP]   = 1;
    MasterIB->ib_GState[PLGAD_TIME]   = 0;
    MasterIB->ib_GState[PLGAD_REPEAT] = 0;
    MasterIB->ib_GState[PLGAD_SHUFF]  = 0;
    MasterIB->ib_GState[PLGAD_CDG] = 0;
    MasterIB->ib_GState[PLGAD_GOCDG] = 0;

    /* The disk head needs to be flying initially, because we key off
     * that to suppress changing PLGAD_TTRACK to anything other
     * than blank.
     * PLGAD_MIN, PLGAD_SEC, and PLGAD_NEG all set to blank.
     */
    MasterIB->ib_GState[PLGAD_COUNTER] = COUNTER_FLYING + 0;
    MasterIB->ib_GState[PLGAD_MIN] = 100;
    MasterIB->ib_GState[PLGAD_SEC] = 100;
    MasterIB->ib_GState[PLGAD_NEG] = 0;
    MasterIB->ib_GState[PLGAD_COLON] = 0;

    ShuffleMode = 0;
    StopCount = 0;

    /* Turn on the speakers; full volume, right now(sorta). */
    cdio->io_Command = CD_ATTENUATE;
    cdio->io_Offset  = 0x7FFF;
    cdio->io_Length  = 0;
    DoIO(cdio);

    /* Initialize the qcode packet. */
    cdqcode->io_Command  = CD_QCODELSN;
    cdqcode->io_Data     = (APTR)&qcode;

    /* Create timer request */
    TimeReq->tr_node.io_Command = TR_ADDREQUEST;
    TimeReq->tr_time.tv_secs    = 1;
    TimeReq->tr_time.tv_micro   = 0;

    GetPlayerState(&PlayerState);

    if (PlayerState.PlayMode == PLM_NORMAL)
    {
	MasterIB->ib_GState[PLGAD_STOP]  =  (PlayerState.PlayState == PLS_STOPPED)
				    || (PlayerState.PlayState == PLS_SELECTED);

	if ( PlayerState.PlayState == PLS_PAUSED )
	{
	    MasterIB->ib_GState[PLGAD_PLAY] = 1;
	}
	else if ( PlayerState.PlayState == PLS_PLAYING )
	{
	    MasterIB->ib_GState[PLGAD_PLAY] = 2;
	}
	else
	{
	    MasterIB->ib_GState[PLGAD_PLAY] = 0;
	}
    }

    GetOptions(&PlayerOptions);

    MasterIB->ib_GState[PLGAD_TIME]   = PlayerOptions.TimeMode;
    MasterIB->ib_GState[PLGAD_REPEAT] = PlayerOptions.Loop;
    MasterIB->ib_GState[PLGAD_INTRO]  = PlayerOptions.Intro * ((0x03 & IntroCount) + 1);

    LastPlayMode  = PlayerState.PlayMode;
    LastPlayState = PlayerState.PlayState;

    UpdateDisplay();

    if ( firstinit )
    {
	FadeIn();
    }

    haveCD = 1;
    AbleColorChanger( TRUE );
    MasterIB->ib_BoxNo = PLGAD_PLAY;

    GetOptions(&PlayerOptions);

    /* Gimme summary. */
    cdio->io_Command  = CD_TOCLSN;
    cdio->io_Offset   = 0;
    cdio->io_Length   = 100;
    cdio->io_Data     = (APTR)TOC;
    DoIO(cdio);

    if (!cdio->io_Error)
    {
	InitTrackCounter();
	PlayList = ObtainPlayList();
	SetPlayList(1);
	GetPlayerState(&PlayerState);
	TotalMinutes = PlayerState.Minute;
	TotalSeconds = PlayerState.Second;
	SetPlayList(0);
    }
    else
    {
	DoReset();
    }

    currsec = TOC[PlayerState.Track].Entry.Position.LSN;
    firstinit = 0;

    return( IntroData );
}


/***************************** Shutdown Routine ****************************/

static void
ShutDown()
{
UWORD *anim;

    TotalMinutes = 100;
    TotalSeconds = 100;
    SetTrackCounter( 0 );
    AbleColorChanger( FALSE );
    haveCD = 0;
    if ( CDGstate )
    {
	CDGchannel = 1;
	CDGChannel( CDGchannel );
	CDGDiskRemoved();
	CDGstate = CDG_AVAILABLE;
    }
    anim = ShutdownAnim;
    MasterIB->ib_BoxNo = -1;

    /* Shutdown anim turns all gadgets to off.  Do that simultaneously
     * to bringing the disk-head back to the outside.
     */
    while ( ( MasterIB->ib_GState[PLGAD_COUNTER] ) ||
	( MasterIB->ib_GState[PLGAD_GOCDG] ) || ( anim ) )
    {
	if ( MasterIB->ib_GState[PLGAD_COUNTER] )
	{
	    MasterIB->ib_GState[PLGAD_COUNTER]--;
	}

	if ( MasterIB->ib_GState[PLGAD_GOCDG] )
	{
	    MasterIB->ib_GState[PLGAD_GOCDG]--;
	}

	if (anim)
	{
	    anim = DoAnimation( anim, 1 );
	}
	else
	{
	    UpdateDisplay();
	}
    }

    /* The DiskOutAnim makes the disk head fly up and the disk itself
     * fly left
     */
    anim = DiskOutAnim;
    while(anim = DoAnimation(anim,1));
}



/****************************** Fade and Reset *****************************/

static void
DoReset()
{
    FadeOut();
    ColdReboot();
}



/*********************** Abort Q-Code related requests *********************/

static void
AbortQCode(void)
{
    if (qoutstanding)
    {
	AbortIO(cdqcode);
	WaitIO(cdqcode);
	qoutstanding = 0;
    }

    if (toutstanding)
    {
	AbortIO(TimeReq);
	WaitIO(TimeReq);
	toutstanding = 0;
    }

    qvalid = 0;
}

/********************** Reset Default PlayList ***********************/

/* Create a default play-list, all enabled or all disabled */
static void
SetPlayList( ULONG enable )
{
WORD           i;

    /* Set playlist back to zero */
    UpdatePlayTime(); while (!ModifyPlayList(1));

    NumSelectedTracks = 0;
    PlayList->EntryCount = 0;

    for ( i = 0; i < TOC[0].Summary.LastTrack; i++ )
    {
	PlayList->Entry[i] = (UBYTE)(i+1);
	if ( enable )
	{
	    PlayList->Entry[i] |= PLEF_ENABLE;
	}
    }
    PlayList->EntryCount = TOC[0].Summary.LastTrack;
    if ( enable )
    {
	NumSelectedTracks = PlayList->EntryCount;
    }


    ModifyPlayList(0);
}

/* Enable all tracks in the PlayList if none of them are lit */
static void
PreparePlayList( void )
{
    WORD i;
    if ( NumSelectedTracks == 0 )
    {
	for ( i = 0; i < PlayList->EntryCount; i++ )
	{
	    PlayList->Entry[i] |= PLEF_ENABLE;
	}
	NumSelectedTracks = PlayList->EntryCount;
    }
}

/* Disable all tracks in the PlayList if all of them are lit */
static void
UnpreparePlayList( void )
{
    WORD i;
    if ( NumSelectedTracks == PlayList->EntryCount )
    {
	for ( i = 0; i < PlayList->EntryCount; i++ )
	{
	    PlayList->Entry[i] &= ~PLEF_ENABLE;
	}
	NumSelectedTracks = 0;
    }
}
@


1.27
log
@If no tracks are selected, we show the total play time in the disk.
Also, playing with no selected tracks plays them all.  Now blank
the track counter when stopped (instead of showing the total number
of tracks).
@
text
@d1 1
a1 1
/* $Id: player.c,v 1.26 93/04/06 15:22:19 peter Exp Locker: peter $ */
d1091 8
d1106 8
d1317 2
d1323 1
a1360 5
    /* We post a negative sign in the time-display if the time mode
     * set to "remaining", not "elapsed".
     */
    MasterIB->ib_GState[PLGAD_NEG] = ( ( PlayerOptions.TimeMode & 1 ) &&
	( PlayerState.PlayState != PLS_STOPPED ) );
@


1.26
log
@Now handle the new colon gadget which controls whether the colon in
the track time display is on or off.  Returning to CD+G screen now
correctly shows the FF/RW sprite-glyph.  Time Mode gadget order improved.
@
text
@d1 1
a1 1
/* $Id: player.c,v 1.25 93/03/31 18:01:29 peter Exp Locker: peter $ */
d94 3
d121 3
d548 1
d698 1
d748 1
d943 1
d1054 1
d1070 2
a1071 2
	     * brighten up any dimmed tracks.
	     * StopCount hits zero after ten consective vblanks
d1079 3
a1081 1
		ResetPlayList();
d1264 1
a1264 1
	MasterIB->ib_GState[PLGAD_TTRACK] = PlayerState.Tracks;
d1299 8
a1306 3
	MasterIB->ib_GState[PLGAD_MIN]    = PlayerState.Minute;
	MasterIB->ib_GState[PLGAD_SEC]    = PlayerState.Second;
	MasterIB->ib_GState[PLGAD_COLON]  = 1;
a1385 2
    PlayList = ObtainPlayList();

a1468 1
    GetPlayerState(&PlayerState);
d1481 6
d1507 2
d1588 62
@


1.25
log
@Now references /screencoords.h.
@
text
@d1 1
a1 1
/* $Id: player.c,v 1.24 93/03/31 15:16:44 peter Exp Locker: peter $ */
d200 1
a200 1
    PLGAD_SHUFF,0,PLGAD_CDG,0, PLGAD_MIN, 100, PLGAD_SEC, 100, PLGAD_NEG, 0, 0xffff,
d565 1
a565 1
		    if ( MasterIB->ib_GState[PLGAD_FF] )
d569 1
a569 1
		    else if ( MasterIB->ib_GState[PLGAD_REV] )
d698 14
a711 4
		GetOptions(&OptionsSet);
		OptionsSet.TimeMode = (OptionsSet.TimeMode + 1) & 0x03;
		OptionsSet.Loop = OptionsSet.Intro = OptionsSet.Subcode = -1;
		SetOptions(&OptionsSet);
d785 1
a785 1
		    if (MasterIB->ib_GState[PLGAD_FF])
d789 1
a789 1
		    else if (MasterIB->ib_GState[PLGAD_REV])
a987 1
		MasterIB->ib_GState[PLGAD_REV] = MasterIB->ib_GState[PLGAD_FF]  = 0;
d1288 1
d1392 1
@


1.24
log
@Now support the new GOCDG gadget, and making it come and go.  Now
support hitting shuffle when in CD+G mode.
@
text
@d1 1
a1 1
/* $Id: player.c,v 1.23 93/03/25 23:02:02 peter Exp Locker: peter $ */
d19 1
a19 1
#include "gadgets.h"
@


1.23
log
@Now clear noscrollticks when not playing/paused.
@
text
@d1 1
a1 1
/* $Id: player.c,v 1.22 93/03/25 19:36:45 peter Exp Locker: peter $ */
d19 1
d117 1
a117 1
ULONG RangeSeed;
d149 1
a149 1
 *	have the CD+G screen frontmoste.
d200 1
a200 1
    PLGAD_SHUFF,0,PLGAD_CDG,0,PLGAD_MIN, 100, PLGAD_SEC, 100, PLGAD_NEG, 0, 0xffff,
d329 1
a329 1
    RangeSeed = (-vhposr & 0x7fff) ^ 0x1D6539A3;
d333 1
a333 1
	for ( i=PLGAD_STOP; i<=PLGAD_20; i++ )
d684 2
a685 1
		ShuffleGrid();
d689 1
a689 1
		     * i.e. never toggle to pause
a693 3
		/* See ShuffleGrid() for info as to why this needs to
		 * be set after sending the play command.
		 */
d736 1
d745 1
d754 1
d759 1
d764 1
a764 1
	    case KEY_CDG:
d909 21
d934 1
d939 1
d951 1
d964 1
d968 1
a968 1
		MasterIB->ib_BoxNo = PLGAD_CDG;
a1144 1

d1193 27
d1371 1
d1491 2
a1492 1
    while ((MasterIB->ib_GState[PLGAD_COUNTER] != 0) || anim)
d1494 1
a1494 1
	if (MasterIB->ib_GState[PLGAD_COUNTER] != 0)
d1497 5
@


1.22
log
@LowLevelBase comes from our libbase now.  Now lets user scroll around
track table even while playing.  Fixed extraneous call to ShutDown()
if no audio disk is found upon init.
@
text
@d1 1
a1 1
/* $Id: player.c,v 1.21 93/03/23 10:35:13 peter Exp Locker: peter $ */
d512 1
d517 4
@


1.21
log
@Repeat and Intro keys supported even when CD+G is playing.  Now calls
new StripIDCMPEvents() routine while waiting for an audio disk to
be inserted.
@
text
@d1 1
a1 1
/* $Id: player.c,v 1.20 93/03/19 19:18:31 peter Exp Locker: peter $ */
d72 1
d110 1
a131 1
struct LowLevelBase  *LowLevelBase;
d368 1
a368 1
						    if (LowLevelBase = (struct LowLevelBase *)OpenLibrary("lowlevel.library", 0L))
d370 7
a376 6
							struct TagItem add_createkeys[] =
							{
							    SCON_AddCreateKeys, 0,
							    SCON_AddCreateKeys, 1,
							    TAG_DONE,
							};
d378 1
a378 1
							if ( !SystemControlA( add_createkeys ) )
d380 1
a380 2

							    if (CDG_Open(&cdp))
d382 1
a382 3
								if (UnpackSprites(&cdp))
								{
								    PlayerLoop(&cdp);
d392 1
a392 2
								    CLEAN( CDG_Close() );
								}
d394 1
d396 2
d399 4
a402 6
								struct TagItem rem_createkeys[] =
								{
								    SCON_RemCreateKeys, 0,
								    SCON_RemCreateKeys, 1,
								    TAG_DONE,
								};
d404 2
a405 2
								SystemControlA( remove_createkeys );
							    }
a406 3
							}

							CLEAN( CloseLibrary(LowLevelBase) );
d504 14
a1397 1
	ShutDown();
@


1.20
log
@Added a comment 
@
text
@d1 1
a1 1
/* $Id: player.c,v 1.19 93/03/19 18:57:39 peter Exp Locker: peter $ */
d106 1
a106 1
UBYTE  LastTrack = 0;
d571 1
a571 1
	else
d573 12
d658 1
a658 1
		return;
d680 1
a680 1
		return;
d708 1
a708 1
		LastTrack  = 0;
d728 1
a728 1
		return;
d736 1
a736 1
		return;
d863 1
a863 1
		return;
d870 21
d926 7
d1123 7
d1179 1
a1179 1
	if (PlayerState.Track != LastTrack)
d1184 1
a1184 1
	    LastTrack = PlayerState.Track;
@


1.19
log
@Now keep seed variable for random number generator myself, so we are
ROMable.  Ensure that minutes and seconds gadgets are initialized to
blank.  Now use lowlevel.library AddCreateKeys instead of calling
ReadJoyPort() myself.  Let Intro animation run out before shutting
down.  Now use new absolute play command to invoke play.
@
text
@d1 1
a1 1
/* $Id: player.c,v 1.18 93/03/17 16:55:18 peter Exp Locker: peter $ */
d493 3
@


1.18
log
@Added static when possible.  Removed dead code.  No longer reference
playerstrip.  Removed invalid PLGAD_COUNTER steps in animations.  Now
the intro anim is played in the event loop so we're responsive while
that's going on.  Other changes to support anim in the event loop.
Removed ESC key handling.
@
text
@d1 1
a1 1
/* $Id: player.c,v 1.17 93/03/11 18:44:47 peter Exp Locker: peter $ */
a90 1
static UWORD GetControllerEvent(void);
d114 1
a164 1
#if 000
d168 22
a189 66
    PLGAD_DISK,23, PLGAD_COUNTER, HEAD_FLYING + 0, 0xffff,
    PLGAD_DISK,23, PLGAD_COUNTER, HEAD_FLYING + 0, 0xffff,
    PLGAD_DISK,23, PLGAD_COUNTER, HEAD_FLYING + 0, 0xffff,
    PLGAD_DISK,22, PLGAD_COUNTER, HEAD_FLYING + 1, 0xffff,
    PLGAD_DISK,22, PLGAD_COUNTER, HEAD_FLYING + 1, 0xffff,
    PLGAD_DISK,22, PLGAD_COUNTER, HEAD_FLYING + 1, 0xffff,
    PLGAD_DISK,21, PLGAD_COUNTER, HEAD_FLYING + 2, 0xffff,
    PLGAD_DISK,21, PLGAD_COUNTER, HEAD_FLYING + 2, 0xffff,
    PLGAD_DISK,21, PLGAD_COUNTER, HEAD_FLYING + 2, 0xffff,
    PLGAD_DISK,20, PLGAD_COUNTER, HEAD_FLYING + 3, 0xffff,
    PLGAD_DISK,20, PLGAD_COUNTER, HEAD_FLYING + 3, 0xffff,
    PLGAD_DISK,20, PLGAD_COUNTER, HEAD_FLYING + 3, 0xffff,
    PLGAD_DISK,19, PLGAD_COUNTER, HEAD_FLYING + 4, 0xffff,
    PLGAD_DISK,19, PLGAD_COUNTER, HEAD_FLYING + 4, 0xffff,
    PLGAD_DISK,19, PLGAD_COUNTER, HEAD_FLYING + 4, 0xffff,
    PLGAD_DISK,18, PLGAD_COUNTER, HEAD_FLYING + 5, 0xffff,
    PLGAD_DISK,18, PLGAD_COUNTER, HEAD_FLYING + 5, 0xffff,
    PLGAD_DISK,18, PLGAD_COUNTER, HEAD_FLYING + 5, 0xffff,
    PLGAD_DISK,17, PLGAD_COUNTER, HEAD_FLYING + 6, 0xffff,
    PLGAD_DISK,17, PLGAD_COUNTER, HEAD_FLYING + 6, 0xffff,
    PLGAD_DISK,17, PLGAD_COUNTER, HEAD_FLYING + 6, 0xffff,
    PLGAD_DISK,16, PLGAD_COUNTER, HEAD_FLYING + 7, 0xffff,
    PLGAD_DISK,16, PLGAD_COUNTER, HEAD_FLYING + 7, 0xffff,
    PLGAD_DISK,16, PLGAD_COUNTER, HEAD_FLYING + 7, 0xffff,
    PLGAD_DISK,15, PLGAD_COUNTER, HEAD_FLYING + 8, 0xffff,
    PLGAD_DISK,15, PLGAD_COUNTER, HEAD_FLYING + 8, 0xffff,
    PLGAD_DISK,15, PLGAD_COUNTER, HEAD_FLYING + 8, 0xffff,
    PLGAD_DISK,14, PLGAD_COUNTER, HEAD_FLYING + 9, 0xffff,
    PLGAD_DISK,14, PLGAD_COUNTER, HEAD_FLYING + 9, 0xffff,
    PLGAD_DISK,14, PLGAD_COUNTER, HEAD_FLYING + 9, 0xffff,
    PLGAD_DISK,13, PLGAD_COUNTER, HEAD_FLYING +10, 0xffff,
    PLGAD_DISK,13, PLGAD_COUNTER, HEAD_FLYING +10, 0xffff,
    PLGAD_DISK,13, PLGAD_COUNTER, HEAD_FLYING +10, 0xffff,
    PLGAD_DISK,12, PLGAD_COUNTER, HEAD_FLYING +11, 0xffff,
    PLGAD_DISK,12, PLGAD_COUNTER, HEAD_FLYING +11, 0xffff,
    PLGAD_DISK,12, PLGAD_COUNTER, HEAD_FLYING +11, 0xffff,
    PLGAD_DISK,11, PLGAD_COUNTER, HEAD_FLYING +12, 0xffff,
    PLGAD_DISK,11, PLGAD_COUNTER, HEAD_FLYING +12, 0xffff,
    PLGAD_DISK,11, PLGAD_COUNTER, HEAD_FLYING +12, 0xffff,
    PLGAD_DISK,10, PLGAD_COUNTER, HEAD_FLYING +13, 0xffff,
    PLGAD_DISK,10, PLGAD_COUNTER, HEAD_FLYING +13, 0xffff,
    PLGAD_DISK,10, PLGAD_COUNTER, HEAD_FLYING +13, 0xffff,
    PLGAD_DISK, 9, PLGAD_COUNTER, HEAD_FLYING +14, 0xffff,
    PLGAD_DISK, 9, PLGAD_COUNTER, HEAD_FLYING +14, 0xffff,
    PLGAD_DISK, 9, PLGAD_COUNTER, HEAD_FLYING +14, 0xffff,
    PLGAD_DISK, 8, PLGAD_COUNTER, HEAD_FLYING +15, 0xffff,
    PLGAD_DISK, 8, PLGAD_COUNTER, HEAD_FLYING +15, 0xffff,
    PLGAD_DISK, 8, PLGAD_COUNTER, HEAD_FLYING +15, 0xffff,
    PLGAD_DISK, 7, PLGAD_COUNTER, HEAD_FLYING +16, 0xffff,
    PLGAD_DISK, 7, PLGAD_COUNTER, HEAD_FLYING +16, 0xffff,
    PLGAD_DISK, 7, PLGAD_COUNTER, HEAD_FLYING +16, 0xffff,
    PLGAD_DISK, 6, PLGAD_COUNTER, HEAD_FLYING +17, 0xffff,
    PLGAD_DISK, 6, PLGAD_COUNTER, HEAD_FLYING +17, 0xffff,
    PLGAD_DISK, 6, PLGAD_COUNTER, HEAD_FLYING +17, 0xffff,
    PLGAD_DISK, 5, PLGAD_COUNTER, HEAD_FLYING +18, 0xffff,
    PLGAD_DISK, 5, PLGAD_COUNTER, HEAD_FLYING +18, 0xffff,
    PLGAD_DISK, 5, PLGAD_COUNTER, HEAD_FLYING +18, 0xffff,
    PLGAD_DISK, 4, PLGAD_COUNTER, HEAD_FLYING +19, 0xffff,
    PLGAD_DISK, 4, PLGAD_COUNTER, HEAD_FLYING +19, 0xffff,
    PLGAD_DISK, 4, PLGAD_COUNTER, HEAD_FLYING +19, 0xffff,
    PLGAD_DISK, 3, PLGAD_COUNTER, HEAD_FLYING +20, 0xffff,
    PLGAD_DISK, 3, PLGAD_COUNTER, HEAD_FLYING +20, 0xffff,
    PLGAD_DISK, 3, PLGAD_COUNTER, HEAD_FLYING +20, 0xffff,
    PLGAD_DISK, 2, PLGAD_COUNTER, HEAD_FLYING +21, 0xffff,
    PLGAD_DISK, 2, PLGAD_COUNTER, HEAD_FLYING +21, 0xffff,
    PLGAD_DISK, 2, PLGAD_COUNTER, HEAD_FLYING +21, 0xffff,
a190 31
    PLGAD_DISK, 1, PLGAD_COUNTER, 0,         0xffff,
    PLGAD_DISK, 1, PLGAD_COUNTER, 0,         0xffff,
    0xffff
};
#else
UWORD IntroData[] =
{
    PLGAD_DISK,24, 0xffff,
    PLGAD_DISK,23, PLGAD_COUNTER, HEAD_FLYING + 0, 0xffff,
    PLGAD_DISK,22, PLGAD_COUNTER, HEAD_FLYING + 1, 0xffff,
    PLGAD_DISK,21, PLGAD_COUNTER, HEAD_FLYING + 2, 0xffff,
    PLGAD_DISK,20, PLGAD_COUNTER, HEAD_FLYING + 3, 0xffff,
    PLGAD_DISK,19, PLGAD_COUNTER, HEAD_FLYING + 4, 0xffff,
    PLGAD_DISK,18, PLGAD_COUNTER, HEAD_FLYING + 5, 0xffff,
    PLGAD_DISK,17, PLGAD_COUNTER, HEAD_FLYING + 6, 0xffff,
    PLGAD_DISK,16, PLGAD_COUNTER, HEAD_FLYING + 7, 0xffff,
    PLGAD_DISK,15, PLGAD_COUNTER, HEAD_FLYING + 8, 0xffff,
    PLGAD_DISK,14, PLGAD_COUNTER, HEAD_FLYING + 9, 0xffff,
    PLGAD_DISK,13, PLGAD_COUNTER, HEAD_FLYING +10, 0xffff,
    PLGAD_DISK,12, PLGAD_COUNTER, HEAD_FLYING +11, 0xffff,
    PLGAD_DISK,11, PLGAD_COUNTER, HEAD_FLYING +12, 0xffff,
    PLGAD_DISK,10, PLGAD_COUNTER, HEAD_FLYING +13, 0xffff,
    PLGAD_DISK, 9, PLGAD_COUNTER, HEAD_FLYING +14, 0xffff,
    PLGAD_DISK, 8, PLGAD_COUNTER, HEAD_FLYING +15, 0xffff,
    PLGAD_DISK, 7, PLGAD_COUNTER, HEAD_FLYING +16, 0xffff,
    PLGAD_DISK, 6, PLGAD_COUNTER, HEAD_FLYING +17, 0xffff,
    PLGAD_DISK, 5, PLGAD_COUNTER, HEAD_FLYING +18, 0xffff,
    PLGAD_DISK, 4, PLGAD_COUNTER, HEAD_FLYING +19, 0xffff,
    PLGAD_DISK, 3, PLGAD_COUNTER, HEAD_FLYING +20, 0xffff,
    PLGAD_DISK, 2, PLGAD_COUNTER, HEAD_FLYING +21, 0xffff,
    PLGAD_DISK, 1, PLGAD_COUNTER, 0,         0xffff,
a192 1
#endif
d240 22
a261 22
    PLGAD_DISK,16, PLGAD_COUNTER,HEAD_FLYING +21, 0xffff,
    PLGAD_DISK,17, PLGAD_COUNTER,HEAD_FLYING +20, 0xffff,
    PLGAD_DISK,18, PLGAD_COUNTER,HEAD_FLYING +19, 0xffff,
    PLGAD_DISK,19, PLGAD_COUNTER,HEAD_FLYING +18, 0xffff,
    PLGAD_DISK,20, PLGAD_COUNTER,HEAD_FLYING +17, 0xffff,
    PLGAD_DISK,21, PLGAD_COUNTER,HEAD_FLYING +16, 0xffff,
    PLGAD_DISK,22, PLGAD_COUNTER,HEAD_FLYING +15, 0xffff,
    PLGAD_DISK,23, PLGAD_COUNTER,HEAD_FLYING +14, 0xffff,
    PLGAD_DISK,24, PLGAD_COUNTER,HEAD_FLYING +13, 0xffff,
    PLGAD_COUNTER,HEAD_FLYING +12, 0xffff,
    PLGAD_COUNTER,HEAD_FLYING +11, 0xffff,
    PLGAD_COUNTER,HEAD_FLYING +10, 0xffff,
    PLGAD_COUNTER,HEAD_FLYING + 9, 0xffff,
    PLGAD_COUNTER,HEAD_FLYING + 8, 0xffff,
    PLGAD_COUNTER,HEAD_FLYING + 7, 0xffff,
    PLGAD_COUNTER,HEAD_FLYING + 6, 0xffff,
    PLGAD_COUNTER,HEAD_FLYING + 5, 0xffff,
    PLGAD_COUNTER,HEAD_FLYING + 4, 0xffff,
    PLGAD_COUNTER,HEAD_FLYING + 3, 0xffff,
    PLGAD_COUNTER,HEAD_FLYING + 2, 0xffff,
    PLGAD_COUNTER,HEAD_FLYING + 1, 0xffff,
    PLGAD_COUNTER,HEAD_FLYING + 0, 0xffff,
a308 1
extern ULONG __far RangeSeed;
d335 2
d369 1
a369 1
							if (CDG_Open(&cdp))
d371 9
a379 1
							    if (UnpackSprites(&cdp))
d381 7
a387 2
								PlayerLoop(&cdp);
/* Don't bother cleaning up since we exit via reboot */
d389 6
a394 1
								CDG_Close();
d396 8
d405 3
d410 1
a410 1
							CloseLibrary(LowLevelBase);
d413 1
a413 1
						    CloseLibrary(PlayerBase);
d416 1
a416 1
						CloseDevice(TimeReq);
d419 1
a419 1
					    DeleteExtIO(TimeReq);
d422 1
a422 1
					DeleteMsgPort(TimeReplyPort);
d424 1
a424 1
				    FreeMem(UndoPlayList, sizeof(struct PlayList));
d427 1
a427 1
				FreeMem(TOC, sizeof(union CDTOC) * NENTRIES);
d430 1
a430 1
			    AbortQCode();
d432 1
a432 1
			    CloseDevice(cdio);
d435 1
a435 1
			DeleteStdIO(cdqcode);
d438 1
a438 1
		    DeleteStdIO(cdio);
d441 1
a441 1
		DeleteMsgPort(qcodereply);
d444 1
a444 1
	    DeleteMsgPort(cdreply);
d447 1
a447 1
	EndPPScreen();
d450 2
a453 15
							    }
							}
						    }
						}
					    }
					}
				    }
				}
			    }
			}
		    }
		}
	    }
	}
    }
d456 1
a456 1
#endif /* INCLUDE_CLEANUP */
a486 4
	    while ( event = GetControllerEvent() )
	    {
		DoKeyStroke(event);
	    }
d493 4
d581 1
a601 2
UWORD  dir;

d604 7
a610 1
	if (event & BOXMOVE)
d612 1
a612 2
		DoBoxMove(event);
		return;
a614 4
	if ((event == IECODE_LBUTTON) || (event == (IECODE_LBUTTON+IECODE_UP_PREFIX))
	    || (event == RAWKEY_RETURN) || (event == (RAWKEY_RETURN | IECODE_UP_PREFIX)))
	    event = GetBoxKey( MasterIB, event );

d617 4
a620 3
	    case RAWKEY_ARROWUP:
		dir = DIR_UP;
		DoBoxMove(dir);
d622 17
a638 14

	    case RAWKEY_ARROWDN:
		dir = DIR_DOWN;
		DoBoxMove(dir);
		break;

	    case RAWKEY_ARROWLT:
		dir = DIR_LEFT;
		DoBoxMove(dir);
		break;

	    case RAWKEY_ARROWRT:
		dir = DIR_RIGHT;
		DoBoxMove(dir);
a641 1

d646 2
a647 1

d656 5
a660 2
		    SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_PRESS);
		    SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_RELEASE);
a668 1

d675 1
a675 1
	    /* A/B loop */
d677 2
a678 1

d698 5
a702 2
		    SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_PRESS);
		    SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_RELEASE);
d707 1
a707 5
	    case RAWKEY_STOP:
		break;

	    case RAWKEY_PREVTRAK:

d715 1
a715 2
	    case RAWKEY_NEXTTRAK:

d723 1
a723 2
	    case (RAWKEY_PREVTRAK | IECODE_UP_PREFIX):

d727 1
a727 2
	    case (RAWKEY_NEXTTRAK | IECODE_UP_PREFIX):

d838 1
a838 2
	    case RAWKEY_ENTER:

d842 1
a842 1
		    DoBoxMove(DIR_RIGHT);
d855 1
a855 1
	    case RAWKEY_PREVTRAK:
d859 1
a859 1
	    case RAWKEY_NEXTTRAK:
d863 1
a863 1
	    case (RAWKEY_PREVTRAK | IECODE_UP_PREFIX):
d874 1
a874 1
	    case (RAWKEY_NEXTTRAK | IECODE_UP_PREFIX):
d885 3
a887 2
	    case IECODE_LBUTTON:
	    case RAWKEY_RETURN:
d896 3
a898 2
	    case DIR_UP:
	    case RAWKEY_ARROWUP:
d906 3
a908 2
	    case DIR_DOWN:
	    case RAWKEY_ARROWDN:
d916 11
a926 2
	    case (DIR_UP | IECODE_UP_PREFIX):
	    case (DIR_DOWN | IECODE_UP_PREFIX):
d946 3
a948 2
	case KEY_PLAY:

d954 2
a955 1

d981 2
a982 1

d985 1
a985 1
	    return(1);
d988 2
a989 1

d995 2
a996 1

d1003 2
a1004 1

d1010 2
a1011 1
	default: return(0);
d1167 1
a1167 1
    if ( MasterIB->ib_GState[PLGAD_COUNTER] & HEAD_FLYING )
d1258 1
a1258 1
    MasterIB->ib_GState[PLGAD_COUNTER] = HEAD_FLYING + 0;
d1344 1
a1428 270
}



/************* Simulate a keypress when using Game Controller **************/

#define NO_JOYEVENT	((UWORD)~0)


/* We usually get called here once every VBlank.
 *
 * REPEAT_INITIAL is the number of VBlanks to skip before repeating
 * 	directional movement.
 * REPEAT_ONGOING is the number of VBlanks to skip between each
 *	successive repeat.
 * MOUSEMOVE_THRESH is the number of mouse ticks below which we
 *	ignore the event completely.  This is to prevent drift
 *	of the highlight box in the axis perpendicular to the
 *	principal motion of the mouse.
 * MOUSEJUMP_THRESH is the number of mouse ticks that must
 *	be exceeded to cause a jump of the highlight box in
 *	that direction.
 * MOUSEDECAY_RATE is the rate at which the mouse ticks decay to
 *	zero when the mouse does not move.
 */
#define REPEAT_INITIAL		45
#define REPEAT_ONGOING		10
#define MOUSEMOVE_THRESH	2
#define MOUSEJUMP_THRESH	100
#define MOUSEDECAY_RATE		5

#define REPEATING	0x80000000

ULONG LastJoyBits = 0;
UWORD LastJoyEvent = NO_JOYEVENT;
UWORD RepeatCount = 0;
LONG MouseX = 0;
LONG MouseY = 0;


/* Map of Game Controller buttons to functions: */
#define NUM_JOYPORTEVENTS 11
ULONG JoyEventMap[ NUM_JOYPORTEVENTS ][ 2 ] =
{
    { JPF_BTN1,  KEY_STOP },		/* A (Red) button is select */
    { JPF_BTN2,  IECODE_LBUTTON },	/* B (Blue) button is stop */
    { JPF_BTN3,  KEY_REPEAT },		/* C (Yellow) button is repeat */
    { JPF_BTN4,  KEY_SHUFFLE },		/* D (Green) button is shuffle */
    { JPF_BTN5,  KEY_FWD },		/* Right Ear button is forward */
    { JPF_BTN6,  KEY_BACK },		/* Left Ear button is rewind */
    { JPF_BTN7,  KEY_PLAY },		/* Play/Pause button toggles play/pause */
    { JPF_UP,    DIR_UP | REPEATING },		/* Move up */
    { JPF_DOWN,  DIR_DOWN | REPEATING },	/* Move down */
    { JPF_LEFT,  DIR_LEFT | REPEATING },	/* Move left */
    { JPF_RIGHT, DIR_RIGHT | REPEATING },	/* Move right */
};

static int
abs( int val )
{
    return( val > 0 ? val : -val );
}

static UWORD
GetControllerEvent(void)
{
ULONG joybits0, joybits1, joybits;
UWORD i;
ULONG event = 0;
UWORD joyevent;

    joybits0 = ReadJoyPort(0);
    joybits1 = ReadJoyPort(1);

    joybits = 0;
    /* We'll heed a joystick or controller in either port.
     * Also, we listen for a mouse in port zero.  Note that
     * here we look only for mouse buttons.  Mouse movement
     * is handled near the end.
     */
    if ( ( ( joybits0 & JP_TYPE_MASK ) == JP_TYPE_GAMECTLR ) ||
	( ( joybits0 & JP_TYPE_MASK ) == JP_TYPE_JOYSTK ) )
    {
	joybits = joybits0;
    }

    if ( ( ( joybits1 & JP_TYPE_MASK ) == JP_TYPE_GAMECTLR ) ||
	( ( joybits1 & JP_TYPE_MASK ) == JP_TYPE_JOYSTK ) )
    {
	joybits |= joybits1;
    }

    /* Let's look for mouse buttons.  The three buttons come in
     * as left = JPF_BTN2, mid = JPF_BTN7, right= JPF_BTN1.
     * Also, if this is a joystick or mouse that hasn't yet
     * moved, it's unknown but we should still respect the buttons.
     */
    if ( ( ( joybits0 & JP_TYPE_MASK ) == JP_TYPE_MOUSE ) ||
	( ( joybits0 & JP_TYPE_MASK ) == JP_TYPE_UNKNOWN ) )
    {
	joybits |= ( joybits0 & ( JPF_BTN2 | JPF_BTN7 | JPF_BTN1 ) );
    }

    joyevent = NO_JOYEVENT;
    for ( i = 0; i < NUM_JOYPORTEVENTS; i++ )
    {
	if ( joybits & JoyEventMap[ i ][ 0 ] )
	{
	    /* Note which button is down.  If two or more buttons are
	     * down, we do nothing, and wait for the situation to
	     * normalize.
	     */
	    if ( joyevent == NO_JOYEVENT )
	    {
		joyevent = i;
	    }
	    else
	    {
		return( 0 );
	    }
	}
    }

    /* If no button was down previously */
    if ( LastJoyEvent == NO_JOYEVENT )
    {
	/* If there's a button down now */
	if ( joyevent != NO_JOYEVENT )
	{
	    /* Send the event for the button in question */
	    event = ( JoyEventMap[ joyevent ][ 1 ] );
	    LastJoyEvent = joyevent;
	    if ( event & REPEATING )
	    {
		RepeatCount = REPEAT_INITIAL;
	    }
	    else
	    {
		RepeatCount = 0;
	    }
	}
    }
    else
    {
	/* We know a button used to be down.  If no buttons are now down,
	 * or if the button that is down is different from the last one
	 * we handled, send the upstroke for the last one down.
	 */
	if ( ( joyevent == NO_JOYEVENT ) || ( LastJoyEvent != joyevent ) )
	{
	    event = ( JoyEventMap[ LastJoyEvent ][ 1 ] | IECODE_UP_PREFIX );
	    LastJoyEvent = NO_JOYEVENT;
	}
	else /* Button is still down */
	{
	    if ( RepeatCount )
	    {
		if ( --RepeatCount == 0 )
		{
		    event = JoyEventMap[ joyevent ][ 1 ];
		    RepeatCount = REPEAT_ONGOING;
		}
	    }
	}
    }
    if ( !event )
    {
	if ( ( joybits0 & JP_TYPE_MASK ) == JP_TYPE_MOUSE )
	{
	    static firstread = 1;
	    static BYTE lastMouseCountX;
	    static BYTE lastMouseCountY;
	    BYTE mouseCountX = ( joybits0 & JP_MHORZ_MASK );
	    BYTE mouseCountY = ( joybits0 & JP_MVERT_MASK ) >> 8;
	    BYTE deltax = mouseCountX - lastMouseCountX;
	    BYTE deltay = mouseCountY - lastMouseCountY;

	    lastMouseCountX = mouseCountX;
	    lastMouseCountY = mouseCountY;
	    if ( firstread )
	    {
		firstread = 0;
	    }
	    else
	    {
		/* If X movement exceeds a "noise" threshold, then we listen
		 * to that motion, otherwise we decay the current MouseX back
		 * towards the origin.
		 */
		if ( abs( deltax ) > MOUSEMOVE_THRESH )
		{
		    MouseX += deltax;
		}
		else if ( !deltax )
		{
		    if ( MouseX > 0 )
		    {
			MouseX -= MOUSEDECAY_RATE;
			if ( MouseX < 0 )
			{
			    MouseX = 0;
			}
		    }
		    else if ( MouseX < 0 )
		    {
			MouseX += MOUSEDECAY_RATE;
			if ( MouseX > 0 )
			{
			    MouseX = 0;
			}
		    }
		}

		/* If Y movement exceeds a "noise" threshold, then we listen
		 * to that motion, otherwise we decay the current MouseY back
		 * towards the origin.
		 */
		if ( abs( deltay ) > MOUSEMOVE_THRESH )
		{
		    MouseY += deltay;
		}
		else if ( !deltay )
		{
		    if ( MouseY > 0 )
		    {
			MouseY -= MOUSEDECAY_RATE;
			if ( MouseY < 0 )
			{
			    MouseY = 0;
			}
		    }
		    else if ( MouseY < 0 )
		    {
			MouseY += MOUSEDECAY_RATE;
			if ( MouseY > 0 )
			{
			    MouseY = 0;
			}
		    }

		}

		/* If the MouseX or MouseY exceeds the jump threshold
		 * then we issue a joystick event and recenter the mouse
		 * on that axis.
		 */
		if ( MouseX > MOUSEJUMP_THRESH )
		{
		    MouseX = 0;
		    event = DIR_RIGHT;
		}
		else if ( MouseX < -MOUSEJUMP_THRESH )
		{
		    MouseX = 0;
		    event = DIR_LEFT;
		}
		else if ( MouseY > MOUSEJUMP_THRESH )
		{
		    MouseY = 0;
		    event = DIR_DOWN;
		}
		else if ( MouseY < -MOUSEJUMP_THRESH )
		{
		    MouseY = 0;
		    event = DIR_UP;
		}
	    }
	}
    }
    return( (UWORD) (event & ~REPEATING) );
@


1.17
log
@Made SAS/6 clean.  Conditionally compile out the cleanup code.
@
text
@d1 1
a1 1
/* $Id: player.c,v 1.16 93/03/08 18:23:35 peter Exp Locker: peter $ */
a59 1
extern void             UpdateGadgets(void);
d62 1
a62 1
extern UWORD *          DoAnimation(UWORD *ins);
a80 1
extern UBYTE __far              playerstrip[];
d84 2
a85 2
void  PlayerLoop(struct CDGPrefs *);
void  DoKeyStroke(UWORD);
d87 6
a92 7
void  SetupPlayer(void);
void  ShutDown(void);
void  DoReset(void);
UBYTE inlist(UBYTE);
void  AbortQCode(void);
UWORD GetControllerEvent(void);
int SubmitKeys(UWORD event);
a93 2
LONG __asm changeintr(register __a1 struct changedata *);

d99 1
a99 1
    playerstrip,	/* UBYTE *BackData (strip) */
d102 2
a103 2
    352, 296, 6,	/* Width, Height, Depth */
    14, 54,		/* ForXOff, ForYOff */
d165 76
a242 14
    PLGAD_DISK,38, PLGAD_MIN, 100, PLGAD_SEC, 100, PLGAD_NEG, 0, 0xffff,
    PLGAD_DISK,37, 0xffff,
    PLGAD_DISK,36, 0xffff,
    PLGAD_DISK,35, 0xffff,
    PLGAD_DISK,34, 0xffff,
    PLGAD_DISK,33, 0xffff,
    PLGAD_DISK,32, 0xffff,
    PLGAD_DISK,31, 0xffff,
    PLGAD_DISK,30, 0xffff,
    PLGAD_DISK,29, 0xffff,
    PLGAD_DISK,28, 0xffff,
    PLGAD_DISK,27, 0xffff,
    PLGAD_DISK,26, 0xffff,
    PLGAD_DISK,25, 0xffff,
a266 1
    PLGAD_DISK, 1, 0xffff,
d269 1
d326 13
a338 14
    PLGAD_DISK,25, PLGAD_COUNTER,HEAD_FLYING +12, 0xffff,
    PLGAD_DISK,26, PLGAD_COUNTER,HEAD_FLYING +11, 0xffff,
    PLGAD_DISK,27, PLGAD_COUNTER,HEAD_FLYING +10, 0xffff,
    PLGAD_DISK,28, PLGAD_COUNTER,HEAD_FLYING + 9, 0xffff,
    PLGAD_DISK,29, PLGAD_COUNTER,HEAD_FLYING + 8, 0xffff,
    PLGAD_DISK,30, PLGAD_COUNTER,HEAD_FLYING + 7, 0xffff,
    PLGAD_DISK,31, PLGAD_COUNTER,HEAD_FLYING + 6, 0xffff,
    PLGAD_DISK,32, PLGAD_COUNTER,HEAD_FLYING + 5, 0xffff,
    PLGAD_DISK,33, PLGAD_COUNTER,HEAD_FLYING + 4, 0xffff,
    PLGAD_DISK,34, PLGAD_COUNTER,HEAD_FLYING + 3, 0xffff,
    PLGAD_DISK,35, PLGAD_COUNTER,HEAD_FLYING + 2, 0xffff,
    PLGAD_DISK,36, PLGAD_COUNTER,HEAD_FLYING + 1, 0xffff,
    PLGAD_DISK,37, PLGAD_COUNTER,HEAD_FLYING + 0, 0xffff,
    PLGAD_DISK,38, 0xffff,
a388 1
struct CDTVPrefs    prefs;
d397 5
a401 1
     * any effect
d407 1
a407 1
    if (!StartPPScreen(PlayGADList, &PlayerBg, scrbuttons, 15))
a429 2
			    FillCDTVPrefs(&prefs);

d524 1
a524 1
void
d529 1
d537 1
a537 1
    SetupPlayer();
d630 1
d634 1
a634 1
		SetupPlayer();
d641 8
a648 1
	WaitTOF();
d658 1
a658 1
void
d810 1
a811 83
#if DEBUGGING
{
    int i;
    static char *modes[] =
    {
        "Normal",
        "FFwd",
        "FRev",
        "SkipFwd",
        "SkipRev",
    };
    static char *states[] =
    {
        "Stopped",
        "Selected",
        "NumEntry",
        "Playing",
        "Paused",
    };

    kprintf("Debugging:\n");
    kprintf("State: %s, Mode: %s\n", states[ PlayerState.PlayState ], modes[ PlayerState.PlayMode ] );
    kprintf("Disk: %ld, Tracks: %ld, ListIndex: %ld, Track: %ld, Time: %ld:%ld\n",
	PlayerState.AudioDisk, PlayerState.Tracks, PlayerState.ListIndex,
	PlayerState.Track, PlayerState.Minute, PlayerState.Second );
    kprintf("PlayList EntryCount %ld", PlayList->EntryCount );
    for ( i = 0; i < PlayList->EntryCount; i++ )
    {
	if ( ( i % 10 ) == 0 )
	{
	     kprintf("\n    ");
	}
	kprintf("%s%2ld%s ",
	PlayList->Entry[ i ] & PLEF_ENABLE ? " " : "(",
	PlayList->Entry[ i ] & PLEF_TRACK,
	PlayList->Entry[ i ] & PLEF_ENABLE ? " " : ")" );
    }
    kprintf("\nShuffleMode: %ld\n\n", ShuffleMode);

    {
	struct MinNode *node;
	struct PlayerLibrary
	{

	    struct Library          PlayerLib;

	    APTR                    SegList;

	    struct Task            *PlayerTask;
	    struct MsgPort         *TaskMsgPort;
	    struct MsgPort         *TaskReplyPort;

	    struct PlayerOptions    PlayerOptions;
	    struct PlayerState      PlayerState;
	    struct PlayList         PlayList;

	    struct SignalSemaphore  PlayListSemaphore;
	    struct SignalSemaphore  PlayStateSemaphore;
	} *pl = (struct PlayerLibrary *) PlayerBase;
	kprintf("PlayerTask: %lx\n", pl->PlayerTask);
	kprintf("PlayListSem: \"%s\"\n    Owner %lx, NestCount %ld, QueueCount %ld\n",
		pl->PlayListSemaphore.ss_Link.ln_Name,
		pl->PlayListSemaphore.ss_Owner, pl->PlayListSemaphore.ss_NestCount,
		pl->PlayListSemaphore.ss_QueueCount );
	for ( node = pl->PlayListSemaphore.ss_WaitQueue.mlh_Head;
	    node->mln_Succ; node = node->mln_Succ )
	{
	    kprintf("%lx ", ((struct SemaphoreRequest *)node)->sr_Waiter );
	}
	kprintf("PlayStateSem: \"%s\"\n    Owner %lx, NestCount %ld, QueueCount %ld\n",
		pl->PlayStateSemaphore.ss_Link.ln_Name,
		pl->PlayStateSemaphore.ss_Owner, pl->PlayStateSemaphore.ss_NestCount,
		pl->PlayStateSemaphore.ss_QueueCount );
	for ( node = pl->PlayStateSemaphore.ss_WaitQueue.mlh_Head;
	    node->mln_Succ; node = node->mln_Succ )
	{
	    kprintf("%lx ", ((struct SemaphoreRequest *)node)->sr_Waiter );
	}
    }
}
#else
		if ( ( MasterIB->ib_BoxNo >= PLGAD_1 ) &&
		    ( MasterIB->ib_BoxNo <= PLGAD_20 ) )
d813 25
a837 1
		    if ( PlayList->EntryCount )
d839 8
a846 1
			ResetPlayList(1);
d848 41
a888 3
		    else
		    {
			ResetPlayList(0);
a889 2

		    UpdatePlayTime();
a890 1
#endif
d892 1
d987 1
a987 1
int
d1017 1
a1017 1
		ResetPlayList( 0 );
d1205 6
d1271 1
a1271 1
void
a1274 1
UWORD *anim;
d1291 11
d1354 1
a1354 7
	FadeTo(0);
    }

    anim = IntroData;
    while ( anim )
    {
	anim = DoAnimation( anim );
d1371 4
a1374 2
    if (!cdio->io_Error) InitTrackCounter();

d1383 1
d1389 1
a1389 1
void
d1419 1
a1419 1
	    anim = DoAnimation(anim);
d1431 1
a1431 1
    while(anim = DoAnimation(anim));
d1438 1
a1438 1
void
d1441 1
a1441 1
    FadeTo(15);
d1449 1
a1449 1
void
d1524 1
a1524 1
int
d1530 1
a1530 1
UWORD
@


1.16
log
@Use state definitions, minor cleanup.  Now unshuffles when play stops
due to end-of-disk.  Changed where includes come from.
@
text
@d1 1
a1 1
/* $Id: player.c,v 1.15 93/03/03 13:31:52 peter Exp Locker: peter $ */
a62 1
extern                  StartPPScreen(struct GadDir *gl, struct BuildBG_Info *bg, UBYTE *buttondata, UBYTE initfade);
d64 1
a64 1
extern int NOOP(void);
a85 2
LONG __asm DoPlayer(register __a6 struct PlayerPrefsBase *);

d319 1
d322 4
d352 1
a352 1
	    WorkIB->ib_GState[i] = CurrentIB->ib_GState[i] = -1;
d384 1
a384 1
						if (PlayerBase = OpenLibrary("player.library", NULL))
d393 2
d441 19
d681 1
a681 1
		IntroCount = -1;
d1409 1
a1409 1
#define NO_JOYEVENT	~0
d1672 1
a1672 1
    return( event & ~REPEATING );
@


1.15
log
@Cleaned up CD+G state handling.  Now handle CD+G issues when changing disks.
@
text
@d1 1
a1 1
/* $Id: player.c,v 1.14 93/02/26 19:03:51 peter Exp Locker: peter $ */
a8 4
#if 000
#else	/* Only needed for WriteTinyStr() code */
#include <intuition/intuition.h>
#endif
d12 1
a12 1
#include <gs:cd/cd.h>
d15 1
a15 1
#include <cdtv/debox.h>
a18 1
#include "/cdtvkeys.h"
d33 3
a35 3
#if 000
#include <cdtv/debox_protos.h>
#endif
d40 2
a41 1
#include <cdtv/debox_pragmas.h>
d43 1
a43 5
#include <cdtv/cdg_cr_pragmas.h>
#include <cdtv/cdg_cr_protos.h>
#ifndef CDTV_CDGPREFS_H
#include <cdtv/cdg_cr_prefs.h>
#endif
d45 3
a47 3
#include <libraries/game.h>
#include <clib/game_protos.h>
#include <pragmas/game_pragmas.h>
d120 1
d138 1
a138 1
struct GameBase      *GameBase;
d190 22
a211 22
    PLGAD_DISK,23, PLGAD_COUNTER, 0x8000+ 0, 0xffff,
    PLGAD_DISK,22, PLGAD_COUNTER, 0x8000+ 1, 0xffff,
    PLGAD_DISK,21, PLGAD_COUNTER, 0x8000+ 2, 0xffff,
    PLGAD_DISK,20, PLGAD_COUNTER, 0x8000+ 3, 0xffff,
    PLGAD_DISK,19, PLGAD_COUNTER, 0x8000+ 4, 0xffff,
    PLGAD_DISK,18, PLGAD_COUNTER, 0x8000+ 5, 0xffff,
    PLGAD_DISK,17, PLGAD_COUNTER, 0x8000+ 6, 0xffff,
    PLGAD_DISK,16, PLGAD_COUNTER, 0x8000+ 7, 0xffff,
    PLGAD_DISK,15, PLGAD_COUNTER, 0x8000+ 8, 0xffff,
    PLGAD_DISK,14, PLGAD_COUNTER, 0x8000+ 9, 0xffff,
    PLGAD_DISK,13, PLGAD_COUNTER, 0x8000+10, 0xffff,
    PLGAD_DISK,12, PLGAD_COUNTER, 0x8000+11, 0xffff,
    PLGAD_DISK,11, PLGAD_COUNTER, 0x8000+12, 0xffff,
    PLGAD_DISK,10, PLGAD_COUNTER, 0x8000+13, 0xffff,
    PLGAD_DISK, 9, PLGAD_COUNTER, 0x8000+14, 0xffff,
    PLGAD_DISK, 8, PLGAD_COUNTER, 0x8000+15, 0xffff,
    PLGAD_DISK, 7, PLGAD_COUNTER, 0x8000+16, 0xffff,
    PLGAD_DISK, 6, PLGAD_COUNTER, 0x8000+17, 0xffff,
    PLGAD_DISK, 5, PLGAD_COUNTER, 0x8000+18, 0xffff,
    PLGAD_DISK, 4, PLGAD_COUNTER, 0x8000+19, 0xffff,
    PLGAD_DISK, 3, PLGAD_COUNTER, 0x8000+20, 0xffff,
    PLGAD_DISK, 2, PLGAD_COUNTER, 0x8000+21, 0xffff,
d221 1
a221 1
    PLGAD_SHUFF,0,PLGAD_CDG,4,PLGAD_MIN, 100, PLGAD_SEC, 100, PLGAD_NEG, 0, 0xffff,
d263 22
a284 22
    PLGAD_DISK,16, PLGAD_COUNTER,0x8000+21, 0xffff,
    PLGAD_DISK,17, PLGAD_COUNTER,0x8000+20, 0xffff,
    PLGAD_DISK,18, PLGAD_COUNTER,0x8000+19, 0xffff,
    PLGAD_DISK,19, PLGAD_COUNTER,0x8000+18, 0xffff,
    PLGAD_DISK,20, PLGAD_COUNTER,0x8000+17, 0xffff,
    PLGAD_DISK,21, PLGAD_COUNTER,0x8000+16, 0xffff,
    PLGAD_DISK,22, PLGAD_COUNTER,0x8000+15, 0xffff,
    PLGAD_DISK,23, PLGAD_COUNTER,0x8000+14, 0xffff,
    PLGAD_DISK,24, PLGAD_COUNTER,0x8000+13, 0xffff,
    PLGAD_DISK,25, PLGAD_COUNTER,0x8000+12, 0xffff,
    PLGAD_DISK,26, PLGAD_COUNTER,0x8000+11, 0xffff,
    PLGAD_DISK,27, PLGAD_COUNTER,0x8000+10, 0xffff,
    PLGAD_DISK,28, PLGAD_COUNTER,0x8000+ 9, 0xffff,
    PLGAD_DISK,29, PLGAD_COUNTER,0x8000+ 8, 0xffff,
    PLGAD_DISK,30, PLGAD_COUNTER,0x8000+ 7, 0xffff,
    PLGAD_DISK,31, PLGAD_COUNTER,0x8000+ 6, 0xffff,
    PLGAD_DISK,32, PLGAD_COUNTER,0x8000+ 5, 0xffff,
    PLGAD_DISK,33, PLGAD_COUNTER,0x8000+ 4, 0xffff,
    PLGAD_DISK,34, PLGAD_COUNTER,0x8000+ 3, 0xffff,
    PLGAD_DISK,35, PLGAD_COUNTER,0x8000+ 2, 0xffff,
    PLGAD_DISK,36, PLGAD_COUNTER,0x8000+ 1, 0xffff,
    PLGAD_DISK,37, PLGAD_COUNTER,0x8000+ 0, 0xffff,
d335 2
a336 1
    InitVarBase(ppb);                                                                                    /* Initilize the varables */
d348 4
a351 1
	for (i=PLGAD_STOP; i<=PLGAD_20; i++) WorkIB->ib_GState[i] = CurrentIB->ib_GState[i] = -1;
d371 1
a371 1
			    if (TOC = AllocMem(sizeof(union CDTOC) * 100, MEMF_PUBLIC))
d384 1
a384 1
						    if (GameBase = (struct GameBase *)OpenLibrary("game.library", 0L))
d396 1
a396 1
							CloseLibrary(GameBase);
a409 1

d413 1
a413 1
				FreeMem(TOC, sizeof(union CDTOC) * 100);
d448 1
a448 1
ULONG               event;
d486 18
a523 1
		    MasterIB->ib_BoxNo = PLGAD_CDG;
d616 3
a618 3
		 * initiate a fresh play.  So we stop playing
		 * if paused, and restart after shuffling, if
		 * stopped.
d620 1
a620 8
		if ( PlayerState.PlayState == PLS_PAUSED )
		{
		    SubmitKeyStroke(KeyPressed = PKS_STOP|PKSF_PRESS);
		    SubmitKeyStroke(KeyPressed = PKS_STOP|PKSF_RELEASE);
		}

		ShuffleGrid();                                                                                      /* Call zero for not quick */

d626 3
a628 2


d631 2
a632 1
	    case KEY_TIMEMODE:                                                                                      /* Change time display mode. */
d640 2
a641 1
	    case KEY_REPEAT:                                                                                        /* A/B loop */
d649 2
a650 1
	    case KEY_INTRO:                                                                                         /* Intro mode */
d668 3
a702 1
		    MasterIB->ib_BoxNo = PLGAD_CDG;
d722 92
a813 5

		if (MasterIB->ib_BoxNo >= PLGAD_1 && MasterIB->ib_BoxNo <= PLGAD_20)
		{
		    if (PlayList->EntryCount) ResetPlayList(1);
		    else                      ResetPlayList(0);
d817 1
a817 1

d820 2
a821 1
	    case RAWKEY_ENTER:                                                                                      /* Numeric keypad */
d823 5
a827 1
		if (MasterIB->ib_BoxNo >= PLGAD_1 && MasterIB->ib_BoxNo <= PLGAD_20) DoBoxMove(DIR_RIGHT);
d870 1
d872 1
d880 1
d889 2
a890 1
		if ( CDGchannel-- == 0 )
d908 5
a912 1

d918 1
a918 9
	case KEY_PAUSE:                                                                                         /* Pause */

	    if (PlayerState.PlayState > PLS_SELECTED)
	    {
		SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_PRESS);
		SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_RELEASE);
	    }

	    return(1);
a919 2
	case KEY_PLAY:                                                                                          /* Play */

d924 1
a924 4
	case KEY_STOP:                                                                                          /*  Stop  */

	    SubmitKeyStroke(KeyPressed = PKS_STOP|PKSF_PRESS);
	    SubmitKeyStroke(KeyPressed = PKS_STOP|PKSF_RELEASE);
a926 1

d931 17
d950 1
a950 1
	case KEY_BACK:                                                                                          /* Back track */
d956 1
a956 1
	case KEY_FWD:                                                                                           /* Next track */
d1069 1
d1126 4
d1195 2
a1196 1
UWORD  *anim;
d1211 1
a1211 1
    MasterIB->ib_GState[PLGAD_CDG] = 4;
d1213 1
d1215 2
a1216 1
    cdio->io_Command = CD_ATTENUATE;                                                                                /* Turn on the speakers; full volume, right now(sorta). */
d1221 2
a1222 1
    cdqcode->io_Command  = CD_QCODELSN;                                                                             /* Initialize the qcode packet. */
d1225 2
a1226 1
    TimeReq->tr_node.io_Command = TR_ADDREQUEST;                                                                    /* Create timer request */
d1268 1
a1268 1
    while (anim)
d1270 1
a1270 1
	anim = DoAnimation(anim);
d1280 2
a1281 1
    cdio->io_Command  = CD_TOCLSN;                                                                          /* Gimme summary. */
d1307 1
a1359 15
/**************** Determine if a Track is in the PlayList ******************/

UBYTE
inlist(UBYTE track)
{
int i;

    for (i=0; i!=PlayList->EntryCount; i++)
	if ((PlayList->Entry[i] & PLEF_TRACK) == track) return(PlayList->Entry[i]);

    return(0);
}



d1402 2
d1409 1
d1437 6
d1469 1
a1469 1
	joybits  |= joybits1;
d1472 7
a1478 1
    if ( ( joybits0 & JP_TYPE_MASK ) == JP_TYPE_MOUSE )
d1480 1
a1480 1
	joybits |= ( joybits0 & ( JPF_BTN1 | JPF_BTN2 | JPF_BTN3 ) );
d1565 5
a1569 1
		if ( ( deltax > MOUSEMOVE_THRESH ) || ( deltax < -MOUSEMOVE_THRESH ) )
d1573 25
a1597 1
		if ( ( deltay > MOUSEMOVE_THRESH ) || ( deltay < -MOUSEMOVE_THRESH ) )
d1601 20
d1622 4
@


1.14
log
@Major work.  Intuitionized.  Prototyped.  Improved behavior.  Added comments.
@
text
@d1 1
a1 1
/* $Id: $ */
d147 24
a170 1
int    CDGAvail = 0, CDGPlaying = 0, CDGDisplaying = 0;
d172 1
a172 1
int    ScreenFront = 0;
a173 1
UBYTE  channel;
d451 1
d453 6
a458 1
    CDGAvail = CDGBegin(cdp);
d490 9
a498 1
		if (!CDGPlaying)
d500 3
a502 1
		    if (CDGAvail && PlayerState.PlayState >= PLS_PLAYING)
d504 2
a505 7
			MasterIB->ib_GState[PLGAD_CDG] = CDGDraw(CDGF_GRAPHICS|CDGF_MIDI);
			if ( MasterIB->ib_GState[PLGAD_CDG] & CDGF_GRAPHICS )
			
			{
			    CDGPlaying = channel = 1;
			    CDGChannel( channel );
			    CDGClearScreen();
d507 4
a510 11
			    if (PlayerState.PlayState == PLS_PAUSED) CDGPause();
			    else                                     CDGPlay(0);


			    /* Because of the loss of the B-button to toggle
			     * in/out of CD+G, we'll always play CD+G
			     */
			    CDGDisplaying = 1;
			    AbleColorChanger( FALSE );
			    CDGFront();
			    MasterIB->ib_BoxNo = PLGAD_CDG;
d512 7
a518 3
			    if (MasterIB->ib_GState[PLGAD_FF])       CDGFastForward();
			    else if (MasterIB->ib_GState[PLGAD_REV]) CDGRewind();
			}
d522 1
a522 3
		else CDGDraw(CDGF_GRAPHICS|CDGF_MIDI);

		if (!CDGDisplaying)
d561 1
a561 1
    if (!CDGDisplaying)
d575 4
a578 1
	    case RAWKEY_ARROWUP: dir = DIR_UP;      DoBoxMove(dir);  break;
d580 14
a593 5
	    case RAWKEY_ARROWDN: dir = DIR_DOWN;    DoBoxMove(dir);  break;

	    case RAWKEY_ARROWLT: dir = DIR_LEFT;    DoBoxMove(dir);  break;

	    case RAWKEY_ARROWRT: dir = DIR_RIGHT;   DoBoxMove(dir);  break;
d661 4
a664 1
		if (CDGPlaying) CDGClearScreen();
d670 4
a673 1
		if (CDGPlaying) CDGClearScreen();
d687 1
a687 1
		if (!CDGDisplaying && CDGPlaying)
d689 1
a689 1
		    CDGDisplaying = 1;
d693 4
a696 1
		    if (PlayerState.PlayState == PLS_PAUSED) CDGPause();
d698 8
a705 2
		    if (MasterIB->ib_GState[PLGAD_FF])       CDGFastForward();
		    else if (MasterIB->ib_GState[PLGAD_REV]) CDGRewind();
a706 1

d731 7
d739 3
a741 5
    else if (!SubmitKeys(event)) switch (event)
    {
	case RAWKEY_PREVTRAK:
	    CDGRewind();
	    break;
d743 10
a752 3
	case RAWKEY_NEXTTRAK:
	    CDGFastForward();
	    break;
d754 10
a763 11
	case (RAWKEY_PREVTRAK | IECODE_UP_PREFIX):
	case (RAWKEY_NEXTTRAK | IECODE_UP_PREFIX):
	    if (PlayerState.PlayState == PLS_PAUSED)
	    {
		CDGPause();
	    }
	    else
	    {
		CDGPlay(0);
	    }
	    break;
d765 7
a771 7
	case IECODE_LBUTTON:
	    CDGDisplaying = 0;
	    CDGBack();
	    SetTrackCounter(1);
	    MasterIB->ib_GState[PLGAD_REV] = MasterIB->ib_GState[PLGAD_FF]  = 0;
	    playertofront = 1;
	    break;
d773 7
a779 4
	case DIR_UP:
	    if (++channel > 15) channel = 1;
	    CDGChannel((channel & 0x0f));
	    break;
d781 7
a787 4
	case DIR_DOWN:
	    if (channel-- == 0) channel = 15;
	    CDGChannel((channel & 0x0f));
	    break;
d789 6
a794 5
	case (DIR_UP | IECODE_UP_PREFIX):
	case (DIR_DOWN | IECODE_UP_PREFIX):
	    if ((KeyPressed & PKSF_STROKEDIR) == PKSF_PRESS)
		SubmitKeyStroke(KeyPressed = ((KeyPressed & PKSF_KEY) | PKSF_RELEASE));
	    break;
d910 3
a912 1
    if (CDGPlaying)
d914 2
a915 1
	if (CDGDisplaying && LastPlayMode == PlayerState.PlayMode && LastPlayState == PlayerState.PlayState) return;
d917 3
a919 1
	if (LastPlayState != PlayerState.PlayState) switch (PlayerState.PlayState)
d922 4
a925 1

d928 7
a934 1
		if (CDGDisplaying)
d936 6
a941 1
		    playertofront = 1;
d943 1
a943 1
		CDGPlaying = CDGDisplaying = 0;
d945 2
a946 1
		MasterIB->ib_GState[PLGAD_REV] = MasterIB->ib_GState[PLGAD_FF]  = 0;
a947 3

	    case PLS_PLAYING: CDGPlay(1); break;
	    case PLS_PAUSED:  CDGPause(); break;
d951 1
a951 1
    switch (PlayerState.PlayState)
a953 1

a958 1

d970 4
a973 2
    if (PlayerState.PlayState == PLS_STOPPED) MasterIB->ib_GState[PLGAD_TTRACK] = PlayerState.Tracks;

d1005 1
a1005 1
    if (PlayerState.AudioDisk == 1)
d1011 1
a1011 1
    if (PlayerState.PlayMode == PLM_NORMAL)
d1037 2
a1038 1
    MasterIB->ib_GState[PLGAD_NEG]    = ( ( PlayerOptions.TimeMode & 1 ) && ( PlayerState.PlayState != PLS_STOPPED ) );
a1092 2
    CDGPlaying = 0;
    CDGDisplaying = 0;
d1183 7
@


1.13
log
@First round of major improvements by Peter.
@
text
@d1 1
a2 1

d9 4
a12 1

a21 1
#include "/basicio/keyclick.h"
d25 1
d30 2
d33 6
a38 3
#include "clib/exec_protos.h"
#include "clib/dos_protos.h"
#include "clib/graphics_protos.h"
d40 1
a40 1

d44 1
d47 5
a51 2
#include "cdtv/cdg_cr_pragmas.h"
#include "cdtv/cdg_cr_prefs.h"
d54 2
a55 2
#include "cdgs:src/game/Game_pragmas.h"
#include "cdgs:src/game/Game_protos.h"
d57 3
a59 3
#include "cdgs:include/internal/playerlibrary.h"
#include "cdgs:include/internal/player_protos.h"
#include "cdgs:include/internal/player_pragmas.h"
d69 2
a70 2
extern VOID __stdargs   EndCDTVScreen(VOID);
extern VOID             InitVarBase(register struct PlayerPrefsBase *ppb);
d72 2
a73 4
extern UWORD           *DoAnimation();
#if NUMBER_ENTRY
extern void             PlayerNumPad(int);
#endif
d78 1
d80 1
a80 1
extern void                    *SysBase;
d83 4
a86 1
extern struct CycleIntInfo      intdata;
d100 1
a100 1
void  SetupPlayer();
a102 2
void  disableclick(int);
void  click(void);
d105 2
a106 1
UWORD GetJoyPortEvent(void);
d112 2
a113 2
struct BuildBg_Info __far PlayerBg = {

d121 1
a121 1
    };
a125 1
WORD CDGFlashTicks = 0;
d129 1
d148 1
a149 4
int    LastEntryCount = -1;
#if NUMBER_ENTRY
int    NumericPadEnabled = 1;
#endif
a150 2
short  changesigbit = -1;
BYTE   keyclick;
a151 1
WORD   blank;
d158 41
a198 41
UWORD IntroData[] = {

    1, PLGAD_DISK,38, PLGAD_MIN, 100, PLGAD_SEC, 100, PLGAD_NEG, 0, 0xffff,
    1, PLGAD_DISK,37, 0xffff,
    1, PLGAD_DISK,36, 0xffff,
    1, PLGAD_DISK,35, 0xffff,
    1, PLGAD_DISK,34, 0xffff,
    1, PLGAD_DISK,33, 0xffff,
    1, PLGAD_DISK,32, 0xffff,
    1, PLGAD_DISK,31, 0xffff,
    1, PLGAD_DISK,30, 0xffff,
    1, PLGAD_DISK,29, 0xffff,
    1, PLGAD_DISK,28, 0xffff,
    1, PLGAD_DISK,27, 0xffff,
    1, PLGAD_DISK,26, 0xffff,
    1, PLGAD_DISK,25, 0xffff,
    1, PLGAD_DISK,24, 0xffff,
    1, PLGAD_DISK,23, PLGAD_COUNTER, 0x8000+ 0, 0xffff,
    1, PLGAD_DISK,22, PLGAD_COUNTER, 0x8000+ 1, 0xffff,
    1, PLGAD_DISK,21, PLGAD_COUNTER, 0x8000+ 2, 0xffff,
    1, PLGAD_DISK,20, PLGAD_COUNTER, 0x8000+ 3, 0xffff,
    1, PLGAD_DISK,19, PLGAD_COUNTER, 0x8000+ 4, 0xffff,
    1, PLGAD_DISK,18, PLGAD_COUNTER, 0x8000+ 5, 0xffff,
    1, PLGAD_DISK,17, PLGAD_COUNTER, 0x8000+ 6, 0xffff,
    1, PLGAD_DISK,16, PLGAD_COUNTER, 0x8000+ 7, 0xffff,
    1, PLGAD_DISK,15, PLGAD_COUNTER, 0x8000+ 8, 0xffff,
    1, PLGAD_DISK,14, PLGAD_COUNTER, 0x8000+ 9, 0xffff,
    1, PLGAD_DISK,13, PLGAD_COUNTER, 0x8000+10, 0xffff,
    1, PLGAD_DISK,12, PLGAD_COUNTER, 0x8000+11, 0xffff,
    1, PLGAD_DISK,11, PLGAD_COUNTER, 0x8000+12, 0xffff,
    1, PLGAD_DISK,10, PLGAD_COUNTER, 0x8000+13, 0xffff,
    1, PLGAD_DISK, 9, PLGAD_COUNTER, 0x8000+14, 0xffff,
    1, PLGAD_DISK, 8, PLGAD_COUNTER, 0x8000+15, 0xffff,
    1, PLGAD_DISK, 7, PLGAD_COUNTER, 0x8000+16, 0xffff,
    1, PLGAD_DISK, 6, PLGAD_COUNTER, 0x8000+17, 0xffff,
    1, PLGAD_DISK, 5, PLGAD_COUNTER, 0x8000+18, 0xffff,
    1, PLGAD_DISK, 4, PLGAD_COUNTER, 0x8000+19, 0xffff,
    1, PLGAD_DISK, 3, PLGAD_COUNTER, 0x8000+20, 0xffff,
    1, PLGAD_DISK, 2, PLGAD_COUNTER, 0x8000+21, 0xffff,
    1, PLGAD_DISK, 1, PLGAD_COUNTER, 0,         0xffff,
    1, PLGAD_DISK, 1, 0xffff,
d200 1
a200 1
    };
d203 24
a226 24
UWORD ShutdownAnim[] = {

    0,PLGAD_STOP,0,PLGAD_REV,0,PLGAD_PLAY,0,PLGAD_FF,0,
      PLGAD_SHUFF,0,PLGAD_CDG,0,0xffff,
    0, PLGAD_20, 0, 0xffff,
    0, PLGAD_19, 0, 0xffff,
    0, PLGAD_18, 0, 0xffff,
    0, PLGAD_17, 0, 0xffff,
    0, PLGAD_16, 0, 0xffff,
    0, PLGAD_15, 0, 0xffff,
    0, PLGAD_14, 0, 0xffff,
    0, PLGAD_13, 0, 0xffff,
    0, PLGAD_12, 0, 0xffff,
    0, PLGAD_11, 0, 0xffff,
    0, PLGAD_10, 0, 0xffff,
    0, PLGAD_9 , 0, 0xffff,
    0, PLGAD_8 , 0, 0xffff,
    0, PLGAD_7 , 0, 0xffff,
    0, PLGAD_6 , 0, 0xffff,
    0, PLGAD_5 , 0, 0xffff,
    0, PLGAD_4 , 0, 0xffff,
    0, PLGAD_3 , 0, 0xffff,
    0, PLGAD_2 , 0, 0xffff,
    0, PLGAD_1 , 0, 0xffff,
d228 1
a228 1
    };
d231 40
a270 40
UWORD DiskOutAnim[] = {

    1, PLGAD_DISK, 1, 0xffff,
    1, PLGAD_DISK, 2, 0xffff,
    1, PLGAD_DISK, 3, 0xffff,
    1, PLGAD_DISK, 4, 0xffff,
    1, PLGAD_DISK, 5, 0xffff,
    1, PLGAD_DISK, 6, 0xffff,
    1, PLGAD_DISK, 7, 0xffff,
    1, PLGAD_DISK, 8, 0xffff,
    1, PLGAD_DISK, 9, 0xffff,
    1, PLGAD_DISK,10, 0xffff,
    1, PLGAD_DISK,11, 0xffff,
    1, PLGAD_DISK,12, 0xffff,
    1, PLGAD_DISK,13, 0xffff,
    1, PLGAD_DISK,14, 0xffff,
    1, PLGAD_DISK,15, 0xffff,
    1, PLGAD_DISK,16, PLGAD_COUNTER,0x8000+21, 0xffff,
    1, PLGAD_DISK,17, PLGAD_COUNTER,0x8000+20, 0xffff,
    1, PLGAD_DISK,18, PLGAD_COUNTER,0x8000+19, 0xffff,
    1, PLGAD_DISK,19, PLGAD_COUNTER,0x8000+18, 0xffff,
    1, PLGAD_DISK,20, PLGAD_COUNTER,0x8000+17, 0xffff,
    1, PLGAD_DISK,21, PLGAD_COUNTER,0x8000+16, 0xffff,
    1, PLGAD_DISK,22, PLGAD_COUNTER,0x8000+15, 0xffff,
    1, PLGAD_DISK,23, PLGAD_COUNTER,0x8000+14, 0xffff,
    1, PLGAD_DISK,24, PLGAD_COUNTER,0x8000+13, 0xffff,
    1, PLGAD_DISK,25, PLGAD_COUNTER,0x8000+12, 0xffff,
    1, PLGAD_DISK,26, PLGAD_COUNTER,0x8000+11, 0xffff,
    1, PLGAD_DISK,27, PLGAD_COUNTER,0x8000+10, 0xffff,
    1, PLGAD_DISK,28, PLGAD_COUNTER,0x8000+ 9, 0xffff,
    1, PLGAD_DISK,29, PLGAD_COUNTER,0x8000+ 8, 0xffff,
    1, PLGAD_DISK,30, PLGAD_COUNTER,0x8000+ 7, 0xffff,
    1, PLGAD_DISK,31, PLGAD_COUNTER,0x8000+ 6, 0xffff,
    1, PLGAD_DISK,32, PLGAD_COUNTER,0x8000+ 5, 0xffff,
    1, PLGAD_DISK,33, PLGAD_COUNTER,0x8000+ 4, 0xffff,
    1, PLGAD_DISK,34, PLGAD_COUNTER,0x8000+ 3, 0xffff,
    1, PLGAD_DISK,35, PLGAD_COUNTER,0x8000+ 2, 0xffff,
    1, PLGAD_DISK,36, PLGAD_COUNTER,0x8000+ 1, 0xffff,
    1, PLGAD_DISK,37, PLGAD_COUNTER,0x8000+ 0, 0xffff,
    1, PLGAD_DISK,38, 0xffff,
d272 1
a272 1
    };
d307 3
a309 2
LONG __asm DoPlayer(register __a6 struct PlayerPrefsBase *ppb) {

d313 2
d320 88
a407 1
    InitVarBase(ppb);                                                                                           /* Initilize the varables */
d409 2
a410 1
    srand((-vhposr & 0x7fff) ^ 0x1D6539A3);
d412 2
a413 89
    if (!StartPPScreen(PlayGADList, &PlayerBg, scrbuttons, 15)) {

        for (i=PLGAD_STOP; i<=PLGAD_20; i++) WorkF->gstate[i] = CurrentF->gstate[i] = -1;

        if (cdreply = (struct MsgPort *)CreatePort(0, 0)) {

            if (qcodereply = (struct MsgPort *)CreatePort(0, 0)) {

                if (cdio = (struct IOStdReq *)CreateStdIO(cdreply)) {

                    if (cdqcode = (struct IOStdReq *)CreateStdIO(qcodereply)) {

                        if (!OpenDevice("cd.device", 0, cdio, 0)) {

                            CopyMem(cdio, cdqcode, sizeof(*cdio));

                            cdio->io_Message.mn_ReplyPort   = cdreply;
                            cdqcode->io_Message.mn_ReplyPort = qcodereply;
                            qoutstanding = toutstanding = qvalid = 0;

                            FillCDTVPrefs(&prefs);

                            keyclick = (prefs.Flags & CDTVPF_KEYCLICK) != 0;

                            if (TOC = AllocMem(sizeof(union CDTOC) * 100, MEMF_PUBLIC)) {

                                if (UndoPlayList = AllocMem(sizeof(struct PlayList), MEMF_PUBLIC)) {

                                    InstallKeyClick();

                                    if (TimeReplyPort = CreateMsgPort()) {

                                        if (TimeReq = (struct timerequest *)
                                            CreateExtIO(TimeReplyPort, sizeof(struct timerequest))) {

                                            if (!OpenDevice("timer.device", UNIT_VBLANK, TimeReq, 0)) {

                                                if (PlayerBase = OpenLibrary("player.library", NULL)) {

                                                    if (GameBase = (struct GameBase *)OpenLibrary("game.library", 0L)) {

                                                        if (CDG_Open(&cdp)) {

                                                            if (UnpackSprites(&cdp)) {

                                                                PlayerLoop(&cdp);
                                                                CDG_Close();
                                                                }

                                                            }

                                                        CloseLibrary(GameBase);
                                                        }

                                                    CloseLibrary(PlayerBase);
                                                    }

                                                CloseDevice(TimeReq);
                                                }

                                            DeleteExtIO(TimeReq);
                                            }

                                        DeleteMsgPort(TimeReplyPort);
                                        }

                                    KeyClickCommand(CLKCMD_DIE, 0, 0, 0, 0, 0);
                                    FreeMem(UndoPlayList, sizeof(struct PlayList));
                                    }

                                FreeMem(TOC, sizeof(union CDTOC) * 100);
                                }

                            AbortQCode();

                            CloseDevice(cdio);
                            }

                        DeleteStdIO(cdqcode);
                        }

                    DeleteStdIO(cdio);
                    }

                DeletePort(qcodereply);
                }

            DeletePort(cdreply);
            }
d415 2
a416 2
        EndCDTVScreen();
        }
d419 1
a419 1
    }
d426 3
a428 2
void PlayerLoop(struct CDGPrefs *cdp) {

d430 1
d434 12
a445 8
    CDGAvail = CDGBegin(cdp);

    while(1) {

	if ( haveCD ) {
	    while(event = GetEvent(&input_data)) DoKeyStroke(event);

	    while(event = GetJoyPortEvent())     DoKeyStroke(event);
d450 5
a454 3
	    if ( PlayerState.AudioDisk != 1 ) {
	        ShutDown();
		if ( PlayerState.AudioDisk == ~0 ) {
d456 33
d490 1
a490 1
	        }
d492 1
a492 1
	    UpdateGadgets();
d494 10
a503 44
	    if (!CDGPlaying) {

	        if (CDGAvail && PlayerState.PlayState >= PLS_PLAYING)
	            if ((CDGDraw(CDGF_GRAPHICS|CDGF_MIDI)) & CDGF_GRAPHICS) {

	            CDGPlaying = channel = 1;
	            CDGChannel( channel );
	            CDGClearScreen();

	            if (PlayerState.PlayState == PLS_PAUSED) CDGPause();
	            else                                     CDGPlay(0);


		    /* Because of the loss of the B-button to toggle
		     * in/out of CD+G, we'll always play CD+G
		     */
	            CDGDisplaying = 1;
	            CDGFront();

	            if (MasterF.gstate[PLGAD_FF])       CDGFastForward();
	            else if (MasterF.gstate[PLGAD_REV]) CDGRewind();
	            }
	        }

	    else CDGDraw(CDGF_GRAPHICS|CDGF_MIDI);

	    if (!CDGDisplaying) {

	        UpdateDisplay();

	        if (ScreenFront) {

	            if (!--ScreenFront) {

	                if (intdata.cintd_View) {

	                    LoadView((struct View *)intdata.cintd_View);
	                    WaitTOF();
	                    }

	                intdata.cintd_Bump = 1;
	                }
	            }
	        }
d505 3
a507 1
	else {
d509 2
a510 1
	    if ( PlayerState.AudioDisk == 1 ) {
d512 3
a514 2
		}
	    else if ( PlayerState.AudioDisk == ~0 ) {
a515 1
		}
d517 2
a518 2
        WaitTOF();
        }
d520 1
d528 12
a539 1
void DoKeyStroke(UWORD event) {
d541 3
a543 4
#if NUMBER_ENTRY
register short  up;
#endif
register UWORD  dir;
d545 9
a553 1
    if (!CDGDisplaying) {
d555 1
a555 1
	if (event & BOXMOVE) {
d557 1
a557 2
		click();
		DoBoxMove(event);
a558 23
	    }

        blank = 0;

        if ((event == IECODE_LBUTTON) || (event == (IECODE_LBUTTON+IECODE_UP_PREFIX))
            || (event == RAWKEY_RETURN) || (event == (RAWKEY_RETURN | IECODE_UP_PREFIX)))
            event = GetBoxKey(&MasterF, event);

        if (!SubmitKeys(event)) switch (event) {

            case RAWKEY_ARROWUP: dir = DIR_UP;      DoBoxMove(dir);  break;

            case RAWKEY_ARROWDN: dir = DIR_DOWN;    DoBoxMove(dir);  break;

            case RAWKEY_ARROWLT: dir = DIR_LEFT;    DoBoxMove(dir);  break;

            case RAWKEY_ARROWRT: dir = DIR_RIGHT;   DoBoxMove(dir);  break;

            case KEY_GBUTTON:

                click();
                togglegnum();
                return;
d560 1
a560 1
            case KEY_SHUFFLE:
d567 87
a653 2
                click();
                if ( PlayerState.PlayState == PLS_PAUSED ) {
d655 1
a655 107
                    SubmitKeyStroke(KeyPressed = PKS_STOP|PKSF_PRESS);
                    SubmitKeyStroke(KeyPressed = PKS_STOP|PKSF_RELEASE);
                    }

                ShuffleGrid();                                                                                      /* Call zero for not quick */

                if ( PlayerState.PlayState == PLS_STOPPED ) {

                    SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_PRESS);
                    SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_RELEASE);
                    }


                return;

            case KEY_TIMEMODE:                                                                                      /* Change time display mode. */

                GetOptions(&OptionsSet);
                OptionsSet.TimeMode = (OptionsSet.TimeMode + 1) & 0x03;
                OptionsSet.Loop = OptionsSet.Intro = OptionsSet.Subcode = -1;
                SetOptions(&OptionsSet);
                break;

            case KEY_REPEAT:                                                                                        /* A/B loop */

                GetOptions(&OptionsSet);
                OptionsSet.Loop = !OptionsSet.Loop;
                OptionsSet.TimeMode = OptionsSet.Intro = OptionsSet.Subcode = -1;
                SetOptions(&OptionsSet);
                break;

            case KEY_INTRO:                                                                                         /* Intro mode */

                GetOptions(&OptionsSet);
                OptionsSet.Intro = !OptionsSet.Intro;
                IntroFlashTicks = ~0;	/* Signifies initial */
                OptionsSet.Loop = OptionsSet.TimeMode = OptionsSet.Subcode = -1;
                SetOptions(&OptionsSet);

                LastTrack  = 0;
                IntroCount = -1;

                if (OptionsSet.Intro && PlayerState.PlayState == PLS_STOPPED) {

                    SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_PRESS);
                    SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_RELEASE);
                    }

                break;

            case RAWKEY_PREVTRAK:

                MasterF.gstate[PLGAD_REV] = 1;
                if (CDGPlaying) CDGClearScreen();
                return;

            case RAWKEY_NEXTTRAK:

                MasterF.gstate[PLGAD_FF] = 1;
                if (CDGPlaying) CDGClearScreen();
                return;

            case (RAWKEY_PREVTRAK | IECODE_UP_PREFIX):

                MasterF.gstate[PLGAD_REV] = 0;
                break;

            case (RAWKEY_NEXTTRAK | IECODE_UP_PREFIX):

                MasterF.gstate[PLGAD_FF] = 0;
                break;

            case KEY_CDG:
                if (!CDGDisplaying && CDGPlaying) {

		    CDGFlashTicks = FLASHLENGTH;
                    CDGDisplaying = 1;
                    CDGFront();
                    if (PlayerState.PlayState == PLS_PAUSED) CDGPause();

                    if (MasterF.gstate[PLGAD_FF])       CDGFastForward();
                    else if (MasterF.gstate[PLGAD_REV]) CDGRewind();
                    }

                break;

            case RAWKEY_ESC:

                if (MasterF.BoxNo >= PLGAD_1 && MasterF.BoxNo <= PLGAD_20) {

                    if (PlayList->EntryCount) ResetPlayList(1);
                    else                      ResetPlayList(0);

                    UpdatePlayTime();
                    }

                break;

            case RAWKEY_ENTER:                                                                                      /* Numeric keypad */

                if (MasterF.BoxNo >= PLGAD_1 && MasterF.BoxNo <= PLGAD_20) DoBoxMove(DIR_RIGHT);

                break;

            default:
#if NUMBER_ENTRY
                if ((up = IsNumKey(event)) >= 0) {
d657 84
a740 7
                    enternum(up);
                    break;
                    }
#endif
                return;
            }
        }
d742 12
a753 83
    else if (!SubmitKeys(event)) switch (event) {

        case RAWKEY_PREVTRAK:

            CDGRewind();
            break;

        case RAWKEY_NEXTTRAK:

            CDGFastForward();
            break;

        case (RAWKEY_PREVTRAK | IECODE_UP_PREFIX):
        case (RAWKEY_NEXTTRAK | IECODE_UP_PREFIX):

            if (PlayerState.PlayState == PLS_PAUSED) CDGPause();
            else                                     CDGPlay(0);

            break;

        case IECODE_LBUTTON:

            CDGDisplaying = 0;
            CDGBack();

            SetTrackCounter(1);
            MasterF.gstate[PLGAD_REV] = MasterF.gstate[PLGAD_FF]  = 0;
            ScreenFront = 20;

            break;

        case DIR_UP:
            if (++channel > 15) channel = 1;
            CDGChannel((channel & 0x0f));

            break;

        case DIR_DOWN:
            if (channel-- == 0) channel = 15;
            CDGChannel((channel & 0x0f));

            break;

        case (DIR_UP | IECODE_UP_PREFIX):
        case (DIR_DOWN | IECODE_UP_PREFIX):
            if ((KeyPressed & PKSF_STROKEDIR) == PKSF_PRESS)
                SubmitKeyStroke(KeyPressed = ((KeyPressed & PKSF_KEY) | PKSF_RELEASE));
            break;
        }

    if (!(event & IECODE_UP_PREFIX)) {

        click();
        }
    }




int SubmitKeys(UWORD event) {

    switch(event) {

        case KEY_PAUSE:                                                                                         /* Pause */

            if (PlayerState.PlayState > PLS_SELECTED) {

                SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_PRESS);
                SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_RELEASE);
                }

            return(1);

        case KEY_PLAY:                                                                                          /* Play */

            SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_PRESS);
            SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_RELEASE);
            return(1);

        case KEY_STOP:                                                                                          /*  Stop  */

            SubmitKeyStroke(KeyPressed = PKS_STOP|PKSF_PRESS);
            SubmitKeyStroke(KeyPressed = PKS_STOP|PKSF_RELEASE);
d755 1
a755 2
            if ( ShuffleMode )
            {
d757 1
d761 1
a761 1
            return(1);
d763 1
a763 1
        case KEY_BACK:                                                                                          /* Back track */
d765 25
a789 26
            MasterF.gstate[PLGAD_REV]  = 1;
            SubmitKeyStroke(KeyPressed = PKS_REVERSE|PKSF_PRESS);
            return(1);

        case KEY_FWD:                                                                                           /* Next track */

            MasterF.gstate[PLGAD_FF]   = 1;
            SubmitKeyStroke(KeyPressed = PKS_FORWARD|PKSF_PRESS);
            return(1);

        case (KEY_BACK|IECODE_UP_PREFIX):

            MasterF.gstate[PLGAD_REV]  = 0;
            SubmitKeyStroke(KeyPressed = PKS_REVERSE|PKSF_RELEASE);
            AbortQCode();
            return(1);

        case (KEY_FWD|IECODE_UP_PREFIX):

            MasterF.gstate[PLGAD_FF]   = 0;
            SubmitKeyStroke(KeyPressed = PKS_FORWARD|PKSF_RELEASE);
            AbortQCode();
            return(1);

        default: return(0);
        }
d791 1
d796 3
a798 2
void UpdateGadgets() {

d801 11
a811 1
    if (PlayerState.PlayState >= PLS_PLAYING) {
d813 4
a816 1
        if (toutstanding) {
d818 5
a822 18
            if (CheckIO(TimeReq)) {

                if (!qoutstanding) {

                    SendIO(cdqcode);
                    qoutstanding = 1;
                    }

                if (CheckIO(cdqcode)) {

                    WaitIO(cdqcode);
                    qoutstanding = 0;

                    if (!cdqcode->io_Error) {

                        copyqcode = qcode;
                        qvalid = 1;
                        }
d824 1
a824 1
                    WaitIO(TimeReq);
d827 1
a827 1
                    if (TimeReq->tr_node.io_Error) kprintf("Error %d\n", TimeReq->tr_node.io_Error);
d830 63
a892 60
                    TimeReq->tr_time.tv_secs    = 1;
                    TimeReq->tr_time.tv_micro   = 0;
                    SendIO(TimeReq);
                    }
                }
            }
        }

    if (CDGPlaying) {

        if (CDGDisplaying && LastPlayMode == PlayerState.PlayMode && LastPlayState == PlayerState.PlayState) return;

        if (LastPlayState != PlayerState.PlayState) switch (PlayerState.PlayState) {

            case PLS_STOPPED:

                if (CDGDisplaying) ScreenFront = 20;

                CDGStop();
                CDGBack();
                CDGPlaying = CDGDisplaying = 0;
                MasterF.gstate[PLGAD_REV] = MasterF.gstate[PLGAD_FF]  = 0;
                break;

            case PLS_PLAYING: CDGPlay(1); break;
            case PLS_PAUSED:  CDGPause(); break;
            }
        }

    switch (PlayerState.PlayState) {

        case PLS_STOPPED:

            AbortQCode();
            break;

        case PLS_PLAYING:
        case PLS_PAUSED:

            if (!toutstanding) {

                TimeReq->tr_time.tv_secs    = 1;
                TimeReq->tr_time.tv_micro   = 0;
                SendIO(TimeReq);
                toutstanding = 1;
                }

            break;
        }

    if (PlayerState.PlayState == PLS_STOPPED) MasterF.gstate[PLGAD_TTRACK] = PlayerState.Tracks;

    else {

        MasterF.gstate[PLGAD_TTRACK] = PlayerState.Track;

        if (PlayerState.Track != LastTrack) {

            if (PlayerState.PlayMode == PLM_SKIPREV) --IntroCount;
            else                                     IntroCount++;
d894 1
a894 1
            LastTrack = PlayerState.Track;
d905 2
a906 1
	    if ( IntroFlashTicks == ~0 ) {
d908 3
a910 2
		}
	    else {
a911 24
		}
            }
        }

    if (PlayerState.AudioDisk == 1) {

        MasterF.gstate[PLGAD_MIN]    = PlayerState.Minute;
        MasterF.gstate[PLGAD_SEC]    = PlayerState.Second;
        }

    if (PlayerState.PlayMode == PLM_NORMAL) {

        MasterF.gstate[PLGAD_STOP]  =  (PlayerState.PlayState == PLS_STOPPED)
                                    || (PlayerState.PlayState == PLS_SELECTED)
                                    || (PlayerState.PlayState == PLS_NUMENTRY);

	if ( PlayerState.PlayState == PLS_PAUSED ) {
	    MasterF.gstate[PLGAD_PLAY] = 1;
	    }
	else if ( PlayerState.PlayState == PLS_PLAYING ) {
	    MasterF.gstate[PLGAD_PLAY] = 2;
	    }
	else {
	    MasterF.gstate[PLGAD_PLAY] = 0;
d913 2
a914 1
        }
d916 11
a926 3
#if NUMBER_ENTRY
    if (NumericPadEnabled && PlayList->EntryCount == LastEntryCount+1) MasterF.D0 = 80;
#endif
d928 13
a940 1
    LastEntryCount = PlayList->EntryCount;
d944 1
a944 1
    MasterF.gstate[PLGAD_TIME]   = PlayerOptions.TimeMode;
d948 1
a948 1
    MasterF.gstate[PLGAD_NEG]    = ( PlayerOptions.TimeMode & 1 );
d950 1
a950 1
    MasterF.gstate[PLGAD_REPEAT] = PlayerOptions.Loop;
d955 1
a955 1
	    MasterF.gstate[PLGAD_INTRO] = ( 0x03 & IntroCount ) + 1;
d960 1
a960 1
	    MasterF.gstate[PLGAD_INTRO] = 5;
d965 1
a965 11
	MasterF.gstate[PLGAD_INTRO] = 0;
    }

    if ( CDGFlashTicks )
    {
	MasterF.gstate[PLGAD_CDG] = 1;
	CDGFlashTicks--;
    }
    else
    {
	MasterF.gstate[PLGAD_CDG] = 0;
d968 1
a968 1
    if (PlayerState.LastModify) MasterF.gstate[PLGAD_SHUFF] = 0;
a975 6
    }

int Nobody( void )
{
	int hello = 5;
	return( hello );
a978 2


d981 6
a986 1
void SetupPlayer() {
a987 3
extern UWORD     IntroData[], *DoAnimation();
register UWORD  *anim;

d996 5
a1000 5
    MasterF.BoxNo                = PLGAD_PLAY;
    MasterF.gstate[PLGAD_STOP]   = 1;
    MasterF.gstate[PLGAD_TIME]   = 0;
    MasterF.gstate[PLGAD_REPEAT] = 0;
    MasterF.gstate[PLGAD_SHUFF]  = 0;
d1003 2
a1009 4
#if NUMBER_ENTRY
    PlayerNumPad(1);
#endif

d1019 4
a1022 1
    if (PlayerState.PlayMode == PLM_NORMAL) {
d1024 13
a1036 13
        MasterF.gstate[PLGAD_STOP]  =  (PlayerState.PlayState == PLS_STOPPED)
                                    || (PlayerState.PlayState == PLS_SELECTED);

	if ( PlayerState.PlayState == PLS_PAUSED ) {
	    MasterF.gstate[PLGAD_PLAY] = 1;
	    }
	else if ( PlayerState.PlayState == PLS_PLAYING ) {
	    MasterF.gstate[PLGAD_PLAY] = 2;
	    }
	else {
	    MasterF.gstate[PLGAD_PLAY] = 0;
	    }
        }
d1040 3
a1042 3
    MasterF.gstate[PLGAD_TIME]   = PlayerOptions.TimeMode;
    MasterF.gstate[PLGAD_REPEAT] = PlayerOptions.Loop;
    MasterF.gstate[PLGAD_INTRO]  = PlayerOptions.Intro * ((0x03 & IntroCount) + 1);
d1049 10
a1058 1
    FadeTo(0);
a1059 1
    anim = IntroData; while (anim) anim = DoAnimation(anim, NULL);
d1061 2
a1062 2

    ClearEvent(&input_data);                                                                                        /* Remove any queued events. */
a1063 2
    disableclick(1);

d1075 5
a1079 5
    else {

        ShutDown();
        DoReset();
        }
d1082 2
a1083 1
    }
d1088 4
a1091 1
void ShutDown() {
d1093 1
a1093 2
register UWORD *anim;

d1096 1
a1096 1
    MasterF.BoxNo = -1;
d1098 9
a1106 1
    while ((MasterF.gstate[PLGAD_COUNTER] != 0) || anim) {
d1108 9
a1116 3
        if (MasterF.gstate[PLGAD_COUNTER] != 0) MasterF.gstate[PLGAD_COUNTER]--;

        if (anim) anim = DoAnimation(anim);
d1118 3
a1120 3
        else UpdateDisplay();
        }

d1123 1
a1123 1
    }
d1129 3
a1131 2
void DoReset() {

d1134 1
a1134 6
    }


/*************************** Make Keyclick Sound ***************************/

void click() {
a1135 16
    if (keyclick && (PlayerState.PlayState < PLS_PLAYING)) {

        disableclick(0);
        KeyClickCommand(CLKCMD_CLICK, 0, 0, 0, 0, 0);
        disableclick(1);
        }
    }


/******************* Disable/Enable Automatic Keyclick *********************/

void disableclick(int disable) {

    if (keyclick) KeyClickCommand(CLKCMD_DISABLE, 0, disable, 0, 0, 0);
    }

d1140 3
a1142 2
UBYTE inlist(UBYTE track) {

d1146 1
a1146 1
        if ((PlayList->Entry[i] & PLEF_TRACK) == track) return(PlayList->Entry[i]);
d1149 1
a1149 1
    }
d1155 16
a1170 3
void AbortQCode(void) {

    if (qoutstanding) {
a1171 12
        AbortIO(cdqcode);
        WaitIO(cdqcode);
        qoutstanding = 0;
        }

    if (toutstanding) {

        AbortIO(TimeReq);
        WaitIO(TimeReq);
        toutstanding = 0;
        }

d1173 1
a1173 1
    }
d1180 20
a1199 2
#define REPEAT_ONGOING	15
#define REPEAT_INITIAL	(3*(REPEAT_ONGOING))
d1206 2
d1209 1
a1213 1

d1227 2
a1228 1
UWORD GetJoyPortEvent(void)
d1230 1
a1230 2

ULONG joybits0, joybits1, joybits = 0;
d1238 6
d1247 1
a1247 1
	joybits  = joybits0;
d1256 5
d1319 52
@


1.12
log
@Modified to handle game controller keys more effectively.
@
text
@d41 3
a43 4
#include "cdgs:src/game/gamebase.h"
#include "cdgs:src/game/readjoyport.h"
#include "cdgs:src/game/game_pragmas.h"
#include "cdgs:src/game/game_protos.h"
d61 1
d63 1
d101 7
a107 4
    NULL, playerstrip, NULL, scrdata,
    352, 296, 6,
    14, 54,
    NULL
d112 2
d115 2
d136 4
a139 1
int    LastEntryCount = -1, NumericPadEnabled = 1;
a148 11
UWORD  JoyPortEvent = 0, JoyPortBits = 0;
UWORD  JoyPortEvents[] = {

    KEY_PAUSE,
    KEY_BACK,
    KEY_FWD,
    KEY_PLAY,
    KEY_STOP
    };


d153 1
a153 1
    1, PLGAD_DISK,38, PLGAD_MIN, 100, PLGAD_SEC, 100, 0xffff,
d190 1
a190 1
    1, PLGAD_DISK, 1, PLGAD_COUNTER, 0,         0xffff,        
d198 2
a199 2
    0,PLGAD_STOP,0,PLGAD_REV,0,PLGAD_PLAY,0,PLGAD_FF,0,PLGAD_PAUSE,0,
      PLGAD_SHUFF,0,PLGAD_GCLR,0,PLGAD_CDG,0,0xffff,
d242 1
a242 1
    1, PLGAD_DISK,17, PLGAD_COUNTER,0x8000+20, 0xffff, 
d263 1
a263 1
    1, PLGAD_DISK,38, 0xffff,        
d270 1
a270 1
*   NAME   
d315 1
a315 1
    
a342 1
                                    InstallJoyMouse();
a379 1
                                    RemoveJoyMouse();
d425 2
a426 46
        while(event = GetEvent(&input_data)) DoKeyStroke(event); 

        while(event = GetJoyPortEvent())     DoKeyStroke(event);

        if (!PlayerState.AudioDisk) {

            ShutDown();
            DoReset();
            }

        UpdateGadgets();

        if (!CDGPlaying) {

            if (CDGAvail && PlayerState.PlayState >= PLS_PLAYING)
                if ((CDGDraw(CDGF_GRAPHICS|CDGF_MIDI)) & CDGF_GRAPHICS) {

                CDGPlaying = channel = 1;
                CDGClearScreen();

                if (PlayerState.PlayState == PLS_PAUSED) CDGPause();
                else                                     CDGPlay(0);

                if (!MasterF.gstate[PLGAD_CDG]) {

                    CDGDisplaying = 1;

                    CDGFront();

                    if (MasterF.gstate[PLGAD_FF])       CDGFastForward();
                    else if (MasterF.gstate[PLGAD_REV]) CDGRewind();
                    }

                else CDGDisplaying = 0;
                }
            }

        else CDGDraw(CDGF_GRAPHICS|CDGF_MIDI);

        if (!CDGDisplaying) {

            UpdateDisplay();

            if (ScreenFront) {

                if (!--ScreenFront) {
d428 1
a428 1
                    if (intdata.cintd_View) {
d430 66
a495 9
                        LoadView((struct View *)intdata.cintd_View);
                        WaitTOF();
                        }

                    intdata.cintd_Bump = 1;
                    }
                }
            }

d508 1
d510 1
d513 1
a513 1
    if (event & BOXMOVE) {
d515 1
a515 4
        click();
        DoBoxMove(event);
        return;
        }
d517 4
a520 1
    if (!CDGDisplaying) {
d531 1
a531 1
    
d533 1
a533 1
    
d535 1
a535 1
    
d537 1
a537 1
    
d544 1
a544 1
            case KEY_GCLR:
d546 5
d552 5
a556 4
                DoGCLRGad();
                return;
    
            case KEY_SHUFFLE:
a557 1
                click();
d559 8
d568 1
a568 1
    
d576 1
a576 1
    
d589 1
d622 1
a622 1
    
d627 1
a627 7

                if (MasterF.gstate[PLGAD_CDG] = (MasterF.gstate[PLGAD_CDG] ? 0:1)) CDGDisplaying = 0;
                break;
    
            case IECODE_RBUTTON:

                if (!MasterF.gstate[PLGAD_CDG] && CDGPlaying) {
d629 1
d639 1
a639 1
    
d644 2
a645 2
                    if (PlayList->EntryCount) ResetPlayList(0, 1);
                    else                      ResetPlayList(0, 0);
d657 1
a657 1
    
d659 1
a659 1

d665 1
a665 1

d690 1
a690 1
        case IECODE_RBUTTON:
a699 2
    
        case IECODE_LBUTTON:
d701 2
a703 1
            if (++channel > 15) channel = 1;
d707 5
a711 1
        case (IECODE_LBUTTON | IECODE_UP_PREFIX):
d713 2
a716 1

d725 1
a725 1
    
d753 7
d824 1
d826 1
d878 1
a878 1
    if (PlayerState.PlayState == PLS_STOPPED) MasterF.gstate[PLGAD_TTRACK] = 100;
d890 16
d909 1
a909 1
    if (PlayerState.AudioDisk) {
d921 9
a929 4
        MasterF.gstate[PLGAD_PLAY]  =  (PlayerState.PlayState == PLS_PLAYING)
                                    || (PlayerState.PlayState == PLS_PAUSED);

        MasterF.gstate[PLGAD_PAUSE] =   PlayerState.PlayState == PLS_PAUSED;
d932 1
d934 1
d941 5
d947 26
a972 1
    MasterF.gstate[PLGAD_INTRO]  = PlayerOptions.Intro * ((0x03 & IntroCount) + 1);
d978 1
a978 1
    if (PlayerState.AudioDisk) DisplayGrid();
d984 5
d992 1
a998 1
int              i, j, k, l;
d1013 1
d1020 1
d1022 1
d1038 9
a1046 4
        MasterF.gstate[PLGAD_PLAY]  =  (PlayerState.PlayState == PLS_PLAYING)
                                    || (PlayerState.PlayState == PLS_PAUSED);

        MasterF.gstate[PLGAD_PAUSE] =   PlayerState.PlayState == PLS_PAUSED;
a1057 21
    j = 1; k = l = 0;

    if (PlayList->EntryCount == TOC[0].Summary.LastTrack && !PlayerState.LastModify) {

        for (i=0; i!=PlayList->EntryCount; i++) {

            if (!inlist(i+1))                             j = 0;                                                    /* all list entries must be present */
            if ((PlayList->Entry[i] & PLEF_TRACK) != i+1) k = 1;                                                    /* at least 1 entry must be out of order */
            if (PlayList->Entry[i] & PLEF_ENABLE)         l = 1;                                                    /* at least 1 entry must be enabled */
            }
        }

    if (j && k && l) {

        MasterF.gstate[PLGAD_SHUFF] = 1;

        UndoPlayList->EntryCount = PlayList->EntryCount;

        for (i=0; i!=PlayList->EntryCount; i++) UndoPlayList->Entry[i] = inlist(i+1);
        }

d1063 1
d1072 1
a1072 1
    cdio->io_Command  = CD_TOCLSN;                                                                                  /* Gimme summary. */
d1095 2
a1096 1
    
d1185 3
a1187 32
UWORD GetJoyPortEvent(void) {

ULONG TempJP0, TempJP1, Temp = 0;
UWORD i, j, k;

    TempJP0 = ReadJoyPort(0);
    TempJP1 = ReadJoyPort(1);

    if ((TempJP0 & JP_TYPE_MASK) == JP_TYPE_GAMECTLR) Temp  = TempJP0;
    if ((TempJP1 & JP_TYPE_MASK) == JP_TYPE_GAMECTLR) Temp |= TempJP1;

    Temp &= (JPF_BTN3|JPF_BTN4|JPF_BTN5|JPF_BTN6|JPF_BTN7);
    Temp >>= JPB_BTN7;

    for (i=j=0,k=Temp; i!=5; i++,k>>=1) if (k & 1) j++;

    if (j <= 1) {

        if (Temp != JoyPortBits) {

            if (JoyPortEvent) {

                i = JoyPortEvent;
                JoyPortEvent = 0;
                JoyPortBits  = Temp;

                return(i | IECODE_UP_PREFIX);
                }

            if (Temp) {

                for (i=0,k=Temp; (i!=5) && !(k&1); i++,k>>=1);
d1189 108
a1296 9
                JoyPortBits  = Temp;
                JoyPortEvent = JoyPortEvents[i];

                return(JoyPortEvent);
                }
            }
        }

    return(0);
d1298 2
@


1.11
log
@removed debugging.
@
text
@a140 1
    0,
d356 1
a357 2
/*                                                      if (CDG_Open(&cdp)) {*/

d361 1
a361 1
/*                                                              CDG_Close();*/
d364 1
a364 1
/*                                                          }*/
d381 2
d422 1
a422 1
/*
d424 1
a424 1
*/
d438 1
a438 1
/*
a464 1
*/
a469 1
            /*
a482 1
            */
d515 1
a515 37
        switch (event) {

            case KEY_PAUSE:                                                                                         /* Pause */

                if (PlayerState.PlayState) {

                    SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_PRESS);
                    SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_RELEASE);
                    }

                return;

            case KEY_PLAY:                                                                                          /* Play */

                SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_PRESS);
                SubmitKeyStroke(KeyPressed = PKS_PLAYPAUSE|PKSF_RELEASE);
                return;

            case KEY_STOP:                                                                                          /*  Stop  */

                SubmitKeyStroke(KeyPressed = PKS_STOP|PKSF_PRESS);
                SubmitKeyStroke(KeyPressed = PKS_STOP|PKSF_RELEASE);
                return;

            case KEY_BACK:                                                                                          /* Back track */

                MasterF.gstate[PLGAD_REV] = 1;
                SubmitKeyStroke(KeyPressed = PKS_REVERSE|PKSF_PRESS);
                return;

            case KEY_FWD:                                                                                           /* Next track */

                MasterF.gstate[PLGAD_FF] = 1;
                SubmitKeyStroke(KeyPressed = PKS_FORWARD|PKSF_PRESS);
                return;

            case (KEY_BACK|IECODE_UP_PREFIX):
a516 12
                MasterF.gstate[PLGAD_REV] = 0;
                SubmitKeyStroke(KeyPressed = PKS_REVERSE|PKSF_RELEASE);
                AbortQCode();
                return;

            case (KEY_FWD|IECODE_UP_PREFIX):

                MasterF.gstate[PLGAD_FF] = 0;
                SubmitKeyStroke(KeyPressed = PKS_FORWARD|PKSF_RELEASE);
                AbortQCode();
                return;

d648 1
a648 1
    else switch (event) {
d703 57
d1046 6
a1051 3
    disableclick(0);
    if (keyclick && PlayerState.PlayState < PLS_PLAYING) KeyClickCommand(CLKCMD_CLICK, 0, 0, 0, 0, 0);
    disableclick(1);
d1115 1
a1115 1
    Temp >>= JPB_RSVDBTN;
d1117 1
a1117 1
    for (i=j=0,k=Temp; i!=6; i++,k>>=1) if (k & 1) j++;
d1134 1
a1134 1
                for (i=0,k=Temp; (i!=6) && !(k&1); i++,k>>=1);
@


1.10
log
@player now can use game controller buttons.
@
text
@d429 1
a429 1
        while(event = GetJoyPortEvent()) {
a430 4
            kprintf("Event = %04lx\n", event);
            DoKeyStroke(event);
            }

a1125 2

                kprintf("i=%ld\n", i);
@


1.9
log
@Exec ColdReboot() function replaces REBOOT().
@
text
@d41 5
d92 1
d124 1
d138 11
d355 2
a356 1
/*                                                  if (CDG_Open(&cdp)) {*/
d358 1
a358 1
                                                        if (UnpackSprites(&cdp)) {
d360 7
a366 3
                                                            PlayerLoop(&cdp);
/*                                                          CDG_Close();*/
                                                            }
d368 2
a369 1
/*                                                        }*/
d429 6
d1095 48
@


1.8
log
@commented out the cd+g stuff.
Did some mods for q-code positioning.
@
text
@a48 1
extern void             REBOOT(void);
d1006 1
a1006 1
    REBOOT();
@


1.7
log
@Revised to work with cd.device.
Removed CD+G functions for now.
@
text
@d87 1
d107 2
a108 2
int                   qvalid, qoutstanding;
struct MsgPort       *cdreply, *qcodereply;
d110 1
a110 1
struct timerequest   *timer;
d316 1
a316 1
                            qoutstanding = qvalid = 0;
d329 1
a329 1
                                    if (PlayerBase = OpenLibrary("player.library", NULL)) {
d331 2
d334 13
a346 1
/*                                        if (CDG_Open(&cdp)) {*/
d348 2
a349 1
                                            if (UnpackSprites(&cdp)) {
d351 1
a351 2
                                                PlayerLoop(&cdp);
/*                                                CDG_Close();*/
d354 2
a355 1
/*                                            }*/
d357 1
a357 1
                                        CloseLibrary(PlayerBase);
d366 1
a366 1
                            if (qoutstanding) {
a367 4
                                AbortIO(cdqcode);
                                WaitIO(cdqcode);
                                }

d533 1
d540 1
d737 22
a758 1
        if (qoutstanding) {
d760 1
a760 1
            if (CheckIO(cdqcode)) {
d762 3
a764 6
                WaitIO(cdqcode);

                if (!cdqcode->io_Error) {

                    copyqcode = qcode;
                    qvalid = 1;
a765 2

                SendIO(cdqcode);
d795 1
a795 7
            if (qoutstanding) {

                AbortIO(cdqcode);
                WaitIO(cdqcode);
                qoutstanding = qvalid = 0;
                }

d801 1
a801 1
            if (!qoutstanding) {
d803 4
a806 2
                SendIO(cdqcode);
                qoutstanding = 1;
d900 4
d1040 23
@


1.6
log
@Now uses player.library instead of player.resource.
@
text
@d13 1
a13 1
#include <cdtv:include/cdtv/cdtv.h>
a56 1
extern                  handlescrsave(struct CycleIntInfo *ci, int blank, struct PlayerPrefsBase *PlayerPrefsBase);
d104 5
a108 4
struct CDTOC         *TOC;
struct CDSubQ         subq;
struct MsgPort       *cdreply, *subqreply;
struct IOStdReq      *cdio, *cdsubq;
d303 1
a303 1
            if (subqreply = (struct MsgPort *)CreatePort(0, 0)) {
d307 1
a307 1
                    if (cdsubq = (struct IOStdReq *)CreateStdIO(subqreply)) {
d309 1
a309 1
                        if (!OpenDevice("cdtv.device", 0, cdio, 0)) {
d311 1
a311 1
                            CopyMem(cdio, cdsubq, sizeof(*cdio));
d314 2
a315 1
                            cdsubq->io_Message.mn_ReplyPort = subqreply;
d321 1
a321 1
                            if (TOC = AllocMem(TOCSIZE, MEMF_PUBLIC)) {
a325 1
                                    InstallScreenSaver();
a329 1
                                        if (CDG_Open(&cdp)) {
d331 2
d336 1
a336 1
                                                CDG_Close();
d338 2
a339 1
                                            }
d347 7
a353 1
                                FreeMem(TOC, TOCSIZE);
a355 2
                            AbortIO(cdsubq);
                            SafeWaitIO(cdsubq);
d359 1
a359 1
                        DeleteStdIO(cdsubq);
d365 1
a365 1
                DeletePort(subqreply);
d387 1
a387 1

d389 1
a389 1

a395 2
            ScreenSaverCommand(SCRSAV_UNSAVE);
            blank = handlescrsave(&intdata, 0, PlayerPrefsBase);
a399 2
        SafeDoIO(cdsubq);

d401 1
a401 1

d404 1
a404 1
            if (CDGAvail && PlayerState.PlayState >= PLS_PLAYING && subq_valid())
d428 1
d432 1
a432 1
            if (!(blank = handlescrsave(&intdata, blank, PlayerPrefsBase))) {
d434 2
a435 1
                UpdateDisplay();
d437 1
a437 3
                if (ScreenFront) {

                    if (!--ScreenFront) {
d439 1
a439 1
                        if (intdata.cintd_View) {
d441 3
a443 3
                            LoadView((struct View *)intdata.cintd_View);
                            WaitTOF();
                            }
d445 1
a445 2
                        intdata.cintd_Bump = 1;
                        }
d448 1
a450 2
        else ScreenSaverCommand(SCRSAV_UNSAVE);

d475 1
a475 1
        blank = 0; ScreenSaverCommand(SCRSAV_UNSAVE);
d684 1
a716 1

d721 19
d747 1
a753 1

d756 2
a757 2
            case PLS_PLAYING:   CDGPlay(1); break;
            case PLS_PAUSED:    CDGPause(); break;
d761 25
d864 1
a864 1
    cdio->io_Command = CD_MUTE;                                                                                     /* Turn on the speakers; full volume, right now(sorta). */
d866 2
a867 2
    cdio->io_Length  = 1;
    SafeDoIO(cdio);
d871 2
a872 2
    cdsubq->io_Command  = CD_SUBQMSF;                                                                               /* Initialize the SubQ packet. */
    cdsubq->io_Data     = (APTR)&subq;
d898 1
a898 1
    if (PlayList->EntryCount == TOC[0].LastTrack && !PlayerState.LastModify) {
a916 3
    currsec = ((TOC[PlayerState.Track].Position.Raw >> 16) & 0xff) * 60
            + ((TOC[PlayerState.Track].Position.Raw >> 8) & 0xff);

d921 1
a921 1
    blank = handlescrsave(&intdata, -1, PlayerPrefsBase);
a922 2
    anim = IntroData; while (anim) anim = DoAnimation(anim, NULL);
    
d930 1
a930 1
    cdio->io_Command  = CD_TOCMSF;                                                                                  /* Gimme summary. */
d934 1
a934 1
    SafeDoIO(cdio);
d943 2
@


1.5
log
@ScreenSaver now disabled when disk is ejected.
@
text
@a37 1
#include "internal/cdtv_cr_hw.h"
d41 3
a43 3
#include "cdtv:include/internal/playerresource.h"
#include "cdtv:include/internal/player_protos.h"
#include "cdtv:include/internal/player_pragmas.h"
d328 1
a328 1
                                    if (PlayerBase = OpenResource("player.resource")) {
d330 1
a330 1
                                        if (OwnPlayer()) {
d332 1
a332 3
                                            if (CDG_Open(&cdp)) {

                                                if (UnpackSprites(&cdp)) {
d334 2
a335 3
                                                    PlayerLoop(&cdp);
                                                    CDG_Close();
                                                    }
d338 2
d507 1
d513 1
d519 1
d525 1
@


1.4
log
@Does not allow highlighted box to change when the A button is being held down.
@
text
@d392 2
d922 1
a922 1
    
@


1.3
log
@Significantly cleaned up code and comments.
@
text
@d13 1
a13 1
#include <cr2:dev/cdtv.h>
d42 3
a44 3
#include "cr2:playerresource/playerresource.h"
#include "cr2:playerresource/player_protos.h"
#include "cr2:playerresource/player_pragmas.h"
d466 1
a466 1
    if ((event & BOXMOVE) && !(input_data.CurrButtonPos & CURRBUTTONA)) {
d470 1
d487 2
a488 2
                    SubmitKeyStroke(PKS_PLAYPAUSE|PKSF_PRESS);
                    SubmitKeyStroke(PKS_PLAYPAUSE|PKSF_RELEASE);
d495 2
a496 2
                SubmitKeyStroke(PKS_PLAYPAUSE|PKSF_PRESS);
                SubmitKeyStroke(PKS_PLAYPAUSE|PKSF_RELEASE);
d501 2
a502 2
                SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
                SubmitKeyStroke(PKS_STOP|PKSF_RELEASE);
d579 2
a580 2
                    SubmitKeyStroke(PKS_PLAYPAUSE|PKSF_PRESS);
                    SubmitKeyStroke(PKS_PLAYPAUSE|PKSF_RELEASE);
d620 1
a620 1
                    if (MasterF.gstate[PLGAD_FF]) CDGFastForward();
d695 3
a697 1
            if ((KeyPressed & PKSF_STROKEDIR) == PKSF_PRESS) SubmitKeyStroke((KeyPressed & PKSF_KEY) | PKSF_RELEASE);
@


1.2
log
@Cleaned up code.  Put headers on functions.
@
text
@a93 13
struct changedata {

    struct Task *me;
    ULONG        sig;
    } changeintrdata;

struct Interrupt changeintrnode = {

    { NULL, NULL, NT_INTERRUPT, 0, "Audio Panel CD Eject" },
    (APTR) &changeintrdata,
    (VOID (*)()) changeintr
    };

d109 1
a109 1
struct IOStdReq      *cdio, *cdsubq, *cdintr;
d310 3
a312 1
                        if (cdintr = (struct IOStdReq *)CreateStdIO(cdreply)) {
d314 20
a333 1
                            if (!OpenDevice("cdtv.device", 0, cdio, 0)) {
d335 1
a335 35
                                CopyMem(cdio, cdsubq, sizeof(*cdio));
                                CopyMem(cdio, cdintr, sizeof(*cdio));

                                cdio->io_Message.mn_ReplyPort   = cdreply;
                                cdintr->io_Message.mn_ReplyPort = cdreply;
                                cdsubq->io_Message.mn_ReplyPort = subqreply;

                                if ((changesigbit = AllocSignal(-1)) != -1) {

                                    changeintrdata.me   = FindTask(NULL);
                                    changeintrdata.sig  = 1L<<changesigbit;
                                    cdintr->io_Command  = CD_ADDCHANGEINT;
                                    cdintr->io_Length   = sizeof(changeintrnode);
                                    cdintr->io_Data     = (APTR)&changeintrnode;
                                    SendIO(cdintr);

                                    FillCDTVPrefs(&prefs);

                                    keyclick = (prefs.Flags & CDTVPF_KEYCLICK) != 0;

                                    if (TOC = AllocMem(TOCSIZE, MEMF_PUBLIC)) {

                                        if (UndoPlayList = AllocMem(sizeof(struct PlayList), MEMF_PUBLIC)) {

                                            InstallKeyClick();
                                            InstallScreenSaver();
                                            InstallJoyMouse();

                                            if (PlayerBase = OpenResource("player.resource")) {

                                                if (OwnPlayer()) {

                                                    if (CDG_Open(&cdp)) {

                                                        if (UnpackSprites(&cdp)) {
d337 2
a338 4
                                                            PlayerLoop(&cdp);
                                                            CDG_Close();
                                                            }
                                                        }
a341 2

                                        FreeMem(TOC, TOCSIZE);
d344 1
a344 10
                                    AbortIO(cdsubq);
                                    SafeWaitIO(cdsubq);

                                    cdio->io_Command = CD_REMCHANGEINT;
                                    cdio->io_Length  = sizeof(changeintrnode);
                                    cdio->io_Data    = (APTR)&changeintrnode;
                                    SafeDoIO(cdio);
                                    SafeWaitIO(cdintr);

                                    FreeSignal(changesigbit);
d347 1
a347 1
                                CloseDevice(cdio);
d350 3
a352 1
                            DeleteStdIO(cdintr);
a379 2
register ULONG      SigEvent;
ULONG               sigchg;
a385 2
    sigchg = 1L << changesigbit;

a387 5
        Forbid();
        SigEvent = SetSignal(0, 0);
        SetSignal(0, SigEvent);
        Permit();

d390 1
a390 1
        if (SigEvent & sigchg) {
d397 1
d474 2
d750 5
a754 2
    MasterF.gstate[PLGAD_MIN]    = PlayerState.Minute;
    MasterF.gstate[PLGAD_SEC]    = PlayerState.Second;
a780 1
    DisplayGrid();
d782 2
a800 8
    cdio->io_Command  = CD_TOCMSF;                                                                                  /* Gimme summary. */
    cdio->io_Offset   = 0;
    cdio->io_Length   = 100;
    cdio->io_Data     = (APTR)TOC;
    SafeDoIO(cdio);

    InitTrackCounter();

d880 17
a960 9
    return(0);
    }


/********************* Disk Change Interrupt Server ************************/

LONG __asm changeintr(register __a1 struct changedata *cd) {

    Signal(cd->me, cd->sig);
@


1.1
log
@Initial revision
@
text
@a1 1
/* #define dcat 1 */
d48 1
a48 1
/* ------------------ ROM GETS RID OF ERROR MESSAGE ----------------- */
d50 11
d62 1
a62 1
#define DIE( str )  goto errxit
d64 8
d73 21
a99 69



BOOL CDGBegin();
VOID CDGEnd();
VOID CDGChannel(ULONG);
void CDGDiskRemoved(void);

void SetPanelMode(int newmode);
void SetPanelCounter(int newmin,int newsec);
void notupkey(void);
void SetPanelTrack(int track);

LONG __asm DoPlayer(register __a6 struct PlayerPrefsBase * ppb);
void dokey(ULONG sevent);
void docdgkey(ULONG sevent);
void click(void);
void disableclick(int);
void stabilize(void);
void updatestat(void);
int  checklimits(void);
void showuserdata(void);
int  computetrackpos(ULONG diskpos, ULONG *trackpos, UBYTE *track, UBYTE *index);
LONG computeplaytime(int, LONG);
void setwaits(int track);
void handlediskchange(void);
void initdisk(void);
int  openstuff(void);
void closestuff(void);
void diemsg(char *str);
void abortwait(struct IOStdReq *ior);
LONG __asm changeintr(register __a1 struct changedata * cd);
void kprintMSF(LONG);


extern void     REBOOT(void);

extern LONG __asm   addMSF(register __d0 LONG, register __d1 LONG);
extern LONG __asm   subMSF(register __d0 LONG, register __d1 LONG);
extern int __stdargs    kprintf(char *, ...);
extern int __stdargs    sprintf(char *, char *, ...);
extern int __stdargs    kputs(char *);
extern void __stdargs   kputchar(char);


extern struct CycleIntInfo  intdata;
extern UWORD volatile       __far vhposr;   /*  Custom chip register.  */
extern char         __far TimerDeviceName[];

extern VOID __stdargs EndCDTVScreen(VOID);
extern VOID InitVarBase(register struct PlayerPrefsBase *ppb);
extern StartPPScreen(struct GadDir *gl, struct BuildBG_Info *bg, UBYTE *buttondata, UBYTE initfade);

extern handlescrsave(struct CycleIntInfo *ci, int blank, struct PlayerPrefsBase *PlayerPrefsBase);

extern void SetNumPad(void);
extern void PlayerNumPad(int);

extern UWORD *Gcptr;
extern UWORD  **Gsptr;
extern int Gi;

void Endgetsprites( struct CDGPrefs *cdgp);


extern ULONG currsec;

/* global data */

a106 28

struct CDTOC        *playlist, single;
struct CDSubQ        subq, curstat;
struct MsgPort      *cdreply, *subqreply;
struct IOStdReq     *cdio, *cdsubq, *cdintr;
struct timerequest  *timer;

LONG    scanval = TOMSF (0, 2, 37);
LONG    lowlim, highlim;
LONG    apos, bpos;                                                 /* For A/B loop          */
short   aidx, bidx;
short   changesigbit = -1;
short   playlistlen, activelistlen, curlistidx, undolistlen;
BYTE    playing, paused, scanning, scandir,
        timemode, abmode, intromode, listloop, statchanged,
        lowlimtype, highlimtype, keyclick, poked, errcnt,
        playonemode;

UBYTE   channel;
int     cdgactive;
int     lastmin,lastsec;
int     lastseek;

WORD            blank;

extern UBYTE __far scrdata[];
extern UBYTE __far playerstrip[];

d115 1
a115 9
struct CDGPrefs  cdp;                                               /* FIX: CALL CDG STRUCTURE ALLOC ROUTINES */


/****************** Definitions I know are required ******************/


struct CDTOC        *TOC;                                           /* Table of contents */

UBYTE  LastTrack;
d119 7
a125 1
struct PlayerOptions  PlayerOptions;
d130 2
a131 1
struct PlayerOptions  OptionsSet;
a132 4
struct Library    *CDGBase;
struct PlayerBase *PlayerBase;


d137 6
a144 5
extern struct GfxBase          *GfxBase;
extern struct DeBoxBase        *DeBoxBase;
extern void                    *SysBase;
extern struct PlayerPrefsBase  *PlayerPrefsBase;

d146 1
a146 1
extern void UpdateGadgets(void);
d196 1
a196 2
      PLGAD_TIME,0,PLGAD_SHUFF,0,PLGAD_GCLR,0,
      PLGAD_CDG,0,0xffff,
a263 34
/*---------------- SHUTDOWN ROUTINE ----------------*/

UWORD *DoAnimation();

ShutDown() {

register UWORD *anim;
extern struct IOStdReq *cdio;
    
    anim = ShutdownAnim;
    MasterF.BoxNo = -1;

    while ((MasterF.gstate[PLGAD_COUNTER] != 0) || anim) {

        if (MasterF.gstate[PLGAD_COUNTER] != 0) MasterF.gstate[ PLGAD_COUNTER ]--;

        if (anim) anim = DoAnimation(anim);

        else UpdateDisplay();
        cdio->io_Command = CD_CHANGESTATE;
        SafeDoIO(cdio);

        if (!cdio->io_Actual) return(1);
        }
    
    anim = DiskOutAnim;
    while( anim = DoAnimation(anim));
    return(0);
    }



/*-----------------------------------------------------------------*/

a264 7
void DoReset() {

    FadeTo(15);
    REBOOT();
    }


d297 100
a396 1
LONG __asm DoPlayer( register __a6 struct PlayerPrefsBase *ppb ) {
d398 5
a402 3
register ULONG      SigEvent;                                                               /* sigwait; */
ULONG               sigchg;
ULONG               event;
d404 2
d407 2
a408 1
    InitVarBase(ppb);                                                                       /* Initilize the varables */
a409 1
    if (!openstuff()) return(20);
a410 1
    if (!(PlayerBase = OpenResource("player.resource"))) return(20);
a411 1
    if (!OwnPlayer()) return(20);
d413 1
a413 1
    PlayList = ObtainPlayList();
d415 1
a415 1
    LastTrack = 0;
d417 3
a419 1
    disableclick(1);
d421 1
a421 1
    initdisk();
d423 1
a423 1
    CDGAvail = CDGBegin(&cdp);
d425 1
a425 1
    sigchg  = 1L << changesigbit;
d430 2
a431 2
        SigEvent = SetSignal(0, 0);                                                         /* Wait(sigwait); */
        SetSignal(0, SigEvent);                                                             /* Clear wakeup signals. */
d434 3
a436 1
        while(event = GetEvent(&input_data)) dokey(event); 
d438 3
a440 1
        if (SigEvent & sigchg) handlediskchange();
d462 1
a462 1
                    if (MasterF.gstate[PLGAD_FF]) CDGFastForward();
a502 75
void UpdateGadgets() {

    GetPlayerState(&PlayerState);

    if (CDGPlaying) {

        if (CDGDisplaying && LastPlayMode == PlayerState.PlayMode && LastPlayState == PlayerState.PlayState) return;

        if (LastPlayState != PlayerState.PlayState) switch (PlayerState.PlayState) {

            case PLS_STOPPED:
                if (CDGDisplaying) ScreenFront = 20;

                CDGStop();
                CDGBack();
                CDGPlaying = CDGDisplaying = 0;
                MasterF.gstate[PLGAD_REV] = MasterF.gstate[PLGAD_FF]  = 0;

                break;

            case PLS_PLAYING:   CDGPlay(1); break;
            case PLS_PAUSED:    CDGPause(); break;
            }
        }

    if (PlayerState.PlayState == PLS_STOPPED) MasterF.gstate[PLGAD_TTRACK] = 100;

    else {

        MasterF.gstate[PLGAD_TTRACK] = PlayerState.Track;

        if (PlayerState.Track != LastTrack) {

            if (PlayerState.PlayMode == PLM_SKIPREV) --IntroCount;
            else                                     IntroCount++;

            LastTrack = PlayerState.Track;
            }
        }

    MasterF.gstate[PLGAD_MIN]    = PlayerState.Minute;
    MasterF.gstate[PLGAD_SEC]    = PlayerState.Second;

    if (PlayerState.PlayMode == PLM_NORMAL) {

        MasterF.gstate[PLGAD_STOP]  =  (PlayerState.PlayState == PLS_STOPPED)
                                    || (PlayerState.PlayState == PLS_SELECTED)
                                    || (PlayerState.PlayState == PLS_NUMENTRY);

        MasterF.gstate[PLGAD_PLAY]  =  (PlayerState.PlayState == PLS_PLAYING)
                                    || (PlayerState.PlayState == PLS_PAUSED);

        MasterF.gstate[PLGAD_PAUSE] =   PlayerState.PlayState == PLS_PAUSED;
        }

    if (NumericPadEnabled && PlayList->EntryCount == LastEntryCount+1) MasterF.D0 = 80;

    LastEntryCount = PlayList->EntryCount;

    GetOptions(&PlayerOptions);

    MasterF.gstate[PLGAD_TIME]   = PlayerOptions.TimeMode;
    MasterF.gstate[PLGAD_REPEAT] = PlayerOptions.Loop;
    MasterF.gstate[PLGAD_INTRO]  = PlayerOptions.Intro * ((0x03 & IntroCount) + 1);

    if (PlayerState.LastModify) MasterF.gstate[PLGAD_SHUFF] = 0;

    SetTrackCounter(0);
    DisplayGrid();

    LastPlayMode  = PlayerState.PlayMode;
    LastPlayState = PlayerState.PlayState;
    }


d504 1
d506 1
a506 1
void dokey(ULONG sevent) {
d509 1
a509 3
register UWORD  event, dir;

    event = sevent;
d750 6
a755 1
void click() {
d757 1
a757 4
    disableclick(0);
    if (keyclick && PlayerState.PlayState < PLS_PLAYING) KeyClickCommand(CLKCMD_CLICK, 0, 0, 0, 0, 0);
    disableclick(1);
    }
d759 1
d761 1
a761 1
void disableclick(int disable) {
d763 2
a764 2
    if (keyclick) KeyClickCommand(CLKCMD_DISABLE, 0, disable, 0, 0, 0);
    }
d766 4
d771 1
d773 4
a776 1
void handlediskchange(void) {
d778 1
a778 2
    cdio->io_Command = CD_CHANGESTATE;
    SafeDoIO(cdio);
d780 1
a780 1
    ScreenSaverCommand(SCRSAV_UNSAVE);                                                                              /* Turn off the screen blanker. */
d782 1
a782 1
    blank = handlescrsave(&intdata, -1, PlayerPrefsBase);
d784 1
a784 1
    if (cdio->io_Actual) {
d786 2
a787 2
        abortwait(cdsubq);
        ShutDown();
d789 2
a790 1
        if (cdgactive) CDGDiskRemoved();
d793 14
a806 1
    DoReset();                                                                                                      /* Check to see if there are any data tracks.  If so, reboot and let Carl/Jerry tell us if we should be playing it. */
d808 1
a808 2
    ClearEvent(&input_data);                                                                                        /* kill any stored keys */
    }
d810 1
d812 1
d814 3
a816 1
UBYTE inlist(UBYTE track) {
d818 1
a818 1
int i;
d820 2
a821 2
    for (i=0; i!=PlayList->EntryCount; i++)
        if ((PlayList->Entry[i] & PLEF_TRACK) == track) return(PlayList->Entry[i]);
d823 2
a824 1
    return(0);
a826 4
/*
 * This routine returns TRUE if any of the tracks on the disk is a
 * data track.
 */
a827 1
void initdisk(void) {
d829 5
d836 3
a838 1
int              i, j, k;
d840 1
a840 1
    cdio->io_Command  = CD_TOCMSF;                                                                                /* Gimme summary. */
a845 2
    activelistlen = playlistlen;

d892 1
a892 1
    j = 1; k = 0;
d898 1
a898 1
            if (!inlist(i+1)) j = 0;                                                                                /* all list entries must be present */
d900 1
d904 1
a904 1
    if (j && k) {
d922 1
a922 13
    CDG_Open(&cdp);

    StartUnpack(&cdp);

    anim = IntroData;

    while (anim) {

        if (Gi < 46) GetSprites(&cdp,250,160);                                                                    /* getsprites immediately returns if sprites are already unpacked and set up */
        anim = DoAnimation(anim, NULL);
        }

    while (Gi < 46) GetSprites(&cdp,250,160);
d925 2
d930 3
a932 1
openstuff() {
d934 4
a937 3
extern struct GadDir    PlayGADList[];
extern UBYTE        __far scrbuttons[];
extern struct BuildBg_Info __far PlayerBg;
d939 1
a939 3
struct CDTVPrefs    prefs;
struct MsgPort      *ireply = NULL;
struct timerequest  *iio = NULL;
d941 1
a941 1
int i;
d943 1
a943 1
    srand((-vhposr & 0x7fff) ^ 0x1D6539A3);
d945 2
a946 1
    if (StartPPScreen(PlayGADList, &PlayerBg, scrbuttons, 15))                          DIE("Can't open CDTV Screen.\n");
d948 4
a951 1
    for (i=PLGAD_STOP; i<=PLGAD_20; i++) WorkF->gstate[i] = CurrentF->gstate[i] = -1;
d953 2
a954 53
    if (!(cdreply = (struct MsgPort *)CreatePort(0, 0)))                                DIE("Can't create reply port.\n");

    if (!(subqreply = (struct MsgPort *)CreatePort(0, 0)))                              DIE("Can't create subq reply port.\n");

    if (!(cdio =(struct IOStdReq *)CreateStdIO(cdreply))
        || !(cdsubq =(struct IOStdReq *)CreateStdIO(subqreply))
        || !(cdintr =(struct IOStdReq *)CreateStdIO(cdreply)))                          DIE("Can't create IO packets.\n");

    if (OpenDevice("cdtv.device", 0, cdio, 0)) {

        cdio->io_Device = NULL;
        DIE("Can't open cdtv.device.\n");
        }

    CopyMem(cdio, cdsubq, sizeof(*cdio));
    CopyMem(cdio, cdintr, sizeof(*cdio));

    cdio->io_Message.mn_ReplyPort   = cdreply;
    cdintr->io_Message.mn_ReplyPort = cdreply;
    cdsubq->io_Message.mn_ReplyPort = subqreply;

    if ((changesigbit = AllocSignal(-1)) == -1)                                         DIE("Can't procure signal bit.\n");

    changeintrdata.me   = FindTask(NULL);
    changeintrdata.sig  = 1L<<changesigbit;
    cdintr->io_Command  = CD_ADDCHANGEINT;
    cdintr->io_Length   = sizeof(changeintrnode);
    cdintr->io_Data     = (APTR)&changeintrnode;
    SendIO(cdintr);

    FillCDTVPrefs(&prefs);

    keyclick = (prefs.Flags & CDTVPF_KEYCLICK) != 0;

    if (!(TOC = AllocMem(TOCSIZE, MEMF_PUBLIC)))                                        DIE("Can't allocate TOC.\n");

    if (!(UndoPlayList = AllocMem(sizeof(struct PlayList), MEMF_PUBLIC)))               DIE("Can't allocate UndoPlayList.\n");

    InstallKeyClick();

    InstallScreenSaver();

    InstallJoyMouse();

    return(1);


errxit:
    if (iio) {

        if (iio->tr_node.io_Device) CloseDevice(iio);
        DeleteStdIO(iio);
        }
d956 1
a956 1
    if (ireply) DeletePort(ireply);
d958 2
a959 2
    closestuff();
    return(0);
d963 1
d965 1
a965 1
void closestuff(void) {
d967 4
a970 1
    RemoveJoyMouse();
a971 38
    if (cdio) {

        if (cdio->io_Device) {

            abortwait(cdsubq);

            cdio->io_Command = CD_REMCHANGEINT;
            cdio->io_Length  = sizeof(changeintrnode);
            cdio->io_Data    = (APTR)&changeintrnode;
            SafeDoIO(cdio);
            SafeWaitIO(cdintr);

            CloseDevice(cdio);
            }

        DeleteStdIO(cdio);
        }

    if (UndoPlayList)        FreeMem(UndoPlayList, sizeof(struct PlayList));
    if (TOC)                 FreeMem(TOC, TOCSIZE);
    if (changesigbit >= 0)   FreeSignal(changesigbit);
    if (cdsubq)              DeleteStdIO(cdsubq);
    if (subqreply)           DeletePort(subqreply);
    if (cdreply)             DeletePort(cdreply);

    KeyClickCommand(CLKCMD_DIE, 0, 0, 0, 0, 0); 
    EndCDTVScreen();
    }



void abortwait(register struct IOStdReq *ior) {

    AbortIO(ior);
    SafeWaitIO(ior);
    }


d973 1
a973 3
/*
 * Diskchange interrupt handler.
 */
d975 1
a975 1
LONG __asm changeintr(register __a1 struct changedata *cd) {
d977 1
a977 2
    Signal(cd->me, cd->sig);
    return(0);
d981 9
a989 1
void SetNumPad() {
d991 1
a991 2
    if (MasterF.BoxNo >= PLGAD_1 && MasterF.BoxNo <= PLGAD_20) PlayerNumPad(0);
    else                                                       PlayerNumPad(1);
d993 3
a995 3


void PlayerNumPad(int on) {
d997 1
a997 5
    cdio->io_Command = CDTV_FRONTPANEL;
    cdio->io_Data    = NULL;
    cdio->io_Offset  = 0;
    cdio->io_Length  = CDTV_PANEL_ENABLED | CDTV_PANEL_PLAY_EJECT | (on ? CDTV_PANEL_NUMERIC:0);
    SafeDoIO(cdio);
d999 2
a1000 1
    NumericPadEnabled = on;
@
