head     1.18;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.18
date     93.04.07.16.57.31;  author peter;  state Exp;
branches ;
next     1.17;

1.17
date     93.04.06.15.22.45;  author peter;  state Exp;
branches ;
next     1.16;

1.16
date     93.03.31.18.01.10;  author peter;  state Exp;
branches ;
next     1.15;

1.15
date     93.03.31.15.15.57;  author peter;  state Exp;
branches ;
next     1.14;

1.14
date     93.03.25.23.02.28;  author peter;  state Exp;
branches ;
next     1.13;

1.13
date     93.03.25.19.37.05;  author peter;  state Exp;
branches ;
next     1.12;

1.12
date     93.03.19.18.58.01;  author peter;  state Exp;
branches ;
next     1.11;

1.11
date     93.03.17.16.55.45;  author peter;  state Exp;
branches ;
next     1.10;

1.10
date     93.03.08.18.23.17;  author peter;  state Exp;
branches ;
next     1.9;

1.9
date     93.03.03.13.32.37;  author peter;  state Exp;
branches ;
next     1.8;

1.8
date     93.02.26.19.03.20;  author peter;  state Exp;
branches ;
next     1.7;

1.7
date     93.02.23.15.38.30;  author peter;  state Exp;
branches ;
next     1.6;

1.6
date     93.01.07.11.02.56;  author jerryh;  state Exp;
branches ;
next     1.5;

1.5
date     92.12.18.11.43.00;  author jerryh;  state Exp;
branches ;
next     1.4;

1.4
date     92.09.21.13.49.09;  author jerryh;  state Exp;
branches ;
next     1.3;

1.3
date     92.07.31.14.11.14;  author jerryh;  state Exp;
branches ;
next     1.2;

1.2
date     92.07.29.10.11.25;  author jerryh;  state Exp;
branches ;
next     1.1;

1.1
date     92.07.23.11.37.20;  author jerryh;  state Exp;
branches ;
next     ;


desc
@Screen update module for Player program.
@


1.18
log
@Now keeps track of NumSelectedTracks.  Moved ResetPlayList() to
player.c.
@
text
@/* $Id: gadgets.c,v 1.17 93/04/06 15:22:45 peter Exp Locker: peter $ */

#include <exec/types.h>
#include <exec/io.h>
#include <exec/execbase.h>
#include <exec/memory.h>

#include <hardware/blit.h>

#include <devices/timer.h>
#include <devices/input.h>
#include <devices/inputevent.h>

#include <graphics/gfx.h>
#include <graphics/rastport.h>
#include <graphics/view.h>

#include <cd/cd.h>
#include <libraries/debox.h>

#include <libraries/dos.h>

/* ZZZ: for ScreenBuffer structure */
#include <intuition/screens.h>

#include "/screencoords.h"
#include "/playerprefs.h"
#include "/display.h"
#include "/playerprefsbase.h"

#include "/playerprefs_pragmas.h"
#include "/playerprefs_protos.h"

#include <clib/exec_protos.h>
#include <clib/dos_protos.h>
#include <clib/graphics_protos.h>
#include <clib/debox_protos.h>

#include <pragmas/exec_old_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/debox_pragmas.h>

#include <internal/playerlibrary.h>
#include <clib/player_protos.h>
#include <pragmas/player_pragmas.h>


/******************************** Defines **********************************/

/* Max pos for track counter */
#define TCOUNTMAX   59

/*************************** External Functions ****************************/

extern void UpdateGadgets(void);
extern int UpdateDisplay( void );

extern GADInsDraw(struct RastPort *, struct GadDir *, int, UWORD);
extern GADSTDBox(struct RastPort *, struct GadDir *, int, UWORD);

extern GADNumber(struct RastPort *, struct BitMap *, struct GadDir *, WORD, WORD);
extern RNormal(struct RastPort *, struct BitMap *, struct GadDir *, WORD, WORD);

/********************* External Structures/Variables ***********************/

extern void                    *SysBase;
extern struct GfxBase          *GfxBase;
extern struct DeBoxBase        *DeBoxBase;
extern struct DOSBase          *DOSBase;
extern struct PlayerPrefsBase  *PlayerPrefsBase;
extern struct PlayerBase       *PlayerBase;

extern struct CDTVInputInfo     input_data;
extern struct IBuffer          *CurrentIB;
extern struct IBuffer          *WorkIB;
extern struct IBuffer          *MasterIB;

extern struct PlayerState       PlayerState;
extern struct PlayList         *PlayList;
extern struct PlayList         *UndoPlayList;
extern WORD noscrolltracks;

extern union  CDTOC            *TOC;
extern struct QCode             qcode, copyqcode;
extern int                      qvalid;
extern struct IOStdReq         *cdio;

extern UBYTE                    KeyPressed;
extern ULONG                    currsec;

extern WORD XOFF;
extern WORD YOFF;
extern ULONG NumSelectedTracks;

/******************************* Functions *********************************/

int NOOP(void);

static GADTrackNum(), GADGridNumber(), RDisk(), RGoCDG(), RCounter();
static UWORD randomNumber( ULONG range );

void   PlayerNumPad(int);

/************************* Structures/Variables ****************************/

static LONG secperpixel = 1;
ULONG randomseed;

/*============================= Gadget Data ===============================*/

/* These arrays are used to render the states of each gadget.
 * Each array is a list of coordinate pairs, one pair per state,
 * of the Left/TopEdge in the scrbuttons.pic picture of that
 * state's imagery.  The Width/Height are inferred from the GadDir.
 */
static UWORD d_STOP[]   = { BTN_STOP_OFF, BTN_STOP_ON };
static UWORD d_REV[]    = { BTN_REV_OFF, BTN_REV_ON };
static UWORD d_PLAY[]   = { BTN_PLAY_OFF, BTN_PLAY_PAUSE, BTN_PLAY_PLAY };
static UWORD d_FF[]     = { BTN_FF_OFF, BTN_FF_ON };

static UWORD d_TIME[]   = { BTN_TIME_TRACK, BTN_TIME_TRACKTOGO, BTN_TIME_DISC, BTN_TIME_DISCTOGO };
static UWORD d_NEG[]	= { BTN_NEG_OFF, BTN_NEG_ON };
static UWORD d_SHUFF[]  = { BTN_SHUFF_OFF, BTN_SHUFF_ON };
static UWORD d_REPEAT[] = { BTN_REPEAT_OFF, BTN_REPEAT_ON };
static UWORD d_INTRO[]  = { BTN_INTRO_OFF, BTN_INTRO_1, BTN_INTRO_2, BTN_INTRO_3, BTN_INTRO_4, BTN_INTRO_ON };
static UWORD d_CDG[]    = { BTN_CDG_OFF, BTN_CDG_GFX, BTN_CDG_MIDI, BTN_CDG_BOTH };
static UWORD d_Colon[]  = { BTN_COLON_OFF, BTN_COLON_ON };

/*============================= Number Data ===============================*/

struct GADNumberInfo d_GridNumberData =
{
    NUM_GRID_XY, NUM_GRID_DIMS,
    4,4,10,2,
    20,0,
    0,0,0,0,
    GNIF_HALF | GNIF_BLANKZERO
};

struct GADNumberInfo d_MinNumberData =
{
    NUM_TIME_XY, NUM_TIME_DIMS,
    0,0,18,2,
    10,0,
    0,0,0,0,
    GNIF_BLANKMAX|GNIF_BLANKLEAD,
};

struct GADNumberInfo d_SecNumberData =
{
    NUM_TIME_XY, NUM_TIME_DIMS,
    0,0,18,2,
    10,0,
    0,0,0,0,
    GNIF_BLANKMAX
};

struct GADNumberInfo d_TrackNumberData =
{
    NUM_TRACK_XY, NUM_TRACK_DIMS,
    26,25,24,2,
    10,0,
    0,0,0,0,
    GNIF_BLANKZERO | GNIF_BLANKMAX
};


/*======================== Gadget Highlight Data ==========================*/

/* Used by GADStdBox() to do the highlighting of the entries in the
 * track table.
 */
struct GADSTDBox d_GridBoxInfo =
{
    -4,-3,33,23,		/* xoffset,yoffset/width/height */
    { 1,1, 192,97 },		/* offi: dispbm=ButtonBM, mask=bmask, coords */
    { 1,1, 226,97 }		/* oni:  dispbm=ButtonBM, mask=ButtonBM, coords */
};


/* These are data tables indicating how to draw the box-highlight
 * for different sized boxes, used by GADInsDraw().
 * d_GADBigButtons[] is for the Play/Pause and regular buttons like Intro, Repeat, etc.
 * d_GADMedButtons[] is for the CDG and Time button.
 * d_GADSmallButtons[] is for the other transport controller buttons.
 */
BYTE d_GADBigButtons[] =
{
    INS_OFF_REDRAW,

    INS_PEN,    34,21,
    INS_MOVE,   3,1,
    INS_DRAW,   44,1,

    INS_PEN,    34,22,
    INS_MOVE,   45,2,
    INS_DRAW,   45,24,

    INS_PEN,    34,23,
    INS_MOVE,   44,25,
    INS_DRAW,   3,25,

    INS_PEN,    34,24,
    INS_MOVE,   2,24,
    INS_DRAW,   2,2,

    INS_END
};

BYTE d_GADSmallButtons[] =
{
    INS_OFF_REDRAW,

    INS_PEN,    34,21,
    INS_MOVE,   3,1,
    INS_DRAW,   26,1,

    INS_PEN,    34,22,
    INS_MOVE,   27,2,
    INS_DRAW,   27,24,

    INS_PEN,    34,23,
    INS_MOVE,   26,25,
    INS_DRAW,   3,25,

    INS_PEN,    34,24,
    INS_MOVE,   2,24,
    INS_DRAW,   2,2,

    INS_END
};

BYTE d_GADMedButtons[] =
{
    INS_OFF_REDRAW,

    INS_PEN,    34,21,
    INS_MOVE,   4,2,
    INS_DRAW,   44,2,

    INS_PEN,    34,22,
    INS_MOVE,   45,3,
    INS_DRAW,   45,20,

    INS_PEN,    34,23,
    INS_MOVE,   44,21,
    INS_DRAW,   4,21,

    INS_PEN,    34,24,
    INS_MOVE,   3,20,
    INS_DRAW,   3,3,

    INS_END
};

/*============================= Gadget List ===============================*/

/* ZZZ: Left/Top/Right/Bottom of PLGAD_COUNTER, DISK, TTRACK are unused */
/* NB: Order of gadgets IS significant.  The laser from PLGAD_COUNTER can
 * overwrite the disk from PLGAD_DISK, thus PLGAD_DISK must follow
 * PLGAD_COUNTER.  Also, PLGAD_TTRACK intentionally writes over PLGAD_COUNTER,
 * so it too must follow.
 *
 * NB: Legal states run from 0..MaxStates-1.
 */

struct GadDir PlayGADList[MAX_PLGAD + 1] =
{
/*  { ID,            Flags,KeyTrans,routine,MaxStates, Up,           Down,         Left,         Right,        Lft, Top, Rt,  Btm, BoxFunc,    BoxData,            RenderFunc,    RenderData }, */

    { PLGAD_DISK,    0x00, 0,            0, 25,        PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     279, 160, 307, 180, NOOP,       NULL,               RDisk,         NULL               },
    { PLGAD_COUNTER, 0x00, 0,            0, TCOUNTMAX, PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     279, 160, 307, 180, NOOP,       NULL,               RCounter,      NULL               },
    { PLGAD_TTRACK,  0x00, 0,            0, 100,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     279, 160, 307, 180, NOOP,       NULL,               GADTrackNum,   &d_TrackNumberData },

    { PLGAD_REV,     0x80, KEY_BACK,     0,   2,       PLGAD_16,     PLGAD_INTRO,  PLGAD_STOP,   PLGAD_PLAY,   CELL_REV,           GADInsDraw, &d_GADSmallButtons, RNormal,       &d_REV    },
    { PLGAD_PLAY,    0x80, KEY_PLAYPAUSE,0,   3,       PLGAD_17,     PLGAD_SHUFF,  PLGAD_REV,    PLGAD_FF,     CELL_PLAY,          GADInsDraw, &d_GADBigButtons,   RNormal,       &d_PLAY   },
    { PLGAD_FF,      0x80, KEY_FWD,      0,   2,       PLGAD_19,     PLGAD_SHUFF,  PLGAD_PLAY,   PLGAD_STOP,   CELL_FF,            GADInsDraw, &d_GADSmallButtons, RNormal,       &d_FF     },
    { PLGAD_STOP,    0x80, KEY_STOP,     0,   2,       PLGAD_20,     PLGAD_REPEAT, PLGAD_FF,     PLGAD_REV,    CELL_STOP,          GADInsDraw, &d_GADSmallButtons, RNormal,       &d_STOP   },

    { PLGAD_GOCDG,   0xC0, KEY_GOCDG, 0,GOCDGSTATES+1, PLGAD_REV,    PLGAD_1,      PLGAD_REPEAT, PLGAD_TIME,   CELL_GOCDG,         GADInsDraw, &d_GADMedButtons,   RGoCDG,        NULL      },
    { PLGAD_TIME,    0x80, KEY_TIMEMODE, 0,   4,       PLGAD_REV,    PLGAD_1,      PLGAD_GOCDG,  PLGAD_INTRO,  CELL_TIME,          GADInsDraw, &d_GADMedButtons,   RNormal,       &d_TIME   },
    { PLGAD_INTRO,   0x80, KEY_INTRO,    0,   6,       PLGAD_REV,    PLGAD_1,      PLGAD_TIME,   PLGAD_SHUFF,  CELL_INTRO,         GADInsDraw, &d_GADBigButtons,   RNormal,       &d_INTRO  },
    { PLGAD_SHUFF,   0x80, KEY_SHUFFLE,  0,   2,       PLGAD_PLAY,   PLGAD_3,      PLGAD_INTRO,  PLGAD_REPEAT, CELL_SHUFF,         GADInsDraw, &d_GADBigButtons,   RNormal,       &d_SHUFF  },
    { PLGAD_REPEAT,  0x80, KEY_REPEAT,   0,   2,       PLGAD_STOP,   PLGAD_5,      PLGAD_SHUFF,  PLGAD_GOCDG,  CELL_REPEAT,        GADInsDraw, &d_GADBigButtons,   RNormal,       &d_REPEAT },

    { PLGAD_1,       0x05, KEY_GBUTTON,  0, 255,       PLGAD_INTRO,  PLGAD_6,      PLGAD_NL,     PLGAD_2,      155, 3,   179, 19,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_2,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_INTRO,  PLGAD_7,      PLGAD_1,      PLGAD_3,      189, 3,   213, 19,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_3,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_SHUFF,  PLGAD_8,      PLGAD_2,      PLGAD_4,      223, 3,   247, 19,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_4,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_REPEAT, PLGAD_9,      PLGAD_3,      PLGAD_5,      257, 3,   281, 19,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_5,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_REPEAT, PLGAD_10,     PLGAD_4,      PLGAD_6,      291, 3,   315, 19,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_6,       0x00, KEY_GBUTTON,  0, 255,       PLGAD_1,      PLGAD_11,     PLGAD_5,      PLGAD_7,      155, 26,  179, 42,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_7,       0x00, KEY_GBUTTON,  0, 255,       PLGAD_2,      PLGAD_12,     PLGAD_6,      PLGAD_8,      189, 26,  213, 42,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_8,       0x00, KEY_GBUTTON,  0, 255,       PLGAD_3,      PLGAD_13,     PLGAD_7,      PLGAD_9,      223, 26,  247, 42,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_9,       0x00, KEY_GBUTTON,  0, 255,       PLGAD_4,      PLGAD_14,     PLGAD_8,      PLGAD_10,     257, 26,  281, 42,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_10,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_5,      PLGAD_15,     PLGAD_9,      PLGAD_11,     291, 26,  315, 42,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_11,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_6,      PLGAD_16,     PLGAD_10,     PLGAD_12,     155, 49,  179, 65,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_12,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_7,      PLGAD_17,     PLGAD_11,     PLGAD_13,     189, 49,  213, 65,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_13,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_8,      PLGAD_18,     PLGAD_12,     PLGAD_14,     223, 49,  247, 65,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_14,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_9,      PLGAD_19,     PLGAD_13,     PLGAD_15,     257, 49,  281, 65,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_15,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_10,     PLGAD_20,     PLGAD_14,     PLGAD_16,     291, 49,  315, 65,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_16,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_11,     PLGAD_REV,    PLGAD_15,     PLGAD_17,     155, 72,  179, 88,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_17,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_12,     PLGAD_PLAY,   PLGAD_16,     PLGAD_18,     189, 72,  213, 88,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_18,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_13,     PLGAD_PLAY,   PLGAD_17,     PLGAD_19,     223, 72,  247, 88,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_19,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_14,     PLGAD_FF,     PLGAD_18,     PLGAD_20,     257, 72,  281, 88,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_20,      0x0A, KEY_GBUTTON,  0, 255,       PLGAD_15,     PLGAD_STOP,   PLGAD_19,     PLGAD_NL,     291, 72,  315, 88,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },

    { PLGAD_MIN,     0x00, 0,            0, 101,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     CELL_MIN,           NOOP,       NULL,               GADNumber,     &d_MinNumberData },
    { PLGAD_SEC,     0x00, 0,            0, 101,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     CELL_SEC,           NOOP,       NULL,               GADNumber,     &d_SecNumberData },
    { PLGAD_NEG,     0x00, 0,            0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     CELL_NEG,           NOOP,       NULL,               RNormal,       &d_NEG },
    { PLGAD_CDG,     0x80, 0,            0,   4,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     CELL_CDG,           NOOP,       NULL,               RNormal,       &d_CDG },
    { PLGAD_COLON,   0x80, 0,            0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     CELL_COLON,         NOOP,       NULL,               RNormal,       &d_Colon },

    { PLGAD_NL,      0x00, 0,         0xff, 0xff,      0xff,         0xff,         0,            0xff,         0,   0,   0,   0,   NULL,       NULL,               NULL }
};


/******************************* No Function *******************************/

int
NOOP( void )
{
    return(0);
}



/*=================== Head Gadget Positioning/Clipping ====================*/

/* Based on state, returns x, y, height, and source-y in button bitmap.
 * The state bit of COUNTER_LASERON means the laser is on, and is ignored
 * by this routine.  The state bit of COUNTER_FLYING means that the head-gadget
 * entry/exit motion is in progress, and the y-value comes from
 * the embedded table, while x=20.
 * If COUNTER_FLYING is not set, the state value reflects the desired head
 * position left/right.
 */
static void
getcounterbase(WORD loc, WORD *x, WORD *y, WORD *dpos, WORD *dsize)
{
static WORD pos[] =
{
    -101, -88, -76, -65, -55,
     -46, -37, -29, -22, -16,
     -11,  -7,  -3,   1,   4,
       7,  10,  12,  14,  15,
      16,  17,
};

    if ( loc & COUNTER_FLYING )
    {
	/* Vertical movememt */
	*x = 6+XOFF;
	if (loc >= 20)  *y = -11+YOFF;
	else            *y = pos[loc & COUNTER_TRACKNUM] + YOFF;
    }

    else
    {
	/* Horizontal movement */
	loc &= COUNTER_TRACKNUM;

	*y = 17+YOFF;
	*x = 6+XOFF+loc;
    }

    /* Default gadget dimensions */
    *dpos  = 101;
    *dsize = 45;

    /* Clip the gadget if off screen */
    if (*y<0)
    {
	*dpos -= *y;
	*dsize += *y;
	*y = 0;
    }
}




/*************************** Head Gadget Movement **************************/

static
RCounter(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new)
{
extern UBYTE            *bmask;
WORD                     xloc, yloc, dpos, dsize;

    /* erase old */
    getcounterbase(old, &xloc, &yloc, &dpos, &dsize);

    if ( old & COUNTER_LASERON )
    {
	/* COUNTER_LASERON means laser is on in old state.  Since the laser
	 * overwrites the CD, we will have to blit the CD back into place to
	 * erase that part of the laser.  We also blit part of the background
	 * near the CD's left end, since the laser could have been there
	 * too.  We pump up dsize so that when we erase the head gadget,
	 * we obliterate the part of the laser that's in the air between
	 * the head and the CD.
	 */
	dsize = 67;
    }

    if (dsize > 0)
    {
	/* This erases the head gadget and any part of the laser which is
	 * in the air below the head
	 */
	SetAPen( rp, 0 );
	RectFill( rp, xloc, yloc, xloc + 79, yloc + dsize - 1 );
    }
    if ( old & COUNTER_LASERON )
    {
	/* Erase the part of the laser which is over the CD by redrawing
	 * part of the CD itself.
	 */
	BltBitMapRastPort( bbm, 96, 209, rp, 38+XOFF, 74+YOFF, 106, 16, 0xC0 );
    }

    getcounterbase(new, &xloc, &yloc, &dpos, &dsize);

    if (dsize > 0)
    {
	/* This draws the laser head */
	BltBitMapRastPort(bbm, 96, dpos, rp, xloc, yloc, 80, dsize, 0xC0 );

	if ( new & COUNTER_LASERON )
	{
	    /* COUNTER_LASERON means laser is on in new state.  This blit draws
	     * the laser.
	     */
	    BltMaskBitMapRastPort(bbm, 97, 147, rp, xloc+12, yloc+37, 50, 34, (ABC|ABNC|ANBC), bmask);
	}
    }

    /* Blitting the disk head blew away the numbers inside.  Thus,
     * we have to mark the PLGAD_TTRACK state as blank.
     */
    CurrentIB->ib_GState[PLGAD_TTRACK] = WorkIB->ib_GState[PLGAD_TTRACK] = 0;

    return(0);
}





/*************************** Disk Gadget Movement **************************/

/* arg rp = ViewPort's RastPort
 * arg bbm = Button bitmap
 * arg GadDir = "gadget" description
 * arg old = old state
 * arg new = new state
 * global bmask = Button bitmap's mask plane (DPaint stencil)
 */

static
RDisk(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new)
{
extern UBYTE           *bmask;

WORD                    xloc,dpos,dwidth;
WORD                    oldxloc, olddwidth;
int                     overlen = 0;

static WORD             nums[] =
{
    /* ZZZ: first entry is unused */
       0,   38,   37,   36,   33,
      30,   26,   21,   16,   10,
       3,   -4,  -12,  -21,  -31,
     -42,  -57,  -72,  -88, -105,
    -126, -148, -171, -195,
};


    /* Work out the span of the disk in its old and new positions,
     * so we know what to erase.
     *
     * To handle the case of (old==0), we choose initial numbers
     * that will produce no rendering.
     */
    olddwidth = -20000;
    oldxloc = 10000;
    if ( ( old ) && ( old < 24 ) )
    {
	olddwidth = 207;

	oldxloc = nums[old]+XOFF;

	if (oldxloc < 0)
	{
	    olddwidth += oldxloc;
	    oldxloc = 0;
	}
	overlen = oldxloc + olddwidth - (151+XOFF);
    }

    xloc = 0;
    dwidth = 0;
    if ( ( new ) && ( new < 24 ) )
    {
	dpos   = 96;
	dwidth = 207;

	xloc = nums[new]+XOFF;

	if (xloc < 0)
	{
	    dpos -= xloc;
	    dwidth += xloc;
	    xloc = 0;
	}
	/* Draw the CD sliding in or out */
	BltBitMapRastPort(bbm, dpos, 209, rp, xloc, 74+YOFF, dwidth, 18, 0xC0 );

	if ( xloc+dwidth - (151+XOFF) > overlen )
	{
	    overlen = xloc+dwidth - (151+XOFF);
	}
    }

    SetAPen( rp, 0 );
    /* If the disk is moving to the right, we may have stuff
     * to erase on the left-hand-side
     */
    if ( xloc > oldxloc )
    {
	RectFill( rp, oldxloc, 74+YOFF, xloc-1, 91+YOFF );
    }
    /* If the disk is moving to the left, we may have stuff
     * to erase on the right-hand-side.  This is more complex,
     * for one reason.  If you look closely at the "plastic"
     * in the track table, you can see the background gradient
     * lensing through.  What we _should_ do is blit the area
     * from the original bitmap (giving us track table plus
     * gradient, then do a masked blit of the CD, superposing
     * that, then a masked blit of the special repair copy
     * of the track, which puts the CD behind.
     * Now we want to avoid the masked blit of the CD, for speed,
     * so we cheat.
     *
     * So what we do here is blit from the original bitmap, which
     * restores the grid and the lensing.  The reason this is
     * a cheat is that the lensing gradient is only visible in
     * the pixels to the right of the extreme of the CD, whereas
     * because the CD is non-rectangular, we should have more
     * of the gradient visible than that.  However, since the
     * anim is fast, who cares?
     */
    if ( oldxloc + olddwidth > xloc + dwidth )
    {
/*ZZZ shouldn't have Intuition refs here? */
	BltBitMapRastPort(MasterIB->ib_ScreenBuffer->sb_BitMap,
	    xloc + dwidth, 74+YOFF,
	    rp, xloc + dwidth, 74+YOFF,
	    oldxloc + olddwidth - ( xloc + dwidth ), 18, 0xC0 );
    }
    /* The CD might have been rendered over part of the track table.
     * We keep a spare masked copy on the scrbuttons screen, and
     * right here, we blit it back over so the CD goes behind,
     * as we wished.
     */
    if (overlen > 0)
    {
	BltMaskBitMapRastPort(bbm, 192,79, rp, 151+XOFF, 74+YOFF,
	    overlen, 18, (ABC|ABNC|ANBC), bmask);

	GADNumber(rp, bbm, &MasterIB->ib_GadList[PLGAD_16], -1, MasterIB->ib_GState[PLGAD_16]);
	GADNumber(rp, bbm, &MasterIB->ib_GadList[PLGAD_17], -1, MasterIB->ib_GState[PLGAD_17]);
	GADNumber(rp, bbm, &MasterIB->ib_GadList[PLGAD_18], -1, MasterIB->ib_GState[PLGAD_18]);
    }
    return(0);
}


/************************** Update Digits in Head **************************/

static
GADTrackNum(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new)
{
struct GadDir gad;
UWORD counterstate;

    counterstate = MasterIB->ib_GState[PLGAD_COUNTER];

    /* When the head is flying, we want the counter to be blank.
     * For speed, we don't keep re-rendering the blankness.
     */
    if ( counterstate & COUNTER_FLYING )
    {
	return(0);
    }

    gad.LeftEdge   = (counterstate & COUNTER_TRACKNUM);
    gad.TopEdge    = 0;
    gad.RenderData = g->RenderData;

    GADNumber(rp, bbm, &gad, old, new);

    return(g->Flags & GDFLAGS_SELECTABLE);
}




/************************** Update Grid Selection **************************/

static
GADGridNumber(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new)
{
struct GadDir gad;

static BYTE gbox[] =
{
    INS_PEN,    43,9,
    INS_MOVE,   2,0,
    INS_DRAW,   22,0,
    INS_DRAW,   24,2,
    INS_DRAW,   24,14,
    INS_DRAW,   22,16,
    INS_DRAW,   2,16,
    INS_DRAW,   0,14,
    INS_DRAW,   0,2,
    INS_DRAW,   2,0,
    INS_END
};

    if ( ( old ^ new ) & GRID_CURRENT )
    {
	CopyMem((char *)g, (char *)&gad, sizeof(struct GadDir));
	gad.BoxData = gbox;
	GADInsDraw( rp, &gad, ( new & GRID_CURRENT ? 1 : 0 ), new );
    }

    return(GADNumber(rp, bbm, g, old,new));
}

/* Handle GOCDG button imagery:
 * arg rp = ViewPort's RastPort
 * arg bbm = Button bitmap
 * arg GadDir = "gadget" description
 * arg old = old state
 * arg new = new state
 * global bmask = Button bitmap's mask plane (DPaint stencil)
 */

static
RGoCDG(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new)
{
    if ( CELL_GOCDG_HEIGHT - new )
    {
	BltBitMapRastPort( bbm,
	    BTN_GOCDG_OFF,
	    rp, CELL_GOCDG_LEFT+XOFF, CELL_GOCDG_TOP+YOFF+new,
	    CELL_GOCDG_WIDTH, CELL_GOCDG_HEIGHT - new, 0xC0 );
    }
    if ( new )
    {
	BltBitMapRastPort( bbm,
	    BTN_GOCDG_ON,
	    rp, CELL_GOCDG_LEFT+XOFF, CELL_GOCDG_TOP+YOFF,
	    CELL_GOCDG_WIDTH, new, 0xC0 );
    }
    return( 1 );
}


/***************************************************************************/
/*********************** Miscellaneous Functions ***************************/
/***************************************************************************/

/**************** Stop Play and Display Total Time on Disk *****************/


void
UpdatePlayTime( void )
{
    SubmitKeyStroke(KeyPressed = PKS_STOP|PKSF_PRESS);
    SubmitKeyStroke(KeyPressed = PKS_STOP|PKSF_RELEASE);
    WaitTOF();
}


/************************* Get Gadget's Keycode ****************************/

UWORD
GetBoxKey(struct IBuffer *ib, UWORD event)
{
UWORD ans;

    if (ib->ib_BoxNo >= 0)
    {
	ans = ib->ib_GadList[ib->ib_BoxNo].KeyTrans + (event & IECODE_UP_PREFIX);
	return(ans);
    }

    return(0);
}





/*================ Scroll Up/Down Functions for DoBoxMove =================*/

static int
ScrollGridUp( void )
{
UBYTE orgpos;

    orgpos = MasterIB->ib_TrackTableOffset;

    MasterIB->ib_TrackTableOffset += 5;

    UpdateGadgets();

    return((MasterIB->ib_TrackTableOffset == orgpos ? 0:1));
}



static int
ScrollGridDown( void )
{
int ans = 1;

    if (MasterIB->ib_TrackTableOffset >= 5) MasterIB->ib_TrackTableOffset -= 5;
    else                 ans = 0;

    UpdateGadgets();

    return(ans);
}




/*************************** Move Box Selection ****************************/

static void
DoBoxMoveGrunt(UWORD event)
{
UBYTE f;
struct GadDir *g;

    if ((KeyPressed & PKSF_STROKEDIR) == PKSF_PRESS) return;

    g = &MasterIB->ib_GadList[MasterIB->ib_BoxNo];
    f = g->Flags;

    if ((event == KEY_LEFT) && (MasterIB->ib_BoxNo == PLGAD_1)) if (ScrollGridDown())
    {
	MasterIB->ib_BoxNo = PLGAD_5;
	return;
    }

    if ((event == KEY_RIGHT) && (MasterIB->ib_BoxNo == PLGAD_20)) if (ScrollGridUp())
    {
	MasterIB->ib_BoxNo = PLGAD_16;
	return;
    }

    if ((event == KEY_UP) && (f & PLFLAGS_SCROLLUP)) if (ScrollGridDown())
    {
	return;
    }

    if ((event == KEY_DOWN) && (f & PLFLAGS_SCROLLDOWN)) if (ScrollGridUp())
    {
	return;
    }

    BoxMove( MasterIB, event );
    return;
}

/* noscrolltracks is a shot counter, which is the timeout during which
 * the player will refuse to automatically scroll so as to put the
 * currently playing track into view.
 * If we're currently in the track table or we end up in the track table
 * as a result of DoBoxMoveGrunt(), we want to set this counter to the
 * countdown value, to enable scrolling.  We need this enabled before
 * DoBoxMoveGrunt(), since some scrolling may result.  We need also
 * to test afterward, since the new position of the highlight matters too.
 */
void DoBoxMove(UWORD event)
{
    UWORD beforebox;
    UWORD afterbox;

    afterbox = MasterIB->ib_BoxNo;
    if ( ( MasterIB->ib_BoxNo >= PLGAD_1 ) && ( MasterIB->ib_BoxNo <= PLGAD_20 ) &&
	( PlayerState.PlayState >= PLS_PLAYING ) )
    {
	noscrolltracks = NOSCROLLTRACKS_TICKS;
    }

    /* We know support gadgets which resist the highlight box when
     * their state is zero.  So iterate on DoBoxMoveGrunt() until
     * either:
     * - we fail to move, or
     * - the new gadget does not have this property, or
     * - the new gadget's state is non-zero
     *
     * ZZZ: Not all infinite-looping conditions are caught by this!
     * You can't make a whole row of gadgets have this feature!
     */
    do
    {
	beforebox = afterbox;
	DoBoxMoveGrunt(event);
	afterbox = MasterIB->ib_BoxNo;
    } while ( ( afterbox != beforebox ) &&
	( MasterIB->ib_GadList[afterbox].Flags & GDFLAGS_DISABLABLE ) &&
	( MasterIB->ib_GState[afterbox] == 0 ) );

    /* If we're moving in the track table, suppress scrolling of the
     * track-table if we're playing
     */
    if ( ( MasterIB->ib_BoxNo >= PLGAD_1 ) && ( MasterIB->ib_BoxNo <= PLGAD_20 ) &&
	( PlayerState.PlayState >= PLS_PLAYING ) )
    {
	noscrolltracks = NOSCROLLTRACKS_TICKS;
    }
}





/************************** Update Digits in Grid **************************/

VOID
DisplayGrid( void )
{
WORD   pos,maxpos,i;
UBYTE *pe;
UWORD *gs;

    /* D0 is the position */
    /* Should be unnecessary as ib_TrackTableOffset should already be an exact
     * multiple of 5
     */
    pos = (MasterIB->ib_TrackTableOffset/5) * 5;

    /* No lower than zero */
    if (pos < 0)
    {
	pos = 0;
    }
    /* Don't let pos be so high that we see any blank rows.
     * The maximum position is one which is 20 less than the
     * number of tracks rounded up to the next multiple of 5.
     */
    maxpos = 5 * ( ( PlayList->EntryCount + 4 ) / 5 ) - 20;
    if ( maxpos < 0 )
    {
	maxpos = 0;
    }

    if ( pos > maxpos )
    {
	pos = maxpos;
    }

    /* Position in playlist of track denoted by first gadget
     * of track table
     */
    MasterIB->ib_TrackTableOffset = pos;

    pe = &PlayList->Entry[pos];
    gs = &MasterIB->ib_GState[PLGAD_1];

    for ( i = 0; i < 20; i++ )
    {
	if ( ( pos >= PlayList->EntryCount ) || ( !*pe ) ) 
	{
	    /* Entries past the end of the PlayList, or entries of
	     * zero should produce a blank gadget
	     */
	    *gs = 0;
	}
	else if (*pe & PLEF_ENABLE)
	{
	    /* The gadget of an enabled track has state = track-number */
	    *gs = *pe & PLEF_TRACK;
	}
	else
	{
	    /* The gadget of a disabled track has state = GRID_DIMMED|track-number */
	    *gs = GRID_DIMMED + (*pe & PLEF_TRACK);
	}

	pe++;
	gs++;
	pos++;
    }

    /* Set the lit number if it is playing */
    MasterIB->ib_CurrentPlayingTrack = 0;

    if ( ( PlayerState.PlayState == PLS_SELECTED ) ||
	( PlayerState.PlayState >= PLS_PLAYING ) )
    {
	UWORD current;

	if ( !noscrolltracks )
	{
	    /* Light up the currently playing track, and ensure that
	     * it's scrolled into view.
	     */
	    while ( PlayerState.ListIndex < MasterIB->ib_TrackTableOffset )
	    {
		MasterIB->ib_TrackTableOffset -= 5;
	    }
	    while ( PlayerState.ListIndex >= MasterIB->ib_TrackTableOffset + 20 )
	    {
		MasterIB->ib_TrackTableOffset += 5;
	    }
	}
	current = PlayerState.ListIndex - MasterIB->ib_TrackTableOffset;
	if ( ( current >= 0 ) && ( current < 20 ) )
	{
	    MasterIB->ib_CurrentPlayingTrack = PLGAD_1 + current;
	    MasterIB->ib_GState[ MasterIB->ib_CurrentPlayingTrack ] |= GRID_CURRENT;
	}
    }
}




/**************************** Randomize Tracks *****************************/

/* We're called from inside UpdateGadgets(), so we don't
 * need to do any refresh of our own
 */
void
UnShuffleGrid( void )
{
WORD i;

    UpdatePlayTime(); while (!ModifyPlayList(1));

    MasterIB->ib_TrackTableOffset = 0;

    PlayList->EntryCount = 0;
    NumSelectedTracks = 0;
    for ( i = 0; i < UndoPlayList->EntryCount; i++ )
    {
	PlayList->Entry[i] = UndoPlayList->Entry[i];
	if ( PlayList->Entry[i] & PLEF_ENABLE )
	{
	    NumSelectedTracks++;
	}
    }
    PlayList->EntryCount = UndoPlayList->EntryCount;

    ModifyPlayList(0);
}

void
ShuffleGrid( LONG alreadyshuffled )
{
WORD    i, j, d, r;

    UpdatePlayTime();
    while (!ModifyPlayList(1));

    /* Blank grid before we display our changes */
    for(i=PLGAD_1; i<=PLGAD_20; i++) MasterIB->ib_GState[i] = 0x0000;

    MasterIB->ib_TrackTableOffset = 0;
    MasterIB->ib_GState[PLGAD_SHUFF] = 1;
    UpdateDisplay();

    if ( !alreadyshuffled )
    {
	CopyMem(PlayList, UndoPlayList, sizeof(struct PlayList));
    }
    PlayList->EntryCount = 0;
    for ( i = 0; i < UndoPlayList->EntryCount; i++ )
    {
	PlayList->Entry[i] = 0;
    }
    PlayList->EntryCount = UndoPlayList->EntryCount;
    NumSelectedTracks = 0;

     /* Generate random list from 'undo' list. */
    for(i=0; i<UndoPlayList->EntryCount; i++)
    {
	j=0;

	do
	{
	    r = randomNumber( UndoPlayList->EntryCount );
	}
	while ( ++j < 10 && PlayList->Entry[r] );

	if (j == 10)
	{
	    d = randomNumber(2);

	    /* Find the r'th unused entry. */
	    while (PlayList->Entry[r])
	    {
		if (d)
		{
		    if (--r < 0) r = UndoPlayList->EntryCount - 1;
		}

		else if (++r >= UndoPlayList->EntryCount) r = 0;
	    }
	}

	PlayList->Entry[r] = UndoPlayList->Entry[i];
	if ( PlayList->Entry[r] & PLEF_ENABLE )
	{
	    NumSelectedTracks++;
	}

	WaitTOF(); WaitTOF(); WaitTOF();

	UpdateGadgets();
	UpdateDisplay();
    }

    ModifyPlayList(0);
    /* Ensure the shuffle button has been lit for FLASHLENGTH frames,
     * knowing that we got 3 WaitTOF()s for every entry
     * in the UndoPlayList
     */
    for ( i = UndoPlayList->EntryCount * 3; i < FLASHLENGTH; i++ )
    {
	WaitTOF();
    }

    MasterIB->ib_GState[PLGAD_SHUFF] = 0;

    UpdateGadgets();
    UpdateDisplay();
}


/*********************** Initialize Head Positioner ************************/

void
InitTrackCounter( void )
{
    secperpixel = TOC[0].Summary.LeadOut.LSN/TCOUNTMAX;

    if (secperpixel == 0) secperpixel = 1;
}




/************************ Head Positioning Function ************************/

void
SetTrackCounter(int now)
{
WORD  loc, pos, move;

    if (PlayerState.PlayState == PLS_NUMENTRY);

    else if ((PlayerState.PlayState == PLS_SELECTED
	    || PlayerState.PlayMode == PLM_SKIPFWD
	    || PlayerState.PlayMode == PLM_SKIPREV)
	    && (PlayerState.PlayState != PLS_STOPPED ))
    {
	currsec = TOC[PlayerState.Track].Entry.Position.LSN;
    }

    else if (PlayerState.PlayState >= PLS_PLAYING)
    {
	if (qvalid) currsec = copyqcode.DiskPosition.LSN;
    }

    else currsec = 0;

    if ( !( MasterIB->ib_GState[PLGAD_COUNTER] & COUNTER_FLYING ) )
    {
	pos = TCOUNTMAX - (currsec/secperpixel);

	if (pos >= TCOUNTMAX) pos = TCOUNTMAX-1;
	if (pos < 0)          pos = 0;

	if (now) loc = pos;

	else
	{
	    loc = MasterIB->ib_GState[PLGAD_COUNTER] & COUNTER_TRACKNUM;
	    pos -= loc;

	    if (pos < 0)
	    {
		move = -2;
		if (pos >= -2) move = pos;
		if (pos < -5)  move = -3;
		if (pos < -10) move = -4;
	    }

	    else
	    {
		move = 2;
		if (pos <= 2) move = pos;
		if (pos > 5)  move = 3;
		if (pos > 10) move = 4;
	    }

	    loc += move;
	}

	MasterIB->ib_GState[PLGAD_COUNTER] = loc;
	if ( PlayerState.PlayState >= PLS_PLAYING )
	{
	    MasterIB->ib_GState[PLGAD_COUNTER] |= COUNTER_LASERON;
	}
    }
}


/******************* Highlight/Unhighlight a Grid Entry ********************/

void
togglegnum( void )
{
int pos;

    pos = MasterIB->ib_TrackTableOffset + (MasterIB->ib_BoxNo - PLGAD_1);

    if ( ( MasterIB->ib_BoxNo < PLGAD_1 ) || ( MasterIB->ib_BoxNo > PLGAD_20 ) ||
	( pos >= PlayList->EntryCount ) )
    {
	return;
    }

    if (PlayList->Entry[pos] & PLEF_TRACK)
    {
	MasterIB->ib_GState[PLGAD_SHUFF] = 0;

	PlayList->Entry[pos] ^= PLEF_ENABLE;
	if ( PlayList->Entry[pos] & PLEF_ENABLE )
	{
	    NumSelectedTracks++;
	}
	else
	{
	    NumSelectedTracks--;
	}

	/* Suppress scrolling of the track-table if we're playing */
	if ( PlayerState.PlayState >= PLS_PLAYING )
	{
	    noscrolltracks = NOSCROLLTRACKS_TICKS;
	}

	UpdatePlayTime();
	UpdateGadgets();
    }
}




/* This is nothing other than an upcoding of RangeRand() from
 * amiga.lib.  We upcode it to avoid problems with accessing
 * the global "randomseed" variable, which is a pain because
 * we're using the blink library-generation stuff.
 */
static UWORD
randomNumber( ULONG range )
{
    ULONG iterations = range-1;

    while ( iterations )
    {
	ULONG overflow = 0;
	if ( randomseed & 0x80000000 )
	{
	    overflow = 1;
	}
	randomseed *= 2;
	if ( overflow )
	{
	    randomseed ^= 0x1D872B41;
	}
	iterations >>= 1;
    }
    return( ( ( randomseed & 0xFFFF ) * range ) >> 16 );
}

@


1.17
log
@Now handle the new colon gadget which controls whether the colon in
the track time display is on or off.
@
text
@d1 1
a1 1
/* $Id: gadgets.c,v 1.16 93/03/31 18:01:10 peter Exp Locker: peter $ */
d94 1
d879 1
a879 1
    for( i = 0; i < 20; i++ )
d953 2
a954 1
    for ( i = 0; i != NENTRIES; i++ )
d957 4
d987 1
a987 1
    for ( i = 0; i != NENTRIES; i++ )
d992 1
d1022 4
d1149 8
a1170 27

/********************** Reset Default PlayList ***********************/

void
ResetPlayList( void )
{
WORD           i;

    MasterIB->ib_GState[PLGAD_SHUFF] = 0;
    /* Set playlist back to zero */
    MasterIB->ib_TrackTableOffset = 0;

    UpdatePlayTime(); while (!ModifyPlayList(1));

    PlayList->EntryCount = 0;

    for ( i = 0; i < TOC[0].Summary.LastTrack; i++ )
    {
	PlayList->Entry[i] = (UBYTE)PLEF_ENABLE | (i+1);
    }

    PlayList->EntryCount = TOC[0].Summary.LastTrack;

    ModifyPlayList(0);

    UpdateGadgets();
}
@


1.16
log
@Now references /screencoords.h.
@
text
@d1 1
a1 1
/* $Id: gadgets.c,v 1.15 93/03/31 15:15:57 peter Exp Locker: peter $ */
d127 1
d311 1
@


1.15
log
@Now use more #defined constants for screen coordinates.  Changes to
support new audio panel graphic and new GOCDG gadget.  Gave meaningful
names to the former ib_D0, ib_D1, and ib_D2.  DoBoxMove() supports
gadgets that are made non-selectable.  Now ensures that highlight
is in track-table when processing togglegnum().  Now includes random
number generator in C.
@
text
@d1 1
a1 1
/* $Id: gadgets.c,v 1.14 93/03/25 23:02:28 peter Exp Locker: peter $ */
d26 1
a26 2
#include "gadgets.h"

@


1.14
log
@DoBoxMove() now sets noscrolltracks before and after moving the box.
@
text
@d1 1
a1 1
/* $Id: gadgets.c,v 1.13 93/03/25 19:37:05 peter Exp Locker: peter $ */
d26 2
a38 1
UWORD __stdargs RangeRand( unsigned long maxValue );
a82 1
extern LONG ShuffleMode;
d100 2
a101 1
static GADTrackNum(), GADGridNumber(), RDisk(), RCounter();
d108 1
d117 4
a120 4
static UWORD d_STOP[]   = {104,28,   130,28 };
static UWORD d_REV[]    = {  0,28,    26,28 };
static UWORD d_PLAY[]   = {156,155,  200,155,   244,155 };
static UWORD d_FF[]     = { 52,28,    78,28 };
d122 6
a127 6
static UWORD d_TIME[]   = { 0, 74,   48, 74,    96, 74,   144,74 };
static UWORD d_NEG[]	= { 0, 55,    6, 55 };
static UWORD d_SHUFF[]  = { 0,101,   48,101 };
static UWORD d_REPEAT[] = { 0,155,   48,155,   155,155,   203,155 };
static UWORD d_INTRO[]  = { 0,182,   48,182,    96,182,   144,182,   192,182,   240,182 };
static UWORD d_CDG[]    = { 0,209,   48,209,   192,128,   240,128 };
d133 1
a133 1
    0,0,8,9,
d142 1
a142 1
    0,9,14,19,
d151 1
a151 1
    0,9,14,19,
d160 1
a160 1
    176,29,16,23,
d183 2
a184 2
 * d_GADBigButtons[] is for the regular buttons like Intro, Repeat, etc.
 * d_GADMedButtons[] is for the play/pause button.
d190 1
d206 1
d213 1
d216 1
a216 1
    INS_DRAW,   22,1,
d219 2
a220 2
    INS_MOVE,   23,2,
    INS_DRAW,   23,24,
d223 1
a223 1
    INS_MOVE,   22,25,
d229 1
d236 1
d238 2
a239 2
    INS_MOVE,   3,1,
    INS_DRAW,   40,1,
d242 2
a243 2
    INS_MOVE,   41,2,
    INS_DRAW,   41,24,
d246 2
a247 2
    INS_MOVE,   40,25,
    INS_DRAW,   3,25,
d250 3
a252 2
    INS_MOVE,   2,24,
    INS_DRAW,   2,2,
d266 1
d270 1
d274 12
a285 9
    { PLGAD_STOP,    0x80, KEY_STOP,     0,   2,       PLGAD_TIME,   PLGAD_NL,     PLGAD_FF,     PLGAD_INTRO,  112, 154, 138, 181, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_STOP   },
    { PLGAD_REV,     0x80, KEY_BACK,     0,   2,       PLGAD_TIME,   PLGAD_NL,     PLGAD_CDG,    PLGAD_PLAY,   4,   154, 30,  181, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_REV    },
    { PLGAD_PLAY,    0x80, KEY_PLAYPAUSE,0,   3,       PLGAD_TIME,   PLGAD_NL,     PLGAD_REV,    PLGAD_FF,     34,  154, 78,  181, GADInsDraw, &d_GADMedButtons,   RNormal,       &d_PLAY   },
    { PLGAD_FF,      0x80, KEY_FWD,      0,   2,       PLGAD_TIME,   PLGAD_NL,     PLGAD_PLAY,   PLGAD_STOP,   82,  154, 108, 181, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_FF     },
    { PLGAD_TIME,    0x80, KEY_TIMEMODE, 0,   4,       PLGAD_16,     PLGAD_INTRO,  PLGAD_REPEAT, PLGAD_SHUFF,  155, 115, 203, 142, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_TIME   },
    { PLGAD_SHUFF,   0x80, KEY_SHUFFLE,  0,   2,       PLGAD_18,     PLGAD_CDG,    PLGAD_TIME,   PLGAD_REPEAT, 216, 115, 264, 142, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_SHUFF  },
    { PLGAD_INTRO,   0x80, KEY_INTRO,    0,   6,       PLGAD_TIME,   PLGAD_1,      PLGAD_STOP,   PLGAD_CDG,    155, 154, 203, 181, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_INTRO  },
    { PLGAD_REPEAT,  0x80, KEY_REPEAT,   0,   4,       PLGAD_20,     PLGAD_5,      PLGAD_SHUFF,  PLGAD_TIME,   268, 115, 316, 142, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_REPEAT },
    { PLGAD_CDG,     0x80, KEY_CDG,      0,   4,       PLGAD_SHUFF,  PLGAD_3,      PLGAD_INTRO,  PLGAD_REV,    207, 154, 255, 181, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_CDG    },
d288 3
a290 3
    { PLGAD_3,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_CDG,    PLGAD_8,      PLGAD_2,      PLGAD_4,      223, 3,   247, 19,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_4,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_CDG,    PLGAD_9,      PLGAD_3,      PLGAD_5,      257, 3,   281, 19,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_5,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_CDG,    PLGAD_10,     PLGAD_4,      PLGAD_6,      291, 3,   315, 19,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
d301 10
a310 8
    { PLGAD_16,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_11,     PLGAD_TIME,   PLGAD_15,     PLGAD_17,     155, 72,  179, 88,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_17,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_12,     PLGAD_TIME,   PLGAD_16,     PLGAD_18,     189, 72,  213, 88,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_18,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_13,     PLGAD_SHUFF,  PLGAD_17,     PLGAD_19,     223, 72,  247, 88,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_19,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_14,     PLGAD_REPEAT, PLGAD_18,     PLGAD_20,     257, 72,  281, 88,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_20,      0x0A, KEY_GBUTTON,  0, 255,       PLGAD_15,     PLGAD_REPEAT, PLGAD_19,     PLGAD_NL,     291, 72,  315, 88,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_MIN,     0x00, 0,            0, 101,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     39,  119, 68,  137, NOOP,       NULL,               GADNumber,     &d_MinNumberData },
    { PLGAD_SEC,     0x00, 0,            0, 101,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     79,  119, 108, 137, NOOP,       NULL,               GADNumber,     &d_SecNumberData },
    { PLGAD_NEG,     0x00, 0,            0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     30,  127, 36,  130, NOOP,       NULL,               RNormal,       &d_NEG             },
d585 1
a585 1
UWORD state;
d587 1
a587 1
    state = MasterIB->ib_GState[PLGAD_COUNTER];
d592 1
a592 1
    if ( state & COUNTER_FLYING )
d597 1
a597 1
    gad.LeftEdge   = (state & COUNTER_TRACKNUM);
d603 1
a603 1
    return(g->Flags & GDFLAGS_BOXOVER);
d641 28
d714 1
a714 1
    orgpos = MasterIB->ib_D0;
d716 1
a716 1
    MasterIB->ib_D0 += 5;
d720 1
a720 1
    return((MasterIB->ib_D0 == orgpos ? 0:1));
d730 1
a730 1
    if (MasterIB->ib_D0 >= 5) MasterIB->ib_D0 -= 5;
d791 4
d800 20
a819 1
    DoBoxMoveGrunt(event);
d844 1
a844 1
    /* Should be unnecessary as ib_D0 should already be an exact
d847 1
a847 1
    pos = (MasterIB->ib_D0/5) * 5;
d872 1
a872 1
    MasterIB->ib_D0 = pos;
d903 1
a903 1
    MasterIB->ib_D2 = 0;
d915 1
a915 1
	    while ( PlayerState.ListIndex < MasterIB->ib_D0 )
d917 1
a917 1
		MasterIB->ib_D0 -= 5;
d919 1
a919 1
	    while ( PlayerState.ListIndex >= MasterIB->ib_D0 + 20 )
d921 1
a921 1
		MasterIB->ib_D0 += 5;
d924 1
a924 1
	current = PlayerState.ListIndex - MasterIB->ib_D0;
d927 2
a928 2
	    MasterIB->ib_D2 = PLGAD_1 + current;
	    MasterIB->ib_GState[ MasterIB->ib_D2 ] |= GRID_CURRENT;
d948 1
a948 1
    MasterIB->ib_D0 = 0;
d961 1
a961 1
ShuffleGrid( void )
d971 1
a971 1
    MasterIB->ib_D0 = 0;
d975 1
a975 1
    if ( !ShuffleMode )
a978 1
    ShuffleMode = 1;
d993 1
a993 1
	    r = RangeRand( UndoPlayList->EntryCount );
d999 1
a999 1
	    d = RangeRand(2);
d1124 1
a1124 1
    pos = MasterIB->ib_D0 + (MasterIB->ib_BoxNo - PLGAD_1);
d1126 5
a1130 1
    if (pos >= PlayList->EntryCount) return;
d1161 1
a1161 1
    MasterIB->ib_D0 = 0;
d1178 28
@


1.13
log
@Now lets user scroll around track table even while playing.
@
text
@d1 1
a1 1
/* $Id: gadgets.c,v 1.12 93/03/19 18:58:01 peter Exp Locker: peter $ */
d700 1
a700 1
void
d737 8
a744 4
/* Invoke the real DoBoxMove() function, but upon exit, check to see if we're
 * currently in the track table.  If we do, we reset the noscrolltracks shot
 * counter, which is the timeout during which the player will refuse to
 * automatically scroll so as to put the currently playing track into view.
d748 5
d754 5
a758 1
    if ( ( MasterIB->ib_BoxNo >= PLGAD_1 ) && ( MasterIB->ib_BoxNo <= PLGAD_20 ) )
d1068 6
@


1.12
log
@Assured laser is rendered over CD by swapping PLGAD_DISK and PLGAD_COUNTER's
order.  Now use KEY_xxx instead of DIR_xxx.
@
text
@d1 1
a1 1
/* $Id: gadgets.c,v 1.11 93/03/17 16:55:45 peter Exp Locker: peter $ */
d83 1
d701 1
a701 1
DoBoxMove(UWORD event)
d737 14
d829 18
a846 4
	/* Light up the currently playing track, and ensure that
	 * it's scrolled into view.
	 */
	while ( PlayerState.ListIndex < MasterIB->ib_D0 )
d848 2
a849 1
	    MasterIB->ib_D0 -= 5;
a850 7
	while ( PlayerState.ListIndex >= MasterIB->ib_D0 + 20 )
	{
	    MasterIB->ib_D0 += 5;
	}

	MasterIB->ib_D2 = PLGAD_1 + PlayerState.ListIndex - MasterIB->ib_D0;
	MasterIB->ib_GState[ MasterIB->ib_D2 ] |= GRID_CURRENT;
@


1.11
log
@Now handle screen centering.  No longer guru 5 if disk is removed
before we even start.  Optimized blits to take advantage of the
fact that the background is now color zero, and to blit only the
minimum necessary number of pixels.
@
text
@d1 1
a1 1
/* $Id: gadgets.c,v 1.10 93/03/08 18:23:17 peter Exp Locker: peter $ */
d250 7
d260 1
a261 1
    { PLGAD_DISK,    0x00, 0,            0, 25,        PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     279, 160, 307, 180, NOOP,       NULL,               RDisk,         NULL               },
d265 1
a265 1
    { PLGAD_PLAY,    0x80, KEY_PLAY,     0,   3,       PLGAD_TIME,   PLGAD_NL,     PLGAD_REV,    PLGAD_FF,     34,  154, 78,  181, GADInsDraw, &d_GADMedButtons,   RNormal,       &d_PLAY   },
d313 2
a314 2
 * The state bit of HEAD_LASERON means the laser is on, and is ignored
 * by this routine.  The state bit of HEAD_FLYING means that the head-gadget
d317 1
a317 1
 * If HEAD_FLYING is not set, the state value reflects the desired head
d332 1
a332 1
    if ( loc & HEAD_FLYING )
d337 1
a337 1
	else            *y = pos[loc & HEAD_TRACKNUM] + YOFF;
d343 1
a343 1
	loc &= HEAD_TRACKNUM;
d376 1
a376 1
    if ( old & HEAD_LASERON )
d378 1
a378 1
	/* HEAD_LASERON means laser is on in old state.  Since the laser
d397 1
a397 1
    if ( old & HEAD_LASERON )
d412 1
a412 1
	if ( new & HEAD_LASERON )
d414 1
a414 1
	    /* HEAD_LASERON means laser is on in new state.  This blit draws
d576 1
a576 1
    if ( state & HEAD_FLYING )
d581 1
a581 1
    gad.LeftEdge   = (state & HEAD_TRACKNUM);
d710 1
a710 1
    if ((event == DIR_LEFT) && (MasterIB->ib_BoxNo == PLGAD_1)) if (ScrollGridDown())
d716 1
a716 1
    if ((event == DIR_RIGHT) && (MasterIB->ib_BoxNo == PLGAD_20)) if (ScrollGridUp())
d722 1
a722 1
    if ((event == DIR_UP) && (f & PLFLAGS_SCROLLUP)) if (ScrollGridDown())
d727 1
a727 1
    if ((event == DIR_DOWN) && (f & PLFLAGS_SCROLLDOWN)) if (ScrollGridUp())
d782 1
d974 1
a974 1
    if ( !( MasterIB->ib_GState[PLGAD_COUNTER] & HEAD_FLYING ) )
d985 1
a985 1
	    loc = MasterIB->ib_GState[PLGAD_COUNTER] & HEAD_TRACKNUM;
d1010 1
a1010 1
	    MasterIB->ib_GState[PLGAD_COUNTER] |= HEAD_LASERON;
@


1.10
log
@Use state definitions, minor cleanup.  Changed where includes come
from.  Fixed arrow navigation table.  Interchanged repeat and CD+G
gadgets.  CD-Disk image no longer needs a piece of the background
pattern to blit right.  Fixed scroll limits on track table.
@
text
@d1 1
a1 1
/* $Id: gadgets.c,v 1.9 93/03/03 13:32:37 peter Exp Locker: peter $ */
d23 3
d92 3
d105 1
a105 1
static LONG secperpixel;
d158 1
a158 1
    20,79,24,2,
d249 1
d252 36
a287 36
/*  { ID,            Flags,KeyTrans,routine,MaxStates, Up,           Down,         Left,         Right,        L,   T,   R,   B,   BoxFunc,    BoxData,            RenderFunc,    RenderData }, */
    { PLGAD_COUNTER, 0x00, 0,            0, TCOUNTMAX, PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     293, 214, 321, 234, NOOP,       NULL,               RCounter,      NULL               },
    { PLGAD_DISK,    0x00, 0,            0, 38,        PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     293, 214, 321, 234, NOOP,       NULL,               RDisk,         NULL               },
    { PLGAD_TTRACK,  0x00, 0,            0, 100,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     293, 214, 321, 234, NOOP,       NULL,               GADTrackNum,   &d_TrackNumberData },
    { PLGAD_STOP,    0x80, KEY_STOP,     0,   2,       PLGAD_TIME,   PLGAD_NL,     PLGAD_FF,     PLGAD_INTRO,  126, 208, 152, 235, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_STOP   },
    { PLGAD_REV,     0x80, KEY_BACK,     0,   2,       PLGAD_TIME,   PLGAD_NL,     PLGAD_CDG,    PLGAD_PLAY,   18,  208, 44,  235, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_REV    },
    { PLGAD_PLAY,    0x80, KEY_PLAY,     0,   3,       PLGAD_TIME,   PLGAD_NL,     PLGAD_REV,    PLGAD_FF,     48,  208, 92,  235, GADInsDraw, &d_GADMedButtons,   RNormal,       &d_PLAY   },
    { PLGAD_FF,      0x80, KEY_FWD,      0,   2,       PLGAD_TIME,   PLGAD_NL,     PLGAD_PLAY,   PLGAD_STOP,   96,  208, 122, 235, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_FF     },
    { PLGAD_TIME,    0x80, KEY_TIMEMODE, 0,   4,       PLGAD_16,     PLGAD_INTRO,  PLGAD_REPEAT, PLGAD_SHUFF,  169, 169, 216, 195, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_TIME   },
    { PLGAD_SHUFF,   0x80, KEY_SHUFFLE,  0,   2,       PLGAD_18,     PLGAD_CDG,    PLGAD_TIME,   PLGAD_REPEAT, 231, 169, 278, 195, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_SHUFF  },
    { PLGAD_INTRO,   0x80, KEY_INTRO,    0,   6,       PLGAD_TIME,   PLGAD_1,      PLGAD_STOP,   PLGAD_CDG,    169, 208, 216, 234, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_INTRO  },
    { PLGAD_REPEAT,  0x80, KEY_REPEAT,   0,   4,       PLGAD_20,     PLGAD_5,      PLGAD_SHUFF,  PLGAD_TIME,   283, 169, 330, 195, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_REPEAT },
    { PLGAD_CDG,     0x80, KEY_CDG,      0,   4,       PLGAD_SHUFF,  PLGAD_3,      PLGAD_INTRO,  PLGAD_REV,    221, 208, 268, 234, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_CDG    },
    { PLGAD_1,       0x05, KEY_GBUTTON,  0, 255,       PLGAD_INTRO,  PLGAD_6,      PLGAD_NL,     PLGAD_2,      169, 57,  193, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_2,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_INTRO,  PLGAD_7,      PLGAD_1,      PLGAD_3,      203, 57,  227, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_3,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_CDG,    PLGAD_8,      PLGAD_2,      PLGAD_4,      237, 57,  261, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_4,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_CDG,    PLGAD_9,      PLGAD_3,      PLGAD_5,      271, 57,  295, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_5,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_CDG,    PLGAD_10,     PLGAD_4,      PLGAD_6,      305, 57,  329, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_6,       0x00, KEY_GBUTTON,  0, 255,       PLGAD_1,      PLGAD_11,     PLGAD_5,      PLGAD_7,      169, 80,  193, 96,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_7,       0x00, KEY_GBUTTON,  0, 255,       PLGAD_2,      PLGAD_12,     PLGAD_6,      PLGAD_8,      203, 80,  227, 96,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_8,       0x00, KEY_GBUTTON,  0, 255,       PLGAD_3,      PLGAD_13,     PLGAD_7,      PLGAD_9,      237, 80,  261, 96,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_9,       0x00, KEY_GBUTTON,  0, 255,       PLGAD_4,      PLGAD_14,     PLGAD_8,      PLGAD_10,     271, 80,  295, 96,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_10,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_5,      PLGAD_15,     PLGAD_9,      PLGAD_11,     305, 80,  329, 96,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_11,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_6,      PLGAD_16,     PLGAD_10,     PLGAD_12,     169, 103, 193, 119, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_12,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_7,      PLGAD_17,     PLGAD_11,     PLGAD_13,     203, 103, 227, 119, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_13,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_8,      PLGAD_18,     PLGAD_12,     PLGAD_14,     237, 103, 261, 119, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_14,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_9,      PLGAD_19,     PLGAD_13,     PLGAD_15,     271, 103, 295, 119, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_15,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_10,     PLGAD_20,     PLGAD_14,     PLGAD_16,     305, 103, 329, 119, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_16,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_11,     PLGAD_TIME,   PLGAD_15,     PLGAD_17,     169, 126, 193, 142, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_17,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_12,     PLGAD_TIME,   PLGAD_16,     PLGAD_18,     203, 126, 227, 142, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_18,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_13,     PLGAD_SHUFF,  PLGAD_17,     PLGAD_19,     237, 126, 261, 142, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_19,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_14,     PLGAD_REPEAT, PLGAD_18,     PLGAD_20,     271, 126, 295, 142, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_20,      0x0A, KEY_GBUTTON,  0, 255,       PLGAD_15,     PLGAD_REPEAT, PLGAD_19,     PLGAD_NL,     305, 126, 329, 142, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_MIN,     0x00, 0,            0, 101,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     53,  173, 82,  191, NOOP,       NULL,               GADNumber,     &d_MinNumberData },
    { PLGAD_SEC,     0x00, 0,            0, 101,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     93,  173, 122, 191, NOOP,       NULL,               GADNumber,     &d_SecNumberData },
    { PLGAD_NEG,     0x00, 0,            0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     44,  181, 50,  184, NOOP,       NULL,               RNormal,       &d_NEG             },
d318 5
a322 1
    -47,-34,-22,-11,-1,8,17,25,32,38,43,47,51,55,58,61,64,66,68,69,70,71
d328 3
a330 3
	*x = 20;
	if (loc >= 20)  *y = 43;
	else            *y = pos[loc & HEAD_TRACKNUM];
d338 2
a339 2
	*y = 71;
	*x = 20+loc;
a362 1
extern struct BitMap    *bm;
d372 1
a372 1
	 * overwrites the CD, we have to blit the CD back into place to
d376 2
a377 2
	 * we obliterate the part of the laser that's between the head
	 * and the CD.
d384 5
a388 2
	/* This erases the head gadget */
	BltBitMap(bm, xloc, yloc, rp->BitMap, xloc, yloc, 80, dsize, 0xc0, 0xff, NULL);
d392 4
a395 1
	BltMaskBitMapRastPort(bbm, 96, 209, rp, 52, 128, 106, 16, (ABC|ABNC|ANBC), bmask);
d403 1
a403 1
	BltMaskBitMapRastPort(bbm, 96, dpos, rp, xloc, yloc, 96, dsize, (ABC|ABNC|ANBC), bmask);
a432 1
 * global bm = screen's initial BitMap (foreground only?)
a438 1
extern struct BitMap   *bm;
d442 2
d447 30
a476 3
    0,52,51,50,47,44,40,35,30,24,17,10,2,-7,-17,-28,
    -43,-58,-74,-91,-112,-134,-157,-181,-206
};
d478 3
a480 6
int            overlen;

    /* Here we erase the CD by blitting from the backing store */
    BltBitMap(bm, 0, 128, rp->BitMap, 0, 128, 267, 18, 0xc0, 0xff, NULL);

    if (new)
d485 3
a487 1
	if (new < 24)
d489 58
a546 8
	    xloc = nums[new];

	    if (xloc < 0)
	    {
		dpos -= xloc;
		dwidth += xloc;
		xloc = 0;
	    }
d548 3
a550 12
	    /* Draw the CD sliding in or out */
	    BltMaskBitMapRastPort(bbm, dpos, 209, rp, xloc, 128, dwidth, 18, (ABC|ABNC|ANBC), bmask);

	    overlen = xloc+dwidth - 165;

	    /* The CD might have been rendered over part of the track table.
	     * We keep a spare masked copy on the scrbuttons screen, and
	     * right here, we blit it back over so the CD goes behind,
	     * as we wished.
	     */
	    if (overlen > 0) BltMaskBitMapRastPort(bbm, 192,74, rp, 165,123, overlen, 23, (ABC|ABNC|ANBC), bmask);
	}
a551 6

    /* Restore destroyed grid */
    if (MasterIB->ib_GState[PLGAD_16]) GADNumber(rp, bbm, &MasterIB->ib_GadList[PLGAD_16], -1, MasterIB->ib_GState[PLGAD_16]);
    if (MasterIB->ib_GState[PLGAD_17]) GADNumber(rp, bbm, &MasterIB->ib_GadList[PLGAD_17], -1, MasterIB->ib_GState[PLGAD_17]);
    if (MasterIB->ib_GState[PLGAD_18]) GADNumber(rp, bbm, &MasterIB->ib_GadList[PLGAD_18], -1, MasterIB->ib_GState[PLGAD_18]);

a555 2


d574 1
a574 1
    gad.LeftEdge   = 20+(state & HEAD_TRACKNUM);
d658 1
a658 1
int
d674 1
a674 1
int
d966 6
a971 1
    pos = TCOUNTMAX - (currsec/secperpixel);
d973 6
a978 2
    if (pos >= TCOUNTMAX) pos = TCOUNTMAX-1;
    if (pos < 0)          pos = 0;
d980 7
a986 1
    if (now) loc = pos;
d988 7
a994 4
    else
    {
	loc = MasterIB->ib_GState[PLGAD_COUNTER] & HEAD_TRACKNUM;
	pos -= loc;
d996 1
a996 6
	if (pos < 0)
	{
	    move = -2;
	    if (pos >= -2) move = pos;
	    if (pos < -5)  move = -3;
	    if (pos < -10) move = -4;
d999 2
a1000 1
	else
d1002 1
a1002 4
	    move = 2;
	    if (pos <= 2) move = pos;
	    if (pos > 5)  move = 3;
	    if (pos > 10) move = 4;
a1003 8

	loc += move;
    }

    MasterIB->ib_GState[PLGAD_COUNTER] = loc;
    if ( PlayerState.PlayState >= PLS_PLAYING )
    {
	MasterIB->ib_GState[PLGAD_COUNTER] |= HEAD_LASERON;
a1007 1

d1033 1
a1033 1
/********************** Clear/Reset Default PlayList ***********************/
d1036 1
a1036 1
ResetPlayList(int clear)
d1048 1
a1048 1
    if ( !clear )
d1050 2
a1051 4
	for ( i = 0; i < TOC[0].Summary.LastTrack; i++ )
	{
	    PlayList->Entry[i] = (UBYTE)PLEF_ENABLE | (i+1);
	}
d1053 1
a1053 2
	PlayList->EntryCount = TOC[0].Summary.LastTrack;
    }
@


1.9
log
@Fixed off-by-one error in position of CD+G imagery for one state.
@
text
@d1 1
a1 1
/* $Id: gadgets.c,v 1.8 93/02/26 19:03:20 peter Exp Locker: peter $ */
d18 2
a19 2
#include <gs:cd/cd.h>
#include <cdtv/debox.h>
a28 1
#include "/cdtvkeys.h"
d48 2
a49 1
#define TCOUNTMAX   59                                                      /* Max pos for track counter */
a87 1
extern UWORD volatile __far     vhposr;                                     /* Custom chip register. */
d118 1
a118 1
static UWORD d_CDG[]    = { 0,209,   48,209,   192,128,   240,128,   288,128 };
d245 1
d249 4
a252 4
    { PLGAD_STOP,    0x80, KEY_STOP,     0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_FF,     PLGAD_INTRO,  126, 208, 152, 235, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_STOP   },
    { PLGAD_REV,     0x80, KEY_BACK,     0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_CDG,    PLGAD_PLAY,   18,  208, 44,  235, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_REV    },
    { PLGAD_PLAY,    0x80, KEY_PLAY,     0,   3,       PLGAD_NL,     PLGAD_NL,     PLGAD_REV,    PLGAD_FF,     48,  208, 92,  235, GADInsDraw, &d_GADMedButtons,   RNormal,       &d_PLAY   },
    { PLGAD_FF,      0x80, KEY_FWD,      0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_PLAY,   PLGAD_STOP,   96,  208, 122, 235, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_FF     },
d254 5
a258 5
    { PLGAD_SHUFF,   0x80, KEY_SHUFFLE,  0,   2,       PLGAD_18,     PLGAD_REPEAT, PLGAD_TIME,   PLGAD_CDG,    231, 169, 278, 195, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_SHUFF  },
    { PLGAD_INTRO,   0x80, KEY_INTRO,    0,   6,       PLGAD_TIME,   PLGAD_1,      PLGAD_STOP,   PLGAD_REPEAT, 169, 208, 216, 234, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_INTRO  },
    { PLGAD_REPEAT,  0x80, KEY_REPEAT,   0,   4,       PLGAD_SHUFF,  PLGAD_3,      PLGAD_INTRO,  PLGAD_TIME,   221, 208, 268, 234, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_REPEAT },
    { PLGAD_CDG,     0x80, KEY_CDG,      0,   5,       PLGAD_20,     PLGAD_CDG,    PLGAD_SHUFF,  PLGAD_REV,    283, 169, 330, 195, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_CDG    },
    { PLGAD_1,       0x05, KEY_GBUTTON,  0, 255,       PLGAD_INTRO,  PLGAD_6,      PLGAD_REPEAT, PLGAD_2,      169, 57,  193, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
d260 3
a262 3
    { PLGAD_3,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_REPEAT, PLGAD_8,      PLGAD_2,      PLGAD_4,      237, 57,  261, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_4,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_REPEAT, PLGAD_9,      PLGAD_3,      PLGAD_5,      271, 57,  295, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_5,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_REPEAT, PLGAD_10,     PLGAD_4,      PLGAD_6,      305, 57,  329, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
d276 2
a277 2
    { PLGAD_19,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_14,     PLGAD_SHUFF,  PLGAD_18,     PLGAD_20,     271, 126, 295, 142, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_20,      0x0A, KEY_GBUTTON,  0, 255,       PLGAD_15,     PLGAD_CDG,    PLGAD_19,     PLGAD_TIME,   305, 126, 329, 142, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
a285 3



d299 2
a300 2
 * The state bit of 0x4000 means the laser is on, and is ignored
 * by this routine.  The state bit of 0x8000 means that the head-gadget
d303 1
a303 1
 * If 0x8000 is not set, the state value reflects the desired head
d314 1
a314 1
    if (loc & 0x8000)                                                                              /* Vertical movememt */
d316 1
d319 1
a319 1
	else            *y = pos[loc & 0xfff];
d322 1
a322 1
    else                                                                                           /* Horizontal movement */
d324 2
a325 1
	loc &= 0xfff;
d331 2
a332 1
    *dpos  = 101;                                                                                   /* Default gadget dimensions */
d335 2
a336 1
    if (*y<0)                                                                                      /* Clip the gadget if off screen */
d356 2
a357 1
    getcounterbase(old, &xloc, &yloc, &dpos, &dsize);                                                                   /* erase old */
d359 1
a359 2
    /* 0x4000 means laser is on in old state */
    if (old & 0x4000)
d361 9
a369 2
	dsize = 57;
	BltBitMap(bbm, 96, 209, rp->BitMap, 52, 128, 80, 16 ,0xc0, 0xff, NULL);
d374 1
d377 4
d386 1
d389 1
a389 2
	/* 0x4000 means laser is on in new state */
	if (new & 0x4000)
d391 3
d398 5
a402 1
    WorkIB->ib_GState[PLGAD_TTRACK] = CurrentIB->ib_GState[PLGAD_TTRACK] = 0;
d470 2
a471 1
    if (MasterIB->ib_GState[PLGAD_16]) GADNumber(rp, bbm, &MasterIB->ib_GadList[PLGAD_16], -1, MasterIB->ib_GState[PLGAD_16]);         /* Restore destroyed grid */
d491 7
a497 1
    if (state & 0x8000) return(0);
d499 1
a499 1
    gad.LeftEdge   = 20+(state & 0xfff);
d533 1
a533 1
    if ((old ^ new) & 0x4000)
d537 1
a537 1
	GADInsDraw(rp, &gad, (new & 0x4000 ? 1:0), new);
a560 15
/******************** Set Grid Entry to Entered Number *********************/

int
SetNum( void )
{
    UpdatePlayTime(); while (!ModifyPlayList(1));

    MasterIB->ib_GState[PLGAD_SHUFF] = 0;

    MasterIB->ib_D1 = 0;

    return(0);
}


a627 6
    if (MasterIB->ib_D1)
    {
	if (SetNum()) return;                                                                                      /* Error in setting number don't move */
	UpdatePlayTime();
    }

d663 1
a663 1
WORD   pos,i;
d665 1
a665 1
UWORD *gs;                                                                                         /* D0 is the position */
d667 4
d673 2
a674 1
    if (pos + 19 >= PlayList->EntryCount)                                                                  /* Scroll upwards until the 20th position is filled with a blank */
d676 1
a676 4
	while((pos + 14 >= PlayList->EntryCount) && (pos > 0)) pos-=5;

	if (pos < 0)  pos = 0;
	if (pos > 80) pos = 80;                                                                             /* Limit the hundred area */
d678 6
a683 5

    MasterIB->ib_D0 = pos;

    for(i=0,pe=&PlayList->Entry[pos],gs=&MasterIB->ib_GState[PLGAD_1];
	(i<20)&&(pos<PlayList->EntryCount); i++,pe++,gs++,pos++)
d685 1
a685 3
	if (!*pe)                   *gs = 0;
	else if (*pe & PLEF_ENABLE) *gs = *pe & PLEF_TRACK;
	else                        *gs = 0x8000 + (*pe & PLEF_TRACK);
d688 9
a696 1
    for(; i<20; i++) *gs++ = 0;
d698 3
a700 3
    MasterIB->ib_D2 = 0;                                                                                         /* Set the lit number if it is playing */

    if (PlayerState.PlayState == PLS_SELECTED || PlayerState.PlayState >= PLS_PLAYING)
d702 13
a714 1
	if ((PlayerState.ListIndex >= MasterIB->ib_D0) && (PlayerState.ListIndex < MasterIB->ib_D0+20))
d716 2
a717 2
	    MasterIB->ib_D2 = PLGAD_1 + PlayerState.ListIndex - MasterIB->ib_D0;
	    MasterIB->ib_GState[ MasterIB->ib_D2 ] |= 0x4000;
d719 27
a745 1
    }
a750 2


d753 3
d766 4
a769 1
    for (i=0; i!=100; i++) PlayList->Entry[i] = UndoPlayList->Entry[i];
a772 2
    UpdateGadgets();
    UpdateDisplay();
d780 2
a781 1
    UpdatePlayTime(); while (!ModifyPlayList(1));
d783 2
a784 1
    for(i=PLGAD_1; i<=PLGAD_20; i++) MasterIB->ib_GState[i] = 0x0000;                                                        /* Blank grid before we display our changes */
a794 1

d796 4
a799 1
    for (i=0; i!=100; i++) PlayList->Entry[i] = 0;
d802 2
a803 1
    for(i=0; i<UndoPlayList->EntryCount; i++)                                                                      /* Generate random list from 'undo' list. */
d807 5
a811 1
	do r = RangeRand(UndoPlayList->EntryCount); while(++j<10 && PlayList->Entry[r]);
d817 2
a818 1
	    while (PlayList->Entry[r])                                                                             /* Find the r'th unused entry. */
d900 1
a900 1
	loc = MasterIB->ib_GState[PLGAD_COUNTER] & 0xfff;
d922 5
a926 1
    MasterIB->ib_GState[PLGAD_COUNTER] = loc + (PlayerState.PlayState >= PLS_PLAYING ? 0x4000:0);
a945 2
	if (MasterIB->ib_D1) SetNum();

d964 2
a965 1
    MasterIB->ib_D0 = 0;                                                                                                 /* Set playlist back to zero */
d969 1
a969 1
    if (clear) PlayList->EntryCount = 0;
d971 1
a971 1
    else
d973 4
a976 1
	for (i=0; i<TOC[0].Summary.LastTrack; i++) PlayList->Entry[i] = (UBYTE)PLEF_ENABLE | (i+1);
@


1.8
log
@Major work.  Intuitionized.  Prototyped.  Improved behavior.  Added comments.
@
text
@d1 1
a1 1
/* $Id: $ */
d119 1
a119 1
static UWORD d_CDG[]    = { 0,209,   48,209,   191,128,   240,128,   288,128 };
@


1.7
log
@First round of major improvements by Peter.
@
text
@d1 1
d24 1
d34 2
a35 1
#include <cdtv/debox_protos.h>
d40 1
a40 1
#include <cdtv/debox_pragmas.h>
d42 3
a44 3
#include "cdgs:include/internal/playerlibrary.h"
#include "cdgs:include/internal/player_protos.h"
#include "cdgs:include/internal/player_pragmas.h"
d54 1
a70 1
extern struct CycleIntInfo      intdata;
d72 3
a74 1
extern struct DisplayFrame     *CurrentF, *WorkF, MasterF;
a85 3
#if NUMBER_ENTRY
extern int                      NumericPadEnabled;
#endif
d92 2
a93 1
static NOOP();
a95 3
#if NUMBER_ENTRY
void   SetNumPad(void);
#endif
a99 2
static LONG diskstart;
static LONG disksec;
a101 3
static WORD enttrack, orgtrack;
static WORD enttrackpos = -1;

d119 1
a119 1
static UWORD d_CDG[]    = { 0,209,   48,209 };
d123 2
a124 2
struct GADNumberInfo d_GridNumberData = {

d130 1
a130 1
    };
d132 2
a133 2
struct GADNumberInfo d_MinNumberData = {

d139 1
a139 3
    };

struct GADNumberInfo d_SecNumberData = {
d141 2
d148 1
a148 1
    };
d150 2
a151 2
struct GADNumberInfo d_TrackNumberData = {

d157 1
a157 1
    };
d162 9
a170 1
struct GADSTDBox d_GridBoxInfo = {
a171 4
    -4,-3,33,23,
    { 1,1, 192,97 },
    { 1,1, 226,97 }
    };
a172 1

d174 4
a177 2
 * for different sized boxes.  The GadDir structure references
 * the appropriate one for each gadget.
d179 2
a180 2
BYTE d_GADBigButtons[] = {

d183 3
a185 2
    INS_MOVE,   2,1,
    INS_DRAW,   45,1,
d187 3
a189 1
    INS_DRAW,   45,25,
d191 3
a193 1
    INS_DRAW,   2,25,
d195 2
a196 1
    INS_DRAW,   2,1,
d198 1
a198 3
    };

BYTE d_GADSmallButtons[] = {
d200 2
d204 2
a205 2
    INS_MOVE,   2,1,
    INS_DRAW,   23,1,
d208 2
a209 2
    INS_MOVE,   24,2,
    INS_DRAW,   24,25,
d212 2
a213 2
    INS_MOVE,   23,26,
    INS_DRAW,   2,26,
d216 2
a217 2
    INS_MOVE,   1,25,
    INS_DRAW,   1,2,
d219 1
a219 1
    };
d221 2
a222 2
BYTE d_GADMedButtons[] = {

d225 2
a226 2
    INS_MOVE,   2,1,
    INS_DRAW,   41,1,
d229 2
a230 2
    INS_MOVE,   42,2,
    INS_DRAW,   42,25,
d233 2
a234 2
    INS_MOVE,   41,26,
    INS_DRAW,   2,26,
d237 2
a238 2
    INS_MOVE,   1,25,
    INS_DRAW,   1,2,
d240 1
a240 1
    };
d244 2
a245 2
struct GadDir PlayGADList[MAX_PLGAD + 1] = {

d255 1
a255 1
    { PLGAD_INTRO,   0x80, KEY_INTRO,    0,   6,       PLGAD_TIME,   PLGAD_1,      PLGAD_STOP,   PLGAD_REPEAT, 169, 208, 216, 234, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_INTRO  }, 
d257 1
a257 1
    { PLGAD_CDG,     0x80, KEY_CDG,      0,   2,       PLGAD_20,     PLGAD_CDG,    PLGAD_SHUFF,  PLGAD_REV,    283, 169, 330, 195, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_CDG    },
d283 1
a283 1
    };
d291 3
a293 2
static NOOP() {

d295 1
a295 1
    }
d301 26
a326 1
static void __regargs getcounterbase(WORD loc, WORD *x, WORD *y, WORD *dpos, WORD *dsize) {
d328 3
a330 15
static WORD pos[] = {

                -47,-34,-22,-11,-1,8,17,25,32,38,43,47,51,55,58,61,64,66,68,69,70,71
                };

    if (loc & 0x8000) {                                                                             /* Vertical movememt */

        *x = 20;
        if (loc >= 20)  *y = 43;
        else            *y = pos[loc & 0xfff];
        }

    else {                                                                                          /* Horizontal movement */

        loc &= 0xfff;
a331 4
        *y = 71;
        *x = 20+loc;
        }

d335 7
a341 7
    if (*y<0) {                                                                                     /* Clip the gadget if off screen */

        *dpos -= *y;
        *dsize += *y;
        *y = 0;     
        }
    }
d348 3
a350 2
static RCounter(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new) {

d357 11
a367 5
    if (old & 0x4000) {                                                                                                 /* old laser is on */

        dsize = 57;
        BltBitMap(bbm, 96, 209, rp->BitMap, 52, 128, 80, 16 ,0xc0, 0xff, NULL);
        }
a368 2
    if (dsize > 0) BltBitMap(bm, xloc, yloc, rp->BitMap, xloc, yloc, 80, dsize, 0xc0, 0xff, NULL);

d371 3
a373 1
    if (dsize > 0) {
d375 6
a380 1
        BltMaskBitMapRastPort(bbm, 96, dpos, rp, xloc, yloc, 96, dsize, (ABC|ABNC|ANBC), bmask);
d382 1
a382 4
        if (new & 0x4000) BltMaskBitMapRastPort(bbm, 97, 147, rp, xloc+12, yloc+37, 50, 34, (ABC|ABNC|ANBC), bmask);    /* new laser is on */
        }
        
    WorkF->gstate[PLGAD_TTRACK] = CurrentF->gstate[PLGAD_TTRACK] = 0;
d384 1
a384 1
    }
d401 3
a403 2
static RDisk(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new) {

d409 5
a413 5
static WORD             nums[] = { 

                            0,52,51,50,47,44,40,35,30,24,17,10,2,-7,-17,-28,
                            -43,-58,-74,-91,-112,-134,-157,-181,-206
                            };  
d415 1
a415 1
register int            overlen;
d420 4
a423 4
    if (new) {
    
        dpos   = 96;
        dwidth = 207;
d425 11
a435 11
        if (new < 24) {
    
            xloc = nums[new];
    
            if (xloc < 0) {

                dpos -= xloc;
                dwidth += xloc; 
                xloc = 0;
                }
    
d437 3
a439 1
            BltMaskBitMapRastPort(bbm, dpos, 209, rp, xloc, 128, dwidth, 18, (ABC|ABNC|ANBC), bmask);
a440 2
            overlen = xloc+dwidth - 165;
    
d446 3
a448 3
            if (overlen > 0) BltMaskBitMapRastPort(bbm, 192,74, rp, 165,123, overlen, 23, (ABC|ABNC|ANBC), bmask);
            }
        }
d450 3
a452 3
    if (MasterF.gstate[PLGAD_16]) GADNumber(rp, bbm, &MasterF.GadList[PLGAD_16], -1, MasterF.gstate[PLGAD_16]);         /* Restore destroyed grid */
    if (MasterF.gstate[PLGAD_17]) GADNumber(rp, bbm, &MasterF.GadList[PLGAD_17], -1, MasterF.gstate[PLGAD_17]);
    if (MasterF.gstate[PLGAD_18]) GADNumber(rp, bbm, &MasterF.GadList[PLGAD_18], -1, MasterF.gstate[PLGAD_18]);
d455 1
a455 1
    }
d462 3
a464 2
static GADTrackNum(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new) {

d467 2
a468 2
    
    state = MasterF.gstate[PLGAD_COUNTER];
d479 1
a479 1
    }
d486 3
a488 2
static GADGridNumber(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new) {

d491 2
a492 2
static BYTE gbox[] = {

d504 1
a504 1
    };
d506 6
a511 1
    if ((old ^ new) & 0x4000) {
a512 5
        CopyMem((char *)g, (char *)&gad, sizeof(struct GadDir));
        gad.BoxData = gbox;
        GADInsDraw(rp, &gad, (new & 0x4000 ? 1:0), new);
        }

d514 1
a514 1
    }
a521 1

d525 3
a527 2
void UpdatePlayTime() {

d531 4
a534 1
    }
d536 4
d541 1
d543 1
d545 2
a546 1
/************************* Get Gadget's Keycode ****************************/
a547 1
UWORD __regargs GetBoxKey(register struct DisplayFrame *mf, UWORD event) {
d549 1
a549 1
register UWORD ans;
d551 4
a554 1
    if (mf->BoxNo >= 0) {
d556 5
a560 3
        ans = mf->GadList[mf->BoxNo].KeyTrans + (event & IECODE_UP_PREFIX);
        return(ans);
        }
d563 1
a563 1
    }
d571 3
a573 2
ScrollGridUp() {

d576 1
a576 1
    orgpos = MasterF.D0;
d578 1
a578 1
    MasterF.D0 += 5;
d582 2
a583 3
    return((MasterF.D0 == orgpos ? 0:1));
    }

a585 1
ScrollGridDown() {
d587 3
d592 1
a592 1
    if (MasterF.D0 >= 5) MasterF.D0 -= 5;
d598 1
a598 1
    }
d605 5
a609 1
void DoBoxMove(UWORD event) {
a610 3
register UBYTE f;
register struct GadDir *g;

d613 1
a613 1
    g = &MasterF.GadList[MasterF.BoxNo];
d616 27
a642 38
    if (MasterF.D1) {
        if (SetNum()) return;                                                                                      /* Error in setting number don't move */
        UpdatePlayTime();
        }

    if ((event == DIR_LEFT) && (MasterF.BoxNo == PLGAD_1)) if (ScrollGridDown()) {

        MasterF.BoxNo = PLGAD_5;
#if NUMBER_ENTRY
        SetNumPad();
#endif
        return;
        }

    if ((event == DIR_RIGHT) && (MasterF.BoxNo == PLGAD_20)) if (ScrollGridUp()) {

        MasterF.BoxNo = PLGAD_16;
#if NUMBER_ENTRY
        SetNumPad();
#endif
        return;
        }

    if ((event == DIR_UP) && (f & PLFLAGS_SCROLLUP)) if (ScrollGridDown()) {

#if NUMBER_ENTRY
        SetNumPad();
#endif
        return;
        }

    if ((event == DIR_DOWN) && (f & PLFLAGS_SCROLLDOWN)) if (ScrollGridUp()) {

#if NUMBER_ENTRY
        SetNumPad();
#endif
        return;
        }
d644 1
a644 4
    BoxMove(&MasterF, event);
#if NUMBER_ENTRY
    SetNumPad();
#endif
d646 1
a646 1
    }
d654 26
a679 1
VOID DisplayGrid() {
a680 24
register WORD   pos,i;
register UBYTE *pe;
register UWORD *gs;                                                                                         /* D0 is the position */
    
    pos = (MasterF.D0/5) * 5;

    if (pos + 19 >= PlayList->EntryCount) {                                                                 /* Scroll upwards until the 20th posisition is filled with a blank */

        while((pos + 14 >= PlayList->EntryCount) && (pos > 0)) pos-=5;

        if (pos < 0)  pos = 0;
        if (pos > 80) pos = 80;                                                                             /* Limit the hundred area */
        }

    MasterF.D0 = pos;

    for(i=0,pe=&PlayList->Entry[pos],gs=&MasterF.gstate[PLGAD_1];
        (i<20)&&(pos<PlayList->EntryCount); i++,pe++,gs++,pos++) {

        if (!*pe)                   *gs = 0;
        else if (*pe & PLEF_ENABLE) *gs = *pe & PLEF_TRACK;
        else                        *gs = 0x8000 + (*pe & PLEF_TRACK);
        }

d683 1
a683 1
    MasterF.D2 = 0;                                                                                         /* Set the lit number if it is playing */
d686 8
a693 10
        if ((PlayerState.ListIndex >= MasterF.D0) && (PlayerState.ListIndex < MasterF.D0+20))
            MasterF.gstate[(MasterF.D2 = PLGAD_1 + PlayerState.ListIndex - MasterF.D0)] |= 0x4000;
    }   






/*================== Randomize Function for ShuffleGrid ===================*/
a694 1
UWORD rnd(int num) {
a695 2
    return(rand() % num);
    }
d702 3
a704 1
void UnShuffleGrid() {
d709 1
a709 1
    MasterF.D0 = 0;
d717 2
a718 5
    UpdateDisplay(); 
    ClearEvent(&input_data);
    }

void ShuffleGrid() {
d720 3
d727 4
a730 4
    for(i=PLGAD_1; i<=PLGAD_20; i++) MasterF.gstate[i] = 0x0000;                                                        /* Blank grid before we display our changes */
    
    MasterF.D0 = 0;
    MasterF.gstate[PLGAD_SHUFF] = 1;
d733 2
a734 1
    if ( !ShuffleMode ) {
d736 1
a736 1
	}
d743 16
a758 1
    for(i=0; i<UndoPlayList->EntryCount; i++) {                                                                     /* Generate random list from 'undo' list. */
d760 5
a764 1
        j=0;
d766 1
a766 20
        do r = rnd(UndoPlayList->EntryCount); while(++j<10 && PlayList->Entry[r]);

        if (j == 10) {

            d = rnd(2);

            while (PlayList->Entry[r]) {                                                                            /* Find the r'th unused entry. */

                if (d) {

                    if (--r < 0) r = UndoPlayList->EntryCount - 1;
                    }

                else if (++r >= UndoPlayList->EntryCount) r = 0;
                }
            }

        PlayList->Entry[r] = UndoPlayList->Entry[i];

        WaitTOF(); WaitTOF(); WaitTOF();
d768 3
a770 3
        UpdateGadgets();
        UpdateDisplay();
        }
d777 2
a778 1
    for ( i = UndoPlayList->EntryCount * 3; i < FLASHLENGTH; i++ ) {
d780 1
a780 1
	}
d782 1
a782 1
    MasterF.gstate[PLGAD_SHUFF] = 0;
d785 2
a786 3
    UpdateDisplay(); 
    ClearEvent(&input_data);
    }
d791 4
a794 5
void InitTrackCounter() {

    disksec     = TOC[0].Summary.LeadOut.LSN;

    secperpixel = disksec/TCOUNTMAX;
d797 1
a797 1
    }
d804 3
a806 2
void SetTrackCounter(int now) {

d812 11
a822 8
            || PlayerState.PlayMode == PLM_SKIPFWD
            || PlayerState.PlayMode == PLM_SKIPREV)
            && (PlayerState.PlayState != PLS_STOPPED )) {

        currsec = TOC[PlayerState.Track].Entry.Position.LSN;
        }

    else if (PlayerState.PlayState >= PLS_PLAYING) {
a823 3
        if (qvalid) currsec = copyqcode.DiskPosition.LSN;
        }

d830 1
a830 1
    
d833 4
a836 1
    else {
d838 7
a844 2
        loc = MasterF.gstate[PLGAD_COUNTER] & 0xfff;
        pos -= loc;
d846 7
a852 21
        if (pos < 0) {

            move = -2;
            if (pos >= -2) move = pos;
            if (pos < -5)  move = -3;
            if (pos < -10) move = -4;
            }

        else {

            move = 2;
            if (pos <= 2) move = pos;
            if (pos > 5)  move = 3;
            if (pos > 10) move = 4;
            }

        loc += move;
        }

    MasterF.gstate[PLGAD_COUNTER] = loc + (PlayerState.PlayState >= PLS_PLAYING ? 0x4000:0);
    }
d854 1
a854 47




/******************** Set Grid Entry to Entered Number *********************/

SetNum() {

    UpdatePlayTime(); while (!ModifyPlayList(1));

    MasterF.gstate[PLGAD_SHUFF] = 0;

    MasterF.D1 = 0;

#if NUMBER_ENTRY
    if (enttrackpos == -1) return(0);

    else {

        if ((enttrack <= TOC->Summary.LastTrack) && (enttrack >= 0)) {

            if (enttrack) {

                PlayList->Entry[enttrackpos] = enttrack | PLEF_ENABLE;
                }

            else {

                PlayList->Entry[enttrackpos] = 0;

                if (PlayList->EntryCount == enttrackpos + 1)                                                            /* Blanked track is at the end of list - Reduce playlistlen */ 
                    while(PlayList->EntryCount-1 >= 0 && !PlayList->Entry[PlayList->EntryCount-1])
                        --PlayList->EntryCount;
                }
            }

        else {                                                                                                          /* an error */

            PlayList->Entry[enttrackpos] = 0;
            ModifyPlayList(0);
            return(1);
            }
        }

    ModifyPlayList(0);
#endif
    return(0);
d857 2
a858 5



#if NUMBER_ENTRY
/********************** Enter a Digit into Position ************************/
a859 1
void enternum(int no) {
a860 31
int i;

    if ((MasterF.BoxNo >= PLGAD_1) && (MasterF.BoxNo <= PLGAD_20)) {       

        if (MasterF.D1) enttrack = (enttrack * 10 + no) % 100;

        else {

            enttrack = no;
            enttrackpos = MasterF.D0 + (MasterF.BoxNo - PLGAD_1);
            if (enttrackpos > 99) return;
            MasterF.D1 = 1;                                                                                             /* do something when moved */

            if (enttrackpos+1 >= PlayList->EntryCount) {

                UpdatePlayTime(); while (!ModifyPlayList(1));

                for (i=PlayList->EntryCount; i<=enttrackpos+1; i++) PlayList->Entry[i] = 0;

                PlayList->EntryCount = enttrackpos+1;
                ModifyPlayList(0);
                }

            UpdatePlayTime();
            }

        PlayList->Entry[enttrackpos] = enttrack;
        }
    }
#endif

a861 1

d864 3
a866 2
void togglegnum() {

d869 1
a869 1
    pos = MasterF.D0 + (MasterF.BoxNo - PLGAD_1);
d873 3
a875 1
    if (PlayList->Entry[pos] & PLEF_TRACK) {
d877 8
a884 10
        MasterF.gstate[PLGAD_SHUFF] = 0;
        
        if (MasterF.D1) SetNum();

        PlayList->Entry[pos] ^= PLEF_ENABLE;

        UpdatePlayTime();
        UpdateGadgets();
        }
    }
d891 4
a894 3
void ResetPlayList(int clear) {

register WORD           i;
d896 2
a897 2
    MasterF.gstate[PLGAD_SHUFF] = 0;
    MasterF.D0 = 0;                                                                                                 /* Set playlist back to zero */
d903 3
a905 1
    else {
d907 2
a908 4
        for (i=0; i<TOC[0].Summary.LastTrack; i++) PlayList->Entry[i] = (UBYTE)PLEF_ENABLE | (i+1);

        PlayList->EntryCount = TOC[0].Summary.LastTrack;
        }
d913 1
a913 30
    }


#if NUMBER_ENTRY
/********* Enable/Disable Numeric Keypad Based on Cursor Position **********/

void SetNumPad() {

    if (MasterF.BoxNo >= PLGAD_1 && MasterF.BoxNo <= PLGAD_20) PlayerNumPad(0);
    else                                                       PlayerNumPad(1);
    }



/************************ Configure Numeric Keypad *************************/

void PlayerNumPad(int on) {

#if 0
    cdio->io_Command = CDTV_FRONTPANEL;
    cdio->io_Data    = NULL;
    cdio->io_Offset  = 0;
    cdio->io_Length  = CDTV_PANEL_ENABLED | CDTV_PANEL_PLAY_EJECT | (on ? CDTV_PANEL_NUMERIC:0);
    DoIO(cdio);
#endif
    NumericPadEnabled = on;
    }

#endif

@


1.6
log
@no effective change.
@
text
@d74 1
d81 1
d83 1
d93 1
d95 1
d109 16
a124 12
static UWORD d_STOP[]   = {  0, 28,   0, 51 };
static UWORD d_REV[]    = { 25, 28,  25, 51 };
static UWORD d_PLAY[]   = { 50, 28,  50, 51 };
static UWORD d_FF[]     = { 75, 28,  75, 51 };
static UWORD d_PAUSE[]  = {100, 28, 100, 51 };

static UWORD d_TIME[]   = { 0,  74, 48,  74, 96, 74, 144, 74 };
static UWORD d_SHUFF[]  = { 0, 101, 48, 101 };
static UWORD d_GCLR[]   = { 0, 128, 48, 128 };
static UWORD d_REPEAT[] = { 0, 155, 48, 155, 155, 155, 203, 155 };
static UWORD d_INTRO[]  = { 0, 182, 48, 182,  96, 182, 144, 182, 192, 182 };
static UWORD d_CDG[]    = { 0, 209, 48, 209 };
d137 10
a146 1
struct GADNumberInfo d_TimerNumberData = {
d175 4
d198 24
a221 2
    INS_MOVE,   3,2,
    INS_DRAW,   18,2,
d223 3
a225 2
    INS_MOVE,   19,3,
    INS_DRAW,   19,17,
d227 3
a229 2
    INS_MOVE,   18,18,
    INS_DRAW,   3,18,
d231 2
a232 2
    INS_MOVE,   2,17,
    INS_DRAW,   2,3,
d243 10
a252 12
    { PLGAD_STOP,    0x80, KEY_STOP,     0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_GCLR,   PLGAD_REV,    24,  211, 49,  234, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_STOP   },
    { PLGAD_REV,     0x80, KEY_BACK,     0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_STOP,   PLGAD_PLAY,   49,  211, 74,  234, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_REV    },
    { PLGAD_PLAY,    0x80, KEY_PLAY,     0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_REV,    PLGAD_FF,     74,  211, 99,  234, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_PLAY   },
    { PLGAD_FF,      0x80, KEY_FWD,      0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_PLAY,   PLGAD_PAUSE,  99,  211, 124, 234, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_FF     },
    { PLGAD_PAUSE,   0x80, KEY_PAUSE,    0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_FF,     PLGAD_INTRO,  124, 211, 150, 234, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_PAUSE  },
    { PLGAD_TIME,    0x80, KEY_TIMEMODE, 0,   4,       PLGAD_16,     PLGAD_INTRO,  PLGAD_CDG,    PLGAD_SHUFF,  169, 169, 216, 195, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_TIME   },
    { PLGAD_SHUFF,   0x80, KEY_SHUFFLE,  0,   2,       PLGAD_18,     PLGAD_REPEAT, PLGAD_TIME,   PLGAD_GCLR,   231, 169, 278, 195, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_SHUFF   },
    { PLGAD_GCLR,    0x80, KEY_GCLR,     0,   2,       PLGAD_20,     PLGAD_CDG,    PLGAD_SHUFF,  PLGAD_STOP,   283, 169, 330, 195, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_GCLR   },
    { PLGAD_INTRO,   0x80, KEY_INTRO,    0,   5,       PLGAD_TIME,   PLGAD_1,      PLGAD_PAUSE,  PLGAD_REPEAT, 169, 208, 216, 234, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_INTRO  }, 
    { PLGAD_REPEAT,  0x80, KEY_REPEAT,   0,   4,       PLGAD_SHUFF,  PLGAD_3,      PLGAD_INTRO,  PLGAD_CDG,    221, 208, 268, 234, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_REPEAT },
    { PLGAD_CDG,     0x80, KEY_CDG,      0,   2,       PLGAD_GCLR,   PLGAD_5,      PLGAD_REPEAT, PLGAD_TIME,   283, 208, 330, 234, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_CDG    },
    { PLGAD_1,       0x05, KEY_GBUTTON,  0, 255,       PLGAD_INTRO,  PLGAD_6,      PLGAD_CDG,    PLGAD_2,      169, 57,  193, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
d255 2
a256 2
    { PLGAD_4,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_CDG,    PLGAD_9,      PLGAD_3,      PLGAD_5,      271, 57,  295, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_5,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_CDG,    PLGAD_10,     PLGAD_4,      PLGAD_6,      305, 57,  329, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
d271 4
a274 3
    { PLGAD_20,      0x0A, KEY_GBUTTON,  0, 255,       PLGAD_15,     PLGAD_GCLR,   PLGAD_19,     PLGAD_TIME,   305, 126, 329, 142, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_MIN,     0x00, 0,            0, 101,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     50,  173, 79,  191, NOOP,       NULL,               GADNumber,     &d_TimerNumberData },
    { PLGAD_SEC,     0x00, 0,            0, 101,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     90,  173, 119, 191, NOOP,       NULL,               GADNumber,     &d_TimerNumberData },
d367 9
d391 1
d410 1
d415 5
d579 1
d581 1
d588 1
d590 1
d596 1
d598 1
d604 1
d606 1
d611 1
d613 1
d675 17
d701 1
a701 1
    MasterF.gstate[PLGAD_SHUFF] ^= 1;                                                                                   /* Toggle */
d704 4
a707 1
    if (MasterF.gstate[PLGAD_SHUFF]) {                                                                                  /* Here we need to save the list and reshuffle the grid.  If we started in shuffle mode, then this is a re-shuffle, so we don't copy to the undo buffer in that case. */
d709 15
a723 1
        CopyMem(PlayList, UndoPlayList, sizeof(struct PlayList));
d725 1
a725 17
        PlayList->EntryCount = 0;
        for (i=0; i!=100; i++) PlayList->Entry[i] = 0;
        PlayList->EntryCount = UndoPlayList->EntryCount;

        for(i=0; i<UndoPlayList->EntryCount; i++) {                                                                     /* Generate random list from 'undo' list. */

            j=0;

            do r = rnd(UndoPlayList->EntryCount); while(++j<10 && PlayList->Entry[r]);

            if (j == 10) {

                d = rnd(2);

                while (PlayList->Entry[r]) {                                                                            /* Find the r'th unused entry. */

                    if (d) {
d727 2
a728 2
                        if (--r < 0) r = UndoPlayList->EntryCount - 1;
                        }
d730 1
a730 2
                    else if (++r >= UndoPlayList->EntryCount) r = 0;
                    }
d732 1
d734 1
a734 1
            PlayList->Entry[r] = UndoPlayList->Entry[i];
d736 1
a736 1
            WaitTOF(); WaitTOF(); WaitTOF();
d738 2
a739 3
            UpdateGadgets();
            UpdateDisplay();
            }
d742 8
a749 1
    else {
d751 1
a751 6
        UpdateDisplay();                                                                                                /* Restore the play list */

        PlayList->EntryCount = 0;
        for (i=0; i!=100; i++) PlayList->Entry[i] = UndoPlayList->Entry[i];
        PlayList->EntryCount = UndoPlayList->EntryCount;
        }
a752 1
    ModifyPlayList(0);
a758 3



d784 1
a784 1
            && MasterF.gstate[PLGAD_TTRACK] != 100) {
d844 1
d875 1
d882 1
d916 1
a919 1

d948 1
a948 1
void ResetPlayList(int dogad, int clear) {
a954 7
    if (dogad) {

        intdata.cintd_VCountDown = 5;
        MasterF.gstate[PLGAD_GCLR] = 1; 
        UpdateDisplay(); 
        }

a968 71
    
    if (dogad) {

        while(intdata.cintd_VCountDown) WaitTOF();
        MasterF.gstate[PLGAD_GCLR] = 0;
        UpdateDisplay();
        }
    }




/******************** Highlight/Unhighligh Entire Grid *********************/

void BlankPlayList(int dogad, int clear) {

register WORD   i;

    MasterF.gstate[PLGAD_SHUFF] = 0;

    if (dogad) {

        intdata.cintd_VCountDown = 5;
        MasterF.gstate[ PLGAD_GCLR ] = 1; 
        UpdateDisplay(); 
        }

    UpdatePlayTime(); while (!ModifyPlayList(1));

    if (clear) for (i=0; i<PlayList->EntryCount; i++) PlayList->Entry[i] &= (UBYTE)PLEF_TRACK;
    
    else       for (i=0; i<PlayList->EntryCount; i++) PlayList->Entry[i] |= (UBYTE)PLEF_ENABLE;
    
    ModifyPlayList(0);

    UpdateGadgets();

    if (dogad) {

        while(intdata.cintd_VCountDown) WaitTOF();
        MasterF.gstate[PLGAD_GCLR] = 0;
        UpdateDisplay();
        }
    }




/***************** Determine/Execute CLR Gadget Function *******************/

void DoGCLRGad() {

register WORD   i;

    if (PlayList->EntryCount) {

        for(i=0; i<PlayList->EntryCount && (PlayList->Entry[i] & PLEF_ENABLE); i++);

        if (i == PlayList->EntryCount) BlankPlayList(1, 1);
        else {

            for(i=0; i<PlayList->EntryCount && !(PlayList->Entry[i] & PLEF_ENABLE); i++);

            if (i == PlayList->EntryCount) ResetPlayList(1, 1);
            else                           BlankPlayList(1, 0);
            }
        }

    else ResetPlayList(1, 0);

    UpdatePlayTime();
d972 1
a972 3



a982 1

d997 1
@


1.5
log
@Revised for cd.device.
@
text
@d695 4
a698 4
    else if ((PlayerState.PlayState  == PLS_SELECTED
        || PlayerState.PlayMode == PLM_SKIPFWD
        || PlayerState.PlayMode == PLM_SKIPREV)
        && MasterF.gstate[PLGAD_TTRACK] != 100) {
@


1.4
log
@No effective change.
@
text
@d17 1
a17 1
#include <cdtv:include/cdtv/cdtv.h>
d75 4
a78 3
extern struct CDTOC            *TOC;
extern struct CDSubQ            subq;
extern struct IOStdReq         *cdio, *cdsubq;
d453 1
a453 1
    if(mf->BoxNo >= 0) {
a672 16
/********************* Check Validity of Q-Code Packet *********************/

int subq_valid(void) {

    return (
           !cdsubq->io_Error
        && subq.Track == PlayerState.Track
        && subq.DiskPosition.Raw
        && (subq.Status == SQSTAT_PLAYING || subq.Status == SQSTAT_PAUSED)
        && (subq.AddrCtrl & ADRCTL_MASK) == ADRCTL_POSITION
        );

    }



d677 1
a677 1
    disksec     = ((TOC[0].Position.Raw >> 16) & 0xff) * 60 + ((TOC[0].Position.Raw >> 8) & 0xff);
d700 1
a700 2
        currsec = ((TOC[PlayerState.Track].Position.Raw >> 16) & 0xff) * 60
                + ((TOC[PlayerState.Track].Position.Raw >> 8) & 0xff);
d705 1
a705 1
        if (subq_valid()) currsec = ((subq.DiskPosition.Raw >> 16) & 0xff) * 60 + ((subq.DiskPosition.Raw >> 8) & 0xff);
d762 1
a762 1
        if ((enttrack <= TOC->LastTrack) && (enttrack >= 0)) {
d879 1
a879 1
        for (i=0; i<TOC[0].LastTrack; i++) PlayList->Entry[i] = (UBYTE)PLEF_ENABLE | (i+1);
d881 1
a881 1
        PlayList->EntryCount = TOC[0].LastTrack;
d979 1
d984 2
a985 2
    SafeDoIO(cdio);

@


1.3
log
@Does not allow highlighted box to changed when the A button is being held down.
@
text
@d39 3
a41 3
#include "cdtv:include/internal/playerresource.h"
#include "cdtv:include/internal/player_protos.h"
#include "cdtv:include/internal/player_pragmas.h"
@


1.2
log
@Cleaned up code.  Put headers on functions.
@
text
@d17 1
a17 1
#include <cr2:dev/cdtv.h>
d39 3
a41 3
#include "cr2:playerresource/playerresource.h"
#include "cr2:playerresource/player_protos.h"
#include "cr2:playerresource/player_pragmas.h"
d80 1
d438 2
a439 2
    SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
    SubmitKeyStroke(PKS_STOP|PKSF_RELEASE);
d503 2
@


1.1
log
@Initial revision
@
text
@a0 11
/* :ts=4
*
*       GADGETS.c -- screen works
*
*       William A. Ware                                                 AC01
*
*****************************************************************************
*   This information is CONFIDENTIAL and PROPRIETARY                                            *
*   Copyright (C) 1991, Silent Software, Incorporated.                                          *
*   All Rights Reserved.                                                                                                        *
****************************************************************************/
d17 1
a17 1
#include <cdtv/cdtv.h>
d44 1
a44 1
ULONG __asm GetKey  (register __a1 struct InputData *id);
d46 1
d48 1
a48 7
extern GADInsDraw( struct RastPort *rp, struct GadDir *g, int val, UWORD state );
extern GADNumber(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new);
extern GADSTDBox( struct RastPort *rp, struct GadDir *g, int val, UWORD state);
extern RNormal( struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new);
extern GADScrSave( struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new);

extern GAD2SRender( struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new);
d50 4
a53 1
extern __regargs PowerTen(register UBYTE dig);
d55 2
a56 1
extern UWORD volatile       __far vhposr;   /*  Custom chip register.  */
d58 2
d65 1
d67 15
a81 2
extern struct CycleIntInfo  intdata;
extern struct CDTVInputInfo input_data;
d83 1
a83 4
extern struct BMInfo    *bmi;
extern struct BitMap    *bm;
extern UBYTE            *mask;
extern struct View      *view, *oldview;
d85 2
a86 1
extern struct DisplayFrame *CurrentF, *WorkF, MasterF;
d88 2
d91 1
a91 2
extern void UpdateGadgets(void);
extern void UpdatePlayTime(void);
d93 3
a95 2
extern void SetNumPad(void);
extern void PlayerNumPad(int);
d97 2
a98 4
/* button bitmap */
extern struct BMInfo    *bbmi;
extern struct BitMap    *bbm;
extern UBYTE            *bmask;
d100 1
a100 1
extern struct RastPort  Rp;
d102 12
a113 29
extern WORD          playlistlen, activelistlen, curlistidx, undolistlen;
extern BYTE          playing, paused, scanning, scandir, timemode;

extern struct PlayerBase    *PlayerBase;
extern struct PlayerState    PlayerState;
extern struct PlayList      *PlayList;
extern struct PlayList      *UndoPlayList;

extern struct CDTOC         *TOC;
extern struct CDSubQ        subq;

extern struct IOStdReq      *cdsubq;

/*--------------------------------------*/

struct GadInfo {

    UBYTE   CurrentPic;
    UBYTE   Flags;
    };

struct GadHeader {

    struct GadDir   *gdlist;
    struct GadInfo  *gdinfo;
    };

/*--------------------------------------*/
static NOOP();
d115 1
a115 1
static GADTrackNum();
a116 24
static GADGridNumber();
static CDisp();
static RDisk(),RCounter();

/* PLGAD_STOP   */
static UWORD d_STOP[]  = {  0, 28,   0, 51 };
static UWORD d_REV[]   = { 25, 28,  25, 51 };
static UWORD d_PLAY[]  = { 50, 28,  50, 51 };
static UWORD d_FF[]    = { 75, 28,  75, 51 };
static UWORD d_PAUSE[] = {100, 28, 100, 51 };

static UWORD d_TIME[]  = { 0,  74, 48,  74, 96, 74, 144, 74 };
static UWORD d_SHUFF[] = { 0, 101, 48, 101 };
static UWORD d_GCLR[]  = { 0, 128, 48, 128 };
static UWORD d_REPEAT[]= { 0, 155, 48, 155, 155, 155, 203, 155 };
static UWORD d_INTRO[] = { 0, 182, 48, 182,  96, 182, 144, 182, 192, 182 };


ULONG currsec;

/*------------------------------------------------------------------*/
/* Data for the different number sets                               */
/*------------------------------------------------------------------*/

d145 1
a145 1
/*-------------- BOX --------------*/
d188 1
a188 3
static UWORD d_CDG[]    = { 0, 209, 48, 209 };

#define TCOUNTMAX   59                                  /* Max pos for track counter */
d233 5
d245 109
d355 1
a355 4
/* if num >= max move the number to < max value by max the highest digit
 * first then moveing on to the lower digits until the num < max
 * might want to turn into digit math - 68000 ins 
 */
d357 2
a358 17
static MaxNumSpecial(register int num, int max) {

register WORD ndig = 0,n,t,t1;
    
    if (num <= max) return(num);

    while(PowerTen(++ndig) <= max);

    num = num % PowerTen(ndig);

    ndig--;

    while((num > max) && ((t = PowerTen( ndig )) > 0)) {

        n = ((max % (t1=PowerTen(ndig+1)))/t) * t;                                                  /* n = digit of max */
        num = num-((num % t1)/t)*t + n;
        ndig--;
d361 5
a365 1
    return(num);
d367 2
a368 2
        
        
d371 1
d392 4
d417 1
a417 1
        CopyMem( (char *)g, (char *)&gad, sizeof(struct GadDir));
d422 1
a422 1
    return( GADNumber( rp, bbm, g, old,new ) );
d427 3
a429 3
/*******
* Disk *
*******/
a430 1
static RDisk(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new) {
d432 1
a432 2
extern struct BitMap   *bm;
extern UBYTE           *bmask;
a433 2
WORD                    xloc,dpos,dwidth;
static WORD             nums[] = { 
d435 1
a435 3
    0,52,51,50,47,44,40,35,30,24,17,10,2,-7,-17,-28,
    -43,-58,-74,-91,-112,-134,-157,-181,-206
    };  
d437 3
a439 33
register int            overlen;

    BltBitMap(bm, 0, 128, rp->BitMap, 0, 128, 267, 18, 0xc0, 0xff, NULL);                                       /* erase old */

    if (!new) goto upnums;
    
    dpos   = 96;
    dwidth = 207;

    if (new >= 24) goto upnums; 
    
    xloc = nums[new];
    
    if (xloc < 0) {

        dpos -= xloc;
        dwidth += xloc; 
        xloc = 0;
        }
    
    BltMaskBitMapRastPort(bbm, dpos, 209, rp, xloc, 128, dwidth, 18, (ABC|ABNC|ANBC), bmask);

    overlen = xloc+dwidth - 165;
    
    if (overlen > 0) BltMaskBitMapRastPort(bbm, 192,74, rp, 165,123, overlen, 23, (ABC|ABNC|ANBC), bmask);

upnums:

    if (MasterF.gstate[PLGAD_16]) GADNumber(rp, bbm, &MasterF.GadList[PLGAD_16], -1, MasterF.gstate[PLGAD_16]);
    if (MasterF.gstate[PLGAD_17]) GADNumber(rp, bbm, &MasterF.GadList[PLGAD_17], -1, MasterF.gstate[PLGAD_17]);
    if (MasterF.gstate[PLGAD_18]) GADNumber(rp, bbm, &MasterF.GadList[PLGAD_18], -1, MasterF.gstate[PLGAD_18]);

    return(0);
d445 1
a445 3
/**********
* COUNTER *
**********/
d447 1
a447 1
static void __regargs getcounterbase(WORD loc, WORD *x, WORD *y, WORD *dpos, WORD *dsize) {
d449 1
a449 4
static WORD pos[] = {
    -47,-34,
    -22,-11,-1,8,17,25,32,38,43,47,51,55,58,61,64,66,68,69,70,71
    };
d451 1
a451 1
    if (loc & 0x8000) {
d453 2
a454 3
        *x = 20;                                                                                                /* Begin lowered */
        if (loc >= 20)  *y = 43;
        else            *y = pos[loc & 0xfff];
d457 1
a457 17
    else {

        loc &= 0xfff;

        *y = 71;
        *x = 20+loc;
        }

    *dpos  = 101;
    *dsize = 45;

    if (*y<0) {

        *dpos -= *y;
        *dsize += *y;
        *y = 0;     
        }
a460 5
static RCounter(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new) {

extern struct BitMap    *bm;
extern UBYTE            *bmask;
WORD                     xloc, yloc, dpos, dsize;
a462 1
    getcounterbase(old, &xloc, &yloc, &dpos, &dsize);                                                               /* erase old */
d464 1
a464 4
    if (old & 0x4000) {                                                                                             /* old laser is on */
        dsize = 57;
        BltBitMap(bbm, 96, 209, rp->BitMap, 52, 128, 80, 16 ,0xc0, 0xff, NULL);
        }
d466 1
a466 1
    if (dsize>0) BltBitMap(bm, xloc, yloc, rp->BitMap, xloc, yloc, 80, dsize, 0xc0, 0xff, NULL);
d468 1
a468 1
    getcounterbase(new, &xloc, &yloc, &dpos, &dsize);
d470 1
a470 1
    if (dsize <= 0) goto upnums;
d472 1
a472 1
    BltMaskBitMapRastPort(bbm, 96, dpos, rp, xloc, yloc, 96, dsize, (ABC|ABNC|ANBC), bmask);
d474 1
a474 3
    if (new & 0x4000) BltMaskBitMapRastPort(bbm, 97, 147, rp, xloc+12, yloc+37, 50, 34, (ABC|ABNC|ANBC), bmask);    /* new laser is on */
        
upnums:
d476 1
a476 2
    WorkF->gstate[PLGAD_TTRACK] = CurrentF->gstate[PLGAD_TTRACK] = 0;
    return(0);
d481 1
a481 1
UWORD __regargs GetBoxKey(register struct DisplayFrame *mf, UWORD event) {
d483 1
a483 1
register UWORD ans;
d485 2
a486 1
    if(mf->BoxNo >= 0) {
d488 1
a488 3
        ans = mf->GadList[mf->BoxNo].KeyTrans + (event & IECODE_UP_PREFIX);
        return(ans);
        }
d490 1
a490 1
    return(0);
d495 3
d543 2
a544 1
/*----------------------------- GRID ------------------------*/
d546 1
a546 3
/* Display grid is responsible for getting numbers on the screen.
 * The position is set in MasterF.D0
 */
d566 2
a567 1
    for(i=0,pe=&PlayList->Entry[pos],gs=&MasterF.gstate[PLGAD_1]; (i<20)&&(pos<PlayList->EntryCount); i++,pe++,gs++,pos++) {
a585 1
ScrollGridUp() {
a586 1
UBYTE orgpos;
d588 1
a588 1
    orgpos = MasterF.D0;
d590 1
a590 1
    MasterF.D0 += 5;
d592 1
a592 17
    UpdateGadgets();

    return((MasterF.D0 == orgpos ? 0:1));
    }



ScrollGridDown() {

int ans = 1;

    if (MasterF.D0 >= 5) MasterF.D0 -= 5;
    else                 ans = 0;

    UpdateGadgets();

    return(ans);
d598 1
a598 8
/* 
 * returns the new playlistlen 
 */

UWORD rnd(int num) {

    return(rand() % num);
    }
a599 2


a667 6
/*---------------------- Track counter ---------------------*/

static LONG diskstart;
static LONG disksec;
static LONG secperpixel;

d669 1
d685 2
a688 2
    GetPlayerState(&PlayerState);

d698 3
d705 3
a707 1
    if ((PlayerState.PlayState  == PLS_SELECTED
d761 1
a762 6
/*----------------------------- entering numbers ---------------------*/


static WORD enttrack,orgtrack;
static WORD enttrackpos = -1;

a789 7

            if (PlayList->EntryCount) {

                if (curlistidx < 0) curlistidx = 0;
                }

            else curlistidx = -1;
d806 3
d844 2
d870 2
d912 2
d947 3
a953 2
    MasterF.gstate[PLGAD_SHUFF] = 0;

d977 20
a996 1
void UpdatePlayTime() {
d998 1
a998 3
    SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
    SubmitKeyStroke(PKS_STOP|PKSF_RELEASE);
    WaitTOF();
d1000 1
@
