head     1.6;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.6
date     93.03.17.16.57.03;  author peter;  state Exp;
branches ;
next     1.5;

1.5
date     93.03.08.18.22.24;  author peter;  state Exp;
branches ;
next     1.4;

1.4
date     93.02.26.16.39.12;  author peter;  state Exp;
branches ;
next     1.3;

1.3
date     92.12.18.11.44.34;  author jerryh;  state Exp;
branches ;
next     1.2;

1.2
date     92.08.20.13.16.25;  author jerryh;  state Exp;
branches ;
next     1.1;

1.1
date     92.07.24.13.11.26;  author jerryh;  state Exp;
branches ;
next     ;


desc
@Intuition-like screen functions.
@


1.6
log
@BuildBg() now handles Build_BGInfo->BackData of NULL.
@
text
@/* :ts=4
*
*   screen.c -- for library
*
*   William A. Ware                         B116
*
*****************************************************************************
*   This information is CONFIDENTIAL and PROPRIETARY                        *
*   Copyright (C) 1991, Silent Software, Incorporated.                      *
*   All Rights Reserved.                                                    *
****************************************************************************/

#include <exec/types.h>
#include <exec/interrupts.h>
#include <exec/memory.h>
#include <exec/libraries.h>
#include <exec/io.h>

#include <devices/timer.h>
#include <devices/input.h>
#include <devices/inputevent.h>

#include <graphics/gfx.h>
#include <graphics/gfxbase.h>
#include <graphics/view.h>
#include <graphics/rastport.h>

#include <cdtv/debox.h>
#include <cdtv/cdtv.h>
#include <cdtv/cdtvprefs.h>

#include <hardware/intbits.h>
#include <hardware/blit.h>

#include <libraries/dos.h>

#include "/playerprefsbase.h"
#include "viewmgr.h"
#include "/screensaver/screensaver.h"
#include "keyclick.h"

#include "/playerprefs_private_pragmas.h"
#include "/playerprefs_protos.h"

#include <clib/alib_protos.h>
#include <clib/exec_protos.h>
#include <clib/graphics_protos.h>
#include <clib/dos_protos.h>
#include <clib/debox_protos.h>
struct BitMap *DeBox_AllocBitMap( UWORD, UWORD, UWORD );
VOID DeBox_FreeBitMap (struct BitMap *);

#include <pragmas/exec_old_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/debox_pragmas.h>
#pragma libcall DeBoxBase DeBox_AllocBitMap 66 21003
#pragma libcall DeBoxBase DeBox_FreeBitMap 6C 801


extern char __far TimerDeviceName[];


/*
 * Spoof the #pragmas
 */
#define SysBase     (PlayerPrefsBase->ppb_ExecBase)
#define DeBoxBase   (PlayerPrefsBase->ppb_DeBoxBase)
#define GfxBase     (PlayerPrefsBase->ppb_GfxBase)



/*------------------------------------------------------------------*/


/****** playerprefs.library/CreateMask **********************************
*
*   NAME
*   CreateMask -- Create a mask from a specific color in the bitmap.
*
*   SYNOPSIS
*   mask = CreateMask (bm, color, mymask);
*    d0        a0  d0:8     a1
*
*   UBYTE *CreateMask (struct BitMap *, UBYTE, UBYTE *);
*
*   FUNCTION
*   This routine creates a single bitplane "mask" out of the supplied
*   BitMap and 'color' argument, and returns a pointer to it.
*
*   For all pixels in the bitmap having a value equal to 'color', a zero
*   bit will be written in the corresponding position in the mask plane.
*   All other bits will be set to one.  Thus, the 'color' argument
*   specifies which color is "transparent."  This is useful for creating
*   masks for use with DPaint brushes.
*
*   If 'mymask' is non-NULL, CreateMask() will deposit the mask into the
*   memory pointed to by 'mymask.'  The memory buffer must reside in
*   CHIP RAM, and must be at least as large as one bitplane from the
*   supplied BitMap.
*
*   If 'mymask' is NULL, CreateMask() will attempt to allocate a single
*   bitplane in CHIP RAM with size and geometry identical to the planes
*   in the supplied BitMap.
*
*   INPUTS
*   bm  - pointer to a bitmap with all bitplanes in CHIP RAM
*   color   - pixel value to be used in making the mask
*   mymask  - pointer to a mask plane in CHIP RAM, or NULL
*
*   RESULT
*   mask    - pointer to resulting mask plane or NULL if an allocation
*         failed
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
*/

UBYTE * __asm LIBCreateMask(    register __a0   struct BitMap           *bm,
                                register __d0   UBYTE                   color,
                                register __a1   UBYTE               *mask,
                                register __a6   struct PlayerPrefsBase
                                                    *PlayerPrefsBase )
{
    struct BitMap   bm1;
    struct BitMap   bm2;
    register WORD   i;
    LONG            xsize;

    CopyMem((char *)bm,(char *)&bm1,(long)sizeof(struct BitMap *));
    CopyMem((char *)bm,(char *)&bm2,(long)sizeof(struct BitMap *));

    bm1.Depth = 1;
    bm2.Depth = 1;
    xsize = bm1.BytesPerRow << 3;

    if (!mask)
        mask = AllocMem((long)(bm1.BytesPerRow * bm1.Rows),MEMF_CHIP);
    if (!mask) return(NULL);

    bm1.Planes[0] = mask;

    BltBitMap(&bm2,0L,0L,&bm1,0L,0L,xsize,(long)bm1.Rows,0xffL,0xffL,NULL);
    for(i=0;i<bm->Depth;i++)
    {
        bm2.Planes[0] = bm->Planes[i];
        BltBitMap(&bm2,0L,0L,&bm1,0L,0L,xsize,(long)bm1.Rows,
                  (color & (1<<i) ? 0x80L:0x20L),0xffL,NULL);
    }
        /* INVERT */
    BltBitMap(&bm2,0L,0L,&bm1,0L,0L,xsize,(long)bm1.Rows,
                0x50L,0xffL, NULL );
    return(mask);
}


/*------------------------------------------------------------------*/
/****** playerprefs.library/CenterCDTVView **********************************
*
*   NAME
*   CenterCDTVView -- Centers a view based on the CDTVPrefs
*
*   SYNOPSIS
*   CenterCDTVView (cdtvprefs, view, width, height)
*              a0       a1   d0:16  d1:16
*
*   VOID CenterCDTVView (struct CDTVPrefs *, struct View *, WORD, WORD);
*
*   FUNCTION
*   Centers a View based on the settings in the CDTVPrefs structure.
*   The View's Dx- and DyOffset values are brought in line with the
*   CDTVPrefs structure.  The first ViewPort in the View is then
*   centered within the View based on GfxBase values and the 'width'
*   and 'height' arguments.
*
*   If 'cdtvprefs' is NULL, the preferences will be read from the
*   bookmark.
*
*   The View->ViewPort->RasInfo->RyOffset will be modified if the
*   resulting ViewPort DyOffset would be too high on the screen for
*   the system to handle.
*
*   Modification of the copper lists is not atomic; you should not call
*   this routine on a View that is currently being displayed.
*
*   INPUTS
*   cdtvprefs - pointer to a CDTVPrefs structure or a NULL
*   view      - pointer to a View with only one ViewPort
*   width     - width of the ViewPort to be modified
*   height    - height of the ViewPort to be modified
*
*   EXAMPLE
*
*   NOTES
*   This routine should be used only on Views having but one ViewPort.
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
*/

VOID __asm LIBCenterCDTVView(   register __a0 struct CDTVPrefs *cdtv,
                                register __a1 struct View *v,
                                register __d0 WORD width,
                                register __d1 WORD height,
                                register __a6 struct PlayerPrefsBase
                                                        *PlayerPrefsBase )

{
    register struct ViewPort *vp;
    struct CDTVPrefs cp;
    register int t,min;

    if (!cdtv)
    {
        FillCDTVPrefs(&cp);
        cdtv = &cp;
    }
    vp = v->ViewPort;
    v->DxOffset = cdtv->DisplayX;
    v->DyOffset = cdtv->DisplayY;

    t = GfxBase->NormalDisplayColumns;
    if (!(vp->Modes & HIRES)) t>>=1;
    t = (t-width)>>1;

    vp->DWidth = width;
    vp->DxOffset = t;


    t = GfxBase->NormalDisplayRows;
    min = -v->DyOffset+13;      /* 11 pixels down */
    if (vp->Modes & LACE)
    {
        t += t;
        min += min;
    }
    t = (t-height)>>1;
    if (t < min)
    {
        vp->RasInfo->RyOffset = min-t;
        height -= (min-t);
        t = min;
    }
    else vp->RasInfo->RyOffset = 0;
    vp->DHeight = height;
    vp->DyOffset = t;

    if(GfxBase->LibNode.lib_Version >= 36) {
        if(vp->DyOffset <0) {
            v->DyOffset += vp->DyOffset;
            vp->DyOffset=0;
        }
    }

    MakeVPort( v, vp );
    MrgCop( v );
}


/****** playerprefs.library/GrabBm ****************************************
*
*   NAME
*   GrabBm -- Decompress a DeBox-compressed image in a useful way.
*
*   SYNOPSIS
*   success = GrabBm (header, data, bmiptr, bmptr, maskptr);
*     d0            a0     a1     a2     a3      a4
*
*   LONG GrabBm (struct CompHeader *, UBYTE *, struct BMInfo **,
*            struct BitMap **, UBYTE **);
*
*   FUNCTION
*   This function is a supplement to the debox.library.  It decompresses
*   the image described by 'header' and 'data,' and places the results
*   in pointers referenced by 'bmiptr,' 'bmptr,' and 'maskptr.'
*
*   The pointer referenced by 'bmiptr' will be filled with a pointer to
*   the BMInfo structure.  The pointer referenced by 'bmptr' will be
*   filled with a pointer to the decompressed bitmap.  The pointer
*   referenced by 'maskptr' will be filled with a pointer to the image's
*   mask plane, if present.  Note that GrabBm() allocates all these
*   structures for you; all you need supply are pointers to your
*   pointers.
*
*   If 'bmiptr,' 'bmptr,' or 'maskptr' are NULL, the corresponding
*   entity is not created.  (If all three are NULL, this function
*   becomes a no-op.)
*
*   If any internal operation fails, zero is returned, and 'bmiptr,'
*   'bmptr,' and 'maskptr' are filled with NULL.
*
*   INPUTS
*   header  - pointer to CompHeader structure, or NULL if data and
*         header are together
*   data    - pointer to compressed image
*   bmiptr  - pointer to client's BMInfo pointer
*   bmptr   - pointer to client's BitMap pointer
*   maskptr - pointer to client's mask pointer
*
*   RESULT
*   success - non-zero if successful; zero otherwise
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   FreeGrabBm(), debox.library/DecompBitMap()
*
*****************************************************************************
*/
__asm LIBGrabBm(    register __a0   struct Header           *h,
                    register __a1   UBYTE                   *data,
                    register __a2   struct BMInfo           **bmiptr,
                    register __a3   struct BitMap           **bmptr,
                    register __a4   UBYTE                   **mask,
                    register __a6   struct PlayerPrefsBase  *PlayerPrefsBase )
{
    register UBYTE ms = 0;
    register struct BMInfo *bmi;
    register struct BitMap *bm;

    if (!(bmi = DecompBMInfo( NULL,NULL,data )))    goto xit;

    /* If only the bmiptr (or less) is passed then we are finished
     */
    if (!bmptr && !mask) goto shortcut;

    if (bmi->bmi_Flags & BMIF_HAS_MASK)             ms = 1;
    if (!(bm = DeBox_AllocBitMap(bmi->bmi_Depth+ms,bmi->bmi_Width,bmi->bmi_Height)))
        goto xit;
    bm->Depth -= ms;
    if (DecompBitMap(NULL,data,bm,bm->Planes[bmi->bmi_Depth]) < 0)
        goto xit;

    if (mask)
    {
        if (!ms)
        {
            if (bmi->bmi_Flags & BMIF_TRANSPARENT_COLOR)
                if (!(*mask = CreateMask(   bm,bmi->bmi_TransparentColor,NULL )))
                    goto xit;
        }
        else
            *mask = bm->Planes[ bm->Depth ];
    }
    else
    {
        if (bm->Planes[bm->Depth])
            FreeMem( bm->Planes[bm->Depth], (long)(bm->BytesPerRow * bm->Rows));
    }
    bm->Planes[bm->Depth] = 0L;


shortcut:
    if (bmiptr) *bmiptr = bmi;
    else        FreeBMInfo(bmi);

    if (bmptr)  *bmptr = bm;
    else        DeBox_FreeBitMap( bm );

    return(1);
xit:
    if (bm)     {bm->Depth += ms; DeBox_FreeBitMap(bm);}
    if (bmi)    FreeBMInfo(bmi);
    if (bmiptr) *bmiptr = NULL;
    if (bmptr)  *bmptr  = NULL;
    if (mask)   *mask   = NULL;
    return(0);
}


/*-----------------------------------------------------------------------*/


/****** playerprefs.library/FreeGrabBm **********************************
*
*   NAME
*   FreeGrabBm -- Frees resources allocated by a call to GrabBm().
*
*   SYNOPSIS
*   FreeGrabBm (bmiptr, bmptr, maskptr);
*             a0     a1       a2
*
*   VOID FreeGrabBm (struct BMInfo **, struct BitMap **, UBYTE **);
*
*   FUNCTION
*   This routine frees resources allocated with GrabBm().
*
*   'bmiptr' is a pointer to your BMInfo pointer.  'bmptr' is a pointer
*   to your BitMap pointer.  'maskptr' is a pointer to your mask
*   pointer.  NULL may be supplied for any of these parameters; no
*   attempt will be made to free the associated object.
*
*   On exit, the pointers referenced by 'bmiptr,' 'bmptr,' and 'maskptr'
*   will be filled with NULL.
*
*   INPUTS
*   bmiptr  - pointer to client's BMInfo pointer
*   bmptr   - pointer to client's BitMap pointer
*   maskptr - pointer to client's mask pointer
*
*   EXAMPLE
*   struct BMInfo *bmi;
*   struct BitMap *bm;
*
*   GrabBm (&bmi, &bm, NULL);
*   ...
*   FreeBm (&bmi, &bm, NULL);
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   GrabBm()
*
*****************************************************************************
*/


VOID __asm LIBFreeGrabBm(   register __a0 struct BMInfo **bmi,
                            register __a1 struct BitMap **bm,
                            register __a2 UBYTE **mask,
                            register __a6 struct PlayerPrefsBase
                                                *PlayerPrefsBase)
{
    if (mask)
    {
        if (*mask)      {(*bm)->Planes[(*bm)->Depth++] = *mask;}
        *mask = 0;
    }
    if (bm)
    {
        if (*bm)        DeBox_FreeBitMap(*bm);
        *bm = 0;
    }
    if (bmi)
    {
        if (*bmi)       FreeBMInfo(*bmi);
        *bmi = 0;
    }
}

/*-----------------------------------------------------------------------*/


/****** playerprefs.library/FillBackDrop **********************************
*
*   NAME
*   FillBackDrop -- Fill a bitmap with a backdrop pattern.
*
*   SYNOPSIS
*   success = FillBackDrop (bm, header, strip);
*     D0            A0    A1     A2
*
*   LONG            success;
*   struct BitMap       *bm;
*   struct CompHeader   *header;
*   UBYTE           *strip;
*
*   FUNCTION
*   This routine fills a bitmap with a compressed image by stamping it
*   repeatedly horizontally across the bitmap.
*
*   'strip' points to the compressed image, which ideally should be a
*   tall, thin image at least as high as the destination bitmap.  The
*   image is centered in Y and stamped repeatedly across the destination 
*   bitmap starting at X=0 and incrementing in X by the strip's width.
*
*   This is useful for creating a gradated dithered background without
*   having to store the whole thing.
*
*   INPUTS
*   bm  - pointer to destination BitMap
*   header  - pointer to CompHeader structure
*   strip   - pointer to compressed strip image
*
*   RESULT
*   success - non-zero if the operation succeeded; zero otherwise
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
*/


int __asm LIBFillBackDrop(  register __a0 struct BitMap *bm,
                            register __a1 struct Header *header,
                            register __a2 UBYTE *strip,
                            register __a6 struct PlayerPrefsBase
                                                    *PlayerPrefsBase)
{
    struct BitMap *sbm = NULL;
    struct BMInfo *sbmi = NULL;
    register WORD i,mw,w,h,syoff,byoff;

    if (!GrabBm( header,strip,&sbmi,&sbm,NULL)) return(0);
    mw = bm->BytesPerRow << 3;
    syoff = byoff = 0;

    if (sbmi->bmi_Height > (h = bm->Rows))
    {
        /* Strip larger than the bitmap - clip strip. */
        syoff = (sbmi->bmi_Height - h)>>1;
    }
    else
    {
        if (sbmi->bmi_Height < h)
        {
            h = sbmi->bmi_Height;
            byoff = (h - sbmi->bmi_Height)>>1;
        }
    }
    for(i=0;i<mw;i+=sbmi->bmi_Width)
    {
        w = sbmi->bmi_Width;
        if (w+i >= mw) w = mw-i;
        BltBitMap( sbm, 0,syoff,bm, i,byoff, w,h, 0xc0,0xff,NULL);
    }

    /* We might want to do a top and bottom fill for strips that are smaller
     * than the width & height of the Screen.
     */

    FreeGrabBm( &sbmi,&sbm,NULL );
    return(1);
}

/*-----------------------------------------------------------------------*/



/****** playerprefs.library/FillForeground **********************************
*
*   NAME
*   FillForeground -- Render a foreground image into a bitmap.
*
*   SYNOPSIS
*   success = FillForeground (bm, header, data, xoff, yoff, bmiptr);
*     D0              A0    A1     A2    D0    D1     A3
*
*   LONG            success;
*   struct BitMap       *bm;
*   struct CompHeader   *header;
*   UBYTE           *data;
*   WORD            xoff, yoff;
*   struct BMInfo       **bmiptr;
*
*   FUNCTION
*   This routine renders an image described by 'header' and 'data' and
*   renders it into the bitmap pointed to by 'bm.'
*
*   'data' points to the compressed image, which is decompressed and
*   rendered into the bitmap.  The upper-left corner of the image is
*   placed at coordinates xoff,yoff in the bitmap.  If the image has
*   a mask associated with it, the image is rendered through the mask
*   "cookie-cut style."
*
*   If 'bmiptr' is non-NULL, then a pointer to the BMInfo of the
*   compressed image will be stored in the pointer referenced by
*   'bmiptr.'
*
*   INPUTS
*   bm  - pointer to BitMap to receive image
*   header  - pointer to a CompHeader structure
*   data    - pointer to compressed image
*   xoff    - X-offset of image in destination BitMap
*   yoff    - Y-offset of image in destination BitMap
*   bmiptr  - pointer to BMInfo pointer, or NULL
*
*   RESULT
*   success - non-zero if operation succeeded; zero otherwise
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   GrabBm()
*
*****************************************************************************
*/


int __asm LIBFillForeground(register __a0 struct BitMap *mbm,
                            register __a1 struct Header *header,
                            register __a2 UBYTE *data,
                            register __d0 WORD xoff,
                            register __d1 WORD yoff,
                            register __a3 struct BMInfo **bmiptr,
                            register __a6 struct PlayerPrefsBase
                                                    *PlayerPrefsBase)
{
    struct BitMap       *bm = NULL;
    struct BMInfo       *bmi = NULL;
    UBYTE               *mask = NULL;
    struct RastPort     rp;
    int                 ans = 0;

    if (!GrabBm( header,data,&bmi,&bm,&mask)) goto xit;

    InitRastPort( &rp );
    rp.BitMap = mbm;

    if (mask)
    {
        BltMaskBitMapRastPort(  bm, 0,0, &rp, xoff, yoff,
                                bmi->bmi_Width,bmi->bmi_Height,
                                (ABC|ABNC|ANBC),mask);
    }
    else
    {
        BltBitMapRastPort(  bm,0,0,&rp, xoff, yoff,
                            bmi->bmi_Width,bmi->bmi_Height,0xc0 );
    }

    if (bmiptr)
    {
        *bmiptr = bmi;
        bmi = NULL;     /* and don't deallocated bmi */
    }
    ans = 1;
xit:
    FreeGrabBm( &bmi,&bm,&mask );
    return(ans);
}


/*-----------------------------------------------------------------------*/



/****** playerprefs.library/BuildBg **********************************
*
*   NAME
*   BuildBg -- Build bitmap from ground up.
*
*   SYNOPSIS
*   success = BuildBg (bbg, bmiptr, bmptr);
*
*   LONG            success;
*   struct BuildBg_Info *bbg;
*   struct BMInfo       **bmiptr;
*   struct BitMap       **bmptr;
*
*   FUNCTION
*   This routine allocates and renders a bitmap according to the
*   information contained in the BuildBg_Info structure pointed to by
*   'bbg.'
*
*   The background is rendered according to the rules specified in
*   FillBackDrop().  The foreground is rendered according to the rules
*   specified in FillForeground().
*
*   The pointer referenced by 'bmiptr' will be filled with a pointer to
*   the BMInfo of the resulting image.  The pointer referenced by
*   'bmptr' will be filled with a pointer to the created bitmap.  Both
*   'bmiptr' and 'bmptr' may be passed as NULL; the associated object
*   will not be created.  (Passing both as NULL turns this routine into
*   a very expensive no-op.)
*
*   If any internal operation fails, zero is returned and nothing is
*   allocated.
*
*   INPUTS
*   bbg - pointer to BuildBg_Info structure:
*       BackHeader  - pointer to CompHeader structure for background
*       BackData    - pointer to compressed 'strip' for background
*       ForHeader   - pointer to CompHeader structure for foreground
*       ForData - pointer to compressed image for foreground
*       width   - width in pixels of bitmap to be created
*       height  - height in pixels of bitmap to be created
*       depth   - number of planes of bitmap to be created
*       ForXOff - X-offset of foreground image in bitmap
*       ForYOff - Y-offset of foreground image in bitmap
*       flags   - reserved
*   bmiptr  - pointer to BMInfo pointer
*   bmptr   - pointer to BitMap pointer
*
*   RESULT
*   success - non-zero if all went well; zero otherwise
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   FillBackDrop(), FillForeground()
*
*****************************************************************************
*/


int __asm LIBBuildBg(   register __a0 struct BuildBg_Info   *bbg,
                        register __a1 struct BMInfo         **bmiptr,
                        register __a2 struct BitMap         **bmptr,
                        register __a6 struct PlayerPrefsBase
                                                    *PlayerPrefsBase)
{
    struct BitMap       *mbm;
    struct BMInfo       *bmi = NULL;
    int                 ans = 0;

    if (!(mbm = DeBox_AllocBitMap( bbg->Depth, bbg->Width, bbg->Height )))
        return(0);

    if ( bbg->BackData )
    {
	if (!(FillBackDrop( mbm, bbg->BackHeader, bbg->BackData ))) goto xit;
    }
    if (!(FillForeground( mbm, bbg->ForHeader, bbg->ForData,
                          bbg->ForXOff,bbg->ForYOff, &bmi )))  goto xit;

    bmi->bmi_Width = bbg->Width;    /* Mod bmi to match the mbm */
    bmi->bmi_Height = bbg->Height;
    bmi->bmi_Depth = bbg->Depth;
    if (bmptr)  {*bmptr  = mbm; mbm = NULL;}    /* don't deallocate mbm */
    if (bmiptr) {*bmiptr = bmi; bmi = NULL;}    /* and don't deallocated bmi */

    ans = 1;
xit:
    if (bmi) FreeBMInfo ( bmi );
    if (mbm) DeBox_FreeBitMap ( mbm );
    return(ans);
}




/*-----------------------------------------------------------------------*/

/****i* playerprefs.library/WriteTinyStr ***********************************
*
*   NAME
*   WriteTinyStr -- Write a limited string into a BitMap with a very
*           small font.
*
*   SYNOPSIS
*   WriteTinyStr (bm, x, y, color, str);
*             A0  D0 D1  D2    A1
*
*   struct BitMap   *bm;
*   WORD        x, y;
*   UBYTE       color;
*   UBYTE       *str;
*
*   FUNCTION
*   Writes a really dinky string into the BitMap pointed to by 'bm' at
*   the coordinates specified by 'x' and 'y' using a pen value of
*   'color.'
*
*   The available character set is limited to the numerals '0' - '9',
*   the letters 'A' - 'Z', 'a' - 'z' (which get mapped to their
*   uppercase counterparts), and the symbol '.'.  All other characters
*   are mapped to a blank space.
*
*   INPUTS
*   bm  - pointer to receive text
*   x   - leftmost edge of rendered text
*   y   - topmost edge of rendered text
*   color   - pen color used to render text
*   str - pointer to string to be rendered, NULL-terminated
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
*/
#define NUMBERDATA_W        112
#define NUMBERDATA_H        5

#define NUMDATA_SIZE  (RASSIZE(NUMBERDATA_W,NUMBERDATA_H))

UWORD __far NumberData[] = {
    0xEBFB,0xFFFC,0x7DF7,0xFEF3,0x65AB,0x2CFD,0xB6DE,
    0xA89B,0x21B4,0x5B2C,0x92A3,0x67F6,0xDB15,0xB6D2,
    0xABBF,0xF9FC,0x7D2E,0xD3A3,0xA5F7,0x5D95,0xB554,
    0xAA12,0x69A4,0x5B2C,0x96AB,0x65F6,0x6A55,0xBEA8,
    0xEBF3,0xF9E5,0x5DF7,0x9EFF,0x7DAA,0x3B97,0x56AE
};

__asm LIBWriteTinyStr(  register __a0 struct BitMap *bm,
                        register __d0 WORD x,
                        register __d1 WORD y,
                        register __d2 UBYTE color,
                        register __a1 UBYTE *str,
                        register __a6 struct PlayerPrefsBase *PlayerPrefsBase)
{
    struct RastPort         rp;
    struct BitMap           *sbm;
    UBYTE                   *onpl,*offpl;
    int                     i;
    int                     val;
    register UBYTE          no;


    if (!(sbm= DeBox_AllocBitMap( 2, NUMBERDATA_W,NUMBERDATA_H ))) return(0);

    onpl = sbm->Planes[0];
    offpl = sbm->Planes[1];
    sbm->Depth = bm->Depth;
    for(i=0;i<bm->Depth;i++,color >>= 1)
        sbm->Planes[i] = (color & 1 ? onpl:offpl);
    CopyMem( NumberData,onpl,NUMDATA_SIZE);
    MemSet( offpl, 0, NUMDATA_SIZE );

    InitRastPort(&rp);
    rp.BitMap = bm;

    while(*str)
    {
        val = -1;
        no = *str++;
        if ((no >= '0') && (no <= '9')) val = no - 48;
        if ((no >= 'A') && (no <= 'Z')) val = no - ('A' - 11);
        if ((no >= 'a') && (no <= 'z')) val = no - ('a' - 11);
        if (no == '.')                  val = 10;
        if (val == -1) { x+= 4; continue; }
        BltMaskBitMapRastPort( sbm,val*3,0,&rp,x,y,3,5,(ABC|ABNC|ANBC),onpl );
        x += 4;
    }
    WaitBlit();
    sbm->Depth = 2;
    sbm->Planes[0] = onpl;
    sbm->Planes[1] = offpl;
    DeBox_FreeBitMap( sbm );
    return(1);
}



/*-------------------------------------------------------------------------*/


/****** playerprefs.library/SafeWaitIO *************************************
*
*   NAME
*   SafeWaitIO -- Safer I/O completion mechanism.
*
*   SYNOPSIS
*   error = SafeWaitIO (ior);
*    D0          A0
*
*   LONG            error;
*   struct IORequest    *ior;
*
*   FUNCTION
*   This routine is identical to WaitIO(), except that it prevents
*   additional calls to WaitIO() on IORequests that have already
*   completed.  To elaborate, the sequence:
*
*       SendIO (ior);
*       WaitIO (ior);
*       WaitIO (ior);   *  WaitIO() on already-completed IOR.  *
*
*   is unsafe, since WaitIO() unconditionally calls Remove() on the
*   IORequest.  SafeWaitIO() detects and avoids this condition.
*
*   SafeWaitIO() and WaitIO() CANNOT be intermixed if you wish to reap
*   the benefits of SafeWaitIO().
*
*   INPUTS
*   ior - pointer to an IORequest structure
*
*   RESULT
*   error   - copy of the IORequest.io_Error field
*
*   EXAMPLE
*   SendIO (ior);
*   SafeWaitIO (ior);
*   SafeWaitIO (ior);
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   SafeDoIO()
*
*****************************************************************************
*/
LONG __asm LIBSafeWaitIO(   register __a0 struct IORequest *ioreq,
                register __a6 struct PlayerPrefsBase 
                *PlayerPrefsBase )
{
    register LONG   retval;

    Forbid();
    if (ioreq->io_Message.mn_Node.ln_Succ) {
        /*
         * The I/O packet has not been checked back in.  WaitIO() on
         * it and flag it as well and truly completed.
         */
        retval = WaitIO(ioreq);
        ioreq->io_Message.mn_Node.ln_Succ = NULL;
    } 
    else {
        /*
         * The I/O packet is already in; use existing error code.
         */
        retval = ioreq->io_Error;
    }
    Permit();
    return (retval);
}



/****** playerprefs.library/FreeIORequest **********************************
*
*   NAME
*   FreeIORequest -- Free an I/O session started with AllocIORequest().
*
*   SYNOPSIS
*   FreeIORequest (ior);
*           A0
*
*   struct IORequest    *ior;
*
*   FUNCTION
*   This routine frees all resources procured with AllocIORequest().
*
*   Any outstanding IO is aborted and allowed to complete.  The device
*   associated with the IORequest is closed, the associated replyport is
*   deleted, and the IORequest itself is then freed.
*
*   INPUTS
*   ior - pointer to IORequest structure
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   AllocIORequest()
*
*****************************************************************************
*/
VOID __asm LIBFreeIORequest(    register __a0 void *ioreq,
                                register __a6 struct PlayerPrefsBase 
                                                        *PlayerPrefsBase )  
{
    register struct IORequest *r;

    if (!(r = (struct IORequest *)ioreq)) return;
    if (r->io_Device)
    {
        if (r->io_Message.mn_Node.ln_Succ) AbortIO(r);
        SafeWaitIO(r);
        CloseDevice( r );
    }
    if (r->io_Message.mn_ReplyPort)
        DeleteMsgPort( r->io_Message.mn_ReplyPort );
    DeleteExtIO( r );
}

/****** playerprefs.library/AllocIORequest *********************************
*
*   NAME
*   AllocIORequest -- Start a session with an Exec device.
*
*   SYNOPSIS
*   ior = AllocIORequest (devname, unit, flags, size);
*   D0          A0      D0     D1    D2
*
*   struct IORequest    *ior;
*   char            *devname;
*   ULONG           unit, flags, size;
*
*   FUNCTION
*   This routine does all the mish-mash necessary to start a session
*   with an Exec-style I/O device.
*
*   A nameless replyport is created, an IORequest structure is created,
*   the named device is opened with the specified unit number and
*   flags, and a pointer to the IORequest is returned.  If any of these
*   operations fail, NULL is returned and nothing is allocated.
*
*   INPUTS
*   devname - pointer to name of device
*   unit    - device unit number, as used by OpenDevice()
*   flags   - device flags, as used by OpenDevice()
*   size    - size of desired IORequest structure, in bytes
*
*   RESULT
*   ior - pointer to allocated IORequest structure, or NULL
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   FreeIORequest()
*
*****************************************************************************
*/
VOID * __asm LIBAllocIORequest( register __a0 char *devname, 
                                register __d0 ULONG unitNumber, 
                                register __d1 ULONG flags, 
                                register __d2 ULONG size,
                                register __a6 struct PlayerPrefsBase 
                                                        *PlayerPrefsBase )
{
    register struct IORequest *r;
    register struct MsgPort *m;
    
    if (!(m = (struct MsgPort *)CreateMsgPort())) return(NULL);
    if (!(r = (struct IORequest *)CreateExtIO( m,size)))
    {
        DeleteMsgPort(m);
        return(NULL);
    }
    if (OpenDevice( devname, unitNumber, r, flags )) 
    {
        r->io_Device = NULL;
        FreeIORequest( r );
        return(NULL);
    }
    return( (VOID *)r );
}



/****** playerprefs.library/SafeDoIO ***************************************
*
*   NAME
*   SafeDoIO -- Safer I/O operation mechanism.
*
*   SYNOPSIS
*   error = SafeDoIO (ior);
*    D0        A0
*
*   LONG            error;
*   struct IORequest    *ior;
*
*   FUNCTION
*   Identical in operation to DoIO().  Exists for the same reason as
*   SafeWaitIO().  In particular:
*
*       DoIO (ior);
*       WaitIO (ior);
*
*   is unsafe.
*   
*   SafeDoIO() and DoIO() cannot be intermixed.  See the SafeWaitIO()
*   docs for more details.
*
*   INPUTS
*   ior - pointer to an IORequest structure
*
*   RESULT
*   error   - copy of IORequest.io_Error field
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   SafeWaitIO()
*
*****************************************************************************
*/
LONG __asm LIBSafeDoIO (  register __a0 struct IORequest *ioreq,
                          register __a6 struct PlayerPrefsBase 
                                                        *PlayerPrefsBase )
{
    register LONG   retval;

    retval = DoIO (ioreq);
    ioreq->io_Message.mn_Node.ln_Succ = NULL;   /*  It's back.  */
    return (retval);
}





/****i* playerprefs.library/SetVersionStr **********************************
*
*   NAME
*   SetVersionStr -- Set the version string in PlayerPrefsBase.
*
*   SYNOPSIS
*   SetVersionStr (str);
*           A0
*
*   char    *str;
*
*   FUNCTION
*   The string pointed to by 'str' is copied into PlayerPrefsBase's
*   private copy of the version string.  The maximum permitted length
*   is seven characters, and will be truncated if longer.
*
*   INPUTS
*   str - pointer to string
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
*/
VOID __asm LIBSetVersionStr( register __a0 char *str,
                        register __a6 struct PlayerPrefsBase *PlayerPrefsBase)
{
    char *s;
    int c = 0;


    ObtainSemaphore( &PlayerPrefsBase->ppb_LibLock );
    s = PlayerPrefsBase->ppb_CDTVVersionStr;
    for(;*str && (c < 7);c++)
        *s++ = *str++;
    for(;c < 8;c++)
        *s++ = 0;
    ReleaseSemaphore( &PlayerPrefsBase->ppb_LibLock );
}


/*=========================================================================
 * WARNING!!! Critical section code - Works with a critical section.
 * modifiy and program with lots of thought
 *=========================================================================
 */

/*=========================================================================
 * launchPPTask()
 *
 * Allows a task to be started with and a success code to be given weather
 * it was started correctly.  The Task that has been started  =M U S T= call
 * sigPPTask() before it exits.
 *========================================================================
 */
 
int
launchPPTask(char *taskname,LONG pri ,APTR prog, ULONG stacksize,
             struct PlayerPrefsBase *PlayerPrefsBase)
{
    int ans = 0;
    
    ObtainSemaphore( &PlayerPrefsBase->ppb_LibLock );
    
    PlayerPrefsBase->ppb_TitleSigNo = AllocSignal(-1);
    PlayerPrefsBase->ppb_TitleSigTask = FindTask(NULL);
    if (!CreateTask( taskname,pri,prog,stacksize )) goto xit;

    if (PlayerPrefsBase->ppb_TitleSigNo != -1)
    {
        Wait( 1 << PlayerPrefsBase->ppb_TitleSigNo);
        FreeSignal( PlayerPrefsBase->ppb_TitleSigNo );
    }
    while(PlayerPrefsBase->ppb_TitleSigTask) WaitTOF();
    Forbid();
    ans = PlayerPrefsBase->ppb_TitleAns;
    Permit();
xit:
    ReleaseSemaphore( &PlayerPrefsBase->ppb_LibLock );
    return(ans);
}

/*=======================================================================
 * sigPPTask()
 *
 * Signals the creating task that it can return to normal running.
 *
 * It sould always be called by a task created by launch pp.  
 * a return value of zero sould be used if the task is going to xit.
 *======================================================================
 */
VOID sigPPTask(struct PlayerPrefsBase *PlayerPrefsBase, int val) {

    Forbid();

    if (PlayerPrefsBase->ppb_TitleSigTask && (PlayerPrefsBase->ppb_TitleSigNo != -1)) {

        Signal(PlayerPrefsBase->ppb_TitleSigTask, 1<<PlayerPrefsBase->ppb_TitleSigNo);
        }

    PlayerPrefsBase->ppb_TitleSigTask = NULL;
    PlayerPrefsBase->ppb_TitleAns = val;
    Permit();
    }

/*-------------------------------------------------------------------------*/

/****i* playerprefs.library/CDTVTitle **************************************
*
*   NAME
*   CDTVTitle -- Display and manipulate the CDTV "strap" screen.
*
*   SYNOPSIS
*   success = CDTVTitle (state);
*     D0              D0
*
*   LONG    success;
*   LONG    state;
*
*   FUNCTION
*   Creates and displays the rotating CDTV logo displayed at boot time.
*   The parameter 'state' determines what it should do.  'state' can
*   have the following values:
*
*   TITLESTATUS_NORMAL:
*       Brings up CDTV strap screen with normal colors.  If the
*       screen is already up, the colors will be faded to the normal
*       colors.
*
*   TITLESTATUS_ERROR:
*       Brings up CDTV strap screen with error colors (red).  If the
*       screen is already up, the colors will be faded to the error
*       colors.
*
*   TITLESTATUS_LEAVE:
*       Fades out CDTV strap screen and frees all resources.
*
*   INPUTS
*   state   - state in which to display the screen
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
*/

__asm CDTVTitleFunc(    register __d0 WORD state,
                        register __a6 struct PlayerPrefsBase *PlayerPrefsBase) {

    return(0);
    }







/****** playerprefs.library/FadeCMap ***************************************
*
*   NAME
*   FadeCMap -- Calculate an intermediate color map.
*
*   SYNOPSIS
*   FadeCMap (map0, map15, destmap, ncolors, level);
*          A0     A1     A2       D0      D1
*
*   UWORD   *map0, *map15, *destmap;
*   WORD    ncolors, level;
*
*   FUNCTION
*   This routine calculates an intermediate color map between the color
*   maps specified by 'map0' and 'map15' using a "fade level" specified
*   by 'level.'  The resulting color map is placed in the buffer pointed
*   to by 'destmap.'
*
*   The valid range of values for 'level' is 0 - 15.  A value of zero
*   yields the colors in 'map0;' a value of 15 yields the colors in
*   'map15.'  Values outside this range are clipped.
*
*   'ncolors' is the number of colors in the color maps.  Values greater
*   than 32 are truncated (for no readily apparent reason).
*
*   INPUTS
*   map0    - pointer to fade level 0 color map
*   map15   - pointer to fade level 15 color map
*   destmap - pointer to buffer to receive new color map
*   ncolors - number of colors in color map
*   level   - fade level; range 0 - 15
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   BetweenColor()
*
*****************************************************************************
*/
VOID __asm LIBFadeCMap( register __a0 UWORD *cmap0,
                        register __a1 UWORD *cmap15,
                        register __a2 UWORD *ncmap,
                        register __d0 WORD  ncr,
                        register __d1 WORD  lv,
                        register __a6 struct PlayerPrefsBase *PlayerPrefsBase)
{
    if (ncr > 32) ncr = 32;
    if (lv >= 15)
    {
        CopyMem( cmap15, ncmap, ncr << 1 );
        return;
    }
    if (lv <  0)
    {
        CopyMem( cmap0, ncmap, ncr << 1 );
        return;
    }
    while (ncr--)
    {
        *ncmap++ = BetweenColor( *cmap0++,*cmap15++,lv );
    }
    return;
}


@


1.5
log
@Fixed includes used.  Removed name collisions with Alloc/FreeBitMap().
@
text
@d730 4
a733 1
    if (!(FillBackDrop( mbm, bbg->BackHeader, bbg->BackData ))) goto xit;
@


1.4
log
@Cleanup, optimization, etc.
@
text
@d49 3
a51 1
#include <cdtv/debox_protos.h>
d56 3
d342 1
a342 1
    if (!(bm = AllocBitMap(bmi->bmi_Depth+ms,bmi->bmi_Width,bmi->bmi_Height)))
d372 1
a372 1
    else        FreeBitMap( bm );
d376 1
a376 1
    if (bm)     {bm->Depth += ms; FreeBitMap(bm);}
d447 1
a447 1
        if (*bm)        FreeBitMap(*bm);
d727 1
a727 1
    if (!(mbm = AllocBitMap( bbg->Depth, bbg->Width, bbg->Height )))
d743 1
a743 1
    if (mbm) FreeBitMap ( mbm );
d824 1
a824 1
    if (!(sbm= AllocBitMap( 2, NUMBERDATA_W,NUMBERDATA_H ))) return(0);
d853 1
a853 1
    FreeBitMap( sbm );
@


1.3
log
@Revised trademark functions.
@
text
@d45 1
a744 208
/*----------------------- VBLANK HANDLER SETTUP ----------------------*/


/****i* playerprefs.library/LoadCycleView **********************************
*
*   NAME
*   LoadCycleView -- Load a View intended to be color-cycled and/or
*            faded.
*
*   SYNOPSIS
*   LoadCycleView (ci, view, cclist);
*              A0   A1     A2
*
*   struct CycleIntInfo *ci;
*   struct View     *view;
*   UWORD           **cclist;
*
*   FUNCTION
*   Loads a View intended to be color-cycled and/or faded by Will's
*   neato VBLANK server.
*
*   (insert details here, Will...)
*
*   INPUTS
*   ci  - pointer to CycleIntInfo structure
*   view    - pointer to View to be displayed
*   cclist  - pointer to array of UWORD pointers, as generated by
*         FindViewRGB()
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   StartViewMgr(), CloseViewMgr()
*
*****************************************************************************
*/
VOID __asm LIBLoadCycleView(register __a0 struct CycleIntInfo   *ci,
                            register __a1 struct View           *view,
                            register __a2 UWORD                 **cclist,
                            register __a6 struct PlayerPrefsBase
                                                            *PlayerPrefsBase)
{
    register struct BMInfo *lbmi;

    lbmi = ci->cintd_BMInfo;
    LoadFoundRGBFade(cclist, lbmi->bmi_ColorMap,lbmi->bmi_NumColors,
                        ci->cintd_Fade0,ci->cintd_Fade1,
                        ci->cintd_AltCMap,
                        ci->cintd_FadeMask );

    ci->cintd_LoadCCList = cclist;
    ci->cintd_LoadView = view;
    LoadView( view );
}


/****i* playerprefs.library/CloseViewMgr ***********************************
*
*   NAME
*   CloseViewMgr -- Shut down color-cycling/fading interrupt server.
*
*   SYNOPSIS
*   CloseViewMgr (ci);
*             A0
*
*   struct CycleIntInfo *ci;
*
*   FUNCTION
*   Shuts down the color-cycling/fading interrupt server installed for
*   the CycleIntInfo pointed to by 'ci.'
*
*   INPUTS
*   ci  - pointer to CycleIntInfo structure
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   StartViewMgr()
*
*****************************************************************************
*/
VOID __asm LIBCloseViewMgr( register __a0 struct CycleIntInfo     *ci,
                            register __a6 struct PlayerPrefsBase
                                                        *PlayerPrefsBase)
{
    Disable();

    if (ci->cintd_intr.is_Code)RemIntServer(INTB_VERTB,ci);

    /* remember the 1.3 LoadView bug ?  Right. */
        if(GfxBase->LibNode.lib_Version >= 36)  LoadView(NULL);
        else if(ci->cintd_oldview)LoadView( ci->cintd_oldview );
    
    ci->cintd_intr.is_Code = NULL;
    ci->cintd_oldview = NULL;
    Enable();

}



/****i* playerprefs.library/StartViewMgr ***********************************
*
*   NAME
*   StartViewMgr -- Create and install a color-cycling/fading interrupt
*           server.
*
*   SYNOPSIS
*   ci = StartViewMgr (myci, bmi, view, cclist, flags);
*
*   struct CycleIntInfo *ci, *myci;
*   struct BMInfo       *bmi;
*   struct View     *view;
*   UWORD           **cclist;
*   UBYTE           flags;
*
*   FUNCTION
*   Initializes and installs a color-cycling/fading interrupt.
*
*   'ci' points to the CycleIntInfo structure to be initialized and
*   installed.  'bmi' points to the image's BMInfo structure, from
*   which color-cycling information is retrieved.  'view' points to the
*   View to be loaded.
*
*   If everything went well, the routine returns a pointer to your
*   CycleIntInfo structure.
*
*   INPUTS
*   myci    - pointer to your CycleIntInfo structure
*   bmi - pointer to BMInfo structure of image to be displayed
*   view    - pointer to View to be loaded
*   cclist  - pointer to array of UWORD pointers, as generated by
*         FindViewRGB()
*   flags   - ????
*
*   RESULT
*   ci  - pointer to your CycleIntInfo structure, or NULL if
*         something went wrong
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   CloseViewMgr()
*
*****************************************************************************
*/
char __far cyclename[] = "cycle";

struct CycleIntInfo * __asm LIBStartViewMgr(
                        register __a0 struct CycleIntInfo    *ci,
                        register __a1 struct BMInfo          *bmi,
                        register __a2 struct View            *view,
                        register __a3 UWORD                  **cclist,
                        register __d0 UBYTE                  flags,
                        register __a6 struct PlayerPrefsBase *PlayerPrefsBase)
{
    VOID VertBIntr();

    MemSet( ci, 0L, sizeof( struct CycleIntInfo ));
    ci->cintd_oldview = GfxBase -> ActiView;
    ci->cintd_PlayerPrefsBase = PlayerPrefsBase;
    ci->cintd_GfxBase   = GfxBase;
    ci->cintd_DeBoxBase = DeBoxBase;
    ci->cintd_vtime     = (GfxBase->DisplayFlags & PAL ?
                            (1000000/50):(1000000/60));
    ci->cintd_VCountDown= 120;
    ci->cintd_Flags     = flags;
    ci->cintd_Fade0 =
        ci->cintd_Fade1 =
        ci->cintd_DestFade0 =
        ci->cintd_DestFade1 = 15;
    ci->cintd_MicroFadeDelay0 =
        ci->cintd_MicroFadeDelay1 = ci->cintd_vtime;

    ci->cintd_BMInfo    = bmi;

    LoadCycleView( ci,view,cclist );

    ci->cintd_intr.is_Node.ln_Type  = NT_INTERRUPT;
    ci->cintd_intr.is_Node.ln_Pri   = -60;
    ci->cintd_intr.is_Node.ln_Name  = cyclename;
    ci->cintd_intr.is_Data          = (APTR)ci;
    ci->cintd_intr.is_Code= VertBIntr;
    /* VertBIntr(ci); */

    AddIntServer(INTB_VERTB,ci);

    return(ci);
}



d979 1
a979 1
        DeletePort( r->io_Message.mn_ReplyPort );
d1035 1
a1035 1
    if (!(m = (struct MsgPort *)CreatePort(0L,0L))) return(NULL);
d1038 1
a1038 1
        DeletePort(m);
d1171 1
@


1.2
log
@Cleaned up code.  Should be no effective change.
@
text
@a1314 45
/*-----------------------------------------------------------------------*/



extern UBYTE __far      rock[];      /* the rock data */
extern UBYTE __far      bstrip[];    /* background */
extern UBYTE __far      ray[];       /* lazer beam */

WORD __far PosX[24] = {

    0,0,0,0,0,0,0,0,
    172,172,172,172,172,172,172,172,
    344,344,344,344,344,344,344,344
    };


WORD __far PosY[24] = {

    0,51,102,153,204,255,306,357,
    0,51,102,153,204,255,306,357,
    0,51,102,153,204,255,306,357
    };


struct BuildBg_Info __far TitleBg = {

    NULL, bstrip, NULL, rock,
    352, 296, 6,
    0, 50,
    NULL
    };

char __far TitlePortName[]  = "TitlePort";
char __far TitleErrorName[] = "TitleError";
char __far TitleTaskName[]  = "TitleTask";

UWORD __far ErrorCMap[] = {

    0x200,0xF60,0xF50,0xF40,0xE40,0xD30,0xC20,0xB10,
    0xA00,0x900,0x800,0x700,0x000,0x000,0x000,0x000,
    0x600,0x000,0x500,0x920,0xF00,0xD30,0x700,0xC00,
    0xC00,0x500,0x000,0xD00,0xF00,0xC00,0xD00,0xE00
    };


a1472 1
VOID __saveds TitleProgram();
d1475 1
a1475 10
                        register __a6 struct PlayerPrefsBase *PlayerPrefsBase)
{
    int                     ans = 1;
    struct Message          msg;
    struct MsgPort          *rport;

    ObtainSemaphore( &PlayerPrefsBase->ppb_LibLock );

    if ((state < 0) || (state > TITLESTATUS_MAX)) {ans = 0; goto xit; }

d1477 1
a1477 32
    Forbid();
    if (!PlayerPrefsBase->ppb_TitlePort) {

        Permit();
        if (state <= TITLESTATUS_LEAVE) goto xit;
        /* I can permit now since there is no way for the TitlePort
         * to come into existance.  Its impossible. No one can get at 
         * the semaphore. Until this title task is up an running or
         * fails to run.
         */
        PlayerPrefsBase->ppb_TitleStatus = state;

        ans = launchPPTask(TitleTaskName, 2,(APTR)TitleProgram, 2000, PlayerPrefsBase );
        }

    else {
        /* Already a task */
        if (rport = (struct MsgPort *)CreatePort (0L,0L)) {
            msg.mn_ReplyPort = rport;
            msg.mn_Node.ln_Type = NT_MESSAGE;
            msg.mn_Length = state;
            PutMsg (PlayerPrefsBase->ppb_TitlePort, &msg);
            Permit();
            WaitPort (rport);
            DeletePort (rport);
            ans = msg.mn_Length;
        }
        else
        {
            Permit();
            ans = 0;
        }
a1478 5
xit:
        /* now other tasks can call this routine */
    ReleaseSemaphore( &PlayerPrefsBase->ppb_LibLock );
    return(ans);
}
a1556 267
struct Message *handletitlemsg( struct PlayerPrefsBase *PlayerPrefsBase )
{
    struct Message *msg;

    if (msg = GetMsg(PlayerPrefsBase->ppb_TitlePort))
    {
        ScreenSaverCommand(SCRSAV_UNSAVE);
        PlayerPrefsBase->ppb_TitleStatus = msg->mn_Length;
        if (msg->mn_Length > TITLESTATUS_LEAVE)
        {
            msg->mn_Length = 1;
            ReplyMsg( msg );
            msg = NULL;
        }
        else msg->mn_Length = 1;
    }
    return(msg);
}


/***************************************************************************
* TitleProgram()
*
* The task that will display the title.   The program will open a message
* a private message port that is stored in ppb_TitlePort in the library
* base.  There is an optional exit that will be the copyright screen.
* In this case the caller must take down the screen using the call
* FreeCopyright().
****************************************************************************/

/* unspoof the SysBase pragma */
/* #undef SysBase */

VOID __saveds TitleProgram() {

int                      ans = 0;
struct BMInfo           *mbmi = NULL;
struct BitMap           *mbm1 = NULL, *mbm2 = NULL;
struct View             *ov = NULL;
struct View             *view1 = NULL, *view2 = NULL;
UWORD                   *v1list[32], *v2list[32], cmap[32];
UWORD                    viewmgr = 0;
struct CycleIntInfo      ci;
int                      i, fade, fadeto;
struct PlayerPrefsBase  *PlayerPrefsBase;
struct timerequest      *timer;
struct MsgPort          *titleport;
struct Message          *msg;
UWORD                    blank;

extern char __far        _LibName[];

    Forbid();
    if (!(PlayerPrefsBase = (struct PlayerPrefsBase *)OpenLibrary(_LibName, 0L))) return;

    if (PlayerPrefsBase->ppb_TitlePort || !(titleport = (struct MsgPort *)CreatePort(0L, 0L))) {

        sigPPTask(PlayerPrefsBase, 0);
        CloseLibrary(PlayerPrefsBase);
        return;
        }

    PlayerPrefsBase->ppb_TitlePort = titleport;
    
    sigPPTask(PlayerPrefsBase, 1);
    Permit();

    ConfigureCDTV(NULL);
    
    /* FRAME COUNT TIMER */
    if (!(timer = AllocIORequest(TimerDeviceName, UNIT_VBLANK, 0, sizeof(*timer)))) goto xit;

    timer->tr_node.io_Command = TR_ADDREQUEST;
    timer->tr_time.tv_secs    = 0;

    if (msg = handletitlemsg(PlayerPrefsBase)) goto xit;

    if (!(BuildBg(&TitleBg, &mbmi, &mbm1))) goto xit;

    if (msg = handletitlemsg(PlayerPrefsBase)) goto xit;

    if (!(mbm2 = AllocBitMap(mbmi->bmi_Depth, mbmi->bmi_Width, mbmi->bmi_Height))) goto xit;

    BltBitMap(mbm1, 0, 0, mbm2, 0, 0, mbm1->BytesPerRow<<3, mbm1->Rows, 0xc0, 0xff, NULL);
/*
    if (!(FillForeground(mbm2, NULL, ray, 118, 123, NULL))) goto xit;
*/
    if (!(view1 = (struct View *)CreateView(NULL, mbm1, mbmi->bmi_Width, mbmi->bmi_Height, EXTRA_HALFBRITE))) goto xit;
    if (!(view2 = (struct View *)CreateView(NULL, mbm2, mbmi->bmi_Width, mbmi->bmi_Height, EXTRA_HALFBRITE))) goto xit;

    CenterCDTVView(NULL, view1, mbmi->bmi_Width, mbmi->bmi_Height);
    CenterCDTVView(NULL, view2, mbmi->bmi_Width, mbmi->bmi_Height);

    if (msg = handletitlemsg(PlayerPrefsBase)) goto xit;
/*
    WriteTinyStr(mbm1, 18, 235, 53, PlayerPrefsBase->ppb_CDTVVersionStr);
    WriteTinyStr(mbm2, 18, 235, 53, PlayerPrefsBase->ppb_CDTVVersionStr);
*/
    if (msg = handletitlemsg(PlayerPrefsBase)) goto xit;

    FindViewRGB(view1, v1list, 32);
    FindViewRGB(view2, v2list, 32);

    ov = GfxBase->ActiView;

    StartViewMgr(&ci, mbmi, view1, v1list, CINTD_NOCYCLE);

    viewmgr = 1;
    ci.cintd_MicroFadeDelay0 = 16666;
    ci.cintd_MicroFadeDelay1 = 16666;
    ci.cintd_AltCMap         = ErrorCMap;

    ci.cintd_FadeMask = 0;

    if (msg = handletitlemsg(PlayerPrefsBase)) goto xit;

    for (i=0; i<32; i++) cmap[i] = mbmi->bmi_ColorMap[i];
    fade = fadeto = 0;

    i = 0;
    LoadCycleView(&ci, view1, v1list);    
    
    /* Make sure the screen saver is the same priority as this task
     * I am running this task at higher priorities so that some of
     * carls wait loops will not happen.
     */
    InstallScreenSaver(); 
    InstallKeyClick();
    InstallJoyMouse();
    
    /*
     * Bump all the priorities up to this level
     */
    {
        struct Task *tk;
        UBYTE pri;
        extern char __far scrsav[];

        Forbid();
        pri = FindTask(NULL)->tc_Node.ln_Pri;
        if (tk = FindTask(scrsav)) SetTaskPri(tk, pri);
        Permit();
        }

    WaitTOF(); WaitTOF(); /* Give it a possible head start */
    blank = handlescrsave(&ci, -1, PlayerPrefsBase);
    KeyClickCommand(CLKCMD_SETREPEAT, 0, 0, 0, 0, 0);

    ci.cintd_DestFade0 = 0;

    while (1) {

        timer->tr_time.tv_micro = 41666;
        SendIO(timer);

        switch (ans) {

            case TITLESTATUS_NORMAL:
                fadeto = 0;
                ans = 1;
                break;

            case TITLESTATUS_ERROR:
                fadeto = 15;
                ans = 1;
                break;

            case TITLESTATUS_CDTM:
            case TITLESTATUS_LEAVE:
                ci.cintd_DestFade0 = 15;    /* Fade out */
                ans = 0;
                break;
            }

        ci.cintd_VCountDown = 1;
        if (ans) blank = handlescrsave(&ci, blank, PlayerPrefsBase);
        
            /* This will stop at the timer and wait for the next frame
             */
        if (blank) goto afterrender;

        if (fadeto != fade) {

            if (fadeto < fade)  fade--;
            else                fade++;

            FadeCMap(cmap, ErrorCMap, mbmi->bmi_ColorMap, 32, fade);
            }

/*
        WaitBlit();
        LoadCycleView(&ci, view1, v1list);
        WaitTOF();
*/
        if (fadeto != fade) {

            if (fadeto < fade)  fade--;
            else                fade++;

            FadeCMap(cmap, ErrorCMap, mbmi->bmi_ColorMap, 32, fade);
            }
        
        LoadCycleView(&ci, view2, v2list);
        WaitTOF();

        if (++i >= 24) i=0;

afterrender:
        if (!msg) msg = handletitlemsg(PlayerPrefsBase);

        ans = PlayerPrefsBase->ppb_TitleStatus;

        if (!ans || ((ci.cintd_Fade0 >= 15) && (ans == TITLESTATUS_LEAVE))) {

            PlayerPrefsBase->ppb_TitleStatus = 0;
            break;
            }       

        SafeWaitIO( timer );
        }

xit:
    RemoveJoyMouse();
    KeyClickCommand(CLKCMD_DIE,0,0,0,0,0);
    ScreenSaverCommand(SCRSAV_DIE); 
    Forbid();

    if (viewmgr) CloseViewMgr(&ci);
    if (view2)   DeleteView((struct SuperView *)view2);
    if (view1)   DeleteView((struct SuperView *)view1);
    if (mbm2)    FreeBitMap(mbm2);
    if (mbmi)    FreeBMInfo(mbmi);
    if (mbm1)    FreeBitMap(mbm1);

    if (timer) {

        SafeWaitIO(timer);
        FreeIORequest(timer);
        }

    if (titleport) {

        struct Message *msg1; 

        while(msg1 = GetMsg(titleport)) {

            if (msg1->mn_Length > TITLESTATUS_LEAVE) msg1->mn_Length = 0;

            ReplyMsg(msg1);
            }

        DeletePort(titleport);
        }

    PlayerPrefsBase->ppb_TitleStatus = -1; /* Task has exited */
    PlayerPrefsBase->ppb_TitlePort = NULL;

    if (ov) LoadView(ov);

    if (msg) ReplyMsg(msg);

    CloseLibrary(PlayerPrefsBase);

    /* Still forbid */

    return;
    }
@


1.1
log
@Initial revision
@
text
@a250 3
#if 0
    kprintf("\nview, Dy=%ld, Dx=%ld,Modes=%lx\n",
        v->DyOffset,v->DxOffset,v->Modes);
a251 8
    kprintf("viewport, DW=%ld,DH=%ld,Dx=%ld,Dy=%ld,Modes=%lx,SP=%lx,EM=%lx\n",
    vp->DWidth,vp->DHeight,vp->DxOffset,vp->DyOffset,vp->Modes,
    vp->SpritePriorities,vp->ExtendedModes);

    kprintf("rasinfo, Rx=%ld, Ry=%ld\n",
        vp->RasInfo->RxOffset,vp->RasInfo->RyOffset);

#endif
a1321 1
extern UBYTE __far      cdtvrotate[];/* rotating logo */
d1323 2
a1324 2
WORD __far PosX[24] =
{
d1328 2
a1329 1
};
d1331 1
a1332 2
WORD __far PosY[24] =
{
d1336 2
a1337 1
};
d1339 1
d1341 3
a1343 5
struct BuildBg_Info __far TitleBg =
{
    NULL,bstrip, NULL,rock,
    352,296,6,
    0,94,
d1345 1
a1345 1
};
d1347 1
a1347 1
char __far TitlePortName[] = "TitlePort";
d1349 1
a1349 1
char __far TitleTaskName[] = "TitleTask";
d1352 1
d1357 1
a1357 1
};
d1457 2
a1458 2
VOID sigPPTask(struct PlayerPrefsBase *PlayerPrefsBase, int val )
{
d1461 5
a1465 6
    if ( PlayerPrefsBase->ppb_TitleSigTask &&
         (PlayerPrefsBase->ppb_TitleSigNo != -1))
    {
        Signal( PlayerPrefsBase->ppb_TitleSigTask,
                1<<PlayerPrefsBase->ppb_TitleSigNo );
    }
d1469 1
a1469 1
}
d1533 2
a1534 2
    if (!PlayerPrefsBase->ppb_TitlePort)
    {
d1536 1
a1536 1
        if (state <= TITLESTATUS_LEAVE)     goto xit;
d1544 3
a1546 3
        ans = launchPPTask(TitleTaskName, 2,(APTR)TitleProgram, 2000,
                            PlayerPrefsBase );
    }
d1654 1
a1654 1
        ScreenSaverCommand( SCRSAV_UNSAVE );
a1667 31
struct BitMap *openCDTVRotateBm( register struct PlayerPrefsBase *PlayerPrefsBase )
{
    register struct BitMap *bm;

    ObtainSemaphore( &PlayerPrefsBase->ppb_CRLock );
    if (PlayerPrefsBase->ppb_CRBm)
    {
        bm = PlayerPrefsBase->ppb_CRBm;
        PlayerPrefsBase->ppb_CROpenCnt++;
    }
    else
    {
        GrabBm( NULL, cdtvrotate, NULL, &PlayerPrefsBase->ppb_CRBm, NULL );
        bm = PlayerPrefsBase->ppb_CRBm;
        PlayerPrefsBase->ppb_CROpenCnt = 1;
    }
    ReleaseSemaphore( &PlayerPrefsBase->ppb_CRLock );
    return(bm);
}

VOID closeCDTVRotateBm( register struct PlayerPrefsBase *PlayerPrefsBase)
{
    ObtainSemaphore( &PlayerPrefsBase->ppb_CRLock );
    if (PlayerPrefsBase->ppb_CRBm)
    {
        if (--PlayerPrefsBase->ppb_CROpenCnt <= 0)
            FreeGrabBm( NULL,&PlayerPrefsBase->ppb_CRBm,NULL );
    }
    ReleaseSemaphore( &PlayerPrefsBase->ppb_CRLock );
}

d1681 26
a1706 29
VOID __saveds TitleProgram()
{
/*        struct Library *SysBase = (*((struct Library **) 4)); */
    int             ans = 0;
    struct BMInfo           *mbmi = NULL;
    struct BitMap           *mbm1 = NULL,*mbm2 = NULL;
    struct View             *ov = NULL;
    struct View             *view1 = NULL,*view2 = NULL;
    struct BitMap           *cdtvbm;
    UWORD                   *v1list[32],*v2list[32],cmap[32];
    UWORD                   viewmgr = 0;
    struct CycleIntInfo     ci;
    int                     i,fade,fadeto;
    extern char __far       _LibName[];
    struct PlayerPrefsBase  *PlayerPrefsBase;
    struct timerequest      *timer;
    struct MsgPort          *titleport;
    struct Message          *msg;
    UWORD                   blank;

    Forbid();
    if (!(PlayerPrefsBase = (struct PlayerPrefsBase *)
        OpenLibrary(_LibName,0L))) return;

    if (PlayerPrefsBase->ppb_TitlePort ||
        !(titleport = (struct MsgPort *)CreatePort(0L,0L)))
    {
        sigPPTask( PlayerPrefsBase, 0 );
        CloseLibrary( PlayerPrefsBase );
d1708 1
a1708 1
    }
d1712 1
a1712 1
    sigPPTask(PlayerPrefsBase,1);
d1715 1
a1715 1
    ConfigureCDTV( NULL );
d1718 2
a1719 3
    if (!(timer = AllocIORequest( TimerDeviceName, UNIT_VBLANK, 0,
                    sizeof( *timer )))) 
        goto xit;
d1721 1
a1721 1
    timer->tr_time.tv_secs = 0;
d1725 1
a1725 1
    if (!(BuildBg( &TitleBg, &mbmi,&mbm1 ))) goto xit;
d1729 1
a1729 6
    if (!(mbm2 = AllocBitMap(mbmi->bmi_Depth,mbmi->bmi_Width,mbmi->bmi_Height)))
        goto xit;

    BltBitMap(  mbm1,0,0,mbm2,0,0,
                mbm1->BytesPerRow<<3,mbm1->Rows,0xc0,0xff,NULL);
    if (!(FillForeground( mbm2, NULL, ray, 118,123, NULL ))) goto xit;
d1731 6
a1736 6
    if (!(view1 = (struct View *)CreateView( NULL, mbm1,
                        mbmi->bmi_Width,mbmi->bmi_Height,EXTRA_HALFBRITE)))
        goto xit;
    if (!(view2 = (struct View *)CreateView( NULL, mbm2,
                        mbmi->bmi_Width,mbmi->bmi_Height,EXTRA_HALFBRITE)))
        goto xit;
d1738 2
d1741 5
a1745 3
    CenterCDTVView(NULL,view1,mbmi->bmi_Width,mbmi->bmi_Height);
    CenterCDTVView(NULL,view2,mbmi->bmi_Width,mbmi->bmi_Height);

d1748 2
a1749 4
    WriteTinyStr(   mbm1, 18,235,53,
                    PlayerPrefsBase->ppb_CDTVVersionStr);
    WriteTinyStr(   mbm2, 18,235,53,
                    PlayerPrefsBase->ppb_CDTVVersionStr);
d1751 1
a1751 3
    if (!(cdtvbm = openCDTVRotateBm( PlayerPrefsBase ))) goto xit;

    if (msg = handletitlemsg(PlayerPrefsBase)) goto xit;
d1753 1
a1753 2
    FindViewRGB( view1,v1list,32);
    FindViewRGB( view2,v2list,32);
a1754 2
    ov = GfxBase->ActiView;
    StartViewMgr( &ci,mbmi,view1,v1list,CINTD_NOCYCLE );
d1758 1
a1758 1
    ci.cintd_AltCMap = ErrorCMap;
d1764 1
a1764 1
    for(i=0;i<32;i++) cmap[i] = mbmi->bmi_ColorMap[i];
d1768 1
a1768 2
    LoadCycleView( &ci,view1,v1list );
    
d1785 1
a1785 4
        /*
        extern char __far clickname[];
        extern char __far JoyMousePortName[];
        */
d1788 1
a1788 5
        if (tk = FindTask(scrsav))SetTaskPri(tk,pri);
#if 0
        if (tk = FindTask(clickname))           SetTaskPri(tk,pri);
        if (tk = FindTask(JoyMousePortName))    SetTaskPri(tk,pri);
#endif
d1790 2
a1791 1
    }
d1793 2
a1794 2
    blank = handlescrsave( &ci, -1, PlayerPrefsBase );
    KeyClickCommand( CLKCMD_SETREPEAT,0,0,0,0,0);
d1798 2
a1799 1
    while (1 ) {
d1801 4
a1804 4
        SendIO (timer);
        /* --- */
        switch(ans)
        {
d1809 1
d1814 1
d1820 1
a1820 1
        }
d1823 1
a1823 3
        if (ans)
            blank = handlescrsave( &ci, blank, PlayerPrefsBase );

d1827 1
a1827 2
        if (blank)
            goto afterrender;
d1829 1
a1830 2
        if (fadeto != fade)
        {
a1832 5
            FadeCMap( cmap,ErrorCMap,mbmi->bmi_ColorMap,32,fade);
        }
        WaitBlit();
        LoadCycleView( &ci,view1,v1list );
        WaitTOF();
d1834 2
a1835 1
        BltBitMap(cdtvbm,PosX[i],PosY[i],mbm2,137,75,172,51,0xc0,0xff,NULL);
d1837 1
d1839 4
a1843 2
        if (fadeto != fade)
        {
d1846 3
a1848 2
            FadeCMap( cmap,ErrorCMap,mbmi->bmi_ColorMap,32,fade);
        }
d1850 1
a1850 1
        LoadCycleView( &ci,view2,v2list );
a1852 2
        BltBitMap(cdtvbm,PosX[i],PosY[i],mbm1,137,75,172,51,0xc0,0xff,NULL);

d1856 1
a1856 2
        if (!msg)
            msg = handletitlemsg(PlayerPrefsBase);
d1859 3
a1861 2
        if (!ans || ((ci.cintd_Fade0 >= 15) && (ans == TITLESTATUS_LEAVE)))
        {
d1864 2
a1865 1
        }       
d1867 2
a1868 1
    }
d1872 1
a1872 3
    /* Get rid of the screen saver
     */
    ScreenSaverCommand( SCRSAV_DIE ); 
d1876 5
d1882 1
a1882 8
    if (view2) DeleteView( (struct SuperView *)view2 );
    if (view1) DeleteView( (struct SuperView *)view1 );
    if (mbm2) FreeBitMap( mbm2 );
    if (mbmi) FreeBMInfo( mbmi );
    if (mbm1) FreeBitMap( mbm1 );
    closeCDTVRotateBm( PlayerPrefsBase );


a1883 1
    if (timer) {
d1885 2
a1886 2
        FreeIORequest( timer );
    }
d1889 1
d1891 1
d1893 3
a1895 2
            if (msg1->mn_Length > TITLESTATUS_LEAVE)
                msg1->mn_Length = 0;
d1897 3
a1900 2
        DeletePort(titleport);
    }
d1914 1
a1914 1
}
@
