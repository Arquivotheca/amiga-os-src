head     1.28;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @* @;


1.28
date     93.02.18.16.26.32;  author darren;  state Exp;
branches ;
next     1.27;

1.27
date     93.02.04.10.37.14;  author darren;  state Exp;
branches ;
next     1.26;

1.26
date     93.02.03.16.17.25;  author darren;  state Exp;
branches ;
next     1.25;

1.25
date     93.02.03.11.45.46;  author darren;  state Exp;
branches ;
next     1.24;

1.24
date     92.04.22.10.43.48;  author darren;  state Exp;
branches ;
next     1.23;

1.23
date     92.04.15.08.40.07;  author darren;  state Exp;
branches ;
next     1.22;

1.22
date     92.04.13.14.20.58;  author darren;  state Exp;
branches ;
next     1.21;

1.21
date     92.04.02.18.46.49;  author darren;  state Exp;
branches ;
next     1.20;

1.20
date     92.04.02.17.06.12;  author darren;  state Exp;
branches ;
next     1.19;

1.19
date     92.03.11.13.06.24;  author darren;  state Exp;
branches ;
next     1.18;

1.18
date     92.03.09.09.07.20;  author darren;  state Exp;
branches ;
next     1.17;

1.17
date     92.03.06.09.53.42;  author darren;  state Exp;
branches ;
next     1.16;

1.16
date     92.03.06.09.26.46;  author darren;  state Exp;
branches ;
next     1.15;

1.15
date     92.03.05.20.03.50;  author darren;  state Exp;
branches ;
next     1.14;

1.14
date     92.03.05.15.48.45;  author darren;  state Exp;
branches ;
next     1.13;

1.13
date     92.03.04.19.18.56;  author darren;  state Exp;
branches ;
next     1.12;

1.12
date     92.03.04.19.13.18;  author darren;  state Exp;
branches ;
next     1.11;

1.11
date     92.02.24.12.15.46;  author darren;  state Exp;
branches ;
next     1.10;

1.10
date     92.02.24.11.54.33;  author darren;  state Exp;
branches ;
next     1.9;

1.9
date     92.02.21.15.35.02;  author darren;  state Exp;
branches ;
next     1.8;

1.8
date     92.02.21.10.35.25;  author darren;  state Exp;
branches ;
next     1.7;

1.7
date     92.02.19.17.00.38;  author darren;  state Exp;
branches ;
next     1.6;

1.6
date     92.02.19.16.58.04;  author darren;  state Exp;
branches ;
next     1.5;

1.5
date     92.02.17.15.42.59;  author darren;  state Exp;
branches ;
next     1.4;

1.4
date     92.02.14.17.56.54;  author darren;  state Exp;
branches ;
next     1.3;

1.3
date     92.02.14.12.03.36;  author darren;  state Exp;
branches ;
next     1.2;

1.2
date     92.01.30.16.04.23;  author darren;  state Exp;
branches ;
next     1.1;

1.1
date     92.01.13.11.01.43;  author darren;  state Exp;
branches ;
next     ;


desc
@Prepare to remove double VIEWPORT code - save this for reference
@


1.28
log
@Further limit X display positions to 0-26, which already
pushes the X hardware/display limits, and for now, prevents
negative numbers (possibly cutting into SPRITE slots I need)
@
text
@**
**	$Id: init.asm,v 1.27 93/02/04 10:37:14 darren Exp Locker: darren $
**
**	CDTV CD+G -- init.asm (initialize mem, data, etc)
**
**	(C) Copyright 1992 Commodore-Amiga, Inc.
**	    All Rights Reserved
**
**	
**

** Includes

		INCLUDE	"cdgbase.i"
		INCLUDE	"cdgprefs.i"
		INCLUDE	"cdgs_hw.i"
		INCLUDE	"cdgs:include/cd/cd.i"
		INCLUDE	"cdgs:src/cd/cdprivate.i"
		INCLUDE	"debug.i"

		INCLUDE "devices/serial.i"	;use serial name macro
** Exports

		XDEF	_CDGInit
		XDEF	_CDGFree
** Imports

		XREF	cdgname			;library.asm

		XREF	CDGPackInt		;interrupts.asm
		XREF	CDGVertInt

		XREF	CDGInitMidiOut		;midi.asm
		XREF	CDGFreeMidiOut

		XREF	_intena			;amiga.lib

		XREF	_LVOPermit		;required for PERMIT macro

** Assumptions

	IFNE	cdd_BitPlane1_1-cdd_BitPlane1_0-4
	FAIL	"cdd_BitPlane1_1 does not follow cdd_BitPlane1_0; recode!"
	ENDC

	IFNE	cdd_BitPlane1_2-cdd_BitPlane1_1-4
	FAIL	"cdd_BitPlane1_2 does not follow cdd_BitPlane1_1; recode!"
	ENDC

	IFNE	cdd_BitPlane1_3-cdd_BitPlane1_2-4
	FAIL	"cdd_BitPlane1_3 does not follow cdd_BitPlane1_2; recode!"
	ENDC

	IFNE	cdd_BitPlane1_Extra-cdd_BitPlane1_3-4
	FAIL	"cdd_Bitplane1_Extra does not follow cdd_Bitplane1_3; recode!"
	ENDC

	IFNE	cdd_BitPlane2_1-cdd_BitPlane2_0-4
	FAIL	"cdd_BitPlane2_1 does not follow cdd_BitPlane2_0; recode!"
	ENDC

	IFNE	cdd_BitPlane2_2-cdd_BitPlane2_1-4
	FAIL	"cdd_BitPlane2_2 does not follow cdd_BitPlane2_1; recode!"
	ENDC

	IFNE	cdd_BitPlane2_3-cdd_BitPlane2_2-4
	FAIL	"cdd_BitPlane2_3 does not follow cdd_BitPlane2_2; recode!"
	ENDC

	IFNE	cdd_BitPlane2_Extra-cdd_BitPlane2_3-4
	FAIL	"cdd_Bitplane2_Extra does not follow cdd_Bitplane2_3; recode!"
	ENDC

	IFNE	cdd_CDIO
	FAIL	"cdd_CDIO not first in CDGData struct; recode!"
	ENDC

	; InitStruct() checking - since cdd_PacketData may be set
	; quite large, its possible to have a CDGData area larger
	; than 64K!!!  Actually this is not a problem, but the
	; programmer needs to check that there are no elements after
	; cdd_PacketData which need to be inited (even if inited to 0
	; since I let InitStruct() clear the memory, and not AllocMem()).
	;
	; InitStruct() uses a DBF loop, which is a WORD size limited
	; loop, to clear memory.
	;

	IFGE	CDGData_SIZEOF-(64*1024)
		FAIL	"CDGData too large for InitStruct(); recode"
	ENDC

	; since I copy this bits, I need to make sure they are in the
	; same bit positions

	IFNE	EF3B_NOECC-CDGB_NOECC
	FAIL	"EF3B_NOECC != CDGB_NOECC; recode!"
	ENDC

	IFNE	EF3B_NOMIDI-CDGB_NOMIDI
	FAIL	"EF3B_NOMIDI != CDGB_NOMIDI; recode!"
	ENDC

	IFNE	EF3B_ALTSPRITES-CDGB_ALTSPRITES
	FAIL	"EF3B_ALTSPRITES != CDGB_ALTSPRITES; recode!"
	ENDC

** Equates


	;GACK!!! CDTV has no idea how big my view is, hence no idea
	;how to center me in PAL mode in Y or X.  X is close enough,
	;but need something for Y.  Should really be done in the
	;player module, except the owner of that module is not
	;available.  25 is based on an NTSC screen, minus what we
	;already subtract for 1/2 font height


PAL_KLUDGE	EQU	25

		SECTION	cdg

*****i* cdg.library/_CDGFree ******************************************
*
*   NAME
*	_CDGFree -- Free data structure
*   
*   SYNOPSIS
*	VOID _CDGFree( CDGBase )
*	                 A5
*
*	VOID _CDGDispatch( struct CDGBase * );
*
*   FUNCTION
*	Free all memory, etc., allocated by _CDGInit()
*
*   RETURNS
*	None.
*
*   NOTES
*	Should only be called if _CDGInit() succeeded!!!
*
***********************************************************************

_CDGFree:
	PRINTF	DBG_ENTRY,<'CDG--_CDGFree($%lx)'>,A5

		movem.l	d2-d7/a2-a6,-(sp)

		move.l	cdg_BaseData(a5),d0
		beq	CDGInit_FAIL0

		move.l	d0,a4
		bra	CDGInit_FREEDATA

*****i* cdg.library/_CDGInit ******************************************
*
*   NAME
*	_CDGInit -- Initialize data module
*   
*   SYNOPSIS
*	result = _CDGInit( CDGBase, CDGPrefs )
*	D0                 A5		A4
*
*	struct CDGData *_CDGDispatch( struct CDGBase *, struct CDGPrefs * );
*
*   FUNCTION
*	Allocate memory, initialize data, etc.
*
*   RETURNS
*	result - Pointer to initialized CDGData structure, or NULL
*	indicating failure.
*
***********************************************************************
_CDGInit:

	PRINTF	DBG_ENTRY,<'CDG--_CDGInit($%lx,$%lx)'>,A5,A4

		movem.l	d2-d7/a2-a6,-(sp)

		move.l	a4,a3			;cache

		move.l	cdg_ExecLib(a5),a6
		move.l	#CDGData_SIZEOF,d0

		move.l	#MEMF_PUBLIC,d1

	PRINTF	DBG_OSCALL,<'CDG--AllocMem($%lx,$%lx)'>,D0,D1

		JSRLIB	AllocMem

	PRINTF	DBG_OSCALL,<'CDG--CDGData @@ $%lx'>,D0

		tst.l	d0
		beq	CDGInit_FAIL0

		move.l	d0,a4

	; init struct stuff

		move.l	d0,a2
		move.l	#CDGData_SIZEOF,d0
		lea	initdata(pc),a1

	PRINTF	DBG_OSCALL,<'CDG--InitStruct($%lx,$%lx,$%lx)'>,A1,A2,D0

		JSRLIB	InitStruct

	; initialize back pointer

		move.l	a5,cdd_CDGBase(a4)

	; and ExecBase pointer

		move.l	a6,cdd_ExecLib(a4)

	; and CDGPrefs

		move.l	a3,cdd_CDGPrefs(a4)

	; copy relevant data that we don't want to dereference for lookup

		move.l	cdgp_SigMask(a3),cdd_SigMask(a4)
		move.l	cdgp_SigTask(a3),cdd_SigTask(a4)

		move.b	cdgp_Control+1(a3),cdd_ExtraFlags3(a4)


	; Obtain VBLANK rate from execbase.  While perhaps not perfect,
	; it is adequate for simple timing needs

		move.b	VBlankFrequency(a6),cdd_VBlankRate+1(a4)

	; Open cd.device

		lea	cdd_CDPORT(a4),a0

		move.l	a0,cdd_CDIO+MN_REPLYPORT(a4)
		move.b	#NT_REPLYMSG,cdd_CDIO+LN_TYPE(a4)
		move.w	#IOSTD_SIZE,cdd_CDIO+MN_LENGTH(a4)

		move.b	#NT_MSGPORT,LN_TYPE(a0)
		move.b	#PA_SIGNAL,MP_FLAGS(a0)
		move.b	#SIGB_SINGLE,MP_SIGBIT(a0)
		move.l	ThisTask(a6),MP_SIGTASK(a0)
		lea	MP_MSGLIST(a0),a1
		NEWLIST	a1

		lea	cddevname(pc),a0
		moveq	#00,d0
		move.l	a4,a1		;iorequest is 1st in structure!
		moveq	#00,d1		;which is ideal for FRAMECALL interrupt

	PRINTF	DBG_OSCALL,<'CDG--OpenDevice($%lx,$%lx,$%lx,$%lx)'>,A0,D0,A1,D1

		JSRLIB	OpenDevice
		
		tst.l	d0
		bne	CDGInit_FAIL1

		move.l	IO_DEVICE(a4),a1
		move.l	db_CDSUBPage(a1),cdd_SubCodeBank(a4)

	PRINTF	DBG_FLOW,<'CDG--SubCodes @@$%lx'>,cdd_SubCodeBank(a4)

	; open graphics.library

		lea	gfxname(pc),a1
		moveq	#37,d0

	PRINTF	DBG_OSCALL,<'CDG--OpenLibrary($%lx,$%lx)'>,A1,D0

		JSRLIB	OpenLibrary

		tst.l	d0
		beq	CDGInit_FAILVER

	PRINTF	DBG_OSCALL,<'CDG--GfxBase @@ $%lx'>,D0

		move.l	d0,cdd_GfxLib(a4)
		move.l	d0,a3

		
		exg	a3,a6			;use gfxbase, cache exec

	;
	; Make sure blitter interrupts are disabled, as they should
	; be, however there is a bug in V37 graphics.library (and
	; earlier versions) which cause blitter interrupts to be
	; left enabled at startup time.  This happens when Graphics
	; calls CIA AddICRVector(), and the CIA-B TOD ALARM is in
	; a state that it generates an immediate CIA-B TOD interrupt.
	;
	; Graphics then enables interrupts, and leaves them enabled
	; until GELS are used once (which uses the CIA-B TOD counter
	; for beam collision detection during blits).  Once the blit
	; is done, blitter interrupts are then disabled again.  However
	; if the machine comes up with blitter interrupts enabled
	; (about 1 in 10x on 68000 machines), then all blitter operations
	; end up causing an interrupt, and hence, considerably slower.
	;
	; This bug is fixed for V38 graphics, but ... not in time for
	; CDTV-CR.  A fix is in SetPatch though.
	;
		JSRLIB	OwnBlitter
		JSRLIB	WaitBlit
		move.w	#INTF_BLIT,_intena
		JSRLIB	DisownBlitter

	; Initialize graphics structures (bitmaps first)

		lea	cdd_BitMap1(a4),a0
		moveq	#DISPLAY_DEPTH,d0
		move.w	#DISPLAY_WIDTH,d1
		move.w	#DISPLAY_HEIGHT,d2

	PRINTF	DBG_OSCALL,<'CDG--InitBitMap($%lx,$%lx,$%lx,$%lx)'>,A0,D0,D1,D2

		JSRLIB	InitBitMap

	; Allocate DISPLAY_DEPTH-1 bitplanes for BitMap structure

		lea	cdd_BitMap1(a4),a2
		lea	cdd_RasInfo1(a4),a0
		move.l	a2,ri_BitMap(a0)

		move.w	#DISPLAY_WIDTH,d0
		move.w	#((DISPLAY_DEPTH-1)*DISPLAY_HEIGHT),d1

	PRINTF	DBG_OSCALL,<'CDG--AllocRaster($%lx,$%lx)'>,D0,D1

		JSRLIB	AllocRaster

		tst.l	d0
		beq	CDGInit_FAIL2

		;stash pointer for BltClear

		move.l	d0,a1

		; store bit plane pointers

		moveq	#DISPLAY_DEPTH-2,d2
		lea	bm_Planes(a2),a0
		lea	cdd_BitPlane1_0(a4),a2

CDGInit_BM1:

	PRINTF	DBG_FLOW,<'CDG--BitMap Raster @@ $%lx'>,D0

		move.l	d0,(a0)+
		move.l	d0,(a2)+
		addq.w	#APTR_SIZE,d1		;old code - could be removed
		add.l	#((DISPLAY_WIDTH*DISPLAY_HEIGHT)/8),d0
		dbf	d2,CDGInit_BM1

	; BltClear this memory - Use BytesPerRow mode, and do NOT wait
	; Shift DISPLAY_HEIGHT << 18 (16 to move to upper word, plus
	; * 4 for 4 bitplanes)

		move.l	#((DISPLAY_HEIGHT<<18)!(DISPLAY_WIDTH/8)),d0
		move.l	#(1<<1),d1

	PRINTF	DBG_OSCALL,<'CDG--BltClear($%lx,$%lx,$%lx)'>,A1,D0,D1

		JSRLIB	BltClear

	; Allocate DISPLAY_DEPTH-1 bitplanes for BitMap2

		move.w	#DISPLAY_WIDTH,d0
		move.w	#((DISPLAY_DEPTH-1)*DISPLAY_HEIGHT),d1

	PRINTF	DBG_OSCALL,<'CDG--AllocRaster($%lx,$%lx)'>,D0,D1

		JSRLIB	AllocRaster

		tst.l	d0
		beq	CDGInit_FAIL3

		;stash pointer for BltClear

		move.l	d0,a1

		; store bit plane pointers

		moveq	#DISPLAY_DEPTH-2,d2
		lea	cdd_BitPlane2_0(a4),a0

CDGInit_BM2:

	PRINTF	DBG_FLOW,<'CDG--BitMap Raster @@ $%lx'>,D0

		move.l	d0,(a0)+
		add.l	#((DISPLAY_WIDTH*DISPLAY_HEIGHT)/8),d0
		dbf	d2,CDGInit_BM2

	; BltClear this memory - Use BytesPerRow mode, and do NOT wait
	; Shift DISPLAY_HEIGHT << 18 (16 to move to upper word, plus
	; * 4 for 4 bitplanes)

		move.l	#((DISPLAY_HEIGHT<<18)!(DISPLAY_WIDTH/8)),d0
		move.l	#(1<<1),d1

	PRINTF	DBG_OSCALL,<'CDG--BltClear($%lx,$%lx,$%lx)'>,A1,D0,D1

		JSRLIB	BltClear

	; Allocate an extra bit-plane, and store as bitplane 3.  Also
	; swap bitplane 3 as stored above into bitplane 4.
	;
	; This allows us to do the following -
	;
	; Bit plane 3 is ALL 1's all the time.  Hence the minimum displayable
	; color is color 8.
	;
	; Colors 0-7 are never used.
	;
	; Color 0 is the border color!!! And settable independently
	; of the display.  Important requirement for CD+G specification.
	;
	; Colors 8-15, and 24-31 are useable as the 16 colors needed for the
	; graphics display.
	;
	; Colors 16-23 are used for our 8 color sprite when channel
	; selection is being displayed.
	;
	; Here is how it looks on a graph
	;
	;	BitPlanes -> 4 3 2 1 0
	;
	;                    x 1 x x x  (minimum %01000 max %11111 )
	;                               (        #$08       #$31   )
	;
	; The following are possible
	;
	;	BINARY  DECIMAL  USE
	;	COLOR # COLOR #  FOR CD+G DISPLAY
	;
	;	01000   08	 Graphics color 0   T C = 16 (08-15 & 24-31)
	;	01001   09       Graphics color 1   O O
	;       ...                                 T L
	;       01111   15       Graphics color 7   A O
	;       11000   24       Graphics color 8   L R
	;       ...                                   S
	;	11111   31       Graphics color 15
	;
	; Note that bitplanes 0, 1, 2, and 4 can be therefore be treated
	; as a set of 4 bitplanes, and are allocated as contiguous memory
	; for blitter efficiency reasons.  Bitplane 3 can be ignored
	; and is always set to 1's.  Color index 0-7 are unused, making
	; it possible to set border color.  Color index 16-23 are unused,
	; and are used for sprites, which must use colors 16-31.
	;

		move.w	#DISPLAY_WIDTH,d0
		move.w	#DISPLAY_HEIGHT,d1

		JSRLIB	AllocRaster

	PRINTF	DBG_OSCALL,<'CDG--$%lx=AllocRaster()'>,D0

		tst.l	d0
		beq	CDGInit_FAIL4

		move.l	d0,cdd_ExtraRaster1(a4)
		move.l	d0,cdd_BitPlane1_Extra(a4)
		move.l	d0,cdd_BitPlane2_Extra(a4)

	; store as 3rd bitplane in bitmap structs

		lea	cdd_BitMap1(a4),a0
		lea	bm_Planes(a0),a0
		move.l	12(a0),16(a0)		;move bitplane 3->4
		move.l	d0,12(a0)		;store extra plane as plane 3

	; BltClear this memory - Use BytesPerRow mode, and DO wait
	; Shift DISPLAY_HEIGHT << 18 (16 to move to upper word, plus
	; * 4 for 4 bitplanes)
	;
	; We want this to WAIT for the blitter to finish so we are
	; sure all memory is set-up at first LoadView time!
	;
	; This is the extra bitplane which is always set to 1's,
	; and BltClear can do this by passing in a value in the FLAGS
	; argument to fill with.

		move.l	d0,a1
		move.l	#((DISPLAY_HEIGHT<<16)!(DISPLAY_WIDTH/8)),d0
		move.l	#(($FFFF<<16)!(1<<0)!(1<<1)!(1<<2)),d1

	PRINTF	DBG_OSCALL,<'CDG--BltClear($%lx,$%lx,$%lx)'>,A1,D0,D1

		JSRLIB	BltClear

	; allocate extra memory for 4 sprites, and work room for
	; TV GRAPHICS FONT data

		move.l	cdd_CDGPrefs(a4),a0

		moveq	#00,d0
		move.w	cdgp_SpriteHeight(a0),d0
		addq.l	#2,d0			;plus 1 line terminator, and 1 posctrl
		lsl.l	#4,d0			;X (4 bytes per line, and 4 sprites)

	; add enough extra memory for 4 12 bit high TV GFX FONTS -
	; but make them 4 bytes wide for convienent blitter manipulation

		add.l	#(FONT_HEIGHT*4*4),d0
		move.l	d0,cdd_4SpriteSize(a4)	;cache
		move.l	#MEMF_CHIP!MEMF_CLEAR,d1
		exg	a3,a6			;use execbase

	PRINTF	DBG_OSCALL,<'CDG--AllocMem($%lx,$%lx)'>,D0,D1

		JSRLIB	AllocMem

	PRINTF	DBG_OSCALL,<'CDG--$%lx=AllocMem()'>,D0

		tst.l	d0
		beq	CDGInit_FAIL5

	; stash pointers to sprite data memory

		move.l	d0,cdd_4SpriteData(a4)
		move.l	cdd_CDGPrefs(a4),a0
		moveq	#00,d1
		move.w	cdgp_SpriteHeight(a0),d1
		addq.l	#2,d1			;plus 1 terminator, and 1 posctrl
		lsl.l	#2,d1			;* 4 bytes per line
		add.l	d1,d0
		move.l	d0,cdd_SpriteData3(a4)
		add.l	d1,d0
		move.l	d0,cdd_SpriteData4(a4)
		add.l	d1,d0
		move.l	d0,cdd_SpriteData5(a4)
		add.l	d1,d0

	; and pointers to TFV GFX FONT data
		move.l	d0,cdd_FontPlane(a4)
		moveq	#(FONT_HEIGHT*4),d1
		add.l	d1,d0
		move.l	d0,cdd_NegPlane(a4)
		add.l	d1,d0
		move.l	d0,cdd_1sPlane(a4)
		add.l	d1,d0
		move.l	d0,cdd_0sPlane(a4)

	; pre-fill 1's plane

		moveq	#(FONT_HEIGHT-1),d1
		move.l	cdd_1sPlane(a4),a0
		move.l	#$FC000000,d0
CDGInit_Fill1s:
		move.l	d0,(a0)+
		dbf	d1,CDGInit_Fill1s

		exg	a3,a6			;use gfxbase

	; Initialize other Gfx structures - these are already 0's,
	; but its better to use the standard Gfx calls to init these
	; for future compatability, and ease of modification later

		lea	cdd_View1(a4),a2
		move.l	a2,a1

	; set the initial ActiveView ptr up too since we have the
	; pointer handy

	PRINTF	DBG_OSCALL,<'CDG--InitView($%lx)'>,A1

		JSRLIB	InitView

		lea	cdd_ViewPort1(a4),a0
		move.l	a0,v_ViewPort(a2)
		move.l	a0,a2

	PRINTF	DBG_OSCALL,<'CDG--InitVPort($%lx)'>,A0

		JSRLIB	InitVPort

		; Initialization of ViewPort

		lea	cdd_RasInfo1(a4),a0
		move.w	#VISUAL_X,ri_RxOffset(a0)
		move.w	#VISUAL_Y,ri_RyOffset(a0)

		move.l	a0,vp_RasInfo(a2)
		move.w	#VISUAL_WIDTH,vp_DWidth(a2)
		move.w	#VISUAL_HEIGHT,vp_DHeight(a2)
		or.w	#V_SPRITES,vp_Modes(a2)

	; calculate min left edge, and set DxOffset.  Minimum is
	; based on worst case position possible without losing any
	; sprite DMA

		lea	cdd_View1(a4),a0

		move.l	cdd_CDGPrefs(a4),a1
		move.w	cdgp_DisplayX(a1),d0
		cmp.w	cdd_MinDisplayX(a4),d0
		bge.s	CDGInit_XInRange	;signed compare!

		move.w	cdd_MinDisplayX(a4),d0	;limit

CDGInit_XInRange:
		cmp.w	#26,d0			;realistic limits
		blt.s	CDGInit_XMaxRange
		move.w	#26,d0
CDGInit_XMaxRange:
		move.w	d0,cdd_MinDisplayX(a4)	;cache for future reference

		add.w	#CENTER_X,d0
		cmp.w	#350,d0			;well, almost max of +362
		ble.s	CDGInit_XMaxed
		move.w	#350,d0
CDGInit_XMaxed:

		add.w	d0,v_DxOffset(a0)

	; same idea for Y, but there is no sprite limitation - there is
	; a reasonable limit however meant to give us suitable VBLANK
	; bandwidth

		moveq	#-14,d1			;not quite true limit of -15 PAL
		move.w	cdgp_DisplayY(a1),d0
		cmp.w	d1,d0
		bge.s	CDGInit_YInRange
		move.w	d1,d0
CDGInit_YInRange:
		move.w	#CENTER_Y,d1

		move.w	gb_DisplayFlags(a6),d1
		and.w	#PAL,d1
		beq.s	CDGInit_NotPal

		add.w	#PAL_KLUDGE,d1		;kludge for PAL centering (yuck!)
CDGInit_NotPal:
		add.w	d1,d0			;and center screen

		cmp.w	#200,d0			;well, almost max of +217
		ble.s	CDGInit_YMaxed
		move.w	#200,d0
CDGInit_YMaxed:
		add.w	d0,v_DyOffset(a0)

		; final step is to obtain a color map

		moveq	#(1<<DISPLAY_DEPTH),d0

	PRINTF	DBG_OSCALL,<'CDG--GetColorMap($%lx)'>,D0

		JSRLIB	GetColorMap

	PRINTF	DBG_OSCALL,<'CDG--$%lx=GetColorMap()'>,D0

		tst.l	d0
		beq	CDGInit_FAIL6

		move.l	d0,vp_ColorMap(a2)

	; Create intermediate copper lists

		lea	cdd_View1(a4),a0
		lea	cdd_ViewPort1(a4),a1

	PRINTF	DBG_OSCALL,<'CDG--MakeVPort($%lx,$%lx)'>,A0,A1

		JSRLIB	MakeVPort

	;;;	TST.L	D0		-- not implemented for V37
	;;;	BNE.s	CDGInit_FAIL8	-- usable in V39???

	; Create copper lists

		lea	cdd_View1(a4),a1

	PRINTF	DBG_OSCALL,<'CDG--MrgCop($%lx)'>,A1

		JSRLIB	MrgCop

	PRINTF	DBG_OSCALL,<'CDG--$%lx=MrgCop()'>,D0

		tst.l	d0		; error returned implemented
		bne	CDGInit_FAIL10	; for V37 graphics

	; Get 4 sprites - so we can have left & right (32 bit wide)
	; 15 color sprites - only use 8 colors though

		move.l	cdd_SpriteBase(a4),d0

		lea	cdd_SimpleSprite2(a4),a2
		move.l	a2,a0

		move.l	cdd_CDGPrefs(a4),a1
		move.w	cdgp_SpriteHeight(a1),d2

	PRINTF	DBG_OSCALL,<'CDG--GetSprite($%lx,$%lx)'>,A0,D0

		JSRLIB	GetSprite

		tst.l	d0
		bmi	CDGInit_FAIL12


		move.w	d2,ss_height(a2)
		move.w	#RELSPRITE_X,ss_x(a2)
		move.w	#RELSPRITE_Y,ss_y(a2)

		move.l	cdd_SpriteBase(a4),d0
		addq.b	#1,d0

		lea	cdd_SimpleSprite3(a4),a2
		move.l	a2,a0

	PRINTF	DBG_OSCALL,<'CDG--GetSprite($%lx,$%lx)'>,A0,D0

		JSRLIB	GetSprite
		tst.l	d0
		bmi	CDGInit_FAIL13

		move.w	d2,ss_height(a2)
		move.w	#RELSPRITE_X,ss_x(a2)
		move.w	#RELSPRITE_Y,ss_y(a2)

		move.l	cdd_SpriteBase(a4),d0
		addq.b	#2,d0

		lea	cdd_SimpleSprite4(a4),a2
		move.l	a2,a0

	PRINTF	DBG_OSCALL,<'CDG--GetSprite($%lx,$%lx)'>,A0,D0

		JSRLIB	GetSprite
		tst.l	d0
		bmi	CDGInit_FAIL14

		move.w	d2,ss_height(a2)
		move.w	#(RELSPRITE_X+SPRITE_WIDTH),ss_x(a2)
		move.w	#RELSPRITE_Y,ss_y(a2)

		move.l	cdd_SpriteBase(a4),d0
		addq.b	#3,d0

		lea	cdd_SimpleSprite5(a4),a2
		move.l	a2,a0

	PRINTF	DBG_OSCALL,<'CDG--GetSprite($%lx,$%lx)'>,A0,D0

		JSRLIB	GetSprite
		tst.l	d0
		bmi	CDGInit_FAIL15

		move.w	d2,ss_height(a2)
		move.w	#(RELSPRITE_X+SPRITE_WIDTH),ss_x(a2)
		move.w	#RELSPRITE_Y,ss_y(a2)

	; Set initial colors for ViewPort

		move.l	cdd_CDGPrefs(a4),a0
		lea	cdgp_SpriteColors(a0),a0
		lea	cdd_ColorTable1(a4),a2
		move.l	a2,a1

	; bump pointer to colors by 16 words, so we will copy our 8
	; sprite colors to colors 16-23 inclusive

		add.w	#(16*2),a1

		moveq	#3,d0		;4 long words = 8 words of colors!

CDGInit_SpriteColors:
		move.l	(a0)+,(a1)+
		dbf	d0,CDGInit_SpriteColors

		lea	cdd_ViewPort1(a4),a0
		move.l	a2,a1
		moveq	#32,d0

	PRINTF	DBG_OSCALL,<'CDG--LoadRGB4($%lx,$%lx,$%lx)'>,A0,A1,D0

		JSRLIB	LoadRGB4

		BSRSELF	SniffCopperList

	; Try to obtain ownership of serial misc, but not required.
	; If not obtained, then CD+MIDI just won't work

		move.l	a3,a6		;restore execbase

	; but don't bother if prefs flag says don't bother

		btst	#CDGB_NOMIDI,cdd_ExtraFlags3(a4)
		BNE_S	CDGInit_MidiDisabled

	; First try to remove serial.device which (ACK!!) does not
	; release the MISC/SERIAL bits until expunged!

		FORBID

		lea	DeviceList(a6),a0
		lea	sername(pc),a1

		JSRLIB	FindName
		tst.l	d0
		beq.s	CDGInit_NoSerial

		move.l	d0,a1
		JSRLIB	RemDevice

CDGInit_NoSerial:
		PERMIT

		lea	miscname(pc),a1
		JSRLIB	OpenResource

	PRINTF	DBG_OSCALL,<'CDG--$%lx=OpenResource("misc.resource")'>,D0

		tst.l	d0
		BEQ_S	CDGInit_NoMiscRes	;???

		move.l	d0,a6

		moveq	#MR_SERIALBITS,d0
		lea	cdgname(pc),a1
		JSR	MR_ALLOCMISCRESOURCE(a6)

		tst.l	d0
		BNE_S	CDGInit_NoMiscRes

	PRINTF	DBG_OSCALL,<'CDG--Owned MR_SERIALBITS'>

		moveq	#MR_SERIALPORT,d0
		lea	cdgname(pc),a1
		JSR	MR_ALLOCMISCRESOURCE(a6)

		tst.l	d0
		bne.s	CDGInit_FreeSerBits

	PRINTF	DBG_OSCALL,<'CDG--Owned MR_SERIALPORT'>

	; mark as we own resource bits, and cache resource base for
	; Free when CDGEnd() is called

		move.l	a6,cdd_MiscResource(a4)

	; see midi.asm for the code which inits the serial port for midi out

		BSRSELF	CDGInitMidiOut

		bra.s	CDGInit_NoMiscRes

CDGInit_FreeSerBits:

		moveq	#MR_SERIALBITS,d0
		JSR	MR_FREEMISCRESOURCE(a6)

	PRINTF	DBG_OSCALL,<'CDG--Free MR_SERIALBITS'>

CDGInit_NoMiscRes:

		move.l	a3,a6		;restore A6 - execbase

CDGInit_MidiDisabled:

	; reset border color to color 0

		lea	cdd_CLUTTable(a4),a0
		move.l	a0,cdd_BorderPen(a4)

	; Initialize midi out buffer

		lea	cdd_MidiBytes(a4),a0
		move.l	a0,cdd_PutMidiByte(a4)
		move.l	a0,cdd_GetMidiByte(a4)

		lea	cdd_EndMidiBytes(a4),a0
		move.l	a0,cdd_MaxMidiByte(a4)

	; Initialize PACKET buffer pointers

		lea	cdd_PacketData(a4),a0
		move.l	a0,cdd_PutPacket(a4)
		move.l	a0,cdd_GetPacket(a4)

		lea	cdd_EndPackets(a4),a0
		move.l	a0,cdd_MaxPacket(a4)

	; Initialize BUCKET pointers

		lea	cdd_Buckets(a4),a0
		move.l	a0,cdd_NextBucket(a4)		;prime
		move.l	a0,a2				;cache

	PRINTF	DBG_FLOW,<'CDG--First Bucket @@ $%lx'>,A0

	; Initialize Next pointer; first for speed; circular

		moveq	#6,d1

CDGInit_Buckets:

		lea	CDGBucket_SIZEOF(a0),a1
		move.l	a1,cdt_Next(a0)

	PRINTF	DBG_FLOW,<'CDG--Store $%lx in cdt_Next($%lx)'>,A1,A0

		move.l	a1,a0
		dbf	d1,CDGInit_Buckets

	PRINTF	DBG_FLOW,<'CDG--Store $%lx in cdt_Next($%lx)'>,A2,A0

		move.l	a2,cdt_Next(a0)

	; Initialize active/inactive bitplane pointers

		lea	cdd_BitPlane1_0(a4),a0
		move.l	a0,cdd_ActivePlanes(a4)

		lea	cdd_BitPlane2_0(a4),a0
		move.l	a0,cdd_InactivePlanes(a4)

	; Initialize, and add interrupt servers

		lea	cdd_IntVBlank(a4),a1
		move.l	a4,IS_DATA(a1)
		moveq	#INTB_VERTB,d0

	PRINTF	DBG_OSCALL,<'CDG--AddIntServer($%lx,$%lx)'>,D0,A1

		JSRLIB	AddIntServer

	; Add notification hook in cd.device

		move.l	a4,a1		

		move.w	#CD_ADDFRAMEINT,IO_COMMAND(a1)
		move.l	#IS_SIZE,IO_LENGTH(a1)
		lea	cdd_CDINT(a1),a0
		move.l	a0,IO_DATA(a1)	;link

		lea	CDGPackInt(pc),a0
		move.l	a0,cdd_CDINT+IS_CODE(a1)
		move.l	a1,cdd_CDINT+IS_DATA(a1)

	; cd.device is using Cause() - needs to be documented

		move.b	#NT_INTERRUPT,cdd_CDINT+LN_TYPE(a1)
		move.b	#32,cdd_CDINT+LN_PRI(a1)

	PRINTF	DBG_OSCALL,<'CDG--SendIO($%lx)'>,A1

		JSRLIB	SendIO

	;-- FINALLY DONE!!!  Store pointer to this data!!

		move.l	a4,d0		;return SUCCESS!!
		movem.l	(sp)+,d2-d7/a2-a6

	PRINTF	DBG_EXIT,<'CDG--$%lx=_CDGInit()'>,D0

		rts


CDGInit_FREEDATA:

	; disable subcodes

		move.l	cdd_ExecLib(a4),a6
		moveq	#00,d0
		move.l	#SIGF_SINGLE,d1
		JSRLIB	SetSignal		;clear it

		move.l	a4,a1
		move.w	#CD_REMFRAMEINT,IO_COMMAND(a1)

	PRINTF	DBG_OSCALL,<'CDG--DoIO($%lx)'>,A1

		JSRLIB	DoIO

	; Remove Interrupt servers

		move.l	cdd_ExecLib(a4),a6

		lea	cdd_IntVBlank(a4),a1
		moveq	#INTB_VERTB,d0

	PRINTF	DBG_OSCALL,<'CDG--RemIntServer($%lx,$%lx)'>,D0,A1

		JSRLIB	RemIntServer

	; Free misc.resource bits (for CD+MIDI data)

		move.l	cdd_MiscResource(a4),d0
		beq.s	CDGInit_FAIL16		;owned??

	; see midi.asm for code which restores the serial port

		BSRSELF	CDGFreeMidiOut

		move.l	d0,a6			;yes, free serial port stuff

		moveq	#MR_SERIALBITS,d0
		JSR	MR_FREEMISCRESOURCE(a6)

		moveq	#MR_SERIALPORT,d0
		JSR	MR_FREEMISCRESOURCE(a6)

	PRINTF	DBG_OSCALL,<'CDG--Free MR_SERIALPORT/BITS'>

	; Free Sprite #5

CDGInit_FAIL16:

		move.l	cdd_GfxLib(a4),a6
		move.l	cdd_SpriteBase(a4),d0
		addq.b	#3,d0

	PRINTF	DBG_OSCALL,<'CDG--FreeSprite($%lx)'>,D0

		JSRLIB	FreeSprite

	; Free Sprite #4

CDGInit_FAIL15:

		move.l	cdd_GfxLib(a4),a6
		move.l	cdd_SpriteBase(a4),d0
		addq.b	#2,d0

	PRINTF	DBG_OSCALL,<'CDG--FreeSprite($%lx)'>,D0

		JSRLIB	FreeSprite

	; Free Sprite #3

CDGInit_FAIL14:

		move.l	cdd_GfxLib(a4),a6
		move.l	cdd_SpriteBase(a4),d0
		addq.b	#1,d0

	PRINTF	DBG_OSCALL,<'CDG--FreeSprite($%lx)'>,D0

		JSRLIB	FreeSprite

	; Free Sprite #2

CDGInit_FAIL13:

		move.l	cdd_GfxLib(a4),a6
		move.l	cdd_SpriteBase(a4),d0

	PRINTF	DBG_OSCALL,<'CDG--FreeSprite($%lx)'>,D0

		JSRLIB	FreeSprite


	; Free Copper List

CDGInit_FAIL12:


		move.l	cdd_GfxLib(a4),a6
		lea	cdd_View1(a4),a0
		move.l	v_LOFCprList(a0),a0

	PRINTF	DBG_OSCALL,<'CDG--FreeCprList($%lx)'>,A0

		JSRLIB	FreeCprList

	; Free Intermediate copper List 1

CDGInit_FAIL10:


		move.l	cdd_GfxLib(a4),a6
		lea	cdd_ViewPort1(a4),a0

	PRINTF	DBG_OSCALL,<'CDG--FreeVPortCopLists($%lx)'>,A0

		JSRLIB	FreeVPortCopLists

	; Free ColorMap1

CDGInit_FAIL8:

		move.l	cdd_GfxLib(a4),a6
		lea	cdd_ViewPort1(a4),a2
		move.l	vp_ColorMap(a2),a0

	PRINTF	DBG_OSCALL,<'CDG--FreeColorMap($%lx)'>,A0

		JSRLIB	FreeColorMap

	; ColorMap allocation failure 1

	; Free Sprite Data buffer

CDGInit_FAIL6:
		move.l	cdd_ExecLib(a4),a6
		
		move.l	cdd_4SpriteSize(a4),d0
		move.l	cdd_4SpriteData(a4),a1

	PRINTF	DBG_OSCALL,<'CDG--FreeMem($%lx,$%lx)'>,A1,D0

		JSRLIB	FreeMem

	; Free ExtraRaster1

CDGInit_FAIL5:
		move.l	cdd_GfxLib(a4),a6
		
		move.w	#DISPLAY_WIDTH,d0
		move.w	#DISPLAY_HEIGHT,d1
		move.l	cdd_ExtraRaster1(a4),a0

	PRINTF	DBG_OSCALL,<'CDG--FreeRaster($%lx,$%lx,$%lx)'>,A0,D0,D1

		JSRLIB	FreeRaster

	; Free 2nd set of bitplanes

CDGInit_FAIL4:

		move.l	cdd_GfxLib(a4),a6
		move.l	cdd_BitPlane2_0(a4),a0

		move.l	#DISPLAY_WIDTH,d0
		move.l	#((DISPLAY_DEPTH-1)*DISPLAY_HEIGHT),d1

	PRINTF	DBG_OSCALL,<'CDG--FreeRaster($%lx,$%lx,$%lx)'>,A0,D0,D1

		JSRLIB	FreeRaster

	; Free 1st set bitplanes

CDGInit_FAIL3:

		move.l	cdd_GfxLib(a4),a6
		move.l	cdd_BitPlane1_0(a4),a0

		move.l	#DISPLAY_WIDTH,d0
		move.l	#((DISPLAY_DEPTH-1)*DISPLAY_HEIGHT),d1

	PRINTF	DBG_OSCALL,<'CDG--FreeRaster($%lx,$%lx,$%lx)'>,A0,D0,D1

		JSRLIB	FreeRaster

	; close Gfx library too

CDGInit_FAIL2:
		move.l	cdd_ExecLib(a4),a6
		move.l	cdd_GfxLib(a4),a1


	PRINTF	DBG_OSCALL,<'CDG--CloseLibrary($%lx)'>,A1

		JSRLIB	CloseLibrary

CDGInit_FAILVER:

	; Close cdtv.device

		move.l	cdd_ExecLib(a4),a6
		move.l	a4,a1

	PRINTF	DBG_OSCALL,<'CDG--CloseDevice($%lx)'>,A1

		JSRLIB	CloseDevice

	; release structure memory

CDGInit_FAIL1:
		move.l	cdd_ExecLib(a4),a6
		move.l	a4,a1
		move.l	#CDGData_SIZEOF,d0

	PRINTF	DBG_OSCALL,<'CDG--FreeMem($%lx,$%lx)'>,A1,D0

		JSRLIB	FreeMem

	; couldn't even allocate memory for structure

CDGInit_FAIL0:
		moveq	#00,d0
		movem.l	(sp)+,d2-d7/a2-a6

	PRINTF	DBG_EXIT,<'CDG--$%lx=_CDGInit()'>,D0

		rts


		CNOP	0,4

	; InitStruct() initialization table

initdata:
		INITLONG	cdd_IntVBlank+LN_NAME,cdgname
		INITLONG	cdd_IntVBlank+IS_CODE,CDGVertInt
		INITBYTE	cdd_IntVBlank+LN_TYPE,NT_INTERRUPT
		INITBYTE	cdd_IntVBlank+LN_PRI,1
		INITWORD	cdd_MinDisplayX,0
		INITLONG	cdd_SpriteBase,2
		INITBYTE	cdd_ActiveChannel,1		
		INITBYTE	cdd_VBlankFlags,VBFF_BACKSCREEN
		INITBYTE	cdd_GPackCount,GPACKCOUNT
		INITBYTE	cdd_MPackCount,MPACKCOUNT

		dc.w		0

gfxname:		
		GRAPHICSNAME

miscname:
		MISCNAME

sername:
		SERIALNAME

	; GACK!! no assembly include file!

cddevname:
		dc.b	'cd.device',0


******* cdg.library/--background-- ************************************
*
*   CD+G
*
*	CD+G is a standard format for encoding graphics data on
*	audio CD's.  This data is stored with the audio data such
*	that the graphics data retrieved is synchronized with the
*	audio.
*
*	CD+G currently defines a limited set of graphics operations
*	including --
*
*	o Setting border color (0..15)
*
*	o Drawing a 6 bit wide, by 12 bit high graphic image
*	  at a specific ROW/COLUMN position.  The graphic image
*	  is drawn in 2 colors.  The pen colors to use are encoded
*	  in the graphic data.
*
*	  A 6x12 pixel element is known as a FONT.
*
*	o Exclusive-OR a 6x12 bit graphic image with another.
*	  EOR makes it possible to draw a graphic image, and
*	  color it in more than 2 colors by EORing the previous
*	  bit-pattern with a new one using 2 new pen colors.
*
*	o Clear the entire display with a color (0..15).
*
*	o Change the color table (0..15).  Separate CD+G instructions
*	  are used to load pen colors 0-7, and 8-15.
*
*	o Scroll screen left/right, up/down.  The vacated portion
*	  is filled in with a pen color (0..15).  Smooth scrolling
*	  is possible.
*
*	o Scroll screen left/right, up/down.  The vacated portion
*	  is filled in with the data which is scrolled off screen.
*
*	There are currently two kinds of graphics --
*
*	o Line Graphics - the display is a VISIBLE 2 rows, by
*	  48 columns.  Each FONT element in the display is 6 pixels
*	  wide by 12 pixels high.  This mode is currently NOT
*	  supported.
*
*	o TV Graphics - the display is a VISIBLE 16 rows, by
*	  48 columns.  Each FONT element in the display is 6 pixels
*	  wide by 12 pixels high.  This mode IS supported by
*	  cdg.library.
*
*   CHANNELS -
*
*	Two of the CD+G drawing instructions can be divided into
*	channel numbers.  These are the WRITE FONT intruction
*	which draws a 2 color 6x12 image on the screen, and the EOR
*	FONT instruction which uses EOR logic to draw over an existing
*	font.
*
*	The primary channel number is 0, and would typically be used
*	to draw a picture.  Infact, some CD+G disks will only use
*	channel 0.
*
*	In addition to channel 0, there are 15 other channels which
*	can be used for additional graphics imagery, such as the
*	text for more than one language.
*
*	By default the cdg.library uses channels 0, and 1 for
*	graphic data.  The cdg.library also provides a function
*	so that channels 2-15 can be used instead of channel
*	1.  Therefore, two channels are always active.
*
*	While the CD+G specification recommends that there be
*	a mechanism for selectively turning on/off all 16 channels,
*	it is also not entirely clear if, or how the data should
*	be mixed on screen.
*
*	Because there are already variations in CD+G implementations
*	regarding channel selection, and usage, the scheme provided
*	for in cdg.library is probably the least complicated for the
*	user.  It is however admittedly not completely within the
*	ideal specification.
*
*   PACKS & PACKETS
*
*	CD+G data is stored in something called a PACKET.  There
*	are up to 4 TV GRAPHIC'S PACKS per PACKET.  Each PACK
*	in a PACKET can be a separate graphics instruction from
*	those listed above.
*
*	Because a new PACKET is available 75x/second, CD+G requires
*	most of the available CPU time on a 68000 based system to
*	keep up with the data.
*
*   ERROR CORRECTION
*
*	Because of the nature of CD's, data can be munged.  Because
*	audio data must be played in real-time, it is not possible
*	to retry a bad block of data.  The CD standard includes
*	an ERROR CORRECTION method which helps to minimize data loss.
*
*	As of V39 of the cdg.library, Reed-Solomon error
*	correction has been implemented in software.  While the current
*	software implementation is quite efficient, a mechanism
*	has been provided for disabling error correction.
*
*	In the case of a 68000 Amiga-CD unit running a 7Mhz 68000,
*	ERROR DETECTION requires approximately 550-600us per PACK.
*	Correction of ONE error requires an additional 350-400us
*	per PACK.  Correction of TWO errors requires an additional
*	800-1000us per PACK.  Correction of more than two errors
*	per PACK is not possible, and PACKS with more than two
*	errors are discarded.
*
*	If error correction has been disabled, all PACKS are processed
*	as is.  However because the typical case is no errors, the
*	additional 2 milliseconds per PACKET (4 PACKS) still makes it
*	possible to leave approximately 50% of the available CPU time
*	free when CD+G is running with error correction enabled.
*
*	***NOTE***
*
*		The CD+G/+MIDI module was originally designed for
*		use on a 68000 based system.  Therefore timing
*		is obviously improved on a 68020-68040 based system.
*
*	In addition to the Reed-Solomon error correction, PACK
*	data is 8x interleaved on disk.  Therefore even if 16
*	bytes of contiguous data are munged by a scratch, or
*	other imperfection, it is likely that all 16 bytes can
*	be corrected.
*
*	It is possible that in the future error correction may be
*	implemented in hardware, in which case error correction might
*	always be enabled.
*
*	Even with error correction enabled, it is possible to have more
*	than two errors per PACK, or to have so many errors that the
*	error detection code cannot calculate the actual number of
*	errors.
*
*   cdg.library (V39)
*
*	The cdg.library provides a set of functions for use with   
*	Commodore Amiga CD systems.  These functions are meant to be
*	used by the Player Preferences module which lets the user
*	select audio tracks to play.  Note that these functions
*	were not available in the initial cdg.library, and the V39
*	functions are not compatable with the earlier version of
*	the CDTV cdg.library.  It is also possible to write a custom
*	player program which makes use of cdg.library to play CD+G, and
*	CD+MIDI disks.
*
*	***NOTE***
*
*		The cdg.library was primarily designed for use with
*		the audio disk player module, so does not use Intuition
*		screens.  Infact the player module installs an input
*		handler to lock-out Intuition.  Use of the cdg.library
*		in an Intuition environment requires similar locking
*		and use of cdg.library functions to manage screen
*		ordering.  The primary reason for writing your own
*		+G/+MIDI player would be for a Kaoroke player, or
*		other multi-media environments in which the Intuition
*		model does not apply well.
*
*	The caller of cdg.library functions is responsible for managing
*	user input, and CD activity, including selecting tracks to
*	play, starting play, stopping play, etc.  These kinds of
*	disk control functions are provided by the cd.device.
*
*	In the typical case, the following steps are recommended -
*
*	1.) Initialize a CDGPrefs structure.  This structure
*	must be entirely filled in, and contains many pointers to
*	sprite data which must be initialized.  CDGAllocPrefs()
*	should be used to allocate the CDGPrefs structure.  Likewise
*	use CDGFreePrefs() to free the structure.
*
*	The sprites are used to display activity information to the
*	user when the CD+G display is active.  An example would be
*	a change in channel selection.  A new channel number is
*	automatically displayed for a few moments for the user's
*	benefit.  Sprites are also used to display disk activity
*	such as PAUSE mode.
*	
*	Each image is composed of 4 sprites.  Two sprites are
*	used for the left side of the symbol, and two for the
*	right.  The image can use 8 colors because attached
*	sprites are used.  Each symbol requires pointers to
*	FOUR sprites arranged in this order -
*
*		1st ptr -> Left side sprite
*		2nd ptr -> Left side, attached sprite
*		3rd ptr -> Right side sprite
*		4th ptr -> Right side, attached sprite
*
*	The ordering arrangement is designed to be convienent
*	for the cdg.library, and provides enough colors to make
*	attractive images.  Because sprites are used, the total width
*	of each image is always 32 bits wide, and the height is
*	variable.  It is highly recommended that the images not be
*	more than 32 bits high to insure they fit on the screen, and
*	avoid excessive memory usage.
*
*	Sprite data should be in CHIP RAM, and be stored in the
*	simple sprite format including space for the posctrl words, and
*	NULL terminating words.  The height of all sprites must be
*	the same.
*
*	The CDGPrefs structure includes other fields defined in the
*	cdgprefs.i/h file such as display position, and an array of
*	8 colors to be used for the sprites.
*
*	2.) Call CDGBegin() with the CDGPrefs() structure as an argument.
*	This function starts the cdg.library.  The call may fail due to
*	lack of memory, or inability to open a needed system resource.
*	Of interest, the cdg.library will only process MIDI packets IF
*	the serial port, and control bits have not been allocated by
*	some other task (e.g., the serial.device).
*
*	Once started, the cdg.library starts collecting PACKETS as
*	available.  The PACKETS are buffered, but because of the
*	rate and size of the PACKETS assume no more than 1 seconds
*	worth of PACKET data will be buffered before it is overwritten
*	by more recent PACKETS.
*
*	3.) Call CDGPlay(), and start the CD playing.  Once the CD starts
*	playing, assume the cdg.library is receiving CD+G PACKETS.  At this
*	point your code should call CDGDraw() as often as possible.  During
*	every call, CDGDraw() will process any pending PACKS.
*
*	CDGDraw() also returns a value indicating if ANY CD+G, or CD+MIDI
*	PACKS have been processed.  This is meant to be used as an indicator
*	that the CD+G screen should be brought to front, or perhaps a gadget
*	would be displayed indicating that CD+G is available.  The user will
*	probably prefer the CD+G screen automatically coming to front, or they
*	will miss the initial portion of the animation.
*
*	To bring the CD+G screen to front, use the CDGFront() call.
*	It is recommended that you first call CDGDraw() so that
*	any pending PACKS will be processed before the screen is
*	made visible.
*
*	4.) The player program is now responsible for switching to
*	CD+G mode by efficiently checking for user input, and regularly
*	calling the CDGDraw() function.  The loop should be coded
*	to provide maximum CPU time for CDGDraw().  A mechanism is
*	provided so that Wait() can be used to sleep between calls.
*
*	5.) If the user presses a key, or button indicating they want 
*	to bring the Player program to front, you must use the CDGBack()
*	function to tell CD+G to turn off any sprites it has on screen, and
*	notify it not to bring its own screen to front again until CDGFront()
*	is called.
*
*	6.) The cdg.library provides a number of functions for
*	telling it what the CD is doing, as well the ability to
*	change the active channels 1-15.  These functions are also
*	used to provide some visual indication to the user that their input
*	has been noticed, and what is happening.  In addition to the channel
*	selection, there are sprite images in CDGPrefs for the following
*	modes --
*
*		PLAY	- Image is displayed for a few moments.
*			  Indicates the disk has started PLAY.
*			  Should be displayed whenever the disk
*			  starts playing, including after PAUSE,
*			  STOP, FF, and REW.
*
*		PAUSE	- Image is displayed indefinitely.
*
*		STOP	- Image is displayed indefinitely.
*
*		FF	- Image is displayed indefinitely.
*
*		REW	- Image is displayed indefinitely.
*
*		NEXT TRACK - Image is displayed for a few moments.
*			     PLAY is implied.
*
*		PREV TRACK - Image is displayed for a few moments.
*			     PLAY is implied.
*
*		CHANNEL    - Image is displayed for a few moments.
*
*	See AutoDocs for the functions used to display these images.
*
*	7.) If the CD is removed, the CDGDiskRemoved() function should
*	be called.
*
*	8.) To close down the cdg.library, use the CDGEnd() function
*	to free all memory, and resources allocated by CDGBegin().
*
*	Note that while your own screen is displayed, it is not
*	necessary to call CDGDraw() once per PACKET, but it should
*	still be called as often as possible of data may be lost.
*	Assume no more than 1/2-3/4 seconds of PACKET data will be
*	buffered before it is overwritten by new data.
*
*	Note that sprite images can be replaced by a more recent
*	sprite image if the image has not already been removed
*	from the display.  For example, if the user is changing
*	channel numbers, you can call CDGChannel() at any time,
*	and the most recent channel will be displayed.
*
*	If you call CDGBack() while a sprite image is being
*	displayed, the sprite image is turned off at the next
*	VBLANK.  The last sprite image is NOT automatically restored
*	when you call CDGFront() again.  Therefore if the disk
*	is still in PAUSE mode, you will probably want to call
*	CDGPause() again after bring the CD+G screen to front.
*
*    SPECIAL CONSIDERATIONS
*
*	During FF and REW, CD+G data is missed.  Because data is
*	missed, the CD+G display is cleared during these operations,
*	and the display may not be properly updated.  For example, if
*	the color tables were supposed to have been changed during the
*	section of the CD which is skipped in FF/REW modes, the colors
*	will be wrong when the disk starts to PLAY again.  Fortunately
*	many CD+G titles refresh the colors regularly, but not all.  Some
*	titles draw static images may not be updated for long sections of
*	play.
*
*	Because there is no work around for this problem, you can
*	either disable FF/REW during CD+G, or allow the problem.
*	Ideally CD+G instructions will contain enough repetative
*	information that this will not be a significant problem.
*
*	Another special problem is that some PACKS are missed when the
*	CD is taken out of PAUSE mode, and placed in PLAY mode.  There is
*	no good work around for this problem, and it is generally not
*	too annoying.
*
*    MIDI DATA
*
*	CD's can also contain MIDI data.  The cdg.library optionally
*	handles MIDI PACKETS during CDGDraw(), and sends this data
*	at MIDI Baud rates out the serial port.  It is therefore important
*	to call CDGDraw() often enough to avoid long delays between
*	MIDI PACK handling.
*
*	MIDI PACKS can contain 0-12 bytes per PACK.  Therefore it is
*	possible to exceed the maximum transmission rate allowed by
*	MIDI.  In actual use though designers of +MIDI disks are warned
*	about this, and will typically send much less data than the
*	maximum possible.  MIDI PACK data is stored in a serial output queue,
*	and transmitted via TBE interrupts.  It is therefore possible to
*	interleave +G, and +MIDI data such that new graphics are being drawn
*	at the same time +MIDI data is being transmitted.
*
*	CDGStop(), CDGPause(), CDGFastForward(), CDGRewind(),
*	CDGNextTrack(), CDGPrevTrack(), and CDGDiskRemoved() will
*	send a sequence of bytes to tell all midi channels to be
*	quiet if any +MIDI data has been sent since the sequence
*	was last sent.  This is done to avoid 'stuck' notes.
*
*    SYNCHRONIZATION
*
*	One of problems with CD+MIDI is synchronization of audio, and
*	+MIDI data.  Depending on the subcode hardware implementation,
*	software may receive subcodes a byte at a time, or a FRAME
*	at a time.  Assuming the later, there is still the problem of
*	synchronizing +MIDI data from a FRAME which has already	passed
*	with audio which is currently being played.  When you add in
*	software/hardware overhead/delays, only approximate
*	synchronization can be expected.
*
*	In actual use synchronization is not a significant problem;
*	our audio perception is limited.  However if you fail to call
*	CDGDraw() at regular intervals, the cdg.library may buffer
*	the data, but audio synchronization could be audibly affected.
*
*	The same problem is of course true for +G (though less
*	significant).  There is another problem with +G though.  There
*	is no synchronization between VBLANK rate, and scrolling effects
*	in +G disks.  So a +G scroll command may look smooth on one
*	system, but "jerk" slightly on another.  New PACKETS are
*	received 75x per second, while VBLANK rate may be 60x or 50x
*	per second.
*
*	The cdg.library batches up color changes, and scroll commands for
*	the next complete video frame (around VBLANK time).  This is done to
*	so that each video frame has a stable/solid look, but means that a
*	scroll command or color change command may have to wait as much
*	as one complete video frame before being displayed.  For color
*	changes this is not visually noticeable, but for smooth scrolling
*	effects lack of synchronization can be seen.
*
***********************************************************************


		END@


1.27
log
@Not really needed, but wait for reply when removing frame call
interrupt.
(safe)
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.26 93/02/03 16:17:25 darren Exp Locker: darren $
a174 1

a356 1

a396 1

d606 6
d1203 1
a1203 1
		INITWORD	cdd_MinDisplayX,-16
@


1.26
log
@Fix bug - set V_SPRITE flag in viewport
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.25 93/02/03 11:45:46 darren Exp Locker: darren $
d235 1
a235 5
	; Open cd.device, but dig this - no reply port is needed,
	; hence this is a breeze to setup - we are only going to
	; use one cdtv.device command, and that one requires SendIO()
	; because it does not return until AbortIO(), and we could
	; careless about getting back a reply
d237 13
d966 4
a970 1

d973 1
a973 1
	PRINTF	DBG_OSCALL,<'CDG--SendIO($%lx)'>,A1
d975 1
a975 1
		JSRLIB	SendIO
d991 1
a991 1
		BEQ_S	CDGInit_FAIL16		;owned??
@


1.25
log
@First pass at mods for AA CD Game system
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.24 92/04/22 10:43:48 darren Exp Locker: darren $
d18 1
a18 1
		INCLUDE	"cdgs:src/cd/internal.i"
d584 1
@


1.24
log
@Document mods
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.23 92/04/15 08:40:07 darren Exp Locker: darren $
d16 3
a18 1
		INCLUDE	"cdtv_cr_hw.i"
a109 1
	;GACK!!! NO "cdtv.i" file!!!  Oh well, only need this one define
a110 2
CDTV_FRAMECALL	EQU	40

d235 1
a235 1
	; Open cdtv.device, but dig this - no reply port is needed,
d241 1
a241 1
		lea	cdtvdevname(pc),a0
d253 5
d919 1
a919 1
	; Add notification hook in cdtv.device
d923 5
a927 1
		move.w	#CDTV_FRAMECALL,IO_COMMAND(a1)
d929 4
a932 2
		move.l	a0,IO_DATA(a1)
		moveq	#00,d0
d934 2
a935 3
		move.l	d0,IO_LENGTH(a1)
		move.l	d0,IO_OFFSET(a1)
		JSRLIB	SendIO
d937 1
a937 1
	; enable subcodes
d939 1
a939 1
		move.b	#1,(CDTVHARDWARE+CDSK_SUBCODEDATA)
a954 2
		move.b	#0,(CDTVHARDWARE+CDSK_SUBCODEDATA)

d958 1
a958 1
	PRINTF	DBG_OSCALL,<'CDG--AbortIO($%lx)'>,A1
d960 1
a960 1
		JSRLIB	AbortIO
d962 2
d1207 2
a1208 2
cdtvdevname:
		dc.b	'cdtv.device',0
d1311 1
a1311 1
*	As of V38 of the cdg.library, Reed-Solomon error
d1316 1
a1316 1
*	In the case of a stock CDTV-CR unit running a 7Mhz 68000,
d1330 6
d1351 1
a1351 1
*   cdg.library (V38)
d1354 1
a1354 1
*	the Commodore CDTV player.  These functions are meant to be
d1357 1
a1357 1
*	were not available in the initial cdg.library, and the V38
d1359 2
a1360 2
*	the library.  It is also possible to write a custom player
*	program which makes use of cdg.library to play CD+G, and
d1363 13
d1379 1
a1379 1
*	disk control functions are provided by the cdtv.device.
d1567 32
@


1.23
log
@Support arbitrary X positioning of CD+G screen
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.22 92/04/13 14:20:58 darren Exp Locker: darren $
d1357 3
a1359 1
*	sprite data which must be initialized.
d1404 2
a1405 2
*	available.  The PACKETS are buffered (though because of the
*	rate and size of the PACKETS), assume no more than 1 seconds
d1427 4
a1430 6
*	CD+G mode by efficiently checking for user input, and busy
*	looping on the CDGDraw() function.  The loop should be coded
*	to provide maximum CPU time for CDGDraw().  A mechanism is also
*	provided so that Wait() can be used to sleep between calls,
*	however be aware that your task will be signaled 75x per second
*	while the disk is playing.
d1473 2
a1474 3
*	8.) To close down the cdg.library, call CDGStop(), and
*	    use the CDGEnd() function to free all memory, and resources
*	    allocated by CDGBegin().
d1477 4
a1480 5
*	necessary to call CDGDraw() on a timely basis, however it
*	is important to call it often (e.g., once every 1/2-3/4
*	seconds) so that CD+G data is not lost.  The longer
*	you wait between calls, the longer it may take to process
*	pending PACKs.
d1490 4
a1493 1
*	VBLANK.
d1499 7
a1505 5
*	and it can take a while for the display to be properly
*	updated.  For example, if the color tables were supposed to
*	have been changed during the section of the CD which is
*	skipped in FF/REW modes, the colors will be wrong when the
*	disk starts to PLAY again.
d1510 1
a1510 3
*	information that this won't be a significant problem.  If
*	for example the CD+G data reloads the color tables often,
*	and redraws the screen often enough, the problem is tolerable.
d1529 4
a1532 4
*	maximum allowed/possible.  MIDI PACK data is stored in a serial
*	output queue, and transmitted via TBE interrupts.  It is therefore
*	possible to interleave +G, and +MIDI data such that new graphics
*	are being drawn at the same time +MIDI data is being transmitted.
@


1.22
log
@Kludge for pal mode - center.  Also bound X position for smooth
(simple) scrolling
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.21 92/04/02 18:46:49 darren Exp $
a600 3
		and.b	#$F0,d0		;round (for smooth scroll,
					;and simplicity)

d603 1
a603 1
	; same idea for Y, but there is sprite limitation - there is
@


1.21
log
@Initialize +G/+MIDI counters
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.20 92/04/02 17:06:12 darren Exp Locker: darren $
d112 6
d119 3
d600 4
d616 9
a624 1
		add.w	#CENTER_Y,d0		;and center screen
@


1.20
log
@Change CD_ -> CDSK_
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.19 92/03/11 13:06:24 darren Exp Locker: darren $
d1164 3
@


1.19
log
@Modify some comments
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.18 92/03/09 09:07:20 darren Exp Locker: darren $
d912 1
a912 1
		move.b	#1,(CDTVHARDWARE+CD_SUBCODEDATA)
d928 1
a928 1
		move.b	#0,(CDTVHARDWARE+CD_SUBCODEDATA)
@


1.18
log
@Initialize border pen pointer
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.17 92/03/06 09:53:42 darren Exp Locker: darren $
d222 2
a223 2
	; obtain VBLANK rate from exec, which is calced by timer.device
	; (may be other than 60/50 if genlocked)
d235 2
a236 2
		move.l	a4,a1
		moveq	#00,d1
d332 1
a332 1
		addq.w	#APTR_SIZE,d1
d483 1
a483 1
		add.w	#2,d0			;plus 1 line terminator, and 1 posctrl
d722 1
a722 1
	; Set initial colors for both ViewPorts
@


1.17
log
@Turn off debugging
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.16 92/03/06 09:26:46 darren Exp Locker: darren $
d829 5
@


1.16
log
@Updates position via VIEW to be consistent with CDTV behavior.  Dropped
idea of using sprite 0 for now.
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.15 92/03/05 20:03:50 darren Exp Locker: darren $
d18 1
a18 1
DEBUG_DETAIL	SET	DBG_ALL
@


1.15
log
@Reverse meaning of ALTSPRITE bit, and never check return from
GetSprite(sp,0); also never FreeSprite(0) so we can steal away
the sprite from Intuition
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.14 92/03/05 15:48:45 darren Exp Locker: darren $
d18 1
a18 1

a220 13
	; set sprite base to use sprites 2-5?

		btst	#EF3B_ALTSPRITES,cdd_ExtraFlags3(a4)
		bne.s	CDGInit_UseSprites

	; if so, also place limits on left edge of screen so we don't
	; lose sprites due to DMA bandwidth limitations

	PRINTF	DBG_FLOW,<'CDG--Spites 0-3 requested'>

		clr.l	cdd_SpriteBase(a4)

		move.w	#-32,cdd_MinDisplayX(a4)
a221 2
CDGInit_UseSprites:

d576 2
d591 1
a591 1
		move.w	d0,vp_DxOffset(a2)
d609 1
a609 1
		move.w	d0,vp_DyOffset(a2)
a654 1
		move.l	d0,d3
a664 5
	; do like Intuition - never bother trying to see if GetSprite(blah,0)
	; works

		tst.b	d3
		beq.s	CDGInit_NoCareSprite
a668 1
CDGInit_NoCareSprite:
a1003 1
		beq.s	CDGInit_FAIL12		;never FREE sprite 0
@


1.14
log
@Added code for screen centering, positioning, disable of +MIDI, selection
of sprites to use.
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.13 92/03/04 19:18:56 darren Exp Locker: darren $
d224 1
a224 1
		beq.s	CDGInit_UseSprites
d229 1
a229 1
	PRINTF	DBG_FLOW,<'CDG--Spites 2-5 requested'>
d231 1
a231 1
		addq.l	#02,cdd_SpriteBase(a4)
d233 1
a233 1
		move.w	#-16,cdd_MinDisplayX(a4)
d668 2
d679 6
d688 2
d1024 1
a1024 1
		addq.b	#3,d0
d1176 2
a1177 1
		INITWORD	cdd_MinDisplayX,-32
@


1.13
log
@Fix a sentence
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.12 92/03/04 19:13:18 darren Exp Locker: darren $
d91 15
d214 23
d587 37
d667 1
a667 1
		moveq	#2,d0
d684 3
a686 1
		moveq	#3,d0
d700 3
a702 1
		moveq	#4,d0
d716 3
a718 1
		moveq	#5,d0
d765 5
d838 2
d977 2
a978 1
		moveq	#5,d0
d989 2
a990 1
		moveq	#4,d0
d1001 2
a1002 1
		moveq	#3,d0
d1013 2
a1014 1
		moveq	#2,d0
d1166 1
@


1.12
log
@new/modified background notes
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.11 92/02/24 12:15:46 darren Exp Locker: darren $
d1402 4
a1405 4
*	Another special problem is you should expect that a few PACKS
*	will be missed when the disk is taken out of PAUSE mode, and
*	PLAY has been started again.  There is no good work around for
*	this problem, and it is generally not too annoying.
@


1.11
log
@Comments added
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.10 92/02/24 11:54:33 darren Exp Locker: darren $
d1191 1
a1191 1
*	an error CORRECTION method which helps to minimize data loss.
d1193 33
a1225 13
*	Error correction may, or may not be implemented in the
*	cdg.library.  Error correction requires a considerable
*	amount of CPU time, or error correcting hardware if
*	available.  Even with error correction it is not always
*	possible to correct the data.
*
*	The result of NON-CORRECTED data which is in error may be
*	a display glitch.
*
*	The result of NON-CORRECTABLE data which is in error is
*	missed graphics data, also resulting in a display glitch.
*	While better than no error correction, there is still the
*	possibility of an imperfect display.
d1235 3
a1237 1
*	the library.
d1241 2
a1242 1
*	play, starting play, stopping play, etc.
d1318 4
a1321 1
*	to provide maximum CPU time for CDGDraw().
d1364 3
a1366 1
*	8.) To close down the cdg.library, use the CDGEnd() function.
d1371 1
a1371 1
*	seconds) so that CD+G/+MIDI data is not lost.  The longer
d1402 5
d1410 13
a1422 6
*	handle MIDI PACKETS during CDGDraw(), and sends this data
*	at MIDI Baud rates out the serial port.  However because
*	of variations in MIDI implementations, the cdg.library
*	code may not work with all MIDI devices.  Incompatability
*	reports will be considered if a cdg.library upgrade is
*	implemented in the future.
@


1.10
log
@Add code to expunge serial.device (well, try to anyway) beforw
we try to obtain the MISC bits for serial.  This is because of
a bug in serial.device in that it does not release the resource
bits until it is expunged.  This code is here for the case of
starting up the cdg.library after DOS has been started.
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.9 92/02/21 15:35:02 darren Exp Locker: darren $
d1383 6
@


1.9
log
@New, and better idea of how to make use of TBE interrupts efficiently.
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.8 92/02/21 10:35:25 darren Exp Locker: darren $
d19 1
d35 3
d684 18
d1084 3
d1091 1
@


1.8
log
@Remove code which initializes the midi out buffer.  Also changed
name of subroutine calls which initialize/restore midi output
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.7 92/02/19 17:00:38 darren Exp Locker: darren $
d729 9
@


1.7
log
@No change

@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.6 92/02/19 16:58:04 darren Exp Locker: darren $
d30 2
a31 2
		XREF	CDGAddMidiInt		;midi.asm
		XREF	CDGRemMidiInt
d713 1
a713 1
	; see midi.asm for the code which adds the level 1 mport for serial out
d715 1
a715 1
		BSRSELF	CDGAddMidiInt
a729 9
	; Initialize MIDI output buffer

		lea	cdd_MidiByteData(a4),a0
		move.l	a0,cdd_PutMidiByte(a4)
		move.l	a0,cdd_GetMidiByte(a4)

		lea	cdd_EndMidiBytes(a4),a0
		move.l	a0,cdd_MaxMidiByte(a4)

d839 1
a839 1
	; see midi.asm for code which removes midi/serial out mport
d841 1
a841 1
		BSRSELF	CDGRemMidiInt
@


1.6
log
@Code to initialize midi out buffer, and add/remove serial TBE
interrupt calls.
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.5 92/02/17 15:42:59 darren Exp Locker: darren $
@


1.5
log
@doc changes
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.4 92/02/14 17:56:54 darren Exp Locker: darren $
d30 3
d712 5
d730 9
d846 3
a848 1
		BEQ_S	CDGInit_FAIL12		;owned??
d850 2
d863 2
@


1.4
log
@Change cdtv_CR.. to cdtv_cr
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.3 92/02/14 12:03:36 darren Exp Locker: darren $
d1256 1
a1256 1
*	change the active channels 1-15.  These are functions are also
d1266 1
a1266 1
*			  STOP, FF, REW, NEXT TRACK, PREVIOUS TRACK.
d1294 3
a1296 1
*	seconds) so that CD+G/+MIDI data is not lost.
@


1.3
log
@Initialize cdd_VBlankFlags so VBFB_BACKSCREEN bit is initially set.
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.2 92/01/30 16:04:23 darren Exp Locker: darren $
d16 1
a16 1
		INCLUDE	"cdtv:include/internal/cdtv_CR_hw.i"
@


1.2
log
@Initial check-in of ALPHA cdg.library for CDTV-CR
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.1 92/01/13 11:01:43 darren Exp Locker: darren $
d1030 1
a1030 1

@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
**	$Id: init.asm,v 1.1 92/1/2 08:00:00 darren Exp $
d16 1
d30 54
d85 6
d93 1
a93 1
*****i* cdg/_CDGFree **************************************************
d118 1
a118 1
		movem.l	d2-d3/a2-a6,-(sp)
d126 1
a126 1
*****i* cdg/_CDGInit **************************************************
d150 1
a150 1
		movem.l	d2-d3/a2-a6,-(sp)
d197 18
d220 2
d225 1
a225 1
		beq	CDGInit_FAIL1
d232 2
a233 1
	; Initialize graphics structures (bitmaps first)
d235 23
a257 1
		exg	a3,a6			;use gfxbase, cache exec
d259 1
d270 1
a270 10
		lea	cdd_BitMap2(a4),a0
		moveq	#DISPLAY_DEPTH,d0
		move.w	#DISPLAY_WIDTH,d1
		move.w	#DISPLAY_HEIGHT,d2

	PRINTF	DBG_OSCALL,<'CDG--InitBitMap($%lx,$%lx,$%lx,$%lx)'>,A0,D0,D1,D2

		JSRLIB	InitBitMap

	; Allocate DISPLAY_DEPTH-1 bitplanes for BitMap1
a292 1
		moveq	#00,d1
d294 1
d300 2
a301 1
		move.l	d0,0(a0,d1.w)
a319 4
		lea	cdd_BitMap2(a4),a2
		lea	cdd_RasInfo2(a4),a0
		move.l	a2,ri_BitMap(a0)

d337 1
a337 2
		moveq	#00,d1
		lea	bm_Planes(a2),a0
d343 1
a343 2
		move.l	d0,0(a0,d1.w)
		addq.w	#APTR_SIZE,d1
d414 1
a414 1
		BEQ_S	CDGInit_FAIL4
d417 2
a426 5
		lea	cdd_BitMap2(a4),a0
		lea	bm_Planes(a0),a0
		move.l	12(a0),16(a0)		;move bitplane 3->4
		move.l	d0,12(a0)		;store extra plane as plane 3

d438 3
a440 2
		move.l	#((DISPLAY_HEIGHT<<18)!(DISPLAY_WIDTH/8)),d0
		move.l	#(($FFFF<<16)!(1<<1)!(1<<2)),d1
d446 2
a447 1
	; allocate extra memory for 4 sprites
d455 5
d471 1
a471 1
		BEQ_S	CDGInit_FAIL5
d487 20
a519 2
		move.l	a2,cdd_ActiveView(a4)

d535 3
d539 2
a540 2
		move.w	#DISPLAY_WIDTH,vp_DWidth(a2)
		move.w	#DISPLAY_HEIGHT,vp_DHeight(a2)
a556 40
	; initialize VIEW/VIEWPORT 2

		lea	cdd_View2(a4),a2
		move.l	a2,a1

	PRINTF	DBG_OSCALL,<'CDG--InitView($%lx)'>,A1

		JSRLIB	InitView

		lea	cdd_ViewPort2(a4),a0
		move.l	a0,v_ViewPort(a2)
		move.l	a0,a2

	PRINTF	DBG_OSCALL,<'CDG--InitVPort($%lx)'>,A0

		JSRLIB	InitVPort

		; Initialization of ViewPort

		lea	cdd_RasInfo2(a4),a0
		move.l	a0,vp_RasInfo(a2)
		move.w	#DISPLAY_WIDTH,vp_DWidth(a2)
		move.w	#DISPLAY_HEIGHT,vp_DHeight(a2)


		; final step is to obtain a color map

		moveq	#(1<<DISPLAY_DEPTH),d0

	PRINTF	DBG_OSCALL,<'CDG--GetColorMap($%lx)'>,D0

		JSRLIB	GetColorMap

	PRINTF	DBG_OSCALL,<'CDG--$%lx=GetColorMap()'>,D0

		tst.l	d0
		beq	CDGInit_FAIL7

		move.l	d0,vp_ColorMap(a2)

a568 10
		lea	cdd_View2(a4),a0
		lea	cdd_ViewPort2(a4),a1

	PRINTF	DBG_OSCALL,<'CDG--MakeVPort($%lx,$%lx)'>,A0,A1

		JSRLIB	MakeVPort

	;;;	TST.L	D0		-- not implemented for V37
	;;;	BNE.s	CDGInit_FAIL9	-- usable in V39???

d580 1
a580 7
		BNE_S	CDGInit_FAIL10	; for V37 graphics

		lea	cdd_View2(a4),a1

	PRINTF	DBG_OSCALL,<'CDG--MrgCop($%lx)'>,A1

		JSRLIB	MrgCop
a581 5
	PRINTF	DBG_OSCALL,<'CDG--$%lx=MrgCop()'>,D0

		tst.l	d0		; error return implemented
		BNE_S	CDGInit_FAIL11	; for V37 graphics

d596 1
a596 1
		BMI_S	CDGInit_FAIL12
d599 2
a600 2
		move.w	#260,ss_x(a2)
		move.w	#160,ss_y(a2)
d610 1
a610 1
		BMI_S	CDGInit_FAIL13
d613 2
a614 2
		move.w	#260,ss_x(a2)
		move.w	#160,ss_y(a2)
d624 1
a624 1
		BMI_S	CDGInit_FAIL14
d627 2
a628 2
		move.w	#276,ss_x(a2)
		move.w	#160,ss_y(a2)
d638 1
a638 1
		BMI_S	CDGInit_FAIL15
d641 2
a642 2
		move.w	#276,ss_x(a2)
		move.w	#160,ss_y(a2)
a650 6
	; debug - set color 8 to something visible

	IFNE	SHOWSCREEN
		move.w	#$0484,(8*2)(a1)
	ENDC

d670 1
a670 9
		lea	cdd_ViewPort2(a4),a0
		move.l	a2,a1
		moveq	#32,d0

	PRINTF	DBG_OSCALL,<'CDG--LoadRGB4($%lx,$%lx,$%lx)'>,A0,A1,D0

		JSRLIB	LoadRGB4

	; obtain pointers to copper list stuff for poking
a671 2
		BSRSELF	SniffCopperLists

d722 43
d773 3
a775 1
	DEBUG_TRAP	9
d777 12
a788 1
		JSRLIB	AddIntServer
d790 1
a793 1
		move.l	a4,cdg_BaseData(a5)
d795 1
a795 1
		movem.l	(sp)+,d2-d3/a2-a6
d804 11
d818 1
a842 2
CDGInit_FAIL16:

d884 2
a885 1
	; Free Copper List 2
a887 9
		move.l	cdd_GfxLib(a4),a6
		lea	cdd_View2(a4),a0
		move.l	v_LOFCprList(a0),a0

	PRINTF	DBG_OSCALL,<'CDG--FreeCprList($%lx)'>,A0

		JSRLIB	FreeCprList

	; Free Copper List 1
a888 2
CDGInit_FAIL11:

d897 1
a897 1
	; Free Intermediate copper List 2
a900 11
		move.l	cdd_GfxLib(a4),a6
		lea	cdd_ViewPort2(a4),a0

	PRINTF	DBG_OSCALL,<'CDG--FreeVPortCopLists($%lx)'>,A0

		JSRLIB	FreeVPortCopLists

	; Free Intermediate copper List 1

CDGInit_FAIL9:

d909 1
a909 1
	; Free ColorMap2
a913 12
		lea	cdd_ViewPort2(a4),a2
		move.l	vp_ColorMap(a2),a0

	PRINTF	DBG_OSCALL,<'CDG--FreeColorMap($%lx)'>,A0

		JSRLIB	FreeColorMap

	; Free ColorMap1

CDGInit_FAIL7:

		move.l	cdd_GfxLib(a4),a6
d928 1
a928 1
		move.l	cdd_4SpriteSize,d0
d948 1
a948 1
	; Free Planes of BitMap2
d953 1
a953 1
		lea	cdd_BitMap2(a4),a2
a957 3
		lea	bm_Planes(a2),a0
		move.l	(a0),a0

d962 1
a962 1
	; Free Planes of BitMap1
d967 1
a967 1
		lea	cdd_BitMap1(a4),a2
a971 3
		lea	bm_Planes(a2),a0
		move.l	(a0),a0

d987 11
d1013 1
a1013 1
		movem.l	(sp)+,d2-d3/a2-a6
d1022 1
a1022 1
	; easy initialization table
d1028 3
a1030 2
		INITBYTE	cdd_IntVBlank+LN_PRI,0
		
d1039 6
a1044 1
******* cdg/--background-- ********************************************
a1057 2
*	o Setting screen colors (0..15)
*
d1061 1
a1061 2
*	  in the graphic data.  Zero bits are drawn in one color,
*	  and One bits are drawn in another.
d1067 1
a1067 1
*	  color it in more than 2 colors by EOR the previous
d1072 2
a1073 2
*	o Change the color table (0..15).  A separate CD+G
*	  command is used to load pen colors 0-7, and 8-15.
d1084 1
a1084 1
*	o Line Graphics - the display is a visible 2 rows, by
d1089 1
a1089 1
*	o TV Graphics - the display is a visible 16 rows, by
d1113 1
a1113 1
*	1.  Therefore, 2 channels are always active.
d1150 1
a1150 1
*	The result of non-corrected data which is in error may be
d1153 1
a1153 1
*	The result of non-correctable data which is in error is
d1158 1
a1158 1
*   cdg.library
d1163 4
a1166 1
*	select audio tracks to play.
d1168 1
a1168 1
*	The caller of these functions is responsible for managing
d1176 1
a1176 1
*	sprite data which must be initialized by the application.
d1204 2
a1205 2
*	Sprite data does NOT need to be in CHIP RAM, however it must
*	be in simple sprite format including the posctrl words, and
d1214 5
a1218 2
*	This function starts CD+G, and may fail due to lack of memory,
*	or inability to open a needed system resource.
d1221 2
a1222 2
*	available.  The PACKETS are buffered, though because of the
*	rate, and size of the PACKETS, assume no more than 1 seconds
d1226 4
a1229 4
*	3.) Start the CD playing.  Once the CD starts playing, assume
*	the cdg.library is receiving CD+G PACKETS.  At this point
*	your code should call CDGDraw() as often as possible.  During
*	every call, CDGDraw() will process any pending PACKETS.
d1231 6
a1236 7
*	CDGDraw() also returns a TRUE value if ANY CD+G PACKS have
*	been processed.  This is meant to be used as an indicator
*	that the CD+G screen should be brought to front, or perhaps
*	a gadget would be displayed indicating that CD+G is available.
*	The user will probably prefer the CD+G screen automatically
*	coming to front, or they will miss the initial portion of
*	the animation.
d1240 1
a1240 1
*	any pending PACKETS will be processed before the screen is
d1249 4
a1252 4
*	to bring the Player Preferences program to front, you must
*	use the CDGBack() function to tell CD+G to turn off any
*	sprites it has on screen, and notify it not to bring its own
*	screen to front again until CDGFront() is called.
d1256 5
a1260 5
*	change the active channels 1-15.  These are functions are
*	used to provide some visual indication to the user that
*	their input has been noticed, and what is happening.  In
*	addition to the channel selection, there are sprite images
*	in CDGPrefs for the following modes --
d1286 4
a1289 1
*	7.) To close down CD+G, use the CDGEnd() function.
d1294 1
a1294 1
*	seconds) so that CD+G data isn't lost.
d1303 2
a1304 2
*	displayed, its is removed before CDGBack() returns to
*	your code.
d1325 2
a1326 2
*	CD's can also contain MIDI data.  The cdg.library also
*	manages MIDI PACKETS during CDGDraw(), and sends this data
@
