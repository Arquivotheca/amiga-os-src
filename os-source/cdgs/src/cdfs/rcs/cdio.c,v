head     1.10;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.10
date     93.05.05.18.19.22;  author jesup;  state Exp;
branches ;
next     1.9;

1.9
date     93.03.04.17.11.12;  author jesup;  state Exp;
branches ;
next     1.8;

1.8
date     93.03.04.01.37.07;  author jesup;  state Exp;
branches ;
next     1.7;

1.7
date     93.01.16.13.36.06;  author jerryh;  state Exp;
branches ;
next     1.6;

1.6
date     92.05.14.13.30.52;  author jesup;  state Exp;
branches ;
next     1.5;

1.5
date     92.02.21.00.27.29;  author jesup;  state Exp;
branches ;
next     1.4;

1.4
date     92.02.20.02.52.55;  author jesup;  state Exp;
branches ;
next     1.3;

1.3
date     92.02.17.00.04.29;  author jesup;  state Exp;
branches ;
next     1.2;

1.2
date     91.12.22.23.01.36;  author bryce;  state Exp;
branches ;
next     1.1;

1.1
date     91.10.16.09.19.59;  author andy;  state Exp;
branches ;
next     ;


desc
@@


1.10
log
@Fix io_torture hits at boot (cosmetic)
@
text
@/***********************************************************************
****************                                        ****************
****************        -=   CD FILE SYSTEM   =-        ****************
****************                                        ****************
************************************************************************
***                                                                  ***
***   Written by Carl Sassenrath for Commodore International, Ltd.   ***
*** Copyright (C) 1991 Commodore Electronics Ltd. All rights reserved***                                                                  ***
***                                                                  ***
***         Confidential and Proprietary System Source Code          ***
***                                                                  ***
***********************************************************************/

#include "main.h"
#include <devices/trackdisk.h>

IMPORT  struct Task *FindTask();
IMPORT  APTR FetchA4();

/* we can't handle 64K dir block cache blocks! (not that we have that much
   mem anyways, that would be a truely impressive amount of ram). In reality
   this can't go over 256 in the forseeable future (that's 512K contiguous)
   but it's safer to handle it, since it's theoretically possible.  - REJ */

#define INVALID_DIR_INDEX       0xffff

#define D(x)    ;
#define DD(x)   ;

/***********************************************************************
***
***  DiskChanged
***
***     Low-level disk change interrupt server.
***     If there are no other disk change interrupt servers in the
***     list, then no one else is interested in disk inserts, and
***     we will reset the machine!
***
***     May want to delay if SCSI or TrackDisk is active, or if
***     we are not the Boot device.
***
***********************************************************************/
extern  VOID DiskChanged();
#asm
        XDEF    _DiskChanged
_DiskChanged:
                movem.l d2/a2/a4/a6,-(sp)
                move.l  10(a1),a4       ; data segment
                jsr     _ChangeFunc
                movem.l (sp)+,d2/a2/a4/a6
                rts

#endasm

/***********************************************************************
***
***  ChangeFunc
***
***     An interrupt level function that handles disk change events.
***
***********************************************************************/
void ChangeFunc()
{
        Debug1("\tC\n");
	D(Debug0("Disk Change\n"));

        InsertFlag = TRUE;
        Signal(FSProc, 1 << (FSPort->mp_SigBit));
}

/***********************************************************************
***
***  InitBootIO
***
***     Setup a temporary IO connection for checking out the boot disk.
***
***********************************************************************/
InitBootIO()
{
        BootPort.mp_Flags = 0;
        BootPort.mp_SigBit = AllocSignal(-1);
        BootPort.mp_SigTask = FindTask(NULL);
        NewList(&BootPort.mp_MsgList);

        DevIOReq.io_Message.mn_Node.ln_Type = NT_REPLYMSG;
        DevIOReq.io_Message.mn_ReplyPort = &BootPort;   
        if (OpenDevice(&DeviceName[0],0,&DevIOReq,0)) return FALSE;

        return TRUE;
}

QuitBootIO()
{
        CloseDevice(&DevIOReq);
        FreeSignal(BootPort.mp_SigBit);
}

/***********************************************************************
***
***  InitCDIO
***
***********************************************************************/
InitCDIO() {

        D(Debug0("Welcome to the CD filesystem.\n"));

        if (OpenDevice("input.device",0,&InpReq,0)) return FALSE;

        /* Init and open our device: */
        DevIOReq.io_Message.mn_Node.ln_Type = NT_REPLYMSG;

        /* Share the process message port !?  Messy.
        DevIOReq.io_Message.mn_ReplyPort = FSPort; */

        DevMsgPort.mp_Node.ln_Type = NT_MSGPORT;
        DevMsgPort.mp_Flags        = PA_SIGNAL;
        DevMsgPort.mp_SigBit       = AllocSignal(-1);
        DevMsgPort.mp_SigTask      = FindTask(NULL);
        NewList(&DevMsgPort.mp_MsgList);
        DevIOReq.io_Message.mn_ReplyPort = &DevMsgPort;

        if (OpenDevice(DeviceName,UnitNumber,&DevIOReq,OpenFlags)) return FALSE;

#ifdef COMPLEX_CACHE
        DevMasterReq = DevIOReq;                /* for initing IOR's */
#endif
        DevChgReq    = DevIOReq;                /* copy struct */

        /* Setup disk change interrupt and its request: */
        DiskChgInt.is_Node.ln_Type = NT_INTERRUPT;
        DiskChgInt.is_Code = &DiskChanged;
        DiskChgInt.is_Data = (APTR)&DevChgReq;
        DevChgReq.io_Message.mn_Node.ln_Name = (char *)FetchA4();       
        DevChgReq.io_Command = CD_ADDCHANGEINT; 
        DevChgReq.io_Data = (APTR)&DiskChgInt;  
        SendIO(&DevChgReq);             

        return(TRUE);
        }

/***********************************************************************
***
***  MakeCache
***
***********************************************************************/
MakeCache()
{
#ifdef COMPLEX_CACHE
        if (CacheSize > 0x7fff)
                CacheSize = 0x7fff;

        /* guaranteed to be all 0's!!!! active = 0, block = 0, etc */
        MUST(Cache = MakeVector((WORD) CacheSize * (WORD) sizeof(struct Cache)));
        MUST(Cache[0].data = MakeVector(CacheSize << BlockShift));

        /* set up IOR's so we can use them */
        {
                REG UWORD i;
                for (i = 0; i < CacheSize; i++)
                {
                        /* structure copy */
                        Cache[i].IOR = DevMasterReq;
                        /* safe to add since data is a UBYTE * */
                        Cache[i].data = Cache[0].data + (i << BlockShift);
                }
        }
        LastCachedBlock = 0;
#else
        MUST(Cache = MakeVector(CacheSize << BlockShift));
#endif
        MUST(DirCache = MakeVector(DirCacheSize << BlockShift));
        MUST(DirCacheIndex = MakeVector(DirCacheSize * sizeof(ULONG)));
        MUST(DirCacheList = MakeVector(DirCacheSize * sizeof(UWORD)));
        DirCacheFirst = INVALID_DIR_INDEX;

        /* this must be of range -1 ... max_uword, i.e. LONG */
        DirCacheHighWater = -1;

        return TRUE;
}

/***********************************************************************
***
***  MoreCache
***
***     Add or subtract some number of blocks from the disk cache.
***     (Implicit flush in this code).
***
***********************************************************************/
MoreCache(new)
        REG LONG new;
{
        if (!new) return CacheSize;

        new += CacheSize;
        if (new <= 2) new = 2;

#ifdef COMPLEX_CACHE
        FlushDataCache();       /* make sure pending IO's are done */

        Forbid();       /* Don't want to risk losing my memory! */
        FreeVector(Cache[0].data);      /* one big allocation */
        FreeVector(Cache);

        if (new > 0x7fff)
                new = 0x7fff;

        /* guaranteed to be all 0's!!!! active = 0, block = 0, etc */
        Cache = MakeVector((WORD) new * (WORD) sizeof(struct Cache));
        if (Cache)
                Cache[0].data = MakeVector(new << BlockShift);
        while (!Cache || !Cache[0].data)
                                 /* Too big... come as close as we can. */
        {
                if (Cache) FreeVector(Cache);

                Cache = MakeVector((WORD) (--new) *
                                   (WORD) sizeof(struct Cache));
                if (Cache)
                        Cache[0].data = MakeVector(new << BlockShift);
        }
        Permit();

        CacheSize = new;

        /* set up IOR's so we can use them */
        {
                REG UWORD i;
                for (i = 0; i < CacheSize; i++)
                {
                        /* structure copy */
                        Cache[i].IOR = DevMasterReq;
                        Cache[i].data = Cache[0].data + (i << BlockShift);
                }
        }
#else
        Forbid();       /* Don't want to risk losing my memory! */
        FreeVector(Cache);
        Cache = MakeVector(new << BlockShift);
        while (!Cache) /* Too big... come as close as we can. */
        {
                Cache = MakeVector((--new) << BlockShift);
        }
        Permit();

        CacheBlock = 0;         /* Flush */
        CacheSize = new;

#endif
        return new;
}

#ifdef COMPLEX_CACHE
/***********************************************************************
***
***  StartCacheRead
***
*** Starts the IOR for a cache block
************************************************************************/
void StartCacheRead(index,block)
        UWORD index;
        ULONG block;
{
        struct Cache *cache = &Cache[index];

        if (cache->active)                      /* Aborted or not */
                WaitIO(&(cache->IOR));

        cache->block = block;
        cache->retry = Retry;   /* Max retries */
        cache->active = TRUE;

        StartDevIO(&(Cache[index].IOR),CD_READ,block << BlockShift,BlockSize,
                   cache->data);
        /* retries are handled above in ReadBlock */
}

/***********************************************************************
***
***  FlushDataCache
***
***********************************************************************/
FlushDataCache()
{
        REG UWORD i;

        D(Debug0("Flush data cache\n"));
        for (i = 0; i < CacheSize; i++)
        {
                if (Cache[i].active)
                {
                        if (!CheckIO(&(Cache[i].IOR)))
                                AbortIO(&(Cache[i].IOR));
                        WaitIO(&(Cache[i].IOR));
                        Cache[i].active = FALSE;
                }
                Cache[i].block = 0;
        }
        LastCachedBlock = 0;
}

/***********************************************************************
***
***  AbortCacheAllBut
***
*** Abort all requests but the one mentioned.
***
***********************************************************************/
AbortCacheAllBut(block)
        ULONG block;
{
        REG UWORD i;

        D(Debug0("Abort all but %ld\n",block));
        for (i = 0; i < CacheSize; i++)
        {
                if (Cache[i].active)
                {
                        if (!CheckIO(&(Cache[i].IOR)) &&
                            block != Cache[i].block)
                        {
                                /* MUST mark as invalid before waiting! */
                                /* this is to keep quickread safe.      */
                                Cache[i].block = 0;
                                AbortIO(&(Cache[i].IOR));

                        /* no need to wait, it'll be done when it's needed */
                                /*WaitIO(&(Cache[i].IOR));*/
                                /*Cache[i].active = FALSE;*/
                        }
                }
        }
        LastCachedBlock = block;
}

/***********************************************************************
***
***  AbortCacheLessThan
***
*** Abort all requests below the on mentioned
***
***********************************************************************/
AbortCacheLessThan(block)
        ULONG block;
{
        REG UWORD i;

        DD(Debug0("Abort less than %ld\n",block));
        for (i = 0; i < CacheSize; i++)
        {
                if (Cache[i].block < block &&
                    Cache[i].active &&
                    !CheckIO(&(Cache[i].IOR)))
                {
                        /* MUST mark as invalid before waiting! */
                        /* this is to keep quickread safe.      */
                        Cache[i].block = 0;
                        AbortIO(&(Cache[i].IOR));

                        /* no need to wait, it'll be done when it's needed */
                        /*WaitIO(&(Cache[i].IOR));*/
                        /*Cache[i].active = FALSE;*/
                }
        }
}
#endif

/***********************************************************************
***
***  FlushCache
***
***********************************************************************/
FlushCache()
{
        /* no need to clear index values, since LRU list is empty */
        DirCacheFirst = INVALID_DIR_INDEX;
        DirCacheHighWater = -1;
#ifdef COMPLEX_CACHE
        FlushDataCache();
#else
        CacheBlock = 0;
#endif
}

/***********************************************************************
***  InCache
***
***     Returns if a given block is in the cache.  (REJ)
***     done of TRUE means it only looks for completed blocks.
***     done of FALSE means look for uncompleted blocks as well.
***
***********************************************************************/
LONG InCache(lbn,done)
        ULONG lbn;
        int done;
{
#ifdef COMPLEX_CACHE
        REG UWORD i;
        for (i = 0; i < CacheSize; i++)
        {
                if (lbn == Cache[i].block)
                {
                        /* done means it must be complete */
                        /* if complete, check io_Error as well! */
                        return (!done || !Cache[i].active ||
                                (CheckIO(&(Cache[i].IOR)) &&
                                 !Cache[i].IOR.io_Error));
                }
        }
        return FALSE;
#else
        if (CacheBlock && lbn >= CacheBlock && lbn < CacheBlock+CacheSize)
                return TRUE;
        return FALSE;
#endif
}

/***********************************************************************
***  DirCacheFull
***
***     Returns whether the dir cache is full or not. (REJ)
***
***********************************************************************/
LONG DirCacheFull()
{
        return DirCacheHighWater >= DirCacheSize-1;
}

/***********************************************************************
***
***  ReadBlock
***
***     V34.2 - changes to stat gathering
***
***********************************************************************/
#ifdef COMPLEX_CACHE
        /* Alternate scheme to try to keep blocks streaming into memory */

        /* We have multiple buffers.  Each has it's own IOR.  As each   */
        /* block is read, IF the current file has not been Seek()ed     */
        /* backwards, the previous block (if cached) will be dumped, and*/
        /* the ior will be sent to prefetch the next block of data from */
        /* the drive.  However, we will NOT prefetch past the end of a  */
        /* file, nor will we do this on files with backward Seeks.      */
        /* Actually, we take all blocks that are lower and roll them    */
        /* over after a hit, to handle Seek forwards.                   */

        /* If we get a cache miss, we will AbortIO any IOR's, and then  */
        /* restart all for successive blocks starting at the new        */
        /* location.  This does NOT help switching between two files!   */
        /* Perhaps we should only reuse blocks as needed (plus any we   */
        /* AbortIO'd).  This _might_ help with the two-file problem, but*/
        /* I suspect it's not worth it. - REJ                           */

        /* Careful: with quick read stuff, we must NOT wait on a hit.   */
        /* Also, is it safe to have LastCachedBlock change during a     */
        /* QuickRead? Since it will never try a quickread if the FS is  */
        /* running, it can only be a problem during a Wait.             */

        /* parameters: back_seeked - boolean flag                       */
        /*             eof - end of file lba, or -1 for non-file        */
        /* global:     LastCachedBlock - the last block REQUESTED       */

UBYTE *ReadBlock(lbn,eof,back_seeked,quick)
        ULONG   lbn;
        ULONG   eof;
        int     back_seeked,quick;
{
        REG UWORD i,j;

        DD(Debug0("\tb %ld, eof %ld, %ld\n",lbn,eof,back_seeked));

        /* FIX!  why do we keep this? Should only do when debugging is on? */
        /* ditto for other stats variables.  Should be a define.  - REJ */
        BlockCount++;

        for (i = 0; i < CacheSize; i++)
        {
                if (lbn == Cache[i].block)
                {
                    /* We have a cache hit! */
                    DD(Debug0("Cache hit %ld %s\n",lbn,
                             Cache[i].active ?
                                (!CheckIO(&(Cache[i].IOR)) ? "(not done)" : "")
                                : ""));
                    D(Debug0(Cache[i].active ?
                                (!CheckIO(&(Cache[i].IOR)) ? "(" : ".")
                                : "."));
                    /* now if the previous block is in the cache, drop it */
                    /* and start an IOR for the next block.               */
                    /* Better yet, do all blocks older than the current.  */
                    /* MUST NEVER read ahead if back_seeked is true!      */
                    /* QuickRead WILL cause new IORs to be sent!!!!       */
                    if (eof != 0xffffffff /* not a data block */ &&
                        !back_seeked && eof > LastCachedBlock)
                    {
                        /* abort active requests earlier than hit */
                        /* since we've never seeked back, should be great */
//                      AbortCacheLessThan(lbn);

                        for (j = 0; j < CacheSize; j++)
                        {
                            if (Cache[j].block < lbn)
                            {
                            /* don't start if we're quick and it's not done */
                                if (!quick || 
                                    !Cache[j].active ||
                                    CheckIO(&(Cache[j].IOR)))
                                {
                                        DD(Debug0("Reuse %ld for b %ld\n",j,
                                                 LastCachedBlock+1));
                                        StartCacheRead(j,++LastCachedBlock);
                                }
                            }
                        }
                    }
                    /* QuickRead uses InCache, which checks io_Error, */
                    /* so retrys are safe.                            */
                    /* now we must wait if the block isn't ready yet  */
                    while (Cache[i].active)
                    {
                        WaitIO(&(Cache[i].IOR));
                        if (!Cache[i].IOR.io_Error ||
                             Cache[i].IOR.io_Error != CDERR_DMAFAILED ||
                             Cache[i].retry-- == 0)
                        {
                            /* Carl never checked for errors here! */
                            /* Fix!? should we do something about errs???? */
                            DD(Debug0("Got data\n"));
                            Cache[i].active = FALSE;
                        } else {
                            /* retry */
                            D(Debug0("Retry %ld lbn %ld\n",Cache[i].retry,
                                     Cache[i].block));
                            StartDevIO(&(Cache[i].IOR),CD_READ,
                                       Cache[i].block << BlockShift,
                                       BlockSize,Cache[i].data);
                        }
                        D(Debug0(")"));
                    }

                    /* fix? should we remove this stats stuff? */
                    HitCount++;
                    return Cache[i].data;
                }
        }

        /* we had no cache hit.  Grab some blocks and start stuff going */
        D(Debug0("Miss: %ld",lbn));

        /* This abort code is safe with QuickRead since it NEVER Waits! */

        /* first Abort any active IOR's */
        AbortCacheLessThan(0xffffffff);         /* MAX_ULONG */

        /* now find a block to satisfy this request */
        /* for now, we'll start IORs for all blocks */
        LastCachedBlock = lbn-1;
        for (i = 0; i < CacheSize; i++)
                StartCacheRead(i,++LastCachedBlock);

        /* FIX! remove this statistics stuff!!! */
        ReadCount += BlockSize;

        /* now return when the first block is ready */
        /* we KNOW cache[0].IOR is active! */
        /* QuickRead uses InCache, which checks io_Error, so retrys are safe */
        while (Cache[0].active)
        {
/* FIX!! should be a subroutine! */
                WaitIO(&(Cache[0].IOR));
                if (!Cache[0].IOR.io_Error ||
                     Cache[0].IOR.io_Error != CDERR_DMAFAILED ||
                     Cache[0].retry-- == 0)
                {
                    /* Carl never checked for errors here! */
                    /* Fix!? should we do something about errs???? */
                    if (Cache[0].IOR.io_Error)
                            Cache[0].block  = 0;
                    Cache[0].active = FALSE;
                } else {
                    /* retry */
                    D(Debug0("Retry %ld lbn %ld\n",Cache[0].retry,
                             Cache[0].block));
                    StartDevIO(&(Cache[0].IOR),CD_READ,
                               Cache[0].block << BlockShift,
                               BlockSize,Cache[0].data);
                }
        }
        DD(Debug0("Got first block...\n"));
        D(Debug0(".\n"));

        return Cache[0].data;
}
#else
UBYTE *ReadBlock(lbn)
        ULONG   lbn;
{
        Debug3("\tb%lx\n",lbn); 

        /* FIX!  why do we keep this? Should only do when debugging is on? */
        /* ditto for other stats variables.  Should be a define.  - REJ */
        BlockCount++;

        if (CacheBlock && lbn >= CacheBlock && lbn < CacheBlock+CacheSize)
        {
                HitCount++;
                D(Debug0("rcache-H: lbn=%ld\n",lbn));
                return &Cache[(lbn-CacheBlock) << BlockShift];
        }
        ReadCount += CacheSize;
        D(Debug0("rcache-M: lbn=%ld\n",lbn));

        ReadBytes(Cache,lbn<<BlockShift,CacheSize<<BlockShift);
        CacheBlock = lbn;
        return Cache;
}
#endif


/***********************************************************************
***
***  GetDirBlock
***
*** Modified to add simple LRU scheme.  Max dircachesize is 0xfffe
*** blocks (yeah, right).  The only reason I used a uword is that iso.c
*** sets it as a uword from some params it reads.
************************************************************************/
DIREC *GetDirBlock(lbn)
        ULONG lbn;
{
        REG DIREC *dr;
        REG UWORD i,prev;
	int err;

        /* first scan the list for a match.  Scan in LRU order */
        prev = INVALID_DIR_INDEX;
        i = DirCacheFirst;

        if (i != INVALID_DIR_INDEX)
        {
            while (1) {
                DD(Debug0("LRU index %ld, lbn=%ld\n",i,DirCacheIndex[i]));
                if (lbn == DirCacheIndex[i])
                {
                        DD(Debug0("LRU hit, prev = %ld!\n",prev));
                        /* move entry to front of list - don't move if first */
                        if (prev != INVALID_DIR_INDEX)
                        {
                                DirCacheList[prev] = DirCacheList[i];
                                DirCacheList[i] = DirCacheFirst;
                                DirCacheFirst = i;
                        }
                        return (DIREC *)(&DirCache[i<<BlockShift]);
                }
                /* we must keep prev and i valid if we didn't find it! */
                if (DirCacheList[i] == INVALID_DIR_INDEX)
                        break;

                /* get next entry in list */
                prev = i;
                i = DirCacheList[i];
            }
        }

        /* failure, not cached. i is either INVALID_DIR_INDEX (nothing
           cached), or it's the index of the least-recently-used block.  Only
           replace the LRU block if the cache is full.
        */

        /* this handles the i == INVALID_DIR_INDEX case! */
        if (DirCacheHighWater < DirCacheSize-1)
        {
                /* we have unused blocks to use */
                prev = i;       /* this will still be the end of the list */

                /* this is the block to load into */
                i = ++DirCacheHighWater;
        }

        /* i CANNOT be INVALID_DIR_INDEX here */
        DD(Debug0("LRU miss, prev = %ld, i = %ld, high = %ld\n",prev,i,
                 DirCacheHighWater));

        /* remove from end of list */
        if (prev != INVALID_DIR_INDEX)
                DirCacheList[prev] = INVALID_DIR_INDEX;

        /* add to head of list */
        DirCacheList[i] = DirCacheFirst;
        DirCacheFirst   = i;  /* this node will be at head of the list */

        /*
        ** Now that the device driver does prefetching, we
        ** read read directly to the directory cache, rather than
        ** flushing the file cache.
        **
        ** Previous code looped until a good block came in, but
        ** the test was buggy.  This code retries until read
        ** is ok.
        */
        dr = (DIREC *)&DirCache[i<<BlockShift];
        D(Debug0("DirBlk-M: lbn=%ld\n",lbn));

	/* continue trying until the disk is removed - probably not wise... */
	/* it should probably give up after a while... */
	do {
        	err = ReadBytes(dr,lbn<<BlockShift,BlockSize);
		if (err == TDERR_DiskChanged)
		{
			D(Debug0("Disk removed!!!\n"));
			/* we must make sure this doesn't look valid. */
			/* use an invalid block number, since the LRU */
			/* scheme doesn't make it easy to remove it.  */
			DirCacheIndex[i] = 0xffffffff;
			PktRes2 = ERROR_NO_DISK;
			return NULL;
		}
 	} while (err);       /* V24.4 - Must read it! */

        DirCacheIndex[i] = lbn;

        /*
         * if there are empty entries in the dir cache, and the next block
         * is also a directory cache block, it's nice to read them in,
         * since you tend to have N directory blocks, then the data for
         * those files.  This helps avoid a seek back to the directory after
         * reading each file or two (hopefully).  Mostly it helps at
         * startup.
         *
         * This is handled in dir.c, since it knows if the next block is
         * a directory block (using DirCacheFull to know if empty slots exist).
         */

        return dr;
}


/***********************************************************************
***
***  ReadBytes
***
***********************************************************************/
ReadBytes(buf,offset,size)      /* Bytes, bytes, bytes */
        char *buf;
        ULONG offset;
        ULONG size;
{
        REG int err;
        REG int i;

        DD(Debug0("cd_read      : buf=%lx,lbn=%ld,size=%lx\n",buf,offset>>BlockShift,size));

        for (i = 0; i < Retry; i++)
        {
                err = DoDevIO(CD_READ,offset,size,buf);
                if (err == 0) return 0;
                ReadErrs++;
                DD(Debug0("\tE%lx.%lx.%lx.%lx\n",err,offset,size,buf));
                if (err != CDERR_DMAFAILED) break;
        }
        return err;
}


/***********************************************************************
***
***  StartReadBytes
***
***********************************************************************/
StartReadBytes(buf,offset,size) /* Bytes, bytes, bytes */
        char *buf;
        ULONG offset;
        ULONG size;
{
        REG int err;
        REG int i;

        DD(Debug0("cd_startread : buf=%lx,lbn=%ld,size=%lx\n",buf,offset>>BlockShift,size));

        /* Must NOT be used again unitl WaitReadBytes is called!!!!! */
        StartDevIO(&DevIOReq,CD_READ,offset,size,buf);
}


/***********************************************************************
***
***  WaitReadBytes
***
***********************************************************************/
WaitReadBytes(buf,offset,size)  /* Bytes, bytes, bytes */
        char *buf;
        ULONG offset;
        ULONG size;
{
        REG int err;
        REG int i;

        for (i = 0; i < Retry; i++)
        {
                WaitIO(&DevIOReq);
                err = DevIOReq.io_Error;
                if (err == 0) return 0;
                ReadErrs++;
                DD(Debug0("\tE%lx.%lx.%lx.%lx\n",err,offset,size,buf));
                if (err != CDERR_DMAFAILED) break;
                StartDevIO(&DevIOReq,CD_READ,offset,size,buf);
        }
        return err;
}


/***********************************************************************
***
***  ReadCD
***
***********************************************************************/
ReadCD(buf,blk,len)
        char *buf;
        ULONG blk;
        ULONG len;
{
        return ReadBytes(buf, blk << BlockShift, len << BlockShift);
}


/***********************************************************************
***
***  ReMount
***
***     Called when a disk change interrupt has been detected in 
***     the main dispatch loop.
***
***     Re-initializes data structures each time, but this routine
***     happens so rarely that this is not a concern.
***
* FIX??? should we abort any active IOR's for complex cache???
***********************************************************************/
ReMount()
{
        /* V34.2 moved inhibit check to main.c */
        InsertFlag = FALSE;

        if (InputPends) return FALSE;   /* it's busy, ignore it */
        InputPends = TRUE;

        DoDevIO(CD_CHANGESTATE,0,0,0);
        if (DevIOReq.io_Actual)         /* true when no disk */
        {
                InpEvent.ie_Class = IECLASS_DISKREMOVED;
                UnMount();
        }
        else
        {
                InpEvent.ie_Class = IECLASS_DISKINSERTED;
                Mount(FALSE);
        }
        InpEvent.ie_NextEvent = NULL;
        /* No time stamp. */

        InpPacket.dp_Link = (struct Message *) &InpReq;
        InpPacket.dp_Port = FSPort; 
        InpPacket.dp_Type = ACTION_DISK_CHANGE;

        InpReq.io_Message.mn_Node.ln_Name = (char *) &InpPacket;
        InpReq.io_Message.mn_Node.ln_Type = NT_REPLYMSG;
        InpReq.io_Message.mn_ReplyPort = FSPort;
        InpReq.io_Command = IND_WRITEEVENT;     
        InpReq.io_Data = (APTR) &InpEvent;
        InpReq.io_Length = sizeof(InpEvent);

        SendIO(&InpReq);

        return TRUE;
}

@


1.9
log
@Added debugs
@
text
@d85 1
a85 1
        DevIOReq.io_Message.mn_Node.ln_Type = NT_MESSAGE;
d110 1
a110 1
        DevIOReq.io_Message.mn_Node.ln_Type = NT_MESSAGE;
d866 1
a866 1
        InpReq.io_Message.mn_Node.ln_Type = NT_MESSAGE;
@


1.8
log
@GetDirBlock will now return an error if a disk is removed.  It still
doesn't return if it gets a read error - it keeps trying.  On failure,
it sets pktres2 to ERROR_NO_DISK.
@
text
@d65 1
d711 1
@


1.7
log
@cd.device instead of cdtv.device.
@
text
@d15 1
d633 1
d704 14
a717 2
        while( ReadBytes(dr,lbn<<BlockShift,BlockSize) )
                ;       /* V24.4 - Must read it! */
@


1.6
log
@Fixed MoreCache - it wasn't freeing the data, and could whomp low mem
if an allocation failed
@
text
@d3 1
a3 1
****************        -=  CDTV FILE SYSTEM  =-        ****************
d16 2
a17 2
IMPORT	struct Task *FindTask();
IMPORT	APTR FetchA4();
d24 1
a24 1
#define INVALID_DIR_INDEX	0xffff
d26 2
a27 2
#define	D(x)	;
#define	DD(x)	;
d33 4
a36 4
***	Low-level disk change interrupt server.
***	If there are no other disk change interrupt servers in the
***	list, then no one else is interested in disk inserts, and
***	we will reset the machine!
d38 2
a39 2
***	May want to delay if SCSI or TrackDisk is active, or if
***	we are not the Boot device.
d42 1
a42 1
extern	VOID DiskChanged();
d44 1
a44 2
	XREF	ResetAmiga
	XDEF	_DiskChanged
d46 5
a50 7
		movem.l	d2/a2/a4/a6,-(sp)
		move.l	10(a1),a4	; data segment
		jsr	_ChangeFunc
		tst.l	d0		; reset? CES V22.3
		bne	ResetAmiga	; V22.4
		movem.l	(sp)+,d2/a2/a4/a6
		rts
d58 1
a58 1
***	An interrupt level function that handles disk change events.
d61 1
a61 1
ChangeFunc()
d63 4
a66 13
	Debug1("\tC\n");

	/* Reset the machine if no other change int is found... V22.3 */
	if (NoReset > 0 && InhibitCount == 0 &&   /* V34.2 */
		(ULONG)(DevChgReq.io_Message.mn_Node.ln_Pred)+4 == 
		(ULONG)(DevChgReq.io_Message.mn_Node.ln_Succ))
	{
		return TRUE;
	}

	InsertFlag = TRUE;
	Signal(FSProc, 1 << (FSPort->mp_SigBit));
	return FALSE;  /* no reset */
d73 1
a73 1
***	Setup a temporary IO connection for checking out the boot disk.
d78 4
a81 4
	BootPort.mp_Flags = 0;
	BootPort.mp_SigBit = AllocSignal(-1);
	BootPort.mp_SigTask = FindTask(NULL);
	NewList(&BootPort.mp_MsgList);
d83 3
a85 3
	DevIOReq.io_Message.mn_Node.ln_Type = NT_MESSAGE;
	DevIOReq.io_Message.mn_ReplyPort = &BootPort;	
	if (OpenDevice(&DeviceName[0],0,&DevIOReq,0)) return FALSE;
d87 1
a87 1
	return TRUE;
d92 2
a93 2
	CloseDevice(&DevIOReq);
	FreeSignal(BootPort.mp_SigBit);
d101 3
a103 3
InitCDIO()
{
	extern Reset();
d105 33
a137 36
	D(Debug0("Welcome to the CD filesystem.\n"));

	if (OpenDevice("input.device",0,&InpReq,0)) return FALSE;

	/* Init and open our device: */
	DevIOReq.io_Message.mn_Node.ln_Type = NT_MESSAGE;

	/* Share the process message port !?  Messy.
	DevIOReq.io_Message.mn_ReplyPort = FSPort; */

	DevMsgPort.mp_Node.ln_Type = NT_MSGPORT;
	DevMsgPort.mp_Flags        = PA_SIGNAL;
	DevMsgPort.mp_SigBit       = AllocSignal(-1);
	DevMsgPort.mp_SigTask      = FindTask(NULL);
	NewList(&DevMsgPort.mp_MsgList);
	DevIOReq.io_Message.mn_ReplyPort = &DevMsgPort;

	if (OpenDevice(DeviceName,UnitNumber,&DevIOReq,OpenFlags))
		return FALSE;
#ifdef COMPLEX_CACHE
	DevMasterReq = DevIOReq;		/* for initing IOR's */
#endif
	DevChgReq    = DevIOReq;		/* copy struct */

	DoDevIO(CD_START,0,0,0);	/* start HW ints again V22.2 */
	DoDevIO(CD_OPTIONS,0,DebugLevel>>16,0);	/* V34.4 */

	/* Setup disk change interrupt and its request: */
	DiskChgInt.is_Node.ln_Type = NT_INTERRUPT;
	DiskChgInt.is_Code = &DiskChanged;
	DiskChgInt.is_Data = (APTR)&DevChgReq;
	DevChgReq.io_Message.mn_Node.ln_Name = (char *)FetchA4();	
	DevChgReq.io_Command = CD_ADDCHANGEINT;	
	DevChgReq.io_Data = (APTR)&DiskChgInt;	
	SendIO(&DevChgReq);		
}
d147 2
a148 2
	if (CacheSize > 0x7fff)
		CacheSize = 0x7fff;
d150 16
a165 16
	/* guaranteed to be all 0's!!!! active = 0, block = 0, etc */
	MUST(Cache = MakeVector((WORD) CacheSize * (WORD) sizeof(struct Cache)));
	MUST(Cache[0].data = MakeVector(CacheSize << BlockShift));

	/* set up IOR's so we can use them */
	{
		REG UWORD i;
		for (i = 0; i < CacheSize; i++)
		{
			/* structure copy */
			Cache[i].IOR = DevMasterReq;
			/* safe to add since data is a UBYTE * */
			Cache[i].data = Cache[0].data + (i << BlockShift);
		}
	}
	LastCachedBlock = 0;
d167 1
a167 1
	MUST(Cache = MakeVector(CacheSize << BlockShift));
d169 9
a177 9
	MUST(DirCache = MakeVector(DirCacheSize << BlockShift));
	MUST(DirCacheIndex = MakeVector(DirCacheSize * sizeof(ULONG)));
	MUST(DirCacheList = MakeVector(DirCacheSize * sizeof(UWORD)));
	DirCacheFirst = INVALID_DIR_INDEX;

	/* this must be of range -1 ... max_uword, i.e. LONG */
	DirCacheHighWater = -1;

	return TRUE;
d184 2
a185 2
***	Add or subtract some number of blocks from the disk cache.
***	(Implicit flush in this code).
d189 1
a189 1
	REG LONG new;
d191 1
a191 1
	if (!new) return CacheSize;
d193 41
a233 41
	new += CacheSize;
	if (new <= 2) new = 2;

#ifdef COMPLEX_CACHE
	FlushDataCache();	/* make sure pending IO's are done */

	Forbid();	/* Don't want to risk losing my memory! */
	FreeVector(Cache[0].data);	/* one big allocation */
	FreeVector(Cache);

	if (new > 0x7fff)
		new = 0x7fff;

	/* guaranteed to be all 0's!!!! active = 0, block = 0, etc */
	Cache = MakeVector((WORD) new * (WORD) sizeof(struct Cache));
	if (Cache)
		Cache[0].data = MakeVector(new << BlockShift);
	while (!Cache || !Cache[0].data)
				 /* Too big... come as close as we can. */
	{
		if (Cache) FreeVector(Cache);

		Cache = MakeVector((WORD) (--new) *
				   (WORD) sizeof(struct Cache));
		if (Cache)
			Cache[0].data = MakeVector(new << BlockShift);
	}
	Permit();

	CacheSize = new;

	/* set up IOR's so we can use them */
	{
		REG UWORD i;
		for (i = 0; i < CacheSize; i++)
		{
			/* structure copy */
			Cache[i].IOR = DevMasterReq;
			Cache[i].data = Cache[0].data + (i << BlockShift);
		}
	}
d235 14
a248 14
	Forbid();	/* Don't want to risk losing my memory! */
	FreeVector(Cache);
	Cache = MakeVector(new << BlockShift);
	while (!Cache) /* Too big... come as close as we can. */
	{
		Cache = MakeVector((--new) << BlockShift);
	}
	Permit();

	CacheBlock = 0;		/* Flush */
	CacheSize = new;

#endif
	return new;
d259 2
a260 2
	UWORD index;
	ULONG block;
d262 1
a262 1
	struct Cache *cache = &Cache[index];
d264 10
a273 10
	if (cache->active)			/* Aborted or not */
		WaitIO(&(cache->IOR));

	cache->block = block;
	cache->retry = Retry;	/* Max retries */
	cache->active = TRUE;

	StartDevIO(&(Cache[index].IOR),CD_READ,block << BlockShift,BlockSize,
		   cache->data);
	/* retries are handled above in ReadBlock */
d283 1
a283 1
	REG UWORD i;
d285 13
a297 13
	D(Debug0("Flush data cache\n"));
	for (i = 0; i < CacheSize; i++)
	{
		if (Cache[i].active)
		{
			if (!CheckIO(&(Cache[i].IOR)))
				AbortIO(&(Cache[i].IOR));
			WaitIO(&(Cache[i].IOR));
			Cache[i].active = FALSE;
		}
		Cache[i].block = 0;
	}
	LastCachedBlock = 0;
d308 1
a308 1
	ULONG block;
d310 1
a310 1
	REG UWORD i;
d312 20
a331 20
	D(Debug0("Abort all but %ld\n",block));
	for (i = 0; i < CacheSize; i++)
	{
		if (Cache[i].active)
		{
			if (!CheckIO(&(Cache[i].IOR)) &&
			    block != Cache[i].block)
			{
				/* MUST mark as invalid before waiting! */
				/* this is to keep quickread safe.	*/
				Cache[i].block = 0;
				AbortIO(&(Cache[i].IOR));

			/* no need to wait, it'll be done when it's needed */
				/*WaitIO(&(Cache[i].IOR));*/
				/*Cache[i].active = FALSE;*/
			}
		}
	}
	LastCachedBlock = block;
d342 1
a342 1
	ULONG block;
d344 1
a344 1
	REG UWORD i;
d346 17
a362 17
	DD(Debug0("Abort less than %ld\n",block));
	for (i = 0; i < CacheSize; i++)
	{
		if (Cache[i].block < block &&
		    Cache[i].active &&
		    !CheckIO(&(Cache[i].IOR)))
		{
			/* MUST mark as invalid before waiting! */
			/* this is to keep quickread safe.	*/
			Cache[i].block = 0;
			AbortIO(&(Cache[i].IOR));

			/* no need to wait, it'll be done when it's needed */
			/*WaitIO(&(Cache[i].IOR));*/
			/*Cache[i].active = FALSE;*/
		}
	}
d373 3
a375 3
	/* no need to clear index values, since LRU list is empty */
	DirCacheFirst = INVALID_DIR_INDEX;
	DirCacheHighWater = -1;
d377 1
a377 1
	FlushDataCache();
d379 1
a379 1
	CacheBlock = 0;
d386 3
a388 3
***	Returns if a given block is in the cache.  (REJ)
***	done of TRUE means it only looks for completed blocks.
***	done of FALSE means look for uncompleted blocks as well.
d392 2
a393 2
	ULONG lbn;
	int done;
d396 13
a408 13
	REG UWORD i;
	for (i = 0; i < CacheSize; i++)
	{
		if (lbn == Cache[i].block)
		{
			/* done means it must be complete */
			/* if complete, check io_Error as well! */
			return (!done || !Cache[i].active ||
			        (CheckIO(&(Cache[i].IOR)) &&
				 !Cache[i].IOR.io_Error));
		}
	}
	return FALSE;
d410 3
a412 3
	if (CacheBlock && lbn >= CacheBlock && lbn < CacheBlock+CacheSize)
		return TRUE;
	return FALSE;
d419 1
a419 1
***	Returns whether the dir cache is full or not. (REJ)
d424 1
a424 1
	return DirCacheHighWater >= DirCacheSize-1;
d431 1
a431 1
***	V34.2 - changes to stat gathering
d435 22
a456 22
	/* Alternate scheme to try to keep blocks streaming into memory */

	/* We have multiple buffers.  Each has it's own IOR.  As each   */
	/* block is read, IF the current file has not been Seek()ed     */
	/* backwards, the previous block (if cached) will be dumped, and*/
	/* the ior will be sent to prefetch the next block of data from */
	/* the drive.  However, we will NOT prefetch past the end of a  */
	/* file, nor will we do this on files with backward Seeks.      */
	/* Actually, we take all blocks that are lower and roll them	*/
	/* over after a hit, to handle Seek forwards.			*/

	/* If we get a cache miss, we will AbortIO any IOR's, and then  */
	/* restart all for successive blocks starting at the new	*/
	/* location.  This does NOT help switching between two files!   */
	/* Perhaps we should only reuse blocks as needed (plus any we   */
	/* AbortIO'd).  This _might_ help with the two-file problem, but*/
	/* I suspect it's not worth it. - REJ				*/

	/* Careful: with quick read stuff, we must NOT wait on a hit.	*/
	/* Also, is it safe to have LastCachedBlock change during a	*/
	/* QuickRead? Since it will never try a quickread if the FS is	*/
	/* running, it can only be a problem during a Wait.		*/
d458 3
a460 3
	/* parameters: back_seeked - boolean flag			*/
	/*	       eof - end of file lba, or -1 for non-file	*/
	/* global:     LastCachedBlock - the last block REQUESTED	*/
d463 3
a465 3
	ULONG	lbn;
	ULONG	eof;
	int	back_seeked,quick;
d467 101
a567 101
	REG UWORD i,j;

	DD(Debug0("\tb %ld, eof %ld, %ld\n",lbn,eof,back_seeked));

	/* FIX!  why do we keep this? Should only do when debugging is on? */
	/* ditto for other stats variables.  Should be a define.  - REJ */
	BlockCount++;

	for (i = 0; i < CacheSize; i++)
	{
		if (lbn == Cache[i].block)
		{
		    /* We have a cache hit! */
		    DD(Debug0("Cache hit %ld %s\n",lbn,
			     Cache[i].active ?
				(!CheckIO(&(Cache[i].IOR)) ? "(not done)" : "")
				: ""));
		    D(Debug0(Cache[i].active ?
				(!CheckIO(&(Cache[i].IOR)) ? "(" : ".")
				: "."));
		    /* now if the previous block is in the cache, drop it */
		    /* and start an IOR for the next block.		  */
		    /* Better yet, do all blocks older than the current.  */
		    /* MUST NEVER read ahead if back_seeked is true!	  */
		    /* QuickRead WILL cause new IORs to be sent!!!!	  */
		    if (eof != 0xffffffff /* not a data block */ &&
			!back_seeked && eof > LastCachedBlock)
		    {
			/* abort active requests earlier than hit */
			/* since we've never seeked back, should be great */
//			AbortCacheLessThan(lbn);

			for (j = 0; j < CacheSize; j++)
			{
			    if (Cache[j].block < lbn)
			    {
			    /* don't start if we're quick and it's not done */
				if (!quick || 
				    !Cache[j].active ||
				    CheckIO(&(Cache[j].IOR)))
				{
					DD(Debug0("Reuse %ld for b %ld\n",j,
						 LastCachedBlock+1));
					StartCacheRead(j,++LastCachedBlock);
				}
			    }
			}
		    }
		    /* QuickRead uses InCache, which checks io_Error, */
		    /* so retrys are safe.			      */
		    /* now we must wait if the block isn't ready yet  */
		    while (Cache[i].active)
		    {
			WaitIO(&(Cache[i].IOR));
			if (!Cache[i].IOR.io_Error ||
			     Cache[i].IOR.io_Error != CDERR_DMAFAILED ||
			     Cache[i].retry-- == 0)
			{
			    /* Carl never checked for errors here! */
			    /* Fix!? should we do something about errs???? */
			    DD(Debug0("Got data\n"));
			    Cache[i].active = FALSE;
			} else {
			    /* retry */
			    D(Debug0("Retry %ld lbn %ld\n",Cache[i].retry,
				     Cache[i].block));
			    StartDevIO(&(Cache[i].IOR),CD_READ,
				       Cache[i].block << BlockShift,
				       BlockSize,Cache[i].data);
			}
			D(Debug0(")"));
		    }

		    /* fix? should we remove this stats stuff? */
		    HitCount++;
		    return Cache[i].data;
		}
	}

	/* we had no cache hit.  Grab some blocks and start stuff going */
	D(Debug0("Miss: %ld",lbn));

	/* This abort code is safe with QuickRead since it NEVER Waits! */

	/* first Abort any active IOR's */
	AbortCacheLessThan(0xffffffff);		/* MAX_ULONG */

	/* now find a block to satisfy this request */
	/* for now, we'll start IORs for all blocks */
	LastCachedBlock = lbn-1;
	for (i = 0; i < CacheSize; i++)
		StartCacheRead(i,++LastCachedBlock);

	/* FIX! remove this statistics stuff!!! */
	ReadCount += BlockSize;

	/* now return when the first block is ready */
	/* we KNOW cache[0].IOR is active! */
	/* QuickRead uses InCache, which checks io_Error, so retrys are safe */
	while (Cache[0].active)
	{
d569 21
a589 21
		WaitIO(&(Cache[0].IOR));
		if (!Cache[0].IOR.io_Error ||
		     Cache[0].IOR.io_Error != CDERR_DMAFAILED ||
		     Cache[0].retry-- == 0)
		{
		    /* Carl never checked for errors here! */
		    /* Fix!? should we do something about errs???? */
		    if (Cache[0].IOR.io_Error)
			    Cache[0].block  = 0;
		    Cache[0].active = FALSE;
		} else {
		    /* retry */
		    D(Debug0("Retry %ld lbn %ld\n",Cache[0].retry,
			     Cache[0].block));
		    StartDevIO(&(Cache[0].IOR),CD_READ,
			       Cache[0].block << BlockShift,
			       BlockSize,Cache[0].data);
		}
	}
	DD(Debug0("Got first block...\n"));
	D(Debug0(".\n"));
d591 1
a591 1
	return Cache[0].data;
d595 1
a595 1
	ULONG	lbn;
d597 1
a597 1
	Debug3("\tb%lx\n",lbn);	
d599 17
a615 17
	/* FIX!  why do we keep this? Should only do when debugging is on? */
	/* ditto for other stats variables.  Should be a define.  - REJ */
	BlockCount++;

	if (CacheBlock && lbn >= CacheBlock && lbn < CacheBlock+CacheSize)
	{
		HitCount++;
		D(Debug0("rcache-H: lbn=%ld\n",lbn));
		return &Cache[(lbn-CacheBlock) << BlockShift];
	}
	ReadCount += CacheSize;
	D(Debug0("rcache-M: lbn=%ld\n",lbn));

	ReadBytes(Cache,lbn<<BlockShift,CacheSize<<BlockShift);
	CacheBlock = lbn;
	return Cache;
}
d628 1
a628 1
	ULONG lbn;
d630 2
a631 2
	REG DIREC *dr;
	REG UWORD i,prev;
d633 87
a719 87
	/* first scan the list for a match.  Scan in LRU order */
	prev = INVALID_DIR_INDEX;
	i = DirCacheFirst;

	if (i != INVALID_DIR_INDEX)
	{
	    while (1) {
		DD(Debug0("LRU index %ld, lbn=%ld\n",i,DirCacheIndex[i]));
		if (lbn == DirCacheIndex[i])
		{
			DD(Debug0("LRU hit, prev = %ld!\n",prev));
			/* move entry to front of list - don't move if first */
			if (prev != INVALID_DIR_INDEX)
			{
				DirCacheList[prev] = DirCacheList[i];
				DirCacheList[i] = DirCacheFirst;
				DirCacheFirst = i;
			}
			return (DIREC *)(&DirCache[i<<BlockShift]);
		}
		/* we must keep prev and i valid if we didn't find it! */
		if (DirCacheList[i] == INVALID_DIR_INDEX)
			break;

		/* get next entry in list */
		prev = i;
		i = DirCacheList[i];
	    }
	}

	/* failure, not cached. i is either INVALID_DIR_INDEX (nothing
	   cached), or it's the index of the least-recently-used block.  Only
	   replace the LRU block if the cache is full.
	*/

	/* this handles the i == INVALID_DIR_INDEX case! */
	if (DirCacheHighWater < DirCacheSize-1)
	{
		/* we have unused blocks to use */
		prev = i;	/* this will still be the end of the list */

		/* this is the block to load into */
		i = ++DirCacheHighWater;
	}

	/* i CANNOT be INVALID_DIR_INDEX here */
	DD(Debug0("LRU miss, prev = %ld, i = %ld, high = %ld\n",prev,i,
		 DirCacheHighWater));

	/* remove from end of list */
	if (prev != INVALID_DIR_INDEX)
		DirCacheList[prev] = INVALID_DIR_INDEX;

	/* add to head of list */
	DirCacheList[i] = DirCacheFirst;
	DirCacheFirst   = i;  /* this node will be at head of the list */

	/*
	** Now that the device driver does prefetching, we
	** read read directly to the directory cache, rather than
	** flushing the file cache.
	**
	** Previous code looped until a good block came in, but
	** the test was buggy.  This code retries until read
	** is ok.
	*/
	dr = (DIREC *)&DirCache[i<<BlockShift];
	D(Debug0("DirBlk-M: lbn=%ld\n",lbn));

	while( ReadBytes(dr,lbn<<BlockShift,BlockSize) )
		;	/* V24.4 - Must read it! */

	DirCacheIndex[i] = lbn;

	/*
	 * if there are empty entries in the dir cache, and the next block
	 * is also a directory cache block, it's nice to read them in,
	 * since you tend to have N directory blocks, then the data for
	 * those files.  This helps avoid a seek back to the directory after
	 * reading each file or two (hopefully).  Mostly it helps at
	 * startup.
	 *
	 * This is handled in dir.c, since it knows if the next block is
	 * a directory block (using DirCacheFull to know if empty slots exist).
	 */

	return dr;
d728 4
a731 4
ReadBytes(buf,offset,size)	/* Bytes, bytes, bytes */
	char *buf;
	ULONG offset;
	ULONG size;
d733 14
a746 14
	REG int err;
	REG int i;

	DD(Debug0("cd_read	: buf=%lx,lbn=%ld,size=%lx\n",buf,offset>>BlockShift,size));

	for (i = 0; i < Retry; i++)
	{
		err = DoDevIO(CD_READ,offset,size,buf);
		if (err == 0) return 0;
		ReadErrs++;
		DD(Debug0("\tE%lx.%lx.%lx.%lx\n",err,offset,size,buf));
		if (err != CDERR_DMAFAILED) break;
	}
	return err;
d755 4
a758 4
StartReadBytes(buf,offset,size)	/* Bytes, bytes, bytes */
	char *buf;
	ULONG offset;
	ULONG size;
d760 7
a766 7
	REG int err;
	REG int i;

	DD(Debug0("cd_startread	: buf=%lx,lbn=%ld,size=%lx\n",buf,offset>>BlockShift,size));

	/* Must NOT be used again unitl WaitReadBytes is called!!!!! */
	StartDevIO(&DevIOReq,CD_READ,offset,size,buf);
d775 4
a778 4
WaitReadBytes(buf,offset,size)	/* Bytes, bytes, bytes */
	char *buf;
	ULONG offset;
	ULONG size;
d780 14
a793 14
	REG int err;
	REG int i;

	for (i = 0; i < Retry; i++)
	{
		WaitIO(&DevIOReq);
		err = DevIOReq.io_Error;
		if (err == 0) return 0;
		ReadErrs++;
		DD(Debug0("\tE%lx.%lx.%lx.%lx\n",err,offset,size,buf));
		if (err != CDERR_DMAFAILED) break;
		StartDevIO(&DevIOReq,CD_READ,offset,size,buf);
	}
	return err;
d803 3
a805 3
	char *buf;
	ULONG blk;
	ULONG len;
d807 1
a807 1
	return ReadBytes(buf, blk << BlockShift, len << BlockShift);
d815 2
a816 2
***	Called when a disk change interrupt has been detected in 
***	the main dispatch loop.
d818 2
a819 2
***	Re-initializes data structures each time, but this routine
***	happens so rarely that this is not a concern.
d825 2
a826 2
	/* V34.2 moved inhibit check to main.c */
	InsertFlag = FALSE;
d828 27
a854 27
	if (InputPends) return FALSE;	/* it's busy, ignore it */
	InputPends = TRUE;

	DoDevIO(CD_CHANGESTATE,0,0,0);
	if (DevIOReq.io_Actual)		/* true when no disk */
	{
		InpEvent.ie_Class = IECLASS_DISKREMOVED;
		UnMount();
	}
	else
	{
		InpEvent.ie_Class = IECLASS_DISKINSERTED;
		Mount(FALSE);
	}
	InpEvent.ie_NextEvent = NULL;
	/* No time stamp. */

	InpPacket.dp_Link = (struct Message *) &InpReq;
	InpPacket.dp_Port = FSPort; 
	InpPacket.dp_Type = ACTION_DISK_CHANGE;

	InpReq.io_Message.mn_Node.ln_Name = (char *) &InpPacket;
	InpReq.io_Message.mn_Node.ln_Type = NT_MESSAGE;
	InpReq.io_Message.mn_ReplyPort = FSPort;
	InpReq.io_Command = IND_WRITEEVENT;	
	InpReq.io_Data = (APTR) &InpEvent;
	InpReq.io_Length = sizeof(InpEvent);
d856 1
a856 1
	SendIO(&InpReq);
d858 1
a858 1
	return TRUE;
@


1.5
log
@Added AbortCacheLessThan, cleaned up abort calls
Fixed major bug with waiting on IOR's in QuickRead
Clear Cache[x].block before AbortIO for safety.
debug changes
@
text
@d215 1
d223 2
a224 1
	Cache[0].data = MakeVector(new << BlockShift);
d232 2
a233 1
		Cache[0].data = MakeVector(new << BlockShift);
@


1.4
log
@On abort, don't wait for the packets to come back.  Also (though no
longer needed with QuickPackets around), set block to 0 before aborting.
Lots 'a debug changes
@
text
@d345 31
d474 1
a474 1
UBYTE *ReadBlock(lbn,eof,back_seeked)
d477 1
a477 1
	int	back_seeked;
d504 2
a505 2
		    if (eof == 0xffffffff /* not a data block */ ||
			(!back_seeked && eof > LastCachedBlock))
d507 4
d515 9
a523 3
				DD(Debug0("Reuse %ld for b %ld\n",j,
					 LastCachedBlock+1));
				StartCacheRead(j,++LastCachedBlock);
d559 1
a559 1
	D(Debug0("Cache miss on %ld",lbn));
d564 1
a564 15
	for (i = 0; i < CacheSize; i++)
	{
		if (Cache[i].active)
		{
		    if (!CheckIO(&(Cache[i].IOR)))
		    {
/* we can't be waiting, can we? that would mean cdtv.device was broken! FIX! */
Cache[i].block = 0;
			AbortIO(&(Cache[i].IOR)); /* must wait before reuse! */
		    } else {
			WaitIO(&(Cache[i].IOR));  /* was already finished    */
			Cache[i].active = FALSE;
		    }
		}
	}
@


1.3
log
@MAJOR changes
Use LRU scheme for directories (big win)
use N separate cache buffers, and use N IOR's, asynch, rolling
forward.
@
text
@d332 3
d336 4
a339 3
				WaitIO(&(Cache[i].IOR));
				Cache[i].active = FALSE;
				Cache[i].block = 0;
d368 2
d461 1
a461 1
		    D(Debug0("Cache hit %ld %s\n",lbn,
d465 3
d508 1
d518 1
a518 1
	D(Debug0("Cache miss on %ld\n",lbn));
d529 2
d574 1
@


1.2
log
@Much changes.  Fold some functions onto each other.  Optimize directory
cache for Jerry's new 4510 stuff (don't blow file cache).
@
text
@d19 7
d27 1
d136 5
a140 1
	DevChgReq = DevIOReq;		/* copy struct */
d161 21
d183 1
d186 6
d211 36
d259 1
d263 80
d350 40
a389 1
	REG int i;
d391 9
a399 3
	for (i = 0; i < DirCacheSize; i++) DirCacheIndex[i] = 0;
	DirCacheBlock = 0;
	CacheBlock = 0;
d409 157
d571 2
a580 1

d588 1
d595 4
a598 1
***********************************************************************/
d603 5
a607 1
	REG int i;
d609 1
a609 5
	/*
	** It is a shame to ever leave empty slots in this cache.
	** Perhaps the first read could fill the cache.
	*/
	for (i = 0; i < DirCacheSize; i++)
d611 2
d615 8
a622 1
			D(Debug0("DirBlk-H: lbn=%ld\n",lbn));
d625 23
d650 12
d671 1
a671 1
	dr = (DIREC *)&DirCache[DirCacheBlock<<BlockShift];
d677 13
a689 2
	DirCacheIndex[DirCacheBlock++] = lbn;
	if (DirCacheBlock >= DirCacheSize) DirCacheBlock = 0; /* wrap */
d708 1
a708 1
	D(Debug0("cd_read	: buf=%lx,lbn=%ld,size=%lx\n",buf,offset>>BlockShift,size));
d715 47
a761 1
		Debug1("\tE%lx.%lx.%lx.%lx\n",err,offset,size,buf);
d763 1
d793 1
@


1.1
log
@Initial revision
@
text
@d19 2
d109 2
d115 11
a125 1
	DevIOReq.io_Message.mn_ReplyPort = FSPort;
d217 1
d222 1
d224 1
a224 1
	ReadCD(Cache,lbn,CacheSize);
d229 1
d238 1
a238 1
	DIREC *dr;
d241 4
d249 1
d254 11
a264 6
	do
	{
		dr = (DIREC *)ReadBlock(lbn);
	}
	while (!dr);		/* V24.4 - Must read it! */
	/*	if (!dr) return NULL;*/
d266 2
a267 1
	CopyMem(dr,&DirCache[DirCacheBlock<<BlockShift],BlockSize);
a269 1

a274 12
/***********************************************************************
***
***  ReadCD
***
***********************************************************************/
ReadCD(buf,blk,len)
	char *buf;
	ULONG blk;
	ULONG len;
{
	return ReadBytes(buf, blk << BlockShift, len << BlockShift);
}
d281 1
a281 1
ReadBytes(buf,offset,size)
d289 1
a289 1
	size += 8; /* V23.1 - compensate for DMA H/W bug! */
d301 15
@
