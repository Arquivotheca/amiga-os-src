head     1.3;
branch   ;
access   ;
symbols  ;
locks    jerryh:1.3; strict;
comment  @ * @;


1.3
date     93.07.29.13.29.24;  author jerryh;  state Exp;
branches ;
next     1.2;

1.2
date     93.07.28.17.09.34;  author jerryh;  state Exp;
branches ;
next     1.1;

1.1
date     93.07.26.12.59.18;  author jerryh;  state Exp;
branches ;
next     ;


desc
@Player program.
@


1.3
log
@Somewhat fixed bug with enabling one track while selected.
Fixed memory free problem.
Looks for TOP and LEFT in tooltypes.
@
text
@
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <exec/types.h>
#include <exec/memory.h>
#include <dos/dos.h>
#include <dos/rdargs.h>
#include <workbench/startup.h>
#include <intuition/intuition.h>
#include <intuition/gadgetclass.h>
#include <libraries/dos.h>
#include <libraries/gadtools.h>
#include <graphics/gfxmacros.h>
#include <devices/timer.h>
#include <cdgs:include/internal/playerlibrary.h>

#include <clib/alib_protos.h>
#include <clib/exec_protos.h>
#include <clib/dos_protos.h>
#include <clib/intuition_protos.h>
#include <clib/graphics_protos.h>
#include <clib/icon_protos.h>
#include <cdgs:include/internal/player_protos.h>

#include <pragmas/exec_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/icon_pragmas.h>
#include <cdgs:include/internal/player_pragmas.h>

#include "player_rev.h"

#define SysBase (*((struct ExecBase **)4))

extern struct Image FREVI1;
extern struct Image FREV_SI1;
extern struct Image PlayPauseI1;
extern struct Image PlayPause_PlayI1;
extern struct Image PlayPause_PauseI1;
extern struct Image FFWDI1;
extern struct Image FFWD_SI1;
extern struct Image StopI1;
extern struct Image Stop_SI1;
extern struct Image LoopI1;
extern struct Image Loop_SI1;
extern struct Image IntroI1;
extern struct Image Intro_SI1;
extern struct Image TimeMode0I1;
extern struct Image TimeMode1I1;
extern struct Image TimeMode2I1;
extern struct Image TimeMode3I1;


struct Library *DOSBase;
struct Library *IntuitionBase;
struct Library *GfxBase;
struct Library *PlayerBase;
struct Library *IconBase;

#define TEMPLATE      "TOP/N,LEFT/N"
#define OPT_TOP       0
#define OPT_LEFT      1
#define OPT_COUNT     2

#define NUMTRACKS       40
#define BIGGADGETS      NUMTRACKS
#define GID_FREV        NUMTRACKS
#define GID_PLAYPAUSE   NUMTRACKS + 1
#define GID_FFWD        NUMTRACKS + 2
#define GID_STOP        NUMTRACKS + 3
#define GID_LOOPMODE    NUMTRACKS + 4
#define GID_INTROMODE   NUMTRACKS + 5
#define GID_TIMEMODE    NUMTRACKS + 6

#define MATRIXLEFT      155
#define MATRIXTOP       17

#define BIGBUTTONSIZE   26
#define MODEBUTTONSIZE  43
#define BIGBUTTONGAP    5

enum { OPT_LOOP, OPT_INTRO, OPT_TIME };

BYTE NextTimeMode[] = { 1, 3, 0, 2 };

struct Image *IconArray[][4] = {

    { &FREVI1,      &FREV_SI1 },
    { &PlayPauseI1, &PlayPause_PlayI1, &PlayPause_PauseI1 },
    { &FFWDI1,      &FFWD_SI1 },
    { &StopI1,      &Stop_SI1 },
    { &LoopI1,      &Loop_SI1 },
    { &IntroI1,     &Intro_SI1 },
    { &TimeMode0I1, &TimeMode1I1,      &TimeMode3I1,      &TimeMode2I1 }
    };


char TrackText[] = "01020304050607080910111213141516171819202122232425262728293031323334353637383940" VERSTAG;

struct TagItem  WinTags[] = {

    {WA_Title,(ULONG)"CD Audio Player"},
    {WA_CustomScreen,NULL},
    {WA_Top,0},
    {WA_Left,0},
    {WA_Height,MATRIXTOP+105},
    {WA_Width,MATRIXLEFT+245},
    {WA_Gadgets,NULL},
    {WA_Flags,WFLG_CLOSEGADGET|WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_SMART_REFRESH\
             |WFLG_ACTIVATE|WFLG_RMBTRAP|WFLG_NOCAREREFRESH},

    {TAG_DONE,0}
    };



struct Window        *window;
struct MsgPort       *IPort;
struct MsgPort       *TPort;
struct timerequest   *TReq;
struct Gadget        *BigGadgets, *Gad_FREV, *Gad_PLAYPAUSE, *Gad_FFWD, *Gad_STOP;
struct Gadget        *Gad_LOOPMODE, *Gad_INTROMODE, *Gad_TIMEMODE;
struct PlayList      *PlayList;
struct PlayerState    PlayerState;
struct PlayerOptions  PlayerOptions;

int                   AudioDisk = 0, ColonLit = 1, MinusLit = 0;
int                   Selecting, Selected, Playing, Paused, CurrentIndex, HighlightedIndex;
int                   LoopMode, IntroMode, TimeMode, DisplayTracks;


#define WIN_Title   WinTags[0].ti_Data
#define WIN_Screen  WinTags[1].ti_Data
#define WIN_Top     WinTags[2].ti_Data
#define WIN_Left    WinTags[3].ti_Data
#define WIN_Height  WinTags[4].ti_Data
#define WIN_Width   WinTags[5].ti_Data
#define WIN_Gadgets WinTags[6].ti_Data




ULONG val(char *s) {

ULONG v;
char  c;

    v = 0;

    for (; *s; s++) {

        c = *s;

        if ((c>='0')&&(c<='9')) c-='0';
        v=v*10+c;
        }

    return(v);
    }




void StripIntuiMessages(struct MsgPort *mp) {

struct IntuiMessage *msg;
struct Node         *succ;

    msg = (struct IntuiMessage *)mp->mp_MsgList.lh_Head;

    while (succ = msg->ExecMessage.mn_Node.ln_Succ) {

        if (msg->IDCMPWindow == window) {

            Remove(msg);
            ReplyMsg(msg);
            }
        
        msg = (struct IntuiMessage *)succ;
        }
    }



struct Gadget *MakeGadget(WORD LeftEdge, WORD TopEdge, struct Image *Image, UWORD ID) {

struct Gadget *Gad;

    if (Gad = (struct Gadget *)AllocMem(sizeof(struct Gadget), MEMF_PUBLIC|MEMF_CLEAR)) {

        Gad->LeftEdge = LeftEdge;
        Gad->TopEdge  = TopEdge;
        Gad->Width    = Image->Width;
        Gad->Height   = Image->Height;

        Gad->Flags      = GFLG_GADGHNONE|GFLG_GADGIMAGE;
        Gad->Activation = GACT_RELVERIFY|GACT_IMMEDIATE;
        Gad->GadgetType = GTYP_BOOLGADGET;
        Gad->GadgetID   = ID;

        Gad->GadgetRender = Image;

        return (Gad);
        }

    return (NULL);
    }


struct Gadget *MakeTrackGadget(WORD LeftEdge, WORD TopEdge, WORD Width, WORD Height, UWORD ID) {

struct Gadget *Gad;
struct Border *Border;
UWORD         *Pairs;

    if (Gad = (struct Gadget *)AllocMem(sizeof(struct Gadget), MEMF_PUBLIC|MEMF_CLEAR)) {

        Gad->LeftEdge = LeftEdge;
        Gad->TopEdge  = TopEdge;
        Gad->Width    = Width;
        Gad->Height   = Height;

        Gad->Flags      = GFLG_GADGHNONE;
        Gad->Activation = GACT_RELVERIFY|GACT_IMMEDIATE;
        Gad->GadgetType = GTYP_BOOLGADGET;
        Gad->GadgetID   = ID;

        if (Gad->GadgetRender = Border = AllocMem(sizeof(struct Border), MEMF_PUBLIC|MEMF_CLEAR)) {

            Border->FrontPen = 2;
            Border->DrawMode = JAM1;
            Border->Count    = 3;

            if (Border->XY = Pairs = AllocMem(4*Border->Count, MEMF_PUBLIC)) {

                Pairs[0] = 0;     Pairs[1] = Height;
                Pairs[2] = 0;     Pairs[3] = 0;
                Pairs[4] = Width; Pairs[5] = 0;
                }

            if (Border->NextBorder = AllocMem(sizeof(struct Border), MEMF_PUBLIC|MEMF_CLEAR)) {

                Border = Border->NextBorder;

                Border->FrontPen = 1;
                Border->DrawMode = JAM1;
                Border->Count    = 3;

                if (Border->XY = Pairs = AllocMem(4*Border->Count, MEMF_PUBLIC)) {

                    Pairs[0] = Width; Pairs[1] = 0;
                    Pairs[2] = Width; Pairs[3] = Height;
                    Pairs[4] = 0;     Pairs[5] = Height;
                    }
                }
            }

        return (Gad);
        }

    return (NULL);
    }


void DeleteGadget(struct Gadget *Gad) {

struct Border *Border, *TempBorder;

    if (!(Gad->Flags & GFLG_GADGIMAGE)) {

        if (Border = (struct Border *)Gad->GadgetRender) {

            while (Border) {

                TempBorder = Border;
                Border     = Border->NextBorder;
            
                if (TempBorder->XY) {

                    FreeMem((char *)(TempBorder->XY), TempBorder->Count*4);
                    }

                FreeMem((char *)TempBorder, sizeof(struct Border));
                }
            }
        }

    FreeMem((char *)Gad, sizeof(struct Gadget));
    }



void SelectIcon(struct Gadget *Gad, int Icon) {

    Gad->GadgetRender = IconArray[Gad->GadgetID-BIGGADGETS][Icon];

    RefreshGList(Gad, window, NULL, 1);
    }



void DisplayButton(struct Gadget *Gad, int Flag, char *DispText, int Len) {

    if (Flag && Selecting) { SetAPen(window->RPort, 3); SetBPen(window->RPort, 3); }
    else                   { SetAPen(window->RPort, 0); SetBPen(window->RPort, 0); }

    RectFill(window->RPort, Gad->LeftEdge + 1,
                            Gad->TopEdge  + 1,
                            Gad->LeftEdge + Gad->Width  - 1,
                            Gad->TopEdge  + Gad->Height - 1);
    if (DispText) {

        SetAPen(window->RPort, 1);
    
        Move(window->RPort, Gad->LeftEdge + 5, Gad->TopEdge + 11);
        if (DispText) Text(window->RPort, DispText, Len);
        }        
    }



void DisplayTrackButtons(int NumButtons) {

struct Gadget **GadP;
int             i;

    for (GadP=(struct Gadget **)&WIN_Gadgets,i=0; i<NumButtons; GadP=(struct Gadget **)&(*GadP)->NextGadget,i++)

        DisplayButton(*GadP, PlayList->Entry[(*GadP)->GadgetID] & PLEF_ENABLE, &TrackText[i*2], 2);
    }



void EnableButton(struct Gadget *Gad, int Flag, char *DispText, int Len) {

    while (!ModifyPlayList(1)) Delay(1);

    if (Flag) PlayList->Entry[Gad->GadgetID] |= PLEF_ENABLE;
    else      PlayList->Entry[Gad->GadgetID] &= PLEF_TRACK;

    ModifyPlayList(0);

    DisplayButton(Gad, Flag, DispText, Len);
    }



void EnableTrackButtons(int NumButtons, int Flag, int DispText) {

struct Gadget **GadP;
int             i;

    for (GadP=(struct Gadget **)&WIN_Gadgets,i=0; i<NumButtons; GadP=(struct Gadget **)&(*GadP)->NextGadget,i++)

        if (DispText) EnableButton(*GadP, Flag, &TrackText[i*2], 2);
        else          EnableButton(*GadP, Flag, NULL, 0);
    }





void HighlightButton(int Track, int Flag) {

    if (Track <= NUMTRACKS) {

        if (Flag) SetAPen(window->RPort, 1);
        else {

            if   (PlayList->Entry[Track] & PLEF_ENABLE) SetAPen(window->RPort, 3);
            else                                        SetAPen(window->RPort, 0);
            }

        Move(window->RPort, MATRIXLEFT + 2 + (Track % 8) * 30,      MATRIXTOP + 2 + (Track / 8) * 20);
        Draw(window->RPort, MATRIXLEFT + 2 + (Track % 8) * 30 + 21, MATRIXTOP + 2 + (Track / 8) * 20);
        Draw(window->RPort, MATRIXLEFT + 2 + (Track % 8) * 30 + 21, MATRIXTOP + 2 + (Track / 8) * 20 + 13);
        Draw(window->RPort, MATRIXLEFT + 2 + (Track % 8) * 30,      MATRIXTOP + 2 + (Track / 8) * 20 + 13);
        Draw(window->RPort, MATRIXLEFT + 2 + (Track % 8) * 30,      MATRIXTOP + 2 + (Track / 8) * 20);
        }
    }



void InvertOption(int Option) {

struct PlayerOptions Opts;
int                  i;

    if (!GetOptions(&Opts)) {

        for (i=0; i!=4; i++) {

            if (i != Option) ((BYTE *)&Opts)[i] = -1;
            else {

                if (Option != OPT_TIME) ((BYTE *)&Opts)[i] = !((BYTE *)&Opts)[i];
                else Opts.TimeMode = NextTimeMode[Opts.TimeMode];
                }
            }

        SetOptions(&Opts);
        GetOptions(&PlayerOptions);
        }
    }


char LitSegments[4][7];

char SegmentArray[11][7] = {

    { 1, 1, 1, 1, 1, 1, 0 },
    { 0, 1, 1, 0, 0, 0, 0 },
    { 1, 1, 0, 1, 1, 0, 1 },
    { 1, 1, 1, 1, 0, 0, 1 },
    { 0, 1, 1, 0, 0, 1, 1 },
    { 1, 0, 1, 1, 0, 1, 1 },
    { 1, 0, 1, 1, 1, 1, 1 },
    { 1, 1, 1, 0, 0, 0, 0 },
    { 1, 1, 1, 1, 1, 1, 1 },
    { 1, 1, 1, 0, 0, 1, 1 },
    { 0, 0, 0, 0, 0, 0, 0 }
    };


char DigitPos[] = { 31, 56, 91, 116 };

char SegPos[7][4] = {

    {  4,  0, 10,  2 },
    { 12,  2, 14, 14 },
    { 12, 16, 14, 28 },
    {  4, 28, 10, 30 },
    {  0, 16,  2, 28 },
    {  0,  2,  2, 14 },
    {  4, 14, 10, 16 }
    };



void DisplaySegment(int DigitNum, int Segment, int Light) {

    if      ( LitSegments[DigitNum][Segment] && !Light) { SetAPen(window->RPort, 0); LitSegments[DigitNum][Segment] = 0; }
    else if (!LitSegments[DigitNum][Segment] &&  Light) { SetAPen(window->RPort, 1); LitSegments[DigitNum][Segment] = 1; }
    else return;

    BNDRYOFF(window);

    RectFill(window->RPort, SegPos[Segment][0] + DigitPos[DigitNum],
                            SegPos[Segment][1] + 20,
                            SegPos[Segment][2] + DigitPos[DigitNum],
                            SegPos[Segment][3] + 20);
    }




void DisplayDigit(int DigitNum, int Digit) {

int i;

    for (i=0; i!=7; i++) DisplaySegment(DigitNum, i, SegmentArray[Digit][i]);
    }





void DisplayTime(void) {

    if (Selected && ((TimeMode == 1) || (TimeMode == 3))) {

        if (!MinusLit) {

            MinusLit = 1;
            SetAPen(window->RPort, 1);
            RectFill(window->RPort, 20, 34, 26, 36);
            }
        }

    else {

        if (MinusLit) {

            MinusLit = 0;
            SetAPen(window->RPort, 0);
            RectFill(window->RPort, 20, 34, 26, 36);
            }
        }


    if (AudioDisk) {

        if (!(PlayerState.Minute/10)) DisplayDigit(0, 10);
        else                          DisplayDigit(0, PlayerState.Minute/10);

        DisplayDigit(1, PlayerState.Minute%10);

        if (!ColonLit) {

            ColonLit = 1;
            SetAPen(window->RPort, 1);
            RectFill(window->RPort, 80, 27, 82, 29);
            RectFill(window->RPort, 80, 42, 82, 44);
            }

        DisplayDigit(2, PlayerState.Second/10);
        DisplayDigit(3, PlayerState.Second%10);
        }

    else {

        DisplayDigit(0, 10);
        DisplayDigit(1, 10);

        if (ColonLit) {

            ColonLit = 0;
            SetAPen(window->RPort, 0);
            RectFill(window->RPort, 80, 27, 82, 29);
            RectFill(window->RPort, 80, 42, 82, 44);
            }

        DisplayDigit(2, 10);
        DisplayDigit(3, 10);
        }
    }



enum { ALLCLR, SOMEENA, ALLENA };


int TracksSelected(void) {

int i, SomeENA = 0, AllENA = 1;

    for (i=0; i<PlayerState.Tracks; i++) {

        if (PlayList->Entry[i] & PLEF_ENABLE) SomeENA = 1;
        else                                  AllENA  = 0;
        }

    return(SomeENA + AllENA);
    }




void SendTimerRequest(void) {

    TReq->tr_node.io_Command = TR_ADDREQUEST;
    TReq->tr_time.tv_secs    = 0;
    TReq->tr_time.tv_micro   = 200000;
    SendIO(TReq);
    }




void DoPlayer(int TOP, int LEFT) {

ULONG               Event;
int                 exit_code = 0;
int                 i, j, k;

struct Screen        *Screen;
struct IntuiMessage  *imsg;
struct Gadget       **GadP, *Gad, *TempGad, *LastDownGadget;

    PlayList = ObtainPlayList();

    memset(&LitSegments[0][0], 1, sizeof(LitSegments));

    Screen=LockPubScreen(NULL);
    UnlockPubScreen(NULL, Screen);

    WIN_Screen = (ULONG)Screen;
    WIN_Top    = TOP;
    WIN_Left   = LEFT;

    GadP = (struct Gadget **)&WIN_Gadgets;

    for (j=MATRIXTOP,k=0; j!=MATRIXTOP+100; j+=20) {

        for (i=MATRIXLEFT; i!=MATRIXLEFT+240; i+=30) {

           *GadP = MakeTrackGadget(i, j, 25, 17, k++);
            GadP = (struct Gadget **)&(*GadP)->NextGadget;
            }
        }

    *GadP = BigGadgets = Gad_FREV = MakeGadget(8,                    88, &FREVI1,      GID_FREV);

     GadP = (struct Gadget **)&(*GadP)->NextGadget;
    *GadP = Gad_PLAYPAUSE = MakeGadget(8+BIGBUTTONSIZE+BIGBUTTONGAP, 88, &PlayPauseI1, GID_PLAYPAUSE);

     GadP = (struct Gadget **)&(*GadP)->NextGadget;
    *GadP = Gad_FFWD = MakeGadget(2+BIGBUTTONSIZE*3+BIGBUTTONGAP*2,  88, &FFWDI1,      GID_FFWD);

     GadP = (struct Gadget **)&(*GadP)->NextGadget;
    *GadP = Gad_STOP = MakeGadget(2+BIGBUTTONSIZE*4+BIGBUTTONGAP*3,  88, &StopI1,      GID_STOP);


     GadP = (struct Gadget **)&(*GadP)->NextGadget;
    *GadP = Gad_LOOPMODE  = MakeGadget(8,                                 57, &LoopI1,  GID_LOOPMODE);

     GadP = (struct Gadget **)&(*GadP)->NextGadget;
    *GadP = Gad_INTROMODE = MakeGadget(8+MODEBUTTONSIZE+BIGBUTTONGAP,     57, &IntroI1, GID_INTROMODE);

     GadP = (struct Gadget **)&(*GadP)->NextGadget;
    *GadP = Gad_TIMEMODE  = MakeGadget(8+MODEBUTTONSIZE*2+BIGBUTTONGAP*2, 57, &IntroI1, GID_TIMEMODE);

    if (window = OpenWindowTagList(NULL, WinTags)) {

        window->UserPort = IPort;

        ModifyIDCMP(window, IDCMP_GADGETUP|IDCMP_MOUSEBUTTONS|IDCMP_GADGETDOWN|IDCMP_CLOSEWINDOW);

        SetAPen(window->RPort, 2);
        Move(window->RPort, 8, 54);
        Draw(window->RPort, 8, MATRIXTOP);
        Draw(window->RPort, 147, MATRIXTOP);
        SetAPen(window->RPort, 1);
        Draw(window->RPort, 147, 54);
        Draw(window->RPort, 8, 54);

        DisplayTime();

        GetPlayerState(&PlayerState);
        AudioDisk = PlayerState.AudioDisk == 1;

        if   (Paused  = PlayerState.PlayState == PLS_PAUSED)  SelectIcon(Gad_PLAYPAUSE, 2);
        if   (Playing = PlayerState.PlayState >= PLS_PLAYING) SelectIcon(Gad_PLAYPAUSE, 1);
        else                                                  SelectIcon(Gad_STOP,      1);

        Selecting = Selected = PlayerState.PlayState >= PLS_SELECTED;

        GetOptions(&PlayerOptions);

        if (LoopMode  = PlayerOptions.Loop)  SelectIcon(Gad_LOOPMODE,  1);
        if (IntroMode = PlayerOptions.Intro) SelectIcon(Gad_INTROMODE, 1);

        SelectIcon(Gad_TIMEMODE, TimeMode = PlayerOptions.TimeMode);

        if ((DisplayTracks = PlayerState.Tracks) > 40) DisplayTracks = 40;

        if (AudioDisk) EnableTrackButtons(DisplayTracks, 1, 1);

        SendTimerRequest();

//***** Event Loop **************************************************************************************

        while (!exit_code) {

            Event = Wait((1L << TPort->mp_SigBit) | (1L << IPort->mp_SigBit));

//********* Timer Event (update player states) **********************************************************

            if (Event & (1L << TPort->mp_SigBit)) {

                GetMsg(TPort);
                SendTimerRequest();                    

                GetPlayerState(&PlayerState);
                GetOptions(&PlayerOptions);

                if ((PlayerState.AudioDisk == 1) != AudioDisk) {

                    AudioDisk = PlayerState.AudioDisk == 1;

                    if ((DisplayTracks = PlayerState.Tracks) > 40) DisplayTracks = 40;

                    if (AudioDisk) {

                        Selecting = 0;
                        EnableTrackButtons(DisplayTracks, 1, 1);
                        }

                    else EnableTrackButtons(NUMTRACKS, 0, 0);
                    }

                if ((PlayerState.PlayState == PLS_PAUSED) != Paused) {

                    if   (Paused = PlayerState.PlayState == PLS_PAUSED) SelectIcon(Gad_PLAYPAUSE, 2);
                    else                                                SelectIcon(Gad_PLAYPAUSE, 1);
                    }

                if ((PlayerState.PlayState >= PLS_PLAYING) != Playing) {

                    if (Playing = PlayerState.PlayState >= PLS_PLAYING) {

                        SelectIcon(Gad_PLAYPAUSE, 1);
                        SelectIcon(Gad_STOP,      0);
                        }

                    else {

                        SelectIcon(Gad_PLAYPAUSE, 0);
                        SelectIcon(Gad_STOP,      1);
                        }
                    }

                if ((PlayerState.PlayState >= PLS_SELECTED) != Selected) {

                    if (Selected = PlayerState.PlayState >= PLS_SELECTED) {

                        Selecting = 1;
                        DisplayTrackButtons(DisplayTracks);
                        HighlightButton(HighlightedIndex = CurrentIndex = PlayerState.ListIndex, 1);
                        }

                    else if (Selecting) {

                        HighlightButton(HighlightedIndex, 0);
                        Selecting = 0;
                        }
                    }

                if (CurrentIndex != PlayerState.ListIndex) {

                    CurrentIndex = PlayerState.ListIndex;

                    if (Selected) {

                        HighlightButton(HighlightedIndex, 0);
                        HighlightButton(HighlightedIndex = CurrentIndex, 1);
                        }
                    }

                if (LoopMode != PlayerOptions.Loop) {

                    LoopMode = PlayerOptions.Loop;
                    SelectIcon(Gad_LOOPMODE, LoopMode);
                    }

                if (IntroMode != PlayerOptions.Intro) {

                    if ((IntroMode = PlayerOptions.Intro) && !Playing) {

                        SubmitKeyStroke(PKS_PLAYPAUSE|PKSF_PRESS);
                        SubmitKeyStroke(PKS_PLAYPAUSE|PKSF_RELEASE);
                        }

                    SelectIcon(Gad_INTROMODE, IntroMode);
                    }

                if (TimeMode != PlayerOptions.TimeMode) {

                    SelectIcon(Gad_TIMEMODE, TimeMode = PlayerOptions.TimeMode);
                    }

                DisplayTime();
                }

//********* Button Event ********************************************************************************

            if (Event & (1L << IPort->mp_SigBit)) {

                if (imsg=(struct IntuiMessage *)GetMsg(IPort)) {

                    if (imsg->IDCMPWindow == window) {

                        if (imsg->Class & IDCMP_CLOSEWINDOW) exit_code = 1;

                        else {

                            Gad = (struct Gadget *)imsg->IAddress;

                            if (imsg->Class & IDCMP_GADGETDOWN) {

                                LastDownGadget = Gad;

                                if (Gad->GadgetID < DisplayTracks) {

                                    if (Playing) {

                                        SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
                                        SubmitKeyStroke(PKS_STOP|PKSF_RELEASE);
                                        }

                                    if (!Selecting && !Selected && (TracksSelected() == ALLENA)) {

                                        Selecting = 1;
                                        EnableTrackButtons(DisplayTracks, 0, 1);
                                        }

                                    else Selecting = 1;

                                    EnableButton(Gad, !(PlayList->Entry[Gad->GadgetID] & PLEF_ENABLE),
                                                      &TrackText[Gad->GadgetID*2], 2);

                                    if (Selected && TracksSelected() == ALLENA) EnableTrackButtons(DisplayTracks, 0, 1);

                                    if (TracksSelected() == ALLCLR) {

                                        Selecting = 0;
                                        EnableTrackButtons(DisplayTracks, 1, 1);
                                        }

                                    SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
                                    SubmitKeyStroke(PKS_STOP|PKSF_RELEASE);
                                    }

                                else if (Gad->GadgetID == GID_PLAYPAUSE) SubmitKeyStroke(PKS_PLAYPAUSE|PKSF_PRESS);
                                else if (Gad->GadgetID == GID_STOP) {

                                        if (Playing || (TracksSelected() == ALLENA)) {

                                            SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
                                            SubmitKeyStroke(PKS_STOP|PKSF_RELEASE);
                                            }

                                        if (!Selected || (TracksSelected() == ALLENA)) {

                                            Selecting = 0;
                                            EnableTrackButtons(DisplayTracks, 1, 1);
                                            }

                                        SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
                                        }

                                else if (Gad->GadgetID == GID_FREV) {

                                    if (AudioDisk) {

                                        SelectIcon(Gad, 1);
                                        SubmitKeyStroke(PKS_REVERSE|PKSF_PRESS);
                                        }
                                    }

                                else if (Gad->GadgetID == GID_FFWD) {

                                    if (AudioDisk) {

                                        SelectIcon(Gad, 1);
                                        SubmitKeyStroke(PKS_FORWARD|PKSF_PRESS);
                                        }
                                    }

                                else if (Gad->GadgetID == GID_LOOPMODE)  InvertOption(OPT_LOOP);
                                else if (Gad->GadgetID == GID_INTROMODE) InvertOption(OPT_INTRO);
                                else if (Gad->GadgetID == GID_TIMEMODE)  InvertOption(OPT_TIME);
                                }

                            else if (imsg->Class & IDCMP_GADGETUP
                                 || ((imsg->Class & IDCMP_MOUSEBUTTONS) && (imsg->Code == SELECTUP))) {

                                if (imsg->Class & IDCMP_MOUSEBUTTONS) Gad = LastDownGadget;

                                if      (Gad->GadgetID == GID_PLAYPAUSE) SubmitKeyStroke(PKS_PLAYPAUSE|PKSF_RELEASE);
                                else if (Gad->GadgetID == GID_STOP)      SubmitKeyStroke(PKS_STOP|PKSF_RELEASE);
                                else if (Gad->GadgetID == GID_FREV) {

                                    if (AudioDisk) {

                                        SelectIcon(Gad, 0);
                                        SubmitKeyStroke(PKS_REVERSE|PKSF_RELEASE);
                                        }
                                    }

                                else if (Gad->GadgetID == GID_FFWD) {

                                    if (AudioDisk) {

                                        SelectIcon(Gad, 0);
                                        SubmitKeyStroke(PKS_FORWARD|PKSF_RELEASE);
                                        }
                                    }
                                }
                            }

                        ReplyMsg((struct Message *)imsg);
                        }

                    else StripIntuiMessages(IPort);
                    }
                }
            }

//***** Close Down **************************************************************************************

        SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
        SubmitKeyStroke(PKS_STOP|PKSF_RELEASE);

        Delay(5);

        while (!ModifyPlayList(1)) Delay(1);
        ModifyPlayList(0);

        WaitPort(TPort);
        while(GetMsg(TPort));

        window->UserPort = NULL;
        StripIntuiMessages(IPort);
        CloseWindow(window);
        }

    else printf("Could not open window\n");

    Gad = (struct Gadget *)WIN_Gadgets;

    while (Gad) {

        TempGad = Gad;
        Gad     = Gad->NextGadget;

        DeleteGadget(TempGad);
        }
    }






int main (int argc, char **argv) {

struct RDArgs     *rdargs;
char              *opts[OPT_COUNT];
struct WBStartup  *argmsg;
struct WBArg      *wb_arg;
struct DiskObject *dobj;
int                TOP = 0, LEFT = 0;
char              *s;

    memset(opts, 0, sizeof(opts));

    if (IconBase = OpenLibrary("icon.library", 0)) {

        if (IPort = CreateMsgPort()) {

            if (DOSBase = OpenLibrary("dos.library", 0)) {

                if (IntuitionBase = OpenLibrary("intuition.library", 0)) {

                    if (GfxBase = OpenLibrary("graphics.library", 0)) {

                        if (PlayerBase = OpenLibrary("player.library", 0)) {

                            if (TPort = CreateMsgPort()) {

                                if (TReq = CreateIORequest(TPort, sizeof(struct timerequest))) {

                                    if (!OpenDevice("timer.device", 0, TReq, UNIT_MICROHZ)) {

                                        if (argc) {

                                            if (rdargs = ReadArgs(TEMPLATE, (LONG *)opts, NULL)) {

                                                if (opts[OPT_TOP])  TOP  = *(ULONG *)opts[OPT_TOP];
                                                if (opts[OPT_LEFT]) LEFT = *(ULONG *)opts[OPT_LEFT];

                                                FreeArgs(rdargs);
                                                }
                                            }

                                        else {

                                            argmsg = (struct WBStartup *)argv;
                                            wb_arg = argmsg->sm_ArgList;

                                            if ((*wb_arg->wa_Name) && (dobj = GetDiskObject(wb_arg->wa_Name))) {

                                                if (s = (char *)FindToolType(dobj->do_ToolTypes, "TOP"))  TOP  = val(s);
                                                if (s = (char *)FindToolType(dobj->do_ToolTypes, "LEFT")) LEFT = val(s);

                                                FreeDiskObject(dobj);
                                                }
                                            }

                                        DoPlayer(TOP, LEFT);
                                        CloseDevice(TReq);
                                        }

                                    DeleteIORequest(TReq);
                                    }

                                DeleteMsgPort(TPort);
                                }

                            CloseLibrary(PlayerBase);
                            }

                        CloseLibrary(GfxBase);
                        }

                    CloseLibrary(IntuitionBase);
                    }

                CloseLibrary(DOSBase);
                }

            DeleteMsgPort(IPort);
            }

        CloseLibrary(IconBase);
        }

    exit(0);
    }


@


1.2
log
@Reworked everything to use real gadget icons
and made player behave more like the AmigaCD audio player.
@
text
@d9 1
d23 1
d30 1
d60 1
d145 21
d288 1
d290 1
a290 2
        FreeMem((char *)Gad, sizeof(struct Gadget));
        }
d562 1
a562 1
void DoPlayer(void) {
a563 2
struct RDArgs      *rdargs;
char               *opts[OPT_COUNT];
a573 1
    memset(opts, 0, sizeof(opts));
d576 2
a577 1
    if (rdargs = ReadArgs(TEMPLATE, (LONG *)opts, NULL)) {
d579 41
a619 2
        Screen=LockPubScreen(NULL);
        UnlockPubScreen(NULL, Screen);
d621 9
a629 42
        WIN_Screen = (ULONG)Screen;

        if (opts[OPT_TOP])  WIN_Top  = *(ULONG *)opts[OPT_TOP];
        if (opts[OPT_LEFT]) WIN_Left = *(ULONG *)opts[OPT_LEFT];

        GadP = (struct Gadget **)&WIN_Gadgets;

        for (j=MATRIXTOP,k=0; j!=MATRIXTOP+100; j+=20) {

            for (i=MATRIXLEFT; i!=MATRIXLEFT+240; i+=30) {

               *GadP = MakeTrackGadget(i, j, 25, 17, k++);
                GadP = (struct Gadget **)&(*GadP)->NextGadget;
                }
            }

        *GadP = BigGadgets = Gad_FREV = MakeGadget(8,                    88, &FREVI1,      GID_FREV);

         GadP = (struct Gadget **)&(*GadP)->NextGadget;
        *GadP = Gad_PLAYPAUSE = MakeGadget(8+BIGBUTTONSIZE+BIGBUTTONGAP, 88, &PlayPauseI1, GID_PLAYPAUSE);

         GadP = (struct Gadget **)&(*GadP)->NextGadget;
        *GadP = Gad_FFWD = MakeGadget(2+BIGBUTTONSIZE*3+BIGBUTTONGAP*2,  88, &FFWDI1,      GID_FFWD);

         GadP = (struct Gadget **)&(*GadP)->NextGadget;
        *GadP = Gad_STOP = MakeGadget(2+BIGBUTTONSIZE*4+BIGBUTTONGAP*3,  88, &StopI1,      GID_STOP);


         GadP = (struct Gadget **)&(*GadP)->NextGadget;
        *GadP = Gad_LOOPMODE  = MakeGadget(8,                                 57, &LoopI1,  GID_LOOPMODE);

         GadP = (struct Gadget **)&(*GadP)->NextGadget;
        *GadP = Gad_INTROMODE = MakeGadget(8+MODEBUTTONSIZE+BIGBUTTONGAP,     57, &IntroI1, GID_INTROMODE);

         GadP = (struct Gadget **)&(*GadP)->NextGadget;
        *GadP = Gad_TIMEMODE  = MakeGadget(8+MODEBUTTONSIZE*2+BIGBUTTONGAP*2, 57, &IntroI1, GID_TIMEMODE);

        if (window = OpenWindowTagList(NULL, WinTags)) {

            window->UserPort = IPort;

            ModifyIDCMP(window, IDCMP_GADGETUP|IDCMP_MOUSEBUTTONS|IDCMP_GADGETDOWN|IDCMP_CLOSEWINDOW);
d631 6
a636 7
            SetAPen(window->RPort, 2);
            Move(window->RPort, 8, 54);
            Draw(window->RPort, 8, MATRIXTOP);
            Draw(window->RPort, 147, MATRIXTOP);
            SetAPen(window->RPort, 1);
            Draw(window->RPort, 147, 54);
            Draw(window->RPort, 8, 54);
d638 1
a638 1
            DisplayTime();
d640 1
a640 43
            GetPlayerState(&PlayerState);
            AudioDisk = PlayerState.AudioDisk == 1;

            if   (Paused  = PlayerState.PlayState == PLS_PAUSED)  SelectIcon(Gad_PLAYPAUSE, 2);
            if   (Playing = PlayerState.PlayState >= PLS_PLAYING) SelectIcon(Gad_PLAYPAUSE, 1);
            else                                                  SelectIcon(Gad_STOP,      1);

            Selecting = Selected = PlayerState.PlayState >= PLS_SELECTED;

            GetOptions(&PlayerOptions);

            if (LoopMode  = PlayerOptions.Loop)  SelectIcon(Gad_LOOPMODE,  1);
            if (IntroMode = PlayerOptions.Intro) SelectIcon(Gad_INTROMODE, 1);

            SelectIcon(Gad_TIMEMODE, TimeMode = PlayerOptions.TimeMode);

            if ((DisplayTracks = PlayerState.Tracks) > 40) DisplayTracks = 40;

            if (AudioDisk) EnableTrackButtons(DisplayTracks, 1, 1);

            SendTimerRequest();

//********* Event Loop **************************************************************************************

            while (!exit_code) {

                Event = Wait((1L << TPort->mp_SigBit) | (1L << IPort->mp_SigBit));

//************* Timer Event (update player states) **********************************************************

                if (Event & (1L << TPort->mp_SigBit)) {

                    GetMsg(TPort);
                    SendTimerRequest();                    

                    GetPlayerState(&PlayerState);
                    GetOptions(&PlayerOptions);

                    if ((PlayerState.AudioDisk == 1) != AudioDisk) {

                        AudioDisk = PlayerState.AudioDisk == 1;

                        if ((DisplayTracks = PlayerState.Tracks) > 40) DisplayTracks = 40;
d642 2
a643 1
                        if (AudioDisk) {
d645 1
a645 3
                            Selecting = 0;
                            EnableTrackButtons(DisplayTracks, 1, 1);
                            }
d647 32
a678 1
                        else EnableTrackButtons(NUMTRACKS, 0, 0);
d681 4
a684 1
                    if ((PlayerState.PlayState == PLS_PAUSED) != Paused) {
d686 3
a688 5
                        if   (Paused = PlayerState.PlayState == PLS_PAUSED) SelectIcon(Gad_PLAYPAUSE, 2);
                        else                                                SelectIcon(Gad_PLAYPAUSE, 1);
                        }

                    if ((PlayerState.PlayState >= PLS_PLAYING) != Playing) {
d690 1
a690 1
                        if (Playing = PlayerState.PlayState >= PLS_PLAYING) {
d692 1
a692 3
                            SelectIcon(Gad_PLAYPAUSE, 1);
                            SelectIcon(Gad_STOP,      0);
                            }
d694 5
a698 1
                        else {
d700 2
a701 3
                            SelectIcon(Gad_PLAYPAUSE, 0);
                            SelectIcon(Gad_STOP,      1);
                            }
d703 1
d705 1
a705 1
                    if ((PlayerState.PlayState >= PLS_SELECTED) != Selected) {
d707 1
a707 1
                        if (Selected = PlayerState.PlayState >= PLS_SELECTED) {
d709 6
a714 6
                            Selecting = 1;
                            DisplayTrackButtons(DisplayTracks);
                            HighlightButton(HighlightedIndex = CurrentIndex = PlayerState.ListIndex, 1);
                            }

                        else if (Selecting) {
d716 2
a717 3
                            HighlightButton(HighlightedIndex, 0);
                            Selecting = 0;
                            }
d719 1
d721 1
a721 1
                    if (CurrentIndex != PlayerState.ListIndex) {
d723 1
a723 1
                        CurrentIndex = PlayerState.ListIndex;
d725 1
a725 1
                        if (Selected) {
d727 2
a728 3
                            HighlightButton(HighlightedIndex, 0);
                            HighlightButton(HighlightedIndex = CurrentIndex, 1);
                            }
d730 1
d732 1
a732 1
                    if (LoopMode != PlayerOptions.Loop) {
d734 3
a736 5
                        LoopMode = PlayerOptions.Loop;
                        SelectIcon(Gad_LOOPMODE, LoopMode);
                        }

                    if (IntroMode != PlayerOptions.Intro) {
d738 1
a738 1
                        if ((IntroMode = PlayerOptions.Intro) && !Playing) {
d740 1
a740 3
                            SubmitKeyStroke(PKS_PLAYPAUSE|PKSF_PRESS);
                            SubmitKeyStroke(PKS_PLAYPAUSE|PKSF_RELEASE);
                            }
d742 2
a743 1
                        SelectIcon(Gad_INTROMODE, IntroMode);
d746 2
a747 1
                    if (TimeMode != PlayerOptions.TimeMode) {
d749 1
a749 2
                        SelectIcon(Gad_TIMEMODE, TimeMode = PlayerOptions.TimeMode);
                        }
d751 1
a751 1
                    DisplayTime();
d754 4
a757 1
//************* Button Event ********************************************************************************
d759 3
a761 1
                if (Event & (1L << IPort->mp_SigBit)) {
d763 1
a763 1
                    if (imsg=(struct IntuiMessage *)GetMsg(IPort)) {
d765 1
a765 1
                        if (imsg->IDCMPWindow == window) {
d767 1
a767 1
                            if (imsg->Class & IDCMP_CLOSEWINDOW) exit_code = 1;
d769 1
a769 1
                            else {
d771 1
a771 1
                                Gad = (struct Gadget *)imsg->IAddress;
d773 1
a773 1
                                if (imsg->Class & IDCMP_GADGETDOWN) {
d775 1
a775 1
                                    LastDownGadget = Gad;
d777 1
a777 1
                                    if (Gad->GadgetID < DisplayTracks) {
d779 3
a781 1
                                        if (Playing) {
d783 1
a783 3
                                            SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
                                            SubmitKeyStroke(PKS_STOP|PKSF_RELEASE);
                                            }
d785 3
a787 1
                                        if (!Selecting && !Selected && (TracksSelected() == ALLENA)) {
d789 1
a789 3
                                            Selecting = 1;
                                            EnableTrackButtons(DisplayTracks, 0, 1);
                                            }
d791 2
a792 2
                                        EnableButton(Gad, !(PlayList->Entry[Gad->GadgetID] & PLEF_ENABLE),
                                                          &TrackText[Gad->GadgetID*2], 2);
d794 1
a794 1
                                        if (Selecting && (TracksSelected() == ALLCLR)) {
d796 1
a796 3
                                            Selecting = 0;
                                            EnableTrackButtons(DisplayTracks, 1, 1);
                                            }
d798 2
a799 2
                                        SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
                                        SubmitKeyStroke(PKS_STOP|PKSF_RELEASE);
d802 3
a804 2
                                    else if (Gad->GadgetID == GID_PLAYPAUSE) SubmitKeyStroke(PKS_PLAYPAUSE|PKSF_PRESS);
                                    else if (Gad->GadgetID == GID_STOP) {
d806 2
a807 1
                                            if (Playing || (TracksSelected() == ALLENA)) {
d809 1
a809 3
                                                SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
                                                SubmitKeyStroke(PKS_STOP|PKSF_RELEASE);
                                                }
d811 3
a813 1
                                            if (!Selected || (TracksSelected() == ALLENA)) {
d815 1
a815 1
                                                Selecting = 0;
d817 3
a819 3
                                                if (Selected || (TracksSelected() != ALLENA))
                                                    EnableTrackButtons(DisplayTracks, 1, 1);
                                                }
d821 2
a822 2
                                            SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
                                            }
d824 1
a824 1
                                    else if (Gad->GadgetID == GID_FREV) {
d826 1
a826 1
                                        if (AudioDisk) {
d828 2
a829 3
                                            SelectIcon(Gad, 1);
                                            SubmitKeyStroke(PKS_REVERSE|PKSF_PRESS);
                                            }
d831 1
d833 1
a833 1
                                    else if (Gad->GadgetID == GID_FFWD) {
d835 1
a835 1
                                        if (AudioDisk) {
d837 2
a838 3
                                            SelectIcon(Gad, 1);
                                            SubmitKeyStroke(PKS_FORWARD|PKSF_PRESS);
                                            }
d840 6
d847 4
a850 4
                                    else if (Gad->GadgetID == GID_LOOPMODE)  InvertOption(OPT_LOOP);
                                    else if (Gad->GadgetID == GID_INTROMODE) InvertOption(OPT_INTRO);
                                    else if (Gad->GadgetID == GID_TIMEMODE)  InvertOption(OPT_TIME);
                                    }
d852 3
a854 8
                                else if (imsg->Class & IDCMP_GADGETUP
                                     || ((imsg->Class & IDCMP_MOUSEBUTTONS) && (imsg->Code == SELECTUP))) {

                                    if (imsg->Class & IDCMP_MOUSEBUTTONS) Gad = LastDownGadget;

                                    if      (Gad->GadgetID == GID_PLAYPAUSE) SubmitKeyStroke(PKS_PLAYPAUSE|PKSF_RELEASE);
                                    else if (Gad->GadgetID == GID_STOP)      SubmitKeyStroke(PKS_STOP|PKSF_RELEASE);
                                    else if (Gad->GadgetID == GID_FREV) {
d856 1
a856 1
                                        if (AudioDisk) {
d858 2
a859 3
                                            SelectIcon(Gad, 0);
                                            SubmitKeyStroke(PKS_REVERSE|PKSF_RELEASE);
                                            }
d861 1
d863 1
a863 1
                                    else if (Gad->GadgetID == GID_FFWD) {
d865 1
a865 1
                                        if (AudioDisk) {
d867 2
a868 3
                                            SelectIcon(Gad, 0);
                                            SubmitKeyStroke(PKS_FORWARD|PKSF_RELEASE);
                                            }
a871 2

                            ReplyMsg((struct Message *)imsg);
d874 1
a874 1
                        else StripIntuiMessages(IPort);
d876 2
d880 1
d882 1
a882 1
//********* Close Down **************************************************************************************
d884 2
a885 2
            SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
            SubmitKeyStroke(PKS_STOP|PKSF_RELEASE);
d887 26
a912 1
            Delay(5);
a913 2
            while (!ModifyPlayList(1)) Delay(1);
            ModifyPlayList(0);
a914 2
            WaitPort(TPort);
            while(GetMsg(TPort));
a915 4
            window->UserPort = NULL;
            StripIntuiMessages(IPort);
            CloseWindow(window);
            }
a916 1
        else printf("Could not open window\n");
d918 1
a918 1
        Gad = (struct Gadget *)WIN_Gadgets;
d920 7
a926 1
        while (Gad) {
d928 1
a928 2
            TempGad = Gad;
            Gad     = Gad->NextGadget;
d930 1
a930 2
            DeleteGadget(TempGad);
            }
d932 1
a932 2
        FreeArgs(rdargs);
        }
d934 17
a950 2
    else printf("required argument missing\n");
    }
d952 2
d955 3
d959 1
d961 2
d964 1
d966 2
a967 1
int main (int argc, char **argv) {
d969 3
a971 1
    if (IPort = CreateMsgPort()) {
d973 3
a975 1
        if (DOSBase = OpenLibrary("dos.library", 0)) {
d977 1
a977 14
            if (IntuitionBase = OpenLibrary("intuition.library", 0)) {

                if (GfxBase = OpenLibrary("graphics.library", 0)) {

                    if (PlayerBase = OpenLibrary("player.library", 0)) {

                        if (TPort = CreateMsgPort()) {

                            if (TReq = CreateIORequest(TPort, sizeof(struct timerequest))) {

                                if (!OpenDevice("timer.device", 0, TReq, UNIT_MICROHZ)) {

                                    DoPlayer();
                                    CloseDevice(TReq);
d980 1
a980 1
                                DeleteIORequest(TReq);
d983 1
a983 1
                            DeleteMsgPort(TPort);
d986 1
a986 1
                        CloseLibrary(PlayerBase);
d989 1
a989 1
                    CloseLibrary(GfxBase);
d992 1
a992 1
                CloseLibrary(IntuitionBase);
d995 1
a995 1
            CloseLibrary(DOSBase);
d998 1
a998 1
        DeleteMsgPort(IPort);
@


1.1
log
@Initial revision
@
text
@d30 1
d34 19
d82 13
a94 1
char TrackText[] = "01020304050607080910111213141516171819202122232425262728293031323334353637383940";
d96 2
a114 73
int IconArray[][70] = {

//
//   Fill Pair ---------------------------------------
//   Pairs -----------------------------------       /\ 
//   # of Elements ------.    /               \     /  \
//   NextIcon --------v  v   /                 \   /    \
//
                    { 0, 4, 3,  13, 8, -8,  8,  8,  4,  0 },                            // FREV
                    { 1, 4, 12, 13, 8, -8,  8,  8,  4,  0 },
                    { 0, 4, 6,  5,  16, 8,  0,  16, 4,  8 },                            // PLAYPAUSE
                    { 0, 6, 28, 5,  5,  0,  5,  16, 0,  16, 2,  8 },
                    { 1, 6, 36, 5,  5,  0,  5,  16, 0,  16, 2,  8 },
                    { 0, 4, 5,  5,  8,  8,  0,  16, 4,  8 },                            // FFWD
                    { 1, 4, 14, 5,  8,  8,  0,  16, 4,  8 },
                    { 1, 6, 8,  8,  0,  10, 10, 10, 10, 0,  5,  5 },                    // STOP
                    { 1, 62,                                                            // LOOP
                            9, 14,
                                    0, -3,  1,  -5,  3, -7,
                                    6, -8,  10, -8, 10, -11,
                                   14, -6,  10, -1, 10, -4,
                                    6, -4,  4,  -2, 4,   2,
                                    6,  4,  20,  4, 22,  2,
                                   22, -2,  20, -4, 16, -4,
                                   16, -8,  20, -8, 23, -7,
                                   25, -5,  26, -2, 26,  2,
                                   25,  5,  23, 7,  20,  8,
                                    6,  8,  3,  7,  1,   5,
                                    0,  2,
                                    
                                                           11, -9 },
                    { 0, 16,                                                             // INTRO
                            6,  8,
                                    8,  0,  8,  8, 10,  8,
                                    7, 11,  4,  8,  6,  8,
                                    6,  2,  0,  2,
                                                            1,  1 },
                    { 0, 16,
                            16, 8,
                                    8,  0,  8,  8, 10,  8,
                                    7, 11,  4,  8,  6,  8,
                                    6,  2,  0,  2,
                                                            1,  1 },
                    { 1, 16,
                            26, 8,
                                    8,  0,  8,  8, 10,  8,
                                    7, 11,  4,  8,  6,  8,
                                    6,  2,  0,  2,
                                                            1,  1 },
                    { 0, 12,                                                            // TIMEMODE
                            13, 4,
                                    6,  0,  6, -2,  9,  1,
                                    6,  4,  6,  2,  0,  2,
                                                            7,  0 },
                    { 0, 12,
                            23, 9,
                                    6,  0,  6, -2,  9,  1,
                                    6,  4,  6,  2,  0,  2,
                                                            7,  0 },
                    { 0, 12,
                            7,  14,
                                   12,  0, 12, -2, 15,  1,
                                   12,  4, 12,  2, 0,   2,
                                                           13,  0 },
                    { 1, 12,
                            23, 19,
                                   12,  0, 12, -2, 15,  1,
                                   12,  4, 12,  2, 0,   2,
                                                           13,  0 },

                    { 1, 0 },
                    };

d125 4
a128 1
int                   AudioDisk = 0, ColonLit = 1;
d162 26
a187 1
struct Gadget *CreateGadget(WORD LeftEdge, WORD TopEdge, WORD Width, WORD Height, UWORD ID) {
d246 1
a246 1
    if (Border = (struct Border *)Gad->GadgetRender) {
d248 1
a248 1
        while (Border) {
d250 4
a253 2
            TempBorder = Border;
            Border     = Border->NextBorder;
d255 4
a258 1
            if (TempBorder->XY) {
d260 1
a260 1
                FreeMem((char *)(TempBorder->XY), TempBorder->Count*4);
d262 1
d264 1
a264 2
            FreeMem((char *)TempBorder, sizeof(struct Border));
            }
d266 2
a268 2
    FreeMem((char *)Gad, sizeof(struct Gadget));
    }
d270 1
d272 1
d274 2
a275 1
void EnableButton(struct Gadget *Gad, int Flag, char *DispText, int Len) {
a276 1
    while (!ModifyPlayList(1));
a277 2
    if (Flag) PlayList->Entry[Gad->GadgetID] |= PLEF_ENABLE;
    else      PlayList->Entry[Gad->GadgetID] &= PLEF_TRACK;
d279 1
a279 1
    ModifyPlayList(0);
d281 2
a282 2
    if (Flag) { SetAPen(window->RPort, 3); SetBPen(window->RPort, 3); }
    else      { SetAPen(window->RPort, 0); SetBPen(window->RPort, 0); }
a287 1

d294 1
a294 1
        }
d299 1
a299 1
void EnableTrackButtons(int NumButtons, int Flag, int DispText) {
d306 1
a306 2
        if (DispText) EnableButton(*GadP, Flag, &TrackText[i*2], 2);
        else          EnableButton(*GadP, Flag, NULL, 0);
d311 1
d313 1
a313 1
void HighlightButton(int Track, int Flag) {
d315 2
a316 2
    if (Flag) SetAPen(window->RPort, 1);
    else {
d318 1
a318 25
        if   (PlayList->Entry[Track] & PLEF_ENABLE) SetAPen(window->RPort, 3);
        else                                        SetAPen(window->RPort, 0);
        }

    Move(window->RPort, MATRIXLEFT + 2 + (Track % 8) * 30,      MATRIXTOP + 2 + (Track / 8) * 20);
    Draw(window->RPort, MATRIXLEFT + 2 + (Track % 8) * 30 + 21, MATRIXTOP + 2 + (Track / 8) * 20);
    Draw(window->RPort, MATRIXLEFT + 2 + (Track % 8) * 30 + 21, MATRIXTOP + 2 + (Track / 8) * 20 + 13);
    Draw(window->RPort, MATRIXLEFT + 2 + (Track % 8) * 30,      MATRIXTOP + 2 + (Track / 8) * 20 + 13);
    Draw(window->RPort, MATRIXLEFT + 2 + (Track % 8) * 30,      MATRIXTOP + 2 + (Track / 8) * 20);
    }



void DrawIcon(struct Gadget *Gad) {

int i, j;

    for (i=j=0; i!=(Gad->GadgetID-BIGGADGETS); j++) if (IconArray[j][0]) i++;

    SetOPen(window->RPort, 0);
    SetAPen(window->RPort, 3);
    RectFill(window->RPort, Gad->LeftEdge + 1,
                            Gad->TopEdge  + 1,
                            Gad->LeftEdge + Gad->Width  - 1, 
                            Gad->TopEdge  + Gad->Height - 1);
d320 1
a320 25
    do {

        SetAPen(window->RPort, 1);

        Move(window->RPort, Gad->LeftEdge + IconArray[j][2],
                            Gad->TopEdge  + IconArray[j][3]);

        for (i=4; i<IconArray[j][1]+4; i+=2) {

            Draw(window->RPort, Gad->LeftEdge + IconArray[j][2] + IconArray[j][i],
                                Gad->TopEdge  + IconArray[j][3] + IconArray[j][i+1]);
            }

        Draw(window->RPort, Gad->LeftEdge + IconArray[j][2],
                            Gad->TopEdge  + IconArray[j][3]);

        SetAPen(window->RPort, 0);
        SetOPen(window->RPort, 1);

        Flood(window->RPort, 0, Gad->LeftEdge + IconArray[j][2] + IconArray[j][i],
                                Gad->TopEdge  + IconArray[j][3] + IconArray[j][i+1]);

        } while (!IconArray[j++][0]);

    SetOPen(window->RPort, 0);
d325 1
d327 2
a328 1
void DrawGadgetIcons(void) {
d330 1
a330 1
struct Gadget *Gad = BigGadgets;
d332 2
a333 5
    while (Gad) {

        DrawIcon(Gad);
        Gad = Gad->NextGadget;
        }
a338 1
void SelectIcon(struct Gadget *Gad, int Start, int Length, int Flag) {
d340 1
a340 1
int i, j, k=0;
d342 1
a342 1
    for (i=j=0; i!=(Gad->GadgetID-BIGGADGETS); j++) if (IconArray[j][0]) i++;
d344 2
a345 1
    do {
d347 10
a356 15
        if (k++ >= Start) {

            if (k <= Start + Length) {

                SetAPen(window->RPort, Flag ? 2 : 0);
                SetOPen(window->RPort, 1);

                Flood(window->RPort, 0, Gad->LeftEdge + IconArray[j][2] + IconArray[j][IconArray[j][1]+4],
                                        Gad->TopEdge  + IconArray[j][3] + IconArray[j][IconArray[j][1]+5]);
                }
            }

        } while (!IconArray[j++][0]);

    SetOPen(window->RPort, 0);
d374 1
a374 1
                else if (++((BYTE *)&Opts)[i] == 4) ((BYTE *)&Opts)[i] = 0;
d402 1
a402 1
char DigitPos[] = { 19, 49, 89, 119 };
d406 7
a412 7
    {  4,  0, 12,  4 },
    { 12,  2, 16, 16 },
    { 12, 16, 16, 30 },
    {  4, 28, 12, 32 },
    {  0, 16,  4, 30 },
    {  0,  2,  4, 16 },
    {  4, 14, 12, 18 }
d426 1
a426 1
                            SegPos[Segment][1] + 19,
d428 1
a428 1
                            SegPos[Segment][3] + 19);
d447 21
d470 3
a472 1
        DisplayDigit(0, PlayerState.Minute/10);
d479 2
a480 2
            RectFill(window->RPort, 75, 26, 79, 30);
            RectFill(window->RPort, 75, 41, 79, 45);
d496 2
a497 2
            RectFill(window->RPort, 75, 26, 79, 30);
            RectFill(window->RPort, 75, 41, 79, 45);
d506 20
a544 2
int                 Selected, Playing, Paused, CurrentIndex, HighlightedIndex, LoopMode, IntroMode, TimeMode, DisplayTracks;

d547 1
a547 1
struct Gadget       **GadP, *Gad, *TempGad;
d570 1
a570 1
               *GadP = CreateGadget(i, j, 25, 17, k++);
d575 1
a575 1
        *GadP = BigGadgets = Gad_FREV = CreateGadget(8,                    88, BIGBUTTONSIZE,     BIGBUTTONSIZE, GID_FREV);
d578 1
a578 1
        *GadP = Gad_PLAYPAUSE = CreateGadget(8+BIGBUTTONSIZE+BIGBUTTONGAP, 88, BIGBUTTONSIZE*2-6, BIGBUTTONSIZE, GID_PLAYPAUSE);
d581 1
a581 1
        *GadP = Gad_FFWD = CreateGadget(2+BIGBUTTONSIZE*3+BIGBUTTONGAP*2,  88, BIGBUTTONSIZE,     BIGBUTTONSIZE, GID_FFWD);
d584 1
a584 1
        *GadP = Gad_STOP = CreateGadget(2+BIGBUTTONSIZE*4+BIGBUTTONGAP*3,  88, BIGBUTTONSIZE,     BIGBUTTONSIZE, GID_STOP);
d588 1
a588 1
        *GadP = Gad_LOOPMODE  = CreateGadget(8,                                 57, MODEBUTTONSIZE, BIGBUTTONSIZE, GID_LOOPMODE);
d591 1
a591 1
        *GadP = Gad_INTROMODE = CreateGadget(8+MODEBUTTONSIZE+BIGBUTTONGAP,     57, MODEBUTTONSIZE, BIGBUTTONSIZE, GID_INTROMODE);
d594 1
a594 1
        *GadP = Gad_TIMEMODE  = CreateGadget(8+MODEBUTTONSIZE*2+BIGBUTTONGAP*2, 57, MODEBUTTONSIZE, BIGBUTTONSIZE, GID_TIMEMODE);
d600 1
a600 3
            ModifyIDCMP(window, IDCMP_GADGETUP|IDCMP_GADGETDOWN|IDCMP_CLOSEWINDOW);

            DrawGadgetIcons();
d615 3
a617 3
            if   (Paused  = PlayerState.PlayState == PLS_PAUSED)  SelectIcon(Gad_PLAYPAUSE, 0, 99, 1);
            if   (Playing = PlayerState.PlayState >= PLS_PLAYING) SelectIcon(Gad_PLAYPAUSE, 0, 1,  1);
            else                                                  SelectIcon(Gad_STOP,      0, 99, 1);
d619 1
a619 1
            Selected = PlayerState.PlayState >= PLS_SELECTED;
d623 2
a624 4
            if (LoopMode  = PlayerOptions.Loop)  SelectIcon(Gad_LOOPMODE,  0, 99, 1);
            if (IntroMode = PlayerOptions.Intro) SelectIcon(Gad_INTROMODE, 0, 99, 1);

            TimeMode = PlayerOptions.TimeMode;
d626 1
a626 7
            switch (TimeMode) {

                case 0: SelectIcon(Gad_TIMEMODE, 3, 1, 0); SelectIcon(Gad_TIMEMODE, 0, 1, 1); break;
                case 1: SelectIcon(Gad_TIMEMODE, 0, 1, 0); SelectIcon(Gad_TIMEMODE, 1, 1, 1); break;
                case 2: SelectIcon(Gad_TIMEMODE, 1, 1, 0); SelectIcon(Gad_TIMEMODE, 2, 1, 1); break;
                case 3: SelectIcon(Gad_TIMEMODE, 2, 1, 0); SelectIcon(Gad_TIMEMODE, 3, 1, 1); break;
                }
d656 7
a662 2
                        if (AudioDisk) EnableTrackButtons(DisplayTracks, 1, 1);
                        else           EnableTrackButtons(NUMTRACKS, 0, 0);
d665 1
a665 1
                    if ((PlayerState.PlayState >= PLS_SELECTED) != Selected) {
d667 2
a668 3
                        if (Selected = PlayerState.PlayState >= PLS_SELECTED)
                             HighlightButton(HighlightedIndex = CurrentIndex = PlayerState.ListIndex, 1);
                        else HighlightButton(HighlightedIndex, 0);
d675 2
a676 2
                            SelectIcon(Gad_PLAYPAUSE, 0, 1,  1);
                            SelectIcon(Gad_STOP,      0, 99, 0);
d681 2
a682 3
                            HighlightButton(HighlightedIndex, 0);
                            SelectIcon(Gad_PLAYPAUSE, 0, 99, 0);
                            SelectIcon(Gad_STOP,      0, 99, 1);
d686 10
a695 1
                    if ((PlayerState.PlayState == PLS_PAUSED) != Paused) {
d697 3
a699 2
                        if   (Paused = PlayerState.PlayState == PLS_PAUSED) SelectIcon(Gad_PLAYPAUSE, 0, 99, 1);
                        else                                                SelectIcon(Gad_PLAYPAUSE, 1, 2,  0);
d716 1
a716 1
                        SelectIcon(Gad_LOOPMODE, 0, 99, LoopMode);
d721 7
a727 2
                        IntroMode = PlayerOptions.Intro;
                        SelectIcon(Gad_INTROMODE, 0, 99, IntroMode);
d732 1
a732 9
                        TimeMode = PlayerOptions.TimeMode;

                        switch (TimeMode) {

                            case 0: SelectIcon(Gad_TIMEMODE, 3, 1, 0); SelectIcon(Gad_TIMEMODE, 0, 1, 1); break;
                            case 1: SelectIcon(Gad_TIMEMODE, 0, 1, 0); SelectIcon(Gad_TIMEMODE, 1, 1, 1); break;
                            case 2: SelectIcon(Gad_TIMEMODE, 1, 1, 0); SelectIcon(Gad_TIMEMODE, 2, 1, 1); break;
                            case 3: SelectIcon(Gad_TIMEMODE, 2, 1, 0); SelectIcon(Gad_TIMEMODE, 3, 1, 1); break;
                            }
d754 2
d758 11
a768 2
                                        SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
                                        SubmitKeyStroke(PKS_STOP|PKSF_RELEASE);
d773 6
d784 19
a802 1
                                    else if (Gad->GadgetID == GID_STOP)      SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
d807 1
a807 1
                                            SelectIcon(Gad, 0, 99, 1);
d816 1
a816 1
                                            SelectIcon(Gad, 0, 99, 1);
d826 2
a827 1
                                else if (imsg->Class & IDCMP_GADGETUP) {
d829 2
d837 1
a837 1
                                            SelectIcon(Gad, 0, 99, 0);
d846 1
a846 1
                                            SelectIcon(Gad, 0, 99, 0);
d862 11
@
