head     1.8;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.8
date     93.02.26.19.03.20;  author peter;  state Exp;
branches ;
next     1.7;

1.7
date     93.02.23.15.38.30;  author peter;  state Exp;
branches ;
next     1.6;

1.6
date     93.01.07.11.02.56;  author jerryh;  state Exp;
branches ;
next     1.5;

1.5
date     92.12.18.11.43.00;  author jerryh;  state Exp;
branches ;
next     1.4;

1.4
date     92.09.21.13.49.09;  author jerryh;  state Exp;
branches ;
next     1.3;

1.3
date     92.07.31.14.11.14;  author jerryh;  state Exp;
branches ;
next     1.2;

1.2
date     92.07.29.10.11.25;  author jerryh;  state Exp;
branches ;
next     1.1;

1.1
date     92.07.23.11.37.20;  author jerryh;  state Exp;
branches ;
next     ;


desc
@Screen update module for Player program.
@


1.8
log
@Major work.  Intuitionized.  Prototyped.  Improved behavior.  Added comments.
@
text
@/* $Id: $ */

#include <exec/types.h>
#include <exec/io.h>
#include <exec/execbase.h>
#include <exec/memory.h>

#include <hardware/blit.h>

#include <devices/timer.h>
#include <devices/input.h>
#include <devices/inputevent.h>

#include <graphics/gfx.h>
#include <graphics/rastport.h>
#include <graphics/view.h>

#include <gs:cd/cd.h>
#include <cdtv/debox.h>

#include <libraries/dos.h>

#include "/playerprefs.h"
#include "/display.h"
#include "/playerprefsbase.h"

#include "/playerprefs_pragmas.h"
#include "/playerprefs_protos.h"
#include "/cdtvkeys.h"

#include <clib/exec_protos.h>
#include <clib/dos_protos.h>
#include <clib/graphics_protos.h>
#include <clib/debox_protos.h>
UWORD __stdargs RangeRand( unsigned long maxValue );

#include <pragmas/exec_old_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/debox_pragmas.h>

#include <internal/playerlibrary.h>
#include <clib/player_protos.h>
#include <pragmas/player_pragmas.h>


/******************************** Defines **********************************/

#define TCOUNTMAX   59                                                      /* Max pos for track counter */

/*************************** External Functions ****************************/

extern void UpdateGadgets(void);
extern int UpdateDisplay( void );

extern GADInsDraw(struct RastPort *, struct GadDir *, int, UWORD);
extern GADSTDBox(struct RastPort *, struct GadDir *, int, UWORD);

extern GADNumber(struct RastPort *, struct BitMap *, struct GadDir *, WORD, WORD);
extern RNormal(struct RastPort *, struct BitMap *, struct GadDir *, WORD, WORD);

/********************* External Structures/Variables ***********************/

extern void                    *SysBase;
extern struct GfxBase          *GfxBase;
extern struct DeBoxBase        *DeBoxBase;
extern struct DOSBase          *DOSBase;
extern struct PlayerPrefsBase  *PlayerPrefsBase;
extern struct PlayerBase       *PlayerBase;

extern struct CDTVInputInfo     input_data;
extern struct IBuffer          *CurrentIB;
extern struct IBuffer          *WorkIB;
extern struct IBuffer          *MasterIB;

extern struct PlayerState       PlayerState;
extern struct PlayList         *PlayList;
extern struct PlayList         *UndoPlayList;
extern LONG ShuffleMode;

extern union  CDTOC            *TOC;
extern struct QCode             qcode, copyqcode;
extern int                      qvalid;
extern struct IOStdReq         *cdio;

extern UBYTE                    KeyPressed;
extern ULONG                    currsec;
extern UWORD volatile __far     vhposr;                                     /* Custom chip register. */

/******************************* Functions *********************************/

int NOOP(void);

static GADTrackNum(), GADGridNumber(), RDisk(), RCounter();

void   PlayerNumPad(int);

/************************* Structures/Variables ****************************/

static LONG secperpixel;

/*============================= Gadget Data ===============================*/

/* These arrays are used to render the states of each gadget.
 * Each array is a list of coordinate pairs, one pair per state,
 * of the Left/TopEdge in the scrbuttons.pic picture of that
 * state's imagery.  The Width/Height are inferred from the GadDir.
 */
static UWORD d_STOP[]   = {104,28,   130,28 };
static UWORD d_REV[]    = {  0,28,    26,28 };
static UWORD d_PLAY[]   = {156,155,  200,155,   244,155 };
static UWORD d_FF[]     = { 52,28,    78,28 };

static UWORD d_TIME[]   = { 0, 74,   48, 74,    96, 74,   144,74 };
static UWORD d_NEG[]	= { 0, 55,    6, 55 };
static UWORD d_SHUFF[]  = { 0,101,   48,101 };
static UWORD d_REPEAT[] = { 0,155,   48,155,   155,155,   203,155 };
static UWORD d_INTRO[]  = { 0,182,   48,182,    96,182,   144,182,   192,182,   240,182 };
static UWORD d_CDG[]    = { 0,209,   48,209,   191,128,   240,128,   288,128 };

/*============================= Number Data ===============================*/

struct GADNumberInfo d_GridNumberData =
{
    0,0,8,9,
    4,4,10,2,
    20,0,
    0,0,0,0,
    GNIF_HALF | GNIF_BLANKZERO
};

struct GADNumberInfo d_MinNumberData =
{
    0,9,14,19,
    0,0,18,2,
    10,0,
    0,0,0,0,
    GNIF_BLANKMAX|GNIF_BLANKLEAD,
};

struct GADNumberInfo d_SecNumberData =
{
    0,9,14,19,
    0,0,18,2,
    10,0,
    0,0,0,0,
    GNIF_BLANKMAX
};

struct GADNumberInfo d_TrackNumberData =
{
    176,29,16,23,
    20,79,24,2,
    10,0,
    0,0,0,0,
    GNIF_BLANKZERO | GNIF_BLANKMAX
};


/*======================== Gadget Highlight Data ==========================*/

/* Used by GADStdBox() to do the highlighting of the entries in the
 * track table.
 */
struct GADSTDBox d_GridBoxInfo =
{
    -4,-3,33,23,		/* xoffset,yoffset/width/height */
    { 1,1, 192,97 },		/* offi: dispbm=ButtonBM, mask=bmask, coords */
    { 1,1, 226,97 }		/* oni:  dispbm=ButtonBM, mask=ButtonBM, coords */
};


/* These are data tables indicating how to draw the box-highlight
 * for different sized boxes, used by GADInsDraw().
 * d_GADBigButtons[] is for the regular buttons like Intro, Repeat, etc.
 * d_GADMedButtons[] is for the play/pause button.
 * d_GADSmallButtons[] is for the other transport controller buttons.
 */
BYTE d_GADBigButtons[] =
{
    INS_OFF_REDRAW,
    INS_PEN,    34,21,
    INS_MOVE,   3,1,
    INS_DRAW,   44,1,

    INS_PEN,    34,22,
    INS_MOVE,   45,2,
    INS_DRAW,   45,24,

    INS_PEN,    34,23,
    INS_MOVE,   44,25,
    INS_DRAW,   3,25,

    INS_PEN,    34,24,
    INS_MOVE,   2,24,
    INS_DRAW,   2,2,
    INS_END
};

BYTE d_GADSmallButtons[] =
{
    INS_OFF_REDRAW,
    INS_PEN,    34,21,
    INS_MOVE,   3,1,
    INS_DRAW,   22,1,

    INS_PEN,    34,22,
    INS_MOVE,   23,2,
    INS_DRAW,   23,24,

    INS_PEN,    34,23,
    INS_MOVE,   22,25,
    INS_DRAW,   3,25,

    INS_PEN,    34,24,
    INS_MOVE,   2,24,
    INS_DRAW,   2,2,
    INS_END
};

BYTE d_GADMedButtons[] =
{
    INS_OFF_REDRAW,
    INS_PEN,    34,21,
    INS_MOVE,   3,1,
    INS_DRAW,   40,1,

    INS_PEN,    34,22,
    INS_MOVE,   41,2,
    INS_DRAW,   41,24,

    INS_PEN,    34,23,
    INS_MOVE,   40,25,
    INS_DRAW,   3,25,

    INS_PEN,    34,24,
    INS_MOVE,   2,24,
    INS_DRAW,   2,2,
    INS_END
};

/*============================= Gadget List ===============================*/

struct GadDir PlayGADList[MAX_PLGAD + 1] =
{
    { PLGAD_COUNTER, 0x00, 0,            0, TCOUNTMAX, PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     293, 214, 321, 234, NOOP,       NULL,               RCounter,      NULL               },
    { PLGAD_DISK,    0x00, 0,            0, 38,        PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     293, 214, 321, 234, NOOP,       NULL,               RDisk,         NULL               },
    { PLGAD_TTRACK,  0x00, 0,            0, 100,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     293, 214, 321, 234, NOOP,       NULL,               GADTrackNum,   &d_TrackNumberData },
    { PLGAD_STOP,    0x80, KEY_STOP,     0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_FF,     PLGAD_INTRO,  126, 208, 152, 235, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_STOP   },
    { PLGAD_REV,     0x80, KEY_BACK,     0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_CDG,    PLGAD_PLAY,   18,  208, 44,  235, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_REV    },
    { PLGAD_PLAY,    0x80, KEY_PLAY,     0,   3,       PLGAD_NL,     PLGAD_NL,     PLGAD_REV,    PLGAD_FF,     48,  208, 92,  235, GADInsDraw, &d_GADMedButtons,   RNormal,       &d_PLAY   },
    { PLGAD_FF,      0x80, KEY_FWD,      0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_PLAY,   PLGAD_STOP,   96,  208, 122, 235, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_FF     },
    { PLGAD_TIME,    0x80, KEY_TIMEMODE, 0,   4,       PLGAD_16,     PLGAD_INTRO,  PLGAD_REPEAT, PLGAD_SHUFF,  169, 169, 216, 195, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_TIME   },
    { PLGAD_SHUFF,   0x80, KEY_SHUFFLE,  0,   2,       PLGAD_18,     PLGAD_REPEAT, PLGAD_TIME,   PLGAD_CDG,    231, 169, 278, 195, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_SHUFF  },
    { PLGAD_INTRO,   0x80, KEY_INTRO,    0,   6,       PLGAD_TIME,   PLGAD_1,      PLGAD_STOP,   PLGAD_REPEAT, 169, 208, 216, 234, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_INTRO  },
    { PLGAD_REPEAT,  0x80, KEY_REPEAT,   0,   4,       PLGAD_SHUFF,  PLGAD_3,      PLGAD_INTRO,  PLGAD_TIME,   221, 208, 268, 234, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_REPEAT },
    { PLGAD_CDG,     0x80, KEY_CDG,      0,   5,       PLGAD_20,     PLGAD_CDG,    PLGAD_SHUFF,  PLGAD_REV,    283, 169, 330, 195, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_CDG    },
    { PLGAD_1,       0x05, KEY_GBUTTON,  0, 255,       PLGAD_INTRO,  PLGAD_6,      PLGAD_REPEAT, PLGAD_2,      169, 57,  193, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_2,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_INTRO,  PLGAD_7,      PLGAD_1,      PLGAD_3,      203, 57,  227, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_3,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_REPEAT, PLGAD_8,      PLGAD_2,      PLGAD_4,      237, 57,  261, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_4,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_REPEAT, PLGAD_9,      PLGAD_3,      PLGAD_5,      271, 57,  295, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_5,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_REPEAT, PLGAD_10,     PLGAD_4,      PLGAD_6,      305, 57,  329, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_6,       0x00, KEY_GBUTTON,  0, 255,       PLGAD_1,      PLGAD_11,     PLGAD_5,      PLGAD_7,      169, 80,  193, 96,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_7,       0x00, KEY_GBUTTON,  0, 255,       PLGAD_2,      PLGAD_12,     PLGAD_6,      PLGAD_8,      203, 80,  227, 96,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_8,       0x00, KEY_GBUTTON,  0, 255,       PLGAD_3,      PLGAD_13,     PLGAD_7,      PLGAD_9,      237, 80,  261, 96,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_9,       0x00, KEY_GBUTTON,  0, 255,       PLGAD_4,      PLGAD_14,     PLGAD_8,      PLGAD_10,     271, 80,  295, 96,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_10,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_5,      PLGAD_15,     PLGAD_9,      PLGAD_11,     305, 80,  329, 96,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_11,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_6,      PLGAD_16,     PLGAD_10,     PLGAD_12,     169, 103, 193, 119, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_12,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_7,      PLGAD_17,     PLGAD_11,     PLGAD_13,     203, 103, 227, 119, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_13,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_8,      PLGAD_18,     PLGAD_12,     PLGAD_14,     237, 103, 261, 119, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_14,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_9,      PLGAD_19,     PLGAD_13,     PLGAD_15,     271, 103, 295, 119, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_15,      0x00, KEY_GBUTTON,  0, 255,       PLGAD_10,     PLGAD_20,     PLGAD_14,     PLGAD_16,     305, 103, 329, 119, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_16,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_11,     PLGAD_TIME,   PLGAD_15,     PLGAD_17,     169, 126, 193, 142, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_17,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_12,     PLGAD_TIME,   PLGAD_16,     PLGAD_18,     203, 126, 227, 142, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_18,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_13,     PLGAD_SHUFF,  PLGAD_17,     PLGAD_19,     237, 126, 261, 142, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_19,      0x02, KEY_GBUTTON,  0, 255,       PLGAD_14,     PLGAD_SHUFF,  PLGAD_18,     PLGAD_20,     271, 126, 295, 142, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_20,      0x0A, KEY_GBUTTON,  0, 255,       PLGAD_15,     PLGAD_CDG,    PLGAD_19,     PLGAD_TIME,   305, 126, 329, 142, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_MIN,     0x00, 0,            0, 101,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     53,  173, 82,  191, NOOP,       NULL,               GADNumber,     &d_MinNumberData },
    { PLGAD_SEC,     0x00, 0,            0, 101,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     93,  173, 122, 191, NOOP,       NULL,               GADNumber,     &d_SecNumberData },
    { PLGAD_NEG,     0x00, 0,            0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     44,  181, 50,  184, NOOP,       NULL,               RNormal,       &d_NEG             },

    { PLGAD_NL,      0x00, 0,         0xff, 0xff,      0xff,         0xff,         0,            0xff,         0,   0,   0,   0,   NULL,       NULL,               NULL }
};





/******************************* No Function *******************************/

int
NOOP( void )
{
    return(0);
}



/*=================== Head Gadget Positioning/Clipping ====================*/

/* Based on state, returns x, y, height, and source-y in button bitmap.
 * The state bit of 0x4000 means the laser is on, and is ignored
 * by this routine.  The state bit of 0x8000 means that the head-gadget
 * entry/exit motion is in progress, and the y-value comes from
 * the embedded table, while x=20.
 * If 0x8000 is not set, the state value reflects the desired head
 * position left/right.
 */
static void
getcounterbase(WORD loc, WORD *x, WORD *y, WORD *dpos, WORD *dsize)
{
static WORD pos[] =
{
    -47,-34,-22,-11,-1,8,17,25,32,38,43,47,51,55,58,61,64,66,68,69,70,71
};

    if (loc & 0x8000)                                                                              /* Vertical movememt */
    {
	*x = 20;
	if (loc >= 20)  *y = 43;
	else            *y = pos[loc & 0xfff];
    }

    else                                                                                           /* Horizontal movement */
    {
	loc &= 0xfff;

	*y = 71;
	*x = 20+loc;
    }

    *dpos  = 101;                                                                                   /* Default gadget dimensions */
    *dsize = 45;

    if (*y<0)                                                                                      /* Clip the gadget if off screen */
    {
	*dpos -= *y;
	*dsize += *y;
	*y = 0;
    }
}




/*************************** Head Gadget Movement **************************/

static
RCounter(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new)
{
extern struct BitMap    *bm;
extern UBYTE            *bmask;
WORD                     xloc, yloc, dpos, dsize;

    getcounterbase(old, &xloc, &yloc, &dpos, &dsize);                                                                   /* erase old */

    /* 0x4000 means laser is on in old state */
    if (old & 0x4000)
    {
	dsize = 57;
	BltBitMap(bbm, 96, 209, rp->BitMap, 52, 128, 80, 16 ,0xc0, 0xff, NULL);
    }

    if (dsize > 0)
    {
	BltBitMap(bm, xloc, yloc, rp->BitMap, xloc, yloc, 80, dsize, 0xc0, 0xff, NULL);
    }

    getcounterbase(new, &xloc, &yloc, &dpos, &dsize);

    if (dsize > 0)
    {
	BltMaskBitMapRastPort(bbm, 96, dpos, rp, xloc, yloc, 96, dsize, (ABC|ABNC|ANBC), bmask);

	/* 0x4000 means laser is on in new state */
	if (new & 0x4000)
	{
	    BltMaskBitMapRastPort(bbm, 97, 147, rp, xloc+12, yloc+37, 50, 34, (ABC|ABNC|ANBC), bmask);
	}
    }

    WorkIB->ib_GState[PLGAD_TTRACK] = CurrentIB->ib_GState[PLGAD_TTRACK] = 0;
    return(0);
}





/*************************** Disk Gadget Movement **************************/

/* arg rp = ViewPort's RastPort
 * arg bbm = Button bitmap
 * arg GadDir = "gadget" description
 * arg old = old state
 * arg new = new state
 * global bm = screen's initial BitMap (foreground only?)
 * global bmask = Button bitmap's mask plane (DPaint stencil)
 */

static
RDisk(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new)
{
extern struct BitMap   *bm;
extern UBYTE           *bmask;

WORD                    xloc,dpos,dwidth;

static WORD             nums[] =
{
    0,52,51,50,47,44,40,35,30,24,17,10,2,-7,-17,-28,
    -43,-58,-74,-91,-112,-134,-157,-181,-206
};

int            overlen;

    /* Here we erase the CD by blitting from the backing store */
    BltBitMap(bm, 0, 128, rp->BitMap, 0, 128, 267, 18, 0xc0, 0xff, NULL);

    if (new)
    {
	dpos   = 96;
	dwidth = 207;

	if (new < 24)
	{
	    xloc = nums[new];

	    if (xloc < 0)
	    {
		dpos -= xloc;
		dwidth += xloc;
		xloc = 0;
	    }

	    /* Draw the CD sliding in or out */
	    BltMaskBitMapRastPort(bbm, dpos, 209, rp, xloc, 128, dwidth, 18, (ABC|ABNC|ANBC), bmask);

	    overlen = xloc+dwidth - 165;

	    /* The CD might have been rendered over part of the track table.
	     * We keep a spare masked copy on the scrbuttons screen, and
	     * right here, we blit it back over so the CD goes behind,
	     * as we wished.
	     */
	    if (overlen > 0) BltMaskBitMapRastPort(bbm, 192,74, rp, 165,123, overlen, 23, (ABC|ABNC|ANBC), bmask);
	}
    }

    if (MasterIB->ib_GState[PLGAD_16]) GADNumber(rp, bbm, &MasterIB->ib_GadList[PLGAD_16], -1, MasterIB->ib_GState[PLGAD_16]);         /* Restore destroyed grid */
    if (MasterIB->ib_GState[PLGAD_17]) GADNumber(rp, bbm, &MasterIB->ib_GadList[PLGAD_17], -1, MasterIB->ib_GState[PLGAD_17]);
    if (MasterIB->ib_GState[PLGAD_18]) GADNumber(rp, bbm, &MasterIB->ib_GadList[PLGAD_18], -1, MasterIB->ib_GState[PLGAD_18]);

    return(0);
}




/************************** Update Digits in Head **************************/

static
GADTrackNum(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new)
{
struct GadDir gad;
UWORD state;

    state = MasterIB->ib_GState[PLGAD_COUNTER];

    if (state & 0x8000) return(0);

    gad.LeftEdge   = 20+(state & 0xfff);
    gad.TopEdge    = 0;
    gad.RenderData = g->RenderData;

    GADNumber(rp, bbm, &gad, old, new);

    return(g->Flags & GDFLAGS_BOXOVER);
}




/************************** Update Grid Selection **************************/

static
GADGridNumber(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new)
{
struct GadDir gad;

static BYTE gbox[] =
{
    INS_PEN,    43,9,
    INS_MOVE,   2,0,
    INS_DRAW,   22,0,
    INS_DRAW,   24,2,
    INS_DRAW,   24,14,
    INS_DRAW,   22,16,
    INS_DRAW,   2,16,
    INS_DRAW,   0,14,
    INS_DRAW,   0,2,
    INS_DRAW,   2,0,
    INS_END
};

    if ((old ^ new) & 0x4000)
    {
	CopyMem((char *)g, (char *)&gad, sizeof(struct GadDir));
	gad.BoxData = gbox;
	GADInsDraw(rp, &gad, (new & 0x4000 ? 1:0), new);
    }

    return(GADNumber(rp, bbm, g, old,new));
}



/***************************************************************************/
/*********************** Miscellaneous Functions ***************************/
/***************************************************************************/

/**************** Stop Play and Display Total Time on Disk *****************/


void
UpdatePlayTime( void )
{
    SubmitKeyStroke(KeyPressed = PKS_STOP|PKSF_PRESS);
    SubmitKeyStroke(KeyPressed = PKS_STOP|PKSF_RELEASE);
    WaitTOF();
}


/******************** Set Grid Entry to Entered Number *********************/

int
SetNum( void )
{
    UpdatePlayTime(); while (!ModifyPlayList(1));

    MasterIB->ib_GState[PLGAD_SHUFF] = 0;

    MasterIB->ib_D1 = 0;

    return(0);
}


/************************* Get Gadget's Keycode ****************************/

UWORD
GetBoxKey(struct IBuffer *ib, UWORD event)
{
UWORD ans;

    if (ib->ib_BoxNo >= 0)
    {
	ans = ib->ib_GadList[ib->ib_BoxNo].KeyTrans + (event & IECODE_UP_PREFIX);
	return(ans);
    }

    return(0);
}





/*================ Scroll Up/Down Functions for DoBoxMove =================*/

int
ScrollGridUp( void )
{
UBYTE orgpos;

    orgpos = MasterIB->ib_D0;

    MasterIB->ib_D0 += 5;

    UpdateGadgets();

    return((MasterIB->ib_D0 == orgpos ? 0:1));
}



int
ScrollGridDown( void )
{
int ans = 1;

    if (MasterIB->ib_D0 >= 5) MasterIB->ib_D0 -= 5;
    else                 ans = 0;

    UpdateGadgets();

    return(ans);
}




/*************************** Move Box Selection ****************************/

void
DoBoxMove(UWORD event)
{
UBYTE f;
struct GadDir *g;

    if ((KeyPressed & PKSF_STROKEDIR) == PKSF_PRESS) return;

    g = &MasterIB->ib_GadList[MasterIB->ib_BoxNo];
    f = g->Flags;

    if (MasterIB->ib_D1)
    {
	if (SetNum()) return;                                                                                      /* Error in setting number don't move */
	UpdatePlayTime();
    }

    if ((event == DIR_LEFT) && (MasterIB->ib_BoxNo == PLGAD_1)) if (ScrollGridDown())
    {
	MasterIB->ib_BoxNo = PLGAD_5;
	return;
    }

    if ((event == DIR_RIGHT) && (MasterIB->ib_BoxNo == PLGAD_20)) if (ScrollGridUp())
    {
	MasterIB->ib_BoxNo = PLGAD_16;
	return;
    }

    if ((event == DIR_UP) && (f & PLFLAGS_SCROLLUP)) if (ScrollGridDown())
    {
	return;
    }

    if ((event == DIR_DOWN) && (f & PLFLAGS_SCROLLDOWN)) if (ScrollGridUp())
    {
	return;
    }

    BoxMove( MasterIB, event );
    return;
}





/************************** Update Digits in Grid **************************/

VOID
DisplayGrid( void )
{
WORD   pos,i;
UBYTE *pe;
UWORD *gs;                                                                                         /* D0 is the position */

    pos = (MasterIB->ib_D0/5) * 5;

    if (pos + 19 >= PlayList->EntryCount)                                                                  /* Scroll upwards until the 20th position is filled with a blank */
    {
	while((pos + 14 >= PlayList->EntryCount) && (pos > 0)) pos-=5;

	if (pos < 0)  pos = 0;
	if (pos > 80) pos = 80;                                                                             /* Limit the hundred area */
    }

    MasterIB->ib_D0 = pos;

    for(i=0,pe=&PlayList->Entry[pos],gs=&MasterIB->ib_GState[PLGAD_1];
	(i<20)&&(pos<PlayList->EntryCount); i++,pe++,gs++,pos++)
    {
	if (!*pe)                   *gs = 0;
	else if (*pe & PLEF_ENABLE) *gs = *pe & PLEF_TRACK;
	else                        *gs = 0x8000 + (*pe & PLEF_TRACK);
    }

    for(; i<20; i++) *gs++ = 0;

    MasterIB->ib_D2 = 0;                                                                                         /* Set the lit number if it is playing */

    if (PlayerState.PlayState == PLS_SELECTED || PlayerState.PlayState >= PLS_PLAYING)
    {
	if ((PlayerState.ListIndex >= MasterIB->ib_D0) && (PlayerState.ListIndex < MasterIB->ib_D0+20))
	{
	    MasterIB->ib_D2 = PLGAD_1 + PlayerState.ListIndex - MasterIB->ib_D0;
	    MasterIB->ib_GState[ MasterIB->ib_D2 ] |= 0x4000;
	}
    }
}






/**************************** Randomize Tracks *****************************/

void
UnShuffleGrid( void )
{
WORD i;

    UpdatePlayTime(); while (!ModifyPlayList(1));

    MasterIB->ib_D0 = 0;

    PlayList->EntryCount = 0;
    for (i=0; i!=100; i++) PlayList->Entry[i] = UndoPlayList->Entry[i];
    PlayList->EntryCount = UndoPlayList->EntryCount;

    ModifyPlayList(0);
    UpdateGadgets();
    UpdateDisplay();
}

void
ShuffleGrid( void )
{
WORD    i, j, d, r;

    UpdatePlayTime(); while (!ModifyPlayList(1));

    for(i=PLGAD_1; i<=PLGAD_20; i++) MasterIB->ib_GState[i] = 0x0000;                                                        /* Blank grid before we display our changes */

    MasterIB->ib_D0 = 0;
    MasterIB->ib_GState[PLGAD_SHUFF] = 1;
    UpdateDisplay();

    if ( !ShuffleMode )
    {
	CopyMem(PlayList, UndoPlayList, sizeof(struct PlayList));
    }
    ShuffleMode = 1;

    PlayList->EntryCount = 0;
    for (i=0; i!=100; i++) PlayList->Entry[i] = 0;
    PlayList->EntryCount = UndoPlayList->EntryCount;

    for(i=0; i<UndoPlayList->EntryCount; i++)                                                                      /* Generate random list from 'undo' list. */
    {
	j=0;

	do r = RangeRand(UndoPlayList->EntryCount); while(++j<10 && PlayList->Entry[r]);

	if (j == 10)
	{
	    d = RangeRand(2);

	    while (PlayList->Entry[r])                                                                             /* Find the r'th unused entry. */
	    {
		if (d)
		{
		    if (--r < 0) r = UndoPlayList->EntryCount - 1;
		}

		else if (++r >= UndoPlayList->EntryCount) r = 0;
	    }
	}

	PlayList->Entry[r] = UndoPlayList->Entry[i];

	WaitTOF(); WaitTOF(); WaitTOF();

	UpdateGadgets();
	UpdateDisplay();
    }

    ModifyPlayList(0);
    /* Ensure the shuffle button has been lit for FLASHLENGTH frames,
     * knowing that we got 3 WaitTOF()s for every entry
     * in the UndoPlayList
     */
    for ( i = UndoPlayList->EntryCount * 3; i < FLASHLENGTH; i++ )
    {
	WaitTOF();
    }

    MasterIB->ib_GState[PLGAD_SHUFF] = 0;

    UpdateGadgets();
    UpdateDisplay();
}


/*********************** Initialize Head Positioner ************************/

void
InitTrackCounter( void )
{
    secperpixel = TOC[0].Summary.LeadOut.LSN/TCOUNTMAX;

    if (secperpixel == 0) secperpixel = 1;
}




/************************ Head Positioning Function ************************/

void
SetTrackCounter(int now)
{
WORD  loc, pos, move;

    if (PlayerState.PlayState == PLS_NUMENTRY);

    else if ((PlayerState.PlayState == PLS_SELECTED
	    || PlayerState.PlayMode == PLM_SKIPFWD
	    || PlayerState.PlayMode == PLM_SKIPREV)
	    && (PlayerState.PlayState != PLS_STOPPED ))
    {
	currsec = TOC[PlayerState.Track].Entry.Position.LSN;
    }

    else if (PlayerState.PlayState >= PLS_PLAYING)
    {
	if (qvalid) currsec = copyqcode.DiskPosition.LSN;
    }

    else currsec = 0;

    pos = TCOUNTMAX - (currsec/secperpixel);

    if (pos >= TCOUNTMAX) pos = TCOUNTMAX-1;
    if (pos < 0)          pos = 0;

    if (now) loc = pos;

    else
    {
	loc = MasterIB->ib_GState[PLGAD_COUNTER] & 0xfff;
	pos -= loc;

	if (pos < 0)
	{
	    move = -2;
	    if (pos >= -2) move = pos;
	    if (pos < -5)  move = -3;
	    if (pos < -10) move = -4;
	}

	else
	{
	    move = 2;
	    if (pos <= 2) move = pos;
	    if (pos > 5)  move = 3;
	    if (pos > 10) move = 4;
	}

	loc += move;
    }

    MasterIB->ib_GState[PLGAD_COUNTER] = loc + (PlayerState.PlayState >= PLS_PLAYING ? 0x4000:0);
}



/******************* Highlight/Unhighlight a Grid Entry ********************/

void
togglegnum( void )
{
int pos;

    pos = MasterIB->ib_D0 + (MasterIB->ib_BoxNo - PLGAD_1);

    if (pos >= PlayList->EntryCount) return;

    if (PlayList->Entry[pos] & PLEF_TRACK)
    {
	MasterIB->ib_GState[PLGAD_SHUFF] = 0;

	if (MasterIB->ib_D1) SetNum();

	PlayList->Entry[pos] ^= PLEF_ENABLE;

	UpdatePlayTime();
	UpdateGadgets();
    }
}




/********************** Clear/Reset Default PlayList ***********************/

void
ResetPlayList(int clear)
{
WORD           i;

    MasterIB->ib_GState[PLGAD_SHUFF] = 0;
    MasterIB->ib_D0 = 0;                                                                                                 /* Set playlist back to zero */

    UpdatePlayTime(); while (!ModifyPlayList(1));

    if (clear) PlayList->EntryCount = 0;

    else
    {
	for (i=0; i<TOC[0].Summary.LastTrack; i++) PlayList->Entry[i] = (UBYTE)PLEF_ENABLE | (i+1);

	PlayList->EntryCount = TOC[0].Summary.LastTrack;
    }

    ModifyPlayList(0);

    UpdateGadgets();
}
@


1.7
log
@First round of major improvements by Peter.
@
text
@d1 1
d24 1
d34 2
a35 1
#include <cdtv/debox_protos.h>
d40 1
a40 1
#include <cdtv/debox_pragmas.h>
d42 3
a44 3
#include "cdgs:include/internal/playerlibrary.h"
#include "cdgs:include/internal/player_protos.h"
#include "cdgs:include/internal/player_pragmas.h"
d54 1
a70 1
extern struct CycleIntInfo      intdata;
d72 3
a74 1
extern struct DisplayFrame     *CurrentF, *WorkF, MasterF;
a85 3
#if NUMBER_ENTRY
extern int                      NumericPadEnabled;
#endif
d92 2
a93 1
static NOOP();
a95 3
#if NUMBER_ENTRY
void   SetNumPad(void);
#endif
a99 2
static LONG diskstart;
static LONG disksec;
a101 3
static WORD enttrack, orgtrack;
static WORD enttrackpos = -1;

d119 1
a119 1
static UWORD d_CDG[]    = { 0,209,   48,209 };
d123 2
a124 2
struct GADNumberInfo d_GridNumberData = {

d130 1
a130 1
    };
d132 2
a133 2
struct GADNumberInfo d_MinNumberData = {

d139 1
a139 3
    };

struct GADNumberInfo d_SecNumberData = {
d141 2
d148 1
a148 1
    };
d150 2
a151 2
struct GADNumberInfo d_TrackNumberData = {

d157 1
a157 1
    };
d162 9
a170 1
struct GADSTDBox d_GridBoxInfo = {
a171 4
    -4,-3,33,23,
    { 1,1, 192,97 },
    { 1,1, 226,97 }
    };
a172 1

d174 4
a177 2
 * for different sized boxes.  The GadDir structure references
 * the appropriate one for each gadget.
d179 2
a180 2
BYTE d_GADBigButtons[] = {

d183 3
a185 2
    INS_MOVE,   2,1,
    INS_DRAW,   45,1,
d187 3
a189 1
    INS_DRAW,   45,25,
d191 3
a193 1
    INS_DRAW,   2,25,
d195 2
a196 1
    INS_DRAW,   2,1,
d198 1
a198 3
    };

BYTE d_GADSmallButtons[] = {
d200 2
d204 2
a205 2
    INS_MOVE,   2,1,
    INS_DRAW,   23,1,
d208 2
a209 2
    INS_MOVE,   24,2,
    INS_DRAW,   24,25,
d212 2
a213 2
    INS_MOVE,   23,26,
    INS_DRAW,   2,26,
d216 2
a217 2
    INS_MOVE,   1,25,
    INS_DRAW,   1,2,
d219 1
a219 1
    };
d221 2
a222 2
BYTE d_GADMedButtons[] = {

d225 2
a226 2
    INS_MOVE,   2,1,
    INS_DRAW,   41,1,
d229 2
a230 2
    INS_MOVE,   42,2,
    INS_DRAW,   42,25,
d233 2
a234 2
    INS_MOVE,   41,26,
    INS_DRAW,   2,26,
d237 2
a238 2
    INS_MOVE,   1,25,
    INS_DRAW,   1,2,
d240 1
a240 1
    };
d244 2
a245 2
struct GadDir PlayGADList[MAX_PLGAD + 1] = {

d255 1
a255 1
    { PLGAD_INTRO,   0x80, KEY_INTRO,    0,   6,       PLGAD_TIME,   PLGAD_1,      PLGAD_STOP,   PLGAD_REPEAT, 169, 208, 216, 234, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_INTRO  }, 
d257 1
a257 1
    { PLGAD_CDG,     0x80, KEY_CDG,      0,   2,       PLGAD_20,     PLGAD_CDG,    PLGAD_SHUFF,  PLGAD_REV,    283, 169, 330, 195, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_CDG    },
d283 1
a283 1
    };
d291 3
a293 2
static NOOP() {

d295 1
a295 1
    }
d301 26
a326 1
static void __regargs getcounterbase(WORD loc, WORD *x, WORD *y, WORD *dpos, WORD *dsize) {
d328 3
a330 15
static WORD pos[] = {

                -47,-34,-22,-11,-1,8,17,25,32,38,43,47,51,55,58,61,64,66,68,69,70,71
                };

    if (loc & 0x8000) {                                                                             /* Vertical movememt */

        *x = 20;
        if (loc >= 20)  *y = 43;
        else            *y = pos[loc & 0xfff];
        }

    else {                                                                                          /* Horizontal movement */

        loc &= 0xfff;
a331 4
        *y = 71;
        *x = 20+loc;
        }

d335 7
a341 7
    if (*y<0) {                                                                                     /* Clip the gadget if off screen */

        *dpos -= *y;
        *dsize += *y;
        *y = 0;     
        }
    }
d348 3
a350 2
static RCounter(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new) {

d357 11
a367 5
    if (old & 0x4000) {                                                                                                 /* old laser is on */

        dsize = 57;
        BltBitMap(bbm, 96, 209, rp->BitMap, 52, 128, 80, 16 ,0xc0, 0xff, NULL);
        }
a368 2
    if (dsize > 0) BltBitMap(bm, xloc, yloc, rp->BitMap, xloc, yloc, 80, dsize, 0xc0, 0xff, NULL);

d371 3
a373 1
    if (dsize > 0) {
d375 6
a380 1
        BltMaskBitMapRastPort(bbm, 96, dpos, rp, xloc, yloc, 96, dsize, (ABC|ABNC|ANBC), bmask);
d382 1
a382 4
        if (new & 0x4000) BltMaskBitMapRastPort(bbm, 97, 147, rp, xloc+12, yloc+37, 50, 34, (ABC|ABNC|ANBC), bmask);    /* new laser is on */
        }
        
    WorkF->gstate[PLGAD_TTRACK] = CurrentF->gstate[PLGAD_TTRACK] = 0;
d384 1
a384 1
    }
d401 3
a403 2
static RDisk(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new) {

d409 5
a413 5
static WORD             nums[] = { 

                            0,52,51,50,47,44,40,35,30,24,17,10,2,-7,-17,-28,
                            -43,-58,-74,-91,-112,-134,-157,-181,-206
                            };  
d415 1
a415 1
register int            overlen;
d420 4
a423 4
    if (new) {
    
        dpos   = 96;
        dwidth = 207;
d425 11
a435 11
        if (new < 24) {
    
            xloc = nums[new];
    
            if (xloc < 0) {

                dpos -= xloc;
                dwidth += xloc; 
                xloc = 0;
                }
    
d437 3
a439 1
            BltMaskBitMapRastPort(bbm, dpos, 209, rp, xloc, 128, dwidth, 18, (ABC|ABNC|ANBC), bmask);
a440 2
            overlen = xloc+dwidth - 165;
    
d446 3
a448 3
            if (overlen > 0) BltMaskBitMapRastPort(bbm, 192,74, rp, 165,123, overlen, 23, (ABC|ABNC|ANBC), bmask);
            }
        }
d450 3
a452 3
    if (MasterF.gstate[PLGAD_16]) GADNumber(rp, bbm, &MasterF.GadList[PLGAD_16], -1, MasterF.gstate[PLGAD_16]);         /* Restore destroyed grid */
    if (MasterF.gstate[PLGAD_17]) GADNumber(rp, bbm, &MasterF.GadList[PLGAD_17], -1, MasterF.gstate[PLGAD_17]);
    if (MasterF.gstate[PLGAD_18]) GADNumber(rp, bbm, &MasterF.GadList[PLGAD_18], -1, MasterF.gstate[PLGAD_18]);
d455 1
a455 1
    }
d462 3
a464 2
static GADTrackNum(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new) {

d467 2
a468 2
    
    state = MasterF.gstate[PLGAD_COUNTER];
d479 1
a479 1
    }
d486 3
a488 2
static GADGridNumber(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new) {

d491 2
a492 2
static BYTE gbox[] = {

d504 1
a504 1
    };
d506 6
a511 1
    if ((old ^ new) & 0x4000) {
a512 5
        CopyMem((char *)g, (char *)&gad, sizeof(struct GadDir));
        gad.BoxData = gbox;
        GADInsDraw(rp, &gad, (new & 0x4000 ? 1:0), new);
        }

d514 1
a514 1
    }
a521 1

d525 3
a527 2
void UpdatePlayTime() {

d531 4
a534 1
    }
d536 4
d541 1
d543 1
d545 2
a546 1
/************************* Get Gadget's Keycode ****************************/
a547 1
UWORD __regargs GetBoxKey(register struct DisplayFrame *mf, UWORD event) {
d549 1
a549 1
register UWORD ans;
d551 4
a554 1
    if (mf->BoxNo >= 0) {
d556 5
a560 3
        ans = mf->GadList[mf->BoxNo].KeyTrans + (event & IECODE_UP_PREFIX);
        return(ans);
        }
d563 1
a563 1
    }
d571 3
a573 2
ScrollGridUp() {

d576 1
a576 1
    orgpos = MasterF.D0;
d578 1
a578 1
    MasterF.D0 += 5;
d582 2
a583 3
    return((MasterF.D0 == orgpos ? 0:1));
    }

a585 1
ScrollGridDown() {
d587 3
d592 1
a592 1
    if (MasterF.D0 >= 5) MasterF.D0 -= 5;
d598 1
a598 1
    }
d605 5
a609 1
void DoBoxMove(UWORD event) {
a610 3
register UBYTE f;
register struct GadDir *g;

d613 1
a613 1
    g = &MasterF.GadList[MasterF.BoxNo];
d616 27
a642 38
    if (MasterF.D1) {
        if (SetNum()) return;                                                                                      /* Error in setting number don't move */
        UpdatePlayTime();
        }

    if ((event == DIR_LEFT) && (MasterF.BoxNo == PLGAD_1)) if (ScrollGridDown()) {

        MasterF.BoxNo = PLGAD_5;
#if NUMBER_ENTRY
        SetNumPad();
#endif
        return;
        }

    if ((event == DIR_RIGHT) && (MasterF.BoxNo == PLGAD_20)) if (ScrollGridUp()) {

        MasterF.BoxNo = PLGAD_16;
#if NUMBER_ENTRY
        SetNumPad();
#endif
        return;
        }

    if ((event == DIR_UP) && (f & PLFLAGS_SCROLLUP)) if (ScrollGridDown()) {

#if NUMBER_ENTRY
        SetNumPad();
#endif
        return;
        }

    if ((event == DIR_DOWN) && (f & PLFLAGS_SCROLLDOWN)) if (ScrollGridUp()) {

#if NUMBER_ENTRY
        SetNumPad();
#endif
        return;
        }
d644 1
a644 4
    BoxMove(&MasterF, event);
#if NUMBER_ENTRY
    SetNumPad();
#endif
d646 1
a646 1
    }
d654 26
a679 1
VOID DisplayGrid() {
a680 24
register WORD   pos,i;
register UBYTE *pe;
register UWORD *gs;                                                                                         /* D0 is the position */
    
    pos = (MasterF.D0/5) * 5;

    if (pos + 19 >= PlayList->EntryCount) {                                                                 /* Scroll upwards until the 20th posisition is filled with a blank */

        while((pos + 14 >= PlayList->EntryCount) && (pos > 0)) pos-=5;

        if (pos < 0)  pos = 0;
        if (pos > 80) pos = 80;                                                                             /* Limit the hundred area */
        }

    MasterF.D0 = pos;

    for(i=0,pe=&PlayList->Entry[pos],gs=&MasterF.gstate[PLGAD_1];
        (i<20)&&(pos<PlayList->EntryCount); i++,pe++,gs++,pos++) {

        if (!*pe)                   *gs = 0;
        else if (*pe & PLEF_ENABLE) *gs = *pe & PLEF_TRACK;
        else                        *gs = 0x8000 + (*pe & PLEF_TRACK);
        }

d683 1
a683 1
    MasterF.D2 = 0;                                                                                         /* Set the lit number if it is playing */
d686 8
a693 10
        if ((PlayerState.ListIndex >= MasterF.D0) && (PlayerState.ListIndex < MasterF.D0+20))
            MasterF.gstate[(MasterF.D2 = PLGAD_1 + PlayerState.ListIndex - MasterF.D0)] |= 0x4000;
    }   






/*================== Randomize Function for ShuffleGrid ===================*/
a694 1
UWORD rnd(int num) {
a695 2
    return(rand() % num);
    }
d702 3
a704 1
void UnShuffleGrid() {
d709 1
a709 1
    MasterF.D0 = 0;
d717 2
a718 5
    UpdateDisplay(); 
    ClearEvent(&input_data);
    }

void ShuffleGrid() {
d720 3
d727 4
a730 4
    for(i=PLGAD_1; i<=PLGAD_20; i++) MasterF.gstate[i] = 0x0000;                                                        /* Blank grid before we display our changes */
    
    MasterF.D0 = 0;
    MasterF.gstate[PLGAD_SHUFF] = 1;
d733 2
a734 1
    if ( !ShuffleMode ) {
d736 1
a736 1
	}
d743 16
a758 1
    for(i=0; i<UndoPlayList->EntryCount; i++) {                                                                     /* Generate random list from 'undo' list. */
d760 5
a764 1
        j=0;
d766 1
a766 20
        do r = rnd(UndoPlayList->EntryCount); while(++j<10 && PlayList->Entry[r]);

        if (j == 10) {

            d = rnd(2);

            while (PlayList->Entry[r]) {                                                                            /* Find the r'th unused entry. */

                if (d) {

                    if (--r < 0) r = UndoPlayList->EntryCount - 1;
                    }

                else if (++r >= UndoPlayList->EntryCount) r = 0;
                }
            }

        PlayList->Entry[r] = UndoPlayList->Entry[i];

        WaitTOF(); WaitTOF(); WaitTOF();
d768 3
a770 3
        UpdateGadgets();
        UpdateDisplay();
        }
d777 2
a778 1
    for ( i = UndoPlayList->EntryCount * 3; i < FLASHLENGTH; i++ ) {
d780 1
a780 1
	}
d782 1
a782 1
    MasterF.gstate[PLGAD_SHUFF] = 0;
d785 2
a786 3
    UpdateDisplay(); 
    ClearEvent(&input_data);
    }
d791 4
a794 5
void InitTrackCounter() {

    disksec     = TOC[0].Summary.LeadOut.LSN;

    secperpixel = disksec/TCOUNTMAX;
d797 1
a797 1
    }
d804 3
a806 2
void SetTrackCounter(int now) {

d812 11
a822 8
            || PlayerState.PlayMode == PLM_SKIPFWD
            || PlayerState.PlayMode == PLM_SKIPREV)
            && (PlayerState.PlayState != PLS_STOPPED )) {

        currsec = TOC[PlayerState.Track].Entry.Position.LSN;
        }

    else if (PlayerState.PlayState >= PLS_PLAYING) {
a823 3
        if (qvalid) currsec = copyqcode.DiskPosition.LSN;
        }

d830 1
a830 1
    
d833 4
a836 1
    else {
d838 7
a844 2
        loc = MasterF.gstate[PLGAD_COUNTER] & 0xfff;
        pos -= loc;
d846 7
a852 21
        if (pos < 0) {

            move = -2;
            if (pos >= -2) move = pos;
            if (pos < -5)  move = -3;
            if (pos < -10) move = -4;
            }

        else {

            move = 2;
            if (pos <= 2) move = pos;
            if (pos > 5)  move = 3;
            if (pos > 10) move = 4;
            }

        loc += move;
        }

    MasterF.gstate[PLGAD_COUNTER] = loc + (PlayerState.PlayState >= PLS_PLAYING ? 0x4000:0);
    }
d854 1
a854 47




/******************** Set Grid Entry to Entered Number *********************/

SetNum() {

    UpdatePlayTime(); while (!ModifyPlayList(1));

    MasterF.gstate[PLGAD_SHUFF] = 0;

    MasterF.D1 = 0;

#if NUMBER_ENTRY
    if (enttrackpos == -1) return(0);

    else {

        if ((enttrack <= TOC->Summary.LastTrack) && (enttrack >= 0)) {

            if (enttrack) {

                PlayList->Entry[enttrackpos] = enttrack | PLEF_ENABLE;
                }

            else {

                PlayList->Entry[enttrackpos] = 0;

                if (PlayList->EntryCount == enttrackpos + 1)                                                            /* Blanked track is at the end of list - Reduce playlistlen */ 
                    while(PlayList->EntryCount-1 >= 0 && !PlayList->Entry[PlayList->EntryCount-1])
                        --PlayList->EntryCount;
                }
            }

        else {                                                                                                          /* an error */

            PlayList->Entry[enttrackpos] = 0;
            ModifyPlayList(0);
            return(1);
            }
        }

    ModifyPlayList(0);
#endif
    return(0);
d857 2
a858 5



#if NUMBER_ENTRY
/********************** Enter a Digit into Position ************************/
a859 1
void enternum(int no) {
a860 31
int i;

    if ((MasterF.BoxNo >= PLGAD_1) && (MasterF.BoxNo <= PLGAD_20)) {       

        if (MasterF.D1) enttrack = (enttrack * 10 + no) % 100;

        else {

            enttrack = no;
            enttrackpos = MasterF.D0 + (MasterF.BoxNo - PLGAD_1);
            if (enttrackpos > 99) return;
            MasterF.D1 = 1;                                                                                             /* do something when moved */

            if (enttrackpos+1 >= PlayList->EntryCount) {

                UpdatePlayTime(); while (!ModifyPlayList(1));

                for (i=PlayList->EntryCount; i<=enttrackpos+1; i++) PlayList->Entry[i] = 0;

                PlayList->EntryCount = enttrackpos+1;
                ModifyPlayList(0);
                }

            UpdatePlayTime();
            }

        PlayList->Entry[enttrackpos] = enttrack;
        }
    }
#endif

a861 1

d864 3
a866 2
void togglegnum() {

d869 1
a869 1
    pos = MasterF.D0 + (MasterF.BoxNo - PLGAD_1);
d873 3
a875 1
    if (PlayList->Entry[pos] & PLEF_TRACK) {
d877 8
a884 10
        MasterF.gstate[PLGAD_SHUFF] = 0;
        
        if (MasterF.D1) SetNum();

        PlayList->Entry[pos] ^= PLEF_ENABLE;

        UpdatePlayTime();
        UpdateGadgets();
        }
    }
d891 4
a894 3
void ResetPlayList(int clear) {

register WORD           i;
d896 2
a897 2
    MasterF.gstate[PLGAD_SHUFF] = 0;
    MasterF.D0 = 0;                                                                                                 /* Set playlist back to zero */
d903 3
a905 1
    else {
d907 2
a908 4
        for (i=0; i<TOC[0].Summary.LastTrack; i++) PlayList->Entry[i] = (UBYTE)PLEF_ENABLE | (i+1);

        PlayList->EntryCount = TOC[0].Summary.LastTrack;
        }
d913 1
a913 30
    }


#if NUMBER_ENTRY
/********* Enable/Disable Numeric Keypad Based on Cursor Position **********/

void SetNumPad() {

    if (MasterF.BoxNo >= PLGAD_1 && MasterF.BoxNo <= PLGAD_20) PlayerNumPad(0);
    else                                                       PlayerNumPad(1);
    }



/************************ Configure Numeric Keypad *************************/

void PlayerNumPad(int on) {

#if 0
    cdio->io_Command = CDTV_FRONTPANEL;
    cdio->io_Data    = NULL;
    cdio->io_Offset  = 0;
    cdio->io_Length  = CDTV_PANEL_ENABLED | CDTV_PANEL_PLAY_EJECT | (on ? CDTV_PANEL_NUMERIC:0);
    DoIO(cdio);
#endif
    NumericPadEnabled = on;
    }

#endif

@


1.6
log
@no effective change.
@
text
@d74 1
d81 1
d83 1
d93 1
d95 1
d109 16
a124 12
static UWORD d_STOP[]   = {  0, 28,   0, 51 };
static UWORD d_REV[]    = { 25, 28,  25, 51 };
static UWORD d_PLAY[]   = { 50, 28,  50, 51 };
static UWORD d_FF[]     = { 75, 28,  75, 51 };
static UWORD d_PAUSE[]  = {100, 28, 100, 51 };

static UWORD d_TIME[]   = { 0,  74, 48,  74, 96, 74, 144, 74 };
static UWORD d_SHUFF[]  = { 0, 101, 48, 101 };
static UWORD d_GCLR[]   = { 0, 128, 48, 128 };
static UWORD d_REPEAT[] = { 0, 155, 48, 155, 155, 155, 203, 155 };
static UWORD d_INTRO[]  = { 0, 182, 48, 182,  96, 182, 144, 182, 192, 182 };
static UWORD d_CDG[]    = { 0, 209, 48, 209 };
d137 10
a146 1
struct GADNumberInfo d_TimerNumberData = {
d175 4
d198 24
a221 2
    INS_MOVE,   3,2,
    INS_DRAW,   18,2,
d223 3
a225 2
    INS_MOVE,   19,3,
    INS_DRAW,   19,17,
d227 3
a229 2
    INS_MOVE,   18,18,
    INS_DRAW,   3,18,
d231 2
a232 2
    INS_MOVE,   2,17,
    INS_DRAW,   2,3,
d243 10
a252 12
    { PLGAD_STOP,    0x80, KEY_STOP,     0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_GCLR,   PLGAD_REV,    24,  211, 49,  234, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_STOP   },
    { PLGAD_REV,     0x80, KEY_BACK,     0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_STOP,   PLGAD_PLAY,   49,  211, 74,  234, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_REV    },
    { PLGAD_PLAY,    0x80, KEY_PLAY,     0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_REV,    PLGAD_FF,     74,  211, 99,  234, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_PLAY   },
    { PLGAD_FF,      0x80, KEY_FWD,      0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_PLAY,   PLGAD_PAUSE,  99,  211, 124, 234, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_FF     },
    { PLGAD_PAUSE,   0x80, KEY_PAUSE,    0,   2,       PLGAD_NL,     PLGAD_NL,     PLGAD_FF,     PLGAD_INTRO,  124, 211, 150, 234, GADInsDraw, &d_GADSmallButtons, RNormal,       &d_PAUSE  },
    { PLGAD_TIME,    0x80, KEY_TIMEMODE, 0,   4,       PLGAD_16,     PLGAD_INTRO,  PLGAD_CDG,    PLGAD_SHUFF,  169, 169, 216, 195, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_TIME   },
    { PLGAD_SHUFF,   0x80, KEY_SHUFFLE,  0,   2,       PLGAD_18,     PLGAD_REPEAT, PLGAD_TIME,   PLGAD_GCLR,   231, 169, 278, 195, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_SHUFF   },
    { PLGAD_GCLR,    0x80, KEY_GCLR,     0,   2,       PLGAD_20,     PLGAD_CDG,    PLGAD_SHUFF,  PLGAD_STOP,   283, 169, 330, 195, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_GCLR   },
    { PLGAD_INTRO,   0x80, KEY_INTRO,    0,   5,       PLGAD_TIME,   PLGAD_1,      PLGAD_PAUSE,  PLGAD_REPEAT, 169, 208, 216, 234, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_INTRO  }, 
    { PLGAD_REPEAT,  0x80, KEY_REPEAT,   0,   4,       PLGAD_SHUFF,  PLGAD_3,      PLGAD_INTRO,  PLGAD_CDG,    221, 208, 268, 234, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_REPEAT },
    { PLGAD_CDG,     0x80, KEY_CDG,      0,   2,       PLGAD_GCLR,   PLGAD_5,      PLGAD_REPEAT, PLGAD_TIME,   283, 208, 330, 234, GADInsDraw, &d_GADBigButtons,   RNormal,       &d_CDG    },
    { PLGAD_1,       0x05, KEY_GBUTTON,  0, 255,       PLGAD_INTRO,  PLGAD_6,      PLGAD_CDG,    PLGAD_2,      169, 57,  193, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
d255 2
a256 2
    { PLGAD_4,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_CDG,    PLGAD_9,      PLGAD_3,      PLGAD_5,      271, 57,  295, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_5,       0x01, KEY_GBUTTON,  0, 255,       PLGAD_CDG,    PLGAD_10,     PLGAD_4,      PLGAD_6,      305, 57,  329, 73,  GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
d271 4
a274 3
    { PLGAD_20,      0x0A, KEY_GBUTTON,  0, 255,       PLGAD_15,     PLGAD_GCLR,   PLGAD_19,     PLGAD_TIME,   305, 126, 329, 142, GADSTDBox,  &d_GridBoxInfo,     GADGridNumber, &d_GridNumberData  },
    { PLGAD_MIN,     0x00, 0,            0, 101,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     50,  173, 79,  191, NOOP,       NULL,               GADNumber,     &d_TimerNumberData },
    { PLGAD_SEC,     0x00, 0,            0, 101,       PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     PLGAD_NL,     90,  173, 119, 191, NOOP,       NULL,               GADNumber,     &d_TimerNumberData },
d367 9
d391 1
d410 1
d415 5
d579 1
d581 1
d588 1
d590 1
d596 1
d598 1
d604 1
d606 1
d611 1
d613 1
d675 17
d701 1
a701 1
    MasterF.gstate[PLGAD_SHUFF] ^= 1;                                                                                   /* Toggle */
d704 4
a707 1
    if (MasterF.gstate[PLGAD_SHUFF]) {                                                                                  /* Here we need to save the list and reshuffle the grid.  If we started in shuffle mode, then this is a re-shuffle, so we don't copy to the undo buffer in that case. */
d709 15
a723 1
        CopyMem(PlayList, UndoPlayList, sizeof(struct PlayList));
d725 1
a725 17
        PlayList->EntryCount = 0;
        for (i=0; i!=100; i++) PlayList->Entry[i] = 0;
        PlayList->EntryCount = UndoPlayList->EntryCount;

        for(i=0; i<UndoPlayList->EntryCount; i++) {                                                                     /* Generate random list from 'undo' list. */

            j=0;

            do r = rnd(UndoPlayList->EntryCount); while(++j<10 && PlayList->Entry[r]);

            if (j == 10) {

                d = rnd(2);

                while (PlayList->Entry[r]) {                                                                            /* Find the r'th unused entry. */

                    if (d) {
d727 2
a728 2
                        if (--r < 0) r = UndoPlayList->EntryCount - 1;
                        }
d730 1
a730 2
                    else if (++r >= UndoPlayList->EntryCount) r = 0;
                    }
d732 1
d734 1
a734 1
            PlayList->Entry[r] = UndoPlayList->Entry[i];
d736 1
a736 1
            WaitTOF(); WaitTOF(); WaitTOF();
d738 2
a739 3
            UpdateGadgets();
            UpdateDisplay();
            }
d742 8
a749 1
    else {
d751 1
a751 6
        UpdateDisplay();                                                                                                /* Restore the play list */

        PlayList->EntryCount = 0;
        for (i=0; i!=100; i++) PlayList->Entry[i] = UndoPlayList->Entry[i];
        PlayList->EntryCount = UndoPlayList->EntryCount;
        }
a752 1
    ModifyPlayList(0);
a758 3



d784 1
a784 1
            && MasterF.gstate[PLGAD_TTRACK] != 100) {
d844 1
d875 1
d882 1
d916 1
a919 1

d948 1
a948 1
void ResetPlayList(int dogad, int clear) {
a954 7
    if (dogad) {

        intdata.cintd_VCountDown = 5;
        MasterF.gstate[PLGAD_GCLR] = 1; 
        UpdateDisplay(); 
        }

a968 71
    
    if (dogad) {

        while(intdata.cintd_VCountDown) WaitTOF();
        MasterF.gstate[PLGAD_GCLR] = 0;
        UpdateDisplay();
        }
    }




/******************** Highlight/Unhighligh Entire Grid *********************/

void BlankPlayList(int dogad, int clear) {

register WORD   i;

    MasterF.gstate[PLGAD_SHUFF] = 0;

    if (dogad) {

        intdata.cintd_VCountDown = 5;
        MasterF.gstate[ PLGAD_GCLR ] = 1; 
        UpdateDisplay(); 
        }

    UpdatePlayTime(); while (!ModifyPlayList(1));

    if (clear) for (i=0; i<PlayList->EntryCount; i++) PlayList->Entry[i] &= (UBYTE)PLEF_TRACK;
    
    else       for (i=0; i<PlayList->EntryCount; i++) PlayList->Entry[i] |= (UBYTE)PLEF_ENABLE;
    
    ModifyPlayList(0);

    UpdateGadgets();

    if (dogad) {

        while(intdata.cintd_VCountDown) WaitTOF();
        MasterF.gstate[PLGAD_GCLR] = 0;
        UpdateDisplay();
        }
    }




/***************** Determine/Execute CLR Gadget Function *******************/

void DoGCLRGad() {

register WORD   i;

    if (PlayList->EntryCount) {

        for(i=0; i<PlayList->EntryCount && (PlayList->Entry[i] & PLEF_ENABLE); i++);

        if (i == PlayList->EntryCount) BlankPlayList(1, 1);
        else {

            for(i=0; i<PlayList->EntryCount && !(PlayList->Entry[i] & PLEF_ENABLE); i++);

            if (i == PlayList->EntryCount) ResetPlayList(1, 1);
            else                           BlankPlayList(1, 0);
            }
        }

    else ResetPlayList(1, 0);

    UpdatePlayTime();
d972 1
a972 3



a982 1

d997 1
@


1.5
log
@Revised for cd.device.
@
text
@d695 4
a698 4
    else if ((PlayerState.PlayState  == PLS_SELECTED
        || PlayerState.PlayMode == PLM_SKIPFWD
        || PlayerState.PlayMode == PLM_SKIPREV)
        && MasterF.gstate[PLGAD_TTRACK] != 100) {
@


1.4
log
@No effective change.
@
text
@d17 1
a17 1
#include <cdtv:include/cdtv/cdtv.h>
d75 4
a78 3
extern struct CDTOC            *TOC;
extern struct CDSubQ            subq;
extern struct IOStdReq         *cdio, *cdsubq;
d453 1
a453 1
    if(mf->BoxNo >= 0) {
a672 16
/********************* Check Validity of Q-Code Packet *********************/

int subq_valid(void) {

    return (
           !cdsubq->io_Error
        && subq.Track == PlayerState.Track
        && subq.DiskPosition.Raw
        && (subq.Status == SQSTAT_PLAYING || subq.Status == SQSTAT_PAUSED)
        && (subq.AddrCtrl & ADRCTL_MASK) == ADRCTL_POSITION
        );

    }



d677 1
a677 1
    disksec     = ((TOC[0].Position.Raw >> 16) & 0xff) * 60 + ((TOC[0].Position.Raw >> 8) & 0xff);
d700 1
a700 2
        currsec = ((TOC[PlayerState.Track].Position.Raw >> 16) & 0xff) * 60
                + ((TOC[PlayerState.Track].Position.Raw >> 8) & 0xff);
d705 1
a705 1
        if (subq_valid()) currsec = ((subq.DiskPosition.Raw >> 16) & 0xff) * 60 + ((subq.DiskPosition.Raw >> 8) & 0xff);
d762 1
a762 1
        if ((enttrack <= TOC->LastTrack) && (enttrack >= 0)) {
d879 1
a879 1
        for (i=0; i<TOC[0].LastTrack; i++) PlayList->Entry[i] = (UBYTE)PLEF_ENABLE | (i+1);
d881 1
a881 1
        PlayList->EntryCount = TOC[0].LastTrack;
d979 1
d984 2
a985 2
    SafeDoIO(cdio);

@


1.3
log
@Does not allow highlighted box to changed when the A button is being held down.
@
text
@d39 3
a41 3
#include "cdtv:include/internal/playerresource.h"
#include "cdtv:include/internal/player_protos.h"
#include "cdtv:include/internal/player_pragmas.h"
@


1.2
log
@Cleaned up code.  Put headers on functions.
@
text
@d17 1
a17 1
#include <cr2:dev/cdtv.h>
d39 3
a41 3
#include "cr2:playerresource/playerresource.h"
#include "cr2:playerresource/player_protos.h"
#include "cr2:playerresource/player_pragmas.h"
d80 1
d438 2
a439 2
    SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
    SubmitKeyStroke(PKS_STOP|PKSF_RELEASE);
d503 2
@


1.1
log
@Initial revision
@
text
@a0 11
/* :ts=4
*
*       GADGETS.c -- screen works
*
*       William A. Ware                                                 AC01
*
*****************************************************************************
*   This information is CONFIDENTIAL and PROPRIETARY                                            *
*   Copyright (C) 1991, Silent Software, Incorporated.                                          *
*   All Rights Reserved.                                                                                                        *
****************************************************************************/
d17 1
a17 1
#include <cdtv/cdtv.h>
d44 1
a44 1
ULONG __asm GetKey  (register __a1 struct InputData *id);
d46 1
d48 1
a48 7
extern GADInsDraw( struct RastPort *rp, struct GadDir *g, int val, UWORD state );
extern GADNumber(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new);
extern GADSTDBox( struct RastPort *rp, struct GadDir *g, int val, UWORD state);
extern RNormal( struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new);
extern GADScrSave( struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new);

extern GAD2SRender( struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new);
d50 4
a53 1
extern __regargs PowerTen(register UBYTE dig);
d55 2
a56 1
extern UWORD volatile       __far vhposr;   /*  Custom chip register.  */
d58 2
d65 1
d67 15
a81 2
extern struct CycleIntInfo  intdata;
extern struct CDTVInputInfo input_data;
d83 1
a83 4
extern struct BMInfo    *bmi;
extern struct BitMap    *bm;
extern UBYTE            *mask;
extern struct View      *view, *oldview;
d85 2
a86 1
extern struct DisplayFrame *CurrentF, *WorkF, MasterF;
d88 2
d91 1
a91 2
extern void UpdateGadgets(void);
extern void UpdatePlayTime(void);
d93 3
a95 2
extern void SetNumPad(void);
extern void PlayerNumPad(int);
d97 2
a98 4
/* button bitmap */
extern struct BMInfo    *bbmi;
extern struct BitMap    *bbm;
extern UBYTE            *bmask;
d100 1
a100 1
extern struct RastPort  Rp;
d102 12
a113 29
extern WORD          playlistlen, activelistlen, curlistidx, undolistlen;
extern BYTE          playing, paused, scanning, scandir, timemode;

extern struct PlayerBase    *PlayerBase;
extern struct PlayerState    PlayerState;
extern struct PlayList      *PlayList;
extern struct PlayList      *UndoPlayList;

extern struct CDTOC         *TOC;
extern struct CDSubQ        subq;

extern struct IOStdReq      *cdsubq;

/*--------------------------------------*/

struct GadInfo {

    UBYTE   CurrentPic;
    UBYTE   Flags;
    };

struct GadHeader {

    struct GadDir   *gdlist;
    struct GadInfo  *gdinfo;
    };

/*--------------------------------------*/
static NOOP();
d115 1
a115 1
static GADTrackNum();
a116 24
static GADGridNumber();
static CDisp();
static RDisk(),RCounter();

/* PLGAD_STOP   */
static UWORD d_STOP[]  = {  0, 28,   0, 51 };
static UWORD d_REV[]   = { 25, 28,  25, 51 };
static UWORD d_PLAY[]  = { 50, 28,  50, 51 };
static UWORD d_FF[]    = { 75, 28,  75, 51 };
static UWORD d_PAUSE[] = {100, 28, 100, 51 };

static UWORD d_TIME[]  = { 0,  74, 48,  74, 96, 74, 144, 74 };
static UWORD d_SHUFF[] = { 0, 101, 48, 101 };
static UWORD d_GCLR[]  = { 0, 128, 48, 128 };
static UWORD d_REPEAT[]= { 0, 155, 48, 155, 155, 155, 203, 155 };
static UWORD d_INTRO[] = { 0, 182, 48, 182,  96, 182, 144, 182, 192, 182 };


ULONG currsec;

/*------------------------------------------------------------------*/
/* Data for the different number sets                               */
/*------------------------------------------------------------------*/

d145 1
a145 1
/*-------------- BOX --------------*/
d188 1
a188 3
static UWORD d_CDG[]    = { 0, 209, 48, 209 };

#define TCOUNTMAX   59                                  /* Max pos for track counter */
d233 5
d245 109
d355 1
a355 4
/* if num >= max move the number to < max value by max the highest digit
 * first then moveing on to the lower digits until the num < max
 * might want to turn into digit math - 68000 ins 
 */
d357 2
a358 17
static MaxNumSpecial(register int num, int max) {

register WORD ndig = 0,n,t,t1;
    
    if (num <= max) return(num);

    while(PowerTen(++ndig) <= max);

    num = num % PowerTen(ndig);

    ndig--;

    while((num > max) && ((t = PowerTen( ndig )) > 0)) {

        n = ((max % (t1=PowerTen(ndig+1)))/t) * t;                                                  /* n = digit of max */
        num = num-((num % t1)/t)*t + n;
        ndig--;
d361 5
a365 1
    return(num);
d367 2
a368 2
        
        
d371 1
d392 4
d417 1
a417 1
        CopyMem( (char *)g, (char *)&gad, sizeof(struct GadDir));
d422 1
a422 1
    return( GADNumber( rp, bbm, g, old,new ) );
d427 3
a429 3
/*******
* Disk *
*******/
a430 1
static RDisk(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new) {
d432 1
a432 2
extern struct BitMap   *bm;
extern UBYTE           *bmask;
a433 2
WORD                    xloc,dpos,dwidth;
static WORD             nums[] = { 
d435 1
a435 3
    0,52,51,50,47,44,40,35,30,24,17,10,2,-7,-17,-28,
    -43,-58,-74,-91,-112,-134,-157,-181,-206
    };  
d437 3
a439 33
register int            overlen;

    BltBitMap(bm, 0, 128, rp->BitMap, 0, 128, 267, 18, 0xc0, 0xff, NULL);                                       /* erase old */

    if (!new) goto upnums;
    
    dpos   = 96;
    dwidth = 207;

    if (new >= 24) goto upnums; 
    
    xloc = nums[new];
    
    if (xloc < 0) {

        dpos -= xloc;
        dwidth += xloc; 
        xloc = 0;
        }
    
    BltMaskBitMapRastPort(bbm, dpos, 209, rp, xloc, 128, dwidth, 18, (ABC|ABNC|ANBC), bmask);

    overlen = xloc+dwidth - 165;
    
    if (overlen > 0) BltMaskBitMapRastPort(bbm, 192,74, rp, 165,123, overlen, 23, (ABC|ABNC|ANBC), bmask);

upnums:

    if (MasterF.gstate[PLGAD_16]) GADNumber(rp, bbm, &MasterF.GadList[PLGAD_16], -1, MasterF.gstate[PLGAD_16]);
    if (MasterF.gstate[PLGAD_17]) GADNumber(rp, bbm, &MasterF.GadList[PLGAD_17], -1, MasterF.gstate[PLGAD_17]);
    if (MasterF.gstate[PLGAD_18]) GADNumber(rp, bbm, &MasterF.GadList[PLGAD_18], -1, MasterF.gstate[PLGAD_18]);

    return(0);
d445 1
a445 3
/**********
* COUNTER *
**********/
d447 1
a447 1
static void __regargs getcounterbase(WORD loc, WORD *x, WORD *y, WORD *dpos, WORD *dsize) {
d449 1
a449 4
static WORD pos[] = {
    -47,-34,
    -22,-11,-1,8,17,25,32,38,43,47,51,55,58,61,64,66,68,69,70,71
    };
d451 1
a451 1
    if (loc & 0x8000) {
d453 2
a454 3
        *x = 20;                                                                                                /* Begin lowered */
        if (loc >= 20)  *y = 43;
        else            *y = pos[loc & 0xfff];
d457 1
a457 17
    else {

        loc &= 0xfff;

        *y = 71;
        *x = 20+loc;
        }

    *dpos  = 101;
    *dsize = 45;

    if (*y<0) {

        *dpos -= *y;
        *dsize += *y;
        *y = 0;     
        }
a460 5
static RCounter(struct RastPort *rp, struct BitMap *bbm, struct GadDir *g, WORD old, WORD new) {

extern struct BitMap    *bm;
extern UBYTE            *bmask;
WORD                     xloc, yloc, dpos, dsize;
a462 1
    getcounterbase(old, &xloc, &yloc, &dpos, &dsize);                                                               /* erase old */
d464 1
a464 4
    if (old & 0x4000) {                                                                                             /* old laser is on */
        dsize = 57;
        BltBitMap(bbm, 96, 209, rp->BitMap, 52, 128, 80, 16 ,0xc0, 0xff, NULL);
        }
d466 1
a466 1
    if (dsize>0) BltBitMap(bm, xloc, yloc, rp->BitMap, xloc, yloc, 80, dsize, 0xc0, 0xff, NULL);
d468 1
a468 1
    getcounterbase(new, &xloc, &yloc, &dpos, &dsize);
d470 1
a470 1
    if (dsize <= 0) goto upnums;
d472 1
a472 1
    BltMaskBitMapRastPort(bbm, 96, dpos, rp, xloc, yloc, 96, dsize, (ABC|ABNC|ANBC), bmask);
d474 1
a474 3
    if (new & 0x4000) BltMaskBitMapRastPort(bbm, 97, 147, rp, xloc+12, yloc+37, 50, 34, (ABC|ABNC|ANBC), bmask);    /* new laser is on */
        
upnums:
d476 1
a476 2
    WorkF->gstate[PLGAD_TTRACK] = CurrentF->gstate[PLGAD_TTRACK] = 0;
    return(0);
d481 1
a481 1
UWORD __regargs GetBoxKey(register struct DisplayFrame *mf, UWORD event) {
d483 1
a483 1
register UWORD ans;
d485 2
a486 1
    if(mf->BoxNo >= 0) {
d488 1
a488 3
        ans = mf->GadList[mf->BoxNo].KeyTrans + (event & IECODE_UP_PREFIX);
        return(ans);
        }
d490 1
a490 1
    return(0);
d495 3
d543 2
a544 1
/*----------------------------- GRID ------------------------*/
d546 1
a546 3
/* Display grid is responsible for getting numbers on the screen.
 * The position is set in MasterF.D0
 */
d566 2
a567 1
    for(i=0,pe=&PlayList->Entry[pos],gs=&MasterF.gstate[PLGAD_1]; (i<20)&&(pos<PlayList->EntryCount); i++,pe++,gs++,pos++) {
a585 1
ScrollGridUp() {
a586 1
UBYTE orgpos;
d588 1
a588 1
    orgpos = MasterF.D0;
d590 1
a590 1
    MasterF.D0 += 5;
d592 1
a592 17
    UpdateGadgets();

    return((MasterF.D0 == orgpos ? 0:1));
    }



ScrollGridDown() {

int ans = 1;

    if (MasterF.D0 >= 5) MasterF.D0 -= 5;
    else                 ans = 0;

    UpdateGadgets();

    return(ans);
d598 1
a598 8
/* 
 * returns the new playlistlen 
 */

UWORD rnd(int num) {

    return(rand() % num);
    }
a599 2


a667 6
/*---------------------- Track counter ---------------------*/

static LONG diskstart;
static LONG disksec;
static LONG secperpixel;

d669 1
d685 2
a688 2
    GetPlayerState(&PlayerState);

d698 3
d705 3
a707 1
    if ((PlayerState.PlayState  == PLS_SELECTED
d761 1
a762 6
/*----------------------------- entering numbers ---------------------*/


static WORD enttrack,orgtrack;
static WORD enttrackpos = -1;

a789 7

            if (PlayList->EntryCount) {

                if (curlistidx < 0) curlistidx = 0;
                }

            else curlistidx = -1;
d806 3
d844 2
d870 2
d912 2
d947 3
a953 2
    MasterF.gstate[PLGAD_SHUFF] = 0;

d977 20
a996 1
void UpdatePlayTime() {
d998 1
a998 3
    SubmitKeyStroke(PKS_STOP|PKSF_PRESS);
    SubmitKeyStroke(PKS_STOP|PKSF_RELEASE);
    WaitTOF();
d1000 1
@
