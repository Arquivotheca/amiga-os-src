head     39.16;
branch   ;
access   ;
symbols  ;
locks    davidj:39.16; strict;
comment  @ * @;


39.16
date     93.05.26.13.47.58;  author davidj;  state Exp;
branches ;
next     39.15;

39.15
date     93.04.13.17.12.54;  author davidj;  state Exp;
branches ;
next     39.14;

39.14
date     93.04.05.14.38.31;  author davidj;  state Exp;
branches ;
next     39.13;

39.13
date     93.02.15.10.51.39;  author davidj;  state Exp;
branches ;
next     39.12;

39.12
date     92.12.01.12.18.31;  author davidj;  state Exp;
branches ;
next     39.11;

39.11
date     92.08.27.16.02.54;  author davidj;  state Exp;
branches ;
next     39.10;

39.10
date     92.08.03.08.31.46;  author davidj;  state Exp;
branches ;
next     39.9;

39.9
date     92.07.30.22.41.25;  author davidj;  state Exp;
branches ;
next     39.8;

39.8
date     92.07.29.09.10.40;  author davidj;  state Exp;
branches ;
next     39.7;

39.7
date     92.07.23.16.57.04;  author davidj;  state Exp;
branches ;
next     39.6;

39.6
date     92.07.14.11.55.04;  author davidj;  state Exp;
branches ;
next     39.5;

39.5
date     92.06.26.01.15.53;  author davidj;  state Exp;
branches ;
next     39.4;

39.4
date     92.06.19.03.58.02;  author davidj;  state Exp;
branches ;
next     39.3;

39.3
date     92.06.03.13.48.33;  author davidj;  state Exp;
branches ;
next     39.2;

39.2
date     92.06.03.01.31.12;  author davidj;  state Exp;
branches ;
next     39.1;

39.1
date     92.06.02.11.12.51;  author davidj;  state Exp;
branches ;
next     39.0;

39.0
date     92.06.01.16.27.41;  author davidj;  state Exp;
branches ;
next     ;


desc
@initial RCS
@


39.16
log
@optimized
@
text
@/* dispatch.c
 *
 */

#include "classbase.h"

/*****************************************************************************/

#define	DB(x)	;

/*****************************************************************************/

static ULONG bestmodeid (struct ClassBase * cb, ULONG data,...)
{
    return BestModeIDA ((struct TagItem *) & data);
}

/*****************************************************************************/

static ULONG notifyAttrChanges (struct ClassBase * cb, Object * o, VOID * ginfo, ULONG flags, ULONG tag1,...)
{
    return DoMethod (o, OM_NOTIFY, &tag1, ginfo, flags);
}

/*****************************************************************************/

static void freeExtraInfo (struct ClassBase * cb, struct localData * lod)
{
    if (lod->lod_NumAlloc)
    {
	LONG i;

	for (i = (LONG) (lod->lod_NumAlloc - 1); i >= 0; i--)
	    ReleasePen (lod->lod_ColorMap, lod->lod_Allocated[i]);
	lod->lod_NumAlloc = 0L;
    }

    if ((lod->lod_BMap) && !(lod->lod_Flags & LODF_SAMEBM))
    {
	WaitBlit ();
	FreeBitMap (lod->lod_BMap);
	lod->lod_BMap = NULL;
    }
}

/*****************************************************************************/

static struct ColorMap *GetObjectColorMap (struct ClassBase * cb, Class * cl, Object * o)
{
    struct localData *lod = INST_DATA (cl, o);
    struct ColorMap *cm = NULL;
    ULONG i, r, g, b;

    if (lod->lod_Colors)
    {
	/* Get a color map */
	if (cm = GetColorMap (lod->lod_NumColors))
	{
	    /* Set the colors */
	    for (i = 0; i < lod->lod_NumColors; i++)
	    {
		r = lod->lod_CRegs[i * 3 + 0];
		g = lod->lod_CRegs[i * 3 + 1];
		b = lod->lod_CRegs[i * 3 + 2];
		SetRGB32CM (cm, i, r, g, b);
	    }
	}
    }
    return (cm);
}

/*****************************************************************************/

static ULONG copyMethod (struct ClassBase * cb, Class * cl, Object * o, struct dtGeneral * msg)
{
    struct localData *lod = INST_DATA (cl, o);
    struct IFFHandle *iff;
    BOOL success = FALSE;

    if (iff = AllocIFF ())
    {
	if (iff->iff_Stream = (ULONG) OpenClipboard (0L))
	{
	    InitIFFasClip (iff);
	    success = writeObject (cb, iff, o, lod);
	    CloseClipboard ((struct ClipboardHandle *) iff->iff_Stream);
	}
	FreeIFF (iff);
    }
    return ((ULONG) success);
}

/*****************************************************************************/

static ULONG writeMethod (struct ClassBase * cb, Class * cl, Object * o, struct dtWrite * msg)
{
    struct localData *lod = INST_DATA (cl, o);
    struct IFFHandle *iff;
    BOOL success = FALSE;

    if (iff = AllocIFF ())
    {
	if (iff->iff_Stream = msg->dtw_FileHandle)
	{
	    InitIFFasDOS (iff);
	    success = writeObject (cb, iff, o, lod);
	}
	FreeIFF (iff);
    }
    return ((ULONG) success);
}

/*****************************************************************************/

/* Methods we support */
ULONG m[] =
{
    OM_NEW,
    OM_GET,
    OM_SET,
    OM_UPDATE,
    OM_DISPOSE,

    GM_LAYOUT,
    GM_HITTEST,
    GM_GOACTIVE,
    GM_HANDLEINPUT,
    GM_RENDER,

    DTM_FRAMEBOX,
    DTM_SELECT,
    DTM_CLEARSELECTED,
    DTM_COPY,
    DTM_PRINT,
    DTM_WRITE,

    ~0,
};

/*****************************************************************************/

/* Inquire attribute of an object */
static ULONG getPictureDTAttr (struct ClassBase * cb, Class * cl, Object * o, struct opGet * msg)
{
    struct localData *lod = INST_DATA (cl, o);

    switch (msg->opg_AttrID)
    {
	case DTA_Methods:
	    *msg->opg_Storage = (ULONG) m;
	    break;

	case PDTA_ModeID:
	    *msg->opg_Storage = lod->lod_ModeID;
	    break;

	case PDTA_BitMapHeader:
	    *msg->opg_Storage = (ULONG) & lod->lod_BMHD;
	    break;

#ifdef	PDTA_DestBitMap
	case PDTA_DestBitMap:
#endif
	case PDTA_ClassBitMap:
	case PDTA_BitMap:
	    *msg->opg_Storage = (ULONG) lod->lod_BMap;
	    break;

	case PDTA_ColorRegisters:
	    *msg->opg_Storage = (ULONG) lod->lod_Colors;
	    break;

	case PDTA_CRegs:
	    *msg->opg_Storage = (ULONG) lod->lod_CRegs;
	    break;

	case PDTA_GRegs:
	    *msg->opg_Storage = (ULONG) lod->lod_GRegs;
	    break;

	case PDTA_ColorTable:
	    *msg->opg_Storage = (ULONG) lod->lod_ColorTable;
	    break;

	case PDTA_ColorTable2:
	    *msg->opg_Storage = (ULONG) lod->lod_ColorTable2;
	    break;

	case PDTA_Allocated:
	    *msg->opg_Storage = (ULONG) lod->lod_Allocated;
	    break;

	case PDTA_NumColors:
	    *msg->opg_Storage = (ULONG) lod->lod_NumColors;
	    break;

	case PDTA_NumAlloc:
	    *msg->opg_Storage = (ULONG) lod->lod_NumAlloc;
	    break;

	case PDTA_Grab:
	    *msg->opg_Storage = (ULONG) & lod->lod_Point;
	    break;

	default:
	    return (DoSuperMethodA (cl, o, msg));
    }

    return (1L);
}

/*****************************************************************************/

/* Set attributes of an object */
static ULONG setPictureDTAttrs (struct ClassBase * cb, Class * cl, Object * o, struct opSet * msg)
{
    struct TagItem *tags = msg->ops_AttrList;
    struct localData *lod;
    struct TagItem *tstate;
    struct TagItem *tag;
    ULONG refresh = 0L;
    struct BitMap *obm;
    ULONG tidata;
    WORD ncolors;
    ULONG modeid;

    lod = INST_DATA (cl, o);

    ncolors = lod->lod_NumColors;
    modeid = lod->lod_ModeID;
    obm = lod->lod_SourceBMap;

    /* process rest */
    tstate = tags;
    while (tag = NextTagItem (&tstate))
    {
	tidata = tag->ti_Data;
	switch (tag->ti_Tag)
	{
	    case OBP_Precision:
		lod->lod_Precision = tidata;
		break;

	    case PDTA_Remap:
		if (tidata)
		    lod->lod_Flags |= LODF_REMAP;
		else
		    lod->lod_Flags &= ~LODF_REMAP;
		break;

	    case PDTA_NumSparse:
		lod->lod_NumSparse = (UWORD) tidata;
		if (tidata)
		    lod->lod_Flags |= LODF_SPARSE;
		else
		    lod->lod_Flags &= ~LODF_SPARSE;
		break;

	    case PDTA_SparseTable:
		lod->lod_SparseTable = (UBYTE *) tidata;
		break;

	    case PDTA_FreeSourceBitMap:
		if (tidata)
		    lod->lod_Flags |= LODF_FREESRC;
		else
		    lod->lod_Flags &= ~LODF_FREESRC;
		break;

	    case PDTA_ModeID:
		lod->lod_ModeID = tidata;
		break;

	    case PDTA_NumColors:
		lod->lod_NumColors = (WORD) tidata;
		break;

		/* Remember shared data!!! Our subclass is telling us about the new bitmap. */
	    case PDTA_BitMap:
		lod->lod_OurBMap = (struct BitMap *) tidata;
	    case PDTA_ClassBitMap:
		lod->lod_SourceBMap = (struct BitMap *) tidata;
		break;

	    case PDTA_Screen:
		lod->lod_Screen = (struct Screen *) tidata;
		break;

	    case PDTA_Grab:
		lod->lod_Point = *((Point *) tidata);
		break;

	    case DTA_VisibleVert:
	    case DTA_TotalVert:
	    case DTA_VisibleHoriz:
	    case DTA_TotalHoriz:
		refresh = 1L;
		break;
	}
    }

    if (lod->lod_NumColors != ncolors)
    {
	struct FrameInfo *fri;
	ULONG size1;
	ULONG size2;
	ULONG size3;
	ULONG size4;
	ULONG size5;
	ULONG size6;
	ULONG size7;
	ULONG msize;

	GetAttr (DTA_FrameInfo, o, (ULONG *) & fri);

	ncolors = lod->lod_NumColors;

	if (lod->lod_Colors)
	    FreeVec (lod->lod_Colors);

	/* How big is the histogram table */
	lod->lod_HistoSize = sizeof (ULONG) * ncolors;

	/* Compute amount of memory needed for colors */
	size1 = sizeof (struct ColorRegister) * ncolors + 2;	/* lod_Colors */
	size2 = size1 + (sizeof (LONG) * 3 * ncolors) + 2;	/* lod_CRegs */
	size3 = size2 + (sizeof (LONG) * 3 * ncolors * 2) + 2;	/* lod_GRegs */
	size4 = size3 + (sizeof (UBYTE) * ncolors) + 2;		/* lod_ColorTable */
	size5 = size4 + (sizeof (UBYTE) * ncolors) + 2;		/* lod_ColorTable2 */
	size6 = size5 + (sizeof (UBYTE) * ncolors * 2) + 2;	/* lod_Allocated */
	size7 = size6 + lod->lod_HistoSize + 2;			/* lod_Histogram */
	msize = size7 + lod->lod_HistoSize + 2;			/* lod_Histogram2 */

	if (lod->lod_Colors = AllocVec (msize, MEMF_CLEAR))
	{
	    lod->lod_CRegs       = MEMORY_N_FOLLOWING (lod->lod_Colors, size1);
	    lod->lod_GRegs       = MEMORY_N_FOLLOWING (lod->lod_Colors, size2);
	    lod->lod_ColorTable  = MEMORY_N_FOLLOWING (lod->lod_Colors, size3);
	    lod->lod_ColorTable2 = MEMORY_N_FOLLOWING (lod->lod_Colors, size4);
	    lod->lod_Allocated   = MEMORY_N_FOLLOWING (lod->lod_Colors, size5);
	    lod->lod_Histogram   = MEMORY_N_FOLLOWING (lod->lod_Colors, size6);
	    lod->lod_Histogram2  = MEMORY_N_FOLLOWING (lod->lod_Colors, size7);
	}

	fri->fri_ColorMap = (struct ColorMap *) lod->lod_CRegs;
    }

    if (obm != lod->lod_SourceBMap)
    {
	struct FrameInfo *fri;

	GetAttr (DTA_FrameInfo, o, (ULONG *) & fri);

#if 0
	fri->fri_Dimensions.Width = lod->lod_BMHD.bmh_PageWidth;
	fri->fri_Dimensions.Height = lod->lod_BMHD.bmh_PageHeight;
	fri->fri_Dimensions.Depth = lod->lod_BMHD.bmh_Depth;
#else
	fri->fri_Dimensions.Width = GetBitMapAttr (lod->lod_SourceBMap, BMA_WIDTH);
	fri->fri_Dimensions.Height = GetBitMapAttr (lod->lod_SourceBMap, BMA_HEIGHT);
	fri->fri_Dimensions.Depth = GetBitMapAttr (lod->lod_SourceBMap, BMA_DEPTH);
#endif
    }

    if (modeid != lod->lod_ModeID)
    {
	struct DimensionInfo dim;
	struct DisplayInfo di;
	struct FrameInfo *fri;
	ULONG flags = NULL;

	GetAttr (DTA_FrameInfo, o, (ULONG *) & fri);

	di.NotAvailable = TRUE;
	if (!GetDisplayInfoData (NULL, (APTR) & di, sizeof (struct DisplayInfo), DTAG_DISP, lod->lod_ModeID) || di.NotAvailable)
	{
	    if (lod->lod_ModeID & 0x800)
		flags |= DIPF_IS_HAM;
	    else if (lod->lod_ModeID & 0x80)
		flags |= DIPF_IS_EXTRAHALFBRITE;
	    if ((modeid = bestmodeid (cb,
				      BIDTAG_SourceID, lod->lod_ModeID,
				      BIDTAG_DIPFMustHave, flags,
#if 1
				      BIDTAG_NominalWidth,  lod->lod_BMHD.bmh_PageWidth,
				      BIDTAG_NominalHeight, lod->lod_BMHD.bmh_PageHeight,
#else
				      BIDTAG_NominalWidth,  lod->lod_BMHD.bmh_Width,
				      BIDTAG_NominalHeight, lod->lod_BMHD.bmh_Height,
#endif
				      BIDTAG_DesiredWidth,  lod->lod_BMHD.bmh_Width,
				      BIDTAG_DesiredHeight, lod->lod_BMHD.bmh_Height,
				      BIDTAG_Depth, lod->lod_BMHD.bmh_Depth,
				      TAG_DONE)) != INVALID_ID)
	    {
		lod->lod_ModeID = modeid;
		GetDisplayInfoData (NULL, (APTR) & di, sizeof (struct DisplayInfo), DTAG_DISP, lod->lod_ModeID);
	    }
	}

	if (!di.NotAvailable)
	{
	    GetDisplayInfoData (NULL, (APTR) & dim, sizeof (struct DimensionInfo), DTAG_DIMS, lod->lod_ModeID);
	    fri->fri_Dimensions.Depth = MIN (fri->fri_Dimensions.Depth, dim.MaxDepth);
	    fri->fri_PropertyFlags = di.PropertyFlags;
	    fri->fri_Resolution = *(&di.Resolution);
	    fri->fri_RedBits = di.RedBits;
	    fri->fri_GreenBits = di.GreenBits;
	    fri->fri_BlueBits = di.BlueBits;
	}
    }

    return (refresh);
}

/*****************************************************************************/

/* 6 7 3 */
#define	RED_SCALE	6
#define	GREEN_SCALE	7
#define	BLUE_SCALE	3

/*****************************************************************************/

#define	SQ(x)		((x)*(x))
#define	AVGC(i1,i2,c)	((lod->lod_GRegs[((i1) * 3) + (c)]>>1)+(lod->lod_GRegs[((i2) * 3) + (c)]>>1))

/*****************************************************************************/

static ULONG color_error (ULONG r1, ULONG r2, ULONG g1, ULONG g2, ULONG b1, ULONG b2)
{
    r1 >>= 24;
    g1 >>= 24;
    b1 >>= 24;
    r2 >>= 24;
    g2 >>= 24;
    b2 >>= 24;
    return (SQ (r1 - r2) + SQ (g1 - g2) + SQ (b1 - b2));
}

/*****************************************************************************/

static ULONG framePictureDT (struct ClassBase * cb, Class * cl, Object * o, struct dtFrameBox * dtf)
{
    struct FrameInfo *fri;
    ULONG retval = 1L;

    if (!(dtf->dtf_FrameFlags & FRAMEF_SPECIFY))
    {
	/* Tell me about yourself */
	GetAttr (DTA_FrameInfo, o, (ULONG *) & fri);
	CopyMem (fri, dtf->dtf_FrameInfo, MIN (dtf->dtf_SizeFrameInfo, sizeof (struct FrameInfo)));
    }

    return (retval);
}

/*****************************************************************************/

#if 0
void CopyBitMap (struct ClassBase * cb, struct BitMap * bm1, struct BitMap * bm2)
{
    ULONG bpr1 = bm1->BytesPerRow;
    ULONG bpr2 = bm2->BytesPerRow;
    ULONG width;
    UBYTE *src;
    UBYTE *dst;
    LONG r;
    LONG p;

    width = GetBitMapAttr (bm1, BMA_WIDTH) / 8;

    for (p = bm1->Depth - 1; p >= 0; p--)
    {
	src = (BYTE *) bm1->Planes[p];
	dst = (BYTE *) bm2->Planes[p];

	for (r = bm1->Rows; r > 0; r--)
	{
	    CopyMem (src, dst, width);
	    src += bpr1;
	    dst += bpr2;
	}
    }
}
#endif

/*****************************************************************************/
/* Clean this up.  It's gone through several evolutions and has gotten dirty */
/*****************************************************************************/

static ULONG layoutMethod (struct ClassBase * cb, Class * cl, Object * o, struct gpLayout * gpl)
{
    struct DTSpecialInfo *si = (struct DTSpecialInfo *) G (o)->SpecialInfo;
    struct localData *lod = INST_DATA (cl, o);
    ULONG errLevel = RETURN_OK;
    struct Screen *scr = NULL;
    ULONG errNumber = 0L;
    struct IBox *domain;
    BOOL remap = FALSE;
    ULONG retval = 1L;
    STRPTR title;

    LONG testr, testg, testb;
    struct TagItem tags[2];
    struct BitMap *fbm;
    ULONG table[3];
    ULONG odepth;
    ULONG depth;
    LONG i, j;
    LONG err1;
    LONG err2;
    LONG got;

    BOOL send = FALSE;

    /* Obtain the layout lock */
    ObtainSemaphore (&si->si_Lock);

    /* Set the layout flag */
    si->si_Flags |= DTSIF_LAYOUT;

    /* Get the name and the domain */
    GetAttr (DTA_ObjName, o, (ULONG *) & title);
    GetAttr (DTA_Domain, o, (ULONG *) & domain);

    /* Get a screen pointer */
    if (lod->lod_Screen)
	scr = lod->lod_Screen;
    else if (gpl && gpl->gpl_GInfo)
	scr = gpl->gpl_GInfo->gi_Screen;

    /* Need to remap the bitmap to the destination screen */
    if (gpl->gpl_Initial && lod->lod_SourceBMap)
    {
	/* Do we need to send any information */
	send = TRUE;

	/* Free the extra information */
	freeExtraInfo (cb, lod);

	/* Clear the histogram table */
	memset (lod->lod_Histogram, 0, lod->lod_HistoSize);

	/* We have to have a screen */
	if (scr)
	{
	    /* We only do remap if we have color information */
	    if (lod->lod_Colors)
	    {
		/* Set up tags */
		tags[0].ti_Tag = OBP_Precision;
		tags[0].ti_Data = lod->lod_Precision;
		tags[1].ti_Tag = TAG_DONE;

		/* Time to do major conversion */
		lod->lod_ColorMap = scr->ViewPort.ColorMap;
		depth = MAX (scr->RastPort.BitMap->Depth, (ULONG) lod->lod_BMHD.bmh_Depth);

		/* Get a pointer to the friend bitmap */
		fbm = &(scr->BitMap);

#if 0
		/* Fill the histogram table */
		TallyBitMap (lod->lod_SourceBMap, lod->lod_Histogram, lod->lod_BMHD.bmh_Width);
#endif

		/* Do we have a sparse table? */
		if ((lod->lod_Flags & LODF_SPARSE) &&
		    (lod->lod_SparseCM = GetColorMap (lod->lod_NumSparse)))
		{
		    for (i = 0; i < lod->lod_NumSparse; i++)
		    {
			GetRGB32 (scr->ViewPort.ColorMap, lod->lod_SparseTable[i], 1, (ULONG *) table);
			SetRGB32CM (lod->lod_SparseCM, i, table[0], table[1], table[2]);
		    }
		}

		/* If they asked us to remap, or they told us to be like a screen
		 * which is deeper then the picture, then we have to allocate a work bitmap. */
		if ((lod->lod_Flags & LODF_REMAP) || (lod->lod_Screen && (lod->lod_BMHD.bmh_Depth < lod->lod_Screen->RastPort.BitMap->Depth)))
		{
		    lod->lod_BMap = AllocBitMap ((ULONG) lod->lod_BMHD.bmh_Width, (ULONG) lod->lod_BMHD.bmh_Height, depth, BMF_CLEAR, fbm);
		    lod->lod_Flags &= ~LODF_SAMEBM;
		}
		else
		{
		    lod->lod_Flags |= LODF_SAMEBM;
		}

		if (lod->lod_Flags & LODF_REMAP)
		{
		    if (lod->lod_BMap)
		    {
			/* Fill the histogram table */
			TallyBitMap (lod->lod_SourceBMap, lod->lod_Histogram, lod->lod_BMHD.bmh_Width);

			for (i = 0; i < lod->lod_NumColors; i++)
			{
			    if (lod->lod_Histogram[i])
			    {
				if (lod->lod_Flags & LODF_SPARSE)
				{
				    got = FindColor (lod->lod_SparseCM, lod->lod_CRegs[i * 3 + 0], lod->lod_CRegs[i * 3 + 1], lod->lod_CRegs[i * 3 + 2], lod->lod_NumSparse);
				    got = lod->lod_SparseTable[got];
				}
				else
				{
				    got = ObtainBestPenA (lod->lod_ColorMap, lod->lod_CRegs[i * 3 + 0], lod->lod_CRegs[i * 3 + 1], lod->lod_CRegs[i * 3 + 2], tags);
				    GetRGB32 (lod->lod_ColorMap, got, 1, (lod->lod_GRegs + (lod->lod_NumAlloc * 3)));
				    lod->lod_Allocated[lod->lod_NumAlloc++] = got;
				}
				if (got != i)
				    remap = TRUE;
				lod->lod_ColorTable[i] = lod->lod_ColorTable2[i] = got;
			    }
			}

			if (remap)
			{
			    for (i = 0; i < lod->lod_NumColors; i++)
			    {
				err1 = color_error (
						       lod->lod_CRegs[i * 3 + 0], lod->lod_GRegs[i * 3 + 0],
						       lod->lod_CRegs[i * 3 + 1], lod->lod_GRegs[i * 3 + 1],
						       lod->lod_CRegs[i * 3 + 2], lod->lod_GRegs[i * 3 + 2]);

				if (err1 > 2000)
				{
				    for (j = 0; j < lod->lod_NumAlloc; j++)
				    {
					testr = AVGC (i, j, 0);
					testg = AVGC (i, j, 1);
					testb = AVGC (i, j, 2);

					err2 = color_error (
							       lod->lod_CRegs[i * 3 + 0], testr,
							       lod->lod_CRegs[i * 3 + 1], testg,
							       lod->lod_CRegs[i * 3 + 2], testb);

					if (err2 < err1)
					{
					    err1 = err2;
					    lod->lod_ColorTable2[i] = lod->lod_Allocated[j];
					}
				    }
				}
			    }

			    odepth = lod->lod_SourceBMap->Depth;
			    lod->lod_SourceBMap->Depth = MIN (odepth, 8);
			    XLateBitMap (lod->lod_SourceBMap, lod->lod_BMap, lod->lod_ColorTable, lod->lod_ColorTable2, lod->lod_BMHD.bmh_Width);
			    lod->lod_SourceBMap->Depth = odepth;
			}
		    }
		    else
		    {
			errLevel = RETURN_FAIL;
			errNumber = ERROR_NO_FREE_STORE;
			retval = 0L;
		    }
		}

		if (lod->lod_SparseCM)
		    FreeColorMap (lod->lod_SparseCM);
	    }

	    if (!remap && lod->lod_BMap && !(lod->lod_Flags & LODF_SAMEBM))
	    {
#if 0
		/* So that we can do fast bitmaps */
		CopyBitMap (cb, lod->lod_SourceBMap, lod->lod_BMap);
#else
		BltBitMap (lod->lod_SourceBMap, 0, 0,
			   lod->lod_BMap, 0, 0, lod->lod_BMHD.bmh_Width, lod->lod_BMHD.bmh_Height,
			   0xC0, 0xFF, NULL);
#endif
	    }
	}
	else if (!(lod->lod_Flags & LODF_REMAP))
	{
	    lod->lod_Flags |= LODF_SAMEBM;
	}

	if (lod->lod_Flags & LODF_SAMEBM)
	{
	    lod->lod_Flags &= ~LODF_FREESRC;
	    lod->lod_BMap = lod->lod_SourceBMap;
	}

	WaitBlit ();

	if (lod->lod_Flags & LODF_FREESRC)
	{
	    FreeBitMap (lod->lod_OurBMap);
	    lod->lod_OurBMap = NULL;
	}
    }

    /* Clear the layout flag */
    si->si_Flags &= ~DTSIF_LAYOUT;

    si->si_VisVert  = (LONG) domain->Height;
    si->si_TotVert  = (LONG) lod->lod_BMHD.bmh_Height;

    si->si_VisHoriz = (LONG) domain->Width;
    si->si_TotHoriz = (LONG) lod->lod_BMHD.bmh_Width;

    if (send)
    {
	/* Tell everyone about the changes that we made */
	notifyAttrChanges (cb, o, gpl->gpl_GInfo, NULL,
			   GA_ID,		G (o)->GadgetID,
			   DTA_NominalVert,	(LONG) lod->lod_BMHD.bmh_Height,
			   DTA_NominalHoriz,	(LONG) lod->lod_BMHD.bmh_Width,
			   DTA_ErrorLevel,	errLevel,
			   DTA_ErrorNumber,	errNumber,
			   DTA_Title,		title,
			   TAG_DONE);
    }

    /* Release the layout lock */
    ReleaseSemaphore (&si->si_Lock);

    return (retval);
}

/*****************************************************************************/

static UWORD ghost_pattern[] = {0x4444, 0x1111, 0x4444, 0x1111};

/*****************************************************************************/

static ULONG renderMethod (struct ClassBase * cb, Class * cl, Object * o, struct gpRender * msg)
{
    struct DTSpecialInfo *si = (struct DTSpecialInfo *) G (o)->SpecialInfo;
    struct localData *lod = INST_DATA (cl, o);
    struct IBox *domain;
    struct RastPort *rp;
    LONG tx, ty, bx, by;
    LONG width, height;
    struct IBox *sel;

    if (!lod->lod_BMap || (si->si_Flags & DTSIF_LAYOUT) || !AttemptSemaphoreShared (&si->si_Lock))
	return (0);

    GetAttr (DTA_Domain, o, (ULONG *) & domain);
    GetAttr (DTA_SelectDomain, o, (ULONG *) & sel);

    width = (ULONG) MIN (lod->lod_BMHD.bmh_Width, domain->Width);
    height = (ULONG) MIN (lod->lod_BMHD.bmh_Height, domain->Height);

    /* Get a pointer to the rastport */
    if (rp = msg->gpr_RPort)
    {
	BltBitMapRastPort (lod->lod_BMap, (ULONG) si->si_TopHoriz, (ULONG) si->si_TopVert,
			   rp, domain->Left, domain->Top, width, height, 0xC0);
	if (sel)
	{
	    tx = (LONG) sel->Left - si->si_TopHoriz;
	    ty = (LONG) sel->Top - si->si_TopVert;
	    bx = tx + (LONG) sel->Width - 1;
	    by = ty + (LONG) sel->Height - 1;

	    if ((tx < width) && (ty < height) && (bx > 0) && (by > 0))
	    {
		if (tx < 0)
		    tx = 0;
		if (ty < 0)
		    ty = 0;
		if (bx > width - 1)
		    bx = width - 1;
		if (by > height - 1)
		    by = height - 1;

		SetAfPt (rp, ghost_pattern, 2);
		SetDrMd (rp, JAM1);
		SetAPen (rp, 2);
		WaitBlit ();
		RectFill (rp, domain->Left + tx, domain->Top + ty, domain->Left + bx, domain->Top + by);
	    }
	}

	si->si_OTopVert = si->si_TopVert;
	si->si_OTopHoriz = si->si_TopHoriz;
    }
    ReleaseSemaphore (&si->si_Lock);
    return (1L);
}

/*****************************************************************************/

static ULONG printMethod (struct ClassBase * cb, Class * cl, Object * o, struct dtPrint * msg)
{
    struct localData *lod = INST_DATA (cl, o);
    struct GadgetInfo *gi = msg->dtp_GInfo;
    struct RastPort *prp;
    union printerIO *pio;
    UWORD width, height;
    struct ColorMap *cm;
    struct RastPort rp;
    ULONG retval = 0L;
    BOOL going = TRUE;
    struct IBox *sel;
    UWORD left, top;
    UWORD iospecial;
    LONG destcols;
    LONG destrows;
    ULONG sigr;
    ULONG psig;
    ULONG tmpl;

    if (pio = msg->dtp_PIO)
    {
	/* What bit are we going to wait on? */
	psig = 1L << pio->ios.io_Message.mn_ReplyPort->mp_SigBit;

	if (GetAttr (DTA_SelectDomain, o, (ULONG *) & sel) && sel)
	{
	    left   = sel->Left;
	    top    = sel->Top;
	    width  = sel->Width;
	    height = sel->Height;
	}
	else
	{
#if 1
	    left   = 0;
	    top    = 0;
	    width  = lod->lod_BMHD.bmh_Width;
	    height = lod->lod_BMHD.bmh_Height;
#else
	    /* Fill in the window rectangle */
	    QueryOverscan (lod->lod_ModeID, &rect, OSCAN_VIDEO);
	    left   = 0;
	    top    = 0;
	    width  = lod->lod_BMHD.bmh_PageWidth;	/* rect.MaxX - rect.MinX + 1; */
	    height = lod->lod_BMHD.bmh_PageHeight;	/* rect.MaxY - rect.MinY + 1; */
#endif
	}

	/* Get a color map */
	if (cm = GetObjectColorMap (cb, cl, o))
	{
	    /* Prepare the RastPort */
	    InitRastPort (&rp);
	    rp.BitMap = lod->lod_SourceBMap;
	    prp = (struct RastPort *) GetTagData (DTA_RastPort, (ULONG)&rp, msg->dtp_AttrList);

	    destcols = destrows = 0;
#if 0
	    iospecial = SPECIAL_ASPECT;
#else
	    /* Compute the flags & size */
	    if ((lod->lod_BMHD.bmh_Width == width) && (lod->lod_BMHD.bmh_Height == height))
	    {
		iospecial = SPECIAL_FULLCOLS | SPECIAL_ASPECT;
	    }
	    else
	    {
		iospecial = SPECIAL_FRACCOLS | SPECIAL_ASPECT;
		tmpl = lod->lod_BMHD.bmh_Width;
		tmpl = tmpl << 16;
		destcols = (tmpl / width) << 16;
	    }
#endif

	    destcols  = (LONG)  GetTagData (DTA_DestCols, (ULONG)destcols,  msg->dtp_AttrList);
	    destrows  = (LONG)  GetTagData (DTA_DestRows, (ULONG)destrows,  msg->dtp_AttrList);
	    iospecial = (UWORD) GetTagData (DTA_Special,  (ULONG)iospecial, msg->dtp_AttrList);

	    /* Prepare to dump the RastPort */
	    pio->iodrp.io_Command = PRD_DUMPRPORT;
	    pio->iodrp.io_RastPort = prp;
	    pio->iodrp.io_ColorMap = cm;
	    pio->iodrp.io_Modes = lod->lod_ModeID;
	    pio->iodrp.io_SrcX = left;
	    pio->iodrp.io_SrcY = top;
	    pio->iodrp.io_SrcWidth = width;
	    pio->iodrp.io_SrcHeight = height;
	    pio->iodrp.io_DestCols = destcols;
	    pio->iodrp.io_DestRows = destrows;
	    pio->iodrp.io_Special = iospecial;
	    SendIO ((struct IORequest *) pio);

	    while (going)
	    {
		/* Wait for something to happen */
		sigr = Wait (psig | SIGBREAKF_CTRL_C);

		/* Did they try to abort us? */
		if (sigr & SIGBREAKF_CTRL_C)
		{
		    /* Abort the IO */
		    AbortIO ((struct IORequest *) pio);
		    WaitIO ((struct IORequest *) pio);

		    /* Reset the printer (otherwise they get garbage the next time they print) */
		    pio->ios.io_Command = CMD_WRITE;
		    pio->ios.io_Data = "\033c";
		    pio->ios.io_Length = -1L;
		    DoIO ((struct IORequest *) pio);
		    going = FALSE;
		}

		/* Is the print complete? */
		if (sigr & psig)
		{
		    while (GetMsg (pio->ios.io_Message.mn_ReplyPort)) ;
		    going = FALSE;
		}
	    }

	    /* Return the return value from the print request */
	    if ((retval = (ULONG) pio->ios.io_Error) == 0)
	    {
		DoMethod (o, DTM_CLEARSELECTED, gi);
	    }

	    /* Free the temporary color map */
	    FreeColorMap (cm);
	}
    }

    return retval;
}

/*****************************************************************************/

static ULONG ASM Dispatch (REG (a0) Class * cl, REG (a2) Object * o, REG (a1) Msg msg)
{
    struct ClassBase *cb = (struct ClassBase *) cl->cl_UserData;
    struct DTSpecialInfo *si;
    struct localData *lod;
    Object *newobj;
    ULONG retval;

    switch (msg->MethodID)
    {
	case OM_NEW:
	    if (newobj = (Object *) DoSuperMethodA (cl, o, msg))
	    {
		lod = INST_DATA (cl, newobj);
		lod->lod_ModeID = INVALID_ID;
		lod->lod_Flags |= LODF_REMAP;
		lod->lod_Precision = PRECISION_IMAGE;

		si = (struct DTSpecialInfo *) G (newobj)->SpecialInfo;
		si->si_VertUnit = si->si_HorizUnit = 1;
		si->si_OTopVert = si->si_OTopHoriz = -1;
		setPictureDTAttrs (cb, cl, newobj, (struct opSet *) msg);
	    }
	    retval = (ULONG) newobj;
	    break;

	case OM_GET:
	    retval = getPictureDTAttr (cb, cl, o, (struct opGet *) msg);
	    break;

	case OM_UPDATE:
	case OM_SET:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    retval += setPictureDTAttrs (cb, cl, o, (struct opSet *) msg);
	    if (retval)
	    {
		struct RastPort *rp;
		struct gpRender gpr;

		/* Get a pointer to the rastport */
		if (rp = ObtainGIRPort (((struct opSet *) msg)->ops_GInfo))
		{
		    /* Force a redraw */
		    gpr.MethodID = GM_RENDER;
		    gpr.gpr_GInfo = ((struct opSet *) msg)->ops_GInfo;
		    gpr.gpr_RPort = rp;
		    gpr.gpr_Redraw = GREDRAW_UPDATE;
		    DoMethodA (o, &gpr);

		    /* Release the temporary rastport */
		    ReleaseGIRPort (rp);
		}

		/* Clear the return value */
		retval = 0L;
	    }
	    break;

	case GM_LAYOUT:
	    notifyAttrChanges (cb, o, ((struct gpLayout *) msg)->gpl_GInfo, NULL,
			       GA_ID, G (o)->GadgetID,
			       DTA_Busy, TRUE,
			       TAG_DONE);
	    retval = DoSuperMethodA (cl, o, msg);
	    retval += DoAsyncLayout (o, (struct gpLayout *) msg);
	    break;

	case DTM_PROCLAYOUT:
	    notifyAttrChanges (cb, o, ((struct gpLayout *) msg)->gpl_GInfo, NULL,
			       GA_ID, G (o)->GadgetID,
			       DTA_Busy, TRUE,
			       TAG_DONE);
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);

	case DTM_ASYNCLAYOUT:
	    retval += layoutMethod (cb, cl, o, (struct gpLayout *) msg);
	    break;

	case GM_RENDER:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    retval += renderMethod (cb, cl, o, (struct gpRender *) msg);
	    break;

	case DTM_FRAMEBOX:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    retval += framePictureDT (cb, cl, o, (struct dtFrameBox *) msg);
	    break;

	case DTM_CLEARSELECTED:
	    ((struct DTSpecialInfo *) (G (o)->SpecialInfo))->si_Flags &= ~DTSIF_HIGHLIGHT;
	case DTM_SELECT:
	    {
		struct dtSelect *dts = (struct dtSelect *) msg;
		struct RastPort *rp;

		/* Get a pointer to the rastport */
		if (rp = ObtainGIRPort (dts->dts_GInfo))
		{
		    struct gpRender gpr;

		    /* Force a redraw */
		    gpr.MethodID = GM_RENDER;
		    gpr.gpr_GInfo = dts->dts_GInfo;
		    gpr.gpr_RPort = rp;
		    gpr.gpr_Redraw = GREDRAW_REDRAW;
		    DoMethodA (o, &gpr);

		    /* Release the temporary rastport */
		    ReleaseGIRPort (rp);
		}
		/* Clear the return value */
		retval = 0L;
	    }
	    break;

	case DTM_PRINT:
	    retval = printMethod (cb, cl, o, (struct dtPrint *) msg);
	    break;

	case DTM_COPY:
	    retval = copyMethod (cb, cl, o, (struct dtGeneral *) msg);
	    break;

	case DTM_WRITE:
	    retval = writeMethod (cb, cl, o, (struct dtWrite *) msg);
	    break;

	case OM_DISPOSE:
	    /* Wait for any blits to finish */
	    WaitBlit ();

	    /* Get a pointer to the instance data */
	    lod = INST_DATA (cl, o);

	    freeExtraInfo (cb, lod);

	    if (lod->lod_Colors)
		FreeVec (lod->lod_Colors);

	    /* As soon as we have data sharing get rid of this!!! */
	    if (lod->lod_OurBMap)
		FreeBitMap (lod->lod_OurBMap);

	    /* Let the superclass handle everything else */
	default:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    break;
    }

    return (retval);
}

/*****************************************************************************/

Class *initClass (struct ClassBase * cb)
{
    Class *cl;

    if (cl = MakeClass (PICTUREDTCLASS, DATATYPESCLASS, NULL, sizeof (struct localData), 0L))
    {
	cl->cl_Dispatcher.h_Entry = (ULONG (*)()) Dispatch;
	cl->cl_UserData = (ULONG) cb;
	AddClass (cl);
    }
    return (cl);
}
@


39.15
log
@removed extra notification
@
text
@d13 1
a13 1
Class *initClass (struct ClassBase * cb)
d15 1
a15 9
    Class *cl;

    if (cl = MakeClass (PICTUREDTCLASS, DATATYPESCLASS, NULL, sizeof (struct localData), 0L))
    {
	cl->cl_Dispatcher.h_Entry = Dispatch;
	cl->cl_UserData = (ULONG) cb;
	AddClass (cl);
    }
    return (cl);
d20 1
a20 1
ULONG notifyAttrChanges (struct ClassBase * cb, Object * o, VOID * ginfo, ULONG flags, ULONG tag1,...)
d27 1
a27 1
void freeExtraInfo (struct ClassBase * cb, struct localData * lod)
d48 1
a48 1
struct ColorMap *GetObjectColorMap (struct ClassBase * cb, Class * cl, Object * o)
d74 1
a74 155
ULONG ASM Dispatch (REG (a0) Class * cl, REG (a2) Object * o, REG (a1) Msg msg)
{
    struct ClassBase *cb = (struct ClassBase *) cl->cl_UserData;
    struct DTSpecialInfo *si;
    struct localData *lod;
    Object *newobj;
    ULONG retval;

    switch (msg->MethodID)
    {
	case OM_NEW:
	    if (newobj = (Object *) DoSuperMethodA (cl, o, msg))
	    {
		lod = INST_DATA (cl, newobj);
		lod->lod_ModeID = INVALID_ID;
		lod->lod_Flags |= LODF_REMAP;
		lod->lod_Precision = PRECISION_IMAGE;

		si = (struct DTSpecialInfo *) G (newobj)->SpecialInfo;
		si->si_VertUnit = si->si_HorizUnit = 1;
		si->si_OTopVert = si->si_OTopHoriz = -1;
		setPictureDTAttrs (cb, cl, newobj, (struct opSet *) msg);
	    }
	    retval = (ULONG) newobj;
	    break;

	case OM_GET:
	    retval = getPictureDTAttr (cb, cl, o, (struct opGet *) msg);
	    break;

	case OM_UPDATE:
	case OM_SET:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    retval += setPictureDTAttrs (cb, cl, o, (struct opSet *) msg);
	    if (retval)
	    {
		struct RastPort *rp;
		struct gpRender gpr;

		/* Get a pointer to the rastport */
		if (rp = ObtainGIRPort (((struct opSet *) msg)->ops_GInfo))
		{
		    /* Force a redraw */
		    gpr.MethodID = GM_RENDER;
		    gpr.gpr_GInfo = ((struct opSet *) msg)->ops_GInfo;
		    gpr.gpr_RPort = rp;
		    gpr.gpr_Redraw = GREDRAW_UPDATE;
		    DoMethodA (o, &gpr);

		    /* Release the temporary rastport */
		    ReleaseGIRPort (rp);
		}

		/* Clear the return value */
		retval = 0L;
	    }
	    break;

	case GM_LAYOUT:
	    notifyAttrChanges (cb, o, ((struct gpLayout *) msg)->gpl_GInfo, NULL,
			       GA_ID, G (o)->GadgetID,
			       DTA_Busy, TRUE,
			       TAG_DONE);
	    retval = DoSuperMethodA (cl, o, msg);
	    retval += DoAsyncLayout (o, (struct gpLayout *) msg);
	    break;

	case DTM_PROCLAYOUT:
	    notifyAttrChanges (cb, o, ((struct gpLayout *) msg)->gpl_GInfo, NULL,
			       GA_ID, G (o)->GadgetID,
			       DTA_Busy, TRUE,
			       TAG_DONE);
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);

	case DTM_ASYNCLAYOUT:
	    retval += layoutMethod (cb, cl, o, (struct gpLayout *) msg);
	    break;

	case GM_RENDER:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    retval += renderMethod (cb, cl, o, (struct gpRender *) msg);
	    break;

	case DTM_FRAMEBOX:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    retval += framePictureDT (cb, cl, o, (struct dtFrameBox *) msg);
	    break;

	case DTM_CLEARSELECTED:
	    ((struct DTSpecialInfo *) (G (o)->SpecialInfo))->si_Flags &= ~DTSIF_HIGHLIGHT;
	case DTM_SELECT:
	    {
		struct dtSelect *dts = (struct dtSelect *) msg;
		struct RastPort *rp;

		/* Get a pointer to the rastport */
		if (rp = ObtainGIRPort (dts->dts_GInfo))
		{
		    struct gpRender gpr;

		    /* Force a redraw */
		    gpr.MethodID = GM_RENDER;
		    gpr.gpr_GInfo = dts->dts_GInfo;
		    gpr.gpr_RPort = rp;
		    gpr.gpr_Redraw = GREDRAW_REDRAW;
		    DoMethodA (o, &gpr);

		    /* Release the temporary rastport */
		    ReleaseGIRPort (rp);
		}
		/* Clear the return value */
		retval = 0L;
	    }
	    break;

	case DTM_PRINT:
	    retval = printMethod (cb, cl, o, (struct dtPrint *) msg);
	    break;

	case DTM_COPY:
	    retval = copyMethod (cb, cl, o, (struct dtGeneral *) msg);
	    break;

	case DTM_WRITE:
	    retval = writeMethod (cb, cl, o, (struct dtWrite *) msg);
	    break;

	case OM_DISPOSE:
	    /* Wait for any blits to finish */
	    WaitBlit ();

	    /* Get a pointer to the instance data */
	    lod = INST_DATA (cl, o);

	    freeExtraInfo (cb, lod);

	    if (lod->lod_Colors)
		FreeVec (lod->lod_Colors);

	    /* As soon as we have data sharing get rid of this!!! */
	    if (lod->lod_OurBMap)
		FreeBitMap (lod->lod_OurBMap);

	    /* Let the superclass handle everything else */
	default:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    break;
    }

    return (retval);
}

/*****************************************************************************/

ULONG copyMethod (struct ClassBase * cb, Class * cl, Object * o, struct dtGeneral * msg)
d95 1
a95 1
ULONG writeMethod (struct ClassBase * cb, Class * cl, Object * o, struct dtWrite * msg)
d143 1
a143 1
ULONG getPictureDTAttr (struct ClassBase * cb, Class * cl, Object * o, struct opGet * msg)
a213 7
ULONG bestmodeid (struct ClassBase * cb, ULONG data,...)
{
    return BestModeIDA ((struct TagItem *) & data);
}

/*****************************************************************************/

d215 1
a215 1
ULONG setPictureDTAttrs (struct ClassBase * cb, Class * cl, Object * o, struct opSet * msg)
a431 1

d443 1
a443 1
ULONG framePictureDT (struct ClassBase * cb, Class * cl, Object * o, struct dtFrameBox * dtf)
d492 1
a492 1
ULONG layoutMethod (struct ClassBase * cb, Class * cl, Object * o, struct gpLayout * gpl)
d730 1
a730 1
UWORD ghost_pattern[] = {0x4444, 0x1111, 0x4444, 0x1111};
d734 1
a734 1
ULONG renderMethod (struct ClassBase * cb, Class * cl, Object * o, struct gpRender * msg)
d793 1
a793 1
ULONG printMethod (struct ClassBase * cb, Class * cl, Object * o, struct dtPrint * msg)
d926 169
@


39.14
log
@moved histogram down into remap section
@
text
@d685 2
d706 3
d873 5
a877 2
    /* Release the layout lock */
    ReleaseSemaphore (&si->si_Lock);
d879 1
a879 1
    if (gpl)
d883 6
a888 15
			   GA_ID, G (o)->GadgetID,
			   DTA_VisibleVert, (si->si_VisVert = (LONG) domain->Height),
			   DTA_TotalVert, (si->si_TotVert = (LONG) lod->lod_BMHD.bmh_Height),
			   DTA_NominalVert, (LONG) lod->lod_BMHD.bmh_Height,

			   DTA_VisibleHoriz, (si->si_VisHoriz = (LONG) domain->Width),
			   DTA_TotalHoriz, (si->si_TotHoriz = (LONG) lod->lod_BMHD.bmh_Width),
			   DTA_NominalHoriz, (LONG) lod->lod_BMHD.bmh_Width,

			   DTA_ErrorLevel, errLevel,
			   DTA_ErrorNumber, errNumber,

			   DTA_Title, title,
			   DTA_Busy, FALSE,
			   DTA_Sync, TRUE,
d891 3
@


39.13
log
@removed debugging information
@
text
@d248 1
a248 1
	    CloseClipboard ((struct ClipboardHandler *) iff->iff_Stream);
d497 2
a498 2
	size4 = size3 + (sizeof (UBYTE) * ncolors) + 2;	/* lod_ColorTable */
	size5 = size4 + (sizeof (UBYTE) * ncolors) + 2;	/* lod_ColorTable2 */
d500 2
a501 2
	size7 = size6 + lod->lod_HistoSize + 2;	/* lod_Histogram */
	msize = size7 + lod->lod_HistoSize + 2;	/* lod_Histogram2 */
d505 3
a507 3
	    lod->lod_CRegs = MEMORY_N_FOLLOWING (lod->lod_Colors, size1);
	    lod->lod_GRegs = MEMORY_N_FOLLOWING (lod->lod_Colors, size2);
	    lod->lod_ColorTable = MEMORY_N_FOLLOWING (lod->lod_Colors, size3);
d509 3
a511 3
	    lod->lod_Allocated = MEMORY_N_FOLLOWING (lod->lod_Colors, size5);
	    lod->lod_Histogram = MEMORY_N_FOLLOWING (lod->lod_Colors, size6);
	    lod->lod_Histogram2 = MEMORY_N_FOLLOWING (lod->lod_Colors, size7);
d629 30
d728 1
d731 1
d760 3
d835 4
d842 1
d898 1
a898 2
UWORD ghost_pattern[] =
{0x4444, 0x1111, 0x4444, 0x1111};
a964 1
    struct Rectangle rect;
@


39.12
log
@added RastPort and tags to printing.
@
text
@a29 1

a36 1

a238 1
    struct GadgetInfo *gi = msg->dtg_GInfo;
a241 1
    DB (kprintf ("copyMethod : gi=%08lx\n", gi));
a251 1
    DB (kprintf ("  return %ld\n", (LONG)success));
a259 1
    struct GadgetInfo *gi = msg->dtw_GInfo;
a262 1
    DB (kprintf ("writeMethod : gi=%08lx\n", gi));
a271 1
    DB (kprintf ("  return %ld\n", (LONG)success));
a377 1

d957 6
d969 1
d978 1
a978 1
	    prp = GetTagData (DTA_RastPort, (ULONG)&rp, msg->dtp_AttrList);
d980 4
d996 1
d999 1
a999 1
	    destrows  = (LONG)  GetTagData (DTA_DestCols, 0L,               msg->dtp_AttrList);
a1032 1

@


39.11
log
@no longer clears selected after DTM_COPY or DTM_WRITE.
@
text
@d936 1
d947 1
d980 1
d995 4
d1001 1
a1001 1
	    pio->iodrp.io_RastPort = &rp;
d1009 1
a1009 1
	    pio->iodrp.io_DestRows = 0;
@


39.10
log
@remap problem fixed
@
text
@a9 2
#define	DE(x)	;
#define	DD(x)	;
a217 1
	    DD (kprintf ("freeExtraInfo\n"));
a219 1
	    DD (kprintf ("free colors\n"));
a223 1
	    DD (kprintf ("free bitmap\n"));
a226 2
	    DD (kprintf ("pass to superclass\n"));

d245 1
a253 1

d256 1
a256 6

    if (success)
	DoMethod (o, DTM_CLEARSELECTED, gi);
    else
	DisplayBeep (NULL);

d269 1
a276 1

d279 1
a279 6

    if (success)
	DoMethod (o, DTM_CLEARSELECTED, gi);
    else
	DisplayBeep (NULL);

d562 2
a563 2
#if 0
				      BIDTAG_NominalWidth, lod->lod_BMHD.bmh_PageWidth,
d566 1
a566 1
				      BIDTAG_NominalWidth, lod->lod_BMHD.bmh_Width,
d569 1
a569 1
				      BIDTAG_DesiredWidth, lod->lod_BMHD.bmh_Width,
a581 3

	    DB (kprintf ("depth %ld, dim %ld\n", (LONG) fri->fri_Dimensions.Depth, (LONG) dim.MaxDepth));

a707 1
		DB (kprintf ("TallyBitMap\n"));
a710 1
		DB (kprintf ("sparse table\n"));
a736 1
			DB (kprintf ("remap\n"));
a759 1
			    DB (kprintf ("get dither colors\n"));
a788 1
			    DB (kprintf ("xlatebm\n"));
d957 3
a959 3
	    left = sel->Left;
	    top = sel->Top;
	    width = sel->Width;
d966 3
a968 3
	    left = 0;
	    top = 0;
	    width = lod->lod_BMHD.bmh_PageWidth;	/* rect.MaxX - rect.MinX + 1; */
@


39.9
log
@fixed Mike's problem
@
text
@a12 2
#define	NO_DOUBLE_ALLOC	TRUE

d214 4
a229 2
	    {
		WaitBlit ();
d231 2
a232 1
	    }
d658 2
d666 1
d669 1
a669 1
    struct Screen *scr;
d673 11
a684 1
    DB (kprintf ("layoutMethod\n"));
d690 1
a690 1
    DB (kprintf ("get name & domain\n"));
d695 4
a698 2
    scr = ((lod->lod_Screen) ? lod->lod_Screen : ((gpl->gpl_GInfo) ? gpl->gpl_GInfo->gi_Screen : NULL));
    DB (kprintf ("screen=0x%lx\n", scr));
d701 1
a701 1
    if (gpl->gpl_Initial && scr && lod->lod_SourceBMap)
d703 2
a704 11
	LONG testr, testg, testb;
	struct TagItem tags[2];
	struct BitMap *fbm;
	BOOL remap = FALSE;
	ULONG table[3];
	ULONG odepth;
	ULONG depth;
	LONG i, j;
	LONG err1;
	LONG err2;
	LONG got;
d706 5
a710 2
	/* We only do remap if we have color information */
	if (lod->lod_Colors)
d712 7
a718 4
	    /* Set up tags */
	    tags[0].ti_Tag = OBP_Precision;
	    tags[0].ti_Data = lod->lod_Precision;
	    tags[1].ti_Tag = TAG_DONE;
d720 10
a729 6
	    /* Time to do major conversion */
	    lod->lod_ColorMap = scr->ViewPort.ColorMap;
	    depth = MAX (scr->BitMap.Depth, (ULONG) lod->lod_BMHD.bmh_Depth);

	    /* Get a pointer to the friend bitmap */
	    fbm = (scr) ? &(scr->BitMap) : NULL;
d731 11
a741 3
	    /* Free the extra information */
	    DB (kprintf ("freeExtraInfo\n"));
	    freeExtraInfo (cb, lod);
d743 11
a753 2
	    /* Clear the histogram table */
	    memset (lod->lod_Histogram, 0, lod->lod_HistoSize);
d755 1
a755 31
	    /* Fill the histogram table */
	    DB (kprintf ("TallyBitMap\n"));
	    TallyBitMap (lod->lod_SourceBMap, lod->lod_Histogram, lod->lod_BMHD.bmh_Width);

	    /* Do we have a sparse table? */
	    DB (kprintf ("sparse table\n"));
	    if ((lod->lod_Flags & LODF_SPARSE) &&
		(lod->lod_SparseCM = GetColorMap (lod->lod_NumSparse)))
	    {
		for (i = 0; i < lod->lod_NumSparse; i++)
		{
		    GetRGB32 (scr->ViewPort.ColorMap, lod->lod_SparseTable[i], 1, (ULONG *) table);
		    SetRGB32CM (lod->lod_SparseCM, i, table[0], table[1], table[2]);
		}
	    }

	    /* If they asked us to remap, or they told us to be like a screen which is deeper
	     * then the picture, then we have to allocate a work bitmap */
	    if ((lod->lod_Flags & LODF_REMAP) || (lod->lod_Screen && (lod->lod_BMHD.bmh_Depth < lod->lod_Screen->RastPort.BitMap->Depth)))
	    {
		DB (kprintf ("allocbitmap %ld, %ld, %ld\n", (ULONG) lod->lod_BMHD.bmh_Width, (ULONG) lod->lod_BMHD.bmh_Height, (ULONG) depth));
		lod->lod_BMap = AllocBitMap ((ULONG) lod->lod_BMHD.bmh_Width, (ULONG) lod->lod_BMHD.bmh_Height, depth, BMF_CLEAR, fbm);
	    }
	    else
	    {
		lod->lod_Flags |= LODF_SAMEBM;
	    }

	    if (lod->lod_Flags & LODF_REMAP)
	    {
		if (lod->lod_BMap)
d757 1
a757 2
		    DB (kprintf ("remap\n"));
		    for (i = 0; i < lod->lod_NumColors; i++)
d759 2
a760 1
			if (lod->lod_Histogram[i])
d762 1
a762 1
			    if (lod->lod_Flags & LODF_SPARSE)
d764 14
a777 8
				got = FindColor (lod->lod_SparseCM, lod->lod_CRegs[i * 3 + 0], lod->lod_CRegs[i * 3 + 1], lod->lod_CRegs[i * 3 + 2], lod->lod_NumSparse);
				got = lod->lod_SparseTable[got];
			    }
			    else
			    {
				got = ObtainBestPenA (lod->lod_ColorMap, lod->lod_CRegs[i * 3 + 0], lod->lod_CRegs[i * 3 + 1], lod->lod_CRegs[i * 3 + 2], tags);
				GetRGB32 (lod->lod_ColorMap, got, 1, (lod->lod_GRegs + (lod->lod_NumAlloc * 3)));
				lod->lod_Allocated[lod->lod_NumAlloc++] = got;
a778 3
			    if (got != i)
				remap = TRUE;
			    lod->lod_ColorTable[i] = lod->lod_ColorTable2[i] = got;
a779 1
		    }
d781 1
a781 4
		    if (remap)
		    {
			DB (kprintf ("get dither colors\n"));
			for (i = 0; i < lod->lod_NumColors; i++)
d783 7
a789 4
			    err1 = color_error (
						   lod->lod_CRegs[i * 3 + 0], lod->lod_GRegs[i * 3 + 0],
						   lod->lod_CRegs[i * 3 + 1], lod->lod_GRegs[i * 3 + 1],
						   lod->lod_CRegs[i * 3 + 2], lod->lod_GRegs[i * 3 + 2]);
d791 1
a791 3
			    if (err1 > 2000)
			    {
				for (j = 0; j < lod->lod_NumAlloc; j++)
d793 5
a797 3
				    testr = AVGC (i, j, 0);
				    testg = AVGC (i, j, 1);
				    testb = AVGC (i, j, 2);
d799 10
a808 9
				    err2 = color_error (
							   lod->lod_CRegs[i * 3 + 0], testr,
							   lod->lod_CRegs[i * 3 + 1], testg,
							   lod->lod_CRegs[i * 3 + 2], testb);

				    if (err2 < err1)
				    {
					err1 = err2;
					lod->lod_ColorTable2[i] = lod->lod_Allocated[j];
d812 6
d819 6
a824 6

			DB (kprintf ("xlatebm\n"));
			odepth = lod->lod_SourceBMap->Depth;
			lod->lod_SourceBMap->Depth = MIN (odepth, 8);
			XLateBitMap (lod->lod_SourceBMap, lod->lod_BMap, lod->lod_ColorTable, lod->lod_ColorTable2, lod->lod_BMHD.bmh_Width);
			lod->lod_SourceBMap->Depth = odepth;
d827 3
a829 17
		else
		{
		    errLevel = RETURN_FAIL;
		    errNumber = ERROR_NO_FREE_STORE;
		    retval = 0L;
		}
	    }
	    else if (lod->lod_Flags & LODF_SAMEBM)
	    {
		lod->lod_Flags &= ~LODF_FREESRC;
		lod->lod_BMap = lod->lod_SourceBMap;
	    }

	    if (lod->lod_SparseCM)
	    {
		DB (kprintf ("free color map\n"));
		FreeColorMap (lod->lod_SparseCM);
a830 1
	}
d832 13
a844 5
#if NO_DOUBLE_ALLOC
	if (!remap && lod->lod_BMap && !(lod->lod_Flags & LODF_SAMEBM))
#else
	if (!remap && lod->lod_BMap)
#endif
d846 2
a847 5
	    DB (kprintf ("blit\n"));
	    BltBitMap (lod->lod_SourceBMap, 0, 0,
		       lod->lod_BMap, 0, 0, lod->lod_BMHD.bmh_Width, lod->lod_BMHD.bmh_Height,
		       0xC0, 0xFF, NULL);
	    WaitBlit ();
d850 2
a853 2
	    DB (kprintf ("free source 0x%lx\n", lod->lod_OurBMap));
	    WaitBlit ();
a862 1
    DB (kprintf ("release lock\n"));
d865 22
a886 21
    /* Tell everyone about the changes that we made */
    DB (kprintf ("notify changes\n"));
    DE (kprintf ("level=%ld, error=%ld\n", errLevel, errNumber));
    notifyAttrChanges (cb, o, gpl->gpl_GInfo, NULL,
		       GA_ID, G (o)->GadgetID,
		       DTA_VisibleVert, (si->si_VisVert = (LONG) domain->Height),
		       DTA_TotalVert, (si->si_TotVert = (LONG) lod->lod_BMHD.bmh_Height),
		       DTA_NominalVert, (LONG) lod->lod_BMHD.bmh_Height,

		       DTA_VisibleHoriz, (si->si_VisHoriz = (LONG) domain->Width),
		       DTA_TotalHoriz, (si->si_TotHoriz = (LONG) lod->lod_BMHD.bmh_Width),
		       DTA_NominalHoriz, (LONG) lod->lod_BMHD.bmh_Width,

		       DTA_ErrorLevel, errLevel,
		       DTA_ErrorNumber, errNumber,

		       DTA_Title, title,
		       DTA_Busy, FALSE,
		       DTA_Sync, TRUE,
		       TAG_DONE);
    DB (kprintf ("return %ld\n", retval));
@


39.8
log
@*** empty log message ***
@
text
@d737 3
a739 3
#if NO_DOUBLE_ALLOC
	    if (lod->lod_Flags & LODF_REMAP)
#endif
d744 4
d821 1
a821 1
	    else
a822 2
#if NO_DOUBLE_ALLOC
		lod->lod_Flags |= LODF_SAMEBM;
a824 1
#endif
@


39.7
log
@no changes
@
text
@d7 2
d13 2
d52 1
a52 1
    if (lod->lod_BMap)
d402 1
d549 1
a549 1
	fri->fri_Dimensions.Width  = lod->lod_BMHD.bmh_PageWidth;
d551 1
a551 1
	fri->fri_Dimensions.Depth  = lod->lod_BMHD.bmh_Depth;
d553 1
a553 1
	fri->fri_Dimensions.Width  = GetBitMapAttr (lod->lod_SourceBMap, BMA_WIDTH);
d555 1
a555 1
	fri->fri_Dimensions.Depth  = GetBitMapAttr (lod->lod_SourceBMap, BMA_DEPTH);
d576 2
a577 2
				      BIDTAG_SourceID,		lod->lod_ModeID,
				      BIDTAG_DIPFMustHave,	flags,
d579 2
a580 2
				      BIDTAG_NominalWidth,	lod->lod_BMHD.bmh_PageWidth,
				      BIDTAG_NominalHeight,	lod->lod_BMHD.bmh_PageHeight,
d582 2
a583 2
				      BIDTAG_NominalWidth,	lod->lod_BMHD.bmh_Width,
				      BIDTAG_NominalHeight,	lod->lod_BMHD.bmh_Height,
d585 3
a587 3
				      BIDTAG_DesiredWidth,	lod->lod_BMHD.bmh_Width,
				      BIDTAG_DesiredHeight,	lod->lod_BMHD.bmh_Height,
				      BIDTAG_Depth,		lod->lod_BMHD.bmh_Depth,
d591 1
a591 1
		GetDisplayInfoData (NULL, (APTR) & di, sizeof (struct DisplayInfo),  DTAG_DISP, lod->lod_ModeID);
d597 1
a597 1
	    GetDisplayInfoData (NULL, (APTR) &dim, sizeof (struct DimensionInfo),DTAG_DIMS, lod->lod_ModeID);
d599 1
a599 1
	    DB (kprintf ("depth %ld, dim %ld\n", (LONG)fri->fri_Dimensions.Depth, (LONG)dim.MaxDepth));
d737 9
a745 2
	    DB (kprintf ("allocbitmap %ld, %ld, %ld\n", (ULONG) lod->lod_BMHD.bmh_Width, (ULONG) lod->lod_BMHD.bmh_Height, (ULONG)depth));
	    if (lod->lod_BMap = AllocBitMap ((ULONG) lod->lod_BMHD.bmh_Width, (ULONG) lod->lod_BMHD.bmh_Height, depth, BMF_CLEAR, fbm))
d747 1
a747 1
		if (lod->lod_Flags & LODF_REMAP)
a769 1
		}
d771 1
a771 4
		if (remap)
		{
		    DB (kprintf ("get dither colors\n"));
		    for (i = 0; i < lod->lod_NumColors; i++)
d773 7
a779 4
			err1 = color_error (
					       lod->lod_CRegs[i * 3 + 0], lod->lod_GRegs[i * 3 + 0],
					       lod->lod_CRegs[i * 3 + 1], lod->lod_GRegs[i * 3 + 1],
					       lod->lod_CRegs[i * 3 + 2], lod->lod_GRegs[i * 3 + 2]);
d781 1
a781 3
			if (err1 > 2000)
			{
			    for (j = 0; j < lod->lod_NumAlloc; j++)
d783 5
a787 8
				testr = AVGC (i, j, 0);
				testg = AVGC (i, j, 1);
				testb = AVGC (i, j, 2);

				err2 = color_error (
						       lod->lod_CRegs[i * 3 + 0], testr,
						       lod->lod_CRegs[i * 3 + 1], testg,
						       lod->lod_CRegs[i * 3 + 2], testb);
d789 10
a798 4
				if (err2 < err1)
				{
				    err1 = err2;
				    lod->lod_ColorTable2[i] = lod->lod_Allocated[j];
d802 6
d809 6
a814 6

		    DB (kprintf ("xlatebm\n"));
		    odepth = lod->lod_SourceBMap->Depth;
		    lod->lod_SourceBMap->Depth = MIN (odepth, 8);
		    XLateBitMap (lod->lod_SourceBMap, lod->lod_BMap, lod->lod_ColorTable, lod->lod_ColorTable2, lod->lod_BMHD.bmh_Width);
		    lod->lod_SourceBMap->Depth = odepth;
d819 5
a823 3
		errLevel = RETURN_FAIL;
		errNumber = ERROR_NO_FREE_STORE;
		retval = 0L;
d833 3
d837 1
d867 3
a869 3
		       DTA_VisibleVert,		(si->si_VisVert = (LONG)domain->Height),
		       DTA_TotalVert,		(si->si_TotVert = (LONG) lod->lod_BMHD.bmh_Height),
		       DTA_NominalVert, 	(LONG)lod->lod_BMHD.bmh_Height,
d871 6
a876 6
		       DTA_VisibleHoriz,	(si->si_VisHoriz = (LONG) domain->Width),
		       DTA_TotalHoriz,		(si->si_TotHoriz = (LONG) lod->lod_BMHD.bmh_Width),
		       DTA_NominalHoriz,	(LONG) lod->lod_BMHD.bmh_Width,

		       DTA_ErrorLevel,		errLevel,
		       DTA_ErrorNumber,		errNumber,
d878 3
a880 3
		       DTA_Title,		title,
		       DTA_Busy,		FALSE,
		       DTA_Sync,		TRUE,
d888 2
a889 1
UWORD ghost_pattern[] = {0x4444, 0x1111, 0x4444, 0x1111};
d978 3
a980 3
	    left   = sel->Left;
	    top    = sel->Top;
	    width  = sel->Width;
d987 4
a990 4
	    left   = 0;
	    top    = 0;
	    width  = lod->lod_BMHD.bmh_PageWidth;	/* rect.MaxX - rect.MinX + 1; */
	    height = lod->lod_BMHD.bmh_PageHeight;	/*  rect.MaxY - rect.MinY + 1; */
@


39.6
log
@check for failure of remap bitmap
@
text
@d9 1
d214 1
d217 1
d222 1
a395 5
#if 0
#pragma libcall GfxBase BestModeIDA 41A 801
ULONG BestModeIDA (struct TagItem * tags);
#endif

a397 1

d556 1
d586 1
a586 1
		GetDisplayInfoData (NULL, (APTR) & di, sizeof (struct DisplayInfo), DTAG_DISP, lod->lod_ModeID);
d592 5
@


39.5
log
@cleaned up print section.
pass picture width & height instead of page, to BestModeID
@
text
@d7 3
d49 1
d220 2
d223 1
a570 1

d653 2
d661 1
d667 1
d673 1
d706 1
d713 1
d717 1
d728 1
d733 1
d758 1
d788 1
d797 2
d804 1
d809 1
a809 1
	if (!remap)
d811 1
d820 2
d831 1
d835 2
d847 3
d854 1
a854 1

d860 1
a860 2
UWORD ghost_pattern[] =
{0x4444, 0x1111, 0x4444, 0x1111};
@


39.4
log
@implemented DTM_PROCLAYOUT
@
text
@d385 1
d388 1
d566 12
a577 7
				      BIDTAG_SourceID, lod->lod_ModeID,
				      BIDTAG_DIPFMustHave, flags,
				      BIDTAG_NominalWidth, lod->lod_BMHD.bmh_PageWidth,
				      BIDTAG_NominalHeight, lod->lod_BMHD.bmh_PageHeight,
				      BIDTAG_DesiredWidth, lod->lod_BMHD.bmh_Width,
				      BIDTAG_DesiredHeight, lod->lod_BMHD.bmh_Height,
				      BIDTAG_Depth, lod->lod_BMHD.bmh_Depth,
d920 3
a922 3
	    left = sel->Left;
	    top = sel->Top;
	    width = sel->Width;
d928 5
a932 5
	    QueryOverscan (lod->lod_ModeID, &rect, OSCAN_TEXT);
	    left = 0;
	    top = 0;
	    width = rect.MaxX - rect.MinX + 1;
	    height = rect.MaxY - rect.MinY + 1;
@


39.3
log
@put DTM_SELECT handling back in.
@
text
@d9 1
a9 1
Class *initClass (struct ClassBase *cb)
d16 1
a16 1
	cl->cl_UserData           = (ULONG) cb;
d24 1
a24 1
ULONG notifyAttrChanges (struct ClassBase *cb, Object * o, VOID * ginfo, ULONG flags, ULONG tag1,...)
d26 1
d32 1
a32 1
void freeExtraInfo (struct ClassBase *cb, struct localData * lod)
d53 1
a53 1
struct ColorMap *GetObjectColorMap (struct ClassBase *cb, Class * cl, Object * o)
d56 1
a56 1
    struct ColorMap *cm;
d59 1
a59 2
    /* Get a color map */
    if (cm = GetColorMap (lod->lod_NumColors))
d61 11
a71 7
	/* Set the colors */
	for (i = 0; i < lod->lod_NumColors; i++)
	{
	    r = lod->lod_CRegs[i * 3 + 0];
	    g = lod->lod_CRegs[i * 3 + 1];
	    b = lod->lod_CRegs[i * 3 + 2];
	    SetRGB32CM (cm, i, r, g, b);
d95 1
d122 3
a124 3
		    gpr.MethodID   = GM_RENDER;
		    gpr.gpr_GInfo  = ((struct opSet *) msg)->ops_GInfo;
		    gpr.gpr_RPort  = rp;
d138 13
d152 3
a154 1
	    retval += layoutPictureDT (cb, cl, o, (struct gpLayout *) msg);
d180 3
a182 3
		    gpr.MethodID   = GM_RENDER;
		    gpr.gpr_GInfo  = dts->dts_GInfo;
		    gpr.gpr_RPort  = rp;
d215 2
a216 2
	    if (lod->lod_SourceBMap)
		FreeBitMap (lod->lod_SourceBMap);
d229 1
a229 1
ULONG copyMethod (struct ClassBase *cb, Class * cl, Object * o, struct dtGeneral * msg)
d258 1
a258 1
ULONG writeMethod (struct ClassBase *cb, Class * cl, Object * o, struct dtWrite * msg)
d314 1
a314 1
ULONG getPictureDTAttr (struct ClassBase *cb, Class * cl, Object * o, struct opGet * msg)
d332 4
d373 1
a373 1
	    *msg->opg_Storage = (ULONG) &lod->lod_Point;
d385 11
d397 1
a397 1
ULONG setPictureDTAttrs (struct ClassBase *cb, Class * cl, Object * o, struct opSet * msg)
d422 4
d433 12
d462 2
d468 1
a468 1
		lod->lod_Screen = (struct Screen *)tidata;
d472 1
a472 7
		lod->lod_Point = *((Point *)tidata);
		break;

#if 0
	    case DTA_TopVert:
		si->si_TopVert = tidata;
		refresh = 1L;
a475 3
		si->si_VisVert = tidata;
		break;

a476 8
		si->si_TotVert = tidata;
		break;

	    case DTA_TopHoriz:
		si->si_TopHoriz = tidata;
		refresh = 1L;
		break;

a477 3
		si->si_VisHoriz = tidata;
		break;

d479 1
a479 1
		si->si_TotHoriz = tidata;
a480 1
#endif
d536 6
a541 1
	fri->fri_Dimensions.Width = GetBitMapAttr (lod->lod_SourceBMap, BMA_WIDTH);
d543 2
a544 1
	fri->fri_Dimensions.Depth = GetBitMapAttr (lod->lod_SourceBMap, BMA_DEPTH);
d551 1
d555 24
a578 2
	if (GetDisplayInfoData (NULL, (APTR) & di, sizeof (struct DisplayInfo), DTAG_DISP, lod->lod_ModeID) &&
	    (di.NotAvailable == NULL))
d607 1
d619 1
a619 1
ULONG framePictureDT (struct ClassBase *cb, Class * cl, Object * o, struct dtFrameBox * dtf)
d636 1
a636 1
ULONG layoutPictureDT (struct ClassBase *cb, Class * cl, Object * o, struct gpLayout * gpl)
d645 2
a646 7
    notifyAttrChanges (cb, o, gpl->gpl_GInfo, NULL,
		       GA_ID,		G (o)->GadgetID,
		       DTA_Busy,	TRUE,
		       TAG_DONE);

    GetAttr (DTA_ObjName, o, (ULONG *) &title);
    GetAttr (DTA_Domain,  o, (ULONG *) &domain);
d648 2
a649 3
    /* Time to do minor conversion */
    si->si_VisVert = domain->Height;
    si->si_TotVert = lod->lod_BMHD.bmh_Height;
d651 2
a652 2
    si->si_VisHoriz = domain->Width;
    si->si_TotHoriz = lod->lod_BMHD.bmh_Width;
d664 1
d672 20
a691 4
	/* Set up tags */
	tags[0].ti_Tag = OBP_Precision;
	tags[0].ti_Data = PRECISION_IMAGE;
	tags[1].ti_Tag = TAG_DONE;
d693 6
a698 22
	/* Set the layout flag */
	si->si_Flags |= DTSIF_LAYOUT;

	/* Time to do major conversion */
	lod->lod_ColorMap = scr->ViewPort.ColorMap;
	depth = MAX (scr->BitMap.Depth, (ULONG) lod->lod_BMHD.bmh_Depth);

	/* Get a pointer to the friend bitmap */
	fbm = (scr) ? &(scr->BitMap) : NULL;

	/* Free the extra information */
	freeExtraInfo (cb, lod);

	/* Clear the histogram table */
	memset (lod->lod_Histogram, 0, lod->lod_HistoSize);

	/* Fill the histogram table */
	TallyBitMap (lod->lod_SourceBMap, lod->lod_Histogram, lod->lod_BMHD.bmh_Width);

	if (lod->lod_BMap = AllocBitMap ((ULONG) lod->lod_BMHD.bmh_Width, (ULONG) lod->lod_BMHD.bmh_Height, depth, BMF_CLEAR, fbm))
	{
	    if (lod->lod_Flags & LODF_REMAP)
d700 1
a700 1
		for (i = 0; i < lod->lod_NumColors; i++)
d702 2
a703 9
		    if (lod->lod_Histogram[i])
		    {
			got = ObtainBestPenA (lod->lod_ColorMap, lod->lod_CRegs[i * 3 + 0], lod->lod_CRegs[i * 3 + 1], lod->lod_CRegs[i * 3 + 2], tags);
			GetRGB32 (lod->lod_ColorMap, got, 1, (lod->lod_GRegs + (lod->lod_NumAlloc * 3)));
			lod->lod_Allocated[lod->lod_NumAlloc++] = got;
			if (got != i)
			    remap = TRUE;
			lod->lod_ColorTable[i] = lod->lod_ColorTable2[i] = got;
		    }
d707 1
a707 1
	    if (remap)
d709 1
a709 1
		for (i = 0; i < lod->lod_NumColors; i++)
d711 1
a711 6
		    err1 = color_error (
					   lod->lod_CRegs[i * 3 + 0], lod->lod_GRegs[i * 3 + 0],
					   lod->lod_CRegs[i * 3 + 1], lod->lod_GRegs[i * 3 + 1],
					   lod->lod_CRegs[i * 3 + 2], lod->lod_GRegs[i * 3 + 2]);

		    if (err1 > 2000)
d713 1
a713 1
			for (j = 0; j < lod->lod_NumAlloc; j++)
d715 17
a731 3
			    testr = AVGC (i, j, 0);
			    testg = AVGC (i, j, 1);
			    testb = AVGC (i, j, 2);
d733 8
a740 4
			    err2 = color_error (
						   lod->lod_CRegs[i * 3 + 0], testr,
						   lod->lod_CRegs[i * 3 + 1], testg,
						   lod->lod_CRegs[i * 3 + 2], testb);
d742 3
a744 1
			    if (err2 < err1)
d746 14
a759 2
				err1 = err2;
				lod->lod_ColorTable2[i] = lod->lod_Allocated[j];
d763 5
a768 5

		odepth = lod->lod_SourceBMap->Depth;
		lod->lod_SourceBMap->Depth = MIN (odepth, 8);
		XLateBitMap (lod->lod_SourceBMap, lod->lod_BMap, lod->lod_ColorTable, lod->lod_ColorTable2, lod->lod_BMHD.bmh_Width);
		lod->lod_SourceBMap->Depth = odepth;
d772 1
a772 3
		BltBitMap (lod->lod_SourceBMap, 0, 0,
			   lod->lod_BMap, 0, 0, lod->lod_BMHD.bmh_Width, lod->lod_BMHD.bmh_Height,
			   0xC0, 0xFF, NULL);
d775 23
a797 13
	    if (lod->lod_Flags & LODF_FREESRC)
	    {
		FreeBitMap (lod->lod_SourceBMap);
		lod->lod_SourceBMap = NULL;
	    }
	}
	else
	{
	    retval = 0L;
	}

	si->si_TotVert = lod->lod_BMHD.bmh_Height;
	si->si_TotHoriz = lod->lod_BMHD.bmh_Width;
d799 2
a800 3
	/* Clear the layout flag */
	si->si_Flags &= ~DTSIF_LAYOUT;
    }
d802 1
d804 12
a815 9
		       GA_ID,		G (o)->GadgetID,
		       DTA_VisibleVert,	si->si_VisVert,
		       DTA_TotalVert,	si->si_TotVert,
		       DTA_NominalVert,	si->si_TotVert,
		       DTA_VisibleHoriz,si->si_VisHoriz,
		       DTA_TotalHoriz,	si->si_TotHoriz,
		       DTA_NominalHoriz,si->si_TotHoriz,
		       DTA_Title,	title,
		       DTA_Busy,	FALSE,
d823 2
a824 1
UWORD ghost_pattern[] = {0x4444, 0x1111, 0x4444, 0x1111};
d828 1
a828 1
ULONG renderMethod (struct ClassBase *cb, Class * cl, Object * o, struct gpRender * msg)
d838 1
a838 1
    if (!lod->lod_BMap)
a849 8
	if ((msg->MethodID == GM_RENDER) && (msg->gpr_Redraw == GREDRAW_REDRAW) &&
	    (si->si_OTopVert != si->si_TopVert) && (si->si_OTopVert != si->si_TopVert))
	{
	    EraseRect (rp,
		       domain->Left, domain->Top,
		       domain->Left + domain->Width - 1,
		       domain->Top + domain->Height - 1);
	}
a851 1

d873 1
d881 1
a881 1

d887 1
a887 1
ULONG printMethod (struct ClassBase *cb, Class * cl, Object * o, struct dtPrint * msg)
@


39.2
log
@added support for DTA_Methods attribute.
@
text
@d117 3
a119 3
		    gpr.MethodID = GM_RENDER;
		    gpr.gpr_GInfo = ((struct opSet *) msg)->ops_GInfo;
		    gpr.gpr_RPort = rp;
d149 1
d160 3
a162 3
		    gpr.MethodID = GM_RENDER;
		    gpr.gpr_GInfo = dts->dts_GInfo;
		    gpr.gpr_RPort = rp;
a363 1
    struct DTSpecialInfo *si = (struct DTSpecialInfo *) G (o)->SpecialInfo;
@


39.1
log
@added screen, point and free source bitmap flag.
@
text
@a131 5
	case DTM_FRAMEBOX:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    retval += framePictureDT (cb, cl, o, (struct dtFrameBox *) msg);
	    break;

d142 5
d265 27
d299 4
@


39.0
log
@initial RCS
@
text
@a8 7
#define	DR(x)	;
#define	DS(x)	;
#define	DL(x)	;
#define	DD(x)	;

/*****************************************************************************/

d16 1
a16 1
	cl->cl_UserData = (ULONG) cb;
a105 1
	    DS (kprintf ("om_set (picture)\n"));
a138 1
	    DL (kprintf ("gm_layout : layoutPictureDT\n"));
a139 1
	    DL (kprintf ("gm_layout : retval=%ld\n", retval));
d316 4
d363 7
d383 9
d417 1
d548 1
a551 1
    DL (kprintf (" notify busy\n"));
a559 2
    DD (kprintf (" layout %ld,%ld,%ld,%ld\n", (ULONG)domain->Left, (ULONG)domain->Top, (ULONG)domain->Width, (ULONG)domain->Height));

d562 1
a562 1
    si->si_TotVert = lod->lod_BMHD.h;
d565 4
a568 1
    si->si_TotHoriz = lod->lod_BMHD.w;
d571 1
a571 2
    DL (kprintf (" initial=%ld, gi=0x%lx\n", gpl->gpl_Initial, gpl->gpl_GInfo));
    if (gpl->gpl_Initial && gpl->gpl_GInfo)
a572 2
	struct Screen *scr = gpl->gpl_GInfo->gi_Screen;
	struct Window *win = gpl->gpl_GInfo->gi_Window;
a589 1
	DL (kprintf (" start layout : win=0x%lx title=%s\n", win, win->Title));
d594 1
a594 1
	depth = MAX (scr->BitMap.Depth, (ULONG) lod->lod_BMHD.nplanes);
a602 1
	DL (kprintf (" clear memory\n"));
d606 1
a606 2
	DL (kprintf (" tallybitmap\n"));
	TallyBitMap (lod->lod_SourceBMap, lod->lod_Histogram, lod->lod_BMHD.w);
d608 1
a608 2
	DL (kprintf (" alloc bitmap\n"));
	if (lod->lod_BMap = AllocBitMap ((ULONG) lod->lod_BMHD.w, (ULONG) lod->lod_BMHD.h, depth, BMF_CLEAR, fbm))
a611 1
		DL (kprintf (" get pens\n"));
a627 1
		DL (kprintf (" build dither map\n"));
a656 1
		DL (kprintf (" remap bitmap\n"));
d659 1
a659 1
		XLateBitMap (lod->lod_SourceBMap, lod->lod_BMap, lod->lod_ColorTable, lod->lod_ColorTable2, lod->lod_BMHD.w);
a663 1
		DL (kprintf (" blit\n"));
d665 1
a665 1
			   lod->lod_BMap, 0, 0, lod->lod_BMHD.w, lod->lod_BMHD.h,
d668 6
d680 2
a681 3
	DL (kprintf (" finish layout\n"));
	si->si_TotVert = lod->lod_BMHD.h;
	si->si_TotHoriz = lod->lod_BMHD.w;
a686 1
    DL (kprintf (" notify done\n"));
a717 1
    DR (kprintf ("renderMethod (picture)\n"));
d724 2
a725 4
    DD (kprintf (" render %ld,%ld,%ld,%ld\n", (ULONG)domain->Left, (ULONG)domain->Top, (ULONG)domain->Width, (ULONG)domain->Height));

    width = (ULONG) MIN (lod->lod_BMHD.w, domain->Width);
    height = (ULONG) MIN (lod->lod_BMHD.h, domain->Height);
a737 1
	DR (kprintf ("blit\n"));
a768 4
    else
    {
	DR (kprintf ("no rastport\n"));
    }
d824 1
a824 1
	    if ((lod->lod_BMHD.w == width) && (lod->lod_BMHD.h == height))
d831 1
a831 1
		tmpl = lod->lod_BMHD.w;
@
