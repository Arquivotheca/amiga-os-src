head     1.28;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @@;


1.28
date     94.03.02.14.57.00;  author jesup;  state Exp;
branches ;
next     1.27;

1.27
date     92.12.16.11.46.37;  author jesup;  state Exp;
branches ;
next     1.26;

1.26
date     92.12.16.11.35.13;  author jesup;  state Exp;
branches ;
next     1.25;

1.25
date     92.12.06.21.47.35;  author jesup;  state Exp;
branches ;
next     1.24;

1.24
date     92.09.08.13.20.24;  author jesup;  state Exp;
branches ;
next     1.23;

1.23
date     92.09.01.16.51.09;  author jesup;  state Exp;
branches ;
next     1.22;

1.22
date     92.08.25.00.51.10;  author jesup;  state Exp;
branches ;
next     1.21;

1.21
date     92.07.10.17.31.07;  author jesup;  state Exp;
branches ;
next     1.20;

1.20
date     92.07.07.22.02.12;  author jesup;  state Exp;
branches ;
next     1.19;

1.19
date     92.04.09.00.55.51;  author jesup;  state Exp;
branches ;
next     1.18;

1.18
date     91.05.07.08.21.21;  author steveb;  state Exp;
branches ;
next     1.17;

1.17
date     91.03.21.14.35.15;  author steveb;  state Exp;
branches ;
next     1.16;

1.16
date     91.02.22.14.06.39;  author steveb;  state Exp;
branches ;
next     1.15;

1.15
date     91.01.17.14.29.53;  author steveb;  state Exp;
branches ;
next     1.14;

1.14
date     91.01.08.14.30.55;  author steveb;  state Exp;
branches ;
next     1.13;

1.13
date     90.12.17.08.18.17;  author steveb;  state Exp;
branches ;
next     1.12;

1.12
date     90.10.18.08.53.54;  author steveb;  state Exp;
branches ;
next     1.11;

1.11
date     90.10.17.11.18.57;  author steveb;  state Exp;
branches ;
next     1.10;

1.10
date     90.09.20.17.40.08;  author steveb;  state Exp;
branches ;
next     1.9;

1.9
date     90.06.05.13.03.50;  author steveb;  state Exp;
branches ;
next     1.8;

1.8
date     90.04.06.15.18.08;  author steveb;  state Exp;
branches ;
next     1.7;

1.7
date     89.12.08.01.06.10;  author steveb;  state Exp;
branches ;
next     1.6;

1.6
date     89.12.06.10.47.21;  author steveb;  state Exp;
branches ;
next     1.5;

1.5
date     89.10.05.11.55.50;  author steveb;  state Exp;
branches ;
next     1.4;

1.4
date     89.07.13.15.18.42;  author steveb;  state Exp;
branches ;
next     1.3;

1.3
date     89.04.10.17.06.19;  author steveb;  state Exp;
branches ;
next     1.2;

1.2
date     89.03.13.17.00.12;  author steveb;  state Exp;
branches ;
next     1.1;

1.1
date     89.03.13.16.46.40;  author steveb;  state Exp;
branches ;
next     ;


desc
@1.3.1
@


1.28
log
@added comment about deletefromet
@
text
@		SECTION filesystem,CODE

		NOLIST
		INCLUDE	"exec/types.i"
		INCLUDE	"dos/dosextens.i"
		INCLUDE "dos/exall.i"
		INCLUDE	"utility/hooks.i"
		INCLUDE	"globals.i"
		INCLUDE	"moredos.i"
		INCLUDE	"private.i"
		INCLUDE	"printf.mac"
		LIST

;		DEBUGENABLE

		XREF	Type,LooseBlock,WorkFail,WorkDone,LooseKeyBlock
		XREF	CheckLock,WaitBlock,GetPubMem,Hash,IsDir,_LVOFreeMem
		XREF	_LVOMatchPatternNoCase,NextListEntry,LooseA3Block

		XDEF	ExObject,ExNext,ExAll,DoInfo

;==============================================================================
; ExObject( packet )
;	      d0
;
; Returns information about the required object (using the lock in the packet).
; Doesn't save any registers because it's called as a co-routine and goes away.
;==============================================================================
ExObject	movea.l	d0,a2			save packet address
		movea.l	dp_Arg1(a2),a0		check the lock (BPTR)
	printf <'Examine called, lock=%ld\n'>

		bsr	CheckLock		will set key=0 if invalid
		move.l	d0,d2			was lock valid ?
		bne.s	ExObjOK			yes
		movea.l	a2,a0
		bra	WorkFail		lock was bad

ExObjOK		tst.l	dp_Arg1(a2)		if using a NULL lock
		beq.s	10$			don't attempt to mark it

		movea.l	dp_Arg1(a2),a0		mark lock as examined
		adda.l	a0,a0
		adda.l	a0,a0
		moveq.l	#-1,d1
		move.l	d1,fl_Examined(a0)

10$		bsr	WaitBlock		get the required key
		movea.l	d0,a3			stash the buffer
		bra	SetInfo			and return info about it


;==============================================================================
; entry = GetDCEntry( NET, lastkey, packet)
;   a0                a4      d4      a2
;
; Most of this routine isn't needed for ExAll, just for ExNext, though ExAll
; benefits whenever it has to break also.  Returns NULL if there isn't an
; entry to examine.  If it returns null, either no block is locked 
; (NET_BlockNum = 0) OR the initial block is still locked (NET_BlockNum != 0)
;
;==============================================================================

; Fetch dirlist block, and find the right entry.  The info
; in the dirlist is always the next entry you want to fetch.  If need be, the
; old entry value is in d4 (from fib_DiskKey).

; If NET_NextBlockNum and d2 are the same, we never let go of the dircache
; block,
; we KNOW we have the block and entry we want.  Go to GotDCBlock to find the
; right spot.  Somewhat inefficient.  Should save ptr to entry in reg!!!!!
GetDCEntry:
	printf <'GetDCEntry block %ld, key %ld\n'>,NET_NextBlockNum(a4),NET_NextKey(a4)
;	printf <'	current block %ld ($%lx)'>,NET_BlockNum(a4),NET_BlockPtr(a4)
		movem.l	d2/d5/d6/a3,-(sp)	MUST match NextDCEntry!!!!

		; restore variables from NET structure
		move.l	NET_BlockNum(a4),d2	0 if no block currently held!
		move.l	NET_BlockPtr(a4),a3
		move.l	NET_NextBlockNum(a4),d0
		beq	GetDCNoMore		if 0, last one returned was end
		cmp.l	d2,d0			is this the same block we have?
		beq.s	GotDCBlock 

;	printf <'need to get block %ld (old %ld)...'>,d0,d2
		; if we don't have the right block, we have no block (d2=0)
		move.l	d0,d2			save for looseblock
		bsr	WaitBlock
		move.l	d0,a3			keep buffer

; If numentries is 0, then the file must have been deleted (and no other
; entries were in the block).  Grab the next entry in any following list block.
; If we merely don't find it, search for the previous entry in the current
; listblock.  If we don't find THAT, just take the first one here and hope.
; If we do find it, take the next one, of course.

; Note: if NET_NextKey is 0 (initial exnext call), then we'll fail to find
; it anywhere, and will fail to find the previous one.  We should return the
; first entry in the current block (or first block with an entry).  (It fails
; to find the previous one (d4) since the previous one is the directory this
; is in, and no directory can be in it's own dirlist.  NOTE: on the first
; (and all) exnext calls, fl_Examined will be !0.  If it's 0, the lock was
; unlocked, and if we can't find the entry return no_more_entries.

GotDCBlock:	move.l	cb_SIZEOF+fhl_NumEntries(a3),d6
	printf <'got dirlist $%lx, entries=%ld\n'>,a3,d6

		subq.w	#1,d6
		move.w	d6,d5			save original number of entries
		bmi.s	GetNextListBlock	none - must have been deleted!
		lea.l	cb_SIZEOF+fhl_Entries(a3),a0
		move.l	a0,a1			save original entries ptr
		bra.s	20$
10$		bsr	NextListEntry		updates a0,d6.w
20$		move.l	fle_Key(a0),d1
		cmp.l	NET_NextKey(a4),d1	see if it's the right entry
		beq.s	FoundNextEntry		got it!
		tst.w	d6			run out of entries yet?
		bne.s	10$

	printf <'didnt find the entry!  must have been deleted!\n'>
		; didn't find our entry in this list block (must have been
		; deleted or maybe commented).  Search for previous entry.
		move.w	d5,d6
		move.l	a1,a0			get entries ptr back
		bra.s	40$
30$		bsr	NextListEntry		updates a0,d6
40$		cmp.l	fle_Key(a0),d4		see if it's the previous entry
		beq.s	ReturnNextEntry		got it!
		tst.w	d6			run out of entries yet?
		bne.s	30$

		; handle people who unlock the main lock between exnexts.
		; we use the fl_examined flag to know if anyone ever examined
		; this lock...
		cmp.l	#ACTION_EXAMINE_ALL,dp_Action(a2)
		beq.s	ReturnFirstEntry	this kludge is only for Exnext

		move.l	dp_Arg1(a2),a0		Lock
		add.l	a0,a0
		add.l	a0,a0			bptr->cptr
		tst.l	fl_Examined(a0)		was it ever examined?
		bne.s	ReturnFirstEntry	yes, return first in block

		; added test - if the previous item was the parent, return the
		; first entry anyways.  This handles people who unlock after
		; the Examine before the first ExNext...
		move.l	cb_SIZEOF+fhl_Parent(a3),d0
		cmp.l	d0,d4
		beq.s	ReturnFirstEntry

	printf <'didnt find previous entry, lock never examined...'>
		; d0 is parent - associate with parent
		bsr	LooseA3Block
		moveq	#0,d2			no block held...
		bra.s	GetDCNoMore		we're done...
		
		; didn't find either previous or next.  Return first entry
		; in current block.
ReturnFirstEntry
	printf <'didnt find previous entry! return first entry!\n'>
		move.l	a1,a0			get entries ptr back
		move.w	d5,d6			indicate we didn't skip any

; We found the entry we want.  a0 points to entry, d6.w is number
; of entries left in this block, NOT including this one.  d2 is block
; number, a3 is block.
FoundNextEntry	; save variables in NET structure for next call
		move.l	a0,NET_Entry(a4)
		move.l	d2,NET_BlockNum(a4)	0 if no block currently held!
		move.l	a3,NET_BlockPtr(a4)
		move.w	d6,NET_NumEntries(a4)	only needed for NextDCEntry...
		movem.l	(sp)+,d2/d5/d6/a3	MUST match NextDCEntry!!!!
		rts

; we come here when we found the previous entry returned.  Skip it and
; return the next entry.  a0 is last entry returned, d6 is entries left
; NOT including this one
ReturnNextEntry printf <'ReturnNextEntry'>
		tst.w	d6			any more entries?
		beq.s	GetNextListBlock	no, get next block
		bsr	NextListEntry		finds the one we want
		bra	FoundNextEntry		and return it

; we come here when we want to return the first entry of the next list
; block (with entries).
GetNextListBlock: printf <'GetNextListBlock'>
;	printf <'1:loosing block %ld ($%lx)'>,d2,a3
		move.l	cb_SIZEOF+fhl_Parent(a3),d0	associate with parent
		move.l	cb_SIZEOF+fhl_NextBlock(a3),d2  new list block
		bsr	LooseA3Block

;	printf <'getting block %ld'>,d2
		; get next list block
		move.l	d2,d0
		beq.s	GetDCNoMore		if no more blocks, we're done
		bsr	WaitBlock
		move.l	d0,a3
		tst.l	cb_SIZEOF+fhl_NumEntries(a3)
		beq.s	GetNextListBlock	none in this, fetch _next_ one

		; finally found a block with entries.  Return first.
		move.l	cb_SIZEOF+fhl_NumEntries(a3),d6
		subq.w	#1,d6				don't include this one
		lea	cb_SIZEOF+fhl_Entries(a3),a0	entry to return
		move.l	d2,NET_NextBlockNum(a4)	we have an entry, set up ET
		bra	FoundNextEntry

; no entry to return (must have been deleted).  d2 is 0 or block to loose.
GetDCNoMore:	sub.l	a0,a0			return NULL entry ptr
		bra	FoundNextEntry		so the vars get updated

;==============================================================================
; NextDCEntry( NET )
;              a4
;
; called after data is extracted from the entry, to set up for the next
; entry.  Sets NET_NextBlockNum and NET_NextKey.
;
;==============================================================================
NextDCEntry	movem.l	d2/d5/d6/a3,-(sp)	MUST match GetDCEntry!!!!

		; restore variables from NET structure
		move.l	NET_Entry(a4),a0
		move.l	NET_BlockNum(a4),d2	0 if no block currently held!
		move.l	NET_BlockPtr(a4),a3
;	printf <'NextDCEntry block %ld, entry $%lx\n'>,d2,NET_NumEntries-2(a4)
		move.w	NET_NumEntries(a4),d6

		; tst.w	d6			any more entries?
		beq.s	NextListNeeded
		bsr	NextListEntry		(a0,d6.w)
		; NET_NextBlockNum is still correct
NextDCSetKey
	printf <'NexDCEntry key %ld, block %ld, buffer $%lx'>,fle_Key(a0),d2,a0
		move.l	fle_Key(a0),NET_NextKey(a4)	next entry to return
NextDCDone:	bra	FoundNextEntry		saves vars in NET and returns

; we succeeded, but we need to fetch the next list block to find the next
; entry for the ET.
NextListNeeded
		move.l	cb_SIZEOF+fhl_Parent(a3),d0	associate with parent
		move.l	cb_SIZEOF+fhl_NextBlock(a3),d2  new list block
		bsr	LooseA3Block

		; get the next list block, if any
		clr.l	NET_NextBlockNum(a4)	default, return NO_MORE next
		move.l	d2,d0
		beq.s	NextDCDone		no more lists, return success
		bsr	WaitBlock		fetch next list block
		move.l	d0,a3
;	printf <'Fetched next list block %ld ($%lx)'>,d2,a3
		tst.l	cb_SIZEOF+fhl_NumEntries(a3)
		beq.s	NextListNeeded		none in this, fetch _next_ one

		; this leaves NextBlockNum and BlockNum the same, and Blockptr
		; now points to the next block.

		move.l	d2,NET_NextBlockNum(a4)	we have an entry, set up ET
		lea	cb_SIZEOF+fhl_Entries(a3),a0
;	printf <'Setting NextKey to %ld'>,fle_Key(a0)
		bra.s	NextDCSetKey		got it, set next key and return


;==============================================================================
; ET,parent = GetET( last, packet )
; d0,d1               d0     a2
;
; returns valid ET in d0.  Also checks the lock, makes sure the parent
; is a directory, etc.  last is used to know if we just want to validate it
; or if we want to rebuild the ET.  if last == parent, this is the first time
; through.  If this fails, it kills the coroutine, so no error checking is
; needed.  If last == 0, this was called from ExAll.
;==============================================================================
GetET		movem.l	d3-d6/a2-a4,-(sp)
		move.l	d0,d4			save last block examined
		movea.l	dp_Arg1(a2),a0		check the lock
		bsr	CheckLock
		move.l	d0,d3			stash parent directory key
		bne.s	CheckForET		no problems, it's valid
GetETFail	movea.l	a2,a0			return bad lock error
	printf <'ParentKey was bad, exiting\n'>
		bra	WorkFail		kills coroutine

CheckForET
; before we go any further, see if we have a valid ExamineThing in the Lock
		movea.l	dp_Arg1(a2),a0		check for the ExamineThing
		adda.l	a0,a0
		adda.l	a0,a0
		move.l	a0,d6			save lock ptr
		movea.l	fl_SIZEOF(a0),a4	is there an ET attached?
		cmp.w	#0,a4
		beq.s	AllocET			none there, make one

; there is an examinething here but we may have to rebuild the list of keys
; in case someone is re-using a lock for another list or dir call.  This
; happens every time you do a dir or list in the current directory.  We can
; quite easily test for this if fib_LastKey=parentkey
		tst.l	d4			were we called by ExAll?
		beq.s	20$			yes, must be first ExAll

; it's from ExNext: figure out if we need to rebuild
		tst.l	fl_Examined(a0)		do we need to rebuild?
		beq.s	20$			yes, unlocked between calls
		cmp.l	d3,d4			is this the first ExNext ?
		bne	GetETDone		no, so carry on normally
20$:
	printf <'First ExNext/ExAll, reusing ET\n'>
; see if this is a dos\4 filesystem.  If so, and validator succeeded, we
; will reset a NewExamineThing.
		tst.b	ET_Type(a4)
		beq.s	old_et			what type was it?
		tst.w	BitmapValid(a5)
		bne.s	new_et			use old if bitmap invalid

; very strange.  We have an NET, and yet the bitmap is invalid.  Maybe it
; was removed, modified, reinserted and is validating.  Free the NET and
; go to GetET (it will make an old one).  a0 still is FileLock.
		clr.l	fl_SIZEOF(a0)		make sure ptr is cleared
		move.l	a4,a1			NET to free
		moveq.l	#NET_SIZEOF,d0
		jsr	_LVOFreeMem(a6)
		bra.s	AllocET

new_et:		; we have and want an NET.  clear it and reuse
		; newly allocated ones are clear
		clr.l	NET_NextKey(a4)		clear out current key value
		clr.l	NET_NextBlockNum(a4)
		clr.l	NET_BlockNum(a4)
		bra.s	InitET

; we need to clear out any keys hanging around in the ExamineThing because
; they would screw up the sort code if we left them there.
old_et		lea.l	ET_Entries(a4),a0
		move.l	HTSize(a5),d0		clear for size of hashtable
10$		clr.l	(a0)+
		dbra	d0,10$
		bra.s	InitET			and initialise it now

; there wasn't an examinething attached to the lock so we must make one now
; see if this is a dos\4 filesystem.  If so, and validator succeeded, we
; will build a NewExamineThing.
AllocET	printf <'Constructing ExamineThing\n'>
		btst.b	#2,DiskType+3(a5)	Are we using fast dirs?
		beq.s	10$			what type was it?
		tst.w	BitmapValid(a5)
		beq.s	10$			use old if bitmap invalid
		moveq.l	#NET_SIZEOF,d0		NewExamineThing size
		moveq.l	#1,d5			for ET_TYPE
	printf <'allocating NET\n'>
		bra.s	20$

		; build old-style examinething
10$		move.l	HTSize(a5),d0		get number of hashtable entries
		lsl.l	#2,d0			convert to byte size
		add.l	#4+ET_SIZEOF,d0		+ ending entry and currentkey
		moveq	#0,d5			old-style ExamineThing

		; do the actual allocation
20$		bsr	GetPubMem		allocated clear
		tst.l	d0
		bne.s	GotET			and initialise the key list
		move.l	#ERROR_NO_FREE_STORE,ErrorCode(a5)
		bra	GetETFail		error out

; we have an ExamineThing now but we must initialise and sort the key list
; d5 is the type of the new ET
GotET		movea.l	d0,a4			stash ExamineThing pointer
		move.b	d5,ET_Type(a4)		set the type of ET
		movea.l	d6,a0			in the lock structure too
		move.l	a4,fl_SIZEOF(a0)	** gotta update includes **

InitET		move.l	d3,d0			read parent directory key
		bsr	WaitBlock
		movea.l	d0,a3

		move.l	d3,-(sp)		stash parent key for a while

; make sure it was a directory that was initially examined and not a file header
; If it's not a directory - return error_no_more_entries.  Lock will be
; cleaned up when UnLock is called (ET freed).  If we branch to NoMore, we don't
; care about stuff on the stack (the coroutine is being killed).
		movea.l	a3,a0
		bsr	IsDir			preserves a0!
		tst.l	d0
		beq	NoMore			returns packet, kills coroutine

		tst.b	ET_Type(a4)		which type of examinething?
		beq.s	FillOldET

		; fill in new-style ET
		move.l	BlockSize(a5),d0	find first dirlist block
		move.l	cb_SIZEOF+vudb_DirList(a3,d0.l),NET_NextBlockNum(a4)
		addq.w	#4,sp			drop dir block # (d3 is valid!)
		bra.s	DropDir			done with directory

		; fill an old-stype ET
FillOldET	lea.l	cb_SIZEOF+udb_HashTable(a3),a0
		move.l	HTSize(a5),d3		number of entries to search
		subq.l	#1,d3
FillLoop	move.l	(a0)+,d0		get next key
		beq.s	30$			nothing there
		lea.l	ET_Entries(a4),a1	put entries lowest to highest
10$		move.l	(a1)+,d1		get next entry in table
		beq.s	20$			-4(a1) is where it lives
		cmp.l	d1,d0
		bgt.s	10$
		move.l	d0,-4(a1)		found slot for this one
		move.l	d1,d0
		bra.s	10$
20$		move.l	d0,-4(a1)		fill in last entry
30$		dbra	d3,FillLoop		keep going

		move.l	(sp)+,d3		get back parent key
		lea.l	ET_Entries(a4),a1	fill in current key
		move.l	a1,ET_CurrentKey(a4)

DropDir		move.l	d3,d0			associate with this block (itself)
		bsr	LooseA3Block		frees parent block

		; we have an ET, return it
GetETDone	move.l	a4,d0
		move.l	d3,d1
		movem.l	(a7)+,d3-d6/a2-a4
		rts

;==============================================================================
; GetLinkInfo ( source, dest, sourcetype, dest-type, ed-type)
;		  a0     a1      d0          d1        d2
;
; Sets the fields that can be modified by a link.  REQUIRES HOLDING 2
; BUFFERS AT ONCE!  (This is ok now).  SrcType 0 means source is a buffer, type
; 1 means source is an fle pointer.  DestType 0 means fib, type 1 means an
; ExAllData structure (ed_...).  Preserves all regs.  d2 only valid for
; dest-type 1.
;==============================================================================
GetLinkInfo:	movem.l	d0-d1/d3/a0-a2,-(sp)	save regs

		; grab the fields that might be modified by the link...
		tst.l	d0
		beq.s	fhb_passed
		moveq	#0,d3
		move.w	fle_Days(a0),d3		date is stored as words!
		move.l	d3,-(sp)		(gives us 179 years) 20(sp)
		move.w	fle_Min(a0),d3
		move.l	d3,-(sp)			16(sp)
		move.w	fle_Tick(a0),d3
		move.l	d3,-(sp)			12(sp)
		move.l	fle_Size(a0),-(sp)		8(sp)
		move.l	fle_Protection(a0),-(sp)	4(sp)
		move.l	fle_OwnerXID(a0),-(sp)		0(sp)
		bra.s	got_data

fhb_passed:	lea	cb_SIZEOF(a0),a0
		add.l	BlockSize(a5),a0		a0 = vfhb ptr
		move.l	vfhb_Days(a0),-(sp)		20(sp)
		move.l	vfhb_Mins(a0),-(sp)		16(sp)
		move.l	vfhb_Ticks(a0),-(sp)		12(sp)
		move.l	vfhb_ByteSize(a0),-(sp)		8(sp)
		move.l	vfhb_Protect(a0),-(sp)		4(sp)
		move.l	vfhb_OwnerXID(a0),-(sp)		0(sp)

got_data:	; a0 is fle_xxx or vfhb_xxx...
		; save some regs
		move.l	a1,a2			dest structure ptr
		move.l	d1,d3			dest structure type
		bne.s	5$			it's not a fib
		move.l	fib_EntryType(a2),d1
		bra.s	7$
5$		move.l	ed_Type(a2),d1
7$
		cmpi.w	#ST_FLINK,d1		is it a file link ?
		beq.s	10$			yep
		cmpi.w	#ST_DLINK,d1		was it a directory link ?
		bne.s	50$			nope, normal dir or file

; It's a link!  Grab header this links to.  Requires 2 buffers!!!! FIX (NOT!)
10$		; we must fetch the block, and then the block it's linked to
		; DANGER! we hold 2 blocks here!!! FIX (NOT!)
		tst.l	d0			do we need 1 or two indirects?
		beq.s	20$			1
		move.l	fle_Key(a0),d0		2 indirects
		bsr	WaitBlock		fetch the link
		move.l	d0,a0
		move.l	BlockSize(a5),d0
		move.l	vfhb_Link+cb_SIZEOF(a0,d0.l),-(sp) the "real" file/dir
		bsr	LooseKeyBlock		associate with self
		move.l	(sp)+,d0		now grab the real file/dir
		bra.s	30$

20$		move.l	vfhb_Link(a0),d0	real file/dir to grab

30$		bsr	WaitBlock		grab the linked-to block
		move.l	d0,a0			don't overwrite this!
		lea.l	cb_SIZEOF(a0),a0	reset a0 vfhb ptr
		adda.l	BlockSize(a5),a0

		; modify the values on the stack... (avoid d0!)
		move.l	vfhb_Days(a0),20(sp)		20(sp)
		move.l	vfhb_Mins(a0),16(sp)		16(sp)
		move.l	vfhb_Ticks(a0),12(sp)		12(sp)
		clr.l	8(sp)			size... (assume a dir)
		tst.l	d3			is dest a fib?
		bne.s	35$			no, it's an ed_xxxx
		tst.l	fib_EntryType(a2)	is this a dir?
		bra.s	37$			doesn't modify cc's!!!
35$		tst.l	ed_Type(a2)		is this a dir?
37$		bpl.s	40$			yes
		move.l	vfhb_ByteSize(a0),8(sp) size...
40$		move.l	vfhb_Protect(a0),4(sp)	protection...
		move.l	vfhb_OwnerXID(a0),(sp)	ownerid...

		; ok, dump the linked-to object
		move.l	d0,a0			ptr to buffer still in d0
		bsr	LooseKeyBlock		associate with self

		; these are the fields that are fetched from the link (if any)
50$		tst.l	d3			are we modifying a fib?
		bne.s	60$			no
		move.l	20(sp),fib_DateStamp(a2)   set the date
		move.l	16(sp),fib_DateStamp+4(a2)
		move.l	12(sp),fib_DateStamp+8(a2)
		move.l	8(sp),d0		size
		move.l	d0,fib_Size(a2)
		move.w	BlockShift(a5),d1	make numblocks
		lsr.l	d1,d0			we ignore extensions
		addq.l	#1,d0			for fileheader
		move.l	d0,fib_NumBlocks(a2)	approximate
		move.l	4(sp),fib_Protection(a2)
		move.l	(sp),fib_OwnerUID(a2)	sets both!!
		bra.s	link_exit

60$		; not a fib.  d2 is the ED_xxx value, a2 is ed_xxx ptr
		cmpi.w	#ED_DATE,d2		do we need size
		blt.s	70$			nope
		move.l	20(sp),ed_Days(a2)	set the date
		move.l	16(sp),ed_Mins(a2)
		move.l	12(sp),ed_Ticks(a2)

70$		cmpi.w	#ED_SIZE,d2		do we need size
		blt.s	link_exit		nope
		move.l	8(sp),ed_Size(a2)

		cmpi.w	#ED_PROTECTION,d2	do we need protection bits ?
		blt.s	link_exit		nope
		move.l	4(sp),ed_Prot(a2)

		cmpi.w	#ED_OWNER,d2		do we need owner info ?
		blt.s	link_exit		nope
		move.l	(sp),ed_OwnerUID(a2)

link_exit	lea	6*4(sp),sp		drop the 6 values
		movem.l	(sp)+,d0-d1/d3/a0-a2
		rts

;==============================================================================
; ExNext( packet )
;	    d0
;
; Examines the next entry in a directory.  If the previous call was to Examine
; then fl_SIZEOF will be 0 (no ExamineThing) and fib_DiskKey will be the same
; as the key returned by CheckLock.  This means we will have to set up an
; ExamineThing on this lock and fill it with the keys referenced by this dir.
; These keys are sorted by block order, lowest to highest.
;
; If the previous call was to ExNext then two things can happen.  In the
; normal case, fl_SIZEOF will contain a pointer to an initialised ExamineThing
; and we'll use the state information in there to find where the next file is.
; In the horrible case, the caller could have UnLocked the directory between
; ExNext calls which will have lost all the state information that was held
; in the ExamineThing.  If this is the case, then the ExamineThing is rebuilt
; and all the headers are scanned until we run out or we find the first one
; larger than the current fib_DiskKey.  This is a kluge to support Lattice
; and Manx DNext calls that UnLock the directory between ExNext calls.
;
; New for dos\4: since we have compressed directory blocks, we may also have
; a DirList block number and entry number within it.  This will only happen
; for dos\4 filesystems, and only when the disk has validated successfully
; (after that, they'll be maintained correctly).  We'll also use the fib key
; value to try to reconnect with the right spot if needed, either because of
; the lattice/manx DNext junk, or if the directory changed since we last
; looked at it.  If it did, we'll try to locate the key we wanted in the
; current block.  Deletions can cause it to move down in the current block,
; but not up (currently), and currently it can't move to another block.  If
; the entry is not there at all, we look for the previous entry (fib_DiskKey).
; If we find that, we return the next entry.  If we don't find it, we return
; the first entry of the block (since both must have been deleted - nasty).
; In various cases were one or both were deleted, we may have to fetch more
; dirlist blocks until we find an entry to return.
;
; NET_NextBlockNum = 0 means there are no more entries to return.
;
; The only problem comes from SetComment.  This causes deletion and 
; re-insertion of a block.  we'll live with it showing up twice.  Oh well.
;
; Careful: these need to be coordinated with the insertion/deletion logic!
;==============================================================================
ExNext	printf <'ExNext called\n'>
		movea.l	d0,a2			save the packet
		moveq	#0,d0			we're not ExAll
		movea.l	dp_Arg2(a2),a0		stash fib_LastKey
		adda.l	a0,a0			to make the kluge check quicker
		adda.l	a0,a0
		move.l	fib_DiskKey(a0),d0
		move.l	d0,d4			save last examined for later
		bsr	GetET			returns ET in d0 or KillCo's
		move.l	d0,a4			no error checking needed
		move.l	d1,d3			secondary result is parent key

; now we have a valid ExamineThing pointed to by a4.  Use ET_CurrentKey to
; find out which header we have to read next and check for an extension.
; If it's a new-style ET, handle in new way.
FastMethod	tst.b	ET_Type(a4)		is this new style?
		beq.s	OldFastMethod		no

; get the entry to examine.  NULL means there is no entry. Returns in a0!
		clr.l	NET_BlockNum(a4)	no block currently held
		bsr	GetDCEntry		(a4,d4,a2)
		move.l	a0,d0
		beq	NoMore			no entry to examine (d2==0)

; fill in info and get set for next ExNext.  a0 points to entry.
		movea.l	dp_Arg2(a2),a1		get pointer to fib
		adda.l	a1,a1
		adda.l	a1,a1			cptr
	printf <'FoundNextEntry (%ld, block %ld, left %ld to $%lx)\n'>,fle_Key(a0),NET_BlockNum(a4),NET_NumEntries(a4),a1
		move.l	fle_Key(a0),fib_DiskKey(a1)
		move.b	fle_Type(a0),d0
		ext.w	d0
		ext.l	d0
		move.l	d0,fib_DirEntryType(a1)
		move.l	d0,fib_EntryType(a1)	no one should use this

		movem.l	a0/a1,-(sp)		save (TRICKY below)
		lea	fle_FileName(a0),a0	now filename and comment
		lea	fib_FileName(a1),a1
		moveq	#0,d0
		move.b	(a0),d0
10$		move.b	(a0)+,(a1)+
		dbra	d0,10$			always copies length byte

		move.l	4(sp),a1		TRICKY!!!!
		lea	fib_Comment(a1),a1	now copy comment (a0 is correct)
		moveq	#0,d0
		move.b	(a0),d0
20$		move.b	(a0)+,(a1)+
		dbra	d0,20$			always copies length byte
		movem.l	(sp)+,a0/a1		restore

		; fill in the data that may be modified by a link...
		moveq	#1,d0			a0 is an fle_..., not a fhb
		moveq	#0,d1			dest is a fib
		bsr	GetLinkInfo		(a0,a1,d0,d1- regs unchanged)

		; done filling in entry.  Find next and setup ET for next call
		bsr	NextDCEntry

; FIX!!! can be combined with exall
		; free list block and exit
		bsr	FreeNETBlock

		clr.w	ErrorCode+2(a5)		no error
	printf <'ExNext succeeded'>
		moveq.l	#TRUE,d0		we succeeded
		move.l	a2,a0			packet to return
		bra	WorkDone		all done, return

;
; finally, here's the non-dos\4 method of doing exnext...
;
; THIS WAS BROKEN!  There's a race condition: if the deleted file is the
; next ExamineKey for a FIB, and it gets re-allocated and used to store
; data, then the checksum will be wrong!!!  This causes spurious checksum
; errors!  Now solved with DeleteFromET.
;
OldFastMethod	movea.l	ET_CurrentKey(a4),a0	get next key to read
	printf <'Next ExamineKey=%ld\n'>,(a0)
		move.l	(a0)+,d2
		beq.s	SetInfo			none, we are at the end
		move.l	a0,ET_CurrentKey(a4)	and update current key pointer
		move.l	d2,d0			go read this key
		bsr	WaitBlock
		movea.l	d0,a3			stash the buffer

		lea.l	cb_SIZEOF(a3),a0
		adda.l	BlockSize(a5),a0
		cmp.l	vfhb_Parent(a0),d3	does this file belong ?
		bne.s	30$			no, another header got here!
		cmpi.l	#t.short,cb_SIZEOF+fhb_Type(a3)  valid file type ?
		beq.s	40$			header type checks out OK

; it's possible for another process to delete a key we had stashed and replace
; it with another file in between our ExNext calls.  The above tests make sure
; this is not the case and come here to try again if it was.
30$		; movea.l	a3,a0		no good, scrap this block
		move.l	d2,d0			associate with itself
		bsr	LooseA3Block		(could have been deleted)
		suba.l	a3,a3			no buffer held onto now
		bra.s	OldFastMethod		and try again

; we've a valid header, see if it has an extension to be linked into the table
40$		move.l	vfhb_HashChain(a0),d0
		beq.s	70$			no extension, carry on

; we must insert an extension key into our list of keys to be examined.
		movea.l	ET_CurrentKey(a4),a0
		subq.l	#4,a0			back up pointer by 1
		move.l	a0,ET_CurrentKey(a4)
50$		move.l	4(a0),d1		is next key empty
		beq.s	60$			yep, current pos is our slot
		cmp.l	d1,d0			are we less than next key
		blt.s	60$			yep, current pos is our slot
		move.l	d1,(a0)+		move next key down
		bra.s	50$			and keep looking
60$		move.l	d0,(a0)			save the extra key

; now we have to do the Lattice/Manx kluge check.  If the header key we just
; fetched is less than fib_DiskKey and parent!=fib_DiskKey, loop and try again
;70$		cmp.l	d4,d3			if d3=d4 then first ExNext
;		beq.s	SetInfo			so we can call SetInfo
;		cmp.l	d4,d2			are we past last place ?
;		ble.s	30$			no, loose a3 and scan again

; Changed so that we are not incompatible with oldfs disks.  When the owning
; directory is examined we set a flag in the lock.  If the lock we are now
; using doesn't have this field set, then it has been freed so we will have
; to wind through the ExNext process until we get to the required key.  When
; we find that key, we reset the flag and wind through one more time (to get
; the next entry).
70$		cmp.l	d4,d3
		beq.s	SetInfo

		movea.l	dp_Arg1(a2),a0		in the lock structure too
		adda.l	a0,a0
		adda.l	a0,a0
		tst.l	fl_Examined(a0)		was lock freed between ExNexts?
		bne.s	SetInfo			nope, use the current entry
	printf <'Unlocked, current key = %ld\n'>,d2
		cmp.l	d4,d2			are we back to where we were
		bne.s	30$			no, so search until we are
		subq.l	#1,fl_Examined(a0)	yes, mark as examined
		bra.s	30$			and scan one more entry

;==============================================================================
; SetInfo( packet, buffer, key )
;	     a2	     a3     d2
;
; Fills in a FileInfoBlock with the data from a file or directory header.  The
; packet that requested this info is automatically sent back by this routine
; and the co-routine that called us is killed.  Can fail if buffer or key = 0.
; Doesn't save registers because it's called as a part of various co-routines
; and then killed.  NOTE: packet is in a2 not d0 as with pure co-routines.
; if the key was bad then there will be no buffer to free up.
;
; args were modified because ExNext and ExObject were moving packet and buffer
; from a2 and a3 anyway.  These are the regs that SetInfo used so there was
; no point transferring them.  Just consider SetInfo as part of ExNext or
; ExInfo and this register convention ain't so bad!
;==============================================================================
SetInfo		tst.l	d2			is this a valid key number ?
		bne.s	goodkey			yes, it's OK
NoMore		move.w	#ERROR_NO_MORE_ENTRIES,ErrorCode+2(a5)
		movea.l	a2,a0			fail this packet
		bra	WorkFail		won't come back, end of dir
goodkey		bsr.s	DoInfo			do stuff for the packet
		movea.l	a2,a0
		bra	WorkDone		send packet back and die

;==============================================================================
; This has been broken out as a separate routine so it can be used for ACTION_
; EXAMINE_FH aswell.  Saves us duplicating a whole bunch of code.  Doesn't save
; registers because it's more often called as a co-routine under ExNext and I
; don't want to slow it down too much.  Regs should be saves by EXAMINE_FH code
;==============================================================================
DoInfo	printf <'DoInfo called\n'>
		movea.l	dp_Arg2(a2),a4		get fib pointer
		adda.l	a4,a4			convert to machine ptr
		adda.l	a4,a4
		movea.l	a3,a0			check the type of this buffer
		bsr	Type
		move.l	d0,fib_DirEntryType(a4)	save directory type
		move.l	d0,fib_EntryType(a4)	and plain type
		move.l	d2,fib_DiskKey(a4)	key of where this block is

; name is 8 longwords long
		lea.l	cb_SIZEOF(a3),a0
		adda.l	BlockSize(a5),a0
		movem.l	vfhb_FileName(a0),d0-d7
		movem.l	d0-d7,fib_FileName(a4)

; comment is 20 longwords long
		clr.w	fib_Comment(a4)		assume none
		tst.b	vfhb_Comment(a0)
		beq.s	DoDate			no comment to copy
		movem.l	vfhb_Comment(a0),d0-d7
		movem.l	d0-d7,fib_Comment(a4)
		movem.l	vfhb_Comment+32(a0),d0-d7
		movem.l	d0-d7,fib_Comment+32(a4)
		movem.l	vfhb_Comment+64(a0),d0-d3
		movem.l	d0-d3,fib_Comment+64(a4)

; date is 3 longwords long
DoDate		; date is now handled by GetLinkInfo

; we've done all the stuff that's common to dirs, files and links; now see
; if we need to read another header for a linked file or directory.
		moveq	#0,d0			a0 is an block ptr, not an fle
		move.l	a3,a0			block ptr
		moveq	#0,d1			a1 is a fib ptr
		move.l	a4,a1			fib ptr
		bsr	GetLinkInfo		(a0,a1,d0,d1 - regs unchanged)

; all done, free up this block and return to caller (remember buffer was freed)
		move.l	cb_Key(a3),d0		associate with self
		bsr	LooseA3Block		block back on valid queue
		clr.w	ErrorCode+2(a5)		nothing wrong
		moveq.l	#TRUE,d0		no problems
		rts

;==============================================================================
; ExAll( packet )
;	   d0
;
; Fills a buffer with as many names as possible from the given directory.  The
; packet arguments are as follows :-
;
;	dp_Arg1		BPTR	Lock	lock on directory to be scanned
;	dp_Arg2		APTR	Buffer	memory area to be filled with names
;	dp_Arg3		LONG	Size	maximum size of the memory area
;	dp_Arg4		LONG	Data	codes describing which data is required
;	dp_Arg5		APTR	Control	pointer to control structure
;
; Lock, Buffer and Size are self explanatory though Lock MUST be on a dir.
; Data is a value from 1 to 6 that determines which information is to be
; stored in the buffer.  Each higher value adds a new thing to the list
; as described in the table below:-
;
;	1		FileName
;	2		Type
;	3		Size in bytes
;	4		Protection bits
;	5		3 longwords of date
;	6		Comment (will be NULL if no comment)
;	7		Owner info
;
; The data is put into the buffer in the following format.  Note, only the
; fields selected by the Data value will be present.
;
;	STRUCT ExAllData,0
;		APTR	Next		pointer to next entry or NULL
;		APTR	Name		pointer to CSTR name
;		ULONG	Type		same type values as for ExNext et al.
;		ULONG	Size		size of file in bytes
;		ULONG	Prot		protection bits
;		ULONG	Days		date fields
;		ULONG	Mins
;		ULONG	Ticks
;		APTR	Comment		pointer to BSTR comment
;		LABEL	strings		strings will start here
;	LABEL ExAllData_SIZEOF
;
; The Next field has been included (as have the pointers to name and comment)
; to make it easier for 'C' programs to parse the buffer.  If the strings,
; which are variable length, were made part of the structure, all types of
; unions and casting would be required.
;
; The control structure is required so that FFS can keep track if more than
; one call to ExAll is required.  This happens when there are more names in
; a directory than will fit into the buffer.  The format of the control
; structure is as follows:-
;
;	STRUCTURE Control,0
;		ULONG	Entries		number of entries in buffer (return)
;		ULONG	LastKey		for keeping track (must be 0 to start)
;		APTR	MatchString	pointer to BSTR for pattern matching
;		APTR	MatchFunc	pointer to function for comparing
;	LABEL Control_SIZEOF
;
; Entries:  This field tells the calling application how many entries are
;	    in the buffer after calling ExAll.
;
; LastKey:  This field ABSOLUTELY MUST be initialised to 0 before calling
;	    ExAll for the first time.  Any other value will cause nasty
;	    things to happen.  If ExAll doesn't return ERROR_NO_MORE_ENTRIES,
;	    then this field should not be touched before making the second
;	    and subsequent calls to ExAll.  Whenever ExAll returns TRUE, there
;	    are more calls required before all names have been received.
;	    As soon as a FALSE return is received (and IOErr says no_more..)
;	    then ExAll has completed.
;
; MatchString
;	    if this field is NULL then all filenames will be returned.  If
;	    this field is non-null then it is interpreted as a pointer to
;	    a string that is used to pattern match all file names before
;	    accepting them and putting them into the buffer.  The default
;	    AmigaDOS pattern match routine is used unless......
;
; MatchFunc: ....contains a pointer to a function to perform pattern
;	    matching on two strings.  If no MatchFunc is to be called then
;	    this entry should be NULL.  The MatchFunc is called with
;	    the following parameters:-
;
;	    BOOL = MatchFunc( DataVal, BufferData, MatchString )
;				d0	  a0		a1
;
;	    All args are passed on the stack AND in the indicated registers.
;	    d0-d1/a0-a1 are scratch, all other registers must be restored.
;
;	    DataVal is the number describing which fields are present.
;	    BufferData is the pointer to the current entry in the buffer
;	    MatchString is an APTR to a BSTR to be matched against.
;	    MatchFunc should return FALSE if the entry is not to be
;	    accepted, otherwise return TRUE.
;
;
; ExAll is started as a coroutine, all registers are scratch!
;==============================================================================
ExAll		movea.l	d0,a2			save packet address
		movea.l	dp_Arg5(a2),a3		get control struct
		clr.l	c_Entries(a3)		no entries in buffer
		tst.l	c_LastKey(a3)		is this the first call ?
		bne.s	ExAllContinue		nope, continuing scan

; this is the very first call to ExAll for the given directory.  Check that
; we really do have a directory lock and initialise the ExamineThing to
; start scanning the directory entries.
		moveq.l	#0,d0			this is ExAll calling...
		bsr	GetET			get ET or KillCo this rtn
		move.l	d0,a4			ET or NET
		move.l	d1,d7			key of directory
		bra.s	ExAllSetup

; This entry point is used if this is a subsequent call to ExAll because the
; previous calls didn't get all of the files (there was no room in the buffer).
; It assumes that the given lock has the appropriate ExamineThing so the Lock
; must NOT be freed between calls to ExAll.
ExAllContinue	movea.l	dp_Arg1(a2),a0		get the lock
		adda.l	a0,a0			convert to APTR
		adda.l	a0,a0
		move.l	fl_Key(a0),d7		save disk key of directory
		movea.l	fl_SIZEOF(a0),a4	get the ExamineThing
ExAllSetup
		move.l	dp_Arg2(a2),d2		stash current buffer address
		move.l	dp_Arg3(a2),d3		get max buffer size
		moveq.l	#0,d4			no previous entry yet

; FIX!!! not safe!!!! has the same problem ExNext does!!!!!
; if a file is deleted, and then a new file created using the same header,
; before it has bubbled to the top of the ET, you can jump directories!
; I'll add a sanity check to make sure that any entry found has a parent of
; the current dir - that at least makes the danger minimal.  -- REJ

; now we have a valid ExamineThing pointed to by a4.  Use ET_CurrentKey to
; find out which header we have to read next and check for an extension.
; Note: ET can now be NET!
ExAllLoop	tst.b	ET_Type(a4)
		beq.s	exall_old_et
; DCFS
; get the entry to examine.  NULL means there is no entry.  Returns a0!
		; may be holding a block already....
		move.l	d4,d5			save d4!!!
		movea.l	dp_Arg5(a2),a0		get control struct
		move.l	c_LastKey(a0),d4	last key examined
	printf <'ExAll loop: block %ld ($%lx), nextblock %ld, nextkey %ld, lastkey %ld'>,NET_BlockNum(a4),NET_BlockPtr(a4),NET_NextBlockNum(a4),NET_NextKey(a4),d4
		bsr	GetDCEntry		(a4,d4,a2)
		move.l	d5,d4			restore
		move.l	a0,d0
		beq	ExAllFitted		no entry to examine (d2==0)
		bra.s	reserve_space		 stack

; for non-DCFS partitions
exall_old_et:	movea.l	ET_CurrentKey(a4),a0	is there another key ?
		tst.l	(a0)
		beq	ExAllFitted		nope, we are finished

; common for DCFS and non-DCFS
reserve_space	move.l	dp_Arg4(a2),d0		calculate max memory needed
		move.l	d0,d1
		lsl.w	#2,d1			size = code * 4 + 4 + 32(name)
		addq.w	#4,d1
		move.w	d1,d5			need this later (name area)
; FIX! namemax!
		addi.w	#32,d1			assuming name always required
		cmpi.w	#ED_DATE,d0
		blt.s	10$
		addq.w	#8,d1			if >=5 add 8 bytes for date
		addq.w	#8,d5			and offset name address too
10$		cmpi.w	#ED_COMMENT,d0		if >=6 add 80 bytes for comment
		bcs.s	20$			branch on d0 < 6
		addi.w	#80,d1
20$		cmp.l	d1,d3			do we have room in the buffer
		blt	ExAllNoFit		nope, must exit now

; update number of entries, next pointer in last entry, init this entry
; (this is common to DCFS and non-DCFS, so do it first)
		movea.l	dp_Arg5(a2),a0		get control struct
		addq.l	#1,c_Entries(a0)	and bump entry count
		tst.l	d4			is there a previous entry ?
		beq.s	80$			nope
		movea.l	d4,a0			yes, update its next pointer
		move.l	d2,ed_Next(a0)		to point to this entry

80$		move.l	d4,d6			save prev (in case rejected)
		move.l	d2,d4			mark this entry as previous
		movea.l	d2,a0			and current as having no next
		clr.l	ed_Next(a0)		clear ed_Next pointer

; now comes the major dividing point between DCFS and non-DCFS.  We could
; perhaps find a way to share more of it in the future.
; d2&d4 have buffer address, d6 has previous buffer, d5 has offset to name
; d3 has space left in buffer, d7 has parent directory key
;	printf <'d2-d6 = $%lx $%lx $%lx $%lx $%lx'>,d2,d3,d4,d5,d6
		tst.b	ET_Type(a4)
		bne	exall_fill_DCFS

; this code fills in non-DCFS entries
		movea.l	ET_CurrentKey(a4),a0	get next key to read
		move.l	(a0)+,d0
		move.l	a0,ET_CurrentKey(a4)	and update current key pointer
		movea.l	dp_Arg5(a2),a1		update lastkey in control struct
		move.l	d0,c_LastKey(a1)
		bsr	WaitBlock		read this block
		movea.l	d0,a3			stash the buffer

		lea.l	cb_SIZEOF(a3),a0
		adda.l	BlockSize(a5),a0
; This is a fix to make sure we don't "jump" directories (see above).  Make
; sure any entry we grab has a parent of the directory we're examining.
		cmp.l	vfhb_Parent(a0),d7
		bne	ExAllNext		wrong directory!!!!!!!
		
; we've a valid header, see if it has an extension to be linked into the table
		move.l	vfhb_HashChain(a0),d0
		beq.s	70$			no extension, carry on

; we must insert an extension key into our list of keys to be examined.
		movea.l	ET_CurrentKey(a4),a0
		subq.l	#4,a0			back up pointer by 1
		move.l	a0,ET_CurrentKey(a4)
50$		move.l	4(a0),d1		is next key empty
		beq.s	60$			yep, current pos is our slot
		cmp.l	d1,d0			are we less than next key
		blt.s	60$			yep, current pos is our slot
		move.l	d1,(a0)+		move next key down
		bra.s	50$			and keep looking
60$		move.l	d0,(a0)			save the extra key

; we have a header pointed to by a3 and a buffer with enough room for the
; data required.  Get the relevant info from the header and store it into
; the callers buffer (using d2 as an address holder for this).  Calculate
; how much data space is used and update the buffer pointer accordingly.
;
; We must handle links here!  First copy type, key, name, comment, and date,
; then set numblocks, size, protection bits, and ownerid from the link.
70$		movea.l	d2,a0			get current entry ptr back

; we saved the offset to the name earlier (in d5) use this to calculate the
; name pointer and store it in the buffer (assume name is always required)
		movea.l	d2,a1			get current address
		adda.w	d5,a1			calculate name address
		move.l	a1,ed_Name(a0)		and store in buffer
		lea.l	cb_SIZEOF(a3),a0
		adda.l	BlockSize(a5),a0
		lea.l	vfhb_FileName(a0),a0
		moveq	#0,d0
		move.b	(a0)+,d0		get length of name
		bra.s	91$
90$		move.b	(a0)+,(a1)+		transfer name as a C string
91$		dbra	d0,90$
		clr.b	(a1)+			must NULL terminate
		move.l	a1,d0			pad to next longword boundary
		addq.l	#3,d0
		andi.w	#$fffc,d0
		movea.l	d0,a1
	
; a1 is now pointing to the tentative address of the comment (if it is there)
		move.l	dp_Arg4(a2),d0
		cmpi.w	#ED_COMMENT,d0		will we need comment
		bcs.s	100$			nope, do the rest
		movea.l	d2,a0			yes, set up the address
		clr.l	ed_Comment(a0)		assume no comment
		lea.l	cb_SIZEOF(a3),a0
		adda.l	BlockSize(a5),a0
		tst.b	vfhb_Comment(a0)
		beq.s	100$			correct, there was none

; Steve had a bug, and left ed_Comment a BSTR (ugh).  He documented it as
; a CSTR.  It's a really bad spot to be in...  We'll go with CSTR.
		move.l	a0,-(sp)
		movea.l	d2,a0
		move.l	a1,ed_Comment(a0)
		move.l	(sp)+,a0
		lea.l	vfhb_Comment(a0),a0
		moveq	#0,d0
		move.b	(a0)+,d0		get length of comment
		bra.s	96$
95$		move.b	(a0)+,(a1)+		copy as CSTR!!!!!
96$		dbra	d0,95$
		clr.b	(a1)+			terminate - a1 is live!
		move.w	a1,d0
		and.w	#1,d0
		add.w	d0,a1			round up to next word!

; a1 will now be pointing to the address of the next entry.  Update bytes left.
100$		move.l	a1,d2			this is the next entry
		move.l	d2,d0			calculate bytes used
		sub.l	d4,d0			d4 is now current (and prev)
		sub.l	d0,d3			d3 holds bytes left

; all the variable length stuff has been done so now do the fixed length things
		movea.l	d4,a0			d4 is holding buffer address
		move.l	dp_Arg4(a2),d0

		cmpi.w	#ED_TYPE,d0		do we need type ?
		blt	CheckMatch		nope, only name
		movem.l	d0/a0,-(sp)		yes, get the type
		movea.l	a3,a0
		bsr	Type
		move.l	d0,d1
		movem.l	(sp)+,d0/a0
		move.l	d1,ed_Type(a0)

; fetch the linked fHB if any...
		move.l	d2,-(sp)
		move.l	d0,d2			arg for GetLinkInfo
		moveq	#1,d1			dest is an ed_xxx
		move.l	a0,a1			dest is an ed_xxx
		moveq	#0,d0			src is buffer
		move.l	a3,a0			src is buffer
		bsr	GetLinkInfo		(a0,a1,d0,d1 - regs unchanged)
		move.l	(sp)+,d2

		bra	CheckMatch

; this is a dircache entry - fill exall entry from dircache
; FIX!!!! a lot of this could be shared with non-DCFS with some work!
exall_fill_DCFS:
		move.l	NET_Entry(a4),a3	get entry pointer back
	printf <'exall, key %ld, entry $%lx,buffer $%lx'>,fle_Key(a3),a3,d2
		movea.l	dp_Arg5(a2),a0		update lastkey in control struct
		move.l	fle_Key(a3),c_LastKey(a0)

; we have a dircache entry in a3 and a buffer with enough room for the
; data required.  Get the relevant info from the header and store it into
; the callers buffer (using d2 as an address holder for this).  Calculate
; how much data space is used and update the buffer pointer accordingly.
;
; We must handle links here!  First copy type, key, name, comment, and date,
; then set numblocks, size, protection bits, and ownerid from the link.
; This will require holding two blocks at once!!!!! DANGER!!  but we're
; going to require (and force) more than one buffer anyways, so it's safe.
; FIX (NOT!)
		movea.l	d2,a0			get current entry ptr back

; we saved the offset to the name earlier (in d5) use this to calculate the
; name pointer and store it in the buffer (assume name is always required)
		movea.l	d2,a1			get current address
		adda.w	d5,a1			calculate name address
		move.l	a1,ed_Name(a0)		and store in buffer
		lea.l	fle_FileName(a3),a0
		moveq	#0,d0
		move.b	(a0)+,d0		get length of name
		bra.s	91$
90$		move.b	(a0)+,(a1)+		transfer name as a C string
91$		dbra	d0,90$
		clr.b	(a1)+			must NULL terminate
		move.l	a1,d0			pad to next longword boundary
		addq.l	#3,d0
		andi.w	#$fffc,d0
		movea.l	d0,a1
	
; a1 is now pointing to the tentative address of the comment (if it is there)
; a0 points to the comment in the dircache entry (right after the filename)
		move.l	dp_Arg4(a2),d0
		cmpi.w	#ED_COMMENT,d0		will we need comment
		bcs.s	100$			nope, do the rest (d0<comment)
		move.l	a0,-(sp)		save addr of comment
		movea.l	d2,a0
		clr.l	ed_Comment(a0)		clear in case there's no
		move.l	(sp)+,a0		 comment
		tst.b	(a0)
		beq.s	100$			no comment

; Steve had a bug, and left ed_Comment a BSTR (ugh).  He documented it as
; a CSTR.  It's a really bad spot to be in...  We'll go with CSTR.
		move.l	a0,-(sp)		save addr of comment
		movea.l	d2,a0
		move.l	a1,ed_Comment(a0)
		move.l	(sp)+,a0		comment is right after name
		moveq	#0,d0
		move.b	(a0)+,d0		get length of comment
		bra.s	96$
95$		move.b	(a0)+,(a1)+		copy as CSTR!!!!!
96$		dbra	d0,95$
		clr.b	(a1)+			terminate - a1 is live!
		move.w	a1,d0
		and.w	#1,d0
		add.w	d0,a1			round up to next word!

; a1 will now be pointing to the address of the next entry.  Update bytes left.
100$		move.l	a1,d2			this is the next entry
		move.l	d2,d0			calculate bytes used
		sub.l	d4,d0			d4 is now current (and prev)
		sub.l	d0,d3			d3 holds bytes left

; all the variable length stuff has been done so now do the fixed length things
		movea.l	d4,a0			d4 is holding buffer address
		move.l	dp_Arg4(a2),d0

		cmpi.w	#ED_TYPE,d0		do we need type ?
		blt.s	CheckMatch		nope, only name
		move.b	fle_Type(a3),d1
		ext.w	d1
		ext.l	d1			type is a signed long!
		move.l	d1,ed_Type(a0)

; fetch the linked fHB if any...
		move.l	d2,-(sp)
		move.l	d0,d2			arg for GetLinkInfo
		moveq	#1,d1			dest is an ed_xxx
		move.l	a0,a1			dest is an ed_xxx
		moveq	#1,d0			src is an fle_xxx
		move.l	a3,a0			src is an fle_xxx
		bsr	GetLinkInfo		(a0,a1,d0,d1 - regs unchanged)
		move.l	(sp)+,d2

		; bra	CheckMatch  fall through

; We now have a completed entry in the callers buffer.  D4 is pointing to this
; entry, d6 to the previous and d2 to the next.  Before accepting this entry
; and going for the next one, see if we should do any pattern matching.
;
; Someone changed the interface.  If there is a matchstring then do the default
; pattern matching on it and then continue on to look for a matchfunc if the
; entry has been accepted (acts as a separate filter instead) !!!!!!!!!!!!!!!!!!
CheckMatch	movea.l	dp_Arg5(a2),a1		get control struct
		tst.l	c_MatchString(a1)	any match string
		beq.s	CheckFunction		nope, just look for a function

		movem.l	a2-a4,-(sp)
		lea.l	MyMatchFunc(pc),a3	default match routine
		movea.l	d4,a0			setup buffer data
		movea.l	c_MatchString(a1),a1	match string
		move.l	dp_Arg4(a2),d0		data value
;		move.l	a1,-(sp)		stack args too
;		move.l	a0,-(sp)
;		move.l	d0,-(sp)
		jsr	(a3)			call the function
;		adda.w	#12,sp			clean up the stack
		movem.l	(sp)+,a2-a4
		tst.l	d0			should we keep this entry ?
		bne.s	CheckFunction		yes, maybe a user function too

; the entry has been rejected so we're going to have to back up the pointers
Rejected	move.l	d2,d0
		sub.l	d4,d0			calculate space used
		add.l	d0,d3			and add back to available space
		move.l	d4,d2			make d2 current address
		move.l	d6,d4			and update previous address
		beq.s	10$			there was no previous entry
		movea.l	d4,a0
		clr.l	(a0)			has no next entry anymore
10$		movea.l	dp_Arg5(a2),a0
		subq.l	#1,c_Entries(a0)	one less entry
		bra.s	ExAllNext		go for the next one

; Maybe call a user supplied hook to do (further) pattern matching checks
CheckFunction	movea.l	dp_Arg5(a2),a0		get control struct
		move.l	c_MatchFunc(a0),d0	was there a match function ?
		beq.s	ExAllNext		nope, so all done
		movem.l	a2-a4,-(sp)		yes, must call it

		movea.l d0,a0                   the hook itself
		movea.l d4,a1                   point at buffer data
		lea     dp_Arg4(a2),a2          pointer to type ("data" longword)
		movea.l h_Entry(a0),a3          a0=hook, a1=exalldata ptr, 
		jsr     (a3)                     a2 = pointer to type ("data)

		movem.l	(sp)+,a2-a4
		tst.l	d0
		beq.s	Rejected		entry rejected

; Everything done for this entry.  Free the block and look for the next
ExAllNext	tst.b	ET_Type(a4)
		bne.s	10$
		; old type

;	printf <'dropping block $%lx (%ld)'>,a3,cb_Key(a3)
		move.l	d7,d0			associate with directory
		bsr	LooseA3Block		free current block
		bra	ExAllLoop		and look for the next block

		; DCFS
10$		bsr	NextDCEntry
		bra	ExAllLoop

; We ran out of space in the buffer so return TRUE to make caller call us again
ExAllNoFit	printf <'ExAll: not enough space'>
		bsr.s	FreeNETBlock
		clr.w	ErrorCode+2(a5)		nothing wrong
		moveq.l	#TRUE,d0		no problems
		movea.l	a2,a0
		bra	WorkDone		send packet back and die

; we have completed the scan of the directory, return FALSE and ERROR_NO_MORE
ExAllFitted	bsr.s	FreeNETBlock
		move.l	#ERROR_NO_MORE_ENTRIES,ErrorCode(a5)
		movea.l	a2,a0			fail this packet
		bra	WorkFail		won't come back, end of dir

MyMatchFunc	movem.l	d2/a6,-(sp)		save exec
		movea.l	DosLib(a5),a6		get DOS
		move.l	ed_Name(a0),d2		get the name
		move.l	a1,d1			args for MatchPattern(match,str)
		jsr	_LVOMatchPatternNoCase(a6)	get a match
		movem.l	(sp)+,d2/a6		restore exec
		rts

; Free NET block if held
FreeNETBlock:	tst.b	ET_Type(a4)
		beq.s	10$			not an NET
		move.l	NET_BlockPtr(a4),a0	the block buffer
		move.l	cb_SIZEOF+fhl_Parent(a0),d0	associate with itself
		tst.l	NET_BlockNum(a4)	block or 0
		beq.s	10$			NextDCEntry may have freed it!
;	printf <'2:loosing block %ld ($%lx)'>,d0,a0
		bsr	LooseBlock
		clr.l	NET_BlockNum(a4)	we no longer hold this block!
		; blockptr is invalid too, but we key off blocknum
10$		rts

		
		END
@


1.27
log
@pointer still needs to be bumped...
@
text
@d670 5
@


1.26
log
@Forgot to adjust the clr.b for the terminator for the new loop
@
text
@d1065 1
a1065 1
		clr.b	(a1)			must NULL terminate
d1094 1
a1094 1
		clr.b	(a1)			terminate - a1 is live!
d1161 1
a1161 1
		clr.b	(a1)			must NULL terminate
d1190 1
a1190 1
		clr.b	(a1)			terminate - a1 is live!
@


1.25
log
@Fixed handling of comments in exall
@
text
@d1065 1
a1065 1
		clr.b	-1(a1)			must NULL terminate
d1094 1
a1094 1
		clr.b	-1(a1)			terminate - a1 is live!
d1161 1
a1161 1
		clr.b	-1(a1)			must NULL terminate
d1190 1
a1190 1
		clr.b	-1(a1)			terminate - a1 is live!
@


1.24
log
@Don't do the manx patch for exall
@
text
@d1062 1
d1064 1
a1064 1
		dbra	d0,90$
d1091 3
a1093 2
91$		move.b	(a0)+,(a1)+		copy as CSTR!!!!!
		dbra	d0,91$
d1158 1
d1160 1
a1160 1
		dbra	d0,90$
d1187 3
a1189 2
91$		move.b	(a0)+,(a1)+		copy as CSTR!!!!!
		dbra	d0,91$
@


1.23
log
@Added code to handle people unlocking locks between exnexts on a DCFS partition
@
text
@d136 3
@


1.22
log
@added support for hardlinks in exall, and for dcfs in exall and exnext.
Factored the support into one routine called by all cases (GetLinkInfo).
This makes it easy to maintain.  Also made sure the date is taken from the
linked-to object for consistency.
@
text
@d54 2
a55 2
; entry = GetDCEntry( NET, lastkey)
;   a0                a4      d4
d101 3
a103 1
; is in, and no directory can be in it's own dirlist.
d132 16
a147 1
	printf <'didnt find previous entry! return first entry!\n'>
d149 6
d157 2
d611 1
a611 1
		beq	OldFastMethod		no
d615 1
a615 1
		bsr	GetDCEntry
d957 1
a957 1
		bsr	GetDCEntry
d1199 1
a1199 1
		blt	CheckMatch		nope, only name
@


1.21
log
@Fixed ExAll not clearing NET_BlockNum on free of block
Many .s opts
removed unneeded load of d6 in GetDCEntry
Make sure we associate dircache blocks with their directories
@
text
@d16 1
a16 1
		XREF	Type,LooseBlock,WorkFail,WorkDone
d400 129
a604 15
		move.l	fle_Size(a0),d0
		move.l	d0,fib_Size(a1)
		move.w	BlockShift(a5),d1	make numblocks
		lsr.l	d1,d0			we ignore extensions
		addq.l	#1,d0			for fileheader
		move.l	d0,fib_NumBlocks(a1)	approximate
		move.l	fle_Protection(a0),fib_Protection(a1)
		move.l	fle_OwnerXID(a0),fib_OwnerUID(a1)	sets both!!
		moveq	#0,d0
		move.w	fle_Days(a0),d0		date is stored as words!
		move.l	d0,fib_DateStamp(a1)	(gives us 179 years)
		move.w	fle_Min(a0),d0
		move.l	d0,fib_DateStamp+4(a1)
		move.w	fle_Tick(a0),d0
		move.l	d0,fib_DateStamp+8(a1)
d606 1
a606 1
		; we lose entry ptr here...
a607 1
		move.l	a1,-(sp)		save for comment
d614 1
a614 1
		move.l	(sp)+,a1
d620 1
d622 5
d770 1
a770 2
DoDate		movem.l	vfhb_Days(a0),d0-d2
		movem.l	d0-d2,fib_DateStamp(a4)	fill in the date
d774 5
a778 60
		clr.l	fib_NumBlocks(a4)	assume it's a directory
		clr.l	fib_Size(a4)
		move.l	fib_EntryType(a4),d0
		cmpi.w	#ST_FLINK,d0		is it a file link ?
		beq.s	5$			yep
		cmpi.w	#ST_DLINK,d0		was it a directory link ?
		bne.s	10$			nope, normal dir or file

; It's a link!  Loose this header and get the one associated with it instead
5$		move.l	vfhb_Link(a0),-(sp)	save the key
		move.l	cb_Key(a3),d0		associate with self
		bsr	LooseA3Block
		move.l	(sp)+,d0		and get the new block
		bsr	WaitBlock
		movea.l	d0,a3
		movea.l	d0,a0
		bsr	Type			re-arm the type check

; this check will have a real file or directory to work with now
10$		cmpi.w	#st.file,d0		check it's a file
		bne.s	20$			nope, it was a directory

; calculate how many blocks this file uses including link table extensions.
		lea.l	cb_SIZEOF(a3),a0
		adda.l	BlockSize(a5),a0
		move.l	vfhb_ByteSize(a0),d0
		move.l	d0,fib_Size(a4)		save size
		btst.b	#0,DiskType+3(a5)	is this DOS/0 or DOS/2 or DOS/4
		bne.s	17$			nope

		divu.w	BytesPerData+2(a5),d0	different calc for DOS\0
		move.l	d0,d1
		ext.l	d0
		swap	d1
		tst.w	d1
		beq.s	18$
		addq.l	#1,d0			allow for partial blocks
		bra.s	19$			but NOT for link tables

; The old filing system doesn't include link tables in the blocks used count
17$		move.w	BlockShift(a5),d1
		lsr.l	d1,d0			convert to num blocks
		move.l	BlockSize(a5),d1	allow for a partial block too
		subq.l	#1,d1
		and.l	fib_Size(a4),d1
		beq.s	18$			no partial block used
		addq.l	#1,d0

18$		move.l	d0,d1			get number of ext blocks
		divu.w	HTSize+2(a5),d1		hash table size
		ext.l	d1
		add.l	d1,d0			add to total blocks

19$		move.l	d0,fib_NumBlocks(a4)	stash blocks used by file

; I've moved this here so links inherit the files protection bits
20$		lea.l	cb_SIZEOF(a3),a0
		adda.l	BlockSize(a5),a0
		move.l	vfhb_Protect(a0),fib_Protection(a4)
		move.l	vfhb_OwnerXID(a0),fib_OwnerUID(a4)
d1019 3
d1088 9
a1096 15
		lea.l	cb_SIZEOF(a3),a1
		adda.l	BlockSize(a5),a1
		cmpi.w	#ED_SIZE,d0		do we need size
		blt	CheckMatch		nope
		move.l	vfhb_ByteSize(a1),ed_Size(a0)

		cmpi.w	#ED_PROTECTION,d0	do we need protection bits ?
		blt	CheckMatch		nope
		move.l	vfhb_Protect(a1),ed_Prot(a0)

		cmpi.w	#ED_DATE,d0		do we need date ?
		blt	CheckMatch		nope
		move.l	vfhb_Days(a1),ed_Days(a0)
		move.l	vfhb_Mins(a1),ed_Mins(a0)
		move.l	vfhb_Ticks(a1),ed_Ticks(a0)
a1097 3
		cmpi.w	#ED_OWNER,d0		do we need owner info ?
		blt	CheckMatch		nope
		move.l	vfhb_OwnerXID(a1),ed_OwnerUID(a0)
d1112 6
d1174 1
a1174 1
		blt.s	CheckMatch		nope, only name
d1180 9
a1188 3
		cmpi.w	#ED_SIZE,d0		do we need size
		blt.s	CheckMatch		nope
		move.l	fle_Size(a3),ed_Size(a0)
a1189 17
		cmpi.w	#ED_PROTECTION,d0	do we need protection bits ?
		blt.s	CheckMatch		nope
		move.l	fle_Protection(a3),ed_Prot(a0)

		cmpi.w	#ED_DATE,d0		do we need date ?
		blt.s	CheckMatch		nope
		moveq	#0,d1
		move.w	fle_Days(a3),d1		stored as words!
		move.l	d1,ed_Days(a0)
		move.w	fle_Min(a3),d1
		move.l	d1,ed_Mins(a0)
		move.w	fle_Tick(a3),d1
		move.l	d1,ed_Ticks(a0)

		cmpi.w	#ED_OWNER,d0		do we need owner info ?
		blt.s	CheckMatch		nope
		move.l	fle_OwnerXID(a3),ed_OwnerUID(a0)
a1190 1

@


1.20
log
@Added Dircache support to ExAll
Factored out routines for getting the next dircache entry
Fixed ExAll to check if an object has been deleted and the fhb reused
Fixed an ExNext/ExAll dircache bug where it could use the wrong type
of ExamineThing if a disk went from Valid to Invalid and an ET was still
attached to a lock (it should really free the ET on NO_MORE_ENTRIES).
Added support for OwnerID to ExNext/ExAll
@
text
@d16 1
a16 1
		XREF	Type,LooseBlock,DiscardBlock,WorkFail,WorkDone
d54 2
a55 2
; GetDCEntry( NET, lastkey)
;             a4      d4
d73 2
a74 1
	printf <'exnext via dirlist, block %ld, key %ld\n'>,NET_NextBlockNum(a4),NET_NextKey(a4)
a79 2
		move.w	NET_NumEntries(a4),d6

d85 1
d104 1
a104 1
	printf <'got dirlist, entries=%ld\n'>,d6
d108 1
a108 1
		bmi	GetNextListBlock	none - must have been deleted!
d144 1
a144 1
		move.w	d6,NET_NumEntries(a4)
d160 2
a161 1
		move.l	d2,d0			current list block
d165 1
d183 1
a183 1
		bra.s	FoundNextEntry		so the vars get updated
d199 1
d206 3
a208 1
NextDCSetKey	move.l	fle_Key(a0),NET_NextKey(a4)	next entry to return
d213 2
a214 1
NextListNeeded	move.l	d2,d0			current list block
d224 1
a224 1
;	printf <'Fetched next list block %ld'>,d2
d228 3
d298 1
d527 1
a527 1
		beq	SetInfo			none, we are at the end
d666 1
a666 1
		; FIX??? no block to associate with!
d718 1
a718 1
		; FIX??? which block to associate with?
d868 1
d1199 3
a1201 1
					; FIX??? Associate with which header?
d1210 2
a1211 1
ExAllNoFit	bsr.s	FreeNETBlock
d1235 2
a1236 1
		move.l	NET_BlockNum(a4),d0	associate with itself
d1238 1
d1240 2
@


1.19
log
@Added vast amounts of code to handle dircaches.  Still need to do ExAll!
@
text
@d5 2
a6 1
		INCLUDE	"libraries/dosextens.i"
d17 2
a18 2
		XREF	CheckLock,WaitBlock,GetPubMem,Hash,IsDir
		XREF	_LVOMatchPatternNoCase,NextListEntry
d52 1
d54 2
a55 2
; ExNext( packet )
;	    d0
d57 4
a60 5
; Examines the next entry in a directory.  If the previous call was to Examine
; then fl_SIZEOF will be 0 (no ExamineThing) and fib_DiskKey will be the same
; as the key returned by CheckLock.  This means we will have to set up an
; ExamineThing on this lock and fill it with the keys referenced by this dir.
; These keys are sorted by block order, lowest to highest.
d62 175
a236 31
; If the previous call was to ExNext then two things can happen.  In the
; normal case, fl_SIZEOF will contain a pointer to an initialised ExamineThing
; and we'll use the state information in there to find where the next file is.
; In the horrible case, the caller could have UnLocked the directory between
; ExNext calls which will have lost all the state information that was held
; in the ExamineThing.  If this is the case, then the ExamineThing is rebuilt
; and all the headers are scanned until we run out or we find the first one
; larger than the current fib_DiskKey.  This is a kluge to support Lattice
; and Manx DNext calls that UnLock the directory between ExNext calls.
;
; New for dos\4: since we have compressed directory blocks, we may also have
; a DirList block number and entry number within it.  This will only happen
; for dos\4 filesystems, and only when the disk has validated successfully
; (after that, they'll be maintained correctly).  We'll also use the fib key
; value to try to reconnect with the right spot if needed, either because of
; the lattice/manx DNext junk, or if the directory changed since we last
; looked at it.  If it did, we'll try to locate the key we wanted in the
; current block.  Deletions can cause it to move down in the current block,
; but not up (currently), and currently it can't move to another block.  If
; the entry is not there at all, we look for the previous entry (fib_DiskKey).
; If we find that, we return the next entry.  If we don't find it, we return
; the first entry of the block (since both must have been deleted - nasty).
; In various cases were one or both were deleted, we may have to fetch more
; dirlist blocks until we find an entry to return.
;
; NET_Block = 0 means there are no more entries to return.
;
; The only problem comes from SetComment.  This causes deletion and 
; re-insertion of a block.  we'll live with it showing up twice.  Oh well.
;
; Careful: these need to be coordinated with the insertion/deletion logic!
d238 3
a240 3
ExNext		movea.l	d0,a2			save the packet
	printf <'ExNext called\n'>
ExContinue	movea.l	dp_Arg1(a2),a0		check the lock
d244 1
a244 1
ExNextFail	movea.l	a2,a0			return bad lock error
d246 1
a246 7
		bra	WorkFail

CheckForET	movea.l	dp_Arg2(a2),a0		first, stash fib_LastKey
		adda.l	a0,a0			to make the kluge check quicker
		adda.l	a0,a0
		move.l	fib_DiskKey(a0),d4
	printf <'Parent=%ld DiskKey=%ld\n'>,d3,d4
d248 1
a248 1
; This is the rest of the normal ExNext routine as used by the FFS format.
a249 3
FFSExNext	suba.l	a3,a3			a3=0 means no buffer here
		moveq.l	#0,d2			therefore no relevant key

d253 4
a256 3
		movea.l	fl_SIZEOF(a0),a4
		cmpa.w	#0,a4
		beq.s	GetET			none there, make one
d262 4
d267 1
a267 1
		beq.s	4$			yes, unlocked between calls
d269 3
a271 3
		bne	FastMethod		no, so carry on normally
4$:
	printf <'First ExNext\n'>
d277 1
a277 1
		beq.s	old_et			use old if bitmap invalid
d279 10
d290 3
a292 2
		clr.l	NET_Block(a4)
		bra	InitET
d305 1
a305 1
GetET	printf <'Constructing ExamineThing\n'>
d322 1
a322 1
20$		bsr	GetPubMem
d326 1
a326 1
		bra	ExNextFail		error out
d332 1
a332 3
		movea.l	dp_Arg1(a2),a0		in the lock structure too
		adda.l	a0,a0
		adda.l	a0,a0
d350 1
a350 1
		tst.l	ET_Type(a4)		which type of examinething?
d355 1
a355 1
		move.l	cb_SIZEOF+vudb_DirList(a3,d0.l),NET_Block(a4)
d380 62
a441 4
DropDir		movea.l	a3,a0			which block to drop
		move.l	d3,d0			associate with this block (itself)
		bsr	LooseBlock		frees parent block
		suba.l	a3,a3			no block being held onto
d449 5
a453 55
; new fast method.  Fetch dirlist block, and find the right entry.  The info
; in the dirlist is always the next entry you want to fetch.  If need be, the
; old entry value is in d4 (from fib_DiskKey).
	printf <'exnext via dirlist, block %ld, key %ld\n'>,NET_Block(a4),NET_NextKey(a4)
		move.l	NET_Block(a4),d0
		move.l	d0,d2			save for looseblock
		beq	NoMore			if 0, last one returned was end
		bsr	WaitBlock
		move.l	d0,a3			keep buffer

; If numentries is 0, then the file must have been deleted (and no other
; entries were in the block).  Grab the next entry in any following list block.
; If we merely don't find it, search for the previous entry in the current
; listblock.  If we don't find THAT, just take the first one here and hope.
; If we do find it, take the next one, of course.

; Note: if NET_NextKey is 0 (initial exnext call), then we'll fail to find
; it anywhere, and will fail to find the previous one.  We should return the
; first entry in the current block (or first block with an entry).  (It fails
; to find the previous one (d4) since the previous one is the directory this
; is in, and no directory can be in it's own dirlist.

		move.l	cb_SIZEOF+fhl_NumEntries(a3),d6
	printf <'got dirlist, entries=%ld\n'>,d6

		subq.w	#1,d6
		move.w	d6,d5			save original number of entries
		bmi	GetNextListBlock	none - must have been deleted!
		lea.l	cb_SIZEOF+fhl_Entries(a3),a0
		move.l	a0,a1			save original entries ptr
		bra.s	20$
10$		bsr	NextListEntry		updates a0,d6.w
20$		move.l	fle_Key(a0),d1
		cmp.l	NET_NextKey(a4),d1	see if it's the right entry
		beq.s	FoundNextEntry		got it!
		tst.w	d6			run out of entries yet?
		bne.s	10$

	printf <'didnt find the entry!  must have been deleted!\n'>
		; didn't find our entry in this list block (must have been
		; deleted or maybe commented).  Search for previous entry.
		move.w	d5,d6
		move.l	a1,a0			get entries ptr back
		bra.s	40$
30$		bsr	NextListEntry		updates a0,d6
40$		cmp.l	fle_Key(a0),d4		see if it's the previous entry
		beq	ReturnNextEntry		got it!
		tst.w	d6			run out of entries yet?
		bne.s	30$
	printf <'didnt find previous entry! return first entry!\n'>

		; didn't find either previous or next.  Return first entry
		; in current block.
		move.l	a1,a0			get entries ptr back
		move.w	d5,d6			indicate we didn't skip any
d455 1
a455 3
; fill in info and get set for next ExNext.  a0 points to entry, d6.w is number
; of entries left in this block, NOT including this one.
FoundNextEntry	move.l	a0,-(sp)		save pointer to find next
d459 1
a459 1
	printf <'FoundNextEntry (%ld, block %ld, left %ld to $%lx)\n'>,fle_Key(a0),d2,d6,a1
d473 1
d482 1
d498 2
a499 8
		; done filling in entry.  Find next and set ET
		move.l	(sp)+,a0		get back entry ptr
		tst.w	d6			any more entries?
		beq.s	NextListNeeded
		bsr	NextListEntry		(a0,d6.w)
		; NET_Block is still correct

ExListSet	move.l	fle_Key(a0),NET_NextKey(a4)	next entry to return
d501 1
d503 1
a503 3
		move.l	a3,a0			the block buffer
		move.l	d2,d0			associate with itself
		bsr	LooseBlock
d505 1
a505 1
ExListDone	clr.w	ErrorCode+2(a5)		no error
a510 52
; we succeeded, but we need to fetch the next list block to find the next
; entry for the ET.
NextListNeeded	move.l	d2,d0			current list block
		move.l	cb_SIZEOF+fhl_NextBlock(a3),d2  new list block
		move.l	a3,a0			buffer to free
		bsr	LooseBlock

		; get the next list block, if any
		clr.l	NET_Block(a4)		default, return NO_MORE next
		move.l	d2,d0
		beq.s	ExListDone		no more lists, return success
		bsr	WaitBlock		fetch next list block
		move.l	d0,a3
	printf <'Fetched next list block'>
		tst.l	cb_SIZEOF+fhl_NumEntries(a3)
		beq.s	NextListNeeded		none in this, fetch _next_ one

		move.l	d2,NET_Block(a4)	we have an entry, set up ET
		lea	cb_SIZEOF+fhl_Entries(a3),a0
		bra.s	ExListSet		got it, set next info and return

; we come here when we found the previous entry returned.  Skip it and
; return the next entry.  a0 is last entry returned, d6 is entries left
; NOT including this one
ReturnNextEntry printf <'ReturnNextEntry'>
		tst.w	d6			any more entries?
		beq.s	GetNextListBlock	no, get next block
		bsr	NextListEntry		finds the one we want
		bra	FoundNextEntry		and return it

; we come here when we want to return the first entry of the next list
; block (with entries).
GetNextListBlock: printf <'GetNextListBlock'>
		move.l	d2,d0			current list block
		move.l	cb_SIZEOF+fhl_NextBlock(a3),d2  new list block
		move.l	a3,a0			buffer to free
		bsr	LooseBlock

		; get next list block
		move.l	d2,d0
		beq	NoMore			if no more blocks, we're done
		bsr	WaitBlock
		move.l	d0,a3
		tst.l	cb_SIZEOF+fhl_NumEntries(a3)
		beq.s	GetNextListBlock	none in this, fetch _next_ one

		; finally found a block with entries.  Return first.
		move.l	cb_SIZEOF+fhl_NumEntries(a3),d6
		subq.w	#1,d6				don't include this one
		lea	cb_SIZEOF+fhl_Entries(a3),a0	entry to return
		move.l	d2,NET_Block(a4)	we have an entry, set up ET
		bra	FoundNextEntry
d533 1
a533 1
30$		movea.l	a3,a0			no good, scrap this block
d535 1
a535 1
		bsr	LooseBlock		(could have been deleted)
d656 2
a657 2
		movea.l	a3,a0			FIX??? no block to associate with!
		bsr	LooseBlock
d705 1
d708 2
a709 2
		movea.l	a3,a0			FIX??? which block to associate with?
		bsr	LooseBlock		block back on valid queue
d738 1
d808 3
d816 1
a816 1
		bne	ExAllContinue		nope, continuing scan
d821 5
a825 80
		movea.l	dp_Arg1(a2),a0		check the lock (BPTR)
		bsr	CheckLock		will set key=0 if invalid
		tst.l	d0
		bne.s	ExAllObjOK
		movea.l	a2,a0
		bra	WorkFail		lock was bad

ExAllObjOK	bsr	WaitBlock		get the required key
		movea.l	d0,a3			stash the buffer
		movea.l	d0,a0			check it is a directory
		bsr	IsDir			preserves a0!
		tst.l	d0
		bne.s	ExAllIsDir		no problems
						; not a directory ...
						; FIX?? what to associate with! (0)
		bsr	LooseBlock		free up the buffer (a0)
		movea.l	a2,a0
		bra	WorkFail		exit with an error

; We have been given a valid directory to scan.  Before we go any further,
; see if we have a valid ExamineThing in the Lock and either create it or
; initialise it ready for the scanning loop.  a3 holds directory buffer.
ExAllIsDir	movea.l	dp_Arg1(a2),a0		check for the ExamineThing
		adda.l	a0,a0
		adda.l	a0,a0
		movea.l	fl_SIZEOF(a0),a4
		cmpa.w	#0,a4
		beq.s	ExAllGetET		none there, make one

; we need to clear out any keys hanging around in the ExamineThing because
; they would screw up the sort code if we left them there.
		lea.l	ET_Entries(a4),a0
		move.l	HTSize(a5),d0		clear htsize+1 entries
10$		clr.l	(a0)+
		dbra	d0,10$
		bra.s	ExAllInitET		and initialise it now

; there wasn't an examinething attached to the lock so we must make one now
ExAllGetET	move.l	HTSize(a5),d0		get number of hashtable entries
		lsl.l	#2,d0			convert to byte size
		add.l	#4+ET_SIZEOF,d0		+ ending entry and currentkey
		bsr	GetPubMem
		tst.l	d0
		bne.s	ExAllGotET		and initialise the key list
		move.l	#ERROR_NO_FREE_STORE,ErrorCode(a5)
		movea.l	a3,a0			free the directory buffer
					; FIX??? Associate with which header? (0)
		bsr	LooseBlock
		movea.l	a2,a0
		bra	WorkFail		exit the routine

; we have an ExamineThing now but we must initialise and sort the key list
ExAllGotET	movea.l	d0,a4			stash ExamineThing pointer
		movea.l	dp_Arg1(a2),a0		in the lock structure too
		adda.l	a0,a0
		adda.l	a0,a0
		move.l	a4,fl_SIZEOF(a0)	** gotta update includes **

ExAllInitET	lea.l	cb_SIZEOF+udb_HashTable(a3),a0
		move.l	HTSize(a5),d3		number of entries to search
		subq.l	#1,d3
ExAllFillLoop	move.l	(a0)+,d0		get next key
		beq.s	30$			nothing there
		lea.l	ET_Entries(a4),a1	put entries lowest to highest
10$		move.l	(a1)+,d1		get next entry in table
		beq.s	20$			-4(a1) is where it lives
		cmp.l	d1,d0
		bgt.s	10$
		move.l	d0,-4(a1)		found slot for this one
		move.l	d1,d0
		bra.s	10$
20$		move.l	d0,-4(a1)		fill in last entry
30$		dbra	d3,ExAllFillLoop	keep going

		lea.l	ET_Entries(a4),a1	fill in current key
		move.l	a1,ET_CurrentKey(a4)
		movea.l	a3,a0			free up the parent key
					; FIX??? Associate with which header?
		bsr	LooseBlock
		suba.l	a3,a3			no block being held onto
d834 1
d836 1
d841 6
d849 17
a865 1
ExAllLoop	movea.l	ET_CurrentKey(a4),a0	is there another key ?
d869 2
a870 1
		move.l	dp_Arg4(a2),d0		calculate max memory needed
d875 1
d877 1
a877 1
		cmpi.w	#5,d0
d881 2
a882 2
10$		cmpi.w	#6,d0			if 6 add 80 bytes for comment
		bne.s	20$
d887 23
a917 1
; we've a valid header, see if it has an extension to be linked into the table
d920 6
d945 1
a945 11
70$		movea.l	dp_Arg5(a2),a0		get control struct
		addq.l	#1,c_Entries(a0)	and bump entry count
		tst.l	d4			is there a previous entry ?
		beq.s	80$			nope
		movea.l	d4,a0			yes, update its next pointer
		move.l	d2,(a0)			to point to this entry

80$		move.l	d4,d6			save prev (in case rejected)
		move.l	d2,d4			mark this entry as previous
		movea.l	d2,a0			and current as having no next
		clr.l	(a0)
d951 1
a951 1
		move.l	a1,ead_Name(a0)		and store in buffer
d955 1
a955 1
		clr.w	d0
d967 2
a968 2
		cmpi.w	#6,d0			will we need comment
		bne.s	100$			nope, do the rest
d970 1
a970 1
		clr.l	ead_Comment(a0)		assume no comment
d976 2
d980 1
a980 1
		move.l	a1,ead_Comment(a0)
d983 3
a985 4
		move.b	(a0),d0			get length of comment
		ext.w	d0
		lsr.w	#2,d0			convert to lword length
91$		move.l	(a0)+,(a1)+
d987 4
d1002 2
a1003 2
		cmpi.w	#2,d0			do we need type ?
		blt.s	CheckMatch		nope, only name
d1009 1
a1009 1
		move.l	d1,ead_Type(a0)
d1013 98
a1110 1
		cmpi.w	#3,d0			do we need size
d1112 1
a1112 1
		move.l	vfhb_ByteSize(a1),ead_Size(a0)
d1114 1
a1114 1
		cmpi.w	#4,d0			do we need protection bits ?
d1116 7
a1122 1
		move.l	vfhb_Protect(a1),ead_Prot(a0)
d1124 1
a1124 1
		cmpi.w	#5,d0			do we need date ?
d1126 2
a1127 3
		move.l	vfhb_Days(a1),ead_Days(a0)
		move.l	vfhb_Mins(a1),ead_Mins(a0)
		move.l	vfhb_Ticks(a1),ead_Ticks(a0)
d1129 1
a1173 7
; original broken code
;		movea.l	d0,a3
;		movea.l	d4,a2			point at buffer data
;		movea.l	h_Entry(a3),a3
;		jsr	(a3)

; Randalls fixed version
d1185 3
a1187 1
ExAllNext	movea.l	a3,a0
d1189 1
a1189 1
		bsr	LooseBlock		free current block
d1192 3
d1197 2
a1198 1
ExAllNoFit	clr.w	ErrorCode+2(a5)		nothing wrong
d1204 2
a1205 1
ExAllFitted	move.l	#ERROR_NO_MORE_ENTRIES,ErrorCode(a5)
d1211 1
a1211 1
		move.l	ead_Name(a0),d2		get the name
d1217 10
@


1.18
log
@fixed hooks interface to match pattern callback in exall
@
text
@d17 1
a17 1
		XREF	_LVOMatchPatternNoCase
d70 22
d131 6
d138 4
d144 1
a144 1
		lea.l	ET_Entries(a4),a0
d151 2
d154 11
a164 1
		move.l	HTSize(a5),d0		get number of hashtable entries
d166 5
a170 2
		addq.l	#4+ET_SIZEOF,d0		+ ending entry and currentkey
		bsr	GetPubMem
d177 1
d179 1
d192 3
d196 1
a196 1
		bsr	IsDir
d198 10
a207 1
		beq.s	NotADir			it was not a directory
d209 2
a210 1
		lea.l	cb_SIZEOF+udb_HashTable(a3),a0
d226 2
a227 1
NotADir		lea.l	ET_Entries(a4),a1	fill in current key
d229 4
a232 2
		movea.l	a3,a0			free up the parent key
		bsr	LooseBlock
a233 1
		move.l	(sp)+,d3		get back parent key
d237 180
a416 1
FastMethod	movea.l	ET_CurrentKey(a4),a0	get next key to read
d418 1
a418 2
		beq.s	SetInfo			none, we are at the end
	printf <'Next ExamineKey=%ld\n'>,d2
d435 1
d438 1
a438 1
		bra.s	FastMethod		and try again
d500 2
a501 2
		bne.s	10$			yes, it's OK
		move.w	#ERROR_NO_MORE_ENTRIES,ErrorCode+2(a5)
d504 1
a504 1
10$		bsr.s	DoInfo			do stuff for the packet
d557 1
a557 1
		movea.l	a3,a0
d574 1
a574 1
		btst.b	#0,DiskType+3(a5)	is this DOS/0 or DOS/2
d608 1
a608 1
		movea.l	a3,a0
d727 1
a727 1
		bsr	IsDir
d730 3
a732 2
		movea.l	a3,a0			not a directory ...
		bsr	LooseBlock		free up the buffer
d757 1
a757 1
		addq.l	#4+ET_SIZEOF,d0		+ ending entry and currentkey
d763 1
d794 1
d1012 1
@


1.17
log
@fixed eac_matchxxx to conform with standard imposed by DOS.  Now uses hook
interface for MatchFunc and ALWAYS uses default routines for MatchString.
@
text
@d746 14
a759 4
		movea.l	d0,a3
		movea.l	d4,a2			point at buffer data
		movea.l	h_Entry(a3),a3
		jsr	(a3)
@


1.16
log
@support for DOS/2 and DOS/3 format disks (international char sets for hashing)
@
text
@d6 1
d706 4
d712 1
a712 1
		beq.s	ExAllNext		nope, just go for the next
d716 1
a716 4
		move.l	c_MatchFunc(a1),d0	call a match function ?
		beq.s	NoFunc			nope
		movea.l	d0,a3			yes, call this instead
NoFunc		movea.l	d4,a0			setup buffer data
d719 3
a721 3
		move.l	a1,-(sp)		stack args too
		move.l	a0,-(sp)
		move.l	d0,-(sp)
d723 1
a723 1
		adda.w	#12,sp			clean up the stack
d726 1
a726 1
		bne.s	ExAllNext		yes
d729 1
a729 1
		move.l	d2,d0
d739 14
@


1.15
log
@uses MatchPatternNoCase instead of MatchPattern in ExAll
@
text
@d330 1
a330 1
		tst.b	DiskType+3(a5)		is this DOS/0
@


1.14
log
@fixed ExNext to check that the Examined header is a directory.  Prevents
a bunch of checksum errors when exnext attempts to read data blocks as
file header blocks.

@
text
@d16 1
a16 1
		XREF	_LVOMatchPattern
d759 1
a759 1
		jsr	_LVOMatchPattern(a6)	get a match
@


1.13
log
@fixed enforcer hit when eac_Matchstring item is rejected
@
text
@d105 1
a105 1
		bne.s	FastMethod		no, so carry on normally
d140 7
d163 1
a163 1
		lea.l	ET_Entries(a4),a1	fill in current key
@


1.12
log
@ead_Name string was overwritten by date if it was enabled
@
text
@d725 1
d728 1
a728 1
		movea.l	dp_Arg5(a2),a0
@


1.11
log
@null terminate file names in exall code
@
text
@d571 1
@


1.10
log
@fixed matchstring processing for exall
@
text
@d71 1
d77 1
d84 1
d102 2
d106 2
a108 1
	printf <'First ExNext\n'>
d118 2
a119 1
GetET		move.l	HTSize(a5),d0		get number of hashtable entries
d631 1
d746 1
a746 1
MyMatchFunc	move.l	a6,-(sp)		save exec
d748 2
a749 2
		movea.l	ead_Name(a0),a0		get the name
		exg	a0,a1			args for MatchPattern(match,str)
d751 1
a751 1
		movea.l	(sp)+,a6		restore exec
@


1.9
log
@fixes for manx/lattice scandir stuff
@
text
@d16 1
d29 2
d37 4
a40 1
ExObjOK		movea.l	dp_Arg1(a2),a0		mark lock as examined
d46 1
a46 1
		bsr	WaitBlock		get the required key
a82 63
; Since the old filing system never sorted its hash chains I am forced to use
; the old broken method of scanning headers.  I refuse to compromise FFS
; performance so I've broken this out as a completely different ExNext routine
;		tst.b	DiskType+3(a5)		FFS or oldFS ?
;		bne	FFSExNext		it's FFS, go fast

*** *** *** we're ExNexting an old FS disk, so do it the old way *** *** ***
;		suba.l	a3,a3			no buffer yet
;		moveq.l	#0,d2			so no relevant key
;		cmp.l	d3,d4			is this the first ExNext ?
;		bne.s	10$			nope, get old key
;		move.l	d3,d0			yes, get directory header
;		bsr	WaitBlock
;		movea.l	d0,a3			save buffer pointer
;		moveq.l	#0,d0			start at hash table 0
;		bra.s	20$			and go find the next key

; this is not the first ExNext call, see if the last file has an extension
;10$		move.l	d4,d0
;		bsr	WaitBlock		fetch file header
;		movea.l	d0,a3
;		lea.l	cb_SIZEOF(a3),a0
;		adda.l	BlockSize(a5),a0	point at end of block
;		cmp.l	vfhb_Parent(a0),d3	is file in this dir ?
;		beq.s	12$			yep, no problems
;11$		movea.l	a3,a0
;		bsr	LooseBlock
;		suba.l	a3,a3
;		bra	SetInfo			bad file, quit now
;12$		move.l	vfhb_HashChain(a0),d0	fetch next on hashchain
;		bne.s	30$			another on hash chain, get it

; there was no other file on the hash chain so find next in the hash table
;15$		lea.l	vfhb_FileName(a0),a0
;		bsr	Hash			get hash offset
;		subi.w	#udb_HashTable,d0	convert to offset into table
;		addq.l	#4,d0			and bump to next entry
;		move.l	d0,-(sp)		save this value
;		movea.l	a3,a0
;		bsr	LooseBlock		free up old header
;		move.l	d3,d0
;		bsr	WaitBlock
;		movea.l	d0,a3			fetch directory header
;		move.l	(sp)+,d0		get back hash offset

;20$		lea.l	cb_SIZEOF+fhb_HashTable(a3,d0.w),a0
;21$		move.l	HTSize(a5),d1
;		lsl.l	#2,d1			
;		cmp.l	d1,d0
;		beq.s	11$			at end of hashtable
;		addq.l	#4,d0			bump index counter
;		move.l	(a0)+,d1		get next entry
;		beq.s	21$			nothing there, try next
;		move.l	d1,d0			found next entry

;30$		move.l	d0,d2			save new header key
;		movea.l	a3,a0
;		bsr	LooseBlock		free previous header
;		move.l	d2,d0
;		bsr	WaitBlock		and fetch the next one
;		movea.l	d0,a3
;		bra	SetInfo			header to examine in a3

d102 1
d161 1
d211 4
a214 1
70$		movea.l	dp_Arg1(a2),a0		in the lock structure too
d219 1
d256 2
a257 1
DoInfo		movea.l	dp_Arg2(a2),a4		get fib pointer
d738 6
a743 2
******* just a stub routine until I get the DOS pattern match routines *******
MyMatchFunc	moveq.l	#TRUE,d0		match all files
@


1.8
log
@variable block sized support.  fixed a couple of exall bugs
@
text
@d34 7
a40 1
ExObjOK		bsr	WaitBlock		get the required key
a64 1

d81 1
a81 1
;		bne.s	FFSExNext		it's FFS, go fast
d98 3
a100 1
;		cmp.l	cb_SIZEOF+fhb_Parent(a3),d3	is file in this dir ?
d106 1
a106 1
;12$		move.l	cb_SIZEOF+fhb_HashChain(a3),d0
d110 1
a110 1
;15$		lea.l	cb_SIZEOF+fhb_FileName(a3),a0
d123 4
a126 2
;21$		cmpi.l	#72*4,d0
;		beq.s	11$			at end, no more entries
d162 1
a162 1
		moveq.l	#72,d0			clearing 73 entries
d168 3
a170 1
GetET		move.l	#ET_SIZEOF,d0		get the structure
d190 2
a191 1
		moveq.l	#72-1,d3		number of entries to search
d239 1
a239 1
		beq.s	SetInfo			no extension, carry on
d260 16
d540 1
a540 1
		moveq.l	#72,d0			clearing 73 entries
d546 3
a548 1
ExAllGetET	move.l	#ET_SIZEOF,d0		get the structure
d566 2
a567 1
		moveq.l	#72-1,d3		number of entries to search
@


1.7
log
@notification added
@
text
@d17 1
a17 1
		XDEF	ExObject,ExNext,ExAll
d75 2
a76 2
		tst.b	DiskType+3(a5)		FFS or oldFS ?
		bne.s	FFSExNext		it's FFS, go fast
d79 9
a87 9
		suba.l	a3,a3			no buffer yet
		moveq.l	#0,d2			so no relevant key
		cmp.l	d3,d4			is this the first ExNext ?
		bne.s	10$			nope, get old key
		move.l	d3,d0			yes, get directory header
		bsr	WaitBlock
		movea.l	d0,a3			save buffer pointer
		moveq.l	#0,d0			start at hash table 0
		bra.s	20$			and go find the next key
d90 11
a100 11
10$		move.l	d4,d0
		bsr	WaitBlock		fetch file header
		movea.l	d0,a3
		cmp.l	cb_SIZEOF+fhb_Parent(a3),d3	is file in this dir ?
		beq.s	12$			yep, no problems
11$		movea.l	a3,a0
		bsr	LooseBlock
		suba.l	a3,a3
		bra	SetInfo			bad file, quit now
12$		move.l	cb_SIZEOF+fhb_HashChain(a3),d0
		bne.s	30$			another on hash chain, get it
d103 11
a113 11
15$		lea.l	cb_SIZEOF+fhb_FileName(a3),a0
		bsr	Hash			get hash offset
		subi.w	#udb_HashTable,d0	convert to offset into table
		addq.l	#4,d0			and bump to next entry
		move.l	d0,-(sp)		save this value
		movea.l	a3,a0
		bsr	LooseBlock		free up old header
		move.l	d3,d0
		bsr	WaitBlock
		movea.l	d0,a3			fetch directory header
		move.l	(sp)+,d0		get back hash offset
d115 7
a121 7
20$		lea.l	cb_SIZEOF+fhb_HashTable(a3,d0.w),a0
21$		cmpi.l	#72*4,d0
		beq.s	11$			at end, no more entries
		addq.l	#4,d0			bump index counter
		move.l	(a0)+,d1		get next entry
		beq.s	21$			nothing there, try next
		move.l	d1,d0			found next entry
d123 7
a129 7
30$		move.l	d0,d2			save new header key
		movea.l	a3,a0
		bsr	LooseBlock		free previous header
		move.l	d2,d0
		bsr	WaitBlock		and fetch the next one
		movea.l	d0,a3
		bra	SetInfo			header to examine in a3
d210 3
a212 1
		cmp.l	cb_SIZEOF+fhb_Parent(a3),d3  does this file belong ?
d226 2
a227 2
40$		move.l	cb_SIZEOF+fhb_HashChain(a3),d0
		beq.s	70$			no extension, carry on
d243 4
a246 4
70$		cmp.l	d4,d3			if d3=d4 then first ExNext
		beq.s	SetInfo			so we can call SetInfo
		cmp.l	d4,d2			are we past last place ?
		ble.s	30$			no, loose a3 and scan again
a262 3
;
; If this is an ACTION_EXAMINE_ALL packet then we loop back as long as we
; haven't read all the files or completely filled the callers array.
d269 3
d273 7
a279 1
10$		movea.l	dp_Arg2(a2),a4		get fib pointer
d289 3
a291 1
		movem.l	cb_SIZEOF+fhb_FileName(a3),d0-d7
d296 1
a296 1
		tst.b	cb_SIZEOF+fhb_Comment(a3)
d298 1
a298 1
		movem.l	cb_SIZEOF+fhb_Comment(a3),d0-d7
d300 1
a300 1
		movem.l	cb_SIZEOF+fhb_Comment+32(a3),d0-d7
d302 1
a302 1
		movem.l	cb_SIZEOF+fhb_Comment+64(a3),d0-d3
d304 1
d306 1
a306 1
DoDate		movem.l	cb_SIZEOF+fhb_Days(a3),d0-d2
d320 1
a320 1
5$		move.l	cb_SIZEOF+fhb_Link(a3),-(sp)	save the key
d334 3
a336 1
		move.l	cb_SIZEOF+fhb_ByteSize(a3),d0
d341 1
a341 1
		divu.w	#488,d0			different calc for DOS\0
d351 1
a351 1
17$		moveq.l	#9,d1
d353 2
a354 1
		move.l	#511,d1			allow for a partial block too
d360 1
a360 1
		divu.w	#72,d1			72 = hash table size
d367 3
a369 1
		move.l	cb_SIZEOF+fhb_Protect(a3),fib_Protection(a4)
d371 2
a372 2
; all done, free up this block and return a successful packet
20$		movea.l	a3,a0
d376 1
a376 2
		movea.l	a2,a0
		bra	WorkDone		send packet back and die
d408 1
a408 1
;		APTR	Name		pointer to BSTR name
d586 1
a586 1
20$		cmp.w	d1,d3			do we have room in the buffer
d598 3
a600 1
40$		move.l	cb_SIZEOF+fhb_HashChain(a3),d0
d636 12
a647 7
		lea.l	cb_SIZEOF+fhb_FileName(a3),a0
		move.b	(a0),d0			get length of name
		ext.w	d0			calculate longword length
		lsr.w	#2,d0
90$		move.l	(a0)+,(a1)+		transfer name
		dbra	d0,90$			will be padded to lword len

d654 3
a656 1
		tst.b	cb_SIZEOF+fhb_Comment(a3)
d659 2
d662 2
a663 1
		lea.l	cb_SIZEOF+fhb_Comment(a3),a0
d689 2
d693 1
a693 1
		move.l	cb_SIZEOF+fhb_ByteSize(a3),ead_Size(a0)
d697 1
a697 1
		move.l	cb_SIZEOF+fhb_Protect(a3),ead_Prot(a0)
d701 3
a703 3
		move.l	cb_SIZEOF+fhb_Days(a3),ead_Days(a0)
		move.l	cb_SIZEOF+fhb_Mins(a3),ead_Mins(a0)
		move.l	cb_SIZEOF+fhb_Ticks(a3),ead_Ticks(a0)
@


1.6
log
@added exall plus support for hard links
@
text
@@


1.5
log
@Stuff added to handle links and a bug fix to make file block sizes 
agree with what the old filing system did (don't include extensions).
@
text
@d15 1
a15 1
		XREF	CheckLock,WaitBlock,GetPubMem,Hash
d17 1
a17 1
		XDEF	ExObject,ExNext
a38 19
; ExAll( packet )
;	   d0
;
; Fills an array of ShortFibs with info about all of the files in a directory.
; Directory must still be locked and Examined in the same manner as for ExNext
; but this one won't exit until the array has been filled or all entries were
; scanned.  Returns vary and there is one funny case, as follows:
;
; Res1 = Number of files in array		This is a good exit
; Res2 = ErrorCode				normally NO_MORE_ENTRIES
;
; Watch out for Res1=0 and Res2=NO_MORE_ENTRIES, it just means there were no
; files to be scanned in the given directory.  
;
; Res1 = FALSE					This is a bad exit
; Res2 = ErrorCode				normally bad lock or r/w error
;==============================================================================

;==============================================================================
d362 369
@


1.4
log
@ExNext now uses the old (broken) method when using oldfs disks.  Could not
maintain compatibility using the new FFS method because oldFS disk are
not guaranteed to have sorted hash chains.  The only reason for this not
working is because of the GODDAMN KLUGE FIX for Lattice and Manx programs.
@
text
@d78 2
a79 1
		movea.l	dp_Arg1(a2),a0		check the lock
a259 1
; **** need to fix this for unsorted hash chains in the old filing system ****
a289 1
***** TEST FOR A LINK HERE AND GO READ THE OTHER HEADER IF IT IS ONE!!!!!!
a297 4
		clr.l	fib_NumBlocks(a4)	assume it's a directory
		move.l	cb_SIZEOF+fhb_ByteSize(a3),fib_Size(a4)  save size
		cmpi.w	#st.file,d0		check it's a file
		bne.s	20$			nope, it was a directory
a298 35
; calculate how many blocks this file uses including link table extensions and
; the file header entry too.
		move.l	fib_Size(a4),d0		get back the size
;		tst.b	DiskType+3(a5)		is this DOS/0
;		bne.s	17$			nope

;		move.l	cb_SIZEOF+fhb_DataSize(a3),fib_Size(a4)  save size
;		move.l	fib_Size(a4),d0		OLDfs uses a different slot

;		divu.w	#488,d0
;		move.l	d0,d1
;		ext.l	d0
;		swap	d1
;		tst.w	d1
;		beq.s	18$
;		addq.l	#1,d0
;		bra.s	18$

17$		moveq.l	#9,d1
		lsr.l	d1,d0			convert to num blocks
		move.l	#511,d1			allow for a partial block too
		and.l	fib_Size(a4),d1
		beq.s	18$			no partial block used
		addq.l	#1,d0
18$		move.l	d0,d1			get number of ext blocks
		divu.w	#72,d1			72 = hash table size
		ext.l	d1
		add.l	d1,d0			add to total blocks
;I've taken this out because the old file system doesn't do it!!!!
;		addq.l	#1,d0			and one for file header block
19$		move.l	d0,fib_NumBlocks(a4)	stash this

; sizes set up according to file type, now fill in info that's the same for
; both file and directory headers.  movem's used for speed here.
20$		move.l	cb_SIZEOF+fhb_Protect(a3),fib_Protection(a4)
d302 1
d317 57
d375 1
a375 1
		movea.l	a3,a0
@


1.3
log
@made FFS use same size field as old fs
@
text
@d15 1
a15 1
		XREF	CheckLock,WaitBlock,GetPubMem
d90 60
d151 1
a151 1
		suba.l	a3,a3			a3=0 means no buffer here
d182 1
a182 1
		bra.s	ExNextFail		error out
d200 1
a200 1
		lea.l	ET_Entries(a4),a1	put entries in lowest to highest
d290 1
@


1.2
log
@*** empty log message ***
@
text
@d246 2
a247 2
		tst.b	DiskType+3(a5)		is this DOS/0
		bne.s	17$			nope
d249 2
a250 2
		move.l	cb_SIZEOF+fhb_DataSize(a3),fib_Size(a4)  save size
		move.l	fib_Size(a4),d0		OLDfs uses a different slot
d252 8
a259 8
		divu.w	#488,d0
		move.l	d0,d1
		ext.l	d0
		swap	d1
		tst.w	d1
		beq.s	18$
		addq.l	#1,d0
		bra.s	18$
@


1.1
log
@Initial revision
@
text
@d246 16
a261 1
		moveq.l	#9,d1
@
