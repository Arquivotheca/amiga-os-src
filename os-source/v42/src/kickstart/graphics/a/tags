Alert	GfxMem.asm	/^*	an Alert() will be called if you attempt to free/
AllocBitMap	SimpleSprites.asm	/^*	AllocBitMap()graphics\/sprite.h$/
AllocDBufInfo	changevpbitmap.asm	/^*       AllocDBufInfo(vp)$/
AllocRaster	AllocRaster.asm	/^*	planeptr = AllocRaster( width, height )$/
AllocSpriteData	SimpleSprites.asm	/^*	FreeSpriteData  - free sprite data allocated by /
AllocSpriteDataA	SimpleSprites.asm	/^*	SpritePtr | 0 = AllocSpriteDataA(bitmap,taglist)/
AreaCircle	AreaCircle.asm	/^*	error = (int) AreaCircle( rp,  cx,  cy, radius)$/
AreaDraw	AreaDraw.asm	/^*	error = AreaDraw( rp,  x,     y)$/
AreaEllipse	AreaCircle.asm	/^*	This function is actually a macro which calls $/
AreaEnd	AreaEllipse.asm	/^*	Add an ellipse to the vector buffer. It will be /
AreaMove	AreaCircle.asm	/^*	AreaMove() AreaDraw() AreaCircle() InitArea() Ar/
AttachPalExtra	NewColorStuff.asm	/^*       status=AttachPalExtra( cm, vp)$/
AttemptLockLayerRom	AttemptLockLayerRom.asm	/^*	gotit = AttemptLockLayerRom( layer )$/
BMF_INTERLEAVED	allocbitmap.asm	/^*				BMF_INTERLEAVED (see AllocBitMap). The flag$/
BeginRefresh	ScrollRaster.asm	/^*   call the appropriate BeginRefresh(Intuition) o/
BltClear	BltClear.asm	/^*	BltClear( memBlock, bytecount, flags )$/
BltPattern	BltPattern.asm	/^*       BltPattern(rp, mask, xl, yl, maxx, maxy, b/
BytesPerRow	WritePixel.asm	/^muls	(a0),d1		* could be BytesPerRow(a0)$/
CBump	gasm.asm	/^*	CBump( c )$/
CEND	MrgCop.asm	/^*       depend on this! Each list must be terminat/
CINIT	gasm.asm	/^* 	cl = CINIT( ucl , n )$/
CMOVE	gasm.asm	/^*	CMOVE( c , a , v )$/
CMove	gasm.asm	/^*	CMove( c , a , v )$/
CWAIT	gasm.asm	/^*	CWAIT( c , v , h )$/
CWait	gasm.asm	/^*	CWait( c , v , h )$/
CalcFMode	CalcIVG.asm	/^*	fmode = CalcFMode(ViewPort)$/
CalcIVG	CalcIVG.asm	/^*	count = CalcIVG(View, ViewPort)$/
ChangeExtSpriteA	SimpleSprites.asm	/^*       ChangeExtSpriteA( vp, oldsprite, newsprite/
ChangeSprite	SimpleSprites.asm	/^*       ChangeSprite( vp, s, newdata)$/
ChangeVPBitMap	changevpbitmap.asm	/^*	Allocates a structure which is used by the Chang/
CloseMonitor	Monitor.asm	/^*       CloseMonitor() graphics\/monitor.h$/
DR	CalcIVG.asm	/^	DR	(a1)$/
DisownBlitter	OwnBlitter.asm	/^*	DisownBlitter() WaitBlit()$/
DisplayBeep	GetRGB4.asm	/^*	DisplayBeep() will lead to incorrect results.$/
Draw	Draw.asm	/^*       Draw( rp,   x,     y)$/
DrawCircle	Circle.asm	/^*	DrawCircle( rp, cx, cy, radius)$/
DrawEllipse	Circle.asm	/^*	This routine is a macro which calls DrawEllipse(/
EraseRect	EraseRect.asm	/^*	EraseRect( rp, xmin, ymin, xmax, ymax)$/
FMode	CalcIVG.asm	/^*	To calculate the maximum FMode (or Bandwidth) th/
FindColor	NewColorStuff.asm	/^*       color =FindColor(  cm,  R,   G,    B , max/
Flood	Flood.asm	/^*	error = Flood( rp, mode, x, y)$/
FreeBitMap	allocbitmap.asm	/^*       When finished with the bitmap, you should /
FreeColorMap	FreeColorMap.asm	/^*       FreeColorMap( colormap )$/
FreeCopList	FreeCopList.asm	/^*       FreeCopList(coplist)$/
FreeCprList	FreeCprList.asm	/^*       FreeCprList(cprlist)$/
FreeDBufInfo	changevpbitmap.asm	/^*	FreeDBufInfo() ChangeVPBitMap()$/
FreeMem	FreeVPortCopLists.asm	/^*       lists and call FreeMem() to deallocate the/
FreeRaster	AllocRaster.asm	/^*	FreeRaster() graphics\/gfx.h$/
FreeSprite	SimpleSprites.asm	/^*	FreeSprite() ChangeSprite() MoveSprite() GetSpri/
FreeSpriteData	SimpleSprites.asm	/^*	FreeSpriteData(extsp) (V39)$/
FreeVPortCopLists	FreeVPortCopLists.asm	/^*       FreeVPortCopLists(vp)$/
GetAPen	GetSet.asm	/^*       GetAPen  ( rp )$/
GetBPen	GetSet.asm	/^*       GetBPen  ( rp )$/
GetColorMap	GetColorMap.asm	/^*       cm = GetColorMap( entries )$/
GetDrMd	GetSet.asm	/^*       GetDrMd  ( rp )$/
GetExtSpriteA	SimpleSprites.asm	/^*	Sprite_Number = GetExtSpriteA( sprite, tags )  (/
GetOPen	GetSet.asm	/^*	GetOPen() graphics\/gfxmacros.h$/
GetRGB32	NewColorStuff.asm	/^*       GetRGB32(  cm,  firstcolor, ncolors, table/
GetRGB4	GetColorMap.asm	/^*	it being anything you can understand. Use GetRGB/
GetSprite	SimpleSprites.asm	/^*	Sprite_Number = GetSprite( sprite, pick )$/
GetVPModeID	GetVPModeID.asm	/^*	modeID =  GetVPModeID( vp )$/
GfxFree	GfxMem.asm	/^*	graphics\/gfxnodes.h GfxFree() GfxAssociate() Gfx/
GfxLookUp	GfxMem.asm	/^*	that given the pointer the node can be retrieved/
GfxNew	CalcIVG.asm	/^*	GfxNew()  VideoControl()  graphics\/view.h$/
InitArea	AreaEnd.asm	/^*	InitArea() AreaMove() AreaDraw() AreaEllipse()  /
InitBitMap	InitBitMap.asm	/^*	InitBitMap( bm, depth, width, height )$/
InitRastPort	InitRastPort.asm	/^*   	InitRastPort( rp )$/
InitTmpRas	InitTmpRas.asm	/^*   	InitTmpRas(tmpras, buffer, size)$/
InitVPort	InitVPort.asm	/^*	InitVPort( vp )$/
InitView	InitView.asm	/^*	InitView( view )$/
LN_NAME	OwnBlitter.asm	/^move.l	ThisTask(a6),LN_NAME(sp)$/
LN_PRED	OwnBlitter.asm	/^MOVE.L  A0,LN_PRED(A1)$/
LN_TYPE	WaitTOF.asm	/^move.b	d0,LN_TYPE(sp)$/
LOCAL_RP	AreaEnd.asm	/^*	pea		LOCAL_RP(sp)			* newras$/
LoadRGB32	NewColorStuff.asm	/^*       LoadRGB32(  vp,  table )$/
LoadRGB4	LoadRGB4.asm	/^*	LoadRGB4( vp, colors , count )$/
LoadView	LoadView.asm	/^*       LoadView( View )$/
LockLayerRom	AttemptLockLayerRom.asm	/^*	LockLayerRom() UnlockLayerRom()$/
MN_REPLYPORT	changevpbitmap.asm	/^tst.l	dbi_SafeMessage+MN_REPLYPORT(a2)$/
MakeVPort	InitVPort.asm	/^*	MakeVPort() graphics\/view.h$/
ModeNotAvailable	GetVPModeID.asm	/^*	graphics\/displayinfo.h, ModeNotAvailable()$/
MonitorSpec	Monitor.asm	/^*       OpenMonitor -- open a named MonitorSpec (V/
Move	Draw.asm	/^*	Move() graphics\/rastport.h$/
MoveSprite	SimpleSprites.asm	/^*	MoveSprite(vp, sprite, x, y)$/
MrgCop	LoadView.asm	/^*       InitVPort(), MakeVPort(), and MrgCop().$/
ObatinBestPen	NewColorStuff.asm	/^*	optimize its palette error metrics differently. /
ObtainBestColor	NewColorStuff.asm	/^*		Generally, for shared access, you should use Ob/
ObtainBestPen	NewColorStuff.asm	/^*	The error metric used for ObtainBestPen() is bas/
ObtainBestPenA	NewColorStuff.asm	/^*		    use this function as a fallback when Obtain/
ObtainPen	NewColorStuff.asm	/^*       n = ObtainPen( cm, n, r, g, b, flags)$/
OpenMonitor	Monitor.asm	/^*       mspc = OpenMonitor( monitor_name , display/
OwnBlitter	OwnBlitter.asm	/^*       OwnBlitter()$/
PolyDraw	PolyDraw.asm	/^*	PolyDraw( rp, count , array )$/
QBSBlit	QBSBlit.asm	/^*	QBSBlit( bsp )$/
QBlit	QBSBlit.asm	/^*	QBlit() hardware\/blit.h$/
RastPort	GetSet.asm	/^*       SetOutlinePen -- Set the Outline Pen value/
ReadPixel	ReadPixel.asm	/^*       penno = ReadPixel( rp,    x,    y )$/
ReadPixelArray8	rpa8.asm	/^*	count = ReadPixelArray8(rp,xstart,ystart,xstop,y/
ReadPixelLine8	rpa8.asm	/^*	count = ReadPixelLine8(rp,xstart,ystart,width,ar/
RectFill	RectFill.asm	/^*	RectFill( rp, xmin, ymin, xmax, ymax)$/
RelasePen	NewColorStuff.asm	/^*	If this call succceeds, then you must call Relas/
ReleasePen	NewColorStuff.asm	/^*       ReleasePen( cm, n)$/
ScrollRaster	ScrollRaster.asm	/^*   ScrollRaster(rp, dx, dy, xmin, ymin, xmax, yma/
ScrollVPort	ScrollVPort.asm	/^*	ScrollVPort( vp )$/
SearchColorMap	NewColorStuff.asm	/^*       color | -1 =SearchColorMap(  cm,  proc, R,/
SetABPenDrMd	SetAPen.asm	/^*	SetABPenDrMd( rp, apen, bpen, mode )$/
SetAPen	GetSet.asm	/^*	SetAPen() graphics\/gfx.h$/
SetBPen	GetSet.asm	/^*	SetBPen() graphics\/gfx.h$/
SetDrMd	GetSet.asm	/^*	SetDrMd() graphics\/gfx.h$/
SetMaxPen	GetSet.asm	/^*       SetMaxPen ( rp, maxpen)$/
SetOPen	gasm.asm	/^*	SetOPen(rp, pen)$/
SetOutlinePen	GetSet.asm	/^*       old_pen=SetOutlinePen  ( rp, pen )$/
SetRGB32	NewColorStuff.asm	/^*       SetRGB32(  vp,  n,   r,    g,    b)$/
SetRGB32CM	SetRGB4CM.asm	/^*       SetRGB32CM(  cm,  n,   r,    g,    b)$/
SetRGB4	FreeColorMap.asm	/^*       SetRGB4() GetColorMap() graphics\/view.h$/
SetRGB4CM	SetRGB4CM.asm	/^*       SetRGB4CM(  cm,  n,   r,    g,    b)$/
SetRast	SetRast.asm	/^*       SetRast( rp, pen )$/
SetWriteMask	GetSet.asm	/^*       success=SetWriteMask ( rp, msk )$/
Text	MustMem.asm	/^* Text() - shouldn't. Change was made for Text() i/
UCopperListInit	gasm.asm	/^*	cl = UCopperListInit( ucl , n )$/
UnlockLayer	UnlockLayerRom.asm	/^*	This call is identical to UnlockLayer (layers.li/
UnlockLayerRom	LockLayerRom.asm	/^*	UnlockLayerRom() layers.library\/LockLayer() grap/
VBeamPos	SetAPen.asm	/^*	pos = VBeamPos()$/
VPOrigin	vporigin.asm	/^*	VPOrigin(v, vp, origin1, origin2)$/
VideoControl	VideoControl.asm	/^*       error = VideoControl( cm , tags )$/
ViewPort	CalcIVG.asm	/^*	CalcFMode -- Calculate the max FMode value to us/
Viewports	MakeVPort.asm	/^*	In V37 and earlier, narrow Viewports (whose righ/
WaitBOVP	WaitBOVP.asm	/^*	WaitBOVP( vp )$/
WaitBlit	WaitBlit.asm	/^*       WaitBlit()$/
WaitTOF	WaitBOVP.asm	/^*	WaitTOF() VBeamPos()$/
WritePixel	ReadPixel.asm	/^*       WritePixel()	graphics\/rastport.h$/
WritePixelArray8	wpa8.asm	/^*	count = WritePixelArray8(rp,xstart,ystart,xstop,/
WritePixelLine8	wpa8.asm	/^*	count = WritePixelLine8(rp,xstart,ystart,width,a/
_DefaultMoveSprite	SimpleSprites.asm	/^got_vp:	vp_to_vector	a2,vt_MoveSprite,_DefaultMove/
_DefaultPokeColors	NewColorStuff.asm	/^vp_to_vector	a0,vt_PokeColors,_DefaultPokeColors(p/
_LVOAlert	MustMem.asm	/^*		jsr	_LVOAlert(a6)$/
_LVOAllocMem	GetColorMap.asm	/^jsr	_LVOAllocMem(a6)$/
_LVOAllocVec	SimpleSprites.asm	/^jsr	_LVOAllocVec(a6)$/
_LVOAreaDraw	AreaCircle.asm	/^jsr	_LVOAreaDraw(a6)		* close it up, sets cc$/
_LVOAttemptSemaphore	AttemptLockLayerRom.asm	/^jsr		_LVOAttemptSemaphore(a6)$/
_LVOBltClear	AreaEnd.asm	/^jsr		_LVOBltClear(a6)$/
_LVOBltPattern	AreaEnd.asm	/^	jsr		_LVOBltPattern(a6)$/
_LVOClipBlit	EraseRect.asm	/^jsr	_LVOClipBlit(a6)$/
_LVODisownBlitter	BltPattern.asm	/^jsr	_LVODisownBlitter(a6)$/
_LVODoHookClipRects	BltPattern.asm	/^jsr	_LVODoHookClipRects(a6)$/
_LVODraw	AreaEnd.asm	/^*				jsr	_LVODraw(a6)$/
_LVODrawEllipse	AreaEnd.asm	/^*		end bart - 05.05.86 change in args to DrawEllip/
_LVOFreeMem	FreeColorMap.asm	/^jsr	_LVOFreeMem(a6)	* free off colortable$/
_LVOFreeVec	SimpleSprites.asm	/^jsr	_LVOFreeVec(a6)$/
_LVOGetVPModeID	CalcIVG.asm	/^jsr	_LVOGetVPModeID(a6)$/
_LVOGfxLookUp	LoadView.asm	/^jsr	_LVOGfxLookUp(a6)$/
_LVOInitBitMap	AreaEnd.asm	/^jsr		_LVOInitBitMap(a6)$/
_LVOMove	AreaEnd.asm	/^*				jsr	_LVOMove(a6)$/
_LVOMoveSprite	SimpleSprites.asm	/^jsr	_LVOMoveSprite(a6)$/
_LVONextTagItem	NewColorStuff.asm	/^jsr	_LVONextTagItem(a6)$/
_LVOObtainGfxSemaphore	LockLayerRom.asm	/^jsr	_LVOObtainGfxSemaphore(a6)$/
_LVOObtainSemaphore	LockLayerRom.asm	/^jsr		_LVOObtainSemaphore(a6)$/
_LVOPermit	NewColorStuff.asm	/^jsr	_LVOPermit(a6)$/
_LVOReadPixelLine8	rpa8.asm	/^    jsr _LVOReadPixelLine8(a6)$/
_LVOReleaseGfxSemaphore	UnlockLayerRom.asm	/^jsr	_LVOReleaseGfxSemaphore(a6)$/
_LVOReleaseSemaphore	MustMem.asm	/^jsr	_LVOReleaseSemaphore(a6)$/
_LVOReplyMsg	changevpbitmap.asm	/^jsr	_LVOReplyMsg(a6)$/
_LVOSetRGB32	SetRGB4.asm	/^jsr	_LVOSetRGB32(a6)$/
_LVOSetSignal	OwnBlitter.asm	/^jsr	_LVOSetSignal(a6)$/
_LVOSignal	OwnBlitter.asm	/^jsr	_LVOSignal(a6)$/
_LVOVBeamPos	WaitBOVP.asm	/^jsr _LVOVBeamPos(a6)			* returns in d0.l$/
_LVOWait	OwnBlitter.asm	/^jsr	_LVOWait(a6)$/
_LVOWritePixel	AreaEnd.asm	/^jsr	_LVOWritePixel(a6)$/
a	LoadView.asm	/^*       LoadView -- Use a (possibly freshly create/
a2	rpa8.asm	/^move.l  d5,d1       ; y (current line)$/
a3	wpa8.asm	/^	move.l	d4,d3		; recalculate a3 (array source poin/
abs	cdraw.asm	/^*	add.w	d1,d1				* 2*abs(dy)$/
acceptable	FreeColorMap.asm	/^*		  acceptable (V39).$/
adata	Draw.asm	/^move.w  #$FFFF,adata(a0)$/
agnus	WaitBlit.asm	/^*	Because of a bug in agnus (prior to all revision/
ai_Count	AreaCircle.asm	/^		sub.w	#1,ai_Count(a0)		* yes, lets just backup$/
ai_FirstX	AreaCircle.asm	/^if ai_FirstX(a0)=d7$/
ai_FlagPtr	AreaCircle.asm	/^		move.l	a2,ai_FlagPtr(a0)$/
ai_FlagTbl	InitArea.asm	/^	    move.l  a1,ai_FlagTbl(a0)           * ai->Fla/
ai_MaxCount	AreaCircle.asm	/^if ai_MaxCount(a0)>=d7.w$/
ai_VctrPtr	AreaCircle.asm	/^		move.l	a1,ai_VctrPtr(a0)	* new pointer$/
ai_VctrTbl	InitArea.asm	/^	    move.l  a1,ai_VctrTbl(a0)           * ai->Vct/
and	EraseRect.asm	/^*	(xmax >= xmin) and (ymax >= ymin)$/
animation	changevpbitmap.asm	/^*       AllocDBufInfo -- Allocate information for /
at	AreaMove.asm	/^*	at  (x,y). Add the necessary  points  to  vector/
b	BltPattern.asm	/^lp1:	move.b	(a5)+,d4$/
bandwidth	CalcIVG.asm	/^* 4) The bandwidth (FMode) we are using.$/
bd	ScrollVPort.asm	/^	pea	bd(a7)$/
bdata	BltPattern.asm	/^		move.l	d0,bdata(a0)	* and adata$/
bindrecord	MustMem.asm	/^* bindrecord() in d\/startup.c - if you have no mem/
bit	SetRGB4.asm	/^	bsr.s	get_12bit_color	;d1=12bit(d1,d2,d3)$/
bitclear	SimpleSprites.asm	/^; bitclear(gb_SpriteReserved-gb_SoftSprites,snum)=/
bitmap	allocbitmap.asm	/^*       GetBitMapAttr -- Returns information about/
bits	InitBitMap.asm	/^*	width - number of bits (columns) wide for this B/
bltSetup	MustMem.asm	/^* bltSetup() in text\/bltcopy.asm - now checks for /
bltadat	SetRast.asm	/^	move	d0,bltadat(a0)$/
bltafwm	BltPattern.asm	/^	move.w	d4,bltafwm(a0)$/
bltalwm	SetRast.asm	/^move	d0,bltalwm(a0)$/
bltbdat	BltPattern.asm	/^	move.l	d2,bltbdat(a0)$/
bltbytes	AreaEnd.asm	/^move.w	d2,d1	* bltbytes(d0,d1) (xmin,xmax)$/
bltcon0	AreaEnd.asm	/^	move.w	#NANBC+NABC+ANBC+ABC+DEST+SRCC,bltcon0(a0)/
bltcon1	BltClear.asm	/^	move    d6,bltcon1(a0)          * so use move.w i/
bltcpt	BltPattern.asm	/^	move.l	a4,bltcpt(a0)$/
bltdmod	BltPattern.asm	/^	move.w	d2,bltdmod(a0)$/
bltmda	BltPattern.asm	/^move.l	d0,bltmda(a0)	* and bltmdd$/
bltmdb	Draw.asm	/^move.w  d6,bltmdb(a0)$/
bltmdc	AreaEnd.asm	/^	move.w	d5,bltmdc(a0)$/
bltmdd	BltClear.asm	/^	move    d6,bltmdd(a0)           * io->bltcon1 = i/
bltpta	BltPattern.asm	/^move.l	gn_bltpta(a1),bltpta(a0)$/
bltptc	AreaEnd.asm	/^move.l	a1,bltptc(a0)$/
bltptd	BltClear.asm	/^move.l  a1,bltptd(a0)           * io->bltptd = (UB/
bltsize	AreaEnd.asm	/^move.w	d1,bltsize(a0)$/
bltsizh	BltPattern.asm	/^move.w	d2,bltsizh(a0)$/
bltsizv	AreaEnd.asm	/^move.w	d1,bltsizv(a0)$/
bm_BytesPerRow	InitBitMap.asm	/^move    d1,bm_BytesPerRow(a0)       * bm->BytesPer/
bm_Depth	Draw.asm	/^until bm_Depth(a4).b=d1$/
bm_Flags	InitBitMap.asm	/^	clr.b	bm_Flags(a0)$/
bm_Pad	SetRast.asm	/^cmp.w	#UNLIKELY_WORD,bm_Pad(a1)$/
bm_Planes	AreaEnd.asm	/^move.l	a1,LOCAL_BM+bm_Planes(sp)$/
bm_Rows	InitBitMap.asm	/^	move    d2,bm_Rows(a0)              * bm->Rows = /
bn_beamsync	QBSBlit.asm	/^move.w	d1,bn_beamsync(a1)$/
bn_stat	QBlit.asm	/^		btst    #CLEANMEn,bn_stat(a2)$/
bpr1_w	ScrollVPort.asm	/^move.w	d1,bpr1_w(a7)$/
buffer	InitArea.asm	/^*	pointed to by buffer (short pointer) should be f/
by	ScrollRaster.asm	/^*   Move the bits in the raster by (dx,dy) towards/
cd_absdx	cdraw.asm	/^		move.w	d5,cd_absdx(sp)$/
cd_code1	cdraw.asm	/^move.b	d0,cd_code1(a0)$/
cd_code2	cdraw.asm	/^move.b	d0,cd_code2(a0)$/
cd_con1	cdraw.asm	/^move.w	d4,cd_con1(sp)$/
cd_dx	cdraw.asm	/^move.w	d4,cd_dx(sp)$/
cd_dy	cdraw.asm	/^move.w	d5,cd_dy(sp)$/
cd_xmajor	cdraw.asm	/^		clr.b	cd_xmajor(sp)$/
changed	SetAPen.asm	/^*	once, or not at all if nothing changed (warning /
ci_DestData	NewColorStuff.asm	/^move.w	d3,ci_DestData(a2)$/
ci_SIZEOF	changevpbitmap.asm	/^move.w	d1,ci_DestData+ci_SIZEOF(a0)$/
circle	Circle.asm	/^*	radius - the radius of the circle (note: the rad/
closes	CalcIVG.asm	/^* window closes (View->DxOffset + ViewPort->DxOffs/
cm_AuxFlags	NewColorStuff.asm	/^btst	#CMAB_FULLPALETTE,cm_AuxFlags(a3)$/
cm_Bp_1_base	GetColorMap.asm	/^	move.w	#8,cm_Bp_1_base(a2)$/
cm_Count	GetColorMap.asm	/^move.w	d1,cm_Count(a2)	* stash size of ColorTable$/
cm_LowColorBits	LoadRGB4.asm	/^	tst.l	cm_LowColorBits(a0)$/
cm_PalExtra	NewColorStuff.asm	/^	tst.l	cm_PalExtra(a0)$/
cm_SpriteBase_Even	GetColorMap.asm	/^	move.w	#16,cm_SpriteBase_Even(a2)$/
cm_Type	CalcIVG.asm	/^tst.b	cm_Type(a0)$/
cm_VPModeID	GetColorMap.asm	/^	move.l	#INVALID_ID,cm_VPModeID(a2)$/
color	SetRGB4.asm	/^*	the color (r,g,b) for pen number n.$/
commands	VideoControl.asm	/^*	private commands (used internally by intuition -/
completed	allocbitmap.asm	/^*	completed (by calling WaitBlit()) before you cal/
condition	Draw.asm	/^*	a cusp condition (B10406) can occur when final e/
cr_BitMap	cdraw.asm	/^if cr_BitMap(a2).l$/
cr_MaxX	ReadPixel.asm	/^					if cr_MaxX(a0)>=d0.w$/
cr_MaxY	ReadPixel.asm	/^							if cr_MaxY(a0)>=d1.w$/
cr_MinX	ReadPixel.asm	/^				if cr_MinX(a0)<=d0.w$/
cr_MinY	ReadPixel.asm	/^						if cr_MinY(a0)<=d1.w$/
cr_lobs	ReadPixel.asm	/^tst.l	cr_lobs(a0)$/
dbi_BeamPos1	changevpbitmap.asm	/^	move.w	d0,dbi_BeamPos1(a2)$/
dbi_CopPtr1	changevpbitmap.asm	/^movem.l	a0\/a4\/a5,dbi_CopPtr1(a2)$/
dbi_Count1	changevpbitmap.asm	/^	move.l	#1,dbi_Count1(a2)$/
dbi_MatchLong	changevpbitmap.asm	/^	move.l	gb_SpecialCounter(a6),dbi_MatchLong(a2)$/
disownblitter	OwnBlitter.asm	/^* called like disownblitter(GB)$/
double	changevpbitmap.asm	/^*	viewport. This can be used to implement double (/
dualpf	CalcIVG.asm	/^* d5.b = flag for dualpf (if not 0, then = Depth o/
ellipse	AreaEllipse.asm	/^*	a  - the horizontal radius of the ellipse (note:/
es_flags	SimpleSprites.asm	/^tst.w	es_flags(a2)$/
es_wordwidth	SimpleSprites.asm	/^	move.w	#1,es_wordwidth(a3)$/
ffff	NewColorStuff.asm	/^;	if sprites then uwordmask[1] |= $ffff	(yep, even/
field	GetVPModeID.asm	/^*	DisplayInfo.NotAvailable field (defined in graph/
first	PolyDraw.asm	/^*	array - pointer to first (x,y) pair$/
flags_l	NewColorStuff.asm	/^clr.l	flags_l(a7)$/
fmode	CalcIVG.asm	/^* d6.w	= fmode		(default = 1x bandwidth)$/
fwmask	AreaEnd.asm	/^	move.l	d0,fwmask(a0)	* and lwmask$/
gb_BeamSync	QBSBlit.asm	/^	tst.w	gb_BeamSync(a6)$/
gb_BlitLock	OwnBlitter.asm	/^addq.w  #1,gb_BlitLock(a6)$/
gb_ChipRevBits0	AreaEnd.asm	/^	btst	#GFXB_BIG_BLITS,gb_ChipRevBits0(a6)$/
gb_DBList	changevpbitmap.asm	/^	move.l	a2,gb_DBList(a5)$/
gb_Debug	CalcIVG.asm	/^tst.b	gb_Debug(a6)$/
gb_Flags	OwnBlitter.asm	/^or.w    #QBOWNER,gb_Flags(a6)$/
gb_MemType	SimpleSprites.asm	/^tst.b	gb_MemType(a5)$/
gb_ScanDoubledSprites	SimpleSprites.asm	/^bset.b	d0,gb_ScanDoubledSprites(a5)$/
gb_SoftSprites	SimpleSprites.asm	/^ss_lp	btst.b	d1,gb_SoftSprites(a6)$/
gb_SpecialCounter	MrgCop.asm	/^	addq.l	#1,gb_SpecialCounter(a6)$/
gb_SprMoveDisable	SimpleSprites.asm	/^	bset.b	d1,gb_SprMoveDisable(a6)$/
gb_SpriteReserved	SimpleSprites.asm	/^btst.b	d0,gb_SpriteReserved(a5)$/
gb_SpriteWidth	SimpleSprites.asm	/^	move.w	d0,gb_SpriteWidth(a6)$/
gb_TOF_WaitQ	WaitTOF.asm	/^move.l	a5,a0				; gb_TOF_WaitQ(GfxBase)$/
gb_VBlank	QBSBlit.asm	/^tst.b	gb_VBlank(a6)$/
gb_blthd	OwnBlitter.asm	/^tst.l	gb_blthd(a6)		* any blits queued?$/
gb_blttl	QBlit.asm	/^move.l  a1,gb_blttl(a6)     * new end of list$/
gb_bsblthd	OwnBlitter.asm	/^	tst.l	gb_bsblthd(a6)	* new code by Dale 11\/4\/85 a/
gb_bsblttl	QBSBlit.asm	/^    move.l  a1,gb_bsblttl(a6)       * new end of l/
get	cdraw.asm	/^*	movem.l	(8*4)+12(sp),d2\/d3	* get (x0,y0)$/
get_bplcon2	NewColorStuff.asm	/^* get_bplcon2() - ZDBPSELx, ZDBPEN, ZDCTEN, PF1Px,/
get_bplcon3	NewColorStuff.asm	/^* get_bplcon3() - PF2OFx, SPRESx, BRDRBLNKM, BRDRN/
get_bplcon4	NewColorStuff.asm	/^* get_bplcon4() - BPLAMx, ESPRMx, OSPRMx$/
getmaxbytesperrow	MustMem.asm	/^* getmaxbytesperrow() - will always (eventually) g/
gn_bltptb	BltPattern.asm	/^			move.l	d0,gn_bltptb(a1)$/
gn_bltptr	BltPattern.asm	/^move.l	a4,gn_bltptr(a1)$/
gn_bpw	BltPattern.asm	/^*			move.w	bm_BytesPerRow(a4),gn_bpw(a1)$/
gn_filln	BltPattern.asm	/^move.b	d0,gn_filln(a1)$/
gn_jstop	BltPattern.asm	/^move.w	d2,gn_jstop(a1)$/
h_Entry	BltPattern.asm	/^move.l	#rect_rtn,myhook+h_Entry(a7)$/
height	allocbitmap.asm	/^*	sizey = the height (in pixels) desired.$/
height_w	SimpleSprites.asm	/^move.w	d1,height_w(a7)$/
hrep_w	SimpleSprites.asm	/^	clr.w	hrep_w(a7)$/
if	BltClear.asm	/^*	bytecount - if (flags & 2) == 0 then$/
in	NewColorStuff.asm	/^*		rendered in (for instance, it will not examine /
intreq	QBlit.asm	/^move.w  #INTF_BLIT,intreq(a0)$/
it	GfxMem.asm	/^*	structures, if necessary, before freeing it (see/
jsr	LoadView.asm	/^	jsr	(a0)$/
l	AreaCircle.asm	/^move.l	(sp)+,a2$/
library/RemakeDispla	MakeVPort.asm	/^*	intuition.library\/RemakeDisplay() intuition.libr/
library/RethinkDispla	MrgCop.asm	/^*	intuition.library\/RethinkDisplay()$/
library/Wai	WaitTOF.asm	/^*	exec.library\/Wait() exec.library\/Signal()$/
list	CalcIVG.asm	/^*	Although there may be other copper instructions /
lr_SuperBitMap	cdraw.asm	/^if	lr_SuperBitMap(a5).l$/
lwmask	Draw.asm	/^move.w  d7,lwmask(a0)$/
makemask	MustMem.asm	/^* makemask() in c\/blitplate.c - now checks for NUL/
mask	LoadRGB4.asm	/^move.w	#$fff,d2	; mask (leave genlock bits alone)$/
min	SimpleSprites.asm	/^; srcwords=min(srcwords,wordwidth)$/
mode	BltClear.asm	/^*	mode (with the pre-ECS blitter) rows must be <- /
modes	NewColorStuff.asm	/^move.l	d0,d5					; d5=modes(vp)$/
modes_w	ScrollVPort.asm	/^move.w	d0,modes_w(a7)$/
myrect	BltPattern.asm	/^	movem.w	d0\/d1\/d2\/d3,myrect(a7)$/
needed	CalcIVG.asm	/^	asl.w	#1,d0		; total number of CopperCycles neede/
new_mode	ScrollVPort.asm	/^	WORDVAR	modes			; new_mode(vp)$/
now	SimpleSprites.asm	/^add.w	d2,d2			; now (a0,d2) points at copins$/
number	SetRGB4.asm	/^*       n - the color number (range from 0 to 31)$/
nv	InitArea.asm	/^	    asl.l   #2,d0                       * nv = nv/
of	InitArea.asm	/^*	such that it has a size of (max vectors ).  The /
ofs_closest_color	NewColorStuff.asm	/^	move.l	#-1,ofs_closest_color(a7)$/
ofs_closest_error	NewColorStuff.asm	/^move.l	d0,ofs_closest_error(a7)$/
ofs_colormask	NewColorStuff.asm	/^	move.l	d7,ofs_colormask(a7)$/
ofs_counter	NewColorStuff.asm	/^	subq.l	#1,ofs_counter(a7)$/
ofs_flags	NewColorStuff.asm	/^tst.l	ofs_flags(a7)$/
ofs_gbase	NewColorStuff.asm	/^	move.l	a6,ofs_gbase(a7)$/
ofs_jmpvector	NewColorStuff.asm	/^	move.l	a1,ofs_jmpvector(a7)$/
ofs_match_rgb	NewColorStuff.asm	/^movem.l	d1\/d2\/d3,ofs_match_rgb(a7)$/
ofs_realmax	NewColorStuff.asm	/^move.l	d6,ofs_realmax(a7)$/
old_data_flag_w	SimpleSprites.asm	/^clr.w	old_data_flag_w(a7)$/
or	SimpleSprites.asm	/^;   if  (vp->Modes & VP_HIDE)$/
pe_FirstFree	NewColorStuff.asm	/^	move.w	d1,pe_FirstFree(a3)$/
pe_FirstShared	NewColorStuff.asm	/^	move.w	#-1,pe_FirstShared(a3)$/
pe_NFree	NewColorStuff.asm	/^move.w	d1,pe_NFree(a3)$/
pe_NShared	NewColorStuff.asm	/^	subq.w	#1,pe_NShared(a2)$/
pe_RefCnt	NewColorStuff.asm	/^	move.l	a4,pe_RefCnt(a3)$/
pe_ViewPort	NewColorStuff.asm	/^move.l	a5,pe_ViewPort(a3)$/
planes	rpa8.asm	/^bra     plane_count ; do rest of planes (if any) $/
pointer	FreeColorMap.asm	/^*		  Passing a NULL pointer (meaning "do nothing")/
pokevp	LoadRGB4.asm	/^bsr	_pokevp			; pokevp(a0=vp,d0=regnum, d1=value, /
position	gasm.asm	/^*	v - vertical beam position (relative to top of v/
precision_l	NewColorStuff.asm	/^	clr.l	precision_l(a7)$/
pstart_w	SimpleSprites.asm	/^move.w	#bm_Planes+8,pstart_w(a7)$/
rastport	GetSet.asm	/^*       SetMaxPen -- set maximum pen value for a r/
rectangle	BltPattern.asm	/^*       Blit using drawmode,areafill pattern, and /
return	InitTmpRas.asm	/^    move.l  a0,d0           return(tmpras *)$/
ri_BitMap	NewColorStuff.asm	/^tst.l	ri_BitMap(a2)$/
rom	AttemptLockLayerRom.asm	/^*					 by rom(gfx lib) code$/
rp_AOLPen	GetSet.asm	/^move.b	d0,rp_AOLPen(a0)$/
rp_AreaPtSz	BltPattern.asm	/^if rp_AreaPtSz(a2)>=#0.b$/
rp_AreaPtrn	BltPattern.asm	/^tst.l	rp_AreaPtrn(a1)$/
rp_BgPen	SetAPen.asm	/^	move.b  d0,rp_BgPen(a1)             * w->BgPen = /
rp_BitMap	AreaEnd.asm	/^	move.l	a0,rp_BitMap(a1)			* newras.BitMap = &bitm/
rp_DrawMode	AreaEnd.asm	/^	move.b	#RP_COMPLEMENT,rp_DrawMode(a1)		* compleme/
rp_FgPen	InitRastPort.asm	/^    move.b  d0,rp_FgPen(a1)             * r->FgPen/
rp_Flags	AreaEnd.asm	/^	move.w	#ONE_DOT,rp_Flags(a1)		* Flags = ONE_DOT$/
rp_Layer	BltPattern.asm	/^	tst.l	rp_Layer(a1)$/
rp_LinePtrn	AreaEnd.asm	/^move.w	d0,rp_LinePtrn(a1)			* LinePtrs = -1$/
rp_Mask	AreaEnd.asm	/^	move.b	d0,rp_Mask(a1)				* writemask = -1$/
rp_cp_x	Draw.asm	/^movem.w d0\/d1,rp_cp_x(a1)   * new cp_x and cp_y$/
rp_cp_y	AreaEnd.asm	/^					if rp_cp_y(a1)<d1.w$/
rp_linpatcnt	Draw.asm	/^sub.b   d0,rp_linpatcnt(a1)$/
rp_minterms	AreaEnd.asm	/^	move.b	#NANBC+NABC+ANBC+ABNC,rp_minterms(a1)	* co/
sizeof	gasm.asm	/^*	Instead you must allocate a block MEMF_PUBLIC|ME/
space	GetColorMap.asm	/^; now, allocate space (zero filled) for low color /
sprite	SimpleSprites.asm	/^add.b	d5,d2			; 4 slots per sprite (from above)$/
spriteatt_l	SimpleSprites.asm	/^clr.l	spriteatt_l(a7)$/
spriteflags_w	SimpleSprites.asm	/^	clr.w	spriteflags_w(a7)$/
spritenum_w	SimpleSprites.asm	/^move.w	d1,spritenum_w(a7)$/
srcwords_w	SimpleSprites.asm	/^move.w	#1,srcwords_w(a7)$/
ss_height	SimpleSprites.asm	/^	move.w	height_w(a7),ss_height(a3)$/
ss_num	SimpleSprites.asm	/^	move.w	d0,ss_num(a2)$/
ss_posctldata	SimpleSprites.asm	/^	move.l  a2,ss_posctldata(a1)$/
ss_x	SimpleSprites.asm	/^	move.w	d0,ss_x(a1)$/
st	NewColorStuff.asm	/^	st	(a4)+$/
structure	GfxMem.asm	/^*       GfxNew -- allocate a graphics extended dat/
the	SetRGB4CM.asm	/^*	Store the (r,g,b) triplet at index n of the Colo/
to	Draw.asm	/^*       Draw a line from the current pen position /
tpt_x	vporigin.asm	/^	add.w	d0,tpt_x(a2)$/
tr_RasPtr	InitTmpRas.asm	/^    move.l  a1,tr_RasPtr(a0)$/
tstate_l	NewColorStuff.asm	/^	move.l	a1,tstate_l(a7)$/
v_DyOffset	InitView.asm	/^move.w  #$2c,v_DyOffset(a1)$/
view_y_w	ScrollVPort.asm	/^move.w	v_DyOffset(a0),view_y_w(a7)$/
viewport	changevpbitmap.asm	/^*	      of the same layout as the one attached to /
vp_ColorMap	LoadRGB4.asm	/^1$:	tst.l	vp_ColorMap(a0)$/
vp_SpritePriorities	InitVPort.asm	/^move.b	#$24,vp_SpritePriorities(a1)$/
vrep_w	SimpleSprites.asm	/^move.w	d1,vrep_w(a7)$/
vskip_l	SimpleSprites.asm	/^move.l	d1,vskip_l(a7)$/
w	AreaCircle.asm	/^		    movem.w	(sp)+,d0\/d1		* restore d0\/d1$/
waittof	WaitTOF.asm	/^* now downcoded from waittof() in waitbovp.c$/
width	allocbitmap.asm	/^*	sizex = the width (in pixels) desired for the bi/
wordwidth_w	SimpleSprites.asm	/^	move.w	#1,wordwidth_w(a7)$/
