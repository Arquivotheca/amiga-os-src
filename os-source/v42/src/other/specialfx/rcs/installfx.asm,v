head     39.10;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @* @;


39.10
date     93.09.14.18.51.50;  author spence;  state Exp;
branches ;
next     39.9;

39.9
date     93.09.13.19.00.00;  author spence;  state Exp;
branches ;
next     39.8;

39.8
date     93.09.02.18.19.16;  author spence;  state Exp;
branches ;
next     39.7;

39.7
date     93.07.19.11.46.50;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     93.07.06.18.34.13;  author spence;  state Exp;
branches ;
next     39.5;

39.5
date     93.07.02.17.19.45;  author spence;  state Exp;
branches ;
next     39.4;

39.4
date     93.06.30.13.42.36;  author spence;  state Exp;
branches ;
next     39.3;

39.3
date     93.05.10.17.46.39;  author spence;  state Exp;
branches ;
next     39.2;

39.2
date     93.04.23.18.02.03;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     93.03.17.12.10.48;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     93.03.12.19.13.16;  author spence;  state Exp;
branches ;
next     ;


desc
@Displays a taglist of effects
@


39.10
log
@Attempts to lock the AnimationSemaphore().
If unsuccesful, returns SFX_ERR_Animating as secondary error.
@
text
@********************************************************************************
*
*	$Id: InstallFX.asm,v 39.9 93/09/13 19:00:00 spence Exp Locker: spence $
*
********************************************************************************

	opt	p=68020
	section	code

	include	'exec/types.i'
	include	'exec/memory.i'
	include	'exec/ables.i'
	include	'graphics/view.i'
	include	'graphics/copper.i'
	include	'graphics/gfxbase.i'
	include	'utility/tagitem.i'

	include	"SpecialFXBase.i"
	include	"SpecialFX.i"
	include	"SpecialFX_internal.i"

	xdef	_LVOInstallFXA
	xdef	DoUCopStuff
	xref	_LVONextTagItem
	xref	_LVOFindTagItem
	xref	_LVOAllocMem
	xref	_LVOFreeMem
	xref	_LVOAttemptSemaphore
	xref	_LVOObtainSemaphore
	xref	_LVOReleaseSemaphore
	xref	_LVOPermit
	xref	_LVOFreeCopList
	xref	_LVOUCopperListInit

******* specialfx.library/InstallFXA *******************************************
*
*   NAME
*	InstallFXA -- Installs the initial settings of the Effect
*	InstallFX -- varargs stub for InstallFXA()
*
*   SYNOPSIS
*	DisplayHandle = InstallFXA(View, ViewPort, TagItems)
*	d0                         a0    a1        a2
*
*	APTR InstallFXA(struct View *, struct ViewPort *,
*	                APTR *, struct TagItem *);
*
*	DisplayHandle = InstallFX(View, ViewPort, Tag1, ...)
*
*	APTR InstallFX(struct View *, struct ViewPort *, ULONG, ...);
*
*   FUNCTION
*	To install the intial settings of the list of special effects in the
*	ViewPort.
*
*   INPUTS
*	View          - The View of the display
*	ViewPort      - The ViewPort of the display
*	TagItems      - A pointer to an array of SFX_ tags.
*
*   TAGS
*	SFX_InstallEffect - ti_Data is an FXHandle obtained from AllocFX()
*
*	SFX_InstallErrorCode - ti_Data points to a ULONG that will contain
*	                       an error code if DisplayHandle is NULL.
*
*   RESULT
*	DisplayHandle - a DisplayHandle if succesful, else NULL, in which case
*	                the ULONG pointed to by SFX_InstallErrorCode
*	                (if used) will contain an error number.
*	                DisplayHandle will be passed to AnimateFX() for
*	                animating the display.
*
*   NOTES
*	After calling InstallFXA(), you should remake the display, either
*	with intuition's MakeScreen()/RethinkDisplay() if using intuition
*	screens, or with graphics' MakeVPort()/MrgCop()/LoadView() if using
*	a custom View and ViewPort.
*
*	This function will not work with a UserCopperList. Either use
*	a UserCopperList for your own tricks, or use specialfx.library, but
*	do not mix-and-match.
*
*   SEE ALSO
*	<libraries/specialfx.h> AllocFX() AnimateFX() RemoveFX()
*
********************************************************************************

_LVOInstallFXA:
	movem.l	d2-d7/a2-a6,-(sp)
	; Save some info on the stack
	sub.l	#FRAME_SIZE,sp
	move.l	sp,a5
	clr.l	stk_ErrorCode(a5)
	move.l	a6,stk_SpecialFXBase(a5)
	move.l	a2,stk_TagPtr(a5)
	movem.l	a0-a1,stk_View(a5)	; save View and ViewPort

	; see if another task is animating
	move.l	a6,a4
	move.l	sfxb_AnimationSemaphore(a4),a0
	move.l	sfxb_ExecBase(a6),a6
	jsr	_LVOAttemptSemaphore(a6)
	move.l	a4,a6
	tst.l	d0
	beq	lock_error

	; ensure the ViewPort is not remade during the operation
	move.l	a6,a4
	move.l	sfxb_GfxBase(a6),a0
	move.l	gb_ActiViewCprSemaphore(a0),a0
	move.l	sfxb_ExecBase(a6),a6
	jsr	_LVOObtainSemaphore(a6)
	move.l	a4,a6

	; **********************************************************************
	;
	; Each SpecialEffect needs its own UserCopperList, so iterate
	; through the taglist and allocate a UCopList for each tag. If
	; any allocation fails, then they must all be freed.
	;
	; **********************************************************************
* {

	moveq	#0,d5			; d5 will count the number of tag items
	move.l	d5,d7			; bit 31 is set to disable copper dbuffering
	move.l	sfxb_GfxBase(a6),a4
	move.l	sfxb_UtilityBase(a6),a6
	move.l	vp_UCopIns(a1),d2	; store the original UCopIns pointer
	lea	stk_TagPtr(a5),a3
calc_loop:
	move.l	a3,a0
	jsr	_LVONextTagItem(a6)
	tst.l	d0
	beq.s	tags_done
	move.l	d0,a0
	move.l	ti_Tag(a0),d0
	and.l	#~$80001000,d0
	bne.s	1$
	; must be SFX_InstallEffect
	move.l	ti_Data(a0),d0
	beq.s	calc_loop
	move.l	d0,a0			; a0 -> FxHandle from AllocFX(). The 
					; FxHandle structure is *before* this
					; pointer
	move.l	ToFXHandle(a0),a0	; BackPointer
	move.l	fxh_Type(a0),d0
	and.l	#~$80000000,d0
	add.w	d0,d0
	add.w	d0,d0
	move.l	stk_SpecialFXBase(a5),a1
	move.l	sfxb_CountVectors(a1),a1
	move.l	-4(a1,d0),a1
	jsr	(a1)
	addq.l	#1,d5
	bra.s	calc_loop
1$:
	subq.w	#1,d0
	bne.s	install_dbuff
	; must be SFX_InstallErrorCode
	move.l	ti_Data(a0),stk_ErrorCode(a5)	; for error passing
	bra.s	calc_loop
install_dbuff:
	; is SFX_DoubleBuffer
	move.l	ti_Data(a0),d7
	beq.s	calc_loop		; if FALSE, set d7 to 0,
	moveq	#-1,d7			; else set d7 to -1
	bra.s	calc_loop

* 	{
tags_done:
	move.l	a2,stk_TagPtr(a5)	; restore

	; allocate the RAM for the AnimHandle
	moveq	#AnimHandle_SIZEOF,d0
	move.l	d5,a2			; safe keeping
	asl.l	#2,d5
	add.l	d5,d0			; 4 bytes per SFX handle
	move.l	d0,d5
	move.l	#(MEMF_PUBLIC|MEMF_CLEAR),d1
	move.l	gb_ExecBase(a4),a6
	jsr	_LVOAllocMem(a6)
	tst.l	d0
	beq	FAILURE_0
	move.l	d0,a3
	add.l	#AnimHandle_SIZEOF,d0
	move.l	d0,stk_DispHandle(a5)	; Points to the list of FXHandles
	beq	FAILURE_0
	move.l	stk_View(a5),ah_View(a3)
	move.l	stk_ViewPort(a5),ah_ViewPort(a3)
	move.l	d5,ah_HandleSize(a3)
	move.l	a2,ah_HandleCount(a3)
	tst.l	d7
	bmi.s	1$
	or.w	#AHF_NODBUFF,ah_Flags(a3)
1$:

	; checkpoint
	; a3 -> AnimHandle
	; a4 -> GfxBase
	; a5 -> stack frame
	; a6 -> ExecBase

	; Look through the DspIns for the last bplcon3 value.
	moveq	#0,d2			; store bplcon3 here
	move.l	stk_ViewPort(a5),a0
	move.l	vp_DspIns(a0),d0
	beq.s	got_con3
	move.l	d0,a0
	move.w	cl_Count(a0),d7
	move.l	cl_CopIns(a0),d0
	beq.s	got_con3
	move.l	d0,a0
	move.w	#(BPLCON3&$fff),d3
	bra.s	get_bplcon3.
get_bplcon3:
	move.w	(a0)+,d0		; opcode
	move.l	(a0)+,d1		; address and data
	cmp.b	#0,d0
	bne.s	get_bplcon3.
	swap	d1
	cmp.w	d3,d1
	bne.s	get_bplcon3.		; not a MOVE
	swap	d1
	move.w	d1,d2			; store the bplcon3
get_bplcon3.:
	dbra.s	d7,get_bplcon3
	and.w	#%0001110111111111,d2	; save the bits of bplcon3 we don't want to touch
got_con3:
	move.w	d2,stk_BPLCON3(a5)

	; now walk through the taglist again, and build the copperlist
	move.l	gb_UtilBase(a4),a6
	lea	stk_TagPtr(a5),a0
	movem.l	a0/a6,-(sp)
build_loop:
	movem.l	(sp),a0/a6
	jsr	_LVONextTagItem(a6)
	tst.l	d0
	beq.s	tags_done2
	move.l	d0,a0
	move.l	ti_Tag(a0),d0
	and.l	#~$80001000,d0
	bne.s	build_loop
	; must be SFX_InstallEffect
	move.l	ti_Data(a0),d0
	beq	calc_loop
	move.l	d0,a0			; a0 -> FxHandle from AllocFX(). The 
					; FxHandle structure is *before* this
					; pointer
	move.l	ToFXHandle(a0),a0	; BackPointer
	move.l	fxh_Type(a0),d0
	and.l	#~$80000000,d0
	add.w	d0,d0
	add.w	d0,d0
	move.l	stk_SpecialFXBase(a5),a1
	move.l	sfxb_InstallVectors(a1),a1
	move.l	-4(a1,d0),a1
	jsr	(a1)
	bra.s	build_loop

tags_done2:
*	}

	; now store this AnimHandle in our list.
	; a3 has the AnimHandle.

	; first, get the Semaphore
	move.l	stk_SpecialFXBase(a5),a4
	move.l	sfxb_ExecBase(a4),a6
	move.l	sfxb_AHListSemaphore(a4),a0
	jsr	_LVOObtainSemaphore(a6)
	lea	sfxb_AHList(a4),a0
search_ahlist:
	move.w	ahl_Count(a0),d0
	cmp.w	#MAX_AHLIST,d0
	beq.s	nxt_ahlist_chk
	addq.w	#1,d0
	move.w	d0,ahl_Count(a0)
	lea	ahl_AnimHandles(a0),a1
10$:
	tst.l	(a1)+
	bne.s	10$
	move.l	a3,-4(a1)

	move.l	sfxb_AHListSemaphore(a4),a0
	jsr	_LVOReleaseSemaphore(a6)

	moveq	#0,d0
	addq.l	#8,sp			; a0/a6
_InstallFXA.:
	; release the semaphore
	move.l	d0,d2
	move.l	stk_SpecialFXBase(a5),a6
	move.l	sfxb_GfxBase(a6),a0
	move.l	gb_ActiViewCprSemaphore(a0),a0
	move.l	sfxb_ExecBase(a6),a6
	jsr	_LVOReleaseSemaphore(a6)
ret_err:
	move.l	stk_ErrorCode(a5),d0
	beq.s	1$
	move.l	d0,a0
	move.l	d2,(a0)			; store the error code
1$:

	move.l	a3,d0			; return the AnimHandle
clean_up:
	add.l	#FRAME_SIZE,sp
	movem.l	(sp)+,a2-a6/d2-d7
	rts

nxt_ahlist_chk:
	move.l	MLN_SUCC(a0),a0
	tst.l	MLN_SUCC(a0)	; end of the list
	bne.s	search_ahlist
new_ahlist:
	moveq	#ahl_SIZEOF,d0
	move.l	#(MEMF_CLEAR+MEMF_PUBLIC),d1	
	move.l	sfxb_ExecBase(a4),a6
	jsr	_LVOAllocMem(a6)
	move.l	d0,d2
	beq.s	NO_AHLIST_ERR
	move.l	d0,a1
	lea	sfxb_AHListHead(a4),a0
	ADDHEAD	a0,a1
	move.l	d2,a0
	bra	search_ahlist

NO_AHLIST_ERR:
	; Low on memory, so we need to undo all the UCopList stuff
	; NYI!!
	bra.s	_InstallFXA.

; If the AnimationSemaphore is already locked, return an error SFX_ERR_Animating.
lock_error:
	; Look for a SFX_InstallErrorCode
	move.l	sfxb_UtilityBase(a6),a6
	move.l	#SFX_InstallErrorCode,d0
	move.l	a2,a0
	jsr	_LVOFindTagItem(a6)
	tst.l	d0
	beq.s	clean_up
	move.l	d0,a0
	move.l	ti_Data(a0),stk_ErrorCode(a5)
	move.l	#SFX_ERR_Animating,d2
	sub.l	a3,a3
	bra.s	ret_err
* }

********************************************************************************
********************************************************************************
* {
* DoUCopStuff - allocates a UCopList, and links it in with the rest.
*
* Takes - d1 = copper instructions
*	  d2 -> Original UCopIns in the ViewPort in case of error.
*	  a0 -> FXHandle
*	  a4 -> GfxBase
*	  a5 -> Stk frame
*	  a6 -> UtilityBase
*
* Trashes d3,d4
*

DoUCopStuff:
	; now allocate a UserCopperlist
	move.l	d1,d3
	move.l	a0,d4
	moveq	#ucl_SIZEOF,d0
	move.l	#(MEMF_CLEAR|MEMF_PUBLIC),d1
	exg	a4,a6
	move.l	a6,-(sp)
	move.l	gb_ExecBase(a6),a6
	jsr	_LVOAllocMem(a6)
	move.l	(sp)+,a6
	tst.l	d0
	beq.s	FAILURE_1
	move.l	d0,a0
	move.l	d4,a1
	move.l	d0,fxh_UCopList(a1)
	move.l	d0,d4
	move.l	d3,d0
	jsr	_LVOUCopperListInit(a6)
	exg	a4,a6
	tst.l	d0
	beq.s	FAILURE_2
	; link this UCopList into the list in the ViewPort
	move.l	stk_ViewPort(a5),a0
	move.l	d4,a1
	move.l	vp_UCopIns(a0),ucl_Next(a1)
	move.l	a1,vp_UCopIns(a0)
	rts

* }
********************************************************************************


FAILURE_2:
	; free the UCopList
	move.l	stk_SpecialFXBase(a5),a6
	move.l	sfxb_ExecBase(a6),a6
	move.l	a2,a1
	moveq	#ucl_SIZEOF,d0
	jsr	_LVOFreeMem(a6)
FAILURE_1:
	; free all the other UCopLists. d2 -> original UCopList, so we know where
	; to stop.
	addq.l	#4,sp			; remove the rts from DoUCopstuff()
	move.l	stk_SpecialFXBase(a5),a6
	move.l	sfxb_ExecBase(a6),a4
	move.l	sfxb_GfxBase(a6),a6
	move.l	stk_ViewPort(a5),a2
	move.l	vp_UCopIns(a2),d3
1$:
	cmp.l	d3,d2
	beq.s	FAILURE_0
	move.l	d3,a0
	move.l	ucl_FirstCopList(a0),a0
	jsr	_LVOFreeCopList(a6)
	exg	a4,a6
	move.l	d3,a1
	move.l	ucl_Next(a1),d3
	moveq	#ucl_SIZEOF,d0
	jsr	_LVOFreeMem(a6)
	exg	a4,a6
	bra.s	1$

FAILURE_0:
	; not enough memory
	moveq	#SFX_ERR_NoMem,d0
	bra	_InstallFXA.

	end
@


39.9
log
@Added copper double buffering
@
text
@d3 1
a3 1
*	$Id: InstallFX.asm,v 39.8 93/09/02 18:19:16 spence Exp Locker: spence $
d25 1
d28 1
d99 9
d299 1
d307 1
d334 14
@


39.8
log
@Autodoc chante
@
text
@d3 1
a3 1
*	$Id: InstallFX.asm,v 39.7 93/07/19 11:46:50 spence Exp Locker: spence $
d115 1
d148 1
a148 1
	bne.s	calc_loop		; unkown
d152 6
d182 4
a251 1
	; put the CopList in the UCopIns
d254 24
d293 1
d298 23
@


39.7
log
@Autodoc cleanup
@
text
@d3 1
a3 1
*	$Id: InstallFX.asm,v 39.6 93/07/06 18:34:13 spence Exp Locker: spence $
d83 1
a83 1
*	<specialfx/specialfx.h> AllocFX() AnimateFX() RemoveFX()
@


39.6
log
@Calls the vectors through the table off SpecialFXBase
@
text
@d3 1
a3 1
*	$Id: InstallFX.asm,v 39.5 93/07/02 17:19:45 spence Exp Locker: spence $
d33 1
a33 1
******* SpecialFX.library/InstallFXA *******************************************
d79 1
a79 1
*	a UserCopperList for your own tricks, or use SpecialFX.library, but
d83 1
a83 1
*	<SpecialFX/SpecialFX.h> AllocFX() AnimateFX() RemoveFX()
@


39.5
log
@DisplayFX -> renamed to InstallFX
FXHandle returned points to an array of pointers to the
Effects structure. The real FXHandle is at a -ve offset
from this.
@
text
@d3 1
a3 1
*	$Id: InstallFX.asm,v 39.4 93/06/30 13:42:36 spence Exp Locker: spence $
a32 7
	xref	CountColours
	xref	CountScrollLines
	xref	CountIntControl
	xref	InstallColours
	xref	DisplayScrollLines	; <<< CHANGE THIS!!
	xref	InstallIntControl

a86 29
* Table of pointers to functions to count the number of copper instructions
* needed by each tag type. Each function allocates the UCopList and adds it
* to the ViewPort.
*
* Each function takes:
* a0 -> FxHandle
* a4 -> GfxBase
* a5 -> StackStuff
* a6 -> UtilityBase

CountTable:
	dc.l	CountColours
	dc.l	CountScrollLines
	dc.l	CountIntControl

* Table of pointers to functions to build the UserCopperlists for each
* tag type.
*
* Each function takes:
* a0 -> FxHandle
* a4 -> GfxBase
* a5 -> StackStuff
* a6 -> UtilityBase

InstallTable:
	dc.l	InstallColours
	dc.l	DisplayScrollLines		; <<< CHANGE THIS
	dc.l	InstallIntControl

d139 2
a140 1
	lea	CountTable(pc),a1
d234 2
a235 1
	lea	InstallTable(pc),a1
@


39.4
log
@CountIntControl and DisplayIntControl added to the lists.
@
text
@d3 1
a3 1
*	$Id: DisplayFX.asm,v 39.3 93/05/10 17:46:39 spence Exp Locker: spence $
d22 1
a22 1
	xdef	_LVODisplayFXA
d36 3
a38 3
	xref	DisplayColours
	xref	DisplayScrollLines
	xref	DisplayIntControl
d40 1
a40 1
******* SpecialFX.library/DisplayFXA *******************************************
d43 2
a44 2
*	DisplayFXA -- Displays the initial settings of the Effect
*	DisplayFX -- varargs stub for DisplayFXA()
d47 2
a48 2
*	error = DisplayFXA(View, ViewPort, DisplayHandle, TagItems)
*	d0                 a0    a1        a2             a3
d50 2
a51 2
*	ULONG DisplayFXA(struct View *, struct ViewPort *,
*	                 APTR *, struct TagItem *);
d53 1
a53 1
*	error = DisplayFX(View, ViewPort, DisplayHandle, Tag1, ...)
d55 1
a55 1
*	ULONG DisplayFX(struct View *, struct ViewPort *, APTR *, ULONG, ...);
d58 2
a59 1
*	To display the intial settings of the list of special effects.
a63 1
*	DisplayHandle - A pointer to an APTR
a65 1
*
d67 1
a67 3
*	SFX_ColourRange - Builds a copperlist to alter the colour of
*	                  specified pens at specified lines, in the maximum
*	                  possible colourspace of the chip set.
d69 2
a70 11
*	SFX_ScrollLines - Builds a copperlist to scroll a group of lines
*	                  horizontally, independant from the rest of the
*	                  ViewPort.
*
*	SFX_IntControl  - Builds a copperlist to cause an interrupt at the
*	                  specified line. Note that in order to minimise
*	                  extra interrupts being enabled when the last
*	                  SFX_IntControl is removed, you should add the
*	                  interrupt server with exec.library/AddIntServer()
*	                  after calling DisplayFXA(), and before remaking
*	                  the display.
d73 5
a77 4
*	error - 0 if succesful, else an error number, as defined in
*	        <SpecialFX/SpecialFX.h>
*	*DisplayHandle is initialised, and should be passed to AnimateFXA()
*	and RemoveFXA().
d80 1
a80 1
*	After calling DisplayFXA(), you should remake the display, either
d90 1
a90 1
*	<SpecialFX/SpecialFX.h> AnimateFX() RemoveFX()
d95 2
a96 1
* needed by each tag type.
d99 1
a99 1
* a0 -> this TagItem
d113 1
a113 1
* a0 -> this TagItem
d118 4
a121 4
DisplayTable:
	dc.l	DisplayColours
	dc.l	DisplayScrollLines
	dc.l	DisplayIntControl
d123 1
a123 2
_MyDisplayFXA::
_LVODisplayFXA:
d128 1
d130 1
a130 2
	move.l	a2,stk_DispHandle(a5)
	move.l	a3,stk_TagPtr(a5)
a150 1
	move.l	a3,a2
d162 10
d180 6
d200 2
a201 2
	move.l	stk_DispHandle(a5),a3
	move.l	d0,(a3)			; put it in the handle pointer
d203 2
a209 2
	lea	AnimHandle_SIZEOF(a3),a3
	move.l	a3,stk_DispHandle(a5)
d212 1
d256 10
d269 1
a269 1
	lea	DisplayTable(pc),a1
d280 1
a280 1
_DisplayFXA.:
d288 6
a293 1
	move.l	d2,d0
d380 1
a380 1
	bra	_DisplayFXA.
@


39.3
log
@Moved ColourRange and ScrollLines code to separate files.
Now calls each through a LUT.
@
text
@d3 1
a3 1
*	$Id: DisplayFX.asm,v 39.2 93/04/23 18:02:03 spence Exp Locker: spence $
d35 1
d38 1
d76 8
d117 1
d131 1
@


39.2
log
@ScrollLines implementation
@
text
@d3 1
a3 1
*	$Id: DisplayFX.asm,v 39.1 93/03/17 12:10:48 spence Exp Locker: spence $
a9 35
BPLCON3	equ	$dff106
COLOUR0	equ	$dff180
BPLMOD0	equ	$dff108
BPLMOD1	equ	$dff10a
BPLCON1	equ	$dff102
DDFSTRT equ	$dff092
FMODE	equ	$dff1fc
BPL1PTH	equ	$dff0e0
BPL2PTH	equ	$dff0e4

CMOVE	MACRO	;reg,value
	movem.l	d0/d1,-(sp)
	move.l	a2,a1			; a2 -> UCopList
	move.l	\1,d0
	move.l	\2,d1
	jsr	_LVOCMove(a6)
	move.l	a2,a1
	jsr	_LVOCBump(a6)
	movem.l	(sp)+,d0/d1
	ENDM

ABSW	MACRO	; reg
	tst.w	\1
	bpl.s	a\@@
	neg.w	\1
a\@@:
	ENDM

ABSL	MACRO	; reg
	tst.l	\1
	bpl.s	b\@@
	neg.l	\1
b\@@:
	ENDM

d23 1
a29 4
	xref	_LVOMakeVPort
	xref	_LVOMrgCop
	xref	_LVOLoadView
	xref	_LVOScrollVPort
a30 1
	xref	_LVOGetRGB32
d32 5
a36 3
	xref	_LVOCWait
	xref	_LVOCMove
	xref	_LVOCBump
d95 27
d163 6
a168 4
	subq.w	#1,d0
	beq	count_colours
	subq.w	#1,d0
	beq	count_scrolllines
d240 5
a244 4
	subq.w	#1,d0
	beq	DisplayColours
	subq.w	#1,d0
	beq	DisplayScrollLines
a267 993
* {
	; **********************************************************************
	;
	; Count the number of copper instructions needed for the ColorRange
	;
	; **********************************************************************

count_colours:
	addq.l	#1,d5
	move.l	ti_Data(a0),a0
	moveq	#0,d0			; d0 will count the WAITs
	move.l	d0,d1
	move.w	fxh_Num(a0),d7
	beq	calc_loop		; early sanity check
	move.w	d7,d1			; d1 will count the colours
	move.l	fxh_First(a0),a1
	subq.w	#1,d7
	move.w	cor_WAIT_Y(a1),d6
	addq.w	#1,d6
count_colours_loop:
	move.w	cor_WAIT_Y(a1),d3
	cmp.w	d3,d6
	beq.s	chk_restore
	addq.w	#1,d0			; one more WAIT
	move.w	d3,d6
chk_restore:
	btst.b	#CORB_RESTORE,cor_Flags+3(a1)
	beq.s	count_colours_loop.
	addq.w	#1,d1
	addq.w	#1,d0			; possibly one more WAIT
count_colours_loop.:
	lea	CorPrivate_SIZE(a1),a1
	dbra.s	d7,count_colours_loop
	btst.b	#GFXB_AA_LISA,gb_ChipRevBits0(a4)
	beq.s	1$
	; for AA, need 2 colour instructions, and 2 bplcon3 instructions per line
	asl.l	#2,d1
1$:
	add.l	d0,d1			; add the WAITs
	addq.w	#2,d1			; terminator

count_get_ucop:
	bsr	DoUCopStuff
	bra	calc_loop

* }
********************************************************************************
* {	
	; **********************************************************************
	;
	; This code will build the UserCopperList to display the colours of
	; this set.
	;
	; **********************************************************************

	; enters with:
	; a0 -> TagItem
	; a4 -> GfxBase
	; a5 -> Stack frame
	; a6 -> UtilityBase

DisplayColours:
	move.l	a4,a6
	move.l	ti_Data(a0),a4
	move.l	stk_DispHandle(a5),a3
	move.l	a4,(a3)+		; store the FxHandle in the AnimHandle
	move.l	a3,stk_DispHandle(a5)
	move.l	fxh_UCopList(a4),a2	; use a2 -> UCopList
	move.w	fxh_Num(a4),d4
	subq.w	#1,d4
	bcs	build_loop		; early sanity check
	move.l	fxh_First(a4),a4
	moveq	#0,d7
	move.w	cor_WAIT_Y(a4),d7	; d7 will store the current WAIT value
	addq.w	#1,d7			; (prime for 1st time through)
loop_array1:
	swap	d4
	moveq	#0,d5			; d5 = -1 to restore
loop_array:
	btst.b	#CORB_RESTORE,cor_Flags+3(a4)
	beq.s	1$
	move.l	stk_ViewPort(a5),a0
	move.l	vp_ColorMap(a0),a0
	move.l	cor_Pen(a4),d0
	moveq	#1,d1
	lea	Red32_orig(a4),a1
	jsr	_LVOGetRGB32(a6)
	moveq	#-1,d5
	clr.w	d5			; d5 = 0xffff0000 to show repeat this entry,
					; d5 = 0x00008000 to show use the cached values

1$:
	; build the private copper list cache
	move.l	#COLOUR0,a3
	move.w	#(BPLCON3&$1fe),d6
	swap	d6
	move.w	cor_Pen+2(a4),d6
	move.w	d6,d4
	and.w	#31,d6
	add.w	d6,d6
	add.w	d6,a3			; a3 = colour register address
	move.w	d4,d6			; calculate the colour bank number
	and.w	#~31,d6
	asl.w	#8,d6
	or.w	stk_BPLCON3(a5),d6	; store together
	move.l	d6,con3_hi(a4)
	or.w	#$0200,d6
	move.l	d6,con3_lo(a4)
	and.l	#$ffff,d6

build_colours:
	move.w	cor_WAIT_Y(a4),d0
	cmp.w	d0,d7
	beq.s	same_line
	move.w	d0,d7			; the line number
restore_colour:
	bset.l	#31,d7
same_line:
	moveq	#-2,d0
	swap	d0
	move.w	d7,d0			; build the WAIT
	asl.w	#8,d0
	or.w	#1,d0
	swap	d0
	move.l	d0,Wait(a4)
100$:
	; build the colour registers
	move.b	cor_Blue(a4),d0
	move.b	d0,d2
	swap	d2
	move.b	d0,d2
	move.w	cor_Red(a4),d0
	move.b	cor_Green(a4),d1
	tst.w	d5
	bpl.s	10$
	move.b	Blue32_orig(a4),d0
	move.b	d0,d2
	swap	d2
	move.b	d0,d2
	move.w	Red32_orig(a4),d0
	move.b	Green32_orig(a4),d1
10$:
	moveq	#0,d3
	move.w	d0,d3
	and.w	#$0f00,d3
	move.b	d1,d3
	asl.b	#4,d3
	and.b	#$f,d2
	or.b	d2,d3
	swap	d3
	move.w	d0,d3
	lsr.w	#4,d3
	move.b	d1,d3
	and.b	#$f0,d3
	swap	d2
	lsr.b	#4,d2
	or.b	d2,d3
	move.w	d3,d0
	swap	d0
	move.w	a3,d0
	and.w	#$01fe,d0
	swap	d0
	move.w	d0,d2
	tst.w	d5
	bmi.s	101$
	move.l	d0,pen_hi(a4)
101$:
	move.l	d3,d0
	move.w	a3,d0
	and.w	#$01fe,d0
	swap	d0
	move.w	d0,d1
	tst.w	d5
	bmi.s	102$
	move.l	d0,pen_lo(a4)
102$:
	; now build the copper list
	tst.l	d7			; do we need the WAIT?
	bpl.s	3$
	move.l	a2,a1
	moveq	#0,d0
	move.w	d7,d0
	move.l	d1,-(sp)
	moveq	#0,d1
	jsr	_LVOCWait(a6)
	move.l	a2,a1
	jsr	_LVOCBump(a6)
	move.l	(sp)+,d1
	bclr.l	#31,d7
3$:
	btst.b	#GFXB_AA_LISA,gb_ChipRevBits0(a6)
	beq.s	4$
	and.w	#~$0200,d6		; Hi bits
	CMOVE	#BPLCON3,d6
4$:

	CMOVE	a3,d2			; Hi Colours
	btst.b	#GFXB_AA_LISA,gb_ChipRevBits0(a6)
	beq.s	2$
	or.w	#$0200,d6		; Lo bits
	CMOVE	#BPLCON3,d6
	CMOVE	a3,d1			; Lo colours
2$:

	; done that one. Do we need to restore the pen?
	tst.l	d5
	bpl.s	next_colour
	move.l	#$8000,d5
	addq.w	#1,d7
	bra	restore_colour
next_colour:
	lea	CorPrivate_SIZE(a4),a4
	swap	d4
	dbra	d4,loop_array1

end_colours:
	move.l	#10000,d0
	move.l	#255,d1
	move.l	a2,a1
	jsr	_LVOCWait(a6)		; CEND
	move.l	a2,a1
	jsr	_LVOCBump(a6)

	bra	build_loop
* }
********************************************************************************
********************************************************************************
* {
	; **********************************************************************
	;
	; Count the number of copper instructions needed for the ScrollLines
	;
	; **********************************************************************

	;
	; For each ScrollLine case, we need the following copperlist:
	; WAIT (sl_YOffset-1, 0)		; LINE 1
	; MOVE BPLMOD0,xxx	; set start of next line correctly
	; MOVE BPLMOD1,xxx
	; WAIT (sl_YOffset, 0)			; LINE 2
	; MOVE BPLMOD0,xxx	; align next sl_YCount lines up
	; MOVE BPLMOD1,xxx
	; MOVE DDFSTRT,xxx
	; MOVE BPLCON1,xxx
	; MOVE FMODE,xxx	; (only on AA)
	; WAIT (sl_YOffset+sl_YCount-1, 0)	; LINE 3
	; MOVE BPLMOD0,xxx	; set start of next line correctly
	; MOVE BPLMOD1,xxx
	; WAIT (sl_YOffset+sl_YCount, 0)	; LINE 4
	; MOVE BPLMOD0,xxx	; align next sl_YCount lines up
	; MOVE BPLMOD1,xxx
	; MOVE DDFSTRT,xxx
	; MOVE BPLCON1,xxx
	; MOVE FMODE,xxx	; (only on AA)
	;
	; There are times when some of these LINEs are not needed. These
	; are defined in the following LUT:

LINE_1_INS	equ	3
LINE_2AA_INS	equ	6
LINE_2ECS_INS	equ	5
LINE_3_INS	equ	3
LINE_4AA_INS	equ	6
LINE_4ECS_INS	equ	5

; The tables take on the form:
; Previous Scroll 1 line away:  Next 1 line away, Next 2 lines away, Next 3> lines away
; Previous Scroll 2 lines away: Next 1 line away, Next 2 lines away, Next 3> lines away

; If only scrolling 1 line, the copper instructions are:
AAScroll1Line:
	dc.w	LINE_2AA_INS,(LINE_2AA_INS+LINE_4AA_INS),(LINE_2AA_INS+LINE_4AA_INS)
	dc.w	(LINE_1_INS+LINE_2AA_INS),(LINE_1_INS+LINE_2AA_INS+LINE_4AA_INS),(LINE_1_INS+LINE_2AA_INS+LINE_4AA_INS)
ScrollLineTableSize	equ	*-AAScroll1Line
; If scrolling 2 or more lines:
AAScroll2Lines:
	dc.w	(LINE_2AA_INS+LINE_3_INS),(LINE_2AA_INS+LINE_3_INS+LINE_4AA_INS),(LINE_2AA_INS+LINE_3_INS+LINE_4AA_INS)
	dc.w	(LINE_1_INS+LINE_2AA_INS+LINE_3_INS),(LINE_1_INS+LINE_2AA_INS+LINE_3_INS+LINE_4AA_INS),(LINE_1_INS+LINE_2AA_INS+LINE_3_INS+LINE_4AA_INS)

ECSScroll1Line:
	dc.w	LINE_2ECS_INS,(LINE_2ECS_INS+LINE_4ECS_INS),(LINE_2ECS_INS+LINE_4ECS_INS)
	dc.w	(LINE_1_INS+LINE_2ECS_INS),(LINE_1_INS+LINE_2ECS_INS+LINE_4ECS_INS),(LINE_1_INS+LINE_2ECS_INS+LINE_4ECS_INS)
ECSScroll2Lines:
	dc.w	(LINE_2ECS_INS+LINE_3_INS),(LINE_2ECS_INS+LINE_3_INS+LINE_4ECS_INS),(LINE_2ECS_INS+LINE_3_INS+LINE_4ECS_INS)
	dc.w	(LINE_1_INS+LINE_2ECS_INS+LINE_3_INS),(LINE_1_INS+LINE_2ECS_INS+LINE_3_INS+LINE_4ECS_INS),(LINE_1_INS+LINE_2ECS_INS+LINE_3_INS+LINE_4ECS_INS)

count_scrolllines:
	addq.l	#1,d5
	move.l	ti_Data(a0),a0		; get the FXHandle
	moveq	#0,d1			; d1 will count the instructions
	move.w	fxh_Num(a0),d7
	beq	calc_loop		; early sanity check
	moveq	#0,d4			; use d4 to divide by 2 for lace
	move.l	stk_ViewPort(a5),a1
	btst.b	#2,vp_Modes+1(a1)	; laced?
	beq.s	4$
	moveq	#1,d4
4$:
	move.l	fxh_First(a0),a1	; First ScrollLines structure
	subq.w	#1,d7
	move.w	sl_YOffset(a1),d6
	movem.l	d5/a3,-(sp)	
	lea	AAScroll1Line(pc),a3
	btst.b	#GFXB_AA_LISA,gb_ChipRevBits0(a4)
	bne.s	1$
	lea	ECSScroll1Line(pc),a3
1$:
	; What type is the first ScrollLine?
	; We know it is >1 line from the previous ScrollLine.
	; If there is another in the list, how far is it from there?
	moveq	#0,d5
	move.l	d5,d3
	tst.w	d7
	beq.s	20$
	move.w	sclPrivate_SIZEOF+sl_YOffset(a1),d0
	sub.w	d6,d0
	sub.w	sl_YCount(a1),d0
	asr.w	d4,d0
	beq.s	2$
	moveq	#NEXT_SL_2,d5
	subq.w	#1,d0
	beq.s	2$
20$:
	moveq	#NEXT_SL_3G,d5
2$:
	addq.w	#PREV_SL_2,d5
	move.w	d5,sclp_Type(a1)

	move.w	sl_YCount(a1),d0
	asr.w	d4,d0
	cmp.w	#1,d0
	beq.s	3$
	add.w	#ScrollLineTableSize,d5
3$:
	add.w	0(a3,d5.w),d1		; This many copper instructions for the first ScrollLines.
	tst.w	d7
	beq.s	sl_counted		; no more to do.

	bra.s	count_sl_loop.
count_sl_loop:
	move.w	d6,d3
	add.w	sl_YCount(a1),d3	; d3 is where the last ScrollLines finished
	lea	sclPrivate_SIZEOF(a1),a1
	move.w	sl_YOffset(a1),d6
	; What type is this one? How far is it from the last? How far is it to the next?
	moveq	#0,d5
	move.w	d6,d0
	sub.w	d3,d0			; how far from the previous?
	asr.w	d4,d0
	cmp.w	#1,d0
	ble.s	1$
	moveq	#PREV_SL_2,d5
1$:
	tst.w	d7
	bne.s	3$
	addq.w	#NEXT_SL_3G,d5
	bra.s	2$
3$:
	move.w	d6,d0
	add.w	sl_YCount(a1),d0
	move.w	sclPrivate_SIZEOF+sl_YOffset(a1),d2
	sub.w	d0,d2
	asr.w	d4,d2
	subq.w	#1,d2
	beq.s	2$			; next is only 1 away
	addq.w	#2,d5
	subq.w	#1,d2
	beq.s	2$			; next is 2 away
	addq.w	#2,d5			; next is 3> away
2$:
	move.w	d5,sclp_Type(a1)
	cmp.w	#1,sl_YCount(a1)
	beq.s	do_sl_count
	add.w	#ScrollLineTableSize,d5
do_sl_count:
	add.w	0(a3,d5.w),d1
count_sl_loop.
	dbra.s	d7,count_sl_loop

sl_counted:
	movem.l	(sp)+,d5/a3
	add.w	#16,d1			; for good luck
	bra	count_get_ucop

* }
********************************************************************************
* {
	; **********************************************************************
	;
	; This code will build the UserCopperList to scroll blocks of line in
	; this ViewPort.
	;
	; **********************************************************************

	; enters with:
	; a0 -> TagItem
	; a4 -> GfxBase
	; a5 -> Stack frame
	; a6 -> UtilityBase

DisplayScrollLines:
	move.l	a4,a6
	move.l	ti_Data(a0),a4
	move.l	stk_DispHandle(a5),a3
	move.l	a4,(a3)+		; store the FxHandle in the AnimHandle
	move.l	a3,stk_DispHandle(a5)
	move.w	fxh_Num(a4),d7
	beq	build_loop		; early sanity check

	; **********************************************************************
	;
	; This code calculates the deltas for DDFSTRT, BPLCON1, BPLMODx and FMODE
	; for 64 different positions, by faking out a ViewPort, and calling
	; ScrollVPort(). Then for each position, look through the vp->DspIns, and
	; store the results.
	;
	; **********************************************************************

	sub.l	#(vp_SIZEOF+ri_SIZEOF),sp
	move.l	sp,a2			; a2 -> dummy ViewPort
	lea	vp_SIZEOF(a2),a1	; a1 -> RasInfo
	move.l	stk_ViewPort(a5),a3
	moveq	#0,d0
	move.l	d0,vp_Next(a2)
	move.l	vp_ColorMap(a3),vp_ColorMap(a2)
	move.l	d0,vp_DspIns(a2)
	move.l	d0,vp_SprIns(a2)
	move.l	d0,vp_ClrIns(a2)
	move.l	d0,vp_UCopIns(a2)
	move.l	vp_DWidth(a3),vp_DWidth(a2)	; DWidth and DHeight
	move.l	vp_DxOffset(a3),vp_DxOffset(a2)	; DxOffset and DyOffset
	move.l	vp_Modes(a3),vp_Modes(a2)	; Modes, SpritePri and ExtendedModes
	move.l	a1,vp_RasInfo(a2)
	move.l	vp_RasInfo(a3),a3
	move.l	d0,ri_Next(a1)			; No DPF for now.
	move.l	ri_BitMap(a3),ri_BitMap(a1)
	move.l	d0,ri_RxOffset(a1)		; RxOffset and RyOffset
	move.l	a1,a3

	; a2 -> dummy ViewPort
	; a3 -> dummy RasInfo

	; Make the ViewPort

	FORBID	a1
	move.l	stk_View(a5),a0
	move.l	a2,a1
	move.l	v_ViewPort(a0),-(sp)
	move.l	a1,v_ViewPort(a0)
	jsr	_LVOMakeVPort(a6)
	move.l	stk_View(a5),a0
	move.l	(sp)+,v_ViewPort(a0)
	PERMIT	save

	; look for the modulo values, and store them in d6.l,
	; and FMode, Modulos, BplCon1, and DDFStrt to store in the Current holdings.
	moveq	#0,d6
	move.l	vp_DspIns(a2),d0
*	beq	FAILURE_3
	move.l	d0,a0
	move.l	cl_CopIns(a0),d0
*	beq	FAILURE_3
	move.l	d0,a0
sl_curr_loop:
	lea	ci_SIZEOF(a0),a0	; skip the first WAIT
	btst.b	#0,ci_OpCode+1(a0)	; last WAIT?
	bne	searched_ci
	move.w	ci_DestAddr(a0),d0
	move.w	ci_DestData(a0),d1
	and.w	#$fff,d0
	cmp.w	#(BPLCON1&$fff),d0
	beq.s	sl_curr_con1
	cmp.w	#(DDFSTRT&$fff),d0
	beq.s	sl_curr_ddfstrt
	cmp.w	#(FMODE&$fff),d0
	beq.s	sl_curr_fmode
	cmp.w	#(BPL1PTH&$fff),d0
	beq.s	sl_curr_bpl1
	cmp.w	#(BPL2PTH&$fff),d0
	beq.s	sl_curr_bpl2
	cmp.w	#(BPLMOD0&$fff),d0
	beq.s	sl_curr_mod0
	cmp.w	#(BPLMOD1&$fff),d0
	bne.s	sl_curr_loop
sl_curr_mod1:
	move.w	d1,d6
	move.w	d1,slp_ZeroBPLMOD1(a4)
	bra.s	sl_curr_loop
sl_curr_mod0:
	swap	d6
	move.w	d1,d6
	swap	d6
	move.w	d1,slp_ZeroBPLMOD0(a4)
	bra.s	sl_curr_loop
sl_curr_con1:
	move.w	d1,slp_ZeroBPLCON1(a4)
	bra.s	sl_curr_loop
sl_curr_ddfstrt:
	move.w	d1,slp_ZeroDDFSTRT(a4)
	bra.s	sl_curr_loop
sl_curr_fmode:
	move.w	d1,slp_ZeroFMODE(a4)
	move.l	a6,-(sp)
	move.l	gb_bwshifts(a6),a6
	and.w	#3,d1
	move.b	0(a6,d1.w),d1
	addq.w	#1,d1
	move.w	d1,slp_ZeroDelta(a4)
	move.l	(sp)+,a6
	bra.s	sl_curr_loop
sl_curr_bpl1:
	move.w	d1,d4
	swap	d4
	lea	ci_SIZEOF(a0),a0	; assume LOW bits in the next instruction
	move.w	ci_DestData(a0),d4
	bra	sl_curr_loop
sl_curr_bpl2:
	move.w	d1,d5
	swap	d5
	lea	ci_SIZEOF(a0),a0	; assume LOW bits in the next instruction
	move.w	ci_DestData(a0),d5
	bra	sl_curr_loop

searched_ci:
	move.w	slp_ZeroFMODE(a4),d1
	move.l	a6,-(sp)
	move.l	gb_bwshifts(a6),a6
	and.w	#3,d1
	move.b	0(a6,d1.w),d1
	addq	#1,d1
	move.w	d1,slp_ZeroDelta(a4)
	move.l	(sp)+,a6

	; checkpoint
	; d4 = BPL1PTR
	; d5 = BPL2PTR
	; d6 = Mod0:Mod1
	; a2 -> tmp ViewPort on stack
	; a3 -> tmp RasInfo on stack
	; a4 -> struct FXHandle
	; a5 -> Stack stuff
	; a6 -> GfxBase

	; calculate all of the positions
	move.w	vp_DxOffset(a2),slp_DxOffset(a4)
	move.w	slp_OffsetCount(a4),d7	; this many positions to store
	subq.w	#1,d7			; for dbra
	move.l	a4,-(sp)
	lea	slPrivate_SIZEOF(a4),a4	; a4 -> start of block
	move.l	vp_ColorMap(a2),d0
	beq.s	1$
	move.l	d0,a0
	tst.b	cm_Type(a0)
	beq.s	1$
	swap	d7
	move.b	cm_AuxFlags(a0),d7
	swap	d7
	bclr.b	#CMAB_NO_INTERMED_UPDATE,cm_AuxFlags(a0)	; not exactly friendly, as the ColorMap is not a copy
1$:
	move.l	vp_DspIns(a2),a0
	move.l	cl_CopIns(a0),a0
	move.l	a0,-(sp)
svp_loop
	addq.w	#1,ri_RxOffset(a3)
	move.l	a2,a0
	jsr	_LVOScrollVPort(a6)
	move.l	(sp),a0			; CopIns
sl_init_loop:
	lea	ci_SIZEOF(a0),a0	; skip the first WAIT
	btst.b	#0,ci_OpCode+1(a0)	; last WAIT?
	bne.s	svp_loop.
	move.w	ci_DestAddr(a0),d0
	move.w	ci_DestData(a0),d1
	and.w	#$fff,d0
	cmp.w	#(BPLCON1&$fff),d0
	beq.s	sl_init_con1
	cmp.w	#(DDFSTRT&$fff),d0
	beq.s	sl_init_ddfstrt
	cmp.w	#(FMODE&$fff),d0
	beq.s	sl_init_fmode
	cmp.w	#(BPLMOD0&$fff),d0
	beq.s	sl_init_mod0
	cmp.w	#(BPLMOD1&$fff),d0
	bne.s	sl_init_loop
sl_init_mod1:
	move.w	d1,OffBPLMOD1(a4)
	bra.s	sl_init_loop
sl_init_mod0:
	move.w	d1,OffBPLMOD0(a4)
	bra.s	sl_init_loop
sl_init_con1:
	move.w	d1,OffBPLCON1(a4)
	bra.s	sl_init_loop
sl_init_ddfstrt:
	move.w	d1,OffDDFSTRT(a4)
	bra.s	sl_init_loop
sl_init_fmode:
	move.w	d1,OffFMODE(a4)
	bra.s	sl_init_loop
svp_loop.
	move.w	OffFMODE(a4),d1
	move.l	a6,d2
	move.l	gb_bwshifts(a6),a6
	and.w	#3,d1
	move.b	0(a6,d1.w),d1
	addq.w	#1,d1
	move.w	d1,OffDelta(a4)		; multiply the Whole values by 2, 4, or 8 == shift by 1, 2 or 3
	move.l	d2,a6
	move.l	d6,d2
	sub.w	OffBPLMOD1(a4),d2
	move.w	d2,OffLineLen1(a4)
	swap	d2
	sub.w	OffBPLMOD0(a4),d2
	move.w	d2,OffLineLen0(a4)
	lea	slOffsetTable_SIZEOF(a4),a4
	dbra.s	d7,svp_loop

	move.l	vp_ColorMap(a2),a0
	swap	d7
	move.b	d7,cm_AuxFlags(a0)
	addq.l	#4,sp
	move.l	(sp)+,a4
	add.l	#(vp_SIZEOF+ri_SIZEOF),sp

	; checkpoint
	; d6 = Mod0:Mod1
	; a4 -> struct FxHandle
	; a5 -> Stack stuff
	; a6 -> GfxBase

	; now build the copperlist
	move.l	d6,stk_ZeroMod0(a5)
	move.l	d6,stk_LastMod0(a5)
	move.w	fxh_Num(a4),d7
	subq.w	#1,d7
	move.l	fxh_UCopList(a4),a2
	move.l	a4,-(sp)
	move.w	d7,-(sp)
	move.l	a4,a3
	move.l	fxh_First(a4),a4	; a4 -> first struct ScrollLines in the list

	; calculate the Whole part of the XOffset, and the offset into the
	; slOffsetTable
calc_sloff:
	move.w	sl_XOffset(a4),d3
	ext.l	d3
	move.w	slp_OffsetCount(a3),d2
	move.l	d3,d0
	bpl.s	3$
	addq.l	#1,d0
3$:
	divs	d2,d0
	move.w	d0,sclp_Whole(a4)	; number of whole 'jumps' to make (including the sign)
	subq.w	#1,d2
	tst.w	d3
	bpl.s	2$
	eor.w	d2,d3
	addq.w	#1,d3
	neg.w	d3
	subq.w	#1,sclp_Whole(a4)
2$:
	and.w	d2,d3			; our 'true' XOffset
	lea	FxHandle_SIZEOF(a3),a1
	tst.w	d3
	beq.s	1$
	mulu	#slOffsetTable_SIZEOF,d3
	lea	slPrivate_SIZEOF(a3,d3),a1
1$:
	move.l	a1,sclp_slOff(a4)
	lea	sclPrivate_SIZEOF(a4),a4
	dbra.s	d7,calc_sloff
	move.w	(sp)+,d7

	; now the main build loop
	; use the upper word of d7 to mask the y values. If the ViewPort is
	; interlaced, we want all the y values to be even.
	swap	d7
	move.w	#$ffff,d7
	move.l	stk_ViewPort(a5),a3
	btst.b	#2,vp_Modes+1(a3)	; laced?
	beq.s	10$
	subq.w	#1,d7
10$:
	swap	d7

	move.l	(sp),a4
	move.l	fxh_First(a4),a4
build_sl_loop:
	move.l	(sp),a3
	lea	FxHandle_SIZEOF(a3),a1
	move.l	sclp_slOff(a4),a3
	move.l	sl_YCount(a4),d5	; Count:YOffset
	move.w	sclp_Type(a4),d4
	move.w	sclp_Whole(a4),d6
	cmp.w	#PREV_SL_2,d4
	blt	build_line2_chk		; d3 is already set up, and we don't need LastMod
	; here, the previous ScrollLines was 2 or more lines away, so we need
	; at least LINE_1
	subq.w	#PREV_SL_2,d4
	moveq	#0,d0
	move.l	d0,d1			; X value
	move.w	d5,d0
	subq.w	#1,d0			; Y value
	swap	d7
	and.w	d7,d0
	swap	d7
	move.l	a2,a1
	jsr	_LVOCWait(a6)
	move.l	a2,a1
	jsr	_LVOCBump(a6)
	; calculate the modulos we need.
	move.w	OffDelta(a3),d2
	move.w	d6,d1
	exg	d6,d2
	asl.w	d6,d2
	move.w	d1,d6
	move.w	stk_ZeroMod0(a5),d1
	add.w	d1,d2
	move.w	d2,d0
	swap	d0
	CMOVE	#BPLMOD0,d2
	move.w	OffDelta(a3),d2
	move.w	d6,d1
	exg	d6,d2
	asl.w	d6,d2
	move.w	d1,d6
	move.w	stk_ZeroMod1(a5),d1
	add.w	d1,d2
	move.w	d2,d0
	CMOVE	#BPLMOD1,d2
	move.l	d0,stk_LastMod0(a5)
	move.l	stk_ZeroMod0(a5),d3
	sub.w	d0,d3
	swap	d0
	swap	d3
	sub.w	d0,d3
	swap	d3

build_line2_chk:	
	; build LINE_2
	; Easy bits first:
	moveq	#0,d1
	move.l	d1,d0
	move.w	d5,d0
	move.l	a2,a1
	jsr	_LVOCWait(a6)
	move.l	a2,a1
	jsr	_LVOCBump(a6)
	moveq	#0,d2
	move.w	OffDDFSTRT(a3),d2
	CMOVE	#DDFSTRT,d2
	move.w	OffBPLCON1(a3),d2
	CMOVE	#BPLCON1,d2
	btst.b	#GFXB_AA_LISA,gb_ChipRevBits0(a6)
	beq.s	1$
	move.w	OffFMODE(a3),d2
	CMOVE	#FMODE,d2
1$:
	; now the modulos.
	; From our table, we deduce:
	; if (the height of this block == 1)
	; {
	;    if (the next block is 1 line away)
	;        calculate modulos to point to bitplanes of the next block's offset
	;    if (the next block is 2 or more lines away)
	;        calculate modulos to point to restore the bplptrs
	; }
	; else  // height of this block is 2 or more lines
	;    calculate the modulos to point to start of next line in this block
	swap	d5
	cmp.w	#1,d5
	bne	build_line2_l2
	tst.w	d4
	beq.s	build_line2_l0
	; height is 1, and the next block is 2 or more lines away, so
	; calculate the modulos to put the bplptrs back to their orignal setting.
	move.l	OffBPLMOD0(a3),d0
	move.l	d0,stk_LastMod0(a5)
	sub.w	OffLineLen1(a3),d3
	swap	d3
	sub.w	OffLineLen0(a3),d3
	swap	d3
	bra	build_line3_n2
build_line2_l0:
	; height is 1, and the next block is 1 line away, so calculate the modulos
	; to put the bplptrs at the start of the next line.
	move.l	sclPrivate_SIZEOF+sclp_slOff(a4),a0
	move.w	OffDelta(a0),d1
	move.w	sclPrivate_SIZEOF+sclp_Whole(a4),d6	; next Whole value
	move.w	d6,d2
	asl.w	d1,d2
	move.w	stk_ZeroMod0(a5),d0
	add.w	d0,d2		; this is what we want to be
	swap	d3
	add.w	d3,d2
	sub.w	OffBPLMOD0(a3),d0
	sub.w	d0,d2
	move.w	d2,d0
	CMOVE	#BPLMOD0,d2
	swap	d0
	swap	d3
	move.w	d6,d2
	asl.w	d1,d2
	move.w	stk_ZeroMod1(a5),d0
	add.w	d0,d2
	add.w	d3,d2
	sub.w	OffBPLMOD1(a3),d0
	sub.w	d0,d2
	move.w	d2,d0
	CMOVE	#BPLMOD1,d2
	move.l	d0,stk_LastMod0(a5)
	move.l	stk_ZeroMod0(a5),d6
	move.w	d6,d1
	sub.w	d0,d6
	sub.w	OffLineLen1(a3),d6
	add.w	d6,d3
	swap	d3
	swap	d0
	swap	d6
	move.w	d6,d1
	sub.w	d0,d6
	sub.w	OffLineLen0(a3),d6
	add.w	d6,d3
	swap	d3
	bra	build_sl_loop.
build_line2_l2:
	move.l	OffBPLMOD0(a3),d2
	swap	d2
	CMOVE	#BPLMOD0,d2
	swap	d2
	CMOVE	#BPLMOD1,d2
	sub.w	OffLineLen1(a3),d3
	swap	d3
	sub.w	OffLineLen0(a3),d3
	swap	d3
build_line3_chk:
	; Check if we need to build LINE_3
	; we always need LINE_3 if this block is 2 or more lines high.
	move.w	d5,d0
	swap	d5
	cmp.w	#2,d0
	blt	build_line4_chk
	add.w	d5,d0
	subq.w	#1,d0		; line number
	swap	d7
	and.w	d7,d0
	swap	d7
	moveq	#0,d1
	move.l	a2,a1
	jsr	_LVOCWait(a6)
	move.l	a2,a1
	jsr	_LVOCBump(a6)
	; now the modulos.	
	; From our table, we deduce:
	; if (the next block is only 1 line away)
	;    calculate the modulos to point to bitplanes of the next block's offset
	; else
	;    calculate the modulos to restore the bitplanes as they were.
	tst.w	d4
	bne	build_line3_n2
	; next block is only 1 line away.
	; calculate how far we want to be from the origin, and compensate with
	; how far we are now.
	move.l	sclPrivate_SIZEOF+sclp_slOff(a4),a0
	move.w	OffDelta(a0),d1
	move.w	sclPrivate_SIZEOF+sclp_Whole(a4),d6	; next Whole value
	move.w	d6,d2
	asl.w	d1,d2
	move.w	stk_ZeroMod0(a5),d0
	add.w	d0,d2		; this is what we want to be.
	swap	d3
	add.w	d3,d2
	move.w	d2,d0
	CMOVE	#BPLMOD0,d2
	swap	d0
	swap	d3
	move.w	d6,d2
	asl.w	d1,d2
	move.w	stk_ZeroMod1(a5),d0
	add.w	d0,d2
	add.w	d3,d2
	move.w	d2,d0
	CMOVE	#BPLMOD1,d2
	move.l	d0,stk_LastMod0(a5)
	move.l	stk_ZeroMod0(a5),d1
	sub.w	d0,d1
	add.w	d1,d3
	swap	d0
	swap	d3
	swap	d1
	sub.w	d0,d1
	add.w	d1,d3
	swap	d3
	bra	build_sl_loop.
build_line3_n2:
	move.l	stk_ZeroMod0(a5),d2
	swap	d2
	swap	d3
	add.w	d3,d2
	CMOVE	#BPLMOD0,d2
	swap	d2
	swap	d3
	add.w	d3,d2
	CMOVE	#BPLMOD1,d2
	swap	d2
	move.l	d2,stk_LastMod0(a5)
build_line4_chk:
	; check if we need to build LINE_4.
	; We always need LINE_4 if the next block is 2 or more lines away.
	tst.w	d4
	beq	build_sl_loop.	; next is 1 line away
	move.w	d5,d0
	swap	d5
	add.w	d5,d0		; line number
	moveq	#0,d1
	move.l	a2,a1
	jsr	_LVOCWait(a6)
	move.l	a2,a1
	jsr	_LVOCBump(a6)
	move.l	(sp),a3		; get back the FxHandle, so we can get the slp_Zero data
	lea	slp_ZeroDDFSTRT(a3),a3
	cmp.w	#NEXT_SL_3G,d4
	bge	build_line4_n3
	; next block is only 2 lines away.
	; Restore DDFSTRT, BPLCON1 and FMODE for the 1 non-scrolled line, but
	; calculate the modulos for the next scrolled line.
	move.w	OffDDFSTRT(a3),d2
	CMOVE	#DDFSTRT,d2
	move.w	OffBPLCON1(a3),d2
	CMOVE	#BPLCON1,d2
	btst.b	#GFXB_AA_LISA,gb_ChipRevBits0(a6)
	beq.s	1$
	move.w	OffFMODE(a3),d2
	CMOVE	#FMODE,d2
1$:
	move.l	sclPrivate_SIZEOF+sclp_slOff(a4),a0
	move.w	OffDelta(a0),d1
	move.w	sclPrivate_SIZEOF+sclp_Whole(a4),d6	; next Whole value
	move.w	d6,d2
	asl.w	d1,d2
	move.w	stk_ZeroMod0(a5),d0
	add.w	d0,d2
	move.w	d2,d0
	swap	d0
	CMOVE	#BPLMOD0,d2
	move.w	d6,d2
	asl.w	d1,d2
	move.w	stk_ZeroMod1(a5),d0
	add.w	d0,d2
	move.w	d2,d0
	CMOVE	#BPLMOD1,d2
	move.l	d0,stk_LastMod0(a5)
	move.l	stk_ZeroMod0(a5),d3
	sub.w	d0,d3
	swap	d0
	swap	d3
	sub.w	d0,d3
	swap	d3
	bra	build_sl_loop.
build_line4_n3:
	; next is 3 or more lines away, so just restore everything
	move.w	(a3)+,d2
	CMOVE	#DDFSTRT,d2
	move.w	(a3)+,d2
	CMOVE	#BPLCON1,d2
	move.w	(a3)+,d2
	CMOVE	#BPLMOD0,d2
	swap	d2
	move.w	(a3)+,d2
	CMOVE	#BPLMOD1,d2
	swap	d2
	move.l	d2,stk_LastMod0(a5)
	btst.b	#GFXB_AA_LISA,gb_ChipRevBits0(a6)
	beq.s	1$
	move.w	(a3)+,d2
	CMOVE	#FMODE,d2
1$:
build_sl_loop.:
	; that's it
	lea	sclPrivate_SIZEOF(a4),a4
	dbra	d7,build_sl_loop
	addq.l	#4,sp			; FxHandle

	move.l	#10000,d0
	move.l	#255,d1
	move.l	a2,a1
	jsr	_LVOCWait(a6)		; CEND
	move.l	a2,a1
	jsr	_LVOCBump(a6)

	bra	build_loop

* }
@


39.1
log
@Builds a UCopList per FX. not one big UCopList for the whole anim.
This makes it easier to add and remove affects from the display, and
speeds up animation, as there are less copperinstructions to filter
through.
@
text
@d3 1
a3 1
*	$Id: DisplayFX.asm,v 39.0 93/03/12 19:13:16 spence Exp Locker: spence $
d31 14
d47 1
d63 1
d67 1
d157 1
d169 1
a169 1
	beq	tags_done
d174 3
a176 38
	beq.s	count_colours
	bra.s	calc_loop

count_colours:
	addq.l	#1,d5
	move.l	ti_Data(a0),a0
	moveq	#0,d0			; d0 will count the WAITs
	move.l	d0,d1
	move.w	fxh_Num(a0),d7
	beq.s	calc_loop		; early sanity check
	move.w	d7,d1			; d1 will count the colours
	move.l	fxh_First(a0),a1
	move.w	cor_WAIT_Y(a1),d6
	addq.w	#1,d6
	subq.w	#1,d7
count_colours_loop:
	move.w	cor_WAIT_Y(a1),d3
	cmp.w	d3,d6
	beq.s	chk_restore
	addq.w	#1,d0			; one more WAIT
	move.w	d3,d6
chk_restore:
	btst.b	#CORB_RESTORE,cor_Flags+3(a1)
	beq.s	count_colours_loop.
	addq.w	#1,d1
	addq.w	#1,d0			; possibly one more WAIT
count_colours_loop.:
	lea	CorPrivate_SIZE(a1),a1
	dbra.s	d7,count_colours_loop
	btst.b	#GFXB_AA_LISA,gb_ChipRevBits0(a4)
	beq.s	1$
	; for AA, need 2 colour instructions, and 2 bplcon3 instructions per line
	asl.l	#2,d1
1$:
	add.l	d0,d1			; add the WAITs
	addq.w	#2,d1			; terminator

	bsr	DoUCopStuff
d179 1
d244 1
a244 1
	beq	tags_done2
d249 3
a251 1
	beq.s	DisplayColours
d256 1
d272 47
d320 3
a322 1
	
d345 1
a345 1
	bcs.s	build_loop		; early sanity check
d499 61
d561 99
d661 603
d1265 5
d1311 1
@


39.0
log
@Initial log in.
Just ColorRange for now.
@
text
@d3 1
a3 1
*	$Id: animcontrol.asm,v 40.1 93/03/03 17:11:47 spence Exp Locker: spence $
d46 2
d111 1
a111 1
*	<SpecialFX/SpecialFX.h> AnimateFXA() RemoveFXA()
a114 1
_MyDisplayFXA::
d125 16
a140 2
	; Precalculate the number of copper instructions we will need, by
	; iterating through the taglist.
d145 1
a145 1
	moveq	#0,d2			; d2 will keep count
d174 1
a174 1
	beq.s	count_colours_loop.
d177 5
d191 3
a193 2
	addq.w	#1,d1			; terminator
	add.l	d1,d2			; add to the running total
d201 1
d215 1
a215 15

	; now allocate a UserCopperlist
	moveq	#ucl_SIZEOF,d0
	move.l	#(MEMF_CLEAR|MEMF_PUBLIC),d1
	jsr	_LVOAllocMem(a6)
	tst.l	d0
	beq	FAILURE_1
	move.l	d0,a0
	move.l	d0,a2
	move.l	d2,d0
	exg	a4,a6
	jsr	_LVOUCopperListInit(a6)
	tst.l	d0
	beq	FAILURE_2
	move.l	a2,ah_UCopList(a3)
d220 1
a220 3
	; a1 -> ViewPort
	; a2 -> struct UCopList
	; a4 -> ExecBase
d222 1
a222 1
	; a6 -> GfxBase
d253 1
a253 2
	move.l	a6,a4
	move.l	gb_UtilBase(a6),a6
a269 4
	move.l	stk_ViewPort(a5),a1	; get the ViewPort
	move.l	vp_UCopIns(a1),d0
	move.l	d0,ucl_Next(a2)
	move.l	a2,vp_UCopIns(a1)
d272 1
a272 1
	addq.l	#8,sp
d274 8
a295 1
	; a2 -> struct UCopList
d306 1
d466 44
d512 2
d518 18
a535 3
	; free the AnimHandle
	move.l	stk_DispHandle(a5),a1
	moveq	#AnimHandle_SIZEOF,d0
d537 3
@
