
/* Code generated by Toolmaker V1.1.22 */

/* Includes */
 
#include <exec/memory.h>
#include <graphics/view.h>
#include <graphics/displayinfo.h>

#include "tmgr_common.h"
#include "TstMgr.h"
#include "TstMgr_tm.h"
#include "TstMgr_text.h"
#include "TstMgr_tm_protos.h"
#include "tmgr_misc_protos.h"

#ifndef D(x)
#define D(x) /* PutStr(x) */
#endif

/* static function prototypes */
/* 
static BOOL TM_WindowSignal(struct TMData *);
static VOID TM_RemoveWindow(struct TMWindowInfo *);
static BOOL WindowIDCMP_ERRWINDO(struct TMData *, struct IntuiMessage *);
*/

/* Mouse pointer data for disabled window */
 
UWORD chip WaitPointer[] =
  {
  0x0000, 0x0000,
  0x0400, 0x07C0,
  0x0000, 0x07C0,
  0x0100, 0x0380,
  0x0000, 0x07E0,
  0x07C0, 0x1FF8,
  0x1FF0, 0x3FEC,
  0x3FF8, 0x7FDE,
  0x3FF8, 0x7FBE,
  0x7FFC, 0xFF7F,
  0x7EFC, 0xFFFF,
  0x7FFC, 0xFFFF,
  0x3FF8, 0x7FFE,
  0x3FF8, 0x7FFE,
  0x1FF0, 0x3FFC,
  0x07C0, 0x1FF8,
  0x0000, 0x07E0,
  0x0000, 0x0000,
  };

/* Screen data */
 
struct ColorSpec ColorSpec[] = 
  {
    {0, 0x1, 0xC, 0x1},
    {1, 0x0, 0x0, 0x2},
    {2, 0xF, 0xF, 0xF},
    {3, 0xB, 0x2, 0x2},
    {-1, 0x0, 0x0, 0x0}
  };
WORD screen0labels1[] = {-1};

/* Window data */
 

/* Font data */
 
struct TextAttr topaz8 =
  {
  "topaz.font", /* ta_Name */
  8,    /* ta_YSize */
  FS_NORMAL,    /* ta_Style */
  FPF_ROMFONT   /* ta_Flags */
  };

/****** TstMgr_tm.c/TM_Request *****************************
*
*   NAME
*   TM_Request -- display a message in a system requester.
*
*   SYNOPSIS
*   num = TM_Request(Window, Title, TextFormat, GadgetFormat,
*                    IDCMP_ptr, Arg1, Arg2, ...)
*
*   LONG TM_Request(struct Window *, char *, char *, char *,
*                   ULONG *, APTR, ...);
*
*   FUNCTION
*   Calls EasyRequestArgs to display a message in a system
*   requester without having to fill in an EasyStruct structure.
*   This function uses a varargs calling convention.
*
*   INPUTS
*   Window = pointer to window (passed to EasyRequestArgs()).
*   Title = title bar string (passed to EasyRequestArgs()).
*   TextFormat = body text (passed to EasyRequestArgs()).
*   GadgetFormat = gadget text (passed to EasyRequestArgs()).
*   IDCMP_ptr = IDCMP value (passed to EasyRequestArgs()).
*   Args = arguments (passed to EasyRequestArgs()).
*
*   RESULT
*   num = gadget number returned by EasyRequestArgs().
*
*   EXAMPLE
*
*   NOTES
*   The intuition library must be open before calling this
*   function.
*
*   BUGS
*
*   SEE ALSO
*   intuition.library/EasyRequestArgs()
*
**************************************************************
*
*/
LONG TM_Request(struct Window *Window, char *Title, char *TextFormat, char *GadgetFormat, ULONG *IDCMP_ptr, APTR Arg1, ...)
  {
  struct EasyStruct es = {sizeof(struct EasyStruct), 0, NULL, NULL, NULL};

  es.es_Title = Title;
  es.es_TextFormat = TextFormat;
  es.es_GadgetFormat = GadgetFormat;

  return(EasyRequestArgs(Window, &es, IDCMP_ptr, &Arg1));
  }

/****** TstMgr_tm.c/TM_Open *****************************
*
*   NAME
*   TM_Open -- initialize user-interface data.
*
*   SYNOPSIS
*   TMData = TM_Open(ErrorCode)
*
*   struct TMData *TM_Open(ULONG *error);
*
*   FUNCTION
*   Creates an initializes a TMData structure.  This
*   includes allocating memory for a TMData structure,
*   creating a message port for window IDCMP messages,
*   and opening any fonts on disk.
*
*   INPUTS
*   error = pointer to ULONG to store an error number.
*           Error numbers are defined in the _tm.h file.
*
*   RESULT
*   TMData = pointer to an initialized TMData structure
*            or NULL if an error occurred.
*
*   EXAMPLE
*
*   NOTES
*   The intuition and gadtools libraries must be open before
*   calling this function.  If any disk fonts are used the
*   diskfont and graphics libraries must also be open.
*
*   BUGS
*
*   SEE ALSO
*   TM_Close()
*
**************************************************************
*
*/
struct TMData *TM_Open(ULONG *error) {
    struct TMData *tmdata;

    if (tmdata = AllocMem(sizeof(struct TMData), MEMF_CLEAR)) {
        tmdata->Size = sizeof(struct TMData);

        if (tmdata->WindowMsgPort = CreateMsgPort()) {
            *error = TMERR_OK;
            return(tmdata);
        }
        FreeMem(tmdata, sizeof(struct TMData));
    }
    else {
        *error = TMERR_MEMORY;
    }

    return(NULL);
}

/****** TstMgr_tm.c/TM_Close *****************************
*
*   NAME
*   TM_Close -- frees user-interface data.
*
*   SYNOPSIS
*   TM_Close(TMData)
*
*   VOID TM_Close(struct TMData *TMData);
*
*   FUNCTION
*   Frees resources allocated by TM_Open().
*
*   INPUTS
*   TMData = pointer to TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   TM_Open()
*
**************************************************************
*
*/
VOID TM_Close(struct TMData *TMData) {
    struct Message *msg;

    if (TMData) {
        CloseWindow_ERRWINDO(TMData);
        CloseScreen_TESTMANA(TMData);

        if (TMData->WindowMsgPort) {  /* new stuff, save for the DeleteMsgPort(). */
            Forbid();
            while (msg = GetMsg(TMData->WindowMsgPort)) {
                ReplyMsg(msg);
            }
            DeleteMsgPort(TMData->WindowMsgPort);
            Permit();
        }
        FreeMem(TMData, TMData->Size);
    }
}

/****** TstMgr_tm.c/TM_EventLoop *****************************
*
*   NAME
*   TM_EventLoop -- waits for all events.
*
*   SYNOPSIS
*   TM_EventLoop(TMData)
*
*   VOID TM_EventLoop(struct TMData *);
*
*   FUNCTION
*   Waits for any events to signal program.  All IDCMP, ARexx,
*   and a user signal messages received are sent to the
*   appropriate signal function.  A return value of TRUE from
*   any of the signal functions will terminate the loop.
*
*   INPUTS
*   TMData = pointer to TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   TM_WindowSignal(), TM_ARexxSignal(), exec.library/Wait()
*
**************************************************************
*
*/
VOID TM_EventLoop(struct TMData *TMData) {
  BOOL done=FALSE, result;
  ULONG windowsignal, signals, clientSignal, waitSigs;
  struct TMgr_Globals *t;

    windowsignal = 1L << TMData->WindowMsgPort->mp_SigBit;
    t = (struct TMgr_Globals *)(TMData->UserData);
    clientSignal = 1L << t->mp->mp_SigBit;
    waitSigs = windowsignal | clientSignal;

    while (!done) {
        signals = Wait(waitSigs);

        if (signals & windowsignal) {
            if (result = TM_WindowSignal(TMData)) 
                done = result;
        }
        if (signals & clientSignal) {
           D("tmEventLoop:  Doing clientSignal\n");
              /* Process struct errReport */
              if (result = TMgr_DoSigs(TMData)) {
                  done = result;
              }
        }
    }
}

/****** TstMgr_tm.c/OpenScreen_TESTMANA *****************************
*
*   NAME
*   OpenScreen_TESTMANA -- Open custom screen "TESTMANA".
*
*   SYNOPSIS
*   success = OpenScreen_TESTMANA(TMData)
*
*   BOOL OpenScreen_TESTMANA(struct TMData *);
*
*   FUNCTION
*   Creates and displays the custom screen labeled "TESTMANA"
*   and gets its visual info.
*
*   INPUTS
*   TMData = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*   success = TRUE if command was successfully completed,
*             or if Workbench Screen is used instead of custom screen.
*             FALSE if not.
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
**************************************************************
*
*/
BOOL OpenScreen_TESTMANA(struct TMData *TMData)
  {
  ULONG lasttag;
  struct TMgr_Globals *t;

  t = (struct TMgr_Globals *)TMData->UserData;

  if (ScreenInfo_TESTMANA.Screen) {
    ScreenToFront(ScreenInfo_TESTMANA.Screen);
    return(TRUE);
  }
  else {
    if (t->useWB) {
        if (ScreenInfo_TESTMANA.Screen = LockPubScreen(NULL)) {
          if (ScreenInfo_TESTMANA.VisualInfo = GetVisualInfo(ScreenInfo_TESTMANA.Screen, TAG_DONE)) {
            return(TRUE);         /* blatant lie, but we already have a screen. */
          }
          else {
            UnlockPubScreen(NULL,ScreenInfo_TESTMANA.Screen);
            ScreenInfo_TESTMANA.Screen = NULL;
          }
        }
        return(FALSE);
    }

    lasttag = ScreenInfo_TESTMANA.MoreTags ? TAG_MORE : TAG_DONE;

    if (ScreenInfo_TESTMANA.Screen = OpenScreenTags(NULL,
          SA_Title, TEXT_S0TITLE,   /* TestManager */
          SA_DisplayID, HIRESLACE_KEY,
          SA_Overscan, OSCAN_TEXT,
          SA_Colors, ColorSpec,
          SA_Height, 100,
          SA_Top, 320,
          SA_Left, 0,
          SA_BlockPen, 1,
          SA_DetailPen, 0,
          SA_FullPalette, TRUE,
          SA_Depth, 2,
          SA_Pens, screen0labels1,
          lasttag, ScreenInfo_TESTMANA.MoreTags))
      {
        if (ScreenInfo_TESTMANA.VisualInfo = GetVisualInfo(ScreenInfo_TESTMANA.Screen, TAG_DONE)) {
            return(TRUE);
        }
        CloseScreen(ScreenInfo_TESTMANA.Screen);
      }
  }

  return(FALSE);
  }

/****** TstMgr_tm.c/CloseScreen_TESTMANA *****************************
*
*   NAME
*   CloseScreen_TESTMANA -- Close custom screen "TESTMANA".
*
*   SYNOPSIS
*   CloseScreen_TESTMANA(TMData)
*
*   VOID CloseScreen_TESTMANA(struct TMData *);
*
*   FUNCTION
*   Closes the custom screen labeled "TESTMANA"
*   and frees the visual info.
*
*   INPUTS
*   TMData = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*   This command is called by TM_Close().
*
*   BUGS
*
*   SEE ALSO
*   TM_Close()
*
**************************************************************
*  Please note that this function is called AFTER TMData->UserData is freed.
*  Thus anything stored in TMgr_Globals is *history*.  This means specifically
*  that the "useWB" field is gone, which would be quite useful here.
*/
VOID CloseScreen_TESTMANA(struct TMData *TMData) {

    if(ScreenInfo_TESTMANA.VisualInfo) {
      FreeVisualInfo(ScreenInfo_TESTMANA.VisualInfo);
      ScreenInfo_TESTMANA.VisualInfo = NULL;
    }

    if (ScreenInfo_TESTMANA.Screen) {
        CloseScreen(ScreenInfo_TESTMANA.Screen);
        ScreenInfo_TESTMANA.Screen = NULL;
    }
}

/****** TstMgr_tm.c/OpenWindow_ERRWINDO *****************************
*
*   NAME
*   OpenWindow_ERRWINDO -- Open window "ERRWINDO".
*
*   SYNOPSIS
*   success = OpenWindow_ERRWINDO(TMData)
*
*   BOOL OpenWindow_ERRWINDO(struct TMData *);
*
*   FUNCTION
*   Opens the window with label "ERRWINDO"
*   along with any gadgets it contains.
*
*   INPUTS
*   TMData  = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*   success = TRUE if command was successfully completed.
*             FALSE if not.
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   CloseWindow_ERRWINDO()
*
**************************************************************
*
*/
BOOL OpenWindow_ERRWINDO(struct TMData *TMData)
  {
  ULONG lasttag;
  struct NewGadget ng;
  struct TMgr_Globals *t;

  t = (struct TMgr_Globals *)TMData->UserData;

  if(WindowInfo_ERRWINDO.Window)
    {
    WindowToFront(WindowInfo_ERRWINDO.Window);
    ActivateWindow(WindowInfo_ERRWINDO.Window);
    }
  else
    {
    WindowInfo_ERRWINDO.FirstGadget = NULL;
    WindowInfo_ERRWINDO.ContextGadget = CreateContext(&WindowInfo_ERRWINDO.FirstGadget);

    ng.ng_VisualInfo = ScreenInfo_TESTMANA.VisualInfo;

    ng.ng_LeftEdge = 404;
    ng.ng_TopEdge = 51+ScreenInfo_TESTMANA.Screen->BarHeight;
    ng.ng_Width = 212;
    ng.ng_Height = 12;
    ng.ng_Flags = PLACETEXT_ABOVE;
    ng.ng_TextAttr = (struct TextAttr *) &topaz8;
    ng.ng_GadgetText = TEXT_W0G0;   /* Last ERROR from */
    ng.ng_GadgetID = 0;
    lasttag = GadgetInfo_LASTERRO.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_LASTERRO.Gadget = CreateGadget(TEXT_KIND, WindowInfo_ERRWINDO.ContextGadget, &ng,
        GTTX_Text, TEXT_W0G0T1, /* N/A */
        GTTX_CopyText, TRUE,
        GTTX_Border, TRUE,
        lasttag, GadgetInfo_LASTERRO.MoreTags);

    ng.ng_LeftEdge = 164;
    ng.ng_GadgetText = TEXT_W0G1;   /* Last Msg From */
    ng.ng_GadgetID = 0;
    lasttag = GadgetInfo_LMFrom.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_LMFrom.Gadget = CreateGadget(TEXT_KIND, GadgetInfo_LASTERRO.Gadget, &ng,
        GTTX_Text, TEXT_W0G1T1, /* N/A */
        GTTX_CopyText, TRUE,
        GTTX_Border, TRUE,
        lasttag, GadgetInfo_LMFrom.MoreTags);

    ng.ng_LeftEdge = 320;
    ng.ng_TopEdge = 71+ScreenInfo_TESTMANA.Screen->BarHeight;
    ng.ng_Width = 100;
    ng.ng_Flags = PLACETEXT_LEFT;
    ng.ng_GadgetText = TEXT_W0G2;   /* Error Count:  */
    ng.ng_GadgetID = 0;
    lasttag = GadgetInfo_ECnt.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_ECnt.Gadget = CreateGadget(TEXT_KIND, GadgetInfo_LMFrom.Gadget, &ng,
        GTTX_CopyText, TRUE,
        GTTX_Text, TEXT_W0G2T1, /* 0 */
        GTTX_Border, TRUE,
        lasttag, GadgetInfo_ECnt.MoreTags);

    ng.ng_LeftEdge = 404;
    ng.ng_TopEdge = 19+ScreenInfo_TESTMANA.Screen->BarHeight;
    ng.ng_Width = 212;
    ng.ng_Flags = PLACETEXT_ABOVE;
    ng.ng_GadgetText = TEXT_W0G3;   /* Last ERROR Rec'd */
    ng.ng_GadgetID = 0;
    lasttag = GadgetInfo_LErr.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_LErr.Gadget = CreateGadget(TEXT_KIND, GadgetInfo_ECnt.Gadget, &ng,
        GTTX_Text, TEXT_W0G3T1, /* N/A */
        GTTX_CopyText, TRUE,
        GTTX_Border, TRUE,
        lasttag, GadgetInfo_LErr.MoreTags);

    ng.ng_LeftEdge = 164;
    ng.ng_GadgetText = TEXT_W0G4;   /* Last MSG Rec'd */
    ng.ng_GadgetID = 0;
    lasttag = GadgetInfo_LTime.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_LTime.Gadget = CreateGadget(TEXT_KIND, GadgetInfo_LErr.Gadget, &ng,
        GTTX_Text, TEXT_W0G4T1, /* N/A */
        GTTX_CopyText, TRUE,
        GTTX_Border, TRUE,
        lasttag, GadgetInfo_LTime.MoreTags);

    ng.ng_LeftEdge = 12;
    ng.ng_TopEdge = 3+ScreenInfo_TESTMANA.Screen->BarHeight;
    ng.ng_Width = 124;
    ng.ng_Height = 44;
    ng.ng_Flags = PLACETEXT_LEFT;
    ng.ng_GadgetText = TEXT_W0G5;    
    ng.ng_GadgetID = 0;
    lasttag = GadgetInfo_PASSFAIL.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_PASSFAIL.Gadget = CreateGadget(TEXT_KIND, GadgetInfo_LTime.Gadget, &ng,
        GTTX_Text, TEXT_W0G5T1, /*      PASS */
        GTTX_Border, TRUE,
        lasttag, GadgetInfo_PASSFAIL.MoreTags);

    ng.ng_TopEdge = 51+ScreenInfo_TESTMANA.Screen->BarHeight;
    ng.ng_Height = 12;
    ng.ng_Flags = PLACETEXT_IN;
    ng.ng_GadgetText = TEXT_W0G6;    
    ng.ng_GadgetID = 0;
    lasttag = GadgetInfo_TESTING.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_TESTING.Gadget = CreateGadget(TEXT_KIND, GadgetInfo_PASSFAIL.Gadget, &ng,
        GTTX_Text, TEXT_W0G6T2, /* Testing */
        GTTX_Border, TRUE,
        lasttag, GadgetInfo_TESTING.MoreTags);

    ng.ng_TopEdge = 71+ScreenInfo_TESTMANA.Screen->BarHeight;
    ng.ng_Width = 100;
    ng.ng_GadgetText = TEXT_W0G7;   /* Abort Test */
    ng.ng_GadgetID = ID_ABORTTES;
    lasttag = GadgetInfo_ABORTTES.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_ABORTTES.Gadget = CreateGadget(BUTTON_KIND, GadgetInfo_TESTING.Gadget, &ng,
        lasttag, GadgetInfo_ABORTTES.MoreTags);

    ng.ng_LeftEdge = 516;
    ng.ng_GadgetText = TEXT_W0G8;   /* Exit */
    ng.ng_GadgetID = ID_BYEBYE;
    lasttag = GadgetInfo_BYEBYE.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_BYEBYE.Gadget = CreateGadget(BUTTON_KIND, GadgetInfo_ABORTTES.Gadget, &ng,
        lasttag, GadgetInfo_BYEBYE.MoreTags);

    if(GadgetInfo_BYEBYE.Gadget)
      {
      lasttag = WindowInfo_ERRWINDO.MoreTags ? TAG_MORE : TAG_DONE;

      if((WindowInfo_ERRWINDO.Window = OpenWindowTags(NULL,
        WA_PubScreen, ((t->useWB) ? NULL : ScreenInfo_TESTMANA.Screen),
        WA_Title, TEXT_W0TITLE, /* Test Status */
        WA_IDCMP, NULL,
        WA_Gadgets, WindowInfo_ERRWINDO.FirstGadget,
        WA_WBenchWindow, TRUE,
        WA_Backdrop, !(t->useWB),   /* Backdrop unless on WB screen     */
        WA_Borderless, !(t->useWB), /* Borderless unless on WB screen   */
        WA_ScreenTitle, TEXT_W0T1,  /* TestManager                      */
        WA_DragBar, t->useWB,       /* Dragbar only if on WB Screen     */
        WA_DepthGadget, t->useWB,   /* DepthGadget only if on WB Screen */
        WA_CloseGadget, t->useWB,   /* CloseGadget only if on WB Screen */
        WA_SizeGadget, FALSE,
        WA_Left, 0,
        WA_Top, 0,
        WA_Width, 640,
        WA_Height, 90 + ScreenInfo_TESTMANA.Screen->BarHeight,  /* adjust for font */
        WA_MinWidth, 50,
        WA_MinHeight, 30,
        WA_DetailPen, 1,
        WA_BlockPen, 0,
        WA_SimpleRefresh, TRUE,
        lasttag, WindowInfo_ERRWINDO.MoreTags)))
        {
          SetFont(window_ERRWINDO->RPort, t->tmgr_font);    /* Topaz 80 (titlebar too?) */
          WindowInfo_ERRWINDO.Window->UserPort = TMData->WindowMsgPort;
          ModifyIDCMP(WindowInfo_ERRWINDO.Window, IDCMP_REFRESHWINDOW | TEXTIDCMP | BUTTONIDCMP | IDCMP_GADGETUP | IDCMP_CLOSEWINDOW);
          GT_RefreshWindow(WindowInfo_ERRWINDO.Window, NULL);
          WindowInfo_ERRWINDO.Flags |= TMWF_OPENED;
          if (t->useWB)
            UnlockPubScreen(NULL, ScreenInfo_TESTMANA.Screen);
          return(TRUE);
        }
      FreeGadgets(WindowInfo_ERRWINDO.FirstGadget);
      }
    }
    if (t->useWB) {   /* we've failed to open window and will exit; don't close somebody else's pubscreen */
       UnlockPubScreen(NULL, ScreenInfo_TESTMANA.Screen);
       ScreenInfo_TESTMANA.Screen = NULL;
    }

    return(FALSE);
}

/****** TstMgr_tm.c/CloseWindow_ERRWINDO *****************************
*
*   NAME
*   CloseWindow_ERRWINDO -- Close window "ERRWINDO".
*
*   SYNOPSIS
*   CloseWindow_ERRWINDO(TMData)
*
*   VOID CloseWindow_ERRWINDO(struct TMData *);
*
*   FUNCTION
*   Closes the window with label "ERRWINDO"
*   and frees its resources.
*
*   INPUTS
*   TMData  = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   OpenWindow_ERRWINDO()
*
**************************************************************
*
*/
VOID CloseWindow_ERRWINDO(struct TMData *TMData)
  {
  TM_RemoveWindow(&WindowInfo_ERRWINDO);
  }

/****** TstMgr_tm.c/DisableWindow_ERRWINDO *****************************
*
*   NAME
*   DisableWindow_ERRWINDO -- disable input to window "ERRWINDO".
*
*   SYNOPSIS
*   DisableWindow_ERRWINDO(TMData)
*
*   VOID DisableWindow_ERRWINDO(struct TMData *);
*
*   FUNCTION
*   Disables all input to window with label "ERRWINDO"
*   and changes its mouse pointer.
*
*   INPUTS
*   TMData  = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   EnableWindow_ERRWINDO()
*
**************************************************************
*
*/
VOID DisableWindow_ERRWINDO(struct TMData *TMData)
  {
  if((WindowInfo_ERRWINDO.DisableCount == 0) && (WindowInfo_ERRWINDO.Flags & TMWF_OPENED))
    {
    InitRequester(&WindowInfo_ERRWINDO.Requester);
    if(Request(&WindowInfo_ERRWINDO.Requester, WindowInfo_ERRWINDO.Window))
      {
      WindowInfo_ERRWINDO.Flags |= TMWF_DISABLED;
      SetPointer(WindowInfo_ERRWINDO.Window, WaitPointer, 16, 16, -6, 0);
      }
    }
  WindowInfo_ERRWINDO.DisableCount++;
  }

/****** TstMgr_tm.c/EnableWindow_ERRWINDO *****************************
*
*   NAME
*   EnableWindow_ERRWINDO -- enable input to window "ERRWINDO".
*
*   SYNOPSIS
*   EnableWindow_ERRWINDO(TMData)
*
*   VOID EnableWindow_ERRWINDO(struct TMData *);
*
*   FUNCTION
*   Enables input to window with label "ERRWINDO"
*   and clears its mouse pointer.
*
*   INPUTS
*   TMData  = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*   DisableWindow_ERRWINDO()
*
**************************************************************
*
*/
VOID EnableWindow_ERRWINDO(struct TMData *TMData)
  {
  WindowInfo_ERRWINDO.DisableCount--;
  if((WindowInfo_ERRWINDO.DisableCount == 0) && (WindowInfo_ERRWINDO.Flags & (TMWF_DISABLED | TMWF_OPENED)))
    {
    EndRequest(&WindowInfo_ERRWINDO.Requester, WindowInfo_ERRWINDO.Window);
    WindowInfo_ERRWINDO.Flags &= ~TMWF_DISABLED;
    ClearPointer(WindowInfo_ERRWINDO.Window);
    }
  }

/* *********************************************************** */
/* Static functions (available only to functions in this file) */
/* *********************************************************** */
 
static BOOL TM_WindowSignal(struct TMData *TMData) {
    BOOL done=FALSE;
    BOOL result;
    struct IntuiMessage *imessage;

    while (imessage = GT_GetIMsg(TMData->WindowMsgPort)) {
        if (imessage->IDCMPWindow == WindowInfo_ERRWINDO.Window) {
            if (result = WindowIDCMP_ERRWINDO(TMData, imessage)) 
                done = result;
        }

        GT_ReplyIMsg(imessage);
    }

    return(done);
}

static BOOL WindowIDCMP_ERRWINDO(struct TMData *TMData, struct IntuiMessage *imessage) {
    BOOL done=FALSE;
    BOOL result;

    switch (imessage->Class) {
        case IDCMP_REFRESHWINDOW:   /* Always refresh */
            GT_BeginRefresh(WindowInfo_ERRWINDO.Window);
            GT_EndRefresh(WindowInfo_ERRWINDO.Window, TRUE);
            break;

        case IDCMP_GADGETUP:
            if (result = Window_ERRWINDO_GADGETUP(TMData, imessage)) 
                done = result;
            break;

        case IDCMP_CLOSEWINDOW:
            if (result = Window_ERRWINDO_CLOSEWINDOW(TMData, imessage)) 
                done = result;
            break;

    }

    return(done);
}


/* This seems buggy! */
static VOID TM_RemoveWindow(struct TMWindowInfo *TMWindowInfo) {
/*    struct IntuiMessage *imessage;
    struct Node *succ;
*/
    struct Message *msg;

    if(TMWindowInfo->Window) {
        if (TMWindowInfo->Menu) {
          ClearMenuStrip(TMWindowInfo->Window);
          FreeMenus(TMWindowInfo->Menu);
          TMWindowInfo->Menu = NULL;
        }

        if (TMWindowInfo->Window->UserPort) {
            Forbid();
/*  This code seems to be for shared window msg ports.  Not Applicable to TstMgr.
            imessage = (struct IntuiMessage *) TMWindowInfo->Window->UserPort->mp_MsgList.lh_Head;
            while (succ = imessage->ExecMessage.mn_Node.ln_Succ) {
                if (imessage->IDCMPWindow == TMWindowInfo->Window) {
                    Remove((struct Node *) imessage);
                    ReplyMsg((struct Message *) imessage);
                }
                imessage = (struct IntuiMessage *) succ;
            }
*/
            while (msg = GetMsg(TMWindowInfo->Window->UserPort)) {
                ReplyMsg(msg);
            }
            TMWindowInfo->Window->UserPort = NULL;  /* It's a copy; original gets DeletePort()ed. */
            ModifyIDCMP(TMWindowInfo->Window, 0L);

            Permit();
        }

        CloseWindow(TMWindowInfo->Window);
        TMWindowInfo->Window = NULL;
        TMWindowInfo->Flags = NULL;
    }

    if (TMWindowInfo->FirstGadget) {
        FreeGadgets(TMWindowInfo->FirstGadget);
        TMWindowInfo->FirstGadget = NULL;
    }
}

