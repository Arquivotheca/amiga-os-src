head     39.10;
branch   ;
access   ;
symbols  ;
locks    davidj:39.10; strict;
comment  @ * @;


39.10
date     93.09.27.09.49.05;  author davidj;  state Exp;
branches ;
next     39.9;

39.9
date     93.05.25.10.26.41;  author davidj;  state Exp;
branches ;
next     39.8;

39.8
date     93.04.13.17.03.33;  author davidj;  state Exp;
branches ;
next     39.7;

39.7
date     93.04.02.09.32.32;  author davidj;  state Exp;
branches ;
next     39.6;

39.6
date     92.12.04.17.03.46;  author davidj;  state Exp;
branches ;
next     39.5;

39.5
date     92.12.02.14.47.42;  author davidj;  state Exp;
branches ;
next     39.4;

39.4
date     92.08.03.09.00.25;  author davidj;  state Exp;
branches ;
next     39.3;

39.3
date     92.07.23.17.31.19;  author davidj;  state Exp;
branches ;
next     39.2;

39.2
date     92.06.23.03.42.13;  author davidj;  state Exp;
branches ;
next     39.1;

39.1
date     92.06.19.03.57.18;  author davidj;  state Exp;
branches ;
next     39.0;

39.0
date     92.06.02.08.10.21;  author davidj;  state Exp;
branches ;
next     ;


desc
@initial RCS
@


39.10
log
@layout now handles NULL gadgetinfo
@
text
@/* dispatch.c
 *
 */

#include "asciibase.h"

/*****************************************************************************/

#define	G(o)	((struct Gadget *)(o))

/*****************************************************************************/

void NewList (struct List *);

/*****************************************************************************/

struct localData
{
    VOID	*lod_Pool;
    ULONG	 lod_Flags;
    LONG	 lod_MWidth;

    /* ANSI Decoding */
    BOOL	 lod_InSequence;
    BYTE	 lod_CharsInBuffer;
    BYTE	 lod_NumGoodChars;
    UBYTE	 lod_SaveBuffer[30];
    BYTE	 lod_ScanStep;
    SHORT	 lod_WhichANSI;
};

/*****************************************************************************/

#define	LDF_EUC		(1L<<0)

/*****************************************************************************/

static ULONG setdtattrs (struct ASCIILib * ascii, Object * o, ULONG data,...)
{
    return (SetDTAttrsA (o, NULL, NULL, (struct TagItem *) & data));
}

/*****************************************************************************/

static ULONG getdtattrs (struct ASCIILib * ascii, Object * o, ULONG data,...)
{
    return (GetDTAttrsA (o, (struct TagItem *) & data));
}

/*****************************************************************************/

static ULONG notifyAttrChanges (struct ASCIILib * ascii, Object * o, VOID * ginfo, ULONG flags, ULONG tag1,...)
{
    return DoMethod (o, OM_NOTIFY, &tag1, ginfo, flags);
}

/*****************************************************************************/

#define	ATTR_UNDERLINE	1
#define	ATTR_HIGHLIGHT	2
#define ATTR_BLINK	4
#define	ATTR_INVERSE	8

/*****************************************************************************/

#define	CSI	0x9B

/* External comparison routines. */
extern BYTE __stdargs Num1 (WORD Char);
extern BYTE __stdargs Num2 (WORD Char);
extern BYTE __stdargs Num3 (WORD Char);
extern BYTE __stdargs Num4 (WORD Char);

 /* This structure describes an ANSI control sequence. */
struct ControlCode
{
    UBYTE FirstChar;
    BYTE (*__stdargs Match) (WORD Char);
    UBYTE LastChar;

    BYTE ExactSize;
    WORD Func;
};

/*****************************************************************************/

/* At present 55 different control sequences are supported/trapped. */
#define NUM_CODES 55

/* This follows the control code information. */
static struct ControlCode ANSICode[] =
{
 /* Single Character Sequences. */

    'D', NULL, 0, 1, 0,		/* CursorScrollDown, */
    'M', NULL, 0, 1, 0,		/* CursorScrollUp, */
    'E', NULL, 0, 1, 0,		/* NextLine, */
    '7', NULL, 0, 1, 0,		/* SaveCursor, */
    '8', NULL, 0, 1, 0,		/* LoadCursor, */
    '=', NULL, 0, 1, 0,		/* NumericAppMode, */
    '>', NULL, 0, 1, 0,		/* NumericAppMode, */
    'N', NULL, 0, 1, 0,		/* Ignore, */
    'O', NULL, 0, 1, 0,		/* Ignore, */
    'H', NULL, 0, 1, 0,		/* SetTab, */
    'Z', NULL, 0, 1, 0,		/* RequestTerminal, */
    'c', NULL, 0, 1, 0,		/* Reset, */
    '<', NULL, 0, 1, 0,		/* Ignore, */
    '~', NULL, 0, 1, 0,		/* Ignore, */
    'n', NULL, 0, 1, 0,		/* Ignore, */
    '}', NULL, 0, 1, 0,		/* Ignore, */
    'o', NULL, 0, 1, 0,		/* Ignore, */
    '|', NULL, 0, 1, 0,		/* Ignore, */

 /* Double Character Sequences. */

    '[', NULL, 's', 2, 0,	/* SaveCursor, */
    '[', NULL, 'u', 2, 0,	/* LoadCursor, */
    '(', NULL, 'A', 2, 0,	/* FontStuff, */
    '(', NULL, 'B', 2, 0,	/* FontStuff, */
    '(', NULL, '0', 2, 0,	/* FontStuff, */
    ')', NULL, 'A', 2, 0,	/* FontStuff, */
    ')', NULL, 'B', 2, 0,	/* FontStuff, */
    ')', NULL, '0', 2, 0,	/* FontStuff, */
    '#', NULL, '3', 2, 0,	/* ScaleFont, */
    '#', NULL, '4', 2, 0,	/* ScaleFont, */
    '#', NULL, '5', 2, 0,	/* ScaleFont, */
    '#', NULL, '6', 2, 0,	/* ScaleFont, */
    '#', NULL, '8', 2, 0,	/* Ignore, */
    ' ', NULL, 'F', 2, 0,	/* Ignore, */
    ' ', NULL, 'G', 2, 0,	/* Ignore, */

 /* Multiple Character Sequence. */

    '[', Num3, 'i', 0, 0,	/* Ignore, */
    '[', Num3, 'n', 0, 0,	/* RequestInformation, */
    '[', Num3, 'c', 0, 0,	/* RequestTerminal, */
    '[', Num3, 'h', 0, 0,	/* SetSomething, */
    '[', Num3, 'l', 0, 0,	/* SetSomething, */

    '[', Num4, 'h', 0, 0,	/* Ignore, */

    '[', Num1, 'A', 0, 0,	/* MoveCursor, */
    '[', Num1, 'B', 0, 0,	/* MoveCursor, */
    '[', Num1, 'C', 0, 0,	/* MoveCursor, */
    '[', Num1, 'D', 0, 0,	/* MoveCursor, */
    '[', Num1, 'K', 0, 0,	/* EraseLine, */
    '[', Num1, 'J', 0, 0,	/* EraseScreen, */
    '[', Num1, 'P', 0, 0,	/* EraseCharacters, */
    '[', Num1, 'L', 0, 0,	/* InsertLine, */
    '[', Num1, 'M', 0, 0,	/* ClearLine, */
    '[', Num1, 'g', 0, 0,	/* SetTabs, */
    '[', Num1, 'q', 0, 0,	/* Ignore, */

    '[', Num2, 'H', 0, 0,	/* SetPosition, */
    '[', Num2, 'f', 0, 0,	/* SetPosition, */
    '[', Num2, 'm', 0, 1,	/* SetAttributes, */
    '[', Num2, 'y', 0, 0,	/* Ignore, */
    '[', Num2, 'r', 0, 0,	/* SetRegion, */
};

/*****************************************************************************/

static void DoCancel (Class * cl, Object * o)
{
    struct localData *lod = INST_DATA (cl, o);

    lod->lod_InSequence = FALSE;
    lod->lod_NumGoodChars = lod->lod_CharsInBuffer = lod->lod_ScanStep = 0;
}

/*****************************************************************************/

static BOOL ParseCode (Class * cl, Object * o, UBYTE c)
{
    struct localData *lod = INST_DATA (cl, o);
    SHORT i;

    /* ScanStep = 0:	This is the first character to introduce a control sequence. */
    if (!lod->lod_ScanStep)
    {
	/* Scan all available codes and try to find a match. */
	for (i = 0; i < NUM_CODES; i++)
	{
	    /* This character may introduce a control sequence. */
	    if (ANSICode[i].FirstChar == c)
	    {
		/*
		 * If this is a single character control sequence call the approriate function and exit immediately.
		 */
		if (ANSICode[i].ExactSize == 1)
		{
		    lod->lod_SaveBuffer[lod->lod_CharsInBuffer++] = c;
		    lod->lod_SaveBuffer[lod->lod_CharsInBuffer] = 0;
		    lod->lod_NumGoodChars = lod->lod_CharsInBuffer;
		    lod->lod_CharsInBuffer = lod->lod_ScanStep = 0;
		    lod->lod_WhichANSI = i;
		    return (FALSE);
		}

		/*
		 * The length of this control sequence is greater than a single character. Save the input character and return.
		 */
		lod->lod_ScanStep = i;
		lod->lod_SaveBuffer[lod->lod_CharsInBuffer++] = c;
		lod->lod_SaveBuffer[lod->lod_CharsInBuffer] = 0;
		return (TRUE);
	    }
	}

	/* No control sequence introducing character was found. */
	/* No Match */
	lod->lod_NumGoodChars = lod->lod_CharsInBuffer = lod->lod_ScanStep = 0;
	return (FALSE);
    }
    else
    {
	/* Length of the control sequence overrides the boundary, exit immediately! */
	if (lod->lod_CharsInBuffer == 21)
	{
	    /* No Match */
	    lod->lod_NumGoodChars = lod->lod_CharsInBuffer = lod->lod_ScanStep = 0;
	    return (FALSE);
	}

	/* Scan the remaining codes for a match. */
	for (i = lod->lod_ScanStep; i < NUM_CODES; i++)
	{

	    /*
	     * This sequence begins with the same character the parser was initialized with, so let's take a look at it.
	     */
	    if (ANSICode[i].FirstChar == lod->lod_SaveBuffer[0])
	    {
		/* This character is supposed to terminate the sequence. So let's exit. */
		if (ANSICode[i].LastChar == c)
		{
		    lod->lod_SaveBuffer[lod->lod_CharsInBuffer++] = c;
		    lod->lod_SaveBuffer[lod->lod_CharsInBuffer] = 0;
		    lod->lod_NumGoodChars = lod->lod_CharsInBuffer;
		    lod->lod_CharsInBuffer = lod->lod_ScanStep = 0;
		    lod->lod_WhichANSI = i;
		    return (FALSE);
		}
		else
		{
		    if (ANSICode[i].Match)
		    {
			/* This character is part of a legal sequence. Store it and return. */
			if ((*(ANSICode[i].Match)) (c))
			{
			    lod->lod_ScanStep = i;
			    lod->lod_SaveBuffer[lod->lod_CharsInBuffer++] = c;
			    return (TRUE);
			}
		    }
		}
	    }
	}

	/* This character is not part of a valid ANSI control sequence, so exit. */
	/* No Match */
	lod->lod_NumGoodChars = lod->lod_CharsInBuffer = lod->lod_ScanStep = 0;
	return (FALSE);
    }
}

/*****************************************************************************/

static void CSIFake (Class * cl, Object * o)
{
    struct localData *lod = INST_DATA (cl, o);

    /* Reset scanner */
    DoCancel (cl, o);

    /* Perform as if ESC [ had been transmitted. */
    lod->lod_InSequence = ParseCode (cl, o, '[');
}

/*****************************************************************************/

static UBYTE *ReadValue (UBYTE * Buffer, SHORT * Value)
{
    while ((*Buffer < '0' || *Buffer > '9') && *Buffer)
	Buffer++;

    if (*Buffer)
    {
	*Value = 0;
	while (*Buffer >= '0' && *Buffer <= '9')
	    *Value = (*Value * 10) + (*Buffer++ - '0');
    }
    else
	*Value = -1;

    if (*Buffer == ';' || *Buffer == ' ')
	return (&Buffer[1]);
    else
	return (NULL);
}

/*****************************************************************************/

ULONG layoutMethod (struct ASCIILib * ascii, Class * cl, Object * o, struct gpLayout * gpl)
{
    struct DTSpecialInfo *si = (struct DTSpecialInfo *) G (o)->SpecialInfo;
    struct localData *lod = INST_DATA (cl, o);
    ULONG style = FS_NORMAL;
    struct TextFont *font;
    BOOL noprint = FALSE;
    struct RastPort trp;
    struct IBox *domain;
    ULONG hunit, hwidth;
    struct Line *line;
    STRPTR escbuffer;
    STRPTR title;
    LONG tspace;
    LONG offset;		/* Segment offset */
    LONG twidth;		/* Width of tab	 */
    LONG swidth;		/* Segment width */
    LONG lwidth;		/* Total line width */
    LONG anchor;		/* Beginning of	current	segment	 */
    WORD *space;
    WORD lspace;
    LONG width;			/* Width of view area */
    WORD *kern;
    BOOL split;
    ULONG bsig;
    LONG tabs;			/* Number of tabs */
    LONG chs;			/* Number of characters	 */
    LONG len;
    LONG num;
    LONG i;
    BOOL lf;
    WORD ch;

    BYTE fgpen = 1, bgpen = 0;
    BYTE attributes = 0;
    BYTE tmpen;
    WORD value;

    struct TextAttr *tattr;
    struct List *linelist;
    UBYTE smallbuffer[1];
    ULONG wrap = FALSE;
    BOOL send = FALSE;
    ULONG bufferlen;
    STRPTR buffer;
    ULONG visible;
    ULONG total;

    if (gpl->gpl_GInfo)
    {
	fgpen = gpl->gpl_GInfo->gi_DrInfo->dri_Pens[TEXTPEN];
	bgpen = gpl->gpl_GInfo->gi_DrInfo->dri_Pens[BACKGROUNDPEN];
    }

    /* Get the information that is required */
    if ((i = getdtattrs (ascii, o,
			 DTA_TextAttr,	(ULONG) &tattr,
			 DTA_TextFont,	(ULONG) &font,
			 TDTA_Buffer,	(ULONG) &buffer,
			 TDTA_BufferLen,(ULONG) &bufferlen,
			 TDTA_LineList,	(ULONG) &linelist,
			 TDTA_WordWrap,	(ULONG) &wrap,
			 DTA_Domain,	(ULONG) &domain,
			 DTA_ObjName,	(ULONG) &title,
			 TAG_DONE)) >= 7)
    {
	/* Obtain a lock on our data */
	ObtainSemaphore (&(si->si_Lock));

	/* Cache the information that we need */
	width = (LONG) domain->Width;
	space = (WORD *) (font->tf_CharSpace);
	kern  = (WORD *) (font->tf_CharKern);
	total = si->si_TotVert;

	/* Make sure we have a buffer to operate on */
	if (buffer)
	{
	    /* Make sure we are supposed to layout the text */
	    if (wrap || gpl->gpl_Initial)
	    {
		InitRastPort (&trp);
		SetFont (&trp, font);

		split = FALSE;
		send = TRUE;
		lf = FALSE;
		offset = 0;
		swidth = 0;
		lwidth = 0;
		tabs = 0;
		chs = 0;
		num = 0;
		len = 0;
		lspace = -1;

#if 1
		tspace = TextLength (&trp, " ", 1) * 8;
#else
		tspace = (space && kern) ? 64 : (font->tf_XSize * 8);
#endif

		DoCancel (cl, o);

		/* Delete the old line list */
		while (line = (struct Line *) RemHead (linelist))
		    FreePooled (lod->lod_Pool, line, sizeof (struct Line));

		for (anchor = i = bsig = 0; (i <= bufferlen) && (bsig == 0); i++)
		{
		    len++;
		    ch = buffer[i];

		    if (lod->lod_InSequence)
		    {
			if (ch == 27)
			{
			    num++;
			    DoCancel (cl, o);
			    lod->lod_InSequence = TRUE;
			}
			else if (ch == CSI)
			{
			    num++;
			    CSIFake (cl, o);
			}
			else if (lod->lod_InSequence = ParseCode (cl, o, ch))
			{
			    num++;
			}
			else
			{
			    if (lod->lod_NumGoodChars)
			    {
				escbuffer = &lod->lod_SaveBuffer[0];
				switch (ANSICode[lod->lod_WhichANSI].Func)
				{
				    case 1:
					do
					{
					    escbuffer = ReadValue (escbuffer, &value);

					    if (value == -1)
						value = 0;

					    switch (value)
					    {
						case 0:
						    attributes = 0;
						    style = FS_NORMAL;
						    fgpen = 1;
						    bgpen = 0;
						    if (gpl->gpl_GInfo)
						    {
							fgpen = gpl->gpl_GInfo->gi_DrInfo->dri_Pens[TEXTPEN];
							bgpen = gpl->gpl_GInfo->gi_DrInfo->dri_Pens[BACKGROUNDPEN];
						    }
						    break;

						case 1:
						    attributes |= ATTR_HIGHLIGHT;
						    style |= FSF_BOLD;
						    break;

						case 3:
						    style |= FSF_ITALIC;
						    break;

						case 4:
						    attributes |= ATTR_UNDERLINE;
						    style |= FSF_UNDERLINED;
						    break;

						case 5:
						    attributes |= ATTR_BLINK;
						    break;

						case 7:
						    attributes |= ATTR_INVERSE;
						    tmpen = fgpen;
						    fgpen = bgpen;
						    bgpen = tmpen;
						    break;

						default:
						    if (value >= 30)
						    {
							if (value <= 37)
							{
							    if (attributes & ATTR_INVERSE)
								bgpen = value - 30;
							    else
								fgpen = value - 30;
							}
							else
							{
							    if (value >= 40 && value <= 47)
							    {
								if (attributes & ATTR_INVERSE)
								    fgpen = value - 40;
								else
								    bgpen = value - 40;
							    }
							}
						    }
						    else if (value >= 20)
						    {
							switch (value - 20)
							{
							    case 2:
								attributes &= ~ATTR_HIGHLIGHT;
								style &= ~FSF_BOLD;
								break;

							    case 3:
								style &= ~FSF_ITALIC;
								break;

							    case 4:
								attributes &= ~ATTR_UNDERLINE;
								style &= ~FSF_UNDERLINED;
								break;
							}
						    }

						    break;
					    }
					}
					while (escbuffer);
					break;
				}
			    }

			    DoCancel (cl, o);
			    noprint = split = TRUE;
			}
		    }
		    else if ((ch == 27) || (ch == CSI))
		    {
			split = lod->lod_InSequence = TRUE;
		    }
		    else if (ch == '\t')
		    {
			if (chs)
			{
			    split = TRUE;
			}
			else
			{
			    if (tabs++ || !lwidth)
				twidth = tspace;
			    else
				twidth = (((lwidth / tspace) + 1) * tspace) - lwidth;

			    noprint = TRUE;
			    if (!wrap || (swidth + twidth <= width - offset))
			    {
				offset += twidth;
				swidth += twidth;
				lwidth += twidth;
				num++;
			    }
			    else
			    {
				lf = TRUE;
			    }
			}
		    }
		    else if (ch == '\r')
		    {
			split = TRUE;
		    }
		    else if ((ch == '\n') || (ch == 0) || (ch == 12))
		    {
			lf = TRUE;
		    }
		    else
		    {
			if (tabs)
			{
			    num--;
			    noprint = split = TRUE;
			}
			else
			{
			    if ((lod->lod_Flags & LDF_EUC) || (space && kern))
			    {
				smallbuffer[0] = ch;
				twidth = TextLength (&trp, smallbuffer, 1);
			    }
			    else
				twidth = font->tf_XSize;

			    if ((num == 0) && (style & FSF_ITALIC))
				offset += font->tf_XSize / 3;

			    if (!wrap || (swidth + twidth <= width - offset))
			    {
				swidth += twidth;
				lwidth += twidth;
				num++;
			    }
			    else
			    {
				lf = TRUE;
				if (lspace >= 0)
				    num -= (i - lspace);
			    }

			    chs++;
			    if (ch == ' ')
				lspace = i;
			}
		    }

		    if (lf || split || (wrap && (swidth > (width - offset))))
		    {
			if (noprint)
			{
			    if (line && lf)
			    {
				line->ln_Flags |= LNF_LF;
				lwidth = 0;
				offset = 0;
			    }
			}
			else
			{
			    if (line = AllocPooled (lod->lod_Pool, sizeof (struct Line)))
			    {
				SetSoftStyle (&trp, style, 0xFF);
				swidth = TextLength (&trp, &buffer[anchor], num);

				line->ln_Text    = &buffer[anchor];
				line->ln_TextLen = num;
				line->ln_XOffset = offset;
				line->ln_Width   = swidth;
				line->ln_Flags   = NULL;
				line->ln_FgPen   = fgpen;
				line->ln_BgPen   = bgpen;
				line->ln_Style   = style;
				line->ln_Data    = NULL;
				AddTail (linelist, (struct Node *) line);

				if (lf || (wrap && (swidth > (width - offset))))
				{
				    line->ln_Flags |= LNF_LF;
				    lod->lod_MWidth = MAX (lod->lod_MWidth, lwidth);
				    lwidth = 0;
				    offset = 0;
				}
				else
				{
				    offset += swidth;
				}
			    }

			    if (!lf && num && (num < len))
			    {
				num--;
			    }
			    else if ((ch == CSI) && (num == 0))
			    {
				num = -1;
			    }
			}

			i = anchor + num;
			anchor = i + 1;

			lspace = -1;
			chs = tabs = num = len = swidth = 0;
			split = lf = noprint = FALSE;

			/* Aborted? */
			bsig = CheckSignal (SIGBREAKF_CTRL_C);
		    }
		}

		/* Force a recount, because some of the partial lines may not have been added to the list. */
		total = 0;
		line = (struct Line *) linelist;
		while (line->ln_Link.mln_Succ && i)
		{
		    if (line->ln_Flags & LNF_LF)
			total++;
		    line = (struct Line *) line->ln_Link.mln_Succ;
		}
	    }
	}

	if ((space && kern) || (lod->lod_Flags & LDF_EUC))
	{
	    si->si_HorizUnit = hunit = 1;
	    hwidth = lod->lod_MWidth;
	}
	else
	{
	    si->si_HorizUnit = hunit = font->tf_XSize;
	    hwidth = lod->lod_MWidth / font->tf_XSize;
	}

	si->si_VisVert = visible = domain->Height / si->si_VertUnit;
	si->si_TotVert = total;

	si->si_VisHoriz = (LONG) domain->Width / hunit;
	si->si_TotHoriz = hwidth;

	si->si_VertUnit = font->tf_YSize;

	/* Check for abortion */
	if (CheckSignal (SIGBREAKF_CTRL_C))
	    bsig++;

	/* Were we aborted? */
	if (send && (bsig == 0))
	{
	    /* Tell everyone about our changes */
	    notifyAttrChanges (ascii, o, gpl->gpl_GInfo, NULL,
			       GA_ID,		G (o)->GadgetID,
			       DTA_Title,	title,
			       TAG_DONE);
	}

	/* Release the lock */
	ReleaseSemaphore (&(si->si_Lock));
    }

    return (total);
}

/*****************************************************************************/

static ULONG ASM dispatch (REG (a0) Class * cl, REG (a2) Object * o, REG (a1) Msg msg)
{
    struct ASCIILib *ascii = (struct ASCIILib *) cl->cl_UserData;
    struct localData *lod;
    Object *newobj;
    ULONG retval;

    switch (msg->MethodID)
    {
	case OM_NEW:
	    if (newobj = (Object *) DoSuperMethodA (cl, o, msg))
	    {
		ULONG len, estlines, poolsize;
		struct DataTypeHeader *dth;
		struct DataType *dtn;
		UWORD dtype;

		lod = INST_DATA (cl, newobj);

		/* Get the handles */
		getdtattrs (ascii, newobj,
			    DTA_DataType, (ULONG) &dtn,
			    TDTA_BufferLen, (ULONG)&len,
			    TAG_DONE);

		/* Estimate the pool size that we will need */
		estlines = (len / 80) + 1;
		estlines = (estlines > 200) ? 200 : estlines;
		poolsize = sizeof (struct Line) * estlines;

		/* Create a message for the lines */
		if (lod->lod_Pool = CreatePool (MEMF_CLEAR | MEMF_PUBLIC, poolsize, poolsize))
		{
		    /* See if we are EUC or not */
		    if (dtn)
		    {
			dth = dtn->dtn_Header;
			dtype = dth->dth_Flags & DTF_TYPE_MASK;
			if ((dtype == DTF_BINARY) && (Stricmp (dth->dth_Name, "EUC") == 0))
			    lod->lod_Flags |= LDF_EUC;
		    }
		}
		else
		{
		    CoerceMethod (cl, newobj, OM_DISPOSE);
		    newobj = NULL;
		}
	    }
	    retval = (ULONG) newobj;
	    break;

	case OM_UPDATE:
	case OM_SET:
	    if ((retval = DoSuperMethodA (cl, o, msg)) && (OCLASS (o) == cl))
	    {
		struct RastPort *rp;

		/* Get a pointer to the rastport */
		if (rp = ObtainGIRPort (((struct opSet *) msg)->ops_GInfo))
		{
		    struct gpRender gpr;

		    /* Force a redraw */
		    gpr.MethodID   = GM_RENDER;
		    gpr.gpr_GInfo  = ((struct opSet *) msg)->ops_GInfo;
		    gpr.gpr_RPort  = rp;
		    gpr.gpr_Redraw = GREDRAW_UPDATE;
		    DoMethodA (o, &gpr);

		    /* Release the temporary rastport */
		    ReleaseGIRPort (rp);
		}
		retval = 0;
	    }
	    break;

	case GM_LAYOUT:
	    notifyAttrChanges (ascii, o, ((struct gpLayout *) msg)->gpl_GInfo, NULL,
			       GA_ID, G (o)->GadgetID,
			       DTA_Busy, TRUE,
			       TAG_DONE);

	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    retval += DoAsyncLayout (o, (struct gpLayout *) msg);
	    break;

	case DTM_PROCLAYOUT:
	    notifyAttrChanges (ascii, o, ((struct gpLayout *) msg)->gpl_GInfo, NULL,
			       GA_ID, G (o)->GadgetID,
			       DTA_Busy, TRUE,
			       TAG_DONE);
	    DoSuperMethodA (cl, o, msg);

	case DTM_ASYNCLAYOUT:
	    retval = layoutMethod (ascii, cl, o, (struct gpLayout *) msg);
	    break;

	case OM_DISPOSE:
	    {
		struct List *linelist;

		lod = INST_DATA (cl, o);

		/* Don't let the super class free the line list */
		if (getdtattrs (ascii, o, TDTA_LineList, (ULONG) &linelist, TAG_DONE) && linelist)
		    NewList (linelist);

		/* Delete the line list */
		DeletePool (lod->lod_Pool);
	    }

	    /* Let the superclass handle everything else */
	default:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    break;
    }

    return (retval);
}

/*****************************************************************************/

Class *initClass (struct ASCIILib * ascii)
{
    Class *cl;

    if (cl = MakeClass (ASCIIDTCLASS, TEXTDTCLASS, NULL, sizeof (struct localData), 0L))
    {
	cl->cl_Dispatcher.h_Entry = (ULONG (*)()) dispatch;
	cl->cl_UserData = (ULONG) ascii;
	AddClass (cl);
    }

    return (cl);
}
@


39.9
log
@fixed tab problem
fixed pen problem
@
text
@a65 138
Class *initClass (struct ASCIILib * ascii)
{
    Class *cl;

    if (cl = MakeClass (ASCIIDTCLASS, TEXTDTCLASS, NULL, sizeof (struct localData), 0L))
    {
	cl->cl_Dispatcher.h_Entry = Dispatch;
	cl->cl_UserData = (ULONG) ascii;
	AddClass (cl);
    }

    return (cl);
}

/*****************************************************************************/

ULONG ASM Dispatch (REG (a0) Class * cl, REG (a2) Object * o, REG (a1) Msg msg)
{
    struct ASCIILib *ascii = (struct ASCIILib *) cl->cl_UserData;
    struct localData *lod;
    Object *newobj;
    ULONG retval;

    switch (msg->MethodID)
    {
	case OM_NEW:
	    if (newobj = (Object *) DoSuperMethodA (cl, o, msg))
	    {
		ULONG len, estlines, poolsize;
		struct DataTypeHeader *dth;
		struct DataType *dtn;
		UWORD dtype;

		lod = INST_DATA (cl, newobj);

		/* Get the handles */
		getdtattrs (ascii, newobj,
			    DTA_DataType, (ULONG) &dtn,
			    TDTA_BufferLen, (ULONG)&len,
			    TAG_DONE);

		/* Estimate the pool size that we will need */
		estlines = (len / 80) + 1;
		estlines = (estlines > 200) ? 200 : estlines;
		poolsize = sizeof (struct Line) * estlines;

		/* Create a message for the lines */
		if (lod->lod_Pool = CreatePool (MEMF_CLEAR | MEMF_PUBLIC, poolsize, poolsize))
		{
		    /* See if we are EUC or not */
		    if (dtn)
		    {
			dth = dtn->dtn_Header;
			dtype = dth->dth_Flags & DTF_TYPE_MASK;
			if ((dtype == DTF_BINARY) && (Stricmp (dth->dth_Name, "EUC") == 0))
			    lod->lod_Flags |= LDF_EUC;
		    }
		}
		else
		{
		    CoerceMethod (cl, newobj, OM_DISPOSE);
		    newobj = NULL;
		}
	    }
	    retval = (ULONG) newobj;
	    break;

	case OM_UPDATE:
	case OM_SET:
	    if ((retval = DoSuperMethodA (cl, o, msg)) && (OCLASS (o) == cl))
	    {
		struct RastPort *rp;

		/* Get a pointer to the rastport */
		if (rp = ObtainGIRPort (((struct opSet *) msg)->ops_GInfo))
		{
		    struct gpRender gpr;

		    /* Force a redraw */
		    gpr.MethodID   = GM_RENDER;
		    gpr.gpr_GInfo  = ((struct opSet *) msg)->ops_GInfo;
		    gpr.gpr_RPort  = rp;
		    gpr.gpr_Redraw = GREDRAW_UPDATE;
		    DoMethodA (o, &gpr);

		    /* Release the temporary rastport */
		    ReleaseGIRPort (rp);
		}
		retval = 0;
	    }
	    break;

	case GM_LAYOUT:
	    notifyAttrChanges (ascii, o, ((struct gpLayout *) msg)->gpl_GInfo, NULL,
			       GA_ID, G (o)->GadgetID,
			       DTA_Busy, TRUE,
			       TAG_DONE);

	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    retval += DoAsyncLayout (o, (struct gpLayout *) msg);
	    break;

	case DTM_PROCLAYOUT:
	    notifyAttrChanges (ascii, o, ((struct gpLayout *) msg)->gpl_GInfo, NULL,
			       GA_ID, G (o)->GadgetID,
			       DTA_Busy, TRUE,
			       TAG_DONE);
	    DoSuperMethodA (cl, o, msg);

	case DTM_ASYNCLAYOUT:
	    retval = layoutMethod (ascii, cl, o, (struct gpLayout *) msg);
	    break;

	case OM_DISPOSE:
	    {
		struct List *linelist;

		lod = INST_DATA (cl, o);

		/* Don't let the super class free the line list */
		if (getdtattrs (ascii, o, TDTA_LineList, (ULONG) &linelist, TAG_DONE) && linelist)
		    NewList (linelist);

		/* Delete the line list */
		DeletePool (lod->lod_Pool);
	    }

	    /* Let the superclass handle everything else */
	default:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    break;
    }

    return (retval);
}

/*****************************************************************************/

d337 1
a338 2
    BYTE fgpen = gpl->gpl_GInfo->gi_DrInfo->dri_Pens[TEXTPEN];
    BYTE bgpen = gpl->gpl_GInfo->gi_DrInfo->dri_Pens[BACKGROUNDPEN];
d352 6
d454 7
a460 2
						    fgpen = gpl->gpl_GInfo->gi_DrInfo->dri_Pens[TEXTPEN];
						    bgpen = gpl->gpl_GInfo->gi_DrInfo->dri_Pens[BACKGROUNDPEN];
d733 138
@


39.8
log
@removed extra notify
@
text
@d476 2
a477 2
    BYTE fgpen = 1;
    BYTE bgpen = 0;
d532 4
d537 1
d587 2
a588 2
						    fgpen = 1;
						    bgpen = 0;
@


39.7
log
@handles layout better
@
text
@d9 3
a11 3
#define	DB(x)	;
#define	DL(x)	;
#define	DR(x)	;
d13 1
a13 1
#define	G(o)	((struct Gadget *)(o))
d38 1
a38 1
ULONG setdtattrs (struct ASCIILib * ascii, Object * o, ULONG data,...)
d45 1
a45 1
ULONG getdtattrs (struct ASCIILib * ascii, Object * o, ULONG data,...)
d52 1
a52 1
ULONG notifyAttrChanges (struct ASCIILib * ascii, Object * o, VOID * ginfo, ULONG flags, ULONG tag1,...)
d173 1
a173 1
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
d229 1
a229 1
struct ControlCode ANSICode[] =
d301 1
a301 1
void DoCancel (Class * cl, Object * o)
d311 1
a311 1
BOOL ParseCode (Class * cl, Object * o, UBYTE c)
d407 1
a407 1
void CSIFake (Class * cl, Object * o)
d483 4
a487 1
    ULONG bufferlen;
a489 9
    ULONG wrap = FALSE;

    UBYTE smallbuffer[2];

    smallbuffer[1] = 0;

    DL (kprintf ("\nascii : layout v=%ld,%ld,%ld, h=%ld,%ld,%ld\n",
	si->si_TopVert, si->si_VisVert, si->si_TotVert,
	si->si_TopHoriz,si->si_VisHoriz,si->si_TotHoriz));
d491 1
d493 8
a500 8
			 DTA_TextAttr, (ULONG) & tattr,
			 DTA_TextFont, (ULONG) & font,
			 TDTA_Buffer, (ULONG) & buffer,
			 TDTA_BufferLen, (ULONG) & bufferlen,
			 TDTA_LineList, (ULONG) & linelist,
			 TDTA_WordWrap, (ULONG)&wrap,
			 DTA_Domain, (ULONG) & domain,
			 DTA_ObjName, (ULONG) & title,
d503 1
a503 1
	DL (kprintf ("ascii : obtain si_Lock (l)\n"));
d506 1
a507 1

d509 2
a510 17
	kern = (WORD *) (font->tf_CharKern);

	InitRastPort (&trp);
	SetFont (&trp, font);

	split = FALSE;
	lf = FALSE;
	total = 0;
	offset = 0;
	swidth = 0;
	lwidth = 0;
	tabs = 0;
	chs = 0;
	num = 0;
	len = 0;
	lspace = -1;
	tspace = (space && kern) ? 64 : (font->tf_XSize * 8);
d512 1
d515 1
a515 2
	    DL (kprintf ("ascii : buffer length %ld\n", bufferlen));

d518 16
a711 1
#if 1
a716 19
#else
			    if (lod->lod_Flags & LDF_EUC)
			    {
				twidth = TextLength (&trp, (STRPTR) &ch, 1);
			    }
			    else if (space && kern)
			    {
				WORD cn;

				if ((ch > font->tf_HiChar) || (ch < font->tf_LoChar))
				    ch = font->tf_HiChar;
				cn = ch - font->tf_LoChar;

				if ((num == 0) && (kern[cn] < 0))
				    offset += ABS (kern[cn]);

				twidth = space[cn] + kern[cn];
			    }
#endif
a750 1
				total++;
a776 1
				    total++;
d805 10
a816 6
	else
	{
	    DL (kprintf ("ascii : buffer empty\n"));
	}

	DL (kprintf ("vis=%ld, tot=%ld\n", (LONG) domain->Width, lod->lod_MWidth));
a828 15
	/* Force a recount, because some of the partial lines may not have been added to the list. */
	{
	    struct Line *ln;
	    LONG count = 0;

	    ln = (struct Line *) linelist;
	    while (ln->ln_Link.mln_Succ && i)
	    {
		if (ln->ln_Flags & LNF_LF)
		    count++;
		ln = (struct Line *) ln->ln_Link.mln_Succ;
	    }
	    total = count;
	}

d837 3
a839 4
	DL (kprintf ("ascii : hu=%ld, vh=%ld, th=%ld\n", si->si_HorizUnit, si->si_VisHoriz, si->si_TotHoriz));

	ReleaseSemaphore (&(si->si_Lock));
	DL (kprintf ("ascii : release si_Lock (l)\n"));
d841 2
a842 1
	if (bsig == 0)
d844 1
a844 1
	    DB (kprintf ("ascii : notify changes\n"));
d846 2
a847 14
			       GA_ID, G (o)->GadgetID,

			       DTA_VisibleVert, visible,
			       DTA_TotalVert, total,
			       DTA_NominalVert, total,

			       DTA_VisibleHoriz, domain->Width / hunit,
			       DTA_TotalHoriz, hwidth,
			       DTA_NominalHoriz, hwidth,
			       DTA_HorizUnit, hunit,

			       DTA_Title, title,
			       DTA_Busy, FALSE,
			       DTA_Sync, TRUE,
d850 3
a852 4
    }
    else
    {
	DL (kprintf ("couldn't get enough information to layout\n"));
a853 4

    DL (kprintf ("ascii : done v=%ld,%ld,%ld, h=%ld,%ld,%ld\n",
	si->si_TopVert, si->si_VisVert, si->si_TotVert,
	si->si_TopHoriz,si->si_VisHoriz,si->si_TotHoriz));
@


39.6
log
@render speedup
@
text
@d489 4
d699 4
d719 2
a720 1
				twidth = TextLength (&trp, (STRPTR) &ch, 1);
@


39.5
log
@CSI introducer not handled properly.
@
text
@d19 1
a20 1

d94 1
d102 4
a105 1
		getdtattrs (ascii, newobj, DTA_DataType, (ULONG) &dtn, TAG_DONE);
d107 18
a124 2
		/* See if we are EUC or not */
		if (dtn)
d126 2
a127 4
		    dth = dtn->dtn_Header;
		    dtype = dth->dth_Flags & DTF_TYPE_MASK;
		    if ((dtype == DTF_BINARY) && (Stricmp (dth->dth_Name, "EUC") == 0))
			lod->lod_Flags |= LDF_EUC;
a148 1
		    DR (kprintf ("ascii force %ld\n", GREDRAW_UPDATE));
a158 1
	    DB (kprintf ("ascii : gm_layout\n"));
a164 2

	    DB (kprintf ("ascii : task, spawn process\n"));
a165 1
	    DB (kprintf ("ascii : gm_layout done\n"));
a168 1
	    DB (kprintf ("ascii : dtm_proclayout\n"));
a175 1
	    DB (kprintf ("ascii : gm_asynclayout\n"));
a176 1
	    DB (kprintf ("ascii : gm_asynclayout done\n"));
d179 14
d216 1
a216 1
     BYTE (*__stdargs Match) (WORD Char);
a324 1

a421 1

a473 1
    WORD cn;
a526 1
	total = si->si_TotVert;
d535 2
d538 1
a538 1
		    FreeVec (line);
d709 4
a712 1
			    twidth = TextLength (&trp, &ch, 1);
a713 1
			    /* font->tf_Flags & FPF_PROPORTIONAL) */
d716 1
a716 1
				twidth = TextLength (&trp, &ch, 1);
d720 2
d731 1
a733 1
#endif
d771 1
a771 1
			    if (line = AllocVec (sizeof (struct Line), MEMF_CLEAR | MEMF_PUBLIC))
d776 1
a776 1
				line->ln_Text = &buffer[anchor];
d779 6
a784 4
				line->ln_Width = swidth;
				line->ln_FgPen = fgpen;
				line->ln_BgPen = bgpen;
				line->ln_Style = style;
d840 15
@


39.4
log
@*** empty log message ***
@
text
@a9 2
#define	DS(x)	;
#define	DH(x)	;
d11 1
d19 2
d34 4
d85 2
d91 24
d127 3
a129 3
		    gpr.MethodID = GM_RENDER;
		    gpr.gpr_GInfo = ((struct opSet *) msg)->ops_GInfo;
		    gpr.gpr_RPort = rp;
d131 1
d686 9
a694 1
			    if (space && kern)	/* font->tf_Flags & FPF_PROPORTIONAL) */
d707 1
d774 1
d776 5
d803 1
a803 1
	if (space && kern)
@


39.3
log
@no changes
@
text
@d12 1
d68 1
a68 1
	cl->cl_UserData           = (ULONG) ascii;
d96 3
a98 3
		    gpr.MethodID   = GM_RENDER;
		    gpr.gpr_GInfo  = ((struct opSet *) msg)->ops_GInfo;
		    gpr.gpr_RPort  = rp;
d111 3
a113 3
	    notifyAttrChanges (ascii, o, ((struct gpLayout *)msg)->gpl_GInfo, NULL,
			       GA_ID,	G (o)->GadgetID,
			       DTA_Busy,TRUE,
d125 3
a127 3
	    notifyAttrChanges (ascii, o, ((struct gpLayout *)msg)->gpl_GInfo, NULL,
			       GA_ID,	G (o)->GadgetID,
			       DTA_Busy,TRUE,
d159 3
a161 3
    UBYTE	 FirstChar;
    BYTE (*__stdargs Match) (WORD Char);
    UBYTE	 LastChar;
d163 2
a164 2
    BYTE	 ExactSize;
    WORD	 Func;
d434 1
a434 1
    BOOL wrap;
d436 3
a438 1
    DB (kprintf ("ascii : layout row=%ld, col=%ld\n", si->si_TopVert, si->si_TopHoriz));
d446 1
d449 1
a449 1
			 TAG_DONE)) >= 6)
d451 1
a451 1
	DS (kprintf ("ascii : obtain si_Lock (l)\n"));
d454 1
a454 1
	wrap = FALSE;
d456 21
a476 1
	if (wrap || gpl->gpl_Initial)
d478 1
a478 24
	    width = (LONG) domain->Width;

	    DoCancel (cl, o);

	    while (line = (struct Line *) RemHead (linelist))
		FreeVec (line);

	    space = (WORD *) (font->tf_CharSpace);
	    kern = (WORD *) (font->tf_CharKern);

	    InitRastPort (&trp);
	    SetFont (&trp, font);

	    split = FALSE;
	    lf = FALSE;
	    total = 0;
	    offset = 0;
	    swidth = 0;
	    lwidth = 0;
	    tabs = 0;
	    chs = 0;
	    num = 0;
	    len = 0;
	    lspace = -1;
d480 5
a484 1
	    tspace = (space && kern) ? 64 : (font->tf_XSize * 8);
d486 4
a489 4
	    for (anchor = i = bsig = 0; (i <= bufferlen) && (bsig == 0); i++)
	    {
		len++;
		ch = buffer[i];
d491 1
a491 3
		if (lod->lod_InSequence)
		{
		    if (ch == 27)
d493 16
a508 16
			num++;
			DoCancel (cl, o);
			lod->lod_InSequence = TRUE;
		    }
		    else if (ch == CSI)
		    {
			num++;
			CSIFake (cl, o);
		    }
		    else if (lod->lod_InSequence = ParseCode (cl, o, ch))
		    {
			num++;
		    }
		    else
		    {
			if (lod->lod_NumGoodChars)
d510 1
a510 2
			    escbuffer = &lod->lod_SaveBuffer[0];
			    switch (ANSICode[lod->lod_WhichANSI].Func)
d512 7
a518 4
				case 1:
				    do
				    {
					escbuffer = ReadValue (escbuffer, &value);
d520 2
a521 2
					if (value == -1)
					    value = 0;
d523 33
a555 33
					switch (value)
					{
					    case 0:
						attributes = 0;
						style = FS_NORMAL;
						fgpen = 1;
						bgpen = 0;
						break;

					    case 1:
						attributes |= ATTR_HIGHLIGHT;
						style |= FSF_BOLD;
						break;

					    case 3:
						style |= FSF_ITALIC;
						break;

					    case 4:
						attributes |= ATTR_UNDERLINE;
						style |= FSF_UNDERLINED;
						break;

					    case 5:
						attributes |= ATTR_BLINK;
						break;

					    case 7:
						attributes |= ATTR_INVERSE;
						tmpen = fgpen;
						fgpen = bgpen;
						bgpen = tmpen;
						break;
d557 2
a558 11
					    default:
						if (value >= 30)
						{
						    if (value <= 37)
						    {
							if (attributes & ATTR_INVERSE)
							    bgpen = value - 30;
							else
							    fgpen = value - 30;
						    }
						    else
d560 1
a560 1
							if (value >= 40 && value <= 47)
d563 1
a563 1
								fgpen = value - 40;
d565 1
a565 1
								bgpen = value - 40;
d567 10
d578 1
a578 4
						}
						else if (value >= 20)
						{
						    switch (value - 20)
d580 6
a585 4
							case 2:
							    attributes &= ~ATTR_HIGHLIGHT;
							    style &= ~FSF_BOLD;
							    break;
d587 3
a589 3
							case 3:
							    style &= ~FSF_ITALIC;
							    break;
d591 5
a595 4
							case 4:
							    attributes &= ~ATTR_UNDERLINE;
							    style &= ~FSF_UNDERLINED;
							    break;
a596 1
						}
d598 2
a599 1
						break;
d601 3
a603 3
				    }
				    while (escbuffer);
				    break;
d605 3
a608 14

			DoCancel (cl, o);
			noprint = split = TRUE;
		    }
		}
		else if ((ch == 27) || (ch == CSI))
		{
		    split = lod->lod_InSequence = TRUE;
		}
		else if (ch == '\t')
		{
		    if (chs)
		    {
			split = TRUE;
d610 5
a614 1
		    else
d616 1
a616 7
			if (tabs++ || !lwidth)
			    twidth = tspace;
			else
			    twidth = (((lwidth / tspace) + 1) * tspace) - lwidth;

			noprint = TRUE;
			if (!wrap || (swidth + twidth <= width - offset))
d618 1
a618 4
			    offset += twidth;
			    swidth += twidth;
			    lwidth += twidth;
			    num++;
d622 17
a638 1
			    lf = TRUE;
d641 1
a641 8
		}
		else if ((ch == '\n') || (ch == 0) || (ch == 12))
		{
		    lf = TRUE;
		}
		else
		{
		    if (tabs)
d643 1
a643 2
			num--;
			noprint = split = TRUE;
d647 1
a647 1
			if (space && kern)	/* font->tf_Flags & FPF_PROPORTIONAL) */
d649 2
a650 8
			    if ((ch > font->tf_HiChar) || (ch < font->tf_LoChar))
				ch = font->tf_HiChar;
			    cn = ch - font->tf_LoChar;

			    if ((num == 0) && (kern[cn] < 0))
				offset += ABS (kern[cn]);

			    twidth = space[cn] + kern[cn];
d653 9
a661 1
			    twidth = font->tf_XSize;
d663 4
a666 2
			if ((num == 0) && (style & FSF_ITALIC))
			    offset += font->tf_XSize / 3;
d668 2
a669 12
			if (!wrap || (swidth + twidth <= width - offset))
			{
			    swidth += twidth;
			    lwidth += twidth;
			    num++;
			}
			else
			{
			    lf = TRUE;
			    if (lspace >= 0)
				num -= (i - lspace);
			}
d671 12
a682 5
			chs++;
			if (ch == ' ')
			    lspace = i;
		    }
		}
d684 3
a686 10
		if (lf || split || (wrap && (swidth > (width - offset))))
		{
		    if (noprint)
		    {
			if (line && lf)
			{
			    line->ln_Flags |= LNF_LF;
			    lwidth = 0;
			    offset = 0;
			    total++;
d689 2
a690 1
		    else
d692 1
a692 1
			if (line = AllocVec (sizeof (struct Line), MEMF_CLEAR | MEMF_PUBLIC))
d694 1
a694 13
			    SetSoftStyle (&trp, style, 0xFF);
			    swidth = TextLength (&trp, &buffer[anchor], num);

			    line->ln_Text = &buffer[anchor];
			    line->ln_TextLen = num;
			    line->ln_XOffset = offset;
			    line->ln_Width = swidth;
			    line->ln_FgPen = fgpen;
			    line->ln_BgPen = bgpen;
			    line->ln_Style = style;
			    AddTail (linelist, (struct Node *) line);

			    if (lf || (wrap && (swidth > (width - offset))))
a696 1
				lod->lod_MWidth = MAX (lod->lod_MWidth, lwidth);
d701 4
a704 1
			    else
d706 24
a729 1
				offset += swidth;
d731 3
d736 9
a744 2
			if (!lf && num && (num < len))
			    num--;
a745 10

		    i = anchor + num;
		    anchor = i + 1;

		    lspace = -1;
		    chs = tabs = num = len = swidth = 0;
		    split = lf = noprint = FALSE;

		    /* Aborted? */
		    bsig = CheckSignal (SIGBREAKF_CTRL_C);
d751 1
a751 1
	    total = si->si_TotVert;
d754 1
a754 1
	DB (kprintf ("vis=%ld, tot=%ld\n", (LONG)domain->Width, lod->lod_MWidth));
d767 2
a768 2
	si->si_VisVert  = visible = domain->Height / si->si_VertUnit;
	si->si_TotVert  = total;
d773 1
a773 1
	si->si_VertUnit  = font->tf_YSize;
d775 1
a775 1
	DH (kprintf ("ascii : hu=%ld, vh=%ld, th=%ld\n", si->si_HorizUnit, si->si_VisHoriz, si->si_TotHoriz));
d778 1
a778 1
	DS (kprintf ("ascii : release si_Lock (l)\n"));
d784 1
a784 1
			       GA_ID,			G (o)->GadgetID,
d786 8
a793 8
			       DTA_VisibleVert,		visible,
			       DTA_TotalVert,		total,
			       DTA_NominalVert,		total,

			       DTA_VisibleHoriz,	domain->Width / hunit,
			       DTA_TotalHoriz,		hwidth,
			       DTA_NominalHoriz,	hwidth,
			       DTA_HorizUnit,		hunit,
d795 3
a797 3
			       DTA_Title,		title,
			       DTA_Busy,		FALSE,
			       DTA_Sync,		TRUE,
d801 8
@


39.2
log
@*** empty log message ***
@
text
@d11 1
d396 1
d750 11
d764 6
a769 2
	si->si_VisHoriz = (LONG) domain->Width;
	si->si_TotHoriz = lod->lod_MWidth;
d782 1
a782 1
			       DTA_NominalHoriz,	lod->lod_MWidth,
d784 4
a787 3
			       DTA_VisibleHoriz,	domain->Width,
			       DTA_TotalHoriz,		lod->lod_MWidth,
			       DTA_NominalVert,		total,
@


39.1
log
@implemented DTM_PROCLAYOUT
@
text
@d10 2
d118 1
d445 1
d755 1
@


39.0
log
@initial RCS
@
text
@d9 1
d106 4
a109 3
	    notifyAttrChanges (ascii, o, ((struct gpLayout *) msg)->gpl_GInfo, NULL,
			       GA_ID, G (o)->GadgetID,
			       DTA_Busy, TRUE,
d111 1
d114 11
a124 6
	    /* If we are running on Intuition, then create a separate process to run the layout on */
	    if (FindTask (NULL)->tc_Node.ln_Type == NT_TASK)
	    {
		retval += DoAsyncLayout (o, (struct gpLayout *) msg);
		break;
	    }
d127 1
d129 1
d430 2
d433 2
a434 2
			 TDTA_TextAttr, (ULONG) & tattr,
			 TDTA_TextFont, (ULONG) & font,
a706 4
#if 0
			    lod->lod_MWidth = MAX (lod->lod_MWidth, (offset + swidth));
#endif

d742 2
d747 1
a747 1
	si->si_VisHoriz = domain->Width;
d754 1
d756 13
a768 9
			       GA_ID, G (o)->GadgetID,
			       DTA_VisibleVert, visible,
			       DTA_TotalVert, total,
			       DTA_VisibleHoriz, domain->Width,
			       DTA_TotalHoriz, lod->lod_MWidth,
			       DTA_NominalHoriz, lod->lod_MWidth,
			       DTA_NominalVert, total,
			       DTA_Title, title,
			       DTA_Busy, FALSE,
@
