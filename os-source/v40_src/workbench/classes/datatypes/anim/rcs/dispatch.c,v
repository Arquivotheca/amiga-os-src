head     40.2;
branch   ;
access   ;
symbols  ;
locks    davidj:40.2; strict;
comment  @ * @;


40.2
date     93.05.25.11.59.56;  author davidj;  state Exp;
branches ;
next     40.1;

40.1
date     93.03.22.14.50.20;  author davidj;  state Exp;
branches ;
next     40.0;

40.0
date     93.03.12.16.04.15;  author davidj;  state Exp;
branches ;
next     39.1;

39.1
date     92.06.24.04.51.02;  author davidj;  state Exp;
branches ;
next     39.0;

39.0
date     92.06.02.08.44.24;  author davidj;  state Exp;
branches ;
next     ;


desc
@initial RCS
@


40.2
log
@now sets up error return codes properly
@
text
@/* dispatch.c
 *
 */

#include "classbase.h"

/*****************************************************************************/

#define	DB(x)	;
#define	DT(x)	;

/*****************************************************************************/

#define	MAX_BMAPS	3

/*****************************************************************************/

struct localData
{
    struct IFFHandle		*lod_IFF;		/* IFF Handle */

    /* Frame Information */
    struct BitMap		*lod_KeyFrame;		/* Key frame */
    UWORD			 lod_Width;
    UWORD			 lod_Height;
    UWORD			 lod_Depth;
    UWORD			 lod_Pad;
    LONG			 lod_CurDelta;		/* The current delta */
    LONG			 lod_NumFrames;		/* Number of frames */

    /* Audio Information */
    UBYTE			*lod_Sample;
    ULONG			 lod_SampleLength;
    ULONG			 lod_Period;

    /* Delta Information */

    LONG			*lod_DBuffer;		/* Delta buffer */
    WORD			*lod_YTable;		/* Y table */
    ULONG			 lod_Current;
    struct BitMap		*lod_CurBMap;		/* The current delta bitmap */
    struct BitMap		*lod_DBMap[MAX_BMAPS];	/* Delta bitmaps */

    struct SignalSemaphore	 lod_Lock;
};

/*****************************************************************************/

#define	G(o)		((struct Gadget *)o)

/*****************************************************************************/

static ULONG setdtattrs (struct ClassBase * cb, Object * o, ULONG data,...)
{
    return (SetDTAttrsA (o, NULL, NULL, (struct TagItem *) & data));
}

/*****************************************************************************/

static ULONG getdtattrs (struct ClassBase * cb, Object * o, ULONG data,...)
{
    return (GetDTAttrsA (o, (struct TagItem *) & data));
}

/*****************************************************************************/

static void copybitmap (struct ClassBase * cb, struct BitMap * bm1, struct BitMap * bm2)
{
    ULONG bpr1 = bm1->BytesPerRow;
    ULONG bpr2 = bm2->BytesPerRow;
    ULONG width;
    UBYTE *src;
    UBYTE *dst;
    LONG r;
    LONG p;

    width = GetBitMapAttr (bm1, BMA_WIDTH) / 8;

    for (p = bm1->Depth - 1; p >= 0; p--)
    {
	src = (BYTE *) bm1->Planes[p];
	dst = (BYTE *) bm2->Planes[p];

	for (r = bm1->Rows; r > 0; r--)
	{
	    CopyMem (src, dst, width);
	    src += bpr1;
	    dst += bpr2;
	}
    }
}

/*****************************************************************************/

static void freebitmap (struct ClassBase *cb, struct BitMap *bm)
{
    ULONG i;

    if (bm)
    {
	/* Free the planes */
	for (i = 0; i < (ULONG)bm->Depth; i++)
	    FreeVec (bm->Planes[i]);

	/* Free the bitmap */
	FreeVec (bm);
    }
}

/*****************************************************************************/

static struct BitMap *allocbitmap (struct ClassBase *cb, ULONG w, ULONG h, ULONG d, ULONG flags, struct BitMap *fbm)
{
    struct BitMap *bm;
    ULONG mflags;
    ULONG msize;
    ULONG i;

    if (bm = AllocVec (sizeof (struct BitMap), MEMF_CLEAR))
    {
	/* We be all */
	mflags = MEMF_CLEAR;
	if (flags & BMF_DISPLAYABLE)
	    mflags |= MEMF_CHIP;

	/* Initialize the bitmap */
	InitBitMap (bm, d, w, h);

	/* Calculate the raster size */
#if 0
	msize = RASSIZE (w, h);
#else
	msize = RASSIZE (((w + 63) & ~63), h);
#endif

	/* Allocate the planes */
	for (i = 0; i < d; i++)
	{
	    if ((bm->Planes[i] = AllocVec (msize, mflags)) == NULL)
	    {
		freebitmap (cb, bm);
		return (NULL);
	    }
	}
    }
    return (bm);
}

/*****************************************************************************/

/* Properties that we can deal with */
static LONG ilbmprops[] =
{
    ID_ILBM, ID_BMHD,
    ID_ILBM, ID_CMAP,
    ID_ILBM, ID_CAMG,
    ID_ILBM, ID_GRAB,
    ID_ILBM, ID_NAME,
};

/*****************************************************************************/

#define	MAXSRCPLANES		24
#define	BPR(w)			((w) + 15 >> 4 << 1)
#define MaxPackedSize(rowSize)  ((rowSize) + (((rowSize)+127) >> 7 ))
#define	RowBytes(w)		((((w) + 15) >> 4) << 1)
#define	ChunkMoreBytes(cn)	(cn->cn_Size - cn->cn_Scan)
#define UGetByte()		(*source++)
#define UPutByte(c)		(*dest++ = (c))

/*****************************************************************************/

#if 1
WORD __asm UnPackRow (register __a0 BYTE ** pSource,
                      register __a1 BYTE ** pDest,
                      register __d0 WORD srcBytes,
                      register __d1 WORD dstBytes);
#else
static BOOL UnPackRow (BYTE ** pSource, BYTE ** pDest, WORD srcBytes0, WORD dstBytes0)
{
    register WORD srcBytes = srcBytes0;
    register WORD dstBytes = dstBytes0;
    register BYTE *source = *pSource;
    register BYTE *dest = *pDest;
    WORD minus128 = -128;	/* get the compiler to generate a CMP.W */
    BOOL error = TRUE;
    register WORD n;
    register BYTE c;

    while (dstBytes > 0)
    {
	if ((srcBytes -= 1) < 0)
	    goto ErrorExit;
	n = UGetByte ();

	if (n >= 0)
	{
	    n += 1;
	    if ((srcBytes -= n) < 0)
		goto ErrorExit;
	    if ((dstBytes -= n) < 0)
		goto ErrorExit;

	    do
	    {
		UPutByte (UGetByte ());
	    } while (--n > 0);
	}
	else if (n != minus128)
	{
	    n = -n + 1;
	    if ((srcBytes -= 1) < 0)
		goto ErrorExit;
	    if ((dstBytes -= n) < 0)
		goto ErrorExit;
	    c = UGetByte ();

	    do
	    {
		UPutByte (c);
	    } while (--n > 0);
	}
    }
    error = FALSE;		/* success! */

  ErrorExit:
    *pSource = source;
    *pDest = dest;
    return (error);
}
#endif

/*****************************************************************************/

static LONG GetBody (struct ClassBase * cb, struct IFFHandle * iff, struct BitMapHeader * bmhd, struct BitMap * bitmap)
{
    BYTE *buf, *nullDest, *nullBuf, **pDest;
    register int iPlane, iRow, nEmpty;
    BYTE *planes[MAXSRCPLANES];			/* array of ptrs to planes & mask */
    struct ContextNode *cn;
    register WORD nFilled;
    STRPTR buffer, anchor;
    UBYTE srcPlaneCnt;
    WORD srcRowBytes;
    WORD destRowBytes;
    LONG bufRowBytes;
    WORD compression;
    LONG error = 0;
    ULONG bufsize;
    int nRows;

    srcRowBytes  = RowBytes (bmhd->bmh_Width);
    bufsize = MaxPackedSize (srcRowBytes) << 4;
    if (anchor = buffer = AllocVec (bufsize, MEMF_CLEAR))
    {
	cn = CurrentChunk (iff);

	compression  = bmhd->bmh_Compression;
	if (compression <= cmpByteRun1)
	{
	    srcPlaneCnt  = bmhd->bmh_Depth;		/* Haven't counted for mask plane yet */
	    destRowBytes = bitmap->BytesPerRow;
	    bufRowBytes  = MaxPackedSize (srcRowBytes);
	    nRows        = bmhd->bmh_Height;

	    /* Complain if client asked for a conversion GetBODY doesn't handle. */
	    if ((srcRowBytes <= bitmap->BytesPerRow) && (bufsize >= bufRowBytes * 2) && (srcPlaneCnt <= MAXSRCPLANES))
	    {
		if (nRows > bitmap->Rows)
		    nRows = bitmap->Rows;

		/* Initialize array "planes" with bitmap ptrs; NULL in empty slots. */
		for (iPlane = 0; iPlane < bitmap->Depth; iPlane++)
		    planes[iPlane] = (BYTE *) bitmap->Planes[iPlane];
		for (; iPlane < MAXSRCPLANES; iPlane++)
		    planes[iPlane] = NULL;

		/* Copy any mask plane ptr into corresponding "planes" slot. */
		if (bmhd->bmh_Masking == mskHasMask)
		{
		    planes[srcPlaneCnt] = NULL;	/* In case more dstPlanes than src. */
		    srcPlaneCnt += 1;	/* Include mask plane in count. */
		}

		/* Setup a sink for dummy destination of rows from unwanted planes. */
		nullDest = buffer;
		buffer += srcRowBytes;
		bufsize -= srcRowBytes;

		/* Read the BODY contents into client's bitmap.
		 * De-interleave planes and decompress rows.
		 * MODIFIES: Last iteration modifies bufsize. */
		buf = buffer + bufsize;	/* Buffer is currently empty. */
		for (iRow = nRows; iRow > 0; iRow--)
		{
		    for (iPlane = 0; iPlane < srcPlaneCnt; iPlane++)
		    {
			pDest = &planes[iPlane];

			/* Establish a sink for any unwanted plane. */
			if (*pDest == NULL)
			{
			    nullBuf = nullDest;
			    pDest = &nullBuf;
			}

			/* Read in at least enough bytes to uncompress next row. */
			nEmpty = buf - buffer;	/* size of empty part of buffer. */
			nFilled = bufsize - nEmpty;	/* this part has data. */
			if (nFilled < bufRowBytes)
			{
			    /* Need to read more. */

			    /* Move the existing data to the front of the buffer. */
			    /* Now covers range buffer[0]..buffer[nFilled-1]. */
			    CopyMem (buf, buffer, nFilled);	/* Could be moving 0 bytes. */

			    if (nEmpty > ChunkMoreBytes (cn))
			    {
				/* There aren't enough bytes left to fill the buffer. */
				nEmpty = ChunkMoreBytes (cn);
				bufsize = nFilled + nEmpty;	/* heh-heh */
			    }

			    /* Append new data to the existing data. */
			    if (ReadChunkBytes (iff, &buffer[nFilled], nEmpty) < nEmpty)
			    {
				error = DTERROR_INVALID_DATA;
				goto errorOut;
			    }

			    buf = buffer;
			    nFilled = bufsize;
			}

			/* Copy uncompressed row to destination plane. */
			if (compression == cmpNone)
			{
			    if (nFilled < srcRowBytes)
			    {
				error = DTERROR_INVALID_DATA;
				goto errorOut;
			    }

			    CopyMem (buf, *pDest, srcRowBytes);
			    buf += srcRowBytes;
			    *pDest += destRowBytes;
			}
			else
			{
			    /* Decompress row to destination plane. */
			    if (UnPackRow (&buf, pDest, nFilled, srcRowBytes))
			    {
				/* pSource, pDest, srcBytes, dstBytes  */
				error = DTERROR_INVALID_DATA;
				goto errorOut;
			    }
			    else
			    {
				*pDest += (destRowBytes - srcRowBytes);
			    }
			}
		    }
		}
	    }
	    else
		error = DTERROR_INVALID_DATA;
	}
	else
	    error = DTERROR_UNKNOWN_COMPRESSION;

errorOut:
	FreeVec (anchor);
    }
    else
	error = ERROR_NO_FREE_STORE;

    SetIoErr (error);
    return (error);
}

/*****************************************************************************/

struct IFFHeader
{
    UBYTE ih_Type[4];		/* File type (FORM, LIST or CAT) */
    ULONG ih_Length;		/* File length */
    UBYTE ih_Form[4];		/* Form type */
};

#define	IH_SIZE	(sizeof (struct IFFHeader))

/*****************************************************************************/

static LONG CountFrames (struct ClassBase * cb, BPTR fh)
{
    struct IFFHeader ih;
    BOOL going = TRUE;
    LONG frames = -1;
    LONG len;

    /* Finding the file length using this method forces the file system to load
     * the entire chain into memory. */
    if (Seek (fh, 0, OFFSET_END) >= 0)
    {
	if ((len = Seek (fh, 0, OFFSET_BEGINNING)) >= 0)
	{
	    if (Read (fh, &ih, IH_SIZE) == IH_SIZE)
	    {
		if ((Strnicmp (ih.ih_Type, "FORM", 4) == 0) && (Strnicmp (ih.ih_Form, "ANIM", 4) == 0))
		{
		    if (ih.ih_Length + 8 != len)
		    {
			SetIoErr (DTERROR_INVALID_DATA);
			return -1;
		    }

		    frames = 0;
		    while ((Read (fh, &ih, IH_SIZE) == IH_SIZE) && going)
		    {
			if (Seek (fh, ih.ih_Length - sizeof (ULONG), OFFSET_CURRENT) == -1)
			    going = FALSE;
			else
			    frames++;
		    }
		}
		else
		    SetIoErr (DTERROR_INVALID_DATA);
	    }
	    else
		SetIoErr (DTERROR_INVALID_DATA);
	}
    }

    return (frames);
}

/*****************************************************************************/

static ULONG InitializeData (struct ClassBase * cb, Class * cl, Object * o, struct TagItem * attrs)
{
    struct localData *lod = INST_DATA (cl, o);
    struct StoredProperty *sp;
    struct BitMapHeader *bmhd;
    BOOL good = FALSE;
    struct BitMap *bm;
    ULONG modeid = 0;
    Point *point;
    STRPTR title;

    InitSemaphore (&lod->lod_Lock);

    title = (STRPTR) GetTagData (DTA_Name, NULL, attrs);

    getdtattrs (cb, o,
		DTA_Handle, &lod->lod_IFF,
		PDTA_BitMapHeader, &bmhd,
		PDTA_Grab, &point,
		TAG_DONE);

    /* IFF handle is already opened for reading */
    PropChunks (lod->lod_IFF, ilbmprops, 5);
    StopChunk (lod->lod_IFF, ID_ILBM, ID_BODY);

    if (ParseIFF (lod->lod_IFF, IFFPARSE_SCAN) == 0L)
    {
	if (sp = FindProp (lod->lod_IFF, ID_ILBM, ID_BMHD))
	{
	    CopyMem (sp->sp_Data, bmhd, sizeof (struct BitMapHeader));

	    lod->lod_Width  = (UWORD) bmhd->bmh_Width;
	    lod->lod_Height = (UWORD) bmhd->bmh_Height;
	    lod->lod_Depth  = (UWORD) bmhd->bmh_Depth;

	    if (lod->lod_Depth > 8)
	    {
		SetIoErr (ERROR_OBJECT_WRONG_TYPE);
	    }
	    else
	    {
		/* Allocate a bitmap to hold the image */
		if (lod->lod_KeyFrame = bm = allocbitmap (cb, (ULONG) lod->lod_Width, (ULONG) lod->lod_Height, (ULONG) lod->lod_Depth, BMF_DISPLAYABLE, NULL))
		{
		    if (sp = FindProp (lod->lod_IFF, ID_ILBM, ID_NAME))
			title = (STRPTR) sp->sp_Data;

		    /* Prepare the Mode ID */
		    if (sp = FindProp (lod->lod_IFF, ID_ILBM, ID_CAMG))
		    {
			modeid = *((ULONG *) sp->sp_Data);
			if ((!(modeid & MONITOR_ID_MASK)) ||
			    ((modeid & EXTENDED_MODE) &&
			     (!(modeid & 0xFFFF0000))))
			{
			    modeid &= (~(EXTENDED_MODE | SPRITES | GENLOCK_AUDIO | GENLOCK_VIDEO | VP_HIDE));
			}
			if ((modeid & 0xFFFF0000) && (!(modeid & 0x00001000)))
			{
			    modeid = 0L;
			}
		    }

		    if (modeid == 0L)
		    {
			modeid = LORES_KEY;
			if (lod->lod_Width >= 640)
			    modeid = HIRES;
			if (lod->lod_Height >= 400)
			    modeid |= LACE;
		    }

		    /* Announce our plans to the world */
		    setdtattrs (cb, o,
				DTA_ObjName,		title,
				DTA_NominalHoriz,	(ULONG) lod->lod_Width,
				DTA_NominalVert,	(ULONG) lod->lod_Height,
				DTA_TotalHoriz,		(ULONG) lod->lod_Width,
				DTA_TotalVert,		(ULONG) lod->lod_Height,
				ADTA_Width,		(ULONG) lod->lod_Width,
				ADTA_Height,		(ULONG) lod->lod_Height,
				ADTA_Depth,		(ULONG) lod->lod_Depth,
				ADTA_Frames,		(ULONG) 1,
				ADTA_KeyFrame,		lod->lod_KeyFrame,
				ADTA_ModeID,		modeid,

				TAG_DONE);

		    /* Get the color information */
		    if (sp = FindProp (lod->lod_IFF, ID_ILBM, ID_CMAP))
		    {
			struct ColorRegister *rgb, *cmap, *ccmap;
			WORD i, ncolors;
			LONG *cregs;

			i = ncolors = MAX ((sp->sp_Size / 3L), (1 << lod->lod_Depth));

			setdtattrs (cb, o, PDTA_NumColors, ncolors, TAG_DONE);

			getdtattrs (cb, o,
				    PDTA_ColorRegisters, (ULONG) & cmap,
				    PDTA_CRegs, &cregs,
				    TAG_DONE);

			rgb = (struct ColorRegister *) sp->sp_Data;
			ccmap = cmap;
			while (i--)
			{
			    *cmap = *rgb;
			    cmap++;
			    rgb++;
			}

			cmap = ccmap;
			for (i = 0; i < ncolors; i++)
			{
			    cregs[i * 3 + 0] = (LONG) cmap[i].red   << 24;
			    cregs[i * 3 + 1] = (LONG) cmap[i].green << 24;
			    cregs[i * 3 + 2] = (LONG) cmap[i].blue  << 24;
			}
		    }
		    else
		    {
			setdtattrs (cb, o, PDTA_NumColors, (1 << lod->lod_Depth), TAG_DONE);
		    }

		    /* Make sure we can get the body of the picture */
		    if (GetBody (cb, lod->lod_IFF, bmhd, lod->lod_KeyFrame) == 0)
		    {
			/* Allocate work areas */
			lod->lod_DBuffer = AllocVec (64000, NULL);
			lod->lod_YTable  = AllocYTable (cb, bm);

			/* Allocate the delta bitmaps */
			lod->lod_DBMap[0] = allocbitmap (cb, (ULONG) lod->lod_Width, (ULONG) lod->lod_Height, (ULONG) lod->lod_Depth, NULL, NULL);
			lod->lod_DBMap[1] = allocbitmap (cb, (ULONG) lod->lod_Width, (ULONG) lod->lod_Height, (ULONG) lod->lod_Depth, NULL, NULL);

			/* Make sure everything was allocated */
			if (lod->lod_DBMap[0] && lod->lod_DBMap[1] && lod->lod_DBuffer && lod->lod_YTable)
			{
			    struct AnimHeader *ah;
			    LONG fps = 10;		/* Was six */

			    /* Copy the bitmaps */
			    copybitmap (cb, bm, lod->lod_DBMap[0]);
			    copybitmap (cb, bm, lod->lod_DBMap[1]);

			    /* Close in preparation for counting and rewinding */
			    CloseIFF (lod->lod_IFF);

			    /* We want to default to one frame (the keyframe) */
			    lod->lod_NumFrames = 1;

			    /* Go back to the beginning */
			    Seek (lod->lod_IFF->iff_Stream, 0, OFFSET_BEGINNING);
			    if (OpenIFF (lod->lod_IFF, IFFF_READ) == 0)
			    {
				/* Set up the stop & prop chunks */
				StopChunk (lod->lod_IFF, ID_ILBM, ID_BODY);
				PropChunk (lod->lod_IFF, ID_ILBM, ID_ANHD);
				StopChunk (lod->lod_IFF, ID_ILBM, ID_DLTA);

				/* Skip past the body */
				ParseIFF (lod->lod_IFF, IFFPARSE_SCAN);

				if (ParseIFF (lod->lod_IFF, IFFPARSE_SCAN) != IFFERR_EOF)
				{
				    if (sp = FindProp (lod->lod_IFF, ID_ILBM, ID_ANHD))
				    {
				        ah = (struct AnimHeader *) sp->sp_Data;

					/* Jiffies are 1/60 of a second */
					DT (kprintf ("time=%ld\n", ah->ah_RelTime));

					DB (kprintf ("op=%ld, bits=%ld\n", (LONG)ah->ah_Operation, (LONG)ah->ah_Flags));

#if 1
					if (ah->ah_Operation == 5)
					    good = TRUE;
#else
					if ((ah->ah_Operation == 5) || (ah->ah_Operation == 8))
					    good = TRUE;
#endif

					if (good)
					{
					    /* Close in preparation for counting and rewinding */
					    CloseIFF (lod->lod_IFF);

					    /* Count the number of frames */
					    lod->lod_NumFrames = CountFrames (cb, lod->lod_IFF->iff_Stream);

					    /* Reopen that fucking file */
					    OpenIFF (lod->lod_IFF, IFFF_READ);

					    if (lod->lod_NumFrames > 0)
						lod->lod_CurDelta = lod->lod_NumFrames + 1;
					    else
						lod->lod_NumFrames = 1;
					}
				    }
				}
			    }

			    /* Announce the latest developments */
			    setdtattrs (cb, o,
					ADTA_Frames,		lod->lod_NumFrames,
					ADTA_FramesPerSecond,	fps,
					TAG_DONE);

			    return (TRUE);
			}
			else
			    SetIoErr (ERROR_NO_FREE_STORE);
		    }
		}
		else
		    SetIoErr (ERROR_NO_FREE_STORE);
	    }
	}
	else
	    SetIoErr (ERROR_REQUIRED_ARG_MISSING);
    }
    else
	SetIoErr (ERROR_SEEK_ERROR);

    return (FALSE);
}

/*****************************************************************************/

static BOOL LocateDelta (struct ClassBase *cb, struct localData *lod, LONG delta)
{
    struct IFFHandle *iff = lod->lod_IFF;
    struct StoredProperty *sp;
    struct AnimHeader *ah;
    struct BitMap *bm;
    BOOL going = TRUE;

    /* If they are asking for a delta that is before the current delta, then we need to rewind */
    if (delta < lod->lod_CurDelta)
    {
	/* Initialize the delta buffers */
	copybitmap (cb, lod->lod_KeyFrame, lod->lod_DBMap[0]);
	copybitmap (cb, lod->lod_KeyFrame, lod->lod_DBMap[1]);

	/* Close in preparation for counting and rewinding */
	CloseIFF (iff);

	/* Go back to the beginning */
	Seek (iff->iff_Stream, 0, OFFSET_BEGINNING);
	if (OpenIFF (iff, IFFF_READ) == 0)
	{
	    /* Set up the stop & prop chunks */
	    StopChunk (iff, ID_ILBM, ID_BODY);
	    PropChunk (iff, ID_ILBM, ID_ANHD);
	    StopChunk (iff, ID_ILBM, ID_DLTA);

	    /* Skip past the body */
	    ParseIFF (iff, IFFPARSE_SCAN);
	}

	/* Say that we are before the first delta */
	lod->lod_CurBMap = NULL;
	lod->lod_CurDelta = 0;
    }

    /* Get the required frame */
    while ((lod->lod_CurDelta < delta) && going)
    {
	/* Scan for the next delta */
	if (ParseIFF (iff, IFFPARSE_SCAN) == IFFERR_EOF)
	{
	    SetIoErr (ERROR_NO_MORE_ENTRIES);
	    going = FALSE;
	}
	else if (sp = FindProp (iff, ID_ILBM, ID_ANHD))
	{
	    /* Increment the frame counter */
	    lod->lod_CurDelta++;

	    /* Get the pointers */
	    ah = (struct AnimHeader *) sp->sp_Data;
	    bm = lod->lod_CurBMap = lod->lod_DBMap[lod->lod_Current];
	    if (ah->ah_Interleave == 0)
	    {
		lod->lod_Current++;
		if (lod->lod_Current > 1)
		    lod->lod_Current = 0;
	    }

	    /* Decode the deltas */
	    LoadDelta (cb, iff, lod->lod_YTable, bm, ah, lod->lod_DBuffer);
	}
	else
	{
	    SetIoErr (ERROR_OBJECT_NOT_FOUND);
	    going = FALSE;
	}
    }

    return going;
}

/*****************************************************************************/

static struct BitMap *loadframe (struct ClassBase *cb, Class *cl, Object *o, struct adtFrame *msg)
{
    struct localData *lod = INST_DATA (cl, o);

    ObtainSemaphore (&lod->lod_Lock);

    /* Clear the return value */
    msg->alf_BitMap = NULL;

    /* Locate the delta */
    if (LocateDelta (cb, lod, msg->alf_Frame))
    {
	if (msg->alf_Frame == 0)
	{
	    if (msg->alf_UserData != lod->lod_KeyFrame)
		freebitmap (cb, msg->alf_UserData);
	    msg->alf_UserData = msg->alf_BitMap = lod->lod_KeyFrame;
	}
	else if (lod->lod_CurBMap)
	{
	    /* Make sure we have a bitmap to copy to */
	    if ((msg->alf_UserData == NULL) || (msg->alf_UserData == lod->lod_KeyFrame))
		msg->alf_UserData = allocbitmap (cb, (ULONG) lod->lod_Width, (ULONG) lod->lod_Height, (ULONG) lod->lod_Depth, NULL, NULL);

	    /* Copy the bitmap */
	    if (msg->alf_UserData)
		copybitmap (cb, lod->lod_CurBMap, (struct BitMap *) msg->alf_UserData);
	    msg->alf_BitMap = msg->alf_UserData;
	}
    }
    else
    {
	freebitmap (cb, msg->alf_UserData);
	msg->alf_UserData = NULL;
    }

    ReleaseSemaphore (&lod->lod_Lock);

    return msg->alf_BitMap;
}

/*****************************************************************************/

static ULONG unloadframe (struct ClassBase *cb, Class *cl, Object *o, struct adtFrame *msg)
{
    struct localData *lod = INST_DATA (cl, o);

    if (msg->alf_UserData != lod->lod_KeyFrame)
	freebitmap (cb, msg->alf_UserData);
    msg->alf_UserData = NULL;
    return 0;
}

/*****************************************************************************/

static ULONG startMethod (struct ClassBase * cb, Class * cl, Object * o, struct adtStart *asa)
{
    struct localData *lod = INST_DATA (cl, o);

    ObtainSemaphore (&lod->lod_Lock);

    /* Go to where ever they tell us */
    LocateDelta (cb, (struct localData *) INST_DATA (cl, o), asa->asa_Frame);

    ReleaseSemaphore (&lod->lod_Lock);

    return (ULONG) DoSuperMethodA (cl, o, (Msg) asa);
}

/*****************************************************************************/

static ULONG ASM Dispatch (REG (a0) Class * cl, REG (a2) Object * o, REG (a1) Msg msg)
{
    struct ClassBase *cb = (struct ClassBase *) cl->cl_UserData;
    struct localData *lod = INST_DATA (cl, o);
    ULONG retval;

    switch (msg->MethodID)
    {
	case OM_NEW:
	    if (retval = DoSuperMethodA (cl, o, msg))
	    {
		if (!(InitializeData (cb, cl, (Object *) retval, ((struct opSet *) msg)->ops_AttrList)))
		{
		    CoerceMethod (cl, (Object *) retval, OM_DISPOSE);
		    retval = NULL;
		}
	    }
	    return (retval);

	case ADTM_LOADFRAME:
	    return (ULONG) loadframe (cb, cl, o, (struct adtFrame *)msg);

	case ADTM_UNLOADFRAME:
	    return (ULONG) unloadframe (cb, cl, o, (struct adtFrame *)msg);

	case ADTM_START:
	    return (ULONG) startMethod (cb, cl, o, (struct adtStart *) msg);

	case OM_DISPOSE:
	    WaitBlit ();
	    freebitmap (cb, lod->lod_KeyFrame);
	    lod->lod_KeyFrame = NULL;
	    freebitmap (cb, lod->lod_DBMap[0]);
	    lod->lod_DBMap[0] = NULL;
	    freebitmap (cb, lod->lod_DBMap[1]);
	    lod->lod_DBMap[1] = NULL;
	    FreeVec (lod->lod_DBuffer);
	    lod->lod_DBuffer = NULL;
	    FreeYTable (cb, lod->lod_YTable);
	    lod->lod_YTable = NULL;

	/* Let the superclass handle everything else */
	default:
	    return (ULONG) DoSuperMethodA (cl, o, msg);
    }
}

/*****************************************************************************/

Class *initClass (struct ClassBase * cb)
{
    Class *cl;

    if (cl = MakeClass (ANIMDTCLASS, ANIMATIONDTCLASS, NULL, sizeof (struct localData), 0L))
    {
	cl->cl_Dispatcher.h_Entry = (ULONG (*)()) Dispatch;
	cl->cl_UserData = (ULONG) cb;
	AddClass (cl);
    }

    return (cl);
}
@


40.1
log
@took out anim op-8 support
@
text
@d53 1
a53 1
ULONG setdtattrs (struct ClassBase * cb, Object * o, ULONG data,...)
d60 1
a60 1
ULONG getdtattrs (struct ClassBase * cb, Object * o, ULONG data,...)
d67 1
a67 1
void copybitmap (struct ClassBase * cb, struct BitMap * bm1, struct BitMap * bm2)
d95 1
a95 1
void freebitmap (struct ClassBase *cb, struct BitMap *bm)
d112 1
a112 1
struct BitMap *allocbitmap (struct ClassBase *cb, ULONG w, ULONG h, ULONG d, ULONG flags, struct BitMap *fbm)
a150 16
Class *initClass (struct ClassBase * cb)
{
    Class *cl;

    if (cl = MakeClass (ANIMDTCLASS, ANIMATIONDTCLASS, NULL, sizeof (struct localData), 0L))
    {
	cl->cl_Dispatcher.h_Entry = (ULONG (*)()) Dispatch;
	cl->cl_UserData = (ULONG) cb;
	AddClass (cl);
    }

    return (cl);
}

/*****************************************************************************/

d152 1
a152 1
LONG ilbmprops[] =
d173 7
a179 1
BOOL unpackrow (BYTE ** pSource, BYTE ** pDest, WORD srcBytes0, WORD dstBytes0)
d231 1
d235 1
a235 1
LONG GetBody (struct ClassBase * cb, struct IFFHandle * iff, struct BitMapHeader * bmhd, struct BitMap * bitmap)
d248 1
a248 1
    LONG error = 1;
d328 2
a329 2
				FreeVec (anchor);
				return (IFFERR_MANGLED);
d341 2
a342 2
				FreeVec (anchor);
				return (IFFERR_MANGLED);
d352 1
a352 1
			    if (unpackrow (&buf, pDest, nFilled, srcRowBytes))
d355 2
a356 2
				FreeVec (anchor);
				return (IFFERR_MANGLED);
d366 2
d369 2
d372 1
d376 1
a376 4
    {
	SetIoErr (ERROR_NO_FREE_STORE);
	error = IFFERR_NOMEM;
    }
d378 1
d395 1
a395 1
LONG CountFrames (struct ClassBase * cb, BPTR fh)
d410 1
a410 1
		if ((strncmp (ih.ih_Type, "FORM", 4) == 0) && (strncmp (ih.ih_Form, "ANIM", 4) == 0))
d414 2
a415 1
			DB (kprintf ("File corrupt, header says %ld bytes\n", ih.ih_Length + 8));
d427 2
d430 2
d440 1
a440 1
ULONG InitializeData (struct ClassBase * cb, Class * cl, Object * o, struct TagItem * attrs)
d445 1
a474 2
	    DB (kprintf ("w=%ld, h=%ld, d=%ld\n", (ULONG)bmhd->bmh_Width, (ULONG)bmhd->bmh_Height, (ULONG)bmhd->bmh_Depth));

d567 1
a567 1
		    if (GetBody (cb, lod->lod_IFF, bmhd, lod->lod_KeyFrame) == 1)
d581 1
a581 2
			    BOOL good = FALSE;
			    LONG fps = 6;
d634 5
a643 3
			    /* We always want it to close & reopen */
			    lod->lod_CurDelta = lod->lod_NumFrames + 1;

d671 1
a671 1
BOOL LocateDelta (struct ClassBase *cb, struct localData *lod, LONG delta)
d746 1
a746 1
struct BitMap *loadframe (struct ClassBase *cb, Class *cl, Object *o, struct adtFrame *msg)
a780 1
    DB (kprintf ("loaded\n"));
d789 1
a789 1
ULONG unloadframe (struct ClassBase *cb, Class *cl, Object *o, struct adtFrame *msg)
d801 1
a801 1
ULONG startMethod (struct ClassBase * cb, Class * cl, Object * o, struct adtStart *asa)
a807 1
    DB (kprintf ("locate %ld...", asa->asa_Frame));
a808 1
    DB (kprintf ("found\n"));
d817 1
a817 1
ULONG ASM Dispatch (REG (a0) Class * cl, REG (a2) Object * o, REG (a1) Msg msg)
d862 16
@


40.0
log
@initial RCS
@
text
@d619 4
d625 1
@


39.1
log
@fixed remove and dispose
@
text
@d1 1
a1 2
/*
 * dispatch.c
d7 2
d10 3
d14 135
d151 1
a151 1
Class *initClass (struct ClassBase *cb)
d155 1
a155 1
    if (cl = MakeClass ("anim.datatype", DATATYPESCLASS, NULL, sizeof (struct localData), 0L))
d157 1
a157 1
	cl->cl_Dispatcher.h_Entry = Dispatch;
d161 1
d167 235
a401 1
void freeExtraInfo (struct ClassBase *cb, struct localData * lod)
d403 35
a437 15
    if (lod->lod_NumAlloc)
    {
	LONG i;

	for (i = (LONG) (lod->lod_NumAlloc - 1); i >= 0; i--)
	    ReleasePen (lod->lod_ColorMap, lod->lod_Allocated[i]);
	lod->lod_NumAlloc = 0L;
    }

    if (lod->lod_BMap)
    {
	FreeBitMap (lod->lod_BMap);
	lod->lod_BMap = NULL;
    }
}
d441 1
a441 1
ULONG ASM Dispatch (REG (a0) Class * cl, REG (a2) Object * o, REG (a1) Msg msg)
a442 1
    struct ClassBase *cb = (struct ClassBase *) cl->cl_UserData;
d444 32
a475 2
    struct DTSpecialInfo *si;
    ULONG retval = 0L;
d477 1
a477 4
    switch (msg->MethodID)
    {
	case OM_NEW:
	    if (retval = DoSuperMethodA (cl, o, msg))
d479 1
a479 5
		if (!(initializeAG (cb, cl, (Object *) retval, (struct opSet *) msg)))
		{
		    CoerceMethod (cl, (Object *) retval, OM_DISPOSE);
		    return NULL;
		}
d481 4
a484 18
	    break;

	case OM_GET:
	    retval = getAGAttr (cb, cl, o, (struct opGet *) msg);
	    break;

	case OM_SET:
	case OM_UPDATE:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    retval += setAGAttrsAttrs (cb, cl, o, (struct opSet *) msg);

	    if (retval && (OCLASS (o) == cl))
	    {
		struct RastPort *rp;
		struct gpRender gpr;

		/* Get a pointer to the rastport */
		if (rp = ObtainGIRPort (((struct opSet *) msg)->ops_GInfo))
d486 165
a650 9
		    /* Force a redraw */
		    gpr.MethodID = GM_RENDER;
		    gpr.gpr_GInfo = ((struct opSet *) msg)->ops_GInfo;
		    gpr.gpr_RPort = rp;
		    gpr.gpr_Redraw = GREDRAW_UPDATE;
		    DoMethodA (o, &gpr);

		    /* Release the temporary rastport */
		    ReleaseGIRPort (rp);
d652 2
a653 2
		/* Clear the return value */
		retval = 0L;
d655 6
a660 1
	    break;
d662 2
a663 10
	case GM_HITTEST:
	    retval = GMR_GADGETHIT;
	    break;

	case GM_GOACTIVE:
	case GM_HANDLEINPUT:
	    {
		struct gpInput *gpi = (struct gpInput *) msg;
		struct InputEvent *ie = gpi->gpi_IEvent;
		struct dtTrigger dtt;
d665 1
a665 6
		if (ie->ie_Code == SELECTUP)
		{
		    dtt.MethodID     = DTM_TRIGGER;
		    dtt.dtt_GInfo    = NULL;
		    dtt.dtt_Function = STM_PLAY;
		    dtt.dtt_Data     = NULL;
d667 7
a673 9
		    sam (cb, lod->lod_SIPCPort, (Msg) &dtt, sizeof (struct dtTrigger));
		    retval = (GMR_NOREUSE | GMR_VERIFY);
		}
		else
		{
		    retval = GMR_MEACTIVE;
		}
	    }
	    break;
d675 50
a724 30
	case DTM_GOTO:
	    sam (cb, lod->lod_SIPCPort, msg, sizeof (struct dtGoto));
	    break;

	case DTM_TRIGGER:
	    sam (cb, lod->lod_SIPCPort, msg, sizeof (struct dtTrigger));
	    break;

	case DTM_PROCLAYOUT:
	case GM_LAYOUT:
	    /* Show that we are attached to the window */
	    lod->lod_Flags |= LODF_ATTACHED;

	    /* We have to pass this one up to our superclass */
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);

	    /* We need to cache the window & requester pointers */
	    if (((struct gpLayout *) msg)->gpl_Initial)
	    {
		lod->lod_Window = ((struct gpLayout *) msg)->gpl_GInfo->gi_Window;
		lod->lod_Requester = ((struct gpLayout *) msg)->gpl_GInfo->gi_Requester;

		/* Clone the RastPort */
		lod->lod_RPort = *(lod->lod_Window->RPort);
	    }
	    si = (struct DTSpecialInfo *) G (o)->SpecialInfo;
	    if (si->si_Flags & DTSIF_LAYOUT)
	    {
		si->si_Flags |= DTSIF_NEWSIZE;
		retval = 1L;
a725 6
	    else
	    {
		si->si_Flags |= DTSIF_LAYOUT;
		sam (cb, lod->lod_SIPCPort, msg, sizeof (struct gpLayout));
	    }
	    break;
d727 8
a734 61
	case DTM_FRAMEBOX:
	    retval = frameMethod (cb, cl, o, (struct dtFrameBox *) msg);
	    break;

	case GM_RENDER:
	    retval = renderMethod (cb, cl, o, (struct gpRender *) msg);
	    break;

	case DTM_PRINT:
	    retval = printMethod (cb, cl, o, (struct dtPrint *) msg);
	    break;

	case DTM_REMOVEDTOBJECT:
	    /* Do we have a control process running */
	    if ((lod->lod_Flags & LODF_ATTACHED) && lod->lod_Process)
	    {
		/* Tell the control process to go away */
		DB (kprintf ("tell process to detach animation\n"));
		Signal (lod->lod_Process, SIGBREAKF_CTRL_E);

		/* Wait until they detach */
		while (lod->lod_Flags & LODF_ATTACHED)
		    Delay (2);
		DB (kprintf ("detached\n"));
	    }
	    break;

	case OM_DISPOSE:
	    /* Show that it's time to go away */
	    lod->lod_Flags |= LODF_DISPOSE;

	    /* Do we have a control process running */
	    if ((lod->lod_Flags & LODF_RUNNING) && lod->lod_Process)
	    {
		/* Tell the control process to go away */
		DB (kprintf ("tell process to abort\n"));
		Signal (lod->lod_Process, SIGBREAKF_CTRL_C);

		/* Wait until they go away */
		while (lod->lod_Flags & LODF_RUNNING)
		    Delay (2);
		DB (kprintf ("process done running\n"));
	    }

	    freeExtraInfo (cb, lod);

	    if (lod->lod_Colors)
		FreeVec (lod->lod_Colors);

	    /* As soon as we have data sharing get rid of this!!! */
	    if (lod->lod_SourceBMap)
		FreeBitMap (lod->lod_SourceBMap);
	    if (lod->lod_SourceBMap1)
		FreeBitMap (lod->lod_SourceBMap1);
	    if (lod->lod_SourceBMap2)
		FreeBitMap (lod->lod_SourceBMap2);

	    /* Let the superclass handle everything else */
	default:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    break;
d737 1
a737 62
    return (retval);
}

/*****************************************************************************/

BOOL initializeAG (struct ClassBase *cb, Class * cl, Object * o, struct opSet * msg)
{
    struct localData *lod = INST_DATA (cl, o);	/* Object data */
    struct DTSpecialInfo *si;
    struct IFFHandle *iff;

    lod->lod_ModeID = INVALID_ID;
    lod->lod_Flags |= LODF_REMAP;

    si = (struct DTSpecialInfo *) G (o)->SpecialInfo;
    si->si_VertUnit = si->si_HorizUnit = 1;
    si->si_OTopVert = si->si_OTopHoriz = -1;

    /* Make sure we have a file handle */
    if (GetAttr (DTA_Handle, o, (ULONG *) & iff) && iff)
    {
	if (GetILBM (cb, cl, o, ((struct opSet *) msg)->ops_AttrList))
	{
	    /* Set all the attributes */
	    setAGAttrsAttrs (cb, cl, o, (struct opSet *) msg);

	    /* Create a process to monitor this object */
	    if (lod->lod_Process = createnewproc (cb,
						  NP_Output, Output (),
						  NP_CloseOutput, FALSE,
						  NP_Input, Input (),
						  NP_CloseInput, FALSE,
						  NP_Cli, TRUE,
						  NP_Name, PROC_NAME,
						  NP_CommandName, PROC_NAME,
						  NP_StackSize, 4096L,
						  NP_Entry, ObjectHandler,
						  NP_Priority, 1L,
						  TAG_DONE))
	    {
		/* Initialize the message */
		lod->lod_Message.sm_Message.mn_Node.ln_Type = NT_MESSAGE;
		lod->lod_Message.sm_Message.mn_Length = sizeof (struct StartupMsg);
		lod->lod_Message.sm_ClassBase = cb;
		lod->lod_Message.sm_Class = cl;
		lod->lod_Message.sm_Object = o;

		/* Show that we are operational */
		lod->lod_Going = TRUE;

		/* Send the information to the process */
		PutMsg (&(lod->lod_Process->pr_MsgPort), &lod->lod_Message);

		/* Wait until the new process starts */
		while (!(lod->lod_Flags & LODF_RUNNING))
		    Delay (2);

		return (TRUE);
	    }
	}
    }
    return (FALSE);
d742 1
a742 2
/* Inquire attribute of an object */
ULONG getAGAttr (struct ClassBase *cb, Class * cl, Object * o, struct opGet * msg)
d746 1
a746 45
    switch (msg->opg_AttrID)
    {
	case PDTA_ModeID:
	    *msg->opg_Storage = lod->lod_ModeID;
	    break;

	case PDTA_BitMapHeader:
	    *msg->opg_Storage = (ULONG) & lod->lod_BMHD;
	    break;

	case PDTA_BitMap:
	    *msg->opg_Storage = (ULONG) lod->lod_BMap;
	    break;

	case PDTA_ColorRegisters:
	    *msg->opg_Storage = (ULONG) lod->lod_Colors;
	    break;

	case PDTA_CRegs:
	    *msg->opg_Storage = (ULONG) lod->lod_CRegs;
	    break;

	case PDTA_GRegs:
	    *msg->opg_Storage = (ULONG) lod->lod_GRegs;
	    break;

	case PDTA_ColorTable:
	    *msg->opg_Storage = (ULONG) lod->lod_ColorTable;
	    break;

	case PDTA_ColorTable2:
	    *msg->opg_Storage = (ULONG) lod->lod_ColorTable2;
	    break;

	case PDTA_Allocated:
	    *msg->opg_Storage = (ULONG) lod->lod_Allocated;
	    break;

	case PDTA_NumColors:
	    *msg->opg_Storage = (ULONG) lod->lod_NumColors;
	    break;

	case PDTA_NumAlloc:
	    *msg->opg_Storage = (ULONG) lod->lod_NumAlloc;
	    break;
d748 2
a749 3
	default:
	    return ((ULONG)DoSuperMethodA (cl, o, msg));
    }
d751 32
a782 38
    return (1L);
}

/*****************************************************************************/

/* Set attributes of an object */
ULONG setAGAttrsAttrs (struct ClassBase *cb, Class * cl, Object * o, struct opSet * msg)
{
    struct DTSpecialInfo *si = (struct DTSpecialInfo *) G (o)->SpecialInfo;
    struct TagItem *tags = msg->ops_AttrList;
    struct localData *lod;
    struct TagItem *tstate;
    struct TagItem *tag;
    ULONG refresh = 0L;
    struct BitMap *obm;
    ULONG tidata;
    WORD ncolors;
    ULONG modeid;

    lod = INST_DATA (cl, o);

    ncolors = lod->lod_NumColors;
    modeid = lod->lod_ModeID;
    obm = lod->lod_SourceBMap;

    /* process rest */
    tstate = tags;
    while (tag = NextTagItem (&tstate))
    {
	tidata = tag->ti_Data;
	switch (tag->ti_Tag)
	{
	    case PDTA_Remap:
		if (tidata)
		    lod->lod_Flags |= LODF_REMAP;
		else
		    lod->lod_Flags &= ~LODF_REMAP;
		break;
a783 135
	    case PDTA_ModeID:
		lod->lod_ModeID = tidata;
		break;

	    case PDTA_NumColors:
		lod->lod_NumColors = (WORD) tidata;
		break;

		/* Remember shared data!!! Our subclass is telling us about the new bitmap. */
	    case PDTA_BitMap:
		lod->lod_SourceBMap = (struct BitMap *) tidata;
		break;

	    case DTA_TopVert:
		si->si_TopVert = tidata;
		refresh = 1L;
		break;

	    case DTA_VisibleVert:
		si->si_VisVert = tidata;
		break;

	    case DTA_TotalVert:
		si->si_TotVert = tidata;
		break;

	    case DTA_TopHoriz:
		si->si_TopHoriz = tidata;
		refresh = 1L;
		break;

	    case DTA_VisibleHoriz:
		si->si_VisHoriz = tidata;
		break;

	    case DTA_TotalHoriz:
		si->si_TotHoriz = tidata;
		break;
	}
    }

    if (lod->lod_NumColors != ncolors)
    {
	struct FrameInfo *fri;
	ULONG size1;
	ULONG size2;
	ULONG size3;
	ULONG size4;
	ULONG size5;
	ULONG size6;
	ULONG size7;
	ULONG msize;

	GetAttr (DTA_FrameInfo, o, (ULONG *) & fri);

	ncolors = lod->lod_NumColors;

	if (lod->lod_Colors)
	    FreeVec (lod->lod_Colors);

	/* How big is the histogram table */
	lod->lod_HistoSize = sizeof (ULONG) * ncolors;

	/* Compute amount of memory needed for colors */
	size1 = sizeof (struct ColorRegister) * ncolors + 2;	/* lod_Colors */
	size2 = size1 + (sizeof (LONG) * 3 * ncolors) + 2;	/* lod_CRegs */
	size3 = size2 + (sizeof (LONG) * 3 * ncolors * 2) + 2;	/* lod_GRegs */
	size4 = size3 + (sizeof (UBYTE) * ncolors) + 2;	/* lod_ColorTable */
	size5 = size4 + (sizeof (UBYTE) * ncolors) + 2;	/* lod_ColorTable2 */
	size6 = size5 + (sizeof (UBYTE) * ncolors * 2) + 2;	/* lod_Allocated */
	size7 = size6 + lod->lod_HistoSize + 2;	/* lod_Histogram */
	msize = size7 + lod->lod_HistoSize + 2;	/* lod_Histogram2 */

	if (lod->lod_Colors = AllocVec (msize, MEMF_CLEAR))
	{
	    lod->lod_CRegs = MEMORY_N_FOLLOWING (lod->lod_Colors, size1);
	    lod->lod_GRegs = MEMORY_N_FOLLOWING (lod->lod_Colors, size2);
	    lod->lod_ColorTable = MEMORY_N_FOLLOWING (lod->lod_Colors, size3);
	    lod->lod_ColorTable2 = MEMORY_N_FOLLOWING (lod->lod_Colors, size4);
	    lod->lod_Allocated = MEMORY_N_FOLLOWING (lod->lod_Colors, size5);
	    lod->lod_Histogram = MEMORY_N_FOLLOWING (lod->lod_Colors, size6);
	    lod->lod_Histogram2 = MEMORY_N_FOLLOWING (lod->lod_Colors, size7);
	}

	fri->fri_ColorMap = (struct ColorMap *) lod->lod_CRegs;
    }

    if (obm != lod->lod_SourceBMap)
    {
	struct FrameInfo *fri;

	GetAttr (DTA_FrameInfo, o, (ULONG *) & fri);

	fri->fri_Dimensions.Width  = GetBitMapAttr (lod->lod_SourceBMap, BMA_WIDTH);
	fri->fri_Dimensions.Height = GetBitMapAttr (lod->lod_SourceBMap, BMA_HEIGHT);
	fri->fri_Dimensions.Depth  = GetBitMapAttr (lod->lod_SourceBMap, BMA_DEPTH);
    }

    if (modeid != lod->lod_ModeID)
    {
	struct DisplayInfo di;
	struct FrameInfo *fri;

	GetAttr (DTA_FrameInfo, o, (ULONG *) & fri);

	if (GetDisplayInfoData (NULL, (APTR) & di, sizeof (struct DisplayInfo), DTAG_DISP, lod->lod_ModeID) &&
	    (di.NotAvailable == NULL))
	{
	    fri->fri_PropertyFlags = di.PropertyFlags;
	    fri->fri_Resolution = *(&di.Resolution);
	    fri->fri_RedBits = di.RedBits;
	    fri->fri_GreenBits = di.GreenBits;
	    fri->fri_BlueBits = di.BlueBits;
	}
    }

    return (refresh);
}

/*****************************************************************************/

ULONG frameMethod (struct ClassBase *cb, Class * cl, Object * o, struct dtFrameBox * msg)
{
    struct FrameInfo *fri;
    ULONG retval = 1L;

    if (!(msg->dtf_FrameFlags & FRAMEF_SPECIFY))
    {
	/* Tell me about yourself */
	GetAttr (DTA_FrameInfo, o, (ULONG *) & fri);
	CopyMem (fri, msg->dtf_FrameInfo, MIN (msg->dtf_SizeFrameInfo, sizeof (struct FrameInfo)));
    }
    return (retval);
}

d786 1
a786 1
ULONG renderMethod (struct ClassBase *cb, Class * cl, Object * o, struct gpRender * msg)
a787 1
    struct DTSpecialInfo *si = (struct DTSpecialInfo *) G (o)->SpecialInfo;
a788 3
    struct IBox *domain;
    struct RastPort *rp;
    LONG width, height;
d790 5
a794 28
    if (!lod->lod_BMap)
	return (0);

    GetAttr (DTA_Domain, o, (ULONG *) & domain);

    width = (ULONG) MIN (lod->lod_BMHD.bmh_Width, domain->Width);
    height = (ULONG) MIN (lod->lod_BMHD.bmh_Height, domain->Height);

    /* Get a pointer to the rastport */
    if (rp = msg->gpr_RPort)
    {
	if ((msg->MethodID == GM_RENDER) && (msg->gpr_Redraw == GREDRAW_REDRAW) &&
	    (si->si_OTopVert != si->si_TopVert) && (si->si_OTopVert != si->si_TopVert))
	{
	    EraseRect (rp,
		       domain->Left, domain->Top,
		       domain->Left + domain->Width - 1,
		       domain->Top + domain->Height - 1);
	}

	BltBitMapRastPort (lod->lod_BMap, (ULONG) si->si_TopHoriz, (ULONG) si->si_TopVert,
			   rp, domain->Left, domain->Top, width, height, 0xC0);

	si->si_OTopVert = si->si_TopVert;
	si->si_OTopHoriz = si->si_TopHoriz;
    }
    return (1L);
}
d798 1
a798 1
struct ColorMap *GetObjectColorMap (struct ClassBase *cb, Class * cl, Object * o)
a800 2
    struct ColorMap *cm;
    ULONG i, r, g, b;
d802 1
a802 14
    /* Get a color map */
    if (cm = GetColorMap (lod->lod_NumColors))
    {
	/* Set the colors */
	for (i = 0; i < lod->lod_NumColors; i++)
	{
	    r = lod->lod_CRegs[i * 3 + 0];
	    g = lod->lod_CRegs[i * 3 + 1];
	    b = lod->lod_CRegs[i * 3 + 2];
	    SetRGB32CM (cm, i, r, g, b);
	}
    }
    return (cm);
}
d804 10
d816 1
a816 1
ULONG printMethod (struct ClassBase *cb, Class * cl, Object * o, struct dtPrint * msg)
d818 1
d820 6
a825 54
    struct GadgetInfo *gi = msg->dtp_GInfo;
    struct PrinterExtendedData *ped;
    struct Preferences *prefs;
    struct PrinterData *pd;
    struct Rectangle rect;
    union printerIO *pio;
    UWORD width, height;
    struct ColorMap *cm;
    struct RastPort rp;
    ULONG retval = 0L;
    BOOL going = TRUE;
    struct IBox *sel;
    UWORD left, top;
    UWORD iospecial;
    LONG destcols;
    ULONG sigr;
    ULONG psig;
    ULONG tmpl;

    if (pio = msg->dtp_PIO)
    {
	pd = (struct PrinterData *) pio->iodrp.io_Device;
	ped = &pd->pd_SegmentData->ps_PED;
	prefs = &pd->pd_Preferences;

	/* What bit are we going to wait on? */
	psig = 1L << pio->ios.io_Message.mn_ReplyPort->mp_SigBit;

	if (GetAttr (DTA_SelectDomain, o, (ULONG *) & sel) && sel)
	{
	    left = sel->Left;
	    top = sel->Top;
	    width = sel->Width;
	    height = sel->Height;
	}
	else
	{
	    /* Fill in the window rectangle */
	    QueryOverscan (lod->lod_ModeID, &rect, OSCAN_TEXT);
	    left = 0;
	    top = 0;
	    width = rect.MaxX - rect.MinX + 1;
	    height = rect.MaxY - rect.MinY + 1;
	}

	/* Get a color map */
	if (cm = GetObjectColorMap (cb, cl, o))
	{
	    /* Prepare the RastPort */
	    InitRastPort (&rp);
	    rp.BitMap = lod->lod_SourceBMap;

	    /* Compute the flags & size */
	    if ((lod->lod_BMHD.bmh_Width == width) && (lod->lod_BMHD.bmh_Height == height))
d827 5
a831 8
		iospecial = SPECIAL_FULLCOLS | SPECIAL_ASPECT;
	    }
	    else
	    {
		iospecial = SPECIAL_FRACCOLS | SPECIAL_ASPECT;
		tmpl = lod->lod_BMHD.bmh_Width;
		tmpl = width << 16;
		destcols = (tmpl / width) << 16;
d833 1
a833 19

	    /* Prepare to dump the RastPort */
	    pio->iodrp.io_Command = PRD_DUMPRPORT;
	    pio->iodrp.io_RastPort = &rp;
	    pio->iodrp.io_ColorMap = cm;
	    pio->iodrp.io_Modes = lod->lod_ModeID;
	    pio->iodrp.io_SrcX = left;
	    pio->iodrp.io_SrcY = top;
	    pio->iodrp.io_SrcWidth = width;
	    pio->iodrp.io_SrcHeight = height;
	    pio->iodrp.io_DestCols = destcols;
	    pio->iodrp.io_DestRows = 0;
	    pio->iodrp.io_Special = iospecial;
	    SendIO ((struct IORequest *) pio);

	    while (going)
	    {
		/* Wait for something to happen */
		sigr = Wait (psig | SIGBREAKF_CTRL_C);
d835 5
a839 6
		/* Did they try to abort us? */
		if (sigr & SIGBREAKF_CTRL_C)
		{
		    /* Abort the IO */
		    AbortIO ((struct IORequest *) pio);
		    WaitIO ((struct IORequest *) pio);
d841 2
a842 5
		    /* Reset the printer (otherwise they get garbage the next time they print) */
		    pio->ios.io_Command = CMD_WRITE;
		    pio->ios.io_Data = "\033c";
		    pio->ios.io_Length = -1L;
		    DoIO ((struct IORequest *) pio);
d844 12
a855 2
		    going = FALSE;
		}
d857 3
a859 17
		/* Is the print complete? */
		if (sigr & psig)
		{
		    while (GetMsg (pio->ios.io_Message.mn_ReplyPort)) ;
		    going = FALSE;
		}
	    }

	    /* Return the return value from the print request */
	    if ((retval = (ULONG) pio->ios.io_Error) == 0)
	    {
		DoMethod (o, DTM_CLEARSELECTED, gi);
	    }

	    /* Free the temporary color map */
	    FreeColorMap (cm);
	}
a860 2

    return retval;
@


39.0
log
@initial RCS
@
text
@d8 1
a8 1
#define	DB(x)	x
d16 1
a16 1
    if (cl = MakeClass ("animdtclass", DATATYPESCLASS, NULL, sizeof (struct localData), 0L))
d135 1
d137 3
d182 1
d188 1
d200 1
d206 1
d538 2
a539 2
    width = (ULONG) MIN (lod->lod_BMHD.w, domain->Width);
    height = (ULONG) MIN (lod->lod_BMHD.h, domain->Height);
d643 1
a643 1
	    if ((lod->lod_BMHD.w == width) && (lod->lod_BMHD.h == height))
d650 1
a650 1
		tmpl = lod->lod_BMHD.w;
@
