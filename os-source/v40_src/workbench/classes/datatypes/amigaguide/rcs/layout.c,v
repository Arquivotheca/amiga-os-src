head     39.17;
branch   ;
access   ;
symbols  ;
locks    davidj:39.17; strict;
comment  @ * @;


39.17
date     93.09.22.15.52.16;  author davidj;  state Exp;
branches ;
next     39.16;

39.16
date     93.06.17.14.18.29;  author davidj;  state Exp;
branches ;
next     39.15;

39.15
date     93.05.25.13.14.53;  author davidj;  state Exp;
branches ;
next     39.14;

39.14
date     93.05.04.16.51.19;  author davidj;  state Exp;
branches ;
next     39.13;

39.13
date     93.04.30.16.13.03;  author davidj;  state Exp;
branches ;
next     39.12;

39.12
date     93.04.27.09.49.24;  author davidj;  state Exp;
branches ;
next     39.11;

39.11
date     93.03.22.16.30.42;  author davidj;  state Exp;
branches ;
next     39.10;

39.10
date     92.12.04.17.14.55;  author davidj;  state Exp;
branches ;
next     39.9;

39.9
date     92.08.31.17.16.14;  author davidj;  state Exp;
branches ;
next     39.8;

39.8
date     92.08.13.13.41.05;  author davidj;  state Exp;
branches ;
next     39.7;

39.7
date     92.08.10.16.46.13;  author davidj;  state Exp;
branches ;
next     39.6;

39.6
date     92.08.03.17.11.21;  author davidj;  state Exp;
branches ;
next     39.5;

39.5
date     92.07.23.17.03.59;  author davidj;  state Exp;
branches ;
next     39.4;

39.4
date     92.07.15.22.33.14;  author davidj;  state Exp;
branches ;
next     39.3;

39.3
date     92.06.22.10.50.43;  author davidj;  state Exp;
branches ;
next     39.2;

39.2
date     92.06.19.04.04.46;  author davidj;  state Exp;
branches ;
next     39.1;

39.1
date     92.06.05.04.19.34;  author davidj;  state Exp;
branches ;
next     39.0;

39.0
date     92.06.02.08.30.45;  author davidj;  state Exp;
branches ;
next     ;


desc
@initial RCS
@


39.17
log
@can now turn off the control panel
@
text
@/* layout.c
 *
 */

#include "amigaguidebase.h"
#include "hosthandle.h"

/*****************************************************************************/

#define	DB(x)	;

/*****************************************************************************/

ULONG layoutMethod (struct AGLib *ag, Class * cl, Object * o, ULONG initial)
{
    ULONG (*ASM he) (REG (a0) struct Hook * h, REG (a2) VOID * obj, REG (a1) VOID * msg);
    struct DTSpecialInfo *si = (struct DTSpecialInfo *) G (o)->SpecialInfo;
    struct IBox *domain = NULL;
    struct DatabaseData *dbd;
    struct TextFont *font;
    struct ClientData *cd;
    struct WorkLayout *wl;
    struct RastPort trp;
    struct NodeData *nd;
    struct _Object *ob;
    struct Line *line;
    struct IBox lbox;
    LONG i, j, k, x;
    BOOL wordwrap;
    STRPTR label;
    LONG total;
    BPTR lock;
    BPTR fh;

    /* Get the data pointers */
    cd = INST_DATA (cl, o);

    if (cd->cd_CurrentNode == NULL)
	return 0;

    /* Show that we need to compute the rastports again */
    cd->cd_Flags |= AGF_NEWSIZE;

    /* Get the data pointers */
    nd = INST_DATA (ag->ag_NodeClass, cd->cd_CurrentNode);
    ob = _OBJECT (cd->cd_CurrentNode);
    dbd = INST_DATA (ag->ag_DatabaseClass, nd->nd_Database);

    /* Get the font */
    if (nd->nd_Font)
	font = nd->nd_Font;
    else if (cd->cd_Font)
	font = cd->cd_Font;
    else
	font = cd->cd_GInfo.gi_DrInfo->dri_Font;

    /* Make sure we have a font */
    if (font)
    {
	/* Initialize the temporary rastport */
	InitRastPort (&trp);
	SetFont (&trp, font);

	/* Initialize the control rastport */
	cd->cd_Control = *(&trp);
	SetFont (&cd->cd_Control, cd->cd_GInfo.gi_DrInfo->dri_Font);
	cd->cd_ControlHeight = cd->cd_GInfo.gi_DrInfo->dri_Font->tf_YSize + 4;

	/* Initialize a few text variables */
	cd->cd_LineHeight = font->tf_YSize + 2;

	si->si_VertUnit = (LONG) cd->cd_LineHeight;
	si->si_HorizUnit = 1L;

	/* Get the wrap state */
	wordwrap = ((dbd->dbd_Flags & DBDF_WRAP) || (nd->nd_Flags & HNF_WRAP));

	/* No wrap, then we will need a layer */
	if (!wordwrap)
	    dbd->dbd_Flags |= DBDF_LAYER;
	cd->cd_Flags |= AGF_RENDER;

	/* Clear the active line */
	cd->cd_ActiveLine = NULL;

	/* Clear the old line list */
	while (line = (struct Line *) RemHead ((struct List *) &cd->cd_LineList))
	    freepvec (ag, cd->cd_Pool, line);

	/* Get the domain of the object */
	GetAttr (DTA_Domain, o, (ULONG *) & domain);

	/* Set the state of the controls */
	for (i = 0; i < MAX_CONTROLS; i++)
	{
	    cd->cd_Controls[i].c_Flags |= CF_DISABLED;
	    switch (i)
	    {
		case C_CONTENTS:
		    if (nd->nd_TOC)
			cd->cd_Controls[i].c_Flags &= ~CF_DISABLED;
		    else if (Stricmp (nd->nd_Name, "Main") != 0)
			cd->cd_Controls[i].c_Flags &= ~CF_DISABLED;
		    break;

		case C_INDEX:
		    if (dbd->dbd_Index)
			cd->cd_Controls[i].c_Flags &= ~CF_DISABLED;
		    break;

		case C_HELP:
		    if (dbd->dbd_Help)
			cd->cd_Controls[i].c_Flags &= ~CF_DISABLED;
		    else if (Stricmp (dbd->dbd_Name, MASTER_HELP) != 0)
		    {
			if (lock = LVOLockE (ag, NULL, MASTER_HELP, ACCESS_READ))
			{
			    cd->cd_Controls[i].c_Flags &= ~CF_DISABLED;
			    UnLock (lock);
			}
		    }
		    break;

		case C_RETRACE:
		    if (cd->cd_HistoryList.mlh_TailPred != (struct Node *) &cd->cd_HistoryList)
			cd->cd_Controls[i].c_Flags &= ~CF_DISABLED;
		    break;

		case C_BROWSE_PREV:
		    if (nd->nd_Prev)
		    {
			if (Stricmp (nd->nd_Name, nd->nd_Prev) != 0)
			    cd->cd_Controls[i].c_Flags &= ~CF_DISABLED;
		    }
		    else if (ob != (struct _Object *) dbd->dbd_NodeList.mlh_Head)
			cd->cd_Controls[i].c_Flags &= ~CF_DISABLED;
		    break;

		case C_BROWSE_NEXT:
		    if (nd->nd_Next)
		    {
			if (Stricmp (nd->nd_Name, nd->nd_Next) != 0)
			    cd->cd_Controls[i].c_Flags &= ~CF_DISABLED;
		    }
		    else if (ob != (struct _Object *) dbd->dbd_NodeList.mlh_TailPred)
			cd->cd_Controls[i].c_Flags &= ~CF_DISABLED;
		    break;
	    }
	}

	/* See if we have controls */
	if (cd->cd_Flags & AGF_CONTROLS)
	{
	    /* layout the control panel */
	    GetLabelsExtent (ag, &cd->cd_Control, LABEL_CONTENTS, LABEL_BROWSE_NEXT, &lbox);
	    cd->cd_BoxWidth = (ULONG) lbox.Width;
	    for (i = k = x = 0, cd->cd_Top = domain->Top; i < 6; i++, k++)
	    {
		label = LVOGetAGString (ag, LABEL_CONTENTS + i);
		j = (cd->cd_BoxWidth - TextLength (&cd->cd_Control, label, strlen (label))) / 2;

		cd->cd_Controls[i].c_Left = x;
		cd->cd_Controls[i].c_TLeft = x + j;
		cd->cd_Controls[i].c_Top = cd->cd_Top;
		cd->cd_Controls[i].c_ID = STM_CONTENTS + k;
		cd->cd_Controls[i].c_Label = label;
		cd->cd_Controls[i].c_LabelLen = strlen (label);

		if (i == 2)
		{
		    cd->cd_Controls[i].c_ID = STM_HELP;
		    k--;
		}

		x += (cd->cd_BoxWidth + 2);
		if ((x + cd->cd_BoxWidth > domain->Width) && (i < 5))
		{
		    x = 0;
		    cd->cd_Top += (cd->cd_ControlHeight + 1);
		}
		/* Allow at least one line of text */
		if (cd->cd_Top - domain->Top > domain->Height)
		    i = 6;
	    }
	    cd->cd_Top++;
	    cd->cd_Height = domain->Height - cd->cd_Top - 2;
	    cd->cd_Top += cd->cd_ControlHeight + 2;
	}
	else
	{
	    cd->cd_Top    = domain->Top;
	    cd->cd_Height = domain->Height - cd->cd_Top - 2;
	    cd->cd_ControlHeight = 0;
	}

	if (nd->nd_Object)
	{
	    struct gpLayout gpl;

	    /* show that we've need to be refreshed */
	    cd->cd_Flags |= AGF_SYNC | AGF_LAYOUT;

	    /* Tell the object about it's size. Call the object layout method */
	    setattrs (ag, nd->nd_Object,
		      GA_Left, domain->Left,
		      GA_Top, cd->cd_Top,
		      GA_Width, domain->Width,
		      GA_Height, cd->cd_Height - 1,
		      TAG_DONE);

	    gpl.MethodID = DTM_PROCLAYOUT;
	    gpl.gpl_GInfo = (cd->cd_Window) ? &cd->cd_GInfo : NULL;
	    gpl.gpl_Initial = initial;
	    DoMethodA (nd->nd_Object, (Msg) & gpl);

	    /* Ask the object about its size */
	    getdtattrs (ag, nd->nd_Object,
			DTA_VisibleVert, (ULONG *) & si->si_VisVert,
			DTA_TotalVert, (ULONG *) & si->si_TotVert,
			DTA_VisibleHoriz, (ULONG *) & si->si_VisHoriz,
			DTA_TotalHoriz, (ULONG *) & si->si_TotHoriz,
			TAG_DONE);
	}
	else
	{
	    /* Do we have a node buffer? */
	    ObtainSemaphore (&nd->nd_Lock);

	    /* Empty buffer? */
	    if (nd->nd_Buffer == NULL)
	    {
		/* Are we a node host? */
		if (dbd->dbd_HH)
		{
		    struct TagItem tags[4];
		    struct Rectangle rect;

		    /* Initialize the tag list */
		    tags[0].ti_Tag = AGA_HelpGroup;
		    tags[0].ti_Data = cd->cd_HelpGroup;
		    tags[1].ti_Tag = TAG_DONE;

		    /* If we have a window, then we have more tags */
		    if (cd->cd_Window)
		    {
			rect = *((struct Rectangle *) &cd->cd_Window->LeftEdge);
			tags[1].ti_Tag = HTNA_Screen;
			tags[1].ti_Data = (ULONG) cd->cd_Window->WScreen;
			tags[2].ti_Tag = HTNA_Rectangle;
			tags[2].ti_Data = (ULONG) & rect;
			tags[3].ti_Tag = TAG_DONE;
		    }

		    /* Prepare the message */
		    memset (&nd->nd_ONM, 0, sizeof (struct opNodeIO));

		    nd->nd_ONM.MethodID = HM_OPENNODE;
		    nd->nd_ONM.onm_Attrs = tags;
		    nd->nd_ONM.onm_Node = nd->nd_Name;
		    nd->nd_ONM.onm_Flags = nd->nd_Flags;

		    /* Get a pointer to the entry point */
#if 1
		    he = dbd->dbd_HH->hh_Dispatcher.h_Entry;
#else
		    he = (ULONG (ASM *) (REG (a0) struct Hook *, REG (a2) VOID *, REG (a1) VOID *)) dbd->dbd_HH->hh_Dispatcher.h_Entry;
#endif

		    /* Open the node */
		    if ((*he) ((struct Hook *) dbd->dbd_HH, dbd->dbd_Name, &nd->nd_ONM))
		    {
			if (nd->nd_ONM.onm_Flags & HTNF_DONE)
			{
			    /* They don't have any more data! */
			}
			else if (nd->nd_ONM.onm_DocBuffer)
			{
			    nd->nd_Buffer = nd->nd_ONM.onm_DocBuffer;
			    nd->nd_BufferLen = nd->nd_ONM.onm_BuffLen;
			}
			else if (nd->nd_ONM.onm_FileName)
			{
			    if (fh = Open (nd->nd_ONM.onm_FileName, MODE_OLDFILE))
			    {
				/* Seek to the offset */
				if (Seek (nd->nd_FileHandle, 0L, OFFSET_END) >= 0)
				{
				    if ((nd->nd_BufferLen = Seek (nd->nd_FileHandle, 0L, OFFSET_BEGINNING)) >= 0)
				    {
					if (nd->nd_Buffer = AllocVec (nd->nd_BufferLen + 2, MEMF_CLEAR))
					{
					    /* Read from the source file into the buffer */
					    if (Read (nd->nd_FileHandle, nd->nd_Buffer, nd->nd_BufferLen) == nd->nd_BufferLen)
					    {
						nd->nd_Flags |= HNF_FREEBUFFER;
					    }
					    else
					    {
						/* Couldn't read, so clear it */
						FreeVec (nd->nd_Buffer);
						nd->nd_Buffer = NULL;
					    }
					}
				    }
				}
				Close (fh);
			    }
			}
		    }
		}
		/* Allocate the node buffer */
		else if (nd->nd_Buffer = AllocVec (nd->nd_BufferLen + 2, MEMF_CLEAR))
		{
		    /* Seek to the offset */
		    Seek (nd->nd_FileHandle, nd->nd_Offset, OFFSET_BEGINNING);

		    /* Read from the source file into the buffer */
		    if (Read (nd->nd_FileHandle, nd->nd_Buffer, nd->nd_BufferLen) == nd->nd_BufferLen)
		    {
			nd->nd_Flags |= HNF_FREEBUFFER;
		    }
		    else
		    {
			/* Couldn't read, so clear it */
			FreeVec (nd->nd_Buffer);
			nd->nd_Buffer = NULL;
		    }
		}
	    }

	    /* If we have text to layout, then perform layout */
	    if (nd->nd_Buffer)
	    {
		/* Allocate the work structure */
		if (wl = allocpvec (ag, cd->cd_Pool, sizeof (struct WorkLayout), MEMF_CLEAR | MEMF_PUBLIC))
		{
		    /* Set the domain of the object */
		    wl->wl_View = *domain;

		    /* Initialize the NON-ZERO variables */
		    wl->wl_Text = TRUE;

		    /* Set the initial styles */
		    wl->wl_Style = FS_NORMAL;
		    wl->wl_FgPen = cd->cd_GInfo.gi_DrInfo->dri_Pens[TEXTPEN];
		    wl->wl_BgPen = cd->cd_GInfo.gi_DrInfo->dri_Pens[BACKGROUNDPEN];
		    wl->wl_Justify = JLEFT;

		    /* Initialize the RastPort */
		    InitRastPort (&wl->wl_RPort);

		    /* Set the font */
		    wl->wl_Font = font;

		    /* Set the font */
		    SetFont (&wl->wl_RPort, wl->wl_Font);

		    /* Calculate the amount of space a tab takes up */
		    wl->wl_SpaceWidth = TextLength (&wl->wl_RPort, " ", 1);
		    wl->wl_TabSpace = wl->wl_SpaceWidth * nd->nd_DefTabs;

		    /* Is wordwrap on? */
		    if ((dbd->dbd_Flags & DBDF_WRAP) || (nd->nd_Flags & HNF_WRAP))
			wl->wl_DefWrap = wl->wl_Wrap = TRUE;
		    if ((dbd->dbd_Flags & DBDF_SMARTWRAP) || (nd->nd_Flags & HNF_SMARTWRAP))
			wl->wl_DefWrap = wl->wl_Wrap = wl->wl_DefSmartWrap = wl->wl_SmartWrap = TRUE;

		    /* layout the document */
		    rl_layoutRecurse (ag, cd, dbd, nd, wl, nd->nd_Buffer, nd->nd_BufferLen);

		    /* Free the temporary work data */
		    freepvec (ag, cd->cd_Pool, wl);
		}
	    }

	    /* Release the semaphore */
	    ReleaseSemaphore (&nd->nd_Lock);

	    /* Adjust the line count */
	    total = 0;
	    line = (struct Line *) &cd->cd_LineList;
	    while (line->ln_Link.mln_Succ)
	    {
		if (line->ln_Flags & LNF_LF)
		    total++;
		line = (struct Line *) line->ln_Link.mln_Succ;
	    }

	    /* Make sure everyone knows what we are */
	    si->si_VisVert = cd->cd_VisVert = cd->cd_Height / cd->cd_LineHeight;
	    si->si_TotVert = total;

	    si->si_VisHoriz = cd->cd_VisHoriz = domain->Width;
	    si->si_TotHoriz = cd->cd_TotHoriz;

	    /* Check to see if we are visible */
	    if (si->si_TopVert > si->si_TotVert - si->si_VisVert)
		si->si_TopVert = si->si_TotVert - si->si_VisVert;
	    if (si->si_TopVert < 0)
		si->si_TopVert = 0;
	    if (si->si_TopHoriz > si->si_TotHoriz - si->si_VisHoriz)
		si->si_TopHoriz = si->si_TotHoriz - si->si_VisHoriz;
	    if (si->si_TopHoriz < 0)
		si->si_TopHoriz = 0;

	    /* show that we've need to be refreshed */
	    cd->cd_Flags |= AGF_SYNC | AGF_LAYOUT;
	}
    }
    return (1L);
}
@


39.16
log
@*** empty log message ***
@
text
@d151 2
a152 4
	/* layout the control panel */
	GetLabelsExtent (ag, &cd->cd_Control, LABEL_CONTENTS, LABEL_BROWSE_NEXT, &lbox);
	cd->cd_BoxWidth = (ULONG) lbox.Width;
	for (i = k = x = 0, cd->cd_Top = domain->Top; i < 6; i++, k++)
d154 7
a160 2
	    label = LVOGetAGString (ag, LABEL_CONTENTS + i);
	    j = (cd->cd_BoxWidth - TextLength (&cd->cd_Control, label, strlen (label))) / 2;
d162 6
a167 6
	    cd->cd_Controls[i].c_Left = x;
	    cd->cd_Controls[i].c_TLeft = x + j;
	    cd->cd_Controls[i].c_Top = cd->cd_Top;
	    cd->cd_Controls[i].c_ID = STM_CONTENTS + k;
	    cd->cd_Controls[i].c_Label = label;
	    cd->cd_Controls[i].c_LabelLen = strlen (label);
d169 5
a173 5
	    if (i == 2)
	    {
		cd->cd_Controls[i].c_ID = STM_HELP;
		k--;
	    }
d175 9
a183 5
	    x += (cd->cd_BoxWidth + 2);
	    if ((x + cd->cd_BoxWidth > domain->Width) && (i < 5))
	    {
		x = 0;
		cd->cd_Top += (cd->cd_ControlHeight + 1);
d185 9
a193 3
	    /* Allow at least one line of text */
	    if (cd->cd_Top - domain->Top > domain->Height)
		i = 6;
a194 3
	cd->cd_Top++;
	cd->cd_Height = domain->Height - cd->cd_Top - 2;
	cd->cd_Top += cd->cd_ControlHeight + 2;
d360 1
a360 1
		    wl->wl_TabSpace   = wl->wl_SpaceWidth * nd->nd_DefTabs;
@


39.15
log
@stopped an endless loop
@
text
@d67 1
a67 1
	cd->cd_ControlHeight = cd->cd_GInfo.gi_DrInfo->dri_Font->tf_YSize + 3;
d183 1
a183 1
	cd->cd_Height = domain->Height - cd->cd_Top - 1;
@


39.14
log
@move variable initialization from rlayout.c
@
text
@d333 1
d335 2
a336 1
		    wl->wl_FgPen = 1;
@


39.13
log
@clean up
@
text
@d343 7
d354 1
a354 1
			wl->wl_DefWrap = wl->wl_Wrap = wl->wl_SmartWrap = TRUE;
@


39.12
log
@supports { } in buttons correctly
@
text
@a6 1
#include <ctype.h>
d14 1
a14 1
VOID *allocpvec (struct AGLib * ag, void *pool, ULONG byteSize, ULONG attributes)
a15 34
    ULONG realSize;
    ULONG *mem;

    realSize = byteSize + sizeof(ULONG);
    if (mem = AllocPooled (pool, realSize))
        *mem++ = realSize;
    return((void *)mem);
}

/*****************************************************************************/

VOID freepvec (struct AGLib * ag, void *pool, void *memoryBlock)
{
    ULONG *mem;

    if (memoryBlock)
    {
        mem = ((ULONG *)memoryBlock)-1;
        FreePooled (pool, mem, *mem);
    }
}

/*****************************************************************************/

void DoCancel (struct AGLib * ag, struct ClientData * cd)
{
    cd->cd_InSequence = FALSE;
    cd->cd_NumGoodChars = cd->cd_CharsInBuffer = cd->cd_ScanStep = 0;
}

/*****************************************************************************/

ULONG layoutMethod (struct AGLib * ag, Class * cl, Object * o, ULONG initial)
{
a17 1
    struct TextFont *font;
d20 1
a20 3
    struct Line *line;
    ULONG style = FS_NORMAL;
    UBYTE saveBuffer[512];
d22 1
a22 1
    STRPTR argv[MAXARG];
d26 1
d29 1
a30 9
    LONG tspace;
    LONG offset;		/* Segment offset */
    LONG twidth;		/* Width of tab	 */
    LONG swidth;		/* Segment width */
    LONG lwidth;		/* Total line width */
    LONG anchor;		/* Beginning of	current	segment	 */
    LONG mwidth;		/* Maximum line width */
    WORD *space;
    WORD lspace;
a31 7
    BYTE fgpen;
    BYTE bgpen;
    ULONG argc;
    ULONG bsig;
    LONG width;			/* Width of view area */
    WORD *kern;
    WORD quote;
a32 6
    LONG tabs;			/* Number of tabs */
    LONG chs;			/* Number of characters	 */
    LONG len;
    LONG num;
    WORD cbs;
    WORD ch;
a34 8
    BOOL noprint;
    BOOL split;
    BOOL wrap;
    BOOL lf;

    UBYTE smallbuffer[2];

    smallbuffer[1] = 0;
d75 3
d79 1
a79 1
	if (!(dbd->dbd_Flags & DBDF_WRAP))
d83 3
d87 1
a87 1
	while (line = (struct Line *) RemHead ((struct List *) & cd->cd_LineList))
d125 1
a125 1
		    if (cd->cd_HistoryList.lh_TailPred != (struct Node *) & cd->cd_HistoryList)
d135 1
a135 1
		    else if (ob != (struct _Object *) dbd->dbd_NodeList.lh_Head)
d145 1
a145 1
		    else if (ob != (struct _Object *) dbd->dbd_NodeList.lh_TailPred)
d151 1
a151 1
	/* Layout the control panel */
d195 4
a198 4
		      GA_Left,	domain->Left,
		      GA_Top,	cd->cd_Top,
		      GA_Width,	domain->Width,
		      GA_Height,cd->cd_Height - 1,
d201 2
a202 2
	    gpl.MethodID    = DTM_PROCLAYOUT;
	    gpl.gpl_GInfo   = (cd->cd_Window) ? &cd->cd_GInfo : NULL;
d208 4
a211 4
			DTA_VisibleVert,	(ULONG *) &si->si_VisVert,
			DTA_TotalVert,		(ULONG *) &si->si_TotVert,
			DTA_VisibleHoriz,	(ULONG *) &si->si_VisHoriz,
			DTA_TotalHoriz,		(ULONG *) &si->si_TotHoriz,
d229 1
a229 1
		    tags[0].ti_Tag  = AGA_HelpGroup;
d231 1
a231 1
		    tags[1].ti_Tag  = TAG_DONE;
d236 2
a237 2
			rect = *((struct Rectangle *)&cd->cd_Window->LeftEdge);
			tags[1].ti_Tag  = HTNA_Screen;
d239 3
a241 3
			tags[2].ti_Tag  = HTNA_Rectangle;
			tags[2].ti_Data = (ULONG) &rect;
			tags[3].ti_Tag  = TAG_DONE;
d246 2
a247 1
		    nd->nd_ONM.MethodID  = HM_OPENNODE;
d249 1
a249 1
		    nd->nd_ONM.onm_Node  = nd->nd_Name;
d256 1
a256 1
		    he = (ULONG (ASM *)(REG (a0) struct Hook *, REG (a2) VOID *, REG (a1) VOID *)) dbd->dbd_HH->hh_Dispatcher.h_Entry;
d321 1
a321 8
	    /**********************/
	    /**********************/
	    /**********************/
	    /* Layout Starts Here */
	    /**********************/
	    /**********************/
	    /**********************/

d324 2
a325 29
		/* Set up our work variables */
		DoCancel (ag, cd);

		space = (WORD *) (font->tf_CharSpace);
		kern  = (WORD *) (font->tf_CharKern);

		/* Initialize the variables */
		width = (LONG) domain->Width;
		tspace = 8 * font->tf_XSize;
		noprint = FALSE;
		split = FALSE;
		wrap = FALSE;
		lspace = -1;
		lf = FALSE;
		offset = 0;
		swidth = 0;
		lwidth = 0;
		mwidth = 0;
		quote  = 0;
		fgpen  = cd->cd_GInfo.gi_DrInfo->dri_Pens[TEXTPEN];
		bgpen  = cd->cd_GInfo.gi_DrInfo->dri_Pens[BACKGROUNDPEN];
		tabs   = 0;
		chs    = 0;
		num    = 0;
		len    = 0;
		cbs    = 0;

		/* Used to have <= instead of < */
		for (anchor = i = bsig = 0; (i <= nd->nd_BufferLen) && (bsig == 0); i++)
d327 2
a328 280
		    len++;
		    ch = nd->nd_Buffer[i];

		    if (cd->cd_InSequence)
		    {
			if (((ch == '@@') && (nd->nd_Buffer[i + 1] == CBS)) || ((ch == CBS) && (cbs == 0)))
			{
			    if (ch == '@@')
			    {
				i++;
				num++;
			    }
			    num++;
			    cbs = 1;
			    DoCancel (ag, cd);
			    cd->cd_InSequence = TRUE;
			}
			else
			{
			    if (ch == QUOTE)
				quote ^= 1;
			    else if (quote==0)
			    {
				if (ch == CBS)
				    cbs++;
				else if (ch == CBE)
				    cbs--;
			    }

			    if (cbs == 0)
			    {
				saveBuffer[cd->cd_CharsInBuffer] = 0;
				strcpy (&saveBuffer[256], saveBuffer);
				if ((argc = ParseString (ag, &saveBuffer[256], argv, MAXARG)) > 0)
				{
				    /* Font attribute */
				    if (argc == 1)
				    {
					/* Attributes */
					if (Stricmp (argv[0], "b") == 0)
					    style |= FSF_BOLD;
					else if (Stricmp (argv[0], "ub") == 0)
					    style &= ~FSF_BOLD;
					else if (Stricmp (argv[0], "i") == 0)
					    style |= FSF_ITALIC;
					else if (Stricmp (argv[0], "ui") == 0)
					    style &= ~FSF_ITALIC;
					else if (Stricmp (argv[0], "u") == 0)
					    style |= FSF_UNDERLINED;
					else if (Stricmp (argv[0], "uu") == 0)
					    style &= ~FSF_UNDERLINED;
				    }
				    /* Color attribute */
				    else if (argc == 2)
				    {
					BYTE pen;

					if (Stricmp (argv[1], "text") == 0)
					    pen = cd->cd_GInfo.gi_DrInfo->dri_Pens[TEXTPEN];
					else if (Stricmp (argv[1], "shine") == 0)
					    pen = cd->cd_GInfo.gi_DrInfo->dri_Pens[SHINEPEN];
					else if (Stricmp (argv[1], "shadow") == 0)
					    pen = cd->cd_GInfo.gi_DrInfo->dri_Pens[SHADOWPEN];
					else if (Stricmp (argv[1], "fill") == 0)
					    pen = cd->cd_GInfo.gi_DrInfo->dri_Pens[FILLPEN];
					else if (Stricmp (argv[1], "filltext") == 0)
					    pen = cd->cd_GInfo.gi_DrInfo->dri_Pens[FILLTEXTPEN];
					else if (Stricmp (argv[1], "back") == 0)
					    pen = cd->cd_GInfo.gi_DrInfo->dri_Pens[BACKGROUNDPEN];
					else if (Stricmp (argv[1], "background") == 0)
					    pen = cd->cd_GInfo.gi_DrInfo->dri_Pens[BACKGROUNDPEN];
					else if (Stricmp (argv[1], "highlight") == 0)
					    pen = cd->cd_GInfo.gi_DrInfo->dri_Pens[HIGHLIGHTTEXTPEN];

					if (Stricmp (argv[0], "fg") == 0)
					    fgpen = pen;
					else if (Stricmp (argv[0], "bg") == 0)
					    bgpen = pen;
				    }
				    /* Button */
				    else
				    {
					LONG bofs, blen, msize;

					blen = strlen (argv[0]);
					bofs = anchor + (&argv[0][0] - &saveBuffer[256]) + 2;

					SetSoftStyle (&trp, FS_NORMAL, 0xFF);
					swidth = TextLength (&trp, argv[0], blen) + 8;

					/* Buttons can't wrap... */
					if ((dbd->dbd_Flags & DBDF_WRAP) && line && (swidth > (width - offset)))
					{
					    line->ln_Flags |= LNF_LF;
					    mwidth = MAX (mwidth, lwidth);
					    lwidth = 0;
					    offset = 0;
					}

					msize = sizeof (struct Line) + strlen (saveBuffer) + 1;
					if (line = allocpvec (ag, cd->cd_Pool, msize, MEMF_CLEAR | MEMF_PUBLIC))
					{
					    line->ln_Text = &nd->nd_Buffer[bofs];
					    line->ln_TextLen = blen;
					    line->ln_XOffset = offset;
					    line->ln_Width = swidth;
					    line->ln_FgPen = fgpen;
					    line->ln_BgPen = bgpen;
					    line->ln_Style = FS_NORMAL;
					    line->ln_Flags |= LNF_LINK;
					    line->ln_Data = MEMORY_FOLLOWING (line);
					    strcpy (line->ln_Data, saveBuffer);
					    AddTail ((struct List *) & cd->cd_LineList, (struct Node *) line);

					    if (lf || ((dbd->dbd_Flags & DBDF_WRAP) && (swidth > (width - offset))))
					    {
						line->ln_Flags |= LNF_LF;
						mwidth = MAX (mwidth, lwidth);
						lwidth = 0;
						offset = 0;
					    }
					    else
					    {
						offset += swidth;
						lwidth += swidth;
					    }
					}
				    }
				}

				DoCancel (ag, cd);
				noprint = split = TRUE;
			    }
			    else
			    {
				saveBuffer[cd->cd_CharsInBuffer++] = ch;
				num++;
			    }
			}
		    }
		    else if ((nd->nd_Buffer[i - 1] != '\\') && (ch == '@@') && (nd->nd_Buffer[i + 1] == CBS))
		    {
			if (num == 0)
			    anchor--;

			if (tabs)
			{
			    num--;
			    noprint = TRUE;
			}
			split = cd->cd_InSequence = TRUE;
			cbs = 0;
		    }
		    else if (ch == '\t')
		    {
			if (chs)
			{
			    split = TRUE;
			}
			else
			{
			    if (tabs++ || !lwidth)
				twidth = tspace;
			    else
				twidth = (((lwidth / tspace) + 1) * tspace) - lwidth;

			    noprint = TRUE;
			    if (!(dbd->dbd_Flags & DBDF_WRAP) || (swidth + twidth <= width - offset))
			    {
				offset += twidth;
				swidth += twidth;
				lwidth += twidth;
				num++;
			    }
			    else
			    {
				lf = TRUE;
			    }
			}
		    }
		    else if ((ch == '\n') || (ch == 0) || (ch == 12))
		    {
			lf = TRUE;
		    }
		    else if ((ch == '\\') && (nd->nd_Buffer[i + 1] == '@@'))
		    {
			split = TRUE;
		    }
		    else
		    {
			if (tabs)
			{
			    num--;
			    noprint = split = TRUE;
			}
			else
			{
			    if (space && kern)
			    {
				smallbuffer[0] = ch;
				twidth = TextLength (&trp, smallbuffer, 1);
			    }
			    else
				twidth = font->tf_XSize;

			    if ((num == 0) && (style & FSF_ITALIC))
				offset += font->tf_XSize / 3;

			    if (!(dbd->dbd_Flags & DBDF_WRAP) || (swidth + twidth <= width - offset))
			    {
				swidth += twidth;
				lwidth += twidth;
				num++;
			    }
			    else
			    {
				lf = TRUE;
				if (lspace >= 0)
				    num -= (i - lspace);
				else
				    wrap = TRUE;
			    }

			    chs++;
			    if (ch == ' ')
				lspace = i;
			}
		    }

		    if (lf || split || ((dbd->dbd_Flags & DBDF_WRAP) && (swidth > (width - offset))))
		    {
			if ((nd->nd_Buffer[anchor] == '@@') && isalpha (nd->nd_Buffer[anchor + 1]))
			{
			    noprint = TRUE;
			}

			if (noprint)
			{
			    if (line && lf)
			    {
				line->ln_Flags |= LNF_LF;
				mwidth = MAX (mwidth, lwidth);
				lwidth = 0;
				offset = 0;
			    }
			}
			else
			{
			    if (line = allocpvec (ag, cd->cd_Pool, sizeof (struct Line), MEMF_CLEAR | MEMF_PUBLIC))
			    {
				SetSoftStyle (&trp, style, 0xFF);
				swidth = TextLength (&trp, &nd->nd_Buffer[anchor], num);
				line->ln_Text = &nd->nd_Buffer[anchor];
				line->ln_TextLen = num;
				line->ln_XOffset = offset;
				line->ln_Width   = swidth;
				line->ln_FgPen   = fgpen;
				line->ln_BgPen   = bgpen;
				line->ln_Style   = style;
				AddTail ((struct List *) & cd->cd_LineList, (struct Node *) line);

				if (lf || ((dbd->dbd_Flags & DBDF_WRAP) && (swidth > (width - offset))))
				{
				    line->ln_Flags |= LNF_LF;
				    mwidth = MAX (mwidth, lwidth);
				    lwidth = 0;
				    offset = 0;
				}
				else
				{
				    offset += swidth;
				}
			    }

			    if (!lf && num && (num < len))
				num--;
			}

			i = anchor + num;
			anchor = i + 1;
d330 21
a350 6
			if (wrap)
			    anchor--;

			lspace = -1;
			chs = tabs = num = len = swidth = 0;
			noprint = split = wrap = lf = FALSE;
d352 2
a353 3
			/* Aborted? */
			bsig = CheckSignal (SIGBREAKF_CTRL_E);
		    }
a368 1
	    total--;
d371 2
a372 2
	    si->si_VisVert  = cd->cd_VisVert = cd->cd_Height / cd->cd_LineHeight;
	    si->si_TotVert  = total;
d375 1
a375 1
	    si->si_TotHoriz = cd->cd_TotHoriz = mwidth;
@


39.11
log
@layout bugs fixed
@
text
@d83 1
d408 1
d439 9
a447 4
			    if (ch == CBS)
				cbs++;
			    else if (ch == CBE)
				cbs--;
@


39.10
log
@render speedup.
@
text
@a11 3
#define	DH(x)	;
#define	DF(x)	;
#define	DX(x)	;
a65 1
    BOOL noprint;
d76 1
a82 1
    BOOL split;
d88 1
a88 1
    BOOL lf;
a89 2
    WORD cn;
    WORD cbs;
d92 8
a100 1
    DB (kprintf ("layoutMethod\n"));
a103 2
    {
	DB (kprintf ("no current node\n"));
a104 1
    }
d145 1
a145 2
	/* Clear the line list */
	cd->cd_TotVert = 0;
a152 1
	DB (kprintf ("  get state of controls\n"));
a210 1
	DB (kprintf ("  layout control panel\n"));
d249 2
a250 2
	    /* Clear the connection */
	    setattrs (ag, nd->nd_Object, ICA_TARGET, NULL, TAG_DONE);
a252 1
	    DB (kprintf ("ag : set size\n"));
d254 4
a257 4
		      GA_Left, domain->Left,
		      GA_Top, cd->cd_Top,
		      GA_Width, domain->Width,
		      GA_Height, cd->cd_Height - 1,
a259 1
	    DX (kprintf ("ag : layout %ld\n", initial));
a263 1
	    DX (kprintf ("ag : layout complete\n"));
d267 4
a270 4
			DTA_VisibleVert, (ULONG *) & cd->cd_VisVert,
			DTA_TotalVert, (ULONG *) & cd->cd_TotVert,
			DTA_VisibleHoriz, (ULONG *) & cd->cd_VisHoriz,
			DTA_TotalHoriz, (ULONG *) & cd->cd_TotHoriz,
a271 8

	    /* Hook it up now */
#if 0
	    setattrs (ag, nd->nd_Object, ICA_TARGET, cd->cd_Glue, TAG_DONE);
#endif
	    /* show that we've need to be refreshed */
	    cd->cd_Flags &= ~AGF_SYNC;
	    cd->cd_Flags |= AGF_LAYOUT;
a275 1
	    DB (kprintf ("  layout text\n"));
d311 1
d313 3
a327 1
			    DH (kprintf ("host buffer : 0x%lx len=%ld\n", nd->nd_Buffer, nd->nd_BufferLen));
a330 1
			    DH (kprintf ("host filename : [%s]\n", nd->nd_ONM.onm_FileName));
a357 4
		    else
		    {
			DH (kprintf ("host couldn't open %s\n", nd->nd_Name));
		    }
d378 8
a385 1
	    ReleaseSemaphore (&nd->nd_Lock);
d393 1
a393 1
		kern = (WORD *) (font->tf_CharKern);
d400 1
d448 1
d465 1
d492 1
a509 1
					    cd->cd_TotVert++;
a532 1
						cd->cd_TotVert++;
d610 1
a610 1
			    if (space && kern)	/* font->tf_Flags & FPF_PROPORTIONAL) */
d612 2
a613 8
				if ((ch > font->tf_HiChar) || (ch < font->tf_LoChar))
				    ch = font->tf_HiChar;
				cn = ch - font->tf_LoChar;

				if ((num == 0) && (kern[cn] < 0))
				    offset += ABS (kern[cn]);

				twidth = space[cn] + kern[cn];
d632 2
a656 1
				cd->cd_TotVert++;
a664 1

d668 4
a671 4
				line->ln_Width = swidth;
				line->ln_FgPen = fgpen;
				line->ln_BgPen = bgpen;
				line->ln_Style = style;
a679 1
				    cd->cd_TotVert++;
d694 3
d699 1
a699 1
			split = lf = noprint = FALSE;
d707 30
a736 3
	    cd->cd_VisVert = cd->cd_Height / cd->cd_LineHeight;
	    cd->cd_VisHoriz = domain->Width;
	    cd->cd_TotHoriz = mwidth;
a741 6
    else
    {
	DF (kprintf ("  no font!\n"));
    }

    DB (kprintf ("layout complete\n"));
@


39.9
log
@color support.
@
text
@d14 1
d18 26
a45 1

d150 1
a150 1
	    FreeVec (line);
d254 3
a263 1
		      ICA_TARGET, NULL,
d266 3
a268 3
	    DB (kprintf ("ag : layout %ld\n", initial));
	    gpl.MethodID = DTM_PROCLAYOUT;
	    gpl.gpl_GInfo = (cd->cd_Window) ? &cd->cd_GInfo : NULL;
d271 1
a271 1
	    DB (kprintf ("ag : layout complete\n"));
d281 2
d284 4
d522 1
a522 1
					if (line = AllocVec (msize, MEMF_CLEAR | MEMF_PUBLIC))
d676 1
a676 1
			    if (line = AllocVec (sizeof (struct Line), MEMF_CLEAR | MEMF_PUBLIC))
d724 3
a727 4

	/* show that we've been layed out */
	cd->cd_Flags |= AGF_LAYOUT | AGF_SYNC;
	DF (kprintf ("  AGF_LAYOUT has been set\n"));
@


39.8
log
@tracks help group
@
text
@d384 7
a390 7
		fgpen = 1;
		bgpen = 0;
		tabs = 0;
		chs = 0;
		num = 0;
		len = 0;
		cbs = 0;
d425 1
a425 1
				    if (argc > 1)
d427 42
a515 16
				    }
				    else
				    {
					/* Attributes */
					if (Stricmp (argv[0], "b") == 0)
					    style |= FSF_BOLD;
					else if (Stricmp (argv[0], "ub") == 0)
					    style &= ~FSF_BOLD;
					else if (Stricmp (argv[0], "i") == 0)
					    style |= FSF_ITALIC;
					else if (Stricmp (argv[0], "ui") == 0)
					    style &= ~FSF_ITALIC;
					else if (Stricmp (argv[0], "u") == 0)
					    style |= FSF_UNDERLINED;
					else if (Stricmp (argv[0], "uu") == 0)
					    style &= ~FSF_UNDERLINED;
@


39.7
log
@set busy flag
@
text
@d30 1
a30 1
    struct TextFont *font = NULL;
a39 1
    struct opNodeIO onm;
d267 19
d287 5
a291 3
		    memset (&onm, 0, sizeof (struct opNodeIO));
		    onm.MethodID = HM_OPENNODE;
		    onm.onm_Node = nd->nd_Name;
d297 1
a297 1
		    if ((*he) ((struct Hook *) dbd->dbd_HH, dbd->dbd_Name, &onm))
d299 1
a299 1
			if (onm.onm_Flags & HTNF_DONE)
d303 1
a303 1
			else if (onm.onm_DocBuffer)
d305 2
a306 2
			    nd->nd_Buffer = onm.onm_DocBuffer;
			    nd->nd_BufferLen = onm.onm_BuffLen;
d309 1
a309 1
			else if (onm.onm_FileName)
d311 2
a312 2
			    DH (kprintf ("host filename : [%s]\n", onm.onm_FileName));
			    if (fh = Open (onm.onm_FileName, MODE_OLDFILE))
d338 4
@


39.6
log
@*** empty log message ***
@
text
@d113 1
d222 1
a222 1
	cd->cd_Height = domain->Height - cd->cd_Top;
@


39.5
log
@*** empty log message ***
@
text
@d13 1
d33 1
d41 1
a41 1
    struct Line *line;
d62 1
a72 4
    /* For enabling/disabling */
    struct _Object *ob;
    BPTR lock;

d74 1
d78 2
d81 1
d83 4
d91 1
a91 14
    /* No wrap, then we will need a layer */
    if (!(dbd->dbd_Flags & DBDF_WRAP))
	dbd->dbd_Flags |= DBDF_LAYER;
    cd->cd_Flags |= AGF_RENDER;

    /* Clear the line list */
    cd->cd_TotVert = 0;
    while (line = (struct Line *) RemHead ((struct List *) & cd->cd_LineList))
	FreeVec (line);

    /* Get the domain of the object */
    GetAttr (DTA_Domain, o, (ULONG *) & domain);

    /* Get the font information */
d96 2
a97 36
    SetFont (cd->cd_Window->RPort, font);

    /* Initialize text RastPort */
    cd->cd_Render = *cd->cd_Window->RPort;
    SetDrMd (&cd->cd_Render, JAM2);
    SetAPen (&cd->cd_Render, cd->cd_GInfo.gi_DrInfo->dri_Pens[TEXTPEN]);
    SetBPen (&cd->cd_Render, cd->cd_GInfo.gi_DrInfo->dri_Pens[BACKGROUNDPEN]);
    cd->cd_Render.Mask = 0xFF;
    cd->cd_LineHeight = font->tf_YSize + 2;
    si->si_VertUnit = (LONG) cd->cd_LineHeight;
    si->si_HorizUnit = 1L;

    /* Initialize control panel RastPort */
    cd->cd_Control = *cd->cd_Window->RPort;
    SetDrMd (&cd->cd_Control, JAM2);
    SetAPen (&cd->cd_Control, cd->cd_GInfo.gi_DrInfo->dri_Pens[TEXTPEN]);
    SetBPen (&cd->cd_Control, cd->cd_GInfo.gi_DrInfo->dri_Pens[BACKGROUNDPEN]);
    SetFont (&cd->cd_Control, cd->cd_GInfo.gi_DrInfo->dri_Font);
    cd->cd_ControlHeight = cd->cd_GInfo.gi_DrInfo->dri_Font->tf_YSize + 3;
    cd->cd_Control.Mask = 0xFF;

    /* Initialize clear RastPort */
    cd->cd_Clear = *cd->cd_Window->RPort;
    SetDrMd (&cd->cd_Clear, JAM2);
    SetAPen (&cd->cd_Clear, cd->cd_GInfo.gi_DrInfo->dri_Pens[BACKGROUNDPEN]);
    SetBPen (&cd->cd_Clear, cd->cd_GInfo.gi_DrInfo->dri_Pens[BACKGROUNDPEN]);
    cd->cd_Clear.Mask = 0xFF;

    /* Initialize highlight RastPort */
    cd->cd_Highlight = *cd->cd_Window->RPort;
    SetDrMd (&cd->cd_Highlight, COMPLEMENT);
    cd->cd_Highlight.Mask = 0x1;

    /* Initialize the temporary rastport */
    InitRastPort (&trp);
    SetFont (&trp, font);
d99 1
a99 1
    /* Kind of late now to be checking this??? */
d102 27
d130 1
d189 1
a253 1
	    cd->cd_Flags |= AGF_SYNC;
d258 1
d478 1
a478 1
		    else if ((ch == '@@') && (nd->nd_Buffer[i + 1] == CBS))
d522 4
d573 1
a573 1
			if ((nd->nd_Buffer[anchor] == '@@') && isalpha (nd->nd_Buffer[anchor+1]))
d640 1
d642 6
a647 1
	cd->cd_Flags |= AGF_LAYOUT;
d650 1
@


39.4
log
@now uses LVOLockE to lock help file
@
text
@d7 1
d580 5
@


39.3
log
@added Highlight rastport
@
text
@d164 1
a164 1
			if (lock = Lock (MASTER_HELP, ACCESS_READ))
@


39.2
log
@ghost buttons
@
text
@a25 1

d27 1
a30 1
    struct DTSpecialInfo *si;
a81 1
    si = (struct DTSpecialInfo *) G (o)->SpecialInfo;
d101 1
d108 1
a108 1
    SetFont (&cd->cd_Render, font);
d110 2
d120 1
d127 6
a132 1
    SetFont (&cd->cd_Clear, font);
d179 4
a182 1
			cd->cd_Controls[i].c_Flags &= ~CF_DISABLED;
d189 4
a192 1
			cd->cd_Controls[i].c_Flags &= ~CF_DISABLED;
@


39.1
log
@*** empty log message ***
@
text
@d6 1
d11 1
d17 1
d26 2
d29 1
d34 1
a36 2
    struct IBox *domain = NULL;
    struct ClientData *cd;
d38 1
d40 2
a63 1
    LONG i, j, k, x;
d68 5
a72 1
    struct IBox lbox;
a77 2
    {
	kprintf ("ag : no current node\n");
a78 1
    }
d81 1
d96 1
a96 1
    GetAttr (DTA_Domain, o, (ULONG *)&domain);
d134 52
d194 5
a198 5
	    cd->cd_Controls[i].c_Left     = x;
	    cd->cd_Controls[i].c_TLeft    = x + j;
	    cd->cd_Controls[i].c_Top      = cd->cd_Top;
	    cd->cd_Controls[i].c_ID       = STM_CONTENTS + k;
	    cd->cd_Controls[i].c_Label    = label;
d201 3
a203 1
	    if (i==2)
d205 1
d219 1
a219 1
	cd->cd_Top   += cd->cd_ControlHeight + 2;
d228 5
a232 5
		      GA_Left,		domain->Left,
		      GA_Top,		cd->cd_Top,
		      GA_Width,		domain->Width,
		      GA_Height,	cd->cd_Height - 1,
		      ICA_TARGET,	NULL,
d236 2
a237 2
	    gpl.MethodID    = GM_LAYOUT;
	    gpl.gpl_GInfo   = (cd->cd_Window) ? &cd->cd_GInfo : NULL;
d239 1
a239 1
	    DoMethodA (nd->nd_Object, &gpl);
d244 5
a248 5
			DTA_VisibleVert,	(ULONG *)&cd->cd_VisVert,
		        DTA_TotalVert,		(ULONG *)&cd->cd_TotVert,
			DTA_VisibleHoriz,	(ULONG *)&cd->cd_VisHoriz,
		        DTA_TotalHoriz,		(ULONG *)&cd->cd_TotHoriz,
		        TAG_DONE);
d257 2
d261 55
d317 1
a317 1
		if (nd->nd_Buffer = AllocVec (nd->nd_BufferLen + 2, MEMF_CLEAR))
d323 5
a327 1
		    if (!(Read (nd->nd_FileHandle, nd->nd_Buffer, nd->nd_BufferLen) == nd->nd_BufferLen))
d337 1
a337 27
	    /* Set up our work variables */
	    DoCancel (ag, cd);

	    space = (WORD *) (font->tf_CharSpace);
	    kern = (WORD *) (font->tf_CharKern);

	    /* Initialize the variables */
	    width = (LONG) domain->Width;
	    tspace = 8 * font->tf_XSize;
	    noprint = FALSE;
	    split = FALSE;
	    lspace = -1;
	    lf = FALSE;
	    offset = 0;
	    swidth = 0;
	    lwidth = 0;
	    mwidth = 0;
	    fgpen = 1;
	    bgpen = 0;
	    tabs = 0;
	    chs = 0;
	    num = 0;
	    len = 0;
	    cbs = 0;

	    /* Used to have <= instead of < */
	    for (anchor = i = bsig = 0; (i <= nd->nd_BufferLen) && (bsig == 0); i++)
d339 2
a340 2
		len++;
		ch = nd->nd_Buffer[i];
d342 29
a370 3
		if (cd->cd_InSequence)
		{
		    if (((ch == '@@') && (nd->nd_Buffer[i + 1] == CBS)) || ((ch == CBS) && (cbs == 0)))
d372 1
a372 1
			if (ch == '@@')
d374 5
a378 1
			    i++;
d380 3
d384 6
a389 11
			num++;
			cbs = 1;
			DoCancel (ag, cd);
			cd->cd_InSequence = TRUE;
		    }
		    else
		    {
			if (ch == CBS)
			    cbs++;
			else if (ch == CBE)
			    cbs--;
d391 1
a391 5
			if (cbs == 0)
			{
			    saveBuffer[cd->cd_CharsInBuffer] = 0;
			    strcpy (&saveBuffer[256], saveBuffer);
			    if ((argc = ParseString (ag, &saveBuffer[256], argv, MAXARG)) > 0)
d393 3
a395 1
				if (argc > 1)
d397 3
a399 4
				    LONG bofs, blen, msize;

				    blen = strlen (argv[0]);
				    bofs = anchor + (&argv[0][0] - &saveBuffer[256]) + 2;
d401 2
a402 2
				    SetSoftStyle (&trp, FS_NORMAL, 0xFF);
				    swidth = TextLength (&trp, argv[0], blen) + 8;
d404 2
a405 24
				    /* Buttons can't wrap... */
				    if ((dbd->dbd_Flags & DBDF_WRAP) && line && (swidth > (width - offset)))
				    {
					line->ln_Flags |= LNF_LF;
					mwidth = MAX (mwidth, lwidth);
					lwidth = 0;
					offset = 0;
					cd->cd_TotVert++;
				    }

				    msize = sizeof (struct Line) + strlen (saveBuffer) + 1;
				    if (line = AllocVec (msize, MEMF_CLEAR | MEMF_PUBLIC))
				    {
					line->ln_Text = &nd->nd_Buffer[bofs];
					line->ln_TextLen = blen;
					line->ln_XOffset = offset;
					line->ln_Width = swidth;
					line->ln_FgPen = fgpen;
					line->ln_BgPen = bgpen;
					line->ln_Style = FS_NORMAL;
					line->ln_Flags |= LNF_LINK;
					line->ln_Data = MEMORY_FOLLOWING (line);
					strcpy (line->ln_Data, saveBuffer);
					AddTail ((struct List *) & cd->cd_LineList, (struct Node *) line);
d407 2
a408 1
					if (lf || ((dbd->dbd_Flags & DBDF_WRAP) && (swidth > (width - offset))))
d416 3
a418 1
					else
d420 25
a444 2
					    offset += swidth;
					    lwidth += swidth;
d447 16
d464 8
a471 16
				else
				{
				    /* Attributes */
				    if (Stricmp (argv[0], "b") == 0)
					style |= FSF_BOLD;
				    else if (Stricmp (argv[0], "ub") == 0)
					style &= ~FSF_BOLD;
				    else if (Stricmp (argv[0], "i") == 0)
					style |= FSF_ITALIC;
				    else if (Stricmp (argv[0], "ui") == 0)
					style &= ~FSF_ITALIC;
				    else if (Stricmp (argv[0], "u") == 0)
					style |= FSF_UNDERLINED;
				    else if (Stricmp (argv[0], "uu") == 0)
					style &= ~FSF_UNDERLINED;
				}
d473 6
d480 1
a480 4
			    DoCancel (ag, cd);
			    noprint = split = TRUE;
			}
			else
d482 2
a483 2
			    saveBuffer[cd->cd_CharsInBuffer++] = ch;
			    num++;
d485 2
a486 20
		    }
		}
		else if ((ch == '@@') && (nd->nd_Buffer[i + 1] == CBS))
		{
		    if (num==0)
			anchor--;

		    if (tabs)
		    {
			num--;
			noprint = TRUE;
		    }
		    split = cd->cd_InSequence = TRUE;
		    cbs = 0;
		}
		else if (ch == '\t')
		{
		    if (chs)
		    {
			split = TRUE;
d488 1
a488 1
		    else
d490 1
a490 7
			if (tabs++ || !lwidth)
			    twidth = tspace;
			else
			    twidth = (((lwidth / tspace) + 1) * tspace) - lwidth;

			noprint = TRUE;
			if (!(dbd->dbd_Flags & DBDF_WRAP) || (swidth + twidth <= width - offset))
d492 1
a492 4
			    offset += twidth;
			    swidth += twidth;
			    lwidth += twidth;
			    num++;
d496 17
a512 1
			    lf = TRUE;
d515 1
a515 8
		}
		else if ((ch == '\n') || (ch == 0) || (ch == 12))
		{
		    lf = TRUE;
		}
		else
		{
		    if (tabs)
d517 1
a517 2
			num--;
			noprint = split = TRUE;
d521 1
a521 1
			if (space && kern)	/* font->tf_Flags & FPF_PROPORTIONAL) */
d523 2
a524 8
			    if ((ch > font->tf_HiChar) || (ch < font->tf_LoChar))
				ch = font->tf_HiChar;
			    cn = ch - font->tf_LoChar;

			    if ((num == 0) && (kern[cn] < 0))
				offset += ABS (kern[cn]);

			    twidth = space[cn] + kern[cn];
d527 6
a532 1
			    twidth = font->tf_XSize;
d534 2
a535 2
			if ((num == 0) && (style & FSF_ITALIC))
			    offset += font->tf_XSize / 3;
d537 7
a543 12
			if (!(dbd->dbd_Flags & DBDF_WRAP) || (swidth + twidth <= width - offset))
			{
			    swidth += twidth;
			    lwidth += twidth;
			    num++;
			}
			else
			{
			    lf = TRUE;
			    if (lspace >= 0)
				num -= (i - lspace);
			}
d545 12
a556 5
			chs++;
			if (ch == ' ')
			    lspace = i;
		    }
		}
d558 3
a560 11
		if (lf || split || ((dbd->dbd_Flags & DBDF_WRAP) && (swidth > (width - offset))))
		{
		    if (noprint)
		    {
			if (line && lf)
			{
			    line->ln_Flags |= LNF_LF;
			    mwidth = MAX (mwidth, lwidth);
			    lwidth = 0;
			    offset = 0;
			    cd->cd_TotVert++;
d563 2
a564 1
		    else
d566 1
a566 1
			if (line = AllocVec (sizeof (struct Line), MEMF_CLEAR | MEMF_PUBLIC))
d568 1
a568 13
			    SetSoftStyle (&trp, style, 0xFF);
			    swidth = TextLength (&trp, &nd->nd_Buffer[anchor], num);

			    line->ln_Text = &nd->nd_Buffer[anchor];
			    line->ln_TextLen = num;
			    line->ln_XOffset = offset;
			    line->ln_Width = swidth;
			    line->ln_FgPen = fgpen;
			    line->ln_BgPen = bgpen;
			    line->ln_Style = style;
			    AddTail ((struct List *) & cd->cd_LineList, (struct Node *) line);

			    if (lf || ((dbd->dbd_Flags & DBDF_WRAP) && (swidth > (width - offset))))
d576 4
a579 1
			    else
d581 24
a604 1
				offset += swidth;
d606 3
d611 9
a619 2
			if (!lf && num && (num < len))
			    num--;
a620 10

		    i = anchor + num;
		    anchor = i + 1;

		    lspace = -1;
		    chs = tabs = num = len = swidth = 0;
		    split = lf = noprint = FALSE;

		    /* Aborted? */
		    bsig = CheckSignal (SIGBREAKF_CTRL_E);
d624 1
a624 2
	    cd->cd_VisVert  = cd->cd_Height / cd->cd_LineHeight;
	    cd->cd_TotVert  = cd->cd_TotVert;
@


39.0
log
@initial RCS
@
text
@a9 1
#define	DL(x)	;
a12 34
WORD GetLabelsExtent (struct AGLib * ag, struct RastPort *rp, LONG min, LONG max, struct IBox * box)
{
    WORD retval = 0;
    STRPTR label;
    WORD w = 0;
    LONG i;

    /* Clear the upper-left corner */
    box->Left = box->Top = 0;

    /* Compute the height of the label, plus the gadget border. */
    box->Height = rp->TxHeight + 4;

    /* Check each label */
    for (i = min; i <= max; i++)
    {
	/* Get the string to use */
	label = LVOGetAGString (ag, i);

	/* Remember the maximum width label */
	w = MAX (w, (TextLength (rp, label, strlen (label))));

	/* Increment the label counter */
	retval++;
    }

    /* Add in a little extra space, plus the gadget border. */
    box->Width = w + TextLength (rp, "m", 1) + 8;

    return retval;
}

/*****************************************************************************/

d65 7
d79 1
d82 1
a82 1
    si->si_TotVert = 0;
d162 1
a162 1
	    DL (kprintf ("layout nd_Object\n"));
d164 5
a168 4
		      GA_Left,	domain->Left,
		      GA_Top,	cd->cd_Top,
		      GA_Width,	domain->Width,
		      GA_Height,cd->cd_Height - 1,
d171 1
d176 12
d287 1
a287 1
					si->si_TotVert++;
d311 1
a311 1
					    si->si_TotVert++;
d447 1
a447 1
			    si->si_TotVert++;
d472 1
a472 1
				si->si_TotVert++;
d496 4
a499 6
	    si->si_TopVert = 0L;
	    si->si_VisVert = cd->cd_Height / cd->cd_LineHeight;
	    si->si_TotVert = si->si_TotVert;
	    si->si_TopHoriz = 0;
	    si->si_VisHoriz = domain->Width;
	    si->si_TotHoriz = mwidth;
d501 2
@
