head     39.17;
branch   ;
access   ;
symbols  ;
locks    davidj:39.17; strict;
comment  @ * @;


39.17
date     93.06.17.14.19.23;  author davidj;  state Exp;
branches ;
next     39.16;

39.16
date     93.05.13.13.55.46;  author davidj;  state Exp;
branches ;
next     39.15;

39.15
date     93.05.04.16.52.15;  author davidj;  state Exp;
branches ;
next     39.14;

39.14
date     93.05.03.10.54.10;  author davidj;  state Exp;
branches ;
next     39.13;

39.13
date     93.04.30.16.13.44;  author davidj;  state Exp;
branches ;
next     39.12;

39.12
date     93.04.27.09.50.25;  author davidj;  state Exp;
branches ;
next     39.11;

39.11
date     93.04.23.09.42.44;  author davidj;  state Exp;
branches ;
next     39.10;

39.10
date     93.03.24.12.16.54;  author davidj;  state Exp;
branches ;
next     39.9;

39.9
date     93.03.22.16.31.17;  author davidj;  state Exp;
branches ;
next     39.8;

39.8
date     92.08.31.17.17.20;  author davidj;  state Exp;
branches ;
next     39.7;

39.7
date     92.08.13.13.41.59;  author davidj;  state Exp;
branches ;
next     39.6;

39.6
date     92.08.10.16.46.53;  author davidj;  state Exp;
branches ;
next     39.5;

39.5
date     92.08.05.17.26.20;  author davidj;  state Exp;
branches ;
next     39.4;

39.4
date     92.07.15.22.32.27;  author davidj;  state Exp;
branches ;
next     39.3;

39.3
date     92.06.23.03.46.13;  author davidj;  state Exp;
branches ;
next     39.2;

39.2
date     92.06.22.09.57.17;  author davidj;  state Exp;
branches ;
next     39.1;

39.1
date     92.06.19.04.04.22;  author davidj;  state Exp;
branches ;
next     39.0;

39.0
date     92.06.02.08.30.20;  author davidj;  state Exp;
branches ;
next     ;


desc
@initial RCS
@


39.17
log
@*** empty log message ***
@
text
@/* dbdispatch.c
 *
 */

#include "amigaguidebase.h"
#include "hosthandle.h"
#include <stdlib.h>

/*****************************************************************************/

#define	DB(x)	;

/*****************************************************************************/

#define	AG_PREFIX	"@@{"
#define	AG_PREFIX_LEN	2

/*****************************************************************************/

static STRPTR errMsgs[] =
{
    "missing argument(s)",
    "couldn't create node",
    "must be inside a node",
    "line too long",
    "doesn't contain any nodes",
    "missing endnode(s)",
};

/*****************************************************************************/

static STRPTR warnMsgs[] =
{
    "undefined keyword",
};

/*****************************************************************************/

enum
{
    DBDK_DATABASE,
    DBDK_AUTHOR,
    DBDK_ANNOTATION,			/* Not used */
    DBDK_COPYRIGHT,
    DBDK_VERSION,

    DBDK_XREF,
    DBDK_NAME,				/* Not used */
    DBDK_INDEX,
    DBDK_HELP,

    DBDK_TITLE,
    DBDK_TOC,
    DBDK_PREVIOUS,
    DBDK_NEXT,
    DBDK_KEYWORDS,

    DBDK_ONOPEN,
    DBDK_ONCLOSE,

    DBDK_DNODE,
    DBDK_EMBED,
    DBDK_ENDNODE,
    DBDK_FONT,
    DBDK_HEIGHT,
    DBDK_MACRO,
    DBDK_MASTER,
    DBDK_NODE,
    DBDK_PROPORTIONAL,
    DBDK_REMARK,
    DBDK_SMARTWRAP,
    DBDK_TAB,
    DBDK_WIDTH,
    DBDK_WORDWRAP,
};

/*****************************************************************************/

static const struct Keyword dbd_Keywords[] =
{
    {"$VER:",		DBDK_VERSION},
    {"(C)",		DBDK_COPYRIGHT},
    {"AUTHOR",		DBDK_AUTHOR},
    {"DATABASE",	DBDK_DATABASE},
    {"DNODE",		DBDK_DNODE},
    {"EMBED",		DBDK_EMBED},
    {"ENDNODE",		DBDK_ENDNODE},
    {"FONT",		DBDK_FONT},
    {"HEIGHT",		DBDK_HEIGHT},
    {"HELP",		DBDK_HELP},
    {"INDEX",		DBDK_INDEX},
    {"KEYWORDS",	DBDK_KEYWORDS},
    {"MACRO",		DBDK_MACRO},
    {"MASTER",		DBDK_MASTER},
    {"NEXT",		DBDK_NEXT},
    {"NODE",		DBDK_NODE},
    {"ONCLOSE",		DBDK_ONCLOSE},
    {"ONOPEN",		DBDK_ONOPEN},
    {"PREV",		DBDK_PREVIOUS},
    {"PROPORTIONAL",	DBDK_PROPORTIONAL},
    {"REM",		DBDK_REMARK},
    {"REMARK",		DBDK_REMARK},
    {"SMARTWRAP",	DBDK_SMARTWRAP},
    {"TAB",		DBDK_TAB},
    {"TITLE",		DBDK_TITLE},
    {"TOC",		DBDK_TOC},
    {"WIDTH",		DBDK_WIDTH},
    {"WORDWRAP",	DBDK_WORDWRAP},
    {"XREF",		DBDK_XREF},
};

#define	DBDK_TOTAL_KEYWORDS	(sizeof (dbd_Keywords) / sizeof (struct Keyword))

/*****************************************************************************/

static LONG dbd_debugPrintf (struct AGLib *ag, struct DatabaseData *dbd, STRPTR fmt, LONG argv,...)
{
    LONG retval = -1;

    if (dbd->dbd_Flags & DBDF_DEBUG)
    {
	if (dbd->dbd_ErrorFH == NULL)
	{
	    if (Stricmp (dbd->dbd_ErrorName, "ON") == 0)
		strcpy (dbd->dbd_ErrorName, "CON:0/0/400/75/AmigaGuide errors/CLOSE/WAIT");
	    dbd->dbd_ErrorFH = Open (dbd->dbd_ErrorName, MODE_NEWFILE);
	}

	if (dbd->dbd_ErrorFH)
	    retval = VFPrintf (dbd->dbd_ErrorFH, fmt, (LONG *) & argv);
    }

    return (retval);
}

/*****************************************************************************/

static void dbd_closeDebug (struct AGLib *ag, struct DatabaseData *dbd, LONG mode)
{
    /* Close the error file */
    if (dbd->dbd_ErrorFH)
    {
	if (mode == 1)
	    dbd_debugPrintf (ag, dbd, "\n%s: %ld Errors, %ld Warnings\n",
			 (LONG) dbd->dbd_Name, (LONG) dbd->dbd_Errors, (LONG) dbd->dbd_Warnings);

	Close (dbd->dbd_ErrorFH);
	dbd->dbd_ErrorFH = NULL;
    }
}

/*****************************************************************************/

static ULONG dbd_disposeDatabase (struct AGLib *ag, Class * cl, Object * o, Msg msg, struct DatabaseData *dbd)
{
    struct Node *ln;
    Object *ostate;
    Object *member;
    LONG i;

    /* Execute the close database command */
    if (dbd->dbd_OnClose)
    {
	sprintf (dbd->dbd_ErrorLine, "%s %s", dbd->dbd_OnClose, dbd->dbd_FullName);
	m_sendCmd (ag, dbd->dbd_ErrorLine);
    }

    /* Remove all the nodes from the node list */
    ostate = (Object *) dbd->dbd_NodeList.mlh_Head;
    while (member = NextObject (&ostate))
    {
	DoMethod (member, OM_REMOVE);
	DoMethodA (member, msg);
    }

    /* Free the macro list */
    while (ln = RemHead ((struct List *) &dbd->dbd_MacroList))
	FreeVec (ln);

    /* Close the fonts */
    if (dbd->dbd_Font)
	CloseFont (dbd->dbd_Font);
    for (i = 0; i < MAX_FONTS; i++)
    {
	if (dbd->dbd_Fonts[i])
	    CloseFont (dbd->dbd_Fonts[i]);
    }

    /* Close the file */
    if (dbd->dbd_FileHandle)
	Close (dbd->dbd_FileHandle);

    /* Unlock the lock */
    UnLock (dbd->dbd_FileLock);

    /* Free other variables */
    for (i = 0; i < DBD_STRINGS; i++)
	FreeVec (dbd->dbd_Strings[i]);

    /* Pass it up to the superclass */
    DoSuperMethodA (cl, o, msg);

    return (1L);
}

/*****************************************************************************/

/* Set attributes of an object */
static ULONG dbd_setAttrs (struct AGLib * ag, Class * cl, Object * o, struct opSet * msg)
{
    struct DatabaseData *dbd = INST_DATA (cl, o);
    struct TagItem *tags = msg->ops_AttrList;
    struct TagItem *tstate;
    struct TagItem *tag;
    ULONG refresh = 0L;
    ULONG tidata;
    ULONG i;

    /* process rest */
    tstate = tags;
    while (tag = NextTagItem (&tstate))
    {
	tidata = tag->ti_Data;
	switch (tag->ti_Tag)
	{
	    case DBA_Name:
	    case DBA_Index:
	    case DBA_Help:
	    case DBA_OnOpen:
	    case DBA_OnClose:
		i = tag->ti_Tag - DBA_Name;
		FreeVec (dbd->dbd_Strings[i]);
		dbd->dbd_Strings[i] = NULL;
		if (tidata && (dbd->dbd_Strings[i] = AllocVec (strlen ((STRPTR) tidata) + 1, MEMF_CLEAR)))
		    strcpy (dbd->dbd_Strings[i], (STRPTR) tidata);
		break;

	    case DBA_FileHandle:
		dbd->dbd_FileHandle = (BPTR) tidata;
		break;
#if 0
	    /* Set the cross reference for a database */
	    case DBA_XRef:
		break;
#endif
	}
    }

    return (refresh);
}

/*****************************************************************************/

static BOOL dbd_parseCommand (struct AGLib * ag, Object * o, struct DatabaseData * dbd, STRPTR cmd, ULONG * text)
{
    struct NodeData *nd;
    BOOL retval = FALSE;
    STRPTR argv[MAXARG];
    ULONG errnum = 0;
    ULONG token;
    ULONG argc;

    *text = FALSE;
    if ((argc = ParseString (ag, cmd, argv, MAXARG)) > 0)
    {
	retval = TRUE;

	if (strncmp (argv[0], AG_PREFIX, AG_PREFIX_LEN) == 0)
	{
	    if (dbd->dbd_CurrentNode)
		*text = TRUE;
	    else
		errnum = 3;
	}
	else
	{
	    /* Get the node data */
	    nd = NULL;
	    if (dbd->dbd_CurrentNode)
		nd = INST_DATA (ag->ag_NodeClass, dbd->dbd_CurrentNode);

	    /* Upper case the command to make comparision quicker */
	    StrToUpper (ag, argv[0]);

	    /* Tokenize and handle the command */
	    switch (token = m_binSearch (&argv[0][1], strlen (&argv[0][1]), dbd_Keywords, DBDK_TOTAL_KEYWORDS))
	    {
		/***************************************************************************/
		/***************************************************************************/
		/***************************************************************************/
		case DBDK_DATABASE:
		case DBDK_AUTHOR:
		case DBDK_ANNOTATION:
		case DBDK_COPYRIGHT:
		case DBDK_VERSION:
		    if (argc > 1)
			setattrs (ag, o, DTA_ObjName + (token - DBDK_DATABASE), argv[1], TAG_DONE);
		    else
			errnum = 1;
		    break;

		/***************************************************************************/
		/***************************************************************************/
		/***************************************************************************/
		case DBDK_XREF:
		case DBDK_INDEX:
		case DBDK_HELP:
		    if (argc > 1)
			setattrs (ag, o, DBA_XRef + (token - DBDK_XREF), argv[1], TAG_DONE);
		    else
			errnum = 1;
		    break;

		/***************************************************************************/
		/***************************************************************************/
		/***************************************************************************/
		case DBDK_TITLE:
		case DBDK_TOC:
		case DBDK_PREVIOUS:
		case DBDK_NEXT:
		case DBDK_KEYWORDS:
		    if (dbd->dbd_CurrentNode && (argc > 1))
			setattrs (ag, dbd->dbd_CurrentNode, HNA_Title + (token - DBDK_TITLE), argv[1], TAG_DONE);
		    else if (!dbd->dbd_CurrentNode)
			errnum = 3;
		    else
			errnum = 1;
		    break;

		/***************************************************************************/
		/***************************************************************************/
		/***************************************************************************/
		case DBDK_ONOPEN:
		case DBDK_ONCLOSE:
		    if (argc > 1)
		    {
			if (dbd->dbd_CurrentNode)
			    setattrs (ag, dbd->dbd_CurrentNode, HNA_OnOpen + (token - DBDK_ONOPEN), argv[1], TAG_DONE);
			else
			    setattrs (ag, o, DBA_OnOpen + (token - DBDK_ONOPEN), argv[1], TAG_DONE);
		    }
		    else
			errnum = 1;
		    break;

		/***************************************************************************/
		/***************************************************************************/
		/***************************************************************************/
		case DBDK_PROPORTIONAL:
		    if (dbd->dbd_CurrentNode)
			nd->nd_Flags |= HNF_PROPORTIONAL;
		    else
			dbd->dbd_Flags |= DBDF_PROPORTIONAL;
		    break;

		case DBDK_SMARTWRAP:
		    if (dbd->dbd_CurrentNode)
			nd->nd_Flags |= HNF_SMARTWRAP;
		    else
			dbd->dbd_Flags |= DBDF_SMARTWRAP;
		    break;

		case DBDK_WORDWRAP:
		    if (dbd->dbd_CurrentNode)
			nd->nd_Flags |= HNF_WRAP;
		    else
			dbd->dbd_Flags |= DBDF_WRAP;
		    break;

		/***************************************************************************/
		/***************************************************************************/
		/***************************************************************************/
		case DBDK_ENDNODE:
		    if (dbd->dbd_CurrentNode)
		    {
			dbd->dbd_NumEndNodes++;
			if (nd->nd_Offset == (-1))
			    nd->nd_Offset = dbd->dbd_Offset;
			nd->nd_BufferLen = dbd->dbd_Offset - nd->nd_Offset;
		    }
		    else
			errnum = 3;
		    dbd->dbd_CurrentNode = NULL;
		    break;

		case DBDK_FONT:
		    if (argc > 2)
		    {
			ULONG *font, size = 0;
			struct TextAttr *ta;
			STRPTR name;

			if (dbd->dbd_CurrentNode)
			{
			    font = (ULONG *) & nd->nd_Font;
			    name = nd->nd_FontName;
			    ta = &nd->nd_TextAttr;
			}
			else
			{
			    font = (ULONG *) & dbd->dbd_Font;
			    name = dbd->dbd_FontName;
			    ta = &dbd->dbd_TextAttr;
			}

			strncpy (name, argv[1], 32);
			StrToLong (argv[2], (LONG *) & size);

			ta->ta_Name = name;
			ta->ta_YSize = (UWORD) size;
			ta->ta_Style = NULL;
			ta->ta_Flags = NULL;

			if (*font)
			    CloseFont ((struct TextFont *) *font);
			if (!(*font = (ULONG) OpenDiskFont (ta)))
			    *font = (ULONG) OpenFont (ta);
		    }
		    else
			errnum = 1;
		    break;

		case DBDK_MACRO:
		    if (argc >= 2)
		    {
			ULONG size1, size2, size3;
			struct MacroNode *mn;

			/* How much space do we need */
			size1 = sizeof (struct MacroNode);

			size2 = strlen (argv[1]) + 2;
			size3 = strlen (argv[2]) + 2;

			/* Allocate a node structure */
			if (mn = AllocVec (size1 + size2 + size3, MEMF_CLEAR))
			{
			    /* Copy the macro name */
			    mn->mn_Node.ln_Name = (char *) mn + size1;
			    strcpy (mn->mn_Node.ln_Name, argv[1]);
			    StrToUpper (ag, mn->mn_Node.ln_Name);

			    /* Copy the macro */
			    mn->mn_Macro = mn->mn_Node.ln_Name + size2;
			    strcpy (mn->mn_Macro, argv[2]);

			    /* Add the node to the list */
			    AddTail ((struct List *) &dbd->dbd_MacroList, &mn->mn_Node);
			}
		    }
		    else
			errnum = 1;
		    break;

		case DBDK_MASTER:
		    if (argc > 1)
		    {
			struct Process *pr = (struct Process *) FindTask (NULL);
			struct FileInfoBlock *fib;
			struct DateStamp mds;
			APTR oldWP;
			BPTR lock;

			/* Turn off requesters for a moment */
			oldWP = pr->pr_WindowPtr;
			pr->pr_WindowPtr = (APTR) - 1;

			/* Try to lock the master file */
			if (lock = Lock (argv[1], ACCESS_READ))
			{
			    /* Get a temporary FIB to work with */
			    if (fib = AllocDosObject (DOS_FIB, NULL))
			    {
				/* Examine the master file */
				if (Examine (lock, fib))
				{
				    /* Copy the date of the master file. */
				    mds = *(&fib->fib_Date);

				    /* Examine the AmigaGuide file */
				    if (Examine (dbd->dbd_FileLock, fib))
				    {
					/* Compare the dates to see if the master has been updated. */
					if (CompareDates (&mds, &fib->fib_Date) < 0)
					{
					    /* Show that the file is stale */
					    dbd->dbd_Flags |= DBDF_STALE;
					}
				    }
				}
				/* Get rid of the temporary FIB */
				FreeDosObject (DOS_FIB, fib);
			    }
			    /* Unlock the master */
			    UnLock (lock);
			}

			/* Restore the window pointer */
			pr->pr_WindowPtr = oldWP;
		    }
		    else
			errnum = 1;
		    break;

		case DBDK_NODE:
		    /* End any node */
		    if (dbd->dbd_CurrentNode)
		    {
			errnum = 6;
		    }
		    /* Create a new Node object */
		    else if (argc > 1)
		    {
			STRPTR title, name;

			name = argv[1];
			title = (argv[2]) ? argv[2] : name;

			if (dbd->dbd_CurrentNode = NewObject (ag->ag_NodeClass, NULL,
								HNA_Name,	name,
								HNA_Title,	title,
								HNA_Database,	o,
								HNA_FileHandle,	dbd->dbd_FileHandle,
								TAG_DONE))
			    dbd->dbd_NumNodes++;
			else
			    errnum = 2;
		    }
		    else
			errnum = 1;
		    break;

		case DBDK_TAB:
		    if (argc > 1)
		    {
			ULONG i, j;

			StrToLong (argv[1], (LONG *) &i);
			if (dbd->dbd_CurrentNode)
			{
			    nd->nd_DefTabs = i;
			    for (i = j = 0; i < MAX_TABS; i++, j += nd->nd_DefTabs)
				nd->nd_Tabs[i] = j;
			}
			else
			{
			    dbd->dbd_DefTabs = i;
			    for (i = j = 0; i < MAX_TABS; i++, j += dbd->dbd_DefTabs)
				dbd->dbd_Tabs[i] = j;
			}
		    }
		    else
			errnum = 1;
		    break;

		/***************************************************************************/
		/***************************************************************************/
		/***************************************************************************/
		case DBDK_EMBED:
#if 0
		    if (dbd->dbd_CurrentNode && (argc > 1))
			setattrs (ag, dbd->dbd_CurrentNode,
				  HNA_EmbedName, argv[1],
				  HNA_EmbedLine, dbd->dbd_Offset - nd->nd_Offset,
				  TAG_DONE);
		    else if (!dbd->dbd_CurrentNode)
			errnum = 3;
		    else
			errnum = 1;
		    break;
#endif
		case DBDK_HEIGHT:
		case DBDK_REMARK:
		case DBDK_WIDTH:
		    break;

		/***************************************************************************/
		/***************************************************************************/
		/***************************************************************************/
		case DBDK_DNODE:
		    retval = FALSE;
		    break;

		default:
		    errnum = 100;
		    break;
	    }
	}
    }

    if (errnum)
    {
	if (errnum < 100)
	{
	    dbd->dbd_Errors++;
	    dbd_debugPrintf (ag, dbd, "%s, Line %ld, Error %ld: %s\n",
			 (LONG) dbd->dbd_Name, (LONG) dbd->dbd_NumLines, (LONG) errnum, (LONG) errMsgs[(errnum - 1)]);
	}
	else
	{
	    dbd->dbd_Warnings++;
	    dbd_debugPrintf (ag, dbd, "%s, Line %ld, Warning %ld: %s\n",
			 (LONG) dbd->dbd_Name, (LONG) dbd->dbd_NumLines, (LONG) errnum, (LONG) warnMsgs[(errnum - 100)]);
	}
    }

    return (retval);
}

/*****************************************************************************/

static BOOL dbd_initDB (struct AGLib * ag, Class * cl, Object * o, struct opSet * msg)
{
    ULONG (*ASM he) (REG (a0) struct Hook * h, REG (a2) VOID * obj, REG (a1) VOID * msg);
    struct DatabaseData *dbd = INST_DATA (cl, o);	/* Object data */
    struct NodeData *nd = NULL;	/* Current Node */
    BOOL amigaguide = FALSE;
    struct ClientData *cd;
    struct HostHandle *hh;
    struct opFindHost ofh;	/* Used to find the Main node */
    struct DataType *dtn;
    BOOL success = FALSE;	/* Able to initialize? */
    struct TextAttr *ta;
    BOOL going = TRUE;		/* Keep processing file? */
    LONG cof, offset;
    ULONG tbufsize;		/* Size of temporary buffer */
    LONG lineofs;		/* Offset of last line */
    STRPTR tbuf;		/* Temporary buffer */
    STRPTR name;		/* Name of the database */
    LONG dblen;			/* Length of entire database */
    ULONG text;
    LONG ofs;			/* Current offset in file */
    LONG len;			/* Length of Read() */
    UBYTE ch;
    LONG i;			/* Counter */
    LONG j;

    ULONG errLevel = RETURN_WARN;
    ULONG errNumber;
    STRPTR errString;

    STRPTR title;
    Object *no;

    /*********************/
    /* Initialize Layout */
    /*********************/

    /* Initialize the default layout information */
    NewList ((struct List *) &dbd->dbd_MacroList);
    dbd->dbd_MinWidth = 15;
    dbd->dbd_DefTabs = 8;
    for (i = j = 0; i < MAX_TABS; i++, j += dbd->dbd_DefTabs)
	dbd->dbd_Tabs[i] = j;

    /* Initialize the default monospace font */
    ta = &dbd->dbd_TAttr[0];
    {
#undef	GfxBase
#include <graphics/gfxbase.h>
	struct GfxBase *gfxbase = (struct GfxBase *) ag->ag_GfxBase;

	ta->ta_Name = gfxbase->DefaultFont->tf_Message.mn_Node.ln_Name;
	ta->ta_YSize = gfxbase->DefaultFont->tf_YSize;
	ta->ta_Style = gfxbase->DefaultFont->tf_Style;
	ta->ta_Flags = gfxbase->DefaultFont->tf_Flags;
#define	GfxBase	ag->ag_GfxBase
	dbd->dbd_Fonts[0] = OpenFont (ta);
	dbd->dbd_Font = OpenFont (ta);
    }

    /***************************/
    /* Continue Initialization */
    /***************************/

    /* Initialize the semaphore */
    InitSemaphore (&dbd->dbd_Lock);

    /* Initialize the node list */
    NewList ((struct List *) &dbd->dbd_NodeList);
    NewList ((struct List *) &dbd->dbd_XRefList);

    /* See if they want debugging information */
    if (GetVar ("AmigaGuide/Debug", dbd->dbd_ErrorName, sizeof (dbd->dbd_ErrorName), NULL) > 0)
    {
	if (Stricmp (dbd->dbd_ErrorName, "OFF") != 0)
	    dbd->dbd_Flags |= DBDF_DEBUG;
    }

    /* Get the name of the database */
    errString = name = (STRPTR) GetTagData (DBA_Name, NULL, ((struct opSet *) msg)->ops_AttrList);
    hh = (struct HostHandle *) GetTagData (DBA_HostHandle, NULL, ((struct opSet *) msg)->ops_AttrList);
    cd = (struct ClientData *) GetTagData (DBA_ClientData, NULL, ((struct opSet *) msg)->ops_AttrList);

    /* We are coming from a file */
    if (hh == NULL)
    {
	/* Get a lock on the file */
	if (dbd->dbd_FileLock = LVOLockE (ag, NULL, name, ACCESS_READ))
	{
	    if (NameFromLock (dbd->dbd_FileLock, dbd->dbd_FullName, sizeof (dbd->dbd_FullName)))
		name = dbd->dbd_FullName;

	    /* Sniff the file */
	    if (dtn = ObtainDataTypeA (DTST_FILE, (APTR) dbd->dbd_FileLock, NULL))
	    {
		/* Is it an AmigaGuide document? */
		if (Stricmp (dtn->dtn_Header->dth_BaseName, "amigaguide") == 0)
		    amigaguide = TRUE;

		/* Release the datatype */
		ReleaseDataType (dtn);
	    }
	}
    }

    /* Set the attributes */
    dbd_setAttrs (ag, cl, o, msg);

    /* We are coming from a HyperHost */
    if (hh)
    {
	struct TagItem tags[2];

	/* Initialize the tag list */
	tags[0].ti_Tag = AGA_HelpGroup;
	tags[0].ti_Data = (cd) ? cd->cd_HelpGroup : 0L;
	tags[1].ti_Tag = TAG_DONE;

	/* Try creating the main node for this database */
	memset (&ofh, 0, sizeof (struct opFindHost));

	ofh.MethodID = HM_FINDNODE;
	ofh.ofh_Attrs = tags;
	ofh.ofh_Node = MAIN_NODE;
	ofh.ofh_Title = MAIN_NODE;

	/* Show that the database is an AmigaGuide database */
	dbd->dbd_Flags |= DBDF_NODEHOST;

	/* Remember the host handle */
	dbd->dbd_HH = hh;

	/* Get a pointer to the entry point */
	he = hh->hh_Dispatcher.h_Entry;

	/* Try creating the main node for the node host */
	if ((*he) (hh, name, &ofh))
	{
	    /* Create the node object. */
	    if (dbd->dbd_CurrentNode = NewObject (ag->ag_NodeClass, NULL,
						  HNA_Name, (ULONG) ofh.ofh_Node,
						  HNA_Title, (ULONG) ofh.ofh_Title,
						  HNA_TOC, (ULONG) ofh.ofh_TOC,
						  HNA_Next, (ULONG) ofh.ofh_Next,
						  HNA_Previous, (ULONG) ofh.ofh_Prev,
						  HNA_Database, o,
						  HNA_HostHandle, hh,
						  TAG_DONE))
	    {
		/* Indicate success */
		success = TRUE;
	    }
	}
    }
    else if (amigaguide)
    {
	/* Show that the database is an AmigaGuide database */
	dbd->dbd_Flags |= DBDF_AMIGAGUIDE;

	/* Open the file */
	if (dbd->dbd_FileHandle = LVOOpenE (ag, NULL, name, MODE_OLDFILE))
	{
	    if (Seek (dbd->dbd_FileHandle, 0L, OFFSET_END) >= 0L)
	    {
		if ((dblen = Seek (dbd->dbd_FileHandle, 0L, OFFSET_BEGINNING)) > 0L)
		{
		    tbufsize = MIN (10240, dblen);
		    if (tbuf = AllocVec (tbufsize + 1, MEMF_CLEAR))
		    {
			/* Initialize the working variables */
			dbd->dbd_NumLines = dbd->dbd_NumNodes = 0;
			success = TRUE;
			ofs = 0;

			/* Read from the file into our working buffer */
			while (going && ((len = Read (dbd->dbd_FileHandle, tbuf, tbufsize)) > 0L))
			{
			    for (i = j = lineofs = 0; going && (i < len); i++)
			    {
				if ((tbuf[i] == 10) || (tbuf[i] == 0))
				{
				    j++;
				    dbd->dbd_NumLines++;
				    dbd->dbd_Offset = ofs + lineofs;

				    ch = tbuf[i];
				    tbuf[i] = 0;

				    text = TRUE;
				    if (tbuf[lineofs] == '@@')
				    {
					/* Command line */
					going = dbd_parseCommand (ag, o, dbd, (tbuf + lineofs), &text);
					nd = INST_DATA (ag->ag_NodeClass, dbd->dbd_CurrentNode);
				    }

				    if (text)
				    {
					/* Text line */
					if (nd)
					{
					    if (nd->nd_Offset == (-1))
						nd->nd_Offset = dbd->dbd_Offset;
					    nd->nd_TotVert++;
					}
				    }

				    lineofs = i + 1;
				    tbuf[i] = ch;
				}
			    }

			    /* Seek to the correct position within the file */
			    ofs += lineofs;
			    cof = Seek (dbd->dbd_FileHandle, 0, OFFSET_CURRENT);
			    if (offset = ofs - cof)
				Seek (dbd->dbd_FileHandle, offset, OFFSET_CURRENT);

			    /* See if the line was too long */
			    if (j == 0)
			    {
				dbd->dbd_Errors++;
				dbd_debugPrintf (ag, dbd, "%s, Line %ld, Error 4: %s\n",
					     (LONG) dbd->dbd_Name, (LONG) dbd->dbd_NumLines, (LONG) errMsgs[3]);
				success = going = FALSE;
			    }

			    /* If the length read is not equal to the buffer size, then we
			     * must be done reading */
			    if (len != tbufsize)
				going = FALSE;
			}

			if (len < 0)
			    success = FALSE;

			if (dbd->dbd_NumNodes == 0)
			{
			    dbd_debugPrintf (ag, dbd, "%s, Line %ld, Error 5: %s\n",
					     (LONG) dbd->dbd_Name, (LONG) dbd->dbd_NumLines, (LONG) errMsgs[4]);
			    SetIoErr (DTERROR_NOT_ENOUGH_DATA);
			    dbd->dbd_Errors++;
			    success = FALSE;
			}
			else if (dbd->dbd_NumEndNodes < dbd->dbd_NumNodes)
			{
			    dbd_debugPrintf (ag, dbd, "%s, Line %ld, Error 6: %s\n",
					     (LONG) dbd->dbd_Name, (LONG) dbd->dbd_NumLines, (LONG) errMsgs[5]);
			    SetIoErr (DTERROR_NOT_ENOUGH_DATA);
			    dbd->dbd_Errors++;
			    success = FALSE;
			}

			if (success)
			{
			    errLevel = RETURN_OK;
			}

			FreeVec (tbuf);
		    }
		}
	    }
	}
    }
    else if (going)
    {
	/* It wasn't an AmigaGuide database.  So create a database with a main node that is the new object. */

	/* Create the object. When we enter the object we will do AddDTObject() and RefreshDTObject().
	 * When we exit the object, we will do RemoveDTObject(). */
	if (no = newdtobject (ag, name,
			      DTA_SourceType, DTST_FILE,
			      GA_Immediate, TRUE,
			      GA_RelVerify, TRUE,
			      TAG_DONE))
	{
	    /* Get the object name */
	    GetAttr (DTA_ObjName, no, (ULONG *) & title);

	    /* Create the node object. */
	    if (dbd->dbd_CurrentNode = NewObject (ag->ag_NodeClass, NULL,
						  HNA_Name, (ULONG) "Main",
						  HNA_Title, (ULONG) ((title) ? title : name),
						  HNA_Database, o,
						  HNA_Object, no,
						  TAG_DONE))
	    {
		success = TRUE;
	    }
	    else
	    {
		DisposeDTObject (no);
	    }
	}
    }

    errNumber = IoErr ();

    if (success)
    {
	/* Execute the open database command */
	if (dbd->dbd_OnOpen)
	{
	    sprintf (dbd->dbd_ErrorLine, "%s %s", dbd->dbd_OnOpen, dbd->dbd_FullName);
	    if ((i = m_sendCmd (ag, dbd->dbd_ErrorLine)) > 0)
	    {
		errNumber = DTERROR_COULDNT_OPEN;
		errLevel = i;
		success = FALSE;
		SetIoErr (errNumber);
	    }
	}
    }

    if (success)
    {
	/* Increment the use count */
	dbd->dbd_UseCnt++;

	/* Add the database to the list */
	ObtainSemaphore (&ag->ag_Lock);
	DoMethod (o, OM_ADDTAIL, &ag->ag_DatabaseList);
	ReleaseSemaphore (&ag->ag_Lock);
    }
    else if (cd)
    {
	cd->cd_ErrorLevel = errLevel;

	switch (cd->cd_ErrorNumber = errNumber)
	{
	    case ERROR_INVALID_RESIDENT_LIBRARY:
		cd->cd_ErrorNumber = DTERROR_UNKNOWN_DATATYPE;
		break;

	    case ERROR_OBJECT_NOT_FOUND:
		cd->cd_ErrorNumber = DTERROR_COULDNT_OPEN;
		break;
	}
	cd->cd_ErrorString = (ULONG) errString;
    }

    /* Close the debugging window (doesn't really because of WAIT) */
    dbd_closeDebug (ag, dbd, 1);

    return (success);
}

/*****************************************************************************/

static Object *dbd_findDatabase (struct AGLib *ag, STRPTR name, struct HostHandle *hh)
{
    struct DatabaseData *dbd;
    Object *retval = NULL;
    BPTR lock = NULL;
    Object *member;
    Object *ostate;
    BOOL comp;

    comp = TRUE;
    if (hh == NULL)
    {
	if ((lock = LVOLockE (ag, NULL, name, ACCESS_READ)) == NULL)
	{
	    if (IoErr () != ERROR_OBJECT_NOT_FOUND)
		return NULL;
	    comp = FALSE;
	}
    }

    SetIoErr (ERROR_OBJECT_NOT_FOUND);

    if (comp)
    {
	/* Lock the database list */
	ObtainSemaphore (&ag->ag_Lock);

	/* Search through the database list for a matching database */
	ostate = (Object *) ag->ag_DatabaseList.mlh_Head;
	while (member = NextObject (&ostate))
	{
	    /* Convert the member to a database object */
	    dbd = INST_DATA (ag->ag_DatabaseClass, member);

	    /* See if it matches */
	    if ((Stricmp (dbd->dbd_Name, name) == 0) && (SameLock (lock, dbd->dbd_FileLock) == LOCK_SAME))
	    {
		retval = member;
		SetIoErr (0);
		break;
	    }
	}

	/* Release the database lock */
	ReleaseSemaphore (&ag->ag_Lock);
    }

    /* Release the temporary lock */
    UnLock (lock);

    return (retval);
}

/*****************************************************************************/

static ULONG ASM dbd_dispatch (REG (a0) Class * cl, REG (a2) Object * o, REG (a1) Msg msg)
{
    struct AGLib *ag = (struct AGLib *) cl->cl_UserData;
    struct DatabaseData *dbd = INST_DATA (cl, o);
    struct HostHandle *hh;
    ULONG retval = 0L;
    Object *newobj;
    Object *member;
    STRPTR name;
    ULONG err;

    switch (msg->MethodID)
    {
	    /* Create a new database object */
	case OM_NEW:
	    /* Find the name */
	    name = (STRPTR) GetTagData (DBA_Name, NULL, ((struct opSet *) msg)->ops_AttrList);
	    hh = (struct HostHandle *) GetTagData (DBA_HostHandle, NULL, ((struct opSet *) msg)->ops_AttrList);

	    /* See if the database already exists */
	    if (newobj = dbd_findDatabase (ag, name, hh))
	    {
		/* Get a pointer to the instance data */
		dbd = INST_DATA (cl, newobj);

		/* Bump the use count */
		ObtainSemaphore (&dbd->dbd_Lock);
		dbd->dbd_UseCnt++;
		ReleaseSemaphore (&dbd->dbd_Lock);
	    }
	    /* It didn't exist, so try creating it */
	    else if (IoErr () == ERROR_OBJECT_NOT_FOUND)
	    {
		if (newobj = (Object *) DoSuperMethodA (cl, o, msg))
		{
		    if (!(dbd_initDB (ag, cl, newobj, (struct opSet *) msg)))
		    {
			CoerceMethod (cl, newobj, OM_DISPOSE);
			newobj = NULL;
		    }
		}
	    }
	    else
	    {
		CoerceMethod (cl, newobj, OM_DISPOSE);
		newobj = NULL;
	    }

	    retval = (ULONG) newobj;
	    break;

	    /* Add a node object to the database's node list */
	case OM_ADDMEMBER:
	    member = ((struct opAddMember *) msg)->opam_Object;
	    DoMethod (member, OM_ADDTAIL, &dbd->dbd_NodeList);
	    break;

	    /* Remove a node object from the database's node list */
	case OM_REMMEMBER:
	    member = ((struct opAddMember *) msg)->opam_Object;
	    retval = (ULONG) DoMethod (member, OM_REMOVE);
	    break;

	    /* Set database attributes */
	case OM_SET:
	    retval = dbd_setAttrs (ag, cl, o, (struct opSet *) msg);
	    break;

	case OM_DISPOSE:
	    err = IoErr();

	    /* Any users? */
	    if (dbd->dbd_UseCnt == 0)
	    {
		/* Lock the database */
		ObtainSemaphore (&dbd->dbd_Lock);

		retval = dbd_disposeDatabase (ag, cl, o, msg, dbd);
	    }
	    else
	    {
		/* Lock the database */
		ObtainSemaphore (&dbd->dbd_Lock);

		/* Decrement the use count */
		dbd->dbd_UseCnt--;

		/* Any users? */
		if (dbd->dbd_UseCnt == 0)
		{
		    /* Remove the object from the database list */
		    ObtainSemaphore (&ag->ag_Lock);
		    DoMethod (o, OM_REMOVE);
		    ReleaseSemaphore (&ag->ag_Lock);

		    retval = dbd_disposeDatabase (ag, cl, o, msg, dbd);
		}
		else
		{
		    /* Release the lock */
		    ReleaseSemaphore (&dbd->dbd_Lock);
		}
	    }
	    SetIoErr (err);
	    break;

#if 0
	    /* Get database attributes */
	case OM_GET:
#endif
	    /* Let the superclass handle everything else */
	default:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    break;
    }

    return (retval);
}

/*****************************************************************************/

Class *initDBClass (struct AGLib * ag)
{
    Class *cl;

    if (cl = MakeClass (NULL, ROOTCLASS, NULL, sizeof (struct DatabaseData), 0L))
    {
	cl->cl_Dispatcher.h_Entry = (ULONG (*)()) dbd_dispatch;
	cl->cl_UserData = (ULONG) ag;
    }

    return (cl);
}
@


39.16
log
@suppress multiple requesters
@
text
@d9 5
a13 2
//#define PROF
#include <internal/prof.h>
d15 3
d41 4
d46 15
a60 3
    DBDK_COPYRIGHT,
    DBDK_AUTHOR,
    DBDK_DATABASE,
a65 3
    DBDK_HELP,
    DBDK_INDEX,
    DBDK_KEYWORDS,
a67 1
    DBDK_NEXT,
a68 3
    DBDK_ONCLOSE,
    DBDK_ONOPEN,
    DBDK_PREVIOUS,
a72 2
    DBDK_TITLE,
    DBDK_TOC,
a74 1
    DBDK_XREF
d241 5
d260 1
d268 1
a268 1
	if (strncmp (argv[0], "@@{", 2) == 0)
d286 1
a286 1
	    switch (m_binSearch (&argv[0][1], strlen (&argv[0][1]), dbd_Keywords, DBDK_TOTAL_KEYWORDS))
d288 7
d296 4
a299 3
		case DBDK_HEIGHT:
		case DBDK_REMARK:
		case DBDK_WIDTH:
d302 6
a307 1
		case DBDK_COPYRIGHT:
d309 1
a309 1
			setattrs (ag, o, DTA_ObjCopyright, argv[1], TAG_DONE);
d314 12
a325 3
		case DBDK_AUTHOR:
		    if (argc > 1)
			setattrs (ag, o, DTA_ObjAuthor, argv[1], TAG_DONE);
d330 5
a334 1
		case DBDK_DATABASE:
d336 6
a341 1
			setattrs (ag, o, DTA_ObjName, argv[1], TAG_DONE);
d346 22
a367 2
		case DBDK_DNODE:
		    retval = FALSE;
d370 3
a385 14
		case DBDK_EMBED:
#if 0
		    if (dbd->dbd_CurrentNode && (argc > 1))
			setattrs (ag, dbd->dbd_CurrentNode,
				  HNA_EmbedName, argv[1],
				  HNA_EmbedLine, dbd->dbd_Offset - nd->nd_Offset,
				  TAG_DONE);
		    else if (!dbd->dbd_CurrentNode)
			errnum = 3;
		    else
			errnum = 1;
#endif
		    break;

a422 23
		case DBDK_HELP:
		    if (argc > 1)
			setattrs (ag, o, DBA_Help, argv[1], TAG_DONE);
		    else
			errnum = 1;
		    break;

		case DBDK_INDEX:
		    if (argc > 1)
			setattrs (ag, o, DBA_Index, argv[1], TAG_DONE);
		    else
			errnum = 1;
		    break;

		case DBDK_KEYWORDS:
		    if (dbd->dbd_CurrentNode && (argc > 1))
			setattrs (ag, dbd->dbd_CurrentNode, HNA_Keywords, argv[1], TAG_DONE);
		    else if (!dbd->dbd_CurrentNode)
			errnum = 3;
		    else
			errnum = 1;
		    break;

a504 9
		case DBDK_NEXT:
		    if (dbd->dbd_CurrentNode && (argc > 1))
			setattrs (ag, dbd->dbd_CurrentNode, HNA_Next, argv[1], TAG_DONE);
		    else if (!dbd->dbd_CurrentNode)
			errnum = 3;
		    else
			errnum = 1;
		    break;

d519 5
a523 5
			if (dbd->dbd_CurrentNode = newobject (ag, ag->ag_NodeClass, NULL,
								HNA_Name, name,
								HNA_Title, title,
								HNA_Database, o,
								HNA_FileHandle, dbd->dbd_FileHandle,
a532 47
		case DBDK_ONCLOSE:
		    if (argc > 1)
		    {
			if (dbd->dbd_CurrentNode)
			    setattrs (ag, dbd->dbd_CurrentNode, HNA_OnClose, argv[1], TAG_DONE);
			else
			    setattrs (ag, o, DBA_OnClose, argv[1], TAG_DONE);
		    }
		    else
			errnum = 1;
		    break;

		case DBDK_ONOPEN:
		    if (argc > 1)
		    {
			if (dbd->dbd_CurrentNode)
			    setattrs (ag, dbd->dbd_CurrentNode, HNA_OnOpen, argv[1], TAG_DONE);
			else
			    setattrs (ag, o, DBA_OnOpen, argv[1], TAG_DONE);
		    }
		    else
			errnum = 1;
		    break;

		case DBDK_PREVIOUS:
		    if (dbd->dbd_CurrentNode && (argc > 1))
			setattrs (ag, dbd->dbd_CurrentNode, HNA_Previous, argv[1], TAG_DONE);
		    else if (!dbd->dbd_CurrentNode)
			errnum = 3;
		    else
			errnum = 1;
		    break;

		case DBDK_PROPORTIONAL:
		    if (dbd->dbd_CurrentNode)
			nd->nd_Flags |= HNF_PROPORTIONAL;
		    else
			dbd->dbd_Flags |= DBDF_PROPORTIONAL;
		    break;

		case DBDK_SMARTWRAP:
		    if (dbd->dbd_CurrentNode)
			nd->nd_Flags |= HNF_SMARTWRAP;
		    else
			dbd->dbd_Flags |= DBDF_SMARTWRAP;
		    break;

d556 5
a560 1
		case DBDK_TITLE:
d562 4
a565 1
			setattrs (ag, dbd->dbd_CurrentNode, HNA_Title, argv[1], TAG_DONE);
d571 4
a574 8

		case DBDK_TOC:
		    if (dbd->dbd_CurrentNode && (argc > 1))
			setattrs (ag, dbd->dbd_CurrentNode, HNA_TOC, argv[1], TAG_DONE);
		    else if (!dbd->dbd_CurrentNode)
			errnum = 3;
		    else
			errnum = 1;
d577 5
a581 12
		case DBDK_WORDWRAP:
		    if (dbd->dbd_CurrentNode)
			nd->nd_Flags |= HNF_WRAP;
		    else
			dbd->dbd_Flags |= DBDF_WRAP;
		    break;

		case DBDK_XREF:
		    if (argc > 1)
			setattrs (ag, o, DBA_XRef, argv[1], TAG_DONE);
		    else
			errnum = 1;
a644 4
    /* ALL CODE STARTS HERE */

    ONTIMER(2);

d751 1
a751 1
	    if (dbd->dbd_CurrentNode = newobject (ag, ag->ag_NodeClass, NULL,
a780 2
			ONTIMER(3);

a788 1
			    ONTIMER(4);
a803 1
					ONTIMER(5);
a804 1
					OFFTIMER(5);
a822 1
			    OFFTIMER(4);
a823 6
			    ONTIMER(6);
#if 0
			    /* Start at the beginning of a line */
			    ofs += lineofs;
			    Seek (dbd->dbd_FileHandle, ofs, OFFSET_BEGINNING);
#else
a828 1
#endif
a842 1
			    OFFTIMER(6);
a869 2
			OFFTIMER (3);

d892 1
a892 1
	    if (dbd->dbd_CurrentNode = newobject (ag, ag->ag_NodeClass, NULL,
a955 2
    OFFTIMER(2);

a1026 2
    ONTIMER(1);

d1122 1
d1125 1
a1125 1

a1130 2

    OFFTIMER(1);
@


39.15
log
@changed minimum width from 10 to 15
@
text
@d8 4
d20 2
a30 1

d304 1
a479 1
#if NO_ENDNODE
d483 1
a483 4
			if (nd->nd_Offset == (-1))
			    nd->nd_Offset = dbd->dbd_Offset;
			nd->nd_BufferLen = dbd->dbd_Offset - nd->nd_Offset;
			dbd->dbd_CurrentNode = NULL;
a484 2
#endif

d486 1
a486 1
		    if (argc > 1)
d493 1
a493 1
			if (!(dbd->dbd_CurrentNode = newobject (ag, ag->ag_NodeClass, NULL,
d498 3
a500 1
								TAG_DONE)))
d650 1
d670 4
d810 2
d820 1
d836 1
d838 1
d857 1
d859 2
d864 7
d876 2
a877 3
				dbd_debugPrintf (ag, dbd, "%s, Line %ld, Error %ld: %s\n",
					     (LONG) dbd->dbd_Name, (LONG) dbd->dbd_NumLines,
					     (LONG) 4, (LONG) errMsgs[(4 - 1)]);
d885 1
d890 17
a906 2
			else
			    errLevel = RETURN_OK;
a907 1
#if NO_ENDNODE
d910 1
a910 8
			    /* End any node */
			    if (dbd->dbd_CurrentNode)
			    {
				if (nd->nd_Offset == (-1))
				    nd->nd_Offset = dbd->dbd_Offset;
				nd->nd_BufferLen = dbd->dbd_Offset - nd->nd_Offset;
				dbd->dbd_CurrentNode = NULL;
			    }
d912 2
a913 1
#endif
d921 1
a921 1
    else
d1001 2
d1018 11
a1028 2
    if ((hh == NULL) && !(lock = LVOLockE (ag, NULL, name, ACCESS_READ)))
	comp = FALSE;
d1046 1
d1074 2
d1096 1
a1096 1
	    else if (newobj = (Object *) DoSuperMethodA (cl, o, msg))
d1098 1
a1098 1
		if (!(dbd_initDB (ag, cl, newobj, (struct opSet *) msg)))
d1100 5
a1104 2
		    CoerceMethod (cl, newobj, OM_DISPOSE);
		    newobj = NULL;
d1107 6
d1179 2
@


39.14
log
@alphabetized the switch statement
@
text
@d474 11
d870 14
@


39.13
log
@clean up
@
text
@d265 7
a271 1
		case DBDK_DATABASE:
d273 1
a273 1
			setattrs (ag, o, DTA_ObjName, argv[1], TAG_DONE);
d285 75
a359 1
		case DBDK_XREF:
d361 1
a361 1
			setattrs (ag, o, DBA_XRef, argv[1], TAG_DONE);
d366 1
a366 1
		case DBDK_COPYRIGHT:
d368 10
a377 1
			setattrs (ag, o, DTA_ObjCopyright, argv[1], TAG_DONE);
d464 5
a468 47
		case DBDK_FONT:
		    if (argc > 2)
		    {
			ULONG *font, size = 0;
			struct TextAttr *ta;
			STRPTR name;

			if (dbd->dbd_CurrentNode)
			{
			    font = (ULONG *) & nd->nd_Font;
			    name = nd->nd_FontName;
			    ta = &nd->nd_TextAttr;
			}
			else
			{
			    font = (ULONG *) & dbd->dbd_Font;
			    name = dbd->dbd_FontName;
			    ta = &dbd->dbd_TextAttr;
			}

			strncpy (name, argv[1], 32);
			StrToLong (argv[2], (LONG *) & size);

			ta->ta_Name = name;
			ta->ta_YSize = (UWORD) size;
			ta->ta_Style = NULL;
			ta->ta_Flags = NULL;

			if (*font)
			    CloseFont ((struct TextFont *) *font);
			if (!(*font = (ULONG) OpenDiskFont (ta)))
			    *font = (ULONG) OpenFont (ta);
		    }
		    else
			errnum = 1;
		    break;

		case DBDK_INDEX:
		    if (argc > 1)
			setattrs (ag, o, DBA_Index, argv[1], TAG_DONE);
		    else
			errnum = 1;
		    break;

		case DBDK_HELP:
		    if (argc > 1)
			setattrs (ag, o, DBA_Help, argv[1], TAG_DONE);
d494 8
a501 30
		case DBDK_DNODE:
		    retval = FALSE;
		    break;

		case DBDK_WORDWRAP:
		    if (dbd->dbd_CurrentNode)
			nd->nd_Flags |= HNF_WRAP;
		    else
			dbd->dbd_Flags |= DBDF_WRAP;
		    break;

		case DBDK_SMARTWRAP:
		    if (dbd->dbd_CurrentNode)
			nd->nd_Flags |= HNF_SMARTWRAP;
		    else
			dbd->dbd_Flags |= DBDF_SMARTWRAP;
		    break;

		case DBDK_PROPORTIONAL:
		    if (dbd->dbd_CurrentNode)
			nd->nd_Flags |= HNF_PROPORTIONAL;
		    else
			dbd->dbd_Flags |= DBDF_PROPORTIONAL;
		    break;

		case DBDK_TITLE:
		    if (dbd->dbd_CurrentNode && (argc > 1))
			setattrs (ag, dbd->dbd_CurrentNode, HNA_Title, argv[1], TAG_DONE);
		    else if (!dbd->dbd_CurrentNode)
			errnum = 3;
d506 8
a513 5
		case DBDK_TOC:
		    if (dbd->dbd_CurrentNode && (argc > 1))
			setattrs (ag, dbd->dbd_CurrentNode, HNA_TOC, argv[1], TAG_DONE);
		    else if (!dbd->dbd_CurrentNode)
			errnum = 3;
d527 3
a529 5
		case DBDK_NEXT:
		    if (dbd->dbd_CurrentNode && (argc > 1))
			setattrs (ag, dbd->dbd_CurrentNode, HNA_Next, argv[1], TAG_DONE);
		    else if (!dbd->dbd_CurrentNode)
			errnum = 3;
d531 1
a531 1
			errnum = 1;
d534 3
a536 5
		case DBDK_KEYWORDS:
		    if (dbd->dbd_CurrentNode && (argc > 1))
			setattrs (ag, dbd->dbd_CurrentNode, HNA_Keywords, argv[1], TAG_DONE);
		    else if (!dbd->dbd_CurrentNode)
			errnum = 3;
d538 1
a538 1
			errnum = 1;
d541 1
a541 1
		case DBDK_ONOPEN:
d544 3
d548 5
a552 1
			    setattrs (ag, dbd->dbd_CurrentNode, HNA_OnOpen, argv[1], TAG_DONE);
d554 5
a558 1
			    setattrs (ag, o, DBA_OnOpen, argv[1], TAG_DONE);
d564 5
a568 8
		case DBDK_ONCLOSE:
		    if (argc > 1)
		    {
			if (dbd->dbd_CurrentNode)
			    setattrs (ag, dbd->dbd_CurrentNode, HNA_OnClose, argv[1], TAG_DONE);
			else
			    setattrs (ag, o, DBA_OnClose, argv[1], TAG_DONE);
		    }
d573 1
a573 2
		case DBDK_EMBED:
#if 0
d575 1
a575 4
			setattrs (ag, dbd->dbd_CurrentNode,
				  HNA_EmbedName, argv[1],
				  HNA_EmbedLine, dbd->dbd_Offset - nd->nd_Offset,
				  TAG_DONE);
a579 1
#endif
d582 1
a582 1
		case DBDK_ENDNODE:
d584 1
a584 5
		    {
			if (nd->nd_Offset == (-1))
			    nd->nd_Offset = dbd->dbd_Offset;
			nd->nd_BufferLen = dbd->dbd_Offset - nd->nd_Offset;
		    }
d586 1
a586 2
			errnum = 3;
		    dbd->dbd_CurrentNode = NULL;
d589 1
a589 1
		case DBDK_TAB:
d591 1
a591 17
		    {
			ULONG i, j;

			StrToLong (argv[1], (LONG *) &i);
			if (dbd->dbd_CurrentNode)
			{
			    nd->nd_DefTabs = i;
			    for (i = j = 0; i < MAX_TABS; i++, j += nd->nd_DefTabs)
				nd->nd_Tabs[i] = j;
			}
			else
			{
			    dbd->dbd_DefTabs = i;
			    for (i = j = 0; i < MAX_TABS; i++, j += dbd->dbd_DefTabs)
				dbd->dbd_Tabs[i] = j;
			}
		    }
d662 1
a662 1
    dbd->dbd_MinWidth = 10;
@


39.12
log
@now looks at nodehost to determine sameness
@
text
@a7 1

d25 72
d99 1
a99 1
static LONG DebugPrintf (struct AGLib *ag, struct DatabaseData *dbd, STRPTR fmt, LONG argv, ...)
d105 2
a106 2
        if (dbd->dbd_ErrorFH == NULL)
        {
d109 2
a110 2
            dbd->dbd_ErrorFH = Open (dbd->dbd_ErrorName, MODE_NEWFILE);
        }
d112 2
a113 2
        if (dbd->dbd_ErrorFH)
            retval = VFPrintf (dbd->dbd_ErrorFH, fmt, (LONG *)&argv);
d121 1
a121 1
static void CloseDebug (struct AGLib *ag, struct DatabaseData *dbd, LONG mode)
d127 2
a128 2
	    DebugPrintf (ag, dbd, "\n%s: %ld Errors, %ld Warnings\n",
			 (LONG)dbd->dbd_Name, (LONG)dbd->dbd_Errors, (LONG)dbd->dbd_Warnings);
d137 1
a137 1
static Object *FindDataBase (struct AGLib * ag, STRPTR name, struct HostHandle *hh)
d139 2
a140 3
    struct DatabaseData *dbd;
    Object *retval = NULL;
    BPTR lock = NULL;
d142 1
a142 33
    Object *ostate;
    BOOL comp;

    comp = TRUE;
    if ((hh == NULL) && !(lock = LVOLockE (ag, NULL, name, ACCESS_READ)))
	comp = FALSE;

    if (comp)
    {
	/* Lock the database list */
	ObtainSemaphore (&ag->ag_Lock);

	/* Search through the database list for a matching database */
	ostate = (Object *) ag->ag_DatabaseList.lh_Head;
	while (member = NextObject (&ostate))
	{
	    /* Convert the member to a database object */
	    dbd = INST_DATA (ag->ag_DatabaseClass, member);

	    /* See if it matches */
	    if ((Stricmp (dbd->dbd_Name, name) == 0) && (SameLock (lock, dbd->dbd_FileLock) == LOCK_SAME))
	    {
		retval = member;
		break;
	    }
	}

	/* Release the database lock */
	ReleaseSemaphore (&ag->ag_Lock);
    }

    /* Release the temporary lock */
    UnLock (lock);
d144 2
a145 10
    return (retval);
}

/*****************************************************************************/

Class *initDBClass (struct AGLib * ag)
{
    Class *cl;

    if (cl = MakeClass (NULL, ROOTCLASS, NULL, sizeof (struct DatabaseData), 0L))
d147 2
a148 2
	cl->cl_Dispatcher.h_Entry = (ULONG (*)()) DBDispatch;
	cl->cl_UserData = (ULONG) ag;
a150 10
    return (cl);
}

/*****************************************************************************/

static ULONG disposeDatabase (struct AGLib *ag, Class *cl, Object *o, Msg msg, struct DatabaseData *dbd)
{
    Object *ostate;
    Object *member;

d152 1
a152 1
    ostate = (Object *) dbd->dbd_NodeList.lh_Head;
d159 5
a163 1
    /* Close the font */
d166 5
d180 2
a181 3
    FreeVec (dbd->dbd_Name);
    FreeVec (dbd->dbd_Index);
    FreeVec (dbd->dbd_Help);
d191 2
a192 1
ULONG ASM DBDispatch (REG (a0) Class * cl, REG (a2) Object * o, REG (a1) Msg msg)
a193 1
    struct AGLib *ag = (struct AGLib *) cl->cl_UserData;
d195 44
a238 6
    struct HostHandle *hh;
    ULONG retval = 0L;
    Object *newobj;
    Object *member;
    STRPTR name;
    ULONG err;
d240 2
a241 1
    switch (msg->MethodID)
d243 168
a410 5
	/* Create a new database object */
	case OM_NEW:
	    /* Find the name */
	    name = (STRPTR) GetTagData (DBA_Name, NULL, ((struct opSet *) msg)->ops_AttrList);
	    hh = (struct HostHandle *) GetTagData (DBA_HostHandle, NULL, ((struct opSet *) msg)->ops_AttrList);
d412 13
a424 5
	    /* See if the database already exists */
	    if (newobj = FindDataBase (ag, name, hh))
	    {
		/* Get a pointer to the instance data */
		dbd = INST_DATA (cl, newobj);
d426 5
a430 16
		/* Bump the use count */
		ObtainSemaphore (&dbd->dbd_Lock);
		dbd->dbd_UseCnt++;
		ReleaseSemaphore (&dbd->dbd_Lock);
	    }
	    /* It didn't exist, so try creating it */
	    else if (newobj = (Object *) DoSuperMethodA (cl, o, msg))
	    {
		if (!(initializeDatabase (ag, cl, newobj, (struct opSet *) msg)))
		{
		    CoerceMethod (cl, newobj, OM_DISPOSE);
		    newobj = NULL;
		}
	    }
	    retval = (ULONG) newobj;
	    break;
d432 2
a433 5
	/* Add a node object to the database's node list */
	case OM_ADDMEMBER:
	    member = ((struct opAddMember *) msg)->opam_Object;
	    DoMethod (member, OM_ADDTAIL, &dbd->dbd_NodeList);
	    break;
d435 11
a445 5
	/* Remove a node object from the database's node list */
	case OM_REMMEMBER:
	    member = ((struct opAddMember *) msg)->opam_Object;
	    retval = (ULONG) DoMethod (member, OM_REMOVE);
	    break;
d447 69
a515 4
	/* Set database attributes */
	case OM_SET:
	    retval = setDBAttrs (ag, cl, o, (struct opSet *) msg);
	    break;
d517 11
a527 3
	case OM_DISPOSE:
	    /* Close the debugging window (doesn't really because of WAIT) */
//	    CloseDebug (ag, dbd, 0);
d529 11
a539 1
	    err = IoErr();
d541 13
a553 5
	    /* Any users? */
	    if (dbd->dbd_UseCnt == 0)
	    {
		/* Lock the database */
		ObtainSemaphore (&dbd->dbd_Lock);
d555 11
a565 6
		retval = disposeDatabase (ag, cl, o, msg, dbd);
	    }
	    else
	    {
		/* Lock the database */
		ObtainSemaphore (&dbd->dbd_Lock);
d567 4
a570 2
		/* Decrement the use count */
		dbd->dbd_UseCnt--;
d572 17
a588 7
		/* Any users? */
		if (dbd->dbd_UseCnt == 0)
		{
		    /* Remove the object from the database list */
		    ObtainSemaphore (&ag->ag_Lock);
		    DoMethod (o, OM_REMOVE);
		    ReleaseSemaphore (&ag->ag_Lock);
d590 3
a592 7
		    retval = disposeDatabase (ag, cl, o, msg, dbd);
		}
		else
		{
		    /* Release the lock */
		    ReleaseSemaphore (&dbd->dbd_Lock);
		}
d594 2
a595 2
	    SetIoErr (err);
	    break;
d597 14
a610 7
	    /* Get database attributes */
	case OM_GET:

	    /* Let the superclass handle everything else */
	default:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    break;
d618 1
a618 1
BOOL initializeDatabase (struct AGLib * ag, Class * cl, Object * o, struct opSet * msg)
d622 1
a622 1
    struct NodeData *nd = NULL;				/* Current Node */
d626 1
a626 1
    struct opFindHost ofh;				/* Used to find the Main node */
d628 8
a635 7
    BOOL success = FALSE;				/* Able to initialize? */
    BOOL going = TRUE;					/* Keep processing file? */
    ULONG tbufsize;					/* Size of temporary buffer */
    LONG lineofs;					/* Offset of last line */
    STRPTR tbuf;					/* Temporary buffer */
    STRPTR name;					/* Name of the database */
    LONG dblen;						/* Length of entire database */
d637 2
a638 2
    LONG ofs;						/* Current offset in file */
    LONG len;						/* Length of Read() */
d640 1
a640 1
    LONG i;						/* Counter */
d643 2
a644 2
    ULONG  errLevel = RETURN_WARN;
    ULONG  errNumber;
d650 31
d685 2
a686 2
    NewList (&dbd->dbd_NodeList);
    NewList (&dbd->dbd_XRefList);
d704 4
a707 4
        if (dbd->dbd_FileLock = LVOLockE (ag, NULL, name, ACCESS_READ))
        {
            if (NameFromLock (dbd->dbd_FileLock, dbd->dbd_FullName, sizeof (dbd->dbd_FullName)))
                name = dbd->dbd_FullName;
d709 10
a718 10
            /* Sniff the file */
            if (dtn = ObtainDataTypeA (DTST_FILE, (APTR) dbd->dbd_FileLock, NULL))
            {
                /* Is it an AmigaGuide document? */
                if (Stricmp (dtn->dtn_Header->dth_BaseName, "amigaguide") == 0)
                    amigaguide = TRUE;

                /* Release the datatype */
                ReleaseDataType (dtn);
            }
d723 1
a723 1
    setDBAttrs (ag, cl, o, msg);
d731 1
a731 1
	tags[0].ti_Tag  = AGA_HelpGroup;
d733 1
a733 1
	tags[1].ti_Tag  = TAG_DONE;
d737 2
a738 1
	ofh.MethodID  = HM_FINDNODE;
d740 1
a740 1
	ofh.ofh_Node  = MAIN_NODE;
d757 7
a763 7
						  HNA_Name,		(ULONG) ofh.ofh_Node,
						  HNA_Title,		(ULONG) ofh.ofh_Title,
						  HNA_TOC,		(ULONG) ofh.ofh_TOC,
						  HNA_Next,		(ULONG) ofh.ofh_Next,
						  HNA_Previous,		(ULONG) ofh.ofh_Prev,
						  HNA_Database, 	o,
						  HNA_HostHandle,	hh,
d809 1
a809 1
					going = ParseCommand (ag, o, dbd, (tbuf + lineofs), &text);
d837 3
a839 3
				DebugPrintf (ag, dbd, "%s, Line %ld, Error %ld: %s\n",
					     (LONG)dbd->dbd_Name, (LONG)dbd->dbd_NumLines,
					     (LONG)4, (LONG)errMsgs[(4-1)]);
a849 1
			{
a850 1
			}
a851 1
			{
a852 1
			}
d867 3
a869 3
			      DTA_SourceType,	DTST_FILE,
			      GA_Immediate,	TRUE,
			      GA_RelVerify,	TRUE,
d877 4
a880 4
						  HNA_Name,	(ULONG) "Main",
						  HNA_Title,	(ULONG) ((title) ? title : name),
						  HNA_Database,	o,
						  HNA_Object,	no,
d896 16
d934 1
a934 1
	cd->cd_ErrorString = (ULONG)errString;
d938 1
a938 1
    CloseDebug (ag, dbd, 1);
d945 1
a945 1
BOOL ParseCommand (struct AGLib * ag, Object * o, struct DatabaseData * dbd, STRPTR cmd, ULONG * text)
d947 10
a956 5
    struct NodeData *nd = NULL;
    BOOL retval = FALSE;
    STRPTR argv[MAXARG];
    ULONG errnum = 0;
    ULONG argc;
d958 1
a958 2
    *text = FALSE;
    if ((argc = ParseString (ag, cmd, argv, MAXARG)) > 0)
d960 2
a961 1
	retval = TRUE;
d963 3
a965 1
	if (dbd->dbd_CurrentNode)
d967 9
a975 1
	    nd = INST_DATA (ag->ag_NodeClass, dbd->dbd_CurrentNode);
d978 36
a1013 1
	/* Global */
d1015 7
a1021 17
	if (Stricmp (argv[0], "@@database") == 0)
	{
	    if (argc > 1)
		setattrs (ag, o, DTA_ObjName, argv[1], TAG_DONE);
	    else
		errnum = 1;
	}
	else if (Stricmp (argv[0], "@@author") == 0)
	{
	    if (argc > 1)
		setattrs (ag, o, DTA_ObjAuthor, argv[1], TAG_DONE);
	    else
		errnum = 1;
	}
	else if (Stricmp (argv[0], "@@xref") == 0)
	{
	    if (argc > 1)
d1023 5
a1027 1
		/* Load the xref in argv[1] into the database xref list */
d1029 19
a1047 26
	    else
		errnum = 1;
	}
	else if (Stricmp (argv[0], "@@(c)") == 0)
	{
	    if (argc > 1)
		setattrs (ag, o, DTA_ObjCopyright, argv[1], TAG_DONE);
	    else
		errnum = 1;
	}
	else if (Stricmp (argv[0], "@@$ver:") == 0)
	{
	}
	else if (Stricmp (argv[0], "@@master") == 0)
	{
	    if (argc > 1)
	    {
		struct Process *pr = (struct Process *) FindTask (NULL);
		struct FileInfoBlock *fib;
		struct DateStamp mds;
		APTR oldWP;
		BPTR lock;

		/* Turn off requesters for a moment */
		oldWP = pr->pr_WindowPtr;
		pr->pr_WindowPtr = (APTR)-1;
d1049 2
a1050 11
		/* Try to lock the master file */
		if (lock = Lock (argv[1], ACCESS_READ))
		{
		    /* Get a temporary FIB to work with */
		    if (fib = AllocDosObject (DOS_FIB, NULL))
		    {
			/* Examine the master file */
			if (Examine (lock, fib))
			{
			    /* Copy the date of the master file. */
			    mds = *(&fib->fib_Date);
d1052 5
a1056 17
			    /* Examine the AmigaGuide file */
			    if (Examine (dbd->dbd_FileLock, fib))
			    {
				/* Compare the dates to see if the master has been updated. */
				if (CompareDates (&mds, &fib->fib_Date) < 0)
				{
				    /* Show that the file is stale */
				    dbd->dbd_Flags |= DBDF_STALE;
				}
			    }
			}
			/* Get rid of the temporary FIB */
			FreeDosObject (DOS_FIB, fib);
		    }
		    /* Unlock the master */
		    UnLock (lock);
		}
d1058 1
a1058 2
		/* Restore the window pointer */
		pr->pr_WindowPtr = oldWP;
d1060 1
a1060 16
	}
	else if (Stricmp (argv[0], "@@rem") == 0)
	{
	}
	else if (Stricmp (argv[0], "@@remark") == 0)
	{
	}
	else if (Stricmp (argv[0], "@@width") == 0)
	{
	}
	else if (Stricmp (argv[0], "@@height") == 0)
	{
	}
	else if (Stricmp (argv[0], "@@font") == 0)
	{
	    if (argc > 2)
d1062 5
a1066 3
		ULONG *font, size = 0;
		struct TextAttr *ta;
		STRPTR name;
d1068 2
a1069 1
		if (dbd->dbd_CurrentNode)
d1071 6
a1076 3
		    font = (ULONG *) & nd->nd_Font;
		    name = nd->nd_FontName;
		    ta = &nd->nd_TextAttr;
d1080 2
a1081 3
		    font = (ULONG *) & dbd->dbd_Font;
		    name = dbd->dbd_FontName;
		    ta = &dbd->dbd_TextAttr;
a1082 13

		strncpy (name, argv[1], 32);
		StrToLong (argv[2], (LONG *)&size);

		ta->ta_Name  = name;
		ta->ta_YSize = (UWORD) size;
		ta->ta_Style = NULL;
		ta->ta_Flags = NULL;

		if (*font)
		    CloseFont ((struct TextFont *)*font);
		if (!(*font = (ULONG) OpenDiskFont (ta)))
		    *font = (ULONG) OpenFont (ta);
d1084 2
a1085 63
	    else
		errnum = 1;
	}
	else if (Stricmp (argv[0], "@@index") == 0)
	{
	    if (argc > 1)
		setattrs (ag, o, DBA_Index, argv[1], TAG_DONE);
	    else
		errnum = 1;
	}
	else if (Stricmp (argv[0], "@@help") == 0)
	{
	    if (argc > 1)
		setattrs (ag, o, DBA_Help, argv[1], TAG_DONE);
	    else
		errnum = 1;
	}
	else if (Stricmp (argv[0], "@@xref") == 0)
	{
	    if (argc > 1)
		setattrs (ag, o, DBA_XRef, argv[1], TAG_DONE);
	    else
		errnum = 1;
	}
	else if (Stricmp (argv[0], "@@node") == 0)
	{
	    STRPTR title, name;

	    /* Create a new Node object */
	    if (argc > 1)
	    {
		name  = argv[1];
		title = (argv[2]) ? argv[2] : name;

		if (!(dbd->dbd_CurrentNode = newobject (ag, ag->ag_NodeClass, NULL,
						  HNA_Name,		name,
						  HNA_Title,		title,
						  HNA_Database,		o,
						  HNA_FileHandle,	dbd->dbd_FileHandle,
						  TAG_DONE)))
		    errnum = 2;
	    }
	    else
		errnum = 1;
	}
	else if (Stricmp (argv[0], "@@dnode") == 0)
	{
	    retval = FALSE;
	}
	else if (Stricmp (argv[0], "@@wordwrap") == 0)
	{
	    if (dbd->dbd_CurrentNode)
		nd->nd_Flags |= HNF_WRAP;
	    else
		dbd->dbd_Flags |= DBDF_WRAP;
	}
	else if (Stricmp (argv[0], "@@proportional") == 0)
	{
	    if (dbd->dbd_CurrentNode)
		nd->nd_Flags |= HNF_PROPORTIONAL;
	    else
		dbd->dbd_Flags |= DBDF_PROPORTIONAL;
	}
d1087 2
a1088 1
	/* Node */
d1090 4
a1093 96
	else if (Stricmp (argv[0], "@@title") == 0)
	{
	    if (dbd->dbd_CurrentNode && (argc > 1))
		setattrs (ag, dbd->dbd_CurrentNode, HNA_Title, argv[1], TAG_DONE);
	    else if (!dbd->dbd_CurrentNode)
		errnum = 3;
	    else
		errnum = 1;
	}
	else if (Stricmp (argv[0], "@@toc") == 0)
	{
	    if (dbd->dbd_CurrentNode && (argc > 1))
		setattrs (ag, dbd->dbd_CurrentNode, HNA_TOC, argv[1], TAG_DONE);
	    else if (!dbd->dbd_CurrentNode)
		errnum = 3;
	    else
		errnum = 1;
	}
	else if (Stricmp (argv[0], "@@prev") == 0)
	{
	    if (dbd->dbd_CurrentNode && (argc > 1))
		setattrs (ag, dbd->dbd_CurrentNode, HNA_Previous, argv[1], TAG_DONE);
	    else if (!dbd->dbd_CurrentNode)
		errnum = 3;
	    else
		errnum = 1;
	}
	else if (Stricmp (argv[0], "@@next") == 0)
	{
	    if (dbd->dbd_CurrentNode && (argc > 1))
		setattrs (ag, dbd->dbd_CurrentNode, HNA_Next, argv[1], TAG_DONE);
	    else if (!dbd->dbd_CurrentNode)
		errnum = 3;
	    else
		errnum = 1;
	}
	else if (Stricmp (argv[0], "@@keywords") == 0)
	{
	    if (dbd->dbd_CurrentNode && (argc > 1))
		setattrs (ag, dbd->dbd_CurrentNode, HNA_Keywords, argv[1], TAG_DONE);
	    else if (!dbd->dbd_CurrentNode)
		errnum = 3;
	    else
		errnum = 1;
	}
	else if (Strnicmp (argv[0], "@@{", 2) == 0)
	{
	    if (dbd->dbd_CurrentNode)
		*text = TRUE;
	    else
		errnum = 3;
	}
	else if (Stricmp (argv[0], "@@embed") == 0)
	{
	    if (dbd->dbd_CurrentNode && (argc > 1))
		setattrs (ag, dbd->dbd_CurrentNode,
			  HNA_EmbedName, argv[1],
			  HNA_EmbedLine, dbd->dbd_Offset - nd->nd_Offset,
			  TAG_DONE);
	    else if (!dbd->dbd_CurrentNode)
		errnum = 3;
	    else
		errnum = 1;
	}
	else if (Stricmp (argv[0], "@@endnode") == 0)
	{
	    if (dbd->dbd_CurrentNode)
	    {
		if (nd->nd_Offset == (-1))
		    nd->nd_Offset = dbd->dbd_Offset;
		nd->nd_BufferLen = dbd->dbd_Offset - nd->nd_Offset;
	    }
	    else
		errnum = 3;
	    dbd->dbd_CurrentNode = NULL;
	}
	else
	{
	    errnum = 100;
	}
    }

    if (errnum)
    {
        if (errnum < 100)
        {
            dbd->dbd_Errors++;
            DebugPrintf (ag, dbd, "%s, Line %ld, Error %ld: %s\n",
                      (LONG)dbd->dbd_Name, (LONG)dbd->dbd_NumLines, (LONG)errnum, (LONG)errMsgs[(errnum-1)]);
        }
        else
        {
            dbd->dbd_Warnings++;
            DebugPrintf (ag, dbd, "%s, Line %ld, Warning %ld: %s\n",
                      (LONG)dbd->dbd_Name, (LONG)dbd->dbd_NumLines, (LONG)errnum, (LONG)warnMsgs[(errnum-100)]);
        }
d1101 1
a1101 2
/* Set attributes of an object */
ULONG setDBAttrs (struct AGLib * ag, Class * cl, Object * o, struct opSet * msg)
d1103 1
a1103 6
    struct DatabaseData *dbd = INST_DATA (cl, o);
    struct TagItem *tags = msg->ops_AttrList;
    struct TagItem *tstate;
    struct TagItem *tag;
    ULONG refresh = 0L;
    ULONG tidata;
d1105 1
a1105 3
    /* process rest */
    tstate = tags;
    while (tag = NextTagItem (&tstate))
d1107 2
a1108 28
	tidata = tag->ti_Data;
	switch (tag->ti_Tag)
	{
	    case DBA_Name:
		FreeVec (dbd->dbd_Name);
		dbd->dbd_Name = NULL;
		if (tidata && (dbd->dbd_Name = AllocVec (strlen ((STRPTR) tidata) + 1, MEMF_CLEAR)))
		    strcpy (dbd->dbd_Name, (STRPTR) tidata);
		break;

	    case DBA_Index:
		FreeVec (dbd->dbd_Index);
		dbd->dbd_Index = NULL;
		if (tidata && (dbd->dbd_Index = AllocVec (strlen ((STRPTR) tidata) + 1, MEMF_CLEAR)))
		    strcpy (dbd->dbd_Index, (STRPTR) tidata);
		break;

	    case DBA_Help:
		FreeVec (dbd->dbd_Help);
		dbd->dbd_Help = NULL;
		if (tidata && (dbd->dbd_Help = AllocVec (strlen ((STRPTR) tidata) + 1, MEMF_CLEAR)))
		    strcpy (dbd->dbd_Help, (STRPTR) tidata);
		break;

	    case DBA_FileHandle:
		dbd->dbd_FileHandle = (BPTR) tidata;
		break;
	}
d1111 1
a1111 1
    return (refresh);
@


39.11
log
@wasn't freeing all attributes allocated.
@
text
@d66 1
a66 1
static Object *FindDataBase (struct AGLib * ag, STRPTR name)
d70 1
d73 1
a73 1
    BPTR lock;
d75 5
a79 2
    /* Get a lock on the file */
    if (lock = LVOLockE (ag, NULL, name, ACCESS_READ))
d101 1
d103 2
a104 3
	/* Release the temporary lock */
	UnLock (lock);
    }
d167 1
d180 1
d183 1
a183 1
	    if (newobj = FindDataBase (ag, name))
@


39.10
log
@changed debugging information.
@
text
@d11 1
a11 5
#define	DB(x)	;

/*****************************************************************************/

STRPTR errMsgs[] =
d21 1
a21 1
STRPTR warnMsgs[] =
d28 1
a28 1
LONG DebugPrintf (struct AGLib *ag, struct DatabaseData *dbd, STRPTR fmt, LONG argv, ...)
a36 1
#if 1
a37 3
#else
		sprintf (dbd->dbd_ErrorName, "CON:0/0/400/75/%s errors/CLOSE/WAIT", FilePart (dbd->dbd_Name));
#endif
d50 1
a50 1
void CloseDebug (struct AGLib *ag, struct DatabaseData *dbd, LONG mode)
d66 41
d122 1
a122 37
Object *FindDataBase (struct AGLib * ag, STRPTR name)
{
    struct DatabaseData *dbd;
    Object *member;
    Object *ostate;

    /* Lock the database list */
    ObtainSemaphore (&ag->ag_Lock);

    /* Search through the database list for a matching database */
    ostate = (Object *) ag->ag_DatabaseList.lh_Head;
    while (member = NextObject (&ostate))
    {
	/* Convert the member to a database object */
	dbd = INST_DATA (ag->ag_DatabaseClass, member);

	/* See if it matches */
	if (Stricmp (dbd->dbd_Name, name) == 0)
	{
	    /* Release the database lock */
	    ReleaseSemaphore (&ag->ag_Lock);

	    /* Return a pointer to the object that we found */
	    return (member);
	}
    }

    /* Release the database lock */
    ReleaseSemaphore (&ag->ag_Lock);
    return (NULL);
}

/*****************************************************************************/

#define	SHOW_NODES	FALSE

ULONG disposeDatabase (struct AGLib *ag, Class *cl, Object *o, Msg msg, struct DatabaseData *dbd)
a123 3
#if SHOW_NODES
    struct NodeData *nd;
#endif
a130 5
#if SHOW_NODES
	nd = INST_DATA (ag->ag_NodeClass, member);
	kprintf ("'%s', '%s', %ld, %ld\n", nd->nd_Name, nd->nd_Title, nd->nd_Offset, nd->nd_BufferLen);
#endif

d143 8
a288 1
    BPTR lock;
d324 2
a325 1
        if (lock = LVOLockE (ag, NULL, name, ACCESS_READ))
d327 1
a327 1
            if (NameFromLock (lock, dbd->dbd_FullName, sizeof (dbd->dbd_FullName)))
d331 1
a331 1
            if (dtn = ObtainDataTypeA (DTST_FILE, (APTR) lock, NULL))
a339 17
            UnLock (lock);
	}
#if 0
	else
	{
	    UBYTE pbuffer[300];
	    BPTR old;

	    DebugPrintf (ag, dbd, "Couldn't lock '%s'\n", (LONG) name);

	    old = CurrentDir (NULL);
	    if (NameFromLock (old, pbuffer, sizeof (pbuffer)))
		DebugPrintf (ag, dbd, "database current dir '%s'\n", (LONG) pbuffer);
	    CurrentDir (old);

	    if (NameFromLock (cd->cd_Process->pr_CurrentDir, pbuffer, sizeof (pbuffer)))
		DebugPrintf (ag, dbd, "process current dir '%s'\n", (LONG) pbuffer);
a340 1
#endif
a604 4
#if 0
	    if (argc > 1)
		setattrs (ag, o, DTA_ObjVersion, argv[1], TAG_DONE);
#endif
a696 1
#if 1
a698 4
#else
		if (!(*font = (ULONG) OpenFont (ta)))
		    *font = (ULONG) OpenDiskFont (ta);
#endif
d887 1
a887 2
		if (dbd->dbd_Name)
		    FreeVec (dbd->dbd_Name);
d894 1
a894 2
		if (dbd->dbd_Index)
		    FreeVec (dbd->dbd_Index);
d901 1
a901 2
		if (dbd->dbd_Help)
		    FreeVec (dbd->dbd_Help);
@


39.9
log
@clean up
@
text
@d40 6
a45 1
            sprintf (dbd->dbd_ErrorName, "CON:0/0/400/75/%s errors/CLOSE/WAIT", FilePart (dbd->dbd_Name));
d314 1
a314 1
    if (GetVar ("AmigaGuide/Debug", dbd->dbd_ErrorLine, sizeof (dbd->dbd_ErrorLine), NULL) > 0)
d316 1
a316 1
	if (Stricmp (dbd->dbd_ErrorLine, "ON") == 0)
d345 17
@


39.8
log
@no change.
@
text
@a14 3
#define	SHOW_ERRORS	FALSE

#if SHOW_ERRORS
d20 8
d29 37
a65 1
#endif
d75 1
a75 1
	cl->cl_Dispatcher.h_Entry = DBDispatch;
d118 39
a162 1
    Object *ostate;
d169 1
a169 1
	    /* Create a new database object */
d197 1
a197 1
	    /* Add a node object to the database's node list */
d203 1
a203 1
	    /* Remove a node object from the database's node list */
d209 1
a209 1
	    /* Set database attributes */
d215 3
d223 4
a226 2
		DoSuperMethodA (cl, o, msg);
		retval = 1L;
a238 8
		    /* Remove all the nodes from the node list */
		    ostate = (Object *) dbd->dbd_NodeList.lh_Head;
		    while (member = NextObject (&ostate))
		    {
			DoMethod (member, OM_REMOVE);
			DoMethodA (member, msg);
		    }

d244 1
a244 10
		    if (dbd->dbd_Font)
			CloseFont (dbd->dbd_Font);

		    /* Close the file */
		    if (dbd->dbd_FileHandle)
			Close (dbd->dbd_FileHandle);

		    /* Pass it up to the superclass */
		    DoSuperMethodA (cl, o, msg);
		    retval = 1L;
d292 1
d294 1
a294 1
    ULONG  errLevel  = RETURN_WARN;
d298 3
d308 7
d321 1
a321 1
    if ((hh == NULL) && (lock = LVOLockE (ag, NULL, name, ACCESS_READ)))
d323 16
a338 12
	if (NameFromLock (lock, dbd->dbd_FullName, sizeof (dbd->dbd_FullName)))
	    name = dbd->dbd_FullName;

	/* Sniff the file */
	if (dtn = ObtainDataTypeA (DTST_FILE, (APTR) lock, NULL))
	{
	    /* Is it an AmigaGuide document? */
	    if (Stricmp (dtn->dtn_Header->dth_BaseName, "amigaguide") == 0)
		amigaguide = TRUE;

	    /* Release the datatype */
	    ReleaseDataType (dtn);
a339 1
	UnLock (lock);
d378 3
d402 1
a402 1
		    tbufsize = MIN (10096, dblen);
d413 1
a413 1
			    for (i = lineofs = 0; going && (i < len); i++)
d417 1
d452 10
d485 1
a485 4
	/* It wasn't an AmigaGuide database.
	 *  So create a database with a main node that is the new object. */
	STRPTR title;
	Object *no;
d490 3
a492 3
			      DTA_SourceType, DTST_FILE,
			      GA_Immediate, TRUE,
			      GA_RelVerify, TRUE,
d543 4
d657 6
d700 4
d706 1
a706 1
		DB (kprintf ("font=%08lx, name=\"%s\", size=%ld (%s)\n", *font, ta->ta_Name, (ULONG)ta->ta_YSize, argv[2]));
d850 4
a855 1
#if 0
d858 12
a869 1
	DB (kprintf ("%s %ld Error %ld: %s\n", dbd->dbd_Name, dbd->dbd_NumLines, errnum, errMsgs[(errnum-1)]));
a870 1
#endif
@


39.7
log
@tracks help group
@
text
@a11 5
#define	DF(x)	;
#define	DE(x)	;
#define	DN(x)	;
#define	DD(x)	;
#define	DS(x)	;
a49 1
    DF (kprintf ("FindDataBase %s\n", name));
a65 1
	    DF (kprintf (" found!\n"));
a71 1
    DF (kprintf (" not found\n"));
a92 1
	    DN (kprintf ("om_new (database)\n"));
a108 1
		DN (kprintf (" initialize database\n"));
a140 1
		DD (kprintf ("dispose of database\n"));
a175 1
		    DD (kprintf ("dispose of database\n"));
a242 1
    DB (kprintf ("LVOLockE %s\n", name));
a245 1
	{
a246 2
	    DB (kprintf ("full name: %s\n", name));
	}
a252 1
	    {
a253 6
		DB (kprintf ("%s IS AN AMIGAGUIDE DOCUMENT\n", name));
	    }
	    else
	    {
		DB (kprintf ("%s IS NOT AN AMIGAGUIDE DOCUMENT\n", name));
	    }
a257 4
	else
	{
	    DB (kprintf ("couldn't obtain datatype for %s\n", name));
	}
a259 4
    else
    {
	DB (kprintf ("couldn't lock %s\n", name));
    }
a290 1
	DB (kprintf ("find the main node\n"));
a293 1
	    DB (kprintf (" create '%s' node object : title='%s'\n", ofh.ofh_Node, ofh.ofh_Title));
a304 4
	else
	{
	    DB (kprintf ("they refuse to admit to a Main node!!!\n"));
	}
a381 1
			DB (kprintf (" done reading\n"));
a396 1
	DF (kprintf (" get new object [%s]\n", name));
a406 1
	    DF (kprintf (" create node object\n"));
a420 4
	else
	{
	    DE (kprintf ("Couldn't load %s : IoErr=%ld \n", name, IoErr() ));
	}
a427 1
	DB (kprintf (" increment use count\n"));
a450 2

    DB (kprintf (" return %ld\n", (ULONG) success));
a545 1
				    DS (kprintf ("Master \"%s\" is newer than \"%s\".\n", argv[1], dbd->dbd_Name));
d571 1
a573 1
		ULONG *font;
d589 4
a592 2
		ta->ta_Name = name;
		ta->ta_YSize = atoi (argv[2]);
d600 1
a721 1
	    DB (kprintf ("%s at %ld\n", argv[1], (dbd->dbd_Offset - nd->nd_Offset)));
d746 1
d751 1
@


39.6
log
@added busy flag
@
text
@d239 1
a239 1
    ULONG  errNumber = 0;
d298 1
a298 2
	/* Show that the database is an AmigaGuide database */
	dbd->dbd_Flags |= DBDF_NODEHOST;
d300 4
a303 2
	/* Remember the host handle */
	dbd->dbd_HH = hh;
d306 1
d308 1
a308 1
	ofh.ofh_Attrs = NULL;
a309 1
	ofh.ofh_TOC   = NULL;
d311 3
a313 2
	ofh.ofh_Next  = NULL;
	ofh.ofh_Prev  = NULL;
d315 3
a791 1
#if SHOW_ERRORS
d793 3
a795 2
	kprintf ("%s %ld Error %ld: %s\n", dbd->dbd_Name, dbd->dbd_NumLines, errnum, errMsgs[(errnum-1)]);
#endif
@


39.5
log
@now use the full path name to open the databases
@
text
@d16 1
d557 46
@


39.4
log
@open goes through LVOOpenE
@
text
@d14 2
d54 1
a54 1
    DB (kprintf ("FindDataBase %s\n", name));
d71 1
a71 1
	    DB (kprintf (" found!\n"));
d78 1
a78 1
    DB (kprintf (" not found\n"));
d100 1
a100 1
	    DB (kprintf ("om_new (database)\n"));
d117 1
a117 1
		DB (kprintf (" initialize database\n"));
d150 1
a150 1
		DB (kprintf ("dispose of database\n"));
d186 1
a186 1
		    DB (kprintf ("dispose of database\n"));
d254 1
d257 6
d268 1
d270 6
d280 4
d285 4
@


39.3
log
@set error values
@
text
@d17 13
d252 1
a252 1
    if ((hh == NULL) && (lock = Lock (name, ACCESS_READ)))
d267 3
d319 1
a319 1
	if (dbd->dbd_FileHandle = Open (name, MODE_OLDFILE))
d328 2
d332 2
d336 1
a336 1
			    for (i = lineofs = 0; going && (i <= len); i++)
d340 1
d370 1
a371 1

d374 2
a448 3

	/* Set the attributes */
	setDBAttrs (ag, cl, o, msg);
d478 1
d497 2
d504 2
d513 2
d520 2
d567 3
a569 3
		    CloseFont (*font);
		if (!(*font = OpenFont (ta)))
		    *font = OpenDiskFont (ta);
d571 2
d578 2
d585 2
d592 2
d605 1
a605 1
		dbd->dbd_CurrentNode = newobject (ag, ag->ag_NodeClass, NULL,
d610 2
a611 1
						  TAG_DONE);
d613 2
d641 4
d650 4
d659 4
d668 4
d677 4
d684 4
a687 1
	    *text = TRUE;
d697 4
d710 2
d715 6
@


39.2
log
@title was NULL sometimes
@
text
@d78 1
d130 2
d181 1
d202 1
a202 1
    struct NodeData *nd = NULL;	/* Current Node */
d204 1
d206 1
a206 1
    struct opFindHost ofh;	/* Used to find the Main node */
d208 7
a214 7
    BOOL success = FALSE;	/* Able to initialize? */
    BOOL going = TRUE;		/* Keep processing file? */
    ULONG tbufsize;		/* Size of temporary buffer */
    LONG lineofs;		/* Offset of last line */
    STRPTR tbuf;		/* Temporary buffer */
    STRPTR name;		/* Name of the database */
    LONG dblen;			/* Length of entire database */
d217 2
a218 2
    LONG ofs;			/* Current offset in file */
    LONG len;			/* Length of Read() */
d220 5
a224 1
    LONG i;			/* Counter */
d234 1
a234 1
    name = (STRPTR) GetTagData (DBA_Name, NULL, ((struct opSet *) msg)->ops_AttrList);
d236 1
d361 4
d414 2
d430 17
@


39.1
log
@implemented node hosts
@
text
@d527 2
d530 12
a541 6
	    dbd->dbd_CurrentNode = newobject (ag, ag->ag_NodeClass, NULL,
					      HNA_Name, ((argc > 1) ? argv[1] : NULL),
					      HNA_Title, ((argc > 2) ? argv[2] : NULL),
					      HNA_Database, o,
					      HNA_FileHandle, dbd->dbd_FileHandle,
					      TAG_DONE);
d545 1
@


39.0
log
@initial RCS
@
text
@d6 1
d12 2
d24 1
a24 1
	cl->cl_UserData           = (ULONG) ag;
d132 1
d168 1
d196 1
d200 2
d226 1
d228 2
a229 3
    /* Lock the file */
    DB (kprintf (" lock %s\n", name));
    if (lock = Lock (name, ACCESS_READ))
a231 1
	DB (kprintf (" sniff type\n"));
a234 1
	    DB (kprintf (" compare [%s]\n", dtn->dtn_Header->dth_BaseName));
d244 2
a245 2
    DB (kprintf (" amigaguide=%ld\n", (ULONG) amigaguide));
    if (amigaguide)
d248 42
a292 1
	DB (kprintf (" open %s\n", name));
d361 2
a362 3
	/* It wasn't an AmigaGuide database.  So create a database with a main node that
	 * is the new object.
	 */
d366 3
a368 3
	/* Create the object. When we enter the object we will do AddDTObject()
	 * and RefreshDTObject().   When we exit the object, we will do RemoveDTObject(). */
	DB (kprintf (" get new object\n"));
d370 4
a373 4
						DTA_SourceType,	DTST_FILE,
						GA_Immediate,	TRUE,
						GA_RelVerify,	TRUE,
						TAG_DONE))
d375 2
a376 1
	    GetAttr (DTA_ObjName, no, (ULONG *)&title);
d379 1
a379 1
	    DB (kprintf (" create node object\n"));
d381 5
a385 5
						HNA_Name,	(ULONG)"Main",
						HNA_Title,	(ULONG)((title) ? title : name),
						HNA_Database,	o,
						HNA_Object,	no,
						TAG_DONE))
d394 4
d414 1
a414 1
    DB (kprintf (" return %ld\n", (ULONG)success));
d487 1
a487 1
		    font = (ULONG *)&nd->nd_Font;
d493 1
a493 1
		    font = (ULONG *)&dbd->dbd_Font;
d499 1
a499 1
		ta->ta_Name  = name;
d510 15
d541 1
a541 1
		nd->nd_Flags   |= HNF_WRAP;
d548 1
a548 1
		nd->nd_Flags   |= HNF_PROPORTIONAL;
d586 1
a586 1
	    DB (kprintf ("%s at %ld\n", argv[1], (dbd->dbd_Offset - nd->nd_Offset) ));
d634 14
a647 6
	    case DBA_Title:
		if (dbd->dbd_Title)
		    FreeVec (dbd->dbd_Title);
		dbd->dbd_Title = NULL;
		if (tidata && (dbd->dbd_Title = AllocVec (strlen ((STRPTR) tidata) + 1, MEMF_CLEAR)))
		    strcpy (dbd->dbd_Title, (STRPTR) tidata);
@
