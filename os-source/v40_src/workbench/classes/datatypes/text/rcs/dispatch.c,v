head     39.13;
branch   ;
access   ;
symbols  ;
locks    davidj:39.13; strict;
comment  @ * @;


39.13
date     93.12.07.11.27.53;  author davidj;  state Exp;
branches ;
next     39.12;

39.12
date     93.09.27.09.51.54;  author davidj;  state Exp;
branches ;
next     39.11;

39.11
date     93.06.15.15.32.33;  author davidj;  state Exp;
branches ;
next     39.10;

39.10
date     93.01.21.09.09.29;  author davidj;  state Exp;
branches ;
next     39.9;

39.9
date     92.12.07.09.41.03;  author davidj;  state Exp;
branches ;
next     39.8;

39.8
date     92.12.04.17.04.30;  author davidj;  state Exp;
branches ;
next     39.7;

39.7
date     92.12.02.17.19.33;  author davidj;  state Exp;
branches ;
next     39.6;

39.6
date     92.08.03.09.01.55;  author davidj;  state Exp;
branches ;
next     39.5;

39.5
date     92.07.23.17.49.16;  author davidj;  state Exp;
branches ;
next     39.4;

39.4
date     92.06.22.04.04.46;  author davidj;  state Exp;
branches ;
next     39.3;

39.3
date     92.06.04.14.21.03;  author davidj;  state Exp;
branches ;
next     39.2;

39.2
date     92.06.03.01.53.13;  author davidj;  state Exp;
branches ;
next     39.1;

39.1
date     92.06.02.11.40.35;  author davidj;  state Exp;
branches ;
next     39.0;

39.0
date     92.06.01.17.23.35;  author davidj;  state Exp;
branches ;
next     ;


desc
@initial RCS
@


39.13
log
@wasn't cloning the RastPorts all the time.
@
text
@/* file: 	dispatch.c
 * module:	text.datatype
 *
 */

#include "textbase.h"
#include <graphics/gfxmacros.h>

/*****************************************************************************/

#define	DB(x)	;
#define	DR(x)	;
#define	DL(x)	;

/*****************************************************************************/

ULONG getdtattrs (struct TextLib *txl, Object * o, ULONG data,...)
{
    return (GetDTAttrsA (o, (struct TagItem *) &data));
}

/*****************************************************************************/

ULONG setdtattrs (struct TextLib *txl, Object * o, ULONG data,...)
{
    return (SetDTAttrsA (o, NULL, NULL, (struct TagItem *) &data));
}

/*****************************************************************************/

ULONG notifyAttrChanges (struct TextLib *txl, Object * o, VOID * ginfo, ULONG flags, ULONG tag1,...)
{
    return DoMethod (o, OM_NOTIFY, &tag1, ginfo, flags);
}

/*****************************************************************************/

static struct TextAttr topaz =
{"topaz.font", 8, NULL, NULL};

/*****************************************************************************/

void PrepareFont (struct TextLib *txl, Object * o, struct localData *lod, struct TextAttr *tattr)
{
    struct DTSpecialInfo *si = (struct DTSpecialInfo *) G (o)->SpecialInfo;
    struct IBox *box;

    if (tattr)
    {
	GetAttr (DTA_Domain, o, (ULONG *) & box);

	if (lod->lod_Font)
	{
	    CloseFont (lod->lod_Font);
	    if (lod->lod_TmpPlane)
		FreeRaster (lod->lod_TmpPlane, lod->lod_TmpWidth, lod->lod_TmpHeight);
	}

	lod->lod_TextAttr = tattr;
	if (!(lod->lod_Font = OpenFont (lod->lod_TextAttr)))
	    lod->lod_Font = OpenFont (&topaz);

	si->si_VertUnit = lod->lod_TmpHeight = lod->lod_Font->tf_YSize;
	si->si_HorizUnit = (lod->lod_Font->tf_Flags & FPF_PROPORTIONAL) ? 1L : lod->lod_Font->tf_XSize;

	lod->lod_TmpWidth = box->Width;
	if (!box->Width)
	    lod->lod_TmpWidth = lod->lod_Font->tf_XSize * 80;

	if (lod->lod_TmpPlane = AllocRaster (lod->lod_TmpWidth, lod->lod_TmpHeight))
	    InitTmpRas (&lod->lod_TmpRas, lod->lod_TmpPlane, RASSIZE (lod->lod_TmpWidth, lod->lod_TmpHeight));
    }
}

/*****************************************************************************/

/* TAB, SPACE, COMMA, ... */
UBYTE delimArray[] = "	 *-,()<>[];\"";

/*****************************************************************************/

/* Methods we support */
ULONG m[] =
{
    OM_NEW,
    OM_GET,
    OM_SET,
    OM_UPDATE,
    OM_DISPOSE,

    GM_LAYOUT,
    GM_HITTEST,
    GM_GOACTIVE,
    GM_HANDLEINPUT,
    GM_RENDER,

#if 0
    DTM_SELECT,
#endif
    DTM_CLEARSELECTED,

    DTM_PRINT,
    DTM_COPY,
    DTM_WRITE,

    ~0,
};

/*****************************************************************************/

/* Inquire attribute of an object */
ULONG getTextDTAttr (struct TextLib *txl, Class * cl, Object * o, struct opGet *msg)
{
    struct localData *lod = INST_DATA (cl, o);

    switch (msg->opg_AttrID)
    {
	case DTA_Methods:
	    *msg->opg_Storage = (ULONG) m;
	    break;

	case DTA_TextAttr:
	    *msg->opg_Storage = (ULONG) lod->lod_TextAttr;
	    break;

	case DTA_TextFont:
	    *msg->opg_Storage = (ULONG) lod->lod_Font;
	    break;

	case TDTA_Buffer:
	    *msg->opg_Storage = (ULONG) lod->lod_Buffer;
	    break;

	case TDTA_BufferLen:
	    *msg->opg_Storage = (ULONG) lod->lod_BufferLen;
	    break;

	case TDTA_LineList:
	    *msg->opg_Storage = (ULONG) & lod->lod_LineList;
	    break;

	case TDTA_WordWrap:
	    *msg->opg_Storage = (lod->lod_Flags & LODF_WORDWRAP) ? TRUE : FALSE;
	    break;

	default:
	    return (DoSuperMethodA (cl, o, msg));
    }

    return (1L);
}

/*****************************************************************************/

/* Set attributes of an object */
ULONG setTextDTAttrs (struct TextLib * txl, Class * cl, Object * o, struct opSet * msg)
{
    struct TagItem *tags = msg->ops_AttrList;
    struct localData *lod;
    struct TagItem *tstate;
    struct TagItem *tag;
    ULONG refresh = 0L;
    ULONG tidata;

    lod = INST_DATA (cl, o);

    /* process rest */
    tstate = tags;
    while (tag = NextTagItem (&tstate))
    {
	tidata = tag->ti_Data;
	switch (tag->ti_Tag)
	{
	    case TDTA_WordDelim:
		lod->lod_WordDelim = (UBYTE *) tidata;
		break;

		/* If this changes, then we need to layout!!! */
	    case TDTA_Buffer:
		lod->lod_Buffer = (STRPTR) tidata;
		break;

		/* If this changes, then we need to layout!!! */
	    case TDTA_BufferLen:
		lod->lod_BufferLen = tidata;
		break;

		/* If this changes, then we need to layout!!! */
	    case TDTA_WordWrap:
		if (tidata)
		    lod->lod_Flags |= LODF_WORDWRAP;
		else
		    lod->lod_Flags &= ~LODF_WORDWRAP;
		break;

	    case DTA_TextAttr:
		PrepareFont (txl, o, lod, (struct TextAttr *) tidata);
	    case DTA_VisibleVert:
	    case DTA_TotalVert:
	    case DTA_VisibleHoriz:
	    case DTA_TotalHoriz:
		refresh = 1L;
		break;

	    case DTA_Sync:
		if (tidata)
		    refresh = 1;
		break;
	}
    }

    return (refresh);
}

/*****************************************************************************/

struct Region *installclipregion (struct TextLib *txl, struct Window *w, struct Layer *l, struct Region *r)
{
    BOOL refresh = FALSE;
    struct Region *or;

    if (w->Flags & WINDOWREFRESH)
    {
	EndRefresh (w, FALSE);
	refresh = TRUE;
    }
    or = InstallClipRegion (l, r);
    if (refresh)
	BeginRefresh (w);
    return (or);
}

/*****************************************************************************/

/* Render a single line of text at a given position */
VOID RenderLine (struct TextLib * txl, struct localData * lod, UWORD x, UWORD y, UWORD w, STRPTR text, ULONG len)
{
    struct RastPort *rp = &lod->lod_Render;

    Move (rp, x, y);
    Text (rp, text, len);
    if (rp->cp_x < w)
    {
	RectFill (&lod->lod_Clear,
		  rp->cp_x, y - rp->TxBaseline,
		  w, y - rp->TxBaseline + rp->TxHeight - 1);
    }
}

/*****************************************************************************/
/*
 * This function performs most of the rendering work needed by our sample. It
 * first locks the window's layer to insure it doesn't get sized during the
 * rendering process. It then looks at the current window size and adjusts
 * its rendering variables in consequence. If the damage parameter is set to
 * TRUE, the routine then proceeds to explicitly erase any area of the
 * display to which we will not be rendering in the rendering loop. This
 * erases any left over characters that could be left if the user sizes the
 * window smaller. Finally, the routine determines which lines of the display
 * need to be updated and goes on to do it.
 */
/*****************************************************************************/

ULONG renderMethod (struct TextLib *txl, Class * cl, Object * o, struct gpRender *msg)
{
    struct DTSpecialInfo *si = (struct DTSpecialInfo *) G (o)->SpecialInfo;
    struct localData *lod = INST_DATA (cl, o);
    struct GadgetInfo *gi = msg->gpr_GInfo;
    struct Window *win = gi->gi_Window;
    struct Layer *l = win->WLayer;
    LONG redraw = msg->gpr_Redraw;
    struct Region *old_r;
    struct Rectangle rect;
    struct Hook *oldhook;
    struct Line *line;
    struct IBox *box;
    struct IBox *sel;
    WORD curline = 0;
    ULONG style;
    UWORD rmarg;
    WORD x, y;
    LONG i, j;
    WORD cox;
    WORD cw;
    WORD lx;

    WORD ax, ay;
    WORD ex, ey;

    DR (kprintf ("  text renderMethod %ld\n", redraw));
    if ((si->si_Flags & DTSIF_LAYOUT) || !AttemptSemaphoreShared (&(si->si_Lock)))
    {
	lod->lod_Flags |= LODF_REDRAW;
	DR (kprintf ("   layout\n"));
	return 0;
    }

    if (lod->lod_Flags & LODF_REDRAW)
    {
	DR (kprintf ("   lodf_redraw\n"));
	lod->lod_Flags ^= LODF_REDRAW;
	redraw = GREDRAW_REDRAW;
    }

    getdtattrs (txl, o, DTA_SelectDomain, &sel, TAG_DONE);
    box = &lod->lod_Domain;

    DB (kprintf ("o=%08lx, lod=%08lx box=%08lx\n", o, lod, box));

    /* Compute the right margin */
    rmarg = box->Left + box->Width;

    /* The ONLY way we can get a toggle method is if we were highlighted and we want to turn it off */
    if (redraw == GREDRAW_TOGGLE)
    {
	DR (kprintf ("   toggle\n"));
	if (lod->lod_Flags & LODF_HIGHLIGHT)
	{
	    si->si_Flags |= DTSIF_HIGHLIGHT;
	    si->si_Flags &= ~DTSIF_HIGHLIGHT;
	    DrawBox (txl, cl, o, &lod->lod_Highlight, box, sel, DBS_DOWN);
	    lod->lod_Flags &= ~LODF_HIGHLIGHT;
	}
    }
    else
    {
	if (si->si_VisVert > si->si_TotVert)
	{
	    lod->lod_UsefulHeight = UMult32 (si->si_TotVert, si->si_VertUnit);
	    si->si_TopVert = 0;
	}
	else if (si->si_TopVert + si->si_VisVert > si->si_TotVert)
	{
	    si->si_TopVert = (si->si_TotVert - si->si_VisVert);
	    lod->lod_UsefulHeight = UMult32 ((si->si_TotVert - si->si_TopVert), si->si_VertUnit);
	}
	DR (kprintf ("  v %ld,%ld,%ld\n", si->si_TopVert, si->si_VisVert, si->si_TotVert));

	/* if we were called because of damage, we must erase any left over garbage */
	if (redraw == GREDRAW_REDRAW)
	{
	    DR (kprintf ("   redraw\n"));

	    /* erase anything left over on the right side of the window */
	    if (lod->lod_UsefulHeight)
	    {
		DR (kprintf ("clear right %ld,%ld,%ld,%ld\n",
			     (LONG) box->Left, (LONG) box->Top,
			     (LONG) (box->Left + box->Width - 1),
			     (LONG) (box->Top + lod->lod_UsefulHeight - 1)));

		RectFill (&lod->lod_Clear,
			  box->Left,
			  box->Top,
			  box->Left + box->Width - 1,
			  box->Top + lod->lod_UsefulHeight - 1);
	    }

	    /* erase anything left over on the bottom of the window */
	    if ((box->Left < box->Left + box->Width) &&
		(box->Top + lod->lod_UsefulHeight < box->Top + box->Height))
	    {
		DR (kprintf ("clear bottom %ld,%ld,%ld,%ld\n",
			     (LONG) box->Left, (LONG) (box->Top + lod->lod_UsefulHeight),
			     (LONG) (box->Left + box->Width - 1),
			     (LONG) (box->Top + box->Height - 1)));

		RectFill (&lod->lod_Clear,
			  box->Left,
			  box->Top + lod->lod_UsefulHeight,
			  box->Left + box->Width - 1,
			  box->Top + box->Height - 1);
	    }
	}

	/* if we at least one line and one column to render in... */
	if (lod->lod_UsefulHeight && box->Width)
	{
	    cw = box->Width;
	    cox = 0;

	    /* get a pointer to the first line currently visible */
	    DR (kprintf ("find top\n"));
	    i = si->si_TopVert;
	    line = (struct Line *) lod->lod_LineList.mlh_Head;
	    while (line->ln_Link.mln_Succ && i)
	    {
		if (line->ln_Flags & LNF_LF)
		    i--;
		line = (struct Line *) line->ln_Link.mln_Succ;
	    }

	    /* Default to no drawing */
	    DR (kprintf ("do calcs\n"));
	    i = j = 0;

	    /* Calculate the default x, y */
	    x = (LONG) box->Left - (si->si_TopHoriz * si->si_HorizUnit);
	    y = (LONG) box->Top + lod->lod_Font->tf_Baseline;

	    /* Give ourselves a NULL backfill hook */
	    DR (kprintf ("  install nobackfill hook in %08lx, %08lx\n", l, l->LayerInfo));
#if 0
	    LockLayerInfo (l->LayerInfo);
#endif
	    oldhook = InstallLayerHook (l, LAYERS_NOBACKFILL);

	    DR (kprintf ("  scroll\n"));
	    if ((redraw == GREDRAW_REDRAW)
		|| (si->si_TopVert >= si->si_OTopVert + si->si_VisVert - 1)
		|| ((si->si_OTopVert > si->si_VisVert) && (si->si_TopVert <= si->si_OTopVert - si->si_VisVert + 1))
		|| (si->si_TopHoriz >= si->si_OTopHoriz + si->si_VisHoriz - 1)
		|| ((si->si_OTopHoriz > si->si_VisHoriz) && (si->si_TopHoriz <= si->si_OTopHoriz - si->si_VisHoriz + 1))
		|| ((si->si_TopHoriz != si->si_OTopHoriz) && (si->si_TopVert != si->si_OTopVert))
		)
	    {
		/* the whole display must be redrawn */
		i = si->si_VisVert;
		j = si->si_VisHoriz;
	    }
	    else if (si->si_TopVert < si->si_OTopVert)
	    {
		/* we just need to scroll the text */
		ScrollRasterBF (msg->gpr_RPort,
				0, -(LONG) UMult32 ((si->si_OTopVert - si->si_TopVert), si->si_VertUnit),
				box->Left,
				box->Top,
				box->Left + box->Width - 1,
				box->Top + lod->lod_UsefulHeight - 1);

		/* indicates what section needs to be redrawn */
		i = si->si_OTopVert - si->si_TopVert;
	    }
	    else if (si->si_TopVert > si->si_OTopVert)
	    {
		/* we just need to scroll the text */
		ScrollRasterBF (msg->gpr_RPort,
				0, UMult32 ((si->si_TopVert - si->si_OTopVert), si->si_VertUnit),
				box->Left,
				box->Top,
				box->Left + box->Width - 1,
				box->Top + lod->lod_UsefulHeight - 1);

		/* indicates what section needs to be redrawn */
		i = si->si_VisVert - (si->si_TopVert - si->si_OTopVert);
		while (line->ln_Link.mln_Succ && i)
		{
		    if (line->ln_Flags & LNF_LF)
		    {
			curline++;
			i--;
		    }
		    line = (struct Line *) line->ln_Link.mln_Succ;
		}

		y += UMult32 (si->si_VertUnit, (si->si_VisVert - (si->si_TopVert - si->si_OTopVert)));
		i = si->si_TopVert - si->si_OTopVert;
	    }
	    /* HORIZONTAL */
	    else if (si->si_TopHoriz < si->si_OTopHoriz)
	    {
		/* indicates what section needs to be redrawn */
		j = (si->si_OTopHoriz - si->si_TopHoriz) * si->si_HorizUnit;
		i = si->si_VisVert;
		cw = (WORD) j;

		/* we just need to scroll the text */
		ScrollRasterBF (msg->gpr_RPort,
				-(j), 0,
				box->Left,
				box->Top,
				box->Left + box->Width - 1,
				box->Top + lod->lod_UsefulHeight - 1);
	    }
	    else if (si->si_TopHoriz > si->si_OTopHoriz)
	    {
		/* indicates what section needs to be redrawn */
		j = (si->si_TopHoriz - si->si_OTopHoriz) * si->si_HorizUnit;
		i = si->si_VisVert;
		cw = (WORD) j;
		cox = box->Width - cw;

		/* we just need to scroll the text */
		ScrollRasterBF (msg->gpr_RPort,
				j, 0,
				box->Left,
				box->Top,
				box->Left + box->Width - 1,
				box->Top + lod->lod_UsefulHeight - 1);
	    }

	    if (l)
	    {
		ax = ay = ex = ey = -1;
		if (sel)
		{
		    ax = sel->Left - (si->si_TopHoriz * si->si_HorizUnit);
		    ay = sel->Top - si->si_TopVert;
		    ex = sel->Width - (si->si_TopHoriz * si->si_HorizUnit);
		    ey = sel->Height - si->si_TopVert;
		}

		/* Set up the clipping rectangle */
		rect.MinX = box->Left + cox;
		rect.MinY = box->Top;
		rect.MaxX = rect.MinX + cw - 1;
		rect.MaxY = rect.MinY + lod->lod_UsefulHeight - 1;

		/* Apply the clipping region */
		DR (kprintf ("  install clip region\n"));
		ClearRegion (lod->lod_Region);
		OrRectRegion (lod->lod_Region, &rect);
		old_r = installclipregion (txl, win, l, lod->lod_Region);

#if 1
#else
		tags[0].ti_Tag = RPTAG_DrawBounds;
		tags[0].ti_Data = (ULONG) & rect;
		tags[1].ti_Tag = TAG_DONE;
		GetRPAttrsA (msg->gpr_RPort, tags);
		DB (kprintf ("%ld,%ld,%ld,%ld\n", (ULONG) rect.MinX, (ULONG) rect.MinY, (ULONG) rect.MaxX, (ULONG) rect.MaxY));
#endif

		/* Make sure all the attributes are properly set. */
		SetSoftStyle (&lod->lod_Render, style = line->ln_Style, 0xFF);

		/* render all the lines we need */
		DR (kprintf ("  render lines : %08lx, %08lx, %ld\n", line, line->ln_Link.mln_Succ, i));
		lx = x;
		while (line->ln_Link.mln_Succ && i)
		{
#if 1
		    if (1)
#else
		    if ((y >= rect.MinY) && (y <= rect.MaxX))
#endif
		    {
			SetABPenDrMd (&lod->lod_Render, line->ln_FgPen, line->ln_BgPen, JAM2);
			if (style != line->ln_Style)
			    SetSoftStyle (&lod->lod_Render, style = line->ln_Style, 0xFF);

			if (lx < (x + line->ln_XOffset))
			{
			    RectFill (&lod->lod_Clear,
				      lx, y - lod->lod_Render.TxBaseline,
				      x + line->ln_XOffset, y - lod->lod_Render.TxBaseline + si->si_VertUnit - 1);
			}

			if (x + line->ln_XOffset < box->Left + box->Width)
			{
			    RenderLine (txl, lod, x + line->ln_XOffset, y, rmarg, line->ln_Text, line->ln_TextLen);
			    lx = lod->lod_Render.cp_x;
			}

			if (line->ln_Flags & LNF_LF)
			{
			    /* Handle selected lines */
			    if (sel && (curline >= ay) && (curline <= ey))
			    {
				if (ay == ey)
				{
				    RectFill (&lod->lod_Highlight,
					      box->Left + ax,
					      y - lod->lod_Render.TxBaseline,
					      box->Left + ex,
					      y - lod->lod_Render.TxBaseline + si->si_VertUnit - 1);
				}
				else if (curline == ay)
				{
				    RectFill (&lod->lod_Highlight,
					      box->Left + ax,
					      y - lod->lod_Render.TxBaseline,
					      box->Left + box->Width - 1,
					      y - lod->lod_Render.TxBaseline + si->si_VertUnit - 1);
				}
				else if (curline == ey)
				{
				    RectFill (&lod->lod_Highlight,
					      box->Left,
					      y - lod->lod_Render.TxBaseline,
					      box->Left + ex,
					      y - lod->lod_Render.TxBaseline + si->si_VertUnit - 1);
				}
				else
				{
				    RectFill (&lod->lod_Highlight,
					      box->Left,
					      y - lod->lod_Render.TxBaseline,
					      box->Left + box->Width - 1,
					      y - lod->lod_Render.TxBaseline + si->si_VertUnit - 1);
				}
			    }
			    y += si->si_VertUnit;
			    curline++;
			    lx = x;
			    i--;
			}
		    }
		    else
		    {
			if (line->ln_Flags & LNF_LF)
			{
			    y += si->si_VertUnit;
			    curline++;
			    lx = x;
			    i--;
			}
		    }

		    line = (struct Line *) line->ln_Link.mln_Succ;
		}

		/* Restore the clip region */
		installclipregion (txl, win, l, old_r);
	    }
	    else
	    {
		DR (kprintf ("  no layer\n"));
	    }

	    /* Restore the original backfill hook */
	    InstallLayerHook (l, oldhook);
#if 0
	    UnlockLayerInfo (l->LayerInfo);
#endif
	}

	si->si_OTopVert = si->si_TopVert;
	si->si_OTopHoriz = si->si_TopHoriz;
    }

    ReleaseSemaphore (&(si->si_Lock));

    DR (kprintf ("   done\n"));
    return (1L);
}

/*****************************************************************************/

ULONG printMethod (struct TextLib * txl, Class * cl, Object * o, struct dtPrint * msg)
{
    struct localData *lod = INST_DATA (cl, o);
    struct Preferences *prefs;
    struct PrinterData *pd;
    union printerIO *pio;
    LONG pstatus = 0L;
    ULONG retval = 0L;
    struct Line *line;
    UBYTE spaces[80];
    UBYTE attrs[80];
    ULONG style = ~0;
    BYTE fgpen = ~0;
    BYTE bgpen = ~0;
    UBYTE tmp[16];
    ULONG tspace;
    ULONG bsig;
    UWORD i, j;
    UWORD lx;

    if (pio = msg->dtp_PIO)
    {
	pd = (struct PrinterData *) pio->iodrp.io_Device;
	prefs = &pd->pd_Preferences;

	/* Initialize the tab line */
	for (i = 0; i < 80; i++)
	    spaces[i] = ' ';

	/* Compute the tab size */
	tspace = (ULONG) ((lod->lod_Font->tf_CharSpace && lod->lod_Font->tf_CharKern) ? 8 : lod->lod_Font->tf_XSize);

	/* Initialize variables */
	lx = 0;
	i = 1;

	line = (struct Line *) lod->lod_LineList.mlh_Head;
	while (line->ln_Link.mln_Succ && (pstatus == 0L) && !(bsig = CheckSignal (SIGBREAKF_CTRL_C)))
	{

	    /* Perform TAB spacing */

	    if (line->ln_XOffset > lx)
	    {
		/* Spaces from previous character divided by size of space */
		j = (line->ln_XOffset - lx) / tspace;
		spaces[j] = 0;
		pio->ios.io_Length = -1;
		pio->ios.io_Data = (APTR) spaces;
		pio->ios.io_Command = CMD_WRITE;
		DoIO ((struct IORequest *) pio);
		pstatus = (LONG) pio->ios.io_Error;
		spaces[j] = ' ';
	    }

	    if ((pstatus == 0L) &&
		((style != line->ln_Style) || (fgpen != line->ln_FgPen) || (bgpen != line->ln_BgPen)))
	    {
		/* Set font attributes */
		style = line->ln_Style;
		strcpy (attrs, "\033[0m");
		if (style & FSF_BOLD)
		    strcat (attrs, "\033[1m");
		if (style & FSF_ITALIC)
		    strcat (attrs, "\033[3m");
		if (style & FSF_UNDERLINED)
		    strcat (attrs, "\033[4m");

		/* Set foreground color attributes */
		fgpen = line->ln_FgPen;
		sprintf (tmp, "\033[3%ldm", (LONG) fgpen);
		strcat (attrs, tmp);

		/* Set background color attributes */
		bgpen = line->ln_FgPen;
		sprintf (tmp, "\033[4%ldm", (LONG) bgpen);
		strcat (attrs, tmp);
		pio->ios.io_Length = -1;
		pio->ios.io_Data = (APTR) attrs;
		pio->ios.io_Command = CMD_WRITE;
		DoIO ((struct IORequest *) pio);
		pstatus = (LONG) pio->ios.io_Error;
	    }

	    /* Print line */

	    if (pstatus == 0L)
	    {
		pio->ios.io_Length = line->ln_TextLen;
		pio->ios.io_Data = (APTR) line->ln_Text;
		pio->ios.io_Command = CMD_WRITE;
		DoIO ((struct IORequest *) pio);
		pstatus = (LONG) pio->ios.io_Error;

		lx = line->ln_XOffset + line->ln_Width;

		if ((line->ln_Flags & LNF_LF) && (pstatus == 0L))
		{
		    pio->ios.io_Length = 1;
		    pio->ios.io_Data = (APTR) "\n";
		    pio->ios.io_Command = CMD_WRITE;
		    DoIO ((struct IORequest *) pio);
		    pstatus = (LONG) pio->ios.io_Error;

		    lx = 0;
		    i++;

		    if ((i > prefs->PaperLength) && (pstatus == 0L))
		    {
			pio->ios.io_Length = 1;
			pio->ios.io_Data = (APTR) "";
			pio->ios.io_Command = CMD_WRITE;
			DoIO ((struct IORequest *) pio);
			pstatus = (LONG) pio->ios.io_Error;
			i = 1;
		    }
		}
	    }
	    line = (struct Line *) line->ln_Link.mln_Succ;
	}

	/* Show that we tried to print */
	retval = (ULONG) pstatus;
    }

    return retval;
}

/*****************************************************************************/

BOOL writeObject (struct TextLib * txl, APTR handle, Object * o, struct localData * lod, struct GadgetInfo * gi, LONG mode)
{
    struct IFFHandle *iff = (struct IFFHandle *) handle;
    BPTR fh = (BPTR) handle;
    BOOL success = FALSE;
    struct IBox *sel;

    GetAttr (DTA_SelectDomain, o, (ULONG *) & sel);

    if (sel == NULL)
    {
	if (mode == DTWM_IFF)
	{
	    if (OpenIFF (iff, IFFF_WRITE) == 0)
	    {
		if (PushChunk (iff, ID_FTXT, ID_FORM, IFFSIZE_UNKNOWN) == 0)
		{
		    if (PushChunk (iff, 0, ID_CHRS, lod->lod_BufferLen) == 0)
			if (WriteChunkBytes (iff, lod->lod_Buffer, lod->lod_BufferLen) == lod->lod_BufferLen)
			    if (PopChunk (iff) == 0)
				success = TRUE;
		    PopChunk (iff);
		}
		CloseIFF (iff);
	    }
	}
	else if (mode == DTWM_RAW)
	{
	    if (Write (fh, lod->lod_Buffer, lod->lod_BufferLen) == lod->lod_BufferLen)
		success = TRUE;
	}

    }
    else
    {
	ULONG s = MIN (lod->lod_AWord, lod->lod_EWord);
	ULONG e = MAX (lod->lod_AWord, lod->lod_EWord);
	ULONG len;

	len = e - s;

	if (mode == DTWM_IFF)
	{
	    if (OpenIFF (iff, IFFF_WRITE) == 0)
	    {
		if (PushChunk (iff, ID_FTXT, ID_FORM, IFFSIZE_UNKNOWN) == 0)
		{
		    if (PushChunk (iff, 0, ID_CHRS, len) == 0)
			if (WriteChunkBytes (iff, (STRPTR) s, len) == len)
			    if (PopChunk (iff) == 0)
				success = TRUE;
		    PopChunk (iff);
		}
		CloseIFF (iff);
	    }
	}
	else if (mode == DTWM_RAW)
	{
	    if (Write (fh, (STRPTR) s, len) == len)
		success = TRUE;
	}

	DoMethod (o, DTM_CLEARSELECTED, gi);
    }

    if (!success)
	DisplayBeep (NULL);

    return (success);
}

/*****************************************************************************/

ULONG copyMethod (struct TextLib * txl, Class * cl, Object * o, struct dtGeneral * msg)
{
    struct localData *lod = INST_DATA (cl, o);
    struct IFFHandle *iff;
    BOOL success = FALSE;

    if (iff = AllocIFF ())
    {
	if (iff->iff_Stream = (ULONG) OpenClipboard (0L))
	{
	    InitIFFasClip (iff);
	    success = writeObject (txl, iff, o, lod, msg->dtg_GInfo, DTWM_IFF);
	    CloseClipboard ((struct ClipboardHandle *) iff->iff_Stream);
	}

	FreeIFF (iff);
    }
    return ((ULONG) success);
}

/*****************************************************************************/

ULONG writeMethod (struct TextLib * txl, Class * cl, Object * o, struct dtWrite * msg)
{
    struct localData *lod = INST_DATA (cl, o);
    struct IFFHandle *iff;
    BOOL success = FALSE;

    if (msg->dtw_Mode == DTWM_IFF)
    {
	if (iff = AllocIFF ())
	{
	    if (iff->iff_Stream = msg->dtw_FileHandle)
	    {
		InitIFFasDOS (iff);
		success = writeObject (txl, iff, o, lod, msg->dtw_GInfo, DTWM_IFF);
	    }
	    FreeIFF (iff);
	}
    }
    else if (msg->dtw_Mode == DTWM_RAW)
    {
	success = writeObject (txl, (APTR) msg->dtw_FileHandle, o, lod, msg->dtw_GInfo, DTWM_RAW);
    }

    return ((ULONG) success);
}

/*****************************************************************************/

static ULONG ASM dispatch (REG (a0) Class * cl, REG (a2) Object * o, REG (a1) Msg msg)
{
    struct DTSpecialInfo *si = (struct DTSpecialInfo *) G (o)->SpecialInfo;
    struct TextLib *txl = (struct TextLib *) cl->cl_UserData;
    struct localData *lod = INST_DATA (cl, o);
    struct RastPort *rp;
    struct gpRender gpr;
    struct Node *node;
    Object *newobj;
    ULONG retval;

    switch (msg->MethodID)
    {
	case OM_NEW:
	    DB (kprintf ("\n--- New -----------------------------------------\n"));
	    if (newobj = (Object *) DoSuperMethodA (cl, o, msg))
	    {
		struct DataTypeHeader *dth;
		struct DataType *dtn;
		BOOL success = FALSE;
		STRPTR title;
		UWORD dtype;
		BPTR fh;

		lod = INST_DATA (cl, newobj);

		/* Show that we use scrollraster */
		EG (newobj)->MoreFlags |= GMORE_SCROLLRASTER;

		/* Initialize object data */
		NewList ((struct List *) &lod->lod_LineList);

		/* Establish defaults */
		lod->lod_WordDelim = delimArray;

		/* Prepare the font */
		PrepareFont (txl, newobj, lod, &topaz);

		/* Get the default title */
		title = (STRPTR) GetTagData (DTA_Name, NULL, ((struct opSet *) msg)->ops_AttrList);

		/* Get the handles */
		getdtattrs (txl, newobj,
			    DTA_Handle, (ULONG) & fh,
			    DTA_DataType, (ULONG) & dtn,
			    TAG_DONE);

		/* If there are no handles, then the source must be RAM */
		if ((dtn == NULL) && (fh == NULL))
		{
		    success = TRUE;
		}
		else if (dtn && fh)
		{
		    dth = dtn->dtn_Header;
		    dtype = dth->dth_Flags & DTF_TYPE_MASK;

		    if (dtype == DTF_IFF)
		    {
			struct IFFHandle *iff = (struct IFFHandle *) fh;
			struct StoredProperty *sp;
			struct ContextNode *cn;

			/* We want a name if there is one */
			PropChunk (iff, ID_FTXT, ID_NAME);

			/* IFF Handle is already opened for reading! */
			if (StopChunk (iff, ID_FTXT, ID_CHRS) == 0L)
			{
			    /* Parse the file, stopping at a character chunk */
			    if (ParseIFF (iff, IFFPARSE_SCAN) == 0)
			    {
				/* Get information on the current chunk */
				if ((cn = CurrentChunk (iff)) && (cn->cn_Size > 0L))
				{
				    lod->lod_BufferLen = cn->cn_Size;
				    if (lod->lod_Buffer = AllocVec (lod->lod_BufferLen + 1L, MEMF_CLEAR))
				    {
					if (ReadChunkBytes (iff, lod->lod_Buffer, lod->lod_BufferLen) == lod->lod_BufferLen)
					{
					    if (sp = FindProp (iff, ID_FTXT, ID_NAME))
						title = (STRPTR) sp->sp_Data;
					    success = TRUE;
					}
				    }
				}
			    }
			}
		    }
		    else if (dtype == DTF_MISC)
		    {
			if (fh)
			    success = TRUE;
		    }
		    else
		    {
			if (dtype == DTF_BINARY)
			{
			    DB (kprintf ("binary data, %s\n", dtn->dtn_Header->dth_Name));
			}

			if (Seek (fh, 0L, OFFSET_END) >= 0L)
			{
			    if ((lod->lod_BufferLen = Seek (fh, 0L, OFFSET_BEGINNING)) > 0L)
			    {
				if (lod->lod_Buffer = AllocVec (lod->lod_BufferLen + 1L, MEMF_CLEAR))
				{
				    if (Read (fh, lod->lod_Buffer, lod->lod_BufferLen) == lod->lod_BufferLen)
				    {
					success = TRUE;
				    }
				}
			    }
			}
		    }
		}

		if (success)
		{
		    if ((lod->lod_Region = NewRegion ()) == NULL)
			success = FALSE;
		}

		if (success)
		{
		    struct TagItem tags[2];

		    tags[0].ti_Tag = DTA_ObjName;
		    tags[0].ti_Data = (ULONG) title;
		    tags[1].ti_Tag = TAG_DONE;
		    DoSuperMethod (cl, newobj, OM_SET, tags, NULL);

		    setTextDTAttrs (txl, cl, newobj, (struct opSet *) msg);
		}
		else
		{
		    CoerceMethod (cl, newobj, OM_DISPOSE);
		    newobj = NULL;
		}
	    }

	    retval = (ULONG) newobj;
	    break;

	case OM_GET:
	    retval = getTextDTAttr (txl, cl, o, (struct opGet *) msg);
	    break;

	case OM_NOTIFY:
	    retval = DoSuperMethodA (cl, o, msg);
	    {
		struct TagItem *attrs = ((struct opSet *) msg)->ops_AttrList;
		struct Line *ln;
		UBYTE mp = 0;

		if (GetTagData (DTA_Sync, NULL, attrs))
		{
		    ln = (struct Line *) lod->lod_LineList.mlh_Head;
		    while (ln->ln_Link.mln_Succ)
		    {
			mp = (ln->ln_FgPen > mp) ? ln->ln_FgPen : mp;
			mp = (ln->ln_BgPen > mp) ? ln->ln_BgPen : mp;
			ln = (struct Line *) ln->ln_Link.mln_Succ;
		    }
		    SetMaxPen (&lod->lod_Render, mp);
		    SetMaxPen (&lod->lod_Clear, mp);
		}
	    }
	    break;

	case OM_UPDATE:
	case OM_SET:
	    retval = DoSuperMethodA (cl, o, msg);
	    retval += setTextDTAttrs (txl, cl, o, (struct opSet *) msg);

	    if (retval && (OCLASS (o) == cl))
	    {
		/* Get a pointer to the rastport */
		if (rp = ObtainGIRPort (((struct opSet *) msg)->ops_GInfo))
		{
		    /* Force a redraw */
		    gpr.MethodID = GM_RENDER;
		    gpr.gpr_GInfo = ((struct opSet *) msg)->ops_GInfo;
		    gpr.gpr_RPort = rp;
		    gpr.gpr_Redraw = GREDRAW_UPDATE;
		    DR (kprintf ("  force %ld\n", GREDRAW_UPDATE));
		    DoMethodA (o, &gpr);

		    /* Release the temporary rastport */
		    ReleaseGIRPort (rp);
		}

		/* Clear the return value */
		retval = 0L;
	    }
	    break;

	case GM_RENDER:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    retval += renderMethod (txl, cl, o, (struct gpRender *) msg);
	    break;

	case GM_GOACTIVE:
	case GM_HANDLEINPUT:
	    retval = handleInput (txl, cl, o, (struct gpInput *) msg);
	    break;

	case GM_GOINACTIVE:
	    retval = goinactive (txl, cl, o, (struct gpInput *) msg);
	    break;

	case DTM_CLEARSELECTED:
	    ((struct DTSpecialInfo *) (G (o)->SpecialInfo))->si_Flags &= ~DTSIF_HIGHLIGHT;
	case DTM_SELECT:
	    {
		struct dtSelect *dts = (struct dtSelect *) msg;

		/* Get a pointer to the rastport */
		if (rp = ObtainGIRPort (dts->dts_GInfo))
		{
		    /* Toggle the currently selected line */
		    gpr.MethodID = GM_RENDER;
		    gpr.gpr_GInfo = dts->dts_GInfo;
		    gpr.gpr_RPort = rp;
		    gpr.gpr_Redraw = GREDRAW_TOGGLE;
		    DoMethodA (o, &gpr);

		    /* Release the temporary rastport */
		    ReleaseGIRPort (rp);
		}
		/* Clear the return value */
		retval = 0L;
	    }
	    break;

	case DTM_PRINT:
	    retval = printMethod (txl, cl, o, (struct dtPrint *) msg);
	    break;

	case DTM_COPY:
	    retval = copyMethod (txl, cl, o, (struct dtGeneral *) msg);
	    break;

	case DTM_WRITE:
	    retval = writeMethod (txl, cl, o, (struct dtWrite *) msg);
	    break;

	case GM_LAYOUT:
	case DTM_PROCLAYOUT:
	    /* Make sure the RastPort are set up */
	    {
		struct gpLayout *gpl = (struct gpLayout *) msg;
		struct GadgetInfo *gi = gpl->gpl_GInfo;
		UWORD *pens, pena[NUMDRIPENS + 1];
		struct IBox *box;

		DL (kprintf ("Layout %ld\n", ((struct gpLayout *) msg)->gpl_Initial));

		if (gi && gi->gi_Window)
		{
		    struct RastPort *rp = gi->gi_Window->RPort;

		    /* Initialize pen array */
		    pens = gi->gi_DrInfo->dri_Pens;

		    /* Initialize the RastPorts */
		    DB (kprintf ("copy clear rastport\n"));
		    lod->lod_Clear = *rp;
		    lod->lod_Render = *rp;
		    lod->lod_Highlight = *rp;
		}
		else
		{
		    /* Initialize pen array */
		    pena[BACKGROUNDPEN] = 0;
		    pena[TEXTPEN] = 1;
		    pena[FILLPEN] = 3;
		    pens = pena;

		    /* Initialize the RastPorts */
		    DB (kprintf ("initialize clear rastport\n"));
		    InitRastPort (&lod->lod_Clear);
		    InitRastPort (&lod->lod_Render);
		    InitRastPort (&lod->lod_Highlight);
		}

		/* Set the TmpRas */
		lod->lod_Render.TmpRas = &lod->lod_TmpRas;
		lod->lod_Highlight.TmpRas = &lod->lod_TmpRas;
		lod->lod_Clear.TmpRas = &lod->lod_TmpRas;

		SetABPenDrMd (&lod->lod_Render, pens[TEXTPEN], pens[BACKGROUNDPEN], JAM2);
		SetFont (&lod->lod_Render, lod->lod_Font);
		SetWrMsk (&lod->lod_Render, 0xFF);

		SetABPenDrMd (&lod->lod_Clear, pens[BACKGROUNDPEN], pens[BACKGROUNDPEN], JAM2);
		SetFont (&lod->lod_Clear, lod->lod_Font);
		SetWrMsk (&lod->lod_Render, 0xFF);

		SetABPenDrMd (&lod->lod_Highlight, pens[FILLPEN], pens[BACKGROUNDPEN], COMPLEMENT);
		SetWrMsk (&lod->lod_Highlight, 0x1);
		SetFont (&lod->lod_Highlight, lod->lod_Font);

		lod->lod_Flags |= LODF_REDRAW;
		retval = (ULONG) DoSuperMethodA (cl, o, msg);
		FreeVec (lod->lod_Selected);
		lod->lod_Selected = NULL;

		/* Get the current size */
		getdtattrs (txl, o, DTA_Domain, &box, TAG_DONE);
		lod->lod_Domain = *box;
		si->si_VisVert = UDivMod32 (box->Height, si->si_VertUnit);
		lod->lod_UsefulHeight = UMult32 (si->si_VisVert, si->si_VertUnit);
	    }
	    break;

	    /* Let the superclass handle everything else */
	case DTM_REMOVEDTOBJECT:
	    DL (kprintf ("Remove object\n"));
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    break;

	case OM_DISPOSE:
	    FreeVec (lod->lod_Buffer);
	    while (node = RemHead ((struct List *) &lod->lod_LineList))
		FreeVec (node);
	    if (lod->lod_Font)
		CloseFont (lod->lod_Font);
	    if (lod->lod_TmpPlane)
		FreeRaster (lod->lod_TmpPlane, lod->lod_TmpWidth, lod->lod_TmpHeight);
	    FreeVec (lod->lod_Selected);
	    DisposeRegion (lod->lod_Region);

	    /* Let the superclass handle everything else */
	default:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    break;
    }

    return (retval);
}

/*****************************************************************************/

Class *initClass (struct TextLib * txl)
{
    Class *cl;

    if (cl = MakeClass (TEXTDTCLASS, DATATYPESCLASS, NULL, sizeof (struct localData), 0L))
    {
	cl->cl_Dispatcher.h_Entry = (ULONG (*)()) dispatch;
	cl->cl_UserData = (ULONG) txl;
	AddClass (cl);
    }
    return (cl);
}
@


39.12
log
@now handles NULL gadgetinfo
@
text
@d13 1
d17 1
a17 1
ULONG getdtattrs (struct TextLib * txl, Object * o, ULONG data,...)
d19 1
a19 1
    return (GetDTAttrsA (o, (struct TagItem *) & data));
d24 1
a24 1
ULONG setdtattrs (struct TextLib * txl, Object * o, ULONG data,...)
d26 1
a26 1
    return (SetDTAttrsA (o, NULL, NULL, (struct TagItem *) & data));
d31 1
a31 1
ULONG notifyAttrChanges (struct TextLib * txl, Object * o, VOID * ginfo, ULONG flags, ULONG tag1,...)
d38 2
a39 1
static struct TextAttr topaz = {"topaz.font", 8, NULL, NULL};
d43 1
a43 1
void PrepareFont (struct TextLib * txl, Object * o, struct localData * lod, struct TextAttr * tattr)
d112 1
a112 1
ULONG getTextDTAttr (struct TextLib * txl, Class * cl, Object * o, struct opGet * msg)
d264 1
a264 1
ULONG renderMethod (struct TextLib * txl, Class * cl, Object * o, struct gpRender * msg)
d308 2
d327 10
a336 10
        if (si->si_VisVert > si->si_TotVert)
        {
            lod->lod_UsefulHeight = UMult32 (si->si_TotVert, si->si_VertUnit);
            si->si_TopVert = 0;
        }
        else if (si->si_TopVert + si->si_VisVert > si->si_TotVert)
        {
            si->si_TopVert = (si->si_TotVert - si->si_VisVert);
            lod->lod_UsefulHeight = UMult32 ((si->si_TotVert - si->si_TopVert), si->si_VertUnit);
        }
d347 5
d360 2
a361 2
	    if ((box->Left < box->Left + box->Width)
		&& (box->Top + lod->lod_UsefulHeight < box->Top + box->Height))
d363 5
d379 1
a379 1
	    cw  = box->Width;
d383 1
d394 1
d415 1
a415 1
	      )
d497 3
a499 3
		    ax = sel->Left   - (si->si_TopHoriz * si->si_HorizUnit);
		    ay = sel->Top    - si->si_TopVert;
		    ex = sel->Width  - (si->si_TopHoriz * si->si_HorizUnit);
d517 1
a517 1
		tags[0].ti_Tag  = RPTAG_DrawBounds;
d519 1
a519 1
		tags[1].ti_Tag  = TAG_DONE;
d907 1
d923 1
a923 1
		NewList ((struct List *) & lod->lod_LineList);
d1044 1
a1044 1
		struct TagItem *attrs = ((struct opSet *)msg)->ops_AttrList;
d1058 1
a1058 1
		    SetMaxPen (&lod->lod_Clear,  mp);
d1114 3
a1116 3
		    gpr.MethodID   = GM_RENDER;
		    gpr.gpr_GInfo  = dts->dts_GInfo;
		    gpr.gpr_RPort  = rp;
d1142 1
a1142 2
	    /* See if we have just been added */
	    if (((struct gpLayout *) msg)->gpl_Initial)
d1144 6
a1149 2
		struct GadgetInfo *gi = ((struct gpLayout *) msg)->gpl_GInfo;
		UWORD *pens, pena[NUMDRIPENS+1];
d1159 3
a1161 2
		    lod->lod_Clear     = *rp;
		    lod->lod_Render    = *rp;
d1173 1
d1180 1
a1180 1
		lod->lod_Render.TmpRas    = &lod->lod_TmpRas;
d1182 1
a1182 1
		lod->lod_Clear.TmpRas     = &lod->lod_TmpRas;
a1194 6
	    }

	    lod->lod_Flags |= LODF_REDRAW;
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    FreeVec (lod->lod_Selected);
	    lod->lod_Selected = NULL;
d1196 4
a1199 3
	    /* Get the current size */
	    {
		struct IBox *box;
d1201 1
d1209 6
d1217 1
a1217 1
	    while (node = RemHead ((struct List *) & lod->lod_LineList))
a1248 1

@


39.11
log
@*** empty log message ***
@
text
@a15 15
Class *initClass (struct TextLib * txl)
{
    Class *cl;

    if (cl = MakeClass (TEXTDTCLASS, DATATYPESCLASS, NULL, sizeof (struct localData), 0L))
    {
	cl->cl_Dispatcher.h_Entry = Dispatch;
	cl->cl_UserData = (ULONG) txl;
	AddClass (cl);
    }
    return (cl);
}

/*****************************************************************************/

a79 315
ULONG ASM Dispatch (REG (a0) Class * cl, REG (a2) Object * o, REG (a1) Msg msg)
{
    struct DTSpecialInfo *si = (struct DTSpecialInfo *) G (o)->SpecialInfo;
    struct TextLib *txl = (struct TextLib *) cl->cl_UserData;
    struct localData *lod = INST_DATA (cl, o);
    struct RastPort *rp;
    struct gpRender gpr;
    struct Node *node;
    ULONG retval = 0L;
    Object *newobj;

    switch (msg->MethodID)
    {
	case OM_NEW:
	    if (newobj = (Object *) DoSuperMethodA (cl, o, msg))
	    {
		struct DataTypeHeader *dth;
		struct DataType *dtn;
		BOOL success = FALSE;
		STRPTR title;
		UWORD dtype;
		BPTR fh;

		lod = INST_DATA (cl, newobj);

		/* Show that we use scrollraster */
		EG (newobj)->MoreFlags |= GMORE_SCROLLRASTER;

		/* Initialize object data */
		NewList ((struct List *) & lod->lod_LineList);

		/* Establish defaults */
		lod->lod_WordDelim = delimArray;

		/* Prepare the font */
		PrepareFont (txl, newobj, lod, &topaz);

		/* Get the default title */
		title = (STRPTR) GetTagData (DTA_Name, NULL, ((struct opSet *) msg)->ops_AttrList);

		/* Get the handles */
		getdtattrs (txl, newobj,
			    DTA_Handle, (ULONG) & fh,
			    DTA_DataType, (ULONG) & dtn,
			    TAG_DONE);

		/* If there are no handles, then the source must be RAM */
		if ((dtn == NULL) && (fh == NULL))
		{
		    DB (kprintf ("raw mode\n"));
		    success = TRUE;
		}
		else if (dtn && fh)
		{
		    dth = dtn->dtn_Header;
		    dtype = dth->dth_Flags & DTF_TYPE_MASK;

		    if (dtype == DTF_IFF)
		    {
			struct IFFHandle *iff = (struct IFFHandle *) fh;
			struct StoredProperty *sp;
			struct ContextNode *cn;

			/* We want a name if there is one */
			PropChunk (iff, ID_FTXT, ID_NAME);

			/* IFF Handle is already opened for reading! */
			if (StopChunk (iff, ID_FTXT, ID_CHRS) == 0L)
			{
			    /* Parse the file, stopping at a character chunk */
			    if (ParseIFF (iff, IFFPARSE_SCAN) == 0)
			    {
				/* Get information on the current chunk */
				if ((cn = CurrentChunk (iff)) && (cn->cn_Size > 0L))
				{
				    lod->lod_BufferLen = cn->cn_Size;
				    if (lod->lod_Buffer = AllocVec (lod->lod_BufferLen + 1L, MEMF_CLEAR))
				    {
					if (ReadChunkBytes (iff, lod->lod_Buffer, lod->lod_BufferLen) == lod->lod_BufferLen)
					{
					    if (sp = FindProp (iff, ID_FTXT, ID_NAME))
						title = (STRPTR) sp->sp_Data;
					    success = TRUE;
					}
				    }
				}
			    }
			}
		    }
		    else if (dtype == DTF_MISC)
		    {
			if (fh)
			    success = TRUE;
		    }
		    else
		    {
			if (dtype == DTF_BINARY)
			{
			    DB (kprintf ("binary data, %s\n", dtn->dtn_Header->dth_Name));
			}

			if (Seek (fh, 0L, OFFSET_END) >= 0L)
			{
			    if ((lod->lod_BufferLen = Seek (fh, 0L, OFFSET_BEGINNING)) > 0L)
			    {
				if (lod->lod_Buffer = AllocVec (lod->lod_BufferLen + 1L, MEMF_CLEAR))
				{
				    if (Read (fh, lod->lod_Buffer, lod->lod_BufferLen) == lod->lod_BufferLen)
				    {
					success = TRUE;
				    }
				}
			    }
			}
		    }
		}

		if (success)
		{
		    if ((lod->lod_Region = NewRegion ()) == NULL)
			success = FALSE;
		}

		if (success)
		{
		    struct TagItem tags[2];

		    tags[0].ti_Tag = DTA_ObjName;
		    tags[0].ti_Data = (ULONG) title;
		    tags[1].ti_Tag = TAG_DONE;
		    DoSuperMethod (cl, newobj, OM_SET, tags, NULL);

		    setTextDTAttrs (txl, cl, newobj, (struct opSet *) msg);
		}
		else
		{
		    CoerceMethod (cl, newobj, OM_DISPOSE);
		    newobj = NULL;
		}
	    }

	    retval = (ULONG) newobj;
	    break;

	case OM_GET:
	    retval = getTextDTAttr (txl, cl, o, (struct opGet *) msg);
	    break;

	case OM_NOTIFY:
	    retval = DoSuperMethodA (cl, o, msg);
	    {
		struct TagItem *attrs = ((struct opSet *)msg)->ops_AttrList;
		struct Line *ln;
		UBYTE mp = 0;

		if (GetTagData (DTA_Sync, NULL, attrs))
		{
		    ln = (struct Line *) lod->lod_LineList.mlh_Head;
		    while (ln->ln_Link.mln_Succ)
		    {
			mp = (ln->ln_FgPen > mp) ? ln->ln_FgPen : mp;
			mp = (ln->ln_BgPen > mp) ? ln->ln_BgPen : mp;
			ln = (struct Line *) ln->ln_Link.mln_Succ;
		    }
		    SetMaxPen (&lod->lod_Render, mp);
		    SetMaxPen (&lod->lod_Clear,  mp);
		}
	    }
	    break;

	case OM_UPDATE:
	case OM_SET:
	    retval = DoSuperMethodA (cl, o, msg);
	    retval += setTextDTAttrs (txl, cl, o, (struct opSet *) msg);

	    if (retval && (OCLASS (o) == cl))
	    {
		/* Get a pointer to the rastport */
		if (rp = ObtainGIRPort (((struct opSet *) msg)->ops_GInfo))
		{
		    /* Force a redraw */
		    gpr.MethodID = GM_RENDER;
		    gpr.gpr_GInfo = ((struct opSet *) msg)->ops_GInfo;
		    gpr.gpr_RPort = rp;
		    gpr.gpr_Redraw = GREDRAW_UPDATE;
		    DR (kprintf ("  force %ld\n", GREDRAW_UPDATE));
		    DoMethodA (o, &gpr);

		    /* Release the temporary rastport */
		    ReleaseGIRPort (rp);
		}

		/* Clear the return value */
		retval = 0L;
	    }
	    break;

	case GM_RENDER:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    retval += renderMethod (txl, cl, o, (struct gpRender *) msg);
	    break;

	case GM_GOACTIVE:
	case GM_HANDLEINPUT:
	    retval = handleInput (txl, cl, o, (struct gpInput *) msg);
	    break;

	case GM_GOINACTIVE:
	    retval = goinactive (txl, cl, o, (struct gpInput *) msg);
	    break;

	case DTM_CLEARSELECTED:
	    ((struct DTSpecialInfo *) (G (o)->SpecialInfo))->si_Flags &= ~DTSIF_HIGHLIGHT;
	case DTM_SELECT:
	    {
		struct dtSelect *dts = (struct dtSelect *) msg;

		/* Get a pointer to the rastport */
		if (rp = ObtainGIRPort (dts->dts_GInfo))
		{
		    /* Toggle the currently selected line */
		    gpr.MethodID   = GM_RENDER;
		    gpr.gpr_GInfo  = dts->dts_GInfo;
		    gpr.gpr_RPort  = rp;
		    gpr.gpr_Redraw = GREDRAW_TOGGLE;
		    DoMethodA (o, &gpr);

		    /* Release the temporary rastport */
		    ReleaseGIRPort (rp);
		}
		/* Clear the return value */
		retval = 0L;
	    }
	    break;

	case DTM_PRINT:
	    retval = printMethod (txl, cl, o, (struct dtPrint *) msg);
	    break;

	case DTM_COPY:
	    retval = copyMethod (txl, cl, o, (struct dtGeneral *) msg);
	    break;

	case DTM_WRITE:
	    retval = writeMethod (txl, cl, o, (struct dtWrite *) msg);
	    break;

	case GM_LAYOUT:
	case DTM_PROCLAYOUT:
	    /* See if we have just been added */
	    if (((struct gpLayout *) msg)->gpl_Initial)
	    {
		struct GadgetInfo *gi = ((struct gpLayout *) msg)->gpl_GInfo;
		struct RastPort *rp = gi->gi_Window->RPort;

		/* Do initial cloning of rastports */
		lod->lod_Render = *rp;
		lod->lod_Highlight = *rp;
		lod->lod_Clear = *rp;

		lod->lod_Render.TmpRas = &lod->lod_TmpRas;
		lod->lod_Highlight.TmpRas = &lod->lod_TmpRas;
		lod->lod_Clear.TmpRas = &lod->lod_TmpRas;

		SetABPenDrMd (&lod->lod_Render, gi->gi_DrInfo->dri_Pens[TEXTPEN], gi->gi_DrInfo->dri_Pens[BACKGROUNDPEN], JAM2);
		SetFont (&lod->lod_Render, lod->lod_Font);
		SetWrMsk (&lod->lod_Render, 0xFF);

		SetABPenDrMd (&lod->lod_Clear, gi->gi_DrInfo->dri_Pens[BACKGROUNDPEN], gi->gi_DrInfo->dri_Pens[BACKGROUNDPEN], JAM2);
		SetFont (&lod->lod_Clear, lod->lod_Font);
		SetWrMsk (&lod->lod_Render, 0xFF);

		SetABPenDrMd (&lod->lod_Highlight, gi->gi_DrInfo->dri_Pens[FILLPEN], gi->gi_DrInfo->dri_Pens[BACKGROUNDPEN], COMPLEMENT);
		SetWrMsk (&lod->lod_Highlight, 0x1);
		SetFont (&lod->lod_Highlight, lod->lod_Font);
	    }

	    lod->lod_Flags |= LODF_REDRAW;
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    FreeVec (lod->lod_Selected);
	    lod->lod_Selected = NULL;

	    /* Get the current size */
	    {
		struct IBox *box;

		getdtattrs (txl, o, DTA_Domain, &box, TAG_DONE);
		lod->lod_Domain = *box;
		si->si_VisVert = UDivMod32 (box->Height, si->si_VertUnit);
		lod->lod_UsefulHeight = UMult32 (si->si_VisVert, si->si_VertUnit);
	    }
	    break;

	case OM_DISPOSE:
	    FreeVec (lod->lod_Buffer);
	    while (node = RemHead ((struct List *) & lod->lod_LineList))
		FreeVec (node);
	    if (lod->lod_Font)
		CloseFont (lod->lod_Font);
	    if (lod->lod_TmpPlane)
		FreeRaster (lod->lod_TmpPlane, lod->lod_TmpWidth, lod->lod_TmpHeight);
	    FreeVec (lod->lod_Selected);
	    DisposeRegion (lod->lod_Region);

	    /* Let the superclass handle everything else */
	default:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    break;
    }

    return (retval);
}

/*****************************************************************************/

a288 1

d293 1
a293 1
	return (0);
d874 352
@


39.10
log
@moved setting of GMORE_SCROLLRASTER flag to creation time instead of scroll time.
@
text
@a117 1
		si = (struct DTSpecialInfo *) G (newobj)->SpecialInfo;
d244 1
a262 1
	    retval = DoSuperMethodA (cl, o, msg);
d347 2
a348 1
		struct RastPort *rp = ((struct gpLayout *) msg)->gpl_GInfo->gi_Window->RPort;
d359 1
a359 1
		SetABPenDrMd (&lod->lod_Render, 1, 0, JAM2);
d363 1
a363 1
		SetABPenDrMd (&lod->lod_Clear, 0, 0, JAM2);
d367 1
a367 1
		SetABPenDrMd (&lod->lod_Highlight, ~0, 0, COMPLEMENT);
d600 1
a600 1
    struct Region *old_r = NULL;
a957 1
    struct PrinterExtendedData *ped;
a977 1
	ped = &pd->pd_SegmentData->ps_PED;
d1170 1
a1170 1
	    CloseClipboard ((struct ClipboardHandler *) iff->iff_Stream);
@


39.9
log
@removed extraneous LockLayerInfo()
@
text
@d121 3
a738 1
		EG (o)->MoreFlags |= GMORE_SCROLLRASTER;
a751 1
		EG (o)->MoreFlags |= GMORE_SCROLLRASTER;
a782 1
		EG (o)->MoreFlags |= GMORE_SCROLLRASTER;
a798 1
		EG (o)->MoreFlags |= GMORE_SCROLLRASTER;
@


39.8
log
@render speedup
@
text
@d715 1
d717 1
d939 1
d941 1
@


39.7
log
@improved scrolling speed.
@
text
@a32 1

a39 1

a46 1

d52 1
a52 2
static struct TextAttr topaz =
{"topaz.font", 8, NULL, NULL};
d212 6
d278 1
a278 1
		    DR (kprintf ("force %ld\n", GREDRAW_UPDATE));
d314 3
a316 3
		    gpr.MethodID = GM_RENDER;
		    gpr.gpr_GInfo = dts->dts_GInfo;
		    gpr.gpr_RPort = rp;
d341 1
d356 1
a356 2
		SetDrMd (&lod->lod_Render, JAM2);
		SetAPen (&lod->lod_Render, 1);
d360 1
a360 2
		SetDrMd (&lod->lod_Clear, JAM2);
		SetAPen (&lod->lod_Clear, 0);
d364 1
a364 2
		SetDrMd (&lod->lod_Highlight, COMPLEMENT);
		SetAPen (&lod->lod_Highlight, ~0);
d368 1
a368 1
	case DTM_PROCLAYOUT:
d373 10
d394 1
d529 5
d542 18
a596 1
    struct Region *new_r = NULL;
a597 1
    struct TagItem tags[3];
a598 1
    BOOL refresh = FALSE;
a599 1
    BOOL total = FALSE;
a603 1
    ULONG usefulh;
d615 1
a615 1
    DR (kprintf ("text renderMethod %ld\n", redraw));
d620 1
a620 1
	DR (kprintf (" layout\n"));
d626 1
a626 1
	DR (kprintf (" lodf_redraw\n"));
d631 2
a632 1
    getdtattrs (txl, o, DTA_Domain, &box, DTA_SelectDomain, &sel, TAG_DONE);
d637 1
a637 3
    /*
     * The ONLY way we can get a toggle method is if we were highlighted and we want to turn it off
     */
d640 1
a640 1
	DR (kprintf (" toggle\n"));
a643 1
	    getdtattrs (txl, o, DTA_SelectDomain, &sel, TAG_DONE);
d651 11
a661 1
	si->si_VisVert = UDivMod32 (box->Height, si->si_VertUnit);
a662 15
	if (si->si_VisVert > si->si_TotVert)
	{
	    usefulh = UMult32 (si->si_TotVert, si->si_VertUnit);
	    si->si_TopVert = 0;
	}
	else if (si->si_TopVert + si->si_VisVert > si->si_TotVert)
	{
	    si->si_TopVert = (si->si_TotVert - si->si_VisVert);
	    usefulh = UMult32 ((si->si_TotVert - si->si_TopVert), si->si_VertUnit);
	}
	else
	{
	    usefulh = UMult32 (si->si_VisVert, si->si_VertUnit);
	}

d666 2
a667 1
	    DR (kprintf (" redraw\n"));
d669 1
a669 1
	    if (usefulh)
d675 1
a675 1
			  box->Top + usefulh - 1);
d680 1
a680 1
		&& (box->Top + usefulh < box->Top + box->Height))
d684 1
a684 1
			  box->Top + usefulh,
d691 1
a691 1
	if (usefulh && box->Width)
d693 3
d697 1
a698 3
	    i = si->si_TopVert;
	    cw = box->Width;
	    cox = 0;
d709 6
d718 1
a727 2
		x = box->Left - (si->si_TopHoriz * si->si_HorizUnit);
		y = box->Top + lod->lod_Font->tf_Baseline;
a729 1
		total = TRUE;
d740 1
a740 1
				box->Top + usefulh - 1);
a742 2
		x = box->Left - (si->si_TopHoriz * si->si_HorizUnit);
		y = box->Top + lod->lod_Font->tf_Baseline;
d754 1
a754 1
				box->Top + usefulh - 1);
d768 1
a768 2
		x = box->Left - (si->si_TopHoriz * si->si_HorizUnit);
		y = box->Top + lod->lod_Font->tf_Baseline + UMult32 (si->si_VertUnit, (si->si_VisVert - (si->si_TopVert - si->si_OTopVert)));
a774 2
		x = (LONG) box->Left - (si->si_TopHoriz * si->si_HorizUnit);
		y = (LONG) (box->Top + lod->lod_Font->tf_Baseline);
d786 1
a786 1
				box->Top + usefulh - 1);
a790 2
		x = (LONG) box->Left - (si->si_TopHoriz * si->si_HorizUnit);
		y = (LONG) (box->Top + lod->lod_Font->tf_Baseline);
d803 1
a803 1
				box->Top + usefulh - 1);
d811 3
a813 3
		    ax = sel->Left - (si->si_TopHoriz * si->si_HorizUnit);
		    ay = sel->Top - si->si_TopVert;
		    ex = sel->Width - (si->si_TopHoriz * si->si_HorizUnit);
d817 11
a827 17
		/* SET UP CLIPPING REGION HERE */
		if (new_r = NewRegion ())
		{
		    /* Set up the rectangle */
		    rect.MinX = box->Left + cox;
		    rect.MinY = box->Top;
		    rect.MaxX = rect.MinX + cw - 1;
		    rect.MaxY = rect.MinY + usefulh - 1;

		    OrRectRegion (new_r, &rect);
		    if (win->Flags & WINDOWREFRESH)
		    {
			EndRefresh (win, FALSE);
			refresh = TRUE;
		    }
		    old_r = InstallClipRegion (l, new_r);
		}
d829 2
a834 1

d836 1
d842 1
d856 1
a856 1
			if (total && (lx < (x + line->ln_XOffset)))
a870 9
			    if (total && (lod->lod_Render.cp_x < box->Left + box->Width))
			    {
				RectFill (&lod->lod_Clear,
					  lod->lod_Render.cp_x,
					  y - lod->lod_Render.TxBaseline,
					  box->Left + box->Width - 1,
					  y - lod->lod_Render.TxBaseline + si->si_VertUnit - 1);
			    }

d927 6
a932 8
		/* REMOVE THE CLIPPING REGION */
		if (new_r)
		{
		    InstallClipRegion (l, old_r);
		    if (refresh)
			BeginRefresh (win);
		    DisposeRegion (new_r);
		}
d935 1
d946 1
a946 1
    DR (kprintf (" done\n"));
@


39.6
log
@supports DTST_RAM
@
text
@d7 1
d9 1
a9 2
#define	NOBACKFILL	FALSE
#define	SRASTER		TRUE
d55 2
a56 1
static struct TextAttr topaz = {"topaz.font", 8, NULL, NULL};
d193 5
d239 22
d276 1
d339 29
d527 1
a527 1
VOID RenderLine (struct TextLib * txl, struct localData * lod, UWORD x, UWORD y, STRPTR text, ULONG len)
d533 6
d562 1
a574 1
    BOOL damage;
d576 1
a576 2
    BYTE fgpen;
    BYTE bgpen;
d583 4
a586 1
    DR (kprintf ("text renderMethod\n"));
d597 1
d599 1
a599 1
	msg->gpr_Redraw = GREDRAW_REDRAW;
d604 2
a605 3
    lod->lod_Render = *msg->gpr_RPort;
    lod->lod_Highlight = *msg->gpr_RPort;
    lod->lod_Clear = *msg->gpr_RPort;
a606 9
    lod->lod_Render.TmpRas = &lod->lod_TmpRas;
    lod->lod_Highlight.TmpRas = &lod->lod_TmpRas;
    lod->lod_Clear.TmpRas = &lod->lod_TmpRas;

    SetDrMd (&lod->lod_Highlight, COMPLEMENT);
    SetAPen (&lod->lod_Highlight, ~0);
    lod->lod_Highlight.Mask = 0x1;
    SetFont (&lod->lod_Highlight, lod->lod_Font);

d610 1
a610 1
    if (msg->gpr_Redraw == GREDRAW_TOGGLE)
a623 15
	SetDrMd (&lod->lod_Render, JAM2);
	SetAPen (&lod->lod_Render, 1);
	SetFont (&lod->lod_Render, lod->lod_Font);
	lod->lod_Render.Mask = -1;

	SetDrMd (&lod->lod_Clear, JAM2);
	SetAPen (&lod->lod_Clear, 0);
	SetFont (&lod->lod_Clear, lod->lod_Font);
	lod->lod_Clear.Mask = -1;

	tags[0].ti_Tag = RPTAG_DrawBounds;
	tags[0].ti_Data = (ULONG) & rect;
	tags[1].ti_Tag = TAG_DONE;
	GetRPAttrsA (msg->gpr_RPort, tags);

d642 1
a642 1
	if (msg->gpr_Redraw == GREDRAW_REDRAW)
a684 1
#if NOBACKFILL
a686 2
	    damage = LAYERREFRESH & l->Flags;
#endif
d688 1
a688 1
	    if ((msg->gpr_Redraw == GREDRAW_REDRAW)
a705 1
#if SRASTER
a706 1
#endif
a721 1
#if SRASTER
a722 1
#endif
a756 1
#if SRASTER
a757 1
#endif
a775 1
#if SRASTER
a776 1
#endif
a784 1
#if SRASTER
a785 10
#else
	    if (!damage && (LAYERREFRESH & l->Flags))
	    {
		BeginRefresh (win);
		msg->MethodID = GREDRAW_REDRAW;
		renderMethod (txl, cl, o, msg);
		EndRefresh (win, TRUE);
	    }
	    else if (i)
#endif
a786 3
		WORD ax, ay;
		WORD ex, ey;

a795 5
		/* Make sure all the attributes are properly set. */
		SetAPen (&lod->lod_Render, fgpen = line->ln_FgPen);
		SetBPen (&lod->lod_Render, bgpen = line->ln_BgPen);
		SetSoftStyle (&lod->lod_Render, style = line->ln_Style, 0xFF);

d814 10
d828 5
a832 15
		    if (fgpen != line->ln_FgPen)
			SetAPen (&lod->lod_Render, fgpen = line->ln_FgPen);
		    if (bgpen != line->ln_BgPen)
			SetBPen (&lod->lod_Render, bgpen = line->ln_BgPen);
		    if (style != line->ln_Style)
			SetSoftStyle (&lod->lod_Render, style = line->ln_Style, 0xFF);

		    if (total && (lx < (x + line->ln_XOffset)))
		    {
			RectFill (&lod->lod_Clear,
				  lx, y - lod->lod_Render.TxBaseline,
				  x + line->ln_XOffset, y - lod->lod_Render.TxBaseline + si->si_VertUnit - 1);
		    }

		    if (x + line->ln_XOffset < box->Left + box->Width)
d834 3
a836 3
			RenderLine (txl, lod, x + line->ln_XOffset, y, line->ln_Text, line->ln_TextLen);
			lx = lod->lod_Render.cp_x;
		    }
d838 1
a838 3
		    if (line->ln_Flags & LNF_LF)
		    {
			if (total && (lod->lod_Render.cp_x < box->Left + box->Width))
d841 2
a842 4
				      lod->lod_Render.cp_x,
				      y - lod->lod_Render.TxBaseline,
				      box->Left + box->Width - 1,
				      y - lod->lod_Render.TxBaseline + si->si_VertUnit - 1);
d845 1
a845 2
			/* Handle selected lines */
			if (sel && (curline >= ay) && (curline <= ey))
d847 7
a853 9
			    if (ay == ey)
			    {
				RectFill (&lod->lod_Highlight,
					  box->Left + ax,
					  y - lod->lod_Render.TxBaseline,
					  box->Left + ex,
					  y - lod->lod_Render.TxBaseline + si->si_VertUnit - 1);
			    }
			    else if (curline == ay)
d855 2
a856 2
				RectFill (&lod->lod_Highlight,
					  box->Left + ax,
d861 3
a863 1
			    else if (curline == ey)
d865 32
a896 5
				RectFill (&lod->lod_Highlight,
					  box->Left,
					  y - lod->lod_Render.TxBaseline,
					  box->Left + ex,
					  y - lod->lod_Render.TxBaseline + si->si_VertUnit - 1);
d898 14
a911 8
			    else
			    {
				RectFill (&lod->lod_Highlight,
					  box->Left,
					  y - lod->lod_Render.TxBaseline,
					  box->Left + box->Width - 1,
					  y - lod->lod_Render.TxBaseline + si->si_VertUnit - 1);
			    }
a912 5

			y += si->si_VertUnit;
			curline++;
			lx = x;
			i--;
a927 1
#if NOBACKFILL
a929 1
#endif
@


39.5
log
@*** empty log message ***
@
text
@d12 1
d64 14
a77 1
    GetAttr (DTA_Domain, o, (ULONG *) & box);
d79 9
a87 24
    if (lod->lod_Font)
    {
	CloseFont (lod->lod_Font);

	if (lod->lod_TmpPlane)
	{
	    FreeRaster (lod->lod_TmpPlane, lod->lod_TmpWidth, lod->lod_TmpHeight);
	}
    }

    lod->lod_TextAttr = tattr;
    if (!(lod->lod_Font = OpenFont (lod->lod_TextAttr)))
	lod->lod_Font = OpenFont (&topaz);

    si->si_VertUnit = lod->lod_TmpHeight = lod->lod_Font->tf_YSize;
    si->si_HorizUnit = (lod->lod_Font->tf_Flags & FPF_PROPORTIONAL) ? 1L : lod->lod_Font->tf_XSize;

    lod->lod_TmpWidth = box->Width;
    if (!box->Width)
	lod->lod_TmpWidth = lod->lod_Font->tf_XSize * 80;

    if (lod->lod_TmpPlane = AllocRaster (lod->lod_TmpWidth, lod->lod_TmpHeight))
    {
	InitTmpRas (&lod->lod_TmpRas, lod->lod_TmpPlane, RASSIZE (lod->lod_TmpWidth, lod->lod_TmpHeight));
d138 2
a139 2
			    DTA_Handle, (ULONG) &fh,
			    DTA_DataType, (ULONG) &dtn,
d212 1
a212 1
		    tags[0].ti_Tag  = DTA_ObjName;
d214 1
a214 1
		    tags[1].ti_Tag  = TAG_DONE;
d398 4
d434 18
d520 2
d525 1
d555 1
d602 1
d671 5
a675 5
				    0, -(LONG) UMult32 ((si->si_OTopVert - si->si_TopVert), si->si_VertUnit),
				    box->Left,
				    box->Top,
				    box->Left + box->Width - 1,
				    box->Top + usefulh - 1);
d689 5
a693 5
				    0, UMult32 ((si->si_TopVert - si->si_OTopVert), si->si_VertUnit),
				    box->Left,
				    box->Top,
				    box->Left + box->Width - 1,
				    box->Top + usefulh - 1);
d726 5
a730 5
				    -(j), 0,
				    box->Left,
				    box->Top,
				    box->Left + box->Width - 1,
				    box->Top + usefulh - 1);
d747 5
a751 5
				    j, 0,
				    box->Left,
				    box->Top,
				    box->Left + box->Width - 1,
				    box->Top + usefulh - 1);
d905 1
@


39.4
log
@cleaned up block selection
@
text
@d1 3
a3 2
/* dispatch.c
 * dispatcher routine for the text class
d8 5
d131 4
d137 1
d139 2
a140 2
			    DTA_Handle, (ULONG) & fh,
			    DTA_DataType, (ULONG) & dtn,
d143 7
a149 1
		if (dtn && fh)
a153 2
		    PrepareFont (txl, newobj, lod, &topaz);

d213 1
a213 1
		    tags[0].ti_Tag = DTA_ObjName;
d215 1
a215 1
		    tags[1].ti_Tag = TAG_DONE;
d322 4
a325 2
	    CloseFont (lod->lod_Font);
	    FreeRaster (lod->lod_TmpPlane, lod->lod_TmpWidth, lod->lod_TmpHeight);
d476 1
d482 1
d489 1
d531 8
a538 4
	si->si_Flags |= DTSIF_HIGHLIGHT;
	getdtattrs (txl, o, DTA_SelectDomain, &sel, TAG_DONE);
	si->si_Flags &= ~DTSIF_HIGHLIGHT;
	DrawBox (txl, cl, o, &lod->lod_Highlight, box, sel, DBS_DOWN);
d617 6
d632 1
a632 1
		x = box->Left - si->si_TopHoriz;
d641 1
d643 2
a644 1
		ScrollWindowRaster (gi->gi_Window,
d652 1
a652 1
		x = box->Left - si->si_TopHoriz;
d659 1
d661 2
a662 1
		ScrollWindowRaster (gi->gi_Window,
d681 1
a681 1
		x = box->Left - si->si_TopHoriz;
d689 1
a689 1
		x = (LONG) box->Left - si->si_TopHoriz;
d691 1
a691 1
		j = si->si_OTopHoriz - si->si_TopHoriz;
d696 1
d698 2
a699 1
		ScrollWindowRaster (gi->gi_Window,
d709 1
a709 1
		x = (LONG) box->Left - si->si_TopHoriz;
d711 1
a711 1
		j = si->si_TopHoriz - si->si_OTopHoriz;
d717 1
d719 2
a720 1
		ScrollWindowRaster (gi->gi_Window,
d728 4
a731 1
	    if (i)
d733 8
d747 1
a747 1
		    ax = sel->Left - si->si_TopHoriz;
d749 1
a749 1
		    ex = sel->Width - si->si_TopHoriz;
d773 1
a773 1
		    old_r = InstallClipRegion (msg->gpr_RPort->Layer, new_r);
d860 1
a860 1
		    InstallClipRegion (msg->gpr_RPort->Layer, old_r);
d866 5
@


39.3
log
@Got rid of double-refresh
@
text
@a8 27
#define	DB(x)	x

/*****************************************************************************/

struct localData
{
    struct TextAttr	*lod_TextAttr;
    STRPTR		 lod_Buffer;
    ULONG		 lod_BufferLen;
    struct MinList	 lod_LineList;

    struct TextFont	*lod_Font;
    ULONG		 lod_Flags;

    /* Temporary Display Information */
    struct RastPort	 lod_Render;
    struct RastPort	 lod_Clear;
    struct TmpRas	 lod_TmpRas;
    PLANEPTR		 lod_TmpPlane;
    UWORD		 lod_Width, lod_Height;
    UBYTE		 lod_WordBuffer[128];
};

#define	LODF_REDRAW	(1L<<0)

/*****************************************************************************/

d16 1
a16 1
	cl->cl_UserData           = (ULONG) txl;
d26 1
d32 8
d42 1
d65 1
a65 1
	    FreeRaster (lod->lod_TmpPlane, lod->lod_Width, lod->lod_Height);
d73 2
a74 2
    si->si_VertUnit = lod->lod_Height = lod->lod_Font->tf_YSize;
    si->si_HorizUnit = (lod->lod_Font->tf_Flags & FPF_PROPORTIONAL) ? 0 : lod->lod_Font->tf_XSize;
d76 1
a76 1
    lod->lod_Width = box->Width;
d78 1
a78 1
	lod->lod_Width = lod->lod_Font->tf_XSize * 80;
d80 1
a80 1
    if (lod->lod_TmpPlane = AllocRaster (lod->lod_Width, lod->lod_Height))
d82 1
a82 1
	InitTmpRas (&lod->lod_TmpRas, lod->lod_TmpPlane, RASSIZE (lod->lod_Width, lod->lod_Height));
d88 5
d95 1
d98 2
a99 1
    struct DTSpecialInfo *si;
d118 2
d122 3
d198 1
a198 1
		    tags[0].ti_Tag  = DTA_ObjName;
d200 1
a200 1
		    tags[1].ti_Tag  = TAG_DONE;
a225 2
		struct RastPort *rp;

a228 2
		    struct gpRender gpr;

d230 3
a232 3
		    gpr.MethodID   = GM_RENDER;
		    gpr.gpr_GInfo  = ((struct opSet *) msg)->ops_GInfo;
		    gpr.gpr_RPort  = rp;
d250 33
d296 1
d299 2
d308 2
a309 1
	    FreeRaster (lod->lod_TmpPlane, lod->lod_Width, lod->lod_Height);
d337 5
d410 4
d433 4
a436 2
    Move (&lod->lod_Render, x, y);	/* move the cursor to the position */
    Text (&lod->lod_Render, text, len);	/* write to the window             */
d467 2
d491 1
a491 1
    GetAttr (DTA_Domain, o, (ULONG *) & box);
d494 1
d498 1
d501 4
a504 4
    SetDrMd (&lod->lod_Render, JAM2);
    SetAPen (&lod->lod_Render, 1);
    SetFont (&lod->lod_Render, lod->lod_Font);
    lod->lod_Render.Mask = -1;
d506 9
a514 25
    SetDrMd (&lod->lod_Clear, JAM2);
    SetAPen (&lod->lod_Clear, 0);
    SetFont (&lod->lod_Clear, lod->lod_Font);
    lod->lod_Clear.Mask = -1;

#if 0
    tags[0].ti_Tag  = RPTAG_DrawBounds;
    tags[0].ti_Data = (ULONG) &rect;
    tags[1].ti_Tag  = TAG_DONE;
    DB (kprintf ("GetRPAttrsA rp=0x%lx\n", msg->gpr_RPort));
    GetRPAttrsA (msg->gpr_RPort, tags);
    DB (kprintf ("%ld,%ld,%ld,%ld\n", (LONG) rect.MinX, (LONG) rect.MinY, (LONG) rect.MaxX, (LONG) rect.MaxY));
#endif

    si->si_VisVert = UDivMod32 (box->Height, si->si_VertUnit);

    if (si->si_VisVert > si->si_TotVert)
    {
	usefulh = UMult32 (si->si_TotVert, si->si_VertUnit);
	si->si_TopVert = 0;
    }
    else if (si->si_TopVert + si->si_VisVert > si->si_TotVert)
    {
	si->si_TopVert = (si->si_TotVert - si->si_VisVert);
	usefulh = UMult32 ((si->si_TotVert - si->si_TopVert), si->si_VertUnit);
d518 4
a521 2
	usefulh = UMult32 (si->si_VisVert, si->si_VertUnit);
    }
d523 23
a545 34
    /* if we were called because of damage, we must erase any left over garbage */
    if (msg->gpr_Redraw == GREDRAW_REDRAW)
    {
	/* erase anything left over on the right side of the window */
	if (usefulh)
	{
	    RectFill (&lod->lod_Clear,
		      box->Left,
		      box->Top,
		      box->Left + box->Width - 1,
		      box->Top + usefulh - 1);
	}

	/* erase anything left over on the bottom of the window */
	if ((box->Left < box->Left + box->Width)
	    && (box->Top + usefulh < box->Top + box->Height))
	{
	    RectFill (&lod->lod_Clear,
		      box->Left,
		      box->Top + usefulh,
		      box->Left + box->Width - 1,
		      box->Top + box->Height - 1);
	}
    }

    /* if we at least one line and one column to render in... */
    if (usefulh && box->Width)
    {
	/* get a pointer to the first line currently visible */
	line = (struct Line *) lod->lod_LineList.mlh_Head;
	i = si->si_TopVert;
	cw = box->Width;
	cox = 0;
	while (line->ln_Link.mln_Succ && i)
d547 1
a547 3
	    if (line->ln_Flags & LNF_LF)
		i--;
	    line = (struct Line *) line->ln_Link.mln_Succ;
d550 33
a582 47
	/* Default to no drawing */
	i = j = 0;

	if ((msg->gpr_Redraw == GREDRAW_REDRAW)
	    || (si->si_TopVert >= si->si_OTopVert + si->si_VisVert - 1)
	    || ((si->si_OTopVert > si->si_VisVert) && (si->si_TopVert <= si->si_OTopVert - si->si_VisVert + 1))
	    || (si->si_TopHoriz >= si->si_OTopHoriz + si->si_VisHoriz - 1)
	    || ((si->si_OTopHoriz > si->si_VisHoriz) && (si->si_TopHoriz <= si->si_OTopHoriz - si->si_VisHoriz + 1))
	    || ((si->si_TopHoriz != si->si_OTopHoriz) && (si->si_TopVert != si->si_OTopVert))
	   )
	{
	    /* the whole display must be redrawn */
	    x = box->Left - si->si_TopHoriz;
	    y = box->Top + lod->lod_Font->tf_Baseline;
	    i = si->si_VisVert;
	    j = si->si_VisHoriz;
	    total = TRUE;
	}
	else if (si->si_TopVert < si->si_OTopVert)
	{
	    /* we just need to scroll the text */
	    EG (o)->MoreFlags |= GMORE_SCROLLRASTER;
	    ScrollWindowRaster (gi->gi_Window,
				0, -(LONG) UMult32 ((si->si_OTopVert - si->si_TopVert), si->si_VertUnit),
				box->Left,
				box->Top,
				box->Left + box->Width - 1,
				box->Top + usefulh - 1);

	    /* indicates what section needs to be redrawn */
	    x = box->Left - si->si_TopHoriz;
	    y = box->Top + lod->lod_Font->tf_Baseline;
	    i = si->si_OTopVert - si->si_TopVert;
	}
	else if (si->si_TopVert > si->si_OTopVert)
	{
	    /* we just need to scroll the text */
	    EG (o)->MoreFlags |= GMORE_SCROLLRASTER;
	    ScrollWindowRaster (gi->gi_Window,
				0, UMult32 ((si->si_TopVert - si->si_OTopVert), si->si_VertUnit),
				box->Left,
				box->Top,
				box->Left + box->Width - 1,
				box->Top + usefulh - 1);

	    /* indicates what section needs to be redrawn */
	    i = si->si_VisVert - (si->si_TopVert - si->si_OTopVert);
d590 2
a591 67
	    x = box->Left - si->si_TopHoriz;
	    y = box->Top + lod->lod_Font->tf_Baseline + UMult32 (si->si_VertUnit, (si->si_VisVert - (si->si_TopVert - si->si_OTopVert)));
	    i = si->si_TopVert - si->si_OTopVert;
	}
        /* HORIZONTAL */
        else if (si->si_TopHoriz < si->si_OTopHoriz)
        {
            /* indicates what section needs to be redrawn */
            x = (LONG) box->Left - si->si_TopHoriz;
            y = (LONG) (box->Top + lod->lod_Font->tf_Baseline);
            j = si->si_OTopHoriz - si->si_TopHoriz;
            i = si->si_VisVert;
            cw = (WORD) j;

            /* we just need to scroll the text */
            EG(o)->MoreFlags |= GMORE_SCROLLRASTER;
            ScrollWindowRaster (gi->gi_Window,
                                -(j), 0,
                                box->Left,
                                box->Top,
                                box->Left + box->Width - 1,
                                box->Top + usefulh - 1);
        }
        else if (si->si_TopHoriz > si->si_OTopHoriz)
        {
            /* indicates what section needs to be redrawn */
            x = (LONG) box->Left - si->si_TopHoriz;
            y = (LONG) (box->Top + lod->lod_Font->tf_Baseline);
            j = si->si_TopHoriz - si->si_OTopHoriz;
            i = si->si_VisVert;
            cw = (WORD) j;
            cox = box->Width - cw;

            /* we just need to scroll the text */
            EG(o)->MoreFlags |= GMORE_SCROLLRASTER;
            ScrollWindowRaster (gi->gi_Window,
                                j, 0,
                                box->Left,
                                box->Top,
                                box->Left + box->Width - 1,
                                box->Top + usefulh - 1);
        }

	if (i)
	{
	    /* Make sure all the attributes are properly set. */
	    SetAPen (&lod->lod_Render, fgpen = line->ln_FgPen);
	    SetBPen (&lod->lod_Render, bgpen = line->ln_BgPen);
	    SetSoftStyle (&lod->lod_Render, style = line->ln_Style, 0xFF);

	    /* SET UP CLIPPING REGION HERE */
	    if (new_r = NewRegion ())
	    {
		/* Set up the rectangle */
		rect.MinX = box->Left + cox;
		rect.MinY = box->Top;
		rect.MaxX = rect.MinX + cw - 1;
		rect.MaxY = rect.MinY + usefulh - 1;

		OrRectRegion (new_r, &rect);
		if (win->Flags & WINDOWREFRESH)
		{
		    EndRefresh (win, FALSE);
		    refresh = TRUE;
		}
		old_r = InstallClipRegion (msg->gpr_RPort->Layer, new_r);
	    }
d593 45
a637 19
	    /* render all the lines we need */
	    lx = x;
	    while (line->ln_Link.mln_Succ && i)
	    {
		if (fgpen != line->ln_FgPen)
		    SetAPen (&lod->lod_Render, fgpen = line->ln_FgPen);
		if (bgpen != line->ln_BgPen)
		    SetBPen (&lod->lod_Render, bgpen = line->ln_BgPen);
		if (style != line->ln_Style)
		    SetSoftStyle (&lod->lod_Render, style = line->ln_Style, 0xFF);

		if (total && (lx < (x + line->ln_XOffset)))
		{
		    RectFill (&lod->lod_Clear,
			      lx, y - lod->lod_Render.TxBaseline,
			      x + line->ln_XOffset, y - lod->lod_Render.TxBaseline + si->si_VertUnit - 1);
		}

		if (x + line->ln_XOffset < box->Left + box->Width)
d639 86
a724 2
		    RenderLine (txl, lod, x + line->ln_XOffset, y, line->ln_Text, line->ln_TextLen);
		    lx = lod->lod_Render.cp_x;
d727 12
a738 3
		if (line->ln_Flags & LNF_LF)
		{
		    if (total && (lod->lod_Render.cp_x < box->Left + box->Width))
d741 62
a802 4
				  lod->lod_Render.cp_x,
				  y - lod->lod_Render.TxBaseline,
				  box->Left + box->Width - 1,
				  y - lod->lod_Render.TxBaseline + si->si_VertUnit - 1);
d805 1
a805 3
		    lx = x;
		    y += si->si_VertUnit;
		    i--;
d807 11
a817 2
		line = (struct Line *) line->ln_Link.mln_Succ;
	    }
d819 2
a820 9
	    /* REMOVE THE CLIPPING REGION */
	    if (new_r)
	    {
		InstallClipRegion (msg->gpr_RPort->Layer, old_r);
		if (refresh)
		    BeginRefresh (win);
		DisposeRegion (new_r);
	    }
	}
a822 3
    si->si_OTopVert  = si->si_TopVert;
    si->si_OTopHoriz = si->si_TopHoriz;

d962 1
a962 1
BOOL writeObject (struct TextLib * txl, struct IFFHandle * iff, Object * o, struct localData * lod)
d964 2
d973 1
a973 1
	if (OpenIFF (iff, IFFF_WRITE) == 0)
d975 1
a975 1
	    if (PushChunk (iff, ID_FTXT, ID_FORM, IFFSIZE_UNKNOWN) == 0)
d977 45
a1021 7
		if (PushChunk (iff, 0, ID_CHRS, lod->lod_BufferLen) == 0)
		    if (WriteChunkBytes (iff, lod->lod_Buffer, lod->lod_BufferLen) == lod->lod_BufferLen)
			if (PopChunk (iff) == 0)
			    success = TRUE;
		PopChunk (iff);
	    }
	    CloseIFF (iff);
d1023 2
d1027 3
a1037 1
    struct GadgetInfo *gi = msg->dtg_GInfo;
d1046 1
a1046 1
	    success = writeObject (txl, iff, o, lod);
a1051 6

    if (success)
	DoMethod (o, DTM_CLEARSELECTED, gi);
    else
	DisplayBeep (NULL);

a1059 1
    struct GadgetInfo *gi = msg->dtw_GInfo;
d1070 1
a1070 1
		success = writeObject (txl, iff, o, lod);
d1077 1
a1077 4
	if (Write (msg->dtw_FileHandle, lod->lod_Buffer, lod->lod_BufferLen) == lod->lod_BufferLen)
	    success = TRUE;
	else
	    success = FALSE;
a1078 5

    if (success)
	DoMethod (o, DTM_CLEARSELECTED, gi);
    else
	DisplayBeep (NULL);
@


39.2
log
@added support DTA_Methods
@
text
@d9 1
a9 2
#define	DB(x)	;
#define	DP(x)	;
d108 1
a109 1
    struct localData *lod;
d203 1
a203 1
		    tags[0].ti_Tag = DTA_ObjName;
d205 1
a205 1
		    tags[1].ti_Tag = TAG_DONE;
d228 1
d239 4
a242 6
		    gpr.MethodID = GM_RENDER;
		    gpr.gpr_GInfo = ((struct opSet *) msg)->ops_GInfo;
		    gpr.gpr_RPort = rp;
		    gpr.gpr_Redraw = GREDRAW_UPDATE;	/* REDRAW; */

		    /* Redraw... */
d271 5
a276 1
	    lod = INST_DATA (cl, o);
d379 4
d422 1
d469 5
a473 4
    tags[0].ti_Tag = RPTAG_DrawBounds;
    tags[0].ti_Data = (ULONG) & rect;
    tags[1].ti_Tag = TAG_DONE;
    GetRPAttrsA (rp, tags);
a840 1
	DP (kprintf ("print complete : break=%ld, status=%ld\n", bsig, pstatus));
@


39.1
log
@didn't change!
@
text
@d292 24
d323 5
a327 1
	case TDTA_TextAttr:
d331 1
a331 1
	case TDTA_TextFont:
@


39.0
log
@initial RCS
@
text
@a36 6
#define	ID_FTXT		MAKE_ID('F','T','X','T')
#define	ID_CHRS		MAKE_ID('C','H','R','S')
#define	ID_NAME		MAKE_ID('N','A','M','E')

/*****************************************************************************/

@
