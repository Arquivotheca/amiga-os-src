head     38.19;
branch   ;
access   ;
symbols  ;
locks    davidj:38.19; strict;
comment  @ * @;


38.19
date     93.04.29.11.17.23;  author davidj;  state Exp;
branches ;
next     38.18;

38.18
date     93.01.25.14.38.12;  author davidj;  state Exp;
branches ;
next     38.17;

38.17
date     92.08.27.16.00.43;  author davidj;  state Exp;
branches ;
next     38.16;

38.16
date     92.08.03.16.52.30;  author davidj;  state Exp;
branches ;
next     38.15;

38.15
date     92.07.31.17.50.48;  author davidj;  state Exp;
branches ;
next     38.14;

38.14
date     92.07.29.11.13.10;  author davidj;  state Exp;
branches ;
next     38.13;

38.13
date     92.07.09.22.32.26;  author davidj;  state Exp;
branches ;
next     38.12;

38.12
date     92.06.24.17.31.40;  author davidj;  state Exp;
branches ;
next     38.11;

38.11
date     92.06.24.02.09.59;  author davidj;  state Exp;
branches ;
next     38.10;

38.10
date     92.06.08.23.26.21;  author davidj;  state Exp;
branches ;
next     38.9;

38.9
date     92.03.17.16.04.01;  author davidj;  state Exp;
branches ;
next     38.8;

38.8
date     92.03.10.14.44.03;  author davidj;  state Exp;
branches ;
next     38.7;

38.7
date     92.03.04.11.53.54;  author davidj;  state Exp;
branches ;
next     38.6;

38.6
date     92.01.23.12.55.09;  author davidj;  state Exp;
branches ;
next     38.5;

38.5
date     92.01.22.17.09.40;  author davidj;  state Exp;
branches ;
next     38.4;

38.4
date     91.11.26.14.01.52;  author davidj;  state Exp;
branches ;
next     38.3;

38.3
date     91.11.15.21.03.00;  author Unknown;  state Exp;
branches ;
next     38.2;

38.2
date     91.11.12.22.00.11;  author Unknown;  state Exp;
branches ;
next     38.1;

38.1
date     91.11.11.08.53.00;  author davidj;  state Exp;
branches ;
next     ;


desc
@main functions
@


38.19
log
@change monitor check to always be the Workbench screen
@
text
@/* pe_custom.c
 * Pointer Preference Editor
 */

#include "pointer.h"
#include <intuition/pointerclass.h>

#define	DB(x)	;
#define	DV(x)	;
#define	DR(x)	;

/*****************************************************************************/

struct EdMenu far EM[] =
{
    {NM_TITLE, MSG_PROJECT_MENU, EC_NOP, 0},
    {NM_ITEM, MSG_PROJECT_OPEN, EC_OPEN, 0},
    {NM_ITEM, MSG_PROJECT_SAVE_AS, EC_SAVEAS, 0},
    {NM_ITEM, MSG_NOTHING, EC_NOP, 0},
    {NM_ITEM, MSG_PROJECT_QUIT, EC_CANCEL, 0},

    {NM_TITLE, MSG_EDIT_MENU, EC_NOP, 0},
    {NM_ITEM, MSG_EDIT_CUT, EC_CUT, 0},
    {NM_ITEM, MSG_EDIT_COPY, EC_COPY, 0},
    {NM_ITEM, MSG_EDIT_PASTE, EC_PASTE, 0},
    {NM_ITEM, MSG_NOTHING, EC_NOP, 0},
    {NM_ITEM, MSG_EDIT_ERASE, EC_ERASE, 0},
    {NM_ITEM, MSG_NOTHING, EC_NOP, 0},
    {NM_ITEM, MSG_EDIT_UNDO, EC_UNDO, 0},
    {NM_ITEM, MSG_NOTHING, EC_NOP, 0},
    {NM_ITEM, MSG_PTR_EDIT_LOAD_IMAGE, EC_LOAD_IMAGE, 0},
    {NM_ITEM, MSG_NOTHING, EC_NOP, 0},
    {NM_ITEM, MSG_EDIT_RESET_TO_DEFAULTS, EC_MYRESETALL, 0},
    {NM_ITEM, MSG_EDIT_LAST_SAVED, EC_MYLASTSAVED, 0},
    {NM_ITEM, MSG_EDIT_RESTORE, EC_MYRESTORE, 0},

    {NM_TITLE, MSG_OPTIONS_MENU, EC_NOP, 0},
    {NM_ITEM, MSG_OPTIONS_SAVE_ICONS, EC_SAVEICONS, CHECKIT | MENUTOGGLE},

    {NM_END, MSG_NOTHING, EC_NOP, 0}
};

/*****************************************************************************/

#define NW_IDCMP	(IDCMP_CLOSEWINDOW | IDCMP_MENUPICK | IDCMP_REFRESHWINDOW | BUTTONIDCMP | PALETTEIDCMP | SLIDERIDCMP)
#define NW_FLAGS	(WFLG_ACTIVATE | WFLG_SIMPLE_REFRESH)
#define NWW_FLAGS	(WFLG_ACTIVATE | WFLG_SIMPLE_REFRESH | WFLG_DRAGBAR | WFLG_DEPTHGADGET)

/* main display gadgets */
struct EdGadget far EG[] =
{
    {BUTTON_KIND, 0, 0, 87, 14, MSG_SAVE_GAD, EC_SAVE, 0},	/* 0 : Save */
    {BUTTON_KIND, 0, 0, 87, 14, MSG_USE_GAD, EC_USE, 0},	/* 1 : Use */
    {BUTTON_KIND, 0, 0, 87, 14, MSG_CANCEL_GAD, EC_CANCEL, 0},	/* 2 : Cancel */

    {BUTTON_KIND, 0, 20, 148, 14, MSG_PTR_TEST_GAD, EC_TEST, 0},	/* 3 : Test */
    {BUTTON_KIND, 0, 36, 148, 14, MSG_PTR_CLEAR_GAD, EC_CLEAR, 0},	/* 4 : Clear */
    {BUTTON_KIND, 0, 52, 148, 14, MSG_PTR_SET_GAD, EC_SET, 0},	/* 5 : Set Grab Point */
    {BUTTON_KIND, 0, 68, 148, 14, MSG_PTR_RESET_GAD, EC_RESET, 0},	/* 6 : Reset */

    {PALETTE_KIND, 0, 86, 148, 40, NULL, EC_PALETTE, 0},	/* 7 : Palette */

    {SLIDER_KIND, 0, 130, 104, 11, MSG_PTR_RED_GAD, EC_RED, 0},	/* 8 : Red */
    {SLIDER_KIND, 0, 143, 104, 11, MSG_PTR_GREEN_GAD, EC_GREEN, 0},	/* 9 : Green */
    {SLIDER_KIND, 0, 156, 104, 11, MSG_PTR_BLUE_GAD, EC_BLUE, 0},	/* 10 : Blue  */

    {CYCLE_KIND, 0, 2, 100, 14, NULL, EC_TYPE, 0},	/* 11 : Type */
    {CYCLE_KIND, 0, 2, 148, 14, NULL, EC_SIZE, 0},	/* 12 : Size */
};

/*****************************************************************************/

APTR newdtobject (EdDataPtr ed, STRPTR name, Tag tag1,...)
{
    return (NewDTObjectA (name, (struct TagItem *) & tag1));
}

/*****************************************************************************/

ULONG getdtattrs (EdDataPtr ed, Object * o, ULONG data,...)
{
    return (GetDTAttrsA (o, (struct TagItem *) & data));
}

/*****************************************************************************/

ULONG setdtattrs (EdDataPtr ed, Object * o, ULONG data,...)
{
    return (SetDTAttrsA (o, NULL, NULL, (struct TagItem *) & data));
}

/*****************************************************************************/

ULONG CheckBitRange (EdDataPtr ed, UBYTE bit)
{
    if (bit > HIGHBITSPERGUN)
	bit = HIGHBITSPERGUN;
    if (bit < LOWBITSPERGUN)
	bit = LOWBITSPERGUN;
    return ((ULONG) bit);
}

/*****************************************************************************/

/* value is in the current bit size */
ULONG Make8 (EdDataPtr ed, ULONG value, ULONG bits)
{
    ULONG result;
    ULONG mask;

    if (bits == 8)
	return (value);

    mask = value << (8 - bits);
    result = 0;
    while (mask)
    {
	result |= mask;
	mask = mask >> bits;
    }

    return (result);
}


/*****************************************************************************/

ULONG Make32 (EdDataPtr ed, ULONG eight)
{
    return ((eight << 24) + (eight << 16) + (eight << 8) + eight);
}

/*****************************************************************************/

VOID SetRGB8 (EdDataPtr ed, UWORD color, ULONG r, ULONG g, ULONG b)
{
    SetRGB32 (&ed->ed_Screen->ViewPort, color, Make32 (ed, r), Make32 (ed, g), Make32 (ed, b));
}

/*****************************************************************************/

UWORD GetIndex (EdDataPtr ed, UWORD pen)
{
    UWORD i;

    for (i = 0; i < MAXPENS; i++)
    {
	if (pen == ed->ed_ColorTable[i])
	    return (i);
    }
    return (0);
}

/*****************************************************************************/

void vprintf (EdDataPtr ed, void *fmt, LONG data,...)
{
    VPrintf (fmt, (LONG *) & data);
}

/*****************************************************************************/

VOID ProcessArgs (EdDataPtr ed, struct DiskObject * diskObj)
{
    UBYTE *tmp;
    ULONG hold;

    if (diskObj)
    {
	if (tmp = FindToolType (diskObj->do_ToolTypes, "CLIPUNIT"))
	    if (StrToLong (tmp, &hold) > 0L)
		ed->ed_ClipUnit = hold;

	ed->ed_RemapImage = TRUE;
	if (FindToolType (diskObj->do_ToolTypes, "NOREMAP"))
	    ed->ed_RemapImage = FALSE;
    }
    else
    {
	/* This check is need to keep CPR from crashing */
	if (ed->ed_Args[OPT_CLIPUNIT])
	    ed->ed_ClipUnit = *((ULONG *) ed->ed_Args[OPT_CLIPUNIT]);

	ed->ed_RemapImage = (ed->ed_Args[OPT_NOREMAP]) ? FALSE : TRUE;
    }
}

/*****************************************************************************/

ULONG ASM Filter (REG (a0) struct Hook * h, REG (a2) struct FileRequester * fr, REG (a1) struct AnchorPath * ap)
{
    EdDataPtr ed = (EdDataPtr) h->h_Data;
    struct DataType *dtn;
    ULONG use = FALSE;
    UBYTE buffer[300];
    BPTR lock;

    strncpy (buffer, fr->fr_Drawer, sizeof (buffer));
    AddPart (buffer, ap->ap_Info.fib_FileName, sizeof (buffer));
    if (lock = Lock (buffer, ACCESS_READ))
    {
	if (ap->ap_Info.fib_DirEntryType < 0)
	{
	    if (dtn = ObtainDataTypeA (DTST_FILE, (APTR) lock, NULL))
	    {
		if (dtn->dtn_Header->dth_GroupID == GID_PICTURE)
		    use = TRUE;
		ReleaseDataType (dtn);
	    }
	}
	else
	    use = TRUE;

	UnLock (lock);
    }

    return (use);
}

/*****************************************************************************/

EdStatus InitEdData (EdDataPtr ed)
{
    struct MonitorSpec *ms;
    struct Screen *scr;
    register WORD i, j;
    ULONG modeid;

    ed->ed_FilterHook.h_Entry = Filter;
    ed->ed_FilterHook.h_Data = ed;

    /* Clear the pens */
    for (i = 0; i < MAXPENS; i++)
	ed->ed_Pens[i] = (-1);

    /* Default to the first pen in our palette */
    ed->ed_APen = 5;
    ed->ed_Depth = 3;

    /* Set the default screen values */
    ed->ed_ModeId = LORES_KEY;
    ed->ed_SWidth = ed->ed_WWidth = 340;
    ed->ed_SHeight = ed->ed_WHeight = 200;

    /* Set the size for LORES */
    ed->ed_Width = 16;
    ed->ed_Height = 24;
    ed->ed_XMag = ed->ed_YMag = 6;

    /*******************************/
    /* Get the Display Information */
    /*******************************/

    if (scr = LockPubScreen ("Workbench"))
    {
	modeid = GetVPModeID (&scr->ViewPort);
	if (GetDisplayInfoData (NULL, (UBYTE *) & ed->ed_DispInfo, sizeof (struct DisplayInfo), DTAG_DISP, modeid))
	{
	    WORD sw, sh;

	    sw = (4 * ed->ed_DispInfo.SpriteResolution.x) / ed->ed_DispInfo.Resolution.x;
	    sh = (4 * ed->ed_DispInfo.SpriteResolution.y) / ed->ed_DispInfo.Resolution.y;
#if 0
	    ed->ed_XMag = sw;
	    ed->ed_YMag = sh;
#endif

	    DV (vprintf (ed, "screen res: %ld,%ld\n", (LONG) ed->ed_DispInfo.Resolution.x, (LONG) ed->ed_DispInfo.Resolution.y));
	    DV (vprintf (ed, "sprite res: %ld,%ld\n", (LONG) ed->ed_DispInfo.SpriteResolution.x, (LONG) ed->ed_DispInfo.SpriteResolution.y));
	    DV (vprintf (ed, "    aspect: %ld,%ld\n", (LONG) sw, (LONG) sh));
	    DV (vprintf (ed, "      bits: r%ld g%ld b%ld\n", (ULONG) ed->ed_DispInfo.RedBits, (ULONG) ed->ed_DispInfo.GreenBits, (ULONG) ed->ed_DispInfo.BlueBits));

#if 0
	    /* Get the bits */
	    ed->ed_RedBits   = CheckBitRange (ed, ed->ed_DispInfo.RedBits);
	    ed->ed_GreenBits = CheckBitRange (ed, ed->ed_DispInfo.GreenBits);
	    ed->ed_BlueBits  = CheckBitRange (ed, ed->ed_DispInfo.BlueBits);
#endif

	    if (ed->ed_DispInfo.PropertyFlags & DIPF_IS_SPRITES_ATT)
	    {
		DV (vprintf (ed, "supports attached sprites\n", NULL));
	    }
	    if (ed->ed_DispInfo.PropertyFlags & DIPF_IS_SPRITES_CHNG_RES)
	    {
		DV (vprintf (ed, "supports variable sprite resolutions\n", NULL));
	    }
	    if (ed->ed_DispInfo.PropertyFlags & DIPF_IS_SPRITES_CHNG_BASE)
	    {
		DV (vprintf (ed, "can change sprite base color\n", NULL));
	    }
	}

	if (ms = OpenMonitor (NULL, modeid))
	{
	    if (ms->ms_Flags & MSF_DOUBLE_SPRITES)
	    {
		DV (vprintf (ed, "scan double sprites\n", NULL));
	    }

	    if (ms->ms_Flags & MSF_REQUEST_A2024)
	    {
		DV (vprintf (ed, "request 2024\n", NULL));
		ed->ed_Flags |= EDF_2024;
	    }
	    CloseMonitor (ms);
	}

	{
	    if ((ed->ed_Pens[0] = ObtainPen (scr->ViewPort.ColorMap, -1, 0, 0, 0, PEN_EXCLUSIVE)) >= 0)
	    {
		if ((ed->ed_Pens[1] = ObtainPen (scr->ViewPort.ColorMap, -1, 0, 0, 0, PEN_EXCLUSIVE)) >= 0)
		{
		    if ((ed->ed_Pens[2] = ObtainPen (scr->ViewPort.ColorMap, -1, 0, 0, 0, PEN_EXCLUSIVE)) >= 0)
		    {
			ed->ed_Flags |= EDF_WINDOW | EDF_EXCLUSIVE;
			DV (vprintf (ed, "got exclusive pens\n", NULL));
		    }
		}
	    }

	    if (!(ed->ed_Flags & EDF_EXCLUSIVE))
	    {
		DV (vprintf (ed, "couldn't get exclusive pens\n", NULL));
		for (i = 0; i < MAXPENS; i++)
		{
		    ReleasePen (scr->ViewPort.ColorMap, ed->ed_Pens[i]);
		    ed->ed_Pens[i] = (-1);
		}
		for (i = 5, j = 0; j < 3; i++, j++)
		    ed->ed_Pens[j] = i;
	    }
	}

	ed->ed_ColorTable[0] = 0;
	for (i = 0; i < 3; i++)
	    ed->ed_ColorTable[(i + 1)] = ed->ed_Pens[i];

	if (ed->ed_Flags & EDF_WINDOW)
	{
	    ed->ed_Depth = scr->BitMap.Depth;
	    ed->ed_APen = 0;
	    ed->ed_WHeight -= 13;
	}

	UnlockPubScreen (NULL, scr);
    }

    /***********************/
    /* Initialize the Data */
    /***********************/

    /* Initialize the sketchpad gadget */
    if (ed->ed_SketchClass = initsketchGClass (ed))
    {
	/* Create the bitplanes */
	if ((allocpp (ed, &ed->ed_PrefsDefaults)) == ES_NORMAL)
	{
	    if ((allocpp (ed, &ed->ed_PrefsWork)) == ES_NORMAL)
	    {
		if ((allocpp (ed, &ed->ed_PrefsInitial)) == ES_NORMAL)
		{
		    if (ed->ed_UndoBM = AllocBitMap ((MAXWIDTH * 2), MAXHEIGHT, ed->ed_Depth, BMF_DISPLAYABLE | BMF_STANDARD | BMF_CLEAR, NULL))
		    {
			if (ed->ed_TempBM = AllocBitMap (MAXWIDTH, MAXHEIGHT, ed->ed_Depth, BMF_DISPLAYABLE | BMF_STANDARD | BMF_CLEAR, NULL))
			{
			    ULONG msize;

			    InitBitMap (&ed->ed_WorkBM, ed->ed_Depth, MAXWIDTH, MAXHEIGHT);
			    msize = RASSIZE (MAXWIDTH, MAXHEIGHT);
			    if (ed->ed_WorkBM.Planes[0] = (PLANEPTR) AllocVec (msize, MEMF_CHIP | MEMF_CLEAR))
			    {
				for (i = 1; i < ed->ed_Depth; i++)
				    ed->ed_WorkBM.Planes[i] = ed->ed_WorkBM.Planes[0];

				InitRastPort (&ed->ed_WorkRP);
				ed->ed_WorkRP.BitMap = &ed->ed_WorkBM;

				/* Make the default image */
				CopyFromDefault (ed);

				return (ES_NORMAL);
			    }
			    FreeBitMap (ed->ed_UndoBM);
			}
			FreeBitMap (ed->ed_TempBM);
		    }
		    FreeBitMap (ed->ed_PrefsInitial.ep_BMap);
		}
		FreeBitMap (ed->ed_PrefsWork.ep_BMap);
	    }
	    FreeBitMap (ed->ed_PrefsDefaults.ep_BMap);
	}
    }
    return (ES_NO_MEMORY);
}

/*****************************************************************************/

BOOL InitDisp (EdDataPtr ed)
{
    struct Rectangle mrect;
    struct Rectangle rect;
    BOOL result = FALSE;
    LONG left = 0;
    WORD rofs = 4;
    WORD lofs = 4;
    WORD ofs = 2;

    if (ed->ed_Flags & EDF_WINDOW)
    {
	if (ed->ed_Screen = LockPubScreen ("Workbench"))
	{
	    /* No problem */
	    result = TRUE;
	}
    }
    else
    {
	ofs = 13;
	lofs = -2;
	rofs = 6;

	/* Set the screen name */
	strcpy (ed->ed_ScreenNameBuf, "POINTER");
	ed->ed_PubScreenName = ed->ed_ScreenNameBuf;

	QueryOverscan (ed->ed_ModeId, &mrect, OSCAN_MAX);
	QueryOverscan (ed->ed_ModeId, &rect, OSCAN_TEXT);

	if (ed->ed_SWidth >= (rect.MaxX - rect.MinX + 1))
	{
	    if (ed->ed_SWidth <= (mrect.MaxX - rect.MinX + 1))
		rect.MaxX = ed->ed_SWidth + 1;
	}
	else
	{
	    left = ((rect.MaxX - rect.MinX + 1) - ed->ed_SWidth) / 2;
	}

	/* Open the screen */
	if (ed->ed_Screen = OpenPrefsScreen (ed,
					     SA_DisplayID, ed->ed_ModeId,
					     SA_Title, GetString (&ed->ed_LocaleInfo, MSG_PREFS_NAME),
					     SA_Depth, 4,
					     SA_Left, left,
					     SA_Width, ed->ed_SWidth,
					     SA_Height, ed->ed_SHeight,
					     SA_Font, &(ed->ed_TextAttr),
					     SA_PubName, ed->ed_ScreenNameBuf,
					     SA_DClip, &rect,
					     SA_LikeWorkbench, TRUE,
					     SA_AutoScroll, TRUE,
					     TAG_DONE))
	{
	    /* We opened it */
	    ed->ed_Flags |= EDF_OUR_PUBLIC;

	    /* Make the screen public */
	    PubScreenStatus (ed->ed_Screen, 0L);

	    /* No problem */
	    result = TRUE;
	}
    }

    if (ed->ed_Screen)
    {
#if 1
	ed->ed_RedBits   = CheckBitRange (ed, ed->ed_DispInfo.RedBits);
	ed->ed_GreenBits = CheckBitRange (ed, ed->ed_DispInfo.GreenBits);
	ed->ed_BlueBits  = CheckBitRange (ed, ed->ed_DispInfo.BlueBits);
#else
	/* Get the ModeId */
	ed->ed_ModeId = GetVPModeID (&ed->ed_Screen->ViewPort);
	if (GetDisplayInfoData (NULL, (UBYTE *) & ed->ed_DispInfo, sizeof (struct DisplayInfo), DTAG_DISP, ed->ed_ModeId))
	{
	    ed->ed_RedBits   = CheckBitRange (ed, ed->ed_DispInfo.RedBits);
	    ed->ed_GreenBits = CheckBitRange (ed, ed->ed_DispInfo.GreenBits);
	    ed->ed_BlueBits  = CheckBitRange (ed, ed->ed_DispInfo.BlueBits);
	}
#endif

	/* Save */
	EG[0].eg_LeftEdge = lofs;
	EG[0].eg_TopEdge = ed->ed_WHeight - EG[0].eg_Height - ofs;
	/* Use */
	EG[1].eg_LeftEdge = (ed->ed_WWidth - EG[1].eg_Width - rofs) / 2;
	EG[1].eg_TopEdge = ed->ed_WHeight - EG[1].eg_Height - ofs;
	/* Cancel */
	EG[2].eg_LeftEdge = ed->ed_WWidth - EG[2].eg_Width - rofs;
	EG[2].eg_TopEdge = ed->ed_WHeight - EG[2].eg_Height - ofs;

	/* Test */
	EG[3].eg_LeftEdge = ed->ed_WWidth - EG[3].eg_Width - rofs;
	/* Clear */
	EG[4].eg_LeftEdge = ed->ed_WWidth - EG[4].eg_Width - rofs;
	/* Set Point */
	EG[5].eg_LeftEdge = ed->ed_WWidth - EG[5].eg_Width - rofs;
	/* Reset Colors */
	EG[6].eg_LeftEdge = ed->ed_WWidth - EG[6].eg_Width - rofs;

	/* Palette */
	EG[7].eg_LeftEdge = ed->ed_WWidth - EG[7].eg_Width - rofs;

	/* R G B Sliders */
	EG[8].eg_LeftEdge = ed->ed_WWidth - EG[8].eg_Width - rofs;
	EG[9].eg_LeftEdge = ed->ed_WWidth - EG[9].eg_Width - rofs;
	EG[10].eg_LeftEdge = ed->ed_WWidth - EG[10].eg_Width - rofs;

	EG[11].eg_Width = 2 + (16 * 6) + 2 + 1;
	EG[11].eg_LeftEdge = lofs;
	EG[12].eg_LeftEdge = ed->ed_WWidth - EG[12].eg_Width - rofs;
    }

    return (result);
}

/*****************************************************************************/

VOID CopyPrefs (EdDataPtr ed, struct ExtPrefs * dp, struct ExtPrefs * sp)
{
    register WORD c;

    /* Make a backup */
    if (dp == &(ed->ed_PrefsWork))
    {
	Store (ed);
    }

    /* 32 is the size of the copiable portion of the structure */
    CopyMem (&sp->ep_PP[0], &dp->ep_PP[0], 32);
    CopyMem (&sp->ep_PP[1], &dp->ep_PP[1], 32);

    /* Copy from the sketchpad into our buffer */
    bltbm (sp->ep_BMap, 0, 0,
	   dp->ep_BMap, 0, 0, (MAXWIDTH * 2), MAXHEIGHT,
	   0xC0, 0xFF, NULL, ed->ed_GfxBase);

    /* Copy the colors */
    for (c = 0; c < MAXCOLORS; c++)
	dp->ep_CMap[c] = *(&sp->ep_CMap[c]);

    ed->ed_Size = (sp->ep_PP[0].pp_Size) ? sp->ep_PP[0].pp_Size - POINTERXRESN_LORES : 0;
}

/*****************************************************************************/

VOID CleanUpEdData (EdDataPtr ed)
{
    UWORD i;

    if (ed->ed_Cancelled && (ed->ed_Flags & EDF_TESTED))
    {
	/* Restore the initial pointer */
	CopyPrefs (ed, &ed->ed_PrefsWork, &ed->ed_PrefsInitial);

	/* Set the pointer */
	SavePrefs (ed, ENV_NAME);
    }

    /* Free the bitmaps */
    WaitBlit ();
    FreeBitMap (ed->ed_PrefsInitial.ep_BMap);
    FreeBitMap (ed->ed_PrefsWork.ep_BMap);
    FreeBitMap (ed->ed_PrefsDefaults.ep_BMap);
    FreeBitMap (ed->ed_UndoBM);
    FreeBitMap (ed->ed_TempBM);
    FreeVec (ed->ed_WorkBM.Planes[0]);

    /* Get rid of the sketch class */
    if (ed->ed_SketchClass)
    {
	freesketchGClass (ed, ed->ed_SketchClass);
    }
    /* Is our public screen open? */
    if (ed->ed_Screen)
    {
	if (ed->ed_Flags & EDF_OUR_PUBLIC)
	{
	    /* Keep trying to close it */
	    while (!CloseScreen (ed->ed_Screen))
		Delay (50);
	}
	else
	{
	    if (ed->ed_Flags & EDF_EXCLUSIVE)
	    {
		for (i = 0; i < MAXPENS; i++)
		{
		    ReleasePen (ed->ed_Screen->ViewPort.ColorMap, ed->ed_Pens[i]);
		    ed->ed_Pens[i] = (-1);
		}
	    }

	    UnlockPubScreen (NULL, ed->ed_Screen);
	}
    }
    FreeAslRequest (ed->ed_ImageReq);
}

/*****************************************************************************/

BOOL CreateDisplay (EdDataPtr ed)
{
    struct LocaleInfo *li;

    li = &(ed->ed_LocaleInfo);
    ed->ed_WhichLabels[0] = GetString (li, MSG_PTR_NORMAL_GAD);
    ed->ed_WhichLabels[1] = GetString (li, MSG_PTR_BUSY_GAD);

    ed->ed_SizeLabels[0] = GetString (li, MSG_PTR_LORES_GAD);
    ed->ed_SizeLabels[1] = GetString (li, MSG_PTR_HIRES_GAD);

    ed->ed_LastAdded = CreateContext (&ed->ed_Gadgets);

    DoPrefsGadget (ed, &EG[0], NULL, TAG_DONE);
    DoPrefsGadget (ed, &EG[1], NULL, TAG_DONE);
    DoPrefsGadget (ed, &EG[2], NULL, TAG_DONE);

    /* Build the editor specific gadgets */
    RenderGadgets (ed);

    /* Create the menus and open the window */
    if ((ed->ed_LastAdded)
	&& (ed->ed_Menus = CreatePrefsMenus (ed, EM))
	&& (ed->ed_Window = OpenPrefsWindow (ed,
					     ((ed->ed_Flags & EDF_WINDOW) ? WA_Title : TAG_IGNORE), GetString (&ed->ed_LocaleInfo, MSG_PREFS_NAME),
					     WA_IDCMP, NW_IDCMP,
					     WA_Flags, ((ed->ed_Flags & EDF_WINDOW) ? NWW_FLAGS : NW_FLAGS),
					     WA_InnerWidth, ed->ed_WWidth,
					     WA_InnerHeight, ed->ed_WHeight,
					     WA_Borderless, !(ed->ed_Flags & EDF_WINDOW),
					     WA_Backdrop, !(ed->ed_Flags & EDF_WINDOW),
					     WA_PubScreen, ed->ed_Screen,
					     WA_NewLookMenus, TRUE,
					     WA_Gadgets, ed->ed_Gadgets,
					     TAG_DONE)))
    {
	/* Bring the screen to front */
	ScreenToFront (ed->ed_Screen);

	return (TRUE);
    }
    DisposeDisplay (ed);

    return (FALSE);
}

/*****************************************************************************/

VOID DisposeDisplay (EdDataPtr ed)
{

    /* Do we have a window? */
    if (ed->ed_Window)
    {
	ClearMenuStrip (ed->ed_Window);
	CloseWindow (ed->ed_Window);
    }
    /* Free the menus */
    FreeMenus (ed->ed_Menus);

    /* Free the GadTools gadgets */
    FreeGadgets (ed->ed_Gadgets);

    /* Do we have a sketchpad? */
    if (ed->ed_GSketch)
    {
	DisposeObject (ed->ed_GSketch);
	ed->ed_GSketch = NULL;
    }
}

/*****************************************************************************/

VOID RefreshRepeats (EdDataPtr ed)
{
    WORD echo_w = MAXWIDTH + 4;
    WORD echo_h = MAXHEIGHT + 4;
    register WORD tx, ty;
    register WORD bx, by;
    register WORD i;

    /* Get a pointer to the sketchpad rastport */
    if (ed->ed_Window)
    {
	tx = ed->ed_GSketch->LeftEdge + ed->ed_GSketch->Width + 7;
	ty = ed->ed_GSketch->TopEdge + 2;

	/* Create the mask */
	SetRast (&ed->ed_WorkRP, 0);
	clipblit (&(ed->ed_PrefsWork.ep_RPort), (ed->ed_Which * MAXWIDTH), 0,
		  &ed->ed_WorkRP, 0, 0, ed->ed_Width, ed->ed_Height,
		  0xE0, ed->ed_GfxBase);

	for (i = 0; i < 4; i++, tx += echo_w)
	{
	    if (i == 2)
	    {
		ty += echo_h;
		tx = ed->ed_GSketch->LeftEdge + ed->ed_GSketch->Width + 7;
	    }

	    bx = tx + echo_w - 1;
	    by = ty + echo_h - 1;

	    SetAPen (ed->ed_Window->RPort, i);
	    RectFill (ed->ed_Window->RPort, tx, ty, bx, by);

	    clipblit (&ed->ed_WorkRP, 0, 0,
		      ed->ed_Window->RPort, tx + 2, ty + 2,
		      ed->ed_Width, ed->ed_Height,
		      0x20, ed->ed_GfxBase);

	    clipblit (&(ed->ed_PrefsWork.ep_RPort), (ed->ed_Which * MAXWIDTH), 0,
		      ed->ed_Window->RPort, tx + 2, ty + 2,
		      ed->ed_Width, ed->ed_Height,
		      0xE0, ed->ed_GfxBase);
	}
    }
}

/*****************************************************************************/

VOID RenderDisplay (EdDataPtr ed)
{
    WORD echo_w = MAXWIDTH + 4;
    WORD echo_h = MAXHEIGHT + 4;
    WORD echo_tw = 4 + (echo_w * 2) + 4;
    WORD echo_th = 2 + (echo_h * 2) + 2;
    register WORD tx, ty;

    DrawBB (ed,
	    ed->ed_GSketch->LeftEdge - 1,
	    ed->ed_GSketch->TopEdge,
	    ed->ed_GSketch->Width + 2,
	    ed->ed_GSketch->Height,
	    GT_VisualInfo, ed->ed_VisualInfo,
	    TAG_DONE);

    tx = ed->ed_GSketch->LeftEdge + ed->ed_GSketch->Width + 3;
    ty = ed->ed_GSketch->TopEdge;

    DrawBB (ed, tx, ty, echo_tw, echo_th,
	    GT_VisualInfo, ed->ed_VisualInfo,
	    GTBB_Recessed, TRUE,
	    TAG_DONE);

    /* Draw the repeat rectangles */
    RefreshRepeats (ed);
}

/*****************************************************************************/

VOID SetSliders (EdDataPtr ed)
{
    struct ExtPrefs *pp = &(ed->ed_PrefsWork);
    BOOL disable = FALSE;

    if (ed->ed_APen == 0)
	disable = TRUE;

    ed->ed_GRed = DoPrefsGadget (ed, &EG[8], ed->ed_GRed,
				 GTSL_Level, pp->ep_CMap[GetIndex (ed, ed->ed_APen)].t_Red >> (HIGHBITSPERGUN - ed->ed_RedBits),
				 GTSL_Min, 0,
				 GTSL_Max, (1 << ed->ed_RedBits) - 1,
				 GTSL_MaxLevelLen, 3,
				 GTSL_LevelFormat, "%3ld",
				 GA_Immediate, TRUE,
				 GA_Disabled, disable,
				 TAG_DONE);


    ed->ed_GGreen = DoPrefsGadget (ed, &EG[9], ed->ed_GGreen,
				   GTSL_Level, pp->ep_CMap[GetIndex (ed, ed->ed_APen)].t_Green >> (HIGHBITSPERGUN - ed->ed_GreenBits),
				   GTSL_Min, 0,
				   GTSL_Max, (1 << ed->ed_GreenBits) - 1,
				   GTSL_MaxLevelLen, 3,
				   GTSL_LevelFormat, "%3ld",
				   GA_Immediate, TRUE,
				   GA_Disabled, disable,
				   TAG_DONE);

    ed->ed_GBlue = DoPrefsGadget (ed, &EG[10], ed->ed_GBlue,
				  GTSL_Level, pp->ep_CMap[GetIndex (ed, ed->ed_APen)].t_Blue >> (HIGHBITSPERGUN - ed->ed_BlueBits),
				  GTSL_Min, 0,
				  GTSL_Max, (1 << ed->ed_BlueBits) - 1,
				  GTSL_MaxLevelLen, 3,
				  GTSL_LevelFormat, "%3ld",
				  GA_Immediate, TRUE,
				  GA_Disabled, disable,
				  TAG_DONE);
}

/*****************************************************************************/

BOOL upgadget (EdDataPtr ed, struct Gadget * g)
{

    if (g->Flags & GFLG_SELECTED)
    {
	struct Window *w = ed->ed_Window;
	USHORT pos;

	/* Remove the gadget from the list */
	pos = RemoveGList (w, g, 1L);

	/* Turn it back on */
	g->Flags &= ~GFLG_SELECTED;

	/* Add it back to the list */
	AddGList (w, g, (LONG) pos, 1L, NULL);

	/* Refresh the entire gadget */
	RefreshGList (g, w, NULL, 1);

	return (TRUE);
    }
    return (FALSE);
}

/*****************************************************************************/

VOID RenderGadgets (EdDataPtr ed)
{
    register WORD i, j;

    switch (ed->ed_Size)
    {
	case 0:
	    ed->ed_Width = 16;
	    ed->ed_Height = 24;
	    ed->ed_XMag = ed->ed_YMag = 6;
	    break;

	case 1:
	    ed->ed_Width = 32;
	    ed->ed_Height = 48;
	    ed->ed_XMag = ed->ed_YMag = 3;
	    break;
    }

    /* Use the colors from the new brush */
    for (i = 0, j = 1; i < 3; i++, j++)
    {
	DR (vprintf (ed, "%ld = %ld\n", (ULONG) i, ed->ed_Pens[i]));
	SetRGB8 (ed, ed->ed_Pens[i],
		 ed->ed_PrefsWork.ep_CMap[j].t_Red,
		 ed->ed_PrefsWork.ep_CMap[j].t_Green,
		 ed->ed_PrefsWork.ep_CMap[j].t_Blue);
    }

    ed->ed_GTest = DoPrefsGadget (ed, &EG[3], ed->ed_GTest, TAG_DONE);

    ed->ed_GClear = DoPrefsGadget (ed, &EG[4], ed->ed_GClear, TAG_DONE);

    /* Force the gadget to be toggle select */
    if (ed->ed_GSetPoint = DoPrefsGadget (ed, &EG[5], ed->ed_GSetPoint, TAG_DONE))
    {
	ed->ed_GSetPoint->Activation |= GACT_TOGGLESELECT;
    }
    ed->ed_GResetColor = DoPrefsGadget (ed, &EG[6], ed->ed_GResetColor, TAG_DONE);

    ed->ed_GPalette = DoPrefsGadget (ed, &EG[7], ed->ed_GPalette,
				     GTPA_Color, ed->ed_APen,
				     GTPA_NumColors, 4,
				     GTPA_ColorTable, ed->ed_ColorTable,
				     GTPA_IndicatorWidth, 18,
				     TAG_DONE);

    /* Set/Create the sliders */
    SetSliders (ed);

    /* Set the radio button for which image to edit */
    ed->ed_GType = DoPrefsGadget (ed, &EG[11], ed->ed_GType,
				  GTCY_Labels, ed->ed_WhichLabels,
				  GTCY_Active, ed->ed_Which,
				  TAG_DONE);

    if (ed->ed_DispInfo.PropertyFlags & DIPF_IS_SPRITES_CHNG_RES)
    {
	/* Set the radio button for which size to edit */
	ed->ed_GSize = DoPrefsGadget (ed, &EG[12], ed->ed_GSize,
				      GTCY_Labels, ed->ed_SizeLabels,
				      GTCY_Active, ed->ed_Size,
				      TAG_DONE);
    }

    /* Create the sketch gadget */
    if ((ed->ed_GSketch == NULL) && (ed->ed_LastAdded))
    {
	/* Create the sketchpad gadget */
	ed->ed_LastAdded = ed->ed_GSketch = (struct Gadget *)
	  NewPrefsObject (ed, ed->ed_SketchClass, NULL,
			  GA_Left, ed->ed_Screen->WBorLeft + ((ed->ed_Flags & EDF_WINDOW) ? 4 : -1),
			  GA_Top, 20 + ed->ed_Screen->WBorTop + ed->ed_Screen->Font->ta_YSize + 1,
			  GA_Width, 2 + (16 * 6) + 1,
			  GA_Height, 2 + (24 * 6) + 1,
			  GA_Immediate, TRUE,
			  GA_FollowMouse, TRUE,
			  GA_RelVerify, TRUE,
			  GA_ID, EC_SKETCH,
			  GA_UserData, EC_SKETCH,
			  GA_Previous, ed->ed_LastAdded,
			  TAG_DONE);
    }

    if (ed->ed_GSketch)
    {
	UpdateSketch (ed);
    }
}

/*****************************************************************************/

VOID SyncTextGadgets (EdDataPtr ed)
{
}

/*****************************************************************************/

EdStatus TestFunc (EdDataPtr ed)
{
    struct SignalSemaphore *sem;
    register WORD i, j;

    DoPrefsGadget (ed, NULL, ed->ed_GTest, GA_Disabled, TRUE, TAG_DONE);
    Forbid ();
    if (sem = FindSemaphore ("« IPrefs »"))
	ObtainSemaphore (sem);
    Permit ();

    if ((ed->ed_Screen->Flags & SCREENTYPE) != WBENCHSCREEN)
    {
	DR (vprintf (ed, "test func\n", NULL));
	for (i = 17, j = 1; j < 8; i++, j++)
	{
	    SetRGB8 (ed, i,
		     ed->ed_PrefsWork.ep_CMap[j].t_Red,
		     ed->ed_PrefsWork.ep_CMap[j].t_Green,
		     ed->ed_PrefsWork.ep_CMap[j].t_Blue);
	}
    }

    ed->ed_Flags |= EDF_TESTED;

    if (sem)
	ReleaseSemaphore (sem);
    DoPrefsGadget (ed, NULL, ed->ed_GTest, GA_Disabled, FALSE, TAG_DONE);
    return (SavePrefs (ed, ENV_NAME));
}

/*****************************************************************************/

VOID UpdateColor (EdDataPtr ed)
{
    SetRGB8 (ed, ed->ed_APen,
	     ed->ed_PrefsWork.ep_CMap[GetIndex (ed, ed->ed_APen)].t_Red,
	     ed->ed_PrefsWork.ep_CMap[GetIndex (ed, ed->ed_APen)].t_Green,
	     ed->ed_PrefsWork.ep_CMap[GetIndex (ed, ed->ed_APen)].t_Blue);
}

/*****************************************************************************/

VOID ResetColors (EdDataPtr ed)
{
    register UWORD c;

    for (c = 0; c < MAXCOLORS; c++)
	ed->ed_PrefsWork.ep_CMap[c] = ed->ed_PrefsInitial.ep_CMap[c];

    RenderGadgets (ed);
}

/*****************************************************************************/

VOID ProcessSpecialCommand (EdDataPtr ed, EdCommand ec)
{
    EdStatus result = ES_NORMAL;
    BOOL untest = FALSE;
    UWORD icode;
    LONG hx, hy;

    icode = ed->ed_CurrentMsg.Code;
    switch (ec)
    {
	case EC_CUT:
	    result = CutFunc (ed);
	    break;

	case EC_COPY:
	    result = CopyFunc (ed);
	    break;

	case EC_PASTE:
	    result = PasteFunc (ed, EC_PASTE);
	    break;

	case EC_LOAD_IMAGE:
	    result = PasteFunc (ed, EC_LOAD_IMAGE);
	    break;

	case EC_ERASE:
	    result = EraseFunc (ed);
	    break;

	case EC_UNDO:
	    setgadgetattrs (ed, ed->ed_GSketch, SPA_Restore, TRUE, TAG_DONE);
	    break;

	case EC_TEST:
	    result = TestFunc (ed);
	    break;

	case EC_CLEAR:
	    setgadgetattrs (ed, ed->ed_GSketch,
			    SPA_Store, TRUE,
			    SPA_Clear, TRUE,
			    TAG_DONE);
	    break;

	case EC_RESET:
	    ResetColors (ed);
	    break;

	case EC_PALETTE:
	    /* Set the currently select color */
	    ed->ed_APen = icode;

	    /* Set the sliders */
	    SetSliders (ed);
	    break;

	case EC_RED:
	    ed->ed_PrefsWork.ep_CMap[GetIndex (ed, ed->ed_APen)].t_Red = Make8 (ed, icode, ed->ed_RedBits);
	    UpdateColor (ed);
	    break;

	case EC_GREEN:
	    ed->ed_PrefsWork.ep_CMap[GetIndex (ed, ed->ed_APen)].t_Green = Make8 (ed, icode, ed->ed_GreenBits);
	    UpdateColor (ed);
	    break;

	case EC_BLUE:
	    ed->ed_PrefsWork.ep_CMap[GetIndex (ed, ed->ed_APen)].t_Blue = Make8 (ed, icode, ed->ed_GreenBits);
	    UpdateColor (ed);
	    break;

	case EC_SKETCH:
	    upgadget (ed, ed->ed_GSetPoint);
	    break;

	case EC_MYRESETALL:
	    CopyPrefs (ed, &ed->ed_PrefsWork, &ed->ed_PrefsDefaults);
	    untest = TRUE;
	    break;

	case EC_MYLASTSAVED:
	    result = OpenPrefs (ed, ARC_NAME);
	    untest = TRUE;
	    break;

	case EC_MYRESTORE:
	    CopyPrefs (ed, &ed->ed_PrefsWork, &ed->ed_PrefsInitial);
	    untest = TRUE;
	    break;

	case EC_TYPE:
	    ed->ed_Which = (UWORD) icode;

	    /* Update the display */
	    RenderGadgets (ed);
	    RenderDisplay (ed);
	    break;

	case EC_SIZE:
	    ed->ed_Size = (UWORD) icode;

	    /* Both pointers must be the same resolution */
	    ed->ed_PrefsWork.ep_PP[0].pp_Size = icode + POINTERXRESN_LORES;
	    ed->ed_PrefsWork.ep_PP[1].pp_Size = icode + POINTERXRESN_LORES;

	    /* Both pointers must be the same resolution */
	    ed->ed_PrefsWork.ep_PP[0].pp_YSize = (icode) ? POINTERYRESN_HIGH : POINTERYRESN_DEFAULT;
	    ed->ed_PrefsWork.ep_PP[1].pp_YSize = (icode) ? POINTERYRESN_HIGH : POINTERYRESN_DEFAULT;

	    /* Range check the hot spot */
	    hx = (ed->ed_PrefsWork.ep_PP[ed->ed_Which].pp_X) ? 65536L - (LONG)ed->ed_PrefsWork.ep_PP[ed->ed_Which].pp_X : 0;
	    hy = (ed->ed_PrefsWork.ep_PP[ed->ed_Which].pp_Y) ? 65536L - (LONG)ed->ed_PrefsWork.ep_PP[ed->ed_Which].pp_Y : 0;
	    if ((icode==0) && (hx >= 16L))
		ed->ed_PrefsWork.ep_PP[ed->ed_Which].pp_X = -15L;
	    if ((icode==0) && (hy >= 24L))
		ed->ed_PrefsWork.ep_PP[ed->ed_Which].pp_Y = -23L;

	    /* Update the display */
	    RenderGadgets (ed);
	    RenderDisplay (ed);
	    break;

	default:
	    break;
    }

    if (untest)
    {
	if (ed->ed_Flags & EDF_TESTED)
	{
	    TestFunc (ed);
	    ed->ed_Flags &= ~EDF_TESTED;
	}

	RenderGadgets (ed);
	RenderDisplay (ed);
    }

    if (result != ES_NORMAL)
	ShowError2 (ed, result);
}

/*****************************************************************************/

EdCommand
GetCommand (EdDataPtr ed)
{

    return (EC_NOP);
}

/*****************************************************************************/

VOID
GetSpecialCmdState (EdDataPtr ed, EdCommand ec, CmdStatePtr state)
{

    state->cs_Available = TRUE;
    state->cs_Selected = FALSE;
}
@


38.18
log
@check directory
@
text
@d469 5
d482 1
@


38.17
log
@range check hot spot.
@
text
@d202 1
a202 1
	if (dtn = ObtainDataTypeA (DTST_FILE, (APTR) lock, NULL))
d204 9
a212 2
	    if (dtn->dtn_Header->dth_GroupID == GID_PICTURE)
		use = TRUE;
a213 2
	    ReleaseDataType (dtn);
	}
@


38.16
log
@handles Moniterm monitors correctly.
supports NOREMAP keyword.
@
text
@a403 1
    UWORD value;
d972 1
d1076 8
@


38.15
log
@now longer opens on window on Moniterm
@
text
@a170 1
	{
a171 1
	    {
d173 4
a176 2
	    }
	}
d183 2
d268 1
d273 1
d469 3
a471 6
	    if (!(ed->ed_Flags & EDF_2024))
	    {
		ed->ed_RedBits   = CheckBitRange (ed, ed->ed_DispInfo.RedBits);
		ed->ed_GreenBits = CheckBitRange (ed, ed->ed_DispInfo.GreenBits);
		ed->ed_BlueBits  = CheckBitRange (ed, ed->ed_DispInfo.BlueBits);
	    }
@


38.14
log
@removed color setting code.
made window 20 pixels wider.
@
text
@d52 3
a54 3
    {BUTTON_KIND, 0, 0, 87, 14, MSG_SAVE_GAD, EC_SAVE, 0},		/*  0 : Save */
    {BUTTON_KIND, 0, 0, 87, 14, MSG_USE_GAD, EC_USE, 0},		/*  1 : Use */
    {BUTTON_KIND, 0, 0, 87, 14, MSG_CANCEL_GAD, EC_CANCEL, 0},		/*  2 : Cancel */
d56 10
a65 10
    {BUTTON_KIND, 0, 20, 148, 14, MSG_PTR_TEST_GAD, EC_TEST, 0},	/*  3 : Test */
    {BUTTON_KIND, 0, 36, 148, 14, MSG_PTR_CLEAR_GAD, EC_CLEAR, 0},	/*  4 : Clear */
    {BUTTON_KIND, 0, 52, 148, 14, MSG_PTR_SET_GAD, EC_SET, 0}	,	/*  5 : Set Grab Point */
    {BUTTON_KIND, 0, 68, 148, 14, MSG_PTR_RESET_GAD, EC_RESET, 0},	/*  6 : Reset */

    {PALETTE_KIND, 0, 86, 148, 40, NULL, EC_PALETTE, 0},		/*  7 : Palette */

    {SLIDER_KIND, 0, 130,104, 11, MSG_PTR_RED_GAD, EC_RED, 0},		/*  8 : Red */
    {SLIDER_KIND, 0, 143,104, 11, MSG_PTR_GREEN_GAD, EC_GREEN, 0},	/*  9 : Green */
    {SLIDER_KIND, 0, 156,104, 11, MSG_PTR_BLUE_GAD, EC_BLUE, 0},	/* 10 : Blue  */
d67 2
a68 2
    {CYCLE_KIND, 0, 2, 100, 14, NULL, EC_TYPE, 0},			/* 11 : Type */
    {CYCLE_KIND, 0, 2, 148, 14, NULL, EC_SIZE, 0},			/* 12 : Size */
a74 1

a81 1

a88 1

a95 1

a129 1

a136 1

a157 1

a230 1
    ed->ed_PenOffset = 0;
a249 1

a251 1
#if 0
d256 1
d265 6
d295 1
a295 1
		ed->ed_Flags |= (EDF_2024 | EDF_WINDOW);
a299 1
	if ((ed->ed_Pens[0] = ObtainPen (scr->ViewPort.ColorMap, -1, 0, 0, 0, PEN_EXCLUSIVE)) >= 0)
d301 1
a301 1
	    if ((ed->ed_Pens[1] = ObtainPen (scr->ViewPort.ColorMap, -1, 0, 0, 0, PEN_EXCLUSIVE)) >= 0)
d303 1
a303 1
		if ((ed->ed_Pens[2] = ObtainPen (scr->ViewPort.ColorMap, -1, 0, 0, 0, PEN_EXCLUSIVE)) >= 0)
d305 5
a309 2
		    ed->ed_Flags |= EDF_WINDOW | EDF_EXCLUSIVE;
		    DV (vprintf (ed, "got exclusive pens\n", NULL));
a311 1
	}
d313 1
a313 3
	if (!(ed->ed_Flags & EDF_EXCLUSIVE))
	{
	    for (i = 0; i < MAXPENS; i++)
d315 2
a316 1
		if (ed->ed_Pens[i] >= 0)
d319 1
d321 2
a322 1
		ed->ed_Pens[i] = (-1);
a323 2
	    for (i = 5, j = 0; j < 3; i++, j++)
		ed->ed_Pens[j] = i;
a332 1
	    DV (vprintf (ed, "depth %ld\n", (LONG) ed->ed_Depth));
a333 1
	    ed->ed_PenOffset = 0;
d421 1
a421 1
	QueryOverscan (ed->ed_ModeId, &rect,  OSCAN_TEXT);
d435 11
a445 11
					     SA_DisplayID,	ed->ed_ModeId,
					     SA_Title,		GetString (&ed->ed_LocaleInfo, MSG_PREFS_NAME),
					     SA_Depth,		4,
					     SA_Left,		left,
					     SA_Width,		ed->ed_SWidth,
					     SA_Height,		ed->ed_SHeight,
					     SA_Font,		&(ed->ed_TextAttr),
					     SA_PubName,	ed->ed_ScreenNameBuf,
					     SA_DClip,		&rect,
					     SA_LikeWorkbench,	TRUE,
					     SA_AutoScroll,	TRUE,
d465 6
a470 3
	    ed->ed_RedBits = CheckBitRange (ed, ed->ed_DispInfo.RedBits);
	    ed->ed_GreenBits = CheckBitRange (ed, ed->ed_DispInfo.GreenBits);
	    ed->ed_BlueBits = CheckBitRange (ed, ed->ed_DispInfo.BlueBits);
d580 1
a580 4
		    if (ed->ed_Pens[i] >= 0)
		    {
			ReleasePen (ed->ed_Screen->ViewPort.ColorMap, ed->ed_Pens[i]);
		    }
d748 4
d754 1
a754 1
				 GTSL_Level, pp->ep_CMap[GetIndex (ed, ed->ed_APen - ed->ed_PenOffset)].t_Red >> (HIGHBITSPERGUN - ed->ed_RedBits),
d760 1
a760 1
				 GA_Disabled, ((ed->ed_APen == ed->ed_PenOffset) ? TRUE : FALSE),
d765 1
a765 1
				   GTSL_Level, pp->ep_CMap[GetIndex (ed, ed->ed_APen - ed->ed_PenOffset)].t_Green >> (HIGHBITSPERGUN - ed->ed_GreenBits),
d771 1
a771 1
				   GA_Disabled, ((ed->ed_APen == ed->ed_PenOffset) ? TRUE : FALSE),
d775 1
a775 1
				  GTSL_Level, pp->ep_CMap[GetIndex (ed, ed->ed_APen - ed->ed_PenOffset)].t_Blue >> (HIGHBITSPERGUN - ed->ed_BlueBits),
d781 1
a781 1
				  GA_Disabled, ((ed->ed_APen == ed->ed_PenOffset) ? TRUE : FALSE),
d885 10
a894 10
			  GA_Left,		ed->ed_Screen->WBorLeft + ((ed->ed_Flags & EDF_WINDOW) ? 4 : -1),
			  GA_Top,		20 + ed->ed_Screen->WBorTop + ed->ed_Screen->Font->ta_YSize + 1,
			  GA_Width,		2 + (16 * 6) + 1,
			  GA_Height,		2 + (24 * 6) + 1,
			  GA_Immediate,		TRUE,
			  GA_FollowMouse,	TRUE,
			  GA_RelVerify,		TRUE,
			  GA_ID,		EC_SKETCH,
			  GA_UserData,		EC_SKETCH,
			  GA_Previous,		ed->ed_LastAdded,
a946 2

    DR (vprintf (ed, "update color\n", NULL));
d948 3
a950 3
	     ed->ed_PrefsWork.ep_CMap[GetIndex (ed, ed->ed_APen - ed->ed_PenOffset)].t_Red,
	     ed->ed_PrefsWork.ep_CMap[GetIndex (ed, ed->ed_APen - ed->ed_PenOffset)].t_Green,
	     ed->ed_PrefsWork.ep_CMap[GetIndex (ed, ed->ed_APen - ed->ed_PenOffset)].t_Blue);
d955 1
a955 2
VOID
ResetColors (EdDataPtr ed)
d1024 1
a1024 1
	    ed->ed_PrefsWork.ep_CMap[GetIndex (ed, ed->ed_APen - ed->ed_PenOffset)].t_Red = Make8 (ed, icode, ed->ed_RedBits);
d1029 1
a1029 1
	    ed->ed_PrefsWork.ep_CMap[GetIndex (ed, ed->ed_APen - ed->ed_PenOffset)].t_Green = Make8 (ed, icode, ed->ed_GreenBits);
d1034 1
a1034 1
	    ed->ed_PrefsWork.ep_CMap[GetIndex (ed, ed->ed_APen - ed->ed_PenOffset)].t_Blue = Make8 (ed, icode, ed->ed_GreenBits);
d1043 1
a1043 1
	    CopyPrefs(ed,&ed->ed_PrefsWork,&ed->ed_PrefsDefaults);
d1048 1
a1048 1
	    result = OpenPrefs(ed,ARC_NAME);
d1053 1
a1053 1
	    CopyPrefs(ed,&ed->ed_PrefsWork,&ed->ed_PrefsInitial);
d1073 2
a1074 2
	    ed->ed_PrefsWork.ep_PP[0].pp_YSize = (icode) ? POINTERYRESN_HIGHASPECT : POINTERYRESN_DEFAULT;
	    ed->ed_PrefsWork.ep_PP[1].pp_YSize = (icode) ? POINTERYRESN_HIGHASPECT : POINTERYRESN_DEFAULT;
@


38.13
log
@*** empty log message ***
@
text
@d56 4
a59 4
    {BUTTON_KIND, 0, 20, 128, 14, MSG_PTR_TEST_GAD, EC_TEST, 0},	/*  3 : Test */
    {BUTTON_KIND, 0, 36, 128, 14, MSG_PTR_CLEAR_GAD, EC_CLEAR, 0},	/*  4 : Clear */
    {BUTTON_KIND, 0, 52, 128, 14, MSG_PTR_SET_GAD, EC_SET, 0}	,	/*  5 : Set Grab Point */
    {BUTTON_KIND, 0, 68, 128, 14, MSG_PTR_RESET_GAD, EC_RESET, 0},	/*  6 : Reset */
d61 1
a61 1
    {PALETTE_KIND, 0, 86, 128, 40, NULL, EC_PALETTE, 0},		/*  7 : Palette */
d63 3
a65 3
    {SLIDER_KIND, 0, 130, 84, 11, MSG_PTR_RED_GAD, EC_RED, 0},		/*  8 : Red */
    {SLIDER_KIND, 0, 143, 84, 11, MSG_PTR_GREEN_GAD, EC_GREEN, 0},	/*  9 : Green */
    {SLIDER_KIND, 0, 156, 84, 11, MSG_PTR_BLUE_GAD, EC_BLUE, 0},	/* 10 : Blue  */
d68 1
a68 1
    {CYCLE_KIND, 0, 2, 128, 14, NULL, EC_SIZE, 0},			/* 12 : Size */
d243 1
a243 1
    ed->ed_SWidth = ed->ed_WWidth = 320;
d398 1
a398 1
    UWORD pens[NUMDRIPENS + 2];
d401 1
a405 1
    LONG left;
a420 3
	/* Use the default pen array */
	pens[0] = -1;

d425 12
a436 2
	QueryOverscan (ed->ed_ModeId, &rect, OSCAN_TEXT);
	left = ((rect.MaxX - rect.MinX + 1) - ed->ed_SWidth) / 2;
d440 11
a450 12
					     SA_DisplayID, ed->ed_ModeId,
					     SA_Title, GetString (&ed->ed_LocaleInfo, MSG_PREFS_NAME),
					     SA_Depth, 4,
					     SA_Left, left,
					     SA_Width, ed->ed_SWidth,
					     SA_Height, ed->ed_SHeight,
					     SA_Font, &(ed->ed_TextAttr),
					     SA_PubName, ed->ed_ScreenNameBuf,
					     SA_Overscan, OSCAN_TEXT,
					     SA_Pens, pens,
					     SA_FullPalette, TRUE,
					     SA_LikeWorkbench, TRUE,
d453 1
a453 2
	    DR (vprintf (ed, "public screen\n", NULL));

a455 8
	    /* Set color zero */
	    value = GetRGB4 (ed->ed_Screen->ViewPort.ColorMap, 0);
	    SetRGB4 (&(ed->ed_Screen->ViewPort), 4, ((value & 0xF00) >> 8), ((value & 0xF0) >> 4), (value & 0xF));

	    /* Give us good menu colors */
	    SetRGB4 (&(ed->ed_Screen->ViewPort), 14, 15, 15, 15);
	    SetRGB4 (&(ed->ed_Screen->ViewPort), 15, 0, 0, 0);

d502 1
a502 1
	EG[11].eg_Width = lofs + (16 * 6);
@


38.12
log
@Use new pref shell
@
text
@d33 3
a35 3
    {NM_ITEM, MSG_EDIT_RESET_TO_DEFAULTS, EC_RESETALL, 0},
    {NM_ITEM, MSG_EDIT_LAST_SAVED, EC_LASTSAVED, 0},
    {NM_ITEM, MSG_EDIT_RESTORE, EC_RESTORE, 0},
d52 3
a54 3
    {BUTTON_KIND, 0, 0, 87, 14, MSG_SAVE_GAD, EC_SAVE, 0},	/* 0 : Save */
    {BUTTON_KIND, 0, 0, 87, 14, MSG_USE_GAD, EC_USE, 0},	/* 1 : Use */
    {BUTTON_KIND, 0, 0, 87, 14, MSG_CANCEL_GAD, EC_CANCEL, 0},	/* 2 : Cancel */
d56 10
a65 10
    {BUTTON_KIND, 0, 20, 128, 14, MSG_PTR_TEST_GAD, EC_TEST, 0},	/* 3 : Test */
    {BUTTON_KIND, 0, 36, 128, 14, MSG_PTR_CLEAR_GAD, EC_CLEAR, 0},	/* 4 : Clear */
    {BUTTON_KIND, 0, 52, 128, 14, MSG_PTR_SET_GAD, EC_SET, 0},	/* 5 : Set Grab Point */
    {BUTTON_KIND, 0, 68, 128, 14, MSG_PTR_RESET_GAD, EC_RESET, 0},	/* 6 : Reset */

    {PALETTE_KIND, 0, 88, 128, 40, NULL, EC_PALETTE, 0},	/* 7 : Palette */

    {SLIDER_KIND, 0, 132, 84, 11, MSG_PTR_RED_GAD, EC_RED, 0},	/* 8 : Red */
    {SLIDER_KIND, 0, 145, 84, 11, MSG_PTR_GREEN_GAD, EC_GREEN, 0},	/* 9 : Green */
    {SLIDER_KIND, 0, 158, 84, 11, MSG_PTR_BLUE_GAD, EC_BLUE, 0},	/* 10 : Blue  */
d67 2
a68 2
    {CYCLE_KIND, 0, 4, 100, 14, NULL, EC_TYPE, 0},	/* 11 : Type */
    {CYCLE_KIND, 0, 4, 128, 14, NULL, EC_SIZE, 0},	/* 12 : Size */
d339 1
d401 3
a403 1
    WORD ofs = 4;
d417 3
a419 1
	ofs = 12;
d444 1
d479 1
a479 1
	EG[0].eg_LeftEdge = 4;
d482 1
a482 1
	EG[1].eg_LeftEdge = (ed->ed_WWidth - EG[1].eg_Width - 4) / 2;
d485 1
a485 1
	EG[2].eg_LeftEdge = ed->ed_WWidth - EG[2].eg_Width - 4;
d489 1
a489 1
	EG[3].eg_LeftEdge = ed->ed_WWidth - EG[3].eg_Width - 4;
d491 1
a491 1
	EG[4].eg_LeftEdge = ed->ed_WWidth - EG[4].eg_Width - 4;
d493 1
a493 1
	EG[5].eg_LeftEdge = ed->ed_WWidth - EG[5].eg_Width - 4;
d495 1
a495 1
	EG[6].eg_LeftEdge = ed->ed_WWidth - EG[6].eg_Width - 4;
d498 1
a498 1
	EG[7].eg_LeftEdge = ed->ed_WWidth - EG[7].eg_Width - 4;
d501 3
a503 3
	EG[8].eg_LeftEdge = ed->ed_WWidth - EG[8].eg_Width - 4;
	EG[9].eg_LeftEdge = ed->ed_WWidth - EG[9].eg_Width - 4;
	EG[10].eg_LeftEdge = ed->ed_WWidth - EG[10].eg_Width - 4;
d505 3
a507 3
	EG[11].eg_Width = 2 + (ed->ed_Width * ed->ed_XMag) + 1;
	EG[11].eg_LeftEdge = 4;
	EG[12].eg_LeftEdge = ed->ed_WWidth - EG[12].eg_Width - 4;
d515 1
a515 2
VOID
CopyPrefs (EdDataPtr ed, struct ExtPrefs * dp, struct ExtPrefs * sp)
d525 3
a527 1
    /* Need to copy the grab point! */
d537 2
d557 1
a673 14
VOID SwitchRepeats (EdDataPtr ed)
{

    SetAPen (ed->ed_Window->RPort, 0);

    RectFill (ed->ed_Window->RPort,
	      ed->ed_GSketch->LeftEdge + ed->ed_GSketch->Width + 3,
	      ed->ed_GSketch->TopEdge,
	      ed->ed_GSketch->LeftEdge + ed->ed_GSketch->Width + 3 + ((MAXWIDTH + 4) * 2) + 8,
	      ed->ed_GSketch->TopEdge + ((MAXHEIGHT + 4) * 2) + 4);
}

/*****************************************************************************/

d676 2
a677 2
    WORD echo_w = ed->ed_Width + 4;
    WORD echo_h = ed->ed_Height + 4;
d725 2
a726 2
    WORD echo_w = ed->ed_Width + 4;
    WORD echo_h = ed->ed_Height + 4;
d888 11
a898 12
	  NewPrefsObject (ed,
			  ed->ed_SketchClass, NULL,
			  GA_Left, ed->ed_Screen->WBorLeft + 4,
			  GA_Top, 20 + ed->ed_Screen->WBorTop + ed->ed_Screen->Font->ta_YSize + 1,
			  GA_Width, 2 + (ed->ed_Width * ed->ed_XMag) + 1,
			  GA_Height, 2 + (ed->ed_Height * ed->ed_YMag) + 1,
			  GA_Immediate, TRUE,
			  GA_FollowMouse, TRUE,
			  GA_RelVerify, TRUE,
			  GA_ID, EC_SKETCH,
			  GA_UserData, EC_SKETCH,
			  GA_Previous, ed->ed_LastAdded,
d916 1
a916 2
EdStatus
TestFunc (EdDataPtr ed)
d923 1
a923 1
    if (sem = FindSemaphore ("+ IPrefs ;"))
a942 1

d974 1
a974 2
VOID
ProcessSpecialCommand (EdDataPtr ed, EdCommand ec)
d977 1
d1049 15
a1067 1
	    SwitchRepeats (ed);
d1079 4
a1083 1
	    SwitchRepeats (ed);
d1090 12
@


38.11
log
@*** empty log message ***
@
text
@d31 2
d195 27
d229 3
d586 1
d999 5
a1003 1
	    result = PasteFunc (ed);
@


38.10
log
@*** empty log message ***
@
text
@d6 1
d9 2
d14 155
a168 2
VOID
ProcessArgs (EdDataPtr ed, struct DiskObject * diskObj)
a172 1
    DB (kprintf ("ProcessArgs : enter\n"));
a188 1
    DB (kprintf ("ProcessArgs : exit\n"));
d193 1
a193 2
EdStatus
InitEdData (EdDataPtr ed)
d195 4
a198 2
    register WORD i;
    ULONG msize;
d200 24
a223 3
    /* Initialize the sketchpad gadget */
    DB (kprintf ("InitEdData : enter\n"));
    if (ed->ed_SketchClass = initsketchGClass (ed))
d225 71
a295 2
	/* Default to the first pen in our palette */
	ed->ed_APen = 5;
d297 14
a310 4
	/* Set the maximum width, height & depth */
	ed->ed_Width = 16;
	ed->ed_Height = 24;
	ed->ed_Depth = 3;
d312 3
a314 2
	/* Set the amount to magnify by */
	ed->ed_XMag = ed->ed_YMag = 6;
d316 3
d326 1
a326 1
		    if (allocbitmap (ed, &ed->ed_Undo, ed->ed_Depth, ed->ed_Width, ed->ed_Height))
d328 1
a328 3
			InitBitMap (&ed->ed_ShadowBM, ed->ed_Depth, ed->ed_Width, ed->ed_Height);
			msize = RASSIZE (ed->ed_Width, ed->ed_Height);
			if (ed->ed_ShadowBM.Planes[0] = (PLANEPTR) AllocVec (msize, MEMF_CHIP|MEMF_CLEAR))
d330 5
a334 1
			    for (i = 1; i < ed->ed_Depth; i++)
d336 2
a337 2
				ed->ed_ShadowBM.Planes[i] = ed->ed_ShadowBM.Planes[0];
			    }
d339 2
a340 2
			    InitRastPort (&ed->ed_ShadowRP);
			    ed->ed_ShadowRP.BitMap = &ed->ed_ShadowBM;
d342 2
a343 2
			    /* Make the default image */
			    CopyFromDefault (ed);
d345 3
a347 2
			    DB (kprintf ("InitEdData : return ES_NORMAL\n"));
			    return (ES_NORMAL);
d349 1
a349 1
			freebitmap (ed, &ed->ed_ShadowBM, ed->ed_Width, ed->ed_Height);
d351 1
a351 1
		    freebitmap (ed, &ed->ed_Undo, ed->ed_Width, ed->ed_Height);
d353 1
a353 1
		freebitmap (ed, &(ed->ed_PrefsInitial.pp_BMap), ed->ed_Width, ed->ed_Height);
d355 1
a355 1
	    freebitmap (ed, &(ed->ed_PrefsWork.pp_BMap), ed->ed_Width, ed->ed_Height);
a356 1
	freebitmap (ed, &(ed->ed_PrefsDefaults.pp_BMap), ed->ed_Width, ed->ed_Height);
a357 1
    DB (kprintf ("InitEdData : return ES_NO_MEMORY\n"));
d363 1
a363 2
VOID
CopyPrefs (EdDataPtr ed, struct PointerPrefs * dp, struct PointerPrefs * sp)
d365 6
a370 1
    register WORD c;
d372 1
a372 3
    /* Make a backup */
    DB (kprintf ("CopyPrefs : enter\n"));
    if (dp == &(ed->ed_PrefsWork))
d374 5
a378 1
	Store (ed);
d380 6
a385 4
    /* Copy from the sketchpad into our buffer */
    bltbm (&(sp->pp_BMap), 0, 0,
	   &(dp->pp_BMap), 0, 0, ed->ed_Width, ed->ed_Height,
	   0xC0, 0xFF, NULL, ed->ed_GfxBase);
d387 83
a469 6
    /* Copy the support fields */
    dp->pp_NumColors = sp->pp_NumColors;
    dp->pp_Grab = sp->pp_Grab;
    for (c = 0; c < MAXCOLORS; c++)
    {
	dp->pp_CMap[c] = sp->pp_CMap[c];
d471 2
a472 1
    DB (kprintf ("CopyPrefs : exit\n"));
d477 2
a478 2
BOOL
InitDisp (EdDataPtr ed)
d480 1
a480 8
    UWORD pens[NUMDRIPENS + 2];
    struct Rectangle rect;
    struct Screen *wbscr;
    struct DrawInfo *dri;
    BOOL result = FALSE;
    register WORD i;
    LONG left = 0L;
    UWORD value;
d482 2
a483 6
    /* Use the default pen array */
    DB (kprintf ("InitDisp : enter\n"));
    pens[0] = -1;

#if 0
    if (wbscr = LockPubScreen ("Workbench"))
d485 1
a485 15
	if (wbscr->BitMap.Depth > 1)
	{
	    if (dri = GetScreenDrawInfo (wbscr))
	    {
		for (i = 0; i <= NUMDRIPENS; i++)
		    pens[i] = dri->dri_Pens[i];

		FreeScreenDrawInfo (wbscr, dri);
	    }
	}
	else
	{
	    pens[0] = -1;
	}
	UnlockPubScreen (NULL, wbscr);
a486 1
#endif
d488 1
a488 3
    /* Set the screen name */
    strcpy (ed->ed_ScreenNameBuf, "POINTER");
    ed->ed_PubScreenName = ed->ed_ScreenNameBuf;
d490 4
a493 33
    QueryOverscan (LORES_KEY, &rect, OSCAN_TEXT);
    left = ((rect.MaxX - rect.MinX + 1) - 320) / 2;

    /* Open the screen */
    if (ed->ed_PScreen = OpenPrefsScreen (ed,
					  SA_Title, GetString (&ed->ed_LocaleInfo, MSG_PREFS_NAME),
					  SA_Depth, 4,
					  SA_Left, left,
					  SA_Width, 320,
					  SA_Height, 200,
					  SA_Font, &(ed->ed_TextAttr),
					  SA_PubName, ed->ed_ScreenNameBuf,
					  SA_Overscan, OSCAN_TEXT,
					  SA_Pens, pens,
					  SA_FullPalette, TRUE,
					  TAG_DONE))
    {
	/* Set color zero */
	value = GetRGB4 (ed->ed_PScreen->ViewPort.ColorMap, 0);
	SetRGB4 (&(ed->ed_PScreen->ViewPort), 4, ((value & 0xF00) >> 8), ((value & 0xF0) >> 4), (value & 0xF));

	/* Give us good menu colors */
	SetRGB4 (&(ed->ed_PScreen->ViewPort), 14, 15, 15, 15);
	SetRGB4 (&(ed->ed_PScreen->ViewPort), 15,  0,  0,  0);

	for (i = 4; i < 8; i++)
	{
	    value = ~GetRGB4 (ed->ed_PScreen->ViewPort.ColorMap, i);
	    SetRGB4 (&(ed->ed_PScreen->ViewPort), 15 - i, ((value & 0xF00) >> 8), ((value & 0xF0) >> 4), (value & 0xF));
	}

	/* Make the screen public */
	PubScreenStatus (ed->ed_PScreen, 0L);
d495 3
a497 5
	/* No problem */
	result = TRUE;
    }
    DB (kprintf ("InitDisp : exit\n"));
    return (result);
d502 1
a502 2
VOID
CleanUpEdData (EdDataPtr ed)
d504 2
d516 6
a521 4
    freebitmap (ed, &(ed->ed_PrefsInitial.pp_BMap), ed->ed_Width, ed->ed_Height);
    freebitmap (ed, &(ed->ed_PrefsWork.pp_BMap), ed->ed_Width, ed->ed_Height);
    freebitmap (ed, &(ed->ed_PrefsDefaults.pp_BMap), ed->ed_Width, ed->ed_Height);
    freebitmap (ed, &ed->ed_Undo, ed->ed_Width, ed->ed_Height);
a522 3
    /* Free the shadow bitmap */
    FreeVec (ed->ed_ShadowBM.Planes[0]);

d529 1
a529 1
    if (ed->ed_PScreen)
d531 7
a537 2
	/* Keep trying to close it */
	while (!CloseScreen (ed->ed_PScreen))
d539 13
a551 1
	    Delay (50);
d556 9
a564 78
/*****************************************************************************/

struct EdMenu far EM[] =
{
    {NM_TITLE, MSG_PROJECT_MENU, EC_NOP, 0},
    {NM_ITEM, MSG_PROJECT_OPEN, EC_OPEN, 0},
    {NM_ITEM, MSG_PROJECT_SAVE_AS, EC_SAVEAS, 0},
    {NM_ITEM, MSG_NOTHING, EC_NOP, 0},
    {NM_ITEM, MSG_PROJECT_QUIT, EC_CANCEL, 0},

    {NM_TITLE, MSG_EDIT_MENU, EC_NOP, 0},
    {NM_ITEM, MSG_EDIT_CUT, EC_CUT, 0},
    {NM_ITEM, MSG_EDIT_COPY, EC_COPY, 0},
    {NM_ITEM, MSG_EDIT_PASTE, EC_PASTE, 0},
    {NM_ITEM, MSG_NOTHING, EC_NOP, 0},
    {NM_ITEM, MSG_EDIT_ERASE, EC_ERASE, 0},
    {NM_ITEM, MSG_NOTHING, EC_NOP, 0},
    {NM_ITEM, MSG_EDIT_UNDO, EC_UNDO, 0},
    {NM_ITEM, MSG_NOTHING, EC_NOP, 0},
    {NM_ITEM, MSG_EDIT_RESET_TO_DEFAULTS, EC_RESETALL, 0},
    {NM_ITEM, MSG_EDIT_LAST_SAVED, EC_LASTSAVED, 0},
    {NM_ITEM, MSG_EDIT_RESTORE, EC_RESTORE, 0},

    {NM_TITLE, MSG_OPTIONS_MENU, EC_NOP, 0},
    {NM_ITEM, MSG_OPTIONS_SAVE_ICONS, EC_SAVEICONS, CHECKIT | MENUTOGGLE},

    {NM_END, MSG_NOTHING, EC_NOP, 0}
};

/*****************************************************************************/

#define NW_LEFT		0
#define NW_TOP		0
#define NW_WIDTH	314
#define NW_HEIGHT	190
#define NW_IDCMP	(IDCMP_CLOSEWINDOW | IDCMP_MENUPICK | IDCMP_REFRESHWINDOW | BUTTONIDCMP | PALETTEIDCMP | SLIDERIDCMP)
#define NW_FLAGS	(WFLG_ACTIVATE | SIMPLE_REFRESH)
#define NW_MINWIDTH	NW_WIDTH
#define NW_MINHEIGHT	NW_HEIGHT
#define NW_MAXWIDTH	NW_WIDTH
#define NW_MAXHEIGHT	NW_HEIGHT
#define ZOOMWIDTH	200

#define	SB_HEIGHT	14
#define	SB_TOP		(NW_HEIGHT - SB_HEIGHT - 6)

#define	GB_WIDTH	138
#define	GB_LEFT		(NW_WIDTH - GB_WIDTH - 4)
#define	GC_WIDTH	87
#define	GS_LEFT		4
#define	GU_LEFT		113
#define	GC_LEFT		(NW_WIDTH - GC_WIDTH - 4)

#define	PA_LEFT		GB_LEFT
#define	SL_LEFT		(GB_LEFT + 44)	/* Was 44 */
#define	SL_WIDTH	(GB_WIDTH - 44)

/* main display gadgets */
struct EdGadget far EG[] =
{
    {BUTTON_KIND, GS_LEFT, SB_TOP, GC_WIDTH, SB_HEIGHT, MSG_SAVE_GAD, EC_SAVE, 0},
    {BUTTON_KIND, GU_LEFT, SB_TOP, GC_WIDTH, SB_HEIGHT, MSG_USE_GAD, EC_USE, 0},
    {BUTTON_KIND, GC_LEFT, SB_TOP, GC_WIDTH, SB_HEIGHT, MSG_CANCEL_GAD, EC_CANCEL, 0},

    {BUTTON_KIND, GB_LEFT, 4, GB_WIDTH, SB_HEIGHT, MSG_PTR_TEST_GAD, EC_TEST, 0},
    {BUTTON_KIND, GB_LEFT, 20, GB_WIDTH, SB_HEIGHT, MSG_PTR_CLEAR_GAD, EC_CLEAR, 0},
    {BUTTON_KIND, GB_LEFT, 36, GB_WIDTH, SB_HEIGHT, MSG_PTR_SET_GAD, EC_SET, 0},
    {BUTTON_KIND, GB_LEFT, 52, GB_WIDTH, SB_HEIGHT, MSG_PTR_RESET_GAD, EC_RESET, 0},

    {PALETTE_KIND, PA_LEFT, 70, GB_WIDTH, 40, NULL, EC_PALETTE, 0},

    {SLIDER_KIND, SL_LEFT, 114, SL_WIDTH, 11, MSG_PTR_RED_GAD, EC_RED, 0},
    {SLIDER_KIND, SL_LEFT, 127, SL_WIDTH, 11, MSG_PTR_GREEN_GAD, EC_GREEN, 0},
    {SLIDER_KIND, SL_LEFT, 140, SL_WIDTH, 11, MSG_PTR_BLUE_GAD, EC_BLUE, 0},
};


/*****************************************************************************/
d566 2
a567 3
BOOL
CreateDisplay (EdDataPtr ed)
{
d582 1
d584 5
a588 5
					     WA_Flags, NW_FLAGS,
					     WA_Width, ed->ed_Screen->Width,
					     WA_Height, ed->ed_Screen->Height,
					     WA_Borderless, FALSE,
					     WA_Backdrop, TRUE,
d606 1
a606 2
VOID
DisposeDisplay (EdDataPtr ed)
d631 14
d647 2
a648 2
    WORD echo_w = ed->ed_Width + 7 + 4;
    WORD echo_h = ed->ed_Height + 3 + 2;
d656 1
a656 1
	tx = ed->ed_GSketch->LeftEdge + ed->ed_GSketch->Width + 8;
d660 3
a662 3
	SetRast (&ed->ed_ShadowRP, 0);
	clipblit (&(ed->ed_PrefsWork.pp_RPort), 0, 0,
		  &ed->ed_ShadowRP, 0, 0, ed->ed_Width, ed->ed_Height,
d670 1
a670 1
		tx = ed->ed_GSketch->LeftEdge + ed->ed_GSketch->Width + 8;
d679 2
a680 2
	    clipblit (&ed->ed_ShadowRP, 0, 0,
		      ed->ed_Window->RPort, tx + 4, ty + 2,
d684 2
a685 2
	    clipblit (&(ed->ed_PrefsWork.pp_RPort), 0, 0,
		      ed->ed_Window->RPort, tx + 4, ty + 2,
d694 1
a694 2
VOID
RenderDisplay (EdDataPtr ed)
d696 2
a697 2
    WORD echo_w = ed->ed_Width + 7 + 4;
    WORD echo_h = ed->ed_Height + 3 + 2;
d710 1
a710 1
    tx = ed->ed_GSketch->LeftEdge + ed->ed_GSketch->Width + 4;
d724 1
a724 2
VOID
SetSliders (EdDataPtr ed)
d726 1
a726 2
    struct PointerPrefs *pp = &(ed->ed_PrefsWork);
    STRPTR ptr;
a727 2
    ptr = "%2lu";

d729 5
a733 3
				 GTSL_Level, ((pp->pp_CMap[(ed->ed_APen - 4)].red & 0xf0) >> 4),
				 GTSL_MaxLevelLen, 2,
				 GTSL_LevelFormat, ptr,
d735 1
a735 1
				 GA_Disabled, ((ed->ed_APen == 4) ? TRUE : FALSE),
d740 5
a744 3
				   GTSL_Level, ((pp->pp_CMap[(ed->ed_APen - 4)].green & 0xf0) >> 4),
				   GTSL_MaxLevelLen, 2,
				   GTSL_LevelFormat, ptr,
d746 1
a746 1
				   GA_Disabled, ((ed->ed_APen == 4) ? TRUE : FALSE),
d750 5
a754 3
				  GTSL_Level, ((pp->pp_CMap[(ed->ed_APen - 4)].blue & 0xf0) >> 4),
				  GTSL_MaxLevelLen, 2,
				  GTSL_LevelFormat, ptr,
d756 1
a756 1
				  GA_Disabled, ((ed->ed_APen == 4) ? TRUE : FALSE),
d762 1
a762 2
BOOL
upgadget (EdDataPtr ed, struct Gadget * g)
d789 1
a789 2
VOID
RenderGadgets (EdDataPtr ed)
d793 25
a829 1
				     GTPA_Depth, ed->ed_Depth - 1,
d831 3
a833 2
				     GTPA_ColorOffset, 4,
				     GTPA_IndicatorWidth, 36,
d839 15
d861 2
a862 2
			  GA_Left, ed->ed_Screen->WBorLeft + GS_LEFT,
			  GA_Top, 4 + ed->ed_Screen->WBorTop + ed->ed_Screen->Font->ta_YSize + 1,
d873 1
a877 8
    /* Use the colors from the new brush (was 12) */
    for (i = 5, j = 1; i < 8; i++, j++)
    {
	SetRGB4 (&(ed->ed_PScreen->ViewPort), i,
		 ed->ed_PrefsWork.pp_CMap[j].red >> 4,
		 ed->ed_PrefsWork.pp_CMap[j].green >> 4,
		 ed->ed_PrefsWork.pp_CMap[j].blue >> 4);
    }
d882 1
a882 2
VOID
SyncTextGadgets (EdDataPtr ed)
d891 1
d894 16
a909 6
    for (i = 17, j = 1; j < 8; i++, j++)
    {
	SetRGB4 (&(ed->ed_Screen->ViewPort), i,
		 (ed->ed_PrefsWork.pp_CMap[j].red & 0xf0) >> 4,
		 (ed->ed_PrefsWork.pp_CMap[j].green & 0xf0) >> 4,
		 (ed->ed_PrefsWork.pp_CMap[j].blue & 0xf0) >> 4);
d914 4
d923 1
a923 2
VOID
UpdateColor (EdDataPtr ed)
a924 1
    UWORD value, i;
d926 5
a930 10
    SetRGB4 (&(ed->ed_Screen->ViewPort), ed->ed_APen,
	     (ed->ed_PrefsWork.pp_CMap[(ed->ed_APen - 4)].red & 0xf0) >> 4,
	     (ed->ed_PrefsWork.pp_CMap[(ed->ed_APen - 4)].green & 0xf0) >> 4,
	     (ed->ed_PrefsWork.pp_CMap[(ed->ed_APen - 4)].blue & 0xf0) >> 4);

    for (i = 4; i < 8; i++)
    {
	value = ~GetRGB4 (ed->ed_PScreen->ViewPort.ColorMap, i);
	SetRGB4 (&(ed->ed_PScreen->ViewPort), 15 - i, ((value & 0xF00) >> 8), ((value & 0xF0) >> 4), (value & 0xF));
    }
d941 1
a941 1
	ed->ed_PrefsWork.pp_CMap[c] = ed->ed_PrefsInitial.pp_CMap[c];
d1001 1
a1001 1
	    ed->ed_PrefsWork.pp_CMap[(ed->ed_APen - 4)].red = icode << 4;
d1006 1
a1006 1
	    ed->ed_PrefsWork.pp_CMap[(ed->ed_APen - 4)].green = icode << 4;
d1011 1
a1011 1
	    ed->ed_PrefsWork.pp_CMap[(ed->ed_APen - 4)].blue = icode << 4;
d1017 22
@


38.9
log
@added stupid color complementing code!
@
text
@d1 2
a2 3
/*
 * pe_custom.c Pointer Preference Editor
 *
a7 1
#define	DL(x)	;
d17 1
d34 1
d46 1
d84 1
d97 1
d109 1
d126 1
d144 1
d147 1
d166 1
d209 1
@


38.8
log
@added TESTED flag.
@
text
@d187 1
a187 1
	SetRGB4 (&(ed->ed_PScreen->ViewPort), 15, 0, 0, 0);
d189 6
d581 2
a582 2
    /* Use the colors from the new brush */
    for (i = 5, j = 1; i < 12; i++, j++)
d623 1
d629 6
@


38.7
log
@added checked for bitmap.depth==1
@
text
@d203 1
a203 3

    /* Did they hit the cancel button? */
    if (ed->ed_Cancelled)
d211 1
d606 2
@


38.6
log
@removed %U from the color level display.
@
text
@d143 1
a143 1
	if (dri = GetScreenDrawInfo (wbscr))
d145 4
a148 2
	    for (i = 0; i <= NUMDRIPENS; i++)
		pens[i] = dri->dri_Pens[i];
d150 6
a155 1
	    FreeScreenDrawInfo (wbscr, dri);
@


38.5
log
@added window border.  centered window.
@
text
@a462 2
    if (LocaleBase)
	ptr = "%2lU";
@


38.4
log
@changed back to depth of 2
@
text
@d129 2
a130 1
    UWORD pens[NUMDRIPENS + 1];
d135 1
d145 1
a145 2
	    for (i = 0; i < NUMDRIPENS; i++)
	    {
a146 1
	    }
d152 1
d157 3
d164 1
a164 1
#if 1
a166 3
#else
					  SA_DisplayID, LORES_KEY,
#endif
d275 1
a275 1
#define	SB_TOP		(NW_HEIGHT - SB_HEIGHT - 4)
d278 1
a278 1
#define	GB_LEFT		(NW_WIDTH - GB_WIDTH)
d280 1
a280 1
#define	GS_LEFT		0
d282 1
a282 1
#define	GC_LEFT		(NW_WIDTH - GC_WIDTH)
d285 1
a285 1
#define	SL_LEFT		(GB_LEFT + 44)
d331 1
a331 1
					     WA_Borderless, TRUE,
d387 1
a387 1
	tx = ed->ed_GSketch->LeftEdge + ed->ed_GSketch->Width + 12;
d401 1
a401 1
		tx = ed->ed_GSketch->LeftEdge + ed->ed_GSketch->Width + 12;
d442 1
a442 1
    tx = ed->ed_GSketch->LeftEdge + ed->ed_GSketch->Width + 8;
d555 1
a555 1
			  GA_Left, ed->ed_Screen->WBorLeft,
@


38.3
log
@added repeat image
@
text
@d54 1
a54 1
	ed->ed_Depth = 4;
@


38.2
log
@updated to do V39 style menus properly.
@
text
@d1 2
a2 2
/* pe_custom.c
 * Pointer Preference Editor
d13 2
a14 1
VOID ProcessArgs (EdDataPtr ed, struct DiskObject * diskObj)
d39 2
a40 1
EdStatus InitEdData (EdDataPtr ed)
d42 3
d68 14
a81 2
			/* Make the default image */
			CopyFromDefault (ed);
d83 3
a85 1
			return (ES_NORMAL);
a94 1

d100 2
a101 1
VOID CopyPrefs (EdDataPtr ed, struct PointerPrefs * dp, struct PointerPrefs * sp)
a109 1

d126 2
a127 1
BOOL InitDisp (EdDataPtr ed)
a149 1

a151 1

d160 4
d165 1
d179 1
a179 1
	SetRGB4 (&(ed->ed_PScreen->ViewPort), 15,  0,  0,  0);
a186 1

d192 2
a193 1
VOID CleanUpEdData (EdDataPtr ed)
a204 1

d211 3
a218 1

d294 4
a297 4
    {BUTTON_KIND, GB_LEFT,   4, GB_WIDTH, SB_HEIGHT, MSG_PTR_TEST_GAD, EC_TEST, 0},
    {BUTTON_KIND, GB_LEFT,  20, GB_WIDTH, SB_HEIGHT, MSG_PTR_CLEAR_GAD, EC_CLEAR, 0},
    {BUTTON_KIND, GB_LEFT,  36, GB_WIDTH, SB_HEIGHT, MSG_PTR_SET_GAD, EC_SET, 0},
    {BUTTON_KIND, GB_LEFT,  52, GB_WIDTH, SB_HEIGHT, MSG_PTR_RESET_GAD, EC_RESET, 0},
d299 1
a299 1
    {PALETTE_KIND,PA_LEFT,  70, GB_WIDTH, 40, NULL, EC_PALETTE, 0},
d309 2
a310 1
BOOL CreateDisplay (EdDataPtr ed)
a341 1

d349 2
a350 1
VOID DisposeDisplay (EdDataPtr ed)
a358 1

d375 51
a425 1
VOID RenderDisplay (EdDataPtr ed)
d431 1
a431 2
    WORD tx, ty, bx, by;
    register WORD i;
d450 1
a450 17
    tx += 4;
    ty += 2;
    for (i = 0; i < 4; i++, tx += echo_w)
    {
	SetAPen (ed->ed_Window->RPort, i);

	if (i == 2)
	{
	    ty += echo_h;
	    tx = ed->ed_GSketch->LeftEdge + ed->ed_GSketch->Width + 8 + 4;
	}

	bx = tx + echo_w - 1;
	by = ty + echo_h - 1;

	RectFill (ed->ed_Window->RPort, tx, ty, bx, by);
    }
d455 2
a456 1
VOID SetSliders (EdDataPtr ed)
d493 2
a494 2
#if 0
BOOL downgadget (EdDataPtr ed, struct Gadget * g)
a495 25
    if (!(g->Flags & GFLG_SELECTED))
    {
	struct Window *w = ed->ed_Window;
	USHORT pos;

	/* Remove the gadget from the list */
	pos = RemoveGList (w, g, 1L);

	/* Turn it back on */
	g->Flags |= GFLG_SELECTED;

	/* Add it back to the list */
	AddGList (w, g, (LONG) pos, 1L, NULL);

	/* Refresh the entire gadget */
	RefreshGList (g, w, NULL, 1);

	return (TRUE);
    }

    return (FALSE);
}
#endif

/*****************************************************************************/
a496 2
BOOL upgadget (EdDataPtr ed, struct Gadget * g)
{
a515 1

d521 2
a522 1
VOID RenderGadgets (EdDataPtr ed)
a534 1

d559 1
a565 1

a569 1

d582 2
a583 1
VOID SyncTextGadgets (EdDataPtr ed)
d589 2
a590 1
EdStatus TestFunc (EdDataPtr ed)
d607 2
a608 1
VOID UpdateColor (EdDataPtr ed)
d610 1
d619 2
a620 1
VOID ResetColors (EdDataPtr ed)
d632 2
a633 1
VOID ProcessSpecialCommand (EdDataPtr ed, EdCommand ec)
d713 2
a714 1
EdCommand GetCommand (EdDataPtr ed)
d716 1
d722 2
a723 1
VOID GetSpecialCmdState (EdDataPtr ed, EdCommand ec, CmdStatePtr state)
d725 1
@


38.1
log
@initial rcs login
@
text
@d49 1
a49 1
	ed->ed_Depth = 3;
d110 3
d114 1
a114 1
    UWORD pens[1];
d117 18
a137 3

    /* Use the default pen array */
    pens[0] = -1;
@
