head     38.39;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


38.39
date     92.08.13.14.43.33;  author vertex;  state Exp;
branches ;
next     38.38;

38.38
date     92.08.13.13.33.18;  author vertex;  state Exp;
branches ;
next     38.37;

38.37
date     92.07.02.10.58.21;  author vertex;  state Exp;
branches ;
next     38.36;

38.36
date     92.06.24.14.48.50;  author vertex;  state Exp;
branches ;
next     38.35;

38.35
date     92.06.22.15.50.02;  author vertex;  state Exp;
branches ;
next     38.34;

38.34
date     92.03.02.11.15.26;  author vertex;  state Exp;
branches ;
next     38.33;

38.33
date     92.01.29.11.57.06;  author vertex;  state Exp;
branches ;
next     38.32;

38.32
date     92.01.21.17.35.41;  author vertex;  state Exp;
branches ;
next     38.31;

38.31
date     92.01.15.09.20.39;  author vertex;  state Exp;
branches ;
next     38.30;

38.30
date     92.01.13.13.06.16;  author vertex;  state Exp;
branches ;
next     38.29;

38.29
date     92.01.13.10.59.23;  author vertex;  state Exp;
branches ;
next     38.28;

38.28
date     92.01.10.12.10.00;  author vertex;  state Exp;
branches ;
next     38.27;

38.27
date     91.12.30.13.30.50;  author vertex;  state Exp;
branches ;
next     38.26;

38.26
date     91.11.11.11.18.24;  author vertex;  state Exp;
branches ;
next     38.25;

38.25
date     91.11.11.11.10.53;  author vertex;  state Exp;
branches ;
next     38.24;

38.24
date     91.11.11.11.00.41;  author vertex;  state Exp;
branches ;
next     38.23;

38.23
date     91.09.23.12.02.12;  author vertex;  state Exp;
branches ;
next     38.22;

38.22
date     91.09.19.15.41.36;  author vertex;  state Exp;
branches ;
next     38.21;

38.21
date     91.08.20.16.44.12;  author vertex;  state Exp;
branches ;
next     38.20;

38.20
date     91.08.20.16.38.49;  author vertex;  state Exp;
branches ;
next     38.19;

38.19
date     91.08.20.16.36.36;  author vertex;  state Exp;
branches ;
next     38.18;

38.18
date     91.08.20.09.41.32;  author vertex;  state Exp;
branches ;
next     38.17;

38.17
date     91.08.12.12.43.25;  author vertex;  state Exp;
branches ;
next     38.16;

38.16
date     91.08.06.18.25.01;  author vertex;  state Exp;
branches ;
next     38.15;

38.15
date     91.08.06.14.15.23;  author vertex;  state Exp;
branches ;
next     38.14;

38.14
date     91.07.19.16.23.14;  author vertex;  state Exp;
branches ;
next     38.13;

38.13
date     91.07.15.11.29.57;  author vertex;  state Exp;
branches ;
next     38.12;

38.12
date     91.07.15.10.41.35;  author vertex;  state Exp;
branches ;
next     38.11;

38.11
date     91.07.10.17.10.21;  author vertex;  state Exp;
branches ;
next     38.10;

38.10
date     91.07.02.15.40.12;  author vertex;  state Exp;
branches ;
next     38.9;

38.9
date     91.07.02.15.22.17;  author vertex;  state Exp;
branches ;
next     38.8;

38.8
date     91.07.01.17.08.06;  author vertex;  state Exp;
branches ;
next     38.7;

38.7
date     91.07.01.11.52.30;  author vertex;  state Exp;
branches ;
next     38.6;

38.6
date     91.06.28.15.08.01;  author vertex;  state Exp;
branches ;
next     38.5;

38.5
date     91.06.28.13.18.55;  author vertex;  state Exp;
branches ;
next     38.4;

38.4
date     91.06.28.12.50.16;  author vertex;  state Exp;
branches ;
next     38.3;

38.3
date     91.06.24.16.38.56;  author vertex;  state Exp;
branches ;
next     38.2;

38.2
date     91.06.24.13.25.53;  author vertex;  state Exp;
branches ;
next     38.1;

38.1
date     91.06.21.13.31.25;  author vertex;  state Exp;
branches ;
next     ;


desc
@Prefs editor shell - main entry point and event loop
@


38.39
log
@*** empty log message ***
@
text
@
/* includes */
#include <libraries/asl.h>
#include <workbench/startup.h>
#include <workbench/workbench.h>
#include <intuition/intuition.h>
#include <dos/dosextens.h>
#include <dos/dos.h>
#include <exec/memory.h>
#include <exec/execbase.h>
#include <exec/libraries.h>
#include <string.h>

/* prototypes */
#include <clib/exec_protos.h>
#include <clib/icon_protos.h>
#include <clib/dos_protos.h>
#include <clib/intuition_protos.h>
#include <clib/graphics_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/asl_protos.h>
#include <clib/locale_protos.h>
#include <clib/wb_protos.h>
#include <clib/alib_protos.h>
#include <clib/utility_protos.h>
#include <clib/layers_protos.h>

/* direct ROM interface */
#include <pragmas/exec_pragmas.h>
#include <pragmas/icon_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/gadtools_pragmas.h>
#include <pragmas/asl_pragmas.h>
#include <pragmas/locale_pragmas.h>
#include <pragmas/wb_pragmas.h>
#include <pragmas/utility_pragmas.h>
#include <pragmas/layers_pragmas.h>

/* application includes */
#include "pe_custom.h"
#include "pe_strings.h"
#include "pe_utils.h"


/*****************************************************************************/


VOID EventLoop(EdDataPtr ed);
VOID OpenLib(EdDataPtr ed, struct Library **libBase, STRPTR libName,
             AppStringsID error);
VOID ProcessCommand(EdDataPtr ed, EdCommand ec);
VOID WriteIcon(EdDataPtr ed, STRPTR name);
BOOL FileRequest(EdDataPtr ed, BOOL mode);
UBYTE DoDiskObj(EdDataPtr ed, STRPTR name);
BOOL CreateDisp(EdDataPtr ed);
VOID DisposeDisp(EdDataPtr ed);
VOID RenderGadg(EdDataPtr ed);


/*****************************************************************************/


#define A_EDIT 0
#define A_USE  1
#define A_SAVE 2


int main(int argc, char *argv)
{
struct ExecBase   *SysBase = (*((struct ExecBase **) 4));
struct Process	  *process;
struct WBStartup  *wbMsg = NULL;
struct WBArg      *wbArg;
struct MsgPort    *rendezVous;
EdDataPtr          ed = NULL;
LONG               failureLevel = RETURN_FAIL;
LONG		   failureCode  = 0;
STRPTR             presetName = NULL;
BYTE               action = A_EDIT;
BPTR		   oldLock;
BPTR               progLock;
AppStringsID       result;
struct Message    *msg;
APTR               udata;

    process = (struct Process *)SysBase->ThisTask;
    if (!(process->pr_CLI))
    {
        WaitPort(&process->pr_MsgPort);
        wbMsg = (struct WBStartup *) GetMsg(&process->pr_MsgPort);
    }

    if (SysBase->LibNode.lib_Version < 39)
    {
	failureCode = ERROR_INVALID_RESIDENT_LIBRARY;
    }
    else
    {
        Forbid();
        if (rendezVous = FindPort(PORT_NAME))
        {
            Signal(rendezVous->mp_SigTask,SIGBREAKF_CTRL_F);
            failureLevel = RETURN_WARN;
        }
        else
        {
            if (ed = AllocVec(sizeof(EdData),MEMF_PUBLIC|MEMF_CLEAR))
            {
                udata                             = SysBase->ThisTask->tc_UserData;
                SysBase->ThisTask->tc_UserData    = (APTR)ed;
                ed->ed_RendezVous.mp_Node.ln_Name = PORT_NAME;
                ed->ed_RendezVous.mp_Node.ln_Pri  = -128;
                ed->ed_RendezVous.mp_Node.ln_Type = NT_MSGPORT;
                ed->ed_RendezVous.mp_SigTask      = (struct Task *)process;
                ed->ed_RendezVous.mp_Flags        = PA_IGNORE;
                AddPort(&ed->ed_RendezVous);
            }
            else
            {
                failureLevel = RETURN_FAIL;
                failureCode  = ERROR_NO_FREE_STORE;
            }
        }
        Permit();

        if (ed)
        {
            ed->ed_SysBase           = SysBase;
            ed->ed_TextAttr.ta_Name  = "topaz.font";
            ed->ed_TextAttr.ta_YSize = 8;
            ed->ed_TextAttr.ta_Style = FS_NORMAL;
            ed->ed_TextAttr.ta_Flags = FPF_ROMFONT;
            ed->ed_SaveIcons         = (wbMsg != NULL);
            ed->ed_Quit              = FALSE;
            ed->ed_Cancelled         = FALSE;
            ed->ed_InitFail          = FALSE;
            ed->ed_CheckCmdState     = TRUE;

            ed->ed_AppPort.mp_Node.ln_Type = NT_MSGPORT;
            ed->ed_AppPort.mp_SigTask      = (struct Task *)process;
            ed->ed_AppPort.mp_Flags        = PA_SIGNAL;
            ed->ed_AppPort.mp_SigBit       = AllocSignal(-1);
            NewList(&ed->ed_AppPort.mp_MsgList);

            OpenLib(ed,&ed->ed_IntuitionBase,"intuition.library", MSG_NOTHING);
            OpenLib(ed,&ed->ed_GfxBase,      "graphics.library",  MSG_NOTHING);
            OpenLib(ed,&ed->ed_DOSBase,      "dos.library",       MSG_NOTHING);
            OpenLib(ed,&ed->ed_GadToolsBase, "gadtools.library",  MSG_NOTHING);
            OpenLib(ed,&ed->ed_IconBase,     "icon.library",      MSG_NOTHING);
            OpenLib(ed,&ed->ed_AslBase,      "asl.library",       MSG_NO_ASL_LIBRARY);
            OpenLib(ed,&ed->ed_IFFParseBase, "iffparse.library",  MSG_NO_IFFPARSE_LIBRARY);
            OpenLib(ed,&ed->ed_UtilityBase,  "utility.library",   MSG_NOTHING);
#ifdef LOCKLAYERINFO
            OpenLib(ed,&ed->ed_LayersBase,   "layers.library",    MSG_NOTHING);
#endif

#ifdef DATATYPES
            OpenLib(ed,&ed->ed_DataTypesBase,"datatypes.library", DATATYPE_ERROR);
#endif

            if (!ed->ed_InitFail)
            {
                CurrentDir(oldLock=CurrentDir(NULL));

                if (ed->ed_LocaleBase = OpenLibrary("locale.library",38))
                {
                    ed->ed_LocaleInfo.li_LocaleBase = ed->ed_LocaleBase;
                    ed->ed_LocaleInfo.li_Catalog = OpenCatalogA(NULL,"Sys/prefs.catalog",NULL);
                }

                result = InitEdData(ed);
                if (result == ES_NORMAL)
                {
                    if (wbMsg)
                    {
                        wbArg = wbMsg->sm_ArgList;
                        CurrentDir(wbArg->wa_Lock);
                        if (progLock = Lock(wbArg->wa_Name,ACCESS_READ))
                        {
                            if (!NameFromLock(progLock,ed->ed_ProgramPath,PROGPATHSIZE))
                            {
                                ed->ed_InitFail = TRUE;
                            }
                            UnLock(progLock);

                            action = DoDiskObj(ed,wbArg->wa_Name);

                            if (wbMsg->sm_NumArgs > 1)
                            {
                                wbArg++;
                                presetName = wbArg->wa_Name;
                                CurrentDir(wbArg->wa_Lock);
                                action = DoDiskObj(ed,presetName);
                            }
                        }
                        else
                        {
                            ed->ed_InitFail = TRUE;
                        }
                    }
                    else
                    {
                        ed->ed_InitFail = TRUE;
                        if (GetProgramName(ed->ed_NameBuf,NAMEBUFSIZE))
                        {
                            strcpy(ed->ed_NameBuf,FilePart(ed->ed_NameBuf));
                            if (GetProgramDir())
                            {
                                if (NameFromLock(GetProgramDir(),ed->ed_ProgramPath,PROGPATHSIZE))
                                {
                                    ed->ed_InitFail = FALSE;
                                }
                            }
                            else
                            {
                                ed->ed_InitFail = FALSE;
                                strcpy(ed->ed_ProgramPath,"SYS:Prefs");
                            }

                            if (!ed->ed_InitFail)
                                ed->ed_InitFail = !AddPart(ed->ed_ProgramPath,ed->ed_NameBuf,PROGPATHSIZE);
                        }

                        memset(ed->ed_Args,0,sizeof(ed->ed_Args));
                        if (ed->ed_RdArgs = ReadArgs(TEMPLATE,ed->ed_Args,NULL))
                        {
                            presetName = (STRPTR)ed->ed_Args[OPT_FROM];

                            if (ed->ed_Args[OPT_USE])
                                action = A_USE;
                            if (ed->ed_Args[OPT_SAVE])
                                action = A_SAVE;
                            if (ed->ed_Args[OPT_EDIT])
                                action = A_EDIT;

                            if (ed->ed_Args[OPT_SCREEN])
                                ed->ed_PubScreenName = (STRPTR)ed->ed_Args[OPT_SCREEN];

                            ProcessArgs(ed,NULL);
                        }
                        else
                        {
                            ed->ed_InitFail = TRUE;
                            PrintFault(IoErr(),NULL);
                        }
                    }

		    if (!ed->ed_InitFail)
		    {
		        CopyPrefs(ed,&ed->ed_PrefsWork,&ed->ed_PrefsDefaults);
                        if (presetName)
                        {
                            if ((result = OpenPrefs(ed,presetName)) != ES_NORMAL)
                            {
                                ShowError2(ed,result);  /* couldn't open requested presets */
                                CopyPrefs(ed,&ed->ed_PrefsWork,&ed->ed_PrefsDefaults);
                            }
                        }
                        else
                        {
                            if ((result = OpenPrefs(ed,ENV_NAME)) != ES_NORMAL)
                            {
                                if (ed->ed_SecondaryResult != ERROR_OBJECT_NOT_FOUND)
                                    ShowError2(ed,result);  /* couldn't load saved prefs */
                                CopyPrefs(ed,&ed->ed_PrefsWork,&ed->ed_PrefsDefaults);
                            }
                        }

                        CopyPrefs(ed,&ed->ed_PrefsInitial,&ed->ed_PrefsWork);

                        if (action == A_SAVE)
                        {
                            ProcessCommand(ed,EC_SAVE);
                            failureLevel = RETURN_OK;
                        }
                        else if (action == A_USE)
                        {
                            ProcessCommand(ed,EC_USE);
                            failureLevel = RETURN_OK;
                        }
                        else
                        {
                            if (InitDisp(ed))
                            {
                                if (ed->ed_Font = OpenFont(&ed->ed_TextAttr))
                                {
#ifndef USES_OWN_SCREEN
                                    if (ed->ed_Screen = LockPubScreen(ed->ed_PubScreenName))
                                    {
#endif
                                        if (ed->ed_VisualInfo = GetVisualInfoA(ed->ed_Screen,NULL))
                                        {
                                            if (ed->ed_DrawInfo = GetScreenDrawInfo(ed->ed_Screen))
                                            {
                                                if (CreateDisp(ed))
                                                {
                                                    EventLoop(ed);
                                                    DisposeDisp(ed);

                                                    ed->ed_SecondaryResult = 0;
                                                    failureLevel = RETURN_OK;
                                                }
                                                FreeScreenDrawInfo(ed->ed_Screen,ed->ed_DrawInfo);
                                            }
                                            FreeVisualInfo(ed->ed_VisualInfo);
                                        }
#ifndef USES_OWN_SCREEN
                                        UnlockPubScreen(NULL,ed->ed_Screen);
                                    }
#endif
                                    CloseFont(ed->ed_Font);
                                }
                            }
                        }
                    }
                    CleanUpEdData(ed);

                    if (failureCode = ed->ed_SecondaryResult)
                        failureLevel = RETURN_FAIL;
                }
                else
                {
                    ShowError2(ed,result);
                }
                CurrentDir(oldLock);

                FreeAslRequest(ed->ed_FileReq);
            }

            RemPort(&ed->ed_RendezVous);
            if (ed->ed_RdArgs)
                FreeArgs(ed->ed_RdArgs);

	    if (ed->ed_LocaleBase)
                CloseCatalog(ed->ed_LocaleInfo.li_Catalog);

	    while (msg = GetMsg(&ed->ed_AppPort))
	        ReplyMsg(msg);

#ifdef DATATYPES
            CloseLibrary(ed->ed_DataTypesBase);
#endif

#ifdef LOCKLAYERINFO
            CloseLibrary(ed->ed_LayersBase);
#endif

            CloseLibrary(ed->ed_IntuitionBase);
            CloseLibrary(ed->ed_GfxBase);
            CloseLibrary(ed->ed_DOSBase);
            CloseLibrary(ed->ed_GadToolsBase);
            CloseLibrary(ed->ed_AslBase);
            CloseLibrary(ed->ed_IFFParseBase);
            CloseLibrary(ed->ed_IconBase);
            CloseLibrary(ed->ed_UtilityBase);
            CloseLibrary(ed->ed_LocaleBase);
            CloseLibrary(ed->ed_WorkbenchBase);
            FreeSignal(ed->ed_AppPort.mp_SigBit);

            SysBase->ThisTask->tc_UserData = udata;
            FreeVec(ed);
        }
    }

    if (wbMsg)
    {
    	Forbid();
    	ReplyMsg(wbMsg);
    }

    process->pr_Result2 = failureCode;  /* can't use SetIoErr() cause DOS ain't open! */
    return(failureLevel);
}


/*****************************************************************************/


#define SysBase ed->ed_SysBase


/*****************************************************************************/


VOID OpenLib(EdDataPtr ed, struct Library **libBase, STRPTR libName,
             AppStringsID error)
{
    if (!ed->ed_InitFail)
    {
        if (!(*libBase = OpenLibrary(libName,38)))   /* should be 39, but... */
        {
            ed->ed_InitFail = TRUE;
            if (error != MSG_NOTHING)
                ShowError1(ed,error);
        }
    }
}


/*****************************************************************************/


UBYTE DoDiskObj(EdDataPtr ed, STRPTR name)
{
struct DiskObject *diskObj;
STRPTR             tvalue;
UBYTE              action = A_EDIT;

    if (diskObj = GetDiskObject(name))
    {
        if (tvalue = FindToolType(diskObj->do_ToolTypes,"ACTION"))
        {
            if (MatchToolValue(tvalue,"EDIT"))
                action = A_EDIT;
            if (MatchToolValue(tvalue,"USE"))
                action = A_USE;
            if (MatchToolValue(tvalue,"SAVE"))
                action = A_SAVE;
        }

        if (tvalue = FindToolType(diskObj->do_ToolTypes,"CREATEICONS"))
        {
            if (!Stricmp(tvalue,"YES"))
                ed->ed_SaveIcons = TRUE;
            else if (!Stricmp(tvalue,"NO"))
                ed->ed_SaveIcons = FALSE;
        }

        if (tvalue = FindToolType(diskObj->do_ToolTypes,"PUBSCREEN"))
        {
            ed->ed_PubScreenName = ed->ed_ScreenNameBuf;
            strncpy(ed->ed_ScreenNameBuf,tvalue,sizeof ed->ed_ScreenNameBuf);
        }

        ProcessArgs(ed,diskObj);
        FreeDiskObject(diskObj);
    }

    return(action);
}


/*****************************************************************************/


VOID ProcessCommand(EdDataPtr ed, EdCommand ec)
{
EdStatus result = ES_NORMAL;

    if (ed->ed_Window)
        SyncTextGadgets(ed);

    ed->ed_CheckCmdState = TRUE;
    switch (ec)
    {
        case EC_ACTIVATE : ScreenToFront(ed->ed_Window->WScreen);
                           if (!(ed->ed_Window->Flags & WFLG_BACKDROP))
                               WindowToFront(ed->ed_Window);
                           ActivateWindow(ed->ed_Window);
            		   if (ed->ed_Window->Flags & ZOOMED)
                	       ZipWindow(ed->ed_Window);
                           break;

        case EC_OPEN     : if (FileRequest(ed,TRUE))
                           {
                               result = OpenPrefs(ed,ed->ed_NameBuf);
                               RenderGadg(ed);
                           }
                           break;

        case EC_SAVE     : if ((result = SavePrefs(ed,ARC_NAME)) == ES_NORMAL)
                           {
                               DisposeDisp(ed);
                               ed->ed_Quit = TRUE;
			       result = SavePrefs(ed,ENV_NAME);
                           }
                           break;

        case EC_USE      : DisposeDisp(ed);
                           ed->ed_Quit = TRUE;
                           result = SavePrefs(ed,ENV_NAME);
                           break;

        case EC_SAVEAS   : if (FileRequest(ed,FALSE))
                               if ((result = SavePrefs(ed,ed->ed_NameBuf)) == ES_NORMAL)
                                   if (ed->ed_SaveIcons)
                                       WriteIcon(ed,ed->ed_NameBuf);

                           break;

        case EC_RESETALL : CopyPrefs(ed,&ed->ed_PrefsWork,&ed->ed_PrefsDefaults);
                           RenderGadg(ed);
                           break;

        case EC_LASTSAVED: result = OpenPrefs(ed,ARC_NAME);
                           RenderGadg(ed);
                           break;

        case EC_RESTORE  : CopyPrefs(ed,&ed->ed_PrefsWork,&ed->ed_PrefsInitial);
                           RenderGadg(ed);
                           break;

        case EC_CANCEL   : ed->ed_Quit      = TRUE;
                           ed->ed_Cancelled = TRUE;
                           break;

        case EC_SAVEICONS: ed->ed_SaveIcons = !ed->ed_SaveIcons;
                           break;

        case EC_NOP      : break;

        default          : ProcessSpecialCommand(ed,ec);
                           break;
    }

    if (result != ES_NORMAL)
        ShowError2(ed,result);
}


/*****************************************************************************/


VOID GetCmdState(EdDataPtr ed, EdCommand ec, CmdStatePtr state)
{
    switch (ec)
    {
        case EC_OPEN     :
        case EC_SAVE     :
        case EC_USE      :
        case EC_SAVEAS   :
        case EC_RESETALL :
        case EC_LASTSAVED:
        case EC_RESTORE  :
        case EC_CANCEL   :
        case EC_NOP      : state->cs_Available = TRUE;
                           state->cs_Selected  = TRUE;
                           break;


        case EC_SAVEICONS: state->cs_Available = TRUE;
                           state->cs_Selected  = ed->ed_SaveIcons;
                           break;

        default          : GetSpecialCmdState(ed,ec,state);
                           break;
    }
}


/*****************************************************************************/


VOID ProcessItem(EdDataPtr ed, struct MenuItem *item)
{
CmdState state;

    if ((EdCommand)MENU_USERDATA(item) != EC_NOP)
    {
        GetCmdState(ed,(EdCommand)MENU_USERDATA(item),&state);

        if (state.cs_Available)
            item->Flags |= ITEMENABLED;
        else
            item->Flags &= ~ITEMENABLED;

        if (state.cs_Selected)
            item->Flags |= CHECKED;
        else
            item->Flags &= ~CHECKED;
    }
}


/*****************************************************************************/


VOID EventLoop(EdDataPtr ed)
{
struct IntuiMessage *intuiMsg;
struct MenuItem     *menuItem;
struct MenuItem     *subItem;
struct Menu         *menu;
UWORD                menuNum;
struct Gadget       *gadget;
ULONG                sigs;
struct WBArg        *wbArg;
struct AppMessage   *appMsg;
struct Gadget       *activeGad;
BPTR                 oldLock;
enum EdStatus        result;

    while (!ed->ed_Quit)
    {
        if (ed->ed_CheckCmdState && ((SetSignal(0,0) & (1L << window->UserPort->mp_SigBit)) == 0))
        {
            menu = window->MenuStrip;
            ClearMenuStrip(window);

            while (menu)
            {
                menuItem = menu->FirstItem;
                while (menuItem)
                {
                    subItem = menuItem->SubItem;
                    while (subItem)
                    {
                        ProcessItem(ed,subItem);
                        subItem = subItem->NextItem;
                    }
                    ProcessItem(ed,menuItem);
                    menuItem = menuItem->NextItem;
                }
                menu = menu->NextMenu;
            }

            ResetMenuStrip(window,ed->ed_Menus);
            ed->ed_CheckCmdState = FALSE;
        }

        sigs = Wait(1L<<window->UserPort->mp_SigBit | 1L<<ed->ed_AppPort.mp_SigBit | SIGBREAKF_CTRL_F | SIGBREAKF_CTRL_C);

        if (sigs & SIGBREAKF_CTRL_F)
            ProcessCommand(ed,EC_ACTIVATE);

        if (sigs & SIGBREAKF_CTRL_C)
        {
            ed->ed_Quit      = TRUE;
            ed->ed_Cancelled = TRUE;
        }

	while ((!ed->ed_Quit) && (appMsg = (struct AppMessage *)GetMsg(&ed->ed_AppPort)))
	{
            if (appMsg->am_NumArgs)
            {
                if (appMsg->am_Type == MTYPE_APPWINDOW)
                    ActivateWindow(window);
                wbArg = appMsg->am_ArgList;
                oldLock = CurrentDir(wbArg->wa_Lock);
                NameFromLock(wbArg->wa_Lock,ed->ed_NameBuf,NAMEBUFSIZE);
                AddPart(ed->ed_NameBuf,wbArg->wa_Name,NAMEBUFSIZE);
                if ((result = OpenPrefs(ed,wbArg->wa_Name)) != ES_NORMAL)
                    ShowError2(ed,result);
                RenderGadg(ed);
                CurrentDir(oldLock);
            }
            else
            {
                ProcessCommand(ed,EC_ACTIVATE);
            }
            ReplyMsg(appMsg);
        }

	while ((!ed->ed_Quit) && (intuiMsg = GT_GetIMsg(window->UserPort)))
	{
            ed->ed_CurrentMsg = *intuiMsg;
	    GT_ReplyIMsg(intuiMsg);

	    gadget = (struct Gadget *)ed->ed_CurrentMsg.IAddress;
	    switch (ed->ed_CurrentMsg.Class)
	    {
		case IDCMP_REFRESHWINDOW:
#ifdef LOCKLAYERINFO
					  LockLayerInfo(&ed->ed_CurrentMsg.IDCMPWindow->WScreen->LayerInfo);
#endif

                                          GT_BeginRefresh(ed->ed_CurrentMsg.IDCMPWindow);
                                          RenderDisplay(ed);
                                          GT_EndRefresh(ed->ed_CurrentMsg.IDCMPWindow,TRUE);

#ifdef LOCKLAYERINFO
					  UnlockLayerInfo(&ed->ed_CurrentMsg.IDCMPWindow->WScreen->LayerInfo);
#endif
                                          break;

#ifdef SEND_EC_CLOSEGADGET
		case IDCMP_CLOSEWINDOW  : ProcessCommand(ed,EC_CLOSEGADGET);
		                          break;
#else
		case IDCMP_CLOSEWINDOW  : ProcessCommand(ed,EC_CANCEL);
                                          break;
#endif

		case IDCMP_MENUPICK     : menuNum = intuiMsg->Code;
                                          while ((menuNum != MENUNULL) && (!ed->ed_Quit))
                                          {
                                              menuItem = ItemAddress(intuiMsg->IDCMPWindow->MenuStrip,menuNum);
                                              ProcessCommand(ed,(EdCommand)MENU_USERDATA(menuItem));
                                              menuNum = menuItem->NextSelect;
                                          }
                                          break;

		case IDCMP_GADGETDOWN   : activeGad = gadget;
		case IDCMP_MOUSEMOVE    : ProcessCommand(ed,(EdCommand)activeGad->GadgetID);
                                          break;

		case IDCMP_GADGETUP     : ProcessCommand(ed,(EdCommand)gadget->GadgetID);
                                          break;

                default                 : ProcessCommand(ed,GetCommand(ed));
	    }
	}
    }
}


/*****************************************************************************/


BOOL CreateDisp(EdDataPtr ed)
{
struct Process *process;

    if (CreateDisplay(ed))
    {
        SetFont(window->RPort,ed->ed_Font);
        SetMenuStrip(window,ed->ed_Menus);
        GT_RefreshWindow(window,NULL);
        RenderDisplay(ed);

        if (ed->ed_WorkbenchBase = OpenLibrary("workbench.library",39))
        {
            ed->ed_AppWindow = AddAppWindowA(0,NULL,window,&ed->ed_AppPort,NULL);
/*
            ed->ed_AppMenu   = AddAppMenuItemA(0,NULL,window->Title,&ed->ed_AppPort,NULL);
*/
        }

        process = (struct Process *)SysBase->ThisTask;
        ed->ed_OldWindowPtr = process->pr_WindowPtr;
        process->pr_WindowPtr = ed->ed_Window;
        return(TRUE);
    }

    return(FALSE);
}


/*****************************************************************************/


VOID DisposeDisp(EdDataPtr ed)
{
struct Process *process;

    if (ed->ed_Window)
    {
        process = (struct Process *)SysBase->ThisTask;
        process->pr_WindowPtr = ed->ed_OldWindowPtr;
/*
	if (ed->ed_AppMenu)
	    RemoveAppMenuItem(ed->ed_AppMenu);
*/
	if (ed->ed_AppWindow)
	    RemoveAppWindow(ed->ed_AppWindow);

        DisposeDisplay(ed);
        ed->ed_Window = NULL;
    }
}


/*****************************************************************************/


VOID RenderGadg(EdDataPtr ed)
{
    if (ed->ed_Window)
        RenderGadgets(ed);
}


/*****************************************************************************/


UWORD far PrefImageData[] = {
    0x0000, 0x0000, 0x0004, 0x0000,
    0x0000, 0x0000, 0x0001, 0x0000,
    0x0000, 0x07FF, 0x8000, 0x4000,
    0x0000, 0x1800, 0x6000, 0x1000,
    0x0000, 0x20FC, 0x1000, 0x0800,
    0x0000, 0x4102, 0x0800, 0x0C00,
    0x0000, 0x4082, 0x0800, 0x0C00,
    0x0000, 0x4082, 0x0800, 0x0C00,
    0x0000, 0x2104, 0x0800, 0x0C00,
    0x0000, 0x1E18, 0x1000, 0x0C00,
    0x0000, 0x0060, 0x2000, 0x0C00,
    0x0000, 0x0080, 0xC000, 0x0C00,
    0x0000, 0x0103, 0x0000, 0x0C00,
    0x0000, 0x021C, 0x0000, 0x0C00,
    0x0000, 0x0108, 0x0000, 0x0C00,
    0x0000, 0x00F0, 0x0000, 0x0C00,
    0x0000, 0x0108, 0x0000, 0x0C00,
    0x0000, 0x0108, 0x0000, 0x0C00,
    0x4000, 0x00F0, 0x0000, 0x0C00,
    0x1000, 0x0000, 0x0000, 0x0C00,
    0x0400, 0x0000, 0x0000, 0x0C00,
    0x01FF, 0xFFFF, 0xFFFF, 0xFC00,
    0x0000, 0x0000, 0x0000, 0x0000,
/**/
    0xFFFF, 0xFFFF, 0xFFF8, 0x0000,
    0xD555, 0x5555, 0x5556, 0x0000,
    0xD555, 0x5000, 0x5555, 0x8000,
    0xD555, 0x47FF, 0x9555, 0x6000,
    0xD555, 0x5F03, 0xE555, 0x5000,
    0xD555, 0x3E55, 0xF555, 0x5000,
    0xD555, 0x3F55, 0xF555, 0x5000,
    0xD555, 0x3F55, 0xF555, 0x5000,
    0xD555, 0x5E53, 0xF555, 0x5000,
    0xD555, 0x4147, 0xE555, 0x5000,
    0xD555, 0x551F, 0xD555, 0x5000,
    0xD555, 0x557F, 0x1555, 0x5000,
    0xD555, 0x54FC, 0x5555, 0x5000,
    0xD555, 0x55E1, 0x5555, 0x5000,
    0xD555, 0x54F5, 0x5555, 0x5000,
    0xD555, 0x5505, 0x5555, 0x5000,
    0xD555, 0x54F5, 0x5555, 0x5000,
    0xD555, 0x54F5, 0x5555, 0x5000,
    0x3555, 0x5505, 0x5555, 0x5000,
    0x0D55, 0x5555, 0x5555, 0x5000,
    0x0355, 0x5555, 0x5555, 0x5000,
    0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000,
};


STRPTR far TTypes[] =
{
    "ACTION=USE",
    NULL
};


struct Image far PrefImage =
{
    0, 0,		/* LeftEdge, TopEdge */
    54, 23,		/* Width, Height */
    2,			/* Depth */
    PrefImageData,	/* ImageData */
    0x033, 0x00,	/* PlanePick, PlaneOnOff */
    NULL		/* NextImage */
};

struct DiskObject far PrefObject =
{
    WB_DISKMAGIC,
    WB_DISKVERSION,

    NULL,
    0, 0,
    54, 23,
    GADGHBOX|GADGIMAGE,
    RELVERIFY|GADGIMMEDIATE,
    BOOLGADGET,
    (APTR)&PrefImage,
    NULL,
    NULL,
    NULL, NULL, NULL,
    NULL,

    WBPROJECT,
    NULL,
    TTypes,
    NO_ICON_POSITION,
    NO_ICON_POSITION,
    NULL, NULL, NULL
};


VOID WriteIcon(EdDataPtr ed,STRPTR name)
{
struct DiskObject diskObj;

    diskObj                = PrefObject;
    diskObj.do_DefaultTool = ed->ed_ProgramPath;
    PutDiskObject(name,&diskObj);
}


/*****************************************************************************/


#undef SysBase
#define ASM __asm
#define REG(x) register __## x

VOID ASM IntuiHook(REG(a0) struct Hook *hook,
                   REG(a2) struct FileRequester *fr,
                   REG(a1) struct IntuiMessage *intuiMsg)
{
EdDataPtr        ed;
struct ExecBase *SysBase = (*((struct ExecBase **) 4));

    if (intuiMsg->Class == IDCMP_REFRESHWINDOW)
    {
        ed = (EdDataPtr)SysBase->ThisTask->tc_UserData;

#ifdef LOCKLAYERINFO
	LockLayerInfo(&intuiMsg->IDCMPWindow->WScreen->LayerInfo);
#endif

        GT_BeginRefresh(intuiMsg->IDCMPWindow);
        RenderDisplay(ed);
        GT_EndRefresh(intuiMsg->IDCMPWindow,TRUE);

#ifdef LOCKLAYERINFO
	UnlockLayerInfo(&intuiMsg->IDCMPWindow->WScreen->LayerInfo);
#endif
    }
}


BOOL FileRequest(EdDataPtr ed, BOOL mode)
{
BOOL        success;
struct Hook hook;

    hook.h_Entry = IntuiHook;    /* what should this be cast to to avoid warnings?? */

    if (!ed->ed_FileReq)
    {
        if (!(ed->ed_FileReq = AllocPrefsRequest(ed, ASL_FileRequest,
                                                 ASLFR_InitialDrawer,   PRESET_DIR,
                                                 ASLFR_InitialFile,     PRESET_NAME,
                                                 ASLFR_InitialLeftEdge, window->LeftEdge+12,
                                                 ASLFR_InitialTopEdge,  window->TopEdge+12,
                                                 ASLFR_Window,          window,
                                                 ASLFR_SleepWindow,     TRUE,
                                                 ASLFR_RejectIcons,     TRUE,
                                                 TAG_DONE)))
        {
            ShowError2(ed,ES_NO_MEMORY);
            return(FALSE);
        }
    }

    if (mode)
	success = RequestPrefsFile(ed,ASLFR_TitleText,    GetString(&ed->ed_LocaleInfo,MSG_REQ_LOAD),
                                      ASLFR_DoSaveMode,   FALSE,
                                      ASLFR_IntuiMsgFunc, &hook,
	                              TAG_DONE);
    else
	success = RequestPrefsFile(ed,ASLFR_TitleText,    GetString(&ed->ed_LocaleInfo,MSG_REQ_SAVE),
                                      ASLFR_DoSaveMode,   TRUE,
                                      ASLFR_IntuiMsgFunc, &hook,
	                              TAG_DONE);

    if (success)
    {
	stccpy(ed->ed_NameBuf,ed->ed_FileReq->rf_Dir, NAMEBUFSIZE);
	AddPart(ed->ed_NameBuf,ed->ed_FileReq->rf_File, NAMEBUFSIZE);
	return(TRUE);
    }

    return(FALSE);
}
@


38.38
log
@*** empty log message ***
@
text
@d901 1
a901 1
	LockLayerInfo(intuiMsg->IDCMPWindow->WScreen->LayerInfo);
d909 1
a909 1
	UnlockLayerInfo(intuiMsg->IDCMPWindow->WScreen->LayerInfo);
@


38.37
log
@*** empty log message ***
@
text
@d86 1
d111 1
d361 2
@


38.36
log
@*** empty log message ***
@
text
@d895 5
d903 4
@


38.35
log
@Added code to support custom screens in prefs editors
Added code to open datatypes.library
Now requires >= V39 ROM, and >= 38 disk libraries
@
text
@d158 1
a158 1
            OpenLib(ed,&ed->ed_DataTypesBase,"datatypes.library", MSG_NO_DATATYPES_LIBRARY);
@


38.34
log
@Removed check for "pubscreen = NULL" which was used to decide whether or not
  to make the editor into an app window. It is now always made an appwindow.
@
text
@d94 1
a94 1
    if (SysBase->LibNode.lib_Version < 37)
d157 4
d287 1
d290 1
d307 1
d310 1
d340 4
d388 1
a388 1
        if (!(*libBase = OpenLibrary(libName,37)))
d662 1
a662 1
					  LockLayerInfo(&window->WScreen->LayerInfo);
d665 1
a665 1
                                          GT_BeginRefresh(window);
d667 1
a667 1
                                          GT_EndRefresh(window,TRUE);
d670 1
a670 1
					  UnlockLayerInfo(&window->WScreen->LayerInfo);
d674 4
d680 1
d719 1
a719 1
        if (ed->ed_WorkbenchBase = OpenLibrary("workbench.library",37))
d895 1
a895 1
        GT_BeginRefresh(window);
d897 1
a897 1
        GT_EndRefresh(window,TRUE);
d916 1
a916 1
                                                 ASLFR_Window,          ed->ed_Window,
@


38.33
log
@No longer calls FreeAslRequest() even when asl.library didn't open
Initially positions the file requester relative to the position of the prefs editor
@
text
@d702 1
a702 1
        if ((!ed->ed_PubScreenName) && (ed->ed_WorkbenchBase = OpenLibrary("workbench.library",37)))
@


38.32
log
@*** empty log message ***
@
text
@d318 2
a331 2
	    FreeAslRequest(ed->ed_FileReq);

d895 7
a901 5
                                                 ASLFR_InitialDrawer, PRESET_DIR,
                                                 ASLFR_InitialFile,   PRESET_NAME,
                                                 ASLFR_Window,        ed->ed_Window,
                                                 ASLFR_SleepWindow,   TRUE,
                                                 ASLFR_RejectIcons,   TRUE,
@


38.31
log
@Now frees FileRequester structure on exit
@
text
@d909 1
@


38.30
log
@*** empty log message ***
@
text
@d329 2
@


38.29
log
@Uses new asl.h features
@
text
@a897 1
                                                 ASLFR_IntuiMsgFunc, &hook,
d906 2
a907 1
	success = RequestPrefsFile(ed,ASLFR_TitleText, GetString(&ed->ed_LocaleInfo,MSG_REQ_LOAD),
d910 3
a912 2
	success = RequestPrefsFile(ed,ASLFR_TitleText,  GetString(&ed->ed_LocaleInfo,MSG_REQ_SAVE),
                                      ASLFR_DoSaveMode, TRUE,
@


38.28
log
@*** empty log message ***
@
text
@d863 2
d866 3
a868 2
struct IntuiMessage * __stdargs DoFRRefresh(ULONG mask, struct IntuiMessage *intuiMsg,
                                            struct FileRequester *freq)
a879 2

    return(intuiMsg);
d885 4
a888 3
BOOL             success,bool;
struct TagItem   tags[3];
struct Requester req;
d892 8
a899 6
        tags[0].ti_Tag  = ASL_Dir;
        tags[0].ti_Data = (ULONG)PRESET_DIR;
        tags[1].ti_Tag  = ASL_File;
        tags[1].ti_Data = (ULONG)PRESET_NAME;
        tags[2].ti_Tag  = TAG_DONE;
        if (!(ed->ed_FileReq = AllocAslRequest(ASL_FileRequest,tags)))
a905 3
    InitRequester(&req);
    bool = Request(&req,window);

d907 1
a907 4
	success = RequestPrefsFile(ed,ASL_FuncFlags, FILF_DOMSGFUNC,
	                              ASL_Hail,      GetString(&ed->ed_LocaleInfo,MSG_REQ_LOAD),
                                      ASL_Window,    ed->ed_Window,
                                      ASL_HookFunc,  DoFRRefresh,
d910 2
a911 4
	success = RequestPrefsFile(ed,ASL_FuncFlags, FILF_DOMSGFUNC|FILF_SAVE,
	                              ASL_Hail,      GetString(&ed->ed_LocaleInfo,MSG_REQ_SAVE),
                                      ASL_Window,    ed->ed_Window,
                                      ASL_HookFunc,  DoFRRefresh,
a912 3

    if (bool)
        EndRequest(&req,window);
@


38.27
log
@Removed AppMenu code
Now uses GadgetID instead of UserData
@
text
@d26 1
d39 1
d153 3
d330 4
d646 6
a651 1
		case IDCMP_REFRESHWINDOW: GT_BeginRefresh(window);
d654 4
@


38.26
log
@CopyPrefs() now passes the address of the prefs structures
@
text
@d655 1
a655 1
		case IDCMP_MOUSEMOVE    : ProcessCommand(ed,(EdCommand)activeGad->UserData);
d658 1
a658 1
		case IDCMP_GADGETUP     : ProcessCommand(ed,(EdCommand)gadget->UserData);
d685 1
d687 1
d711 1
a711 1

d714 1
a714 1

@


38.25
log
@Calls of CopyPrefs() now pass EdDataPtr
@
text
@d241 1
a241 1
		        CopyPrefs(ed,ed->ed_PrefsWork,ed->ed_PrefsDefaults);
d247 1
a247 1
                                CopyPrefs(ed,ed->ed_PrefsWork,ed->ed_PrefsDefaults);
d256 1
a256 1
                                CopyPrefs(ed,ed->ed_PrefsWork,ed->ed_PrefsDefaults);
d260 1
a260 1
                        CopyPrefs(ed,ed->ed_PrefsInitial,ed->ed_PrefsWork);
d466 1
a466 1
        case EC_RESETALL : CopyPrefs(ed,ed->ed_PrefsWork,ed->ed_PrefsDefaults);
d474 1
a474 1
        case EC_RESTORE  : CopyPrefs(ed,ed->ed_PrefsWork,ed->ed_PrefsInitial);
@


38.24
log
@Now calls ScreenToFront() whenever another instance gets started
Now only calls WindowToFront() if the window is not backdrop
Has slightly different code to handle gadget events to allow boopsi gadgets in 
  prefs editors
Now calls InitDisp() before initializing the display
@
text
@d241 1
a241 1
		        CopyPrefs(ed->ed_PrefsWork,ed->ed_PrefsDefaults);
d247 1
a247 1
                                CopyPrefs(ed->ed_PrefsWork,ed->ed_PrefsDefaults);
d256 1
a256 1
                                CopyPrefs(ed->ed_PrefsWork,ed->ed_PrefsDefaults);
d260 1
a260 1
                        CopyPrefs(ed->ed_PrefsInitial,ed->ed_PrefsWork);
d466 1
a466 1
        case EC_RESETALL : CopyPrefs(ed->ed_PrefsWork,ed->ed_PrefsDefaults);
d474 1
a474 1
        case EC_RESTORE  : CopyPrefs(ed->ed_PrefsWork,ed->ed_PrefsInitial);
@


38.23
log
@Correctly handles shell return codes
@
text
@d241 1
a241 1
		        ed->ed_PrefsWork = ed->ed_PrefsDefaults;
d247 1
a247 1
                                ed->ed_PrefsWork = ed->ed_PrefsDefaults;
d256 1
a256 1
                                ed->ed_PrefsWork = ed->ed_PrefsDefaults;
d260 1
a260 1
                        ed->ed_PrefsInitial = ed->ed_PrefsWork;
d274 1
a274 1
                            if (ed->ed_Font = OpenFont(&ed->ed_TextAttr))
d276 1
a276 1
                                if (ed->ed_Screen = LockPubScreen(ed->ed_PubScreenName))
d278 1
a278 1
                                    if (ed->ed_VisualInfo = GetVisualInfoA(ed->ed_Screen,NULL))
d280 1
a280 1
                                        if (ed->ed_DrawInfo = GetScreenDrawInfo(ed->ed_Screen))
d282 1
a282 1
                                            if (CreateDisp(ed))
d284 4
a287 2
                                                EventLoop(ed);
                                                DisposeDisp(ed);
d289 4
a292 2
                                                ed->ed_SecondaryResult = 0;
                                                failureLevel = RETURN_OK;
d294 1
a294 1
                                            FreeScreenDrawInfo(ed->ed_Screen,ed->ed_DrawInfo);
d296 1
a296 1
                                        FreeVisualInfo(ed->ed_VisualInfo);
d298 1
a298 1
                                    UnlockPubScreen(NULL,ed->ed_Screen);
a299 1
                                CloseFont(ed->ed_Font);
d431 4
a434 2
        case EC_ACTIVATE : WindowToFront(ed->ed_Window);
			   ActivateWindow(ed->ed_Window);
d466 1
a466 1
        case EC_RESETALL : ed->ed_PrefsWork = ed->ed_PrefsDefaults;
d474 1
a474 1
        case EC_RESTORE  : ed->ed_PrefsWork = ed->ed_PrefsInitial;
d564 1
d654 5
a658 3
                case IDCMP_MOUSEMOVE    :
		case IDCMP_GADGETUP     :
		case IDCMP_GADGETDOWN   : ProcessCommand(ed,(EdCommand)gadget->UserData);
@


38.22
log
@Added call to SyncTextGadgets call
@
text
@d92 1
a92 1
    if (SysBase->LibNode.lib_Version < 36)
d265 1
d267 1
a267 2

                        if (action == A_USE)
d270 1
d272 1
a272 2

                        if ((action != A_USE) && (action != A_SAVE))
a283 1
                                                failureLevel = RETURN_OK;
d286 3
d301 3
d362 1
a362 1
        if (!(*libBase = OpenLibrary(libName,36)))
d674 1
a674 1
        if ((!ed->ed_PubScreenName) && (ed->ed_WorkbenchBase = OpenLibrary("workbench.library",36)))
@


38.21
log
@*** empty log message ***
@
text
@d416 3
@


38.20
log
@Same comment as above.... Didn't quite do it the previous time :-)
@
text
@d862 1
a862 1
            return(TRUE);
@


38.19
log
@Fixed bug with incorrectly handling return code from FileRequest() function calls
@
text
@d53 1
a53 1
EdStatus FileRequest(EdDataPtr ed, BOOL mode);
d426 1
a426 1
        case EC_OPEN     : if ((result = FileRequest(ed,TRUE)) == ES_NORMAL)
d446 1
a446 1
        case EC_SAVEAS   : if ((result = FileRequest(ed,FALSE)) == ES_NORMAL)
d846 1
a846 1
EdStatus FileRequest(EdDataPtr ed, BOOL mode)
d861 2
a862 1
            return(ES_NO_MEMORY);
@


38.18
log
@No longer calls RenderGadget() when the display is originally created
@
text
@d426 1
a426 1
        case EC_OPEN     : if (FileRequest(ed,TRUE))
d446 1
a446 1
        case EC_SAVEAS   : if (FileRequest(ed,FALSE))
@


38.17
log
@No longer does an AddGList()/RefreshGList() of the editor's gadgets
@
text
@a664 1
        RenderGadg(ed);
@


38.16
log
@Made file req callback function use __stdargs
@
text
@a662 2
        AddGList(window,ed->ed_Gadgets,-1,-1,NULL);
        RefreshGList(ed->ed_Gadgets,window,NULL,-1);
@


38.15
log
@Now closes window before saving prefs
Now correctly sets pr_WindowPtr to point to prefs window
Open/SavePrefs now assume ed->ed_PrefsWork
@
text
@d831 2
a832 2
struct IntuiMessage *DoFRRefresh(ULONG mask, struct IntuiMessage *intuiMsg,
                                 struct FileRequester *freq)
@


38.14
log
@Added a requester in the main window whenever the file req is up in order to
block user input in the main window
@
text
@d55 3
d133 1
a134 1
            ed->ed_PrefsChanged      = FALSE;
d241 1
d244 1
a244 1
                            if ((result = OpenPrefs(ed,presetName,&ed->ed_PrefsInitial)) != ES_NORMAL)
d247 1
a247 1
                                ed->ed_PrefsInitial = ed->ed_PrefsDefaults;
a248 1
                            ed->ed_PrefsChanged = TRUE;
d252 1
a252 1
                            if ((result = OpenPrefs(ed,ENV_NAME,&ed->ed_PrefsInitial)) != ES_NORMAL)
d256 1
a256 1
                                ed->ed_PrefsInitial = ed->ed_PrefsDefaults;
d260 1
a260 1
                        ed->ed_PrefsWork = ed->ed_PrefsInitial;
d282 1
a282 1
                                            if (CreateDisplay(ed))
a283 6
                                                if (ed->ed_WorkbenchBase = OpenLibrary("workbench.library",36))
                                                {
                                                    ed->ed_AppWindow = AddAppWindowA(0,NULL,window,&ed->ed_AppPort,NULL);
                                                    ed->ed_AppMenu   = AddAppMenuItemA(0,NULL,window->Title,&ed->ed_AppPort,NULL);
                                                }

a284 2
                                                RenderDisplay(ed);
                                                RenderGadgets(ed);
d286 1
a286 1
                                                DisposeDisplay(ed);
a310 2
            FreeRemember(&ed->ed_Tracker,TRUE);

a313 6
	    if (ed->ed_AppMenu)
	        RemoveAppMenuItem(ed->ed_AppMenu);

	    if (ed->ed_AppWindow)
	        RemoveAppWindow(ed->ed_AppWindow);

d346 1
a346 1
#define SysBase ed->ed_SysBase;
d428 2
a429 2
                               result = OpenPrefs(ed,ed->ed_NameBuf,&ed->ed_PrefsWork);
                               RenderGadgets(ed);
d433 6
a438 4
        case EC_SAVE     : if ((result = SavePrefs(ed,ARC_NAME,&ed->ed_PrefsWork)) == ES_NORMAL)
			       if ((result = SavePrefs(ed,ENV_NAME,&ed->ed_PrefsWork)) == ES_NORMAL)
                                   ed->ed_Quit = TRUE;

d441 3
a443 3
        case EC_USE      : if ((result = SavePrefs(ed,ENV_NAME,&ed->ed_PrefsWork)) == ES_NORMAL)
                               ed->ed_Quit = TRUE;

d447 1
a447 1
                               if ((result = SavePrefs(ed,ed->ed_NameBuf,&ed->ed_PrefsWork)) == ES_NORMAL)
d454 1
a454 1
                           RenderGadgets(ed);
d457 2
a458 2
        case EC_LASTSAVED: result = OpenPrefs(ed,ARC_NAME,&ed->ed_PrefsWork);
                           RenderGadgets(ed);
d462 1
a462 1
                           RenderGadgets(ed);
d465 2
a466 1
        case EC_CANCEL   : ed->ed_Quit = TRUE;
d502 5
d588 4
a591 1
            ed->ed_Quit = TRUE;
d593 1
a593 2
        ed->ed_CurrentMsg = NULL;
	while (appMsg = (struct AppMessage *)GetMsg(&ed->ed_AppPort))
d603 1
a603 1
                if ((result = OpenPrefs(ed,wbArg->wa_Name,&ed->ed_PrefsWork)) != ES_NORMAL)
d605 1
a605 1
                RenderGadgets(ed);
d615 1
a615 1
	while (intuiMsg = GT_GetIMsg(window->UserPort))
d617 5
a621 3
            ed->ed_CurrentMsg = intuiMsg;
	    gadget = (struct Gadget *)intuiMsg->IAddress;
	    switch(intuiMsg->Class)
a646 2
	    GT_ReplyIMsg(intuiMsg);
	    ed->ed_CurrentMsg = NULL;
d655 67
d851 3
a853 2
BOOL           success,bool;
struct TagItem tags[3];
d868 2
a869 2
    InitRequester(&ed->ed_SleepReq);
    bool = Request(&ed->ed_SleepReq,window);
d885 1
a885 1
        EndRequest(&ed->ed_SleepReq,window);
@


38.13
log
@Now opens sys/prefs.catalog instead of simply prefs.catalog
@
text
@d787 1
a787 1
BOOL success;
d803 3
d818 3
@


38.12
log
@Changes to use new pe_strings module
Now creates a port using PORT_NAME as a name instead of EDITOR_NAME
Now creates an AppMenu using window->Title instead of EDITOR_NAME
@
text
@d156 1
a156 1
                    ed->ed_LocaleInfo.li_Catalog = OpenCatalogA(NULL,"prefs.catalog",NULL);
@


38.11
log
@Now parses tooltypes of the tool icon
Now knows about the PUBSCREEN tooltype
Now knows about the CREATEICONS tooltype
Now turns off icon creation when the editor is run from the shell
Now calls editor function to give it a chance to look at the command-line and at
  the tooltypes
@
text
@d41 1
a41 1
#include "texttable.h"
d50 1
a50 1
             enum AppStringsID error);
d79 1
a79 1
enum AppStringsID  result;
d96 1
a96 1
        if (rendezVous = FindPort(EDITOR_NAME))
d106 1
a106 1
                ed->ed_RendezVous.mp_Node.ln_Name = EDITOR_NAME;
d284 1
a284 1
                                                    ed->ed_AppMenu   = AddAppMenuItemA(0,NULL,EDITOR_NAME,&ed->ed_AppPort,NULL);
d366 1
a366 1
             enum AppStringsID error)
@


38.10
log
@Fixed stupid bug introduced in previous version preventing anything from working!
@
text
@d25 1
d37 1
d54 1
a70 1
struct DiskObject *diskObj;
a75 1
STRPTR             tvalue;
d128 1
a128 1
            ed->ed_SaveIcons         = TRUE;
d164 1
a164 1
                        wbArg    = wbMsg->sm_ArgList;
d173 10
a187 21

                        if (wbMsg->sm_NumArgs > 1)
                        {
                            wbArg++;
                            presetName = wbArg->wa_Name;
                            CurrentDir(wbArg->wa_Lock);

                            if (diskObj = GetDiskObject(presetName))
                            {
                                if (tvalue = FindToolType(diskObj->do_ToolTypes,"ACTION"))
                                {
                                    if (MatchToolValue(tvalue,"EDIT"))
                                        action = A_EDIT;
                                    if (MatchToolValue(tvalue,"USE"))
                                        action = A_USE;
                                    if (MatchToolValue(tvalue,"SAVE"))
                                        action = A_SAVE;
                                }
                                FreeDiskObject(diskObj);
                            }
                        }
d223 5
d273 1
a273 1
                                if (ed->ed_Screen = LockPubScreen((STRPTR)ed->ed_Args[OPT_SCREEN]))
d377 43
@


38.9
log
@Fixed bug with crashing when exiting under Workbench
@
text
@d76 1
a76 1
BPTR		   oldLock = NULL;
a121 2
            CurrentDir(oldLock=CurrentDir(NULL));

d150 2
d314 1
a333 2

            CurrentDir(oldLock);
@


38.8
log
@Corrected startup bugs preventing editors from running under the C= shell
correctly, or running from the resident list
@
text
@a85 1
        oldLock = process->pr_CurrentDir;
d122 2
d334 2
a352 1
        CurrentDir(oldLock);
@


38.7
log
@Added AppMenu and AppWindow support
Added EC_ACTIVATE as a standard command
@
text
@d201 1
a201 1
                        if (GetProgramName(ed->ed_ProgramPath,PROGPATHSIZE))
d203 2
a204 1
                            if (progLock = Lock(ed->ed_ProgramPath,ACCESS_READ))
d206 1
a206 1
                                if (NameFromLock(progLock,ed->ed_ProgramPath,PROGPATHSIZE))
a209 1
                                UnLock(progLock);
d211 8
@


38.6
log
@Fixed bug in ProcessItem that was causing gadtools separator bar to be
displayed as active
Optimized a tad
@
text
@d23 2
d35 1
d79 1
d86 1
d134 6
d163 1
a163 1
                        oldLock  = CurrentDir(wbArg->wa_Lock);
d277 6
d316 9
d334 2
d342 1
a342 3
        if (oldLock)
            CurrentDir(oldLock);

d386 6
d507 4
d540 1
a540 1
        sigs = Wait(1L<<window->UserPort->mp_SigBit | SIGBREAKF_CTRL_F | SIGBREAKF_CTRL_C);
d543 1
a543 6
        {
            WindowToFront(ed->ed_Window);
            ActivateWindow(ed->ed_Window);
            if (ed->ed_Window->Flags & ZOOMED)
                ZipWindow(ed->ed_Window);
        }
d548 23
d741 1
d745 6
a750 1
        if (!(ed->ed_FileReq = AllocAslRequest(ASL_FileRequest,NULL)))
a759 2
                                      ASL_Dir,       PRESET_DIR,
                                      ASL_File,      PRESET_NAME,
a765 2
                                      ASL_Dir,       PRESET_DIR,
                                      ASL_File,      PRESET_NAME,
@


38.5
log
@Corrected bug where incorrect command-line arguments were not causing the shell to quit
@
text
@a144 1
            }
a145 2
            if (!ed->ed_InitFail)
            {
d446 3
a448 1
    GetCmdState(ed,(EdCommand)MENU_USERDATA(item),&state);
d450 4
a453 4
    if (state.cs_Available)
        item->Flags |= ITEMENABLED;
    else
        item->Flags &= ~ITEMENABLED;
d455 5
a459 4
    if (state.cs_Selected)
        item->Flags |= CHECKED;
    else
        item->Flags &= ~CHECKED;
@


38.4
log
@Now calls CleanUpEdData() upon termination to allow editor-specific cleanup code
@
text
@d224 3
a226 3
                    if (presetName)
                    {
                        if ((result = OpenPrefs(ed,presetName,&ed->ed_PrefsInitial)) != ES_NORMAL)
d228 6
a233 2
                            ShowError2(ed,result);  /* couldn't open requested presets */
                            ed->ed_PrefsInitial = ed->ed_PrefsDefaults;
d235 1
a235 5
                        ed->ed_PrefsChanged = TRUE;
                    }
                    else
                    {
                        if ((result = OpenPrefs(ed,ENV_NAME,&ed->ed_PrefsInitial)) != ES_NORMAL)
d237 6
a242 3
                            if (ed->ed_SecondaryResult != ERROR_OBJECT_NOT_FOUND)
                                ShowError2(ed,result);  /* couldn't load saved prefs */
                            ed->ed_PrefsInitial = ed->ed_PrefsDefaults;
a243 1
                    }
d245 1
a245 1
                    ed->ed_PrefsWork = ed->ed_PrefsInitial;
d247 4
a250 4
                    if (action == A_SAVE)
                    {
                        ProcessCommand(ed,EC_SAVE);
                    }
d252 4
a255 4
                    if (action == A_USE)
                    {
                        ProcessCommand(ed,EC_USE);
                    }
d257 1
a257 3
                    if ((action != A_USE) && (action != A_SAVE))
                    {
                        if (ed->ed_Font = OpenFont(&ed->ed_TextAttr))
d259 1
a259 1
                            if (ed->ed_Screen = LockPubScreen((STRPTR)ed->ed_Args[OPT_SCREEN]))
d261 1
a261 1
                                if (ed->ed_VisualInfo = GetVisualInfoA(ed->ed_Screen,NULL))
d263 1
a263 1
                                    if (ed->ed_DrawInfo = GetScreenDrawInfo(ed->ed_Screen))
d265 1
a265 1
                                        if (CreateDisplay(ed))
d267 9
a275 5
                                            failureLevel = RETURN_OK;
                                            RenderDisplay(ed);
                                            RenderGadgets(ed);
                                            EventLoop(ed);
                                            DisposeDisplay(ed);
d277 1
a277 1
                                        FreeScreenDrawInfo(ed->ed_Screen,ed->ed_DrawInfo);
d279 1
a279 1
                                    FreeVisualInfo(ed->ed_VisualInfo);
d281 1
a281 1
                                UnlockPubScreen(NULL,ed->ed_Screen);
a282 1
                            CloseFont(ed->ed_Font);
@


38.3
log
@Corrected "Last Saved" behavior
@
text
@d282 1
@


38.2
log
@Corrected bugs with incorrect and excessive error message printing
@
text
@d226 1
a226 1
                        if ((result = OpenPrefs(ed,presetName,&ed->ed_PrefsVirtual)) != ES_NORMAL)
d229 1
a229 1
                            ed->ed_PrefsVirtual = ed->ed_PrefsDefaults;
d235 1
a235 1
                        if ((result = OpenPrefs(ed,ENV_NAME,&ed->ed_PrefsVirtual)) != ES_NORMAL)
d239 1
a239 1
                            ed->ed_PrefsVirtual = ed->ed_PrefsDefaults;
d243 1
a243 1
                    ed->ed_PrefsWork = ed->ed_PrefsVirtual;
d388 1
a388 1
        case EC_LASTSAVED: result = OpenPrefs(ed,ed->ed_NameBuf,&ed->ed_PrefsWork);
d392 1
a392 1
        case EC_RESTORE  : ed->ed_PrefsWork = ed->ed_PrefsVirtual;
@


38.1
log
@Initial V38 RCS checkin
@
text
@a136 1
            OpenLib(ed,&ed->ed_LocaleBase,   "locale.library",    MSG_NOTHING);
d138 1
a138 1
            if (ed->ed_LocaleBase)
d140 5
a144 2
                ed->ed_LocaleInfo.li_LocaleBase = ed->ed_LocaleBase;
                ed->ed_LocaleInfo.li_Catalog = OpenCatalogA(NULL,"prefs.catalog",NULL);
d237 2
a238 1
                            ShowError2(ed,result);  /* couldn't load saved prefs */
@
