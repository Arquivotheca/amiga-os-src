head     38.22;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


38.22
date     93.02.09.11.55.06;  author vertex;  state Exp;
branches ;
next     38.21;

38.21
date     93.01.25.12.25.18;  author vertex;  state Exp;
branches ;
next     38.20;

38.20
date     93.01.19.15.49.05;  author vertex;  state Exp;
branches ;
next     38.19;

38.19
date     92.10.26.11.01.05;  author vertex;  state Exp;
branches ;
next     38.18;

38.18
date     92.08.08.14.42.23;  author vertex;  state Exp;
branches ;
next     38.17;

38.17
date     92.03.24.17.48.15;  author vertex;  state Exp;
branches ;
next     38.16;

38.16
date     92.02.27.13.14.11;  author vertex;  state Exp;
branches ;
next     38.15;

38.15
date     92.02.17.16.15.08;  author vertex;  state Exp;
branches ;
next     38.14;

38.14
date     92.01.28.12.35.48;  author vertex;  state Exp;
branches ;
next     38.13;

38.13
date     92.01.22.12.22.56;  author vertex;  state Exp;
branches ;
next     38.12;

38.12
date     92.01.21.14.11.50;  author vertex;  state Exp;
branches ;
next     38.11;

38.11
date     92.01.09.16.38.45;  author vertex;  state Exp;
branches ;
next     38.10;

38.10
date     91.12.30.14.26.58;  author vertex;  state Exp;
branches ;
next     38.9;

38.9
date     91.11.15.13.08.50;  author vertex;  state Exp;
branches ;
next     38.8;

38.8
date     91.11.11.12.17.10;  author vertex;  state Exp;
branches ;
next     38.7;

38.7
date     91.11.04.12.39.04;  author vertex;  state Exp;
branches ;
next     38.6;

38.6
date     91.10.25.10.42.45;  author vertex;  state Exp;
branches ;
next     38.5;

38.5
date     91.10.24.15.34.54;  author vertex;  state Exp;
branches ;
next     38.4;

38.4
date     91.09.20.09.15.44;  author vertex;  state Exp;
branches ;
next     38.3;

38.3
date     91.08.20.11.55.15;  author vertex;  state Exp;
branches ;
next     38.2;

38.2
date     91.08.12.13.29.50;  author vertex;  state Exp;
branches ;
next     38.1;

38.1
date     91.08.09.10.47.21;  author vertex;  state Exp;
branches ;
next     ;


desc
@Prefs editor shell - custom Overscan interface
@


38.22
log
@Fixed bounds checking code, now handles sync values
@
text
@
/* includes */
#include <exec/types.h>
#include <exec/libraries.h>
#include <exec/ports.h>
#include <exec/memory.h>
#include <exec/execbase.h>
#include <devices/keymap.h>
#include <intuition/intuition.h>
#include <intuition/screens.h>
#include <intuition/gadgetclass.h>
#include <graphics/text.h>
#include <libraries/asl.h>
#include <libraries/gadtools.h>
#include <libraries/locale.h>
#include <prefs/locale.h>
#include <dos/dos.h>
#include <dos/exall.h>
#include <string.h>
#include <stdio.h>

/* prototypes */
#include <clib/exec_protos.h>
#include <clib/dos_protos.h>
#include <clib/iffparse_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/intuition_protos.h>
#include <clib/graphics_protos.h>
#include <clib/alib_protos.h>
#include <clib/utility_protos.h>
#include <clib/asl_protos.h>

/* direct ROM interface */
#include <pragmas/exec_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/iffparse_pragmas.h>
#include <pragmas/gadtools_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/utility_pragmas.h>
#include <pragmas/asl_pragmas.h>

/* application includes */
#include "pe_custom.h"
#include "pe_strings.h"
#include "pe_utils.h"
#include "pe_iff.h"
#include "edit.h"


#define SysBase ed->ed_SysBase
#define MONITOR_PART(id)	((id) & MONITOR_ID_MASK)


/*****************************************************************************/


/* The IFF chunks known to this prefs editor. IFFPrefChunkCnt says how many
 * chunks there are
 */
#define IFFPrefChunkCnt 2
static LONG far IFFPrefChunks[] =
{
    ID_PREF, ID_PRHD,
    ID_PREF, ID_OSCN,
};


/*****************************************************************************/


/* The PrefHeader structure this editor outputs */
static struct PrefHeader far IFFPrefHeader =
{
    0,   /* version */
    0,   /* type    */
    0    /* flags   */
};


/*****************************************************************************/


VOID BuildList(EdDataPtr ed)
{
ULONG                modeID;
BOOL                 present;
struct Node         *node;
struct MonitorEntry *me;
struct DimensionInfo dimInfo;
struct MonitorInfo   monInfo;
struct DisplayInfo   dispInfo;
UWORD                len;
DisplayInfoHandle    dh;
/*
ULONG                wbID;
struct Screen       *wb;
*/
ULONG                id;

    NewList(&ed->ed_MonitorList);
/*
    wbID = INVALID_ID;
    if (wb = LockPubScreen("Workbench"))
    {
        wbID = GetVPModeID(&wb->ViewPort);
        UnlockPubScreen(NULL,wb);
    }
*/
    modeID = INVALID_ID;
    while ((modeID = NextDisplayInfo(modeID)) != INVALID_ID)
    {
	if (MONITOR_PART(modeID))
	{
            present = FALSE;
            for (me = (struct MonitorEntry *)ed->ed_MonitorList.lh_Head; me->me_Node.ln_Succ; me = (struct MonitorEntry *)me->me_Node.ln_Succ)
                if (MONITOR_PART(me->me_ID) == MONITOR_PART(modeID))
                    present = TRUE;

            if ((!present)
            &&  (dh = FindDisplayInfo(modeID))
            &&  (GetDisplayInfoData(dh,(APTR)&dispInfo,sizeof(struct DisplayInfo),DTAG_DISP,INVALID_ID))
            &&  (GetDisplayInfoData(dh,(APTR)&monInfo,sizeof(struct MonitorInfo),DTAG_MNTR,INVALID_ID)))
            {
                if ((!dispInfo.NotAvailable) && (dispInfo.PropertyFlags & DIPF_IS_WB))
		{
		    id = monInfo.PreferredModeID;
/*
		    if (MONITOR_PART(wbID) == MONITOR_PART(id))
		        id = wbID;
*/
                    if ((dh = FindDisplayInfo(id))
                    &&  (GetDisplayInfoData(dh,(APTR)&dispInfo,sizeof(struct DisplayInfo),DTAG_DISP,INVALID_ID))
                    &&  (GetDisplayInfoData(dh,(APTR)&monInfo,sizeof(struct MonitorInfo),DTAG_MNTR,INVALID_ID))
                    &&  (GetDisplayInfoData(dh,(APTR)&dimInfo,sizeof(struct DimensionInfo),DTAG_DIMS,INVALID_ID)))
                    {
                        if (me = AllocVec(sizeof(struct MonitorEntry),MEMF_CLEAR|MEMF_PUBLIC))
                        {
                            me->me_ID = id;

                            if (monInfo.Mspc)
                            {
                                if (monInfo.Mspc->ms_Special)
                                {
                                    me->me_HStart = monInfo.Mspc->ms_Special->hsync.asi_Start;
                                    me->me_HStop  = monInfo.Mspc->ms_Special->hsync.asi_Stop;
                                    me->me_VStart = monInfo.Mspc->ms_Special->vsync.asi_Start;
                                    me->me_VStop  = monInfo.Mspc->ms_Special->vsync.asi_Stop;
                                }

                                if (monInfo.Mspc->ms_Node.xln_Name)
                                {
                                    stccpy(me->me_Name,monInfo.Mspc->ms_Node.xln_Name,MENAMELEN);
                                    len = strlen(me->me_Name);
                                    if ((len > 8) && (Stricmp(&me->me_Name[len-8],".monitor")==0))
                                        me->me_Name[len-8] = 0;
                                    me->me_Name[0] = ToUpper(me->me_Name[0]);

                                    if ((Stricmp(me->me_Name,"NTSC") == 0) || (Stricmp(me->me_Name,"PAL") == 0))
                                    {
                                        len = strlen(me->me_Name);
                                        while (len--)
                                            me->me_Name[len] = ToUpper(me->me_Name[len]);
                                    }
                                }
                            }

                            me->me_Node.ln_Name  = me->me_Name;
                            me->me_DisplayInfo   = dispInfo;
                            me->me_DimensionInfo = dimInfo;
                            me->me_MonitorInfo   = monInfo;

                            node = ed->ed_MonitorList.lh_Head;
                            while (node->ln_Succ)
                            {
                                if (Stricmp(node->ln_Name,me->me_Node.ln_Name) >= 0)
                                    break;
                                node = node->ln_Succ;
                            }
                            Insert(&ed->ed_MonitorList,(struct Node *)me,node->ln_Pred);
                        }
                    }
                }
	    }
	}
    }
}


/*****************************************************************************/


BOOL InitPrefs(EdDataPtr ed, struct ExtPrefs *prefs)
{
ULONG        count;
struct Node *node;

    count = 0;
    node = ed->ed_MonitorList.lh_Head;
    while (node->ln_Succ)
    {
        node = node->ln_Succ;
        count++;
    }

    if (count == 0)
        return(TRUE);

    if (prefs->ep_Next = AllocVec(sizeof(struct ExtPrefs)*count,MEMF_PUBLIC|MEMF_CLEAR))
    {
        prefs = prefs->ep_Next;
        node  = ed->ed_MonitorList.lh_Head;
        while (node->ln_Succ)
        {
            prefs->ep_Monitor = *(struct MonitorEntry *)node;
            node = node->ln_Succ;

            if (node->ln_Succ)
            {
                prefs->ep_Next = (struct ExtPrefs *) ((ULONG)prefs + sizeof(struct ExtPrefs));
                prefs = prefs->ep_Next;
            }
        }
        return(TRUE);
    }

    return(FALSE);
}


/*****************************************************************************/


VOID FitRect(struct Rectangle *container, struct Rectangle *inner)
{
    if (inner->MinX < container->MinX)
        inner->MinX = container->MinX;

    if (inner->MinY < container->MinY)
        inner->MinY = container->MinY;

    if (inner->MaxX > container->MaxX)
        inner->MaxX = container->MaxX;

    if (inner->MaxY > container->MaxY)
        inner->MaxY = container->MaxY;
}


/*****************************************************************************/


VOID GrowRect(struct Rectangle *container, struct Rectangle *inner)
{
    if (inner->MinX > container->MinX)
        inner->MinX = container->MinX;

    if (inner->MinY > container->MinY)
        inner->MinY = container->MinY;

    if (inner->MaxX < container->MaxX)
        inner->MaxX = container->MaxX;

    if (inner->MaxY < container->MaxY)
        inner->MaxY = container->MaxY;
}


/*****************************************************************************/


VOID PrefsToMonitorEntry(EdDataPtr ed, struct OverscanPrefs *op,
                         struct MonitorEntry *me)
{
struct DisplayInfo    dispInfo;
struct MonitorInfo    monInfo;
struct DimensionInfo  dimInfo;
Point                 shift;
Point	              newviewpos;
UWORD                 xscale,yscale;
DisplayInfoHandle     dh;

    if ((dh = FindDisplayInfo(me->me_ID))
    &&  (GetDisplayInfoData(dh,(APTR)&dispInfo,sizeof(struct DisplayInfo),DTAG_DISP,INVALID_ID))
    &&  (GetDisplayInfoData(dh,(APTR)&monInfo,sizeof(struct MonitorInfo),DTAG_MNTR,INVALID_ID))
    &&  (GetDisplayInfoData(dh,(APTR)&dimInfo,sizeof(struct DimensionInfo),DTAG_DIMS,INVALID_ID)))
    {
        xscale = monInfo.ViewResolution.x / dispInfo.Resolution.x;
        yscale = monInfo.ViewResolution.y / dispInfo.Resolution.y;

	/* Start with the real live MaxOScan from the graphics database,
	 * and displace it by the amount that the new ViewPosition differs
	 * from the actual ViewPosition (scaled to the appropriate resolution).
	 * Note that we must validate the new ViewPosition because the
	 * addition/deletion of the VGAOnly icon could alter the
	 * ViewPositionRange (isn't persistent data fun?!?)
	 */
	newviewpos = op->os_ViewPos;
        /* make sure the view's horizontal position falls within legal range */
        if (newviewpos.x < monInfo.ViewPositionRange.MinX)
            newviewpos.x = monInfo.ViewPositionRange.MinX;
        else if (newviewpos.x > monInfo.ViewPositionRange.MaxX)
            newviewpos.x = monInfo.ViewPositionRange.MaxX;

        /* make sure the view's vertical position falls within legal range */
        if (newviewpos.y < monInfo.ViewPositionRange.MinY)
            newviewpos.y = monInfo.ViewPositionRange.MinY;
        else if (newviewpos.y > monInfo.ViewPositionRange.MaxY)
            newviewpos.y = monInfo.ViewPositionRange.MaxY;

        shift.x = ((monInfo.ViewPosition.x - newviewpos.x) * monInfo.ViewResolution.x) / dispInfo.Resolution.x;
        shift.y = ((monInfo.ViewPosition.y - newviewpos.y) * monInfo.ViewResolution.y) / dispInfo.Resolution.y;

        ShiftRect(&dimInfo.MaxOScan, shift.x, shift.y);

	/* Set up TxtOScan based on the prefs data.  MinX and MinY
	 * are zero by definition;  the view origin is _defined_ to be
	 * the upper-left corner of the TxtOScan rectangle.  Everything
	 * is quantized to the ViewResolution, which may be coarser
	 * (an even multiple) of the mode's actual resolution.
	 */
        dimInfo.TxtOScan.MinX  = 0;
        dimInfo.TxtOScan.MinY  = 0;
        dimInfo.TxtOScan.MaxX  = op->os_Text.x - Modulo(op->os_Text.x, xscale) - 1;
        dimInfo.TxtOScan.MaxY  = op->os_Text.y - Modulo(op->os_Text.y, yscale) - 1;

	/* Set up StdOScan based on the prefs data, and quantize
	 * to the ViewResolution
	 */
        dimInfo.StdOScan       = op->os_Standard;
        dimInfo.StdOScan.MinX -= Modulo(dimInfo.StdOScan.MinX, xscale);
        dimInfo.StdOScan.MinY -= Modulo(dimInfo.StdOScan.MinY, yscale);
        dimInfo.StdOScan.MaxX -= Modulo((WORD)(dimInfo.StdOScan.MaxX+1), xscale);
        dimInfo.StdOScan.MaxY -= Modulo((WORD)(dimInfo.StdOScan.MaxY+1), yscale);

        monInfo.ViewPosition = newviewpos;

	/* We now must ensure that TxtOScan and StdOScan are legal, and
	 * we ought to do it in the same manner Intuition does.  What
	 * Intuition does is:
	 *
	 *	- ensure that the oscan rectangle fits inside MaxOScan
	 *	- ensure that the result encloses the Nominal rectangle
	 *
	 * It turns out that Intuition chops the rectangle to fit
	 * inside MaxOScan, rather than shift it.
	 */

	FitRect( &dimInfo.MaxOScan, &dimInfo.TxtOScan );
	GrowRect( &dimInfo.Nominal, &dimInfo.TxtOScan );

	FitRect( &dimInfo.MaxOScan, &dimInfo.StdOScan );
	GrowRect( &dimInfo.Nominal, &dimInfo.StdOScan );

        me->me_DimensionInfo = dimInfo;
        me->me_DisplayInfo   = dispInfo;
        me->me_MonitorInfo   = monInfo;

        if (op->os_Magic == OSCAN_MAGIC)
        {
            me->me_HStart = op->os_HStart;
            me->me_HStop  = op->os_HStop;
            me->me_VStart = op->os_VStart;
            me->me_VStop  = op->os_VStop;
            CheckSyncBounds(ed,me);
        }
    }
}


/*****************************************************************************/


EdStatus InitEdData(EdDataPtr ed)
{
struct ExtPrefs *ep;

    BuildList(ed);

    if (InitPrefs(ed,&ed->ed_PrefsDefaults) && InitPrefs(ed,&ed->ed_PrefsInitial) && InitPrefs(ed,&ed->ed_PrefsWork))
    {
        ep = ed->ed_PrefsDefaults.ep_Next;
        while (ep)
        {
            ep->ep_Monitor.me_DimensionInfo.TxtOScan = ep->ep_Monitor.me_DimensionInfo.Nominal;
            ep->ep_Monitor.me_DimensionInfo.StdOScan = ep->ep_Monitor.me_DimensionInfo.Nominal;
            ShiftRect(&ep->ep_Monitor.me_DimensionInfo.MaxOScan,
                       ep->ep_Monitor.me_MonitorInfo.ViewPosition.x-ep->ep_Monitor.me_MonitorInfo.DefaultViewPosition.x,
                       ep->ep_Monitor.me_MonitorInfo.ViewPosition.y-ep->ep_Monitor.me_MonitorInfo.DefaultViewPosition.y);
            ep->ep_Monitor.me_MonitorInfo.ViewPosition = ep->ep_Monitor.me_MonitorInfo.DefaultViewPosition;

            ep = ep->ep_Next;
        }

        return(ES_NORMAL);
    }

    CleanUpEdData(ed);

    return(ES_NO_MEMORY);
}


/*****************************************************************************/


VOID CleanUpEdData(EdDataPtr ed)
{
struct Node *node;

    FreeVec(ed->ed_PrefsDefaults.ep_Next);
    FreeVec(ed->ed_PrefsInitial.ep_Next);
    FreeVec(ed->ed_PrefsWork.ep_Next);

    while (node = RemHead(&ed->ed_MonitorList))
        FreeVec(node);
}


/*****************************************************************************/


VOID CopyPrefs(EdDataPtr ed, struct ExtPrefs *p1, struct ExtPrefs *p2)
{
    while (p1)
    {
        p1->ep_Monitor = p2->ep_Monitor;
        p1 = p1->ep_Next;
        p2 = p2->ep_Next;
    }
}


/*****************************************************************************/


EdStatus ReadPrefs(EdDataPtr ed, struct IFFHandle *iff, struct ContextNode *cn)
{
struct OverscanPrefs  op;
struct ExtPrefs      *ep;
struct DisplayInfo    dispInfo;
ULONG                 id;

    if (cn->cn_ID != ID_OSCN || cn->cn_Type != ID_PREF)
        return(ES_IFF_UNKNOWNCHUNK);

    if (ReadChunkBytes(iff,&op,sizeof(struct OverscanPrefs)) == sizeof(struct OverscanPrefs))
    {
        GetDisplayInfoData(FindDisplayInfo(DEFAULT_MONITOR_ID),(APTR)&dispInfo,sizeof(struct DisplayInfo),DTAG_DISP,INVALID_ID);
        if (dispInfo.PropertyFlags & DIPF_IS_PAL)
	    id = PAL_MONITOR_ID;
        else
            id = NTSC_MONITOR_ID;

        if (MONITOR_PART(op.os_DisplayID) == DEFAULT_MONITOR_ID)
            op.os_DisplayID = (op.os_DisplayID & ~MONITOR_ID_MASK) | id;

        ep = ed->ed_PrefsWork.ep_Next;
        while (ep)
        {
            if (ep->ep_Monitor.me_ID == op.os_DisplayID)
            {
                PrefsToMonitorEntry(ed,&op,&ep->ep_Monitor);
                break;
            }
            ep = ep->ep_Next;
        }

        return(ES_NORMAL);
    }

    return(ES_IFFERROR);
}


EdStatus OpenPrefs(EdDataPtr ed, STRPTR name)
{
    return(ReadIFF(ed,name,IFFPrefChunks,IFFPrefChunkCnt,ReadPrefs));
}


/*****************************************************************************/


EdStatus WritePrefs(EdDataPtr ed, struct IFFHandle *iff, struct ContextNode *cn)
{
struct ExtPrefs      *ep;
struct OverscanPrefs  op;
struct MonitorEntry  *me;

    ep = ed->ed_PrefsWork.ep_Next;
    while (ep)
    {
        me                = &ep->ep_Monitor;
        op.os_Reserved    = 0;
        op.os_Magic       = OSCAN_MAGIC;
        op.os_HStart      = me->me_HStart;
        op.os_HStop       = me->me_HStop;
        op.os_VStart      = me->me_VStart;
        op.os_VStop       = me->me_VStop;
        op.os_DisplayID   = me->me_ID;
	op.os_ViewPos     = me->me_MonitorInfo.ViewPosition;
	op.os_Text.x      = RectWidth(&me->me_DimensionInfo.TxtOScan);
	op.os_Text.y      = RectHeight(&me->me_DimensionInfo.TxtOScan);
	op.os_Standard    = me->me_DimensionInfo.StdOScan;

        if (!PushChunk(iff,0,ID_OSCN,sizeof(struct OverscanPrefs)))
        {
            if (WriteChunkBytes(iff,&op,sizeof(struct OverscanPrefs)) == sizeof(struct OverscanPrefs))
            {
                if (!PopChunk(iff))
                {
                    ep = ep->ep_Next;
                    continue;
                }
            }
        }
        return(ES_IFFERROR);
    }

    return(ES_NORMAL);
}


EdStatus SavePrefs(EdDataPtr ed, STRPTR name)
{
    return(WriteIFF(ed,name,&IFFPrefHeader,WritePrefs));
}


/*****************************************************************************/


#define NW_WIDTH     418
#define NW_HEIGHT    124
#define	NW_IDCMP     (IDCMP_MOUSEBUTTONS | IDCMP_MENUPICK | IDCMP_REFRESHWINDOW | IDCMP_INTUITICKS | BUTTONIDCMP | CHECKBOXIDCMP | SLIDERIDCMP | CYCLEIDCMP | TEXTIDCMP | LISTVIEWIDCMP)
#define	NW_FLAGS     (WFLG_ACTIVATE | WFLG_DEPTHGADGET | WFLG_DRAGBAR | WFLG_SIMPLE_REFRESH)
#define NW_MINWIDTH  NW_WIDTH
#define NW_MINHEIGHT NW_HEIGHT
#define NW_MAXWIDTH  NW_WIDTH
#define NW_MAXHEIGHT NW_HEIGHT
#define ZOOMWIDTH    200

struct EdMenu far EM[] = {
    {NM_TITLE,  MSG_PROJECT_MENU,           EC_NOP, 0},
      {NM_ITEM, MSG_PROJECT_OPEN,           EC_OPEN, 0},
      {NM_ITEM, MSG_PROJECT_SAVE_AS,        EC_SAVEAS, 0},
      {NM_ITEM, MSG_NOTHING,                EC_NOP, 0},
      {NM_ITEM, MSG_PROJECT_QUIT,           EC_CANCEL, 0},

    {NM_TITLE,  MSG_EDIT_MENU,              EC_NOP, 0},
      {NM_ITEM, MSG_EDIT_RESET_TO_DEFAULTS, EC_RESETALL, 0},
      {NM_ITEM, MSG_EDIT_LAST_SAVED,        EC_LASTSAVED, 0},
      {NM_ITEM, MSG_EDIT_RESTORE,           EC_RESTORE, 0},

    {NM_TITLE,  MSG_OPTIONS_MENU,           EC_NOP, 0},
      {NM_ITEM, MSG_OPTIONS_SAVE_ICONS,     EC_SAVEICONS, CHECKIT|MENUTOGGLE},

    {NM_END,    MSG_NOTHING,                EC_NOP, 0}
};

/* main display gadgets */
struct EdGadget far EG[] = {
    {BUTTON_KIND,   8,   107, 87,  14, MSG_SAVE_GAD,          EC_SAVE,        0},
    {BUTTON_KIND,   165, 107, 87,  14, MSG_USE_GAD,           EC_USE,         0},
    {BUTTON_KIND,   323, 107, 87,  14, MSG_CANCEL_GAD,        EC_CANCEL,      0},

    {LISTVIEW_KIND, 8,   18,  146, 80, MSG_OSCN_MONITORS_GAD, EC_MONITORLIST, 0},
    {BUTTON_KIND,   170, 66,  240, 14, MSG_OSCN_EDITTEXT_GAD, EC_EDITTEXT,    0},
    {BUTTON_KIND,   170, 83,  240, 14, MSG_OSCN_EDITGFX_GAD,  EC_EDITGFX,     0}
};

/*****************************************************************************/


BOOL CreateDisplay(EdDataPtr ed)
{
UWORD               zoomSize[4];
struct DisplayInfo  dispInfo;
ULONG               scrID;
UWORD               currentCnt;
struct ExtPrefs    *ep;

    zoomSize[0] = -1;
    zoomSize[1] = -1;
    zoomSize[2] = ZOOMWIDTH;
    zoomSize[3] = ed->ed_Screen->WBorTop + ed->ed_Screen->Font->ta_YSize + 1;

    scrID = MONITOR_PART(GetVPModeID(&ed->ed_Screen->ViewPort));
    if (!scrID)
    {
        GetDisplayInfoData(FindDisplayInfo(DEFAULT_MONITOR_ID),(APTR)&dispInfo,sizeof(struct DisplayInfo),DTAG_DISP,INVALID_ID);
        if (dispInfo.PropertyFlags & DIPF_IS_PAL)
	    scrID = PAL_MONITOR_ID;
        else
            scrID = NTSC_MONITOR_ID;
    }

    currentCnt = 0;
    ep = ed->ed_PrefsWork.ep_Next;
    while (ep)
    {
	if (MONITOR_PART(ep->ep_Monitor.me_ID) == scrID)
	{
	    ed->ed_CurrentMon = &ep->ep_Monitor;
	    break;
	}

        currentCnt++;
        ep = ep->ep_Next;
    }

    ed->ed_LastAdded = CreateContext(&ed->ed_Gadgets);
    DoPrefsGadget(ed,&EG[0],NULL,TAG_DONE);
    DoPrefsGadget(ed,&EG[1],NULL,TAG_DONE);
    DoPrefsGadget(ed,&EG[2],NULL,TAG_DONE);

    DoPrefsGadget(ed,&EG[3],NULL,GTLV_Labels,       &ed->ed_MonitorList,
                                 GTLV_ShowSelected, NULL,
                                 GTLV_Selected,     currentCnt,
                                 GTLV_MakeVisible,  currentCnt,
                                 LAYOUTA_SPACING,   1,
                                 GTLV_ScrollWidth,  18,
                                 TAG_DONE);

    RenderGadgets(ed);

    if ((ed->ed_LastAdded)
    &&  (ed->ed_Menus = CreatePrefsMenus(ed,EM))
    &&  (ed->ed_Window = OpenPrefsWindow(ed,WA_InnerWidth,  NW_WIDTH,
                                            WA_InnerHeight, NW_HEIGHT,
                                            WA_MinWidth,    NW_MINWIDTH,
                                            WA_MinHeight,   NW_MINHEIGHT,
                                            WA_MaxWidth,    NW_MAXWIDTH,
                                            WA_MaxHeight,   NW_MAXHEIGHT,
                                            WA_IDCMP,       NW_IDCMP,
                                            WA_Flags,       NW_FLAGS,
                                            WA_Zoom,        zoomSize,
                                            WA_AutoAdjust,  TRUE,
                                            WA_PubScreen,   ed->ed_Screen,
                                            WA_Title,       GetString(&ed->ed_LocaleInfo,MSG_OSCN_NAME),
                                            WA_NewLookMenus,TRUE,
                                            WA_Gadgets,     ed->ed_Gadgets,
                                            TAG_DONE)))
    {
        return(TRUE);
    }

    DisposeDisplay(ed);
    return(FALSE);
}


/*****************************************************************************/


VOID DisposeDisplay(EdDataPtr ed)
{
    if (ed->ed_Window)
    {
        ClearMenuStrip(ed->ed_Window);
        CloseWindow(ed->ed_Window);
    }
    FreeMenus(ed->ed_Menus);
    FreeGadgets(ed->ed_Gadgets);
}


/*****************************************************************************/


VOID CenterLine(EdDataPtr ed, struct Window *wp, AppStringsID id,
                UWORD x, UWORD y, UWORD w)
{
STRPTR str;
UWORD  len;

    str = GetString(&ed->ed_LocaleInfo,id);
    len = strlen(str);

    Move(wp->RPort,(w-TextLength(wp->RPort,str,len)) / 2 + wp->BorderLeft + x,wp->BorderTop+y);
    Text(wp->RPort,str,len);
}


/*****************************************************************************/


VOID PutSizes(EdDataPtr ed, AppStringsID id, UWORD x, UWORD y, struct Rectangle *rect)
{
char buffer[40];

    sprintf(buffer,GetString(&ed->ed_LocaleInfo,id),RectWidth(rect),RectHeight(rect));

    Move(window->RPort,x+window->BorderLeft,y+window->BorderTop);
    Text(window->RPort,buffer,strlen(buffer));
}


/**************************,***************************************************/


VOID RenderSizes(EdDataPtr ed)
{
    if (window)
    {
        PutSizes(ed,MSG_OSCN_MINSIZE,174,28, &ed->ed_CurrentMon->me_DimensionInfo.Nominal);
        PutSizes(ed,MSG_OSCN_TEXTSIZE,174,37,&ed->ed_CurrentMon->me_DimensionInfo.TxtOScan);
        PutSizes(ed,MSG_OSCN_GFXSIZE,174,46, &ed->ed_CurrentMon->me_DimensionInfo.StdOScan);
        PutSizes(ed,MSG_OSCN_MAXSIZE,174,55, &ed->ed_CurrentMon->me_DimensionInfo.MaxOScan);
    }

    if ((RectWidth(&ed->ed_CurrentMon->me_DimensionInfo.Nominal) == RectWidth(&ed->ed_CurrentMon->me_DimensionInfo.MaxOScan))
    &&  (RectHeight(&ed->ed_CurrentMon->me_DimensionInfo.Nominal) == RectHeight(&ed->ed_CurrentMon->me_DimensionInfo.MaxOScan)))
    {
        ed->ed_EditText = DoPrefsGadget(ed,&EG[4],ed->ed_EditText,GA_Disabled,TRUE,TAG_DONE);
        ed->ed_EditGfx  = DoPrefsGadget(ed,&EG[5],ed->ed_EditGfx,GA_Disabled,TRUE,TAG_DONE);
    }
    else
    {
        ed->ed_EditText = DoPrefsGadget(ed,&EG[4],ed->ed_EditText,GA_Disabled,FALSE,TAG_DONE);
        ed->ed_EditGfx  = DoPrefsGadget(ed,&EG[5],ed->ed_EditGfx,GA_Disabled,FALSE,TAG_DONE);
    }
}


/*****************************************************************************/


VOID DrawBB(EdDataPtr ed, SHORT x, SHORT y, SHORT w, SHORT h, ULONG tags, ...)
{
    DrawBevelBoxA(ed->ed_Window->RPort,x+ed->ed_Window->BorderLeft,
                                       y+ed->ed_Window->BorderTop,
                                       w,h,(struct TagItem *)&tags);
}


/**************************,***************************************************/


VOID RenderDisplay(EdDataPtr ed)
{
    SetAPen(window->RPort,ed->ed_DrawInfo->dri_Pens[TEXTPEN]);
    SetBPen(window->RPort,ed->ed_DrawInfo->dri_Pens[BACKGROUNDPEN]);

    CenterLine(ed,window,MSG_OSCN_OVERSCAN_DIM_HDR,180,12,230);
    DrawBB(ed,170,18,240,44,GT_VisualInfo, ed->ed_VisualInfo,
                            GTBB_Recessed, TRUE,
                            TAG_DONE);
    RenderSizes(ed);
}


/*****************************************************************************/


VOID RenderGadgets(EdDataPtr ed)
{
    RenderSizes(ed);
}


/*****************************************************************************/


VOID ProcessSpecialCommand(EdDataPtr ed, EdCommand ec)
{
struct Requester req;
BOOL             bool;
UWORD            icode;
struct ExtPrefs *ep;

    switch (ec)
    {
        case EC_MONITORLIST: icode = ed->ed_CurrentMsg.Code;
                             ep    = ed->ed_PrefsWork.ep_Next;
                             while (icode--)
                                 ep = ep->ep_Next;

                             ed->ed_CurrentMon = &ep->ep_Monitor;
			     break;

        case EC_EDITTEXT   :
        case EC_EDITGFX    : InitRequester(&req);
                             req.Flags = NOISYREQ;
                             bool = Request(&req,window);

                             EditOverscan(ed,ec == EC_EDITTEXT);

                             if (bool)
                                 EndRequest(&req,window);

                             break;

        default            : break;
    }

    RenderSizes(ed);
}


/*****************************************************************************/


VOID GetSpecialCmdState(EdDataPtr ed, EdCommand ec, CmdStatePtr state)
{
    state->cs_Available = TRUE;
    state->cs_Selected  = FALSE;
}
@


38.21
log
@Temporarily disabled GrowRect()
@
text
@a254 1
/*
a265 1
*/
d350 1
a350 1
	GrowRect( &dimInfo.MaxOScan, &dimInfo.TxtOScan );
d353 1
a353 1
	GrowRect( &dimInfo.MaxOScan, &dimInfo.StdOScan );
d365 1
@


38.20
log
@Fixed range checking code, thanks Peter!
@
text
@d255 1
d267 1
@


38.19
log
@Added origin position code
@
text
@d253 19
d279 1
d291 22
a312 2
        shift.x = ((monInfo.ViewPosition.x - op->os_ViewPos.x) * monInfo.ViewResolution.x) / dispInfo.Resolution.x;
        shift.y = ((monInfo.ViewPosition.y - op->os_ViewPos.y) * monInfo.ViewResolution.y) / dispInfo.Resolution.y;
d316 6
d327 3
d336 1
a336 1
        monInfo.ViewPosition = op->os_ViewPos;
d338 13
a350 11
        /* make sure the view's horizontal position falls within legal range */
        if (monInfo.ViewPosition.x < monInfo.ViewPositionRange.MinX)
            monInfo.ViewPosition.x = monInfo.ViewPositionRange.MinX;
        else if (monInfo.ViewPosition.x > monInfo.ViewPositionRange.MaxX)
            monInfo.ViewPosition.x = monInfo.ViewPositionRange.MaxX;

        /* make sure the view's vertical position falls within legal range */
        if (monInfo.ViewPosition.y < monInfo.ViewPositionRange.MinY)
            monInfo.ViewPosition.y = monInfo.ViewPositionRange.MinY;
        else if (monInfo.ViewPosition.y > monInfo.ViewPositionRange.MaxY)
            monInfo.ViewPosition.y = monInfo.ViewPositionRange.MaxY;
d352 2
a353 39
        /* make sure width of text overscan falls within legal range */
        if (dimInfo.TxtOScan.MaxX - dimInfo.TxtOScan.MinX > dimInfo.MaxOScan.MaxX - dimInfo.MaxOScan.MinX)
        {
            dimInfo.TxtOScan.MinX = 0;
            dimInfo.TxtOScan.MaxX = dimInfo.MaxOScan.MaxX;
        }

        /* make sure height of text overscan falls within legal range */
        if (dimInfo.TxtOScan.MaxY - dimInfo.TxtOScan.MinY > dimInfo.MaxOScan.MaxY - dimInfo.MaxOScan.MinY)
        {
            dimInfo.TxtOScan.MinY = 0;
            dimInfo.TxtOScan.MaxY = dimInfo.MaxOScan.MaxY;
        }

        if (dimInfo.TxtOScan.MaxX > dimInfo.MaxOScan.MaxX)
            ShiftRect(&dimInfo.MaxOScan,dimInfo.TxtOScan.MaxX-dimInfo.MaxOScan.MaxX,0);

        if (dimInfo.TxtOScan.MaxY > dimInfo.MaxOScan.MaxY)
            ShiftRect(&dimInfo.MaxOScan,0,dimInfo.TxtOScan.MaxY-dimInfo.MaxOScan.MaxY);

        if (dimInfo.MaxOScan.MinX > 0)
            ShiftRect(&dimInfo.MaxOScan,-dimInfo.MaxOScan.MinX,0);

        if (dimInfo.MaxOScan.MinY > 0)
            ShiftRect(&dimInfo.MaxOScan,0,-dimInfo.MaxOScan.MinY);

        /* make sure width of graphics overscan falls within legal range */
        if (dimInfo.StdOScan.MaxX - dimInfo.StdOScan.MinX > dimInfo.MaxOScan.MaxX - dimInfo.MaxOScan.MinX)
        {
            dimInfo.StdOScan.MinX = dimInfo.MaxOScan.MinX;
            dimInfo.StdOScan.MaxX = dimInfo.MaxOScan.MaxX;
        }

        /* make sure height of graphics overscan falls within legal range */
        if (dimInfo.StdOScan.MaxY - dimInfo.StdOScan.MinY > dimInfo.MaxOScan.MaxY - dimInfo.MaxOScan.MinY)
        {
            dimInfo.StdOScan.MinY = dimInfo.MaxOScan.MinY;
            dimInfo.StdOScan.MaxY = dimInfo.MaxOScan.MaxY;
        }
@


38.18
log
@Bounds checks values from prefs file against what gfx database says
@
text
@d141 1
a141 1
                            if (monInfo.Mspc && monInfo.Mspc->ms_Node.xln_Name)
d143 7
a149 5
                                stccpy(me->me_Name,monInfo.Mspc->ms_Node.xln_Name,MENAMELEN);
                                len = strlen(me->me_Name);
                                if ((len > 8) && (Stricmp(&me->me_Name[len-8],".monitor")==0))
                                    me->me_Name[len-8] = 0;
                                me->me_Name[0] = ToUpper(me->me_Name[0]);
d151 1
a151 1
                                if ((Stricmp(me->me_Name,"NTSC") == 0) || (Stricmp(me->me_Name,"PAL") == 0))
d153 1
d155 10
a164 2
                                    while (len--)
                                        me->me_Name[len] = ToUpper(me->me_Name[len]);
a165 1

d345 7
a351 1

d479 12
a490 6
        me              = &ep->ep_Monitor;
        op.os_DisplayID = me->me_ID;
	op.os_ViewPos   = me->me_MonitorInfo.ViewPosition;
	op.os_Text.x    = RectWidth(&me->me_DimensionInfo.TxtOScan);
	op.os_Text.y    = RectHeight(&me->me_DimensionInfo.TxtOScan);
	op.os_Standard  = me->me_DimensionInfo.StdOScan;
@


38.17
log
@Removed WA_Left and WA_Top
@
text
@d95 5
d102 8
a109 1

d123 1
a123 2
            &&  (GetDisplayInfoData(dh,(APTR)&monInfo,sizeof(struct MonitorInfo),DTAG_MNTR,INVALID_ID))
            &&  (GetDisplayInfoData(dh,(APTR)&dimInfo,sizeof(struct DimensionInfo),DTAG_DIMS,INVALID_ID)))
d127 6
a132 1
                    if ((dh = FindDisplayInfo(monInfo.PreferredModeID))
d139 1
a139 1
                            me->me_ID = monInfo.PreferredModeID;
d141 1
a141 1
                            if ((monInfo.Mspc) && (monInfo.Mspc->ms_Node.xln_Name))
d224 19
d277 58
a334 1
        monInfo.ViewPosition   = op->os_ViewPos;
a335 3
        me->me_DimensionInfo   = dimInfo;
        me->me_DisplayInfo     = dispInfo;
        me->me_MonitorInfo     = monInfo;
d584 1
@


38.16
log
@Now sets NOISYREQ in the invisible requester so mouse clicks will come through
@
text
@a407 2
#define NW_LEFT      0
#define NW_TOP       0
d458 2
a459 2
    zoomSize[0] = NW_LEFT;
    zoomSize[1] = NW_TOP;
d503 1
a503 3
    &&  (ed->ed_Window = OpenPrefsWindow(ed,WA_Left,        NW_LEFT,
                                            WA_Top,         NW_TOP,
                                            WA_InnerWidth,  NW_WIDTH,
@


38.15
log
@No longer call GetDisplayInfoData() with a NULL first argument, as this is broken in
  KS 37.175
@
text
@d662 1
@


38.14
log
@Changed method of storing prefs
@
text
@d94 1
d109 4
a112 3
            &&  (GetDisplayInfoData(NULL,(APTR)&dispInfo,sizeof(struct DisplayInfo),DTAG_DISP,modeID))
            &&  (GetDisplayInfoData(NULL,(APTR)&monInfo,sizeof(struct MonitorInfo),DTAG_MNTR,modeID))
            &&  (GetDisplayInfoData(NULL,(APTR)&dimInfo,sizeof(struct DimensionInfo),DTAG_DIMS,modeID)))
d116 4
a119 3
                    if ((GetDisplayInfoData(NULL,(APTR)&dispInfo,sizeof(struct DisplayInfo),DTAG_DISP,monInfo.PreferredModeID))
                    &&  (GetDisplayInfoData(NULL,(APTR)&monInfo,sizeof(struct MonitorInfo),DTAG_MNTR,monInfo.PreferredModeID))
                    &&  (GetDisplayInfoData(NULL,(APTR)&dimInfo,sizeof(struct DimensionInfo),DTAG_DIMS,monInfo.PreferredModeID)))
d216 1
d218 4
a221 3
    if ((GetDisplayInfoData(NULL,(APTR)&dispInfo,sizeof(struct DisplayInfo),DTAG_DISP,me->me_ID))
    &&  (GetDisplayInfoData(NULL,(APTR)&monInfo,sizeof(struct MonitorInfo),DTAG_MNTR,me->me_ID))
    &&  (GetDisplayInfoData(NULL,(APTR)&dimInfo,sizeof(struct DimensionInfo),DTAG_DIMS,me->me_ID)))
d329 1
a329 1
        GetDisplayInfoData(NULL,(APTR)&dispInfo,sizeof(struct DisplayInfo),DTAG_DISP,DEFAULT_MONITOR_ID);
d468 1
a468 1
        GetDisplayInfoData(NULL,(APTR)&dispInfo,sizeof(struct DisplayInfo),DTAG_DISP,DEFAULT_MONITOR_ID);
@


38.13
log
@Now correctly selects the Workbench's mode by default
@
text
@d95 1
a95 1
    NewList(&ed->ed_AvailMonitors);
d103 1
a103 1
            for (me = (struct MonitorEntry *)ed->ed_AvailMonitors.lh_Head; me->me_Node.ln_Succ; me = (struct MonitorEntry *)me->me_Node.ln_Succ)
d114 3
a116 6
                    me        = &ed->ed_PrefsInitial.ep_Monitors[ed->ed_NumMonitors++];
                    me->me_ID = monInfo.PreferredModeID;

                    if ((GetDisplayInfoData(NULL,(APTR)&dispInfo,sizeof(struct DisplayInfo),DTAG_DISP,me->me_ID))
                    &&  (GetDisplayInfoData(NULL,(APTR)&monInfo,sizeof(struct MonitorInfo),DTAG_MNTR,me->me_ID))
                    &&  (GetDisplayInfoData(NULL,(APTR)&dimInfo,sizeof(struct DimensionInfo),DTAG_DIMS,me->me_ID)))
d118 1
a118 1
                        if ((monInfo.Mspc) && (monInfo.Mspc->ms_Node.xln_Name))
d120 1
a120 5
                            stccpy(me->me_Name,monInfo.Mspc->ms_Node.xln_Name,MENAMELEN);
                            len = strlen(me->me_Name);
                            if ((len > 8) && (Stricmp(&me->me_Name[len-8],".monitor")==0))
                                me->me_Name[len-8] = 0;
                            me->me_Name[0] = ToUpper(me->me_Name[0]);
d122 1
a122 1
                            if ((Stricmp(me->me_Name,"NTSC") == 0) || (Stricmp(me->me_Name,"PAL") == 0))
d124 1
d126 11
a136 2
                                while (len--)
                                    me->me_Name[len] = ToUpper(me->me_Name[len]);
d139 4
a142 1
                        }
d144 8
a151 11
                        me->me_Node.ln_Name  = me->me_Name;
                        me->me_DisplayInfo   = dispInfo;
                        me->me_DimensionInfo = dimInfo;
                        me->me_MonitorInfo   = monInfo;

                        node = ed->ed_AvailMonitors.lh_Head;
                        while (node->ln_Succ)
                        {
                            if (Stricmp(node->ln_Name,me->me_Node.ln_Name) >= 0)
                                break;
                            node = node->ln_Succ;
a152 1
                        Insert(&ed->ed_AvailMonitors,(struct Node *)me,node->ln_Pred);
d154 1
a154 1
		}
d164 1
a164 1
VOID MapDefaultMonitor(EdDataPtr ed, ULONG fromID, ULONG toID)
d166 10
a175 1
UWORD i;
d177 22
a198 3
    for (i=0; i<ed->ed_NumPrefs; i++)
	if (MONITOR_PART(ed->ed_Prefs[i].os_DisplayID) == fromID)
	    ed->ed_Prefs[i].os_DisplayID = (ed->ed_Prefs[i].os_DisplayID & ~MONITOR_ID_MASK) | toID;
d205 2
a206 1
VOID PrefsToMon(EdDataPtr ed)
a207 4
UWORD                 i;
UWORD                 j;
struct MonitorEntry  *me;
struct OverscanPrefs *op;
d214 3
a216 1
    for (i=0; i<ed->ed_NumPrefs; i++)
d218 29
a246 9
        op = &ed->ed_Prefs[i];
        me = NULL;
	for (j=0; j<ed->ed_NumMonitors; j++)
	{
	    me = &ed->ed_PrefsWork.ep_Monitors[j];
	    if (me->me_ID == op->os_DisplayID)
	        break;
	    me = NULL;
	}
a247 7
	if ((me)
        &&  (GetDisplayInfoData(NULL,(APTR)&dispInfo,sizeof(struct DisplayInfo),DTAG_DISP,me->me_ID))
        &&  (GetDisplayInfoData(NULL,(APTR)&monInfo,sizeof(struct MonitorInfo),DTAG_MNTR,me->me_ID))
        &&  (GetDisplayInfoData(NULL,(APTR)&dimInfo,sizeof(struct DimensionInfo),DTAG_DIMS,me->me_ID)))
	{
	    xscale = monInfo.ViewResolution.x / dispInfo.Resolution.x;
	    yscale = monInfo.ViewResolution.y / dispInfo.Resolution.y;
d249 3
a251 17
	    shift.x = ((monInfo.ViewPosition.x - op->os_ViewPos.x) * monInfo.ViewResolution.x) / dispInfo.Resolution.x;
	    shift.y = ((monInfo.ViewPosition.y - op->os_ViewPos.y) * monInfo.ViewResolution.y) / dispInfo.Resolution.y;

	    ShiftRect(&dimInfo.MaxOScan, shift.x, shift.y);

	    dimInfo.TxtOScan.MinX  = 0;
	    dimInfo.TxtOScan.MinY  = 0;
	    dimInfo.TxtOScan.MaxX  = op->os_Text.x - Modulo(op->os_Text.x, xscale) - 1;
	    dimInfo.TxtOScan.MaxY  = op->os_Text.y - Modulo(op->os_Text.y, yscale) - 1;

	    dimInfo.StdOScan       = op->os_Standard;
	    dimInfo.StdOScan.MinX -= Modulo(dimInfo.StdOScan.MinX, xscale);
	    dimInfo.StdOScan.MinY -= Modulo(dimInfo.StdOScan.MinY, yscale);
	    dimInfo.StdOScan.MaxX -= Modulo((WORD)(dimInfo.StdOScan.MaxX+1), xscale);
	    dimInfo.StdOScan.MaxY -= Modulo((WORD)(dimInfo.StdOScan.MaxY+1), yscale);

	    monInfo.ViewPosition   = op->os_ViewPos;
d253 1
a253 6
	    me->me_DimensionInfo   = dimInfo;
	    me->me_DisplayInfo     = dispInfo;
	    me->me_MonitorInfo     = monInfo;
	}
    }
}
d255 11
d267 2
a268 1
/*****************************************************************************/
d270 2
d273 1
a273 5
VOID MonToPrefs(EdDataPtr ed)
{
UWORD                 i;
struct MonitorEntry  *me;
struct OverscanPrefs *op;
d275 2
a276 14
    for (i=0; i<ed->ed_NumMonitors; i++)
    {
        me = &ed->ed_PrefsWork.ep_Monitors[i];
        op = &ed->ed_Prefs[i];

        op->os_DisplayID = me->me_ID;
	op->os_ViewPos   = me->me_MonitorInfo.ViewPosition;
	op->os_Text.x    = RectWidth(&me->me_DimensionInfo.TxtOScan);
	op->os_Text.y    = RectHeight(&me->me_DimensionInfo.TxtOScan);
	op->os_Standard  = me->me_DimensionInfo.StdOScan;
    }

    ed->ed_NumPrefs = ed->ed_NumMonitors;
}
d282 1
a282 1
EdStatus InitEdData(EdDataPtr ed)
d284 1
a284 6
UWORD i;

    BuildList(ed);

    ed->ed_PrefsWork     = ed->ed_PrefsInitial;
    ed->ed_PrefsDefaults = ed->ed_PrefsInitial;
d286 3
a288 9
    for (i=0; i<ed->ed_NumMonitors; i++)
    {
        ed->ed_PrefsDefaults.ep_Monitors[i].me_DimensionInfo.TxtOScan   = ed->ed_PrefsDefaults.ep_Monitors[i].me_DimensionInfo.Nominal;
        ed->ed_PrefsDefaults.ep_Monitors[i].me_DimensionInfo.StdOScan   = ed->ed_PrefsDefaults.ep_Monitors[i].me_DimensionInfo.Nominal;
        ShiftRect(&ed->ed_PrefsDefaults.ep_Monitors[i].me_DimensionInfo.MaxOScan,
                   ed->ed_PrefsDefaults.ep_Monitors[i].me_MonitorInfo.ViewPosition.x-ed->ed_PrefsDefaults.ep_Monitors[i].me_MonitorInfo.DefaultViewPosition.x,
                   ed->ed_PrefsDefaults.ep_Monitors[i].me_MonitorInfo.ViewPosition.y-ed->ed_PrefsDefaults.ep_Monitors[i].me_MonitorInfo.DefaultViewPosition.y);
        ed->ed_PrefsDefaults.ep_Monitors[i].me_MonitorInfo.ViewPosition = ed->ed_PrefsDefaults.ep_Monitors[i].me_MonitorInfo.DefaultViewPosition;
    }
d290 2
a291 1
    return(ES_NORMAL);
d298 1
a298 1
VOID CleanUpEdData(EdDataPtr ed)
d300 6
a305 1
    FreeRemember(&ed->ed_Tracker,TRUE);
d314 5
d322 1
a322 15
    if (ReadChunkBytes(iff,&ed->ed_Prefs[ed->ed_NumPrefs++],sizeof(struct OverscanPrefs)) == sizeof(struct OverscanPrefs))
        return(ES_NORMAL);

    return(ES_IFFERROR);
}


EdStatus OpenPrefs(EdDataPtr ed, STRPTR name)
{
EdStatus           result;
struct DisplayInfo dispInfo;
ULONG              id;

    ed->ed_NumPrefs = 0;
    if ((result = ReadIFF(ed,name,IFFPrefChunks,IFFPrefChunkCnt,ReadPrefs)) == ES_NORMAL)
d330 15
a344 2
	MapDefaultMonitor(ed,DEFAULT_MONITOR_ID,id);
	PrefsToMon(ed);
d347 7
a353 1
    return(result);
d362 3
a364 1
UWORD num;
d366 9
a374 1
    MonToPrefs(ed);
a375 3
    num = ed->ed_NumPrefs;
    while (num--)
    {
d377 3
a379 1
            if (WriteChunkBytes(iff,&ed->ed_Prefs[num],sizeof(struct OverscanPrefs)) == sizeof(struct OverscanPrefs))
d381 2
d384 3
a386 1

d449 5
a453 5
UWORD                zoomSize[4];
struct DisplayInfo   dispInfo;
ULONG                scrID;
UWORD                currentCnt;
struct MonitorEntry *mon;
a454 4
    /* no monitors, just split! */
    if (ed->ed_NumMonitors == 0)
	return(FALSE);

d470 3
a472 5
    ed->ed_CurrentMon = (struct MonitorEntry *)ed->ed_AvailMonitors.lh_Head;
    currentCnt        = 0;

    mon = (struct MonitorEntry *)ed->ed_AvailMonitors.lh_Head;
    while (mon->me_Node.ln_Succ)
d474 1
a474 1
	if (MONITOR_PART(mon->me_ID) == scrID)
d476 1
a476 1
	    ed->ed_CurrentMon = mon;
d481 1
a481 1
        mon = (struct MonitorEntry *)mon->me_Node.ln_Succ;
d489 1
a489 1
    DoPrefsGadget(ed,&EG[3],NULL,GTLV_Labels,       &ed->ed_AvailMonitors,
d643 1
a643 1
struct Node     *node;
d648 1
a648 1
                             node  = ed->ed_AvailMonitors.lh_Head;
d650 1
a650 1
                                 node = node->ln_Succ;
d652 1
a652 1
                             ed->ed_CurrentMon = (struct MonitorEntry *)node;
@


38.12
log
@*** empty log message ***
@
text
@d410 5
a414 5
UWORD              zoomSize[4];
struct DisplayInfo dispInfo;
ULONG              scrID;
UWORD              currentCnt;
UWORD              i;
d435 1
a435 1
    ed->ed_CurrentMon = &ed->ed_PrefsWork.ep_Monitors[0];
d438 2
a439 1
    for (i=0; i<ed->ed_NumMonitors; i++)
d441 1
a441 1
	if (MONITOR_PART(ed->ed_PrefsWork.ep_Monitors[i].me_ID) == scrID)
d443 1
a443 2
	    ed->ed_CurrentMon = &ed->ed_PrefsWork.ep_Monitors[i];
	    currentCnt        = i;
d446 3
@


38.11
log
@Now capitalized PAL and NTSC in the monitor list
@
text
@d606 2
d611 6
a616 1
        case EC_MONITORLIST: ed->ed_CurrentMon = &ed->ed_PrefsWork.ep_Monitors[ed->ed_CurrentMsg.Code];
@


38.10
log
@Now keeps monitor list in alphabetical order
@
text
@d128 8
@


38.9
log
@Fixed Reset to Defaults
@
text
@d88 1
d135 8
a142 1
                        AddTail(&ed->ed_AvailMonitors,(struct Node *)me);
@


38.8
log
@checkin
Changes for new prefs shell
@
text
@d256 6
a261 2
        ed->ed_PrefsDefaults.ep_Monitors[i].me_DimensionInfo.TxtOScan = ed->ed_PrefsDefaults.ep_Monitors[i].me_DimensionInfo.Nominal;
        ed->ed_PrefsDefaults.ep_Monitors[i].me_DimensionInfo.StdOScan = ed->ed_PrefsDefaults.ep_Monitors[i].me_DimensionInfo.Nominal;
@


38.7
log
@Removed code to deal with unnamed monitors
Now capitalizes the first letter of the monitor name
@
text
@a83 8
VOID ProcessArgs(EdDataPtr ed, struct DiskObject *diskObj)
{
}


/*****************************************************************************/


a581 8
VOID SyncTextGadgets(EdDataPtr ed)
{
}


/*****************************************************************************/


a606 9
}


/*****************************************************************************/


EdCommand GetCommand(EdDataPtr ed)
{
    return(EC_NOP);
@


38.6
log
@*** empty log message ***
@
text
@a100 1
UWORD		     unnamed;
a101 1
    unnamed = 0;
d134 1
a134 4
                        }
                        else
                        {
                            sprintf(me->me_Name,"Monitor %ld",(LONG)(++unnamed));
@


38.5
log
@Fixed incorrect loop index use in PrefsToMon
@
text
@a448 1
                                 GTLV_Top,          currentCnt,
@


38.4
log
@Added SyncTextGadgets() support
@
text
@d175 1
d188 1
a188 1
	for (i=0; i<ed->ed_NumMonitors; i++)
d190 1
a190 1
	    me = &ed->ed_PrefsWork.ep_Monitors[i];
d449 1
@


38.3
log
@Now uses DoPrefsGadget() instead of CreatePrefsGadget() to improve visuals on window
  opening
@
text
@d58 26
d307 1
a307 1
    if ((result = ReadIFF(ed,name,ReadPrefs)) == ES_NORMAL)
d349 1
a349 1
    return(WriteIFF(ed,name,WritePrefs));
a416 5
    if (!(ed->ed_Menus = CreatePrefsMenus(ed,EM)))
    {
	return(FALSE);
    }

d454 26
a479 30
    if (!ed->ed_LastAdded)
    {
        DisposeDisplay(ed);
        return(FALSE);
    }

    if (!(ed->ed_Window = OpenPrefsWindow(ed,WA_Left,        NW_LEFT,
                                             WA_Top,         NW_TOP,
                                             WA_InnerWidth,  NW_WIDTH,
                                             WA_InnerHeight, NW_HEIGHT,
                                             WA_MinWidth,    NW_MINWIDTH,
                                             WA_MinHeight,   NW_MINHEIGHT,
                                             WA_MaxWidth,    NW_MAXWIDTH,
                                             WA_MaxHeight,   NW_MAXHEIGHT,
                                             WA_IDCMP,       NW_IDCMP,
                                             WA_Flags,       NW_FLAGS,
                                             WA_Zoom,        zoomSize,
                                             WA_AutoAdjust,  TRUE,
                                             WA_PubScreen,   ed->ed_Screen,
                                             WA_Title,       GetString(&ed->ed_LocaleInfo,MSG_OSCN_NAME),
                                             WA_NewLookMenus,TRUE,
                                             WA_Gadgets,     ed->ed_Gadgets,
                                             TAG_DONE)))
    {
        DisposeDisplay(ed);
	return(FALSE);
    }

    return(TRUE);
}
d588 8
@


38.2
log
@Now uses WA_Gadgets to add the gadgets to the window
@
text
@d420 3
a422 3
    CreatePrefsGadget(ed,&EG[0],TAG_DONE);
    CreatePrefsGadget(ed,&EG[1],TAG_DONE);
    CreatePrefsGadget(ed,&EG[2],TAG_DONE);
d424 6
a429 6
    CreatePrefsGadget(ed,&EG[3],GTLV_Labels,       &ed->ed_AvailMonitors,
                                GTLV_ShowSelected, NULL,
                                GTLV_Selected,     currentCnt,
                                LAYOUTA_SPACING,   1,
                                GTLV_ScrollWidth,  18,
                                TAG_DONE);
d431 1
a431 2
    ed->ed_EditText = CreatePrefsGadget(ed,&EG[4],TAG_DONE);
    ed->ed_EditGfx  = CreatePrefsGadget(ed,&EG[5],TAG_DONE);
d516 7
a522 4
    PutSizes(ed,MSG_OSCN_MINSIZE,174,28, &ed->ed_CurrentMon->me_DimensionInfo.Nominal);
    PutSizes(ed,MSG_OSCN_TEXTSIZE,174,37,&ed->ed_CurrentMon->me_DimensionInfo.TxtOScan);
    PutSizes(ed,MSG_OSCN_GFXSIZE,174,46, &ed->ed_CurrentMon->me_DimensionInfo.StdOScan);
    PutSizes(ed,MSG_OSCN_MAXSIZE,174,55, &ed->ed_CurrentMon->me_DimensionInfo.MaxOScan);
d527 2
a528 2
        SetGadgetAttr(ed,ed->ed_EditText,GA_Disabled,TRUE,TAG_DONE);
        SetGadgetAttr(ed,ed->ed_EditGfx,GA_Disabled,TRUE,TAG_DONE);
d532 2
a533 2
        SetGadgetAttr(ed,ed->ed_EditText,GA_Disabled,FALSE,TAG_DONE);
        SetGadgetAttr(ed,ed->ed_EditGfx,GA_Disabled,FALSE,TAG_DONE);
d538 11
d558 3
a560 3
    DrawPrefsBevelBox(ed,170,18,240,44,GT_VisualInfo, ed->ed_VisualInfo,
                                       GTBB_Recessed, TRUE,
                                       TAG_DONE);
@


38.1
log
@Initial V38 RCS checkin
@
text
@a395 21
    if (!(ed->ed_Window = OpenPrefsWindow(ed,WA_Left,        NW_LEFT,
                                             WA_Top,         NW_TOP,
                                             WA_InnerWidth,  NW_WIDTH,
                                             WA_InnerHeight, NW_HEIGHT,
                                             WA_MinWidth,    NW_MINWIDTH,
                                             WA_MinHeight,   NW_MINHEIGHT,
                                             WA_MaxWidth,    NW_MAXWIDTH,
                                             WA_MaxHeight,   NW_MAXHEIGHT,
                                             WA_IDCMP,       NW_IDCMP,
                                             WA_Flags,       NW_FLAGS,
                                             WA_Zoom,        zoomSize,
                                             WA_AutoAdjust,  TRUE,
                                             WA_PubScreen,   ed->ed_Screen,
                                             WA_Title,       GetString(&ed->ed_LocaleInfo,MSG_OSCN_NAME),
                                             WA_NewLookMenus,TRUE,
                                             TAG_DONE)))
    {
        FreeMenus(ed->ed_Menus);
	return(FALSE);
    }

d440 22
d471 5
a475 2
    ClearMenuStrip(ed->ed_Window);
    CloseWindow(ed->ed_Window);
@
