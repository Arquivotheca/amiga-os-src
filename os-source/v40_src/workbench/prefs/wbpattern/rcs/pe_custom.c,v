head     38.20;
branch   ;
access   ;
symbols  ;
locks    davidj:38.20; strict;
comment  @ * @;


38.20
date     93.01.25.14.23.09;  author davidj;  state Exp;
branches ;
next     38.19;

38.19
date     92.08.26.14.20.09;  author davidj;  state Exp;
branches ;
next     38.18;

38.18
date     92.08.13.13.19.22;  author davidj;  state Exp;
branches ;
next     38.17;

38.17
date     92.08.03.17.17.31;  author davidj;  state Exp;
branches ;
next     38.16;

38.16
date     92.07.29.14.38.03;  author davidj;  state Exp;
branches ;
next     38.15;

38.15
date     92.07.09.15.11.24;  author davidj;  state Exp;
branches ;
next     38.14;

38.14
date     92.06.24.17.32.35;  author davidj;  state Exp;
branches ;
next     38.13;

38.13
date     92.06.24.02.06.21;  author davidj;  state Exp;
branches ;
next     38.12;

38.12
date     92.06.16.15.03.03;  author davidj;  state Exp;
branches ;
next     38.11;

38.11
date     92.06.12.00.45.42;  author davidj;  state Exp;
branches ;
next     38.10;

38.10
date     92.06.10.02.22.37;  author davidj;  state Exp;
branches ;
next     38.9;

38.9
date     92.03.25.11.34.42;  author davidj;  state Exp;
branches ;
next     38.8;

38.8
date     92.03.16.10.46.47;  author davidj;  state Exp;
branches ;
next     38.7;

38.7
date     92.03.02.11.20.01;  author davidj;  state Exp;
branches ;
next     38.6;

38.6
date     92.02.17.16.18.09;  author davidj;  state Exp;
branches ;
next     38.5;

38.5
date     92.02.03.17.27.15;  author davidj;  state Exp;
branches ;
next     38.4;

38.4
date     92.01.27.10.27.53;  author davidj;  state Exp;
branches ;
next     38.3;

38.3
date     91.11.26.13.40.25;  author davidj;  state Exp;
branches ;
next     38.2;

38.2
date     91.11.22.08.54.51;  author Unknown;  state Exp;
branches ;
next     38.1;

38.1
date     91.11.12.10.55.54;  author Unknown;  state Exp;
branches ;
next     ;


desc
@wbpattern specific code
@


38.20
log
@checks for directory in filter
@
text
@/* pe_custom.c
 * WBPattern Preference Editor
 *
 */

#include "wbpattern.h"

extern struct BitMap Presets;

UWORD ghost_pattern[] = {0x4444, 0x1111, 0x4444, 0x1111};

/*****************************************************************************/

#pragma libcall WorkbenchBase WBConfig 54 1002
void *WBConfig (ULONG, void *);

struct PatternBitMap
{
    struct BitMap *pbm_BitMap;
    UWORD pbm_Width;
    UWORD pbm_Height;
};

/*****************************************************************************/

#define	PWIDTH		16
#define	PHEIGHT		16
#define	PDEPTH		2

#define	XSCALE		6
#define	YSCALE		6

#define NW_LEFT		0
#define NW_TOP		0
#define NW_WIDTH	634
#define NW_HEIGHT	126
#define	BUTTON_WIDTH	87

#define NW_IDCMP	(IDCMP_CLOSEWINDOW | IDCMP_MENUPICK | IDCMP_REFRESHWINDOW | BUTTONIDCMP | PALETTEIDCMP | SLIDERIDCMP)
#define BNW_FLAGS	(WFLG_ACTIVATE | SIMPLE_REFRESH)
#define NW_FLAGS	(WFLG_ACTIVATE | WINDOWDEPTH | WINDOWDRAG | SIMPLE_REFRESH)
#define NW_MINWIDTH	NW_WIDTH
#define NW_MINHEIGHT	NW_HEIGHT
#define NW_MAXWIDTH	NW_WIDTH
#define NW_MAXHEIGHT	NW_HEIGHT
#define ZOOMWIDTH	200

/* Sketchpad left edge */
#define	SKETCH_LEFT	432	/* was 327 */

/* Tool left edge */
#define	TOOL_LEFT	534	/* was 429 */

/* Preset left edge */
#define	PRESET_LEFT	340	/* was 527 */

/* Preset top edge */
#define	PRESET_TOP	67

/* Repeat top edge */
#define	REPEAT_TOP	4

#define	XREPEATS	4
#define	YREPEATS	3

#define	DX		4
#define	DY		2
#define	DW		8
#define	DH		4

/*****************************************************************************/

VOID
ProcessArgs (EdDataPtr ed, struct DiskObject * diskObj)
{
    UBYTE *tmp;
    ULONG hold;

    if (diskObj)
    {
	if (tmp = FindToolType (diskObj->do_ToolTypes, "CLIPUNIT"))
	    if (StrToLong (tmp, &hold) > 0L)
		ed->ed_ClipUnit = hold;

	ed->ed_RemapImage = TRUE;
	if (FindToolType (diskObj->do_ToolTypes, "NOREMAP"))
	    ed->ed_RemapImage = FALSE;
    }
    else
    {
	if (ed->ed_Args[OPT_CLIPUNIT])
	    ed->ed_ClipUnit = *((ULONG *) ed->ed_Args[OPT_CLIPUNIT]);

	ed->ed_RemapImage = (ed->ed_Args[OPT_NOREMAP]) ? FALSE : TRUE;
    }
    ed->ed_PubScreenName = "Workbench";
}

/*****************************************************************************/

/* Need to copy the type (pattern or picture) and the data
(pattern data or picture name). */
VOID CopyPrefs (EdDataPtr ed, struct ExtPrefs * dp, struct ExtPrefs * sp)
{
    UWORD i;

    /* Make a backup if we are changing the work buffer */
    if (dp == &ed->ed_PrefsWork)
	Store (ed);

    bltbm (&(sp->ep_BMap), 0, 0,
	   &(dp->ep_BMap), 0, 0, (ed->ed_Width * 3), ed->ed_Height,
	   0xC0, 0xFF, NULL, ed->ed_GfxBase);

    /* Copy the type (picture or pattern) */
    dp->ep_WBP[0].wbp_Flags = sp->ep_WBP[0].wbp_Flags;
    dp->ep_WBP[1].wbp_Flags = sp->ep_WBP[1].wbp_Flags;
    dp->ep_WBP[2].wbp_Flags = sp->ep_WBP[2].wbp_Flags;

    /* Copy the names also */
    for (i = 0; i < 3; i++)
	strcpy (dp->ep_Path[i], sp->ep_Path[i]);

    /* Set the current type */
    ed->ed_Type = 0x1 & (ed->ed_PrefsWork.ep_WBP[(ed->ed_Which / ed->ed_Width)].wbp_Flags);
}

/*****************************************************************************/

BOOL InitDisp (EdDataPtr ed)
{

    return (TRUE);
}

/*****************************************************************************/

EdStatus InitEdData (EdDataPtr ed)
{
    struct Screen *scr;

    ed->ed_FilterHook.h_Entry = Filter;
    ed->ed_FilterHook.h_Data = ed;

    /* Initialize the sketchpad gadget */
    if (ed->ed_SketchClass = initsketchGClass (ed))
    {
	/* Default to the first pen in our palette */
	ed->ed_APen = 1;

	/* Set the maximum width, height & depth */
	ed->ed_Width = 16;
	ed->ed_Height = 16;
	ed->ed_Depth = 3;
	if (scr = LockPubScreen (NULL))
	{
	    ed->ed_Depth = scr->BitMap.Depth;
	    UnlockPubScreen (NULL, scr);
	}

	/* Set the amount to magnify by */
	ed->ed_XMag = ed->ed_YMag = 6;

	/* Default to pattern */
	ed->ed_PrefsDefaults.ep_WBP[0].wbp_Flags = 0x1;
	ed->ed_PrefsDefaults.ep_WBP[1].wbp_Flags = 0x1;
	ed->ed_PrefsDefaults.ep_WBP[2].wbp_Flags = 0x1;

	/* Create the bitplanes */
	if ((allocpp (ed, &ed->ed_PrefsDefaults)) == ES_NORMAL)
	{
	    if ((allocpp (ed, &ed->ed_PrefsWork)) == ES_NORMAL)
	    {
		if ((allocpp (ed, &ed->ed_PrefsInitial)) == ES_NORMAL)
		{
		    if (allocbitmap (ed, &ed->ed_Undo, ed->ed_Depth, ed->ed_Width, ed->ed_Height))
		    {
			if (allocbitmap (ed, &ed->ed_Temp, ed->ed_Depth, ed->ed_Width, ed->ed_Height))
			{
			    /* Make the default image */
			    CopyFromDefault (ed);

			    return (ES_NORMAL);
			}
			freebitmap (ed, &(ed->ed_Temp), ed->ed_Width, ed->ed_Height);
		    }
		    freebitmap (ed, &(ed->ed_Undo), ed->ed_Width, ed->ed_Height);
		}
		freebitmap (ed, &(ed->ed_PrefsInitial.ep_BMap), (ed->ed_Width * 3) + 2, ed->ed_Height);
	    }
	    freebitmap (ed, &(ed->ed_PrefsWork.ep_BMap), (ed->ed_Width * 3) + 2, ed->ed_Height);
	}
	freebitmap (ed, &(ed->ed_PrefsDefaults.ep_BMap), (ed->ed_Width * 3) + 2, ed->ed_Height);
    }
    return (ES_NO_MEMORY);
}

/*****************************************************************************/

VOID CleanUpEdData (EdDataPtr ed)
{

    /* Did they hit the cancel button? */
    if (ed->ed_Cancelled && (ed->ed_Flags & (EDF_TESTBD | EDF_CHANGED)))
    {
	/* Restore the initial pointer */
	CopyPrefs (ed, &ed->ed_PrefsWork, &ed->ed_PrefsInitial);
	SavePrefs (ed, ENV_NAME);
    }

    /* Free the bitmaps */
    freebitmap (ed, &(ed->ed_PrefsInitial.ep_BMap), (ed->ed_Width * 3) + 2, ed->ed_Height);
    freebitmap (ed, &(ed->ed_PrefsWork.ep_BMap), (ed->ed_Width * 3) + 2, ed->ed_Height);
    freebitmap (ed, &(ed->ed_PrefsDefaults.ep_BMap), (ed->ed_Width * 3) + 2, ed->ed_Height);

    /* Free the bitmaps */
    freebitmap (ed, &(ed->ed_Temp), ed->ed_Width, ed->ed_Height);
    freebitmap (ed, &(ed->ed_Undo), ed->ed_Width, ed->ed_Height);

    /* Get rid of the sketch class */
    if (ed->ed_SketchClass)
    {
	freesketchGClass (ed, ed->ed_SketchClass);
    }
    FreeAslRequest (ed->ed_ImageReq);
    FreeAslRequest (ed->ed_SampleReq);
}

/*****************************************************************************/

struct EdMenu far EM[] =
{
    {NM_TITLE, MSG_PROJECT_MENU, EC_NOP, 0},
    {NM_ITEM, MSG_PROJECT_OPEN, EC_OPEN, 0},
    {NM_ITEM, MSG_PROJECT_SAVE_AS, EC_SAVEAS, 0},
    {NM_ITEM, MSG_NOTHING, EC_NOP, 0},
    {NM_ITEM, MSG_PROJECT_QUIT, EC_CANCEL, 0},

    {NM_TITLE, MSG_EDIT_MENU, EC_NOP, 0},
    {NM_ITEM, MSG_EDIT_CUT, EC_CUT, 0},
    {NM_ITEM, MSG_EDIT_COPY, EC_COPY, 0},
    {NM_ITEM, MSG_EDIT_PASTE, EC_PASTE, 0},
    {NM_ITEM, MSG_NOTHING, EC_NOP, 0},
    {NM_ITEM, MSG_EDIT_ERASE, EC_ERASE, 0},
    {NM_ITEM, MSG_NOTHING, EC_NOP, 0},
    {NM_ITEM, MSG_EDIT_UNDO, EC_UNDO, 0},
    {NM_ITEM, MSG_NOTHING, EC_NOP, 0},
    {NM_ITEM, MSG_WBP_EDIT_LOAD_IMAGE, EC_LOAD_IMAGE, 0},
    {NM_ITEM, MSG_NOTHING, EC_NOP, 0},
    {NM_ITEM, MSG_EDIT_RESET_TO_DEFAULTS, EC_MYRESETALL, 0},
    {NM_ITEM, MSG_EDIT_LAST_SAVED, EC_MYLASTSAVED, 0},
    {NM_ITEM, MSG_EDIT_RESTORE, EC_MYRESTORE, 0},

    {NM_TITLE, MSG_OPTIONS_MENU, EC_NOP, 0},
    {NM_ITEM, MSG_OPTIONS_SAVE_ICONS, EC_SAVEICONS, CHECKIT | MENUTOGGLE},

    {NM_END, MSG_NOTHING, EC_NOP, 0}
};

/*****************************************************************************/

/* main display gadgets */
struct EdGadget far EG[] =
{
    {BUTTON_KIND, 8, 107, BUTTON_WIDTH, 14, MSG_SAVE_GAD, EC_SAVE, 0},
    {BUTTON_KIND, 273, 107, BUTTON_WIDTH, 14, MSG_USE_GAD, EC_USE, 0},
    {BUTTON_KIND, NW_WIDTH-4-BUTTON_WIDTH, 107, BUTTON_WIDTH, 14, MSG_CANCEL_GAD, EC_CANCEL, 0},

    {CYCLE_KIND, 143, 4, 178, 16, MSG_WBP_PLACEMENT_GAD, EC_WHICH, 0},		/* Placement: */

    {BUTTON_KIND, 143, 89, 178, 14, MSG_WBP_TEST_GAD, EC_TEST, 0},		/* Test */

    {BUTTON_KIND, TOOL_LEFT, 89, 96, 14, MSG_WBP_CLEAR_GAD, EC_CLEAR, 0},	/* Clear */
    {BUTTON_KIND, TOOL_LEFT, 73, 96, 14, MSG_WBP_UNDO_GAD, EC_UNDO, 0},		/* Undo */
    {PALETTE_KIND, TOOL_LEFT, 4, 96, 66, NULL, EC_PALETTE, 0},

    {CYCLE_KIND, 143, 23, 178, 16, MSG_WBP_TYPE_GAD, EC_TYPE, 0},		/* Type: */

    {BUTTON_KIND, 143, 46, 178, 14, MSG_WBP_SELECT_PICTURE_GAD, EC_SELECT, 0},	/* Select Picture... */
    {TEXT_KIND, 143, 61, 178, 14, MSG_WBP_PICTURE_NAME_GAD, EC_NOP, 0},		/* Picture Name: */
};

/*****************************************************************************/

BOOL CreateDisplay (EdDataPtr ed)
{
    struct EdGadget eg = {NULL};
    register WORD i, j, k;
    struct LocaleInfo *li;
    struct Gadget *gad;

    if (ed->ed_Screen)
    {
	j = 1 << ed->ed_Screen->BitMap.Depth;
	for (i = 0; i < 4; i++)
	    ed->ed_ColorTable[i] = i;
	for (i = 1, k = 7; i < 5; i++, k--)
	    ed->ed_ColorTable[k] = j - i;
    }

    li = &(ed->ed_LocaleInfo);
    ed->ed_WhichLabels[0] = GetString (li, MSG_WBP_WORKBENCH_GAD);
    ed->ed_WhichLabels[1] = GetString (li, MSG_WBP_WINDOWS_GAD);
    ed->ed_WhichLabels[2] = GetString (li, MSG_WBP_SCREEN_GAD);

    ed->ed_TypeLabels[0] = GetString (li, MSG_WBP_TYPE_PICTURE_GAD);
    ed->ed_TypeLabels[1] = GetString (li, MSG_WBP_TYPE_PATTERN_GAD);

    ed->ed_LastAdded = CreateContext (&ed->ed_Gadgets);

    DoPrefsGadget (ed, &EG[0], NULL, TAG_DONE);
    DoPrefsGadget (ed, &EG[1], NULL, TAG_DONE);
    DoPrefsGadget (ed, &EG[2], NULL, TAG_DONE);

    /* Build the editor specific gadgets */
    RenderGadgets (ed);

    /* Add the preset gadgets */
    eg.eg_GadgetKind = GENERIC_KIND;
    eg.eg_LeftEdge = PRESET_LEFT + DX;
    eg.eg_TopEdge = PRESET_TOP + DY;
    eg.eg_Width = PWIDTH;
    eg.eg_Height = PHEIGHT;
    eg.eg_Label = NULL;
    eg.eg_Command = EC_PRESETS;
    eg.eg_GadgetFlags = NULL;

    for (i = 0; i < MAXPRESETS; i++)
    {
	if (ed->ed_GPresets[i] = gad = DoPrefsGadget (ed, &eg, NULL, TAG_DONE))
	{
	    gad->UserData = (APTR) i;
	    gad->Flags = (ed->ed_Type) ? GFLG_GADGHCOMP : GFLG_GADGHCOMP | GFLG_DISABLED;
	    gad->Activation = RELVERIFY;
	    gad->GadgetType |= BOOLGADGET;
	}
	if (i == 3)
	{
	    eg.eg_LeftEdge = PRESET_LEFT + DX;
	    eg.eg_TopEdge += PHEIGHT;
	}
	else
	{
	    eg.eg_LeftEdge += PWIDTH;
	}
    }

    /* Create the menus and open the window */
    if ((ed->ed_LastAdded)
	&& (ed->ed_Menus = CreatePrefsMenus (ed, EM))
	&& (ed->ed_Window = OpenPrefsWindow (ed,
					     WA_IDCMP, NW_IDCMP,
					     WA_Flags, NW_FLAGS,
					     WA_InnerWidth, NW_WIDTH,
					     WA_InnerHeight, NW_HEIGHT,
					     WA_MinWidth, NW_MINWIDTH,
					     WA_MinHeight, NW_MINHEIGHT,
					     WA_MaxWidth, NW_MAXWIDTH,
					     WA_MaxHeight, NW_MAXHEIGHT,
					     WA_Title, GetString (&ed->ed_LocaleInfo, MSG_PREFS_NAME),
					     WA_AutoAdjust, TRUE,
					     WA_PubScreen, ed->ed_Screen,
					     WA_NewLookMenus, TRUE,
					     WA_Gadgets, ed->ed_Gadgets,
					     TAG_DONE)))
    {
	/* Bring the screen to front */
	ScreenToFront (ed->ed_Screen);

	return (TRUE);
    }
    DisposeDisplay (ed);

    return (FALSE);
}

/*****************************************************************************/

VOID
DisposeDisplay (EdDataPtr ed)
{

    /* Do we have a window? */
    if (ed->ed_Window)
    {
	ClearMenuStrip (ed->ed_Window);
	CloseWindow (ed->ed_Window);
    }
    /* Free the menus */
    FreeMenus (ed->ed_Menus);

    /* Free the GadTools gadgets */
    FreeGadgets (ed->ed_Gadgets);

    /* Do we have a sketchpad? */
    if (ed->ed_GSketch)
    {
	DisposeObject (ed->ed_GSketch);
	ed->ed_GSketch = NULL;
    }
}

/*****************************************************************************/

VOID
CenterLine (EdDataPtr ed, struct RastPort * rp, AppStringsID id,
	    UWORD x, UWORD y, UWORD w)
{
    STRPTR str;
    UWORD len;

    str = GetString (&ed->ed_LocaleInfo, id);
    len = strlen (str);

    Move (rp, (w - TextLength (rp, str, len)) / 2 + window->BorderLeft + x,
	  window->BorderTop + y);

    Text (rp, str, len);
}

/*****************************************************************************/

VOID RefreshRepeats (EdDataPtr ed)
{
    register WORD x, y;

    /* Get a pointer to the sketchpad rastport */
    if (ed->ed_Window)
    {
	for (y = REPEAT_TOP + DY + ed->ed_Window->BorderTop;
	     y < REPEAT_TOP + DY + ed->ed_Window->BorderTop + YREPEATS * ed->ed_Height;
	     y += ed->ed_Height)
	{
	    for (x = PRESET_LEFT + DX + ed->ed_Window->BorderLeft;
		 x < PRESET_LEFT + DX + ed->ed_Window->BorderLeft + XREPEATS * ed->ed_Width;
		 x += ed->ed_Width)
	    {
		bltbmrp (&(ed->ed_PrefsWork.ep_BMap), ed->ed_Which, 0,
			 ed->ed_Window->RPort, x, y, ed->ed_Width, ed->ed_Height,
			 0xC0, ed->ed_GfxBase);
	    }
	}
    }
}

/*****************************************************************************/

VOID RenderDisplay (EdDataPtr ed)
{
    struct RastPort *rp;

    rp = ed->ed_Window->RPort;
    SetAPen (rp, ed->ed_DrawInfo->dri_Pens[HIGHLIGHTTEXTPEN]);
    SetBPen (rp, ed->ed_DrawInfo->dri_Pens[BACKGROUNDPEN]);

    /* Draw the labels */
    CenterLine (ed, rp, MSG_WBP_PRESETS_LABEL, PRESET_LEFT - 8, PRESET_TOP - 3, 71 + 16);

    /* Draw the border around the sketchpad */
    DrawBB (ed,
	    ed->ed_GSketch->LeftEdge - 1,
	    ed->ed_GSketch->TopEdge,
	    ed->ed_GSketch->Width + 2,
	    ed->ed_GSketch->Height,
	    GT_VisualInfo, ed->ed_VisualInfo,
	    TAG_DONE);

    /* Draw the border around the repeat area */
    DrawBB (ed,
	    PRESET_LEFT + ed->ed_Window->BorderLeft,
	    REPEAT_TOP + ed->ed_Window->BorderTop,
	    XREPEATS * PWIDTH + DW,
	    YREPEATS * PHEIGHT + DH,
	    GT_VisualInfo, ed->ed_VisualInfo,
	    GTBB_Recessed, TRUE,
	    TAG_DONE);

    /* Draw the repeat area */
    RefreshRepeats (ed);

    /* Draw the border around the preset area */
    DrawBB (ed,
	    PRESET_LEFT + ed->ed_Window->BorderLeft,
	    PRESET_TOP + ed->ed_Window->BorderTop,
	    XREPEATS * PWIDTH + DW,
	    2 * PHEIGHT + DH,
	    GT_VisualInfo, ed->ed_VisualInfo,
	    TAG_DONE);

    /* Show the presets */
    WaitBlit ();
    bltbmrp (&Presets, 0, 0,
	     rp,
	     PRESET_LEFT + DX + ed->ed_Window->BorderLeft,
	     PRESET_TOP + DY + ed->ed_Window->BorderTop,
	     (XREPEATS * PWIDTH), (2 * PHEIGHT),
	     0xC0, ed->ed_GfxBase);

    if (ed->ed_Type == 0)
    {
	WaitBlit ();

	SetAfPt (rp, ghost_pattern, 2);
	SetDrMd (rp, JAM1);
	SetAPen (rp, ed->ed_DrawInfo->dri_Pens[TEXTPEN]);

	RectFill (rp,
		  PRESET_LEFT + DX + ed->ed_Window->BorderLeft,
		  REPEAT_TOP + DY + ed->ed_Window->BorderTop,
		  PRESET_LEFT + DX + ed->ed_Window->BorderLeft + (XREPEATS * ed->ed_Height) - 1,
		  REPEAT_TOP + DY + ed->ed_Window->BorderTop + (YREPEATS * ed->ed_Width) - 1);
	RectFill (rp,
		  PRESET_LEFT + DX + ed->ed_Window->BorderLeft,
		  PRESET_TOP + DY + ed->ed_Window->BorderTop,
		  PRESET_LEFT + DX + ed->ed_Window->BorderLeft + (XREPEATS * PWIDTH) - 1,
		  PRESET_TOP + DY + ed->ed_Window->BorderTop + (2 * PHEIGHT) - 1);
	SetAfPt (rp, NULL, 0);
    }
}

/*****************************************************************************/

VOID RenderGadgets (EdDataPtr ed)
{
    UWORD i;

    /* Set the radio button for which image to edit */
    ed->ed_GWhich = DoPrefsGadget (ed, &EG[3], ed->ed_GWhich,
				   GTCY_Labels, ed->ed_WhichLabels,
				   GTCY_Active, ed->ed_Which / ed->ed_Width,
				   TAG_DONE);

    /* Set all the buttons up. */
    ed->ed_GTest = DoPrefsGadget (ed, &EG[4], ed->ed_GTest, TAG_DONE);
    ed->ed_GClear = DoPrefsGadget (ed, &EG[5], ed->ed_GClear,
				   GA_Disabled, ((ed->ed_Type) ? FALSE : TRUE),
				   TAG_DONE);
    ed->ed_GUndo = DoPrefsGadget (ed, &EG[6], ed->ed_GUndo,
				  GA_Disabled, ((ed->ed_Type) ? FALSE : TRUE),
				  TAG_DONE);

    /* Set the palette */
    ed->ed_GPalette = DoPrefsGadget (ed, &EG[7], ed->ed_GPalette,
				     GTPA_ColorTable, ed->ed_ColorTable,
				     GTPA_Depth, MIN (ed->ed_Screen->BitMap.Depth, 3),
				     GTPA_Color, ed->ed_APen,
				     GTPA_IndicatorHeight, 15,
				     GA_Disabled, ((ed->ed_Type) ? FALSE : TRUE),
				     TAG_DONE);

    ed->ed_GType = DoPrefsGadget (ed, &EG[8], ed->ed_GType,
				  GTCY_Labels, ed->ed_TypeLabels,
				  GTCY_Active, ed->ed_Type,
				  TAG_DONE);

    ed->ed_GSelect = DoPrefsGadget (ed, &EG[9], ed->ed_GSelect,
				    GA_Disabled, ((ed->ed_Type) ? TRUE : FALSE),
				    TAG_DONE);

    ed->ed_GName = DoPrefsGadget (ed, &EG[10], ed->ed_GName,
				  GTTX_Border, TRUE,
				  GTTX_Text, (ed->ed_Type) ? "" : FilePart (&ed->ed_PrefsWork.ep_Path[(ed->ed_Which / ed->ed_Width)][0]),
				  GA_Disabled, ((ed->ed_Type) ? TRUE : FALSE),
				  TAG_DONE);

    /* Create the sketchpad gadget */
    if (ed->ed_LastAdded && (ed->ed_GSketch == NULL))
    {
	ed->ed_LastAdded = ed->ed_GSketch = (struct Gadget *)
	  NewPrefsObject (ed,
			  ed->ed_SketchClass, NULL,
			  GA_Left, SKETCH_LEFT + ed->ed_Screen->WBorLeft,
			  GA_Top, 4 + ed->ed_Screen->WBorTop + ed->ed_Screen->Font->ta_YSize + 1,
			  GA_Width, 2 + (PWIDTH * XSCALE) + 1,
			  GA_Height, 2 + (PHEIGHT * YSCALE) + 1,
			  GA_Immediate, TRUE,
			  GA_FollowMouse, TRUE,
			  GA_RelVerify, TRUE,
			  GA_ID, EC_SKETCH,
			  GA_Previous, ed->ed_LastAdded,
			  TAG_DONE);
    }

    if (ed->ed_GPresets[0])
    {
	USHORT pos;

	for (i = 0; i < MAXPRESETS; i++)
	{
	    pos = RemoveGList (ed->ed_Window, ed->ed_GPresets[i], 1L);
	    if (ed->ed_Type)
		ed->ed_GPresets[i]->Flags &= ~GFLG_DISABLED;
	    else
		ed->ed_GPresets[i]->Flags |= GFLG_DISABLED;
	    AddGList (ed->ed_Window, ed->ed_GPresets[i], (LONG) pos, 1L, NULL);
	}
    }

    /* Set the sketch pad */
    if (ed->ed_GSketch)
    {
	setgadgetattrs (ed, ed->ed_GSketch, GA_Disabled, ((ed->ed_Type) ? FALSE : TRUE), TAG_DONE);

	/* Update the sketchpad */
	UpdateSketch (ed);
    }
}

/*****************************************************************************/

VOID SyncTextGadgets (EdDataPtr ed)
{
}

/*****************************************************************************/

APTR newdtobject (EdDataPtr ed, STRPTR name, Tag tag1,...)
{

    return (NewDTObjectA (name, (struct TagItem *) & tag1));
}

/*****************************************************************************/

ULONG getdtattrs (EdDataPtr ed, Object * o, ULONG data,...)
{

    return (GetDTAttrsA (o, (struct TagItem *) & data));
}

/*****************************************************************************/

ULONG setdtattrs (EdDataPtr ed, Object * o, ULONG data,...)
{

    return (SetDTAttrsA (o, NULL, NULL, (struct TagItem *) & data));
}

/*****************************************************************************/

EdStatus UndoFunc (EdDataPtr ed)
{

    /* Restore the undo buffer */
    setgadgetattrs (ed, ed->ed_GSketch,
		    SPA_Restore, TRUE,
		    TAG_DONE);

    /* Draw the repeat area */
    RenderGadgets (ed);

    return (ES_NORMAL);
}

/*****************************************************************************/

EdStatus ClearFunc (EdDataPtr ed)
{

    /* Clear the work area */
    setgadgetattrs (ed, ed->ed_GSketch,
		    SPA_Store, TRUE,
		    SPA_Clear, TRUE,
		    TAG_DONE);

    /* Draw the repeat area */
    RenderGadgets (ed);

    return (ES_NORMAL);
}

/*****************************************************************************/

ULONG ASM Filter (REG (a0) struct Hook * h, REG (a2) struct FileRequester * fr, REG (a1) struct AnchorPath * ap)
{
    EdDataPtr ed = (EdDataPtr) h->h_Data;
    struct DataType *dtn;
    ULONG use = FALSE;
    UBYTE buffer[300];
    BPTR lock;

    strncpy (buffer, fr->fr_Drawer, sizeof (buffer));
    AddPart (buffer, ap->ap_Info.fib_FileName, sizeof (buffer));
    if (lock = Lock (buffer, ACCESS_READ))
    {
	    if (ap->ap_Info.fib_DirEntryType < 0)
	    {
		if (dtn = ObtainDataTypeA (DTST_FILE, (APTR) lock, NULL))
		{
		    if (dtn->dtn_Header->dth_GroupID == GID_PICTURE)
			use = TRUE;
		    ReleaseDataType (dtn);
		}
	    }
	    else
		use = TRUE;
	UnLock (lock);
    }

    return (use);
}

/*****************************************************************************/

BOOL SelectSample (EdDataPtr ed, ULONG tag1,...)
{
    if (!ed->ed_SampleReq)
	ed->ed_SampleReq = AllocAslRequest (ASL_FileRequest, NULL);

    return (AslRequest (ed->ed_SampleReq, (struct TagItem *) & tag1));
}

/*****************************************************************************/

EdStatus TestFunc (EdDataPtr ed)
{
    struct SignalSemaphore *sem;
    EdStatus result;

    DoPrefsGadget (ed, NULL, ed->ed_GTest, GA_Disabled, TRUE, TAG_DONE);
    Forbid ();
    if (sem = FindSemaphore ("« IPrefs »"))
	ObtainSemaphore (sem);
    Permit ();
    ed->ed_Flags |= EDF_TESTBD | EDF_CHANGED;
    result = SavePrefs (ed, ENV_NAME);
    if (sem)
	ReleaseSemaphore (sem);
    DoPrefsGadget (ed, NULL, ed->ed_GTest, GA_Disabled, FALSE, TAG_DONE);
    return result;
}

/*****************************************************************************/

VOID ProcessSpecialCommand (EdDataPtr ed, EdCommand ec)
{
    EdStatus result = ES_NORMAL;
    char path[PATHNAMESIZE];
    struct DataType *dtn;
    BOOL untest = FALSE;
    BOOL update = FALSE;
    struct Hook hook;
    UWORD icode;
    UWORD x, y;
    BPTR lock;

    icode = ed->ed_CurrentMsg.Code;
    switch (ec)
    {
	case EC_PRESETS:
	    /* Backup the current image */
	    Store (ed);

	    /* Clear the destination */
	    SetPrefsRast (ed, 0);

	    /* Which preset was hit? */
	    icode = (UWORD) (((struct Gadget *) ed->ed_CurrentMsg.IAddress)->UserData);

	    /* Figure out the offset of the preset */
	    x = y = 0;
	    if (icode >= XREPEATS)
	    {
		icode -= XREPEATS;
		y += PHEIGHT;
	    }
	    x += (icode * PWIDTH);

	    /* Copy the selected preset into the current work area */
	    bltbm (&Presets, x, y,
		   &(ed->ed_PrefsWork.ep_BMap),
		   ed->ed_Which, 0,
		   ed->ed_Width, ed->ed_Height,
		   0xC0, 0xFF, NULL, ed->ed_GfxBase);

	    /* Update the sliders */
	    RenderGadgets (ed);
	    break;

	case EC_TYPE:
	    /* Update the type */
	    ed->ed_Type = (UWORD) icode;

	    /* Clear the old type */
	    ed->ed_PrefsWork.ep_WBP[(ed->ed_Which / ed->ed_Width)].wbp_Flags &= ~0x1;

	    /* Set the new type */
	    ed->ed_PrefsWork.ep_WBP[(ed->ed_Which / ed->ed_Width)].wbp_Flags |= ed->ed_Type;

	    /* Update the display */
	    update = TRUE;
	    break;

	case EC_WHICH:
	    /* Set the current view */
	    ed->ed_Which = (UWORD) icode *ed->ed_Width;

	    /* Set the current type */
	    ed->ed_Type = 0x1 & (ed->ed_PrefsWork.ep_WBP[(ed->ed_Which / ed->ed_Width)].wbp_Flags);

	    /* Update the display */
	    update = TRUE;
	    break;

	case EC_CUT:
	    result = CutFunc (ed);
	    break;

	case EC_COPY:
	    result = CopyFunc (ed);
	    break;

	case EC_PASTE:
	    result = PasteFunc (ed, EC_PASTE);
	    break;

	case EC_LOAD_IMAGE:
	    result = PasteFunc (ed, EC_LOAD_IMAGE);
	    break;

	case EC_ERASE:
	    result = EraseFunc (ed);
	    break;

	case EC_UNDO:
	    result = UndoFunc (ed);
	    break;

	case EC_TEST:
	    result = TestFunc (ed);
	    break;

	case EC_CLEAR:
	    result = ClearFunc (ed);
	    break;

	case EC_PALETTE:
	    /* Set the currently select color */
	    ed->ed_APen = icode;

	    /* Update the sliders */
	    RenderGadgets (ed);
	    break;

	case EC_SKETCH:
	    if ((ULONG) ed->ed_GSketch->SpecialInfo != 0xFFFFFFFF)
		RefreshRepeats (ed);
	    break;

	case EC_SELECT:
	    strcpy (path, &ed->ed_PrefsWork.ep_Path[(ed->ed_Which / ed->ed_Width)][0]);
	    *PathPart (path) = 0;
	    hook.h_Entry = IntuiHook;

	    if (SelectSample (ed,
			      ASLFR_TitleText,		GetString (&ed->ed_LocaleInfo, MSG_WBP_SELECT_PICTURE_LABEL),
			      ASLFR_Window,		ed->ed_Window,
			      ASLFR_InitialDrawer,	path,
			      ASLFR_InitialFile,	FilePart (&ed->ed_PrefsWork.ep_Path[(ed->ed_Which / ed->ed_Width)][0]),
			      ASLFR_IntuiMsgFunc,	&hook,
			      ASLFR_SleepWindow,	TRUE,
			      ASLFR_RejectIcons,	TRUE,
			      ASLFR_FilterFunc,		&ed->ed_FilterHook,
			      TAG_DONE))
	    {
		/* Build the path name */
		strcpy (path, ed->ed_SampleReq->fr_Drawer);
		AddPart (path, ed->ed_SampleReq->fr_File, sizeof (path));

		/* Construct the error message */
		result = ES_DOSERROR;
		ed->ed_ErrorFileName = path;

		/* Did they enter a name? */
		if (strlen (ed->ed_SampleReq->fr_File) == 0)
		{
		    /* Clear the name */
		    ed->ed_PrefsWork.ep_Path[(ed->ed_Which / ed->ed_Width)][0] = 0;

		    /* Update the view */
		    update = TRUE;

		    /* Show normal */
		    result = ES_NORMAL;
		}
		/* See if the file exists */
		else if (lock = Lock (path, ACCESS_READ))
		{
		    if (NameFromLock (lock, path, sizeof (path)))
		    {
			if (dtn = ObtainDataTypeA (DTST_FILE, (APTR) lock, NULL))
			{
			    if (dtn->dtn_Header->dth_GroupID == GID_PICTURE)
			    {
				strcpy (&ed->ed_PrefsWork.ep_Path[(ed->ed_Which / ed->ed_Width)][0], path);

				/* Update the view */
				update = TRUE;

				/* Show normal */
				result = ES_NORMAL;
			    }
			    else
			    {
				result = ES_NOT_A_PICTURE;
			    }
			    ReleaseDataType (dtn);
			}
		    }
		    UnLock (lock);
		}
	    }
	    break;

	case EC_MYRESETALL:
	    CopyPrefs(ed, &ed->ed_PrefsWork,&ed->ed_PrefsDefaults);
	    update = untest = TRUE;
	    break;

	case EC_MYLASTSAVED:
	    result = OpenPrefs(ed,ARC_NAME);
	    update = untest = TRUE;
	    break;

	case EC_MYRESTORE:
	    CopyPrefs(ed,&ed->ed_PrefsWork, &ed->ed_PrefsInitial);
	    update = untest = TRUE;
	    break;

	default:
	    break;
    }

    if (update)
    {
	if (untest && (ed->ed_Flags & EDF_TESTBD))
	{
	    result = TestFunc (ed);
	    ed->ed_Flags &= ~EDF_TESTBD;
	}
	RenderGadgets (ed);
	RenderDisplay (ed);
    }

    if (result != ES_NORMAL)
	ShowError2 (ed, result);
}

/*****************************************************************************/

EdCommand
GetCommand (EdDataPtr ed)
{

    return (EC_NOP);
}

/*****************************************************************************/

VOID
GetSpecialCmdState (EdDataPtr ed, EdCommand ec, CmdStatePtr state)
{

    state->cs_Available = TRUE;
    state->cs_Selected = FALSE;
}
@


38.19
log
@made wider.
@
text
@d686 10
a695 3
	if (dtn = ObtainDataTypeA (DTST_FILE, (APTR) lock, NULL))
	{
	    if (dtn->dtn_Header->dth_GroupID == GID_PICTURE)
a696 3

	    ReleaseDataType (dtn);
	}
@


38.18
log
@fixed another problem with cancel
@
text
@d35 1
a35 1
#define NW_WIDTH	604
d37 2
d49 1
a49 1
#define	SKETCH_LEFT	402	/* was 327 */
d52 1
a52 1
#define	TOOL_LEFT	504	/* was 429 */
d55 1
a55 1
#define	PRESET_LEFT	325	/* was 527 */
d265 5
a269 4
    {BUTTON_KIND, 8, 107, 87, 14, MSG_SAVE_GAD, EC_SAVE, 0},
    {BUTTON_KIND, 252, 107, 87, 14, MSG_USE_GAD, EC_USE, 0},
    {BUTTON_KIND, 513, 107, 87, 14, MSG_CANCEL_GAD, EC_CANCEL, 0},
    {CYCLE_KIND, 143, 4, 178, 16, MSG_WBP_PLACEMENT_GAD, EC_WHICH, 0},	/* Placement: */
d271 1
a271 1
    {BUTTON_KIND, 143, 89, 178, 14, MSG_WBP_TEST_GAD, EC_TEST, 0},	/* Test */
d274 1
a274 1
    {BUTTON_KIND, TOOL_LEFT, 73, 96, 14, MSG_WBP_UNDO_GAD, EC_UNDO, 0},	/* Undo */
d277 1
a277 1
    {CYCLE_KIND, 143, 23, 178, 16, MSG_WBP_TYPE_GAD, EC_TYPE, 0},	/* Type: */
d280 1
a280 1
    {TEXT_KIND, 143, 61, 178, 14, MSG_WBP_PICTURE_NAME_GAD, EC_NOP, 0},	/* Picture Name: */
@


38.17
log
@added support for NOREMAP
@
text
@d202 1
a202 1
    if (ed->ed_Cancelled && (ed->ed_Flags & EDF_TESTBD))
d718 1
a718 1
    ed->ed_Flags |= EDF_TESTBD;
@


38.16
log
@CopyPrefs now copies the name of the picture
@
text
@a79 1
	{
d82 4
a85 1
	}
d91 2
@


38.15
log
@*** empty log message ***
@
text
@d99 2
d114 4
a718 1

d863 12
d876 1
a876 1
		if (lock = Lock (path, ACCESS_READ))
@


38.14
log
@use new prefs shell
@
text
@d10 1
a10 2
UWORD ghost_pattern[] =
{0x4444, 0x1111, 0x4444, 0x1111};
d95 3
a97 2
VOID
CopyPrefs (EdDataPtr ed, struct ExtPrefs * dp, struct ExtPrefs * sp)
a98 1

d106 5
a110 1
}
d112 4
d118 1
a118 2
BOOL
InitDisp (EdDataPtr ed)
d126 1
a126 2
EdStatus
InitEdData (EdDataPtr ed)
d152 5
d188 1
a188 2
VOID
CleanUpEdData (EdDataPtr ed)
d192 1
a192 1
    if (ed->ed_Cancelled)
d196 1
a196 5

	if (ed->ed_Flags & EDF_TESTBD)
	{
	    SavePrefs (ed, ENV_NAME);
	}
d238 3
a240 3
    {NM_ITEM, MSG_EDIT_RESET_TO_DEFAULTS, EC_RESETALL, 0},
    {NM_ITEM, MSG_EDIT_LAST_SAVED, EC_LASTSAVED, 0},
    {NM_ITEM, MSG_EDIT_RESTORE, EC_RESTORE, 0},
d320 1
a320 1
	    gad->Flags = GADGHCOMP;
d410 1
a410 2
VOID
RefreshRepeats (EdDataPtr ed)
d478 1
d488 2
d598 1
a598 2
VOID
SyncTextGadgets (EdDataPtr ed)
d628 1
a628 64
#if 0
EdStatus
TestFunc (EdDataPtr ed)
{

    if (ed->ed_Type == 0)
    {
	STRPTR name = &ed->ed_PrefsWork.ep_Path[(ed->ed_Which / ed->ed_Width)][0];
	struct PatternBitMap *opbm;
	struct BitMapHeader *bmhd;
	struct PatternBitMap pbm;
	struct gpLayout gpl;
	struct BitMap *bm;
	Object *dto;

	if (dto = newdtobject (ed, name, DTA_SourceType, DTST_FILE, TAG_DONE))
	{
	    /* Set the screen to remap to */
	    setdtattrs (ed, dto,
			PDTA_Screen, ed->ed_Screen,
			PDTA_FreeSourceBitMap, TRUE,
			TAG_DONE);

	    /* Tell the object to remap */
	    gpl.MethodID = GM_LAYOUT;
	    gpl.gpl_GInfo = NULL;
	    gpl.gpl_Initial = 1;
	    if (DoMethodA (dto, &gpl))
	    {
		if (getdtattrs (ed, dto,
				PDTA_BitMapHeader, &bmhd,
				PDTA_BitMap, &bm,
				TAG_DONE) == 2)
		{
		    /* Fill out the structure that Workbench needs */
		    pbm.pbm_BitMap = bm;
		    pbm.pbm_Width = bmhd->bmh_Width;
		    pbm.pbm_Height = bmhd->bmh_Height;

		    if (bm)
		    {
			opbm = WBConfig (1 + (ed->ed_Which / ed->ed_Width), &pbm);
			Delay (250);
			WBConfig (1 + (ed->ed_Which / ed->ed_Width), opbm);
		    }
		}
	    }

	    DisposeDTObject (dto);
	}
    }
    else if (ed->ed_Type == 1)
    {
	ed->ed_Flags |= EDF_TESTBD;
	return (SavePrefs (ed, ENV_NAME));
    }
}

#endif

/*****************************************************************************/

EdStatus
UndoFunc (EdDataPtr ed)
d644 1
a644 2
EdStatus
ClearFunc (EdDataPtr ed)
d698 1
a698 2
VOID
ProcessSpecialCommand (EdDataPtr ed, EdCommand ec)
d701 20
d723 3
d775 1
a775 2
	    RenderGadgets (ed);
	    RenderDisplay (ed);
d786 1
a786 2
	    RenderGadgets (ed);
	    RenderDisplay (ed);
d814 1
a814 12
	    DoPrefsGadget (ed, NULL, ed->ed_GTest, GA_Disabled, TRUE, TAG_DONE);
	    Forbid ();
	    if (sem = FindSemaphore ("+ IPrefs ;"))
	    {
		ObtainSemaphore (sem);
	    }
	    Permit ();
	    ed->ed_Flags |= EDF_TESTBD;
	    result = SavePrefs (ed, ENV_NAME);
	    if (sem)
		ReleaseSemaphore (sem);
	    DoPrefsGadget (ed, NULL, ed->ed_GTest, GA_Disabled, FALSE, TAG_DONE);
d850 1
d853 6
d863 5
a867 1
			strcpy (&ed->ed_PrefsWork.ep_Path[(ed->ed_Which / ed->ed_Width)][0], path);
d869 12
a880 5
			/* Clear the pattern */
			SetPrefsRast (ed, 0);

			/* Update the view */
			RenderGadgets (ed);
d887 14
d904 11
@


38.13
log
@*** empty log message ***
@
text
@a127 3
    if (!(ed->ed_DataTypesBase = OpenLibrary ("datatypes.library", 39)))
	return (ES_REQUIRES_DATATYPES);

d208 1
a209 1
    CloseLibrary (ed->ed_DataTypesBase);
d231 2
d836 5
a840 1
	    result = PasteFunc (ed);
d889 8
a896 8
			      ASLFR_TitleText, GetString (&ed->ed_LocaleInfo, MSG_WBP_SELECT_PICTURE_LABEL),
			      ASLFR_Window, ed->ed_Window,
			      ASLFR_InitialDrawer, path,
			      ASLFR_InitialFile, FilePart (&ed->ed_PrefsWork.ep_Path[(ed->ed_Which / ed->ed_Width)][0]),
			      ASLFR_IntuiMsgFunc, &hook,
			      ASLFR_SleepWindow, TRUE,
			      ASLFR_RejectIcons, TRUE,
			      ASLFR_FilterFunc, ((DataTypesBase) ? &ed->ed_FilterHook : NULL),
@


38.12
log
@now does magic bitmaps
@
text
@d487 1
a487 1
#if 0
a492 1
#endif
d760 1
d812 1
a813 1
	    RenderGadgets (ed);
d824 1
a825 1
	    RenderGadgets (ed);
d849 7
d858 3
@


38.11
log
@changed file format
@
text
@d10 2
a11 1
UWORD ghost_pattern[] = {0x4444, 0x1111, 0x4444, 0x1111};
d48 1
a48 1
#define	SKETCH_LEFT	327
d50 3
d54 1
a54 1
#define	PRESET_LEFT	527
d99 1
d123 1
d141 5
d184 1
d251 4
a254 2
    {BUTTON_KIND, 512, 107, 87, 14, MSG_CANCEL_GAD, EC_CANCEL, 0},
    {CYCLE_KIND, 144, 4, 178, 16, MSG_WBP_PLACEMENT_GAD, EC_WHICH, 0},	/* Placement: */
d256 3
a258 5
    {BUTTON_KIND, 144, 89, 178, 14, MSG_WBP_TEST_GAD, EC_TEST, 0},	/* Test */
    {BUTTON_KIND, 429, 89, 96, 14, MSG_WBP_CLEAR_GAD, EC_CLEAR, 0},	/* Clear */
    {BUTTON_KIND, 429, 73, 96, 14, MSG_WBP_UNDO_GAD, EC_UNDO, 0},	/* Undo */

    {PALETTE_KIND, 429, 4, 96, 66, NULL, EC_PALETTE, 0},
d260 1
a260 1
    {CYCLE_KIND, 144, 23, 178, 16, MSG_WBP_TYPE_GAD, EC_TYPE, 0},	/* Type: */
d262 2
a263 2
    {BUTTON_KIND, 144, 46, 178, 14, MSG_WBP_SELECT_PICTURE_GAD, EC_SELECT, 0},	/* Select Picture... */
    {TEXT_KIND, 144, 61, 178, 14, MSG_WBP_PICTURE_NAME_GAD, EC_NOP, 0},	/* Picture Name: */
d268 1
a268 2
BOOL
CreateDisplay (EdDataPtr ed)
d271 1
a273 2
    UWORD zoomSize[4];
    register WORD i;
d275 8
a282 4
    zoomSize[0] = NW_LEFT;
    zoomSize[1] = 0;
    zoomSize[2] = ZOOMWIDTH;
    zoomSize[3] = ed->ed_Screen->WBorTop + ed->ed_Screen->Font->ta_YSize + 1;
d311 1
a311 1
    for (i = 0; i < 8; i++)
d313 1
a313 1
	if (gad = DoPrefsGadget (ed, &eg, NULL, TAG_DONE))
d315 3
a317 3
	    gad->UserData    = (APTR) i;
	    gad->Flags       = GADGHCOMP;
	    gad->Activation  = RELVERIFY;
a343 1
					     WA_Zoom, zoomSize,
d432 1
a432 2
VOID
RenderDisplay (EdDataPtr ed)
d487 1
d490 1
a490 1
		  REPEAT_TOP  + DY + ed->ed_Window->BorderTop,
d492 2
a493 1
		  REPEAT_TOP  + DY + ed->ed_Window->BorderTop  + (YREPEATS * ed->ed_Width) - 1);
d496 1
a496 1
		  PRESET_TOP  + DY + ed->ed_Window->BorderTop,
d498 1
a498 1
		  PRESET_TOP  + DY + ed->ed_Window->BorderTop  + (2 * PHEIGHT) - 1);
d505 1
a505 2
VOID
RenderGadgets (EdDataPtr ed)
d507 2
d518 1
a518 1
				     GA_Disabled, ((ed->ed_Type) ? FALSE : TRUE),
d521 1
a521 1
				     GA_Disabled, ((ed->ed_Type) ? FALSE : TRUE),
d526 1
d566 1
a566 1
    if (ed->ed_GSketch)
d568 11
a578 3
	setgadgetattrs (ed, ed->ed_GSketch,
			GA_Disabled, ((ed->ed_Type) ? FALSE : TRUE),
			TAG_DONE);
d584 2
d628 1
d660 1
a660 1
		    pbm.pbm_Width  = bmhd->bmh_Width;
d681 1
d748 1
a748 2
BOOL
SelectSample (EdDataPtr ed, ULONG tag1,...)
a749 1

d806 1
a806 1
	    ed->ed_PrefsWork.ep_WBP[(ed->ed_Which/ed->ed_Width)].wbp_Flags &= ~0x1;
d809 1
a809 1
	    ed->ed_PrefsWork.ep_WBP[(ed->ed_Which/ed->ed_Width)].wbp_Flags |= ed->ed_Type;
d812 1
a813 1
	    RenderDisplay (ed);
d821 1
a821 1
	    ed->ed_Type  = 0x1 & (ed->ed_PrefsWork.ep_WBP[(ed->ed_Which/ed->ed_Width)].wbp_Flags);
d824 1
a825 1
	    RenderDisplay (ed);
d876 8
a883 8
			      ASLFR_TitleText,		GetString (&ed->ed_LocaleInfo, MSG_WBP_SELECT_PICTURE_LABEL),
			      ASLFR_Window,		ed->ed_Window,
			      ASLFR_InitialDrawer,	path,
			      ASLFR_InitialFile,	FilePart (&ed->ed_PrefsWork.ep_Path[(ed->ed_Which / ed->ed_Width)][0]),
			      ASLFR_IntuiMsgFunc,	&hook,
			      ASLFR_SleepWindow,	TRUE,
			      ASLFR_RejectIcons,	TRUE,
			      ASLFR_FilterFunc,		((DataTypesBase) ? &ed->ed_FilterHook : NULL),
d893 5
@


38.10
log
@*** empty log message ***
@
text
@d528 1
a528 1
				  GTTX_Text, FilePart (ed->ed_PrefsWork.ep_WBP[(ed->ed_Which / ed->ed_Width)].wbp_Path),
d604 1
a604 1
	STRPTR name = ed->ed_PrefsWork.ep_WBP[(ed->ed_Which / ed->ed_Width)].wbp_Path;
d845 1
a845 1
	    strcpy (path, ed->ed_PrefsWork.ep_WBP[(ed->ed_Which / ed->ed_Width)].wbp_Path);
d853 1
a853 1
			      ASLFR_InitialFile,	FilePart (ed->ed_PrefsWork.ep_WBP[(ed->ed_Which / ed->ed_Width)].wbp_Path),
d866 1
a866 1
			strcpy (ed->ed_PrefsWork.ep_WBP[(ed->ed_Which / ed->ed_Width)].wbp_Path, path);
@


38.9
log
@removed WA_LeftEdge, WA_TopEdge
@
text
@d8 5
a12 2
#define	DB(x)	;
#define	DL(x)	;
d14 9
a22 1
extern struct BitMap Presets;
d35 2
a36 2
#define NW_WIDTH	403
#define NW_HEIGHT	129
d46 2
a47 4
#define	C1_LEFT		8
#define	C2_LEFT		132
#define	C3_LEFT		240
#define	C4_LEFT		311
d49 2
a50 1
#define	REPEAT_TOP	4
d52 1
d55 3
d68 2
a69 1
VOID ProcessArgs (EdDataPtr ed, struct DiskObject * diskObj)
d92 2
a93 1
VOID CopyPrefs (EdDataPtr ed, struct WBPatternPrefs * dp, struct WBPatternPrefs * sp)
d99 2
a100 2
    bltbm (&(sp->wp_BMap), 0, 0,
	   &(dp->wp_BMap), 0, 0, (ed->ed_Width << 1), ed->ed_Height,
d106 2
a107 1
BOOL InitDisp (EdDataPtr ed)
d109 1
d115 2
a116 1
EdStatus InitEdData (EdDataPtr ed)
d118 7
d134 1
a134 1
	ed->ed_Depth = 4;
d150 2
a151 2
				/* Make the default image */
				CopyFromDefault (ed);
d153 1
a153 1
				return (ES_NORMAL);
d159 1
a159 1
		freebitmap (ed, &(ed->ed_PrefsInitial.wp_BMap), (ed->ed_Width << 1) + 2, ed->ed_Height);
d161 1
a161 1
	    freebitmap (ed, &(ed->ed_PrefsWork.wp_BMap), (ed->ed_Width << 1) + 2, ed->ed_Height);
d163 1
a163 1
	freebitmap (ed, &(ed->ed_PrefsDefaults.wp_BMap), (ed->ed_Width << 1) + 2, ed->ed_Height);
a164 1

d170 2
a171 1
VOID CleanUpEdData (EdDataPtr ed)
d181 1
a181 2
	    ed->ed_Which = 0;
	    saveprefs (ed, BDROP_ENV_NAME);
d183 1
d185 4
a188 6
	if (ed->ed_Flags & EDF_TESTWIN)
	{
	    ed->ed_Which = ed->ed_Width;
	    saveprefs (ed, WIN_ENV_NAME);
	}
    }
a192 3
    freebitmap (ed, &(ed->ed_PrefsInitial.wp_BMap), (ed->ed_Width << 1) + 2, ed->ed_Height);
    freebitmap (ed, &(ed->ed_PrefsWork.wp_BMap),    (ed->ed_Width << 1) + 2, ed->ed_Height);
    freebitmap (ed, &(ed->ed_PrefsDefaults.wp_BMap),(ed->ed_Width << 1) + 2, ed->ed_Height);
d199 2
d237 10
a246 3
    {BUTTON_KIND,       8, 111, 87, 14, MSG_SAVE_GAD, EC_SAVE, 0},
    {BUTTON_KIND,     157, 111, 87, 14, MSG_USE_GAD, EC_USE, 0},
    {BUTTON_KIND,     308, 111, 87, 14, MSG_CANCEL_GAD, EC_CANCEL, 0},
d248 1
a248 5
    {MX_KIND,     C1_LEFT,  15, 76, 12, NULL, EC_WHICH, PLACETEXT_RIGHT},

    {BUTTON_KIND, C1_LEFT,  47,115, 14, MSG_WBP_TEST_GAD, EC_TEST, 0},
    {BUTTON_KIND, C1_LEFT,  65,115, 14, MSG_WBP_CLEAR_GAD, EC_CLEAR, 0},
    {BUTTON_KIND, C1_LEFT,  83, 92, 20, MSG_WBP_UNDO_GAD, EC_UNDO, 0},
d250 2
a251 1
    {PALETTE_KIND,C3_LEFT,   4, 52, 99, NULL, EC_PALETTE, 0},
a253 1

d256 2
a257 1
BOOL CreateDisplay (EdDataPtr ed)
d273 4
d289 1
a289 1
    eg.eg_LeftEdge = C4_LEFT + DX;
d301 3
a303 3
	    gad->UserData = (APTR) i;
	    gad->Flags = GADGHCOMP;
	    gad->Activation = RELVERIFY;
a305 1

d308 1
a308 1
	    eg.eg_LeftEdge = C4_LEFT + DX;
a322 4
#if 0
					     WA_Left, NW_LEFT,
					     WA_Top, NW_TOP,
#endif
a341 1

d349 2
a350 1
VOID DisposeDisplay (EdDataPtr ed)
a358 1

d375 3
a377 2
VOID CenterLine (EdDataPtr ed, struct RastPort * rp, AppStringsID id,
		  UWORD x, UWORD y, UWORD w)
d393 2
a394 1
VOID RefreshRepeats (EdDataPtr ed)
d405 2
a406 2
	    for (x = C4_LEFT + DX + ed->ed_Window->BorderLeft;
		 x < C4_LEFT + DX + ed->ed_Window->BorderLeft + XREPEATS * ed->ed_Width;
d409 1
a409 1
		bltbmrp (&(ed->ed_PrefsWork.wp_BMap), ed->ed_Which, 0,
d419 2
a420 1
VOID RenderDisplay (EdDataPtr ed)
d429 1
a429 2
    CenterLine (ed, rp, MSG_WBP_PATTERN_LABEL, C1_LEFT, 10, 115);
    CenterLine (ed, rp, MSG_WBP_PRESETS_LABEL, C4_LEFT - 8, PRESET_TOP - 3, 71 + 16);
a439 18
    /* Draw the border around the undo display */
    DrawBB (ed,
	    ed->ed_GUndo->LeftEdge + ed->ed_GUndo->Width + 1,
	    ed->ed_GUndo->TopEdge,
	    ed->ed_Width + 6,
	    ed->ed_GUndo->Height,
	    GT_VisualInfo, ed->ed_VisualInfo,
	    GTBB_Recessed, TRUE,
	    TAG_DONE);

    /* Show the undo buffer */
    bltbmrp (&ed->ed_Undo, 0, 0,
	     ed->ed_Window->RPort,
	     ed->ed_GUndo->LeftEdge + ed->ed_GUndo->Width + 4,
	     ed->ed_GUndo->TopEdge + 2,
	     ed->ed_Width, ed->ed_Height,
	     0xC0, ed->ed_GfxBase);

d442 1
a442 1
	    C4_LEFT + ed->ed_Window->BorderLeft,
d455 1
a455 1
	    C4_LEFT + ed->ed_Window->BorderLeft,
d464 3
a466 3
	     ed->ed_Window->RPort,
	     C4_LEFT + DX + ed->ed_Window->BorderLeft,
	      PRESET_TOP + DY + ed->ed_Window->BorderTop,
a468 1
}
d470 19
d491 2
a492 1
VOID RenderGadgets (EdDataPtr ed)
a493 1

d496 2
a497 3
				   GTMX_Labels, ed->ed_WhichLabels,
				   GTMX_Active, ed->ed_Which / ed->ed_Width,
				   LAYOUTA_SPACING, 4,
d502 6
a507 2

    ed->ed_GClear = DoPrefsGadget (ed, &EG[5], ed->ed_GClear, TAG_DONE);
a508 2
    ed->ed_GUndo = DoPrefsGadget (ed, &EG[6], ed->ed_GUndo, TAG_DONE);

d511 1
a511 1
				     GTPA_Depth, ed->ed_Screen->BitMap.Depth,
d514 1
d517 15
d538 1
a538 1
			  GA_Left, C2_LEFT + ed->ed_Screen->WBorLeft,
d550 7
d567 8
a574 1
VOID SyncTextGadgets (EdDataPtr ed)
d576 18
d598 3
a600 1
EdStatus TestFunc (EdDataPtr ed)
d602 1
a602 1
    if (ed->ed_Which == 0)
d604 43
a646 2
	ed->ed_Flags |= EDF_TESTBD;
	return (saveprefs (ed, BDROP_ENV_NAME));
d648 1
a648 1
    else if (ed->ed_Which == ed->ed_Width)
d650 2
a651 2
	ed->ed_Flags |= EDF_TESTWIN;
	return (saveprefs (ed, WIN_ENV_NAME));
a652 2

    return (SavePrefs (ed, ENV_NAME));
d654 1
d658 2
a659 1
EdStatus UndoFunc (EdDataPtr ed)
d661 1
d675 2
a676 1
EdStatus ClearFunc (EdDataPtr ed)
d678 1
d693 41
a733 1
VOID ProcessSpecialCommand (EdDataPtr ed, EdCommand ec)
d736 2
d740 1
d753 1
a753 1
	    icode =  (UWORD)(((struct Gadget *)ed->ed_CurrentMsg.IAddress)->UserData);
d766 1
a766 1
		   &(ed->ed_PrefsWork.wp_BMap),
d775 15
d792 4
a795 1
	    ed->ed_Which = (UWORD) icode * ed->ed_Width;
d797 1
a797 1
	    /* Update the sliders */
d799 1
d823 2
a824 1
	    result = TestFunc (ed);
d844 31
d885 2
a886 1
EdCommand GetCommand (EdDataPtr ed)
d888 1
d894 2
a895 1
VOID GetSpecialCmdState (EdDataPtr ed, EdCommand ec, CmdStatePtr state)
@


38.8
log
@GC_SKETCH was in UserData instead of GA_ID
@
text
@d293 1
d296 1
@


38.7
log
@*** empty log message ***
@
text
@d499 1
a499 1
			  GA_UserData, EC_SKETCH,
a653 2
	    {
		/* Draw the repeat area */
a654 1
	    }
@


38.6
log
@lock Workbench instead of default public screen.
@
text
@a98 1

a269 1
#if 1
a270 3
#else
	    gad->GadgetID = (USHORT) i;
#endif
a585 1
#if 1
d587 1
a587 3
#else
	    icode =  (UWORD)(((struct Gadget *)ed->ed_CurrentMsg.IAddress)->GadgetID);
#endif
@


38.5
log
@gadget id messed up on pre-sets
@
text
@a63 1
	    {
a64 1
	    }
a69 1
	{
a70 1
	}
d72 1
@


38.4
log
@centered strings
@
text
@d274 3
d278 1
d594 3
d598 1
a598 1

@


38.3
log
@fixed ed_Which problem
@
text
@a39 1
#define	REPEAT_LEFT	311
d218 3
a220 3
    {BUTTON_KIND,   8, 111, 87, 14, MSG_SAVE_GAD, EC_SAVE, 0},
    {BUTTON_KIND, 157, 111, 87, 14, MSG_USE_GAD, EC_USE, 0},
    {BUTTON_KIND, 308, 111, 87, 14, MSG_CANCEL_GAD, EC_CANCEL, 0},
d222 5
a226 5
    {MX_KIND, C1_LEFT, 15, 76, 12, NULL, EC_WHICH, PLACETEXT_RIGHT},

    {BUTTON_KIND, C1_LEFT, 47,115, 14, MSG_WBP_TEST_GAD, EC_TEST, 0},
    {BUTTON_KIND, C1_LEFT, 65,115, 14, MSG_WBP_CLEAR_GAD, EC_CLEAR, 0},
    {BUTTON_KIND, C1_LEFT, 83, 92, 20, MSG_WBP_UNDO_GAD, EC_UNDO, 0},
d228 1
a228 1
    {PALETTE_KIND, C3_LEFT, 4, 52, 99, NULL, EC_PALETTE, 0},
d403 2
a404 2
    CenterLine (ed, rp, MSG_WBP_PATTERN_LABEL, C1_LEFT, 10, 144);
    CenterLine (ed, rp, MSG_WBP_PRESETS_LABEL, C4_LEFT, PRESET_TOP - 3, 80);
@


38.2
log
@change topborder to be zero
@
text
@d25 1
a25 1
#define NW_HEIGHT	125
d166 1
a166 1
	    ed->ed_Which = 1;
d219 3
a221 3
    {BUTTON_KIND,   8, 107, 87, 14, MSG_SAVE_GAD, EC_SAVE, 0},
    {BUTTON_KIND, 157, 107, 87, 14, MSG_USE_GAD, EC_USE, 0},
    {BUTTON_KIND, 308, 107, 87, 14, MSG_CANCEL_GAD, EC_CANCEL, 0},
d372 1
a372 1
    register WORD x, y, o;
a376 2
	o = (ed->ed_Width << ed->ed_Which);

d385 1
a385 1
		bltbmrp (&(ed->ed_PrefsWork.wp_BMap), o, 0,
d473 1
a473 1
				   GTMX_Active, ed->ed_Which,
d532 1
a532 1
    else if (ed->ed_Which == 1)
d605 1
a605 1
		   (ed->ed_Width << ed->ed_Which), 0,
d615 1
a615 1
	    ed->ed_Which = (UWORD) icode;
@


38.1
log
@initial rcs checkin
@
text
@d244 1
a244 1
    zoomSize[1] = ed->ed_Screen->WBorTop + ed->ed_Screen->Font->ta_YSize + 1;
d246 1
a246 1
    zoomSize[3] = zoomSize[1];
d299 1
a299 1
					     WA_Top, zoomSize[1],
@
