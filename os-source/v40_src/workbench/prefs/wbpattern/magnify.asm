*********************************************************************
*
* Magnify a bitmap to another bitmap with optional grid.
*
*			by Michael Sinz
*
*********************************************************************
*
* Function call prototype:
*
*	For assembly or languages that can do registers:
*
*		void MagnifyBitMap(	struct BitMap *from,	a0
*					struct BitMap *to,	a1
*					UBYTE xMag,		d0
*					UBYTE yMag,		d1
*					SHORT xSize,		d2
*					SHORT GridFlag);	d3
*
*
*
* This function will take the source bit map and magnify the first
* (xSize) bits per line by xMag, placing them into the destination
* bit map.  The yMagnification will duplicate each of the lines
* into the destination that number of times.
*
* xMag is the X Magnification:  1-to-1 up to 16-to-1  The values
* are limited to numbers between 1 and 16, inclusive.  No error
* checking is done on these as stange values will cause even
* stranger results...
*
* yMag is the Y Magnification:  1-to-1 up to n-to-1  The values
* are limited to numbers that fit in 16 bits.  Note that a value
* of 0 is 65536 y-mag and will cause strange results...  Again, no
* error checking is done on this value...
*
* The xSize is the number of bits from the source that need to be
* magnified.  Since the source bitmap may be bigger than what
* you wish to magnify, this value is used to limit the number of
* bits to an exact number.
*
* If the grid flag is set, the last bit of the magnified bits is
* cleared.  If the magnification is only 1, this is ignored in that
* direction.
*
* No error checking is done.  Both BitMaps must be valid and the
* source BitMap must have at least as many bit planes as the
* destination BitMap.  The Depth of the magnify is defined by the
* depth field in the destination BitMap.  Fancy error checking
* should be done in the calling code.  (Such as the destination
* being big enough to handle the magnification of the source.)
*
* As with all routines, a0/a1/d0/d1 are scrap, but a0 and a1 are
* not changed.  There is no real return result other than the
* garbage that is dropped into d0...  This value is of no use...
*
*********************************************************************
*
* Include some of the files needed...
*
	include	"exec/types.i"
	include	"graphics/gfx.i"
*
*********************************************************************
*
	section	MagnifyBitMap,code
	xdef	_MagnifyBitMap		; Register version

*
*********************************************************************
*
* This entry point takes the parameters in registers:
*
*	a0	- Pointer to FROM BitMap...
*	a1	- Pointer to TO BitMap...
*	d0	- xMagnification value...
*	d1	- yMagnification value...
*	d2	- xSize of source in pixels...
*	d3	- Grid flag : 0==no grid, 0!=grid...
*
_MagnifyBitMap:
	swap.w	d0		; Put the xMag in the high...
	move.w	d1,d0		; Get the yMag into the low...
	move.w	d2,d1		; Get the xSize...
	swap.w	d1		; Swap it...
	move.w	d3,d1		; Get the grid flag...
*
* Drop into the code that does this...
*
*********************************************************************
*
* The following is the input to this code:
*
*	a0	- Pointer to the FROM BitMap...
*	a1	- Pointer to the TO BitMap...
*	d0 (hi)	- xMagnification value...
*	d0 (lo)	- yMagnification value...
*	d1 (hi)	- xSize of source in pixels...
*	d1 (lo)	- Grid flag : 0==no grid, 0!=grid...
*
DoMagnify:
	movem.l	d2-d7/a2-a5,-(sp)	; Save all...
*
*********************************************************************
*
* So, we got called to do a magnify.  I guess we should
* do each bitplane of the source.  (There is no real checking of
* the input values.  That would be done in a higher level function
* such as the C code that called me.)
*
* So, we are sitting here with some bitmap pointers, scale factors,
* xSize, and the grid flag.  What more could we want?
*
	moveq.l	#1,d2		; Start out with 1 bit...
	swap.w	d0		; Swap xMag into low...
	asl.l	d0,d2		; Shift the mask...
	swap.w	d0		; Swap yMag back into low...
	subq.l	#1,d2		; Drop back into a bitmask...
	tst.w	d1		; Check grid...
	beq.s	Next1		; No grid to do...
	subq.l	#1,d2		; Drop grid value...
	bne.s	Next1		; No X mag, so no X grid...
	moveq.l	#1,d2		; Set X bit...
*
* Ok, we have what the X bit should look like.  Now, we need to
* start up some loops...
*
* Remember not to change d2 as it is the X bit...
*
Next1:
	swap.w	d1		; Put the xSize into lower word now
	moveq.l	#0,d7		; Clear d7...
	move.b	bm_Depth(a1),d7	; Get the depth we need...
	asl.l	#2,d7		; Multiply by 4...
*
* So, d7 is now the index into the bitplane array...
*
	moveq.l	#0,d6		; Clear d6...
	move.w	bm_BytesPerRow(a1),d6	; Get number of bytes...
*
* and we now know the destination bit plane line size...
*
*********************************************************************
*
* As we come to this point we have: (in addition to the initial stuff)
*
*	d7	- depth offset into bitmap structure...
*	d6	- destination line size in bytes...
*	d2	- The new X bit stuff...

*
* Step through the bit planes...
*
Loop1:
	subq.l	#4,d7		; Drop one...
	move.l	bm_Planes(a0,d7),a2	; Get from plane...
	move.l	bm_Planes(a1,d7),a3	; Get to plane...
*
* We need to do all of the lines of source...
*
	clr.w	d3		; Clear row count...
Loop2:
	bsr.s	DoLine		; Do a line...  (See docs...)
	addq.w	#1,d3		; Count this line...
	cmp.w	bm_Rows(a0),d3	; Check if done...
	bne.s	Loop2		; Loop back for more...
*
*
	tst.l	d7		; Check if we are done...
	bne.s	Loop1		; Do the next bit plane...
*
* So, we think we are done.  Restore the registers and exit...
*
	movem.l	(sp)+,d2-d7/a2-a5
	rts			; ok, we are done ;-)
*
*********************************************************************
*
* DoLine - Gee, things are getting interesting...
*
* DoLine will advance the bitmap pointers to the next line before
* returning.  Thus, all you need to do is call DoLine() for each
* line.
*
* We get called with the following values:
*
*	d7	- depth offset into bitmap structure...
*	d6	- destination line size in words...
*	d3	- line number...
*	d2	- The new X bit stuff...
*	d1	- Low word is the xSize, high word is grid flag...
*	d0	- Low word is the yMag, high word is the xMag value
*
*	a0	- From bitmap...
*	a1	- To bitmap...
*	a2	- From bitline...
*	a3	- To bitline...
*
DoLine:
	movem.l	d3/d7/a2/a3,-(sp)	; Save these...
	moveq.l	#16,d3		; Get our bit count...
	moveq.l	#0,d5		; The TO_BIT...
*
* We will use the upper half of d3 to store the bit loop...
*
	swap.w	d3		; Move it up...
	clr.w	d3		; Clear just the lower word
BitLoop:
	move.w	d3,d7		; Scrap stuff...
	and.w	#15,d7		; Mask all but the last bits...
*
* Get the next bit into the high-bit of the word d5...
*
	beq.s	LoadMore	; Load more...
	asl.w	#1,d4		; Shift the from bit...
	bra.s	SkipLoad	; Skip the load...
LoadMore:
	move.w	(a2)+,d4	; Get next word of bits...
SkipLoad:
	swap.w	d3		; Put the bit count back down...
*
* So, we need to move based on xMag
*
	swap.w	d0		; Get xMag...
	sub.w	d0,d3		; Drop the bit...
	swap.w	d0		; Put xMag back...
*
	moveq.l	#0,d7		; Clear the new X bit...
	tst.w	d4		; Check if we need a SET xBit...
	bpl.s	NoBit		; If top bit of from is 0, no bit...
	move.w	d2,d7		; Set the new X bit...
NoBit:
	tst.w	d3		; Check d3...
	ble.s	NoShift		; If Positive, non-zero, we shift...
	asl.w	d3,d7		; Ok... we moved it...
	or.w	d7,d5		; Mask it into d5...
	bra.s	DoNextBit	; And skip the rest...
*
NoShift:
	move.w	d7,a4		; Save this for a moment...
	neg.w	d3		; Make it positive...
	beq.s	CleanBit	; Check if we have gone negative...
	asr.l	d3,d7		; Cut the new bit for the leftovers...
CleanBit:
	or.w	d7,d5		; Set it in d5...
*
* We now have a d5 that is useful, so save it into a line...
*
	bsr.s	MagLines	; Do the yMag lines...
*
* Ok, lets take the leftovers and set it into d5...
*
	move.w	a4,d5		; Restore it again...
	neg.w	d3		; Negative again...
	addq.w	#8,d3		; We use 2 addq as they are faster
	addq.w	#8,d3		; than one add.w #16
	asl.w	d3,d5		; Shift it by the correct amount...
*
* Ok, on to the next bit...
*
DoNextBit:
	swap.w	d3		; Get the bit loop back...
	addq.w	#1,d3		; Add one to the loop...
	cmp.w	d1,d3		; Check if we are done...
	bne.s	BitLoop		; If not, loop some more...
*
* Check for leftovers...
*
	swap.w	d3		; Get the bit position...
	cmp.w	#16,d3		; Check if any leftovers...
	beq.s	ExitLine	; If not, skip this...
*
* Ok, d5 contains important info, so do it...
*
	bsr.s	MagLines	; Write the leftovers to the lines...
*
* We are done with the line...
* Now, bump the FROM line and TO line pointers...
*
ExitLine:
	movem.l	(sp)+,d3/d7/a2/a3	; Restore these...
	move.w	d0,d4		; Get yMag...
	subq.w	#1,d4		; Drop one...
Loop3:
	add.l	d6,a3		; Add line size to pointer
	dbra	d4,Loop3	; Loop for each yMag size...
*
	moveq.l	#0,d4		; Clear d4...
	move.w	bm_BytesPerRow(a0),d4	; Get the bytes per row...
	add.l	d4,a2		; Bump the from line...
	rts			; Return from scan line...
*
*********************************************************************
*
* Ok, d5 is the word that needs to be put in (a3) and yMag lines
* below it.  If yMag>1 and grid flag is set, we place a zero in
* the last of the yMag lines...
*
MagLines:
	move.l	a3,a5		; We need a line pointer...
	move.w	d0,d7		; Get the yMag value...
	move.w	d5,(a3)+	; Do first one...
	subq.w	#1,d7		; Count it...
	beq.s	DoneLines	; Check if done...
*
* Now do magnify lines...
*
LinesLoop:
	add.l	d6,a5		; Point at next line...
	subq.w	#1,d7		; Count this...
	beq.s	LastLine	; If last line, special case...
	move.w	d5,(a5)		; Save that line...
	bra.s	LinesLoop	; Back and do next one...
*
* We did all of the lines except for the last one.  It may need to be
* a grid line so we will need to check and set zero if so...
*
LastLine:
	swap.w	d1		; Get grid flag in low word...
	tst.w	d1		; check it...
	beq.s	NoGridLine	; If no grid line, skip...
	moveq.l	#0,d5		; Clear the entry...
NoGridLine:
	move.w	d5,(a5)		; Save this one...
	swap.w	d1		; Restore grid flag into high word...
DoneLines:
	rts			; Return...
*
*********************************************************************
	end
