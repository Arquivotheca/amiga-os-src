head     38.17;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


38.17
date     93.10.05.14.54.07;  author vertex;  state Exp;
branches ;
next     38.16;

38.16
date     93.05.03.16.16.38;  author vertex;  state Exp;
branches ;
next     38.15;

38.15
date     93.01.19.13.41.54;  author vertex;  state Exp;
branches ;
next     38.14;

38.14
date     92.03.23.09.52.48;  author vertex;  state Exp;
branches ;
next     38.13;

38.13
date     92.03.04.14.18.38;  author vertex;  state Exp;
branches ;
next     38.12;

38.12
date     92.03.04.11.42.07;  author vertex;  state Exp;
branches ;
next     38.11;

38.11
date     92.03.03.16.37.51;  author vertex;  state Exp;
branches ;
next     38.10;

38.10
date     92.03.03.13.05.53;  author vertex;  state Exp;
branches ;
next     38.9;

38.9
date     92.02.18.16.46.18;  author vertex;  state Exp;
branches ;
next     38.8;

38.8
date     92.02.17.16.30.13;  author vertex;  state Exp;
branches ;
next     38.7;

38.7
date     92.01.29.16.04.26;  author vertex;  state Exp;
branches ;
next     38.6;

38.6
date     92.01.21.15.12.56;  author vertex;  state Exp;
branches ;
next     38.5;

38.5
date     91.12.05.12.53.20;  author vertex;  state Exp;
branches ;
next     38.4;

38.4
date     91.11.20.11.26.14;  author vertex;  state Exp;
branches ;
next     38.3;

38.3
date     91.11.12.09.45.18;  author vertex;  state Exp;
branches ;
next     38.2;

38.2
date     91.10.28.09.32.49;  author vertex;  state Exp;
branches ;
next     38.1;

38.1
date     91.10.22.14.21.28;  author vertex;  state Exp;
branches ;
next     ;


desc
@Blanker commodity
@


38.17
log
@Fixed bug with input handler calling SetRGB32() in basically an infinite loop
  whenever the animation was stalled or not playing. Not it'll do the SetRGB32
  once, and only once.

Now uses graphics.library to do its splines instead of hitting the HW
@
text
@
#include <exec/types.h>
#include <exec/libraries.h>
#include <exec/memory.h>
#include <devices/inputevent.h>
#include <intuition/intuitionbase.h>
#include <intuition/intuition.h>
#include <libraries/commodities.h>
#include <graphics/displayinfo.h>
#include <graphics/text.h>
#include <graphics/videocontrol.h>
#include <graphics/view.h>
#include <hardware/custom.h>
#include <hardware/dmabits.h>
#include <string.h>

#include <clib/exec_protos.h>
#include <clib/layers_protos.h>
#include <clib/intuition_protos.h>
#include <clib/commodities_protos.h>
#include <clib/icon_protos.h>
#include <clib/graphics_protos.h>
#include <clib/dos_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/utility_protos.h>

#include <pragmas/exec_pragmas.h>
#include <pragmas/layers_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/commodities_pragmas.h>
#include <pragmas/icon_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/gadtools_pragmas.h>
#include <pragmas/utility_pragmas.h>

#include "ce_custom.h"
#include "ce_window.h"
#include "ce_strings.h"


/*****************************************************************************/


extern struct Library       *SysBase;
extern struct IntuitionBase *IntuitionBase;
extern struct Library       *CxBase;
extern struct Library       *IconBase;
extern struct Library       *GfxBase;
extern struct Library       *DOSBase;
extern struct Library       *GadToolsBase;
extern struct Library       *UtilityBase;
extern LONG                  cxSignal;
extern CxObj                *cxBroker;
extern struct Gadget        *cxGadgets;
extern struct Menu          *cxMenus;
extern struct Window        *cxWindow;
extern APTR                  cxVisualInfo;

static struct Gadget   *blankSecondsGad;
static struct Gadget   *cycleColorsGad;
static struct Gadget   *animationGad;
static struct Task     *parentTask;
static ULONG            cmd;
static struct Screen   *screen;
static WORD             screenWidth;
static WORD             screenHeight;
static ULONG            blankInterval = 600;
static ULONG            blankTimeOut;
static ULONG	        animTimeOut;
static BOOL             cycleColors;
static BOOL		doAnimation;
static ULONG            loopCount;
static ULONG            oldLoopCount;
static UWORD            stalled;
static WORD             mouseX;
static WORD             mouseY;
static WORD             maxPoints;
static LONG             oldPri;

extern struct Custom __far custom;

#define ANIMINTERVAL (600)   /* change animation type every 60 seconds */
#define MAXLINES     (30)
#define MAXPOINTS    (20)
#define STACKSIZE    (1500)
#define HALF(a)      ((*(a)+(a)[1])>>1)
#define FIX(x)       (((LONG)(x)) << 7)
#define FIXH(x)      (((LONG)((*(x)+(x)[1])>>1)) << 7)

static struct box
{
    WORD x[MAXPOINTS];
    WORD y[MAXPOINTS];
} store[MAXLINES];

static struct box *ptr;
static struct box *eptr;
static WORD numlines;
static WORD mdelta = -1;
static WORD maxlines = MAXLINES/2;
static WORD dx[MAXPOINTS],  dy[MAXPOINTS];
static WORD ox[MAXPOINTS],  oy[MAXPOINTS];
static WORD nx[MAXPOINTS],  ny[MAXPOINTS];
static WORD dr, dg, db;
static WORD nr, ng, nb;
static WORD closed;
static const STRPTR nextlegal[] = {"01458", "236", "01458", "236", "01458", "23", "01458", "", "0145"};
static const WORD advval[] = { 3, 2, 3, 2, 1, 0, 1, 0, 1 };
static char realfunc[14];

struct RastPort *rastPort;
LONG oldx, oldy;

VOID __asm DrawSpline(register __a0 LONG x1, register __a1 LONG y1,
                      register __a2 LONG x2, register __a3 LONG y2,
                      register __a5 LONG x3, register __a6 LONG y3,
                      register __d6 LONG x4, register __d7 LONG y4);


/*****************************************************************************/


#define CMD_NOP       0
#define CMD_BLANK     1
#define CMD_UNBLANK   2
#define CMD_HIDE      3
#define CMD_QUIT      4
#define CMD_SECONDS   5
#define CMD_CYCLE     6
#define CMD_ANIMATION 7


/*****************************************************************************/


static struct TextAttr __far topazAttr =
{
    "topaz.font",
    8,
    FS_NORMAL,
    FPF_ROMFONT
};


/*****************************************************************************/


static const UWORD __chip           blankData[] = {0,0,0,0,0,0};
static struct SimpleSprite    blankMouse;

#define BlankMouse()   ChangeSprite(NULL,&blankMouse,(APTR)blankData)
#define UnblankMouse() RethinkDisplay();


/*****************************************************************************/


static VOID __stdargs __saveds BlankAction(CxMsg *cxm, CxObj *co)
{
struct InputEvent *ie;
UWORD              i;

    ie = (struct InputEvent *)CxMsgData(cxm);

    if (ie->ie_Class == IECLASS_TIMER)
    {
        if (screen)
        {
            animTimeOut++;

            if (loopCount == oldLoopCount)
            {
                stalled++;
                if (stalled == 40)
                {
                    Forbid();  /* make sure screen pointer doesn't become invalid */

                    if (screen)
                    {
                        for (i=0; i<32; i++)
                            SetRGB32(&screen->ViewPort,i,0,0,0);
                    }

                    Permit();
                }
            }
            else
            {
                oldLoopCount = loopCount;
                stalled      = 0;
            }
        }

        if (!blankTimeOut-- && (!(ie->ie_Qualifier & (IEQUALIFIER_LEFTBUTTON|IEQUALIFIER_RBUTTON|IEQUALIFIER_MIDBUTTON))))
        {
            cmd = CMD_BLANK;
            Signal(parentTask,(1L << cxSignal));
            blankTimeOut = blankInterval;
        }
    }
    else
    {
        if (screen)
        {
            cmd = CMD_UNBLANK;
            Signal(parentTask,(1L << cxSignal));
            SetTaskPri(parentTask,oldPri);
        }
        blankTimeOut = blankInterval;
    }
}


/*****************************************************************************/


static VOID NewIntervals(LONG blankSeconds)
{
    if (blankSeconds <= 0)
        blankSeconds = 1;
    else if (blankSeconds >= 10000)
        blankSeconds = 9999;

    blankInterval = blankSeconds*10;
    blankTimeOut  = blankInterval;
    animTimeOut   = ANIMINTERVAL;
}


/*****************************************************************************/


BOOL ProcessCustomArgs(struct WBStartup *wbMsg, struct DiskObject *diskObj,
                       ULONG *cliOpts)
{
STRPTR arg;
LONG   blankSeconds;

    blankSeconds = 60;
    cycleColors  = TRUE;
    doAnimation  = TRUE;
    loopCount    = 0;

    if (wbMsg)
    {
        if (arg = FindToolType(diskObj->do_ToolTypes,"SECONDS"))
            StrToLong(arg,&blankSeconds);

        if (arg = FindToolType(diskObj->do_ToolTypes,"CYCLECOLORS"))
            cycleColors = !MatchToolValue(arg,"NO");

        if (arg = FindToolType(diskObj->do_ToolTypes,"ANIMATION"))
            doAnimation = !MatchToolValue(arg,"NO");
    }
    else
    {
        if (cliOpts[OPT_SECONDS])
            blankSeconds = *(ULONG *)cliOpts[OPT_SECONDS];

        if (cliOpts[OPT_CYCLECOLORS])
            cycleColors = (Stricmp((STRPTR)cliOpts[OPT_CYCLECOLORS],"NO") != 0);

        if (cliOpts[OPT_ANIMATION])
            doAnimation = (Stricmp((STRPTR)cliOpts[OPT_ANIMATION],"NO") != 0);
    }

    NewIntervals(blankSeconds);

    return(TRUE);
}


/*****************************************************************************/


VOID ProcessCustomCxMsg(ULONG cmd)
{
}


/*****************************************************************************/


VOID ProcessCustomCxCmd(ULONG cmd)
{
}


/*****************************************************************************/


static BOOL ProcessCommand(UWORD cmd);

BOOL ProcessIntuiMsg(struct IntuiMessage *intuiMsg)
{
ULONG            class;
UWORD            icode;
struct Gadget   *gad;
BOOL             ok;
UWORD            menuNum;
struct MenuItem *menuItem;

    class = intuiMsg->Class;
    icode = intuiMsg->Code;
    gad   = intuiMsg->IAddress;
    GT_ReplyIMsg(intuiMsg);

    ok = TRUE;
    switch (class)
    {
        case IDCMP_CLOSEWINDOW  : ok = ProcessCommand(CMD_HIDE);
                                  break;

        case IDCMP_REFRESHWINDOW: RefreshWindow(TRUE);
                                  break;

        case IDCMP_MENUPICK     : menuNum = icode;
                                  while ((menuNum != MENUNULL) && (ok))
                                  {
                                      menuItem = ItemAddress(cxMenus,menuNum);
                                      ok = ProcessCommand((UWORD)MENU_USERDATA(menuItem));

                                      if (cxMenus == NULL)
                                          break;

                                      menuNum = menuItem->NextSelect;
                                  }
                                  break;

        case IDCMP_GADGETUP     :
        case IDCMP_GADGETDOWN   : ok = ProcessCommand((UWORD)gad->UserData);
                                  break;
    }

    return(ok);
}


/*****************************************************************************/


BOOL CreateCustomGadgets(VOID)
{
struct NewGadget  ng;
struct Gadget    *gad;

    if (gad = CreateContext(&cxGadgets))
    {
        /* Some invariants */
        ng.ng_LeftEdge   = cxWindow->BorderLeft+200;
        ng.ng_Height     = 14;
        ng.ng_TextAttr   = &topazAttr;
        ng.ng_GadgetID   = 0;
        ng.ng_Flags      = NULL;
        ng.ng_VisualInfo = cxVisualInfo;

        ng.ng_TopEdge    = cxWindow->BorderTop+4;
        ng.ng_Width      = 52;
        ng.ng_GadgetText = GetString(MSG_BL_SECONDS_GAD);
        ng.ng_UserData   = (APTR)CMD_SECONDS;

        blankSecondsGad = CreateGadget(INTEGER_KIND,gad,&ng,GTIN_Number,   blankInterval/10,
                                                            GTIN_MaxChars, 4,
                                                            TAG_DONE);

        ng.ng_TopEdge    = cxWindow->BorderTop+21;
        ng.ng_Width      = 20;
        ng.ng_GadgetText = GetString(MSG_BL_CYCLECOLORS_GAD);
        ng.ng_UserData   = (APTR)CMD_CYCLE;

        cycleColorsGad = CreateGadget(CHECKBOX_KIND,blankSecondsGad,&ng,GTCB_Checked, cycleColors,
                                                                        TAG_DONE);

        ng.ng_TopEdge    = cxWindow->BorderTop+35;
        ng.ng_Width      = 20;
        ng.ng_GadgetText = GetString(MSG_BL_ANIMATION_GAD);
        ng.ng_UserData   = (APTR)CMD_ANIMATION;

        if (animationGad = CreateGadget(CHECKBOX_KIND,cycleColorsGad,&ng,GTCB_Checked, doAnimation,
                                                                         TAG_DONE))
        {
            AddGList(cxWindow,cxGadgets,-1,-1,NULL);
            RefreshGList(cxGadgets,cxWindow,NULL,-1);
            GT_RefreshWindow(cxWindow,NULL);
            ActivateGadget(blankSecondsGad,cxWindow,NULL);
            return(TRUE);
        }
        FreeGadgets(cxGadgets);
        cxGadgets = NULL;
    }
    return(FALSE);
}


/*****************************************************************************/


static struct NewMenu NM[] =
{
    {NM_TITLE,  NULL, 0, 0, 0, (APTR)CMD_NOP,  },
      {NM_ITEM, NULL, 0, 0, 0, (APTR)CMD_HIDE, },
      {NM_ITEM, NULL, 0, 0, 0, (APTR)CMD_QUIT, },

    {NM_END,    0,    0, 0, 0, (APTR)CMD_NOP,  }
};


static VOID DoItem(WORD itemNum, ULONG label)
{
    if (NM[itemNum].nm_Type != NM_TITLE)
    {
        NM[itemNum].nm_Label   = (APTR)((ULONG)GetString(label)+2);
        NM[itemNum].nm_CommKey = GetString(label);
    }
    else
    {
        NM[itemNum].nm_Label = GetString(label);
    }
}


/*****************************************************************************/


BOOL CreateCustomMenus(VOID)
{
    DoItem(0,MSG_PROJECT_MENU);
    DoItem(1,MSG_PROJECT_HIDE);
    DoItem(2,MSG_PROJECT_QUIT);

    if (cxMenus = CreateMenusA(NM,NULL))
    {
        if (LayoutMenus(cxMenus,cxVisualInfo,GTMN_NewLookMenus,TRUE,
                                             TAG_DONE))
        {
            SetMenuStrip(cxWindow,cxMenus);
            return(TRUE);
        }
        FreeMenus(cxMenus);
        cxMenus = NULL;
    }
    return(FALSE);
}


/*****************************************************************************/


VOID RefreshWindow(BOOL refreshEvent)
{
    if (refreshEvent)
    {
        GT_BeginRefresh(cxWindow);
        GT_EndRefresh(cxWindow,TRUE);
    }
}


/*****************************************************************************/


static LONG seed;

static WORD Random(WORD i)
{
LONG rseed;
LONG rval;

    rseed = seed;
    if  (rseed == 0)
        rseed = 323214521 + screen->MouseX + screen->MouseY;

    rseed = rseed * 123213 + 121;
    rval  = (rseed >> 5) & 65535;
    seed  = rseed;
    return ((WORD)((i * rval) >> 16));
}


/*****************************************************************************/


static VOID MakeFunc(VOID)
{
WORD i;
WORD goallen;
WORD sofar;
char *p;
char *nextpossib;

    closed = Random(4);
    switch (closed)
    {
        case 3: closed = 2;

        case 2: goallen = 3 + Random(4);
                break;

        case 1: goallen = 4 + Random(7);
                break;

        case 0: goallen = 2 + Random(8);
                break;
    }

    while (1)
    {
        if  (closed == 0)
            nextpossib = "0145";
        else
            nextpossib = "0123456";

        sofar   = 0;
        p = realfunc;
        while (sofar < goallen)
        {
            i = nextpossib[Random((WORD)strlen(nextpossib))]   - '0';
            *p++ = i;
            nextpossib = nextlegal[i];
            sofar   +=  advval[i];
        }

        if  (sofar == goallen)
        {
            if  (closed == 0)
            {
                if  (nextpossib[0]  ==  '0')
                    break;

            }
            else
            {
                if  (*nextpossib == '0' || realfunc[0] < 4  ||  *(p-1) <    4)  {
                    if  ((*nextpossib == '0') ?
                             ((realfunc[0]  & 2) != 0) : ((realfunc[0]  & 2) == 0)) {
                        if  (realfunc[0] != 5) {
                            realfunc[0] ^=  2;
                            break;
                        }
                    } else {
                        break;
                    }
                }
            }
        }
    }

    *p  = 100;
    maxPoints = goallen;
    switch (closed)
    {
        case 2: for (i=0; i<p-realfunc; i++)
                    p[i] = realfunc[i];
                p[p-realfunc] = 100;
                break;

        case 1: break;

        case 0: maxPoints++;
                break;
    }
}


/*****************************************************************************/


static VOID Draw_S_F(WORD *xptr, WORD *yptr)
{
    oldx = HALF(xptr);
    oldy = HALF(yptr);

    DrawSpline(FIX(oldx),    FIX(oldy),
               FIX(xptr[1]), FIX(yptr[1]),
               FIX(xptr[2]), FIX(yptr[2]),
               FIXH(xptr+2), FIXH(yptr+2));
}


/*****************************************************************************/


static VOID Draw_SF(WORD *xptr, WORD *yptr)
{
    oldx = HALF(xptr);
    oldy = HALF(yptr);

    DrawSpline(FIX(oldx),    FIX(oldy),
               FIX(xptr[1]), FIX(yptr[1]),
               FIX(xptr[2]), FIX(yptr[2]),
               FIX(xptr[3]), FIX(yptr[3]));
}


/*****************************************************************************/


static VOID DrawS_F(WORD *xptr, WORD *yptr)
{
    oldx = *xptr;
    oldy = *yptr;

    DrawSpline(FIX(*xptr),   FIX(*yptr),
               FIX(xptr[1]), FIX(yptr[1]),
               FIX(xptr[2]), FIX(yptr[2]),
               FIXH(xptr+2), FIXH(yptr+2));
}


/*****************************************************************************/


static VOID DrawSF(WORD *xptr, WORD *yptr)
{
    oldx = *xptr;
    oldy = *yptr;

    DrawSpline(FIX(*xptr),   FIX(*yptr),
               FIX(xptr[1]), FIX(yptr[1]),
               FIX(xptr[2]), FIX(yptr[2]),
               FIX(xptr[3]), FIX(yptr[3]));
}


/*****************************************************************************/


static VOID Draw_LF(WORD *xptr, WORD *yptr)
{
    Move(rastPort,HALF(xptr),HALF(yptr));
    xptr++;
    yptr++;
    Draw(rastPort,*xptr,*yptr);
}


/*****************************************************************************/


static VOID DrawL_F(WORD *xptr, WORD *yptr)
{
    Move(rastPort, *xptr, *yptr);
    Draw(rastPort, HALF(xptr),HALF(yptr));
}


/*****************************************************************************/


static VOID DrawLF(WORD *xptr, WORD *yptr)
{
    Move(rastPort,*xptr, *yptr);
    xptr++;
    yptr++;
    Draw(rastPort,*xptr,*yptr);
}


/*****************************************************************************/


static VOID DrawnLF(WORD *dummya, WORD *dummyb)
{
}


/*****************************************************************************/


static VOID (*funcs[])(WORD *, WORD *) =
{
    DrawSF,
    DrawS_F,
    Draw_SF,
    Draw_S_F,
    DrawLF,
    DrawL_F,
    Draw_LF,
    NULL,
    DrawnLF
};


/*****************************************************************************/


static VOID DrawFunc(struct box *bptr)
{
LONG i;
WORD *x, *y;
char *p;

    switch (closed)
    {
        case 2: for (i=0, x=&(bptr->x[0]),  y=&(bptr->y[0]); i<maxPoints;   i++, x++, y++)
                {
                    x[maxPoints] =  screenWidth - 1 -   *x;
                    y[maxPoints] =  screenHeight -  1 - *y;
                }
setup:
                x[maxPoints] =  bptr->x[0];
                y[maxPoints] =  bptr->y[0];
                x++, y++;
                x[maxPoints] =  bptr->x[1];
                y[maxPoints] =  bptr->y[1];
                break;

        case 1: x = &(bptr->x[0]);
                y = &(bptr->y[0]);
                goto setup;
    }

    p = realfunc;
    x = &(bptr->x[0]);
    y = &(bptr->y[0]);
    while (*p < 10)
    {
        (funcs[*p])(x,  y);
        i = advval[*p];
        x += i;
        y += i;
        p++;
    }
}


/*****************************************************************************/


static VOID Adv(WORD *o, WORD *d, WORD *n, WORD w)
{
    *n = *o + *d;
    if (*n < 0)
    {
        *n = 0;
        *d = Random(6) + 1;
    }
    else if (*n >= w)
    {
        *n = w - 1;
        *d = - Random(6) - 1;
    }
}


/*****************************************************************************/


static VOID AdvanceLines(VOID)
{
WORD i;

    for (i=0; i<maxPoints; i++)
    {
        Adv(ox+i, dx+i, nx+i, screenWidth);
        Adv(oy+i, dy+i, ny+i, screenHeight);
    }
}


/*****************************************************************************/


static VOID DrawNew(VOID)
{
WORD       i;
struct box *bptr;

    while (numlines >= maxlines)
    {
        SetAPen(rastPort,0);
        bptr = eptr;
        DrawFunc(bptr);

        SetAPen(rastPort,1);
        numlines--;
        bptr++;

        if (bptr == store + MAXLINES)
            bptr = store;
        eptr = bptr;
    }

    bptr = ptr;
    for (i=0; i<maxPoints; i++)
    {
        bptr->x[i] = ox[i] = nx[i];
        bptr->y[i] = oy[i] = ny[i];
    }

    DrawFunc(bptr);
    numlines++;
    bptr++;

    if  (bptr == store + MAXLINES)
    {
        bptr = store;
        if  (mdelta == 1)
        {
            maxlines++;
            if (maxlines >= MAXLINES - 1)
                mdelta = -1;
        }
        else
        {
            maxlines--;
            if  (maxlines <= 2)
                mdelta = 1;
        }
    }
    ptr = bptr;
}


/*****************************************************************************/


static VOID StartLines(VOID)
{
WORD i;

    if (doAnimation)
    {
        ptr  = store;
        eptr = store;
        numlines = 0 ;
        if (dx[0] == 0)
        {
            for (i=0; i<MAXPOINTS; i++)
            {
                ox[i] = Random(screenWidth);
                oy[i] = Random(screenHeight);
                dx[i] = 2 + Random(3);
                dy[i] = 2 + Random(3);
            }
        }
    }

    nr = 53;
    ng = 33;
    nb = 35;
    dr = -3;
    dg = 5;
    db = 7;

    if (!cycleColors)
        SetRGB32(&screen->ViewPort,1,0xbbbbbbbb,0xbbbbbbbb,0xbbbbbbbb);
    else
        SetRGB32(&screen->ViewPort,1,nr << 24,ng << 24,nb << 24);

    BlankMouse();

    if (doAnimation)
    {
        for (i=0; i<maxlines; i++)
        {
            AdvanceLines();
            DrawNew();
        }
    }
}


/*****************************************************************************/


static VOID Colors(VOID)
{
WORD or, og, ob;
ULONG color;

    if (cycleColors)
    {
        or = nr;
        og = ng;
        ob = nb;
        Adv(&or, &dr, &nr, 128);
        Adv(&og, &dg, &ng, 128);
        Adv(&ob, &db, &nb, 128);

        color = 0;
        if (doAnimation)
            color = 1;

        SetRGB32(&screen->ViewPort,color,nr << 24,ng << 24,nb << 24);

        BlankMouse();
    }
}


/*****************************************************************************/


VOID HideInterface(VOID)
{
    if (cxWindow)
        NewIntervals(((struct StringInfo *)blankSecondsGad->SpecialInfo)->LongInt);

    DisposeWindow();
}


/*****************************************************************************/


struct ColorBunch
{
     UWORD NumColors;
     UWORD FirstColor;
     ULONG Colors[32*3];
     UWORD EndMarker;
};


static BOOL ProcessCommand(UWORD cmd)
{
ULONG                 lock;
ULONG                 modeID;
struct InputEvent     ie;
struct DimensionInfo  dimInfo;
WORD                  screenW, screenH, screenD;
struct Screen        *tempScreen;
struct TagItem        tags[2];
struct Rectangle      rect;
struct ViewPortExtra *extra;
struct ColorBunch     black;

    switch (cmd)
    {
        case CMD_HIDE     : HideInterface();
                            break;

        case CMD_QUIT     : return(FALSE);

        case CMD_SECONDS  : NewIntervals(((struct StringInfo *)blankSecondsGad->SpecialInfo)->LongInt);
                            break;

        case CMD_CYCLE    : cycleColors = (SELECTED & cycleColorsGad->Flags);
                            break;

        case CMD_ANIMATION: doAnimation = (SELECTED & animationGad->Flags);
                            break;

        case CMD_BLANK    : if (screen)
                            {
                                ScreenToFront(screen);
                            }
                            else
                            {
                                tags[0].ti_Tag = VTAG_VIEWPORTEXTRA_GET;
                                tags[1].ti_Tag = TAG_END;

			        lock = LockIBase(0);
			        if (IntuitionBase->FirstScreen)
			        {
                                    modeID  = GetVPModeID(&IntuitionBase->FirstScreen->ViewPort);
                                    VideoControl(IntuitionBase->FirstScreen->ViewPort.ColorMap,tags);
                                    extra   = (struct ViewPortExtra *)tags[0].ti_Data;
                                    rect    = extra->DisplayClip;
                                }
                                else
                                {
                                    modeID = LORES_KEY;
                                    QueryOverscan(LORES_KEY,&rect,OSCAN_TEXT);
                                }

                                mouseX  = IntuitionBase->MouseX;
                                mouseY  = IntuitionBase->MouseY;
                                screenW = rect.MaxX - rect.MinX + 1;
                                screenH = rect.MaxY - rect.MinY + 1;
                                screenD = 1;
                                UnlockIBase(lock);

                                if (!doAnimation)
                                {
                                    if (GetDisplayInfoData(FindDisplayInfo(modeID),(APTR)&dimInfo,sizeof(struct DimensionInfo),DTAG_DIMS,INVALID_ID))
                                    {
                                        screenH = dimInfo.MinRasterHeight;
                                    }
                                }

                                if (screenW < 32)
                                    screenW = 32;

                                if (screenH < 8)
                                    screenH = 8;

                                /* Avoid external video showing through */
                                tags[0].ti_Tag  = VTAG_CHROMAKEY_SET;
                                tags[0].ti_Data = TRUE;
                                tags[1].ti_Tag  = TAG_DONE;

                                memset(&black,0,sizeof(black));
                                black.NumColors = 32;

                                if (screen = OpenScreenTags(NULL,SA_DisplayID,    modeID,
                                                                 SA_Depth,        screenD,
                                                                 SA_Width,        screenW,
                                                                 SA_Height,       screenH,
                                                                 SA_Quiet,        TRUE,
                                                                 SA_DClip,        &rect,
                                                                 SA_VideoControl, tags,
                                                                 SA_Colors32,     &black,
                                                                 TAG_DONE))
                                {
                                    BlankMouse();

                                    rastPort     = &screen->RastPort;
                                    screenWidth  = screen->Width;
                                    screenHeight = screen->Height;
                                    animTimeOut  = 0;

                                    SetAPen(rastPort,1);
                                    MakeFunc();
                                    StartLines();
                                    Colors();
                                }
                            }

                            if (screen && (doAnimation || cycleColors))
                            {
                                loopCount = 0;
                                stalled   = 0;
                                SetTaskPri(FindTask(NULL),-128);
                                while ((SetSignal(0,0) & (1<<cxSignal)) == 0)
                                {
                                    loopCount++;
                                    if (doAnimation)
                                    {
                                        AdvanceLines();
                                        DrawNew();
                                        Colors();

                                        if (animTimeOut >= ANIMINTERVAL)
                                        {
                                            animTimeOut = 0;
                                            MakeFunc();
                                            SetRast(rastPort,0);
                                            StartLines();
                                        }
                                    }
                                    else
                                    {
                                        WaitTOF();
                                        Colors();
                                    }
                                }
                                Signal(parentTask,(1 << cxSignal));
                                SetTaskPri(parentTask,oldPri);
                            }
                            break;

        case CMD_UNBLANK  : if (screen)
                            {
                                loopCount  = 0;
                                stalled    = 0;
                                tempScreen = screen;
                                screen     = NULL;         /* this is so input handler doesn't SetRGB32() into a closed screen */
                                CloseScreen(tempScreen);

                                ie.ie_NextEvent          = NULL;
                                ie.ie_Class              = IECLASS_POINTERPOS;
                                ie.ie_SubClass           = 0;
                                ie.ie_Code               = 0;
                                ie.ie_Qualifier          = 0;
                                ie.ie_X                  = mouseX;
                                ie.ie_Y                  = mouseY;
                                ie.ie_TimeStamp.tv_secs  = 0;
                                ie.ie_TimeStamp.tv_micro = 0;
                                AddIEvents(&ie);
                            }
                            break;


    }

    return(TRUE);
}


/*****************************************************************************/


VOID ProcessCustomCxSig(VOID)
{
    ProcessCommand(cmd);
}


/*****************************************************************************/


BOOL CreateCustomCx(CxObj *broker)
{
    parentTask = FindTask(NULL);
    oldPri = parentTask->tc_Node.ln_Pri;

    AttachCxObj(broker,CxCustom(BlankAction,NULL));
    return ((BOOL)(CxObjError(broker) == 0));
}


/*****************************************************************************/


VOID DisposeCustomCx(VOID)
{
    SetTaskPri(parentTask,oldPri);
    ProcessCommand(CMD_UNBLANK);
}
@


38.16
log
@Now prevents genlocked video from showing through the blanker screen
@
text
@d60 20
a79 19
struct Gadget   *blankSecondsGad;
struct Gadget   *cycleColorsGad;
struct Gadget   *animationGad;
struct Task     *parentTask;
ULONG            cmd;
struct Screen   *screen = NULL;
struct RastPort *rastPort;
WORD             screenWidth;
WORD             screenHeight;
ULONG            blankInterval = 600;
ULONG            blankTimeOut;
ULONG	         animTimeOut;
BOOL             cycleColors;
BOOL		 doAnimation;
ULONG            loopCount;
ULONG            oldLoopCount;
UWORD            stalled;
WORD             mouseX;
WORD             mouseY;
d91 1
a91 5
WORD maxpoints;

LONG oldPri;

struct box
d97 22
a118 21
struct box *ptr;
struct box *eptr;
WORD numlines;
WORD mdelta = -1;
WORD maxlines = MAXLINES/2;
WORD dx[MAXPOINTS],  dy[MAXPOINTS];
WORD ox[MAXPOINTS],  oy[MAXPOINTS];
WORD nx[MAXPOINTS],  ny[MAXPOINTS];
WORD dr, dg, db;
WORD or, og, ob;
WORD nr, ng, nb;
WORD closed;
char *nextlegal[] = {"01458", "236", "01458", "236", "01458", "23", "01458", "", "0145"};
WORD advval[] = { 3, 2, 3, 2, 1, 0, 1, 0, 1 };
unsigned char realfunc[14];
char namefunc[20];

LONG oldx, oldy, oldwidth,  oldptr;
WORD oldcol;

VOID __stdargs DrawSpline(LONG x1, LONG y1, LONG x2, LONG y2, LONG x3, LONG y3, LONG x4, LONG y4);
d137 1
a137 1
struct TextAttr far topazAttr =
d149 2
a150 2
UWORD __chip           blankData[] = {0,0,0,0,0,0};
struct SimpleSprite    blankMouse;
d159 1
a159 1
VOID __stdargs __saveds BlankAction(CxMsg *cxm, CxObj *co)
d175 1
a175 1
                if (stalled >= 40)
d182 1
a182 1
                            SetRGB4(&screen->ViewPort,i,0,0,0);
d218 1
a218 1
VOID NewIntervals(LONG blankSeconds)
d293 1
a293 1
BOOL ProcessCommand(UWORD cmd);
d399 1
a399 1
struct NewMenu NM[] =
d409 1
a409 1
VOID DoItem(WORD itemNum, AppStringsID label)
d463 1
a463 1
LONG seed;
d465 1
a465 1
WORD Random(WORD i)
d477 1
a477 1
    return ((i * rval) >> 16);
d484 1
a484 1
VOID MakeFunc(VOID)
d489 1
a489 1
unsigned char *p;
d492 13
a504 13
    closed =    Random(4);
    switch(closed)  {
case 3:
        closed =    2;
case 2:
        goallen = 3 + Random(4);
        break;
case 1:
        goallen = 4 + Random(7);
        break;
case 0:
        goallen = 2 + Random(8);
        break;
d506 3
a508 1
    while   (1) {
d513 1
d516 3
a518 2
        while   (sofar <    goallen)    {
            i = nextpossib[Random(strlen(nextpossib))]   - '0';
d523 5
a527 2
        if  (sofar == goallen) {
            if  (closed == 0) {
d530 4
a533 1
            } else {
d548 1
d550 16
a565 23
    maxpoints = goallen;
    switch (closed) {
case 2:
        for (i=0; i<p-realfunc; i++)
            p[i] = realfunc[i];
        p[p-realfunc] = 100;
        break;
case 1:
        break;
case 0:
        maxpoints++;
        break;
    }
    for (i=0, p=realfunc; *p <  100; p++, i++)
        namefunc[i] = *p + '0';
    namefunc[i++] = ' ';
    namefunc[i++] = '0' + closed;
    namefunc[i++] = ' ';
    namefunc[i++] = '0' + maxpoints;
    namefunc[i] = 0;
}


d569 1
a569 1
VOID Draw_S_F(WORD *xptr, WORD *yptr)
d573 5
a577 4
    OwnBlitter();
    DrawSpline(FIX(oldx), FIX(oldy),    FIX(xptr[1]), FIX(yptr[1]),
                  FIX(xptr[2]), FIX(yptr[2]),   FIXH(xptr+2), FIXH(yptr+2));
    DisownBlitter();
d579 2
a580 2


d584 1
a584 1
VOID Draw_SF(WORD *xptr, WORD *yptr)
d588 5
a592 4
    OwnBlitter();
    DrawSpline(FIX(oldx), FIX(oldy),    FIX(xptr[1]), FIX(yptr[1]),
                  FIX(xptr[2]), FIX(yptr[2]),   FIX(xptr[3]), FIX(yptr[3]));
    DisownBlitter();
d594 2
a595 2


d599 1
a599 1
VOID DrawS_F(WORD *xptr, WORD *yptr)
d604 4
a607 4
    OwnBlitter();
    DrawSpline(FIX(*xptr), FIX(*yptr), FIX(xptr[1]), FIX(yptr[1]),
                  FIX(xptr[2]), FIX(yptr[2]),   FIXH(xptr+2), FIXH(yptr+2));
    DisownBlitter();
d609 2
a610 2


d614 1
a614 1
VOID DrawSF(WORD *xptr, WORD *yptr)
d619 4
a622 4
    OwnBlitter();
    DrawSpline(FIX(*xptr), FIX(*yptr), FIX(xptr[1]), FIX(yptr[1]),
                  FIX(xptr[2]), FIX(yptr[2]),   FIX(xptr[3]), FIX(yptr[3]));
    DisownBlitter();
d624 2
a625 2


d629 1
a629 1
VOID Draw_LF(WORD *xptr, WORD *yptr)
d641 1
a641 1
VOID DrawL_F(WORD *xptr, WORD *yptr)
d651 1
a651 1
VOID DrawLF(WORD *xptr, WORD *yptr)
d663 1
a663 1
VOID DrawnLF(WORD *dummya, WORD *dummyb)
d671 1
a671 1
VOID (*funcs[])(WORD *, WORD *) =
d688 1
a688 1
VOID DrawFunc(struct box *bptr)
d691 2
a692 2
WORD   *x, *y;
unsigned    char *p;
d694 7
a700 9
    oldwidth = screen->RastPort.BitMap->BytesPerRow;
    oldptr   = (LONG)screen->RastPort.BitMap->Planes[0];
    switch(closed)
    {
case 2:
        for (i=0, x=&(bptr->x[0]),  y=&(bptr->y[0]); i<maxpoints;   i++, x++, y++)  {
            x[maxpoints] =  screenWidth - 1 -   *x;
            y[maxpoints] =  screenHeight -  1 - *y;
        }
d702 10
a711 10
        x[maxpoints] =  bptr->x[0];
        y[maxpoints] =  bptr->y[0];
        x++, y++;
        x[maxpoints] =  bptr->x[1];
        y[maxpoints] =  bptr->y[1];
        break;
case 1:
        x = &(bptr->x[0]);
        y = &(bptr->y[0]);
        goto setup;
d713 1
d717 1
a717 1
    while   (*p <   10)
d731 1
a731 1
VOID Adv(WORD *o, WORD *d, WORD *n, WORD w)
d733 2
a734 2
    *n  = *o + *d;
    if  (*n <   0)
d736 2
a737 2
        *n  = 0;
        *d  = Random(6) + 1;
d741 2
a742 2
        *n  = w -   1;
        *d  = - Random(6) -  1;
d750 1
a750 1
VOID AdvanceLines(VOID)
d754 1
a754 1
    for (i=0; i<maxpoints; i++)
d765 1
a765 1
VOID DrawNew(VOID)
a767 1
WORD       oldpen;
a771 2
        oldpen = screen->RastPort.FgPen;
        oldcol = 0xb0a;
d776 1
a776 2
        oldcol =    0xbfa;
        SetAPen(rastPort,oldpen);
d780 1
a780 1
        if  (bptr   ==  store   + MAXLINES)
d786 1
a786 1
    for (i=0; i<maxpoints; i++)
d788 2
a789 2
        bptr->x[i] = ox[i] =    nx[i];
        bptr->y[i] = oy[i] =    ny[i];
d819 1
a819 1
VOID StartLines(VOID)
d828 1
a828 1
        if  (dx[0] == 0)
d847 2
a848 2
    if (cycleColors)
        SetRGB4(&screen->ViewPort,1,0xFF,0xFF,0xFF);
d850 1
a850 1
        SetRGB4(&screen->ViewPort,1,nr >> 3,ng >> 3,nb >> 3);
d868 1
a868 1
VOID Colors(VOID)
d870 3
d882 1
d884 3
a886 3
            SetRGB4(&screen->ViewPort,1,(nr >> 3), (ng >> 3), (nb >> 3));
        else
            SetRGB4(&screen->ViewPort,0,(nr >> 3), (ng >> 3), (nb >> 3));
d905 13
a917 1
BOOL ProcessCommand(UWORD cmd)
d928 1
a928 1
UWORD                 i;
d990 1
a990 1
                                // Avoid external video showing through
d995 3
d1005 1
a1007 3
                                    for (i = 0; i < 32; i++)
                                        SetRGB4(&screen->ViewPort,i,0,0,0);

a1033 12
                                        AdvanceLines();
                                        DrawNew();

                                        AdvanceLines();
                                        DrawNew();
                                        AdvanceLines();
                                        DrawNew();

                                        AdvanceLines();
                                        DrawNew();
                                        AdvanceLines();
                                        DrawNew();
a1046 2
                                        WaitTOF();
                                        WaitTOF();
d1060 1
a1060 1
                                screen     = NULL;         /* this is so input handler doesn't SetRGB4() into a closed screen */
d1101 1
a1101 1
    return (CxObjError(broker) == 0);
@


38.15
log
@Added HideInterface() to be called when Exchange requests a window shutdown
@
text
@d975 12
a986 6
                                if (screen = OpenScreenTags(NULL,SA_DisplayID,   modeID,
                                                                 SA_Depth,       screenD,
                                                                 SA_Width,       screenW,
                                                                 SA_Height,      screenH,
                                                                 SA_Quiet,       TRUE,
                                                                 SA_DClip,       &rect,
@


38.14
log
@No longer uses a window when doing animation
@
text
@d893 9
d917 1
a917 3
        case CMD_HIDE     : if (cxWindow)
                                NewIntervals(((struct StringInfo *)blankSecondsGad->SpecialInfo)->LongInt);
                            DisposeWindow();
@


38.13
log
@*** empty log message ***
@
text
@a65 1
struct Window   *window;
d151 2
a152 1
UWORD __chip pointerData[] = {0,0,0,0,0,0};
d154 2
d157 1
d853 2
d884 2
d904 1
d976 2
a977 1
                                    SetRGB4(&screen->ViewPort,0,0,0,0);
d979 1
a979 7
                                    if (window = OpenWindowTags(NULL,WA_CustomScreen, screen,
                                                                     WA_Flags,        WFLG_BORDERLESS,
                                                                     WA_Activate,     TRUE,
                                                                     TAG_DONE))
                                    {
                                        SetPointer(window,pointerData,1,16,0,0);
                                    }
d1042 2
a1043 5
                                loopCount = 0;
                                stalled   = 0;
                                if (window)
                                    CloseWindow(window);

@


38.12
log
@No longer blanks the display if any mouse buttons are currently held down
@
text
@a889 1
UWORD                 i;
a891 2
struct DisplayInfo    dispInfo;
ULONG                 next;
a896 1
DisplayInfoHandle     dh;
d948 1
a948 2
                                    next = INVALID_ID;
                                    while ((next = NextDisplayInfo(next)) != INVALID_ID)
d950 1
a950 18
                                        if ((next & MONITOR_ID_MASK) == (modeID & MONITOR_ID_MASK))
                                        {
                                            if ((dh = FindDisplayInfo(next))
                                            &&  (GetDisplayInfoData(dh,(APTR)&dimInfo,sizeof(struct DimensionInfo),DTAG_DIMS,INVALID_ID))
                                            &&  (GetDisplayInfoData(dh,(APTR)&dispInfo,sizeof(struct DisplayInfo),DTAG_DISP,INVALID_ID)))
                                            {
                                                if (!dispInfo.NotAvailable && (!(dispInfo.PropertyFlags & (DIPF_IS_DUALPF | DIPF_IS_PF2PRI | DIPF_IS_HAM | DIPF_IS_EXTRAHALFBRITE))))
                                                {
                                                    if (dimInfo.MinRasterWidth < screenW)
                                                    {
                                                        screenW = dimInfo.MinRasterWidth;
                                                        screenH = dimInfo.MinRasterHeight;
                                                        screenD = 1;  /* dimInfo.MinDepth; */
                                                        modeID  = next;
                                                    }
                                                }
                                            }
                                        }
d968 1
a968 2
                                    for (i=0; i<32; i++)
                                        SetRGB4(&screen->ViewPort,i,0,0,0);
@


38.11
log
@Now handles the case where there is no currently active screen when opening
  the blanking screen
@
text
@d194 1
a194 1
        if (!blankTimeOut--)
@


38.10
log
@Fixed busy task checking code not working more than once
@
text
@d929 14
a942 5
			        lock    = LockIBase(0);
                                modeID  = GetVPModeID(&IntuitionBase->FirstScreen->ViewPort);
                                VideoControl(IntuitionBase->FirstScreen->ViewPort.ColorMap,tags);
                                extra   = (struct ViewPortExtra *)tags[0].ti_Data;
                                rect    = extra->DisplayClip;
@


38.9
log
@Fixed access of IntuiMessage->Code field after having replied the message
@
text
@a1 1

d174 1
a174 1
                if (stalled == 40)
d1007 1
d1054 1
@


38.8
log
@No longer call GetDisplayInfoData() with a NULL first argument, as this is broken in
  KS 37.175
@
text
@d298 1
d305 1
d318 1
a318 1
        case IDCMP_MENUPICK     : menuNum = intuiMsg->Code;
@


38.7
log
@Now looks at the frontmost screen's DClip to open its own screen
@
text
@d899 1
d947 3
a949 2
                                            if ((GetDisplayInfoData(NULL,(APTR)&dimInfo,sizeof(struct DimensionInfo),DTAG_DIMS,next))
                                            &&  (GetDisplayInfoData(NULL,(APTR)&dispInfo,sizeof(struct DisplayInfo),DTAG_DISP,next)))
@


38.6
log
@Now turns the screen black if an animation stalls due to lack of CPU time
@
text
@d12 2
d887 12
a898 9
ULONG                lock;
ULONG                modeID;
UWORD                i;
struct InputEvent    ie;
struct DimensionInfo dimInfo;
struct DisplayInfo   dispInfo;
ULONG                next;
WORD                 screenW, screenH, screenD;
struct Screen       *tempScreen;
d924 4
a927 1
                                lock    = LockIBase(0);
d929 3
d934 2
a935 2
                                screenW = IntuitionBase->FirstScreen->Width;
                                screenH = IntuitionBase->FirstScreen->Height;
d970 6
a975 5
                                if (screen = OpenScreenTags(NULL,SA_DisplayID, modeID,
                                                                 SA_Depth,     screenD,
                                                                 SA_Width,     screenW,
                                                                 SA_Height,    screenH,
                                                                 SA_Quiet,     TRUE,
@


38.5
log
@Made window larger
@
text
@d74 3
d160 1
d167 1
d170 23
d241 1
d893 1
d991 1
d995 1
d1037 1
d1041 3
a1043 2
                                CloseScreen(screen);
                                screen = NULL;
@


38.4
log
@Now blanks the mouse when the blanking screen is up
@
text
@d318 1
a318 1
        ng.ng_LeftEdge   = cxWindow->BorderLeft+160;
a334 1
        ng.ng_LeftEdge   = cxWindow->BorderLeft+160;
a342 1
        ng.ng_LeftEdge   = cxWindow->BorderLeft+160;
@


38.3
log
@Enabled new look menus
@
text
@a11 1
#include <graphics/gfxmacros.h>
d65 1
d148 6
d941 8
d1007 3
@


38.2
log
@Now reads string gadget value before closing window
Now sends the screen to the front every time the blanking interval expires
Now Waits() instead of busy-looping when no animation and no color cycling is done
@
text
@d395 1
a395 2
    if (cxMenus = CreateMenus(NM,GTMN_NewLookMenus,TRUE,
                                 TAG_DONE))
d397 2
a398 1
        if (LayoutMenus(cxMenus,cxVisualInfo,TAG_DONE))
@


38.1
log
@Initial V38 RCS checkin
@
text
@d159 1
a159 1
        if (!blankTimeOut-- && !screen)
d163 1
a163 1
            blankTimeOut = blankInterval;  /* forces one more pass in case screen didn't open */
d349 1
d863 3
a865 1
        case CMD_HIDE     : DisposeWindow();
d879 1
a879 1
        case CMD_BLANK    : if (!screen)
d881 4
d947 1
a947 1
                            if (screen)
@
