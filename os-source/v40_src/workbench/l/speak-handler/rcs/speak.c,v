head     1.4;
branch   ;
access   ;
symbols  V37_4:1.4 V37_1:1.3 V36_3:1.2 V36_1:1.2;
locks    ; strict;
comment  @ * @;


1.4
date     91.02.21.19.14.53;  author andy;  state Exp;
branches ;
next     1.3;

1.3
date     91.01.31.22.45.54;  author andy;  state Exp;
branches ;
next     1.2;

1.2
date     90.06.13.18.56.26;  author andy;  state Exp;
branches ;
next     1.1;

1.1
date     90.06.13.18.48.37;  author andy;  state Exp;
branches ;
next     ;


desc
@initial checkin
@


1.4
log
@fixed early exit problem
@
text
@#include <exec/types.h>
#include <exec/nodes.h>
#include <exec/lists.h>
#include <exec/ports.h>
#include <exec/libraries.h>
#include <exec/devices.h>
#include <exec/io.h>
#include <exec/memory.h>
#include <libraries/dos.h>
#include <libraries/dosextens.h>
#include <libraries/filehandler.h>
#include "devices/narrator.h"
#include "handler.h"
#include "speak-handler_rev.h"


ULONG TranslatorBase;
BYTE amaps[] = {3, 5, 10, 12};   /* audio channel allocation maps */

char copyright[] = 
  "Copyright 1987-1990 Commodore-Amiga, Inc. All Rights Reserved";
char vers[]=VERTAG;

main()
{
 /* AmigaDos/Handler  related data structures */
struct DosPacket      	*packet;      /* a pointer to the  dos packet sent */
struct Process        	*process;     /* pointer to our process */
UBYTE                 	*parmdevname; /* pointer to device name in parmpkt Arg1 */
ULONG                 	parmextra;    /* extra info passed in parmpkt      Arg2 */
struct DeviceNode     	*node;        /* our device node passed in parmpkt Arg3 */
struct FileHandle     	*fh;          /* a pointer to our file handle           */
ULONG			*point;
struct VARS 		*vars;	      /* pointer to our variable block	*/

packet = taskwait();	/* wait for parm. packet */

parmdevname = (UBYTE *) BADDR(packet->dp_Arg1); /* name for handler */
parmextra = (ULONG) packet->dp_Arg2;  		/* extra info */
node = (struct DeviceNode *) BADDR(packet->dp_Arg3);
process = (struct Process *) FindTask(0);


if(!(vars=(UBYTE *)AllocMem(sizeof(struct VARS),MEMF_PUBLIC|MEMF_CLEAR)))
	cleanup(packet,vars);

SetVars(packet,vars,parmdevname,process);

/* node->dn_Task = &process->pr_MsgPort;	/* only one gets fired up at a time */

returnpkt(packet,DOS_TRUE,packet->dp_Res2);    /* everything ok */

  while(TRUE) {
   packet = taskwait();                                /* wait for packet */
   switch(packet->dp_Type) {
     case ACTION_FIND_OUTPUT: 
          fh = (struct FileHandle *) BADDR(packet->dp_Arg1);  
          fh->fh_Port = (struct MsgPort *)DOS_TRUE;
          vars->OpenCount++;
          returnpkt(packet,DOS_TRUE,packet->dp_Res2);
          break;

     case ACTION_END:
          vars->OpenCount--;
          returnpkt(packet,DOS_TRUE,packet->dp_Res2);
          if((vars->OpenCount)<=0) {
	    clean(vars);
	    exit(0);
	  }
          break;

     case ACTION_WRITE:
	 Say((UBYTE *)packet->dp_Arg2,(packet->dp_Arg3)-1,vars);
         returnpkt(packet,packet->dp_Arg3,packet->dp_Res2);   
         break;

     case ACTION_DISK_INFO: {
	struct InfoData *v=(struct InfoData *)BADDR(packet->dp_Arg1);
        v->id_DiskType=  (LONG) IDS;
	returnpkt(packet,DOS_TRUE,0);
        break;
     }
     default:
	returnpkt(packet,FALSE,ERROR_ACTION_NOT_KNOWN);
/*        node->dn_Task = 0; */
	if(vars->OpenCount <= 0) {
	    clean(vars);
	    exit(0);
	}
   }
  }

}

clean(vars)
struct VARS *vars;
{
if(vars->TalkDevice)CloseDevice(vars->iow);
if(vars->iow)DeleteExtIO(vars->iow,(ULONG)sizeof(*(vars->iow)));
if(vars->devport)DeletePort(vars->devport);
if(TranslatorBase)CloseLibrary(TranslatorBase);
if(vars->buffer)FreeMem(vars->buffer,MAXSIZE+2);
if(vars->phoneme)FreeMem(vars->phoneme,MAXOSIZE+2);

if(vars)FreeMem(vars,sizeof(struct VARS));
return;
}

cleanup(packet,vars)
struct DosPacket *packet;
struct	 VARS *vars;
{
clean(vars);
returnpkt(packet,FALSE,RETURN_FAIL);
exit(0);
}

SetVars(packet,vars,parmdevname,process)
struct DosPacket *packet;
struct   VARS *vars;
UBYTE *parmdevname;
struct Process *process;
{
int i;


if(!((vars->buffer)=(UBYTE *)AllocMem(MAXSIZE+2,MEMF_PUBLIC|MEMF_CLEAR)))
	cleanup(packet,vars);

if(!((vars->phoneme)=(UBYTE *)AllocMem(MAXOSIZE+2,MEMF_PUBLIC|MEMF_CLEAR)))
	cleanup(packet,vars);

vars->clientport = packet->dp_Port;    /* get senders port (taskid) */

if(!(vars->devport=(struct MsgPort *)CreatePort("Chatter",0)))
	cleanup(packet,vars);

if(!(TranslatorBase=OpenLibrary("translator.library",0)))
	cleanup(packet,vars);

if(!(vars->iow=(struct narrator_rb *)
    CreateExtIO(vars->devport,(ULONG)sizeof(*(vars->iow))))) {
	cleanup(packet,vars);
}

vars->TalkDevice = (OpenDevice("narrator.device",0,vars->iow,0) == 0);
if(!(vars->TalkDevice))cleanup(packet,vars);

vars->iow->ch_masks= amaps;
vars->iow->nm_masks= sizeof(amaps);
vars->iow->mouths  = 0;   /* mouth OFF */

vars->iow->sex = DEFSEX;
vars->iow->mode = DEFMODE;
vars->iow->rate = DEFRATE;
vars->iow->pitch = DEFPITCH;

for (i = 0; ( (parmdevname[i]) && (parmdevname[i] != ':')) ; i++);
if (parmdevname[i] == ':')SetOpt(&parmdevname[i+1],TRUE,vars);

vars->iow->message.io_Message.mn_ReplyPort = vars->devport;
vars->iow->message.io_Command = CMD_WRITE;
vars->iow->message.io_Offset = 0;
vars->iow->message.io_Message.mn_Length = sizeof(*(vars->iow));
vars->iow->message.io_Message.mn_Node.ln_Type = 0;

vars->OpenCount=0;

return(0);
}
@


1.3
log
@fixed diskinfo case
and findinput case
@
text
@a15 1
#define CMDREV "\0$VER: " VSTRING;
d22 1
a22 1
char vers[]="CMDREV";
d53 1
a53 1
while(TRUE) {
a54 1

d67 1
a67 1
	    clean(packet,vars);
d86 4
a89 2
	clean(packet,vars);
	exit(0);
d91 2
a93 1
}
d95 1
a95 2
clean(packet,vars)
struct DosPacket *packet;
d98 1
a98 1
if(!(vars->TalkDevice)) CloseDevice(vars->iow);
d104 1
d106 1
d113 1
a113 1
clean(packet,vars);
a125 1
vars->TalkDevice = 1;
d135 2
a136 2
if(!(vars->devport=(struct MsgPort *)
	CreatePort("Chatter",0)))cleanup(packet,vars);
d138 1
a138 1
if(!(TranslatorBase=OpenLibrary("translator.library",0))) {
a139 1
}
d142 3
a144 1
    CreateExtIO(vars->devport,(ULONG)sizeof(*(vars->iow)))))cleanup(packet,vars);
d146 2
a147 2
if(((vars->TalkDevice)=OpenDevice("narrator.device",0,vars->iow,0)))
	    cleanup(packet,vars);
d165 1
@


1.2
log
@added version number, cleans up memory when unknown packet received.
@
text
@d49 1
a57 1
     case ACTION_FIND_INPUT:
d64 1
a64 1
     
d79 4
a82 7
     case ACTION_INFO:
     case ACTION_DISK_INFO:
	for(point=(UBYTE *)BADDR(packet->dp_Arg1);
	    point<point+sizeof(struct InfoData);point++) *point = 0;
        ((struct InfoData *)BADDR(packet->dp_Arg1))->id_InUse=(LONG)vars->iow;
        ((struct InfoData *)BADDR(packet->dp_Arg1))->id_DiskType= (LONG) IDS;
	returnpkt(packet,DOS_TRUE,packet->dp_Res2);
d84 1
a84 1

@


1.1
log
@Initial revision
@
text
@d14 1
d16 2
d22 2
a23 1
  "Copyright 1987  Commodore-Amiga, Inc. All Rights Reserved";
d44 1
d49 1
d90 3
a92 1

@
