head	40.18;
access;
symbols;
locks; strict;
comment	@ * @;


40.18
date	93.05.20.22.52.18;	author LPOMA;	state Exp;
branches;
next	38.15;

38.15
date	92.12.16.01.15.14;	author LPOMA;	state Exp;
branches;
next	38.14;

38.14
date	92.11.25.13.30.53;	author LPOMA;	state Exp;
branches;
next	38.9;

38.9
date	92.06.23.00.45.27;	author LPOMA;	state Exp;
branches;
next	38.7;

38.7
date	92.05.06.10.26.32;	author LPOMA;	state Exp;
branches;
next	38.5;

38.5
date	92.03.30.13.47.34;	author LPOMA;	state Exp;
branches;
next	38.4;

38.4
date	92.03.08.22.45.30;	author LPOMA;	state Exp;
branches;
next	38.3;

38.3
date	92.02.21.11.10.24;	author LPOMA;	state Exp;
branches;
next	38.2;

38.2
date	92.01.05.14.21.16;	author LPOMA;	state Exp;
branches;
next	38.1;

38.1
date	91.12.04.18.17.39;	author LPOMA;	state Exp;
branches;
next	;


desc
@CrossDOS for AmigaDOS V2.1
@


40.18
log
@Mostly struct name changes to support the enhanced Key in the lock.

Added the ability to create a lock for a dummy object. This is needed to
support the default "Disk.info".
@
text
@/* fileIO.c **************************************************************
** Copyright 1991 CONSULTRON
*
*      DOS file IO related functions.
*
*************************************************************************/

#include "FS:FS.h"

extern struct FS     *fsys;
extern int  DOSerror;
extern struct IOStdReq  *diskreq;
extern struct trans_table *trans_tbl;
extern struct ExecBase  *SysBase;

extern UCHAR *info;
#define STRLEN_INFO 5


/*************
* OpenFile()  --- Open file.
*   Return 0 if cannot open.
*************/
int OpenFile(filehandle, dirlock, name, mode)
register struct FileHandle *filehandle;
register struct MLock *dirlock;
UCHAR *name;    /* BADDR(BSTR) */
int mode;
{
F();
    register struct MFileInfoBlock *mfib = (struct MFileInfoBlock *)fsys->f_scratch;
    register struct MFileInfoBlock *newmfib;
    register struct MLock *lock=0;
    int lockmode;
    int strln;
    UBYTE fileflags=0;


    {
            /* Find if file exists.  newmfib = mfib if found or =0 if not found */
        newmfib = FindObject(dirlock, name, mfib);

        if( DOSerror == ERROR_INVALID_COMPONENT_NAME )    /* bad filespec */
        {
            return(DOSFALSE);
        }

        if( newmfib && (mfib->mfib_DirEntStatus != MLDE_FILE))    /* if not a file, return with error */
        {
            DOSerror = ERROR_OBJECT_WRONG_TYPE;
            return(DOSFALSE);
        }

        switch(mode)
        {
            case ACTION_FINDINPUT:
                lockmode = SHARED_LOCK;
                break;
            case ACTION_FINDUPDATE:
                lockmode = SHARED_LOCK;
                if(!newmfib) goto Open_Create_New_File;
                break;
            case ACTION_FINDOUTPUT:
                lockmode = EXCLUSIVE_LOCK;
                if( newmfib )
                {
                    if( !DeleteObject(dirlock, name))
                    {
                        return(DOSFALSE);
                    }
                }
Open_Create_New_File:
                if( newmfib = CreateObject(dirlock, name, mfib))
                {
                    fileflags |= FILE_MOD_F;
                }
                break;
            case 0:                     /* if mode = 0 then this function was called by ACTION_FH_FROM_LOCK */
                lock = dirlock;         /* set the lock to the lock passed in dirlock */
                break;
            default:    return(DOSFALSE);
        }
    }

    if( !newmfib )
    {
#ifdef MFS
        if(newmfib = GetDummyObject(name, mfib));
        else
#endif
        {
            return(DOSFALSE);
        }
    }

    if(lock == 0) if(!(lock = MakeLock(dirlock, newmfib, lockmode)))
    {
        return(DOSFALSE);
    }

    lock->ml_KeyPtr->kp_flags          |= fileflags;

/*### set global text filter if FS flag set and != icon file ".info" ###*/
/* Using the utility.library equivalent to strnicmp() because with localization
it should handle case for international characters properly */
    if( (fsys->f_FSflags & (MF_GLOB_TXFLTR | MF_GLOB_TXTRANS))
           /* make sure the string length is not longer than the string to be searched */
        && ((0 > (strln = name[0]-STRLEN_INFO))
        || (0 != strnicmp(info,&name[strln+1],STRLEN_INFO))) )
    {
        if(fsys->f_FSflags & MF_GLOB_TXFLTR)
        {
DPRTF(KPrintF( "\nOpenFile: Text Filter ON"));
            lock->ml_lock_ext.le_filt_flags |= CTRLM_CTRLZ_F;
        }
        if(fsys->f_FSflags & MF_GLOB_TXTRANS)
        {
DPRTF(KPrintF( "\nOpenFile: Text Tranlator ON"));
            lock->ml_lock_ext.le_filt_flags |= XLAT1_F;
            lock->ml_lock_ext.le_trans_tbl = trans_tbl; /* set the translation table if used */
        }
    }
    lock->ml_lock_ext.le_prev_clust     =
    lock->ml_lock_ext.le_curr_clust     = lock->ml_KeyPtr->kp_start_clust;
    if(ILLEGAL_CLUST == lock->ml_KeyPtr->kp_dir_clust) lock->ml_lock_ext.le_databuffnum = lock->ml_KeyPtr->kp_dir_ent;
    else lock->ml_lock_ext.le_databuffnum = C_DBUFF_UNUSED;

  /* the following statement is VERY NECESSARY but not documented very clearly */
    filehandle->fh_Arg1 = (LONG)lock;     /* pass back FileLock */

    return(DOSTRUE);
}


#define SEEK_ERROR  -1L
#define FILE_ERROR  (ULONG)(-1L)
/**********************************************************************
*   Set_File_Size() -- Set file to the specified file position.  Zero new data.
*
*   return = -1 if error.
*          = new file size if successful.
**********************************************************************/
LONG Set_File_Size(lock,offset,mode)
register struct MLock *lock;
LONG offset;
LONG mode;
{
F();
    LONG curr_cluster,cluster,prevcluster;
    register ULONG new_eof,old_eof;
    register LONG i;
    register struct Lock_ext *lock_ext;
    ULONG filepos;
    register UBYTE *data;
    ULONG datasz;

    if(!lock)
    {
        DOSerror = ERROR_INVALID_LOCK;
        return(DOSFALSE);
    }

    if(!CompareVolNode_Write(lock)) return(DOSFALSE);

    DOSerror = ERROR_SEEK_ERROR;

    lock_ext = &(lock->ml_lock_ext);

    old_eof = lock->ml_KeyPtr->kp_file_size;
    curr_cluster = lock_ext->le_curr_clust;
    filepos = lock_ext->le_file_pos;

    switch(mode)
    {
        case OFFSET_BEGINNING:
            new_eof = offset;
            break;
        case OFFSET_CURRENT:
            new_eof = offset + filepos;
            break;
        case OFFSET_END:
            new_eof = offset + old_eof;
            break;
        default:
            DOSerror = ERROR_SEEK_ERROR;
            break;
    }

    if(old_eof > new_eof)
    {           /* Shorten file size if possible */
/**************************************************************************
For purposes of design simplification, I allow any handle owner to shorten the file
to any size even if there are handle owners of this file with current positions
larger than the new size. I can't imagine the need to shorten the file with other
handles on it at the same time.

If in the future we need to support the limiting of the shorten of the files
dependant on the other handles, we can add it in.
**************************************************************************/
    /* Set the new EOF and free unused clusters */
        cluster = lock->ml_KeyPtr->kp_start_clust;
        for(i = (new_eof)/(fsys->f_blocks_clust<<fsys->f_bytes_block_sh); i > 0; i--)
        {       /* fast-forward to current cluster */
            cluster = readFATentry(fsys,prevcluster = cluster);
            if( (cluster == FAT_BAD ) || (cluster == FAT_FREE) )
            {       /* Illegal FAT link */
                return(SEEK_ERROR);
            }
            else if( cluster >= FAT_EOF_LOW )
            {
                lock_ext->le_prev_clust = prevcluster;
            }
        }
        FreeClusters(readFATentry(fsys,prevcluster));   /* Free cluster no longer used */
        writeFATentry(fsys,prevcluster,FAT_EOF);        /* Make last cluster the EOF */

    /* Change the file size for this lock and locks on the same object */
        lock->ml_KeyPtr->kp_file_size = new_eof;

    /* If current file position of "lock" is greater than new file size, set
    current file position of "lock" to EOF */
        if(lock_ext->le_file_pos > new_eof)
        {
            filepos = new_eof;
            curr_cluster = cluster;
        }
    }
    else
    {           /* Lengthen file size if possible */
        if(SEEK_ERROR == SeekFilePos(lock,0,OFFSET_END))    /* seek to end of file */
        {
            return(SEEK_ERROR);
        }
        if((cluster = lock_ext->le_curr_clust) >= FAT_EOF_LOW) cluster = lock_ext->le_prev_clust;

        data = (UBYTE *)fsys->f_scratch;
    /** Zero all data in buffer **/
        datasz = fsys->f_scratch_sz/sizeof(ULONG);
        for(i=0; i<datasz; i++) ((ULONG *)data)[i] = 0;
        datasz = fsys->f_scratch_sz;
        for(i=(new_eof-old_eof)/(datasz); i>=0; i--)
        {
            if(i==0) datasz=(new_eof-old_eof)%(datasz);
            if(FILE_ERROR == WriteData(lock,data,datasz))
            {
                FreeClusters(readFATentry(fsys,cluster));   /* Free clusters allocated */
                writeFATentry(fsys,cluster,FAT_EOF);        /* Make last cluster the EOF */
                new_eof = SEEK_ERROR;      /* indicate seek error */
                break;      /* break out of for() loop */
            }
        }
    }

/* only set file modified bit if the EOF changed */
    if( (old_eof != new_eof) && (new_eof != SEEK_ERROR) )
    {
        lock->ml_KeyPtr->kp_flags |= FILE_MOD_F;
    }

    lock_ext->le_file_pos = filepos;
    lock_ext->le_curr_clust = curr_cluster;

    DOSerror = 0;
    return((LONG)new_eof);

}


#define JAN_01_80  0x1B00

/*************
* CloseFile()  --- Close file.
*   Return DOSFALSE if cannot close.
*************/
int CloseFile(lock)
register struct MLock *lock;
{
F();
    register struct MFileInfoBlock *mfib = (struct MFileInfoBlock *)fsys->f_scratch;
    register struct FS_dir_ent *dirent;
    UCHAR ctrlz=CTRLZ;
    ULONG volatile filesize;

    if(!lock)
    {
        DOSerror = ERROR_INVALID_LOCK;
        return(DOSFALSE);
    }

    if(lock && (lock->ml_KeyPtr->kp_flags & FILE_MOD_F))
    {
        if(!CompareVolNode_Write(lock)) return(DOSFALSE);

                /* If Ctrl M or Ctrl Z filter flag set put */
        if( lock->ml_lock_ext.le_filt_flags & CTRLM_CTRLZ_F)
        {
            SeekFilePos(lock, 0, OFFSET_END);     /* go to end of file */
            WriteData(lock, &(ctrlz), 1);     /* write CTRLZ at end of file */
        }
          mfib->mfib_DiskCluster   = (lock->ml_KeyPtr->kp_dir_clust);
          mfib->mfib_DiskDirEntry  = (lock->ml_KeyPtr->kp_dir_ent)-1; /* point to previous entry */
          mfib->mfib_DirEntStatus  = MLDE_DIR;

/*### Update date of parent directory of file ###*/
        SetDate_ParentDir(mfib);

        if(!(dirent = GetNextDirEnt(mfib)))
        {
            return(DOSFALSE);
        }

        filesize = lock->ml_KeyPtr->kp_file_size;
          SWAPLONG(dirent->fde_file_size,filesize);

            /*** set "rwed" file attributes ****/
        dirent->fde_protection = 0;

            /**** Set Current Date and Time ****/
        *((ULONG *)(dirent->fde_time)) = SetCurrentTime(); /* copy creation time */

        if( !StoreDirEnt(dirent))
        {
            return(DOSFALSE);
        }
    }

    return(FreeLock(lock));
}



#define FILE_ERROR  (ULONG)(-1L)
#define FILE_EOF    0
/***************
*   ReadData() -- Get file data requested and move into buffer.
*
*   return = 0 for end of file
*          = size of transfer
*          = -1 (DOSTRUE) for error in reading.
********/
LONG ReadData(lock, buffer, size)
register struct MLock *lock;
register UBYTE *buffer;
LONG size;
{
F();
    register struct FS *fs = fsys;
    register ULONG blocks_clust = fs->f_blocks_clust;
    register ULONG bytes_clust = blocks_clust<<fs->f_bytes_block_sh;
    register LONG datasize, pos_mod;
    register LONG i, j, actualsize=0;
    LONG maxtransferpos;
    register LONG filepos;
    LONG cluster, prevcluster, nextcluster;
    UBYTE *data, *databgn;
    struct trans_table *t_tbl;
    UBYTE *tbl;

    BYTE error=0;

    DOSerror = 0;

    if(!lock)
    {
        DOSerror = ERROR_INVALID_LOCK;
        return(FILE_ERROR);
    }

    if(!CompareVolNode(lock)) return(FILE_ERROR);

    maxtransferpos = min(lock->ml_KeyPtr->kp_file_size, (lock->ml_lock_ext.le_file_pos) + size);
    filepos = lock->ml_lock_ext.le_file_pos;
    cluster = lock->ml_lock_ext.le_curr_clust;
    prevcluster = lock->ml_lock_ext.le_prev_clust;

/* Already at End-of-File */
    if( filepos >= lock->ml_KeyPtr->kp_file_size) return(FILE_EOF);

    while( (filepos < maxtransferpos)
        && (cluster < FAT_BAD)
        && !(error) )
    {
        pos_mod = filepos%bytes_clust;

    /****** special SPEEDUP particularly for large files */
        if( (0 == pos_mod)
            /* Added to insure dummy file doe not try to get read from disk */
            && (ILLEGAL_CLUST != cluster)     /* not a dummy file */
                /* Check if you can transfer direct to buffer. */
            && !(lock->ml_lock_ext.le_filt_flags & CTRLM_CTRLZ_F)   /* not filtering */
                 /* and mask fits memory */
            && ((ULONG)(&buffer[actualsize]) == (fsys->f_mem_mask & (ULONG)(&buffer[actualsize])))
            && ((datasize = min(size-actualsize, maxtransferpos-filepos)) >= bytes_clust))
        {
        /* Calculate maximum cluster size to transfer directly at one time */
            for(j=1, i=datasize/bytes_clust, nextcluster=prevcluster=cluster;
                (i>1);
                i--, j++)
            {
                if((nextcluster=readFATentry(fsys,nextcluster)) != cluster+j) break;    /* check if contiguous clusters */
                if(0 != (FindBlockInCache(ConvertCluster(nextcluster,0)))) break;     /* check if already in cache */
            }
D();
            error = GetBlockMem(&buffer[actualsize],ConvertCluster(cluster,0), blocks_clust*j);
            
        /* adjust file and buffer pointers to actual bytes read */
            datasize = diskreq->io_Actual;
            cluster += (datasize/bytes_clust) - 1;
            actualsize += datasize;
            filepos += datasize;
        }
         else 
        {
        /* calc maximum number of bytes to be transferred in current cluster */
            datasize = min(bytes_clust - pos_mod, maxtransferpos - filepos);

            if( !(data = ReadCluster(cluster, lock)))
            {
                error = (BYTE)FILE_ERROR;
                break;  /* break out of while() */
            }

        /* calc begin displacement of data in current Block */
            databgn = &data[pos_mod];

        /* Ctrl M or Ctrl Z Filter flag set */
            if( lock->ml_lock_ext.le_filt_flags & CTRLM_CTRLZ_F)
            {
                for(i=0; i < datasize; i++)
                {
                    if(databgn[i] == CTRLM);    /* if CTRL_M do not transfer */
                     else if (databgn[i] == CTRLZ)  /* if CTRL_Z then EOF */
                    {
                        filepos = lock->ml_KeyPtr->kp_file_size-i;
                        break;
                    }
                     else buffer[actualsize++] = databgn[i];    /* no filter byte */
                }
                filepos += i;
            }
        /* NO Filter -- regular transfer */
             else
            {
                CopyMem(databgn, &buffer[actualsize], datasize );
                actualsize += datasize;
                filepos += datasize;
            }
        }
    /* go find next cluster if file position pointing to next cluster */
        if( (filepos) && (0 == (pos_mod=filepos%bytes_clust)) && (datasize) )
        {
            cluster = readFATentry(fs,prevcluster = cluster);
            if( (cluster == FAT_BAD ) || (cluster == FAT_FREE) )
            {       /* Illegal FAT link */
                error = (BYTE)FILE_ERROR;
            }
        }
        lock->ml_lock_ext.le_curr_clust = cluster;
        lock->ml_lock_ext.le_prev_clust = prevcluster;
        lock->ml_lock_ext.le_file_pos = filepos;
    }

    if( (lock->ml_lock_ext.le_filt_flags & XLAT1_F))
    {                           /* XLAT1 filter or International translator set */
        if(t_tbl = lock->ml_lock_ext.le_trans_tbl)
        {
            tbl = t_tbl->tbl_MtoA;      /* Translate MSDOS to Amiga */
            for(i=0; i < actualsize; i++)
            {
               buffer[i] = tbl[buffer[i]];
            }
        }
         else
        {   /* No translate table. Use high-bit strip */
            for(i=0; i < actualsize; i++)
            {
                buffer[i] &= ASCII_7;
            }
        }
    }
    return((LONG)actualsize);
}


/***************
*   WriteData() -- Move file data from buffer to block cache buffer.
*
*   return = 0 for end of file
*          = size of transfer
*          = -1 (DOSTRUE) for error in writing.
********/
LONG WriteData(lock, buffer, size)
register struct MLock *lock;
register UBYTE *buffer;
LONG size;
{
F();
    register struct FS *fs = fsys;
    register int bytes_clust = fs->f_blocks_clust<<fs->f_bytes_block_sh;
    register int datasize, pos_mod;
    register LONG i, actualsize=0;
    LONG cluster, prevcluster;
    register LONG filepos;
    UBYTE *data, *databgn;
    struct Lock_ext *lock_ext;
    UBYTE addctrlj = 0, c;
    struct trans_table *t_tbl;
    UBYTE *tbl;


DPRTF(KPrintF("\n\tW: block = %ld  size = %ld",lock->ml_lock_ext.le_curr_clust>>fs->f_bytes_block_sh, size));
    if(size <= 0) return(0);
    if(!lock)
    {
        DOSerror = ERROR_INVALID_LOCK;
        return(FILE_ERROR);
    }


    if(!CompareVolNode_Write(lock)) return(FILE_ERROR);
    if(DOSerror == ERROR_WRITE_PROTECTED) return(FILE_ERROR);

    lock_ext = &(lock->ml_lock_ext);
    filepos= lock_ext->le_file_pos;
    /* If a dummy file, then protect it from being written to */
    if(ILLEGAL_CLUST == (cluster = lock_ext->le_curr_clust))
    {
        DOSerror = ERROR_WRITE_PROTECTED;
        return(FILE_ERROR);
    }
    prevcluster = lock_ext->le_prev_clust;

    lock->ml_KeyPtr->kp_flags  |= FILE_MOD_F;

    while( ((datasize = size - actualsize) > 0)
        && ((cluster < FAT_BAD) || (cluster >= FAT_EOF_LOW)))
    {
        pos_mod = filepos%bytes_clust;

    /* calc maximum number of bytes to be transfered in current cluster */
        datasize = min(bytes_clust - pos_mod, size-actualsize);

    /* go allocate next cluster if at the end of file */
        if((datasize) && (cluster >= FAT_EOF_LOW))
        {
            if( !(cluster = AllocCluster(prevcluster)))
            {
                DOSerror = ERROR_DISK_FULL;
                return(FILE_ERROR);
            }
              else if(FAT_BAD <= cluster)
            {
                break;  /* break out of while() */
            }
        }

/*###########################################################################
    INSERT Direct transfer speedup routine here.
###########################################################################*/
        {
            if(datasize != bytes_clust)  /* only partial cluster to be written */
            {               /* Get data from cluster(s) */
                if( !(data = ReadCluster(cluster, lock)))
                {
                    break;  /* break out of while() */
                }
            }
            if( !(data = WriteCluster(cluster, lock)))
            {
                break;  /* break out of while() */
            }

        /* calc begin displacement of data in current Block */
            databgn = &data[pos_mod];

        /* Ctrl M or Ctrl Z filter flag set */
            if( lock_ext->le_filt_flags & CTRLM_CTRLZ_F)
            {
                for(i=pos_mod;
                    (actualsize < size) && (i < bytes_clust);
                    i++)
                {
                /* if CTRL_J add CTRL_M before */
                    c = buffer[actualsize++];
                    if(!addctrlj)
                    {
                        switch( c )
                        {
                            case CTRLJ:
                                c = CTRLM;  /* insert CTRL M before CTRL J */
                                actualsize--;
                            case CTRLM:
                                addctrlj = 1;
                            default:
                                break;
                        }
                    }
                      else addctrlj = 0;
                    data[i] = c;    /* no filter byte */
                }
                filepos += (datasize = (i-pos_mod));
            }
        /* NO Filter -- regular transfer */
              else
            {
                CopyMem(&buffer[actualsize], databgn, datasize );
                actualsize += datasize;
                filepos += datasize;
            }

            if( (lock_ext->le_filt_flags & XLAT1_F))
            {                           /* International translator set */
                if(t_tbl = lock->ml_lock_ext.le_trans_tbl)
                {
                    tbl = t_tbl->tbl_AtoM;      /* Translate Amiga to MSDOS */
                    for(i=0; i < datasize; i++)
                    {
                        databgn[i] = tbl[databgn[i]];
                    }
                }
            }
        }
    /* go find next cluster if file position pointing to next cluster */
        if( (filepos) && (0 == (pos_mod=filepos%bytes_clust)) && (datasize) )
        {
            cluster = readFATentry(fsys,prevcluster = cluster);
            lock_ext->le_prev_clust = prevcluster;
        }
    }

/* If actual size of write is less than the requested transfer size, do not
update current cluster and file position so that the user can retry this
operation at the same file location.  */
    if(actualsize == size)
    {
        lock_ext->le_curr_clust = cluster;
        lock_ext->le_prev_clust = prevcluster;
        lock_ext->le_file_pos = filepos;
    }

/* If the current file position is greater than the file size, change the file
size for this lock and locks on the same object */
    if(filepos > lock->ml_KeyPtr->kp_file_size)
    {
        lock->ml_KeyPtr->kp_file_size = filepos;
    }
    return((LONG)actualsize);
}


#define SEEK_ERROR  -1L
/********
*   SeekFilePos() -- Seek to the specified file position and return old position.
*
*   mode = -1 = OFFSET_BEGINNING -- relative to the beginning of file
*        =  0 = OFFSET_CURRENT   -- relative to the current position of file
*        =  1 = OFFSET_END       -- relative to the end of file
*
*   return = old position
*          = -1 (SEEK_ERROR) for error in seeking.
********/
LONG SeekFilePos(lock, offset, mode)
register struct MLock *lock;
LONG offset;
LONG mode;
{
F();
    LONG filepos, oldpos;
    int i;
    LONG cluster, prevcluster, endpos;


    if(!lock)
    {
        DOSerror = ERROR_INVALID_LOCK;
        return(FILE_ERROR);
    }

    endpos= lock->ml_KeyPtr->kp_file_size;


    oldpos = lock->ml_lock_ext.le_file_pos;
    cluster = lock->ml_KeyPtr->kp_start_clust;

    if(!CompareVolNode(lock)) return(FILE_ERROR);

    switch(mode)
    {
        case OFFSET_BEGINNING:
            filepos = offset;
            break;
        case OFFSET_CURRENT:
            filepos = offset + lock->ml_lock_ext.le_file_pos;
            break;
        case OFFSET_END:
            filepos = offset + endpos;
            break;
        default:
            DOSerror = ERROR_SEEK_ERROR;
            return(SEEK_ERROR);
            break;
    }
    if((filepos>endpos) || (filepos<0))
    {
            DOSerror = ERROR_SEEK_ERROR;
            return(SEEK_ERROR);
    }

/* Find new current cluster */
/* Since this is a single-linked list, I must start with the starting cluster
 to find the current cluster of the seek position */
    for(i = (filepos)/(fsys->f_blocks_clust<<fsys->f_bytes_block_sh); i > 0; i--)
    {       /* fast-forward to current cluster */
        cluster = readFATentry(fsys,prevcluster = cluster);
        if( (cluster == FAT_BAD) || (cluster == FAT_FREE) )
        {       /* Illegal FAT link */
            DOSerror = ERROR_SEEK_ERROR;
            return(SEEK_ERROR);
        }
        else if( cluster >= FAT_EOF_LOW )
        {
            lock->ml_lock_ext.le_prev_clust = prevcluster;
        }
    }
    lock->ml_lock_ext.le_file_pos = filepos;
    lock->ml_lock_ext.le_curr_clust = cluster;

    return(oldpos);
}


/*##############################################################################
###############   Begin WriteData() Direct transfer Speedup Routine  ###########
####    This routine is not used because it actually slows down writing
####    data to the disk.  Go figure!  Current tests results:
####
####    (Copying >700K worth of files to the disk with 65K minimum buffer size)
####    to floppy -> 70 seconds slower.
####    to hard disk -> 2 seconds slower.
####
####    This routine is here for those who would like to try it out.  If you can
####    make it faster than the buffering technique used above.  Be my guest.

    LONG nextcluster;


    /****** special SPEEDUP particularly for large files */
        if( (0 == pos_mod)
                /* Check if you can transfer direct to buffer. */
            && !(lock->ml_lock_ext.le_filt_flags & CTRLM_CTRLZ_F)   /* not filtering */
                 /* and mask fits memory */
            && ((ULONG)(&buffer[actualsize]) == (fsys->f_mem_mask & (ULONG)(&buffer[actualsize])))
            && ((datasize = size-actualsize) >= bytes_clust))
        {
        /* Calculate maximum cluster size to transfer directly at one time */
DPRTF(KPrintF("\n\tdatasize=%ld  ",datasize));
        /* First, try to find all consecutive clusters */
            for(j=1,i=datasize/bytes_clust, nextcluster=cluster;
                (i>1);
                i--,j++)
            {
DPRTF(KPrintF("\n\t1: i=%ld  j=%ld  nextcluster=%ld  cluster=%ld",i,j,nextcluster,cluster));
                if((nextcluster=readFATentry(fsys,nextcluster)) != cluster+j) break;    /* check if contiguous clusters */
                if(0 != (FindBlockInCache(ConvertCluster(nextcluster,0)))) break;     /* check if already in cache */
            }
        /* Next, try to allocate consecutive clusters if nextcluster>=FAT_EOF_LOW from previous routine */
            if(nextcluster >= FAT_EOF_LOW)
            {
                for(nextcluster=prevcluster;
                    (i>1) && ((nextcluster = AllocCluster(nextcluster)) == cluster+j);
                    i--,j++)
                {
DPRTF(KPrintF("\n\t2: i=%ld  j=%ld  nextcluster=%ld  cluster=%ld",i,j,nextcluster,cluster));
                }
            }

/** Check to see if one too many clusters allocated if the last cluster could
not be consecutive. Deallocate if necessary */
                if( nextcluster == 0 )
                {
                    DOSerror = ERROR_DISK_FULL;
                    return(FILE_ERROR);
                }
                  else if(FAT_BAD <= nextcluster)
                {
                    break;  /* break out of while() */
                }
            if(PutBlockMem(&buffer[actualsize],ConvertCluster(cluster,0), blocks_clust*j))
            {
                break;  /* break out of while() loop */
            }

            datasize = diskreq->io_Actual;
            cluster += (datasize/bytes_clust) - 1;
DPRTF(KPrintF( "\nWriteData: j=%ld  datasize=%ld  size-actualsize=%ld",j,datasize,size-actualsize));
            actualsize += datasize;
            filepos += datasize;

        }
        else
###############   End WriteData() Speedup Routine  ############################
##############################################################################*/
@


38.15
log
@Move of string constant to this module. Cast to remove error msg.
@
text
@d30 1
a84 4
    if( newmfib && (mfib->mfib_Protection & FIBF_WRITE))
    {
        fileflags |= FILE_WRITE_PROT_F;
    }
d87 7
a93 1
        return(DOSFALSE);
d101 1
a101 1
    lock->ml_lock_ext.le_flags          = fileflags;
d124 3
a126 2
    lock->ml_lock_ext.le_curr_clust     = lock->ml_lock_ext.le_start_clust;
    lock->ml_lock_ext.le_databuffnum    = C_DBUFF_UNUSED;
d148 1
d152 2
a153 2
    register struct Lock_ext *nextlock_ext,*lock_ext;
    ULONG filepos, maxpos=0;
a156 1

d169 1
a169 1
    old_eof = lock_ext->le_file_size;
d191 9
a199 13
/* Find maximum file position of all lock extensions of the same object */
/* But do not count the current position of "lock" */
        nextlock_ext = (struct Lock_ext *)(lock_ext->le_samelock.mln_Succ);
        do
        {
            maxpos = max(maxpos,nextlock_ext->le_file_pos);
            nextlock_ext = (struct Lock_ext *)(nextlock_ext->le_samelock.mln_Succ);
        } while(nextlock_ext != lock_ext);

    /* The new EOF cannot be smaller than the largest current file position */
    /* except the current position of "lock" */
        new_eof = max(maxpos,new_eof);

d201 1
a201 1
        cluster = lock_ext->le_start_clust;
d218 1
a218 6
        nextlock_ext = lock_ext;
        do
        {
            nextlock_ext->le_file_size = new_eof;
            nextlock_ext = (struct Lock_ext *)(nextlock_ext->le_samelock.mln_Succ);
        } while(nextlock_ext != lock_ext);
d257 1
a257 1
        lock_ext->le_flags |= FILE_MOD_F;
d263 1
d278 1
d290 1
a290 1
    if(lock && (lock->ml_lock_ext.le_flags & FILE_MOD_F))
d300 2
a301 2
          mfib->mfib_DiskCluster   = (lock->ml_lock_ext.le_dir_clust);
          mfib->mfib_DiskDirEntry  = (lock->ml_lock_ext.le_dir_ent)-1; /* point to previous entry */
d312 1
a312 1
        filesize = lock->ml_lock_ext.le_file_size;
d346 1
d371 1
a371 1
    maxtransferpos = min(lock->ml_lock_ext.le_file_size, (lock->ml_lock_ext.le_file_pos) + size);
d377 1
a377 1
    if( filepos >= lock->ml_lock_ext.le_file_size) return(FILE_EOF);
d387 2
d403 1
d434 1
a434 1
                        filepos = lock->ml_lock_ext.le_file_size-i;
d497 1
d505 1
a505 1
    struct Lock_ext *nextlock_ext,*lock_ext;
a509 1
    DOSerror = 0;
d525 6
a530 1
    cluster = lock_ext->le_curr_clust;
d533 1
a533 1
    lock_ext->le_flags |= FILE_MOD_F;
d643 1
a643 1
    if(filepos > lock_ext->le_file_size)
d645 1
a645 6
        nextlock_ext = lock_ext;
        do
        {
            nextlock_ext->le_file_size = filepos;
            nextlock_ext = (struct Lock_ext *)(nextlock_ext->le_samelock.mln_Succ);
        } while(nextlock_ext != lock_ext);
d667 1
a671 1
    DOSerror = 0;
d679 1
a679 1
    endpos= lock->ml_lock_ext.le_file_size;
d683 1
a683 1
    cluster = lock->ml_lock_ext.le_start_clust;
@


38.14
log
@Fixed problem when reading or seeking past EOF or BOF. Now conforms to
method used in 2.0 FFS.
@
text
@d14 1
d16 1
a16 2

static const UCHAR *info = ".info";
d418 1
a418 1
                error = FILE_ERROR;
d454 1
a454 1
                error = FILE_ERROR;
@


38.9
log
@Modified OpenFile() to allow ACTION_FH_FROM_LOCK to work.
,
@
text
@a10 6
extern UBYTE *ReadCluster();
extern UBYTE *WriteCluster();
extern struct FS_dir_ent *GetNextDirEnt();
extern struct MFileInfoBlock *CreateObject();
extern struct MFileInfoBlock *FindObject();
extern struct MLock         *MakeLock();
d16 1
a16 1
UCHAR *info = ".info";
d93 1
a93 1
    if(lock == 0) if(!(lock = MakeLock(newmfib, lockmode)))
d363 1
a363 1
    if(!lock) return(FILE_ERROR);
d365 5
a380 2
    DOSerror = ERROR_SEEK_ERROR;

d508 1
d510 1
a510 1
DPRTF(KPrintF("\n\tW: block = %ld  size = %ld",lock->ml_lock_ext.le_curr_clust>>bytes_block_sh, size));
d512 5
a516 1
    if(!lock) return(FILE_ERROR);
a520 1
    DOSerror = ERROR_SEEK_ERROR;
d670 8
a677 1
    if(!lock) return(FILE_ERROR);
a685 2
    DOSerror = ERROR_SEEK_ERROR;

d698 1
d702 5
a706 1
    filepos = max(0,min(endpos,filepos));
d716 1
@


38.7
log
@Fixed problem with what is acceptable as a EOF FAT entry.  The previous
version only accepted 0xFFFF.  In further 'digging', MS-DOS allows for
0xFFF8 to 0xFFFF inclusive to be acceptable as an EOF FAT entry.  The only
occurance we have seen recently of using an EOF FAT entry other than 0xFFFF
was on a disk written to with the Apple File Exchange on a Mac.  They (go
figure!) used 0xFFF8 instead.
@
text
@d38 1
a38 1
    register struct MLock *lock;
d83 3
d94 6
a99 1
    if( !newmfib || !(lock = MakeLock(newmfib, lockmode)))
@


38.5
log
@Fixed ReadData() to check cache for speedup.
@
text
@d203 2
a204 2
            if( ((cluster >= FAT_BAD ) && (cluster < FAT_EOF )) || (cluster == FAT_FREE) )
            {
d207 1
a207 1
            else if( cluster == FAT_EOF )
d237 1
a237 1
        if((cluster = lock_ext->le_curr_clust) == FAT_EOF) cluster = lock_ext->le_prev_clust;
d332 1
d447 2
a448 2
            if( ((cluster >= FAT_BAD ) && (cluster < FAT_EOF )) || (cluster == FAT_FREE) )
            {
a449 1
                break;
d521 1
a521 1
        && ((cluster < FAT_BAD) || (cluster == FAT_EOF)))
d529 1
a529 1
        if((datasize) && (FAT_EOF == cluster))
d695 2
a696 2
        if( ((cluster >= FAT_BAD ) && (cluster < FAT_EOF )) || (cluster == FAT_FREE) )
        {
d699 1
a699 1
        else if( cluster == FAT_EOF )
d745 2
a746 2
        /* Next, try to allocate consecutive clusters if nextcluster=FAT_EOF from previous routine */
            if(nextcluster == FAT_EOF)
@


38.4
log
@Changed the Open() specs on ACTION_FINDUPDATE to match 2.0 instead of 1.3
specs.
@
text
@d24 2
d44 3
a46 2
        /* Find if file exists.  newmfib = mfib if found or =0 if not found */
    newmfib = FindObject(dirlock, name, mfib);
d48 4
a51 4
    if( DOSerror == ERROR_INVALID_COMPONENT_NAME )    /* bad filespec */
    {
        return(DOSFALSE);
    }
d53 5
a57 5
    if( newmfib && (mfib->mfib_DirEntStatus != MLDE_FILE))    /* if not a file, return with error */
    {
        DOSerror = ERROR_OBJECT_WRONG_TYPE;
        return(DOSFALSE);
    }
d59 12
a70 14
    switch(mode)
    {
        case ACTION_FINDINPUT:
            lockmode = SHARED_LOCK;
            break;
        case ACTION_FINDUPDATE:
            lockmode = SHARED_LOCK;
            if(!newmfib) goto Open_Create_New_File;
            break;
        case ACTION_FINDOUTPUT:
            lockmode = EXCLUSIVE_LOCK;
            if( newmfib )
            {
                if( !DeleteObject(dirlock, name))
d72 4
a75 1
                    return(DOSFALSE);
a76 1
            }
d78 7
a84 6
            if( newmfib = CreateObject(dirlock, name, mfib))
            {
                fileflags |= FILE_MOD_F;
            }
            break;
        default:    return(DOSFALSE);
a97 1

d119 1
a119 2
    lock->ml_lock_ext.le_curr_clust     =
        (lock->ml_lock_ext.le_start_clust = (LONG)mfib->mfib_start_clust);
d344 1
a344 1
ULONG size;
d346 3
a348 1
    register ULONG bytes_clust = fsys->f_blocks_clust<<fsys->f_bytes_block_sh;
d351 2
a352 2
    ULONG maxtransferpos;
    register ULONG filepos;
a357 2
    ULONG blocks_clust = fsys->f_blocks_clust;

d361 4
a369 2
    if(!CompareVolNode(lock)) return(FILE_ERROR);

d391 6
a396 2
                (i>1) && ((nextcluster=readFATentry(fsys,nextcluster)) == cluster+j);
                i--, j++);
d445 1
a445 1
            cluster = readFATentry(fsys,prevcluster = cluster);
d489 1
a489 1
ULONG size;
d491 2
a492 1
    register int bytes_clust = fsys->f_blocks_clust<<fsys->f_bytes_block_sh;
d494 1
a494 1
    register ULONG i, actualsize=0;
d496 1
a496 1
    register ULONG filepos;
d504 2
d508 5
a517 11
    if(!CompareVolNode_Write(lock)) return(FILE_ERROR);

/* files with READ locks are not allowed to be written to */
    if(lock->ml_lock.fl_Access == READ_LOCK)
    {
        DOSerror = ERROR_WRITE_PROTECTED;
        return(FILE_ERROR);
    }

    DOSerror = ERROR_SEEK_ERROR;

d541 1
d543 1
a543 1
    INSERT Direct transfer sppedup routine here.
a544 1

d662 4
a665 1
    oldpos=lock->ml_lock_ext.le_file_pos;
a666 1
    endpos=(lock->ml_lock_ext.le_file_size);
d738 1
a738 1
                (i>1) && ((nextcluster=readFATentry(fsys,prevcluster=nextcluster)) == cluster+j);
d742 2
@


38.3
log
@Added ReadData() optimization for consecutive block reads.
@
text
@d38 1
d60 1
a60 2
            goto OpenFile1;

d62 2
a63 6
            lockmode = EXCLUSIVE_LOCK;
OpenFile1:
            if( newmfib && (mfib->mfib_Protection & FIBF_WRITE))
            {
                fileflags |= FILE_WRITE_PROT_F;
            }
d66 1
d74 1
a77 1
                lockmode = EXCLUSIVE_LOCK;
d83 4
d94 1
d96 1
a96 1
/* Using the utility.library equivalent to strnicmp() becasue with localization
d99 3
a101 1
        && (0 != strnicmp(info,&name[name[0]-(STRLEN_INFO-1)],STRLEN_INFO)))
d105 1
a105 1
DPRTF(KPrintF( "\nOpenFile: Text Filter 1 ON"));
d110 1
a110 1
DPRTF(KPrintF( "\nOpenFile: Text Tranlator 1 ON"));
@

38.2
log
@Changed Trans_A_M() and Trans_M_A() to use more optimized code.
@
text
@d18 1
d111 1
d194 1
a194 1
        for(i = (new_eof)/(fsys->f_bytes_block * fsys->f_blocks_clust); i > 0; i--)
d203 1
a203 1
                lock_ext->le_last_clust = prevcluster;
d231 1
a231 1
        if((cluster = lock_ext->le_curr_clust) == FAT_EOF) cluster = lock_ext->le_last_clust;
d340 3
a342 3
    register int bytes_clust = fsys->f_bytes_block * fsys->f_blocks_clust;
    register int datasize, pos_mod;
    register ULONG i, actualsize=0;
d345 1
a345 1
    LONG cluster, prevcluster;
d352 1
d358 1
d368 2
a369 1
        && (cluster < FAT_BAD) )
d373 17
a389 13
    /* calc maximum number of bytes to be transferred in current cluster */
        datasize = min(bytes_clust - pos_mod, maxtransferpos - (filepos));

    /* special SPEEDUP particularly for large files */
        if((datasize == bytes_clust)
            && (pos_mod == 0)
            && !(lock->ml_lock_ext.le_filt_flags & CTRLM_CTRLZ_F)
            && (fsys->f_FSflags & MF_PUB_MEM))
        {
            if( GetBlockMem(&buffer[actualsize],ConvertCluster(cluster,0), blocks_clust))
            {
                break;  /* break out of while() */
            }
a391 1

d395 3
d400 1
a429 1
        pos_mod = filepos%bytes_clust;
d431 1
a431 1
        if( (filepos) && (pos_mod == 0) && (datasize) )
d436 1
a438 4
            else if( cluster == FAT_EOF )
            {
                lock->ml_lock_ext.le_last_clust = prevcluster;
            }
d441 1
d479 2
a480 2
    int bytes_clust = fsys->f_bytes_block * fsys->f_blocks_clust;
    int datasize, pos_mod;
d494 1
d496 1
a496 1
    filepos= lock_ext->le_file_pos;
d511 2
a512 2
    while( (actualsize < size)
        && ((cluster < FAT_BAD) || (cluster == FAT_EOF)) )
d522 1
a522 1
            if( !(cluster = AllocCluster(lock_ext->le_last_clust)))
d527 4
d532 4
a535 1
          else if(FAT_BAD <= cluster)
d537 8
a544 6
            break;  /* break out of while() */
        }

        if(datasize != bytes_clust)  /* only partial cluster to be written */
        {               /* Get data from cluster(s) */
            if( !(data = ReadCluster(cluster, lock)))
d548 10
a557 19
         }
        if( !(data = WriteCluster(cluster, lock)))
        {
            break;  /* break out of while() */
        }

    /* calc begin displacement of data in current Block */
        databgn = &data[pos_mod];

    /* Ctrl M or Ctrl Z filter flag set */
        if( lock_ext->le_filt_flags & CTRLM_CTRLZ_F)
        {
            for(i=pos_mod;
                (actualsize < size) && (i < bytes_clust);
                i++)
            {
            /* if CTRL_J add CTRL_M before */
                c = buffer[actualsize++];
                if(!addctrlj)
d559 3
a561 1
                    switch( c )
d563 10
a572 7
                        case CTRLJ:
                            c = CTRLM;  /* insert CTRL M before CTRL J */
                            actualsize--;
                        case CTRLM:
                            addctrlj = 1;
                        default:
                            break;
d574 2
d577 8
a584 2
                  else addctrlj = 0;
                data[i] = c;    /* no filter byte */
a585 9
            filepos += (datasize = (i-pos_mod));
        }
    /* NO Filter -- regular transfer */
          else
        {
            CopyMem(&buffer[actualsize], databgn, datasize );
            actualsize += datasize;
            filepos += datasize;
        }
d587 3
a589 6
        if( (lock_ext->le_filt_flags & XLAT1_F))
        {                           /* International translator set */
            if(t_tbl = lock->ml_lock_ext.le_trans_tbl)
            {
                tbl = t_tbl->tbl_AtoM;      /* Translate Amiga to MSDOS */
                for(i=0; i < datasize; i++)
d591 5
a595 1
                    databgn[i] = tbl[databgn[i]];
a598 1
        pos_mod = filepos%bytes_clust;
d600 1
a600 1
        if( (filepos) && (pos_mod == 0) && (datasize) )
d603 1
a603 4
            if( cluster == FAT_EOF )
            {
                lock->ml_lock_ext.le_last_clust = prevcluster;
            }
d613 1
d681 1
a681 1
    for(i = (filepos)/(fsys->f_bytes_block * fsys->f_blocks_clust); i > 0; i--)
d690 1
a690 1
            lock->ml_lock_ext.le_last_clust = prevcluster;
d698 71
@


38.1
log
@Original CrossDOS souce submitted to CBM
@
text
@d346 1
d440 1
d443 1
a443 1
               buffer[i] = t_tbl->tbl_M_A[buffer[i]];
d447 1
a447 1
        {
d479 1
d577 1
d580 1
a580 1
                    databgn[i] = t_tbl->tbl_A_M[databgn[i]];
@
