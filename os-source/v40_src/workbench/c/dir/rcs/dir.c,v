head     1.28;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @*   @;


1.28
date     91.06.04.17.49.29;  author vertex;  state Exp;
branches ;
next     1.27;

1.27
date     91.04.26.15.38.39;  author vertex;  state Exp;
branches ;
next     1.26;

1.26
date     91.04.14.23.50.26;  author B_Drake;  state Exp;
branches ;
next     1.25;

1.25
date     91.03.17.16.52.57;  author B_Drake;  state Exp;
branches ;
next     1.24;

1.24
date     91.03.04.22.09.59;  author B_Drake;  state Exp;
branches ;
next     1.23;

1.23
date     91.02.25.20.55.14;  author B_Drake;  state Exp;
branches ;
next     1.22;

1.22
date     90.10.26.13.54.34;  author John_Toebes;  state Exp;
branches ;
next     1.21;

1.21
date     90.10.26.09.52.48;  author John_Toebes;  state Exp;
branches ;
next     1.20;

1.20
date     90.10.11.22.04.04;  author J_Toebes;  state Exp;
branches ;
next     1.19;

1.19
date     90.09.06.14.02.19;  author eric;  state Exp;
branches ;
next     1.18;

1.18
date     90.09.05.13.56.18;  author eric;  state Exp;
branches ;
next     1.17;

1.17
date     90.06.14.14.33.42;  author andy;  state Exp;
branches ;
next     1.16;

1.16
date     90.06.09.21.13.00;  author andy;  state Exp;
branches ;
next     1.15;

1.15
date     90.06.01.00.03.09;  author andy;  state Exp;
branches ;
next     1.14;

1.14
date     90.05.31.23.58.05;  author andy;  state Exp;
branches ;
next     1.13;

1.13
date     90.05.31.23.55.00;  author andy;  state Exp;
branches ;
next     1.12;

1.12
date     90.05.31.22.26.36;  author andy;  state Exp;
branches ;
next     1.11;

1.11
date     90.05.31.00.36.15;  author andy;  state Exp;
branches ;
next     1.10;

1.10
date     90.05.30.23.58.15;  author andy;  state Exp;
branches ;
next     1.9;

1.9
date     90.05.26.18.58.40;  author andy;  state Exp;
branches ;
next     1.8;

1.8
date     90.05.25.14.01.40;  author andy;  state Exp;
branches ;
next     1.7;

1.7
date     90.05.01.21.28.46;  author andy;  state Exp;
branches ;
next     1.6;

1.6
date     90.05.01.21.12.29;  author andy;  state Exp;
branches ;
next     1.5;

1.5
date     90.04.06.19.06.38;  author andy;  state Exp;
branches ;
next     1.4;

1.4
date     90.04.06.15.43.14;  author andy;  state Exp;
branches ;
next     1.3;

1.3
date     90.03.12.20.06.02;  author andy;  state Exp;
branches ;
next     1.2;

1.2
date     90.03.01.19.26.59;  author andy;  state Exp;
branches ;
next     1.1;

1.1
date     90.01.22.19.51.57;  author andy;  state Exp;
branches ;
next     1.0;

1.0
date     90.01.22.19.29.03;  author andy;  state Exp;
branches ;
next     ;


desc
@Dir command for cdos
@


1.28
log
@Changed sorting code to avoid infinite loop problems given certain input filenames
@
text
@; /*
FailAt 21
Lc -d -j73 -rr -O -o/obj/Dir.o -i/include -v -cfimst -q1e99w Dir.c
Blink /obj/Dir.o to Dir.ld lib lib:lcr.lib sc sd nd batch
Protect /bin/Dir +p
Quit
*/

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* |_o_o|\\ Copyright (c) 1989 The Software Distillery.  All Rights Reserved */
/* |. o.| || This program may not be distributed without the permission of   */
/* | .	| || the authors:			      BBS: (919) 460-7430    */
/* | o	| ||   Dave Baker      Alan Beale	  Jim Cooper		     */
/* |  . |//    Jay Denebeim    Bruce Drake	  Gordon Keener 	     */
/* ======      John Mainwaring Andy Mercier	  Jack Rouse		     */
/*	       John Toebes     Mary Ellen Toebes  Doug Walker  Mike Whitcher */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*---------------------------------------------------------------------------*/
/* Command: Dir 							     */
/* Author:  Bruce M. Drake						     */
/*									     */
/* Change History:							     */
/*  Date    Person	  Action					     */
/* -------  ------------- -----------------				     */
/* 06APR89  Bruce Drake   Initial Creation				     */
/* 30OCT89    "     "     Rewritten to use DOS 36                            */
/* 03NOV89    "     "     Rewritten again to use new algorithms made         */
/*			    possible with DOS 36			     */
/* 27NOV89    "     "     Added Global structure variable, simplifies        */
/*			    registerized parameters			     */
/* 03DEC89    "     "     Completed implementation of MatchFirst, MatchNext  */
/*			    but interactive mode needs work.		     */
/* 08DEC89    "     "     Complete and tested, needs interactive Delete      */
/*			    code added. Problem with Match...() prevents     */
/*			    implementation until problems are resolved.      */
/* 13DEC89    "     "     Last minute documentation and bug fixes.  What I   */
/*			    would call Version 0.9			     */
/* 17DEC89    "     "     All functions implemented, ready for first beta.   */
/* 06JAN90    "     "     Fixed problem with MatchFirst() and with OPT       */
/*			    parameter parsing				     */
/* 08MAR90    "     "     Fixed problem with interactive not flushing to     */
/*			    screen.  Also re-arranged code to drop size.     */
/* 11MAR90    "     "     Fixed problem with wildcards and interactive mode. */
/* 19MAY90    "     "     Verified bug free and FEATURE FROZEN! Modified     */
/*			    error message to reflect better phraseology.     */
/*			    Good ol' 1.0!                                    */
/* 23MAY90    "     "     Last second tweaks, ready to ship (I hope! F=3108) */
/* 24MAY90    "     "     Revamped error printing mechanism (F=3104)         */
/* 10JUL90    "     "     Fixed bugs precipitated by changes to V36.         */
/* 12JUL90    "     "     Enhanced operation to emulate the 1.3 Dir more     */
/*			    closely.  Switch to C 5.10.  (F=3104)            */
/* 31AUG90    "     "     Completed program by adding last second patches.   */
/*			    (Filesize = 3108)                                */
/* 11DEC90    "     "     Added code to test for circular links              */
/* 13DEC90    "     "     Patched bug in circular link code, handles empty   */
/*			    directories now!				     */
/* 30JAN91    "     "     Added ^C event robustness replacing routines that  */
/*			    was lost somehow in the shuffle and will not     */
/*			    stomp on low memory!			     */
/* 13APR91    "     "     Stepped back to more stable version and added some */
/*			    other bug fixes and the ability to show links.   */
/* 14APR91    "     "     Corrected esoteric collating bug.                  */
/* 26APR91  M. Taillefer  Corrected #? and <dir>/#? behavior                 */
/*									     */
/* Notes:								     */
/*   This code is being redesigned for 2.1.  There were some major problems  */
/*  found in the code pertaining to complex wildcard patterns.	There has    */
/*  not been any solution to the problem found by anyone that the problem    */
/*  was described to.  Fortunately, the problem is relatively rare.	     */
/*---------------------------------------------------------------------------*/

/* Options */
#define SEE_LINKS  1   /* shows when an entry is a link and what type */

#include "internal/commands.h"
#include "dir_rev.h"

#include "fctype.h"

/*===============================================================*/
/* These string definitions below are close to the BCPL version. */
/*===============================================================*/
#define MSG_OPTION_IGNORED   " option ignored\n"
#define MSG_OUT_OF_MEM_INC   "List incomplete - "
#define MSG_NOT_A_DIR	     "%s is not a directory\n"
#define MSG_DELETED	     "Deleted\n"
#define MSG_COMMAND_PROMPT   "\nCommand ? "
#define MSG_INVALID_RESPONSE "Invalid response - try again\n"
#define MSG_NO_INFO_FOR      "Could not get information for %s\n"
#define MSG_CIRCULAR_DIR     "Error, circular directory entry found\n"

/*===============================================*/
/* Template for the main section of the command. */
/*===============================================*/
#define TEMPLATE	  "DIR,OPT/K,ALL/S,DIRS/S,FILES/S,INTER/S" CMDREV
#define OPT_DIR 	  0
#define OPT_OPT 	  1
#define OPT_ALL 	  2
#define OPT_DIRS	  3
#define OPT_FILES	  4
#define OPT_INTER	  5
#define OPT_COUNT	  6

/*====================================================================*/
/* Template for the interactive mode when examining a file, not a dir */
/*====================================================================*/
#define INTER_FILE_TEMPLATE \
	"T=TYPE/S,B=BACK/S,DEL=DELETE/S,Q=QUIT/S,C=COM/S,COMMAND"

/*====================================================================*/
/* Template for the interactive mode when examining a dir, not a file */
/*====================================================================*/
#define INTER_DIR_TEMPLATE \
	"E=ENTER/S,B=BACK/S,DEL=DELETE/S,Q=QUIT/S,C=COM/S,COMMAND"

#define OPT_INTER_ENTER_TYPE  0    /* behold the reusable flag! */
#define OPT_INTER_BACK	      1
#define OPT_INTER_DELETE      2
#define OPT_INTER_QUIT	      3
#define OPT_INTER_COM	      4
#define OPT_INTER_COMMAND     5
#define INTER_COUNT	      6

/*==============================================================*/
/* Flag definitions below apply to the global.optflags variable */
/*==============================================================*/
#define ALL_FLAG	  1
#define DIRS_FLAG	  2
#define FILES_FLAG	  4
#define INTER_FLAG	  8
#define OPT_BACK_FLAG	  16
#define OPT_ENTER_FLAG	  32
#define OPT_QUIT_FLAG	  64
#define REPEAT_ENTRY_FLAG 128
#define DELETE_DIR_FLAG   256

/*==================*/
/* General defines  */
/*==================*/
#define NO_ERROR	  0
#define BREAKBITS	  (SIGBREAKF_CTRL_C)
#define FILENAME_SIZE	  32
#define FILEPATH_SIZE	  128
#define BUFFER_SIZE	  2048
#define TEMPVECTOR_SIZE   5
#define TYPE_DIR	  0
#define TYPE_FILE	  1
#define EXEC_BUFF_SIZE	  128

/*====================*/
/* Private structures */
/*======================================================================*/
/* This structure forms a linked list of filenames for sorting purposes */
/*======================================================================*/
struct FNameList {
  struct FNameList *fnl_next;        /* must be first field in structure due to sorting algorithm */
  LONG		    fnl_filetype;
  char		    fnl_name[FILENAME_SIZE];
};

/*==============================================================*/
/* This structure makes it possible to check for circular links */
/* Added: bmd 12/10/90						*/
/*==============================================================*/
struct Lookback {
  struct Lookback *next;
  BPTR		   lock;
};

/*==========================================================*/
/* This structure gives us the facility of global variables */
/* while keeping the code pure and resident-able.	    */
/*==========================================================*/
struct Global {
  struct Library    *SysBase;
  struct DOSLibrary *DOSBase;
  struct AnchorPath ap;
  LONG		    optflags;
  LONG		    errorcode;
  LONG		    returncode;
  LONG		    opts[OPT_COUNT];
  UBYTE 	    *buffer;
  UBYTE 	    filename[FILEPATH_SIZE];
  UBYTE 	    fntemp[2][FILEPATH_SIZE];
  LONG		    tempvector[TEMPVECTOR_SIZE];
  struct FNameList  *fnametemp,
		    *fnamewalk,
		    *fnameprev;
  struct Lookback   *lookwalk;
};

/*=======================*/
/*  Function Prototypes  */
/*=======================*/
void do_dir(struct Global *, int, struct Lookback *);
void dointeract(struct Global *, BPTR, int);
int vsprintf(char *, char *, long []);

#pragma syscall RawDoFmt 20a ba9804
extern void __builtin_emit(UWORD);
static void __regargs prbuf(char c);


/*=============================================================*/
/*********************** Main program **************************/
/*=============================================================*/
int cmd_dir(void)
{
  struct Library    *SysBase = (*((struct Library **) 4));
  struct DOSLibrary *DOSBase;
  struct Global      global;
  struct RDArgs     *argsptr;
  UBYTE 	    *text;

  /*===========================================================*/
  /* Initialize global data structure and return code variable */
  /*===========================================================*/
  memset((char *)&global, 0, sizeof(struct Global));
  global.SysBase = SysBase;		/* Added: bmd 12/10/90 */
  global.returncode = RETURN_FAIL;
  global.errorcode = NO_ERROR;

  if ((DOSBase = (struct DosLibrary *)OpenLibrary(DOSLIB, DOSVER))) {

    global.DOSBase = DOSBase;

    /*==================================================================*/
    /* AllocVec changed to syntax of old AllocVecType().  I try to trap */
    /* ALL instances of memory allocation failures. buffer is just some */
    /* general work space for building strings and stuff like that.	*/
    /*==================================================================*/
    if (!(global.buffer = AllocVec(BUFFER_SIZE, MEMF_CLEAR | MEMF_PUBLIC))) {
      global.errorcode = IoErr();
    }
    else {

      /*==================================================================*/
      /* If ReadArgs() sees anything but zeros passed to it in elements   */
      /* of this array, ReadArgs() will assume that they are defaults.    */
      /*==================================================================*/
      argsptr = ReadArgs(TEMPLATE, global.opts, NULL);

      /*=================================================================*/
      /* argsptr will be NULL if ReadArgs() failed, the secondary result */
      /* code is fetched by IoErr().                                     */
      /*=================================================================*/
      if (argsptr == NULL) global.errorcode = IoErr();
      else {

	/*=================================================================*/
	/* We need to check various OPT options.  We build the		   */
	/* global.optflags variable here to reflect user specified options */
	/* and set our defaults. No check is made for mutual exclusion.    */
	/*=================================================================*/
	if (global.opts[OPT_OPT] != NULL) {
	  text = (char *)global.opts[OPT_OPT];
	  while (*text) {

	    switch(*text++)
	    {
	      case 'i': case 'I':       /**** Interactive ***/
		global.opts[OPT_INTER] = 1;
		break;

	      case 'a': case 'A':       /**** All ***********/
		global.opts[OPT_ALL]   = 1;
		break;

	      case 'd': case 'D':       /**** Dirs only *****/
		global.opts[OPT_DIRS]  = 1;
		break;

	      case 'f': case 'F':       /**** Files only ****/
		global.opts[OPT_FILES] = 1;
		break;

	      default:
		/*======================================================*/
		/* Should get here only if an invalid option was found. */
		/*======================================================*/
		FPutC(Output(), text[-1]);
		PutStr(MSG_OPTION_IGNORED);
		break;
	    }
	  }
	}

	/*=============================================*/
	/* Set global flags based on specified options */
	/*=============================================*/
	if (global.opts[OPT_ALL])    global.optflags |= ALL_FLAG;
	if (global.opts[OPT_INTER])  global.optflags |= INTER_FLAG;
	if (global.opts[OPT_FILES])  global.optflags |= FILES_FLAG;
	if (global.opts[OPT_DIRS])   global.optflags |= DIRS_FLAG;

	/*===================*/
	/* Set flag defaults */
	/*===================*/
	if (global.opts[OPT_FILES] == 0 && global.opts[OPT_DIRS] == 0)
	  global.optflags |= DIRS_FLAG | FILES_FLAG;

	/*===========================================================*/
	/* Initialize AnchorPath flags that Match...() need to do    */
	/* the directory scan.	We always assume we want to do	     */
	/* wildcard analysis and CTRL-C trapping.		     */
	/*===========================================================*/
	global.ap.ap_BreakBits = BREAKBITS;
	global.ap.ap_Flags = APF_DOWILD;

	/*================================================================*/
	/* MatchFirst() doesn't like a NULL passed to it as the first     */
	/* parameter.  Since ReadArgs() returns to us a NULL instead of   */
	/* a pointer to a NULL when the user does not specify any dir, we */
	/* must make a pointer to a NULL.  Otherwise, MatchFirst() dies.  */
	/* This cures several bugs reported to CBM, fixed on 06JAN90.	  */
	/*================================================================*/
	if (global.opts[OPT_DIR] == NULL) global.opts[OPT_DIR] = (LONG)"";

	/*===================================================================*/
	/* Here is the only MatchFirst() call.  MatchFirst() does several    */
	/* things: 1) initializes the AnchorPath structure, 2) checks	     */
	/* wildcard status on the input dirname (which can be a NULL to      */
	/* indicate the desire to scan the current directory), 3) returns to */
	/* us things like FileInfoBlocks and a lock the filename is relative */
	/* to. It returns a ZERO (NULL) to indicate success, otherwise the   */
	/* error codes match those in ...dos.h and ...dosasl.h. 	     */
	/* See ...dosasl.h for more.					     */
	/*===================================================================*/
	if (MatchFirst((char *)global.opts[OPT_DIR], &global.ap)) {
	  global.errorcode = IoErr();
	  if( (global.errorcode != ERROR_BREAK) &&
	      !(global.ap.ap_Flags & APF_ITSWILD) )
	    VPrintf(MSG_NO_INFO_FOR, &global.opts[OPT_DIR]);
	}
	else
	{
	  /*================================================================*/
	  /* Check to see if we examined a directory or not.  If we are not */
	  /* processing wildcards and if the examine revealed a file, we    */
	  /* can't go any further.                                          */
	  /*================================================================*/
	  if ((global.ap.ap_Info.fib_DirEntryType < 0) &&
	      (!(global.ap.ap_Flags & APF_ITSWILD)))
	  {
	    global.errorcode = ERROR_DIR_NOT_FOUND;
	    VPrintf(MSG_NOT_A_DIR, &global.opts[OPT_DIR]);
	  }
	  else
	  {
	    /*=========================================*/
	    /* Go and get the directory or directories */
	    /*=========================================*/
	    global.ap.ap_Flags &= ~APF_DIDDIR;
	    do_dir(&global, 0, NULL);
	  }
	}  /*====== end if MatchFirst() =====*/

	/*========================================================*/
	/* This function cleans up the AnchorPath structure list. */
	/*========================================================*/
	MatchEnd(&global.ap);

	/*=================================================================*/
	/* Always call FreeArgs() after successfully calling ReadArgs() to */
	/* recover any allocated memory and to perform cleanup functions.  */
	/*=================================================================*/
	FreeArgs(argsptr);
      }

      FreeVec(global.buffer);
    }
    /*==============*/
    /* Cleanup code */
    /*==============*/
    if ((global.errorcode != NO_ERROR)) {

      /*=============================================================*/
      /* The only time we print an error message is when we have an  */
      /* error other than ERROR_NO_MORE_ENTRIES. We suppress setting */
      /* Result2 if we have ERROR_BREAK.			     */
      /*=============================================================*/
      if (global.errorcode != ERROR_BREAK)
	SetIoErr(global.errorcode);

      if (global.errorcode != ERROR_NO_MORE_ENTRIES)
	PrintFault(global.errorcode, NULL);
    }
    CloseLibrary((struct Library *)DOSBase);
  }
  else { OPENFAIL; }
  return(global.returncode);
}


/*================================================================*/
/*  Function: do_dir()                                            */
/*   Purpose: provide a routine to gather and display directories */
/*	      in a recursive manner.				  */
/*================================================================*/

/*=============================================*/
/* Special #defines for library base pointers. */
/* Used as substitutes for clarity of code.    */
/*=============================================*/
#define SysBase     global->SysBase
#define DOSBase     global->DOSBase
#define tempvector  global->tempvector
#define fnametemp   global->fnametemp
#define fnamewalk   global->fnamewalk
#define fnameprev   global->fnameprev

void do_dir(struct Global *global, int reclvl, struct Lookback *lookback)
{
  struct FNameList    *fnamehead = NULL;
  struct Lookback      previous;
  int		       rc,
		       matchrc,
		       column;
  BPTR		       dirlock = NULL,
		       lock;

  /*================================================*/
  /* Properly assign DOSBase to keep our code pure. */
  /*================================================*/
  global->returncode = RETURN_FAIL;
  matchrc = 0;
  previous.next = lookback;

  /*========================================================================*/
  /* Reset the flag that tells us to enter the next directory we encounter. */
  /*========================================================================*/
  global->optflags &= ~OPT_ENTER_FLAG;

  /*==============================================================*/
  /* Set up the flags and the loop for MatchNext(). If we have a  */
  /* directory, we have to perform a work around.  Normally, we   */
  /* set the APF_DODIR flag to tell Match...() to enter the       */
  /* directory. But we have to make the setting of the flag	  */
  /* conditional on if MatchFirst() returns a file or a dir.      */
  /*==============================================================*/
  if ((global->ap.ap_Info.fib_DirEntryType > 0)) {

    if (!((reclvl == 0) && (global->ap.ap_Flags & APF_ITSWILD)))
    {
      global->ap.ap_Flags |= APF_DODIR;
      matchrc = MatchNext(&global->ap);
    }
  }

  /*===================================================================*/
  /* To facilitate maintaining a lock on the current parent directory, */
  /* we copy the parent lock.  Match...() generates this and we need   */
  /* to save this lock for the interactive TYPE and DELETE commands.   */
  /* We are certain to have a lock by this time or this code will have */
  /* never executed to this point.				       */
  /* *** It became apparent that there is no need to execute this code */
  /* if matchrc is indicating anything other that complete success.    */
  /* The problem that arose is one of hitting ^C at just the right     */
  /* time, I was trying to duplock something that didn't exist!!       */
  /*===================================================================*/
  if((global->ap.ap_FoundBreak) & BREAKBITS)
  {
    matchrc = ERROR_BREAK;
    global->optflags = OPT_QUIT_FLAG;
  }

  if ( matchrc == NULL )        /* added/restored by bmd on 01/20/91 */
  {
    dirlock = DupLock(global->ap.ap_Current->an_Lock);

    /*====================================================================*/
    /* We need to check our list of directory locks to see if we have	  */
    /* already seen this directory entry.  If we have, we have a circular */
    /* hard/soft link (or a corrupt directory!).                          */
    /*====================================================================*/
    previous.lock = dirlock;
    previous.next = lookback;
    global->lookwalk = lookback;
    while (global->lookwalk)
    {
      if ( (SameLock(global->lookwalk->lock, dirlock) == LOCK_SAME) &&
	   !(global->ap.ap_Flags & APF_DIDDIR) )
      {
	PutStr(MSG_CIRCULAR_DIR);
	goto TimeToGo;
      }
      global->lookwalk = global->lookwalk->next;
    }
  }

  /*================================================================*/
  /* Everything should be ready to go at this point.  This while    */
  /* loop starts the section of the code which increments through   */
  /* a directory one file at a time.  There are many things to	    */
  /* check for as we go, but as long as matchrc == NULL, things are */
  /* A-OK.							    */
  /*================================================================*/
  while(matchrc == NULL) {

    /*==============================================================*/
    /* MatchNext() may return the flag APF_DIDDIR.  This shows that */
    /* it is done with this directory level.   This would seem	    */
    /* redundant with the flag ERROR_NO_MORE_ENTRIES, but we were   */
    /* getting returned to us an entry for the parent directory!    */
    /* We have to trap this.					    */
    /*==============================================================*/

    if (global->ap.ap_Flags & APF_DIDDIR)
    {
      global->ap.ap_Flags &= ~APF_DIDDIR;
      matchrc = ERROR_NO_MORE_ENTRIES;
      break;
    }

    if((global->ap.ap_FoundBreak) & BREAKBITS) {
	matchrc = ERROR_BREAK;
	global->optflags = OPT_QUIT_FLAG;
	break;
    }

    /*=============================================================*/
    /* When we find a directory, print it unless printing is	   */
    /* suppressed. fib_DirEntryType > NULL indicates a directory. */
    /*=============================================================*/
    if ((global->optflags & DIRS_FLAG) &&
	(global->ap.ap_Info.fib_DirEntryType > 0)) {

      /*===================================================================*/
      /* When the user uses wildcards, we are to print the fully qualified */
      /* path with our dirname.  This way the user sees the context of the */
      /* directory files as the program sees it.			   */
      /*===================================================================*/
      if ( (global->ap.ap_Flags & APF_ITSWILD) && (reclvl == 0) ) /* 020491 */
      {
	NameFromLock( global->ap.ap_Current->an_Lock,
		      global->filename, FILEPATH_SIZE );
	AddPart(global->filename, global->ap.ap_Info.fib_FileName, FILEPATH_SIZE);
      }
      else
      {
	strncpy(global->filename, global->ap.ap_Info.fib_FileName, FILEPATH_SIZE);
      }

      /*======================================================*/
      /* set up indentation (brute force!) and print the name */
      /*======================================================*/
      tempvector[0] = (reclvl + 1) * 5;
      tempvector[1] = (LONG)global->filename;
#ifdef SEE_LINKS
      if (global->ap.ap_Info.fib_DirEntryType == ST_LINKDIR)
	tempvector[2] = (LONG)"(dir) <hl>";
      else
#endif
	tempvector[2] = (LONG)"(dir)";
      vsprintf(global->buffer, "%%%lds%%s %%s", tempvector);
      tempvector[0] = (LONG)" ";

      /*=========================================================*/
      /* If we are in interactive mode, call dointeract(), else  */
      /* we tack on a newline to our freshly printed dirname.	 */
      /*=========================================================*/
      if (global->optflags & INTER_FLAG) {

	/*========================================================*/
	/* Basically, dointeract() prompts after the filename and */
	/* performs actions based on its template.  Return codes  */
	/* appear in global->optflags and global->returncode. The */
	/* REPEAT_ENTRY_FLAG is to support the dointeract() call  */
	/* and redisplay the filename depending on which command  */
	/* the user typed.					  */
	/*========================================================*/
	global->optflags |= REPEAT_ENTRY_FLAG;
	while(global->optflags & REPEAT_ENTRY_FLAG)
	{
	  /*======================================================*/
	  /* Print the filename and perform interactive functions */
	  /*======================================================*/
	  VPrintf(global->buffer, tempvector);
	  VPrintf(" ? ", NULL);
	  dointeract(global, NULL, TYPE_DIR);
	}
	/*=========================================================*/
	/* OPT_BACK_FLAG signals that the user wishes to come back */
	/* one level shallower in the directory tree structure.    */
	/*=========================================================*/
	if (global->optflags & OPT_BACK_FLAG)
	{
	  /*=====================================*/
	  /* Reset the flag and exit this level. */
	  /*=====================================*/
	  global->optflags &= ~OPT_BACK_FLAG;
	  break;
	}

	/*===========================================================*/
	/* OPT_QUIT_FLAG signals the user's desire to hit the road.  */
	/* We have to preserve this flag so we can quit cleanly from */
	/* any level. We also quit out if we have a major error.     */
	/*===========================================================*/
	if ((global->optflags & OPT_QUIT_FLAG) ||
	    (global->returncode == RETURN_FAIL))
	  goto TimeToGo;
      }
      else
      {
	/*====================================*/
	/* Just print and terminate the line. */
	/*====================================*/
	VPrintf(global->buffer, tempvector);
	PutStr("\n");
      }
    }

    /*====================================================================*/
    /*	 Under 1.3, if the user types a command such as "Dir RAM:#?", the */
    /* user will see the contents of the top 2 levels of RAM:.	I need	  */
    /* to check for all the conditions to emulate this behaviour.	  */
    /*====================================================================*/

    /*====================================================================*/
    /* 26APR91 - Put this code in comment. 1.3 behavior was wrong.        */
    /*           "Dir RAM:#?" now only shows files and dirs in the root   */
    /*           of RAM: and doesn't enter unless ALL is specified        */
    /*====================================================================*/
/*
    if ( !(global->optflags & ALL_FLAG) &&
	  (reclvl < 1) &&
	  (global->ap.ap_Flags & APF_ITSWILD) &&
	  (global->ap.ap_Info.fib_DirEntryType >= 0))
    {
      global->optflags |= OPT_ENTER_FLAG;
    }
*/

    /*===============================================================*/
    /* If the user specified the ALL keyword (or OPT A) then we need */
    /* to take the just printed dirname and use it to send to the    */
    /* do_dir() function recursively. It is possible to enter sub-   */
    /* directories even if we specified not to display them!	     */
    /*===============================================================*/
    if ((global->optflags & (ALL_FLAG | OPT_ENTER_FLAG)) &&
	(global->ap.ap_Info.fib_DirEntryType >= 0))
    {
      /*===========================================================*/
      /* Make the call to get the subdirectory. Add 1 to reclvl to */
      /* keep track of the recursion level for proper indentation. */
      /*===========================================================*/
      do_dir(global, reclvl + 1, &previous);

      /*==================================================================*/
      /* MatchNext() returns the flag APF_DIDDIR if it finished examining */
      /* a directory.  We need to reset it at this point because our code */
      /* will exit prematurely if we don't!                               */
      /*==================================================================*/
      global->ap.ap_Flags &= ~APF_DIDDIR;

      /*=================================================================*/
      /* The program may have had an error, or the user may want to quit */
      /* the program.  Either way, we exit the same.			 */
      /*=================================================================*/
      if ((global->optflags & OPT_QUIT_FLAG) ||
	  (global->returncode == RETURN_FAIL))
	goto TimeToGo;
    }

    /*==========================================================*/
    /* If we have a file and we want to print files, we need to */
    /* store the filenames in sorted order for later printing.	*/
    /*==========================================================*/
    if((global->optflags & FILES_FLAG) &&
       (global->ap.ap_Info.fib_DirEntryType < 0)) {

      /*==========================================*/
      /* First, we need to allocate the new node. */
      /*==========================================*/
      fnametemp = AllocVec(sizeof(struct FNameList),
			   MEMF_CLEAR | MEMF_PUBLIC);
      if (fnametemp == NULL)
      {
	/*=======================================*/
	/* If we have very little memory left... */
	/*=======================================*/
	global->errorcode = IoErr();
	PutStr(MSG_OUT_OF_MEM_INC);
	break;
      }

      /*=========================================*/
      /* Initialize the new node filename field. */
      /*=========================================*/
      strncpy(fnametemp->fnl_name, global->ap.ap_Info.fib_FileName, FILENAME_SIZE);
      fnametemp->fnl_filetype = global->ap.ap_Info.fib_DirEntryType;

      /* Insert the new node in alphabetical order within the list of names */
      fnameprev = &fnamehead;
      fnamewalk = fnamehead;
      while (fnamewalk)
      {
          if (stricmp(fnamewalk->fnl_name,fnametemp->fnl_name) > 0)
          {
              fnametemp->fnl_next = fnameprev->fnl_next;
              fnameprev->fnl_next = fnametemp;
              break;
          }
          fnameprev = fnamewalk;
          fnamewalk = fnamewalk->fnl_next;
      }

      if (!fnamewalk)
           fnameprev->fnl_next = fnametemp;

    } /*===== End if(isn't a dir). =====*/

    /*========================================*/
    /* We are ready to examine the next item. */
    /*========================================*/
    matchrc = MatchNext(&global->ap);

    /*============================================================*/
    /* The reason we delete our directory here is because of the  */
    /* need to work around an anomoly in the Match...() routines. */
    /* It seems that if we delete a file or directory out from	  */
    /* under the Match...() functions, we invite a visit from the */
    /* GURU.  NOTE: This workaround was unnecessary with ARP!	  */
    /* We have to have done our next MatchNext() to preserve the  */
    /* integrity of the AnchorPath state variables.		  */
    /*============================================================*/
    if (global->optflags & DELETE_DIR_FLAG)
    {
      lock = CurrentDir(dirlock);
      if (!DeleteFile(global->filename))
      {
	PrintFault(IoErr(), NULL);      /* fixed 11OCT90, err msg bug */
      }
      else
      {
	PutStr(MSG_DELETED);
      }
      CurrentDir(lock);
      global->optflags &= ~DELETE_DIR_FLAG;
    }

  } /*===== End while(!matchrc), the main examination loop. =====*/

  /*========================================*/
  /* Check return codes for control breaks. */
  /*========================================*/
  if (matchrc == ERROR_BREAK)
  {
    global->errorcode = ERROR_BREAK;
    global->returncode = RETURN_WARN;
    global->optflags = OPT_QUIT_FLAG;
    goto TimeToGo;
  }

  /*===============================================================*/
  /* When the user has specified QUIT in the interactive mode,	   */
  /* we need to skirt around code which is unnecessary to execute. */
  /*===============================================================*/
  if (global->optflags & OPT_QUIT_FLAG)
  {
    goto TimeToGo;
  }

  /*===============================================*/
  /* A real error occurred if this check succeeds! */
  /*===============================================*/
  if (matchrc != ERROR_NO_MORE_ENTRIES)
  {
    global->errorcode = IoErr();
  }

  global->returncode = RETURN_OK;	/* (probable) successful execution */


  /*============================================================*/
  /* This hack attempts to fix one of the wildard problems with */
  /* the Match...() calls. I am looking for a real fix, as this */
  /* is broken for certain patterns.				*/
  /*============================================================*/

  /*=======================================================================*/
  /* 26APR91 - put this code in comment, we want behavior consistent with  */
  /*	       the List command                                            */
  /*=======================================================================*/
/*
  if ( !((reclvl == 0) && strchr( (char *)global->opts[OPT_DIR], '/') &&
	 global->ap.ap_Flags & APF_ITSWILD) )
  {
*/
    /*=============================================================*/
    /* Printout routine. This takes a list and prints it unless we */
    /* have suppressed the printing of the filenames.		   */
    /*=============================================================*/
    fnametemp = fnamehead;
    tempvector[2] = NULL;
    column = 1;
    while (fnametemp && (!global->returncode))
    {
      /*======================================================*/
      /* Check for the INTER keyword..	We indent differently */
      /* when in the interactive mode.			      */
      /*======================================================*/
      if (global->optflags & INTER_FLAG)
      {
	/*====================*/
	/* Set up indentation */
	/*====================*/
	tempvector[0] = (reclvl * 5) + 2;
	tempvector[1] = (LONG)fnametemp->fnl_name;
	tempvector[2] = (LONG)"";
#ifdef SEE_LINKS
	if (fnametemp->fnl_filetype == ST_LINKFILE)
	  tempvector[2] = (LONG)" <hl>";
	if (fnametemp->fnl_filetype == ST_SOFTLINK)
	  tempvector[2] = (LONG)" <sl>";
#else
	tempvector[2] = (LONG)"";
#endif
	vsprintf(global->buffer, "%%%lds%%s%%s", tempvector);
	tempvector[0] = (LONG)" ";

	/*======================================================*/
	/* Support for repeating the printing of the filename	*/
	/* after certain commands in the dointeract() function. */
	/*======================================================*/
	global->optflags |= REPEAT_ENTRY_FLAG;
	strncpy(global->filename, fnametemp->fnl_name, FILEPATH_SIZE);
	while(global->optflags & REPEAT_ENTRY_FLAG)
	{
	  VPrintf(global->buffer, tempvector);
	  VPrintf(" ? ", NULL);
	  dointeract(global, dirlock, TYPE_FILE);
	}

	/*=========================================*/
	/* Check on flags returned by dointeract() */
	/*=========================================*/
	if (global->optflags & OPT_BACK_FLAG)
	{
	  global->optflags &= ~OPT_BACK_FLAG;
	  goto TimeToGo;
	}
	if ((global->optflags & OPT_QUIT_FLAG))
	{
	  goto TimeToGo;
	}
      }
      else
      {
	/*===================*/
	/* Give user an out! */
	/*===================*/
	if (CheckSignal(BREAKBITS))
	{
	  global->optflags = OPT_QUIT_FLAG;
	  global->returncode = RETURN_WARN;
	  global->errorcode = ERROR_BREAK;
	  break;
	}

	/*=======================================================*/
	/* We are not interactive, so set up the indentation and */
	/* print the filenames in a two column format (for now). */
	/*=======================================================*/
	strncpy(global->fntemp[column&1], fnametemp->fnl_name, FILENAME_SIZE);
#ifdef SEE_LINKS
	if (fnametemp->fnl_filetype == ST_LINKFILE)
	  strcat(global->fntemp[column&1], " <hl>");
	if (fnametemp->fnl_filetype == ST_SOFTLINK)
	  strcat(global->fntemp[column&1], " <sl>");
#endif
	tempvector[column] = (LONG)global->fntemp[column&1];
	column = 3 - column;
	if ((column == 1) || (fnametemp->fnl_next == NULL))
	{
	  tempvector[0] = (reclvl * 5) + 2;
	  vsprintf(global->buffer, "%%%lds%%-31s  %%s\n", tempvector);
	  tempvector[0] = (LONG)" ";
	  VPrintf(global->buffer, tempvector);
	  tempvector[2] = NULL;
	}
      }

      /*================*/
      /* Walk the list. */
      /*================*/
      fnametemp = fnametemp->fnl_next;
/*
    }
*/
  }  /*===== End of if(matchrc). End of file printing routine =====*/

  /*=============================================================*/
  /* TimeToGo is a place that the code can jump to IF an exit	 */
  /* is in order.  All cleanup functions are assured to execute. */
  /*=============================================================*/

TimeToGo:
  /*==============================*/
  /* File Name List cleanup code. */
  /*==============================*/
  while (fnamehead != NULL)
  {
    fnametemp = fnamehead->fnl_next;
    FreeVec(fnamehead);
    fnamehead = fnametemp;
  }
  if (dirlock) UnLock(dirlock);
}


/*======================================================================*/
/*  Function:  dointeract()                                             */
/*   Purpose:  This function does our interactive functions for us.	*/
/*	       Since the context is single file oriented, we just need	*/
/*	       to pass the filename.					*/
/*======================================================================*/

void dointeract(struct Global *global, BPTR parent, int filetype)
{
  struct RDArgs      *argsptr;
  UBYTE 	     *execbuff;
  LONG		      opts[INTER_COUNT];
  char		      chr[1];
  BPTR		      fileptr,
		      lock;

  /*===========================*/
  /* Initialize main variables */
  /*===========================*/
  global->returncode = RETURN_OK;
  global->optflags |= REPEAT_ENTRY_FLAG;
  memset(&opts, 0, sizeof(opts));

  Flush(Output());

  /*===================================*/
  /* Allocate memory for general usage */
  /*===================================*/
  if (
      !(execbuff = AllocVec(EXEC_BUFF_SIZE, MEMF_CLEAR | MEMF_PUBLIC))
     )
  {
    /*=============================*/
    /* If our allocation failed... */
    /*=============================*/
    global->errorcode = IoErr();
    PutStr(MSG_OUT_OF_MEM_INC);
    global->returncode = RETURN_FAIL;
  }
  else
  {
    /*=====================================================*/
    /* If our memory is allocated, get our args from StdIn */
    /*=====================================================*/
    if (filetype == TYPE_DIR)
    {
      /*===============================================*/
      /* If the name is a directory, use this template */
      /*===============================================*/
      argsptr = ReadArgs(INTER_DIR_TEMPLATE, opts, 0);
    }
    else
    {
      /*==================================================*/
      /* If the name is a file, use this template instead */
      /*==================================================*/
      argsptr = ReadArgs(INTER_FILE_TEMPLATE, opts, 0);
    }

    /*===================================*/
    /* Check to see if ReadArgs() failed */
    /*===================================*/
    if (argsptr == NULL)
    {
      global->errorcode = IoErr();
      global->returncode = RETURN_FAIL;
    }
    else
    {
      /*====================*/
      /*  Type file routine */
      /*====================*/
      if (opts[OPT_INTER_ENTER_TYPE] && (filetype == TYPE_FILE))
      {
	/*===================*/
	/* Open file to type */
	/*===================*/
	lock = CurrentDir(parent);
	if (!(fileptr = Open(global->filename, MODE_OLDFILE)))
	{
	  global->errorcode = IoErr();
	  global->returncode = RETURN_FAIL;
	}
	else
	{
	  /*=========================================================*/
	  /* Loop through file, reading and then writing a character */
	  /*=========================================================*/
	  while ((*chr = FGetC(fileptr)) != -1)
	  {
	    /*===================*/
	    /* Give user an out! */
	    /*===================*/
	    if (CheckSignal(BREAKBITS))
	    {
	      PrintFault(ERROR_BREAK, NULL);
	      break;
	    }

	    /*================================*/
	    /* Output the character to stdout */
	    /*================================*/
	    WriteChars(chr, 1);
	  }

	  /*==================================================*/
	  /* Replace previous input filehandle and close file */
	  /*==================================================*/
	  Close(fileptr);
	}
	CurrentDir(lock);
	goto RepeatOut;
      }

      /*===================*/
      /* Command execution */
      /*===================*/
      if (opts[OPT_INTER_COM])  /*= user MUST specify C or COM =*/
      {
	if (opts[OPT_INTER_COMMAND])
	{
	  /*=====================================*/
	  /* Everything is ready, do the command */
	  /*=====================================*/
	  Execute((char *)opts[OPT_INTER_COMMAND], NULL, NULL);
	  PutStr("\n");
	  goto RepeatOut;
	}
	else
	{
	  /*=============================================================*/
	  /* Provide a command prompt for those who apparently need one! */
	  /*=============================================================*/
	  PutStr(MSG_COMMAND_PROMPT);
	  Flush(Output());

	  if(FGets(Input(), execbuff, BUFFER_SIZE))
	  {
		Execute(execbuff, NULL, NULL);
		PutStr("\n");
	  }
	  goto RepeatOut;
	}
      }
      else
      {
	/*===========================================================*/
	/* If the user typed gobbledygook, this traps it as an error */
	/* because any unknown syntax in the rest of the template    */
	/* will end up here!					     */
	/*===========================================================*/
	if (opts[OPT_INTER_COMMAND])
	{
	  PutStr(MSG_INVALID_RESPONSE);
	  goto RepeatOut;
	}
      }

      /*==============*/
      /* Quit routine */
      /*==============*/
      if (opts[OPT_INTER_QUIT])
      {
	global->optflags = OPT_QUIT_FLAG;
	goto NoRepeatOut;
      }

      /*========================*/
      /* Backup one dir routine */
      /*========================*/
      if (opts[OPT_INTER_BACK])
      {
	global->ap.ap_Flags |= APF_DIDDIR;
	global->optflags |= OPT_BACK_FLAG;
	goto NoRepeatOut;
      }

      /*=======================*/
      /* Enter one dir routine */
      /*=======================*/
      if (opts[OPT_INTER_ENTER_TYPE] && (filetype == TYPE_DIR))
      {
	global->optflags |= OPT_ENTER_FLAG;
	goto NoRepeatOut;
      }

      /*=====================*/
      /* Delete file routine */
      /*=====================*/
      if (opts[OPT_INTER_DELETE])
      {
	if (filetype == TYPE_FILE)
	{
	  /*============================================================*/
	  /* Set up to delete the file by setting the current directory */
	  /*============================================================*/
	  lock = CurrentDir(parent);
	  if(!DeleteFile(global->filename))
	  {
	    global->errorcode = IoErr();
	    global->returncode = RETURN_ERROR;
	  }
	  else
	  {
	    PutStr(MSG_DELETED);
	  }
	  CurrentDir(lock);
	}
	else  /*= filetype == TYPE_DIR =*/
	{
	  global->optflags |= DELETE_DIR_FLAG;
	}
	goto NoRepeatOut;
      }

      /*==================================================================*/
      /* Control reaches here if the user only pressed the return key or  */
      /* was "goto"d here.  We need to reset the repeat flag so we can go */
      /* to another file!						  */
      /*==================================================================*/
NoRepeatOut:

      /*==================================================================*/
      /* Reset the repeat flag because we want to go to the next filename */
      /*==================================================================*/
      global->optflags &= ~REPEAT_ENTRY_FLAG;

RepeatOut:

      /*====================================*/
      /* Clean up after the ReadArgs() call */
      /*====================================*/
      FreeArgs(argsptr);
    }

    /*===============================*/
    /* Give back the memory we used. */
    /*===============================*/
    FreeVec(execbuff);
  }
}


/*==============================================================*/
/* Function: prbuf						*/
/*  Purpose: The following stub routine is called from RawDoFmt */
/*	     for each character in the string.	At invocation,	*/
/*	     we have:						*/
/*		D0 - next character to be formatted		*/
/*		A3 - pointer to data buffer			*/
/*==============================================================*/
static void __regargs prbuf(char c)
{
  __builtin_emit(0x16c0);   /* move.b D0,(A3)+ */
}


/*====================================================================*/
/* Function: vsprintf						      */
/*  Purpose: This is a tiny implementation of sprintf.	Note that it  */
/*	     assumes that the buffer is large enough to hold any      */
/*	     formatted string you ask it to generate.		      */
/*====================================================================*/
int vsprintf(char *buf, char *ctl, long args[])
{
  RawDoFmt(ctl, args, prbuf, buf);
  return(strlen(buf));
}
@


1.27
log
@Changed #? and <dir>/#? behavior to be like LIST command
@
text
@a85 1
#define MSG_DUP_FILENAME     "Duplicate filename found\n"
d157 1
a157 1
  struct FNameList *fnl_next;
d695 13
a707 13
      /*============================================================*/
      /* I am using a modified sequential insertion sort routine.   */
      /* Such as it is, it's close to the performance of qsorting   */
      /* the filenames after reading them all in.  The difference   */
      /* is negligible in small directories and not bad for big     */
      /* ones.	fnamehead is the list head.			    */
      /*============================================================*/
      if (fnamehead == NULL) {

	/*==============================================================*/
	/* If the list is empty, we just create the head of the list.	*/
	/*==============================================================*/
	fnamehead = fnametemp;
a708 130
      else {

	/*========================================================*/
	/* We are ready for sorting the list. Initialize walking  */
	/* variables.						  */
	/*========================================================*/
	fnamewalk = fnamehead;
	fnameprev = NULL;

	/*=================================================*/
	/* This while(){} below controls the list walking. */
	/*=================================================*/
	while (fnamewalk)
	{
	  /*=======================================================*/
	  /* Speed the search by skipping all filenames till we    */
	  /* find a match for the first chrarcter. This saves many */
	  /* unneeded calls to stricmp().                          */
	  /*=======================================================*/
	  if (( toupper( fnamewalk->fnl_name[0] )) <    /* 041491 */
	      ( toupper( fnametemp->fnl_name[0] )))
	  {
	    /*===================================================*/
	    /* Walk the list keeping track of the previous node. */
	    /*===================================================*/
	    fnameprev = fnamewalk;
	    fnamewalk = fnamewalk->fnl_next;
	  }

	  /*========================================================*/
	  /* If we found the end of the list, back up to last valid */
	  /* node.						    */
	  /*========================================================*/
	  if (fnamewalk == NULL)
	    fnamewalk = fnameprev;

	  /*======================================================*/
	  /* Compare the filenames and test for duplicates. rc is */
	  /* either 1, 0, or -1 based on the comparison.	  */
	  /*======================================================*/

#ifdef CHECK_FOR_DUP
	  if ((rc = stricmp(fnamewalk->fnl_name,
			    fnametemp->fnl_name)) == 0)
	  {
#else
	  rc = stricmp(fnamewalk->fnl_name,fnametemp->fnl_name);
#endif

	    /*=====================================================*/
	    /* Oops, we have a duplicate filename!  This error	   */
	    /* was not trapped in the BCPL code.  Evidently the    */
	    /* directory was updated incorrectly making the chain  */
	    /* loop around to earlier elements.  I consider this   */
	    /* an error condition and break out of this mess.	   */
	    /*	  "It's worse than that, he's dead, Jim!"          */
	    /* EXCEPT THIS IS THE NORMAL CONDITION WITH PATHMAN... */
	    /*=====================================================*/

#ifdef CHECK_FOR_DUP
	    global->errorcode = ERROR_INVALID_COMPONENT_NAME;
	    PutStr(MSG_DUP_FILENAME);
	    global->returncode = RETURN_FAIL;
	    goto TimeToGo;
	  }
	  else
#endif

	  {
	    /*=====================================================*/
	    /* We havef ound the right place, put our new filename */
	    /* structure there.  rc is from the stricmp() above.   */
	    /*=====================================================*/
	    if (rc > 0)
	    {
	      /*===================================================*/
	      /* Make our current node the next after the new one. */
	      /*===================================================*/
	      fnametemp->fnl_next = fnamewalk;

	      /*=================================================*/
	      /* fnameprev points to where we came from last	 */
	      /* iteration of the while(fnamewalk).  It is NULL  */
	      /* the first time through when examining the head. */
	      /*=================================================*/
	      if (fnameprev == NULL)
	      {
		/*=====================================*/
		/* Place the new fnl node at the head. */
		/*=====================================*/
		fnamehead = fnametemp;
	      }
	      else
	      {
		/*=========================================*/
		/* Place the fnl structure at a certain    */
		/* location just before the filename which */
		/* has a greater ascii value than it does. */
		/*=========================================*/
		fnameprev->fnl_next = fnametemp;
	      }

	      /*========================================*/
	      /* We've done our insertion, so we leave. */
	      /*========================================*/
	      break;
	    }

	    /*===============================================*/
	    /* Make a new previous and increment to the next */
	    /* element in the list.			     */
	    /*===============================================*/
	    fnameprev = fnamewalk;
	    fnamewalk = fnamewalk->fnl_next;

	  }   /*===== End of else to stricmp(...) =====*/

	}  /*===== End while(fnamewalk) =====*/

	/*=================================================*/
	/* Check to see if we have gone through the entire */
	/* list and haven't been inserted.                 */
	/*=================================================*/
	if (rc < 0)
	{
	  /*==========================================*/
	  /* If such is the case, tack it on the end! */
	  /*==========================================*/
	  fnameprev->fnl_next = fnametemp;
	}
d710 2
a711 1
      } /*===== End else of if(fnamehead). End of the sort. =====*/
@


1.26
log
@Eliminated esoteric collating bug involving "{" and "_".  Updated source comments
@
text
@d64 1
d621 7
d635 1
d906 1
d912 6
d921 1
d1020 1
d1022 1
a1022 1

@


1.25
log
@Fixed bug that causes crash when filenames > 31 chars encountered (NFS) I think!
@
text
@d61 3
a63 3
/* 26FEB91    "     "     Ironed out the wildcard problems, source code is   */
/*			    cleaned up, should be ready to release!	     */
/* 17MAR91    "     "     Modified for coping with filenames > 31 chars.     */
d66 4
a69 1
/*   This code is being redesigned by me for 2.1.			     */
d72 3
d77 2
a78 1
#include <fctype.h>    /* added to get prototype for toupper() */
a82 1

a95 1

a140 1

d145 1
a145 1
#define BUFFER_SIZE	  2048	 /* Changed: from 1024, 17MAR91, bmd */
a152 2
/*====================*/

d332 2
a333 1
	  if(global.errorcode != ERROR_BREAK)
a363 1

a372 1

a535 3
#if 0
	NameFromLock(dirlock, global->filename, FILEPATH_SIZE);
#else
a537 1
#endif
d550 1
d554 1
d718 1
a718 2
	  /* unneeded calls to stricmp(). 'And'ing with 0xDF is    */
	  /* quicker (and dirtier) than the toupper() macro.       */
d720 2
a721 2
	  if ((fnamewalk->fnl_name[0] & 0xDF) < /* Change to the ToUpper */
	      (fnametemp->fnl_name[0] & 0xDF))  /* if it is ever ready!  */
d896 6
d926 1
d931 3
d980 2
a981 1
	strncpy(global->fntemp[column&1], fnametemp->fnl_name, FILEPATH_SIZE);
d986 1
d1193 1
a1193 1
      /*=======================*/
d1195 1
a1195 1
      /*=======================*/
a1293 1

@


1.24
log
@Added code to distinguish links from regular files and directories.
@
text
@d63 1
d141 1
a141 1
#define BUFFER_SIZE	  1024	 /* Changed: bmd, from 256, 12/10/90 */
d545 1
a545 1
	strcpy(global->filename, global->ap.ap_Info.fib_FileName);
d685 1
a685 1
      strcpy(fnametemp->fnl_name, global->ap.ap_Info.fib_FileName);
d934 1
a934 1
	strcpy(global->filename, fnametemp->fnl_name);
d972 1
a972 1
	strcpy(global->fntemp[column&1], fnametemp->fnl_name);
@


1.23
log
@Fixed #?/#?, cleaned up source.  (Bruce Drake 25-Feb-91)
@
text
@d12 1
a12 1
/* | .	| || the authors:			      BBS: (919) 382-8265    */
d16 1
a16 1
/*	       John Toebes     Mary Ellen Toebes  Doug Walker	Mike Witcher */
a67 5
/*===================================================================*/
/* This #define should be set to a 1 only if you wish to revert      */
/* this source code to the point where it was on the Beta 6 release. */
/*===================================================================*/

d140 2
a141 2
#define BUFFER_SIZE	     1024   /* Changed: bmd, from 256, 12/10/90 */
#define TEMPVECTOR_SIZE   4
d155 1
d182 2
a183 1
  LONG		tempvector[TEMPVECTOR_SIZE];
d185 3
a187 3
			      *fnamewalk,
			      *fnameprev;
  struct Lookback  *lookwalk;
d553 1
a553 1
	tempvector[2] = (LONG)"(dir hl)";
d685 1
d920 5
a924 4
	if (global->ap.ap_Info.fib_DirEntryType == ST_LINKFILE)
	  tempvector[2] = (LONG)" (hl)";
	else
	  tempvector[2] = (LONG)"";
d971 6
a976 1
	tempvector[column] = (LONG)fnametemp->fnl_name;
@


1.22
log
@Correct crashing with ^c on dir all
@
text
@d55 8
a62 1
/* 26OCT90   John Toebes  Corrected problems with ^C in MatchNext            */
d65 1
a65 2
/*	  Please refer to annotated diff output file called V36.Dir.Diff     */
/*	  accompanying this source for comments about recent changes.	     */
a72 3
#define  ANDY_MODS     0


d75 1
d89 1
d145 1
a145 1
#define BUFFER_SIZE	  256
d163 9
d177 1
d186 5
d196 1
a196 1
void do_dir(struct Global *, int);
d204 1
a215 4
#if ANDY_MODS
  LONG		       tempvector[TEMPVECTOR_SIZE];
#endif

d220 1
d332 2
a333 2
	  if(global.errorcode == ERROR_BREAK)PrintFault(global.errorcode,NULL);
	  else VPrintf(MSG_NO_INFO_FOR, &global.opts[OPT_DIR]);
d335 2
a336 52

#if ANDY_MODS
	else do {
	 if(global.errorcode == ERROR_BREAK) {
	   break;
	 }
	  /*================================================================*/
	  /* Check to see if we examined a directory or not.  If we are not */
	  /* processing wildcards and if the examine revealed a file, we    */
	  /* can't go any further.                                          */
	  /*================================================================*/
	  if ((global.ap.ap_Info.fib_DirEntryType < 0) &&
	      (!(global.ap.ap_Flags & APF_ITSWILD))) {
		global.errorcode = ERROR_DIR_NOT_FOUND;
		VPrintf(MSG_NOT_A_DIR, &global.opts[OPT_DIR]);
		global.returncode = RETURN_WARN;
	  }
	  else {

	    /*======================================================*/
	    /* set up indentation (brute force!) and print the name */
	    /*======================================================*/

		strcpy(global.filename, global.ap.ap_Info.fib_FileName);
		tempvector[0] = 2;
		tempvector[1] = (LONG)global.filename;

		if (global.ap.ap_Info.fib_DirEntryType >= 0) {
		   if ((global.ap.ap_Flags & APF_ITSWILD)) {
		       vsprintf(global.buffer, "%%%lds%%s (dir)\n", tempvector);
		       global.ap.ap_Flags &= ~APF_DIDDIR;
		       tempvector[0] = (LONG)" ";
		       VPrintf(global.buffer, tempvector);
		   }
	    /*=========================================*/
	    /* Go and get the directory or directories */
	    /*=========================================*/
		   do_dir(&global, 0);
		   global.ap.ap_Flags &= ~APF_DIDDIR;
		   if ((global.opts[OPT_INTER]) &&
			(global.optflags & OPT_QUIT_FLAG))break;
		}
		else {
		    vsprintf(global.buffer, "%%%lds%%s\n", tempvector);
		    tempvector[0] = (LONG)" ";
		    VPrintf(global.buffer, tempvector);
		}
	  }
	} while (!MatchNext(&global.ap));  /*===== end if MatchFirst() =====*/
#else
	else {

d354 1
a354 1
	    do_dir(&global, 0);
a356 1
#endif
d368 1
a368 2

	 FreeArgs(argsptr);
a371 1

d403 12
a414 1
void do_dir(struct Global *global, int reclvl)
d416 2
a417 6
  struct DosLibrary   *DOSBase;
  struct Library      *SysBase = (*((struct Library **) 4));
  struct FNameList    *fnamehead = NULL,
		      *fnametemp,
		      *fnamewalk,
		      *fnameprev;
d421 1
a421 1
  BPTR		       dirlock,
a422 1
  LONG		       tempvector[TEMPVECTOR_SIZE];
a426 1
  DOSBase = global->DOSBase;
d429 1
a429 2
  dirlock = NULL;

d443 1
a443 1
  if ((global->ap.ap_Info.fib_DirEntryType >= 0)) {
a444 1
#if !ANDY_MODS
a446 1
#endif
a448 1
#if !ANDY_MODS
a449 1
#endif
d458 4
d463 29
a491 2
  if (!matchrc)
     dirlock = DupLock(global->ap.ap_Current->an_Lock);
d519 1
d525 1
a525 1
    /* suppressed. fib_DirEntryType >= NULL indicates a directory. */
d528 1
a528 1
	(global->ap.ap_Info.fib_DirEntryType >= 0)) {
a529 1
#if !ANDY_MODS
d535 1
a535 1
      if (global->ap.ap_Flags & APF_ITSWILD)
d537 1
d539 4
a548 1
#endif
a552 3
#if ANDY_MODS
      strcpy(global->filename, global->ap.ap_Info.fib_FileName);
#endif
d555 5
a559 1
      vsprintf(global->buffer, "%%%lds%%s (dir)", tempvector);
a617 1
#if !ANDY_MODS
a629 1
#endif
d644 1
a644 1
      do_dir(global, reclvl + 1);
a652 1

a842 1
    if (matchrc) break;
a867 5
    if((global->ap.ap_FoundBreak) & BREAKBITS) {
	matchrc = ERROR_BREAK;
	break;
    }

d877 1
d897 4
a900 1
  else
a905 1
    global->returncode = RETURN_OK;   /* (probable) successful execution */
a919 3
#if ANDY_MODS
	tempvector[0] = ((reclvl+1) * 5) + 2;
#else
a920 1
#endif
d922 5
a926 1
	vsprintf(global->buffer, "%%%lds%%s", tempvector);
a975 3
#if ANDY_MODS
	  tempvector[0] = ((reclvl+1) * 5) + 2;
#else
a976 1
#endif
d1007 1
a1007 1
  UnLock(dirlock);
a1019 2
  struct Library     *SysBase = (*((struct Library **) 4));
  struct DosLibrary  *DOSBase;
a1020 1
/*		       *input; */
a1029 1
  DOSBase = global->DOSBase;
@


1.21
log
@Corrected enforcer problems with ^C in MatchNext()
@
text
@d459 1
@


1.20
log
@Correct deleting directories problem.  Message was not printed correctly.
@
text
@d55 1
d493 2
a494 1
  dirlock = DupLock(global->ap.ap_Current->an_Lock);
d844 1
@


1.19
log
@The real new version from John Toebes.
@
text
@d857 1
a857 2
	global->errorcode = IoErr();
	global->returncode = RETURN_ERROR;
@


1.18
log
@New version from John Toebes
@
text
@@


1.17
log
@you can now control-C out of ALL dirs
@
text
@d12 5
a16 5
/* | .  | || the authors:                             BBS: (919) 382-8265    */
/* | o  | ||   Dave Baker      Alan Beale         Jim Cooper                 */
/* |  . |//    Jay Denebeim    Bruce Drake        Gordon Keener              */
/* ======      John Mainwaring Andy Mercier       Jack Rouse                 */
/*             John Toebes     Mary Ellen Toebes  Doug Walker   Mike Witcher */
d20 7
a26 7
/* Command: Dir                                                              */
/* Author:  Bruce M. Drake                                                   */
/*                                                                           */
/* Change History:                                                           */
/*  Date    Person        Action                                             */
/* -------  ------------- -----------------                                  */
/* 06APR89  Bruce Drake   Initial Creation                                   */
d29 1
a29 1
/*                          possible with DOS 36                             */
d31 1
a31 1
/*                          registerized parameters                          */
d33 1
a33 1
/*                          but interactive mode needs work.                 */
d35 2
a36 2
/*                          code added. Problem with Match...() prevents     */
/*                          implementation until problems are resolved.      */
d38 1
a38 1
/*                          would call Version 0.9                           */
d41 1
a41 1
/*                          parameter parsing                                */
d43 1
a43 1
/*                          screen.  Also re-arranged code to drop size.     */
d46 2
a47 2
/*                          error message to reflect better phraseology.     */
/*                          Good ol' 1.0!                                    */
d50 9
a58 2
/*                                                                           */
/* Notes:                                                                    */
d61 8
d78 3
a80 3
#define MSG_DUP_FILENAME     "Duplicate filename - directory may be corrupt"
#define MSG_NOT_A_DIR        "%s is not a directory\n"
#define MSG_DELETED          "Deleted\n"
d89 8
a96 8
#define TEMPLATE          "DIR,OPT/K,ALL/S,DIRS/S,FILES/S,INTER/S" CMDREV
#define OPT_DIR           0
#define OPT_OPT           1
#define OPT_ALL           2
#define OPT_DIRS          3
#define OPT_FILES         4
#define OPT_INTER         5
#define OPT_COUNT         6
d102 1
a102 1
        "T=TYPE/S,B=BACK/S,DEL=DELETE/S,Q=QUIT/S,C=COM/S,COMMAND"
d108 1
a108 1
        "E=ENTER/S,B=BACK/S,DEL=DELETE/S,Q=QUIT/S,C=COM/S,COMMAND"
d111 1
a111 1
#define OPT_INTER_BACK        1
d113 2
a114 2
#define OPT_INTER_QUIT        3
#define OPT_INTER_COM         4
d116 1
a116 1
#define INTER_COUNT           6
d121 7
a127 7
#define ALL_FLAG          1
#define DIRS_FLAG         2
#define FILES_FLAG        4
#define INTER_FLAG        8
#define OPT_BACK_FLAG     16
#define OPT_ENTER_FLAG    32
#define OPT_QUIT_FLAG     64
d135 5
a139 4
#define NO_ERROR          0
#define BREAKBITS         (SIGBREAKF_CTRL_C)
#define FILENAME_SIZE     32
#define BUFFER_SIZE       256
d141 3
a143 3
#define TYPE_DIR          0
#define TYPE_FILE         1
#define EXEC_BUFF_SIZE    128
d154 1
a154 1
  char             fnl_name[FILENAME_SIZE];
d159 1
a159 1
/* while keeping the code pure and resident-able.           */
d164 6
a169 6
  LONG              optflags;
  LONG              errorcode;
  LONG              returncode;
  LONG              opts[OPT_COUNT];
  UBYTE             *buffer;
  UBYTE             filename[FILENAME_SIZE];
d192 1
a192 2
  UBYTE             *text;
  LONG                 tempvector[TEMPVECTOR_SIZE];
d194 4
d212 1
a212 1
    /* general work space for building strings and stuff like that.     */
d232 81
a312 81
        /*=================================================================*/
        /* We need to check various OPT options.  We build the             */
        /* global.optflags variable here to reflect user specified options */
        /* and set our defaults. No check is made for mutual exclusion.    */
        /*=================================================================*/
        if (global.opts[OPT_OPT] != NULL) {
          text = (char *)global.opts[OPT_OPT];
          while (*text) {

            switch(*text++)
            {
              case 'i': case 'I':       /**** Interactive ***/
                global.opts[OPT_INTER] = 1;
                break;

              case 'a': case 'A':       /**** All ***********/
                global.opts[OPT_ALL]   = 1;
                break;

              case 'd': case 'D':       /**** Dirs only *****/
                global.opts[OPT_DIRS]  = 1;
                break;

              case 'f': case 'F':       /**** Files only ****/
                global.opts[OPT_FILES] = 1;
                break;

              default:
                /*======================================================*/
                /* Should get here only if an invalid option was found. */
                /*======================================================*/
                FPutC(Output(), text[-1]);
                PutStr(MSG_OPTION_IGNORED);
                break;
            }
          }
        }

        /*=============================================*/
        /* Set global flags based on specified options */
        /*=============================================*/
        if (global.opts[OPT_ALL])    global.optflags |= ALL_FLAG;
        if (global.opts[OPT_INTER])  global.optflags |= INTER_FLAG;
        if (global.opts[OPT_FILES])  global.optflags |= FILES_FLAG;
        if (global.opts[OPT_DIRS])   global.optflags |= DIRS_FLAG;

        /*===================*/
        /* Set flag defaults */
        /*===================*/
        if (global.opts[OPT_FILES] == 0 && global.opts[OPT_DIRS] == 0)
          global.optflags |= DIRS_FLAG | FILES_FLAG;

        /*===========================================================*/
        /* Initialize AnchorPath flags that Match...() need to do    */
        /* the directory scan.  We always assume we want to do       */
        /* wildcard analysis and CTRL-C trapping.                    */
        /*===========================================================*/
        global.ap.ap_BreakBits = BREAKBITS;
        global.ap.ap_Flags = APF_DOWILD;

        /*================================================================*/
        /* MatchFirst() doesn't like a NULL passed to it as the first     */
        /* parameter.  Since ReadArgs() returns to us a NULL instead of   */
        /* a pointer to a NULL when the user does not specify any dir, we */
        /* must make a pointer to a NULL.  Otherwise, MatchFirst() dies.  */
        /* This cures several bugs reported to CBM, fixed on 06JAN90.     */
        /*================================================================*/
        if (global.opts[OPT_DIR] == NULL) global.opts[OPT_DIR] = (LONG)"";

        /*===================================================================*/
        /* Here is the only MatchFirst() call.  MatchFirst() does several    */
        /* things: 1) initializes the AnchorPath structure, 2) checks        */
        /* wildcard status on the input dirname (which can be a NULL to      */
        /* indicate the desire to scan the current directory), 3) returns to */
        /* us things like FileInfoBlocks and a lock the filename is relative */
        /* to. It returns a ZERO (NULL) to indicate success, otherwise the   */
        /* error codes match those in ...dos.h and ...dosasl.h.              */
        /* See ...dosasl.h for more.                                         */
        /*===================================================================*/
        if (MatchFirst((char *)global.opts[OPT_DIR], &global.ap)) {
          global.errorcode = IoErr();
d314 5
a318 3
          else VPrintf(MSG_NO_INFO_FOR, &global.opts[OPT_DIR]);
        }
        else do {
d320 1
a320 1
	break;
d322 12
a333 12
          /*================================================================*/
          /* Check to see if we examined a directory or not.  If we are not */
          /* processing wildcards and if the examine revealed a file, we    */
          /* can't go any further.                                          */
          /*================================================================*/
          if ((global.ap.ap_Info.fib_DirEntryType < 0) &&
              (!(global.ap.ap_Flags & APF_ITSWILD))) {
                global.errorcode = ERROR_DIR_NOT_FOUND;
                VPrintf(MSG_NOT_A_DIR, &global.opts[OPT_DIR]);
                global.returncode = RETURN_WARN;
          }
          else {
d336 2
a337 2
      	    /* set up indentation (brute force!) and print the name */
      	    /*======================================================*/
d339 3
a341 3
      		strcpy(global.filename, global.ap.ap_Info.fib_FileName);
      		tempvector[0] = 2;
      		tempvector[1] = (LONG)global.filename;
d343 1
a343 1
          	if (global.ap.ap_Info.fib_DirEntryType >= 0) {
d345 4
a348 4
 	    	       vsprintf(global.buffer, "%%%lds%%s (dir)\n", tempvector);
       	    	       global.ap.ap_Flags &= ~APF_DIDDIR;
	               tempvector[0] = (LONG)" ";
          	       VPrintf(global.buffer, tempvector);
d350 6
a355 6
            /*=========================================*/
            /* Go and get the directory or directories */
            /*=========================================*/
  	           do_dir(&global, 0);
       	    	   global.ap.ap_Flags &= ~APF_DIDDIR;
  		   if ((global.opts[OPT_INTER]) && 
d360 2
a361 2
                    tempvector[0] = (LONG)" ";
                    VPrintf(global.buffer, tempvector);
d363 26
a388 2
          }
        } while (!MatchNext(&global.ap));  /*===== end if MatchFirst() =====*/
d390 4
a393 10
        /*========================================================*/
        /* This function cleans up the AnchorPath structure list. */
        /*========================================================*/
        MatchEnd(&global.ap);


        /*=================================================================*/
        /* Always call FreeArgs() after successfully calling ReadArgs() to */
        /* recover any allocated memory and to perform cleanup functions.  */
        /*=================================================================*/
d395 7
a401 1
         FreeArgs(argsptr);
d411 1
d413 12
a424 13
  if ((global.errorcode != NO_ERROR)) {
    /*=============================================================*/
    /* The only time we print an error message is when we have an  */
    /* error other than ERROR_NO_MORE_ENTRIES. We suppress setting */
    /* Result2 if we have ERROR_BREAK.                             */
    /*=============================================================*/
    if (global.errorcode != ERROR_BREAK)
      SetIoErr(global.errorcode);

    if (global.errorcode != ERROR_NO_MORE_ENTRIES)
      PrintFault(global.errorcode, NULL);
  }
  CloseLibrary((struct Library *)DOSBase);
d434 1
a434 1
/*            in a recursive manner.                              */
d442 9
a450 9
                      *fnametemp,
                      *fnamewalk,
                      *fnameprev;
  int                  rc,
                       matchrc,
                       column;
  BPTR                 dirlock,
                       lock;
  LONG                 tempvector[TEMPVECTOR_SIZE];
d469 1
a469 1
  /* directory. But we have to make the setting of the flag       */
d474 9
a482 3

    global->ap.ap_Flags |= APF_DODIR;
    matchrc = MatchNext(&global->ap);
d490 1
a490 1
  /* never executed to this point.                                     */
d497 1
a497 1
  /* a directory one file at a time.  There are many things to      */
d499 1
a499 1
  /* A-OK.                                                          */
d502 1
a502 1
	
d505 1
a505 1
    /* it is done with this directory level.   This would seem      */
d508 1
a508 1
    /* We have to trap this.                                        */
d518 1
a518 1
    if((global->ap.ap_FoundBreak)&BREAKBITS) {
d524 1
a524 1
    /* When we find a directory, print it unless printing is       */
d528 18
a545 1
        (global->ap.ap_Info.fib_DirEntryType >= 0)) {
d550 1
d552 1
d560 1
a560 1
      /* we tack on a newline to our freshly printed dirname.    */
d564 39
a602 39
        /*========================================================*/
        /* Basically, dointeract() prompts after the filename and */
        /* performs actions based on its template.  Return codes  */
        /* appear in global->optflags and global->returncode. The */
        /* REPEAT_ENTRY_FLAG is to support the dointeract() call  */
        /* and redisplay the filename depending on which command  */
        /* the user typed.                                        */
        /*========================================================*/
        global->optflags |= REPEAT_ENTRY_FLAG;
        while(global->optflags & REPEAT_ENTRY_FLAG)
        {
          /*======================================================*/
          /* Print the filename and perform interactive functions */
          /*======================================================*/
          VPrintf(global->buffer, tempvector);
          VPrintf(" ? ", NULL);
          dointeract(global, NULL, TYPE_DIR);
        }
        /*=========================================================*/
        /* OPT_BACK_FLAG signals that the user wishes to come back */
        /* one level shallower in the directory tree structure.    */
        /*=========================================================*/
        if (global->optflags & OPT_BACK_FLAG)
        {
          /*=====================================*/
          /* Reset the flag and exit this level. */
          /*=====================================*/
          global->optflags &= ~OPT_BACK_FLAG;
          break;
        }

        /*===========================================================*/
        /* OPT_QUIT_FLAG signals the user's desire to hit the road.  */
        /* We have to preserve this flag so we can quit cleanly from */
        /* any level. We also quit out if we have a major error.     */
        /*===========================================================*/
        if ((global->optflags & OPT_QUIT_FLAG) ||
            (global->returncode == RETURN_FAIL))
          goto TimeToGo;
d606 20
a625 6
        /*====================================*/
        /* Just print and terminate the line. */
        /*====================================*/
        VPrintf(global->buffer, tempvector);
        PutStr("\n");
      }
d627 1
d633 1
a633 1
    /* directories even if we specified not to display them!         */
d636 1
a636 1
        (global->ap.ap_Info.fib_DirEntryType >= 0))
d654 1
a654 1
      /* the program.  Either way, we exit the same.                     */
d657 2
a658 2
          (global->returncode == RETURN_FAIL))
        goto TimeToGo;
d663 1
a663 1
    /* store the filenames in sorted order for later printing.  */
d672 1
a672 1
                           MEMF_CLEAR | MEMF_PUBLIC);
d675 6
a680 6
        /*=======================================*/
        /* If we have very little memory left... */
        /*=======================================*/
        global->errorcode = IoErr();
        PutStr(MSG_OUT_OF_MEM_INC);
        break;
d693 1
a693 1
      /* ones.  fnamehead is the list head.                         */
d697 4
a700 4
        /*==============================================================*/
        /* If the list is empty, we just create the head of the list.   */
        /*==============================================================*/
        fnamehead = fnametemp;
d704 39
a742 39
        /*========================================================*/
        /* We are ready for sorting the list. Initialize walking  */
        /* variables.                                             */
        /*========================================================*/
        fnamewalk = fnamehead;
        fnameprev = NULL;

        /*=================================================*/
        /* This while(){} below controls the list walking. */
        /*=================================================*/
        while (fnamewalk)
        {
          /*=======================================================*/
          /* Speed the search by skipping all filenames till we    */
          /* find a match for the first chrarcter. This saves many */
          /* unneeded calls to stricmp(). 'And'ing with 0xDF is    */
          /* quicker (and dirtier) than the toupper() macro.       */
          /*=======================================================*/
          if ((fnamewalk->fnl_name[0] & 0xDF) < /* Change to the ToUpper */
              (fnametemp->fnl_name[0] & 0xDF))  /* if it is ever ready!  */
          {
            /*===================================================*/
            /* Walk the list keeping track of the previous node. */
            /*===================================================*/
            fnameprev = fnamewalk;
            fnamewalk = fnamewalk->fnl_next;
          }

          /*========================================================*/
          /* If we found the end of the list, back up to last valid */
          /* node.                                                  */
          /*========================================================*/
          if (fnamewalk == NULL)
            fnamewalk = fnameprev;

          /*======================================================*/
          /* Compare the filenames and test for duplicates. rc is */
          /* either 1, 0, or -1 based on the comparison.          */
          /*======================================================*/
d745 3
a747 3
          if ((rc = stricmp(fnamewalk->fnl_name,
                            fnametemp->fnl_name)) == 0)
          {
d749 1
a749 1
          rc = stricmp(fnamewalk->fnl_name,fnametemp->fnl_name);
d752 9
a760 9
            /*=====================================================*/
            /* Oops, we have a duplicate filename!  This error     */
            /* was not trapped in the BCPL code.  Evidently the    */
            /* directory was updated incorrectly making the chain  */
            /* loop around to earlier elements.  I consider this   */
            /* an error condition and break out of this mess.      */
            /*    "It's worse than that, he's dead, Jim!"          */
            /* EXCEPT THIS IS THE NORMAL CONDITION WITH PATHMAN... */
            /*=====================================================*/
d763 70
a832 70
            global->errorcode = ERROR_INVALID_COMPONENT_NAME;
            PutStr(MSG_DUP_FILENAME);
            global->returncode = RETURN_FAIL;
            goto TimeToGo;
          }
          else
#endif

          {
            /*=====================================================*/
            /* We havef ound the right place, put our new filename */
            /* structure there.  rc is from the stricmp() above.   */
            /*=====================================================*/
            if (rc > 0)
            {
              /*===================================================*/
              /* Make our current node the next after the new one. */
              /*===================================================*/
              fnametemp->fnl_next = fnamewalk;

              /*=================================================*/
              /* fnameprev points to where we came from last     */
              /* iteration of the while(fnamewalk).  It is NULL  */
              /* the first time through when examining the head. */
              /*=================================================*/
              if (fnameprev == NULL)
              {
                /*=====================================*/
                /* Place the new fnl node at the head. */
                /*=====================================*/
                fnamehead = fnametemp;
              }
              else
              {
                /*=========================================*/
                /* Place the fnl structure at a certain    */
                /* location just before the filename which */
                /* has a greater ascii value than it does. */
                /*=========================================*/
                fnameprev->fnl_next = fnametemp;
              }

              /*========================================*/
              /* We've done our insertion, so we leave. */
              /*========================================*/
              break;
            }

            /*===============================================*/
            /* Make a new previous and increment to the next */
            /* element in the list.                          */
            /*===============================================*/
            fnameprev = fnamewalk;
            fnamewalk = fnamewalk->fnl_next;

          }   /*===== End of else to stricmp(...) =====*/

        }  /*===== End while(fnamewalk) =====*/

        /*=================================================*/
        /* Check to see if we have gone through the entire */
        /* list and haven't been inserted.                 */
        /*=================================================*/
        if (rc < 0)
        {
          /*==========================================*/
          /* If such is the case, tack it on the end! */
          /*==========================================*/
          fnameprev->fnl_next = fnametemp;
        }
d846 1
a846 1
    /* It seems that if we delete a file or directory out from    */
d848 1
a848 1
    /* GURU.  NOTE: This workaround was unnecessary with ARP!     */
d850 1
a850 1
    /* integrity of the AnchorPath state variables.               */
d857 2
a858 2
        global->errorcode = IoErr();
        global->returncode = RETURN_ERROR;
d862 1
a862 1
        PutStr(MSG_DELETED);
d868 1
a868 1
    if((global->ap.ap_FoundBreak)&BREAKBITS) {
d886 1
a886 1
  /* When the user has specified QUIT in the interactive mode,     */
d905 1
a905 1
    /* have suppressed the printing of the filenames.              */
d914 2
a915 2
      /* Check for the INTER keyword..  We indent differently */
      /* when in the interactive mode.                        */
d919 37
a955 33
        /*====================*/
        /* Set up indentation */
        /*====================*/
        tempvector[0] = ((reclvl+1) * 5) + 2;
        tempvector[1] = (LONG)fnametemp->fnl_name;
        vsprintf(global->buffer, "%%%lds%%s", tempvector);
        tempvector[0] = (LONG)" ";

        /*======================================================*/
        /* Support for repeating the printing of the filename   */
        /* after certain commands in the dointeract() function. */
        /*======================================================*/
        global->optflags |= REPEAT_ENTRY_FLAG;
        strcpy(global->filename, fnametemp->fnl_name);
        while(global->optflags & REPEAT_ENTRY_FLAG)
        {
          VPrintf(global->buffer, tempvector);
          VPrintf(" ? ", NULL);
          dointeract(global, dirlock, TYPE_FILE);
        }

        /*=========================================*/
        /* Check on flags returned by dointeract() */
        /*=========================================*/
        if (global->optflags & OPT_BACK_FLAG)
        {
          global->optflags &= ~OPT_BACK_FLAG;
          goto TimeToGo;
        }
        if ((global->optflags & OPT_QUIT_FLAG))
        {
          goto TimeToGo;
        }
d959 29
a987 25
        /*===================*/
        /* Give user an out! */
        /*===================*/
        if (CheckSignal(BREAKBITS))
        {
          global->optflags = OPT_QUIT_FLAG;
          global->returncode = RETURN_WARN;
          global->errorcode = ERROR_BREAK;
          break;
        }

        /*=======================================================*/
        /* We are not interactive, so set up the indentation and */
        /* print the filenames in a two column format (for now). */
        /*=======================================================*/
        tempvector[column] = (LONG)fnametemp->fnl_name;
        column = 3 - column;
        if ((column == 1) || (fnametemp->fnl_next == NULL))
        {
          tempvector[0] = ((reclvl+1) * 5) + 2;
          vsprintf(global->buffer, "%%%lds%%-31s  %%s\n", tempvector);
          tempvector[0] = (LONG)" ";
          VPrintf(global->buffer, tempvector);
          tempvector[2] = NULL;
        }
d999 1
a999 1
  /* TimeToGo is a place that the code can jump to IF an exit    */
d1019 3
a1021 3
/*   Purpose:  This function does our interactive functions for us.     */
/*             Since the context is single file oriented, we just need  */
/*             to pass the filename.                                    */
d1029 6
a1034 6
/*                     *input; */
  UBYTE              *execbuff;
  LONG                opts[INTER_COUNT];
  char                chr[1];
  BPTR                fileptr,
                      lock;
d1095 38
a1132 38
        /*===================*/
        /* Open file to type */
        /*===================*/
        lock = CurrentDir(parent);
        if (!(fileptr = Open(global->filename, MODE_OLDFILE)))
        {
          global->errorcode = IoErr();
          global->returncode = RETURN_FAIL;
        }
        else
        {
          /*=========================================================*/
          /* Loop through file, reading and then writing a character */
          /*=========================================================*/
          while ((*chr = FGetC(fileptr)) != -1)
          {
            /*===================*/
            /* Give user an out! */
            /*===================*/
            if (CheckSignal(BREAKBITS))
            {
              PrintFault(ERROR_BREAK, NULL);
              break;
            }

            /*================================*/
            /* Output the character to stdout */
            /*================================*/
            WriteChars(chr, 1);
          }

          /*==================================================*/
          /* Replace previous input filehandle and close file */
          /*==================================================*/
          Close(fileptr);
        }
        CurrentDir(lock);
        goto RepeatOut;
d1140 24
a1163 24
        if (opts[OPT_INTER_COMMAND])
        {
          /*=====================================*/
          /* Everything is ready, do the command */
          /*=====================================*/
          Execute((char *)opts[OPT_INTER_COMMAND], NULL, NULL);
          PutStr("\n");
          goto RepeatOut;
        }
        else
        {
          /*=============================================================*/
          /* Provide a command prompt for those who apparently need one! */
          /*=============================================================*/
          PutStr(MSG_COMMAND_PROMPT);
          Flush(Output());

          if(FGets(Input(), execbuff, BUFFER_SIZE))
          {
                Execute(execbuff, NULL, NULL);
                PutStr("\n");
          }
          goto RepeatOut;
        }
d1167 10
a1176 10
        /*===========================================================*/
        /* If the user typed gobbledygook, this traps it as an error */
        /* because any unknown syntax in the rest of the template    */
        /* will end up here!                                         */
        /*===========================================================*/
        if (opts[OPT_INTER_COMMAND])
        {
          PutStr(MSG_INVALID_RESPONSE);
          goto RepeatOut;
        }
d1184 2
a1185 2
        global->optflags = OPT_QUIT_FLAG;
        goto NoRepeatOut;
d1193 3
a1195 3
        global->ap.ap_Flags |= APF_DIDDIR;
        global->optflags |= OPT_BACK_FLAG;
        goto NoRepeatOut;
d1203 2
a1204 2
        global->optflags |= OPT_ENTER_FLAG;
        goto NoRepeatOut;
d1212 22
a1233 22
        if (filetype == TYPE_FILE)
        {
          /*============================================================*/
          /* Set up to delete the file by setting the current directory */
          /*============================================================*/
          lock = CurrentDir(parent);
          if(!DeleteFile(global->filename))
          {
            global->errorcode = IoErr();
            global->returncode = RETURN_ERROR;
          }
          else
          {
            PutStr(MSG_DELETED);
          }
          CurrentDir(lock);
        }
        else  /*= filetype == TYPE_DIR =*/
        {
          global->optflags |= DELETE_DIR_FLAG;
        }
        goto NoRepeatOut;
d1239 1
a1239 1
      /* to another file!                                                 */
d1265 1
a1265 1
/* Function: prbuf                                              */
d1267 4
a1270 4
/*           for each character in the string.  At invocation,  */
/*           we have:                                           */
/*              D0 - next character to be formatted             */
/*              A3 - pointer to data buffer                     */
d1279 4
a1282 4
/* Function: vsprintf                                                 */
/*  Purpose: This is a tiny implementation of sprintf.  Note that it  */
/*           assumes that the buffer is large enough to hold any      */
/*           formatted string you ask it to generate.                 */
@


1.16
log
@fixed enforcer hit caused by incorrectly placed FreeArgs
@
text
@d294 2
a295 1
          VPrintf(MSG_NO_INFO_FOR, &global.opts[OPT_DIR]);
d298 3
a300 1

d308 3
a310 3
            global.errorcode = ERROR_DIR_NOT_FOUND;
            VPrintf(MSG_NOT_A_DIR, &global.opts[OPT_DIR]);
            global.returncode = RETURN_WARN;
d451 1
a451 1

d467 5
d688 1
a688 1
            /* We have found the right place, put our new filename */
d781 5
@


1.15
log
@moved return() a little
@
text
@d346 8
a357 5
      /*=================================================================*/
      /* Always call FreeArgs() after successfully calling ReadArgs() to */
      /* recover any allocated memory and to perform cleanup functions.  */
      /*=================================================================*/
      FreeArgs(argsptr);
@


1.14
log
@its always best to call routines before the library is closed
@
text
@a372 3

  return(global.returncode);

a373 1

d376 1
a376 2


@


1.13
log
@*** empty log message ***
@
text
@a359 5
    CloseLibrary((struct Library *)DOSBase);
  }
  else { 
    OPENFAIL;
  }
d361 1
a361 2
  if ((global.errorcode != NO_ERROR))
  {
d375 7
@


1.12
log
@checkin for comparison
@
text
@d186 2
a187 2
  if ((DOSBase = (struct DosLibrary *)OpenLibrary(DOSLIB, DOSVER)))
  {
d195 1
a195 2
    if (!(global.buffer = AllocVec(BUFFER_SIZE, MEMF_CLEAR | MEMF_PUBLIC)))
    {
d198 2
a199 2
    else
    {
d210 3
a212 6
      if (argsptr == NULL)
      {
        global.errorcode = IoErr();
      }
      else
      {
d218 1
a218 2
        if (global.opts[OPT_OPT] != NULL)
        {
d220 2
a221 2
          while (*text)
          {
d280 1
a280 4
        if (global.opts[OPT_DIR] == NULL)
        {
          global.opts[OPT_DIR] = (LONG)"";
        }
d304 1
a304 2
              (!(global.ap.ap_Flags & APF_ITSWILD)))
          {
d318 1
d323 2
d326 7
a332 2
                tempvector[0] = (LONG)" ";
                VPrintf(global.buffer, tempvector);
a333 2

/*
d335 3
a337 1
		    vsprintf(global.buffer, "%%%lds%%s (file)\n", tempvector);
a338 8
*/

            /*=========================================*/
            /* Go and get the directory or directories */
            /*=========================================*/

            do_dir(&global, 0);

a339 1

d362 1
a362 2
  else
  {
d425 1
a425 1
  if ((global->ap.ap_Info.fib_DirEntryType > 0)) {
d448 2
a449 2
  while(matchrc == NULL)
  {
d470 2
a471 2
        (global->ap.ap_Info.fib_DirEntryType >= 0))
    {
d485 2
a486 2
      if (global->optflags & INTER_FLAG)
      {
d544 1
a544 1
        (global->ap.ap_Info.fib_DirEntryType > 0))
d574 2
a575 2
       (global->ap.ap_Info.fib_DirEntryType < 0))
    {
d603 2
a604 2
      if (fnamehead == NULL)
      {
d610 2
a611 2
      else
      {
a1154 1
/*    FreeVec(input); */
@


1.11
log
@fixed the pattern match code
@
text
@d325 1
a325 1
      		tempvector[0] = 5;
d328 6
a333 2
 	    	    vsprintf(global.buffer, "%%%lds%%s (dir)\n", tempvector);
       	    	    global.ap.ap_Flags &= ~APF_DIDDIR;
d335 2
d338 1
a338 1
		    vsprintf(global.buffer, "%%%lds%%s\n", tempvector);
d340 1
a340 2
                tempvector[0] = (LONG)" ";
                VPrintf(global.buffer, tempvector);
d471 1
d487 1
a487 1
      tempvector[0] = (reclvl + 2) * 5;
d836 1
a836 1
        tempvector[0] = (reclvl * 5) + 2;
d1095 1
a1095 1
      /* Backup one dir rutine */
@


1.10
log
@fixed wildcard and directory entry (almost)
@
text
@d323 1
a323 1
          	if (global.ap.ap_Info.fib_DirEntryType >= 0) {
d325 1
a325 1
      		tempvector[0] = 3;
d327 1
d329 1
a329 2
                    tempvector[0] = (LONG)" ";
                    VPrintf(global.buffer, tempvector);
d331 6
d342 1
a342 1
      	    global.ap.ap_Flags &= ~APF_DIDDIR;
@


1.9
log
@removed test for dup filename AGAIN
@
text
@d177 1
d300 1
a300 2
        if (MatchFirst((char *)global.opts[OPT_DIR], &global.ap))
        {
d304 2
a305 2
        else
        {
d318 13
a330 2
          else
          {
d334 1
d336 1
d339 1
a339 1
        }  /*===== end if MatchFirst() =====*/
d412 1
d425 3
a427 2
  if (global->ap.ap_Info.fib_DirEntryType > 0)
  {
d457 1
d475 1
a475 1
      tempvector[0] = (reclvl + 1) * 5;
d876 1
a876 1
          tempvector[0] = (reclvl * 5) + 2;
a943 1
/*    !(input  = AllocVec(sizeof(struct RDArgs), MEMF_CLEAR | MEMF_PUBLIC))|| */
a958 1
/*    input->RDA_Flags |= RDAF_STDIN; */
@


1.8
log
@new version from the Software Distillery
@
text
@d119 1
a119 1
#define CHECK_FOR_DUP     1
d906 2
a907 2
  struct RDArgs      *argsptr,
                     *input;
d920 1
a920 1
  memset(opts, 0, sizeof(opts));
d928 1
a928 1
      !(input  = AllocVec(sizeof(struct RDArgs), MEMF_CLEAR | MEMF_PUBLIC)) ||
d944 1
a944 1
    input->RDA_Flags |= RDAF_STDIN;
d950 1
a950 1
      argsptr = ReadArgs(INTER_DIR_TEMPLATE, opts, input);
d957 1
a957 1
      argsptr = ReadArgs(INTER_FILE_TEMPLATE, opts, input);
d1140 1
a1140 1
    FreeVec(input);
d1170 1
@


1.7
log
@should work with PATHMAN now
@
text
@d2 5
a6 4
lc -d -j73 -rr -O -o/obj/Dir.o -i/include -v -cifms -q1e99w Dir.c
blink /obj/Dir.o to Dir.ld lib lib:lcr.lib sc sd nd batch
protect /bin/Dir +p
quit
d45 5
d61 1
a61 1
#define MSG_OPTION_IGNORED   "Option %c ignored\n"
d63 1
a63 1
#define MSG_DUP_FILENAME     "Duplicate filename - directory corrupt"
d119 2
d149 2
a150 1
  LONG              rc;
d172 1
a172 1
  struct Library *SysBase = (*((struct Library **) 4));
d174 1
a174 1
  struct Global     global;
a175 1
  int               retcode;
d182 2
a183 1
  global.rc = RETURN_FAIL;
d196 1
a196 1
      PrintFault(IoErr(), NULL);
d212 1
a212 1
        PrintFault(IoErr(), NULL);
d248 2
a249 1
                VPrintf(MSG_OPTION_IGNORED, (LONG *)text);
d272 1
a272 1
	/* wildcards.                                                */
a297 5
	/* ***************************************************************** */
	/* I feel that there is a bug in this function.  It doesn't act the  */
	/* same as its BCPL equivalent.  Any wildcards passed to this code   */
	/* may not cause this program to yield identical results to the BCPL */
	/* version.  Be careful, the BCPL version has its own bugs!          */
d299 1
a299 1
        if (retcode = MatchFirst((char *)global.opts[OPT_DIR], &global.ap))
d301 1
a302 1
          if(IoErr() != ERROR_NO_MORE_ENTRIES)PrintFault(IoErr(), NULL);
d314 1
d316 1
a316 1
            global.rc = RETURN_WARN;
d352 16
a367 1
  return(global.rc);
d380 1
a380 1
  struct Library *SysBase = (*((struct Library **) 4));
d385 6
a390 6
  int                 rc,
                      matchrc,
                      column;
  BPTR                dirlock,
                      lock;
  LONG                tempvector[TEMPVECTOR_SIZE];
d396 1
a396 5
  global->rc = RETURN_FAIL;

  /*=======================================================*/
  /* I forgot to initialize this variable.  Fixed 10MAR90. */
  /*=======================================================*/
d421 2
d473 1
a473 1
        /* appear in global->optflags and global->rc. The flag    */
d507 1
a507 1
            (global->rc == RETURN_FAIL))
d516 1
a516 1
        VPrintf("\n", NULL);
d548 1
a548 1
          (global->rc == RETURN_FAIL))
d569 2
a570 2
        VPrintf(MSG_OUT_OF_MEM_INC, NULL);
        PrintFault(IoErr(), NULL);
d614 1
a614 1
              (fnametemp->fnl_name[0] & 0xDF))  /* when it is ready.     */
d634 2
a635 1
/*
d637 3
a639 2
                            fnametemp->fnl_name)) == 0) {
*/
d641 11
d653 4
a656 13
            /*====================================================*/
            /* Oops, we have a duplicate filename!  This error    */
            /* was not trapped in the BCPL code.  Evidently the   */
            /* directory was updated incorrectly making the chain */
            /* loop around to earlier elements.  I consider this  */
            /* an error condition and break out of this mess.     */
            /*    "It's worse than that, he's dead, Jim!"         */

	    /* EXCEPT THIS IS THE NORMAL CONDITION WITH PATHMAN... */
            /*====================================================*/
/*
            VPrintf(MSG_DUP_FILENAME, NULL);
            global->rc = RETURN_FAIL;
d659 2
a660 3
          else 
*/
	  {
d662 1
d709 1
a709 1
            }   /*===== End of else to stricmp(...) =====*/
d748 2
a749 2
        PrintFault(IoErr(), NULL);
        global->rc = RETURN_ERROR;
d753 1
a753 1
        VPrintf(MSG_DELETED, NULL);
d766 2
a767 2
    PrintFault(ERROR_BREAK, NULL);
    global->rc = RETURN_WARN;
a773 1
  /* This is only economic.                                        */
d785 1
a785 1
    PrintFault(IoErr(), NULL);
d793 1
a793 1
    global->rc = RETURN_OK;     /* (probable) successful execution */
d797 1
a797 1
    while (fnametemp && (!global->rc))
d841 11
a864 10

          /*===================*/
          /* Give user an out! */
          /*===================*/
          if (CheckSignal(BREAKBITS))
          {
            PrintFault(ERROR_BREAK, NULL);
            global->optflags = OPT_QUIT_FLAG;
            break;
          }
d904 1
a904 1
  struct Library *SysBase = (*((struct Library **) 4));
d908 1
a908 1
  UBYTE	             *execbuff;
d918 1
a918 1
  global->rc = RETURN_OK;
a921 4
  /*=============================================================*/
  /* Added 08MAR90 to remedy the fact that this code was written */
  /* while the VPrintf() was not buffering yet!                  */
  /*=============================================================*/
d935 3
a937 3
    VPrintf(MSG_OUT_OF_MEM_INC, NULL);
    PrintFault(IoErr(), NULL);
    global->rc = RETURN_FAIL;
d954 3
a956 3
      /*==========================================*/
      /* If the name is a file, use this template */
      /*==========================================*/
d965 2
a966 2
      PrintFault(IoErr(), NULL);
      global->rc = RETURN_FAIL;
d981 2
a982 2
          PrintFault(IoErr(), NULL);
          global->rc = RETURN_FAIL;
d1026 1
a1026 1
          VPrintf("\n", NULL);
d1034 8
a1041 6
          VPrintf(MSG_COMMAND_PROMPT, NULL);
          Flush(Output());                        /*=== Added 11MAR90 ===*/
          if(FGets(Input(), execbuff, BUFFER_SIZE)) {
          	Execute(execbuff, NULL, NULL);
          	VPrintf("\n", NULL);
	  }
d1054 1
a1054 1
          VPrintf(MSG_INVALID_RESPONSE, NULL);
d1100 2
a1101 2
            PrintFault(IoErr(), NULL);
            global->rc = RETURN_ERROR;
d1105 1
a1105 1
            VPrintf(MSG_DELETED, NULL);
@


1.6
log
@removed NO_MORE_ENTRIES message if file isn't found
@
text
@d615 1
d617 4
a620 2
                            fnametemp->fnl_name)) == 0)
          {
d628 2
d631 1
d636 4
a639 2
          else
          {
d686 1
a686 1
          }  /*===== End of else to stricmp(...) =====*/
@


1.5
log
@changed use of Fget to match ANSI
added null check, too
@
text
@d297 1
a297 1
          PrintFault(IoErr(), NULL);
@


1.4
log
@new SW distillery release, pattern match should work now
@
text
@d1009 4
a1012 3
          FGets(Input(), execbuff, BUFFER_SIZE);
          Execute(execbuff, NULL, NULL);
          VPrintf("\n", NULL);
@


1.3
log
@JT update
@
text
@d43 1
d119 1
d163 1
d173 1
a173 1
  memset((char *)&global,0,sizeof(struct Global));
d192 2
a193 3
      /* Set opts[] to zero. If ReadArgs() sees anything but zeros passed */
      /* in elements this array, ReadArgs() will assume them as being     */
      /* defaults.                                                        */
d260 3
a262 2
        /* Set up an AnchorPath structure that Match...() need to do */
        /* the directory scan.                                       */
d268 1
a268 1
        /* MatchFirst() doesn't seem to like a NULL passed to the first   */
d272 1
d288 5
d359 1
d371 3
a373 3
  /*====================================================*/
  /* Assign DOSBase to keep from re-opening the library */
  /*====================================================*/
d376 9
d389 1
a389 1
  /* directory, we have a BUG to work around. Normally, we should */
d392 1
a392 2
  /* conditional on if MatchFirst() returns a file or a dir. This */
  /* shouldn't be necessary, Match...() already knows better!     */
d417 2
a418 2
    /* MatchNext() returns the flag APF_DIDDIR. This signifies that */
    /* we are done with this directory level.  This would seem      */
d420 2
a421 2
    /* getting too much nonsense data returned to us (i.e. an entry */
    /* for the parent directory!) and we had to trap this somehow.  */
d430 1
a430 1
    /* When we find a directory, print it unless dir printing is   */
d452 1
a452 1
        /* Basically, dointeract prompts after the filename and   */
d456 2
a457 2
        /* and redisplay the filename based on which command the  */
        /* user typed.                                            */
d522 6
d535 1
a535 1
    /* store the filenames in sorted order for future printing. */
d547 3
a549 3
        /*================================*/
        /* list incomplete error message. */
        /*================================*/
d555 3
a557 3
      /*=======================================================*/
      /* Initialize the new node filename and filetype fields. */
      /*=======================================================*/
d561 5
a565 5
      /* I am using a sequential insertion sort routine. Such as it */
      /* is, the sort is faster than the printing of the names and  */
      /* it's close to the performance of qsorting the filenames.   */
      /* The difference is negligible in small directories and      */
      /* not too bad for big ones.  fnamehead is the list head.     */
d592 1
a592 2
          /* quicker than the toupper macro which has an if        */
          /* decision in it.                                       */
d594 2
a595 2
          if ((fnamewalk->fnl_name[0] & 0xDF) <  /* Change to the ToUpper */
              (fnametemp->fnl_name[0] & 0xDF))   /* when it is ready.     */
d619 4
a622 5
            /* Oops, we have a duplicate!  This error was not     */
            /* trapped out in the BCPL code (I know, it bit me!). */
            /* Evidently the directory was updated incorrectly    */
            /* making the pointer chain loop around to earlier    */
            /* elements or something like that.  I consider this  */
d632 4
a635 4
            /*====================================================*/
            /* When we find the right place, put our new filename */
            /* structure there. rc is from the stricmp() above.   */
            /*====================================================*/
d703 9
a711 10
    /*===========================================================*/
    /* The reason we delete our directory here is because of the */
    /* need to work around an anomoly (BUG) in the Match...()    */
    /* routines.  It seems that if we delete a file or directory */
    /* out from under the Match...() functions, we invite a GURU */
    /* visit.  NOTE: This workaround was unnecessary with ARP!   */
    /* We have to have done our next MatchNext() to preserve the */
    /* integrity of the AnchorPath state variables.              */
    /* If you think this code is bad, see Delete.c!              */
    /*===========================================================*/
d743 1
a743 1
  /* This is not only economic, it is prudent!                     */
d769 4
a772 4
      /*==========================================================*/
      /* Check for the INTER keyword again. we indent differently */
      /* when in the interactive mode.                            */
      /*==========================================================*/
d813 1
a813 1
        /* print the filenames in a two column format.           */
d873 1
d877 5
a881 4
  LONG               opts[INTER_COUNT];
  char               chr[1];
  BPTR               fileptr,
                     lock;
d890 5
d900 4
a903 1
  if (!(input  = AllocVec(sizeof(struct RDArgs), MEMF_CLEAR | MEMF_PUBLIC)))
d1008 3
a1010 2
          FGets(Input(), global->buffer, BUFFER_SIZE);
          Execute(global->buffer, NULL, NULL);
a1090 1

d1106 4
a1109 3
    /*==============================*/
    /* Give back the memory we used */
    /*==============================*/
d1131 3
a1133 3
/*  Purpose: This is a tiny implementation of sprintf for use within  */
/*           dir.c.  Note that it assumes that the buffer is large    */
/*           enough to hold any formatted string.                     */
@


1.2
log
@version number update
@
text
@d41 2
a115 1
#define FILLER_SIZE       256
a130 5
struct UserAnchor {
  struct AnchorPath ap;
  UBYTE             filler[FILLER_SIZE];
};

d137 1
a137 1
  struct UserAnchor *uap;       /* uap is for User Anchor Pointer */
d140 1
d161 5
a165 7
  struct Global      global;
  struct DosLibrary  *DOSBase;
  struct RDArgs      *argsptr;
  struct UserAnchor  ua;
  int                retcode;
  LONG               opts[OPT_COUNT];
  UBYTE              *text;
d170 1
a170 1
  memset( &global,0,sizeof(struct Global));
d193 1
a193 2
      memset(opts, 0, sizeof(opts));
      argsptr = ReadArgs(TEMPLATE, opts, NULL);
d210 1
a210 1
        if (opts[OPT_OPT] != NULL)
d212 1
a212 1
          text = (char *)opts[OPT_OPT];
d218 1
a218 1
                opts[OPT_INTER] = 1;
d222 1
a222 1
                opts[OPT_ALL]   = 1;
d226 1
a226 1
                opts[OPT_DIRS]  = 1;
d230 1
a230 1
                opts[OPT_FILES] = 1;
d246 4
a249 4
        if (opts[OPT_ALL])    global.optflags |= ALL_FLAG;
        if (opts[OPT_INTER])  global.optflags |= INTER_FLAG;
        if (opts[OPT_FILES])  global.optflags |= FILES_FLAG;
        if (opts[OPT_DIRS])   global.optflags |= DIRS_FLAG;
d254 1
a254 1
        if (opts[OPT_FILES] == 0 && opts[OPT_DIRS] == 0)
d261 2
a262 3
        ua.ap.ap_BreakBits = BREAKBITS;
        ua.ap.ap_Strlen = FILLER_SIZE;
        ua.ap.ap_Flags = APF_DOWILD;
d270 1
a270 1
        if (opts[OPT_DIR] == NULL)
d272 1
a272 1
          opts[OPT_DIR] = (LONG)"";
d285 1
a285 1
        if (retcode = MatchFirst((char *)opts[OPT_DIR], &ua.ap))
d287 1
a287 1
          VPrintf(MSG_NO_INFO_FOR, &opts[OPT_DIR]);
d297 2
a298 2
          if ((ua.ap.ap_Info.fib_DirEntryType < 0) &&
              (!(ua.ap.ap_Flags & APF_ITSWILD)))
d300 1
a300 1
            VPrintf(MSG_NOT_A_DIR, &opts[OPT_DIR]);
a307 1
            global.uap = &ua;
d316 1
a316 1
        MatchEnd(&ua.ap);
d376 1
a376 1
  if (global->uap->ap.ap_Info.fib_DirEntryType > 0)
d378 2
a379 2
    global->uap->ap.ap_Flags |= APF_DODIR;
    matchrc = MatchNext(&global->uap->ap);
d387 1
a387 1
  dirlock = DupLock(global->uap->ap.ap_Current->an_Lock);
d405 1
a405 1
    if (global->uap->ap.ap_Flags & APF_DIDDIR)
d416 1
a416 1
        (global->uap->ap.ap_Info.fib_DirEntryType >= 0))
d421 1
a421 1
      strcpy(global->filename, global->uap->ap.ap_Info.fib_FileName);
d490 1
a490 1
        (global->uap->ap.ap_Info.fib_DirEntryType > 0))
d503 1
a503 1
      global->uap->ap.ap_Flags &= ~APF_DIDDIR;
d514 1
a514 1
       (global->uap->ap.ap_Info.fib_DirEntryType < 0))
d534 1
a534 1
      strcpy(fnametemp->fnl_name, global->uap->ap.ap_Info.fib_FileName);
d605 2
a606 1
            break;
d679 1
a679 1
    matchrc = MatchNext(&global->uap->ap);
d867 1
d1011 1
a1011 1
        global->uap->ap.ap_Flags |= APF_DIDDIR;
@


1.1
log
@new version of command
@
text
@@


1.0
log
@added to rcs
@
text
@d39 2
a42 2
/*   There are perhaps a couple of areas that could be improved, but they    */
/*   probably are of little worth and offers meager performance gains.       */
d216 1
a216 2
        text = (char *)opts[OPT_OPT];
        while (*text)
d218 2
a219 1
          switch(*text++)
d221 5
a225 3
            case 'i': case 'I':       /**** Interactive ***/
              opts[OPT_INTER] = 1;
              break;
d227 3
a229 3
            case 'a': case 'A':       /**** All ***********/
              opts[OPT_ALL]   = 1;
              break;
d231 3
a233 3
            case 'd': case 'D':       /**** Dirs only *****/
              opts[OPT_DIRS]  = 1;
              break;
d235 3
a237 3
            case 'f': case 'F':       /**** Files only ****/
              opts[OPT_FILES] = 1;
              break;
d239 7
a245 6
            default:
              /*======================================================*/
              /* Should get here only if an invalid option was found. */
              /*======================================================*/
              VPrintf(MSG_OPTION_IGNORED, (LONG *)text);
              break;
d270 11
@
