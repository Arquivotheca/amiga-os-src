head     40.1;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @*   @;


40.1
date     93.04.12.10.39.57;  author vertex;  state Exp;
branches ;
next     1.17;

1.17
date     91.02.13.21.31.38;  author jgm;  state Exp;
branches ;
next     1.16;

1.16
date     91.02.04.19.37.58;  author jgm;  state Exp;
branches ;
next     1.15;

1.15
date     91.01.27.20.24.47;  author jgm;  state Exp;
branches ;
next     1.14;

1.14
date     91.01.11.20.40.44;  author jgm;  state Exp;
branches ;
next     1.13;

1.13
date     91.01.06.16.40.14;  author jgm;  state Exp;
branches ;
next     1.12;

1.12
date     91.01.02.02.23.50;  author Mary_Ellen_Toebes;  state Exp;
branches ;
next     1.11;

1.11
date     90.10.09.22.36.11;  author jgm;  state Exp;
branches ;
next     1.10;

1.10
date     90.10.01.21.37.20;  author jgm;  state Exp;
branches ;
next     1.9;

1.9
date     90.09.27.17.21.05;  author jgm;  state Exp;
branches ;
next     1.8;

1.8
date     90.09.06.19.17.15;  author eric;  state Exp;
branches ;
next     1.7;

1.7
date     90.09.06.19.17.10;  author andy;  state Exp;
branches ;
next     1.6;

1.6
date     90.05.25.14.21.27;  author andy;  state Exp;
branches ;
next     1.5;

1.5
date     90.04.06.19.10.24;  author andy;  state Exp;
branches ;
next     1.4;

1.4
date     90.04.06.19.01.03;  author andy;  state Exp;
branches ;
next     1.3;

1.3
date     90.04.06.14.55.32;  author andy;  state Exp;
branches ;
next     1.2;

1.2
date     90.03.12.20.17.50;  author andy;  state Exp;
branches ;
next     1.1;

1.1
date     90.03.01.19.44.21;  author andy;  state Exp;
branches ;
next     1.0;

1.0
date     90.01.22.19.38.01;  author andy;  state Exp;
branches ;
next     ;


desc
@Search command for cdos
@


40.1
log
@Fixed crash and burn when no FROM argument was given
@
text
@; /*
lc -d2 -j73 -o/obj/Search.o -i/include -rr -v -cusf Search
blink /obj/Search.o to /bin/Search sc sd nd
protect /bin/Search +p
quit
*/

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* |_o_o|\\ Copyright (c) 1989 The Software Distillery.  All Rights Reserved */
/* |. o.| || This program may not be distributed without the permission of   */
/* | .	| || the authors:			      BBS: (919) 382-8265    */
/* | o	| ||   Dave Baker      Alan Beale	  Jim Cooper		     */
/* |  . |//    Jay Denebeim    Bruce Drake	  Gordon Keener 	     */
/* ======      John Mainwaring Andy Mercier	  Jack Rouse		     */
/*	       John Toebes     Mary Ellen Toebes  Doug Walker		     */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**	(C) Copyright 1989 Commodore-Amiga, Inc.
 **	    All Rights Reserved
**/

/*---------------------------------------------------------------------------*/
/* Command: Search							     */
/* Author:  John Mainwaring						     */
/* Change History:							     */
/*  Date    Person	  Action					     */
/* -------  ------------- -----------------				     */
/* 19MAR89  John Toebes   Initial Creation				     */
/* 19apr89 John Mainwaring first compilable stub			     */
/* 30Jul89 John Mainwaring create name & pattern elements		s15  */
/* 14NOV89 John Mainwaring compilable under dos1.4 (not working)        a1   */
/* 04DEC89 John Mainwaring parse parameters and dump debug info 	a2   */
/* 07DEC89 John Mainwaring version released for dos1.4 beta		a3   */
/* 11FEB90 John Mainwaring tidy up global structure			b1   */
/* 12FEB90 John Mainwaring cut down on allocated store			b2   */
/* 21FEB90 John Mainwaring Tidy up for release				b3   */
/* 21FEB90 John Mainwaring Experiment with Anchor stuff			b4   */
/* 13MAR90 John Mainwaring remove FILE option and handle multi arg path	b5   */
/* 14MAR90 John Mainwaring handle multi arg path with FILE option	b6   */
/* 20MAY90 John Mainwaring return WARN if no match found		b7   */
/* 20MAY90 John Mainwaring provide operation as a filter		b8   */
/* 25AUG90 John Mainwaring don't mess up printing lines with "%s"	b9   */
/* 01Jan90 Mary Ellen Toebes don't print filename if no wild cards B11608    */
/* 01Jan90 Mary Ellen Toebes Kludge - breaks search <* (rex needs) B11867    */
/* 01Jan90 Mary Ellen Toebes quiet overrides quick                 B10622    */
/* 06Jan91 John Mainwaring Check search arg shorter than 256 chars    B10867 */
/* 06Jan91 John Mainwaring make QUICK work with QUIET                 B10622 */
/* 06Jan91 John Mainwaring Don't do filtering for AREXX console input B10867 */
/* 11Jan91 John Mainwaring No file name if more than one FROM multiargB11608 */
/* 19Jan91 John Mainwaring Fix crash on redirected output - bad lock  B12158 */
/* 26Jan91 John Mainwaring Process *N at beginning or end of pattern  B11966 */
/* 02FEB91 John Mainwaring Improve handling of *N at either end of a line    */
/* 04FEB91 John Mainwaring Use DirChanged flag in MatchFirst/Next loop       */
/* 04FEB91 John Mainwaring Fix Enforcer hit, pointer optptr init      B12653 */
/* Notes:								     */
/*---------------------------------------------------------------------------*/

#include "internal/commands.h"
#include "search_rev.h"

void aprintf();

#define MSG_FILE_ABANDONED	"** File abandoned\n"
#define MSG_SRCH_ARG_ERR	"** SEARCH string too long\n"

#define TEMPLATE    "FROM/M,SEARCH/A,ALL/S,NONUM/S,QUIET/S,QUICK/S,FILE/S,PATTERN/S" CMDREV
#define TEMPLATE2   "SEARCH/A,PATTERN/S,NONUM/S"

#define OPT_COUNT	8
#define SEARCH_DEPTH	25
#define BLANK_COUNT	(SEARCH_DEPTH + 1) * 5
#define LINESIZE	256
#define FPATHSIZE	256

#define FROM	0
#define SEARCH	FROM+1
#define ALL	SEARCH+1
#define NONUM	ALL+1
#define QUIET	NONUM+1
#define QUICK	QUIET+1
#define FILE	QUICK+1
#define PATTERN FILE+1

/* NOBLANKNAME controls whether to print a blank line in place of the	*/
/* file name for an unambiguous search path (filename) to completely 	*/
/* emulate Dos 1.3  (defined) or omit the blank line (undefined).	*/
/* Default is now defined - ie no blank line				*/

#define NOBLANKNAME

struct search_global {			/* sort of allocated statics	*/
   long opts[OPT_COUNT];
   long crout,				/* last line had CR, not '\n'   */
	pdirs;				/* print dirs (& indent etc)    */
   BPTR curfile;
   long pattern;			/* searching contents of file	*/
   long name;		 		/* matching filenames		*/
   long foundmatch;			/* init false, controls rc	*/
   long filtering;			/* called with input redirected */
   long noterm;				/* line not terminated, LF or 0 */
   long lcount;				/* current line number in curfile */
   char search[LINESIZE];		/* processed search template	*/
   char line[LINESIZE+4];		/* current line from file	*/
   char temp[LINESIZE+4];		/* work space for a line	*/
   char blankline[BLANK_COUNT+1];	/* blankline[BLANK_COUNT] == '\0'*/
   char fpath[FPATHSIZE+1];		/* full path to current file	*/
   };

void prepargs(struct DosLibrary *DOSBase, struct search_global *glob);
int dosearch(struct DosLibrary *DOSBase, struct search_global *glob);
void TFPN(struct DosLibrary *DOSBase, struct search_global *glob, BPTR lock);
unsigned long StrMovToUpper(char *mptr, char *uptr);
int filter(struct DosLibrary *DOSBase, struct search_global *glob);
int getline(struct DosLibrary *DOSBase, struct search_global *glob);

int cmd_search(void)
/*	------								*/
{
struct DosLibrary *DOSBase;
struct Library *SysBase = (*((struct Library **) 4));
struct RDargs *rdargs;
struct CommandLineInterface *cli;
int rc, rc2;
struct search_global glob;

rc = RETURN_FAIL;
if ((DOSBase = (struct DosLibrary *)OpenLibrary(DOSLIB, DOSVER))) {
   memset((char *)&glob, '\0', sizeof(glob));
   memset((char *)&glob.blankline[0], ' ', BLANK_COUNT);

   /* if input is redirected, function as a filter			*/
   cli = Cli();
   glob.filtering = ((cli->cli_StandardInput != Input()));
   /* on second thought, what if we're running under AREXX and we have	*/
   /* a modified file handle for the same console???			*/
   if (glob.filtering)
      if (IsInteractive(cli->cli_StandardInput)
       && IsInteractive(Input()))
         if (((struct FileHandle *)BADDR(cli->cli_StandardInput))->fh_Type
          == ((struct FileHandle *)BADDR(Input()))->fh_Type)
            glob.filtering = 0;

   if (glob.filtering) {
      rdargs = ReadArgs(TEMPLATE2, (long *)&glob.opts[1], NULL);
      /* rearrange results to line up with standard template		*/
      glob.opts[PATTERN] = glob.opts[ALL];
      glob.opts[ALL] = 0;
      }
   else
      rdargs = ReadArgs(TEMPLATE, (long *)&glob.opts[0], NULL);
   if (rdargs == NULL) {
      rc2 = IoErr();
      PrintFault(rc2, NULL);
      }
   else {
      if (strlen((char *)glob.opts[SEARCH]) > 255)
         PutStr(MSG_SRCH_ARG_ERR);
      else {
         prepargs(DOSBase, &glob);

         if (glob.filtering)
            rc2 = filter(DOSBase, &glob);
         else {
            rc2 = dosearch(DOSBase, &glob);
            if (glob.crout)
            /* Erase last unmatched filename (from QUICK option)	*/
            PutStr("\r\033[K");
            }
         if (rc2) PrintFault(rc2, NULL);
         else	/* everything went OK					*/
            if (glob.foundmatch) rc = RETURN_OK;
            else rc = RETURN_WARN;
         }
      FreeArgs(rdargs);
      }
   CloseLibrary((struct Library *)DOSBase);
   }
else {OPENFAIL;}
return(rc);
}

void prepargs(struct DosLibrary *DOSBase, struct search_global *glob)
/*  --------								*/
/* check arguments in command line for valid input and put things into	*/
/* easier form for processing.						*/
{
char *optr, *sptr;
unsigned long l;

sptr = glob->search;
optr = (char *)glob->opts[SEARCH];
if (glob->opts[FILE])
   /* search arg will be used to match file names			*/
   glob->name = 1;
else
   {
   /* search arg will be used to match file contents			*/
   glob->pattern = 1;
   *sptr++ = P_ANY;	/* match anywhere within a line in the file	*/
   }
if (glob->opts[PATTERN] || glob->opts[FILE])
   {
   ParsePattern(optr, glob->temp, LINESIZE);
   optr = glob->temp;
   }
l = StrMovToUpper(optr, sptr);
if (!glob->opts[FILE])
   sptr[l] = P_ANY;

/* do not support QUICK or QUIET with FILE				*/
if (glob->opts[FILE])
   {
   glob->opts[QUICK] = 0;
   glob->opts[QUIET] = 0;
   }

/* control layouts depending on interaction of options			*/

if (glob->pattern && (glob->opts[QUICK] == 0) && (glob->opts[QUIET] == 0))
   /* use indented layout when searching contents unless QUICK or QUIET */
   glob->pdirs = 1;

if (glob->opts[FILE] && (glob->name == 0))
   /* also use indented layout for FILE with no NAME argument		*/
   glob->pdirs = 1;
}

int dosearch(struct DosLibrary *DOSBase, struct search_global *glob)
/*  --------								*/
{
struct Library *SysBase = (*((struct Library **) 4));
struct AnchorPath *anchor;
long pargs[3];
char **optptr;
char *fptr;
char *indent;
char *twodots = "..\n";
char *erase_eol = "\033[K\r";
char *newln = "\n";
char *dirstr = " (dir)\n";
char *alldir[2];
BPTR oldlock;
int frc, dothisfile, sres, depth, getpath = 0;
int justonearg = FALSE;
int justonefile = FALSE;

if ((anchor = AllocVec(sizeof(struct AnchorPath), MEMF_CLEAR)) == 0)
	/* plausible description of what happened			*/
   return ERROR_NO_FREE_STORE;

optptr = (char **)glob->opts[FROM];
/* if user did not specify FROM (path) argument default to current dir	*/
if (!optptr || (*optptr == 0))
{
   alldir[0] = "#?";
   alldir[1] = NULL;
   optptr = alldir;
   }
else
   /* only one path argument given by user				*/
   if (optptr[1] == 0) justonearg = TRUE;

while ((fptr = *optptr++) != 0) {

   pargs[1] = (long)&(anchor->ap_Info.fib_FileName);
   indent = (char *)&(glob->blankline[BLANK_COUNT-3]);
   depth = 0;
   /* if not standard indenting, need to initialize directory path	*/
   if (!glob->pdirs)getpath = 1;
   memset((char *)anchor, 0, sizeof(struct AnchorPath));
   anchor->ap_BreakBits = SIGBREAKF_CTRL_C;
   anchor->ap_Flags = APF_DOWILD;

   if (MatchFirst(fptr, anchor))
      frc = IoErr();
   else {
      frc = 0;
      justonefile =
         (justonearg &&
         (anchor->ap_Info.fib_DirEntryType < 0) &&
	 (!(anchor->ap_Flags & APF_ITSWILD))) ;
   }

   while (frc == 0) {
      if (anchor->ap_Info.fib_DirEntryType < 0) {        /*file*/
         /* If directory lock has changed and we are printing the path	*/
         /* for every file (QUICK or QUIET option) refresh the path.	*/
         /* Also need to do something for standard indented format, but	*/
         /* a bit too complicated to throw in at the last minute, and	*/
         /* in an case would like more support from MatchFirst/Next or	*/
         /* utility routines to do the genealogy of the directory lock	*/
         if (anchor->ap_Flags & APF_DirChanged) {
            if (!glob->pdirs) getpath = 1;
            }
	 if (glob->name) {
	    StrMovToUpper(anchor->ap_Info.fib_FileName, glob->temp);
	    dothisfile = MatchPattern(glob->search, glob->temp);
            if (dothisfile && !glob->pattern) glob->foundmatch = DOSTRUE;
	    }
         else
            /* process all files if matching contents instead of names	*/
            dothisfile = 1;
	 if (dothisfile) {
	    pargs[0] = (long)indent;
	    if (glob->pdirs) {    /* default indenting style              */
	       pargs[2] = (long)twodots;
	    }
	    else if (glob->opts[QUICK]) {
		  pargs[2] = (long)erase_eol; /* erase to EOL, no lf    */
		  glob->crout = 1;	  /* missing CR outstanding	*/
	    }
	    else {	/* QUIET or most instances of FILE		*/
		pargs[2] = (long)newln;
	    }

            /* print the filename now unless QUIET option was specified */
            /* by itself or the search path was a single file		*/
	    if ((glob->opts[QUIET] == 0 || glob->opts[QUICK] != 0)) {
               if (justonefile)
                  #ifndef NOBLANKNAME
                  PutStr("\n")
                  #endif
                  ;
               else {
	          /* only invoke NameFromLock() if we need to              */
	          if (getpath) {
		     TFPN(DOSBase, glob, anchor->ap_Current->an_Lock);
		     indent = glob->fpath;
		     pargs[0] = (long)indent;
		     getpath = 0;
		     }
	          VPrintf("%s%s%s", pargs);
	          }
	       }
            /* see if we're matching file contents instead of names	*/
	    if (glob->pattern) {
	       oldlock = CurrentDir(anchor->ap_Current->an_Lock);
	       glob->curfile =
		     Open(anchor->ap_Info.fib_FileName, MODE_OLDFILE);
	       if (glob->curfile == 0)
                  PrintFault(IoErr(), anchor->ap_Info.fib_FileName);
	       else {
		  sres = 0;
		  glob->lcount =  0;
		  glob->noterm =  0;
		  while (getline(DOSBase, glob)) {
		     if (MatchPattern(glob->search, glob->temp)) {
                        glob->foundmatch = DOSTRUE;
                        /* no need to half shift this line		*/
                        if (glob->noterm)
                           glob->noterm = -1;

			if (glob->opts[QUIET]) {
                        /* print name now that we have a contents match	*/
                           /* if QUICK also specified, name is already  */
                           /* printed but without a carriage return     */
                           if (glob->opts[QUICK])
                              PutStr("\n");
			   /* only invoke NameFromLock() if we need to  */
			   if (getpath) {
			      TFPN(DOSBase, glob, anchor->ap_Current->an_Lock);
			      indent = glob->fpath;
			      pargs[0] = (long)indent;
			      getpath = 0;
			      }
			   VPrintf("%s%s%s", pargs);
			   break;	/* one match is all we need	*/
			   }
			else {
			   if (glob->crout) {
			      PutStr("\n");       /* need a line feed	*/
			      glob->crout = 0;
			      }
			   if (glob->opts[NONUM]==0) {
                              /* print line number			*/
                              VPrintf("%6ld ", &glob->lcount);
                              }

			   PutStr(glob->line);
			   }
			}
		     if (sres=CheckSignal(SIGBREAKF_CTRL_C | SIGBREAKF_CTRL_D))
			break;	  /* close this file, and maybe quit	*/
		     }
		  Close(glob->curfile);
		  if (sres & SIGBREAKF_CTRL_C) frc = ERROR_BREAK;
		  else if (sres & SIGBREAKF_CTRL_D)
		     PutStr(MSG_FILE_ABANDONED);
		  }
       	       CurrentDir(oldlock);
	       }
	    }
	 }
      else {	/*  dir  */
	 if (anchor->ap_Flags & APF_DIDDIR) {
	    /* exiting a directory, clean up				*/
	    if (glob->pdirs) indent = indent+5;
	    else getpath = 1;
	       /* signal need to restore previous directory path	*/
	    depth = depth-1;
	    anchor->ap_Flags &= ~APF_DIDDIR;
	    }
	 else {
	    /* first time we've seen this directory - print it or enter */
	    /* it or whatever...					*/
	    if (glob->pdirs) {
	       pargs[0] = (long)indent - 2;
	       pargs[2] = (long)dirstr;
               if (anchor->ap_Info.fib_FileName[0] != 0)
	          VPrintf("%s%s%s", pargs);
               else
                  /* suppress first level indenting for devices or	*/
                  /* blank file names, eg : or ""			*/
                  indent += 5;
	       }
	    if (glob->opts[ALL]
	       || ((depth == 0) && !(anchor->ap_Flags & APF_ITSWILD))) {
	       anchor->ap_Flags |= APF_DODIR;
	       depth = depth+1;
	       if (depth > SEARCH_DEPTH) frc = ERROR_BUFFER_OVERFLOW;
	       if (glob->pdirs) indent = indent-5;

	       else {
		  /* signal need to set up new directory path		*/
		  getpath = 1;
		  }
	       }
	    }
	 }
      /* as long as there's been no error, go around again              */
      if (frc == 0)
         if(MatchNext(anchor)) frc = IoErr();
      }
   if (frc == ERROR_NO_MORE_ENTRIES) frc = 0;
   MatchEnd(anchor);

   if (frc != 0)
      /* trouble somewhere, or maybe ^C - bail out			*/
      break;
   }

   FreeVec(anchor);
   return frc;	/* 0 means no problems in this directory		*/
}

void TFPN(struct DosLibrary *DOSBase, struct search_global *glob, BPTR lock)
/*   ----								*/
/*  put Terminated Full Path Name for lock in glob->fpath		*/
{
char *fnptr = glob->fpath;

NameFromLock(lock, fnptr, FPATHSIZE);
while (*fnptr++);
fnptr-=2;
if (*fnptr != ':')
   *++fnptr = '/';
*++fnptr = '\0';
}


unsigned long StrMovToUpper(char *mptr, char *uptr)
/*	      -------------						*/
{
unsigned long l = 0;
register unsigned char c, la = 'a', lz = 'z', cd = 'a'-'A';

while(c = *mptr)
   {
   if (c >= la)
      if (c <= lz)
         c -= cd;
   *uptr = c;

   uptr++;
   l++;
   mptr++;
   }
*uptr = 0;
return l;
}



int filter (struct DosLibrary *DOSBase, struct search_global *glob)
/*  ------								*/
/* try to match search string against lines read in from redirected	*/
/* standard input as a filter						*/
{
int  sres;
sres = 0;		/* initialize return code			*/
glob->lcount = 0;	/* initialize line counter			*/
glob->curfile = Input();
glob->noterm = 0;

while (getline(DOSBase,glob)) {
   if (MatchPattern(glob->search, glob->temp)) {
      glob->foundmatch = DOSTRUE;
      /* no need to half shift this line				*/
      if (glob->noterm)
         glob->noterm = -1;
      if (glob->opts[NONUM]==0) VPrintf("%6ld ", &glob->lcount);
      PutStr(glob->line);
      }
   if (sres=CheckSignal(SIGBREAKF_CTRL_C | SIGBREAKF_CTRL_D))
      break;	  /* close this file, and maybe quit			*/
   }

if (sres & SIGBREAKF_CTRL_C) return ERROR_BREAK;
else return 0;
}



int getline(struct DosLibrary *DOSBase, struct search_global *glob)
/*  -------								*/
/* Read a 'line' from glob->curfile into glob->line and glob->temp.	*/
/* Translate glob->temp to upper case for pattern matching.  Terminate	*/
/* glob->line with '/n' in case we need to print it.  If previous line	*/
/* was not terminated by '\n' or '\0', assume this is a binary file and	*/
/* step half a line at a time to ensure we will catch instances of the	*/
/* search pattern that happen to span a buffer.  Maintain line count in	*/
/* glob->lcount based on number of '\n' encountered.			*/
{
char *bufptr, *bufpt2;
BPTR curfile;
long c, ccount;

curfile = glob->curfile;

if (glob->noterm >0) { /* means previous 'line' was unterminated	*/
   /* move top half of line buffer to bottom and ignore old '\0'	*/
   memcpy(&glob->line[0], &glob->line[LINESIZE/2], LINESIZE/2);
   memcpy(&glob->temp[0], &glob->temp[LINESIZE/2], LINESIZE/2);

   bufptr = &glob->line[LINESIZE/2];
   bufpt2 = &glob->temp[LINESIZE/2];
   ccount = LINESIZE/2;
   }
else {
   /* previous buffer was terminated - start fresh			*/
   bufptr = glob->line;
   bufpt2 = glob->temp;
   ccount = LINESIZE;
   if (glob->noterm == 0) { /* terminated by '\n', not '\0'?		*/
      *bufpt2 = '\n'; /* put '\n' at start of line for pattern match	*/
      bufpt2++;
      }
   }
c = FGetC(curfile);
/* if we're at end of file now, return					*/
if (c == -1) return 0;
while ((c > 0) && (c != '\n')) {
   if ((c >= (long)'a') && (c <= (long)'z')) {
      /* store line as upper case for pattern matching			*/
      *bufpt2 = c + (long)('A' - 'a');
      }
   else {
      /* case conversion not required					*/
      *bufpt2 = c;
      }
   bufpt2 += 1;
   /* filter out NUL and control characters with or without high bit	*/
   if (((c + 1) & 0x7f) <= ' ')
      if (c != '\t') {
         /* placeholder for output					*/
         c = '.';
         }
   *bufptr = c;
   bufptr += 1;
   ccount -= 1;
   if (ccount <= 0) break;
   c = FGetC(curfile);
   }

/* assume unterminated line - otherwise will be changed below		*/
glob->noterm = 1;
/* always return null terminated strings with '\n' as well on line	*/
/* line (for possible printing purposes)				*/
*bufptr = '\n';
bufptr += 1;
*bufptr = '\0';
/* temp	(for matching against search pattern)				*/
if (c == '\n') {
   /* only criterion for incrementing line count			*/
   *bufpt2 = '\n';	/* need to include '\n' for pattern matching	*/
   bufpt2++;
   glob->lcount += 1;
   glob->noterm = 0;	/* indicate line terminated by '\n'		*/
   }
if (c == '\0') {
   /* must treat this as a terminator to find strings in binary files	*/
   glob->noterm = -1;	/* indicate line terminated by '\0'		*/
   }
*bufpt2 = '\0';
/* found something - return TRUE to process whether EOF or not.		*/
return 1;
}



#if 0
void aprintf( fmt, args )
char *fmt, *args;
{
   struct Library *DOSBase;
   struct Library *SysBase = (*((struct Library **) 4));

   if(DOSBase=OpenLibrary(DOSLIB,DOSVER)) {
       VFPrintf(Output(), fmt, (LONG *)&args );
       CloseLibrary(DOSBase);
   }
}
#endif

@


1.17
log
@Use APF_DirChanged to keep path correct for QUICK & QUIET options
eg Search :#?/#? fubar QUICK
Fix bad pointer dereference -> Enforcer hit, bug B12653
@
text
@d139 1
a139 1
         if (((struct FileHandle *)BADDR(cli->cli_StandardInput))->fh_Type 
d216 1
a216 1
   
d253 2
a254 1
if (*optptr == 0) {
d260 1
a260 1
   /* only one path argument given by user				*/ 
d274 1
a274 1
   if (MatchFirst(fptr, anchor)) 
d276 1
a276 1
   else { 
d278 1
a278 1
      justonefile = 
d283 1
a283 1
   
d422 1
a422 1
		  
d431 1
a431 1
      if (frc == 0) 
d596 1
a596 1
return 1; 
d598 2
a599 2
 
 
@


1.16
log
@Improve handling of *N in patterns (eg allow "(*N| )pattern")
@
text
@d53 2
d260 1
a260 1
   if (*optptr[1] == 0) justonearg = TRUE;
d285 9
@


1.15
log
@Fix B11966 by allowing *N (newline) at start or end of Search string
Fix B12158 (crash on redirected output) due to misplaced unlock
Change unambiguous file path to no blank line
@
text
@d52 1
d197 1
a197 5
   /* Allow user to specify search argument  is left anchored		*/
   if (*(char *)(glob->opts[SEARCH]) == '\n')
      optr++;
   else
      *sptr++ = P_ANY;	/* match anywhere within a line in the file	*/
d205 2
a206 7
if (!glob->opts[FILE]) {
   /* See if search argument is right anchored				*/
   if (sptr[l-1] == '\n')
      sptr[l-1] = '\0';
   else
      sptr[l] = P_ANY;
   }
d338 3
a340 1
                        glob->noterm = 0;
d487 2
a488 1
      glob->noterm = 0;
d518 1
a518 1
if (glob->noterm) {
d532 4
a570 1
*bufpt2 = '\0';
d573 2
d576 1
a576 1
   glob->noterm = 0;
d580 1
a580 1
   glob->noterm = 0;
d582 1
@


1.14
log
@Don't do filtering by mistake when invoked by AREXX (B10867)
Don't print file name if more than one FROM multiarg (B11608)
@
text
@d50 2
d84 2
a85 1
/*
a86 1
*/
d188 1
d196 5
a200 1
   *sptr++ = P_ANY;	/* match anywhere within a line in the file	*/
d204 1
a204 1
   ParsePattern((char *)glob->opts[SEARCH], glob->temp, LINESIZE);
a206 2
else
   optr = (char *)glob->opts[SEARCH];
d208 7
a214 2
if (!glob->opts[FILE])
   sptr[l] = P_ANY;
a379 1
		  CurrentDir(oldlock);
d384 1
@


1.13
log
@check for long search argument to prevent memory overwrite (B10867)
make QUICK option work correctly with QUIET option (B10622)
@
text
@d48 2
a57 2
#define KLUDGE 

d79 7
d128 9
a136 9
   glob.filtering = (
      (cli->cli_StandardInput != Input()) 
#ifdef KLUDGE 
      ||
      (((struct FileHandle *)
      BADDR(cli->cli_StandardInput))->fh_Type 
      != ((struct FileHandle *)BADDR(Input()))->fh_Type) 
#endif 
      );
a229 1
/*BPTR savefh;*/
d239 2
a240 1
int frc, dothisfile, /*lres,*/ sres, /*lcount,*/ depth, getpath = 0/*, fpl*/;
d254 4
d274 2
a275 1
         ((anchor->ap_Info.fib_DirEntryType < 0) &&
d304 16
a319 10
	    if ((glob->opts[QUIET] == 0 || glob->opts[QUICK] != 0)
                 && !justonefile) {
	       /* only invoke NameFromLock() if we need to              */
	       if (getpath) {
		  TFPN(DOSBase, glob, anchor->ap_Current->an_Lock);
		  indent = glob->fpath;
		  pargs[0] = (long)indent;
		  getpath = 0;
		  }
	       VPrintf("%s%s%s", pargs);
a320 1

@


1.12
log
@*** empty log message ***
@
text
@d46 2
d59 1
d144 4
a147 1
      prepargs(DOSBase, &glob);
d149 12
a160 7
      if (glob.filtering)
         rc2 = filter(DOSBase, &glob);
      else {
         rc2 = dosearch(DOSBase, &glob);
         if (glob.crout)
         /* Don't leave cursor hanging somewhere odd           		*/
            PutStr("\n");
a161 5

      if (rc2) PrintFault(rc2, NULL);
      else	/* everything went OK					*/
         if (glob.foundmatch) rc = RETURN_OK;
         else rc = RETURN_WARN;
a204 3

if (glob->opts[QUIET])
   glob->opts[QUICK] = 0;
d291 3
a293 1
	    if (glob->opts[QUIET] == 0 && !justonefile) {
d322 4
@


1.11
log
@Restore printing of chars with high bit set (was removed by
version 1.10 as part of handling binary files)
@
text
@d43 3
d54 2
d118 9
a126 1
   glob.filtering = (cli->cli_StandardInput != Input());
d200 3
d231 1
d255 9
a263 2
   if (MatchFirst(fptr, anchor)) frc = IoErr();
   else frc = 0;
d288 1
a288 1
	    if (glob->opts[QUIET] == 0) {
@


1.10
log
@Fix B9422 - Search now finds text strings in binary files
@
text
@d491 2
a492 3
   /* now filter unprintable characters if any				*/
   c &= 0x7f;
   if (c < ' ')
d507 1
a507 1
/* line									*/
d511 1
a511 1
/* temp									*/
@


1.9
log
@Fix B10100 - "abandonned" should be spelled "abandoned"
@
text
@a50 1
#define MSG_OPEN_FAILED		"Couldn't open file\n"
a75 1
   char search[LINESIZE];
d80 5
d94 1
a157 1
char temp[LINESIZE];
d171 2
a172 2
   ParsePattern((char *)glob->opts[SEARCH], temp, LINESIZE);
   optr = temp;
d204 1
a204 1
BPTR savefh;
d214 1
a214 3
int frc, dothisfile, lres, sres, lcount, depth, getpath = 0/*, fpl*/;
char temp[LINESIZE];	/* place to convert strings to upper case	*/
char line[LINESIZE];	/* current line to match from a file		*/
d243 2
a244 2
	    StrMovToUpper(anchor->ap_Info.fib_FileName, temp);
	    dothisfile = MatchPattern(glob->search, temp);
d281 1
a281 1
		  PutStr(MSG_OPEN_FAILED);
d284 4
a287 8
		  lcount = 0;
		  savefh = SelectInput(glob->curfile);
		  while (FGets(Input(),line, LINESIZE)) {
		     lres=strlen(line);
		     lcount++;
		     if(line[lres-1] != 0)line[lres - 1] = '\0';
		     StrMovToUpper(line, temp);
		     if (MatchPattern(glob->search, temp)) {
d289 2
d308 6
a313 3
			   if (glob->opts[NONUM]==0)VPrintf("%6ld ", &lcount);
			   PutStr(line);
			   PutStr("\n");
a320 1
		  SelectInput(savefh);
d423 5
a427 2
int lres, lcount, sres;
char line[LINESIZE], temp[LINESIZE];
d429 2
a430 9
sres = 0;	/* initialize return code				*/
lcount = 0;	/* initialize line counter				*/

while (FGets(Input(),line, LINESIZE)) {
   lres=strlen(line);
   lcount++;
   if(line[lres-1] != 0) line[lres - 1] = '\0';
   StrMovToUpper(line, temp);
   if (MatchPattern(glob->search, temp)) {
d432 4
a435 3
      if (glob->opts[NONUM]==0) VPrintf("%6ld ", &lcount);
      PutStr(line);
      PutStr("\n");
d446 82
@


1.8
log
@New version from John Toebes.
Note: Added definitions for SysBase.
@
text
@d52 1
a52 1
#define MSG_FILE_ABANDONNED	"** File abandonned\n"
d322 1
a322 1
		     PutStr(MSG_FILE_ABANDONNED);
@


1.7
log
@no changes
@
text
@d2 1
a2 1
lc -d2 -j73 -O -o/obj/Search.o -i/include -rr -v -cusf Search
d40 3
d54 2
a55 1
#define TEMPLATE    "FROM/A/M,SEARCH/A,ALL/S,NONUM/S,QUIET/S,QUICK/S,FILE/S,PATTERN/S" CMDREV
d80 2
d90 1
a91 1

d98 1
d106 4
a109 1
   rdargs = ReadArgs(TEMPLATE, (long *)&glob.opts[0], NULL);
d111 8
d126 8
a133 4
      rc2 = dosearch(DOSBase, &glob);
      if (glob.crout)
      /* Don't leave cursor hanging somewhere odd              		*/
         PutStr("\n");
d136 3
a138 1
      else rc = 0;	/* everything went OK				*/
d196 1
d206 1
a206 1
char *erase_eol = "[K\r";
d209 1
d217 1
a217 1
   return ERROR_BUFFER_OVERFLOW;
d220 6
d237 2
a238 1
   frc = MatchFirst(fptr, anchor);
d244 1
d280 1
a280 1
		  VPrintf(MSG_OPEN_FAILED, NULL);
d291 1
d310 1
a310 1
			   VPrintf(line, NULL);
d320 1
a320 1
		  if (sres & SIGBREAKF_CTRL_C)frc = ERROR_BREAK;
d330 1
a330 1
	    if (glob->pdirs)indent = indent+5;
d342 6
a347 1
	       VPrintf("%s%s%s", pargs);
d353 1
a353 1
	       if (depth > SEARCH_DEPTH)frc = ERROR_BUFFER_OVERFLOW;
d364 2
a365 1
      if (frc == 0)frc = MatchNext(anchor);
d367 1
a367 1
   if (frc == ERROR_NO_MORE_ENTRIES)frc = 0;
d375 1
a375 1
    FreeVec(anchor);
d413 32
@


1.6
log
@new version from Software Distillery
@
text
@@


1.5
log
@*** empty log message ***
@
text
@d46 2
a80 1

a81 1

d83 1
a84 1
unsigned long StrMovToUpper(char *mptr, char *uptr);
d96 1
a96 2
if ((DOSBase = (struct DosLibrary *)OpenLibrary(DOSLIB, DOSVER)))
   {
d101 1
a101 2
   if (rdargs == NULL)
      {
d105 1
a105 2
   else
      {
d113 2
a114 5
      if (rc2)
         PrintFault(rc2, NULL);
      else
         rc = 0;	/* everything went OK				*/

a116 1

d119 1
a119 2
else
   OPENFAIL;
a171 1
/*  --------								*/
d194 4
a197 4
while ((fptr = *optptr++) != 0)
   {
   pargs[1] = (long)&anchor->ap_Info.fib_FileName;
   indent = (char *)&glob->blankline[BLANK_COUNT-3];
d200 2
a201 3
   if (!glob->pdirs)
      getpath = 1;
   memset((char *)anchor, '\0', sizeof(struct AnchorPath));
d206 3
a208 6
   while (frc == 0)
      {
      if (anchor->ap_Info.fib_DirEntryType < 0)         /*file*/
	 {
	 if (glob->name)
	    {
d215 1
a215 2
	 if (dothisfile)
	    {
d217 1
a217 2
	    if (glob->pdirs)    /* default indenting style              */
	       {
d219 2
a220 4
	       }
	    else
	       if (glob->opts[QUICK])
		  {
d223 4
a226 5
		  }
	       else	/* QUIET or most instances of FILE		*/
		  {
		  pargs[2] = (long)newln;
		  }
d229 1
a229 2
	    if (glob->opts[QUIET] == 0)
	       {
d231 1
a231 2
	       if (getpath)
		  {
d241 1
a241 2
	    if (glob->pattern)
	       {
d247 1
a247 2
	       else
		  {
d256 2
a257 3
		     if (MatchPattern(glob->search, temp))
			{
			if (glob->opts[QUIET])
a258 1
			   {
d260 1
a260 2
			   if (getpath)
			      {
d269 2
a270 4
			else
			   {
			   if (glob->crout)
			      {
d274 1
a274 2
			   if (glob->opts[NONUM] == 0)
			      VPrintf("%6ld ", &lcount);
d285 1
a285 2
		  if (sres & SIGBREAKF_CTRL_C)
		     frc = ERROR_BREAK;
d292 2
a293 3
      else						/*dir */
	 {
	 if (anchor->ap_Flags & APF_DIDDIR)
d295 2
a296 4
	    {
	    if (glob->pdirs)
	       indent = indent+5;
	    else
a297 1
	       getpath = 1;
d301 1
a301 1
	 else
d304 1
a304 3
	    {
	    if (glob->pdirs)
	       {
d310 1
a310 2
	       || ((depth == 0) && !(anchor->ap_Flags & APF_ITSWILD)))
	       {
d313 4
a316 6
	       if (depth > SEARCH_DEPTH)
		  frc = ERROR_BUFFER_OVERFLOW;
	       if (glob->pdirs)
		  indent = indent-5;
	       else
		  {
d324 1
a324 2
      if (frc == 0)
	 frc = MatchNext(anchor);
d326 1
a326 3
   if (frc == ERROR_NO_MORE_ENTRIES)
      frc = 0;

d333 2
a334 1
   FreeVec(anchor);
d373 16
@


1.4
log
@changed use of Fgets to match ANSI
removed S shortcut in ReadArgs
@
text
@d273 1
a273 1
		  while (!FGets(Input(),line, LINESIZE)) {
@


1.3
log
@multiargs and wild cards working
@
text
@d49 1
a49 1
#define TEMPLATE    "FROM/A/M,S=SEARCH/A,ALL/S,NONUM/S,QUIET/S,QUICK/S,FILE/S,PATTERN/S" CMDREV
d273 2
a274 2
		  while (lres = FGets(Input(),line, LINESIZE))
		     {
d276 1
a276 1
		     line[lres - 1] = '\0';
@


1.2
log
@rewrite, faster, does find like functions
@
text
@d1 413
a413 418
; /*
lc -d2 -j73 -O -o/obj/Search.o -i/include -rr -v -cusf Search
blink /obj/Search.o to /bin/Search sc sd nd
protect /bin/Search +p
quit
*/

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* |_o_o|\\ Copyright (c) 1989 The Software Distillery.  All Rights Reserved */
/* |. o.| || This program may not be distributed without the permission of   */
/* | .	| || the authors:			      BBS: (919) 382-8265    */
/* | o	| ||   Dave Baker      Alan Beale	  Jim Cooper		     */
/* |  . |//    Jay Denebeim    Bruce Drake	  Gordon Keener 	     */
/* ======      John Mainwaring Andy Mercier	  Jack Rouse		     */
/*	       John Toebes     Mary Ellen Toebes  Doug Walker		     */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**	(C) Copyright 1989 Commodore-Amiga, Inc.
 **	    All Rights Reserved
**/

/*---------------------------------------------------------------------------*/
/* Command: Search							     */
/* Author:  John Mainwaring						     */
/* Change History:							     */
/*  Date    Person	  Action					     */
/* -------  ------------- -----------------				     */
/* 19MAR89  John Toebes   Initial Creation				     */
/* 19apr89 John Mainwaring first compilable stub			     */
/* 30Jul89 John Mainwaring create name & pattern elements		s15  */
/* 14NOV89 John Mainwaring compilable under dos1.4 (not working)        a1   */
/* 04DEC89 John Mainwaring parse parameters and dump debug info 	a2   */
/* 07DEC89 John Mainwaring version released for dos1.4 beta		a3   */
/* 11FEB90 John Mainwaring tidy up global structure			b1   */
/* 12FEB90 John Mainwaring cut down on allocated store			b2   */
/* 21FEB90 John Mainwaring Tidy up for release				b3   */
/* Notes:								     */
/*---------------------------------------------------------------------------*/

#include "internal/commands.h"
#include "search_rev.h"

#define MSG_OPEN_FAILED		"Couldn't open file\n"
#define MSG_FILE_ABANDONNED	"** File abandonned\n"

#define TEMPLATE    "FROM,S=SEARCH,ALL/S,NONUM/S,QUIET/S,QUICK/S,FILE/S,PATTERN/S" CMDREV

#define OPT_COUNT	8
#define SEARCH_DEPTH	25
#define BLANK_COUNT	(SEARCH_DEPTH + 1) * 5
#define INBUFFSIZE	8000
#define LINESIZE	256
#define NAMESIZE	40
#define FPATHSIZE	256

#define FROM	0
#define SEARCH	FROM+1
#define ALL	SEARCH+1
#define NONUM	ALL+1
#define QUIET	NONUM+1
#define QUICK	QUIET+1
#define FILE	QUICK+1
#define PATTERN FILE+1

struct search_global {		/* sort of allocated statics	*/
   long opts[OPT_COUNT];
   long crout,				/* last line had CR, not '\n'   */
	pdirs;				/* print dirs (& indent etc)    */
   BPTR curfile;
   char search[LINESIZE];
   long pattern;			/* searching contents of file	*/
   long name;		 		/* matching filenames		*/
   char blankline[BLANK_COUNT+1];	/* blankline[BLANK_COUNT] == '\0'*/
   char fpath[FPATHSIZE+1];		/* full path to current file	*/
   };

int prepargs(struct DosLibrary *DOSBase, struct search_global *glob);

int dosearch(struct DosLibrary *DOSBase, struct search_global *glob);

void TFPN(struct DosLibrary *DOSBase, struct search_global *glob, BPTR lock);

unsigned long StrMovToUpper(char *mptr, char *uptr);

int cmd_search(void)
/*	------							*/
{
struct DosLibrary *DOSBase;
struct RDargs *rdargs;
int rc, rc2;
struct search_global glob;

rc = RETURN_FAIL;
if ((DOSBase = (struct DosLibrary *)OpenLibrary(DOSLIB, DOSVER)))
   {
   memset((char *)&glob, '\0', sizeof(glob));
   memset((char *)&glob.blankline[0], ' ', BLANK_COUNT);
   rdargs = ReadArgs(TEMPLATE, (long *)&glob.opts[0], NULL);

   if (rdargs == NULL)
      {
      rc2 = IoErr();
      PrintFault(rc2, NULL);
      }
   else
      {
      rc2 = prepargs(DOSBase, &glob);
      if (rc2 == 0)
         {
         rc2 = dosearch(DOSBase, &glob);
         if (glob.crout)
         /* Don't leave cursor hanging somewhere odd              	*/
            PutStr("\n");
         }

      if (rc2)
         PrintFault(rc2, NULL);
      else
         rc = 0;	/* everything went OK				*/

      FreeArgs(rdargs);
      }

   CloseLibrary((struct Library *)DOSBase);
   }
else
   OPENFAIL;
return(rc);
}

int prepargs(struct DosLibrary *DOSBase, struct search_global *glob)
/*  --------								*/
/* check arguments in command line for valid input and put things into	*/
/* easier form for processing.						*/
{
char *optr, *sptr;
unsigned long l;
char temp[LINESIZE];

if (glob->opts[SEARCH])
   {
   sptr = glob->search;
   if (glob->opts[FILE])
      /* search arg will be used to match file names			*/
      glob->name = 1;
   else
      {
      /* search arg will be used to match file contents			*/
      glob->pattern = 1;
      *sptr++ = P_ANY;	/* match anywhere within a line in the file	*/
      }
   if (glob->opts[PATTERN] || glob->opts[FILE])
      {
      ParsePattern((char *)glob->opts[SEARCH], temp, LINESIZE);
      optr = temp;
      }
   else
      optr = (char *)glob->opts[SEARCH];
   l = StrMovToUpper(optr, sptr);
   if (!glob->opts[FILE])
      sptr[l] = P_ANY;
   }

/* must have either FROM or SEARCH arg	- might change this requirement */
if ((glob->opts[FROM] == 0) && (glob->opts[SEARCH] == 0))
   return ERROR_REQUIRED_ARG_MISSING;

/* do not support QUICK or QUIET with FILE				*/
if (glob->opts[FILE])
   {
   glob->opts[QUICK] = 0;
   glob->opts[QUIET] = 0;
   }

/* control layouts depending on interaction of options			*/

if (glob->pattern && (glob->opts[QUICK] == 0) && (glob->opts[QUIET] == 0))
   /* use indented layout when searching contents unless QUICK or QUIET */
   glob->pdirs = 1;

if (glob->opts[FILE] && (glob->name == 0))
   /* also use indented layout for FILE with no NAME argument		*/
   glob->pdirs = 1;

/* seem to want content matches but didn't specify a pattern            */
/* nothing useful to do 						*/
if ((glob->pattern == 0) && (glob->opts[FILE] == 0))
   return ERROR_REQUIRED_ARG_MISSING;

/* need a symbol ERROR_NO_ERROR - and NULL (being a pointer) ain't it   */
return 0;
}

int dosearch(struct DosLibrary *DOSBase, struct search_global *glob)
/*  --------								*/
{
struct AnchorPath *anchor;
long pargs[3];
BPTR savefh;
char *indent;
char *twodots = "..\n";
char *erase_eol = "[K\r";
char *newln = "\n";
char *dirstr = " (dir)\n";
BPTR oldlock;
int frc, dothisfile, lres, sres, lcount, depth, getpath = 0/*, fpl*/;
char temp[LINESIZE];	/* place to convert strings to upper case	*/
char line[LINESIZE];	/* current line to match from a file		*/

indent = (char *)&glob->blankline[BLANK_COUNT-3];
depth = 0;
/* if not standard indenting, signal need to initialize directory path	*/
if (!glob->pdirs)
   getpath = 1;

if (anchor = AllocVec(sizeof(struct AnchorPath)+255, MEMF_CLEAR))
   {
   pargs[1] = (long)&anchor->ap_Info.fib_FileName;
   anchor->ap_BreakBits = SIGBREAKF_CTRL_C;
   anchor->ap_Strlen = 255;	/* Causes trouble if less than LINESIZE	*/
   anchor->ap_Flags = APF_DOWILD;
   frc = MatchFirst((char *)glob->opts[FROM], anchor);
   while (frc == 0)
      {
      if (anchor->ap_Info.fib_DirEntryType < 0)         /*file*/
	 {
	 if (glob->name)
	    {
	    StrMovToUpper(anchor->ap_Info.fib_FileName, temp);
	    dothisfile = MatchPattern(glob->search, temp);
	    }
         else
            /* process all files if matching contents instead of names	*/
            dothisfile = 1;
	 if (dothisfile)
	    {
	    pargs[0] = (long)indent;
	    if (glob->pdirs)    /* default indenting style              */
	       {
	       pargs[2] = (long)twodots;
	       }
	    else
	       if (glob->opts[QUICK])
		  {
		  pargs[2] = (long)erase_eol; /* erase to EOL, no lf    */
		  glob->crout = 1;	  /* missing CR outstanding	*/
		  }
	       else	/* QUIET or most instances of FILE		*/
		  {
		  pargs[2] = (long)newln;
		  }

            /* print the filename now unless QUIET option was specified */
	    if (glob->opts[QUIET] == 0)
	       {
	       /* only invoke NameFromLock() if we need to              */
	       if (getpath)
		  {
		  TFPN(DOSBase, glob, anchor->ap_Current->an_Lock);
		  indent = glob->fpath;
		  pargs[0] = (long)indent;
		  getpath = 0;
		  }
	       VPrintf("%s%s%s", pargs);
	       }

            /* see if we're matching file contents instead of names	*/
	    if (glob->pattern)
	       {
	       oldlock = CurrentDir(anchor->ap_Current->an_Lock);
	       glob->curfile =
		     Open(anchor->ap_Info.fib_FileName, MODE_OLDFILE);
	       if (glob->curfile == 0)
		  VPrintf(MSG_OPEN_FAILED, NULL);
	       else
		  {
		  sres = 0;
		  lcount = 0;
		  savefh = SelectInput(glob->curfile);
		  while (lres = FGets(Input(),line, LINESIZE))
		     {
		     lcount++;
		     line[lres - 1] = '\0';
		     StrMovToUpper(line, temp);
		     if (MatchPattern(glob->search, temp))
			{
			if (glob->opts[QUIET])
                        /* print name now that we have a contents match	*/
			   {
			   /* only invoke NameFromLock() if we need to  */
			   if (getpath)
			      {
			      TFPN(DOSBase, glob, anchor->ap_Current->an_Lock);
			      indent = glob->fpath;
			      pargs[0] = (long)indent;
			      getpath = 0;
			      }
			   VPrintf("%s%s%s", pargs);
			   break;	/* one match is all we need	*/
			   }
			else
			   {
			   if (glob->crout)
			      {
			      PutStr("\n");       /* need a line feed	*/
			      glob->crout = 0;
			      }
			   if (glob->opts[NONUM] == 0)
			      VPrintf("%6ld ", &lcount);
			   VPrintf(line, NULL);
			   PutStr("\n");
			   }
			}
		     if (sres=CheckSignal(SIGBREAKF_CTRL_C | SIGBREAKF_CTRL_D))
			break;	  /* close this file, and maybe quit	*/
		     }
		  Close(glob->curfile);
		  CurrentDir(oldlock);
		  SelectInput(savefh);
		  if (sres & SIGBREAKF_CTRL_C)
		     frc = ERROR_BREAK;
		  else if (sres & SIGBREAKF_CTRL_D)
		     PutStr(MSG_FILE_ABANDONNED);
		  }
	       }
	    }
	 }
      else						/*dir */
	 {
	 if (anchor->ap_Flags & APF_DIDDIR)
	    /* exiting a directory, clean up				*/
	    {
	    if (glob->pdirs)
	       indent = indent+5;
	    else
	       /* signal need to restore previous directory path	*/
	       getpath = 1;
	    depth = depth-1;
	    anchor->ap_Flags &= ~APF_DIDDIR;
	    }
	 else
	    /* first time we've seen this directory - print it or enter */
	    /* it or whatever...					*/
	    {
	    if (glob->pdirs)
	       {
	       pargs[0] = (long)indent - 2;
	       pargs[2] = (long)dirstr;
	       VPrintf("%s%s%s", pargs);
	       }
	    if (glob->opts[ALL]
	       || ((depth == 0) && !(anchor->ap_Flags & APF_ITSWILD)))
	       {
	       anchor->ap_Flags |= APF_DODIR;
	       depth = depth+1;
	       if (depth > SEARCH_DEPTH)
		  frc = ERROR_BUFFER_OVERFLOW;
	       if (glob->pdirs)
		  indent = indent-5;
	       else
		  {
		  /* signal need to set up new directory path		*/
		  getpath = 1;
		  }
	       }
	    }
	 }
      /* as long as there's been no error, go around again              */
      if (frc == 0)
	 frc = MatchNext(anchor);
      }
   if (frc == ERROR_NO_MORE_ENTRIES)
      frc = 0;

   MatchEnd(anchor);
   FreeVec(anchor);
   return frc;	/* 0 means no problems in this directory		*/
   }
else	/* plausible description of what happened			*/
   return ERROR_BUFFER_OVERFLOW;
}

void TFPN(struct DosLibrary *DOSBase, struct search_global *glob, BPTR lock)
/*   ----								*/
/*  put Terminated Full Path Name for lock in glob->fpath		*/
{
char *fnptr = glob->fpath;

NameFromLock(lock, fnptr, FPATHSIZE);
while (*fnptr++);
fnptr-=2;
if (*fnptr != ':')
   *++fnptr = '/';
*++fnptr = '\0';
}


unsigned long StrMovToUpper(char *mptr, char *uptr)
/*	      -------------						*/
{
unsigned long l = 0;
register unsigned char c, la = 'a', lz = 'z', cd = 'a'-'A';

while(c = *mptr)
   {
   if (c >= la)
      if (c <= lz)
         c -= cd;
   *uptr = c;

   uptr++;
   l++;
   mptr++;
   }
*uptr = 0;
return l;
}

@


1.1
log
@major overhaul
@
text
@d1 418
a418 418
; /*
lc -d2 -j73 -O -o/obj/Search.o -i/include -rr -v -cusf Search
blink /obj/Search.o to /bin/Search sc sd nd
protect /bin/Search +p
quit
*/

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* |_o_o|\\ Copyright (c) 1989 The Software Distillery.  All Rights Reserved */
/* |. o.| || This program may not be distributed without the permission of   */
/* | .	| || the authors:			      BBS: (919) 382-8265    */
/* | o	| ||   Dave Baker      Alan Beale	  Jim Cooper		     */
/* |  . |//    Jay Denebeim    Bruce Drake	  Gordon Keener 	     */
/* ======      John Mainwaring Andy Mercier	  Jack Rouse		     */
/*	       John Toebes     Mary Ellen Toebes  Doug Walker		     */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**	(C) Copyright 1989 Commodore-Amiga, Inc.
 **	    All Rights Reserved
**/

/*---------------------------------------------------------------------------*/
/* Command: Search							     */
/* Author:  John Mainwaring						     */
/* Change History:							     */
/*  Date    Person	  Action					     */
/* -------  ------------- -----------------				     */
/* 19MAR89  John Toebes   Initial Creation				     */
/* 19apr89 John Mainwaring first compilable stub			     */
/* 30Jul89 John Mainwaring create name & pattern elements		s15  */
/* 14NOV89 John Mainwaring compilable under dos1.4 (not working)        a1   */
/* 04DEC89 John Mainwaring parse parameters and dump debug info 	a2   */
/* 07DEC89 John Mainwaring version released for dos1.4 beta		a3   */
/* 11FEB90 John Mainwaring tidy up global structure			b1   */
/* 12FEB90 John Mainwaring cut down on allocated store			b2   */
/* 21FEB90 John Mainwaring Tidy up for release				b3   */
/* Notes:								     */
/*---------------------------------------------------------------------------*/

#include "internal/commands.h"
#include "search_rev.h"

#define MSG_OPEN_FAILED		"Couldn't open file\n"
#define MSG_FILE_ABANDONNED	"** File abandonned\n"

#define TEMPLATE    "FROM,S=SEARCH,ALL/S,NONUM/S,QUIET/S,QUICK/S,FILE/S,PATTERN/S" CMDREV

#define OPT_COUNT	8
#define SEARCH_DEPTH	25
#define BLANK_COUNT	(SEARCH_DEPTH + 1) * 5
#define INBUFFSIZE	8000
#define LINESIZE	256
#define NAMESIZE	40
#define FPATHSIZE	256

#define FROM	0
#define SEARCH	FROM+1
#define ALL	SEARCH+1
#define NONUM	ALL+1
#define QUIET	NONUM+1
#define QUICK	QUIET+1
#define FILE	QUICK+1
#define PATTERN FILE+1

struct search_global {		/* sort of allocated statics	*/
   long opts[OPT_COUNT];
   long crout,				/* last line had CR, not '\n'   */
	pdirs;				/* print dirs (& indent etc)    */
   BPTR curfile;
   char search[LINESIZE];
   long pattern;			/* searching contents of file	*/
   long name;		 		/* matching filenames		*/
   char blankline[BLANK_COUNT+1];	/* blankline[BLANK_COUNT] == '\0'*/
   char fpath[FPATHSIZE+1];		/* full path to current file	*/
   };

int prepargs(struct DosLibrary *DOSBase, struct search_global *glob);

int dosearch(struct DosLibrary *DOSBase, struct search_global *glob);

void TFPN(struct DosLibrary *DOSBase, struct search_global *glob, BPTR lock);

unsigned long StrMovToUpper(char *mptr, char *uptr);

int cmd_search(void)
/*	------							*/
{
struct DosLibrary *DOSBase;
struct RDargs *rdargs;
int rc, rc2;
struct search_global glob;

rc = RETURN_FAIL;
if ((DOSBase = (struct DosLibrary *)OpenLibrary(DOSLIB, DOSVER)))
   {
   memset((char *)&glob, '\0', sizeof(glob));
   memset((char *)&glob.blankline[0], ' ', BLANK_COUNT);
   rdargs = ReadArgs(TEMPLATE, (long *)&glob.opts[0], NULL);

   if (rdargs == NULL)
      {
      rc2 = IoErr();
      PrintFault(rc2, NULL);
      }
   else
      {
      rc2 = prepargs(DOSBase, &glob);
      if (rc2 == 0)
         {
         rc2 = dosearch(DOSBase, &glob);
         if (glob.crout)
         /* Don't leave cursor hanging somewhere odd              	*/
            PutStr("\n");
         }

      if (rc2)
         PrintFault(rc2, NULL);
      else
         rc = 0;	/* everything went OK				*/

      FreeArgs(rdargs);
      }

   CloseLibrary((struct Library *)DOSBase);
   }
else
   OPENFAIL;
return(rc);
}

int prepargs(struct DosLibrary *DOSBase, struct search_global *glob)
/*  --------								*/
/* check arguments in command line for valid input and put things into	*/
/* easier form for processing.						*/
{
char *optr, *sptr;
unsigned long l;
char temp[LINESIZE];

if (glob->opts[SEARCH])
   {
   sptr = glob->search;
   if (glob->opts[FILE])
      /* search arg will be used to match file names			*/
      glob->name = 1;
   else
      {
      /* search arg will be used to match file contents			*/
      glob->pattern = 1;
      *sptr++ = P_ANY;	/* match anywhere within a line in the file	*/
      }
   if (glob->opts[PATTERN] || glob->opts[FILE])
      {
      ParsePattern((char *)glob->opts[SEARCH], temp, LINESIZE);
      optr = temp;
      }
   else
      optr = (char *)glob->opts[SEARCH];
   l = StrMovToUpper(optr, sptr);
   if (!glob->opts[FILE])
      sptr[l] = P_ANY;
   }

/* must have either FROM or SEARCH arg	- might change this requirement */
if ((glob->opts[FROM] == 0) && (glob->opts[SEARCH] == 0))
   return ERROR_REQUIRED_ARG_MISSING;

/* do not support QUICK or QUIET with FILE				*/
if (glob->opts[FILE])
   {
   glob->opts[QUICK] = 0;
   glob->opts[QUIET] = 0;
   }

/* control layouts depending on interaction of options			*/

if (glob->pattern && (glob->opts[QUICK] == 0) && (glob->opts[QUIET] == 0))
   /* use indented layout when searching contents unless QUICK or QUIET */
   glob->pdirs = 1;

if (glob->opts[FILE] && (glob->name == 0))
   /* also use indented layout for FILE with no NAME argument		*/
   glob->pdirs = 1;

/* seem to want content matches but didn't specify a pattern            */
/* nothing useful to do 						*/
if ((glob->pattern == 0) && (glob->opts[FILE] == 0))
   return ERROR_REQUIRED_ARG_MISSING;

/* need a symbol ERROR_NO_ERROR - and NULL (being a pointer) ain't it   */
return 0;
}

int dosearch(struct DosLibrary *DOSBase, struct search_global *glob)
/*  --------								*/
{
struct AnchorPath *anchor;
long pargs[3];
BPTR savefh;
char *indent;
char *twodots = "..\n";
char *erase_eol = "[K\r";
char *newln = "\n";
char *dirstr = " (dir)\n";
BPTR oldlock;
int frc, dothisfile, lres, sres, lcount, depth, getpath = 0/*, fpl*/;
char temp[LINESIZE];	/* place to convert strings to upper case	*/
char line[LINESIZE];	/* current line to match from a file		*/

indent = (char *)&glob->blankline[BLANK_COUNT-3];
depth = 0;
/* if not standard indenting, signal need to initialize directory path	*/
if (!glob->pdirs)
   getpath = 1;

if (anchor = AllocVec(sizeof(struct AnchorPath)+255, MEMF_CLEAR))
   {
   pargs[1] = (long)&anchor->ap_Info.fib_FileName;
   anchor->ap_BreakBits = SIGBREAKF_CTRL_C;
   anchor->ap_Strlen = 255;	/* Causes trouble if less than LINESIZE	*/
   anchor->ap_Flags = APF_DOWILD;
   frc = MatchFirst((char *)glob->opts[FROM], anchor);
   while (frc == 0)
      {
      if (anchor->ap_Info.fib_DirEntryType < 0)         /*file*/
	 {
	 if (glob->name)
	    {
	    StrMovToUpper(anchor->ap_Info.fib_FileName, temp);
	    dothisfile = MatchPattern(glob->search, temp);
	    }
         else
            /* process all files if matching contents instead of names	*/
            dothisfile = 1;
	 if (dothisfile)
	    {
	    pargs[0] = (long)indent;
	    if (glob->pdirs)    /* default indenting style              */
	       {
	       pargs[2] = (long)twodots;
	       }
	    else
	       if (glob->opts[QUICK])
		  {
		  pargs[2] = (long)erase_eol; /* erase to EOL, no lf    */
		  glob->crout = 1;	  /* missing CR outstanding	*/
		  }
	       else	/* QUIET or most instances of FILE		*/
		  {
		  pargs[2] = (long)newln;
		  }

            /* print the filename now unless QUIET option was specified */
	    if (glob->opts[QUIET] == 0)
	       {
	       /* only invoke NameFromLock() if we need to              */
	       if (getpath)
		  {
		  TFPN(DOSBase, glob, anchor->ap_Current->an_Lock);
		  indent = glob->fpath;
		  pargs[0] = (long)indent;
		  getpath = 0;
		  }
	       VPrintf("%s%s%s", pargs);
	       }

            /* see if we're matching file contents instead of names	*/
	    if (glob->pattern)
	       {
	       oldlock = CurrentDir(anchor->ap_Current->an_Lock);
	       glob->curfile =
		     Open(anchor->ap_Info.fib_FileName, MODE_OLDFILE);
	       if (glob->curfile == 0)
		  VPrintf(MSG_OPEN_FAILED, NULL);
	       else
		  {
		  sres = 0;
		  lcount = 0;
		  savefh = SelectInput(glob->curfile);
		  while (lres = FGets(Input(),line, LINESIZE))
		     {
		     lcount++;
		     line[lres - 1] = '\0';
		     StrMovToUpper(line, temp);
		     if (MatchPattern(glob->search, temp))
			{
			if (glob->opts[QUIET])
                        /* print name now that we have a contents match	*/
			   {
			   /* only invoke NameFromLock() if we need to  */
			   if (getpath)
			      {
			      TFPN(DOSBase, glob, anchor->ap_Current->an_Lock);
			      indent = glob->fpath;
			      pargs[0] = (long)indent;
			      getpath = 0;
			      }
			   VPrintf("%s%s%s", pargs);
			   break;	/* one match is all we need	*/
			   }
			else
			   {
			   if (glob->crout)
			      {
			      PutStr("\n");       /* need a line feed	*/
			      glob->crout = 0;
			      }
			   if (glob->opts[NONUM] == 0)
			      VPrintf("%6ld ", &lcount);
			   VPrintf(line, NULL);
			   PutStr("\n");
			   }
			}
		     if (sres=CheckSignal(SIGBREAKF_CTRL_C | SIGBREAKF_CTRL_D))
			break;	  /* close this file, and maybe quit	*/
		     }
		  Close(glob->curfile);
		  CurrentDir(oldlock);
		  SelectInput(savefh);
		  if (sres & SIGBREAKF_CTRL_C)
		     frc = ERROR_BREAK;
		  else if (sres & SIGBREAKF_CTRL_D)
		     PutStr(MSG_FILE_ABANDONNED);
		  }
	       }
	    }
	 }
      else						/*dir */
	 {
	 if (anchor->ap_Flags & APF_DIDDIR)
	    /* exiting a directory, clean up				*/
	    {
	    if (glob->pdirs)
	       indent = indent+5;
	    else
	       /* signal need to restore previous directory path	*/
	       getpath = 1;
	    depth = depth-1;
	    anchor->ap_Flags &= ~APF_DIDDIR;
	    }
	 else
	    /* first time we've seen this directory - print it or enter */
	    /* it or whatever...					*/
	    {
	    if (glob->pdirs)
	       {
	       pargs[0] = (long)indent - 2;
	       pargs[2] = (long)dirstr;
	       VPrintf("%s%s%s", pargs);
	       }
	    if (glob->opts[ALL]
	       || ((depth == 0) && !(anchor->ap_Flags & APF_ITSWILD)))
	       {
	       anchor->ap_Flags |= APF_DODIR;
	       depth = depth+1;
	       if (depth > SEARCH_DEPTH)
		  frc = ERROR_BUFFER_OVERFLOW;
	       if (glob->pdirs)
		  indent = indent-5;
	       else
		  {
		  /* signal need to set up new directory path		*/
		  getpath = 1;
		  }
	       }
	    }
	 }
      /* as long as there's been no error, go around again              */
      if (frc == 0)
	 frc = MatchNext(anchor);
      }
   if (frc == ERROR_NO_MORE_ENTRIES)
      frc = 0;

   MatchEnd(anchor);
   FreeVec(anchor);
   return frc;	/* 0 means no problems in this directory		*/
   }
else	/* plausible description of what happened			*/
   return ERROR_BUFFER_OVERFLOW;
}

void TFPN(struct DosLibrary *DOSBase, struct search_global *glob, BPTR lock)
/*   ----								*/
/*  put Terminated Full Path Name for lock in glob->fpath		*/
{
char *fnptr = glob->fpath;

NameFromLock(lock, fnptr, FPATHSIZE);
while (*fnptr++);
fnptr-=2;
if (*fnptr != ':')
   *++fnptr = '/';
*++fnptr = '\0';
}


unsigned long StrMovToUpper(char *mptr, char *uptr)
/*	      -------------						*/
{
unsigned long l = 0;
register unsigned char c, la = 'a', lz = 'z', cd = 'a'-'A';

while(c = *mptr)
   {
   if (c >= la)
      if (c <= lz)
         c -= cd;
   *uptr = c;

   uptr++;
   l++;
   mptr++;
   }
*uptr = 0;
return l;
}

@


1.0
log
@added to rcs
@
text
@d34 3
d43 3
a64 3

#define Toupper(x) ((('a'<=x) && x<='z' ? (x-('a'-'A')) : x ))

d68 1
a68 2
	pdirs,				/* print dirs (& indent etc)    */
	matchnames;			/* print lines matching SEARCH	*/
d70 3
a72 5
   char line[LINESIZE];
   char pattern[LINESIZE];		/* pattern for search		*/
   char name[LINESIZE]; 		/* pattern for matching names	*/
   char uline[LINESIZE];		/* file contents in upper case	*/
   char uname[LINESIZE];		/* current file name upper case */
a88 1
struct search_global *glob;
d91 1
d96 5
a100 1
   if ((glob = AllocVec(sizeof(struct search_global), MEMF_CLEAR)) != NULL)
d102 13
a114 2
      memset((char *)&glob->blankline[0], ' ', BLANK_COUNT);
      rdargs = ReadArgs(TEMPLATE, (long *)glob, NULL);
d116 2
a117 5
      if (rdargs == NULL)
	 {
	 rc2 = IoErr();
	 PrintFault(rc2, NULL);
	 }
d119 1
a119 9
	 {
	 rc2 = prepargs(DOSBase, glob);
	 if (rc2 == 0)
	    {
	    rc2 = dosearch(DOSBase, glob);
	    if (glob->crout)
	       /* Don't leave cursor hanging somewhere odd              */
	       PutStr("\n");
	    }
d121 1
a121 12
	 /*
	 if (rc2 == ERROR_BUFFER_OVERFLOW)
	    PutStr("*** Buffer overflow\n");
	 else if (rc2 == ERROR_BREAK)
	    PutStr("*** BREAK\n");
	 */
	 if (rc2)
	    PrintFault(rc2, NULL);

	 FreeArgs(rdargs);
	 }
      FreeVec(glob);
a122 2
   else /* say something about lack of memory				*/
      PutStr("*** Buffer overflow\n");
d142 1
d144 2
a145 1
      sptr = glob->name;
d148 3
a150 2
      sptr = glob->pattern;
      *sptr++ = P_ANY;
d177 1
a177 1
if (*glob->pattern && (glob->opts[QUICK] == 0) && (glob->opts[QUIET] == 0))
d181 1
a181 1
if (glob->opts[FILE] && (*glob->name == 0))
a184 4
if ((glob->opts[FILE] && *glob->pattern) || glob->opts[QUIET])
   /* print only names, only for files containing the pattern		*/
   glob->matchnames = 1;

d187 1
a187 1
if ((*glob->pattern == 0) && (glob->opts[FILE] == 0))
d206 3
a208 1
int frc, suppress, lres, sres, lcount, depth, getpath = 0/*, fpl*/;
a214 4
/*
if (depth >= SEARCH_DEPTH)
   return ERROR_BUFFER_OVERFLOW;
*/
d216 1
a216 1
if (anchor = AllocVec(sizeof(struct AnchorPath)+128, MEMF_CLEAR))
a217 1
/* pargs[1] = (long)&anchor->ap_Buf;                                    */
d220 1
a220 1
   anchor->ap_Strlen = 128;
d227 1
a227 1
	 if (*glob->name != 0)
d229 2
a230 2
	    StrMovToUpper(anchor->ap_Info.fib_FileName, glob->uname);
	    suppress = MatchPattern(glob->name, glob->uname);
d232 4
a235 1
	 if (suppress || (*glob->name == 0))
d252 3
a254 1
	    if (glob->matchnames == 0)
d266 3
a268 1
	    if (*glob->pattern != 0)
d274 1
a274 1
		  VPrintf("Couldn't open file\n", NULL);
d280 1
a280 1
		  while (lres = FGets(Input(),glob->line, LINESIZE))
d283 3
a285 3
		     glob->line[lres - 1] = '\0';
		     StrMovToUpper(glob->line, glob->uline);
		     if (MatchPattern(glob->pattern, glob->uline))
d287 2
a288 1
			if (glob->matchnames)
d305 1
a305 1
			      PutStr("\n");       /* need a line feed     */
d310 1
a310 1
			   VPrintf(glob->line, NULL);
d323 1
a323 1
		     PutStr("** File abandonned\n");
d394 1
a394 1
   *++fnptr = '\0';
d401 2
a402 1
unsigned long c, l = 0;
d406 5
a410 1
   *uptr = Toupper(c);
d418 1
@
