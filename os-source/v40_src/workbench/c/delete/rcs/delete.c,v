head     1.24;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @*   @;


1.24
date     91.06.06.12.32.45;  author vertex;  state Exp;
branches ;
next     1.23;

1.23
date     91.05.28.14.13.43;  author vertex;  state Exp;
branches ;
next     1.22;

1.22
date     91.05.28.13.39.32;  author vertex;  state Exp;
branches ;
next     1.21;

1.21
date     91.05.21.16.26.15;  author vertex;  state Exp;
branches ;
next     1.20;

1.20
date     91.05.21.14.47.28;  author vertex;  state Exp;
branches ;
next     1.19;

1.19
date     91.03.16.18.19.32;  author Jim_Cooper;  state Exp;
branches ;
next     1.18;

1.18
date     91.03.16.16.26.09;  author Jim_Cooper;  state Exp;
branches ;
next     1.17;

1.17
date     91.02.24.20.55.18;  author Jim_Cooper;  state Exp;
branches ;
next     1.16;

1.16
date     91.02.03.10.10.29;  author Jim_Cooper;  state Exp;
branches ;
next     1.15;

1.15
date     90.12.10.22.25.15;  author Jim_Cooper;  state Exp;
branches ;
next     1.14;

1.14
date     90.11.07.14.40.03;  author Unknown;  state Exp;
branches ;
next     1.13;

1.13
date     90.11.06.06.06.51;  author J_Toebes;  state Exp;
branches ;
next     1.12;

1.12
date     90.10.12.15.40.59;  author Unknown;  state Exp;
branches ;
next     1.11;

1.11
date     90.10.12.14.49.48;  author Unknown;  state Exp;
branches ;
next     1.10;

1.10
date     90.10.11.20.51.15;  author Unknown;  state Exp;
branches ;
next     1.9;

1.9
date     90.05.25.14.39.32;  author andy;  state Exp;
branches ;
next     1.8;

1.8
date     90.05.04.22.23.53;  author andy;  state Exp;
branches ;
next     1.7;

1.7
date     90.04.18.21.54.20;  author Unknown;  state Exp;
branches ;
next     1.6;

1.6
date     90.04.11.22.12.18;  author andy;  state Exp;
branches ;
next     1.5;

1.5
date     90.04.10.19.17.20;  author andy;  state Exp;
branches ;
next     1.4;

1.4
date     90.04.07.22.32.13;  author andy;  state Exp;
branches ;
next     1.3;

1.3
date     90.03.12.20.14.55;  author andy;  state Exp;
branches ;
next     1.2;

1.2
date     90.03.01.19.26.02;  author andy;  state Exp;
branches ;
next     1.1;

1.1
date     90.01.22.19.51.41;  author andy;  state Exp;
branches ;
next     1.0;

1.0
date     90.01.22.19.28.43;  author andy;  state Exp;
branches ;
next     ;


desc
@Delete command for cdos
@


1.24
log
@Now CDs to correct location before doing GetDeviceProc()
@
text
@; /*
lc -d -rr -j73 -O -o/obj/Delete.o -i/include -v -csf Delete
blink /obj/Delete.o to /bin/Delete sc sd nd
protect /bin/Delete +p
quit
*/

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* |_o_o|\\ Copyright (c) 1989 The Software Distillery.  All Rights Reserved */
/* |. o.| || This program may not be distributed without the permission of   */
/* | .	| || the authors:			      BBS: (919) 460-7430    */
/* | o	| ||   Dave Baker      Alan Beale	  Jim Cooper		     */
/* |  . |//    Jay Denebeim    Bruce Drake	  Gordon Keener 	     */
/* ======      John Mainwaring Andy Mercier	  Jack Rouse		     */
/*	       John Toebes     Mary Ellen Toebes  Doug Walker	Mike Witcher */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*---------------------------------------------------------------------------*/
/* Command: Delete							     */
/* Author: James E. Cooper Jr.						     */
/* Change History:							     */
/*  Date    Person	  Action					     */
/* -------  ------------- -----------------				     */
/* 30APR89  Jim Cooper	  Initial Creation				     */
/* 27NOV89  Jim Cooper	  Final Version Completed			     */
/* 08DEC89  Jim Cooper	  Re-Done for V36.42				     */
/* 04MAR90  Jim Cooper	  Modified for loss of "AnchorPath.ap_Buf"...        */
/* 12OCT90  Jim Cooper	  Fixed several bugs... 			     */
/* 06NOV90  John Toebes   Corrected problem with deleteing locked files      */
/* 07NOV90  Jim Cooper	  Fixed John's fix so it reported error messages     */
/*			  correctly.					     */
/* 10DEC90  Jim Cooper	  Added RETURN_WARN return for trying to delete      */
/*			  non-existant file.  (1.3 compat)                   */
/* 03FEB91  Jim Cooper	  Finally fixed problems with printing wrong name    */
/*			  when deleting links.	NameFromLock() was returning */
/*			  incorrect name.				     */
/* 24FEB91  Jim Cooper	  Switched to GetDeviceProc()/FreeDeviceProc() calls */
/*			  from oldstyle DeviceProc().  This should remove    */
/*			  lingering problems with links.		     */
/* 16MAR91  Jim Cooper	  "Fixed" problem with circular links; also fixed    */
/*			  back to use AnchorPath.ap_Buf so I print relative  */
/*			  names just like I (and the 1.3 Delete) used to.    */
/* 16Mar91  Jim Cooper	  Took care of Bill Hawes' Enforcer hit report.  Was */
/*			  not checking to see if a DupLock() succeeded or    */
/*			  failed.  Fixed now.				     */
/* Notes:								     */
/*---------------------------------------------------------------------------*/

#include "internal/commands.h"
#include "delete_rev.h"

#define MSG_NO_FILES	"No file to delete\n"
#define MSG_DEVICE	"%s is a device and cannot be deleted\n"
#define MSG_DELETED	"  Deleted\n"
#define MSG_NOT_DELETED "  Not Deleted"

#define TEMPLATE	"FILE/M/A,ALL/S,QUIET/S,FORCE/S" CMDREV
#define OPT_PATTERN	0
#define OPT_ALL 	1
#define OPT_QUIET	2
#define OPT_FORCE	3
#define OPT_COUNT	4

/*---------------------------------------------------------------------------*/
/* Global structure used to pass everything between the two routines.	     */
/*---------------------------------------------------------------------------*/
struct Global {
  struct DOSLibrary *DOSBase;
  long opts[OPT_COUNT];
  long dcount;
  BPTR dlock;
  long rc;
  long result2;
};

/*---------------------------------------------------------------------------*/
/* Function prototype for the second routine, so we can use registerized     */
/* parameters.								     */
/*---------------------------------------------------------------------------*/
int KillList(struct Global *, char *, BPTR, STRPTR);

/*---------------------------------------------------------------------------*/
/* The main delete routine.						     */
/*---------------------------------------------------------------------------*/
int cmd_delete(void)
{
  struct Global global;
  struct Library *SysBase = (*((struct Library **) 4));
  struct DosLibrary *DOSBase;
  struct RDargs *rdargs;
  struct DevProc *dproc;
  char *curarg, **argptr;

  /* variables added to deal with absolute drive name problems */
  BPTR *prelocks = NULL;
  STRPTR *names = NULL;
  BPTR *arglock;
  UWORD i,j;
  char oldCh;
  UWORD argcnt;
  BOOL argmatched;
  STRPTR argname;
  UWORD numsources = 0;
  STRPTR *devname;
  BPTR oldCD;

  /*-------------------------------------------------------------------------*/
  /* First, clear the global structure so we don't have any garbage floating.*/
  /*-------------------------------------------------------------------------*/
  memset(&global,0,sizeof(struct Global));

  /*-------------------------------------------------------------------------*/
  /* Set up the default return code.					     */
  /*-------------------------------------------------------------------------*/
  global.rc = RETURN_WARN;

  /*-------------------------------------------------------------------------*/
  /* And open the dos library for our use.				     */
  /*-------------------------------------------------------------------------*/
  if ((DOSBase = (struct DOSLibrary *)OpenLibrary(DOSLIB, DOSVER))) {

    /*-----------------------------------------------------------------------*/
    /* If it opened successfully, store the pointer in the global structure  */
    /* to pass it to the other routine (IF we get that far!).                */
    /*-----------------------------------------------------------------------*/
    global.DOSBase = DOSBase;

    /*-----------------------------------------------------------------------*/
    /* Parse the command line.						     */
    /*-----------------------------------------------------------------------*/
    rdargs = ReadArgs(TEMPLATE, global.opts, NULL);

    /*-----------------------------------------------------------------------*/
    /* If there was an error parsing, print an error message and get out!    */
    /*-----------------------------------------------------------------------*/
    if (rdargs == NULL) {
      PrintFault(IoErr(), NULL);
    } else {

	/* count the number of things to delete */
        argptr = (char **) global.opts[OPT_PATTERN];
        numsources = 0;
        while (*argptr++)
            numsources++;

        /* allocate an array to hold locks on the things to delete */
        if (!(prelocks = AllocVec((ULONG)numsources*4,MEMF_CLEAR|MEMF_PUBLIC)))
        {
            PrintFault(ERROR_NO_FREE_STORE,NULL);
            goto Done;
        }

        /* allocate an array to hold the device names of the things to delete */
        if (!(names = AllocVec((ULONG)numsources*4,MEMF_CLEAR|MEMF_PUBLIC)))
        {
            PrintFault(ERROR_NO_FREE_STORE,NULL);
            goto Done;
        }

        argptr = (char **) global.opts[OPT_PATTERN];
        argcnt = 0;
        while (argptr[argcnt])
        {
	    /* scan for device name */
            argname = argptr[argcnt];
            i = 0;
            while ((argname[i] != ':') && (argname[i]))
                i++;

	    /* got a colon, so its a device name */
            if (argname[i] == ':')
            {
                i++;
                oldCh = argname[i];
                argname[i] = 0;

		/* see if this device name has already been used */
                argmatched = FALSE;
                j = 0;
                while (j <= argcnt)
                {
                    if ((names[j]) && (stricmp(argname,names[j]) == 0))
                    {
                        argmatched = TRUE;
                        break;
                    }
                    j++;
                }

                if (argmatched)
                {
                    prelocks[argcnt] = DupLock(prelocks[j]);
                }
                else
                {
                    prelocks[argcnt] = Lock(argname,ACCESS_READ);
                }

                if (prelocks[argcnt])
                {
                    if (!(names[argcnt] = AllocVec(strlen(argname)+1,MEMF_CLEAR|MEMF_PUBLIC)))
                    {
                        PrintFault(ERROR_NO_FREE_STORE,NULL);
                        goto Done;
                    }
                    strcpy(names[argcnt],argname);

                    argname[i] = oldCh;
                    strcpy(argname,&argname[i]);
                }
            }
            argcnt++;
        }


      arglock = &prelocks[0];
      devname = &names[0];
      argptr = (char **)global.opts[OPT_PATTERN];
      /*---------------------------------------------------------------------*/
      /* The following while loop handles the NEW MultiArgs spec.	     */
      /*---------------------------------------------------------------------*/
      while (curarg = *argptr++) {

	/*-------------------------------------------------------------------*/
	/* If the filespec given doesn't have a device associated with it,   */
	/* something is VERY wrong!  Tell 'em so and exit.                   */
	/*-------------------------------------------------------------------*/
        if (*arglock)
            oldCD = CurrentDir(*arglock);

	if ((dproc = GetDeviceProc(curarg, NULL)) == NULL) {
          if (*arglock)
              CurrentDir(oldCD);
	  PrintFault(IoErr(), NULL);
	  global.dcount++;
	} else {
	  FreeDeviceProc(dproc);
          if (*arglock)
              CurrentDir(oldCD);

	  /*-----------------------------------------------------------------*/
	  /* If the filespec they gave ends with a colon, it is either a     */
	  /* device, such as RAM:, or an assignment, such as C:.  We can't   */
	  /* do anything about these (according to current specs), so we     */
	  /* just complain and exit.					     */
	  /*-----------------------------------------------------------------*/
          if ((!curarg[0]) && (*devname))
          {
	    VPrintf(MSG_DEVICE, (long *)devname);
	    global.dcount++;
	    break;
	  } else {

	    /*---------------------------------------------------------------*/
	    /* Finally!  Everthing SEEMS ok, so we try to delete something.  */
	    /*---------------------------------------------------------------*/
	    if (KillList(&global, curarg, *arglock, *devname) != NULL) {
	      break;
	    }
	  }
	}
	arglock++;
	devname++;
      }
      /*---------------------------------------------------------------------*/
      /* We're ready to exit, so clean up after ourselves.                   */
      /*---------------------------------------------------------------------*/
      FreeArgs(rdargs);
    }

    if (!(global.dcount)) {
      PutStr(MSG_NO_FILES);
      global.rc = RETURN_WARN;
    }

Done:
    if (prelocks)
    {
        i = 0;
        while (i < numsources)
            UnLock(prelocks[i++]);
        FreeVec(prelocks);
    }

    if (names)
    {
        i = 0;
        while (i < numsources)
            FreeVec(names[i++]);
        FreeVec(names);
    }

    if(global.rc)SetIoErr(global.result2);
   CloseLibrary((struct Library *)DOSBase);
  } else {
    OPENFAIL;
  }
  return(global.rc);
}

/*---------------------------------------------------------------------------*/
/* This routine is used to kill all the files which match a specific pattern */
/* whether the pattern includes wildcards or not.			     */
/*---------------------------------------------------------------------------*/
int KillList(struct Global *global, char *name, BPTR lock, STRPTR devname)
{
  struct Library *SysBase = (*((struct Library **) 4));
  struct AnchorPath *ua;
  BOOL skip1,printflag=TRUE;
  LONG temprc=0,trc,loopc;
  struct DosLibrary *DOSBase;
  BPTR oldlock, curlock, flock;
  char *cachename;
  char cachefull[ENVMAX];
  BPTR oldCD;

  DOSBase = global->DOSBase;
  global->rc = RETURN_OK;

  /*-------------------------------------------------------------------------*/
  /* Try to allocate a chunk of memory to use with the pattern match stuff.  */
  /*-------------------------------------------------------------------------*/
  if ((ua = AllocVec(sizeof(struct AnchorPath)+ENVMAX,
		     MEMF_CLEAR|MEMF_PUBLIC)) == NULL) {
    PrintFault(IoErr(),NULL);
    global->rc = RETURN_FAIL;
  } else {

    /*-----------------------------------------------------------------------*/
    /* Now we have to set up the pattern match structure.		     */
    /*-----------------------------------------------------------------------*/
    /* Set the flag which tells the pattern matcher to decode wild cards.    */
    /*-----------------------------------------------------------------------*/
    ua->ap_Flags = APF_DOWILD;
    ua->ap_Strlen = ENVMAX;

    /*-----------------------------------------------------------------------*/
    /* Tell the matcher to stop if the user presses Ctrl-C.		     */
    /*-----------------------------------------------------------------------*/
    ua->ap_BreakBits = SIGBREAKF_CTRL_C;

    /*-----------------------------------------------------------------------*/
    /* Finally, call the matcher.					     */
    /*-----------------------------------------------------------------------*/
    if (lock)
        oldCD = CurrentDir(lock);

    loopc = MatchFirst(name,ua);

    /*-----------------------------------------------------------------------*/
    /* Process all matches returned.					     */
    /*-----------------------------------------------------------------------*/
    while ((loopc == 0) && ((temprc == 0) ||
	    (temprc == ERROR_OBJECT_IN_USE) ||
	    (temprc == ERROR_DIRECTORY_NOT_EMPTY) ||
	    (temprc == ERROR_DELETE_PROTECTED))) {

      /*---------------------------------------------------------------------*/
      /* 'skip1' is a flag which tells us whether or not to try deleting a   */
      /* subdirectory.	Basically, skip it if we have not deleted all the    */
      /* files under it, delete it if we have cleaned it out.  This only has */
      /* validity if the user used the 'ALL' keyword on the command line.    */
      /*---------------------------------------------------------------------*/
      skip1 = FALSE;

      /*---------------------------------------------------------------------*/
      /* Make a copy of this file's name with full path.                     */
      /*---------------------------------------------------------------------*/
      if ((curlock = DupLock(ua->ap_Current->an_Lock)) == NULL) {

	/*-------------------------------------------------------------------*/
	/* If we can't duplicate the lock, something is *seriously* wrong!   */
	/* Let's set some error codes and BAIL OUT!                          */
	/*-------------------------------------------------------------------*/
	temprc = 1L;
	break;

      } else {
	strcpy(cachefull, ua->ap_Buf);
	cachename = FilePart(cachefull);

	if (((ua->ap_Info.fib_DirEntryType > 0) &&
	     (ua->ap_Info.fib_DirEntryType < 3)) &&
	    global->opts[OPT_ALL]) {

	  /*-----------------------------------------------------------------*/
	  /* The flag APF_DIDDIR tells us that we are 'backing out' of a     */
	  /* subdirectory... in other words, we have deleted all sub files   */
	  /* of that directory and we are moving back to its parent.  If     */
	  /* this flag is set, we need to clear it, and leave skip1 alone so */
	  /* this subdir gets deleted as the user specified.		     */
	  /*-----------------------------------------------------------------*/
	  if (!(ua->ap_Flags & APF_DIDDIR)) {

	    /*---------------------------------------------------------------*/
	    /* If we are deleting ALL files, tell the matcher to enter this  */
	    /* directory; we also need to skip trying to delete this file    */
	    /* until we exit it, as explained above.			     */
	    /*---------------------------------------------------------------*/
	    ua->ap_Flags |= APF_DODIR;
	    skip1 = TRUE;
	    UnLock(curlock);
	  }
	  ua->ap_Flags &= ~APF_DIDDIR;
	}
      }

      /*---------------------------------------------------------------------*/
      /* Now get the next file which matches the given pattern. 	     */
      /*---------------------------------------------------------------------*/
      loopc = MatchNext(ua);

      /*---------------------------------------------------------------------*/
      /* Now, unless we are skipping the current file, we need to try to     */
      /* delete it.							     */
      /*---------------------------------------------------------------------*/
      if (!skip1) {

	/*-------------------------------------------------------------------*/
	/* Gather info and set current directory of file we wish to delete.  */
	/*-------------------------------------------------------------------*/
	oldlock = CurrentDir(curlock);
	flock = Lock(cachename,ACCESS_READ);
	if (flock == NULL) {
	  /* There was an error on the current file.. */
	  temprc = IoErr();
	  trc = 0L;
	  if (global->opts[OPT_QUIET] == NULL) {
	    if (devname)
	        PutStr(devname);
	    PutStr(cachefull);
	  }
	  Result2(temprc);
	} else {
	  UnLock(flock);

	  /*-----------------------------------------------------------------*/
	  /* Unless we are being vewy qwiet, print the name of the file we   */
	  /* are about to try to delete.				     */
	  /*-----------------------------------------------------------------*/
	  if (global->opts[OPT_QUIET] == NULL) {
	    if (devname)
	        PutStr(devname);
	    PutStr(cachefull);
	  }

	  /*-----------------------------------------------------------------*/
	  /* If we got this far, we can assume we are going to exit with a   */
	  /* return code, whether we actually delete the file or not.	     */
	  /*-----------------------------------------------------------------*/
	  global->rc = RETURN_OK;

	  /*-----------------------------------------------------------------*/
	  /* KILL IT!							     */
	  /*-----------------------------------------------------------------*/
	  global->dcount++;

	  trc=DeleteFile(cachename);
	  if(trc == NULL) { /* failed for some reason */
	    global->result2 =IoErr();
	    if((global->result2 == ERROR_DELETE_PROTECTED)&&
		global->opts[OPT_FORCE]) {

	      global->result2=0; /* ready for second try */
	      SetProtection(cachename,0x0); /* try again */
	      trc=DeleteFile(cachename);
	    }
	  }
	} /* Match to flock == NULL else clause above */
	CurrentDir(oldlock);
	UnLock(curlock);

	if(trc != NULL) {
	  /*-----------------------------------------------------------------*/
	  /* If it worked, tell everybody!  Unless we are in QUIET mode, of  */
	  /* course!							     */
	  /*-----------------------------------------------------------------*/
	  if (global->opts[OPT_QUIET] == NULL) PutStr(MSG_DELETED);
	  global->rc=RETURN_OK;
	  global->result2=0;
	}
	else {
	  /*-----------------------------------------------------------------*/
	  /* If we aren't able to kill the file, we need to tell 'em about   */
	  /* it and go on.						     */
	  /*-----------------------------------------------------------------*/
	  temprc = IoErr();
	  global->result2 = temprc;

	  /*-----------------------------------------------------------------*/
	  /* If we have been quiet up to now, we need to go ahead and print  */
	  /* the name out.  This was a rather annoying ommision of the BCPL  */
	  /* version, in that if you told it to be quiet, it would... except */
	  /* when it printed an error message, you never knew WHERE the      */
	  /* error had occured. 					     */
	  /*-----------------------------------------------------------------*/
	  if (global->opts[OPT_QUIET] != NULL) {
	    if (devname)
	        PutStr(devname);
	    PutStr(cachefull);
	  }
	  PrintFault(temprc, MSG_NOT_DELETED);
	  printflag=FALSE; /* don't print the message again */
	}
      }
    }

    /*-----------------------------------------------------------------------*/
    /* If the only error we had was that we ran out of files to delete, we   */
    /* are doing fine!	Set the return code so the user knows everything     */
    /* went well.							     */
    /*-----------------------------------------------------------------------*/
    if (temprc == ERROR_NO_MORE_ENTRIES) {
      temprc = NULL;
      global->rc = RETURN_OK;
    }

    /*-----------------------------------------------------------------------*/
    /* If the user hit Ctrl-C, we have to warn him that he is being rude!    */
    /*-----------------------------------------------------------------------*/
    if (temprc == ERROR_BREAK) {
      temprc = NULL;
      PrintFault(IoErr(),NULL);
      global->rc = RETURN_WARN;
      global->dcount++;
    }

    /*-----------------------------------------------------------------------*/
    /* If there was any other error, tell the user about it and leave!	     */
    /*-----------------------------------------------------------------------*/
    if (temprc) {
      if(printflag)PrintFault(IoErr(),NULL);
      global->rc = RETURN_FAIL;
      global->dcount++;
    }

    /*-----------------------------------------------------------------------*/
    /* We have to clean up after ourselves.				     */
    /*-----------------------------------------------------------------------*/
    MatchEnd(ua);

    if (lock)
        CurrentDir(oldCD);

    FreeVec(ua);
  }
  return(global->rc);
}
@


1.23
log
@Fixed checking code against deleting device names, broke in 37.5
@
text
@d105 1
d228 3
d232 2
d238 2
@


1.22
log
@Fixed output for multiple arguments containing equivalent device names
@
text
@d239 3
a241 2
	  if (*(curarg + strlen(curarg) - 1) == ':') {
	    VPrintf(MSG_DEVICE, (long *)&curarg);
@


1.21
log
@Now preserves current dir accross calls to MatchFirst/Next to workaround a bug 
in DOS
@
text
@d191 10
a200 1
                    if (!(prelocks[argcnt] = DupLock(prelocks[j])))
d202 1
a202 1
                        PrintFault(ERROR_NO_FREE_STORE, NULL);
d205 1
a208 15
                }
                else
                {
                    if (prelocks[argcnt] = Lock(argname,ACCESS_READ))
                    {
                        if (!(names[argcnt] = AllocVec(strlen(argname)+1,MEMF_CLEAR|MEMF_PUBLIC)))
                        {
                            PrintFault(ERROR_NO_FREE_STORE,NULL);
                            goto Done;
                        }
                        strcpy(names[argcnt],argname);

                        argname[i] = oldCh;
                        strcpy(argname,&argname[i]);
                    }
@


1.20
log
@Added monstruous code to deal with absolute drive names and disk swapping.
Now always deletes from the correct disk.
@
text
@d198 1
a198 4
                    if (oldCh)
                        strcpy(argname,&argname[i]);
                    else
                        argname[0] = 0;
d212 1
a212 4
                        if (oldCh)
                            strcpy(argname,&argname[i]);
                        else
                            argname[0] = 0;
a345 3
    if (lock)
        CurrentDir(oldCD);

d537 4
@


1.19
log
@Fixed Enforcer hit problem reported by Bill Hawes.
@
text
@d80 1
a80 1
int KillList(struct Global *, char *);
d94 12
d139 89
d259 1
a259 1
	    if (KillList(&global, curarg) != NULL) {
d264 2
d272 1
d277 18
d307 1
a307 1
int KillList(struct Global *global, char *name)
d317 1
d347 3
d352 3
d434 2
d447 2
d503 2
@


1.18
log
@Fixed circular link problem.  Also went back to printing relative names
rather than complete path/name.
@
text
@d11 1
a11 1
/* | .	| || the authors:			      BBS: (919) 382-8288    */
d43 3
d245 1
a245 3
      curlock = DupLock(ua->ap_Current->an_Lock);
      strcpy(cachefull, ua->ap_Buf);
      cachename = FilePart(cachefull);
d247 21
a267 17
      if (((ua->ap_Info.fib_DirEntryType > 0) &&
	   (ua->ap_Info.fib_DirEntryType < 3)) &&
	  global->opts[OPT_ALL]) {

	/*-------------------------------------------------------------------*/
	/* The flag APF_DIDDIR tells us that we are 'backing out' of a sub-  */
	/* directory... in other words, we have deleted all sub files of     */
	/* that directory and we are moving back to its parent.  If this     */
	/* flag is set, we need to clear it, and leave skip1 alone so this   */
	/* subdir gets deleted as the user specified.			     */
	/*-------------------------------------------------------------------*/
	if (!(ua->ap_Flags & APF_DIDDIR)) {

	  /*-----------------------------------------------------------------*/
	  /* If we are deleting ALL files, tell the matcher to enter this    */
	  /* directory; we also need to skip trying to delete this file      */
	  /* until we exit it, as explained above.			     */
d269 12
a280 3
	  ua->ap_Flags |= APF_DODIR;
	  skip1 = TRUE;
	  UnLock(curlock);
a281 1
	ua->ap_Flags &= ~APF_DIDDIR;
d392 1
@


1.17
log
@Finally got rid of DeviceProc() call; used GetDeviceProc(),
FreeDeviceProc() pair instead.
@
text
@d40 3
a70 1
  char dname[ENVMAX+1];
a88 1

d146 1
a146 1
	  if ((IoErr() == NULL) && (*(curarg + strlen(curarg) - 1) == ':')) {
d150 1
a150 2
	  }
	  else {
d190 2
a191 1
  char cachename[ENVMAX];
d199 1
a199 1
  if ((ua = AllocVec(sizeof(struct AnchorPath),
d211 1
d243 2
a244 1
      strcpy(cachename, ua->ap_Info.fib_FileName);
d246 3
a248 1
      if (ua->ap_Info.fib_DirEntryType > 0 && global->opts[OPT_ALL]) {
a286 2
	NameFromLock(curlock,global->dname,ENVMAX);
	AddPart(global->dname,cachename,ENVMAX);
d292 1
a292 1
	    PutStr(global->dname);
d303 1
a303 1
	    PutStr(global->dname);
d357 1
a357 1
	    PutStr(global->dname);
@


1.16
log
@Fixed wrong name printing when deleting links.
@
text
@d37 3
d86 1
d133 2
a134 2
	if (DeviceProc(curarg) == NULL) {
	  PrintFault(IoErr(),NULL);
d137 1
d147 2
a148 2
	    global.dcount++; /* they probably accidently typed a space */
	    break;	/* let's give them another chance */
d182 1
a182 3
int KillList(global, name)
struct Global *global;
char *name;
@


1.15
log
@Fixed return code prob. with deleting non-existant file.
@
text
@d34 3
d279 2
a284 2
	  NameFromLock(curlock,global->dname,ENVMAX);
	  AddPart(global->dname,cachename,ENVMAX);
a289 1
	  NameFromLock(flock,global->dname,ENVMAX);
@


1.14
log
@Fixed John's fix (1.13) so that it displays proper error messages.
How do I set the author name for this RCS stuff?  All these "Unknown"
author fixes are mine (Jim Cooper).  In fact, most of the ones marked
"andy" are mine as well.  He is just the person who put them in the RCS.
@
text
@d32 2
d160 1
@


1.13
log
@Corrected problem with deleting files that have a lock outstanding on them.
In the interest of ensuring a clean change note that the formatting is
slightly off because I did not indent an entire else clause (this makes many
more lines match and shows what the change is.  The next person to edit this
file should fix these lines.
@
text
@d30 2
d273 21
a293 17
        if (flock == NULL)
        {
           /* There was an error on the current file.. */
           trc = 1;
        }
        else
        {
	NameFromLock(flock,global->dname,ENVMAX);
	UnLock(flock);

	/*-------------------------------------------------------------------*/
	/* Unless we are being vewy qwiet, print the name of the file we are */
	/* about to try to delete.					     */
	/*-------------------------------------------------------------------*/
	if (global->opts[OPT_QUIET] == NULL) {
	  PutStr(global->dname);
	}
d295 5
a299 5
	/*-------------------------------------------------------------------*/
	/* If we got this far, we can assume we are going to exit with a     */
	/* return code, whether we actually delete the file or not.	     */
	/*-------------------------------------------------------------------*/
	global->rc = RETURN_OK;
d301 4
a304 4
	/*-------------------------------------------------------------------*/
	/* KILL IT!							     */
	/*-------------------------------------------------------------------*/
	global->dcount++;
d306 4
a309 4
	trc=DeleteFile(cachename);
	if(trc == NULL) { /* failed for some reason */
	  global->result2 =IoErr();
	  if((global->result2 == ERROR_DELETE_PROTECTED)&&
d312 4
a315 3
		global->result2=0; /* ready for second try */
		SetProtection(cachename,0x0); /* try again */
		trc=DeleteFile(cachename);
d317 1
a317 2
	}
        } /* Match to flock == NULL else clause above */
@


1.12
log
@Oops! 1.11 left a dangling lock.  Fixed now.
@
text
@d29 1
d271 7
d311 1
@


1.11
log
@Fixed confusion over multiple volumes with same name.
@
text
@d28 1
d177 1
a177 1
  BPTR oldlock, curlock;
a227 4
#if 0
      NameFromLock(ua->ap_Current->an_Lock,global->dname,ENVMAX);
      AddPart(global->dname,(char *)&ua->ap_Info.fib_FileName,ENVMAX);
#else
a229 1
#endif
d249 1
d265 3
d269 3
a271 3
	curlock = Lock(cachename,ACCESS_READ);
	NameFromLock(curlock,global->dname,ENVMAX);
	UnLock(curlock);
a291 13
#if 0
	trc=DeleteFile(global->dname);
	if(trc == NULL) { /* failed for some reason */
	  global->result2 =IoErr();
	  if((global->result2 == ERROR_DELETE_PROTECTED)&&
		global->opts[OPT_FORCE]) {

		global->result2=0; /* ready for second try */
		SetProtection(global->dname,0x0); /* try again */
		trc=DeleteFile(global->dname);
	  }
	}
#else
d304 1
a304 1
#endif
@


1.10
log
@Fixed "delete /c" trying to delete a/b/c if current dir is a/b (path bug)
@
text
@d176 2
d227 1
d230 4
d268 5
d292 1
d304 15
@


1.9
log
@new version from the Software Distillery
fixes return code problems
@
text
@d204 1
a204 1
    loopc=MatchFirst(name,ua);
d209 4
a212 5
    while ((loopc == 0) &&
	   ((temprc == 0) ||
	    (temprc==ERROR_OBJECT_IN_USE) ||
	    (temprc==ERROR_DIRECTORY_NOT_EMPTY) ||
	    (temprc==ERROR_DELETE_PROTECTED))) {
d253 1
a253 1
      loopc=MatchNext(ua);
@


1.8
log
@was doing a SetIOErr even if open failed, this crashed under 1.3
@
text
@d11 5
a15 5
/* | .  | || the authors:                             BBS: (919) 382-8288    */
/* | o  | ||   Dave Baker      Alan Beale         Jim Cooper                 */
/* |  . |//    Jay Denebeim    Bruce Drake        Gordon Keener              */
/* ======      John Mainwaring Andy Mercier       Jack Rouse                 */
/*             John Toebes     Mary Ellen Toebes  Doug Walker   Mike Witcher */
d19 10
a28 10
/* Command: Delete                                                           */
/* Author: James E. Cooper Jr.                                               */
/* Change History:                                                           */
/*  Date    Person        Action                                             */
/* -------  ------------- -----------------                                  */
/* 30APR89  Jim Cooper    Initial Creation                                   */
/* 27NOV89  Jim Cooper    Final Version Completed                            */
/* 08DEC89  Jim Cooper    Re-Done for V36.42                                 */
/* 04MAR90  Jim Cooper    Modified for loss of "AnchorPath.ap_Buf"...        */
/* Notes:                                                                    */
d34 3
a36 3
#define MSG_NO_FILES    "No file to delete\n"
#define MSG_DEVICE      "%s is a device and cannot be deleted\n"
#define MSG_DELETED     "  Deleted\n"
d39 4
a42 4
#define TEMPLATE        "FILE/M/A,ALL/S,QUIET/S,FORCE/S" CMDREV
#define OPT_PATTERN     0
#define OPT_ALL         1
#define OPT_QUIET       2
d44 1
a44 1
#define OPT_COUNT       4
d47 1
a47 1
/* Global structure used to pass everything between the two routines.        */
d61 1
a61 1
/* parameters.                                                               */
d66 1
a66 1
/* The main delete routine.                                                  */
d83 1
a83 1
  /* Set up the default return code.                                         */
d88 1
a88 1
  /* And open the dos library for our use.                                   */
d99 1
a99 1
    /* Parse the command line.                                               */
d112 1
a112 1
      /* The following while loop handles the NEW MultiArgs spec.            */
d116 20
a135 20
        /*-------------------------------------------------------------------*/
        /* If the filespec given doesn't have a device associated with it,   */
        /* something is VERY wrong!  Tell 'em so and exit.                   */
        /*-------------------------------------------------------------------*/
        if (DeviceProc(curarg) == NULL) {
          PrintFault(IoErr(),NULL);
          global.dcount++;
        } else {

          /*-----------------------------------------------------------------*/
          /* If the filespec they gave ends with a colon, it is either a     */
          /* device, such as RAM:, or an assignment, such as C:.  We can't   */
          /* do anything about these (according to current specs), so we     */
          /* just complain and exit.                                         */
          /*-----------------------------------------------------------------*/
          if ((IoErr() == NULL) && (*(curarg + strlen(curarg) - 1) == ':')) {
            VPrintf(MSG_DEVICE, (long *)&curarg);
            global.dcount++; /* they probably accidently typed a space */
	    break; 	/* let's give them another chance */
          } 
d138 8
a145 8
            /*---------------------------------------------------------------*/
            /* Finally!  Everthing SEEMS ok, so we try to delete something.  */
            /*---------------------------------------------------------------*/
            if (KillList(&global, curarg) != NULL) {
              break;
            }
          }
        }
d155 1
a155 1
    if(global.rc)SetIoErr(global.result2); 
d157 3
a159 1
  } else { OPENFAIL;}
d165 1
a165 1
/* whether the pattern includes wildcards or not.                            */
d178 1
a179 1

d184 2
a185 1
                     MEMF_CLEAR|MEMF_PUBLIC)) == NULL) {
a186 1
    PrintFault(IoErr(),NULL);
d190 1
a190 1
    /* Now we have to set up the pattern match structure.                    */
d197 1
a197 1
    /* Tell the matcher to stop if the user presses Ctrl-C.                  */
d202 1
a202 1
    /* Finally, call the matcher.                                            */
d207 1
a207 1
    /* Process all matches returned.                                         */
d209 5
a213 1
    while ( (!loopc) && ((!temprc)||(temprc==202)||(temprc==222))) {
d217 1
a217 1
      /* subdirectory.  Basically, skip it if we have not deleted all the    */
d231 18
a248 18
        /*-------------------------------------------------------------------*/
        /* The flag APF_DIDDIR tells us that we are 'backing out' of a sub-  */
        /* directory... in other words, we have deleted all sub files of     */
        /* that directory and we are moving back to its parent.  If this     */
        /* flag is set, we need to clear it, and leave skip1 alone so this   */
        /* subdir gets deleted as the user specified.                        */
        /*-------------------------------------------------------------------*/
        if (!(ua->ap_Flags & APF_DIDDIR)) {

          /*-----------------------------------------------------------------*/
          /* If we are deleting ALL files, tell the matcher to enter this    */
          /* directory; we also need to skip trying to delete this file      */
          /* until we exit it, as explained above.                           */
          /*-----------------------------------------------------------------*/
          ua->ap_Flags |= APF_DODIR;
          skip1 = TRUE;
        }
        ua->ap_Flags &= ~APF_DIDDIR;
d252 1
a252 1
      /* Now get the next file which matches the given pattern.              */
d258 1
a258 1
      /* delete it.                                                          */
d262 20
a281 20
        /*-------------------------------------------------------------------*/
        /* Unless we are being vewy qwiet, print the name of the file we are */
        /* about to try to delete.                                           */
        /*-------------------------------------------------------------------*/
        if (global->opts[OPT_QUIET] == NULL) {
          PutStr(global->dname);
        }

        /*-------------------------------------------------------------------*/
        /* If we got this far, we can assume we are going to exit with a     */
        /* return code, whether we actually delete the file or not.          */
        /*-------------------------------------------------------------------*/
        global->rc = RETURN_OK;

        /*-------------------------------------------------------------------*/
        /* KILL IT!                                                          */
        /*-------------------------------------------------------------------*/
        global->dcount++;
	  
        trc=DeleteFile(global->dname);
d289 1
a289 1
        	trc=DeleteFile(global->dname);
d293 5
a297 5
          /*-----------------------------------------------------------------*/
          /* If it worked, tell everybody!  Unless we are in QUIET mode, of  */
          /* course!                                                         */
          /*-----------------------------------------------------------------*/
          if (global->opts[OPT_QUIET] == NULL) PutStr(MSG_DELETED);
d300 1
a300 1
        } 
d302 5
a306 5
          /*-----------------------------------------------------------------*/
          /* If we aren't able to kill the file, we need to tell 'em about   */
          /* it and go on.                                                   */
          /*-----------------------------------------------------------------*/
          temprc = IoErr();
a307 1
  	  global->rc = RETURN_FAIL;
d309 11
a319 11
          /*-----------------------------------------------------------------*/
          /* If we have been quiet up to now, we need to go ahead and print  */
          /* the name out.  This was a rather annoying ommision of the BCPL  */
          /* version, in that if you told it to be quiet, it would... except */
          /* when it printed an error message, you never knew WHERE the      */
          /* error had occured.                                              */
          /*-----------------------------------------------------------------*/
          if (global->opts[OPT_QUIET] != NULL) {
            PutStr(global->dname);
          }
          PrintFault(temprc, MSG_NOT_DELETED);
d321 1
a321 1
        }
d327 2
a328 2
    /* are doing fine!  Set the return code so the user knows everything     */
    /* went well.                                                            */
d345 1
a345 1
    /* If there was any other error, tell the user about it and leave!       */
d354 1
a354 1
    /* We have to clean up after ourselves.                                  */
@


1.7
log
@added version string
@
text
@d155 2
a156 1
    CloseLibrary((struct Library *)DOSBase);
a157 1
  if(global.rc)SetIoErr(global.result2);
@


1.6
log
@fixed stopping problem...continues properly
@
text
@d32 1
d39 1
a39 1
#define TEMPLATE        "FILE/M/A,ALL/S,QUIET/S,FORCE/S"
@


1.5
log
@force option works
@
text
@d132 4
a135 2
            global.dcount++;
          } else {
d171 1
a171 1
  LONG temprc,trc;
d201 1
a201 1
    temprc = MatchFirst(name, ua);
d206 1
a206 1
    while (temprc == NULL) {
d247 1
a247 1
      temprc = MatchNext(ua);
@


1.4
log
@changed returncode to warn if file not found
@
text
@d38 1
a38 1
#define TEMPLATE        "FILE/M/A,ALL/S,QUIET/S"
d42 2
a43 1
#define OPT_COUNT       3
d54 1
d153 2
a154 3
  } else {
    OPENFAIL;
  }
d168 2
a169 2
  BOOL skip1;
  int temprc;
d271 6
d278 6
a283 2
        if (DeleteFile(global->dname) != NULL) {

d288 5
a292 5
          if (global->opts[OPT_QUIET] == NULL) {
            PutStr(MSG_DELETED);
          }
        } else {

d298 1
d312 1
a312 1
          temprc = ERROR_NO_MORE_ENTRIES;
d339 2
a340 2
    if (temprc != NULL) {
      PrintFault(IoErr(),NULL);
@


1.3
log
@JT update
@
text
@d38 1
a38 1
#define TEMPLATE        "FILE/M/A,ALL/S,Q=QUIET/S"
d68 1
d165 1
a172 4
  /*-------------------------------------------------------------------------*/
  /* Unfortunately, the most common action is to FAIL!                       */
  /*-------------------------------------------------------------------------*/
  global->rc = RETURN_FAIL;
d179 1
d287 1
a340 1

@


1.2
log
@version number update
@
text
@d11 1
a11 1
/* | .  | || the authors:                             BBS: (919) 382-8265    */
d27 1
a31 1
#include "delete_rev.h"
d38 1
a38 1
#define TEMPLATE        "FILE/M/A,ALL/S,Q=QUIET/S" CMDREV
d51 1
d53 1
a163 1
  char fname[ENVMAX];
d179 1
a179 1
  if ((ua = AllocVec(sizeof(struct AnchorPath)+255,
a186 3
    ua->ap_Strlen = 255;

    /*-----------------------------------------------------------------------*/
d215 1
a215 4
      /* Make a copy of this file's name.  This gets around a BUG in CH's    */
      /* chain routines, which croak if you delete a file out from under     */
      /* them.  Strange, this never happens if you use Examine/ExNext, or    */
      /* FindFirst/FindNext from the ARP.library!                            */
d217 2
a218 1
      strcpy(fname, ua->ap_Buf);
d258 1
a258 1
          PutStr(fname);
d272 1
a272 1
        if (DeleteFile(fname) != NULL) {
d284 2
a285 1
          /* If we aren't able to kill the file, we need to get out!         */
d297 1
a297 1
            PutStr(fname);
a300 1
          break;
@


1.1
log
@new version of command
@
text
@@


1.0
log
@added to rcs
@
text
@d11 1
a11 1
/* | .  | || the authors:                             BBS: (919) 382-8288    */
d31 1
d38 1
a38 1
#define TEMPLATE        "FILE/M/A,ALL/S,Q=QUIET/S"
@
