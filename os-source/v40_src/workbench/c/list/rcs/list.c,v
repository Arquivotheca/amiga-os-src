head     1.27;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @*   @;


1.27
date     91.11.08.11.46.22;  author Jim_Cooper;  state Exp;
branches ;
next     1.26;

1.26
date     91.10.18.16.40.58;  author Jim_Cooper;  state Exp;
branches ;
next     1.25;

1.25
date     91.05.08.08.25.06;  author Jim_Cooper;  state Exp;
branches ;
next     1.24;

1.24
date     91.02.25.22.36.43;  author Jim_Cooper;  state Exp;
branches ;
next     1.23;

1.23
date     91.02.03.09.54.51;  author Jim_Cooper;  state Exp;
branches ;
next     1.22;

1.22
date     91.01.22.19.24.17;  author Jim_Cooper;  state Exp;
branches ;
next     1.21;

1.21
date     91.01.11.12.56.25;  author Jim_Cooper;  state Exp;
branches ;
next     1.20;

1.20
date     91.01.02.18.24.11;  author Jim_Cooper;  state Exp;
branches ;
next     1.19;

1.19
date     91.01.02.00.08.50;  author Jim_Cooper;  state Exp;
branches ;
next     1.18;

1.18
date     90.12.10.22.19.14;  author Jim;  state Exp;
branches ;
next     1.17;

1.17
date     90.10.17.16.10.05;  author Unknown;  state Exp;
branches ;
next     1.16;

1.16
date     90.10.16.10.16.33;  author Unknown;  state Exp;
branches ;
next     1.15;

1.15
date     90.10.16.08.15.58;  author Unknown;  state Exp;
branches ;
next     1.14;

1.14
date     90.10.12.14.24.59;  author Unknown;  state Exp;
branches ;
next     1.13;

1.13
date     90.10.10.21.50.59;  author Unknown;  state Exp;
branches ;
next     1.12;

1.12
date     90.10.10.21.10.07;  author Unknown;  state Exp;
branches ;
next     1.11;

1.11
date     90.09.06.14.18.13;  author eric;  state Exp;
branches ;
next     1.10;

1.10
date     90.09.05.15.35.21;  author eric;  state Exp;
branches ;
next     1.9;

1.9
date     90.06.01.00.42.12;  author andy;  state Exp;
branches ;
next     1.8;

1.8
date     90.05.30.21.15.24;  author andy;  state Exp;
branches ;
next     1.7;

1.7
date     90.05.26.18.51.34;  author andy;  state Exp;
branches ;
next     1.6;

1.6
date     90.05.25.13.56.53;  author andy;  state Exp;
branches ;
next     1.5;

1.5
date     90.04.18.12.43.02;  author Unknown;  state Exp;
branches ;
next     1.4;

1.4
date     90.04.10.11.05.15;  author andy;  state Exp;
branches ;
next     1.3;

1.3
date     90.04.06.15.16.21;  author andy;  state Exp;
branches ;
next     1.2;

1.2
date     90.03.12.20.16.16;  author andy;  state Exp;
branches ;
next     1.1;

1.1
date     90.01.22.19.53.05;  author andy;  state Exp;
branches ;
next     1.0;

1.0
date     90.01.22.19.35.47;  author andy;  state Exp;
branches 1.0.1.1;
next     ;

1.0.1.1
date     90.03.01.19.33.06;  author andy;  state Exp;
branches ;
next     ;


desc
@List command for cdos
@


1.27
log
@Added two new LFORMAT options - %e, and %m.  Also, fixed bug from last
version when descending into directories, LF was printed in wrong place.
@
text
@; /*
lc -d -j73 -rr -O -o/obj/list.o -i/include -v -cisf list
blink /obj/list.o to /bin/list sc sd nd
protect /bin/list +p
quit
*/

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* |_o_o|\\ Copyright (c) 1989 The Software Distillery.  All Rights Reserved */
/* |. o.| || This program may not be distributed without the permission of   */
/* | .	| || the authors:			      BBS: (919) 460-7430    */
/* | o	| ||   Dave Baker      Alan Beale	  Jim Cooper		     */
/* |  . |//    Jay Denebeim    Bruce Drake	  Gordon Keener 	     */
/* ======      John Mainwaring Andy Mercier	  Jack Rouse		     */
/*	       John Toebes     Mary Ellen Toebes  Doug Walker	Mike Witcher */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**	(C) Copyright 1989 Commodore-Amiga, Inc.
 **	    All Rights Reserved
**/

/*---------------------------------------------------------------------------*/
/* Command: List							     */
/* Author:  James E. Cooper Jr. 					     */
/* Change History:							     */
/*  Date     Person	   Action					     */
/* -------  ------------- -----------------				     */
/* 24MAY89  Jim Cooper	  Initial Creation				     */
/* 13DEC89  Jim Cooper	  Time for some serious work; deadline TODAY!	     */
/* 19DEC89  Jim Cooper	  FINALLY! (Even LFORMAT!!!)                         */
/* 30DEC89  Jim Cooper	  Bug Fixes (NULL on 'TO' option, Header and Footer  */
/*			  suppression on 'LFORMAT' option, etc.)             */
/* 19FEB90  Jim Cooper	  You mean nobody noticed that I wasn't printing     */
/*			  FileNotes?  Shows how often it is used.	     */
/* 05MAR90  Jim Cooper	  Finished code for 'ALL' option.                    */
/* 08MAR90  Jim Cooper	  ??BUG reported when 'Global' not initialized.      */
/*			  Also, made "...is empty" work as supposed to.      */
/* 21MAY90  Jim Cooper	  Small change to logic for 'ALL' option, added      */
/*			  "No match found..." message.                       */
/* 22MAY90  Jim Cooper	  Small cleanups to output.			     */
/* 23MAY90  Jim Cooper	  Added new LFORMAT options!			     */
/* 24MAY90  Jim Cooper	  Finished adding new LFORMAT options.	Fixed bug    */
/*			  with occasional (-1) returns.                      */
/* 31AUG90  Jim Cooper	  Final bug, I hope.  Fixed suppression of header    */
/*			  when using QUICK option, hopefully in ALL cases!   */
/* 10OCT90  Jim Cooper	  Cleaned up, fixed 'list since', compiled w/5.10.   */
/* 17OCT90  Jim Cooper	  Fixed problem with extremely long lformat strings. */
/* 20NOV90  Jim Cooper	  Updated for change in DateStamp() prototype.  Also */
/*			  changed BBS number in header, and re-compiled with */
/*			  most recent headers.				     */
/* 10DEC90  Jim Cooper	  Fixed extra lines problems with options of NOHEAD  */
/*			  ALL FILES together.  Also, misalignment on large   */
/*			  files.					     */
/* 20DEC90  Jim Cooper	  Rearranged code slightly.  Fixed problem of wrong  */
/*			  message being printed.			     */
/* 02JAN91  Jim Cooper	  Made SUB switch work again.  Change necessary due  */
/*			  to change in behaviour of DOS AddPart() call.      */
/* 11JAN91  Jim Cooper	  O.K.	Fixed so '#?/#?' style parameters work.      */
/* 22JAN91  Jim Cooper	  Oops!  Minor inconsistency with last change, where */
/*			  two slashes were printed when only one was needed. */
/*			  Only showed up with LFORMAT option.		     */
/* 03FEB91  Jim Cooper	  Yeah!  Finally got 'APF_DirChanged'!  Took nearly  */
/*			  five whole minutes to make use of it! 	     */
/* 25FEB91  Jim Cooper	  Changed to use ap_Buf to enable printing RELATIVE  */
/*			  path (just like 1.3!).  Added '%f' flag to LFORMAT */
/*			  in case you really DO need the FULL path.	     */
/* 08MAY91  Jim Cooper	  Forgot to screen extras recognised by RawDoFmt()   */
/*			  from output string when using LFORMAT option.  Now */
/*			  unrecognised options simply print with '%' in      */
/*			  front of them.				     */
/* 18OCT91  Jim Cooper	  Fixed SUB and PAT options to work as they should   */
/*			  have all along.  Now "list all pat #?.c" will show */
/*			  all .c files on drive.  Also, worked on strings    */
/*			  a little to ease internationalization process.     */
/* 04NOV91  Jim Cooper	  #?!@@&$ forgot to change the position of a linefeed */
/*			  print when I moved strings around in the previous  */
/*			  version.  Fixed.				     */
/* 08NOV91  Jim Cooper	  Added two new LFORMAT options: %E - file Extension */
/*			  and %M - name Minus extension.		     */
/*									     */
/* Notes:								     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Comment out the following line if you do NOT want any new LFormat options */
/*---------------------------------------------------------------------------*/
#define WANT_NEW_LFORMAT

#include "internal/commands.h"
#include "list_rev.h"
/* defines for ReadArgs() */

#define MSG_ARGS_EXCL	"'DATES' and 'NODATES' are mutually exclusive\n"
#define MSG_CANT_OPEN	"*** Can't open %s - "
#define MSG_INVALID_SINCE_UPTO \
"*** Invalid 'UPTO' or 'SINCE' parameter - ignored\n"
#define MSG_DIR 	"Directory \"%s\" "
#define MSG_DIR_EMPTY	"is empty\n"
#define MSG_DIR_ON	"on %s %s\n"
#define MSG_DIR_TYPE	"Dir"
#define MSG_NO_INFO	"No information for \"%s\""
#define MSG_EMPTY	"empty"
#define MSG_TOTAL	"\nTOTAL: "
#define MSG_COUNT	"%ld %s - "
#define MSG_BLOCK	"%ld %s used\n"
#define MSG_MANY_FILES	"files"
#define MSG_ONE_FILE	"file"
#define MSG_MANY_DIRS	"directories"
#define MSG_ONE_DIR	"directory"
#define MSG_MANY_BLOCKS "blocks"
#define MSG_ONE_BLOCK	"block"
#define MSG_PROTBITS	"hsparwed"
#define MSG_NO_MATCH	"No match found\n"
#define MSG_CANT_LIST	"\" cannot be listed: not a FileSystem device\n"
#define MSG_INVALID_DS	"<invalid>"

#define TEMPLATE "DIR/M,P=PAT/K,KEYS/S,DATES/S,NODATES/S,TO/K,SUB/K,SINCE/K,\
UPTO/K,QUICK/S,BLOCK/S,NOHEAD/S,FILES/S,DIRS/S,LFORMAT/K,ALL/S" CMDREV

#define OPT_DIR      0
#define OPT_PAT      1
#define OPT_KEYS     2
#define OPT_DATES    3
#define OPT_NODATES  4
#define OPT_TO	     5
#define OPT_SUB      6
#define OPT_SINCE    7
#define OPT_UPTO     8
#define OPT_QUICK    9
#define OPT_BLOCK   10
#define OPT_NOHEAD  11
#define OPT_FILES   12
#define OPT_DIRS    13
#define OPT_LFORMAT 14
#define OPT_ALL     15
#define OPT_COUNT   16

/*---------------------------------------------------------------------------*/
/* Define the signals we wish the pattern matcher to stop on.		     */
/*---------------------------------------------------------------------------*/
#define BREAK_SIGS SIGBREAKF_CTRL_C | SIGBREAKF_CTRL_D

/*---------------------------------------------------------------------------*/
/* Define the minimum buffer size necessary to format output.		     */
/*---------------------------------------------------------------------------*/
#define MIN_BUFFER 32

/*---------------------------------------------------------------------------*/
/* DirList structure is used to store directory names for ALL option.	     */
/*---------------------------------------------------------------------------*/
struct DirList {
  struct DirList *next;
  char dname[ENVMAX];
};

/*---------------------------------------------------------------------------*/
/* Global structure is used to pass info between the two routines.	     */
/*---------------------------------------------------------------------------*/
struct Global {
  struct DosLibrary *DOSBase;
  long opts[OPT_COUNT];
  long dircount;
  long filecount;
  long numblocks;
  struct DirList *dhead;
  long totaldirs;
  long totalfiles;
  long totalblocks;
  char *lformat;			/* print format specifier string     */
  char *lorder; 			/* order of values for above	     */
  long *listfields;
  long notfirst;
  long scount;
  long rc;
  struct DateStamp now;
  struct DateTime datetime;
  char comdef[4];
  char dow[LEN_DATSTRING];
  char date[LEN_DATSTRING];
  char time[LEN_DATSTRING];
  UBYTE patbuf[ENVMAX*2];
  UBYTE subbuf[ENVMAX*2];
};

int list_dir(struct Global *, char *, struct AnchorPath *,
	     struct DateStamp *, struct DateStamp *);
void PrintDirStats(struct Global *);
void vsprintf(char *, char *, long *);
void prbuf(char c);

/*---------------------------------------------------------------------------*/
/* Main program 							     */
/*---------------------------------------------------------------------------*/
int cmd_list(void)
{
  struct Library *SysBase = (*((struct Library **) 4));
  struct DosLibrary *DOSBase;
  struct RDargs *rdargs;
  struct AnchorPath *ua;
  struct DateStamp since, upto;
  struct Global *global;
  struct DirList *dtemp;
  char curbuf[ENVMAX];
  char subtemp[ENVMAX];
  char **argptr;
  char *dummy[2];
  BPTR tofile, oldoutput;
  long i, j, lfindex, lindex, scount, rc;
  char *temp;
  char c;

  rc = RETURN_FAIL;

  /*-------------------------------------------------------------------------*/
  /* 'dummy' is used to initialize the 'argptr' array, in case the user      */
  /* didn't type any dir names.                                              */
  /*-------------------------------------------------------------------------*/
  dummy[0] = "";
  dummy[1] = NULL;

  /*-------------------------------------------------------------------------*/
  /* Try to open the 2.0 dos.library.					     */
  /*-------------------------------------------------------------------------*/
  if ((DOSBase = (struct DOSLibrary *)OpenLibrary(DOSLIB, DOSVER))) {

    /*-----------------------------------------------------------------------*/
    /* Create our global data area.					     */
    /*-----------------------------------------------------------------------*/
    if ((global = (struct Global *)
	    AllocVec(sizeof(struct Global), MEMF_PUBLIC|MEMF_CLEAR)) == NULL) {
      PrintFault(IoErr(),NULL);
      goto panic;
    }

    /*-----------------------------------------------------------------------*/
    /* Save the DOSBase pointer for later use.				     */
    /*-----------------------------------------------------------------------*/
    global->DOSBase = DOSBase;

    /*-----------------------------------------------------------------------*/
    /* Now try to parse the user's input.                                    */
    /*-----------------------------------------------------------------------*/
    rdargs = ReadArgs(TEMPLATE, global->opts, NULL);

    /*-----------------------------------------------------------------------*/
    /* If we had an error parsing, rdargs should be null.		     */
    /*-----------------------------------------------------------------------*/
    if (rdargs == NULL) {
      PrintFault(IoErr(),NULL);
    } else {

      /*---------------------------------------------------------------------*/
      /* If they gave an LFORMAT option, try to parse it the same way the    */
      /* BCPL version of list does.					     */
      /*---------------------------------------------------------------------*/
      temp = (char *)global->opts[OPT_LFORMAT];

      /*---------------------------------------------------------------------*/
      /* Grab some memory for workspace.				     */
      /*---------------------------------------------------------------------*/
      i = (temp != NULL) ? strlen(temp) : MIN_BUFFER;
      if ((global->lformat = AllocVec(((i<<1)+i+1),
				     MEMF_PUBLIC|MEMF_CLEAR))==NULL) {
	PrintFault(IoErr(), NULL);
	goto listexit;
      }
      global->lorder = global->lformat + (i<<1) + 1;

      if (temp != NULL) {
	for (global->scount=0, i=0; i<strlen(temp); i++) {
	  if ((temp[i] == '%') && ((temp[i+1] & 0x5f) == 'S')) {
	    temp[i+1] = 's';
	    global->scount++;
	  }
	}
	for (i=0,lfindex=0,lindex=0,scount=0; i<strlen(temp); i++) {
	  subtemp[0]=0;
	  global->lformat[lfindex++] = temp[i];
	  if (temp[i] == '%') {
	    j=0;
	    while ((temp[i+1] == '-') ||
		   ((temp[i+1] >= '0') && (temp[i+1] <= '9')) ||
		   (temp[i+1] == '.')) {
	      subtemp[j++] = temp[i+1];
	      i++;
	    }
	    subtemp[j]=0;
	    c = (temp[i+1] & 0x5f);
	    switch (c) {
	      case 'A':
	      case 'B':
	      case 'C':
	      case 'D':
#ifdef WANT_NEW_LFORMAT
	      case 'E':
#endif
	      case 'F':
	      case 'K':
	      case 'L':
#ifdef WANT_NEW_LFORMAT
	      case 'M':
#endif
	      case 'N':
	      case 'P':
	      case 'T':
		temp[i+1] = 's';
		global->lorder[lindex++] = (c+0x20);
		break;
	      case 'S':
		scount++;
		if ((global->scount > 3) && ((scount==1) || (scount == 3))) {
		  global->lorder[lindex++] = 'p';
		} else {
		  if ((global->scount > 1) && (scount==1)) {
		    global->lorder[lindex++] = 'p';
		  } else {
		    global->lorder[lindex++] = 'n';
		  }
		}
		break;
	      default:
		global->lformat[lfindex++] = '%';
		break;
	    }
	    if (subtemp[0]) {
	      j=0;
	      while (subtemp[j]) {
		global->lformat[lfindex++] = subtemp[j++];
	      }
	      subtemp[0]=0;
	    }
	  }
	}
      } else {

	/*-------------------------------------------------------------------*/
	/* They DIDN'T give an LFORMAT option; let's build our output string */
	/* anyway.  Makes life simpler (and faster!) in the other routine.   */
	/*-------------------------------------------------------------------*/
	i = 0;				/* use as index to 'lorder' string.  */

	/*-------------------------------------------------------------------*/
	/* If not using the LFORMAT option, we ALWAYS! print the name.	     */
	/*-------------------------------------------------------------------*/
	global->lorder[i++] = 'n';

	/*-------------------------------------------------------------------*/
	/* QUICK option handling.					     */
	/*-------------------------------------------------------------------*/
	if (global->opts[OPT_QUICK] == NULL) {
	  if (global->opts[OPT_KEYS] != NULL) {
	    strcpy(global->lformat, "%-17s [%5s]");
	    global->lorder[i++] = 'k';
	  } else {
	    strcpy(global->lformat, "%-24s");
	  }
	  strcat(global->lformat, " %7s");
	  if (global->opts[OPT_BLOCK] != NULL) {
	    global->lorder[i++] = 'b';
	  } else {
	    global->lorder[i++] = 'l';
	  }
	  strcat(global->lformat, " %s");
	  global->lorder[i++] = 'a';
	  if (global->opts[OPT_NODATES] == NULL) {
	    strcat(global->lformat, " %-9s %s");
	    global->lorder[i++] = 'd';
	    global->lorder[i++] = 't';
	  }
	  strcpy(global->comdef,"\n: ");
	  strcat(global->lformat, "%s");
	  global->lorder[i] = 'c';
	} else {
	  if (global->opts[OPT_DATES] != NULL) {
	    strcpy(global->lformat, "%-25s %-9s %s");
	    global->lorder[i++] = 'd';
	    global->lorder[i] = 't';
	  } else {
	    strcpy(global->lformat, "%s");
	  }
	}
      }

      /*---------------------------------------------------------------------*/
      /* Now that we know how many variables we need to print, we need to    */
      /* create an array to hold at least that many variables.	We'll make   */
      /* sure we have at least the minimum necessary to handle any default   */
      /* printing as well.						     */
      /*---------------------------------------------------------------------*/
      if ((global->listfields = AllocVec(((strlen(global->lorder) > 4) ?
					 strlen(global->lorder) : 4)
					 * sizeof(long),
					 MEMF_PUBLIC|MEMF_CHIP))==NULL) {
	PrintFault(IoErr(),NULL);
	goto listexit;
      }

      /*---------------------------------------------------------------------*/
      /* 'DATES' and 'NODATES' are the only mutually-exclusive options.      */
      /*---------------------------------------------------------------------*/
      if ((global->opts[OPT_DATES] != NULL) &&
	  (global->opts[OPT_NODATES] != NULL)) {
	PutStr(MSG_ARGS_EXCL);
      } else {
	/*-------------------------------------------------------------------*/
	/* If the user told us where to send the output, try to make sure it */
	/* at least gets started in that direction.			     */
	/*-------------------------------------------------------------------*/
	if (global->opts[OPT_TO] != NULL) {
	  if ((tofile = Open((char *)global->opts[OPT_TO],
			     MODE_NEWFILE)) == NULL) {
	    VPrintf(MSG_CANT_OPEN, &global->opts[OPT_TO]);
	    PrintFault(IoErr(),NULL);
	    goto listexit;
	  } else {
	    oldoutput = SelectOutput(tofile);
	  }
	}
	if ((ua = AllocVec(sizeof(struct AnchorPath)+ENVMAX,
			   MEMF_PUBLIC|MEMF_CLEAR)) == NULL) {
	  PrintFault(IoErr(), NULL);
	} else {

	  /*-----------------------------------------------------------------*/
	  /* Grab the current DateStamp, for future use.		     */
	  /*-----------------------------------------------------------------*/
	  DateStamp((struct DateStamp *)&global->now);

	  /*-----------------------------------------------------------------*/
	  /* If they gave a SINCE option, try to set up for its use.	     */
	  /*-----------------------------------------------------------------*/
	  if (global->opts[OPT_SINCE] != NULL) {
	    memcpy((char *)&global->datetime,(char *)&global->now,
		   sizeof(struct DateStamp));
	    global->datetime.dat_Format = FORMAT_DOS;
	    global->datetime.dat_Flags = DTF_SUBST;
	    global->datetime.dat_StrDate = (char *)global->opts[OPT_SINCE];
	    global->datetime.dat_StrTime = "00:00:00";
	    if (!StrToDate(&global->datetime)) {
	      global->datetime.dat_StrDate = NULL;
	      global->datetime.dat_StrTime = (char *)global->opts[OPT_SINCE];
	      if (!StrToDate(&global->datetime)) {
		PutStr(MSG_INVALID_SINCE_UPTO);
	      } else {
		memcpy((char *)&since,(char *)&global->datetime,
		       sizeof(struct DateStamp));
	      }
	    } else {
	      memcpy((char *)&since,(char *)&global->datetime,
		     sizeof(struct DateStamp));
	    }
	  }

	  /*-----------------------------------------------------------------*/
	  /* Check for an UPTO option, and set it up if present.	     */
	  /*-----------------------------------------------------------------*/
	  if (global->opts[OPT_UPTO] != NULL) {
	    memcpy((char *)&global->datetime,(char *)&global->now,
		   sizeof(struct DateStamp));
	    global->datetime.dat_Format = FORMAT_DOS;
	    global->datetime.dat_Flags = DTF_SUBST;
	    global->datetime.dat_StrDate = (char *)global->opts[OPT_UPTO];
	    global->datetime.dat_StrTime = "23:59:59";
	    if (!StrToDate(&global->datetime)) {
	      global->datetime.dat_StrDate = NULL;
	      global->datetime.dat_StrTime = (char *)global->opts[OPT_UPTO];
	      if (!StrToDate(&global->datetime)) {
		PutStr(MSG_INVALID_SINCE_UPTO);
	      } else {
		memcpy((char *)&upto,(char *)&global->datetime,
		       sizeof(struct DateStamp));
	      }
	    } else {
	      memcpy((char *)&upto,(char *)&global->datetime,
		     sizeof(struct DateStamp));
	    }
	  }

	  /*-----------------------------------------------------------------*/
	  /* Remember 'dummy', from above?  Use it if necessary.             */
	  /*-----------------------------------------------------------------*/
	  if ((argptr = (char **)global->opts[OPT_DIR]) == NULL) {
	    argptr = dummy;
	  }

	  /*-----------------------------------------------------------------*/
	  /* Start parsing the Multi-Args!				     */
	  /*-----------------------------------------------------------------*/
	  while ((*(argptr) != NULL) || (global->dhead != NULL)) {

	    /*---------------------------------------------------------------*/
	    /* If there is anything in 'global->dhead' (which can ONLY occur */
	    /* if the ALL option was used!) we need to take care of any sub- */
	    /* directories before we move on.				     */
	    /*---------------------------------------------------------------*/
	    if (global->dhead != NULL) {
	      strcpy(curbuf, global->dhead->dname);
	      dtemp = global->dhead->next;
	      FreeVec(global->dhead);
	      global->dhead = dtemp;
	    } else {
	      curbuf[0] = 0;
	      AddPart(curbuf, *(argptr++), ENVMAX);
	    }

	    /*---------------------------------------------------------------*/
	    /* Handle PAT and SUB keywords here.			     */
	    /*---------------------------------------------------------------*/
	    if (global->opts[OPT_PAT] != NULL) {
	      ParsePatternNoCase((UBYTE *)global->opts[OPT_PAT],
				 global->patbuf, ENVMAX << 1);
	    } else {
	      if (global->opts[OPT_SUB] != NULL) {
		strcpy(subtemp, "#?");
		strcat(subtemp, (char *)global->opts[OPT_SUB]);
		strcat(subtemp, "#?");
		ParsePatternNoCase(subtemp, global->subbuf, ENVMAX << 1);
	      }
	    }

	    /*---------------------------------------------------------------*/
	    /* Call the match loop.					     */
	    /*---------------------------------------------------------------*/
	    if (list_dir(global,curbuf,ua,&since,&upto) > RETURN_WARN) {
	      break;
	    }

	    if (global->rc != RETURN_OK) {
	      break;
	    }
	  }

	  /*-----------------------------------------------------------------*/
	  /* If we are NOT using the LFORMAT option and we DID use ALL...    */
	  /* and they didn't request not to see it                           */
	  /*-----------------------------------------------------------------*/
	  if ((global->opts[OPT_LFORMAT] == NULL) &&
	      (global->opts[OPT_NOHEAD] == NULL) &&
	      (global->opts[OPT_ALL] != NULL)) {

	    /*---------------------------------------------------------------*/
	    /* Check to see if we HAVE any stats to print...		     */
	    /*---------------------------------------------------------------*/
	    if ((global->totalfiles+global->totaldirs) != NULL) {

	      PutStr(MSG_TOTAL);

	      /*-------------------------------------------------------------*/
	      /* Print total statistics, then exit.			     */
	      /*-------------------------------------------------------------*/
	      if ((global->opts[OPT_DIRS] == NULL) &&
		  (global->totalfiles != NULL)) {
		global->listfields[0] = global->totalfiles;
		if (global->totalfiles > 1L) {
		  global->listfields[1] = (long)MSG_MANY_FILES;
		} else {
		  global->listfields[1] = (long)MSG_ONE_FILE;
		}
		VPrintf(MSG_COUNT, global->listfields);
	      }
	      if ((global->opts[OPT_FILES] == NULL) &&
		  (global->totaldirs != NULL)) {
		global->listfields[0] = global->totaldirs;
		if (global->totaldirs > 1L) {
		  global->listfields[1] = (long)MSG_MANY_DIRS;
		} else {
		  global->listfields[1] = (long)MSG_ONE_DIR;
		}
		VPrintf(MSG_COUNT, global->listfields);
	      }
	      global->listfields[0] = global->totalblocks;
	      if (global->totalblocks > 1L) {
		global->listfields[1] = (long)MSG_MANY_BLOCKS;
	      } else {
		global->listfields[1] = (long)MSG_ONE_BLOCK;
	      }
	      VPrintf(MSG_BLOCK, global->listfields);
	    }
	  }
	}
	FreeVec(ua);

	/*-------------------------------------------------------------------*/
	/* If we have re-directed the output (at the user's request), we     */
	/* have to set the output back to where it was when we started.      */
	/*-------------------------------------------------------------------*/
	if (global->opts[OPT_TO] != NULL) {
	  SelectOutput(oldoutput);
	  Close(tofile);
	}
      }
listexit:
      FreeArgs(rdargs);
      if (global->listfields != NULL) {
	FreeVec(global->listfields);
      }
      if (global->lformat != NULL) {
	FreeVec(global->lformat);
      }
    }

    /*-----------------------------------------------------------------------*/
    /* If there is anything in the DirList, we have to clean it up before we */
    /* exit!								     */
    /*-----------------------------------------------------------------------*/
    while (global->dhead) {
      dtemp = global->dhead->next;
      FreeVec(global->dhead);
      global->dhead = dtemp;
    }

    rc = global->rc;
    FreeVec(global);

panic:
    CloseLibrary((struct Library *)DOSBase);
  } else {
    OPENFAIL;
  }
  return(rc);
}

#define DOSBase global->DOSBase

/*---------------------------------------------------------------------------*/
/* This is the routine which parses the directories, deciding what to print  */
/* based on the user input.						     */
/*---------------------------------------------------------------------------*/
int list_dir(global, dirname, ua, since, upto)
struct Global *global;
char *dirname;
struct AnchorPath *ua;
struct DateStamp *since, *upto;
{
  struct Library *SysBase = (*((struct Library **) 4));
  long temprc=0;
  char namebuf[ENVMAX];
  char dirbuf[ENVMAX];
  char fulldir[ENVMAX];
  char combuf[ENVMAX];
#ifdef WANT_NEW_LFORMAT
  char minusbuf[32];
  char extbuf[32];
#endif
  char blkbuf[16];
  char keybuf[16];
  char lenbuf[16];
  char protbits[9];
  char *tptr;
  long i, entrytype, lindex;
  long rc;
  long didhdr;
  struct DirList *dhead, *dtemp, *dtail;

  dhead = dtail = NULL;
  didhdr = 0L;

  /*-------------------------------------------------------------------------*/
  /* Set the default return code.					     */
  /*-------------------------------------------------------------------------*/
  global->rc = RETURN_FAIL;
  memset((char *)ua, 0, sizeof(struct AnchorPath));

  /*-------------------------------------------------------------------------*/
  /* Set up the AnchorPath structure for use in the pattern match routines.  */
  /*-------------------------------------------------------------------------*/
  ua->ap_BreakBits = SIGBREAKF_CTRL_C;
#if THEY_EVER_IMPLEMENT_THE_FLAG
  ua->ap_Flags |= APF_DOWILD|APF_FollowHLinks;
#else
  ua->ap_Flags |= APF_DOWILD;
#endif
  ua->ap_Strlen = ENVMAX;

  if ((rc=MatchFirst(dirname,ua))==NULL) {
    if (!IsFileSystem(dirname)) {
      PutStr("\"");
      PutStr(dirname);
      PutStr(MSG_CANT_LIST);
      goto ldexit;
    }

    if ((ua->ap_Info.fib_DirEntryType >= 0) && !(ua->ap_Flags&APF_ITSWILD)) {

      ua->ap_Flags |= APF_DODIR;
      if (((rc=MatchNext(ua)) == NULL) && (ua->ap_Flags & APF_DIDDIR)) {

	ua->ap_Flags &= ~APF_DIDDIR;
	if ((global->opts[OPT_LFORMAT] == NULL) &&
	    (global->opts[OPT_NOHEAD] == NULL) &&
	    (global->notfirst)) {
	  PutStr("\n");
	}
	global->notfirst = 1;
	temprc = (long)dirname;
	if ((global->opts[OPT_LFORMAT]==NULL)&&(global->opts[OPT_NOHEAD]==NULL)) {
	  VPrintf(MSG_DIR, &temprc);
	  PutStr(MSG_DIR_EMPTY);
	}
	global->rc = RETURN_OK;
	goto ldexit;
      }
    }
  }

  if(rc)temprc = IoErr();
  if (temprc == ERROR_NO_MORE_ENTRIES) {
    global->rc = RETURN_OK;
    goto ldexit;
  }
  if (temprc == ERROR_BREAK) {
    PrintFault(IoErr(),NULL);
    global->rc = RETURN_WARN;
    goto ldexit;
  }

  if (temprc != NULL) {
    temprc = (long)dirname;
    if ((global->opts[OPT_LFORMAT]==NULL)&&(global->opts[OPT_NOHEAD]==NULL))
	VPrintf(MSG_NO_INFO, &temprc);
    PrintFault(IoErr(), "");
    goto ldexit;
  }

  else {

    /*-----------------------------------------------------------------------*/
    /* Finally, the meat of this routine --- the loop which processes each   */
    /* file.								     */
    /*-----------------------------------------------------------------------*/
    ua->ap_Flags &= ~APF_DIDDIR;
    do {

      /*---------------------------------------------------------------------*/
      /* First check to see if MatchNext() did an internal dir change.       */
      /*---------------------------------------------------------------------*/
      if (ua->ap_Flags & APF_DirChanged) {

	/*-------------------------------------------------------------------*/
	/* The dir has changed... print stats for the last directory, and    */
	/* reset so we print everything correctly!			     */
	/*-------------------------------------------------------------------*/
	PrintDirStats(global);
	didhdr = 0L;
      }

      if (ua->ap_Flags & APF_DIDDIR) {
	ua->ap_Flags &= ~APF_DIDDIR;
/*
	rc=0;
	temprc = ERROR_NO_MORE_ENTRIES;
	break;
*/
	continue;
      }

      /*---------------------------------------------------------------------*/
      /* If we haven't printed a header for this directory yet...            */
      /*---------------------------------------------------------------------*/
      if (didhdr == 0L) {

	/*-------------------------------------------------------------------*/
	/* Get the name of the PARENT of the current file; we need to print  */
	/* it if we print a header, or if the user specified the appropriate */
	/* LFORMAT option.						     */
	/*-------------------------------------------------------------------*/
	/* For regular printing, we need a relative path...		     */
	/*-------------------------------------------------------------------*/
	strcpy(dirbuf, ua->ap_Buf);
	*(PathPart(dirbuf)) = 0;
	strcpy(namebuf, dirbuf);

	/*-------------------------------------------------------------------*/
	/* ...but, if you use %f in LFORMAT, we need the Full path.	     */
	/*-------------------------------------------------------------------*/
	NameFromLock(ua->ap_Current->an_Lock, fulldir, ENVMAX);
	AddPart(fulldir, "", ENVMAX);

	/*-------------------------------------------------------------------*/
	/* Add the trailing ':' or '/' to the directory name, for possible   */
	/* printing use.						     */
	/*-------------------------------------------------------------------*/
	AddPart(dirbuf, "", ENVMAX);

	/*-------------------------------------------------------------------*/
	/* Print a header if we aren't specifically told not to, and we are  */
	/* NOT using the LFORMAT option, and they didn't give us a non-      */
	/* ambiguous fully qualified filespec.				     */
	/*-------------------------------------------------------------------*/
	if ((namebuf[0] != 0) &&
	    (global->opts[OPT_NOHEAD] == NULL) &&
	    (global->opts[OPT_QUICK] == NULL) &&
	    (global->opts[OPT_LFORMAT] == NULL)) {
	  if (global->notfirst) {
	    PutStr("\n");
	  }
	  global->listfields[0] = (long)namebuf;
	  VPrintf(MSG_DIR, global->listfields);
	  memcpy((char *)&global->datetime,(char *)&global->now,
		 sizeof(struct DateStamp));
	  global->datetime.dat_Format  = FORMAT_DOS;
	  global->datetime.dat_Flags   = NULL;
	  global->datetime.dat_StrDay  = global->dow;
	  global->datetime.dat_StrDate = global->date;
	  global->datetime.dat_StrTime = global->time;
	  DateToStr(&global->datetime);
	  global->listfields[0] = (long)global->dow;
	  global->listfields[1] = (long)global->date;
	  VPrintf(MSG_DIR_ON, global->listfields);
	}

	/*-------------------------------------------------------------------*/
	/* Make sure we print a blank line, if we have more to do.	     */
	/*-------------------------------------------------------------------*/
	global->notfirst = 1;

	/*-------------------------------------------------------------------*/
	/* Also, flag that we have printed the header for this directory.    */
	/*-------------------------------------------------------------------*/
	didhdr = 1L;
      }

      entrytype = ua->ap_Info.fib_DirEntryType;

      /*---------------------------------------------------------------------*/
      /* If they requested the ALL option, we must keep track of the	     */
      /* directory names we encounter along the way.  FIFO buffering is used */
      /* for simplicity's sake.                                              */
      /*---------------------------------------------------------------------*/
      if ((global->opts[OPT_ALL] != NULL) && (entrytype >= 0)) {
	if ((dtemp = AllocVec(sizeof(struct DirList),
			      MEMF_PUBLIC|MEMF_CLEAR)) != NULL) {
	  strcpy(dtemp->dname,namebuf);
	  AddPart(dtemp->dname,ua->ap_Info.fib_FileName,ENVMAX);
	  if (dhead == NULL) {
	    dhead = dtail = dtemp;
	  } else {
	    dtail->next = dtemp;
	    dtail = dtemp;
	  }
	}
      }

      /*---------------------------------------------------------------------*/
      /* Check the entry's type, and fit it with the FILES and DIRS options. */
      /*---------------------------------------------------------------------*/
      if (((entrytype < 0) && (global->opts[OPT_DIRS] != NULL)) ||
	  ((entrytype > 0) && (global->opts[OPT_FILES] != NULL))) {
	if ((global->opts[OPT_DIRS] == NULL) ||
	    (global->opts[OPT_FILES] == NULL)) {
	  continue;
	}
      }

      /*---------------------------------------------------------------------*/
      /* Check the current file's DateStamp against the SINCE option, if     */
      /* requested, of course!						     */
      /*---------------------------------------------------------------------*/
      if ((global->opts[OPT_SINCE] != NULL) &&
	  (CompareDates(since,
			(struct DateStamp *)&ua->ap_Info.fib_Date) <= 0)) {
	continue;
      }

      /*---------------------------------------------------------------------*/
      /* Check UPTO here.						     */
      /*---------------------------------------------------------------------*/
      if ((global->opts[OPT_UPTO] != NULL) &&
	  (CompareDates(upto,
			(struct DateStamp *)&ua->ap_Info.fib_Date) >= 0)) {
	continue;
      }

      /*---------------------------------------------------------------------*/
      /* Last, check if it matches the PAT or SUB patterns, if any.	     */
      /*---------------------------------------------------------------------*/
      if (global->patbuf[0]) {
	if (MatchPatternNoCase(global->patbuf,
			       (char *)&ua->ap_Info.fib_FileName) == NULL) {
	  continue;
	}
      } else {
	if (global->subbuf[0]) {
	  if (MatchPatternNoCase(global->subbuf,
				 (char *)&ua->ap_Info.fib_FileName) == NULL) {
	    continue;
	  }
	}
      }

      /*---------------------------------------------------------------------*/
      /* If we made it here, we are good to go on printing this file.  Of    */
      /* course, we have to collect and format all the information first.    */
      /*---------------------------------------------------------------------*/
      memcpy((char *)&global->datetime,(char *)&ua->ap_Info.fib_Date,
	     sizeof(struct DateStamp));
      global->datetime.dat_Format  = FORMAT_DOS;
      global->datetime.dat_Flags =(!global->opts[OPT_DATES]) ?  DTF_SUBST : 0;
				  global->datetime.dat_StrDay  = global->dow;
      global->datetime.dat_StrDate = global->date;
      global->datetime.dat_StrTime = global->time;

      /*---------------------------------------------------------------------*/
      /* If DateToStr() set the fields properly, as in setting "<unset>",    */
      /* "<invalid>", etc. on error, I wouldn't have to do the following     */
      /* check.  I could use the fields directly, instead of setting them    */
      /* myself.							     */
      /*---------------------------------------------------------------------*/
      if (DateToStr(&global->datetime) == NULL) {
	strcpy(global->date, MSG_INVALID_DS);
	strcpy(global->time, MSG_INVALID_DS);
      }

#ifdef WANT_NEW_LFORMAT
      strcpy(minusbuf, ua->ap_Info.fib_FileName);
      tptr = strrchr(minusbuf, '.');
      if (tptr)
      {
	 strcpy(extbuf, &tptr[1]);
	 *tptr = 0;
      }
      else
      {
	 extbuf[0] = 0;
      }
#endif

      vsprintf(blkbuf,"%ld",&ua->ap_Info.fib_NumBlocks);
      vsprintf(keybuf,"%ld",&ua->ap_Info.fib_DiskKey);
      vsprintf(lenbuf,"%ld",&ua->ap_Info.fib_Size);

      /*---------------------------------------------------------------------*/
      /* For speed issues, I have moved this loop here. In previous versions */
      /* I had this loop INSIDE the next, which would have slowed the loop   */
      /* considerably if anyone requested multiple instances of attributes.  */
      /*---------------------------------------------------------------------*/
      strcpy(protbits, MSG_PROTBITS);
      for (i=0; i<8; i++) {
	if ((ua->ap_Info.fib_Protection & (1 << (7-i))) ==
	    ((i<4) ? NULL : (1 << (7-i)))) {
	  protbits[i] = '-';
	}
      }

      for (lindex = 0; (lindex < strlen(global->lorder)); lindex++) {
	switch (global->lorder[lindex]) {

	  /* file protection attributes */
	  case 'a':
	    global->listfields[lindex] = (long)protbits;
	    break;

	  /* file length (in blocks) */
	  case 'b':
	    if (entrytype >= 0) {
	      global->listfields[lindex] = (long)MSG_DIR_TYPE;
	    } else {
	      if (ua->ap_Info.fib_Size == NULL) {
		global->listfields[lindex] = (long)MSG_EMPTY;
	      } else {
		global->listfields[lindex] = (long)blkbuf;
	      }
	    }
	    break;

	  /* file comment */
	  case 'c':
	    global->listfields[lindex] = (long)combuf;
	    if (ua->ap_Info.fib_Comment[0] != NULL) {
	      strcpy(combuf,global->comdef);
	      strcat(combuf,ua->ap_Info.fib_Comment);
	    } else {
	      combuf[0] = 0;
	    }
	    break;

	  /* date field */
	  case 'd':
	    global->listfields[lindex] = (long)global->date;
	    break;

#ifdef WANT_NEW_LFORMAT
	  /* file extension only */
	  case 'e':
	    global->listfields[lindex] = (long)extbuf;
	    break;
#endif

	  /* full path */
	  case 'f':
	    global->listfields[lindex] = (long)fulldir;
	    break;

	  /* file's key block */
	  case 'k':
	    global->listfields[lindex] = (long)keybuf;
	    break;

	  /* file length (in bytes) */
	  case 'l':
	    if (entrytype >= 0) {
	      global->listfields[lindex] = (long)MSG_DIR_TYPE;
	    } else {
	      if (ua->ap_Info.fib_Size == NULL) {
		global->listfields[lindex] = (long)MSG_EMPTY;
	      } else {
		global->listfields[lindex] = (long)lenbuf;
	      }
	    }
	    break;

#ifdef WANT_NEW_LFORMAT
	  /* filename minus extension */
	  case 'm':
	    global->listfields[lindex] = (long)minusbuf;
	    break;
#endif

	  /* filename */
	  case 'n':
	    global->listfields[lindex] = (long)&ua->ap_Info.fib_FileName;
	    break;

	  /* path */
	  case 'p':
	    global->listfields[lindex] = (long)dirbuf;
	    break;

	  /* time field */
	  case 't':
	    global->listfields[lindex] = (long)global->time;
	    break;
	}
      }

      /*---------------------------------------------------------------------*/
      /* Finally!  Print everything we have collected.			     */
      /*---------------------------------------------------------------------*/
      VPrintf(global->lformat, global->listfields);
      PutStr("\n");

      if (entrytype >= 0) {
	if (global->opts[OPT_FILES] == NULL) {
	  global->dircount++;
	  global->totaldirs++;
	}
      } else {
	if (global->opts[OPT_DIRS] == NULL) {
	  global->filecount++;
	  global->totalfiles++;
	}
      }

      /*---------------------------------------------------------------------*/
      /* We must add one to account for the extra block used by the	     */
      /* directory entry itself.					     */
      /*---------------------------------------------------------------------*/
      global->numblocks += ua->ap_Info.fib_NumBlocks+1;
      global->totalblocks += ua->ap_Info.fib_NumBlocks+1;

      if (CheckSignal(SIGBREAKF_CTRL_C) != 0L) {
	Result2(ERROR_BREAK);
	rc = 1;
	break;
      }

    } while ((rc=MatchNext(ua)) == NULL);

    if(rc)temprc = IoErr();
    if((temprc == ERROR_NO_MORE_ENTRIES) || (temprc == 0)) {
      global->rc = RETURN_OK;
    }
    if (temprc == ERROR_BREAK) {
      PrintFault(ERROR_BREAK, NULL);
      global->rc = RETURN_WARN;
    }
ldexit:
    MatchEnd(ua);
  }

  /*-------------------------------------------------------------------------*/
  /* If we have cached any directories, for use with the ALL option, we need */
  /* to add them to the global list for processing.			     */
  /*-------------------------------------------------------------------------*/
  if (dhead) {
    dtail->next = global->dhead;
    global->dhead = dhead;
  }

  /*-------------------------------------------------------------------------*/
  /* Print statistics for the final directory we worked on.		     */
  /*-------------------------------------------------------------------------*/
  PrintDirStats(global);

  return(global->rc);
}

/*---------------------------------------------------------------------------*/
/* This routine prints the statistics for a single directory.  The TOTAL is  */
/* printed in main() (IF the ALL option was used.).                          */
/*---------------------------------------------------------------------------*/
void PrintDirStats(struct Global *global)
{
  struct Library *SysBase = (*((struct Library **) 4));

  /*-------------------------------------------------------------------------*/
  /* If we DIDN'T use the LFORMAT option...                                  */
  /*-------------------------------------------------------------------------*/
  if ((global->opts[OPT_LFORMAT] == NULL) &&
      (global->opts[OPT_NOHEAD] == NULL)) {

    /*-----------------------------------------------------------------------*/
    /* Check to see if we HAVE any stats to print...			     */
    /*-----------------------------------------------------------------------*/
    if ((global->filecount+global->dircount) != NULL) {

      /*---------------------------------------------------------------------*/
      /* Print statistics for this set, then exit.			     */
      /*---------------------------------------------------------------------*/
      if ((global->opts[OPT_DIRS] == NULL) &&
	  (global->filecount != NULL)) {
	global->listfields[0] = global->filecount;
	if (global->filecount > 1L) {
	  global->listfields[1] = (long)MSG_MANY_FILES;
	} else {
	  global->listfields[1] = (long)MSG_ONE_FILE;
	}
	VPrintf(MSG_COUNT, global->listfields);
      }
      if ((global->opts[OPT_FILES] == NULL) &&
	  (global->dircount != NULL)) {
	global->listfields[0] = global->dircount;
	if (global->dircount > 1L) {
	  global->listfields[1] = (long)MSG_MANY_DIRS;
	} else {
	  global->listfields[1] = (long)MSG_ONE_DIR;
	}
	VPrintf(MSG_COUNT, global->listfields);
      }
      global->listfields[0] = global->numblocks;
      if (global->numblocks > 1L) {
	global->listfields[1] = (long)MSG_MANY_BLOCKS;
      } else {
	global->listfields[1] = (long)MSG_ONE_BLOCK;
      }
      VPrintf(MSG_BLOCK, global->listfields);
    }
/*  else PutStr(MSG_NO_MATCH); */
  }

  /*-------------------------------------------------------------------------*/
  /* Clear these for next time around.					     */
  /*-------------------------------------------------------------------------*/
  global->dircount = global->filecount = global->numblocks = 0L;
}

/***
*
* This is a tiny implementation of sprintf for use within List
* It should elminate most needs to format numbers
* Note that it assumes that the buffer is large enough to hold any
* formatted string
*
***/

#pragma syscall RawDoFmt 20a ba9804
extern void __builtin_emit(unsigned short);

void vsprintf(char *buffer, char *ctlstr, long args[])
{
   RawDoFmt(ctlstr, args, prbuf, buffer);
}

/***
*
* The following stub routine is called from RawDoFmt for each
* character in the string.  At invocation, we have:
*    D0 - next character to be formatted
*    A3 - pointer to data buffer
*
***/
void prbuf(char c)
{
__builtin_emit(0x16c0);   /* move.b D0,(A3)+ */
}
@


1.26
log
@Fixed SUB and PAT to proper operation; also fixed strings for better
internationalization.
@
text
@d75 5
d84 5
d294 3
d300 3
d641 4
d649 1
d794 3
a809 4

	  if (global->notfirst) {
	    PutStr("\n");
	  }
d914 14
d982 7
d1011 7
@


1.25
log
@Fixed problem with LFORMAT "%x" causing Enforcer hits.  See source.
@
text
@d71 4
d83 2
a84 2
#define MSG_ARGS_EXCL  "'DATES' and 'NODATES' are mutually exclusive\n"
#define MSG_CANT_OPEN  "*** Can't open %s - "
d87 19
a105 17
#define MSG_DIR_EMPTY  "Directory \"%s\" is empty\n"
#define MSG_DIR_ON     "Directory \"%s\" on %s %s\n"
#define MSG_DIR_TYPE   "Dir"
#define MSG_NO_INFO    "No information for \"%s\""
#define MSG_EMPTY      "empty"
#define MSG_TOTAL      "\nTOTAL: "
#define MSG_FILE       "%ld file%s- "
#define MSG_MANY       "s "
#define MSG_ONE        " "
#define MSG_DIR        "%ld director%s - "
#define MSG_MANY_DIRS  "ies"
#define MSG_ONE_DIR    "y"
#define MSG_BLOCK      "%ld block%sused\n"
#define MSG_PROTBITS   "hsparwed"
#define MSG_NO_MATCH   "No match found\n"
#define MSG_CANT_LIST  "\" cannot be listed: not a FileSystem device\n"
#define MSG_INVALID_DS "<invalid>"
d171 2
a180 2
#define DOSBase global.DOSBase

d187 1
d191 1
a191 1
  struct Global global;
d198 1
a198 1
  long i, j, lfindex, lindex, scount;
d202 1
a202 2
  memset((char *)&global, 0, sizeof(global));
  global.rc = RETURN_FAIL;
d217 14
d233 1
a233 1
    rdargs = ReadArgs(TEMPLATE, global.opts, NULL);
d246 1
a246 1
      temp = (char *)global.opts[OPT_LFORMAT];
d252 1
a252 1
      if ((global.lformat = AllocVec(((i<<1)+i+1),
d257 1
a257 1
      global.lorder = global.lformat + (i<<1) + 1;
d260 1
a260 1
	for (global.scount=0, i=0; i<strlen(temp); i++) {
d263 1
a263 1
	    global.scount++;
d268 1
a268 1
	  global.lformat[lfindex++] = temp[i];
d291 1
a291 1
		global.lorder[lindex++] = (c+0x20);
d295 2
a296 2
		if ((global.scount > 3) && ((scount==1) || (scount == 3))) {
		  global.lorder[lindex++] = 'p';
d298 2
a299 2
		  if ((global.scount > 1) && (scount==1)) {
		    global.lorder[lindex++] = 'p';
d301 1
a301 1
		    global.lorder[lindex++] = 'n';
d306 1
a306 1
		global.lformat[lfindex++] = '%';
d312 1
a312 1
		global.lformat[lfindex++] = subtemp[j++];
d329 1
a329 1
	global.lorder[i++] = 'n';
d334 4
a337 4
	if (global.opts[OPT_QUICK] == NULL) {
	  if (global.opts[OPT_KEYS] != NULL) {
	    strcpy(global.lformat, "%-17s [%5s]");
	    global.lorder[i++] = 'k';
d339 1
a339 1
	    strcpy(global.lformat, "%-24s");
d341 3
a343 3
	  strcat(global.lformat, " %7s");
	  if (global.opts[OPT_BLOCK] != NULL) {
	    global.lorder[i++] = 'b';
d345 1
a345 1
	    global.lorder[i++] = 'l';
d347 6
a352 6
	  strcat(global.lformat, " %s");
	  global.lorder[i++] = 'a';
	  if (global.opts[OPT_NODATES] == NULL) {
	    strcat(global.lformat, " %-9s %s");
	    global.lorder[i++] = 'd';
	    global.lorder[i++] = 't';
d354 3
a356 3
	  strcpy(global.comdef,"\n: ");
	  strcat(global.lformat, "%s");
	  global.lorder[i] = 'c';
d358 4
a361 4
	  if (global.opts[OPT_DATES] != NULL) {
	    strcpy(global.lformat, "%-25s %-9s %s");
	    global.lorder[i++] = 'd';
	    global.lorder[i] = 't';
d363 1
a363 1
	    strcpy(global.lformat, "%s");
d374 2
a375 2
      if ((global.listfields = AllocVec(((strlen(global.lorder) > 4) ?
					 strlen(global.lorder) : 4)
d385 2
a386 2
      if ((global.opts[OPT_DATES] != NULL) &&
	  (global.opts[OPT_NODATES] != NULL)) {
d393 2
a394 2
	if (global.opts[OPT_TO] != NULL) {
	  if ((tofile = Open((char *)global.opts[OPT_TO],
d396 1
a396 1
	    VPrintf(MSG_CANT_OPEN, &global.opts[OPT_TO]);
d411 1
a411 1
	  DateStamp((struct DateStamp *)&global.now);
d416 2
a417 2
	  if (global.opts[OPT_SINCE] != NULL) {
	    memcpy((char *)&global.datetime,(char *)&global.now,
d419 8
a426 8
	    global.datetime.dat_Format = FORMAT_DOS;
	    global.datetime.dat_Flags = DTF_SUBST;
	    global.datetime.dat_StrDate = (char *)global.opts[OPT_SINCE];
	    global.datetime.dat_StrTime = "00:00:00";
	    if (!StrToDate(&global.datetime)) {
	      global.datetime.dat_StrDate = NULL;
	      global.datetime.dat_StrTime = (char *)global.opts[OPT_SINCE];
	      if (!StrToDate(&global.datetime)) {
d429 1
a429 1
		memcpy((char *)&since,(char *)&global.datetime,
d433 1
a433 1
	      memcpy((char *)&since,(char *)&global.datetime,
d441 2
a442 2
	  if (global.opts[OPT_UPTO] != NULL) {
	    memcpy((char *)&global.datetime,(char *)&global.now,
d444 8
a451 8
	    global.datetime.dat_Format = FORMAT_DOS;
	    global.datetime.dat_Flags = DTF_SUBST;
	    global.datetime.dat_StrDate = (char *)global.opts[OPT_UPTO];
	    global.datetime.dat_StrTime = "23:59:59";
	    if (!StrToDate(&global.datetime)) {
	      global.datetime.dat_StrDate = NULL;
	      global.datetime.dat_StrTime = (char *)global.opts[OPT_UPTO];
	      if (!StrToDate(&global.datetime)) {
d454 1
a454 1
		memcpy((char *)&upto,(char *)&global.datetime,
d458 1
a458 1
	      memcpy((char *)&upto,(char *)&global.datetime,
d466 1
a466 1
	  if ((argptr = (char **)global.opts[OPT_DIR]) == NULL) {
d473 1
a473 1
	  while ((*(argptr) != NULL) || (global.dhead != NULL)) {
d476 1
a476 1
	    /* If there is anything in 'global.dhead' (which can ONLY occur  */
d480 5
a484 5
	    if (global.dhead != NULL) {
	      strcpy(curbuf, global.dhead->dname);
	      dtemp = global.dhead->next;
	      FreeVec(global.dhead);
	      global.dhead = dtemp;
d490 6
a495 2
	    if (global.opts[OPT_PAT] != NULL) {
	      AddPart(curbuf, (char *)global.opts[OPT_PAT], ENVMAX);
d497 1
a497 1
	      if (global.opts[OPT_SUB] != NULL) {
d499 1
a499 1
		strcat(subtemp, (char *)global.opts[OPT_SUB]);
d501 1
a501 1
		AddPart(curbuf, subtemp, ENVMAX);
d508 1
a508 1
	    if (list_dir(&global,curbuf,ua,&since,&upto) > RETURN_WARN) {
d512 1
a512 1
	    if (global.rc != RETURN_OK) {
d521 3
a523 3
	  if ((global.opts[OPT_LFORMAT] == NULL) &&
	      (global.opts[OPT_NOHEAD] == NULL) &&
	      (global.opts[OPT_ALL] != NULL)) {
d528 1
a528 1
	    if ((global.totalfiles+global.totaldirs) != NULL) {
d535 5
a539 5
	      if ((global.opts[OPT_DIRS] == NULL) &&
		  (global.totalfiles != NULL)) {
		global.listfields[0] = global.totalfiles;
		if (global.totalfiles > 1L) {
		  global.listfields[1] = (long)MSG_MANY;
d541 1
a541 1
		  global.listfields[1] = (long)MSG_ONE;
d543 1
a543 1
		VPrintf(MSG_FILE, global.listfields);
d545 5
a549 5
	      if ((global.opts[OPT_FILES] == NULL) &&
		  (global.totaldirs != NULL)) {
		global.listfields[0] = global.totaldirs;
		if (global.totaldirs > 1L) {
		  global.listfields[1] = (long)MSG_MANY_DIRS;
d551 1
a551 1
		  global.listfields[1] = (long)MSG_ONE_DIR;
d553 1
a553 1
		VPrintf(MSG_DIR, global.listfields);
d555 3
a557 3
	      global.listfields[0] = global.totalblocks;
	      if (global.totalblocks > 1L) {
		global.listfields[1] = (long)MSG_MANY;
d559 1
a559 1
		global.listfields[1] = (long)MSG_ONE;
d561 1
a561 1
	      VPrintf(MSG_BLOCK, global.listfields);
d571 1
a571 1
	if (global.opts[OPT_TO] != NULL) {
d578 2
a579 2
      if (global.listfields != NULL) {
	FreeVec(global.listfields);
d581 2
a582 2
      if (global.lformat != NULL) {
	FreeVec(global.lformat);
d590 4
a593 4
    while (global.dhead) {
      dtemp = global.dhead->next;
      FreeVec(global.dhead);
      global.dhead = dtemp;
d595 5
d604 1
a604 1
  return(global.rc);
a606 1
#undef DOSBase
d647 3
d651 1
d675 4
a678 2
	if ((global->opts[OPT_LFORMAT]==NULL)&&(global->opts[OPT_NOHEAD]==NULL))
	  VPrintf(MSG_DIR_EMPTY, &temprc);
d774 1
d783 4
a786 2
	  global->listfields[1] = (long)global->dow;
	  global->listfields[2] = (long)global->date;
a789 1
	  VPrintf(MSG_DIR_ON, global->listfields);
d855 17
d1076 1
a1076 1
	  global->listfields[1] = (long)MSG_MANY;
d1078 1
a1078 1
	  global->listfields[1] = (long)MSG_ONE;
d1080 1
a1080 1
	VPrintf(MSG_FILE, global->listfields);
d1090 1
a1090 1
	VPrintf(MSG_DIR, global->listfields);
d1094 1
a1094 1
	global->listfields[1] = (long)MSG_MANY;
d1096 1
a1096 1
	global->listfields[1] = (long)MSG_ONE;
@


1.24
log
@Now prints relative pathname, just like 1.3 used to, and I added an LFORMAT
flag to allow you to print the FULL path name if you wish.
@
text
@d67 4
d191 1
a191 1
  long i, lfindex, lindex, scount;
d232 1
a232 1
      if ((global.lformat = AllocVec((i+(i/2)+1),
d237 1
a237 1
      global.lorder = global.lformat + i + 1;
d247 1
d250 1
d254 1
a254 1
	      global.lformat[lfindex++] = temp[i+1];
d257 1
d285 10
@


1.23
log
@Implemented 'APF_DirChanged' flag support.
@
text
@d64 3
d257 1
d366 1
a366 1
	if ((ua = AllocVec(sizeof(struct AnchorPath),
d578 1
d603 1
d689 1
d695 11
a705 5
	NameFromLock(ua->ap_Current->an_Lock, namebuf, ENVMAX);
	strcpy(dirbuf, namebuf);
	if (namebuf[strlen(namebuf)-1] == '/') {
	  namebuf[strlen(namebuf)-1] = 0;
	}
d718 1
a718 1
	if (((dirname[0] != NULL) || (global->opts[OPT_ALL] != NULL)) &&
d878 5
d886 1
a886 1
	    continue;
d908 1
a908 5
	    if (dirname[0] != NULL) {
	      global->listfields[lindex] = (long)dirbuf;
	    } else {
	      global->listfields[lindex] = NULL;
	    }
@


1.22
log
@Oops!  Double '/' problem with LFORMAT on last change.  FIXED!
@
text
@d62 2
a188 1
  SysBase = (*((struct Library **) 4));
a581 1
  BPTR checklock;
a584 1
  checklock = NULL;
d657 1
a657 3
      /* First check the current lock against our cached one.  If they don't */
      /* match, then MatchNext() has done an internal switch to a new dir.   */
      /* Since this is the only way to find out, we check it ourselves.      */
d659 1
a659 13
      if (checklock != NULL) {
	if (SameLock(checklock,ua->ap_Current->an_Lock) != 0L) {

	  /*-----------------------------------------------------------------*/
	  /* The lock has changed... print stats for the last directory, and */
	  /* reset so we print everything correctly!			     */
	  /*-----------------------------------------------------------------*/
	  PrintDirStats(global);
	  didhdr = 0L;
	  UnLock(checklock);
	  checklock = DupLock(ua->ap_Current->an_Lock);
	}
      } else {
d662 2
a663 1
	/* This must be the first time through, so we simply Dup the lock.   */
d665 2
a666 1
	checklock = DupLock(ua->ap_Current->an_Lock);
a955 7
  }

  /*-------------------------------------------------------------------------*/
  /* If we have a cached directory lock, we need to UnLock() it before exit. */
  /*-------------------------------------------------------------------------*/
  if (checklock != NULL) {
    UnLock(checklock);
@


1.21
log
@Fixed #?/#? processing.  Now prints correct directory names, etc.
@
text
@d59 3
d703 3
@


1.20
log
@Fixed SUB option.  It works again.
@
text
@d58 1
d157 1
d463 2
a464 48
	    /*---------------------------------------------------------------*/
	    /* If we are NOT using the LFORMAT option...		     */
	    /*---------------------------------------------------------------*/
	    if ((global.opts[OPT_LFORMAT] == NULL) &&
		(global.opts[OPT_NOHEAD] == NULL)) {

	      /*-------------------------------------------------------------*/
	      /* Check to see if we HAVE any stats to print...		     */
	      /*-------------------------------------------------------------*/
	      if ((global.filecount+global.dircount) != NULL) {

		/*-----------------------------------------------------------*/
		/* Print statistics for this set, then loop back and see if  */
		/* we have another set to do.				     */
		/*-----------------------------------------------------------*/
		if ((global.opts[OPT_DIRS] == NULL) &&
		    (global.filecount != NULL)) {
		  global.listfields[0] = global.filecount;
		  if (global.filecount > 1L) {
		    global.listfields[1] = (long)MSG_MANY;
		  } else {
		    global.listfields[1] = (long)MSG_ONE;
		  }
		  VPrintf(MSG_FILE, global.listfields);
		}
		if ((global.opts[OPT_FILES] == NULL) &&
		    (global.dircount != NULL)) {
		  global.listfields[0] = global.dircount;
		  if (global.dircount > 1L) {
		    global.listfields[1] = (long)MSG_MANY_DIRS;
		  } else {
		    global.listfields[1] = (long)MSG_ONE_DIR;
		  }
		  VPrintf(MSG_DIR, global.listfields);
		}
		global.listfields[0] = global.numblocks;
		if (global.numblocks > 1L) {
		  global.listfields[1] = (long)MSG_MANY;
		} else {
		  global.listfields[1] = (long)MSG_ONE;
		}
		VPrintf(MSG_BLOCK, global.listfields);
	      }
/*		else PutStr(MSG_NO_MATCH); */

	      if (global.rc != RETURN_OK) {
		break;
	      }
d556 4
d577 2
d582 2
a583 1
  global->dircount = global->filecount = global->numblocks = 0L;
d598 5
a602 13
    i = 0;
    while (dirname[i]) {
      if ((dirbuf[i] = dirname[i]) == ':') {
	dirbuf[i+1] = 0;
	if (!IsFileSystem(dirbuf)) {
	  PutStr("\"");
	  PutStr(dirbuf);
	  PutStr(MSG_CANT_LIST);
	  goto ldexit;
	}
	break;
      }
      ++i;
a647 45
    /* Get the name of the PARENT of the current file; we need to print it   */
    /* if we print a header, or if the user specified the appropriate	     */
    /* LFORMAT option.							     */
    /*-----------------------------------------------------------------------*/
    NameFromLock(ua->ap_Current->an_Lock, namebuf, ENVMAX);
    strcpy(dirbuf, namebuf);

    /*-----------------------------------------------------------------------*/
    /* Add the trailing ':' or '/' to the directory name, for possible       */
    /* printing use.							     */
    /*-----------------------------------------------------------------------*/
    AddPart(dirbuf, "", ENVMAX);

    /*-----------------------------------------------------------------------*/
    /* Print a header if we aren't specifically told not to, and we are NOT  */
    /* using the LFORMAT option, and they didn't give us a non-ambiguous,    */
    /* fully qualified filespec.					     */
    /*-----------------------------------------------------------------------*/
    if (((dirname[0] != NULL) || (global->opts[OPT_ALL] != NULL)) &&
	(global->opts[OPT_NOHEAD] == NULL) &&
	(global->opts[OPT_QUICK] == NULL) &&
	(global->opts[OPT_LFORMAT] == NULL)) {
      global->listfields[0] = (long)namebuf;
      memcpy((char *)&global->datetime,(char *)&global->now,
	     sizeof(struct DateStamp));
      global->datetime.dat_Format  = FORMAT_DOS;
      global->datetime.dat_Flags   = NULL;
      global->datetime.dat_StrDay  = global->dow;
      global->datetime.dat_StrDate = global->date;
      global->datetime.dat_StrTime = global->time;
      DateToStr(&global->datetime);
      global->listfields[1] = (long)global->dow;
      global->listfields[2] = (long)global->date;
      if (global->notfirst) {
	PutStr("\n");
      }
      VPrintf(MSG_DIR_ON, global->listfields);
    }

    /*-----------------------------------------------------------------------*/
    /* Make sure we print a blank line, if we have more to do.		     */
    /*-----------------------------------------------------------------------*/
    global->notfirst = 1;

    /*-----------------------------------------------------------------------*/
d654 25
d686 46
d733 9
a741 1
	continue;
d955 5
d964 13
d978 59
@


1.19
log
@Fixed problem of wrong message for unmounted volume.  Other cleanups,
odds & ends.
@
text
@d56 2
d173 1
d447 4
a450 3
		AddPart(curbuf, "#?", ENVMAX);
		AddPart(curbuf, (char *)global.opts[OPT_SUB], ENVMAX);
		AddPart(curbuf, "#?", ENVMAX);
@


1.18
log
@Fixed several bugs... check comments in source for details.
@
text
@d54 2
d154 1
a154 1
int vsprintf(char *, char *, long *);
d630 32
a661 8
  i = 0;
  while (dirname[i]) {
    if ((dirbuf[i] = dirname[i]) == ':') {
      dirbuf[i+1] = 0;
      if (!IsFileSystem(dirbuf)) {
	PutStr("\"");
	PutStr(dirbuf);
	PutStr(MSG_CANT_LIST);
a663 1
      break;
a664 1
    ++i;
a666 21
  if(((rc=MatchFirst(dirname,ua))==NULL)&&(ua->ap_Info.fib_DirEntryType >= 0)
    && !(ua->ap_Flags&APF_ITSWILD)) {

    ua->ap_Flags |= APF_DODIR;
    if (((rc=MatchNext(ua)) == NULL) && (ua->ap_Flags & APF_DIDDIR)) {

	 ua->ap_Flags &= ~APF_DIDDIR;
	 if ((global->opts[OPT_LFORMAT] == NULL) &&
	     (global->opts[OPT_NOHEAD] == NULL) &&
	     (global->notfirst)) {
	   PutStr("\n");
	 }
	 global->notfirst = 1;
	 temprc = (long)dirname;
	 if ((global->opts[OPT_LFORMAT]==NULL)&&(global->opts[OPT_NOHEAD]==NULL))
		VPrintf(MSG_DIR_EMPTY, &temprc);
	  global->rc = RETURN_OK;
	  goto ldexit;
    }
   }

d829 13
a846 7
	    strcpy(protbits, MSG_PROTBITS);
	    for (i=0; i<8; i++) {
	      if ((ua->ap_Info.fib_Protection & (1 << (7-i))) ==
		  ((i<4) ? NULL : (1 << (7-i)))) {
		protbits[i] = '-';
	      }
	    }
d981 1
a981 1
int vsprintf(char *buffer, char *ctlstr, long args[])
a983 1
   return(strlen(buffer));
@


1.17
log
@Fixed problem with extremely long lformat strings, as per report by Bill Hawes.
@
text
@d11 1
a11 1
/* | .	| || the authors:			      BBS: (919) 382-8265    */
d48 6
d62 1
a62 1
#define MSG_ARGS_EXCL "'DATES' and 'NODATES' are mutually exclusive\n"
d66 17
a82 16
#define MSG_DIR_EMPTY "Directory \"%s\" is empty\n"
#define MSG_DIR_ON    "Directory \"%s\" on %s %s\n"
#define MSG_DIR_TYPE  "Dir"
#define MSG_NO_INFO   "No information for \"%s\""
#define MSG_EMPTY     "empty"
#define MSG_TOTAL     "\nTOTAL: "
#define MSG_FILE      "%ld file%s- "
#define MSG_MANY      "s "
#define MSG_ONE       " "
#define MSG_DIR       "%ld director%s - "
#define MSG_MANY_DIRS "ies"
#define MSG_ONE_DIR   "y"
#define MSG_BLOCK     "%ld block%sused\n"
#define MSG_PROTBITS  "hsparwed"
#define MSG_NO_MATCH  "No match found\n"
#define MSG_CANT_LIST "\" cannot be listed: not a FileSystem device\n"
d153 1
a153 1
static void __regargs prbuf(char c);
d177 1
d287 1
a287 1
	    strcpy(global.lformat, "%-25s");
d289 1
a289 1
	  strcat(global.lformat, " %6s");
d359 1
a359 1
	  DateStamp((long *)&global.now);
d650 5
a654 1
	 if ((global->opts[OPT_LFORMAT]==NULL)&&(global->notfirst))PutStr("\n");
d810 11
a820 1
      DateToStr(&global->datetime);
d895 5
a899 1
	    global->listfields[lindex] = (long)dirbuf;
d934 6
a971 5
static void __regargs prbuf(char c);
#if 0
void RawDoFmt(char *, long[], void(*)(), char *);
#endif

d986 1
a986 1
static void __regargs prbuf(char c)
@


1.16
log
@Damn!  Forgot to null-terminate the string buffer!  FINALLY fixed.
@
text
@d47 1
d104 5
a184 9
    /* Grab some memory for workspace.					     */
    /*-----------------------------------------------------------------------*/
    if ((global.lformat = AllocVec(ENVMAX*4,MEMF_PUBLIC|MEMF_CLEAR))==NULL) {
      PrintFault(IoErr(), NULL);
      goto listexit;
    }
    global.lorder = global.lformat + (ENVMAX * 3);

    /*-----------------------------------------------------------------------*/
d201 12
a600 1
  char *colonptr;
d620 11
a630 8
  if (colonptr=strchr(dirname,':')) {
    strncpy(dirbuf,dirname,colonptr-dirname+1);
    dirbuf[colonptr-dirname+1] = 0;
    if (!IsFileSystem(dirbuf)) {
      PutStr("\"");
      PutStr(dirbuf);
      PutStr(MSG_CANT_LIST);
      goto ldexit;
d632 1
@


1.15
log
@Oops!  1.14 still had problems with non-filesystem devices.  Fixed.
@
text
@d614 1
@


1.14
log
@Fixed list of non-filesystem devices.
@
text
@d74 1
a74 1
#define MSG_CANT_LIST "\" cannot be listed"
d592 1
d612 8
a619 5
  if ((dirname[strlen(dirname)-1] == ':') && !IsFileSystem(dirname)) {
    PutStr("\"");
    PutStr(dirname);
    PrintFault(IoErr(),MSG_CANT_LIST);
    goto ldexit;
@


1.13
log
@Fixed JimM's bug with space padding on LIST QUICK
@
text
@d74 1
d417 2
a418 1
	      strcpy(curbuf, *(argptr++));
d426 2
a427 2
		strcat(curbuf, (char *)global.opts[OPT_SUB]);
		strcat(curbuf, "#?");
d610 7
@


1.12
log
@Bug fixes, SINCE TODAY problems and long command lines
@
text
@a287 1
	  strcpy(global.lformat, "%-25s");
d289 1
a289 1
	    strcat(global.lformat, " %-9s %s");
d292 2
@


1.11
log
@Real new version from John Toebes.
@
text
@d46 1
d141 2
a148 1
  struct DosLibrary *DOSBase;
a177 5
    /* Ok, it opened.  Now save the pointer and move on.		     */
    /*-----------------------------------------------------------------------*/
    global.DOSBase = DOSBase;

    /*-----------------------------------------------------------------------*/
d351 1
a351 1
	    global.datetime.dat_StrTime = NULL;
d376 1
a376 1
	    global.datetime.dat_StrTime = NULL;
d477 1
a477 1
	      } 
d571 3
a579 1
  struct DosLibrary *DOSBase;
a596 5
  /* Make a local copy of DOSBase.					     */
  /*-------------------------------------------------------------------------*/
  DOSBase = global->DOSBase;

  /*-------------------------------------------------------------------------*/
d615 4
a618 4
         if ((global->opts[OPT_LFORMAT]==NULL)&&(global->notfirst))PutStr("\n");
         global->notfirst = 1;
         temprc = (long)dirname;
         if ((global->opts[OPT_LFORMAT]==NULL)&&(global->opts[OPT_NOHEAD]==NULL))
d620 2
a621 2
          global->rc = RETURN_OK;
          goto ldexit;
d701 1
a701 1
        rc=0;
d703 1
a703 1
        break;
d706 1
a706 1
 	continue;
d768 1
a768 1
			          global->datetime.dat_StrDay  = global->dow;
a775 9

      /****************************************/
      /* WHAT IN THE HELL IS WRONG!!!!!!!!!!! */
      /* If I don't include the following two */
      /* lines, I can't print the TIME field. */

      global->listfields[0] = (long)global->dow;
      global->listfields[1] = (long)global->date;
      /****************************************/
@


1.10
log
@New version from John Toebes
@
text
@@


1.9
log
@more fixed on the wildcard routines
@
text
@d1 1
a1 1
 /*
d44 2
d668 2
a669 1
    /* using the LFORMAT option.					     */
d673 1
@


1.8
log
@fixed its pattern match code
@
text
@d1 1
a1 1
; /*
d478 3
a480 3
	      } else {
		PutStr(MSG_NO_MATCH);
	      }
d580 1
a580 1
  long temprc;
d589 1
d612 3
a614 2
  if ((MatchFirst(dirname,ua)==NULL) && (ua->ap_Info.fib_DirEntryType >= 0)
    && (!(ua->ap_Flags&APF_ITSWILD) || global->opts[OPT_ALL]) ) {
d616 10
a625 12
    if ((MatchNext(ua) == NULL) && (ua->ap_Flags & APF_DIDDIR)) {
      if ((global->opts[OPT_LFORMAT]==NULL) && (global->notfirst != NULL)) {
	PutStr("\n");
      }
      global->notfirst = 1;
      temprc = (long)dirname;
      if ((global->opts[OPT_LFORMAT]==NULL)&&(global->opts[OPT_NOHEAD]==NULL))
	VPrintf(MSG_DIR_EMPTY, &temprc);
      global->rc = RETURN_OK;
      goto ldexit;
    } else {
      temprc = IoErr();
d627 1
a627 3
  } else {
    temprc = IoErr();
  }
d629 1
d639 1
d646 3
a648 1
  } else {
d697 1
d699 3
d703 1
a703 1
      if (ua->ap_Flags & APF_DIDDIR) {
d705 4
a708 1
	break;
d710 1
a710 1
*/
d735 2
a736 2
      if (((entrytype < NULL) && (global->opts[OPT_DIRS] != NULL)) ||
	  ((entrytype > NULL) && (global->opts[OPT_FILES] != NULL))) {
d892 1
a892 3
    } while (MatchNext(ua) == NULL);

    temprc = IoErr();
d894 2
a895 1
    if (temprc == 0L) {
@


1.7
log
@DATES option now lists the dates
@
text
@d287 1
a287 1
	  global.lorder[i++] = 'c';
d293 1
a293 1
	    global.lorder[i++] = 't';
d611 2
a612 1
  if ((MatchFirst(dirname,ua)==NULL) && (ua->ap_Info.fib_DirEntryType >= 0)) {
d696 1
a696 1

d701 1
@


1.6
log
@new version from the Software Distillery
@
text
@d758 2
a759 2
      global->datetime.dat_Flags   = DTF_SUBST;
      global->datetime.dat_StrDay  = global->dow;
@


1.5
log
@found a couple more messages that escaped the lformat test
Also, now actually stops on a control-C
@
text
@d11 5
a15 5
/* | .  | || the authors:                             BBS: (919) 382-8265    */
/* | o  | ||   Dave Baker      Alan Beale         Jim Cooper                 */
/* |  . |//    Jay Denebeim    Bruce Drake        Gordon Keener              */
/* ======      John Mainwaring Andy Mercier       Jack Rouse                 */
/*             John Toebes     Mary Ellen Toebes  Doug Walker   Mike Witcher */
d18 2
a19 2
/**     (C) Copyright 1989 Commodore-Amiga, Inc.
 **         All Rights Reserved
d23 23
a45 16
/* Command: List                                                             */
/* Author:  James E. Cooper Jr.                                              */
/* Change History:                                                           */
/*  Date     Person        Action                                            */
/* -------  ------------- -----------------                                  */
/* 24MAY89  Jim Cooper    Initial Creation                                   */
/* 13DEC89  Jim Cooper    Time for some serious work; deadline TODAY!        */
/* 19DEC89  Jim Cooper    FINALLY! (Even LFORMAT!!!)                         */
/* 30DEC89  Jim Cooper    Bug Fixes (NULL on 'TO' option, Header and Footer  */
/*                        suppression on 'LFORMAT' option, etc.)             */
/* 19FEB90  Jim Cooper    You mean nobody noticed that I wasn't printing     */
/*                        FileNotes?  Shows how often it is used.            */
/* 05MAR90  Jim Cooper    Finished code for 'ALL' option.                    */
/* 08MAR90  Jim Cooper    ??BUG reported when 'Global' not initialized.      */
/*                        Also, made "...is empty" work as supposed to.      */
/* Notes:                                                                    */
d50 1
a50 1
/* defines for GADS */
d52 1
d56 15
a70 14
#define MSG_DIR_EMPTY  "Directory \"%s\" is empty\n"
#define MSG_DIR_ON     "Directory \"%s\" on %s %s\n"
#define MSG_DIR_TYPE   "    Dir"
#define MSG_NO_INFO    "No information for \"%s\""
#define MSG_EMPTY      "  empty"
#define MSG_TOTAL      "\nTOTAL: "
#define MSG_FILE       "%ld file%s- "
#define MSG_MANY       "s "
#define MSG_ONE        " "
#define MSG_DIR        "%ld director%s - "
#define MSG_MANY_DIRS  "ies"
#define MSG_ONE_DIR    "y"
#define MSG_BLOCK      "%ld block%sused\n"
#define MSG_PROTBITS   "hsparwed"
a71 1
#ifdef COMPAT
a72 3
UPTO/K,QUICK/S,BLOCK/S,NOHEAD/S,FILES/S,DIRS/S,LFORMAT/K" CMDREV
#else
#define TEMPLATE "DIR/M,P=PAT/K,KEYS/S,DATES/S,NODATES/S,TO/K,SUB/K,SINCE/K,\
a73 1
#endif
d80 1
a80 1
#define OPT_TO       5
a89 4

#ifdef COMPAT
#define OPT_COUNT   15
#else
a91 1
#endif
d94 1
a94 1
/* Define the signals we wish the pattern matcher to stop on.                */
a97 1
#ifndef COMPAT
d99 1
a99 1
/* DirList structure is used to store directory names for ALL option.        */
a104 1
#endif
d107 1
a107 1
/* Global structure is used to pass info between the two routines.           */
a114 1
#ifndef COMPAT
d119 3
a121 5
#endif
  struct DateStamp now;
  struct DateTime datetime;
  char dow[LEN_DATSTRING], date[LEN_DATSTRING], time[LEN_DATSTRING];
  long listfields[9];
d125 6
d134 3
a136 1
             struct DateStamp *, struct DateStamp *);
d139 1
a139 1
/* Main program                                                              */
a148 1
#ifndef COMPAT
a149 1
#endif
a150 3
#ifdef COMPAT
  char *curarg;
#endif
d154 3
a156 1
  long i;
d159 1
d169 1
a169 1
  /* Try to open the 1.4 dos.library.                                        */
d174 1
a174 1
    /* Ok, it opened.  Now save the pointer and move on.                     */
d179 9
d193 1
a193 1
    /* If we had an error parsing, rdargs should be null.                    */
d201 1
a201 1
      /* BCPL version of list does.                                          */
d203 107
a309 9
      if (global.opts[OPT_LFORMAT] != NULL) {
        for (global.scount=0, i=0;
             i<strlen((char *)global.opts[OPT_LFORMAT]);i++) {
          if ((((char *)global.opts[OPT_LFORMAT])[i] == '%') &&
              ((((char *)global.opts[OPT_LFORMAT])[i+1] & 0x5F) == 'S')) {
	    ((char *)global.opts[OPT_LFORMAT])[i+1] = 's';
            global.scount++;
          }
        }
d316 2
a317 2
          (global.opts[OPT_NODATES] != NULL)) {
        PrintFault(ERROR_REQUIRED_ARG_MISSING, NULL);
d319 116
a434 104
        /*-------------------------------------------------------------------*/
        /* If the user told us where to send the output, try to make sure it */
        /* at least gets started in that direction.                          */
        /*-------------------------------------------------------------------*/
        if (global.opts[OPT_TO] != NULL) {
          if ((tofile = Open((char *)global.opts[OPT_TO],
                             MODE_NEWFILE)) == NULL) {
            VPrintf(MSG_CANT_OPEN, &global.opts[OPT_TO]);
            PrintFault(IoErr(),NULL);
            goto listexit;
          } else {
            oldoutput = SelectOutput(tofile);
          }
        }
        if ((ua = AllocVec(sizeof(struct AnchorPath),
                           MEMF_PUBLIC|MEMF_CLEAR)) == NULL) {
          PrintFault(IoErr(), NULL);
        } else {

          /*-----------------------------------------------------------------*/
          /* Grab the current DateStamp, for future use.                     */
          /*-----------------------------------------------------------------*/
          DateStamp((long *)&global.now);

          /*-----------------------------------------------------------------*/
          /* If they gave a SINCE option, try to set up for its use.         */
          /*-----------------------------------------------------------------*/
          if (global.opts[OPT_SINCE] != NULL) {
            memcpy((char *)&global.datetime,(char *)&global.now,
                   sizeof(struct DateStamp));
            global.datetime.dat_Format = FORMAT_DOS;
            global.datetime.dat_Flags = DTF_SUBST;
            global.datetime.dat_StrDate = (char *)global.opts[OPT_SINCE];
            global.datetime.dat_StrTime = NULL;
            if (!StrToDate(&global.datetime)) {
              global.datetime.dat_StrDate = NULL;
              global.datetime.dat_StrTime = (char *)global.opts[OPT_SINCE];
              if (!StrToDate(&global.datetime)) {
                PutStr(MSG_INVALID_SINCE_UPTO);
              }
            }
            memcpy((char *)&since,(char *)&global.datetime,
                   sizeof(struct DateStamp));
          }

          /*-----------------------------------------------------------------*/
          /* Check for an UPTO option, and set it up if present.             */
          /*-----------------------------------------------------------------*/
          if (global.opts[OPT_UPTO] != NULL) {
            memcpy((char *)&global.datetime,(char *)&global.now,
                   sizeof(struct DateStamp));
            global.datetime.dat_Format = FORMAT_DOS;
            global.datetime.dat_Flags = DTF_SUBST;
            global.datetime.dat_StrDate = (char *)global.opts[OPT_UPTO];
            global.datetime.dat_StrTime = NULL;
            if (!StrToDate(&global.datetime)) {
              global.datetime.dat_StrDate = NULL;
              global.datetime.dat_StrTime = (char *)global.opts[OPT_UPTO];
              if (!StrToDate(&global.datetime)) {
                PutStr(MSG_INVALID_SINCE_UPTO);
              }
            }
            memcpy((char *)&upto,(char *)&global.datetime,
                   sizeof(struct DateStamp));
          }

          /*-----------------------------------------------------------------*/
          /* Remember 'dummy', from above?  Use it if necessary.             */
          /*-----------------------------------------------------------------*/
          if ((argptr = (char **)global.opts[OPT_DIR]) == NULL) {
            argptr = dummy;
          }

#ifdef COMPAT
          /*-----------------------------------------------------------------*/
          /* Start parsing the Multi-Args!                                   */
          /*-----------------------------------------------------------------*/
          while (argptr && (curarg = *(argptr++))) {

            /*---------------------------------------------------------------*/
            /* We need a copy of the current argument, in case we have to    */
            /* modify it with a pattern/substring argument.                  */
            /*---------------------------------------------------------------*/
            strcpy(curbuf, curarg);
#else
          /*-----------------------------------------------------------------*/
          /* Start parsing the Multi-Args!                                   */
          /*-----------------------------------------------------------------*/
          while ((*(argptr) != NULL) || (global.dhead != NULL)) {

            /*---------------------------------------------------------------*/
            /* If there is anything in 'global.dhead' (which can ONLY occur  */
            /* if the ALL option was used!) we need to take care of any sub- */
            /* directories before we move on.                                */
            /*---------------------------------------------------------------*/
            if (global.dhead != NULL) {
              strcpy(curbuf, global.dhead->dname);
              dtemp = global.dhead->next;
              FreeVec(global.dhead);
              global.dhead = dtemp;
            } else {
              strcpy(curbuf, *(argptr++));
            }
#endif
d436 4
a439 21
            if (global.opts[OPT_PAT] != NULL) {
              AddPart(curbuf, (char *)global.opts[OPT_PAT], ENVMAX);
            } else {
              if (global.opts[OPT_SUB] != NULL) {
                AddPart(curbuf, "#?", ENVMAX);
                strcat(curbuf, (char *)global.opts[OPT_SUB]);
                strcat(curbuf, "#?");
              }
            }

            /*---------------------------------------------------------------*/
            /* Call the match loop.                                          */
            /*---------------------------------------------------------------*/
            if (list_dir(&global,curbuf,ua,&since,&upto) >= RETURN_WARN) {
              break;
            }

            /*---------------------------------------------------------------*/
            /* If we are NOT using the LFORMAT option...                     */
            /*---------------------------------------------------------------*/
            if ((global.opts[OPT_LFORMAT] == NULL) && 
d442 4
a445 4
              /*-------------------------------------------------------------*/
              /* Check to see if we HAVE any stats to print...               */
              /*-------------------------------------------------------------*/
              if ((global.filecount+global.dircount) != NULL) {
d447 45
a491 44
                /*-----------------------------------------------------------*/
                /* Print statistics for this set, then loop back and see if  */
                /* we have another set to do.                                */
                /*-----------------------------------------------------------*/
                if ((global.opts[OPT_DIRS] == NULL) &&
                    (global.filecount != NULL)) {
                  global.listfields[0] = global.filecount;
                  if (global.filecount > 1L) {
                    global.listfields[1] = (long)MSG_MANY;
                  } else {
                    global.listfields[1] = (long)MSG_ONE;
                  }
                  VPrintf(MSG_FILE, global.listfields);
                }
                if ((global.opts[OPT_FILES] == NULL) &&
                    (global.dircount != NULL)) {
                  global.listfields[0] = global.dircount;
                  if (global.dircount > 1L) {
                    global.listfields[1] = (long)MSG_MANY_DIRS;
                  } else {
                    global.listfields[1] = (long)MSG_ONE_DIR;
                  }
                  VPrintf(MSG_DIR, global.listfields);
                }
                global.listfields[0] = global.numblocks;
                if (global.numblocks > 1L) {
                  global.listfields[1] = (long)MSG_MANY;
                } else {
                  global.listfields[1] = (long)MSG_ONE;
                }
                VPrintf(MSG_BLOCK, global.listfields);
              }
              if (global.rc != RETURN_OK) {
                break;
              }
            }
          }
#ifndef COMPAT

          /*-----------------------------------------------------------------*/
          /* If we are NOT using the LFORMAT option and we DID use ALL...    */
	  /* and they didn't request not to see it 			     */
          /*-----------------------------------------------------------------*/
          if ((global.opts[OPT_LFORMAT] == NULL) &&
d493 1
a493 44
              (global.opts[OPT_ALL] != NULL)) {

            /*---------------------------------------------------------------*/
            /* Check to see if we HAVE any stats to print...                 */
            /*---------------------------------------------------------------*/
            if ((global.totalfiles+global.totaldirs) != NULL) {

              PutStr(MSG_TOTAL);

              /*-------------------------------------------------------------*/
              /* Print total statistics, then exit.                          */
              /*-------------------------------------------------------------*/
              if ((global.opts[OPT_DIRS] == NULL) &&
                  (global.totalfiles != NULL)) {
                global.listfields[0] = global.totalfiles;
                if (global.totalfiles > 1L) {
                  global.listfields[1] = (long)MSG_MANY;
                } else {
                  global.listfields[1] = (long)MSG_ONE;
                }
                VPrintf(MSG_FILE, global.listfields);
              }
              if ((global.opts[OPT_FILES] == NULL) &&
                  (global.totaldirs != NULL)) {
                global.listfields[0] = global.totaldirs;
                if (global.totaldirs > 1L) {
                  global.listfields[1] = (long)MSG_MANY_DIRS;
                } else {
                  global.listfields[1] = (long)MSG_ONE_DIR;
                }
                VPrintf(MSG_DIR, global.listfields);
              }
              global.listfields[0] = global.totalblocks;
              if (global.totalblocks > 1L) {
                global.listfields[1] = (long)MSG_MANY;
              } else {
                global.listfields[1] = (long)MSG_ONE;
              }
              VPrintf(MSG_BLOCK, global.listfields);
            }
          }
#endif
        }
        FreeVec(ua);
d495 50
a544 8
        /*-------------------------------------------------------------------*/
        /* If we have re-directed the output (at the user's request), we     */
        /* have to set the output back to where it was when we started.      */
        /*-------------------------------------------------------------------*/
        if (global.opts[OPT_TO] != NULL) {
          SelectOutput(oldoutput);
          Close(tofile);
        }
d548 6
a554 1
#ifndef COMPAT
d558 1
a558 1
    /* exit!                                                                 */
a564 1
#endif
a580 2
  char protbits[9];
  char pformat[32];
d583 6
a588 2
  long i, entrytype;
#ifndef COMPAT
d592 1
a592 2
#endif
  global->dircount = global->filecount = global->numblocks = NULL;
d595 1
a595 1
  /* Make a local copy of DOSBase.                                           */
d600 1
a600 1
  /* Set the default return code.                                            */
d611 1
a611 2
  temprc = MatchFirst(dirname, ua);
  if ((temprc == NULL) && (ua->ap_Info.fib_DirEntryType >= 0)) {
d613 3
a615 4
    temprc = MatchNext(ua);
    if (ua->ap_Flags & APF_DIDDIR) {
      if (global->notfirst != NULL) {
        PutStr("\n");
d620 1
a620 1
	    VPrintf(MSG_DIR_EMPTY, &temprc);
d623 2
d626 3
a629 1
  }
d642 1
a642 1
        VPrintf(MSG_NO_INFO, &temprc);
d649 2
a650 2
    /* if we print a header, or if the user specified the appropriate        */
    /* LFORMAT option.                                                       */
d657 1
a657 1
    /* printing use.                                                         */
d661 7
a667 7
    /*---------------------------------------------------------------------*/
    /* Print a header if we aren't specifially told not to, and we are NOT */
    /* using the LFORMAT option.                                           */
    /*---------------------------------------------------------------------*/
    if ((dirname[0] != NULL) &&
        (global->opts[OPT_NOHEAD] == NULL) &&
        (global->opts[OPT_LFORMAT] == NULL)) {
d670 4
a673 4
             sizeof(struct DateStamp));
      global->datetime.dat_Format = FORMAT_DOS;
      global->datetime.dat_Flags = NULL;
      global->datetime.dat_StrDay = global->dow;
d676 1
a678 1
      DateToStr(&global->datetime);
d680 1
a680 1
        PutStr("\n");
d683 1
a683 1
    	}
d686 1
a686 1
    /* Make sure we print a blank line, if we have more to do.               */
d692 1
a692 1
    /* file.                                                                 */
d697 2
a698 2
        temprc = ERROR_NO_MORE_ENTRIES;
        break;
d703 19
d725 5
a729 5
          ((entrytype > NULL) && (global->opts[OPT_FILES] != NULL))) {
        if ((global->opts[OPT_DIRS] == NULL) ||
            (global->opts[OPT_FILES] == NULL)) {
          continue;
        }
d734 1
a734 1
      /* requested, of course!                                               */
d737 3
a739 3
          (CompareDates(since,
                        (struct DateStamp *)&ua->ap_Info.fib_Date) < 0)) {
        continue;
d743 1
a743 1
      /* Check UPTO here.                                                    */
d746 3
a748 3
          (CompareDates(upto,
                        (struct DateStamp *)&ua->ap_Info.fib_Date) > 0)) {
        continue;
d755 8
a762 23
      memset((char *)global->listfields, 0, sizeof(global->listfields));
      global->listfields[0] = (long)&ua->ap_Info.fib_FileName;

#ifndef COMPAT
      /*---------------------------------------------------------------------*/
      /* If they requested the ALL option, we must keep track of the         */
      /* directory names we encounter along the way.  FIFO buffering is used */
      /* for simplicity's sake.                                              */
      /*---------------------------------------------------------------------*/
      if ((global->opts[OPT_ALL] != NULL) && (entrytype >= 0)) {
        if ((dtemp = AllocVec(sizeof(struct DirList),
                              MEMF_PUBLIC|MEMF_CLEAR)) != NULL) {
          strcpy(dtemp->dname,namebuf);
          AddPart(dtemp->dname,ua->ap_Info.fib_FileName,ENVMAX);
          if (dhead == NULL) {
            dhead = dtail = dtemp;
          } else {
            dtail->next = dtemp;
            dtail = dtemp;
          }
        }
      }
#endif
d764 3
a766 10
      /*---------------------------------------------------------------------*/
      /* KEYS option handling.                                               */
      /*---------------------------------------------------------------------*/
      if (global->opts[OPT_KEYS] != NULL) {
        strcpy(pformat, "%-17s [%5ld]");
        global->listfields[1] = ua->ap_Info.fib_DiskKey;
      } else {
        strcpy(pformat, "%-25s%s");
        global->listfields[1] = (long)"";
      }
d768 90
d859 2
a860 58
      /* QUICK option handling.                                              */
      /*---------------------------------------------------------------------*/
      if (global->opts[OPT_QUICK] == NULL) {
        if (entrytype >= 0) {
          strcat(pformat, "%s");
          global->listfields[2] = (long)MSG_DIR_TYPE;
        } else {
          if (ua->ap_Info.fib_Size == NULL) {
            strcat(pformat, "%s");
            global->listfields[2] = (long)MSG_EMPTY;
          } else {
            strcat(pformat, " %6ld");
            global->listfields[2] = ua->ap_Info.fib_Size;
            if (global->opts[OPT_BLOCK] != NULL) {
              global->listfields[2] = ua->ap_Info.fib_NumBlocks;
            }
          }
        }
        strcat(pformat, " %s");
        strcpy(protbits, MSG_PROTBITS);
        for (i=0; i<8; i++) {
          if ((ua->ap_Info.fib_Protection & (1 << (7-i))) ==
              ((i<4) ? NULL : (1 << (7-i)))) {
            protbits[i] = '-';
          }
        }
        global->listfields[3] = (long)protbits;
      }

      /*---------------------------------------------------------------------*/
      /* All this is really necessary to make this work like the BCPL        */
      /* version of the List command.  Has to do with which fields go with   */
      /* which options.                                                      */
      /*---------------------------------------------------------------------*/
      if (((global->opts[OPT_DATES] != NULL) &&
           (global->opts[OPT_QUICK] != NULL)) ||
          ((global->opts[OPT_NODATES] == NULL) &&
           (global->opts[OPT_QUICK] == NULL))) {

        if(!global->opts[OPT_NODATES])strcat(pformat, " %-9s %s"); /* don't print date */

        memset((char *)&global->datetime, 0, sizeof(global->datetime));
        memcpy((char *)&global->datetime,(char *)&ua->ap_Info.fib_Date,
               sizeof(struct DateStamp));
        global->datetime.dat_Format = FORMAT_DOS;
        if(!global->opts[OPT_DATES])global->datetime.dat_Flags = DTF_SUBST;
        global->datetime.dat_StrDay = global->dow;
        global->datetime.dat_StrDate = global->date;
        global->datetime.dat_StrTime = global->time;
        DateToStr(&global->datetime);
        if (global->opts[OPT_QUICK] != NULL) {
          global->listfields[2] = (long)global->date;
          global->listfields[3] = (long)global->time;
        } else {
          global->listfields[4] = (long)global->date;
          global->listfields[5] = (long)global->time;
        }
      }
d863 4
a866 6
        if (global->opts[OPT_FILES] == NULL) {
          global->dircount++;
#ifndef COMPAT
          global->totaldirs++;
#endif
        }
d868 4
a871 6
        if (global->opts[OPT_DIRS] == NULL) {
          global->filecount++;
#ifndef COMPAT
          global->totalfiles++;
#endif
        }
d875 2
a876 2
      /* We must add one to account for the extra block used by the          */
      /* directory entry itself.                                             */
a878 1
#ifndef COMPAT
a879 2
#endif
      strcat(pformat, "\n");
d881 1
a881 11
      /*---------------------------------------------------------------------*/
      /* If the user did NOT give an LFORMAT option, print everything we     */
      /* have collected.
      /*---------------------------------------------------------------------*/
      if (global->opts[OPT_LFORMAT] == NULL) {
        VPrintf(pformat, global->listfields);
        if (ua->ap_Info.fib_Comment[0] != NULL) {
          global->listfields[0] = (long)&ua->ap_Info.fib_Comment;
          VPrintf(": %s\n", global->listfields);
        }
      } else {
d883 1
a883 15
        /*-------------------------------------------------------------------*/
        /* If they DID give an LFORMAT option, print the pieces in the order */
        /* the user specified, according to the same rules the BCPL List     */
        /* used.                                                             */
        /*-------------------------------------------------------------------*/
        global->listfields[1] = global->listfields[0];
        if (global->scount > 1) {
            global->listfields[0] = (long)dirbuf;
        }
        global->listfields[2] = global->listfields[(global->scount==3) ? 1:0];
        global->listfields[3] = global->listfields[1];
        VPrintf((char *)global->opts[OPT_LFORMAT], global->listfields);
        PutStr("\n");
      }
    } while ((temprc = MatchNext(ua)) == NULL);
d885 1
a885 1
    if (temprc == ERROR_NO_MORE_ENTRIES) {
a894 1
#ifndef COMPAT
d899 18
d918 18
a935 1
  return(global->rc);
@


1.4
log
@fixed DATES, NODATES, and NOHEAD functions
@
text
@d199 1
d330 1
a330 1
            if (list_dir(&global,curbuf,ua,&since,&upto) > RETURN_WARN) {
d501 1
a501 1
  ua->ap_BreakBits = BREAK_SIGS;
d514 2
a515 1
      VPrintf(MSG_DIR_EMPTY, &temprc);
d532 2
a533 1
    VPrintf(MSG_NO_INFO, &temprc);
d574 1
a574 1
    }
d750 1
a750 1
      /* have collected.                                                     */
@


1.3
log
@pattern match code fixed, obeys dates, etc.
@
text
@a210 1

d336 2
a337 1
            if (global.opts[OPT_LFORMAT] == NULL) {
d385 1
d388 1
d698 3
a700 1
        strcat(pformat, " %-9s %s");
d705 1
a705 1
        global->datetime.dat_Flags = DTF_SUBST;
@


1.2
log
@errors out on error out, inits globals
@
text
@d141 1
d470 1
d587 11
@


1.1
log
@new version of command
@
text
@d11 5
a15 5
/* | .	| || the authors:			      BBS: (919) 382-8265    */
/* | o	| ||   Dave Baker      Alan Beale	  Jim Cooper		     */
/* |  . |//    Jay Denebeim    Bruce Drake	  Gordon Keener 	     */
/* ======      John Mainwaring Andy Mercier	  Jack Rouse		     */
/*	       John Toebes     Mary Ellen Toebes  Doug Walker	Mike Witcher */
d18 2
a19 2
/**	(C) Copyright 1989 Commodore-Amiga, Inc.
 **	    All Rights Reserved
d23 16
a38 11
/* Command: List							     */
/* Author:  James E. Cooper Jr. 					     */
/* Change History:							     */
/*  Date     Person	   Action					     */
/* -------  ------------- -----------------				     */
/* 24MAY89  Jim Cooper	  Initial Creation				     */
/* 13DEC89  Jim Cooper	  Time for some serious work; deadline TODAY!	     */
/* 19DEC89  Jim Cooper	  FINALLY! (Even LFORMAT!!!)                         */
/* 30DEC89  Jim Cooper	  Bug Fixes (NULL on 'TO' option, Header and Footer  */
/*			  suppression on 'LFORMAT' option, etc.)             */
/* Notes:								     */
d53 1
d60 1
a60 1
#define MSG_BLOCK      "%ld block%sused\n\n"
d63 7
a69 2
#define TEMPLATE "DIR/M,P=PAT/K,KEYS/S,DATES/S,NODATES/S,TO/K,SUB/K,\
SINCE/K,UPTO/K,QUICK/S,BLOCK/S,NOHEAD/S,FILES/S,DIRS/S,LFORMAT/K" CMDREV
d76 1
a76 1
#define OPT_TO	     5
d86 2
d89 1
a89 2

#if 0
d91 1
a91 1
#define OPT_SORT    16
d95 1
a95 1
/* Define the signals we wish the pattern matcher to stop on.		     */
d99 1
d101 1
a101 1
/* Global structure is used to pass info between the two routines.	     */
d103 9
d118 6
d127 3
a129 1
  long listfields[6];
d134 1
a134 1
	     struct DateStamp *, struct DateStamp *);
d137 1
a137 1
/* Main program 							     */
d146 3
d150 4
a153 1
  char *curarg, **argptr;
d156 1
d158 2
d168 1
a168 1
  /* Try to open the 1.4 dos.library.					     */
d173 1
a173 1
    /* Ok, it opened.  Now save the pointer and move on.		     */
a175 1
    memset((char *)global.opts, 0, sizeof(global.opts));
d183 1
a183 1
    /* If we had an error parsing, rdargs should be null.		     */
d190 14
d207 2
a208 2
	  (global.opts[OPT_NODATES] != NULL)) {
	PrintFault(ERROR_REQUIRED_ARG_MISSING, NULL);
d211 18
a228 18
	/*-------------------------------------------------------------------*/
	/* If the user told us where to send the output, try to make sure it */
	/* at least gets started in that direction.			     */
	/*-------------------------------------------------------------------*/
	if (global.opts[OPT_TO] != NULL) {
	  if ((tofile = Open((char *)global.opts[OPT_TO],
			     MODE_NEWFILE)) == NULL) {
	    VPrintf(MSG_CANT_OPEN, &global.opts[OPT_TO]);
	    PrintFault(IoErr(),NULL);
	    goto listexit;
	  } else {
	    oldoutput = SelectOutput(tofile);
	  }
	}
	if ((ua = AllocVec(sizeof(struct AnchorPath)+255,
			   MEMF_CLEAR|MEMF_PUBLIC)) == NULL) {
	  PrintFault(IoErr(), NULL);
	} else {
d230 4
a233 4
	  /*-----------------------------------------------------------------*/
	  /* Grab the current DateStamp, for future use.		     */
	  /*-----------------------------------------------------------------*/
	  DateStamp((long *)&global.now);
d235 20
a254 20
	  /*-----------------------------------------------------------------*/
	  /* If they gave a SINCE option, try to set up for its use.	     */
	  /*-----------------------------------------------------------------*/
	  if (global.opts[OPT_SINCE] != NULL) {
	    memcpy((char *)&global.datetime,(char *)&global.now,
		   sizeof(struct DateStamp));
	    global.datetime.dat_Format = FORMAT_DOS;
	    global.datetime.dat_Flags = DTF_SUBST;
	    global.datetime.dat_StrDate = (char *)global.opts[OPT_SINCE];
	    global.datetime.dat_StrTime = NULL;
	    if (!StrToDate(&global.datetime)) {
	      global.datetime.dat_StrDate = NULL;
	      global.datetime.dat_StrTime = (char *)global.opts[OPT_SINCE];
	      if (!StrToDate(&global.datetime)) {
		PutStr(MSG_INVALID_SINCE_UPTO);
	      }
	    }
	    memcpy((char *)&since,(char *)&global.datetime,
		   sizeof(struct DateStamp));
	  }
d256 20
a275 20
	  /*-----------------------------------------------------------------*/
	  /* Check for an UPTO option, and set it up if present.	     */
	  /*-----------------------------------------------------------------*/
	  if (global.opts[OPT_UPTO] != NULL) {
	    memcpy((char *)&global.datetime,(char *)&global.now,
		   sizeof(struct DateStamp));
	    global.datetime.dat_Format = FORMAT_DOS;
	    global.datetime.dat_Flags = DTF_SUBST;
	    global.datetime.dat_StrDate = (char *)global.opts[OPT_UPTO];
	    global.datetime.dat_StrTime = NULL;
	    if (!StrToDate(&global.datetime)) {
	      global.datetime.dat_StrDate = NULL;
	      global.datetime.dat_StrTime = (char *)global.opts[OPT_UPTO];
	      if (!StrToDate(&global.datetime)) {
		PutStr(MSG_INVALID_SINCE_UPTO);
	      }
	    }
	    memcpy((char *)&upto,(char *)&global.datetime,
		   sizeof(struct DateStamp));
	  }
d277 6
a282 6
	  /*-----------------------------------------------------------------*/
	  /* Remember 'dummy', from above?  Use it if necessary.             */
	  /*-----------------------------------------------------------------*/
	  if ((argptr = (char **)global.opts[OPT_DIR]) == NULL) {
	    argptr = dummy;
	  }
d284 5
a288 4
	  /*-----------------------------------------------------------------*/
	  /* Start parsing the Multi-Args!				     */
	  /*-----------------------------------------------------------------*/
	  while (argptr && (curarg = *argptr++)) {
d290 10
a299 5
	    /*---------------------------------------------------------------*/
	    /* We need a copy of the current argument, in case we have to    */
	    /* modify it with a pattern/substring argument.		     */
	    /*---------------------------------------------------------------*/
	    strcpy(curbuf, curarg);
d301 14
a314 9
	    if (global.opts[OPT_PAT] != NULL) {
	      AddPart(curbuf, (char *)global.opts[OPT_PAT], ENVMAX);
	    } else {
	      if (global.opts[OPT_SUB] != NULL) {
		AddPart(curbuf, "#?", ENVMAX);
		strcat(curbuf, (char *)global.opts[OPT_SUB]);
		strcat(curbuf, "#?");
	      }
	    }
d316 9
a324 6
	    /*---------------------------------------------------------------*/
	    /* Call the match loop.					     */
	    /*---------------------------------------------------------------*/
	    if (list_dir(&global,curbuf,ua,&since,&upto) > RETURN_WARN) {
	      break;
	    }
d326 6
a331 4
	    /*---------------------------------------------------------------*/
	    /* If we are NOT using the LFORMAT option...		     */
	    /*---------------------------------------------------------------*/
	    if (global.opts[OPT_LFORMAT] == NULL) {
d333 4
a336 38
	      /*-------------------------------------------------------------*/
	      /* Print statistics for this set, then loop back and see if we */
	      /* have another set to do.				     */
	      /*-------------------------------------------------------------*/
	      if ((global.opts[OPT_DIRS] == NULL) &&
		  (global.filecount != NULL)) {
		global.listfields[0] = global.filecount;
		if (global.filecount > 1L) {
		  global.listfields[1] = (long)MSG_MANY;
		} else {
		  global.listfields[1] = (long)MSG_ONE;
		}
		VPrintf(MSG_FILE, global.listfields);
	      }
	      if ((global.opts[OPT_FILES] == NULL) &&
		  (global.dircount != NULL)) {
		global.listfields[0] = global.dircount;
		if (global.dircount > 1L) {
		  global.listfields[1] = (long)MSG_MANY_DIRS;
		} else {
		  global.listfields[1] = (long)MSG_ONE_DIR;
		}
		VPrintf(MSG_DIR, global.listfields);
	      }
	      global.listfields[0] = global.numblocks;
	      if (global.numblocks > 1L) {
		global.listfields[1] = (long)MSG_MANY;
	      } else {
		global.listfields[1] = (long)MSG_ONE;
	      }
	      VPrintf(MSG_BLOCK, global.listfields);
	    }
	    if (global.rc != RETURN_OK) {
	      break;
	    }
	  }
	}
	FreeVec(ua);
d338 101
a438 8
	/*-------------------------------------------------------------------*/
	/* If we have re-directed the output (at the user's request), we     */
	/* have to set the output back to where it was when we started.      */
	/*-------------------------------------------------------------------*/
	if (global.opts[OPT_TO] != NULL) {
	  SelectOutput(oldoutput);
	  Close(tofile);
	}
d443 12
d473 4
a476 1
  long i, entrytype, scount;
d478 4
d483 1
a483 1
  /* Make a local copy of DOSBase.					     */
d488 1
a488 1
  /* Set the default return code.					     */
a495 1
  ua->ap_Strlen = 255;
d503 11
a515 2
    temprc = (long)dirname;
    VPrintf(MSG_DIR_EMPTY, &temprc);
d533 2
a534 2
    /* if we print a header, or if the user specified the appropriate	     */
    /* LFORMAT option.							     */
d537 1
a538 2
    global->dircount = global->filecount = global->numblocks = NULL;

d540 2
a541 2
    /* Print a header if we aren't specifially told not to, and we are NOT   */
    /* using the LFORMAT option.					     */
d543 6
d550 2
a551 2
	(global->opts[OPT_NOHEAD] == NULL) &&
	(global->opts[OPT_LFORMAT] == NULL)) {
d554 1
a554 1
	     sizeof(struct DateStamp));
d563 3
d570 5
d576 1
a576 1
    /* file.								     */
d579 1
d581 2
a582 2
	temprc = ERROR_NO_MORE_ENTRIES;
	break;
d584 1
d587 2
a588 2
      /* Check the current file's DateStamp against the SINCE option,        */
      /* if requested, of course!					     */
d591 3
a593 3
	  (CompareDates(since,
			(struct DateStamp *)&ua->ap_Info.fib_Date) < 0)) {
	continue;
d595 1
d597 1
a597 1
      /* Check UPTO here.						     */
d600 3
a602 3
	  (CompareDates(upto,
			(struct DateStamp *)&ua->ap_Info.fib_Date) > 0)) {
	continue;
a607 2
      /* Also, we have to be sure to count ONE extra block used by the	     */
      /* directory entry itself.					     */
a608 2
      ++global->numblocks;
      entrytype = ua->ap_Info.fib_DirEntryType;
d612 1
d614 3
a616 1
      /* KEYS option handling.						     */
d618 18
d637 2
a638 2
	strcpy(pformat, "%-17s [%5ld]");
	global->listfields[1] = ua->ap_Info.fib_DiskKey;
d640 2
a641 2
	strcpy(pformat, "%-25s%s");
	global->listfields[1] = (long)"";
d645 1
a645 1
      /* QUICK option handling. 					     */
d648 24
a671 24
	if (ua->ap_Info.fib_DirEntryType >= 0) {
	  strcat(pformat, "%s");
	  global->listfields[2] = (long)MSG_DIR_TYPE;
	} else {
	  if (ua->ap_Info.fib_Size == NULL) {
	    strcat(pformat, "%s");
	    global->listfields[2] = (long)MSG_EMPTY;
	  } else {
	    strcat(pformat, " %6ld");
	    global->listfields[2] = ua->ap_Info.fib_Size;
	    if (global->opts[OPT_BLOCK] != NULL) {
	      global->listfields[2] = ua->ap_Info.fib_NumBlocks;
	    }
	  }
	}
	strcat(pformat, " %s");
	strcpy(protbits, MSG_PROTBITS);
	for (i=0; i<8; i++) {
	  if ((ua->ap_Info.fib_Protection & (1 << (7-i))) ==
	      ((i<4) ? NULL : (1 << (7-i)))) {
	    protbits[i] = '-';
	  }
	}
	global->listfields[3] = (long)protbits;
d675 1
a675 1
      /* All this is really necessary to make this work like the BCPL	     */
d677 1
a677 1
      /* which options. 						     */
d680 20
a699 20
	   (global->opts[OPT_QUICK] != NULL)) ||
	  ((global->opts[OPT_NODATES] == NULL) &&
	   (global->opts[OPT_QUICK] == NULL))) {
	strcat(pformat, " %-9s %s");
	memset((char *)&global->datetime, 0, sizeof(global->datetime));
	memcpy((char *)&global->datetime,(char *)&ua->ap_Info.fib_Date,
	       sizeof(struct DateStamp));
	global->datetime.dat_Format = FORMAT_DOS;
	global->datetime.dat_Flags = DTF_SUBST;
	global->datetime.dat_StrDay = global->dow;
	global->datetime.dat_StrDate = global->date;
	global->datetime.dat_StrTime = global->time;
	DateToStr(&global->datetime);
	if (global->opts[OPT_QUICK] != NULL) {
	  global->listfields[2] = (long)global->date;
	  global->listfields[3] = (long)global->time;
	} else {
	  global->listfields[4] = (long)global->date;
	  global->listfields[5] = (long)global->time;
	}
d703 6
a708 3
	if (global->opts[OPT_FILES] == NULL) {
	  global->dircount++;
	}
d710 6
a715 3
	if (global->opts[OPT_DIRS] == NULL) {
	  global->filecount++;
	}
d717 9
a725 1
      global->numblocks += ua->ap_Info.fib_NumBlocks;
d730 1
a730 1
      /* have collected.						     */
d733 5
a737 1
	VPrintf(pformat, global->listfields);
d740 13
a752 19
	/*-------------------------------------------------------------------*/
	/* If they DID give an LFORMAT option, try to parse it the same as   */
	/* the BCPL version of list does it.				     */
	/*-------------------------------------------------------------------*/
	AddPart(namebuf, "", ENVMAX);
	for (scount=0,i=0;i<strlen((char *)global->opts[OPT_LFORMAT]);i++) {
	  if ((((char *)global->opts[OPT_LFORMAT])[i] == '%') &&
	      (((char *)global->opts[OPT_LFORMAT])[i+1] == 's')) {
	    scount++;
	  }
	}
	if (!(scount & 1)) {
	  global->listfields[1] = global->listfields[0];
	  global->listfields[0] = (long)&namebuf;
	}
	global->listfields[2] = global->listfields[0];
	global->listfields[3] = global->listfields[1];
	VPrintf((char *)global->opts[OPT_LFORMAT], global->listfields);
	PutStr("\n");
d755 1
d766 6
@


1.0
log
@added to rcs
@
text
@d11 5
a15 5
/* | .	| || the authors:                             BBS: (919) 382-8265    */
/* | o	| ||   Dave Baker      Alan Beale         Jim Cooper                 */
/* |  . |//    Jay Denebeim    Bruce Drake        Gordon Keener              */
/* ======      John Mainwaring Andy Mercier       Jack Rouse                 */
/*             John Toebes     Mary Ellen Toebes  Doug Walker   Mike Witcher */
d23 6
a28 6
/* Command: List                                                             */
/* Author:  James E. Cooper Jr.                                              */
/* Change History:                                                           */
/*  Date     Person        Action                                            */
/* -------  ------------- -----------------                                  */
/* 24MAY89  Jim Cooper    Initial Creation                                   */
d30 4
a33 2
/* 19DEC89  Jim Cooper    FINALLY! (Even LFORMAT!!!)                         */
/* Notes:                                                                    */
d65 1
a65 1
#define OPT_TO       5
d88 1
a88 1
/* Global structure is used to pass info between the two routines.           */
d103 2
a104 2
int list_dir(struct Global *, char *, struct AnchorPath *, 
             struct DateStamp *, struct DateStamp *);
d107 1
a107 1
/* Main program                                                              */
d129 1
a129 1
  /* Try to open the 1.4 dos.library.                                        */
d134 1
a134 1
    /* Ok, it opened.  Now save the pointer and move on.                     */
d145 1
a145 1
    /* If we had an error parsing, rdargs should be null.                    */
d154 3
a156 3
      if ((global.opts[OPT_DATES] != NULL) && 
          (global.opts[OPT_NODATES] != NULL)) {
        PrintFault(ERROR_REQUIRED_ARG_MISSING, NULL);
d159 18
a176 18
        /*-------------------------------------------------------------------*/
        /* If the user told us where to send the output, try to make sure it */
        /* at least gets started in that direction.                          */
        /*-------------------------------------------------------------------*/
        if (global.opts[OPT_TO] != NULL) {
          if ((tofile = Open((char *)global.opts[OPT_TO],
                             MODE_NEWFILE)) == NULL) {
            VPrintf(MSG_CANT_OPEN, &global.opts[OPT_TO]);
            PrintFault(IoErr(),NULL);
            goto listexit;
          } else {
            oldoutput = SelectOutput(tofile);
          }
        }
        if ((ua = AllocVec(sizeof(struct AnchorPath)+255,
                           MEMF_CLEAR|MEMF_PUBLIC)) == NULL) {
          PrintFault(IoErr(), NULL);
        } else {
d178 4
a181 4
          /*-----------------------------------------------------------------*/
          /* Grab the current DateStamp, for future use.                     */
          /*-----------------------------------------------------------------*/
          DateStamp((long *)&global.now);
d183 20
a202 20
          /*-----------------------------------------------------------------*/
          /* If they gave a SINCE option, try to set up for its use.         */
          /*-----------------------------------------------------------------*/
          if (global.opts[OPT_SINCE] != NULL) {
            memcpy((char *)&global.datetime,(char *)&global.now,
                   sizeof(struct DateStamp));
            global.datetime.dat_Format = FORMAT_DOS;
            global.datetime.dat_Flags = DTF_SUBST;
            global.datetime.dat_StrDate = (char *)global.opts[OPT_SINCE];
            global.datetime.dat_StrTime = NULL;
            if (!StrToDate(&global.datetime)) {
              global.datetime.dat_StrDate = NULL;
              global.datetime.dat_StrTime = (char *)global.opts[OPT_SINCE];
              if (!StrToDate(&global.datetime)) {
                PutStr(MSG_INVALID_SINCE_UPTO);
              }
            }
            memcpy((char *)&since,(char *)&global.datetime,
                   sizeof(struct DateStamp));
          }
d204 20
a223 20
          /*-----------------------------------------------------------------*/
          /* Check for an UPTO option, and set it up if present.             */
          /*-----------------------------------------------------------------*/
          if (global.opts[OPT_UPTO] != NULL) {
            memcpy((char *)&global.datetime,(char *)&global.now,
                   sizeof(struct DateStamp));
            global.datetime.dat_Format = FORMAT_DOS;
            global.datetime.dat_Flags = DTF_SUBST;
            global.datetime.dat_StrDate = (char *)global.opts[OPT_UPTO];
            global.datetime.dat_StrTime = NULL;
            if (!StrToDate(&global.datetime)) {
              global.datetime.dat_StrDate = NULL;
              global.datetime.dat_StrTime = (char *)global.opts[OPT_UPTO];
              if (!StrToDate(&global.datetime)) {
                PutStr(MSG_INVALID_SINCE_UPTO);
              }
            }
            memcpy((char *)&upto,(char *)&global.datetime,
                   sizeof(struct DateStamp));
          }
d225 6
a230 6
          /*-----------------------------------------------------------------*/
          /* Remember 'dummy', from above?  Use it if necessary.             */
          /*-----------------------------------------------------------------*/
          if ((argptr = (char **)global.opts[OPT_DIR]) == NULL) {
            argptr = dummy;
          }
d232 4
a235 4
          /*-----------------------------------------------------------------*/
          /* Start parsing the Multi-Args!                                   */
          /*-----------------------------------------------------------------*/
          while (argptr && (curarg = *argptr++)) {
d237 5
a241 5
            /*---------------------------------------------------------------*/
            /* We need a copy of the current argument, in case we have to    */
            /* modify it with a pattern/substring argument.                  */
            /*---------------------------------------------------------------*/
            strcpy(curbuf, curarg);
d243 9
a251 9
            if (global.opts[OPT_PAT] != NULL) {
              AddPart(curbuf, (char *)global.opts[OPT_PAT], ENVMAX);
            } else {
              if (global.opts[OPT_SUB] != NULL) {
                AddPart(curbuf, "#?", ENVMAX);
                strcat(curbuf, (char *)global.opts[OPT_SUB]);
                strcat(curbuf, "#?");
              }
            }
d253 6
a258 6
            /*---------------------------------------------------------------*/
            /* Call the match loop.                                          */
            /*---------------------------------------------------------------*/
            if (list_dir(&global,curbuf,ua,&since,&upto) > RETURN_WARN) {
              break;
            }
d260 4
a263 37
            /*---------------------------------------------------------------*/
            /* Print statistics for this set, then loop back and see if we   */
            /* have another set to do.                                       */
            /*---------------------------------------------------------------*/
            if ((global.opts[OPT_DIRS] == NULL) &&
                (global.filecount != NULL)) {
              global.listfields[0] = global.filecount;
              if (global.filecount > 1L) {
                global.listfields[1] = (long)MSG_MANY;
              } else {
                global.listfields[1] = (long)MSG_ONE;
              }
              VPrintf(MSG_FILE, global.listfields);
            }
            if ((global.opts[OPT_FILES] == NULL) &&
                (global.dircount != NULL)) {
              global.listfields[0] = global.dircount;
              if (global.dircount > 1L) {
                global.listfields[1] = (long)MSG_MANY_DIRS;
              } else {
                global.listfields[1] = (long)MSG_ONE_DIR;
              }
              VPrintf(MSG_DIR, global.listfields);
            }
            global.listfields[0] = global.numblocks;
            if (global.numblocks > 1L) {
              global.listfields[1] = (long)MSG_MANY;
            } else {
              global.listfields[1] = (long)MSG_ONE;
            }
            VPrintf(MSG_BLOCK, global.listfields);
            if (global.rc != RETURN_OK) {
              break;
            }
          }
        }
        FreeVec(ua);
d265 47
a311 8
        /*-------------------------------------------------------------------*/
        /* If we have re-directed the output (at the user's request), we     */
        /* have to set the output back to where it was when we started.      */
        /*-------------------------------------------------------------------*/
        if (global.opts[OPT_TO] != NULL) {
          SelectOutput(oldoutput);
          Close(tofile);
        }
d337 1
a337 1
  /* Make a local copy of DOSBase.                                           */
d342 1
a342 1
  /* Set the default return code.                                            */
d379 2
a380 2
    /* if we print a header, or if the user specified the appropriate        */
    /* LFORMAT option.                                                       */
d387 2
a388 1
    /* Print a header if we aren't specifially told not to.                  */
d390 3
a392 1
    if ((dirname[0] != NULL) && (global->opts[OPT_NOHEAD] == NULL)) {
d395 1
a395 1
             sizeof(struct DateStamp));
d409 1
a409 1
    /* file.                                                                 */
d413 2
a414 2
        temprc = ERROR_NO_MORE_ENTRIES;
        break;
d419 1
a419 1
      /* if requested, of course!                                            */
d422 3
a424 3
          (CompareDates(since,
                        (struct DateStamp *)&ua->ap_Info.fib_Date) < 0)) {
        continue;
d427 1
a427 1
      /* Check UPTO here.                                                    */
d430 3
a432 3
          (CompareDates(upto,
                        (struct DateStamp *)&ua->ap_Info.fib_Date) > 0)) {
        continue;
d438 2
a439 2
      /* Also, we have to be sure to count ONE extra block used be the       */
      /* directory entry itself.                                             */
d447 1
a447 1
      /* KEYS option handling.                                               */
d450 2
a451 2
        strcpy(pformat, "%-17s [%5ld]");
        global->listfields[1] = ua->ap_Info.fib_DiskKey;
d453 2
a454 2
        strcpy(pformat, "%-25s%s");
        global->listfields[1] = NULL;
d458 1
a458 1
      /* QUICK option handling.                                              */
d461 24
a484 24
        if (ua->ap_Info.fib_DirEntryType >= 0) {
          strcat(pformat, "%s");
          global->listfields[2] = (long)MSG_DIR_TYPE;
        } else {
          if (ua->ap_Info.fib_Size == NULL) {
            strcat(pformat, "%s");
            global->listfields[2] = (long)MSG_EMPTY;
          } else {
            strcat(pformat, " %6ld");
            global->listfields[2] = ua->ap_Info.fib_Size;
            if (global->opts[OPT_BLOCK] != NULL) {
              global->listfields[2] = ua->ap_Info.fib_NumBlocks;
            }
          }
        }
        strcat(pformat, " %s");
        strcpy(protbits, MSG_PROTBITS);
        for (i=0; i<8; i++) {
          if ((ua->ap_Info.fib_Protection & (1 << (7-i))) == 
              ((i<4) ? NULL : (1 << (7-i)))) {
            protbits[i] = '-';
          }
        }
        global->listfields[3] = (long)protbits;
d488 1
a488 1
      /* All this is really necessary to make this work like the BCPL        */
d490 1
a490 1
      /* which options.                                                      */
d493 20
a512 20
           (global->opts[OPT_QUICK] != NULL)) ||
          ((global->opts[OPT_NODATES] == NULL) &&
           (global->opts[OPT_QUICK] == NULL))) {
        strcat(pformat, " %-9s %s");
        memset((char *)&global->datetime, 0, sizeof(global->datetime));
        memcpy((char *)&global->datetime,(char *)&ua->ap_Info.fib_Date,
               sizeof(struct DateStamp));
        global->datetime.dat_Format = FORMAT_DOS;
        global->datetime.dat_Flags = DTF_SUBST;
        global->datetime.dat_StrDay = global->dow;
        global->datetime.dat_StrDate = global->date;
        global->datetime.dat_StrTime = global->time;
        DateToStr(&global->datetime);
        if (global->opts[OPT_QUICK] != NULL) {
          global->listfields[2] = (long)global->date;
          global->listfields[3] = (long)global->time;
        } else {
          global->listfields[4] = (long)global->date;
          global->listfields[5] = (long)global->time;
        }
d516 3
a518 3
        if (global->opts[OPT_FILES] == NULL) {
          global->dircount++;
        }
d520 3
a522 3
        if (global->opts[OPT_DIRS] == NULL) {
          global->filecount++;
        }
d529 1
a529 1
      /* have collected.                                                     */
d532 1
a532 1
        VPrintf(pformat, global->listfields);
d535 19
a553 19
        /*-------------------------------------------------------------------*/
        /* If they DID give an LFORMAT option, try to parse it the same as   */
        /* the BCPL version of list does it.                                 */
        /*-------------------------------------------------------------------*/
        AddPart(namebuf, "", ENVMAX);
        for (scount=0,i=0;i<strlen((char *)global->opts[OPT_LFORMAT]);i++) {
          if ((((char *)global->opts[OPT_LFORMAT])[i] == '%') &&
              (((char *)global->opts[OPT_LFORMAT])[i+1] == 's')) {
            scount++;
          }
        }
        if (!(scount & 1)) {
          global->listfields[1] = global->listfields[0];
          global->listfields[0] = (long)&namebuf;
        }
        global->listfields[2] = global->listfields[0];
        global->listfields[3] = global->listfields[1];
        VPrintf((char *)global->opts[OPT_LFORMAT], global->listfields);
        PutStr("\n");
@


1.0.1.1
log
@fixes lformat problems; should act like 1.3 lformat now
@
text
@d11 2
a12 2
/* | .  | || the authors:                             BBS: (919) 382-8265    */
/* | o  | ||   Dave Baker      Alan Beale         Jim Cooper                 */
d18 2
a19 2
/**     (C) Copyright 1989 Commodore-Amiga, Inc.
 **         All Rights Reserved
d29 1
a29 1
/* 13DEC89  Jim Cooper    Time for some serious work; deadline TODAY!        */
a30 4
/* 30DEC89  Jim Cooper    Bug Fixes (NULL on 'TO' option, Header and Footer  */
/*                        suppression on 'LFORMAT' option, etc.)             */
/* 19FEB90  Jim Cooper    You mean nobody noticed that I wasn't printing     */
/*                        FileNotes?  Show how often it is used.             */
d52 1
a52 1
#define MSG_BLOCK      "%ld block%sused\n"
d81 1
a81 1
/* Define the signals we wish the pattern matcher to stop on.                */
a97 1
  long notfirst;
d101 1
a101 1
int list_dir(struct Global *, char *, struct AnchorPath *,
d152 1
a152 1
      if ((global.opts[OPT_DATES] != NULL) &&
d259 2
a260 1
            /* If we are NOT using the LFORMAT option...                     */
d262 4
a265 28
            if (global.opts[OPT_LFORMAT] == NULL) {

              /*-------------------------------------------------------------*/
              /* Print statistics for this set, then loop back and see if we */
              /* have another set to do.                                     */
              /*-------------------------------------------------------------*/
              if ((global.opts[OPT_DIRS] == NULL) &&
                  (global.filecount != NULL)) {
                global.listfields[0] = global.filecount;
                if (global.filecount > 1L) {
                  global.listfields[1] = (long)MSG_MANY;
                } else {
                  global.listfields[1] = (long)MSG_ONE;
                }
                VPrintf(MSG_FILE, global.listfields);
              }
              if ((global.opts[OPT_FILES] == NULL) &&
                  (global.dircount != NULL)) {
                global.listfields[0] = global.dircount;
                if (global.dircount > 1L) {
                  global.listfields[1] = (long)MSG_MANY_DIRS;
                } else {
                  global.listfields[1] = (long)MSG_ONE_DIR;
                }
                VPrintf(MSG_DIR, global.listfields);
              }
              global.listfields[0] = global.numblocks;
              if (global.numblocks > 1L) {
d270 1
a270 1
              VPrintf(MSG_BLOCK, global.listfields);
d272 17
d379 1
a379 2
    /* Print a header if we aren't specifially told not to, and we are NOT   */
    /* using the LFORMAT option.                                             */
d381 1
a381 3
    if ((dirname[0] != NULL) &&
        (global->opts[OPT_NOHEAD] == NULL) &&
        (global->opts[OPT_LFORMAT] == NULL)) {
a392 4
      if (global->notfirst) {
        PutStr("\n");
      }
      global->notfirst = 1;
a396 14
    /* If they DID give an LFORMAT option, try to parse it the same way the  */
    /* BCPL version of list does.                                            */
    /*-----------------------------------------------------------------------*/
    if (global->opts[OPT_LFORMAT] != NULL) {
      AddPart(namebuf, "", ENVMAX);
      for (scount=0,i=0;i<strlen((char *)global->opts[OPT_LFORMAT]);i++) {
        if ((((char *)global->opts[OPT_LFORMAT])[i] == '%') &&
            ((((char *)global->opts[OPT_LFORMAT])[i+1] & 0x5F) == 'S')) {
          scount++;
        }
      }
    }

    /*-----------------------------------------------------------------------*/
a414 1

d427 1
a427 1
      /* Also, we have to be sure to count ONE extra block used by the       */
d443 1
a443 1
        global->listfields[1] = (long)"";
d468 1
a468 1
          if ((ua->ap_Info.fib_Protection & (1 << (7-i))) ==
a521 4
        if (ua->ap_Info.fib_Comment[0] != NULL) {
          global->listfields[0] = (long)&ua->ap_Info.fib_Comment;
          VPrintf(": %s\n", global->listfields);
        }
d525 2
a526 3
        /* If they DID give an LFORMAT option, print the pieces in the order */
        /* the user specified, according to the same rules the BCPL List     */
        /* used.                                                             */
d528 6
a533 3
        global->listfields[1] = global->listfields[0];
        if (scount > 1) {
            global->listfields[0] = (long)&namebuf;
d535 5
a539 1
        global->listfields[2] = global->listfields[(scount == 3) ? 1 : 0];
@
