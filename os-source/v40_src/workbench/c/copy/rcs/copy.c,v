head     36.57;
branch   ;
access   ;
symbols  DistilleryFinal:1.14;
locks    ; strict;
comment  @*   @;


36.57
date     92.12.03.10.38.14;  author vertex;  state Exp;
branches ;
next     36.56;

36.56
date     92.05.20.17.54.27;  author vertex;  state Exp;
branches ;
next     36.55;

36.55
date     91.06.06.19.54.56;  author vertex;  state Exp;
branches ;
next     36.54;

36.54
date     91.06.06.11.35.14;  author vertex;  state Exp;
branches ;
next     36.53;

36.53
date     91.06.03.17.46.18;  author vertex;  state Exp;
branches ;
next     36.52;

36.52
date     91.05.30.09.41.56;  author vertex;  state Exp;
branches ;
next     36.51;

36.51
date     91.05.21.16.57.04;  author vertex;  state Exp;
branches ;
next     36.50;

36.50
date     91.05.16.16.09.38;  author vertex;  state Exp;
branches ;
next     36.49;

36.49
date     91.05.02.13.22.09;  author eric;  state Exp;
branches ;
next     36.48;

36.48
date     91.05.01.15.04.35;  author eric;  state Exp;
branches ;
next     36.47;

36.47
date     91.04.26.00.55.01;  author Jay;  state Exp;
branches ;
next     36.46;

36.46
date     91.04.19.16.53.44;  author eric;  state Exp;
branches ;
next     36.45;

36.45
date     91.04.18.10.03.00;  author eric;  state Exp;
branches ;
next     36.44;

36.44
date     91.04.18.09.45.43;  author eric;  state Exp;
branches ;
next     36.43;

36.43
date     91.04.15.14.14.47;  author eric;  state Exp;
branches ;
next     36.42;

36.42
date     91.02.27.10.28.23;  author eric;  state Exp;
branches ;
next     36.41;

36.41
date     91.02.27.10.10.16;  author eric;  state Exp;
branches ;
next     36.40;

36.40
date     90.12.21.22.26.48;  author Jay;  state Exp;
branches ;
next     36.39;

36.39
date     90.10.26.01.36.49;  author Jay;  state Exp;
branches ;
next     36.38;

36.38
date     90.10.25.11.33.15;  author eric;  state Exp;
branches ;
next     36.37;

36.37
date     90.10.22.20.44.14;  author Jay;  state Exp;
branches ;
next     36.36;

36.36
date     90.10.12.00.22.10;  author Jay;  state Exp;
branches ;
next     36.35;

36.35
date     90.10.03.01.31.12;  author Jay;  state Exp;
branches ;
next     36.34;

36.34
date     90.09.26.02.21.07;  author Jay;  state Exp;
branches ;
next     36.33;

36.33
date     90.09.25.22.51.50;  author Jay;  state Exp;
branches ;
next     36.31;

36.31
date     90.09.06.13.38.13;  author eric;  state Exp;
branches ;
next     36.30;

36.30
date     90.09.05.12.12.55;  author eric;  state Exp;
branches ;
next     36.29;

36.29
date     90.08.28.21.41.33;  author Jay;  state Exp;
branches ;
next     36.28;

36.28
date     90.08.28.00.21.08;  author Jay;  state Exp;
branches ;
next     36.27;

36.27
date     90.08.28.00.03.53;  author Jay;  state Exp;
branches ;
next     36.26;

36.26
date     90.08.26.23.29.51;  author Jay;  state Exp;
branches ;
next     36.25;

36.25
date     90.08.26.22.48.08;  author Jay;  state Exp;
branches ;
next     36.24;

36.24
date     90.08.26.13.22.20;  author Jay;  state Exp;
branches ;
next     36.23;

36.23
date     90.08.21.20.47.50;  author C=;  state Exp;
branches ;
next     36.16;

36.16
date     90.05.20.19.25.52;  author Jay;  state Exp;
branches ;
next     36.15;

36.15
date     90.05.20.16.48.46;  author Jay;  state Exp;
branches ;
next     1.14;

1.14
date     90.05.18.01.26.37;  author Jay;  state Exp;
branches ;
next     1.13;

1.13
date     90.05.17.23.56.59;  author Jay;  state Exp;
branches ;
next     1.12;

1.12
date     90.04.20.22.55.17;  author andy;  state Exp;
branches ;
next     1.11;

1.11
date     90.04.20.07.25.01;  author andy;  state Exp;
branches ;
next     1.10;

1.10
date     90.04.18.22.49.15;  author Unknown;  state Exp;
branches ;
next     1.9;

1.9
date     90.04.10.18.14.48;  author andy;  state Exp;
branches ;
next     1.8;

1.8
date     90.04.09.17.52.18;  author andy;  state Exp;
branches ;
next     1.7;

1.7
date     90.04.09.14.11.33;  author andy;  state Exp;
branches ;
next     1.6;

1.6
date     90.04.06.15.39.58;  author andy;  state Exp;
branches ;
next     1.5;

1.5
date     90.04.06.14.59.31;  author andy;  state Exp;
branches ;
next     1.4;

1.4
date     90.03.19.21.55.16;  author andy;  state Exp;
branches ;
next     1.3;

1.3
date     90.03.12.20.05.09;  author andy;  state Exp;
branches ;
next     1.2;

1.2
date     90.03.03.16.25.38;  author andy;  state Exp;
branches ;
next     1.1;

1.1
date     90.02.03.01.41.44;  author andy;  state Exp;
branches ;
next     1.0;

1.0
date     90.01.22.19.28.12;  author andy;  state Exp;
branches ;
next     ;


desc
@Copy command for cdos
@


36.57
log
@Now correctly handles failure of SetProtection(), SetComment(), and
SetFileDate(). Because SetComment() fails on NFS and on CrossDOS,
SetFileDate() never was done on files, making the CLONE option not
fully work. All three functions are considered failures only if
IoErr() reports something different than ERROR_ACTION_NOT_KNOWN.

In case of error after a call to DupLock(), an error code was being
set always to ERROR_NO_FREE_STORE instead of using the result of
IoErr()

The default size for the buffers used was always equivalent to (BUF=0)
which caused the buffers to be the size of the files being copied.
This was contrary to the docs, and caused problems when copying large
files through Envoy. The default size is now BUF=128 which gives a 64K
buffer.                                                                  
@
text
@/* Notes:                                                                    *
 *                                                                           *
 * This program handles the following cases:                                 *
 *    1) Copy with wildcards                                                 *
 *    2) Copy file -> file                                                   *
 *    3) Copy file -> directory                                              *
 *    4) Copy directory -> directory                                         *
 *                                                                           *
 * In an attempt to make the program as small as possible, I have used       *
 * gotos and other nasty tricks.  Sorry about that, but hopefully there      *
 * are enough comments to enable the code to remain clear                    *
 *                                                                           *
 *---------------------------------------------------------------------------*/

#include "internal/commands.h"
#include "copy_rev.h"

#ifdef MWDEBUG
#include "memlib/memwatch.h"
#endif

#define TEMPLATE  "FROM/M,TO/A,ALL/S,QUIET/S,BUF=BUFFER/K/N,CLONE/S,DATES/S,NOPRO/S,COM/S,NOREQ/S" CMDREV
#define OPT_FROM     0
#define OPT_TO       1
#define OPT_ALL      2
#define OPT_QUIET    3
#define OPT_BUFS     4
#define OPT_CLONE    5
#define OPT_DATES    6
#define OPT_NOPRO    7
#define OPT_COM      8
#define OPT_NOREQ    9
#define OPT_COUNT    10

#define PARSE_KLUDGE
#define SEE_COLON_KLUDGE


/* need DOS V37 cause we now use ChangeMode() */
#define COPYDOSVER 37

/***********************************************************************
 *                        Messages used by this program                */

#define  MSG_DEST_WRONG_DIR   "Destination must be a directory.\n"
#define  MSG_DIR              "%s (Dir)"
#define  MSG_DIR_CREATE       "   [created]\n"
#define  MSG_COPIED           "copied.\n"
#define  MSG_TABIN            "        "	/* not strictly needed, but
						                       perhaps useful          */
#define  MSG_DELETED          "Destination file \"%s\" removed.\n"
#define  MSG_NOOPEN           "Can't open %s for "
#define  MSG_INOUT            "%sput - "
#define  MSG_IN               "in"
#define  MSG_OUT              "out"
#define  MSG_IOERROR          "Error in %sing - "
#define  MSG_READ             "read"
#define  MSG_WRITE            "writ"
#define  MSG_RECURS           "\nInfinite loop in \"%s\".\n"
#define  MSG_ERROR            "%s: "
#define  MSG_ERROR1           "%s - "
#define  MSG_TOWILD           "Wildcard destination invalid.\n"

/***********************************************************************/

#define  TABIN                8
#define  BUF_SAFE             100	/* To allow for extra memory
					                 * allocated by AllocVec      */
void Tab(int tabstops, struct DosLibrary * DOSBase);
ULONG IsFatal(LONG ErrNo);
LONG MatchNext2(struct AnchorPath *anchor, BPTR lock, struct DosLibrary * DOSBase);

/***********************************************************************
 *                                                                     *
 *    Copy program mainline.                                           *
 *                                                                     *
 * This routine is fairly optomized.  Since most of the code is error  *
 * handling, I've used GOTOs to collect the common areas.  It should   *
 * be clear anyway, in most cases clearer than it was before I         *
 * commonized the code sequences.  Its definately much smaller, and    *
 * has the advantage of putting all common error code in one place so  *
 * only one place needs changing if it needs modification.             *
 *                                                                     *
 * NOTE: This MUST be the first routine in the module                  *
 *                                                                     *
 ***********************************************************************/

#ifdef DEBUG1
int cmd_copy(void);
int main(void)
{
   return cmd_copy();
}

#endif

int cmd_copy(void)
{
   struct Library *SysBase;
   struct DosLibrary *DOSBase;
   int multisrc = FALSE, tabin = 0, isfile, created = 0;
   int cont, firsttime, inout;
   struct RDargs *rdargs = NULL;
   char *msgbuf1 = NULL, *msgbuf = NULL, *buf = NULL, *curarg=NULL, **argptr;
   long rc = RETURN_OK, res2 = 0, opts[OPT_COUNT];
   long bufsize, t=0, bs;
   BPTR outlock = NULL, temp, infh = NULL, outfh = NULL, temp1, temp2;
   BPTR destlock = NULL;
   struct FileInfoBlock *fib = NULL;
   APTR windptr;
   struct AnchorPath *ap = NULL;
   char	*fromless[] = {"",NULL};
#ifdef SEE_COLON_KLUDGE
   char *path, c;
#endif
   BPTR *prelocks = NULL;
   STRPTR *names = NULL;
   BPTR *arglock;
   BPTR oldCD;
   UWORD i,j;
   char oldCh;
   UWORD argcnt;
   BOOL argmatched;
   STRPTR argname;
   UWORD numsources = 0;
   BOOL ok;

/* Macro to get longword-aligned stack space for a structure	*/
/* Uses ANSI token catenation to form a name for the char array */
/* based on the variable name, then creates an appropriately	*/
/* typed pointer to point to the first longword boundary in the */
/* char array allocated.					*/
#define D_S(name, type) char a_##name[sizeof(type)+3]; \
			type *name = (type *)((LONG)(a_##name+3) & ~3);

	SysBase = (struct Library *)(*((struct Library **) 4));
	windptr = (APTR)-1;

   if ((DOSBase = (struct DosLibrary *) OpenLibrary(DOSNAME, COPYDOSVER))) {

/***********************************************************************
 *                                                                     *
 * Initialization section.  Allocate memory, initialize variables,     *
 *    etc.                                                             *
 *                                                                     *
 ***********************************************************************/

      if (CheckSignal(SIGBREAKF_CTRL_C)) {
	 PrintFault(ERROR_BREAK, NULL);
	 goto Done;
      }

/***********************************************************************
 *                                                                     *
 *    A common error routine lives near the bottom of this routine     *
 *    it is called ErrExit, and is where most fatal error cases end    *
 *    up.  It is gotten to with a goto rather than being a subroutine  *
 *                                                                     *
 ***********************************************************************/

      if ((msgbuf = AllocVec(MSGBUFSIZE, NULL)) == NULL ||
          (msgbuf1 = AllocVec(MSGBUFSIZE, NULL)) == NULL ||

	  (ap = AllocVec(sizeof(struct AnchorPath) + 256, MEMF_CLEAR)) == NULL ||

	  (fib = AllocVec(sizeof(struct FileInfoBlock), MEMF_PUBLIC)) == NULL) {

	 res2 = ERROR_NO_FREE_STORE;
	 PrintFault(ERROR_NO_FREE_STORE, NULL);

	 goto Done;
      }
      memset((char *) opts, 0, sizeof(opts));
      rdargs = ReadArgs(TEMPLATE, opts, NULL);

      if (rdargs == NULL) {
	 res2 = IoErr();
	 rc = RETURN_FAIL;
    t = 0;
	 goto ErrExit2;		/* <=== Bail out to common error routine       */
      } else {

/***********************************************************************
 *                                                                     *
 * We've got a good set of parameters.  Now we need to figure out the  *
 *    environment we're operating in.  The original BCPL copy routine  *
 *    had several special cases, each of which had a different output  *
 *    to the user.  Rather than duplicating the output, and having     *
 *    several special routines for each flavor of copy, this version   *
 *    is written to handle them all with one routine.                  *
 *                                                                     *
 * Here's a list of the possible variations to the input.  Originally  *
 *    multiargs were not supported, I will talk more about that later. *
 *                                                                     *
 *    1) One file to another file   - No output                        *
 *    2) One file to a directory    - No output                        *
 *          The difference of the two above are distinguished by the   *
 *          existance of the destination.  Its a file copy if the      *
 *          destination is a file, or does not exist, it is a copy     *
 *          to directory if it is a directory.                         *
 *    3) Directory to directory     - Prints each file                 *
 *    4) Wildcard to directory      - Prints each file                 *
 *    5) All parameter              - Prints each file                 *
 *                                                                     *
 * Delete printed nothing if multiple single files were given.  I      *
 * never liked that, I think whenever there are multiple things to do  *
 * some feedback needs to be given to the user.  This version of Copy  *
 * reflects that.  It always prints the file being worked on if there  *
 * is more than one file requested.                                    *
 *                                                                     *
 ***********************************************************************/

/***********************************************************************
 * If the user doesn't want requesters put on the screen, turn off     *
 * requesters for this process                                         *
 ***********************************************************************/

	 if (opts[OPT_NOREQ]) {
	    windptr = THISPROC->pr_WindowPtr;
	    THISPROC->pr_WindowPtr = (APTR) - 1;
	 }

/***********************************************************************\
 * I don't agree that this should be put in, however some have asked   *
 * for wildcards to be disallowed in the destination.                  *
\***********************************************************************/

#ifdef   PARSE_KLUDGE
   if((buf=AllocVec(500,0))==NULL || ParsePattern((char *)opts[OPT_TO], buf, 500))
#else
   if(ParsePattern((char *)opts[OPT_TO], NULL, 0))
#endif
   {
      PutStr(MSG_TOWILD);
		res2 = 0;
		rc = RETURN_ERROR;
		goto Done;
   }
#ifdef   PARSE_KLUDGE
   FreeVec(buf);
   buf = NULL;
#endif

/***********************************************************************\
 * Copy is documented as not requiring a FROM, I never realized this   *
 * but sure enough, even in the dos reference manual for 2.0 it says   *
 * this.  The behaviour is just like specifing a FROM "", so... we'll  *
 * fake it by providing the same structure that FROM "" would have     *
 * given.                                                              *
\***********************************************************************/
	if(opts[OPT_FROM] == NULL)
	{
		opts[OPT_FROM] = (long)&fromless;
	}

/***********************************************************************
 * We always may step into directories, so set the flag                *
 ***********************************************************************/

	 ap->ap_Flags = APF_DOWILD;
	 ap->ap_BreakBits = SIGBREAKF_CTRL_C;
	 ap->ap_Strlen = 256;

	 argptr = (char **) opts[OPT_FROM];
         numsources = 0;
         while (*argptr++)
             numsources++;

         if (!(prelocks = AllocVec((ULONG)numsources*4,MEMF_CLEAR|MEMF_PUBLIC)))
         {
    	     res2 = ERROR_NO_FREE_STORE;
	     PrintFault(ERROR_NO_FREE_STORE, NULL);
	     goto Done;
         }

         if (!(names = AllocVec((ULONG)numsources*4,MEMF_CLEAR|MEMF_PUBLIC)))
         {
    	     res2 = ERROR_NO_FREE_STORE;
	     PrintFault(ERROR_NO_FREE_STORE, NULL);
	     goto Done;
         }

	 argptr = (char **) opts[OPT_FROM];
	 argcnt = 0;
         while (argptr[argcnt])
         {
             argname = argptr[argcnt];
             i = 0;
             while ((argname[i] != ':') && (argname[i]))
                 i++;

             if (argname[i] == ':')
             {
                 i++;
		 oldCh = argname[i];
                 argname[i] = 0;

                 argmatched = FALSE;
                 j = 0;
                 while (j <= argcnt)
                 {
                     if ((names[j]) && (stricmp(argname,names[j]) == 0))
                     {
                         argmatched = TRUE;
                         break;
                     }
                     j++;
                 }

                 if (argmatched)
                 {
                     if (!(prelocks[argcnt] = DupLock(prelocks[j])))
		     {
                         res2 = IoErr();
	                 PrintFault(res2, NULL);
	                 goto Done;
	             }

                     argname[i] = oldCh;
                     if (oldCh)
                         strcpy(argname,&argname[i]);
                     else
                         argname[0] = 0;
                 }
                 else
                 {
                     if (!(prelocks[argcnt] = Lock(argname,ACCESS_READ)))
                     {
                         argname[i] = oldCh;
                         res2 = IoErr();
                         if (res2 != ERROR_ACTION_NOT_KNOWN)
                         {
                             t = (LONG)argname;
                             VPrintf(MSG_NOOPEN,&t);

                             t = (long)&MSG_IN;
                             VPrintf(MSG_INOUT, &t);
                             PrintFault(res2, NULL);
                             t = NULL;
                             goto Done;
                         }
                     }
                     else
                     {
                         if (!(names[argcnt] = AllocVec(strlen(argname)+1,MEMF_CLEAR|MEMF_PUBLIC)))
                         {
                             res2 = ERROR_NO_FREE_STORE;
                             PrintFault(ERROR_NO_FREE_STORE, NULL);
                             goto Done;
                         }
                         strcpy(names[argcnt],argname);

                         argname[i] = oldCh;
                         if (oldCh)
                             strcpy(argname,&argname[i]);
                         else
                             argname[0] = 0;
                     }
                 }
             }
             argcnt++;
         }

	 argptr = (char **) opts[OPT_FROM];
         arglock = &prelocks[0];

         t = 0;

         if (*arglock)
             oldCD = CurrentDir(*arglock);

	 if (MatchFirst(*argptr, ap)) {
	    if (*arglock)
                CurrentDir(oldCD);
	    res2 = IoErr();
		if( res2 == ERROR_OBJECT_NOT_FOUND ){

			t = opts[OPT_FROM];
			VPrintf(MSG_NOOPEN, (void *)opts[OPT_FROM]);

			t = (long)&MSG_IN;
			VPrintf(MSG_INOUT, &t);
			PrintFault(res2, NULL);
			t = NULL;
			rc = RETURN_FAIL;
#ifdef SEE_COLON_KLUDGE

/*
 * This code is to keep install scripts from breaking.  If
 * an attempt is made to copy a specific file from C: which is
 * not there, return warn rather than error.
 * (C= put a bunch of things resident into the shell
 * and removed it from C: in 2.0, not a good idea IMHO)
 */
                        path = PathPart(*(char **)opts[OPT_FROM]);
                        c = *path;
                        *path = '\0';
                        if (*arglock)
                           oldCD = CurrentDir(*arglock);
                        temp = Lock(*(char **)opts[OPT_FROM], ACCESS_READ);
                        temp1 = Lock("C:", ACCESS_READ);
                        if (*arglock)
                            CurrentDir(oldCD);

                        rc = (SameLock( temp, temp1 ) == LOCK_SAME )?
                                                        RETURN_WARN:RETURN_FAIL;
                        *path = c;
                        UnLock(temp);
                        UnLock(temp1);
                        temp = NULL;
                        temp1 = NULL;
#endif
			goto Done;
		}
	    goto ErrExit;
	 }

	 isfile = IsFileSystem((char *) opts[OPT_TO]);
	 if (!isfile && IoErr() && IoErr() != ERROR_ACTION_NOT_KNOWN) {
	    res2 = IoErr();

            if (*arglock)
  	        CurrentDir(oldCD);

	    goto ErrExit;
	 }

         if (*arglock)
  	     CurrentDir(oldCD);

/***********************************************************************
 *                                                                     *
 * If the first parameter is wild, or is a directory, or there are     *
 * more than one input files, then this program goes into 'multisrc'   *
 * mode.  This means the output must be a directory, and files will    *
 * be printed as output.                                               *
 *                                                                     *
 ***********************************************************************/

	 if (((ap->ap_Flags & APF_ITSWILD) != 0) ||
	     (ap->ap_Info.fib_DirEntryType > 0) ||
	     (argptr[1] != NULL)) {

	    multisrc = TRUE;

/***********************************************************************
 *                                                                     *
 * If the input parameter is not wild, and it is a directory, then     *
 * step into it.  Later code is not aware that we've steped into the   *
 * directory, so we have to be careful about not taking what           *
 * MatchFirst/Next as gosphal.                                         *
 *                                                                     *
 ***********************************************************************/

	    if ((ap->ap_Flags & APF_ITSWILD) == 0 &&
		(ap->ap_Info.fib_DirEntryType > 0)) {
	       ap->ap_Flags |= APF_DODIR;
	       if(MatchNext2(ap,*arglock,DOSBase)) {
		   res2 = IoErr();
	           if(res2 != ERROR_NO_MORE_ENTRIES)goto ErrExit; /* new test */
	       }
	    }
	 }
    t = opts[OPT_TO];
	 if (multisrc && isfile) {

/***********************************************************************
 *                                                                     *
 * Output MUST be a directory.  If it doesn't exist, create it.        *
 * If its not a directory, abort program.                              *
 *                                                                     *
 ***********************************************************************/
	    if ((outlock = Lock((char *) opts[OPT_TO], SHARED_LOCK))) {

	       if (Examine(outlock, fib)) {
		  if (fib->fib_DirEntryType < 0) {
		     PutStr(MSG_DEST_WRONG_DIR);
		     res2 = 0;
		     rc = RETURN_ERROR;
		     goto Done;
		  }
	       } else {
		  res2 = IoErr();
		  goto ErrExit;
	       }
	       created = FALSE;
	    } else {
	       if ((outlock = CreateDir((char *) opts[OPT_TO])) == NULL) {
		  res2 = IoErr();
		  goto ErrExit;
	       }
	       created = TRUE;
	       if (!opts[OPT_QUIET]) {
		  VPrintf("   %s" MSG_DIR_CREATE, &opts[OPT_TO]);
	       }
	       UnLock(outlock);
	       if ((outlock = Lock((char *) opts[OPT_TO], SHARED_LOCK)) == NULL)
	       {
		  res2 = IoErr();
		  goto ErrExit;
	       }
	    }
	    if (!(destlock = DupLock(outlock)))
	    {
                res2 = IoErr();
		goto ErrExit;
	    }
	 } else {

/***********************************************************************
 *                                                                     *
 * Not multiple source files, doesn't have to be a directory.          *
 * If its not a directory, unlock outlock.  Outlock is a lock on the   *
 * parent directory of the output file, not the output file itself.    *
 *                                                                     *
 ***********************************************************************/

	    if ((outlock = Lock((char *) opts[OPT_TO], ACCESS_READ)) == NULL) {
	       if (((res2 = IoErr()) != ERROR_OBJECT_NOT_FOUND) &&
		   (res2 != ERROR_ACTION_NOT_KNOWN))
		  goto ErrExit;
	    }
	    if (outlock) {
	       if (Examine(outlock, fib)) {
		  if (fib->fib_DirEntryType < 0) {
		     UnLock(outlock);
		     outlock = NULL;
		  }
	       } else {
		  res2 = IoErr();
		  goto ErrExit;
	       }
	    }
	 }

/***********************************************************************
 *                                                                     *
 * At this point, the following things are true:                       *
 *                                                                     *
 *          1) if dest is a dir we got a lock on it                    *
 *          2) if dest isn't a dir we don't                            *
 *          3) we know if the input is wild, or multiargs              *
 *          4) we should have a anchor on the first input file         *
 *                                                                     *
 *       we still need to:                                             *
 *                                                                     *
 *          1) allocate buffers                                        *
 *          2) turn off requesters if asked                            *
 *                                                                     *
 ***********************************************************************/

         if (*arglock)
  	     oldCD = CurrentDir(*arglock);

	 if (opts[OPT_BUFS])
	 {
	    bufsize = *(long *) opts[OPT_BUFS];

	    if (bufsize < 0 || !IsFileSystem(argptr[0]))
	       bufsize = 128;

/***********************************************************************
 * Doesn't make much sense to ask for negative buffers.  If the user   *
 * did, just quietly set the size to the default. 0 buffers is a       *
 * special case.  I'll go more into that when the code comes up        *
 ***********************************************************************/

	 }
	 else		/* No BUF argument, so.. */
	 {
             bufsize = 128;
	 }
	 bufsize *= 0x200;

         if (*arglock)
  	     CurrentDir(oldCD);


/***********************************************************************
 * If positive bufsize, allocate the buffer.                           *
 ***********************************************************************/

	 if (bufsize)
         {
             while (TRUE)
             {
                 if (buf = AllocVec(bufsize, 0))
                     break;

                 if (bufsize <= 1024)
                 {
                     res2 = ERROR_NO_FREE_STORE;
                     t = 0;
                     goto ErrExit;
                 }
                 bufsize -= 1024;
             }
	 }

/***********************************************************************
 *                                                                     *
 *    And now the moment we've all been waiting for.  The main loop of *
 *    this program.  The environment is set up, all the memory is      *
 *    allocated, its dark out, and we've got our sun glasses on.       *
 *    Let's rock.                                                      *
 *                                                                     *
 ***********************************************************************/

	 firsttime = TRUE;

/***********************************************************************
 * Step over multiargs                                                 *
 ***********************************************************************/

	 while (curarg = *argptr++) {
	    if (firsttime)
	       firsttime = FALSE;
	    else {

/***********************************************************************
 * Unless its the first time through the loop, do a little             *
 * initialization.  Make sure the file exists.  If the file is a dir   *
 * and is not wild, step into it.                                      *
 ***********************************************************************/

	       UnLock(outlock);
               if (!(outlock = DupLock(destlock)))
               {
		  res2 = IoErr();
		  goto ErrExit;
               }

	       arglock++;
               if (*arglock)
                   oldCD = CurrentDir(*arglock);
	       if (MatchFirst(curarg, ap)) {
	          if (*arglock)
	              CurrentDir(oldCD);
		  res2 = IoErr();
        	  t = (long)curarg;
			if( res2 == ERROR_OBJECT_NOT_FOUND ){

				t = opts[OPT_FROM];
				VPrintf(MSG_NOOPEN, (void *)&curarg);

				t = (long)&MSG_IN;
				VPrintf(MSG_INOUT, &t);
				PrintFault(res2, NULL);
				t = NULL;
				rc = RETURN_WARN;
				continue;
			}
		  goto ErrExit;
	       }

	       if (*arglock)
	           CurrentDir(oldCD);

	       if ((ap->ap_Flags & APF_ITSWILD) == 0 &&
		   (ap->ap_Info.fib_DirEntryType > 0)) {
		  ap->ap_Flags |= APF_DODIR;
		  if(MatchNext2(ap,*arglock,DOSBase)) {
		        res2 = IoErr(); /* new test */
	               if(res2 != ERROR_NO_MORE_ENTRIES)goto ErrExit;
		  }
	       }
	    }

/***********************************************************************
 *                                                                     *
 * Main copy loop, each argument gets copied here, one pass is made    *
 * through the loop for simple file to file copies, several times      *
 * through for wildcards or directories.                               *
 *                                                                     *
 ***********************************************************************/

	    do {

/***********************************************************************
 *                                                                     *
 * Using MatchFirst/Next stepping into directories list the directory  *
 * twice.  Once going in, and another time going out.  This is handy   *
 * because some programs, like delete are concerned with exiting the   *
 * the directory, others like this one want to know when a directory   *
 * is entered.                                                         *
 *                                                                     *
 * The following code takes care of walking back up the directory tree *
 * its at the beginning of the do loop rather than the end because we  *
 * need to ignore the second time the entry is hit, other than         *
 * popping out.                                                        *
 *                                                                     *
 ***********************************************************************/

	       while (ap->ap_Flags & APF_DIDDIR) {
		  tabin--;
			if(isfile){
			  temp = outlock;
			  outlock = ParentDir(outlock);
			  UnLock(temp);

			  if( outlock && (ap->ap_Info.fib_DirEntryType > 0) &&
			     (opts[OPT_CLONE] || opts[OPT_DATES])			){
				temp = CurrentDir(outlock);
				SetFileDate(ap->ap_Info.fib_FileName, &ap->ap_Info.fib_Date);
				CurrentDir(temp);
			  }
			}
		  /* tell Anchor to step out */
		  ap->ap_Flags &= ~APF_DIDDIR;

/***********************************************************************
 *                                                                     *
 * tabin in the following if statement is somewhat subtle.  Recall if  *
 * we're copying a directory, we do a DODIR, but don't create the      *
 * directory and step in.  MatchNext under that circumstance would     *
 * pass to this routine the original directory at the very end of the  *
 * copy.  We use the tabin variable to indicate this has occured, and  *
 * exit the loop even though MatchNext doesn't tell us to do this      *
 *                                                                     *
 ***********************************************************************/

		  if ((cont = MatchNext2(ap,*arglock,DOSBase)) || (tabin < 0)) {
		     goto ExitLoop;	/* Pardon the goto, trying for small */
		  }
	       }

	       if (CheckSignal(SIGBREAKF_CTRL_C)) {
		  PrintFault(ERROR_BREAK, NULL);
		  goto Done;
	       }
/***********************************************************************
 *                                                                     *
 * The following loop is the trickiest code in the program.  Its       *
 * purpose is to keep evaluating until we get to a file.  If the all   *
 * option isn't set, it will just go to the main copy loop.  If it is  *
 * this routine will keep creating directories and walking the dir     *
 * structure until a file is found.  In the event an empty directory   *
 * is found, it will drop back a directory, and continue the copy.     *
 *                                                                     *
 ***********************************************************************/

	       while (ap->ap_Info.fib_DirEntryType > 0) {

		  if (!opts[OPT_QUIET]) {
		     Tab(tabin + 1, DOSBase);
		     t = (LONG) ap->ap_Info.fib_FileName;
		     VPrintf(MSG_DIR, &t);
		  }
		  if (opts[OPT_ALL]) {
/***********************************************************************
 *                                                                     *
 * The previous line of code has already confused two people, myself,  *
 * and the person who do the walkthrough of the program.  We are       *
 * guaranteed to be multisource here because multisource is set if     *
 * we're copying a directory, or if there's a wildcard.  If we find    *
 * a directory under those circumstances, if ALL is set, we create     *
 * and lock the directory, if all is not set, we just print that we've *
 * hit the directory, and go to the next file.                         *
 *                                                                     *
 ***********************************************************************/

		     if (CheckSignal(SIGBREAKF_CTRL_C)) {
			PrintFault(ERROR_BREAK, NULL);
			goto Done;
		     }

/***********************************************************************\
 *                                                                     *
 * If a directory is linked to a subdirectory of itself, infinite      *
 * recursion can occur.  I can actually see someone doing this for a   *
 * legitimate reason, if that person had really nasty deep directory   *
 * structures.  Anyway, a check goes here and if it would cause        *
 * this problem, it will be fixed caught.                              *
 *                                                                     *
\***********************************************************************/

			/* Get a lock on the input directory */
			temp = CurrentDir(ap->ap_Current->an_Lock);
			temp1 = Lock(ap->ap_Info.fib_FileName, SHARED_LOCK);
			CurrentDir(temp);

			temp2 = DupLock(ap->ap_Current->an_Lock);

			while (temp2 != NULL){
				if (SameLock(temp1, temp2) == LOCK_SAME) {
					t = (LONG) ap->ap_Info.fib_FileName;
					VPrintf(MSG_RECURS, &t);
					res2 = 0;
					UnLock(temp1);
					UnLock(temp2);
					goto ErrExit;
				}
				temp = ParentDir(temp2);
				UnLock(temp2);
				temp2 = temp;
			};

			if(isfile){

				if (created) {
					temp2 = ParentDir(outlock);
				} else {
					temp2 = DupLock(outlock);
				}

				/* Walk up the chain of parents looking for the
					current input directory.  If its on the list
					infinite recursion will occure.              */

				while (temp2 != NULL){
					if (SameLock(temp1, temp2) == LOCK_SAME) {
						t = (LONG) ap->ap_Info.fib_FileName;
						VPrintf(MSG_RECURS, &t);
						res2 = 0;
						UnLock(temp1);
						UnLock(temp2);
						goto ErrExit;
					}
					temp = ParentDir(temp2);
					UnLock(temp2);
					temp2 = temp;
				};

				temp = CurrentDir(outlock);
				if ((outlock = Lock(ap->ap_Info.fib_FileName, SHARED_LOCK)) == NULL)
				{
					if ((outlock = CreateDir(ap->ap_Info.fib_FileName)) == NULL)
					{
						res2 = IoErr();
						outlock = CurrentDir(temp);
						if (!opts[OPT_QUIET])
							PutStr("\n");
						strcpy( msgbuf1, ap->ap_Info.fib_FileName);
						t = (long)msgbuf1;

						goto ErrExit;
					} else if (!opts[OPT_QUIET]) PutStr(MSG_DIR_CREATE);

				} else 		if (!opts[OPT_QUIET]) PutStr("\n");

				tabin++;
				temp = CurrentDir(temp);
				UnLock(temp);		/* release parent lock */
			} else 			if (!opts[OPT_QUIET]) PutStr("\n");
			UnLock(temp1);

		  } else {

/***********************************************************************
 *                                                                     *
 * This means we've hit a directory without option all set.  It will   *
 * only happen the first time through the while loop.  Since we're     *
 * not copying directories at this point, skip this dir and go to      *
 * the next file. (branches to the main copy loop)                     *
 *                                                                     *
 ***********************************************************************/

		     if (!opts[OPT_QUIET])
			PutStr("\n");
		     goto Loop;
		  }

/***********************************************************************
 * Okay, we've found a directory, and know we want to copy it, so now  *
 * Let's step into the directory.                                      *
 ***********************************************************************/

		  ap->ap_Flags |= APF_DODIR;
		  if(MatchNext2(ap,*arglock,DOSBase)) {
		   cont = IoErr();   /* new test */
	           goto ExitLoop;
		  }
		  if (ap->ap_Flags & APF_DIDDIR) {

/***********************************************************************
 * This means there's an empty directory, we've already created it,    *
 * but oh, well.. What should occur at this point, is we go to the     *
 * file in the parent directory following this directory without       *
 * copying                                                             *
 ***********************************************************************/

		     tabin--;
			 if(isfile){
			     temp = outlock;
			     outlock = ParentDir(outlock);
			     UnLock(temp);
				 if( outlock && (ap->ap_Info.fib_DirEntryType > 0)	&&
			     	 (opts[OPT_CLONE] || opts[OPT_DATES])			)
				 {
					temp = CurrentDir(outlock);
					SetFileDate(ap->ap_Info.fib_FileName, &ap->ap_Info.fib_Date);
					CurrentDir(temp);
				 }
			 }
		     ap->ap_Flags &= ~APF_DIDDIR;	/* tell Anchor to step out */
		     goto Loop;
		  }
	       }

/***********************************************************************
 *                                                                     *
 * Okay, here's the condition we're currently in...  We're pointing    *
 * to something that must be a file with the anchor, if we're copying  *
 * a file, outlock is NULL, otherwise outlock is a lock on the parent  *
 * directory of the soon-to-be file.                                   *
 *                                                                     *
 * Its now time to open the files.  Output file first, then input file *
 * Currently, if the open doesn't work, the whole program aborts, by   *
 * changing the common failure code, it would be easy to just loop     *
 * instead.                                                            *
 *                                                                     *
 * Quite a few bytes of code are saved by having common error handling *
 * for all three of the open statements.                               *
 *                                                                     *
 ***********************************************************************/

	       inout = TRUE;

	       temp = CurrentDir(ap->ap_Current->an_Lock);
	       if (!(infh = Open(ap->ap_Info.fib_FileName, MODE_OLDFILE))) {
		  inout = FALSE;
	       }
	       CurrentDir(temp);
	       if (infh){
			  if (outlock) {
			     temp = CurrentDir(outlock);
			     outfh = Open(ap->ap_Info.fib_FileName, MODE_NEWFILE);
		    	     CurrentDir(temp);
			  } else {
			     outfh = Open((char *) opts[OPT_TO], MODE_NEWFILE);
			  }
			}

	       if (!outfh || !infh) {
			res2 = IoErr();
			t = (int) ap->ap_Info.fib_FileName;
		  if(!outfh)
		  {
			if(!multisrc)
			{
				t=(int)opts[OPT_TO];
			}
			Close(infh);
			infh = 0;
			}

		  VPrintf(MSG_NOOPEN, &t);

		  t = (int) ((inout) ? &MSG_OUT : &MSG_IN);
		  VPrintf(MSG_INOUT, &t);
		  PrintFault(res2, NULL);
		  rc = RETURN_WARN;
		  if (IsFatal(res2)) {
		     MatchEnd(ap);
		     goto Done;
		  } else {
		     res2 = NULL;
		     goto Loop;
		  }
	       }
/***********************************************************************
 *                                                                     *
 * Hokay, now we've got both files open the input file is examined     *
 * into fib, so we print the name and copy the file.                   *
 *                                                                     *
 ***********************************************************************/

	       if (multisrc && !opts[OPT_QUIET]) {
		  Tab(tabin, DOSBase);
		  t = (LONG) ap->ap_Info.fib_FileName;
		  VPrintf("   %s..", &t);
		  Flush(Output());
	       }
/***********************************************************************
 *                                                                     *
 * Here is the promised new feature.  If BUFSIZE = 0 memory is         *
 * allocated and deleted for each file.  The buffer ends up being      *
 * exactly the right size for the file.  This gives the fast fileing   *
 * system the exact size of the file, hopefully it will find a space   *
 * on the disk the right size and will put the file contigious on the  *
 * disk.  This of course is a big win when it comes to running the     *
 * program, it will load a program stored on contigious sectors with   *
 * one file request, thereby loading even big programs very fast.      *
 *                                                                     *
 * I stole this idea from an early copy program for the amiga called   *
 * xcopy.                                                              *
 *                                                                     *
 ***********************************************************************/

	       if (bufsize == 0) {
		  bs = ap->ap_Info.fib_Size;

		  if (bs == 0)
		      bs = 8;

                  while (TRUE)
                  {
		      if (buf = AllocVec(bs, 0))
		          break;

		      if (bs <= 1024)
		      {
			  res2 = ERROR_NO_FREE_STORE;
         		  t = 0;
			  goto ErrExit;
	              }
	              bs -= 1024;
		  }
    	       }
	      else bs = bufsize;

/***********************************************************************
 * Here's the Copy (finally) lotta work for such a short thing, eh???  *
 ***********************************************************************/
	       while ((t = Read(infh, buf, bs)) > 0) {

		  if (CheckSignal(SIGBREAKF_CTRL_C)) {
		     t = 1;
		     PrintFault(ERROR_BREAK, NULL);
		     SetIoErr(0);
		     break;
		  }
		  if (Write(outfh, buf, t) != t) {
		     t = 1;
		     break;
		  }
	       }
/***********************************************************************
 * Collect the error reason (if any)                                   *
 * T is non-zero if any error occured                                  *
 ***********************************************************************/
	       if (t) {
		    res2 = IoErr();
	       }
/***********************************************************************
 * Get all the files closed before processing any error.               *
 ***********************************************************************/
	       Close(outfh);
	       outfh = NULL;

	       Close(infh);
	       infh = NULL;

	       if (outlock) {
		  temp = CurrentDir(outlock);
		  strcpy(msgbuf, ap->ap_Info.fib_FileName);
	       }
	       else {
                if( strlen((char *)opts[OPT_TO]) >= MSGBUFSIZE )
                {
                        FreeVec(msgbuf);
			/* Since strlen does not include the terminating NULL
			   we need strlen + 1 */
                        if((msgbuf = AllocVec(1 + strlen((char *)opts[OPT_TO]), NULL))
                                                                           == NULL)
                        {
                                res2 = ERROR_NO_FREE_STORE;
                                goto ErrExit;
                        }
                }
                strcpy( msgbuf, (char *)opts[OPT_TO]);

	       }

	       if (t) {
		  if (res2) {

/***********************************************************************
 * if res2 must have been some error, read returns < 0 if error.       *
 * Write is set above                                                  *
 ***********************************************************************/

		     t = (int) ((t < 0) ? &MSG_READ : &MSG_WRITE);
		     VPrintf(MSG_IOERROR, &t);
		     PrintFault(res2, NULL);
		     rc = RETURN_ERROR;
		     if ((t == (long) &MSG_READ) ||
			 (res2 != ERROR_WRITE_PROTECTED)) {
				if(isfile){
					VPrintf(MSG_DELETED, (int *) &msgbuf);
					DeleteFile(msgbuf);
				}
		     }
		     if ((LONG)temp != -1) CurrentDir(temp);
		     if (IsFatal(res2)) {
			MatchEnd(ap);
			goto Done;
		     }
		     else goto Loop;
		  }
		  else {

/***********************************************************************
 * musta hit ^C in the loop                                            *
 ***********************************************************************/

			if(isfile)
			{
				VPrintf(MSG_DELETED, (int *) &msgbuf);
				DeleteFile(msgbuf);
			}

		     if ((LONG)temp != -1) CurrentDir(temp);
	             t = 0;
		     goto ErrExit1;
		  }
	       }
	       if (bufsize == 0) {
		  FreeVec(buf);
		  buf = NULL;
	       }
	       if (multisrc && !opts[OPT_QUIET])
		  PutStr(MSG_COPIED);

/***********************************************************************
 * Set protection bits, dates, and comment if applicable               *
 ***********************************************************************/

	       if (isfile)
	       {
	           ok = TRUE;
		   if (!opts[OPT_NOPRO])
                       if (SetProtection(msgbuf,(ap->ap_Info.fib_Protection & ~FIBF_ARCHIVE)) == DOSFALSE)
                           if (IoErr() != ERROR_ACTION_NOT_KNOWN)
                               ok = FALSE;

                   if (ok)
                       if (opts[OPT_DATES] || opts[OPT_CLONE])
                           if (SetFileDate(msgbuf, &ap->ap_Info.fib_Date) == DOSFALSE)
                               if (IoErr() != ERROR_ACTION_NOT_KNOWN)
                                   ok = FALSE;

                   if (ok)
                       if (opts[OPT_CLONE] || opts[OPT_COM])
                           if (SetComment(msgbuf, ap->ap_Info.fib_Comment) == DOSFALSE)
                               if (IoErr() != ERROR_ACTION_NOT_KNOWN)
                                   ok = FALSE;

                   if (!ok)
                   {
                       PrintFault(IoErr(), msgbuf);
                       rc = RETURN_WARN;
                   }
	       }

	       if ((LONG)temp != -1)
		  CurrentDir(temp);

/***********************************************************************
 *                                                                     *
 * End of main copy loop.  Find next file to copy (if any)             *
 *                                                                     *
 ***********************************************************************/
	     Loop:;
	    } while ((cont = MatchNext2(ap,*arglock,DOSBase)) == NULL);

/***********************************************************************
 *                                                                     *
 * Error handling while in main copy loop.  When fatal errors occur in *
 * the loop control is passed to here.  Also, if MatchNext at the end  *
 * of the loop fails we execute this code.                             *
 *                                                                     *
 ***********************************************************************/

	  ExitLoop:
	    if (cont != ERROR_NO_MORE_ENTRIES && cont != NULL) {
	       res2 = IoErr();
	       goto ErrExit;
	    }
	    MatchEnd(ap);
	 }
      }
      goto Done;

/***********************************************************************
 *                                                                     *
 * main error code.  Fatal errors end up here generally.               *
 *                                                                     *
 ***********************************************************************/

    ErrExit:
      rc = RETURN_FAIL;
    ErrExit1:
      MatchEnd(ap);
    ErrExit2:
      if (res2 == ERROR_NO_MORE_ENTRIES) {
	 res2 = 0;
	 rc = RETURN_OK;
      }
      if (res2) {
         if(res2 != ERROR_BREAK){
            GetProgramName(msgbuf, MSGBUFSIZE);
            VPrintf(MSG_ERROR, (void *)&msgbuf);
            if(t){
               VPrintf(MSG_ERROR1, (void *)&t);
            }
	         PrintFault(res2, NULL);
         }
      }
/***********************************************************************
 * Clean up from whatever state we were in                             *
 ***********************************************************************/

    Done:
      if (prelocks)
      {
          i = 0;
          while (i < numsources)
              UnLock(prelocks[i++]);
          FreeVec(prelocks);
      }

      if (names)
      {
          i = 0;
          while (i < numsources)
              FreeVec(names[i++]);
          FreeVec(names);
      }

      FreeVec(msgbuf);
      FreeVec(msgbuf1);
      FreeVec(ap);
      FreeVec(buf);
      FreeVec(fib);

      if (rdargs)
          FreeArgs(rdargs);

      if (infh)
	 Close(infh);

      if (outfh)
	 Close(outfh);

      UnLock(outlock);
      UnLock(destlock);

      if (windptr != (void *) -1) {
	 THISPROC->pr_WindowPtr = windptr;
      }

      SetIoErr(res2);

      CloseLibrary((struct Library *) DOSBase);
   } else {
      OPENFAIL;
   }
   return (rc);
}


LONG MatchNext2(struct AnchorPath *anchor, BPTR lock, struct DosLibrary * DOSBase)
{
LONG result;
BPTR old;

    if (lock)
      old = CurrentDir(lock);

    result = MatchNext(anchor);

    if (lock)
      CurrentDir(old);

    return(result);
}


/***********************************************************************
 *                                                                     *
 * void  Tab( int, *dosbase ) : Prints 8 spaces for each tab stop      *
 *                              specified.                             *
 ***********************************************************************/
void Tab(int tabstops, struct DosLibrary * DOSBase)
{
   int i;
   for (i = 0; i < tabstops; i++) {
      PutStr(MSG_TABIN);
   }
}

/************************************************************************
 *                                                                      *
 * ULONG IsFatal( LONG ErrNo )   : Returns boolean indicating an abort  *
 *                                  of the program is in order.         *
 ************************************************************************/
ULONG IsFatal(LONG ErrNo)
{
#define CNV( errno ) (1<<(errno-201))
   ULONG fatals =
   CNV(ERROR_DISK_NOT_VALIDATED) |
   CNV(ERROR_DISK_WRITE_PROTECTED) |
   CNV(ERROR_DEVICE_NOT_MOUNTED) |
   CNV(ERROR_SEEK_ERROR) |
   CNV(ERROR_NOT_A_DOS_DISK) |
   CNV(ERROR_DISK_FULL) |
   CNV(ERROR_NO_DISK);

   return (ULONG) ((ErrNo > 200) &&
		   (ErrNo < 232) &&
		   ((fatals & CNV(ErrNo)) != 0));
}
@


36.56
log
@Fixed excessive memory allocations when BUF=0 and filesize=0.
Removed silly extra-long header
@
text
@d126 1
d315 1
a315 1
	                 PrintFault(ERROR_NO_FREE_STORE, NULL);
d560 1
a560 1
	       bufsize = 200;
d571 1
a571 9
	    /* To lessen the number of swaps required by Workbench (Kick 207)
	       for a single drive copy, we would prefer that the default
	       number of buffers be 0.  However, we must make sure we are
	       dealing with a file system.  If not, set to 200
	    */
	    if (IsFileSystem(argptr[0]))
		bufsize = 0;
	    else
		bufsize = 200;
d1119 25
a1143 14
	       if (isfile &&
		   (!opts[OPT_NOPRO] &&
		    (SetProtection(msgbuf,
			    (ap->ap_Info.fib_Protection & ~FIBF_ARCHIVE))
		     != DOSTRUE)) ||
		   (((opts[OPT_CLONE] || opts[OPT_COM]) &&
	       SetComment(msgbuf, ap->ap_Info.fib_Comment) != DOSTRUE)) ||
		   (((opts[OPT_DATES] || opts[OPT_CLONE]) &&
	       SetFileDate(msgbuf, &ap->ap_Info.fib_Date) != DOSTRUE))) {
#if 0
/* sorry Charlie, this needs to be off */
		  PrintFault(IoErr(), msgbuf);
		  rc = RETURN_WARN;
#endif
d1145 1
@


36.55
log
@No longer uses ChangeMode since older file systems (NFS) do not understand it
@
text
@d1 1
a1 346
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* |_o_o|\\ Copyright (c) 1991 The Software Distillery.  All Rights Reserved */
/* |. o.| || This program may not be distributed without the permission of   */
/* | .  | || the authors:                             BBS: (919) 460-7430    */
/* | o  | ||   Dave Baker      Alan Beale         Jim Cooper                 */
/* |  . |//    Jay Denebeim    Bruce Drake        Gordon Keener              */
/* ======      John Mainwaring Andy Mercier       Jack Rouse                 */
/*							   John Toebes		  Mary Ellen Toebes		     */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**     (C) Copyright 1989 Commodore-Amiga, Inc.
 **         All Rights Reserved
 **/

/*---------------------------------------------------------------------------*
 * Command: Copy                                                             *
 * Author:  Jay Denebeim                                                     *
 * Change History:                                                           *
 *  Date    Person        Action                                             *
 * -------  ------------- -----------------                                  *
 * 19MAR89  John Toebes   Initial Creation                                   *
 * 25MAR89  Jay Denebeim  Initial Coding                                     *
 * 19OCT89  Jay Denebeim  Rewrite with real DOS 1.4                          *
 *
 *    REVISION HISTORY UNDER RCS
 *
 *    $Log:	copy.c,v $
*   Revision 36.51  91/05/21  16:57:04  vertex
*   Added kludge workaround to ensure current directory is the same across calls to
*   MatchFirst/Next() to avoid bug in DOS
*
*   Revision 36.50  91/05/16  16:09:38  vertex
*   Added monstruous code to make multi arguments work reliably with
*   absolute drive names. This added over a K in size to the program.
*
*   Revision 36.49  91/05/02  13:22:09  eric
*   Changed error: Wild destination invalid
*   To           : Wildcard destination invalid
*
*   Revision 36.48  91/05/01  15:04:35  eric
*   If the OPT_TO argument exceeds MSGBUFSIZE bytes a new buffer was
*   allocated.  The new buffer was too small by 1 byte because the
*   allocation forgot to include the NULL terminator.  Now fixed.
*
*   Revision 36.47  91/04/26  00:55:01  Jay
*   Boy, I musta been asleep the night I did 36.43.  Not only does it
*   cause the current directory to go to the boot volume, it will also
*   delete the wrong file if you abort a copy to a specific file.
*   It would delete the file with the 'from' name rather than the to
*   name.
*
*   Revision 36.46  91/04/19  16:53:44  eric
*   Added additional logic to flesh out what's wrong if IsFileSystem()
*   returns FALSE.
*
*   Revision 36.45  91/04/18  10:03:00  eric
*   Was doing a ParentDir on a nil file lock resulting in a requester
*   if the boot disk was not in the drive.  - Jay Denebeim
*
*   Revision 36.44  91/04/18  09:45:43  eric
*   Yet another yucky kludge.  The new code does the following:
*   IF copy from dir = C: AND only one file is being copied AND
*   the file does not exist THEN return warn instead of error.
*
*   The reason for this is to keep install scripts which copy
*   the commands from C: that are now resident to the shell to
*   continue working.  - Jay Denebeim
*
*   Revision 36.43  91/04/15  14:14:47  eric
*   Jay: 37.2 introduced a memoration induced enforcer hit.  This fixes it.
*   (The bug was really introduced in 36.42 - EMC)
*
*   Revision 36.42  91/02/27  10:28:23  eric
*   Bug in DOS was introduced since I wrote the last version 36 update.
*   Currently ParsePattern requires a buffer to hold the parsed pattern
*   even if all we want is a IsWild bool.
*   A kludge has been inserted into the code to workaround this problem.
*
*   Revision 36.41  91/01/09  21:36:31  Jay
*   B11750:  I don't agree with doing this I feel that people should be
*            able to name their destinations whatever they want them to
*            be.  This update removes the ability to copy to files
*            containing what the pattern matcher conciders wildcards.
*            There is no way to escape the characters and create a name
*            with wildcards.
*
*   Revision 36.40  90/12/21  22:26:48  Jay
*   B11099:  Undetected infiniate recursion when soft/hard links
*   	cause recursion on input.  This update fixes that.
*
*   Revision 36.39  90/10/26  01:36:49  Jay
*   Unnumbered bug "Copy error message is bogus".  Was always printing the
*   'TO' destination.  Changed to print the 'TO' if not multisrc, prints
*   the filename otherwise.
*   Refer: bryce (Bryce Nesbitt,,9267,)
*
*   Revision 36.38  90/10/25  11:33:15  eric
*   Made the default number of buffers 0 if dealing with a file system.
*
*   Revision 36.37  90/10/22  20:44:14  Jay
*   B10293: (Yet again)  There is still a bug in the file system, *
*   is a file system.  However, there was also a bug in copy, I was
*   checking the to file rather than the from file.
*
*   Revision 36.36  90/10/12  00:22:10  Jay
*   Unnumbered bug.  Copy was having problems with the new date routine.
*   Aparently it was setting the date on the source under some
*   circumstances.  I have not been able to re-produce it, however
*   I have added several checks around the problem area.  Specifically,
*   I am checking on outlock != NULL, and ensuring the changed file is
*   a directory.  Hopefully this will fix it.
*   Additionally it was only setting the directory date if the clone
*   switch was used, now it is also doing it if dates are requested.
*
*   Revision 36.35  90/10/03  01:31:12  Jay
*   B10293:  copy was having trouble with copy from *.  This problem was
*   caused by trying to find the size of the file copied from on
*   non-file-system files.  To fix, change the buffer size to be fixed
*   at 200 if the from file is not a file system.
*
*   Revision 36.34  90/09/26  02:21:07  Jay
*   Re-Align copyright notice.
*   Ensure all variables are initialized.  This may help the copy * bug.
*
*   B9532:  copy to ram:test now works.  I did this by removing the
*   requirement for a from, and if the from is not provided fake the
*   multi-args equivilent for FROM "".
*
*   Revision 36.33  90/09/25  22:51:50  Jay
*   Check in to 'official' RCS file most current version of copy.
*
*   Revision 36.32  90/09/11  03:01:26  Jay
*   Put SysBase back in.  Also, remove all compiler warnings.
*
*   Revision 36.31  90/09/03  18:18:39  Jay
*   Suggestion by John Toebes.  Preserve dates of directories when CLONing.
*   Real easy to implement, set the date whenever stepping out of a
*   directory.
*   Cost: 92 bytes / 0 blocks
*
*   Revision 36.30  90/09/01  11:40:41  Jay
*   Finally, a real fix for the KLUDGE.  Randal found it, basically
*   I was counting on the current directory to not be NULL when the
*   software was started.  This showed up when copying wildcards,
*   the way I was telling wether or not to re-set the Current
*   Directory back to the original was if it was != NULL.
*
*   Revision 36.29  90/08/28  21:41:33  Jay
*   Cost: 36 bytes/ 1 block (sigh)
*
*   This fixes a couple of non-reported bugs.  They were found by Alan Beale
*   of the Software Distillery.  Basically, there were several problems
*   with non-filesystem devices.  This fixes all known ones, specifically:
*   aborting a copy to a non file system resulted in 'destination file
*   device: removed', and a bad one, using the ALL option on a non file system
*   caused all files in sub-directories of the original directory to be copied
*   to the boot device (NULL lock syndrom).
*
*   These were fixed by judicious use of tests for filesystem disabling portions
*   of the code which were not appropriate for non-filesystems.
*
*   Revision 36.28  90/08/28  00:21:08  Jay
*   Put KLUDGE back in, aparently its not fixed yet.
*
*   Revision 36.27  90/08/28  00:03:53  Jay
*   Change the phone number of the BBS
*
*   Revision 36.26  90/08/26  23:29:51  Jay
*   Cost: 4 bytes/ 0 sectors (don't ask me why, optomizer vagarities)
*
*   Bug #B9118.  The logic on one of the error handling routines was
*   broken in some editing session awhile ago.  When the files are
*   being open, the existance of the input filehandle told the
*   routine wether the file was for input or output.  At some point
*   the logic was changed to set the input filehandle to NULL when
*   the open output failed, thereby breaking the logic deciding wether
*   the input or output file failed to open.
*   I fixed this by moving the closeing of the input file to later in
*   the code.  This allowed me to simplify the code somewhat, and to
*   reduce redundant code to a single instance.
*   Strangely enough, even with the code removed, the object code ended
*   up bigger.
*
*   Revision 36.25  90/08/26  22:48:08  Jay
*   Cost: 24 bytes/0 blocks
*   Bug #B8215 yet again.  Turns out that the version of DOS Randal
*   was using had different behaviour for MatchFirst/Next then I did.
*   Now that I've got a newer version of Kickstart, the change is
*   visible.  Previously, MatchFirst returned an OK result code if
*   the (unique) file name was non-existant.  Now, if the file is
*   unique, and does not exist, MatchFirst returns 'Object not found'.
*   This is OK behaviour, just different from what I was using.  Because
*   of this, copy for him was returning with a non-so-good response.
*   My assumption was if MatchFirst returned bad results, there was
*   something seriously wrong, and so the error string did not reflect
*   the FROM file name, only the error itself.
*   To fix the problem, I've handled 'object not found' on MatchFirst
*   the same way that an Open input filehandle is treated.
*
*   Revision 36.24  90/08/26  13:22:20  Jay
*   Remove KLUDGE, change for clean compilation.
*
*   Revision 36.23  90/08/21  20:47:50  C=
*   Incorporate C= changes to my copy of copy.
*
*   Revision 1.14  90/06/14  17:55:58  andy
*   added more tests for ERROR_BREAK,
*   added error test after each MatchNext
*   removed error printing after setprotect,etc. failure
*
*   Revision 1.13  90/05/25  13:52:53  andy
*   new version from SW Distillery
*
*   Revision 36.16  90/05/20  19:25:52  Jay
*   Fixes bugs:
*   * B8215 wrong 'arg' used for error strings.  Well, that's not quite
*           right.  Actually, the src/dest file was not always printed
*           this was design intent, to make the file as small as possible.
*           To fix, printed the src/dest file name under more errors.
*           Ended up being not as expensive as I thought, 128 bytes/0 blocks
*
*   Revision 36.15  90/05/20  16:48:46  Jay
*   This version fixes several problems:
*
*   * B8115: Preserving the archive bit on a copy.
*   * B8150: Not handling infinite recursion.  This was fixed by walking
*            the chain of directories back to the root looking for
*            duplicate locks.  If one exists, the program is aborted.
*            It may not be a bad idea to make this non-fatal, but
*            I'm leaving it like it is for the time being.
*   * B8259: Unable to copy to PRT:.  Actually, this is any non-file-system.
*            What the problem was is the handlers for these cannot deal
*            with createdirs and file stat modifys (flags, dates etc).
*            Solution was to check to see if the object of the copy was
*            a non-file-system, and suppress the fatal problem if so.
*            Outstanding issue:  STDOUT indicates it IS a file system, so
*            is still broke in this respect.  When copying TO * the
*            program will still abort.  C= needs to re-think wether or
*            not the console should be a file system.
*   Cost of update: 248 bytes
*                   0   blocks
*
*   Revision 1.14  90/05/18  01:26:37  Jay
*   Merged Andy's version with mine.  Using shipped RCS files.
*   It is a false statement that I like this formatting better I'm
*   using Indent, and am not really happy with it, but the formatting
*   changes are so great, its not practicle to merge the sources
*   unless something like this is done.  *sigh*
*
*   Okay.  There were several collisions, Andy generally won, but I've
*   left in my checking of IoErr and the file copying over a file fix.
*
*   Additionally, I've changed the way the setting flags/comments/dates
*   etc work.  Originally the way copy worked, is it would go through
*   all three settings, then evaluated the error.  Even if one failed
*   the others would be executed.  When I optomized and put in the
*   gotos, I aparently changed it so the first failure aborted the
*   rest of the changes.  Since its worked this way for awhile, and
*   no one has complained, I've now put all the changes in one if
*   statement.  Equivilent code, but perhaps more compact.  Dunno,
*   certainly easier to read.
*
 * Revision 36.12  90/03/30  20:28:33  Jay
 * Copy was overwriting dirs if a dir was copied to itself.  1.3 Copy
 * (and originally this copy, don't know how it happened), opens the
 * input file first, thereby blocking the open for write.
 *
 * Revision 36.11  90/03/29  03:15:35  Jay
 * Provide more discriminating error handling.
 *
 * Revision 36.10  90/03/27  23:28:11  Jay
 * Integrate Andy's version with mine.
 *
 * Revision 36.7  90/03/11  16:31:37  Jay
 * Aparently MatchFirst is DupLocking a NULL lock.  This version
 * includes a Kludge to get around this.
 * Please fix it for real!
 *
 * Revision 36.6a  90/03/08  02:06:20  Andy
*   Revision 1.13  90/05/17  23:56:59  Jay
*   Switch indentation back to my style.
*
*   Revision 1.12  90/04/20  22:55:17  andy
*   copy no longer deletes the destination if the source is unreadable
*
*   Revision 1.11  90/04/20  07:25:01  andy
*   fixed control-C out of infinite copy loop.  Though it
*   probably should detect this error and never get in it.
*
*   Revision 1.10  90/04/18  22:49:15  Unknown
*   stops on a control-C now
*
 * Revision 36.10  90/03/27  23:28:11  Jay
 * Integrate Andy's version with mine.
 *
 * Revision 36.7  90/03/11  16:31:37  Jay
 * Aparently MatchFirst is DupLocking a NULL lock.  This version
 * includes a Kludge to get around this.
 * Please fix it for real!
 *
 * Revision 36.6a  90/03/08  02:06:20  Andy
 * removed some of the GOTOs to clean up program flow
 * no longer deletes a write protected file
 * all variables initialized
 * sets current directory if brought up before any CD exists
 *
 * Revision 36.6  90/03/10  23:15:44  Jay
 * Terminations while forbidden.
 *
 * Revision 36.5  90/01/15  22:06:20  Jay
 * forgot to set the outfh to null after closing
 *
 * Revision 36.4  90/01/15  21:45:30  Jay
 * Reset the window pointer too late.  Also, extrenious newline when
 * in quiet mode.
 *
 * Revision 36.3  90/01/14  14:18:09  Jay
 * Remove comments around the code that causes requester suppression.
 *
 * Revision 36.2  90/01/13  13:00:17  Jay
 * Fix bugs found by code review.
 *
 * Revision 36.1  90/01/07  22:49:32  Jay
 * Check in Current beta version
 *
 *
 * Revision 1.8  89/12/12  11:24:51  Jay
 * Forgot to initialize some variables.  Additionally, code tends
 * to work a little better if one doesn't use non allocated memory
 * for storage.
 *
 * Revision 1.6  89/12/06  23:34:20  Jay
 * Incorporate Andy's suggestion to make NOREQUEST part of QUIET.
 * (also verified that the BUF command now works fine)
 *
 * Revision 1.5  89/12/06  22:47:51  Jay
 * Incorporate John's changes from C= into the RCS version of Copy.c
 * (was really easy by the way)
 *
 * Revision 1.4  89/12/05  00:53:24  Jay
 * Pretty up the comments
 *
 * Revision 1.3  89/12/05  00:35:11  Jay
 * Silly me, need to set up the file name before setting flags etc
 *
 * Notes:                                                                    *
a68 2
#define  MIN_BUF              0x1000	/* 4K minimum buffer size     */

d590 6
a595 2
	 if (bufsize) {
	    if ((buf = AllocVec(bufsize, 0)) == NULL) {
d597 8
a604 17
/***********************************************************************
 * If there is not enough memory for the buffer, take the largest      *
 * available. If that doesn't work abort the program.                  *
 ***********************************************************************/

	       Forbid();	/* so someone doesn't steal memory from us */
	       bufsize = AvailMem(MEMF_LARGEST) - BUF_SAFE;
	       if (bufsize > MIN_BUF) {
		  buf = AllocVec(bufsize, 0);
	       }
	       Permit();
	       if (buf == NULL) {
            t = 0;
		  res2 = ERROR_NO_FREE_STORE;
		  goto ErrExit;
	       }
	    }
d606 1
d999 16
a1014 12
		  if ((buf = AllocVec(bs, 0)) == NULL) {
		     Forbid();	/* so someone doesn't steal memory from us */
		     bs = AvailMem(MEMF_LARGEST) - BUF_SAFE;
		     if (bs > MIN_BUF) {
			buf = AllocVec(bs, 0);
		     }
		     Permit();
		     if (buf == NULL) {
			res2 = ERROR_NO_FREE_STORE;
         		t = 0;
			goto ErrExit;
		     }
d1016 1
a1016 1
	       }
@


36.54
log
@Now CDs to the right location before IsFileSystem() calls
@
text
@d838 6
a843 1
	       if (!ChangeMode(CHANGE_LOCK,outlock,SHARED_LOCK))
a846 4
	       }
	       created = TRUE;
	       if (!opts[OPT_QUIET]) {
		  VPrintf("   %s" MSG_DIR_CREATE, &opts[OPT_TO]);
@


36.53
log
@Fixed kludge to cause attempts to load C:XXX files to return 5 instead of 20 upon
failure
@
text
@a763 3
         if (*arglock)
  	     CurrentDir(oldCD);

d767 4
d773 4
d897 3
d927 4
@


36.52
log
@Fixed bug with multi-source mode loosing the target's directory between
each source being processed.
Also simplified termination code since UnLock()/FreeVec() can take NULL
arguments safely
@
text
@d744 2
d748 3
@


36.51
log
@Added kludge workaround to ensure current directory is the same across calls to
MatchFirst/Next() to avoid bug in DOS
@
text
@d28 4
d383 4
d455 1
d485 1
a485 1
   if ((DOSBase = (struct DosLibrary *) OpenLibrary(DOSNAME, DOSVER))) {
d828 5
d838 5
d966 8
a975 1

d1268 1
a1268 1
		    	 CurrentDir(temp);
d1545 6
a1550 14
      if (msgbuf)
	 FreeVec(msgbuf);
      if (msgbuf1)
	 FreeVec(msgbuf1);
      if (ap)
	 FreeVec(ap);
      if (buf)
	 FreeVec(buf);

	  /* I don't know if this is required, but just to be safe.... */
	  if (opts[OPT_FROM] == (long)&fromless)
	  {
		opts[OPT_FROM] = (long)NULL;
	  }
d1552 2
a1553 1
		FreeArgs(rdargs);
d1556 1
d1559 3
a1561 4
      if (outlock)
	 UnLock(outlock);
      if (fib)
	 FreeVec(fib);
@


36.50
log
@Added monstruous code to make multi arguments work reliably with
absolute drive names. This added over a K in size to the program.
@
text
@d28 4
d410 1
d682 1
a682 1
                         if (!(names[argcnt] = AllocVec(strlen(&argname[i+1])+1,MEMF_CLEAR|MEMF_PUBLIC)))
a705 1
         oldCD = NULL;
a707 1
         arglock++;
d710 1
a710 1
	    if (oldCD)
d750 1
a750 1
         if (oldCD)
d785 1
a785 1
	       if(MatchNext(ap)) {
a946 1
               oldCD = NULL;
a948 1
               arglock++;
d951 1
a951 1
	          if (oldCD)
d970 1
a970 1
	       if (oldCD)
d976 1
a976 1
		  if(MatchNext(ap)) {
d1036 1
a1036 1
		  if ((cont = MatchNext(ap)) || (tabin < 0)) {
d1183 1
a1183 1
		  if(MatchNext(ap)) {
d1453 1
a1453 1
	    } while ((cont = MatchNext(ap)) == NULL);
d1556 18
@


36.49
log
@Changed error: Wild destination invalid
To           : Wildcard destination invalid
@
text
@d28 4
d36 1
a36 1
*   
d40 1
a40 1
*   delete the wrong file if you abort a copy to a specific file.  
d43 1
a43 1
*   
d47 1
a47 1
*   
d51 1
a51 1
*   
d56 1
a56 1
*   
d60 1
a60 1
*   
d64 1
a64 1
*   
d78 1
a78 1
*   
d82 1
a82 1
*   
d88 1
a88 1
*   
d91 1
a91 1
*   
d96 1
a96 1
*   
d103 1
a103 1
*   a directory.  Hopefully this will fix it. 
d106 1
a106 1
*   
d109 1
a109 1
*   caused by trying to find the size of the file copied from on 
d112 1
a112 1
*   
d116 2
a117 2
*   
*   B9532:  copy to ram:test now works.  I did this by removing the 
d120 1
a120 1
*   
d123 1
a123 1
*   
d126 1
a126 1
*   
d132 1
a132 1
*   
d137 3
a139 3
*   the way I was telling wether or not to re-set the Current 
*   Directory back to the original was if it was != NULL.  
*   
d142 1
a142 1
*   
d150 1
a150 1
*    
d153 1
a153 1
*   
d156 1
a156 1
*   
d159 1
a159 1
*   
d162 1
a162 1
*   
d169 1
a169 1
*   the input or output file failed to open.  
d175 1
a175 1
*   
d188 1
a188 1
*   the FROM file name, only the error itself.  
d191 1
a191 1
*   
d194 1
a194 1
*   
d197 1
a197 1
*   
d202 1
a202 1
*   
d205 1
a205 1
*   
d213 1
a213 1
*   
d216 1
a216 1
*   
d229 1
a229 1
*            is still broke in this respect.  When copying TO * the 
d234 1
a234 1
*   
d449 10
d470 1
a470 1
	
d575 1
a575 1
      	 
d587 1
a587 1
	
d597 101
d699 7
a705 1
    t = 0;
d707 2
d711 1
a711 1
			
d723 1
a723 1
 * This code is to keep install scripts from breaking.  If 
d746 4
d944 5
d950 2
d955 1
a955 1
			
d968 4
d1013 1
a1013 1
			  
d1096 1
a1096 1
         
d1136 1
a1136 1
	
d1140 1
a1140 1
					if ((outlock = CreateDir(ap->ap_Info.fib_FileName)) == NULL) 
d1148 1
a1148 1
						
d1151 1
a1151 1
					
d1153 1
a1153 1
				
d1259 1
a1259 1
			
d1318 1
a1318 1
	       } 
d1356 1
a1356 1
	       } 
d1363 1
a1363 1
                        if((msgbuf = AllocVec(1 + strlen((char *)opts[OPT_TO]), NULL)) 
d1371 1
a1371 1
                        
d1397 1
a1397 1
		     } 
d1399 1
a1399 1
		  } 
d1502 16
d1526 1
a1526 1
	  
@


36.48
log
@If the OPT_TO argument exceeds MSGBUFSIZE bytes a new buffer was
allocated.  The new buffer was too small by 1 byte because the
allocation forgot to include the NULL terminator.  Now fixed.
@
text
@d28 5
d391 1
a391 1
#define  MSG_TOWILD           "Wild destination invalid.\n"
@


36.47
log
@Boy, I musta been asleep the night I did 36.43.  Not only does it
cause the current directory to go to the boot volume, it will also
delete the wrong file if you abort a copy to a specific file.  
It would delete the file with the 'from' name rather than the to
name.
@
text
@d28 7
d1218 3
a1220 1
                        if((msgbuf = AllocVec(strlen((char *)opts[OPT_TO]), NULL)) 
@


36.46
log
@Added additional logic to flesh out what's wrong if IsFileSystem()
returns FALSE.
@
text
@d28 4
d1208 12
a1219 5
		temp1 = Lock(ap->ap_Info.fib_FileName, SHARED_LOCK);
		temp = ParentDir(temp1);
		Examine( temp1, fib );
		UnLock(temp1);
		strcpy(msgbuf, fib->fib_FileName );
@


36.45
log
@Was doing a ParentDir on a nil file lock resulting in a requester
if the boot disk was not in the drive.  - Jay Denebeim
@
text
@d28 4
d608 1
a608 1
	 if (IoErr() == ERROR_DEVICE_NOT_MOUNTED) {
@


36.44
log
@Yet another yucky kludge.  The new code does the following:
IF copy from dir = C: AND only one file is being copied AND
the file does not exist THEN return warn instead of error.

The reason for this is to keep install scripts which copy
the commands from C: that are now resident to the shell to
continue working.  - Jay Denebeim
@
text
@d28 9
d965 1
a965 1
				do {
d977 1
a977 1
				} while (temp2 != NULL);
@


36.43
log
@Jay: 37.2 introduced a memoration induced enforcer hit.  This fixes it.
(The bug was really introduced in 36.42 - EMC)
@
text
@d28 4
d37 1
a37 1
**   
d340 1
d413 3
d568 22
@


36.42
log
@Bug in DOS was introduced since I wrote the last version 36 update.
Currently ParsePattern requires a buffer to hold the parsed pattern
even if all we want is a IsWild bool.
A kludge has been inserted into the code to workaround this problem.
@
text
@d28 6
d510 1
a510 2
   buf = AllocVec(500, 0);
   if(ParsePattern((char *)opts[OPT_TO], buf, 500))
d1161 5
a1165 2
		  temp = (BPTR)-1;
		  strcpy(msgbuf, (char *) opts[OPT_TO]);
@


36.41
log
@B11750:  I don't agree with doing this I feel that people should be
         able to name their destinations whatever they want them to
         be.  This update removes the ability to copy to files
         containing what the pattern matcher conciders wildcards.
         There is no way to escape the characters and create a name
         with wildcards.
@
text
@d2 1
a2 1
/* |_o_o|\\ Copyright (c) 1990 The Software Distillery.  All Rights Reserved */
d28 8
d329 2
d503 4
d508 1
d515 4
@


36.40
log
@B11099:  Undetected infiniate recursion when soft/hard links
	cause recursion on input.  This update fixes that.
@
text
@d28 4
d341 1
d487 14
a500 1
	 
@


36.39
log
@Unnumbered bug "Copy error message is bogus".  Was always printing the
'TO' destination.  Changed to print the 'TO' if not multisrc, prints
the filename otherwise.
Refer: bryce (Bryce Nesbitt,,9267,)
@
text
@d28 6
d840 10
a849 4
		     /* Get a lock on the input directory */
		     temp = CurrentDir(ap->ap_Current->an_Lock);
		     temp1 = Lock(ap->ap_Info.fib_FileName, SHARED_LOCK);
		     CurrentDir(temp);
d851 21
d873 1
a896 1
				UnLock(temp1);
d915 3
d919 1
a920 3
		     tabin++;
		     temp = CurrentDir(temp);
		     UnLock(temp);	/* release parent lock */
@


36.38
log
@Made the default number of buffers 0 if dealing with a file system.
@
text
@d28 3
d319 1
a319 1
						                                                                           perhaps useful          */
d336 1
a336 1
					                                     * allocated by AllocVec      */
d976 7
a982 3
		  if(!infh)t = (int) ap->ap_Info.fib_FileName;
		  else {
			t=(int)opts[OPT_TO];
@


36.37
log
@B10293: (Yet again)  There is still a bug in the file system, *
is a file system.  However, there was also a bug in copy, I was
checking the to file rather than the from file.
@
text
@d28 5
d628 2
a629 1
	 if (opts[OPT_BUFS]) {
d634 1
d641 13
a653 2
	 } else
	    bufsize = 200;
@


36.36
log
@Unnumbered bug.  Copy was having problems with the new date routine.
Aparently it was setting the date on the source under some
circumstances.  I have not been able to re-produce it, however
I have added several checks around the problem area.  Specifically,
I am checking on outlock != NULL, and ensuring the changed file is
a directory.  Hopefully this will fix it. 
Additionally it was only setting the directory date if the clone
switch was used, now it is also doing it if dates are requested.
@
text
@d28 10
d626 1
a626 1
	    if (bufsize < 0 || !isfile)
@


36.35
log
@B10293:  copy was having trouble with copy from *.  This problem was
caused by trying to find the size of the file copied from on 
non-file-system files.  To fix, change the buffer size to be fixed
at 200 if the from file is not a file system.
@
text
@d28 6
d738 2
a739 1
			  if(opts[OPT_CLONE]){
d896 2
a897 1
				 if(opts[OPT_CLONE])
@


36.34
log
@Re-Align copyright notice.
Ensure all variables are initialized.  This may help the copy * bug.

B9532:  copy to ram:test now works.  I did this by removing the 
requirement for a from, and if the from is not provided fake the
multi-args equivilent for FROM "".
@
text
@d28 8
d610 1
a610 1
	    if (bufsize < 0)
@


36.33
log
@Check in to 'official' RCS file most current version of copy.
@
text
@d8 1
a8 1
/*								John Toebes		   Mary Ellen Toebes		  */
d28 3
d266 1
a266 1
#define TEMPLATE  "FROM/A/M,TO/A,ALL/S,QUIET/S,BUF=BUFFER/K/N,CLONE/S,DATES/S,NOPRO/S,COM/S,NOREQ/S" CMDREV
d336 1
a336 1
	struct Library *SysBase;
d338 1
a338 1
   int multisrc = FALSE, tabin = 0, isfile, created;
d341 1
a341 1
   char *msgbuf1 = NULL, *msgbuf = NULL, *buf = NULL, *curarg, **argptr;
d343 1
a343 1
   long bufsize, t, bs;
d348 1
d444 13
d1174 6
d1181 1
a1181 1
	 FreeArgs(rdargs);
@


36.31
log
@The real new version from John Toebes.
Note: added definition of SysBase.
@
text
@d28 16
a262 2
#define KLUDGE

d333 1
a333 1
   struct Library *SysBase = (*((struct Library **) 4));
d343 1
a343 1
   APTR windptr = (APTR)-1;
d354 3
a356 4
#ifdef KLUDGE
   int kludge = FALSE;
#endif

a369 6
#ifdef KLUDGE
      if (THISPROC->pr_CurrentDir == NULL) {
	 THISPROC->pr_CurrentDir = Lock("SYS:", ACCESS_READ);
	 kludge = TRUE;
      }
#endif
d706 6
d864 6
d1017 1
a1017 1
		  temp = NULL;
d1040 1
a1040 1
		     if (temp) CurrentDir(temp);
d1059 1
a1059 1
		     if (temp) CurrentDir(temp);
d1090 1
a1090 1
	       if (temp)
a1170 7
#ifdef KLUDGE
      if (kludge) {
	 UnLock(THISPROC->pr_CurrentDir);
	 THISPROC->pr_CurrentDir = NULL;
      }
#endif

@


36.30
log
@Added definition of SysBase
@
text
@@


36.29
log
@Cost: 36 bytes/ 1 block (sigh)

This fixes a couple of non-reported bugs.  They were found by Alan Beale
of the Software Distillery.  Basically, there were several problems
with non-filesystem devices.  This fixes all known ones, specifically:
aborting a copy to a non file system resulted in 'destination file
device: removed', and a bad one, using the ALL option on a non file system
caused all files in sub-directories of the original directory to be copied
to the boot device (NULL lock syndrom).
 
These were fixed by judicious use of tests for filesystem disabling portions
of the code which were not appropriate for non-filesystems.
@
text
@d28 14
d319 1
@


36.28
log
@Put KLUDGE back in, aparently its not fixed yet.
@
text
@d28 3
d680 5
a684 3
		  temp = outlock;
		  outlock = ParentDir(outlock);
		  UnLock(temp);
d748 44
a791 9
		     if (created) {
			temp2 = ParentDir(outlock);
		     } else {
			temp2 = DupLock(outlock);
		     }

		     /* Walk up the chain of parents looking for the
                        current input directory.  If its on the list
                        infinite recursion will occure.              */
a792 36
		     do {
			if (SameLock(temp1, temp2) == LOCK_SAME) {
			   t = (LONG) ap->ap_Info.fib_FileName;
			   VPrintf(MSG_RECURS, &t);
			   res2 = 0;
			   UnLock(temp1);
			   UnLock(temp2);
			   goto ErrExit;
			}
			temp = ParentDir(temp2);
			UnLock(temp2);
			temp2 = temp;
		     } while (temp2 != NULL);
		     UnLock(temp1);

		     temp = CurrentDir(outlock);
		     if ((outlock = Lock(ap->ap_Info.fib_FileName, SHARED_LOCK))
			 == NULL) 
           {
			   if ((outlock = CreateDir(ap->ap_Info.fib_FileName)) == NULL) 
            {
			      res2 = IoErr();
   			   outlock = CurrentDir(temp);
	   		   if (!opts[OPT_QUIET])
		   	      PutStr("\n");
               strcpy( msgbuf1, ap->ap_Info.fib_FileName);
               t = (long)msgbuf1;
			      goto ErrExit;
   			} else if (!opts[OPT_QUIET])
	   		   PutStr(MSG_DIR_CREATE);
		      } else {
      			if (!opts[OPT_QUIET])
		   	   PutStr("\n");

		      }

d832 5
a836 3
		     temp = outlock;
		     outlock = ParentDir(outlock);
		     UnLock(temp);
d1001 4
a1004 2
			VPrintf(MSG_DELETED, (int *) &msgbuf);
			DeleteFile(msgbuf);
d1019 5
a1023 2
		     VPrintf(MSG_DELETED, (int *) &msgbuf);
		     DeleteFile(msgbuf);
@


36.27
log
@Change the phone number of the BBS
@
text
@d28 3
d226 6
d311 1
a311 1
   APTR windptr = (void *)-1;
d322 3
d339 6
d1126 6
@


36.26
log
@Cost: 4 bytes/ 0 sectors (don't ask me why, optomizer vagarities)

Bug #B9118.  The logic on one of the error handling routines was
broken in some editing session awhile ago.  When the files are
being open, the existance of the input filehandle told the
routine wether the file was for input or output.  At some point
the logic was changed to set the input filehandle to NULL when
the open output failed, thereby breaking the logic deciding wether
the input or output file failed to open.  
I fixed this by moving the closeing of the input file to later in
the code.  This allowed me to simplify the code somewhat, and to
reduce redundant code to a single instance.
Strangely enough, even with the code removed, the object code ended
up bigger.
@
text
@d4 1
a4 1
/* | .  | || the authors:                             BBS: (919) 382-8265    */
d8 1
d28 16
@


36.25
log
@Cost: 24 bytes/0 blocks
Bug #B8215 yet again.  Turns out that the version of DOS Randal
was using had different behaviour for MatchFirst/Next then I did.
Now that I've got a newer version of Kickstart, the change is
visible.  Previously, MatchFirst returned an OK result code if
the (unique) file name was non-existant.  Now, if the file is
unique, and does not exist, MatchFirst returns 'Object not found'.
This is OK behaviour, just different from what I was using.  Because
of this, copy for him was returning with a non-so-good response.
My assumption was if MatchFirst returned bad results, there was
something seriously wrong, and so the error string did not reflect
the FROM file name, only the error itself.  
To fix the problem, I've handled 'object not found' on MatchFirst
the same way that an Open input filehandle is treated.
@
text
@d27 16
a821 1
		  res2 = IoErr();
d825 11
a835 4
	       if (infh)
		  if (outlock) {
		     temp = CurrentDir(outlock);
		     if (!(outfh = Open(ap->ap_Info.fib_FileName, MODE_NEWFILE))) {
d837 3
d842 2
a843 14
		     }
		     CurrentDir(temp);
		  } else {
		     if (!(outfh = Open((char *) opts[OPT_TO], MODE_NEWFILE))) {
			res2 = IoErr();
			Close(infh);
			infh = 0;
		     }
		  }

	       if (!outfh || !infh) {
		  if(!infh)t = (int) ap->ap_Info.fib_FileName;
		  else t=(int)opts[OPT_TO];

@


36.24
log
@Remove KLUDGE, change for clean compilation.
@
text
@d27 3
d377 12
d575 12
@


36.23
log
@Incorporate C= changes to my copy of copy.
@
text
@d27 2
a28 2
*   Revision 36.23  90/08/21  20:44:07  Jay
*   *** empty log message ***
a186 6
#ifdef MWDEBUG
#include "memlib/memwatch.h"
#endif

#define KLUDGE

a256 1
   struct Library *SysBase = (*((struct Library **) 4));
d266 1
a266 1
   APTR windptr = (void *) -1;
a276 3
#ifdef KLUDGE
   int kludge = FALSE;
#endif
a286 5
#ifdef MWDEBUG
      MWInit(NULL, 0);
      MWReport(NULL, MWR_FULL);
#endif

a290 6
#ifdef KLUDGE
      if (THISPROC->pr_CurrentDir == NULL) {
	 THISPROC->pr_CurrentDir = Lock("SYS:", ACCESS_READ);
	 kludge = TRUE;
      }
#endif
a1050 6
#ifdef KLUDGE
      if (kludge) {
	 UnLock(THISPROC->pr_CurrentDir);
	 THISPROC->pr_CurrentDir = NULL;
      }
#endif
@


36.16
log
@Fixes bugs:
* B8215 wrong 'arg' used for error strings.  Well, that's not quite
        right.  Actually, the src/dest file was not always printed
        this was design intent, to make the file as small as possible.
        To fix, printed the src/dest file name under more errors.
        Ended up being not as expensive as I thought, 128 bytes/0 blocks
@
text
@d27 19
d193 1
a193 1
#define TEMPLATE  "FROM/A/M,TO/A,ALL/S,QUIET/S,BUF=BUFFER/K/N,CLONE/S,DATES/S,NOPRO/S,COM/S" CMDREV
d203 2
a204 1
#define OPT_COUNT    9
d263 1
d378 1
a378 1
	 if (opts[OPT_QUIET]) {
d429 4
a432 1
	       MatchNext(ap);
d580 1
a580 1
        t = (long)curarg;
d586 4
a589 1
		  MatchNext(ap);
d757 4
a760 2
		  MatchNext(ap);

d822 3
a824 1
		  t = (int) ap->ap_Info.fib_FileName;
d826 1
d879 1
a879 1
         t = 0;
d883 2
a884 2
	       } else
		  bs = bufsize;
d906 3
a908 3
	       if (t != 0)
		  res2 = IoErr();

d921 2
a922 1
	       } else {
a927 1

d944 1
a944 2
		     if (temp)
			CurrentDir(temp);
d948 4
a951 4
		     } else {
			goto Loop;
		     }
		  } else {
a957 1

d960 2
a961 3
		     if (temp)
			CurrentDir(temp);
            t = 0;
d985 2
a986 1

d989 1
d1116 1
@


36.15
log
@This version fixes several problems:

* B8115: Preserving the archive bit on a copy.
* B8150: Not handling infinite recursion.  This was fixed by walking
         the chain of directories back to the root looking for
         duplicate locks.  If one exists, the program is aborted.
         It may not be a bad idea to make this non-fatal, but
         I'm leaving it like it is for the time being.
* B8259: Unable to copy to PRT:.  Actually, this is any non-file-system.
         What the problem was is the handlers for these cannot deal
         with createdirs and file stat modifys (flags, dates etc).
         Solution was to check to see if the object of the copy was
         a non-file-system, and suppress the fatal problem if so.
         Outstanding issue:  STDOUT indicates it IS a file system, so
         is still broke in this respect.  When copying TO * the 
         program will still abort.  C= needs to re-think wether or
         not the console should be a file system.
Cost of update: 248 bytes
                0   blocks
@
text
@d26 22
a47 1
 *    $Log:     copy.c,v $
d204 2
d244 1
a244 1
   int multisrc = FALSE, tabin = 0, isfile = TRUE, created;
d247 1
a247 1
   char *msgbuf = NULL, *buf = NULL, *curarg, **argptr;
d301 1
d318 1
d371 1
d411 1
d522 1
d556 1
d686 16
a701 13
			 == NULL) {
			if ((outlock = CreateDir(ap->ap_Info.fib_FileName))
			    == NULL) {
			   res2 = IoErr();
			   outlock = CurrentDir(temp);
			   if (!opts[OPT_QUIET])
			      PutStr("\n");
			   goto ErrExit;
			} else if (!opts[OPT_QUIET])
			   PutStr(MSG_DIR_CREATE);
		     } else {
			if (!opts[OPT_QUIET])
			   PutStr("\n");
d703 1
a703 1
		     }
d847 1
d932 1
d1005 8
a1012 2
	 GetProgramName(msgbuf, MSGBUFSIZE);
	 PrintFault(res2, msgbuf);
d1021 2
@


1.14
log
@Merged Andy's version with mine.  Using shipped RCS files.
It is a false statement that I like this formatting better I'm
using Indent, and am not really happy with it, but the formatting
changes are so great, its not practicle to merge the sources
unless something like this is done.  *sigh*

Okay.  There were several collisions, Andy generally won, but I've
left in my checking of IoErr and the file copying over a file fix.

Additionally, I've changed the way the setting flags/comments/dates
etc work.  Originally the way copy worked, is it would go through
all three settings, then evaluated the error.  Even if one failed
the others would be executed.  When I optomized and put in the
gotos, I aparently changed it so the first failure aborted the
rest of the changes.  Since its worked this way for awhile, and
no one has complained, I've now put all the changes in one if
statement.  Equivilent code, but perhaps more compact.  Dunno,
certainly easier to read.
@
text
@d26 21
a46 1
 *    $Log:	copy.c,v $
d66 1
a66 1
*   
d173 1
a173 1
						                           perhaps useful          */
d182 1
d188 1
a188 1
                                     * allocated by AllocVec      */
d221 1
a221 1
   int multisrc = FALSE, tabin = 0;
d227 1
a227 1
   BPTR outlock = NULL, temp, infh = NULL, outfh = NULL;
d232 8
d350 5
d385 1
a385 1
	 if (multisrc) {
d406 1
d412 1
d602 1
d625 30
d656 1
a656 1
		     if ((outlock = Lock(ap->ap_Info.fib_FileName, ACCESS_READ))
d667 5
a671 2
		     } else if (!opts[OPT_QUIET])
			PutStr("\n");
d913 9
a921 7
	       if((!opts[OPT_NOPRO] && 
               (SetProtection(msgbuf, ap->ap_Info.fib_Protection) 
                                                         != DOSTRUE))   ||
	         (((opts[OPT_CLONE] || opts[OPT_COM]) &&
		         SetComment(msgbuf, ap->ap_Info.fib_Comment) != DOSTRUE)) ||
	         (((opts[OPT_DATES] || opts[OPT_CLONE]) &&
		         SetFileDate(msgbuf, &ap->ap_Info.fib_Date) != DOSTRUE))  ){
d923 2
a924 2
      		  PrintFault(IoErr(), msgbuf);
		        rc = RETURN_WARN;
@


1.13
log
@Switch indentation back to my style.
@
text
@d27 20
d153 1
a153 1
																		                                             perhaps useful          */
d167 1
a167 1
															          * allocated by AllocVec      */
d171 1
d188 1
a188 1
#ifdef MWDEBUG
a199 1
   struct Library *SysBase = (*((struct Library **) 4));
d666 3
a668 9
	       t = (int) ap->ap_Info.fib_FileName;	/* set string for error */
	       if (outlock) {
		  temp = CurrentDir(outlock);
		  if (!(outfh = Open(ap->ap_Info.fib_FileName, MODE_NEWFILE)))
		     res2 = IoErr();
		  CurrentDir(temp);
	       } else {
		  if (!(outfh = Open((char *) opts[OPT_TO], MODE_NEWFILE)))
		     t = (int) opts[OPT_TO];
d670 1
d672 17
a689 10
	       if (outfh) {	/* we got an output file */
		  temp = CurrentDir(ap->ap_Current->an_Lock);
		  if (!(infh = Open(ap->ap_Info.fib_FileName, MODE_OLDFILE))) {
		     res2 = IoErr();
		     inout = FALSE;
		     Close(outfh);
		     outfh = NULL;
		  }
		  CurrentDir(temp);
	       }
d691 1
d696 8
a703 3
		  res2 = NULL;
/*		  rc = RETURN_WARN; */
		  goto Loop;
d716 1
d804 2
a805 2
		     if ((t == (long) &MSG_READ) && ((res2 != ERROR_WRITE_PROTECTED) &&
				       (res2 != ERROR_READ_PROTECTED))) {
d811 6
a816 1
		     goto Loop;
d822 1
d842 11
a852 15
	       rc = RETURN_OK;
	       if (!opts[OPT_NOPRO] && ((SetProtection(msgbuf,
			      ap->ap_Info.fib_Protection)) != DOSTRUE)) {
		  rc = RETURN_WARN;
		  goto FlagSetFail;
	       }
	       if ((opts[OPT_CLONE] || opts[OPT_COM]) &&
		   ((SetComment(msgbuf, ap->ap_Info.fib_Comment)) != DOSTRUE)) {
		  rc = RETURN_WARN;
		  goto FlagSetFail;
	       }
	       if ((opts[OPT_DATES] || opts[OPT_CLONE]) &&
		   ((SetFileDate(msgbuf, &ap->ap_Info.fib_Date)) != DOSTRUE)) {
		  rc = RETURN_WARN;
		  goto FlagSetFail;
a853 4
	     FlagSetFail:
	       if (rc)
		  PrintFault(IoErr(), msgbuf);

a933 6
#ifdef MWDEBUG
      MWReport(NULL, MWR_FULL);
      PutStr("MWTerm");
      MWTerm();
#endif

d957 6
a962 3
#if 0
void aprintf(fmt, args)
char *fmt, *args;
d964 12
a975 6
   struct Library *DOSBase;
   struct Library *SysBase = (*((struct Library **) 4));
   if (DOSBase = OpenLibrary(DOSLIB, DOSVER)) {
      VFPrintf(Output(), fmt, (LONG *) & args);
      CloseLibrary(DOSBase);
   }
a976 2

#endif
@


1.12
log
@copy no longer deletes the destination if the source is unreadable
@
text
@d27 3
d33 1
a33 1
*   
d36 1
a36 1
*   
d39 1
a39 1
 * 
d133 1
a133 1
												                                             perhaps useful          */
d146 2
a147 2
#define  BUF_SAFE             100	   /* To allow for extra memory
										          * allocated by AllocVec      */
d244 1
a244 1
	 rc=RETURN_FAIL;
d292 1
a292 1
         ap->ap_BreakBits = SIGBREAKF_CTRL_C;
d372 3
a374 2
		if( ((res2 = IoErr()) != ERROR_OBJECT_NOT_FOUND) && 
		      (res2 != ERROR_ACTION_NOT_KNOWN)) goto ErrExit;
a533 1

d564 4
a567 5
	       if (CheckSignal(SIGBREAKF_CTRL_C)) {
		  PrintFault(ERROR_BREAK, NULL);
		  goto Done;
	       }

d575 2
a576 1
			   if (!opts[OPT_QUIET])PutStr("\n");
d646 1
a646 1
	       t = (int) ap->ap_Info.fib_FileName; /* set string for error */
a649 1

d651 2
a652 3
		     CurrentDir(temp);
	       }
	       else {
d654 2
a655 2
		     t=(int)opts[OPT_TO];
		     res2 = IoErr();
d775 2
a776 2
		     if ((t==(long)&MSG_READ)&&((res2 != ERROR_WRITE_PROTECTED)&&
			    (res2 != ERROR_READ_PROTECTED ))) {
d780 2
a781 1
		     if (temp)CurrentDir(temp);
d792 2
a793 1
		     if (temp)CurrentDir(temp);
d807 6
a812 6
	       rc=RETURN_OK;
	       if (!opts[OPT_NOPRO] && ((SetProtection(msgbuf, 
			ap->ap_Info.fib_Protection)) != DOSTRUE)) {
	             rc = RETURN_WARN;
		     goto FlagSetFail;
	       	}
d814 3
a816 3
		((SetComment(msgbuf, ap->ap_Info.fib_Comment)) !=DOSTRUE)) {
	             rc = RETURN_WARN;
		     goto FlagSetFail;
d818 8
a825 8
	        if ((opts[OPT_DATES] || opts[OPT_CLONE]) &&
		  ((SetFileDate(msgbuf, &ap->ap_Info.fib_Date)) != DOSTRUE)) {
		    rc = RETURN_WARN;
		    goto FlagSetFail;
		}
		
		FlagSetFail:
		  if(rc)PrintFault(IoErr(), msgbuf);
d827 2
a828 1
	       if (temp)CurrentDir(temp);
d863 1
a863 1
      rc=RETURN_FAIL;
d868 2
a869 2
	res2=0;
	rc=RETURN_OK;
d871 3
a873 3
      if(res2) {
	GetProgramName(msgbuf, MSGBUFSIZE);
        PrintFault(res2, msgbuf);
d917 3
a919 1
   } else {OPENFAIL;}
d937 1
a937 1
void aprintf( fmt, args )
d942 3
a944 3
   if(DOSBase=OpenLibrary(DOSLIB,DOSVER)) {
       VFPrintf(Output(), fmt, (LONG *)&args );
       CloseLibrary(DOSBase);
d947 1
a948 1

@


1.11
log
@fixed control-C out of infinite copy loop.  Though it
probably should detect this error and never get in it.
@
text
@d27 4
d774 2
a775 1
		     if ((t == (long) &MSG_READ) || (res2 != 223)) {
@


1.10
log
@stops on a control-C now
@
text
@d27 3
a331 1

d526 1
d556 5
@


1.9
log
@removed Q as synonym for quiet.
@
text
@d282 1
d717 1
d924 1
a924 2
       VFPrintf(
?put(), fmt, (LONG *)&args );
@


1.8
log
@added currentdir of NULL kludge back
@
text
@d103 1
a103 1
#define TEMPLATE  "FROM/A/M,TO/A,ALL/S,Q=QUIET/S,BUF=BUFFER/K/N,CLONE/S,DATES/S,NOPRO/S,COM/S" CMDREV
@


1.7
log
@no longer gives misleading 'no more entries' error message
@
text
@d101 2
d922 2
a923 1
       VFPrintf( Output(), fmt, (LONG *)&args );
@


1.6
log
@fixed the COPY to par: problem (we hope)
@
text
@d232 2
a233 1
	 goto ErrExit1;		/* <=== Bail out to common error routine       */
d558 1
a558 2
			   if (!opts[OPT_QUIET])
			      PutStr("\n");
d628 1
d632 1
d634 3
a636 2
		  CurrentDir(temp);
	       } else {
d638 1
a652 1
		  t = (int) ap->ap_Info.fib_FileName;
d658 1
a658 1
		  rc = RETURN_WARN;
d762 1
a762 2
		     if (temp)
			CurrentDir(temp);
a768 2
		     rc = RETURN_WARN;

d773 2
a774 3
		     if (temp)
			CurrentDir(temp);
		     goto ErrExit;
d787 6
a792 5

	       if (!opts[OPT_NOPRO] && SetProtection(
			msgbuf, ap->ap_Info.fib_Protection) != DOSTRUE) {
		  goto FlagSetFail;
	       }
d794 3
a796 2
		SetComment(msgbuf, ap->ap_Info.fib_Comment) != DOSTRUE) {
		  goto FlagSetFail;
d798 8
a805 2
	       if ((opts[OPT_DATES] || opts[OPT_CLONE]) &&
		 SetFileDate(msgbuf, &ap->ap_Info.fib_Date) != DOSTRUE) {
d807 1
a807 5
		FlagSetFail:PrintFault(IoErr(), msgbuf);
		  rc = RETURN_WARN;
	       }
	       if (temp)
		  CurrentDir(temp);
a827 1
	       rc = RETURN_ERROR;
d842 2
d845 9
a853 6
    ErrExit1:
      GetProgramName(msgbuf, MSGBUFSIZE);
      PrintFault(res2, msgbuf);
      if (rc == RETURN_OK)
	 rc = RETURN_FAIL;

a891 2
      if (res2)
	 SetIoErr(res2);
d893 2
d896 1
a896 5
   } else {
      OPENFAIL;
      rc = RETURN_FAIL;
   }

d912 14
@


1.5
log
@fixes copy problems...
@
text
@d358 3
a360 3
	    if ((outlock = Lock((char *) opts[OPT_TO], ACCESS_READ)) == NULL &&
		(res2 = IoErr()) != ERROR_OBJECT_NOT_FOUND) {
	       goto ErrExit;
@


1.4
log
@changed flags so copy steps out of directory properly
@
text
@d2 1
a2 1
/* |_o_o|\\ Copyright (c) 1989 The Software Distillery.  All Rights Reserved */
d14 10
a23 10
/*---------------------------------------------------------------------------*/
/* Command: Copy                                                             */
/* Author:  Jay Denebeim                                                     */
/* Change History:                                                           */
/*  Date    Person        Action                                             */
/* -------  ------------- -----------------                                  */
/* 19MAR89  John Toebes   Initial Creation                                   */
/* 25MAR89  Jay Denebeim  Initial Coding                                     */
/* 19OCT89  Jay Denebeim  Rewrite with real DOS 1.4                          */
/*
d27 9
a35 1
 * Revision 36.6  90/03/08  02:06:20  Andy
d41 3
d46 1
a46 1
 * 
d50 1
a50 1
 * 
d80 13
a92 13
/* Notes:                                                                    */
/*                                                                           */
/* This program handles the following cases:                                 */
/*    1) Copy with wildcards                                                 */
/*    2) Copy file -> file                                                   */
/*    3) Copy file -> directory                                              */
/*    4) Copy directory -> directory                                         */
/*                                                                           */
/* In an attempt to make the program as small as possible, I have used       */
/* gotos and other nasty tricks.  Sorry about that, but hopefully there      */
/* are enough comments to enable the code to remain clear                    */
/*                                                                           */
/*---------------------------------------------------------------------------*/
d113 2
a114 2
/***********************************************************************/
/*                        Messages used by this program                */
d120 2
a121 2
#define  MSG_TABIN            "        "  /* not strictly needed, but
                                             perhaps useful          */
d134 3
a136 3
#define  BUF_SAFE             100   /* To allow for extra memory
                                       allocated by AllocVec      */
#define  MIN_BUF              0x1000   /* 4K minimum buffer size  */
d138 1
a138 1
void  Tab( int tabstops, struct DosLibrary *DOSBase );
d140 14
a153 14
/***********************************************************************/
/*                                                                     */
/*    Copy program mainline.                                           */
/*                                                                     */
/* This routine is fairly optomized.  Since most of the code is error  */
/* handling, I've used GOTOs to collect the common areas.  It should   */
/* be clear anyway, in most cases clearer than it was before I         */
/* commonized the code sequences.  Its definately much smaller, and    */
/* has the advantage of putting all common error code in one place so  */
/* only one place needs changing if it needs modification.             */
/*                                                                     */
/* NOTE: This MUST be the first routine in the module                  */
/*                                                                     */
/***********************************************************************/
d161 1
d166 12
a177 11
struct DosLibrary    *DOSBase;
int                  multisrc = FALSE, tabin = 0;
int 		     cont, firsttime,inout;
struct RDargs        *rdargs = NULL;
char                 *msgbuf=NULL, *buf=NULL, *curarg, **argptr;
long                 rc=RETURN_OK, res2 = 0, opts[OPT_COUNT];
long		     bufsize, t=0, bs, nolock=0;
BPTR                 outlock = NULL, temp, infh = NULL, outfh = NULL;
struct FileInfoBlock *fib= NULL;
APTR                 windptr = (void *)-1;
struct AnchorPath    *ap = NULL;
d179 3
a181 1
if ((DOSBase = (struct DosLibrary *)OpenLibrary(DOSNAME, DOSVER))) {
d183 1
a183 4
   if(!(THISPROC->pr_CurrentDir)) {
      THISPROC->pr_CurrentDir = Lock("SYS:", ACCESS_READ);
      nolock = TRUE;
   }
d185 6
a190 6
/***********************************************************************/
/*                                                                     */
/* Initialization section.  Allocate memory, initialize variables,     */
/*    etc.                                                             */
/*                                                                     */
/***********************************************************************/
d193 2
a194 2
   MWInit( NULL, 0 );
   MWReport( NULL, MWR_FULL );
d197 10
a206 4
   if( CheckSignal( SIGBREAKF_CTRL_C ) ){
      PrintFault(ERROR_BREAK,NULL);
      goto Done;
   }
d208 7
a214 7
/***********************************************************************/
/*                                                                     */
/*    A common error routine lives near the bottom of this routine     */
/*    it is called ErrExit, and is where most fatal error cases end    */
/*    up.  It is gotten to with a goto rather than being a subroutine  */
/*                                                                     */
/***********************************************************************/
d216 1
a216 1
   if((msgbuf = AllocVec(MSGBUFSIZE,NULL)) == NULL                         ||
d218 1
a218 1
      (ap = AllocVec(sizeof(struct AnchorPath)+256, MEMF_CLEAR)) == NULL   ||
d220 1
a220 1
      (fib = AllocVec(sizeof(struct FileInfoBlock),MEMF_PUBLIC)) == NULL   ){
d222 2
a223 2
      res2 = ERROR_NO_FREE_STORE;
      PrintFault(ERROR_NO_FREE_STORE, NULL);
d225 4
a228 2
      goto Done;
   }
d230 4
a233 2
   memset( (char *)opts, 0, sizeof(opts));
   rdargs = ReadArgs(TEMPLATE, opts, NULL);
d235 29
a263 5
   if (rdargs == NULL) {
      res2 = IoErr();
      goto ErrExit1;     /* <=== Bail out to common error routine       */
   }
   else {
d265 4
a268 29
/***********************************************************************/
/*                                                                     */
/* We've got a good set of parameters.  Now we need to figure out the  */
/*    environment we're operating in.  The original BCPL copy routine  */
/*    had several special cases, each of which had a different output  */
/*    to the user.  Rather than duplicating the output, and having     */
/*    several special routines for each flavor of copy, this version   */
/*    is written to handle them all with one routine.                  */
/*                                                                     */
/* Here's a list of the possible variations to the input.  Originally  */
/*    multiargs were not supported, I will talk more about that later. */
/*                                                                     */
/*    1) One file to another file   - No output                        */
/*    2) One file to a directory    - No output                        */
/*          The difference of the two above are distinguished by the   */
/*          existance of the destination.  Its a file copy if the      */
/*          destination is a file, or does not exist, it is a copy     */
/*          to directory if it is a directory.                         */
/*    3) Directory to directory     - Prints each file                 */
/*    4) Wildcard to directory      - Prints each file                 */
/*    5) All parameter              - Prints each file                 */
/*                                                                     */
/* Delete printed nothing if multiple single files were given.  I      */
/* never liked that, I think whenever there are multiple things to do  */
/* some feedback needs to be given to the user.  This version of Copy  */
/* reflects that.  It always prints the file being worked on if there  */
/* is more than one file requested.                                    */
/*                                                                     */
/***********************************************************************/
d270 7
a276 4
/***********************************************************************/
/* If the user doesn't want requesters put on the screen, turn off     */
/* requesters for this process                                         */
/***********************************************************************/
d278 2
a279 4
      if( opts[OPT_QUIET] ){
         windptr = THISPROC->pr_WindowPtr;
         THISPROC->pr_WindowPtr = (APTR)-1;
      }
d281 1
a281 3
/***********************************************************************/
/* We always may step into directories, so set the flag                */
/***********************************************************************/
d283 12
a294 2
      ap->ap_Flags  = APF_DOWILD;
      ap->ap_Strlen = 256;
d296 3
a298 1
      argptr = (char **)opts[OPT_FROM];
d300 1
a300 4
      if( MatchFirst(*argptr, ap) ){
         res2 = IoErr();
         goto ErrExit;
      }
d302 8
a309 8
/***********************************************************************/
/*                                                                     */
/* If the first parameter is wild, or is a directory, or there are     */
/* more than one input files, then this program goes into 'multisrc'   */
/* mode.  This means the output must be a directory, and files will    */
/* be printed as output.                                               */
/*                                                                     */
/***********************************************************************/
d311 7
a317 3
      if(((ap->ap_Flags & APF_ITSWILD) != 0) ||
         (ap->ap_Info.fib_DirEntryType > 0) ||
         (argptr[1] != NULL)) {
d319 6
a324 1
         multisrc = TRUE;
d326 1
a326 8
/***********************************************************************/
/*                                                                     */
/* If the input parameter is not wild, and it is a directory, then     */
/* step into it.  Later code is not aware that we've steped into the   */
/* directory, so we have to be careful about not taking what           */
/* MatchFirst/Next as gosphal.                                         */
/*                                                                     */
/***********************************************************************/
d328 21
a348 6
         if( (ap->ap_Flags & APF_ITSWILD) == 0      &&
             (ap->ap_Info.fib_DirEntryType > 0)    ){
             ap->ap_Flags |= APF_DODIR;
             MatchNext(ap);
         }
      }
d350 7
a356 1
      if( multisrc ) {
d358 16
a373 6
/***********************************************************************/
/*                                                                     */
/* Output MUST be a directory.  If it doesn't exist, create it.        */
/* If its not a directory, abort program.                              */
/*                                                                     */
/***********************************************************************/
d375 15
a389 1
         if( (outlock = Lock( (char *)opts[OPT_TO], SHARED_LOCK )) ){
d391 2
a392 25
            if( Examine( outlock, fib ) ){
               if( fib->fib_DirEntryType < 0 ){
                  PutStr( MSG_DEST_WRONG_DIR );
                  res2 = 0;
/*                  SetIoErr(0); */
                  rc = RETURN_ERROR;
                  goto Done;
               }
            }
	    else { 
               res2 = IoErr();
               goto ErrExit;
            }
         }
	 else {
            if(( outlock = CreateDir( (char *)opts[OPT_TO] )) == NULL){
               res2 = IoErr();
               goto ErrExit;
            }
            if(!opts[OPT_QUIET]){
               VPrintf("   %s"MSG_DIR_CREATE, &opts[OPT_TO]);
            }
         }
      }
      else {
d394 7
a400 7
/***********************************************************************/
/*                                                                     */
/* Not multiple source files, doesn't have to be a directory.          */
/* If its not a directory, unlock outlock.  Outlock is a lock on the   */
/* parent directory of the output file, not the output file itself.    */
/*                                                                     */
/***********************************************************************/
d402 3
a404 17
         if((outlock = Lock( (char *)opts[OPT_TO], ACCESS_READ))== NULL &&
          (res2 = IoErr()) != ERROR_OBJECT_NOT_FOUND ) {
            goto ErrExit;
         }
         if(outlock){
            if(Examine(outlock, fib)){
               if(fib->fib_DirEntryType < 0){
                  UnLock(outlock);
                  outlock = NULL;
               }
            }
	    else {
               res2 = IoErr();
               goto ErrExit;
            }
         }
      }
d406 3
a408 15
/***********************************************************************/
/*                                                                     */
/* At this point, the following things are true:                       */
/*                                                                     */
/*          1) if dest is a dir we got a lock on it                    */
/*          2) if dest isn't a dir we don't                            */
/*          3) we know if the input is wild, or multiargs              */
/*          4) we should have a anchor on the first input file         */
/*                                                                     */
/*       we still need to:                                             */
/*                                                                     */
/*          1) allocate buffers                                        */
/*          2) turn off requesters if asked                            */
/*                                                                     */
/***********************************************************************/
d410 2
a411 2
      if( opts[OPT_BUFS] ){
         bufsize = *(long *)opts[OPT_BUFS];
d413 4
a416 6
         if(bufsize < 0) bufsize = 200;
/***********************************************************************/
/* Doesn't make much sense to ask for negative buffers.  If the user   */
/* did, just quietly set the size to the default. 0 buffers is a       */
/* special case.  I'll go more into that when the code comes up        */
/***********************************************************************/
d418 10
a427 20
      }
      else bufsize = 200;
      bufsize *= 0x200;

/***********************************************************************/
/* If positive bufsize, allocate the buffer.                           */
/***********************************************************************/

      if( bufsize ) {
         if(( buf = AllocVec( bufsize, 0 )) == NULL ) {

/***********************************************************************/
/* If there is not enough memory for the buffer, take the largest      */
/* available. If that doesn't work abort the program.                  */
/***********************************************************************/

            Forbid();      /* so someone doesn't steal memory from us */
            bufsize = AvailMem( MEMF_LARGEST ) - BUF_SAFE;
	    if(bufsize > MIN_BUF) {
            	buf = AllocVec( bufsize, 0 );
d429 9
a437 7
            Permit();
            if( buf == NULL ) {
	        res2 = ERROR_NO_FREE_STORE;
		goto ErrExit;  
	    }
         }
      }
d439 1
a439 8
/***********************************************************************/
/*                                                                     */
/*    And now the moment we've all been waiting for.  The main loop of */
/*    this program.  The environment is set up, all the memory is      */
/*    allocated, its dark out, and we've got our sun glasses on.       */
/*    Let's rock.                                                      */
/*                                                                     */
/***********************************************************************/
d441 3
a443 2
      firsttime = TRUE;
/*      MatchEnd(ap); /* remember, we looked before */
d445 4
a448 3
/***********************************************************************/
/* Step over multiargs                                                 */
/***********************************************************************/
d450 5
a454 3
      while( curarg = *argptr++ ) {
         if(firsttime) firsttime = FALSE;
	 else {
d456 9
a464 14
/***********************************************************************/
/* Unless its the first time through the loop, do a little             */
/* initialization.  Make sure the file exists.  If the file is a dir   */
/* and is not wild, step into it.                                      */
/***********************************************************************/

	    if(	MatchFirst(curarg, ap) ){
               res2 = IoErr();
	       goto ErrExit;
            }
            if((ap->ap_Flags & APF_ITSWILD) == 0   &&
               (ap->ap_Info.fib_DirEntryType > 0)) {
               ap->ap_Flags |= APF_DODIR;
               MatchNext(ap);
a465 1
         }
d467 7
a473 7
/***********************************************************************/
/*                                                                     */
/* Main copy loop, each argument gets copied here, one pass is made    */
/* through the loop for simple file to file copies, several times      */
/* through for wildcards or directories.                               */
/*                                                                     */
/***********************************************************************/
d475 1
a475 1
         do {
d477 14
a490 14
/***********************************************************************/
/*                                                                     */
/* Using MatchFirst/Next stepping into directories list the directory  */
/* twice.  Once going in, and another time going out.  This is handy   */
/* because some programs, like delete are concerned with exiting the   */
/* the directory, others like this one want to know when a directory   */
/* is entered.                                                         */
/*                                                                     */
/* The following code takes care of walking back up the directory tree */
/* its at the beginning of the do loop rather than the end because we  */
/* need to ignore the second time the entry is hit, other than         */
/* popping out.                                                        */
/*                                                                     */
/***********************************************************************/
d492 7
a498 7
            while( ap->ap_Flags & APF_DIDDIR ) {
               tabin--;
               temp = outlock;
               outlock = ParentDir( outlock );
               UnLock( temp );
               /* tell Anchor to step out */
               ap->ap_Flags &= ~APF_DIDDIR;
d500 10
a509 10
/***********************************************************************/
/*                                                                     */
/* tabin in the following if statement is somewhat subtle.  Recall if  */
/* we're copying a directory, we do a DODIR, but don't create the      */
/* directory and step in.  MatchNext under that circumstance would     */
/* pass to this routine the original directory at the very end of the  */
/* copy.  We use the tabin variable to indicate this has occured, and  */
/* exit the loop even though MatchNext doesn't tell us to do this      */
/*                                                                     */
/***********************************************************************/
d511 4
a514 4
               if((cont = MatchNext(ap)) || (tabin < 0)) {
                  goto  ExitLoop;   /* Pardon the goto, trying for small */
               }
            }
d516 14
a529 4
            if( CheckSignal( SIGBREAKF_CTRL_C ) ){
               PrintFault(ERROR_BREAK,NULL);
               goto Done;
            }
d531 18
a548 10
/***********************************************************************/
/*                                                                     */
/* The following loop is the trickiest code in the program.  Its       */
/* purpose is to keep evaluating until we get to a file.  If the all   */
/* option isn't set, it will just go to the main copy loop.  If it is  */
/* this routine will keep creating directories and walking the dir     */
/* structure until a file is found.  In the event an empty directory   */
/* is found, it will drop back a directory, and continue the copy.     */
/*                                                                     */
/***********************************************************************/
d550 14
a563 6
            while(ap->ap_Info.fib_DirEntryType > 0){
               if(!opts[OPT_QUIET]){
                  Tab(tabin+1, DOSBase);
                  t = (LONG)ap->ap_Info.fib_FileName;
                  VPrintf( MSG_DIR, &t );
               }
d565 4
a568 12
               if(opts[OPT_ALL]){
/***********************************************************************/
/*                                                                     */
/* The previous line of code has already confused two people, myself,  */
/* and the person who do the walkthrough of the program.  We are       */
/* guaranteed to be multisource here because multisource is set if     */
/* we're copying a directory, or if there's a wildcard.  If we find    */
/* a directory under those circumstances, if ALL is set, we create     */
/* and lock the directory, if all is not set, we just print that we've */
/* hit the directory, and go to the next file.                         */
/*                                                                     */
/***********************************************************************/
d570 8
a577 12
                  temp = CurrentDir(outlock);
                  if((outlock = Lock(ap->ap_Info.fib_FileName, ACCESS_READ))
                                                                  == NULL ){
                     if((outlock = CreateDir(ap->ap_Info.fib_FileName))
                   						== NULL ){
                        res2 = IoErr();
                        outlock = CurrentDir(temp);
                        if(!opts[OPT_QUIET]) PutStr("\n");
                        goto ErrExit;
                     }else if(!opts[OPT_QUIET]) PutStr(MSG_DIR_CREATE);
                  }
		  else if(!opts[OPT_QUIET]) PutStr("\n");
d579 4
a582 5
                  tabin++;
                  temp = CurrentDir(temp);
                  UnLock(temp);             /* release parent lock */
               }
	       else {
d584 4
a587 8
/***********************************************************************/
/*                                                                     */
/* This means we've hit a directory without option all set.  It will   */
/* only happen the first time through the while loop.  Since we're     */
/* not copying directories at this point, skip this dir and go to      */
/* the next file. (branches to the main copy loop)                     */
/*                                                                     */
/***********************************************************************/
d589 2
a590 3
                  if(!opts[OPT_QUIET]) PutStr("\n");
                  goto Loop;
               }
d592 1
a592 4
/***********************************************************************/
/* Okay, we've found a directory, and know we want to copy it, so now  */
/* Let's step into the directory.                                      */
/***********************************************************************/
d594 6
a599 2
               ap->ap_Flags |= APF_DODIR;
               MatchNext(ap);
d601 8
a608 1
               if( ap->ap_Flags & APF_DIDDIR ){
d610 16
a625 6
/***********************************************************************/
/* This means there's an empty directory, we've already created it,    */
/* but oh, well.. What should occur at this point, is we go to the     */
/* file in the parent directory following this directory without       */
/* copying                                                             */
/***********************************************************************/
d627 10
a636 8
                  tabin--;
                  temp = outlock;
                  outlock = ParentDir( outlock );
                  UnLock( temp );
                  ap->ap_Flags &= ~APF_DIDDIR; /* tell Anchor to step out */
                  goto Loop;
               }
            }
d638 26
a663 16
/***********************************************************************/
/*                                                                     */
/* Okay, here's the condition we're currently in...  We're pointing    */
/* to something that must be a file with the anchor, if we're copying  */
/* a file, outlock is NULL, otherwise outlock is a lock on the parent  */
/* directory of the soon-to-be file.                                   */
/*                                                                     */
/* Its now time to open the files.  Output file first, then input file */
/* Currently, if the open doesn't work, the whole program aborts, by   */
/* changing the common failure code, it would be easy to just loop     */
/* instead.                                                            */
/*                                                                     */
/* Quite a few bytes of code are saved by having common error handling */
/* for all three of the open statements.                               */
/*                                                                     */
/***********************************************************************/
d665 20
a684 10
            inout = TRUE;
            if( outlock ) {
               temp = CurrentDir( outlock );
               if(!(outfh=Open(ap->ap_Info.fib_FileName,MODE_NEWFILE)))
                  res2 = IoErr();
               CurrentDir(temp);
            }
	    else {
               if(!(outfh=Open((char *)opts[OPT_TO],MODE_NEWFILE)))res2=IoErr();
            }
d686 16
a701 10
	    if (outfh) { /* we got an output file */
                temp = CurrentDir(ap->ap_Current->an_Lock);
                if(!(infh = Open(ap->ap_Info.fib_FileName,MODE_OLDFILE))) {
                    res2 = IoErr();
                    inout = FALSE;
                    Close(outfh);
                    outfh = NULL;
		}
                CurrentDir(temp);
	    }
d703 4
a706 10
            if(!outfh || !infh) {
                   t = (int)ap->ap_Info.fib_FileName;
                   VPrintf( MSG_NOOPEN, &t);
                   t = (int)((inout) ? &MSG_OUT : &MSG_IN);
                   VPrintf( MSG_INOUT, &t );
                   PrintFault( res2, NULL );
                   res2 = NULL;
                   rc = RETURN_WARN;
                   goto Loop;
	    }
d708 4
a711 41
/***********************************************************************/
/*                                                                     */
/* Hokay, now we've got both files open the input file is examined     */
/* into fib, so we print the name and copy the file.                   */
/*                                                                     */
/***********************************************************************/

            if( multisrc && !opts[OPT_QUIET]){
               Tab(tabin, DOSBase);
               t = (LONG)ap->ap_Info.fib_FileName;
               VPrintf( "   %s..", &t );
            }

/***********************************************************************/
/*                                                                     */
/* Here is the promised new feature.  If BUFSIZE = 0 memory is         */
/* allocated and deleted for each file.  The buffer ends up being      */
/* exactly the right size for the file.  This gives the fast fileing   */
/* system the exact size of the file, hopefully it will find a space   */
/* on the disk the right size and will put the file contigious on the  */
/* disk.  This of course is a big win when it comes to running the     */
/* program, it will load a program stored on contigious sectors with   */
/* one file request, thereby loading even big programs very fast.      */
/*                                                                     */
/* I stole this idea from an early copy program for the amiga called   */
/* xcopy.                                                              */
/*                                                                     */
/***********************************************************************/

	    if( bufsize == 0 ) {
               bs = ap->ap_Info.fib_Size;
               if(( buf = AllocVec( bs, 0 )) == NULL ) {
            	  Forbid();      /* so someone doesn't steal memory from us */
            	  bs = AvailMem( MEMF_LARGEST ) - BUF_SAFE;
	    	  if(bs > MIN_BUF) {
            	       buf = AllocVec( bs, 0 );
	          }
                  Permit();
                  if( buf == NULL ) {
	          res2 = ERROR_NO_FREE_STORE;
		  goto ErrExit;  
d713 4
d718 6
a723 2
	    }
	    else bs = bufsize;
d725 5
a729 3
/***********************************************************************/
/* Here's the Copy (finally) lotta work for such a short thing, eh???  */
/***********************************************************************/
d731 2
a732 1
            while((t = Read(infh, buf, bs)) > 0){
d734 7
a740 5
               if(CheckSignal(SIGBREAKF_CTRL_C)){
                  t = 1;
                  PrintFault(ERROR_BREAK,NULL);
                  break;
               }
d742 1
a742 10
               if(Write(outfh, buf, t) != t){
                  t = 1;
                  break;
               }
            }
/***********************************************************************/
/* Collect the error reason (if any)                                   */
/* T is non-zero if any error occured                                  */
/***********************************************************************/
            if( t != 0 )res2 = IoErr();
d744 1
a744 5
/***********************************************************************/
/* Get all the files closed before processing any error.               */
/***********************************************************************/
            Close( outfh );
            outfh = NULL;
d746 4
a749 2
            Close( infh );
            infh = NULL;
d751 12
a762 8
            if(outlock){
               temp = CurrentDir( outlock );
               strcpy( msgbuf, ap->ap_Info.fib_FileName );
            }
	    else {
               temp = NULL;
               strcpy( msgbuf, (char *)opts[OPT_TO] );
            }
d764 4
a767 1
            if(t) {
d769 1
a769 1
               if(res2){
d771 1
a771 4
/***********************************************************************/
/* if res2 must have been some error, read returns < 0 if error.       */
/* Write is set above                                                  */
/***********************************************************************/
d773 3
a775 7
                  t = (int)((t<0) ? &MSG_READ : &MSG_WRITE);
                  VPrintf( MSG_IOERROR, &t );
                  PrintFault( res2, NULL );
                  rc = RETURN_ERROR;
		  if((t == (long)&MSG_READ) || (res2 != 223)) {
                      VPrintf( MSG_DELETED, (int *)&msgbuf );
                      DeleteFile(msgbuf);
d777 7
a783 4
                  if(temp) CurrentDir(temp);
                  goto Loop;
               }
	       else {
d785 3
a787 4
/***********************************************************************/
/* musta hit ^C in the loop                                            */
/***********************************************************************/
                  rc = RETURN_WARN;
d789 10
a798 1
                  VPrintf( MSG_DELETED, (int *)&msgbuf );
d800 5
a804 1
                  DeleteFile(msgbuf);
d806 7
a812 4
                  if(temp) CurrentDir(temp);
                  goto ErrExit;
               }
            }
d814 7
a820 4
            if(bufsize == 0){
               FreeVec( buf );
               buf = NULL;
            }
d822 7
a828 43
            if(multisrc && !opts[OPT_QUIET]) PutStr( MSG_COPIED );

/***********************************************************************/
/* Set protection bits, dates, and comment if applicable               */
/***********************************************************************/

            if( !opts[OPT_NOPRO] && SetProtection(
		msgbuf, ap->ap_Info.fib_Protection) != DOSTRUE) {
               goto FlagSetFail;
            }
            if((opts[OPT_CLONE] || opts[OPT_COM]) &&
               SetComment(msgbuf, ap->ap_Info.fib_Comment) != DOSTRUE) {
               goto FlagSetFail;
            }
            if((opts[OPT_DATES] || opts[OPT_CLONE]) &&
               SetFileDate(msgbuf, &ap->ap_Info.fib_Date) != DOSTRUE) {

FlagSetFail:   PrintFault( IoErr(), msgbuf );
               rc = RETURN_WARN;
            }
            if(temp) CurrentDir(temp);

/***********************************************************************/
/*                                                                     */
/* End of main copy loop.  Find next file to copy (if any)             */
/*                                                                     */
/***********************************************************************/
Loop:;
         } while((cont = MatchNext(ap)) == NULL);

/***********************************************************************/
/*                                                                     */
/* Error handling while in main copy loop.  When fatal errors occur in */
/* the loop control is passed to here.  Also, if MatchNext at the end  */
/* of the loop fails we execute this code.                             */
/*                                                                     */
/***********************************************************************/

ExitLoop:
         if(cont != ERROR_NO_MORE_ENTRIES && cont != NULL){
            res2 = IoErr();
            rc = RETURN_ERROR;
            goto ErrExit;
a829 1
      MatchEnd(ap);
d831 1
a831 2
   }
goto Done;
d833 5
a837 5
/***********************************************************************/
/*                                                                     */
/* main error code.  Fatal errors end up here generally.               */
/*                                                                     */
/***********************************************************************/
d839 1
a839 1
ErrExit:
d841 1
a841 1
ErrExit1:
d844 2
a845 1
      if (rc == RETURN_OK) rc = RETURN_FAIL;
d847 3
a849 3
/***********************************************************************/
/* Clean up from whatever state we were in                             */
/***********************************************************************/
d851 17
a867 14
Done:
   if(msgbuf)  FreeVec(msgbuf);
   if(ap)      FreeVec(ap);
   if(buf)     FreeVec(buf);
   if(rdargs)  FreeArgs( rdargs );
   if(infh)    Close(infh);
   if(outfh)   Close(outfh);
   if(outlock) UnLock(outlock);
   if(fib)     FreeVec(fib);
   if(windptr != (void *)-1)THISPROC->pr_WindowPtr = windptr;
   if(nolock){
      UnLock(THISPROC->pr_CurrentDir);
      THISPROC->pr_CurrentDir = NULL;
   }
d869 10
d880 3
a882 3
   MWReport( NULL, MWR_FULL );
PutStr("MWTerm");
   MWTerm();
a883 8
   
   if(res2) SetIoErr( res2 );
   CloseLibrary((struct Library *)DOSBase);
}
else {
   OPENFAIL;
   rc = RETURN_FAIL;
}
d885 10
a894 1
return(rc);
d897 6
a902 6
/***********************************************************************/
/*                                                                     */
/* void  Tab( int, *dosbase ) : Prints 8 spaces for each tab stop      */
/*                              specified.                             */
/***********************************************************************/
void  Tab( int tabstops, struct DosLibrary *DOSBase )
d904 3
a906 3
   int   i;
   for( i = 0; i<tabstops; i++ ){
      PutStr( MSG_TABIN );
@


1.3
log
@general cleanup, gets initial lock if null, fewer gotos,
doesn't delete write protected file
@
text
@d282 3
a284 3
      if(((ap->ap_Flags & APF_ITSWILD) != 0)       ||
         (ap->ap_Info.fib_DirEntryType >= 0)       ||
         (argptr[1] != NULL)                       ){
d297 4
a300 4
         if((ap->ap_Flags & APF_ITSWILD) == 0      &&
            (ap->ap_Info.fib_DirEntryType >= 0)    ){
            ap->ap_Flags |= APF_DODIR;
            MatchNext(ap);
d304 1
a304 1
      if( multisrc ){
d319 1
a319 1
                  SetIoErr(0);
d432 1
d448 1
a448 1
            if( MatchFirst(curarg, ap) ){
d450 1
a450 1
               goto ErrExit;
d453 1
a453 1
               (ap->ap_Info.fib_DirEntryType >= 0) ){
d456 1
a456 1
            }
a484 1

d503 1
a503 1
               if((cont = MatchNext(ap)) != NULL || tabin < 0) {
d524 1
a524 1
            while(ap->ap_Info.fib_DirEntryType >= 0){
d548 1
a548 1
                                                                  == NULL ){
d582 1
a583 1
               MatchNext(ap);  /* this assumes stepping in comes free */
d597 1
a597 1
                  /* tell Anchor to step out (comes free ?) */
d824 1
a824 1
	MatchEnd(ap);	
@


1.2
log
@removed double permit
@
text
@d27 6
a32 3
 * Revision 1.1  90/03/01  19:24:26  andy
 * Initial revision
 * 
d118 1
a118 1
#define  MSG_WRITE            "write"
d155 2
a156 1
int                  multisrc = FALSE, tabin = 0, cont, firsttime, inout;
d159 3
a161 3
long                 rc, res2 = 0, opts[OPT_COUNT], bufsize, t, bs;
BPTR                 outlock = NULL, temp,
                     infh = NULL, outfh = NULL;
d166 1
a166 3
rc = RETURN_OK;
if ((DOSBase = (struct DosLibrary *)OpenLibrary(DOSNAME, DOSVER)))
{
d168 5
d213 1
a213 2
   if (rdargs == NULL)
   {
d215 3
a217 2
      goto ErrExit;     /* <=== Bail out to common error routine       */
   }else{
d323 2
a324 1
            }else{
a325 1
               MatchEnd(ap);
d328 2
a329 1
         }else{
a331 1
               MatchEnd(ap);
d338 2
a339 1
      }else{
d349 2
a350 3
         if((outlock = Lock( (char *)opts[OPT_TO], ACCESS_READ)) == NULL   &&
          (res2 = IoErr()) != ERROR_OBJECT_NOT_FOUND                       ){
            MatchEnd(ap);
d359 2
a360 1
            }else{
a361 1
               MatchEnd(ap);
a392 2
      }else{
         bufsize = 200;
d394 1
d401 2
a402 2
      if( bufsize ){
         if(( buf = AllocVec( bufsize, 0 )) == NULL ){
d411 3
a413 5
            if( bufsize <= MIN_BUF ){
               Permit();
               goto MemAbort1;
            }
            buf = AllocVec( bufsize, 0 );
d415 4
a418 5
            if( buf == NULL ){
MemAbort1:     res2 = ERROR_NO_FREE_STORE;
               MatchEnd(ap);
               goto ErrExit;
            }
d437 3
a439 1
      while( curarg = *argptr++ ){
a440 4
         if(firsttime){
            firsttime = FALSE;
         }else{

a448 1
               MatchEnd(ap);
d466 1
a466 1
         do{
d483 1
a483 1
            while( ap->ap_Flags & APF_DIDDIR ){
d503 1
a503 1
               if((cont = MatchNext(ap)) != NULL || tabin < 0){
a551 1
                        MatchEnd(ap);
d553 1
a553 5
                     }else{
                        if(!opts[OPT_QUIET]) PutStr(MSG_DIR_CREATE);
                     }
                  }else{
                     if(!opts[OPT_QUIET]) PutStr("\n");
d555 2
d560 2
a561 1
               }else{
d619 2
a620 2
            if( outlock ){
               inout = TRUE;
d622 1
a622 2
               if((outfh = Open( ap->ap_Info.fib_FileName, MODE_NEWFILE))
                                                                  == NULL){
d624 1
a624 9
                  CurrentDir( temp );
                  goto NoOpen;
               }
               CurrentDir( temp );
            }else{
               if((outfh = Open((char *)opts[OPT_TO],MODE_NEWFILE)) == NULL){
                  res2 = IoErr();
                  goto NoOpen;
               }
d626 3
d630 10
a639 7
            temp = CurrentDir(ap->ap_Current->an_Lock);
            if((infh = Open(ap->ap_Info.fib_FileName,MODE_OLDFILE)) == NULL){
               res2 = IoErr();
               CurrentDir(temp);
               inout = FALSE;
               Close(outfh);
               outfh = NULL;
d641 10
a650 12
NoOpen:                                      /* yeah, I know, gross, but
                                                saves a few bytes.      */
               t = (int)ap->ap_Info.fib_FileName;
               VPrintf( MSG_NOOPEN, &t);
               t = (int)((inout) ? &MSG_OUT : &MSG_IN);
               VPrintf( MSG_INOUT, &t );
               PrintFault( res2, NULL );
               res2 = NULL;
               rc = RETURN_WARN;
               goto Loop;
            }
            CurrentDir(temp);
d681 1
a681 1
            if( bufsize == 0 ){
d683 6
a688 9
               if(( buf = AllocVec( bs, 0 )) == NULL ){
                  /* so someone doesn't steal memory from us */
                  Forbid();
                  bs = AvailMem( MEMF_LARGEST ) - BUF_SAFE;
                  if( bufsize <= MIN_BUF ){
                     Permit();
                     goto MemAbort2;
                  }
                  buf = AllocVec( bs, 0 );
d690 7
a696 9
                  if( buf == NULL ){
MemAbort2:           res2 = ERROR_NO_FREE_STORE;
                     MatchEnd(ap);
                     goto ErrExit;
                  }
               }
            }else{
               bs = bufsize;
            }
d719 1
a719 1
            if( t != 0 )   res2 = IoErr();
d733 2
a734 1
            }else{
d739 1
a739 1
            if(t != 0){
d752 4
a755 4

                  VPrintf( MSG_DELETED, (int *)&msgbuf );
                  DeleteFile(msgbuf);

d758 3
a760 1
               }else{
d767 1
a770 1
                  MatchEnd(ap);
d786 2
a787 3
            if( opts[OPT_NOPRO] == 0 &&
                SetProtection(msgbuf, ap->ap_Info.fib_Protection) !=
                                                         DOSTRUE){
d791 1
a791 2
               SetComment(msgbuf, ap->ap_Info.fib_Comment) !=
                                                            DOSTRUE){
d795 1
a795 2
               SetFileDate(msgbuf, &ap->ap_Info.fib_Date) !=
                                                         DOSTRUE){
d808 1
a808 1
         }while((cont = MatchNext(ap)) == NULL);
d823 2
a824 2
         }
         MatchEnd( ap );
d836 2
a841 1
Done:
d846 1
d848 1
a848 3
   if(ap){
      FreeVec(ap);
   }
d855 4
a858 3

   if(windptr != (void *)-1) {
      THISPROC->pr_WindowPtr = windptr;
a867 1
   
d870 1
a870 2
else
{
a889 1

@


1.1
log
@that second permit was a killer.  it always did 2 permits,
which unprotected a bunch of stuff
@
text
@d10 3
a12 3
/**	(C) Copyright 1989 Commodore-Amiga, Inc.
 **	    All Rights Reserved
**/
d25 1
a25 1
 *    
d27 20
a46 3
*   Revision 1.0  90/01/22  19:28:12  andy
*   added to rcs
*   
d51 1
a51 1
 * 
d55 1
a55 1
 * 
d59 1
a59 1
 * 
d62 1
a62 1
 * 
d65 1
a65 1
 * 
d83 4
d106 1
a106 1
#define  MSG_TABIN            "        "  /* not strictly needed, but 
d120 1
a120 1
#define  BUF_SAFE             20    /* To allow for extra memory 
d122 1
d141 8
d156 1
a156 1
BPTR                 outlock = NULL, temp, 
d159 1
a159 1
APTR                 windptr = NULL;
d173 5
d182 1
a182 1
   
d192 1
a192 1
            
d194 1
a194 1
                                               
d199 1
a199 1
      
d202 1
a202 1
      
d205 1
a205 1
      
d211 1
a211 1
      
d243 10
d258 1
a258 1
      
d260 1
a260 1
      
d265 1
a265 1
      
d278 1
a278 1
         
d296 1
a296 1
      
d305 1
a305 1
         
d307 1
a307 1
               
d318 1
d324 1
d332 1
a332 1
         
d343 1
d354 1
d359 1
a359 1
      
d375 1
a375 1
    
d390 1
a390 1
      
d405 4
d412 2
a413 1
               res2 = ERROR_NO_FREE_STORE;
a417 5
      
/***********************************************************************/
/* If the user doesn't want requesters put on the screen, turn off     */
/* requesters for this process                                         */
/***********************************************************************/
a418 5
      if( opts[OPT_QUIET] ){
         windptr = THISPROC->pr_WindowPtr;
         THISPROC->pr_WindowPtr = (APTR)-1;
      }
      
d429 1
a429 1
      
d435 1
a435 1
         
d448 1
d457 1
a457 1
            
d484 1
a484 1
                     
d488 1
a488 1
               UnLock( temp );   
d491 1
a491 1
               
d507 1
a507 1
         
d512 1
a512 1
            
d545 1
a545 1
                  if((outlock = Lock(ap->ap_Info.fib_FileName, ACCESS_READ)) 
d547 1
a547 1
                     if((outlock = CreateDir(ap->ap_Info.fib_FileName)) 
d551 2
a552 1
                        PutStr("\n");
d564 1
a564 1
                     
d577 1
a577 1
                  
d584 1
a584 1
                  
d587 1
a587 1
                     
d594 1
a594 1
                        
d624 1
a624 1
               if((outfh = Open( ap->ap_Info.fib_FileName, MODE_NEWFILE)) 
d637 1
a637 1
            
d643 2
d646 1
a646 1
NoOpen:                                      /* yeah, I know, gross, but 
d665 1
a665 1
            
d671 1
a671 1
            
d692 1
a692 1
                  Forbid();      
d694 4
d701 2
a702 1
                     res2 = ERROR_NO_FREE_STORE;
d709 1
a709 1
            
d713 1
a713 1
            
d715 1
a715 1
               
d721 1
a721 1
               
d741 1
a741 1
            
d749 1
a749 1
            
d751 1
a751 1
               
d753 1
a753 1
                  
d758 1
a758 1
                     
d763 1
a763 1
   
d779 2
a780 1
                  goto Done;
d783 1
a783 1
            
d788 1
a788 1
            
d790 1
a790 1
            
d795 1
a795 1
            if( opts[OPT_NOPRO] == 0 && 
d801 1
a801 1
               SetComment(msgbuf, ap->ap_Info.fib_Comment) != 
d813 1
a813 1
            
d867 11
a877 1
   if(windptr) THISPROC->pr_WindowPtr = windptr;
@


1.0
log
@added to rcs
@
text
@d26 4
a29 1
 *    $Log:	Copy.c,v $
a646 1
                  Permit();
@
