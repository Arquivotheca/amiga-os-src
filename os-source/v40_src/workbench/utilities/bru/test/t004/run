#! /bin/sh

goal="walk and archive 1023 character directory tree"
bru=${BRU:-bru}

# Parse our args.  Options include:
#
#	-s	Print our one line test goal and quit
#

while true
do
	case $1 in
		-d)	dflag="on"
			shift
			;;
		-g)	echo $goal
			exit 0
			;;
		*bru*)	bru=$1
			shift
			;;
		*)	break
			;;
	esac
done

cat <<EOT
This test is intended to create a pathname that is the maximum that bru
is capable of handling for files that are not links.  Current versions of
bru should not complain about about archiving or restoring the file, and
will use the extension area of the file header block to save the full
pathname.  The name that gets put in the fname or lname fields will be
the modified name for backwards compatibility.
EOT

if [ "$dflag" != "on" ]
then
	trap "../bin/rmtree tmpdir000 ; rm -f bru.out ; exit 1" 1 2 13 15
fi

# First clean up any stuff that may be left from a previous test.

if test -d tmpdir000
then
	../bin/rmtree tmpdir000
fi

if test -f bru.out
then
	rm -f bru.out
fi

# Run test.

top=`pwd`
for i in 0 1 2 3 4 5 6 7 8 9
do
	for j in 0 1 2 3 4 5 6 7 8 9
	do
		mkdir tmpdir0${i}${j}
		cd tmpdir0${i}${j}
	done
done
mkdir tmpdir100
cd tmpdir100
mkdir tmpdir101
cd tmpdir101
touch abc
cd $top

$bru -cvf bru.out tmpdir000
echo "bru exit status was $?"

$bru -ivf bru.out
echo "bru exit status was $?"

$bru -dddvf bru.out
echo "bru exit status was $?"

../bin/rmtree tmpdir000

$bru -xvf bru.out
echo "bru exit status was $?"

$bru -dddvf bru.out
echo "bru exit status was $?"

if [ "$dflag" != "on" ]
then
	../bin/rmtree tmpdir000
	rm -f bru.out
fi

exit 0
