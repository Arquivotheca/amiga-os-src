head     37.2;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @*   @;


37.2
date     91.02.15.14.15.24;  author eric;  state Exp;
branches ;
next     37.1;

37.1
date     91.01.23.16.57.19;  author eric;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.23.16.57.09;  author eric;  state Exp;
branches ;
next     ;


desc
@@


37.2
log
@New from Fred Fish 12 Feb 91
@
text
@/************************************************************************
 *									*
 *	Copyright (c) 1988 Enhanced Software Technologies, Inc.		*
 *			     All Rights Reserved			*
 *		(Major additions by Arnold Robbins at Georgia Tech)	*
 *									*
 *	This software and/or documentation is protected by U.S.		*
 *	Copyright Law (Title 17 United States Code).  Unauthorized	*
 *	reproduction and/or sales may result in imprisonment of up	*
 *	to 1 year and fines of up to $10,000 (17 USC 506).		*
 *	Copyright infringers may also be subject to civil liability.	*
 *									*
 ************************************************************************
 */


/*
 *  FILE
 *
 *	sys.c    runtime support library calls
 *
 *  SCCS
 *
 *	@@(#)sys.c	12.8	11 Feb 1991
 *
 *  DESCRIPTION
 *
 *	Calls to the runtime support library are localized here
 *	to aid portability and modification and/or inclusion
 *	of custom versions.
 *
 *	This form of interface adds an extra level of function
 *	call overhead, but the benefits for modification or
 *	debugging purposes outweigh the negligible decrease
 *	in efficiency.  (Use the profiler to discover just
 *	how little time is actually spent in these routines!)
 *
 *	There is some question about the best way to deal with
 *	situations in which functions like "printf" return
 *	error results.  This generally indicates a severe
 *	problem with the environment or corrupted runtime
 *	data space.  In any case, it is probably undesirable
 *	to continue execution under those circumstances, so
 *	we abort with an IOT signal and core dump.
 *
 *	An additional advantage of having these functions
 *	centralized is that lint will only have one version
 *	of the library call to complain about.  This
 *	considerably reduces the typical size and complexity
 *	of the lint output log.
 *
 */

#include "globals.h"


/*
 *  FUNCTION
 *
 *	s_vfprintf    call the vfprintf function
 *
 *  SYNOPSIS
 *
 *	int s_vfprintf (stream, format, ap)
 *	FILE *stream;
 *	char *format;
 *	va_list ap;
 *
 *  DESCRIPTION
 *
 *	Invokes the library "vfprintf" function.  If varargs support
 *	is supplied by the system, then we just pass our args on to
 *	vfprintf.  If not, then we need to rebuild an appropriate
 *	argument list for the fprintf call.  This should work on
 *	most reasonable machines that don't have varargs (because if
 *	it didn't work they would HAVE varargs support).
 *
 *  NOTE
 *
 *	DO NOT use the DBUG macros here, since the DBUG package
 *	also calls this function to obtain varargs support.
 *
 */

int s_vfprintf (stream, format, ap)
FILE *stream;
char *format;
va_list ap;
{
    int rtnval;
#if HAVE_VARARGS
    rtnval = vfprintf (stream, format, ap);
#else
    ARGS_DCL;

    ARG0 =  va_arg (ap, ARGS_TYPE);
    ARG1 =  va_arg (ap, ARGS_TYPE);
    ARG2 =  va_arg (ap, ARGS_TYPE);
    ARG3 =  va_arg (ap, ARGS_TYPE);
    ARG4 =  va_arg (ap, ARGS_TYPE);
    ARG5 =  va_arg (ap, ARGS_TYPE);
    ARG6 =  va_arg (ap, ARGS_TYPE);
    ARG7 =  va_arg (ap, ARGS_TYPE);
    ARG8 =  va_arg (ap, ARGS_TYPE);
    ARG9 =  va_arg (ap, ARGS_TYPE);
    rtnval = fprintf (stream, format, ARGS_LIST);
#endif
    return (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_fprintf    call the fprintf function
 *
 *  SYNOPSIS
 *
 *	int s_fprintf (stream, format, va_alist)
 *	FILE *stream;
 *	char *format;
 *	va_dcl
 *
 *  DESCRIPTION
 *
 *	Invokes the library "fprintf" function.  We call the
 *	internal version of vprintf and let it deal with the
 *	variable arguments problem.
 */

/*VARARGS2*/
int s_fprintf (VA_ARG(FILE *,stream), VA_ARG(char *,format), VA_ALIST)
VA_OARGS(FILE *stream;)
VA_OARGS(char *format;)
VA_DCL
{
    int rtnval;
    va_list args;

    VA_START (args, format);
    rtnval = s_vfprintf (stream, format, args);
    va_end (args);
    return (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_vsprintf    call the vsprintf function
 *
 *  SYNOPSIS
 *
 *	int s_vsprintf (s, format, ap)
 *	char *s;
 *	char *format;
 *	va_list ap;
 *
 *  DESCRIPTION
 *
 *	Invokes the library "vsprintf" function.  We call the internal
 *	form of vsprintf and let it deal with the variable arguments
 *	problem.
 *
 *	Big problem here.  System V defines sprintf to return an
 *	int, and -1 for error.  4.2BSD follows V7 and has it returning
 *	a char *, the string it is printing into, and therefore
 *	there really is no way to tell if it returned an error.
 *	If we're lucky, on a bizarre conversion, the string will
 *	have an EOS as the first character, so we test against that.
 */

/*VARARGS2*/
int s_vsprintf (s, format, ap)
char *s;
char *format;
va_list ap;
{
    int rtnval;

#if HAVE_VARARGS
    rtnval = vsprintf (s, format, ap);
#else
    ARGS_DCL;
    ARG0 =  va_arg (ap, ARGS_TYPE);
    ARG1 =  va_arg (ap, ARGS_TYPE);
    ARG2 =  va_arg (ap, ARGS_TYPE);
    ARG3 =  va_arg (ap, ARGS_TYPE);
    ARG4 =  va_arg (ap, ARGS_TYPE);
    ARG5 =  va_arg (ap, ARGS_TYPE);
    ARG6 =  va_arg (ap, ARGS_TYPE);
    ARG7 =  va_arg (ap, ARGS_TYPE);
    ARG8 =  va_arg (ap, ARGS_TYPE);
    ARG9 =  va_arg (ap, ARGS_TYPE);
#if BSD4_2
    /* kludge */
    if (sprintf (s, format, ARGS_LIST) != s || *s == EOS) {
	rtnval = 0;
    }
#else
    /* do it right */
    rtnval = sprintf (s, format, ARGS_LIST);
#endif
#endif
    return (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_sprintf    call the sprintf function
 *
 *  SYNOPSIS
 *
 *	int s_sprintf (s, format, va_alist)
 *	char *s;
 *	char *format;
 *	va_dcl
 *
 *  DESCRIPTION
 *
 *	Invokes the library "sprintf" function.  We call the internal
 *	form of vsprintf and let it deal with the variable arguments
 *	problem.
 *
 */

/*VARARGS2*/
int s_sprintf (VA_ARG(char *,s), VA_ARG(char *,format), VA_ALIST)
VA_OARGS(char *s;)
VA_OARGS(char *format;)
VA_DCL
{
    int rtnval;
    va_list args;

    VA_START (args, format);
    rtnval = s_vsprintf (s, format, args);
    va_end (args);
    return (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_fflush    invoke the library fflush function
 *
 *  SYNOPSIS
 *
 *	VOID s_fflush (stream)
 *	FILE *stream;
 *
 *  DESCRIPTION
 *
 *	Invokes the library fflush function.  Any error is
 *	immediately fatal.
 *
 */

VOID s_fflush (stream)
FILE *stream;
{
    DBUG_ENTER ("s_flush");
    if (fflush (stream) == EOF) {
	(VOID) abort ();
    }
    DBUG_VOID_RETURN;
}
 

/*
 *  FUNCTION
 *
 *	s_open    invoke file open library function
 *
 *  SYNOPSIS
 *
 *	int s_open (path, oflag [ , mode ])
 *	char *path;
 *	int oflag, mode;
 *
 *  DESCRIPTION
 *
 *	Invoke the library function to open a file.  Path points
 *	to a path name, oflag is for the file status flags, and
 *	mode is the file mode if the file is created.
 *
 */

int s_open (path, oflag, mode)
char *path;
int oflag, mode;
{
    int rtnval;

    DBUG_ENTER ("s_open");
    DBUG_PRINT ("open", ("file \"%s\", flag %o, mode %o", path, oflag, mode));
#if amigados
    if (AccessRawFloppy (path, 0) == 0) {
	DBUG_PRINT ("xopen", ("open '%s' as a raw device file", path));
	rtnval = OpenRawFloppy (path, oflag, mode);
    } else if (AccessRawTape (path, 0) == 0) {
	DBUG_PRINT ("xopen", ("open '%s' as a raw tape device", path));
	rtnval = OpenRawTape (path, oflag, mode);
    } else {
	DBUG_PRINT ("xopen", ("open '%s' as a normal file", path));
	rtnval = open (path, oflag, mode);
    }
#else
    rtnval = open (path, oflag, mode);
#endif
    DBUG_PRINT ("open", ("open on descriptor %d", rtnval));
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_ccreat    create a contiguous file
 *
 *  SYNOPSIS
 *
 *	int s_ccreat (path, mode, size)
 *	char *path;
 *	int mode;
 *	int size;
 *
 *  DESCRIPTION
 *
 *	Invoke the library function to creat a Masscomp style contiguous
 *	file.  Path points to a path name, mode is the file mode, and size
 *	is the initial size of the file.
 *
 *	The open will fail with errno ENOSPC if insufficient contiguous
 *	disk space is available.  In this case, we issue a warning
 *	that the file will not be contiguous, and open it as a normal
 *	noncontiguous file.
 *
 */

/*ARGSUSED*/	/* Turn off lint checking for unused args in s_ccreat */

int s_ccreat (path, mode, size)
char *path;
int mode;
long size;
{
    int rtnval;

    DBUG_ENTER ("s_ccreat");
    DBUG_PRINT ("ccreat", ("create contiguous file \"%s\"", path));
    DBUG_PRINT ("ccreat", ("mode %o, size %ld", mode, size));
#if HAVE_CONTIGUOUS
    rtnval = open (path, O_RDWR | O_CREAT | O_CTG | O_TRUNC, mode, size);
    if ((rtnval == SYS_ERROR) && (errno == ENOSPC)) {
	bru_errnor (MSG_COPEN, path);
	rtnval = open (path, O_RDWR | O_CREAT | O_TRUNC, mode, size);
    }
#else
    bru_message (MSG_CNOSUP, path);
    rtnval = open (path, O_RDWR | O_CREAT | O_TRUNC, mode);
#endif
    DBUG_PRINT ("ccreat", ("open on stream %d", rtnval));
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_close    invoke the low level file close facility
 *
 *  SYNOPSIS
 *
 *	int s_close (fildes)
 *	int fildes;
 *
 *  DESCRIPTION
 *
 *	Close the file for the given file descriptor.
 *
 */

int s_close (fildes)
int fildes;
{
    int rtnval;

    DBUG_ENTER ("s_close");
    DBUG_PRINT ("close", ("close descriptor %d", fildes));
#if amigados
    if (IsRawTapeFd (fildes)) {
	rtnval = CloseRawTape (fildes);
    } else if (IsRawFloppyFd (fildes)) {
	rtnval = CloseRawFloppy (fildes);
    } else {
	rtnval =  close (fildes);
    }
#else
    rtnval =  close (fildes);
#endif
    DBUG_RETURN (rtnval);
}
 


/*
 *  FUNCTION
 *
 *	s_access    invoke low level access library routine
 *
 *  SYNOPSIS
 *
 *	int s_access (path, amode)
 *	char *path;
 *	int amode;
 *
 *  DESCRIPTION
 *
 *	Invoke low level library routine "access" to test files
 *	for accessibility.
 *
 */

int s_access (path, amode)
char *path;
int amode;
{
    int rtnval;
    
    DBUG_ENTER ("s_access");
    DBUG_PRINT ("access", ("test '%s' for access %d", path, amode));
#if amigados
    if ((rtnval = AccessRawFloppy (path, amode)) != 0) {
	if ((rtnval = AccessRawTape (path, amode)) != 0) {
	    rtnval = access (path, amode);
	}
    }
#else
    rtnval = access (path, amode);
#endif
    DBUG_PRINT ("access", ("result = %d", rtnval));
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_read    invoke library function to read from file
 *
 *  SYNOPSIS
 *
 *	int s_read (fildes, buf, nbyte)
 *	int fildes;
 *	char *buf;
 *	UINT nbyte;
 *
 *  DESCRIPTION
 *
 *	Invoke library function to read from file.
 *
 */

int s_read (fildes, buf, nbyte)
int fildes;
char *buf;
UINT nbyte;
{
    int rtnval;
    
    DBUG_ENTER ("s_read");
    DBUG_PRINT ("read", ("read %u bytes from descriptor %d", nbyte, fildes));
#if amigados
    if (IsRawTapeFd (fildes)) {
	rtnval = ReadRawTape (fildes, buf, nbyte);
    } else if (IsRawFloppyFd (fildes)) {
	rtnval = ReadRawFloppy (fildes, buf, nbyte);
    } else {
	rtnval = read (fildes, buf, nbyte);
    }
#else
    rtnval = read (fildes, buf, nbyte);
#endif
    DBUG_PRINT ("read", ("read returns %d", rtnval));
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_chown    invoke library function to change file owner
 *
 *  SYNOPSIS
 *
 *	int s_chown (path, owner, group)
 *	char *path;
 *	int owner, group;
 *
 *  DESCRIPTION
 *
 *	Invoke low level library routine to change ownership of file.
 *
 */

int s_chown (path, owner, group)
char *path;
int owner, group;
{
    int rtnval;

    DBUG_ENTER ("s_chown");
#if unix || xenix
    rtnval = chown (path, owner, group);
#else
    rtnval = 0;
#endif
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_sleep    invoke library function to sleep for N seconds
 *
 *  SYNOPSIS
 *
 *	VOID s_sleep (seconds)
 *	UINT seconds;
 *
 *  DESCRIPTION
 *
 *	Invoke library function to sleep for specified number of
 *	seconds.
 *
 */

VOID s_sleep (seconds)
UINT seconds;
{
    DBUG_ENTER ("s_sleep");
#if unix || xenix
    (VOID) sleep (seconds);
#endif
#if amigados
    (VOID) Delay ((long) (50 * seconds));
#endif
    DBUG_VOID_RETURN;
}


/*
 *  FUNCTION
 *
 *	s_uname    invoke library function to get system info
 *
 *  SYNOPSIS
 *
 *	int s_uname (name)
 *	struct utsname *name;
 *
 *  DESCRIPTION
 *
 *	Invoke library function to get information about host system.
 *
 */

int s_uname (name)
struct utsname *name;
{
    int rtnval;
    
    DBUG_ENTER ("s_uname");
    rtnval = uname (name);
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_umask    invoke library function to set/get file mask
 *
 *  SYNOPSIS
 *
 *	int s_umask (cmask)
 *	int cmask;
 *
 *  DESCRIPTION
 *
 *	Invoke library function to set and get the file creation mask.
 *
 */

int s_umask (cmask)
int cmask;
{
    int rtnval;

    DBUG_ENTER ("s_umask");
#if unix || xenix
    rtnval = umask (cmask);
#else
    rtnval = 0;
#endif
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_utime    set file access and modification times
 *
 *  SYNOPSIS
 *
 *	int s_utime (path, times)
 *	char *path;
 *	struct utimbuf *times;
 *
 *  DESCRIPTION
 *
 *	Invoke the library function utime to set file access and
 *	modification times.
 *
 *  NOTES
 *
 *	For non-unix systems, this is currently a NOP, though
 *	in theory it is possible to change the date for systems
 *	like the Amiga by accessing the raw file system (yetch!).
 *
 */

/*VARARGS1*/
int s_utime (path, times)
char *path;
struct utimbuf *times;
{
    int rtnval;

    DBUG_ENTER ("s_utime");
    rtnval = utime (path, times);
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_chmod    change mode of file
 *
 *  SYNOPSIS
 *
 *	int s_chmod (path, mode)
 *	char *path;
 *	int mode;
 *
 *  DESCRIPTION
 *
 *	Invoke library function to change the access mode of a file.
 *
 *  NOTES
 *
 *	On some systems there is a real problem with lint concerning the
 *	type of the second argument (sometimes declared as unsigned short
 *	in the lint library).  The declaration used here matches the actual
 *	code in the system V library and the System V Interface Definition
 *	published by AT&T.  If your lint complains then either fix your
 *	library or complain to your vender.  This has been fixed in the
 *	UniPlus 5.2 lint library.
 *
 *	For the Amiga, the owner modes are used.  Delete permission
 *	is always set.
 *
 */

int s_chmod (path, mode)
char *path;
int mode;
{
    int rtnval;

    DBUG_ENTER ("s_chmod");
    DBUG_PRINT ("chmod", ("chmod %s to %#x", path, mode));
#if amigados
    rtnval = 0;		/* build Lattice mode here */
    if (mode & BS_IREAD) {
	rtnval |= S_IREAD;
    }
    if (mode & BS_IWRITE) {
	rtnval |= (S_IWRITE | S_IDELETE);
    }
    if (mode & BS_IEXEC) {
	rtnval |= S_IEXECUTE;
    }
    mode = rtnval;
    DBUG_PRINT ("chmod", ("lattice mode is %#x", mode));
#endif
    rtnval = chmod (path, mode);
    DBUG_PRINT ("chmod", ("chmod result is %d", rtnval));
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_write    write data to a file
 *
 *  SYNOPSIS
 *
 *	int s_write (fildes, buf, nbyte)
 *	int fildes;
 *	char *buf;
 *	UINT nbyte;
 *
 *  DESCRIPTION
 *
 *	Invoke the low level I/O routine to write to a file.
 *
 */

int s_write (fildes, buf, nbyte)
int fildes;
char *buf;
UINT nbyte;
{
    int rtnval;

    DBUG_ENTER ("s_write");
    DBUG_PRINT ("write", ("write %u bytes to fildes %d", nbyte, fildes));
#if amigados
    if (IsRawTapeFd (fildes)) {
	rtnval = WriteRawTape (fildes, buf, nbyte);
    } else if (IsRawFloppyFd (fildes)) {
	rtnval = WriteRawFloppy (fildes, buf, nbyte);
    } else {
	rtnval = write (fildes, buf, nbyte);
    }
#else
    rtnval = write (fildes, buf, nbyte);
    DBUG_PRINT ("write", ("write returns %d, errno %d", rtnval, errno));
#endif
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_unlink    remove a directory entry
 *
 *  SYNOPSIS
 *
 *	int s_unlink (path)
 *	char *path;
 *
 *  DESCRIPTION
 *
 *	Invoke low level routine to remove a directory entry.
 *
 */

int s_unlink (path)
char *path;
{
    int rtnval;

    DBUG_ENTER ("s_unlink");
    rtnval = unlink (path);
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_time    get current system time
 *
 *  SYNOPSIS
 *
 *	long s_time (tloc)
 *	long *tloc;
 *
 *  DESCRIPTION
 *
 *	Invoke low level routine to get system time.
 *
 *	Note that BSD4_2 lint library defines both the argument and result
 *	as typedef time_t, which is an int, and the BSD4_2 online manual
 *	defines the types correctly (grrrrrrrr!!!!!).
 *
 */

long s_time (tloc)
long *tloc;
{
    long rtnval;

    DBUG_ENTER ("s_time");
#if BSD4_2 && lint
    rtnval = (long) time ((time_t *) tloc);
#else
    rtnval = time (tloc);
#endif
    DBUG_PRINT ("time", ("time is %ld", rtnval));
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_ulimit    get and set user limits
 *
 *  SYNOPSIS
 *
 *	long s_ulimit (cmd, newlimit)
 *	int cmd;
 *	long newlimit;
 *
 *  DESCRIPTION
 *
 *	Provides control over process limits.  Currently bru only
 *	uses it to get or set the maximum file size limit.
 *
 *	If we do not have a ulimit, then we assume there are no
 *	limits to a file's size.  Getting the limit returns the
 *	maximum value of an unsigned long.  Setting the limit is
 *	essentially a nop and returns the requested size.
 *
 *  BUGS
 *
 *	Determining the maximum value of an unsigned long is currently
 *	dependent on two's complement arithmetic.
 *
 */

long s_ulimit (cmd, newlimit)
int cmd;
long newlimit;
{
    long result;
#if !HAVE_ULIMIT
    unsigned long temp;
#endif

    DBUG_ENTER ("s_ulimit");
    DBUG_PRINT ("ulimit", ("cmd = %d; newlimit = %ld", cmd, newlimit));
#if HAVE_ULIMIT
    result = ulimit (cmd, newlimit);
#else
    switch (cmd) {
	case 1:
	    temp = ~0;
	    temp >>= 1;
	    result = (long) temp;
	    break;
	case 2:
	    result = newlimit;
	    break;
    }
#endif
    DBUG_PRINT ("ulimit", ("returns %ld", result));
    DBUG_RETURN (result);
}


/*
 *  FUNCTION
 *
 *	s_getuid    get real user ID of process
 *
 *  SYNOPSIS
 *
 *	int s_getuid ()
 *
 *  DESCRIPTION
 *
 *	Invoke low level routine to get the real user ID of process.
 *
 */

int s_getuid ()
{
    int rtnval;

    DBUG_ENTER ("s_getuid");
#if unix || xenix
    rtnval = getuid ();
#else
    rtnval = 0;
#endif
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_getgid    get real group ID of process
 *
 *  SYNOPSIS
 *
 *	int s_getgid ()
 *
 *  DESCRIPTION
 *
 *	Invoke low level routine to get the real group ID of process.
 *
 */

int s_getgid ()
{
    int rtnval;

    DBUG_ENTER ("s_getgid");
#if unix || xenix
    rtnval = getgid ();
#else
    rtnval = 0;
#endif
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_ctime    convert internal time to string
 *
 *  SYNOPSIS
 *
 *	char *s_ctime (clock)
 *	long *clock;
 *
 *  DESCRIPTION
 *
 *	Call standard library routine to convert from internal time
 *	format to string form.
 *
 *	Note that BSD4_2 lint library defines the argument as typedef
 *	time_t, which is an int, and the BSD4_2 online manual defines
 *	the type correctly (grrrrrrrr!!!!!).
 */

char *s_ctime (clock)
long *clock;
{
    char *rtnval;

    DBUG_ENTER ("s_ctime");
#if BSD4_2 && lint
    rtnval = ctime ((time_t *) clock);
#else
    rtnval = ctime (clock);
#endif
    DBUG_PRINT ("ctime", ("converted to '%s'", rtnval));
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_localtime    convert internal time to time structure
 *
 *  SYNOPSIS
 *
 *	struct tm *s_localtime (clock)
 *	long *clock;
 *
 *  DESCRIPTION
 *
 *	Call standard library routine to convert from internal time
 *	format to time structure form.
 *
 *	Note that BSD4_2 lint library defines the argument as "time_t *"
 *	where time_t is typedef as an int, and the BSD4_2 online manual defines
 *	the type correctly (grrrrrrrr!!!!!).
 */

struct tm *s_localtime (clock)
long *clock;
{
    struct tm *rtnval;

    DBUG_ENTER ("s_localtime");
    DBUG_PRINT ("localtime", ("convert time %ld", *clock));
#if BSD4_2 && lint
    rtnval = localtime ((time_t *) clock);
#else
    rtnval = localtime (clock);
#endif
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_asctime    convert time structure to ascii string
 *
 *  SYNOPSIS
 *
 *	char *s_asctime (tm)
 *	struct tm *tm;
 *
 *  DESCRIPTION
 *
 *	Call standard library routine to convert from time structure form
 *	to an ascii string.
 *
 */

char *s_asctime (tm)
struct tm *tm;
{
    char *rtnval;

    DBUG_ENTER ("s_asctime");
    rtnval = asctime (tm);
    DBUG_PRINT ("asctime", ("asctime returns '%s'", rtnval));
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_fopen    open a stream
 *
 *  SYNOPSIS
 *
 *	FILE *s_fopen (file_name, type)
 *	char *file_name;
 *	char *type;
 *
 *  DESCRIPTION
 *
 *	Invokes the standard library routine to open a stream.
 *
 */

FILE *s_fopen (file_name, type)
char *file_name;
char *type;
{
    FILE *rtnval;
    
    DBUG_ENTER ("s_fopen");
    rtnval = fopen (file_name, type);
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_mknod    make a directory, or a special or ordinary file
 *
 *  SYNOPSIS
 *
 *	int s_mknod (path, mode, dev)
 *	char *path;
 *	int mode, dev;
 *
 *  DESCRIPTION
 *
 *	Invokes the low level function mknod to make a directory entry.
 *
 *	If called on a symbolic link, report an error, since that code
 *	should go through s_symlink and/or s_csymlink.
 *
 *	!!! BEWARE !!!  On BSD4.1 systems, the dev parameter must be
 *	zero for directories or regular files or nasty filesystem
 *	things happen.
 *
 *	I don't know if this applies to 4.2 as well, but I'm going to
 *	assume that it does.  The manual says that 'dev' is ignored, but
 *	Berkeley doc isn't always right.  ADR.
 */

int s_mknod (path, mode, dev)
char *path;
int mode, dev;
{
    int rtnval;

    DBUG_ENTER ("s_mknod");
#if BSD4_1 || BSD4_2
    if (IS_DIR (mode) || IS_REG (mode)) {
	dev = 0;
    }
#endif
    DBUG_PRINT ("mknod", ("make node \"%s\" mode %o device %x", path, mode, dev));
    if (IS_FLNK (mode)) {
	bru_message (MSG_BUG, "s_mknod (symlink)");
    }
#if unix || xenix
    rtnval = mknod (path, mode, dev);
#else
    (VOID) s_fprintf (errfp, "warning -- mknod() not implemented!\n");
    rtnval = SYS_ERROR;
#endif
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_strtol   convert string to a long integer
 *
 *  SYNOPSIS
 *
 *	long s_strtol (str, ptr, base)
 *	char *str;
 *	char **ptr;
 *	int base;
 *
 *  DESCRIPTION
 *
 *	Invoke standard library routine to convert string to a long
 *	integer.
 *
 */

S32BIT s_strtol (str, ptr, base)
char *str;
char **ptr;
int base;
{
    long rtnval;

    DBUG_ENTER ("s_strtol");
    rtnval = strtol (str, ptr, base);
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_malloc    allocate memory from system
 *
 *  SYNOPSIS
 *
 *	char *s_malloc (size)
 *	UINT size;
 *
 *  DESCRIPTION
 *
 *	Call standard library routine to allocate memory.
 *
 */

char *s_malloc (size)
UINT size;
{
    char *rtnval;

    errno = 0;					/* 286 bug workaround */
    rtnval = malloc (size);
    return (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_exit    terminate process
 *
 *  SYNOPSIS
 *
 *	VOID s_exit (status)
 *	int status;
 *
 *  DESCRIPTION
 *
 *	Call the low level routine to terminate process.
 *
 */

VOID s_exit (status)
int status;
{
    DBUG_ENTER ("s_exit");
    DBUG_PRINT ("exit", ("exiting with status %d", status));
#if BSD4_2
    (VOID) exit (status);
#else
    exit (status);
#endif
    DBUG_VOID_RETURN;
}


/*
 *  FUNCTION
 *
 *	s_getopt    parse command line options
 *
 *  SYNOPSIS
 *
 *	int s_getopt (argc, argv, optstring)
 *	int argc;
 *	char **argv;
 *	char *optstring;
 *
 */

int s_getopt (argc, argv, optstring)
int argc;
char **argv;
char *optstring;
{
    int rtnval;

    DBUG_ENTER ("s_getopt");
    rtnval = getopt (argc, argv, optstring);
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_free    free memory received via malloc
 *
 *  SYNOPSIS
 *
 *	VOID s_free (ptr)
 *	char *ptr;
 *
 *  DESCRIPTION
 *
 *	Used to free memory allocated via the standard library
 *	memory allocator (malloc).
 *
 */

VOID s_free (ptr)
char *ptr;
{
    DBUG_ENTER ("s_free");
#if BSD4_2
    (VOID) free (ptr);
#else
    free (ptr);
#endif
    DBUG_VOID_RETURN;
}


/*
 *  FUNCTION
 *
 *	s_getpwent    get password file entry
 *
 *  SYNOPSIS
 *
 *	struct passwd *s_getpwent ()
 *
 *  DESCRIPTION
 *
 *	Invoke standard library routine to get a password file entry.
 *
 */

#if !unix && !xenix
static BOOLEAN pwentopen = FALSE;
static struct passwd pwentfake = {
    "root",
    "NONE",
    0,
    0,
    "NONE",
    "NONE",
    "NONE",
    "/",
    "/bin/sh"
};
#endif

struct passwd *s_getpwent ()
{
    struct passwd *rtnval;
#if unix || xenix
    rtnval = getpwent ();
#else
    if (pwentopen) {
	rtnval = (struct passwd *)NULL;
    } else {
	pwentopen = TRUE;
	rtnval = &pwentfake;
    }
#endif
    return (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_endpwent    close password file when done with it
 *
 *  SYNOPSIS
 *
 *	VOID s_endpwent ()
 *
 *  DESCRIPTION
 *
 *	Calls standard library function endpwent to close password
 *	file when done with it.
 *
 */

VOID s_endpwent ()
{
#if unix || xenix
#if BSD4_2
    (VOID) endpwent ();
#else
    endpwent ();
#endif
#else
    pwentopen = FALSE;
#endif
}


/*
 *  FUNCTION
 *
 *	s_getgrent    get group file entry
 *
 *  SYNOPSIS
 *
 *	struct group *s_getgrent ()
 *
 *  DESCRIPTION
 *
 *	Invoke standard library routine to get a group file entry.
 *
 */

#if !unix && !xenix
static BOOLEAN grentopen = FALSE;
static struct group grentfake = {
    "root",
    "NONE",
    0,
    NULL
};
#endif

struct group *s_getgrent ()
{
    struct group *rtnval;

#if unix || xenix
    rtnval = getgrent ();
#else
    if (grentopen) {
	rtnval = (struct group *)NULL;
    } else {
	grentopen = TRUE;
	rtnval = &grentfake;
    }
#endif
    return (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_endgrent    close group file when done with it
 *
 *  SYNOPSIS
 *
 *	VOID s_endgrent ()
 *
 *  DESCRIPTION
 *
 *	Calls standard library function endpwent to close group
 *	file when done with it.
 *
 */

VOID s_endgrent ()
{
#if unix || xenix
#if BSD4_2
    (VOID) endgrent ();
#else
    endgrent ();
#endif
#else
    grentopen = FALSE;
#endif
}


/*
 *  FUNCTION
 *
 *	s_signal    set up signal handling
 *
 *  SYNOPSIS
 *
 *	SIGTYPE s_signal (sig, func)
 *	int sig;
 *	SIGTYPE func;
 *
 *  DESCRIPTION
 *
 *	Set signal handling by calling low level routine "signal".
 *
 *  NOTES
 *
 *	There is considerable disagreement, between different implementations
 *	and proposed standards, for the declared type of signal() and it's
 *	second argument.  For example:
 *
 *		(1) System V Interface Definition from AT&T
 *
 *			int (*signal (sig, func)()) { int sig; int (*func)();
 *
 *		(2) Proposed ANSI C standard
 *
 *			void (*signal (sig, func)()) { int sig; void (*func)();
 *
 *		(3) 68000 System V generic release (Motorola Microport)
 *
 *			int (*signal (sig, func)()) { int sig; int (*func)();
 *			(in library)
 *
 *			int (*signal (sig, func)()) { int sig; void (*func)();
 *			(in lint and documentation for signal(2))
 *
 *	The inconsistency in (3) has been corrected in UniSoft's UniPlus
 *	based on the 68000 generic release, by fixing the lint library to
 *	be in agreement with the code and header files (change void to int).
 *
 *	If your lint complains about this then complain to your vendor!
 *
 */

SIGTYPE s_signal (sig, func)
int sig;
SIGTYPE func;
{
    SIGTYPE rtnval;

    DBUG_ENTER ("s_signal");
    DBUG_PRINT ("signals", ("set signal (%d,%lx)", sig, func));
#if unix || xenix || amigados
    rtnval = signal (sig, func);
#else
    DBUG_PRINT ("signals", ("signals not implemented in this system"));
    rtnval = (SIGTYPE) SYS_ERROR;
#endif
    DBUG_PRINT ("signals", ("signal returns %d", rtnval));
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_ioctl    issue low level function to control device
 *
 *  SYNOPSIS
 *
 *	int s_ioctl (fildes, request, arg)
 *	int fildes;
 *	int request;
 *	int arg;
 *
 *  DESCRIPTION
 *
 *	Issue the low level request to control device.
 *
 */

int s_ioctl (fildes, request, arg)
int fildes, request, arg;
{
    int rtnval;

    DBUG_ENTER ("s_ioctl");
    DBUG_PRINT ("ioctl", ("ioctl on fildes %d", fildes));
    DBUG_PRINT ("ioctl", ("request %d, arg %d", request, arg));
#if unix || xenix
#if BSD4_2
    rtnval = ioctl (fildes, request, (char *) arg);
#else
    rtnval = ioctl (fildes, request, arg);
#endif
#else
    (VOID) s_fprintf (errfp, "warning -- ioctl() not implemented!\n");
    rtnval = SYS_ERROR;
#endif
    DBUG_PRINT ("ioctl", ("ioctl returns %d", rtnval));
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_strcat    concatenate two strings
 *
 *  SYNOPSIS
 *
 *	char *s_strcat (s1, s2)
 *	char *s1, *s2;
 *
 *  DESCRIPTION
 *
 *	Append copy of string s2 to end of string s1.
 *
 */

char *s_strcat (s1, s2)
char *s1, *s2;
{
    char *rtnval;
    
    rtnval = strcat (s1, s2);
    return (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_strcmp    compare two strings lexicographically
 *
 *  SYNOPSIS
 *
 *	int s_strcmp (s1, s2)
 *	char *s1, *s2;
 *
 *  DESCRIPTION
 *
 *	Compare string s1 with string s2 and return an integer less
 *	than, equal to, or greater than zero according as s1 is
 *	lexicographically less than, equal to, or greater than s2.
 *
 */

int s_strcmp (s1, s2)
char *s1, *s2;
{
    int rtnval;

    rtnval = strcmp (s1, s2);
    return (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_strcpy    copy strings from one location to another
 *
 *  SYNOPSIS
 *
 *	char *s_strcpy (s1, s2)
 *	char *s1, *s2;
 *
 *  DESCRIPTION
 *
 *	Copy string s2 to s1, stopping after the null character has been
 *	copied.
 *
 */

char *s_strcpy (s1, s2)
char *s1, *s2;
{
    char *rtnval;
    
    rtnval = strcpy (s1, s2);
    return (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_strncpy    copy strings from one location to another
 *
 *  SYNOPSIS
 *
 *	char *s_strncpy (s1, s2, n)
 *	char *s1, *s2;
 *	int n;
 *
 *  DESCRIPTION
 *
 *	Copy n characters from string s2 to s1, truncating s2 or
 *	padding s1 with nulls as required.
 *
 */

char *s_strncpy (s1, s2, n)
char *s1, *s2;
int n;
{
    char *rtnval;
    
    rtnval = strncpy (s1, s2, n);
    return (rtnval);
}



/*
 *  FUNCTION
 *
 *	s_strlen    find length of string
 *
 *  SYNOPSIS
 *
 *	int s_strlen (s)
 *	char *s;
 *
 *  DESCRIPTION
 *
 *	Count characters in string s, not including terminating null.
 *
 */

int s_strlen (s)
char *s;
{
    int rtnval;

    rtnval = strlen (s);
    return (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_strchr    find first occurance of character in string
 *
 *  SYNOPSIS
 *
 *	char *s_strchr (s, c)
 *	char *s;
 *	int c;
 *
 *  DESCRIPTION
 *
 *	Search forward in string s until first occurance of
 *	string character c, returning pointer.  If strchr is available,
 *	just use it.  If not, and index is available, substitute it
 *	instead.  Otherwise just do brute force.
 *
 */

char *s_strchr (s, c)
char *s;
int c;
{
    char *rtnval;

#if HAVE_STRCHR
    rtnval = strchr (s, c);
#else
#if HAVE_INDEX
    rtnval = index (s, c);
#else
    rtnval = NULL;
    if (s != NULL) {
	while (*s != EOS && *s != c) {s++;}
	if (*s == c) {
	    rtnval = s;
	}
    }
#endif	/* HAVE_INDEX */
#endif	/* HAVE_STRCHR */
    return (rtnval);
}



/*
 *  FUNCTION
 *
 *	s_strrchr    find last given character in string
 *
 *  SYNOPSIS
 *
 *	char *s_strrchr (s, c)
 *	char *s;
 *	char c;
 *
 *  DESCRIPTION
 *
 *	Find last occurance of the given character c in the string s.
 *	Use strrchr if available.  If not, and rindex is available,
 *	use that.  Otherwise just do brute force.
 *
 */

char *s_strrchr (s, c)
char *s;
int c;
{
    char *rtnval;
#if HAVE_STRRCHR
    rtnval = strrchr (s, c);
#else
#if HAVE_RINDEX
    rtnval = rindex (s, c);
#else
    if (s == NULL) {
	rtnval = NULL;
    } else {
	rtnval = s;
	while (*s != EOS) {s++;}
	while (s > rtnval && *s != c) {s--;}
	if (*s == c) {
	    rtnval = s;
	} else {
	    rtnval = NULL;
	}
    }
#endif	/* HAVE_RINDEX */
#endif	/* HAVE_STRRCHR */
    return (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_mkdir    make a directory node
 *
 *  SYNOPSIS
 *
 *	int s_mkdir (path, mode)
 *	char *path;
 *	int mode;
 *
 *  DESCRIPTION
 *
 *	Contains code to make a directory node and its entries
 *	"." and ".."
 *
 *	This is a system call under 4.2, so we just use it.
 *	Also just a system call under UniPlus with NFS.
 *
 *	Note that the effective user id must be root for this
 *	to work.  Thus this is only usable by root or if the
 *	process is owned by root and has the SUID bit set.
 *
 *	As an alternative, the system "mkdir" command could
 *	be forked but this is much faster.  This is probably
 *	fertile ground for anyone looking for system security
 *	loopholes.
 *
 *	Note that the parent directory must be writable by the
 *	real user.
 *
 *	Under 4.2, 'mkdir' is a system call, so this routine will just
 *	use the system call.  Using the system call should help
 *	security issues too.  Similarly UniPlus with NFS...
 *
 *	Note, this routine may not be completely bulletproof.  How
 *	will it behave if the name ends with a '/', as in
 *	"/usr/bin/"?  How will BSD4.2 mkdir() behave in this case?
 *
 */


/*
 *  PSEUDO CODE
 *
 *	Begin mkdir
 *	    Default return value is SYS_ERROR
 *	    If path will not fit in working buffer then
 *		Zap errno to prevent misleading messages
 *	    Else
 *		Copy file name to local work buffer
 *		Find stem and leaf separator
 *		If there is a leaf string then
 *		    Erase leaf, leaving stem and '/'
 *		    Build name by adding "." to stem
 *		Else
 *		    Set the name to "."
 *		End if
 *		If the parent directory can be written then
 *		    If the directory node is made successfully then
 *			Copy name to entries buffer
 *			Build name for first entry
 *			If the entry cannot be linked then
 *			    Unlink the directory file
 *			Else
 *			    Build name for second entry
 *			    If the entry cannot be linked then
 *				Build name for previous entry
 *				Unlink previous entry
 *				Unlink the directory
 *			    Else
 *				Directory was made successfully
 *			    End if
 *			End if
 *		    End if
 *		End if
 *	    End if
 *	    Return result
 *	End mkdir
 *
 */



#if !amigados

int s_mkdir (path, mode)
char *path;
int mode;
{
    int rtnval;

#if HAVE_MKDIR

    DBUG_ENTER ("s_mkdir");
    rtnval = mkdir (path, mode);
    DBUG_RETURN (rtnval);

#else

    char *leaf;
    char parent[BRUPATHMAX];
    char entries[BRUPATHMAX+3];		/* Leave room for "/.." */

    DBUG_ENTER ("s_mkdir");
    rtnval = SYS_ERROR;
    if (s_strlen (path) >= BRUPATHMAX) {
	errno = ENAMETOOLONG;
	DBUG_PRINT ("mkdir", ("pathname too long!"));
    } else {
	(VOID) s_strcpy (parent, path);
	leaf = s_strrchr (parent, '/');
	if (leaf != NULL) {
	    *++leaf = EOS;
	    (VOID) s_strcat (parent, ".");
	} else {
	    (VOID) s_strcpy (parent, ".");
	}
	DBUG_PRINT ("mkdir", ("test %s for access %d", parent, A_WRITE));
	if (s_access (parent, A_WRITE) == 0) {
	    DBUG_PRINT ("mkdir", ("parent writable, make the %s node", path));
	    if (s_mknod (path, mode, 0) != SYS_ERROR) {
		DBUG_PRINT ("mkdir", ("node made, make the . & .. entries"));
		(VOID) s_strcpy (entries, path);
		(VOID) s_strcat (entries, "/.");
		if (s_link (path, entries) == SYS_ERROR) {
		    (VOID) s_unlink (path);
		} else {
		    (VOID) s_strcat (entries, ".");
		    if (s_link (parent, entries) == SYS_ERROR) {
			entries[s_strlen(entries)-1] = EOS;
			(VOID) s_unlink (entries);
			(VOID) s_unlink (path);
		    } else {
			DBUG_PRINT ("mkdir", ("directory made"));
			rtnval = 0;
		    }
		}
	    }
	}
    }
    DBUG_RETURN (rtnval);
#endif
}

#endif	/* !amigados */


/*
 *  FUNCTION
 *
 *	s_lseek    seek to location in file
 *
 *  SYNOPSIS
 *
 *	S32BIT s_lseek (fildes, offset, whence)
 *	int fildes;
 *	S32BIT offset;
 *	int whence;
 *
 *  DESCRIPTION
 *
 *	Invoke the standard library function to seek to file
 *	location.
 *
 */

S32BIT s_lseek (fildes, offset, whence)
int fildes;
S32BIT offset;
int whence;
{
    S32BIT rtnval;
    
    DBUG_ENTER ("s_lseek");
    DBUG_PRINT ("lseek", ("lseek on fildes %d", fildes));
    DBUG_PRINT ("lseek", ("offset %ld, whence %d", offset, whence));
#if amigados
    if (IsRawTapeFd (fildes)) {
	rtnval = LseekRawTape (fildes, offset, whence);
    } else if (IsRawFloppyFd (fildes)) {
	rtnval = LseekRawFloppy (fildes, offset, whence);
    } else {
	rtnval = lseek (fildes, offset, whence);
    }
#else
    rtnval = lseek (fildes, offset, whence);
#endif
    DBUG_PRINT ("lseek", ("lseek returns %ld", rtnval));
    DBUG_RETURN (rtnval);
}


int s_tolower (c)
int c;
{
#if BSD4_2
    /* BSD tolower blindly converts, while S5 checks, so we check for it */
    if (!isupper (c)) {
	return (c);
    } else {
	return (tolower (c));
    }
#else
    return (tolower (c));
#endif
}


int s_creat (path, mode)
char *path;
int mode;
{
    int rtnval;
    
    DBUG_ENTER ("s_creat");
    rtnval = creat (path, mode);
    DBUG_RETURN (rtnval);
}


int s_isdigit (c)
int c;
{
    return (isdigit (c));
}


int s_atoi (str)
char *str;
{
    int rtnval;
    
    DBUG_ENTER ("s_atoi");
    rtnval = atoi (str);
    DBUG_RETURN (rtnval);
}


int s_fileno (stream)
FILE *stream;
{
    return (fileno (stream));
}


/*
 *	If we have memcpy() then just use it.  Otherwise, we can
 *	fake it with bcopy() if available.  If neither, then just
 *	do it brute force.
 */

char *s_memcpy (s1, s2, n)
char *s1;
char *s2;
int n;
{
#if HAVE_MEMCPY
    return (memcpy (s1, s2, n));
#else
#if HAVE_BCOPY
    (VOID) bcopy (s2, s1, n);
    return (s1);
#else
    char *saved_s1 = s1;
    while (n-- > 0) {
	*s1++ = *s2++;
    }
    return (saved_s1);
#endif	/* HAVE_BCOPY */
#endif	/* HAVE_MEMCPY */
}

/*
 *	If we have memset() then just use it.  Otherwise, just do
 *	it brute force.
 *
 *	We could optimize here and do block memory sets one longword
 *	at a time.  This may be a significant improvement if memset is
 *	not available.
 *
 */

char *s_memset (s, c, n)
char *s;
int c;
int n;
{
#if HAVE_MEMSET
    return (memset (s, c, n));
#else
    char *saved_s = s;
    while (n-- > 0) {
	*s++ = c;
    }
    return (saved_s);
#endif	/* HAVE_MEMSET */
}


int s_link (path1, path2)
char *path1, *path2;
{
    int rtnval;
    
    DBUG_ENTER ("s_link");
    DBUG_PRINT ("link", ("link \"%s\" to existing \"%s\"", path2, path1));
#if unix || xenix
    rtnval = link (path1, path2);
#else
    rtnval = SYS_ERROR;		/* No obvious way to fake it */
#endif
    DBUG_RETURN (rtnval);
}


/*
 *	For the amigados version, we only need to fake a dup for
 *	stdin, stdout, or stderr by simply returning the given fildes.
 *	This should work ok for what we want to do with it...
 */

int s_dup (fildes)
int fildes;
{
    int rtnval;
    
    DBUG_ENTER ("s_dup");
#if unix || xenix
    rtnval = dup (fildes);
#else
#if amigados
    if (fildes == 0 || fildes == 1 || fildes == 2) {
	rtnval = fildes;
    } else {
	errno = EBADF;
	rtnval = SYS_ERROR;
    }
#else
    (VOID) s_fprintf (errfp, "warning -- dup() not implemented!\n");
    rtnval = SYS_ERROR;
#endif
#endif
    DBUG_RETURN (rtnval);
}


char *s_getenv (name)
char *name;
{
    char *rtnval;
    
    DBUG_ENTER ("s_getenv");
    rtnval = getenv (name);
    DBUG_RETURN (rtnval);
}


int s_fork ()
{
    int rtnval;
    
    DBUG_ENTER ("s_fork");
#if unix || xenix
    rtnval = fork ();
#else
    rtnval = SYS_ERROR;
#endif
    DBUG_PRINT ("fork", ("fork returns %d", rtnval));
    DBUG_RETURN (rtnval);
}



/*
 *	Under SVR4, wait() returns type pid_t, which is a long.
 *	So we make our internal version return long in all cases.
 */

#if !amigados

long s_wait (stat_loc)
int *stat_loc;
{
    long rtnval;
    
    DBUG_ENTER ("s_wait");
    DBUG_PRINT ("wait", ("wait with &status = %lx", stat_loc));
#if HAVE_UNIONWAIT
    rtnval = wait ((union wait *) stat_loc);
    if (stat_loc != NULL) {
	DBUG_PRINT ("wait", ("status = %x", stat_loc -> w_status));
    }
#else
    rtnval = wait (stat_loc);
    if (stat_loc != NULL) {
	LINTCOOKIE;
	DBUG_PRINT ("wait", ("status = %x", *stat_loc));
    }
#endif
    DBUG_PRINT ("wait", ("wait returns %ld", rtnval));
    DBUG_RETURN (rtnval);
}

#endif	/* !amigados */


/*
 *	The BSD4_2 lint library has a totally screwed up entry for execv.
 *	It has no explicitly declared return type, so defaults to int, but
 *	then does not explicitly return anything so lint complains about
 *	any code that tries to use the return value.
 */

int s_execv (path, argv)
char *path;
char *argv[];
{
    int rtnval;
    
    DBUG_ENTER ("s_execv");
#if BSD4_2 && lint
    (VOID) execv (path, argv);			/* Lint library lies! */
    rtnval = -1;
#else
#if amigados
    (VOID) s_fprintf(errfp, "Sorry, execv not yet implemented!\n");
    rtnval = -1;
#else
    rtnval = execv (path, argv);
#endif
#endif
    DBUG_RETURN (rtnval);
}


int s_setuid (uid)
int uid;
{
    int rtnval;
    
    DBUG_ENTER ("s_setuid");
#if unix || xenix
    rtnval = setuid (uid);
#else
    rtnval = 0;
#endif
    DBUG_RETURN (rtnval);
}


int s_setgid (gid)
int gid;
{
    int rtnval;
    
    DBUG_ENTER ("s_setgid");
#if unix || xenix
    rtnval = setgid (gid);
#else
    rtnval = 0;
#endif
    DBUG_RETURN (rtnval);
}


int s_fclose (stream)
FILE *stream;
{
    int rtnval;
    
    DBUG_ENTER ("s_fclose");
    rtnval = fclose (stream);
    DBUG_RETURN (rtnval);
}


char *s_fgets (s, n, stream)
char *s;
int n;
FILE *stream;
{
    char *rtnval;
    
    rtnval = fgets (s, n, stream);
    return (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_readlink    read a symbolic link
 *
 *  SYNOPSIS
 *
 *	int s_readlink (name, buf, size);
 *	char *name;
 *	char *buf;
 *	int size;
 *
 *  DESCRIPTION
 *
 *	Read a symbolic link on systems that have symbolic links.
 *	Is a NOP on other systems and just returns SYS_ERROR.
 *
 *	Under SUN's 3.2 OS, readlink() may return garbage if the first
 *	argument is one of the special files in /dev.  So, we must
 *	avoid calling readlink for anything except real symbolic links.
 *	Readlink is documented to leave ENXIO in errno if the name is
 *	not a symbolic link, so that's what we do also...
 *
 */

/*ARGSUSED*/	/* Turn off lint checking for unused args in s_readlink */

int s_readlink (name, buf, size)
char *name, *buf;
int size;
{
    int rtnval;
#if HAVE_SYMLINKS
    struct bstat bsbuf;			/* Used to avoid SUN 3.2 bug */
#endif

    DBUG_ENTER ("s_readlink");
#if HAVE_SYMLINKS
    if (bstat (name, &bsbuf, FALSE) == NULL) {
	rtnval = SYS_ERROR;
    } else {
	if (IS_FLNK (bsbuf.bst_mode)) {
	    rtnval = readlink (name, buf, size);
	} else {
	    errno = ENXIO;
	    rtnval = SYS_ERROR;
	}
    }
#else
    rtnval = SYS_ERROR;
#endif
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_timezone    get local time zone information
 *
 *	S5 defines an extern long timezone == difference in seconds between
 *	GMT and local standard time. BSD does not have this extern, but it
 *	will tell us what our timezone is in minutes west of GMT. So we
 *	just compute it on the fly.
 *
 */

#define SEC_PER_MIN (60)

#if HAVE_TZSET

long s_timezone ()
{
    tzset ();
    return (timezone);
}

#else

#if HAVE_GETTIMEOFDAY

long s_timezone ()
{
    long timezone;
    struct timeval tv;
    struct timezone tz;

    (VOID) gettimeofday (&tv, &tz);
    timezone = tz.tz_minuteswest * SEC_PER_MIN;
    return (timezone);
}

#endif	/* HAVE_GETTIMEOFDAY */
#endif	/* HAVE_TZSET */


#if HAVE_SYMLINKS

/*
 * Supply these routines on our own for 4.2.  Make them static (if
 * appropriate) to keep this stuff all in one file.
 */

/* s_symlink --- make a symbolic link */

int s_symlink (name1, name2)
char *name1, *name2;
{
    int rtnval;

    DBUG_ENTER ("s_symlink");
    rtnval = symlink (name1, name2);
    DBUG_RETURN (rtnval);
}

#if pyr

/* s_csymlink --- make a conditional symbolic link */

int s_csymlink (name1, name2)
char *name1, *name2;
{
    int rtnval;

    DBUG_ENTER ("s_symlink");
    rtnval = csymlink (name1, name2);
    DBUG_RETURN (rtnval);
}

#endif	/* pyr */
#endif	/* HAVE_SYMLINKS */

/*ARGSUSED*/	/* Turn off lint checking for unused args in s_eject */

int s_eject (fildes)
int fildes;
{
    int rtnval = 0;

    DBUG_ENTER ("s_eject");
    DBUG_PRINT ("eject", ("eject media on fildes %d", fildes));
#if AUX
    rtnval = s_ioctl (fildes, AL_EJECT, 0);
#endif
    DBUG_RETURN (rtnval);
}


/*ARGSUSED*/	/* Turn off lint checking for unused args in s_format */

s_format (fildes)
int fildes;
{
    int status = 0;
#if AUX
    struct diskformat fmt;

    fmt.d_secsize = 512;
    fmt.d_dens = 2;
    fmt.d_fsec = 0;
    fmt.d_lsec = 1599;
    fmt.d_fhead = 0;
    fmt.d_lhead = 1;
    fmt.d_fcyl = 0;
    fmt.d_lcyl = 79;
    fmt.d_ileave = 1;
    status = !(ioctl (fildes, UIOCFORMAT, &fmt) == -1);
#endif
    return (status);
}


/*
 *  FUNCTION
 *
 *	s_strdup   make a duplicate of a string in new memory
 *
 *  SYNOPSIS
 *
 *	char *s_strdup (string)
 *	char *string;
 *
 *  DESCRIPTION
 *
 *	Given pointer to a string, allocates sufficient memory to make
 *	a duplicate copy, and copies the string to the newly allocated
 *	memory.  Returns pointer to the new string on success, NULL
 *	on failure.
 *
 */


char *s_strdup (string)
char *string;
{
    char *new;

    if ((new = s_malloc ((UINT) (strlen (string) + 1))) != NULL) {
	(VOID) s_strcpy (new, string);
    }
    return (new);
}

#if HAVE_SHM

int s_kill (pid, sig)
int pid;
int sig;
{
    int status;

    DBUG_ENTER ("s_kill");
    DBUG_PRINT ("kill", ("kill pid %d with sig %d", pid, sig));
    status = kill (pid, sig);
    DBUG_PRINT ("kill", ("kill returns %d", status));
    DBUG_RETURN (status);
}

#endif
@


37.1
log
@New version January 1991
@
text
@d24 1
a24 1
 *	@@(#)sys.c	12.6	01 Jan 1991
@


37.0
log
@added to rcs
@
text
@d24 1
a24 1
 *	@@(#)sys.c	11.20	10/10/89
d54 1
a54 2
#include "autoconfig.h"
#include "config.h"
a55 59
#if HAVE_VARARGS
#  include <varargs.h>		/* Use system supplied varargs */
#else
#  include "vargs.h"		/* Use our "fake" varargs */
#endif

#if RMT				/* Want remote mag tape support via /etc/rmt */
#  if SYSRMTLIB			/* Use the installed system version */
#    include <local/rmt.h>	/* Remote mag tape functions, if available */
#  else				/* Else use our local internal copy */
#    include "rmt.h"		/* Local copy's include file */
#  endif
#endif

#if (amiga && LATTICE)
#  define NARGS			/* stdio.h defines some args incompatibly */
#endif

#include <stdio.h>

#if amiga
#  include <errno.h>
#endif

#if (unix || xenix)
#  include <sys/types.h>
#  include "utsname.h"
#  include <sys/stat.h>
#  include <pwd.h>
#  include <grp.h>
#  include <fcntl.h>
#else
#  include "utsname.h"
#  include "sys.h"
#endif

#include <ctype.h>

#if unix || xenix
#  if BSD4_2
#    include <sys/wait.h>		/* Used by s_wait() */
#    include <sys/time.h>		/* Used by s_timezone() */
#  else
#    include <time.h>
#  endif
#  if HAVE_SYMLINKS
#      include <errno.h>
#  endif
#endif

#include "typedefs.h"		/* Type definitions */
#include "dbug.h"		/* Macro based debugger file */
#include "manifest.h"		/* Manifest constants */
#include "macros.h"		/* Useful macros */
#include "usermsg.h"		/* Error codes */

extern FILE *errfp;		/* Stream error messages written to */
extern VOID bru_message ();	/* Report an error to user */

a91 2
    extern int vfprintf ();			/* See vprintf(3S) */

a93 1
    extern int fprintf ();
d132 4
a135 4
int s_fprintf (stream, format, va_alist)
FILE *stream;
char *format;
va_dcl
d138 1
a138 1
    auto va_list args;
d140 1
a140 1
    va_start (args);
a181 1
    extern int vsprintf ();
a184 5
#if BSD4_2
    extern char *sprintf ();			/* See printf(3S) */
#else
    extern int sprintf ();			/* See printf(3S) */
#endif
d230 4
a233 4
int s_sprintf (s, format, va_alist)
char *s;
char *format;
va_dcl
d238 1
a238 1
    va_start (args);
a264 5
    extern int abort ();			/* See abort(3C) */
#ifndef fflush					/* fflush() sometimes macro */
    extern int fflush ();			/* See fclose(3S) */
#endif

d296 1
a296 2
    register int rtnval;
    extern int open ();			/* See open(2) */
d300 1
a300 1
#if amiga
d314 1
a314 1
    DBUG_PRINT ("open", ("open on stream %d", rtnval));
d344 2
d351 1
a351 2
    register int rtnval;
    extern int open ();			/* See open(2) */
d390 1
a390 2
    register int rtnval;
    extern int close ();			/* See close(2) */
d393 2
a394 2
    DBUG_PRINT ("close", ("close stream %d", fildes));
#if amiga
d432 1
a432 2
    register int rtnval;
    extern int access ();			/* See access(2) */
d436 1
a436 1
#if amiga
d473 1
a473 2
    register int rtnval;
    extern int read ();			/* See read(2) */
d476 2
a477 2
    DBUG_PRINT ("read", ("read %u bytes from stream %d", nbyte, fildes));
#if amiga
d514 1
a514 2
    register int rtnval;
    extern int chown ();			/* See chown(2) */
a545 11
#if unix || xenix
#if BSD4_2
    extern int sleep ();			/* See sleep(3C) */
#else
    extern UINT sleep ();			/* See sleep(3C) */
#endif
#endif
#if amiga
    extern int Delay ();
#endif

d550 1
a550 1
#if amiga
d565 1
a565 1
 *	struct my_utsname *name;
a570 16
 *	Previous versions just either picked up a copy of utsname from
 *	the <sys/utsname.h> file, or the faked version.  In both cases
 *	the structure was identical, and of the same size.  Then along
 *	came xenix release 3.0, with a slightly different layout for
 *	the utsname structure, and I realised that it was a bad idea
 *	to blindly use the utsname structure directly in the declarations
 *	to describe archive blocks.  This is really an internal data
 *	structure containing system information, that simply happens
 *	to have a one-to-one mapping with a system structure on some
 *	systems, but not all.  Thus was born the my_utsname structure
 *	and the policy of filling the my_utsname structure from the
 *	actual contents of a real utsname structure, if available.
 *
 *	Note that the size of each element is defined to be 9 by
 *	the documentation (yes, size is hardwired in...).
 *
d574 1
a574 1
struct my_utsname *name;
d576 1
a576 4
    register int rtnval;
    extern int uname ();			/* See uname(2) */
    extern struct utsname utsname;
    extern char *s_strncpy ();
d579 1
a579 10
    rtnval = uname (&utsname);
    (VOID) s_strncpy (name -> sysname, utsname.sysname, 9 - 1);
    (VOID) s_strncpy (name -> nodename, utsname.nodename, 9 - 1);
    (VOID) s_strncpy (name -> release, utsname.release, 9 - 1);
    (VOID) s_strncpy (name -> version, utsname.version, 9 - 1);
#if HAVE_UTSNAME_MACHINE
    (VOID) s_strncpy (name -> machine, utsname.machine, 9 - 1);
#else
    (VOID) s_strncpy (name -> machine, "unknown", 9 - 1);
#endif
d603 1
a603 2
    register int rtnval;
    extern int umask ();			/* See umask(2) */
d624 1
a624 1
 *	struct {time_t x,y;} *times;
a632 6
 *	The structure declaration is used to match that in the
 *	lint library /usr/lib/llib-lc, to shut up lint.
 *	The Unix System V User's Manual has the type of the
 *	second argument as a pointer to a structure "utimbuf",
 *	which is not declared anywhere in the header files.
 *
d642 1
a642 1
struct {time_t x, y;} *times;
d644 1
a644 2
    register int rtnval;
    extern int utime ();			/* See utime(2) */
d686 1
a686 4
    register int rtnval;
#if unix || xenix || (amiga && LATTICE)
    extern int chmod ();			/* See chmod(2) */
#endif
d689 14
a702 4
#if (amiga && LATTICE)
    mode >>= 5;
    mode &= 0xF;
    mode |= 1;
a703 1
#if unix || xenix || (amiga && LATTICE)
d705 1
a705 17
#else
    rtnval = 0;
#endif
#if (amiga && LATTICE && VANILLA3_10)
    /*
     *  Bug in vanilla Lattice 3.10 always gives result of 0 for
     *  mode == 0, or gives 0 for failure and -1 for success for
     *  mode != 0.  So map these to correct returns...
     */
    if (mode != 0) {
	if (rtnval == 0) {
	    rtnval = -1;
	} else {
	    rtnval = 0;
	}
    }
#endif
d733 1
a733 2
    register int rtnval;
    extern int write ();			/* See write(2) */
d736 2
a737 2
    DBUG_PRINT ("write", ("write %u bytes to stream %d", nbyte, fildes));
#if amiga
d747 1
a747 1
    DBUG_PRINT ("write", ("write returns %d", rtnval));
d772 1
a772 2
    register int rtnval;
    extern int unlink ();			/* See unlink(2) */
d803 1
a803 9
    register long rtnval;
#if BSD4_2 && lint
    extern time_t time ();			/* See time(2) */
#else
    extern long time ();			/* See time(2) */
#endif
#if MANX
    extern long manx2unix ();
#endif
a810 3
#if MANX
    rtnval = manx2unix (rtnval);
#endif
d849 1
a849 3
#if HAVE_ULIMIT
    extern long ulimit ();
#else
d891 1
a891 2
    register int rtnval;
    extern int getuid ();			/* See getuid(2) */
d920 1
a920 2
    register int rtnval;
    extern int getgid ();			/* See getgid(2) */
a934 27
 *	s_gets    get a string from a stream
 *
 *  SYNOPSIS
 *
 *	char *s_gets (s)
 *	char *s;
 *
 *  DESCRIPTION
 *
 *	Invoke the standard library routine gets.
 *
 */

char *s_gets (s)
char *s;
{
    register char *rtnval;
    extern char *gets ();			/* See gets(3S) */ 
    
    rtnval = gets (s);
    return (rtnval);
}


/*
 *  FUNCTION
 *
d955 1
a955 5
    register char *rtnval;
#if MANX
    auto long myclock;
#endif
    extern char *ctime ();			/* See ctime(3C) */
a957 5
#if MANX
    myclock = unix2manx (*clock);
    clock = &myclock;
    DBUG_PRINT ("ctime", ("convert 'Manx' time %ld", *clock));
#endif
d991 1
a991 7
    register struct tm *rtnval;
    extern struct tm *localtime ();		/* See ctime(3C) */
#if MANX
    struct manx_tm *tmp;
    auto long myclock;
    static struct tm mytm;
#endif
a994 5
#if MANX
    myclock = unix2manx (*clock);
    clock = &myclock;
    DBUG_PRINT ("localtime", ("convert 'Manx' time %ld", *clock));
#endif
a999 13
#if MANX
    tmp = (struct manx_tm *) rtnval;
    mytm.tm_sec = tmp -> tm_sec;
    mytm.tm_min = tmp -> tm_min;
    mytm.tm_hour = tmp -> tm_hour;
    mytm.tm_mday = tmp -> tm_mday;
    mytm.tm_mon = tmp -> tm_mon;
    mytm.tm_year = tmp -> tm_year;
    mytm.tm_wday = tmp -> tm_wday;
    mytm.tm_yday = tmp -> tm_wday;
    mytm.tm_isdst = tmp -> tm_isdst;
    rtnval = &mytm;
#endif    
d1024 1
a1024 5
    register char *rtnval;
    extern char *asctime ();		/* See ctime(3C) */
#if MANX
    static struct manx_tm mytm;
#endif
a1026 12
#if MANX
    mytm.tm_sec = tm -> tm_sec;
    mytm.tm_min = tm -> tm_min;
    mytm.tm_hour = tm -> tm_hour;
    mytm.tm_mday = tm -> tm_mday;
    mytm.tm_mon = tm -> tm_mon;
    mytm.tm_year = tm -> tm_year;
    mytm.tm_wday = tm -> tm_wday;
    mytm.tm_yday = tm -> tm_wday;
    mytm.tm_isdst = tm -> tm_isdst;
    tm = (struct tm *) &mytm;
#endif
d1054 1
a1054 2
    register FILE *rtnval;
    extern FILE *fopen ();			/* See fopen(3S) */
d1093 1
a1093 4
    register int rtnval;
#if unix || xenix
    extern int mknod ();			/* See mknod(2) */
#endif
d1139 1
a1139 2
    register long rtnval;
    extern long strtol ();			/* See strtol(3C) */
a1149 84
 *	s_stat    get file status
 *
 *  SYNOPSIS
 *
 *	int s_stat (path, buf)
 *	char *path;
 *	struct stat *buf;
 *
 *  DESCRIPTION
 *
 *	Invoke low level routine to get file status.
 *
 *	Under 4.2BSD, we use the lstat routine instead, which
 *	will tell us whether or not we've found a symbolic link.
 *	An lstat on a normal file acts just like regular stat.
 *
 */

/*VARARGS1*/	/* Funny stuff with 2nd arg due to rmt.h define of stat */
int s_stat (path, buf)
char *path;
struct stat *buf;
{
    register int rtnval;
#if HAVE_SYMLINKS
    extern int lstat ();			/* See stat(2) */
#else
    extern int stat ();				/* See stat(2) */
#endif

    DBUG_ENTER ("s_stat");
#if HAVE_SYMLINKS
    rtnval = lstat (path, buf);
#else
    rtnval = stat (path, buf);
#endif
    DBUG_RETURN (rtnval);
}


/*
 *  FUNCTION
 *
 *	s_fstat    get file status
 *
 *  SYNOPSIS
 *
 *	int s_fstat (fildes, buf)
 *	int fildes;
 *	struct stat *buf;
 *
 *  DESCRIPTION
 *
 *	Invoke low level routine to get file status, using an open file
 *	descriptor.  Currently only used by the directory access routines
 *	under USG, so we don't need a BSD equivalent (lfstat ?).
 *
 */

#if (!HAVE_SEEKDIR) || amiga
int s_fstat (fildes, buf)
int fildes;
struct stat *buf;
{
    register int rtnval;
#if unix || xenix
    extern int fstat ();			/* See stat(2) */
#endif

    DBUG_ENTER ("s_fstat");
#if unix || xenix
    rtnval = fstat (fildes, buf);
#else
    (VOID) s_fprintf (errfp, "warning -- fstat() not implemented!\n");
    rtnval = SYS_ERROR;
#endif
    DBUG_RETURN (rtnval);
}
#endif  /* (!HAVE_SEEKDIR) || amiga */


/*
 *  FUNCTION
 *
d1166 1
a1166 3
    register char *rtnval;
    extern char *malloc ();			/* See malloc(3C) */
    extern int errno;
a1192 6
#if BSD4_2
    extern int exit ();			/* See exit(2) */
#else
    extern VOID exit ();			/* See exit(2) */
#endif

d1223 1
a1223 2
    register int rtnval;
    extern int getopt ();			/* See getopt(3C) */
a1250 6
#if BSD4_2
    extern int free ();			/* See malloc(3C) */
#else
    extern VOID free ();			/* See malloc(3C) */
#endif

d1293 1
a1293 1
    register struct passwd *rtnval;
a1294 1
    extern struct passwd *getpwent ();		/* See getpwent(3C) */
d1297 1
a1297 1
    if (pwentopen == TRUE) {
a1327 1
    extern int endpwent ();		/* See getpwent(3C) */
a1329 1
    extern VOID endpwent ();		/* See getpwent(3C) */
d1365 2
a1366 1
    register struct group *rtnval;
a1367 1
    extern struct group *getgrent ();		/* See getgrent(3C) */
d1370 1
a1370 1
    if (grentopen == TRUE) {
a1400 1
    extern int endgrent ();		/* See getgrent(3C) */
a1402 1
    extern VOID endgrent ();		/* See getgrent(3C) */
d1460 1
a1460 4
    register SIGTYPE rtnval;
#if unix || xenix || amiga
    extern SIGTYPE signal ();		/* See signal(2) */
#endif
d1464 1
a1464 1
#if unix || xenix || amiga
a1477 29
 *	s_sscanf    convert formatted input from buffer
 *
 *  SYNOPSIS
 *
 *	VOID s_sscanf (s, format [ , pointer ] ... )
 *	char *s;
 *	char *format;
 *
 *  DESCRIPTION
 *
 *	Calls routine from standard library to do formatted input.
 *
 */

/*VARARGS2*/
VOID s_sscanf (s, format, a1, a2, a3, a4, a5, a6, a7, a8, a9)
char *s;
char *format;
char *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8, *a9;
{
    extern int sscanf ();			/* See scanf (3S) */

    (VOID) sscanf (s, format, a1, a2, a3, a4, a5, a6, a7, a8, a9);
}


/*
 *  FUNCTION
 *
d1496 1
a1496 4
    register int rtnval;
#if unix || xenix
    extern int ioctl ();			/* See ioctl(2) */
#endif
d1535 1
a1535 2
    register char *rtnval;
    extern char *strcat ();
d1563 1
a1563 2
    register int rtnval;
    extern int strcmp ();
d1590 1
a1590 2
    register char *rtnval;
    extern char *strcpy ();
d1619 1
a1619 2
    register char *rtnval;
    extern char *strncpy ();
d1646 1
a1646 2
    register int rtnval;
    extern int strlen ();
d1662 1
a1662 1
 *	char c;
d1667 3
a1669 1
 *	string character c, returning pointer.
a1672 4
#if BSD4_2
#define strchr index
#endif

d1675 1
a1675 1
char c;
d1677 3
a1679 3
    register char *rtnval;
#if unix || xenix
    extern char *strchr ();
d1682 3
d1692 2
a1693 1
#endif
d1713 2
a1717 4
#if BSD4_2
#define strrchr rindex
#endif

d1720 1
a1720 1
char c;
d1722 2
a1723 3
    register char *rtnval;
#if unix || xenix
    extern char *strrchr ();
d1726 3
d1741 2
a1742 1
#endif
d1830 3
d1837 2
a1840 3
    register int rtnval;
    extern int mkdir ();

d1847 3
a1849 5
    register int rtnval;
    register char *leaf;
    auto char parent[NAMESIZE];
    auto char entries[NAMESIZE+4];
    extern int errno;			/* System error return code */
d1853 2
a1854 2
    if (s_strlen (path) > (NAMESIZE - 2)) {
	errno = 0;				/* bogus errno */
d1892 2
d1919 1
a1919 2
    register S32BIT rtnval;
    extern S32BIT lseek ();			/* See lseek(2) */
d1924 1
a1924 1
#if amiga
a1942 4
#ifndef tolower					/* A macro on some systems */
    extern int tolower ();			/* See conv(3C) */
#endif

d1960 1
a1960 2
    register int rtnval;
    extern int creat ();			/* See creat(2) */
d1978 1
a1978 2
    register int rtnval;
    extern int atoi ();			/* See strtol(3C) */
d1993 6
d2004 4
a2007 1
#if BSD4_2
a2010 1
#if xenix || z8000 || (amiga && MANX)
d2016 21
d2038 6
a2043 4
    extern char *memcpy ();			/* See memory(3C) */
    return (memcpy (s1, s2, n));
#endif
#endif
d2050 1
a2050 4
    register int rtnval;
#if unix || xenix
    extern int link ();			/* See link(2) */
#endif
d2064 1
a2064 1
 *	For the amiga version, we only need to fake a dup for
d2072 1
a2072 1
    register int rtnval;
d2078 1
a2078 1
#if amiga
d2097 1
a2097 2
    register char *rtnval;
    extern char *getenv ();			/* See getenv(3C) */
d2107 1
a2107 2
    register int rtnval;
    extern int fork ();			/* See fork(2) */
d2120 9
a2128 1
int s_wait (stat_loc)
d2131 1
a2131 2
    register int rtnval;
    extern int wait ();			/* See wait(2) */
d2135 1
a2135 1
#if BSD4_2
d2137 3
d2142 4
d2147 1
d2151 2
d2165 1
a2165 2
    register int rtnval;
    extern int execv ();			/* See exec(2) */
d2172 1
a2172 1
#if amiga
d2186 1
a2186 2
    register int rtnval;
    extern int setuid ();			/* See setuid(2) */
d2201 1
a2201 1
    register int rtnval;
d2216 1
a2216 2
    register int rtnval;
    extern int fclose ();			/* See fclose(3S) */
d2229 1
a2229 2
    register char *rtnval;
    extern char *fgets ();			/* See gets(3S) */
d2267 1
a2267 1
    register int rtnval;
d2269 1
a2269 3
    struct stat sbuf;			/* Used to avoid SUN 3.2 bug */
    extern int readlink ();		/* See readlink(2) */
    extern int errno;			/* System error return code */
d2274 1
a2274 1
    if (s_stat (name, &sbuf) == SYS_ERROR) {
d2277 1
a2277 1
	if (IS_FLNK (sbuf.st_mode)) {
d2305 2
a2306 1
#if BSD4_2
d2309 1
a2309 6
    auto long timezone;
    struct timeval tv;
    struct timezone tz;

    (VOID) gettimeofday (&tv, &tz);
    timezone = tz.tz_minuteswest * SEC_PER_MIN;
a2311 1
#endif
a2312 6
#if USG5 || (amiga && LATTICE)
long s_timezone ()
{
    extern long timezone;
#if xenix
    extern void tzset ();			/* VOID may not be void */
a2313 2
    extern VOID tzset ();
#endif
d2315 1
a2315 4
    tzset ();
    return (timezone);
}
#endif
a2316 1
#if amiga && MANX
d2319 7
a2325 1
    return (0L);
a2326 1
#endif
d2328 3
d2344 1
a2344 2
    register int rtnval;
    extern int symlink ();			/* See symlink(2) */
d2358 1
a2358 2
    register int rtnval;
    extern int csymlink ();			/* See csymlink(2) for OSx */
d2368 1
a2368 3
#if AUX
#include <sys/ssioctl.h>	/* Contains special ioctl's for Apple A/UX */
#endif
a2382 5
#if AUX
#include <sys/diskformat.h>
#include <sys/ioctl.h>
#include <errno.h>
#endif
d2384 2
d2391 1
a2391 1
    auto struct diskformat fmt;
d2431 1
a2431 1
    register char *new;
a2445 1
    extern int kill ();
@
