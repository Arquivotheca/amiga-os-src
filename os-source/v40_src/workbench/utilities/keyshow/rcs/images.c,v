head     1.1;
branch   ;
access   ;
symbols  V36_8:1.1 V36_7:1.1;
locks    ; strict;
comment  @ * @;


1.1
date     90.04.19.15.22.08;  author eric;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@
#include "keytoy.h"
extern struct Remember *RememberKey;

extern struct Image CheckImage, UpImage, DownImage, RightImage, LeftImage;
extern struct Image CapsImage, HelpImage, DelImage, CtrlImage, AltImage;
extern struct Image ELShiftImage, RShiftImage, ULShiftImage;


UWORD IData[] = {
    /* CheckIData */
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x06c0,
    0x0000, 0x1b00,
    0x0000, 0x6c00,
    0x0001, 0xb000,
    0x3606, 0xc000,
    0x0d9b, 0x0000,
    0x036c, 0x0000,
    0x00f0, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,

    /* UpIData */
    0xffff, 0xffff,
    0xf9ff, 0xffff,
    0xf0ff, 0xffff,
    0xe07f, 0xffff,
    0xc93f, 0xffff,
    0xf9ff, 0xffff,
    0xf9ff, 0xffff,
    0xffff, 0xffff,
    0xffff, 0xffff,

    /* DownIData */
    0xffff, 0xffff,
    0xffff, 0xffff,
    0xf9ff, 0xffff,
    0xf9ff, 0xffff,
    0xc93f, 0xffff,
    0xe07f, 0xffff,
    0xf0ff, 0xffff,
    0xf9ff, 0xffff,
    0xffff, 0xffff,

    /* RightIData */
    0xffff, 0xffff,
    0xfffe, 0x3fff,
    0xffff, 0x07ff,
    0xff00, 0x03ff,
    0xffff, 0x07ff,
    0xfffe, 0x3fff,
    0xffff, 0xffff,
    0xffff, 0xffff,
    0xffff, 0xffff,

    /* LeftIData */
    0xffff, 0xffff,
    0xf1ff, 0xffff,
    0x83ff, 0xffff,
    0x0003, 0xffff,
    0x83ff, 0xffff,
    0xf1ff, 0xffff,
    0xffff, 0xffff,
    0xffff, 0xffff,
    0xffff, 0xffff,

    /* CapsIData */
    0xffff, 0xffff,
    0xe1ff, 0xffff,
    0xe1ff, 0xffff,
    0xffff, 0xffff,
    0xffff, 0xffff,
    0xffff, 0xffff,
    0xffff, 0xffff,
    0xffff, 0xffff,
    0xffff, 0xffff,

    /* HelpIData */
    0xffff, 0xffff,
    0x9213, 0x87ff,
    0x9273, 0x93ff,
    0x8233, 0x87ff,
    0x9273, 0x9fff,
    0x9210, 0x9fff,
    0xffff, 0xffff,
    0xffff, 0xffff,
    0xffff, 0xffff,

    /* DelIData */
    0xffff, 0xffff,
    0xc386, 0x7fff,
    0xc99e, 0x7fff,
    0xcd8e, 0x7fff,
    0xc99e, 0x7fff,
    0xc386, 0x0fff,
    0xffff, 0xffff,
    0xffff, 0xffff,
    0xffff, 0xffff,

    /* CtrlIData */
    0x0000, 0x0000,
    0x7fbc, 0xc000,
    0xc336, 0xc000,
    0xc33c, 0xc000,
    0xc336, 0xc000,
    0x7336, 0xf800,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,

    /* AltIData */
    0x0000, 0x0000,
    0x0303, 0x07e0,
    0x0783, 0x0180,
    0x0cc3, 0x0180,
    0x1fe3, 0x0180,
    0x3033, 0xf180,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,

    /* ELShiftIData */
    0x0000, 0x0000, 0x0000,
    0x1ecd, 0xefbf, 0x0000,
    0x30cc, 0xcc0c, 0x0000,
    0x1cfc, 0xcf0c, 0x0000,
    0x06cc, 0xcc0c, 0x0000,
    0x3ccd, 0xec0c, 0x0000,
    0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000,

    /* RShiftIData */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x1ecd, 0xefbf, 0x0000, 0x0000, 0x0000,
    0x30cc, 0xcc0c, 0x0000, 0x0000, 0x0000,
    0x1cfc, 0xcf0c, 0x0000, 0x0000, 0x0000,
    0x06cc, 0xcc0c, 0x0000, 0x0000, 0x0000,
    0x3ccd, 0xec0c, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    /* ULShiftIData */
    0x0000, 0x0000, 0x0000, 0x0000,
    0x1ecd, 0xefbf, 0x0000, 0x0000,
    0x30cc, 0xcc0c, 0x0000, 0x0000,
    0x1cfc, 0xcf0c, 0x0000, 0x0000,
    0x06cc, 0xcc0c, 0x0000, 0x0000,
    0x3ccd, 0xec0c, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000
};

InitImages()
{
    WORD i;
    UWORD *memBlock;

    if((memBlock = (UWORD *)AllocRemember(&RememberKey, sizeof(IData),
	MEMF_CHIP)) == NULL)
	failNotice("Internal system error", "Not enough memory");

    CheckImage.ImageData = memBlock;
    UpImage.ImageData = CheckImage.ImageData + 24;
    DownImage.ImageData = UpImage.ImageData + 18;
    RightImage.ImageData = DownImage.ImageData + 18;
    LeftImage.ImageData = RightImage.ImageData + 18;
    CapsImage.ImageData = LeftImage.ImageData + 18;
    HelpImage.ImageData = CapsImage.ImageData + 18;
    DelImage.ImageData = HelpImage.ImageData + 18;
    CtrlImage.ImageData = DelImage.ImageData + 18;
    AltImage.ImageData = CtrlImage.ImageData + 18;
    ELShiftImage.ImageData = AltImage.ImageData + 18;
    RShiftImage.ImageData = ELShiftImage.ImageData + 27;
    ULShiftImage.ImageData = RShiftImage.ImageData + 45;

    for (i = 0; i < (sizeof(IData)/2); i++)
	*memBlock++ = IData[i];
}

@
