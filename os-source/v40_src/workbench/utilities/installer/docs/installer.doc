

            Documentation for 2.16 Installer
            Last Revised: February 9th, 1993


Contents:

    1 Background

    2 Overview
      2.1  Standard Invocation
      2.2  Initial Actions
      2.3  Startup Screens
      2.4  Installation Actions

    3 Scripting Language Tutorial
      3.1  Basic Elements
      3.2  Escape Characters
      3.3  Symbols (Variables)
      3.4  Types of Symbols
      3.5  Statements
      3.6  Data Types
      3.7  Special Features
      3.8  Miscellaneous

    4 Installer Language Reference
      4.1  Notes
      4.2  Statements
      4.3  Control Statements
      4.4  Debugging Statements
      4.5  User-Defined Procedures
      4.6  Functions
      4.7  Summary of Parameters
      4.8  Pre-Defined Variables

    5 Installer Language Quick Reference
      5.1  Overview
      5.2  Quick Language Overview
      5.3  Pre-Defined Variables
      5.4  Default Help String Variables
      5.5  Statements
      5.6  Functions


                Section 1: Background

Installation of applications from floppy disks onto a hard disk has proven
to be a very inconsistent and often frustrating endeavor for most end-users.
This has been caused by many factors, some of which are:

    a. Many products do not come with any utility or script to install an
       application on a hard disk.

    b. Many products assume a great deal of familiarity with the startup
       process of the Amiga and applications, including assigns, device names
       (as opposed to volume names), etc.

    c. The installation scripts or utilities included with some products vary
       widely in their ability to deal with different environments and
       systems.

About a year ago, Commodore set out to remedy this situation, by developing
a standard tool that developers can include with their products, which
provides the user with a standard way to install applications.  The
Installer's features were based on a number of assumptions:

    a. Installation requirements vary widely---some need assigns, some need
       new drawers created, some install pieces in system drawers such as a
       fonts drawer, a `product' might be just an upgrade and the
       installation must check to see which version (if any) they currently
       have installed, etc.

    b. Different users have different levels of comfort and expertise when
       attempting to install software, and the Installer should be able to
       accommodate a range of users.  Many installation scripts assume a
       great deal of knowledge, which is very intimidating for a novice.

    c. The installer tool must be very flexible internally, but present a
       consistent pleasant graphical user interface to the user that only
       shows the user information or prompts that they need to see.  The
       Installer should be resolution, color and font sensitive.

    d. Writing scripts to install an application will require some effort,
       but certainly no more than writing an AmigaDOS shell script
       equivalent, and the resulting installation procedure will be more
       friendly, flexible, and much better looking than the latter.

    e. Not everyone will be running 2.0 by the time the tool becomes
       available, so it must run under 1.3 and 2.0.


                Section 2: Overview

The Installer is a script driven program, that presents a consistent
installation environment to the end user.  The user never sees the script.
Instead they are presented with simple yes/no choices, and may be asked to
specify locations to put things on their system.

To accommodate different user levels, they can choose to run the tool in
novice, average or expert modes.  Scripts can include help text to explain
any choices that the user must make.  At each step the user is given the
option of aborting the installation.




2.1  Standard Invocation

The Installer program requires a 10000 byte stack.  Project icons for
Installer script should indicate a stack size of 10000.  If starting
Installer from a CLI, first do a "Stack 10000".

The Installer is normally started up from a Workbench Project icon which has
the same name as the script to interpret and has a default tool of
Installer. A number of tooltypes are available to modify the operation of
the Installer:

    SCRIPT - Path to a script file to be used with Installer.

    APPNAME - Name of the application being installed (appears in the startup
              screen).  This MUST be given.

    MINUSER - The minimum possible operation mode of the installation for a
              script.  This will be either NOVICE (all decisions made by
              Installer), AVERAGE (only important decisions made by user) or
              EXPERT (user confirms almost all actions).  The Default is
              NOVICE.

    DEFUSER - Indicates which operation mode button should be initially
              selected.  Same values as MINUSER, with the value of the
              MINUSER tooltype being the default (which will be NOVICE if
              MINUSER not defined).

    NOPRINT - If set to FALSE, then the printer option in the log file
              settings will be ghosted.

    PRETEND - If set to FALSE, indicates that PRETEND mode not available for
              this script.

    LANGUAGE - Is used to set the variable @language (default for @language
               is "english".  Installer will attempt to load the
               corresponding language catalog to allow for language
               localization.

    LOGFILE - The name of the log file that the Installer should use.
              This must be a full path.  The default is "install_log_file".

    LOG - In NOVICE mode the default is to create a log file (to disk).
          If this tooltype is set to FALSE, the creation of a log file in
          NOVICE mode is disabled.

Although the installer can be started up from the CLI, that is not the
recommended mode.  CLI invocation is provided mainly for script debugging
purposes.  The command template is:

SCRIPT/k,APPNAME,MINUSER,DEFUSER,LOGFILE,NOLOG/s,NOPRETEND/s,
NOPRINT/s,LANGUAGE/k




2.2  Initial Actions

The first thing the installer does is compile the installation script into
an internal format that can be easily interpreted.  If there are syntax
errors in the script, they will be caught during this phase.




2.3  Startup Screens

Next, the Installer asks the user what Installation Mode to run in, either
NOVICE, AVERAGE or EXPERT.  If the user chooses NOVICE, they will not be
asked any more questions (although they may be requested to do things).  In
the other user levels, a second display appears asking the user if he wants
to install "for real" or "do a dry run", and if he wants a transcription of
the installation process written to either a file or printer.




2.4  Installation Actions

Now the Installer interprets its internal version of the script.  Any
commands that call for a user interface will cause the Installer to
algorithmically generate a display, always including buttons to allow for
context sensitive help and aborting the installation.


            Section 3: Scripting Language Tutorial

The script language of the Installer is based on LISP.  It is not difficult
to learn, but requires a lot of parentheses.  An Installer script can easily
be made to look very readable.




3.1  Basic Elements

The basic elements of the installer language are:

    Type                  Example
    ----                  -------
    decimal integers      5
    hexadecimal integers  $a000
    binary integers       %0010010
    strings               "Hello" or 'Hello'
    symbols               x
    comments              ; this is a comment
    ( )                   for statement definition
    space                 delimits symbols
     (or any white space)




3.2  Escape Characters

Escape characters are supported as in the C language:

    Escape
    sequence  Produces
    --------  --------
    '\n'      newline character
    '\r'      return character
    '\t'      tab character
    '\0'      a NUL character
    '\"'      a double-quote
    '\\'      a backslash




3.3  Symbols (Variables)

A symbol is any sequence of characters surrounded by spaces that is not a
quoted string, an integer or a control character.  This means that symbols
can have punctuation marks and other special characters in them.  The
following are all valid symbols:

    x
    total
    this-is-a-symbol
    **name**
    @#__#@




3.4  Types of Symbols

There are three types of symbols:

    a. user-defined symbols.  These are created using the "set" function.

    b. built-in function names.  These include things like '+' and '*' as
       well as textual names such as "delete" or "rename".

    c. special symbols.  These are variables which are created by the
       installer before the script actually starts to run, and are used to
       tell the script certain things about the environment. These symbols
       always begin with an '@' sign.  An example is '@default-dest' which
       tells you the default directory that was selected by the installer.




3.5  Statements

The format of a statement is:

    (operator <operand1> <operand2> ...)

A statement to assign the value '5' to the variable 'x' would be:

    (set x 5)

You can read this as "set x to 5".  Note that the variable 'x' does not have
to be declared -- it is created by this statement.

Note that there is no difference between operators and functions -- the
function 'set' and the arithmetic operator '+' are both used exactly the
same way.

Combining statements: A statement can be used as the operand to another
statement as follows:

    (set var (+ 3 5))

In this case, the statement '(+ 3 5)' is evaluated first, and the result is
8. You can think of this as having the '(+ 3 5)' part being replaced by an
8. So now we are left with:

    (set var 8)

which is the same form as the first example.

Note that the '(+ 3 5)' part actually produced a value: 8.  This is called
the "result" of the statement.  Many statements return results, even some
that might surprise you (such as "set" and "if").




3.6  Data Types

All data types in the installer are dynamic, that is to say the type of a
variable is determined by the data that is in it.  So if you assign the
string "Hello, World" to the variable 'x', then 'x' will be of type STRING.
Later you can assign an integer to 'x' and x will be of type INTEGER.  When
using variables in expressions, the interpreter will attempt to convert to
the proper type if possible.

Special forms: There are two exceptions to the form of a statement.  The
first type is used for string substitution: If the first item in parentheses
is a text string rather than a function name, the result of that clause is
another string that is created by taking the original string and performing
a "printf"-like formatting operation on it, using the other arguments of the
statement as parameters to the formatting operation.

Thus the statement:

    ("My name is %s and I am %ld years old" "Mary" 5)

Becomes:

    "My name is Mary and I am 5 years old"

Note since the formatting operation uses the ROM "RawDoFmt" routine, decimal
values must always be specified with "%ld" rather than "%d" (The interpreter
always passes numeric quantities as longwords).  Note that a variable
containing the string may be used rather than the string itself.

The second type of exception occurs if the elements in parentheses are
themselves statements in parentheses.  In this case, the interpreter assumes
that all the elements are statements to be executed sequentially.

For example, this statement sets the value of three different variables:
"var1", "var2" and "var3".

    ((set var1 5) (set var2 6) (set var3 7))

What this feature does is allow the language to have a block structure,
where an "if" statement can have multiple statements in its "then" or "else"
clause. Note that the result of this statement will be the result of the
last statement in the sequence.

Complex statements: Here is an example of how statements in the script
language can be combined into complex expressions.  We will start with an
"if" statement. The basic format of an "if" statement is:

    (if <condition> <then-statement> [<else-statement>])

The condition should be a statement which returns a value.  The "then" and
optional "else" parts should be statements.  Note that if the "then" or
"else" statements produce a result, then the "if" statement will also have
this result.

Our first example is a rather strange one: Using an "if" statement to
simulate a boolean "not" operator. (Note that there are easier ways in the
script language to do this).

    (set flag 0)              ; set a flag to FALSE

    (set flag (if flag 0 1))  ; a Boolean NOT

Basically, the "if" statement tests the variable "flag".  If flag is
non-zero, it produces the value "0".  Otherwise, the result is "1".  In
either case, "flag" is set to the result of the "if" statement.

Now, let's plug some real statements into our "if" statement.

    (if flag                                ; conditional test
        (message "'flag' was non-zero\n")   ; "then" clause.
        (message "'flag' was zero\n")       ; "else" clause.
    )                                       ; closing parenthesis

Note the style of the indenting.  This makes for an easier to read program.

Now, we'll add a real condition.  "=" tests for equality of the two items.

    (if (= a 2)                    ; conditional test
        (message "a is 2\n")       ; "then" clause
        (message "a is not 2\n")   ; "else" clause
    )                              ; closing parenthesis

Finally, just to make things interesting, we'll make the "else" clause a
compound statement.

    (if (= a 2)                           ; conditional test
        (message "a is 2\n")              ; "then" clause
        (    (message "a is not 2\n")      ; "else" compound statement
            (set a 2)
            (message "but it is now!\n")
        )                                 ; end of compound statement
    )                                     ; end of if




3.7  Special Features

When the Installer first starts up, it attempts to determine the "best"
place to install the application.  Any volume named "WORK:" is given
preference, as this is the standard way that an Amiga comes configured from
Commodore.

There are two keyboard shortcuts.  Whenever there is a "Help" button active,
pressing the HELP key will also bring up the help display.  Whenever there
is an "Abort" button active, pressing ESC brings up the abort requester.
Also, whenever the installer is "busy", pressing ESC brings up the abort
requester -- there is text is the title bar to that effect.

If an application must have assigns or other actions performed during system
boot, the Installer will add these to a file named "S:user-startup". The
installer will then add the lines

    if exists S:user-startup
    execute S:user-startup
    endif

to the user's "startup-sequence".  The Installer will attempt to determine
the boot volume of the system when looking for the "startup-sequence" and
can handle any AmigaDOS scripts executed from "startup-sequence" (up to 10
levels of nesting).

The Installer can create an assign to just a device, volume or logical
assignment.  This comes in handy when you want to update an application
which comes on a volume named "MyApp:", but the installed version is in a
directory with the logical assign "MyApp:"!

The Installer always copies files in CLONE mode, meaning all the protection
bits, filenotes and file dates are preserved.  When copying files the
Installer gives a "fuelgauge" readout of the progress of the copy.

The Installer can find the version number of any executable file that has
either a RomTag with an ID string (such as libraries and devices) or has a
version string conforming to that given in the 1990 DevCon notes.  The
Installer can also checksum files.  A separate utility named "instsum" is
provided to determine a file's checksum for use with this feature.




3.8  Miscellaneous

To perform a set of actions on all the contents of a directory matching a
pattern you can use the "foreach" operator.  To perform a set of actions on
an explicit set of files, the following installer statements can be used as
a template:

    (set n 0)
    (while (set thisfile (select n "file1" "file2" "file3" ""))
        (    (set n (+ n 1))
            (... your stuff involving this file ...)
        )
    )

Note that an empty string is considered a FALSE value to any condition
operator.

To run an external CLI command which normally requires user input, redirect
the input from a file with the needed responses.  For example, to format a
disk one could combine the statement shown below with a file which contains
only a newline character.

    (run "format <nl_file drive DF0: name ToBeEmpty")


            Section 4: Installer Language Reference




4.1  NOTES

a. When the script exits either by comming to the end or via the "exit"
statement, a message will be displayed saying where the application was
installed and where the logfile (if any) was written.  Note that you must
store in "@default-dest" where you actually installed the application (see
"@default-dest" below).

b. A newline character ('\n', 0x0a) will cause a line break when the
installer performs word-wrapping.  A hard-space (ALT-space, 0xa0) will
prevent a word break when the installer performs word-wrapping.  Also,
quoted sections will be considered one word for word-wrapping purposes.  For
example, if the following help text was used:

    "The disk name \"FrameZapper 2.0\" is needed to complete installation."

then the text "FrameZapper 2.0" will not have a word break before the "2".

c. The maximum size of a string in a script is 512 bytes.  The maximum size
of any string variable is 10000 bytes.  If you need to create long help text
for example, break it into 512 byte chunks and then use the automatic string
concatenation ability of the installer to create the final, larger string.
Also, don't overlook the the use of line continuation of strings in scripts
to make your scripts more manageable.  If you ever find that the installer
reports a stack overflow error, look to see if it caused by too many small
strings being concatenated and merge them into larger blocks.

d. The "run" and "execute" statements only return the result of the command
run or executed under 2.0; they always return 0 under 1.3.  If you must have
some result under both 1.3 and 2.0, try this combo:

    # in the DOS script to execute:
    failat 31
    command
    if error
        setenv installer-result 10
    else
        if warn
            setenv installer-result 5
        else
            setenv installer-result 0
        endif
    endif

    # in the installer script
    (execute DOS-Script)
    (set theResult (getenv "installer-result"))

e. Filename and directoryname wildcard patterns specified in a script must
be no longer than 64 characters.


4.2  Statements

(set <varname> <value> [<varname2> <value2> ...])

Set the variable <varname> to the indicated value.  If <varname> does not
exist it will be created.  Set returns the value of the last assignment.

Note: All variables are typeless, and any variable may be used wherever a
string could be used.  All variables are global.

The "set" statement can be used to convert a string to an integer value:

    (set <integer-var> (+ <string-var>))

Use the "cat" statement to do the reverse.


(makedir <name> <parameters>)

Creates a new directory.  Parameters:

    prompt - tell the user what's going to happen.
    help - text of help message
    infos - create an icon for directory
    confirm - if this option is present, user will be prompted, else the
              directory will be created silently.
    safe - make directory even if in PRETEND mode


(copyfiles <parameters>)

Copies one or more files from the install disk to a target directory.  Each
file will be displayed with a checkmark next to the name indicating if the
file should be copied or not.  Note that a write protected file is
considered "delete protected" as well.  Parameters:

    prompt, help - as above
    source - name of source directory or file
    dest - name of destination directory, which is created if it doesn't
           exist.  Note that both source and dest may be relative pathnames.
    newname - if copying one file only, and file is to be renamed, this is
              the new name
    choices - a list of files/directories to be copied (optional)
    all - all files/directories in the source directory should be copied
    pattern - indicates that files/directories from the source dir matching a
              pattern should be copied.  The pattern should be no more than
              64 characters long.
              Note that only one of "choices", "all" or "pattern" should be
              used at any one time.
    files - only copy files.  By default the installer will match and copy
            subdirectories.
    infos - switch to copy icons along with other files/directories
    fonts - switch to not display ".font" files, yet still copy any that
            match a directory that is being copied.
    (optional <option> <option> ...) - dictates what will be considered a
            failure on copying.
            The first three options are mutually exclusive (they may not be
            specified together).
                "fail" - installer aborts if could not copy (the default)
                "nofail" - installer continues if could not copy
                "oknodelete" - aborts if can't copy, unless reason was
                               "delete protected"
            The next two options may be used with any other "optional"
            options.
                "force" - unprotect destination
                "askuser" - ask user if the file should be unprotected (but
                            not in novice)
                In the case of "askuser", the default for novice mode is an
                answer of "no".  Therefore, you may want to use "force" to
                make the novice mode default answer appear to be "yes".
    (delopts <option> <option> ...) - removes options set by "optional"
    confirm -  if this option is present, user will be prompted to indicate
               which files are to be copied, else the files will be copied
               silently.
    safe - copy files even if in PRETEND mode.


(copylib <parameters>)

Copies one file using version checking; i.e., it only overwrites an existing
file if the new file has a higher version/revision number.  "Copylib" will
create the destination directory as long as there is only one level missing.
For example, copying to a non-existent "DEVS:midi" would create the
directory "midi", but copying to "DEVS:midi/extra" where neither "midi" nor
"extra" exists would fail.  Note that a write protected library file is
considered "delete protected" as well.  Parameters:

    prompt, help - as above
    source - name of source directory or file
    dest - name of destination directory
           Note that both source and dest may be relative pathnames.
    newname - if copying one file only, and file is to be renamed,
              this is the new name
    infos - switch to copy icons along with other files
    (optional <option> <option> ...) - dictates what will be considered a
                                       failure on copying.
        The first three options are mutually exclusive (they may not be
            specified together).
            "fail" - installer aborts if could not copy (the default)
            "nofail" - installer continues if could not copy
            "oknodelete" - aborts if can't copy, unless reason was
                           "delete protected"
        The next two options may be used with any other "optional" options.
            "force" - unprotect destination
            "askuser" - ask user if the file should be unprotected
                        (but not in novice)
            In the case of "askuser", the default for novice mode is an
            answer of "no".  Therefore, you may want to use "force" to make
            the novice mode default answer appear to be "yes".
    (delopts <option> <option> ...) - removes options set by "optional"
    confirm - user will be asked to confirm.  Note that an EXPERT user
              will be able to overwrite a newer file with an older one.
    safe - copy the file even if in PRETEND mode


(startup <appname> <parameters>)

This command edits the "S:user-startup" file, which is executed by the
user's startup-sequence (Installer will modify the user's startup- sequence
if needed, although in a friendly way).  The "command" parameter is used to
declare AmigaDOS command lines which will be executed.  The command lines
are grouped by application, using the supplied argument "appname".  If there
is already an entry in "S:user-startup" for that application, the new
command lines will completely replace the old.  The command lines for other
applications will not be affected.  Note: The prompt and help parameters for
the "startup" statement are only used by the confirmation display to edit
"user-startup".  This only happens in EXPERT mode.  Parameters:

    prompt, help - as above
    command - used to declare an AmigaDOS command line to be
              executed at system startup.


(tooltype <parameters>)

Modify an icon's tool type.  Normally the new tool type values will be set
up in advance by various statements in the install language (i.e. the user
does not actually have to type in the tooltype values).  For example, you
could use an "askchoice" to ask the user what type of screen resolution they
want and then format the tooltype string based on their choice.  The
"tooltype" operation merely asks for a confirmation before actually writing.
Parameters:

    prompt, help - as above
    dest - the icon to be modified
    settooltype - the tooltype name and value string.
    setdefaulttool - default tool for a project
    setstack - set size of stack
    noposition - reset to NOICONPOSITION
    swapcolors - swap first two planes of icon's image if OS rev less than
                 v36
    confirm - if this option is present, the user will be asked for
              confirmation, otherwise the modification proceeds
              silently.
    safe - make changes even if in PRETEND mode


(textfile <parameters>)

Creates a text file from other textfiles or computed text strings.  This can
be used to create configuration files, AREXX programs or execute scripts.
Parameters:

    help, prompt - as above
    dest - the name of the text file to be created.
    append - a string to be appended to the new text file.
    include - a text file to be appended to the new text file.
    confirm - if this option is present, the user will be asked for
    confirmation, otherwise the writing proceeds silently.
    safe - create file even if in PRETEND mode


(execute <argument> ...)

Executes an AmigaDOS script with the arguments given.  NOTE: Does not ask
user for confirmation, however this can be added by using "askchoice" or
"askbool". Parameters:

    help, prompt - as above
    confirm - if this option is present, the user will be asked for
              confirmation, otherwise the execute proceeds silently.
    safe - execute script even if in PRETEND mode

Returns a result if executed under 2.0.  Returns 0 under 1.3.  See NOTES for
workarounds under 1.3.


(run <argument> ...)

Executes a compiled program with the arguments given.  NOTE: Does not ask
user for confirmation, however this can be added by using "askchoice" or
"askbool". Parameters:

    help, prompt - as above
    confirm - if this option is present, the user will be asked for
              confirmation, otherwise the run proceeds silently.
    safe - run program even if in PRETEND mode

Returns a result is executed under 2.0.  Returns 0 under 1.3.  See NOTES for
workarounds under 1.3.


(rexx <argument> ...)

Executes an ARexx script with the arguments given.  NOTE: Does not ask user
for confirmation, however this can be added by using "askchoice" or
"askbool". If the ARexx server is not active, an error will be generated.
Parameters:

    help, prompt - as above
    confirm - if this option is present, the user will be asked for
    confirmation, otherwise the rexx script proceeds silently.
    safe - execute script even if in PRETEND mode


(makeassign <assign> [<path>] (parameters))

Assigns 'assign' to 'path'.  If 'path' is not specified, the assignment is
cleared.  Parameters:

    safe - assign even if in PRETEND mode

Note: assign must be supplied without a colon; i.e. "ENV" not "ENV:".


(rename <oldname> <newname> <parameters>)

Renames a file or directory.  If the "disk" parameter is given, then this
command relabels the disk named oldname to newname.  When relabeling a disk,
ONLY include a colon in the oldname.  Returns 1 if the rename was
successful, 0 if it failed.  Parameters:

    help, prompt - as above
    confirm - if this option is present, the user will be asked for
              confirmation, otherwise the rename proceeds silently.
    disk - switch to get rename to relabel a disk.
    safe - rename even if in PRETEND mode


(delete <file> <parameters>)

Delete a file.  Note that a write protected file is considered "delete
protected" as well.  Parameters:

    help, prompt - as above
    confirm - if this option is present, the user will be asked for
              confirmation, otherwise the delete proceeds silently.
    (optional <option> <option> ...) - should deletions be forced.
        options:
            "force" - unprotect destination
            "askuser" - ask user if the file should be unprotected
                        (but not in novice)
            In the case of "askuser", the default for novice mode is an
            answer of "no".  Therefore, you may want to use "force" to make
            the novice mode default answer appear to be "yes".
    (delopts <option> <option> ...) - removes options set by "optional"
    safe - delete even if in PRETEND mode


(protect <file> [<string of flags to change>] [<decimal mask>] <parameters>)

Either gets the protection status of a file (if a second argument is not
given), or sets it.  Two methods exist for setting the status: string (e.g.
"+r -w +e -d") or numeric (e.g. 5).  The string method allows the changing
of any of the flags individually, while numeric writes to all flags at once
(possibly changing bits unintendedly).  The bits in the binary
representation of the decimal mask correspond to the flags in the following
manner:

8 7 6 5 4 3 2 1  <- Bit number

h s p a r w e d  <- corresponding protection flag

^ ^ ^ ^ ^ ^ ^ ^
| | | | | | | |
| | | | | | | +- \
| | | | | | +--- | 0 = flag set
| | | | | +----- | 1 = flag clear
| | | | +------- /
| | | |
| | | |
| | | +--------- \
| | +----------- | 0 = flag clear
| +------------- | 1 = flag set
+--------------- /

Note that the meaning of the bits in the numeric value follows the DOS
convention that a 1 in the high four bits (flags "hspa") indicates that the
flag is set, while a 1 in the lower four bits (flags "rwed") indicates that
the flag is cleared.

When setting bits, "protect" returns 1 if the attempt succeeded, else it
returns a 0.  Getting the bits returns either the numeric value of the
protection status (see interpretation, above) or -1 upon failure.
Parameters:

    safe - change protection even if in PRETEND mode


(abort <message> <message> ...)

Exits the installation procedure with the given messages and then processes
the onerror statements (if any).


(exit <string> <string> ... (quiet))

This causes normal termination of a script.  If strings are provided, they
are displayed.  The "done with installation" message is then displayed.  The
"onerror" statements are not executed.  If (quiet) is specified, the final
report display is skipped.


(complete <number>)

This statement is used to inform the user how complete the installation is.
The number (which must be between 0 and 100) will be printed in the title
bar of the installer window with a '%' sign.


(message <string> <string> ...)

This statement displays a message to the user in a window, along with
Proceed, Abort and optional Help buttons.  Note that messages are not
printed when running at user level 0 (novice).  Parameters:

    help - optional help text


(working <string> <string> ...)

The strings will be concatenated to form a message which will appear below a
standard line that reads "Working on Installation".  Useful if you are doing
a long operation other than file copying (which has its own status display).


(welcome <string> <string> ...)
Installer looks for the occurrence of this statement in a script file during
compilation.  If it does not exist (as is the case for older scripts) the
"Welcome to the <APPNAME> App installation utility" display is presented to
the user as soon as compilation has finished. If this statement is present,
Installer will not put up the "Welcome..." display until the (welcome)
statement is reached.  This allows for the execution of code before the
first displays come up.  Note that the state of the "@user-level" and
"@pretend" variables will be based on the initial defaults including any
modification by tooltypes.  The string arguments are prepended to the
standard help text for whichever of the two initial displays appears first.


4.3  Control Statements

NOTE: Strings can be used as the result of a test expression.  An empty
string is considered a FALSE value, all others are considered TRUE.

(if <expression> <true-statement> <false-statement>)

Operates as a standard "if-then" statement.


(while <expression> <statement> ... )

Operates as a standard "do-while" statement.


(until <expression> <statement> ... )

Operates as a standard "do-until" statement.


(foreach <drawer name> <pattern> <statement>)

For each file or directory matching the pattern located in the given drawer
statement will be executed.  The special variables "@each-name" and
"@each-type" will contain the filename and the DOS object type,
respectively. (By DOS object type we mean the same value as found in
fib_DirEntryType if one were to "Examine" the object.) Patterns specified in
a script must be no longer than 64 characters.


((...) (...) (...))

Execute a sequence of statements.  The statements in the parentheses will be
executed in order -- not needed at topmost level.


(trap <trapflags> <statements>)

Used for catching errors.  Works much like C "longjmp", i.e.  when an error
occurs, control is passed to the statement after "trap".  "Trapflags"
determine which errors are trapped.  The trap statement itself returns the
error type or zero if no error occurred.  The current error type values are:

    1 - user aborted
    2 - ran out of memory
    3 - error in script
    4 - DOS error (see @ioerr below)
    5 - bad parameter data


(onerror <statements>)

When a fatal error occurs that was not trapped, a set of statements can be
called to clean-up after the script.  These statements are logged in by
using the onerror construct.  Note that onerror can be used multiple times
to allow context sensitive termination.


(select <n> <item1> <item2> ...)
Only the selected element will be evaluated.  In this manner, "select" can
be used as a case select construct.


4.4  Debugging Statements

(user <user-level>)

Used to change the user level of the current installation.  This statement
should ONLY be used when debugging scripts.  Remove such statements from any
script before distribution of your product.  Returns the current user level.


(debug <anything> <anything> ...)

When the Installer is run from a CLI, "debug" will print the values of the
parameters with a space between each parameter.  For example, the statements

    (set myvar 2)
    (debug "This value of 'myvar' is" myvar)

will print "This value of myvar is 2".  If the parameter is an uninitialized
variable, then debug will print "<NIL>" as its value.




4.5  User-Defined Procedures
The Installer has user-defined procedures (subroutines).  This functionality
is currently very primative.  There are no local variables.  To define a new
procedure, use the "procedure" command:

    (procedure <procedure-name> <statement>)

You can then call the procedure like so:

    (<procedure-name>)

Note that <procedure-name> is not a string, just a symbolic name.


4.6  Functions


(<string> <arguments> ...)

The "string substitution function".  Whenever a text string is the first
item in a parenthesized group, the arguments will be substituted into the
string using RawDoFmt.  Note: This function does no argument type checking.


(cat <string> <string> ...)

Concatenates the strings and returns the resulting string.

To convert an integer to a string, use the "cat" function.  All integer
arguments to "cat" are converted to strings during concatenation.  Use the
"set" statement to convert a string to an integer.


(substr <string> <start> [<count>])

Returns a substring of <string>, beginning with the character at offset
<start> (offset begins with 0 for the first character) and including <count>
characters. If <count> is omitted, the rest of the string (to its end) is
returned.


(strlen <string>)

Returns the length of the given string.


(transcript <string> <string> ...)

Concatenates the strings, appends a newline and then prints the resulting
string to the transcript file (if any).


(tackon <path> <file>)

Concatenates the filename to the pathname and returns resulting string.
Currently, "tackon" cannot deal with a leading '/' in the <file> parameter.
This may be fixed in a future version.


(fileonly <path>)

Returns only the file part of a pathname.


(pathonly <path>)

Returns only the non-file part of a pathname.


(expandpath <path>)

Returns the full path, given a shortened path.  For example, it might expand
"SYS:c" to "System2.x:c".


(askdir <parameters>)

Asks the user for a directory name, with a scrolling list requester.  The
user can either create a new directory or specify an existing one.  If the
user cancels, the routine will cause an abort.  NOTE: It is always best to
first insure that the volume you want is mounted by using the "askdisk"
command. Parameters:

    prompt, help - as above
    default - default name of directory to be selected.  Note that this may
              be a relative pathname.
    newpath - allows non-existent paths to be supplied as the default drawer.
    disk - show drive list first.
    assigns - debugging parameter; indicates that logical assigns should
              satisfy requests as well.  Remove this parameter before
              distributing disk.



(askfile <parameters>)

Asks the user for a file name, with a scrolling list requester.  The default
path can be either reference a file or a drawer.  If a file, the filename
gadget is filled in.  Parameters:

    prompt, help - as above
    newpath - allows non-existent paths to be supplied as the default drawer.
    disk - show drive list first.
    default - default name of file to be selected  Note that this may be
              a relative pathname.


(askstring <parameters>)

Prompts the user to enter a text string.  Parameters:

    prompt, help - as above
    default - the default text string.


(asknumber <parameters>)

Prompts the user to enter an integer quantity.  Prints the allowed range
below the integer gadget if the "range" parameter is given, and prevents the
user from proceeding without entering a valid number.  Parameters:

    prompt, help - as above
    range - valid input range of numbers
    default - default value


(askchoice <parameters>)

Ask the user to select one out of N choices, using radio buttons.
Parameters:

    prompt, help - as above
    choices - a list of choice strings, such as "ok" "cancel", etc.
    default - the number of the default choice (defaults to 0)


(askoptions <parameters>)

Ask the user to select any number of N choices, using checkbox buttons.  A
bit mask is returned as a result, with the first bit indicating the state of
the first choice, etc.  Parameters:

    prompt, help - as above
    choices - a list of choice strings, such as "ok" "cancel", etc.
    default - a bit mask of the buttons to be checked (defaults to -1)


(askbool <parameters>)

Ask the user to select yes or no.  Parameters:

    prompt, help - as above
    default - 0 = no, 1 = yes
        choices - change the positive and negative text.  The defaults are
        "Yes" and "No".  So to change the text to "Proceed" and "Cancel"
        you would use: (choices "Proceed" "Cancel")


(askdisk <parameters>)

Ask the user to insert a disk in a user friendly manner.  For instance, the
prompt can describe the disk by its label; e.g. "FooBar Program Disk".  This
function will not exit until the correct disk is inserted, or the user
aborts.

    prompt, help - as above
        dest - the volume name of the disk to be inserted
    newname - a name to assign to the disk for future reference.
              This assignment is done even in Dry Run mode -- it is
              considered "safe" disk - switch to get a drive list to be shown
              initially.
    assigns - Debugging option; this indicates that logical assigns should
              satisfy the request as well.  Remove this parameter before
              distributing disk.
    Note: volume name must be supplied without a colon;
          i.e. "ENV" not "ENV:".


(exists <filename> (noreq))

Returns 0 if does not exists, 1 if a file, and 2 if a directory.  If noreq
is specified, no requester is displayed if the path given is not on a
mounted volume.  In this case the result is 0.


(earlier <file-1> <file-2>)

Returns TRUE if file-1 is earlier than file-2.


(getsize <filename>)

Returns the size of a file.


(getdevice <path>)

returns the name of the device upon which <path> resides. For example,
"c:mount" as a path might return "WB_2.x".


(getdiskspace <pathname>)

Returns the available space in bytes on the disk given by pathname.  Returns
-1 if the pathname is bad or information could not be obtained from the
filesystem (even though pathname was valid).


(getsum <filename>)

Returns the checksum of a file, for comparing versions.


(getversion <filename> (resident))

If the named file has a RomTag with an ID string or a 2.x version string,
this will return the version number.  If filename is not provided, then the
version of the OS is returned instead.  Note that this function does NOT
assume files ending with ".library" or ".device" reside in a particular
place -- the path must be included. If "resident" is specified, attempts to
return version of library or device in memory.  For example:

    (getversion "intuition.library" (resident))

would return the version/revision of intuition.  Note that using the
"resident" parameter causes first the library and then the device list to be
checked.

The version number is returned as a 32 bit value, where the high order 16
bit word is the version and the low order word is the revision.  Here is
some sample statements to parse a version number:

(set vernum (getversion "c:iconx"))
(set ver (/ vernum 65536))
(set rev (- vernum (* ver 65536) ) )

(message
        ("You have version %ld.%ld" ver rev)
)


(getenv <name>)

Returns the contents of the given ENV: variable.


(getassign <name> <opts>)

Returns the pathname of the object 'name'.  The default is for logical
assignments only, but can be changed using an options string where the
characters are:

    'v' - only match volumes
    'a' - only match logical assignments
    'd' - only match devices

Therefore 'a' would be equivalent to having no options.  Returns an empty
string on failure.

Notes: Name must be supplied without a colon; i.e. "ENV" not "ENV:".
       A variable previously set to name may be used in place of name.  If a
       device name is used as the name and the search is limited to devices,
       then "getassign" will return the device or volume name if the device
       exists, otherwise it will return an empty string. An example usage
       would be (getassign "df1" "d").


(database <feature>)

Returns information about the Amiga that the Installer is running on.
"Feature" is a string.  This function always returns a string result, even
if the result looks like a number.  If the feature requested is not
recognized, the function returns "unknown".  The currently understood
features and their possible values are:

    "vblank": "50", "60"
    "cpu": "68000", "68010", "68020", "68030", "68040"
    "graphics-mem": [returns a string representing the amount of free
                    graphics memory]
    "total-mem": [returns a string representing the total amount of
                 free memory]
    "chiprev": "AGNUS" [implies original chip set], "ECS", "AA"


(select <n> <item1> <item2> ...)

Returns the value of the Nth item.


(patmatch <pattern> <string>)
Determines if a string matches an AmigaDOS pattern.  Returns either TRUE or
FALSE.


(=  <expression-1> <expression-2>)
(>  <expression-1> <expression-2>)
(>= <expression-1> <expression-2>)
(<  <expression-1> <expression-2>)
(<= <expression-1> <expression-2>)
(<> <expression-1> <expression-2>)

These are the standard relational expressions.


(+  <expression> ...)

Returns the sum of all the arguments.


(-  <expression-1> <expression-2>)

Returns the first argument minus the second argument


(* <expression> ...)

Returns the product of all the arguments


(/  <expression-1> <expression-2>)

Returns the first argument divided by the second argument


(AND <expression-1> <expression-2>)
(OR  <expression-1> <expression-2>)
(XOR <expression-1> <expression-2>)
(NOT <expression>)

Standard logical functions


(BITAND <expression-1> <expression-2>)
(BITOR  <expression-1> <expression-2>)
(BITXOR <expression-1> <expression-2>)
(BITNOT <expression>)

Bitwise versions of the standard logical functions


(shiftleft <number> <amount to shift>)
(shiftrght <number> <amount to shift>)

These functions perform a bit-oriented shift by the amount specified.  Zeros
are shifted in on the opposite side.


(IN  <expression> <bit number-1> ...)

Returns 0 if none of the given bit numbers (starting at 0 for the LSB) is set
in the result of expression, else returns a mask of the bits that were set.


4.7  Summary of Parameters


(assigns)

A debug option used in the "askdisk" statement to indicate that logical
assigns will match the askdisk request as well.  This parameter should not
be used for final disks, only for debugging.


(help <string-1> <string-2> ...)

This is used to specify the help text for each action.


(prompt <string-1> <string-2> ...)

This is used to provide the "title" of the screen which explains to the user
what this step does.


(safe)

    This tells the installer that an action not normally performed in
Pretend mode should be performed.


(choices <string-1> <string-2> ...)

Used to display a series of checkmarks.  This is used in the "askchoice"
function to indicate what choices the user has.  It can also be used in the
"copyfiles" statement to specify that only certain files can be copied. (If
absent, some other criterion will be used to determine which files to copy).


(pattern <string>)

Used in the "copyfiles" statement to specify a wildcard pattern.


(all)

In the "copyfiles" statement, specifies that all files are to be copied.


(source <filename>)

Specifies the file or directory to be read as part of this command.


(dest <filename>)

Specifies the file or directory to be modified as part of the command.


(newname <name>)

Used in "copyfiles" to specify that a file will have a new name after being
copied.  Used in "askdisk" to assign the new name to the inserted disk. Used
in "copylib" to specify that the library will have a new name after being
copied.


(newpath)

Used by "askdir" and "askfile" to allows non-existent paths to be supplied as
the default drawer.


(confirm <user-level>)

On some statements, the user will only be informed of the action (and
allowed to cancel it) if the "confirm" option is specified.  The user level
can be "expert" or "average" ("expert" is the default).


(infos)

Indicates to the "copyfiles" statement that accompanying ".info" files are
to be copied as well.  If the destination drawer does not exist, a default
icon will be made for the drawer the Installer creates.


(fonts)

Indicates to the "copyfiles" statement that accompanying ".font" files are
to be copied as well.


(optional <option> <option> ...)

Indicates to the "copyfiles" and "copylib" statements that it is not a fatal
error to have a copy fail.  Used for "delete" to indicate if deletion should
be "forced".


(delopts <option> <option> ...)

Indicates to the "copyfiles", "copylib" and "delete" statements that the
listed options should be _removed_ from the global internal list of options
for this statement.  The default global option is "fail".


(nogauge)
When used with the "copyfiles" and "copylib" statements this disables the
copy status indicator.


(settooltype <tooltype> <value>)

Used to modify a tooltype to a certain value.  If the tooltype does not
exist it will be created; if the <values> parameter is omitted, the tooltype
will be deleted.  A tooltype without a value may be added in the following
manner:

    (settooltype <tooltype-string> "")

Remember that (tooltype <tooltype-string>) deletes the tooltype given.


(setdefaulttool <value>)

Used to modify the default tool of an icon.


(setstack <value>)

Used to modify the stack size included in an icon.


(noposition)

Used to modify the positioning of an icon to NO_ICON_POSITION.


(swapcolors)

Used to swap the first two planes of the image of the icon being modified if
the version of the OS if less than 36 (i.e., prior to version 2.0).  This
does mean that your icons need to have the 2.0 color scheme on your
distribution disks.


(disk)

When used with the "rename" statement, specifies that a disk relabel
operation is really desired.  When used with the "askdir" or "askfile"
statement, specifies that a drive list should be shown initially (instead of
a file list).


(append <string>)

Within a "textfile" statement, will append the string to the textfile.


(include <filename>)

Within a "textfile" statement, will append the listed file to the textfile.


(default <value>)

Specifies the default value of an askchoice, askstring, or asknumber action.


(range <min> <max>)

Specifies the range of allowable numbers for an asknum statement.


(command <text> ...)

Specifies the text of a command to be inserted into the S:User-Startup file.
(Argument strings are merged.)


4.9  Pre-Defined Variables

Pre-defined variables are available for use by the install script.  They may
be modified on-the-fly, but their type may not be changed (e.g. from strings
to numeric) unless it never had a value to begin with.


@abort-button
    Replacement text for the "Abort Install" button.

@app-name
    The APPNAME value given at startup.

@icon
    The pathname of the icon used to start the installer.

@execute-dir
    If this variable is set to a valid path, then the installer will change
directory to it whenever a "run" or "execute" statement is performed.

@default-dest
    The installer's suggested location for installing an application.  If
you installed the application somewhere else (as the result of asking the
user) then you should modify this value -- this will allow the "final"
statement to work properly.  Note that creating a drawer and putting the
application in that drawer is considered installing the application
somewhere else.  Set it to "" if there really is no definite place that the
"application" was installed. The log file will be copied to the drawer
indicated by @default-dest unless it was set to "".

@language
    Used to set the variable @language (default for @language is "english".
Installer will attempt to load the corresponding language catalog to allow
for language localization.

@pretend
    The state of the Pretend flag (1 if Pretend mode).

@user-level
    The user-level the script is being run at: 0 for novice, 1 for average,
2 for expert.

@error-msg
    The text that would have been printed for a fatal error, but was
overridden by a trap statement.

@special-msg
    If a script wants to supply its own text for any fatal error at various
points in the script, this variable should be set to that text.  The
original error text will be appended to the special-msg within parenthesis.
Set this variable to "" to clear the special-msg handling.

@ioerr
    The value of the last DOS error.  Can be used in conjunction with the
"trap" statement to learn more about what an error occurred.

@each-name
@each-type
    Used in a "foreach" loop (see above).

@askoptions-help
@askchoice-help
@asknumber-help
@askstring-help
@askdisk-help
@askfile-help
@askdir-help
@copylib-help
@copyfiles-help
@makedir-help
@startup-help
    Default help text for various functions.  These can be appended to the
explanation provided for a particular action or used as is.


            Section 5: Installer Language Quick Reference

5.1  Overview

    Attempts to install in "work:" by default if it exists.
    HELP key brings up context-sensitive help.
    Esc key brings up the abort requester.
    Can add assigns to s:User-Startup, and adds lines to
    s:Startup-Sequence (if necessary) to make sure s:User-Startup is executed
      upon boot-up.
    Can check versions of files/libraries.
    Install can run in "Real" (do it) or "Pretend" (dry run) modes.




5.2  Quick Language Overview

    Language is lisp-like (lots of parentheses (()) (-:).
    Variables are typeless (a la ARexx), i.e., strings and numbers are
      treated interchangeably.
    Strings are delimited with " or '.
    Certain embedded sequences are available for strings:
        '\n'    newline        '\r'    return
        '\t'    tab            '\0'    NULL
        '\"'    double-quote   '\\'    backslash
    Statements go in parentheses ( ).  The general format is:
        (operator <operand1> <operand2> ...)
    E.g., to assign the value '5' to the variable 'x', use
        (set x 5)
    To produce the sum of two numbers, use
        (+ 5 9)
    Note that there is no difference between operators and functions-- the
      function 'set' and the arithmetic operator '+' are both used exactly
      the same way.
    Combining statements: A statement can be used as the operand to another
      statement.  E.g.:
        (set x (+ 3 5))
      In this case, the statement '(+ 3 5)' is evaluated first, and the
        result is 8.  You can think of this as having the '(+ 3 5)' part
        being replaced by an 8, leaving:
        (set v 8)
      Note that the '(+ 3 5)' part actually produced a value: "8".  This is
      called the "result" of the statement.  Many statements return results,
      even some that might surprise you (such as "set" and "if").
    Comments are preceded with a semi-colon ";"
    Hex numbers are preceded with a $ (e.g. $23).
    Binary numbers are preceded with a % (e.g. %0101).
    Many statements return a value which can be used in assignments or tests.
    Data can be formatted using a string literal with argument placemarkers,
      for example:
        ("I am %ld foot %ld inches tall." 6 3)
        ;Produces a string with %ld's replaced with 6 and 3.
        ;Remember that decimal values must be specified as longwords.




5.3  Pre-Defined Variables

    @icon - pathname of install script icon
    @execute-dir -  installer will change to this directory before performing
      a "run" or "execute" statement.
    @default-desk - dir.  where install wants to put things by default
    @pretend - state of "pretend" (dry run mode) flag 0-Real, 1-Pretend
    @language - language specified in tooltypes/CLI (default "english")
    @user-level - 0-Novice, 1-Average, 2-Expert
    @error-msg - msg that would be displayed if error not trapped (see trap)
    @special-msg - custom fatal error message
    @each-name, @each-type - used in "foreach" loop
    @execute-dir - If set to a valid path, installer will change directory to
      it whenever a "run" or "execute" statement is performed.




5.4  Default Help String Variables

    @askoptions-help    @askchoice-help      @asknumber-help
    @askstring-help     @askdisk-help        @askfile-help
    @askdir-help        @copylib-help        @copyfiles-help
    @makedir-help       @startup-help



5.5  Statements

Many commands have standard parameters (some optional):
    (all) ; specifies all files are to copied
    (append <string>) ; add string to text file (for textfile)
    (choices <string1> <string2> ...) ; radio button options
    (command <string1> <string2>...) ; add to s:user-startup
    (confirm <user-level>) ; confirmation
    (default <value>) ; default value, choice, string, etc.
    (dest <file>) ; output to <file>
    (help <string1> <string2> ...) ; define current help info
    (include <file>) ; insert file in textfile statement
    (infos) ; copy .info files also
    (newname <name>) ; specify new file or disk name
    (noposition) ; make icon "floating"
    (pattern <string>) ; used w/ "files" for patterns
    (prompt <string1> <string2> ...) ; text to show user
    (range <min> <max>) ; numeric input (asknum) range
    (safe) ; force installer to perform action even if in Pretend mode.
    (settooltype <tooltype> <value>) ; set icon tool type
    (setdefaulttool <value>) ; set icon's default tool
    (setstack <value>) ; set icon's stack value
    (source <file>) ; read from <file>
    (swapcolors) ; swap 1st two planes of icon image if OS rev less than v36
    (welcome <string> <string> ...) ; Invokes "welcome" display

Note: Custom parameters are shown below in < >, and standard parameters are
show as (param..) where "param" is one of help, prompt, safe, etc.  See
above for details on standard parameters.


(abort <string1> <string2> ...)
  ; abandon installation

(complete <num>)
  ; display percentage through install in titlebar

(copyfiles (prompt..) (help..) (source..) (dest..) (newname..) (choices..)
  (all) (pattern..) (files) (infos) (confirm..) (safe)
  (optional <option> <option> ...) (delopts <option> <option> ...) (nogauge))
  ; copy files (and subdir's by default).  files option say NO subdirectories

(copylib (prompt..) (help..) (source..) (dest..) (newname..) (infos)
  (confirm) (safe) (optional <option> <option> ...)
  (delopts <option> <option> ...) (nogauge))
  ; install a library if newer version

(delete file (help..) (prompt..) (confirm..) (optional <option> <option> ...)
  (delopts <option> <option> ...) (safe))
  ; delete file

(execute <arg> (help..) (prompt..) (confirm) (safe))
  ; execute script file

(exit <string> <string> ... (quiet))
  ; end installation after displaying strings (if provided)

(foreach <dir> <pattern> <statements>)
  ;do for entries in directory

(if expr truestatements falsestatements)
  ; conditional

(makeassign <assign> <path> (safe)) ; note: <assign> doesn't need `:'
  ; create an assignment

(makedir <name> (prompt..) (help..) (infos) (confirm..) (safe))
  ; make a directory

(message <string1> <string2>...)
  ; display message with Proceed, Abort buttons

(onerror (<statements>))
  ; general error trap

(protect <file> [<string of flags to change>] [<decimal mask>] <parameters>)
  ; Get/Set file protection flags

(rename <old> <new> (help..) (prompt..) (confirm..) (safe))
  ; rename files

(rexx <arg> (help..) (prompt..) (confirm..) (safe))
  ; execute ARexx script

(run <arg> (help..) (prompt..) (confirm..) (safe))
  ; execute program

(set <varname> <expression>)
  ; assign a value to a variable

(startup (prompt..) (command..))
  ; add a command to the boot scripts (startup-sequence, user-startup)

(textfile (prompt..) (help..) (dest..) (append) (include..) (confirm..)
  (safe))
  ; create text file from other text files and strings

(tooltype (prompt..) (help..) (dest..) (settooltype..) (setstack..)
  (setdefaulttool..) (noposition) (confirm..) (safe))
  ; modify an icon

(trap <flags> <statements>)
  ; trap errors.  flags: 1-abort, 2-nomem, 3-error, 4-dos, 5-badargs

(until <expr> <statements>)
  ; do-until conditional structure (test end of loop)

(welcome <string> <string> ...)
  ; Allow Installation to commence.

(while <expr> <statements>)
  ; do-while conditional structure (test top of loop)

(working)
  ; indicate to user that installer is busy doing things


5.6  Functions

(= <expr1> <expr2>) ; equality test (returns 0 or 1)

(> <expr1> <expr2>) ; greater than test (returns 0 or 1)

(>= <expr1> <expr2>) ; greater than or equal test (returns 0 or 1)

(< <expr1> <expr2>) ; less than test (returns 0 or 1)

(<= <expr1> <expr2>) ; less than or equal test

(+ <expr1> <expr2> ...) ; returns sum of expressions

(- <expr1> <expr2>) ; returns <expr1> minus <expr2>

(* <expr1> <expr2> ...) ; returns product of expressions

(/ <expr1> <expr2>) ; returns <expr1> divided by <expr2>

(AND <expr1> <expr2>) ; returns logical AND of <expr1> and <expr2>

(OR <expr1> <expr2>) ; returns logical OR of <expr1> and <expr2>

(XOR <expr1> <expr2>) ; returns logical XOR of <expr1> and <expr2>

(NOT <expr>) ; returns logical NOT of <expr>

(BITAND <expr1> <expr2>) ; returns bitwise AND of <expr1> and <expr2>

(BITOR <expr1> <expr2>) ; returns bitwise OR of <expr1> and <expr2>

(BITXOR <expr1> <expr2>) ; returns bitwise XOR of <expr1> and <expr2>

(BITNOT <expr>) ; returns bitwise NOT of <expr>

(shiftleft <number> <amount to shift>) ; logical shift left

(shiftrght <number> <amount to shift>) ; logical shift right

(IN <expr> <bit-number> <bitnumber>...)    ; returns <expr> AND bits

(<format string> <arg1> <arg2> ...) ; printf clone

(askdir (prompt..) (help..) (default..) (newpath) (disk))
  ; ask for directory name

(askfile (prompt..) (help..) (default..) (newpath) (disk))
  ; ask for file name

(askstring (prompt..) (help..) (default..)) ; ask for a string

(asknumber (prompt..) (help..) (range..) (default..)) ; ask for a number

(askchoice (prompt..) (choices..) (default..)) ; choose 1 options

(askoptions (prompt (help..) (choices..) default..)) ; choose n options

(askbool (prompt..) (help..) (default..) (choices..)) ; 0=no, 1=yes

(askdisk (prompt..) (help..) (dest..) (newname..) (assigns))

(cat <string1> <string2>...) ; returns concatenation of strings

(exists <filename> (noreq)) ; 0 if no, 1 if file, 2 if dir

(expandpath <path>) ; Expands a short path to its full path equivalent

(earlier <file1> <file2>) ; true if file1 earlier than file2

(fileonly <path>) ; return file part of path (see pathonly)

(getassign <name> <opts>) ; return value of logical name (no `:')
  ; <opts: 'v'-volumes, 'a'-logical, 'd'-devices

(getdevice <path>) ; returns name of device upon which <path> resides

(getdiskspace <path>) ; return available space

(getenv <name>) ; return value of environment variable

(getsize <file>) ; return size

(getsum <file>) ; return checksum of file for comparison purposes

(getversion <file> (resident))
  ; return version/revision of file, library, etc. as 32 bit num

(pathonly <path>) ; return dir part of path (see fileonly)

(patmatch <pattern> <string>) ; Does <pattern> match <string> ? TRUE : FALSE

(select <n> <item1> <item2> ...) ; return n'th item

(strlen <string>) ; string length

(substr <string> <start> [<count>]) ; returns a substring of <string>

(transcript <string1> <string2>) ; puts concatenated strings in log file

(tackon <path> <file>) ; return properly concatenated file to path

