head     39.2;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


39.2
date     92.12.28.16.07.34;  author vertex;  state Exp;
branches ;
next     39.1;

39.1
date     92.08.10.11.36.53;  author vertex;  state Exp;
branches ;
next     ;


desc
@Installer source code
@


39.2
log
@*** empty log message ***
@
text
@/* ========================================================================= *
 * Support.c - creates the window for installer utility                      *
 * By Talin & Joe Pearce. (c) 1990 Sylvan Technical Arts                     *
 * ========================================================================= */

#ifndef EXEC_TYPES_H
#include <intuition/intuition.h>
#include <workbench/workbench.h>
#include <exec/memory.h>

/* #define __NO_PRAGMAS */
#include "functions.h"
#endif

#include <string.h>

#include "xfunctions.h"

#include "installer.h"

extern struct Library *IntuitionBase, *IconBase;

struct Gadget *FindGadgetB(struct Gadget *gad, WORD num)
{
	while (gad)
	{	if (gad->GadgetID == num) return gad;
		gad = gad->NextGadget;
	}
	return NULL;
}

struct Gadget *FindGadget(struct Window *win, WORD num)
{
	return FindGadgetB(win->FirstGadget,num);
}

void EmptyPort(struct MsgPort *port)
{	struct Message *msg;

	Forbid();
	while (msg = GetMsg(port)) ReplyMsg(msg);
	Permit();
}

void SelectGadget(struct Gadget *gad, struct Window *win, USHORT state)
{	long p;

	if ((gad->Flags & GADGHIGHBITS) == GADGHCOMP)
	{	p = RemoveGadget(win,gad);
		AddGList(win,gad,p,1,NULL);
		RefreshGList(gad,win,NULL,1);
	}

	p = RemoveGadget(win,gad);
	gad->Flags = (gad->Flags & ~SELECTED) | state;
	AddGList(win,gad,p,1,NULL);
	RefreshGList(gad,win,NULL,1);
}

struct String *new_string(char *text)
{	struct String	*str;
	WORD			len = 3 + strlen(text);

	if (str = MemAlloc(len,0L))
	{
		str->length = len;
		strcpy((char *)(str + 1),text);
	}

	return str;
}

struct String *empty_string(LONG size)
{	struct String	*str;
	WORD			len = 3 + size;

	if (str = MemAlloc(len,MEMF_CLEAR)) str->length = len;
	return str;
}

BOOL CheckToolValue(struct DiskObject *dobj,char *type,char *value)
{	char *str;

	if (dobj->do_ToolTypes == NULL) return FALSE;

	str = FindToolType(dobj->do_ToolTypes,type);
	if (str == NULL) return FALSE;

	return MatchToolValue(str,value);
}

char *LocateToolType(struct DiskObject *dobj,char *type)
{	char *str;

	if (dobj->do_ToolTypes == NULL) return NULL;

	str = FindToolType(dobj->do_ToolTypes,type);
	if (str == NULL) return NULL;

	return (strlen(str) == 0 ? NULL : str);
}

struct Library	*ConsoleDevice;
struct IOStdReq	conreq;

struct Library *OpenConsoleLib(void)
{
	if (!OpenDevice("console.device",-1,(struct IORequest *)&conreq,0))
	{
		ConsoleDevice = (struct Library *)conreq.io_Device;
	}

	return ConsoleDevice;
}

void CloseConsoleLib(void)
{
	if (ConsoleDevice) CloseDevice((struct IORequest *)&conreq);
}

UWORD DoKeyConvert(struct IntuiMessage *imsg)
{	static struct InputEvent ievent = { NULL, IECLASS_RAWKEY, 0, 0, 0};
	char	buffer[4];

	if (imsg->Class != RAWKEY) return 0;

	ievent.ie_Code = imsg->Code;
	ievent.ie_Qualifier = imsg->Qualifier;

	/* get previous codes from location pointed to by IAddress
	 *  this pointer is valid until IntuiMessage is replied.
	 */

	ievent.ie_position.ie_addr = *(APTR *)imsg->IAddress;
	if (RawKeyConvert(&ievent, buffer, 2, NULL) == 1) return (UWORD)buffer[0];

	return 0;
}
@


39.1
log
@Initial V39 RCS checkin
@
text
@d135 1
a135 1
	if (RawKeyConvert(&ievent, buffer, 2, NULL) == 1) return buffer[0];
@
