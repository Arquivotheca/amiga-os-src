head     36.10;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


36.10
date     93.04.06.08.35.34;  author kaori;  state Exp;
branches ;
next     36.9;

36.9
date     92.12.02.11.13.30;  author kaori;  state Exp;
branches ;
next     36.8;

36.8
date     92.08.24.15.03.52;  author kaori;  state Exp;
branches ;
next     36.7;

36.7
date     92.08.13.13.48.10;  author kaori;  state Exp;
branches ;
next     36.6;

36.6
date     92.07.31.15.19.21;  author kaori;  state Exp;
branches ;
next     36.5;

36.5
date     91.06.13.10.32.50;  author jerryh;  state Exp;
branches ;
next     36.4;

36.4
date     91.03.05.15.26.35;  author jerryh;  state Exp;
branches ;
next     36.3;

36.3
date     91.02.27.12.03.55;  author jerryh;  state Exp;
branches ;
next     36.2;

36.2
date     91.02.26.16.40.49;  author jerryh;  state Exp;
branches ;
next     36.1;

36.1
date     90.04.20.07.10.34;  author jesup;  state Exp;
branches ;
next     ;


desc
@read/write code - finds drives, reads rdbs, writes rdbs, reads/writes defs, etc.
@


36.10
log
@SetFont to topaz8.
@
text
@/* readwrite.c - code to handle the prep main screen */

#include <exec/types.h>
#include <exec/memory.h>
#include <exec/errors.h>
#include <devices/trackdisk.h>
#include <graphics/gfx.h>
#include <graphics/gfxmacros.h>
#include <intuition/intuition.h>
#include <dos/filehandler.h>

#include <dos.h>
#include <stdlib.h>
#include <string.h>

#include <stdio.h>

/* for lattice */
#include <clib/exec_protos.h>
#include <clib/dos_protos.h>
#include <clib/graphics_protos.h>
#include <clib/intuition_protos.h>

#include <pragmas/exec_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/intuition_pragmas.h>

#include "refresh.h"
#include "protos.h"
#include <clib/alib_protos.h>

#include "global.h"

#include "gadgetids.h"
#include "gadgets.h"
#include "windows.h"

#include "scsi.h"
#include "scsidisk.h"

#define SAME 0

#define GetBlock(n) (&array[((n) - d->Block) * rdb->rdb_BlockBytes])

#define USEINTERLEAVE	/* for XT drives */

extern struct TextFont *tfont;	/* 40.3 */
extern UWORD XtraTop;	/* 40.3 */

/* TRUE == success, FALSE == failure */
/* TRUE means don't tell of errors */

int CommitChanges(struct Window *w,int informat)
{
	register struct Drive *d = SelectedDrive;
	struct RigidDiskBlock *rdb;
	struct PartitionBlock *p,*lastp,*newp;
	struct FileSysHeaderBlock *fs,*lastfs,*newfs;
	struct LoadSegBlock *ls,*lastls,*newls;
	struct BadBlockBlock *bb,*lastbb,*newbb;
	struct IOStdReq *ior = NULL;
	struct MsgPort *port = NULL;
	int  result = FALSE,opened = FALSE;
	LONG maxblock,blocks,i,flags,low_badblock;
	char *array = NULL;

	if (!d || !d->rdb) return FALSE;

	if (!(port = CreatePort(0L,0L))) goto cleanup;
	if (!(ior = CreateStdIO(port))) goto cleanup;

	/* now write out array starting at block d->Block */
	if (i = OpenDevice(d->DeviceName,d->Addr + d->Lun * 10,
		(struct IORequest *)ior,0L))
	{
		Notify(w,"Error %d on device open!",i);
		goto cleanup;
	}

	opened = TRUE;

	if (d->oldrdb && AnalyzePartitions(d->rdb,d->oldrdb))
	{
		if (!AskSure(w,CommitText))
			goto cleanup;
		else
			ForceReboot = TRUE;     /* reboot WILL be needed! */
	} /* don't ask if nothing will be lost or wasn't preped before */

	/* ok, the user wants us to write it out */

	/* try to reassign any bad blocks the user entered */
	ReassignAll(d,ior);

	/* first, get the memory */
	blocks = CountBlocks(d->rdb);

	if (!(array = AllocMem(blocks * d->rdb->rdb_BlockBytes + 20,
		MEMF_PUBLIC | MEMF_CLEAR))) goto cleanup;

	ior->io_Data    = (APTR) array;
	ior->io_Length  = blocks * d->rdb->rdb_BlockBytes;
	ior->io_Offset  = d->Block * d->rdb->rdb_BlockBytes;
	ior->io_Command = CMD_WRITE;

	/* set the LASTLUN, LASTTID, or LAST flags in the RDB if needed */
	/* since the driver only handles one board, LASTTID|LASTLUN == LAST */
  	flags = CalcFlags(d);
	if (flags != (d->rdb->rdb_Flags & (RDBFF_LAST | RDBFF_LASTLUN | RDBFF_LASTTID)))
	{
		/* the flags aren't right: fix em */
		d->Flags |= UPDATE;
		d->rdb->rdb_Flags &= ~(RDBFF_LAST|RDBFF_LASTLUN|RDBFF_LASTTID);
		d->rdb->rdb_Flags |= flags;
	}

	rdb  = (struct RigidDiskBlock *) array;
	*rdb = *(d->rdb);     /* structure copy */
	rdb->rdb_HostID = HOST_ID;

	/* set all the null pointers to 0xffffffff */
	rdb->rdb_BadBlockList      = (struct BadBlockBlock *)0xffffffff;
	rdb->rdb_PartitionList     = (struct PartitionBlock *)0xffffffff;
	rdb->rdb_FileSysHeaderList = (struct FileSysHeaderBlock *)0xffffffff;
	rdb->rdb_DriveInit         = (struct LoadSegBlock *)0xffffffff;

	for (i = 0; i < 6; i++)
		rdb->rdb_Reserved1[i] = (ULONG)0xffffffff;

	maxblock = d->Block;	/* start at the old rigid disk block, or 0 */

	/* Partitions next */
	for (lastp = NULL,p = d->rdb->rdb_PartitionList;
		p;
		lastp = newp,p = p->pb_Next)
	{
		maxblock++;
		if (lastp)
			lastp->pb_Next = (struct PartitionBlock *)maxblock;
		else
			rdb->rdb_PartitionList = (struct PartitionBlock *)maxblock;

		newp = (struct PartitionBlock *) GetBlock(maxblock);
		*newp = *p; /* structure copy */
		CtoBStr(&(newp->pb_DriveName[0]));

		/* 39.13 - Now partition HostID field is set by users */
		/* newp->pb_HostID = HOST_ID; */
		newp->pb_Next   = (struct PartitionBlock *) 0xffffffff;
	}

	/* now file systems */
	for (lastfs = NULL,fs = d->rdb->rdb_FileSysHeaderList;
		fs;
		lastfs = newfs,fs = fs->fhb_Next)
	{
		maxblock++;
		if (lastfs)
			lastfs->fhb_Next = (struct FileSysHeaderBlock *) maxblock;
		else
			rdb->rdb_FileSysHeaderList = (struct FileSysHeaderBlock *)maxblock;
		newfs = (struct FileSysHeaderBlock *) GetBlock(maxblock);
		*newfs = *fs; /* structure copy */

		newfs->fhb_HostID = HOST_ID;

		newfs->fhb_SegListBlocks = (struct LoadSegBlock *) 0xffffffff;
		newfs->fhb_Next = (struct FileSysHeaderBlock *) 0xffffffff;

		/* now loadsegblocks */
		for (lastls = NULL,ls = fs->fhb_SegListBlocks;
			ls;
			lastls = newls,ls = ls->lsb_Next)
		{
			maxblock++;
			if (lastls)
				lastls->lsb_Next = (struct LoadSegBlock *)maxblock;
			else
				newfs->fhb_SegListBlocks = (struct LoadSegBlock *)maxblock;

			newls = (struct LoadSegBlock *) GetBlock(maxblock);

			/* to, from, size in bytes */
			memcpy((char *) newls,(char *) ls,ls->lsb_SummedLongs << 2);

			newls->lsb_HostID = HOST_ID;
			newls->lsb_Next   = (struct LoadSegBlock *) 0xffffffff;
		}
	}

	/* now bad blocks */
	low_badblock = d->rdb->rdb_RDBBlocksHi + 1;

	for (lastbb = NULL,bb = d->rdb->rdb_BadBlockList;
		bb;
		lastbb = newbb,bb = bb->bbb_Next)
	{
		maxblock++;
		if (lastbb)
			lastbb->bbb_Next = (struct BadBlockBlock *)maxblock;
		else
			rdb->rdb_BadBlockList = (struct BadBlockBlock *)maxblock;

		newbb = (struct BadBlockBlock *) GetBlock(maxblock);

		/* to, from, size in bytes */
		memcpy((char *) newbb,(char *) bb,bb->bbb_SummedLongs << 2);

		{
			short i;
			LONG  good;
			ULONG *map;

			if (d->rdb->rdb_Interleave > 1)
			{
				/* this usage of sectors is correct */
				map = BuildInterleaveMap(d->rdb->rdb_Interleave,
					d->rdb->rdb_Sectors);
				if (!map)
					goto cleanup;
			}

			/* 2 longs per entry */
			for (i = 0; i < (newbb->bbb_SummedLongs - 6)/2; i++)
			{
				/* first, maintain low_badblock */
				good = newbb->bbb_BlockPairs[i].bbe_GoodBlock;

				/* first, maintain low_badblock */
				if (good > 0 && good < low_badblock)
				{
					low_badblock = good;
				}

#ifdef USEINTERLEAVE
				/* second, translate sector numbers                          */
				/* re: interleave needed for switching interleaves.          */
				/* map already built all sectors internally are interleave 1 */
				if (d->rdb->rdb_Interleave > 1)
				{
					LONG sec;

					/* first get sector on cylinder */
					sec = newbb->bbb_BlockPairs[i].bbe_BadBlock % d->rdb->rdb_CylBlocks;

					/* I _think_ this use of sector is ok */
					/* now make that sector on head */
					sec = sec % d->rdb->rdb_Sectors;

					/* '- sec' to give start of head */
					newbb->bbb_BlockPairs[i].bbe_BadBlock += map[sec] - sec;
				}
#endif
			}

		if (d->rdb->rdb_Interleave > 1)
			FreeMem((char *) map,d->rdb->rdb_Sectors * 4);
		}

	newbb->bbb_HostID = HOST_ID;
	newbb->bbb_Next   = (struct BadBlockBlock *) 0xffffffff;
	}

	/* drive init code */
	for (lastls = NULL,ls = d->rdb->rdb_DriveInit;
		ls;
		lastls = newls,ls = ls->lsb_Next)
	{
		maxblock++;
		if (lastls)
			lastls->lsb_Next = (struct LoadSegBlock *)maxblock;
		else
			rdb->rdb_DriveInit = (struct LoadSegBlock *)maxblock;

		newls = (struct LoadSegBlock *) GetBlock(maxblock);

		/* to, from, size in bytes */
		memcpy((char *)newls,(char *)ls,ls->lsb_SummedLongs << 2);

		newls->lsb_HostID = HOST_ID;
		newls->lsb_Next   = (struct LoadSegBlock *) 0xffffffff;
	}

	rdb->rdb_HighRDSKBlock = maxblock;
	if (maxblock >= low_badblock)
	{
		Notify(w, "Save failed, not enough space for configuration data", 0);
		/* FIX! - add rdsk cylinder gadget */
		Notify(w, "Try a low-level format, or removing file systems or partitions", 0);
		goto cleanup;
	}

	/* checksum all the blocks */
	for (i = d->Block;i <= maxblock;i++)
		CheckSumBlock((struct RigidDiskBlock *) GetBlock(i));

	/* now write out array starting at block d->Block */
	DoIO((struct IORequest *) ior);

	if (ior->io_Error)
	{
		if (!informat)
		{
			Notify(w,"Error %d on write!",(LONG) (ior->io_Error));
			goto cleanup;
		}
		else
		{
			/* don't care if it failed for format */
			return TRUE;
		}
	}

	/* note that this drive had it's RDSK written out */
	d->Flags |= WRITTEN;

	result = TRUE;

cleanup:
	if (opened) CloseDevice((struct IORequest *) ior);
	if (ior)    DeleteStdIO(ior);
	if (port)   DeletePort(port);
	if (array)  FreeMem(array,blocks * d->rdb->rdb_BlockBytes + 20);

	return result;
}


int CountBlocks (rdb)
	struct RigidDiskBlock *rdb;
{
	register struct PartitionBlock *p;
	register struct FileSysHeaderBlock *fsb;
	struct LoadSegBlock *lsb;
	struct BadBlockBlock *bb;
	register int num;

	num = 1;

	for (p = rdb->rdb_PartitionList;p;p = p->pb_Next)
		num++;

	for (fsb = rdb->rdb_FileSysHeaderList;fsb;fsb = fsb->fhb_Next)
	{
		num++;
		for (lsb = fsb->fhb_SegListBlocks;lsb;lsb = lsb->lsb_Next)
			num++;
	}

	for (bb = rdb->rdb_BadBlockList;bb;bb = bb->bbb_Next)
		num++;

	for (lsb = rdb->rdb_DriveInit;lsb;lsb = lsb->lsb_Next)
		num++;

	return num;
}

/* compute add-to-zero checksum for a block.  summed_longs must be set up */

void
CheckSumBlock (rdb)
	struct RigidDiskBlock *rdb;	/* may be anything actually */
{
	register LONG *larray;
	register LONG checksum;
	register short i;

	rdb->rdb_ChkSum = 0;

	larray = (LONG *) rdb;
	checksum = 0;
	for (i = 0;i < rdb->rdb_SummedLongs;i++)
	{
		checksum += larray[i];
	}

	rdb->rdb_ChkSum = 0 - checksum;	  /* I prefer EOR checksums, or CRC */
}

/* check a checksum */

int
CheckCheckSum (rdb)
	struct RigidDiskBlock *rdb;
{
	register LONG *array;
	register LONG checksum;
	register unsigned short i;

	if (rdb->rdb_SummedLongs <= 0 ||
	    rdb->rdb_SummedLongs >= 65536)
		return FALSE;		/* sanity check */

	checksum = 0;
	array = (LONG *) rdb;

	for (i = 0;i < rdb->rdb_SummedLongs;i++)
		checksum += array[i];

	return (checksum == 0);
}

static char *devnames[] = {
	"",
	"2nd.",
	"3rd.",
	"4th.",
	"5th.",
	"6th.",
	"7th.",
	"8th.",
};

/* get all drives in the system */

int
GetDrives (rp,name,flags,numaddr,numlun)
	struct RastPort *rp;
	char *name;			/* of device */
	LONG flags;			/* SCSI or ST506 (aka XT) */
	LONG numaddr,numlun;
{
	register struct Drive *d,*lastd,*firstd;
	struct IOStdReq *ior = NULL;
	struct MsgPort *port = NULL;
	int res = FALSE,done = FALSE;
	unsigned short addr,lun,board;
	char str[80];
	LONG error;

	if (!(port = CreatePort(0L,0L)))
		goto cleanup;
	if (!(ior = CreateStdIO(port)))
		goto cleanup;

	/* point lastd at last drive in system */
	for (lastd = FirstDrive; lastd && lastd->NextDrive;
	     lastd = lastd->NextDrive)
		; /* NULL */
	firstd = lastd;

	/* handle steve's wierd board multiple handlers */
	for (board = 0; board < 8 && !done; board++)
	{
	    /* for each addr/lun pair */
	    for (addr = 0; addr < numaddr && !done; addr++)
	    {
		for (lun = 0; lun < numlun && !done; lun++)
		{
			sprintf(str,
				"Checking %s%s address %d unit %d...          ",
				devnames[board],name,addr,lun);
			SetFont(rp,tfont);	/* 40.3 */
			Move(rp,140,100 + XtraTop);
			Text(rp,str,strlen(str));
			sprintf(str,"%s%s",devnames[board],name);
			if (!(error = OpenDevice(str,addr + lun * 10,
					         (struct IORequest *) ior, 0L)))
			{
				/* a device exists! */
				found_driver = TRUE;

				/* check the driver version */
				/* so we know if we can use mask=0xffffffff */
				scsiversion =
					ior->io_Device->dd_Library.lib_Version;

				if (!(d = AllocNew(Drive)))
				{
					CloseDevice((struct IORequest *) ior);
					goto cleanup;
				}
				d->NextDrive = NULL;
				if (!FirstDrive)
					FirstDrive = d;
				else
					lastd->NextDrive = d;
				NumDrives++;

				d->Flags = flags;
				d->Addr  = addr;
				d->Lun   = lun;
				d->Block = 0;
				d->SCSIBadBlocks = 0;

				strcpy(d->DeviceName,str);

				if (!GetRDB(ior,d)) GetDriveType(ior,d);

				/* get number of bad blocks */
				if (flags == SCSI)
				  d->SCSIBadBlocks = ReadDefects(ior);

				lastd = d;
				if (!firstd) firstd = d;

				CloseDevice((struct IORequest *) ior);
			} else {
				/* if device doesn't exist, stop */
				if (error == IOERR_OPENFAIL)
					done = TRUE;
				else
					/* we know the driver exists */
					found_driver = TRUE;
			} /* opendevice */
		} /* for lun */
	    } /* for addr */
	} /* for board */

	/* make sure all the lastXXX flags are correct */
	for (d = firstd; d; d = d->NextDrive)
	{
		if (d->rdb)
		{
			flags = CalcFlags(d);

			if (flags != (d->rdb->rdb_Flags &
				      (RDBFF_LAST|RDBFF_LASTLUN|RDBFF_LASTTID)))
			{
				/* the flags aren't right: fix em */
				d->Flags |= UPDATE;
				d->rdb->rdb_Flags &=
				      ~(RDBFF_LAST|RDBFF_LASTLUN|RDBFF_LASTTID);
				d->rdb->rdb_Flags |= flags;
			}
		}
	}

	res = TRUE;
	goto dealloc;

cleanup:
	res = FALSE;
dealloc:
	if (ior)
		DeleteStdIO(ior);
	if (port)
		DeletePort(port);

	return res;
}








/* try to read via inquiry the type of drive and match against drives */
void
GetDriveType (ior,d)
	struct IOStdReq *ior;
	register struct Drive *d;
{
	register struct DriveDef *def;
	char inquiry[6],data[36];
	LONG version = 0,revision = 0;	// 39.9

	inquiry[0] = S_INQUIRY;
	inquiry[1] =
	inquiry[2] =
	inquiry[3] = 0;
	inquiry[4] = 36;
	inquiry[5] = 0;

	if (!DoSCSI(ior,(UWORD *) inquiry,6,(UWORD *) data,36,
		    SCSIF_READ|SCSIF_AUTOSENSE))
	{
		if (data[0] != 0 || (data[3] & 0x0F) != 1)
			return;
		if (def = FindDrive(d->Flags & SCSI ? SCSI_Defs : St506_Defs,
				    &data[8],&data[16],&data[32]))
		{
			d->oldrdb = NULL;
			d->bad    = NULL;
			d->rdb    = CopyRDB(def->Initial_RDB);
			d->Flags  = def->ControllerType;
			d->Block  = 0;

			if (!DoQuickSetup(d))
			{
				FreeRDB(d->rdb);
				return;
			}

			GetFSVersion("L:FastFileSystem",&version,&revision);

			/* add FFS to the drive */
			d->rdb->rdb_FileSysHeaderList =
			      MakeFileSys(NULL,d->rdb,"L:FastFileSystem",
					  'DOS\x01',version,revision);

			d->Flags |= UPDATE;
		}
	}
}


#define BIGBLOCKS	// 39.10


int
GetRDB (ior,d)
	struct IOStdReq *ior;
	struct Drive *d;
{
	ULONG size = 512;	/* default and only for st506 */
	register struct RigidDiskBlock *rdb = NULL;
	register struct RigidDiskBlock *newrdb;
	ULONG block;
	short i;

#ifdef BIGBLOCKS
	/* we use SCSI read commands for st506/xt drives as well because  */
	/* the driver will interpret them for us.			  */

	/* This is very critical part, but we need it at least for CD-ROM drive. */
	unsigned char inquiry[10];
	unsigned char data[36];
	ULONG lblock = 0;		/* logical block address */

	/* now try to find out what size the drive is */
	inquiry[0] = S_READ_CAPACITY;
	inquiry[1] = 0;
	inquiry[2] = (lblock & 0xff000000) >> 24;
	inquiry[3] = (lblock & 0x00ff0000) >> 16;
	inquiry[4] = (lblock & 0x0000ff00) >> 8;
	inquiry[5] = (lblock & 0x000000ff);
	inquiry[6] =
	inquiry[7] = 0;
	inquiry[8] = 0;		/* pmi (partical medium indicater) */
	inquiry[9] = 0;

	if (!DoSCSI(ior,(UWORD *) inquiry,10,(UWORD *) data,8,
		    SCSIF_READ|SCSIF_AUTOSENSE))
	{
		size = ((data[4] << 24) | (data[5] << 16) |
			(data[6] <<  8) | (data[7]));
		if (size == 0)		/* should not happen...., but... */
			goto CD_CHECK;
	} else {
CD_CHECK:
{
		/* FIX for CD-ROM device.
		   At first access to CD, READ CAPACITY command fails.
		   Ask device type and if it's CD-ROM device,
		   we set size 2048 bytes. It prevents lock up drive.  */

		/* ask drive type */
		inquiry[0] = S_INQUIRY;
		inquiry[1] =
		inquiry[2] =
		inquiry[3] = 0;
		inquiry[4] = 36;
		inquiry[5] = 0;

//		kprintf("Failed READ CAPACITY... Send INQUIRY.\n");

		if (!DoSCSI(ior,(UWORD *) inquiry,6,(UWORD *) data,36,
			    SCSIF_READ|SCSIF_AUTOSENSE))
		{
			if (data[0] == 0x05)	/* device type is CD-ROM */
				size = 2048;
			else			/* assume 512 */
				size = 512;
		}
		/* can't get inquiry back, assume 512 */
		else size = 512;
}
	}
//	kprintf("block size = %d\n",size);
#endif

	if (!(rdb = (struct RigidDiskBlock *)
		    AllocMem(size,MEMF_PUBLIC|MEMF_CLEAR)))
 		return NULL;

	/* first find rigid disk block, if it exists */
	for (block = 0; block < RDB_LOCATION_LIMIT; block++)
	{
		/* if read fails, abort immediately */
		if (!ReadBlock(ior,(APTR) rdb,size,block))
		{
			FreeMem((char *) rdb, size);
			return NULL;
		}
		/* make sure it's a rigiddiskblock */
		if (rdb->rdb_ID == IDNAME_RIGIDDISK &&
		    CheckCheckSum(rdb))
			break;
	}
	if (block == RDB_LOCATION_LIMIT)	/* i.e. didn't find it */
	{
		FreeMem((char *) rdb, size);
		return NULL;	/* didn't find it, but no errors */
	}

	if (!(newrdb = AllocNew(RigidDiskBlock)))
	{
		FreeMem((char *) rdb, size);
		return NULL;
	}

	*newrdb = *rdb;		/* copy the rigid disk portion of the sector */

	/* clear unused chains for easy error handling */
	for (i = 0; i < 6; i++)
		newrdb->rdb_Reserved1[i] = NULL;

	/* we have a valid rigid disk block! */


	if (!ReadBadBlockList(ior,newrdb,size,(struct BadBlockBlock *) rdb))
		goto bbb_error;
	if (!ReadPartitionList(ior,newrdb,size,(struct PartitionBlock *) rdb))
		goto pb_error;
	if (!ReadFileSysList(ior,newrdb,size,(struct FileSysHeaderBlock *) rdb))
		goto fsb_error;
	if (!ReadDriveInitList(ior,newrdb,size,(struct LoadSegBlock *) rdb))
		goto dvi_error;

	d->rdb    = newrdb;
	d->oldrdb = CopyRDB(newrdb);
	d->Block  = block;
	d->Flags |= PREPED;

	if (memcmp(newrdb->rdb_ControllerVendor,"Adaptec ",8) == SAME)
	{
		d->Flags |= ADAPTEC;
	}

	FreeMem((char *) rdb, size);

	return TRUE;

/* now the error handling code - easier to do this way so I don't free	   */
/* random memory pointed to by block numbers. All reserved lists are null. */

bbb_error:	newrdb->rdb_BadBlockList	= NULL;
pb_error:	newrdb->rdb_PartitionList	= NULL;
fsb_error:	newrdb->rdb_FileSysHeaderList	= NULL;
dvi_error:	newrdb->rdb_DriveInit		= NULL;

/*printf("Error reading sublists!\n");*/
	/* One of them had an error, dump the rigid disk block */
	FreeMem((char *) rdb, size);	/* the temp buffer 	 */
	FreeRDB(newrdb);		/* all the stuff read in */

	return FALSE;
}





int
ReadBadBlockList (ior,rdb,size,sec)
	struct IOStdReq *ior;
	struct RigidDiskBlock *rdb;
	long size;
	struct BadBlockBlock *sec;	/* size of sector */
{
	register struct BadBlockBlock *b,*lastb;
	register ULONG nextblock;
#ifdef USEINTERLEAVE
	register LONG sector;
	register short i;
	ULONG *map;
#endif

	nextblock = (ULONG) rdb->rdb_BadBlockList;
	rdb->rdb_BadBlockList = NULL;
	if (nextblock != 0xffffffff)
	{
		lastb = NULL;
		while (nextblock != 0xffffffff) {
			if (!(b = (struct BadBlockBlock *)
				  AllocMem(size,MEMF_PUBLIC)))
				return FALSE;

			if (!ReadBlockCheck(ior,(APTR) sec,size,nextblock,
					    IDNAME_BADBLOCK))
			{
				FreeMem((char *) b, size);
				return FALSE;
			}

			/* memcpy is to,from,size */
			memcpy((char *) b,(char *) sec,size);/* size may vary */

#ifdef USEINTERLEAVE
			if (rdb->rdb_Interleave > 1)
			{
				/* this use of sectors is ok */
				map = BuildInterleaveMap(rdb->rdb_Interleave,
							 rdb->rdb_Sectors);
				if (!map)
				{
					FreeMem((char *) b, size);
					return FALSE;
				}
			}

			/* 2 longs per entry */
			/* the bbe struct is 8 bytes long */
			for (i = 0; i < (b->bbb_SummedLongs - 6)/2; i++)
			{
			    /* translate sector numbers re: interleave        */
			    /* needed for switching interleaves.	      */
			    /* all sectors internally are interleave 1        */
			    if (rdb->rdb_Interleave > 1)
			    {
				/* first get sector on cylinder */
				sector = b->bbb_BlockPairs[i].bbe_BadBlock %
				         rdb->rdb_CylBlocks;

				/* I _think_ this use of sectors is ok */
				/* now make that sector on head */
				sector = sector % rdb->rdb_Sectors;

				/* translate to interleave 1           */
				/* '- sector' to give start of head    */
				/* FindSector searches table for match */

				b->bbb_BlockPairs[i].bbe_BadBlock +=
					FindSector(map,sector) - sector;
			    }
			}
			if (rdb->rdb_Interleave > 1)
				FreeMem((char *) map,rdb->rdb_Sectors * 4);
#endif

			if (lastb == NULL)
				rdb->rdb_BadBlockList = b;
			else
				lastb->bbb_Next = b;

/*printf("Got BadBlock block %d\n",nextblock);*/

			nextblock = (LONG) b->bbb_Next;
			b->bbb_Next = NULL;

			lastb = b;
		}
	}
	return TRUE;
}


void AddPartitionList(struct RigidDiskBlock *rdb, struct PartitionBlock *p) {

struct PartitionBlock **sp, *tp;

  if (rdb->rdb_PartitionList == NULL) {
    rdb->rdb_PartitionList = p;
    p->pb_Next = NULL;
    }

  else {
    sp = &rdb->rdb_PartitionList;

    while (*sp) {

      if (p->pb_Environment[DE_LOWCYL] < (*sp)->pb_Environment[DE_LOWCYL]) {
        tp = *sp;
        *sp = p;
        p->pb_Next = tp;
        return;
        }

      sp = &((*sp)->pb_Next);
      }

    *sp = p;
    p->pb_Next = NULL;
    }
  }



int
ReadPartitionList (ior,rdb,size,sec)
	struct IOStdReq *ior;
	struct RigidDiskBlock *rdb;
	long size;
	struct PartitionBlock *sec;	/* size of sector */
{
	register struct PartitionBlock *p;
	register LONG nextblock;

	nextblock = (LONG) rdb->rdb_PartitionList;
	rdb->rdb_PartitionList = NULL;
	if (nextblock != 0xffffffff)
	{
		while (nextblock != 0xffffffff) {
			if (!(p = AllocNew(PartitionBlock)))
				return FALSE;
			if (!ReadBlockCheck(ior,(APTR) sec,size,nextblock,
					    IDNAME_PARTITION))
			{
				FreeMem((char *) p, sizeof(*p));
				return FALSE;
			}
			*p = *sec;

/*printf("Got partition %s at block %d\n",p->pb_DriveName,nextblock);*/

			nextblock = (LONG) p->pb_Next;

                        AddPartitionList(rdb, p);

			BtoCStr(p->pb_DriveName);
		}
	}
	return TRUE;
}

int
ReadFileSysList (ior,rdb,size,sec)
	struct IOStdReq *ior;
	struct RigidDiskBlock *rdb;
	long size;
	struct FileSysHeaderBlock *sec;	/* size of sector */
{
	register struct FileSysHeaderBlock *f,*lastf;
	register LONG nextblock;

	nextblock = (LONG) rdb->rdb_FileSysHeaderList;
	rdb->rdb_FileSysHeaderList = NULL;
	if (nextblock != 0xffffffff)
	{
		lastf = NULL;
		while (nextblock != 0xffffffff) {
			if (!(f = AllocNew(FileSysHeaderBlock)))
				return FALSE;
			if (!ReadBlockCheck(ior,(APTR) sec,size,nextblock,
					    IDNAME_FILESYSHEADER))
			{
				FreeMem((char *) f, sizeof(*f));
				return FALSE;
			}
			*f = *sec;	/* structure copy */
			if (lastf == NULL)
				rdb->rdb_FileSysHeaderList = f;
			else
				lastf->fhb_Next = f;

/*printf("Got FileSystem 0x%lx %d at block %d\n",f->fhb_DosType,f->fhb_Version,nextblock);*/

			nextblock = (LONG) f->fhb_Next;
			f->fhb_Next = NULL;

			/* now read in the file system */
			if (!ReadLoadSegList(ior,f,size,
					     (struct LoadSegBlock *) sec))
			{
				FreeMem((char *) f, sizeof(*f));
				if (lastf)
					lastf->fhb_Next = NULL;
				else
					rdb->rdb_FileSysHeaderList = NULL;

				return FALSE;
			}

			lastf = f;
		}
	}
	return TRUE;
}

int
ReadDriveInitList (ior,rdb,size,sec)
	struct IOStdReq *ior;
	struct RigidDiskBlock *rdb;
	long size;
	struct LoadSegBlock *sec;	/* size of sector */
{
	register struct LoadSegBlock *l,*lastl;
	register LONG nextblock;

	nextblock = (LONG) rdb->rdb_DriveInit;
	rdb->rdb_DriveInit = NULL;
	if (nextblock != 0xffffffff)
	{
		lastl = NULL;
		while (nextblock != 0xffffffff) {
			if (!(l = (struct LoadSegBlock *)
				  AllocMem(size,MEMF_PUBLIC)))
				return FALSE;
			if (!ReadBlockCheck(ior,(APTR) sec,size,nextblock,
					    IDNAME_LOADSEG))
			{
				FreeMem((char *) l, size);
				return FALSE;
			}

			/* memcpy is to,from,size */
			memcpy((char *) l,(char *) sec,size);

			if (lastl == NULL)
				rdb->rdb_DriveInit = l;
			else
				lastl->lsb_Next = l;

/*printf("Got LoadSegBlock block at %d\n",nextblock);*/

			nextblock = (LONG) l->lsb_Next;
			l->lsb_Next = NULL;

			lastl = l;
		}
	}
	return TRUE;
}

int
ReadLoadSegList (ior,f,size,sec)
	struct IOStdReq *ior;
	struct FileSysHeaderBlock *f;
	long size;
	struct LoadSegBlock *sec;	/* size of sector */
{
	register struct LoadSegBlock *l,*lastl;
	register LONG nextblock;

	nextblock = (LONG) f->fhb_SegListBlocks;
	f->fhb_SegListBlocks = NULL;
	if (nextblock != 0xffffffff)
	{
		lastl = NULL;
		while (nextblock != 0xffffffff) {
			if (!(l = (struct LoadSegBlock *)
				  AllocMem(size,MEMF_PUBLIC)))
				return FALSE;
			if (!ReadBlockCheck(ior,(APTR) sec,size,nextblock,
					    IDNAME_LOADSEG))
			{
				FreeMem((char *) l, size);
				return FALSE;
			}

			/* memcpy is to,from,size */
			memcpy((char *) l,(char *) sec,size);

			if (lastl == NULL)
				f->fhb_SegListBlocks = l;
			else
				lastl->lsb_Next = l;

/*printf("Got LoadSegBlock block at %d\n",nextblock);*/

			nextblock = (LONG) l->lsb_Next;
			l->lsb_Next = NULL;

			lastl = l;
		}
	}
	return TRUE;
}

/* read a block off the drive.  ior is already opened */

int
ReadBlock (ior,dest,size,block)
	register struct IOStdReq *ior;
	APTR dest;
	LONG size;	/* size of blocks */
	LONG block;	/* which block # to read */
{
	ior->io_Data   = dest;
	ior->io_Offset = size * block;
	ior->io_Length = size;
	ior->io_Command = CMD_READ;

	DoIO((struct IORequest *) ior);
	return (ior->io_Error == 0);
}

/* Read a block, verify ID and checksum */

int
ReadBlockCheck (ior,dest,size,block,id)
	struct IOStdReq *ior;
	APTR dest;
	LONG size;	/* size of blocks */
	LONG block;	/* which block # to read */
	LONG id;
{
	if (ReadBlock(ior,dest,size,block) &&
	    *((LONG *) dest) == id &&
	    CheckCheckSum((struct RigidDiskBlock *) dest))
		return TRUE;

	return FALSE;
}

/* convert C string to BCPL string */

void
CtoBStr (str)
	register char *str;
{
	register int len,i;

	len = strlen(str);
	for (i = len; i > 0; i--)
		str[i] = str[i-1];

	str[0] = (char) len;
}

/* convert BCPL string to C string */

void
BtoCStr (str)
	register char *str;
{
	register int len,i;

	len = str[0];
	for (i = 0; i < len; i++)	/* note: overlapping copy */
		str[i] = str[i+1];

	str[len] = '\0';
}

/* read all defs in a given directory, perhaps multiple per file */
/* if "dir" is really a file, only read what's in that file.	 */
/* if two defs for same drive, only keep the most recent 	 */

struct DriveDef *
GetDefs (dir,type)
	char *dir;
	int type;	/* SCSI | ST506 */
{
	struct DriveDef *d = NULL;
	char pathname[256];
	register BPTR dirlock;
	register struct FileInfoBlock *fib;	/* must be long-aligned */
	register int len;

	if (!(fib = (struct FileInfoBlock *)
		    AllocMem(sizeof(struct FileInfoBlock),
			     MEMF_PUBLIC|MEMF_CLEAR)))
		return NULL;

	/* build pathname */
	strcpy(pathname,dir);
	len = strlen(pathname);

	if (dirlock = Lock(dir,ACCESS_READ))
	{
		if (Examine(dirlock,fib))
		{
			if (fib->fib_DirEntryType < 0)	/* file */
			{
				d = ReadDefs(pathname,d,type);

			} else {
				/* set up pathname for additions */
				if (len && pathname[len-1] != ':' &&
				    pathname[len-1] != '/')
				{
					pathname[len] = '/';
					pathname[++len] = '\0';
				}

				/* examine everything in directory */
				while (ExNext(dirlock,fib)) {
				   if (fib->fib_DirEntryType < 0) /* file */
				   {
				      strcpy(&pathname[len],fib->fib_FileName);
				      d = ReadDefs(pathname,d,type);
				   }
				}
			}
		}
		UnLock(dirlock);
	}

	FreeMem((char *) fib, sizeof(*fib));
	return d;
}

/* read in all the defs in a file, if it is a drive definition file */

struct DriveDef *
ReadDefs (file,defs,type)
	char *file;
	struct DriveDef *defs;
	int type;
{
	register struct DiskDrive *dd;
	register struct DriveDef  *d;
	BPTR fh;
	register int done = FALSE;
	ULONG offset;

	if (fh = Open(file,MODE_OLDFILE))
	{
		while (!done) {
		  if (dd = AllocNew(DiskDrive))
		  {
		    offset = Seek(fh,0L,OFFSET_CURRENT);
		    if (sizeof(*dd) == Read(fh,(char *) dd,sizeof(*dd)))
		    {
		      if (dd->Ident == IDNAME_DRIVE)
		      {
			if (dd->ControllerType & type)
			{
			  if (d = AllocNew(DriveDef))
			  {
			    if (d->Initial_RDB = AllocNew(RigidDiskBlock))
			    {
			      /* finally! we have it */
			      *(d->Initial_RDB) = dd->rdb;
			      d->ds 		= dd->ds; /* struct copy */
			      d->Offset		= offset;
			      d->ControllerType = dd->ControllerType;
			      d->Reserved1	= dd->Reserved1;
			      d->Reserved2	= dd->Reserved2;
			      d->Succ = d->Prev = NULL;
			      strncpy(d->Filename,file,128);

			      CheckDefDates(&defs,d); /* also links into list */

			    } else {
			      done = TRUE;
			      FreeMem((char *) d, sizeof(*d));
			    }
			  } else
			    done = TRUE;
			} /* no else - if wrong type, continue */
		      } else
		 	done = TRUE;
		    } else
		      done = TRUE;

		    FreeMem((char *) dd, sizeof(*dd));
		  } else
		    done = TRUE;
		}
		Close(fh);
	}

	return defs;
}

/* check for duplicates, keep one with newest date */
/* also links in d to defs, can modify *defs       */

void
CheckDefDates (defs,d)
	struct DriveDef **defs;
	register struct DriveDef *d;
{
	register struct DriveDef *tmp;
	int done = FALSE;

	if (*defs)
	{
		for (tmp = *defs; tmp; tmp = tmp->Succ)
		{
			/* if there are duplicates, check datestamps */

			if (SameDrive(tmp->Initial_RDB,d->Initial_RDB))
			{
				if (d->ds.ds_Days   > tmp->ds.ds_Days   ||
				    d->ds.ds_Minute > tmp->ds.ds_Minute ||
				    d->ds.ds_Tick   > tmp->ds.ds_Tick)
				{
					/* d is newer, replace */
					d->Succ = tmp->Succ;
					d->Prev = tmp->Prev;
					if (d->Prev)
						d->Prev->Succ = d;
					if (d->Succ)
						d->Succ->Prev = d;
					if (*defs == tmp)
						*defs = d;

					FreeMem((char *) tmp->Initial_RDB,
						sizeof(struct RigidDiskBlock));
					FreeMem((char *) tmp, sizeof (*tmp));
				} else {
					/* tmp is newer, drop d */
					FreeMem((char *) d->Initial_RDB,
						sizeof(struct RigidDiskBlock));
					FreeMem((char *) d, sizeof (*d));
				}
				done = TRUE;
				break;
			}
		}
		if (!done)
		{
			/* no duplicates, so just link in at head */
			d->Prev = NULL;
			d->Succ = *defs;
			(*defs)->Prev = d;
			*defs = d;
		}
	} else
		*defs = d;	/* no other entries */
}

/* Find drive with same name, etc, or return NULL */

struct DriveDef *
FindDrive (list,man,prod,rev)
	struct DriveDef *list;
	char *man,*prod,*rev;
{
	register struct DriveDef *dd;

	for (dd = list; dd; dd = dd->Succ)
	{
		if (memcmp(man,dd->Initial_RDB->rdb_DiskVendor,8) == SAME &&
		    memcmp(prod,dd->Initial_RDB->rdb_DiskProduct,16) == SAME &&
		    memcmp(rev,dd->Initial_RDB->rdb_DiskRevision,4) == SAME)

			return(dd);
	}
	return NULL;
}


/* do any SCSI command using the supplied iorequest, ret 0=success or error */
/* data must be word aligned and dmaable */
/* ditto for command */

UBYTE  sensedata[255];
struct SCSICmd cmdblk;

int
DoSCSI (ior,command,clen,data,dlen,flags)
	register struct IOStdReq *ior;
	UWORD *command;
	ULONG clen;
	UWORD *data;
	ULONG dlen;
	ULONG flags; /* only a ubyte used for actual xfer, rest for this rtn */
{

	SendSCSI(ior,command,clen,data,dlen,flags);
	WaitIO((struct IORequest *) ior);

#ifdef TEST_SCSI
printf("direct scsi return error %d, status %d\n",ior->io_Error,cmdblk.scsi_Status);
if (cmdblk.scsi_SenseActual)
{
int i;
printf("Sense data (length %d) = 0x",cmdblk.scsi_SenseActual);
for(i = 0; i < cmdblk.scsi_SenseActual; i++)
printf("%02.2x",sensedata[i]);
printf("\n");
}
#endif
	if (cmdblk.scsi_Status)
		return (int)cmdblk.scsi_Status;

	return (int)ior->io_Error;	/* see scsidisk.h for errors */
}

void
SendSCSI (ior,command,clen,data,dlen,flags)
	register struct IOStdReq *ior;
	UWORD *command;
	ULONG clen;
	UWORD *data;
	ULONG dlen;
	ULONG flags; /* only a ubyte used for actual xfer, rest for this rtn */
{
	/* first set up ior */
	ior->io_Data    = (APTR) &cmdblk;
	ior->io_Length  = sizeof(cmdblk);
	ior->io_Actual  = ior->io_Offset = 0;
	ior->io_Command = HD_SCSICMD;

	/* now set up cmdblk */
	cmdblk.scsi_Data      = data;
	cmdblk.scsi_Length    = dlen;
	cmdblk.scsi_Actual    = 0;
	cmdblk.scsi_Command   = (UBYTE *) command;
	cmdblk.scsi_CmdLength = clen;
	cmdblk.scsi_CmdActual = 0;
	cmdblk.scsi_Flags     = flags & 0xff; /* probably not needed */
	cmdblk.scsi_Status    = 0;
	cmdblk.scsi_SenseData = sensedata;
	cmdblk.scsi_SenseLength = sizeof(sensedata);
	cmdblk.scsi_SenseActual = 0;
	cmdblk.scsi_NextLinked  = NULL;

	SendIO((struct IORequest *) ior);
}







/* return the LASTLUN, LASTTID, or LAST flags */
/* if the driver handles one board, LASTTID | LASTLUN == LAST */

LONG CalcFlags(register struct Drive *d) {

register struct Drive *d2;
register LONG flags = 0;

  if (d->NextDrive == NULL) flags = RDBFF_LAST | RDBFF_LASTLUN | RDBFF_LASTTID;
  else if (strcmp(&(d->NextDrive->DeviceName[0]),&(d->DeviceName[0])) != SAME) {
    /* Last of this device driver - set all flags */
    flags = RDBFF_LAST | RDBFF_LASTLUN | RDBFF_LASTTID;
    }

  else if (d->NextDrive->Addr != d->Addr) {

    /* last at this address */
    flags = RDBFF_LASTLUN;
    if (d->NextDrive->Addr/100 != d->Addr/100) {
      /* next one is on another board */
      flags |= RDBFF_LASTTID;
      }
    }

  else {

    /* are all the rest on the same address and driver? */
    flags |= RDBFF_LASTTID;                             /* assume yes */
    for (d2=d->NextDrive; d2; d2=d2->NextDrive) {
      if (d2->Addr != d->Addr
        || strcmp(&(d2->DeviceName[0]), &(d->DeviceName[0])) != SAME) {
        /* no, there's one at a diff addr or driver */
        flags &= ~RDBFF_LASTTID;
        break;
        }
      }
    }

  return flags;
  }







/* build an interleave translation table - essentially a hash table */

ULONG *
BuildInterleaveMap (interleave,sectors)
	ULONG interleave,sectors;
{
	ULONG *ptr,sec,lastsec;

	if (ptr = (ULONG *) AllocMem(sectors * sizeof(ULONG),MEMF_CLEAR))
	{
		lastsec = 0;
		for (sec = 1; sec < sectors; sec++)
		{
			lastsec = (lastsec + interleave) % sectors;
			while (1)
			{
				/* make sure it isn't used already */
				if (!lastsec || ptr[lastsec])
					lastsec++;
				else
					break;
			}
			ptr[lastsec] = sec;
		}
	}

	return ptr;
}

/* searches a map for a sector */
ULONG
FindSector (map,sector)
	ULONG *map,sector;
{
	ULONG i = 0;

	/* assumes match will be found! */
	while (map[i] != sector)
		i++;

	return i;
}

@


36.9
log
@Partition block saves host id what user add.
@
text
@d48 3
d455 2
a456 1
			Move(rp,140,100);
@


36.8
log
@Changed from "MODE_SENSE" to "READ_CAPACITY" for checking block size.
(IDE drive can't provide block size imformation with MODE_SENSE.)
@
text
@a43 2
#define AllocNew(t)	((struct t *) AllocMem(sizeof(struct t),MEMF_CLEAR))

a45 1

a47 5





d51 13
a63 1
int CommitChanges(struct Window *w, int informat) {
d65 12
a76 23
register struct Drive *d = SelectedDrive;
struct RigidDiskBlock *rdb;
struct PartitionBlock *p,*lastp,*newp;
struct FileSysHeaderBlock *fs,*lastfs,*newfs;
struct LoadSegBlock *ls,*lastls,*newls;
struct BadBlockBlock *bb,*lastbb,*newbb;
struct IOStdReq *ior = NULL;
struct MsgPort *port = NULL;
int  result = FALSE, opened = FALSE;
LONG maxblock,blocks,i,flags,low_badblock;
char *array = NULL;

  if (!d || !d->rdb) return FALSE;

  if (!(port = CreatePort(0L,0L))) goto cleanup;
  if (!(ior = CreateStdIO(port))) goto cleanup;

  /* now write out array starting at block d->Block */
  if (i = OpenDevice(d->DeviceName, d->Addr + d->Lun * 10,
    (struct IORequest *)ior, 0L)) {
    Notify(w,"Error %d on device open!",i);
    goto cleanup;
    }
d78 1
a78 1
  opened = TRUE;
d80 44
a123 30
  if (d->oldrdb && AnalyzePartitions(d->rdb,d->oldrdb)) {
    if (!AskSure(w,CommitText)) goto cleanup;
    else ForceReboot = TRUE;     /* reboot WILL be needed! */
    } /* don't ask if nothing will be lost or wasn't preped before */

  /* ok, the user wants us to write it out */

  /* try to reassign any bad blocks the user entered */
  ReassignAll(d,ior);

  /* first, get the memory */
  blocks = CountBlocks(d->rdb);

  if (!(array = AllocMem(blocks * d->rdb->rdb_BlockBytes + 20,
     MEMF_PUBLIC | MEMF_CLEAR))) goto cleanup;

  ior->io_Data          = (APTR) array;
  ior->io_Length        = blocks * d->rdb->rdb_BlockBytes;
  ior->io_Offset        = d->Block * d->rdb->rdb_BlockBytes;
  ior->io_Command       = CMD_WRITE;

  /* set the LASTLUN, LASTTID, or LAST flags in the RDB if needed */
  /* since the driver only handles one board, LASTTID|LASTLUN == LAST */
  flags = CalcFlags(d);
  if (flags != (d->rdb->rdb_Flags & (RDBFF_LAST | RDBFF_LASTLUN | RDBFF_LASTTID))) {
    /* the flags aren't right: fix em */
    d->Flags |= UPDATE;
    d->rdb->rdb_Flags &= ~(RDBFF_LAST|RDBFF_LASTLUN|RDBFF_LASTTID);
    d->rdb->rdb_Flags |= flags;
    }
d125 2
a126 3
  rdb  = (struct RigidDiskBlock *) array;
  *rdb = *(d->rdb);     /* structure copy */
  rdb->rdb_HostID = HOST_ID;
d128 1
a128 20
  /* set all the null pointers to 0xffffffff */
  rdb->rdb_BadBlockList      = (struct BadBlockBlock *)0xffffffff;
  rdb->rdb_PartitionList     = (struct PartitionBlock *)0xffffffff;
  rdb->rdb_FileSysHeaderList = (struct FileSysHeaderBlock *)0xffffffff;
  rdb->rdb_DriveInit         = (struct LoadSegBlock *)0xffffffff;

  for (i = 0; i < 6; i++) rdb->rdb_Reserved1[i] = (ULONG)0xffffffff;

  maxblock = d->Block;	/* start at the old rigid disk block, or 0 */
 
  /* Partitions next */

  for (lastp=NULL, p=d->rdb->rdb_PartitionList; p; lastp=newp, p=p->pb_Next) {
    maxblock++;
    if (lastp) lastp->pb_Next = (struct PartitionBlock *)maxblock;
    else rdb->rdb_PartitionList = (struct PartitionBlock *)maxblock;

    newp = (struct PartitionBlock *) GetBlock(maxblock);
    *newp = *p; /* structure copy */
    CtoBStr(&(newp->pb_DriveName[0]));
d130 48
a177 3
    newp->pb_HostID = HOST_ID;
    newp->pb_Next   = (struct PartitionBlock *) 0xffffffff;
    }
d179 1
a179 1
  /* now file systems */
d181 39
a219 24
  for (lastfs=NULL, fs=d->rdb->rdb_FileSysHeaderList; fs;
    lastfs=newfs, fs=fs->fhb_Next) {
    maxblock++;
    if (lastfs) lastfs->fhb_Next = (struct FileSysHeaderBlock *) maxblock;
    else rdb->rdb_FileSysHeaderList = (struct FileSysHeaderBlock *)maxblock;

    newfs = (struct FileSysHeaderBlock *) GetBlock(maxblock);
    *newfs = *fs; /* structure copy */

    newfs->fhb_HostID = HOST_ID;

    newfs->fhb_SegListBlocks = (struct LoadSegBlock *) 0xffffffff;
    newfs->fhb_Next = (struct FileSysHeaderBlock *) 0xffffffff;

    /* now loadsegblocks */

    for (lastls=NULL, ls=fs->fhb_SegListBlocks; ls; lastls=newls, ls=ls->lsb_Next) {
      maxblock++;
      if (lastls) lastls->lsb_Next = (struct LoadSegBlock *)maxblock;
      else newfs->fhb_SegListBlocks = (struct LoadSegBlock *)maxblock;

      newls = (struct LoadSegBlock *) GetBlock(maxblock);

      /* to, from, size in bytes */
d221 5
a225 1
      memcpy((char *) newls, (char *) ls, ls->lsb_SummedLongs << 2);
d227 5
a231 4
      newls->lsb_HostID = HOST_ID;
      newls->lsb_Next   = (struct LoadSegBlock *) 0xffffffff;
      }
    }
d233 7
a239 3
  /* now bad blocks */

  low_badblock = d->rdb->rdb_RDBBlocksHi + 1;
d241 2
a242 24
  for (lastbb=NULL, bb=d->rdb->rdb_BadBlockList; bb; lastbb=newbb, bb=bb->bbb_Next) {
    maxblock++;
    if (lastbb) lastbb->bbb_Next = (struct BadBlockBlock *)maxblock;
    else rdb->rdb_BadBlockList = (struct BadBlockBlock *)maxblock;

    newbb = (struct BadBlockBlock *) GetBlock(maxblock);

    /* to, from, size in bytes */

    memcpy((char *) newbb,(char *) bb,bb->bbb_SummedLongs << 2);

    {

      short i;
      LONG  good;
      ULONG *map;

      if (d->rdb->rdb_Interleave > 1) {
        /* this usage of sectors is correct */
        map = BuildInterleaveMap(d->rdb->rdb_Interleave,
        d->rdb->rdb_Sectors);
        if (!map)
        goto cleanup;
        }
d244 3
a246 4
      /* 2 longs per entry */
      for (i = 0; i < (newbb->bbb_SummedLongs - 6)/2; i++) {
        /* first, maintain low_badblock */
        good = newbb->bbb_BlockPairs[i].bbe_GoodBlock;
d248 3
a250 25
        /* first, maintain low_badblock */
        if (good > 0 && good < low_badblock) {
          low_badblock = good;
          }

#ifdef USEINTERLEAVE
        /* second, translate sector numbers re: interleave*/
        /* needed for switching interleaves.	      */
        /* map already built			      */
        /* all sectors internally are interleave 1        */

        if (d->rdb->rdb_Interleave > 1) {

          LONG sec;

          /* first get sector on cylinder */
          sec = newbb->bbb_BlockPairs[i].bbe_BadBlock % d->rdb->rdb_CylBlocks;

          /* I _think_ this use of sector is ok */
          /* now make that sector on head */
          sec = sec % d->rdb->rdb_Sectors;

          /* '- sec' to give start of head */
          newbb->bbb_BlockPairs[i].bbe_BadBlock += map[sec] - sec;
          }
d252 1
a252 1
        }
d254 3
a256 3
      if (d->rdb->rdb_Interleave > 1)
      FreeMem((char *) map,d->rdb->rdb_Sectors * 4);
      }
d258 32
a289 3
    newbb->bbb_HostID = HOST_ID;
    newbb->bbb_Next   = (struct BadBlockBlock *) 0xffffffff;
    }
d291 3
a293 10
  /* drive init code */
  for (lastls=NULL, ls=d->rdb->rdb_DriveInit; ls; lastls=newls, ls=ls->lsb_Next) {
    maxblock++;
    if (lastls) lastls->lsb_Next = (struct LoadSegBlock *)maxblock;
    else rdb->rdb_DriveInit = (struct LoadSegBlock *)maxblock;

    newls = (struct LoadSegBlock *) GetBlock(maxblock);

    /* to, from, size in bytes */
    memcpy((char *)newls, (char *)ls, ls->lsb_SummedLongs << 2);
d295 2
a296 3
    newls->lsb_HostID = HOST_ID;
    newls->lsb_Next   = (struct LoadSegBlock *) 0xffffffff;
    }
d298 16
a313 26
  rdb->rdb_HighRDSKBlock = maxblock;

  if (maxblock >= low_badblock) {
    Notify(w,"Save failed, not enough space for configuration data", 0);
    /* FIX! - add rdsk cylinder gadget */
    Notify(w, "Try a low-level format, or removing file systems or partitions", 0);
    goto cleanup;
    }

  /* checksum all the blocks */
  for (i = d->Block; i <= maxblock; i++) 
    CheckSumBlock((struct RigidDiskBlock *) GetBlock(i));

  /* now write out array starting at block d->Block */
  DoIO((struct IORequest *) ior);

  if (ior->io_Error) {
    if (!informat) {
      Notify(w,"Error %d on write!",(LONG) (ior->io_Error));
      goto cleanup;
      }
    else {
      /* don't care if it failed for format */
      return TRUE;
      }
    }
d315 1
a315 2
  /* note that this drive had it's RDSK written out */
  d->Flags |= WRITTEN;
a316 2
  result = TRUE;

d318 4
a321 4
  if (opened) CloseDevice((struct IORequest *) ior);
  if (ior)    DeleteStdIO(ior);
  if (port)   DeletePort(port);
  if (array)  FreeMem(array,blocks * d->rdb->rdb_BlockBytes + 20);
d323 2
a324 5
  return result;
  }



a326 1

d338 1
a338 1
	for (p = rdb->rdb_PartitionList; p; p = p->pb_Next)
d341 1
a341 1
	for (fsb = rdb->rdb_FileSysHeaderList; fsb; fsb = fsb->fhb_Next)
d344 1
a344 1
		for (lsb = fsb->fhb_SegListBlocks; lsb; lsb = lsb->lsb_Next)
d348 1
a348 1
	for (bb = rdb->rdb_BadBlockList; bb; bb = bb->bbb_Next)
d351 1
a351 1
	for (lsb = rdb->rdb_DriveInit; lsb; lsb = lsb->lsb_Next)
d371 1
a371 1
	for (i = 0; i < rdb->rdb_SummedLongs; i++)
d396 1
a396 1
	for (i = 0; i < rdb->rdb_SummedLongs; i++)
a412 8








d520 1
a520 1
				d->rdb->rdb_Flags &= 
d617 2
a618 3
	unsigned char readcapacity[10];
	unsigned char rc_data[8];
	int pmi = 0;			/* partical medium indicater */
d622 10
a631 10
	readcapacity[0] = S_READ_CAPACITY;
	readcapacity[1] = 0;
	readcapacity[2] = (lblock & 0xff000000) >> 24;
	readcapacity[3] = (lblock & 0x00ff0000) >> 16;
	readcapacity[4] = (lblock & 0x0000ff00) >> 8;
	readcapacity[5] = (lblock & 0x000000ff);
	readcapacity[6] =
	readcapacity[7] = 0;
	readcapacity[8] = pmi;
	readcapacity[9] = 0;
d633 1
a633 1
	if (!DoSCSI(ior,(UWORD *) readcapacity,10,(UWORD *) rc_data,8,
d636 2
a637 2
		size = ((rc_data[4] << 24) | (rc_data[5] << 16) |
			(rc_data[6] <<  8) | (rc_data[7]));
a646 2
		unsigned char inquiry[6];
		unsigned char i_data[36];
d651 1
a651 1
		inquiry[2] = 
d658 1
a658 1
		if (!DoSCSI(ior,(UWORD *) inquiry,6,(UWORD *) i_data,36,
d661 1
a661 1
			if (i_data[0] == 0x05)	/* device type is CD-ROM */
d1236 1
a1236 1
		    } else 
@


36.7
log
@Check block size for non-512 (CD-ROM drive)
@
text
@d609 5
a613 3
	/* Lattice will always word-align these */
	unsigned char modesense[6];
	unsigned char modes[12];  /* inc descriptors, not inc parameters */
d615 11
a625 8
	/* read the sector size from the drive */
	modesense[0] = S_MODE_SENSE;
	modesense[1] = 			/* driver will fill in lun */
	modesense[2] = 
	modesense[3] = 0;
	modesense[4] = 12;
	modesense[5] = 0;
//	modesense[6] = 0;
d627 1
a627 1
	if (!DoSCSI(ior,(UWORD *) modesense,6,(UWORD *) modes,12,
d630 4
a633 1
		size = modes[9] * 0x10000 + modes[10] * 0x100 + modes[11];
d635 5
a639 4
	{	
		/* FIX for CD-ROM device, actually MODE_SENSE should return correct
		   information, but in some ocations this command returns error.
		   This part just asks device type and if it's CD-ROM device,
d641 2
a642 1
		char data[36];
d645 6
a650 6
		modesense[0] = S_INQUIRY;
		modesense[1] = 			/* driver will fill in lun */
		modesense[2] = 
		modesense[3] = 0;
		modesense[4] = 36;
		modesense[5] = 0;
d652 1
a652 1
//		kprintf("Failed MODE_SENSE... Send INQUIRY.\n");
d654 1
a654 1
		if (!DoSCSI(ior,(UWORD *) modesense,6,(UWORD *) data,36,
d657 1
a657 1
			if (data[0] == 0x05)	/* device type is CD-ROM */
d664 1
d666 1
a666 1
	}
a667 2
//	sprintf(tmp,"size = %d",size);
//	kprintf("%s\n",tmp);
@


36.6
log
@Add GetFSVersion() and change MakeFileSys()
@
text
@d445 1
a445 1
			Move(rp,60,100);
a446 1

d591 1
a591 2


a614 1
	modesense[4] = 12;
d617 4
a620 3
	modesense[3] = 
	modesense[5] =
	modesense[6] = 0;
d627 28
a654 2
		/* can't get modesense back, assume 512 */
		size = 512;
d657 2
d662 1
a662 1
		return NULL;
@


36.5
log
@sorts partition lists in ascending cylinder order
@
text
@d550 1
d579 2
d584 1
a584 1
					  'DOS\x01',0);
a595 1

d908 1
a908 1
/*printf("Got FileSystem 0x%lx at block %d\n",f->fhb_DosType,nextblock);*/
@


36.4
log
@Compile warning messages removed

@
text
@d10 1
d807 32
d846 1
a846 1
	register struct PartitionBlock *p,*lastp;
a852 1
		lastp = NULL;
a863 7
			if (lastp == NULL)
				rdb->rdb_PartitionList = p;
			else
				lastp->pb_Next = p;

			BtoCStr(p->pb_DriveName);

a866 1
			p->pb_Next = NULL;
d868 3
a870 1
			lastp = p;
@


36.3
log
@Allocate/FreeMem size inconsistancy fixed.
@
text
@a49 35
/* TRUE == success, FALSE == failure */

int
CommitChanges (w,informat)
	struct Window *w;
	int informat;		/* TRUE means don't tell of errors */
{
	register struct Drive *d = SelectedDrive;
	struct RigidDiskBlock *rdb;
	struct PartitionBlock *p,*lastp,*newp;
	struct FileSysHeaderBlock *fs,*lastfs,*newfs;
	struct LoadSegBlock *ls,*lastls,*newls;
	struct BadBlockBlock *bb,*lastbb,*newbb;
	struct IOStdReq *ior = NULL;
	struct MsgPort *port = NULL;
	int  result = FALSE, opened = FALSE;
	LONG maxblock,blocks,i,flags,low_badblock;
	char *array = NULL;

	if (!d || !d->rdb)		/* sanity */
		return FALSE;

	if (!(port = CreatePort(0L,0L)))
		goto cleanup;
	if (!(ior = CreateStdIO(port)))
		goto cleanup;

	/* now write out array starting at block d->Block */
	if (i = OpenDevice(d->DeviceName,d->Addr + d->Lun * 10,
			   (struct IORequest *) ior,0L))
	{
		Notify(w,"Error %d on device open!",i);
		goto cleanup;
	}
	opened = TRUE;
a51 16
	if (d->oldrdb && AnalyzePartitions(d->rdb,d->oldrdb))
	{
		if (!AskSure(w,CommitText))
				goto cleanup;

		/* reboot WILL be needed! */
		ForceReboot = TRUE;
	} /* don't ask if nothing will be lost or wasn't preped before */

	/* ok, the user wants us to write it out */

	/* try to reassign any bad blocks the user entered */
	ReassignAll(d,ior);

	/* first, get the memory */
	blocks = CountBlocks(d->rdb);
a52 3
	if (!(array = AllocMem(blocks * d->rdb->rdb_BlockBytes + 20,
			       MEMF_PUBLIC | MEMF_CLEAR)))	/* ^ safety*/
		goto cleanup;
a53 4
	ior->io_Data 	= (APTR) array;
	ior->io_Length	= blocks * d->rdb->rdb_BlockBytes;
	ior->io_Offset	= d->Block * d->rdb->rdb_BlockBytes;
	ior->io_Command	= CMD_WRITE;
d55 2
a56 24
	/* set the LASTLUN, LASTTID, or LAST flags in the RDB if needed */
	/* since the driver only handles one board, LASTTID|LASTLUN == LAST */
	flags = CalcFlags(d);

	if (flags != (d->rdb->rdb_Flags &
		      (RDBFF_LAST|RDBFF_LASTLUN|RDBFF_LASTTID)))
	{
		/* the flags aren't right: fix em */
		d->Flags |= UPDATE;
		d->rdb->rdb_Flags &= ~(RDBFF_LAST|RDBFF_LASTLUN|RDBFF_LASTTID);
		d->rdb->rdb_Flags |= flags;
	}

	rdb  = (struct RigidDiskBlock *) array;
	*rdb = *(d->rdb);	/* structure copy */
	rdb->rdb_HostID = HOST_ID;

	/* set all the null pointers to 0xffffffff */
	rdb->rdb_BadBlockList	   = (struct BadBlockBlock *)      0xffffffff;
	rdb->rdb_PartitionList     = (struct PartitionBlock *)     0xffffffff;
	rdb->rdb_FileSysHeaderList = (struct FileSysHeaderBlock *) 0xffffffff;
	rdb->rdb_DriveInit 	   = (struct LoadSegBlock *)	   0xffffffff;
	for (i = 0; i < 6; i++)
		rdb->rdb_Reserved1[i] = (ULONG) 		   0xffffffff;
d58 1
a58 1
	maxblock = d->Block;	/* start at the old rigid disk block, or 0 */
d60 158
a217 109
	/* Partitions next */
	for (lastp = NULL, p = d->rdb->rdb_PartitionList;
	     p;
	     lastp = newp, p = p->pb_Next)
	{
		maxblock++;
		if (lastp)
			lastp->pb_Next = (struct PartitionBlock *) maxblock;
		else
			rdb->rdb_PartitionList = (struct PartitionBlock *)
						 maxblock;

		newp = (struct PartitionBlock *) GetBlock(maxblock);
		*newp = *p; /* structure copy */
		CtoBStr(&(newp->pb_DriveName[0]));

		newp->pb_HostID = HOST_ID;
		newp->pb_Next   = (struct PartitionBlock *) 0xffffffff;
	}

	/* now file systems */
	for (lastfs = NULL, fs = d->rdb->rdb_FileSysHeaderList;
	     fs;
	     lastfs = newfs, fs = fs->fhb_Next)
	{
		maxblock++;
		if (lastfs)
			lastfs->fhb_Next =
					(struct FileSysHeaderBlock *) maxblock;
		else
			rdb->rdb_FileSysHeaderList = 
					(struct FileSysHeaderBlock *) maxblock;

		newfs = (struct FileSysHeaderBlock *) GetBlock(maxblock);
		*newfs = *fs; /* structure copy */

		newfs->fhb_HostID = HOST_ID;

		newfs->fhb_SegListBlocks = (struct LoadSegBlock *) 0xffffffff;
		newfs->fhb_Next = (struct FileSysHeaderBlock *) 0xffffffff;

		/* now loadsegblocks */
		for (lastls = NULL, ls = fs->fhb_SegListBlocks;
		     ls;
		     lastls = newls, ls = ls->lsb_Next)
		{
			maxblock++;
			if (lastls)
				lastls->lsb_Next = (struct LoadSegBlock *)
						   maxblock;
			else
				newfs->fhb_SegListBlocks =
					       (struct LoadSegBlock *) maxblock;

			newls = (struct LoadSegBlock *) GetBlock(maxblock);

			/* to, from, size in bytes */
			memcpy((char *) newls, (char *) ls,
			       ls->lsb_SummedLongs << 2);

			newls->lsb_HostID = HOST_ID;
			newls->lsb_Next   = (struct LoadSegBlock *) 0xffffffff;
		}
	}

	/* now bad blocks */
	low_badblock = d->rdb->rdb_RDBBlocksHi + 1;

	for (lastbb = NULL, bb = d->rdb->rdb_BadBlockList;
	     bb;
	     lastbb = newbb, bb = bb->bbb_Next)
	{
		maxblock++;
		if (lastbb)
			lastbb->bbb_Next = (struct BadBlockBlock *) maxblock;
		else
			rdb->rdb_BadBlockList = (struct BadBlockBlock *)
						maxblock;

		newbb = (struct BadBlockBlock *) GetBlock(maxblock);

		/* to, from, size in bytes */
		memcpy((char *) newbb,(char *) bb,bb->bbb_SummedLongs << 2);

		{
			short i;
			LONG  good;
			ULONG *map;

			if (d->rdb->rdb_Interleave > 1)
			{
				/* this usage of sectors is correct */
				map = BuildInterleaveMap(d->rdb->rdb_Interleave,
							 d->rdb->rdb_Sectors);
				if (!map)
					goto cleanup;
			}

			/* 2 longs per entry */
			for (i = 0; i < (newbb->bbb_SummedLongs - 6)/2; i++)
			{
			    /* first, maintain low_badblock */
			    good = newbb->bbb_BlockPairs[i].bbe_GoodBlock;

			    /* first, maintain low_badblock */
			    if (good > 0 && good < low_badblock)
			    {
				low_badblock = good;
			    }
d220 4
a223 11
			    /* second, translate sector numbers re: interleave*/
			    /* needed for switching interleaves.	      */
			    /* map already built			      */
			    /* all sectors internally are interleave 1        */
			    if (d->rdb->rdb_Interleave > 1)
			    {
				LONG sec;

				/* first get sector on cylinder */
				sec = newbb->bbb_BlockPairs[i].bbe_BadBlock %
				      d->rdb->rdb_CylBlocks;
d225 10
a234 3
				/* I _think_ this use of sector is ok */
				/* now make that sector on head */
				sec = sec % d->rdb->rdb_Sectors;
d236 3
a238 4
				/* '- sec' to give start of head */
				newbb->bbb_BlockPairs[i].bbe_BadBlock +=
					map[sec] - sec;
			    }
d240 1
a240 1
			}
d242 52
a293 3
			if (d->rdb->rdb_Interleave > 1)
				FreeMem((char *) map,d->rdb->rdb_Sectors * 4);
		}
d295 1
a295 38
		newbb->bbb_HostID = HOST_ID;
		newbb->bbb_Next   = (struct BadBlockBlock *) 0xffffffff;
	}

	/* drive init code */
	for (lastls = NULL, ls = d->rdb->rdb_DriveInit;
	     ls;
	     lastls = newls, ls = ls->lsb_Next)
	{
		maxblock++;
		if (lastls)
			lastls->lsb_Next = (struct LoadSegBlock *)
					   maxblock;
		else
			rdb->rdb_DriveInit = (struct LoadSegBlock *) maxblock;

		newls = (struct LoadSegBlock *) GetBlock(maxblock);

		/* to, from, size in bytes */
		memcpy((char *) newls, (char *) ls,
		       ls->lsb_SummedLongs << 2);

		newls->lsb_HostID = HOST_ID;
		newls->lsb_Next   = (struct LoadSegBlock *) 0xffffffff;
	}

	rdb->rdb_HighRDSKBlock = maxblock;

	if (maxblock >= low_badblock)
	{
		Notify(w,"Save failed, not enough space for configuration data",
		       0);
/* FIX! - add rdsk cylinder gadget */
		Notify(w,
	       "Try a low-level format, or removing file systems or partitions",
		       0);
		goto cleanup;
	}
d297 5
a301 39
	/* checksum all the blocks */
	for (i = d->Block; i <= maxblock; i++)
		CheckSumBlock((struct RigidDiskBlock *) GetBlock(i));

/*#ifdef DEBUG*/
{ BPTR fh;
fh = Open("ram:rdsk",MODE_NEWFILE);
Write(fh,array,blocks * rdb->rdb_BlockBytes);
Close(fh);
printf("sending to disk\n");
}
/*#endif*/

	/* now write out array starting at block d->Block */
	DoIO((struct IORequest *) ior);

/*#ifdef DEBUG*/
{ BPTR fh;
fh = Open("ram:rdsk_after_doio",MODE_NEWFILE);
Write(fh,array,blocks * rdb->rdb_BlockBytes);
Close(fh);
printf("sending to disk\n");
}
/*#endif*/

	if (ior->io_Error)
	{
		if (!informat)
		{
			Notify(w,"Error %d on write!",(LONG) (ior->io_Error));
			goto cleanup;
		} else {
			/* don't care if it failed for format */
			return TRUE;
		}
	}

	/* note that this drive had it's RDSK written out */
	d->Flags |= WRITTEN;
d303 6
a308 1
	result = TRUE;
a309 12
cleanup:
	if (opened)
		CloseDevice((struct IORequest *) ior);
	if (ior)
		DeleteStdIO(ior);
	if (port)
		DeletePort(port);
	if (array)
		FreeMem(array,blocks * d->rdb->rdb_BlockBytes + 20);
								/* ^ safety */
	return result;
}
d311 1
a311 2
int
CountBlocks (rdb)
d479 1
a479 2
				if (!GetRDB(ior,d))
					GetDriveType(ior,d);
d483 1
a483 3
				{
					d->SCSIBadBlocks = ReadDefects(ior);
				}
d486 1
a486 2
				if (!firstd)
					firstd = d;
d1330 6
d1337 1
a1337 1
/* if the driver handles one board, LASTTID|LASTLUN == LAST */
d1339 41
a1379 6
LONG
CalcFlags (d)
	register struct Drive *d;
{
	register struct Drive *d2;
	register LONG flags = 0;
a1380 20
	if (d->NextDrive == NULL)
	{
		flags = RDBFF_LAST | RDBFF_LASTLUN | RDBFF_LASTTID;

	} else if (strcmp(&(d->NextDrive->DeviceName[0]),&(d->DeviceName[0])) !=
		   SAME) {

		/* Last of this device driver - set all flags */
		flags = RDBFF_LAST | RDBFF_LASTLUN | RDBFF_LASTTID;

	} else if (d->NextDrive->Addr != d->Addr) {

		/* last at this address */
		flags = RDBFF_LASTLUN;
		if (d->NextDrive->Addr / 100 != d->Addr / 100)
		{
			/* next one is on another board */
			flags |= RDBFF_LASTTID;
		}
	} else {
a1381 14
		/* are all the rest on the same address and driver? */
		flags |= RDBFF_LASTTID;				/* assume yes */
		for (d2 = d->NextDrive; d2; d2 = d2->NextDrive)
			if (d2->Addr != d->Addr ||
			    strcmp(&(d2->DeviceName[0]),
				   &(d->DeviceName[0])) != SAME)
			{
				/* no, there's one at a diff addr or driver */
				flags &= ~RDBFF_LASTTID;
				break;
			}
	}
	return flags;
}
@


36.2
log
@Updated to compile under lc 5.10a
@
text
@a1030 1
			printf("SegAlloc %ld\n", size);
@


36.1
log
@initial check in
@
text
@d18 4
a21 4
#include <proto/exec.h>
#include <proto/dos.h>
#include <proto/graphics.h>
#include <proto/intuition.h>
d23 5
d30 1
a115 4
/*
printf("Calculated flags of 0x%lx\n",flags);
printf("Old flags were      0x%lx\n",d->rdb->rdb_Flags);
*/
d459 8
d573 1
a573 4
/*
printf("Calculated flags of 0x%lx\n",flags);
printf("Old flags were      0x%lx\n",d->rdb->rdb_Flags);
*/
d600 7
d653 6
d734 2
d746 1
a746 1
	d->oldrdb = CopyRDB(newrdb);	/* save until rewritten to disk */
d775 4
d1031 1
d1360 1
a1360 1
		return cmdblk.scsi_Status;
d1362 1
a1362 1
	return ior->io_Error;	/* see scsidisk.h for errors */
@
