head     38.7;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


38.7
date     93.08.13.12.05.56;  author davidj;  state Exp;
branches ;
next     38.6;

38.6
date     92.07.29.08.42.34;  author davidj;  state Exp;
branches ;
next     38.5;

38.5
date     92.06.24.17.32.47;  author davidj;  state Exp;
branches ;
next     38.4;

38.4
date     92.06.23.21.39.54;  author davidj;  state Exp;
branches ;
next     38.3;

38.3
date     92.06.19.15.23.17;  author davidj;  state Exp;
branches ;
next     38.2;

38.2
date     92.06.01.12.03.23;  author vertex;  state Exp;
branches ;
next     38.1;

38.1
date     91.10.02.16.32.08;  author vertex;  state Exp;
branches ;
next     ;


desc
@Menu handling for IconEdit
@


38.7
log
@*** empty log message ***
@
text
@
/* includes */
#include <exec/memory.h>
#include <dos/dostags.h>
#include <graphics/scale.h>
#include <libraries/gadtools.h>
#include <intuition/intuition.h>
#include <intuition/gadgetclass.h>
#include <string.h>
#include <stdio.h>

/* prototypes */
#include <clib/macros.h>
#include <clib/gadtools_protos.h>
#include <clib/intuition_protos.h>
#include <clib/graphics_protos.h>
#include <clib/dos_protos.h>
#include <clib/icon_protos.h>
#include <clib/asl_protos.h>
#include <clib/exec_protos.h>

/* direct ROM interface */
#include <pragmas/gadtools_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/icon_pragmas.h>
#include <pragmas/asl_pragmas.h>
#include <pragmas/exec_pragmas.h>

/* application includes */
#include "iemenus.h"
#include "iemain.h"
#include "ieio.h"
#include "iemisc.h"
#include "ieiff.h"
#include "ieclip.h"
#include "texttable.h"
#include "iegads.h"
#include "ieutils.h"

/*****************************************************************************/

extern struct Library *DOSBase;
extern struct Library *IntuitionBase;
extern struct Library *IconBase;
extern struct Library *AslBase;
extern struct Library *GfxBase;
extern struct Library *GadToolsBase;
extern struct Library *SysBase;
extern struct Library *DataTypesBase;

/*****************************************************************************/

BOOL SaveAsCFunc (WindowInfoPtr wi);
BOOL TemplateFunc (WindowInfoPtr wi);
BOOL EraseFunc (WindowInfoPtr wi);
BOOL RecolorFunc (WindowInfoPtr wi);
BOOL TopLeftFunc (WindowInfoPtr wi);
BOOL PaletteFunc (WindowInfoPtr wi);

BOOL LoadIFFImage (WindowInfoPtr wi, STRPTR name, USHORT cur, BOOL errs);
BOOL SaveIFFBrush (WindowInfoPtr wi, STRPTR name, DynamicImagePtr di);

/*****************************************************************************/

/** !!!! DANGER !!!!
 ** If you change this strip, also change the stupid,
 ** yet inconvenient, absolute item # references in the init code
 ** below
 ** !!!! DANGER !!!!
 **/

struct NewMenu NM[] =
{
    {NM_TITLE, (STRPTR) MSG_IE_PROJECT_MENU,},
    {NM_ITEM, (STRPTR) MSG_IE_PROJECT_NEW, 0, 0, 0, NewFunc,},
    {NM_ITEM, (STRPTR) NM_BARLABEL,},
    {NM_ITEM, (STRPTR) MSG_IE_PROJECT_OPEN, 0, 0, 0, OpenFunc,},
    {NM_ITEM, (STRPTR) NM_BARLABEL,},
    {NM_ITEM, (STRPTR) MSG_IE_PROJECT_SAVE, 0, 0, 0, SaveFunc,},
    {NM_ITEM, (STRPTR) MSG_IE_PROJECT_SAVEAS, 0, 0, 0, SaveAsFunc,},
    {NM_ITEM, (STRPTR) MSG_IE_PROJECT_SAVEASDEF, 0, 0, 0, SaveDefFunc,},
    {NM_ITEM, (STRPTR) MSG_IE_PROJECT_SAVEASC, 0, 0, 0, SaveAsCFunc,},
    {NM_ITEM, (STRPTR) NM_BARLABEL,},
    {NM_ITEM, (STRPTR) MSG_IE_PROJECT_QUIT, 0, 0, 0, QuitFunc,},

    {NM_TITLE, (STRPTR) MSG_IE_EDIT_MENU,},
    {NM_ITEM, (STRPTR) MSG_IE_EDIT_CUT, 0, 0, 0, CutClipFunc,},
    {NM_ITEM, (STRPTR) MSG_IE_EDIT_COPY, 0, 0, 0, CopyClipFunc,},
    {NM_ITEM, (STRPTR) MSG_IE_EDIT_PASTE, 0, 0, 0, PasteClipFunc,},
    {NM_ITEM, (STRPTR) MSG_IE_EDIT_ERASE, 0, 0, 0, EraseFunc,},
    {NM_ITEM, (STRPTR) NM_BARLABEL,},
    {NM_ITEM, (STRPTR) MSG_IE_EDIT_OPENCLIP, 0, 0, 0, OpenClipFunc,},
    {NM_ITEM, (STRPTR) MSG_IE_EDIT_SAVECLIP, 0, 0, 0, SaveClipFunc,},
    {NM_ITEM, (STRPTR) MSG_IE_EDIT_SHOWCLIP, 0, 0, 0, ShowClipFunc,},

    {NM_TITLE, (STRPTR) MSG_IE_TYPE_MENU,},
    {NM_ITEM, (STRPTR) MSG_IE_TYPE_DISK, 0, CHECKIT, ~1, V (0),},
    {NM_ITEM, (STRPTR) MSG_IE_TYPE_DRAWER, 0, CHECKIT, ~2, V (1),},
    {NM_ITEM, (STRPTR) MSG_IE_TYPE_TOOL, 0, CHECKIT | CHECKED, ~4, V (2),},
    {NM_ITEM, (STRPTR) MSG_IE_TYPE_PROJECT, 0, CHECKIT, ~8, V (3),},
    {NM_ITEM, (STRPTR) MSG_IE_TYPE_GARBAGE, 0, CHECKIT, ~16, V (4),},

    {NM_TITLE, (STRPTR) MSG_IE_HIGHLIGHT_MENU,},
    {NM_ITEM, (STRPTR) MSG_IE_HIGHLIGHT_COMPLEMENT, 0, CHECKIT | CHECKED, ~1, V (0),},
    {NM_ITEM, (STRPTR) MSG_IE_HIGHLIGHT_BACKFILL, 0, CHECKIT, ~2, V (1),},
    {NM_ITEM, (STRPTR) MSG_IE_HIGHLIGHT_IMAGE, 0, CHECKIT, ~4, V (2),},

    {NM_TITLE, (STRPTR) MSG_IE_IMAGES_MENU,},
    {NM_ITEM, (STRPTR) MSG_IE_IMAGES_EXCHANGE, 0, 0, 0, ExchangeFunc,},
    {NM_ITEM, (STRPTR) MSG_IE_IMAGES_COPY, 0, 0, 0, CopyFunc,},
    {NM_ITEM, (STRPTR) MSG_IE_IMAGES_TEMPLATE, 0, 0, 0, TemplateFunc,},
    {NM_ITEM, (STRPTR) NM_BARLABEL,},
    {NM_ITEM, (STRPTR) MSG_IE_IMAGES_LOAD, 0, 0, 0, 0,},
    {NM_SUB, (STRPTR) MSG_IE_IMAGES_IFFBRUSH, 0, 0, 0, LIFFFunc,},
    {NM_SUB, (STRPTR) MSG_IE_IMAGES_NORMAL, 0, 0, 0, LStdFunc,},
    {NM_SUB, (STRPTR) MSG_IE_IMAGES_SELECTED, 0, 0, 0, LAltFunc,},
    {NM_SUB, (STRPTR) MSG_IE_IMAGES_BOTH, 0, 0, 0, LBthFunc,},
    {NM_ITEM, (STRPTR) MSG_IE_IMAGES_SAVEIFF, 0, 0, 0, SIFFFunc,},
    {NM_ITEM, (STRPTR) NM_BARLABEL,},
    {NM_ITEM, (STRPTR) MSG_IE_IMAGES_RESTORE, 0, 0, 0, RestoreFunc,},

    {NM_TITLE, (STRPTR) MSG_IE_EXTRAS_MENU,},
    {NM_ITEM, (STRPTR) MSG_IE_EXTRAS_RECOLOR, 0, 0, 0, RecolorFunc,},	/* 43 */
    {NM_ITEM, (STRPTR) MSG_IE_EXTRAS_AUTO, 0, 0, 0, TopLeftFunc,},
    {NM_ITEM, (STRPTR) MSG_IE_EXTRAS_PALETTE, 0, 0, 0, PaletteFunc,},

    {NM_TITLE, (STRPTR) MSG_IE_SETTINGS_MENU,},
    {NM_ITEM, (STRPTR) MSG_IE_SETTINGS_GRID, 0, CHECKIT | MENUTOGGLE, 0, V (0),},
    {NM_ITEM, (STRPTR) MSG_IE_SETTINGS_ICONS, 0, CHECKIT | MENUTOGGLE, 0, V (1),},
    {NM_ITEM, (STRPTR) NM_BARLABEL,},
    {NM_ITEM, (STRPTR) MSG_IE_SETTINGS_SAVE, 0, 0, 0, V (2),},

    {NM_END, 0, 0, 0, 0, 0},
};

/** !!!! DANGER !!!!
 ** If you change this strip, also change the stupid,
 ** yet inconvenient, absolute item # references in the init code
 ** below
 ** !!!! DANGER !!!!
 **/

/*****************************************************************************/

struct Image blank = {0, 0, 0, 0, 0, NULL, 0, 1, NULL};

/*****************************************************************************/

void CreateWinTitle (WindowInfoPtr wi, UBYTE *name)
{
    sprintf (wi->wintitle, GetString (MSG_IE_TITLE), FilePart (name));
}

/*****************************************************************************/

VOID CheckClippable (WindowInfoPtr wi, struct DiskObject * dob)
{
    struct Image *im;

    im = dob->do_Gadget.GadgetRender;
    if ((im) && (im->Width > ICON_WIDTH) && (im->Height > ICON_HEIGHT))
    {
	wi->clippable = TRUE;
    }

    im = dob->do_Gadget.SelectRender;
    if ((im) && (im->Width > ICON_WIDTH) && (im->Height > ICON_HEIGHT))
    {
	wi->clippable = TRUE;
    }
}

/*****************************************************************************/

BOOL LayoutIEMenus (WindowInfoPtr wi, struct Menu * menus, ULONG tag1,...)
{
    return (LayoutMenusA (menus, wi->vi, (struct TagItem *) & tag1));
}

/*****************************************************************************/

struct Menu *CreateIEMenus (WindowInfoPtr wi, struct NewMenu * nm)
{
    struct Menu *menus;
    UWORD i;

    i = 0;
    while (nm[i].nm_Type != NM_END)
    {
	if (nm[i].nm_Type == NM_TITLE)
	{
	    nm[i].nm_Label = GetString ((LONG) nm[i].nm_Label);
	}
	else if ((nm[i].nm_Type != IM_ITEM) && (nm[i].nm_Label != NM_BARLABEL))
	{
	    nm[i].nm_CommKey = GetString ((LONG) nm[i].nm_Label);
	    nm[i].nm_Label = &nm[i].nm_CommKey[2];
	    if (nm[i].nm_CommKey[0] == ' ')
		nm[i].nm_CommKey = NULL;
	}
	i++;
    }

    if (menus = CreateMenusA (nm, NULL))
    {
	if (!(LayoutIEMenus (wi, menus, GTMN_NewLookMenus, TRUE,
			     TAG_DONE)))
	{
	    FreeMenus (menus);
	    menus = NULL;
	}
    }

    return (menus);
}

/*****************************************************************************/

BOOL CreateIconMenus (WindowInfoPtr wi)
{
    /*** DANGER! Absolute access to menu strip items! */
    if (!wi->w_SaveSrc)
    {
	NM[8].nm_Type = IM_ITEM;
	NM[8].nm_Label = (STRPTR) & blank;
	NM[8].nm_CommKey = NULL;
	NM[8].nm_Flags = NM_ITEMDISABLED;
	NM[8].nm_MutualExclude = NULL;
    }

    /*** DANGER! Absolute access to menu strip items! */
    NM[48].nm_Flags |= ((wi->w_UseGrid) ? CHECKED : NULL);
    NM[49].nm_Flags |= ((wi->w_SaveIcons) ? CHECKED : NULL);

    if (wi->menu = CreateIEMenus (wi, NM))
    {
	SetMenuStrip (wi->win, wi->menu);
	return (TRUE);
    }

    return (FALSE);
}


/*****************************************************************************/


VOID CheckMenuItem (WindowInfoPtr wi, USHORT menunum, UWORD item)
{
    struct Menu *m;
    struct MenuItem *mi;
    UWORD mid;
    USHORT i;

    i = 0;
    m = wi->menu;
    while (i < menunum && m)
    {
	m = m->NextMenu;
	i++;
    }
    if (m)
    {
	mi = m->FirstItem;
	while (mi)
	{
	    mi->Flags &= ~CHECKED;
	    mid = (UWORD) MENU_USERDATA (mi);
	    if (mid == item)
		mi->Flags |= CHECKED;
	    mi = mi->NextItem;
	}
    }
}


/*****************************************************************************/


VOID SetHilite (WindowInfoPtr wi, struct DiskObject * dob, UWORD mhilite)
{
    struct Window *wp;
    USHORT pos;

    wp = wi->win;
    pos = RemoveGList (wp, wi->img1, 1L);
    wi->img1->Flags = dob->do_Gadget.Flags = GADGIMAGE | (USHORT) wi->hilite;
    AddGList (wp, wi->img1, (LONG) pos, 1L, NULL);
    RefreshGList (wi->img1, wp, NULL, 1L);
    if (wi->currentwin == 1)
    {
	wi->currentwin = 0;
	GT_SetGadgetAttrs (wi->mxgad, wp, NULL,
			   GTMX_Active, wi->currentwin,
			   TAG_DONE);
	wi->Adi = &wi->images[wi->currentwin];
	SPSetRepeat (wi->wi_sketch, wi->Adi,
		     (wi->w_LO + 77) + 16, wi->wintopx[wi->currentwin]);
	SPRefresh (wi->wi_sketch);
    }

    wi->changed |= CH_MINOR;
}


/*****************************************************************************/


VOID SetType (WindowInfoPtr wi, struct DiskObject * dob, UWORD mtype)
{

    wi->type = mtype;
    wi->diskobj->do_Type = (UBYTE) mtype;
    wi->changed |= CH_MINOR;
}


/*****************************************************************************/


BOOL HandleMenuEvent (WindowInfoPtr wi, UWORD code)
{
    struct MenuItem *item;
    BOOL terminated = FALSE;
    LONG menunum, itemnum;

    while ((code != MENUNULL) && (!terminated))
    {
	item = ItemAddress (wi->menu, code);
	menunum = (int) MENUNUM (code);
	itemnum = (int) ITEMNUM (code);

	if ((menunum == 0) || (menunum == 1) || (menunum == 4) || (menunum == 5))
	{
	    BOOL (*fptr) (WindowInfoPtr) = MENU_USERDATA (item);
	    terminated = (*fptr) (wi);
	}
	else if (menunum == 2)
	{
	    wi->type = (UWORD) MENU_USERDATA (item);
	    SetType (wi, wi->diskobj, wi->type);
	}
	else if (menunum == 3)
	{
	    wi->hilite = (UWORD) MENU_USERDATA (item);
	    SetHilite (wi, wi->diskobj, wi->hilite);
	}
	else if (menunum == 6)
	{
	    switch (itemnum)
	    {
		    /* Toggle Grid */
		case 0:
		    if (item->Flags & CHECKED)
		    {
			wi->wi_sketch->Grid = TRUE;
		    }
		    else
		    {
			wi->wi_sketch->Grid = FALSE;
		    }

		    /* Remember this for settings */
		    wi->w_UseGrid = wi->wi_sketch->Grid;
		    break;

		    /* Toggle Icon */
		case 1:
		    if (item->Flags & CHECKED)
		    {
			wi->w_SaveIcons = TRUE;
		    }
		    else
		    {
			wi->w_SaveIcons = FALSE;
		    }
		    break;

		    /* Save Settings */
		case 3:
		    SetIconEditPrefs (wi);
		    break;
	    }

	    SPRefresh (wi->wi_sketch);
	}

	code = item->NextSelect;
    }

    return (terminated);
}


/*****************************************************************************/


BOOL NewFunc (WindowInfoPtr wi)
{
    struct Window *wp;
    SHORT i;
    BOOL cancel;

    wp = wi->win;
    cancel = CheckForChanges (wi, MSG_IE_NEWANDZAP, MSG_IE_NEWANDZAP_GADS);
    if (!cancel)
    {
	SPSaveToUndo (wi->wi_sketch);

	for (i = 0; i < 255; i++)
	    wi->iconname[i] = 0;
	if (wi->diskobj)
	    FreeDiskObject (wi->diskobj);
	wi->diskobj = NULL;
	if (wi->type < 0)
	    wi->type = 0;
	if (wi->diskobj = GetDefDiskObject ((UBYTE) (wi->type + 1)))
	{
	    UpdateIconInfo (wi, wi->diskobj);
	    wi->currentwin = 0;
	    wi->Adi = &wi->images[0];
	    SPSetRepeat (wi->wi_sketch, wi->Adi,
			 (wi->w_LO + 77) + 16, wi->wintopx[wi->currentwin]);
	    SPRefresh (wi->wi_sketch);
	    strcpy (wi->wintitle, GetString (MSG_IE_DEFAULT_TITLE));
	    SetWindowTitles (wp, wi->wintitle, (STRPTR) - 1);
	}

	/* Clear the changes flag */
	wi->changed = CH_NONE;
	wi->clippable = FALSE;
    }
    return (FALSE);
}

/*****************************************************************************/

VOID OpenNamedIcon (WindowInfoPtr wi, UBYTE * name, BOOL real)
{
    struct Window *wp;
    struct DiskObject *dob;

    wp = wi->win;
    if (dob = LoadIcon (name, real))
    {
	UpdateIconInfo (wi, dob);
	wi->currentwin = 0;
	wi->Adi = &wi->images[0];
	SPSetRepeat (wi->wi_sketch, wi->Adi,
		     (wi->w_LO + 77) + 16, wi->wintopx[wi->currentwin]);
	SPRefresh (wi->wi_sketch);

	if (wi->diskobj)
	{
	    FreeDiskObject (wi->diskobj);
	}

	wi->diskobj = dob;

	strcpy (wi->iconname, name);
	CreateWinTitle (wi, name);
	SetWindowTitles (wp, wi->wintitle, (UBYTE *) - 1);

	/* Clear the changes flag */
	wi->changed = CH_NONE;
	wi->clippable = FALSE;
	CheckClippable (wi, dob);
    }
    else
    {
	sprintf (wi->w_Buffer, GetString (MSG_IE_ERROR_COULDNT_LOAD), name);
	NotifyUser (0, wi->w_Buffer);
    }

    /* Set up the file requester to match */
    FixFileAndPath (wi->w_FR[FR_ICON], wi->iconname);
}


/*****************************************************************************/


BOOL OpenFunc (WindowInfoPtr wi)
{
    struct Window *wp;
    UBYTE path[255], name[50];
    BOOL cancel;

    wp = wi->win;
    cancel = CheckForChanges (wi, MSG_IE_OPENANDZAP, MSG_IE_OPENANDZAP_GADS);
    if (!cancel)
    {
	struct TagItem tg[10];

	/* Initialize the file requester position */
	if (wi->Width == (-1))
	{
	    wi->LeftEdge = wp->LeftEdge + 12;
	    wi->TopEdge  = wp->TopEdge + 12;
	    wi->Width    = 320;
	    wi->Height   = 175;
	}

	/* Set the file requester position */
	tg[4].ti_Tag = ASL_LeftEdge;
	tg[4].ti_Data = (ULONG) wp->LeftEdge + wi->LeftEdge;
	tg[5].ti_Tag = ASL_TopEdge;
	tg[5].ti_Data = (ULONG) wp->TopEdge + wi->TopEdge;
	tg[6].ti_Tag = ASL_Width;
	tg[6].ti_Data = (ULONG) wi->Width;
	tg[7].ti_Tag = ASL_Height;
	tg[7].ti_Data = (ULONG) wi->Height;

	tg[0].ti_Tag = ASL_Hail;
	tg[0].ti_Data = (ULONG) GetString (MSG_IE_OPENICON_TITLE);
	tg[1].ti_Tag = ASL_FuncFlags;
	tg[1].ti_Data = NULL;
	tg[2].ti_Tag = ASL_OKText;
	tg[2].ti_Data = (ULONG) GetString (MSG_IE_OPEN_GAD);
	tg[3].ti_Tag = ASL_Window;
	tg[3].ti_Data = (ULONG) wp;
	tg[8].ti_Tag = ASL_Pattern;
	tg[8].ti_Data = (ULONG) "#?.info";
	tg[9].ti_Tag = TAG_DONE;

	/* Do we have a file requester? */
	if (wi->w_FR[FR_ICON])
	{
	    if (AslRequest (wi->w_FR[FR_ICON], tg))
	    {
		/* Make sure everything is set up properly */
		FixFileAndPath (wi->w_FR[FR_ICON], NULL);

		/* Build the complete name */
		strcpy (name, wi->w_FR[FR_ICON]->rf_File);
		strcpy (path, wi->w_FR[FR_ICON]->rf_Dir);
		strcpy (wi->w_Tmp, path);
		AddPart (wi->w_Tmp, name, 254);

		SPSaveToUndo (wi->wi_sketch);

		/* Open the icon */
		OpenNamedIcon (wi, wi->w_Tmp, TRUE);

		/* Clear changes flag */
		wi->changed = CH_NONE;
	    }

	    /* Remember where they moved it */
	    wi->LeftEdge = wi->w_FR[FR_ICON]->rf_LeftEdge - wp->LeftEdge;
	    wi->TopEdge = wi->w_FR[FR_ICON]->rf_TopEdge - wp->TopEdge;
	    wi->Width = wi->w_FR[FR_ICON]->rf_Width;
	    wi->Height = wi->w_FR[FR_ICON]->rf_Height;
	}
    }

    return (FALSE);
}


/*****************************************************************************/


BOOL SaveFunc (WindowInfoPtr wi)
{
    if (strlen (wi->iconname) == 0)
    {
	/* Not named yet, so let's get a name */
	SaveAsFunc (wi);
    }
    else
    {
	if (SaveIcon (wi, wi->iconname, wi->diskobj, 0))
	{
	    /* Clear the changes flags */
	    wi->changed = CH_NONE;

	    /* Open the icon */
	    OpenNamedIcon (wi, wi->iconname, TRUE);
	}
	else
	    wi->changed |= CH_CANCEL;
    }

    return (FALSE);
}


/*****************************************************************************/

BOOL SaveAsFunc (WindowInfoPtr wi)
{
    struct Window *wp;
    UBYTE path[255], name[50];

    wp = wi->win;
    if (wi->w_FR[FR_ICON])
    {
	struct TagItem tg[10];

	/* Initialize the file requester position */
	if (wi->Width == (-1))
	{
	    wi->LeftEdge = wp->LeftEdge + 12;
	    wi->TopEdge  = wp->TopEdge + 12;
	    wi->Width    = 320;
	    wi->Height   = 175;
	}

	/* Set the file requester position */
	tg[4].ti_Tag = ASL_LeftEdge;
	tg[4].ti_Data = (ULONG) wp->LeftEdge + wi->LeftEdge;
	tg[5].ti_Tag = ASL_TopEdge;
	tg[5].ti_Data = (ULONG) wp->TopEdge + wi->TopEdge;
	tg[6].ti_Tag = ASL_Width;
	tg[6].ti_Data = (ULONG) wi->Width;
	tg[7].ti_Tag = ASL_Height;
	tg[7].ti_Data = (ULONG) wi->Height;

	tg[0].ti_Tag = ASL_Hail;
	tg[0].ti_Data = (ULONG) GetString (MSG_IE_SAVEICON_TITLE);
	tg[1].ti_Tag = ASL_FuncFlags;
	tg[1].ti_Data = FILF_SAVE;
	tg[2].ti_Tag = ASL_OKText;
	tg[2].ti_Data = (ULONG) GetString (MSG_IE_SAVE_GAD);
	tg[3].ti_Tag = ASL_Window;
	tg[3].ti_Data = (ULONG) wp;
	tg[8].ti_Tag = ASL_Pattern;
	tg[8].ti_Data = (ULONG) "#?";
	tg[9].ti_Tag = TAG_DONE;

	/* Request the icon name */
	if (AslRequest (wi->w_FR[FR_ICON], tg))
	{
	    WORD count;

	    /* Fix the entries */
	    FixFileAndPath (wi->w_FR[FR_ICON], NULL);

	    strcpy (name, wi->w_FR[FR_ICON]->rf_File);
	    strcpy (path, wi->w_FR[FR_ICON]->rf_Dir);
	    strcpy (wi->w_Tmp, path);
	    AddPart (wi->w_Tmp, name, 254);

	    if ((count = stcgfn (wi->w_FR[FR_ICON]->rf_File, wi->w_Tmp)) > 0)
	    {
		strcpy (wi->iconname, wi->w_Tmp);
		if (SaveIcon (wi, wi->iconname, wi->diskobj, 0))
		{
		    /* Open the icon */
		    OpenNamedIcon (wi, wi->iconname, TRUE);

		    /* Clear the changes flags */
		    wi->changed = CH_NONE;
		}
	    }
	    else
	    {
		NotifyUser (MSG_IE_ERROR_NO_FILENAME, NULL);
	    }

	    FixFileAndPath (wi->w_FR[FR_ICON], wi->iconname);
	}
	else
	    wi->changed |= CH_CANCEL;

	/* Remember where they moved it */
	wi->LeftEdge = wi->w_FR[FR_ICON]->rf_LeftEdge - wp->LeftEdge;
	wi->TopEdge = wi->w_FR[FR_ICON]->rf_TopEdge - wp->TopEdge;
	wi->Width = wi->w_FR[FR_ICON]->rf_Width;
	wi->Height = wi->w_FR[FR_ICON]->rf_Height;
    }
    return (FALSE);
}


/*****************************************************************************/


BOOL SaveDefFunc (WindowInfoPtr wi)
{

    SaveIcon (wi, wi->iconname, wi->diskobj, 1);
    return (FALSE);
}


/*****************************************************************************/


BOOL QuitFunc (WindowInfoPtr wi)
{

    return (TRUE);
}


/*****************************************************************************/


BOOL ExchangeFunc (WindowInfoPtr wi)
{
    struct DynamicImage di;

    di.di_Flags = NULL;
    InitDynamicImage (&di, MAXDEPTH, ICON_WIDTH, ICON_HEIGHT);
    if (AllocDynamicImage (&di))
    {
	DrawImage (&di.di_RPort, &wi->images[0].di_Image, 0, 0);
	DrawImage (&wi->images[0].di_RPort, &wi->images[1].di_Image, 0, 0);
	DrawImage (&wi->images[1].di_RPort, &di.di_Image, 0, 0);
	FreeDynamicImage (&di);
	RefreshImages (wi);
	SPRefresh (wi->wi_sketch);

	wi->hilite = 2;
	SetHilite (wi, wi->diskobj, wi->hilite);
	CheckMenuItem (wi, 3, 2);

	wi->changed |= CH_MAJOR;
    }

    return (FALSE);
}


/*****************************************************************************/


BOOL CopyFunc (WindowInfoPtr wi)
{
    SHORT inactivewin;

    inactivewin = (wi->currentwin == 0) ? 1 : 0;
    DrawImage (&wi->images[inactivewin].di_RPort, &wi->images[wi->currentwin].di_Image, 0, 0);
    RefreshImages (wi);

    wi->hilite = 2;
    SetHilite (wi, wi->diskobj, wi->hilite);
    CheckMenuItem (wi, 3, 2);

    /* Indicate image editing change */
    wi->changed |= CH_MAJOR;

    return (FALSE);
}


/*****************************************************************************/


VOID LoadIAI (WindowInfoPtr wi, USHORT lmode, struct DiskObject * dob, USHORT cur)
{
    DynamicImagePtr di = &wi->images[cur];
    struct Image *im;

    if (lmode == 0)
	im = (struct Image *) dob->do_Gadget.GadgetRender;
    else
	im = (struct Image *) dob->do_Gadget.SelectRender;

    if (im)
    {
	SetRast (&di->di_RPort, 0);
	DrawImage (&di->di_RPort, im, 0, 0);
	RefreshImages (wi);

	SPRefresh (wi->wi_sketch);

	if (cur == 1)
	{
	    wi->hilite = 2;
	    SetHilite (wi, wi->diskobj, wi->hilite);
	    CheckMenuItem (wi, 3, 2);
	}

	wi->changed |= CH_MAJOR;
    }
    else
    {
	NotifyUser (MSG_IE_ERROR_NO_IMAGE, NULL);
    }
}


/*****************************************************************************/


VOID LoadIconAsImage (WindowInfoPtr wi, USHORT lmode)
{
    struct Window *wp;
    struct DiskObject *dob;
    UBYTE path[255], name[50];
    struct TagItem tg[10];

    wp = wi->win;
    if (wi->w_FR[FR_ALT])
    {
	/* Initialize the file requester position */
	if (wi->Width == (-1))
	{
	    wi->LeftEdge = wp->LeftEdge + 12;
	    wi->TopEdge  = wp->TopEdge + 12;
	    wi->Width    = 320;
	    wi->Height   = 175;
	}

	/* Set the file requester position */
	tg[4].ti_Tag = ASL_LeftEdge;
	tg[4].ti_Data = (ULONG) wp->LeftEdge + wi->LeftEdge;
	tg[5].ti_Tag = ASL_TopEdge;
	tg[5].ti_Data = (ULONG) wp->TopEdge + wi->TopEdge;
	tg[6].ti_Tag = ASL_Width;
	tg[6].ti_Data = (ULONG) wi->Width;
	tg[7].ti_Tag = ASL_Height;
	tg[7].ti_Data = (ULONG) wi->Height;

	tg[0].ti_Tag = ASL_Hail;
	tg[0].ti_Data = (ULONG) GetString (MSG_IE_LOADICON_TITLE);
	tg[2].ti_Tag = ASL_OKText;
	tg[2].ti_Data = (ULONG) GetString (MSG_IE_LOAD_GAD);
	tg[3].ti_Tag = ASL_Window;
	tg[3].ti_Data = (ULONG) wp;
	tg[1].ti_Tag = ASL_FuncFlags;
	tg[1].ti_Data = NULL;
	tg[8].ti_Tag = ASL_Pattern;
	tg[8].ti_Data = (ULONG) "#?.info";
	tg[9].ti_Tag = TAG_DONE;

	if (AslRequest (wi->w_FR[FR_ALT], tg))
	{
	    FixFileAndPath (wi->w_FR[FR_ALT], NULL);
	    strcpy (name, wi->w_FR[FR_ALT]->rf_File);
	    strcpy (path, wi->w_FR[FR_ALT]->rf_Dir);
	    strcpy (wi->w_Tmp, path);
	    AddPart (wi->w_Tmp, name, 254);
	    FixFileAndPath (wi->w_FR[FR_ALT], wi->w_Tmp);

	    if (dob = LoadIcon (wi->w_Tmp, TRUE))
	    {
		LoadIAI (wi, lmode, dob, wi->currentwin);
	    }
	    else
	    {
		NotifyUser (MSG_IE_ERROR_NOT_AN_ICON, NULL);
	    }

	    if (dob)
	    {
		FreeDiskObject (dob);
	    }

	    wi->changed |= CH_MAJOR;
	}

	/* Remember where they moved it */
	wi->LeftEdge = wi->w_FR[FR_ALT]->rf_LeftEdge - wp->LeftEdge;
	wi->TopEdge = wi->w_FR[FR_ALT]->rf_TopEdge - wp->TopEdge;
	wi->Width = wi->w_FR[FR_ALT]->rf_Width;
	wi->Height = wi->w_FR[FR_ALT]->rf_Height;
    }
}


/*****************************************************************************/


BOOL LStdFunc (WindowInfoPtr wi)
{

    LoadIconAsImage (wi, 0);
    return (FALSE);
}


/*****************************************************************************/


BOOL LAltFunc (WindowInfoPtr wi)
{

    LoadIconAsImage (wi, 1);
    return (FALSE);
}


/*****************************************************************************/


BOOL LBthFunc (WindowInfoPtr wi)
{
    struct Window *wp;
    SHORT curwin = wi->currentwin;
    SHORT i;
    struct DiskObject *dob;
    UBYTE path[255], name[50];
    struct TagItem tg[10];

    wp = wi->win;
    if (wi->w_FR[FR_ALT])
    {
	/* Initialize the file requester position */
	if (wi->Width == (-1))
	{
	    wi->LeftEdge = wp->LeftEdge + 12;
	    wi->TopEdge  = wp->TopEdge + 12;
	    wi->Width    = 320;
	    wi->Height   = 175;
	}

	/* Set the file requester position */
	tg[4].ti_Tag = ASL_LeftEdge;
	tg[4].ti_Data = (ULONG) wp->LeftEdge + wi->LeftEdge;
	tg[5].ti_Tag = ASL_TopEdge;
	tg[5].ti_Data = (ULONG) wp->TopEdge + wi->TopEdge;
	tg[6].ti_Tag = ASL_Width;
	tg[6].ti_Data = (ULONG) wi->Width;
	tg[7].ti_Tag = ASL_Height;
	tg[7].ti_Data = (ULONG) wi->Height;

	tg[0].ti_Tag = ASL_Hail;
	tg[0].ti_Data = (ULONG) GetString (MSG_IE_LOADICON_TITLE);
	tg[2].ti_Tag = ASL_OKText;
	tg[2].ti_Data = (ULONG) GetString (MSG_IE_LOAD_GAD);
	tg[3].ti_Tag = ASL_Window;
	tg[3].ti_Data = (ULONG) wp;
	tg[1].ti_Tag = ASL_FuncFlags;
	tg[1].ti_Data = NULL;
	tg[8].ti_Tag = ASL_Pattern;
	tg[8].ti_Data = (ULONG) "#?.info";
	tg[9].ti_Tag = TAG_DONE;

	if (AslRequest (wi->w_FR[FR_ALT], tg))
	{
	    FixFileAndPath (wi->w_FR[FR_ALT], NULL);
	    strcpy (name, wi->w_FR[FR_ALT]->rf_File);
	    strcpy (path, wi->w_FR[FR_ALT]->rf_Dir);
	    strcpy (wi->w_Tmp, path);
	    AddPart (wi->w_Tmp, name, 254);
	    FixFileAndPath (wi->w_FR[FR_ALT], wi->w_Tmp);

	    if (dob = LoadIcon (wi->w_Tmp, TRUE))
	    {
		for (i = 0; i < 2; i++)
		{
		    wi->currentwin = i;
		    wi->Adi = &wi->images[i];
		    SPSetRepeat (wi->wi_sketch, wi->Adi, (wi->w_LO + 77) + 16, wi->wintopx[i]);
		    LoadIAI (wi, i, dob, wi->currentwin);

		    wi->clippable = FALSE;
		    CheckClippable (wi, dob);
		}
	    }
	    else
	    {
		NotifyUser (MSG_IE_ERROR_NOT_AN_ICON, NULL);
	    }

	    if (dob)
		FreeDiskObject (dob);

	    wi->changed |= CH_MAJOR;
	}

	/* Remember where they moved it */
	wi->LeftEdge = wi->w_FR[FR_ALT]->rf_LeftEdge - wp->LeftEdge;
	wi->TopEdge = wi->w_FR[FR_ALT]->rf_TopEdge - wp->TopEdge;
	wi->Width = wi->w_FR[FR_ALT]->rf_Width;
	wi->Height = wi->w_FR[FR_ALT]->rf_Height;
	wi->currentwin = curwin;
	wi->Adi = &wi->images[wi->currentwin];
	SPSetRepeat (wi->wi_sketch, wi->Adi, (wi->w_LO + 77) + 16, wi->wintopx[wi->currentwin]);
	SPRefresh (wi->wi_sketch);
    }
    return (FALSE);
}

/*****************************************************************************/

BOOL LIFFFunc (WindowInfoPtr wi)
{
    struct Window *wp;
    UBYTE path[255], name[50];
    struct TagItem tg[10];

    wp = wi->win;
    if (wi->w_FR[FR_ILBM])
    {
	/* Initialize the file requester position */
	if (wi->Width == (-1))
	{
	    wi->LeftEdge = wp->LeftEdge + 12;
	    wi->TopEdge  = wp->TopEdge + 12;
	    wi->Width    = 320;
	    wi->Height   = 175;
	}

	/* Set the file requester position */
	tg[4].ti_Tag = ASL_LeftEdge;
	tg[4].ti_Data = (ULONG) wp->LeftEdge + wi->LeftEdge;
	tg[5].ti_Tag = ASL_TopEdge;
	tg[5].ti_Data = (ULONG) wp->TopEdge + wi->TopEdge;
	tg[6].ti_Tag = ASL_Width;
	tg[6].ti_Data = (ULONG) wi->Width;
	tg[7].ti_Tag = ASL_Height;
	tg[7].ti_Data = (ULONG) wi->Height;

	tg[0].ti_Tag = ASL_Hail;
	tg[0].ti_Data = (ULONG) GetString (MSG_IE_LOADBRUSH_TITLE);
	tg[2].ti_Tag = ASL_OKText;
	tg[2].ti_Data = (ULONG) GetString (MSG_IE_LOAD_GAD);
	tg[3].ti_Tag = ASL_Window;
	tg[3].ti_Data = (ULONG) wp;
	tg[1].ti_Tag = ASL_FuncFlags;
	tg[1].ti_Data = NULL;
	tg[8].ti_Tag = ASL_Pattern;
	tg[8].ti_Data = (ULONG) "~(#?.info)";
	tg[9].ti_Tag = TAG_DONE;

	if (AslRequest (wi->w_FR[FR_ILBM], tg))
	{
	    FixFileAndPath (wi->w_FR[FR_ILBM], NULL);
	    strcpy (name, wi->w_FR[FR_ILBM]->rf_File);
	    strcpy (path, wi->w_FR[FR_ILBM]->rf_Dir);
	    strcpy (wi->w_Tmp, path);
	    AddPart (wi->w_Tmp, name, 254);
	    FixFileAndPath (wi->w_FR[FR_ILBM], wi->w_Tmp);

	    LoadIFFImage (wi, wi->w_Tmp, wi->currentwin, TRUE);

	    wi->changed |= CH_MAJOR;
	}

	/* Remember where they moved it */
	wi->LeftEdge = wi->w_FR[FR_ILBM]->rf_LeftEdge - wp->LeftEdge;
	wi->TopEdge = wi->w_FR[FR_ILBM]->rf_TopEdge - wp->TopEdge;
	wi->Width = wi->w_FR[FR_ILBM]->rf_Width;
	wi->Height = wi->w_FR[FR_ILBM]->rf_Height;
    }
    return (FALSE);
}


/*****************************************************************************/


BOOL SStdFunc (WindowInfoPtr wi)
{

    return (FALSE);
}


/*****************************************************************************/


BOOL SIFFFunc (WindowInfoPtr wi)
{
    struct Window *wp;
    DynamicImagePtr di = &wi->images[wi->currentwin];
    UBYTE path[255], name[50];
    struct TagItem tg[10];

    wp = wi->win;
    if (wi->w_FR[FR_ILBM])
    {
	/* Initialize the file requester position */
	if (wi->Width == (-1))
	{
	    wi->LeftEdge = wp->LeftEdge + 12;
	    wi->TopEdge  = wp->TopEdge + 12;
	    wi->Width    = 320;
	    wi->Height   = 175;
	}

	/* Set the file requester position */
	tg[4].ti_Tag = ASL_LeftEdge;
	tg[4].ti_Data = (ULONG) wp->LeftEdge + wi->LeftEdge;
	tg[5].ti_Tag = ASL_TopEdge;
	tg[5].ti_Data = (ULONG) wp->TopEdge + wi->TopEdge;
	tg[6].ti_Tag = ASL_Width;
	tg[6].ti_Data = (ULONG) wi->Width;
	tg[7].ti_Tag = ASL_Height;
	tg[7].ti_Data = (ULONG) wi->Height;

	tg[0].ti_Tag = ASL_Hail;
	tg[0].ti_Data = (ULONG) GetString (MSG_IE_SAVEBRUSH_TITLE);
	tg[1].ti_Tag = ASL_FuncFlags;
	tg[1].ti_Data = FILF_SAVE;
	tg[2].ti_Tag = ASL_OKText;
	tg[2].ti_Data = (ULONG) GetString (MSG_IE_SAVE_GAD);
	tg[3].ti_Tag = ASL_Window;
	tg[3].ti_Data = (ULONG) wp;
	tg[8].ti_Tag = ASL_Pattern;
	tg[8].ti_Data = (ULONG) "~(#?.info)";
	tg[9].ti_Tag = TAG_DONE;

	if (AslRequest (wi->w_FR[FR_ILBM], tg))
	{
	    FixFileAndPath (wi->w_FR[FR_ILBM], NULL);
	    strcpy (name, wi->w_FR[FR_ILBM]->rf_File);
	    strcpy (path, wi->w_FR[FR_ILBM]->rf_Dir);
	    strcpy (wi->w_Tmp, path);
	    AddPart (wi->w_Tmp, name, 254);
	    FixFileAndPath (wi->w_FR[FR_ILBM], wi->w_Tmp);

	    SaveIFFBrush (wi, wi->w_Tmp, di);
	}

	/* Remember where they moved it */
	wi->LeftEdge = wi->w_FR[FR_ILBM]->rf_LeftEdge - wp->LeftEdge;
	wi->TopEdge = wi->w_FR[FR_ILBM]->rf_TopEdge - wp->TopEdge;
	wi->Width = wi->w_FR[FR_ILBM]->rf_Width;
	wi->Height = wi->w_FR[FR_ILBM]->rf_Height;
    }
    return (FALSE);
}


/*****************************************************************************/


BOOL RestoreFunc (WindowInfoPtr wi)
{
    SHORT i;
    struct Image *im;

    for (i = 0; i < 2; i++)
    {
	SetRast (&wi->images[i].di_RPort, 0);

	if (i == 0)
	{
	    im = (struct Image *) wi->diskobj->do_Gadget.GadgetRender;
	}
	else
	{
	    im = (struct Image *) wi->diskobj->do_Gadget.SelectRender;
	}

	DrawImage (&wi->images[i].di_RPort, im, 0, 0);
    }

    RefreshImages (wi);
    SPRefresh (wi->wi_sketch);

    return (FALSE);
}


/*****************************************************************************/


VOID AutoTopLeft (DynamicImagePtr si)
{
    struct RastPort *prp = &(si->di_RPort);
    struct RastPort rp;
    SHORT w = si->di_Image.Width;
    SHORT h = si->di_Image.Height;
    SHORT x, y, mx = w, my = h, p;

    /* clone the rastport */
    rp = *prp;
    SetAPen (&rp, 0);
    SetBPen (&rp, 0);
    SetDrMd (&rp, JAM1);

    for (x = 0; x < w; x++)
    {
	for (y = 0; y < h; y++)
	{
	    p = ReadPixel (&rp, x, y);
	    if (p > 0)
	    {
		mx = MIN (x, mx);
		my = MIN (y, my);
	    }
	}
    }

    x = mx;
    y = my;
    mx = w - x;
    my = h - y;
    ClipBlit (&rp, x, y,
	      &rp, 0, 0,
	      mx, my, VANILLA_COPY);

    if (mx < ICON_WIDTH)
	RectFill (&rp, mx, 0, ICON_WIDTH, ICON_HEIGHT);

    if (my < ICON_HEIGHT)
	RectFill (&rp, 0, my, ICON_WIDTH, ICON_HEIGHT);
}

/*****************************************************************************/

BOOL CheckForChanges (WindowInfoPtr wi, AppStringsID body, AppStringsID gadgets)
{
    UBYTE pname[255];
    ULONG len;

    if ((len = strlen (wi->iconname)) < 1)
    {
	strcpy (pname, GetString (MSG_IE_UNTITLED));
    }
    else if (len < 80)
    {
	strcpy (pname, wi->iconname);
    }
    else
    {
	ULONG i, j, k;

	/* Get the volume portion */
	for (i = k = 0; i < 40; i++)
	{
	    if (wi->iconname[i] == ':')
	    {
		k = i;
		break;
	    }
	}

	/* Find a good splitting place */
	k += 34;
	while (k > 0)
	{
	    if (wi->iconname[k] == '/')
		break;
	    k--;
	}

	/* Build the first part of the name */
	for (i = j = 0; i <= k; i++)
	    pname[j++] = wi->iconname[i];

	/* Do the elipses portion */
	pname[j++] = '.';
	pname[j++] = '.';
	pname[j++] = '.';

	/* Come up with the remainder of the name */
	k = (k < 40) ? 80 - k : 40;
	for (i = len - k; i < len; i++)
	{
	    if (wi->iconname[i] == '/')
		break;
	}

	/* Copy the remainder of the name */
	for (; i < len; i++)
	    pname[j++] = wi->iconname[i];
	pname[j] = 0;
    }

    if (wi->changed)
    {
	switch (EasyReq (wi->win, VNAM, GetString (body), GetString (gadgets), pname))
	{
	    case 2:
		/* Clear the cancel flag */
		wi->changed &= ~CH_CANCEL;

		/* Save the icon */
		SaveFunc (wi);

		/* See if we were canceled */
		if (wi->changed & CH_CANCEL)
		{
		    /* Clear the cancel flag */
		    wi->changed &= ~CH_CANCEL;

		    /* Return cancel */
		    return TRUE;
		}
		break;

	    case 1:
		break;		/* do action */

	    case 0:
		return (TRUE);	/* cancel */
		break;
	}
    }
    return (FALSE);
}


/*****************************************************************************/


/* Find the upper left corner of a big picture */
VOID FindTopLeft (struct RastPort * rp, struct Rectangle * clip, SHORT mw, SHORT mh)
{
    SHORT w = clip->MaxX;
    SHORT h = clip->MaxY;
    SHORT x, y, mx = w, my = h, p;

    if ((w > mw) || (h > mh))
    {
	w--;
	h--;
	for (x = 0; (x < w); x++)
	{
	    for (y = 0; (y < h); y++)
	    {
		p = ReadPixel (rp, x, y);
		if (p > 0)
		{
		    mx = MIN (x, mx);
		    my = MIN (y, my);
		}
	    }
	}
    }
    else
    {
	mx = 0;
	my = 0;
    }
    clip->MinX = mx;
    clip->MinY = my;
    clip->MaxX = MIN (clip->MaxX, (clip->MinX + mw));
    clip->MaxY = MIN (clip->MaxY, (clip->MinY + mh));
}


/*****************************************************************************/

#if 0
#define	MAXF	8191
#define	DESTX	80
#define	DESTY	40

/* Scale brush to maximum allowable size for an icon */
BOOL ScaleImage (ILBMPtr ir, struct BitMap * bm)
{
    struct BitScaleArgs bsa =
    {NULL};

    if (ir && bm)
    {
	bsa.bsa_SrcX = 0;
	bsa.bsa_SrcY = 0;
	bsa.bsa_SrcWidth = ir->ir_Width;
	bsa.bsa_SrcHeight = ir->ir_Height;
	bsa.bsa_XSrcFactor = MAXF;
	bsa.bsa_YSrcFactor = MAXF;
	bsa.bsa_DestX = 0;
	bsa.bsa_DestY = 0;
	bsa.bsa_XDestFactor = (MAXF / ir->ir_Width) * DESTX;
	bsa.bsa_YDestFactor = (MAXF / ir->ir_Height) * DESTY;
	bsa.bsa_SrcBitMap = &(ir->ir_BMap);
	bsa.bsa_DestBitMap = bm;

	BitMapScale (&bsa);
    }
    return (TRUE);
}

#endif

/*****************************************************************************/

BOOL SaveAsCFunc (WindowInfoPtr wi)
{
    struct Window *wp;
    UBYTE path[255], name[50];
    struct TagItem tg[10];

    wp = wi->win;

    if (wi->w_FR[FR_ICON])
    {
	/* Initialize the file requester position */
	if (wi->Width == (-1))
	{
	    wi->LeftEdge = wp->LeftEdge + 12;
	    wi->TopEdge  = wp->TopEdge + 12;
	    wi->Width    = 320;
	    wi->Height   = 175;
	}

	/* Set the file requester position */
	tg[4].ti_Tag = ASL_LeftEdge;
	tg[4].ti_Data = (ULONG) wp->LeftEdge + wi->LeftEdge;
	tg[5].ti_Tag = ASL_TopEdge;
	tg[5].ti_Data = (ULONG) wp->TopEdge + wi->TopEdge;
	tg[6].ti_Tag = ASL_Width;
	tg[6].ti_Data = (ULONG) wi->Width;
	tg[7].ti_Tag = ASL_Height;
	tg[7].ti_Data = (ULONG) wi->Height;

	tg[0].ti_Tag = ASL_Hail;
	tg[0].ti_Data = (ULONG) GetString (MSG_IE_SAVEFILE_TITLE);
	tg[1].ti_Tag = ASL_FuncFlags;
	tg[1].ti_Data = FILF_SAVE;
	tg[2].ti_Tag = ASL_OKText;
	tg[2].ti_Data = (ULONG) GetString (MSG_IE_SAVE_GAD);
	tg[3].ti_Tag = ASL_Window;
	tg[3].ti_Data = (ULONG) wp;
	tg[8].ti_Tag = ASL_Pattern;
	tg[8].ti_Data = (ULONG) "~(#?.info)";
	tg[9].ti_Tag = TAG_DONE;

	if (AslRequest (wi->w_FR[FR_C], tg))
	{
	    FixFileAndPath (wi->w_FR[FR_C], NULL);
	    strcpy (name, wi->w_FR[FR_C]->rf_File);
	    strcpy (path, wi->w_FR[FR_C]->rf_Dir);
	    strcpy (wi->w_Tmp, path);
	    AddPart (wi->w_Tmp, name, 254);
	    FixFileAndPath (wi->w_FR[FR_C], wi->w_Tmp);

	    /* Save as C source */
	    SaveIcon (wi, wi->w_Tmp, wi->diskobj, 2);
	}

	/* Remember where they moved it */
	wi->LeftEdge = wi->w_FR[FR_C]->rf_LeftEdge - wp->LeftEdge;
	wi->TopEdge = wi->w_FR[FR_C]->rf_TopEdge - wp->TopEdge;
	wi->Width = wi->w_FR[FR_C]->rf_Width;
	wi->Height = wi->w_FR[FR_C]->rf_Height;
    }

    return (FALSE);
}


/*****************************************************************************/


BOOL EraseFunc (WindowInfoPtr wi)
{
    DynamicImagePtr di = &wi->images[wi->currentwin];

    if (!CheckForChanges (wi, MSG_IE_ERASEANDZAP, MSG_IE_ERASEANDZAP_GADS))
    {
	SPSaveToUndo (wi->wi_sketch);

	SetRast (&(di->di_RPort), 0);
	RefreshImages (wi);
	SPRefresh (wi->wi_sketch);
	wi->clippable = FALSE;
    }
    return (FALSE);
}


/*****************************************************************************/


BOOL TemplateFunc (WindowInfoPtr wi)
{
    DynamicImagePtr di = &wi->images[wi->currentwin];
    extern struct Image template_data;

    if (!CheckForChanges (wi, MSG_IE_TEMPLATEANDZAP, MSG_IE_TEMPLATEANDZAP_GADS))
    {
	SPSaveToUndo (wi->wi_sketch);

	/* Clear the work area */
	SetRast (&(di->di_RPort), 0);

	/* Draw the template */
	DrawImage (&(di->di_RPort), &template_data, 0, 0);

	/* Refresh the view */
	RefreshImages (wi);
	SPRefresh (wi->wi_sketch);

	wi->changed |= CH_MAJOR;
	wi->clippable = FALSE;
    }

    return (FALSE);
}


/*****************************************************************************/


void Recolor (struct Image * im)
{
    USHORT *data;
    LONG words, offset;
    LONG count;
    USHORT bits;
    USHORT plane;
    USHORT mask;
    UBYTE value;

    if (im)
	if (im->Depth > 0)
	{
	    words = ((im->Width + 15) >> 4) * im->Height;
	    data = im->ImageData;

	    for (count = words; count > 0; count--)
	    {
		bits = 16;
		while (bits--)
		{
		    mask = 1L << bits;
		    value = 0;
		    offset = 0;

		    for (plane = 0; plane < im->Depth; plane++)
		    {
			if (data[offset] & mask)
			{
			    value |= (1 << plane);
			}
			offset += words;
		    }

		    if (value == 2)
		    {
			data[0] |= mask;
			data[words] &= ~mask;
		    }
		    else if (value == 1)
		    {
			data[0] &= ~mask;
			data[words] |= mask;
		    }
		}
		data++;
	    }
	}
}


/*****************************************************************************/


BOOL RecolorFunc (WindowInfoPtr wi)
{

    SPSaveToUndo (wi->wi_sketch);

    /* Do the normal image */
    Recolor (&(wi->images[0].di_Image));
    Recolor (wi->diskobj->do_Gadget.GadgetRender);

    /* Do the alternate image */
    Recolor (&(wi->images[1].di_Image));
    Recolor (wi->diskobj->do_Gadget.SelectRender);

    /* Refresh the screen */
    RefreshImages (wi);

    /* Show that the image has been changed */
    wi->changed |= CH_REMAP;

    /* Refresh the view */
    SPRefresh (wi->wi_sketch);

    return (FALSE);
}


/*****************************************************************************/


BOOL TopLeftFunc (WindowInfoPtr wi)
{

    SPSaveToUndo (wi->wi_sketch);

    AutoTopLeft (&(wi->images[wi->currentwin]));
    RefreshImages (wi);

    /* Major image change */
    wi->changed |= CH_MAJOR;

    /* Refresh the view */
    SPRefresh (wi->wi_sketch);

    return (FALSE);
}


/*****************************************************************************/


BOOL PaletteFunc (WindowInfoPtr wi)
{

    System (wi->w_Palette, NULL);
    return (FALSE);
}
@


38.6
log
@properly undo's after load image
@
text
@d147 1
d149 1
a149 2
struct Image blank =
{0, 0, 0, 0, 0, NULL, 0, 1, NULL};
d151 4
a157 1

a174 1

a176 1

a178 1

a181 1

a183 1

a218 1

a220 1

a222 1

a437 1

a439 1

d463 1
a463 1
	sprintf (wi->wintitle, GetString (MSG_IE_TITLE), name);
a567 1

d583 2
a592 1

d666 2
a1198 2


a1200 1

d1204 1
d1206 2
a1207 2
    strcpy (pname, wi->iconname);
    if (strlen (pname) < 1)
d1209 8
d1218 42
d1265 15
a1279 1
		SaveFunc (wi);	/* save, then do action */
@


38.5
log
@cleaned up file requester smarts
@
text
@d415 2
d549 2
d587 3
a590 3

	/* Open the icon */
	OpenNamedIcon (wi, wi->iconname, TRUE);
@


38.4
log
@use modern file requester placement
@
text
@d609 4
a612 8
	    wi->LeftEdge = wp->BorderLeft + 1;
	    wi->TopEdge = wp->BorderTop;
	    wi->Width = 320;
	    wi->Height = wp->Height - (wp->BorderTop + wp->BorderBottom);
	    if (wi->Height < 140)
	    {
		wi->Height = 140;
	    }
d805 4
a808 8
	    wi->LeftEdge = wp->BorderLeft + 1;
	    wi->TopEdge = wp->BorderTop;
	    wi->Width = 320;
	    wi->Height = wp->Height - (wp->BorderTop + wp->BorderBottom);
	    if (wi->Height < 140)
	    {
		wi->Height = 140;
	    }
d908 4
a911 8
	    wi->LeftEdge = wp->BorderLeft + 1;
	    wi->TopEdge = wp->BorderTop;
	    wi->Width = 320;
	    wi->Height = wp->Height - (wp->BorderTop + wp->BorderBottom);
	    if (wi->Height < 140)
	    {
		wi->Height = 140;
	    }
d996 4
a999 8
	    wi->LeftEdge = wp->BorderLeft + 1;
	    wi->TopEdge = wp->BorderTop;
	    wi->Width = 320;
	    wi->Height = wp->Height - (wp->BorderTop + wp->BorderBottom);
	    if (wi->Height < 140)
	    {
		wi->Height = 140;
	    }
d1074 4
a1077 8
	    wi->LeftEdge = wp->BorderLeft + 1;
	    wi->TopEdge = wp->BorderTop;
	    wi->Width = 320;
	    wi->Height = wp->Height - (wp->BorderTop + wp->BorderBottom);
	    if (wi->Height < 140)
	    {
		wi->Height = 140;
	    }
d1322 4
a1325 8
	    wi->LeftEdge = wp->BorderLeft + 1;
	    wi->TopEdge = wp->BorderTop;
	    wi->Width = 320;
	    wi->Height = wp->Height - (wp->BorderTop + wp->BorderBottom);
	    if (wi->Height < 140)
	    {
		wi->Height = 140;
	    }
@


38.3
log
@new clipboard code
@
text
@d505 4
a508 8
	    wi->LeftEdge = wp->BorderLeft + 1;
	    wi->TopEdge = wp->BorderTop;
	    wi->Width = 320;
	    wi->Height = wp->Height - (wp->BorderTop + wp->BorderBottom);
	    if (wi->Height < 140)
	    {
		wi->Height = 140;
	    }
@


38.2
log
@Increased window size for better localization
@
text
@d7 2
a41 1

a43 1

d51 1
a51 1

d55 9
a64 9
BOOL SaveAsCFunc(WindowInfoPtr wi);
BOOL TemplateFunc(WindowInfoPtr wi);
BOOL EraseFunc(WindowInfoPtr wi);
BOOL RecolorFunc(WindowInfoPtr wi);
BOOL TopLeftFunc(WindowInfoPtr wi);
BOOL PaletteFunc(WindowInfoPtr wi);
BOOL LoadIFFBrush(STRPTR iffname, DynamicImagePtr di, BOOL show_errs);


a66 1

d76 58
a133 58
    {NM_TITLE,  (STRPTR)MSG_IE_PROJECT_MENU,      },
      {NM_ITEM, (STRPTR)MSG_IE_PROJECT_NEW,       0, 0, 0, NewFunc,},
      {NM_ITEM, (STRPTR)NM_BARLABEL,              },
      {NM_ITEM, (STRPTR)MSG_IE_PROJECT_OPEN,      0, 0, 0, OpenFunc,},
      {NM_ITEM, (STRPTR)NM_BARLABEL,              },
      {NM_ITEM, (STRPTR)MSG_IE_PROJECT_SAVE,      0, 0, 0, SaveFunc,},
      {NM_ITEM, (STRPTR)MSG_IE_PROJECT_SAVEAS,    0, 0, 0, SaveAsFunc,},
      {NM_ITEM, (STRPTR)MSG_IE_PROJECT_SAVEASDEF, 0, 0, 0, SaveDefFunc,},
      {NM_ITEM, (STRPTR)MSG_IE_PROJECT_SAVEASC,   0, 0, 0, SaveAsCFunc,},
      {NM_ITEM, (STRPTR)NM_BARLABEL,              },
      {NM_ITEM, (STRPTR)MSG_IE_PROJECT_QUIT,      0, 0, 0, QuitFunc,},

    {NM_TITLE,  (STRPTR)MSG_IE_EDIT_MENU,     },
      {NM_ITEM, (STRPTR)MSG_IE_EDIT_CUT,      0, 0, 0, CutClipFunc,},
      {NM_ITEM, (STRPTR)MSG_IE_EDIT_COPY,     0, 0, 0, CopyClipFunc,},
      {NM_ITEM, (STRPTR)MSG_IE_EDIT_PASTE,    0, 0, 0, PasteClipFunc,},
      {NM_ITEM, (STRPTR)MSG_IE_EDIT_ERASE,    0, 0, 0, EraseFunc,},
      {NM_ITEM, (STRPTR)NM_BARLABEL,          },
      {NM_ITEM, (STRPTR)MSG_IE_EDIT_OPENCLIP, 0, 0, 0, OpenClipFunc,},
      {NM_ITEM, (STRPTR)MSG_IE_EDIT_SAVECLIP, 0, 0, 0, SaveClipFunc,},
      {NM_ITEM, (STRPTR)MSG_IE_EDIT_SHOWCLIP, 0, 0, 0, ShowClipFunc,},

    {NM_TITLE,  (STRPTR)MSG_IE_TYPE_MENU,    },
      {NM_ITEM, (STRPTR)MSG_IE_TYPE_DISK,    0, CHECKIT, ~1, V (0),},
      {NM_ITEM, (STRPTR)MSG_IE_TYPE_DRAWER,  0, CHECKIT, ~2, V (1),},
      {NM_ITEM, (STRPTR)MSG_IE_TYPE_TOOL,    0, CHECKIT | CHECKED, ~4, V (2),},
      {NM_ITEM, (STRPTR)MSG_IE_TYPE_PROJECT, 0, CHECKIT, ~8, V (3),},
      {NM_ITEM, (STRPTR)MSG_IE_TYPE_GARBAGE, 0, CHECKIT, ~16, V (4),},

    {NM_TITLE,  (STRPTR)MSG_IE_HIGHLIGHT_MENU,       },
      {NM_ITEM, (STRPTR)MSG_IE_HIGHLIGHT_COMPLEMENT, 0, CHECKIT | CHECKED, ~1, V (0),},
      {NM_ITEM, (STRPTR)MSG_IE_HIGHLIGHT_BACKFILL,   0, CHECKIT, ~2, V (1),},
      {NM_ITEM, (STRPTR)MSG_IE_HIGHLIGHT_IMAGE,      0, CHECKIT, ~4, V (2),},

    {NM_TITLE,   (STRPTR)MSG_IE_IMAGES_MENU,     },
      {NM_ITEM,  (STRPTR)MSG_IE_IMAGES_EXCHANGE, 0, 0, 0, ExchangeFunc,},
      {NM_ITEM,  (STRPTR)MSG_IE_IMAGES_COPY,     0, 0, 0, CopyFunc,},
      {NM_ITEM,  (STRPTR)MSG_IE_IMAGES_TEMPLATE, 0, 0, 0, TemplateFunc,},
      {NM_ITEM,  (STRPTR)NM_BARLABEL,            },
      {NM_ITEM,  (STRPTR)MSG_IE_IMAGES_LOAD,     0, 0, 0, 0,},
        {NM_SUB, (STRPTR)MSG_IE_IMAGES_IFFBRUSH, 0, 0, 0, LIFFFunc,},
        {NM_SUB, (STRPTR)MSG_IE_IMAGES_NORMAL,   0, 0, 0, LStdFunc,},
        {NM_SUB, (STRPTR)MSG_IE_IMAGES_SELECTED, 0, 0, 0, LAltFunc,},
        {NM_SUB, (STRPTR)MSG_IE_IMAGES_BOTH,     0, 0, 0, LBthFunc,},
      {NM_ITEM,  (STRPTR)MSG_IE_IMAGES_SAVEIFF,  0, 0, 0, SIFFFunc,},
      {NM_ITEM,  (STRPTR)NM_BARLABEL,            },
      {NM_ITEM,  (STRPTR)MSG_IE_IMAGES_RESTORE,  0, 0, 0, RestoreFunc,},

    {NM_TITLE,  (STRPTR)MSG_IE_EXTRAS_MENU,    },
      {NM_ITEM, (STRPTR)MSG_IE_EXTRAS_RECOLOR, 0, 0, 0, RecolorFunc,}, /* 43 */
      {NM_ITEM, (STRPTR)MSG_IE_EXTRAS_AUTO,    0, 0, 0, TopLeftFunc,},
      {NM_ITEM, (STRPTR)MSG_IE_EXTRAS_PALETTE, 0, 0, 0, PaletteFunc,},

    {NM_TITLE,  (STRPTR)MSG_IE_SETTINGS_MENU,  },
      {NM_ITEM, (STRPTR)MSG_IE_SETTINGS_GRID,  0, CHECKIT | MENUTOGGLE, 0, V (0),},
      {NM_ITEM, (STRPTR)MSG_IE_SETTINGS_ICONS, 0, CHECKIT | MENUTOGGLE, 0, V (1),},
      {NM_ITEM, (STRPTR)NM_BARLABEL,           },
      {NM_ITEM, (STRPTR)MSG_IE_SETTINGS_SAVE,  0, 0, 0, V (2),},
d155 1
a155 1
VOID CheckClippable(WindowInfoPtr wi, struct DiskObject *dob)
d157 1
a157 1
struct Image *im;
d176 1
a176 1
BOOL LayoutIEMenus(WindowInfoPtr wi, struct Menu *menus,ULONG tag1, ...)
d178 2
a179 1
    return(LayoutMenusA(menus,wi->vi,(struct TagItem *) &tag1));
d186 1
a186 1
struct Menu *CreateIEMenus(WindowInfoPtr wi, struct NewMenu *nm)
d188 2
a189 2
struct Menu *menus;
UWORD        i;
d194 15
a208 15
        if (nm[i].nm_Type == NM_TITLE)
        {
            nm[i].nm_Label = GetString((LONG)nm[i].nm_Label);
        }
        else if ((nm[i].nm_Type != IM_ITEM) && (nm[i].nm_Label != NM_BARLABEL))
        {
            nm[i].nm_CommKey = GetString((LONG)nm[i].nm_Label);
            nm[i].nm_Label   = &nm[i].nm_CommKey[2];
            if (nm[i].nm_CommKey[0] == ' ')
                nm[i].nm_CommKey = NULL;
        }
        i++;
    }

    if (menus = CreateMenusA(nm,NULL))
d210 4
a213 4
        if (!(LayoutIEMenus(wi,menus,GTMN_NewLookMenus,TRUE,
                                     TAG_DONE)))
        {
            FreeMenus(menus);
d218 1
a218 1
    return(menus);
d225 1
a225 1
BOOL CreateIconMenus(WindowInfoPtr wi)
d227 1
d231 5
a235 5
	NM[8].nm_Type          = IM_ITEM;
        NM[8].nm_Label         = (STRPTR)&blank;
        NM[8].nm_CommKey       = NULL;
        NM[8].nm_Flags         = NM_ITEMDISABLED;
        NM[8].nm_MutualExclude = NULL;
d242 1
a242 1
    if (wi->menu = CreateIEMenus(wi,NM))
d244 2
a245 2
        SetMenuStrip(wi->win,wi->menu);
	return(TRUE);
d248 1
a248 1
    return(FALSE);
d257 4
a260 4
struct Menu *m;
struct MenuItem *mi;
UWORD mid;
USHORT i;
d287 1
a287 1
VOID SetHilite(WindowInfoPtr wi,struct DiskObject * dob, UWORD mhilite)
d289 2
a290 2
struct Window *wp;
USHORT pos;
d293 1
a293 1
    pos = RemoveGList(wp, wi->img1, 1L);
d318 2
a319 1
    wi->type             = mtype;
d321 1
a321 1
    wi->changed         |= CH_MINOR;
d328 1
a328 1
BOOL HandleMenuEvent(WindowInfoPtr wi, UWORD code)
d330 3
a332 3
struct MenuItem *item;
BOOL terminated = FALSE;
LONG menunum, itemnum;
d359 1
a359 1
		/* Toggle Grid */
d374 1
a374 1
		/* Toggle Icon */
d386 1
a386 1
		/* Save Settings */
d388 1
a388 1
		    SetIconEditPrefs(wi);
d407 3
a409 3
struct Window *wp;
SHORT i;
BOOL cancel;
d412 1
a412 1
    cancel = CheckForChanges(wi,MSG_IE_NEWANDZAP,MSG_IE_NEWANDZAP_GADS);
d430 2
a431 2
	    strcpy (wi->wintitle,GetString(MSG_IE_DEFAULT_TITLE));
	    SetWindowTitles (wp, wi->wintitle,(STRPTR)-1);
d447 2
a448 2
struct Window *wp;
struct DiskObject *dob;
d453 1
a453 1
	UpdateIconInfo(wi, dob);
d468 1
a468 1
	sprintf (wi->wintitle, GetString(MSG_IE_TITLE),name);
d472 1
a472 1
	wi->changed   = CH_NONE;
d474 1
a474 1
	CheckClippable(wi,dob);
d478 2
a479 2
	sprintf (wi->w_Buffer, GetString(MSG_IE_ERROR_COULDNT_LOAD),name);
	NotifyUser(0,wi->w_Buffer);
d490 1
a490 1
BOOL OpenFunc(WindowInfoPtr wi)
d492 3
a494 3
struct Window *wp;
UBYTE path[255], name[50];
BOOL cancel;
d497 1
a497 1
    cancel = CheckForChanges(wi,MSG_IE_OPENANDZAP,MSG_IE_OPENANDZAP_GADS);
d526 1
a526 1
	tg[0].ti_Data = (ULONG) GetString(MSG_IE_OPENICON_TITLE);
d530 1
a530 1
	tg[2].ti_Data = (ULONG) GetString(MSG_IE_OPEN_GAD);
d573 1
a573 1
BOOL SaveFunc(WindowInfoPtr wi)
d575 1
d578 2
a579 2
        /* Not named yet, so let's get a name */
        SaveAsFunc (wi);
d583 5
a587 5
        if (SaveIcon (wi, wi->iconname, wi->diskobj, 0))
        {
            /* Clear the changes flags */
            wi->changed = CH_NONE;
        }
d589 2
a590 2
        /* Open the icon */
        OpenNamedIcon (wi, wi->iconname, TRUE);
d602 2
a603 2
struct Window *wp;
UBYTE path[255], name[50];
d608 100
a707 1
        struct TagItem tg[10];
d709 2
a710 99
        /* Initialize the file requester position */
        if (wi->Width == (-1))
        {
            wi->LeftEdge = wp->BorderLeft + 1;
            wi->TopEdge = wp->BorderTop;
            wi->Width = 320;
            wi->Height = wp->Height - (wp->BorderTop + wp->BorderBottom);
            if (wi->Height < 140)
            {
                wi->Height = 140;
            }
        }

        /* Set the file requester position */
        tg[4].ti_Tag = ASL_LeftEdge;
        tg[4].ti_Data = (ULONG) wp->LeftEdge + wi->LeftEdge;
        tg[5].ti_Tag = ASL_TopEdge;
        tg[5].ti_Data = (ULONG) wp->TopEdge + wi->TopEdge;
        tg[6].ti_Tag = ASL_Width;
        tg[6].ti_Data = (ULONG) wi->Width;
        tg[7].ti_Tag = ASL_Height;
        tg[7].ti_Data = (ULONG) wi->Height;

        tg[0].ti_Tag = ASL_Hail;
        tg[0].ti_Data = (ULONG) GetString(MSG_IE_SAVEICON_TITLE);
        tg[1].ti_Tag = ASL_FuncFlags;
        tg[1].ti_Data = FILF_SAVE;
        tg[2].ti_Tag = ASL_OKText;
        tg[2].ti_Data = (ULONG) GetString(MSG_IE_SAVE_GAD);
        tg[3].ti_Tag = ASL_Window;
        tg[3].ti_Data = (ULONG) wp;
        tg[8].ti_Tag = ASL_Pattern;
        tg[8].ti_Data = (ULONG) "#?";
        tg[9].ti_Tag = TAG_DONE;

        /* Request the icon name */
        if (AslRequest (wi->w_FR[FR_ICON], tg))
        {
            WORD count;

            /* Fix the entries */
            FixFileAndPath (wi->w_FR[FR_ICON], NULL);

            strcpy (name, wi->w_FR[FR_ICON]->rf_File);
            strcpy (path, wi->w_FR[FR_ICON]->rf_Dir);
            strcpy (wi->w_Tmp, path);
            AddPart (wi->w_Tmp, name, 254);

            if ((count = stcgfn (wi->w_FR[FR_ICON]->rf_File, wi->w_Tmp)) > 0)
            {
                strcpy (wi->iconname, wi->w_Tmp);
                if (SaveIcon (wi, wi->iconname, wi->diskobj, 0))
                {
                    /* Open the icon */
                    OpenNamedIcon (wi, wi->iconname, TRUE);

                    /* Clear the changes flags */
                    wi->changed = CH_NONE;
                }
            }
            else
            {
                NotifyUser(MSG_IE_ERROR_NO_FILENAME,NULL);
            }

            FixFileAndPath (wi->w_FR[FR_ICON], wi->iconname);
        }

        /* Remember where they moved it */
        wi->LeftEdge = wi->w_FR[FR_ICON]->rf_LeftEdge - wp->LeftEdge;
        wi->TopEdge = wi->w_FR[FR_ICON]->rf_TopEdge - wp->TopEdge;
        wi->Width = wi->w_FR[FR_ICON]->rf_Width;
        wi->Height = wi->w_FR[FR_ICON]->rf_Height;
    }
    return (FALSE);
}


/*****************************************************************************/


BOOL SaveDefFunc(WindowInfoPtr wi)
{
    SaveIcon(wi,wi->iconname, wi->diskobj, 1);
    return(FALSE);
}


/*****************************************************************************/


BOOL QuitFunc(WindowInfoPtr wi)
{
    return(TRUE);
}


/*****************************************************************************/

d712 1
a712 1
BOOL ExchangeFunc(WindowInfoPtr wi)
d714 1
a714 1
struct DynamicImage di;
d717 2
a718 2
    InitDynamicImage(&di,MAXDEPTH,ICON_WIDTH,ICON_HEIGHT);
    if (AllocDynamicImage(&di))
d720 6
a725 6
	DrawImage(&di.di_RPort,&wi->images[0].di_Image,0,0);
	DrawImage(&wi->images[0].di_RPort, &wi->images[1].di_Image,0,0);
	DrawImage(&wi->images[1].di_RPort, &di.di_Image,0,0);
	FreeDynamicImage(&di);
	RefreshImages(wi);
	SPRefresh(wi->wi_sketch);
d728 2
a729 2
	SetHilite(wi,wi->diskobj,wi->hilite);
	CheckMenuItem(wi,3,2);
d734 1
a734 1
    return(FALSE);
d741 1
a741 1
BOOL CopyFunc(WindowInfoPtr wi)
d743 1
a743 1
SHORT inactivewin;
d746 2
a747 2
    DrawImage(&wi->images[inactivewin].di_RPort,&wi->images[wi->currentwin].di_Image,0,0);
    RefreshImages(wi);
d750 2
a751 2
    SetHilite(wi,wi->diskobj,wi->hilite);
    CheckMenuItem(wi,3,2);
d756 1
a756 1
    return(FALSE);
d763 1
a763 1
VOID LoadIAI(WindowInfoPtr wi, USHORT lmode, struct DiskObject * dob, USHORT cur)
d765 2
a766 2
DynamicImagePtr di = &wi->images[cur];
struct Image *im;
d775 3
a777 3
	SetRast(&di->di_RPort,0);
	DrawImage(&di->di_RPort,im,0,0);
	RefreshImages(wi);
d784 2
a785 2
	    SetHilite(wi,wi->diskobj,wi->hilite);
	    CheckMenuItem(wi,3,2);
d792 1
a792 1
	NotifyUser(MSG_IE_ERROR_NO_IMAGE,NULL);
d800 1
a800 1
VOID LoadIconAsImage(WindowInfoPtr wi, USHORT lmode)
d802 4
a805 4
struct Window * wp;
struct DiskObject *dob;
UBYTE path[255], name[50];
struct TagItem tg[10];
d814 3
a816 3
	    wi->TopEdge  = wp->BorderTop;
	    wi->Width    = 320;
	    wi->Height   = wp->Height - (wp->BorderTop + wp->BorderBottom);
d819 19
a837 19
		wi->Height = 140;
	    }
	}

	/* Set the file requester position */
	tg[4].ti_Tag  = ASL_LeftEdge;
	tg[4].ti_Data = (ULONG) wp->LeftEdge + wi->LeftEdge;
	tg[5].ti_Tag  = ASL_TopEdge;
	tg[5].ti_Data = (ULONG) wp->TopEdge + wi->TopEdge;
	tg[6].ti_Tag  = ASL_Width;
	tg[6].ti_Data = (ULONG) wi->Width;
	tg[7].ti_Tag  = ASL_Height;
	tg[7].ti_Data = (ULONG) wi->Height;

	tg[0].ti_Tag  = ASL_Hail;
	tg[0].ti_Data = (ULONG) GetString(MSG_IE_LOADICON_TITLE);
	tg[2].ti_Tag  = ASL_OKText;
	tg[2].ti_Data = (ULONG) GetString(MSG_IE_LOAD_GAD);
	tg[3].ti_Tag  = ASL_Window;
d839 1
a839 1
	tg[1].ti_Tag  = ASL_FuncFlags;
d841 1
a841 1
	tg[8].ti_Tag  = ASL_Pattern;
d843 1
a843 1
	tg[9].ti_Tag  = TAG_DONE;
d845 1
a845 1
	if (AslRequest (wi->w_FR[FR_ALT],tg))
d847 6
a852 6
	    FixFileAndPath(wi->w_FR[FR_ALT], NULL);
	    strcpy(name,wi->w_FR[FR_ALT]->rf_File);
	    strcpy(path,wi->w_FR[FR_ALT]->rf_Dir);
	    strcpy(wi->w_Tmp,path);
	    AddPart(wi->w_Tmp,name, 254);
	    FixFileAndPath(wi->w_FR[FR_ALT],wi->w_Tmp);
d856 1
a856 1
		LoadIAI(wi,lmode,dob,wi->currentwin);
d860 1
a860 1
		NotifyUser(MSG_IE_ERROR_NOT_AN_ICON,NULL);
d873 3
a875 3
	wi->TopEdge  = wi->w_FR[FR_ALT]->rf_TopEdge - wp->TopEdge;
	wi->Width    = wi->w_FR[FR_ALT]->rf_Width;
	wi->Height   = wi->w_FR[FR_ALT]->rf_Height;
d883 1
a883 1
BOOL LStdFunc(WindowInfoPtr wi)
d885 3
a887 2
    LoadIconAsImage(wi,0);
    return(FALSE);
d894 1
a894 1
BOOL LAltFunc(WindowInfoPtr wi)
d896 3
a898 2
    LoadIconAsImage(wi,1);
    return(FALSE);
d905 1
a905 1
BOOL LBthFunc(WindowInfoPtr wi)
d907 6
a912 6
struct Window * wp;
SHORT curwin = wi->currentwin;
SHORT i;
struct DiskObject *dob;
UBYTE path[255], name[50];
struct TagItem tg[10];
d921 3
a923 3
	    wi->TopEdge  = wp->BorderTop;
	    wi->Width    = 320;
	    wi->Height   = wp->Height - (wp->BorderTop + wp->BorderBottom);
d926 19
a944 19
		wi->Height = 140;
	    }
	}

	/* Set the file requester position */
	tg[4].ti_Tag  = ASL_LeftEdge;
	tg[4].ti_Data = (ULONG) wp->LeftEdge + wi->LeftEdge;
	tg[5].ti_Tag  = ASL_TopEdge;
	tg[5].ti_Data = (ULONG) wp->TopEdge + wi->TopEdge;
	tg[6].ti_Tag  = ASL_Width;
	tg[6].ti_Data = (ULONG) wi->Width;
	tg[7].ti_Tag  = ASL_Height;
	tg[7].ti_Data = (ULONG) wi->Height;

	tg[0].ti_Tag  = ASL_Hail;
	tg[0].ti_Data = (ULONG) GetString(MSG_IE_LOADICON_TITLE);
	tg[2].ti_Tag  = ASL_OKText;
	tg[2].ti_Data = (ULONG) GetString(MSG_IE_LOAD_GAD);
	tg[3].ti_Tag  = ASL_Window;
d946 1
a946 1
	tg[1].ti_Tag  = ASL_FuncFlags;
d948 1
a948 1
	tg[8].ti_Tag  = ASL_Pattern;
d950 1
a950 1
	tg[9].ti_Tag  = TAG_DONE;
d952 1
a952 1
	if (AslRequest(wi->w_FR[FR_ALT],tg))
d954 6
a959 6
	    FixFileAndPath(wi->w_FR[FR_ALT],NULL);
	    strcpy(name,wi->w_FR[FR_ALT]->rf_File);
	    strcpy(path,wi->w_FR[FR_ALT]->rf_Dir);
	    strcpy(wi->w_Tmp,path);
	    AddPart(wi->w_Tmp,name,254);
	    FixFileAndPath(wi->w_FR[FR_ALT],wi->w_Tmp);
d961 1
a961 1
	    if (dob = LoadIcon(wi->w_Tmp,TRUE))
d966 3
a968 3
		    wi->Adi        = &wi->images[i];
		    SPSetRepeat(wi->wi_sketch,wi->Adi,(wi->w_LO + 77) + 16,wi->wintopx[i]);
		    LoadIAI(wi,i,dob,wi->currentwin);
d971 1
a971 1
                    CheckClippable(wi,dob);
d976 1
a976 1
		NotifyUser(MSG_IE_ERROR_NOT_AN_ICON,NULL);
d980 1
a980 1
		FreeDiskObject(dob);
d986 4
a989 4
	wi->LeftEdge   = wi->w_FR[FR_ALT]->rf_LeftEdge - wp->LeftEdge;
	wi->TopEdge    = wi->w_FR[FR_ALT]->rf_TopEdge - wp->TopEdge;
	wi->Width      = wi->w_FR[FR_ALT]->rf_Width;
	wi->Height     = wi->w_FR[FR_ALT]->rf_Height;
d991 3
a993 3
	wi->Adi        = &wi->images[wi->currentwin];
	SPSetRepeat(wi->wi_sketch, wi->Adi,(wi->w_LO + 77) + 16,wi->wintopx[wi->currentwin]);
	SPRefresh(wi->wi_sketch);
d995 1
a995 18
    return(FALSE);
}


/*****************************************************************************/


BOOL LoadIFFImage(WindowInfoPtr wi, STRPTR name, USHORT cur, BOOL errs)
{
DynamicImagePtr di = &wi->images[cur];

    if (LoadIFFBrush(name,di,errs))
    {
	RefreshImages(wi);
	SPRefresh(wi->wi_sketch);
	return(TRUE);
    }
    return(FALSE);
a997 1

d1000 1
a1000 2

BOOL LIFFFunc(WindowInfoPtr wi)
d1002 3
a1004 3
struct Window * wp;
UBYTE path[255], name[50];
struct TagItem tg[10];
d1013 3
a1015 3
	    wi->TopEdge  = wp->BorderTop;
	    wi->Width    = 320;
	    wi->Height   = wp->Height - (wp->BorderTop + wp->BorderBottom);
d1018 19
a1036 19
		wi->Height = 140;
	    }
	}

	/* Set the file requester position */
	tg[4].ti_Tag  = ASL_LeftEdge;
	tg[4].ti_Data = (ULONG) wp->LeftEdge + wi->LeftEdge;
	tg[5].ti_Tag  = ASL_TopEdge;
	tg[5].ti_Data = (ULONG) wp->TopEdge + wi->TopEdge;
	tg[6].ti_Tag  = ASL_Width;
	tg[6].ti_Data = (ULONG) wi->Width;
	tg[7].ti_Tag  = ASL_Height;
	tg[7].ti_Data = (ULONG) wi->Height;

	tg[0].ti_Tag  = ASL_Hail;
	tg[0].ti_Data = (ULONG) GetString(MSG_IE_LOADBRUSH_TITLE);
	tg[2].ti_Tag  = ASL_OKText;
	tg[2].ti_Data = (ULONG) GetString(MSG_IE_LOAD_GAD);
	tg[3].ti_Tag  = ASL_Window;
d1038 1
a1038 1
	tg[1].ti_Tag  = ASL_FuncFlags;
d1040 1
a1040 1
	tg[8].ti_Tag  = ASL_Pattern;
d1042 1
a1042 1
	tg[9].ti_Tag  = TAG_DONE;
d1044 1
a1044 1
	if (AslRequest(wi->w_FR[FR_ILBM], tg))
d1046 6
a1051 6
	    FixFileAndPath (wi->w_FR[FR_ILBM],NULL);
	    strcpy(name,wi->w_FR[FR_ILBM]->rf_File);
	    strcpy(path,wi->w_FR[FR_ILBM]->rf_Dir);
	    strcpy(wi->w_Tmp,path);
	    AddPart(wi->w_Tmp,name,254);
	    FixFileAndPath (wi->w_FR[FR_ILBM],wi->w_Tmp);
d1053 1
a1053 1
	    LoadIFFImage(wi,wi->w_Tmp, wi->currentwin, TRUE);
d1071 1
a1071 1
BOOL SStdFunc(WindowInfoPtr wi)
d1073 2
a1074 1
    return(FALSE);
d1081 1
a1081 1
BOOL SIFFFunc(WindowInfoPtr wi)
d1083 4
a1086 4
struct Window * wp;
DynamicImagePtr di = &wi->images[wi->currentwin];
UBYTE path[255], name[50];
struct TagItem tg[10];
d1095 3
a1097 3
	    wi->TopEdge  = wp->BorderTop;
	    wi->Width    = 320;
	    wi->Height   = wp->Height - (wp->BorderTop + wp->BorderBottom);
d1105 1
a1105 1
	tg[4].ti_Tag  = ASL_LeftEdge;
d1107 1
a1107 1
	tg[5].ti_Tag  = ASL_TopEdge;
d1109 1
a1109 1
	tg[6].ti_Tag  = ASL_Width;
d1111 1
a1111 1
	tg[7].ti_Tag  = ASL_Height;
d1114 3
a1116 3
	tg[0].ti_Tag  = ASL_Hail;
	tg[0].ti_Data = (ULONG) GetString(MSG_IE_SAVEBRUSH_TITLE);
	tg[1].ti_Tag  = ASL_FuncFlags;
d1118 3
a1120 3
	tg[2].ti_Tag  = ASL_OKText;
	tg[2].ti_Data = (ULONG) GetString(MSG_IE_SAVE_GAD);
	tg[3].ti_Tag  = ASL_Window;
d1122 1
a1122 1
	tg[8].ti_Tag  = ASL_Pattern;
d1124 1
a1124 1
	tg[9].ti_Tag  = TAG_DONE;
d1126 1
a1126 1
	if (AslRequest(wi->w_FR[FR_ILBM],tg))
d1128 6
a1133 6
	    FixFileAndPath(wi->w_FR[FR_ILBM],NULL);
	    strcpy(name,wi->w_FR[FR_ILBM]->rf_File);
	    strcpy(path,wi->w_FR[FR_ILBM]->rf_Dir);
	    strcpy(wi->w_Tmp,path);
	    AddPart(wi->w_Tmp, name, 254);
	    FixFileAndPath(wi->w_FR[FR_ILBM], wi->w_Tmp);
d1135 1
a1135 1
	    SaveIFFBrush(wi,wi->w_Tmp,di);
d1140 3
a1142 3
	wi->TopEdge  = wi->w_FR[FR_ILBM]->rf_TopEdge - wp->TopEdge;
	wi->Width    = wi->w_FR[FR_ILBM]->rf_Width;
	wi->Height   = wi->w_FR[FR_ILBM]->rf_Height;
d1144 8
a1151 8
    return(FALSE);
}


/*****************************************************************************/


BOOL RestoreFunc(WindowInfoPtr wi)
d1153 2
a1154 2
SHORT i;
struct Image *im;
d1158 1
a1158 1
	SetRast(&wi->images[i].di_RPort,0);
d1169 1
a1169 1
	DrawImage(&wi->images[i].di_RPort,im,0,0);
d1172 17
a1188 17
    RefreshImages(wi);
    SPRefresh(wi->wi_sketch);

    return(FALSE);
}


/*****************************************************************************/


VOID AutoTopLeft(DynamicImagePtr si)
{
struct RastPort *prp = &(si->di_RPort);
struct RastPort rp;
SHORT w = si->di_Image.Width;
SHORT h = si->di_Image.Height;
SHORT x, y, mx = w, my = h, p;
d1192 3
a1194 3
    SetAPen(&rp,0);
    SetBPen(&rp,0);
    SetDrMd(&rp,JAM1);
d1200 1
a1200 1
	    p = ReadPixel(&rp,x,y);
d1203 2
a1204 2
		mx = MIN(x,mx);
		my = MIN(y,my);
d1213 3
a1215 3
    ClipBlit(&rp,x,y,
             &rp,0,0,
             mx,my,VANILLA_COPY);
d1218 1
a1218 1
	RectFill(&rp,mx,0,ICON_WIDTH,ICON_HEIGHT);
d1221 1
a1221 1
	RectFill(&rp,0,my,ICON_WIDTH,ICON_HEIGHT);
d1229 1
a1229 1
BOOL CheckForChanges(WindowInfoPtr wi, AppStringsID body, AppStringsID gadgets)
d1231 1
a1231 1
UBYTE pname[255];
d1233 3
a1235 3
    strcpy(pname,wi->iconname);
    if (strlen(pname) < 1)
	strcpy(pname,GetString(MSG_IE_UNTITLED));
d1239 1
a1239 1
        switch(EasyReq(wi->win,VNAM,GetString(body),GetString(gadgets),pname))
d1241 3
a1243 2
	    case 2: SaveFunc(wi);	/* save, then do action */
		    break;
d1245 2
a1246 1
	    case 1: break;		/* do action */
d1248 3
a1250 2
	    case 0: return(TRUE);	/* cancel */
		    break;
d1253 1
a1253 1
    return(FALSE);
d1261 1
a1261 1
VOID FindTopLeft(struct RastPort * rp, struct Rectangle * clip, SHORT mw, SHORT mh)
d1263 3
a1265 3
SHORT w = clip->MaxX;
SHORT h = clip->MaxY;
SHORT x, y, mx = w, my = h, p;
d1275 1
a1275 1
		p = ReadPixel(rp,x,y);
d1278 2
a1279 2
		    mx = MIN(x,mx);
		    my = MIN(y,my);
d1291 2
a1292 2
    clip->MaxX = MIN(clip->MaxX,(clip->MinX + mw));
    clip->MaxY = MIN(clip->MaxY,(clip->MinY + mh));
d1298 1
a1298 1

d1304 1
a1304 1
BOOL ScaleImage(ILBMPtr ir, struct BitMap * bm)
d1306 2
a1307 1
struct BitScaleArgs bsa = {NULL};
d1311 8
a1318 8
	bsa.bsa_SrcX        = 0;
	bsa.bsa_SrcY        = 0;
	bsa.bsa_SrcWidth    = ir->ir_Width;
	bsa.bsa_SrcHeight   = ir->ir_Height;
	bsa.bsa_XSrcFactor  = MAXF;
	bsa.bsa_YSrcFactor  = MAXF;
	bsa.bsa_DestX       = 0;
	bsa.bsa_DestY       = 0;
d1321 2
a1322 47
	bsa.bsa_SrcBitMap   = &(ir->ir_BMap);
	bsa.bsa_DestBitMap  = bm;

	BitMapScale(&bsa);
    }
    return(TRUE);
}


/*****************************************************************************/


BOOL LoadIFFBrush(STRPTR iffname, DynamicImagePtr di, BOOL show_errs)
{
struct Rectangle clip;
ILBMPtr ir;

    if (ir = ReadILBM(NULL,iffname,NULL))
    {
	SetRast(&(di->di_RPort),0);

        clip.MinX = 0;
        clip.MinY = 0;
        clip.MaxX = ir->ir_Width;
        clip.MaxY = ir->ir_Height;

        /* Find the upper left */
        FindTopLeft(&ir->ir_RPort,&clip,ICON_WIDTH,ICON_HEIGHT);

        /* Copy the image over */
        ClipBlit(&ir->ir_RPort, clip.MinX, clip.MinY,
                 &di->di_RPort, 0, 0,
		 clip.MaxX, clip.MaxY, VANILLA_COPY);

	FreeILBM(ir);
    }
    else
    {
	NotifyUser(MSG_IE_ERROR_READ_BRUSH,NULL);
    }

    return((BOOL)ir);
}


/*****************************************************************************/

d1324 1
a1324 8
BOOL SaveIFFBrush(WindowInfoPtr wi, STRPTR name, DynamicImagePtr di)
{
struct ILBM ir;

    FillInILBM(wi,di,&ir);
    if (WriteILBM(NULL,name,&ir,wi->w_SaveIcons))
    {
        return(TRUE);
d1326 12
a1337 14

    NotifyUser(MSG_IE_ERROR_SAVE_BRUSH,NULL);
    return(FALSE);
}


/*****************************************************************************/


BOOL SaveAsCFunc(WindowInfoPtr wi)
{
struct Window * wp;
UBYTE path[255], name[50];
struct TagItem tg[10];
d1357 1
a1357 1
	tg[4].ti_Tag  = ASL_LeftEdge;
d1359 1
a1359 1
	tg[5].ti_Tag  = ASL_TopEdge;
d1361 3
a1363 3
	tg[6].ti_Tag  = ASL_Width;
	tg[6].ti_Data = (ULONG) wi->Width;
	tg[7].ti_Tag  = ASL_Height;
d1366 3
a1368 3
	tg[0].ti_Tag  = ASL_Hail;
	tg[0].ti_Data = (ULONG) GetString(MSG_IE_SAVEFILE_TITLE);
	tg[1].ti_Tag  = ASL_FuncFlags;
d1370 3
a1372 3
	tg[2].ti_Tag  = ASL_OKText;
	tg[2].ti_Data = (ULONG) GetString(MSG_IE_SAVE_GAD);
	tg[3].ti_Tag  = ASL_Window;
d1374 1
a1374 1
	tg[8].ti_Tag  = ASL_Pattern;
d1376 1
a1376 1
	tg[9].ti_Tag  = TAG_DONE;
d1388 1
a1388 1
	    SaveIcon(wi,wi->w_Tmp, wi->diskobj, 2);
d1393 53
a1445 3
	wi->TopEdge  = wi->w_FR[FR_C]->rf_TopEdge - wp->TopEdge;
	wi->Width    = wi->w_FR[FR_C]->rf_Width;
	wi->Height   = wi->w_FR[FR_C]->rf_Height;
d1448 22
a1469 89
    return (FALSE);
}


/*****************************************************************************/


BOOL EraseFunc(WindowInfoPtr wi)
{
DynamicImagePtr di = &wi->images[wi->currentwin];

    if (!CheckForChanges(wi,MSG_IE_ERASEANDZAP,MSG_IE_ERASEANDZAP_GADS))
    {
        SPSaveToUndo(wi->wi_sketch);

        SetRast(&(di->di_RPort),0);
        RefreshImages(wi);
        SPRefresh(wi->wi_sketch);
        wi->clippable = FALSE;
    }
    return(FALSE);
}


/*****************************************************************************/


BOOL TemplateFunc(WindowInfoPtr wi)
{
DynamicImagePtr di = &wi->images[wi->currentwin];
extern struct Image template_data;

    if (!CheckForChanges(wi,MSG_IE_TEMPLATEANDZAP,MSG_IE_TEMPLATEANDZAP_GADS))
    {
        SPSaveToUndo(wi->wi_sketch);

        /* Clear the work area */
        SetRast(&(di->di_RPort),0);

        /* Draw the template */
        DrawImage(&(di->di_RPort), &template_data, 0, 0);

        /* Refresh the view */
        RefreshImages(wi);
        SPRefresh(wi->wi_sketch);

        wi->changed |= CH_MAJOR;
        wi->clippable = FALSE;
    }

    return(FALSE);
}


/*****************************************************************************/


void Recolor(struct Image *im)
{
USHORT *data;
LONG words, offset;
LONG count;
USHORT bits;
USHORT plane;
USHORT mask;
UBYTE value;

    if (im) if (im->Depth>0)
    {
        words = ((im->Width+15) >> 4) * im->Height;
        data  = im->ImageData;

        for (count=words; count>0; count--)
        {
            bits = 16;
            while (bits--)
            {
                mask    = 1L << bits;
                value   = 0;
                offset  = 0;

                for (plane=0; plane<im->Depth; plane++)
                {
                    if (data[offset] & mask)
                    {
                        value |= (1 << plane);
                    }
                    offset += words;
                }
d1471 4
a1474 1
		if (value == 2)
d1476 23
a1498 2
                    data[0]     |= mask;
                    data[words] &= ~mask;
d1500 3
a1502 9
		else if (value == 1)
		{
                    data[0]     &= ~mask;
                    data[words] |= mask;
		}
            }
            data++;
        }
    }
d1509 1
a1509 1
BOOL RecolorFunc(WindowInfoPtr wi)
d1511 2
a1512 1
    SPSaveToUndo(wi->wi_sketch);
d1515 2
a1516 2
    Recolor(&(wi->images[0].di_Image));
    Recolor(wi->diskobj->do_Gadget.GadgetRender);
d1519 2
a1520 2
    Recolor(&(wi->images[1].di_Image));
    Recolor(wi->diskobj->do_Gadget.SelectRender);
d1523 1
a1523 1
    RefreshImages(wi);
d1529 1
a1529 1
    SPRefresh(wi->wi_sketch);
d1531 1
a1531 1
    return(FALSE);
d1538 1
a1538 1
BOOL TopLeftFunc(WindowInfoPtr wi)
d1540 2
a1541 1
    SPSaveToUndo(wi->wi_sketch);
d1543 2
a1544 2
    AutoTopLeft(&(wi->images[wi->currentwin]));
    RefreshImages(wi);
d1550 1
a1550 1
    SPRefresh(wi->wi_sketch);
d1552 1
a1552 1
    return(FALSE);
d1559 1
a1559 1
BOOL PaletteFunc(WindowInfoPtr wi)
d1561 3
a1563 2
    System(wi->w_Palette,NULL);
    return(FALSE);
@


38.1
log
@Initial V38 RCS checkin
@
text
@d304 1
a304 1
		     (wi->w_LO + 77), wi->wintopx[wi->currentwin]);
d426 1
a426 1
			 (wi->w_LO + 77), wi->wintopx[wi->currentwin]);
d455 1
a455 1
		     (wi->w_LO + 77), wi->wintopx[wi->currentwin]);
d960 1
a960 1
		    SPSetRepeat(wi->wi_sketch,wi->Adi,(wi->w_LO + 77),wi->wintopx[i]);
d985 1
a985 1
	SPSetRepeat(wi->wi_sketch, wi->Adi,(wi->w_LO + 77),wi->wintopx[wi->currentwin]);
@
