head     39.17;
branch   ;
access   ;
symbols  ;
locks    davidj:39.17; strict;
comment  @ * @;


39.17
date     93.04.22.15.19.20;  author davidj;  state Exp;
branches ;
next     39.16;

39.16
date     93.04.14.14.52.21;  author davidj;  state Exp;
branches ;
next     39.15;

39.15
date     93.02.15.12.44.35;  author davidj;  state Exp;
branches ;
next     39.14;

39.14
date     92.12.02.13.40.05;  author davidj;  state Exp;
branches ;
next     39.13;

39.13
date     92.11.30.14.44.12;  author davidj;  state Exp;
branches ;
next     39.12;

39.12
date     92.10.28.14.46.14;  author davidj;  state Exp;
branches ;
next     39.11;

39.11
date     92.08.24.14.48.22;  author davidj;  state Exp;
branches ;
next     39.10;

39.10
date     92.08.13.11.31.12;  author davidj;  state Exp;
branches ;
next     39.9;

39.9
date     92.08.03.16.47.07;  author davidj;  state Exp;
branches ;
next     39.8;

39.8
date     92.07.28.15.02.02;  author davidj;  state Exp;
branches ;
next     39.7;

39.7
date     92.07.14.15.36.03;  author davidj;  state Exp;
branches ;
next     39.6;

39.6
date     92.07.01.00.45.42;  author davidj;  state Exp;
branches ;
next     39.5;

39.5
date     92.06.23.03.09.27;  author davidj;  state Exp;
branches ;
next     39.4;

39.4
date     92.06.22.03.57.55;  author davidj;  state Exp;
branches ;
next     39.3;

39.3
date     92.06.19.04.34.26;  author davidj;  state Exp;
branches ;
next     39.2;

39.2
date     92.06.05.04.34.51;  author davidj;  state Exp;
branches ;
next     39.1;

39.1
date     92.06.03.02.54.28;  author davidj;  state Exp;
branches ;
next     39.0;

39.0
date     92.06.02.08.52.16;  author davidj;  state Exp;
branches ;
next     ;


desc
@initial RCS
@


39.17
log
@wasn't freeing objects correctly
@
text
@/* windowclass.c
 * The purpose of the window class is to simplify the creation of a window with
 * horizontal and vertical scroll bars in the borders.  It doesn't handle any
 * gadget communication, except for the communication of the arrow buttons to
 * the sliders.
 *
 */

#include "multiview.h"

/*****************************************************************************/

#define	DB(x)	;
#define	DC(x)	;

/*****************************************************************************/

#define	WINDOWCLASS	"windowclass"

/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/

ULONG ASM dispatchModel (REG (a0) Class * cl, REG (a2) Object * o, REG (a1) Msg msg);
ULONG ASM dispatchWindow (REG (a0) Class * cl, REG (a2) Object * o, REG (a1) Msg msg);

/*****************************************************************************/

/* Window model data */
struct modelData
{
    LONG mod_TotVert;
    LONG mod_VisVert;
    LONG mod_TopVert;

    LONG mod_TotHoriz;
    LONG mod_VisHoriz;
    LONG mod_TopHoriz;

    ULONG mod_ID;
};

/*****************************************************************************/

static Tag model_attrs[] =
{
    DTA_Sync,
    WOA_Sync,

    WOA_TopVert,
    WOA_VisibleVert,
    WOA_TotalVert,

    WOA_TopHoriz,
    WOA_VisibleHoriz,
    WOA_TotalHoriz,

    ICA_TARGET,
    ICA_MAP,

    TAG_DONE,
};

/*****************************************************************************/

struct TagItem leftm_map[] =
{
    {GA_ID,	WOA_DecHoriz},
    {TAG_DONE,},
};

struct TagItem upm_map[] =
{
    {GA_ID,	WOA_DecVert},
    {TAG_DONE,},
};

struct TagItem rightm_map[] =
{
    {GA_ID,	WOA_IncHoriz},
    {TAG_DONE,},
};

struct TagItem downm_map[] =
{
    {GA_ID,	WOA_IncVert},
    {TAG_DONE,},
};

struct TagItem *model_map[] =
{
    leftm_map,
    upm_map,
    rightm_map,
    downm_map,
};

/*****************************************************************************/

struct TagItem vg_map[] =
{
    {PGA_Top,		WOA_TopVert},
    {PGA_Visible,	WOA_VisibleVert},
    {PGA_Total,		WOA_TotalVert},
    {TAG_DONE,},
};

struct TagItem hg_map[] =
{
    {PGA_Top,		WOA_TopHoriz},
    {PGA_Visible,	WOA_VisibleHoriz},
    {PGA_Total,		WOA_TotalHoriz},
    {TAG_DONE,},
};

/*****************************************************************************/

struct TagItem vm_map[] =
{
    {WOA_TopVert,	PGA_Top},
    {WOA_VisibleVert,	PGA_Visible},
    {WOA_TotalVert,	PGA_Total},
    {TAG_DONE,},
};

struct TagItem hm_map[] =
{
    {WOA_TopHoriz,	PGA_Top},
    {WOA_VisibleHoriz,	PGA_Visible},
    {WOA_TotalHoriz,	PGA_Total},
    {TAG_DONE,},
};

/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/

static struct TagItem prop_tags[] =
{
    {GA_RelVerify,	TRUE},
    {GA_Immediate,	TRUE},
    {GA_FollowMouse,	TRUE},
    {PGA_Total,		1},
    {PGA_Visible,	1},
    {PGA_Top,		0},
    {PGA_NewLook,	TRUE},
    {TAG_DONE,},
};

/*****************************************************************************/

Class *initWindowClass (struct GlobalData * gd)
{
    Class *mcl, *cl;

    /* Create the window model class */
    if (mcl = MakeClass (NULL, MODELCLASS, NULL, sizeof (struct modelData), 0))
    {
	/* Initialize the window model class */
	mcl->cl_Dispatcher.h_Entry = (ULONG (*)()) dispatchModel;
	mcl->cl_UserData           = (ULONG) gd;

	/* Create the window class */
	if (cl = MakeClass (NULL, GADGETCLASS, NULL, NULL, 0L))
	{
	    /* Initialize the window class */
	    cl->cl_Dispatcher.h_Entry = (ULONG (*)()) dispatchWindow;
	    cl->cl_Dispatcher.h_Data  = mcl;
	    cl->cl_UserData           = (ULONG) gd;
	    return (cl);
	}
	FreeClass (mcl);
    }

    return (NULL);
}

/*****************************************************************************/

ULONG freeWindowClass (Class * cl)
{
    struct GlobalData *gd = (struct GlobalData *) cl->cl_UserData;
    Class *mcl = (Class *) cl->cl_Dispatcher.h_Data;

    /* Free the window class */
    if (FreeClass (cl))
    {
	/* Free the window model class */
	return (ULONG) FreeClass (mcl);
    }
    return (0);
}

/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/

static ULONG notifyChanges (struct GlobalData * gd, Object * o, VOID * ginfo, ULONG flags, ULONG tag1,...)
{
    return DoMethod (o, OM_NOTIFY, &tag1, ginfo, flags);
}

/*****************************************************************************/

static ULONG setModelAttrs (struct GlobalData * gd, Class * cl, Object * o, struct opSet * msg)
{
    struct modelData *mod = INST_DATA (cl, o);
    struct TagItem *tags = msg->ops_AttrList;
    struct TagItem *tstate;
    struct TagItem *tag;
    ULONG retval = 0L;
    LONG newHoriz;
    ULONG tidata;
    LONG newVert;

    /* start with original value */
    newHoriz = mod->mod_TopHoriz;
    newVert = mod->mod_TopVert;

    /* Process tags */
    tstate = tags;
    while (tag = NextTagItem (&tstate))
    {
	tidata = tag->ti_Data;

	switch (tag->ti_Tag)
	{
/*	    case WOA_Sync: */
	    case DTA_Sync:
		retval = 1L;
		break;

	    case WOA_TotalVert:
		if (mod->mod_TotVert != tidata)
		{
		    mod->mod_TotVert = tidata;
		    retval = 1L;
		}
		break;

	    case WOA_VisibleVert:
		if (mod->mod_VisVert != tidata)
		{
		    mod->mod_VisVert = tidata;
		    retval = 1L;
		}
		break;

	    case WOA_TopVert:
		newVert = tidata;
		break;

	    case WOA_DecVert:
		newVert--;
		break;

	    case WOA_IncVert:
		newVert++;
		break;

	    case WOA_TotalHoriz:
		if (mod->mod_TotHoriz != tidata)
		{
		    mod->mod_TotHoriz = tidata;
		    retval = 1L;
		}
		break;

	    case WOA_VisibleHoriz:
		if (mod->mod_VisHoriz != tidata)
		{
		    mod->mod_VisHoriz = tidata;
		    retval = 1L;
		}
		break;

	    case WOA_TopHoriz:
		newHoriz = tidata;
		break;

	    case WOA_DecHoriz:
		newHoriz--;
		break;

	    case WOA_IncHoriz:
		newHoriz++;
		break;
	}
    }

    /* VERTICAL Validity check */
    if (mod->mod_VisVert <= 0)
    {
	mod->mod_VisVert = 1;
	retval = 1L;
    }
    if (mod->mod_TotVert <= 0)
    {
	mod->mod_TotVert = 1;
	retval = 1L;
    }
    if (newVert > (mod->mod_TotVert - mod->mod_VisVert))
	newVert = mod->mod_TotVert - mod->mod_VisVert;
    if (newVert < 0)
	newVert = 0;
    if (mod->mod_TopVert != newVert)
    {
	mod->mod_TopVert = newVert;
	retval = 1L;
    }

    /* HORIZONTAL Validity check */
    if (mod->mod_VisHoriz <= 0)
    {
	mod->mod_VisHoriz = 1;
	retval = 1L;
    }
    if (mod->mod_TotHoriz <= 0)
    {
	mod->mod_TotHoriz = 1;
	retval = 1L;
    }
    if (newHoriz > (mod->mod_TotHoriz - mod->mod_VisHoriz))
	newHoriz = mod->mod_TotHoriz - mod->mod_VisHoriz;
    if (newHoriz < 0)
	newHoriz = 0;
    if (mod->mod_TopHoriz != newHoriz)
    {
	mod->mod_TopHoriz = newHoriz;
	retval = 1L;
    }

    return (retval);
}

/*****************************************************************************/

static ULONG getModelAttr (Class * cl, Object * o, struct opGet * msg)
{
    struct modelData *mod = INST_DATA (cl, o);
    ULONG retval = 1L;

    switch (msg->opg_AttrID)
    {
	case WOA_TopVert:
	    *msg->opg_Storage = mod->mod_TopVert;
	    break;

	case WOA_VisibleVert:
	    *msg->opg_Storage = mod->mod_VisVert;
	    break;

	case WOA_TotalVert:
	    *msg->opg_Storage = mod->mod_TotVert;
	    break;

	case WOA_TopHoriz:
	    *msg->opg_Storage = mod->mod_TopHoriz;
	    break;

	case WOA_VisibleHoriz:
	    *msg->opg_Storage = mod->mod_VisHoriz;
	    break;

	case WOA_TotalHoriz:
	    *msg->opg_Storage = mod->mod_TotHoriz;
	    break;

	default:
	    /* I don't recognize this one, let the superclass try */
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    break;
    }

    return (retval);
}

/*****************************************************************************/

ULONG ASM dispatchModel (REG (a0) Class * cl, REG (a2) Object * o, REG (a1) Msg msg)
{
    struct GlobalData *gd = (struct GlobalData *) cl->cl_UserData;
    struct modelData *mod = INST_DATA (cl, o);
    struct opSet *ops = (struct opSet *) msg;
    ULONG retval = 0L;
    Object *newobj;

    switch (msg->MethodID)
    {
	case OM_NEW:
	    /* Have the superclass create the object */
	    if (newobj = (Object *) DoSuperMethodA (cl, o, msg))
	    {
		/* Get the local object data */
		mod = INST_DATA (cl, newobj);

		/* Get the gadget ID */
		mod->mod_ID = GetTagData (GA_ID, NULL, ops->ops_AttrList);

		/* Initialize instance data */
		setModelAttrs (gd, cl, newobj, ops);
	    }
	    retval = (ULONG) newobj;
	    break;

	case OM_GET:
	    retval = (ULONG) getModelAttr (cl, o, (struct opGet *) msg);
	    break;

	case OM_SET:
	case OM_UPDATE:
	    if (!DoSuperMethod (cl, o, ICM_CHECKLOOP))
	    {
		ULONG topvt = DTA_TopVert, otopv = mod->mod_TopVert;
		ULONG visvt = DTA_VisibleVert, ovisv = mod->mod_VisVert;
		ULONG totvt = DTA_TotalVert, ototv = mod->mod_TotVert;
		ULONG topht = DTA_TopHoriz, otoph = mod->mod_TopHoriz;
		ULONG visht = DTA_VisibleHoriz, ovish = mod->mod_VisHoriz;
		ULONG totht = DTA_TotalHoriz, ototh = mod->mod_TotHoriz;
		ULONG nmflag = 0L;

		/* Let the superclass see whatever it wants from OM_SET, such as ICA_TARGET, ICA_MAP, and so on.
		 * For OM_NOTIFY, however, we control all traffic and issue notification specifically for the
		 * attributes we're interested in. */
		if (msg->MethodID == OM_SET)
		    DoSuperMethodA (cl, o, msg);
		else
		    /* these flags aren't present in the message of OM_SET	 */
		    nmflag = ((struct opUpdate *) msg)->opu_Flags;

		/* change 'em, only if changed (or if a "non-interim" message. */
		if ((retval = setModelAttrs (gd, cl, o, ops)) || !(nmflag & OPUF_INTERIM))
		{
		    if (!(FindTagItem (DTA_Sync, ops->ops_AttrList) || FindTagItem (WOA_Sync, ops->ops_AttrList)))
		    {
			if (otopv == mod->mod_TopVert)
			    topvt = TAG_IGNORE;
			if (ovisv == mod->mod_VisVert)
			    visvt = TAG_IGNORE;
			if (ototv == mod->mod_TotVert)
			    totvt = TAG_IGNORE;
			if (otoph == mod->mod_TopHoriz)
			    topht = TAG_IGNORE;
			if (ovish == mod->mod_VisHoriz)
			    visht = TAG_IGNORE;
			if (ototh == mod->mod_TotHoriz)
			    totht = TAG_IGNORE;
		    }

		    /* Pass along GInfo, if any, so gadgets can redraw themselves.
		     *  Pass along opu_Flags, so that the application will know the
		     * difference between and interim message and a final message */
		    notifyChanges (gd, o, ops->ops_GInfo, (nmflag & OPUF_INTERIM),
				   GA_ID, mod->mod_ID,
				   topvt, mod->mod_TopVert,
				   visvt, mod->mod_VisVert,
				   totvt, mod->mod_TotVert,
				   topht, mod->mod_TopHoriz,
				   visht, mod->mod_VisHoriz,
				   totht, mod->mod_TotHoriz,
				   TAG_END);
		}
	    }
	    break;

	default:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    break;
    }

    return (retval);
}

/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/

BOOL initWindowObject (struct GlobalData * gd, Class * cl, Object * o, struct opSet * msg)
{
    struct TagItem *attrs = msg->ops_AttrList;
    struct Gadget *prev = NULL;
    BOOL success = FALSE;
    ULONG backdrop;
    LONG backfill;
    STRPTR title;
    Object *ic;
    ULONG top;
    WORD i;

    struct IBox ac[] =
    {
	{-49, -9, 16, 10},	/* Left */
	{-17, -31, 18, 10},	/* Up */
	{-33, -9, 16, 10},	/* Right */
	{-17, -20, 18, 10},	/* Down */
    };

    WORD relw, relh;

    /* Initialize the list */
    NewList ((struct List *) & gd->gd_List);

    backdrop = GetTagData (WOA_Backdrop, FALSE, attrs);
    title = (STRPTR) GetTagData (DTA_Title, NULL, attrs);
    gd->gd_WinFlags = GetTagData (WOA_Flags, NULL, attrs);

    if (gd->gd_Screen && gd->gd_DrawInfo)
    {
	/* Create the glue to hook all the objects together */
	if (!(gd->gd_Model = newobject (gd, (Class *) cl->cl_Dispatcher.h_Data, NULL, TAG_DONE)))
	    return (FALSE);

	/* Are we supposed to be a backdrop */
	if (backdrop)
	{
	    top = (gd->gd_WinFlags & WOAF_BACKDROP) ? (gd->gd_Screen->BarHeight + 1) : 0;
	    backfill = (LONG) ((gd->gd_WinFlags & WOAF_BITMAP) ? LAYERS_NOBACKFILL : LAYERS_BACKFILL);
	    if (gd->gd_Window = openwindowtags (gd,
						WA_Left,		0,
						WA_Top,			top,
						WA_Width,		gd->gd_Screen->Width,
						WA_Height,		gd->gd_Screen->Height - top,
						WA_SimpleRefresh,	TRUE,
						WA_NoCareRefresh,	TRUE,
						WA_Activate,		TRUE,
						WA_BusyPointer,		TRUE,
						WA_NewLookMenus,	TRUE,
						WA_Backdrop,		TRUE,
						WA_Borderless,		TRUE,
						WA_RMBTrap,		TRUE,
						WA_BackFill,		backfill,
						TAG_MORE, attrs))
	    {
		if (!(gd->gd_WinFlags & WOAF_BACKDROP))
		{
		    gd->gd_Window->RPort->Layer->Flags &= ~LAYERSIMPLE;
		    gd->gd_Window->RPort->Layer->Flags |= LAYERSMART;

		    gd->gd_Window->Flags &= ~WFLG_SIMPLE_REFRESH;
		}

/*		gd->gd_Window->Flags &= ~WFLG_RMBTRAP; */
		success = TRUE;
	    }
	}
	else
	{
	    /* Create the arrow imagry */
	    success = TRUE;
	    for (i = 0; (i < NUM_ARROWS) && success; i++)
	    {
		if (gd->gd_ArrowImg[i] = newobject (gd, NULL, "sysiclass",
						    SYSIA_DrawInfo, gd->gd_DrawInfo,
						    SYSIA_Which, LEFTIMAGE + i,
						    TAG_DONE))
		{
		    if (i % 2)
			/* ODD */
			ac[i].Left = -(gd->gd_ArrowImg[i]->Width - 1);
		    else
			/* EVEN */
			ac[i].Top = -(gd->gd_ArrowImg[i]->Height - 1);
		    ac[i].Width = gd->gd_ArrowImg[i]->Width;
		    ac[i].Height = gd->gd_ArrowImg[i]->Height;
		}
		else
		    success = FALSE;
	    }

	    /* Create the arrow buttons */
	    if (success)
	    {
		/* Fix the positioning of the horizontal buttons */
		ac[2].Left = -(ac[1].Width + ac[2].Width - 1);
		ac[0].Left = ac[2].Left - ac[0].Width;
		relw = -(gd->gd_Screen->WBorLeft + ac[0].Width + ac[2].Width + ac[1].Width);

		/* Fix the positioning of the vertical buttons */
		ac[3].Top = -(ac[2].Height + ac[3].Height - 1);
		ac[1].Top = ac[3].Top - ac[1].Height;
		relh = -(gd->gd_Screen->BarHeight + ac[1].Height + ac[3].Height + ac[0].Height + 3);

		for (i = 0; (i < NUM_ARROWS) && success; i++)
		{
		    if (prev = newobject (gd, NULL, "buttongclass",
					  GA_RelRight, (ULONG) ac[i].Left,
					  GA_RelBottom, (ULONG) ac[i].Top,
					  GA_Width, (ULONG) ac[i].Width,
					  GA_Height, (ULONG) ac[i].Height,
					  GA_Image, gd->gd_ArrowImg[i],
					  GA_ID, (ULONG) (LEFT_GID + i),
					  GA_Immediate, TRUE,
					  GA_RelVerify, TRUE,
					  ((prev) ? GA_Previous : TAG_IGNORE), prev,
					  ICA_TARGET, gd->gd_Model,
					  ICA_MAP, model_map[i],
					  TAG_DONE))
		    {
			if (!gd->gd_First)
			    gd->gd_First = prev;
			DoMethod (o, OM_ADDMEMBER, (LONG) prev);
		    }
		    else
			success = FALSE;
		}
	    }

	    if (success)
	    {
		success = FALSE;

		/* Horizontal prop gadget */
		if (prev = gd->gd_HGad = newobject (gd, NULL, "propgclass",
						    GA_Left, gd->gd_Screen->WBorLeft - 1,
						    GA_RelBottom, (LONG) (ac[0].Top + 2),
						    GA_RelWidth, (LONG) relw,
						    GA_Height, (LONG) (ac[0].Height - 4),
						    GA_Previous, prev,
						    GA_BottomBorder, TRUE,
						    GA_ID, HORIZ_GID,
						    PGA_Freedom, FREEHORIZ,
						    PGA_Borderless, ((gd->gd_Screen->BitMap.Depth == 1) ? FALSE : TRUE),
						    ICA_TARGET, gd->gd_Model,
						    ICA_MAP, hg_map,
						    TAG_MORE, prop_tags))
		{
		    /* Add the object to the list */
		    DoMethod (o, OM_ADDMEMBER, (LONG) prev);
		    if (ic = newobject (gd, NULL, ICCLASS, ICA_TARGET, prev, ICA_MAP, hm_map, TAG_DONE))
			DoMethod (gd->gd_Model, OM_ADDMEMBER, (LONG) ic);

		    /* Vertical prop gadget */
		    if (prev = gd->gd_VGad = newobject (gd, NULL, "propgclass",
							GA_RelRight, (LONG) (ac[1].Left + 4),
							GA_Top, gd->gd_Screen->BarHeight + 2,
							GA_Width, (LONG) (ac[1].Width - 8),
							GA_RelHeight, (LONG) relh,
							GA_Previous, prev,
							GA_RightBorder, TRUE,
							GA_ID, VERT_GID,
							PGA_Freedom, FREEVERT,
							PGA_Borderless, ((gd->gd_Screen->BitMap.Depth == 1) ? FALSE : TRUE),
							ICA_TARGET, gd->gd_Model,
							ICA_MAP, vg_map,
							TAG_MORE, prop_tags))
		    {
			/* Add the object to the list */
			DoMethod (o, OM_ADDMEMBER, (LONG) prev);
			if (ic = newobject (gd, NULL, ICCLASS, ICA_TARGET, prev, ICA_MAP, vm_map, TAG_DONE))
			    DoMethod (gd->gd_Model, OM_ADDMEMBER, (LONG) ic);

			if (gd->gd_Window = openwindowtags (gd,
							    WA_AutoAdjust,	TRUE,
							    WA_CloseGadget,	TRUE,
							    WA_DepthGadget,	TRUE,
							    WA_DragBar,		TRUE,
							    WA_SizeGadget,	TRUE,
							    WA_SizeBRight,	TRUE,
							    WA_SizeBBottom,	TRUE,
							    WA_SimpleRefresh,	TRUE,
							    WA_NoCareRefresh,	TRUE,
							    WA_Activate,	TRUE,
							    WA_BusyPointer,	TRUE,
							    WA_MinWidth,	80L,
							    WA_MinHeight,	gd->gd_Screen->BarHeight + 38,
							    WA_MaxWidth,	-1L,
							    WA_MaxHeight,	-1L,
							    WA_Gadgets,		gd->gd_First,
							    WA_NewLookMenus,	TRUE,
							    WA_Title,		title,
							    TAG_MORE, attrs))
			{
			    success = TRUE;
			}
		    }
		}
	    }
	}

	if (success)
	{
	    /* Set the window pointer */
	    gd->gd_OldWinPtr = gd->gd_Process->pr_WindowPtr;
	    gd->gd_Process->pr_WindowPtr = gd->gd_Window;

	    /* Make it share the IDCMP port */
	    gd->gd_Window->UserPort = gd->gd_IDCMPPort;
	    ModifyIDCMP (gd->gd_Window, IDCMP_FLAGS);

	    /* Add the menus to the window */
	    if (gd->gd_Menu = localizemenus (gd, newmenu))
	    {
		NoObjectLoaded (gd);

		if (backdrop)
		{
		    BackdropMenus (gd);
		}

		SetMenuStrip (gd->gd_Window, gd->gd_Menu);
	    }

	    if (gd->gd_AWPort)
		gd->gd_AppWindow = AddAppWindowA (0, (ULONG) gd, gd->gd_Window, gd->gd_AWPort, NULL);
	}
    }

    return (success);
}

/*****************************************************************************/

ULONG setWindowClassAttrs (struct GlobalData * gd, Class * cl, Object * o, struct opSet * msg)
{
    struct TagItem *tags = msg->ops_AttrList;
    struct TagItem *origtags;
    struct TagItem *tstate;
    struct TagItem *tag;
    ULONG retval = 0;

    /* Set aside the tags so that we can properly send them out */
    origtags = msg->ops_AttrList;
    msg->ops_AttrList = CloneTagItems (origtags);

    /* Handle model attributes first */
    if (FilterTagItems (msg->ops_AttrList, model_attrs, TAGFILTER_AND))
    {
	if (msg->MethodID == OM_NEW)
	    retval = DoMethod (gd->gd_Model, OM_SET, (LONG) msg->ops_AttrList, (LONG) msg->ops_GInfo);
	else
	    retval = DoMethodA (gd->gd_Model, msg);
    }

    /* If this isn't a new, then pass along the attributes */
    if (msg->MethodID != OM_NEW)
    {
	/* re-clone, without re-allocating */
	RefreshTagItemClones (msg->ops_AttrList, origtags);
	if (FilterTagItems (msg->ops_AttrList, model_attrs, TAGFILTER_NOT))
	    DoMethod (o, OM_NOTIFY, msg->ops_AttrList, msg->ops_GInfo, NULL);
    }

    /* free clone and restore original */
    FreeTagItems (msg->ops_AttrList);
    msg->ops_AttrList = origtags;

    /* Process rest */
    tstate = tags;
    while (tag = NextTagItem (&tstate))
    {
	switch (tag->ti_Tag)
	{
	    case DTA_Sync:
		syncMenuItems (gd, cl, o);
		break;
	}
    }
    return (retval);
}

/*****************************************************************************/

ULONG getWindowAttr (struct GlobalData *gd, Class * cl, Object * o, struct opGet * msg)
{
    ULONG retval = 1L;

    /* See if it belongs to the model */
    if (TagInArray (msg->opg_AttrID, model_attrs))
	return (DoMethodA (gd->gd_Model, msg));

    /* It might belong to us */
    switch (msg->opg_AttrID)
    {
	case WOA_Window:
	    *msg->opg_Storage = (ULONG) gd->gd_Window;
	    break;

	default:
	    /* I don't recognize this one, let the superclass try */
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    break;
    }

    return (retval);
}
/*****************************************************************************/

ULONG ASM dispatchWindow (REG (a0) Class * cl, REG (a2) Object * o, REG (a1) Msg msg)
{
    struct GlobalData *gd = (struct GlobalData *) cl->cl_UserData;
    ULONG retval = 0L;
    Object *ostate;
    Object *member;
    Object *newobj;
    WORD i;

    switch (msg->MethodID)
    {
	case OM_NEW:
	    if (newobj = (Object *) DoSuperMethodA (cl, o, msg))
	    {
		DB (kprintf ("init window\n"));
		if (initWindowObject (gd, cl, newobj, (struct opSet *) msg))
		{
		    DB (kprintf ("set window attrs\n"));
		    setWindowClassAttrs (gd, cl, newobj, (struct opSet *) msg);
		}
		else
		{
		    CoerceMethod (cl, newobj, OM_DISPOSE);
		    newobj = NULL;
		}
	    }
	    DB (kprintf ("done initing window\n"));
	    retval = (ULONG) newobj;
	    break;

	case WOM_ADDVIEW:
	    {
		struct Window *win = gd->gd_Window;
		ULONG left, top, width, height;
		Tag wt, ht;

		if (win->Flags & WFLG_BACKDROP)
		{
		    left = 0;
		    top = 0;
		    width = win->Width;
		    height = win->Height;
		    wt = GA_Width;
		    ht = GA_Height;
		}
		else
		{
		    left = win->BorderLeft + 2;
		    top = win->BorderTop + 1;
		    width = -(win->BorderLeft + win->BorderRight + 4);
		    height = -(win->BorderTop + win->BorderBottom + 2);
		    wt = GA_RelWidth;
		    ht = GA_RelHeight;
		}

		/* Create an IC, connecting it to the DataType object */
		DoMethod (o, OM_ADDMEMBER, (LONG) gd->gd_DataObject);

		DC (kprintf ("new ic\n"));
		if (gd->gd_IC = newobject (gd, NULL, ICCLASS, ICA_TARGET, (ULONG) gd->gd_DataObject, TAG_DONE))
		{
		    DC (kprintf ("add member\n"));
		    DoMethod (gd->gd_Model, OM_ADDMEMBER, (LONG) gd->gd_IC);

		    DC (kprintf ("set dtobject attrs\n"));
		    setattrs (gd, (Object *) gd->gd_DataObject,
				  GA_Left, left,
				  GA_Top, top,
				  wt, width,
				  ht, height,
				  ICA_TARGET, o,
				  TAG_DONE);
		    DC (kprintf ("add dtobject\n"));
		    AddDTObject (gd->gd_Window, NULL, gd->gd_DataObject, -1);

		    DC (kprintf ("sync menus\n"));
		    syncMenuItems (gd, cl, o);

		    DC (kprintf ("object added\n"));
		}
	    }
	    break;

	case WOM_REMVIEW:
	    if (gd->gd_DataObject)
	    {
		/* Remove the object from the window */
		RemoveDTObject (gd->gd_Window, gd->gd_DataObject);

		/* Remove the object from the model */
		DoMethod (o, OM_REMMEMBER, (LONG) gd->gd_DataObject);
		DoMethod (gd->gd_Model, OM_REMMEMBER, (LONG) gd->gd_IC);
		DoMethod (gd->gd_IC, OM_DISPOSE);
		gd->gd_IC = NULL;

		NoObjectLoaded (gd);
	    }
	    break;

	case OM_UPDATE:
	case OM_SET:
	    return (setWindowClassAttrs (gd, cl, o, (struct opSet *) msg));
	    break;

	case OM_GET:
	    return (getWindowAttr (gd, cl, o, (struct opGet *) msg));

	case OM_ADDMEMBER:
	    member = ((struct opAddMember *) msg)->opam_Object;
	    DoMethod (member, OM_ADDTAIL, &gd->gd_List);
	    break;

	case OM_REMMEMBER:
	    member = ((struct opAddMember *) msg)->opam_Object;
	    DoMethod (member, OM_REMOVE, &gd->gd_List);
	    break;

	case OM_DISPOSE:
	    /* Clear the menu */
	    if (gd->gd_Menu)
	    {
		ClearMenuStrip (gd->gd_Window);
		FreeMenus (gd->gd_Menu);
		gd->gd_Menu = NULL;
	    }

	    /* Remove the AppWindow */
	    if (gd->gd_AppWindow)
		RemoveAppWindow (gd->gd_AppWindow);
	    gd->gd_AppWindow = NULL;

	    /* Close the window */
	    if (gd->gd_Window)
	    {
		/* Restore the window pointer */
		gd->gd_Process->pr_WindowPtr = gd->gd_OldWinPtr;
		CloseWindowSafely (gd, gd->gd_Window);
		gd->gd_Window = NULL;
	    }

	    /* Delete all the objects that were attached to use */
	    ostate = (Object *) gd->gd_List.mlh_Head;
	    while (member = NextObject (&ostate))
	    {
		DoMethod (member, OM_REMOVE);
		DoMethodA (member, msg);
	    }

	    /* Get rid of the arrow images */
	    for (i = 0; i < NUM_ARROWS; i++)
	    {
		if (gd->gd_ArrowImg[i])
		    DisposeObject (gd->gd_ArrowImg[i]);
		gd->gd_ArrowImg[i] = NULL;
	    }

	    /* Dispose of the model */
	    DisposeObject (gd->gd_Model);

	    gd->gd_HGad = gd->gd_VGad = NULL;
	    gd->gd_First = NULL;
	    gd->gd_Model = NULL;

	    /* Let the superclass handle everything else */
	default:
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    break;
    }

    return (retval);
}
@


39.16
log
@sets RMBTRAP until screen to front.
@
text
@d160 2
a161 2
	mcl->cl_Dispatcher.h_Entry = dispatchModel;
	mcl->cl_UserData = (ULONG) gd;
d167 3
a169 3
	    cl->cl_Dispatcher.h_Entry = dispatchWindow;
	    cl->cl_Dispatcher.h_Data = mcl;
	    cl->cl_UserData = (ULONG) gd;
d174 1
d185 6
a190 4
    /* Free the window model class */
    if (FreeClass (mcl))
	/* Free the window class */
	return ((ULONG) FreeClass (cl));
a719 1
    ULONG tidata;
d943 4
@


39.15
log
@reimplemented model class
@
text
@d335 1
a335 1
static ULONG getModelAttr (struct GlobalData * gd, Class * cl, Object * o, struct opGet * msg)
d404 1
a404 1
	    retval = (ULONG) getModelAttr (gd, cl, o, (struct opGet *) msg);
d447 3
a449 3
		    /*
		     * Pass along GInfo, if any, so gadgets can redraw themselves.  Pass along opu_Flags, so that the application will know the difference between and interim message and a final message
		     */
d516 13
a528 12
						WA_Left, 0,
						WA_Top, top,
						WA_Width, gd->gd_Screen->Width,
						WA_Height, gd->gd_Screen->Height - top,
						WA_SimpleRefresh, TRUE,
						WA_NoCareRefresh, TRUE,
						WA_Activate, TRUE,
						WA_BusyPointer, TRUE,
						WA_NewLookMenus, TRUE,
						WA_Backdrop, TRUE,
						WA_Borderless, TRUE,
						WA_BackFill, backfill,
d538 2
d650 18
a667 18
							    WA_AutoAdjust, TRUE,
							    WA_CloseGadget, TRUE,
							    WA_DepthGadget, TRUE,
							    WA_DragBar, TRUE,
							    WA_SizeGadget, TRUE,
							    WA_SizeBRight, TRUE,
							    WA_SizeBBottom, TRUE,
							    WA_SimpleRefresh, TRUE,
							    WA_NoCareRefresh, TRUE,
							    WA_Activate, TRUE,
							    WA_BusyPointer, TRUE,
							    WA_MinWidth, 80L,
							    WA_MinHeight, gd->gd_Screen->BarHeight + 38,
							    WA_MaxWidth, -1L,
							    WA_MaxHeight, -1L,
							    WA_Gadgets, gd->gd_First,
							    WA_NewLookMenus, TRUE,
							    WA_Title, title,
a748 1
	tidata = tag->ti_Data;
a750 10
#if 0
	    case WOA_Title:
		if (tidata)
		    strcpy (gd->gd_Title, (STRPTR) tidata);
		else
		    gd->gd_Title[0] = 0;
		SetWindowTitles (gd->gd_Window, gd->gd_Title, ((UBYTE *) (~0)));
		break;
#endif

a751 1
/*	    case WOA_Sync: */
@


39.14
log
@added WA_NoCareRefresh tag to window with scrollers.
@
text
@d14 1
a14 2
#define	DT(x)	;
#define	DR(x)	;
d21 104
d126 1
a126 1
static struct IBox ac[] =
d128 4
a131 4
    {-49, -9, 16, 10},		/* Left */
    {-17, -31, 18, 10},		/* Up */
    {-33, -9, 16, 10},		/* Right */
    {-17, -20, 18, 10},		/* Down */
d135 2
a151 147
struct EdMenu
{
    UBYTE	 em_Type;		/* NM_XXX from gadtools.h */
    LONG	 em_Label;
    ULONG	 em_Command;
    UWORD	 em_ItemFlags;
};

/*****************************************************************************/

struct EdMenu newmenu[] =
{
    {NM_TITLE, MV_MENU_PROJECT, MMC_NOP, 0},
    {NM_ITEM, MV_ITEM_OPEN, MMC_OPEN, 0},
    {NM_ITEM, MSG_NOTHING, MMC_NOP, 0},
    {NM_ITEM, MV_ITEM_SAVE_AS, MMC_SAVEAS, 0},
    {NM_ITEM, MSG_NOTHING, MMC_NOP, 0},
    {NM_ITEM, MV_ITEM_PRINT, MMC_PRINT, 0},
    {NM_ITEM, MV_ITEM_ABOUT, MMC_ABOUT, 0},
    {NM_ITEM, MSG_NOTHING, MMC_NOP, 0},
    {NM_ITEM, MV_ITEM_QUIT, MMC_QUIT, 0},

    {NM_TITLE, MV_MENU_EDIT, MMC_NOP, 0},
    {NM_ITEM, MV_ITEM_MARK, MMC_MARK, 0},
    {NM_ITEM, MV_ITEM_COPY, MMC_COPY, 0},
    {NM_ITEM, MSG_NOTHING, MMC_NOP, 0},
    {NM_ITEM, MV_ITEM_SELECT_ALL, MMC_SELECTALL, 0},
    {NM_ITEM, MV_ITEM_CLEAR_SELECTED, MMC_CLEARSELECTED, 0},

    {NM_TITLE, MV_MENU_WINDOW, MMC_NOP, 0},
    {NM_ITEM, MV_ITEM_MINIMIZE, MMC_MINIMIZE, 0},
    {NM_ITEM, MV_ITEM_NORMAL, MMC_NORMAL, 0},
    {NM_ITEM, MV_ITEM_MAXIMIZE, MMC_MAXIMIZE, 0},

    {NM_TITLE, MV_MENU_SETTINGS, MMC_NOP, 0},
    {NM_ITEM, MV_ITEM_SAVE_AS_DEFAULTS, MMC_SAVE_AS_DEFAULTS, 0},

    {NM_END, MSG_NOTHING, MMC_NOP, 0},
};

/*****************************************************************************/

BOOL SetMenuItemState (struct GlobalData * gd, ULONG command, BOOL state)
{
    struct MenuItem *mi;
    struct Menu *m;

    if (m = gd->gd_Menu)
    {
	while (m)
	{
	    mi = m->FirstItem;
	    while (mi)
	    {
		if (((ULONG) GTMENUITEM_USERDATA (mi)) == command)
		{
		    if (state)
			mi->Flags |= ITEMENABLED;
		    else
			mi->Flags &= ~ITEMENABLED;
		    return (TRUE);
		}
		mi = mi->NextItem;
	    }
	    m = m->NextMenu;
	}
    }
    return (FALSE);
}

/*****************************************************************************/

void NoObjectLoaded (struct GlobalData * gd)
{

    SetMenuItemState (gd, MMC_SAVEAS, FALSE);
    SetMenuItemState (gd, MMC_PRINT, FALSE);
    SetMenuItemState (gd, MMC_MARK, FALSE);
    SetMenuItemState (gd, MMC_COPY, FALSE);
    SetMenuItemState (gd, MMC_SELECTALL, FALSE);
    SetMenuItemState (gd, MMC_CLEARSELECTED, FALSE);
    SetMenuItemState (gd, MMC_FIND, FALSE);
    SetMenuItemState (gd, MMC_NEXT, FALSE);
    SetMenuItemState (gd, MMC_GOTO, FALSE);
    SetMenuItemState (gd, MMC_SETBOOKMARK, FALSE);
    SetMenuItemState (gd, MMC_GOTOBOOKMARK, FALSE);
    SetMenuItemState (gd, MMC_EXECUTE, FALSE);
}

/*****************************************************************************/

struct Menu *localizemenus (struct GlobalData * gd, struct EdMenu * em)
{
    struct NewMenu *nm;
    struct Menu *menus;
    UWORD i;

    i = 0;
    while (em[i++].em_Type != NM_END)
    {
    }

    if (!(nm = AllocVec (sizeof (struct NewMenu) * i, MEMF_CLEAR | MEMF_PUBLIC)))
	return (NULL);

    while (i--)
    {
	nm[i].nm_Type = em[i].em_Type;
	nm[i].nm_Flags = em[i].em_ItemFlags;
	nm[i].nm_UserData = (APTR) em[i].em_Command;

	if (em[i].em_Type == NM_TITLE)
	{
	    nm[i].nm_Label = GetString (gd, em[i].em_Label);
	}
	else if (em[i].em_Command == MMC_NOP)
	{
	    nm[i].nm_Label = NM_BARLABEL;
	}
	else if (em[i].em_Type != NM_END)
	{
	    nm[i].nm_CommKey = GetString (gd, em[i].em_Label);
	    nm[i].nm_Label = &nm[i].nm_CommKey[2];
	    if (nm[i].nm_CommKey[0] == ' ')
	    {
		nm[i].nm_CommKey = NULL;
	    }
	}
    }

    if (menus = CreateMenusA (nm, NULL))
    {
	if (!(layoutmenus (gd, menus, GTMN_NewLookMenus, TRUE,
			   TAG_DONE)))
	{
	    FreeMenus (menus);
	    menus = NULL;
	}
    }

    FreeVec (nm);

    return (menus);
}

/*****************************************************************************/

d154 1
a154 1
    Class *cl;
d156 2
a157 1
    if (cl = MakeClass (NULL, GADGETCLASS, NULL, NULL, 0L))
d159 14
a172 3
	cl->cl_Dispatcher.h_Entry = dispatchWindowClass;
	cl->cl_UserData = (ULONG) gd;
	return (cl);
d182 1
d184 5
a188 1
    return ((ULONG) FreeClass (cl));
d192 2
d195 1
a195 1
void PrintMenus (struct GlobalData *gd, BOOL state)
d197 1
a197 3
    SetMenuItemState (gd, MMC_OPEN,  state);
    SetMenuItemState (gd, MMC_PRINT, state);
    SetMenuItemState (gd, MMC_QUIT,  state);
d202 1
a202 1
ULONG ASM dispatchWindowClass (REG (a0) Class * cl, REG (a2) Object * o, REG (a1) Msg msg)
d204 4
a207 1
    struct GlobalData *gd = (struct GlobalData *) cl->cl_UserData;
d209 7
a215 4
    Object *ostate;
    Object *member;
    Object *newobj;
    WORD i;
d217 3
a219 1
    switch (msg->MethodID)
d221 39
a259 4
	case OM_NEW:
	    if (newobj = (Object *) DoSuperMethodA (cl, o, msg))
	    {
		if (initWindowObject (gd, cl, newobj, (struct opSet *) msg))
d261 2
a262 1
		    setWindowClassAttrs (gd, cl, newobj, (struct opSet *) msg);
d264 4
a267 1
		else
d269 2
a270 2
		    CoerceMethod (cl, newobj, OM_DISPOSE);
		    newobj = NULL;
d272 5
a276 1
	    }
d278 3
a280 2
	    retval = (ULONG) newobj;
	    break;
d282 5
a286 5
	case WOM_ADDVIEW:
	    {
		struct Window *win = gd->gd_Window;
		ULONG left, top, width, height;
		Tag wt, ht;
d288 41
a328 1
		DoMethod (o, OM_ADDMEMBER, (LONG) gd->gd_DataObject);
d330 2
a331 31
                if (win->Flags & WFLG_BACKDROP)
                {
                    left = 0;
                    top = 0;
                    width = win->Width;
                    height = win->Height;
                    wt = GA_Width;
                    ht = GA_Height;
                }
                else
                {
                    left = win->WScreen->WBorLeft + 2;
                    top = win->WScreen->BarHeight + 1 + 1;
                    width = -(win->WScreen->WBorLeft + 18 + 4);
                    height = -(win->WScreen->BarHeight + 1 + 10 + 2);
                    wt = GA_RelWidth;
                    ht = GA_RelHeight;
                }

                setattrs (gd, (Object *) gd->gd_DataObject,
                          GA_Left,          left,
                          GA_Top,           top,
                          wt,               width,
                          ht,               height,
                          ICA_TARGET,       ICTARGET_IDCMP,
                          TAG_DONE);

                AddDTObject (gd->gd_Window, NULL, gd->gd_DataObject, -1);
                syncMenuItems (gd, cl, o);
	    }
	    break;
d333 1
a333 5
	case WOM_REMVIEW:
	    if (gd->gd_DataObject)
	    {
		/* So we don't get any more notification events */
		setattrs (gd, (Object *) gd->gd_DataObject, ICA_TARGET, NULL, TAG_DONE);
d335 4
a338 2
		/* Remove the object from the window */
		RemoveDTObject (gd->gd_Window, gd->gd_DataObject);
d340 21
a360 1
		DoMethod (o, OM_REMMEMBER, (LONG) gd->gd_DataObject);
d362 2
a363 2
		NoObjectLoaded (gd);
	    }
d366 3
a368 3
	case OM_UPDATE:
	case OM_SET:
	    retval = setWindowClassAttrs (gd, cl, o, (struct opSet *) msg);
d370 1
d372 4
a375 4
	case OM_ADDMEMBER:
	    member = ((struct opAddMember *) msg)->opam_Object;
	    DoMethod (member, OM_ADDTAIL, &gd->gd_List);
	    break;
d377 7
a383 4
	case OM_REMMEMBER:
	    member = ((struct opAddMember *) msg)->opam_Object;
	    DoMethod (member, OM_REMOVE, &gd->gd_List);
	    break;
d385 5
a389 3
	case OM_DISPOSE:
	    /* Clear the menu */
	    if (gd->gd_Menu)
d391 8
a398 2
		ClearMenuStrip (gd->gd_Window);
		FreeMenus (gd->gd_Menu);
d400 2
d403 3
a405 3
	    /* Remove the AppWindow */
	    if (gd->gd_AppWindow)
		RemoveAppWindow (gd->gd_AppWindow);
d407 3
a409 2
	    /* Close the window */
	    if (gd->gd_Window)
d411 35
a445 4
		/* Restore the window pointer */
		gd->gd_Process->pr_WindowPtr = gd->gd_OldWinPtr;
		CloseWindowSafely (gd, gd->gd_Window);
	    }
d447 13
a459 6
	    /* Delete all the objects that were attached to use */
	    ostate = (Object *) gd->gd_List.mlh_Head;
	    while (member = NextObject (&ostate))
	    {
		DoMethod (member, OM_REMOVE);
		DoMethodA (member, msg);
d461 1
a461 5

	    /* Get rid of the arrow images */
	    for (i = 0; i < NUM_ARROWS; i++)
		if (gd->gd_ArrowImg[i])
		    DisposeObject (gd->gd_ArrowImg[i]);
a462 1
	    /* Let the superclass handle everything else */
d472 1
a472 36

VOID syncMenuItems (struct GlobalData * gd, Class * cl, Object * o)
{
    UWORD i;

    if (gd->gd_Methods = (ULONG *) GetDTMethods (gd->gd_DataObject))
    {
	for (i = 0; gd->gd_Methods[i] != ~0; i++)
	{
	    switch (gd->gd_Methods[i])
	    {
		case DTM_SELECT:
		    if (!(gd->gd_Flags & GDF_BITMAP))
			SetMenuItemState (gd, MMC_MARK, TRUE);
		    break;

		case DTM_CLEARSELECTED:
		    SetMenuItemState (gd, MMC_CLEARSELECTED, TRUE);
		    break;

		case DTM_COPY:
		    SetMenuItemState (gd, MMC_COPY, TRUE);
		    break;

		case DTM_PRINT:
		    SetMenuItemState (gd, MMC_PRINT, TRUE);
		    break;

		case DTM_WRITE:
		    SetMenuItemState (gd, MMC_SAVEAS, TRUE);
		    break;
	    }
	}
    }
}

d483 1
d487 10
d506 5
d514 1
a514 1
	    backfill = (LONG)((gd->gd_WinFlags & WOAF_BITMAP) ? LAYERS_NOBACKFILL : LAYERS_BACKFILL);
a529 3
		DB (kprintf ("top %ld\n", top));
		DB (kprintf ("screen is %s\n", ((gd->gd_WinFlags & WOAF_BITMAP) ? "super-bitmap" : "normal")));
		DB (kprintf ("backfill %s\n",  ((gd->gd_WinFlags & WOAF_BITMAP) ? "LAYERS_NOBACKFILL" : "LAYERS_BACKFILL")));
a531 1
		    DB (kprintf ("make layer smart-refresh\n"));
a536 4
		else
		{
		    DB (kprintf ("keep layer as simple-refresh\n"));
		}
d542 3
a544 1
	    for (i = 0; i < NUM_ARROWS; i++)
a546 1
						    SYSIA_Size, 0,
d551 28
d589 2
d597 2
d602 1
a602 1
	    if (prev)
d604 2
d608 12
a619 10
				      GA_Left, 4L,
				      GA_RelBottom, -7L,
				      GA_RelWidth, -55L,
				      GA_Height, 6L,
				      GA_Previous, prev,
				      GA_BottomBorder, TRUE,
				      GA_ID, HORIZ_GID,
				      PGA_Freedom, FREEHORIZ,
				      PGA_Borderless,	((gd->gd_Screen->BitMap.Depth == 1) ? FALSE : TRUE),
				      TAG_MORE, prop_tags))
d621 1
d623 2
d628 12
a639 10
					  GA_RelRight, -13L,
					  GA_Top, gd->gd_Screen->BarHeight + 2,
					  GA_Width, 10,
					  GA_RelHeight, -(gd->gd_Screen->BarHeight + 35),
					  GA_Previous, prev,
					  GA_RightBorder, TRUE,
					  GA_ID, VERT_GID,
					  PGA_Freedom, FREEVERT,
					  PGA_Borderless,	((gd->gd_Screen->BitMap.Depth == 1) ? FALSE : TRUE),
					  TAG_MORE, prop_tags))
d641 1
d643 2
d646 23
a668 23
			    if (gd->gd_Window = openwindowtags (gd,
								WA_AutoAdjust, TRUE,
								WA_CloseGadget, TRUE,
								WA_DepthGadget, TRUE,
								WA_DragBar, TRUE,
								WA_SizeGadget, TRUE,
								WA_SizeBRight, TRUE,
								WA_SizeBBottom, TRUE,
								WA_SimpleRefresh, TRUE,
								WA_NoCareRefresh, TRUE,
								WA_Activate, TRUE,
								WA_BusyPointer, TRUE,
								WA_MinWidth, 80L,
								WA_MinHeight, gd->gd_Screen->BarHeight + 38,
								WA_MaxWidth, -1L,
								WA_MaxHeight, -1L,
								WA_Gadgets, gd->gd_First,
								WA_NewLookMenus, TRUE,
								WA_Title, title,
								TAG_MORE, attrs))
			    {
				success = TRUE;
			    }
d691 1
a691 3
		    SetMenuItemState (gd, MMC_MINIMIZE, FALSE);
		    SetMenuItemState (gd, MMC_NORMAL,   FALSE);
		    SetMenuItemState (gd, MMC_MAXIMIZE, FALSE);
d710 1
a710 1
    ULONG retval = 0, sync = 0;
d713 1
d715 22
a736 1
    LONG nh, nv;
d738 3
a740 2
    nh = gd->gd_TopHoriz;
    nv = gd->gd_TopVert;
d749 7
a755 3
	    case DTA_TopVert:
	    case WOA_TopVert:
		gd->gd_TopVert = tidata;
d757 1
d759 3
a761 3
	    case DTA_VisibleVert:
	    case WOA_VisibleVert:
		gd->gd_VisVert = tidata;
d763 4
d768 1
a768 4
	    case DTA_TotalVert:
	    case WOA_TotalVert:
		gd->gd_TotVert = tidata;
		break;
d770 3
a772 3
	    case WOA_DecVert:
		gd->gd_TopVert--;
		break;
d774 10
a783 3
	    case WOA_IncVert:
		gd->gd_TopVert++;
		break;
d785 5
a789 4
	    case DTA_TopHoriz:
	    case WOA_TopHoriz:
		gd->gd_TopHoriz = tidata;
		break;
d791 3
a793 4
	    case DTA_VisibleHoriz:
	    case WOA_VisibleHoriz:
		gd->gd_VisHoriz = tidata;
		break;
d795 8
a802 4
	    case DTA_TotalHoriz:
	    case WOA_TotalHoriz:
		gd->gd_TotHoriz = tidata;
		break;
d804 20
a823 3
	    case WOA_DecHoriz:
		gd->gd_TopHoriz--;
		break;
d825 5
a829 3
	    case WOA_IncHoriz:
		gd->gd_TopHoriz++;
		break;
d831 9
a839 4
	    case DTA_Title:
	    case WOA_Title:
		if (tidata)
		    strcpy (gd->gd_Title, (STRPTR) tidata);
d841 101
a941 1
		    gd->gd_Title[0] = 0;
d943 10
a952 3
		if (!(gd->gd_Window->Flags & WFLG_BACKDROP))
		    SetWindowTitles (gd->gd_Window, gd->gd_Title, ((UBYTE *) (~0)));
		break;
d954 4
a957 58
	    case DTA_Sync:
	    case WOA_Sync:
		syncMenuItems (gd, cl, o);
		sync = tidata;
		retval = 1;
		break;
	}
    }

    if (gd->gd_TopVert < 0)
	gd->gd_TopVert = 0;
    if (gd->gd_TopVert > gd->gd_TotVert - gd->gd_VisVert)
	gd->gd_TopVert = gd->gd_TotVert - gd->gd_VisVert;
    if (gd->gd_TopVert < 0)
	gd->gd_TopVert = 0;
    if (gd->gd_TopVert != nv)
	retval = 1;

    if (gd->gd_TopHoriz < 0)
	gd->gd_TopHoriz = 0;
    if (gd->gd_TopHoriz > gd->gd_TotHoriz - gd->gd_VisHoriz)
	gd->gd_TopHoriz = gd->gd_TotHoriz - gd->gd_VisHoriz;
    if (gd->gd_TopHoriz < 0)
	gd->gd_TopHoriz = 0;
    if (gd->gd_TopHoriz != nh)
	retval = 1;

    if (retval)
    {
	DT (kprintf ("V %ld,%ld,%ld  H %ld,%ld,%ld\n",
		 gd->gd_TopVert, gd->gd_VisVert, gd->gd_TotVert,
		 gd->gd_TopHoriz, gd->gd_VisHoriz, gd->gd_TotHoriz));

	if ((sync == 0) && (gd->gd_DataObject))
	{
	    DR (kprintf ("update data object\n"));
	    setgadgetattrs (gd, (struct Gadget *)gd->gd_DataObject, gd->gd_Window,
			     DTA_TotalVert,	gd->gd_TotVert,
			     DTA_VisibleVert,	gd->gd_VisVert,
			     DTA_TopVert,	gd->gd_TopVert,

			     DTA_TotalHoriz,	gd->gd_TotHoriz,
			     DTA_VisibleHoriz,	gd->gd_VisHoriz,
			     DTA_TopHoriz,	gd->gd_TopHoriz,
			     TAG_DONE);
	}

	setgadgetattrs (gd, gd->gd_VGad, gd->gd_Window,
                  PGA_Total,	gd->gd_TotVert,
                  PGA_Visible,	gd->gd_VisVert,
                  PGA_Top,	gd->gd_TopVert,
                  TAG_DONE);

	setgadgetattrs (gd,	gd->gd_HGad, gd->gd_Window,
                  PGA_Total,	gd->gd_TotHoriz,
                  PGA_Visible,	gd->gd_VisHoriz,
                  PGA_Top,	gd->gd_TopHoriz,
                  TAG_DONE);
@


39.13
log
@removed much
@
text
@d15 1
d533 1
d698 1
a698 2
	    DT (kprintf ("update data object\n"));

a724 1

@


39.12
log
@removed model class
@
text
@d2 4
d14 1
a45 41
#define	HORIZ_SLIDER	0
#define	VERT_SLIDER	1
#define	NUM_SLIDERS	2

#define	LEFT_ARROW	0
#define	UP_ARROW	1
#define	RIGHT_ARROW	2
#define	DOWN_ARROW	3
#define	NUM_ARROWS	4

/*****************************************************************************/

struct WindowObj
{
    struct Window	*wo_Window;
    struct Menu		*wo_Menu;
    struct Process	*wo_Process;
    APTR		 wo_OldWinPtr;
    struct AppWindow	*wo_AppWindow;
    struct Gadget	*wo_First;
    struct Gadget	*wo_HGad;			/* Horizontal gadget */
    struct Gadget	*wo_VGad;			/* Vertical gadget */
    Object		*wo_DataObject;
    struct MinList	 wo_List;			/* List of gadgets */
    struct Image	*wo_ArrowImg[NUM_ARROWS];
    UBYTE		 wo_Title[128];
    ULONG		*wo_Methods;
    struct DTMethod	*wo_Trigger;
    ULONG		 wo_Flags;

    LONG		 wo_TopVert;
    LONG		 wo_VisVert;
    LONG		 wo_TotVert;

    LONG		 wo_TopHoriz;
    LONG		 wo_VisHoriz;
    LONG		 wo_TotHoriz;
};

/*****************************************************************************/

d48 4
a51 4
    UBYTE em_Type;		/* NM_XXX from gadtools.h */
    LONG em_Label;
    ULONG em_Command;
    UWORD em_ItemFlags;
d88 1
a88 1
BOOL SetMenuItemState (struct GlobalData * gd, struct WindowObj * wo, ULONG command, BOOL state)
d93 1
a93 1
    if (m = wo->wo_Menu)
d118 1
a118 1
void NoObjectLoaded (struct GlobalData * gd, struct WindowObj * wo)
d121 12
a132 12
    SetMenuItemState (gd, wo, MMC_SAVEAS, FALSE);
    SetMenuItemState (gd, wo, MMC_PRINT, FALSE);
    SetMenuItemState (gd, wo, MMC_MARK, FALSE);
    SetMenuItemState (gd, wo, MMC_COPY, FALSE);
    SetMenuItemState (gd, wo, MMC_SELECTALL, FALSE);
    SetMenuItemState (gd, wo, MMC_CLEARSELECTED, FALSE);
    SetMenuItemState (gd, wo, MMC_FIND, FALSE);
    SetMenuItemState (gd, wo, MMC_NEXT, FALSE);
    SetMenuItemState (gd, wo, MMC_GOTO, FALSE);
    SetMenuItemState (gd, wo, MMC_SETBOOKMARK, FALSE);
    SetMenuItemState (gd, wo, MMC_GOTOBOOKMARK, FALSE);
    SetMenuItemState (gd, wo, MMC_EXECUTE, FALSE);
d197 1
a197 1
    if (cl = MakeClass (NULL, GADGETCLASS, NULL, sizeof (struct WindowObj), 0L))
d219 3
a221 5
    struct WindowObj *wo = INST_DATA (gd->gd_WindowClass, gd->gd_WindowObj);

    SetMenuItemState (gd, wo, MMC_OPEN,  state);
    SetMenuItemState (gd, wo, MMC_PRINT, state);
    SetMenuItemState (gd, wo, MMC_QUIT,  state);
a228 1
    struct WindowObj *wo = INST_DATA (cl, o);
d256 1
a256 2
		struct womView *wom = (struct womView *) msg;
		struct Window *win = wo->wo_Window;
d260 1
a260 2
		wo->wo_DataObject = wom->wom_Object;
		DoMethod (o, OM_ADDMEMBER, (LONG) wo->wo_DataObject);
d281 1
a281 1
                setattrs (gd, (Object *) wo->wo_DataObject,
d289 2
a290 6
#if 0
		setattrs (gd, (Object *) wo->wo_HGad, ICA_TARGET, wo->wo_DataObject, TAG_DONE);
		setattrs (gd, (Object *) wo->wo_VGad, ICA_TARGET, wo->wo_DataObject, TAG_DONE);
#endif
                AddDTObject (wo->wo_Window, NULL, wo->wo_DataObject, -1);
                syncMenuItems (gd, cl, o, wo);
d295 1
a295 1
	    if (wo->wo_DataObject)
d298 1
a298 5
#if 0
		setattrs (gd, (Object *) wo->wo_HGad, ICA_TARGET, NULL, TAG_DONE);
		setattrs (gd, (Object *) wo->wo_VGad, ICA_TARGET, NULL, TAG_DONE);
#endif
		setattrs (gd, (Object *) wo->wo_DataObject, ICA_TARGET, NULL, TAG_DONE);
d301 1
a301 1
		RemoveDTObject (wo->wo_Window, wo->wo_DataObject);
d303 1
a303 1
		DoMethod (o, OM_REMMEMBER, (LONG) wo->wo_DataObject);
d305 1
a305 3
		NoObjectLoaded (gd, wo);

		wo->wo_DataObject = NULL;
a313 4
	case OM_GET:
	    retval = getWindowClassAttr (gd, cl, o, (struct opGet *) msg);
	    break;

d316 1
a316 1
	    DoMethod (member, OM_ADDTAIL, &wo->wo_List);
d321 1
a321 1
	    DoMethod (member, OM_REMOVE, &wo->wo_List);
d326 1
a326 1
	    if (wo->wo_Menu)
d328 2
a329 2
		ClearMenuStrip (wo->wo_Window);
		FreeMenus (wo->wo_Menu);
d333 2
a334 2
	    if (wo->wo_AppWindow)
		RemoveAppWindow (wo->wo_AppWindow);
d337 1
a337 1
	    if (wo->wo_Window)
d340 2
a341 2
		wo->wo_Process->pr_WindowPtr = wo->wo_OldWinPtr;
		CloseWindowSafely (gd, wo->wo_Window);
d345 1
a345 1
	    ostate = (Object *) wo->wo_List.mlh_Head;
d354 2
a355 2
		if (wo->wo_ArrowImg[i])
		    DisposeObject (wo->wo_ArrowImg[i]);
d368 1
a368 1
VOID syncMenuItems (struct GlobalData * gd, Class * cl, Object * o, struct WindowObj * wo)
d372 1
a372 2
    wo->wo_Trigger = NULL;
    if (wo->wo_Methods = (ULONG *) GetDTMethods (wo->wo_DataObject))
d374 1
a374 1
	for (i = 0; wo->wo_Methods[i] != ~0; i++)
d376 1
a376 1
	    switch (wo->wo_Methods[i])
d380 1
a380 1
			SetMenuItemState (gd, wo, MMC_MARK, TRUE);
d384 1
a384 1
		    SetMenuItemState (gd, wo, MMC_CLEARSELECTED, TRUE);
d388 1
a388 1
		    SetMenuItemState (gd, wo, MMC_COPY, TRUE);
d392 1
a392 1
		    SetMenuItemState (gd, wo, MMC_PRINT, TRUE);
d396 1
a396 1
		    SetMenuItemState (gd, wo, MMC_SAVEAS, TRUE);
a404 52
struct TagItem leftm_map[] =
{
    {GA_ID,	WOA_DecHoriz},
    {TAG_DONE,},
};

struct TagItem upm_map[] =
{
    {GA_ID,	WOA_DecVert},
    {TAG_DONE,},
};

struct TagItem rightm_map[] =
{
    {GA_ID,	WOA_IncHoriz},
    {TAG_DONE,},
};

struct TagItem downm_map[] =
{
    {GA_ID,	WOA_IncVert},
    {TAG_DONE,},
};

struct TagItem *arrow_map[] =
{
    leftm_map,
    upm_map,
    rightm_map,
    downm_map,
};

/*****************************************************************************/

struct TagItem vg_map[] =
{
    {PGA_Top,		WOA_TopVert},
    {PGA_Visible,	WOA_VisibleVert},
    {PGA_Total,		WOA_TotalVert},
    {TAG_DONE,},
};

struct TagItem hg_map[] =
{
    {PGA_Top,		WOA_TopHoriz},
    {PGA_Visible,	WOA_VisibleHoriz},
    {PGA_Total,		WOA_TotalHoriz},
    {TAG_DONE,},
};

/*****************************************************************************/

a407 1
    struct WindowObj *wo = INST_DATA (cl, o);
a408 3
    struct DrawInfo *drinfo;
    struct MsgPort *awport;
    struct MsgPort *idcmp;
a409 1
    struct Screen *scr;
d411 1
a412 1
    WORD i, j;
d414 1
d417 1
a417 4
    NewList ((struct List *) & wo->wo_List);

    /* Cache the parent process */
    wo->wo_Process = (struct Process *) FindTask (NULL);
a418 4
    scr = (struct Screen *) GetTagData (WA_PubScreen, NULL, attrs);
    drinfo = (struct DrawInfo *) GetTagData (WOA_DrawInfo, NULL, attrs);
    awport = (struct MsgPort *) GetTagData (WOA_AWPort, NULL, attrs);
    idcmp = (struct MsgPort *) GetTagData (WOA_IDCMPPort, NULL, attrs);
d421 1
a421 1
    wo->wo_Flags = GetTagData (WOA_Flags, NULL, attrs);
d423 1
a423 1
    if (scr && drinfo)
d427 3
a429 2
	    top = (wo->wo_Flags & WOAF_BACKDROP) ? (scr->BarHeight + 1) : 0;
	    if (wo->wo_Window = openwindowtags (gd,
d432 2
a433 2
						WA_Width, scr->Width,
						WA_Height, scr->Height - top,
d435 1
d441 1
a441 1
						WA_BackFill, ((wo->wo_Flags & WOAF_BITMAP) ? LAYERS_NOBACKFILL : LAYERS_BACKFILL),
d444 12
a455 1
		if (!(wo->wo_Flags & WOAF_BACKDROP))
d457 1
a457 2
		    wo->wo_Window->RPort->Layer->Flags &= ~LAYERSIMPLE;
		    wo->wo_Window->RPort->Layer->Flags |= LAYERSMART;
d464 1
a464 1
	    for (i = j = 0; i < NUM_ARROWS; i++)
d466 1
a466 1
		if (wo->wo_ArrowImg[i] = newobject (gd, NULL, "sysiclass",
d468 1
a468 1
						    SYSIA_DrawInfo, drinfo,
d477 1
a477 1
					  GA_Image, wo->wo_ArrowImg[i],
d479 2
a481 2
					  ICA_TARGET, o,
					  ICA_MAP, arrow_map[i],
d484 2
a485 2
			if (!wo->wo_First)
			    wo->wo_First = prev;
a486 1
			j++;
d494 1
a494 1
		if (prev = wo->wo_HGad = newobject (gd, NULL, "propgclass",
d503 1
a503 3
				      ICA_TARGET, o,
				      ICA_MAP, hg_map,
				      PGA_Borderless,	((scr->BitMap.Depth == 1) ? FALSE : TRUE),
d509 1
a509 1
		    if (prev = wo->wo_VGad = newobject (gd, NULL, "propgclass",
d511 1
a511 1
					  GA_Top, scr->BarHeight + 2,
d513 1
a513 1
					  GA_RelHeight, -(scr->BarHeight + 35),
d518 1
a518 3
					  ICA_TARGET, o,
					  ICA_MAP, vg_map,
					  PGA_Borderless,	((scr->BitMap.Depth == 1) ? FALSE : TRUE),
d523 1
a523 1
			    if (wo->wo_Window = openwindowtags (gd,
d535 1
a535 1
								WA_MinHeight, scr->BarHeight + 38,
d538 1
a538 1
								WA_Gadgets, wo->wo_First,
d553 2
a554 2
	    wo->wo_OldWinPtr = wo->wo_Process->pr_WindowPtr;
	    wo->wo_Process->pr_WindowPtr = wo->wo_Window;
d557 2
a558 2
	    wo->wo_Window->UserPort = idcmp;
	    ModifyIDCMP (wo->wo_Window, IDCMP_FLAGS);
d561 1
a561 1
	    if (wo->wo_Menu = localizemenus (gd, newmenu))
d563 1
a563 1
		NoObjectLoaded (gd, wo);
d567 3
a569 3
		    SetMenuItemState (gd, wo, MMC_MINIMIZE, FALSE);
		    SetMenuItemState (gd, wo, MMC_NORMAL,   FALSE);
		    SetMenuItemState (gd, wo, MMC_MAXIMIZE, FALSE);
d572 5
a576 5
		SetMenuStrip (wo->wo_Window, wo->wo_Menu);
	    }

	    if (awport)
		wo->wo_AppWindow = AddAppWindowA (0, (ULONG) wo, wo->wo_Window, awport, NULL);
a586 1
    struct WindowObj *wo = INST_DATA (cl, o);
a587 1
    struct DTSpecialInfo *si = NULL;
d594 2
a595 7
    nh = wo->wo_TopHoriz;
    nv = wo->wo_TopVert;

    if (wo->wo_DataObject)
    {
	si = (struct DTSpecialInfo *) G (wo->wo_DataObject)->SpecialInfo;
    }
d606 1
a606 1
		wo->wo_TopVert = tidata;
d611 1
a611 1
		wo->wo_VisVert = tidata;
d616 1
a616 1
		wo->wo_TotVert = tidata;
d620 1
a620 1
		wo->wo_TopVert--;
d624 1
a624 1
		wo->wo_TopVert++;
d629 1
a629 1
		wo->wo_TopHoriz = tidata;
d634 1
a634 1
		wo->wo_VisHoriz = tidata;
d639 1
a639 1
		wo->wo_TotHoriz = tidata;
d643 1
a643 1
		wo->wo_TopHoriz--;
d647 1
a647 8
		wo->wo_TopHoriz++;
		break;

	    case DTA_Busy:
		if (tidata)
		    setwindowpointer (gd, wo->wo_Window, WA_BusyPointer, TRUE, WA_PointerDelay, TRUE, TAG_DONE);
		else
		    setwindowpointer (gd, wo->wo_Window, WA_Pointer, NULL, TAG_DONE);
d653 1
a653 1
		    strcpy (wo->wo_Title, (STRPTR) tidata);
d655 4
a658 3
		    wo->wo_Title[0] = 0;
		if (!(wo->wo_Window->Flags & WFLG_BACKDROP))
		    SetWindowTitles (wo->wo_Window, wo->wo_Title, ((UBYTE *) (~0)));
d663 3
a665 3
		syncMenuItems (gd, cl, o, wo);
		RefreshGList ((struct Gadget *) wo->wo_DataObject, wo->wo_Window, NULL, 1);
		sync = retval = 1;
d668 9
a676 7
    }

    if (wo->wo_TopVert < 0)
	wo->wo_TopVert = 0;
    if (wo->wo_TopVert > wo->wo_TotVert - wo->wo_VisVert)
	wo->wo_TopVert = wo->wo_TotVert - wo->wo_VisVert;
    if (wo->wo_TopVert != nv)
d679 7
a685 5
    if (wo->wo_TopHoriz < 0)
	wo->wo_TopHoriz = 0;
    if (wo->wo_TopHoriz > wo->wo_TotHoriz - wo->wo_VisHoriz)
	wo->wo_TopHoriz = wo->wo_TotHoriz - wo->wo_VisHoriz;
    if (wo->wo_TopHoriz != nh)
d690 12
a701 6
	if ((sync == 0) && (wo->wo_DataObject))
	{
	     setgadgetattrs (gd, wo->wo_DataObject, wo->wo_Window,
			     DTA_TotalVert, wo->wo_TotVert,
			     DTA_VisibleVert, wo->wo_VisVert,
			     DTA_TopVert, wo->wo_TopVert,
d703 3
a705 3
			     DTA_TotalHoriz, wo->wo_TotHoriz,
			     DTA_VisibleHoriz, wo->wo_VisHoriz,
			     DTA_TopHoriz, wo->wo_TopHoriz,
d709 4
a712 4
	setgadgetattrs (gd, wo->wo_VGad, wo->wo_Window,
                  PGA_Total, wo->wo_TotVert,
                  PGA_Visible, wo->wo_VisVert,
                  PGA_Top, wo->wo_TopVert,
d715 4
a718 4
	setgadgetattrs (gd, wo->wo_HGad, wo->wo_Window,
                  PGA_Total, wo->wo_TotHoriz,
                  PGA_Visible, wo->wo_VisHoriz,
                  PGA_Top, wo->wo_TopHoriz,
a724 50
/*****************************************************************************/

ULONG getWindowClassAttr (struct GlobalData * gd, Class * cl, Object * o, struct opGet * msg)
{
    struct WindowObj *wo = INST_DATA (cl, o);
    ULONG retval = 1L;

    /* It might belong to us */
    switch (msg->opg_AttrID)
    {
	case DTA_TopVert:
	    *msg->opg_Storage = (ULONG) wo->wo_TopVert;
	    break;

	case DTA_VisibleVert:
	    *msg->opg_Storage = (ULONG) wo->wo_VisVert;
	    break;

	case DTA_TotalVert:
	    *msg->opg_Storage = (ULONG) wo->wo_TotVert;
	    break;

	case DTA_TopHoriz:
	    *msg->opg_Storage = (ULONG) wo->wo_TopHoriz;
	    break;

	case DTA_VisibleHoriz:
	    *msg->opg_Storage = (ULONG) wo->wo_VisHoriz;
	    break;

	case DTA_TotalHoriz:
	    *msg->opg_Storage = (ULONG) wo->wo_TotHoriz;
	    break;

	case WOA_Window:
	    *msg->opg_Storage = (ULONG) wo->wo_Window;
	    break;

	case DTA_Title:
	    *msg->opg_Storage = (ULONG) wo->wo_Title;
	    break;

	default:
	    /* I don't recognize this one, let the superclass try */
	    retval = (ULONG) DoSuperMethodA (cl, o, msg);
	    break;
    }

    return (retval);
}
@


39.11
log
@wasn't checking to see if backdrop was on custom screen or public screen.
@
text
@a9 2
#define	DM(x)	;
#define	DS(x)	;
a16 7
struct WindowClass
{
    Class *wc_ModelClass;
};

/*****************************************************************************/

a26 21
static Tag model_attrs[] =
{
    DTA_Sync,
    WOA_Sync,

    DTA_TopVert,
    DTA_VisibleVert,
    DTA_TotalVert,

    DTA_TopHoriz,
    DTA_VisibleHoriz,
    DTA_TotalHoriz,

    ICA_TARGET,
    ICA_MAP,

    TAG_DONE,
};

/*****************************************************************************/

d29 7
a35 7
    {GA_RelVerify, TRUE},
    {GA_Immediate, TRUE},
    {GA_FollowMouse, TRUE},
    {PGA_Total, 1},
    {PGA_Visible, 1},
    {PGA_Top, 0},
    {PGA_NewLook, TRUE},
d51 2
d61 2
a62 1
    Object		*wo_Model;
a63 1
    Object		*wo_IC;
d70 8
a110 11
#if 0
    {NM_TITLE, MV_MENU_SEARCH, MMC_NOP, 0},
    {NM_ITEM, MV_ITEM_FIND, MMC_FIND, 0},
    {NM_ITEM, MV_ITEM_FIND_NEXT, MMC_NEXT, 0},
    {NM_ITEM, MSG_NOTHING, MMC_NOP, 0},
    {NM_ITEM, MV_ITEM_GO_TO_LINE, MMC_GOTO, 0},
    {NM_ITEM, MSG_NOTHING, MMC_NOP, 0},
    {NM_ITEM, MV_ITEM_SET_BOOKMARK, MMC_SETBOOKMARK, 0},
    {NM_ITEM, MV_ITEM_GOTO_BOOKMARK, MMC_GOTOBOOKMARK, 0},
#endif

a115 5
#if 0
    {NM_TITLE, MV_MENU_EXTRAS, MMC_NOP, 0},
    {NM_ITEM, MV_ITEM_EXECUTE_COMMAND, MMC_EXECUTE, 0},
#endif

a230 1
    struct WindowClass *wc;
d233 1
a233 1
    if (wc = AllocVec (sizeof (struct WindowClass), MEMF_CLEAR))
d235 3
a237 12
	if (wc->wc_ModelClass = initWindowMClass (gd))
	{
	    if (cl = MakeClass (NULL, GADGETCLASS, NULL, sizeof (struct WindowObj), 0L))
	    {
		cl->cl_Dispatcher.h_Entry = dispatchWindowClass;
		cl->cl_Dispatcher.h_Data = wc;
		cl->cl_UserData = (ULONG) gd;
		return (cl);
	    }
	    freeWindowMClass (wc->wc_ModelClass);
	}
	FreeVec (wc);
a246 2
    struct WindowClass *wc;
    ULONG retval = FALSE;
d248 1
a248 10
    if (cl)
    {
	wc = (struct WindowClass *) cl->cl_Dispatcher.h_Data;
	if (retval = (ULONG) FreeClass (cl))
	{
	    freeWindowMClass (wc->wc_ModelClass);
	    FreeVec (wc);
	}
    }
    return (retval);
d302 27
a328 22
		if (wo->wo_IC = newobject (gd, NULL, ICCLASS,
					   ICA_TARGET, wo->wo_DataObject,
					   TAG_DONE))
		{
		    if (win->Flags & WFLG_BACKDROP)
		    {
			left = 0;
			top = 0;
			width = win->Width;
			height = win->Height;
			wt = GA_Width;
			ht = GA_Height;
		    }
		    else
		    {
			left = win->WScreen->WBorLeft + 2;
			top = win->WScreen->BarHeight + 1 + 1;
			width = -(win->WScreen->WBorLeft + 18 + 4);
			height = -(win->WScreen->BarHeight + 1 + 10 + 2);
			wt = GA_RelWidth;
			ht = GA_RelHeight;
		    }
d330 6
a335 12
		    setattrs (gd, wo->wo_DataObject,
			      GA_Left,		left,
			      GA_Top,		top,
			      wt,		width,
			      ht,		height,
			      ICA_TARGET,	o,
			      TAG_DONE);

		    DoMethod (wo->wo_Model, OM_ADDMEMBER, (LONG) wo->wo_IC);
		    AddDTObject (wo->wo_Window, NULL, wo->wo_DataObject, -1);
		    syncMenuItems (gd, cl, o, wo);
		}
d343 5
a347 1
		setattrs (gd, wo->wo_DataObject, ICA_TARGET, NULL, TAG_DONE);
a352 2
		DoMethod (wo->wo_Model, OM_REMMEMBER, (LONG) wo->wo_IC);
		DoMethod (wo->wo_IC, OM_DISPOSE);
a356 1
		wo->wo_IC = NULL;
a453 23

#if 0
		case DTM_TRIGGER:
		    DM (kprintf ("Trigger methods\n"));
		    if (wo->wo_Trigger = GetDTTriggerMethods (wo->wo_DataObject))
		    {
			struct NewMenu *nm;
			ULONG cnt;

			for (j = 0; wo->wo_Trigger[j].dtm_Label; j++) ;
			DM (kprintf ("%ld trigger commands\n", j));

			if (nm = AllocVec (sizeof (struct NewMenu) * (j + 2), MEMF_CLEAR))
			{
			    for (j = 0; wo->wo_Trigger[j].dtm_Label; j++)
			    {
				DM (kprintf ("  %s\n", wo->wo_Trigger[j].dtm_Command));
			    }
			    FreeVec (nm);
			}
		    }
		    break;
#endif
d463 1
a463 1
    {GA_ID, WOA_DecHoriz},
d469 1
a469 1
    {GA_ID, WOA_DecVert},
d475 1
a475 1
    {GA_ID, WOA_IncHoriz},
d481 1
a481 1
    {GA_ID, WOA_IncVert},
d485 1
a485 1
struct TagItem *model_map[] =
a494 18
struct TagItem vm_map[] =
{
    {DTA_TopVert, PGA_Top},
    {DTA_VisibleVert, PGA_Visible},
    {DTA_TotalVert, PGA_Total},
    {TAG_DONE,},
};

struct TagItem hm_map[] =
{
    {DTA_TopHoriz, PGA_Top},
    {DTA_VisibleHoriz, PGA_Visible},
    {DTA_TotalHoriz, PGA_Total},
    {TAG_DONE,},
};

/*****************************************************************************/

d497 3
a499 3
    {PGA_Top, DTA_TopVert},
    {PGA_Visible, DTA_VisibleVert},
    {PGA_Total, DTA_TotalVert},
d505 3
a507 3
    {PGA_Top, DTA_TopHoriz},
    {PGA_Visible, DTA_VisibleHoriz},
    {PGA_Total, DTA_TotalHoriz},
a514 1
    struct WindowClass *wc = (struct WindowClass *) cl->cl_Dispatcher.h_Data;
a524 1
    Object *ic;
a543 4
	/* Need some glue to hook all the objects together */
	if (!(wo->wo_Model = newobject (gd, wc->wc_ModelClass, NULL, TAG_DONE)))
	    return (FALSE);

d587 2
a588 2
					  ICA_TARGET, wo->wo_Model,
					  ICA_MAP, model_map[i],
d601 2
a602 1
		if (prev = newobject (gd, NULL, "propgclass",
d611 1
a611 1
				      ICA_TARGET, wo->wo_Model,
a616 7
		    if (ic = newobject (gd, NULL, ICCLASS,
					ICA_TARGET, prev,
					ICA_MAP, hm_map,
					TAG_DONE))
		    {
			DoMethod (wo->wo_Model, OM_ADDMEMBER, (LONG) ic);
		    }
d618 2
a619 1
		    if (prev = newobject (gd, NULL, "propgclass",
d628 1
a628 1
					  ICA_TARGET, wo->wo_Model,
a633 6
			if (ic = newobject (gd, NULL, ICCLASS,
					    ICA_TARGET, prev,
					    ICA_MAP, vm_map,
					    TAG_DONE))
			{
			    DoMethod (wo->wo_Model, OM_ADDMEMBER, (LONG) ic);
a656 1
			}
d701 2
a702 1
    struct TagItem *origtags;
a704 1
    ULONG retval = 0;
d706 1
d708 2
a709 3
    /* Set aside the tags so that we can properly send them out */
    origtags = msg->ops_AttrList;
    msg->ops_AttrList = CloneTagItems (origtags);
d711 1
a711 2
    /* Handle model attributes first */
    if (FilterTagItems (msg->ops_AttrList, model_attrs, TAGFILTER_AND))
d713 1
a713 4
	if (msg->MethodID == OM_NEW)
	    retval = DoMethod (wo->wo_Model, OM_SET, (LONG) msg->ops_AttrList, (LONG) msg->ops_GInfo);
	else
	    retval = DoMethodA (wo->wo_Model, msg);
a715 16
    /* If this is a new, then pass along the attributes */
    if (msg->MethodID != OM_NEW)
    {
	/* re-clone, without re-allocating */
	RefreshTagItemClones (msg->ops_AttrList, origtags);

	if (FilterTagItems (msg->ops_AttrList, model_attrs, TAGFILTER_NOT))
	{
	    DoMethod (o, OM_NOTIFY, msg->ops_AttrList, msg->ops_GInfo, NULL);
	}
    }

    /* free clone and restore original */
    FreeTagItems (msg->ops_AttrList);
    msg->ops_AttrList = origtags;

d723 54
d789 2
d795 42
a846 4
    /* See if it belongs to the model */
    if (TagInArray (msg->opg_AttrID, model_attrs))
	return (DoMethodA (wo->wo_Model, msg));

d850 24
@


39.10
log
@disable Window menu items when backdrop
@
text
@d665 5
a669 2
		wo->wo_Window->RPort->Layer->Flags &= ~LAYERSIMPLE;
		wo->wo_Window->RPort->Layer->Flags |= LAYERSMART;
@


39.9
log
@disable MARK menu item if using CUSTOMBITMAP
@
text
@d789 8
@


39.8
log
@ghost print menu items
@
text
@d492 2
a493 1
		    SetMenuItemState (gd, wo, MMC_MARK, TRUE);
d662 1
d665 2
@


39.7
log
@*** empty log message ***
@
text
@d309 8
@


39.6
log
@cleaned up title
@
text
@d83 15
a97 14
    struct Window *wo_Window;
    struct Menu *wo_Menu;
    struct Process *wo_Process;
    APTR wo_OldWinPtr;
    struct AppWindow *wo_AppWindow;
    struct Gadget *wo_First;
    Object *wo_Model;
    Object *wo_DataObject;
    Object *wo_IC;
    struct MinList wo_List;	/* List of gadgets */
    struct Image *wo_ArrowImg[NUM_ARROWS];
    UBYTE wo_Title[128];
    ULONG *wo_Methods;
    struct DTMethod *wo_Trigger;
d114 2
a115 2
    {NM_TITLE, MENU_PROJECT, MMC_NOP, 0},
    {NM_ITEM, ITEM_OPEN, MMC_OPEN, 0},
d117 1
a117 1
    {NM_ITEM, ITEM_SAVE_AS, MMC_SAVEAS, 0},
d119 8
a126 8
    {NM_ITEM, ITEM_PRINT, MMC_PRINT, 0},
    {NM_ITEM, ITEM_ABOUT, MMC_ABOUT, 0},
    {NM_ITEM, MSG_NOTHING, MMC_NOP, 0},
    {NM_ITEM, ITEM_QUIT, MMC_QUIT, 0},

    {NM_TITLE, MENU_EDIT, MMC_NOP, 0},
    {NM_ITEM, ITEM_MARK, MMC_MARK, 0},
    {NM_ITEM, ITEM_COPY, MMC_COPY, 0},
d128 2
a129 2
    {NM_ITEM, ITEM_SELECT_ALL, MMC_SELECTALL, 0},
    {NM_ITEM, ITEM_CLEAR_SELECTED, MMC_CLEARSELECTED, 0},
d132 3
a134 3
    {NM_TITLE, MENU_SEARCH, MMC_NOP, 0},
    {NM_ITEM, ITEM_FIND, MMC_FIND, 0},
    {NM_ITEM, ITEM_FIND_NEXT, MMC_NEXT, 0},
d136 1
a136 1
    {NM_ITEM, ITEM_GO_TO_LINE, MMC_GOTO, 0},
d138 2
a139 2
    {NM_ITEM, ITEM_SET_BOOKMARK, MMC_SETBOOKMARK, 0},
    {NM_ITEM, ITEM_GOTO_BOOKMARK, MMC_GOTOBOOKMARK, 0},
d142 4
a145 4
    {NM_TITLE, MENU_WINDOW, MMC_NOP, 0},
    {NM_ITEM, ITEM_MINIMIZE, MMC_MINIMIZE, 0},
    {NM_ITEM, ITEM_NORMAL, MMC_NORMAL, 0},
    {NM_ITEM, ITEM_MAXIMIZE, MMC_MAXIMIZE, 0},
d148 2
a149 2
    {NM_TITLE, MENU_EXTRAS, MMC_NOP, 0},
    {NM_ITEM, ITEM_EXECUTE_COMMAND, MMC_EXECUTE, 0},
d152 2
a153 2
    {NM_TITLE, MENU_PREFS, MMC_NOP, 0},
    {NM_ITEM, ITEM_SAVE_AS_DEFAULTS, MMC_SAVE_AS_DEFAULTS, 0},
d342 3
d352 27
a379 2

		    DS (kprintf ("AddDTObject win=0x%lx o=0x%lx\n", wo->wo_Window, wo->wo_DataObject));
a380 2

		    DS (kprintf ("syncMenuItems\n"));
d614 1
d628 1
d638 1
d640 4
a643 1
						WA_AutoAdjust, TRUE,
@


39.5
log
@borderless prop gadgets.
@
text
@d39 1
d800 1
a800 1
	    case DTA_Title:
d810 1
@


39.4
log
@*** empty log message ***
@
text
@a60 1
    {PGA_Borderless, FALSE},
d150 3
d664 1
d687 1
@


39.3
log
@*** empty log message ***
@
text
@d130 1
d139 1
d146 1
d149 1
a199 3
    SetMenuItemState (gd, wo, MMC_MINIMIZE, FALSE);
    SetMenuItemState (gd, wo, MMC_NORMAL, FALSE);
    SetMenuItemState (gd, wo, MMC_MAXIMIZE, FALSE);
a494 3
    SetMenuItemState (gd, wo, MMC_MINIMIZE, TRUE);
    SetMenuItemState (gd, wo, MMC_NORMAL, TRUE);
    SetMenuItemState (gd, wo, MMC_MAXIMIZE, TRUE);
@


39.2
log
@*** empty log message ***
@
text
@d11 1
d21 1
a21 1
    Class	*wc_ModelClass;
d40 3
a42 3
    WOA_TopVert,
    WOA_VisVert,
    WOA_TotVert,
d44 3
a46 3
    WOA_TopHoriz,
    WOA_VisHoriz,
    WOA_TotHoriz,
d83 14
a96 14
    struct Window	*wo_Window;
    struct Menu		*wo_Menu;
    struct AppWindow	*wo_AppWindow;
    ULONG		 wo_ObjectID;
    APTR		 wo_UserData;
    struct Gadget	*wo_First;
    Object		*wo_Model;
    Object		*wo_DisplayObj;
    Object		*wo_IC;
    struct MinList	 wo_List;	/* List of gadgets */
    struct Image	*wo_ArrowImg[NUM_ARROWS];
    UBYTE		 wo_Title[128];
    ULONG		*wo_Methods;
    struct DTMethod	*wo_Trigger;
d103 4
a106 4
    UBYTE		 em_Type;        /* NM_XXX from gadtools.h */
    LONG		 em_Label;
    ULONG		 em_Command;
    UWORD		 em_ItemFlags;
d113 36
a148 36
    {NM_TITLE, MENU_PROJECT,		MMC_NOP,		0},
    {NM_ITEM,  ITEM_OPEN,		MMC_OPEN,		0},
    {NM_ITEM,  MSG_NOTHING,		MMC_NOP,		0},
    {NM_ITEM,  ITEM_SAVE_AS,		MMC_SAVEAS,		0},
    {NM_ITEM,  MSG_NOTHING,		MMC_NOP,		0},
    {NM_ITEM,  ITEM_PRINT,		MMC_PRINT,		0},
    {NM_ITEM,  ITEM_ABOUT,		MMC_ABOUT,		0},
    {NM_ITEM,  MSG_NOTHING,		MMC_NOP,		0},
    {NM_ITEM,  ITEM_QUIT,		MMC_QUIT,		0},

    {NM_TITLE, MENU_EDIT,		MMC_NOP,		0},
    {NM_ITEM,  ITEM_MARK,		MMC_MARK,		0},
    {NM_ITEM,  ITEM_COPY,		MMC_COPY,		0},
    {NM_ITEM,  MSG_NOTHING,		MMC_NOP,		0},
    {NM_ITEM,  ITEM_SELECT_ALL,		MMC_SELECTALL,		0},
    {NM_ITEM,  ITEM_CLEAR_SELECTED,	MMC_CLEARSELECTED,	0},

    {NM_TITLE, MENU_SEARCH,		MMC_NOP,		0},
    {NM_ITEM,  ITEM_FIND,		MMC_FIND,		0},
    {NM_ITEM,  ITEM_FIND_NEXT,		MMC_NEXT,		0},
    {NM_ITEM,  MSG_NOTHING,		MMC_NOP,		0},
    {NM_ITEM,  ITEM_GO_TO_LINE,		MMC_GOTO,		0},
    {NM_ITEM,  MSG_NOTHING,		MMC_NOP,		0},
    {NM_ITEM,  ITEM_SET_BOOKMARK,	MMC_SETBOOKMARK,	0},
    {NM_ITEM,  ITEM_GOTO_BOOKMARK,	MMC_GOTOBOOKMARK,	0},

    {NM_TITLE, MENU_WINDOW,		MMC_NOP,		0},
    {NM_ITEM,  ITEM_MINIMIZE,		MMC_MINIMIZE,		0},
    {NM_ITEM,  ITEM_NORMAL,		MMC_NORMAL,		0},
    {NM_ITEM,  ITEM_MAXIMIZE,		MMC_MAXIMIZE,		0},

    {NM_TITLE, MENU_EXTRAS,		MMC_NOP,		0},
    {NM_ITEM,  ITEM_EXECUTE_COMMAND,	MMC_EXECUTE,		0},

    {NM_END,   MSG_NOTHING,		MMC_NOP,		0},
};
d152 1
a152 1
BOOL SetMenuItemState (struct GlobalData *gd, struct WindowObj *wo, ULONG command, BOOL state)
d159 17
a175 17
        while (m)
        {
            mi = m->FirstItem;
            while (mi)
            {
                if (((ULONG) GTMENUITEM_USERDATA (mi)) == command)
                {
                    if (state)
                        mi->Flags |= ITEMENABLED;
                    else
                        mi->Flags &= ~ITEMENABLED;
                    return (TRUE);
                }
                mi = mi->NextItem;
            }
            m = m->NextMenu;
        }
d182 1
a182 1
void NoObjectLoaded (struct GlobalData *gd, struct WindowObj *wo)
d184 16
a199 15
    SetMenuItemState (gd, wo, MMC_SAVEAS,		FALSE);
    SetMenuItemState (gd, wo, MMC_PRINT,		FALSE);
    SetMenuItemState (gd, wo, MMC_MARK,			FALSE);
    SetMenuItemState (gd, wo, MMC_COPY,			FALSE);
    SetMenuItemState (gd, wo, MMC_SELECTALL,		FALSE);
    SetMenuItemState (gd, wo, MMC_CLEARSELECTED,	FALSE);
    SetMenuItemState (gd, wo, MMC_FIND,			FALSE);
    SetMenuItemState (gd, wo, MMC_NEXT,			FALSE);
    SetMenuItemState (gd, wo, MMC_GOTO,			FALSE);
    SetMenuItemState (gd, wo, MMC_SETBOOKMARK,		FALSE);
    SetMenuItemState (gd, wo, MMC_GOTOBOOKMARK,		FALSE);
    SetMenuItemState (gd, wo, MMC_MINIMIZE,		FALSE);
    SetMenuItemState (gd, wo, MMC_NORMAL,		FALSE);
    SetMenuItemState (gd, wo, MMC_MAXIMIZE,		FALSE);
    SetMenuItemState (gd, wo, MMC_EXECUTE,		FALSE);
d246 1
a246 1
				TAG_DONE)))
d272 2
a273 2
		cl->cl_Dispatcher.h_Data  = wc;
		cl->cl_UserData           = (ULONG) gd;
a336 1
		ULONG i;
d338 2
a339 1
		DoMethod (o, OM_ADDMEMBER, (LONG) wom->wom_Object);
d341 1
a341 2
					   ICA_TARGET, (ULONG) wom->wom_Object,
					   ICA_MAP, (ULONG) wom->wom_Map,
a344 30
		    wo->wo_DisplayObj = wom->wom_Object;
		    AddDTObject (wo->wo_Window, NULL, wo->wo_DisplayObj, -1);
		    RefreshDTObjectA (wo->wo_DisplayObj, wo->wo_Window, NULL, NULL);

		    wo->wo_Trigger = NULL;
		    if (wo->wo_Methods = GetDTMethods (wo->wo_DisplayObj))
		    {
			for (i = 0; wo->wo_Methods[i] != ~0; i++)
			{
			    switch (wo->wo_Methods[i])
			    {
				case DTM_SELECT:
				    SetMenuItemState (gd, wo, MMC_MARK, TRUE);
				    break;

				case DTM_CLEARSELECTED:
				    SetMenuItemState (gd, wo, MMC_CLEARSELECTED, TRUE);
				    break;

				case DTM_COPY:
				    SetMenuItemState (gd, wo, MMC_COPY, TRUE);
				    break;

				case DTM_PRINT:
				    SetMenuItemState (gd, wo, MMC_PRINT, TRUE);
				    break;

				case DTM_WRITE:
				    SetMenuItemState (gd, wo, MMC_SAVEAS, TRUE);
				    break;
d346 2
a347 28
#if 0
				case DTM_TRIGGER:
				    DM (kprintf ("Trigger methods\n"));
				    if (wo->wo_Trigger = GetDTTriggerMethods (wo->wo_DisplayObj))
				    {
					struct NewMenu *nm;
					ULONG cnt;

					for (j = 0; wo->wo_Trigger[j].dtm_Label; j++);
					DM (kprintf ("%ld trigger commands\n", j));

					if (nm = AllocVec (sizeof (struct NewMenu) * (j + 2), MEMF_CLEAR))
					{
					    for (j = 0; wo->wo_Trigger[j].dtm_Label; j++)
					    {
						DM (kprintf ("  %s\n", wo->wo_Trigger[j].dtm_Command));
					    }
					    FreeVec (nm);
					}
				    }
				    break;
#endif
			    }
			}
		    }
		    SetMenuItemState (gd, wo, MMC_MINIMIZE,	TRUE);
		    SetMenuItemState (gd, wo, MMC_NORMAL,	TRUE);
		    SetMenuItemState (gd, wo, MMC_MAXIMIZE,	TRUE);
d349 2
d356 1
a356 1
	    if (wo->wo_DisplayObj)
d358 7
a364 3
		NoObjectLoaded (gd, wo);
		RemoveDTObject (wo->wo_Window, wo->wo_DisplayObj);
		DoMethod (o, OM_REMMEMBER, (LONG) wo->wo_DisplayObj);
d367 4
a370 1
		wo->wo_DisplayObj = NULL;
d408 5
a412 1
		CloseWindow (wo->wo_Window);
d438 63
d537 3
a539 3
    {WOA_TopVert, PGA_Top},
    {WOA_VisVert, PGA_Visible},
    {WOA_TotVert, PGA_Total},
d545 3
a547 3
    {WOA_TopHoriz, PGA_Top},
    {WOA_VisHoriz, PGA_Visible},
    {WOA_TotHoriz, PGA_Total},
d555 3
a557 3
    {PGA_Top,		WOA_TopVert},
    {PGA_Visible,	WOA_VisVert},
    {PGA_Total,		WOA_TotVert},
d563 3
a565 3
    {PGA_Top,		WOA_TopHoriz},
    {PGA_Visible,	WOA_VisHoriz},
    {PGA_Total,		WOA_TotHoriz},
d590 3
d598 1
a598 1
    title = (STRPTR) GetTagData (WOA_Title, NULL, attrs);
d726 8
d797 1
a797 9
	    case WOA_ObjectID:
		wo->wo_ObjectID = tidata;
		break;

	    case WOA_UserData:
		wo->wo_UserData = (APTR) tidata;
		break;

	    case WOA_Title:
d805 4
a811 8
#if 0
    /* If there was a change, then update the objects */
    if (retval && wo->wo_First)
    {
	RefreshGList (wo->wo_First, wo->wo_Window, NULL, -1);
    }
#endif

d833 1
a833 13
	case WOA_ObjectID:
	    *msg->opg_Storage = (ULONG) wo->wo_ObjectID;
	    break;

	case WOA_UserData:
	    *msg->opg_Storage = (ULONG) wo->wo_UserData;
	    break;

	case WOA_DisplayObj:
	    *msg->opg_Storage = (ULONG) wo->wo_DisplayObj;
	    break;

	case WOA_Title:
@


39.1
log
@added menu smarts
@
text
@d37 2
d335 1
a335 1
		ULONG i, j;
a355 1
				    DM (kprintf ("select\n"));
a359 1
				    DM (kprintf ("clear selected\n"));
a363 1
				    DM (kprintf ("copy\n"));
a367 1
				    DM (kprintf ("print\n"));
a370 5
				case DTM_GOTO:
				    DM (kprintf ("goto\n"));
				    SetMenuItemState (gd, wo, MMC_GOTO, TRUE);
				    break;

a371 1
				    DM (kprintf ("write\n"));
d534 3
a536 3
    {PGA_Top, WOA_TopVert},
    {PGA_Visible, WOA_VisVert},
    {PGA_Total, WOA_TotVert},
d542 3
a544 3
    {PGA_Top, WOA_TopHoriz},
    {PGA_Visible, WOA_VisHoriz},
    {PGA_Total, WOA_TotHoriz},
a749 1
#if 1
a750 4
#else
	    /* Perhaps there is a need to refresh the group gadget now. */
	    retval += DoSuperMethodA (cl, o, msg);
#endif
a777 1
		DB (kprintf ("WOA_Title, %s\n", wo->wo_Title));
d784 1
d790 1
@


39.0
log
@initial RCS
@
text
@d10 1
d92 2
d149 51
d333 1
d345 67
d419 1
d712 2
d715 1
@
