head     39.16;
branch   ;
access   ;
symbols  ;
locks    davidj:39.16; strict;
comment  @ * @;


39.16
date     93.06.17.14.11.18;  author davidj;  state Exp;
branches ;
next     39.15;

39.15
date     93.04.14.14.59.24;  author davidj;  state Exp;
branches ;
next     39.14;

39.14
date     93.02.15.12.48.16;  author davidj;  state Exp;
branches ;
next     39.13;

39.13
date     92.12.02.13.43.55;  author davidj;  state Exp;
branches ;
next     39.12;

39.12
date     92.11.30.15.17.03;  author davidj;  state Exp;
branches ;
next     39.11;

39.11
date     92.10.28.14.49.34;  author davidj;  state Exp;
branches ;
next     39.10;

39.10
date     92.08.27.16.03.09;  author davidj;  state Exp;
branches ;
next     39.9;

39.9
date     92.08.13.11.37.41;  author davidj;  state Exp;
branches ;
next     39.8;

39.8
date     92.08.03.16.59.58;  author davidj;  state Exp;
branches ;
next     39.7;

39.7
date     92.07.28.15.03.36;  author davidj;  state Exp;
branches ;
next     39.6;

39.6
date     92.07.14.15.50.29;  author davidj;  state Exp;
branches ;
next     39.5;

39.5
date     92.07.01.00.46.26;  author davidj;  state Exp;
branches ;
next     39.4;

39.4
date     92.06.23.03.10.54;  author davidj;  state Exp;
branches ;
next     39.3;

39.3
date     92.06.22.03.58.25;  author davidj;  state Exp;
branches ;
next     39.2;

39.2
date     92.06.19.04.34.52;  author davidj;  state Exp;
branches ;
next     39.1;

39.1
date     92.06.05.04.35.10;  author davidj;  state Exp;
branches ;
next     39.0;

39.0
date     92.06.02.08.52.49;  author davidj;  state Exp;
branches ;
next     ;


desc
@initial RCS
@


39.16
log
@*** empty log message ***
@
text
@/* multiview.c
 *
 */

#include "multiview.h"

/*****************************************************************************/

LONG OpenNewData (struct GlobalData * gd, ULONG stype, ULONG unit)
{
    struct DataType *dtn;
    LONG retval = 0L;
    BPTR lock;

    /* Remember the source type */
    if ((gd->gd_SourceType = stype) == DTST_FILE)
	unit = (ULONG) gd->gd_NameBuffer;

    /* Show that we're loading a new object */
    setattrs (gd, gd->gd_WindowObj, WOA_Title, (ULONG) GetString (gd, MV_TITLE_LOADING), TAG_DONE);
    setwindowpointer (gd, window, WA_BusyPointer, TRUE, WA_PointerDelay, TRUE, TAG_DONE);

    if (gd->gd_DataObject)
    {
	/* Get rid of the object */
	if (gd->gd_Flags & GDF_BITMAP)
	{
	    CloseEnvironment (gd, 2);
	}
	else
	{
	    /* Remove the object from the window */
	    DoMethod ((Object *) gd->gd_WindowObj, WOM_REMVIEW, (ULONG) gd->gd_DataObject);

	    /* Erase its rectangle */
	    EraseRect (window->RPort,
		       window->BorderLeft,
		       window->BorderTop,
		       window->Width - window->BorderRight - 1,
		       window->Height - window->BorderBottom - 1);

	    /* Dispose of the object */
	    DisposeDTObject (gd->gd_DataObject);
	}
    }

    /* Clear the top */
    gd->gd_TotVert = gd->gd_TotHoriz = 0;

    /* Get the new object */
    if (gd->gd_DataObject = NewDTObject ((STRPTR) unit,
					DTA_ARexxPortName,	(ULONG)gd->gd_ARexxPortName,
					DTA_SourceType,		gd->gd_SourceType,
					DTA_TextAttr,		(ULONG) &gd->gd_TextAttr,
					GA_Immediate,		TRUE,
					GA_RelVerify,		TRUE,
					TAG_DONE))
    {
	/* Try opening the environment */
	if (OpenEnvironment (gd))
	{
	    /* Show success */
	    retval = 1L;

	    /* Clear the scrollers */
	    setgadgetattrs (gd, (struct Gadget *) gd->gd_WindowObj, gd->gd_Window,
			    DTA_TopVert, 0L,
			    DTA_TopHoriz, 0L,
			    TAG_DONE);
	}
	else
	{
	    /* We have problems!!!! */
	    PrintF (gd, 1, gd->gd_SecondaryResult, NULL);
	    gd->gd_Going = FALSE;
	}
    }
    else
    {
	/* Remember the error message */
	gd->gd_SecondaryResult = IoErr ();

	/* Lock the name given */
	if (lock = Lock (gd->gd_NameBuffer, ACCESS_READ))
	{
	    /* Get the object type */
	    if (dtn = ObtainDataTypeA (DTST_FILE, (APTR) lock, NULL))
	    {
		/* If the object type is a directory, then we will bring up the file requester. */
		if (Stricmp (dtn->dtn_Header->dth_Name, "directory") == 0)
		    retval = 2;

		/* Done with the datatype, so release it */
		ReleaseDataType (dtn);
	    }
	    UnLock (lock);
	}

	if (retval == 0)
	{
	    /* Show the error message */
	    PrintF (gd, 2, gd->gd_SecondaryResult, FilePart (gd->gd_NameBuffer));

	    /* Clear the sliders */
	    setgadgetattrs (gd, (struct Gadget *) gd->gd_WindowObj, gd->gd_Window,
			    DTA_TopVert, 0L,
			    DTA_TopHoriz, 0L,
			    DTA_TotalVert, 0L,
			    DTA_TotalHoriz, 0L,
			    TAG_DONE);
	}
	else
	{
	    setattrs (gd, gd->gd_WindowObj, WOA_Title, (ULONG) GetString (gd, MV_TITLE_MULTIVIEW), TAG_DONE);
	}

	/* Clear the window pointer */
	setwindowpointer (gd, window, WA_Pointer, NULL, TAG_DONE);

	/* If we don't have a window, then we might as well stop right now. */
	if (!window)
	    gd->gd_Going = FALSE;
    }

    return (retval);
}

/*****************************************************************************/

ULONG frameobject (struct GlobalData * gd)
{
    struct FrameInfo *fri = &gd->gd_FrameInfo;
    struct DisplayInfo di;
    struct dtFrameBox dtf;
    ULONG modeid;

    /* Get the display information */
    modeid = GetVPModeID (&(gd->gd_Screen->ViewPort));
    GetDisplayInfoData (NULL, (APTR) & di, sizeof (struct DisplayInfo), DTAG_DISP, modeid);

    /* Fill in the frame info */
    fri->fri_PropertyFlags = di.PropertyFlags;
    fri->fri_Resolution = *(&di.Resolution);
    fri->fri_RedBits = di.RedBits;
    fri->fri_GreenBits = di.GreenBits;
    fri->fri_BlueBits = di.BlueBits;
    fri->fri_Dimensions.Width = gd->gd_Screen->Width;
    fri->fri_Dimensions.Height = gd->gd_Screen->Height;
    fri->fri_Dimensions.Depth = gd->gd_Screen->BitMap.Depth;
    fri->fri_Screen = gd->gd_Screen;
    fri->fri_ColorMap = gd->gd_Screen->ViewPort.ColorMap;

    /* Send the message */
    dtf.MethodID = DTM_FRAMEBOX;
    dtf.dtf_ContentsInfo = &gd->gd_FrameInfo;
    dtf.dtf_SizeFrameInfo = sizeof (struct FrameInfo);
    dtf.dtf_FrameFlags = FRAMEF_SPECIFY;
    return (DoDTMethodA (gd->gd_DataObject, gd->gd_Window, NULL, &dtf));
}

/*****************************************************************************/

void SetDataObjectAttrs (struct GlobalData * gd)
{
    if (gd->gd_DataObject)
    {
	DoMethod ((Object *) gd->gd_WindowObj, WOM_ADDVIEW, (ULONG) gd->gd_DataObject, NULL);
    }
}
@


39.15
log
@*** empty log message ***
@
text
@d51 7
a57 6
    if (gd->gd_DataObject = newdtobject (gd, (STRPTR) unit,
					 DTA_SourceType,	gd->gd_SourceType,
					 DTA_TextAttr,		(ULONG) &gd->gd_TextAttr,
					 GA_Immediate,		TRUE,
					 GA_RelVerify,		TRUE,
					 TAG_DONE))
@


39.14
log
@added ARexx support and fixed stale variables
@
text
@a8 5
#define	DB(x)	;
#define	DC(x)	;

/*****************************************************************************/

d51 5
a55 6
    DC (kprintf ("Create New Object\n"));
    if (gd->gd_DataObject = newdtobject (gd, unit,
					 DTA_SourceType, gd->gd_SourceType,
					 DTA_TextAttr, (ULONG) & gd->gd_TextAttr,
					 GA_Immediate, TRUE,
					 GA_RelVerify, TRUE,
a58 1
	DC (kprintf ("OpenEnvironment\n"));
a64 1
	    DC (kprintf ("SetGadgetAttrs (tops=0)\n"));
a79 1
	DC (kprintf ("couldn't create new object\n"));
a123 1
    DC (kprintf ("OpenNewData returns %ld\n", retval));
a124 48
}

/*****************************************************************************/

/* Martin Taillefer's block pointer */
static UWORD chip Block_sdata[] =
{
    0x0000, 0x0000,		/* reserved, must be NULL */

    0x0000, 0x0100,
    0x0100, 0x0280,
    0x0380, 0x0440,
    0x0100, 0x0280,
    0x0100, 0x0ee0,
    0x0000, 0x2828,
    0x2008, 0x5834,
    0x783c, 0x8002,
    0x2008, 0x5834,
    0x0000, 0x2828,
    0x0100, 0x0ee0,
    0x0100, 0x0280,
    0x0380, 0x0440,
    0x0100, 0x0280,
    0x0000, 0x0100,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,

    0x0000, 0x0000,		/* reserved, must be NULL */
};

VOID SetBlockPointer (struct GlobalData * gd, struct Window * win)
{
    SetPointer (win, Block_sdata, 32, 16, -8, -7);
@


39.13
log
@no changes.
@
text
@d10 1
a10 1
#define	DR(x)	;
d14 1
a14 1
LONG OpenNewData (struct GlobalData * gd, ULONG stype)
d21 2
a22 1
    gd->gd_SourceType = stype;
d56 2
a57 1
    if (gd->gd_DataObject = newdtobject (gd, gd->gd_NameBuffer,
d65 1
d72 1
d88 1
d133 1
a224 681
    }
}

/*****************************************************************************/

BOOL ProcessCommand (struct GlobalData * gd, ULONG id, struct IntuiMessage * imsg)
{
    struct Window *win = gd->gd_Window;
    ULONG left, top, width, height;
    struct DTSpecialInfo *si;
    struct dtGeneral dtg;
    BOOL retval = FALSE;
    BOOL change = FALSE;
    BOOL clears = FALSE;
    BOOL clearp = TRUE;

    if (!id)
	return FALSE;

    setwindowpointer (gd, window, WA_BusyPointer, TRUE, WA_PointerDelay, TRUE, TAG_DONE);

    switch (id)
    {
	    /* PROJECT menu */
	case MMC_OPEN:
	    if (FileRequest (gd, 0, GetString (gd, MV_TITLE_SELECT_FILE_TO_OPEN), GetString (gd, MV_LABEL_OPEN), gd->gd_NameBuffer))
	    {
		OpenNewData (gd, DTST_FILE);
		retval = TRUE;
	    }
	    break;

	case MMC_SAVEAS:
	    if (gd->gd_DataObject)
	    {
		SaveObject (gd, DTWM_RAW);
		clears = TRUE;
	    }
	    break;

	case MMC_PRINT:
	    if (gd->gd_DataObject)
		PrintObject (gd, 0);
	    break;

	case MMC_ABOUT:
	    AboutObject (gd);
	    break;

	case MMC_QUIT:
	    gd->gd_Going = FALSE;
	    break;

	    /* EDIT menu */
	case MMC_MARK:
	    if (gd->gd_DataObject)
	    {
		si = (struct DTSpecialInfo *) G (gd->gd_DataObject)->SpecialInfo;
		si->si_Flags |= DTSIF_DRAGSELECT;
		SetBlockPointer (gd, win);
		clearp = FALSE;
	    }
	    break;

	case MMC_COPY:
	    if (gd->gd_DataObject)
	    {
		dtg.MethodID = DTM_COPY;
		if (!(clears = DoDTMethodA (gd->gd_DataObject, win, NULL, &dtg)))
		    DisplayBeep (NULL);
	    }
	    break;

	case MMC_CLEARSELECTED:
	    if (gd->gd_DataObject)
	    {
		dtg.MethodID = DTM_CLEARSELECTED;
		DoDTMethodA (gd->gd_DataObject, win, NULL, &dtg);
	    }
	    break;

	case MMC_SHOWCLIP:
	    OpenNewData (gd, DTST_CLIPBOARD);
	    break;

	    /* SEARCH menu */
	case MMC_GOTO:
	    break;

	case MMC_SETBOOKMARK:
	    break;

	case MMC_GOTOBOOKMARK:
	    break;


	    /* WINDOW menu */
	case MMC_MINIMIZE:
	    left = win->LeftEdge;
	    top = win->TopEdge;
	    width = win->MinWidth;
	    height = win->MinHeight;
	    change = TRUE;
	    break;

	case MMC_NORMAL:
	    left = win->LeftEdge;
	    top = win->TopEdge;
	    width = 0;
	    height = 0;
	    if (gd->gd_DataObject)
	    {
		getdtattrs (gd, gd->gd_DataObject,
			    DTA_NominalHoriz, &width,
			    DTA_NominalVert, &height,
			    TAG_DONE);
	    }

	    if (width == 0)
		width = gd->gd_TextFont->tf_XSize * 80;
	    if (height == 0)
		height = gd->gd_TextFont->tf_YSize * 24;
	    width += 4 + win->BorderLeft + win->BorderRight;
	    height += 2 + win->BorderTop + win->BorderBottom;
	    change = TRUE;
	    break;

	case MMC_MAXIMIZE:
	    left = 0;
	    top = 0;
	    width = win->WScreen->Width;
	    height = win->WScreen->Height;
	    change = TRUE;
	    break;

	    /* EXTRAS menu */
	case MMC_EXECUTE:
	    break;

	case MMC_SAVE_AS_DEFAULTS:
	    SaveSnapShot (gd);
	    break;
    }

    if (clears)
    {
	dtg.MethodID = DTM_CLEARSELECTED;
	DoDTMethodA (gd->gd_DataObject, win, NULL, &dtg);
    }

    if (change)
	ChangeWindowBox (win, left, top, width, height);

    if (clearp)
	setwindowpointer (gd, window, WA_Pointer, NULL, TAG_DONE);

    return (retval);
}

/*****************************************************************************/

VOID Navigate (struct GlobalData * gd, LONG cmd, BOOL needvisual)
{
    LONG otoph, toph, vish, toth;
    LONG otopv, topv, visv, totv;

    if (!gd->gd_DataObject)
	return;

    if (needvisual)
    {
	/* Get the current values from the data object */
	getdtattrs (gd, gd->gd_DataObject,
		    DTA_TopVert,	&topv,
		    DTA_VisibleVert,	&visv,
		    DTA_TotalVert,	&totv,
		    DTA_TopHoriz,	&toph,
		    DTA_VisibleHoriz,	&vish,
		    DTA_TotalHoriz,	&toth,
		    TAG_DONE);

	/* Check for bogus values */
	if ((topv < 0) || (toph < 0) || (totv == 0) || (toth == 0))
	{
	    topv = gd->gd_TopVert;
	    visv = gd->gd_VisVert;
	    totv = gd->gd_TotVert;

	    toph = gd->gd_TopHoriz;
	    vish = gd->gd_VisHoriz;
	    toth = gd->gd_TotHoriz;
	}

	otoph = toph;
	otopv = topv;
    }

    switch (cmd)
    {
	case AC_TOP:
	    topv = 0;
	    break;

	case AC_BOTTOM:
	    topv = totv - visv;
	    break;

	case AC_FAR_LEFT:
	    toph = 0;
	    break;

	case AC_FAR_RIGHT:
	    toph = toth - vish;
	    break;

	case AC_UNIT_UP:
	    topv--;
	    break;

	case AC_UNIT_DOWN:
	    topv++;
	    break;

	case AC_UNIT_LEFT:
	    toph--;
	    break;

	case AC_UNIT_RIGHT:
	    toph++;
	    break;

	case AC_PAGE_UP:
	    topv -= (visv - 1);
	    break;

	case AC_PAGE_DOWN:
	    topv += (visv - 1);
	    break;

	case AC_PAGE_LEFT:
	    toph -= (vish - 1);
	    break;

	case AC_PAGE_RIGHT:
	    toph += (vish - 1);
	    break;

	case AC_FIELD_NEXT:
	    gd->gd_Trigger.dtt_Function = STM_NEXT_FIELD;
	    DoDTMethodA (gd->gd_DataObject, window, NULL, &gd->gd_Trigger);
	    break;

	case AC_FIELD_PREV:
	    gd->gd_Trigger.dtt_Function = STM_PREV_FIELD;
	    DoDTMethodA (gd->gd_DataObject, window, NULL, &gd->gd_Trigger);
	    break;

	case AC_ACTIVATE_FIELD:
	    gd->gd_Trigger.dtt_Function = STM_ACTIVATE_FIELD;
	    DoDTMethodA (gd->gd_DataObject, window, NULL, &gd->gd_Trigger);
	    break;

	case AC_NODE_NEXT:
	    gd->gd_Trigger.dtt_Function = STM_BROWSE_NEXT;
	    DoDTMethodA (gd->gd_DataObject, window, NULL, &gd->gd_Trigger);
	    break;

	case AC_NODE_PREV:
	    gd->gd_Trigger.dtt_Function = STM_BROWSE_PREV;
	    DoDTMethodA (gd->gd_DataObject, window, NULL, &gd->gd_Trigger);
	    break;

	case AC_RETRACE:
	    gd->gd_Trigger.dtt_Function = STM_RETRACE;
	    DoDTMethodA (gd->gd_DataObject, window, NULL, &gd->gd_Trigger);
	    break;
    }

    if (needvisual)
    {
	if (topv < 0)
	    topv = 0;
	if (toph < 0)
	    toph = 0;
	if (topv > totv - visv)
	    topv = totv - visv;
	if (toph > toth - vish)
	    toph = toth - vish;

	if ((topv != otopv) || (toph != otoph))
	{
	    /* Do the scrollers first, because they are faster */
	    setgadgetattrs (gd, gd->gd_VGad, gd->gd_Window, PGA_Top, topv, TAG_DONE);
	    setgadgetattrs (gd,	gd->gd_HGad, gd->gd_Window, PGA_Top, toph, TAG_DONE);

	    /* Now tell the data type to scroll */
	    DR (kprintf ("navigate\n"));
	    setgadgetattrs (gd, (struct Gadget *)gd->gd_DataObject, gd->gd_Window,
			    DTA_TopVert,	topv,
			    DTA_TopHoriz,	toph,
			    TAG_DONE);

	    /* Remember these values */
	    gd->gd_TopVert  = topv;
	    gd->gd_TopHoriz = toph;
	}
    }
}

/*****************************************************************************/

void HandleEvents (struct GlobalData * gd)
{
    struct Gadget *agad = NULL;
    struct MenuItem *menuitem;
    struct IntuiMessage *imsg;
    struct AppMessage *amsg;
    struct WBArg *wbArg;
    LONG topv, toph;
    BOOL reply;
    ULONG siga;
    ULONG sigw;
    ULONG sigr;
    ULONG sigp;

    BOOL refresh = FALSE;
    BOOL update = FALSE;
    BOOL quit = FALSE;
    BOOL newt = FALSE;

    struct TagItem *tstate;
    struct TagItem *tags;
    struct TagItem *tag;
    ULONG tidata;

    sigw = 1L << gd->gd_IDCMPPort->mp_SigBit;
    siga = 1L << gd->gd_AWPort->mp_SigBit;

    while (gd->gd_Going)
    {
	/* Handle scrolling here */
	if (update)
	{
	    update = FALSE;

	    /* Get the latest values from the scrollers */
	    GetAttr (PGA_Top, gd->gd_HGad, (ULONG *) & toph);
	    GetAttr (PGA_Top, gd->gd_VGad, (ULONG *) & topv);

	    /* Send the values */
	    DR (kprintf ("set wo\n"));
	    setgadgetattrs (gd, (struct Gadget *) gd->gd_WindowObj, gd->gd_Window,
			    DTA_TopVert,	topv,
			    DTA_TopHoriz,	toph,
			    TAG_DONE);
	}

	/* Time to refresh the object? */
	if (newt)
	{
	    newt = FALSE;
	    DR (kprintf ("set do\n"));
	    setgadgetattrs (gd, (struct Gadget *) gd->gd_DataObject, gd->gd_Window,
			    DTA_TopVert,	topv,
			    DTA_TopHoriz,	toph,
			    TAG_DONE);
	}

	/* Handle object refresh here */
	if (refresh)
	{
	    refresh = FALSE;
	    DR (kprintf ("refresh\n"));
	    RefreshGList ((struct Gadget *) gd->gd_DataObject, window, NULL, 1);
	}

	/* Wait for something to happen */
	sigp = ((gd->gd_PrintWin) ? (1L << gd->gd_PrintWin->UserPort->mp_SigBit) : NULL);
	sigr = Wait (siga | sigw | sigp | SIGBREAKF_CTRL_C);

	if ((sigr & sigp) && gd->gd_PrintWin)
	{
	    if (SysReqHandler (gd->gd_PrintWin, NULL, FALSE) == 0)
		DoMethod (gd->gd_DataObject, DTM_ABORTPRINT, NULL);
	}

	/* User break */
	if (sigr & SIGBREAKF_CTRL_C)
	    gd->gd_Going = FALSE;

	/* AppWindow messages */
	if (sigr & siga)
	{
	    ActivateWindow (window);
	    setwindowpointer (gd, window, WA_BusyPointer, TRUE, WA_PointerDelay, TRUE, TAG_DONE);

	    /* Pull all the messages from the AppWindow port */
	    while (amsg = (struct AppMessage *) GetMsg (gd->gd_AWPort))
	    {
		/* Any arguments? */
		if (amsg->am_NumArgs)
		{
		    wbArg = amsg->am_ArgList;
		    NameFromLock (wbArg->wa_Lock, gd->gd_NameBuffer, NAMEBUFSIZE);
		    AddPart (gd->gd_NameBuffer, wbArg->wa_Name, NAMEBUFSIZE);

		    /*
		     * Try opening the data.  If it is a directory, and there isn't a class to handle it then popup in it.
		     */
		    if (OpenNewData (gd, DTST_FILE) == 2)
			if (FileRequest (gd, 0, GetString (gd, MV_TITLE_SELECT_FILE_TO_OPEN), GetString (gd, MV_LABEL_OPEN), gd->gd_NameBuffer))
			    OpenNewData (gd, DTST_FILE);
		}
		ReplyMsg ((struct Message *) amsg);
	    }
	}

	/* Handle Intuition messages */
	while (imsg = (struct IntuiMessage *) GetMsg (gd->gd_IDCMPPort))
	{
	    reply = TRUE;
	    switch (imsg->Class)
	    {
		case IDCMP_GADGETDOWN:
		    /* Remember the active gadget */
		    agad = (struct Gadget *) imsg->IAddress;

		    /* Get the current top values */
		    getdtattrs (gd, gd->gd_DataObject, DTA_TopVert, &topv, DTA_TopHoriz, &toph, TAG_DONE);
		    break;

		case IDCMP_INTUITICKS:
		case IDCMP_MOUSEMOVE:
		    if (agad && (agad->Flags & GFLG_SELECTED))
		    {
			switch (agad->GadgetID)
			{
			    case LEFT_GID:
				Navigate (gd, AC_UNIT_LEFT, TRUE);
				break;

			    case RIGHT_GID:
				Navigate (gd, AC_UNIT_RIGHT, TRUE);
				break;

			    case UP_GID:
				Navigate (gd, AC_UNIT_UP, TRUE);
				break;

			    case DOWN_GID:
				Navigate (gd, AC_UNIT_DOWN, TRUE);
				break;

			    case HORIZ_GID:
			    case VERT_GID:
				update = TRUE;
				break;
			}
		    }
		    break;

		case IDCMP_GADGETUP:
		    update = TRUE;
		    agad = NULL;
		    break;

		case IDCMP_IDCMPUPDATE:
		    /* Get the latest values from the scrollers */
		    GetAttr (PGA_Top, gd->gd_HGad, (ULONG *) &toph);
		    GetAttr (PGA_Top, gd->gd_VGad, (ULONG *) &topv);

		    tstate = tags = (struct TagItem *) imsg->IAddress;
		    while (tag = NextTagItem (&tstate))
		    {
			tidata = tag->ti_Data;
			switch (tag->ti_Tag)
			{
			    case DTA_TopVert:
				if (!agad)
				{
				    newt = TRUE;
				    topv = tidata;
				}
			    case DTA_VisibleVert:
			    case DTA_TotalVert:
				if (agad)
				    tag->ti_Tag = TAG_IGNORE;
				break;

			    case DTA_TopHoriz:
				if (!agad)
				{
				    newt = TRUE;
				    toph = tidata;
				}
			    case DTA_VisibleHoriz:
			    case DTA_TotalHoriz:
				if (agad)
				    tag->ti_Tag = TAG_IGNORE;
				break;

			    case DTA_ErrorLevel:
				gd->gd_SecondaryResult = GetTagData (DTA_ErrorNumber, NULL, tags);
				PrintF (gd, 2, gd->gd_SecondaryResult, (STRPTR) GetTagData (DTA_ErrorString, NULL, tags));
				break;

			    case DTA_PrinterStatus:
				PrintComplete (gd);
				if (tidata)
				    PrintF (gd, 1, 990 + tidata, NULL);
				if (quit)
				    gd->gd_Going = FALSE;
				break;

			    case DTA_Sync:
				refresh = TRUE;
				break;

			    case DTA_Busy:
				if (tidata)
				    setwindowpointer (gd, gd->gd_Window, WA_BusyPointer, TRUE, WA_PointerDelay, TRUE, TAG_DONE);
				else
				    setwindowpointer (gd, gd->gd_Window, WA_Pointer, NULL, TAG_DONE);
				break;
			}
		    }
		    SetGadgetAttrsA ((struct Gadget *) gd->gd_WindowObj, gd->gd_Window, NULL, tags);
		    break;

		case IDCMP_MENUPICK:
		    if (imsg->Code != MENUNULL)
		    {
			menuitem = ItemAddress (imsg->IDCMPWindow->MenuStrip, imsg->Code);

			ReplyMsg ((struct Message *) imsg);
			reply = FALSE;

			ProcessCommand (gd, (ULONG) MENU_USERDATA (menuitem), imsg);
		    }
		    break;

		case IDCMP_CHANGEWINDOW:
		    if (gd->gd_Window->Flags & WFLG_ZOOMED)
		    {
			gd->gd_Prefs.p_Zoom = *((struct IBox *) (&gd->gd_Window->LeftEdge));
		    }
		    else if (gd->gd_Flags & GDF_SNAPSHOT)
		    {
			gd->gd_Prefs.p_Window = *((struct IBox *) (&gd->gd_Window->LeftEdge));
			gd->gd_Prefs.p_Window.Width -= (gd->gd_Window->BorderLeft + gd->gd_Window->BorderRight + 4);
			gd->gd_Prefs.p_Window.Height -= (gd->gd_Window->BorderTop + gd->gd_Window->BorderBottom + 2);
		    }
		    else
		    {
			gd->gd_Prefs.p_Window.Left = gd->gd_Window->LeftEdge;
			gd->gd_Prefs.p_Window.Top = gd->gd_Window->TopEdge;
		    }
		    break;

		case IDCMP_CLOSEWINDOW:
		    gd->gd_Going = FALSE;
		    break;

		case IDCMP_RAWKEY:
		    switch (imsg->Code)
		    {
			    /* Shift Tab */
			case 66:
			    Navigate (gd, AC_FIELD_PREV, FALSE);
			    break;

			    /* Up Arrow */
			case 76:
			    if (imsg->Qualifier & ALTED)
				Navigate (gd, AC_TOP, TRUE);
			    else if (imsg->Qualifier & SHIFTED)
				Navigate (gd, AC_PAGE_UP, TRUE);
			    else
				Navigate (gd, AC_UNIT_UP, TRUE);
			    break;

			    /* Down Arrow */
			case 77:
			    if (imsg->Qualifier & ALTED)
				Navigate (gd, AC_BOTTOM, TRUE);
			    else if (imsg->Qualifier & SHIFTED)
				Navigate (gd, AC_PAGE_DOWN, TRUE);
			    else
				Navigate (gd, AC_UNIT_DOWN, TRUE);
			    break;

			    /* Right Arrow */
			case 78:
			    if (imsg->Qualifier & ALTED)
				Navigate (gd, AC_FAR_RIGHT, TRUE);
			    else if (imsg->Qualifier & SHIFTED)
				Navigate (gd, AC_PAGE_RIGHT, TRUE);
			    else
				Navigate (gd, AC_UNIT_RIGHT, TRUE);
			    break;

			    /* Left Arrow */
			case 79:
			    if (imsg->Qualifier & ALTED)
				Navigate (gd, AC_FAR_LEFT, TRUE);
			    else if (imsg->Qualifier & SHIFTED)
				Navigate (gd, AC_PAGE_LEFT, TRUE);
			    else
				Navigate (gd, AC_UNIT_LEFT, TRUE);
			    break;
		    }
		    break;

		case IDCMP_VANILLAKEY:
		    switch (imsg->Code)
		    {
			    /* Backspace */
			case 8:
			    Navigate (gd, AC_PAGE_UP, TRUE);
			    break;

			    /* Tab */
			case 9:
			    if (imsg->Qualifier & SHIFTED)
				Navigate (gd, AC_FIELD_PREV, FALSE);
			    else
				Navigate (gd, AC_FIELD_NEXT, FALSE);
			    break;

			    /* Return */
			case 13:
			    Navigate (gd, AC_ACTIVATE_FIELD, FALSE);
			    break;

			    /* Space */
			case 32:
			    Navigate (gd, AC_PAGE_DOWN, TRUE);
			    break;

			case 'r':
			case 'R':
			    refresh = TRUE;
			    break;

			case '/':
			    Navigate (gd, AC_RETRACE, FALSE);
			    break;

			case '<':
			    Navigate (gd, AC_NODE_PREV, FALSE);
			    break;

			case '>':
			    Navigate (gd, AC_NODE_NEXT, FALSE);
			    break;

			case 'q':
			case 'Q':
			case 27:
			    gd->gd_Going = FALSE;
			    break;
		    }
		    break;

	    }

	    /* Are we supposed to reply to the message? */
	    if (reply)
	    {
		ReplyMsg ((struct Message *) imsg);
	    }
	}

	if (!gd->gd_Going)
	{
	    if (gd->gd_PIO)
	    {
		DoMethod (gd->gd_DataObject, DTM_ABORTPRINT, NULL);
		gd->gd_Going = quit = TRUE;
	    }
	}
@


39.12
log
@removed window model class
@
text
@d10 1
d515 1
d569 1
d580 1
d591 1
@


39.11
log
@removed model class
@
text
@d132 91
d379 1
a379 1
static Tag model_attrs[] =
d381 43
a423 2
    DTA_Sync,
    WOA_Sync,
d425 59
a483 7
    DTA_TopVert,
    DTA_VisibleVert,
    DTA_TotalVert,

    DTA_TopHoriz,
    DTA_VisibleHoriz,
    DTA_TotalHoriz,
d485 33
a517 2
    ICA_TARGET,
    ICA_MAP,
d519 6
a524 2
    TAG_DONE,
};
d530 1
d535 1
a535 1
    BOOL quit = FALSE;
d542 10
d557 2
a558 1
	if (window && (LAYERREFRESH & window->WLayer->Flags))
d560 11
a570 2
	    BeginRefresh (window);
	    EndRefresh (window, TRUE);
d572 9
a580 5

	sigp = NULL;
	if (gd->gd_PrintWin)
	{
	    sigp = 1L << gd->gd_PrintWin->UserPort->mp_SigBit;
d583 10
a592 1
	sigr = Wait ((1L << gd->gd_IDCMPPort->mp_SigBit) | siga | sigw | sigp | SIGBREAKF_CTRL_C);
d600 1
d604 1
d610 1
d613 1
d621 1
a621 1
		     * Try opening the data.  If it is a directory, and there isn't a class to handle it then popup in it
a623 1
		    {
a624 1
			{
a625 2
			}
		    }
a626 1

d631 1
a633 2
	    gd->gd_IMsg = imsg;

d637 106
a748 1
			gd->gd_IMsg = NULL;
d853 5
d878 1
a878 4
		case IDCMP_IDCMPUPDATE:
		    {
			struct TagItem *tstate, *tags, *tag;
			ULONG tidata;
d880 1
a880 26
			tstate = tags = (struct TagItem *) imsg->IAddress;
			while (tag = NextTagItem (&tstate))
			{
			    tidata = tag->ti_Data;
			    switch (tag->ti_Tag)
			    {
				case DTA_ErrorLevel:
				    gd->gd_SecondaryResult = GetTagData (DTA_ErrorNumber, NULL, tags);
				    PrintF (gd, 2, gd->gd_SecondaryResult, (STRPTR) GetTagData (DTA_ErrorString, NULL, tags));
				    break;

				case DTA_PrinterStatus:
				    PrintComplete (gd);
				    if (tidata)
					PrintF (gd, 1, 990 + tidata, NULL);
				    if (quit)
					gd->gd_Going = FALSE;
				    break;
			    }
			}
#if 1
			SetGadgetAttrsA ((struct Gadget *)gd->gd_WindowObj, gd->gd_Window, NULL, tags);
#endif
		    }
		    break;
	    }
d882 1
d884 1
a884 1
	    gd->gd_IMsg = NULL;
a895 217
}

/*****************************************************************************/

VOID Navigate (struct GlobalData * gd, LONG cmd, BOOL needvisual)
{
    LONG otoph, toph, vish, toth;
    LONG otopv, topv, visv, totv;

    if (!gd->gd_DataObject)
	return;

    if (needvisual)
    {
	getdtattrs (gd, gd->gd_DataObject,
		    DTA_TopVert, &topv,
		    DTA_VisibleVert, &visv,
		    DTA_TotalVert, &totv,
		    DTA_TopHoriz, &toph,
		    DTA_VisibleHoriz, &vish,
		    DTA_TotalHoriz, &toth,
		    TAG_DONE);
	otoph = toph;
	otopv = topv;
    }

    switch (cmd)
    {
	case AC_TOP:
	    topv = 0;
	    break;

	case AC_BOTTOM:
	    topv = totv - visv;
	    break;

	case AC_FAR_LEFT:
	    toph = 0;
	    break;

	case AC_FAR_RIGHT:
	    toph = toth - vish;
	    break;

	case AC_UNIT_UP:
	    topv--;
	    break;

	case AC_UNIT_DOWN:
	    topv++;
	    break;

	case AC_UNIT_LEFT:
	    toph--;
	    break;

	case AC_UNIT_RIGHT:
	    toph++;
	    break;

	case AC_PAGE_UP:
	    topv -= (visv - 1);
	    break;

	case AC_PAGE_DOWN:
	    topv += (visv - 1);
	    break;

	case AC_PAGE_LEFT:
	    toph -= (vish - 1);
	    break;

	case AC_PAGE_RIGHT:
	    toph += (vish - 1);
	    break;

	case AC_FIELD_NEXT:
	    gd->gd_Trigger.dtt_Function = STM_NEXT_FIELD;
	    DoDTMethodA (gd->gd_DataObject, window, NULL, &gd->gd_Trigger);
	    break;

	case AC_FIELD_PREV:
	    gd->gd_Trigger.dtt_Function = STM_PREV_FIELD;
	    DoDTMethodA (gd->gd_DataObject, window, NULL, &gd->gd_Trigger);
	    break;

	case AC_ACTIVATE_FIELD:
	    gd->gd_Trigger.dtt_Function = STM_ACTIVATE_FIELD;
	    DoDTMethodA (gd->gd_DataObject, window, NULL, &gd->gd_Trigger);
	    break;

	case AC_NODE_NEXT:
	    gd->gd_Trigger.dtt_Function = STM_BROWSE_NEXT;
	    DoDTMethodA (gd->gd_DataObject, window, NULL, &gd->gd_Trigger);
	    break;

	case AC_NODE_PREV:
	    gd->gd_Trigger.dtt_Function = STM_BROWSE_PREV;
	    DoDTMethodA (gd->gd_DataObject, window, NULL, &gd->gd_Trigger);
	    break;

	case AC_RETRACE:
	    gd->gd_Trigger.dtt_Function = STM_RETRACE;
	    DoDTMethodA (gd->gd_DataObject, window, NULL, &gd->gd_Trigger);
	    break;
    }

    if (needvisual)
    {
	if (topv < 0)
	    topv = 0;
	if (toph < 0)
	    toph = 0;
	if (topv > totv - visv)
	    topv = totv - visv;
	if (toph > toth - vish)
	    toph = toth - vish;

	if ((topv != otopv) || (toph != otoph))
	{
	    setgadgetattrs (gd, (struct Gadget *) gd->gd_WindowObj, gd->gd_Window,
			    DTA_TopVert, topv,
			    DTA_TopHoriz, toph,
			    TAG_DONE);
	}
    }
}

/*****************************************************************************/

/* Martin Taillefer's block pointer */
static UWORD chip Block_sdata[] =
{
    0x0000, 0x0000,		/* reserved, must be NULL */

    0x0000, 0x0100,
    0x0100, 0x0280,
    0x0380, 0x0440,
    0x0100, 0x0280,
    0x0100, 0x0ee0,
    0x0000, 0x2828,
    0x2008, 0x5834,
    0x783c, 0x8002,
    0x2008, 0x5834,
    0x0000, 0x2828,
    0x0100, 0x0ee0,
    0x0100, 0x0280,
    0x0380, 0x0440,
    0x0100, 0x0280,
    0x0000, 0x0100,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,

    0x0000, 0x0000,		/* reserved, must be NULL */
};

VOID SetBlockPointer (struct GlobalData * gd, struct Window * win)
{

    SetPointer (win, Block_sdata, 32, 16, -8, -7);
}

/*****************************************************************************/

ULONG frameobject (struct GlobalData * gd)
{
    struct FrameInfo *fri = &gd->gd_FrameInfo;
    struct DisplayInfo di;
    struct dtFrameBox dtf;
    ULONG modeid;

    /* Get the display information */
    modeid = GetVPModeID (&(gd->gd_Screen->ViewPort));
    GetDisplayInfoData (NULL, (APTR) & di, sizeof (struct DisplayInfo), DTAG_DISP, modeid);

    /* Fill in the frame info */
    fri->fri_PropertyFlags = di.PropertyFlags;
    fri->fri_Resolution = *(&di.Resolution);
    fri->fri_RedBits = di.RedBits;
    fri->fri_GreenBits = di.GreenBits;
    fri->fri_BlueBits = di.BlueBits;
    fri->fri_Dimensions.Width = gd->gd_Screen->Width;
    fri->fri_Dimensions.Height = gd->gd_Screen->Height;
    fri->fri_Dimensions.Depth = gd->gd_Screen->BitMap.Depth;
    fri->fri_Screen = gd->gd_Screen;
    fri->fri_ColorMap = gd->gd_Screen->ViewPort.ColorMap;

    /* Send the message */
    dtf.MethodID = DTM_FRAMEBOX;
    dtf.dtf_ContentsInfo = &gd->gd_FrameInfo;
    dtf.dtf_SizeFrameInfo = sizeof (struct FrameInfo);
    dtf.dtf_FrameFlags = FRAMEF_SPECIFY;
    return (DoDTMethodA (gd->gd_DataObject, gd->gd_Window, NULL, &dtf));
}

/*****************************************************************************/

void SetDataObjectAttrs (struct GlobalData * gd)
{

    if (gd->gd_DataObject)
	DoMethod ((Object *) gd->gd_WindowObj, WOM_ADDVIEW, (ULONG) gd->gd_DataObject, NULL);
@


39.10
log
@now clears selected after DTM_COPY or DTM_WRITE.
@
text
@a9 2
#define	DK(x)	;
#define	DW(x)	;
d24 1
d28 20
a47 20
        /* Get rid of the object */
        if (gd->gd_Flags & GDF_BITMAP)
        {
            CloseEnvironment (gd, 2);
        }
        else
        {
            /* Remove the object from the window */
            DoMethod ((Object *) gd->gd_WindowObj, WOM_REMVIEW, (ULONG) gd->gd_DataObject);

            /* Erase its rectangle */
            EraseRect (window->RPort,
                       window->BorderLeft,
                       window->BorderTop,
                       window->Width - window->BorderRight - 1,
                       window->Height - window->BorderBottom - 1);

            /* Dispose of the object */
            DisposeDTObject (gd->gd_DataObject);
        }
d55 5
a59 5
                                         DTA_SourceType,    gd->gd_SourceType,
                                         DTA_TextAttr,      (ULONG) & gd->gd_TextAttr,
                                         GA_Immediate,      TRUE,
                                         GA_RelVerify,      TRUE,
                                         TAG_DONE))
d62 2
a63 2
        if (OpenEnvironment (gd))
        {
d65 1
a65 1
            retval = 1L;
d67 12
a78 12
            /* Clear the scrollers */
            setgadgetattrs (gd, (struct Gadget *) gd->gd_WindowObj, gd->gd_Window,
                      DTA_TopVert, 0L,
                      DTA_TopHoriz, 0L,
                      TAG_DONE);
        }
        else
        {
            /* We have problems!!!! */
            PrintF (gd, 1, gd->gd_SecondaryResult, NULL);
            gd->gd_Going = FALSE;
        }
d82 2
a83 2
        /* Remember the error message */
        gd->gd_SecondaryResult = IoErr ();
d86 2
a87 2
        if (lock = Lock (gd->gd_NameBuffer, ACCESS_READ))
        {
d89 2
a90 2
            if (dtn = ObtainDataTypeA (DTST_FILE, (APTR) lock, NULL))
            {
d92 2
a93 2
                if (Stricmp (dtn->dtn_Header->dth_Name, "directory") == 0)
                    retval = 2;
d96 22
a117 4
                ReleaseDataType (dtn);
            }
            UnLock (lock);
        }
d119 6
a124 24
        if (retval == 0)
        {
            /* Show the error message */
            PrintF (gd, 2, gd->gd_SecondaryResult, FilePart (gd->gd_NameBuffer));

            /* Clear the sliders */
            setgadgetattrs (gd, (struct Gadget *) gd->gd_WindowObj, gd->gd_Window,
                      DTA_TopVert, 0L,
                      DTA_TopHoriz, 0L,
                      DTA_TotalVert, 0L,
                      DTA_TotalHoriz, 0L,
                      TAG_DONE);
        }
        else
        {
            setattrs (gd, gd->gd_WindowObj, WOA_Title, (ULONG) GetString (gd, MV_TITLE_MULTIVIEW), TAG_DONE);
        }

        /* Clear the window pointer */
        setwindowpointer (gd, window, WA_Pointer, NULL, TAG_DONE);

        /* If we don't have a window, then we might as well stop right now. */
        if (!window)
            gd->gd_Going = FALSE;
d150 1
a150 1
	/* PROJECT menu */
d180 1
a180 1
	/* EDIT menu */
d184 1
a184 1
		si = (struct DTSpecialInfo *) G(gd->gd_DataObject)->SpecialInfo;
d212 1
a212 1
	/* SEARCH menu */
d223 1
a223 1
	/* WINDOW menu */
d225 3
a227 3
	    left   = win->LeftEdge;
	    top    = win->TopEdge;
	    width  = win->MinWidth;
d233 3
a235 3
	    left   = win->LeftEdge;
	    top    = win->TopEdge;
	    width  = 0;
d240 2
a241 2
			    DTA_NominalHoriz,	&width,
			    DTA_NominalVert,	&height,
d246 1
a246 1
		width  = gd->gd_TextFont->tf_XSize * 80;
d249 2
a250 2
	    width  += 4 + win->BorderLeft + win->BorderRight;
	    height += 2 + win->BorderTop  + win->BorderBottom;
d255 3
a257 3
	    left   = 0;
	    top    = 0;
	    width  = win->WScreen->Width;
d262 1
a262 1
	/* EXTRAS menu */
d288 21
a313 1
    struct TagItem *attrs;
a314 1
    struct TagItem *tag;
d339 1
a339 1
	sigr = Wait ((1L << gd->gd_IDCMPPort->mp_SigBit) | siga | sigw | sigp);
d347 3
d363 3
a365 2
		    /* Try opening the data.  If it is a directory, and there isn't a class
		     * to handle it then popup in it */
d402 1
a402 1
			gd->gd_Prefs.p_Zoom = *((struct IBox *)(&gd->gd_Window->LeftEdge));
d406 2
a407 2
			gd->gd_Prefs.p_Window = *((struct IBox *)(&gd->gd_Window->LeftEdge));
			gd->gd_Prefs.p_Window.Width  -= (gd->gd_Window->BorderLeft + gd->gd_Window->BorderRight + 4);
d413 1
a413 1
			gd->gd_Prefs.p_Window.Top  = gd->gd_Window->TopEdge;
a421 1
		    DK (kprintf ("raw %ld\n", (LONG) imsg->Code));
a471 1
		    DK (kprintf ("van %ld\n", (LONG) imsg->Code));
a517 3
		    attrs = (struct TagItem *) imsg->IAddress;

		    if (tag = FindTagItem (DTA_PrinterStatus, attrs))
d519 2
a520 1
			PrintComplete (gd);
d522 23
a544 5
			if (tag->ti_Data)
			    PrintF (gd, 1, 990 + tag->ti_Data, NULL);

			if (quit)
			    gd->gd_Going = FALSE;
a545 20

		    if (tag = FindTagItem (DTA_Busy, attrs))
		    {
			if (tag->ti_Data)
			    setwindowpointer (gd, window, WA_BusyPointer, TRUE, WA_PointerDelay, TRUE, TAG_DONE);
			else
			    setwindowpointer (gd, window, WA_Pointer, NULL, TAG_DONE);
		    }

		    if (tag = FindTagItem (DTA_Title, attrs))
		    {
			setattrs (gd, gd->gd_WindowObj, WOA_Title, tag->ti_Data, TAG_DONE);
		    }

		    if (tag = FindTagItem (DTA_ErrorLevel, attrs))
		    {
			gd->gd_SecondaryResult = GetTagData (DTA_ErrorNumber, NULL, attrs);
			PrintF (gd, 2, gd->gd_SecondaryResult, (STRPTR) GetTagData (DTA_ErrorString,NULL,attrs));
		    }

a590 1
	    DK (kprintf ("AC_TOP\n"));
a594 1
	    DK (kprintf ("AC_BOTTOM\n"));
d776 1
@


39.9
log
@slight clean up
@
text
@d141 1
d164 1
a169 1
	    {
a170 1
	    }
d196 2
a197 1
		DoDTMethodA (gd->gd_DataObject, win, NULL, &dtg);
d272 6
a278 1
    {
a279 1
    }
@


39.8
log
@uses SA_BitMap successfully.
@
text
@a11 1
#define	DE(x)	x
a16 1
    struct dtTrigger dtt;
d21 1
d27 1
a27 3
#if 0
    /* Try performing a LINK to the object */
    if ((gd->gd_DataObject) && (gd->gd_SourceType == DTST_FILE))
d29 16
a44 5
	sprintf (gd->gd_TempBuffer, "LINK \"%s/Main\"", gd->gd_NameBuffer);
	dtt.MethodID     = DTM_TRIGGER;
	dtt.dtt_GInfo    = NULL;
	dtt.dtt_Function = STM_COMMAND;
	dtt.dtt_Data     = gd->gd_TempBuffer;
d46 3
a48 1
	retval = DoGadgetMethodA ((struct Gadget *) gd->gd_DataObject, window, NULL, &dtt);
a49 1
#endif
d51 31
a81 1
    if (retval == 0)
d83 39
a121 86
	if (gd->gd_DataObject)
	{
	    /* Get rid of the object */
	    if (gd->gd_Flags & GDF_BITMAP)
	    {
		CloseEnvironment (gd, 2);
	    }
	    else
	    {
		/* Remove the object from the window */
		DoMethod ((Object *) gd->gd_WindowObj, WOM_REMVIEW, (ULONG) gd->gd_DataObject);

		/* Erase its rectangle */
		EraseRect (window->RPort,
			   window->BorderLeft,
			   window->BorderTop,
			   window->Width - window->BorderRight - 1,
			   window->Height - window->BorderBottom - 1);

		/* Dispose of the object */
		DisposeDTObject (gd->gd_DataObject);
	    }
	}

	gd->gd_TotVert = gd->gd_TotHoriz = 0L;

	/* Get the new object */
	if (gd->gd_DataObject = newdtobject (gd, gd->gd_NameBuffer,
					     DTA_SourceType,	gd->gd_SourceType,
					     DTA_TopVert,	gd->gd_TotVert,
					     DTA_TopHoriz,	gd->gd_TotHoriz,
					     DTA_TextAttr,	(ULONG) & gd->gd_TextAttr,
					     GA_Immediate,	TRUE,
					     GA_RelVerify,	TRUE,
					     TAG_DONE))
	{
	    if (OpenEnvironment (gd) == NULL)
	    {
		/* We have problems!!!! */
		PrintF (gd, 1, gd->gd_SecondaryResult, NULL);
		gd->gd_Going = FALSE;
	    }
	    else
	    {
		retval = 1L;

		/* Clear the top */
		setgadgetattrs (gd, (struct Gadget *) gd->gd_WindowObj, gd->gd_Window,
			  DTA_TopVert, 0L,
			  DTA_TopHoriz, 0L,
			  TAG_DONE);
	    }
	}
	else
	{
	    /* Error message in the window title */
	    gd->gd_SecondaryResult = IoErr ();

	    if (lock = Lock (gd->gd_NameBuffer, ACCESS_READ))
	    {
		if (dtn = ObtainDataTypeA (DTST_FILE, (APTR) lock, NULL))
		{
		    if (Stricmp (dtn->dtn_Header->dth_Name, "directory") == 0)
			retval = 2;
		    ReleaseDataType (dtn);
		}
		UnLock (lock);
	    }

	    if (retval == 0)
	    {
		/* Show the error message */
		PrintF (gd, 2, gd->gd_SecondaryResult, FilePart (gd->gd_NameBuffer));

		/* Clear the sliders */
		setgadgetattrs (gd, (struct Gadget *) gd->gd_WindowObj, gd->gd_Window,
			  DTA_TopVert, 0L,
			  DTA_TopHoriz, 0L,
			  DTA_TotalVert, 0L,
			  DTA_TotalHoriz, 0L,
			  TAG_DONE);
	    }
	    else
	    {
		setattrs (gd, gd->gd_WindowObj, WOA_Title, (ULONG) GetString (gd, MV_TITLE_MULTIVIEW), TAG_DONE);
	    }
d123 3
a125 3
	    /* Clear the window pointer */
	    setwindowpointer (gd, window, WA_Pointer, NULL, TAG_DONE);
	}
d127 1
d304 1
a304 1
	if (LAYERREFRESH & window->WLayer->Flags)
@


39.7
log
@wasn't updating prop gadgets.
@
text
@d28 1
d40 1
d46 9
a54 2
	    /* Remove the object from the window */
	    DoMethod ((Object *) gd->gd_WindowObj, WOM_REMVIEW, (ULONG) gd->gd_DataObject);
d56 10
a65 9
	    /* Erase its rectangle */
	    EraseRect (window->RPort,
		       window->BorderLeft,
		       window->BorderTop,
		       window->Width - window->BorderRight - 1,
		       window->Height - window->BorderBottom - 1);

	    /* Get rid of the object */
	    DisposeDTObject (gd->gd_DataObject);
a764 1
    {
a765 1
    }
@


39.6
log
@new strings
@
text
@d79 6
d105 1
d109 3
a111 1
		setattrs (gd, gd->gd_WindowObj,
a132 1
    struct DTSpecialInfo *si = NULL;
d134 1
d289 1
a290 1
    BOOL multi;
a297 1
    sigp = NULL;
a317 1
	    {
a318 1
	    }
d351 3
a353 1
	    multi = reply = TRUE;
a356 1
#if 1
d362 1
a366 11
#else
		    reply = FALSE;
		    id = imsg->Code;
		    ReplyMsg ((struct Message *) imsg);
		    while ((id != MENUNULL) && gd->gd_Going && multi)
		    {
			menuitem = ItemAddress (imsg->IDCMPWindow->MenuStrip, id);
			if (multi = ProcessCommand (gd, (ULONG) MENU_USERDATA (menuitem), imsg))
			    id = menuitem->NextSelect;
		    }
#endif
d498 3
a515 15
#if 0
		    if (tag = FindTagItem (DTA_Sync, attrs))
		    {
			setattrs (gd, gd->gd_WindowObj, WOA_Sync, tag->ti_Data, TAG_DONE);
		    }
#endif

		    if (tag = FindTagItem (TDTA_WordSelect, attrs))
		    {
			if (tag->ti_Data)
			{
			    DW (kprintf ("TDTA_WordSelect, \"%s\"\n", tag->ti_Data));
			}
		    }

d519 1
a519 1
			PrintF (gd, 2, gd->gd_SecondaryResult, GetTagData (DTA_ErrorString,NULL,attrs));
d526 10
a537 1
    PrintComplete (gd);
d660 4
a663 10
	    DK (kprintf ("set tv=%ld, th=%ld\n", topv, toph));
	    setdtattrs (gd, gd->gd_DataObject, gd->gd_Window,
			DTA_TopVert, topv,
			DTA_TopHoriz, toph,
			DTA_Sync, TRUE,
			TAG_DONE);
	}
	else
	{
	    DK (kprintf ("not different\n"));
a664 4
    }
    else
    {
	DK (kprintf ("don't need visual\n"));
@


39.5
log
@adjusted error messages
nominal wasn't working correctly
@
text
@d12 1
d26 1
a26 1
    setattrs (gd, gd->gd_WindowObj, WOA_Title, (ULONG) GetString (gd, TITLE_LOADING), TAG_DONE);
d109 1
a109 1
		setattrs (gd, gd->gd_WindowObj, WOA_Title, (ULONG) GetString (gd, TITLE_MULTIVIEW), TAG_DONE);
d140 1
a140 1
	    if (FileRequest (gd, 0, GetString (gd, TITLE_SELECT_FILE_TO_OPEN), GetString (gd, LABEL_OPEN), gd->gd_NameBuffer))
d332 1
a332 1
			if (FileRequest (gd, 0, GetString (gd, TITLE_SELECT_FILE_TO_OPEN), GetString (gd, LABEL_OPEN), gd->gd_NameBuffer))
a494 6
		    if (tag = FindTagItem (DTA_ErrorLevel, attrs))
		    {
			gd->gd_SecondaryResult = GetTagData (DTA_ErrorNumber, NULL, attrs);
			PrintF (gd, 2, gd->gd_SecondaryResult, GetTagData (DTA_ErrorString,NULL,attrs));
		    }

d512 1
d514 1
d518 1
d520 1
d530 7
a769 3
    ULONG left, top, width, height;
    Tag wt, ht;

a771 27
	if (window->Flags & WFLG_BACKDROP)
	{
	    left = 0;
	    top = 0;
	    width = window->Width;
	    height = window->Height;
	    wt = GA_Width;
	    ht = GA_Height;
	}
	else
	{
	    left = gd->gd_Screen->WBorLeft + 2;
	    top = gd->gd_Screen->BarHeight + 1 + 1;
	    width = -(gd->gd_Screen->WBorLeft + 18 + 4);
	    height = -(gd->gd_Screen->BarHeight + 1 + 10 + 2);
	    wt = GA_RelWidth;
	    ht = GA_RelHeight;
	}

	setgadgetattrs (gd, (struct Gadget *) gd->gd_DataObject, window,
			GA_Left, left,
			GA_Top, top,
			wt, width,
			ht, height,
			ICA_TARGET, gd->gd_WindowObj,
			TAG_DONE);

@


39.4
log
@now pops up a file requester for disks and drawers.
@
text
@d25 1
a25 1
    setattrs (gd, gd->gd_WindowObj, DTA_Title, (ULONG) GetString (gd, TITLE_LOADING), TAG_DONE);
d108 1
a108 1
		setattrs (gd, gd->gd_WindowObj, DTA_Title, (ULONG) GetString (gd, TITLE_MULTIVIEW), TAG_DONE);
d124 1
a124 1
    UWORD left, top, width, height;
d128 1
d133 2
d175 1
d231 2
a232 1
	    if (!width)
d234 1
a234 1
	    if (!height)
d263 3
d505 1
a505 1
			    PrintF (gd, 1, 5100 + tag->ti_Data, NULL);
d516 8
d567 1
d572 1
d660 1
d667 8
@


39.3
log
@*** empty log message ***
@
text
@d15 1
a15 1
VOID OpenNewData (struct GlobalData * gd, ULONG stype)
d18 3
a20 1
    ULONG retval = 0L;
d75 4
d84 11
a94 1
	    PrintF (gd, 2, gd->gd_SecondaryResult, NULL);
d96 14
a109 5
	    /* Clear the sliders */
	    setattrs (gd, gd->gd_WindowObj,
		      DTA_TotalVert, 0L,
		      DTA_TotalHoriz, 0L,
		      TAG_DONE);
d115 1
d247 4
d268 1
d319 9
a327 1
		    OpenNewData (gd, DTST_FILE);
d484 9
a492 1
		    if (tag = FindTagItem (DTA_PrinterStatus, (struct TagItem *) imsg->IAddress))
d500 1
a500 1
		    if (tag = FindTagItem (DTA_Busy, (struct TagItem *) imsg->IAddress))
d508 1
a508 1
		    if (tag = FindTagItem (TDTA_WordSelect, (struct TagItem *) imsg->IAddress))
@


39.2
log
@*** empty log message ***
@
text
@a9 1
#define	DO(x)	;
d11 1
a11 1
#define	DS(x)	;
d22 4
d29 2
a30 2
	dtt.MethodID = DTM_TRIGGER;
	dtt.dtt_GInfo = NULL;
d32 1
a32 1
	dtt.dtt_Data = gd->gd_TempBuffer;
d57 1
d59 6
a64 7
					     DTA_SourceType, gd->gd_SourceType,
					     DTA_Title, GetString (gd, TITLE_LOADING),
					     DTA_TopVert, gd->gd_TotVert,
					     DTA_TopHoriz, gd->gd_TotHoriz,
					     DTA_TextAttr, (ULONG) & gd->gd_TextAttr,
					     GA_Immediate, TRUE,
					     GA_RelVerify, TRUE,
d76 1
a76 1
	    /* Cache the error message */
d78 1
d80 1
a80 1
	    /* Clear the window data */
a81 1
		      DTA_Title, (ULONG) GetString (gd, TITLE_MULTIVIEW),
a85 3
	    /* Show the error message */
	    PrintF (gd, 1, gd->gd_SecondaryResult, gd->gd_NameBuffer);

d94 1
a94 1
void ProcessCommand (struct GlobalData * gd, ULONG id, struct IntuiMessage * imsg)
d98 1
d100 2
a101 1
    ULONG width, height;
d104 1
a104 1
	return;
d108 1
d113 1
d139 1
d149 6
a154 2
	case MMC_SHOWCLIP:
	    OpenNewData (gd, DTST_CLIPBOARD);
d157 1
a157 1
	case MMC_COPY:
d160 1
a160 1
		dtg.MethodID = DTM_COPY;
d165 24
d190 4
d197 2
a198 2
			    DTA_NominalHoriz, &width,
			    DTA_NominalVert, &height,
d200 29
a228 14
		if (width == 0)
		    width = win->Width;
		else
		    width += 4 + win->BorderLeft + win->BorderRight;

		if (height == 0)
		    height = win->Height;
		else
		    height += 2 + win->BorderTop + win->BorderBottom;

		ChangeWindowBox (win, win->LeftEdge, win->TopEdge, width, height);
	    }
	    break;
    }
d240 2
a241 1
    BOOL reply = TRUE;
d297 1
a297 1
	    reply = TRUE;
d312 1
d314 2
a315 1
		    while ((id != MENUNULL) && gd->gd_Going)
d318 2
a319 2
			ProcessCommand (gd, (ULONG) MENU_USERDATA (menuitem), imsg);
			id = menuitem->NextSelect;
d324 18
a351 1
			    DB (kprintf ("shift tab\n"));
a407 1
			    DB (kprintf ("tab\n"));
a460 1
#if 0
d464 3
a466 1
			    kprintf ("TDTA_WordSelect, \"%s\"", tag->ti_Data);
a467 1
#endif
a594 1
	    DB (kprintf ("topv=%ld, toph=%ld\n", topv, toph));
a713 1
	DS (kprintf ("set ICA_TARGET 0x%lx\n", gd->gd_WindowObj));
a721 1
	DS (kprintf ("WOM_ADDVIEW 0x%lx\n", gd->gd_DataObject));
@


39.1
log
@*** empty log message ***
@
text
@a5 1
#include "multiview_rev.h"
a6 2
char *version = VERSTAG;

d11 2
a12 313

#define	G(o)	((struct Gadget *)(o))

/*****************************************************************************/

#undef	SysBase

/*****************************************************************************/

int cmd_start (void)
{
    struct ExecBase *SysBase = (*((struct ExecBase **) 4));
    LONG failureLevel = RETURN_FAIL;
    struct WBStartup *wbMsg = NULL;
    struct Process *process;
    ULONG backdrop = FALSE;
    struct GlobalData *gd;
    LONG failureCode = 0;
    BPTR oldLock = NULL;
    ULONG snap = FALSE;
    STRPTR name = NULL;
    ULONG stype;

    process = (struct Process *) SysBase->ThisTask;
    if (!(process->pr_CLI))
    {
	WaitPort (&process->pr_MsgPort);
	wbMsg = (struct WBStartup *) GetMsg (&process->pr_MsgPort);
    }

    if (SysBase->LibNode.lib_Version < 39)
    {
	failureCode = ERROR_INVALID_RESIDENT_LIBRARY;
	PrintF (NULL, 0, ERROR_REQUIRES_V39, NULL);
    }
    else if (gd = InitializeSystem ())
    {
	gd->gd_Process = process;

	if (wbMsg)
	{
	    struct DiskObject *dob;
	    struct WBArg *wbArg;
	    STRPTR tmp;
	    ULONG hold;

	    failureLevel = RETURN_OK;
	    wbArg = wbMsg->sm_ArgList;
	    oldLock = CurrentDir (wbArg->wa_Lock);

	    if (dob = GetDiskObject (wbArg->wa_Name))
	    {
		if (tmp = FindToolType (dob->do_ToolTypes, "PUBSCREEN"))
		{
		    strcpy (gd->gd_ScreenNameBuffer, tmp);
		    gd->gd_ScreenName = gd->gd_ScreenNameBuffer;
		}

		if (tmp = FindToolType (dob->do_ToolTypes, "CLIPUNIT"))
		{
		    if (StrToLong (tmp, &hold) > 0L)
			gd->gd_Unit = hold;
		}
		FreeDiskObject (dob);
	    }

	    if (wbMsg->sm_NumArgs > 1)
	    {
		wbArg++;
		stype = DTST_FILE;
		name = wbArg->wa_Name;
	    }
	}
	else
	{
	    if (gd->gd_RDArgs = ReadArgs (TEMPLATE, gd->gd_Options, NULL))
	    {
		if (!((SIGBREAKF_CTRL_C & CheckSignal (SIGBREAKF_CTRL_C))))
		{
		    /* Public screen? */
		    if (gd->gd_Options[OPT_PUBSCREEN])
		    {
			strcpy (gd->gd_ScreenNameBuffer, (STRPTR) gd->gd_Options[OPT_PUBSCREEN]);
			gd->gd_ScreenName = gd->gd_ScreenNameBuffer;
		    }

		    if (gd->gd_Options[OPT_CLIPUNIT])
		    {
			gd->gd_Unit = *((ULONG *) gd->gd_Options[OPT_CLIPUNIT]);
		    }

		    name = (gd->gd_Options[OPT_FILE]) ? (STRPTR) gd->gd_Options[OPT_FILE] : "";
		    stype = DTST_FILE;
		    if (gd->gd_Options[OPT_CLIPBOARD])
		    {
			stype = DTST_CLIPBOARD;
			name = (STRPTR) gd->gd_Unit;
		    }
		}
	    }
	}

	if (name || (stype == DTST_CLIPBOARD))
	{
	    if (gd->gd_DisplayObject = newdtobject (gd, name,
						    DTA_SourceType, stype,
						    GA_Immediate, TRUE,
						    GA_RelVerify, TRUE,
						    DTA_TextAttr, (ULONG) & gd->gd_TextAttr,
						    TAG_DONE))
	    {
		failureCode = ERROR_NO_FREE_STORE;

		if (gd->gd_Options[OPT_SCREEN])
		{
		    ULONG *cregs = NULL, numcolors, i, r, g, b;
		    ULONG backfill = LAYERS_BACKFILL;
		    ULONG back, shine, shadow, fill;
		    UWORD pens[NUMDRIPENS + 1];
		    struct dtFrameBox dtf;
		    struct FrameInfo *fri;
		    struct ColorMap *cm;
		    struct Screen *scr;
		    ULONG table[4][3];
		    ULONG modeid;

		    if (scr = LockPubScreen (NULL))
		    {
			/* Default */
			pens[0] = ~0;

			GetAttr (PDTA_CRegs, gd->gd_DisplayObject, (ULONG *) & cregs);
			GetAttr (PDTA_NumColors, gd->gd_DisplayObject, (ULONG *) & numcolors);
			DB (kprintf ("cregs=0x%lx, numcolors=%ld\n", cregs, numcolors));
			setdtattrs (gd, gd->gd_DisplayObject, NULL, PDTA_Remap, FALSE, TAG_DONE);

			/* Ask the mode ID */
			modeid = INVALID_ID;
			if (GetAttr (PDTA_ModeID, gd->gd_DisplayObject, (ULONG *) & modeid))
			{
			}

			/* Ask the object what it wants to be like */
			dtf.MethodID          = DTM_FRAMEBOX;
			dtf.dtf_FrameInfo     = fri = &gd->gd_FrameInfo;
			dtf.dtf_SizeFrameInfo = sizeof (struct FrameInfo);
			dtf.dtf_FrameFlags    = NULL;
			if (DoDTMethodA (gd->gd_DisplayObject, NULL, NULL, &dtf) && fri->fri_Dimensions.Depth)
			{
			    DB (kprintf ("PropertyFlags : 0x%lx\n", fri->fri_PropertyFlags));
			    DB (kprintf ("RedBits       : 0x%lx\n", fri->fri_RedBits));
			    DB (kprintf ("GreenBits     : 0x%lx\n", fri->fri_GreenBits));
			    DB (kprintf ("BlueBits      : 0x%lx\n", fri->fri_BlueBits));
			    DB (kprintf ("Width         : %ld\n", (ULONG) fri->fri_Dimensions.Width));
			    DB (kprintf ("Height        : %ld\n", (ULONG) fri->fri_Dimensions.Height));
			    DB (kprintf ("Depth         : %ld\n", (ULONG) fri->fri_Dimensions.Depth));
			    DB (kprintf ("Screen        : 0x%lx\n", fri->fri_Screen));
			    DB (kprintf ("ColorMap      : 0x%lx\n", fri->fri_ColorMap));
			}
			else if (modeid == INVALID_ID)
			{
			    modeid = GetVPModeID (&scr->ViewPort);
			    fri->fri_Dimensions.Width  = scr->Width;
			    fri->fri_Dimensions.Height = scr->Height;
			    fri->fri_Dimensions.Depth  = scr->BitMap.Depth;
			}
			DB (kprintf ("ModeID        : 0x%lx\n", modeid));

			/* Get a lock on the default public screen */
			if (cregs)
			{
			    /* Get a temporary color map */
			    if (cm = GetColorMap (numcolors))
			    {
				/* Set the colors */
				DB (kprintf ("picture\n"));
				for (i = 0; i < numcolors; i++)
				{
				    r = cregs[i * 3 + 0];
				    g = cregs[i * 3 + 1];
				    b = cregs[i * 3 + 2];
				    SetRGB32CM (cm, i, r, g, b);
				    DB (kprintf (" %3ld) %08lx x%08lx %08lx\n", i, r, g, b));
				}

				/* Get the first four colors (the GUI colors) from the default public screen */
				GetRGB32 (scr->ViewPort.ColorMap, 0, 4, (ULONG *) table);

				/* Get the closest colors in the picture's color map */
				back = FindColor (cm, table[0][0], table[0][1], table[0][2], numcolors);
				shadow = FindColor (cm, table[1][0], table[1][1], table[1][2], numcolors);
				shine = FindColor (cm, table[2][0], table[2][1], table[2][2], numcolors);
				fill = FindColor (cm, table[3][0], table[3][1], table[3][2], numcolors);

				pens[DETAILPEN] = back;
				pens[BLOCKPEN] = shadow;
				pens[TEXTPEN] = shadow;
				pens[SHINEPEN] = shine;
				pens[SHADOWPEN] = shadow;
				pens[FILLPEN] = fill;
				pens[FILLTEXTPEN] = shadow;
				pens[HIGHLIGHTTEXTPEN] = shine;
				pens[BACKGROUNDPEN] = back;
				pens[BARDETAILPEN] = shadow;
				pens[BARBLOCKPEN] = shine;
				pens[BARTRIMPEN] = shadow;
				pens[NUMDRIPENS] = ~0;

				/* Free the temporary color map */
				FreeColorMap (cm);
			    }
			    backfill = LAYERS_NOBACKFILL;
			    backdrop = TRUE;
			}

			if (gd->gd_Screen = openscreentags (gd,
							    SA_Width,		(ULONG) fri->fri_Dimensions.Width,
							    SA_Height,		(ULONG) fri->fri_Dimensions.Height,
							    SA_Depth,		(ULONG) fri->fri_Dimensions.Depth,
							    SA_DisplayID,	modeid,
							    SA_Interleaved,	TRUE,
							    SA_SharePens,	TRUE,
							    SA_SysFont,		1,
							    SA_ShowTitle,	!(backdrop),
							    SA_Quiet,		backdrop,
							    SA_Pens,		pens,
							    SA_BackFill,	backfill,
							    SA_DetailPen,	pens[DETAILPEN],
							    SA_BlockPen,	pens[BLOCKPEN],
							    TAG_DONE))
			{
			    if (cregs)
			    {
				for (i = 0; i < numcolors; i++)
				{
				    r = cregs[i * 3 + 0];
				    g = cregs[i * 3 + 1];
				    b = cregs[i * 3 + 2];
				    SetRGB32 (&gd->gd_Screen->ViewPort, i, r, g, b);
				}
			    }
			}

			/* Unlock the public screen */
			UnlockPubScreen (NULL, scr);
		    }
		}
		else
		{
		    /* get a pointer to the default public gd->gd_Screen */
		    gd->gd_Screen = LockPubScreen (gd->gd_ScreenName);
		}

		/* We have to have a screen */
		if (gd->gd_Screen)
		{
		    if (gd->gd_VI = GetVisualInfoA (gd->gd_Screen, TAG_DONE))
		    {
			if (gd->gd_DrawInfo = GetScreenDrawInfo (gd->gd_Screen))
			{
			    frameobject (gd);

			    LoadSnapShot (gd, &gd->gd_Snapshot);
			    GetAttr (DTA_NominalHoriz, gd->gd_DisplayObject, &gd->gd_TotHoriz);
			    GetAttr (DTA_NominalVert, gd->gd_DisplayObject, &gd->gd_TotVert);
			    if (gd->gd_TotHoriz == 0)
			    {
				gd->gd_TotHoriz = gd->gd_Snapshot.Width;
				snap = TRUE;
			    }
			    if (gd->gd_TotVert == 0)
			    {
				gd->gd_TotVert = gd->gd_Snapshot.Height;
			    }

			    /* allocate and initialize a scroller as a BOOPSI object */
			    if (gd->gd_WindowObj = newobject (gd, gd->gd_WindowClass, NULL,
							      WA_Left, gd->gd_Snapshot.Left,
							      WA_Top, gd->gd_Snapshot.Top,
							      WA_InnerWidth, gd->gd_TotHoriz + 4,
							      WA_InnerHeight, gd->gd_TotVert + 2,
							      WA_PubScreen, gd->gd_Screen,
							      WA_IDCMP, IDCMP_FLAGS,
							      WOA_Title, (STRPTR) gd->gd_Options[OPT_FILE],
							      WOA_DrawInfo, gd->gd_DrawInfo,
							      WOA_IDCMPPort, gd->gd_IDCMPPort,
							      WOA_AWPort, gd->gd_AWPort,
							      WOA_Backdrop, backdrop,
							      ICA_TARGET, ICTARGET_IDCMP,
							      TAG_DONE))
			    {
				failureLevel = RETURN_OK;
				failureCode = 0;

				GetAttr (WOA_Window, gd->gd_WindowObj, (ULONG *) & gd->gd_Window);

				SetDisplayObjectAttrs (gd);

				ScreenToFront (window->WScreen);

				HandleEvents (gd);

				PrintComplete (gd);

				DoMethod ((Object *) gd->gd_WindowObj, WOM_REMVIEW, (ULONG) gd->gd_DisplayObject);

				if (snap)
				    SaveSnapShot (gd, window);

				DisposeObject (gd->gd_WindowObj);
			    }
			    else
				ShowError (gd, "Couldn't create window object\n");
a13 135
			    FreeScreenDrawInfo (gd->gd_Screen, gd->gd_DrawInfo);
			}
			FreeVisualInfo (gd->gd_VI);
		    }

		    if (gd->gd_Options[OPT_SCREEN])
			CloseScreen (gd->gd_Screen);
		    else
			UnlockPubScreen (NULL, gd->gd_Screen);
		}
		DisposeDTObject (gd->gd_DisplayObject);
	    }
	    else
	    {
		failureCode = IoErr ();
	    }
	}
	else
	{
	    failureCode = ERROR_REQUIRED_ARG_MISSING;
	}

	if (oldLock)
	{
	    CurrentDir (oldLock);
	}

	if (failureLevel)
	{
	    /* Display an error message */
	    PrintF (gd, gd->gd_Options[OPT_REQUESTER], failureCode, NULL);
	}

	FreeArgs (gd->gd_RDArgs);

	ShutdownSystem (gd);
    }
    else
    {
	failureCode = ERROR_NO_FREE_STORE;
	PrintF (NULL, 0, failureCode, NULL);
    }

    if (wbMsg)
    {
	Forbid ();
	ReplyMsg ((struct Message *) wbMsg);
    }
    process->pr_Result2 = failureCode;
    return (failureLevel);
}

/*****************************************************************************/

struct GlobalData *InitializeSystem (void)
{
    struct ExecBase *SysBase = (*((struct ExecBase **) 4));
    struct GlobalData *gd;

    if (gd = AllocVec (sizeof (struct GlobalData), MEMF_CLEAR))
    {
	gd->gd_SysBase = SysBase;
	gd->gd_Going = TRUE;
	gd->gd_Trigger.MethodID = DTM_TRIGGER;

	DOSBase = OpenLibrary ("dos.library", 39);
	IntuitionBase = OpenLibrary ("intuition.library", 39);
	GfxBase = OpenLibrary ("graphics.library", 39);
	UtilityBase = OpenLibrary ("utility.library", 39);
	WorkbenchBase = OpenLibrary ("workbench.library", 39);
	IconBase = OpenLibrary ("icon.library", 39);
	GadToolsBase = OpenLibrary ("gadtools.library", 39);
	LayersBase = OpenLibrary ("layers.library", 39);
	AslBase = OpenLibrary ("asl.library", 37);

	if (LocaleBase = OpenLibrary ("locale.library", 38))
	    gd->gd_Catalog = OpenCatalogA (NULL, "multiview.catalog", NULL);

	if (DataTypesBase = OpenLibrary ("datatypes.library", 0))
	{
	    if (gd->gd_WindowClass = initWindowClass (gd))
	    {
		if (CreateMsgPorts (gd))
		{
#undef	GfxBase
		    gd->gd_TextFont = ((struct GfxBase *) gd->gd_GfxBase)->DefaultFont;
#define	GfxBase	gd->gd_GfxBase

		    gd->gd_TextAttr.ta_Name = gd->gd_TextFont->tf_Message.mn_Node.ln_Name;
		    gd->gd_TextAttr.ta_YSize = gd->gd_TextFont->tf_YSize;
		    gd->gd_TextAttr.ta_Style = gd->gd_TextFont->tf_Style;
		    gd->gd_TextAttr.ta_Flags = gd->gd_TextFont->tf_Flags;

		    return (gd);
		}
	    }
	}
	ShutdownSystem (gd);
    }
    return (NULL);
}

/*****************************************************************************/

VOID ShutdownSystem (struct GlobalData * gd)
{

    if (gd)
    {
	if (LocaleBase)
	{
	    CloseCatalog (gd->gd_Catalog);
	    CloseLibrary (LocaleBase);
	}

	DeleteMsgPort (gd->gd_IDCMPPort);
	DeleteMsgPort (gd->gd_AWPort);
	freeWindowClass (gd->gd_WindowClass);

	CloseLibrary (DataTypesBase);
	CloseLibrary (AslBase);
	CloseLibrary (GadToolsBase);
	CloseLibrary (IconBase);
	CloseLibrary (WorkbenchBase);
	CloseLibrary (UtilityBase);
	CloseLibrary (GfxBase);
	CloseLibrary (IntuitionBase);
	CloseLibrary (DOSBase);

	FreeVec (gd);
    }
}

#define	SysBase	gd->gd_SysBase

a17 1
    ULONG left, top, width, height;
d20 2
a21 1
    Tag wt, ht;
d23 1
a23 1
    if (stype == DTST_FILE)
d31 1
a31 1
	retval = DoGadgetMethodA ((struct Gadget *) gd->gd_DisplayObject, window, NULL, &dtt);
d36 1
a36 1
	if (gd->gd_DisplayObject)
d38 2
a39 6
	    SetAPen (window->RPort, 0);
	    RectFill (window->RPort,
		      window->BorderLeft,
		      window->BorderTop,
		      window->Width - window->BorderRight - 1,
		      window->Height - window->BorderBottom - 1);
d41 29
a69 12
	    DoMethod ((Object *) gd->gd_WindowObj, WOM_REMVIEW, (ULONG) gd->gd_DisplayObject);
	    DisposeDTObject (gd->gd_DisplayObject);
	}

	if (window->Flags & WFLG_BACKDROP)
	{
	    left = 0;
	    top = 0;
	    width = window->Width;
	    height = window->Height;
	    wt = GA_Width;
	    ht = GA_Height;
d73 2
a74 7
	    left = gd->gd_Screen->WBorLeft + 2;
	    top = gd->gd_Screen->BarHeight + 1 + 1;
	    width = -(gd->gd_Screen->WBorLeft + 18 + 4);
	    height = -(gd->gd_Screen->BarHeight + 1 + 10 + 2);
	    wt = GA_RelWidth;
	    ht = GA_RelHeight;
	}
d76 13
a88 17
	if (gd->gd_DisplayObject = newdtobject (gd, gd->gd_NameBuffer,
						DTA_SourceType, stype,
						GA_Left, left,
						GA_Top, top,
						wt, width,
						ht, height,
						GA_Immediate, TRUE,
						GA_RelVerify, TRUE,
						DTA_TopVert, 0,
						DTA_TopHoriz, 0,
						DTA_TextAttr, (ULONG) & gd->gd_TextAttr,
						ICA_TARGET, gd->gd_WindowObj,
						TAG_DONE))
	{
	    frameobject (gd);
	    SetDisplayObjectAttrs (gd);
	}
a99 1
    struct Gadget *g;
a103 3
    if (g = G (gd->gd_DisplayObject))
	si = (struct DTSpecialInfo *) g->SpecialInfo;

d114 1
a114 1
	    if (gd->gd_DisplayObject)
d121 1
a121 1
	    if (gd->gd_DisplayObject)
d128 1
a128 4
	    if (gd->gd_DisplayObject)
	    {
		AboutObject (gd);
	    }
d136 1
a136 1
	    if (si)
d138 1
d149 5
a153 2
	    dtg.MethodID = DTM_COPY;
	    DoDTMethodA (gd->gd_DisplayObject, win, NULL, &dtg);
d157 20
a176 42
	    GetAttr (DTA_NominalHoriz, gd->gd_DisplayObject, &width);
	    GetAttr (DTA_NominalVert, gd->gd_DisplayObject, &height);
	    if (width == 0)
		width = win->Width;
	    else
		width += 4 + win->BorderLeft + win->BorderRight;

	    if (height == 0)
		height = win->Height;
	    else
		height += 2 + win->BorderTop + win->BorderBottom;

	    ChangeWindowBox (win, win->LeftEdge, win->TopEdge, width, height);
	    break;
    }
}

/*****************************************************************************/

VOID AboutObject (struct GlobalData * gd)
{
    struct EasyStruct es;
    struct DataType *dtn;
    UWORD i;

    getdtattrs (gd, gd->gd_DisplayObject, DTA_DataType, (ULONG) & dtn, TAG_DONE);

    strncpy (gd->gd_TempBuffer, DataTypesBase->lib_IdString, 40);
    DB (kprintf ("%ld %ld\n", (ULONG) gd->gd_TempBuffer[(i - 1)], (ULONG) gd->gd_TempBuffer[(i - 2)]));
    i = strlen (gd->gd_TempBuffer);
    if (gd->gd_TempBuffer[(i - 2)] == '\r')
    {
	gd->gd_TempBuffer[(i - 2)] = 0;
    }

    es.es_StructSize = sizeof (struct EasyStruct);
    es.es_Flags = 0;
    es.es_Title = GetString (gd, TITLE_MULTIVIEW);
    es.es_TextFormat = "MultiView %ld.%ld (%s)\n%s\nWritten by David N. Junod\n\nContents Type: %s %s";
    es.es_GadgetFormat = GetString (gd, LABEL_CONTINUE);

    easyrequest (gd, &es, VERSION, REVISION, DATE, gd->gd_TempBuffer, dtn->dtn_Header->dth_Name, GetDTString (dtn->dtn_Header->dth_GroupID));
d188 1
a192 1
    UWORD id;
d212 1
a212 1
	sigr = Wait ((1L << window->UserPort->mp_SigBit) | siga | sigw | sigp);
d218 1
a218 1
		DoMethod (gd->gd_DisplayObject, DTM_ABORTPRINT, NULL);
d225 1
a225 1
	    setwindowpointer (gd, window, WA_BusyPointer, TRUE, TAG_DONE);
d242 1
a242 1
	while (imsg = (struct IntuiMessage *) GetMsg (window->UserPort))
d244 1
d248 11
d266 1
d273 52
d326 1
d329 3
a331 3
			case '/':
			    gd->gd_Trigger.dtt_Function = STM_RETRACE;
			    DoDTMethodA (gd->gd_DisplayObject, window, NULL, &gd->gd_Trigger);
d334 1
d336 19
a354 2
			    gd->gd_Trigger.dtt_Function = STM_ACTIVATE_FIELD;
			    DoDTMethodA (gd->gd_DisplayObject, window, NULL, &gd->gd_Trigger);
d358 1
a358 2
			    gd->gd_Trigger.dtt_Function = STM_BROWSE_PREV;
			    DoDTMethodA (gd->gd_DisplayObject, window, NULL, &gd->gd_Trigger);
d362 7
a368 2
			    gd->gd_Trigger.dtt_Function = STM_BROWSE_NEXT;
			    DoDTMethodA (gd->gd_DisplayObject, window, NULL, &gd->gd_Trigger);
d385 1
a385 1
			    setwindowpointer (gd, window, WA_BusyPointer, TRUE, TAG_DONE);
d389 8
d399 2
a400 2

	    ReplyMsg ((struct Message *) imsg);
d403 1
d408 1
a408 1
BOOL CreateMsgPorts (struct GlobalData * gd)
d410 2
d413 4
a416 1
    if (gd->gd_IDCMPPort = CreateMsgPort ())
d418 113
a530 3
	if (gd->gd_AWPort = CreateMsgPort ())
	    return (TRUE);
	DeleteMsgPort (gd->gd_IDCMPPort);
a531 1
    return (FALSE);
a584 13
void ShowError (struct GlobalData * gd, STRPTR msg,...)
{
    BPTR fh;

    if (fh = Open ("*", MODE_OLDFILE))
    {
	Write (fh, msg, strlen (msg));
	Close (fh);
    }
}

/*****************************************************************************/

d613 1
a613 1
    return (DoDTMethodA (gd->gd_DisplayObject, gd->gd_Window, NULL, &dtf));
d618 1
a618 1
void SetDisplayObjectAttrs (struct GlobalData * gd)
d623 1
a623 1
    if (window->Flags & WFLG_BACKDROP)
d625 18
a642 16
	left = 0;
	top = 0;
	width = window->Width;
	height = window->Height;
	wt = GA_Width;
	ht = GA_Height;
    }
    else
    {
	left = gd->gd_Screen->WBorLeft + 2;
	top = gd->gd_Screen->BarHeight + 1 + 1;
	width = -(gd->gd_Screen->WBorLeft + 18 + 4);
	height = -(gd->gd_Screen->BarHeight + 1 + 10 + 2);
	wt = GA_RelWidth;
	ht = GA_RelHeight;
    }
d644 2
a645 3
    if (gd->gd_DisplayObject)
    {
	setgadgetattrs (gd, (struct Gadget *) gd->gd_DisplayObject, window,
d653 2
a654 1
	DoMethod ((Object *) gd->gd_WindowObj, WOM_ADDVIEW, (ULONG) gd->gd_DisplayObject, NULL);
@


39.0
log
@initial RCS
@
text
@d105 1
a105 1
		    name  = (gd->gd_Options[OPT_FILE]) ? (STRPTR) gd->gd_Options[OPT_FILE] : "";
d110 1
a110 1
			name = (STRPTR)gd->gd_Unit;
d130 1
d140 41
a180 2
		    /* Default */
		    pens[0] = ~0;
d182 2
a183 32
		    GetAttr (PDTA_CRegs, gd->gd_DisplayObject, (ULONG *) & cregs);
		    GetAttr (PDTA_NumColors, gd->gd_DisplayObject, (ULONG *) & numcolors);
		    DB (kprintf ("cregs=0x%lx, numcolors=%ld\n", cregs, numcolors));
		    setdtattrs (gd, gd->gd_DisplayObject, NULL, PDTA_Remap, FALSE, TAG_DONE);

		    /* Ask the object what it wants to be like (Mike) */
		    dtf.MethodID = DTM_FRAMEBOX;
		    dtf.dtf_FrameInfo = fri = &gd->gd_FrameInfo;
		    dtf.dtf_SizeFrameInfo = sizeof (struct FrameInfo);
		    dtf.dtf_FrameFlags = NULL;
		    DoDTMethodA (gd->gd_DisplayObject, NULL, NULL, &dtf);

		    DB (kprintf ("PropertyFlags : 0x%lx\n", fri->fri_PropertyFlags));
/*		    DB (kprintf ("Resolution    : 0x%lx\n", fri->fri_Resolution)); */
		    DB (kprintf ("RedBits       : 0x%lx\n", fri->fri_RedBits));
		    DB (kprintf ("GreenBits     : 0x%lx\n", fri->fri_GreenBits));
		    DB (kprintf ("BlueBits      : 0x%lx\n", fri->fri_BlueBits));
		    DB (kprintf ("Width         : %ld\n", (ULONG) fri->fri_Dimensions.Width));
		    DB (kprintf ("Height        : %ld\n", (ULONG) fri->fri_Dimensions.Height));
		    DB (kprintf ("Depth         : %ld\n", (ULONG) fri->fri_Dimensions.Depth));
		    DB (kprintf ("Screen        : 0x%lx\n", fri->fri_Screen));
		    DB (kprintf ("ColorMap      : 0x%lx\n", fri->fri_ColorMap));

		    /* Ask the mode ID */
		    GetAttr (PDTA_ModeID, gd->gd_DisplayObject, (ULONG *) & modeid);
		    DB (kprintf ("ModeID        : 0x%lx\n", modeid));

		    /* Get a lock on the default public screen */
		    if (cregs && (scr = LockPubScreen (NULL)))
		    {
			/* Get a temporary color map */
			if (cm = GetColorMap (numcolors))
d185 2
a186 3
			    /* Set the colors */
			    DB (kprintf ("picture\n"));
			    for (i = 0; i < numcolors; i++)
d188 10
a197 6
				r = cregs[i * 3 + 0];
				g = cregs[i * 3 + 1];
				b = cregs[i * 3 + 2];
				SetRGB32CM (cm, i, r, g, b);
				DB (kprintf (" %3ld) %08lx x%08lx %08lx\n", i, r, g, b));
			    }
d199 2
a200 2
			    /* Get the first four colors (the GUI colors) from the default public screen */
			    GetRGB32 (scr->ViewPort.ColorMap, 0, 4, (ULONG *) table);
d202 19
a220 19
			    /* Get the closest colors in the picture's color map */
			    back = FindColor (cm, table[0][0], table[0][1], table[0][2], numcolors);
			    shadow = FindColor (cm, table[1][0], table[1][1], table[1][2], numcolors);
			    shine = FindColor (cm, table[2][0], table[2][1], table[2][2], numcolors);
			    fill = FindColor (cm, table[3][0], table[3][1], table[3][2], numcolors);

			    pens[DETAILPEN] = back;
			    pens[BLOCKPEN] = shadow;
			    pens[TEXTPEN] = shadow;
			    pens[SHINEPEN] = shine;
			    pens[SHADOWPEN] = shadow;
			    pens[FILLPEN] = fill;
			    pens[FILLTEXTPEN] = shadow;
			    pens[HIGHLIGHTTEXTPEN] = shine;
			    pens[BACKGROUNDPEN] = back;
			    pens[BARDETAILPEN] = shadow;
			    pens[BARBLOCKPEN] = shine;
			    pens[BARTRIMPEN] = shadow;
			    pens[NUMDRIPENS] = ~0;
d222 5
a226 2
			    /* Free the temporary color map */
			    FreeColorMap (cm);
a227 3
			/* Unlock the public screen */
			UnlockPubScreen (NULL, scr);
		    }
d229 15
a243 17
		    if (gd->gd_Screen = openscreentags (gd,
							SA_Width, (ULONG) fri->fri_Dimensions.Width,
							SA_Height, (ULONG) fri->fri_Dimensions.Height,
							SA_Depth, (ULONG) fri->fri_Dimensions.Depth,
							SA_DisplayID, modeid,
							SA_Interleaved, TRUE,
							SA_SharePens, TRUE,
							SA_SysFont, 1,
							SA_ShowTitle, FALSE,
							SA_Quiet, TRUE,
							SA_Pens, pens,
							SA_BackFill, LAYERS_NOBACKFILL,
							SA_DetailPen, pens[DETAILPEN],
							SA_BlockPen, pens[BLOCKPEN],
							TAG_DONE))
		    {
			if (cregs)
d245 1
a245 1
			    for (i = 0; i < numcolors; i++)
d247 7
a253 4
				r = cregs[i * 3 + 0];
				g = cregs[i * 3 + 1];
				b = cregs[i * 3 + 2];
				SetRGB32 (&gd->gd_Screen->ViewPort, i, r, g, b);
a254 1
			    backdrop = TRUE;
d256 3
d270 3
a272 1
			if (gd->gd_VI = GetVisualInfoA (gd->gd_Screen, TAG_DONE))
d274 11
a284 1
			    if (gd->gd_DrawInfo = GetScreenDrawInfo (gd->gd_Screen))
d286 2
a287 1
				frameobject (gd);
d289 18
a306 12
				LoadSnapShot (gd, &gd->gd_Snapshot);
				GetAttr (DTA_NominalHoriz, gd->gd_DisplayObject, &gd->gd_TotHoriz);
				GetAttr (DTA_NominalVert, gd->gd_DisplayObject, &gd->gd_TotVert);
				if (gd->gd_TotHoriz == 0)
				{
				    gd->gd_TotHoriz = gd->gd_Snapshot.Width;
				    snap = TRUE;
				}
				if (gd->gd_TotVert == 0)
				{
				    gd->gd_TotVert = gd->gd_Snapshot.Height;
				}
d308 1
a308 18
				/* allocate and initialize a scroller as a BOOPSI object */
				if (gd->gd_WindowObj = newobject (gd, gd->gd_WindowClass, NULL,
								  WA_Left, gd->gd_Snapshot.Left,
								  WA_Top, gd->gd_Snapshot.Top,
								  WA_InnerWidth, gd->gd_TotHoriz + 4,
								  WA_InnerHeight, gd->gd_TotVert + 2,
								  WA_PubScreen, gd->gd_Screen,
								  WA_IDCMP, IDCMP_FLAGS,
								  WOA_Title, (STRPTR) gd->gd_Options[OPT_FILE],
								  WOA_DrawInfo, gd->gd_DrawInfo,
								  WOA_IDCMPPort, gd->gd_IDCMPPort,
								  WOA_AWPort, gd->gd_AWPort,
								  WOA_Backdrop, backdrop,
								  ICA_TARGET, ICTARGET_IDCMP,
								  TAG_DONE))
				{
				    failureLevel = RETURN_OK;
				    failureCode  = 0;
d310 9
a318 1
				    GetAttr (WOA_Window, gd->gd_WindowObj, (ULONG *) & gd->gd_Window);
d320 2
a321 9
				    SetDisplayObjectAttrs (gd);

				    ScreenToFront (window->WScreen);

				    HandleEvents (gd);

				    PrintComplete (gd);

				    DoMethod ((Object *) gd->gd_WindowObj, WOM_REMVIEW, (ULONG) gd->gd_DisplayObject);
d323 4
a326 7
				    if (snap)
					SaveSnapShot (gd, window);

				    DisposeObject (gd->gd_WindowObj);
				}
				else
				    ShowError (gd, "Couldn't create window object\n");
d328 1
a328 3
				FreeScreenDrawInfo (gd->gd_Screen, gd->gd_DrawInfo);
			    }
			    FreeVisualInfo (gd->gd_VI);
d330 2
d393 1
a393 1
	DOSBase       = OpenLibrary ("dos.library", 39);
d395 2
a396 2
	GfxBase       = OpenLibrary ("graphics.library", 39);
	UtilityBase   = OpenLibrary ("utility.library", 39);
d398 4
a401 4
	IconBase      = OpenLibrary ("icon.library", 39);
	GadToolsBase  = OpenLibrary ("gadtools.library", 39);
	LayersBase    = OpenLibrary ("layers.library", 39);
	AslBase       = OpenLibrary ("asl.library", 37);
d475 2
a476 2
	dtt.MethodID     = DTM_TRIGGER;
	dtt.dtt_GInfo    = NULL;
d478 1
a478 1
	dtt.dtt_Data     = gd->gd_TempBuffer;
d480 1
a480 1
	retval = DoGadgetMethodA ((struct Gadget *)gd->gd_DisplayObject, window, NULL, &dtt);
d485 2
a486 2
        if (gd->gd_DisplayObject)
        {
d494 3
a496 3
            DoMethod ((Object *) gd->gd_WindowObj, WOM_REMVIEW, (ULONG) gd->gd_DisplayObject);
            DisposeDTObject (gd->gd_DisplayObject);
        }
d498 36
a533 36
        if (window->Flags & WFLG_BACKDROP)
        {
            left = 0;
            top = 0;
            width = window->Width;
            height = window->Height;
            wt = GA_Width;
            ht = GA_Height;
        }
        else
        {
            left = gd->gd_Screen->WBorLeft + 2;
            top = gd->gd_Screen->BarHeight + 1 + 1;
            width = -(gd->gd_Screen->WBorLeft + 18 + 4);
            height = -(gd->gd_Screen->BarHeight + 1 + 10 + 2);
            wt = GA_RelWidth;
            ht = GA_RelHeight;
        }

        if (gd->gd_DisplayObject = newdtobject (gd, gd->gd_NameBuffer,
                                                DTA_SourceType,	stype,
                                                GA_Left,	left,
                                                GA_Top,		top,
                                                wt,		width,
                                                ht,		height,
                                                GA_Immediate,	TRUE,
                                                GA_RelVerify,	TRUE,
                                                DTA_TopVert,	0,
                                                DTA_TopHoriz,	0,
                                                DTA_TextAttr,	(ULONG) & gd->gd_TextAttr,
						ICA_TARGET,	gd->gd_WindowObj,
                                                TAG_DONE))
        {
            frameobject (gd);
            SetDisplayObjectAttrs (gd);
        }
d624 1
a624 1
VOID AboutObject (struct GlobalData *gd)
d630 1
a630 1
    getdtattrs (gd, gd->gd_DisplayObject, DTA_DataType, (ULONG)&dtn, TAG_DONE);
d633 1
a633 1
    DB(kprintf ("%ld %ld\n", (ULONG)gd->gd_TempBuffer[(i-1)], (ULONG)gd->gd_TempBuffer[(i-2)] ));
d635 1
a635 1
    if (gd->gd_TempBuffer[(i-2)]=='\r')
d637 1
a637 1
	gd->gd_TempBuffer[(i-2)]=0;
d640 4
a643 4
    es.es_StructSize   = sizeof (struct EasyStruct);
    es.es_Flags        = 0;
    es.es_Title        = GetString (gd, TITLE_MULTIVIEW);
    es.es_TextFormat   = "MultiView %ld.%ld (%s)\n%s\nWritten by David N. Junod\n\nContents Type: %s %s";
d838 1
@
