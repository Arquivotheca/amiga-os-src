head     39.19;
branch   ;
access   ;
symbols  ;
locks    davidj:39.19; strict;
comment  @ * @;


39.19
date     93.06.17.14.05.45;  author davidj;  state Exp;
branches ;
next     39.18;

39.18
date     93.05.26.11.27.01;  author davidj;  state Exp;
branches ;
next     39.17;

39.17
date     93.05.03.14.55.30;  author davidj;  state Exp;
branches ;
next     39.16;

39.16
date     93.04.14.14.54.45;  author davidj;  state Exp;
branches ;
next     39.15;

39.15
date     93.03.23.14.24.44;  author davidj;  state Exp;
branches ;
next     39.14;

39.14
date     93.02.15.12.46.29;  author davidj;  state Exp;
branches ;
next     39.13;

39.13
date     92.11.30.14.45.44;  author davidj;  state Exp;
branches ;
next     39.12;

39.12
date     92.11.12.10.19.24;  author davidj;  state Exp;
branches ;
next     39.11;

39.11
date     92.08.13.11.35.38;  author davidj;  state Exp;
branches ;
next     39.10;

39.10
date     92.08.10.16.23.55;  author davidj;  state Exp;
branches ;
next     39.9;

39.9
date     92.08.03.16.54.45;  author davidj;  state Exp;
branches ;
next     39.8;

39.8
date     92.07.30.15.45.53;  author davidj;  state Exp;
branches ;
next     39.7;

39.7
date     92.07.28.15.05.34;  author davidj;  state Exp;
branches ;
next     39.6;

39.6
date     92.07.23.17.33.55;  author davidj;  state Exp;
branches ;
next     39.5;

39.5
date     92.07.14.15.46.03;  author davidj;  state Exp;
branches ;
next     39.4;

39.4
date     92.07.01.00.50.35;  author davidj;  state Exp;
branches ;
next     39.3;

39.3
date     92.06.23.23.38.41;  author davidj;  state Exp;
branches ;
next     39.2;

39.2
date     92.06.23.03.14.02;  author davidj;  state Exp;
branches ;
next     39.1;

39.1
date     92.06.22.04.00.09;  author davidj;  state Exp;
branches ;
next     39.0;

39.0
date     92.06.19.08.33.37;  author davidj;  state Exp;
branches ;
next     ;


desc
@initial rcs checkin
@


39.19
log
@*** empty log message ***
@
text
@/* multiview.c
 *
 */

#include "multiview.h"
#include "multiview_rev.h"

/*****************************************************************************/

#define	DB(x)	;
#define	DC(x)	;
#define	DM(x)	;
#define	DR(x)	;
#define	DX(x)	;
#define	DD(x)	;

/*****************************************************************************/

void kprintf (void *, ...);

/*****************************************************************************/

char *version = VERSTAG;

/*****************************************************************************/

extern struct Cmd cmdArray[];

/*****************************************************************************/

#undef	SysBase

/*****************************************************************************/

int cmd_start (void)
{
    struct ExecBase *SysBase = (*((struct ExecBase **) 4));
    extern STRPTR ARexxPortName (AREXXCONTEXT ac);
    LONG failureLevel = RETURN_FAIL;
    struct WBStartup *wbMsg = NULL;
    struct Process *process;
    struct GlobalData *gd;
    LONG failureCode = 0;
    struct Node *node;

    process = (struct Process *) SysBase->ThisTask;
    if (!(process->pr_CLI))
    {
	WaitPort (&process->pr_MsgPort);
	wbMsg = (struct WBStartup *) GetMsg (&process->pr_MsgPort);
    }

    if (SysBase->LibNode.lib_Version < 39)
    {
	failureCode = ERROR_INVALID_RESIDENT_LIBRARY;
	PrintF (NULL, 0, MV_ERROR_REQUIRES_V39, NULL);
    }
    else if (gd = AllocVec (sizeof (struct GlobalData), MEMF_CLEAR))
    {
	gd->gd_Process = (struct Process *) SysBase->ThisTask;
	gd->gd_SysBase = SysBase;
	gd->gd_Going = TRUE;
	gd->gd_Trigger.MethodID = DTM_TRIGGER;
	gd->gd_SourceType = DTST_FILE;

	DOSBase = OpenLibrary ("dos.library", 39);
	IntuitionBase = OpenLibrary ("intuition.library", 39);
	GfxBase = OpenLibrary ("graphics.library", 39);
	UtilityBase = OpenLibrary ("utility.library", 39);
	WorkbenchBase = OpenLibrary ("workbench.library", 39);
	IconBase = OpenLibrary ("icon.library", 39);
	GadToolsBase = OpenLibrary ("gadtools.library", 39);
	LayersBase = OpenLibrary ("layers.library", 39);

	AslBase        = OpenLibrary ("asl.library", 37);
	RexxSysBase    = OpenLibrary ("rexxsyslib.library", 0L);

	if (LocaleBase = OpenLibrary ("locale.library", 38))
	    gd->gd_Catalog = OpenCatalogA (NULL, "Sys/utilities.catalog", NULL);

	if (DataTypesBase = OpenLibrary ("datatypes.library", 0))
	{
	    /* Allocate the command processor */
	    if ((failureCode == 0) && (gd->gd_CmdHeader = AllocCmdProcessor (cmdArray, gd)))
	    {
		if (gd->gd_BlockO = AllocBlockPointer (gd))
		{
		/* Allocate the window class */
		if (gd->gd_WindowClass = initWindowClass (gd))
		{
		    /* Create the Intuition message port */
		    gd->gd_IDCMPPort = CreateMsgPort ();

		    /* Create the Workbench message port */
		    gd->gd_AWPort = CreateMsgPort ();

		    if (gd->gd_IDCMPPort && gd->gd_AWPort)
		    {
#undef	GfxBase
			gd->gd_TextFont = ((struct GfxBase *) gd->gd_GfxBase)->DefaultFont;
#define	GfxBase	gd->gd_GfxBase

			strcpy (gd->gd_FontName, gd->gd_TextFont->tf_Message.mn_Node.ln_Name);
			gd->gd_TextAttr.ta_Name = gd->gd_FontName;
			gd->gd_TextAttr.ta_YSize = gd->gd_TextFont->tf_YSize;
			gd->gd_TextAttr.ta_Style = gd->gd_TextFont->tf_Style;
			gd->gd_TextAttr.ta_Flags = gd->gd_TextFont->tf_Flags;

			NewList (&gd->gd_WindowList);
			NewList ((struct List *) &gd->gd_UserMenuList);

			strcpy (gd->gd_ARexxPortName, "MULTIVIEW");

			/***********************/
			/* Workbench arguments */
			/***********************/

			if (wbMsg)
			{
			    struct WBArg *wa;

			    wa = wbMsg->sm_ArgList;

			    /* Get arguments from the tool icon */
			    GetIconArgs (gd, wa, TRUE);

			    /* Do we have a project icon */
			    if (wbMsg->sm_NumArgs > 1)
			    {
				wa++;

				/* Get arguments from the project icon */
				GetIconArgs (gd, wa, FALSE);

				NameFromLock (wa->wa_Lock, gd->gd_NameBuffer, sizeof (gd->gd_NameBuffer));
				AddPart (gd->gd_NameBuffer, wa->wa_Name, sizeof (gd->gd_NameBuffer));
				gd->gd_SourceName = (APTR) gd->gd_NameBuffer;
			    }
			}

			/*******************/
			/* Shell Arguments */
			/*******************/

			else if (gd->gd_RDArgs = ReadArgs (TEMPLATE, gd->gd_Options, NULL))
			{
			    if (!((SIGBREAKF_CTRL_C & CheckSignal (SIGBREAKF_CTRL_C))))
			    {
				gd->gd_SourceName = (APTR) gd->gd_Options[OPT_FILE];
				if (gd->gd_Options[OPT_FILE])
				{
				    strcpy (gd->gd_NameBuffer, (STRPTR) gd->gd_Options[OPT_FILE]);
				    gd->gd_SourceName = gd->gd_NameBuffer;
				}

				if (gd->gd_Options[OPT_CLIPUNIT])
				    gd->gd_Unit = *((ULONG *) gd->gd_Options[OPT_CLIPUNIT]);

				/* Must be initialized after CLIPUNIT */
				if (gd->gd_Options[OPT_CLIPBOARD])
				{
				    gd->gd_SourceType = DTST_CLIPBOARD;
				    gd->gd_SourceName = (APTR) gd->gd_Unit;
				    gd->gd_NameBuffer[0] = 0;
				}

				if (gd->gd_Options[OPT_SCREEN])
				{
				    strcpy (gd->gd_ScreenNameBuffer, "MultiView");
				    gd->gd_Flags |= GDF_SCREEN;
				}
				else if (gd->gd_Options[OPT_PUBSCREEN])
				{
				    strcpy (gd->gd_ScreenNameBuffer, (STRPTR) gd->gd_Options[OPT_PUBSCREEN]);
				    gd->gd_ScreenName = gd->gd_ScreenNameBuffer;
				}
				else
				{
				    GetDefaultPubScreen (gd->gd_ScreenNameBuffer);
				    gd->gd_ScreenName = gd->gd_ScreenNameBuffer;
				}

				if (gd->gd_Options[OPT_FONTSIZE])
				    gd->gd_TextAttr.ta_YSize = *((ULONG *) gd->gd_Options[OPT_FONTSIZE]);

				if (gd->gd_Options[OPT_FONTNAME])
				{
				    struct Library *DiskfontBase;

				    sprintf (gd->gd_FontName, "%s.font", (STRPTR) gd->gd_Options[OPT_FONTNAME]);
				    if (DiskfontBase = OpenLibrary ("diskfont.library", 0))
				    {
					if (gd->gd_TextFont = OpenDiskFont (&gd->gd_TextAttr))
					    gd->gd_Flags |= GDF_OPENFONT;
					CloseLibrary (DiskfontBase);
				    }
				}

				if (gd->gd_Options[OPT_PORTNAME])
				{
				    strcpy (gd->gd_ARexxPortName, (STRPTR) gd->gd_Options[OPT_PORTNAME]);
				}
			    }
			    else
			    {
				failureCode = gd->gd_SecondaryResult = ERROR_BREAK;
			    }
			}
			else
			{
			    failureCode = gd->gd_SecondaryResult = IoErr ();
			}

			/* Initialize the ARexx handler */
			if (gd->gd_Options[OPT_PORTNAME])
			{
			    if (!(gd->gd_ARexxHandle = InitARexx (gd->gd_ARexxPortName, "mv", TRUE)))
			    {
				failureCode = gd->gd_SecondaryResult = ERROR_OBJECT_EXISTS;
			    }
			}
			else
			{
			    gd->gd_ARexxHandle = InitARexx (gd->gd_ARexxPortName, "mv", FALSE);
			}

			if (gd->gd_ARexxHandle)
			{
			    strcpy (gd->gd_ARexxPortName, ARexxPortName (gd->gd_ARexxHandle));
			}

			/************/
			/* Bookmark */
			/************/

			if ((failureCode == 0) && gd->gd_Options[OPT_BOOKMARK])
			{
			    BPTR fh;

			    /* Open the bookmark file */
			    if (fh = Open ("ENV:MultiView.bookmark", MODE_OLDFILE))
			    {
				/* Real simple for right now.  Just the name.
				 * I'm going to change this to topv, toph, name, node */
				if (Read (fh, gd->gd_NameBuffer, NAMEBUFSIZE) > 0)
				    gd->gd_SourceName = gd->gd_NameBuffer;

				/* Close the bookmark file */
				Close (fh);
			    }
			    else
			    {
				failureCode = IoErr ();
				gd->gd_SecondaryResult = MV_ERROR_COULDNT_LOAD_BOOKMARK;
			    }
			}

			/****************************/
			/* File requester arguments */
			/****************************/

			/* See if we need to pop up a file requester */
			if ((failureCode == 0) && (gd->gd_SourceType == DTST_FILE) && (gd->gd_Options[OPT_WINDOW] == 0))
			{
			    struct DataType *dtn;
			    BOOL request = FALSE;
			    BPTR lock;
			    UBYTE lc;

			    if (gd->gd_SourceName)
			    {
				/* Determine if it is a directory */
				if (lock = Lock (gd->gd_SourceName, ACCESS_READ))
				{
				    /* Get the object type */
				    if (dtn = ObtainDataTypeA (DTST_FILE, (APTR) lock, NULL))
				    {
					/* If the object type is a directory, then we will bring up
					 * the file requester. */
					if (Stricmp (dtn->dtn_Header->dth_Name, "directory") == 0)
					{
					    /* Tack on a / if needed */
					    lc = gd->gd_NameBuffer[(strlen (gd->gd_NameBuffer) - 1)];
					    if ((lc != '/') && (lc != ':'))
						strcat (gd->gd_NameBuffer, "/");
					    request = TRUE;
					}

					/* Done with the datatype, so release it */
					ReleaseDataType (dtn);
				    }
				    UnLock (lock);
				}
			    }
			    else
				request = TRUE;

			    if (request)
			    {
				/* Get a pointer to the destination screen */
				if (!(gd->gd_Screen = LockPubScreen (gd->gd_ScreenName)))
				    gd->gd_Screen = LockPubScreen (NULL);

				/* Load the file requester snapshot */
				LoadSnapShot (gd);

				/* Pop up the file requester */
				ScreenToFront (gd->gd_Screen);
				if (FileRequest (gd, 0, GetString (gd, MV_TITLE_SELECT_FILE_TO_OPEN), GetString (gd, MV_LABEL_OPEN), gd->gd_NameBuffer))
				{
				    gd->gd_SourceName = (APTR) gd->gd_NameBuffer;
				    strcpy (gd->gd_NameBuffer, (STRPTR) gd->gd_SourceName);
				}
				else
				{
				    failureCode = gd->gd_SecondaryResult = ERROR_BREAK;
				    /* ERROR_REQUIRED_ARG_MISSING; */
				}

				/* Unlock the temporary screen */
				UnlockPubScreen (NULL, gd->gd_Screen);
				gd->gd_Screen = NULL;
			    }
			}

			/*********/
			/* Do It */
			/*********/

			/* Success so far? */
			if (failureCode == 0)
			{
			    /* Make sure we have a name to start with */
			    if (gd->gd_SourceName || (gd->gd_SourceType == DTST_CLIPBOARD))
			    {
				if (!(gd->gd_DataObject = NewDTObject (gd->gd_SourceName,
									DTA_SourceType,		gd->gd_SourceType,
									DTA_TextAttr,		(ULONG) & gd->gd_TextAttr,
									DTA_ARexxPortName,	(ULONG)gd->gd_ARexxPortName,
									GA_Immediate,		TRUE,
									GA_RelVerify,		TRUE,
									TAG_DONE)))
				{
				    failureCode = gd->gd_SecondaryResult = IoErr ();
				}
			    }
			    else if (!gd->gd_Options[OPT_WINDOW])
			    {
				failureCode = gd->gd_SecondaryResult = ERROR_REQUIRED_ARG_MISSING;
			    }

			    if (failureCode == 0)
			    {
				/* Open the required display environment */
				if (OpenEnvironment (gd))
				{
				    /* Handle input */
				    HandleEvents (gd);

				    /* Indicate success */
				    gd->gd_SecondaryResult = 0;
				    failureCode = 0;
				    failureLevel = RETURN_OK;

				    /* Close the display environment */
				    CloseEnvironment (gd, 2);
				}
				else
				{
				    failureCode = gd->gd_SecondaryResult;
				}
			    }
			}

			/***********/
			/* Cleanup */
			/***********/

			if (gd->gd_FR)
			    FreeAslRequest (gd->gd_FR);

			while (node = RemHead ((struct List *)&gd->gd_UserMenuList))
			    FreeVec (node);

			if (gd->gd_Flags & GDF_OPENFONT)
			    CloseFont (gd->gd_TextFont);

			/* Free the shell arguments */
			FreeArgs (gd->gd_RDArgs);
		    }

		    /* Delete the IDCMP port */
		    DeleteMsgPort (gd->gd_IDCMPPort);

		    /* Delete the AppWindow message port */
		    DeleteMsgPort (gd->gd_AWPort);

		    /* Free the window class */
		    freeWindowClass (gd->gd_WindowClass);
		}

		    FreeBlockPointer (gd, gd->gd_BlockO);
		}

		/* Free the command processor */
		FreeCmdProcessor (gd->gd_CmdHeader);
	    }

	    if (failureCode != ERROR_BREAK)
		PrintF (gd, gd->gd_Options[OPT_REQUESTER], gd->gd_SecondaryResult, FilePart (gd->gd_NameBuffer));

	    /* Free the ARexx handler */
	    FreeARexx (gd->gd_ARexxHandle);

	    /* Close datatypes.library */
	    CloseLibrary (DataTypesBase);
	}
	else
	{
	    gd->gd_SecondaryResult = MV_ERROR_NO_DATATYPES;
	    failureCode = ERROR_INVALID_RESIDENT_LIBRARY;
	    PrintF (gd, gd->gd_Options[OPT_REQUESTER], gd->gd_SecondaryResult, NULL);
	}

	if (LocaleBase)
	{
	    CloseCatalog (gd->gd_Catalog);
	    CloseLibrary (LocaleBase);
	}

	CloseLibrary (RexxSysBase);
	CloseLibrary (AslBase);
	CloseLibrary (LayersBase);
	CloseLibrary (GadToolsBase);
	CloseLibrary (IconBase);
	CloseLibrary (WorkbenchBase);
	CloseLibrary (UtilityBase);
	CloseLibrary (GfxBase);
	CloseLibrary (IntuitionBase);
	CloseLibrary (DOSBase);
	FreeVec (gd);
    }
    else
    {
	failureCode = ERROR_NO_FREE_STORE;
	PrintF (NULL, 0, failureCode, NULL);
    }

    if (wbMsg)
    {
	Forbid ();
	ReplyMsg ((struct Message *) wbMsg);
    }

    process->pr_Result2 = failureCode;
    return (failureLevel);
}

/*****************************************************************************/

#define	SysBase		 gd->gd_SysBase

/*****************************************************************************/

void GetIconArgs (struct GlobalData * gd, struct WBArg * wa, BOOL tool)
{
    struct DiskObject *dob;
    UBYTE buffer[300];
    BPTR oldLock;
    STRPTR tmp;
    ULONG hold;

    /* Make it the current directory */
    oldLock = CurrentDir (wa->wa_Lock);

    /*
     * Bug in Workbench makes it so that wa_Lock doesn't have the correct directory lock if you specify the tool name without the path in the project icon
     */
    if (tool)
	sprintf (buffer, "PROGDIR:%s", wa->wa_Name);
    else
	strcpy (buffer, wa->wa_Name);

    /* Get the tool icon */
    if (dob = GetDiskObject (buffer))
    {
	if (tmp = FindToolType (dob->do_ToolTypes, "CLIPUNIT"))
	    if (StrToLong (tmp, &hold) > 0L)
		gd->gd_Unit = hold;

	/* Must be initialized after CLIPUNIT */
	if (FindToolType (dob->do_ToolTypes, "CLIPBOARD"))
	{
	    gd->gd_SourceType = DTST_CLIPBOARD;
	    gd->gd_SourceName = (APTR) gd->gd_Unit;
	    gd->gd_NameBuffer[0] = 0;
	}

	if (FindToolType (dob->do_ToolTypes, "SCREEN"))
	{
	    strcpy (gd->gd_ScreenNameBuffer, "MultiView");
	    gd->gd_Options[OPT_SCREEN] = TRUE;
	    gd->gd_Flags |= GDF_SCREEN;
	}
	else if (tmp = FindToolType (dob->do_ToolTypes, "PUBSCREEN"))
	{
	    strcpy (gd->gd_ScreenNameBuffer, tmp);
	    gd->gd_ScreenName = gd->gd_ScreenNameBuffer;
	}
	else
	{
	    GetDefaultPubScreen (gd->gd_ScreenNameBuffer);
	    gd->gd_ScreenName = gd->gd_ScreenNameBuffer;
	}

	if (tmp = FindToolType (dob->do_ToolTypes, "FONTSIZE"))
	    if (StrToLong (tmp, &hold) > 0L)
		gd->gd_TextAttr.ta_YSize = hold;

	if (tmp = FindToolType (dob->do_ToolTypes, "FONTNAME"))
	{
	    struct Library *DiskfontBase;

	    sprintf (gd->gd_FontName, "%s.font", tmp);

	    if (DiskfontBase = OpenLibrary ("diskfont.library", 0))
	    {
		if (gd->gd_TextFont = OpenDiskFont (&gd->gd_TextAttr))
		    gd->gd_Flags |= GDF_OPENFONT;
		CloseLibrary (DiskfontBase);
	    }
	}

	if (FindToolType (dob->do_ToolTypes, "BOOKMARK"))
	    gd->gd_Options[OPT_BOOKMARK] = TRUE;

	if (FindToolType (dob->do_ToolTypes, "BACKDROP"))
	    gd->gd_Options[OPT_BACKDROP] = TRUE;

	if (FindToolType (dob->do_ToolTypes, "WINDOW"))
	    gd->gd_Options[OPT_WINDOW] = TRUE;

	if (tmp = FindToolType (dob->do_ToolTypes, "PORTNAME"))
	    strcpy (gd->gd_ARexxPortName, (STRPTR) tmp);

	/* Free the icon */
	FreeDiskObject (dob);
    }

    /* Go back to the previous directory */
    CurrentDir (oldLock);
}

/*****************************************************************************/

struct Screen *OpenEnvironment (struct GlobalData * gd)
{
    ULONG text, back, shine, shadow, fill, detail, block;
    ULONG backdrop = gd->gd_Options[OPT_BACKDROP];
    ULONG useScreen = gd->gd_Options[OPT_SCREEN];
    ULONG *cregs = NULL, numcolors, i, r, g, b;
    ULONG backfill = (ULONG) LAYERS_BACKFILL;
    LONG left, top, width, height;
    UWORD pens[NUMDRIPENS + 1];
    ULONG modeid = INVALID_ID;
    struct BitMapHeader *bmhd;
    struct BitMap *bm = NULL;
    struct DimensionInfo dim;
    struct Rectangle rect;
    struct dtFrameBox dtf;
    struct FrameInfo *fri;
    BOOL notbusy = FALSE;
    struct ColorMap *cm;
    struct gpLayout gpl;
    struct Screen *scr;
    ULONG table[8][3];
    BOOL remap = TRUE;
    ULONG woaf = NULL;
    ULONG maxnum;
    STRPTR title;
    ULONG scrTypeTag;

    title = GetString (gd, MV_TITLE_LOADING);

    /* Doesn't require a screen */
    gd->gd_Flags &= ~GDF_REQUIRES_SCREEN;

    if (gd->gd_DataObject)
    {
	/* Get the mode ID */
	GetAttr (PDTA_ModeID, gd->gd_DataObject, (ULONG *) & modeid);

	/* Ask the object what kind of environment it needs */
	dtf.MethodID = DTM_FRAMEBOX;
	dtf.dtf_FrameInfo = fri = &gd->gd_FrameInfo;
	dtf.dtf_ContentsInfo = &gd->gd_FrameInfo;
	dtf.dtf_SizeFrameInfo = sizeof (struct FrameInfo);
	dtf.dtf_FrameFlags = NULL;
	if (DoMethodA (gd->gd_DataObject, &dtf) && fri->fri_Dimensions.Depth)
	{
	    if ((fri->fri_PropertyFlags & DIPF_IS_HAM) ||
		(fri->fri_PropertyFlags & DIPF_IS_EXTRAHALFBRITE))
	    {
		/* Requires a screen */
		gd->gd_Flags |= GDF_REQUIRES_SCREEN;

		useScreen = TRUE;
	    }

	    if ((fri->fri_PropertyFlags == 0) && (modeid & 0x800) && (modeid != INVALID_ID))
	    {
		/* Requires a screen */
		gd->gd_Flags |= GDF_REQUIRES_SCREEN;

		useScreen = TRUE;
	    }
	}
    }
    else if (gd->gd_Options[OPT_WINDOW])
    {
	title = GetString (gd, MV_TITLE_MULTIVIEW);
	useScreen = FALSE;
	notbusy = TRUE;
    }
    else
    {
	return NULL;
    }

    /* Should we use a custom screen? */
    if (useScreen)
    {
	/* Lock the default public screen so we know what to look like */
	if (scr = LockPubScreen (NULL))
	{
	    /* Provide some reasonable default values */
	    pens[0] = (USHORT)(~0);
	    detail = (ULONG) scr->DetailPen;
	    block = (ULONG) scr->BlockPen;

	    /* Get the picture information */
	    getdtattrs (gd, gd->gd_DataObject,
			PDTA_CRegs, &cregs,
			PDTA_NumColors, &numcolors,
			PDTA_BitMapHeader, &bmhd,
			TAG_DONE);

	    /* If we don't have a valid mode ID, then be like the Workbench */
	    if (modeid == INVALID_ID)
	    {
		modeid = GetVPModeID (&scr->ViewPort);
		fri->fri_Dimensions.Depth = MIN (2, scr->RastPort.BitMap->Depth);
	    }

	    /* Should the picture be remapped? */
	    if (bmhd)
		remap = (bmhd->bmh_Depth == fri->fri_Dimensions.Depth) ? FALSE : TRUE;
	    setdtattrs (gd, gd->gd_DataObject, NULL, PDTA_Remap, remap, TAG_DONE);

	    /* Do we have color registers? */
	    if (cregs)
	    {
		/* Get a temporary color map */
		if (cm = GetColorMap (numcolors))
		{
		    /* Set the colors in the temporary color map */
		    for (i = 0; i < numcolors; i++)
		    {
			/* Pull the color components */
			r = cregs[i * 3 + 0];
			g = cregs[i * 3 + 1];
			b = cregs[i * 3 + 2];

			/* Set the color */
			SetRGB32CM (cm, i, r, g, b);
		    }

		    /* Determine the maximum number of colors to try finding within */
		    maxnum = numcolors - 1;
		    if (modeid & 0x800)
			maxnum = (1 << (fri->fri_Dimensions.Depth - 2)) - 1;

		    /* Get the GUI colors from the default public screen */
		    GetRGB32 (scr->ViewPort.ColorMap, 0, 4, (ULONG *) table);

		    if (remap)
		    {
			/* Get the closest colors in the picture's color map */
			back = FindColor (scr->ViewPort.ColorMap, table[0][0], table[0][1], table[0][2], 4);
			shadow = FindColor (scr->ViewPort.ColorMap, table[1][0], table[1][1], table[1][2], 4);
			shine = FindColor (scr->ViewPort.ColorMap, table[2][0], table[2][1], table[2][2], 4);
			fill = FindColor (scr->ViewPort.ColorMap, table[3][0], table[3][1], table[3][2], 4);
		    }
		    else
		    {
			/* Get the closest colors in the picture's color map */
			back = FindColor (cm, table[0][0], table[0][1], table[0][2], maxnum);
			shadow = FindColor (cm, table[1][0], table[1][1], table[1][2], maxnum);
			shine = FindColor (cm, table[2][0], table[2][1], table[2][2], maxnum);
			fill = FindColor (cm, table[3][0], table[3][1], table[3][2], maxnum);
		    }

		    /* Set the pens */
		    text = (shadow == back) ? shine : shadow;
		    pens[DETAILPEN] = detail = back;
		    pens[BLOCKPEN] = block = shadow;
		    pens[TEXTPEN] = text;
		    pens[SHINEPEN] = shine;
		    pens[SHADOWPEN] = shadow;
		    pens[FILLPEN] = fill;
		    pens[FILLTEXTPEN] = text;
		    pens[HIGHLIGHTTEXTPEN] = shine;
		    pens[BACKGROUNDPEN] = back;
		    pens[BARDETAILPEN] = shadow;
		    pens[BARBLOCKPEN] = shine;
		    pens[BARTRIMPEN] = shadow;
		    pens[NUMDRIPENS] = (USHORT)(~0);

		    /* Free the temporary color map */
		    FreeColorMap (cm);
		}
		backfill = (ULONG) LAYERS_NOBACKFILL;
		backdrop = TRUE;
	    }

	    /* Close the existing environment */
	    CloseEnvironment (gd, 0);

	    if (bmhd)
	    {
		/* Use the nominal size */
		GetDisplayInfoData (NULL, (APTR) & dim, sizeof (struct DimensionInfo), DTAG_DIMS, modeid);

		/* Default to the standard video overscan display clip */
		rect = *(&dim.StdOScan);

		/* If the width is less then the nominal width, then use the nominal width */
		if (bmhd->bmh_Width <= (dim.Nominal.MaxX - dim.Nominal.MinX + 1))
		{
		    rect.MinX = dim.Nominal.MinX;
		    rect.MaxX = dim.Nominal.MaxX;
		}
		/* If the size is less than the standard video overscan then adjust the display clip */
		else if (bmhd->bmh_Width < (rect.MaxX - rect.MinX + 1))
		    rect.MaxX = bmhd->bmh_Width + rect.MinX - 1;

		/* If the height is less then the nominal height, then use the nominal height */
		if (bmhd->bmh_Height <= (dim.Nominal.MaxY - dim.Nominal.MinY + 1))
		{
		    rect.MinY = dim.Nominal.MinY;
		    rect.MaxY = dim.Nominal.MaxY;
		}
		/* If the size is less than the standard video overscan then adjust the display clip */
		else if (bmhd->bmh_Height < (rect.MaxY - rect.MinY + 1))
		    rect.MaxY = bmhd->bmh_Height + rect.MinY - 1;

		/* Calculate the size of the screen */
		width = MAX (bmhd->bmh_Width, rect.MaxX - rect.MinX + 1);
		height = MAX (bmhd->bmh_Height, rect.MaxY - rect.MinY + 1);

		/* The picture isn't going to be remapped, so come up with the custom bitmap */
		if (!remap && (bmhd->bmh_Width >= width) && (bmhd->bmh_Height >= height))
		{
		    /* Tell the object to generate the bitmap pointer */
		    gpl.MethodID = DTM_PROCLAYOUT;
		    gpl.gpl_GInfo = NULL;
		    gpl.gpl_Initial = 1;

		    if (DoMethodA (gd->gd_DataObject, &gpl))
		    {
			/* Get a pointer to the bitmap */
			getdtattrs (gd, gd->gd_DataObject, PDTA_BitMap, &bm, TAG_DONE);

			woaf = WOAF_BITMAP;
			gd->gd_Flags |= GDF_BITMAP;
		    }
		    else
			bm = NULL;
		}
		else
		    bm = NULL;
	    }
	    else
	    {
		/* Get the overscan text size */
		QueryOverscan (modeid, &rect, OSCAN_TEXT);

		/* calculate the size of the screen */
		width = rect.MaxX - rect.MinX + 1;
		height = rect.MaxY - rect.MinY + 1;

		/* No custom bitmap */
		bm = NULL;
	    }

	    /* Open the new screen */
	    if (gd->gd_Screen = openscreentags (gd,
						SA_Title, GetString (gd, MV_TITLE_MULTIVIEW),
						SA_Width, (ULONG) width,
						SA_Height, (ULONG) height,
						SA_Depth, (ULONG) fri->fri_Dimensions.Depth,
						SA_DClip, &rect,
						SA_AutoScroll, TRUE,
						SA_DisplayID, modeid,
						SA_Interleaved, TRUE,
						SA_SharePens, TRUE,
						SA_SysFont, 1,
						SA_ShowTitle, !(backdrop),
						SA_Quiet, backdrop,
						SA_Behind, TRUE,
						SA_Pens, pens,
						SA_BackFill, backfill,
						SA_DetailPen, detail,
						SA_BlockPen, block,
						((bm) ? SA_BitMap : TAG_IGNORE), bm,
						TAG_DONE))
	    {
		/* Show that we opened the screen */
		gd->gd_Flags |= GDF_OPENSCREEN;

		/* Load the color map */
		if (cregs && !remap)
		{
		    numcolors = 2 << (gd->gd_Screen->RastPort.BitMap->Depth - 1);
#if 0
		    LoadRGB32 (&gd->gd_Screen->ViewPort,
#else
		    for (i = 0; i < numcolors; i++)
		    {
			r = cregs[i * 3 + 0];
			g = cregs[i * 3 + 1];
			b = cregs[i * 3 + 2];
			SetRGB32 (&gd->gd_Screen->ViewPort, i, r, g, b);
		    }
#endif
		}
	    }

	    /* Unlock the public screen */
	    UnlockPubScreen (NULL, scr);
	}
    }
    else
    {
	CloseEnvironment (gd, 1);

	/* get a pointer to the default public gd->gd_Screen */
	gd->gd_Screen = LockPubScreen (gd->gd_ScreenName);
    }

    if (gd->gd_Screen)
    {
	if (gd->gd_VI = GetVisualInfoA (gd->gd_Screen, TAG_DONE))
	{
	    if (gd->gd_DrawInfo = GetScreenDrawInfo (gd->gd_Screen))
	    {
		frameobject (gd);

		if (!gd->gd_WindowObj)
		{
		    LoadSnapShot (gd);

		    getdtattrs (gd, gd->gd_DataObject,
				DTA_NominalHoriz, &gd->gd_TotHoriz,
				DTA_NominalVert, &gd->gd_TotVert,
				TAG_DONE);

		    if (gd->gd_TotHoriz == 0)
		    {
			gd->gd_TotHoriz = gd->gd_Prefs.p_Window.Width;
			gd->gd_Flags |= GDF_SNAPSHOT;
		    }

		    if (gd->gd_TotVert == 0)
		    {
			gd->gd_TotVert = gd->gd_Prefs.p_Window.Height;
		    }

		    gd->gd_VisVert = gd->gd_TotVert;
		    gd->gd_VisHoriz = gd->gd_TotHoriz;

		    top = gd->gd_Prefs.p_Window.Top,
		      left = gd->gd_Prefs.p_Window.Left,
		      width = gd->gd_TotHoriz + 4,
		      height = gd->gd_TotVert + 2,

		    /* Show that we are a backdrop */
		      woaf |= ((useScreen) ? NULL : WOAF_BACKDROP);

		    /* Figure out screen type */
		    scrTypeTag = (gd->gd_Flags & GDF_SCREEN) ? WA_CustomScreen : WA_PubScreen;

		    /* allocate and initialize a scroller as a BOOPSI object */
		    gd->gd_WindowObj = newobject (gd, gd->gd_WindowClass, NULL,
						  ((backdrop) ? TAG_IGNORE : WA_Left), left,
						  ((backdrop) ? TAG_IGNORE : WA_Top), top,
						  ((backdrop) ? TAG_IGNORE : WA_InnerWidth), width,
						  ((backdrop) ? TAG_IGNORE : WA_InnerHeight), height,
						  WA_Zoom,	&gd->gd_Prefs.p_Zoom,
						  scrTypeTag,	gd->gd_Screen,
						  DTA_Title,	title,
						  DTA_TopVert,	gd->gd_TotVert,
						  DTA_TopHoriz,	gd->gd_TotHoriz,
						  WOA_DrawInfo,	gd->gd_DrawInfo,
						  WOA_IDCMPPort,gd->gd_IDCMPPort,
						  WOA_AWPort,	gd->gd_AWPort,
						  WOA_Backdrop,	backdrop,
						  WOA_Flags,	woaf,
						  ICA_TARGET,	ICTARGET_IDCMP,
						  TAG_DONE);
		}

		if (gd->gd_WindowObj)
		{
		    /* Get a pointer to the window */
		    GetAttr (WOA_Window, gd->gd_WindowObj, (ULONG *) & gd->gd_Window);

		    /* Update the object attributes */
		    SetDataObjectAttrs (gd);

		    /* Bring the screen to the front */
		    ScreenToFront (window->WScreen);

		    /* Clear the busy pointer if we should */
		    if (notbusy)
			setwindowpointer (gd, window, WA_Pointer, NULL, TAG_DONE);

		    /* Allow menus to be used */
		    gd->gd_Window->Flags &= ~WFLG_RMBTRAP;

		    return gd->gd_Screen;
		}
	    }
	}
    }
    gd->gd_SecondaryResult = MV_ERROR_COULDNT_OPEN_ENV;
    CloseEnvironment (gd, 2);
    return NULL;
}

/*****************************************************************************/

VOID CloseEnvironment (struct GlobalData * gd, UWORD which)
{

    if (gd->gd_DataObject && (which == 2))
    {
	/* Remove the object from the window */
	DoMethod ((Object *) gd->gd_WindowObj, WOM_REMVIEW, (ULONG) gd->gd_DataObject);

	if (!(gd->gd_Flags & GDF_BITMAP))
	{
	    /* Get rid of the data object */
	    DisposeDTObject (gd->gd_DataObject);
	    gd->gd_DataObject = NULL;
	}
    }

    if (gd->gd_Screen)
    {
	if ((which != 1) || (gd->gd_Flags & GDF_OPENSCREEN))
	{
	    if (gd->gd_WindowObj)
	    {
		DisposeObject (gd->gd_WindowObj);
		gd->gd_WindowObj = NULL;
	    }
	}

	FreeScreenDrawInfo (gd->gd_Screen, gd->gd_DrawInfo);
	FreeVisualInfo (gd->gd_VI);
	gd->gd_DrawInfo = NULL;
	gd->gd_VI = NULL;

	if (gd->gd_Flags & GDF_OPENSCREEN)
	{
	    while (!CloseScreen (gd->gd_Screen))
		Delay (2);
	}
	else
	    UnlockPubScreen (NULL, gd->gd_Screen);
	gd->gd_Flags &= ~(GDF_OPENSCREEN | GDF_SNAPSHOT);
	gd->gd_Screen = NULL;
    }

    if (gd->gd_DataObject && (which == 2) && (gd->gd_Flags & GDF_BITMAP))
    {
	/* Get rid of the data object */
	DisposeDTObject (gd->gd_DataObject);
	gd->gd_DataObject = NULL;
    }

    gd->gd_Flags &= ~GDF_BITMAP;
}

/*****************************************************************************/

VOID AboutObject (struct GlobalData * gd)
{
    struct DataType *dtn = NULL;
    struct EasyStruct es;
    STRPTR s1, s2;
    UWORD i;

    if (gd->gd_DataObject)
    {
	getdtattrs (gd, gd->gd_DataObject, DTA_DataType, (ULONG) & dtn, TAG_DONE);
	s1 = dtn->dtn_Header->dth_Name;
	s2 = GetDTString (dtn->dtn_Header->dth_GroupID);
    }
    else
    {
	s1 = GetString (gd, MV_TITLE_EMPTY);
	s2 = "";
    }

    strncpy (gd->gd_TempBuffer, DataTypesBase->lib_IdString, 40);
    i = strlen (gd->gd_TempBuffer);
    if (gd->gd_TempBuffer[(i - 2)] == '\r')
	gd->gd_TempBuffer[(i - 2)] = 0;

    es.es_StructSize = sizeof (struct EasyStruct);
    es.es_Flags = 0;
    es.es_Title = GetString (gd, MV_TITLE_MULTIVIEW);
    es.es_TextFormat = "MultiView %ld.%ld (%s)\n%s\n\n%s %s";
    es.es_GadgetFormat = GetString (gd, MV_LABEL_CONTINUE);

    easyrequest (gd, &es, VERSION, REVISION, DATE, gd->gd_TempBuffer, s1, s2);
}
@


39.18
log
@prints error message after title message
sends HELP key through to datatype
@
text
@d38 1
d227 5
d336 7
a342 6
				if (!(gd->gd_DataObject = newdtobject (gd, gd->gd_SourceName,
								       DTA_SourceType, gd->gd_SourceType,
								       DTA_TextAttr, (ULONG) & gd->gd_TextAttr,
								       GA_Immediate, TRUE,
								       GA_RelVerify, TRUE,
								       TAG_DONE)))
@


39.17
log
@disables menu item when screen
@
text
@d85 2
d393 3
@


39.16
log
@clears RMBTRAP when the window is brought to front.
@
text
@d573 3
d592 3
d599 4
d604 1
@


39.15
log
@added SysBase
@
text
@d19 4
a60 3

#define	SysBase		 gd->gd_SysBase

d73 3
a75 3
	AslBase = OpenLibrary ("asl.library", 37);
	RexxSysBase = OpenLibrary ("rexxsyslib.library", 0L);
	AmigaGuideBase = OpenLibrary ("amigaguide.library", 0);
d270 2
a271 4

					/*
					 * If the object type is a directory, then we will bring up the file requester.
					 */
d370 3
a397 1
	    {
a398 1
	    }
a418 4
	if (gd->gd_FR)
	    FreeAslRequest (gd->gd_FR);

	CloseLibrary (AmigaGuideBase);
a428 1

d442 1
d449 4
d550 1
a550 1
    ULONG backfill = LAYERS_BACKFILL;
d569 1
a576 1
	DB (kprintf ("\nMode ID       : 0x%lx\n", modeid));
a585 10
	    DD (kprintf ("PropertyFlags : 0x%lx\n", fri->fri_PropertyFlags));
	    DD (kprintf ("RedBits       : 0x%lx\n", fri->fri_RedBits));
	    DD (kprintf ("GreenBits     : 0x%lx\n", fri->fri_GreenBits));
	    DD (kprintf ("BlueBits      : 0x%lx\n", fri->fri_BlueBits));
	    DD (kprintf ("Width         : %ld\n", (ULONG) fri->fri_Dimensions.Width));
	    DD (kprintf ("Height        : %ld\n", (ULONG) fri->fri_Dimensions.Height));
	    DD (kprintf ("Depth         : %ld\n", (ULONG) fri->fri_Dimensions.Depth));
	    DD (kprintf ("Screen        : 0x%lx\n", fri->fri_Screen));
	    DD (kprintf ("ColorMap      : 0x%lx\n", fri->fri_ColorMap));

a588 1
		DD (kprintf ("HAM or ExtraHalfBrite\n"));
a592 2
	    {
		DD (kprintf ("ModeID=0x%08lx\n", modeid));
a593 1
	    }
d614 1
a614 1
	    pens[0] = ~0;
a623 1
	    DD (kprintf ("cregs=0x%lx, numcolors=%ld\n", cregs, numcolors));
a630 1
	    DB (kprintf ("ModeID        : 0x%lx (0x%lx)\n", modeid, INVALID_ID));
a649 1
			DX (kprintf (" %3ld) %08lx x%08lx %08lx\n", i, r, g, b));
a658 1
		    DD (kprintf ("maxnum=%ld\n", (LONG) maxnum));
d694 1
a694 1
		    pens[NUMDRIPENS] = ~0;
a695 4
		    DD (kprintf ("%s: back=%ld, shadow=%ld, shine=%ld, fill=%ld, text=%ld\n",
				 ((remap) ? "remap" : "noremap"),
				 (LONG) back, (LONG) shadow, (LONG) shine, (LONG) fill, (LONG) text));

a745 2
		    /* CRASHES HERE */
		    DB (kprintf ("ProcLayout : %08lx\n", gd->gd_DataObject));
a800 1
		    DD (kprintf ("set %ld colors. depth=%ld, %ld\n", numcolors, (ULONG) gd->gd_Screen->RastPort.BitMap->Depth, (ULONG) (2 << (gd->gd_Screen->BitMap.Depth - 1))));
d802 3
d812 1
a812 4
		}
		else
		{
		    DD (kprintf ("don't set colors. cregs=0x%lx, remap=%ld\n", cregs, (ULONG) remap));
d867 3
a870 1
		    DC (kprintf ("new Window object\n"));
d876 11
a886 11
						  WA_Zoom, &gd->gd_Prefs.p_Zoom,
						  WA_PubScreen, gd->gd_Screen,
						  DTA_Title, title,
						  DTA_TopVert, gd->gd_TotVert,
						  DTA_TopHoriz, gd->gd_TotHoriz,
						  WOA_DrawInfo, gd->gd_DrawInfo,
						  WOA_IDCMPPort, gd->gd_IDCMPPort,
						  WOA_AWPort, gd->gd_AWPort,
						  WOA_Backdrop, backdrop,
						  WOA_Flags, woaf,
						  ICA_TARGET, ICTARGET_IDCMP,
a887 1
		    DC (kprintf ("window initialized\n"));
d892 1
a892 1
		    DC (kprintf ("get window pointer\n"));
d895 1
a895 1
		    DC (kprintf ("set data attrs\n"));
d898 1
a898 1
		    DC (kprintf ("screen to front\n"));
d901 1
a901 1
		    DC (kprintf ("set pointer\n"));
d905 3
a907 1
		    DC (kprintf ("return %08lx\n", gd->gd_Screen));
a930 1
	    DD (kprintf ("disposing of object (no GDF_BITMAP)\n"));
a941 1
		DD (kprintf ("close backdrop window\n"));
a951 1
	DD (kprintf ("close screen\n"));
a955 1
	    DD (kprintf ("screen closed\n"));
a965 1
	DD (kprintf ("disposing of object (GDF_BITMAP)\n"));
@


39.14
log
@added ARexx support and fixed stale variables
@
text
@d57 3
@


39.13
log
@new window class stuff.
@
text
@d23 4
d39 1
d70 2
d78 2
a79 1
	    if (gd->gd_WindowClass = initWindowClass (gd))
d81 2
a82 1
		if (gd->gd_IDCMPPort = CreateMsgPort ())
d84 7
a90 1
		    if (gd->gd_AWPort = CreateMsgPort ())
d103 1
d105 2
d118 1
a118 1
			    GetIconArgs (gd, wa);
d126 1
a126 1
				GetIconArgs (gd, wa);
a186 1
					{
a187 1
					}
d191 5
d207 13
d224 1
a224 1
			if (gd->gd_Options[OPT_BOOKMARK])
d251 1
a251 1
			if ((failureCode==0) && (gd->gd_SourceType==DTST_FILE) && (gd->gd_Options[OPT_WINDOW]==0))
d266 5
a270 3
					/* If the object type is a directory,
					 * then we will bring up the file requester. */
					if (Stricmp (dtn->dtn_Header->dth_Name, "directory")==0)
d346 3
d350 2
a353 3
				    /* Handle input */
				    HandleEvents (gd);

d368 3
a375 3

			/* Delete the AppWindow message port */
			DeleteMsgPort (gd->gd_AWPort);
d380 6
d388 2
a389 2
		/* Free the window class */
		freeWindowClass (gd->gd_WindowClass);
d397 3
d419 2
d450 1
a450 1
void GetIconArgs (struct GlobalData * gd, struct WBArg * wa)
d453 1
d461 8
d470 1
a470 1
    if (dob = GetDiskObject (wa->wa_Name))
a513 1
		{
a514 1
		}
d528 3
d624 147
a770 4
            /* Provide some reasonable default values */
            pens[0] = ~0;
            detail = (ULONG) scr->DetailPen;
            block  = (ULONG) scr->BlockPen;
d772 21
a792 159
            /* Get the picture information */
            getdtattrs (gd, gd->gd_DataObject,
                        PDTA_CRegs,         &cregs,
                        PDTA_NumColors,     &numcolors,
                        PDTA_BitMapHeader,  &bmhd,
                        TAG_DONE);
            DD (kprintf ("cregs=0x%lx, numcolors=%ld\n", cregs, numcolors));

            /* If we don't have a valid mode ID, then be like the Workbench */
            if (modeid == INVALID_ID)
            {
                modeid = GetVPModeID (&scr->ViewPort);
                fri->fri_Dimensions.Depth = MIN (2, scr->RastPort.BitMap->Depth);
            }
            DB (kprintf ("ModeID        : 0x%lx (0x%lx)\n", modeid, INVALID_ID));

            /* Should the picture be remapped? */
            if (bmhd)
                remap = (bmhd->bmh_Depth == fri->fri_Dimensions.Depth) ? FALSE : TRUE;
            setdtattrs (gd, gd->gd_DataObject, NULL, PDTA_Remap, remap, TAG_DONE);

            /* Do we have color registers? */
            if (cregs)
            {
                /* Get a temporary color map */
                if (cm = GetColorMap (numcolors))
                {
                    /* Set the colors in the temporary color map*/
                    for (i = 0; i < numcolors; i++)
                    {
                        /* Pull the color components */
                        r = cregs[i*3+0]; g = cregs[i*3+1]; b = cregs[i*3+2];
                        DX (kprintf (" %3ld) %08lx x%08lx %08lx\n", i, r, g, b));

                        /* Set the color */
                        SetRGB32CM (cm, i, r, g, b);
                    }

                    /* Determine the maximum number of colors to try finding within */
                    maxnum = numcolors - 1;
                    if (modeid & 0x800)
                        maxnum = (1 << (fri->fri_Dimensions.Depth - 2)) - 1;
                    DD (kprintf ("maxnum=%ld\n", (LONG)maxnum));

                    /* Get the GUI colors from the default public screen */
                    GetRGB32 (scr->ViewPort.ColorMap, 0, 4, (ULONG *)table);

                    if (remap)
                    {
                        /* Get the closest colors in the picture's color map */
                        back   = FindColor (scr->ViewPort.ColorMap, table[0][0], table[0][1], table[0][2], 4);
                        shadow = FindColor (scr->ViewPort.ColorMap, table[1][0], table[1][1], table[1][2], 4);
                        shine  = FindColor (scr->ViewPort.ColorMap, table[2][0], table[2][1], table[2][2], 4);
                        fill   = FindColor (scr->ViewPort.ColorMap, table[3][0], table[3][1], table[3][2], 4);
                    }
                    else
                    {
                        /* Get the closest colors in the picture's color map */
                        back   = FindColor (cm, table[0][0], table[0][1], table[0][2], maxnum);
                        shadow = FindColor (cm, table[1][0], table[1][1], table[1][2], maxnum);
                        shine  = FindColor (cm, table[2][0], table[2][1], table[2][2], maxnum);
                        fill   = FindColor (cm, table[3][0], table[3][1], table[3][2], maxnum);
                    }

                    /* Set the pens */
                    text = (shadow == back) ? shine : shadow;
                    pens[DETAILPEN]        = detail = back;
                    pens[BLOCKPEN]         = block  = shadow;
                    pens[TEXTPEN]          = text;
                    pens[SHINEPEN]         = shine;
                    pens[SHADOWPEN]        = shadow;
                    pens[FILLPEN]          = fill;
                    pens[FILLTEXTPEN]      = text;
                    pens[HIGHLIGHTTEXTPEN] = shine;
                    pens[BACKGROUNDPEN]    = back;
                    pens[BARDETAILPEN]     = shadow;
                    pens[BARBLOCKPEN]      = shine;
                    pens[BARTRIMPEN]       = shadow;
                    pens[NUMDRIPENS]       = ~0;

                    DD (kprintf ("%s: back=%ld, shadow=%ld, shine=%ld, fill=%ld, text=%ld\n",
                                  ((remap) ? "remap" : "noremap"),
                                  (LONG)back, (LONG)shadow, (LONG)shine, (LONG)fill, (LONG)text));

                    /* Free the temporary color map */
                    FreeColorMap (cm);
                }
                backfill = (ULONG) LAYERS_NOBACKFILL;
                backdrop = TRUE;
            }

            /* Close the existing environment */
            CloseEnvironment (gd, 0);

            if (bmhd)
            {
                /* Use the nominal size */
                GetDisplayInfoData (NULL, (APTR) & dim, sizeof (struct DimensionInfo), DTAG_DIMS, modeid);

                /* Default to the standard video overscan display clip */
                rect = *(&dim.StdOScan);

                /* If the width is less then the nominal width, then use the nominal width */
                if (bmhd->bmh_Width  <= (dim.Nominal.MaxX - dim.Nominal.MinX + 1))
                {
                    rect.MinX = dim.Nominal.MinX;
                    rect.MaxX = dim.Nominal.MaxX;
                }
                /* If the size is less than the standard video overscan then adjust the display clip */
                else if (bmhd->bmh_Width  < (rect.MaxX - rect.MinX + 1))
                    rect.MaxX = bmhd->bmh_Width + rect.MinX - 1;

                /* If the height is less then the nominal height, then use the nominal height */
                if (bmhd->bmh_Height <= (dim.Nominal.MaxY - dim.Nominal.MinY + 1))
                {
                    rect.MinY = dim.Nominal.MinY;
                    rect.MaxY = dim.Nominal.MaxY;
                }
                /* If the size is less than the standard video overscan then adjust the display clip */
                else if (bmhd->bmh_Height < (rect.MaxY - rect.MinY + 1))
                    rect.MaxY = bmhd->bmh_Height + rect.MinY - 1;

                /* Calculate the size of the screen */
                width  = MAX (bmhd->bmh_Width,  rect.MaxX - rect.MinX + 1);
                height = MAX (bmhd->bmh_Height, rect.MaxY - rect.MinY + 1);

                /* The picture isn't going to be remapped, so come up with the custom bitmap */
                if (!remap && (bmhd->bmh_Width >= width) && (bmhd->bmh_Height >= height))
                {
                    /* Tell the object to generate the bitmap pointer */
                    gpl.MethodID = DTM_PROCLAYOUT;
                    gpl.gpl_GInfo = NULL;
                    gpl.gpl_Initial = 1;
                    if (DoMethodA (gd->gd_DataObject, &gpl))
                    {
                        /* Get a pointer to the bitmap */
                        getdtattrs (gd, gd->gd_DataObject, PDTA_BitMap, &bm, TAG_DONE);

                        woaf = WOAF_BITMAP;
                        gd->gd_Flags |= GDF_BITMAP;
                    }
                    else
                        bm = NULL;
                }
                else
                    bm = NULL;
            }
            else
            {
                /* Get the overscan text size */
                QueryOverscan (modeid, &rect, OSCAN_TEXT);

                /* calculate the size of the screen */
                width  = rect.MaxX - rect.MinX + 1;
                height = rect.MaxY - rect.MinY + 1;

                /* No custom bitmap */
                bm = NULL;
            }
d794 2
a795 2
            /* Open the new screen */
            if (gd->gd_Screen = openscreentags (gd,
d797 40
a836 40
                                                SA_Width, (ULONG) width,
                                                SA_Height, (ULONG) height,
                                                SA_Depth, (ULONG) fri->fri_Dimensions.Depth,
                                                SA_DClip, &rect,
                                                SA_AutoScroll, TRUE,
                                                SA_DisplayID, modeid,
                                                SA_Interleaved, TRUE,
                                                SA_SharePens, TRUE,
                                                SA_SysFont, 1,
                                                SA_ShowTitle, !(backdrop),
                                                SA_Quiet, backdrop,
                                                SA_Behind, TRUE,
                                                SA_Pens, pens,
                                                SA_BackFill, backfill,
                                                SA_DetailPen, detail,
                                                SA_BlockPen, block,
                                                ((bm) ? SA_BitMap : TAG_IGNORE), bm,
                                                TAG_DONE))
            {
                /* Show that we opened the screen */
                gd->gd_Flags |= GDF_OPENSCREEN;

                /* Load the color map */
                if (cregs && !remap)
                {
                    DD (kprintf ("set %ld colors. depth=%ld, %ld\n", numcolors, (ULONG) gd->gd_Screen->RastPort.BitMap->Depth, (ULONG) (2 << (gd->gd_Screen->BitMap.Depth - 1))));
                    numcolors = 2 << (gd->gd_Screen->RastPort.BitMap->Depth - 1);
                    for (i = 0; i < numcolors; i++)
                    {
                        r = cregs[i * 3 + 0];
                        g = cregs[i * 3 + 1];
                        b = cregs[i * 3 + 2];
                        SetRGB32 (&gd->gd_Screen->ViewPort, i, r, g, b);
                    }
                }
                else
                {
                    DD (kprintf ("don't set colors. cregs=0x%lx, remap=%ld\n", cregs, (ULONG) remap));
                }
            }
d863 2
a864 2
				DTA_NominalHoriz,	&gd->gd_TotHoriz,
				DTA_NominalVert,	&gd->gd_TotVert,
d878 1
a878 1
		    gd->gd_VisVert  = gd->gd_TotVert;
d890 1
d908 1
d913 1
d916 1
d919 1
d922 1
d926 1
a964 1
		gd->gd_Window = NULL;
@


39.12
log
@snapshot name is now public screen name.
@
text
@a34 1
    BPTR oldLock;
a94 1
			    struct DiskObject *dob;
a95 2
			    STRPTR tmp;
			    ULONG hold;
d98 3
a100 3
			    oldLock = CurrentDir (wa->wa_Lock);
			    dob = GetDiskObject (wa->wa_Name);
			    CurrentDir (oldLock);
d102 1
d106 4
a113 62

			    if (dob)
			    {
				if (tmp = FindToolType (dob->do_ToolTypes, "CLIPUNIT"))
				    if (StrToLong (tmp, &hold) > 0L)
					gd->gd_Unit = hold;

				/* Must be initialized after CLIPUNIT */
				if (FindToolType (dob->do_ToolTypes, "CLIPBOARD"))
				{
				    gd->gd_SourceType = DTST_CLIPBOARD;
				    gd->gd_SourceName = (APTR) gd->gd_Unit;
				    gd->gd_NameBuffer[0] = 0;
				}

				if (FindToolType (dob->do_ToolTypes, "SCREEN"))
				{
				    strcpy (gd->gd_ScreenNameBuffer, "MultiView");
				    gd->gd_Options[OPT_SCREEN] = TRUE;
				    gd->gd_Flags |= GDF_SCREEN;
				}
				else if (tmp = FindToolType (dob->do_ToolTypes, "PUBSCREEN"))
				{
				    strcpy (gd->gd_ScreenNameBuffer, tmp);
				    gd->gd_ScreenName = gd->gd_ScreenNameBuffer;
				}
				else
				{
				    GetDefaultPubScreen (gd->gd_ScreenNameBuffer);
				    gd->gd_ScreenName = gd->gd_ScreenNameBuffer;
				}

				if (tmp = FindToolType (dob->do_ToolTypes, "FONTSIZE"))
				    if (StrToLong (tmp, &hold) > 0L)
					gd->gd_TextAttr.ta_YSize = hold;

				if (tmp = FindToolType (dob->do_ToolTypes, "FONTNAME"))
				{
				    struct Library *DiskfontBase;

				    sprintf (gd->gd_FontName, "%s.font", tmp);
				    if (DiskfontBase = OpenLibrary ("diskfont.library", 0))
				    {
					if (gd->gd_TextFont = OpenDiskFont (&gd->gd_TextAttr))
					{
					    gd->gd_Flags |= GDF_OPENFONT;
					}
					CloseLibrary (DiskfontBase);
				    }
				}

				if (FindToolType (dob->do_ToolTypes, "BOOKMARK"))
				    gd->gd_Options[OPT_BOOKMARK] = TRUE;

				if (FindToolType (dob->do_ToolTypes, "BACKDROP"))
				    gd->gd_Options[OPT_BACKDROP] = TRUE;

				if (FindToolType (dob->do_ToolTypes, "WINDOW"))
				    gd->gd_Options[OPT_WINDOW] = TRUE;

				FreeDiskObject (dob);
			    }
d127 2
a128 1
				    strcpy (gd->gd_NameBuffer, (STRPTR) gd->gd_SourceName);
d197 2
a198 4

				/*
				 * Real simple for right now.  Just the name.  I'm going to change this to topv, toph, name, node
				 */
d216 26
a241 12
			/* No arguments were provided, so let's pop up the file requester */
			if ((failureCode == 0) &&
			    (gd->gd_SourceName == NULL) &&
			    (gd->gd_SourceType == DTST_FILE) &&
			    (gd->gd_Options[OPT_WINDOW] == 0))
			{
			    /* Get a pointer to the destination screen */
			    if (!(gd->gd_Screen = LockPubScreen (gd->gd_ScreenName)))
				gd->gd_Screen = LockPubScreen (NULL);

			    /* Load the file requester snapshot */
			    LoadSnapShot (gd);
d243 5
a247 6
			    /* Pop up the file requester */
			    ScreenToFront (gd->gd_Screen);
			    if (FileRequest (gd, 0, GetString (gd, MV_TITLE_SELECT_FILE_TO_OPEN), GetString (gd, MV_LABEL_OPEN), gd->gd_NameBuffer))
			    {
				gd->gd_SourceName = (APTR) gd->gd_NameBuffer;
				strcpy (gd->gd_NameBuffer, (STRPTR) gd->gd_SourceName);
d250 3
d254 23
a276 2
				failureLevel = RETURN_OK;
				failureCode = 0;
a277 4

			    /* Unlock the temporary screen */
			    UnlockPubScreen (NULL, gd->gd_Screen);
			    gd->gd_Screen = NULL;
d348 1
a348 1
	    if (failureCode)
d401 81
d799 2
a800 2
				DTA_NominalHoriz, &gd->gd_TotHoriz,
				DTA_NominalVert, &gd->gd_TotVert,
d813 3
@


39.11
log
@now correctly gets the display clip and pens
@
text
@d130 1
d134 1
a134 2

				if (tmp = FindToolType (dob->do_ToolTypes, "PUBSCREEN"))
d139 5
d203 2
d206 2
a207 2

				if (gd->gd_Options[OPT_PUBSCREEN])
d212 5
d285 2
a286 1
			    gd->gd_Screen = LockPubScreen (NULL);
d292 1
@


39.10
log
@was passing DT error number after DT was closed.
@
text
@d418 1
a422 1
    ULONG back, shine, shadow, fill;
d436 1
a436 1
    ULONG table[4][3];
a441 1
    DD (kprintf ("\nOpenEnvironment\n"));
d493 1
d496 1
d499 4
a502 2
	    /* Default */
	    pens[0] = ~0;
d504 203
a706 5
	    getdtattrs (gd, gd->gd_DataObject,
			PDTA_CRegs, &cregs,
			PDTA_NumColors, &numcolors,
			PDTA_BitMapHeader, &bmhd,
			TAG_DONE);
a707 155
	    DB (kprintf ("cregs=0x%lx, numcolors=%ld\n", cregs, numcolors));

	    if (modeid == INVALID_ID)
	    {
		modeid = GetVPModeID (&scr->ViewPort);
		fri->fri_Dimensions.Depth  = MIN (2, scr->RastPort.BitMap->Depth);
	    }
	    DB (kprintf ("ModeID        : 0x%lx (0x%lx)\n", modeid, INVALID_ID));

	    if (bmhd)
		remap = (bmhd->bmh_Depth == fri->fri_Dimensions.Depth) ? FALSE : TRUE;
	    setdtattrs (gd, gd->gd_DataObject, NULL, PDTA_Remap, remap, TAG_DONE);
	    DR (kprintf ("remap=%ld\n", (LONG)remap));

	    /* Get a lock on the default public screen */
	    if (cregs)
	    {
		/* Get a temporary color map */
		if (cm = GetColorMap (numcolors))
		{
		    /* Set the colors */
		    DB (kprintf ("picture\n"));
		    for (i = 0; i < numcolors; i++)
		    {
			r = cregs[i * 3 + 0];
			g = cregs[i * 3 + 1];
			b = cregs[i * 3 + 2];
			SetRGB32CM (cm, i, r, g, b);
			DX (kprintf (" %3ld) %08lx x%08lx %08lx\n", i, r, g, b));
		    }

		    /* Get the first four colors (the GUI colors) from the default public screen */
		    GetRGB32 (scr->ViewPort.ColorMap, 0, 4, (ULONG *) table);

		    maxnum = numcolors;
		    if (modeid & 0x800)
			maxnum = (1 << (fri->fri_Dimensions.Depth - 2)) - 1;

		    if (remap)
		    {
			/* Get the closest colors in the picture's color map */
			back   = FindColor (scr->ViewPort.ColorMap, table[0][0], table[0][1], table[0][2], 4);
			shadow = FindColor (scr->ViewPort.ColorMap, table[1][0], table[1][1], table[1][2], 4);
			shine  = FindColor (scr->ViewPort.ColorMap, table[2][0], table[2][1], table[2][2], 4);
			fill   = FindColor (scr->ViewPort.ColorMap, table[3][0], table[3][1], table[3][2], 4);
		    }
		    else
		    {
			/* Get the closest colors in the picture's color map */
			back   = FindColor (cm, table[0][0], table[0][1], table[0][2], maxnum);
			shadow = FindColor (cm, table[1][0], table[1][1], table[1][2], maxnum);
			shine  = FindColor (cm, table[2][0], table[2][1], table[2][2], maxnum);
			fill   = FindColor (cm, table[3][0], table[3][1], table[3][2], maxnum);
		    }

		    pens[DETAILPEN]        = back;
		    pens[BLOCKPEN]         = shadow;
		    pens[TEXTPEN]          = shadow;
		    pens[SHINEPEN]         = shine;
		    pens[SHADOWPEN]        = shadow;
		    pens[FILLPEN]          = fill;
		    pens[FILLTEXTPEN]      = shadow;
		    pens[HIGHLIGHTTEXTPEN] = shine;
		    pens[BACKGROUNDPEN]    = back;
		    pens[BARDETAILPEN]     = shadow;
		    pens[BARBLOCKPEN]      = shine;
		    pens[BARTRIMPEN]       = shadow;
		    pens[NUMDRIPENS]       = ~0;

		    /* Free the temporary color map */
		    FreeColorMap (cm);
		}
		backfill = (ULONG) LAYERS_NOBACKFILL;
		backdrop = TRUE;
	    }

	    /* Close the existing environment */
	    CloseEnvironment (gd, 0);

	    GetDisplayInfoData (NULL, (APTR) & dim, sizeof (struct DimensionInfo), DTAG_DIMS, modeid);
	    rect = *(&dim.Nominal);

	    DD (kprintf ("fri=(%ld,%ld) dim=(%ld,%ld) bmhd=(%ld,%ld)\n",
		(ULONG) fri->fri_Dimensions.Width,   (ULONG) fri->fri_Dimensions.Height,
		(ULONG) (rect.MaxX - rect.MinX + 1), (ULONG) (rect.MaxY - rect.MinX + 1),
		(ULONG) bmhd->bmh_Width, (ULONG) bmhd->bmh_Height));

	    /* calculate the size of the screen */
	    width  = MAX (bmhd->bmh_Width,  rect.MaxX - rect.MinX + 1);
	    height = MAX (bmhd->bmh_Height, rect.MaxY - rect.MinX + 1);

	    /* The picture isn't going to be remapped, so come up with the custom bitmap */
	    if (!remap && (bmhd->bmh_Width >= width) && (bmhd->bmh_Height >= height))
	    {
		/* Tell the object to generate the bitmap pointer */
		gpl.MethodID    = DTM_PROCLAYOUT;
		gpl.gpl_GInfo   = NULL;
		gpl.gpl_Initial = 1;
		if (DoMethodA (gd->gd_DataObject, &gpl))
		{
		    /* Get a pointer to the bitmap */
		    getdtattrs (gd, gd->gd_DataObject, PDTA_BitMap, &bm, TAG_DONE);

		    woaf = WOAF_BITMAP;
		    gd->gd_Flags |= GDF_BITMAP;
		}
		else
		    bm = NULL;
	    }
	    else
		bm = NULL;

	    /* Open the new screen */
	    if (gd->gd_Screen = openscreentags (gd,
						SA_Width,	(ULONG) width,
						SA_Height,	(ULONG) height,
						SA_Depth,	(ULONG) fri->fri_Dimensions.Depth,
						SA_DClip,	&rect,
						SA_AutoScroll,	TRUE,
						SA_DisplayID,	modeid,
						SA_Interleaved,	TRUE,
						SA_SharePens,	TRUE,
						SA_SysFont,	1,
						SA_ShowTitle,	!(backdrop),
						SA_Quiet,	backdrop,
						SA_Behind,	TRUE,
						SA_Pens,	pens,
						SA_BackFill,	backfill,
						SA_DetailPen,	pens[DETAILPEN],
						SA_BlockPen,	pens[BLOCKPEN],
						((bm) ? SA_BitMap : TAG_IGNORE), bm,
						TAG_DONE))
	    {
		/* Show that we opened the screen */
		gd->gd_Flags |= GDF_OPENSCREEN;

		/* Load the color map */
		if (cregs && !remap)
		{
		    DD (kprintf ("set %ld colors. depth=%ld, %ld\n", numcolors, (ULONG)gd->gd_Screen->RastPort.BitMap->Depth, (ULONG)(2 << (gd->gd_Screen->BitMap.Depth-1))));
		    numcolors = 2 << (gd->gd_Screen->RastPort.BitMap->Depth - 1);
		    for (i = 0; i < numcolors; i++)
		    {
			r = cregs[i * 3 + 0];
			g = cregs[i * 3 + 1];
			b = cregs[i * 3 + 2];
			SetRGB32 (&gd->gd_Screen->ViewPort, i, r, g, b);
		    }
		}
		else
		{
		    DD (kprintf ("don't set colors. cregs=0x%lx, remap=%ld\n", cregs, (ULONG)remap));
		}
	    }

d748 4
a751 4
		    top    = gd->gd_Prefs.p_Window.Top,
		    left   = gd->gd_Prefs.p_Window.Left,
		    width  = gd->gd_TotHoriz + 4,
		    height = gd->gd_TotVert + 2,
d754 1
a754 1
		    woaf |= ((useScreen) ? NULL : WOAF_BACKDROP);
d758 15
a772 15
						  ((backdrop) ? TAG_IGNORE : WA_Left),		left,
						  ((backdrop) ? TAG_IGNORE : WA_Top),		top,
						  ((backdrop) ? TAG_IGNORE : WA_InnerWidth),	width,
						  ((backdrop) ? TAG_IGNORE : WA_InnerHeight),	height,
						  WA_Zoom,		&gd->gd_Prefs.p_Zoom,
						  WA_PubScreen,		gd->gd_Screen,
						  DTA_Title,		title,
						  DTA_TopVert,		gd->gd_TotVert,
						  DTA_TopHoriz,		gd->gd_TotHoriz,
						  WOA_DrawInfo,		gd->gd_DrawInfo,
						  WOA_IDCMPPort,	gd->gd_IDCMPPort,
						  WOA_AWPort,		gd->gd_AWPort,
						  WOA_Backdrop,		backdrop,
						  WOA_Flags,		woaf,
						  ICA_TARGET,		ICTARGET_IDCMP,
d801 1
@


39.9
log
@handles SA_BitMap
@
text
@d363 5
d375 1
a375 5
	}

	if (failureLevel)
	{
	    PrintF (gd, gd->gd_Options[OPT_REQUESTER], gd->gd_SecondaryResult, gd->gd_NameBuffer);
@


39.8
log
@minimum text oscan or picture width.
@
text
@d426 2
d433 1
d437 1
d441 1
d511 1
a511 3
		fri->fri_Dimensions.Width = scr->Width;
		fri->fri_Dimensions.Height = scr->Height;
		fri->fri_Dimensions.Depth = MIN (2, scr->BitMap.Depth);
d585 2
a586 9
	    /* Use the text size */
	    QueryOverscan (modeid, &rect, OSCAN_TEXT);
#if 1
	    width  = MAX (fri->fri_Dimensions.Width,  rect.MaxX - rect.MinX + 1);
	    height = MAX (fri->fri_Dimensions.Height, rect.MaxY - rect.MinX + 1);
#else
	    DB (kprintf ("%ld,%ld,%ld,%ld\n", (LONG)rect.MinX, (LONG)rect.MinY, (LONG)rect.MaxX, (LONG)rect.MaxY));
	    rect.MaxX = MIN (fri->fri_Dimensions.Width - 1,  rect.MaxX);
	    rect.MaxY = MIN (fri->fri_Dimensions.Height - 1, rect.MaxY);
d588 29
a616 3
	    width  = fri->fri_Dimensions.Width;
	    height = fri->fri_Dimensions.Height;
#endif
d631 1
d636 1
d645 2
a646 2
		    DD (kprintf ("set %ld colors. depth=%ld, %ld\n", numcolors, (ULONG)gd->gd_Screen->BitMap.Depth, (ULONG)(2 << (gd->gd_Screen->BitMap.Depth-1))));
		    numcolors = 2 << (gd->gd_Screen->BitMap.Depth - 1);
d706 3
d724 1
a724 1
						  WOA_Flags,		((useScreen) ? NULL : WOAF_BACKDROP),
d759 7
a765 3
	/* Get rid of the data object */
	DisposeDTObject (gd->gd_DataObject);
	gd->gd_DataObject = NULL;
d774 1
d786 1
d789 3
a791 1
	    CloseScreen (gd->gd_Screen);
a793 1
	{
a794 1
	}
d798 10
@


39.7
log
@wasn't get correct numcolors
@
text
@d584 1
a584 1
#if 0
d591 1
@


39.6
log
@*** empty log message ***
@
text
@d15 1
d453 9
a461 9
	    DB (kprintf ("PropertyFlags : 0x%lx\n", fri->fri_PropertyFlags));
	    DB (kprintf ("RedBits       : 0x%lx\n", fri->fri_RedBits));
	    DB (kprintf ("GreenBits     : 0x%lx\n", fri->fri_GreenBits));
	    DB (kprintf ("BlueBits      : 0x%lx\n", fri->fri_BlueBits));
	    DB (kprintf ("Width         : %ld\n", (ULONG) fri->fri_Dimensions.Width));
	    DB (kprintf ("Height        : %ld\n", (ULONG) fri->fri_Dimensions.Height));
	    DB (kprintf ("Depth         : %ld\n", (ULONG) fri->fri_Dimensions.Depth));
	    DB (kprintf ("Screen        : 0x%lx\n", fri->fri_Screen));
	    DB (kprintf ("ColorMap      : 0x%lx\n", fri->fri_ColorMap));
d466 1
a466 1
		DB (kprintf ("HAM or ExtraHalfBrite\n"));
d472 1
a472 1
		DB (kprintf ("ModeID=0x%08lx\n", modeid));
d620 2
a621 1
		    numcolors = gd->gd_Screen->BitMap.Depth << 2;
d629 4
@


39.5
log
@*** empty log message ***
@
text
@d13 2
a329 3
				    /* Remove the object from the window */
				    DoMethod ((Object *) gd->gd_WindowObj, WOM_REMVIEW, (ULONG) gd->gd_DataObject);

d331 1
a331 1
				    CloseEnvironment (gd, 0);
a336 3

				/* Get rid of the data object */
				DisposeDTObject (gd->gd_DataObject);
d382 3
d386 1
d424 1
d432 1
d442 1
a442 1
	DB (kprintf ("\nMode ID     : 0x%lx\n", modeid));
d469 1
a469 1
	    if ((fri->fri_PropertyFlags == 0) && (modeid & 0x800))
d497 1
d499 1
a500 1
	    setdtattrs (gd, gd->gd_DataObject, NULL, PDTA_Remap, FALSE, TAG_DONE);
d502 1
a502 1
	    if (fri->fri_Dimensions.Depth)
a503 3
	    }
	    else if (modeid == INVALID_ID)
	    {
d509 1
a509 1
	    DB (kprintf ("ModeID        : 0x%lx\n", modeid));
d511 5
d530 1
a530 1
			DB (kprintf (" %3ld) %08lx x%08lx %08lx\n", i, r, g, b));
d540 24
a563 13
		    /* Get the closest colors in the picture's color map */
		    back = FindColor (cm, table[0][0], table[0][1], table[0][2], maxnum);
		    shadow = FindColor (cm, table[1][0], table[1][1], table[1][2], maxnum);
		    shine = FindColor (cm, table[2][0], table[2][1], table[2][2], maxnum);
		    fill = FindColor (cm, table[3][0], table[3][1], table[3][2], maxnum);

		    pens[DETAILPEN] = back;
		    pens[BLOCKPEN] = shadow;
		    pens[TEXTPEN] = shadow;
		    pens[SHINEPEN] = shine;
		    pens[SHADOWPEN] = shadow;
		    pens[FILLPEN] = fill;
		    pens[FILLTEXTPEN] = shadow;
d565 5
a569 5
		    pens[BACKGROUNDPEN] = back;
		    pens[BARDETAILPEN] = shadow;
		    pens[BARBLOCKPEN] = shine;
		    pens[BARTRIMPEN] = shadow;
		    pens[NUMDRIPENS] = ~0;
d617 1
a617 1
		if (cregs)
d619 1
d712 1
a712 1
    CloseEnvironment (gd, 0);
d720 9
d732 1
a732 1
	if ((which == 0) || (gd->gd_Flags & GDF_OPENSCREEN))
d789 1
a789 1
    es.es_TextFormat = "MultiView %ld.%ld (%s)\n%s\nWritten by David N. Junod\n\nContents Type: %s %s";
@


39.4
log
@sets clipunit correctly now
@
text
@d11 1
a11 1
#define	DC(x)	x
d44 1
a44 1
	PrintF (NULL, 0, ERROR_REQUIRES_V39, NULL);
d255 1
a255 1
				gd->gd_SecondaryResult = ERROR_COULDNT_LOAD_BOOKMARK;
d276 1
a276 1
			    if (FileRequest (gd, 0, GetString (gd, TITLE_SELECT_FILE_TO_OPEN), GetString (gd, LABEL_OPEN), gd->gd_NameBuffer))
d371 1
a371 1
	    gd->gd_SecondaryResult = ERROR_COULDNT_OPEN_DATATYPES;
d421 1
a428 1
    UWORD width, height;
d434 1
a434 1
    title = GetString (gd, TITLE_LOADING);
d476 1
a476 1
	title = GetString (gd, TITLE_MULTIVIEW);
d565 12
a576 4
	    /* Use the video size */
	    QueryOverscan (modeid, &rect, OSCAN_VIDEO);
	    width  = MIN (fri->fri_Dimensions.Width,  rect.MaxX - rect.MinX + 1);
	    height = MIN (fri->fri_Dimensions.Height, rect.MaxY - rect.MinX + 1);
d583 1
d653 5
d660 4
a663 4
						  WA_Left,		gd->gd_Prefs.p_Window.Left,
						  WA_Top,		gd->gd_Prefs.p_Window.Top,
						  WA_InnerWidth,	gd->gd_TotHoriz + 4,
						  WA_InnerHeight,	gd->gd_TotVert + 2,
d673 1
d694 1
a694 1
    gd->gd_SecondaryResult = ERROR_COULDNT_OPEN_ENV;
d751 1
a751 1
	s1 = GetString (gd, TITLE_EMPTY);
d762 1
a762 1
    es.es_Title = GetString (gd, TITLE_MULTIVIEW);
d764 1
a764 1
    es.es_GadgetFormat = GetString (gd, LABEL_CONTINUE);
@


39.3
log
@open sys/utilities.catalog instead of multiview.catalog
@
text
@d11 2
d32 1
a32 1
    BPTR oldLock = NULL;
d113 5
a124 4
				if (tmp = FindToolType (dob->do_ToolTypes, "CLIPUNIT"))
				    if (StrToLong (tmp, &hold) > 0L)
					gd->gd_Unit = hold;

d183 4
a193 3
				if (gd->gd_Options[OPT_CLIPUNIT])
				    gd->gd_Unit = *((ULONG *) gd->gd_Options[OPT_CLIPUNIT]);

d423 1
d428 1
d462 2
d465 1
d468 2
d471 1
d558 1
a558 1
		backfill = LAYERS_NOBACKFILL;
d565 5
d572 14
a585 13
						SA_Width, (ULONG) fri->fri_Dimensions.Width,
						SA_Height, (ULONG) fri->fri_Dimensions.Height,
						SA_Depth, (ULONG) fri->fri_Dimensions.Depth,
						SA_DisplayID, modeid,
						SA_Interleaved, TRUE,
						SA_SharePens, TRUE,
						SA_SysFont, 1,
						SA_ShowTitle, !(backdrop),
						SA_Quiet, backdrop,
						SA_Pens, pens,
						SA_BackFill, backfill,
						SA_DetailPen, pens[DETAILPEN],
						SA_BlockPen, pens[BLOCKPEN],
@


39.2
log
@wasn't getting the path for Workbench arguments.
@
text
@d63 1
a63 1
	    gd->gd_Catalog = OpenCatalogA (NULL, "multiview.catalog", NULL);
@


39.1
log
@added WINDOW option.
@
text
@d92 1
a92 1
			    struct WBArg *wbArg;
d96 4
a99 4
			    wbArg = wbMsg->sm_ArgList;
			    oldLock = CurrentDir (wbArg->wa_Lock);

			    dob = GetDiskObject (wbArg->wa_Name);
d103 3
a105 2
				wbArg++;
				strcpy (gd->gd_NameBuffer, wbArg->wa_Name);
a346 3
			if (oldLock)
			    CurrentDir (oldLock);

a676 1
		SaveSnapShot (gd);
@


39.0
log
@initial rcs checkin
@
text
@a103 1
				gd->gd_SourceName = (APTR) wbArg->wa_Name;
d105 1
d141 1
a141 1
				    strcpy (gd->gd_FontName, tmp);
d158 2
a159 7
				if (tmp = FindToolType (dob->do_ToolTypes, "ROW"))
				    if (StrToLong (tmp, &hold) > 0L)
					gd->gd_TotVert = hold;

				if (tmp = FindToolType (dob->do_ToolTypes, "COLUMN"))
				    if (StrToLong (tmp, &hold) > 0L)
					gd->gd_TotHoriz = hold;
d169 1
a169 1
			if (gd->gd_RDArgs = ReadArgs (TEMPLATE, gd->gd_Options, NULL))
d205 1
a205 1
				    strcpy (gd->gd_FontName, (STRPTR) gd->gd_Options[OPT_FONTNAME]);
a214 7

				if (gd->gd_Options[OPT_ROW])
				    gd->gd_TotVert = *((ULONG *) gd->gd_Options[OPT_ROW]);

				if (gd->gd_Options[OPT_COLUMN])
				    gd->gd_TotHoriz = *((ULONG *) gd->gd_Options[OPT_COLUMN]);

d259 4
a262 1
			if ((failureCode == 0) && (gd->gd_SourceName == NULL) && (gd->gd_SourceType == DTST_FILE))
d268 1
a268 1
			    LoadSnapShot (gd, &gd->gd_Snapshot);
d297 6
a302 9
				if (gd->gd_DataObject = newdtobject (gd, gd->gd_SourceName,
								     DTA_SourceType,	gd->gd_SourceType,
								     DTA_Title,		GetString (gd, TITLE_LOADING),
								     DTA_TopVert,	gd->gd_TotVert,
								     DTA_TopHoriz,	gd->gd_TotHoriz,
								     DTA_TextAttr,	(ULONG) & gd->gd_TextAttr,
								     GA_Immediate,	TRUE,
								     GA_RelVerify,	TRUE,
								     TAG_DONE))
d304 7
a310 5
				    /* Open the required display environment */
				    if (OpenEnvironment (gd))
				    {
					/* Indicate success */
					failureLevel = RETURN_OK;
d312 13
a324 13
					/* Handle input */
					HandleEvents (gd);

					/* Remove the object from the window */
					DoMethod ((Object *) gd->gd_WindowObj, WOM_REMVIEW, (ULONG) gd->gd_DataObject);

					/* Close the display environment */
					CloseEnvironment (gd, 0);
				    }
				    else
				    {
					failureCode = gd->gd_SecondaryResult;
				    }
d326 2
a327 2
				    /* Get rid of the data object */
				    DisposeDTObject (gd->gd_DataObject);
d331 1
a331 1
				    failureCode = gd->gd_SecondaryResult = IoErr ();
d333 3
a335 4
			    }
			    else
			    {
				failureCode = gd->gd_SecondaryResult = ERROR_REQUIRED_ARG_MISSING;
d423 1
d428 3
d432 39
a470 1
    if (!gd->gd_DataObject)
a474 30
    /* Get the mode ID */
    GetAttr (PDTA_ModeID, gd->gd_DataObject, (ULONG *) & modeid);
    DB (kprintf ("\nMode ID     : 0x%lx\n", modeid));

    /* Ask the object what kind of environment it needs */
    dtf.MethodID          = DTM_FRAMEBOX;
    dtf.dtf_FrameInfo     = fri = &gd->gd_FrameInfo;
    dtf.dtf_ContentsInfo  = &gd->gd_FrameInfo;
    dtf.dtf_SizeFrameInfo = sizeof (struct FrameInfo);
    dtf.dtf_FrameFlags    = NULL;
    if (DoMethodA (gd->gd_DataObject, &dtf) && fri->fri_Dimensions.Depth)
    {
	DB (kprintf ("PropertyFlags : 0x%lx\n", fri->fri_PropertyFlags));
	DB (kprintf ("RedBits       : 0x%lx\n", fri->fri_RedBits));
	DB (kprintf ("GreenBits     : 0x%lx\n", fri->fri_GreenBits));
	DB (kprintf ("BlueBits      : 0x%lx\n", fri->fri_BlueBits));
	DB (kprintf ("Width         : %ld\n", (ULONG) fri->fri_Dimensions.Width));
	DB (kprintf ("Height        : %ld\n", (ULONG) fri->fri_Dimensions.Height));
	DB (kprintf ("Depth         : %ld\n", (ULONG) fri->fri_Dimensions.Depth));
	DB (kprintf ("Screen        : 0x%lx\n", fri->fri_Screen));
	DB (kprintf ("ColorMap      : 0x%lx\n", fri->fri_ColorMap));

	if ((fri->fri_PropertyFlags & DIPF_IS_HAM) ||
	    (fri->fri_PropertyFlags & DIPF_IS_EXTRAHALFBRITE))
	    useScreen = TRUE;

	if ((fri->fri_PropertyFlags == 0) && (modeid & 0x800))
	    useScreen = TRUE;
    }

d497 1
a497 1
		fri->fri_Dimensions.Depth = scr->BitMap.Depth;
d523 1
a523 1
			maxnum = 1 << (fri->fri_Dimensions.Depth - 2);
d610 1
a610 1
		    LoadSnapShot (gd, &gd->gd_Snapshot);
d619 1
a619 1
			gd->gd_TotHoriz = gd->gd_Snapshot.Width;
d625 1
a625 1
			gd->gd_TotVert = gd->gd_Snapshot.Height;
d630 2
a631 2
						  WA_Left,		gd->gd_Snapshot.Left,
						  WA_Top,		gd->gd_Snapshot.Top,
d634 1
d636 1
a636 1
						  DTA_Title,		GetString (gd, TITLE_LOADING),
d655 3
d672 1
d677 7
a683 7
            if (gd->gd_WindowObj)
            {
                SaveSnapShot (gd, window, (gd->gd_Flags & GDF_SNAPSHOT));
                DisposeObject (gd->gd_WindowObj);
                gd->gd_WindowObj = NULL;
                gd->gd_Window = NULL;
            }
@
