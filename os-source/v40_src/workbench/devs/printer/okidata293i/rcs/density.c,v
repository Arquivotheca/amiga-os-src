head     1.6;
branch   ;
access   ;
symbols  V36_22:1.4 L35_20:1.4 L35_19:1.4 L35_17:1.4 L35_16:1.4 L35_15:1.4 L35_11:1.3;
locks    ; strict;
comment  @*   @;


1.6
date     92.01.16.11.02.33;  author davidj;  state Exp;
branches ;
next     1.5;

1.5
date     90.04.06.20.13.10;  author daveb;  state Exp;
branches ;
next     1.4;

1.4
date     88.04.04.21.20.15;  author daveb;  state Exp;
branches ;
next     1.3;

1.3
date     87.10.28.13.15.23;  author daveb;  state Exp;
branches ;
next     1.2;

1.2
date     87.10.27.15.41.37;  author daveb;  state Exp;
branches ;
next     1.1;

1.1
date     87.10.01.09.25.05;  author daveb;  state Exp;
branches ;
next     1.0;

1.0
date     87.09.21.11.50.15;  author daveb;  state Exp;
branches ;
next     ;


desc
@added to rcs
@


1.6
log
@added European paper support
@
text
@/*
	Density module for Okidata293I driver.
	David Berezowski - October/87
*/

#include <exec/types.h>
#include "../printer/printer.h"
#include "../printer/prtbase.h"

/* (30.5cm/ft) * (10mm/cm)					*/
#define MMPERFT		305

/* Margins: minus 1/2" width, minus 1" height (== US diffs)	*/
/*								*/
/* Left            Right           Top           Bottom		*/
/* 50/300 = 1/6    100/300 = 1/3   60/300 = 1/5  60/300 = 1/5	*/
/* 								*/

/* Half inches per ft */
#define HALFINCHPERFT 24

/* Inches per ft */
#define INCHPERFT 12

/* MM per 1/2 inch (round up [12.7->13]) */
#define HALFINCH ((MMPERFT + INCHPERFT)/HALFINCHPERFT)

/* MM per inch (round up) 25.4 */
#define INCH ((MMPERFT + INCHPERFT)/INCHPERFT)

/* Sparse table for paper sizes - offset constant */
#define PSIZE_OFFSET 16

SetDensity(density_code)
ULONG density_code;
{
	extern struct PrinterData *PD;
	extern struct PrinterExtendedData *PED;

	/* SPECIAL_DENSITY     0    1    2    3    4    5    6    7 */
	static int XDPI[8] = {120, 120, 240, 120, 240, 240, 240, 240};
	static int YDPI[8] = {144, 144, 144, 288, 288, 288, 288, 288};
	static char codes[8] = {'L', 'L', 'Z', 'L', 'Z', 'Z', 'Z', 'Z'};

#if 1
	/* Paper sizes in inches */
	static int PaperXSizes[] = {
		80,			/* US_LETTER 8.0 x 10.0*/
		80,			/* US_LEGAL  8.0 x 13.0*/
		80,			/* N_TRACTOR == LETTER */
		136,			/* W_TRACTOR == 13.6 x 10.0 */
		80,			/* CUSTOM    == LETTER */
	/* Euro Ax sizes follow		*/
	/* Paper size in millimeters - 1/2 inch */
		841 - HALFINCH,		/* A0	*/
		594 - HALFINCH,		/* A1	*/
		420 - HALFINCH,		/* A2	*/
		297 - HALFINCH,		/* A3	*/
		210 - HALFINCH,		/* A4	*/
		148 - HALFINCH,		/* A5	*/
		105 - HALFINCH,		/* A6	*/
		74  - HALFINCH,		/* A7	*/
		52  - HALFINCH,		/* A8	*/
		};

	/* Paper sizes in inches */
	static int PaperYSizes[] = {
		10,			/* US_LETTER 8.0 x 10.0*/
		13,			/* US_LEGAL  8.0 x 13.0*/
		10,			/* N_TRACTOR == LETTER */
		10,			/* W_TRACTOR == 13.6 x 10.0 */
		10,			/* CUSTOM    == LETTER */
	/* Euro Ax sizes follow		*/
	/* Paper size in millimeters - 1 inch */
		1189 - INCH,		/* A0	*/
		841  - INCH,	 	/* A1	*/
		594  - INCH, 		/* A2	*/
		420  - INCH, 		/* A3	*/
		297  - INCH, 		/* A4	*/
		210  - INCH, 		/* A5	*/
		148  - INCH, 		/* A6	*/
		105  - INCH, 		/* A7	*/
		74   - INCH,		/* A8	*/
		};

	/* Calculate max dots based on paper size selection */
	UWORD psize;
        ULONG maxwidth,maxheight;

	/* reference array (constant steps of 16) */
	/* Any new in-between sizes will be rounded down */
	psize = PD->pd_Preferences.PaperSize;

	maxwidth =  (ULONG)PaperXSizes[psize/PSIZE_OFFSET];
	maxheight = (ULONG)PaperYSizes[psize/PSIZE_OFFSET];

	/* Math - be precise as possible!  No change in precision for	*/
	/* existing INCH specified paper sizes				*/
	density_code /= SPECIAL_DENSITY1;

	/* Inches:  Inches * DPI */
	if(psize <= CUSTOM)
	{
		PED->ped_MaxColumns = maxwidth;
		PED->ped_MaxXDots = maxwidth * XDPI[density_code] / 10;
		PED->ped_MaxYDots = maxheight * XDPI[density_code];
	}
	/* Millimeters: */
	/*					 */
	/* (X mm) * 12 inches/ft * dots/inch	 */
	/* ------------------------------ = Dots */
	/* 305 mm/ft				 */
	else
	{
		PED->ped_MaxColumns = (maxwidth * 100 / 254);
		PED->ped_MaxXDots = (maxwidth * INCHPERFT * XDPI[density_code])/MMPERFT;
		PED->ped_MaxYDots = (maxheight * INCHPERFT * XDPI[density_code])/MMPERFT;
	}

#else
	density_code /= SPECIAL_DENSITY1;

	/* default is 80 chars (8.0 in.), W_TRACTOR is 136 chars (13.6 in.) */
	PED->ped_MaxColumns = PD->pd_Preferences.PaperSize == W_TRACTOR ? 136 : 80;
	PED->ped_MaxXDots  = (XDPI[density_code] * PED->ped_MaxColumns) / 10;
#endif
	PED->ped_XDotsInch = XDPI[density_code];
	if ((PED->ped_YDotsInch = YDPI[density_code]) == 288) {
		PED->ped_NumRows = 32;
	}
	else {
		PED->ped_NumRows = 16;
	}
	return(codes[density_code]);
}
@


1.5
log
@for rcs 4.x header change
@
text
@d10 24
d45 54
a98 2
	PED->ped_MaxColumns = 
		PD->pd_Preferences.PaperSize == W_TRACTOR ? 136 : 80;
d100 23
d124 3
a126 2
	PED->ped_MaxXDots =
		(XDPI[density_code] * PED->ped_MaxColumns) / 10;
@


1.4
log
@added 288 ydpi support
V1.3 Gamma 10 release
@
text
@@


1.3
log
@added support for narrow and wide tractor paper
V1.3 Gamma 1 check-in
@
text
@d2 1
a2 1
	Density module for Okidata293I (copy of EpsonX) driver.
d17 3
a19 2
	static int XDPI[8] = {120, 120, 240, 240, 240, 240, 240, 240};
	static char codes[8] = {'L', 'L', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z'};
d28 6
@


1.2
log
@V1.3 gamma 1 check-in
@
text
@d2 1
a2 1
	Density module for Okidata_292I driver.
d13 1
d20 2
d23 3
a25 1
	PED->ped_MaxXDots = (XDPI[density_code] * 136) / 10; /* 13.6 inches */
@


1.1
log
@V1.3 beta 4 check-in
@
text
@d2 2
a3 2
	Density module for Epson
	David Berezowski - Sept/87
d20 1
a20 1
	PED->ped_MaxXDots = XDPI[density_code] * 8; /* 8 inches */
@


1.0
log
@added to rcs
@
text
@d7 1
a8 1
#include "../printer/printer.h"
@
