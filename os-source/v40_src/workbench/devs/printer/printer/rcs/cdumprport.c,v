head     1.45;
branch   ;
access   ;
symbols  V38_4:1.40 V37_603:1.39 V36_603:1.37 V36_599:1.36 V36_596:1.36 V36_587:1.32 V36_579:1.30 V36_575:1.30 V36_573:1.30 V36_572:1.30 V36_570:1.27 L34_564:1.27 L34_563:1.27 L34_562:1.25 L35_560:1.24 L35_559:1.23 L35_558:1.23 L35_556:1.22 L35_548:1.21 L35_547:1.20 L35_544:1.19 L35_543:1.18 L35_541:1.17 L35_539:1.16 L35_534:1.15 L35_528:1.14 L35_522:1.13 L35_517:1.12;
locks    ; strict;
comment  @*   @;


1.45
date     92.09.17.14.35.33;  author darren;  state Exp;
branches ;
next     1.44;

1.44
date     92.04.24.12.54.02;  author darren;  state Exp;
branches ;
next     1.43;

1.43
date     92.04.24.10.49.09;  author darren;  state Exp;
branches ;
next     1.42;

1.42
date     92.04.24.09.42.31;  author darren;  state Exp;
branches ;
next     1.41;

1.41
date     92.01.28.14.19.36;  author davidj;  state Exp;
branches ;
next     1.40;

1.40
date     91.07.10.16.16.53;  author darren;  state Exp;
branches ;
next     1.39;

1.39
date     91.02.14.15.25.06;  author darren;  state Exp;
branches ;
next     1.38;

1.38
date     91.02.12.11.47.18;  author darren;  state Exp;
branches ;
next     1.37;

1.37
date     90.10.12.16.33.04;  author darren;  state Exp;
branches ;
next     1.36;

1.36
date     90.09.12.13.15.43;  author darren;  state Exp;
branches ;
next     1.35;

1.35
date     90.09.10.16.34.50;  author darren;  state Exp;
branches ;
next     1.34;

1.34
date     90.09.10.16.08.48;  author darren;  state Exp;
branches ;
next     1.33;

1.33
date     90.09.07.18.10.48;  author darren;  state Exp;
branches ;
next     1.32;

1.32
date     90.08.30.17.23.24;  author darren;  state Exp;
branches ;
next     1.31;

1.31
date     90.08.30.16.19.18;  author darren;  state Exp;
branches ;
next     1.30;

1.30
date     90.04.30.12.48.47;  author daveb;  state Exp;
branches ;
next     1.29;

1.29
date     90.04.06.19.22.58;  author daveb;  state Exp;
branches ;
next     1.28;

1.28
date     90.03.12.14.41.54;  author daveb;  state Exp;
branches ;
next     1.27;

1.27
date     88.10.19.19.19.52;  author daveb;  state Exp;
branches ;
next     1.26;

1.26
date     88.08.25.14.22.17;  author daveb;  state Exp;
branches ;
next     1.25;

1.25
date     88.08.16.16.25.23;  author daveb;  state Exp;
branches ;
next     1.24;

1.24
date     88.07.01.12.56.17;  author daveb;  state Exp;
branches ;
next     1.23;

1.23
date     88.06.07.19.50.46;  author daveb;  state Exp;
branches ;
next     1.22;

1.22
date     88.06.06.01.19.30;  author daveb;  state Exp;
branches ;
next     1.21;

1.21
date     88.04.21.23.09.53;  author daveb;  state Exp;
branches ;
next     1.20;

1.20
date     88.04.19.15.34.37;  author daveb;  state Exp;
branches ;
next     1.19;

1.19
date     88.04.14.12.31.14;  author daveb;  state Exp;
branches ;
next     1.18;

1.18
date     88.04.13.12.26.37;  author daveb;  state Exp;
branches ;
next     1.17;

1.17
date     88.04.10.15.32.55;  author daveb;  state Exp;
branches ;
next     1.16;

1.16
date     88.03.22.18.18.33;  author daveb;  state Exp;
branches ;
next     1.15;

1.15
date     88.03.08.18.21.51;  author daveb;  state Exp;
branches ;
next     1.14;

1.14
date     88.03.07.14.51.01;  author daveb;  state Exp;
branches ;
next     1.13;

1.13
date     88.03.04.11.07.43;  author daveb;  state Exp;
branches ;
next     1.12;

1.12
date     88.02.16.16.10.34;  author daveb;  state Exp;
branches ;
next     1.11;

1.11
date     88.02.02.15.59.41;  author daveb;  state Exp;
branches ;
next     1.10;

1.10
date     88.01.30.12.34.35;  author daveb;  state Exp;
branches ;
next     1.9;

1.9
date     88.01.18.10.58.43;  author daveb;  state Exp;
branches ;
next     1.8;

1.8
date     87.12.21.16.39.31;  author daveb;  state Exp;
branches ;
next     1.7;

1.7
date     87.12.21.11.54.56;  author daveb;  state Exp;
branches ;
next     1.6;

1.6
date     87.11.25.15.19.51;  author daveb;  state Exp;
branches ;
next     1.5;

1.5
date     87.10.29.15.25.24;  author daveb;  state Exp;
branches ;
next     1.4;

1.4
date     87.10.28.13.19.15;  author daveb;  state Exp;
branches ;
next     1.3;

1.3
date     87.10.27.17.06.29;  author daveb;  state Exp;
branches ;
next     1.2;

1.2
date     87.10.01.09.31.39;  author daveb;  state Exp;
branches ;
next     1.1;

1.1
date     87.09.09.06.50.58;  author daveb;  state Exp;
branches ;
next     1.0;

1.0
date     87.08.21.17.20.58;  author daveb;  state Exp;
branches ;
next     ;


desc
@added to rcs / V1.3 beta 2 release
@


1.45
log
@Spelling change
@
text
@/****** printer.device/PRD_DUMPRPORT *************************************
*
*   NAME
*	PRD_DUMPRPORT -- dump the specified RastPort to a graphics printer
*
*   FUNCTION
*	Print a rendition of the supplied RastPort, using the supplied
*	ColorMap, position and scaling information, as specified in
*	the printer preferences.
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set if quick I/O is not possible.
*	io_Command	PRD_DUMPRPORT.
*	io_Flags	IOB_QUICK set if quick I/O is possible.
*	io_RastPort	ptr to a RastPort.
*	io_ColorMap	ptr to a ColorMap.
*	io_Modes	the 'modes' flag from a ViewPort structure,
*			(the upper word is reserved and should be zero).
*
*			If you are running under version 36, or greater
*			of graphics.library, it is recommended that
*			you fill in "io_Modes" with the ULONG (32-bit)
*			value returned from calling:
*
*			ULONG ModeID = GetVPModeID(struct ViewPort *);
*
*			Doing so provides for upwards compatability with
*			the new display modes available under V36
*			(example: aspect ratio calculations for new
*			display modes).
*
*	io_SrcX		x offset into the RastPort to start printing from.
*	io_SrcY		y offset into the RastPort to start printing from.
*	io_SrcWidth	width of the RastPort to print (from io_SrcX).
*	io_SrcHeight	height of the RastPort to print (from io_SrcY).
*	io_DestCols	width of the printout in printer pixels.
*	io_DestRows	height of the printout in printer pixels.
*	io_Special	flag bits
*			(some of which pertain to DestCols and DestRows).
*			-if SPECIAL_MIL is set, then the associated
*			 parameter is specified in thousandths of
*			 an inch on the printer.  ie. if DestCols = 8000,
*			 DestRows = 10500 and SPECIAL_MILROWS and
*			 SPECIAL_MILCOLS is set then the printout would be
*			 8.000 x 10.500 inches.
*			-if SPECIAL_FULL is set, then the specific dimension
*			 is set to the maximum possible as determined
*			 by the printer limits or the configuration
*			 limits; whichever is less.
*			-if SPECIAL_FRAC is set, the parameter is
*			 taken to be a longword binary fraction
*			 of the maximum for that dimension.
*			-if all bits for a dimension are clear,
*			 (ie. SPECIAL MIL/FULL/FRAC and ASPECT are NOT set)
*			 then the parameter is specified in printer pixels.
*			-if SPECIAL_CENTER is set then the image will be
*			 put between the left and right edge of the paper.
*			-if SPECIAL_ASPECT is set, one of the dimensions
*			 may be reduced/expanded to preserve the aspect
*			 ratio of the print.
*			-SPECIAL_DENSITY(1-7) this allows for a maximum of 7
*			 different print densities.  DENSITY1 is the lowest
*			 density and the default.
*			-SPECIAL_NOFORMFEED - this allows for the mixing of
*			 text and graphics or multiple graphic dumps on page
*			 oriented printers (usually laser jet printers).
*			 When this flag is set the page will not be ejected
*			 after a graphic dump.  If you perform another
*			 graphic dump without this flag set OR close the
*			 printer after printing text after a graphic dump,
*			 the page will be ejected.
*			-if SPECIAL_TRUSTME is set then the printer specific
*			 driver is instructed to not issue a reset command
*			 before and after the dump.  If this flag is NOT
*			 checked by the printer specific driver then setting
*			 this flag has no effect.  Since we now recommend
*			 that printer driver writers no longer issue a reset
*			 command it is probably a safe idea to always set
*			 this flag when calling for a dump.
*			-if SPECIAL_NOPRINT is set then the following is done:
*			 Compute print size, set 'io_DestCols' and
*			 'io_DestRows' in the calling program's 'IODRPReq'
*			 structure and exit, DON'T PRINT.  This allows the
*			 calling program to see what the final print size
*			 would be in printer pixels.  Note that it modifies
*			 the 'io_DestCols' and 'io_DestRows' fields of your
*			 'IODRPReq' structure.  It also sets the print
*			 density and updates the 'MaxXDots', 'MaxYDots',
*			 'XDotsInch', and 'YDotsInch' fields of the
*			 'PrinterExtendedData' structure.
*
*	There following rules for the interpretation of io_DestRows and
*	io_DestCols that may produce unexpected results when they are
*	not greater than zero and io_Special is zero.  They have been
*	retained for compatability.  The user will not trigger these
*	other rules with well formed usage of io_Special.
*
*	When io_Special is equal to 0, the following rules
*	(from the V1.1 printer.device, and retained for compatibility
*	reasons) take effect.  Remember, these special rules are
*	for io_DestRows and io_DestCols and only take effect
*	if io_Special is 0).
*
*	a) DestCols>0 & DestRows>0 - use as absolute values.
*	   ie. DestCols=320 & DestRows=200 means that the picture
*	   will appear on the printer as 320x200 dots.
*	b) DestCols=0 & DestRows>0 - use the printers maximum number
*	   of columns and print DestRows lines. ie. if DestCols=0
*	   and DestRows=200 than the picture will appear on the
*	   printer as wide as it can be and 200 dots high.
*	c) DestCols=0 & DestRows=0 - same as above except the driver
*	   determines the proper number of lines to print based on
*	   the aspect ratio of the printer. ie. This results in the
*	   largest picture possible that is not distorted or inverted.
*	   Note: As of this writing, this is the call made by such
*	   program as DeluxePaint, GraphicCraft, and AegisImages.
*	d) DestCols>0 &DestRows=0 - use the specified width and the
*	   driver determines the proper number of lines to print based
*	   on the aspect ratio of the printer. ie. if you desire a
*	   picture that is 500 pixels wide and aspect ratio correct,
*	   use DestCols=500 and DestRows=0.
*	e) DestCols<0 or DestRows>0 - the final picture is either a
*	   reduction or expansion based on the fraction
*	   |DestCols| / DestRows in the proper aspect ratio.
*	   Some examples:
*	   1) if DestCols=-2 & DestRows=1 then the printed picture will
*	      be 2x the AMIGA picture and in the proper aspect ratio.
*	      (2x is derived from |-2| / 1 which gives 2.0)
*	   2) if DestCols=-1 & DestRows=2 then the printed picture will
*	      will be 1/2x the AMIGA picture in the proper aspect ratio.
*	      (1/2x is derived from |-1| / 2 which gives 0.5)
*
*   NOTES
*	The printer selected in preferences must have graphics
*	capability to use this command.  The error 'PDERR_NOTGRAPHICS'
* 	is returned if the printer can not print graphics.
*
*	Color printers may not be able to print black and white or
*	greyscale pictures -- specifically, the Okimate 20 cannot print
*	these with a color ribbon: you must use a black ribbon instead.
*	If the printer has an input buffer option, use it.
*	If the printer can be uni or bi directional, select
*	uni-directional; this produces a much cleaner picture.
*	Most printer drivers will attempt to set unidirectional
*	printing if it is possible under software control.
*
*	Please note that the width and height of the printable area on
*	the printer is in terms of pixels and bounded by the following:
*	 a) WIDTH = (RIGHT_MARGIN - LEFT_MARGIN + 1) / CHARACTERS_PER_INCH
*	 b) HEIGHT = LENGTH / LINES_PER_INCH
*       Margins are set by preferences.
*
*	For BGR printer support, the YMC values in the printer
*	specific render.c functions equate to BGR respectively, ie.
*	yellow is blue, magenta is green, and cyan is red.
*
*	For version 2.1 of the Operating System (the Localization
*	release), some of the printer drivers have been modified to
*	support European A size paper (e.g., "A4").  See preferences.h
*	for a list of defined sizes.  For most printers, this means
*	the maximum X dots will be calculated based on millimeters
*	minus 1/2 inch (approx 13 mm) - this is consistent with existing
*	driver calculations (e.g., 8.0 inches wide for US_LETTER, and
*	US_LEGAL sizes).
*
*	Some printers, like the HP_LaserJet, and HP_DeskJet also
*	calculate maximum Y dots.
*
*	For all modified printer drivers, selecting paper sizes larger
*	than the printer can handle may result in unexpected, or
*	clipped results.  This allows for the possibility of using
*	these drivers with future printers which may physically
*	[and internally] support these larger sizes of paper.
*
*	It is assumed that the user will make reasonable choices when
*	selecting paper size (e.g., not select WIDE TRACTOR for a
*	NARROW TRACTOR printer).
*
* Data Structures
* ---------------
*
*	The printer specific and non-specific data structures can be read
*	ONCE you have opened the printer device.  Here is a code fragment
*	to illustrate how to do just that.
*
*	#include <exec/types.h>
*	#include <devices/printer.h>
*	#include <devices/prtbase.h>
*	#include <devices/prtgfx.h>
*
*	struct IODRPReq PReq;
*	struct PrinterData *PD;
*	struct PrinterExtendedData *PED;
*
*   open the printer device / if it opened...
*   if (OpenDevice("printer.device", 0, &PReq, 0) == NULL) {
*       get pointer to printer data
*       PD = (struct PrinterData *)PReq.io_Device;
*       get pointer to printer extended data
*       PED = &PD->pd_SegmentData->ps_PED;
*       let's see what's there
*       printf("PrinterName = '%s', Version=%u, Revision=%u\n",
*           PED->ped_PrinterName, PD->pd_SegmentData->ps_Version,
*           PD->pd_SegmentData->ps_Revision,);
*       printf("PrinterClass=%u, ColorClass=%u\n",
*           PED->ped_PrinterClass, PED->ped_ColorClass);
*       printf("MaxColumns=%u, NumCharSets=%u, NumRows=%u\n",
*           PED->ped_MaxColumns, PED->ped_NumCharSets, PED->ped_NumRows);
*       printf("MaxXDots=%lu, MaxYDots=%lu, XDotsInch=%u, YDotsInch=%u\n",
*           PED->ped_MaxXDots, PED->ped_MaxYDots,
*           PED->ped_XDotsInch, PED->ped_YDotsInch);
*       CloseDevice(&PReq);
*   }
*
* Preferences
* -----------
*
*    If you want the user to be able to access the printer preferences items
* without having to run preferences (like DPAINT II's printer requester),
* here is what you do.  You can look at the printer's copy of preferences
* by referring to 'PD->pd_Preferences' (the printer device MUST already be
* opened at this point).  After you have this you could put up a requester
* and allow the user to change whatever parameters they wanted.
* BEAR IN MIND THAT YOU ARE RESPONSIBLE FOR RANGE CHECKING THESE SELECTIONS!
* Listed below are the printer preferences items and their valid values.
*
* PrintPitch         - PICA, ELITE, FINE.
* PrintQuality       - DRAFT, LETTER.
* PrintSpacing       - SIX_LPI, EIGHT_LPI.
* PrintLeftMargin    - 1 to PrintRightMargin.
* PrintRightMargin   - PrintLeftMargin to 999.
* PaperLength        - 1 to 999.
* PrintImage         - IMAGE_POSITIVE, IMAGE_NEGATIVE.
* PrintAspect        - ASPECT_HORIZ, ASPECT_VERT.
* PrintShade         - SHADE_BW, SHADE_GREYSCALE, SHADE_COLOR.
* PrintThreshold     - 1 to 15.
* PrintFlags         - CORRECT_RED, CORRECT_GREEN, CORRECT_BLUE, CENTER_IMAGE,
*                      IGNORE_DIMENSIONS, BOUNDED_DIMENSIONS,
*                      ABSOLUTE_DIMENSIONS, PIXEL_DIMENSIONS,
*                      MULTIPLY_DIMENSIONS, INTEGER_SCALING,
*                      ORDERED_DITHERING, HALFTONE_DITHERING.
*                      FLOYD_DITHERING, ANTI_ALIAS, GREY_SCALE2
* PrintMaxWidth      - 0 to 65535.
* PrintMaxHeight     - 0 to 65535.
* PrintDensity       - 1 to 7.
* PrintXOffset       - 0 to 255.
*
* Asynchronous I/O
* ----------------
*
*     The recommended way to do asynchronous i/o is...
*
* a) To send requests for i/o.
*
*     struct IORequest *ioreq;
*     struct MsgPort *port;
*     UBYTE signal;
*
*     port = ioreq->io_Message.mn_ReplyPort;
*     signal = port->mp_SigBit;
*
*     SendIO(ioreq);  send request
*     Wait(signal);  wait for completion (go to sleep)
*     while ((Msg = GetMsg(port)) != NULL) {  get ALL messages
*     }
*
* b) To abort a previous request for i/o.
*
*     struct IORequest *ioreq;
*
*     AbortIO(ioreq);  abort request
*     WaitIO(ioreq);  wait for reply
*
*     at this point you can re-use 'ioreq'.
*
*     Note that in the above examples 'ioreq' could be any one of...
*     a) struct IOStdReq    a standard i/o request
*     b) struct IODRPReq    a dumprport i/o request
*     c) struct IOPrtCmdReq a printer command i/o request
*
*     It is recommend that you do asynchronous i/o in your programs
*     and give the user a way of aborting all requests.
*
*
* 		V1.3 Printer Driver Notes
* 		-------------------------
*
* 	In general densities which use more than one pass should only be
* used for B&W shade dumps.  They can be used for Grey-Scale or Color Shade
* dumps BUT the output may tend to look muddy or dark.  Also multiple pass
* Color dumps tend to dirty or smear the ribbon (ie. yellow will get
* contaminated with the other colors on the ribbon; you have been warned).
*
*
* Alphacom_AlphaPro_101
* ---------------------
* 1. Daisywheel printer (text only).
*
* Brother_HR-15XL
* ---------------
* 1. Daisywheel printer (text only).
*
* CalComp_ColorMaster
* -------------------
* 1. Thermal transfer b&w/color printer (text and graphics).
* 2. Use Black ribbon for non-color dumps; Color ribbon for color dumps.
* 3. Linefeeds # of vertical dots printed.
* 4. Densities supported are 203x200(1) dpi.
* 5. This is a dual printer driver.  Select a PaperSize of 'Narrow Tractor'
*    for use with the ColorMaster; 'Wide Tractor' for use with the
*    ColorView-5912 (which uses 11 x 17 inch paper).
*
* CalComp_ColorMaster2
* -------------------
* 1. Thermal transfer b&w/color printer (text and graphics).
* 2. Use Black ribbon for non-color dumps; Color ribbon for color dumps.
* 3. Linefeeds # of vertical dots printed.
* 4. Densities supported are 203x200(1) dpi.
* 5. This is a dual printer driver.  Select a PaperSize of 'Narrow Tractor'
*    for use with the ColorMaster; 'Wide Tractor' for use with the
*    ColorView-5912 (which uses 11 x 17 inch paper).
* 6. This driver is the same as the Calcomp_ColorMaster driver EXCEPT it is
*    approximately 2 times faster (during color dumps) and requires LOTS of
*    memory (up to 1,272,003 bytes for a full 8 x 10 inch (1600 x 2000 dot)
*    color dump).  Typically full-size (color) dumps are 1600 x 1149 dots and
*    require 730,767 bytes.  Memory requirements for the ColorView-5912
*    are up to 2,572,803 bytes for a full 10 x 16 inch (2048 x 3200 dot)
*    color dump.  Typically full-size (color) dumps are 2048 x 2155 dots and
*    require 1,732,623 bytes.  The memory requirements are 1/3 when doing a
*    non-color printout (on both the ColorMaster and ColorView).
*
* Canon_PJ-1080A
* --------------
* 1. Ink jet b&w/color printer (text and graphics).
* 2. Linefeeds # of vertical dots printed.
* 3. Densities supported are 83x84(1) dpi.
*
* CBM_MPS1000
* -----------
* 1. Dot matrix b&w printer (text and graphics).
* 2. Linefeeds # of vertical dots printed (-1/3 dot if PaperType = Single). *2
* 3. Density	XDPI	YDPI	XYDPI	Comments
* 	1	120	 72	 8640
* 	2	120	144	17280	two pass
* 	3	240	 72	17280			*1
* 	4	120	216	25920	three pass
* 	5	240	144	34560	two pass	*1
* 	6	240	216	51840	three pass	*1
* 	7	same as 6
* 4. Print width for US_LETTER size paper is 8.0 inches.
* 5. As of version 35.48, this driver calculates maximum X dots for
*    European A size paper as defined in preferences.h.  Some of
*    these sizes are too large for this printer.
*
* Diablo_630
* ----------
* 1. Daisywheel printer (text only).
*
* Diablo_Advantage_D25
* --------------------
* 1. Daisywheel printer (text only).
*
* Diablo_C-150
* ------------
* 1. Ink jet b&w/color printer (text and graphics).
* 2. Always linefeeds 4 dots (limitation of printer).
* 3. A PaperSize of 'Wide Tractor' selects a maximum print width of
*    8.5 inches (for wide roll paper).
* 5. Densities supported are 120x120(1) dpi.
*
* EpsonQ (24-pin Epson compatible)
* ------
* 1. Dot matrix b&w/color printer (text and graphics).
* 2. Drives all EpsonQ (LQ1500, LQ2500, etc.) compatible printers.
* 3. Linefeeds # of vertical dots printed.
* 4. Density	XDPI	YDPI	XYDPI	Comments
* 	1	 90	180	16200
* 	2	120	180	21600
* 	3	180	180	32400
* 	4	360	180	64800	*1
* 	5,6,7	same as 4
* 5. A PaperSize of 'Wide Tractor' selects a maximum print width of
*    13.6 inches (for wide carriage printers).
* 6. A PaperType of 'Single' uses only 16 of the 24 pins, whereas a PaperType
*    of 'Fanfold' uses all 24 pins.  The 'Single' option is useful for those
*    printers which have a weak power supply and cannot drive all 24 pins
*    continuously.  If during a single pass of the print head you notice that
*    the top two thirds of the graphics are darker than the bottom one third
*    then you will probably need to drop down to 16 pins.
* 7. As of version 35.71, this driver calculates maximum X dots for
*    European A size paper as defined in preferences.h.  The calculation
*    is based on millimeters minus 1/2 inch (approx 13mm).  Maximum
*    paper width is 13.6 inches, so some European A sizes are too large
*    for this printer.
*
* EpsonX[CBM_MPS-1250] (8/9-pin Epson compatible)
* --------------------
* 1. Dot matrix b&w/color printer (text and graphics).
* 2. Drives all EpsonX (EX/FX/JX/LX/MX/RX, etc.) compatible printers.
* 3. Linefeeds # of vertical dots printed (-1/3 dot if PaperType = Single). *2
* 4. Density	XDPI	YDPI	XYDPI	Comments
* 	1	120	 72	 8640
* 	2	120	144	17280	two pass
* 	3	240	 72	17280			*1
* 	4	120	216	25920	three pass
* 	5	240	144	34560	two pass	*1
* 	6	240	216	51840	three pass	*1
* 	7	same as 6
*
* 5. A PaperSize of 'Wide Tractor' selects a maximum print width of
*    13.6 inches (for wide carriage printers).
* 6. Use this driver if you own a CBM_MPS-1250 (as it is EpsonX compatible).
* 7. As of version 35.42, this driver calculates maximum X dots for
*    European A size paper as defined in preferences.h.  The calculation
*    is based on millimeters minus 1/2 inch (approx 13mm).  Maximum
*    paper width is 13.6 inches, so some European A sizes are too large
*    for this printer.
*
* EpsonXOld (8/9-pin Epson compatible)
* ---------
* 1. Dot matrix b&w printer (text and graphics).
* 2. Drives all very old EpsonX (EX/FX/JX/LX/MX/RX, etc.) compatible printers.
* 3. Linefeeds # of vertical dots printed.
* 4. Density	XDPI	YDPI	XYDPI	Comments
* 	1	 60	72	 4320
* 	2	120	72	 8640	(double speed)			*1
* 	3	120	72	 8640
* 	4	240	72	17280					*1
* 	5	120	72	 8640	(for use on old Star printers)
* 	6	240	72	17280	(for use on old Star printers)	*1
* 	7	240	72	17280	(same as density 4)		*1
* 5. A PaperSize of 'Wide Tractor' selects a maximum print width of
*    13.6 inches (for wide carriage printers).
* 6. Use this driver if the EpsonX driver does not work properly in graphics
*    or text mode on your EpsonX compatible printer.
*
* generic
* -------
* 1. Text only printer.
*
* Howtek_Pixelmaster
* ------------------
* 1. Plastic ink jet b&w/color printer (text and graphics).
* 2. Linefeeds # of vertical dots printed.
* 3. Density	XDPI	YDPI	XYDPI	Comments
* 	1	 80	 80	 6400
* 	2	120	120	14400
* 	3	160	160	25600
* 	4	240	240	57600
* 	5,6,7	same as 4
* 4. Maximum print area is 8.0 x 10.0 inches.
*
* HP_DeskJet
* ----------
* 1. Ink jet non-color printer (text and graphics).
* 2. Linefeeds # of vertical dots printed.
* 3. Density	XDPI	YDPI	XYDPI	Comments
* 	1	 75	 75	 5625
* 	2	100	100	10000
* 	3	150	150	22500
* 	4	300	300	90000
* 	5,6,7	same as 4
* 4. Maximum print area is 8.0 x 10.0 inches US_LEGAL, and 8.0 x
*    13.0 inches US_LETTER.
* 5. As of version 35.29, the driver will calculate maximum area
*    size for European A size paper as defined in preferences.h.
*    The driver calculates the maximum X, and Y dots based on
*    millimeters, minus 1/2 inch from the width, and minus 1"
*    from the height (approx 13mm, and 26mm respectively).
*    Therefore the margin area is consistent with US paper sizes.
* 6. Some European A sizes are too large for this printer.
*
* HP_LaserJet (LaserJet+/LaserJetII compatible)
* -----------
* 1. Laser engine non-color printer (text and graphics).
* 2. Linefeeds # of vertical dots printed.
* 3. Density	XDPI	YDPI	XYDPI	Comments
* 	1	 75	 75	 5625
* 	2	100	100	10000
* 	3	150	150	22500
* 	4	300	300	90000
* 	5,6,7	same as 4
* 4. Maximum print area is 8.0 x 10.0 inches US_LEGAL, and 8.0 x
*    13.0 inches US_LETTER.
* 5. As of version 35.59, the driver will calculate maximum area
*    size for European A size paper as defined in preferences.h.
*    The driver calculates the maximum X, and Y dots based on
*    millimeters, minus 1/2 inch from the width, and minus 1"
*    from the height (approx 13 mm, and 26 mm respectively).
*    Therefore the margin area is consistent with US paper sizes.
* 6. Some European A sizes are too large for this printer.
*
* HP_PaintJet
* -----------
* 1. Ink jet b&w/color printer (text and graphics).
* 2. Linefeeds # of vertical dots printed.
* 3. Densities supported are 180x180(1) dpi.
*
* HP_ThinkJet
* ----------
* 1. Ink jet non-color printer (text and graphics).
* 2. Linefeeds # of vertical dots printed.
* 3. Density	XDPI	YDPI	XYDPI	Comments
* 	1	 96	96	 9216
* 	2	192	96	18432
* 	3,4,5,6,7	same as 4
* 4. This printer prints 640 dots X in 96 DPI mode, and 120 dots
*    X in 192 DPI mode.  Other sizes are not supported by the
*    printer.
*
* Imagewriter II (Imagewriter compatible)
* --------------
* 1. Dot matrix b&w/color printer (text and graphics).
* 2. Linefeeds # of vertical dots printed.
* 3. Density	XDPI	YDPI	XYDPI	Comments
* 	1	 80	 72	 5760
* 	2	120	 72	 8640
* 	3	144	 72	10368
* 	4	160	 72	11520
* 	5	120	144	17280	two pass
* 	6	144	144	20736	two pass
* 	7	160	144	23040	two pass
*
* Nec_Pinwriter (24-wire Pinwriter compatible (P5/P6/P7/P9/P2200))
* -------------
* 1. Dot matrix b&w/color printer (text and graphics).
* 2. Drives all NEC 24-wire Pinwriter compatible printers.
* 3. Linefeeds # of vertical dots printed.
* 4. Density	XDPI	YDPI	XYDPI	Comments
* 	1	 90	180	 16200
* 	2	120	180	 21600
* 	3	180	180	 32400
* 	4	120	360	 43200	two pass
* 	5	180	360	 64800	two pass
* 	6	360	180	 64800
* 	7	360	360	129600	two pass
* 5. A PaperSize of 'Wide Tractor' selects a maximum print width of
*    13.6 inches (for wide carriage printers).
* 6. As of version 35.17, this driver calculates maximum X dots for
*    European A size paper as defined in preferences.h.  The calculation
*    is based on millimeters minus 1/2 inch (approx 13mm).  Maximum
*    paper width is 13.6 inches, so some European A sizes are too large
*    for this printer.
*
* Okidata_92
* ----------
* 1. Dot matrix non-color printer (text and graphics).
* 2. Always linefeeds 7/72 inch (limitation of printer in graphics mode).
* 3. Densities supported are 72x72 dpi.
*
* Okidata_293I
* ------------
* 1. Dot matrix b&w/color printer (text and graphics).
* 2. Drives 292 or 293 using the IBM interface module.
* 3. Linefeeds # of vertical dots printed (-1/2 dot if PaperType = Single) *3
* 4. Density	XDPI	YDPI	XYDPI	Comments
* 	1	120	144	17280
* 	2	240	144	34560
* 	3	120	288	34560	two pass
* 	4	240	288	69120	two pass
* 	5,6,7	same as 4
* 5. A PaperSize of 'Wide Tractor' selects a maximum print width of
*    13.6 inches (for wide carriage printers).
*
* Okimate-20
* ----------
* 1. Thermal transfer b&w/color printer (text and graphics).
* 2. Use Black ribbon for non-color dumps; Color ribbon for color dumps.
* 3. Linefeeds an even # of dots printed. (ie. if 3 printed, 4 advanced).
* 4. Densities supported are 120x144(1) dpi.
*
* Quadram_QuadJet
* ---------------
* 1. Ink jet b&w/color printer (text and graphics).
* 2. Linefeeds # of vertical dots printed.
* 3. Densities supported are 83x84(1) dpi.
*
* Qume_LetterPro_20
* -----------------
* 1. Daisywheel printer (text only).
*
* Seiko_5300
* ----------
* 1. Thermal transfer b&w/color printer (graphics only).
* 2. Use Black ribbon for non-color dumps; Color ribbon for color dumps.
* 3. Density	XDPI	YDPI	XYDPI	Comments
* 	1	152	152	23104	drives CH-5301 printer
* 	2	203	203	41209	drives CH-5312 printer
* 	3	240	240	57600	drives CH-5303 printer
* 	4, 5,6,7	same as 3
* 	You must select the proper density to drive the specific printer
* 	that you have.
* 4. This driver is not on the V1.3 Workbench or Extras disk.  It is
*    available on BIX and directly from Seiko.
*
* Seiko_5300a
* -----------
* 1. Thermal transfer b&w/color printer (graphics only).
* 2. Use Black ribbon for non-color dumps; Color ribbon for color dumps.
* 3. Density	XDPI	YDPI	XYDPI	Comments
* 	1	152	152	23104	drives CH-5301 printer
* 	2	203	203	41209	drives CH-5312 printer
* 	3	240	240	57600	drives CH-5303 printer
* 	4, 5,6,7	same as 3
* 	You must select the proper density to drive the specific printer
* 	that you have.
* 4. This driver is the same as the Seiko_5300 driver EXCEPT it is
*    approximately 2 times faster (during color dumps) and requires LOTS of
*    memory (up to 1,564,569 bytes for a full 8 x 10 inch (1927 x 2173 dot)
*    color dump).  Typically full-size (color) dumps are 1927 x 1248 dots
*    and require 898,569 bytes.  The memory requirements are 1/3 when doing
*    a non-color printout.
* 5. This driver is not on the V1.3 Workbench or Extras disk.  It is
*    available on BIX and directly from Seiko.
*
* Tektronix_4693D
* ---------------
* 1. Thermal transfer b&w/color printer (graphics only).
* 2. Densities supported are 300x300(1) dpi
* 3. Due to the way the printer images a picture none of the printer
*    preferences options affect the printout with the following exceptions:
*    a)Aspect - Horizontal, Vertical
*    b)Shade - B&W, Grey_Scale, Color
*    ...as a result of this only full size pictures can be printed.
* 4. Keypad menu option 3b COLOR ADJUSTMENT may be set from the keypad.
*    For normal prints this option should be set to "do not adjust".
* 5. Keypad menu option 3d VIDEO COLOR CORRECTION may be set from the keypad.
*    For normal prints this option should be set to "do not adjust".
* 6. Keypad menu option 5 BACKGROUND COLOR EXCHANGE may be set from the
*    keypad.  For normal prints this option should be set to "print colors
*    as received".
* 7. Once a picture has been printed additional copies may be printed
*    without resending by using the printers keypad.
* 8. This driver is not on the V1.3 Workbench or Extras disk.  It is
*    available on BIX and directly from Tektronix.
*
* Tektronix_4696
* --------------
* 1. Ink jet b&w/color printer (text and graphics).
* 2. Always linefeeds 4 dots (limitation of printer).
* 3. Densities supported are 121x120(1), 242x120(black)(2) and
*    242x120(color)(3).
*    Selecting a density of 2 or higher really doesn't give you true 242 dpi
*    resolution since the printer only has 121 x dots per inch.
*    Instead this mode tells the printer to go into it's double pass mode.
*    Here, it outputs a line of dots at 121 dpi; and outputs the line again
*    (shifted to the right by 1/242 of an inch).  This produces much more
*    vibrate colors and gives the illusion of more resolution.  One drawback
*    is that large areas of solid colors (red, green, and blue specifically)
*    tend to over-saturate the paper with ink.  Density1 outputs all colors
*    in one pass.  Density 2 does a double pass on black.  Density 3 does a
*    double pass on all colors.  Density 1 to 3 correspond to the printer's
*    graphics printing modes 1 to 3 (respectively).
* 4. This driver is not on the V1.3 Workbench or Extras disk.  It is
*    available on BIX and directly from Tektronix.
* 5. A PaperSize of 'Wide Tractor' selects a maximum print width of
*    9.0 inches (for wide roll paper).
*
* Toshiba_P351C (24-pin Toshiba compatible)
* -------------
* 1. Dot matrix b&w/color printer (text and graphics).
* 2. Drives all Toshiba_P351C compatible printers.
* 3. Linefeeds # of vertical dots printed.
* 4. Density	XDPI	YDPI	XYDPI	Comments
* 	1	180	180	32400
* 	2	360	180	64800
* 	3,4,5,6,7	same as 2
* 5. A PaperSize of 'Wide Tractor' selects a maximum print width of
*    13.5 inches (for wide carriage printers).
*
* Toshiba_P351SX (24-pin Toshiba compatible)
* --------------
* 1. Dot matrix b&w/color printer (text and graphics).
* 2. Drives all Toshiba_P351SX (321SL, 321SLC, 341SL) compatible printers.
* 3. Linefeeds # of vertical dots printed.
* 4. Density	XDPI	YDPI	XYDPI	Comments
* 	1	180	180	 32400
* 	2	360	180	 64800
* 	3	180	360	 64800	two pass
* 	4	360	360	129600	two pass
* 	5,6,7	same as 4
* 5. A PaperSize of 'Wide Tractor' selects a maximum print width of
*    13.5 inches (for wide carriage printers).
*
* Xerox_4020
* ----------
* 1. Ink jet b&w/color printer (text and graphics).
* 2. Always linefeeds 4 dots (limitation of printer).
* 3. This driver is IDENTICAL to the Diablo_C-150 driver EXCEPT it outputs
*    all black dots TWICE.  This is a special feature of this printer and
*    produces much more solid, darker black shades.  Please note that some
*    printing time overhead results from this feature; if you don't want it
*    use the Diablo_C-150 driver.
* 4. Densities supported are 121x120(1) and 242x240(2) dpi.
*    Selecting a density of 2 or higher really doesn't give you true 240 dpi
*    resolution since the Xerox_4020 only has 121 x dots per inch.
*    Instead this mode tells the printer to go into it's pseudo 240 dpi mode.
*    Here, it outputs a line of dots at 121 dpi; moves the paper up 1/240 of
*    an inch and outputs the line again (shifted to the right by 1/240 of an
*    inch).  This produces much more vibrate colors and gives the illusion
*    of more resolution.  One drawback is that large areas of solid colors
*    (red, green, and blue specifically) tend to over-saturate the paper with
*    ink.
* 5. A PaperSize of 'Wide Tractor' selects a maximum print width of
*    9.0 inches (for wide roll paper).
*
*
* Notes
* -----
*
* *0 - on most printers friction fed paper tends to produce better looking
*      (ie. less horizontal banding) graphic dumps than tractor fed paper.
*
* *1 - in this mode the printer cannot print two consecutive dots in a row.
*      It is recommended that you only use this density for B&W Shade dumps.
*
* *2 - only when 72 YDPI is selected.  This option is useful if you notice
*      tiny white horizontal strips in your printout.
*
* *3 - only when 144 YDPI is selected.  This option is useful if you notice
*      tiny white horizontal strips in your printout.
*
*********************************************************************/

#include <exec/memory.h>
#include <exec/errors.h>
#include <intuition/intuition.h>
#include <graphics/gfxbase.h>
#include <graphics/displayinfo.h>

#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/graphics_protos.h>

#include "printer.h"
#include "prtbase.h"
#include "prtgfx.h"

#include "internal.h"

#include "printer_iprotos.h"

#define DEBUG0		0	/* debugging flag: 0-off, 1-on */
#define DEBUG2		0	/* more debugging (list of colors, etc.) */
#define ALLOCDEBUG	0	/* debugging of allocated memory */
#define TDEBUG		0	/* time debugging */
#define SDEBUG		0	/* display symbols */
#define ADEBUG		0	/* aspect ration debugging */

PCDumpRPort(ior)
struct IODRPReq *ior; /* ior is a pointer to the input request */
{
	extern void *AllocMem();
	extern int Scale();
	extern ULONG TypeOfMem();
	extern DisplayInfoHandle FindDisplayInfo();

	extern struct GfxBase *GfxBase;
	extern struct PrinterData *PD;
	extern struct PrinterExtendedData *PED;

	/* misc vars */
	struct Layer *layer;
	struct ClipRect *cliprect;
	UWORD temp1, temp2, loop, depth;
	LONG ltemp;
	ULONG ulong1, ulong2, ulong3, ulong4, ulongpc, ulongpr;
	UBYTE *ptr;
	ULONG PrefsMaxWidth, PrefsMaxHeight, PrefsXOffset;
	UWORD *buf1, xmult, xmod;
	WORD etx;

	/* used for V36 graphics modes - new way to calculate
	   aspect ratio
	*/

	struct	DisplayInfo dpinfo;	/* to be filled in by graphics.lib V36. */
	ULONG	modeID;			/* set equal to io_Modes */
	DisplayInfoHandle mode_handle;
	UWORD	DefaultDPMY,DefaultDPMX;

	/* flags */
	int Aspect, HiRes, Lace, YReduce, XReduce, Center, Dimension;

	int MaxXDots, MaxYDots;
	int	maxX, maxY;
	ULONG aspectX, aspectY, XDotsInch, YDotsInch;
	int err, (*render)();
	ULONG special, mask;

	struct RastPort *rp;
	struct PrtInfo PInfo;
	union colorEntry *cm;
	UWORD xstart, ystart, width, height;
	UWORD maxcols, maxrows;
	LONG pc, pr;
	static UBYTE dmatrix[] = { /* ordered, halftone */
		/* ordered dither matrix */
		0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 14, 7, 13, 5, /* */
#if 1
		/* halftone dither matrix (rotated 45 degrees, looks better) */
		5, 12, 14, 3, 8, 0, 6, 10, 13, 2, 4, 14, 7, 11, 9, 1 /* */
#else
		/* halftone dither matrix (traditional orientation) */
		12, 4, 11, 14, 8, 0, 3, 7, 6, 2, 1, 9, 14, 10, 5, 13 /* */
#endif
	};

#if TDEBUG
    ULONG t1, t2, tl1, tl2;
    t1 = ReadVBlankTime();
#endif

#if SDEBUG
	kprintf("PCDumpRPort=%lx, roundit=%lx, GetSpecialDensity=%lx\n",
		&PCDumpRPort(), &roundit(), &GetSpecialDensity());
	kprintf("yexe=%lx, yexr=%lx, yrxe=%lx, yrxr=%lx\n",
		&YEnlargeXEnlarge(), &YEnlargeXReduce(),
		&YReduceXEnlarge(), &YReduceXReduce());
	kprintf("InitHamArray=%lx, ScanConvertPixelArray=%lx\n",
		&InitHamArray(), &ScanConvertPixelArray());
	kprintf("ConvertPixelArray=%lx, CompactPixelArray=%lx\n",
		&ConvertPixelArray(), &CompactPixelArray());
	kprintf("TransferPixelArray=%lx, CheckBuf=%lx, GetBlack=%lx\n",
		&TransferPixelArray(), &CheckBuf(), &GetBlack());
	kprintf("FixScalingVars=%lx, Force1to1Scaling=%lx, SwapInts=%lx\n",
		&FixScalingVars(), &Force1to1Scaling(), &SwapInts());
	kprintf("FixColorMap=%lx, FixColorsPixelArray=%lx\n",
		&FixColorMap(), &FixColorsPixelArray());
	kprintf("PCQuery=%lx, FloydPixelArray=%lx, FloydSwapDest=%lx\n",
		&PCQuery(), &FloydPixelArray(), &FloydSwapDest());
	kprintf("AliasSwapBufs=%lx, AliasPixelArray=%lx\n",
		&AliasSwapBufs(), &AliasPixelArray());
	kprintf("PD=%lx, PED=%lx, render=%lx, PInfo=%lx\n",
		PD, PED, PED->ped_Render, &PInfo);
#endif SDEBUG
	loop = sizeof(struct PrtInfo);
	ptr = (UBYTE *)&PInfo;
	do {
		*ptr++ = 0; /* zero all members of structure */
	} while (--loop);

	PInfo.pi_rp = rp = ior->io_RastPort;
	xstart = ior->io_SrcX;
	ystart = ior->io_SrcY;
	width = ior->io_SrcWidth;
	height = ior->io_SrcHeight;
	pc = ior->io_DestCols;
	pr = ior->io_DestRows;
	PInfo.pi_render = render = PED->ped_Render;
	PInfo.pi_PrefsFlags = PD->pd_Preferences.PrintFlags;
	Dimension = PInfo.pi_PrefsFlags & DIMENSIONS_MASK;
	special = ior->io_Special;
	GetSpecialDensity(&special);

#if	DEBUG0
	kprintf("PCDumpRPort: enter, ior=%08lx\n", ior);
	kprintf("RastPort=%08lx, ColorMap=%08lx, Modes=%04lx, Special=%04lx, PrefsFlags=%04lx\n",
		rp, ior->io_ColorMap, ior->io_Modes, special, PInfo.pi_PrefsFlags);
	kprintf(
"xstart,ystart=%ld,%ld, width,height=%ld,%ld, pc,pr=%ld,%ld, render=%lx\n",
		xstart, ystart, width, height, pc, pr, render);
	kprintf("SPECIAL = ");
	if (special & SPECIAL_MILCOLS) {
		kprintf("MILCOLS ");
	}
	if (special & SPECIAL_MILROWS) {
		kprintf("MILROWS ");
	}
	if (special & SPECIAL_FULLCOLS) {
		kprintf("FULLCOLS ");
	}
	if (special & SPECIAL_FULLROWS) {
		kprintf("FULLROWS ");
	}
	if (special & SPECIAL_FRACCOLS) {
		kprintf("FRACCOLS ");
	}
	if (special & SPECIAL_FRACROWS) {
		kprintf("FRACROWS ");
	}
	if (special & SPECIAL_CENTER) {
		kprintf(" ");
	}
	if (special & SPECIAL_ASPECT) {
		kprintf("ASPECT ");
	}
	if (ltemp = (special & SPECIAL_DENSITYMASK)) {
		if (ltemp == SPECIAL_DENSITY1) {
			kprintf("DENSITY1 ");
		}
		else if (ltemp == SPECIAL_DENSITY2) {
			kprintf("DENSITY2 ");
		}
		else if (ltemp == SPECIAL_DENSITY3) {
			kprintf("DENSITY3 ");
		}
		else if (ltemp == SPECIAL_DENSITY4) {
			kprintf("DENSITY4 ");
		}
		else if (ltemp == SPECIAL_DENSITY5) {
			kprintf("DENSITY5 ");
		}
		else if (ltemp == SPECIAL_DENSITY6) {
			kprintf("DENSITY6 ");
		}
		else {
			kprintf("DENSITY7 ");
		}
	}
	if (special & SPECIAL_NOFORMFEED) {
		kprintf("NOFORMFEED ");
	}
	if (special & SPECIAL_TRUSTME) {
		kprintf("TRUSTME ");
	}
	if (special & SPECIAL_NOPRINT) {
		kprintf("NOPRINT ");
	}
	kprintf("\n");
	kprintf("PRINTFLAGS = ");
	if (PInfo.pi_PrefsFlags & CORRECT_RED) {
		kprintf("CORRECT_RED ");
	}
	if (PInfo.pi_PrefsFlags & CORRECT_GREEN) {
		kprintf("CORRECT_GREEN ");
	}
	if (PInfo.pi_PrefsFlags & CORRECT_BLUE) {
		kprintf("CORRECT_BLUE ");
	}
	if (PInfo.pi_PrefsFlags & CENTER_IMAGE) {
		kprintf("CENTER_IMAGE ");
	}
	if (Dimension & MULTIPLY_DIMENSIONS) {
		kprintf("MULTIPLY_DIMENSIONS ");
	}
	else if (Dimension & PIXEL_DIMENSIONS) {
		kprintf("PIXEL_DIMENSIONS ");
	}
	else if (Dimension & BOUNDED_DIMENSIONS) {
		kprintf("BOUNDED_DIMENSIONS ");
	}
	else if (Dimension & ABSOLUTE_DIMENSIONS) {
		kprintf("ABSOLUTE_DIMENSIONS ");
	}
	else {
		kprintf("IGNORE_DIMENSIONS ");
	}
	if (PInfo.pi_PrefsFlags & INTEGER_SCALING) {
		kprintf("INTEGER_SCALING ");
	}
	if ((PInfo.pi_PrefsFlags & DITHERING_MASK) == HALFTONE_DITHERING) {
		kprintf("HALFTONE_DITHERING ");
	}
	else if ((PInfo.pi_PrefsFlags & DITHERING_MASK) == FLOYD_DITHERING) {
		kprintf("FLOYD_DITHERING ");
	}
	else {
		kprintf("ORDERED_DITHERING ");
	}
	if (PInfo.pi_PrefsFlags & ANTI_ALIAS) {
		kprintf("ANTI_ALIAS ");
	}
	kprintf("\n");
#endif DEBUG0

	if (!(PED->ped_PrinterClass & PPCF_GFX)) {
		return(Backout(PDERR_NOTGRAPHICS, ior, &PInfo));
	}

	/* MUST DO THIS FIRST AS IT MAY ALTER SOME VARS IN PED */
	Center =
		(PInfo.pi_PrefsFlags & CENTER_IMAGE) | (special & SPECIAL_CENTER);
	if (Center) { /* if want to center picture */
		special &= ~SPECIAL_CENTER; /* clear flag since we did the work */
	}
#if DEBUG0
	kprintf("calling case 5 render (init density stuff)\n");
#endif DEBUG0
	/* init special stuff (density, etc.) */
    /* the 5th parameter here is for V1.0 compatability */
	if (err = (*render)(ior, special, 0, 5, special)) {
#if DEBUG0
		kprintf("case 5 render failed, calling Backout with err=%ld\n", err);
#endif DEBUG0
		return(Backout(err, ior, &PInfo));
	}

	PInfo.pi_special = special;
	PInfo.pi_dmatrix = (PInfo.pi_PrefsFlags & HALFTONE_DITHERING) ?
		&dmatrix[16] : dmatrix;

	/* set up convenience variables */

	/* set flag for whether the printer has black capabilities */
	temp1 = PED->ped_ColorClass & (PCC_BW | PCC_YMC | PCC_YMC_BW | PCC_YMCB);
	if (temp1 != PCC_YMC) { /* if not YMC */
		/* if not YMC_BW or (YMC_BW and not a color picture) */
		if (temp1 != PCC_YMC_BW || (temp1 == PCC_YMC_BW &&
			PD->pd_Preferences.PrintShade != SHADE_COLOR)) {
			PInfo.pi_flags |= PRT_BLACKABLE; /* prt has black capabilities */
		}
	}
	/* set flag for horizontal or vertical pictures */
	if (PD->pd_Preferences.PrintAspect == ASPECT_VERT) {
		PInfo.pi_flags |= PRT_INVERT;
	}
	/* set flag for a b/w or half-tone pictures */
	if (PD->pd_Preferences.PrintShade != SHADE_COLOR) {
		PInfo.pi_flags |= PRT_BW;
	}
	/* set flag for non-dithering of b/w pictures */
	if (PD->pd_Preferences.PrintShade == SHADE_BW) {
		PInfo.pi_threshold = PD->pd_Preferences.PrintThreshold;
	}
	else {
		PInfo.pi_threshold = 0;
	}
	if (ior->io_Modes & HAM) {
		PInfo.pi_flags |= PRT_HAM;
	}
	HiRes = (ior->io_Modes & HIRES) != 0; /* hires flag */
	Lace = (ior->io_Modes & LACE) != 0; /* interlace flag */

	if (layer = rp->Layer) { /* if doing a layer */
		if (layer->SuperBitMap) { /* SuperBitMap ? */
			maxcols = layer->SuperBitMap->BytesPerRow * 8;
			maxrows = layer->SuperBitMap->Rows;

			if (GfxBase->LibNode.lib_Version >= 39) {
				maxcols = GetBitMapAttr(layer->SuperBitMap,BMA_WIDTH);
				maxrows = GetBitMapAttr(layer->SuperBitMap,BMA_HEIGHT);

			}

		}
		else { /* not a SBM */
			maxcols = layer->bounds.MaxX - layer->bounds.MinX + 1;
			maxrows = layer->bounds.MaxY - layer->bounds.MinY + 1;
		}
	}
	else { /* else doing a screen (bitmap) */
		maxcols = rp->BitMap->BytesPerRow * 8;
		maxrows = rp->BitMap->Rows;

		if (GfxBase->LibNode.lib_Version >= 39) {
			maxcols = GetBitMapAttr(rp->BitMap,BMA_WIDTH);
			maxrows = GetBitMapAttr(rp->BitMap,BMA_HEIGHT);

		}
	}
#if	DEBUG0
	kprintf("source size: maxcols=%ld, maxrows=%ld\n", maxcols, maxrows);
#endif DEBUG0

	if ( (xstart<0) || (ystart<0) || (width<=0) || (height<=0)
		|| (xstart + width > maxcols) || (ystart + height > maxrows) ) {
		return(Backout(PDERR_BADDIMENSION, ior, &PInfo));
	}

	XDotsInch = PED->ped_XDotsInch;
	YDotsInch = PED->ped_YDotsInch;

	/* calculate maximum printer width */
	MaxXDots = PED->ped_MaxXDots;
	/* BOUNDED | ABSOLUTE | PIXELS | MULTIPLY */
	if (Dimension != IGNORE_DIMENSIONS) {
		/* get raw number (assume pixels for PIXEL_DIMENSIONS) */
		PrefsMaxWidth = PD->pd_Preferences.PrintMaxWidth;
		if (Dimension & MULTIPLY_DIMENSIONS) {
			PrefsMaxWidth *= width; /* use max width as a multiplier */
		}
		else if (!(Dimension & PIXEL_DIMENSIONS)) {
			/* convert max width from 10ths/" to printer pixels */
			PrefsMaxWidth = (PrefsMaxWidth * XDotsInch + 5) / 10;
		}
	}
	else { /* IGNORE_DIMENSIONS */
		PrefsMaxWidth = (PD->pd_Preferences.PrintRightMargin + 1 -
			PD->pd_Preferences.PrintLeftMargin) * XDotsInch;
		switch (PD->pd_Preferences.PrintPitch) {
			case ELITE:
				PrefsMaxWidth = (PrefsMaxWidth + 6) / 12;
				break;
			case FINE:
				PrefsMaxWidth = (PrefsMaxWidth + 7) / 15;
				break;
			default /* PICA */:
				PrefsMaxWidth = (PrefsMaxWidth + 5) / 10;
				break;
		}
	}
	/*
		We want the lessor of the two BUT not if 'PrefsMaxWidth == 0'
		since this is a special case which means use the maximum width.
	*/
	maxX = (PrefsMaxWidth && (PrefsMaxWidth < MaxXDots)) ?
		PrefsMaxWidth : MaxXDots;
#if DEBUG0
	kprintf("MaxXDots=%ld, PrefsMaxWidth=%ld, maxX=%ld\n",
		MaxXDots, PrefsMaxWidth, maxX);
#endif

	/* calculate maximum printer height */
	MaxYDots = PED->ped_MaxYDots;
	/* BOUNDED | ABSOLUTE | PIXELS | MULTIPLY */
	if (Dimension != IGNORE_DIMENSIONS) {
		/* get raw number (assume pixels for PIXEL_DIMENSIONS) */
		PrefsMaxHeight = PD->pd_Preferences.PrintMaxHeight;
		if (Dimension & MULTIPLY_DIMENSIONS) {
			PrefsMaxHeight *= height; /* use max height as a multiplier */
		}
		else if (!(Dimension & PIXEL_DIMENSIONS)) {
			/* convert max height from 10ths/" to printer pixels */
			PrefsMaxHeight = (PrefsMaxHeight * YDotsInch + 5) / 10;
		}
	}
	else { /* IGNORE_DIMENSIONS */
		PrefsMaxHeight = PD->pd_Preferences.PaperLength * YDotsInch;
		switch (PD->pd_Preferences.PrintSpacing) {
			case EIGHT_LPI:
				PrefsMaxHeight = (PrefsMaxHeight + 4) / 8;
				break;
			default /* SIX_LPI */:
				PrefsMaxHeight = (PrefsMaxHeight + 3) / 6;
				break;
		}
	}
	/*
		We want the lessor of the two BUT not if 'PrefsMaxHeight == 0'
		or 'MaxYDots == 0' since both are special cases which mean
		use the maximum height.
	*/
	maxY = (PrefsMaxHeight && (PrefsMaxHeight < MaxYDots) || !MaxYDots) ?
		PrefsMaxHeight : MaxYDots;
	/*
		If maxY is 0 then the printer has no maximum height.  So we
		chose an arbitrary large number (100 feet) for the maximum
		height.
	*/
	if (maxY == 0) {
		maxY = 600 * 1200; /* 600 dpi * 1200 inches (100 ft) */
	}
#if DEBUG0
	kprintf("MaxYDots=%ld, PrefsMaxHeight=%ld, maxY=%ld\n",
		MaxYDots, PrefsMaxHeight, maxY);
#endif

	if (Dimension &
		(ABSOLUTE_DIMENSIONS | PIXEL_DIMENSIONS | MULTIPLY_DIMENSIONS)) {
		special &= ~SPECIAL_DIMENSIONSMASK; /* clear flags */
		pc = PrefsMaxWidth; /* force # of print columns */
		pr = PrefsMaxHeight; /* force # of print rows */
	}

#if	DEBUG0
	kprintf("Ver=%ld, Rev=%ld, DPMY=%ld, DPMX=%ld\n",
		GfxBase->LibNode.lib_Version, GfxBase->LibNode.lib_Revision,
		GfxBase->NormalDPMY, GfxBase->NormalDPMX);
#endif DEBUG0

	/*
		The following is a known bug/feature!  Technically, special
		must be zero along with pc or pr to enable aspecting.
		However, some software packages assume that this bug is a
		feature so I cannot fix it.  Arrgh!
	*/
/*	if ((special == 0 && (pc == 0 || pr == 0)) ||
*/	if ((pc == 0 || pr == 0) ||
		(special & SPECIAL_ASPECT)) {
		Aspect = TRUE;
		/* Hedley Hi-Res has an aspect ratio of 15:16 (1 : 1.06666) */
		if (PD->pd_Preferences.LaceWB & 128) {
			aspectX = 15;
			aspectY = 16;
		}
		else {
			if (GfxBase->LibNode.lib_Version >= 33) {
				aspectX = roundit(10 * GfxBase->NormalDPMY / 182);
				aspectY = roundit(10 * GfxBase->NormalDPMX / 182);

			}

			/* graphics.library < V33 */
			else {
				aspectX = 6;
				aspectY = 7;
			}
			if (!HiRes) {
				aspectX += aspectX;
			}
			if (!Lace) {
				aspectY += aspectY;
			}
		}

		/* New for V36 - we let graphics.library */
		/* tell us what the aspect ratio is, but */
		/* we have set-up some defaults above    */
		/* incase our checks don't pass.         */
		/* We do check for valid modeID, and let */
		/* graphics.library check for a garbage  */
		/* modeID.                               */

		/* For compatability with our own docs   */
		/* there is now code here to check to	 */
		/* to see if someone swizzled GfxBase    */
		/* NormalDPMX/DPMY - (sigh)              */

		if(GfxBase->LibNode.lib_Version >= 36)
		{
		    /* default is NTSC                       */
		    /* graphics uses these values hard-coded */
		    /* and infact never uses them, but sets  */
		    /* them up at startup for historical     */
		    /* reasosn.  Sadly, they are also used   */
		    /* by the printer.device, and documented */
		    /* as values you can swizzle :-(         */

		    DefaultDPMX=1280;
		    DefaultDPMY=1098;		/* roughly 6/7 */

		    if(GfxBase->DisplayFlags & PAL)
		    {
			DefaultDPMX=1226;
			DefaultDPMY=1299;	/* roughly 1/1 */
		    }

		    if(GfxBase->NormalDPMX == DefaultDPMX)
		    {
			if(GfxBase->NormalDPMY == DefaultDPMY)
			{
			    modeID=ior->io_Modes;
			    if(modeID != INVALID_ID)
			    {
				/* validate ID */
				/* graphics lib knows what a good id is*/

				if(mode_handle=FindDisplayInfo(modeID))
				{
				    if(GetDisplayInfoData(mode_handle,
					(UBYTE *)&dpinfo,
					sizeof(struct DisplayInfo),
					DTAG_DISP,modeID))
				    {
#if ADEBUG
					kprintf("V36 Aspect ratio %ld : %ld\n",
						dpinfo.Resolution.x,
						dpinfo.Resolution.y);
#endif
					aspectX=(ULONG)dpinfo.Resolution.x;
					aspectY=(ULONG)dpinfo.Resolution.y;
				    }
				}
			    }
			}
		    }
		}
	}
	else {
		Aspect = FALSE;
	}

	/* compute inverting stuff */
	if (PInfo.pi_flags & PRT_INVERT) { /* if want to invert picture */
		/* swap x&y vars */
		temp1 = ystart;
		ystart = xstart;
		xstart = temp1 + height - 1;
		ltemp = pc;
		pc = pr;
		pr = ltemp;
		ltemp = aspectX;
		aspectX = aspectY;
		aspectY = ltemp;
		temp1 = width;
		width = height;
		height = temp1;
		/* swap spc bits 1, 3, and 5 (0x15) with bits 2, 4, and 6 (0x2a) */
		ulong1 = special & 0x3f; /* get first 6 bits */
		ulong2 = special & ~0x3f; /* get all but first 6 bits */
		special = ulong2 | ((ulong1 >> 1) & 0x15) | ((ulong1 << 1) & 0x2a);
#if	DEBUG0
		kprintf("inversion corrected pc=%ld, pr=%ld, special=%04lx\n",
			pc, pr, special);
#endif
	}

	/* old auto enlarge/reduce */
	if ((special == 0) && ((pc < 0) || (pr < 0))) {
		pc = width * pc / pr;
		if (pc < 0) {
			pc = -pc;
		}
		pr = 0;
#if	DEBUG0
		kprintf("obsolete auto enlarge/reduce: pc=%ld, pr=%ld\n", pc, pr);
#endif
	}

	/*
		At this point we have taken care of the special case where
		pc and/or pr may be < 0.  The are now definately >= 0.  Thus
		we are going to switch to ulongpc and ulongpr which gives us
		an extra bit of precision.
	*/
	ulongpc = (ULONG)pc;
	ulongpr = (ULONG)pr;

	if (special & SPECIAL_MILCOLS) {
		ulongpc = (ulongpc * XDotsInch + 500) / 1000;
#if	DEBUG0
		kprintf("milcorrected ulongpc=%ld\n", ulongpc);
#endif
	}
	if (special & SPECIAL_MILROWS) {
		ulongpr = (ulongpr * YDotsInch + 500) / 1000;
#if	DEBUG0
		kprintf("milcorrected ulongpr=%ld\n", ulongpr);
#endif
	}

	/* same bug/feature as explained above */
/*	if ((special == 0 && ulongpc == 0) || (special & SPECIAL_FULLCOLS)) {
*/	if (ulongpc == 0 || (special & SPECIAL_FULLCOLS)) {
		ulongpc = maxX;
#if	DEBUG0
		kprintf("full corrected ulongpc=%ld\n", ulongpc);
#endif
	}
	else if (special & SPECIAL_FRACCOLS) {
		ulongpc >>= 15;
		ulongpc++;
		ulongpc = ((ulongpc >> 1) * maxX) >> 16;
#if DEBUG0
		kprintf("frac corrected ulongpc=%ld\n", ulongpc);
#endif
	}
/*	if ((special == 0 && ulongpr == 0) || (special & SPECIAL_FULLROWS)) {
*/	if (ulongpr == 0 || (special & SPECIAL_FULLROWS)) {
		ulongpr = maxY;
#if	DEBUG0
		kprintf("full corrected ulongpr=%ld\n", ulongpr);
#endif
	}
	else if (special & SPECIAL_FRACROWS) {
		ulongpr >>= 15;
		ulongpr++;
		/*
			Old code (can cause 32 bit overflow).
			ulongpr = ((ulongpr >> 1) * maxY) >> 16;
		*/
		ulongpr >>= 1;
		loop = 0;
		temp1 = 1;
		temp2 = 0;
		do {
			ulong1 = (maxY + temp2) / temp1;
			ulong2 = ulongpr * ulong1;
			loop++;
			temp1 *=2;
			temp2 = temp1 / 2;
		} while (ulong2 / ulongpr != ulong1);
		ulongpr = ulong2 >> 16;
#if DEBUG0
		kprintf("frac corrected ulongpr=%ld, loop=%ld, temp1=%ld\n",
			ulongpr, loop, temp1);
#endif
	}

	/* else use ulongpr & ulongpc as absolute values */

	if (Aspect) { /* aspect ratio correct image */
#if	DEBUG0
		kprintf("aspecting...");
#endif
		/*
			This is a KLUDGE so that I don't overrun ulong1 and
			ulong2.  I start by dividing the temp. values ulong3
			and ulong 4 by 1.  If the result of ulong3 x ulongpr
			or ulong4 x ulongpc overruns 32 bits then I go back
			and do it again BUT I increase the ulong3 and ulong4
			divisor by a power of 2.  This will prevent overrun
			at the expence of precision.
		*/
		loop = 0;
		temp1 = 1;
		temp2 = 0;
		do {
			ulong3 = (width * aspectX * XDotsInch + temp2) / temp1;
			ulong4 = (height * aspectY * YDotsInch + temp2) / temp1;
			ulong1 = ulongpr * ulong3;
			ulong2 = ulongpc * ulong4;
			loop++;
			temp1 *=2;
			temp2 = temp1 / 2;
		} while ((ulong1 / ulongpr != ulong3) ||
			(ulong2 / ulongpc != ulong4));
#if DEBUG0
		kprintf("width=%ld, aspectX=%ld, XDotsInch=%ld\n",
			width, aspectX, XDotsInch);
		kprintf("height=%ld, aspectY=%ld, YDotsInch=%ld\n",
			height, aspectY, YDotsInch);
		kprintf("ulong3=%ld, ulong4=%ld, ulong1=%ld, ulong2=%ld\n",
			ulong3, ulong4, ulong1, ulong2);
	kprintf("loop=%ld, temp1=%ld, temp2=%ld, ulongpc=%ld, ulongpr=%ld\n",
			loop, temp1, temp2, ulongpc, ulongpr);
#endif
		if (ulong1 > ulong2) {
			/* diminish ulongpr to correct aspect ratio */
			ulongpr = ulong2 / ulong3;
#if DEBUG0
			kprintf("aspect corrected ulongpr=%ld\n", ulongpr);
#endif
		}
		else if (ulong1 < ulong2) {
			/* diminish ulongpc to correct aspect ratio */
			ulongpc = ulong1 / ulong4;
#if	DEBUG0
			kprintf("aspect corrected ulongpc=%ld\n", ulongpc);
#endif
		}
	}

	/*
		If INTEGER scaling is on then we must scale the # of print columns
		and print rows up or down to the nearest multiple of width and
		height respectively.
	*/
	if (PInfo.pi_PrefsFlags & INTEGER_SCALING) {
#if DEBUG0
		kprintf("INTEGER: ulongpc=%ld, width=%ld, ", ulongpc, width);
#endif
		if (ulongpc < width) {
			ulongpc = width;
		}
		else {
			temp1 = ulongpc % width;
			if (temp1 < width / 2) {
				ulongpc -= temp1;
			}
			else {
				ulongpc += width - temp1;
			}
		}
#if DEBUG0
		kprintf("CORRECTED ulongpc=%ld\nINTEGER: ulongpr=%ld, height=%ld, ",
			ulongpc, ulongpr, height);
#endif
		if (ulongpr < height) {
			ulongpr = height;
		}
		else {
			temp1 = ulongpr % height;
			if (temp1 < height / 2) {
				ulongpr -= temp1;
			}
			else {
				ulongpr += height - temp1;
			}
		}
#if DEBUG0
		kprintf("CORRECTED ulongpr=%ld\n", ulongpr);
#endif
	}
	/*
		If the printer's maximum width is not 0 and the requested
		number of print columns (ulongpc) is greater then the
		printer's maximum width, then set ulongpc to the printer's
		maximum width.
	*/
	if (MaxXDots && (ulongpc > MaxXDots)) {
		ulongpc = MaxXDots;
	}
	/*
		If the printer's maximum height is not 0 and the requested
		number of print rows (ulongpr) is greater then the printer's
		maximum height, then set pr to the printer's maximum height.
	*/
	if (MaxYDots && (ulongpr > MaxYDots)) {
		ulongpr = MaxYDots;
	}

	/*
		At this point 'ulongpc' is at its final value so it is safe to
		calculate the x offset.
	*/
	if (Center) {
		/* calc start posn (note: xpos range is 0 to MaxXDots - 1) */
		PInfo.pi_xpos = (PED->ped_MaxXDots - ulongpc + 1) / 2;
	}
	else { /* check for a user specified x offset */
		if (PrefsXOffset = PD->pd_Preferences.PrintXOffset) {
			/* convert 10ths/" offset to printer pixels */
			PrefsXOffset = (PrefsXOffset * PED->ped_XDotsInch + 5) / 10;
			/* if offset too big, make as big as possible */
			if (PrefsXOffset + ulongpc > PED->ped_MaxXDots) {
				PrefsXOffset = PED->ped_MaxXDots - ulongpc;
			}
			PInfo.pi_xpos = PrefsXOffset;
		}
	}

	/*
		At this point 'ulongpc' and 'ulongpr' are at their final
		value.  If 'NOPRINT' is selected, then we return these values
		to the calling program.
	*/
	if (special & SPECIAL_NOPRINT) {
		ior->io_DestCols = ulongpc + PInfo.pi_xpos;;
		ior->io_DestRows = ulongpr;
		return(Backout(PDERR_NOERR, ior, &PInfo)); /* exit cleanly */
	}

	/* compute y scaling stuff */
	if (YReduce = (height > ulongpr)) { /* if Y REDUCTION */
		PInfo.pi_ymult = height / ulongpr;
		PInfo.pi_ymod = height % ulongpr;
		PInfo.pi_ety = ulongpr;
	}
	else { /* Y ENLARGEMENT or 1:1 */
		PInfo.pi_ymult = ulongpr / height;
		PInfo.pi_ymod = ulongpr % height;
		PInfo.pi_ety = height;
	}

	/* compute x scaling stuff */
	if (XReduce = (width > ulongpc)) { /* if X REDUCTION */
		xmult = width / ulongpc;
		xmod = width % ulongpc;
		etx = ulongpc;
	}
	else { /* X ENLARGEMENT or 1:1 */
		xmult = ulongpc / width;
		xmod = ulongpc % width;
		etx = width;
	}

	/* can alloc mem from this point on cause the NOPRINT option is above */

	depth = rp->BitMap->Depth;

	if (GfxBase->LibNode.lib_Version >= 39) {
		depth = GetBitMapAttr(rp->BitMap,BMA_DEPTH);

	}


	/* see if there are too many planes for ClipBlit use */
	if (depth > MAXDEPTH) {
#if DEBUG0
		kprintf("TOO MANY PLANES FOR CLIPBLIT!\n");
#endif
		PInfo.pi_flags |= PRT_NOBLIT; /* cant use blitter */
	}
	/* see if any of the original rp's planes are in fast mem */
	for (loop=0; loop<depth; loop++) {
		if ((TypeOfMem(rp->BitMap->Planes[loop]) & MEMF_CHIP) != MEMF_CHIP) {
#if DEBUG0
			kprintf("SOURCE RP PLANES ARE NOT IN CHIP MEM!\n");
#endif
			PInfo.pi_flags |= PRT_NOBLIT; /* cant use blitter */
			break;
		}
	}
	/* if not using blitter and this rp has a layer */
	if ((PInfo.pi_flags & PRT_NOBLIT) && layer) {
		for (cliprect = layer->ClipRect; cliprect != NULL;
			cliprect = cliprect->Next) {
			if (cliprect->lobs != NULL) {
				PInfo.pi_flags |= PRT_NORPL;
#if DEBUG0
				kprintf("SOURCE RP PLANES HAVE OBSCURED CLIPRECTS!\n");
#endif
				break;
			}
		}
	}

	if (!(PInfo.pi_flags & PRT_NORPL)) {
		/* get mem for temp rastport */
		if ((PInfo.pi_temprp = AllocMem(sizeof(struct RastPort), MEMF_PUBLIC))
			== NULL) {
#if ALLOCDEBUG
			kprintf("couldn't get %ld bytes for rp\n",
				sizeof(struct RastPort));
#endif
			return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
		}
#if ALLOCDEBUG
		kprintf("depth=%ld, got %ld bytes for rp @@ %lx-%lx\n",
			depth, sizeof(struct RastPort), PInfo.pi_temprp,
			sizeof(struct RastPort) + (UBYTE *)PInfo.pi_temprp - 1);
#endif DEBUG0
		*(PInfo.pi_temprp) = *rp; /* copy rp */
		/* make sure we can write to all planes */
		PInfo.pi_temprp->Mask = 0xff;
		PInfo.pi_temprp->BitMap = NULL; /* havnt got this yet */
		PInfo.pi_temprp->Layer = NULL; /* no layers for this rp */
		/* make sure we have enough mem for ALL the planeptrs */
		temp1 = sizeof(struct BitMap) + depth * sizeof(PLANEPTR);
		/* get mem for temp bitmap */
		if ((PInfo.pi_temprp->BitMap = AllocMem(temp1, MEMF_PUBLIC)) ==
			NULL) {
#if ALLOCDEBUG
			kprintf("couldn't get %ld bytes for bm\n",
				temp1);
#endif
			return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
		}
#if ALLOCDEBUG
		kprintf("got %ld bytes for bm @@ %lx-%lx\n",
			temp1, PInfo.pi_temprp->BitMap,
			temp1 + (UBYTE *)PInfo.pi_temprp->BitMap - 1);
#endif DEBUG0
		*(PInfo.pi_temprp->BitMap) = *(rp->BitMap); /* copy rp bitmap */
		/* have not got these yet */
		PInfo.pi_temprp->BitMap->Planes[0] = NULL;
		/* force copy of bitmap to 1 line high */
		PInfo.pi_temprp->BitMap->Rows = 1;
		/*
			we may need to read in an entire row or an entire col of pixels,
			so make sure that the temprp is big enough for either.
		*/
		temp1 = maxcols > maxrows ? maxcols : maxrows;
		temp1 = ((temp1 + 15) / 16) * 2; /* calculate # of BytesPerRow */
		/* set # of BytesPerRow */
		PInfo.pi_temprp->BitMap->BytesPerRow = temp1;
		temp2 = temp1 * depth; /* calculate # of bytes for all planes */
		if ((PInfo.pi_temprp->BitMap->Planes[0] = AllocMem(temp2, MEMF_CHIP))
			== NULL) {
#if ALLOCDEBUG
			kprintf("couldn't get %ld bytes for Planes\n", temp2);
#endif
			return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
		}
#if ALLOCDEBUG
		kprintf("got %ld bytes for Planes[0] @@ %lx-%lx\n",
			temp2, PInfo.pi_temprp->BitMap->Planes[0],
			temp2 + (UBYTE *)PInfo.pi_temprp->BitMap->Planes[0] - 1);
#endif DEBUG0
		/* initialize plane ptrs for temp bitmap */
		for (loop=1; loop<depth; loop++) {
			PInfo.pi_temprp->BitMap->Planes[loop] =
				PInfo.pi_temprp->BitMap->Planes[loop - 1] + temp1;
#if DEBUG0
			kprintf("Planes[%ld] = %lx-%lx\n",
				loop, PInfo.pi_temprp->BitMap->Planes[loop],
				temp1 + PInfo.pi_temprp->BitMap->Planes[loop] - 1);
#endif
		}
	}

	/****** initialize printerColorMap ******/
	temp1 = 1 << rp->BitMap->Depth;	/* get # of colors in palette */

	if (GfxBase->LibNode.lib_Version >= 39) {
		temp1 = 1 << GetBitMapAttr(rp->BitMap,BMA_DEPTH);
	}

	if (ior->io_Modes & EXTRA_HALFBRITE) {
		/* only half as many real colors, other half will be computed */
		temp1 >>= 1;
	}
	temp2 = temp1 * sizeof(union colorEntry);
#if DEBUG0
	kprintf("# planes = %ld, # colors = %ld, mem req = %ld bytes\n",
		depth, temp1, temp2);
#endif DEBUG0
	if (ior->io_Modes & EXTRA_HALFBRITE) {
		temp2 += (32 + 32 - temp1) * sizeof(union colorEntry);
	}
	PInfo.pi_ColorMapSize = temp2;
	if ((cm = AllocMem(temp2, MEMF_PUBLIC)) == NULL) {
#if ALLOCDEBUG
		kprintf("couldn't get %ld bytes for ColorMap\n", temp2);
#endif
		return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
	}
	PInfo.pi_ColorMap = cm;
#if ALLOCDEBUG
	kprintf("got %ld bytes (%ld entries) for ColorMap @@ %lx-%lx\n",
		temp2, temp1, cm, temp2 + (UBYTE *)cm - 1);
#endif DEBUG0
	for (loop=0; loop<temp1; loop++) {
		temp2 = GetRGB4(ior->io_ColorMap, loop);
		cm->colorByte[PCMYELLOW] = temp2 & 0xf;
		cm->colorByte[PCMMAGENTA] = (temp2 >> 4) & 0xf;
		cm->colorByte[PCMCYAN] = (temp2 >> 8) & 0xf;
#if	DEBUG2
		kprintf("cm=%08lx, colorMap[%02ld]=%08lx\n", cm, loop, cm->colorLong);
#endif
		if (ior->io_Modes & EXTRA_HALFBRITE) {
			(cm + 32)->colorLong = (cm->colorLong >> 1) & 0x7f7f7f7f;
#if	DEBUG2
			kprintf("halfbright[%02ld]=%08lx\n", loop + 32,
				(cm + 32)->colorLong);
#endif
		}
		cm++;
	}

	/*
		At this point the colors are in rgb (ADDITIVE) form.  If we
		want them in ymc (!ADDITIVE) form then we need to convert them.
		If we want negative colors then we also need to convert them.
	*/
	mask = (PED->ped_ColorClass & PCC_ADDITIVE) ? 0x0 : 0x0f0f0f0f;
	mask ^= (PD->pd_Preferences.PrintImage == IMAGE_NEGATIVE) ?
		0x0f0f0f0f : 0x0;
	cm = PInfo.pi_ColorMap;
	for (loop=0; loop<temp1; loop++) {
		cm->colorLong ^= mask;
		if (ior->io_Modes & EXTRA_HALFBRITE) {
			(cm + 32)->colorLong ^= mask;
		}
#if DEBUG2
		kprintf("add/sub corrected[%02ld]=%08lx\n",
			loop, cm->colorLong);
		if (ior->io_Modes & EXTRA_HALFBRITE) {
			kprintf("halfbrite add/sub corrected[%02ld]=%08lx\n",
				loop + 32, (cm + 32)->colorLong);
		}
#endif
		cm++;
	}

	/* calculate black values (MUST BE DONE BEFORE CORRECTING COLORS) */
	cm = PInfo.pi_ColorMap;
	for (loop=0; loop<temp1; loop++) {
		/* calculate black values */
		GetBlack(cm, PInfo.pi_flags);
		if (ior->io_Modes & EXTRA_HALFBRITE) {
			GetBlack(cm + 32, PInfo.pi_flags);
		}
#if	DEBUG2
		kprintf("black corrected[%02ld]=%08lx\n", loop, cm->colorLong);
		if (ior->io_Modes & EXTRA_HALFBRITE) {
			kprintf("halfbrite black corrected[%02ld]=%08lx", loop + 32,
				(cm + 32)->colorLong);
		}
#endif
		cm++;
	}

	/* if want to fix color(s) and NOT in HAM mode and doing a color dump */
	if ((PInfo.pi_PrefsFlags & CORRECT_RGB_MASK) &&
		!(PInfo.pi_flags & PRT_HAM) &&
		(PD->pd_Preferences.PrintShade == SHADE_COLOR)) {
#if DEBUG0
		kprintf("fixing color map\n");
#endif
		FixColorMap(&PInfo);
	}

	PInfo.pi_xstart = xstart;
	PInfo.pi_ystart = ystart;
	PInfo.pi_width = PInfo.pi_tempwidth = width;
	PInfo.pi_height = height;

	/*
		Must round up to nearest multiple of 16 since ReadPixelLine
		works in 16 byte chunks.
	*/
	temp1 = (width + 15) & (~15);
	PInfo.pi_RowBufSize = temp1 * 2;
	if ((PInfo.pi_RowBuf = AllocMem(PInfo.pi_RowBufSize, MEMF_PUBLIC)) ==
		NULL) {
#if ALLOCDEBUG
		kprintf("couldn't get %ld bytes for RowBuf\n", PInfo.pi_RowBufSize);
#endif
		return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
	}
#if ALLOCDEBUG
	kprintf("got %ld bytes (%ld entries) for RowBuf @@ %lx-%lx\n",
		PInfo.pi_RowBufSize, temp1, PInfo.pi_RowBuf,
		PInfo.pi_RowBufSize + (UBYTE *)PInfo.pi_RowBuf - 1);
#endif

	PInfo.pi_pc = ulongpc + PInfo.pi_xpos;
	PInfo.pi_pr = ulongpr;

	/* if anti-aliasing , alloc TopBuf and BotBuf */
	if (PInfo.pi_PrefsFlags & ANTI_ALIAS) {
		if ((PInfo.pi_TopBuf = AllocMem(PInfo.pi_RowBufSize, MEMF_PUBLIC)) ==
			NULL) {
#if ALLOCDEBUG
			kprintf("couldn't get %ld bytes for TopBuf\n",
				PInfo.pi_RowBufSize);
#endif
			return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
		}
#if ALLOCDEBUG
		kprintf("got %ld bytes (%ld entries) for TopBuf @@ %lx-%lx\n",
			PInfo.pi_RowBufSize, temp1, PInfo.pi_TopBuf,
			PInfo.pi_RowBufSize + (UBYTE *)PInfo.pi_TopBuf - 1);
#endif
		if ((PInfo.pi_BotBuf = AllocMem(PInfo.pi_RowBufSize, MEMF_PUBLIC)) ==
			NULL) {
#if ALLOCDEBUG
			kprintf("couldn't get %ld bytes for BotBuf\n",
				PInfo.pi_RowBufSize);
#endif
			return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
		}
#if ALLOCDEBUG
		kprintf("got %ld bytes (%ld entries) for BotBuf @@ %lx-%lx\n",
			PInfo.pi_RowBufSize, temp1, PInfo.pi_BotBuf,
			PInfo.pi_RowBufSize + (UBYTE *)PInfo.pi_BotBuf - 1);
#endif
	}

	/* if floyd dithering or anti-aliasing, alloc Dest1Int */
	if (PInfo.pi_PrefsFlags & (FLOYD_DITHERING | ANTI_ALIAS)) {
		PInfo.pi_Dest1IntSize = (PInfo.pi_pc + 1) * sizeof(union colorEntry);
		if ((PInfo.pi_Dest1Int =
			AllocMem(PInfo.pi_Dest1IntSize, MEMF_PUBLIC|MEMF_CLEAR)) == NULL){
#if ALLOCDEBUG
			kprintf("couldn't get %ld bytes for Dest1Int\n",
				PInfo.pi_Dest1IntSize);
#endif
			return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
		}
#if ALLOCDEBUG
		kprintf("got %ld bytes (%ld entries) for Dest1Int @@ %lx-%lx\n",
			PInfo.pi_Dest1IntSize, PInfo.pi_pc + 1, PInfo.pi_Dest1Int,
			PInfo.pi_Dest1IntSize + (UBYTE *)PInfo.pi_Dest1Int - 1);
#endif
	}

	/* if floyd dithering, alloc Dest2Int */
	if (PInfo.pi_PrefsFlags & FLOYD_DITHERING) {
		PInfo.pi_Dest2IntSize = (PInfo.pi_pc + 1) * sizeof(union colorEntry);
		if ((PInfo.pi_Dest2Int =
			AllocMem(PInfo.pi_Dest2IntSize, MEMF_PUBLIC|MEMF_CLEAR)) == NULL){
#if ALLOCDEBUG
			kprintf("couldn't get %ld bytes for Dest2Int\n",
				PInfo.pi_Dest2IntSize);
#endif
			return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
		}
#if ALLOCDEBUG
		kprintf("got %ld bytes (%ld entries) for Dest2Int @@ %lx-%lx\n",
			PInfo.pi_Dest2IntSize, PInfo.pi_pc + 1, PInfo.pi_Dest2Int,
			PInfo.pi_Dest2IntSize + (UBYTE *)PInfo.pi_Dest2Int - 1);
#endif
	}

	PInfo.pi_ColorIntSize = width * sizeof(union colorEntry);
	if ((PInfo.pi_ColorInt = AllocMem(PInfo.pi_ColorIntSize, MEMF_PUBLIC)) ==
		NULL) {
#if ALLOCDEBUG
		kprintf("couldn't get %ld bytes for ColorInt\n",
			PInfo.pi_ColorIntSize);
#endif
		return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
	}
#if ALLOCDEBUG
	kprintf("got %ld bytes (%ld entries) for ColorInt @@ %lx-%lx\n",
		PInfo.pi_ColorIntSize, width, PInfo.pi_ColorInt,
		PInfo.pi_ColorIntSize + (UBYTE *)PInfo.pi_ColorInt - 1);
#endif
	/* if doing a HAM picture */
	if (PInfo.pi_flags & PRT_HAM) {
		if (!(PInfo.pi_flags & PRT_INVERT)) { /* if not inverted */
			PInfo.pi_HamIntSize = height * sizeof(union colorEntry);
			if ((PInfo.pi_HamInt = AllocMem(PInfo.pi_HamIntSize, MEMF_PUBLIC))
				== NULL) {
#if ALLOCDEBUG
				kprintf("couldn't get %ld bytes for HamInt\n",
					PInfo.pi_HamIntSize);
#endif
				return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
			}
#if ALLOCDEBUG
			kprintf("got %ld bytes (%ld entries) for HamInt @@ %lx-%lx\n",
				PInfo.pi_HamIntSize, height, PInfo.pi_HamInt,
				PInfo.pi_HamIntSize + (UBYTE *)PInfo.pi_HamInt - 1);
#endif
			temp1 = xstart;
		}
		else { /* inverted */
			temp1 = ystart;
		}
		if (temp1) { /* if not starting at left edge */
			/* allocate mem for left edge buffer */
			PInfo.pi_HamBufSize = temp1 * 2;
			if ((PInfo.pi_HamBuf = AllocMem(PInfo.pi_HamBufSize, MEMF_PUBLIC))
				== NULL) {
#if ALLOCDEBUG
				kprintf("couldn't get %ld bytes for HamBuf\n",
					PInfo.pi_HamBufSize);
#endif
				return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
			}
#if ALLOCDEBUG
			kprintf("got %ld bytes (%ld entries) for HamBuf @@ %lx-%lx\n",
				PInfo.pi_HamBufSize, temp1, PInfo.pi_HamBuf,
				PInfo.pi_HamBufSize + (UBYTE *)PInfo.pi_HamBuf - 1);
#endif
		}
		InitHamArray(&PInfo);
	}

	PInfo.pi_ScaleXSize = width * 2;
	if ((PInfo.pi_ScaleX = AllocMem(PInfo.pi_ScaleXSize, MEMF_PUBLIC)) ==
		NULL) {
#if ALLOCDEBUG
		kprintf("couldn't get %ld bytes for ScaleX\n",
			PInfo.pi_ScaleXSize);
#endif
		return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
	}
#if ALLOCDEBUG
	kprintf("got %ld bytes (%ld entries) for ScaleX @@ %lx-%lx\n",
		PInfo.pi_ScaleXSize, width, PInfo.pi_ScaleX,
		PInfo.pi_ScaleXSize + (UBYTE *)PInfo.pi_ScaleX - 1);
#endif
	buf1 = PInfo.pi_ScaleX;
	temp1 = width;
	temp2 = etx;
	do {
		*buf1++ = Scale(xmult, xmod, etx, &temp2);
	} while (--temp1);

	/* if floyd dithering or anti-aliasing or xreducing, alloc ScaleXAlt */
	if ((PInfo.pi_PrefsFlags & (FLOYD_DITHERING | ANTI_ALIAS)) || XReduce) {
		PInfo.pi_ScaleXAltSize = PInfo.pi_pc * 2;
		if ((PInfo.pi_ScaleXAlt = AllocMem(PInfo.pi_ScaleXAltSize,
			MEMF_PUBLIC)) == NULL) {
#if ALLOCDEBUG
			kprintf("couldn't get %ld bytes for ScaleXAlt\n",
				PInfo.pi_ScaleXAltSize);
#endif
			return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
		}
#if ALLOCDEBUG
		kprintf("got %ld bytes (%ld entries) for ScaleXAlt @@ %lx-%lx\n",
			PInfo.pi_ScaleXAltSize, width, PInfo.pi_ScaleXAlt,
			PInfo.pi_ScaleXAltSize + (UBYTE *)PInfo.pi_ScaleXAlt - 1);
#endif
		buf1 = PInfo.pi_ScaleXAlt;
		temp1 = PInfo.pi_pc;
		do {
			*buf1++ = 1;
		} while (--temp1);
	}
#if DEBUG0
	kprintf(
	"xstart,ystart=%ld,%ld, width,height=%ld,%ld, pc,pr=%ld,%ld, xpos=%ld\n",
	xstart, ystart, width, height, PInfo.pi_pc, PInfo.pi_pr, PInfo.pi_xpos);
	kprintf("flags=%lx, threshold=%ld, special=%lx, render=%lx\n",
		PInfo.pi_flags, PInfo.pi_threshold, PInfo.pi_special, PInfo.pi_render);
	kprintf("xmult=%ld, xmod=%ld, etx=%ld, ymult=%ld, ymod=%ld, ety=%ld\n",
		xmult, xmod, etx, PInfo.pi_ymult, PInfo.pi_ymod, PInfo.pi_ety);
#endif
#if TDEBUG
    tl1 = ReadVBlankTime();
#endif
	/* get render buf mem (do this last after all other mem allocations) */
#if DEBUG0
	kprintf("calling case 0 render (getting render buf mem)\n");
#endif DEBUG0
    /* the 5th parameter here is for V1.0 compatability */
	err = (*render)(ior, ulongpc + PInfo.pi_xpos, ulongpr, 0, ulongpc + PInfo.pi_xpos);
	/* case 0 (memory allocation) has been called */
	PInfo.pi_flags |= PRT_RENDER0;
	if (err != PDERR_NOERR) {
#if DEBUG0
		kprintf("case 0 render failed, calling Backout with err=%ld\n", err);
#endif DEBUG0
		return(Backout(err, ior, &PInfo));
	}
#if DEBUG0
	kprintf("calling case 3 render (clearing & initing render buf mem)..");
#endif DEBUG0
	(*render)(0, 0, 0, 3); /* clear & init render buffer */
#if DEBUG0
	kprintf("ok\n");
#endif DEBUG0

	temp1 = PCMYELLOW; /* assume starting at PCMYELLOW */
	temp2 = temp1 + 1; /* assume one pass */
	if (PED->ped_ColorClass & PCC_MULTI_PASS) { /* if multi-pass */
		if (PD->pd_Preferences.PrintShade == SHADE_COLOR) { /* if color */
			if (PED->ped_ColorClass == PCC_YMCB ||
				PED->ped_ColorClass == PCC_BGRW) { /* if 4 color */
				temp2 = temp1 + 4; /* must do 4 passes */
			}
			else {
				temp2 = temp1 + 3; /* must do 3 passes */
			}
		}
		else { /* if B&W or GreyScale */
			temp1 = PCMBLACK; /* must start at PCMBLACK */
			temp2 = temp1 + 1; /* one pass */
		}
	}

	if (PInfo.pi_ystart + PInfo.pi_height < maxrows) {
#if DEBUG0
		kprintf("PRT_BELOW: ystart=%ld, height=%ld, maxrows=%ld\n",
			PInfo.pi_ystart, PInfo.pi_height, maxrows);
#endif DEBUG0
		PInfo.pi_flags |= PRT_BELOW;
	}

	for (; temp1<temp2; temp1++) {
		FixScalingVars(&PInfo); /* necessary */
		width = PInfo.pi_width; /* re-init local var */
#if DEBUG0
		kprintf("temp1=%ld, TopBuf=%lx, RowBuf=%lx, BotBuf=%lx\n",
		temp1, PInfo.pi_TopBuf, PInfo.pi_RowBuf, PInfo.pi_BotBuf);
		kprintf("\tColorInt=%lx, Dest1Int=%lx, Dest2Int=%lx\n",
		PInfo.pi_ColorInt, PInfo.pi_Dest1Int, PInfo.pi_Dest2Int);
		kprintf("\tpi_width=%ld, pi_tempwidth=%ld, width=%ld\n",
			PInfo.pi_width, PInfo.pi_tempwidth, width);
#endif
		if (PInfo.pi_PrefsFlags & ANTI_ALIAS) {
			if (PInfo.pi_ystart != 0) {
#if DEBUG0
				kprintf("initing RowBuf to line ystart - 1\n");
#endif
				MyReadPixelArray(PInfo.pi_ystart - 1, &PInfo,
					PInfo.pi_RowBuf);
			}
			else {
#if DEBUG0
				kprintf("initing RowBuf to %lx\n", ~0);
#endif
				buf1 = PInfo.pi_RowBuf;
				/* invalidate RowBuf */
				do {
					*buf1++ = ~0;
				} while (--width);
			}
#if DEBUG0
			kprintf("initing BotBuf to line ystart\n");
#endif
			MyReadPixelArray(PInfo.pi_ystart, &PInfo,
				PInfo.pi_BotBuf);
		}
		/*
			after the above (in one of the four routines below):
				TopBuf <= RowBuf (which we just invalidated)
				RowBuf <= BotBuf (which we just read)
				BotBuf (will be read)
		*/

		if (YReduce && XReduce) {
#if DEBUG0
			kprintf("calling YRXR...");
#endif DEBUG0
			err = YReduceXReduce(&PInfo, temp1);
		}
		else if (YReduce) {
#if DEBUG0
			kprintf("calling YRXE...");
#endif DEBUG0
			err = YReduceXEnlarge(&PInfo, temp1);
		}
		else if (XReduce) {
#if DEBUG0
			kprintf("calling YEXR...");
#endif DEBUG0
			err = YEnlargeXReduce(&PInfo, temp1);
		}
		else {
#if DEBUG0
			kprintf("calling YEXE...");
#endif DEBUG0
			err = YEnlargeXEnlarge(&PInfo, temp1);
		}
#if DEBUG0
		kprintf("err=%ld\n", err);
#endif DEBUG0
		if (err) {
			break;
		}
		else {
			if (temp1 != temp2 - 1) { /* if NOT on last pass */
#if DEBUG0
				kprintf("calling case 6 render (switch to next color)\n");
#endif DEBUG0
				err = (*render)(0, 0, 0, 6); /* switch to next color */
			}
		}
	}
#if TDEBUG
    tl2 = t2 = ReadVBlankTime();
    if (t2 < t1) {
        t2 += 65536;
    }
    if (tl2 < tl1) {
        tl2 += 65536;
    }
    kprintf("PCDumpRPort: t2=%ld, t1=%ld, elapsed jiffies=%ld, secs=%ld\n",
        t2, t1, t2 - t1, (t2 - t1 + 30) / 60);
    kprintf("Loop: tl2=%ld, tl1=%ld, elapsed jiffies=%ld, secs=%ld\n",
        tl2, tl1, tl2 - tl1, (tl2 - tl1 + 30) / 60);
#endif
	return(Backout(err, ior, &PInfo)); /* return status */
}

roundit(number)
int number;
{
	return( (((number % 10) > 4) ? (number + 10) : number) / 10);
}

GetSpecialDensity(special)
ULONG *special;
{
	extern struct PrinterData *PD;

	static UWORD densities[8] = {
		0, SPECIAL_DENSITY1, SPECIAL_DENSITY2, SPECIAL_DENSITY3,
		SPECIAL_DENSITY4, SPECIAL_DENSITY5, SPECIAL_DENSITY6, SPECIAL_DENSITY7
	};
	UWORD temp;

	/* if user density settings override the application density settings */
	if (temp = densities[PD->pd_Preferences.PrintDensity]) {
		*special &= ~SPECIAL_DENSITYMASK; /* clear application settings */
		*special |= temp; /* get user settings */
	}
}
@


1.44
log
@Use GetBitMapAttr for V39 gfx or greater; for the future, and for
now (because of interleaved bitmaps).
@
text
@d527 1
a527 1
* 2. Drives all Nec 24-wire Pinwriter compatible printers.
@


1.43
log
@Remove reference to read pixel functions in debugging; would like
to use gfxbase functions instead
@
text
@d1029 7
d1045 6
d1542 7
d1656 5
@


1.42
log
@no more compiler warnings
@
text
@a829 2
	kprintf("ReadPixelLine=%lx, rp2rp=%lx, MyReadPixelArray=%lx\n",
		&ReadPixelLine(), &rp2rp(), &MyReadPixelArray());
@


1.41
log
@compiled native
@
text
@d785 1
a785 1
	int prefMax, MaxXDots, MaxYDots;
d840 1
a840 1
	ptr = &PInfo;
@


1.40
log
@First documentation re: European Ax paper size support.
@
text
@d5 2
a6 2
*								 
*   FUNCTION							 
d10 1
a10 1
*								 
d170 1
a170 1
*	than the printer can handle may result in unexpected, or 
d178 1
a178 1
*								 
d226 1
a226 1
* 
d247 1
a247 1
* 
d250 1
a250 1
* 
d252 1
a252 1
* 
d254 1
a254 1
* 
d258 1
a258 1
* 
d261 3
a263 3
* 
*     SendIO(ioreq);  send request 
*     Wait(signal);  wait for completion (go to sleep) 
d266 1
a266 1
* 
d268 1
a268 1
* 
d270 4
a273 4
* 
*     AbortIO(ioreq);  abort request 
*     WaitIO(ioreq);  wait for reply 
* 
d275 1
a275 1
* 
d280 1
a280 1
* 
d283 2
a284 2
* 
* 
d287 1
a287 1
* 
d293 2
a294 2
* 
* 
d298 1
a298 1
* 
d302 1
a302 1
* 
d312 1
a312 1
* 
d331 1
a331 1
* 
d337 1
a337 1
* 
d354 1
a354 1
* 
d358 1
a358 1
* 
d362 1
a362 1
* 
d370 1
a370 1
* 
d395 1
a395 1
* 
d409 1
a409 1
* 
d416 1
a416 1
*    paper width is 13.6 inches, so some European A sizes are too large 
d418 1
a418 1
* 
d436 1
a436 1
* 
d440 1
a440 1
* 
d452 1
a452 1
* 
d492 1
a492 1
* 
d498 1
a498 1
* 
d510 1
a510 1
* 
d523 1
a523 1
* 
d544 1
a544 1
* 
d550 1
a550 1
* 
d564 1
a564 1
* 
d571 1
a571 1
* 
d577 1
a577 1
* 
d581 1
a581 1
* 
d595 1
a595 1
* 
d615 1
a615 1
* 
d636 1
a636 1
* 
d658 1
a658 1
* 
d670 1
a670 1
* 
d684 1
a684 1
* 
d706 2
a707 2
* 
* 
d710 1
a710 1
* 
d713 1
a713 1
* 
d716 1
a716 1
* 
d725 2
d731 3
a733 2
#include <exec/memory.h>
#include <exec/errors.h>
d741 3
a743 1
#define DEBUG		0	/* debugging flag: 0-off, 1-on */
d800 1
d803 1
d805 2
a806 1
/*		12, 4, 11, 14, 8, 0, 3, 7, 6, 2, 1, 9, 14, 10, 5, 13 /* */
d809 1
a809 1
#if TDEBUG 
d858 1
a858 1
#if	DEBUG
d896 1
a896 1
		}	
d911 1
a911 1
		}	
d967 1
a967 1
#endif DEBUG
d979 1
a979 1
#if DEBUG
d981 1
a981 1
#endif DEBUG
d985 1
a985 1
#if DEBUG
d987 1
a987 1
#endif DEBUG
d1041 1
a1041 1
#if	DEBUG
d1043 1
a1043 1
#endif DEBUG
d1088 1
a1088 1
#if DEBUG
d1116 1
a1116 1
		}	
d1133 1
a1133 1
#if DEBUG
d1145 1
a1145 1
#if	DEBUG
d1149 1
a1149 1
#endif DEBUG
d1272 1
a1272 1
#if	DEBUG
d1285 1
a1285 1
#if	DEBUG
d1301 1
a1301 1
#if	DEBUG
d1307 1
a1307 1
#if	DEBUG
d1316 1
a1316 1
#if	DEBUG
d1324 1
a1324 1
#if DEBUG
d1331 1
a1331 1
#if	DEBUG
d1354 1
a1354 1
#if DEBUG
d1363 1
a1363 1
#if	DEBUG
d1388 1
a1388 1
#if DEBUG
d1401 1
a1401 1
#if DEBUG
d1408 1
a1408 1
#if	DEBUG
d1420 1
a1420 1
#if DEBUG
d1435 1
a1435 1
#if DEBUG
d1451 1
a1451 1
#if DEBUG
d1503 1
a1503 1
		
d1533 1
a1533 1
#if DEBUG
d1541 1
a1541 1
#if DEBUG
d1554 1
a1554 1
#if DEBUG
d1576 1
a1576 1
#endif DEBUG
d1597 1
a1597 1
#endif DEBUG
d1623 1
a1623 1
#endif DEBUG
d1628 1
a1628 1
#if DEBUG
d1643 1
a1643 1
#if DEBUG
d1646 1
a1646 1
#endif DEBUG
d1661 1
a1661 1
#endif DEBUG
d1727 1
a1727 1
#if DEBUG
d1925 1
a1925 1
#if DEBUG
d1934 1
a1934 1
#if TDEBUG 
d1938 1
a1938 1
#if DEBUG
d1940 1
a1940 1
#endif DEBUG
d1946 1
a1946 1
#if DEBUG
d1948 1
a1948 1
#endif DEBUG
d1951 1
a1951 1
#if DEBUG
d1953 1
a1953 1
#endif DEBUG
d1955 1
a1955 1
#if DEBUG
d1957 1
a1957 1
#endif DEBUG
d1978 1
a1978 1
#if DEBUG
d1981 1
a1981 1
#endif DEBUG
d1988 1
a1988 1
#if DEBUG
d1998 1
a1998 1
#if DEBUG
d2005 1
a2005 1
#if DEBUG
d2014 1
a2014 1
#if DEBUG
d2028 1
a2028 1
#if DEBUG
d2030 1
a2030 1
#endif DEBUG
d2034 1
a2034 1
#if DEBUG
d2036 1
a2036 1
#endif DEBUG
d2040 1
a2040 1
#if DEBUG
d2042 1
a2042 1
#endif DEBUG
d2046 1
a2046 1
#if DEBUG
d2048 1
a2048 1
#endif DEBUG
d2051 1
a2051 1
#if DEBUG
d2053 1
a2053 1
#endif DEBUG
d2059 1
a2059 1
#if DEBUG
d2061 1
a2061 1
#endif DEBUG
d2078 1
a2078 1
#endif 
@


1.39
log
@Autodoc stuff
@
text
@d156 22
d350 4
d390 5
d413 5
d463 10
a472 2
* 4. Maximum print area is 8.0 x 10.0 inches.
* 
d483 9
a491 1
* 4. Maximum print area is 8.0 x 10.0 inches.
d507 3
d539 5
@


1.38
log
@Spelling errors - fixed for AUTODOCS
@
text
@d4 1
a4 1
*	PRD_DUMPRPORT - dump the specified RastPort to a graphics printer.
@


1.37
log
@Use of ModeID under V36 now ignored if GfxBase->NormalDPMX/DPMY
have been changed from the defaults for NTSC or PAL.  Sadly we
have documented swizzling these values as allowable, along with
a more proper way of forcing an aspect ratio change.
@
text
@d21 1
a21 1
*			of graphics.libary, it is recommended that
d148 1
a148 1
*	the printer is in terms of pixels and bounded by the folllowing:
d161 1
a161 1
*	ONCE you have opended the printer device.  Here is a code fragment
d173 1
a173 1
*   open the printer device / if it opended...
d197 1
a197 1
* without having to run preferences (like DPAINT II's printer requestor),
d200 1
a200 1
* opened at this point).  After you have this you could put up a requestor
d270 1
a270 1
* contaminated with the other colors on the ribbon; you've been warned).
d286 1
a286 1
* 4. Densitie(s) supported are 203x200(1) dpi.
d296 1
a296 1
* 4. Densitie(s) supported are 203x200(1) dpi.
d314 1
a314 1
* 3. Densitie(s) supported are 83x84(1) dpi.
d343 1
a343 1
* 5. Densitie(s) supported are 120x120(1) dpi.
d363 1
a363 1
*    then you'll probably need to drop down to 16 pins.
d398 1
a398 1
* 6. Use this driver if the EpsonX driver doesn't work properly in graphics
d445 1
a445 1
* 3. Densitie(s) supported are 180x180(1) dpi.
d489 1
a489 1
* 3. Densitie(s) supported are 72x72 dpi.
d510 1
a510 1
* 4. Densitie(s) supported are 120x144(1) dpi.
d516 1
a516 1
* 3. Densitie(s) supported are 83x84(1) dpi.
d559 1
a559 1
* 2. Densitie(s) supported are 300x300(1) dpi
d571 1
a571 1
*    as recieved".
d573 1
a573 1
*    whithout resending by using the printers keypad.
@


1.36
log
@No change
@
text
@d715 1
d1126 5
d1133 12
a1144 2
		    modeID=ior->io_Modes;
		    if(modeID != INVALID_ID)
d1146 3
a1148 2
			/* validate ID */
			/* graphics lib knows what a good id is*/
d1150 3
a1152 1
			if(mode_handle=FindDisplayInfo(modeID))
d1154 2
a1155 4
			    if(GetDisplayInfoData(mode_handle,
				(UBYTE *)&dpinfo,
				sizeof(struct DisplayInfo),
				DTAG_DISP,modeID))
d1157 10
d1168 3
a1170 3
				kprintf("V36 Aspect ratio %ld : %ld\n",
					dpinfo.Resolution.x,
					dpinfo.Resolution.y);
d1172 4
a1175 2
				aspectX=(ULONG)dpinfo.Resolution.x;
				aspectY=(ULONG)dpinfo.Resolution.y;
@


1.35
log
@Modified text in docs to
use hardtabs - grrr... the
make doc procedure seems to have
backed out a space of my
spaces?  Weird.
@
text
@@


1.34
log
@Added documentation comments
of new technique for V36
graphics.library users.
@
text
@d21 3
a23 3
*                       of graphics.libary, it is recommended that
*                       you fill in "io_Modes" with the ULONG (32-bit)
*                       value returned from calling:
d25 1
a25 1
*                       ULONG ModeID = GetVPModeID(struct ViewPort *);
d27 4
a30 4
*                       Doing so provides for upwards compatability with
*                       the new display modes available under V36
*                       (example: aspect ratio calculations for new
*                        display modes).
@


1.33
log
@Added code to check for V36 graphics library,
if found, attempt to treat io_Modes as a modeid
as returned by GetVPModeID().  If this
checks out as a valid mode id, we get
aspect ratio info from graphics.library.
This allows compatability with new graphics modes.
@
text
@d19 13
@


1.32
log
@Turn debug info off again.
@
text
@d654 2
d670 1
d678 1
d695 8
d1088 1
d1090 2
d1102 35
@


1.31
log
@Turn debugging on - problem
reported with aspect ration when
in 1280x400 mode.
@
text
@d663 5
a667 5
#define DEBUG		1	/* debugging flag: 0-off, 1-on */
#define DEBUG2		1	/* more debugging (list of colors, etc.) */
#define ALLOCDEBUG	1	/* debugging of allocated memory */
#define TDEBUG		1	/* time debugging */
#define SDEBUG		1	/* display symbols */
@


1.30
log
@changed '"../intuition.h"' to '<intuition/intuition.h>'
@
text
@d663 5
a667 5
#define DEBUG		0	/* debugging flag: 0-off, 1-on */
#define DEBUG2		0	/* more debugging (list of colors, etc.) */
#define ALLOCDEBUG	0	/* debugging of allocated memory */
#define TDEBUG		0	/* time debugging */
#define SDEBUG		0	/* display symbols */
@


1.29
log
@for rcs 4.x header change
@
text
@d652 1
a652 1
#include "../intuition.h"
@


1.28
log
@added some debugging
@
text
@@


1.27
log
@added a call to FixScalingVars and re-inited 'width' at the top of the
MULTI_PASS loop.  This fixes the bug whiched caused a crash whenever
smoothing was turned on with a PCC_MULTI_PASS type printer.  Currently
these are the ColorMaster and Seiko_5300.
This change was made AFTER the offical V1.3 release which is 35.562.
@
text
@d663 5
a667 4
#define DEBUG	0	/* debugging flag: 0-off, 1-on */
#define DEBUG2	0	/* more debugging (list of colors, etc.) */
#define TDEBUG	0	/* time debugging */
#define SDEBUG	0	/* display symbols */
d1406 1
a1406 1
#if DEBUG
d1412 1
a1412 1
#if DEBUG
d1427 1
a1427 1
#if DEBUG
d1433 1
a1433 1
#if DEBUG
d1454 1
a1454 1
#if DEBUG
d1459 1
a1459 1
#if DEBUG
d1492 1
a1492 1
#if DEBUG
d1498 1
a1498 1
#if DEBUG
d1586 1
a1586 1
#if DEBUG
d1591 1
a1591 1
#if DEBUG
d1604 1
a1604 1
#if DEBUG
d1610 1
a1610 1
#if DEBUG
d1617 1
a1617 1
#if DEBUG
d1623 1
a1623 1
#if DEBUG
d1635 1
a1635 1
#if DEBUG
d1641 1
a1641 1
#if DEBUG
d1653 1
a1653 1
#if DEBUG
d1659 1
a1659 1
#if DEBUG
d1669 1
a1669 1
#if DEBUG
d1675 1
a1675 1
#if DEBUG
d1686 1
a1686 1
#if DEBUG
d1692 1
a1692 1
#if DEBUG
d1707 1
a1707 1
#if DEBUG
d1713 1
a1713 1
#if DEBUG
d1725 1
a1725 1
#if DEBUG
d1731 1
a1731 1
#if DEBUG
d1748 1
a1748 1
#if DEBUG
d1754 1
a1754 1
#if DEBUG
@


1.26
log
@updated autodoc for Tektronix_4693D driver
@
text
@d1825 10
a1834 1

@


1.25
log
@made changes to autodoc(s)
@
text
@d520 2
a521 2
* 4. This driver is not on the Workbench or Extras disk.  It is available
*    on BIX and directly from Seiko.
d540 2
a541 2
* 5. This driver is not on the Workbench or Extras disk.  It is available
*    on BIX and directly from Seiko.
d544 1
a544 1
* ----------------
d549 2
a550 2
* 	a)Aspect - Horizontal, Vertical
* 	b)Shade - B&W, Grey_Scale, Color
d552 11
a562 2
* 4. This driver is not on the Workbench or Extras disk.  It is available
*    on BIX and directly from Tektronix.
d581 2
a582 2
* 4. This driver is not on the Workbench or Extras disk.  It is available
*    on BIX and directly from Tektronix.
@


1.24
log
@changed autodocs
V1.3 Gamma 20
@
text
@d1 1
a1 1
/****** printer.device/DumpRPort *************************************
d4 1
a4 1
*	DumpRPort - dump the specified RastPort to a graphics printer.
d755 1
a755 1
	kprintf("PCDumpRPort: enter\n");
@


1.23
log
@V1.3 Gamma 16
@
text
@d249 1
a252 1
* 
d274 3
d283 5
a287 1
* 4. This driver is the same as the Calcomp_ColorMaster driver EXCEPT it is
d291 5
a295 3
*    require 730,767 bytes.  The memory requirements are 1/3 when doing a
*    non-color printout.
* 6. Densitie(s) supported are 203x200(1) dpi.
d308 1
a308 1
* 	1	120	72	 8640
d310 1
a310 1
* 	3	240	72	17280			*1
d338 1
a338 1
* 	1	90	180	16200
d352 2
a353 2
* EpsonX (8/9-pin Epson compatible)
* ------
d358 1
a358 1
* 	1	120	72	 8640
d360 1
a360 1
* 	3	240	72	17280			*1
d396 2
a397 2
* 3. Density      XDPI    YDPI    XYDPI   Comments
* 	1	80	80	 6400
d408 2
a409 2
* 3. Density      XDPI    YDPI    XYDPI   Comments
* 	1	75	75	 5625
d420 2
a421 2
* 3. Density      XDPI    YDPI    XYDPI   Comments
* 	1	75	75	 5625
d438 2
a439 2
* 3. Density      XDPI    YDPI    XYDPI   Comments
* 	1	96	96	 9216
d448 4
a451 4
* 	1	80	72	 5760
* 	2	120	72	 8640
* 	3	144	72	10368
* 	4	160	72	11520
d462 1
a462 1
* 	1	90	180	 16200
d521 20
@


1.22
log
@V1.3 Gamma 15
@
text
@d473 1
a473 1
* 3. Linefeeds # of vertical dots printed (-1/3 dot if PaperType = Single) *2
d537 6
a542 6
*    vibrate colors and gives the illusion of more resolution.  One drawback is
*    that large areas of solid colors (red, green, and blue specifically) tend
*    to over-saturate the paper with ink.  Density1 outputs all colors in one
*    pass.  Density 2 does a double pass on black.  Density 3 does a double
*    pass on all colors.  Density 1 to 3 correspond to the printer's graphics
*    printing modes 1 to 3 (respectively).
d603 2
a604 2
* *1 - in this mode the printer cannot print two consecutive dots in a row.  It
*      is recommended that you only use this density for B&W Shade dumps.
d606 5
a610 2
* *2 - only when 72 YDPI is selected.  This option is useful if you notice tiny
*      white horizontal strips in your printout.
@


1.21
log
@fixed logic to handle computations > 32 bits in in some areas.
V1.3 Gamma 14
@
text
@d252 1
d282 1
a282 1
*    memory (up to ~1,272,003 bytes for a full 8 x 10 inch (1600 x 2000 dot)
d284 1
a284 1
*    require ~730,767 bytes.  The memory requirements are 1/3 when doing a
d296 1
a296 1
* 1. Dot matrix non-color printer (text and graphics).
d363 1
a363 1
* 1. Dot matrix b&w/color printer (text and graphics).
d367 7
a373 3
* 	1	120	72	 8640
* 	2	240	72	17280	*1
* 	3,4,5,6,7	same as 2
d377 1
a377 1
*    mode on your EpsonX compatible printer.
d500 16
a515 2
* Tektronics_4693D
* ----------------
d524 1
a524 1
*    on BIX and from Tektronics.
d526 22
d590 1
a590 1
*    of more resulution.  One drawback is that large areas of solid colors
d603 2
a604 2
* *1 - in this mode the printer cannot print two consecutive dots in a row.
*      It is recommended that you only use this density for B&W Shade dumps.
d606 2
a607 2
* *2 - only when 72 YDPI is selected.  This option is useful if you notice
*      tiny white horizontal strips in your printout.
d632 1
d1297 1
a1297 1
		ior->io_DestCols = ulongpc;
d1338 1
a1338 1
		if (!TestChip(rp->BitMap->Planes[loop])) {
d1750 1
a1750 1
	kprintf("calling case 3 render (clearing & initing render buf mem)\n");
d1753 3
d1817 3
d1823 3
d1829 3
d1835 3
d1840 3
@


1.20
log
@changed autodocs for Tektronics_4693D
V1.3 Gamma 13
@
text
@d601 1
a601 1
	ULONG ulong1, ulong2, ulong3, ulong4;
d704 1
a704 1
		kprintf("FRACCOLS ");
d942 2
a943 1
		since this is a special case which means use the maximum height.
d945 1
a945 1
	maxY = (PrefsMaxHeight && (PrefsMaxHeight < MaxYDots)) ?
d948 3
a950 2
		If maxY is 0 then the printer has no maximum height.  So we chose an
		arbitrary large number (100 feet) for the maximum height.
d974 4
a977 4
		The following is a known bug/feature!  Technically, special must
		be zero along with pc or pr to enable aspecting.  However, some
		software packages assume that this bug is a feature so I cannot
		fix it.  Arrgh!
d1045 10
d1056 1
a1056 1
		pc = (pc * XDotsInch + 500) / 1000;
d1058 1
a1058 1
		kprintf("milcorrected pc=%ld\n", pc);
d1062 1
a1062 1
		pr = (pr * YDotsInch + 500) / 1000;
d1064 1
a1064 1
		kprintf("milcorrected pr=%ld\n", pr);
d1069 3
a1071 3
/*	if ((special == 0 && pc == 0) || (special & SPECIAL_FULLCOLS)) {
*/	if (pc == 0 || (special & SPECIAL_FULLCOLS)) {
		pc = maxX;
d1073 1
a1073 1
		kprintf("full corrected pc=%ld\n", pc);
d1077 5
a1081 5
		pc = ((ULONG) pc) >> 15;
		pc++;
		pc = ((pc >> 1) * maxX) >> 16;
#if	DEBUG
		kprintf("frac corrected pc=%ld\n", pc);
d1084 3
a1086 3
/*	if ((special == 0 && pr == 0) || (special & SPECIAL_FULLROWS)) {
*/	if (pr == 0 || (special & SPECIAL_FULLROWS)) {
		pr = maxY;
d1088 1
a1088 1
		kprintf("full corrected pr=%ld\n", pr);
d1092 21
a1112 5
		pr = ((ULONG) pr) >> 15;
		pr++;
		pr = ((pr >> 1) * maxY) >> 16;
#if	DEBUG
		kprintf("frac corrected pr=%ld\n", pr);
d1116 1
a1116 1
	/* else use pr & pc as absolute values */
d1123 7
a1129 3
			The '/ 8' is a massive KLUDGE so that we do not overrun
			ulong1 & ulong2.  In the future this should be changed
			so that calculations are stored in a 64-bit result.
d1131 14
a1144 5
		ulong3 = (width * aspectX * XDotsInch + 4) / 8;
		ulong4 = (height * aspectY * YDotsInch + 4) / 8;
		ulong1 = pr * ulong3;
		ulong2 = pc * ulong4;
#if	DEBUG
d1151 2
d1155 4
a1158 4
			/* diminish pr to correct aspect ratio */
			pr = ulong2 / ulong3;
#if	DEBUG
			kprintf("aspect corrected pr=%ld\n", pr);
d1162 2
a1163 2
			/* diminish pc to correct aspect ratio */
			pc = ulong1 / ulong4;
d1165 1
a1165 1
			kprintf("aspect corrected pc=%ld\n", pc);
d1177 1
a1177 1
		kprintf("INTEGER: pc=%ld, width=%ld, ", pc, width);
d1179 2
a1180 2
		if (pc < width) {
			pc = width;
d1183 1
a1183 1
			temp1 = pc % width;
d1185 1
a1185 1
				pc -= temp1;
d1188 1
a1188 1
				pc += width - temp1;
d1192 2
a1193 2
		kprintf("CORRECTED pc=%ld\nINTEGER: pr=%ld, height=%ld, ",
			pc, pr, height);
d1195 2
a1196 2
		if (pr < height) {
			pr = height;
d1199 1
a1199 1
			temp1 = pr % height;
d1201 1
a1201 1
				pr -= temp1;
d1204 1
a1204 1
				pr += height - temp1;
d1208 1
a1208 1
		kprintf("CORRECTED pr=%ld\n", pr);
d1212 4
a1215 3
		If the printer's maximum width is not 0 and the requested number of
		print columns (pc) is greater then the printer's maximum width,
		then set pc to the printer's maximum width.
d1217 2
a1218 2
	if (MaxXDots && (pc > MaxXDots)) {
		pc = MaxXDots;
d1221 3
a1223 3
		If the printer's maximum height is not 0 and the requested number of
		print rows (pr) is greater then the printer's maximum height,
		then set pr to the printer's maximum height.
d1225 2
a1226 2
	if (MaxYDots && (pr > MaxYDots)) {
		pr = MaxYDots;
d1230 1
a1230 1
		At this point 'pc' is at its final value so it is safe to
d1235 1
a1235 1
		PInfo.pi_xpos = (PED->ped_MaxXDots - pc + 1) / 2;
d1242 2
a1243 2
			if (PrefsXOffset + pc > PED->ped_MaxXDots) {
				PrefsXOffset = PED->ped_MaxXDots - pc;
d1250 3
a1252 2
		At this point 'pc' and 'pr' are at their final value.  If 'NOPRINT'
		is selected, then we return these values to the calling program.
d1255 2
a1256 2
		ior->io_DestCols = pc;
		ior->io_DestRows = pr;
d1261 4
a1264 4
	if (YReduce = (height > pr)) { /* if Y REDUCTION */
		PInfo.pi_ymult = height / pr;
		PInfo.pi_ymod = height % pr;
		PInfo.pi_ety = pr;
d1267 2
a1268 2
		PInfo.pi_ymult = pr / height;
		PInfo.pi_ymod = pr % height;
d1273 4
a1276 4
	if (XReduce = (width > pc)) { /* if X REDUCTION */
		xmult = width / pc;
		xmod = width % pc;
		etx = pc;
d1279 2
a1280 2
		xmult = pc / width;
		xmod = pc % width;
d1513 2
a1514 2
	PInfo.pi_pc = pc + PInfo.pi_xpos;
	PInfo.pi_pr = pr;
d1698 1
a1698 1
	err = (*render)(ior, pc + PInfo.pi_xpos, pr, 0, pc + PInfo.pi_xpos);
@


1.19
log
@changed autodocs
V1.3 Gamma 11 release
@
text
@d504 2
@


1.18
log
@
added code to read line above and below dump area during aliased prints
V1.3 Gamma 11 release
@
text
@d299 1
a299 1
* 	2	120	108	12960	two pass
d301 2
a302 2
* 	4	240	108	25920	two pass	*1
* 	5	120	216	25920	three pass
d349 1
a349 1
* 	2	120	108	12960	two pass
d351 2
a352 2
* 	4	240	108	25920	two pass	*1
* 	5	120	216	25920	three pass
@


1.17
log
@V1.3 Gamma 10 release
@
text
@d1683 8
d1694 1
d1696 1
a1696 2
			kprintf("setting %ld words in RowBuf to %lx for ANTI_ALIAS\n",
				width, ~0);
d1698 18
a1715 6
			buf1 = PInfo.pi_RowBuf;
			/* invalidate RowBuf */
			do {
				*buf1++ = ~0;
			} while (--width);
			MyReadPixelArray(PInfo.pi_ystart, &PInfo, PInfo.pi_BotBuf);
@


1.16
log
@fixed bug which caused a div0 error if the source width/height were < 8.
V1.3 Gamma 9 release
@
text
@d18 7
a24 7
*			the upper word is reserved and should be zero.
*	io_SrcX		the x offset into the RastPort to start printing from.
*	io_SrcY		the y offset into the RastPort to start printing from.
*	io_SrcWidth	the width of the RastPort to print (from io_SrcX).
*	io_SrcHeight	the height of the RastPort to print (from io_SrcY).
*	io_DestCols	the width of the printout in printer pixels.
*	io_DestRows	the height of the printout in printer pixels.
d197 1
a201 1
* PaperLength        - 1 to 999.
d210 1
a210 1
* PrintDensity       - 0 to 7.
d249 2
a250 3
*
* V1.3 Printer Driver Notes
* -------------------------
d252 7
d272 1
a272 2
* 4. 'SPECIAL_NOFORMFEED' option implemented.
* 5. Densitie(s) supported are 203x200(1) dpi.
d279 7
a285 8
* 4. 'SPECIAL_NOFORMFEED' option implemented.
* 5. This driver is the same as the Calcomp_ColorMaster driver EXCEPT it is
*    approximately 2 times faster (during color dumps) and requires LOTS
*    of memory (up to ~1,272,003 bytes for a full 8.5 x 11 inch
*    (1600 x 2000 dot) color dump).  Typically full-size (color) dumps are
*    1600 x 1149 dots and require ~730,767 bytes.  The memory requirements
*    are 1/3 when doing a black&white or greyscale printout.
* 5. Densitie(s) supported are 203x200(1) dpi.
d296 9
a304 4
* 2. Linefeeds # of vertical dots printed (-1/3 dot if PaperType = Single).
* 3. Densities supported are 120x72(1) and 240x72(2) dpi.
* 4. A PaperSize of 'Wide Tractor' selects a maximum print width of
*    13.6 inches (just in case we bring out a wide tractor printer).
d327 6
a332 2
* 4. Densities supported are 90x180(1), 120x180(2), 180x180(3)
*    and 360x180(4) dpi.
d338 3
a340 1
*    continuously.
d346 10
a355 2
* 3. Linefeeds # of vertical dots printed (-1/3 dot if PaperType = Single).
* 4. Densities supported are 120x72(1) and 240x72(2) dpi.
d358 1
a358 1
* 6. Use this driver if you own a CBM_MPS-1250 (since it is EpsonX compatible).
d360 14
d378 12
d394 7
a400 4
* 3. Densities supported are 75x75(1), 100x100(2), 150x150(3)
*    and 300x300(4) dpi.
* 4. 'SPECIAL_NOFORMFEED' option implemented.
* 5. Maximum print area is 8.0 x 10.0 inches.
d406 7
a412 4
* 3. Densities supported are 75x75(1), 100x100(2), 150x150(3)
*    and 300x300(4) dpi.
* 4. 'SPECIAL_NOFORMFEED' option implemented.
* 5. Maximum print area is 8.0 x 10.0 inches.
d420 9
d433 8
a440 2
* 3. Densities supported are 80x72(1), 96x72(2), 107x72(3), 120x72(4),
*    136x72(5), 144x72(6) & 160x72(7) dpi.
d447 8
a454 2
* 4. Densities supported are 90x180(1), 120x180(2), 180x180(3), 120x360(4),
*    180x360(5), 360x180(6), and 360x360(7).
d468 7
a474 2
* 3. Linefeeds # of vertical dots printed (-1/3 dot if PaperType = Single)
* 4. Densities supported are 120x72(1) and 240x72(2) dpi.
d485 6
d495 10
d510 4
a513 1
* 4. Densities supported are 180x180(1) and 360x180(2) dpi.
d517 14
d552 13
@


1.15
log
@V1.3 Gamma 8 release
@
text
@d3 1
a3 1
*	NAME
d12 66
a77 60
*	io_Message   mn_ReplyPort set if quick I/O is not possible.
*	io_Command   PRD_DUMPRPORT.
*	io_Flags     IOB_QUICK set if quick I/O is possible.
*	io_RastPort	 ptr to a RastPort.
*	io_ColorMap	 ptr to a ColorMap.
*	io_Modes	 the 'modes' flag from a ViewPort structure,
*			     the upper word is reserved and should be zero.
*	io_SrcX		 the x offset into the RastPort to start printing from.
*	io_SrcY		 the y offset into the RastPort to start printing from.
*	io_SrcWidth	 the width of the RastPort to print (from io_SrcX).
*	io_SrcHeight the height of the RastPort to print (from io_SrcY).
*	io_DestCols	 the width of the printout in printer pixels.
*	io_DestRows	 the height of the printout in printer pixels.
*	io_Special	 flag bits (some of which pertain to DestCols and DestRows).
*			-    if SPECIAL_MIL is set, then the associated
*			     parameter is specified in thousandths of
*			     an inch on the printer.  ie. if DestCols = 8000,
*			     DestRows = 10500 and SPECIAL_MILROWS and SPECIAL_MILCOLS
*			     is set then the printout would be 8.000 x 10.500 inches.
*			-    if SPECIAL_FULL is set, then the specific dimension
*			     is set to the maximum possible as determined
*			     by the printer limits or the configuration
*			     limits; whichever is less.
*			-    if SPECIAL_FRAC is set, the parameter is
*			     taken to be a longword binary fraction
*			     of the maximum for that dimension.
*			-    if all bits for a dimension are clear,
*			     (ie. SPECIAL MIL/FULL/FRAC and ASPECT are NOT set)
*			     then the parameter is specified in printer pixels.
*			-    if SPECIAL_CENTER is set then the image will be centered
*				 between the left and right edge of the paper.	
*			-    if SPECIAL_ASPECT is set, one of the dimensions
*			     may be reduced/expanded to preserve the aspect
*			     ratio of the print.
*			-    SPECIAL_DENSITY(1-7) this allows for a maximum of 7
*                different print densities.  DENSITY1 is the lowest density
*                and the default.
*           -    SPECIAL_NOFORMFEED - this allows for the mixing of text and 
*                graphics or multiple graphic dumps on page oriented printers
*                (usually laser jet printers).  When this flag is set the
*                page will not be ejected after a graphic dump.  If you
*                perform another graphic dump without this flag set OR close
*                the printer after printing text after a graphic dump, the 
*                page will be ejected.
*			-	 if SPECIAL_TRUSTME is set then the printer specific driver
*				 is instructed to not issue a reset command before and after
*				 the dump.  If this flag is NOT checked by the printer
*                specific driver then setting this flag has no effect.  Since
*                we now recommend that printer driver writers no longer issue
*                a reset command it is probably a safe idea to always set
*                this flag when calling for a dump.
*			-    if SPECIAL_NOPRINT is set then the following is performed:
*				 Compute print size, set 'io_DestCols' and 'io_DestRows' in
*				 the calling program's 'IODRPReq' structure and exit,
*				 DON'T PRINT.  This allows the calling program to see what
*				 the final print size would be in printer pixels.  Note that
*				 it modifies the 'io_DestCols' and 'io_DestRows' fields of
*				 your 'IODRPReq' structure.  It also sets the print density
*                and updates the 'MaxXDots', 'MaxYDots', 'XDotsInch', and
*				 'YDotsInch' fields of the 'PrinterExtendedData' structure.
d184 5
a188 5
* without having to run preferences (like DPAINT II's printer requestor), here
* is what you do.  You can look at the printer's copy of preferences by
* referring to 'PD->pd_Preferences' (the printer device MUST already be opened
* at this point).  After you have this you could put up a requestor and allow
* the user to change whatever parameters they wanted.
d267 1
d281 1
d287 1
d293 3
a295 3
* 3. Densities supported are 120(1) and 240(2) dpi.
* 4. A PaperSize of 'Wide Tractor' selects a maximum print width of 13.6 inches
*    (just in case we bring out a wide tractor printer).
d309 3
a311 2
* 3. A PaperSize of 'Wide Tractor' selects a maximum print width of 8.5 inches
*    (for wide roll paper).
d314 1
a314 1
* --------------------------------
d318 4
a321 3
* 4. Densities supported are 90(1), 120(2), 180(3) and 360(4) dpi.
* 5. A PaperSize of 'Wide Tractor' selects a maximum print width of 13.6 inches
*    (for wide carriage printers).
d332 4
a335 3
* 4. Densities supported are 120(1) and 240(2) dpi.
* 5. A PaperSize of 'Wide Tractor' selects a maximum print width of 13.6 inches
*    (for wide carriage printers).
d345 2
a346 1
* 3. Densities supported are 75(1), 100(2), 150(3) and 300(4) dpi.
d351 1
a351 1
* --------------------------------------------------
d354 2
a355 1
* 3. Densities supported are 75(1), 100(2), 150(3) and 300(4) dpi.
d363 1
d366 1
a366 1
* ---------------------------------------
d369 2
a370 2
* 3. Densities supported are 80(1), 96(2), 107(3), 120(4),
*    136(5), 144(6) & 160(7) dpi.
d372 10
d386 1
d393 3
a395 3
* 4. Densities supported are 120(1) and 240(2) dpi.
* 5. A PaperSize of 'Wide Tractor' selects a maximum print width of 13.6 inches
*    (for wide carriage printers).
d402 1
d408 9
d436 2
a437 2
* 5. A PaperSize of 'Wide Tractor' selects a maximum print width of 9.0 inches
*    (for wide roll paper).
d966 3
a968 3
			The '>> 3' is a massive KLUDGE so that we do not overrun
			the ulongs.  In the future this should be changed so that
			calculations are stored in a 64-bit result.
d970 2
a971 4
		ulong3 = width >> 3;
		ulong4 = height >> 3;
		ulong3 = ulong3 * aspectX * XDotsInch;
		ulong4 = ulong4 * aspectY * YDotsInch;
@


1.14
log
@fixed negative imaging for RGB type printers
V1.3 Gamma 8 release
@
text
@@


1.13
log
@V1.3 Gamma 8 release
@
text
@d243 160
d449 1
a449 1
	ULONG special;
d1230 2
a1231 2
		want YMC (!ADDITIVE) colors and we are not negating (!NEGATIVE)
		the YMC colors, then convert the RGB colors to YMC.
d1233 16
a1248 14
	if (!(PED->ped_ColorClass & PCC_ADDITIVE) &&
		!(PD->pd_Preferences.PrintImage == IMAGE_NEGATIVE)) {
		cm = PInfo.pi_ColorMap;
		for (loop=0; loop<temp1; loop++) {
			cm->colorLong ^= 0x0f0f0f0f;
			if (ior->io_Modes & EXTRA_HALFBRITE) {
				(cm + 32)->colorLong ^= 0x0f0f0f0f;
			}
#if	DEBUG2
			kprintf("add/sub corrected[%02ld]=%08lx\n", loop, cm->colorLong);
			if (ior->io_Modes & EXTRA_HALFBRITE) {
				kprintf("halfbrite add/sub corrected[%02ld]=%08lx\n",
					loop + 32, (cm + 32)->colorLong);
			}
d1250 1
a1250 2
			cm++;
		}
@


1.12
log
@fixed up autodocs
@
text
@d245 1
a245 1
#include <intuition/intuition.h>
d297 7
a303 3
	static UBYTE dmatrix[32] = {
		0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 14, 7, 13, 5,	/* ordered */
		12, 4, 11, 14, 8, 0, 3, 7, 6, 2, 1, 9, 14, 10, 5, 13	/* halftone */
d476 3
d482 3
d1326 2
a1327 2
	kprintf("getting render buf mem\n");
#endif
d1333 3
d1339 2
a1340 2
	kprintf("clearing and initing render buf mem\n");
#endif
d1399 3
@


1.11
log
@V1.3 Gamma 7 release
@
text
@d58 5
a62 1
*				 the dump.
d138 3
d174 69
@


1.10
log
@added ScaleX logic
V1.3 Gamma 7 release
@
text
@d169 1
a169 1
#include "../intuition.h"
@


1.9
log
@fixed half-brite mode crash bug
V1.3 Gamma 6 release
@
text
@d203 2
a204 1
	UWORD *buf1;
d253 2
a254 1
	kprintf("PD=%lx, PED=%lx, render=%lx\n", PD, PED, PED->ped_Render);
a401 1
	PInfo.pi_scale = Scale;
d820 3
a822 3
		PInfo.pi_xmult = PInfo.pi_tempxmult = width / pc;
		PInfo.pi_xmod = PInfo.pi_tempxmod = width % pc;
		PInfo.pi_etx = PInfo.pi_tempetx = pc;
d825 3
a827 3
		PInfo.pi_xmult = PInfo.pi_tempxmult = pc / width;
		PInfo.pi_xmod = PInfo.pi_tempxmod = pc % width;
		PInfo.pi_etx = PInfo.pi_tempetx = width;
d880 2
d1061 1
d1091 1
d1109 1
d1182 4
d1187 40
d1233 1
a1233 2
		PInfo.pi_xmult, PInfo.pi_xmod, PInfo.pi_etx,
		PInfo.pi_ymult, PInfo.pi_ymod, PInfo.pi_ety);
@


1.8
log
@V1.3 Gamma 5 release
@
text
@d248 4
d396 1
a396 1
	if (err = (*render)(0, special, 0, 5, special)) {
d937 4
@


1.7
log
@fixed bug which had the memory allocation backwards for ham prints
with a non-zero xstart or ystart.
fixed big which didn't allocate enough memory for temprp on certain
ham dumps.  temprp size is now the max of maxcols and maxrows.
margins and page length were bounding specific width/height prints.
V1.3 Gamma 5 release
@
text
@d675 3
d683 4
a686 4
		XDotsInch >>= 3;
		YDotsInch >>= 3;
		ulong3 = width * aspectX * XDotsInch;
		ulong4 = height * aspectY * YDotsInch;
d689 8
@


1.6
log
@moved special density code to separate GetSpecialDensity routine
V1.3 Gamma 4 release
@
text
@d181 1
a181 1
#define DEBUG2	0	/* more debugging */
d183 1
d208 1
a208 1
	int prefMax, prtMax;
d230 20
d460 2
a461 1
	prtMax = PED->ped_MaxXDots;
d473 1
a473 1
	else {
d492 2
a493 2
	maxX =
		(PrefsMaxWidth && (PrefsMaxWidth < prtMax)) ? PrefsMaxWidth : prtMax;
d495 2
a496 2
	kprintf("prtMax=%ld, PrefsMaxWidth=%ld, maxX=%ld\n",
		prtMax, PrefsMaxWidth, maxX);
d500 2
a501 1
	prtMax = PED->ped_MaxYDots;
d513 1
a513 1
	else {
d528 2
a529 2
	maxY =
	  (PrefsMaxHeight && (PrefsMaxHeight < prtMax)) ? PrefsMaxHeight : prtMax;
d538 2
a539 2
	kprintf("prtMax=%ld, PrefsMaxHeight=%ld, maxY=%ld\n",
		prtMax, PrefsMaxHeight, maxY);
d545 2
a546 2
		pc = PrefsMaxWidth;
		pr = PrefsMaxHeight;
d744 3
a746 2
		If the maximum width is not 0 and the requested number of print cols
		(pc) is greater then the maximum width, then set pc to the max.
d748 2
a749 2
	if (maxX && (pc > maxX)) {
		pc = maxX;
d752 3
a754 2
		If the maximum height is not 0 and the requested number of print rows
		(pr) is greater then the maximum height, then set pr to the max.
d756 2
a757 2
	if (maxY && (pr > maxY)) {
		pr = maxY;
d859 1
a859 1
		kprintf("depth=%ld, allocated %ld bytes for rp @@ %lx-%lx\n",
d864 1
a864 1
		PInfo.pi_temprp->BitMap = NULL; /* havnt allocated this yet */
d878 1
a878 1
		kprintf("allocated %ld bytes for bm @@ %lx-%lx\n",
d883 1
a883 1
		/* have not allocated these yet */
d887 6
a892 1
		temp1 = ((width + 15) / 16) * 2; /* calculate # of BytesPerRow */
d904 1
a904 1
		kprintf("allocated %ld bytes for Planes[0] @@ %lx-%lx\n",
d939 2
a940 2
	kprintf("allocated %ld bytes for ColorMap @@ %lx-%lx\n",
		temp2, cm, temp2 + (UBYTE *)cm - 1);
d1031 2
a1032 2
	kprintf("allocated %ld bytes for RowBuf @@ %lx-%lx\n",
		PInfo.pi_RowBufSize, PInfo.pi_RowBuf,
d1049 2
a1050 2
		kprintf("allocated %ld bytes for TopBuf @@ %lx-%lx\n",
			PInfo.pi_RowBufSize, PInfo.pi_TopBuf,
d1062 2
a1063 2
		kprintf("allocated %ld bytes for BotBuf @@ %lx-%lx\n",
			PInfo.pi_RowBufSize, PInfo.pi_BotBuf,
d1079 2
a1080 2
		kprintf("allocated %ld bytes for Dest1Int @@ %lx-%lx\n",
			PInfo.pi_Dest1IntSize, PInfo.pi_Dest1Int,
d1096 2
a1097 2
		kprintf("allocated %ld bytes for Dest2Int @@ %lx-%lx\n",
			PInfo.pi_Dest2IntSize, PInfo.pi_Dest2Int,
d1112 2
a1113 2
	kprintf("allocated %ld bytes for ColorInt @@ %lx-%lx\n",
		PInfo.pi_ColorIntSize, PInfo.pi_ColorInt,
a1117 1
		temp1 = xstart;
a1127 1
			temp1 = ystart;
d1129 2
a1130 2
			kprintf("allocated %ld bytes for HamInt @@ %lx-%lx\n",
				PInfo.pi_HamIntSize, PInfo.pi_HamInt,
d1133 1
d1135 3
d1139 1
d1150 2
a1151 2
			kprintf("allocated %ld bytes for HamBuf @@ %lx-%lx\n",
				PInfo.pi_HamBufSize, PInfo.pi_HamBuf,
@


1.5
log
@added Hedley Hi-Res aspect ratio
V1.3 Gamma 1 check-in (again)
@
text
@a222 4
	static UWORD densities[8] = {
		0, SPECIAL_DENSITY1, SPECIAL_DENSITY2, SPECIAL_DENSITY3,
		SPECIAL_DENSITY4, SPECIAL_DENSITY5, SPECIAL_DENSITY6, SPECIAL_DENSITY7
	};
a242 1
	special = ior->io_Special;
d245 2
a246 5
	/* if user density settings override the application density settings */
	if (temp1 = densities[PD->pd_Preferences.PrintDensity]) {
		special &= ~SPECIAL_DENSITYMASK; /* clear application settings */
		special |= temp1; /* get user settings */
	}
d1233 18
@


1.4
log
@fixed pc==0 and pr==0 bug
V1.3 Gamma 1 check-in
@
text
@d199 1
a199 1
	ULONG ulong1, ulong2;
d209 1
a209 1
	int	aspectX, aspectY;
d443 3
d456 1
a456 1
			PrefsMaxWidth = (PrefsMaxWidth * PED->ped_XDotsInch + 5) / 10;
d461 1
a461 1
			PD->pd_Preferences.PrintLeftMargin) * PED->ped_XDotsInch;
d495 1
a495 1
			PrefsMaxHeight = (PrefsMaxHeight * PED->ped_YDotsInch + 5) / 10;
d499 1
a499 1
		PrefsMaxHeight = PD->pd_Preferences.PaperLength * PED->ped_YDotsInch;
d550 4
a553 3
		if(GfxBase->LibNode.lib_Version >= 33) {
			aspectX = roundit((10 * (GfxBase->NormalDPMY)) / 182);
			aspectY = roundit((10 * (GfxBase->NormalDPMX)) / 182);
d556 14
a569 2
			aspectX = 6;
			aspectY = 7;
a570 6
		if (!HiRes) {
			aspectX += aspectX;
		}
		if (!Lace) {
			aspectY += aspectY;
		}
d613 1
a613 1
		pc = (pc * PED->ped_XDotsInch + 500) / 1000;
d619 1
a619 1
		pr = (pr * PED->ped_YDotsInch + 500) / 1000;
d659 12
a670 5
	if (Aspect) {
		aspectX *= PED->ped_XDotsInch;
		aspectY *= PED->ped_YDotsInch;
		ulong1 = width * aspectX * pr;
		ulong2 = height * aspectY * pc;
d673 1
a673 1
			pr = ulong2 / width / aspectX;
d680 1
a680 1
			pc = ulong1 / height / aspectY;
d1081 2
a1082 1
	if ((PInfo.pi_ColorInt = AllocMem(PInfo.pi_ColorIntSize,MEMF_PUBLIC)) == NULL) {
d1084 2
a1085 1
		kprintf("couldn't get %ld bytes for ColorInt\n", PInfo.pi_ColorIntSize);
@


1.3
log
@V1.3 gamma 1 release
@
text
@d48 1
a48 5
*                and the default.  Bear in mind that if the user selects
*                a density (via preferences) of 1 to 7 that it will override
*                your density selection.  Alternatively you could set
*                'PD->pd_Preferences.PrintDensity' to 1 to 7 to assure that
*                you get the density you want.
d471 6
a476 1
	maxX = (prtMax && (prtMax < PrefsMaxWidth)) ? prtMax : PrefsMaxWidth;
d506 10
a515 1
	maxY = (prtMax && (prtMax < PrefsMaxHeight)) ? prtMax : PrefsMaxHeight;
d517 1
a517 1
		maxY = 600 * 12 * 100; /* 600 dpi * 12 inches * 100 ft */
@


1.2
log
@fixed V1.0 compatability
@
text
@d173 1
a173 1
#include <intuition/intuition.h>
a181 1
#include "prtprefs.h"
d200 1
d206 1
d252 1
a252 1
	PInfo.pi_PrefsFlags = *(UWORD *)(&PD->pd_Preferences.PrintFlags);
d338 2
a339 2
	if (Dimension == PIXEL_DIMENSIONS) {
		kprintf("PIXEL_DIMENSIONS");
d341 4
a344 1
	else if (Dimension == BOUNDED_DIMENSIONS) {
d347 1
a347 1
	else if (Dimension == ABSOLUTE_DIMENSIONS) {
d356 1
a356 1
	if (PInfo.pi_PrefsFlags & HALFTONE_DITHERING) {
d359 9
d376 2
a377 1
	Center = (PInfo.pi_PrefsFlags & CENTER_IMAGE) | (special & SPECIAL_CENTER);
d400 1
a400 1
			PInfo.pi_flags |= PRT_BLACKABLE; /* printer has black capabilities */
d425 3
a427 3
		if (rp->Layer->SuperBitMap) { /* SuperBitMap ? */
			maxcols = rp->Layer->SuperBitMap->BytesPerRow * 8;
			maxrows = rp->Layer->SuperBitMap->Rows;
d451 5
a455 2
		PrefsMaxWidth = *(UWORD *)(&PD->pd_Preferences.PrintMaxWidth);
		if (Dimension != PIXEL_DIMENSIONS) {
d475 1
a475 2
	maxX = ((PrefsMaxWidth) && PrefsMaxWidth < prtMax) ?
		PrefsMaxWidth : prtMax;
d485 5
a489 2
		PrefsMaxHeight = *(UWORD *)(&PD->pd_Preferences.PrintMaxHeight);
		if (Dimension != PIXEL_DIMENSIONS) {
d514 2
a515 1
	if (Dimension == ABSOLUTE_DIMENSIONS || Dimension == PIXEL_DIMENSIONS) {
d702 2
a703 3
		If the printer's maximum width is not 0 and the requested number
		of print columns (pc) is greater then the printer's maximum width,
		then set pc to the max.
d705 2
a706 2
	if (PED->ped_MaxXDots && (pc > PED->ped_MaxXDots)) {
		pc = PED->ped_MaxXDots;
d709 2
a710 3
		If the printer's maximum height is not 0 and the requested number
		of print rows (pr) is greater then the printer's maximum height,
		then set pr to the max.
d712 2
a713 2
	if (PED->ped_MaxYDots && (pr > PED->ped_MaxYDots)) {
		pr = PED->ped_MaxYDots;
d790 13
d804 1
a804 1
	if (!(PInfo.pi_flags & PRT_NOBLIT)) {
d815 3
a817 2
		kprintf("depth=%ld, allocated %ld bytes for rp @@ %lx\n",
			depth, sizeof(struct RastPort), PInfo.pi_temprp);
d825 2
a826 1
		if ((PInfo.pi_temprp->BitMap = AllocMem(temp1, MEMF_PUBLIC)) == NULL) {
d834 3
a836 2
		kprintf("allocated %ld bytes for bm @@ %lx\n",
			temp1, PInfo.pi_temprp->BitMap);
d839 4
a842 2
		PInfo.pi_temprp->BitMap->Planes[0] = NULL; /* havnt allocated these yet */
		PInfo.pi_temprp->BitMap->Rows = 1; /* force copy of bitmap to 1 line high */
d844 2
a845 1
		PInfo.pi_temprp->BitMap->BytesPerRow = temp1; /* set # of BytesPerRow */
d855 3
a857 2
		kprintf("allocated %ld bytes for Planes[0] @@ %lx\n",
			temp2, PInfo.pi_temprp->BitMap->Planes[0]);
d864 3
a866 2
			kprintf("Planes[%ld] = %lx\n",
				loop, PInfo.pi_temprp->BitMap->Planes[loop]);
d890 2
a891 2
	kprintf("allocated %ld bytes for ColorMap @@ %lx, %lx\n",
		temp2, PInfo.pi_ColorMap, cm);
d954 2
a955 1
	if ((PInfo.pi_PrefsFlags & CORRECT_RGB_MASK) && !(PInfo.pi_flags & PRT_HAM) &&
d968 8
a975 2
	PInfo.pi_RowBufSize = width * 2;
	if ((PInfo.pi_RowBuf = AllocMem(PInfo.pi_RowBufSize, MEMF_PUBLIC)) == NULL) {
d982 3
a984 2
	kprintf("allocated %ld bytes for RowBuf @@ %lx\n",
		PInfo.pi_RowBufSize, PInfo.pi_RowBuf);
d986 67
d1061 3
a1063 2
	kprintf("allocated %ld bytes for ColorInt @@ %lx\n",
		PInfo.pi_ColorIntSize, PInfo.pi_ColorInt);
d1080 3
a1082 2
			kprintf("allocated %ld bytes for HamInt @@ %lx\n",
				PInfo.pi_HamIntSize, PInfo.pi_HamInt);
d1096 3
a1098 2
			kprintf("allocated %ld bytes for HamBuf @@ %lx\n",
				PInfo.pi_HamBufSize, PInfo.pi_HamBuf);
d1106 1
a1106 1
	xstart, ystart, width, height, pc, pr, PInfo.pi_xpos);
d1151 20
@


1.1
log
@V1.3 beta 3 release
@
text
@d2 2
a3 2
*								 
*   NAME								 
a37 3
*			-    if ASPECT is set, one of the dimensions
*			     may be reduced/expanded to preserve the aspect
*			     ratio of the print.
d41 31
a71 15
*			-    if SPECIAL_DENSITY(1-7) is set, then the
*			     printer specific driver has the option of
*			     selecting a different dots per inch density
*			     (dpi) than the default one. As of this writing,
*			     the known printer specific modules supporting this
*			     feature are the HP_LASERJET & the HP_LASERJET_PLUS.
*			     For these two printers, the densities are
*			     75, 100, 150 & 300 dpi respectively. The HP_LASERJET
*			     always defaults to 75 dpi if the PaperQuality in
*			     preferences is set to DRAFT; 100 dpi if set to LETTER.
*			     The HP_LASERJET_PLUS defaults to 150 dpi if the
*			     PrintQuality in preferences is set to DRAFT;
*			     300 dpi if set to LETTER.
*			-    if SPECIAL_CENTER is set, then the picture will be
*			     horizontally centered on the paper.
d83 1
a83 1
*	IF io_Special is 0).
d145 1
d151 19
a169 13
*	if (OpenDevice("printer.device", 0, &PReq, 0)) {
*		PD = (struct PrinterData *)PReq.io_Device;
*		PED = &PD->pd_SegmentData->pd_PED;
*		printf("PrinterName = '%s'\n", PED->ped_PrinterName);
*		printf("PrinterClass=%u, ColorClass=%u\n",
*			PED->ped_PrinterClass, PED->ped_ColorClass);
*		printf("MaxColumns=%u, NumCharSets=%u, NumRows=%u\n",
*			PED->ped_MaxColumns, PED->ped_NumCharSets, PED->ped_NumRows);
*		printf("MaxXDots=%lu, MaxYDots=%lu, XDotsInch=%u, YDotsInch=%u\n",
*			PED->ped_MaxXDots, PED->ped_MaxYDots,
*			PED->ped_XDotsInch, PED->ped_YDotsInch);
*		CloseDevice(&PReq);
*	}
d180 2
a181 1
#include "prtprivate.h"
d183 1
d242 1
a242 1
	PInfo.rp = rp = ior->io_RastPort;
d249 1
a249 1
	PInfo.render = render = PED->ped_Render;
d251 2
a252 2
	PInfo.PrefsFlags = *(UWORD *)(&PD->pd_Preferences.PrintFlags);
	Dimension = PInfo.PrefsFlags & DIMENSIONS_MASK;
d262 1
a262 1
		rp, ior->io_ColorMap, ior->io_Modes, special, PInfo.PrefsFlags);
d325 1
a325 1
	if (PInfo.PrefsFlags & CORRECT_RED) {
d328 1
a328 1
	if (PInfo.PrefsFlags & CORRECT_GREEN) {
d331 1
a331 1
	if (PInfo.PrefsFlags & CORRECT_BLUE) {
d334 1
a334 1
	if (PInfo.PrefsFlags & CENTER_IMAGE) {
d349 1
a349 1
	if (PInfo.PrefsFlags & INTEGER_SCALING) {
d352 1
a352 1
	if (PInfo.PrefsFlags & HALFTONE_DITHERING) {
d363 1
a363 1
	Center = (PInfo.PrefsFlags & CENTER_IMAGE) | (special & SPECIAL_CENTER);
d368 2
a369 1
	if (err = (*render)(0, special, 0, 5)) {
d373 3
a375 3
	PInfo.scale = Scale;
	PInfo.special = special;
	PInfo.dmatrix = (PInfo.PrefsFlags & HALFTONE_DITHERING) ?
d386 1
a386 1
			PInfo.flags |= PRT_BLACKABLE; /* printer has black capabilities */
d391 1
a391 1
		PInfo.flags |= PRT_INVERT;
d395 1
a395 1
		PInfo.flags |= PRT_BW;
d399 1
a399 1
		PInfo.threshold = PD->pd_Preferences.PrintThreshold;
d402 1
a402 1
		PInfo.threshold = 0;
d405 1
a405 1
		PInfo.flags |= PRT_HAM;
d537 1
a537 1
	if (PInfo.flags & PRT_INVERT) { /* if want to invert picture */
d645 1
a645 1
	if (PInfo.PrefsFlags & INTEGER_SCALING) {
d704 1
a704 1
		PInfo.xpos = (PED->ped_MaxXDots - pc + 1) / 2;
d714 1
a714 1
			PInfo.xpos = PrefsXOffset;
d730 3
a732 3
		PInfo.ymult = height / pr;
		PInfo.ymod = height % pr;
		PInfo.ety = pr;
d735 3
a737 3
		PInfo.ymult = pr / height;
		PInfo.ymod = pr % height;
		PInfo.ety = height;
d742 3
a744 3
		PInfo.xmult = PInfo.tempxmult = width / pc;
		PInfo.xmod = PInfo.tempxmod = width % pc;
		PInfo.etx = PInfo.tempetx = pc;
d747 3
a749 3
		PInfo.xmult = PInfo.tempxmult = pc / width;
		PInfo.xmod = PInfo.tempxmod = pc % width;
		PInfo.etx = PInfo.tempetx = width;
a753 7
	/* see if planes are too wide for blitter use */
	if (maxcols > MAXBLITSIZE) {
#if DEBUG
		kprintf("SOURCE RP PLANES WIDTH ARE TOO BIG FOR BLITTER USE!\n");
#endif
		PInfo.flags |= PRT_NOBLIT; /* cant use blitter, rp too big */
	}
d760 1
a760 1
		PInfo.flags |= PRT_NOBLIT; /* cant use blitter */
d768 1
a768 1
			PInfo.flags |= PRT_NOBLIT; /* cant use blitter */
d773 1
a773 1
	if (!(PInfo.flags & PRT_NOBLIT)) {
d775 1
a775 1
		if ((PInfo.temprp = AllocMem(sizeof(struct RastPort), MEMF_PUBLIC))
d785 1
a785 1
			depth, sizeof(struct RastPort), PInfo.temprp);
d787 3
a789 3
		*(PInfo.temprp) = *rp; /* copy rp */
		PInfo.temprp->BitMap = NULL; /* havnt allocated this yet */
		PInfo.temprp->Layer = NULL; /* no layers for this rp */
d793 1
a793 1
		if ((PInfo.temprp->BitMap = AllocMem(temp1, MEMF_PUBLIC)) == NULL) {
d802 1
a802 1
			temp1, PInfo.temprp->BitMap);
d804 3
a806 3
		*(PInfo.temprp->BitMap) = *(rp->BitMap); /* copy rp bitmap */
		PInfo.temprp->BitMap->Planes[0] = NULL; /* havnt allocated these yet */
		PInfo.temprp->BitMap->Rows = 1; /* force copy of bitmap to 1 line high */
d808 1
a808 1
		PInfo.temprp->BitMap->BytesPerRow = temp1; /* set # of BytesPerRow */
d810 1
a810 1
		if ((PInfo.temprp->BitMap->Planes[0] = AllocMem(temp2, MEMF_CHIP))
d819 1
a819 1
			temp2, PInfo.temprp->BitMap->Planes[0]);
d823 2
a824 2
			PInfo.temprp->BitMap->Planes[loop] =
				PInfo.temprp->BitMap->Planes[loop - 1] + temp1;
d827 1
a827 1
				loop, PInfo.temprp->BitMap->Planes[loop]);
d842 1
a842 1
	PInfo.ColorMapSize = temp2;
d849 1
a849 1
	PInfo.ColorMap = cm;
d852 1
a852 1
		temp2, PInfo.ColorMap, cm);
d879 1
a879 1
		cm = PInfo.ColorMap;
d897 1
a897 1
	cm = PInfo.ColorMap;
d900 1
a900 1
		GetBlack(cm, PInfo.flags);
d902 1
a902 1
			GetBlack(cm + 32, PInfo.flags);
d915 1
a915 1
	if ((PInfo.PrefsFlags & CORRECT_RGB_MASK) && !(PInfo.flags & PRT_HAM) &&
d923 4
a926 4
	PInfo.xstart = xstart;
	PInfo.ystart = ystart;
	PInfo.width = PInfo.tempwidth = width;
	PInfo.height = height;
d928 2
a929 2
	PInfo.RowBufSize = width * 2;
	if ((PInfo.RowBuf = AllocMem(PInfo.RowBufSize, MEMF_PUBLIC)) == NULL) {
d931 1
a931 1
		kprintf("couldn't get %ld bytes for RowBuf\n", PInfo.RowBufSize);
d937 1
a937 1
		PInfo.RowBufSize, PInfo.RowBuf);
d939 2
a940 2
	PInfo.ColorIntSize = width * sizeof(union colorEntry);
	if ((PInfo.ColorInt = AllocMem(PInfo.ColorIntSize,MEMF_PUBLIC)) == NULL) {
d942 1
a942 1
		kprintf("couldn't get %ld bytes for ColorInt\n", PInfo.ColorIntSize);
d948 1
a948 1
		PInfo.ColorIntSize, PInfo.ColorInt);
d951 1
a951 1
	if (PInfo.flags & PRT_HAM) {
d953 3
a955 3
		if (!(PInfo.flags & PRT_INVERT)) { /* if not inverted */
			PInfo.HamIntSize = height * sizeof(union colorEntry);
			if ((PInfo.HamInt = AllocMem(PInfo.HamIntSize, MEMF_PUBLIC))
d959 1
a959 1
					PInfo.HamIntSize);
d966 1
a966 1
				PInfo.HamIntSize, PInfo.HamInt);
d970 2
a971 2
			PInfo.HamBufSize = temp1 * 2;
			if ((PInfo.HamBuf = AllocMem(PInfo.HamBufSize, MEMF_PUBLIC))
d975 1
a975 1
					PInfo.HamBufSize);
d981 1
a981 1
				PInfo.HamBufSize, PInfo.HamBuf);
d989 1
a989 1
	xstart, ystart, width, height, pc, pr, PInfo.xpos);
d991 1
a991 1
		PInfo.flags, PInfo.threshold, PInfo.special, PInfo.render);
d993 2
a994 2
		PInfo.xmult, PInfo.xmod, PInfo.etx,
		PInfo.ymult, PInfo.ymod, PInfo.ety);
d1003 2
a1004 1
	err = (*render)(ior, pc + PInfo.xpos, pr, 0);
d1006 1
a1006 1
	PInfo.flags |= PRT_RENDER0;
@


1.0
log
@added to rcs
@
text
@a409 85
	/* see if planes are too wide for blitter use */
	if (maxcols > MAXBLITSIZE) {
#if DEBUG
		kprintf("SOURCE RP PLANES WIDTH ARE TOO BIG FOR BLITTER USE!\n");
#endif
		PInfo.flags |= PRT_NOBLIT; /* cant use blitter, rp too big */
	}
	depth = rp->BitMap->Depth;
	/* see if there are too many planes for ClipBlit use */
	if (depth > MAXDEPTH) {
#if DEBUG
		kprintf("TOO MANY PLANES FOR CLIPBLIT!\n");
#endif
		PInfo.flags |= PRT_NOBLIT; /* cant use blitter */
	}
	/* see if any of the original rp's planes are in fast mem */
	for (loop=0; loop<depth; loop++) {
		if (!TestChip(rp->BitMap->Planes[loop])) {
#if DEBUG
			kprintf("SOURCE RP PLANES ARE NOT IN CHIP MEM!\n");
#endif
			PInfo.flags |= PRT_NOBLIT; /* cant use blitter */
			break;
		}
	}

	if (!(PInfo.flags & PRT_NOBLIT)) {
		/* get mem for temp rastport */
		if ((PInfo.temprp = AllocMem(sizeof(struct RastPort), MEMF_PUBLIC))
			== NULL) {
#if DEBUG
			kprintf("couldn't get %ld bytes for temprp\n",
				sizeof(struct RastPort));
#endif
			return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
		}
#if DEBUG
		kprintf("depth=%ld, allocated %ld bytes for PInfo.temprp @@ %lx\n",
			depth, sizeof(struct RastPort), PInfo.temprp);
#endif DEBUG
		*(PInfo.temprp) = *rp; /* copy rp */
		PInfo.temprp->BitMap = NULL; /* havnt allocated this yet */
		PInfo.temprp->Layer = NULL; /* no layers for this rp */
		/* make sure we have enough mem for ALL the planeptrs */
		temp1 = sizeof(struct BitMap) + depth * sizeof(PLANEPTR);
		/* get mem for temp bitmap */
		if ((PInfo.temprp->BitMap = AllocMem(temp1, MEMF_PUBLIC)) == NULL) {
#if DEBUG
			kprintf("couldn't get %ld bytes for PInfo.temprp->BitMap\n",
				temp1);
#endif
			return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
		}
#if DEBUG
		kprintf("allocated %ld bytes for PInfo.temprp->BitMap @@ %lx\n",
			temp1, PInfo.temprp->BitMap);
#endif DEBUG
		*(PInfo.temprp->BitMap) = *(rp->BitMap); /* copy rp bitmap */
		PInfo.temprp->BitMap->Planes[0] = NULL; /* havnt allocated these yet */
		PInfo.temprp->BitMap->Rows = 1; /* force copy of bitmap to 1 line high */
		temp1 = ((width + 15) / 16) * 2; /* calculate # of BytesPerRow */
		PInfo.temprp->BitMap->BytesPerRow = temp1; /* set # of BytesPerRow */
		temp2 = temp1 * depth; /* calculate # of bytes for all planes */
		if ((PInfo.temprp->BitMap->Planes[0] = AllocMem(temp2, MEMF_CHIP))
			== NULL) {
#if DEBUG
			kprintf("couldn't get %ld bytes for Planes\n", temp2);
#endif
			return(Backout(PDERR_INTERNALMEMORY, ior, &PInfo));
		}
#if DEBUG
		kprintf("allocated %ld bytes for Planes[0] @@ %lx\n",
			temp2, PInfo.temprp->BitMap->Planes[0]);
#endif DEBUG
		/* initialize plane ptrs for temp bitmap */
		for (loop=1; loop<depth; loop++) {
			PInfo.temprp->BitMap->Planes[loop] =
				PInfo.temprp->BitMap->Planes[loop - 1] + temp1;
#if DEBUG
			kprintf("Planes[%ld] = %lx\n",
				loop, PInfo.temprp->BitMap->Planes[loop]);
#endif
		}
	}

d729 87
a862 3
#if DEBUG
		kprintf("converting %ld rgb to ymc values\n", temp1);
#endif
a881 3
#if DEBUG
	kprintf("computing %ld black values\n", temp1);
#endif
a1015 3
#if DEBUG
	kprintf("loop start=%ld, loop end=%ld\n", temp1, temp2);
#endif
@
