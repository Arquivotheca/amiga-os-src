head     36.9;
branch   ;
access   ;
symbols  V38_8:36.9 V37_4:36.8 V36_15:36.7 V36_13:36.6 V36_6:36.4 V36_5:36.3 V36_3:36.1 V36_2:36.0 V36_1:36.0 V36_0:35.1;
locks    ; strict;
comment  @*   @;


36.9
date     92.04.14.11.49.15;  author darren;  state Exp;
branches ;
next     36.8;

36.8
date     91.02.14.12.15.27;  author darren;  state Exp;
branches ;
next     36.7;

36.7
date     90.11.26.16.23.56;  author darren;  state Exp;
branches ;
next     36.6;

36.6
date     90.11.02.14.03.04;  author darren;  state Exp;
branches ;
next     36.5;

36.5
date     90.03.03.17.39.04;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     90.02.28.16.03.00;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     90.02.26.15.12.27;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     90.02.26.15.01.28;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     90.01.22.10.59.09;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     89.06.09.10.49.43;  author kodiak;  state Exp;
branches ;
next     35.1;

35.1
date     88.05.10.15.47.48;  author kodiak;  state Exp;
branches ;
next     35.0;

35.0
date     88.05.09.16.34.52;  author kodiak;  state Exp;
branches ;
next     ;


desc
@clipboard device workhorse code
@


36.9
log
@Use of semaphore around open/close which could break Forbid()
during DOS i/o resulting in a race condition, and crash.
Don't bother using delayed expunge flag; delayed expunge is
worthless, and this code wasn't freeing the loaded segment.
@
text
@/*
**	$Header: /usr.MC68010/ghostwheel/darren/V38/clipboard/RCS/dev.c,v 36.8 91/02/14 12:15:27 darren Exp Locker: darren $
**
**      clipboard.device
**
**      (C) Copyright 1985,1989 Commodore-Amiga, Inc.
**          All Rights Reserved
*/
#ifdef	DEBUG
#define	D(a)	kprintf a
#else
#define	D(a)
#endif

#include        "exec/types.h"
#include        "exec/nodes.h"
#include        "exec/lists.h"
#include        "exec/memory.h"
#include        "exec/libraries.h"
#include        "exec/io.h"
#include        "exec/errors.h"
#include	"exec/execbase.h"
#include        "dos/dos.h"
#include        "dos/dosextens.h"
#include	"utility/hooks.h"
#include	"clipboard.h"

/*********************************************************************
**********************************************************************
*
*	Device Initialization
*
**********************************************************************
*********************************************************************/
extern	int Read();
extern	int Write();


/* clipboard device data */

#define	BLOCKSIZE		512
#define	BLOCKMASK		0x01ff
#define	BLOCKSHIFT		9
#define	CLIPSIZECHECK		2000
#define	LOWMEMMARK		0x4000	/* 16K */
#define	IOF_DONE		0x80	/* returned to the user */
#define	IOF_ACTIVE		0x40	/* this will be done soon */
#define	IOF_QUEUED		0x20	/* on a list somewhere */
#define	IOF_PENDINGREAD		0x10	/* this group of reads not started */

struct	ExecBase *SysBase;
struct	Library *DOSBase;
struct	Library *UtilityBase;
ULONG	cd_Segment;
struct	List cd_Units;
struct	SignalSemaphore cd_SS;


/* clip block */
struct ClipBlock {
    struct  Node cb_Node;		/* list of blocks */
    LONG    cb_BlockNum;		/* block number (origin 0) */
    UBYTE   cb_Data[BLOCKSIZE];		/* block data */
};


#define	OPEN_OK			0
#define	OPEN_PROGRESSING	1

/* clipboard unit data */
struct ClipboardUnit {
    struct  ClipboardUnitPartial cu_CUP;/* list of units */
    ULONG   cu_OpenCnt;			/* number of accessors for unit */
    struct  MsgPort cu_PendingOpens;	/* other open requests waiting */
    LONG    cu_PendingID;		/* latest clip identifier */
    LONG    cu_ProcessingID;		/* clip identifier being processed */
    UWORD   cu_ProcessingCommand;	/* command in progress */
    BYTE    cu_WorkLocked;		/* doWork in progress */
    BYTE    cu_OpenFlags;		/* Open() handshake flags */

    ULONG   cu_DiskFile;		/* disk file for clip, if necessary */
    char    cu_DiskFileName[28];	/* name associated w/ cu_DiskFile */
    struct  List cu_BlockHead;		/* list of clip blocks */
    struct  ClipBlock *cu_CurrBlock;	/* most recently accessed block */
    ULONG   cu_CurrentLength;		/* length of clip */
    BOOL    cu_CutValid;		/* false if clip contents not valid */

    struct  List cu_ReadPending;	/* pending read commands, sorted */
    UWORD   cu_CurrentReadCount;	/* number of reads w/ ID w/o EOF */

    struct  List cu_CutPending;		/* pending cut commands, sorted */
    struct  SatisfyMsg cu_SatisfyMsg;	/* message to send to satisfy post */
    struct  MsgPort *cu_SatisfyMsgPort;	/* message port for current post */

    struct  SignalSemaphore cu_ChangeSemaphore;
    struct  MinList cu_ChangeHooks;	/* active change hooks */
};


freeCD(cd)
struct Library *cd;
{
    UBYTE *freePtr;
    ULONG freeSize;

    freePtr = (UBYTE *) cd;
    freeSize = cd->lib_NegSize;
    freePtr -= freeSize;
    freeSize += cd->lib_PosSize;
    FreeMem(freePtr, freeSize);
}


struct Library *
CInit(cd, segment, sysBase)
struct Library *cd;
ULONG segment;
struct ExecBase *sysBase;
{
    UBYTE *failPtr;
    ULONG failSize;

    SysBase = sysBase;
    if ((UtilityBase = (struct Library *) OpenLibrary("utility.library", 0))
	    == 0) {
	freeCD(cd);
	return(0);
    }
    if ((DOSBase = (struct Library *) OpenLibrary("dos.library", 0)) == 0) {
	CloseLibrary(UtilityBase);
	freeCD(cd);
	return(0);
    }
    cd_Segment = segment;
    InitSemaphore(&cd_SS);
    NewList(&cd_Units);
    D(("CInit: device node 0x%lx\n", cd));
    return(cd);
}



/*********************************************************************
**********************************************************************
*
*	support functions
*
**********************************************************************
*********************************************************************/

struct ClipBlock
*newTailBlock(cu)
struct ClipboardUnit *cu;
{
    struct ClipBlock *newBlock;

    D(("newTailBlock(0x%06lx): ", cu));
    Forbid();
    if (newBlock = (struct ClipBlock *)
	    AllocMem(sizeof(*newBlock), MEMF_CLEAR)) {
	if (cu->cu_BlockHead.lh_TailPred->ln_Pred) {
	    /* the list is not empty */
	    newBlock->cb_BlockNum =
		    ((struct ClipBlock *) cu->cu_BlockHead.lh_TailPred)
		    ->cb_BlockNum + 1;
	}
	else {
	    /* the list is empty, this is the first block */
	    newBlock->cb_BlockNum = 0;
	}
	AddTail(&cu->cu_BlockHead, newBlock);
	D(("# %ld ", newBlock->cb_BlockNum));
    }
    else {
	cu->cu_CutValid = FALSE;
    }
    Permit();
    D(("@@ 0x%06lx\n", newBlock));
    return(newBlock);
}

ULONG
openDiskClip(cu, mode)
struct ClipboardUnit *cu;
int mode;
{
    struct Process *pr;
    APTR prWindowPtr;
    int lock1, lock2;
    int tpr, file;

    file = 0;

    /* disable any dos requestor */
    pr = (struct Process *) FindTask(0);
    prWindowPtr = pr->pr_WindowPtr;
    pr->pr_WindowPtr = (APTR) -1;

    /* first see if the new "CLIPS:" assign has been made */
    tpr = DeviceProc("CLIPS:");

    /* re-enable any dos requestor */
    pr->pr_WindowPtr = prWindowPtr;

    if (tpr == 0) {
	/* "CLIPS:" does not exist, use the default "DEVS:clipboards/" */
	if ((lock1 = Lock("DEVS:", SHARED_LOCK)) != 0) {
	    if (((lock2 = Lock("DEVS:clipboards", SHARED_LOCK)) == 0) &&
		    (mode == MODE_NEWFILE)) {
		lock2 = CreateDir("DEVS:clipboards");
	    }
	    if (lock2 != 0) {
		sprintf(cu->cu_DiskFileName, "DEVS:clipboards/%ld",
			cu->cu_CUP.cu_UnitNum);
		file = Open(cu->cu_DiskFileName, mode);
		UnLock(lock2);
	    }
	    UnLock(lock1);
	}
    }
    else {
	sprintf(cu->cu_DiskFileName, "CLIPS:%ld", cu->cu_CUP.cu_UnitNum);
	file = Open(cu->cu_DiskFileName, mode);
    }

    return(file);
}

clearClip(cu)
struct ClipboardUnit *cu;
{
    struct ClipBlock *block, *nextBlock;

    D(("clearClip(0x%06lx);\n", cu));
    Forbid();
    block = cu->cu_BlockHead.lh_Head;
    while (nextBlock = (struct ClipBlock *) block->cb_Node.ln_Succ) {
	D(("  # %ld @@ 0x%06lx\n", block->cb_BlockNum, block));
	FreeMem(block, sizeof(*block));
	block = nextBlock;
    }
    NewList(&cu->cu_BlockHead);
    cu->cu_CurrBlock = 0;
    Permit();
}

    
int
readClip(cu, ior, data, length, offset)
struct ClipboardUnit *cu;
struct IOClipReq *ior;
UBYTE *data;
ULONG length;
ULONG offset;
{
    struct ClipBlock *block;
    ULONG blockNum, index, actual, remaining;
    short i;

    D(("r(0x%06lx, %ld, %ld): ", data, length, offset));
    Forbid();
    actual = 0;
    if (cu->cu_CutValid) {
	if (cu->cu_DiskFile) {
	    /* about to loose Forbid: protect this IO */
	    ior->io_Flags |= IOF_ACTIVE;
	    if (Seek(cu->cu_DiskFile, offset, OFFSET_BEGINING) != -1) {
		actual = Read(cu->cu_DiskFile, data, length);
	    }
	}
	else {
	    if (offset < cu->cu_CurrentLength) {
		if (offset + length > cu->cu_CurrentLength) {
		    actual = cu->cu_CurrentLength - offset;
		}
		else {
		    actual = length;
		}
		if (actual) {
		    /* the starting data will be here */
		    blockNum = offset >> BLOCKSHIFT;
		    index = offset & BLOCKMASK;
		    if ((block = cu->cu_CurrBlock) == 0) {
			block = cu->cu_BlockHead.lh_Head;
		    }
		    if (block->cb_BlockNum != blockNum) {
			while (block->cb_BlockNum > blockNum) {
			    block = (struct ClipBlock *) block->cb_Node.ln_Pred;
			}
			while (block->cb_BlockNum < blockNum) {
			    block = (struct ClipBlock *) block->cb_Node.ln_Succ;
			}
			D(("\nnew read block: 0x%06lx, # %ld\n",
				block, block->cb_BlockNum));
		    }
		    remaining = actual;
		    while (remaining != 0) {
			if (BLOCKSIZE-index < remaining) {
			    for (i = index; i < BLOCKSIZE; i++) {
				*data++ = block->cb_Data[i];
			    }
			    block = (struct ClipBlock *) block->cb_Node.ln_Succ;
			    D(("\ncont'd. read block: 0x%06lx, # %ld\n",
				    block, block->cb_BlockNum));
			    remaining -= BLOCKSIZE-index;
			    index = 0;
			}
			else {
			    for (i = index; i < index+remaining; i++) {
				*data++ = block->cb_Data[i];
			    }
			    remaining = 0;
			}
		    }
		    cu->cu_CurrBlock = block;
		}
	    }
	}
    }
    Permit();
    return(actual);
}


int
writeClip(cu, ior, data, length, offset)
struct ClipboardUnit *cu;
struct IOClipReq *ior;
UBYTE *data;
ULONG length;
ULONG offset;
{
    struct ClipBlock *block, *nextBlock;
    ULONG blockNum, index, actual;
    ULONG file;
    short i;

    D(("w(0x%06lx, %ld, %ld): ", data, length, offset));
    Forbid();
    D((cu->cu_CutValid?"":"CUT NOT VALID!\n"));
    actual = 0;
    if ((!(cu->cu_DiskFile)) &&
	    ((offset + length) > CLIPSIZECHECK) &&
	    (cu->cu_CutValid) &&
	    (AvailMem(MEMF_LARGEST) < LOWMEMMARK)) {
	if (cu->cu_DiskFile = openDiskClip(cu, MODE_NEWFILE)) {
	    /* copy blocks to disk */
	    block = cu->cu_BlockHead.lh_Head;
	    while (nextBlock = (struct ClipBlock *) block->cb_Node.ln_Succ) {
		if (block->cb_BlockNum*BLOCKSIZE < cu->cu_CurrentLength) {
		    if ((block->cb_BlockNum+1)*BLOCKSIZE
			    > cu->cu_CurrentLength) {
			if (Write(cu->cu_DiskFile, block->cb_Data,
				cu->cu_CurrentLength & BLOCKMASK) !=
				(cu->cu_CurrentLength & BLOCKMASK)) {
			    cu->cu_CutValid = FALSE;
			}
		    }
		    else {
			if (Write(cu->cu_DiskFile, block->cb_Data, BLOCKSIZE) !=
				    BLOCKSIZE) {
				cu->cu_CutValid = FALSE;
			    }
		    }
		}
		FreeMem(block, sizeof(*block));
		block = nextBlock;
	    }
	    NewList(&cu->cu_BlockHead);
	}
	else {
	    cu->cu_CutValid = FALSE;
	}
    }
    if (cu->cu_CutValid) {
	if (cu->cu_DiskFile) {
	    D(("(write to disk) "));
	    /* about to loose Forbid: protect this IO */
	    ior->io_Flags |= IOF_ACTIVE;
	    if (Seek(cu->cu_DiskFile, offset, OFFSET_BEGINING) != -1) {
		actual = Write(cu->cu_DiskFile, data, length);
	    }
	}
	else {
	    blockNum = offset >> BLOCKSHIFT;
	    index = offset & BLOCKMASK;
	    if ((block = cu->cu_CurrBlock) == 0) {
		block = newTailBlock(cu);
	    }
	    if (block) {
		if (block->cb_BlockNum != blockNum) {
		    while (block->cb_BlockNum > blockNum) {
			block = (struct ClipBlock *) block->cb_Node.ln_Pred;
		    }
		    while (block && (block->cb_BlockNum < blockNum)) {
			block = (struct ClipBlock *) block->cb_Node.ln_Succ;
			if (block->cb_Node.ln_Succ == 0) {
			    /* build a new node here */
			    block = newTailBlock(cu);
			}
		    }
		}
	    }
	    while (block && (length > 0)) {
		if (BLOCKSIZE-index < length) {
		    D(("\n    finish block: %ld to %ld\n    next block ",
			    index, BLOCKSIZE));
		    for (i = index; i < BLOCKSIZE; i++) {
			block->cb_Data[i] = *data++;
		    }
		    block = (struct ClipBlock *) block->cb_Node.ln_Succ;
		    if (block->cb_Node.ln_Succ == 0) {
			/* build a new node here */
			block = newTailBlock(cu);
			D(("(NEW) "));
		    }
		    actual += BLOCKSIZE-index;
		    length -= BLOCKSIZE-index;
		    index = 0;
		    D(("\n    index now zero, actual %ld, and length %ld\n",
			    actual, length));
		}
		else {
		    for (i = index; i < index+length; i++) {
			block->cb_Data[i] = *data++;
		    }
		    actual += length;
		    length = 0;
		}
	    }
	    cu->cu_CurrBlock = block;
	}
    }
    Permit();
    return(actual);
}


callHook(hook, object, message)
struct Hook *hook;
struct ClipboardUnit *object;
ULONG message;
{
    CallHookPkt(hook, object, &message);
}


endIO(io)
struct IOClipReq *io;
{
    Forbid();
    if (!(io->io_Flags & IOF_DONE)) {
	/* this is the completion of the IO */
	if ((io->io_Flags & IOF_QUICK) == 0)
	    ReplyMsg(io);
    }
    else
	/* the IO has already been completed */
	io->io_Flags &= ~IOF_QUICK;
    io->io_Flags |= IOF_DONE;
    Permit();
    D(("actual(%ld) error(%ld)\n", io->io_Actual, io->io_Error));
}


endQueuedIO(io, ior)
struct IOClipReq *io;
struct IOClipReq *ior;
{
    if (!(io->io_Flags & IOF_DONE))
	Remove(io);
    if (io != ior)
	io->io_Flags &= ~IOF_QUICK;
    endIO(io);
    io->io_Flags &= ~IOF_QUEUED;
}


BOOL
nextPendingReading(cu)
struct ClipboardUnit *cu;
{
    struct IOClipReq *wior1, *wior2;

    wior1 = (struct IOClipReq *) cu->cu_CutPending.lh_Head;
    wior2 = (struct IOClipReq *) cu->cu_ReadPending.lh_Head;
    if (wior1->io_Message.mn_Node.ln_Succ)
	if (wior2->io_Message.mn_Node.ln_Succ) {
	    D(("R #%ld \\ W #%ld\n", wior2->io_ClipID, wior1->io_ClipID));
	    if (wior1->io_ClipID > wior2->io_ClipID)
		/* read list is next up */
		return(TRUE);
	    else
		return(FALSE);
	}
	else
	    return(FALSE);
    else
	return(TRUE);
}


doPost(cu, io, ior)
struct ClipboardUnit *cu;
struct IOClipReq *io;
struct IOClipReq *ior;
{
    cu->cu_SatisfyMsgPort = io->io_Data;
    cu->cu_SatisfyMsg.sm_Unit = cu->cu_CUP.cu_UnitNum;
    cu->cu_SatisfyMsg.sm_ClipID = io->io_ClipID;
    endQueuedIO(io, ior);
}


doWork(cu, ior)
/*	call Forbid()en	*/
struct ClipboardUnit *cu;
struct IOClipReq *ior;
{
    struct IOClipReq *wior;
    struct Hook *hook;
    BOOL workToDo;
    ULONG file;
    int i;
    char c;

    D(("doWork(0x%lx); ", cu));
    ior->io_Flags |= IOF_QUEUED;
    if (cu->cu_WorkLocked) {
	ior->io_Flags &= ~IOF_QUICK;
	D(("/ locked\n"));
	return(0);
    }
    cu->cu_WorkLocked = TRUE;
    workToDo = TRUE;
    do {
	D(("%ld ", cu->cu_ProcessingCommand));
	if (cu->cu_ProcessingCommand == CMD_INVALID) {
	    /* nothing's happening now */
	    if (nextPendingReading(cu)) {
		wior = (struct IOClipReq *) cu->cu_ReadPending.lh_Head;
		if (wior->io_Message.mn_Node.ln_Succ) {
		    cu->cu_ProcessingID = wior->io_ClipID;
		    cu->cu_ProcessingCommand = CMD_READ;
		}
		else
		    workToDo = FALSE;
	    }
	    else {
		wior = (struct IOClipReq *) cu->cu_CutPending.lh_Head;
		if (wior->io_Message.mn_Node.ln_Succ) {
		    cu->cu_ProcessingID = wior->io_ClipID;
		    if ((cu->cu_ProcessingCommand = wior->io_Command)
			    == CBD_POST) {
			doPost(cu, wior, ior);
		    }
		    /* clear the clip file */
		    if (cu->cu_DiskFile) {
		    D(("        about to Close(0x%lx);\n", cu->cu_DiskFile));
			Close(cu->cu_DiskFile);
			cu->cu_DiskFile = 0;
			DeleteFile(cu->cu_DiskFileName);
		    }
		    else {
			clearClip(cu);
		    }
		    cu->cu_CutValid = TRUE;
		}
		else
		    workToDo = FALSE;
	    }
	}
/******/
/******	POST
/******/
	if (cu->cu_ProcessingCommand == CBD_POST) {
	    /* post outstanding */
	    if (nextPendingReading(cu)) {
		wior = (struct IOClipReq *) cu->cu_ReadPending.lh_Head;
		if (wior->io_Message.mn_Node.ln_Succ) {
		    /* a read is waiting for the post */
		    PutMsg(cu->cu_SatisfyMsgPort, &cu->cu_SatisfyMsg);
		    cu->cu_ProcessingCommand = CMD_WRITE;
		}
		else
		    workToDo = FALSE;
	    }
	    else {
		wior = (struct IOClipReq *) cu->cu_CutPending.lh_Head;
		if (wior->io_Message.mn_Node.ln_Succ) {
		    cu->cu_ProcessingID = wior->io_ClipID;
		    if ((cu->cu_ProcessingCommand = wior->io_Command)
			    == CBD_POST) {
			doPost(cu, wior, ior);
		    }
		}
		else
		    workToDo = FALSE;
	    }
	    D(("POST hooks\n"));
	    ObtainSemaphore(&cu->cu_ChangeSemaphore);
	    hook = (struct Hook *) cu->cu_ChangeHooks.mlh_Head;
	    while (hook->h_MinNode.mln_Succ) {
		D(("  hook 0x%lx\n", hook));
		callHook(hook, cu, 0, CBD_POST, cu->cu_ProcessingID);
		hook = (struct Hook *) hook->h_MinNode.mln_Succ;
	    }
	    ReleaseSemaphore(&cu->cu_ChangeSemaphore);
	}
/******/
/******	READ
/******/
	if (cu->cu_ProcessingCommand == CMD_READ) {
	    wior = (struct IOClipReq *) cu->cu_ReadPending.lh_Head;
	    if (wior->io_Message.mn_Node.ln_Succ) {
		if (wior->io_Flags & IOF_PENDINGREAD) {
		    /* this is an initial read command */
		    cu->cu_CurrentReadCount++;
		    wior->io_Flags &= ~IOF_PENDINGREAD;
		}
		/* check for end of file (indicating the paste is complete) */
		if (wior->io_Offset < cu->cu_CurrentLength) {
		    /* not end of file */
		    /* check for a nil destination before actually reading */
		    if (wior->io_Data != 0) {
			/* real destination, perform the read */
			wior->io_Actual = readClip(cu, wior, wior->io_Data,
				wior->io_Length, wior->io_Offset);
			wior->io_Offset += wior->io_Actual;
		    }
		    else {
			if ((wior->io_Offset + wior->io_Length <
				cu->cu_CurrentLength) &&
				(wior->io_Offset + wior->io_Length >
				wior->io_Offset))
			    wior->io_Actual = wior->io_Length;
			else
			    wior->io_Actual =
				    cu->cu_CurrentLength - wior->io_Offset;
			wior->io_Offset += wior->io_Actual;
		    }
		}
		else {
		    /* end of file */
		    wior->io_Actual = 0;
		    wior->io_ClipID = -1;
		    cu->cu_CurrentReadCount--;
		}
		endQueuedIO(wior, ior);
		if (cu->cu_CurrentReadCount == 0) {
		    /* there are no more reads pending */
		    cu->cu_ProcessingCommand = CMD_INVALID;
		}
	    }
	    else
		workToDo = FALSE;
	}
/******/
/******	WRITE
/******/
	if (cu->cu_ProcessingCommand == CMD_WRITE) {
	    wior = (struct IOClipReq *) cu->cu_CutPending.lh_Head;
	    if (wior->io_Message.mn_Node.ln_Succ) {
		if (wior->io_Command == CMD_WRITE) {
		    /* this is a write command */
		    wior->io_Actual = writeClip(cu, wior,
			    wior->io_Data, wior->io_Length, wior->io_Offset);
		    wior->io_Offset += wior->io_Actual;
		    cu->cu_CurrentLength =
			    (cu->cu_CurrentLength > wior->io_Offset) ?
			    cu->cu_CurrentLength : wior->io_Offset;
		    endQueuedIO(wior, ior);
		}
		else
		    if (wior->io_Command == CMD_UPDATE) {
			/* this is an update command */
			cu->cu_ProcessingCommand = CMD_UPDATE;
		    }
		    else
			workToDo = FALSE;
	    }
	    else
		workToDo = FALSE;
	}
/******/
/******	UPDATE
/******/
	if (cu->cu_ProcessingCommand == CMD_UPDATE) {
	    wior = (struct IOClipReq *) cu->cu_CutPending.lh_Head;
	    if (cu->cu_CurrentLength >= 8) {
		if (readClip(cu, wior, &cu->cu_CurrentLength, 4, 4) == 4) {
		    cu->cu_CurrentLength += 8;
		}
		else cu->cu_CurrentLength = 0;
	    }
	    else cu->cu_CurrentLength = 0;
	    D(("    UPDATE cu_CurrentLength %ld\n", cu->cu_CurrentLength));
	    cu->cu_CurrentReadCount = 0;
	    endQueuedIO(wior, ior);
	    if (cu->cu_CurrentLength > 0) {
		D(("UPDATE hooks\n"));
		ObtainSemaphore(&cu->cu_ChangeSemaphore);
		hook = (struct Hook *) cu->cu_ChangeHooks.mlh_Head;
		while (hook->h_MinNode.mln_Succ) {
		    D(("  hook 0x%lx\n", hook));
		    callHook(hook, cu, 0, CMD_UPDATE, cu->cu_ProcessingID);
		    hook = (struct Hook *) hook->h_MinNode.mln_Succ;
		}
		ReleaseSemaphore(&cu->cu_ChangeSemaphore);
	    }
	    cu->cu_ProcessingCommand = CMD_INVALID;
	}
    }
	while (workToDo);
    if (ior->io_Flags & IOF_QUEUED)
	ior->io_Flags &= ~IOF_QUICK;
    cu->cu_WorkLocked = FALSE;
    D((".\n"));
}


insort(list, node)
struct List *list;
struct IOClipReq *node;
{
    struct IOClipReq *search;
    struct Node *loopNode;

    search = (struct IOClipReq *) list->lh_Head;
    loopNode = search->io_Message.mn_Node.ln_Succ;
    while (loopNode) {
	if (node->io_ClipID >= search->io_ClipID) {
	    /* still looking */
	    search = (struct IOClipReq *) loopNode;
	    loopNode = search->io_Message.mn_Node.ln_Succ;
	}
	else {
	    /* insert this one here */
	    loopNode = 0;
	}
    }
    /* insert before search */
    Insert(list, node, search->io_Message.mn_Node.ln_Pred);
}



/*********************************************************************
**********************************************************************
*
*	Device Commands
*
**********************************************************************
*********************************************************************/


CCInvalid(ior)
struct IOClipReq *ior;
{
    D(("CCInvalid(0x%lx);\n", ior));
    ior->io_Error = IOERR_NOCMD;
    endIO(ior);
}


CCClear(ior)
struct IOClipReq *ior;
{
    D(("CCClear(0x%lx);\n", ior));
    CCInvalid(ior);
}


CCStop(ior)
struct IOClipReq *ior;
{
    D(("CCStop(0x%lx);\n", ior));
    CCInvalid(ior);
}


CCStart(ior)
struct IOClipReq *ior;
{
    D(("CCStart(0x%lx);\n", ior));
    CCInvalid(ior);
}


CCFlush(ior)
struct IOClipReq *ior;
{
    D(("CCFlush(0x%lx);\n", ior));
    CCInvalid(ior);
}


/****i* clipboard.device/CMD_RESET ***********************************
*
*   NAME
*	CMD_RESET -- Reset the clipboard.
*
*   FUNCTION
*	CMD_RESET resets the clipboard device without destroying handles
*	to the open device.
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set up
*	io_Device	preset by OpenDevice
*	io_Command	CMD_RESET
*	io_Flags	IOB_QUICK set if quick I/O is possible
*
*********************************************************************/

CCReset(ior)
struct IOClipReq *ior;
{
    D(("CCReset(0x%lx);\n", ior));
    CCStop(ior);
    CCFlush(ior);
    CCStart(ior);
}


/****** clipboard.device/CMD_READ ************************************
*
*   NAME
*	CMD_READ -- Read from a clip on the clipboard.
*
*   FUNCTION
*	The read function serves two purposes.
*
*	When io_Offset is within the clip, this acts as a normal read
*	request, and io_Data is filled with data from the clipboard.
*	The first read request should have a zero io_ClipID, which
*	will be filled with the ID assigned for this read.  Normal
*	sequential access from the beginning of the clip is achieved
*	by setting io_Offset to zero for the first read, then leaving
*	it untouched for subsequent reads.  If io_Data is null, then
*	io_Offset is incremented by io_Actual as if io_Length bytes
*	had been read: this is useful to skip to the end of file
*	by using a huge io_Length.
*
*	When io_Offset is beyond the end of the clip, this acts as a
*	signal to the clipboard device that the application is
*	through reading this clip.  Realize that while an application
*	is in the middle of reading a clip, any attempts to write new
*	data to the clipboard are held off.  This read past the end
*	of file indicates that those operations may now be initiated.
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set up
*	io_Device	preset by OpenDevice
*	io_Unit		preset by OpenDevice
*	io_Command	CMD_READ
*	io_Length	number of bytes to put in data buffer
*	io_Data		pointer to buffer of data to fill, or null to
*			skip over data
*	io_Offset	byte offset of data to read
*	io_ClipID	zero if this is the initial read
*
*   RESULTS
*	io_Error	non-zero if an error occurred
*	io_Actual	filled with the actual number of bytes read
*	io_Data		(the buffer now has io_Actual bytes of data)
*	io_Offset	updated to next read position, which is
*			beyond EOF if io_Actual != io_Length
*	io_ClipID	the clip ID assigned to this read: do not
*			alter for subsequent reads
*
*********************************************************************/

CCRead(ior)
struct IOClipReq *ior;
{
    struct ClipboardUnit *cu;

    cu = (struct ClipboardUnit *) ior->io_Unit;

    D(("CCRead(0x%lx)...", ior));
    if (ior->io_ClipID == 0) {
	ior->io_ClipID = cu->cu_PendingID;
	ior->io_Flags |= IOF_PENDINGREAD;
	ior->io_Error = 0;
    }
    if (ior->io_ClipID < cu->cu_ProcessingID) {
	/* obsolete read */
	D(("    clip id %ld is obsolete\n", ior->io_ClipID));
	ior->io_Actual = 0;
	ior->io_Error = CBERR_OBSOLETEID;
	endIO(ior);
    }
    else {
	insort(&cu->cu_ReadPending, ior);
	doWork(cu, ior);
    }
}


/****** clipboard.device/CMD_WRITE ***********************************
*
*   NAME
*	CMD_WRITE -- Write to a clip on the clipboard.
*
*   FUNCTION
*	This command writes data to the clipboard.  This data can be
*	provided sequentially by clearing io_Offset for the initial
*	write, and using the incremented value unaltered for
*	subsequent writes.  If io_Offset is ever beyond the current
*	clip size, the clip is padded with zeros.
*
*	If this write is in response to a SatisfyMsg for a pending
*	post, then the io_ClipID returned by the CBD_POST command must
*	be used.  Otherwise, a new ID is obtained by clearing the
*	io_ClipID for the first write.  Subsequent writes must not
*	alter the io_ClipID.
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set up
*	io_Device	preset by OpenDevice
*	io_Unit		preset by OpenDevice
*	io_Command	CMD_WRITE
*	io_Length	number of bytes from io_Data to write
*	io_Data		pointer to block of data to write
*	io_Offset	usually zero if this is the initial write
*	io_ClipID	zero if this is the initial write, ClipID of
*			the Post if this is to satisfy a post
*
*   RESULTS
*	io_Error	non-zero if an error occurred
*	io_Actual	filled with the actual number of bytes written
*	io_Offset	updated to next write position
*	io_ClipID	the clip ID assigned to this write: do not
*			alter for subsequent writes
*
*********************************************************************/

/****** clipboard.device/CMD_UPDATE **********************************
*
*   NAME
*	CMD_UPDATE -- Terminate the writing of a clip to the clipboard.
*
*   FUNCTION
*	Indicate to the clipboard that the previous write commands are
*	complete and can be used for any pending pastes (reads).  This
*	command cannot be issued while any of the write commands are
*	pending.
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set up
*	io_Device	preset by OpenDevice
*	io_Unit		preset by OpenDevice
*	io_Command	CMD_UPDATE
*	io_ClipID	the ClipID of the write
*
*   RESULTS
*	io_Error	non-zero if an error occurred
*
*********************************************************************/

/****** clipboard.device/CBD_POST ************************************
*
*   NAME
*	CBD_POST -- Post availability of a clip to the clipboard.
*
*   FUNCTION
*	Indicate to the clipboard device that data is available for
*	use by accessors of the clipboard.  This is intended to be
*	used when a cut is large, in a private data format, and/or
*	changing frequently, and it thus makes sense to avoid
*	converting it to an IFF form and writing it to the clipboard
*	unless another application wants it.  The post provides a
*	message port to which the clipboard device will send a satisfy
*	message if the data is required.
*
*	If the satisfy message is received, the write associated with
*	the post must be performed.  The act of writing the clip
*	indicates that the message has been received: it may then be
*	re-used by the clipboard device, and so must actually be
*	removed from the satisfy message port so that the port is not
*	corrupted.
*
*	If the application wishes to determine if a post it has
*	performed is still the current clip, it should check the
*	post's io_ClipID with that returned by the CBD_CURRENTREADID
*	command.  If the current read io_ClipID is greater, the clip
*	is not still current.
*	
*	If an application has a pending post and wishes to determine
*	if it should satisfy it (e.g. before it exits), it should
*	check the post's io_ClipID with that returned by the
*	CBD_CURRENTWRITEID command.  If the current write io_ClipID is
*	greater, there is no need to satisfy the post.
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set up
*	io_Device	preset by OpenDevice
*	io_Unit		preset by OpenDevice
*	io_Command	CBD_POST
*	io_Data		pointer to satisfy message port
*	io_ClipID	zero
*
*   RESULTS
*	io_Error	non-zero if an error occurred
*	io_ClipID	the clip ID assigned to this post, to be used
*			in the write command if this is satisfied
*
*
*********************************************************************/


CCCut(ior)
/* used as CCWrite(ior), CCUpdate(ior) and CCPost(ior) */
struct IOClipReq *ior;
{
    struct ClipboardUnit *cu;

    cu = (struct ClipboardUnit *) ior->io_Unit;

    D(("CCCut(0x%lx)...", ior));
    if (ior->io_ClipID == 0) {
	ior->io_Error = 0;
	ior->io_ClipID = ++cu->cu_PendingID;
	D(("    ClipID %ld assigned\n", ior->io_ClipID));
    }
    if (ior->io_ClipID < cu->cu_ProcessingID) {
	/* obsolete write */
	D(("    clip id %ld is obsolete\n", ior->io_ClipID));
	ior->io_Actual = 0;
	ior->io_Error = CBERR_OBSOLETEID;
	endIO(ior);
    }
    else {
	insort(&cu->cu_CutPending, ior);
	doWork(cu, ior);
    }
}


/****** clipboard.device/CBD_CURRENTREADID ***************************
*
*   NAME
*	CBD_CURRENTREADID - Determine the current read identifier.
*
*   FUNCTION
*	CBD_CURRENTREADID fills the io_ClipID with a clip identifier that
*	can be compared with that of a post command: if greater than
*	the post identifier then the post data held privately by an
*	application is not valid for its own pasting.
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set up
*	io_Device	preset by OpenDevice
*	io_Unit		preset by OpenDevice
*	io_Command	CBD_CURRENTREADID
*
*   RESULTS
*	io_ClipID	the ClipID of the current write is set
*
*********************************************************************/

CCCurrentReadID(ior)
struct IOClipReq *ior;
{
    struct ClipboardUnit *cu;

    cu = (struct ClipboardUnit *) ior->io_Unit;

    ior->io_ClipID = cu->cu_PendingID;
    endIO(ior);
}


/****** clipboard.device/CBD_CURRENTWRITEID **************************
*
*   NAME
*	CBD_CURRENTWRITEID -- Determine the current write identifier.
*
*   FUNCTION
*	CBD_CURRENTWRITEID fills the io_ClipID with a clip identifier that
*	can be compared with that of a post command: if greater than
*	the post identifier then the post is obsolete and need never
*	be satisfied.
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set up
*	io_Device	preset by OpenDevice
*	io_Unit		preset by OpenDevice
*	io_Command	CBD_CURRENTWRITEID
*
*   RESULTS
*	io_ClipID	the ClipID of the current write is set
*
*********************************************************************/

CCCurrentWriteID(ior)
struct IOClipReq *ior;
{
    struct ClipboardUnit *cu;

    cu = (struct ClipboardUnit *) ior->io_Unit;

    ior->io_ClipID = cu->cu_ProcessingID;
    endIO(ior);
}


/****** clipboard.device/CBD_CHANGEHOOK ******************************
*
*   NAME
*	CBD_CHANGEHOOK -- Add or remove a clip change hook
*
*   FUNCTION
*	CBD_CHANGEHOOK allows specification of a hook to be called
*	when the data on the clipboard has changed.
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set up
*	io_Device	preset by OpenDevice
*	io_Unit		preset by OpenDevice
*	io_Command	CBD_CHANGEHOOK
*	io_Length -     0 to remove, 1 to install this hook
*	io_Data -       struct Hook *, the clip change hook
*
*   HOOK ENVIRONMENT
*       hook message - a ClipHookMsg, as defined in devices/clipboard.h
*           chm_Type - 0, indicating that the message has the
*               following fields:
*           chm_ClipID - the clip ID of the clip triggering the change
*       hook object - io_Unit
*
*********************************************************************/

CCChangeHook(ior)
struct IOClipReq *ior;
{
    struct ClipboardUnit *cu;

    cu = (struct ClipboardUnit *) ior->io_Unit;
    D(("CCChangeHook(0x%lx)\n", ior));
    ObtainSemaphore(&cu->cu_ChangeSemaphore);
    if (ior->io_Length == 1) {
	D(("install hook 0x%lx\n", ior->io_Data));
	AddTail(&cu->cu_ChangeHooks, ior->io_Data);
    }
    else if (ior->io_Length == 0) {
	D(("remove hook 0x%lx\n", ior->io_Data));
	Remove(ior->io_Data);
    }
    else {
	ior->io_Error = IOERR_BADLENGTH;
    }
    ReleaseSemaphore(&cu->cu_ChangeSemaphore);

    endIO(ior);
}


/*********************************************************************
**********************************************************************
*
*	Device Functions
*
**********************************************************************
*********************************************************************/


/****i* clipboard.device/Open ****************************************
*
*   NAME
*	Open - a request to open the clipboard device
*
*   SYNOPSIS
*	OpenDevice("clipboard.device", unit, iORequest, 0), sysBase
*
*   FUNCTION
*	The open routine grants access to a device.  There are two
*	fields in the iORequest block that will be filled in:
*	io_Device and io_Unit.
*
*	A successful OpenDevice call must be matched by a CloseDevice
*	call when access to the device is no longer needed.
*
*   RESULTS
*	If the open was unsuccessful, OpenDevice returns a non-zero
*	result and the iORequest is not valid.
*
*********************************************************************/

#define	po_Task		mn_ReplyPort
#define	po_SigBit	mn_Node.ln_Pri

COpen(unitNum, ior, cd)
ULONG unitNum;
struct IOClipReq *ior;
struct Library *cd;
{
    struct ClipboardUnit *cu;
    struct Node *loopNode;
    struct Node *insert;
    struct Message *po;
    ULONG  diskFile;
    struct ClipBlock *block;
    int    length;

    D(("COpen(0x%lx, 0x%lx);\n", unitNum, ior));
    ObtainSemaphore(&cd_SS);
    cd->lib_Flags &= ~LIBF_DELEXP;
    cu = (struct IOClipReq *) cd_Units.lh_Head;
    loopNode = cu->cu_CUP.cu_Node.ln_Succ;
    insert = cu;
    while (loopNode) {
	if (cu->cu_CUP.cu_UnitNum < unitNum) {
	    /* still looking */
	    cu = (struct IOClipReq *) loopNode;
	    loopNode = cu->cu_CUP.cu_Node.ln_Succ;
	    insert = cu;
	}
	else {
	    if (cu->cu_CUP.cu_UnitNum == unitNum)
		/* found the unit */
		insert = 0;
	    /* indicate to stop looking */
	    loopNode = 0;
	}
    }
    if (insert) {
	D(("    insert new unit at 0x%lx.\n", insert->ln_Pred));
	/* insert new unit */
	if ((cu = (struct ClipboardUnit *)
		AllocMem(sizeof(*cu), MEMF_PUBLIC+MEMF_CLEAR)) == 0) {
	    D(("    error: no memory for unit\n"));
	    ior->io_Error = IOERR_OPENFAIL;
	    ReleaseSemaphore(&cd_SS);
	    return(-1);
	}
	cu->cu_CUP.cu_Node.ln_Name = "clipboard.unit";
	cu->cu_CUP.cu_UnitNum = unitNum;
	cu->cu_OpenCnt = 1;
	NewList(&cu->cu_PendingOpens.mp_MsgList);
	cu->cu_PendingID = 1;
	cu->cu_ProcessingID = 1;
	cu->cu_OpenFlags = OPEN_PROGRESSING;
	NewList(&cu->cu_BlockHead);
	cu->cu_CutValid = FALSE;	/* just a guess */
	NewList(&cu->cu_ReadPending);
	NewList(&cu->cu_CutPending);
	InitSemaphore(&cu->cu_ChangeSemaphore);
	NewList(&cu->cu_ChangeHooks);

	cd->lib_OpenCnt++;
	ior->io_Unit = cu;
	Insert(&cd_Units, cu, insert->ln_Pred);

	/* try to copy disk clip to ram */
	if (diskFile = openDiskClip(cu, MODE_OLDFILE)) {
	    D(("        0x%06lx\n", diskFile));
	    if (Seek(diskFile, 4, OFFSET_BEGINING) != -1) {
		if (Read(diskFile, &length, 4) == 4) {
		    cu->cu_CutValid = TRUE;		/* just a guess */
		    length += 8;
		    cu->cu_CurrentLength = length;
		    if (Seek(diskFile, 0, OFFSET_BEGINING) == -1)
			    cu->cu_CutValid = FALSE;
		    while (cu->cu_CutValid && (length > BLOCKSIZE)) {
			if ((block = (struct ClipBlock *)newTailBlock(cu)) == 0)
				cu->cu_CutValid = FALSE;
			else {
			    if (Read(diskFile, block->cb_Data, BLOCKSIZE) != 
				    BLOCKSIZE) cu->cu_CutValid = FALSE;
			}
			length -= BLOCKSIZE;
		    }
		    if (cu->cu_CutValid && (length > 0)) {
			if ((block = (struct ClipBlock *)newTailBlock(cu)) == 0)
				cu->cu_CutValid = FALSE;
			else {
			    if (Read(diskFile, block->cb_Data, length) != 
				    length) cu->cu_CutValid = FALSE;
			}
		    }
		    if (!cu->cu_CutValid) {
			clearClip(cu);
			if (Seek(diskFile, cu->cu_CurrentLength,
				OFFSET_BEGINING) == 0) {
			    /* make the clip a disk clip */
			    cu->cu_DiskFile = diskFile;
			    diskFile = 0;
			    cu->cu_CutValid = 0;
			}
		    }
		}
	    }
	    D(("        Close(0x%06lx);\n", diskFile));
	    if (diskFile)
		Close(diskFile);
	}
	if (!(cu->cu_CutValid)) cu->cu_CurrentLength = 0;
	D(("    cu_CurrentLength %ld\n", cu->cu_CurrentLength));
	/* Forbid should be re-instated by here */
	/******/
	cu->cu_OpenFlags = OPEN_OK;
	while (po = (struct Message *) GetMsg(&cu->cu_PendingOpens)) {
	    Signal(po->po_Task, 1<<po->po_SigBit);
	}
    }
    else {
	cu->cu_OpenCnt++;
	cd->lib_OpenCnt++;
	ior->io_Unit = cu;
	if (cu->cu_OpenFlags == OPEN_PROGRESSING) {
	    /* wait for someone else to create the unit file */
	    {
		struct Message wpo;
		wpo.po_Task = (struct MsgPort *) FindTask(0);
		wpo.po_SigBit = AllocSignal(-1);
		PutMsg(&cu->cu_PendingOpens, &wpo);
		Wait(1<<wpo.po_SigBit);
		FreeSignal(wpo.po_SigBit);
	    }
	}
    }
    D(("    unit # %ld at 0x%lx\n", cu->cu_CUP.cu_UnitNum, cu));
    ReleaseSemaphore(&cd_SS);
    return(ior->io_Error);
}


/****i* clipboard.device/Close ***************************************
*
*   NAME
*	Close - terminate access to the clipboard device
*
*   SYNOPSIS
*	CloseDevice(iORequest), sysBase
*
*   FUNCTION
*	The close routine notifies the clipboard device that the
*	iORequest will no longer be used.
*
*********************************************************************/

CClose(ior, cd)
struct IOClipReq *ior;
struct Library *cd;
{
    struct ClipboardUnit *cu;
    struct ClipBlock *block;
    int    length;

    cu = (struct ClipboardUnit *) ior->io_Unit;
    ObtainSemaphore(&cd_SS);
    D(("CClose(0x%lx);\n", ior));
    if (--(cu->cu_OpenCnt) == 0) {
	/* last accessor to this unit, shut it down */
	if ((cu->cu_CutValid) && (!(cu->cu_DiskFile)) &&
		(cu->cu_ProcessingID > 1) &&
		(cu->cu_DiskFile = openDiskClip(cu, MODE_NEWFILE))) {
	    /* write out the current cut to disk */
	    length = cu->cu_CurrentLength;
	    block = (struct ClipBlock *)
		    cu->cu_BlockHead.lh_Head;
	    while (cu->cu_CutValid && (length > 0)) {
		if (block->cb_Node.ln_Succ) {
		    if (length > BLOCKSIZE) {
			if (Write(cu->cu_DiskFile, block->cb_Data,
				BLOCKSIZE) != BLOCKSIZE)
				cu->cu_CutValid = FALSE;
			length -= BLOCKSIZE;
		    }
		    else {
			if (Write(cu->cu_DiskFile, block->cb_Data,
				length) != length)
				cu->cu_CutValid = FALSE;
			length = 0;
		    }
		    block = block->cb_Node.ln_Succ;
		}
		else cu->cu_CutValid = FALSE;
	    }
	}
	if (cu->cu_DiskFile) {
	    D(("        about to Close(0x%lx);\n", cu->cu_DiskFile));
	    Close(cu->cu_DiskFile);
	    if ((!cu->cu_CutValid) || (cu->cu_CurrentLength == 0)) {
		DeleteFile(cu->cu_DiskFileName);
	    }
	}
	clearClip(cu);
	Remove(cu);
	FreeMem(cu, sizeof(*cu));
    }

    /* back in Forbid() */

    ior->io_Unit = ior->io_Device = 0;
    --cd->lib_OpenCnt;

    /* Release won't break Forbid() */

    ReleaseSemaphore(&cd_SS);
}


/****i* clipboard.device/Expunge *************************************
*
*   NAME
*	Expunge - indicate a desire to remove the clipboard device
*
*   SYNOPSIS
*	<Expunge is not generally called by application programs>
*
*   FUNCTION
*	The Expunge routine is called when the system needs the memory
*	used by the clipboard device, and the clipboard device has no
*	open units.  The clipboard device is removed from memory until
*	next needed (i.e. until the next
*	OpenDevice("clipboard.device", ...);
*
*********************************************************************/

CExpunge(cd)
struct Library *cd;
{
    if (cd->lib_OpenCnt == 0) {
	CloseLibrary(DOSBase);
	Remove(cd);
	freeCD(cd);
	return(cd_Segment);
    }
    else {
	cd->lib_Flags |= LIBF_DELEXP;
	return(0);
    }
}


/****i* clipboard.device/BeginIO *************************************
*
*   NAME
*	BeginIO - initiate clipboard device IO
*
*   SYNOPSIS
*	SendIO(iORequest), sysBase
*	DoIO(iORequest), sysBase
*
*   FUNCTION
*	The BeginIO is the workhorse device function used to initiate
*	device commands.  It can be called directly or via the exec
*	library functions SendIO and DoIO.
*
*********************************************************************/
int (*commandVector[])() = {
    CCInvalid, CCReset, CCRead, /* CCWrite: */ CCCut, /* CCUpdate */ CCCut,
    CCClear, CCStop, CCStart, CCFlush,
    /* CCPost: */ CCCut, CCCurrentReadID, CCCurrentWriteID, CCChangeHook
};

CBeginIO(ior)
struct IOClipReq *ior;
{
    Forbid();
    ior->io_Message.mn_Node.ln_Type = NT_MESSAGE;
    ior->io_Flags &= ~(IOF_DONE | IOF_QUEUED | IOF_PENDINGREAD);
    if (ior->io_Command >= (sizeof(commandVector)/sizeof(commandVector[0]))) {
	CCInvalid(ior);
    }
    else {
	(*(commandVector[ior->io_Command]))(ior);
    }
    Permit();
}

CAbortIO(ior)
struct IOClipReq *ior;
{
    Forbid();
    if ((!(ior->io_Flags & IOF_DONE)) && (!(ior->io_Flags & IOF_ACTIVE))) {
	ior->io_Error = IOERR_ABORTED;
	if (ior->io_Flags & IOF_QUEUED) 
	    Remove(ior);
	endIO(ior);
    }
    Permit();
}
@


36.8
log
@CMD_RESET does nothing; make it private.
@
text
@d2 1
a2 1
**	$Header: /usr.MC68010/ghostwheel/darren/clipboard/RCS/dev.c,v 36.7 90/11/26 16:23:56 darren Exp Locker: darren $
d56 1
d135 1
d1207 1
a1207 1
    Forbid();
d1234 1
a1234 1
	    Permit();
d1324 1
a1324 1
    Permit();
d1352 1
a1352 1
    Forbid();
d1393 3
d1397 5
a1401 8
    if ((--(cd->lib_OpenCnt) == 0) &&
	/* last accessor for this device, pending expunge? */
	    (cd->lib_Flags & LIBF_DELEXP)) {
	/* expunge the device */
	D(("    CClose calling CExpunge.\n"));
	CExpunge(cd);
    }
    Permit();
@


36.7
log
@Clears io_Error field now as all good devices
should.
@
text
@d2 1
a2 1
**	$Header: /usr.MC68010/machines/heartofgold/amiga/V36/src/workbench/devs/clipboard/RCS/dev.c,v 36.6 90/11/02 14:03:04 darren Exp Locker: darren $
d796 1
a796 1
/****** clipboard.device/CMD_RESET ***********************************
@


36.6
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Header: /usr.MC68010/machines/heartofgold/amiga/V36/src/workbench/devs/clipboard/RCS/dev.c,v 36.5 90/03/03 17:39:04 kodiak Exp Locker: darren $
d882 1
d1020 1
@


36.5
log
@new AUTOINIT version
@
text
@d2 1
a2 1
**	$Header: dev.c,v 36.4 90/02/28 16:03:00 kodiak Exp $
@


36.4
log
@make null io_Data, huge io_Length work for ~0
@
text
@d2 1
a2 1
**	$Header: dev.c,v 36.3 90/02/26 15:12:27 kodiak Exp $
a26 1
#include	"clipboard_rev.h"
a34 7
extern	int AOpen();
extern	int AClose();
extern	int AExpunge();
extern	int AExtFunc();
extern	int ABeginIO();
extern	int AAbortIO();

a37 2
extern	char *AName;
extern	char *AIdent;
a38 30
#define	JMP	0x4ef9

/* clipboard device node */
struct {
    struct {
	UWORD	jmp;
	int	(*(function))();
    } libFunctions[6];
    struct Library cd;
} cdn = {
    /* library functions */
    {
	{ JMP, AAbortIO },
	{ JMP, ABeginIO },
	{ JMP, AExtFunc },
	{ JMP, AExpunge },
	{ JMP, AClose },
	{ JMP, AOpen }
    }
    /* Library */
    {
	/* lib_Node */
	{ 
	    0, 0, NT_DEVICE, 0, "clipboard.device"
	},
	LIBF_SUMUSED|LIBF_CHANGED, 0, 36, sizeof(cdn.cd),
	VERSION, REVISION, VSTRING, 0, 0
    }
};

d99 17
a115 1
CInit(segment, sysBase)
d119 3
d124 4
a127 2
	    == 0)
	return(FALSE);
d130 2
a131 1
	return(FALSE);
d135 2
a136 3
    AddDevice(&cdn.cd);
    D(("CInit: device node 0x%lx\n", &cdn.cd));
    return(TRUE);
d1189 1
a1189 1
COpen(unitNum, ior)
d1192 1
d1204 1
a1204 1
    cdn.cd.lib_Flags &= ~LIBF_DELEXP;
d1247 1
a1247 1
	cdn.cd.lib_OpenCnt++;
d1305 1
a1305 1
	cdn.cd.lib_OpenCnt++;
d1339 1
a1339 1
CClose(ior)
d1341 1
d1390 1
a1390 1
    if ((--(cdn.cd.lib_OpenCnt) == 0) &&
d1392 1
a1392 1
	    (cdn.cd.lib_Flags & LIBF_DELEXP)) {
d1395 1
a1395 1
	CExpunge();
d1418 2
a1419 1
CExpunge()
d1421 1
a1421 1
    if (cdn.cd.lib_OpenCnt == 0) {
d1423 2
a1424 1
	Remove(&cdn.cd);
d1428 1
a1428 1
	cdn.cd.lib_Flags |= LIBF_DELEXP;
@


36.3
log
@add chm_ChangeCmd to hook message
@
text
@d2 1
a2 1
**	$Header: dev.c,v 36.2 90/02/26 15:01:28 kodiak Exp $
d649 4
a652 2
			if (wior->io_Offset + wior->io_Length <
				cu->cu_CurrentLength)
@


36.2
log
@add CBD_CHANGEHOOK command
@
text
@d2 1
a2 1
**	$Header$
d622 1
a622 1
		callHook(hook, cu, 0, cu->cu_ProcessingID);
d721 1
a721 1
		    callHook(hook, cu, 0, cu->cu_ProcessingID);
@


36.1
log
@plug memory leak when clips: assigned to disk file
@
text
@d1 13
a13 19
/*********************************************************************/
/*                                                                   */
/*                     Copyright (c) 1985                            */
/*                    Commodore-Amiga, Inc.                          */
/*                    All rights reserved.                           */
/*                                                                   */
/*     No part of this program may be reproduced, transmitted,       */
/*     transcribed, stored in retrieval system, or translated        */
/*     into any language or computer language, in any form or        */
/*     by any means, electronic, mechanical, magnetic, optical,      */
/*     chemical, manual or otherwise, without the prior written      */
/*     permission of:                                                */
/*                     Commodore-Amiga, Inc.                         */
/*                     983 University Ave #D                         */
/*                     Los Gatos, CA. 95030                          */
/*                                                                   */
/*********************************************************************/
/*#define  D(a)	kprintf a*/
#define  D(a)
d23 3
a25 2
#include        "libraries/dos.h"
#include        "libraries/dosextens.h"
d93 1
d133 3
d144 2
a145 1
    if ((DOSBase = (struct Library *) OpenLibrary("dos.library", 0)) == 0)
d147 4
a152 7
    Forbid();
    if (FindName(&sysBase->DeviceList, cdn.cd.lib_Node.ln_Name)) {
	D(("CInit abort: CloseLibrary(DOSBase = 0x%lx);\n", DOSBase));
	CloseLibrary(DOSBase);
	Permit();
	return(FALSE);
    }
d154 1
a154 2
    Permit();
    D(("CInit success: device node 0x%lx\n", &cdn.cd));
d456 9
d479 1
a479 1
    D(("a(%ld) e(%ld) ", io->io_Actual, io->io_Error));
d538 1
d617 9
d715 11
d1121 51
d1260 2
d1465 1
a1465 1
    /* CCPost: */ CCCut, CCCurrentReadID, CCCurrentWriteID
@


36.0
log
@autodoc changes
@
text
@d18 2
d151 1
a151 3
#ifdef	DEBUG
kprintf("CInit abort: CloseLibrary(DOSBase = 0x%lx);\n", DOSBase);
#endif
d158 1
a158 3
#ifdef	DEBUG
kprintf("CInit success: device node 0x%lx\n", &cdn.cd);
#endif
d178 1
a178 3
#ifdef	DEBUG
kprintf("newTailBlock(0x%06lx): ", cu);
#endif
d193 1
a193 3
#ifdef	DEBUG
kprintf("# %ld ", newBlock->cb_BlockNum);
#endif
d199 1
a199 3
#ifdef	DEBUG
kprintf("@@ 0x%06lx\n", newBlock);
#endif
d255 1
a255 3
#ifdef	DEBUG
kprintf("clearClip(0x%06lx);\n", cu);
#endif
d259 1
d281 1
a281 3
#ifdef	DEBUG
kprintf("r(0x%06lx, %ld, %ld): ", data, length, offset);
#endif
d314 2
a315 3
#ifdef	DEBUG
kprintf("\nnew read block: 0x%06lx, # %ld\n", block, block->cb_BlockNum);
#endif
d324 2
a325 3
#ifdef	DEBUG
kprintf("\ncont'd. read block: 0x%06lx, # %ld\n", block, block->cb_BlockNum);
#endif
d359 1
a359 3
#ifdef	DEBUG
kprintf("w(0x%06lx, %ld, %ld): ", data, length, offset);
#endif
d361 1
a361 3
#ifdef	DEBUG
if (!(cu->cu_CutValid)) kprintf("CUT NOT VALID!\n");
#endif
d398 1
a398 3
#ifdef	DEBUG
kprintf("(write to disk) ");
#endif
d427 2
a428 3
#ifdef	DEBUG
kprintf("\n    finish block: %ld to %ld\n    next block ", index, BLOCKSIZE);
#endif
d436 1
a436 3
#ifdef	DEBUG
kprintf("(NEW) ");
#endif
d441 2
a442 3
#ifdef	DEBUG
kprintf("\n    index now zero, actual %ld, and length %ld\n", actual, length);
#endif
d474 1
a474 3
#ifdef	DEBUG
kprintf("a(%ld) e(%ld) ", io->io_Actual, io->io_Error);
#endif
d501 1
a501 3
#ifdef	DEBUG
kprintf("R #%ld \\ W #%ld\n", wior2->io_ClipID, wior1->io_ClipID);
#endif
d538 1
a538 3
#ifdef	DEBUG
kprintf("doWork(0x%lx); ", cu);
#endif
d542 1
a542 3
#ifdef	DEBUG
kprintf("/ locked\n");
#endif
d548 1
a548 3
#ifdef	DEBUG
kprintf("%ld ", cu->cu_ProcessingCommand);
#endif
d570 1
a570 3
#ifdef	DEBUG
kprintf("        about to Close(0x%lx);\n", cu->cu_DiskFile);
#endif
d697 1
a697 3
#ifdef	DEBUG
kprintf("    UPDATE cu_CurrentLength %ld\n", cu->cu_CurrentLength);
#endif
d707 1
a707 3
#ifdef	DEBUG
kprintf(".\n");
#endif
d749 1
a749 3
#ifdef	DEBUG
kprintf("CCInvalid(0x%lx);\n", ior);
#endif
d758 1
a758 3
#ifdef	DEBUG
kprintf("CCClear(0x%lx);\n", ior);
#endif
d766 1
a766 3
#ifdef	DEBUG
kprintf("CCStop(0x%lx);\n", ior);
#endif
d774 1
a774 3
#ifdef	DEBUG
kprintf("CCStart(0x%lx);\n", ior);
#endif
d782 1
a782 3
#ifdef	DEBUG
kprintf("CCFlush(0x%lx);\n", ior);
#endif
d807 1
a807 3
#ifdef	DEBUG
kprintf("CCReset(0x%lx);\n", ior);
#endif
d869 1
a869 3
#ifdef	DEBUG
kprintf("CCRead(0x%lx)...", ior);
#endif
d876 1
a876 3
#ifdef	DEBUG
kprintf("    clip id %ld is obsolete\n", ior->io_ClipID);
#endif
d1008 1
a1008 3
#ifdef	DEBUG
kprintf("CCCut(0x%lx)...", ior);
#endif
d1011 1
a1011 3
#ifdef	DEBUG
kprintf("    ClipID %ld assigned\n", ior->io_ClipID);
#endif
d1015 1
a1015 3
#ifdef	DEBUG
kprintf("    clip id %ld is obsolete\n", ior->io_ClipID);
#endif
d1141 1
a1141 3
#ifdef	DEBUG
kprintf("COpen(0x%lx, 0x%lx);\n", unitNum, ior);
#endif
d1163 1
a1163 3
#ifdef	DEBUG
kprintf("    insert new unit at 0x%lx.\n", insert->ln_Pred);
#endif
d1167 1
a1167 3
#ifdef	DEBUG
kprintf("    error: no memory for unit\n");
#endif
d1190 1
a1190 3
#ifdef	DEBUG
kprintf("        0x%06lx\n", diskFile);
#endif
d1227 1
a1227 3
#ifdef	DEBUG
kprintf("        Close(0x%06lx);\n", diskFile);
#endif
d1232 1
a1232 3
#ifdef	DEBUG
kprintf("    cu_CurrentLength %ld\n", cu->cu_CurrentLength);
#endif
d1256 1
a1256 3
#ifdef	DEBUG
kprintf("    unit # %ld at 0x%lx\n", cu->cu_CUP.cu_UnitNum, cu);
#endif
d1285 1
a1285 3
#ifdef	DEBUG
kprintf("CClose(0x%lx);\n", ior);
#endif
d1315 1
a1315 3
#ifdef	DEBUG
kprintf("        about to Close(0x%lx);\n", cu->cu_DiskFile);
#endif
d1321 1
a1321 3
	else {
	    clearClip(cu);
	}
d1330 1
a1330 3
#ifdef	DEBUG
kprintf("    CClose calling CExpunge.\n");
#endif
@


35.1
log
@support for CLIPS: assign
@
text
@d836 1
a836 1
/****** clipboard.device/Reset ***************************************
d839 1
a839 1
*	Reset - reset the clipboard
d842 1
a842 1
*	Reset resets the clipboard device without destroying handles
d865 1
a865 1
/****** clipboard.device/Read ****************************************
d868 1
a868 1
*	Read - read clip from clipboard
d943 1
a943 1
/****** clipboard.device/Write ***************************************
d946 1
a946 1
*	Write - write clip to clipboard
d956 1
a956 1
*	Post, then the io_ClipID returned by the Post command must
d981 1
a981 1
/****** clipboard.device/Update **************************************
d984 1
a984 1
*	Update - terminate the writing of a cut to the clipboard
d1004 1
a1004 1
/****** clipboard.device/Post ****************************************
d1007 1
a1007 1
*	Post - post clip to clipboard
d1028 3
a1030 3
*	post's io_ClipID with that returned by the CurrentReadID
*	command.  If CurrentReadID is greater, the clip is not still
*	current.
d1035 2
a1036 2
*	CurrentWriteID command.  If CurrentWriteID is greater, there
*	is no need to satisfy the post.
d1088 1
a1088 1
/****** clipboard.device/CurrentReadID *******************************
d1091 1
a1091 1
*	CurrentReadID - determine the current read identifier.
d1094 1
a1094 1
*	CurrentReadID fills the io_ClipID with a clip identifier that
d1103 1
a1103 1
*	io_Command	CMD_CLIPREADID
d1105 1
a1105 1
* 
d1122 1
a1122 1
/****** clipboard.device/CurrentWriteID ******************************
d1125 1
a1125 1
*	CurrentWriteID - determine the current write identifier.
d1128 1
a1128 1
*	CurrentWriteID fills the io_ClipID with a clip identifier that
d1137 1
a1137 1
*	io_Command	CMD_CLIPWRITEID
d1139 1
a1139 1
* 
d1165 1
a1165 1
/****** clipboard.device/Open ****************************************
d1337 1
a1337 1
/****** clipboard.device/Close ***************************************
d1420 1
a1420 1
/****** clipboard.device/Expunge *************************************
d1451 1
a1451 1
/****** clipboard.device/BeginIO *************************************
@


35.0
log
@from V33
@
text
@d28 1
d123 1
d211 9
d221 37
a371 3
    int lock1, lock2;
    char pathName[32];

d384 1
a384 16
#ifdef	DEBUG
kprintf("\n    convert clip to diskfile %s\n", pathName);
#endif
	/* convert the clip to a disk file */
	if ((lock1 = Lock("DEVS:", SHARED_LOCK)) != 0) {
	    if ((lock2 = Lock("DEVS:clipboards", SHARED_LOCK)) == 0) {
		lock2 = CreateDir("DEVS:clipboards");
	    }
	    if (lock2 != 0) {
		sprintf(pathName, "DEVS:clipboards/%ld", cu->cu_CUP.cu_UnitNum);
		cu->cu_DiskFile = Open(pathName, MODE_NEWFILE);
		UnLock(lock2);
	    }
	    UnLock(lock1);
	}
	if (cu->cu_DiskFile) {
a561 1
    char   pathName[32];
d608 1
a608 3
			sprintf(pathName, "DEVS:clipboards/%ld",
				cu->cu_CUP.cu_UnitNum);
			DeleteFile(pathName);
a1197 1
    char   pathName[32];
d1256 1
a1256 1
	sprintf(pathName, "DEVS:clipboards/%ld", cu->cu_CUP.cu_UnitNum);
d1258 1
a1258 1
kprintf("        Open(\"%s\", MODE_OLDFILE): ", pathName);
a1259 4
	if (diskFile = Open(pathName, MODE_OLDFILE)) {
#ifdef	DEBUG
kprintf("            0x%06lx\n", diskFile);
#endif
a1354 3
    ULONG  diskFile;
    int    lock1, lock2;
    char   pathName[32];
a1356 3
#ifdef	DEBUG
int i;
#endif
a1357 1

d1365 14
a1378 6
	sprintf(pathName, "DEVS:clipboards/%ld", cu->cu_CUP.cu_UnitNum);
	if ((cu->cu_CutValid) && (!(cu->cu_DiskFile))) {
	    if (cu->cu_ProcessingID > 1) {
		if ((lock1 = Lock("DEVS:", SHARED_LOCK)) != 0) {
		    if ((lock2 = Lock("DEVS:clipboards", SHARED_LOCK)) == 0) {
			lock2 = CreateDir("DEVS:clipboards");
d1380 5
a1384 30
		    if (lock2 != 0) {
			diskFile = Open(pathName, MODE_NEWFILE);
			if (diskFile) {
			    length = cu->cu_CurrentLength;
			    block = (struct ClipBlock *)
				    cu->cu_BlockHead.lh_Head;
			    while (cu->cu_CutValid && (length > 0)) {
				if (block->cb_Node.ln_Succ) {
				    if (length > BLOCKSIZE) {
					if (Write(diskFile, block->cb_Data,
						BLOCKSIZE) != BLOCKSIZE)
						cu->cu_CutValid = FALSE;
					length -= BLOCKSIZE;
				    }
				    else {
					if (Write(diskFile, block->cb_Data,
						length) != length)
						cu->cu_CutValid = FALSE;
					length = 0;
				    }
				    block = block->cb_Node.ln_Succ;
				}
				else cu->cu_CutValid = FALSE;
			    }
#ifdef	DEBUG
kprintf("        about to Close(0x%lx);\n", diskFile);
#endif
			    Close(diskFile);
			}
			UnLock(lock2);
d1386 1
a1386 1
		    UnLock(lock1);
d1388 1
d1396 3
a1401 3
	}
	if ((!cu->cu_CutValid) || (cu->cu_CurrentLength == 0)) {
	    DeleteFile(pathName);
@
