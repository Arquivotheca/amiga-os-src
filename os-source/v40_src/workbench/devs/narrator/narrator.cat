	TTL	'$Header: device.asm,v 36.0 88/03/01 15:00:31 kodiak Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: device.asm,v 36.0 88/03/01 15:00:31 kodiak Exp $
*
* $Locker:  $
*
* $Log:	device.asm,v $
*   Revision 36.0  88/03/01  15:00:31  kodiak
*   IO_FLAGS maintained by device
*   
*   Revision 35.0  88/02/22  16:05:07  kodiak
*   initial from V33.old
*   
* Revision 32.1  86/01/22  00:23:17  sam
* placed under source control
* 
*
**********************************************************************
               SECTION speech
_AbsExecBase	EQU	4


* ***** Included Files ***********************************************


	INCLUDE 'assembly.i'
 	INCLUDE 'exec/types.i'
	INCLUDE 'exec/nodes.i'
	INCLUDE 'exec/lists.i'
	INCLUDE 'exec/strings.i'
	INCLUDE 'exec/initializers.i'
	INCLUDE 'exec/memory.i'
	INCLUDE 'exec/interrupts.i'
	INCLUDE 'exec/ports.i'
	INCLUDE 'exec/libraries.i'
	INCLUDE 'exec/devices.i'
	INCLUDE 'exec/io.i'
	INCLUDE 'exec/tasks.i'
	INCLUDE 'exec/resident.i'
	INCLUDE 'hardware/custom.i'
	INCLUDE 'hardware/dmabits.i'
	INCLUDE 'exec/execbase.i'
	INCLUDE 'exec/ables.i'
	INCLUDE 'exec/errors.i'

io_Size	EQU	IO_SIZE
        INCLUDE	'featequ.i'
        INCLUDE	'gloequs.i'
	INCLUDE	'devices/audio.i'
	INCLUDE	'narrator.i'
	INCLUDE	'private.i'
        INCLUDE	'narrator_rev.i'


* ****** Imported Globals *********************************************




* ****** Imported Functions *******************************************

	EXTERN_SYS SendIO
	EXTERN_SYS DoIO
	EXTERN_SYS AddDevice
	EXTERN_SYS RemDevice
	EXTERN_SYS AddTask
	EXTERN_SYS RemTask
	EXTERN_SYS AddHead
	EXTERN_SYS AddTail
	EXTERN_SYS AllocMem
	EXTERN_SYS AllocEntry
	EXTERN_SYS AllocSignal
	EXTERN_SYS AllocAudChan
	EXTERN_SYS StartAudDMA
	EXTERN_SYS StopAudDMA
	EXTERN_SYS FreeAudChan
	EXTERN_SYS Disable
	EXTERN_SYS Enable
	EXTERN_SYS FreeMem
	EXTERN_SYS FreeEntry
	EXTERN_SYS MakeLibrary
	EXTERN_SYS PutFmt
	EXTERN_SYS PutMsg
	EXTERN_SYS ReplyMsg
	EXTERN_SYS Signal
	EXTERN_SYS Wait
	EXTERN_SYS OpenLibrary
	EXTERN_SYS CloseLibrary
	EXTERN_SYS OpenDevice
	EXTERN_SYS CloseDevice
	EXTERN_SYS GetMsg
	EXTERN_SYS FindTask

        EXTERN_DATA _intena

* ****** Exported Functions *******************************************

*	XDEF	_Init
*	XDEF	_Expunge
	XDEF	BeginIO


* ***** Local Definitions **********************************************



	XDEF	Open
	XDEF	Close
 	XDEF	PerformIO
	XDEF	Null
	XDEF	TermIO

	XREF	SDTaskStart
	XREF	INITIAL
 	XREF	endMarker,NarratorName,NarratorIdStr
	XREF	Narrator



* ****** Device/Speech/Initialize **********************************
*
*   NAME
*	Initialize -- initialize the device from nothing
*
*
*   SYNOPSIS
*	Error = Initialize(), SysLib
*	D0		  	A6
*
*
*   FUNCTION
*	Initialize the speech driver at system startup.  This
*	routine is called from OpenDevice if the code is not RAM
*	resident.  THIS ENTRY POINT MUST BE THE FIRST ADDRESS OF
*	THE DRIVER CODE.
*
*
*   INPUTS
*	A6 - Pointer to SysLib
*
*
*   RESULTS
*	0 if init failed, else -1
*	otherwise.
*
*
*   SEE ALSO
*
*
* *********************************************************************
*
*
*   REGISTER USAGE
*
*
*   IMPLEMENTATION
*
*


Init:

		MOVEM.L A2-A6/D3,-(SP)
		MOVE.L	A0,D3				;Cache the segment list

		MOVE.L	_AbsExecBase,A6


Init_OpenOK:
*		;------ Call the library initialization routine
		LEA	devFuncInit(PC),A0
		LEA	devStructInit(PC),A1
		SUB.L   A2,A2
		MOVE.L	#ND_SIZE,D0
		CALLSYS MakeLibrary
		TST.L	D0
		BEQ	Init_Err


Init_Success:
*		;------ Managed to get this far, everything else should be simple
		MOVE.L	D0,A2			;Copy device pointer
		MOVE.L  A2,A4			;Store pointer to my device node
		MOVE.L  A6,ND_SYSLIB(A2)	;Store pointer to system library
		MOVE.L	D3,ND_SEGLIST(A2)	;Store segment list pointer


*		;------ Initialize the task msgport list
		LEA	ND_UNIT+MP_MSGLIST(A2),A0
		NEWLIST A0


*		;------	Initialize the pseudo-unit counter
		MOVE.L	#0,ND_PSEUDO(A2)


*		;------	Create msgport for audio commands
		MOVE.L	#MP_SIZE,D0				;Get mem
		MOVE.L	#MEMF_PUBLIC+MEMF_CLEAR,D1
		CALLSYS	AllocMem
		TST.L	D0
		BEQ	Init_Err

Init_MP2:	MOVE.L	D0,A3
		MOVE.L	A3,ND_CMSGPORT(A2)
		MOVE.B	#NT_MSGPORT,MP+LN_TYPE(A3)		;Initialize port
		LEA	cportname,A1
		MOVE.L	A1,MP+LN_NAME(A3)
		MOVEQ	#-1,D0
		CALLSYS	AllocSignal
		MOVE.B	D0,MP_SIGBIT(A3)
		SUB.L	A1,A1
		CALLSYS	FindTask
		MOVE.L	D0,MP_SIGTASK(A3)
		LEA	MP_MSGLIST(A3),A0
		NEWLIST	A0


*		;------ Create task stack
		LEA	ND_TCB(A2),A1		;Get TCB pointer
		LEA	ND_STACK(A2),A0		;Get top of stack
		MOVE.L	A0,TC_SPLOWER(A1)	;Store in TCB
		LEA	ND_STACKSIZE(A0),A0	;Compute top of stack
		MOVE.L	A0,TC_SPUPPER(A1)	;Store in TCB
		MOVE.L	A2,-(A0)		;Device node (parm to task at startup)
		MOVE.L	A0,TC_SPREG(A1)		;Current stack pointer


*		;------ Add task to system (A1 already points to TCB)
		LEA	SDTaskStart,A2		;Startup task
		SUB.L	A3,A3			;Finalizer routine
		CALLSYS	AddTask
	

*		;------ Add the device
		MOVE.L	A4,A1
		CALLSYS AddDevice


*		;------ Everything worked, return non-zero
		MOVEQ   #-1,D0

Init_End:
		MOVEM.L (SP)+,A2-A6/D3
		RTS

Init_Err:
		MOVEQ	#0,D0
		BRA.S	Init_End



******* Device/Speech/Open ****************************************
*
*   NAME
*	OpenDevice - open the narrator device.
*
*   SYNOPSIS
*	error = OpenDevie("narrator.device", 0, IORequest, 0);
*
*   FUNCTION
*	The OpenDevice routine grants access to the narrator device.
*	OpenDevice checks the unit number, and if non-zero, returns
*	an error (ND_UnitErr).  If this is the first time the driver
*	has been opened, OpenDevice will attempt to open the audio
*	device and allocate the driver's static buffers.  If either
*	of these operations fail, an error is returned (see the .hi
*	files for possible error return codes).  Next, OpenDevice
*	(done for all opens, not just the first one) initializes the
*	user's IORequest block (IORB).  Default values for sex, rate,
*	pitch, pitch mode, sampling frequency, and mouths are set in
*	the appropriate fields of the IORB.  Note that if users wish
*	to use non-default values for these parms, the values must
*	be set after the open is done.  OpenDevice then assigns a
*	pseudo-unit number to the IORB for use in synchronizing read
*	and write requests.  See the read command for more details.
*	Finally, OpenDevice stores the device node pointer in the
*	IORB and clears the delayed expunge bit.
*
*   INPUTS
*	deviceName - must be "narrator.device"
*	unitNumber - must be 0
*	IORequest  - the user's IORB (need not be initialized)
*	flags	   - not used
*
*   RESULTS
*	IORB fields set:
*	   rate	   - 150 words/minute
*	   pitch   - 110 Hz
*	   mode	   - Natural
*	   sex     - Male
*	   mouths  - Off
*	   sampfreq - 22200
*	   volume  - 64 (max)
*	
*	error - same as io_Error field of IORB
*
*   SEE ALSO
*
*
**********************************************************************
*
*
*   REGISTER USAGE
*
*
*   IMPLEMENTATION
*
*


Open:		
		MOVEM.L	 A2/A3/A6,-(SP)


*		;------ Check the unit number, only 0 is valid
		TST.L	D0
		BEQ.S	Open_UnitOK
		MOVEQ   #ND_UnitErr,D0
		BRA	Open_Err

Open_UnitOK:
		MOVE.L	A1,A2				;Copy IORB pointer
                TST.W   LIB_OPENCNT(A6)		        ;Driver already open?
		BNE.S   Is_Open				;Yes


*               ;------ First time driver has been opened.

*		;	Open the audio device and allocate fixed buffers.
		LEA	AudioLib,A0			;Open the audio device
		LEA	ND_IORB3(A6),A1
		CLR.W   ioa_Length+2(A1)		;!!!sam 8/28/85!!!
		MOVEQ	#0,D0
		MOVEQ	#0,D1
		LINKSYS	OpenDevice
		TST.L	D0
		BEQ.S	Open_GotAudio
		MOVE.B	#ND_NoAudLib,D0
		BRA	Open_Err


*		;	Setup audio control IORB
Open_GotAudio:
		LEA	ND_IORB3(A6),A1
		MOVE.B	#NT_MESSAGE,MN+LN_TYPE(A1)		;Set type
		LEA	cportname,A0				;Set name
		MOVE.L	A0,MN+LN_NAME(A1)
		MOVE.L	ND_CMSGPORT(A6),ND_IORB3+MN_REPLYPORT(A6)

*		;	Allocate the fixed buffers
		MOVE.L	#FIXBFRSZ,D0			;Size of buffer
		MOVE.L  #MEMF_CLEAR+MEMF_CHIP,D1	;Get chip memory
		LINKSYS AllocMem			;Get buffer
		TST.L   D0				;Allocate successful?
		BNE.S   Open_GotBuffer			;Yes, branch
                MOVE.B  #ND_NoMem,D0			;No, return an error
		BRA     Open_Err

Open_GotBuffer	MOVE.L	D0,ND_GLOBALS(A6)


*		;------ Increment open counts and set default speaking parms
Is_Open 	ADDQ.W	#1,LIB_OPENCNT(A6)
*		DISABLE A0
		ADDQ.L	#1,ND_PSEUDO(A6)
		MOVE.L	ND_PSEUDO(A6),IO_UNIT(A2)
*		ENABLE	A0
		MOVE.W	#DEFSEX,NDI_SEX(A2)		;MALE SPEAKER
		MOVE.W	#DEFRATE,NDI_RATE(A2)		;MALE RATE
		MOVE.W	#DEFPITCH,NDI_PITCH(A2)		;MALE PITCH
		MOVE.W	#DEFMODE,NDI_MODE(A2)		;NATURAL F0 MODE
		CLR.B	NDI_MOUTHS(A2)			;No mouths for now
		MOVE.W	#DEFFREQ,NDI_SAMPFREQ(A2)	;Normal sampling frequency
		MOVE.W	#DEFVOL,NDI_VOLUME(A2)		;Normal speaking volume
		CLR.B	IO_ERROR(A2)			;Set noErr
		MOVE.L	A6,IO_DEVICE(A2)		;Save device node pointer in IORB


*		;------	New Opens clear the Expunge bit
		LEA	ND_UNIT(A6),A3			;Unit pointer
		BCLR	#UNITB_EXPUNGE,UNIT_FLAGS(A3)	;Clear Expunge bit


Open_End	MOVEM.L	(SP)+,A2/A3/A6
		RTS

Open_Err:
		MOVE.B	D0,IO_ERROR(A2)			;Return error
		MOVE.L	#-1,IO_DEVICE(A2)		;Invalidate devNode pointer
		BRA.S	Open_End




******* Device/Speech/Read **********************************
*
*   NAME
*	Read - Return the next different mouth shape from an 
*       associated write
*
*   SYNOPSIS
*	Standard device command.  See DoIO/SendIO.
*
*   FUNCTION
*	The read command of the narrator device returns mouth
*	shapes to the user.  The shape returned is guaranteed
*	to be differnt from the previously returned shape 
*	(allowing updating to be done only when something has
*	changed).  Each read request is associated with a 
*	write request by the pseudo-unit number assigned by
*	the OpenDevice call.  Since the first structure in
*	the read-mouth IORB is a narrator (write) IORB, this
*	association is easily made by copying the narrator 
*	IORB into the narrate_rb field fo the read IORB.
*	See the .hi files.  If there is no write in progress
*	or in the device input queue with the same pseudo-
*	unit number as the read request, the read will be
*	returned to the user with an error.  This is also
*	how the user knows that the write request has 
*	finished and that s/he should not issue any more
*	reads.  Note that in this case the mouth shapes may
*	not be different from previously returned values.
*
*   INPUTS
*	IORB with the narrator_rb structure copied from the
*	associated write request execpt for:
*	   io_Message - message port for read request
*	   io_Command - CMD_READ
*	   io_Error   - 0
*	   width      - 0
*	   height     - 0
*
*   RESULTS
*	IORB fields set:
*	   width  - mouth width in millimeters/3.67
*		    (division done for scaling)
*	   height - mouth height in millimeters
*	   shape  - compressed form of mouth shapes
*	  	    (internal use only)
*
*   SEE ALSO
*	Write command.
*
**********************************************************************
*
*
*   REGISTER USAGE
*
*
*   IMPLEMENTATION
*

Read:
		MOVEM.L	A3/A6,-(SP)
		MOVE.L	IO_DEVICE(A1),A3
		MOVE.L	_AbsExecBase,A6

*		;------	Clear IOB_QUICK.  This will cause DoIO to wait
		BCLR	#IOB_QUICK,IO_FLAGS(A1)

		
*		;------	If no write request is in progress, and the unit
*		;	is not stopped, return an error.
		LEA	ND_UNIT(A3),A0
		BTST	#UNITB_STOP,UNIT_FLAGS(A0)
		BNE.S	Read_AddTail
		MOVE.L	ND_USERIORB(A3),D0
		BNE.S	Read_withWrite
		MOVE.B	#ND_NoWrite,IO_ERROR(A1)
		BSR	TermIO
		BRA	Read_Rtn


*		;------	A write is in progress, is it the one associated with
*		;	this read?  If not, add the read request to the end of
*		;       the input queue.
Read_withWrite:
		MOVE.L	D0,A0	
		MOVE.L	IO_UNIT(A0),D0
		CMP.L	IO_UNIT(A1),D0
		BEQ.S	Read_sameUnit
Read_AddTail	LEA	ND_UNIT+MP_MSGLIST(A3),A0
		DISABLE
		ADDTAIL
		ENABLE
		BRA.S	Read_Rtn


*		;------	The read and write requests match.  If the mouths have 
*		;	changed, return the new shapes.  If not, add to head
*		;	of input queue.  If the unit is stopped, add the read
*		;	request to the head of the input queue.
Read_sameUnit:
		LEA	ND_UNIT(A3),A0
		BTST	#UNITB_STOP,UNIT_FLAGS(A0)
		BNE.S	Read_Stopped
		MOVE.B	MRB_SHAPE(A1),D0
		MOVE.L	ND_GLOBALS(A3),A0
		CMP.B	CURMOUTH(A0),D0
		BNE.S	Read_NewMouth
Read_Stopped	LEA	ND_UNIT+MP_MSGLIST(A3),A0
		DISABLE
		ADDHEAD
		ENABLE
		BRA.S	Read_Rtn


*		;------	Unpack and return new mouth values 
Read_NewMouth:
		MOVE.B	CURMOUTH(A0),D0
		MOVE.B	D0,D1
		MOVE.B	D0,MRB_SHAPE(A1)
		AND.B	#$0F,D0
		MOVE.B	D0,MRB_WIDTH(A1)
		LSR.B	#4,D1
		MOVE.B	D1,MRB_HEIGHT(A1)
		CLR.B	IO_ERROR(A1)
		BSR	TermIO
		
Read_Rtn	MOVEM.L	(SP)+,A3/A6
		RTS



******* Device/Speech/Write ****************************************
*
*   NAME
*	Write - Send speech request to the narrator device
*
*   SYNOPSIS
*	Standard device command.  See DoIO/SendIO.
*
*   FUNCTION
*	Performs the speech request.  If there is an
*	associated read request on the device input queue,
*	write will remove it and return an initial mouth
*	shape to the user.  Note that if you are going
*	to be doing reads, the mouths parameter must be
*	set to 1.
*
*   INPUTS
*	Narrator IORB
*	   ch_masks - array of audio channel selection masks
*		      (see audio device documentation for
*		       description of this field)
*	   nm_masks - number of audio channel selection masks
*	   mouths   - 0 if no mouths are desired
*		      1 if mouths are to be read
*	   rate     - speaking rate
*	   pitch    - pitch
*	   mode     - pitch mode
*	              0 if natural mode
*		      1 if robotic mode
*	   sex      - 0 if male
*	  	    - 1 if female
*	   io_Message - message port
*	   io_Command - CMD_WRITE
*	   io_Data    - input string
*	   io_Length  - length of input string
*	   
*   RESULTS
*	The function sets the io_Error field of the IORB.  The
*	io_Actual field is set to the length of the input string
*	that was actually processed.  If the return code indicates
*	a phoneme error (ND_PhonErr), io_Actual is the position in
*	the input string where the error occured.
*
*   SEE ALSO
*	Read command.
*	Audio device documentation.
*
*********************************************************************
*
*
*   REGISTER USAGE
*
*
*   IMPLEMENTATION
*

Write:	
		MOVE.L	A2,-(SP)


*		;------	See if a read request for this write request is on the queue
Write_StartLoop:
		DISABLE	A0
		MOVE.L	IO_UNIT(A1),D0
		LEA	ND_UNIT+MP_MSGLIST(A3),A0
		MOVE.L	(A0),D1
Write_Loop:	
		MOVE.L	D1,A2
		MOVE.L	(A2),D1
		BEQ.S	Write_NoRead
		CMP.W	#CMD_READ,IO_COMMAND(A2)
		BNE.S	Write_Loop
		CMP.L	IO_UNIT(A2),D0
		BNE.S	Write_Loop


*		;------	Found a read request on the queue.  Start it going.
Write_FoundRead:
		MOVE.L	A1,-(SP)		;Save write IORB
		MOVE.L	A2,A1			;Copy read IORB ptr
		REMOVE				;Delink read IORB
		ENABLE  A0
		MOVE.L	A2,A1			;Move read IORB ptr 
		MOVE.B	#0,IO_ERROR(A1)		;No error
		BSR	TermIO			;Reply to user
		MOVE.L	(SP)+,A1		;Restore write IORB
		BRA.S	Write_StartLoop		;Look for more reads



*		;------ Startup the write request
Write_NoRead:
		ENABLE	A0
		MOVE.L	(SP)+,A2
		JMP	Narrator			;!!!!!!! DOES NOT RETURN !!!!!
		


******* Device/Speech/Close ***************************************
*
*   NAME
*	CloseDevice - terminates access to the narrator device
*
*   SYNOPSIS
*	CloseDevice(IORequest)
*
*   FUNCTION
*	Close invalidates the IO_UNIT and IO_DEVICE fields in the
*	IORB, preventing subsequent IO until another OpenDevice.
*	CloseDevice also reduces the open count.  If the count 
*	goes to 0 and the expunge bit is set, the device is 
*	expunged.  If the open count goes to zero and the delayed
*	expunge bit is not set, CloseDevice sets the expunge bit.
*
*   INPUTS
*	IORequest block
*
*   RESULTS
*	IORequest block with unit and device pointers invalidated.
*
*   SEE ALSO
*
*
**********************************************************************
*
*
*   REGISTER USAGE
*
*
*   IMPLEMENTAION
*
*


Close:
	MOVEM.L	A2/A3/D2/D3,-(SP)
	LEA	ND_UNIT(A6),A3		;Get unit pointer


*	;------	Remove all IO requests with same pseudo-unit
	MOVE.L	IO_UNIT(A1),D2			;Get pseudo unit number
*	DISABLE	A0
	LEA	MP_MSGLIST+LH_HEAD(A3),A2	;List head
	MOVE.L	(A2),D3				;Pointer to first node

CloseLoop:
	MOVE.L	D3,A2				;Abort each IO request
	MOVE.L	(A2),D3
	BEQ.S	CloseDone
	MOVE.L	A2,A1
	CMP.L	IO_UNIT(A1),D2
	BNE.S	CloseLoop
	BSR	AbortIO
	BRA.S	CloseLoop

CloseDone:
*	ENABLE	A0


*	;------	Reduce device open count.  If last close, jump to Expunge
	MOVEQ	#0,D0				;RC if not last close
*	DISABLE	A0
	SUBQ.W  #1,LIB_OPENCNT(A6)
	BNE.S	Close_NotLast

*	;------	Release fixed buffers.		;!!!sam 11/20/85!!!
	MOVE.L	A6,A2				;!!!sam 11/20/85!!!
	MOVE.L	_AbsExecBase,A6			;!!!sam 11/20/85!!!
	MOVE.L  ND_GLOBALS(A2),A1		;!!!sam 11/20/85!!!
        MOVE.L  #FIXBFRSZ,D0			;!!!sam 11/20/85!!!
	CALLSYS	FreeMem				;!!!sam 11/20/85!!!

*	;------	Close audio device		;!!!sam 11/20/85!!!
	LEA	ND_IORB3(A2),A1			;!!!sam 11/20/85!!!
	CALLSYS	CloseDevice			;!!!sam 11/20/85!!!
	MOVE.L	A2,A6				;!!!sam 11/20/85!!!

	BTST	#UNITB_EXPUNGE,UNIT_FLAGS(A3)
	BEQ.S	Close_NotLast
	MOVE.L	A1,-(SP)			;******* c test only
	BSR	Expunge				;Returns seglist ptr in D0
	MOVE.L	(SP)+,A1			;******* c test only

Close_NotLast:
*	ENABLE	A0
	MOVEM.L	(SP)+,A2/A3/D2/D3
	RTS



* ****** Device/Speech/PerformIO ***********************************
*
*   NAME
*	PerformIO -- do an actual IO request
*
*   SYNOPSIS
*	PerformIO( iORequest ), DevPtr, SysLib
*		   A1	
*
*   FUNCTION
*	PerformIO is called by the device task when a new IO
*	request comes in.  Handles write requests only.  This
*	is a leftover from the earlier days of exec.
*
*
*   INPUTS
*
*
*   RESULTS
*
*
*   SEE ALSO
*
*
* *********************************************************************
*
*
*   REGISTER USAGE
*
*
*   IMPLEMENTATION
*	
*

PerformIO:	
	MOVE.W		IO_COMMAND(A1),D0	;GET COMMAND
	BLE		NoIO			;INVALID
	CMP.W		#CMD_FLUSH,D0
	BGT		NoIO			;INVALID
	LSL.W		#2,D0			;CONVERT TO LONG OFFSET
	LEA		CommandTbl,A0
	MOVE.L		0(A0,D0.W),A0
	JSR		(A0)

Perform_End:
	RTS




* ****** Device/Speech/Expunge ***********************************
*
*   NAME
*	Expunge - Removes device and memory from system
*
*
*   SYNOPSIS
*	Expunge(devNode)
*		   A6
*
*
*   FUNCTION
*	Expunge is called by RemDevice, not by the user. 
*	If the open count is non-zero, Expunge sets the delayed
*	expunge bit in the unit flags byte and returns.  If
*	the open count is zero, Expunge will remove all memory
*	allocated for the device and remove the device from
*	the system list.
*
*
*   INPUTS
*
*
*   RESULTS
*	Retuns 0 if open count is not 0, returns seglist pointer
*	if the expunge happens.
*
*
*   SEE ALSO
*
* *********************************************************************
*
*   REGISTER USAGE
*
*  
*   IMPLEMENTATION
*
   
Expunge:
	MOVEM.L	A3/A6/D3,-(SP)
	MOVE.L	A6,A3
	MOVE.L	_AbsExecBase,A6



	LEA	ND_UNIT(A3),A0				;Unit pointer

*	;------ Last close?  If so, release fixed buffers
	TST.W	LIB_OPENCNT(A3)
	BEQ.S	ExDev
	BSET	#UNITB_EXPUNGE,UNIT_FLAGS(A0)		;Set delayed expunge bit
	MOVEQ	#0,D0					;Return code	
	BRA	ExReturn

ExDev:
*	DISABLE
*	;------	Release fixed buffers.
*	MOVE.L  ND_GLOBALS(A3),A1			;!!!sam 11/20/85!!!
*	MOVE.L  #FIXBFRSZ,D0				;!!!sam 11/20/85!!!
*	CALLSYS	FreeMem					;!!!sam 11/20/85!!!


*	;------	Close audio device
*	LEA	ND_IORB3(A3),A1				;!!!sam 11/20/85!!!
*	CALLSYS	CloseDevice				;!!!sam 11/20/85!!!


*	;------	Remove my task
	LEA	ND_TCB(A3),A1
	CALLSYS	RemTask


*	;------	Remove the device
	MOVE.L	A3,A1
	REMOVE


*	;------	Remove audio control msgport
	MOVE.L	ND_CMSGPORT(A3),A1
	MOVE.L	#MP_SIZE,D0
	CALLSYS	FreeMem


*	;------	Remove device node
	MOVE.L	ND_SEGLIST(A3),D3
	MOVE.L	A3,A1
	MOVEQ	#0,D0			*!!!sam 8/31/85!!!
	MOVEQ	#0,D1			*!!!sam 8/31/85!!!
	MOVE.W	LIB_NEGSIZE(A3),D0	*!!!sam 8/31/85!!!
	SUB.L	D0,A1			*!!!sam 8/31/85!!!
	MOVE.W	LIB_POSSIZE(A3),D1	*!!!sam 8/31/85!!!
	ADD.L	D1,D0			*!!!sam 8/31/85!!!
*	MOVE.L	#ND_SIZE,D0		*!!!sam 8/31/85!!!
	CALLSYS	FreeMem
	MOVE.L	D3,D0
*	ENABLE

ExReturn:	
	MOVEM.L	(SP)+,A3/A6/D3
	RTS



* ****** Device/Speech/BeginIO ***********************************
*
*   NAME
*	BeginIO -- do an actual IO request
*
*
*   SYNOPSIS
*	BeginIO( iORequest ), devNode
*		   A1		A6
*
*
*   FUNCTION
*	BeginIO receives driver requests from the user and
*	either processes them immediately, or queues them
*	for later.  Currently only writes are queued.
*
*
*   INPUTS
*
*
*   RESULTS
*
*
*   SEE ALSO
*
*
*
* *********************************************************************
*
*   REGISTER USAGE
*
*  
*   IMPLEMENTATION
*

BeginIO:
	LEA	ND_UNIT(A6),A0			;Compute msgport pointer
	MOVE.B	#NT_MESSAGE,LN_TYPE(A1)		;Set type
	BSET	#IOB_ACTIVE,IO_FLAGS(A1)	;Set IORB active bit

	AND.B	#(~(IOF_QUICK!IOF_ABORT))&$FF,IO_FLAGS(A1)

	CMP.W	#CMD_STOP,IO_COMMAND(A1)
	BEQ	StopIO
	CMP.W	#CMD_START,IO_COMMAND(A1)
	BEQ.S	StartIO
	CMP.W	#CMD_FLUSH,IO_COMMAND(A1)
	BEQ	FlushIO
	CMP.W	#CMD_RESET,IO_COMMAND(A1)
	BEQ	ResetIO
	CMP.W	#CMD_READ,IO_COMMAND(A1)
	BEQ	Read

	BTST	#UNITB_SHUT,UNIT_FLAGS(A0)
	BEQ	BeginOK
	MOVE.B	#IOERR_ABORTED,IO_ERROR(A1)
	MOVEM.L	A3/A6,-(SP)
	MOVE.L	A6,A3
	MOVE.L	_AbsExecBase,A6
	BSR	TermIO
	MOVEM.L	(SP)+,A3/A6
	RTS

BeginOK:
	LINKSYS PutMsg

	RTS	



******* Device/Speech/StartIO StopIO ****************************
*
*   NAME
*	StopIO  - Stops the device.
*	StartIO - Restarts the device after StopIO
*
*   SYNOPSIS
*	Standard device commands.  See DoIO/SendIO
*
*   FUNCTION
*	StopIO halts the currently active speech (if any) and
*	prevents any queued requests from starting. 
*
*	StartIO restarts the currently active speech (if any)
*	and allows queued request to start.
*
*   INPUTS
*	io_Command = CMD_STOP or CMD_START
*
*   RESULTS
*
*   SEE ALSO
*
*
*
*
**********************************************************************
*
*   REGISTER USAGE
*
*  
*   IMPLEMENTATION
*

StartIO:
	BCLR	#UNITB_STOP,UNIT_FLAGS(A0)
	MOVE.L	A1,-(SP)
	LEA	ND_IORB3(A6),A1
	MOVE.W	#CMD_START,IO_COMMAND(A1)
	BSET	#IOB_QUICK,IO_FLAGS(A1)
	LINKSYS	DoIO
	LEA	ND_TCB(A6),A1
	MOVE.L	ND_SIGNALS(A6),D0
	LINKSYS	Signal
	MOVE.L	(SP)+,A1
	BRA.S	SReturn


StopIO:
	BSET	#UNITB_STOP,UNIT_FLAGS(A0)	;Bit used to stop new requests
	MOVE.L	A1,-(SP)	
	LEA	ND_IORB3(A6),A1			;Get command IORB
	MOVE.W	#CMD_STOP,IO_COMMAND(A1)	;Set STOP
 	BSET	#IOB_QUICK,IO_FLAGS(A1)		;Set quick bit
	LINKSYS	DoIO
	MOVE.L	(SP)+,A1
	
SReturn:
	CLR.B	IO_ERROR(A1)		;Set no error
	MOVEM.L	A3/A6,-(SP)
	MOVE.L  A6,A3
	MOVE.L	_AbsExecBase,A6 
	BSR	TermIO
	MOVEM.L	(SP)+,A3/A6		;Fixup and leave	
	RTS




******* Device/Speech/ResetIO ***********************************
*
*   NAME
*	Reset - Reset the device to a known state
*
*   SYNOPSIS
*	Standard device command.  See DoIO/SendIO.
*
*   FUNCTION
*	Resets the device as though it has just be initialized.
*	Aborts all read/write requests whether active of enqueued.
*	Restarts device if it has been stopped.
*
*   INPUTS
*	io_Command = CMD_RESET
*
*   RESULTS
*
*   SEE ALSO
*
*
*
*
**********************************************************************
*
*   REGISTER USAGE
*
*  
*   IMPLEMENTATION
*

ResetIO:

	MOVEM.L	A2/A3/A4/A6/D3,-(SP)
	MOVE.L	A0,A3
	MOVE.L	A1,A4

*	;------	Shut driver
	BSET	#UNITB_SHUT,UNIT_FLAGS(A3)	;Mark unit as shut down

	BSR	FlushAll

*	;------	Make sure the device is started.  Also does TermIO.
	MOVE.L	A4,A1				;IORB
	MOVE.L	A3,A0				;Unit
	MOVE.L	IO_DEVICE(A1),A6		;devNode
	BSR	StartIO

*	;------ Re-open driver to input
	BCLR	#UNITB_SHUT,UNIT_FLAGS(A3)

	MOVEM.L	(SP)+,A2/A3/A4/A6/D3		;Fixup and leave	
	RTS



******* Device/Speech/FlushIO ***********************************
*
*   NAME
*	Flush - Aborts all inprogress and queued requests
*
*   SYNOPSIS
*	Standard device command.  See DoIO/SendIO
*
*   FUNCTION
*	Aborts all inprogress and queued speech requests.
*
*   INPUTS
*	io_Command - CMD_FLUSH
*
*   RESULTS
*
*   SEE ALSO
*
*
*
*
**********************************************************************
*
*   REGISTER USAGE
*
*  
*   IMPLEMENTATION
*

FlushIO:

	MOVEM.L	A2/A3/A4/A6/D3,-(SP)
	MOVE.L	A0,A3
	MOVE.L	A1,A4

*	;------	Shut driver
	BSET	#UNITB_SHUT,UNIT_FLAGS(A3)	;Mark unit as shut down

	BSR	FlushAll

*	;------ Re-open driver to input
	BCLR	#UNITB_SHUT,UNIT_FLAGS(A3)

	
	MOVE.L	A4,A1
	CLR.B	IO_ERROR(A1)		;Set no error
	MOVE.L  IO_DEVICE(A1),A3
	MOVE.L	_AbsExecBase,A6 
	BSR	TermIO
	MOVEM.L	(SP)+,A2/A3/A4/A6/D3		;Fixup and leave	
	RTS

FlushAll:
*	;------	Abort anything in progress
	MOVE.L	ND_USERIORB(A6),D0		;Get in progress IORB
	BEQ.S	FlushQ				;Nothing in progress
	MOVE.L	D0,A1				;Kill in progress request
	BSR	AbortIO


*	;------	Clear out the msgport queue
FlushQ:
	DISABLE	A0
	LEA	MP_MSGLIST+LH_HEAD(A3),A2	;List head
	MOVE.L	(A2),D3				;Pointer to first node

FlushLoop:
	MOVE.L	D3,A2				;Abort each IO request
	MOVE.L	(A2),D3
	BEQ.S	FDone
	MOVE.L	A2,A1
	BSR	AbortIO
	BRA.S	FlushLoop

FDone	ENABLE	A0
	RTS

	

******* Device/Speech/AbortIO ****************************************
*
*   NAME
*	AbortIO - Abort an IO request
*
*   SYNOPSIS
*	AbortIO(IORequest)
*
*   FUNCTION
*	Aborts a speech IO request.  The request may be in the queue
*       or currently active.
*
*   INPUTS
*	IORB of request to abort.
*
*   RESULTS
*	io_Error field of IORB set to IOERR_ABORTED
*
*   SEE ALSO
*
*
**********************************************************************
*
*

AbortIO:
	MOVEM.L	A3/A6,-(SP)

	MOVE.L	A6,A3
	MOVE.L	_AbsExecBase,A6
	DISABLE

	LEA	ND_UNIT(A3),A0			;Get msgport pointer
	LEA	MP_MSGLIST+LH_HEAD(A0),A0	;Pointer to first node


*	;------ Are we in progress?  If so, set a bit for Synth to look at.

	CMP.L	ND_USERIORB(A3),A1		;Currently running in Synth?
	BNE.S	AbloopQ				;No, check queue
	BSET	#IOB_ABORT,IO_FLAGS(A1)		;Yes, set the abort bit
	BRA.S	AbNotFound			;Fixup and leave


*	;------	Not in progress, are we still on the queue?

AbloopQ:
	MOVE.L	(A0),A0				;Get first node
Abloop	MOVE.L	(A0),D0				;Get node successor
	BEQ.S	AbNotFound			;Not found
	CMP.L	A0,A1				;Node to Abort?
	BEQ.S	AbFound				;Yes
	MOVE.L	D0,A0				;No, keep looking
	BRA.S	Abloop

AbFound	MOVE.L	A1,D0				;Remove node from queue
	REMOVE
	MOVE.L	D0,A1
	MOVE.B	#IOERR_ABORTED,IO_ERROR(A1)	;Set return code

	ENABLE
	BSR	TermIO
	BRA.S	AbReturn

AbNotFound:
	ENABLE

AbReturn:
	MOVEM.L	(SP)+,A3/A6
	RTS

		

* ****** Device/Speech/Null ****************************************
*
*   NAME
*	Null - 
*
*   SYNOPSIS
*	Zero = Null(), DevNode
*	D0	       A6
*
*   FUNCTION
*	Be a constant source of zero's for unimplemented routines.
*
*   RESULTS
*	Zero -- Always return 0 in D0
*
*
*   SEE ALSO
*	SLNullFunc
*
*
* *********************************************************************

ExtFunc:
Null:
		MOVEQ	#0,D0
		RTS
NoIO:
		MOVE.B	#ND_Unimpl,IO_ERROR(A1)
		BSR	TermIO
		RTS

UpdateIO:
ClearIO:
		CLR.B	IO_ERROR(A1)
		BSR	TermIO
		RTS




* ****** Device/TermIO ************************************************
*
*   NAME
*	TermIO - Return an IO request to the user.
*
*
*   SYNOPSIS
*	TermIO( iORequest ), devLib, SysLib
*		A1	     A3        A6     
*
*
*   FUNCTION
*	TermIO does all the necessary cleanup after an I/O
*	Request block has been completed.  It will mark it
*	as done, send it back to the originating task.
*
*
*   INPUTS
*	iORequest -- a pointer to the I/O Request Block
*
* *********************************************************************
*
*   NOTE
*	This routine would normally be found in the device support
*	library.  Currently it does not have a permanent place to
*	live, and is part of each driver's address space.  This
*	will be fixed as we get the device support library nailed
*	down.
*


TermIO:
		LEA	ND_UNIT(A3),A0

*		;------ Clear unit active flag
		BCLR	#UNITB_ACTIVE,UNIT_FLAGS(A0)

*		;------ Clear all flag bits
		MOVE.B	#0,IO_FLAGS(A1)

*		;------ and send it back
		CALLSYS ReplyMsg


Term_End:
		RTS



		XDEF devStructInit
devStructInit:



*		;------ Initialize the device
		INITBYTE	LN_TYPE,NT_DEVICE
		INITLONG	LN_NAME,NarratorName
		INITWORD	LIB_REVISION,REVISION
		INITWORD	LIB_VERSION,VERSION
		INITBYTE	LIB_FLAGS,LIBF_SUMUSED!LIBF_CHANGED
		INITWORD	LIB_OPENCNT,0
		INITBYTE	ND_UNIT+MP+LN_TYPE,NT_MSGPORT
		INITLONG	ND_UNIT+MP+LN_NAME,NarratorName

 		INITBYTE	ND_UNIT+UNIT_FLAGS,0


		INITBYTE	ND_TCB+LN_TYPE,NT_TASK
		INITLONG	ND_TCB+LN_NAME,NarratorName
		INITBYTE	ND_TCB+LN_PRI,0

		
		DC.L		0


*		;------ Device function table

		XDEF devFuncInit
devFuncInit:
		DC.L	Open		; - 6
		DC.L	Close		; - C
		DC.L	Expunge		; -12 
		DC.L	ExtFunc		; -18
		DC.L	BeginIO		; -1E
		DC.L	AbortIO		; -24
		DC.L	-1		; END OF TABLE MARKER

devFuncEnd:

devFuncSize	EQU	(devFuncEnd-devFuncInit)


*		;------ Device command jump table

CommandTbl	DC.L	NoIO		;invalid
		DC.L	ResetIO		;reset
		DC.L	Read		;read
		DC.L	Write		;write
		DC.L	UpdateIO	;update
		DC.L	ClearIO		;clear
		DC.L	StopIO		;stop
		DC.L	StartIO		;start
		DC.L	FlushIO		;flush
		DC.L	NoIO		;finish


cportname	DC.B	'command port',0
		CNOP	0,2


*		;------ Sam's audio library
AudioLib	STRING	'audio.device'

		END



	TTL	'$Header: spname.asm,v 32.1 86/01/22 00:24:36 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: spname.asm,v 32.1 86/01/22 00:24:36 sam Exp $
*
* $Locker:  $
*
* $Log:	spname.asm,v $
* Revision 32.1  86/01/22  00:24:36  sam
* placed under source control
* 
*
**********************************************************************
	SECTION speech


******* Included Files ***********************************************

    INCLUDE	'assembly.i'
    INCLUDE	'narrator_rev.i'
    INCLUDE	'exec/types.i'
    INCLUDE	'exec/nodes.i'
    INCLUDE	'exec/strings.i'
    INCLUDE	'exec/resident.i'



******* Exported *****************************************************

    XDEF	NarratorName
    XDEF	NarratorIdStr



NarratorIdStr    VSTRING


*------ Name String  -------------------------------------------

NarratorName   STRING  'narrator.device'



    END
	TTL	'$Header: narrator.asm,v 32.1 86/01/22 00:24:12 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: narrator.asm,v 32.1 86/01/22 00:24:12 sam Exp $
*
* $Locker:  $
*
* $Log:	narrator.asm,v $
* Revision 32.1  86/01/22  00:24:12  sam
* placed under source control
* 
*
**********************************************************************
		SECTION speech
_AbsExecBase	EQU	4


	INCLUDE 'assembly.i'
 	INCLUDE 'exec/types.i'
	INCLUDE 'exec/nodes.i'
	INCLUDE 'exec/lists.i'
	INCLUDE 'exec/strings.i'
	INCLUDE 'exec/initializers.i'
	INCLUDE 'exec/memory.i'
	INCLUDE 'exec/interrupts.i'
	INCLUDE 'exec/ports.i'
	INCLUDE 'exec/libraries.i'
	INCLUDE 'exec/devices.i'
	INCLUDE 'exec/io.i'
	INCLUDE 'exec/tasks.i'
	INCLUDE 'exec/resident.i'
	INCLUDE 'hardware/custom.i'
	INCLUDE 'hardware/dmabits.i'
	INCLUDE 'exec/execbase.i'
	INCLUDE 'exec/ables.i'
	INCLUDE 'exec/errors.i'

io_Size	EQU	IO_SIZE
        INCLUDE	'featequ.i'
        INCLUDE	'gloequs.i'
	INCLUDE	'devices/audio.i'
	INCLUDE	'narrator.i'
	INCLUDE	'private.i'


******* Imported Functions *******************************************

	EXTERN_SYS AllocMem
	EXTERN_SYS FreeMem
	EXTERN_SYS PutMsg
	EXTERN_SYS ReplyMsg
	EXTERN_SYS Signal
	EXTERN_SYS Wait
	EXTERN_SYS DoIO
	EXTERN_SYS FindTask
	EXTERN_SYS SetTaskPri

	XREF	PARSE,STRMARK,PHONOL,SYLLABLE,PROSOD
	XREF	F0INIT,F0HLS,F0LLS
	XREF	PHONET,TAG,INTERP,FEAT
 	XREF	SYNTH,TermIO,AllocMultChan,FreeMultChan

	XDEF	Narrator


Narrator:
		MOVEM.L	  A1-A6/D2-D7,-(SP)	;Save all important registers

		MOVE.L	  A1,A2            	;Copy ptr to IORequest block to A2
		MOVE.L    ND_GLOBALS(A3),A5	;Get ptr to globals area ptr
*		MOVE.L	  ND_AUDIOLIB(A3),AudLib(A5) ;Save ptr to Audio lib
		MOVE.L	  A2,USERIORB(A5)	;Save ptr to user's IORB

		MOVE.L	_AbsExecBase,A6		;SysLib pointer


*		;------ Allocate the audio channels and
*		;	build the DMA IORBs

		JSR	AllocMultChan
		MOVE.W	D0,D3			;Check return code
		BNE	MAINRTN			;Error
		

*		;------ Copy mouth flag to globals

		MOVE.B	  NDI_MOUTHS(A2),Mouth(A5)


*		;------ Check the speaking rate for bounds

		MOVE.W    NDI_RATE(A2),D1	;Get rate from user
*	        CMP.W     #MINRATE,D1
                CMP.W     #1,D1 
         	BGE.S     PAR1
PAR2		MOVEQ	  #ND_RateErr,D3
		BRA       MAINRTN                
PAR1          	CMP.W     #MAXRATE,D1
          	BGT       PAR2
          	MOVE.W    D1,RATE(A5)


*		;------ Check the pitch for bounds 

		MOVE.W	  NDI_PITCH(A2),D1
	  	CMP.W     #MINPITCH,D1               
          	BGE.S     PAR3
PAR4		MOVEQ     #ND_PitchErr,D3
		BRA	  MAINRTN 
PAR3          	CMP.W     #MAXPITCH,D1
          	BGT       PAR4
          	MOVE.W    D1,FREQ(A5)



*		;------ Check and set the F0 mode

		MOVE.W	  NDI_MODE(A2),D1
		CMP.W     #NATURALF0,D1
          	BEQ.S     PAR5
          	CMP.W     #ROBOTICF0,D1
          	BEQ.S     PAR5
                MOVEQ	  #ND_ModeErr,D3
		BRA       MAINRTN
PAR5       	MOVE.W    D1,F0MODE(A5)


*		;------ Check and set the sex of the voice

		MOVE.W	  NDI_SEX(A2),D1
 		CMP.W     #MALE,D1
          	BEQ.S     PAR6
		CMP.W     #FEMALE,D1
		BEQ.S     PAR6
                MOVEQ	  #ND_SexErr,D3
		BRA	  MAINRTN
PAR6		MOVE.W    D1,SEX(A5)


*		;------ Check and set the sampling frequency

		MOVE.W	  NDI_SAMPFREQ(A2),D1
		CMP.W	  #MINFREQ,D1
		BGE.S     PAR7
PAR8		MOVEQ	  #ND_FreqErr,D3
		BRA       MAINRTN
PAR7		CMP.W     #MAXFREQ,D1
		BGT       PAR8
		MOVE.W	  D1,SampFreq(A5)


*		;------ Check and set the volume

		MOVE.W    NDI_VOLUME(A2),D1
		CMP.W     #MINVOL,D1
                BGE.S     PAR9
PAR10		MOVEQ     #ND_VolErr,D3
		BRA       MAINRTN
PAR9		CMP.W     #MAXVOL,D1
		BGT	  PAR10
		MOVE.B    D1,Volume(A5)


*		;------ Setup and call the synthesizer

		MOVE.L	  IO_DATA(A2),PARSTART(A5)
       		MOVE.L	  IO_DATA(A2),PARVERYB(A5)
		MOVE.W 	  IO_LENGTH+2(A2),LFT2PARS(A5)
          	CLR.L     PARLENTH(A5)        


*		;------- Main synthesizer loop

MAINLOOP  MOVE.L    PARSTART(A5),A0            ;CURRENT POSITION IN PHONEME STRING
          MOVE.L    PARLENTH(A5),D0            ;AMOUNT PREVIOUSLY PARSED
          ADD.L     D0,A0                      ;ADD IN PREVIOUS LENGTH
          MOVE.L    A0,PARSTART(A5)            ;SAVE BACK
          SUB.W     D0,LFT2PARS(A5)            ;REDUCE TOTAL INPUT LENGTH
          MOVE.W    LFT2PARS(A5),MAX2PARS(A5)  ;SET MAX TO PARSE TO REMAINING LEN

REPARSE   JSR       PARSE
          BEQ       MAINRTN             ;IF =0, WE'RE DONE
          BVS       OVERFLOW            ;OVERFLOW IN PARSE
          BPL       MAINRTN             ;IF RC +IVE, INPUT ERROR (D3 HAS POS)
          JSR       STRMARK
          LEA       PHRULES1,A6
          JSR       PHONOL
          BVS       OVERFLOW            ;OVERFLOW IN PHONOL
          JSR       SYLLABLE
          JSR       F0INIT
F0LOOP    JSR       F0HLS
          BEQ.S     DOPROSOD            ;RC = 0 ==> SENTENCE COMPLETED
          BVS       OVERFLOW            ;RC -IVE ==> OVERFLOWED SOME ARRAY
          JSR       F0LLS
          BRA.S     F0LOOP
DOPROSOD  JSR       PROSOD
          LEA       PHRULES2,A6
          JSR       PHONOL
          BVS       OVERFLOW
          JSR       PHONET
          BVS       OVERFLOW
          JSR       TAG
          JSR       INTERP


*	;------	Set the task priority high
	MOVE.L	_AbsExecBase,A6
	SUB.L	A1,A1
	CALLSYS	FindTask
	MOVE.L	D0,A1
	MOVEQ	#100,D0
	CALLSYS	SetTaskPri


*	;------	Call the synthesizer
          JSR       SYNTH


*	;------	Set the task priority low
	MOVE.L	_AbsExecBase,A6
	SUB.L	A1,A1
	CALLSYS	FindTask
	MOVE.L	D0,A1
	MOVEQ	#0,D0
	CALLSYS	SetTaskPri



          MOVE.L    COEFPTR(A5),A1
          MOVE.L    COEFSIZE(A5),D0
          CALLSYS   FreeMem

	  TST.B	    Mouth(A5)
	  BEQ.S	    Write_nomouth
	  MOVE.L    MOTHPTR(A5),A1
	  MOVE.L    MOTHSIZE(A5),D0
	  CALLSYS   FreeMem

Write_nomouth:
	  TST.W     D3
          BEQ       MAINLOOP            ;CONTINUE LOOP UNTIL END OF INPUT



MAINRTN:
	MOVE.W	  D3,D0			;Transfer return code to D0
	MOVEM.L   (SP)+,A1-A6/D2-D7	;Restore important registers

	JSR	  FreeMultChan

	CLR.L	  ND_USERIORB(A3)	;Clear the current user IORB
		
	TST.W	  D0
	BEQ.S	  Write_Good
	BMI.S	  Write_Bad



Write_PCErr:
*		;------ Found a phoneme code error in input string
		AND.L	  #$0000FFFF,D0		;Isolate pos of error
		MOVE.L    D0,IO_ACTUAL(A1)	;Put in user's IORB
		MOVE.B    #ND_PhonErr,D0	;Specify a return code
		BRA.S     Write_End		;Go away	
Write_Good:
		MOVE.L    IO_LENGTH(A1),IO_ACTUAL(A1)	;Set length to entire input string
		BRA.S     Write_End			;Go away
Write_Bad:
		MOVE.L    #0,IO_ACTUAL(A1)		;Clear length actually processed
		
Write_End:
		MOVE.B    D0,IO_ERROR(A1)
		BSR	  TermIO
		RTS


*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                                             ;
*                                                                             ;
*                         OVERFLOW PROCESSING                                 ;
*                                                                             ;
*         FIRST, BACK UP TO PREVIOUS - OR ,                                   ;
*           IF NO PAUSE, FIND A BLANK ABOUT 75% OF THE WAY INTO THE STRING    ;
*             IF NO BLANK, JUST CHOP THE STRING IN HALF                       ;
*                                                                             ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

OVERFLOW  MOVE.L    PARSTART(A5),A0
          MOVE.L    PARLENTH(A5),D0     ;GET LENGTH OF STRING PARSED SO FAR
          SUBQ.W    #2,D0               ;ADJUST TO START WITH 2ND TO LAST CHAR


*-------- Check backwards from the end for a '-' or ','

OVERFLO1  MOVE.B    0(A0,D0),D1
          CMP.B     #',',D1
          BEQ.S     OVERFLO2
          CMP.B     #'-',D1
          BEQ.S     OVERFLO2
          DBEQ      D0,OVERFLO1
          TST.W     D0
          BMI.S     OVERFLO3            ;NO PUNCTUATION FOUND

OVERFLO2  ADDQ.W    #1,D0
          MOVE.W    D0,MAX2PARS(A5)     ;SAVE MAX LEN FOR PARSE TO DEAL WITH
          CLR.L     PARLENTH(A5)        ;CLEAR CURRENT LENGTH
          BRA       REPARSE             ;  AND TRY TO REPARSE


*-------- No punctuation found, try for a space

OVERFLO3  MOVE.L    PARLENTH(A5),D0
          MOVE.W    D0,D1
          LSR.W     #2,D1
          SUB.W     D1,D0               ;START SEARCH 75% OF THE WAY IN
          MOVE.B    #' ',D1
OVERFLO4  CMP.B     0(A0,D0),D1
          DBEQ      D0,OVERFLO4

          TST.W     D0
          BMI.S     OVERFLO5            ;IF -IVE, NO SPACE.
          MOVE.W    D0,MAX2PARS(A5)     ;SAVE MAX LEN FOR PARSE TO DEAL WITH
          CLR.L     PARLENTH(A5)        ;CLEAR CURRENT LENGTH
          BRA       REPARSE             ;   AND REPARSE


*-------- No punctuation or space, just chop in half

OVERFLO5  MOVE.L    PARLENTH(A5),D0
          LSR.W     #1,D0               ;LENGTH/2
          MOVE.W    D0,MAX2PARS(A5)
          CLR.L     PARLENTH(A5)
          BRA       REPARSE

         INCLUDE   'pcequs.i'
         INCLUDE   'phonrules.i'

          DC.B      'COPYRIGHT 1984, JOSEPH KATZ / MARK BARTON'
	  CNOP 0,2

	END
	TTL	'$Header: multchan.asm,v 32.1 86/01/22 00:24:08 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: multchan.asm,v 32.1 86/01/22 00:24:08 sam Exp $
*
* $Locker:  $
*
* $Log:	multchan.asm,v $
* Revision 32.1  86/01/22  00:24:08  sam
* placed under source control
* 
*
**********************************************************************
		SECTION speech
_AbsExecBase	EQU	4


******* Included Files ***********************************************

	INCLUDE 'assembly.i'
 	INCLUDE 'exec/types.i'
	INCLUDE 'exec/nodes.i'
	INCLUDE 'exec/lists.i'
	INCLUDE 'exec/strings.i'
	INCLUDE 'exec/initializers.i'
	INCLUDE 'exec/memory.i'
	INCLUDE 'exec/interrupts.i'
	INCLUDE 'exec/ports.i'
	INCLUDE 'exec/libraries.i'
	INCLUDE 'exec/devices.i'
	INCLUDE 'exec/io.i'
	INCLUDE 'exec/tasks.i'
	INCLUDE 'exec/resident.i'
	INCLUDE 'hardware/custom.i'
	INCLUDE 'hardware/dmabits.i'
	INCLUDE 'exec/execbase.i'
	INCLUDE 'exec/ables.i'
	INCLUDE 'exec/errors.i'

	INCLUDE	'devices/audio.i'
	INCLUDE	'narrator.i'
	INCLUDE	'private.i'


******* Imported Functions *******************************************

	EXTERN_SYS AllocMem
	EXTERN_SYS FreeMem
	EXTERN_SYS DoIO
	EXTERN_SYS WaitIO
	EXTERN_SYS FindTask
	EXTERN_SYS AllocSignal
	EXTERN_SYS FreeSignal
	

******* Exported Functions *******************************************

	XDEF	AllocMultChan,FreeMultChan


******* Imported Globals   *******************************************

	XREF	DMANodeName



*******	Private/Device/Narrator/AllocMultChan*************************
*
*   NAME
*	AllocMultChan - Handles initialization of channels
*
*
*   SYNOPSIS
*
*
*   FUNCTION
*	AllocMultChan allocates the audio channels specified by
*	the channel masks array in the user's IORB; creates the
*	message port for the audio DMA requests; and allocates
*	and fills the DMA IORBs.
*	
*
*   INPUTS
*	A2 - User IORB
*	A3 - Device node
*	A5 - Synthesizer globals area
*	A6 - AbsExecBase
*
*
*   RESULTS
*
*
*   SEE ALSO
*
*
**********************************************************************
*
*
*   REGISTER USAGE
*	Stomps on registers A0, A1, A4, D0, D1, and D3
*
*
*   IMPLEMENTATION
*
*


AllocMultChan:

*	;------	Initialize 

	CLR.B	NDI_CHANMASK(A2)
	CLR.B	NDI_NUMCHAN(A2)
	CLR.L	ND_AUDDMAIORB(A3)
	CLR.L	ND_MSGPORT(A3)

	
*	;------	Allocate the audio channels

	LEA	ND_IORB3(A3),A1
	MOVE.B	#75,LN_PRI(A1)				*!!!sam 10/23/85!!!
	MOVE.B	#ADIOF_NOWAIT+IOF_QUICK,IO_FLAGS(A1)
	MOVE.L	NDI_CHMASKS(A2),ioa_Data(A1)
*	MOVE.W	NDI_NUMMASKS(A2),ioa_Length(A1)		*!!!sam 7/12/85!!!
	MOVE.W	NDI_NUMMASKS(A2),ioa_Length+2(A1)	*!!!sam 7/12/85!!!
	MOVE.W	#ADCMD_ALLOCATE,IO_COMMAND(A1)
	MOVE.L	A1,-(SP)				*!!!sam 7/12/85!!!
	BEGINIO						*!!!sam 7/12/85!!!
	MOVE.L	(SP),A1					*!!!sam 7/12/85!!!
	CALLSYS	WaitIO					*!!!sam 7/12/85!!!
*	CALLSYS	DoIO					*!!!sam 7/12/85!!!
	MOVE.L	(SP)+,A1				*!!!sam 7/12/85!!!
	TST.B	IO_ERROR(A1)
	BEQ.S	AMC_AllocOK
	MOVE.B	#ND_CantAlloc,D0
	BRA	AMC_Return


AMC_AllocOK:
*	;------	Stop all channels.  THIS CODE MOVE TO SYNTH (qv).
*
*	MOVE.W	#CMD_STOP,IO_COMMAND(A1)
*	MOVE.L	A1,-(SP)				*!!!sam 7/12/85!!!
*	CALLSYS	DoIO
*	MOVE.L	(SP)+,A1				*!!!sam 7/12/85!!!


*	;------	Save channel mask in user's IORB

	MOVE.L	IO_UNIT(A1),D1
	MOVE.B	D1,NDI_CHANMASK(A2)
	


*	;------	Create message port for audio DMA requests

	MOVE.L	#MP_SIZE,D0			;Allocate memory
	MOVE.L	#MEMF_PUBLIC+MEMF_CLEAR,D1
	CALLSYS	AllocMem
	TST.L	D0
	BNE.S	AMC_MPAllocOK
	MOVEQ	#ND_NoMem,D3
	BRA	AMC_Return

AMC_MPAllocOK:
	MOVE.L	D0,A4
	MOVE.L	A4,ND_MSGPORT(A3)
	MOVE.B	#NT_MSGPORT,MP+LN_TYPE(A4)	;Type
	LEA	DMANodeName,A0			;Node name
	MOVE.L	A0,MP+LN_NAME(A4)
	MOVEQ	#-1,D0				;Signal
	CALLSYS	AllocSignal
	MOVE.B	D0,MP_SIGBIT(A4)
	SUB.L	A1,A1				;Task
	CALLSYS	FindTask
	MOVE.L	D0,MP_SIGTASK(A4)
	LEA	MP_MSGLIST(A4),A0		;Initialize msg list
	NEWLIST	A0


*	;-----	Allocate audio DMA IORBs.  Two per channel.
	
	LEA	Mask2Num,A0
	MOVEQ	#0,D0
	MOVEQ	#0,D1
	MOVE.B	NDI_CHANMASK(A2),D1
	MOVE.B	0(A0,D1),D0
	BNE.S	AMC_GotChans
	MOVE.B	#ND_CantAlloc,D0		;Die if 0 channels
	BRA	AMC_Return

AMC_GotChans:
	MOVE.B	D0,NDI_NUMCHAN(A2)		;Save in user IORB	
	ADD.W	D0,D0
	MULU	#ioa_Size,D0
	MOVE.L	#MEMF_PUBLIC+MEMF_CLEAR,D1
	CALLSYS	AllocMem
	TST.L	D0
	BNE.S	AMC_GotMem
	MOVE.B	#ND_NoMem,D0
	BRA	AMC_Return

AMC_GotMem:
	MOVE.L	D0,ND_AUDDMAIORB(A3)		;Save ptr in devNode


*	;------	Got memory for IORBs.  Copy control
*		IORB information to DMA IORBs. 

	MOVE.L	A2,-(SP)
	MOVEQ	#0,D3
	MOVE.B	NDI_NUMCHAN(A2),D3		;Number of IORB pairs
	SUBQ.W	#1,D3
	LEA	ND_IORB3(A3),A0			;Control IORB
	MOVE.L	D0,A1				;DMA IORB 1

AMC_IORBCopy:
	LEA	ioa_Size(A1),A2			;DMA IORB 2
	MOVE.W	#(ioa_Size/2)-1,D1

AMC_CopyLoop:
	MOVE.W	(A0)+,D0
	MOVE.W	D0,(A1)+
	MOVE.W	D0,(A2)+
	DBF	D1,AMC_CopyLoop

	LEA	ND_IORB3(A3),A0			;Reset control IORB
	MOVE.L	A2,A1				;Next IORB pair
	DBF	D3,AMC_IORBCopy
	MOVE.L	(SP)+,A2
	MOVEQ	#0,D0				;Good return code

AMC_Return:
*	;------	Time to go away
	
	RTS


Mask2Num:
*	;------	0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F
	DC.B	0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4




*******	Private/Device/Narrator/FreeMultChan *************************
*
*   NAME
*	FreeMultChan - Frees the channels allocated  by AllocMultChan
*
*
*   SYNOPSIS
*
*
*   FUNCTION
*	FreeMultChan frees the channels in use and returns the
*	memory allocated for the DMA IORBs and the msgport.
*	
*
*   INPUTS
*	A1 - User IORB
*	A3 - Device node
*
*
*   RESULTS
*
*
*   SEE ALSO
*
*
**********************************************************************
*
*
*   REGISTER USAGE
*	All registers are preserved
*
*
*   IMPLEMENTATION
*
*

FreeMultChan:
	MOVEM.L	A0/A1/A2/A6/D0/D1,-(SP)		;Save registers
	MOVE.L	_AbsExecBase,A6


*	;------	Free allocated channels

	MOVE.L	A1,A2
	LEA	ND_IORB3(A3),A1
	MOVE.B	NDI_CHANMASK(A2),IO_UNIT+3(A1)
	MOVE.W	#ADCMD_FREE,IO_COMMAND(A1)
	CALLSYS	DoIO


*	;------	Free DMA IORB memory

	MOVE.L	ND_AUDDMAIORB(A3),D0
	BEQ.S	FMC_FreeMsgport
	MOVE.L	D0,A1
	MOVEQ	#0,D0
	MOVE.B	NDI_NUMCHAN(A2),D0
	ADD.W	D0,D0
	MULU	#ioa_Size,D0
	CALLSYS	FreeMem


FMC_FreeMsgport:
	MOVE.L	ND_MSGPORT(A3),D0
	BEQ.S	FMC_ResetKey
	MOVE.L	D0,A1


*	;------ Free up the signal

	MOVE.B	MP_SIGBIT(A1),D0
	CALLSYS	FreeSignal
	

*	;------	Free DMA Msgport

	MOVE.L	ND_MSGPORT(A3),A1
	MOVE.L	#MP_SIZE,D0
	CALLSYS	FreeMem


FMC_ResetKey:
*	;------	Reset Allocation key in control IORB

	LEA	ND_IORB3(A3),A0
	CLR.W	ioa_AllocKey(A0)


	MOVEM.L	(SP)+,A0/A1/A2/A6/D0/D1
	RTS

	END
	
	TTL	'$Header: parse.asm,v 33.1 86/03/05 13:21:29 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: parse.asm,v 33.1 86/03/05 13:21:29 sam Exp $
*
* $Locker:  $
*
* $Log:	parse.asm,v $
* Revision 33.1  86/03/05  13:21:29  sam
* fixed 'string ending with number' bug
* 
* Revision 32.1  86/01/22  00:24:17  sam
* placed under source control
* 
*
**********************************************************************
          SECTION      speech


*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                                     ;
*                        PHONEME PARSER                               ;
*                                                                     ;
*    INPUT IS ASCII PHONEME STRING.  OUTPUT IS PHON, STRESS, DUR      ;
*    ERRORS IN INPUT ARE NOTED BY RETURNING THE -IVE POSITION IN      ;
*    D3.                                                              ;
*                                                                     ;
*                                                                     ;
*    A0 - ADDRESS OF ASCII STRING    A1 - ADDRESS OF DIGRAPH TABLE    ;
*         (SET BY CALLING ROUTINE)                                    ;
*    A2 - PHON ARRAY                 A3 - STRESS ARRAY                ;
*    A4 - FEATURES MATRIX            A5 - GLOBALS AREA                ;
*    A6 - DURATION ARRAY             A7 - STACK POINTER               ;
*                                                                     ;
*    D0 - INDEX INTO ASCII STRING    D1 - INDEX INTO DIGRAPH TABLE    ;
*    D2 - ASCII STRING INCREMENT     D3 - INDEX INTO OUTPUT ARRAYS    ;
*    D4 - PHONEME FEATURE            D5 - SCRATCH                     ;
*    D6 - DIGRAPH COUNT              D7 - ADDR OF DIGRAPH TABLE       ;
*                                                                     ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


*--------- A few handy equates

PARSTEND  EQU       '#'       ;END OF INPUT MARKER
QMARK     EQU       '?'
PERIOD    EQU       '.'
PUNITI    EQU       5         ;P-UNIT INITIATOR BIT (IN DUR ARRAY)
PUNITT    EQU       4         ;P-UNIT TERMINATOR BIT (IN DUR ARRAY)


          INCLUDE     'digraphs.i'
          INCLUDE     'featequ.i'
          INCLUDE     'pcequs.i'
          INCLUDE     'gloequs.i'

          XREF        FEAT
          XDEF        PARSE


*-------- Initialize

PARSE     TST.W     LFT2PARS(A5)        ;ANYTHING TO SAY?
          BGT.S     P1                  ;YES
          MOVEQ     #0,D3               ;NO, RETURN 0
          RTS

P1        LEA       DIGRAPHS,A1
          LEA       PHON(A5),A2
          LEA       STRESS(A5),A3
          LEA       FEAT,A4
          LEA       DUR(A5),A6
          MOVE.L    A1,D7     ;SAVE START ADDRESS OF DIGRAPHS TABLE

          CLR.W     (A2)      ;CLEAR FIRST TWO BYTES OF OUTPUT ARRAYS
          CLR.L     (A3)
          CLR.L     (A6)
          MOVE.B    #PHCQX,2(A2) ;MOVE IN SILENT PHON
          CLR.B     3(A2)        ;AND A BLANK
          MOVEQ     #4,D3        ;START OUTPUT COUNT AT 4

          MOVEQ     #0,D0
          MOVEQ     #0,D2
          MOVEQ     #0,D4
          MOVEQ     #0,D5
          MOVE.W    #DIGRAFCT,D6        ;COUNT OF DIGRAPHS
          CLR.B     0(A3,D3)            ;CLEAR STRESS
          CLR.B     0(A6,D3)            ;CLEAR DUR


*-------- Main parse loop.  Find a match in the digraphs table

PARMAIN   MOVE.B    (A0),D0       ;GET A CHAR FROM INPUT
	  BEQ	    PARDONE	  ;NULL TERMINATES INPUT STRING
          CMP.B     #PARSTEND,D0  ;END OF INPUT?
          BEQ       PARDONE       ;YES, GO AWAY
          LSL.W     #8,D0         ;NO, MOVE TO UPPER BYTE
          MOVE.B    1(A0),D0      ;GET NEXT CHAR FROM INPUT
          MOVEQ     #2,D2         ;START WITH ASSUMPTION IT'S A DIGRAPH


PARAGAIN  MOVEQ     #DIGRAFCT-1,D1      ;DBF COUNT
          MOVE.L    D7,A1               ;RESET DIGRAPH ADDR TO START
PARLOOP   CMP.W     (A1)+,D0            ;COMPARE ASCII WITH DIGRAPH
          DBEQ      D1,PARLOOP          ;LOOP THRU ALL DIGRAPHS

          TST.W     D1
          BPL.S     PARGOT              ;IF D1 NOT NEGATIVE, GOT IT
          CMP.B     #1,D2               ;IF D2=1, CHAR NOT VALID
          BEQ       PARERROR
          AND.W     #$FF00,D0           ;CHECK TO SEE IF ITS A SINGLE CHAR
          MOVEQ     #1,D2               ;D2 HAS NUMBER OF CHARS
          BRA.S     PARAGAIN            ;GO THRU DIGRAPHS AGAIN


*-------- Found an entry in the table

PARGOT    NEG.W     D1                  ;COMPUTE INTERNAL
          ADD.W     #DIGRAFCT-1,D1      ;    PHONEME CODE

          CMP.W     #$3000,D0           ;RANGE CHECK FOR ASCII NUMBER
          BLT.S     PARNOTNM
	  BNE.S     PARGOT1
	  ADD.L	    D2,A0		;SKIP OVER ZERO STRESS
	  BRA	    PARNXT1
PARGOT1   CMP.W     #$3900,D0
          BGT.S     PARNOTNM


*-------- If number and follows a vowel put in stress array.
*         If number not following a vowel, mark as error.

          MOVEQ     #0,D4               ;CLEAR FOR USE AS INDEX
          MOVE.B    -1(A2,D3),D4        ;GET PREVIOUS PHONEME CODE
          LSL.W     #2,D4               ;CONVERT IT TO AN INDEX INTO F.M.
          MOVE.L    0(A4,D4),D4         ;GET PHONEME FEATURES
          BTST      #VOWELBIT,D4        ;TEST FOR VOWEL
          BEQ       PARERROR            ;NOT A VOWEL...ERROR

*-------- Convert ASCII number to binary and store in stress array

          ADD.L     D2,A0               ;BUMP POINTER INTO ASCII STRING
          LSR.W     #8,D0               ;MOVE ASCII CODE INTO LOWER BYTE
          AND.B     #$0F,D0             ;ISOLATE NUMBER PORTION
          OR.B      #$30,D0             ;'OR' IN STRESSED SEGMENT AND
*                                        ;     SYLLABLE MARKERS
          MOVE.B    D0,-1(A3,D3)        ;STORE INTO STRESS ARRAY
          BRA       PARNXT1             ;DON'T BUMP INDEX INTO PHON ARRAY


*-------- Not a stress number, must be a phoneme code

PARNOTNM  ADD.L     D2,A0               ;BUMP POINTER INTO ASCII STRING
          MOVEQ     #0,D4
          MOVE.B    D1,D4               ;GET PC
          LSL.W     #2,D4               ;FM INDEX
          MOVE.L    0(A4,D4),D4         ;GET FEATURES
          BTST      #INVALIDBIT,D4      ;INVALID PHONEME CODE?
          BNE       PARERROR            ;YES, RETURN AN ERROR
          BTST      #WORDBRKBIT,D4      ;WORD BREAK?
          BEQ.S     PARPUNI             ;NO, BRANCH
          MOVEQ     #0,D5               ;YES, CLEAR FOR USE AS INDEX
          MOVE.B    -1(A2,D3),D5        ;     GET LEFT PHONEME CODE
          LSL.W     #2,D5               ;     CONVERT TO F.M. INDEX
          MOVE.L    0(A4,D5),D5         ;     GET FEATURES
          BTST      #WORDBRKBIT,D5      ;     IS IT A WORD BREAK?
          BEQ.S     PARSTORE            ;     NO, STORE PHON


*-------- Found two word breaks next to one another.
*         Overwrite the old pc with the new one.  If
*         D3 <= 4, then there is no real text preceeding
*         the wordbreak.  In this case, just ignore word break.
*         Also, don't store a blank over any previous punctuation.

          CMP.W     #4,D3               ;ANY PREVIOUS TEXT?
          BLE       PARNXT1             ;NO, DONT STORE ANYTHING
          TST.B     D1
          BEQ       PARNXT1             ;IF BLANK, DON'T OVERSTORE
          SUBQ.W    #1,D3               ;BACKUP IN PHON ARRAY
          BRA.S     PARSTORE            ;STORE PUNCTUATION MARK


*-------- Check for P-Unit initiators or terminators

PARPUNI   CMP.B     #PHCLP,D1           ;P-UNIT INITIATOR?
          BNE.S     PARPUNF             ;NO
          BSET      #PUNITI,0(A6,D3)    ;YES, SET P-UNIT INITIATOR BIT
          BRA       PARMAIN             ;     DO NOT STORE ANY PHON CODE

PARPUNF   CMP.B     #PHCRP,D1           ;P-UNIT TERMINATOR?
          BNE.S     PARSTORE            ;NO
          BSET      #PUNITT,-1(A6,D3)   ;YES, SET P-UNIT TERMINATOR BIT
          BRA       PARMAIN             ;     DO NOT STORE ANY PHON CODE


*-------- Store phoneme code and clear stress and dur arrays

PARSTORE  MOVE.B    D1,0(A2,D3)         ;STORE PHONEME CODE
          ADDQ.W    #1,D3               ;BUMP INDEX
          CMP.B     #PHCPE,D1           ;PERIOD?
          BEQ.S     PARDONE             ;YES
          CMP.B     #PHCQM,D1           ;QUESTION MARK?
          BEQ.S     PARDONE             ;YES

PARNEXT   CMP.W     #MAXPHONL,D3        ;DO WE OVERFLOW PHON ARRAY?
          BLT.S     PARNXT1             ;NO
          SUB.L     PARSTART(A5),A0     ;YES,
          MOVE.L    A0,PARLENTH(A5)     ;     COMPUTE LENGTH,
          MOVE.W    #$02,CCR            ;     SET OVERFLOW,
          RTS                           ;     AND RETURN

PARNXT1   MOVE.L    A0,A1               ;COMPUTE LENGTH OF INPUT THAT
          SUB.L     PARSTART(A5),A1     ;     WE'VE PARSED SO FAR
*;;;;;;;          ADDQ.W    #1,A1
          CMP.W     MAX2PARS(A5),A1     ;MAX ALLOWED TO PARSE?
          BGE.S     PARDONE             ;YES, RETURN TO MAIN
          CLR.B     0(A3,D3)            ;NO, CLEAR NEXT STRESS
          CLR.B     0(A6,D3)            ;    CLEAR NEXT DUR
          BRA       PARMAIN             ;    CONTINUE PARSING


*-------- Found an error in input string

PARERROR  MOVE.L    A0,D3               ;CURRENT POS IN STRING
          SUB.L     PARVERYB(A5),D3     ;  - VERY BEGINNING OF STRING
          ADDQ.W    #1,D3               ;  + 1 = POS OF ERROR
          RTS                           ;RETURN


*-------- Done processing input

PARDONE   MOVEQ     #0,D0
          MOVE.B    -1(A2,D3),D0        ;GET LAST CODE IN PHON ARRAY
          BNE.S     PARDON1             ;NOT A SPACE
          SUBQ.W    #1,D3               ;LAST PHON A SPACE, OVERWRITE
          BRA.S     PARDON1X            ;       WITH A DASH
PARDON1   LSL.W     #2,D0               ;CONVERT TO F.M. INDEX
          MOVE.L    0(A4,D0),D0         ;GET PHONEME FEATURES
          BTST      #PAUSEBIT,D0        ;IS LAST PHON A PAUSE?
          BNE.S     PARDON2             ;YES, DON'T NEED TO ADD ANYTHING
PARDON1X  CMP.W     #3,D3               ;DO WE ONLY HAVE A 'QX' ?
          BLE.S     PARDON2             ;YES, DO NOT INSERT A DASH
          MOVE.B    #PHCDA,0(A2,D3)     ;NO, INSERT A DASH IN PHON
          CLR.B     0(A3,D3)            ;             CLEAR STRESS
          CLR.B     0(A6,D3)            ;             CLEAR DUR
          ADDQ.W    #1,D3               ;  INCREASE SIZE OF OUTPUT ARRAYS

PARDON2   MOVE.B    #$FF,0(A2,D3)       ;INSERT 'FF' IN PHON ARRAY,
          MOVE.B    #$FF,0(A3,D3)       ;               STRESS ARRAY, AND
          MOVE.B    #$FF,0(A6,D3)       ;               DUR ARRAY
          ADDQ.W    #1,D3               ;BUMP LENGTH OF OUTPUT ARRAYS
          SUB.L     PARSTART(A5),A0     ;COMPUTE LENGTH OF ASCII STRING
          MOVE.L    A0,PARLENTH(A5)     ;SAVE
          MOVE.W    A0,D0               ;GET LENGTH IN D REGISTER AND
*;;;;          SUB.W     D0,LFT2PARS(A5)     ;    REDUCE AMOUNT LEFT TO PARSE
          CMP.W     #4,D3               ;ANYTHING TO SAY?
          BGT.S     RETURN              ;YES
          MOVEQ     #0,D3               ;NO
          RTS                           ;JUST RETURN
*
RETURN    MOVE.W    D3,PHONLEN(A5)      ;SAVE PHON ARRAY LENGTH
          MOVE.W    #$08,CCR            ;SET CC TO NEGATIVE (NO ERROR)
          RTS

          END 


	TTL	'$Header: strmark.asm,v 32.1 86/01/22 00:24:41 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: strmark.asm,v 32.1 86/01/22 00:24:41 sam Exp $
*
* $Locker:  $
*
* $Log:	strmark.asm,v $
* Revision 32.1  86/01/22  00:24:41  sam
* placed under source control
* 
*
**********************************************************************
          SECTION      speech


*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                                           ;
*                        MARK STRESSED SEGMENTS                             ;
*                                                                           ;
*    A0 - STRESS ARRAY               A1 - PHON ARRAY                        ;
*    A2 - FEATURES MATRIX            A3 -                                   ;
*    A4 -                            A5 - GLOBALS AREA                      ;
*    A6 -                            A7 - STACK POINTER                     ;
*                                                                           ;
*    D0 - PHONEME STRESS             D1 - PHONEME CODE                      ;
*    D2 - PC FEATURES                D3 -                                   ;
*    D4 -                            D5 -                                   ;
*    D6 -                            D7 -                                   ;
*                                                                           ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 
          INCLUDE   'featequ.i'
          INCLUDE   'gloequs.i'
          INCLUDE   'pcequs.i'

          XREF      FEAT
          XDEF      STRMARK

*-------- Initialize pointers

STRMARK   LEA       STRESS(A5),A0       ;GET ADDRESS OF STRESS ARRAY
          LEA       PHON(A5),A1         ;GET ADDRESS OF PHON ARRAY
          LEA       FEAT,A2             ;GET ADDRESS OF FEATURE ARRAY
          MOVEQ     #0,D0
          SUBQ.L    #1,A1               ;SET A1 TO POINT TO PREVIOUS PHONEME


*-------- Main loop.  Sets stressed segment bit on consonents preceeding
*         stressed vowels.

STRLOOP   MOVEQ     #0,D1               ;CLEAR D1
          MOVE.B    (A1)+,D1            ;GET 'PREVIOUS' PHONEME CODE
          MOVE.B    (A0)+,D0            ;GET ENTRY FROM STRESS ARRAY
          BEQ.S     STRLOOP             ;IF STRESS = 0 (UNSTRESSED), SKIP
          CMP.B     #$FF,D0             ;END OF STRESS ARRAY?
          BEQ.S     STREND              ;YEP
          LSL.W     #2,D1               ;CONVERT PHONEME CODE INTO F.M. INDEX
          MOVE.L    0(A2,D1),D2         ;GET FEATURE MATRIX ENTRY
          BTST      #CONSBIT,D2         ;CONSONANT?
          BEQ.S     STRLOOP             ;NO
          OR.B      #$10,-2(A0)         ;SET STRESSED SEGMENT BIT


*-------- Plosive aspirate preceeding liquid or glide which in turn preceeds a
*         stressed vowel is stressed  (extended to PLOS, PLOSA, FRIC, and 
*         AFFRIC)

          AND.L     #LIQUID+GLIDE,D2              ;EITHER LIQUID OR GLIDE?
          BEQ.S     STRCHKN                       ;CHECK FOR A NASAL
          MOVEQ     #0,D1                         ;CLEAR D1
          MOVE.B    -2(A1),D1                     ;GET PRE-PREVIOUS PHON
          LSL.W     #2,D1                         ;CONVERT TO F.M. INDEX
          MOVE.L    0(A2,D1),D2                   ;GET FEATURES
          BTST      #PLOSABIT,D2                  ;PLOSIVE ASPIRATE?
          BEQ.S     STRCHKP                       ;NO, CHECK OTHER STUFF
          OR.B      #$10,-3(A0)                   ;YES, SET STRSSD SEGMENT BIT
          CMP.B     #PHCS,-3(A1)                  ;PRECEEDED BY AN 'S'?
          BNE       STRLOOP
          OR.B      #$10,-4(A0)
          BRA       STRLOOP                       ;NEXT PHON\

STRCHKP   AND.L     #PLOS+AFFRIC+FRIC,D2          ;OTHER STUFF?
          BEQ       STRLOOP                       ;NO
          OR.B      #$10,-3(A0)                   ;YES, STRESS
          BRA       STRLOOP

STRCHKN   MOVE.L    0(A2,D1),D2                   ;GET FEATURES
          AND.L     #NASAL+PLOSA+PLOS,D2          ;IS IT A NASAL OR PLOSIVE?
          BEQ       STRLOOP                       ;NO
          CMP.B     #PHCS,-2(A1)                  ;YES, PRECEEDED BY AN 'S'?
          BNE       STRLOOP                       ;NO, SKIP
          OR.B      #$10,-3(A0)                   ;YES, SET STRESS SEGMENT BIT
          BRA       STRLOOP

STREND    RTS

          END 
	TTL	'$Header: syllable.asm,v 32.1 86/01/22 00:24:46 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: syllable.asm,v 32.1 86/01/22 00:24:46 sam Exp $
*
* $Locker:  $
*
* $Log:	syllable.asm,v $
* Revision 32.1  86/01/22  00:24:46  sam
* placed under source control
* 
*
**********************************************************************
          SECTION      speech


*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                                            ;
*                            SYLLABLE MARKER                                 ;
*                                                                            ;
*                                                                            ;
*    A0 - ADDRESS OF PHON ARRAY      A1 - ADDRESS OF STRESS ARRAY            ;
*    A2 - ADDRESS OF DURATION ARRAY  A3 - ADDRESS OF FEATURE MATRICES        ;
*    A4 -                            A5 - GLOBALS AREA                       ;
*    A6 -                            A7 - STACK POINTER                      ;
*                                                                            ;
*    D0 - INDEX INTO PHON ARRAY      D1 - PHONEME CODE                       ;
*    D2 - START OF SYL POSITION      D3 - PHONEME FEATURE                    ;
*    D4 - POSITION OF FIRST VOWEL    D5 - SCRATCH                            ;
*         IN SYLLABLE                                                        ;
*    D6 - FEATURES TO BE 'OR'D' IN   D7 -                                    ;
*         TO STRESS AND DUR ARRAYS                                           ;
*                                                                            ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


          INCLUDE     'featequ.i'
          INCLUDE     'pcequs.i'
          INCLUDE     'gloequs.i'

          XREF        FEAT
          XDEF        SYLLABLE


*-------- Syllable bits contained in the STRESS array

SYLSTART  EQU       $80       ;START OF SYLLABLE
SYLPOLY   EQU       $40       ;POLY-SYLLABLIC
SYLSTRD   EQU       $20       ;STRESSED PHONEMEM
SYLSGMT   EQU       $10       ;STRESSED SEGMENT


*-------- Syllable bits contained in the DUR array

SYLWORDF  EQU       $80       ;WORD FINAL
SYLPHRSF  EQU       $40       ;PHRASE FINAL


*-------- Initialize

SYLLABLE  LEA       PHON(A5),A0         ;GET ADDRESS OF PHON ARRAY
          LEA       STRESS(A5),A1       ;GET ADDRESS OF STRESS ARRAY
          LEA       DUR(A5),A2          ;GET ADDRESS OD DUR ARRAY
          LEA       FEAT,A3             ;GET ADDRESS OF FEATURE MATRICES

          MOVEQ     #1,D0               ;INDEX INTO PHON ARRAY
          MOVEQ     #0,D1
          MOVEQ     #2,D2
          MOVEQ     #0,D3
          MOVEQ     #0,D4
          MOVEQ     #0,D5
          MOVEQ     #0,D6


*-------- Syllable marking loop

SYLNEXT   ADDQ.W    #1,D0               ;BUMP INDEX INTO INPUT ARRAYS
          MOVEQ     #0,D1               ;CLEAR PHONEME CODE REGISTER
          MOVE.B    0(A0,D0),D1         ;GET PHONEME CODE
          BEQ       SYLBOUND            ;SPACE
          CMP.B     #$FF,D1              ;
          BEQ       SYLDONE             ;END OF INPUT STRING
*         CMP.B     #PHCQ,D1            ;
*         BEQ       SYLGLOTL            ;GLOTTAL STOP
          LSL.W     #2,D1               ;CONVERT PC INTO FM INDEX
          MOVE.L    0(A3,D1),D3         ;GET PHONEME FEATURES
          BTST      #PAUSEBIT,D3        ;
          BNE       SYLBOUND            ;BOUND
          BTST      #VOWELBIT,D3        ;
          BEQ.S     SYLNEXT             ;NOTHING INTERESTING, KEEP LOOKING


*-------- Found a vowel (treat LX and RX as non-vowels)

SYLVOWEL  LSR.W     #2,D1               ;RESTORE PHONEME CODE
          CMP.B     #PHCLX,D1           ;CHECK FOR LX
          BEQ.S     SYLNEXT             ;      ....IGNORE
          CMP.B     #PHCRX,D1           ;CHECK FOR RX
          BEQ.S     SYLNEXT             ;      ....IGNORE

*-------- Not an LX or RX, treat as a real vowel

          TST.W     D4
          BNE.S     SYLVOWL2            ;THIS IS THE SECOND VOWEL IN A WORD
          MOVE.W    D0,D4               ;FIRST OR ONLY VOWEL, MARK IT
          BRA.S     SYLNEXT             ;  AND CONTINUE


*-------- Found two vowels in a word.  Find syllable break.
*         Compute the number of segments to mark.

SYLVOWL2  MOVE.W    D0,D5               ;D5=CURRENT POSITION (POS)
          SUB.W     D4,D5               ;   POS-POSITION OF PREV VOWEL (VL)
          SUBQ.W    #1,D5               ;   POS-VL-1
          LSR.W     #1,D5               ;   (POS-VL-1)/2
          ADD.W     D4,D5               ;   (POS-VL-1)/2 + VL
          SUB.W     D2,D5               ;   (POS-VL-1)/2 + VL - POS OF 1ST
*                                        ;                       SEGMENT (P1S)


*-------- Setup syllable features.  Note that if D4=0 (no previous vowel)
*         then pick up byte from the beginning of the STRESS array.  This
*         will always be zero, insuring an unstressed vowel.

SYLVSET   MOVE.B    0(A1,D4),D6         ;GET STRESS BYTE
          AND.B     #SYLSGMT,D6         ;ISOLATE STRESSED SEGMENT BIT
          LSL.W     #1,D6               ;MOVE TO STRESSED SYLLABLE POSITION
          OR.B      #SYLPOLY,D6         ;SET POLYSYLLABIC BIT


*-------- Get phoneme to be marked as start of syllable.
*         LX and RX are never marked.

          MOVE.B    0(A0,D2),D4         ;GET PHON TO BE MARKED
          CMP.B     #PHCLX,D4           ;LX?
          BEQ.S     SYLUGX              ;YES, MARK NEXT PHON
          CMP.B     #PHCRX,D4           ;NO, RX?
          BNE.S     SYLIGX              ;YES  , MARK NEXT PHON
SYLUGX    OR.B      D6,0(A1,D2)         ;TRANSFER POLYSYLLABIC BIT, IF SET
          ADDQ.W    #1,D2               ;BUMP START OF SYL POINTER
          SUBQ.W    #1,D5               ;DECREASE NUMBER OF SYLS TO MARK
SYLIGX    OR.B      #SYLSTART,0(A1,D2)  ;MARK START OF SYLLABLE


*-------- Fill in syllable bits in STRESS array (DUR array not changed)

SYLVLOOP  OR.B        D6,0(A1,D2)      ;SET APPROPRIATE BITS
          ADDQ.W      #1,D2
          DBF         D5,SYLVLOOP      ;DO LOOP

          MOVE.W      D0,D4            ;UPDATE POSITION ON LAST VOWEL
          BRA         SYLNEXT


*-------- Found word boundry, possibly end of phrase

SYLBOUND  MOVE.B    0(A0,D2),D5         ;GET PHON TO BE MARKED
          CMP.B     #PHCLX,D5           ;LX?
          BEQ.S     SYLUGX2             ;YES, MARK NEXT PHON
          CMP.B     #PHCRX,D5           ;NO, RX?
          BNE.S     SYLIGX2             ;YES, MARK NEXT PHON
SYLUGX2   ADDQ.W    #1,D2               ;BUMP START OF SYL POINTER
SYLIGX2   OR.B      #SYLSTART,0(A1,D2)  ;MARK START OF SYLLABLE
          MOVEQ     #0,D5
          TST.W     D4
          BEQ.S     SYLBSKIP            ;IF D4=0, SKIP WORD FINAL MARKING
          OR.B      #SYLWORDF,0(A2,D4)  ;MARK VOWEL AS WORD FINAL
          MOVE.B    0(A1,D4),D5         ;GET STRESS OF LAST VOWEL
          AND.B     #SYLSGMT,D5         ;ISOLATE STRESSED SEGMENT BIT
          LSL.W     #1,D5               ;MOVE TO STRESSED SYLLABLE POSITION
          BCLR      #5,D6               ;RESET STR SYL BIT, KEEP POLY SYL
          OR.B      D5,D6               ;COMBINE STR AND POLY BITS
          MOVE.W    D0,D5               ;D5=POS
          SUB.W     D2,D5               ;  =POS - P1S
          SUBQ.W    #1,D5               ;  =POS - P1S - 1
SYLBLP1   OR.B      D6,0(A1,D2)         ;SET SYL BITS IN STRESS ARRAY
          ADDQ.W    #1,D2
          DBF       D5,SYLBLP1


*-------- If bound (as opposed to space), mark phrase final bits

          BTST      #PAUSEBIT,D3        ;PAUSE BIT ON?
          BEQ.S     SYLBSKIP            ;NO, A SPACE, SKIP PHRASE FINAL CODE

          MOVE.W    D4,D2               ;RESET D2 TO LAST VOWEL POSITION
          MOVE.W    D0,D5               ;D5=POS
          SUB.W     D4,D5               ;  =POS - VL
          SUBQ.W    #1,D5               ;  =POS - VL - 1

SYLBLP2   BSET      #6,0(A2,D2)         ;SET PHRASE FINAL BIT IN DUR ARRAY
          ADDQ.W    #1,D2
          DBF       D5,SYLBLP2


*-------- Setup for continuing syllable search

SYLBSKIP  MOVE.W    D0,D2               ;!!!sam 10/16/85!!!
          ADDQ.W    #1,D2
          MOVEQ     #0,D4               ;RESET LAST VOWEL POSITION
          MOVE.W    D4,D6               ;CLEAR POLYSYLLABIC BIT
          BRA       SYLNEXT             ;CONTINUE WITH NEXT PHONEME


*-------- Handle glottal stops

SYLGLOTL  MOVE.W    D0,D5               ;COMPUTE AMOUNT TO MARK
          SUB.W     D2,D5
          SUBQ.W    #1,D5
          BRA       SYLVSET             ;GO DO WORK

*-------- Return

SYLDONE   RTS                           ;RETURN

          END 



	TTL	'$Header: phonol.asm,v 32.1 86/01/22 00:24:27 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: phonol.asm,v 32.1 86/01/22 00:24:27 sam Exp $
*
* $Locker:  $
*
* $Log:	phonol.asm,v $
* Revision 32.1  86/01/22  00:24:27  sam
* placed under source control
* 
*
**********************************************************************
          SECTION      speech


*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                                            ;
*                   PHONOLOGICAL RULE INTERPRETER                            ;
*                                                                            ;
*                                                                            ;
*    A0 - ADDRESS OF RULE SET        A1 - ADDRESS OF PHON ARRAY              ;
*    A2 - STRESS ARRAY               A3 - DURATION ARRAY                     ;
*    A4 - FEATURE MATRICES           A5 - GLOBALS AREA                       ;
*    A6 - MUST CONTAIN ADDRESS OF RULE TABLE ON ENTRY                        ;
*                                                                            ;
*    D0 - INDEX INTO RULE SET        D1 - INDEX INTO PHON ARRAY              ;
*    D2 - PHONEME CODE               D3 - SCRATCH                            ;
*    D4 - SCRATCH                    D5 - SCRATCH                            ;
*    D6 - SCRATCH                    D7 - SCRATCH                            ;
*                                                                            ;
*                                                                            ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


          INCLUDE   'featequ.i'
          INCLUDE   'gloequs.i'

          XREF      FEAT
          XDEF      PHONOL


*-------- PHONOL Equs

PHORULLN  EQU          3      ;OFFSET TO RULE LENGTH
PHOOPTNS  EQU          3      ;OFFSET TO RULE OPTIONS
PHOKEYPC  EQU          0      ;OFFSET TO KEY (CENTER) PC
PHOLFTPC  EQU          1      ;OFFSET TO LEFT CONTEXT PC
PHORTPC   EQU          2      ;OFFSET TO RIGHT CONTEXT PC
PHOLFSPC  EQU          7      ;OPTION BIT FOR OPTIONAL-SPACE-ON-LEFT-OK
PHORTSPC  EQU          6      ;OPTION BIT FOR OPTIONAL-SPACE-ON-RIGHT-OK
PHORPLPC  EQU          4      ;OFFSET TO REPLACEMENT PC
PHOINSBF  EQU          5      ;OFFSET TO LEFT INSERTION PC
PHOINSAF  EQU          6      ;OFFSET TO RIGHT INSERTION PC
PHORULOF  EQU          7      ;OFFSET TO BEGINNING OF FEATURE BASED RULES
PHOLAST   EQU          7      ;BIT SPECIFYING LAST FEATURE BASED RULE
PHOONOFF  EQU          5      ;BIT SPECIFYING WHETHER BIT TO BE TESTED SHOULD BE
*                              ;    ON OR OFF
PHOBIT    EQU          6      ;BIT SPECIFYING BIT TEST (ON) OR STRESS (OFF)
PHOCONT   EQU          5      ;BIT ON SPECIFIES THAT OTHER RULES SHOULD BE TRIED


*-------- Initialize

PHONOL    LEA       PHON(A5),A1         ;GET ADDRESS OF PHON ARRAY
          LEA       STRESS(A5),A2       ;GET ADDRESS OF STRESS ARRAY
          LEA       DUR(A5),A3          ;GET ADDRESS OF DUR ARRAY
          LEA       FEAT,A4             ;GET ADDRESS OF FEATURE MATRICES

          MOVEQ     #-1,D0
          MOVEQ     #0,D1
          MOVEQ     #0,D2
          MOVEQ     #0,D3
          MOVEQ     #0,D4
          MOVEQ     #0,D7


*-------- Main phonological rules interpreter loop

PHOMAIN   MOVE.L    A6,A0               ;GET ADDRESS OF RULES TABLE
          ADDQ.W    #1,D1               ;BUMP INDEX INTO RULE SET
PHONXTST  MOVE.B    0(A1,D1),D2         ;GET/RESTORE PHONEME CODE
          CMP.B     #$FF,D2             ;END OF STRING?
          BEQ       PHODONE             ;YES, EXIT

          MOVEQ     #0,D0               ;CLEAR INDEX INTO RULE SET


*-------- Test for match of key (center) portion of rule

          MOVE.B    PHOKEYPC(A0),D3     ;GET KEY PC
          CMP.B     #$FF,D3             ;X'FF' MATCHES ALL
          BEQ.S     PHOMATCH
          CMP.B     D2,D3               ;DOES PHONEME CODE MATCH RULE?
          BEQ.S     PHOMATCH            ;YES


*-------- Get next rule

PHONXRUL  MOVE.B    PHORULLN(A0),D4     ;GET RULE SET LENGTH/OPTIONS
          AND.B     #$0F,D4             ;ISOLATE RULE SET LENGTH
          BEQ.S     PHOMAIN             ;HAVE GONE THRU ALL RULE SETS
          ADD.L     D4,A0               ;UPDATE A0 TO NEXT RULE SET
          BRA.S     PHONXTST            ;BEGIN TESTING WITH NEW RULE SET


*-------- Matched key portion, check left context

PHOMATCH  MOVE.B    PHOLFTPC(A0),D3     ;GET LEFT CONTEXT PC RULE
          CMP.B     #$FF,D3             ;
          BEQ.S     PHOMATLC            ;X'FF' MATCHES ALL
          CMP.B     -1(A1,D1),D3        ;DOES LEFT CONTEXT PC MATCH INPUT?
          BNE.S     PHONXRUL            ;NO, TRY NEXT RULE SET


*-------- Matched left context, check right context

PHOMATLC  MOVE.B    PHORTPC(A0),D3      ;GET RIGHT CONTEXT PC RULE
          CMP.B     #$FF,D3             ;X'FF' MATCHES ALL
          BEQ.S     PHOMATRT
          CMP.B     #$FF,1(A1,D1)       ;END OF PHON ARRAY?
          BEQ.S     PHONXRUL            ;YES. CANNOT POSSIBLY MATCH RIGHT CONTEXT
          CMP.B     1(A1,D1),D3         ;RIGHT CONTEXT MATCH PC?
          BNE.S     PHONXRUL            ;NO, TRY NEXT RULE SET


*-------- All phoneme code rules have applied, check feature based rules

*-------- Check center context rules

PHOMATRT  MOVE.B    0(A2,D1),D4         ;GET STRESS CODE (ALREADY HAVE PC IN D2)
          BSR       PHODORLS            ;CHECK KEY CONTEXT RULES
          BNE.S     PHONXRUL            ;A RULE DID NOT APPLY, TRY NEXT RULE SET


*-------- Center context rules applied, check left context

          MOVE.B    -1(A2,D1),D4                  ;GET STRESS FROM LEFT CONTEXT
          MOVE.B    -1(A1,D1),D2                  ;GET P.C. FROM LEFT CONTEXT
          BNE.S     PHODOLFT                      ;NOT SPACE, CHECK LEFT CONTEXT RULES
          BTST      #PHOLFSPC,PHOOPTNS(A0)        ;CHECK IF OPTIONAL SPACE ON LEFT OK
          BEQ.S     PHODOLFT                      ;NO, TRY RULE WITH SPACE
          MOVE.B    -2(A2,D1),D4                  ;GET STRESS RESIDING BEFORE SPACE
          MOVE.B    -2(A1,D1),D2                  ;GET P.C. RESIDING BEFORE SPACE
PHODOLFT  BSR       PHODORLS                      ;CHECK LEFT CONTEXT RULES
          BNE.S     PHONXRUL                      ;SOME RULE OF THE LEFT CONTEXT
*                                                 ;A RULE DID NOT APPLY, TRY NEXT RULE

*-------- Left context rules applied, check right context

          MOVE.B    1(A2,D1),D4                   ;GET STRESS FROM RIGHT CONTEXT
          MOVE.B    1(A1,D1),D2                   ;GET P.C. FROM RIGHT CONTEXT
          BNE.S     PHODORT                       ;NOT SPACE, CHECK RIGHT CONTEXT
          BTST      #PHORTSPC,PHOOPTNS(A0)        ;OPTIONAL SPACE ON RIGHT OK?
          BEQ.S     PHODORT                       ;NO, TRY RULE WITH SPACE
          MOVE.B    2(A2,D1),D4                   ;GET STRESS FROM P.C. AFTER SPACE
          MOVE.B    2(A1,D1),D2                   ;GET P.C. RESIDING AFTER SPACE
PHODORT   CMP.B     #$FF,D2                       ;END OF PHON ARRAY?
          BNE.S     PHODORT1                      ;  NO, TRY TO APPLY RULE
          CLR.B     D2                            ;  YES, ZERO OUT PC.
*                                                  ;       THE ONLY RULE THAT WILL
*                                                  ;       APPLY IS 'MATCH ALL'
*                                                  ;       RULE.  (KLUDGE)
PHODORT1  BSR       PHODORLS                      ;CHECK RIGHT CONTEXT RULES
          BNE       PHONXRUL                      ;A RULE DID NOT APPLY, TRY NEXT RULE


*-------- All rules have applied, do the appropriate thing

*         Replacement PC

PHOAPPLY  MOVE.B    PHORPLPC(A0),D3     ;GET REPLACEMENT PC
          CMP.B     #$FF,D3             ;X'FF' IMPLIES NO REPLACE
          BEQ.S     PHOAPLY0            ;SKIP REPLACE
          MOVE.B    D3,0(A1,D1)         ;DO REPLACEMENT


*         Left insertions

PHOAPLY0  MOVE.B    PHOINSBF(A0),D3     ;GET PHONEME TO PRE-INSERT
          CMP.B     #$FF,D3             ;
          BEQ.S     PHOAPLY1            ;X'FF' IMPLIES NO INSERT
          SUBQ.W    #1,D1               ;ADJUST INDEX FOR PRE-INSERTION
          BSR       PHOINSRT            ;DO INSERT
          BVC.S     PHOAPLYA
          RTS                           ;IF OVERFLOW, RETRUN
PHOAPLYA  ADDQ.W    #1,D1               ;ADJUST INDEX TO AFTER KEY PHONEME


*         Right insertion

PHOAPLY1  MOVE.B    PHOINSAF(A0),D3     ;GET PHONEME TO POST-INSERT
          CMP.B     #$FF,D3             ;
          BEQ.S     PHOAPLY2            ;X'FF' IMPLIES NO INSERT
          BSR       PHOINSRT            ;DO INSERT
          BVC.S     PHOAPLY2
          RTS                           ;IF OVERFLOW, RETURN


*-------- Check to see if we should continue with rules or start at beginning

PHOAPLY2  BTST      #PHOCONT,PHOOPTNS(A0)         ;
          BNE       PHONXRUL                      ;CONTINUE WITH NEXT RULE
          BRA       PHOMAIN                       ;START AT BEGINNING


*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                                            ;
*                                                                            ;
*           SUBROUTINE TO CHECK FEATURE AND STRESS BASED RULES               ;
*                                                                            ;
*           ON ENTRY:  D2 CONTAINS PC       D4 CONTAINS STRESS BYTE          ;
*                                                                            ;
*                                                                            ;
*                                                                            ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


PHODORLS  LSL.W     #2,D2                         ;CONVERT PC INTO FM INDEX
          MOVE.L    0(A4,D2),D3                   ;FEATURE MATRIX
          LSR.W     #2,D2                         ;RESTORE PC IN D2
PHODORLC  MOVE.B    PHORULOF(A0,D0),D5            ;GET RULE

*-------- There are two types of tests; one to determine if the stress of
*         phoneme in question matches the rule, the other checks for
*         specific features to be present or absent.

          BTST      #PHOBIT,D5          ;FEATURE TEST?
          BNE.S     PHOBITST            ;YES
          MOVE.B    D4,D3               ;NO, MOVE STRESS TO D3


*-------- Combined stress and feature tests

PHOBITST  BTST      #PHOONOFF,D5        ;TEST FOR BIT ON OR OFF
          BEQ.S     PHOBITOF            ;BIT IS SUPPOSED TO BE OFF
          NOT.L     D3                  ;INVERT FEATURE MATRIX
PHOBITOF  BTST      D5,D3               ;BIT TEST CORRECTLY SETS RC
          BNE.S     PHODONE             ;TEST FAILED, RETURN WITH NON-ZERO RC


*-------- Try next feature/stress rule

          ADDQ.W    #1,D0               ;BUMP INDEX INTO RULE SET
          EOR.B     #$FF,D5             ;FLIP RULE (KLUDGE FOR RC)
          BTST      #PHOLAST,D5         ;LAST RULE IN RULE SET?
          BNE.S     PHODORLS            ;NO, TEST NEXT RULE

PHODONE   RTS


*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                                            ;
*         PHONOL INSERT ROUTINE.  RIGHT NOW DOES NOT HANDLE OVERFLOWS        ;
*                                                                            ;
*         A1 - PHON ARRAY              A2 - STRESS ARRAY                     ;
*         A5 - DURATION ARRAY          A3 - TEMP                             ;
*         A4 -                         A5 -                                  ;
*         A6 -                         A7 - STACK POINTER                    ;
*                                                                            ;
*         D1 - INDEX INTO ARRAYS       D7 - LENGTH OF ARRAYS/MOVE AMOUNT     ;
*         D3 - PHONEME CODE TO INSERT                                        ;
*                                                                            ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


PHOINSRT  MOVEM.L   A0-A3,-(SP)         ;SAVE SOME REGS

          MOVEQ     #0,D7
          MOVE.W    PHONLEN(A5),D7      ;GET LENGTH OR ARRAYS
          CMP.W     #MAXPHONL,D7        ;OVERFLOW?
          BLT.S     PHOINAT1            ;NO
          MOVE.W    #$02,CCR            ;YES, SET OVERFLOW
          BRA.S     PHOINSRN            ;     AND RETURN
PHOINAT1  ADDQ.W    #1,PHONLEN(A5)      ;BUMP LENGTH OF ARRAYS

          ADD.L     D7,A1               ;POINT TO END OF PHON ARRAY
          ADD.L     D7,A2               ;                STRESS ARRAY
          ADD.L     D7,A3               ;                DURATION ARRAY
          SUB.W     D1,D7               ;COMPUTE LENGHT OF PORTION TO MOVE
          SUBQ.W    #2,D7               ;ADJUST PROPERLY FOR DBF
*                                        ;   REMEMBER TWO ZEROS AT BEGINNING
PHOINSLP  MOVE.B    -(A1),1(A1)         ;MOVE PHON ARRAY
          MOVE.B    -(A2),1(A2)         ;MOVE STRESS ARRAY
          MOVE.B    -(A3),1(A3)         ;MOVE DURATION ARRAY
          DBF       D7,PHOINSLP         ;LOOP FOR COUNT

          MOVE.B    D3,(A1)             ;INSERT PHONEME CODE
          CLR.B     (A2)                ;CLEAR STRESS ARRAY
          CLR.B     (A3)                ;CLEAR DURATION ARRAY
          ADDQ.W    #1,D1               ;ADJUST INDEX INTO PHON ARRAY

PHOINSRN  MOVEM.L   (SP)+,A0-A3         ;RESTORE REGISTERS

          RTS

          END 


	TTL	'$Header: phonet.asm,v 32.1 86/01/22 00:24:21 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: phonet.asm,v 32.1 86/01/22 00:24:21 sam Exp $
*
* $Locker:  $
*
* $Log:	phonet.asm,v $
* Revision 32.1  86/01/22  00:24:21  sam
* placed under source control
* 
*
**********************************************************************
             SECTION    speech
_AbsExecBase EQU	4
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                        ;
*         MAIN MODULE 'PHONET'           ;
*                                        ;
* FILLS COEF BUFFER WITH TARGET VALUES,  ;
* COMPUTES BOUNDARY VALUES AND CREATES   ;
* TRANSITIONS FROM BOUNDARIES TO TARGETS ;
*                                        ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*


	INCLUDE 'assembly.i'
 	INCLUDE 'exec/types.i'
	INCLUDE 'exec/nodes.i'
	INCLUDE 'exec/lists.i'
	INCLUDE 'exec/strings.i'
	INCLUDE 'exec/initializers.i'
	INCLUDE 'exec/memory.i'
	INCLUDE 'exec/interrupts.i'
	INCLUDE 'exec/ports.i'
	INCLUDE 'exec/libraries.i'
	INCLUDE 'exec/devices.i'
	INCLUDE 'exec/io.i'
	INCLUDE 'exec/tasks.i'
	INCLUDE 'exec/resident.i'
	INCLUDE 'hardware/custom.i'

io_Size	EQU	IO_SIZE
         INCLUDE   'featequ.i'
         INCLUDE   'pcequs.i'
         INCLUDE   'gloequs.i'
	 INCLUDE   'devices/audio.i'
         INCLUDE   'private.i'
*
         EXTERN_SYS AllocMem

         XDEF     PHONET
         XREF     FEAT
         XREF     AMP1T,F1T,RANK,PCT,TEXT,TINT,IHNDUR,MINDUR,FEM1,MOUTHS
*	 XREF	  _AbsExecBase
*
PHONET   BSR      COMPRESS     ;REMOVE IGNORES
	 BSR      FILLDUR      ;FILL IN MISSING DURS
         BSR      COEFOVFL     ;LOOK FOR POSSIBLE COEF OVFL
         BSR      FILLCOEF     ;FILL COEF WITH TARGETS
         BSR.S    CLRCOEF      ;CLEAR F0 ELEMENTS
         BSR      BVAL         ;CALCULATE BOUNDARY VALUES
         BSR      TRANSIT      ;COMPUTE TRANSITIONS
         CLR.W    D0           ;INSURE OVFL NOT SET
         RTS
*
*      SUBROUTINE 'CLRCOEF'
*
* FILLS COEF WITH 0,0,0,FE,FE,FE,0,0...
* SEQUENCES.  THIS IS CONSIDERED A 'CLEAR'
* COEF BUFFER.
* THIS ROUTINE HAS BEEN MOD'ED TO CLEAR F0 ONLY.
*
CLRCOEF  MOVE.L   COEFPTR(A5),A6
*         LEA      COEF,A6     ;PT TO 1ST F1 SPOT
         MOVE.B   #$FF,D1     ;FOR COMPARES
CLRC2    CMP.B    (A6),D1     ;END?
         BNE.S    CLRC1       ;NO, BRANCH
         MOVE.L   COEFPTR(A5),A6
*         LEA      COEF,A6
         MOVE.B   #160,7(A6)  ;STARTING F0=75HZ
         RTS
CLRC1    CLR.B    7(A6)       ;CLEAR F0 ELEMENT
         ADDQ.L   #8,A6       ;INCR ADDR
         BRA      CLRC2
*
* SUBROUTINE 'FILLDUR'
*
* FILLS IN MISSING DURATIONS OF PRIME PHONS,
* ALSO PLACES FRIC RECORDING #'S OF PRIME
* ASPS IN PLACE OF THE 4 LSB STRESS NUMBER.
*
*         REGISTER USAGE
*
* D0=PHON  D1=FEATURE  D6=SCRATCH  D7=SCRATCH
* A0=PHON  A1=DUR  A2=STRESS A4=FEAT
*
FILLDUR  LEA      PHON(A5),A0
         LEA      DUR(A5),A1
         LEA      STRESS(A5),A2
         LEA      FEAT,A4
         MOVEQ    #0,D7        ;CLEAR SCRATCH
FILD0    MOVEQ    #0,D0        ;CLEAR PHON
         MOVE.B   (A0),D0      ;GET PHON
         CMP.B    #$FF,D0      ;LAST PHON?
         BNE.S    FILD9        ;NO, BRANCH
         RTS
FILD9    CMP.B    #PHCRX,D0    ;RX?
         BNE.S    FILD2        ;NO, BRANCH
         MOVEQ    #0,D6
         MOVE.B   (A1),D6      ;YES, GET DUR
         AND.B    #$3F,D6      ;ISOLATE
         MOVE.B   -1(A1),D7    ;GET DUR OF PREV VOWEL
         AND.B    #$3F,D7      ;ISOLATE
         ADD.W    D7,D6        ;ADD TOGETHER
         MOVE.W   D6,D7        ;COMPUTE 3/4 OF SUM
         LSR.W    #2,D7
         SUB.W    D7,D6
         LSR.W    #1,D6        ;/2, AND DISTRIBUTE
         AND.B    #$C0,(A1)    ;CLEAR DUR OF RX
         AND.B    #$C0,-1(A1)  ;CLEAR DUR OF VOWEL
         OR.B     D6,(A1)      ;REPLACE WITH
         OR.B     D6,-1(A1)    ; NEW DURATIONS
         BRA      FILD3        ;BUMP PTRS
FILD2    LSL.W    #2,D0        ;INDEX FOR FEAT
         MOVE.L   0(A4,D0),D1  ;GET FEATURE
         LSR.W    #2,D0        ;RESTORE PHON #
         BTST     #DIPHBIT,D1  ;DIPHTHONG?
         BEQ.S    FILD1        ;NO, BRANCH
         MOVE.B   (A1),D6      ;YES, GET DURATION
         AND.B    #$3F,D6      ;ISOLATE DURATION
         LSR.B    #1,D6        ;/2
         OR.B     D6,1(A1)     ;PLACE IN DIPH'
         ADDQ.B   #1,D6        ;MAKE UP FOR LOST FRAME
         AND.B    #$C0,(A1)    ;CLEAR DUR OF DIPH
         OR.B     D6,(A1)      ;PLACE IN DIPH
         ADDQ.L   #2,A0        ;INCR
         ADDQ.L   #2,A1        ;ARRAY
         ADDQ.L   #2,A2        ;POINTERS
         BRA      FILD0
FILD1    BTST     #PRIMEBIT,D1 ;PRIME?
         BEQ      FILD3        ;NO, BRANCH
         MOVE.B   -1(A2),(A2)  ;MOVE STRESS INFO OVER
         AND.B    #$7F,(A2)    ;REMOVE SYLL START BIT
         LEA      IHNDUR,A3    ;A3 PTS TO DURATION PARMS
         ADD.L    D0,A3        ;ADD PHON #
         BTST     #4,(A2)      ;STRESSED SEGMENT?
         BNE.S    FILD4        ;YES, SKIP
         ADD.L    #128,A3      ;NO, USE MINDUR
FILD4    MOVE.B   (A3),(A1)+   ;MOVE IN DURATION & INCR
         ADDQ.L   #1,A0        ;INCR PHON PTR
         BTST     #ASPIRBIT,D1 ;ASPIR?
         BEQ.S    FILD5        ;NO, BRANCH
         MOVEQ    #0,D0        ;YES, GET PHON+1
         MOVE.B   (A0),D0
         LSL.W    #2,D0        ;INDEX FOR FEAT
         MOVE.L   0(A4,D0),D1  ;GET FEATURE
         AND.B    #$F0,(A2)    ;CLEAR STRESS #
         BTST     #FRONTBIT,D1 ;FRONT?
         BEQ.S    FILD6        ;NO, BRANCH
         OR.B     #3,(A2)      ;/H
         BRA.S    FILD5
FILD6    BTST     #ROUNDBIT,D1 ;ROUND?
         BEQ.S    FILD7        ;NO, BRANCH
         OR.B     #6,(A2)      ;/R
         BRA.S    FILD5
FILD7    BTST     #BACKBIT,D1  ;BACK?
         BEQ.S    FILD8        ;NO, BRANCH
         OR.B     #5,(A2)      ;/B
         BRA      FILD5
FILD8    OR.B     #4,(A2)      ;/M (DEFAULT)
FILD5    ADDQ.L   #1,A2        ;INCR DUR
         BRA      FILD0
FILD3    ADDQ.L   #1,A0        ;INCR PTRS
         ADDQ.L   #1,A1
         ADDQ.L   #1,A2
         BRA      FILD0
*
* SUBROUTINE 'COEFOVFL'
*
* COMPUTES SUM OF THE DUR ARRAY AND EXITS
* WITH OVFL BIT SET IF THE SUM EXCEEDS THE
* RESERVED SPACE FOR THE COEF BUFFER
*
*             REGISTER USAGE
* D0=RUNNING SUM  D2=SCRATCH  D5=FF  D6=3F
* A1=DUR   A5=VARS
COEFOVFL LEA    DUR(A5),A1
        MOVE.B  #$FF,D5         ;FOR QUICK COMPARES
        MOVEQ   #$3F,D6         ;FOR QUICK ANDS
        MOVEQ   #0,D0           ;ZERO THE SUM
        MOVEQ   #0,D2           ;CLEAR SCRATCH REG
COEFOV2 MOVE.B  (A1)+,D2        ;GET DUR & INCR
        CMP.B   D5,D2           ;END?
        BEQ.S   COEFOV1         ;YES, BRANCH
        AND.B   D6,D2           ;NO, ISOLATE DURATION
        ADD.W   D2,D0           ;ADD DURATION TO SUM
        BRA     COEFOV2         ;NEXT DUR ELEMENT
COEFOV1 MOVE.L  D0,MOTHSIZE(A5) ;SAVE #of MOUTHS
	LSL.L   #3,D0           ;MULTIPLY SUM * 8
        ADDQ.L  #8,D0           ;ADD 1 FRAME (FF'S)

*------- GET COEF BUFFER AND SAVE ADDRESS IN GLOBALS AREA -----------
*        AMIGA VERSION ONLY!!!! 

         MOVE.L  D0,COEFSIZE(A5)   ;SAVE SIZE FOR FreeMem
	 MOVEQ   #0,D1	
	 MOVE.L  _AbsExecBase,A6 
         CALLSYS AllocMem 
         TST.L   D0                ;OK?
         BNE.S   COEFOV3           ;YES, BRANCH
COEFOV5  MOVE.W  #2,CCR            ;NO, SET OVFL
         ADDQ.L  #4,SP             ;POP TO RTN TO MAINLINE
         RTS

COEFOV3  MOVE.L  D0,COEFPTR(A5)    ;SAVE BUFFER POINTER
	 TST.B   Mouth(A5)         ;MAKE MOUTHS?
	 BEQ.S   COEFOV4           ;NO, BRANCH
	 MOVE.L  MOTHSIZE(A5),D0   ;YES, ALLOCATE MEMORY
	 MOVEQ   #0,D1             ;    FOR MOUTH BUFFER
	 CALLSYS AllocMem
	 TST.L   D0
	 BEQ     COEFOV5
         MOVE.L  D0,MOTHPTR(A5)
COEFOV4  RTS
*
* SUBROUTINE 'FILLCOEF'
*
* FILLS COEF BUFFER WITH PHONEME TARGET VALUES
*
*           REGISTER USAGE
*
* D0=PHON  D1=FEATURE  D2=DUR  D3=AMP1,F1
* D4=AMP2,F2  D5=AMP3,F3  D6=FRIC  D7=SCRATCH
*
* A0=PHON  A1=DUR  A2=STRESS  A3=F1T or FEM1T
* A4=MOUTHS or FEAT   A5=VARS  A6=COEF
*
VOLINC   EQU       2          ;VOLUME INCR 2DB FOR
*                             ;  STRESSED PHONS
FILLCOEF LEA      PHON(A5),A0
         LEA      DUR(A5),A1
         LEA      STRESS(A5),A2
	 MOVE.L   MOTHPTR(A5),A4
         MOVE.L   COEFPTR(A5),A6
*         LEA      COEF,A6
FILL0    MOVEQ    #0,D0
         MOVE.B   (A0)+,D0     ;GET PHON & INCR
         CMP.B    #$FF,D0      ;DONE?
         BNE.S    FILL1        ;NO, BRANCH
         MOVEQ    #7,D6        ;YES, FILL LAST
FILL2    MOVE.B   #$FF,(A6)+   ;  FRAME WITH $FF'S
         DBF      D6,FILL2     ;LOOP, AND
         RTS                   ;  EXIT
FILL1    MOVEQ    #0,D2
         MOVE.B   (A1)+,D2     ;GET AND ISOLATE
         AND.B    #$3F,D2      ;  DURATION & INCR
         LSL.W    #2,D0        ;INDEX FOR FEAT
         MOVE.L   A4,D7        ;SAVE MOUTHS
	 LEA      FEAT,A4      ;POINT TO FEATURES
         MOVE.L   0(A4,D0),D1  ;GET FEATURE
         MOVE.L   D7,A4        ;RESTORE MOUTHS
         MOVEQ    #0,D3        ;CLEAR REGS
         MOVE.L   D3,D4
         MOVE.L   D3,D5
         LSR.W    #2,D0        ;RESTORE PHON #
         LEA      AMP1T,A3     ;PT TO AMPLITUDES
         ADD.L    D0,A3        ;ADD PHON
         MOVE.B   (A3),D3      ;GET AMP1T
         ADD.L    #128,A3
         MOVE.B   (A3),D4      ;GET AMP2T
         ADD.L    #128,A3
         MOVE.B   (A3),D5      ;GET AMP3T
* ADD 2DB TO NON-ZERO AMPL STRESSED SEGMENTS
         BTST     #4,(A2)      ;STRESSED?
         BEQ.S    FILL5        ;NO, BRANCH
         TST.B    D3           ;ZERO?
         BEQ.S    FILL5A       ;YES, BRANCH
         ADD.B    #VOLINC,D3   ;NO, ADD 2DB
         CMP.B    #31,D3       ;CLIPPED?
         BLE.S    FILL5A       ;NO, BRANCH
         MOVEQ    #31,D3       ;YES, FORCE 31DB
FILL5A   TST.B    D4
         BEQ.S    FILL5B
         ADD.B    #VOLINC,D4
FILL5B   TST.B    D5
         BEQ.S    FILL5
         ADD.B    #VOLINC,D5
FILL5    ADD.L    #5*128,A3
         MOVE.B   (A3),D6      ;GET FRIC
         SWAP     D3           ;POSITION AMPS
         SWAP     D4           ;IN HI WORD
         SWAP     D5
         MOVEQ    #0,D7
         BTST     #PRIMEBIT,D1 ;PRIME?
         BEQ.S    FILL3        ;NO, BRANCH
         BTST     #ASPIRBIT,D1    ;ASPIR?
         BEQ.S    FILL3        ;NO, BRANCH
         MOVE.B   (A2),D7      ;YES, GET FRIC #
         AND.B    #7,D7        ;ISOLATE
         LSL.B    #4,D7        ;POSITION

FILL3    LEA      F1T,A3       ;LOAD PTR TO MALE FORMANT TARGETS
         TST.W    SEX(A5)      ;CHECK FOR FEMALE
         BEQ.S    FILL6M       ;NO, KEEP MALE FORMANTS
         LEA      FEM1,A3      ;YES, USE FEMALE FORMANTS

* IF PHON IS A PERIOD OR QUESTION, USE THE FORMANTS OF THE PREVIOUS PHON
FILL6M   CMP.B    #PHCPE,D0    ;A PERIOD?
         BEQ.S    FILL6P       ;YES, BRANCH
         CMP.B    #PHCQM,D0    ;NO, QUESTION?
         BNE.S    FILL6        ;NO, BRANCH
FILL6P   MOVE.W   D0,-(SP)     ;SAVE PHON,
         MOVE.B   -2(A0),D0    ;GET PREVIOUS PHON & USE ITS FTARGS
         ADD.L    D0,A3        ;ADD PHON
         MOVE.W   (SP)+,D0     ;RESTORE ORIGINAL PHON 
         BRA.S    FILL6PA

FILL6    ADD.L    D0,A3        ;ADD PHON
FILL6PA  MOVE.B   (A3),D3      ;GET F1T
         ADD.L    #128,A3
         MOVE.B   (A3),D4      ;GET F2T
         ADD.L    #128,A3
         MOVE.B   (A3),D5      ;GET F3T
         OR.B     D7,D6        ;OR IN ASP # (IF ANY)
	 TST.B    Mouth(A5)    ;MAKING MOUTHS?
	 BEQ.S    FILL6A       ;NO, BRANCH
	 MOVE.L   A6,-(SP)     ;SAVE COEF
	 LEA      MOUTHS,A6
	 MOVE.B   0(A6,D0),D1  ;GET A MOUTH SHAPE
	 MOVE.L   (SP)+,A6     ;RESTORE COEF
* SUBTRACT 6DB OF NOISE FROM UNSTRESSED FRICATIVE
FILL6A   TST.B    D6           ;FRIC?
         BEQ.S    FILLSF       ;NO, BRANCH
         BTST     #4,(A2)      ;YES, STRESSED?
         BNE.S    FILLSF       ;YES, BRANCH
         MOVE.B   D6,D0        ;SAVE FRIC BYTE
         AND.B    #$F0,D0      ;  AND REMOVE AMPLITUDE
         AND.B    #$0F,D6      ;KEEP AMPLITUDE ONLY
         LSR.B    #1,D6        ;  AND SUBTRACT 6DB
         OR.B     D0,D6        ;OR BACK TOGETHER
* FILL IN COEF WITH TARGETS
FILLSF   SUBQ.W   #1,D2        ;LOOP COUNT = DUR - 1
FILL4    MOVE.B   D3,(A6)+     ;MOVE
         MOVE.B   D4,(A6)+     ; IN
         MOVE.B   D5,(A6)+     ; FORMANTS
         SWAP     D3           ;POSITION AMPLITUDES
         SWAP     D4           ; IN
         SWAP     D5           ; LOW WORDS
         MOVE.B   D3,(A6)+     ;MOVE
         MOVE.B   D4,(A6)+     ; IN
         MOVE.B   D5,(A6)+     ; AMPLITUDES
         SWAP     D3           ;RESTORE
         SWAP     D4           ; FORMANT
         SWAP     D5           ; POSITIONS
         MOVE.B   D6,(A6)+     ;MOVE IN FRIC
         ADDQ.L   #1,A6        ;SKIP OVER F0
         TST.B    Mouth(A5)    ;IF Mouth=TRUE
         BEQ.S    FILL4A       ;  THEN
         MOVE.B   D1,(A4)+     ;  MOVE MOUTH SHAPE INTO BUFFER
FILL4A   DBF      D2,FILL4     ;NEXT FRAME
         ADDQ.L   #1,A2        ;INCR STRESS PTR
         BRA      FILL0        ;NEXT PHON
*
* SUBROUTINE 'BVAL'
*
* COMPUTES BOUNDARY VALUES AT START OF EACH PHON
* SKIPS CALCULATION IF EITHER FORMANT AT BOUNDARY = 0
*
*              REGISTER USAGE
*
* D0=PHON  D1=FEAT & PCT.W  D2=RANK(P)  D3=RANK(P+1)
* D4=TARGET.W  D5=LOCUS.W  D6=LOOP  D7 SCRATCH
* A0=PHON  A1=DUR  A2=RANK  A3=PCT  A4=FEAT
* A5 UNSUSED  A6=COEF
*
BVAL     LEA      PHON(A5),A0
         LEA      DUR(A5),A1
         LEA      RANK,A2
         LEA      PCT,A3
         LEA      FEAT,A4
         MOVE.L   COEFPTR(A5),A6
*         LEA      COEF,A6
BV0      MOVEQ    #0,D0
         MOVEQ    #0,D7        ;CLEAR SCRATCH
         MOVE.B   (A1)+,D7     ;GET DUR TO SCRATCH & INCR
         AND.B    #$3F,D7      ;ISOLATE DURATION
         LSL.W    #3,D7        ;*8
         ADD.L    D7,A6        ;COEF AT BOUNDARY F1
         MOVE.B   1(A0),D0     ;GET PHON+1
         CMP.B    #$FF,D0      ;END?
         BNE.S    BV1          ;NO, BRANCH
         RTS
BV1      LSL.W    #2,D0        ;INDEX FOR FEAT
         MOVE.L   0(A4,D0),D1  ;GET FEATURE
         BTST     #PRIMEBIT,D1 ;PRIME?
         BEQ.S    BV9          ;NO, BRANCH
         AND.L    #PLOS+PLOSA+ASPIR,D1 ;THESE THINGS?
         BEQ.S    BV9          ;NO, BRANCH
         ADDQ.L   #1,A0        ;SKIP THIS PHON
         BRA      BV0
BV9      LSR.W    #2,D0        ;RESTORE PHON+1
         SWAP     D0           ;SAVE PHON+1 IN HI WORD
         MOVE.B   (A0),D0      ;GET PHON
         MOVE.B   0(A2,D0),D2  ;GET RANK(P)
         SWAP     D0           ;GET PHON+1
         MOVE.B   0(A2,D0),D3  ;GET RANK(P+1)
         MOVEQ    #0,D1        ;CLR PCT
         CMP.B    D2,D3        ;COMPARE RANKS
         BGE.S    BV2          ;BRANCH, RANK(P+1) >= RANK(P)
         SWAP     D0           ;RANK(P+1) < RANK(P)
BV2      MOVE.B   0(A3,D0),D1  ;GET PCT(RANKING P)
         MOVEQ    #5,D6        ;PARM COUNT
BV5      MOVEQ    #0,D4        ;CLR TARGET
         MOVEQ    #0,D5        ;CLR LOCUS
         CMP.B    D2,D3        ;COMPARE RANKS
         BGE.S    BV3
         MOVE.B   (A6),D4      ;TARGET = COEF(P+1)
         MOVE.B   -8(A6),D5    ;LOCUS = COEF(P)
         BRA.S    BV4
BV3      MOVE.B   -8(A6),D4    ;TARGET = COEF(P)
         MOVE.B   (A6),D5      ;LOCUS = COEF(P+1)
BV4      CMP.B    #3,D6        ;FORMANT PARM?
         BLT.S    BV6          ;NO, BRANCH
         TST.B    D4           ;YES, EITHER ZERO?
         BEQ.S    BV7          ;YES, SKIP BV CALC
         TST.B    D5
         BEQ.S    BV7
* CALCULATE  BV = T + PCT * (L - T)
BV6      SUB.W    D4,D5        ;L=L-T
         MULS     D1,D5        ;*PCT
         ASR.L    #5,D5        ;JUSTIFY /32
         ADD.W    D4,D5        ;+T
         MOVE.B   D5,(A6)+     ;BVAL INTO COEF
BV8      DBF      D6,BV5       ;NEXT PARM
         ADDQ.L   #1,A0        ;NEXT PHON
         SUBQ.L   #6,A6        ;PT TO START OF CURRENT FRAME
         BRA      BV0
BV7      ADDQ.L   #1,A6        ;SKIP THIS PARM (F(N)=0)
         BRA      BV8
*
* SUBROUTINE 'TRANS'
* COMPUTES LOCATIONS OF FRAMES OF TRANSITION
* AND CLEARS THEM TO 00,00,00,FE,FE,FE,-,- PATTERN
*
*              REGISTER USAGE
*
* D0=DUR(P)  D1=LOOP  D2=T1  D3=T2  D4=RANK(P-1) & TRIAL & GAP
* D5=RANK(P)  D6=RANK(P+1)  D7=SCRATCH
* A0=PHON  A1=DUR  A2=RANK  A3=TEXT  A4=TINT & FEAT  A5 -  A6=COEF
*
TRANSIT  LEA      PHON(A5),A0      ;START AT 2ND PHON
         ADDQ.L   #1,A0
         LEA      DUR(A5),A1
         LEA      RANK,A2
         LEA      TEXT,A3
*        LEA      TINT,A4      ;TAKEN CARE OF IN LINE
         MOVE.L   COEFPTR(A5),A6
*         LEA      COEF,A6
         MOVEQ    #0,D0        ;CLEAR STUFF
         MOVE.L   D0,D1
         MOVE.L   D0,D2
         MOVE.L   D0,D3
         MOVE.L   D0,D4
         MOVE.L   D0,D7
         MOVE.B   (A1)+,D0     ;GET DUR(P-1)
         AND.B    #$3F,D0      ;ISOLATE
TR97     LSL.W    #3,D0        ;*8
         ADD.L    D0,A6        ;ADD TO COEF (1ST BOUNDARY)
TRANS0   MOVEQ    #0,D0        ;CLR PHON & T1 AMPL FLAG
         MOVEQ    #0,D5        ;CLR T2 AMPL FLAG
         MOVEQ    #0,D7        ;CLEAR SCRATCH
         MOVE.B   -1(A0),D7    ;GET P-1
         MOVE.B   0(A2,D7),D4  ;GET R(P-1)  (R=RANK)
         MOVE.B   (A0),D7      ;GET P
         CMP.B    #$FF,D7      ;END?
         BNE.S    TR1          ;NO, BRANCH
         RTS                   ;NO, EXIT
TR1      MOVE.B   0(A2,D7),D5  ;GET R(P)
         MOVE.B   (A1)+,D0     ;GET DUR(P) & INCR
         AND.B    #$3F,D0      ;ISOLATE
         LSL.W    #2,D7        ;INDEX FOR FEAT
         LEA      FEAT,A4
         MOVE.L   0(A4,D7),D1  ;GET FEATURE
         BTST     #PLOSBIT,D1  ;A PLOSIVE?
         BNE.S    TR96         ;YES, BRANCH
         BTST     #PLOSABIT,D1 ;NO, PLOSIVE ASP?
         BEQ.S    TR98         ;NO, BRANCH
TR96     ADDQ.L   #1,A0        ;YES, INCR PHON
         BRA      TR97         ;MOVE COEF PTR & CONTINUE
TR98     LEA      TINT,A4      ;RESTORE A4
         MOVEQ    #0,D7        ;CLEAR SHIFTED PHON
         MOVE.B   1(A0),D7     ;GET P+1
         CMP.B    #$FF,D7      ;END?
         BNE.S    TR98A        ;NO, BRANCH
         BSET     #30,D0       ;YES, SET END OF UTTERANCE FLAG
TR98A    MOVE.B   0(A2,D7),D6  ;GET R(P+1)
         MOVEQ    #0,D7        ;CLEAR SCRATCH
         CMP.B    D5,D4        ;CMP R(P) & R(P-1)
         BLE.S    TR2
         MOVE.B   -1(A0),D7    ;R(P-1) > R(P)
         MOVE.B   0(A3,D7),D2  ;T1=TEXT(P-1)
         BRA.S    TR3
TR2      MOVE.B   (A0),D7      ;R(P-1) <= R(P)
         MOVE.B   0(A4,D7),D2  ;T1=TINT(P)
TR3      CMP.B    D5,D6        ;CMP R(P) & R(P+1)
         BGE.S    TR4
         MOVE.B   (A0),D7      ;R(P) > R(P+1)
         MOVE.B   0(A4,D7),D3  ;T2=TINT(P)
         BRA.S    TR9A
TR4      MOVE.B   1(A0),D7     ;R(P) <= R(P+1)
         MOVE.B   0(A3,D7),D3  ;T2=TEXT(P+1)
* CHECK FOR END OF UTTERANCE
TR9A     BTST     #30,D0       ;CHECK END OF UTTERANCE FLAG
         BEQ.S    TR9          ;NOT END, BRANCH
         MOVEQ    #0,D3        ;END, SET T2=0
* TEST FOR PLOSIVE VOWEL / VOWEL PLOSIVE COMBINATIONS
* IN SUCH, THE AMPLITUDES TO NOT TRANSITION
TR9      BTST     #SONORBIT,D1 ;(P) A SONORANT?
         BEQ.S    TR5          ;NO, BRANCH
         MOVEQ    #0,D7
         LEA      FEAT,A4
         MOVE.B   -1(A0),D7    ;YES, GET P-1
         LSL.W    #2,D7        ;INDEX FOR FEAT
         MOVE.L   0(A4,D7),D6  ;GET FEAT(P-1)
         MOVE.L   D6,D7        ;SAVE FEATURE
         AND.L    #PLOS+PLOSA,D6  ;NAUGHTY?
         BEQ.S    TR10         ;NO, BRANCH
         BSET     #31,D0       ;YES, SET T1 AMPL FLAG
         BRA.S    TR11         ; AND TEST FOR LIQUID+GLIDE
* TEST FOR PLOS + FRIC & ~VOICED / LIQUID+GLIDE
* TRANSITIONS SHOULD BE SET TO 2 AT THESE BOUNDARIES
TR10     BTST     #FRICBIT,D7  ;P-1 A FRIC
         BEQ.S    TR6          ;NO, BRANCH
         BTST     #VOICEDBIT,D7  ;YES, VOICED?
         BNE.S    TR6          ;YES, BRANCH
TR11     BTST     #LIQUIDBIT,D1  ;NO, (P) A LIQUID?
         BNE.S    TR8          ;YES, BRANCH
         BTST     #GLIDEBIT,D1 ;NO, GLIDE?
         BEQ.S    TR6          ;NO, BRANCH
TR8      MOVEQ    #2,D2        ;YES, FORCE T1=2
TR6      MOVEQ    #0,D7
         MOVE.B   1(A0),D7     ;GET P+1
         LSL.W    #2,D7
         MOVE.L   0(A4,D7),D6  ;GET FEAT(P+1)
         AND.L    #PLOS+PLOSA,D6  ;STUFF?
         BEQ.S    TR5          ;NO, BRANCH
         BSET     #31,D5       ;YES, SET T2 AMPL FLAG
*
TR5      SUBQ.W   #1,D0        ;DUR=DUR-1 (LOOP COUNT)
         SUBQ.B   #1,D2        ;T1=T1-1 TO ACCOUNT FOR BVAL POS
         BPL.S    TR7          ;NOT -, BRANCH
         MOVEQ    #0,D2        ;WENT -, FORCE ZERO
TR7      MOVE.W   #$FEFE,D6    ;CLEARING PATTERN
         MOVEQ    #2,D4        ;TRIAL=3
TRA7     MOVE.B   D2,D7        ;T1 TO SCRATCH
         ADD.B    D3,D7        ;ADD T2
         CMP.B    D0,D7        ;T1+T2 >= DUR?
         BLT.S    TRANS        ;NO, BRANCH
         SUBQ.B   #1,D2        ;YES, T1=T1-1
         BMI.S    TRALL        ;GO TO 'CLEAR ALL'
         SUBQ.B   #1,D3        ;T2=T2-1
         BMI.S    TRALL
         SUBQ.B   #1,D4
         BEQ.S    TRALL
         BRA      TRA7
TRANS    MOVE.B   D0,D4        ;GAP=DUR-T1-T2
         SUB.B    D2,D4
         SUB.B    D3,D4        ;D4=GAP
         MOVEQ    #0,D1
         MOVE.B   D2,D1        ;LOOP=T1
         BRA.S    TRA1
TRA2     CLR.W    (A6)         ;CLEAR ELEMENTS
         CLR.B    2(A6)
         BTST     #31,D0       ;TEST T1 AMPL FLAG
         BNE.S    TRA1         ;SET, NO AMPL TRANS
         MOVE.B   D6,3(A6)     ;NOT SET, CLEAR AMPLS
         MOVE.W   D6,4(A6)
TRA1     ADDQ.L   #8,A6        ;NEXT FRAME
         DBF      D1,TRA2
         MOVEQ    #0,D1
         MOVE.B   D4,D1        ;LOOP=GAP
         BRA.S    TRA3
TRA4     ADDQ.L   #8,A6        ;SKIP FRAME
TRA3     DBF      D1,TRA4
         MOVEQ    #0,D1
         MOVE.B   D3,D1        ;LOOP=T2
         BRA.S    TRA5
TRA6     CLR.W    (A6)         ;CLEAR ELEMENTS
         CLR.B    2(A6)
         BTST     #31,D5       ;TEST T2 AMPL FLAG
         BNE.S    TRA5A        ;SET, NO AMPL TRANS
         MOVE.B   D6,3(A6)
         MOVE.W   D6,4(A6)
TRA5A    ADDQ.L   #8,A6        ;NEXT FRAME
TRA5     DBF      D1,TRA6
         ADDQ.L   #1,A0        ;INCR PHON
         BRA      TRANS0
TRALL    MOVEQ    #0,D1        ;CLEAR ALL FRAMES
         MOVE.B   D0,D1        ;LOOP=DUR
         MOVEQ    #0,D4        ;GAP=0
         MOVEQ    #0,D3        ;T2=0
         BRA      TRA1

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*
* SUBROUTINE 'COMPRESS'
*
* DELETES 'IGNORE' TYPE PHONS FROM PHON STRESS & DUR
* ARRAYS AND COMPRESSES THE SPACES OUT.
*
COMPRESS LEA     PHON(A5),A0     ;PHON READ
         LEA     DUR(A5),A1      ;DUR READ
         LEA     STRESS(A5),A2   ;STRESS READ
         LEA     FEAT,A3
         MOVE.L  A5,-(SP)    ;PRESERVE A5
         MOVE.L  A0,A4       ;PHON WRITE
         MOVE.L  A1,A5       ;DUR WRITE
         MOVE.L  A2,A6       ;STRESS WRITE
         MOVE.B  #$FF,D4     ;USE INSTEAD OF IMMED'S
COMPR0   MOVEQ   #0,D0
         MOVE.B  (A0)+,D0    ;GET PHON
         MOVE.B  D0,D5       ;SAVE FOR LATER
         CMP.B   D4,D0       ;LAST PHON?
         BEQ.S   COMPR1      ;YES, EXIT
         MOVE.B  (A1)+,D1    ;GET DUR
         MOVE.B  (A2)+,D2    ;GET STRESS
         LSL.W   #2,D0       ;INDEX FOR FEATURE
         MOVE.L  0(A3,D0),D3 ;GET FEATURE
         BTST    #IGNOREBIT,D3  ;IGNORE?
         BNE     COMPR0      ;YES, DON'T USE
         MOVE.B  D5,(A4)+    ;NO, MOVE DATA BACK
         MOVE.B  D1,(A5)+
         MOVE.B  D2,(A6)+
         BRA     COMPR0      ;NEXT PHON
COMPR1   MOVE.B  D4,(A4)
         MOVE.B  D4,(A5)
         MOVE.B  D4,(A6)
         MOVE.L  (SP)+,A5    ;RESTORE A5
         RTS

         END
	TTL	'$Header: tag.asm,v 32.1 86/01/22 00:24:57 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: tag.asm,v 32.1 86/01/22 00:24:57 sam Exp $
*
* $Locker:  $
*
* $Log:	tag.asm,v $
* Revision 32.1  86/01/22  00:24:57  sam
* placed under source control
* 
*
**********************************************************************
        SECTION    speech

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                       ;
*               'F0FILL'                ;
*                                       ;
* TAGS STRESS ARRAY WITH FLAGS THAT     ;
* INDICATE THE START AND END OF THE     ;
* SYLLABIC NUCLEUS AND THE LAST VOICED  ;
* SEGMENT OF THE SYLLABLE. PASS 2 FILLS ;
* THE F0 ELEMENTS OF COEF WITH THE END- ;
* POINTS OF THE F0 GESTURES AT POINTS   ;
* PROPORTIONAL TO THE SIZE OF THE MOVE- ;
* MENTS.                                ;
*                                       ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*
*          REGISTER USAGE
*
* D0=PHON  D1=FEATURE  D2=STRESS  D3-D7 UNUSED
* A0=PHON  A1=STRESS  A3=TEMP  A4=FEAT  A2/A5-A6 UNUSED
*
         INCLUDE   'featequ.i'
         INCLUDE   'pcequs.i'
         INCLUDE   'gloequs.i'
	 INCLUDE   'f0equs.i'
*
         XDEF     TAG
         XREF     FEAT
*
TAG      BSR.S    TAGSTR
         BSR      FZFILL
         RTS
*
* CLEAR ALL STRESS #'S TO ZERO
*
TAGSTR   LEA      STRESS(A5),A1
         MOVE.B   #$FF,D0     ;FOR COMPARES
         MOVE.B   #$F0,D1     ;FOR AND'S
TAGCLR   CMP.B    (A1),D0     ;END?
         BEQ.S    TAGCLR1     ;YES, BRANCH
         AND.B    D1,(A1)+    ;NO, CLEAR STRESS #
         BRA      TAGCLR
*
* TAG APPROPRIATE SEGMENTS
* TAGBITS: 1=NUCLEUS START  2=NUCLEUS END
*          4=SEG AFTER LAST VOICED SEG
*
TAGCLR1  LEA      PHON(A5),A0
         LEA      STRESS(A5),A1
         LEA      FEAT,A4
TAG0     MOVEQ    #0,D0
         MOVE.B   (A0)+,D0    ;GET PHON
         CMP.B    #$FF,D0     ;END?
         BNE.S    TAG1        ;NO, BRANCH
         RTS                  ;YES, EXIT
TAG1     LSL.W    #2,D0       ;INDEX FOR FEAT
         MOVE.L   0(A4,D0),D1 ;GET FEATURE
         MOVE.B   (A1)+,D2    ;GET STRESS
TAG8     BTST     #7,D2       ;SYLL START?
         BEQ      TAG0        ;NO, BRANCH
TAG3     BTST     #VOWELBIT,D1 ;YES, VOWEL?
         BNE.S    TAG2        ;YES, BRANCH
         MOVEQ    #0,D0       ;NO, KEEP LOOKIN'
         MOVE.B   (A0)+,D0    ;GET NEXT PHON
         LSL.W    #2,D0
         MOVE.L   0(A4,D0),D1 ;GET FEATURE
         MOVE.B   (A1)+,D2    ;GET NEXT STRESS
         BTST     #7,D2       ;SYLL START?
         BNE      TAG9        ;YES, TAG LAST PHON
         BTST     #PAUSEBIT,D1 ;NO, PAUSE?              **** MODIFIED 11/28
         BNE      TAG9        ;YES, TAG LAST PHON
         BRA      TAG3        ;NO, BACK TO VOWEL CHECK
TAG2     OR.B     #1,-1(A1)   ;TAG VOWEL AS NUC START
         BTST     #DIPHBIT,D1 ;DIPHTHONG?
         BNE      TAG4        ;YES, BRANCH
         MOVE.B   (A0),D3     ;LOOK AT NEXT PHON
         CMP.B    #PHCLX,D3   ;LX?
         BEQ.S    TAG4        ;YES, TREAT LIKE DIPH
         CMP.B    #PHCRX,D3   ;NO, RX?
         BEQ.S    TAG4        ;YES, TREAT LIKE DIPH
         OR.B     #2,(A1)     ;NO, TAG END OF NUC
         MOVE.L   A1,A3       ;SAVE LOC
         BRA.S    TAG7        ;GET NEXT PHON
TAG4     OR.B     #2,1(A1)    ;TAG END AFTER DIPH'
         MOVE.L   A1,A3       ;SAVE LOC OF VOICED SEG + 1
TAG7     MOVEQ    #0,D0       ;FIND LAST VOICED SEG OF SYLL
         MOVE.B   (A0)+,D0    ;GET NEXT PHON
         LSL.W    #2,D0
         MOVE.L   0(A4,D0),D1 ;GET FEATURE
         MOVE.B   (A1)+,D2    ;GET NEXT STRESS
TAG10    BTST     #7,D2       ;SYLL START?
         BNE.S    TAG6        ;YES, BRANCH
         BTST     #PAUSEBIT,D1  ;NO, PAUSE?             *** MODIFIED 11/28
         BNE.S    TAG6        ;YES, BRANCH
         BTST     #VOICEDBIT,D1  ;NEITHER, VOICED?
         BEQ      TAG7        ;NO, NEXT PHON
         MOVE.L   A1,A3       ;YES, SAVE LOC
         BRA      TAG7        ;GET NEXT PHON
TAG6     OR.B     #4,(A3)     ;TAG LAST VOICED SEG + 1
         BRA      TAG8        ;NEXT SYLL
*
* NO VOWEL FOUND IN SYLLABLE,
* USE LAST PHON AS NUCLEUS
* THIS IS NOT YET HANDLED PROPERLY !!
*
TAG9     OR.B     #1,-2(A1)   ;TAG NUC START
         OR.B     #2,-1(A1)   ;TAG NUC END
         OR.B     #4,-1(A1)   ;TAG LAST VOICED SEG
         BRA      TAG8
*
* SUBROUTINE 'FZFILL'
*
* FILLS F0 ELEMENTS WITH ENDPOINTS OF
* RISES, PEAKS, FALLS AND CONT. RISES
* CONTAINED IN THE SYLLABLE ARRAYS.
*
*          REGISTER USAGE
*
* D0=DUR  D1=COEF INDEX  D2=SCRATCH  D3=START PT
* D4=PEAK  D5=END PT  D6=CR  D7=SCRATCH
* A0=UNUSED  A1=DUR  A2=STRESS  A3=SYLL  A4=UNUSED
* A5=VARS  A6=COEF
*
FZFILL   LEA      START(A5),A3
         LEA      STRESS(A5),A2
         LEA      DUR(A5),A1
         MOVE.L   COEFPTR(A5),A6
*
* CONVERT BASELINE PITCH TO SAMPLES/GLOT PULSE
*
         MOVE.L   #1221000,D0
	 MOVE.L   #F0BOR*11100,D0 ;GRAND CONSTANT (1221000)
         DIVU     FREQ(A5),D0
         AND.L    #$FFFF,D0     ;CLEAR REMAINDER
         MOVE.L   D0,KHZ12(A5)  ;MOVE TO VARSPACE
         CMP.W    #1,F0MODE(A5) ;ROBOTIC MODE?
         BEQ      TAGROBOT      ;YES, DO ROBOTIC STUFF
FZF0     MOVEQ    #0,D0         ;NO, CLEAH EVAHBODY
         MOVEQ    #0,D1
         MOVEQ    #0,D2
         MOVEQ    #0,D3
         MOVEQ    #0,D4
         MOVEQ    #0,D5
         MOVEQ    #0,D6
         MOVEQ    #0,D7
         MOVE.B   (A1)+,D0    ;GET DUR
         CMP.B    #$FF,D0     ;END?
         BNE.S    FZF01       ;NO, BRANCH
         MOVE.W   #256,D1     ;YES, DISPL TO END ARRAY
         MOVEQ    #0,D5
         MOVE.B   -1(A3,D1),D5 ;GET LAST END VALUE
         MOVE.L   KHZ12(A5),D7 ;COMPUTE END HZ
         DIVU     D5,D7
         MOVE.B   D7,-1(A6)   ;PLACE AS LAST F0 ELEMENT
         RTS                  ;EXIT TO MAINLINE
FZF01    AND.B    #$3F,D0     ;ISOLATE DUR
         BTST     #0,(A2)+    ;NUC START?
         BNE.S    FZF1        ;YES, BRANCH
         LSL.W    #3,D0       ;NO, DUR * 8
         ADD.L    D0,A6       ;ADD TO COEF
         BRA      FZF0
FZF1     MOVE.B   (A3),D3     ;GET START PT
         MOVE.L   #128,D7
         ADD.L    D7,A3
         MOVE.B   (A3),D4     ;GET PEAK
         ADD.L    D7,A3
         MOVE.B   (A3),D5     ;GET END PT
         MOVE.B   D5,D6       ;DUPL END PT
         SWAP     D5          ; IN HI WORD
         MOVE.B   D6,D5       ; FOR USE LATER
         ADD.L    D7,A3
         MOVE.B   (A3)+,D6    ;GET CR & INCR
         SUB.L    #384,A3     ;RESET SYLL PTR
         MOVE.L   KHZ12(A5),D7
         DIVU     D3,D7       ;COMPUTE START HZ
         MOVE.B   D7,7(A6)    ;PLACE IN COEF
         AND.B    #$70,D6     ;ISOLATE CR#
         LSR.B    #1,D6       ;CR# * 8HZ
         MOVEQ    #0,D1
         BRA.S    FZF3A
FZF3     MOVEQ    #0,D0       ;FIND NUC END PT
         MOVE.B   (A1)+,D0    ;GET DUR
         AND.B    #$3F,D0     ;ISOLATE
         BTST     #1,(A2)+    ;NUC END?
         BNE.S    FZF2        ;YES, BRANCH
FZF3A    LSL.W    #3,D0       ;DUR * 8
         ADD.W    D0,D1       ;BUMP NUC LENGTH
         BRA      FZF3        ;NEXT PHON
FZF2     MOVE.W   D1,D7       ;SAVE NUC LENGTH
         SWAP     D1          ; IN HI WORD
         MOVE.W   D7,D1       ; FOR USE LATER
         TST.B    D6          ;A CR?
         BEQ.S    FZF2A       ;NO, BRANCH
* IF A CR, PUT END PT 1/2 WAY THRU NUCLEUS
* INSTEAD OF AT END
         LSR.W    #3,D1       ;CONVERT LEN TO FRAMES
         MOVE.W   D1,D7       ;LEN TO SCRATCH
         LSR.W    #1,D7       ;LEN / 2
         SUB.W    D7,D1       ;D1 = 1/2 LEN
         LSL.W    #3,D1       ;CONVERT BACK TO ELEMENTS
FZF2A    MOVE.L   KHZ12(A5),D7
         DIVU     D5,D7       ;COMPUTE END HZ
         MOVE.B   D7,-1(A6,D1) ;PLACE IN COEF
* COMPUTE POSITION OF PEAK IN TIME
         MOVEQ    #0,D7
         MOVE.B   D4,D7       ;PEAK TO SCRATCH
         SUB.W    D3,D7       ;SUB START
         BPL.S    FZF4        ;ABS VALUE
         NEG.W    D7
FZF4     MOVE.W   D7,D2
         LSL.W    #5,D7       ;DIFF * 32
         SUB.W    D4,D5       ;END - PEAK
         BPL.S    FZF5        ;ABS VALUE
         NEG.W    D5
FZF5     ADD.W    D5,D2       ;D2=TOTAL MOVEMENT (HZ)
         BEQ.S    FZF5A       ;IF ZERO SKIP PEAK PLACEMENT
         DIVU     D2,D7       ;PEAK POSITION RATIO
         MULU     D1,D7       ;*DUR
         LSR.W    #8,D7       ;NORMALIZE, D7=FRAME OF PEAK
         LSL.W    #3,D7       ;D7=ELEMENT PEAK POS
         MOVE.L   KHZ12(A5),D2
         DIVU     D4,D2       ;COMPUTE PEAK HZ
         MOVE.B   D2,-1(A6,D7)  ;PLACE IN COEF
FZF5A    SUBQ.L   #1,A1       ;PT TO NUC END 'CAUSE
         SUBQ.L   #1,A2       ; IT MIGHT BE A NUC START
         CLR.W    D1          ;CLEAR LO BEFORE SWAPPING
         SWAP     D1          ;GET NUC LENGTH BACK
         ADD.L    D1,A6       ;PT COEF AT NUC END
         TST.B    D6          ;A CR?
         BEQ      FZF0        ;NO, NEXT SYLLABLE
FZF7     MOVEQ    #0,D0       ;YES, GET DUR
         MOVE.B   (A1)+,D0
         AND.B    #$3F,D0     ;ISOLATE
         BTST     #2,(A2)+    ;LAST VOICED?
         BNE.S    FZF6        ;YES, BRANCH
         LSL.W    #3,D0       ;NO, DUR * 8
         ADD.L    D0,A6       ;ADD TO COEF
         BRA      FZF7        ;NEXT PHON
FZF6     SWAP     D5          ;GET END VALUE BACK
         ADD.W    D6,D5       ;ADD CONT. RISE
         MOVE.L   KHZ12(A5),D7   ;COMPUTE CR
         DIVU     D5,D7
         MOVE.B   D7,-1(A6)   ;PLACE IN COEF
         SUBQ.L   #1,A1       ;PT BACK AT WHERE
         SUBQ.L   #1,A2       ; COEF IS POINTING
         BRA      FZF0        ;NEXT SYLLABLE
*
* FILLS PITCH VALUES IN COEF BUFFER WITH MONOTONE
*
TAGROBOT MOVE.L   COEFPTR(A5),A6 ;PT TO COEF BUFFER
         MOVE.L   KHZ12(A5),D7   ;COMPUTE PITCH PERIOD
         DIVU     #F0BOR,D7      ;NORMALIZE FOR CORRECT PITCH
         ADDQ.L   #7,A6          ;PT TO PITCH ENTRIES
TAGROB1  CMP.B    #$FF,(A6)      ;END OF BUFFER?
         BEQ.S    TAGROB2        ;YES, BRANCH
         MOVE.B   D7,(A6)        ;MOVE IN PITCH VALUE
         ADDQ.L   #8,A6          ;PT TO NEXT FRAME
         BRA      TAGROB1
TAGROB2  RTS

         END 
	TTL	'$Header: prosod.asm,v 32.1 86/01/22 00:24:32 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: prosod.asm,v 32.1 86/01/22 00:24:32 sam Exp $
*
* $Locker:  $
*
* $Log:	prosod.asm,v $
* Revision 32.1  86/01/22  00:24:32  sam
* placed under source control
* 
*
**********************************************************************
              SECTION      speech

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                ;
*    MAIN MODULE 'PROSOD'        ;
*                                ;
* MODULE FETCHES AND MODIFIES    ;
* PHONEME DURATIONS BASED ON     ;
* CONTEXTUAL RULES               ;
*                                ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*
*    REGISTER USAGE
*
* D0=PCT  D1=PCT1  D2=STRESS,DUR  D3=FEATURE  D4=SCRATCH
* D5=FEAT INDEX    D6=SCRATCH     D7=SCRATCH
*
* A0=PHON PTR  A1=DUR PTR  A2=MINDUR  A3=STRESS PTR
* A4=FEATURE MATRIX  A5 UNUSED  A6=IHNDUR
*
*
        INCLUDE    'featequ.i'
        INCLUDE    'gloequs.i'
*
         XDEF    PROSOD
         XREF    FEAT,IHNDUR,MINDUR
*
PROSOD   LEA     PHON(A5),A0     ;INIT POINTERS
         LEA     DUR(A5),A1      ;PHON, DUR & STRESS WILL TRACK
         LEA     FEAT,A4
         LEA     STRESS(A5),A3
         LEA     IHNDUR,A6
         LEA     MINDUR,A2
         ADDQ.L  #2,A0       ;SKIP THE INITIAL BLANKS
         ADDQ.L  #2,A1
         ADDQ.L  #2,A3
PROS     MOVEQ   #0,D2
         MOVE.B  (A3),D2     ;GET STRESS
         SWAP    D2          ;MOVE TO HI WORD
         MOVE.B  (A1),D2     ;GET DUR BYTE (DUR PORTION = 0)
         MOVEQ   #$20,D0     ;PCT=32 TO BEGIN
         MOVEQ   #0,D5
         MOVE.B  (A0),D5     ;PHON TO D5
         CMP.B   #$FF,D5     ;END OF PHON STR?
         BNE.S   PROSA       ;NO, CONTINUE
         RTS     ;EXIT PROSOD
PROSA    LSL.W   #2,D5       ;INDEX TO FEAT
         MOVE.L  0(A4,D5),D3 ;FEATURE TO D3
         BTST    #IGNOREBIT,D3 ;IGNORE?
         BNE.S   PROSB         ;NO,
PROSC    BTST    #PAUSEBIT,D3  ; PAUSE?
         BEQ.S   PROS2       ;NO, DO RULES
         MOVEQ   #24,D6      ;YES, SET DUR=200MS (24 FR)
         BRA     PROSOD2
PROSB    ADDQ.L  #1,A1       ;YES, INCR PTR ADDR'S
         ADDQ.L  #1,A0
         ADDQ.L  #1,A3
         BRA.S   PROS        ;BRANCH FOR NEXT PHON DATA
*
* RULE1 NOT USED - RULE2 CLAUSE FINAL LENGTHENING
* PCT1=45 (140%) IF SEGMENT IS IN A CLAUSE FINAL SYLL.
*
PROS2    BTST    #6,D2       ;CLAUSE FINAL?
         BEQ.S   PROS3AA      ;NO, NEXT RULE
         MOVEQ   #45,D1      ;YES, PCT1=140%
         BSR     PCTMOD      ;PCT=(PCT1*PCT)/32
*
* RULE3A  A PHRASE FINAL LIQUID OR NASAL IS LENGTHENED
* BY PCT1=45 (140%)
*
* THIS RULE HAS BEEN MODIFIED TO WORD FINAL LIQUIDS & NASALS
*
PROS3AA  MOVE.L  D3,D6       ;FEATURE TO SCRATCH
         AND.L   #LIQUID+NASAL,D6  ;LIQUID OR NASAL?
         BEQ.S   PROS4A      ;NO, NEXT RULE
         CMP.B   #8,1(A0)       ;NEXT ELEMENT A NON-PHON
         BGT.S   PROS4A
PROS3A   MOVEQ   #45,D1      ;YES, PCT1=140%
         BSR     PCTMOD
*
PROS4A   BTST    #VOWELBIT,D3  ;VOWEL?
         BEQ     PROS6       ;NO, SKIP RULES 4,5,7
*
* RULE4  NON-WORD FINAL SHORTENING
* PCT1=27 (85%) IF NOT IN A WORD FINAL SYLLABLE
*
PROS4    BTST    #7,D2       ;WORD FINAL?
         BNE.S   PROS5       ;YES, NEXT RULE
         MOVEQ   #27,D1      ;NO, PCT1=85%
         BSR     PCTMOD
*
* RULE5  POLYSYLLABIC SHORTENING
* PCT1=26 (80%) IF IN A POLYSYLLABIC WORD
*
PROS5    BTST    #22,D2      ;POLYSYL?
         BEQ.S   PROS7       ;NO, NEXT RULE
         MOVEQ   #26,D1      ;YES, PCT1=80%
         BSR     PCTMOD
*
* RULE7  UNSTRESSED SHORTENING
* PCT1=22 (70%) IF UNSTRESSED VOWEL
* ALSO MINDUR=MINDUR/2 WHEN DUR IS COMPUTED
*
PROS7    BTST    #20,D2      ;STRESSED?
         BNE.S   PROS9       ;YES, NEXT RULE
         MOVEQ   #22,D1      ;NO, PCT1=70%
         BSR     PCTMOD
*
* RULE9  POSTVOCALIC CONTEXT OF VOWELS
*
PROS9    MOVEQ   #0,D6       ;GET FEAT OF PHON+1
         MOVE.B  1(A0),D6    ;PHON+1 TO SCRATCH
         LSL.W   #2,D6       ;INDEX TO FEAT
         MOVE.L  0(A4,D6),D7 ;FEAT TO SCRATCH
* OPEN SYLLABLE, STRESSED, WORD FINAL -- PCT1=120%
         BTST    #IGNOREBIT,D7  ;NOT A PHON?
         BNE.S   PROS9AA      ;YES, BRANCH
         BTST    #PAUSEBIT,D7 ;PAUSE?
         BEQ.S   PROS9A       ;NO, NEXT
PROS9AA   BTST    #4,(A3)     ;PHON STRESSED?
         BEQ.S   PROS9A      ;NO, NEXT
         MOVEQ   #38,D1      ;YES, PCT1=120%
         BSR     PCTMOD
         BRA     PROS10      ;NEXT RULE
* BEFORE A VOICED FRIC -- PCT1=118%  (DOWN FROM 160%)
PROS9A   BTST    #FRICBIT,D7 ;FRIC?
         BEQ.S   PROS9B      ;NO, NEXT
         BTST    #VOICEDBIT,D7  ;YES, VOICED?
         BEQ     PROS6A      ;NO, NEXT
         MOVEQ   #38,D1      ;YES, PCT1=118%
         BSR     PCTMOD
         BRA     PROS10
* BEFORE A VOICED PLOSIVE -- PCT1=120%
PROS9B   BTST    #PLOSBIT,D7 ;VOICED PLOS?
         BEQ.S   PROS9C      ;NO, NEXT
         MOVEQ   #38,D1      ;YES, PCT1=120%
         BSR     PCTMOD
         BRA     PROS10
* BEFORE AN UNSTRESSED NASAL -- PCT1=85%
PROS9C   BTST    #NASALBIT,D7  ;NASAL?
         BEQ.S   PROS9D      ;NO, NEXT
         BTST    #4,1(A3)    ;YES, UNSTRESSED?
         BNE     PROS6A      ;NO, NEXT
         MOVEQ   #27,D1      ;YES, PCT1=85%
         BSR     PCTMOD
         BRA     PROS10
* BEFORE A VOICELESS PLOSIVE -- PCT1=70%
PROS9D   BTST    #PLOSABIT,D7  ;PLOSA?
         BEQ.S   PROS6       ;NO, NEXT RULE
         MOVEQ   #22,D1      ;YES, PCT1=70%
         BSR     PCTMOD
         BRA     PROS10
*
* RULE6  NON-INITIAL CONSONANT SHORTENING
* PCT1=27 (85%) IF CONS. NOT WORD INITIAL
*
PROS6    BTST    #CONSBIT,D3 ;CONS?
         BEQ.S   PROS6A      ;NO, NEXT RULE
         CMP.B   #8,-1(A0)     ;YES, WORD INITIAL?
         BGT.S   PROS6A      ;NO, PREV PHON NON-BLANK
         MOVEQ   #27,D1      ;PREV PHON = BLANK
         BSR     PCTMOD
*
* RULE6A   UNSTRESSED PREVOCALIC LIQUID OR GLIDE
* PCT1=3 (10%)
*
PROS6A   BTST    #20,D2      ;STRESSED?
         BNE.S   PROS10      ;YES, NEXT RULE
         MOVE.L  D3,D4       ;FEATURE TO SCRATCH
         AND.L   #LIQUID+GLIDE,D4  ;LIQUID OR GLIDE?
         BEQ.S   PROS10      ;NO, NEXT RULE
         MOVEQ   #0,D4       ;CLEAR SCRATCH
         MOVE.B  1(A0),D4    ;GET PHON+1
         LSL.W   #2,D4       ;INDEX FOR FEAT
         BTST    #VOWELBIT,3(A4,D4)  ;PHON+1=VOWEL?
         BEQ.S   PROS10      ;NO, NEXT RULE
         MOVEQ   #3,D1       ;YES, PCT1=10%
         BSR     PCTMOD
*
* RULE10  SHORTENING IN CLUSTERS
* CLUSTERS IGNORE INTERVENING BLANKS, BUT NOT PUNCTUATION
* D6=PHON-1 FEATURE       D7=PHON+1 FEATURE
*
PROS10   MOVEQ   #0,D5
         MOVE.B  -1(A0),D5   ;PHON-1 CODE TO D5
         BNE.S   PROS10K     ;NOT A BLANK
         MOVE.B  -2(A0),D5   ;BLANK, GET NEXT PHON
PROS10K  LSL.W   #2,D5       ;INDEX FOR FEAT
         MOVE.L  0(A4,D5),D6 ;FEAT(PHON-1) TO D6
         MOVEQ   #0,D5
         MOVE.B  1(A0),D5    ;PHON+1 CODE TO D5
         BNE.S   PROS10L     ;NOT A BLANK
         MOVE.B  2(A0),D5    ;BLANK, GET NEXT PHON
PROS10L  LSL.W   #2,D5       ;INDEX FOR FEAT
         MOVE.L  0(A4,D5),D7 ;FEAT(PHON+1) TO D7
* VOWEL FOLLOWED BY A VOWEL -- PCT1=120%
         BTST    #VOWELBIT,D3  ;PHON=VOWEL?
         BEQ.S   PROS10C     ;NO, SKIP
         BTST    #VOWELBIT,D7  ;YES, PHON+1=VOWEL?
         BEQ.S   PROS10B     ;NO, NEXT
         MOVEQ   #38,D1      ;YES, PCT1=120%
         BSR     PCTMOD
* VOWEL PRECEDED BY A VOWEL -- PCT1=70%
PROS10B  BTST    #VOWELBIT,D6  ;PHON-1=VOWEL?
         BEQ.S   PROSOD1     ;NO, SKIP
         MOVEQ   #22,D1      ;YES, PCT1=70%
         BSR     PCTMOD
         BRA.S   PROSOD1
* CONS. SURROUNDED BY CONS'S -- PCT1=50%
PROS10C  BTST    #CONSBIT,D6 ;PHON-1=CONS?
         BEQ.S   PROS10E     ;NO, NEXT
         BTST    #CONSBIT,D7 ;YES, PHON+1=CONS?
         BEQ.S   PROS10DD    ;NO, NEXT
         MOVEQ   #16,D1      ;YES, PCT=50%
         BSR     PCTMOD
         BRA.S   PROSOD1     ;RULES COMPLETE
* CONS. PRECEDING A CONS. -- PCT1=70%
PROS10D  BTST    #CONSBIT,D6 ;PHON-1=CONS?
         BEQ.S   PROS10E     ;NO, NEXT
PROS10DD MOVEQ   #22,D1      ;YES, PCT1=70%
         BSR     PCTMOD
         BRA.S   PROSOD1
* CONS. FOLLOWED BY A CONS. -- PCT1=70%
PROS10E  BTST    #CONSBIT,D7 ;PHON+1=CONS?
         BNE.S   PROS10DD    ;YES, BRANCH BACK
*
* END OF RULES SECTION, APPLY DURATION FORMULA:
* DUR = ((INHDUR - MINDUR) * PCT) / 32 + MINDUR
* IF SEGMENT IS UNSTRESSED THEN MINDUR = MINDUR / 2
*
PROSOD1  MOVEQ   #0,D5       ;3 CLEARS
         MOVE.L  D5,D6
         MOVE.L  D5,D7
         MOVE.B  (A0),D5     ;PHON TO SCRATCH
         MOVE.B  0(A6,D5),D6 ;INHDUR TO D6
         MOVE.B  0(A2,D5),D7 ;MINDUR TO D7
         BTST    #20,D2      ;STRESSED SEGMENT?
         BNE.S   PROSOD3     ;YES, BRANCH
         BTST    #LIQUIDBIT,D3 ;LIQUID?
         BNE.S   PROSOD3     ;YES, DO NOT COMPRESS
         BTST    #GLIDEBIT,D3  ;NO, GLIDE?
         BNE.S   PROSOD3     ;YES, DO NOT COMPRESS
         LSR.B   #1,D7       ;NO, DIVIDE MINDUR BY 2
*        ADDQ.B  #1,D7       ;ROUND MINDUR
PROSOD3  SUB.B   D7,D6       ;D6 = IHNDUR - MINDUR
         MULU    D0,D6       ;MULTIPLY BY PCT (1/32'S)
         LSR.W   #5,D6       ;DIVIDE BY 32
         ADD.B   D7,D6       ;ADD MINDUR
*
* RULE11: ADDITIVE LENGTHENING DUE TO PLOSIVE ASPIRATION.
* A STRESSED SONORANT PRECEDED BY A VOICELESS PLOSIVE IS
* LENGTHENED BY 3 FRAMES.   (CHANGED TO STRESSED VOWEL)
*
         BTST    #VOWELBIT,D3  ;VOWEL?
         BEQ.S   PROSOD4     ;NO, SKIP
         BTST    #20,D2      ;YES, STRESSED?
         BEQ.S   PROSOD4     ;NO, SKIP
         MOVEQ   #0,D5
         MOVE.B  -1(A0),D5   ;PHON-1 TO SCRATCH
         LSL.W   #2,D5       ;INDEX FOR FEAT
         BTST    #3,2(A4,D5)  ;FEAT(PHON-1)=PLOSA?
         BEQ.S   PROSOD4     ;NO, SKIP
         ADD.B   #3,D6       ;YES, ADD 3 FRAMES
PROSOD4  CMP.B   #$3F,D6     ;TOO BIG?
         BLE.S   PROSOD2     ;NO, BRANCH
         MOVE.B  #$3F,D6     ;YES, CLAMP DURATION AT $3F
PROSOD2  AND.B   #$C0,(A1)   ;CLEAR DURATION OF GARBAGE
         OR.B    D6,(A1)     ;PUT DURATION IN ARRAY
         BRA     PROSB       ;BRANCH TO PTR INCR'S
*
* SUBROUTINE PCTMOD - PERFORMS CALCULATION: PCT = (PCT * PCT1) / 32
*       WITH ROUNDING.  PCT'S ARE ACTUALLY IN 1/32'S
*
PCTMOD   MULU    D1,D0       ;MULTIPLY BY # OF 1/32'S
         ADD.W   #$10,D0     ;ROUND
         LSR.W   #5,D0       ;DIVIDE BY 32
         RTS

         END 

	TTL	'$Header: f0init.asm,v 32.1 86/01/22 00:23:42 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: f0init.asm,v 32.1 86/01/22 00:23:42 sam Exp $
*
* $Locker:  $
*
* $Log:	f0init.asm,v $
* Revision 32.1  86/01/22  00:23:42  sam
* placed under source control
* 
*
**********************************************************************
          SECTION      speech


*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                                             ;
*                        F0 CONTOUR INITIALIZATION                            ;
*                                                                             ;
*                         ALL REGISTERS DESTROYED                             ;
*                                                                             ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


          INCLUDE   'gloequs.i'
          INCLUDE   'featequ.i'
          INCLUDE   'pcequs.i'
          INCLUDE   'f0equs.i'

          XREF      FEAT
          XDEF      F0INIT


*-------- Initialize pointers to various arrays to start of those arrays

F0INIT    LEA       DUR(A5),A0
          MOVE.L    A0,F0DUR(A5)
          LEA       STRESS(A5),A0
          MOVE.L    A0,F0STRESS(A5)
          LEA       PHON(A5),A0
          MOVE.L    A0,F0PHON(A5)
          LEA       ACCENT(A5),A0
          MOVE.L    A0,F0ACCENT(A5)
          LEA       PEAK(A5),A0
          MOVE.L    A0,F0PEAK(A5)
          LEA       FALL(A5),A0
          MOVE.L    A0,F0FALL(A5)
          LEA       RISE(A5),A0
          MOVE.L    A0,F0RISE(A5)
          LEA       CRBRK(A5),A0
          MOVE.L    A0,F0CRBRK(A5)
          LEA       TUNELV(A5),A0
          MOVE.L    A0,F0TUNELV(A5)
          LEA       START(A5),A0
          MOVE.L    A0,F0START(A5)
          LEA       FEND(A5),A0
          MOVE.L    A0,F0END(A5)


*         Ignore 1st two blanks in arrays

          ADDQ.L    #2,F0DUR(A5)
          ADDQ.L    #2,F0STRESS(A5)
          ADDQ.L    #2,F0PHON(A5)


*-------- Clear syllable variables

          CLR.W     F0NUMCLS(A5)        ;CLAUSE NUMBER
          CLR.W     F0NUMAS(A5)         ;NUMBER OF ACCENTED SYLLABLES
          CLR.W     F01STAS(A5)         ;POSITION OF 1ST ACCENTED SYLLABLE
          CLR.W     F0LASTAS(A5)        ;POSITION OF LAST ACCENTED SYLLABLE
          CLR.W     F0NUMSYL(A5)        ;NUMBER OF SYLLABLES
          CLR.W     F0NUMPHS(A5)        ;PHRASE NUMBER
          CLR.W     F0TOTSYL(A5)        ;TOTAL NUMBER OF SYLLABLES IN SENTENCE


*-------- Clear all syllable arrays

          MOVE.L    F0ACCENT(A5),A0     ;GET ADDRESSES
          MOVE.L    F0PEAK(A5),A1
          MOVE.L    F0RISE(A5),A2
          MOVE.L    F0FALL(A5),A3
          MOVE.L    F0START(A5),A4
          MOVE.L    F0END(A5),A6

          MOVE.W    #(F0MAXLEN-4)/4,D0  ;SET COUNT
F0CLEAR1  CLR.L     (A0)+               ;CLEAR EACH LONG
          CLR.L     (A1)+
          CLR.L     (A2)+
          CLR.L     (A3)+
          CLR.L     (A4)+
          CLR.L     (A6)+
          DBF       D0,F0CLEAR1

          MOVE.L    F0TUNELV(A5),A0
          MOVE.L    F0CRBRK(A5),A1

          MOVE.W    #(F0MAXLEN-4)/4,D0   ;SET COUNT
F0CLEAR2  CLR.L     (A0)+               ;CLEAR EACH LONG
          CLR.L     (A1)+
          DBF       D0,F0CLEAR2

          RTS


          END 
	TTL	'$Header: f0hls.asm,v 32.1 86/01/22 00:23:34 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: f0hls.asm,v 32.1 86/01/22 00:23:34 sam Exp $
*
* $Locker:  $
*
* $Log:	f0hls.asm,v $
* Revision 32.1  86/01/22  00:23:34  sam
* placed under source control
* 
*
**********************************************************************
          SECTION    speech

*      F0 HIGH LEVEL SYSTEM
*
*          ALL REGS DESTROYED
*
*          D3 - NUMBER OF AS               D4 - NUMBER OF SYLLABLES
*          D5 - POSITION OF FIRST AS       D6 - CLAUSE NUMBER
*
*
          INCLUDE     'gloequs.i'
          INCLUDE     'featequ.i'
          INCLUDE     'pcequs.i'
          INCLUDE     'f0equs.i'
 
          XREF       FEAT
          XDEF       F0HLS

F0HLS     ADDQ.W    #1,F0NUMCLS(A5)     ;INCREMENT COUNT OF CLAUSES

          BSR       F0CRACNT            ;CREATE ACCENT ARRAY
          BEQ.S     F0HLSRTN            ;CC  = 0 ==> END OF SENTENCE
          BVS.S     F0HLSRTN            ;CC  = OVFL ==> OVERFLOW
          BSR       F0CRCRBR            ;CREATE CR/BREAK ARRAY
          BSR       F0LEVEL             ;CREATE LEVEL
          BSR       F0TUNE              ;CREATE TUNE
          BSR       F0SETCR             ;MODIFY CR/BREAK ARRAY AT CLAUSE BNDRIES
          MOVE.W    #$0,CCR             ;SET CC TO NON-ZERO

*         SAVE FOR USE IN LLS

F0HLSRTN  RTS                           ;RETURN CODE  = 0 IF END OF SENTENCE
*                                        ;            OVFL IF OVERFLOW
*                                        ;            +IVE IF SOMETHING TO SAY

*----------------------------------------------------------------------------
*
*         CREATE ACCENT ARRAY.
*
*----------------------------------------------------------------------------

F0CRACNT  MOVE.L    F0DUR(A5),A2        ;GET ADDRESS OF DUR ARRAY
          MOVE.L    F0STRESS(A5),A1     ;GET ADDRESS OF STRESS ARRAY
          MOVE.L    F0PHON(A5),A0       ;GET ADDRESS OF PHON ARRAY
          MOVE.L    F0ACCENT(A5),A4     ;GET ADDRESS OF ACCENT ARRAY
          LEA       FEAT,A3             ;GET ADDRESS OF FEATURE MATRICES

          MOVEQ     #0,D0
          MOVEQ     #0,D1
          MOVEQ     #0,D4
          MOVEQ     #-1,D5
          CLR.W     F0NUMAS(A5)         ;CLEAR ANY PREVIOUSLY STORED VALUE


F0CRAX0   MOVE.B    (A0)+,D0            ;GET PHONEME CODE
          MOVE.B    (A1)+,D1            ;GET STRESS ELEMENT
          MOVE.B    (A2)+,D2            ;GET DUR ELEMENT
          MOVEQ     #0,D6               ;CLEAR ATTRIBUTES BITS


*-------- Check for end of input, bound, and word break

          CMP.B     #$FF,D0             ;END OF INPUT STRING?
          BEQ       F0CRAXEND           ;YES
          MOVE.W    D0,D3
          LSL.W     #2,D3               ;CONVERT TO FM INDEX
          MOVE.L    0(A3,D3),D3         ;GET FEATURES
          BTST      #WORDBRKBIT,D3      ;WORD BREAK
          BEQ.S     F0NOTWB             ;NO
          ADD.W     #1,F0NUMPHS(A5)     ;YES, INCREASE NUMBER OF WORDS
          OR.B      #F0WORDF,-1(A4,D4)  ;     SET WORD FINAL BIT IN PREV SYL
          BTST      #BOUNDBIT,D3        ;BOUND?
          BNE       F0CRAXEND           ;YES
          BRA.S     F0CRAX0             ;NO, KEEP ON GOING


*-------- Not at a word break, find start of syllable

F0NOTWB   TST.B     D1                  ;CHECK HIGH BIT OF STRESS ELEMENT
          BPL.S     F0CRAX0             ;NOT START OF SYLLABLE


*-------- Found beginning of syllable, determine accent and attributes

          BTST      #F0WORDFB,-1(A4,D4) ;IS PREV SYLLABLE WORD FINAL?
*          BEQ.S     F0NOTWF             ;NO
F0NOTWF   BTST      #F0SSBIT,D1         ;STRESSED SYLLABLE?
          BEQ.S     F0CRAX4             ;BRANCH IF NO


*         Syllable has stress number, find stress number on the next vowel

F0CRAX2A  AND.B     #F0ACNTNO,D1        ;ISOLATE ACCENT NUMBER
          BNE.S     F0CRAX2B            ;FOUND STRESSED VOWEL, OTHERWISE...
          ADDQ.L    #1,A2               ;   BUMP DUR ARRAY
          ADDQ.L    #1,A0               ;   BUMP PHON ARRAY
          MOVE.B    (A1)+,D1            ;   GET NEXT STRESS
          BRA.S     F0CRAX2A            ;   AND KEEP LOOKING


*         Rescale stress number to lie between 1 and 13.  If syllable
*         is multi-syllabic, add 2.  If new stress is less than 5, do
*         not mark syllable as accented.

F0CRAX2B  MULU      #F0STRSCL,D1        ;
          LSR.W     #7,D1               ;RESCALE STRESS
          BTST      #F0POLY,-1(A1)      ;CHECK FOR MULT-SYLLABIC
          BEQ.S     F0CRAX2C            ;IF MULT-SYLLABIC,
          ADDQ.W    #2,D1               ;    RAISE ACCENT BY TWO
F0CRAX2C  CMP.B     #4,D1
          BLE.S     F0CRAX4             ;IF NEW STRESS < 5, TREAT SYL AS UNACCENTED


*         New stress is greater than 5, mark syllable as accented

          ADDQ.W    #1,F0NUMAS(A5)      ;INCREMENT NUMBER OF STRESSED SYLLABLES
          MOVE.W    D4,F0LASTAS(A5)     ;UPDATE POSITION OF LAST 'AS' IN UTTERANCE
          OR.B      #F0STRSYL,D6        ;SET STRESSED SYL BIT IN ACCENT
F0CRAX3   TST.B     D5                  ;
          BPL.S     F0CRAX4
          MOVE.W    D4,D5               ;SAVE POSITION OF FIRST AS


*         Combine accent and attribute bits

F0CRAX4   AND.B     #F0ACNTNO,D1        ;ISOLATE ACCENT NUMBER
          OR.B      D6,D1               ;COMBINE BITS AND ACCENT
          MOVE.B    D1,0(A4,D4)         ;SAVE IN ACCENT ARRAY


*-------- Increment count of syllables and check for overflow

          ADDQ.W    #1,D4		;INCREMENT NUM OF SYLS IN CLAUSE
	  ADD.W	    #1,F0TOTSYL(A5)	;INCREMENT NUM OF SYLS IN SENTENCE
          CMP.W     #F0MAXLEN,F0TOTSYL(A5)   ;CHECK FOR OVERFLOW
          BNE       F0CRAX0             ;CONTINUE FILLING ACCENT ARRAY

F0CRAOV   MOVE.W    #$02,CCR            ;SET CC=OVERFLOW
          RTS


*-------- Fininshed, set some final bits and go away

F0CRAXEND OR.B      #F0CLAUSF,-1(A4,D4)           ;SET CLAUSE FINAL


*-------- If no accented syllables, set D5 to count of syllables.
*         This is done so rule F4B1 will correctly compute the peaks
*         for all unstressed syllables in clause initial positions.

          MOVE.W    F0NUMAS(A5),D3      ;GET NUMBER OF ACCENTED SYLS
          BNE.S     F0SOMEAS            ;AT LEAST ONE
          MOVE.W    D4,D5               ;NONE, SET D5 TO COUNT OF SYLS


*-------- Store vars for later use, and return

F0SOMEAS  MOVE.W    D5,F01STAS(A5)      ;POSITION OF FIRST AS
          MOVE.W    D4,F0NUMSYL(A5)     ;NUMBER OF SYLLABLES (>= 0)
          RTS                           ;   THIS CORRECTLY SETS CC


*----------------------------------------------------------------------------
*
*                          CREAT CR/BREAK ARRAY
*
*               DESTROYS AND RECREATES D4 (NUMBER OF SYLLABLES)
*               UPDATES POSITION OF PHON, STRESS, AND DUR ARRAYS
*
*-----------------------------------------------------------------------------

F0CRCRBR  MOVE.L    F0DUR(A5),A2        ;GET ADDRESS OF DUR ARRAY
          MOVE.L    F0STRESS(A5),A1     ;GET ADDRESS OF STRESS ARRAY
          MOVE.L    F0PHON(A5),A0       ;GET ADDRESS OF PHON ARRAY
          MOVE.L    F0CRBRK(A5),A6      ;GET ADDRESS OF CR/BRK ARRAY
          MOVE.L    F0ACCENT(A5),A4     ;GET ADDRESS OF ACCENT ARRAY
          LEA       FEAT,A3             ;GET ADDRESS OF FEATURE MATRICES

          MOVEQ     #0,D0
          MOVEQ     #0,D4

F0CRB00   MOVE.B    (A0)+,D0            ;GET PHONEME CODE
          MOVE.B    (A1)+,D1            ;GET STRESS ELEMENT
          MOVE.B    (A2)+,D2            ;GET DUR ELEMENT

          CMP.B     #$FF,D0             ;END OF INPUT STRING?
          BEQ.S     F0CRXFF             ;YES

          CMP.B     #PHCDA,D0           ;DASH?
          BNE.S     F0CRB01             ;NO, BRANCH AROUND
          OR.B      #$90,-1(A6,D4)      ;YES, CR=F+R CR#=1
          BRA.S     F0CRB02

F0CRB01   MOVE.W    D0,D3
          LSL.W     #2,D3               ;CONVERT TO FM INDEX
          MOVE.L    0(A3,D3),D3         ;GET PHONEME FEATURES
          BTST      #BOUNDBIT,D3        ;CHECK FOR BOUND
          BNE.S     F0CRBEND            ;BRANCH IF BOUND
*
*         TIME TO ACTUALLY CREATE BREAK ARRAY
*
F0CRB02   TST.B     D1
          BPL.S     F0CRB03
          ADDQ.W    #1,D4

F0CRB03   BTST      #F0PUNITI,D2        ;BEGINNING OF P-UNIT?
          BEQ.S     F0NOTPUI            ;NO
          MOVE.B    #$02,-1(A6,D4)      ;YES, SET BREAK OF 2
          BRA.S     F0CRB00

F0NOTPUI  BTST      #F0PUNITT,D2        ;END OF P-UNIT?
          BEQ.S     F0CRB00             ;NO
          MOVE.B    -1(A6,D4),D1        ;YES, GET CR/BREAK ELEMENT
          AND.B     #$0F,D1             ;  ISOLATE BREAK, ASSIGN BRK OF -2
          LSL.B     #4,D1               ;  IF NO HIGHER BREAK IS ALREADY
          ASR.B     #4,D1               ;  ASSIGNED
          BEQ.S     F0NOTPI1
          CMP.B     #-2,D1
          BGT.S     F0CRB00
F0NOTPI1  OR.B      #$0E,-1(A6,D4)      ;SET BREAK AND PRESERVE ANY CR
          BRA.S     F0CRB00


*-------- Have reached end of input string as delimited by X'FF'.
*         Want F0PHON, F0STRESS, and F0DUR to point to the X'FF', not
*         to the char after.  Necessary when a DASH terminates the clause.

F0CRXFF   SUBQ.L    #1,A0               ;BACKUP PHON
          SUBQ.L    #1,A1               ;BACKUP STRESS
          SUBQ.L    #1,A2               ;BACKUP DUR


*-------- F0PHON, F0STRESS, and F0DUR now point one past the char
*         with BOUND attribute (or DASH).  Save the updated pointers

F0CRBEND  MOVE.L    A0,F0PHON(A5)       ;SAVE UPDATED PHON POSITION
          MOVE.L    A1,F0STRESS(A5)     ;SAVE UPDATED STRESS POSITION
          MOVE.L    A2,F0DUR(A5)        ;SAVE UPDATED DUR POSITION
*
*
*         REPOSITION BREAK NUMBERS TO ACCENTED SYLLABLES WITHIN P-UNITS
*
          MOVEQ     #0,D7
          MOVE.W    D4,D0               ;GET LENGTH OF CLAUSE
          BRA.S     F0BRKDBF            ;START LOOP
F0BRKX0   OR.B      D7,0(A4,D0)         ;SET IN-PUNIT BIT IN ACCENT ARRAY
          MOVE.W    D0,D2
          CMP.B     #$02,0(A6,D0)
          BEQ.S     F0BRKX1             ;P-UNIT INITIATOR
          CMP.B     #$0E,0(A6,D0)
          BNE.S     F0BRKDBF            ;NOT P-UNIT TERMINATOR
          MOVEQ     #-1,D1              ;SET BACKWARD MOTION
          MOVE.B    #F0INPUN,D7         ;SET IN PUNIT BIT
          OR.B      D7,0(A4,D0)         ;SET IN ACCENT ARRAY
          BRA.S     F0BRKCMN            ;JUMP TO COMMON CODE
F0BRKX1   MOVEQ     #1,D1               ;SET FORWARD MOTION
          MOVEQ     #0,D7               ;TURN OFF IN-PUNIT BIT
F0BRKCMN  BTST      #F0SSBIT,0(A4,D2)   ;STRESSED?
          BNE.S     F0BRKGOT            ;YES, MOVE BREAK NUMBER
          ADD.W     D1,D2               ;NO, MOVE TO NEXT/PREV SYL
          BMI.S     F0BRKIGN            ;AT BEG OF CLAUSE, SKIP
          CMP.W     D2,D4               ;
          BGE.S     F0BRKCMN            ;NOT AT END OF CLAUSE, CONTINUE
F0BRKIGN  CLR.B     0(A6,D0)            ;CLEAR BREAK NUMBER
          BRA.S     F0BRKDBF            ;CONTINUE LOOPING
F0BRKGOT  MOVE.B    0(A6,D0),0(A6,D2)   ;MOVE BREAK NUMBER TO AS
          CMP.W     D0,D2
          BEQ.S     F0BRKDBF            ;DO NOT CLEAR IF ORIGINALLY ON AS
          CLR.B     0(A6,D0)            ;CLEAR ORIGINAL BREAK NUMBER
F0BRKDBF  DBF       D0,F0BRKX0
          RTS


*----------------------------------------------------------------------------
*
*         INITIALIZE LEVEL.  IN THIS VERSION OF THE HLS, ALL LEVELS
*         WILL BE SET TO ONE, IMPLYING NO LEVEL MODS ARE TO BE DONE
*
*----------------------------------------------------------------------------

F0LEVEL   MOVE.L    F0TUNELV(A5),A1 ;GET TUNE/LEVEL ARRAY
          MOVE.W    D4,D0           ;GET COUNT OF SYLLABLES
          BRA.S     F0LEVEL1        ;START LOOP
F0LEVEL0  OR.B      #1,0(A1,D0)     ;SET LEVEL=1 (NO LEVEL), PRESERVING ANY TUNE
F0LEVEL1  DBF       D0,F0LEVEL0     ;LOOP

          RTS

*----------------------------------------------------------------------------
*
*         MARK TUNE ON LAST WORD OF CLAUSE
*
*----------------------------------------------------------------------------

F0TUNE    MOVE.L    F0TUNELV(A5),A1   ;GET TUNE/LEVEL ARRAY POINTER
          MOVE.L    F0PHON(A5),A0     ;GET UPDATED PHON ARRAY POINTER
          MOVE.L    F0ACCENT(A5),A4   ;GET ACCENT ARRAY POINTER
          MOVEQ     #0,D1             ;DEFAULT IS NO TUNE
          MOVE.B    -1(A0),D0         ;GET LAST PHONEME CODE
          CMP.B     #PHCPE,D0         ;IS IT A "." ?
          BNE.S     F0TUNEX0          ;NO
          MOVE.B    #F0TUNEA,D1       ;YES, USE TUNE A
F0TUNEX0  CMP.B     #PHCQM,D0         ;IS IT A "?" ?
          BNE.S     F0TUNEX1          ;NO
          MOVE.B    #F0TUNEB,D1       ;YES, USE TUNE B
F0TUNEX1  MOVE.W    D4,D0             ;GET COUNT OF SYLLABLES
          SUBQ.W    #1,D0             ;ADJUST FOR DBF
*
*         MARK SYLLABLE WITH TUNE, MOVING BACKWARDS UNTIL
*         EITHER THE END OF THE PREVIOUS WORD OR THE
*         BEGINNING OF THE CLAUSE IS FOUND.
*
F0TUNEX2  OR.B      D1,0(A1,D0)        ;SET TUNE, PRESERVE LEVEL IF PRESENT
          BTST      #F0WORDFB,0(A4,D0) ;TEST FOR WORD FINAL
F0TUNEX3  DBNE      D0,F0TUNEX2        ;LOOP IF NOT WF UNITL BEGINNING OF CLAUSE

          RTS

*----------------------------------------------------------------------------
*
*         CREATE CR AND BREAKS AT CLAUSE BOUNDRIES:  CR=2, BREAK=3
*         IF TUNE A:  CR=FALL+RISE  (TUNE A OR NO TUNE)
*         IF TUNE B:  CR=MONOTONIC
*
*         FORMAT OF CR/BREAK ENTRY:  BIT 7=CR TYPE
*                                    BITS 6-4=CR NUMBER
*                                    BITS 3-0=BREAK NUMBER
*
*----------------------------------------------------------------------------

F0SETCR   MOVE.L    F0CRBRK(A5),A2      ;GET CR/BREAK ARRAY POINTER
          MOVE.L    F0TUNELV(A5),A1     ;GET TUNE/LEVEL ARRAY POINTER
          MOVE.L    F0PHON(A5),A0       ;GET UPDATED PHON ARRAY POINTER
          MOVE.L    F0ACCENT(A5),A4     ;GET ACCENT ARRAY POINTER
          CMP.B     #PHCPE,-1(A0)       ;PERIOD?
          BEQ.S     F0SETX0             ;YES, SKIP CR/BREAK
          CMP.B     #PHCQM,-1(A0)       ;NO, QUESTION?
          BEQ.S     F0SETX0             ;YES, SKIP CR/BREAK
*         MOVE.B    #$A0,D0             ;CR=F+R, CR#=2   (OLD)
          MOVE.B    #$B0,D0             ;CR=F+R, CR#=3 (CHANGED)
          CMP.B     #F0TUNEB,-1(A1,D4)  ;CHECK FOR TUNE
          BNE.S     F0SETCR1
*         MOVE.B    #$20,D0             ;CR=MONO, CR#=2   (OLD)
          MOVE.B    #$30,D0             ;CR=MONO, CR#=3 (CHANGED)
F0SETCR1  OR.B      D0,-1(A2,D4)        ;SET CR, PRESERVE ANY BREAK PRESENT
*
*         CREATE BREAK AT CLAUSE BOUNDRIES
*
F0SETBRK  TST.W     F0NUMAS(A5)         ;ANY AS'S?
          BEQ.S     F0SETX0             ;NO, SKIP THIS CODE

          MOVE.W    D4,D0
          SUBQ.W    #1,D0               ;ADJUST COUNT FOR DBF AND POSITION
F0SETBR0  BTST      #F0SSBIT,0(A4,D0)   ;AS?
          DBNE      D0,F0SETBR0         ;NO, CONTINUE LOOPING
          AND.B     #$F0,0(A2,D0)       ;  PRESERVE CR, CLEAR BREAK
*         OR.B      #$03,0(A2,D0)       ;  SET BREAK=3     (OLD)
          OR.B      #$04,0(A2,D0)       ;  SET BREAK=4   (CHANGED)

F0SETX0   RTS

          END 

	TTL	'$Header: f0lls.asm,v 32.1 86/01/22 00:23:47 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: f0lls.asm,v 32.1 86/01/22 00:23:47 sam Exp $
*
* $Locker:  $
*
* $Log:	f0lls.asm,v $
* Revision 32.1  86/01/22  00:23:47  sam
* placed under source control
* 
*
**********************************************************************
          SECTION      speech

*
*      F0 LOW LEVEL SYSTEM
*
*          ALL REGISTERS DESTROYED
*
*          GENERALLY, THROUGHOUT ALL OF F0LLS, THE FOLLOWING REGS ARE DEFINED:
*          A0 -                          A1 -
*          A2 -                          A3 -
*          A4 - ACCENT ARRAY             A5 - GLOBALS AREA
*          A6 - PEAK
*
*          D0 THRU D2 - SCRATCH
*          D3 - NUMBER OF AS             D4 - NUMBER OF SYLLABLES
*          D5 - POSITION OF FIRST AS     D6/D7 - SCRATCH
*

*          .NOMACROLIST

          INCLUDE     'gloequs.i'
          INCLUDE     'featequ.i'
          INCLUDE     'pcequs.i'
          INCLUDE     'f0equs.i'

           XREF       FEAT
           XDEF       F0LLS

*
*         MACRO DEFINITIONS
*
ADDPCT   MACRO    ADDPCT                ;ADD N% OF 0(Ax,Dx)-CONST TO 0(Ay,Dy)
*                                        ;    %1     %2  %3   %4       %5  %6
          MOVEQ     #0,\7               ;  USING D REG SPECIFIED AS %7 AS SCRATCH
          MOVE.B    \2,\3,\7            ;GET 0(Ax,Dx)
*          IFNC       '\2','0(A6'        ;IF NOT USING PEAK ARRAY (ALWAYS A6)
	  IFEQ	    \4
          EXT.W     \7                  ;    SIGN EXTEND TO WORD
          ENDC
          IFNE      \4
          SUB.W     #\4,\7              ;IF NON-ZERO CONST, SUB FROM 0(Ax,Dx)
          ENDC
          MULS      \1,\7               ;MULTIPLY IN 128THS
          IFNE      MAC
          BPL.S     *+8
	  ENDC
	  IFNE      AMIGA
          BPL.S	    *+8
	  ENDC
          SUB.W     #64,\7              ;ROUND IF NEGATIVE
	  IFNE	    MAC
          BRA.S     *+6
	  ENDC
	  IFNE	    AMIGA
	  BRA.S     *+6
	  ENDC
          ADD.W     #64,\7              ;ROUND IF POSITIVE
          ASR.W     #7,\7               ;CONVERT TO PERCENTAGES
          ADD.B     \7,\5,\6            ;ADD TO 0(Ay,Dy)

          ENDM


F0LLS     MOVEQ     #0,D0               ;CLEAR ALL D REGS.  THIS IS NECESSARY
          MOVEQ     #0,D1               ;     BECAUSE THE MOVE.W'S BELOW WILL
          MOVEQ     #0,D2               ;     NOT CLEAR THE UPPER HALF OF REG
          MOVEQ     #0,D3
          MOVEQ     #0,D4
          MOVEQ     #0,D5
          MOVEQ     #0,D6
          MOVEQ     #0,D7

          MOVE.W    F0NUMAS(A5),D3      ;RESTORE SOME USEFUL COUNTS
          MOVE.W    F0NUMSYL(A5),D4     ;  D3 THROUGH D5 ARE GENERALLY
          MOVE.W    F01STAS(A5),D5      ;  PRESERVED THROUGH ALL SUBROUTINES
          MOVE.W    F0NUMCLS(A5),D6
          MOVE.W    F0NUMPHS(A5),D7
          TST.W     F0MODE(A5)
          BNE.S     ROBOTF0
          TST.W     D3
          BEQ.S     F0DOF0E             ;IF NO AS'S, SKIP B, C, AND D RULES
          BSR       F0HDPEAK
          BSR       F0B
          BSR       F0C
          BSR       F0D
F0DOF0E   BSR       F0E
          BSR       F0F
          BSR       F0G
*          BRA.S     F0ADJ

ROBOTF0:
*          MOVE.W    D4,D0
*          MOVE.L    F0START(A5),A0
*          MOVE.L    F0PEAK(A5),A1
*          MOVE.L    F0END(A5),A2
*          MOVE.W    FREQ(A5),D1
*          BRA.S     ROBOTDBF
*
*ROBOTLOOP MOVE.B    D1,(A0)+
*          MOVE.B    D1,(A1)+
*          MOVE.B    D1,(A2)+
*ROBOTDBF  DBF       D0,ROBOTLOOP
*
*
*      ADJUST SYLLABLE ARRAY POINTERS FOR NEXT CLAUSE
*      (IF ANY).
*
F0ADJ     LEA      F0START(A5),A0
          MOVEQ    #7,D0
F0SYLADJ  ADD.L    D4,(A0)+
          DBF      D0,F0SYLADJ
*
*        RETURN TO MAIN TO DEAL WITH NEXT CLAUSE (IF ANY)
*
          RTS

*-----------------------------------------------------------------------------
*
*         ASSIGN HEAD PEAK
*
*         On entry, D7 contains the number of words in the clause
*                   D6 contains the clause number
*
*-----------------------------------------------------------------------------

F0HDPEAK: 
	  MOVE.L   F0PEAK(A5),A6
*	  BRA.S	   F0HDNEW
          ADDQ.W   #4,D7                ;FAKING NUMBER OF PHRASES AS
          DIVU     #3,D7                ; # OF (WORDS+4)/3
          MOVEQ    #6,D0
          SUB.W    D6,D0                ;6 - #CLAUSES
          LSL.W    #1,D0                ;12 - 2*#CLAUSES
          BPL.S    F0HDPK2              ;CLAMP AT 0
          MOVEQ    #0,D0
F0HDPK2   MULU     D7,D0                ;#PHR*(12-2*#CLAUSES)
          ADD.W    #F0HDBASE,D0         ;BASELINE + #PHR*(12-2*#CLAUSES)
          MOVE.W   D6,D1                ;
          LSL.W    #3,D1                ;8*#CLAUSES
          SUB.W    D1,D0                ;BASELINE - 8*#CLS + #PHR*(12-2*#CLS)
	  BRA.S	   F0HDNEWE

F0HDNEW	  MOVE.W   D6,D0
	  MULU	   D7,D0
	  ASR.W	   #1,D0
	  MULU	   #3,D7
	  MULU     #10,D6
	  NEG.W	   D0
	  ADD.W	   #F0HDBASE+12,D0
	  SUB.W	   D6,D0
	  ADD.W	   D7,D0

F0HDNEWE:
          CMP.W    #F0MINHPK,D0         ;CHECK AGAINST MIN HEAD PEAK
          BGT.S    F0HDPK0              ;
          MOVE.W   #F0MINHPK,D0         ;CLAMP AT MINIMUM
F0HDPK0   CMP.W    #F0MAXHPK,D0         ;CHECK AGAINST MAX HEAD PEAK
          BLT.S    F0HDPK1
          MOVE.W   #F0MAXHPK,D0         ;CLAMP AT MAX
F0HDPK1   MOVE.B   D0,0(A6,D5)          ;STORE HEAD PEAK

          RTS


*----------------------------------------------------------------------------
*
*         COMPUTE PEAKS FOR ACCENTED SYLLABLES
*
*         On entry, D0 contains HEAD PEAK calculated in F0HDPEAK
*
*----------------------------------------------------------------------------

F0B       MOVE.L    F0TUNELV(A5),A1
          MOVE.L    F0ACCENT(A5),A4
          MOVE.B    #F0110HZ,D1         ;SET TUNE A
          MOVE.B    -1(A1,D4),D2        ;GET TUNE/LEVEL OF LAST SYL
          AND.B     #F0TUNEMK,D2        ;ISOLATE TUNE
          CMP.B     #F0TUNEB,D2         ;CHECK TUNE
          BNE.S     F0B2AX0             ;TUNE A OR NO TUNE
          MOVE.B    #F0125HZ,D1         ;TUNE B
*
F0B2AX0   SUB.B     D1,D0               ;COMPUTE F0 ROOM FOR HEAD PEAK
*
F0B2B     DIVU      D3,D0               ;D0 = DROP (ALL THESE ARE BYTE QUANTITIES,
          MOVE.W    D0,D1               ;D1 = DROP   BUT DOING WORD MOVES TO CLEAR
          MOVE.W    D0,D2               ;D2 = DROP   UPPER BYTE IN WORD)
          CMP.W     #4,D3
          BLT.S     F0B2BX1             ;BRANCH IF LESS THAN 4 AS'S
          MULU      #F0PCT15,D1         ;
          LSR.W     #7,D1               ;D1 = 15% OF DROP
          MOVE.W    D1,D2               ;
          LSL.W     #1,D2               ;D2 = 30% OF DROP
          SUBQ.W    #3,D3               ;MODIFY # OF AS'S
          DIVU      D3,D2               ;D2=DROP/(#AS-3)
          NEG.W     D2
          ADD.W     D0,D2               ;D2=DROP-(30%/(#AS-3))
          ADD.W     D0,D1               ;D1=DROP+15%
*
F0B2BX1
          MOVE.B    D1,D7               ;INITIALIZE D7 TO LARGER DROP
          MOVE.B    0(A6,D5),D6         ;GET HEAD PEAK
          MOVE.W    D5,D0
          ADDQ.W    #1,D0               ;BEGIN AFTER 1ST AS
F0B2BX2   BTST      #F0SSBIT,0(A4,D0)   ;STRESSED?
          BEQ.S     F0B2BX3             ;NO, BRANCH
          CMP.W     F0LASTAS(A5),D0     ;LAST AS?
          BNE.S     F0B2BX4             ;    NO, USE SMALLER DROP
          MOVE.B    D1,D7               ;   YES, USE LARGER DROP
F0B2BX4   SUB.B     D7,D6               ;COMPUTE NEXT AS PEAK
          MOVE.B    D6,0(A6,D0)         ;STORE
          MOVE.B    D2,D7               ;DEFAULT TO SMALLER DROP
F0B2BX3   ADDQ.W    #1,D0
          CMP.W     D0,D4               ;LAST SYLLABLE?
          BGT.S     F0B2BX2             ;NO, CONTINUE
*
*         LEVEL MODIICATIONS
*
F0B3A     MOVE.W    F0LASTAS(A5),D1     ;GET LAST AS
          MOVE.W    D1,D2               ;SETUP D2 AND D1 TO POINT TO LAST AS

F0B3AX0   BTST      #F0SSBIT,0(A4,D1)   ;STRESSED SYLLABLE?
          BEQ.S     F0B3AXEND           ;
          MOVE.B    0(A1,D1),D7         ;GET TUNE/LEVEL ELEMENT
          AND.B     #F0LEVMK,D7         ;ISOLATE LEVEL ELEMENT
          SUBQ.B    #1,D7               ;ADJUST TO -1, 0, +1
          BEQ.S     F0B3AX2             ;IF ZERO, NO MODS
          BLT.S     F0B3A2              ;

*         POSITIVE LEVEL

F0B3A1    CMP.W     F01STAS(A5),D1      ;ANY MORE AS'S?
          BLE.S     F0B3B               ;NO, GO DO ACCENT MODS
          MOVE.W    D1,D0               ;FIND AS ON LEFT (IF ANY)
          SUBQ.W    #1,D0               ;START TO LEFT OF D1
F0B3A1X1  BTST      #F0SSBIT,0(A4,D0)
          DBNE      D0,F0B3A1X1
          MOVE.B    0(A6,D1),D7         ;GET PEAK(I)
          SUB.B     0(A6,D0),D7         ;PEAK(I) - PEAK(I-1)
          EXT.W     D7
          TST.W     D7
          BPL.S     F0B3AX1
          NEG.W     D7                  ;INSURE POSITIVE DIFFERENCE
          BRA.S     F0B3AX1

*         NEGATIVE LEVEL

F0B3A2    MOVE.B    0(A6,D1),D7         ;GET PEAK(I)
          SUB.B     0(A6,D2),D7         ;PEAK(I) - PEAK(I+1)
          EXT.W     D7                  ;EXTEND TO WORD
          TST.W     D7                  ;
          BMI.S     F0B3AX1             ;
          NEG.W     D7                  ;INSURE NEGATIVE DIFFERENCE

F0B3AX1   MULS      #F0PCT40,D7         ;
          LSR.L     #7,D7               ;COMPUTE 40% OF DIFFERENCE
          ADD.B     D7,0(A6,D1)         ;MODIFY PEAK(I)

F0B3AX2   MOVE.W    D1,D2               ;MOVE D2 ONE AS TO LEFT
F0B3AXEND DBF       D1,F0B3AX0          ;LOOP

*         ACCENT MODIFICATION TO AS PEAKS

F0B3B     MOVE.W    F0NUMAS(A5),D3      ;GET NUMBER OF AS'S
          MOVE.W    F0LASTAS(A5),D0     ;GET NUMBER OF SYLLABLES
F0B3BX1   MOVEQ     #0,D1
          MOVEQ     #0,D2
          MOVE.B    0(A4,D0),D1         ;GET ACCENT BYTE
          BTST      #F0SSBIT,D1         ;STRESSED SYLLABLE?
          BEQ.S     F0B3BX2
          AND.B     #F0ACNTNO,D1        ;YES, ISOLATE ACCENT NUMBER
          SUBQ.W    #8,D1               ;SUBTRACT 8
          MOVE.B    0(A6,D0),D2         ;GET PEAK
          SUB.W     #F0BOR,D2           ;D2 = LOCAL ROOM
          MULU      #F0PCT10,D2         ;
          LSR.W     #7,D2               ;D2 = 10% OF LOCAL ROOM
          MULS      D2,D1               ;D1 = (ACCT-8)*10% OF LOCAL ROOM
          ADD.B     D1,0(A6,D0)         ;ADD TO PEAK
F0B3BX2   DBF       D0,F0B3BX1

          RTS


*-----------------------------------------------------------------------------
*
*         ASSIGN RISES AND FALLS FOR ACCENTED SYLLABLES
*
*-----------------------------------------------------------------------------

F0C       MOVE.L    F0CRBRK(A5),A1      ;BREAK ARRAY
          MOVE.L    F0FALL(A5),A2       ;FALL ARRAY
          MOVE.L    F0RISE(A5),A3       ;RISE ARRAY
          MOVE.W    F0LASTAS(A5),D0
F0CX1     BTST      #F0SSBIT,0(A4,D0)   ;STRESSED SYLLABLE?
          BEQ       F0CXEND


*-------- COMPUTE RISE ACCENTS ------------------------------------------------

F0C1A     MOVEQ     #0,D1
          MOVEQ     #0,D2
          MOVE.B    0(A6,D0),D1         ;GET PEAK
          SUB.W     #F0BOR,D1           ;D1 = LOCAL ROOM
          MOVE.B    0(A1,D0),D2         ;D2 = BREAK/CR ELEMENT
          AND.B     #F0BRMASK,D2        ;ISOLATE BREAK NUMBER
          BTST      #3,D2               ;TEST FOR NEGATIVE BREAK
          BEQ.S     F0C1AX0             ;
          OR.W      #$FFF0,D2           ;IF NEGATIVE NYBLE, SIGN EXTEND TO WORD
F0C1AX0
          MOVE.W    D2,D7               ;BREAK NUMBER
          MULS      #F0PCT20,D7         ;20% OF BREAK NUMBER (DONT SHIFT YET)
          ADD.L     #128,D7             ;1 + 20% OF BREAK NUMBER (IN 128THS)
          MULS      D1,D7               ;ROOM*(1 + 20% OF BREAK)
          LSR.L     #7,D7               ;ADJUST FOR PERCENTAGE
          MULS      #F0PCT40,D7         ;
          LSR.L     #7,D7               ;40% OF 120%*ROOM*BREAK NUMBER
          MOVE.B    D7,0(A3,D0)         ;NEW RISE


*-------- COMPUTE FALL ACCENTS ---------------------------------------------

F0C2A     MOVE.W    D2,D7               ;BREAK NUMBER
          SUBQ.W    #1,D7               ;
          MULS      D1,D7               ;ROOM*(BREAK-1)
          MULS      #F0PCT20,D7         ;
          LSR.L     #7,D7               ;20% OF ROOM*(BREAK-1)
          NEG.B     D7                  ;INVERT SIGN
          BPL.S     F0C2AX0             ;CLAMP D7 TO INSURE POSITIVE VALUE
          MOVEQ     #0,D7
F0C2AX0   MOVE.B    D7,0(A2,D0)         ;NEW FALL


*-------- MODIFY ACCENTS WITHIN P-UNITS -------------------------------------

F0C3      BTST      #F0INPUNB,0(A4,D0)  ;IN P-UNIT?
          BEQ.S     F0CXEND             ;NO, SKIP SECTION C3 MODS
          TST.B     D2                  ;CHECK FOR ZERO BREAK
          BNE.S     F0CXEND             ;NON-ZERO BREAK, SKIP C3 MODS

          ADDPCT    #-F0PCT30,0(A3,D0),0,0(A3,D0),D2        ;REDUCE RISE BY 30%
          ADDPCT    #-F0PCT30,0(A2,D0),0,0(A2,D0),D2        ;REDUCE FALL BY 30%


F0CXEND   DBF       D0,F0CX1


*-------- ASSIGN RISE FOR HEAD SYLLABLE -------------------------------------

F0C1C     MOVE.B    0(A6,D5),0(A3,D5)   ;MOVE PEAK OF 1ST AS TO RISE
          SUB.B     #F0BOR,0(A3,D5)     ;RISE = PEAK - BOR

          RTS


*-----------------------------------------------------------------------------
*
*         PHONETIC MODIFICATIONS
*
*-----------------------------------------------------------------------------

F0D       MOVE.L    F0CRBRK(A5),A0      ;CR ARRAY
          MOVE.L    F0TUNELV(A5),A1     ;TUNE/LEVEL ARRAY
          MOVE.W    F0LASTAS(A5),D1     ;POSTION OF LAST AS
          MOVE.W    D1,D0               ;COPY TO "PREVIOUS AS POINTER"
          BRA       F0DXEND             ;START LOOP

F0DX0     BTST      #F0SSBIT,0(A4,D0)   ;STRESSED SYLLABLE?
          BEQ       F0DXEND             ;NO, CONTINUE LOOKING

          MOVE.W    D1,D2               ;COMPUTE NUMBER OF US'S BETWEEN AS'S
          SUB.W     D0,D2
          SUBQ.W    #2,D2
          BEQ       F0D1X0              ;1 US BETWEEN AS'S, NO MODS
          BPL       F0D1B               ;MORE THAN 1 US BETWEEN AS'S


*-------- IF 2 AS'S ARE ADJACENT -----------------------------------------------

F0D1A     ADDPCT    #-F0PCT40,0(A3,D0),0,0(A3,D0),D2        ;REDUCE 1ST RISE 40%

          ADDPCT    #-F0PCT40,0(A3,D1),0,0(A3,D1),D2        ;REDUCE 2ND RISE 40%

          ADDPCT    #-F0PCT20,0(A6,D0),F0BOR,0(A6,D0),D2    ;REDUCE 1ST PEAK 20%LR

          ADDPCT    #F0PCT20,0(A6,D1),F0BOR,0(A6,D1),D2     ;RAISE 2ND PEAK 20%LR


*         INCREASE FALL ACCENT OF FIRST OR RISE ACCENT
*                 OF SECOND SO THAT END POINTS MEET

          MOVE.B    0(A6,D0),D2   ;GET PEAK OF 1ST AS
          SUB.B     0(A2,D0),D2   ;PEAK(1ST) - FALL(1ST)
          SUB.B     0(A6,D1),D2   ;PEAK(1ST) - FALL(1ST) - PEAK(2ND)
          ADD.B     0(A3,D1),D2   ;PEAK(1ST) - FALL(1ST) - (PEAK(2ND) - RISE(2ND))
          BPL.S     F0D1AX1       ;
          SUB.B     D2,0(A3,D1)   ;PEAK-RISE > PEAK-FALL, INCREASE RISE OF 2ND AS
          BRA       F0D1X0

F0D1AX1   ADD.B     D2,0(A2,D0)   ;PEAK-RISE < PEAK-FALL, INCREASE FALL OF 1ST AS
          BRA       F0D1X0


*-------- ADJUST RISE ACCENTS IF AS'S ARE NOT ADJACENT -------------------------

F0D1B     MOVE.W    D2,-(SP)            ;SAVE COUNT OF INTERVENING US'S
          MOVE.W    #F0PCT15,D7         ;1 EXTRA US (TWO INTERVENING US'S)
          SUBQ.W    #1,D2
          BEQ.S     F0D1BX1
          ADD.W     #F0PCT10,D7         ;2 EXTRA US'S
          SUBQ.W    #1,D2
          BEQ.S     F0D1BX1
          ADD.W     #F0PCT5,D7          ;3 OR MORE EXTRA US'S

F0D1BX1   ADDPCT    D7,0(A3,D0),0,0(A3,D0),D2     ;INCREASE RISE OF 1ST AS

          ADDPCT    D7,0(A3,D1),0,0(A3,D1),D2     ;INCREASE RISE OF 2ND AS



*-------- ADJUST PEAKS IF AS'S ARE NOT ADJACENT -------------------------------

F0D1C     MOVE.W    (SP),D2             ;RESTORE COUNT OF INTERVENING US'S
*                                        ;NOTE THAT WE LEAVE D2 ON STACK FOR
*                                        ;LATER USE
          MOVE.W    #-F0PCT15,D7        ;2 US'S
          SUBQ.W    #1,D2
          BEQ.S     F0D1CX1
          SUB.W     #F0PCT10,D7         ;3 OR MORE US'S

F0D1CX1   ADDPCT    D7,0(A6,D1),F0BOR,0(A6,D1),D2           ;DECREASE 2ND PEAK


F0D1D     MOVE.W    (SP),D2             ;RESTORE COUNT, KEEP ON STACK
          MOVE.W    #F0PCT10,D7         ;2 US'S
          SUBQ.W    #1,D2
          BEQ.S     F0D1DX1
          ADD.W     #F0PCT5,D7          ;3 OR MORE US'S

F0D1DX1   ADDPCT    D7,0(A6,D0),F0BOR,0(A6,D0),D2           ;INCREASE 1ST PEAK


*-------- 3 AS'S IN SUCCESSION ------------------------------------------------

F0D1E     NOP                           ;THIS MOD NOT IMPLEMENTED


*-------- MOD TO RISE OF AS NOT IN NOR AT END OF P-UNIT -----------------------

F0D1F     MOVE.W    (SP)+,D2            ;GET # OF US'S AND FIX STACK
          SWAP      D2                  ;SAVE IN UPPER HALF
          BTST      #F0INPUNB,0(A4,D1)  ;OUTSIDE P-UNIT?
          BEQ.S     F0D1FX0             ;YES, CHECK IF 3+ US'S
          MOVE.B    0(A0,D1),D2         ;GET CR/BREAK ELEMENT
          AND.B     #F0BRMASK,D2        ;ISOLATE BREAK ELEMENT
          BEQ.S     F0D1X0              ;NO BREAK, SKIP D1F MOD
          BTST      #3,D2               ;
          BNE.S     F0D1X0              ;-IVE BREAK, SKIP D1F MOD

*         2ND AS OUTSIDE OR AT BEGINNING OF P-UNIT

F0D1FX0   SWAP      D2                  ;RESTORE # OF INTERVENING US'S
          CMP.W     #2,D2
          BLT.S     F0D1X0              ;LESS THAN 3 INTERVENING US'S
          MOVE.B    0(A6,D1),D2         ;GET PEAK
          SUB.B     #F0BOR-5,D2         ;PEAK-(BOR-5)
          MOVE.B    D2,0(A3,D1)         ;STORE AS RISE

F0D1X0    MOVE.W    D0,D1               ;UPDATE CURRENT AS POSITION
F0DXEND   DBF       D0,F0DX0


*-------- COMPUTE ACCENTS OF TERMINALS ---------------------------------------

F0D2      MOVE.W    F0LASTAS(A5),D0               ;COUNT OF SYLLABLES
F0D2X0    BTST      #F0SSBIT,0(A4,D0)             ;STRESSED?
          BEQ.S     F0D2XEND                      ;NO
*
F0D2A     BTST      #F0WORDFB,0(A4,D0)            ;WORD FINAL
          BEQ.S     F0D2XEND                      ;NO, NEXT SYLLABLE
          MOVE.B    0(A1,D0),D1                   ;GET TUNE ARRAY
          AND.B     #F0TUNEMK,D1                  ;ISOLATE TUNE
          CMP.B     #F0TUNEB,D1                   ;TUNE B?
          BEQ.S     F0D2B                         ;YES
          CMP.B     #F0TUNEA,D1                   ;TUNE A?
          BNE.S     F0D2XEND                      ;NO TUNE

*-------- TUNE A, USE F0TERM AS ENDING POINT --------------------------------

F0D2A1    MOVEQ     #0,D7

          IFNE      MAC
          MOVE.B    Ticks+3,D7                    ;GET LOW BYTE OF CLOCK
          AND.B     #$0F,D7                       ;USE LOW NYBBLE
          ENDC

          ADD.B    0(A6,D0),D7                    ;GET PEAK
          SUB.B     #F0TERM,D7                    ;PEAK-F0 TERM
          MOVE.B    D7,0(A2,D0)                   ;SET FALL
          BRA.S     F0D2XEND                      ;CONTINUE

*-------- TUNE B, USE 120% OF PREVIOUS PEAK AS ENDING POINT ------------------
*                 AND TRANSFER 80% OF FALL TO BE ADDITIONAL RISE

F0D2B     ADDPCT    #F0PCT80,0(A2,D0),0,0(A3,D0),D1         ;80% FALL TO RISE
*
F0D2A2    MOVEQ     #0,D7                         ;CLEAR FOR COMPARE
          MOVE.W    D0,D2
          MOVE.B    0(A6,D2),D7                   ;GET PEAK
          BRA.S     F0D2A2X1
F0D2A2X0  MOVE.B    0(A6,D2),D1                   ;GET PEAK
          CMP.W     D1,D7                         ;COMPARE PEAKS (UNSIGNED VALUES)
          BGT.S     F0D2A2X1                      ;NOT BIGGER
          MOVE.B    D1,D7                         ;NEW MAX
F0D2A2X1  DBF       D2,F0D2A2X0                   ;LOOP

          MULU      #F0PCT20+F0PCT100,D7          ;GET 120%
          LSR.W     #7,D7                         ;COMPUTE PERCENTAGE
          MOVE.B    0(A6,D0),D1                   ;GET PEAK WITH TUNE
          SUB.B     D7,D1                         ;CURRENT PEAK - 120% OF PREV HI PEAK
          MOVE.B    D1,0(A2,D0)                   ;SET FALL
*
F0D2XEND  DBF       D0,F0D2X0

          RTS

*-----------------------------------------------------------------------------
*
*         ASSIGN CONTINUATION RISES
*
*-----------------------------------------------------------------------------
F0E       MOVE.L    F0FALL(A5),A2       ;
          MOVE.L    F0CRBRK(A5),A0      ;

F0E1      NOP                           ;THIS RULE IS DONE IN "F0FILL"


F0E2      MOVEQ     #0,D1
          MOVE.W    D4,D0               ;COUNT OF SYLLABLES
          BRA.S     F0E2X2              ;START LOOP
*
F0E2X0    MOVE.B    0(A0,D0),D1         ;GET CR/BREAK BYTE
          AND.B     #F0CRMASK,D1        ;ISOLATE CR TYPE AND NUMBER
          BEQ.S     F0E2X2              ;NO CR
          MOVE.W    #-F0PCT80,D2        ;ASSUME MONOTONIC, DECREASE FALL BY 80%
          BTST      #F0CRTYPE,D1        ;FALL+RISE OR MONOTONIC
          BEQ.S     F0E2X1              ;BIT OFF ==> MONOTONIC
          MOVE.W    #F0PCT30,D2         ;FALL+RISE CR, INCREASE FALL BY 30%
F0E2X1    ADDPCT    D2,0(A2,D0),0,0(A2,D0),D1

F0E2X2    DBF       D0,F0E2X0

          RTS


*-----------------------------------------------------------------------------
*
*         F0 PATTERNS ON THE UNSTRESSED SYLLABLES
*
*-----------------------------------------------------------------------------
F0F       MOVE.L    F0END(A5),A0        ;DEFINE A REGS
          MOVE.L    F0START(A5),A1
          MOVE.L    F0FALL(A5),A2
          MOVE.L    F0RISE(A5),A3
          MOVE.L    F0ACCENT(A5),A4
          MOVE.L    F0PEAK(A5),A6       ;

          MOVE.W    F0LASTAS(A5),D0     ;
F0F2      BTST      #F0SSBIT,0(A4,D0)   ;STRESSED?
          BEQ.S     F0F2X1              ;NO
          MOVE.B    0(A6,D0),D1         ;GET PEAK
          MOVE.B    D1,D2               ;COPY
          SUB.B     0(A3,D0),D1         ;PEAK-RISE
          MOVE.B    D1,0(A1,D0)         ;MOVE TO START
          SUB.B     0(A2,D0),D2         ;PEAK-FALL
          MOVE.B    D2,0(A0,D0)         ;MOVE PEAK TO END
F0F2X1    DBF       D0,F0F2
*
*
*
F0F3
          MOVE.W    D5,D1               ;POSITION OF 1ST AS
          MOVE.W    F0NUMAS(A5),D3      ;GET NUMBER OF AS'S
F0F3X1    MOVE.W    D1,D0               ;UPDATE POSITION OF "PREVIOUS" AS
          MOVEQ     #0,D6               ;CLEAR FOR USE IN MULTIPLIES
          SUBQ.W    #1,D3               ;DECREMENT COUNT OF AS'S
          BLE       F0F4B1              ;ONLY 1 AS (OR NO MORE AS'S)


*         COMPUTE STARTS, PEAKS, AND ENDS OF US'S

          MOVE.L    F0ACCENT(A5),A4
F0F3X2    ADDQ.W    #1,D1
          BTST      #F0SSBIT,0(A4,D1)   ;STRESSED SYLLABLE?
          BEQ.S     F0F3X2              ;NO, KEEP LOOKING
          MOVE.W    D1,D2
          SUB.W     D0,D2
          SUBQ.W    #1,D2               ;COMPUTE NUMBER OF INTERVENING US'S
          BEQ.S     F0F3X1              ;ADJACENT AS'S, SKIP
          MOVE.B    0(A0,D0),D6         ;END OF 1ST AS
          SUB.B     0(A1,D1),D6         ;END OF 1ST AS - START OF 2ND AS
          BPL.S     F0F4                ;+IVE DIFFERENCE IS OK

*         ADJUST ENDPOINTS OF AS'S TO PREVENT RISING F0 IN US'S

          NEG.B     D6                  ;ABS(DIFFERENCE)
          LSR.B     #1,D6               ;ABS(DIFFERNECE)/2
          SUB.B     D6,0(A1,D1)         ;SUBTRACT FROM START
          ADD.B     D6,0(A3,D1)         ;  AND ADD TO RISE
          ADD.B     D6,0(A0,D0)         ;ADD TO END
          SUB.B     D6,0(A2,D0)         ;  AND SUB FROM FALL
          MOVEQ     #0,D6               ;SET DELTA TO ZERO
*
F0F4      MOVE.L    F0CRBRK(A5),A0      ;GET CR/BREAK ARRAY (TEMPORARILY)
          MOVE.B    0(A0,D0),D7         ;GET CR/BREAK ELEMENT
          MOVE.L    F0END(A5),A0        ;RESTORE END ARRAY POINTER
          AND.B     #F0BRMASK,D7        ;ISOLATE BR NUMBER
          CMP.B     #8,D7               ;NEGATIVE BREAK?
          BGE.S     F0F4OPNT            ;YES, AT END OF P-UNIT
          BTST      #F0INPUNB,0(A4,D0)  ;INSIDE P-UNIT, BUT NOT AT END?
          BEQ.S     F0F4OPNT            ;NO, JUMP TO OUTSIDE P-UNIT CODE

*         US'S INSIDE P-UNIT EXHIBIT A LINEAR DROP

F0F4IPNT  DIVU      D2,D6               ;COMPUTE DELTA
          BRA.S     F0F4X2              ;START LOOP
F0F4X1    ADDQ.W    #1,D0
          MOVE.B    -1(A0,D0),0(A1,D0)  ;END(I) -> ST(I+1)
          MOVE.B    0(A1,D0),0(A0,D0)   ;ST(I+1) - DELTA ->
          SUB.B     D6,0(A0,D0)         ;  END(I+1)
          MOVE.B    0(A0,D0),0(A6,D0)   ;END(I+1) + 5 ->
          ADDQ.B    #5,0(A6,D0)         ;  PEAK(I+1)
F0F4X2    DBF       D2,F0F4X1
          BRA       F0F3X1

*         US'S OUTSIDE P-UNIT EXHIBIT AN EXPONENTIAL DROP TO TOP OF BOR

F0F4OPNT
          CMP.W     #1,D2
          BEQ.S     F0F4I1              ;ONE INTERVENING US, USE PREV CALCD DROP
          CMP.W     #2,D2
          BEQ.S     F0F4I2              ;TWO INTERVENING US'S, USE PREV CALCD DROP

*         THREE OR MORE INTERVENING US'S.  SET DROP TO END-(BOR-5)

F0F4I3    MOVE.B    0(A0,D0),D6         ;END OF FIRST AS
          SUB.B     #F0BOR-5,D6         ;END - (BOR - 5)
          SWAP      D2                  ;SAVE COUNT OF INTERVENING US'S IN UPPER D2
          MOVE.W    #3,D2               ;SET NUMBER OF US'S TO 3
          LEA       F0PNPCT3,A4         ;GET ADDR OF PERCENTAGES SEQUENCE
          BSR       F0INTERP            ;INTERPOLATE FIRST 3 INTERMEDIATE US VALUES
          MOVE.L    F0ACCENT(A5),A4     ;RESTORE ACCENT ARRAY
          SWAP      D2                  ;RESTORE COUNT OF INTERVENING US'S
          SUBQ.W    #3,D2               ;# US'S - 3
          BRA.S     F0F4I3X3            ;START LOOP
F0F4I3X2  MOVE.B    0(A0,D0),D6         ;GET END OF PREVIOUS US
          ADDQ.W    #1,D0               ;BUMP INDEX COUNTER
          MOVE.B    D6,0(A1,D0)         ;END -> START
          MOVE.B    D6,0(A0,D0)         ;START -> END
          MOVE.B    D6,0(A6,D0)         ;END -> PEAK
          MOVE.B    0(A4,D0),D6         ;GET ACCENT BYTE
          AND.B     #F0ACNTNO,D6        ;ISOLATE ACCENT NUMBER
          LSL.B     #1,D6               ;MULTIPLY BY 2
          ADD.B     D6,0(A6,D0)         ;ADD TO PEAK
F0F4I3X3  DBF       D2,F0F4I3X2
          BRA       F0F3X1


*         ONE INTERVENING US

F0F4I1
          LEA       F0PNPCT1,A4         ;GET ADDRESS OF PERCENTAGES SEQUENCE
          BSR       F0INTERP            ;COMPUTE INTERMEDIATE US VALUES
          BRA       F0F3X1              ;CONTINUE


*         TWO INTERVENING US'S

F0F4I2
          LEA       F0PNPCT2,A4         ;GET ADDRESS OF PERCENTAGES SEQUENCE
          BSR       F0INTERP            ;COMPUTE INTERMEDIATE US VALUES
          BRA       F0F3X1
*
*
*
F0F4B1    MOVE.L    F0ACCENT(A5),A4
          MOVE.B    #F0BOR,D6           ;SET D6 TO BOR
          MOVE.W    D5,D0               ;GET POS OF 1ST AS
          BRA.S     F0F4B1X1
F0F4B1X0  MOVE.B    0(A4,D0),D1         ;GET ACCENT
          AND.B     #F0ACNTNO,D1        ;ISOLATE ACCENT
          LSL.B     #1,D1               ;ACCENT*2
          MOVE.B    D6,0(A6,D0)         ;PEAK=BOR
          ADD.B     D1,0(A6,D0)         ;       + 2*ACCENT
          MOVE.B    D6,0(A1,D0)         ;START = BOR
          MOVE.B    D6,0(A0,D0)         ;END   = BOR
F0F4B1X1  DBF       D0,F0F4B1X0


F0F5      MOVEQ     #0,D7
          MOVE.L    F0TUNELV(A5),A3     ;ADDR OF TUNE ARRAY
          MOVE.W    D4,D0
          SUBQ.W    #1,D0               ;POS OF LAST SYL
          BTST      #F0SSBIT,0(A4,D0)   ;UNSTRESSED?
          BNE       F0F5XEND            ;NO, SKIP F0F5 RULES
          MOVE.B    0(A3,D0),D2         ;GET TUNE/LEVEL
          AND.B     #F0TUNEMK,D2        ;ISOLATE TUNE FOR LATER
*
F0F5A     MOVE.W    D0,D1
          BRA.S     F0F5AX1
F0F5AX0   BTST      #F0SSBIT,0(A4,D0)   ;STRESSED SYL?
          BNE.S     F0F5AX2             ;FOUND
F0F5AX1   DBF       D0,F0F5AX0          ;CONTINUE UNTIL STR SYL
          MOVEQ     #0,D0               ;NO PREVIOUS AS, USE 0
*
F0F5AX2   SUB.W     D0,D1               ;NUMBER OF UNSTR SYL
          BEQ.S     F0F5AX5             ;ONLY 1 SYL, JUST SET ENDPT
          MOVEQ     #0,D7

          IFNE       MAC
          MOVE.B    Ticks+3,D7          ;GET CLOCK COUNT
          AND.B     #$0F,D7             ;LOW NYBBLE
          ENDC

          ADD.B     0(A0,D0),D7         ;GET END OF STR SYL
          SUB.W     #F0BOR,D7           ;TUNE B OR NO TUNE, USE F0 BOR
          CMP.B     #F0TUNEA,D2         ;TUNE A?
          BNE.S     F0F5AX6             ;NO, USE F0 BOR
          SUB.W     #F0TERM-F0BOR,D7    ;YES, USE F0 TERM
F0F5AX6   DIVU      D1,D7               ;DIFFERENTIAL
          BRA.S     F0F5AX4             ;START LOOP
F0F5AX3   ADDQ.W    #1,D0               ;1ST US AFTER LAST AS
          MOVE.B    -1(A0,D0),0(A1,D0)  ;END(I-1) -> START(I)
          MOVE.B    0(A1,D0),0(A0,D0)   ;START(I) -> END(I)
          SUB.B     D7,0(A0,D0)         ;END(I)-DIFF -> END(I)
          MOVE.B    0(A0,D0),0(A6,D0)   ;END(I) -> PEAK(I)
          ADDQ.B    #5,0(A6,D0)         ;ADD 5HZ PERTURBATION
F0F5AX4   DBF       D1,F0F5AX3          ;LOOP
F0F5AX5   CMP.B     #F0TUNEB,D2         ;SEE IF TUNE B
          BEQ.S     F0F5B               ;IF SO, USE RULE F0F5B
          MOVE.B    #F0TERM,0(A0,D0)    ;SET LAST US END PT TO F0 TERM
          CMP.B     #F0TUNEA,D2         ;TUNE A?
          BEQ.S     F0F5XEND            ;YES, USE F0 TERM
          MOVE.B    #F0BOR,0(A0,D0)     ;NO TUNE, USE F0 BOR
          BRA.S     F0F5XEND
*
*
*
F0F5B     MOVEQ     #0,D7               ;CLEAR D7
          MOVEQ     #0,D1               ;CLEAR D1
          MOVE.W    D4,D0               ;GET COUNT OF SYLS
          BRA.S     F0F5BX1             ;START LOOP
*
F0F5BX0   MOVE.B    0(A6,D0),D1         ;GET SYL PEAK
          CMP.W     D1,D7               ;CHECK AGAINST OLD PEAK
          BGT.S     F0F5BX1             ;NOT GREATER
          MOVE.B    D1,D7               ;SAVE NEW MAX PEAK
F0F5BX1   DBF       D0,F0F5BX0          ;LOOP FOR ENTIRE CLAUSE
*
          MULU      #F0PCT20+F0PCT100,D7
          LSR.W     #7,D7                         ;COMPUTE 120% OF MAX PEAK
          MOVE.B    D7,-1(A0,D4)                  ;SAVE AS END POINT
          ADDQ.W    #5,D7                         ;END + 5HZ
          MOVE.B    D7,-1(A6,D4)                  ;SAVE AS PEAK
          CLR.B     -1(A2,D4)                     ;SET FALL TO 0
          CMP.W     #1,D4                         ;ONLY 1 SYL?
          BLE.S     F0F5XEND                      ;YES, RETURN
          MOVE.B    -2(A0,D4),-1(A1,D4)           ;NO, GET PREV END PT TO START

F0F5XEND  RTS


*----------------------------------------------------------------------------
*
*         SEPARATION INTO RISE/JUMP AND DROP/FALL
*
*----------------------------------------------------------------------------
F0G
F0G3      MOVE.L    F0PHON(A5),A0       ;GET ADDRESSES OF PHON,
          MOVE.L    F0DUR(A5),A1        ;   DUR, AND
          MOVE.L    F0STRESS(A5),A2     ;   STRESS
          SUBQ.L    #1,A0               ;ADJUST TO BEFORE BOUND
          SUBQ.L    #1,A1
          SUBQ.L    #1,A2
          MOVEQ     #0,D2               ;CLEAR D2
          MOVE.W    D4,D0               ;COUNT OF SYLLABLES
          BRA       F0GXEND             ;START LOOP
*
F0G3X0    SUBQ.L    #1,A0               ;MOVE PHON POINTER BACK
          SUBQ.L    #1,A1               ;MOVE DUR POINTER BACK
          TST.B     -(A2)               ;MOVE STRESS AND CHECK
          BPL.S     F0G3X0              ;  FOR START OF SYLLABLE
          BTST      #F0SSBIT,0(A4,D0)   ;START OF SYL FOUND, ACCENTED SYL?
          BEQ       F0GXEND             ;NO
*
          MOVEQ     #0,D1               ;CLEAR D1
          MOVE.B    (A0),D1             ;GET PHONEME CODE
          LSL.W     #2,D1               ;MAKE F.M. INDEX
          LEA       FEAT,A3             ;GET ADDR OF FEATURE MATRICES
          MOVE.L    0(A3,D1),D1         ;GET PHONEME FEATURES
          BTST      #CONSBIT,D1         ;INITIAL CONSONENT?
          BEQ       F0G4                ;NO, SKIP G3 RULES
          BTST      #VOICEDBIT,D1       ;VOICED?
          BEQ.S     F0G3A               ;NO

*-------- VOICED CONSONENT BEGINS AS
*             USE 20% JUMP AND 80% RISE

F0G3B     MOVE.W    #F0PCT20,D1
          MOVE.L    F0RISE(A5),A3       ;GET ADDR OF RISE ARRAY (FOR  F0G3AX0)
          BRA.S     F0G3AX0

*-------- UNVOICED CONSONENT BEGINS AS
*            INCREASE PEAK BY 20%,
*            INCREASE ACCENTS BY 20%
*            USE 80% JUMP AND 20% RISE

F0G3A     MOVE.L    F0PEAK(A5),A6                           ;GET PEAK ARRAY
          ADDPCT    #F0PCT20,0(A6,D0),F0BOR,0(A6,D0),D1     ;BUMP PEAK 20% OF LR
          MOVE.L    F0FALL(A5),A3                           ;GET FALL ARRAY
          ADD.B     D1,0(A3,D0)                             ;BUMP FALL ACCENT
          MOVE.L    F0RISE(A5),A3                           ;GET RISE ARRAY
          ADD.B     D1,0(A3,D0)                             ;BUMP RISE ACCENT

          MOVE.W    #F0PCT80,D1                             ;USE 80% JUMP
*
F0G3AX0   MOVE.L    F0START(A5),A6                          ;GET START ARRAY
          ADDPCT    D1,0(A3,D0),0,0(A6,D0),D2               ;INCREASE START
          SUB.B     D2,0(A3,D0)                             ;DECREASE RISE
*
F0G4      LEA       FEAT,A3                       ;GET ADDR OF FEATURE MATRICES
          BTST      #F0WORDFB,0(A4,D0)            ;WORD FINAL?
          BNE.S     F0G4AX                        ;YES, SKIP G4 RULES
          BTST      #F0SSBIT,1(A4,D0)             ;NEXT SYL US?
          BNE.S     F0G4AX                        ;NO, SKIP G4 RULES
*
*         FIND STRESSED VOWEL IN ACCENTED SYLLABLE
*
          MOVEQ     #0,D1
F0G4X0    MOVE.B    0(A2,D1),D2                   ;GET STRESS BYTE
          ADDQ.W    #1,D1                         ;BUMP INDEX
          AND.B     #F0ACNTNO,D2                  ;ISOLATE ACCENT NUMBER
          BEQ.S     F0G4X0                        ;NOT STRESSED VOWEL
*
*         SEARCH FORWARD UNTIL EITHER AN UNVOICED CONSONENT
*         IS FOUND - AND APPLY RULE 4A, OR THE UNSTRESSED
*         VOWEL IN THE FOLLOWING SYLLABLE IS FOUND - AND APPLY
*         RULE 4B
*
          MOVEQ     #0,D2                         ;UNVOICED CONS FLAG
F0G4X1    MOVEQ     #0,D7                         ;CLEAR
          MOVE.B    0(A0,D1),D7                   ;GET PHONEME
          CMP.B     #PHCQ,D7                      ;GLOTTAL?
          BEQ.S     F0G4B                         ;YES, USE RULE G4B
          LSL.W     #2,D7                         ;CONVERT TO F.M. INDEX
          MOVE.L    0(A3,D7),D7                   ;GET PHONEME FEATURES
          BTST      #VOWELBIT,D7                  ;VOWEL FOUND?
          BNE.S     F0G4B                         ;YES, USE RULE G4B
          BTST      #VOICEDBIT,D7                 ;VOICED CONSONENT?
          BEQ.S     F0G4A                         ;NO, USE RULE G4A
*
F0G4X2    ADDQ.W    #1,D1                         ;BUMP INDEX
          BRA.S     F0G4X1                        ;  AND CONTINUE

*-------- USE STANDARD FALL/DROP RATIO OF 50/50

F0G4AX    MOVE.W    D4,D7                         ;GET NUMBER OF SYLS
          SUBQ.W    #1,D7                         ;GET POSITION OF LAST SYL
          CMP.W     D0,D7                         ;IS AS THE LAST SYLLABLE?
          BEQ.S     F0GXEND                       ;YES, NO DROP ON TERM
*                                                  ;OTHERWISE,
          MOVE.W    #F0PCT50,D7                   ;   USE 50% OF FALL AS DROP
          BRA.S     F0G4BX0                       ;   AND JUMP TO COMMON CODE

*-------- FOUND A VOICED CONSONENT BETWEEN ACCENTED AND UNACCENTED VOWELS

F0G4A     MOVE.W    #F0PCT66,D7                   ;USE 66% OF FALL AS DROP
          BRA.S     F0G4BX0                       ;AND JUMP TO COMMON CODE

*-------- DID NOT FIND VOICED CONS BETWEEN ACCENTED AND UNACCENTED VOWELS

F0G4B     MOVE.W    #F0PCT20,D7                   ;USE 20% OF FALL AS DROP


F0G4BX0   MOVE.L    F0FALL(A5),A3                 ;GET ADDRESS OF FALL ARRAY
          MOVE.L    F0END(A5),A6                  ;GET ADDRESS OF END ARRAY
          ADDPCT    D7,0(A3,D0),0,0(A6,D0),D2     ;INCREASE END POINT
          SUB.B     D2,0(A3,D0)                   ;REDUCE FALL AMOUNT

F0GXEND   DBF       D0,F0G3X0                     ;LOOP

          RTS


*
*-----------------------------------------------------------------------------;
*                                                                             ;
*                           SUBROUTINE F0INTERP                               ;
*                                                                             ;
*                                                                             ;
*             COMPUTES INTERMEDIATE US START, PEAK, AND END VALUES            ;
*                                                                             ;
*             A0 - END ARRAY                    A1 - START ARRAY              ;
*             A4 - ADDRESS OF MULT TABLE        A6 - PEAK ARRAY               ;
*                                                                             ;
*             D0 - INDEX INTO START, PEAK, AND END ARRAYS                     ;
*             D2 - NUMBER OF INTERVENING US'S                                 ;
*             D6 - DROP FROM END OF FIRST "AS" TO TOP OF BOR (BOR-5HZ)        ;
*                                                                             ;
*-----------------------------------------------------------------------------;

F0INTERP  BRA.S     F0INTRP1            ;START LOOP
F0INTRP0  MOVE.B    0(A0,D0),1(A1,D0)   ;END(I) -> ST(I+1)
          MULU      (A4)+,D6
          LSR.W     #7,D6               ;COMPUTE PERCENTAGE OF DROP
          ADDQ.W    #1,D0               ;BUMP INDEX COUNTER
          MOVE.B    0(A1,D0),0(A0,D0)   ;ST(I+1) -> END(I+1)
          SUB.B     D6,0(A0,D0)         ;ST(I+1) - % OF DROP -> END(I+1)
          MOVE.B    0(A0,D0),0(A6,D0)   ;END(I+1) -> PEAK(I+1)
          ADDQ.B    #5,0(A6,D0)         ;PEAK = PEAK + 5HZ
F0INTRP1  DBF       D2,F0INTRP0         ;LOOP
          RTS



*--------- PERCENTAGES SEQUENCE FOR THREE US'S OUTSIDE P-UNIT ------------------

F0PNPCT3  DC.W      F0PCT45             ;DROP OF 1ST US = 45%
          DC.W      F0PCT78             ;DROP OF 2ND US = 35% (78% OF 45%)
          DC.W      F0PCT57             ;DROP OF 3RD US = 20% (57% OF 35%)


*--------- PERCENTAGES SEQUENCE FOR TWO US'S OUTSIDE P-UNIT --------------------

F0PNPCT2   DC.W     F0PCT60             ;DROP OF 1ST US = 60%
           DC.W     F0PCT66             ;DROP OF 2ND US = 40% (66.6% OF 60%)


*--------- PERCENTAGES SEQUENCE FOR ONE US OUTSIDE P-UNIT ----------------------

F0PNPCT1  DC.W      F0PCT100            ;DROP OF ONLY US = 100%


          END 
	TTL	'$Header: interp.asm,v 32.1 86/01/22 00:24:01 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: interp.asm,v 32.1 86/01/22 00:24:01 sam Exp $
*
* $Locker:  $
*
* $Log:	interp.asm,v $
* Revision 32.1  86/01/22  00:24:01  sam
* placed under source control
* 
*
**********************************************************************
               SECTION     speech

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                       ;
*       INTERPOLATION  MODULE           ;
*                                       ;
* LINEARLY INTERPOLATES BETWEEN DATA    ;
* POINTS IN THE COEF BUFFER WHICH ARE   ;
* SITUATED AT INTERVALS OF 8 BYTES.     ;
* THEN SUBSTITUTES NASAL MURMURS.       ;
* ALSO MODIFIES F0 VALUES BASED ON      ;
* PHONEMICS.                            ;
*                                       ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*
         INCLUDE   'featequ.i'
         INCLUDE   'pcequs.i'
         INCLUDE   'gloequs.i'
*
         XDEF     INTERP
         XREF     FEAT,F1T
*
INTERP   MOVEQ    #0,D0       ;CLEAR STUFF
         MOVEQ    #0,D1
         MOVEQ    #0,D2
         MOVEQ    #0,D3
         MOVEQ    #0,D4
         MOVEQ    #0,D5
         MOVEQ    #0,D6
         MOVEQ    #0,D7
*
* INTERPOLATE COEF BUFFER
*
         MOVE.L   COEFPTR(A5),A0   ;F1
*         LEA      COEF,A0   ;F1
         BSR      SEARCH
         MOVE.L   COEFPTR(A5),A0
*         LEA      COEF,A0   ;F2
         ADDQ.L   #1,A0
         BSR      SEARCH
         MOVE.L   COEFPTR(A5),A0
*         LEA      COEF,A0   ;F3
         ADDQ.L   #2,A0
         BSR      SEARCH
         MOVE.L   COEFPTR(A5),A0
*         LEA      COEF,A0   ;F0
         ADDQ.L   #7,A0
         BSR      SEARCH
*        BSR      INTERAMP
* SMOOTH FORMANT DATA
*        MOVE.L   COEFPTR(A5),A6
*        LEA      COEF,A6     ;F1
*        BSR      SMOOTH1
         MOVE.L   COEFPTR(A5),A6
*         LEA      COEF,A6   ;F2
         ADDQ.L   #1,A6
         BSR      SMOOTH      ;SEVERE SMOOTHING OF F2
         MOVE.L   COEFPTR(A5),A6
*         LEA      COEF,A6   ;F3
         ADDQ.L   #2,A6
         BSR      SMOOTH1
         BSR      PEF0        ;MODIFY F0 VALUES
         MOVE.L   COEFPTR(A5),A6
*         LEA      COEF,A6   ;SMOOTH F0
         ADDQ.L   #7,A6
         BSR      SMOOTH
*
         BSR      FRICON
         BSR.S    INTERAMP
         BSR      LAMP
         BSR      NOSE
         TST.B    Mouth(A5)
         BEQ.S    INTEXIT
         BSR      SMOMO
INTEXIT  RTS
*
INTERAMP MOVE.L   COEFPTR(A5),A0
*        LEA      COEF,A0   ;AMP1
         ADDQ.L   #3,A0
         BSR      SEARCH1
         MOVE.L   COEFPTR(A5),A0
*         LEA      COEF,A0   ;AMP2
         ADDQ.L   #4,A0
         BSR      SEARCH1
         MOVE.L   COEFPTR(A5),A0
*         LEA      COEF,A0   ;AMP3
         ADDQ.L   #5,A0
         BSR      SEARCH1
         RTS
*
*      SUBROUTINE 'INTERP8'
*
* LINEARLY INTERPOLATES BETWEEN TWO VALUES
* SITUATED AT (A0) AND 0(A0,D1) PLACING
* INTERMEDIATE VALUES AT 8 BYTE INTERVALS.
* D1 MUST BE A MULTIPLE OF 8 > 8.
* ALL ARITHMETIC IS DONE WITH A 5 BIT FRACTION.
*
INTERP8  MOVEQ    #0,D0
         MOVE.L   D0,D6
         MOVE.B   0(A0,D1),D0 ;END PT TO D0
         MOVE.B   (A0),D6     ;START PT TO D6
         SUB.L    D6,D0       ;COMPUTE DELTA
         ASL.L    #5,D0       ;DELTA * 32
         LSR.W    #3,D1       ;D1=ARITH. OFFSET
         DIVS     D1,D0       ;D0=STEP * 32
         ADDQ.L   #8,A0
         ASL.W    #5,D6       ;START * 32
         SUBQ.W   #2,D1       ;FOR PROPER LOOP COUNT
INTER81  ADD.W    D0,D6       ;ADD STEP
         MOVE.W   D6,D7       ;SAVE D6
         ASR.W    #5,D7       ;/32
         MOVE.B   D7,(A0)     ;PLACE INTERP VAL IN ARRAY
         ADDQ.L   #8,A0
         DBF      D1,INTER81
         RTS
*
*    SUBROUTINES 'SEARCH1' AND 'SEARCH'
*
* SCAN THE COEF BUFFER LOOKING FOR NON-CLEAR
* DATA POINTS.  THESE LOCATIONS ARE PASSED TO
* INTERP8.
*
SEARCH1  MOVEQ    #0,D1       ;ZERO INDEX
SCH4     ADDQ.W   #8,D1       ;LOOK AT NEXT PT
         MOVE.B   0(A0,D1),D6 ;VALUE TO SCR
         CMP.B    #$FF,D6     ;END?
         BNE      SCH3        ;NO, CONT.
         RTS
SCH3     CMP.B    #$FE,D6     ;CLEAR PT?
         BEQ      SCH4        ;YES, BRANCH
         CMP.W    #8,D1       ;OFFSET ONLY 1?
         BNE      SCH6        ;NO, BRANCH
         ADDQ.L   #8,A0       ;YES, DO NOT INTERP
         BRA      SEARCH1     ;NEXT PT.
SCH6     BSR      INTERP8
         BRA      SEARCH1
*
SEARCH   MOVEQ    #0,D1
SCH1     ADDQ.W   #8,D1
         TST.B    0(A0,D1)    ;CLEAR PT?
         BEQ      SCH1        ;YES, BRANCH
         CMP.B    #$FF,0(A0,D1) ;END?
         BNE      SCH2        ;NO, BRANCH
         RTS
SCH2     CMP.W    #8,D1       ;OFFSET ONLY 1?
         BNE      SCH5        ;NO, BRANCH
         ADDQ.L   #8,A0       ;YES, DO NOT INTERP
         BRA      SEARCH
SCH5     BSR      INTERP8
         BRA      SEARCH
*
* SUBROUTINE 'NOSE'
*
* REPLACES NASAL FRAMES WITH STRAIGHT NASAL COEFS.
* THE PARMS FOR M,N,NX & NH ARE STORED IN THE TARGS
* FOR UL, UM, UN AND UN+1 RESPECTIVELY.
*
*            REGISTER USAGE
*
* D0=DUR  D1=LOOP  D2=FEAT  D3=PHON  D4=LOOP2  D5=128
* A0=COEF  A1=PARMS  A2=PHON  A3=DUR  A4=FEAT
* A5 UNUSED  A6=PARMS+
*
NOSE     MOVE.L   COEFPTR(A5),A0
*         LEA      COEF,A0
         LEA      F1T,A1
         LEA      PHON(A5),A2
         LEA      DUR(A5),A3
         LEA      FEAT,A4
         MOVEQ    #0,D5
         MOVE.B   #128,D5      ;PARM INCREMENT
NOSE3    MOVEQ    #0,D3
         MOVE.L   D3,D1
         MOVE.L   D3,D4
         MOVE.B   (A2)+,D3     ;GET PHON & INCR
         CMP.B    #$FF,D3      ;END?
         BNE      NOSE2        ;NO, BRANCH
         RTS
NOSE2    LSL.W    #2,D3        ;INDEX FOR FEAT
         MOVE.L   0(A4,D3),D2  ;GET FEATURE
         MOVEQ    #0,D0
         MOVE.B   (A3)+,D0     ;GET DUR & INCR
         AND.B    #$3F,D0      ;ISOLATE DURATION
         BTST     #NASALBIT,D2 ;NASAL?
         BNE      NOSE1        ;YES, BRANCH
         BTST     #VOWELBIT,D2 ;NO, VOWEL?
         BEQ      NOSE9        ;NO, BRANCH
         MOVEQ    #0,D3        ;YES, GET NEXT PHON
         MOVE.B   (A2),D3      ;
         LSL.W    #2,D3        ;INDEX FOR FEAT
         MOVE.L   0(A4,D3),D2  ;GET FEATURE
         BTST     #NASALBIT,D2 ;PHON+1 NASAL?
         BEQ      NOSE9        ;NO, BRANCH
*VOWEL IS PRE-NASAL: RAISE F1 BY 100HZ AND LOWER ITS AMPLITUDE
*BY 3DB FOR THE LATTER HALF OF ITS DURATION.
         MOVE.B   D0,D1        ;YES, DUR TO D1
         LSR.B    #1,D1        ;DUR/2
         MOVE.B   D1,D4        ;SAVE DUR/2
         LSL.W    #3,D1        ;8 * (DUR/2)
         ADD.L    D1,A0        ;ADD TO COEF
         ADD.B    #4,(A0)      ;F1 + 50HZ AT CENTER FRAME
         ADDQ.L   #8,A0        ;PT TO NEXT FRAME
         SUB.B    D4,D0        ;REMAINDER OF FRAMES + 1
         SUBQ.B   #2,D0        ;LOOP COUNT
NOSE10   ADD.B    #9,(A0)      ;F1 + 100Hz
         MOVE.B   3(A0),D1     ;AMPL - 3db
         LSR.B    #2,D1
         SUB.B    D1,3(A0)
         ADDQ.L   #8,A0        ;PT TO NEXT FRAME
         DBF      D0,NOSE10    ;LOOP
         BRA      NOSE3        ;NEXT PHON
*
NOSE9    LSL.W    #3,D0        ;NO, MULT DUR BY 8
         ADD.L    D0,A0        ;ADD TO COEF
         BRA      NOSE3
NOSE1    LSR.W    #2,D3        ;RESTORE PHON
         CMP.B    #PHCM,D3     ;WHICH NASAL?
         BNE      NOSE4
         MOVE.B   #PHCUL,D3    ;ITS AN 'M'
         BRA      NOSEY
NOSE4    CMP.B    #PHCN,D3
         BNE      NOSE5
         MOVE.B   #PHCUM,D3    ;ITS AN 'N'
         BRA      NOSEY
NOSE5    CMP.B    #PHCNX,D3
         BNE      NOSE6
         MOVE.B   #PHCUN,D3    ;ITS AN 'NX
         BRA      NOSEY
NOSE6    MOVE.B   #PHCUN+1,D3  ;ITS AN 'NH'
NOSEY    MOVE.W   D0,D1        ;SET LOOP1=DUR-1
         SUBQ.W   #1,D1
NOSE8    MOVE.L   A1,A6        ;PARM BASE ADDR
         ADD.L    D3,A6        ;ADD PHON CODE
         MOVEQ    #5,D4        ;LOOP= 6 PARMS
NOSE7    MOVE.B   (A6),(A0)+   ;MOVE PARM TO COEF & INCR
         ADD.L    D5,A6        ;NEXT PARM
         DBF      D4,NOSE7
         ADD.L    #2,A0        ;PT TO NEXT FRAME
         DBF      D1,NOSE8
         BRA      NOSE3        ;RE-ENTER MAIN NOSE
*
*
* SUBROUTINE 'FRICON'
* SETS THE FIRST TWO, AND THE LAST TWO FRAMES
* OF AN UNVOICED FRICATIVE OR ASPIRANT TO -6DB
* OF ITS INHERENT VOLUME.
*
*         REGISTER USAGE
*
* D0=PHON  D1=FEAT  D2=DUR  D3=FRIC AMP  D4=$F0
* D5=$FF   D6=FRIC+ASPIR    D7=$3F
* A0=PHON  A1=DUR  A2=STRESS  A3 -  A4=FEAT  A5 -  A6=COEF
*
FRICON   LEA      PHON(A5),A0
         LEA      DUR(A5),A1
         LEA      STRESS(A5),A2   ;MAYBE FOR FUTURE USE
         LEA      FEAT,A4
         MOVE.L   COEFPTR(A5),A6
*         LEA      COEF,A6
         MOVE.L   #FRIC+ASPIR,D6 ;TEMPLATES
         MOVEQ    #0,D4       ; CLEAR (USE BIT 31 AS NOT FIRST PHON FLAG)
         MOVE.B   #$F0,D4     ; FOR ANDS
         MOVE.B   #$FF,D5     ; & COMPARES
         MOVE.B   #$3F,D7
         BRA.S    FRO0A
FRO0     BSET     #31,D4      ;SET FIRST PHONEME FLAG
FRO0A    MOVEQ    #0,D0       ;CLEAR PHON
         MOVEQ    #0,D2       ;CLEAR DUR
         MOVE.B   (A0)+,D0    ;GET PHON & INCR
         CMP.B    D5,D0       ;END?
         BNE.S    FRO1        ;NO, BRANCH
         RTS                  ;YES, EXIT
FRO1     MOVE.B   (A1)+,D2    ;GET DURATION
         AND.B    D7,D2       ;ISOLATE DURATION
         CMP.B    #PHCPE,D0   ;PERIOD?
         BEQ.S    FRO1B       ;YES, BRANCH
         CMP.B    #PHCQM,D0   ;QUESTION MARK?
         BNE.S    FRO1A       ;NO, BRANCH
*MAKE FORMANTS OF PERIOD OR '?' EQUAL THAT OF PREV FRAME
FRO1B    MOVE.L   A6,A3       ;YES, COEF TO A3
         SUBQ.L   #8,A3       ;PT TO PREV FRAME (PHON)
         MOVE.B   D2,D1       ;DUR TO D1
         EXT.W    D1          ;MAKE SUITABLE
         SUBQ.W   #1,D1       ; AS LOOP COUNTER
FRO1C    MOVE.B   (A3),(A6)   ;MOVE F1
         MOVE.B   1(A3),1(A6) ; F2
         MOVE.B   2(A3),2(A6) ; F3
         ADDQ.L   #8,A6       ;NEXT FRAME OF PERIOD (OR ?)
         DBF      D1,FRO1C
         BRA      FRO0        ;NEXT PHON (WILL BE THE END)
*
FRO1A    LSL.W    #2,D0       ;INDEX FOR FEAT
         MOVE.L   0(A4,D0),D1 ;GET FEATURE
         BTST     #VOICEDBIT,D1 ;VOICED?
         BNE      FRO2        ;YES, BRANCH
         AND.L    D6,D1       ;NO, FRIC OR ASPIR?
         BEQ      FRO2        ;NO, BRANCH
         CMP.B    #2,D2       ;DUR > 2 FRAMES
         BLE      FRO2        ;NO, BRANCH
* DECAY OF VOICING BEFORE A FRIC OR ASPIR
         BTST     #31,D4      ;CHECK NOT FIRST PHONEME FLAG
         BEQ.S    FRO3        ;BRANCH IF FIRST PHONEME
         MOVEQ    #0,D0       ;YES, CLEAR PHON
         MOVE.B   -2(A0),D0   ;GET PRECEDING PHON
         LSL.W    #2,D0       ;INDEX FOR FEAT
         MOVE.L   0(A4,D0),D1 ;GET FEATURE
         BTST     #SONORBIT,D1 ;SONORANT?
         BEQ      FRO3        ;NO, BRANCH
         CLR.B    -5(A6)      ;AMPL'S OF LAST FRAME=0
         CLR.W    -4(A6)
         MOVE.B   #$FE,-13(A6) ;CLEAR 2ND TO LAST FRAME
         MOVE.W   #$FEFE,-12(A6)
*
FRO3     MOVE.B   6(A6),D3    ;GET FF
         AND.B    #$F,D3      ;ISOLATE AMPL
         LSR.B    #1,D3       ;DOWN 6DB
         MOVE.B   D3,D1
         ADDQ.B   #1,D1       ;ROUND
         LSR.B    #1,D1       ;DOWN 12DB
         AND.B    D4,6(A6)    ;ERASE AMPLS OF 1ST
         AND.B    D4,14(A6)   ;  TWO FRAMES
         OR.B     D1,6(A6)    ;REPLACE WITH NEW AMPLS
         OR.B     D3,14(A6)
         LSL.W    #3,D2
         ADD.L    D2,A6       ;PT TO NEXT PHON
         AND.B    D4,-2(A6)   ;ERASE AMPLS OF LAST
         AND.B    D4,-10(A6)  ;  TWO FRAMES
         OR.B     D1,-2(A6)   ;REPLACE WITH NEW AMPLS
         OR.B     D3,-10(A6)
*        CLR.B    -5(A6)      ;SET AMPL'S OF FRIC TO ZERO TO
*        CLR.W    -4(A6)      ; PREVENT POP INTO VOICED SEG
         MOVEQ    #0,D0
* ONSET OF VOICING
         MOVE.B   (A0),D0     ;GET NEXT PHON
         CMP.B    D5,D0       ;END OF INPUT?    **** ADDED 11/27
         BEQ      FRO0        ;YES, BRANCH UP   ****       "
         LSL.W    #2,D0       ;INDEX FOR FEAT
         MOVE.L   0(A4,D0),D1 ;GET FEATURE
         BTST     #SONORBIT,D1  ;SONORANT?
         BEQ      FRO0        ;NO, BRANCH UP
         CLR.B    3(A6)       ;YES, SET AMPL OF FRAME 1
         CLR.W    4(A6)       ; TO ZERO
         MOVE.B   #$FE,11(A6) ;CLEAR NEXT 2 FRAMES
         MOVE.W   #$FEFE,12(A6)
         MOVE.B   #$FE,19(A6)
         MOVE.W   #$FEFE,20(A6)
         BRA      FRO0        ;AGAIN
FRO2     LSL.W    #3,D2       ;PT TO NEXT PHON
         ADD.L    D2,A6
         BRA      FRO0
*
* SUBROUTINE 'LAMP'
*
* CONVERTS AMPLITUDE ARRAYS FROM DB TO LINEAR
*
         DC.B     0,0,0,0,0,0,0,0  ;ROOM FOR SUBTRACTS
LINT     DC.B     0,1,1,1,1,2,2,2,3,3,3,3,4 ;DB TO LINEAR
         DC.B     4,5,5,6,7,7,8,9,10,11,13  ; CONVERSION
         DC.B     14,16,18,20,23,25,28,31   ; TABLE
LAMP     LEA      LINT,A1
         MOVE.L   COEFPTR(A5),A0
         ADDQ.L   #3,A0
*         LEA      COEF+3,A0
         MOVE.B   #$FE,D4     ;FOR COMPARES
         MOVE.B   #$FF,D3
         MOVEQ    #0,D0
LAMP2    MOVE.B   (A0),D0     ;GET AMPL
         CMP.B    D0,D3       ;END?
         BEQ.S    LAMP1       ;YES, BRANCH
         CMP.B    D0,D4       ;CLEAR BYTE?
         BNE.S    LAMP3       ;NO, BRANCH
         ADDQ.L   #8,A0       ;YES, SKIP THIS FRAME
         BRA.S    LAMP2

LAMP3    MOVE.B   0(A1,D0),(A0)+  ;REPLACE FROM TABLE
         MOVE.B   (A0),D0
         MOVE.B   0(A1,D0),(A0)+
         MOVE.B   (A0),D0
         MOVE.B   0(A1,D0),(A0)
         ADDQ.L   #6,A0
         BRA.S    LAMP2
LAMP1    RTS
*
* SUBROUTINE 'SMOOTH'
*
* 7-POINT DATA AVERAGER, WEIGHTING = 1112111
*
*         REGISTER USAGE
*
* D0=SUM  D1=LOOP  D2=8*LOOP D3=SCRATCH
* D4 -    D5 -     D6=$FF    D7 -
* A0-A5 -          A6=COEF+DISP
*
SMOOTH   MOVE.B   #$FF,D6     ;FOR COMPARES
         MOVEQ    #0,D2       ;CLEAR STUFF
         MOVEQ    #0,D3
SMO0     MOVEQ    #0,D0
         MOVEQ    #6,D1       ;LOOP COUNT
SMO1     MOVE.B   D1,D2
         LSL.B    #3,D2       ;8*LOOP FOR INDEX
         MOVE.B   0(A6,D2),D3 ;GET ELEMENT
         CMP.B    D3,D6       ;END?
         BNE      SMO2        ;NO, BRANCH
         RTS                  ;YES, EXIT
SMO2     ADD.W    D3,D0       ;ADD TO SUM
         DBF      D1,SMO1     ;GET NEXT ELEMENT
         MOVE.B   24(A6),D3   ;GET 3RD ELEMENT AGAIN
         ADD.W    D3,D0       ;DOUBLE ITS WEIGHT
         LSR.W    #3,D0       ;SUM / 8
         MOVE.B   D0,24(A6)   ;PUT BACK
         ADDQ.L   #8,A6       ;NEXT FRAME
         BRA      SMO0
*
* SUBROUTINE 'SMOOTH1'
* SAME AS ABOVE EXCEPT WITH WEIGHTING = 1226221
*
SMOOTH1  MOVE.B   #$FF,D6     ;FOR COMPARES
         MOVEQ    #0,D2       ;CLEAR STUFF
         MOVEQ    #0,D3
SMO10    MOVEQ    #0,D0
         MOVEQ    #6,D1       ;LOOP COUNT
SMO11    MOVE.B   D1,D2
         LSL.B    #3,D2       ;8*LOOP FOR INDEX
         MOVEQ    #0,D3
         MOVE.B   0(A6,D2),D3 ;GET ELEMENT
         CMP.B    D3,D6       ;END?
         BNE      SMO12       ;NO, BRANCH
         RTS                  ;YES, EXIT
SMO12    LSL.W    #1,D3       ;DOUBLE IT
         ADD.W    D3,D0       ;ADD TO SUM
         DBF      D1,SMO11
         MOVEQ    #0,D3
         MOVE.B   (A6),D3     ;GET 1ST ELEMENT
         SUB.W    D3,D0       ;SUB FROM SUM
         MOVE.B   48(A6),D3   ;GET 7TH
         SUB.W    D3,D0       ;SUB FROM SUM
         MOVE.B   24(A6),D3   ;GET 4TH
         LSL.W    #2,D3       ;*4
         ADD.W    D3,D0       ;ADD TO SUM
         LSR.W    #4,D0       ;SUM / 16
         MOVE.B   D0,24(A6)   ;PUT BACK IN 4TH
         ADDQ.L   #8,A6       ;NEXT FRAME
         BRA      SMO10
*
* SUBROUTINE 'PEF0'
*
* MODIFIES F0 VALUES BASED ON THE TYPE OF PHON
*
*               REGISTER USAGE
*
* D0=PHON  D1=FEATURE  D2=DURATION  D3=DELTA  D4=SCRATCH  D5-7 --
* A0=PHON  A1 --  A2=DUR  A3 --  A4=FEAT  A5 --  A6=COEF
*
PEF0     LEA      PHON(A5),A0
         LEA      DUR(A5),A2
         LEA      FEAT,A4
         MOVE.L   COEFPTR(A5),A6
*         LEA      COEF,A6
PEF2     MOVEQ    #0,D2       ;CLEAR DURATION
         MOVEQ    #0,D0       ;CLEAR PHON
         MOVE.B   (A0)+,D0    ;GET PHON
         CMP.B    #$FF,D0     ;END?
         BNE      PEF1        ;NO, BRANCH
         RTS                  ;YES, RETURN
PEF1     MOVE.B   (A2)+,D2    ;GET DURATION
         AND.B    #$3F,D2     ;ISOLATE DURATION
         CMP.B    #PHCB,D0    ;'B'?
         BEQ      PEFVPLO     ;YES, BRANCH
         CMP.B    #PHCD,D0    ;NO, 'D'?
         BEQ      PEFVPLO     ;YES, BRANCH
         CMP.B    #PHCQ,D0    ;NO, GLOTTAL STOP?
         BEQ      PEFGLOT     ;YES, BRANCH
         LSL.W    #2,D0       ;NO, INDEX FOR FEAT
         MOVE.L   0(A4,D0),D1 ;GET FEATURE
         BTST     #PLOSABIT,D1  ;PLOSA?
         BNE      PEFPLO        ;YES, BRANCH
         BTST     #NASALBIT,D1  ;NO, NASAL?
         BNE      PEFNAS        ;YES, BRANCH
         BTST     #FRICBIT,D1   ;NO, FRIC?
         BNE      PEFRIC        ;YES, BRANCH
         AND.L    #VOWEL+LIQUID+GLIDE,D1  ;NO, THESE THINGS?
         BNE      PEFVOW      ;YES, BRANCH
         LSL.W    #3,D2       ;NO, SKIP THIS PHON
         ADD.L    D2,A6       ;PT TO NEXT PHON
         BRA      PEF2        ;NEXT PHON
PEFVPLO  MOVEQ    #10,D3      ;DELTA = -8HZ
PEF3     SUBQ     #1,D2       ;LOOP COUNT =  DUR-1
PEF3A    ADD.B    D3,7(A6)    ;ADD DELTA TO F0 ENTRY
         ADDQ.L   #8,A6       ;PT TO NEXT FRAME
         DBF      D2,PEF3A
         BRA      PEF2        ;NEXT PHON
PEFPLO   MOVEQ    #-6,D3      ;DELTA = +5HZ
         BRA      PEF3
PEFNAS   MOVEQ    #-6,D3      ;DELTA = +5HZ
         BRA      PEF3
PEFRIC   MOVEQ    #-6,D3     ;DELTA = +5HZ
         BRA      PEF3
PEFGLOT  MOVE.B   #230,D3     ;SUBSTITUTE F0 = 48HZ
         SUBQ     #1,D2       ;   AT A GLOTTAL STOP
PEF4     MOVE.B   D3,7(A6)
         ADDQ.L   #8,A6
         DBF      D2,PEF4
         BRA      PEF2        ;NEXT PHON
PEFVOW   SUBQ     #1,D2       ;LOOP COUNT
PEF5     MOVE.B   (A6),D3     ;GET F1
         SUB.B    #43,D3      ;F1-43   (F1-500HZ)
         ASR.B    #2,D3       ;(F1-43)/4
*         MOVE.B   D3,D4       ;SAVE
*         ASR.B    #1,D3       ;(F1-43)/8
*         ADD.B    D4,D3       ;(1/4 + 1/8) * (F1 - 43)
         ADD.B    D3,7(A6)    ;MODIFY F0 ENTRY
         ADDQ.L   #8,A6       ;PT TO NEXT FRAME
         DBF      D2,PEF5
         BRA      PEF2
*
* SUBROUTINE 'SMOMO'
*
* SMOOTHS PACKED MOUTH ARRAY
* WEIGHTING IS 1112111
*
*
*  Smooth lower nibble
*
SMOMO	MOVE.L	MOTHPTR(A5),A0	;pt to mouth buffer
	MOVE.L  MOTHSIZE(A5),D1 ;number of bytes in above
	SUBQ.W	#5,D1		;compensate for loop count
	MOVEQ	#$0F,D4		;mask
	MOVEQ	#-16,D5		;mask
SMOMO3	MOVEQ	#0,D2		;clear sum
	MOVEQ	#2,D0		;for 1st 3 elements
SMOMO1	MOVE.B	(A0)+,D6	;get value
	AND.B	D4,D6		;isolate lower nibble
	ADD.B	D6,D2		;add to running sum
	DBF	D0,SMOMO1	;next element (inner)
	MOVE.B	(A0)+,D6	;add next element double weight
	AND.B	D4,D6
	ADD.B	D6,D2
	ADD.B	D6,D2
	MOVEQ	#2,D0		;for last 3
SMOMO2	MOVE.B	(A0)+,D6
	AND.B	D4,D6
	ADD.B	D6,D2
	DBF	D0,SMOMO2	;next element (inner)
	SUBQ.L	#6,A0		;pt to 2nd element for next time
	LSR.B	#3,D2		;divide sum by 8
	AND.B	D5,2(A0)	;clear lower nibble
	OR.B	D2,2(A0)	;replace with smoothed value
	DBF	D1,SMOMO3	;next element (outer)
*
* Smooth upper nibble
*
	MOVE.L	MOTHPTR(A5),A0
	MOVE.L	MOTHSIZE(A5),D1
	SUBQ.W	#5,D1
	MOVEQ	#$0F,D5		;mask
	MOVEQ	#-16,D3		;mask
	MOVEQ	#4,D4		;shift count
SMOMO6	MOVEQ	#0,D2		;clear sum
	MOVEQ	#2,D0		;for 1st 3
SMOMO4	MOVE.B	(A0)+,D6	;get value
	LSR.B	D4,D6		;shift down
	ADD.B	D6,D2		;add to running sum
	DBF	D0,SMOMO4	;next element (inner)
	MOVE.B	(A0)+,D6	;add next element double weight
	LSR.B	D4,D6
	ADD.B	D6,D2
	ADD.B	D6,D2
	MOVEQ	#2,D0		;for last 3
SMOMO5	MOVE.B	(A0)+,D6
	LSR.B	D4,D6
	ADD.B	D6,D2
	DBF	D0,SMOMO5
	SUBQ.L	#6,A0
	ADD.B	D2,D2		;justify sum/8 to upper nibble
	AND.B	D3,D2		;isolate upper nibble
	AND.B	D5,2(A0)
	OR.B	D2,2(A0)
	DBF	D1,SMOMO6	;next element (outer)

	RTS
	END


	TTL	'$Header: featmat.asm,v 32.1 86/01/22 00:23:56 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: featmat.asm,v 32.1 86/01/22 00:23:56 sam Exp $
*
* $Locker:  $
*
* $Log:	featmat.asm,v $
* Revision 32.1  86/01/22  00:23:56  sam
* placed under source control
* 
*
**********************************************************************
        SECTION    speech

*
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                     ;
*         FEATURE   MATRIX            ;
*                                     ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*
*
      INCLUDE   'featequ.i'
*
*
       XDEF   FEAT
*
*
FEAT  DC.L   IGNORE+WORDBRK  ;BLANK
      DC.L   BOUND+SILENT+PAUSE+WORDBRK ;.
      DC.L   BOUND+SILENT+PAUSE+WORDBRK  ;?
      DC.L   BOUND+SILENT+PAUSE+WORDBRK  ;,
      DC.L   SILENT+PAUSE+WORDBRK  ;-
      DC.L   IGNORE  ;(
      DC.L   IGNORE  ;)
      DC.L   IGNORE+INVALID               ;INVALID PHONEME CODE
      DC.L   IGNORE  ;RESERVED
      DC.L   VOWEL+SONOR+FRONT+VOICED  ;IY
      DC.L   VOWEL+SONOR+FRONT+VOICED  ;IH
      DC.L   VOWEL+SONOR+MID+VOICED  ;EH
      DC.L   VOWEL+SONOR+MID+VOICED  ;AE
      DC.L   VOWEL+SONOR+MID+VOICED  ;AA
      DC.L   VOWEL+SONOR+BACK+VOICED  ;AH
      DC.L   VOWEL+SONOR+BACK+VOICED  ;AO
      DC.L   VOWEL+SONOR+BACK+VOICED  ;UH
      DC.L   VOWEL+SONOR+BACK+VOICED  ;AX
      DC.L   VOWEL+SONOR+FRONT+VOICED  ;IX
      DC.L   VOWEL+SONOR+MID+VOICED  ;ER
      DC.L   VOWEL+SONOR+BACK+ROUND+DIPH+VOICED  ;UX
      DC.L   VOWEL+SONOR+MID+VOICED  ;QX  (SILENT VOWEL)
      DC.L   VOWEL+SONOR+BACK+ROUND+VOICED  ;OH
      DC.L   VOWEL+SONOR+MID+VOICED+LIQUID  ;RX
      DC.L   VOWEL+SONOR+MID+VOICED+LIQUID  ;LX
      DC.L   VOWEL+SONOR+FRONT+DIPH+VOICED  ;EY
      DC.L   VOWEL+SONOR+FRONT+VOICED  ;EY'
      DC.L   VOWEL+SONOR+MID+DIPH+VOICED  ;AY
      DC.L   VOWEL+SONOR+FRONT+VOICED  ;AY'
      DC.L   VOWEL+SONOR+BACK+DIPH+VOICED  ;OY
      DC.L   VOWEL+SONOR+FRONT+VOICED  ;OY'
      DC.L   VOWEL+SONOR+MID+DIPH+VOICED  ;AW
      DC.L   VOWEL+SONOR+BACK+ROUND+VOICED  ;AW'
      DC.L   VOWEL+SONOR+BACK+DIPH+VOICED  ;OW
      DC.L   VOWEL+SONOR+BACK+ROUND+VOICED  ;OW'
      DC.L   VOWEL+SONOR+BACK+ROUND+DIPH+VOICED  ;UW
      DC.L   VOWEL+SONOR+BACK+ROUND+VOICED  ;UW'
      DC.L   CONS+SONOR+BACK+ROUND+VOICED+GLIDE  ;WH
      DC.L   CONS+SONOR+BACK+VOICED+LIQUID  ;R
      DC.L   CONS+SONOR+BACK+VOICED+LIQUID  ;L
      DC.L   CONS+SONOR+BACK+ROUND+VOICED+GLIDE  ;W
      DC.L   CONS+SONOR+FRONT+VOICED+GLIDE  ;Y
      DC.L   CONS+SONOR+VOICED+STOPP+NASAL+LABIAL  ;M
      DC.L   CONS+SONOR+VOICED+STOPP+NASAL+DENTAL  ;N
      DC.L   CONS+SONOR+FRONT+VOICED+STOPP+NASAL+PALATE  ;NX
      DC.L   CONS+SONOR+VOICED+STOPP+NASAL+PALATE  ;NH  (FRENCH)
      DC.L   CONS+VOICED+DENTAL  ;DX
      DC.L   CONS+STOPP+SILENT  ;Q
      DC.L   CONS+MID+FRIC+DENTAL  ;S
      DC.L   CONS+FRIC+PALATE  ;SH
      DC.L   CONS+FRIC+LABIAL  ;F
      DC.L   CONS+FRIC+DENTAL  ;TH
      DC.L   CONS+SONOR+VOICED+FRIC+DENTAL  ;Z
      DC.L   CONS+SONOR+VOICED+FRIC+PALATE  ;ZH
      DC.L   CONS+SONOR+VOICED+FRIC+LABIAL  ;V
      DC.L   CONS+SONOR+VOICED+FRIC+DENTAL  ;DH
      DC.L   CONS+STOPP+PLOSA+AFFRIC+PALATE  ;CH
      DC.L   CONS+AFFRIC+PLOSA+PALATE  ;CH'
      DC.L   CONS+ASPIR+PLOSA+PRIME+PALATE  ;CH"
      DC.L   CONS+VOICED+STOPP+AFFRIC+FRIC+PALATE  ;J
      DC.L   CONS+VOICED+PLOS+AFFRIC+PALATE  ;J'
      DC.L   CONS+ASPIR+FRONT  ;/H
      DC.L   CONS+ASPIR+MID  ;/M
      DC.L   CONS+ASPIR+BACK  ;/B
      DC.L   CONS+ASPIR+BACK+ROUND  ;/R
      DC.L   CONS+ASPIR+BACK  ;/C  (LA 'CH'AIM)
      DC.L   CONS+VOICED+STOPP+PLOS+LABIAL  ;B
      DC.L   CONS+VOICED+STOPP+PLOS+LABIAL+PRIME  ;B'
      DC.L   CONS+VOICED+STOPP+PLOS+LABIAL+PRIME  ;B"
      DC.L   CONS+VOICED+STOPP+PLOS+DENTAL  ;D
      DC.L   CONS+VOICED+STOPP+PLOS+DENTAL+PRIME  ;D'
      DC.L   CONS+VOICED+STOPP+PLOS+DENTAL+PRIME  ;D"
      DC.L   CONS+VOICED+STOPP+PLOS+PALATE  ;G
      DC.L   CONS+VOICED+STOPP+PLOS+PALATE+PRIME  ;G'
      DC.L   CONS+VOICED+STOPP+PLOS+PALATE+PRIME  ;G"
      DC.L   CONS+VOICED+STOPP+PLOS+PALATE  ;GX
      DC.L   CONS+VOICED+STOPP+PLOS+PALATE+PRIME  ;GX'
      DC.L   CONS+VOICED+STOPP+PLOS+PALATE+PRIME  ;GX"
      DC.L   CONS+VOICED+STOPP+PLOS+PALATE  ;GH
      DC.L   CONS+VOICED+STOPP+PLOS+PALATE+PRIME  ;GH'
      DC.L   CONS+VOICED+STOPP+PLOS+PALATE+PRIME  ;GH"
      DC.L   CONS+STOPP+PLOSA+LABIAL  ;P
      DC.L   CONS+STOPP+PLOSA+LABIAL+PRIME  ;P'
      DC.L   CONS+ASPIR+PLOSA+LABIAL+PRIME  ;P"
      DC.L   CONS+STOPP+PLOSA+DENTAL  ;T
      DC.L   CONS+STOPP+PLOSA+DENTAL+PRIME  ;T'
      DC.L   CONS+ASPIR+PLOSA+PRIME  ;T"
      DC.L   CONS+STOPP+PLOSA+PALATE  ;K
      DC.L   CONS+STOPP+PLOSA+PRIME+PALATE  ;K'
      DC.L   CONS+ASPIR+PLOSA+PRIME  ;K"
      DC.L   CONS+STOPP+PLOSA+PALATE  ;KX
      DC.L   CONS+STOPP+PLOSA+PRIME+PALATE  ;KX'
      DC.L   CONS+ASPIR+PLOSA+PRIME  ;KX"
      DC.L   CONS+STOPP+PLOSA+PALATE  ;KH
      DC.L   CONS+STOPP+PLOSA+PRIME+PALATE  ;KH'
      DC.L   CONS+ASPIR+PLOSA+PRIME  ;KH"
      DC.L   VOWEL+SONOR+MID+VOICED  ;UL
      DC.L   VOWEL+SONOR+MID+VOICED  ;UM
      DC.L   VOWEL+SONOR+MID+VOICED  ;UN
      DC.L   VOWEL+SONOR+FRONT+VOICED  ;IL
      DC.L   VOWEL+SONOR+FRONT+VOICED  ;IM
      DC.L   VOWEL+SONOR+FRONT+VOICED  ;IN
      END 
	TTL	'$Header: dbyte.asm,v 32.1 86/01/22 00:22:55 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: dbyte.asm,v 32.1 86/01/22 00:22:55 sam Exp $
*
* $Locker:  $
*
* $Log:	dbyte.asm,v $
* Revision 32.1  86/01/22  00:22:55  sam
* placed under source control
* 
*
**********************************************************************

         SECTION     speech


         XDEF  MULT,SIN,FRICS,F1T,F2T,F3T
         XDEF  AMP1T,AMP2T,AMP3T,IHNDUR,MINDUR,TEXT,TINT
         XDEF  FFT,RANK,PCT,FEM1,FEM2,FEM3

         INCLUDE  'gloequs.i'
         INCLUDE  'mdbyte.i'
*
* COMPLETE MULT, SIN, TARGS, FRICS
*
MULT  DC.B   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B   0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3
  DC.B   252,252,252,252,253,253,253,253,254,254,254,254,255,255,255,255
  DC.B   0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7
  DC.B   248,248,249,249,250,250,251,251,252,252,253,253,254,254,255,255
  DC.B   0,0,1,2,3,3,4,5,6,6,7,8,9,9,10,11
  DC.B   244,244,245,246,247,247,248,249,250,250,251,252,253,253,254,255
  DC.B   0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
  DC.B   240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
  DC.B   0,1,2,3,5,6,7,8,10,11,12,13,15,16,17,18
  DC.B   236,237,238,239,241,242,243,244,246,247,248,249,251,252,253,254
  DC.B   0,1,3,4,6,7,9,10,12,13,15,16,18,19,21,22
  DC.B   232,233,235,236,238,239,241,242,244,245,247,248,250,251,253,254
  DC.B   0,1,3,5,7,8,10,12,14,15,17,19,21,22,24,26
  DC.B   228,229,231,233,235,236,238,240,242,243,245,247,249,250,252,254
  DC.B   0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30
  DC.B   224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254
  DC.B   0,2,4,6,9,11,13,15,18,20,22,24,27,29,31,33
  DC.B   220,222,224,226,229,231,233,235,238,240,242,244,247,249,251,253
  DC.B   0,2,5,7,10,12,15,17,20,22,25,27,30,32,35,37
  DC.B   216,218,221,223,226,228,231,233,236,238,241,243,246,248,251,253
  DC.B   0,2,5,8,11,13,16,19,22,24,27,30,33,35,38,41
  DC.B   212,214,217,220,223,225,228,231,234,236,239,242,245,247,250,253
  DC.B   0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45
  DC.B   208,211,214,217,220,223,226,229,232,235,238,241,244,247,250,253
  DC.B   0,3,6,9,13,16,19,22,26,29,32,35,39,42,45,48
  DC.B   204,207,210,213,217,220,223,226,230,233,236,239,243,246,249,252
  DC.B   0,3,7,10,14,17,21,24,28,31,35,38,42,45,49,52
  DC.B   200,203,207,210,214,217,221,224,228,231,235,238,242,245,249,252
  DC.B   0,3,7,11,15,18,22,26,30,33,37,41,45,48,52,56
  DC.B   196,199,203,207,211,214,218,222,226,229,233,237,241,244,248,252
  DC.B   0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60
  DC.B   192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252
  DC.B   0,4,8,12,17,21,25,29,34,38,42,46,51,55,59,63
  DC.B   188,192,196,200,205,209,213,217,222,226,230,234,239,243,247,251
  DC.B   0,4,9,13,18,22,27,31,36,40,45,49,54,58,63,67
  DC.B   184,188,193,197,202,206,211,215,220,224,229,233,238,242,247,251
  DC.B   0,4,9,14,19,23,28,33,38,42,47,52,57,61,66,71
  DC.B   180,184,189,194,199,203,208,213,218,222,227,232,237,241,246,251
  DC.B   0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75
  DC.B   176,181,186,191,196,201,206,211,216,221,226,231,236,241,246,251
  DC.B   0,5,10,15,21,26,31,36,42,47,52,57,63,68,73,78
  DC.B   172,177,182,187,193,198,203,208,214,219,224,229,235,240,245,250
  DC.B   0,5,11,16,22,27,33,38,44,49,55,60,66,71,77,82
  DC.B   168,173,179,184,190,195,201,206,212,217,223,228,234,239,245,250
  DC.B   0,5,11,17,23,28,34,40,46,51,57,63,69,74,80,86
  DC.B   164,169,175,181,187,192,198,204,210,215,221,227,233,238,244,250
  DC.B   0,6,12,18,24,30,36,42,48,54,60,66,72,78,84,90
  DC.B   160,166,172,178,184,190,196,202,208,214,220,226,232,238,244,250
  DC.B   0,6,12,18,25,31,37,43,50,56,62,68,75,81,87,93
  DC.B   156,162,168,174,181,187,193,199,206,212,218,224,231,237,243,249
  DC.B   0,6,13,19,26,32,39,45,52,58,65,71,78,84,91,97
  DC.B   152,158,165,171,178,184,191,197,204,210,217,223,230,236,243,249
  DC.B   0,6,13,20,27,33,40,47,54,60,67,74,81,87,94,101
  DC.B   148,154,161,168,175,181,188,195,202,208,215,222,229,235,242,249
  DC.B   0,7,14,21,28,35,42,49,56,63,70,77,84,91,98,105
  DC.B   144,151,158,165,172,179,186,193,200,207,214,221,228,235,242,249
  DC.B   0,7,14,21,29,36,43,50,58,65,72,79,87,94,101,108
  DC.B   140,147,154,161,169,176,183,190,198,205,212,219,227,234,241,248
  DC.B   0,7,15,22,30,37,45,52,60,67,75,82,90,97,105,112
  DC.B   136,143,151,158,166,173,181,188,196,203,211,218,226,233,241,248
  DC.B   0,7,15,23,31,38,46,54,62,69,77,85,93,100,108,116
  DC.B   132,139,147,155,163,170,178,186,194,201,209,217,225,232,240,248
*

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                               ;
*   FORMANT DATA FOR 11.1 KHZ   ;
*   SAMPLING RATE MALE VOICE    ;
*                               ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*
F1T  DC.B  0,59,59,0,0,0,0,0,0,25,41,49,61,65,53,52
  DC.B  43,53,41,41,32,0,44,45,37,43,37,63,53,51,37,71
  DC.B  56,52,43,32,29,27,28,32,21,24,44,44,44,0,18,0
  DC.B  29,28,31,29,21,21,16,18,32,25,0,24,21,0,0,0
  DC.B  0,0,18,18,18,18,18,18,18,26,18,18,18,18,16,16
  DC.B  16,37,37,37,37,37,37,28,41,28,28,37,28,28,28,28
  DC.B  22,24,25,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
F2T  DC.B  0,110,110,0,0,0,0,0,0,203,164,170,149,106,116,81
  DC.B  104,116,164,121,134,0,88,122,83,166,205,125,179,77,176,127
  DC.B  82,102,79,116,83,56,97,83,46,208,102,148,203,0,166,0
  DC.B  129,170,102,129,112,169,110,124,166,166,0,166,168,0,0,0
  DC.B  0,0,102,102,102,166,166,166,201,201,201,176,176,176,134,133
  DC.B  134,102,102,102,166,166,166,201,201,201,176,176,176,155,155,153
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
F3T  DC.B  0,110,110,0,0,0,0,0,0,138,116,115,109,104,107,112
  DC.B  105,107,116,74,110,0,116,78,129,116,125,107,123,117,115,123
  DC.B  104,110,114,104,99,99,64,133,92,139,0,120,126,0,0,0
  DC.B  117,126,0,117,120,116,106,106,130,130,0,130,116,0,0,0
  DC.B  0,0,99,99,0,120,120,120,132,132,132,102,102,102,102,101
  DC.B  102,99,99,0,120,120,120,110,110,110,102,102,102,92,92,91
  DC.B  110,131,110,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

AMP1T  DC.B  0,0,0,0,0,0,0,0,0,25,28,27,0025,27,27,26 ;AE 1,2,3 down -1
  DC.B  28,27,28,27,30,0,26,29,27,28,29,26,29,27,29,27
  DC.B  30,27,28,27,28,19,25,27,19,28,27,27,27,0,7,0
  DC.B  00,00,00,00,9,9,9,9,0,00,00,9,17,0,0,0
  DC.B  0,0,9,9,0,9,9,0,6,9,9,6,9,9,6,9
  DC.B  0,0,18,18,0,18,18,0,8,17,0,8,17,0,8,17
  DC.B  8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
AMP2T  DC.B  0,0,0,0,0,0,0,0,0,9,11,12,0016,19,14,18
  DC.B  11,14,13,12,9,0,19,15,18,13,14,19,14,18,14,19
  DC.B  11,18,18,7,10,10,16,9,10,8,10,6,5,0,0,0
  DC.B  00,00,00,00,0,1,1,0,0,00,00,0,1,0,0,0
  DC.B  0,0,0,6,0,0,6,0,0,6,0,0,6,0,0,6
  DC.B  0,0,1,1,0,1,1,0,11,10,0,14,10,0,14,10
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
AMP3T  DC.B  0,0,0,0,0,0,0,0,0,7,8,10,0011,5,5,1
  DC.B  3,5,10,9,0,0,0,10,0,12,11,5,11,5,11,5
  DC.B  1,3,1,3,0,0,14,4,0,7,2,1,2,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,3,0,0,3,0,0,3,0,0,3,0,0,3
  DC.B  0,0,0,0,0,0,0,0,2,0,0,2,0,0,2,0
  DC.B  2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
IHNDUR  DC.B  0,2,2,36,24,0,0,0,0,19,18,18,25,24,17,29
  DC.B  19,14,14,22,22,25,22,11,11,23,0,29,0,34,0,31
  DC.B  0,26,0,22,0,12,10,10,10,10,10,8,10,0,4,10
  DC.B  15,15,14,13,8,8,9,6,10,8,5,8,6,10,10,10
  DC.B  10,12,10,1,1,8,1,1,8,1,1,8,1,1,8,1
  DC.B  1,10,2,4,8,2,5,10,1,5,10,1,5,10,1,5
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
MINDUR  DC.B  0,2,2,36,24,0,0,0,0,6,6,7,7,10,6,10
  DC.B  6,5,5,7,7,25,8,8,8,8,0,11,0,13,0,12
  DC.B  0,8,0,7,0,7,4,5,7,5,7,6,6,0,2,8
  DC.B  6,6,7,5,5,5,6,4,7,6,2,6,5,2,2,2
  DC.B  2,5,6,1,1,5,1,1,6,1,1,6,1,1,6,1
  DC.B  1,6,1,2,5,1,3,6,1,2,6,1,2,6,1,2
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
TEXT  DC.B  0,5,5,2,2,0,0,0,0,5,5,5,5,5,5,5
  DC.B  5,5,5,5,5,3,5,5,3,5,5,5,5,5,5,5
  DC.B  5,5,6,5,6,3,3,2,3,3,3,5,6,0,2,2
  DC.B  3,4,3,3,3,3,2,2,3,4,4,4,3,3,3,3
  DC.B  3,3,2,0,3,4,0,4,4,0,4,4,0,4,4,0
  DC.B  4,2,3,3,3,4,4,4,5,5,4,5,5,4,5,5
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
TINT   DC.B  0,2,2,2,2,0,0,0,0,5,5,5,5,5,5,5
  DC.B  5,5,5,5,5,3,5,5,3,5,5,5,5,5,5,5
  DC.B  5,5,6,5,6,3,3,0,3,3,2,0,0,0,0,1
  DC.B  0,0,0,0,1,1,2,0,0,0,0,0,1,0,0,0
  DC.B  0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FFT  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,228,0,0,0,0,0,0,0,0,0,0
  DC.B  12,26,38,37,134,150,164,164,0,26,3,0,154,52,69,85
  DC.B  101,119,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,36,4,0,5,2,0,60,6,0,111,5,0,111,6
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
RANK  DC.B  0,31,31,31,31,0,0,0,0,2,2,2,2,2,2,2
  DC.B  2,2,2,2,2,3,2,3,3,2,5,2,5,2,5,2
  DC.B  5,4,5,4,5,11,10,9,8,8,8,8,8,0,23,31
  DC.B  18,18,18,18,20,20,20,20,23,26,23,26,27,30,30,30
  DC.B  30,30,26,29,26,26,29,26,26,29,26,26,29,26,26,29
  DC.B  26,23,29,30,23,29,30,23,29,30,23,29,30,23,29,30
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PCT  DC.B  0,16,16,16,16,0,0,0,0,16,16,16,16,16,16,16 ; . & , were 32
  DC.B  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16
  DC.B  16,16,16,16,16,16,16,16,16,16,16,24,27,0,24,16
  DC.B  24,27,16,24,24,27,16,24,27,27,16,27,27,32,32,32
  DC.B  32,32,16,32,16,24,32,24,27,32,27,27,32,27,27,32
  DC.B  27,16,16,16,24,32,24,27,32,27,27,11,11,27,11,11
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  'COPYRIGHT 1984 MARK BARTON & JOSEPH KATZ'
  CNOP  0,2
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                       ;
*  FRICATIVE DATA  --  PACKED 4-BIT     ;
*  SIGNED.  ORDER IS LO HI NIBBLE       ;
*                                       ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*
*BEGIN "S"
FRICS  DC.B  32,0,241,32,14,242,47,243,253,33,3,237,32,18,223,1
  DC.B  78,210,237,67,224,29,17,242,15,30,20,222,1,33,15,238
  DC.B  35,224,13,36,235,21,253,16,35,204,83,223,47,243,60,210
  DC.B  18,44,244,29,15,243,255,16,63,15,194,33,14,0,0,255
  DC.B  52,218,52,16,188,84,223,33,254,64,209,1,63,209,61,243
  DC.B  31,226,30,1,32,223,33,0,242,28,3,16,222,65,4,235
  DC.B  33,19,191,95,242,224,45,34,193,14,80,194,254,34,32,192
  DC.B  46,52,174,63,3,29,225,16,34,221,50,1,237,36,15,223
  DC.B  34,47,192,50,1,13,19,254,1,0,0,2,13,3,16,12
  DC.B  5,253,18,17,254,16,241,17,13,3,47,208,66,222,49,239
  DC.B  16,1,225,79,240,225,46,244,14,30,53,219,32,212,61,211
  DC.B  45,51,159,111,243,253,63,227,17,205,99,225,12,49,195,29
  DC.B  32,2,239,254,69,189,47,34,225,238,66,242,250,21,46,207
  DC.B  66,209,44,18,226,13,35,0,253,34,242,14,16,31,211,28
  DC.B  50,161,76,51,190,63,3,14,255,0,5,251,33,19,220,242
  DC.B  48,225,255,64,209,255,33,241,15,15,50,208,253,85,222,27
  DC.B  23,238,46,1,210,63,13,242,241,255,65,222,17,30,209,18
  DC.B  12,51,253,225,33,0,0,31,241,241,15,48,210,29,36,206
  DC.B  79,244,10,3,1,255,62,243,14,224,50,240,12,51,207,19
  DC.B  14,47,227,30,240,17,225,29,18,208,14,36,28,243,13,36
  DC.B  208,45,49,210,254,49,225,45,242,31,0,208,95,226,222,50
  DC.B  17,236,243,48,223,16,18,0,238,35,15,254,48,227,15,30
  DC.B  3,207,64,240,242,15,18,31,239,3,31,30,1,241,0,15
  DC.B  17,241,14,34,207,50,14,17,240,0,2,46,208,48,243,205
  DC.B  64,228,11,33,1,224,46,4,15,15,35,190,66,224,31,1
  DC.B  240,1,62,255,242,240,48,16,207,34,32,222,2,33,238,63
  DC.B  210,241,110,176,30,21,220,64,227,30,240,33,224,32,241,15
  DC.B  18,254,2,16,225,32,1,0,30,2,1,14,17,16,240,13
  DC.B  21,224,30,16,244,238,95,227,238,32,1,239,33,31,241,239
  DC.B  50,254,255,34,240,254,34,241,255,47,1,255,47,243,255,17
* END "S", BEGIN "SH"
  DC.B  33,17,241,253,16,67,242,220,254,67,19,223,254,49,1,240
  DC.B  0,16,1,16,0,206,47,52,2,222,237,66,18,241,223,252
  DC.B  67,36,223,238,32,0,17,17,223,30,18,18,239,254,16,1
  DC.B  33,241,239,30,17,51,208,255,47,242,46,20,239,254,50,19
  DC.B  222,219,98,36,242,204,237,81,85,193,203,252,100,38,206,202
  DC.B  49,67,2,239,253,0,1,33,0,2,222,13,83,19,208,203
  DC.B  30,100,4,205,253,0,65,20,239,253,18,0,32,242,0,31
  DC.B  1,0,0,0,0,17,33,226,220,63,34,243,255,254,65,2
  DC.B  18,189,14,81,38,223,186,63,119,228,154,11,84,70,190,203
  DC.B  48,85,226,220,31,67,20,189,12,67,52,208,202,33,50,19
  DC.B  207,13,0,50,19,238,238,16,50,225,15,16,17,240,0,16
  DC.B  240,33,239,15,50,18,190,252,99,5,222,219,66,68,208,206
  DC.B  252,81,54,241,171,252,66,86,225,170,14,83,52,208,236,16
  DC.B  34,1,255,15,50,241,254,15,17,34,239,16,0,14,33,2
  DC.B  1,254,240,33,18,240,238,31,33,18,239,31,18,255,0,0
  DC.B  32,1,239,15,17,17,242,221,30,83,20,239,187,28,102,53
  DC.B  190,187,62,70,2,189,28,52,18,241,204,30,84,36,206,220
  DC.B  48,69,255,223,30,49,18,223,12,50,52,239,221,14,66,36
  DC.B  223,204,49,67,2,190,13,33,35,241,255,253,50,18,255,33
  DC.B  208,29,52,17,223,236,49,35,241,254,222,47,84,227,221,253
  DC.B  49,36,255,239,31,33,35,255,222,47,35,34,224,222,14,50
  DC.B  2,0,31,242,221,63,51,3,220,15,33,51,242,238,237,48
  DC.B  36,240,238,0,31,49,243,15,237,18,17,16,224,0,15,17
  DC.B  0,0,32,225,237,16,51,17,241,205,46,51,53,222,220,49
  DC.B  18,255,31,1,17,238,255,33,49,225,31,240,0,33,240,15
  DC.B  1,0,16,0,0,240,32,240,16,17,1,221,47,35,1,0
  DC.B  239,15,50,242,238,0,33,18,238,15,16,34,1,223,13,33
  DC.B  19,255,254,34,17,241,238,32,34,241,221,47,68,18,190,253
  DC.B  65,37,208,220,47,84,226,221,253,66,20,238,222,63,51,243
  DC.B  221,13,49,20,222,255,32,2,0,14,242,32,1,239,254,33
* END "SH", BEGIN "F,TH"
  DC.B  35,241,254,17,31,242,239,46,0,241,1,31,13,3,34,16
  DC.B  242,15,17,0,240,0,30,1,1,239,14,241,17,18,15,17
  DC.B  0,17,255,30,19,254,1,16,0,241,45,33,224,0,32,224
  DC.B  0,255,15,17,13,2,0,46,241,240,31,0,1,33,208,16
  DC.B  0,16,2,254,64,243,240,16,239,48,225,17,34,255,32,1
  DC.B  1,240,222,34,15,255,240,15,1,16,0,241,16,240,1,1
  DC.B  238,0,31,34,1,255,1,0,47,241,15,16,1,16,242,14
  DC.B  34,238,0,16,17,223,253,49,2,238,17,16,224,17,15,31
  DC.B  33,2,0,240,31,2,14,0,226,47,1,238,0,240,31,14
  DC.B  241,19,2,29,2,240,32,241,17,0,15,33,224,46,241,238
  DC.B  17,0,240,253,31,19,1,17,240,17,16,0,0,1,240,31
  DC.B  31,2,33,14,3,239,31,15,3,31,47,224,241,16,17,240
  DC.B  15,34,239,32,1,240,17,1,237,31,34,243,14,255,17,238
  DC.B  31,4,31,255,224,15,15,0,49,240,14,0,17,2,254,50
  DC.B  33,240,239,32,225,16,31,2,240,239,46,1,240,15,241,19
  DC.B  31,223,31,18,255,15,31,4,47,239,0,0,0,0,33,2
  DC.B  255,15,17,16,243,32,255,1,3,31,16,3,1,15,254,32
  DC.B  224,224,16,17,0,255,16,0,33,2,47,19,223,30,0,17
  DC.B  0,16,33,239,15,2,47,255,2,240,253,50,2,0,240,31
  DC.B  16,1,2,14,1,240,16,0,240,1,34,240,14,14,2,47
  DC.B  240,0,17,14,240,18,32,0,241,255,48,224,47,241,253,17
  DC.B  16,31,2,16,18,254,32,1,241,33,34,222,31,2,1,240
  DC.B  30,49,226,224,31,31,19,225,43,242,15,1,0,31,239,16
  DC.B  17,0,0,47,240,17,240,33,16,225,255,47,243,1,30,2
  DC.B  32,240,225,32,240,32,14,17,241,255,16,209,30,17,63,210
  DC.B  15,31,17,16,241,17,239,46,33,17,2,1,255,47,18,2
  DC.B  240,15,1,255,16,18,0,0,14,17,193,63,242,31,242,14
  DC.B  16,17,255,223,49,17,240,255,17,17,239,33,15,16,241,16
  DC.B  241,224,29,2,33,15,1,17,224,240,16,239,18,31,241,0
  DC.B  1,31,240,2,254,17,239,63,1,254,1,16,34,239,255,32
* END "F,TH", BEGIN "/H"
  DC.B  15,16,240,32,241,15,18,255,16,1,33,240,0,1,15,17
  DC.B  224,31,17,239,16,17,255,17,240,255,17,16,1,240,31,34
  DC.B  224,31,18,239,47,18,255,15,0,17,241,255,15,33,240,255
  DC.B  16,17,1,238,32,18,255,240,237,66,242,221,32,2,1,255
  DC.B  0,18,240,255,33,18,255,15,34,241,15,0,1,16,16,242
  DC.B  237,65,243,220,47,18,1,239,14,34,2,238,15,18,0,0
  DC.B  0,0,0,0,0,16,224,31,34,222,31,19,255,1,222,48
  DC.B  3,237,16,15,33,210,252,67,226,253,16,17,18,237,32,2
  DC.B  15,0,255,49,241,254,17,240,32,241,254,35,241,254,16,18
  DC.B  17,222,46,52,239,254,1,32,242,222,31,18,224,15,0,0
  DC.B  17,255,15,16,1,240,255,17,18,254,0,0,17,240,254,17
  DC.B  0,0,1,15,18,223,31,18,15,240,0,17,240,15,33,1
  DC.B  255,0,33,241,15,16,18,255,16,240,32,1,255,17,17,16
  DC.B  239,16,34,223,15,18,15,240,16,1,255,16,0,240,255,32
  DC.B  1,224,14,0,18,255,15,0,16,1,238,47,3,0,239,31
  DC.B  52,239,254,17,33,241,237,33,2,254,1,0,1,255,15,33
  DC.B  241,238,15,34,241,237,49,2,255,240,16,34,223,14,18,15
  DC.B  1,255,32,1,255,17,0,33,240,14,35,239,31,2,240,16
  DC.B  0,0,0,0,240,255,255,255,255,15,0,0,0,0,240,255
  DC.B  255,1,0,0,32,241,238,46,18,240,0,0,33,225,254,48
  DC.B  2,0,239,47,36,223,14,18,0,1,255,16,18,239,31,34
  DC.B  240,31,1,16,18,239,31,1,0,240,254,33,241,254,16,1
  DC.B  255,15,17,1,255,31,18,239,30,2,16,240,254,17,240,32
  DC.B  241,254,33,240,31,2,238,49,241,254,33,239,32,224,30,18
  DC.B  224,31,1,0,1,255,0,0,0,0,0,32,242,254,17,241
  DC.B  31,17,255,33,241,14,17,255,255,1,17,240,254,50,240,15
  DC.B  0,240,33,241,254,17,1,240,255,255,255,255,1,240,15,17
  DC.B  1,255,17,1,31,240,16,1,255,1,0,15,17,240,15,17
  DC.B  1,0,31,241,0,17,0,255,33,1,255,16,34,224,253,34
  DC.B  1,254,16,240,32,242,253,33,239,32,2,253,50,225,252,34
* END "/H", BEGIN "/M"
  DC.B  17,17,17,17,1,255,222,254,16,34,17,0,255,15,17,33
  DC.B  18,0,0,255,238,238,254,16,34,18,0,16,17,17,0,255
  DC.B  255,0,240,255,255,16,17,1,0,16,50,18,240,222,237,16
  DC.B  1,0,0,0,1,0,1,16,17,17,1,240,222,237,15,1
  DC.B  16,17,33,17,0,0,255,17,1,255,239,254,0,33,18,17
  DC.B  17,0,255,239,254,0,17,18,0,0,0,16,1,240,15,0
  DC.B  1,0,0,240,15,0,0,0,0,17,33,18,0,255,15,0
  DC.B  16,17,1,255,238,238,15,50,51,2,240,238,254,15,33,34
  DC.B  1,240,238,15,16,17,17,0,239,238,254,255,15,17,50,51
  DC.B  18,239,238,15,16,1,255,255,15,16,1,0,1,0,0,16
  DC.B  50,35,1,223,221,254,16,34,18,240,222,237,15,66,68,18
  DC.B  224,221,15,17,17,240,238,222,254,33,34,51,18,240,238,254
  DC.B  0,17,17,240,255,255,0,0,0,0,17,34,17,1,255,0
  DC.B  255,255,255,15,0,0,1,0,0,15,0,0,17,17,0,239
  DC.B  15,33,35,1,240,238,254,255,16,33,34,2,239,238,15,33
  DC.B  35,18,240,255,239,254,15,16,33,18,1,239,254,33,34,18
  DC.B  239,221,254,16,18,1,240,238,31,51,51,18,240,239,238,238
  DC.B  15,33,34,1,239,221,254,49,68,52,2,239,221,221,15,17
  DC.B  34,2,239,222,254,33,51,51,18,240,239,238,254,15,17,17
  DC.B  240,238,15,16,33,18,240,255,15,17,17,17,240,255,255,15
  DC.B  17,1,0,239,14,0,33,18,17,0,255,15,255,16,17,17
  DC.B  0,255,255,255,16,17,17,240,255,15,17,34,0,255,0,0
  DC.B  0,0,0,16,1,240,255,16,17,1,240,255,16,17,1,255
  DC.B  15,0,16,17,17,0,0,240,255,255,0,16,0,255,255,16
  DC.B  34,34,18,239,238,238,14,33,34,35,1,238,238,31,34,34
  DC.B  241,238,254,0,33,1,16,0,16,17,1,240,239,255,16,17
  DC.B  1,0,15,0,0,17,17,17,0,15,255,255,15,0,17,1
  DC.B  0,0,0,17,1,255,0,0,17,17,240,255,255,255,15,17
  DC.B  33,17,1,0,0,16,1,240,255,15,0,0,255,15,16,17
  DC.B  1,0,0,17,1,255,239,254,0,17,17,240,15,15,16,34
* END "/M", BEGIN "/B"
  DC.B  221,15,17,0,15,0,16,50,35,1,15,17,1,222,238,237
  DC.B  15,0,240,16,50,19,1,0,0,16,1,239,254,16,18,239
  DC.B  255,33,18,0,0,0,16,240,239,15,0,0,0,17,18,0
  DC.B  0,0,0,240,222,14,33,18,0,0,0,17,240,255,255,16
  DC.B  1,240,16,18,1,255,15,0,0,255,15,33,18,240,15,50
  DC.B  35,241,254,255,0,240,239,238,17,33,240,15,33,51,1,255
  DC.B  254,0,255,255,0,0,17,1,255,16,18,224,254,33,34,240
  DC.B  254,15,33,2,222,14,35,240,15,17,34,18,240,222,254,17
  DC.B  240,255,31,34,35,240,15,49,2,222,253,33,35,240,15,240
  DC.B  239,222,221,15,50,51,35,18,17,34,224,204,237,15,240,254
  DC.B  48,52,18,1,0,240,255,254,238,255,33,34,0,16,34,1
  DC.B  255,254,16,1,239,254,16,1,255,15,0,33,34,1,255,32
  DC.B  34,241,254,16,17,0,239,238,15,17,0,15,33,51,19,240
  DC.B  255,240,255,238,255,31,1,17,17,0,16,0,255,255,255,0
  DC.B  17,240,0,0,16,1,239,14,33,17,240,15,16,17,240,254
  DC.B  16,17,223,253,49,52,241,15,17,17,240,205,237,32,19,239
  DC.B  254,48,35,240,254,32,18,240,238,14,33,1,240,15,16,35
  DC.B  240,255,15,0,1,239,254,16,17,0,240,15,1,16,1,0
  DC.B  16,34,240,255,238,15,33,224,237,32,35,1,0,1,255,16
  DC.B  34,224,253,17,1,255,255,15,0,240,15,16,34,18,0,0
  DC.B  17,240,255,222,254,33,18,240,31,50,35,241,221,238,32,18
  DC.B  224,254,32,19,240,255,15,17,18,255,14,17,1,239,254,15
  DC.B  16,34,241,255,32,18,255,15,0,16,0,239,14,33,18,239
  DC.B  15,33,2,0,224,237,48,19,222,254,33,18,0,255,16,34
  DC.B  34,240,238,0,239,254,15,240,15,17,17,34,18,0,255,15
  DC.B  17,255,222,255,255,0,16,1,31,67,35,241,255,255,0,240
  DC.B  222,237,0,240,254,33,35,34,50,19,240,0,239,221,254,239
  DC.B  238,16,17,17,50,51,17,17,17,239,221,254,238,14,17,241
  DC.B  31,50,35,18,1,0,0,255,238,238,0,240,254,49,51,2
  DC.B  0,17,0,255,238,15,33,1,0,16,17,0,0,0,255,255
* END "/B", BEGIN "/R"
  DC.B  0,16,17,1,0,0,0,0,16,1,17,17,17,17,1,240
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,17
  DC.B  17,0,0,255,15,16,17,17,18,17,1,240,255,255,15,16
  DC.B  17,17,17,0,255,255,255,0,0,0,240,255,240,255,255,0
  DC.B  255,0,255,255,16,17,1,240,255,15,240,15,0,16,17,17
  DC.B  16,17,0,0,0,0,16,1,0,17,17,17,17,0,255,255
  DC.B  255,15,16,17,17,17,0,240,255,255,255,255,0,17,17,0
  DC.B  0,255,238,255,15,0,0,17,17,17,0,240,255,255,255,15
  DC.B  16,34,34,34,18,17,0,0,15,0,17,17,17,17,17,0
  DC.B  255,15,240,0,0,17,17,17,0,1,0,0,15,240,16,17
  DC.B  17,1,0,0,240,255,0,15,0,16,1,0,0,255,255,255
  DC.B  15,16,0,0,0,0,255,255,15,0,17,17,1,0,1,0
  DC.B  1,0,0,0,0,0,0,255,0,0,0,0,17,0,255,255
  DC.B  0,0,0,17,1,17,240,255,239,254,0,17,17,17,1,240
  DC.B  255,255,0,0,17,34,18,17,240,255,255,255,31,17,1,0
  DC.B  0,15,0,0,16,17,16,17,0,16,1,240,0,15,17,1
  DC.B  0,0,0,240,255,255,15,17,17,0,0,0,0,0,0,0
  DC.B  0,0,255,255,0,0,16,34,34,1,255,255,255,0,17,17
  DC.B  33,18,1,240,255,254,255,0,33,18,0,0,240,255,255,15
  DC.B  16,17,17,17,0,240,255,15,0,255,15,0,0,17,0,0
  DC.B  255,255,255,0,17,17,17,17,17,17,17,0,255,15,17,17
  DC.B  33,17,1,240,238,238,254,15,16,17,17,1,0,240,255,255
  DC.B  0,0,17,1,0,15,240,0,0,17,17,240,240,255,255,15
  DC.B  0,17,17,240,0,255,255,255,0,16,17,0,0,0,240,255
  DC.B  255,0,16,34,34,18,1,240,255,255,0,17,17,17,17,1
  DC.B  0,240,255,15,0,16,1,16,17,17,1,0,255,255,15,16
  DC.B  33,18,1,240,255,0,0,0,0,0,0,0,0,0,0,240
  DC.B  255,15,1,16,240,255,255,0,17,17,1,0,0,0,0,255
  DC.B  255,0,17,17,17,17,1,0,0,0,255,15,16,17,17,1
  DC.B  17,0,239,255,0,16,17,0,17,1,0,1,240,255,15,0
* END "/R", BEGIN "/C"
  DC.B  51,1,239,171,137,136,170,219,254,33,0,0,0,17,1,15
  DC.B  0,1,16,50,51,34,35,17,1,16,0,240,254,15,16,0
  DC.B  33,35,18,34,34,18,0,0,240,238,254,82,103,136,119,71
  DC.B  17,207,171,153,137,219,30,50,101,69,19,240,221,221,237,254
  DC.B  33,50,68,52,1,255,205,220,254,0,50,35,18,1,222,238
  DC.B  221,238,14,0,34,34,34,17,239,255,238,239,15,17,34,1
  DC.B  1,254,172,187,187,205,13,1,33,34,35,51,240,224,14,240
  DC.B  33,49,53,50,2,33,254,205,253,32,36,98,53,52,31,225
  DC.B  15,254,255,48,18,34,33,241,0,0,16,101,85,103,102,3
  DC.B  240,172,137,186,186,14,50,68,85,35,241,206,170,170,186,219
  DC.B  16,33,67,52,1,224,188,170,171,219,254,16,17,1,255,255
  DC.B  205,219,238,31,50,51,51,19,0,0,0,255,33,1,1,33
  DC.B  34,33,0,0,0,0,17,50,51,35,50,18,17,49,34,18
  DC.B  15,1,33,0,1,255,206,221,237,238,254,15,33,35,50,36
  DC.B  17,238,254,222,254,16,16,34,34,35,18,240,255,254,255,16
  DC.B  66,35,34,17,240,238,238,254,254,0,33,33,2,0,239,222
  DC.B  237,255,0,16,2,0,255,239,255,239,255,254,255,254,240,255
  DC.B  255,255,0,15,0,16,0,0,16,0,1,32,18,17,0,240
  DC.B  0,240,255,255,238,254,238,222,255,15,17,32,18,83,53,85
  DC.B  66,37,16,240,0,66,52,85,84,37,1,239,204,219,237,15
  DC.B  67,69,85,52,18,240,222,221,238,255,16,17,240,240,221,221
  DC.B  237,221,238,238,254,255,222,205,221,221,221,237,238,238,189,204
  DC.B  219,255,31,18,83,68,69,68,1,224,254,221,0,30,35,116
  DC.B  102,136,103,37,224,139,168,154,235,16,66,134,120,102,53,242
  DC.B  15,1,16,51,35,18,241,205,204,187,219,14,0,50,50,1
  DC.B  0,238,222,237,254,49,67,51,51,1,222,188,187,203,253,16
  DC.B  50,34,34,1,239,205,221,237,255,16,17,17,0,255,223,205
  DC.B  237,16,65,36,83,19,35,254,224,254,238,0,16,1,33,34
  DC.B  2,17,255,255,32,17,51,50,19,34,16,1,15,255,17,33
  DC.B  35,50,34,2,255,255,239,221,222,237,238,255,254,255,239,254
* END FRICS
SIN  DC.B  0,1,3,4,6,7,8,10,11,12,13,13,14,15,15,15  ; 0db
  DC.B  15,15,15,15,14,13,13,12,11,10,8,7,6,4,3,1
  DC.B  0,30,28,27,25,24,23,21,20,19,18,18,17,16,16,16
  DC.B  16,16,16,16,17,18,18,19,20,21,23,24,25,27,28,30
  DC.B  0,1,2,3,4,5,6,7,8,9,10,11,11,12,12,12  ; -2db
  DC.B  12,12,12,12,11,11,10,9,8,7,6,5,4,3,2,1
  DC.B  0,30,29,28,27,26,25,24,23,22,21,20,20,19,19,19
  DC.B  19,19,19,19,20,20,21,22,23,24,25,26,27,28,29,30
  DC.B  0,0,1,2,3,4,5,6,7,7,8,8,9,9,9,10  ; -4db
  DC.B  10,10,9,9,9,8,8,7,7,6,5,4,3,2,1,0
  DC.B  0,31,30,29,28,27,26,25,24,24,23,23,22,22,22,21
  DC.B  21,21,22,22,22,23,23,24,24,25,26,27,28,29,30,31
  DC.B  0,0,1,2,3,3,4,5,5,6,6,6,7,7,7,7  ; -6db
  DC.B  7,7,7,7,7,6,6,6,5,5,4,3,3,2,1,0
  DC.B  0,31,30,29,28,28,27,26,26,25,25,25,24,24,24,24
  DC.B  24,24,24,24,24,25,25,25,26,26,27,28,28,29,30,31
  DC.B  0,0,1,1,2,3,3,3,4,4,5,5,5,6,6,6  ; -8db
  DC.B  6,6,6,6,5,5,5,4,4,3,3,3,2,1,1,0
  DC.B  0,31,30,30,29,28,28,28,27,27,26,26,26,25,25,25
  DC.B  25,25,25,25,26,26,26,27,27,28,28,28,29,30,30,31
  DC.B  0,0,0,1,1,2,2,3,3,3,4,4,4,4,4,4  ; -10db
  DC.B  5,4,4,4,4,4,4,3,3,3,2,2,1,1,0,0
  DC.B  0,31,31,30,30,29,29,28,28,28,27,27,27,27,27,27
  DC.B  26,27,27,27,27,27,27,28,28,28,29,29,30,30,31,31
  DC.B  0,0,0,1,1,1,2,2,2,3,3,3,3,3,3,3  ; -12db
  DC.B  3,3,3,3,3,3,3,3,2,2,2,1,1,1,0,0
  DC.B  0,31,31,30,30,30,29,29,29,28,28,28,28,28,28,28
  DC.B  28,28,28,28,28,28,28,28,29,29,29,30,30,30,31,31
  DC.B  0,0,0,0,1,1,1,2,2,2,2,2,2,3,3,3  ; -14db
  DC.B  3,3,3,3,2,2,2,2,2,2,1,1,1,0,0,0
  DC.B  0,31,31,31,30,30,30,29,29,29,29,29,29,28,28,28
  DC.B  28,28,28,28,29,29,29,29,29,29,30,30,30,31,31,31
  DC.B  0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,2  ; -16db
  DC.B  2,2,2,2,2,2,2,1,1,1,1,1,0,0,0,0
  DC.B  0,31,31,31,31,30,30,30,30,30,29,29,29,29,29,29
  DC.B  29,29,29,29,29,29,29,30,30,30,30,30,31,31,31,31
  DC.B  0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2  ; -18db
  DC.B  2,2,1,1,1,1,1,1,1,1,1,0,0,0,0,0
  DC.B  0,31,31,31,31,31,30,30,30,30,30,30,30,30,30,29
  DC.B  29,29,30,30,30,30,30,30,30,30,30,31,31,31,31,31
  DC.B  0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1  ; -20db
  DC.B  1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0
  DC.B  0,31,31,31,31,31,31,31,30,30,30,30,30,30,30,30
  DC.B  30,30,30,30,30,30,30,30,30,31,31,31,31,31,31,31
  DC.B  0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1  ; -22db
  DC.B  1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0
  DC.B  0,31,31,31,31,31,31,31,31,31,30,30,30,30,30,30
  DC.B  30,30,30,30,30,30,30,31,31,31,31,31,31,31,31,31
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  ; -24db
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31
  DC.B  31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  ; -26db
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,31,31,31,31,31,31,31,31,31,31,31,31,31,31
  DC.B  31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  ; -28db
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,31,31,31,31,31,31,31,31,31,31,31,31,31,31
  DC.B  31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  ; -30db
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,31,31,31,31,31,31,31,31,31,31,31,31,31,31
  DC.B  31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  ;
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  ;
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  ;
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0


*
*
***************************************************
*                                                 *
* FEMALE FORMANT TARGETS AT 11100HZ SAMPLING RATE *
*                                                 *
***************************************************
*
FEM1  DC.B  0,59,59,0,0,0,0,0,0,28,40,57,79,79,74,57
  DC.B  43,74,40,43,46,0,46,62,41,51,41,81,56,48,42,74
  DC.B  56,44,40,35,31,28,38,41,32,32,49,44,44,0,18,0
  DC.B  29,28,31,29,21,21,16,18,32,25,0,24,21,0,0,0
  DC.B  0,0,18,18,18,18,18,18,18,26,18,18,18,18,16,16
  DC.B  16,37,37,37,37,37,37,28,41,28,28,37,28,28,28,28
  DC.B  28,28,35,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FEM2  DC.B  0,110,110,0,0,0,0,0,0,253,212,194,189,120,157,104
  DC.B  107,157,212,145,171,0,92,135,102,217,253,129,195,89,184,154
  DC.B  98,136,95,96,86,83,117,83,46,240,152,148,236,0,0,0
  DC.B  129,170,102,129,112,169,110,124,166,166,0,166,168,0,0,0
  DC.B  0,0,102,102,102,148,148,148,201,201,201,176,176,176,155,155
  DC.B  129,102,102,102,148,148,148,201,201,201,176,176,176,155,155,155
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FEM3  DC.B  0,110,110,0,0,0,0,0,0,161,132,129,132,134,136,120
  DC.B  123,136,132,95,124,0,129,91,148,138,148,129,134,124,131,117
  DC.B  132,132,134,132,133,123,93,145,129,148,121,120,129,0,0,0
  DC.B  117,126,0,117,120,116,106,106,130,130,0,130,116,0,0,0
  DC.B  0,0,99,99,0,120,120,120,132,132,132,102,102,102,92,92
  DC.B  92,99,99,0,120,120,120,110,110,110,102,102,102,92,92,92
  DC.B  112,141,126,0,0,0,0,0,0,0,0,0,0,0,0,0
  DC.B  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

  END 

	TTL	'$Header: task.asm,v 32.1 86/01/22 00:25:02 sam Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: task.asm,v 32.1 86/01/22 00:25:02 sam Exp $
*
* $Locker:  $
*
* $Log:	task.asm,v $
* Revision 32.1  86/01/22  00:25:02  sam
* placed under source control
* 
*
**********************************************************************
               SECTION speech
_AbsExecBase	EQU	4
******* Included Files ***********************************************


	INCLUDE 'assembly.i'
	INCLUDE 'exec/types.i'
	INCLUDE 'exec/nodes.i'
	INCLUDE 'exec/lists.i'
	INCLUDE 'exec/strings.i'
	INCLUDE 'exec/initializers.i'
	INCLUDE 'exec/memory.i'
	INCLUDE 'exec/interrupts.i'
	INCLUDE 'exec/ports.i'
	INCLUDE 'exec/libraries.i'
	INCLUDE 'exec/devices.i'
	INCLUDE 'exec/io.i'
	INCLUDE 'exec/tasks.i'
	INCLUDE 'exec/resident.i'
	INCLUDE 'hardware/custom.i'

io_Size	EQU	IO_SIZE
        INCLUDE    'featequ.i'
        INCLUDE    'gloequs.i'
        INCLUDE    'devices/audio.i'
	INCLUDE    'narrator.i'
	INCLUDE    'private.i'



******* Imported Functions *******************************************


	EXTERN_SYS Signal
	EXTERN_SYS AllocSignal
	EXTERN_SYS Wait
	EXTERN_SYS GetMsg
	EXTERN_SYS FindTask



******* Exported Functions *******************************************

	XDEF	SDTaskStart
	XREF	PerformIO

*	XREF	_AbsExecBase



******* Device/Speech/Task **********************************
*
*   NAME

*
*   SYNOPSIS

*
*   FUNCTION
*
*
*   INPUTS

*
*
*   RESULTS
*
*
*   SEE ALSO
*
*
**********************************************************************
*
*
*   REGISTER USAGE
*
*
*   IMPLEMENTATION
*
*



SDTaskStart:
		MOVE.L	_AbsExecBase,A6
		MOVE.L	4(SP),A2		;Device Node
		MOVE.L	A2,A3			;Copy it
		LEA	ND_UNIT(A2),A2		;Get unit pointer


*		;------	Setup task signalling
		SUB.L	A1,A1			;Store pointer to TCB in msgport
		CALLSYS	FindTask
		MOVE.L	D0,MP_SIGTASK(A2)

		MOVEQ	#0,D2			;Allocate and store task signal bit
		MOVEQ	#-1,D0
		CALLSYS	AllocSignal
		BSET	D0,D2
		MOVE.B	D0,MP_SIGBIT(A2)

		MOVEQ	#-1,D0			;Allocate and store task start signal
		CALLSYS	AllocSignal
		BSET	D0,D2
		MOVE.L	D2,ND_SIGNALS(A3)

SDTst:
		BSR.S	ND_Per

SDTask_Wait:	
		MOVE.L	ND_SIGNALS(A3),D0
		CALLSYS	Wait
		BRA.S	SDTst

ND_Per:
		BTST	#UNITB_STOP,UNIT_FLAGS(A2)	;Device stopped?
		BNE.S	SDTask_End			;Yes, wait for next signal

		BSET 	#UNITB_ACTIVE,UNIT_FLAGS(A2) 	;Device busy?
		BNE.S	SDTask_End			;Yes, wait for next signal

*		BEQ.S	SDTask_Cont			;No, continue
*		MOVE.L	#$00020000,D0
*		MOVEQ	#0,D0
*		MOVE.B	ND_WAITSIG(A3),D1
*		BSET	D1,D0
*		CALLSYS	Wait

SDTask_Cont	MOVE.L	A2,A0
		CALLSYS	GetMsg
		TST.L	D0
		BEQ.S	SDTask_Clear

		MOVE.L	D0,A1				;Move IORB into A1
		CMP.W	#CMD_READ,IO_COMMAND(A1)	;Is this a Read?
		BEQ.S	SDTask_1			;Yes, don't save IORB in devNode
		MOVE.L	A1,ND_USERIORB(A3)		;Save in devNode
SDTask_1	BSET	#UNITB_INTASK,UNIT_FLAGS(A2)
		JSR	PerformIO 			;Go to Command interpreter???
		BRA.S	ND_Per

SDTask_Clear:
		BCLR	#UNITB_INTASK,UNIT_FLAGS(A2)	;Clear in task flag
		BCLR	#UNITB_ACTIVE,UNIT_FLAGS(A2)	;Clear driver active flag
SDTask_End:
		RTS

		END




	TTL	'$Header: synth.asm,v 36.0 88/03/01 15:02:04 kodiak Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: synth.asm,v 36.0 88/03/01 15:02:04 kodiak Exp $
*
* $Locker:  $
*
* $Log:	synth.asm,v $
*   Revision 36.0  88/03/01  15:02:04  kodiak
*   do not turn off blitter dma during synthesis
*   
*   Revision 35.0  88/02/23  16:11:33  kodiak
*   initial from V33.old
*   
* Revision 32.1  86/01/22  00:24:51  sam
* placed under source control
* 
*
**********************************************************************
           SECTION      speech
_AbsExecBase EQU 	4
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                        ;
*                 MAIN MODULE 'SYNTH'                    ;
*                                                        ;
* SYNTHESIZES VOCAL WAVEFORM IN REAL TIME FROM DATA THAT ;
*       IS CONTAINED IN THE COEFFICIENT BUFFER.          ;
*                                                        ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*
*           REGISTER USAGE (NOT TRUE)
*
* D0 PITCH,MICFRAME     D4 AMP3,AMP2
* D1 F1X,F2X            D5 SCRATCH
* D2 F0X,F3X            D6 SCRATCH
* D3 AMP2,AMP1          D7 OUTPUT
*
* A0 SIN TABLE          A4 FRICS
* A1 MULT TABLE         A5 VARIABLES
* A2 MOUTHS             A6 COEF. BUFFER
* A3 OUTPUT BUFFER+
*
* COEF. BUFFER = F1,F2,F3,AMP1,AMP2,AMP3,FF,F0...
*


*

	INCLUDE 'assembly.i'
	INCLUDE 'exec/types.i'
	INCLUDE 'exec/nodes.i'
	INCLUDE 'exec/lists.i'
	INCLUDE 'exec/strings.i'
	INCLUDE 'exec/initializers.i'
	INCLUDE 'exec/memory.i'
	INCLUDE 'exec/interrupts.i'
	INCLUDE 'exec/ports.i'
	INCLUDE 'exec/libraries.i'
	INCLUDE 'exec/devices.i'
	INCLUDE 'exec/io.i'
	INCLUDE 'exec/tasks.i'
	INCLUDE 'exec/resident.i'
	INCLUDE 'hardware/custom.i'
	INCLUDE 'hardware/dmabits.i'
	INCLUDE 'exec/execbase.i'
	INCLUDE 'exec/ables.i'
	INCLUDE 'exec/errors.i'

io_Size	EQU	IO_SIZE
        INCLUDE    'featequ.i'
        INCLUDE    'gloequs.i'
	INCLUDE	   'devices/audio.i'
	INCLUDE    'narrator.i'
	INCLUDE    'private.i'



*
        EXTERN_SYS AbortIO
        EXTERN_SYS DoIO
        EXTERN_SYS GetMsg
        EXTERN_SYS Disable
        EXTERN_SYS Enable
        EXTERN_SYS WaitIO
        EXTERN_SYS ReplyMsg

	EXTERN_DATA _intena

        XDEF       SYNTH,DMANodeName
        XREF       MULT,SIN,FRICS
	XREF	   _custom		;for blitter ops

UnitFlags       EQU     F0START
BUFFLEN		EQU	512
OUTBUFF2 	EQU	PHON+BUFFLEN


SYNTH:

*------- Compute addresses of fricatives

         LEA      FRICS,A4
         MOVE.L   A4,D0
         LEA      FRADDR(A5),A4
         MOVEQ    #7,D1           ;LOOP COUNT=8
SYNFFA   MOVE.L   D0,(A4)+        ;MOVE ADDR INTO TABLE
         ADD.L    #480,D0
         DBF      D1,SYNFFA	

	MOVE.L	_AbsExecBase,A6


*	;------	Cache the address of IO_FLAGS
	MOVE.L	USERIORB(A5),A2
	MOVE.L	IO_DEVICE(A2),A4
	LEA	ND_UNIT+UNIT_FLAGS(A4),A3
	MOVE.L	A3,UnitFlags(A5)


*	;------	Check to see if we've been aborted
*	;	CAUTION....A2, not A1 -> IORB.  Also,
*	;	other regs may not be correctly setup.
*	;	Check carefully if this code is put
*	;	back into action.
*	BTST	#IOB_ABORT,IO_FLAGS(A2)
*	BNE	SYABORTED


        MOVE.L    #3579000,D0      ;COLOR CLOCK
        DIVU      SampFreq(A5),D0  ;DIVIDE BY SAMPLING FREQ
        MOVE.W    D0,AudPer(A5)    ;SAVE AS PERIOD


	BSET	#IOB_FIRST,IO_FLAGS(A2)		;First time bit


*	;------	Stop all audio DMA channels.  This code was
*	;	originally in MultChan (qv) but was moved here
*	;	because on overflows the processing loop does
*	;	not contain the allocation and freeing of audio
*	;	channels.  This should cure the loss of stereo
*	;	sync when overflow occurs.
	LEA	ND_IORB3(A4),A1	
	MOVE.B	#ADIOF_NOWAIT+IOF_QUICK,IO_FLAGS(A1)
	MOVE.L	NDI_CHMASKS(A2),ioa_Data(A1)
	MOVE.W	NDI_NUMMASKS(A2),ioa_Length+2(A1)
	MOVE.W	#CMD_STOP,IO_COMMAND(A1)
	CALLSYS	DoIO


*	;------	Setup DMA IORBs
	MOVE.L	ND_AUDDMAIORB(A4),A1
	LEA	DMANodeName,A2
	MOVE.L	A2,IO+LN_NAME(A1)
	MOVE.L	ND_MSGPORT(A4),A3
	MOVE.L	A3,IO+MN_REPLYPORT(A1)
	MOVE.W	#CMD_WRITE,IO_COMMAND(A1)
*	MOVE.W	#BUFFLEN,ioa_Length(A1)		*!!!sam 7/12/85!!!
	MOVE.W	#BUFFLEN,ioa_Length+2(A1)	*!!!sam 7/12/85!!!
	MOVEQ	#0,D0
	MOVE.B	Volume(A5),D0
	MOVE.W	D0,ioa_Volume(A1)
	MOVE.W	#1,ioa_Cycles(A1)
	MOVE.W	AudPer(A5),ioa_Period(A1)
	LEA	OUTBUFF1(A5),A2
	MOVE.L	A2,ioa_Data(A1)
	MOVE.B	#ADIOF_PERVOL,IO_FLAGS(A1)

	MOVE.L	A1,A0
	LEA	ioa_Size(A1),A2
	MOVE.L	USERIORB(A5),A3
	MOVE.B	NDI_NUMCHAN(A3),D0
	ADD.W	D0,D0
	SUBQ.W	#1,D0
	BRA.S	SYN_CopyEnd

SYN_IORBCopy:
	MOVE.W	#(ioa_Size/2)-1,D1
	MOVE.L	A0,A1

SYN_CopyLoop:
	MOVE.W	(A1)+,(A2)+
	DBF	D1,SYN_CopyLoop

SYN_CopyEnd:
	DBF	D0,SYN_IORBCopy


*	;------	Set address of buffer in 2nd set
*	;	of IORBs

	MOVE.L	ND_AUDDMAIORB(A4),A1		;Point to 2nd set
	MOVEQ	#0,D0
	MOVE.B	NDI_NUMCHAN(A3),D0
	MOVE.W	D0,D1				;Save for DBF
	MULU	#ioa_Size,D0
	ADD.L	D0,A1
	LEA	ioa_Data(A1),A1			;Where to put bfr addr

	LEA	OUTBUFF2(A5),A2			;Buffer address
	SUBQ.W	#1,D1				;Number of IORBs

SYN_ALoop:
	MOVE.L	A2,(A1)
	LEA	ioa_Size(A1),A1			;Next IORB
	DBF	D1,SYN_ALoop
	

*	;------	Set the channel mask in the IORB

	MOVE.L	ND_AUDDMAIORB(A4),A1
	LEA	IO_UNIT+3(A1),A1
	MOVEQ	#1,D2

SYN_CM:
	MOVEQ	#3,D0
	MOVE.B	NDI_CHANMASK(A3),D1

SYN_CLoop:
	BTST	D0,D1
	BEQ.S	SYN_CDBF
	CLR.B	(A1)
	BSET	D0,(A1)
	LEA	ioa_Size(A1),A1
SYN_CDBF:
	DBF	D0,SYN_CLoop

	DBF	D2,SYN_CM

*	Here starts SYNTH

         LEA      SIN,A0
         LEA      MULT,A1
         MOVE.L   COEFPTR(A5),A6  ;POINT TO COEF BUFFER 
         MOVE.L   A5,-(SP)
         MOVEQ    #VARLEN-1,D0    ;CLEAR SYNTH VARIABLES
SYNINIT  CLR.W    (A5)+
         DBF      D0,SYNINIT
         MOVE.L   (SP)+,A5
         MOVE.W   #1,FRINC(A5)    ;INIT RECORDING DIRECTION+
         MOVE.W   #BUFFLEN/2,SAMPCNT(A5) ;INIT SAMP CT
         LEA      OUTBUFF1(A5),A3 ;USE FIRST BUFFER
         CLR.W    BUFFLAG(A5)     ; AND DON'T SWITCH YET
*
* COMPUTE SAMPLES/FRAME
*
	  MOVE.W   SampFreq(A5),D0  ;NORMALLY 22200
          MULU     #75,D0           ;FORCE RATE TO TRACK
          DIVU     RATE(A5),D0
          AND.L    #$FFFF,D0
          DIVU     #60,D0
          LSR.W    #1,D0            ;SPEED(A5) IS IN WORDS
          MOVE.W   D0,SPEED(A5)          
*
* INITIALIZE BANDWIDTH PARAMETER
*
	 CLR.W    BANWID(A5)
	 MOVE.W   #9,BANWID(A5)
	 CMP.W    #MALE,SEX(A5)
         BNE.S    SYNBWSET
         ADDQ.W   #2,BANWID(A5)   ;IF MALE, ADD 3
SYNBWSET MOVEQ    #0,D0           ;CLEAR EVAHBODY
         MOVE.L   D0,D1
         MOVE.L   D0,D2
         MOVE.L   D0,D3
         MOVE.L   D0,D4
         MOVE.L   D0,D5
         MOVE.L   D0,D6
         MOVE.L   D0,D7
         MOVE.B   (A6)+,F1INC+1(A5) ;GET PARMS FROM COEF
         BMI      SYNEXIT           ;BRANCH IF END (F1>127)
*
         TST.B    Mouth(A5)
         BEQ.S    SYNIFF
         MOVE.L   MOTHPTR(A5),A2    ;PT TO MOUTHS IF WE'RE MAKING THEM 

* Cache the state of the blitter and turn it off
*	KODIAK 2/23/88	This is not worth it for two reasons:
*	KODIAK 2/23/88	This code is neither disabled, forbid, nor running at
*	KODIAK 2/23/88	a particularly high priority, so there are lots of
*	KODIAK 2/23/88	other reasons that cycles may be lost than to the
*	KODIAK 2/23/88	blitter.  More importantly, the old chips do not
*	KODIAK 2/23/88	set BLTDONE in DMACONR when the blitter dma is off,
*	KODIAK 2/23/88	so WaitBlit is fooled into thinking blits are
*	KODIAK 2/23/88	immediately performed.  This would have to be upgraded
*	KODIAK 2/23/88	to include a dma test in too many places to make it
*	KODIAK 2/23/88	reasonable to do.
SYNIFF:
*	MOVE.L  A0,-(SP)			; KODIAK 2/23/88
*	LEA	_custom,A0			; KODIAK 2/23/88
*	MOVE.W	dmaconr(A0),MySig(A5)		; KODIAK 2/23/88
*	MOVE.W  #DMAF_BLITTER,dmacon(A0)	; KODIAK 2/23/88
*	MOVE.L  (SP)+,A0			; KODIAK 2/23/88
*
* INSTALL FIRST FRAME
*
	 MOVE.B   (A6)+,F2INC+1(A5)
         CLR.W    F3INC(A5)
         MOVE.B   (A6)+,F3INC+1(A5)
         ASL.W    F3INC(A5)       ;DOUBLE F3 FREQ
         ADDQ.L   #3,A6           ;SKIP AMPL PARMS
         MOVE.B   (A6)+,FRFLAG(A5) ;GET FRIC FLAG
         MOVE.B   (A6)+,D5
         MOVE.B   D5,PITCH(A5)
         MOVE.W   SPEED(A5),D0    ;RESET MICFRAME
         SWAP     D0              ;POSITION PITCH LO
         BRA      SYN0            ;PITCH SYNCHRONOUS ENTRY PT
*
* ALL DATA ARE IN REGISTERS.
*
SYN3     TST.B    FRFLAG(A5)  ;FRICATIVE?
         BNE      FRIC1       ;YES, BRANCH
SYN4     MOVEQ    #0,D7       ;NO, CLEAR OUTPUT  <<try removing this instr>>
         MOVE.W   D1,D5       ;F1X TO SCR
         LSR.W    #4,D5       ;JUSTIFY F1X
         MOVE.W   D3,D6       ;AMPL1 TO SCRATCH
         OR.B     0(A0,D5),D6 ;OVERLAY SIN F1
         MOVE.B   0(A1,D6),D7 ;GET PROD F1
         MOVE.L   D2,D5       ;F2X,F3X TO SCRATCH
         LSR.L    #4,D5       ;JUSTIFY F3X,F2X
         AND.W    #$0FFF,D5   ;REMOVE EXTRANEOUS BITS FROM F2X
         MOVE.L   D4,D6       ;AMP3,AMPL2 TO SCRATCH
         OR.B     0(A0,D5),D6 ;OVERLAY SIN F2
         ADD.B    0(A1,D6),D7 ;ADD PROD F2 TO OUTPUT
         SWAP     D5
         SWAP     D6
         OR.B     0(A0,D5),D6 ;OVERLAY SIN F3
         ADD.B    0(A1,D6),D7 ;ADD PROD F3 TO OUTPUT
*
* First output routine
*
	MOVE.B    D7,(A3)+
	MOVE.B    D7,(A3)+
	SUBQ.W    #1,SAMPCNT(A5)
	BNE       FRIC6
*
* Let's waste some time
*
*	MOVE.L    D0,-(SP)
*WASTE   MOVE.W    #$1BE5,D0
*WASTE1  NOP
*	DBF       D0,WASTE1
*	MOVE.L    (SP)+,D0
*
	MOVE.W    #BUFFLEN/2,SAMPCNT(A5)  ;restore sample count
	SUB.L     #BUFFLEN,A3		  ;pt back to beginning of buffer
	MOVEM.L   A0/A1/A2/A4/A6/D0/D1/D2,-(SP)
	MOVE.L	USERIORB(A5),A3
	MOVE.L	IO_DEVICE(A3),A4
	MOVE.L	_AbsExecBase,A6
	TST.B     Mouth(A5)             ;making mouths?
	BEQ.S     SYNOUT1		;no branch
	BSR	  DoMouth
SYNOUT1	BSR	  SYN_Write

	MOVEM.L	(SP)+,A0/A1/A2/A4/A6/D0/D1/D2
	MOVE.L	USERIORB(A5),A3			;Abort request?
	BTST	#IOB_ABORT,IO_FLAGS(A3)
	BNE	SYN_AbortIt			;    yes


	NOT.W     BUFFLAG(A5)           ;switch buffers
        BNE.S     SYNSW1
	LEA       OUTBUFF1(A5),A3       ;choose buffer 1
	BRA.S     FRIC6
SYNSW1	LEA       OUTBUFF2(A5),A3       ;choose buffer 2     
*
* INCREMENT POINTERS
*
FRIC6    MOVE.L   #$03FF03FF,D7 ;FOR MODULO ARITH
         ADD.W    F1INC(A5),D1
         SWAP     D2
         ADD.L    F2INC(A5),D2
         SWAP     D2
         AND.W    D7,D1       ;MOD 64 + 4 BIT FRACTION
         AND.L    D7,D2
         SUBQ.W   #1,BW(A5)   ;DECR BANDWIDTH COUNT
         BNE.S    SYN8
         ADD.L    #64,A0      ;USE NEXT SIN TABLE (-2db)
         MOVE.W   BANWID(A5),BW(A5) ;RESTORE BW COUNTER
SYN8     SUBQ.W   #1,D0       ;DECR MICFRAME
         BPL.S    SYN1        ;BRANCH IF SAME FRAME
* FRAME UPDATE
SYN5     MOVE.B   (A6)+,F1INC+1(A5) ;MOVE PARMS FROM COEF
         BMI      SYNEXIT     ;BRANCH IF END
         MOVE.B   (A6)+,F2INC+1(A5)
         CLR.W    F3INC(A5)
         MOVE.B   (A6)+,F3INC+1(A5)
         ASL.W    F3INC(A5)      ;DOUBLE F3 FREQ
*         MOVE.B   (A6)+,AMP1(A5) ;AMP1 TO HOLDING LOC
*         MOVE.B   (A6)+,AMP2(A5) ;AMP2
*         MOVE.B   (A6)+,AMP3(A5) ;AMP3
         ADDQ.L   #3,A6           ;SKIP AMPL PARMS
         MOVE.B   (A6)+,FRFLAG(A5) ;GET FRIC FLAG
         BLE.S    SYN7A        ;BRANCH IF NOT AN UNVOICED FRIC
         CLR.B    4(A6)        ;CLEAR AMPLS OF FOLLOWING FRAME
         CLR.W    5(A6)
         CLR.B    -4(A6)       ;AND CURRENT FRAME
         CLR.W    -3(A6)       ; ( KLUDGE TO STOP CLAVE' POPPING )
SYN7A    TST.B    FRFLAG(A5)   ;FRICATIVE?
         BEQ.S    SYN7         ;NO, BRANCH
         CLR.W    D5
         MOVE.B   FRFLAG(A5),D5 ;YES, COMPUTE FRIC ADDR
         BTST     #7,D5       ;VFRIC?
         BEQ.S    FRIC5       ;NO, BRANCH
         BSET     #31,D6      ;YES, USE AS VFRIC FLAG
         BRA.S    FRIC5A      ;KEEP AMPL1
FRIC5    MOVEQ    #0,D3       ;CLEAR FORMANT AMPL1
FRIC5A   MOVE.B   D5,D6
         AND.W    #$F,D6      ;D6 = FRIC AMPL
         ASL.W    #5,D6       ;JUSTIFY AMPL
         LSR.B    #2,D5       ;JUSTIFY I.D. TO ID*4
         AND.B    #$1C,D5     ;REMOVE VFRIC & AMPL BITS
         ADD.W    #FRADDR,D5
         MOVE.L   0(A5,D5),A4 ;A4=CORRECT FRIC ADDR
SYN7	 ADDQ.L   #1,A2       ;BUMP MOUTH POINTER
         MOVE.B   (A6)+,D5
         MOVE.B   D5,PITCH(A5)
         MOVE.W   SPEED(A5),D0 ;RESET MICFRAME

SYN1     SWAP     D0          ;POSITION PITCH LO
         SUBQ.W   #1,D0       ;DECR PITCH
         BPL.S    SYN2        ;BRANCH IF SAME PITCH PULSE
SYN0     MOVEQ    #0,D1       ;RESET F1X
         MOVEQ    #0,D2       ;RESET F2X,F3X
         LEA      SIN,A0      ;RESET SIN TABLE ADDR
         MOVE.W   BANWID(A5),BW(A5) ;RESTORE BW COUNTER
         MOVEQ    #0,D3       ;CLEAR AMPL1
         MOVEQ    #0,D4       ;CLEAR AMPL3,AMPL2
         CLR.W    D0          ;INIT PITCH
         MOVE.B   PITCH(A5),D0
         MOVE.B   -5(A6),D3   ;UPDATE AMPLS
         LSL.W    #5,D3       ;JUSTIFY AMPL
         MOVE.B   -3(A6),D4
         SWAP     D4          ;POSITION AMP3 HI
         MOVE.B   -4(A6),D4
         LSL.L    #5,D4
SYN2     SWAP     D0          ;RESTORE PITCH,MICFRAME
         BRA      SYN3        ;NEXT SAMPLE

         DC.B     'COPYRIGHT 1984 MARK BARTON & JOSEPH KATZ'
	 CNOP     0,2
*
* FRICATIVE PLAYBACK
*
FRIC1    MOVEQ    #0,D4       ;CLEAR FORMANT AMPL 2,3
         MOVEQ    #0,D5       ;CLEAR SCRATCH
         MOVE.W   FRIDEX(A5),D5 ;GET OLD REC INDEX
FRIC2    MOVEQ    #0,D7       ;CLEAR OUTPUT SAMPLE
         BTST     #31,D6      ;VFRIC?
         BEQ.S    FRNF1       ;NO, BRANCH
         MOVE.W   D1,D4       ;YES, COMPUTE F1 SAMPLE
         LSR.W    #4,D4       ;JUSTIFY FOR SIN TABLE
         MOVE.B   0(A0,D4),D4 ;GET SIN
         AND.W    #$1F,D4     ;CLEAR STRAY BITS
         OR.W     D3,D4       ;OR IN AMPLITUDE
         MOVE.B   0(A1,D4),D7 ;GET PRODUCT F1
FRNF1    MOVE.W   D7,-(SP)    ;SAVE PRODUCT (IF ANY)
         CLR.W    D4
         MOVE.B   0(A4,D5),D4 ;GET NOISE SAMPLE
         MOVE.W   D4,-(SP)    ;SAVE FOR 2ND SAMPLE
         AND.W    #$F,D4      ;ISOLATE 1ST SAMPLE
         ADD.B    D4,D4       ;POSN SIGN BIT ( ASL.B #1 )
         OR.W     D6,D4       ;OR IN AMPL
         ADD.B    0(A1,D4),D7 ;ADD NOISE
         MOVE.B   D7,(A3)+    ;PLACE IN OUTPUT BUFFER
         MOVE.W   (SP)+,D4    ;RETRIEVE FRIC SAMPLE
         AND.B    #$F0,D4     ;ISOLATE 2ND SAMPLE
         LSR.B    #3,D4       ;POSN
         OR.W     D6,D4       ;OR IN AMPLITUDE
         MOVE.B   0(A1,D4),D7 ;GET NOISE PRODUCT
         ADD.W    (SP)+,D7    ;ADD F1 VALUE (IF ANY)
         MOVE.B   D7,(A3)+    ;PLACE IN OUTPUT BUFFER
         MOVEQ    #0,D4       ;CLEAN UP D4 (AMPL2,3)
*
* Second output routine
*
	SUBQ.W    #1,SAMPCNT(A5)
	BNE       OUTRTN2
*
* Let's waste some time
*
*	MOVE.L    D0,-(SP)
*WASTE2  MOVE.W    #$1BE5,D0
*WASTE3  NOP
*	DBF       D0,WASTE3
*	MOVE.L    (SP)+,D0
*
	MOVE.W    #BUFFLEN/2,SAMPCNT(A5)  ;restore sample count
	SUB.L     #BUFFLEN,A3		;pt back to beginning of buffer
	MOVEM.L   A0/A1/A2/A4/A6/D0/D1/D2/D7,-(SP)
	MOVE.L	  USERIORB(A5),A3
	MOVE.L	  IO_DEVICE(A3),A4
	MOVE.L	  _AbsExecBase,A6
	TST.B	  Mouth(A5)
	BEQ.S	  SYNOUT2
	BSR	  DoMouth
SYNOUT2	BSR	  SYN_Write

	MOVEM.L   (SP)+,A0/A1/A2/A4/A6/D0/D1/D2/D7
        MOVE.L	  USERIORB(A5),A3
	BTST	  #IOB_ABORT,IO_FLAGS(A3)
	BNE	  SYN_AbortIt
	NOT.W     BUFFLAG(A5)           ;switch buffers
        BNE.S     SYNSW2
	LEA       OUTBUFF1(A5),A3       ;choose buffer 1
	BRA.S     OUTRTN2
SYNSW2	LEA       OUTBUFF2(A5),A3       ;choose buffer 2     
*
OUTRTN2  ADD.W    FRINC(A5),D5 ;INCR RECORDING
         BEQ      FRIC3        ;HIT BEGINNING?
         CMP.W    #479,D5      ;HIT END?
         BNE.S    FRIC4
FRIC3    NEG.W    FRINC(A5)    ;REVERSE DIRECTION
FRIC4    BTST     #31,D6       ;VFRIC?
         BEQ.S    FRIC8        ;NO, BRANCH
         ADD.W    F1INC(A5),D1   ; **** ADDED 2/16 TO INCREASE SPEED OF VFRIC
         AND.W    #$3FF,D1       ;                  '
         MOVEQ    #0,D2          ;                  '
         MOVE.W   D5,FRIDEX(A5)  ;SAVE POSITION
         BRA      SYN8    ;DO A FRAME UPDATE (CHGED 2/16 FROM FRIC6 FOR SPEED)
FRIC8    SUBQ.W   #1,D0         ;DECR MICFRAME
         BPL      FRIC2         ;DO ANOTHER 2 SAMPS
         MOVE.W   D5,FRIDEX(A5) ;SAVE POSITION
         BRA      SYN5          ;DO A FRAME UPDATE

SYNEXIT:
	MOVE.L	_AbsExecBase,A6
	MOVE.L	USERIORB(A5),A0
	MOVE.L	IO_DEVICE(A0),A3
	MOVE.L	ND_AUDDMAIORB(A3),A1
	MOVEQ	#0,D3
	MOVE.B	NDI_NUMCHAN(A0),D3
	MOVE.L	D3,D0
	MULU	#ioa_Size,D0
	TST.W	BUFFLAG(A5)
	BNE.S	SYNEX2
	ADD.L	D0,A1

SYNEX2	SUBQ.W	#1,D3

*   Turn blitter back on, if it was on.
*	MOVE.W	MySig(A5),D0				; KODIAK 2/23/88
*	BTST    #DMAB_BLITTER,D0			; KODIAK 2/23/88
*	BEQ.S	SYNEXL					; KODIAK 2/23/88
*	CLR.W	MySig(A5)				; KODIAK 2/23/88
*	LEA     _custom,A6				; KODIAK 2/23/88
*	MOVE.W	#DMAF_SETCLR+DMAF_BLITTER,dmacon(A6)	; KODIAK 2/23/88
*	MOVE.L	_AbsExecBase,A6				; KODIAK 2/23/88

SYNEXL	CALLSYS	WaitIO
	LEA	ioa_Size(A1),A1
	DBF	D3,SYNEXL

	MOVEQ	#0,D3
	BRA.S	SYN_Return

SYN_AbortIt:
	MOVEQ	  #IOERR_ABORTED,D3

SYN_Return:
*   Turn blitter back on, if it was on.
*	MOVE.W	MySig(A5),D0				; KODIAK 2/23/88
*	BTST    #DMAB_BLITTER,D0			; KODIAK 2/23/88
*	BEQ.S	SYNXIT					; KODIAK 2/23/88
*	LEA     _custom,A6				; KODIAK 2/23/88
*	MOVE.W	#DMAF_SETCLR+DMAF_BLITTER,dmacon(A6)	; KODIAK 2/23/88

*SYNXIT
	RTS



DoMouth:
	DISABLE
	MOVE.B	(A2),D0			;Here's the new mouth
	CMP.B	CURMOUTH(A5),D0		;Same as the old mouth
	BEQ.S	DoMouth_Rtn		;Read won't get sent again

	MOVE.B	D0,CURMOUTH(A5)		;Store the new mouth

*	;------	Is there a read on the read queue for this write?
	LEA	ND_UNIT+MP_MSGLIST(A4),A0
	CMP.L	LH_TAILPRED(A0),A0
	BEQ.S	DoMouth_Rtn		;Input queue empty, just return
	MOVE.L	(A0),A1			;Look at first entry on list
	CMP.W	#CMD_READ,IO_COMMAND(A1)	;Is it a read?
	BNE.S	DoMouth_Rtn			;No, just return
	MOVE.L	IO_UNIT(A1),D1		;does the read match the current write?
	CMP.L	IO_UNIT(A3),D1
	BNE.S	DoMouth_Rtn		;Read not for this write, just return

*	;------	Are the mouth shapes different?
	CMP.B	MRB_SHAPE(A1),D0
	BEQ.S	DoMouth_Rtn		;Same shape, just return

*	;------ Remove the read request from the queue and reply to user.
	MOVE.B	D0,MRB_SHAPE(A1)
	MOVE.B	D0,D1
	AND.B	#$0F,D0
	MOVE.B	D0,MRB_WIDTH(A1)
	LSR.B	#4,D1
	MOVE.B	D1,MRB_HEIGHT(A1)
	CLR.B	IO_ERROR(A1)
	REMHEADQ A0,A1,A2
	ENABLE
	CALLSYS	ReplyMsg
	RTS

DoMouth_Rtn:
	ENABLE
	RTS


SYN_Write:
	MOVEQ	#0,D2
	MOVE.B	NDI_NUMCHAN(A3),D2
	MOVE.L	D2,D7
	MULU	#ioa_Size,D7

	TST.W	BUFFLAG(A5)
	BNE.S	SYN_Buff2
	MOVE.L	ND_AUDDMAIORB(A4),A1
	MOVE.L	A1,A2
	ADD.L	D7,A2
	BRA.S	SYN_SetLoop

SYN_Buff2:
	MOVE.L	ND_AUDDMAIORB(A4),A2
	MOVE.L	A2,A1
	ADD.L	D7,A1

SYN_SetLoop:
	MOVE.W	D2,D7
	SUBQ.W	#1,D7

SYN_OutLoop:
	BSET	#IOB_QUICK,IO_FLAGS(A1)
	MOVE.L  A1,-(SP)		*!!!sam 7/12/85!!!
	BEGINIO
	MOVE.L  (SP)+,A1		*!!!sam 7/12/85!!!
	LEA	ioa_Size(A1),A1
	DBF	D7,SYN_OutLoop

	BCLR	#IOB_FIRST,IO_FLAGS(A3)
	BEQ.S	SYN_Wait
	LEA	ND_IORB3(A4),A1
	MOVE.W	#CMD_START,IO_COMMAND(A1)
	CALLSYS	DoIO
	BRA.S	SYN_WReturn

SYN_Wait:
	MOVE.W	D2,D7
	SUBQ.W	#1,D7
	MOVE.L	A2,A1


*	;------	Turn on the blitter, if it was on before
*	MOVE.W	MySig(A5),D0	;get blitter state	; KODIAK 2/22/88
*	BTST	#DMAB_BLITTER,D0			; KODIAK 2/22/88
*	BEQ.S   SYN_WLoop				; KODIAK 2/22/88
*	LEA	_custom,A0				; KODIAK 2/22/88
*	MOVE.W  #DMAF_SETCLR+DMAF_BLITTER,dmacon(A0)	; KODIAK 2/22/88
	

SYN_WLoop:
	CALLSYS	WaitIO
	TST.B	IO_ERROR(A1)
	BNE.S	SYN_WDie
	LEA	ioa_Size(A1),A1
	DBF	D7,SYN_WLoop

*	;------	Save blitter's state and turn it off
*BLITOFF
*	LEA	_custom,A0				; KODIAK 2/22/88
*	MOVE.W	dmaconr(A0),MySig(A5)			; KODIAK 2/22/88
*	MOVE.W  #DMAF_BLITTER,dmacon(A0)		; KODIAK 2/22/88

SYN_WReturn:
	RTS


SYN_WDie:
	BSET	#IOB_ABORT,IO_FLAGS(A3)
	BRA.S	SYN_WReturn


DMANodeName:
	DC.B	'Speech IORB',0
	CNOP	0,2

	END 

