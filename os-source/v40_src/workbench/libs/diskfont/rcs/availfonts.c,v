head     37.4;
branch   ;
access   ;
symbols  V36_167:36.12 V36_162:36.12 V36_160:36.12 V36_157:36.12 V36_139:36.11 V36_137:36.11 V36_135:36.11 V36_125:36.9 V36_124:36.9 V36_122:36.9 V36_121:36.8 V36_116:36.7 V36_111:36.6 V36_97:36.5 V36_86:36.3;
locks    ; strict;
comment  @*   @;


37.4
date     92.06.18.11.38.48;  author darren;  state Exp;
branches ;
next     37.3;

37.3
date     92.03.26.11.52.39;  author davidj;  state Exp;
branches ;
next     37.2;

37.2
date     91.01.31.14.35.24;  author kodiak;  state Exp;
branches ;
next     37.1;

37.1
date     90.11.26.12.14.25;  author kodiak;  state Exp;
branches ;
next     37.0;

37.0
date     90.10.16.01.23.29;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     90.04.10.09.49.57;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     90.04.09.05.46.33;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     90.02.23.13.09.09;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     90.01.30.13.04.28;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     90.01.30.13.00.08;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     89.11.03.16.55.50;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     89.10.03.14.05.11;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     89.09.11.12.26.33;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     89.09.08.11.50.19;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.05.17.12.19.39;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     89.05.17.12.16.48;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     89.05.16.17.03.26;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     89.05.16.16.57.32;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     88.05.24.14.45.01;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     88.05.24.14.43.48;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


37.4
log
@changed 'bugBytes' to 'bufBytes'; the autodoc changes seem to have
been lost while the 3rd diskfont was being worked on
@
text
@/*
**	$Id: availfonts.c,v 37.3 92/03/26 11:52:39 davidj Exp Locker: darren $
**
**      diskfont.library AvailFonts function
**
**	(C) Copyright 1990 Robert R. Burns
**	    All Rights Reserved
**      (C) Copyright 1989 Commodore-Amiga, Inc.
**          All Rights Reserved
*/

/* debug switches */

#ifdef	DEBUG
extern void kprintf (char *,...);

#define	D(a)	kprintf a
#else
#define	D(a)
#endif

#define	DB(x)	;

/* includes */

#include <exec/types.h>

#include "diskfont.h"
#include <diskfont/diskfonttag.h>
#include "dfdata.h"

#include <exec/nodes.h>
#include <exec/lists.h>
#include <exec/ports.h>
#include <dos/dos.h>
#include <dos/dosextens.h>
#include <graphics/gfxbase.h>
#include <graphics/text.h>
#include <utility/tagitem.h>

#include <string.h>
#undef    strcat
#undef    strcmp
#undef    strcpy
#include <clib/dos_protos.h>
#include <clib/exec_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/exec_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/utility_pragmas.h>

/*	exports */

LONG __asm DFAvailFonts (register __a6 struct DiskfontLibrary *,
			  register __a0 UBYTE *, register __d0 LONG, register __d1 ULONG);


/*	imports */

#define	DOSBase		dfl->dfl_DOSBase
#define	SysBase		dfl->dfl_SysBase
#define	GfxBase		dfl->dfl_GfxBase
#define	UtilityBase	dfl->dfl_UtilityBase


/*	locals */

    BOOL FillBuffer (struct DiskfontLibrary *,
		      UBYTE **, UBYTE **, LONG *, LONG *, char *,
		      struct TTextAttr *, struct TagList *, UWORD, LONG, LONG);


/****** diskfont.library/AvailFonts **********************************
*
*   NAME
*	AvailFonts -- Inquire available memory & disk fonts.
*
*   SYNOPSIS
*	error = AvailFonts(buffer, bufBytes, flags);
*	                   A0      D0        D1
*
*	LONG AvailFonts( struct AvailFontsHeader *buffer, LONG bufBytes
*		ULONG flags );
*
*   FUNCTION
*	AvailFonts fills a user supplied buffer with the structure,
*	described below, that contains information about all the
*	fonts available in memory and/or on disk.  Those fonts
*	available on disk need to be loaded into memory and opened
*	via OpenDiskFont, those already in memory are accessed via
*	OpenFont.  The TextAttr structure required by the open calls
*	is part of the information AvailFonts supplies.
*
*	When AvailFonts fails, it returns the number of extra bytes
*	it needed to complete the command.  Add this number to your
*	current buffer size, allocate a new buffer, and try again.
*
*   INPUTS
*	buffer - memory to be filled with struct AvailFontsHeader
*		followed by an array of AvailFonts elements, which
*		contains entries for the available fonts and their
*		names.
*
*	bufBytes - the number of bytes in the buffer
*	flags - AFF_MEMORY is set to search memory for fonts to fill
*		the structure, AFF_DISK is set to search the disk for
*		fonts to fill the structure.  AFF_SCALED is set to
*		not filter out memory fonts that are not designed.
*		AFF_BITMAP is set to filter out fonts that are not
*		stored in Amiga font format, i.e. to filter out
*		outline fonts.  Any combination may be specified.
*		AFF_TAGGED is set to fill the buffer with TAvailFonts
*		elements instead of AvailFonts elements.
*
*   RESULTS
*	buffer - filled with struct AvailFontsHeader followed by the
*		[T]AvailFonts elements, There will be duplicate entries
*		for fonts found both in memory and on disk, differing
*		only by type.  The existance of a disk font in the
*		buffer indicates that it exists as an entry in a font
*		contents file -- the underlying font file has not been
*		checked for validity, thus an OpenDiskFont of it may
*		fail.
*	error - if non-zero, this indicates the number of bytes needed
*		for AvailFonts in addition to those supplied.  Thus
*		structure elements were not returned because of
*		insufficient bufBytes.
*
*   EXAMPLE
*	int afShortage, afSize;
*	struct AvailFontsHeader *afh;
*
*	...
*
*	afSize = 400;
*	do {
*	    afh = (struct AvailFontsHeader *) AllocMem(afSize, 0);
*	    if (afh) {
*	        afShortage = AvailFonts(afh, afSize, AFF_MEMORY|AFF_DISK);
*	        if (afShortage) {
*	            FreeMem(afh, afSize);
*	            afSize += afShortage;
*	        }
*	    }
*	    else {
*	        fail("AllocMem of AvailFonts buffer afh failed\n");
*	        break;
*	    }
*	}
*	    while (afShortage);
*
*	\*
*	 * if (afh) non-zero here, then:
*	 * 1. it points to a valid AvailFontsHeader
*	 * 2. it must have FreeMem(afh, afSize) called for it after use
*	 *\
*
*********************************************************************/
#define	TIS	sizeof(struct TagItem)

BOOL FillBuffer (struct DiskfontLibrary * dfl,
		 UBYTE ** bufTopDown, UBYTE ** bufBottomUp, LONG * bufBytes,
		 LONG * bottomBytes, char *fontName, struct TTextAttr * fontAttr,
		 struct TagList * fontTags, UWORD AFType, LONG TTAFFlag, LONG TFCFlag)
{
    struct TAvailFonts *taf;
    WORD nameLen, tagLen;
    ULONG *tagSearch, *tagEnd;
    char *nameSearch, *s1, *s2;
    struct TagItem *tagList1, *tagList2, *tagEntry;
    int i;

    /* search for pre-existant instance of fontName */
    nameLen = strlen (fontName) + 1;	/* include null terminator */
    nameSearch = *bufBottomUp;
    for (i = *bottomBytes - nameLen; i >= 0; i--)
    {
	s1 = fontName;
	s2 = nameSearch;
	while (*s1)
	{
	    if (*s1++ != *s2++)
		goto failNameMatch;
	}
	if (*s2 == '\0')
	{
	    /* name already in buffer */
	    nameLen = 0;
	    break;
	}
      failNameMatch:
	nameSearch++;
    }
    taf = (struct TAvailFonts *) * bufTopDown;
    tagLen = 0;
    tagSearch = 0;		/* null tag list for empty one */
    if (TTAFFlag)
    {
	if (TFCFlag && fontTags)
	{
	    /* search for pre-existant instance of fontTags */

	    /* count tag items */
	    tagList1 = fontTags;
	    while (NextTagItem (&tagList1))
		tagLen++;

	    if (tagLen != 0)
	    {
		tagLen++;
		tagLen = tagLen * TIS;
		/* search for potential TAG_DONE, then for tag list match */
		tagSearch = (ULONG *) ((((ULONG) * bufBottomUp) + 1) & 0xfffffffe);
		tagEnd = (ULONG *) (((ULONG) tagSearch) + tagLen - TIS);
		for (i = (*bottomBytes - tagLen) / 2; i >= 0; i--)
		{
		    if (*tagEnd == TAG_DONE)
		    {
			tagList1 = fontTags;
			tagList2 = (struct TagItem *) tagSearch;
			while (tagEntry = (struct TagItem *)
			       NextTagItem (&tagList1))
			{
			    if ((tagEntry->ti_Tag != tagList2->ti_Tag) ||
				(tagEntry->ti_Data != tagList2->ti_Data))
				goto failTagMatch;
			    tagList2++;
			}
			/* fontTags is at tagSearch */
			tagLen = 0;
			break;
		    }
		  failTagMatch:
		    tagEnd = (ULONG *) (((LONG) tagEnd) + 2);
		    tagSearch = (ULONG *) (((LONG) tagSearch) + 2);
		}
	    }
	}
	*bufBytes -= tagLen + nameLen + sizeof (struct TAvailFonts);
	*bufTopDown += sizeof (struct TAvailFonts);
    }
    else
    {
	*bufBytes -= nameLen + sizeof (struct AvailFonts);
	*bufTopDown += sizeof (struct AvailFonts);
    }
    if (*bufBytes >= 0)
    {
	DB (kprintf ("FillBuffer type %ld, ", AFType));
	taf->taf_Type = AFType;
	if (nameLen)
	{
	    DB (kprintf ("original "));
	    *bottomBytes += nameLen;
	    *bufBottomUp -= nameLen;
	    for (i = 0; i < nameLen; i++)
		(*bufBottomUp)[i] = fontName[i];
	    taf->taf_Attr.tta_Name = *bufBottomUp;
	}
	else
	{
	    taf->taf_Attr.tta_Name = nameSearch;
	}
	DB (kprintf ("name \"%s\", ", taf->taf_Attr.tta_Name));

	taf->taf_Attr.tta_YSize = fontAttr->tta_YSize;
	taf->taf_Attr.tta_Flags = fontAttr->tta_Flags;
	DB (kprintf ("YSize %ld, Flags 0x%lx, ", taf->taf_Attr.tta_YSize,
		     taf->taf_Attr.tta_Flags));

	if (TTAFFlag && TFCFlag)
	{
	    taf->taf_Attr.tta_Style = fontAttr->tta_Style | FSF_TAGGED;
	    if (tagLen)
	    {
		DB (kprintf ("original "));
		*bottomBytes = (*bottomBytes + tagLen + 1) & 0xfffffffe;
		tagList1 = fontTags;
		tagList2 = (struct TagItem *) ((((ULONG) * bufBottomUp) -
						tagLen - 1) & 0xfffffffe);
		*bufBottomUp = (char *) tagList2;
		taf->taf_Attr.tta_Tags = tagList2;
		while (tagEntry = (struct TagItem *) NextTagItem (&tagList1))
		    *tagList2++ = *tagEntry;
		tagList2->ti_Tag = TAG_DONE;
	    }
	    else
	    {
		taf->taf_Attr.tta_Tags = (struct TagItem *) tagSearch;
	    }
	    DB (kprintf ("Tag @@ 0x%06lx Style 0x%lx\n",
			 taf->taf_Attr.tta_Tags, taf->taf_Attr.tta_Style));
	}
	else
	{
	    taf->taf_Attr.tta_Style = fontAttr->tta_Style & ~FSF_TAGGED;
	    DB (kprintf ("Style 0x%lx\n", taf->taf_Attr.tta_Style));
	}
	return (TRUE);
    }
    DB (kprintf ("FillBuffer failure\n"));
    return (FALSE);
}


LONG __asm DFAvailFonts (register __a6 struct DiskfontLibrary * dfl,
			  register __a0 UBYTE * bufferIn, register __d0 LONG bufBytesIn,
			  register __d1 ULONG flags)
{
    struct AvailFontsHeader *afh;
    UBYTE *buffer, *bufBottomUp;
    LONG bufBytes, bottomBytes;
    struct TextFont *font;
    struct FileInfoBlock *fib;
    struct DevProc *dvp;
    UWORD memEntries, thisFontFlag;

    ULONG fDirLock, prevCurrDir, fcFile;
    char *nameTemp;
    struct FontContentsHeader fch;
    struct TFontContents tfc;

    struct TagItem *ti, tagItem;
    struct TTextAttr tTextAttr;
    UWORD *avail;
    int i;

    DB (kprintf ("AvailFonts(0x%06lx, %ld, 0x%02lx) TTATTR %s\n", bufferIn, bufBytesIn,
		 flags, (flags & AFF_TAGGED) ? "set" : "clear"));

    /* compatability for 1.3 programs like FED -
     *
     * If someone asks for flags -1, meaning ALL fonts, they likely
     * didn't mean AFF_TAGGED.
     *
     * This als means we need to reserve a bit - the high bit - so
     * that there can never be a legit combination which equals -1
     */
    if (flags==-1L) flags^=AFF_TAGGED;	/* turn OFF AFF_TAGGED bit */

    buffer = bufferIn;
    bufBytes = bufBytesIn;
    fib = 0;

    /* initialize the number of entries */
    bufBytes -= sizeof (struct AvailFontsHeader);
    if (bufBytes >= 0)
    {
	afh = (struct AvailFontsHeader *) buffer;
	afh->afh_NumEntries = 0;
	buffer += sizeof (*afh);
    }
    else
	afh = 0;

    /* initialize the name character buffer */
    bufBottomUp = buffer + bufBytes;
    bottomBytes = 0;

    /* cache the fonts on the graphics font list */
    if ((flags & AFF_MEMORY) || (flags & AFF_SCALED))
    {
	Forbid ();
	font = (struct TextFont *) dfl->dfl_GfxBase->TextFonts.lh_Head;
	while (font->tf_Message.mn_Node.ln_Succ != 0)
	{
	    if ((font->tf_Flags &
		 (FPF_DESIGNED | FPF_DISKFONT | FPF_ROMFONT)) == 0)
		thisFontFlag = AFF_SCALED;
	    else
		thisFontFlag = AFF_MEMORY;
	    if (flags & thisFontFlag)
	    {
		ExtendFont (font, 0);
		if (FillBuffer (dfl, &buffer, &bufBottomUp, &bufBytes,
				&bottomBytes, font->tf_Message.mn_Node.ln_Name,
				(struct TTextAttr *) (((ULONG) & font->tf_YSize) - 4),
				((struct TextFontExtension *) font->tf_Extension)->
				tfe_Tags, thisFontFlag,
				flags & AFF_TAGGED, TRUE))
		    (afh->afh_NumEntries)++;
	    }
	    font = (struct TextFont *) font->tf_Message.mn_Node.ln_Succ;
	}
	Permit ();
    }

    if (flags & AFF_DISK)
    {
	/* save # of non-disk entries */
	if (afh)
	    memEntries = afh->afh_NumEntries;	/* only used when afh exists */
	if (fib = (struct FileInfoBlock *) AllocDosObject (DOS_FIB, 0))
	{
	    /* get FONTS: DevProc entry */
	    dvp = (struct DevProc *) GetDeviceProc ("FONTS:", 0);
	    DB (kprintf ("initial dvp 0x%lx\n", dvp));
	    while (dvp)
	    {
		/* get lock on current dvp */
		fib->fib_FileName[0] = 0;	/* create null BSTR */
		do
		{
		    fDirLock = DoPkt3 (dvp->dvp_Port, ACTION_LOCATE_OBJECT,
				       dvp->dvp_Lock, MKBADDR (fib->fib_FileName), SHARED_LOCK);
		    DB (kprintf ("fDirLock 0x%lx\n", fDirLock));
		    if (!fDirLock)
		    {
			if (ErrorReport (IoErr (), REPORT_LOCK, dvp->dvp_Lock,
					 dvp->dvp_Port))
			    goto missingLockContinue;
		    }
		}
		while (!fDirLock);
		/* ensure lock is valid directory while setting up for ExNext */
		if (Examine (fDirLock, fib) && (fib->fib_DirEntryType > 0))
		{
		    /* set CD here for subsequent Open()s */
		    prevCurrDir = CurrentDir (fDirLock);
		    while (ExNext (fDirLock, fib))
		    {
			/* validate name is xxx.font, and that it is a file */
			if ((nameTemp = strrchr (fib->fib_FileName, '.')) &&
			    (strcmp (nameTemp, ".font") == 0) &&
			    (fib->fib_DirEntryType < 0))
			{
			    /* filter any font contents that existed in a prior path */
			    if (afh)
			    {
				for (i = memEntries; i < afh->afh_NumEntries; i++)
				{
				    if (flags & AFF_TAGGED)
				    {
					if (StrEquNC (fib->fib_FileName, ((struct TAvailFonts *)
									  & afh[1])[i].taf_Attr.tta_Name))
					{
					    DB (kprintf ("duplicate disk font name \"%s\"\n",
							 fib->fib_FileName));
					    goto dupFontContinue;
					}
				    }
				    else
				    {
					if (StrEquNC (fib->fib_FileName, ((struct AvailFonts *)
									  & afh[1])[i].af_Attr.ta_Name))
					{
					    DB (kprintf ("duplicate disk font name \"%s\"\n",
							 fib->fib_FileName));
					    goto dupFontContinue;
					}
				    }
				}
			    }
			    /* try to open font contents file */
			    fch.fch_FileID = 0;
			    if (fcFile = Open (fib->fib_FileName, MODE_OLDFILE))
			    {
				if (Read (fcFile, (char *) &fch, sizeof (fch)) == sizeof (fch))
				{
				    DB (kprintf ("FileID 0x%04lx ", fch.fch_FileID));
				    if ((fch.fch_FileID & 0xfff0) == FCH_ID)
				    {
					for (i = 0; i < fch.fch_NumEntries; i++)
					{
					    if (Read (fcFile, (char *) &tfc,
						      sizeof (struct TFontContents))
						== sizeof (struct TFontContents))
					    {
						tfc.tfc_Flags = (tfc.tfc_Flags & ~FPF_ROMFONT) |
						  FPF_DISKFONT;
						if (FillBuffer (dfl, &buffer, &bufBottomUp, &bufBytes,
								&bottomBytes, FilePart (fib->fib_FileName),
								(struct TTextAttr *) (((ULONG) & tfc.tfc_YSize) - 4),
								(struct TagList *) & tfc.tfc_FileName[MAXFONTPATH -
												  (TIS * (tfc.tfc_TagCount + 1))],
								AFF_DISK, flags & AFF_TAGGED,
								fch.fch_FileID >= TFCH_ID))
						    (afh->afh_NumEntries)++;
					    }	/* Read tfc */
					    else
						/* don't try to continue to read font contents */
						break;
					}	/* for fch_NumEntries */
				    }	/* if FCH_ID */
				}	/* Read fch */
				Close (fcFile);
			    }	/* Open .font */
			    DB (kprintf ("flags $%lx\n", flags));
			    if ((fch.fch_FileID == OFCH_ID) && (!(flags & AFF_BITMAP)))
			    {
				strcpy (nameTemp, OTSUFFIX);
				DB (kprintf (".otag name \"%s\"\n", fib->fib_FileName));
				fcFile = Open (fib->fib_FileName, MODE_OLDFILE);
				DB (kprintf ("otag File 0x%lx, error %ld\n", fcFile, IoErr ()));
				strcpy (nameTemp, ".font");
				if (fcFile)
				{
				    DB (kprintf (".otag open\n"));
				    if ((Read (fcFile, (char *) &tagItem, sizeof (tagItem))
					 == sizeof (tagItem)) &&
					(tagItem.ti_Tag == OT_FileIdent) &&
					(ti = AllocVec (tagItem.ti_Data, 0)))
				    {
					DB (kprintf (".otag valid id, size %ld\n", tagItem.ti_Data));
					if (Read (fcFile, (char *) (ti + 1),
						  tagItem.ti_Data - sizeof (tagItem))
					    == tagItem.ti_Data - sizeof (tagItem))
					{
					    *ti = tagItem;	/* initialize first tag */
					    i = GetTagData (OT_AvailSizes, 0, ti);
					    DB (kprintf ("OT_AvailSizes ($%08lx): %ld\n", OT_AvailSizes, i));
					    if (i)
					    {
						tTextAttr.tta_Style = 0;
						if (GetTagData (OT_IsFixed, 0, ti))
						    tTextAttr.tta_Flags = FPF_DISKFONT;
						else
						    tTextAttr.tta_Flags = FPF_DISKFONT | FPF_PROPORTIONAL;
						if (GetTagData (OT_StemWeight, OTS_Medium, ti) >=
						    ((OTS_Medium + OTS_SemiBold) / 2))
						    tTextAttr.tta_Style |= FSF_BOLD;
						if (GetTagData (OT_SlantStyle, OTS_Upright, ti) !=
						    OTS_Upright)
						    tTextAttr.tta_Style |= FSF_ITALIC;
						if (GetTagData (OT_HorizStyle, OTH_Normal, ti) >=
						    ((OTH_Normal + OTH_SemiExpanded) / 2))
						    tTextAttr.tta_Style |= FSF_EXTENDED;
						avail = (UWORD *) (((ULONG) ti) + i);
						i = *avail++;
						DB (kprintf (".otag %ld sizes\n", i));
						while (i-- > 0)
						{
						    tTextAttr.tta_YSize = *avail++;
						    if (FillBuffer (dfl, &buffer, &bufBottomUp,
								    &bufBytes, &bottomBytes,
								    FilePart (fib->fib_FileName), &tTextAttr, 0,
								    AFF_DISK, flags & AFF_TAGGED, 0))
							(afh->afh_NumEntries)++;
						}	/* each avail size */
					    }	/* OT_AvailSizes exists */
					}	/* read remaining ti */
					FreeVec (ti);
				    }	/* read OT_FileIdent and alloc ti */
				    Close (fcFile);
				}	/* Open .otag */
			    }	/* !AFF_BITMAP */
			}	/* if name OK & is file */
		      dupFontContinue:;
		    }		/* while ExNext */
		    CurrentDir (prevCurrDir);
		}		/* if lock OK & Examines & is dir */
		UnLock (fDirLock);	/* null is OK for UnLock */
missingLockContinue:
		dvp = (struct DevProc *) GetDeviceProc ("FONTS:", dvp);
		DB (kprintf ("next dvp 0x%lx\n", dvp));
	    }			/* while dvp */

	    DB (kprintf ("FreeDosObject 0x%lx\n", fib));
	    FreeDosObject (DOS_FIB, fib);
	}			/* if fib */
    }				/* if AFF_DISK */

    DB (kprintf ("exit with bufBytes %ld\n", (LONG)bufBytes));
    if (bufBytes < 0)
	return (-bufBytes);
    else
	return (0);
}
@


37.3
log
@Added check for -1 flags field and clear _TAGGED flag.
@
text
@d2 1
a2 1
**	$Id: availfonts.c,v 37.2 91/01/31 14:35:24 kodiak Exp Locker: davidj $
d84 1
a84 1
*	LONG AvailFonts( struct AvailFontsHeader *buffer, LONG bugBytes
@


37.2
log
@prompt for missing assign path locks
set FPF_PROPORTIONAL based on OT_IsFixed
@
text
@d2 1
a2 1
**	$Id: availfonts.c,v 37.1 90/11/26 12:14:25 kodiak Exp $
d12 1
a12 1
/*	debug switches */
d15 2
a16 1
extern void kprintf(char *,...);
d22 1
a22 2

/*	includes */
d24 1
a24 1
#include	<exec/types.h>
d26 14
a39 12
#include	"diskfont.h"
#include	"diskfonttag.h"
#include	"dfdata.h"

#include	<exec/nodes.h>
#include	<exec/lists.h>
#include	<exec/ports.h>
#include	<dos/dos.h>
#include	<dos/dosextens.h>
#include	<graphics/gfxbase.h>
#include	<graphics/text.h>
#include	<utility/tagitem.h>
d41 1
a41 1
#include	<string.h>
d45 8
a52 8
#include	<clib/dos_protos.h>
#include	<clib/exec_protos.h>
#include	<clib/graphics_protos.h>
#include	<clib/utility_protos.h>
#include	<pragmas/dos_pragmas.h>
#include	<pragmas/exec_pragmas.h>
#include	<pragmas/graphics_pragmas.h>
#include	<pragmas/utility_pragmas.h>
d56 2
a57 2
LONG __asm DFAvailFonts( register __a6 struct DiskfontLibrary *,
	register __a0 UBYTE *, register __d0 LONG, register __d1 ULONG );
d70 3
a72 3
BOOL FillBuffer( struct DiskfontLibrary *,
	UBYTE **, UBYTE **, LONG *, LONG *, char *,
	struct TTextAttr *, struct TagList *, UWORD, LONG, LONG);
d83 1
a83 1
*	
d105 1
a105 1
*	
d163 4
a166 4
BOOL FillBuffer( struct DiskfontLibrary *dfl,
	UBYTE **bufTopDown, UBYTE **bufBottomUp, LONG *bufBytes,
	LONG *bottomBytes, char *fontName, struct TTextAttr *fontAttr,
	struct TagList *fontTags, UWORD AFType, LONG TTAFFlag, LONG TFCFlag)
d176 1
a176 1
    nameLen = strlen(fontName) + 1;	/* include null terminator */
d178 2
a179 1
    for (i = *bottomBytes - nameLen; i >= 0; i--) {
d182 2
a183 1
	while (*s1) {
d187 2
a188 1
	if (*s2 == '\0') {
d193 1
a193 1
failNameMatch:
d196 1
a196 1
    taf = (struct TAvailFonts *) *bufTopDown;
d198 5
a202 3
    tagSearch = 0;			/* null tag list for empty one */
    if (TTAFFlag) {
	if (TFCFlag && fontTags) {
d207 2
a208 1
	    while (NextTagItem(&tagList1)) tagLen++;
d210 2
a211 1
	    if (tagLen != 0) {
d213 1
a213 1
		tagLen = tagLen*TIS;
d215 1
a215 1
		tagSearch = (ULONG *) ((((ULONG) *bufBottomUp)+1) & 0xfffffffe);
d217 4
a220 2
		for (i = (*bottomBytes - tagLen) / 2; i >= 0; i--) {
		    if (*tagEnd == TAG_DONE) {
d224 2
a225 1
				NextTagItem(&tagList1)) {
d227 1
a227 1
				    (tagEntry->ti_Data != tagList2->ti_Data))
d235 1
a235 1
failTagMatch:
d241 2
a242 2
        *bufBytes -= tagLen + nameLen + sizeof(struct TAvailFonts);
        *bufTopDown += sizeof(struct TAvailFonts);
d244 13
a256 10
    else {
        *bufBytes -= nameLen + sizeof(struct AvailFonts);
        *bufTopDown += sizeof(struct AvailFonts);
    }
    if (*bufBytes >= 0) {
	D(("FillBuffer type %ld, ", AFType));
        taf->taf_Type = AFType;
        if (nameLen) {
	    D(("original "));
            *bottomBytes += nameLen;
d258 3
a260 6
            for (i = 0; i < nameLen; i++)
                (*bufBottomUp)[i] = fontName[i];
            taf->taf_Attr.tta_Name = *bufBottomUp;
        }
        else {
            taf->taf_Attr.tta_Name = nameSearch;
d262 5
a266 1
	D(("name \"%s\", ", taf->taf_Attr.tta_Name));
d268 1
a268 1
        taf->taf_Attr.tta_YSize = fontAttr->tta_YSize;
d270 2
a271 2
	D(("YSize %ld, Flags 0x%lx, ", taf->taf_Attr.tta_YSize,
		taf->taf_Attr.tta_Flags));
d273 2
a274 1
        if (TTAFFlag && TFCFlag) {
d276 3
a278 2
	    if (tagLen) {
		D(("original "));
d281 2
a282 2
		tagList2 = (struct TagItem *) ((((ULONG) *bufBottomUp) -
			tagLen - 1) & 0xfffffffe);
d285 1
a285 1
		while (tagEntry = (struct TagItem *) NextTagItem(&tagList1))
d289 2
a290 1
	    else {
d293 5
a297 4
	    D(("Tag @@ 0x%06lx Style 0x%lx\n",
		    taf->taf_Attr.tta_Tags, taf->taf_Attr.tta_Style));
        }
        else {
d299 3
a301 3
	    D(("Style 0x%lx\n", taf->taf_Attr.tta_Style));
        }
        return(TRUE);
d303 2
a304 2
    D(("FillBuffer failure\n"));
    return(FALSE);
d308 3
a310 3
LONG __asm DFAvailFonts( register __a6 struct DiskfontLibrary *dfl,
	register __a0 UBYTE *bufferIn, register __d0 LONG bufBytesIn,
	register __d1 ULONG flags)
d330 12
a341 2
    D(("AvailFonts(0x%06lx, %ld, 0x%02lx) TTATTR %s\n", bufferIn, bufBytesIn,
	    flags, (flags & AFF_TAGGED)?"set":"clear"));
d348 3
a350 2
    bufBytes -= sizeof(struct AvailFontsHeader);
    if (bufBytes >= 0) {
d352 2
a353 2
        afh->afh_NumEntries = 0;
	buffer += sizeof(*afh);
d363 22
a384 18
    if ((flags & AFF_MEMORY) || (flags & AFF_SCALED)) {
	Forbid();
        font = (struct TextFont *) dfl->dfl_GfxBase->TextFonts.lh_Head;
        while (font->tf_Message.mn_Node.ln_Succ != 0) {
            if ((font->tf_Flags &
                    (FPF_DESIGNED | FPF_DISKFONT | FPF_ROMFONT)) == 0)
                thisFontFlag = AFF_SCALED;
            else thisFontFlag = AFF_MEMORY;
            if (flags & thisFontFlag) {
		ExtendFont(font, 0);
                if (FillBuffer(dfl, &buffer, &bufBottomUp, &bufBytes,
			&bottomBytes, font->tf_Message.mn_Node.ln_Name,
                        (struct TTextAttr *) (((ULONG) &font->tf_YSize)-4),
			((struct TextFontExtension *) font->tf_Extension)->
			tfe_Tags, thisFontFlag,
			flags & AFF_TAGGED, TRUE))
                    (afh->afh_NumEntries)++;
            }
d386 2
a387 2
        }
	Permit();
d390 24
a413 49
    if (flags & AFF_DISK) {
      /* save # of non-disk entries */
      if (afh)
	memEntries = afh->afh_NumEntries;	/* only used when afh exists */
      if (fib = (struct FileInfoBlock *) AllocDosObject(DOS_FIB, 0)) {
	/* get FONTS: DevProc entry */
	dvp = (struct DevProc *) GetDeviceProc("FONTS:", 0);
	D(("initial dvp 0x%lx\n", dvp));
	while (dvp) {
	  /* get lock on current dvp */
	  fib->fib_FileName[0] = 0;		/* create null BSTR */
	  do {
	    fDirLock = DoPkt3(dvp->dvp_Port, ACTION_LOCATE_OBJECT,
		dvp->dvp_Lock, MKBADDR(fib->fib_FileName), SHARED_LOCK);
	    D(("fDirLock 0x%lx\n", fDirLock));
	    if (!fDirLock) {
	      if (ErrorReport(IoErr(), REPORT_LOCK, dvp->dvp_Lock,
		  dvp->dvp_Port))
		goto missingLockContinue;
	    }
	  }
	    while (!fDirLock);
	  /* ensure lock is valid directory while setting up for ExNext */
	  if (Examine(fDirLock, fib) && (fib->fib_DirEntryType > 0)) {
	    /* set CD here for subsequent Open()s */
	    prevCurrDir = CurrentDir(fDirLock);
	    while (ExNext(fDirLock, fib)) {
	      /* validate name is xxx.font, and that it is a file */
	      if ((nameTemp = strrchr(fib->fib_FileName, '.')) &&
		  (strcmp(nameTemp, ".font") == 0) &&
		  (fib->fib_DirEntryType < 0)) {
		/* filter any font contents that existed in a prior path */
		if (afh) {
		  for (i = memEntries; i < afh->afh_NumEntries; i++) {
		    if (flags & AFF_TAGGED) {
		      if (StrEquNC(fib->fib_FileName, ((struct TAvailFonts *)
			  &afh[1])[i].taf_Attr.tta_Name)) {
			D(("duplicate disk font name \"%s\"\n",
			    fib->fib_FileName));
			goto dupFontContinue;
		      }
		    }
		    else {
		      if (StrEquNC(fib->fib_FileName, ((struct AvailFonts *)
			  &afh[1])[i].af_Attr.ta_Name)) {
			D(("duplicate disk font name \"%s\"\n",
			    fib->fib_FileName));
			goto dupFontContinue;
		      }
a414 1
		  }
d416 139
a554 88
		/* try to open font contents file */
		fch.fch_FileID = 0;
		if (fcFile = Open(fib->fib_FileName, MODE_OLDFILE)) {
		  if (Read(fcFile, (char *) &fch, sizeof(fch)) == sizeof(fch)) {
		    D(("FileID 0x%04lx ", fch.fch_FileID));
		    if ((fch.fch_FileID & 0xfff0) == FCH_ID) {
		      for (i = 0; i < fch.fch_NumEntries; i++) {
			if (Read(fcFile, (char *) &tfc,
			    sizeof(struct TFontContents))
			    == sizeof(struct TFontContents)) {
			  tfc.tfc_Flags = (tfc.tfc_Flags & ~FPF_ROMFONT) |
			      FPF_DISKFONT;
			  if (FillBuffer(dfl, &buffer, &bufBottomUp, &bufBytes,
			      &bottomBytes, FilePart(fib->fib_FileName),
	                      (struct TTextAttr *) (((ULONG) &tfc.tfc_YSize)-4),
			      (struct TagList *) &tfc.tfc_FileName[MAXFONTPATH-
			      (TIS*(tfc.tfc_TagCount+1))],
			      AFF_DISK, flags & AFF_TAGGED,
			      fch.fch_FileID >= TFCH_ID))
			    (afh->afh_NumEntries)++;
			} /* Read tfc */
			else
			  /* don't try to continue to read font contents */
			  break;
		      } /* for fch_NumEntries */
		    } /* if FCH_ID */
		  } /* Read fch */
		  Close(fcFile);
		} /* Open .font */
		D(("flags $%lx\n", flags));
		if ((fch.fch_FileID == OFCH_ID) && (!(flags & AFF_BITMAP))) {
		  strcpy(nameTemp, OTSUFFIX);
		  D((".otag name \"%s\"\n", fib->fib_FileName));
		  fcFile = Open(fib->fib_FileName, MODE_OLDFILE);
		  D(("otag File 0x%lx, error %ld\n", fcFile, IoErr()));
		  strcpy(nameTemp, ".font");
		  if (fcFile) {
		    D((".otag open\n"));
		    if ((Read(fcFile, (char *) &tagItem, sizeof(tagItem))
			== sizeof(tagItem)) &&
			(tagItem.ti_Tag == OT_FileIdent) &&
			(ti = AllocVec(tagItem.ti_Data, 0))) {
		      D((".otag valid id, size %ld\n", tagItem.ti_Data));
		      if (Read(fcFile, (char *) (ti+1),
			  tagItem.ti_Data-sizeof(tagItem))
			  == tagItem.ti_Data-sizeof(tagItem)) {
			*ti = tagItem;		/* initialize first tag */
			i = GetTagData(OT_AvailSizes, 0, ti);
			D(("OT_AvailSizes ($%08lx): %ld\n", OT_AvailSizes, i));
			if (i) {
			  tTextAttr.tta_Style = 0;
			  if (GetTagData(OT_IsFixed, 0, ti))
			    tTextAttr.tta_Flags = FPF_DISKFONT;
			  else
			    tTextAttr.tta_Flags = FPF_DISKFONT|FPF_PROPORTIONAL;
			  if (GetTagData(OT_StemWeight, OTS_Medium, ti) >=
			      ((OTS_Medium+OTS_SemiBold)/2))
			    tTextAttr.tta_Style |= FSF_BOLD;
			  if (GetTagData(OT_SlantStyle, OTS_Upright, ti) !=
			      OTS_Upright)
			    tTextAttr.tta_Style |= FSF_ITALIC;
			  if (GetTagData(OT_HorizStyle, OTH_Normal, ti) >=
			      ((OTH_Normal+OTH_SemiExpanded)/2))
			    tTextAttr.tta_Style |= FSF_EXTENDED;
			  avail = (UWORD *) (((ULONG) ti) + i);
			  i = *avail++;
			  D((".otag %ld sizes\n", i));
			  while (i-- > 0) {
			    tTextAttr.tta_YSize = *avail++;
			    if (FillBuffer(dfl, &buffer, &bufBottomUp,
				&bufBytes, &bottomBytes,
				FilePart(fib->fib_FileName), &tTextAttr, 0, 
				AFF_DISK, flags & AFF_TAGGED, 0))
			      (afh->afh_NumEntries)++;
			  } /* each avail size */
			} /* OT_AvailSizes exists */
		      } /* read remaining ti */
		      FreeVec(ti);
		    } /* read OT_FileIdent and alloc ti */
		    Close(fcFile);
		  } /* Open .otag */
		} /* !AFF_BITMAP */
	      } /* if name OK & is file */
dupFontContinue:;
	    } /* while ExNext */
	    CurrentDir(prevCurrDir);
	  } /* if lock OK & Examines & is dir */
	  UnLock(fDirLock);		/* null is OK for UnLock */
d556 3
a558 6
	  dvp = (struct DevProc *) GetDeviceProc("FONTS:", dvp);
	  D(("next dvp 0x%lx\n", dvp));
	} /* while dvp */
	FreeDosObject(DOS_FIB, fib);
      } /* if fib */
    } /* if AFF_DISK */
d560 10
a569 2
    if (bufBytes < 0) return(-bufBytes);
    else return(0);
@


37.1
log
@fix $0 access, alpha 2 .otag access
@
text
@d2 1
a2 1
**	$Id$
d366 11
a376 3
	  fDirLock = DoPkt3(dvp->dvp_Port, ACTION_LOCATE_OBJECT,
	      dvp->dvp_Lock, MKBADDR(fib->fib_FileName), SHARED_LOCK);
	  D(("fDirLock 0x%lx\n", fDirLock));
d378 1
a378 2
	  if (fDirLock && Examine(fDirLock, fib) &&
	      (fib->fib_DirEntryType > 0)) {
d458 4
a461 1
			  tTextAttr.tta_Flags = FPF_DISKFONT | FPF_PROPORTIONAL;
d495 1
@


37.0
log
@check in first V37 bug fix before adding .otag code
perform caseless compare of font names when looking for duplicates
@
text
@d2 1
a2 1
**	$Header: Q2500:Src/Bullet/Diskfont/RCS/availfonts.c,v 36.14 90/04/10 09:49:57 kodiak Exp Locker: kodiak $
d6 2
d27 1
d40 3
a64 1
extern char *TailPath(char *);
a65 1

d109 5
a113 3
*		Any combination may be specified.  AFF_TAGGED is set
*		to fill the buffer with TAvailFonts elements instead
*		of AvailFonts elements.
d305 3
d318 3
a320 4
    afh = (struct AvailFontsHeader *) buffer;
    buffer += sizeof(*afh);
    bufBytes -= sizeof(*afh);
    if (bufBytes >= 0)
d322 5
d356 3
a358 1
      memEntries = afh->afh_NumEntries;	/* save number of non-disk entries */
d380 9
a388 9
		for (i = memEntries; i < afh->afh_NumEntries; i++) {
		  if (flags & AFF_TAGGED) {
		    /* avoid CXERR 25... */
		    nameTemp = ((struct TAvailFonts *) &afh[1])
			[i].taf_Attr.tta_Name;
		    if (StrEquNC(fib->fib_FileName, nameTemp)) {
		      D(("duplicate disk font name \"%s\"\n",
			  fib->fib_FileName));
		      goto dupFontContinue;
d390 7
a396 9
		  }
		  else {
		    /* avoid CXERR 25... */
		    nameTemp = ((struct AvailFonts *) &afh[1])
			[i].af_Attr.ta_Name;
		    if (StrEquNC(fib->fib_FileName, nameTemp)) {
		      D(("duplicate disk font name \"%s\"\n",
			  fib->fib_FileName));
		      goto dupFontContinue;
d401 1
d413 1
a413 1
			      &bottomBytes, TailPath(fib->fib_FileName),
d418 1
a418 1
			      fch.fch_FileID == TFCH_ID))
d428 51
a478 1
		} /* Open */
@


36.14
log
@provide both ExtendFont arguments, use graphics pragmas
@
text
@d2 1
a2 1
**	$Header: V36:src/workbench/libs/diskfont/RCS/availfonts.c,v 36.13 90/04/09 05:46:33 kodiak Exp $
d370 1
a370 1
		    if (strcmp(fib->fib_FileName, nameTemp) == 0) {
d380 1
a380 1
		    if (strcmp(fib->fib_FileName, nameTemp) == 0) {
@


36.13
log
@convert to both new rcs and native build
@
text
@d2 1
a2 1
**	$Header: Q:Src/diskfont/RCS/availfonts.c,v 36.13 90/04/09 04:59:41 kodiak Exp $
d39 1
d43 1
d54 1
d56 1
a56 1
#define	DOSBase		dfl->dfl_DOSBase
d328 1
a328 1
		ExtendFont(font);
@


36.12
log
@support assign paths in FONTS:
@
text
@d2 1
a2 1
**	$Header: availfonts.c,v 36.11 90/01/30 13:04:28 kodiak Exp $
d9 3
d13 1
d19 2
a20 9
#include	"exec/types.h"
#include	"exec/nodes.h"
#include	"exec/lists.h"
#include	"exec/ports.h"
#include	"dos/dos.h"
#include	"dos/dosextens.h"
#include	"graphics/gfxbase.h"
#include	"graphics/text.h"
#include	"utility/tagitem.h"
d22 2
d25 1
a25 3

extern char *rindex();
extern char *TailPath();
d27 37
a63 1
extern struct GfxBase *FetchGfxBase();
d152 4
a155 11
BOOL
FillBuffer(bufTopDown, bufBottomUp, bufBytes, bottomBytes, fontName, fontAttr,
fontTags, AFType, TTAFFlag, TFCFlag)
UBYTE **bufTopDown, **bufBottomUp;
LONG *bufBytes;
LONG *bottomBytes;
char *fontName;
struct TTextAttr *fontAttr;
struct TagList *fontTags;
UWORD AFType;
LONG TTAFFlag, TFCFlag;
d159 1
a159 1
    LONG *tagSearch, *tagEnd;
d162 1
a162 1
    int i, j;
d197 2
a198 2
		tagSearch = (LONG *) ((((ULONG) *bufBottomUp)+1) & 0xfffffffe);
		tagEnd = (LONG *) (((ULONG) tagSearch) + tagLen - TIS);
d205 2
a206 1
			    if (*tagEntry != *tagList2++)
d208 1
d215 2
a216 2
		    tagEnd = (LONG *) (((LONG) tagEnd) + 2);
		    tagSearch = (LONG *) (((LONG) tagSearch) + 2);
d263 1
a263 1
		taf->taf_Attr.tta_Tags = tagSearch;
d279 3
a281 4
int DFCAvailFonts(bufBytes, flags, buffer) /* swizzled for movem efficiency */
UBYTE *buffer;
LONG bufBytes;
ULONG flags;
d284 2
a285 2
    UBYTE *bufBottomUp;
    LONG bottomBytes;
d298 2
a299 2
    D(("AvailFonts(0x%06lx, %ld, 0x%02lx) TTATTR %s\n", buffer, bufBytes, flags,
	    (flags & AFF_TAGGED)?"set":"clear"));
d301 2
d318 1
a318 1
        font = (struct TextFont *) FetchGfxBase()->TextFonts.lh_Head;
d326 3
a328 3
                if (FillBuffer(&buffer, &bufBottomUp, &bufBytes, &bottomBytes,
                        font->tf_Message.mn_Node.ln_Name,
                        ((ULONG) &font->tf_YSize)-4,
d348 1
a348 1
	  fDirLock = DoPkt(dvp->dvp_Port, ACTION_LOCATE_OBJECT,
d358 1
a358 1
	      if ((nameTemp = rindex(fib->fib_FileName, '.')) &&
d364 4
a367 2
		    if (strcmp(fib->fib_FileName, ((struct TAvailFonts *)
			&afh[1])[i].taf_Attr.tta_Name) == 0) {
d374 4
a377 2
		    if (strcmp(fib->fib_FileName, ((struct AvailFonts *)
			&afh[1])[i].af_Attr.ta_Name) == 0) {
d386 1
a386 1
		  if (Read(fcFile, &fch, sizeof(fch)) == sizeof(fch)) {
d390 2
a391 1
			if (Read(fcFile, &tfc, sizeof(struct TFontContents))
d395 1
a395 1
			  if (FillBuffer(&buffer, &bufBottomUp, &bufBytes,
d397 2
a398 2
			      ((ULONG) &tfc.tfc_YSize)-4,
			      &tfc.tfc_FileName[MAXFONTPATH-
@


36.11
log
@(turn of debug kprintfs)
@
text
@d2 1
a2 1
**	$Header: availfonts.c,v 36.10 90/01/30 13:00:08 kodiak Exp $
d19 2
a20 1
#include	"libraries/dos.h"
d261 2
a262 1
    UWORD thisFontFlag;
d274 2
d310 80
a389 40
    if ((flags & AFF_DISK) &&
	(fib = (struct FileInfoBlock *) AllocMem(sizeof(*fib), 0))) {
      if (fDirLock = Lock("FONTS:", SHARED_LOCK)) {
        prevCurrDir = CurrentDir(fDirLock);
        if (Examine(fDirLock, fib) &&
            (fib->fib_DirEntryType > 0)) {
          while (ExNext(fDirLock, fib)) {
            if ((nameTemp = rindex(fib->fib_FileName, '.')) &&
                (strcmp(nameTemp, ".font") == 0) &&
                (fib->fib_DirEntryType < 0) &&
                (fcFile = Open(fib->fib_FileName, MODE_OLDFILE))) {
              if (Read(fcFile, &fch, sizeof(fch)) == sizeof(fch)) {
		D(("FileID 0x%04lx ", fch.fch_FileID));
                if ((fch.fch_FileID & 0xfff0) == FCH_ID) {
                  for (i = 0; i < fch.fch_NumEntries; i++) {
                    if (Read(fcFile, &tfc, sizeof(struct TFontContents))
                        == sizeof(struct TFontContents)) {
		      tfc.tfc_Flags = (tfc.tfc_Flags & ~FPF_ROMFONT) |
			  FPF_DISKFONT;
		      if (FillBuffer(&buffer, &bufBottomUp, &bufBytes,
			  &bottomBytes, TailPath(fib->fib_FileName),
			  ((ULONG) &tfc.tfc_YSize)-4,
			  &tfc.tfc_FileName[MAXFONTPATH-
			  (TIS*(tfc.tfc_TagCount+1))],
			  AFF_DISK, flags & AFF_TAGGED,
			  fch.fch_FileID == TFCH_ID))
			(afh->afh_NumEntries)++;
                    }
                  }
                }
              }
              Close(fcFile);
            }
          }
        }
        CurrentDir(prevCurrDir);
        UnLock(fDirLock);
      }
      FreeMem(fib, sizeof(*fib));
    }
@


36.10
log
@obsolete XATTR, introduce TAGGED
@
text
@d2 1
a2 1
**	$Header: availfonts.c,v 36.9 89/11/03 16:55:50 kodiak Exp $
d9 1
d11 3
@


36.9
log
@add example
@
text
@d2 1
a2 1
**	$Header: availfonts.c,v 36.8 89/10/03 14:05:11 kodiak Exp $
d9 1
a9 1
#define	D(a)
d18 1
d64 2
a65 2
*		Any combination may be specified.  AFF_XATTR is set
*		to fill the buffer with XAvailFonts elements instead
d70 1
a70 1
*		[X]AvailFonts elements, There will be duplicate entries
d112 1
d116 1
a116 1
fontX, AFType, XAFFlag, XFCFlag)
d121 2
a122 2
struct XTextAttr *fontAttr;
UWORD fontX;
d124 1
a124 1
LONG XAFFlag, XFCFlag;
d126 3
a128 1
    struct XAvailFonts *xaf;
d130 2
a131 2
    WORD nameLen;
    int i;
d136 1
a136 1
    for (i = 0; i <= (*bottomBytes - nameLen); i++) {
d141 1
a141 1
		goto failMatch;
d148 1
a148 1
failMatch:
d151 38
a188 4
    xaf = (struct XAvailFonts *) *bufTopDown;
    if (XAFFlag) {
        *bufBytes -= nameLen + sizeof(struct XAvailFonts);
        *bufTopDown += sizeof(struct XAvailFonts);
d196 1
a196 1
        xaf->xaf_Type = AFType;
d203 1
a203 1
            xaf->xaf_Attr.xta_Name = *bufBottomUp;
d206 1
a206 1
            xaf->xaf_Attr.xta_Name = nameSearch;
d208 26
a233 10
	D(("name \"%s\", ", xaf->xaf_Attr.xta_Name));
        xaf->xaf_Attr.xta_YSize = fontAttr->xta_YSize;
        xaf->xaf_Attr.xta_Style = fontAttr->xta_Style;
	D(("YSize %ld, Style 0x%lx, ", xaf->xaf_Attr.xta_YSize,
		xaf->xaf_Attr.xta_Style));
        if (XAFFlag && XFCFlag) {
            xaf->xaf_Attr.xta_Flags = fontAttr->xta_Flags | FPF_XTEXTATTR;
            xaf->xaf_Attr.xta_XSize = fontX;
	    D(("Flags 0x%lx, XSize %ld\n", xaf->xaf_Attr.xta_Flags,
		    xaf->xaf_Attr.xta_XSize));
d236 2
a237 2
            xaf->xaf_Attr.xta_Flags = fontAttr->xta_Flags;
	    D(("Flags 0x%lx\n", xaf->xaf_Attr.xta_Flags));
d254 1
a254 1
    struct TextFont *fontList;
d261 1
a261 1
    struct XFontContents xfc;
d265 2
a266 2
    D(("AvailFonts(0x%06lx, %ld, 0x%02lx) XATTR %s\n", buffer, bufBytes, flags,
	    (flags & AFF_XATTR)?"set":"clear"));
d281 3
a283 3
        fontList = (struct TextFont *) FetchGfxBase()->TextFonts.lh_Head;
        while (fontList->tf_Message.mn_Node.ln_Succ != 0) {
            if ((fontList->tf_Flags &
d288 1
d290 5
a294 3
                        fontList->tf_Message.mn_Node.ln_Name,
                        ((ULONG) &fontList->tf_YSize)-4, fontList->tf_XSize,
			thisFontFlag, flags & AFF_XATTR, TRUE))
d297 1
a297 1
	    fontList = (struct TextFont *) fontList->tf_Message.mn_Node.ln_Succ;
d317 3
a319 3
                    if (Read(fcFile, &xfc, sizeof(struct XFontContents))
                        == sizeof(struct XFontContents)) {
		      xfc.xfc_Flags = (xfc.xfc_Flags & ~FPF_ROMFONT) |
d323 5
a327 2
			  ((ULONG) &xfc.xfc_YSize)-4, xfc.xfc_XSize, AFF_DISK,
			  flags & AFF_XATTR, fch.fch_FileID == XFCH_ID))
@


36.8
log
@fix bug in availfonts of memory fonts
@
text
@d2 1
a2 1
**	$Header: availfonts.c,v 36.7 89/09/11 12:26:33 kodiak Exp $
d52 1
a52 1
*  INPUTS
d67 1
a67 1
*  RESULTS
d80 29
@


36.7
log
@use FetchGfxBase as part of making ROMable
@
text
@d2 1
a2 1
**	$Header: availfonts.c,v 36.6 89/09/08 11:50:19 kodiak Exp $
d182 3
a194 1
    D(("AvailFonts() -- XATTR set? 0x%lx\n", flags & AFF_XATTR));
d207 2
a208 2
                        &fontList->tf_YSize, fontList->tf_XSize, thisFontFlag,
			flags & AFF_XATTR, TRUE))
@


36.6
log
@swizzled parameters to AvailFonts C code for movem efficiency
updated autodoc to include AFF_XATTR
added Forbid/Permit loop around memory font list access
@
text
@d2 1
a2 1
**	$Header: availfonts.c,v 36.5 89/05/17 12:19:39 kodiak Exp $
d24 1
a24 1
extern struct GfxBase *GfxBase;
d26 1
d163 1
a163 1
int AvailFonts(bufBytes, flags, buffer)	/* swizzled for movem efficiency */
d196 1
a196 1
        fontList = (struct TextFont *) GfxBase->TextFonts.lh_Head;
@


36.5
log
@disable debugging
@
text
@d2 1
a2 1
**	$Header: availfonts.c,v 36.4 89/05/17 12:16:48 kodiak Exp $
d27 54
a80 50
 *
 *  NAME
 *	AvailFonts - build an array of all fonts in memory / on disk
 *
 *  SYNOPSIS
 *	error = AvailFonts(buffer, bufBytes, types);
 *	                   A0      D0        D1
 *
 *  FUNCTION
 *	AvailFonts fills a user supplied buffer with the structure,
 *	described below, that contains information about all the
 *	fonts available in memory and/or on disk.  Those fonts
 *	available on disk need to be loaded into memory and opened
 *	via OpenDiskFont, those already in memory are accessed via
 *	OpenFont.  The TextAttr structure required by the open calls
 *	is part of the information AvailFonts supplies.
 *
 *	When AvailFonts fails, it returns the number of extra bytes
 *	it needed to complete the command.  Add this number to your
 *	current buffer size, allocate a new buffer, and try again.
 *	If the second AvailFonts call fails, abort the operation.
 *
 *  INPUTS
 *	buffer - memory to be filled with struct AvailFontsHeader
 *		followed by an array of AvailFonts elements, which
 *		contains entries for the available fonts and their
 *		names.
 *	
 *	bufBytes - the number of bytes in the buffer
 *	types - AFF_MEMORY is set to search memory for fonts to fill
 *		the structure, AFF_DISK is set to search the disk for
 *		fonts to fill the structure.  AFF_SCALED is set to
 *		not filter out memory fonts that are not designed.
 *		Any combination may be specified.
 *
 *  RESULTS
 *	buffer - filled with struct AvailFontsHeader followed by the
 *		AvailFonts elements, There will be duplicate entries
 *		for fonts found both in memory and on disk, differing
 *		only by type.  The existance of a disk font in the
 *		buffer indicates that it exists as an entry in a font
 *		contents file -- the underlying font file has not been
 *		checked for validity, thus an OpenDiskFont of it may
 *		fail.
 *	error - if non-zero, this indicates the number of bytes needed
 *		for AvailFonts in addition to those supplied.  Thus
 *		structure elements were not returned because of
 *		insufficient bufBytes.
 *
 ********************************************************************/
d162 1
a162 1
int AvailFonts(buffer, bufBytes, flags)
d194 1
d208 1
a208 1
        fontList = (struct TextFont *) fontList->tf_Message.mn_Node.ln_Succ;
d210 1
@


36.4
log
@fix to work w/ new font contents format
fix code to share name strings
@
text
@d2 1
a2 1
**	$Header: availfonts.c,v 36.3 89/05/16 17:03:26 kodiak Exp $
d9 1
a9 1
#define	D(a)	kprintf a
@


36.3
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Header$
d9 1
d80 1
a80 1
AFType, XAFFlag, XFCFlag)
d86 1
d91 1
a91 1
    char *nameSource, *nameSearch;
d96 1
d98 14
a111 10
    nameLen = -1;
    for (i = 0; i < *bottomBytes, nameSearch[i] != *fontName; i++) {
        nameLen = i;
        for (nameSource = fontName;
                i < *bottomBytes, nameSearch[i] == *nameSource++,
                nameSearch[i] != '\0'; i++);
        if ((i == *bottomBytes) || (nameSearch[i] != '\0'))
            nameLen = -1;
        else
            break;
a112 10
    if (nameLen == -1) {
        /* name not already in buffer */
        nameLen = 1;
        while(*fontName++ != '\0') nameLen++;
    }
    else {
        /* name already in buffer */
        nameSearch = *bufBottomUp + nameLen;
        nameLen = 0;
    }
d123 1
d126 3
d130 1
a130 1
                *(--*bufBottomUp) = *--fontName;
a131 1
            *bottomBytes += nameLen;
d133 1
a133 1
        else
d135 2
d139 2
d142 4
a145 3
            xaf->xaf_Attr.xta_Flags = fontAttr->xta_Flags
                    | FPF_XTEXTATTR | FPF_DISKFONT;
            xaf->xaf_Attr.xta_XSize = fontAttr->xta_XSize;
d148 2
a149 1
            xaf->xaf_Attr.xta_Flags = fontAttr->xta_Flags | FPF_DISKFONT;
d153 1
d187 1
d199 2
a200 2
                        &fontList->tf_YSize, thisFontFlag, flags & AFF_XATTR,
                        TRUE))
d219 2
a220 1
                if (fch.fch_FileID == FCH_ID) {
a221 11
                    if (Read(fcFile, &xfc, sizeof(struct FontContents))
                        == sizeof(struct FontContents)) {
		      if (FillBuffer(&buffer, &bufBottomUp, &bufBytes,
			  &bottomBytes, TailPath(fib->fib_FileName),
			  &xfc, AFF_DISK, flags & AFF_XATTR, FALSE))
			(afh->afh_NumEntries)++;
                    }
                  }
                }
                else if (fch.fch_FileID == XFCH_ID) {
                  for (i = 0; i < fch.fch_NumEntries; i++) {
d224 2
d228 2
a229 1
			  &xfc, AFF_DISK, flags & AFF_XATTR, TRUE))
@


36.2
log
@support for inquiry flag to inhibit learning about scaled fonts
autodoc changes
@
text
@d1 8
a8 7
#include        "exec/types.h"
#include        "exec/nodes.h"
#include        "exec/lists.h"
#include        "exec/ports.h"
#include        "libraries/dos.h"
#include        "graphics/gfxbase.h"
#include        "graphics/text.h"
d10 9
a18 1
#include        "diskfont.h"
@


36.1
log
@ensure DISKFONT is set in disk entries
@
text
@d1 7
a7 7
#include	"exec/types.h"
#include	"exec/nodes.h"
#include	"exec/lists.h"
#include	"exec/ports.h"
#include	"libraries/dos.h"
#include	"graphics/gfxbase.h"
#include	"graphics/text.h"
d9 1
a9 1
#include	"diskfont.h"
d23 1
a23 1
 *			   A0	   D0	     D1
d34 5
d48 3
a50 1
 *		fonts to fill the structure.  Both can be specified.
d67 75
d147 3
a150 2
    struct AvailFontsHeader *afh;
    struct AvailFonts *af;
d152 1
a152 3
    UWORD nameLen;
    UBYTE *names, *nameTemp;
    int i;
d155 1
d157 1
a157 1
    struct FontContents fc;
d159 2
d166 1
a166 4
	afh->afh_NumEntries = 0;
    /* initialize the af pointer */
    if (bufBytes >= 0)
	af = (struct AvailFonts *) buffer;
d168 20
a187 24
    names = buffer;
    names += bufBytes;
    if (flags & AFF_MEMORY) {
	fontList = (struct TextFont *) GfxBase->TextFonts.lh_Head;
	while (fontList->tf_Message.mn_Node.ln_Succ != 0) {
	    nameTemp = fontList->tf_Message.mn_Node.ln_Name;
	    nameLen = 1;
	    while(*nameTemp++ != '\0') nameLen++;
	    names -= nameLen;
	    bufBytes -= nameLen + sizeof(*af);
	    if (bufBytes >= 0) {
		nameTemp = fontList->tf_Message.mn_Node.ln_Name;
		for (i = 0; i < nameLen; i++)
		    names[i] = *nameTemp++;
		af->af_Type = AFF_MEMORY;
		af->af_Attr.ta_Name = names;
		af->af_Attr.ta_YSize = fontList->tf_YSize;
		af->af_Attr.ta_Style = fontList->tf_Style;
		af->af_Attr.ta_Flags = fontList->tf_Flags;
		(afh->afh_NumEntries)++;
		af++;
	    }
	fontList = (struct TextFont *) fontList->tf_Message.mn_Node.ln_Succ;
	}
d190 45
a234 52
    if (flags & AFF_DISK)
	if (fib = (struct FileInfoBlock *) AllocMem(sizeof(*fib), 0)) {
	    if (fDirLock = Lock("FONTS:", SHARED_LOCK)) {
		prevCurrDir = CurrentDir(fDirLock);
		if ( Examine(fDirLock, fib) &&
			(fib->fib_DirEntryType > 0) ) {
		    while ( ExNext(fDirLock, fib) ) {
			if ( (nameTemp = rindex(fib->fib_FileName, '.')) &&
				(strcmp(nameTemp, ".font") == 0) &&
				(fib->fib_DirEntryType < 0) &&
				(fcFile =
					Open(fib->fib_FileName, MODE_OLDFILE))
				) {
			    nameTemp = TailPath(fib->fib_FileName);
			    nameLen = 1;
			    while(*nameTemp++ != '\0') nameLen++;
			    names -= nameLen;
			    bufBytes -= nameLen;
			    if (bufBytes >= 0) {
				nameTemp = fib->fib_FileName;
				for (i = 0; i < nameLen; i++)
				    names[i] = *nameTemp++;
			    }
			    if ( (Read(fcFile, &fch, sizeof(fch))
					== sizeof(fch)) &&
				    (fch.fch_FileID == FCH_ID) ) {
				for (i = 0; i < fch.fch_NumEntries; i++) {
				    if (Read(fcFile, &fc, sizeof(fc))
					    == sizeof(fc)) {
					bufBytes -= sizeof(*af);
					if (bufBytes >= 0) {
					    af->af_Type = AFF_DISK;
					    af->af_Attr.ta_Name = names;
					    af->af_Attr.ta_YSize = fc.fc_YSize;
					    af->af_Attr.ta_Style = fc.fc_Style;
					    af->af_Attr.ta_Flags = fc.fc_Flags
						    | FPF_DISKFONT;
					    (afh->afh_NumEntries)++;
					    af++;
					}
				    }
				}
			    }
			    Close(fcFile);
			}
		    }
		}
		CurrentDir(prevCurrDir);
		UnLock(fDirLock);
	    }
	    FreeMem(fib, sizeof(*fib));
	}
@


36.0
log
@*** empty log message ***
@
text
@d148 2
a149 1
					    af->af_Attr.ta_Flags = fc.fc_Flags;
@
