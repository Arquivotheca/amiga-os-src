head     39.1;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


39.1
date     92.07.14.08.08.30;  author darren;  state Exp;
branches ;
next     39.0;

39.0
date     92.07.08.14.36.10;  author darren;  state Exp;
branches ;
next     38.7;

38.7
date     92.03.26.11.56.49;  author davidj;  state Exp;
branches ;
next     38.6;

38.6
date     91.04.12.20.32.14;  author kodiak;  state Exp;
branches ;
next     38.5;

38.5
date     91.04.11.17.05.57;  author kodiak;  state Exp;
branches ;
next     38.4;

38.4
date     91.04.09.21.22.39;  author kodiak;  state Exp;
branches ;
next     38.3;

38.3
date     91.04.03.18.42.22;  author kodiak;  state Exp;
branches ;
next     38.2;

38.2
date     91.03.24.17.11.12;  author kodiak;  state Exp;
branches ;
next     38.0;

38.0
date     91.02.25.14.43.06;  author kodiak;  state Exp;
branches ;
next     37.1;

37.1
date     91.01.31.14.43.13;  author kodiak;  state Exp;
branches ;
next     37.0;

37.0
date     90.11.26.12.45.11;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


39.1
log
@Ask engine for Underlining if supported (first Broken like Text() does,
but if not, try Solid also).  If neither, try for best non-underlined
font.
@
text
@/*
 * ISSUES:
 *   if alloc char ptr arrays here, can make diskfont romable again?
 */
/*
**	$Id: genfont.c,v 39.0 92/07/08 14:36:10 darren Exp Locker: darren $
**
**      diskfont.library outline font generation
**
**      (C) Copyright 1992 Commodore-Amiga, Inc.
**	    All Rights Reserved
**
**	(C) Copyright 1990 Robert R. Burns
**	    All Rights Reserved
*/
#define YSIZEFACTOR
/*	debug switches */

#ifdef	DEBUG
extern void kprintf(char *,...);
#define DS(a)	kprintf a
#define	D(a)	kprintf a
#define DD(a)
#else
#define DS(a)
#define	D(a)
#define DD(a)
#endif


/*	includes */

#include <exec/types.h>
#include <exec/memory.h>

#include <string.h>
#undef    strcat
#undef    strcmp
#undef    strcpy
#undef    memcpy
#include <setjmp.h>

#include "diskfont.h"
#include <diskfont/diskfonttag.h>
#include <diskfont/glyph.h>

#include "dfdata.h"

#include <clib/exec_protos.h>
#include <clib/dos_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <pragmas/exec_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/utility_pragmas.h>

/*	exports */

/*	imports */

#define	SysBase		dfl->dfl_SysBase
#define	DOSBase		dfl->dfl_DOSBase
#define	GfxBase		dfl->dfl_GfxBase
#define	UtilityBase	dfl->dfl_UtilityBase

/*	locals */
#define  OFONT_TAGCNT	4	/* Points, DPI, DotSize, DONE */

static struct GlyphEngine *glyphEngine;

static struct GlyphMap *charMaps[257];

static UWORD ySize, spaceWidth, yBaseOrigin, loCode, destMod;
static ULONG undefLoc;
static UWORD undefCode, undefKern, undefSpace;


struct TagItem *readOTag(struct DiskfontLibrary *dfl,
	char *fontPath, char *otagName)
{
    ULONG otFile;
    struct TagItem tag, *tags;
    struct Library *glyphLibrary;
    char tempName[256], *s, failure;
    int error, i;

    tags = 0;
    failure = TRUE;

    /* generate .otag file path */
    strcpy(tempName, fontPath);

    s = FilePart(tempName);
    strcpy(s, otagName);
    strcat(s, OTSUFFIX);

    D((".otag name %s\n", tempName));

    /* open .otag file */
    if (!(otFile = Open(tempName, MODE_OLDFILE))) {
	D(("no associated .otag file\n"));
	goto OTEND;
    }

    /* read and verify the .otag */
    if (Read(otFile, &tag, sizeof(tag)) != sizeof(tag)) {
	D(("otFile read fail (8 bytes)\n"));
	goto OTEND;
    }
    if (tag.ti_Tag != OT_FileIdent) {
	D((".otag first tag $%lx, not $%lx\n", tag.ti_Tag, OT_FileIdent));
	goto OTEND;
    }

    D(("OT_FileIdent %ld\n", tag.ti_Data));

    Seek(otFile, 0, OFFSET_END);
    if (Seek(otFile, 0, OFFSET_BEGINNING) != tag.ti_Data) {
	D((".otag file size wrong\n"));
	goto OTEND;
    }
    if (!(tags = (struct TagItem *) AllocVec(tag.ti_Data, 0))) {
	D(("tags allocation failure\n"));
	goto OTEND;
    }

    /* this is a valid .otag file header */
    if (Read(otFile, tags, tag.ti_Data) != tag.ti_Data) {
	D(("tags read failure\n"));
	goto OTEND;
    }

    /* patch indirect pointers */
    for (i = 0; i < tag.ti_Data/sizeof(struct TagItem); i++) {
	if (tags[i].ti_Tag == TAG_DONE)
	    break;
	if (tags[i].ti_Tag & OT_Indirect)
	    tags[i].ti_Data += (ULONG) tags;
    }

    /* ensure the associated glyph library is open */
    /* get the library name */
    if (!(s = (char *) GetTagData(OT_Engine, 0, tags))) {
	D(("no OT_Engine tag\n"));
	goto OTEND;
    }
    if ((glyphEngine)
	    /* validate existing engine */
	    && strcmp(s, glyphEngine->gle_Name)) {
	/* different engine name */
	glyphLibrary = glyphEngine->gle_Library;
	ECloseEngine(glyphEngine);
	glyphEngine = 0;
	CloseLibrary(glyphLibrary);
    }
    if (!glyphEngine) {
	/* get new engine */
	strcpy(tempName, s);
	strcat(tempName, ".library");
	glyphLibrary = OpenLibrary(tempName, 0);
	if (!glyphLibrary) {
	    D(("OpenLibrary \"%s\" failure\n", tempName));
	    goto OTEND;
	}
	glyphEngine = (struct GlyphEngine *) EOpenEngine(glyphLibrary);
	if (!glyphEngine) {
	    D(("OpenEngine \"%s\" failure\n", tempName));
	    CloseLibrary(glyphLibrary);
	    goto OTEND;
	}
    }

    error = ESetInfo(glyphEngine, OT_OTagPath, fontPath,
	    OT_OTagList, tags, TAG_DONE);

    if (error) {
	D(("ESetInfo(OT_OTag...) failed %ld\n", error));
	glyphLibrary = glyphEngine->gle_Library;
	ECloseEngine(glyphEngine);
	CloseLibrary(glyphLibrary);
	glyphEngine = 0;
	goto OTEND;
    }

    failure = FALSE;

OTEND:
    if (otFile)
	Close(otFile);
    if (failure) {
	FreeVec(tags);
	tags = 0;
    }
    return(tags);
}


UWORD imageCode(struct DiskFontHeader *dfh, UWORD code, UWORD bitstart,
	UBYTE forceWhite)
{
    struct GlyphMap *cbm;
    UWORD bitwidth;
    short kern, space;
    UWORD srcMod, *srcY, *src, srcShift, srcEnd;
    UWORD blackTop, blackHeight;
    WORD yOrigin;
    UWORD *destY, *dest, destShift;
    short x, y;

    if (cbm = charMaps[code]) {
	bitwidth = cbm->glm_BlackWidth;
	if (!bitwidth) {
	    ((ULONG *) dfh->dfh_TF.tf_CharLoc)[code-loCode] = 0;
	    ((WORD *) dfh->dfh_TF.tf_CharKern)[code-loCode] = 0;
	    ((WORD *) dfh->dfh_TF.tf_CharSpace)[code-loCode] =
		    cbm->glm_X1-cbm->glm_X0;
	    DD(("code %ld, no bits, CharSpace %ld\n",
		code, cbm->glm_X1-cbm->glm_X0));
	    return(0);
	}
	((ULONG *) dfh->dfh_TF.tf_CharLoc)[code-loCode] =
		(bitstart<<16) | bitwidth;
 	/* rounded off */
	kern = cbm->glm_BlackLeft-cbm->glm_X0;
 	space = cbm->glm_X1-cbm->glm_X0-kern;
	if (forceWhite) {
	    if (forceWhite & 0x02) {
		DD(("kern %ld -> ", kern));
		/* force left */
		if (kern <= 0)
		    kern++;
		DD(("%ld\n", kern));
	    }
	    else {
		/* force right */
		DD(("bitwidth %ld space %ld -> ", bitwidth, space));
		if (space <= bitwidth)
		    space++;
		DD(("%ld\n", space));
	    }
	}
	((WORD *) dfh->dfh_TF.tf_CharKern)[code-loCode] = kern;
	((WORD *) dfh->dfh_TF.tf_CharSpace)[code-loCode] = space;
	DD(("code %ld, CharLoc $%08lx, CharSpace %ld, CharKern %ld\n",
		code, ((ULONG *) dfh->dfh_TF.tf_CharLoc)[code-loCode],
		space, kern));

	yOrigin = cbm->glm_Y0;
	blackTop = cbm->glm_BlackTop;
	blackHeight = cbm->glm_BlackHeight;

	/* truncate to ySize */
	if (blackHeight > ySize) {
	    DS(("truncate %ld blackHeight %ld to %ld, blackTop %ld to %ld\n",
		    code, blackHeight, ySize,
		    blackTop, blackTop+(ySize-blackHeight)/2));
	    blackTop += (blackHeight-ySize)/2;
	    blackHeight = ySize;
	}
	if ((yBaseOrigin+blackTop+blackHeight-ySize) > yOrigin) {
	    D(("shift %ld yOrigin up (%ld to %ld)\n",
		    code, yOrigin, yBaseOrigin+blackTop+blackHeight-ySize));
	    yOrigin = yBaseOrigin+blackTop+blackHeight-ySize;
	}
	else if ((yBaseOrigin+blackTop) < yOrigin) {
	    D(("shift %ld yOrigin down (%ld to %ld)\n",
		    code, yOrigin, yBaseOrigin+blackTop));
	    yOrigin = yBaseOrigin+blackTop;
	}
	srcMod = cbm->glm_BMModulo>>1;
	srcY = ((UWORD *) (cbm->glm_BitMap+(cbm->glm_BMModulo*blackTop))) +
		(cbm->glm_BlackLeft>>4);
	srcShift = cbm->glm_BlackLeft&0xf;
	srcEnd = cbm->glm_BlackWidth+srcShift;
	srcShift = 0x10-srcShift;
	destY = ((UWORD *) dfh->dfh_TF.tf_CharData)+(bitstart>>4)+(destMod*
		(yBaseOrigin-(yOrigin-blackTop)));
	destShift = 0x10-(bitstart&0xf);
	DD(("  srcY $%lx, srcMod %ld, srcShift %ld, srcEnd %ld\n",
		srcY, srcMod, srcShift, srcEnd));
	DD(("  destY $%lx, destShift %ld\n",
		destY, destShift));
	for (y = blackHeight; y > 0; y--) {
	    src = srcY;
	    dest = destY;
	    for (x = srcEnd; x > 0; x-=16) {
		DD(("  dest $%04lx @@ $%lx, src $%04lx-%04lx : %08lx\n",
			*dest, dest, src[0], src[1],
			(((*((ULONG *) src))>>srcShift)&0xffff)<<destShift));
		*((ULONG *) dest) |=
			(((*((ULONG *) src))>>srcShift)&0xffff)<<destShift;
		src++;
		dest++;
	    }
	    srcY += srcMod;
	    destY += destMod;
	}
	if (code == undefCode) {
	    undefLoc = (bitstart<<16) | bitwidth;
	    undefKern = kern;
	    undefSpace = space;
	}
    }
    else {
	bitwidth = 0;

	if (code == undefCode) {
	    undefLoc = 0;
	    undefKern = 0;
	    undefSpace = 0;
	}

	if ((code == ' ') || (code == 0xa0)) {
	    ((UWORD *) dfh->dfh_TF.tf_CharSpace)[code-loCode] = spaceWidth;
	}
	else {
	    ((ULONG *) dfh->dfh_TF.tf_CharLoc)[code-loCode] = undefLoc;
	    ((WORD *) dfh->dfh_TF.tf_CharKern)[code-loCode] = undefKern;
	    ((WORD *) dfh->dfh_TF.tf_CharSpace)[code-loCode] = undefSpace;
	}
	DD(("code %ld, CharLoc $%08lx, CharSpace %ld, CharKern %ld (undef)\n",
		code, ((ULONG *) dfh->dfh_TF.tf_CharLoc)[code-loCode],
		undefKern, undefSpace));
    }
    return(bitwidth);
}


struct TextFont * __saveds GenFont(struct DiskfontLibrary *dfl, char *fontPath,
	struct TTextAttr *tta, struct FontContentsHeader *fch,
	struct TFontContents *tfc, struct TextFont *tfRam,
	WORD wRam)
{
    struct TagItem *tags, *ti;
    UWORD dpiX, dpiY, dpiX2, dpiY2;
    UWORD dotX, dotY;
    FIXED points, temp;
    UWORD ySize2m, ySize2o, ySize2b;
    union {
	ULONG t;			/* tag */
	struct {
	    UWORD n;			/* numerator */
	    UWORD d;			/* denominator */
	} w;
    } ySizeFactor;
    struct TTextAttr ttaLocal;
    struct TagItem dpiTags[3];
    UWORD *sizes;
    struct DiskFontHeader *dfh;
    struct TextFont *tf;
    struct Library *glyphLibrary;
    struct GlyphMap *cbm;
    ULONG *p, allocSize;
    char *s;
    short code, hiCode, ascent, descent, yOrigin;
    short whiteLeft, whiteRight, whiteBoth;
    UWORD w, bitwidth, bitstart;
    int i, cnt, x, y;
    short xSize, width, width2, kern, space;
    long error;
    char otName[32];
    UBYTE tfStyle;

    D(("GenFont(,\"%s\", { \"%s\", %ld, $%lx, $%lx, $%lx }, ) \n",
	    fontPath, tta->tta_Name, tta->tta_YSize, tta->tta_Style,
	    tta->tta_Flags, tta->tta_Tags));

    tags = 0;
    for (code = 0; code < 257; code++) {
	charMaps[code] = 0;
    }
    glyphEngine = 0;
    dfh = 0;
    tf = 0;

    if (tta->tta_Flags & FPF_REVPATH)
	/* cannot do REVPATH work here */
	goto gfEndgame;

    /* get associated .otag file */
    strcpy(otName, tta->tta_Name);
    if (!(s = strrchr(otName, '.'))) {
	D(("no '.' in fontPath name\n"));
	goto gfEndgame;
    }
    *s = '\0';
    tags = readOTag(dfl, fontPath, otName);

    if (!tags) {
	D(("no valid .otag file\n"));
	goto gfEndgame;
    }

    tfStyle = FSF_TAGGED;
    if (GetTagData(OT_StemWeight, OTS_Medium, tags) >=
	    ((OTS_Medium+OTS_SemiBold)/2))
	tfStyle |= FSF_BOLD;
    if (GetTagData(OT_SlantStyle, OTS_Upright, tags) != OTS_Upright)
	tfStyle |= FSF_ITALIC;
    if (GetTagData(OT_HorizStyle, OTH_Normal, tags) >=
	    ((OTH_Normal+OTH_SemiExpanded)/2))
	tfStyle |= FSF_EXTENDED;

#if 0
    /* find alternate font for style */
    s = 0;
    x = GetTagData(OT_StemWeight, OTS_Medium, tags);
    y = GetTagData(OT_SlantStyle, OTS_Upright, tags);
    if ((tta->tta_Style & (FSF_ITALIC|FSF_BOLD)) == (FSF_ITALIC|FSF_BOLD)) {
	if ((x < ((OTS_Medium+OTS_SemiBold)/2)) && (y == OTS_Upright)) {
	    s = GetTagData(dfl, OT_BIName, tags);
	    tfStyle = FSF_ITALIC|FSF_BOLD|FSF_TAGGED;
	}
    }
    if ((!s) && (tta->tta_Style & FSF_ITALIC)) {
	/* ensure italic */
	if (y == OTS_Upright) {
	    s = GetTagData(dfl, OT_IName, tags);
	    tfStyle = FSF_ITALIC|FSF_TAGGED;
	}
    }
    if ((!s) && (tta->tta_Style & FSF_BOLD)) {
	/* ensure bold */
	if (x < ((OTS_Medium+OTS_SemiBold)/2)) {
	    s = GetTagData(dfl, OT_BName, tags);
	    tfStyle = FSF_BOLD|FSF_TAGGED;
	}
    }
    if (s) {
	if (ti = readOTag(dfl, fontPath, s)) {
	    FreeVec(tags);
	    tags = ti;
	    strcpy(otName, s);
	}
	else
	    tfStyle = FSF_TAGGED;
    }
#endif

    /* get default environment */
    if (ti = FindTagItem(OT_DeviceDPI, tags)) {
	dpiX = ti->ti_Data>>16;
	dpiY = ti->ti_Data & 0xffff;
    }
    else {
	dpiX = dfl->dfl_XDPI;
	dpiY = dfl->dfl_YDPI;
    }
    if (ti = FindTagItem(OT_DotSize, tags)) {
	dotX = ti->ti_Data>>16;
	dotY = ti->ti_Data & 0xffff;
    }
    else {
	dotX = dfl->dfl_DotSizeX;
	dotY = dfl->dfl_DotSizeY;
    }

    /* determine size metrics */
    points = 0;
    D(("default: dpiX %ld, dpiY %ld, dotX %ld, dotY %ld\n",
	    dpiX, dpiY, dotX, dotY));
    if (tta->tta_Style & FSF_TAGGED) {
	D(("look at tta_Tags at $%lx\n", tta->tta_Tags));
	if (ti = FindTagItem(OT_DeviceDPI, tta->tta_Tags)) {
	    dpiX = ti->ti_Data>>16;
	    dpiY = ti->ti_Data & 0xffff;
	}
	if (ti = FindTagItem(OT_DotSize, tta->tta_Tags)) {
	    dotX = ti->ti_Data>>16;
	    dotY = ti->ti_Data & 0xffff;
	}
	points = GetTagData(OT_PointHeight, 0, tta->tta_Tags);
	if (points == 0)
	    points = GetTagData(OT_PointSize, 0, tta->tta_Tags) << 12;
	D(("after tag: dpiX %ld, dpiY %ld, dotX %ld, dotY %ld\n",
		dpiX, dpiY, dotX, dotY));
    }
    ySizeFactor.t = GetTagData(OT_YSizeFactor, 0x10001, tags);
    if (!points) {
	ySize = tta->tta_YSize;

	if (tta->tta_Flags & FPF_DESIGNED) {
	    D(("designed...\n"));
	    /* no scaling, find greatest smaller size */
	    ySize2m = 32768;
	    ySize2o = ySize2b = 0;
	    if (sizes = (UWORD *) GetTagData(OT_AvailSizes, 0, tags)) {
		cnt = *sizes++;
		D(("%ld o sizes\n", cnt));
		if (cnt) {
		    ySize2m = *sizes;
		    D(("first %ld <= %ld?\n", ySize2m, ySize));
		    if (ySize2m <= ySize) {
			for (; (cnt > 0) & (*sizes <= ySize); cnt--, sizes++)
			    D(("  %ld <= %ld?\n", *sizes, ySize));
			ySize2o = *--sizes;
			D(("  ySize2o %ld\n", ySize2o));
		    }
		}
	    }

	    for (i = 0; i < fch->fch_NumEntries; i++) {
		if (tfc[i].tfc_YSize < ySize2m)
		    ySize2m = tfc[i].tfc_YSize;
		if ((tfc[i].tfc_YSize <= ySize) &&
			(tfc[i].tfc_YSize > ySize2b)) {
		    ySize2b = tfc[i].tfc_YSize;
		    D(("  ySize2b %ld\n", ySize2b));
		}
	    }

	    ySize2o = (ySize2o > ySize2b) ? ySize2o : ySize2b;
	    if (ySize2o)
		ySize = ySize2o;
	    else if (ySize2m != 32767)
		ySize = ySize2m;
	}

	D(("  ySizeFactor %ld / %ld\n", ySizeFactor.w.n, ySizeFactor.w.d));
#ifdef  YSIZEFACTOR
	dpiX = 72 * dpiX / dpiY * ySizeFactor.w.n / ySizeFactor.w.d;
	dpiY = 72 * ySizeFactor.w.n / ySizeFactor.w.d;
#else
	dpiX = 72 * dpiX / dpiY;
	dpiY = 72;
#endif
	points = ySize<<16;
    }
    else {
#ifdef  YSIZEFACTOR
	ySize = ((points / 72 * dpiY / ySizeFactor.w.n * ySizeFactor.w.d)
		+0x8000)>>16;
#else
	ySize = (points+0x8000)>>16;
#endif
    }

    /* Determine if engine can do underlining if requested; default must
       be no underlining per docs/specs.   We prefer to have Broken
       underlining like gfx Text() would do, but will accept Solid if
       Broken is not supported.

       Assumptions:

	Underlined is not an intrinsic font style, but rather something
	generated by the engine 
    */

    if(tta->tta_Style & FSF_UNDERLINED)
    {
	D(("Underlined requested\n"));

	    /* Set in outline style, but clear in copy of TextAttr */

	    tfStyle |= FSF_UNDERLINED;
	    tta->tta_Style &= ~FSF_UNDERLINED;

	    /* Ask engine for Broken underlining, or Solid, but if neither,
	       this engine cannot underline, and we do not bother searching
	       for an underlined ram font.
	    */

	    if (error = ESetInfo(glyphEngine, OT_UnderLined, OTUL_Broken,
	    	TAG_DONE))
	    {
		if(error = ESetInfo(glyphEngine, OT_UnderLined, OTUL_Solid,
		   TAG_DONE))
		{
			D(("OTERR %ld - Underlining not supported\n",(ULONG)error));
			tfStyle &= ~FSF_UNDERLINED;
		}
	    }
    }

    /* re-look for memory match */
    s = otName + strlen(otName);
    strcpy(s, ".font");
    ttaLocal.tta_Name = otName;
    ttaLocal.tta_YSize = ySize;
    ttaLocal.tta_Style = tfStyle | tta->tta_Style;	/* tfStyle is TAGGED */
    ttaLocal.tta_Flags = 0;
    dpiTags[0].ti_Tag = TA_DeviceDPI;
    dpiTags[0].ti_Data = (dpiX<<16)|dpiY;
    dpiTags[1].ti_Tag = OT_DotSize;
    dpiTags[1].ti_Data = (dotX<<16)|dotY;
    dpiTags[2].ti_Tag = TAG_DONE;
    ttaLocal.tta_Tags = dpiTags;
    tf = OpenFont((struct TextAttr *) &ttaLocal);
    D(("OpenFont({ \"%s\", %ld, $%02lx, $%02lx, })...\n", otName, ySize,
	    ttaLocal.tta_Style, ttaLocal.tta_Flags));
    if (tf) {
	D(("  ram YSize %ld, Style 0x%02lx, Flags0x%02lx\n",
	    tf->tf_YSize, tf->tf_Style, tf->tf_Flags));
	/* get the weight for the resulting ram font */
	w = WeighTAMatch((struct TextAttr *) &ttaLocal,
		(struct TextAttr *) (((ULONG) &tf->tf_YSize)-4),
		((struct TextFontExtension *) tf->tf_Extension)->tfe_Tags);
	D(("tf 0x%lx, w %ld\n", tf, w));
        if (w == MAXFONTMATCHWEIGHT) {
            /* exact match: cannot get better from here! */
	    if (tfRam)
		CloseFont(tfRam);
	    tfRam = 0;
            goto gfEndgame;
	}
	/* not good enough */
	CloseFont(tf);
    }

    /* look for disk match */
    for (i = 0; i < fch->fch_NumEntries; i++) {
	if (tfc[i].tfc_YSize != ySize)
	    continue;
	if (tfc[i].tfc_TagCount) {
	    D(("tfc_TagCount %ld\n", tfc[i].tfc_TagCount));
	    ti = (struct TagItem *) &tfc[i].tfc_FileName[MAXFONTPATH-
		    (tfc[i].tfc_TagCount*sizeof(struct TagItem))];
	    if (ti = FindTagItem(OT_DeviceDPI, ti)) {
		dpiX2 = ti->ti_Data>>16;
		dpiY2 = ti->ti_Data & 0xffff;
		if ((dpiX * dpiY2) != (dpiX2 * dpiY))
		    continue;
	    }
	}
	/* open this disk font */
	D(("Load disk font %s path %s\n", tta->tta_Name, fontPath));
	tf = (struct TextFont *)
		loadDiskFont(dfl, tfc+i, tta->tta_Name, fontPath);
	if (tf)
	    goto gfEndgame;
	D(("  font path %s unchanged?\n", fontPath));
	break;
    }

    temp = GetTagData(OT_SpaceFactor, 0, tags);
    if (temp) {
	D(("OT_SpaceFactor $%08lx\n", temp));
	spaceWidth = (((GetTagData(OT_SpaceFactor, 0, tags) * ySize) + 0x8000) /
	    dpiY * dpiX) >> 16;
    }
    else {
	D(("No OT_SpaceFactor tag\n"));
	spaceWidth = GetTagData(OT_SpaceWidth, 0, tags) * dpiX / 254
		* (points>>12) / 40000;
    }
    if (spaceWidth == 0) {
	D(("No OT_SpaceWidth tag\n"));
	spaceWidth = ySize * dpiX / dpiY / 3;	/* thinspace */
    }
    if (spaceWidth == 0) {
	D(("spaceWidth (0!) = ySize (%ld) * dpiX (%ld) / dpiY (%ld) / 3\n",
		ySize, dpiX, dpiY));
	spaceWidth = 1;
    }
    D(("ySize %ld, points %ld.%04ld, dpiXY %ld, %ld, dotXY %ld, %ld, sp %ld\n",
	    ySize, points>>16, ((points&0xffff)*10000)>>16,
	    dpiX, dpiY, dotX, dotY, spaceWidth));

    if (error = ESetInfo(glyphEngine, OT_PointHeight, points,
	    OT_DeviceDPI, (dpiX<<16)|dpiY, OT_DotSize, (dotX<<16)|dotY,
	    TAG_DONE)) {
	D(("ESetInfo(%ld.%04ld %ld %ld...) failed %ld\n",
		points>>16, ((points&0xffff)*10000)>>16, dpiX, dpiY, error));
	goto gfEndgame;
    }

    if ((tta->tta_Style & FSF_BOLD) && (!(tfStyle & FSF_BOLD)) &&
	    (!(GetTagData(OT_InhibitAlgoStyle, 0, tags) & FSF_BOLD))) {
	D(("set bold."));
	if (!ESetInfo(glyphEngine,
		/* use same values as bullet does for screen fonts */
		OT_EmboldenX, 0x00000e75, OT_EmboldenY, 0x0000099e, TAG_DONE)) {
	    tfStyle |= FSF_BOLD;
	    D(("  successfully."));
	}
	D(("\n"));
    }
    if ((tta->tta_Style & FSF_ITALIC) && (!(tfStyle & FSF_ITALIC)) &&
	    (!(GetTagData(OT_InhibitAlgoStyle, 0, tags) & FSF_ITALIC))) {
	D(("set italic."));
	if (!ESetInfo(glyphEngine,
		/* 16 degrees: between CGTimesItalic (15.6) &
		 *   UniversMediumItalic (16.5)
		 */
		OT_ShearSin, 0x00004690, OT_ShearCos, 0x0000f615, TAG_DONE)) {
	    tfStyle |= FSF_ITALIC;
	    D(("  successfully."));
	}
	D(("\n"));
    }

    /* gather character definitions */
    ascent = descent = bitwidth = hiCode = 0;
    whiteLeft = whiteRight = whiteBoth = 0;
    loCode = ' ';			/* space is required */
    for (code = 0x00; code <= 0x100; code++) {
	DD(("  code %ld $%lx\n", code, code));
	if (code == 0x100)
	    error = ESetInfo(glyphEngine, OT_GlyphCode, 0x25a1 /* en-box */,
		    TAG_DONE);
	else
	    error = ESetInfo(glyphEngine, OT_GlyphCode, code,
		    TAG_DONE);
	if (error) {
	    D(("ESetInfo(OT_GlyphCode, ...$%lx) failed %ld\n", code, error));
	    continue;
	}
	error = EObtainInfo(glyphEngine, OT_GlyphMap, &cbm, TAG_DONE);
	if (error) {
	    D(("EObtainInfo(OT_GlyphMap) failed %ld\n", error));
	    continue;
	}

	    charMaps[code] = cbm;
	    DD(("    width %ld, height %ld\n",
		    cbm->glm_BMModulo, cbm->glm_BMRows));
	    DD(("    blackLeft %ld, blackTop %ld\n",
		    cbm->glm_BlackLeft, cbm->glm_BlackTop));
	    DD(("    blackWidth %ld, blackHeight %ld\n",
		    cbm->glm_BlackWidth, cbm->glm_BlackHeight));
	    DD(("    xOrigin %ld.%ld, yOrigin %ld.%ld\n",
		    cbm->glm_XOrigin>>16,
		    (((cbm->glm_XOrigin<0)?(((~cbm->glm_XOrigin)&0xffff))-1:
		    cbm->glm_XOrigin&0xffff)*10000)>>16,
		    cbm->glm_YOrigin>>16,
		    (((cbm->glm_YOrigin<0)?(((~cbm->glm_YOrigin)&0xffff))-1:
		    cbm->glm_YOrigin&0xffff)*10000)>>16));
	    DD(("    escapement %ld.%ld\n",
		    cbm->glm_Escapement>>16,
		    (((cbm->glm_Escapement<0)?
		    (((~cbm->glm_Escapement)&0xffff))-1:
		    cbm->glm_Escapement&0xffff)*10000)>>16));
#ifdef  DEBUG
	    for (y = 0; y < cbm->glm_BMRows; y++) {
		for (x = 0; x < cbm->glm_BMModulo; x++) {
		    UBYTE bits;

		    bits = cbm->glm_BitMap[y*cbm->glm_BMModulo+x];
		    for (i = 7; i >= 0; i--) {
			if (bits & (1<<i))
			    DD(("*"));
			else
			    DD(("-"));
		    }
		}
		DD(("\n"));
	    }
#endif

	    /* min & max */
	    if (cbm->glm_BlackWidth) {
	    yOrigin = cbm->glm_Y0;
	    if (ascent < (yOrigin-cbm->glm_BlackTop)) {
		ascent = yOrigin-cbm->glm_BlackTop;
		D(("code %ld, ascent now %ld\n", code, ascent));
	    }
	    if (descent < (cbm->glm_BlackTop+cbm->glm_BlackHeight-yOrigin)) {
		descent = cbm->glm_BlackTop+cbm->glm_BlackHeight-yOrigin;
		D(("code %ld, descent now %ld\n", code, descent));
	    }
	    DD(("code %ld x0 %ld x1 %ld bl %ld bw %ld",
		     code, cbm->glm_X0, cbm->glm_X1,
		     cbm->glm_BlackLeft, cbm->glm_BlackWidth));
	if ((code >= 'a') && (code <= 'z')) {
	    if ((cbm->glm_BlackLeft+cbm->glm_BlackWidth) < cbm->glm_X1) {
		/* there is whiteRight */
		if (cbm->glm_X0 < cbm->glm_BlackLeft) {
		    DD((" wl. wb."));
		    whiteLeft++;
		    whiteBoth++;
		}
		DD((" wr."));
		whiteRight++;
	    }
	    else {
		if (cbm->glm_X0 < cbm->glm_BlackLeft) {
		    DD((" wl."));
		    whiteLeft++;
		}
	    }
	    DD(("\n"));
	}
	    bitwidth += cbm->glm_BlackWidth;
	    }
	    if (code < loCode) {
		loCode = code;
	    }
	    if ((code > hiCode) && (code != 0x100)) {
		hiCode = code;
	    }
    }

    /* generate diskfont */
    code = hiCode-loCode+2;
    yBaseOrigin = ascent;
    if ((ascent+descent) > ySize) {
	yBaseOrigin -= (ascent+descent-ySize+1)*2/3;
    }
    D(("code %ld..%ld, bitwidth %ld, ascent %ld descent %ld, yBaseOrig %ld\n",
	    loCode, hiCode, bitwidth, ascent, descent, yBaseOrigin));
    D(("whiteLeft %ld, whiteRight %ld, whiteBoth %ld\n",
	    whiteLeft, whiteRight, whiteBoth));
    if (code < 0)
	goto gfEndgame;
    destMod = ((bitwidth+15)/16)*2;
    allocSize = ((12+sizeof(struct DiskFontHeader)+(OFONT_TAGCNT*8)+7)+
	    (16*code)+(ySize*destMod))
	    & 0xfffffffc;		/* must be even longword size */
    if (!(p = (ULONG *) AllocMem(allocSize, MEMF_CLEAR))) {
	D(("AllocMem %ld failure (%ld+(16*%ld)+(%ld*%ld)\n", allocSize,
		12+sizeof(struct DiskFontHeader)+(OFONT_TAGCNT*8)+7,
		code, ySize, destMod));
	goto gfEndgame;
    }

    p[0] = allocSize;			/* set alloc size as LoadSeg would */
    p[2] = 0x70644e75;			/* moveq #100,d0; rts; */
    dfh = (struct DiskFontHeader *) (p+3);
    dfh->dfh_FileID = DFH_ID;
    strcpy(dfh->dfh_Name, tta->tta_Name);
    dfh->dfh_TF.tf_YSize = ySize;
    dfh->dfh_TF.tf_Style = tfStyle;
    dfh->dfh_TF.tf_Flags = FPF_PROPORTIONAL;
    dfh->dfh_TF.tf_Baseline = yBaseOrigin-1;
    dfh->dfh_TF.tf_BoldSmear = 1;
    dfh->dfh_TF.tf_LoChar = loCode;
    dfh->dfh_TF.tf_HiChar = hiCode;
    dfh->dfh_TF.tf_Modulo = destMod;
    dfh->dfh_Segment = (LONG)(dfh+1);
    dfh->dfh_TF.tf_CharLoc = (APTR) (dfh->dfh_Segment+(OFONT_TAGCNT*8));
    dfh->dfh_TF.tf_CharSpace = (APTR) (((ULONG) dfh->dfh_TF.tf_CharLoc)+
	    (code*4));
    dfh->dfh_TF.tf_CharKern = (APTR) (((ULONG) dfh->dfh_TF.tf_CharSpace)+
	    (code*2));
    dfh->dfh_TF.tf_CharData = (APTR) (((ULONG) dfh->dfh_TF.tf_CharKern)+
	    (code*2));

    ti = (struct TagItem *) dfh->dfh_Segment;
    ti->ti_Tag = OT_PointHeight;
    ti->ti_Data = points;
    ti++;
    ti->ti_Tag = OT_DeviceDPI;
    ti->ti_Data = (dpiX<<16)|dpiY;
    ti++;
    ti->ti_Tag = OT_DotSize;
    ti->ti_Data = (dotX<<16)|dotY;
    ti++;
    ti->ti_Tag = TAG_DONE;
    ti->ti_Data = 0;

    D(("YSize %ld, Baseline %ld, Modulo %ld\n", dfh->dfh_TF.tf_YSize,
	     dfh->dfh_TF.tf_Baseline, dfh->dfh_TF.tf_Modulo));
    DD(("tf_CharData $%lx\n", dfh->dfh_TF.tf_CharData));

    destMod /= 2;

    undefCode = hiCode+1;
    charMaps[undefCode] = charMaps[0x100];
    x = 0x00;				/* guess no adjustment needed */
    y = 26-ySize;
    if ((whiteBoth < y) && (whiteLeft < 24) && (whiteRight < 24)) {
	if (whiteLeft < whiteRight)
	    x = 0x02;			/* ensure white left bearing */
	else
	    x = 0x01;			/* ensure white right bearing */
    }
    DS(("size %ld White Left %ld Right %ld Both %ld Neither %ld force %ld\n",
	    dfh->dfh_TF.tf_YSize, whiteLeft, whiteRight, whiteBoth,
	    whiteBoth-whiteLeft-whiteRight+26, x));
    bitstart = imageCode(dfh, undefCode, 0, x);	/* image undefined character */
    for (code = loCode; code <= hiCode; code++) {
	bitstart += imageCode(dfh, code, bitstart, x);
    }

    if (GetTagData(OT_IsFixed, 0, tags)) {
	/* force a fixed width typeface */
	D(("IsFixed: spaceWidth %ld\n", spaceWidth));
	xSize = spaceWidth;
	for (code = hiCode-loCode+1; code >= 0; code--) {
	    width = (((WORD *) dfh->dfh_TF.tf_CharKern)[code]+
		    ((WORD *) dfh->dfh_TF.tf_CharSpace)[code]);
	    if (xSize < width) {
		xSize = width;
		if (xSize > (spaceWidth+2)) {
		    xSize = spaceWidth+2;	/* that's the limit */
		    break;
		}
	    }
	}

	/* force everything to xSize */
	dfh->dfh_TF.tf_XSize = xSize;
	dfh->dfh_TF.tf_Flags = 0;		/* not PROPORTIONAL */
	for (code = hiCode-loCode+1; code >= 0; code--) {
	    kern = ((WORD *) dfh->dfh_TF.tf_CharKern)[code];
	    space = ((WORD *) dfh->dfh_TF.tf_CharSpace)[code];
	    bitwidth = ((ULONG *) dfh->dfh_TF.tf_CharLoc)[code]&0xffff;
	    width = xSize - kern - space;	/* width adjustment */
	    width2 = width/2;
	    D(("c $%02lx w %ld k %ld s %ld b %ld ? %ld, ", code, width, kern,
		    space, bitwidth, (space-bitwidth)));
	    if ((short)(space-bitwidth) >= kern) {
		/* more whitespace at right than at left */
		D(("+L "));
		kern += width-width2;
		space += width2;
	    }
	    else {
		/* more whitespace at left than at right */
		D(("+R "));
		kern += width2;
		space += width-width2;
	    }
	    if ((kern < 0) && ((short)(space-bitwidth) > 0)) {
		/* pull in kern to center */
		if (-kern > (short)(space-bitwidth)) {
		    kern += (short)(space-bitwidth);
		    space = bitwidth;
		}
		else {
		    space += kern;
		    kern = 0;
		}
	    }
	    else if ((kern > 0) && ((short)(space-bitwidth) < 0)) {
		/* pull in kern to center */
		if (kern > -(short)(space-bitwidth)) {
		    kern += (short)(space-bitwidth);
		    space = bitwidth;
		}
		else {
		    space += kern;
		    kern = 0;
		}
	    }
	    D(("k2 %ld s2 %ld\n", kern, space));
	    ((WORD *) dfh->dfh_TF.tf_CharKern)[code] = kern;
	    ((WORD *) dfh->dfh_TF.tf_CharSpace)[code] = space;
	}
    }
    else {
	if ((loCode <= 'n') && ('n' <= hiCode))
	    spaceWidth = ((WORD *) dfh->dfh_TF.tf_CharKern)['n'-loCode] +
		    ((WORD *) dfh->dfh_TF.tf_CharSpace)['n'-loCode];
	dfh->dfh_TF.tf_XSize = spaceWidth;
    }
    D(("XSize %ld\n", dfh->dfh_TF.tf_XSize));

gfEndgame:
    D(("gfEndGame:\n"));
    if (glyphEngine) {
	glyphLibrary = glyphEngine->gle_Library;
	D(("ECloseEngine...\n"));
	ECloseEngine(glyphEngine);
	CloseLibrary(glyphLibrary);
    }
    D(("FreeVec things...\n"));
    if (tags)
	FreeVec(tags);
    if (dfh) {
	D(("try to patch dfh\n"));
	if (!(tf = (struct TextFont *) PatchDiskFont(dfl, dfh))) {
	    D(("  failed, UnLoadSeg\n"));
	    UnLoadSeg(dfh->dfh_Segment);
	}
    }
    if (!tf) {
	D(("OpenWeighedFont...\n"));
	tf = (struct TextFont *)
		OpenWeighedFont(dfl, fontPath, tta, fch, tfc, tfRam, wRam);
    }

    if ((tfRam) && (tf != tfRam)) {
	D(("Close tfRam font\n"));
	CloseFont(tfRam);
    }

    D(("GenFont result $%lx { \"%s\", %ld, $%lx, $%lx }\n",
	    tf, tf->tf_Message.mn_Node.ln_Name,
	    tf->tf_YSize, tf->tf_Style, tf->tf_Flags));
    return(tf);
}
@


39.0
log
@First pass at support for fonts of same name, Y size, and style.
This code was not passing the DotSize tag when doing an OpenFont()
to check for an existing match.  Latest V39 WeighTAMatch() supports
request of, and checking for DotSize.  Need to verify there is
no problem created by doing this, but it looks to be the correct
thing to do.
@
text
@d6 1
a6 1
**	$Id: genfont.c,v 38.7 92/03/26 11:56:49 davidj Exp $
d10 3
a15 1

d537 37
@


38.7
log
@changed reference to diskfonttag.h
@
text
@d6 1
a6 1
**	$Id: genfont.c,v 38.6 91/04/12 20:32:14 kodiak Exp Locker: davidj $
d346 1
a346 1
    struct TagItem dpiTags[2];
d546 3
a548 1
    dpiTags[1].ti_Tag = TAG_DONE;
@


38.6
log
@correctly look for memory copy w/ applicable style bits
set tf_BoldSmear to 1, not 0
ask bullet to make characters bold or italic if appropriate
fix IsFixed spacing correction to reduce kerning
add escape from white padding for one-side-padded fonts
@
text
@d4 1
a4 1
 */ 
d6 1
a6 1
**	$Id: genfont.c,v 38.6 91/04/12 13:24:18 kodiak Exp Locker: kodiak $
d31 2
a32 2
#include	<exec/types.h>
#include	<exec/memory.h>
d34 1
a34 1
#include	<string.h>
d39 1
a39 1
#include	<setjmp.h>
d41 3
a43 3
#include	"diskfont.h"
#include	"/bullet/diskfonttag.h"
#include	"/bullet/glyph.h"
d45 1
a45 1
#include	"dfdata.h"
d479 1
a479 1
	ySize = tta->tta_YSize;	
d673 1
a673 1
	
d908 1
a908 1
	
@


38.5
log
@remove reordering of code access to bullet
fix undefined character glyph creation
adjust width of small fonts to enhance whitespace
@
text
@d6 1
a6 1
**	$Id: genfont.c,v 38.4 91/04/09 21:22:39 kodiak Exp Locker: kodiak $
d20 1
a20 1
#define	D(a)
d375 4
d486 1
a486 2
	    if (cnt = GetTagData(OT_AvailSizes, 0, tags)) {
		sizes = (UWORD *) (((ULONG) tags) + cnt);
d542 1
a542 1
    ttaLocal.tta_Style = FSF_TAGGED;
d549 2
a550 1
    D(("OpenFont({ \"%s\", %ld,,, })...\n", otName, ySize));
d627 25
d785 1
a785 1
 /* dfh->dfh_TF.tf_BoldSmear = 0; */
d821 1
a821 1
    if (whiteBoth < y) {
d857 1
d860 3
a862 4
	    D(("w %ld k %ld s %ld b %ld, ", width, kern, space,
		    ((ULONG *) dfh->dfh_TF.tf_CharLoc)[code]&0xffff));
	    if ((space - (((ULONG *) dfh->dfh_TF.tf_CharLoc)[code]&0xffff)) >=
		    kern) {
d864 1
d870 1
d874 22
d938 3
a940 1
    D(("  GenFont result $%lx\n", tf));
@


38.4
log
@correctly set tf_XSize
use bullet library character placement & spacing
another decender jump fix: ignore empty bitmaps & use 1/2 (vs. 2/3)
    of excess room for ascenders
add ascender ducking
make space width dependant on x resolution
@
text
@d6 1
a6 1
**	$Id: genfont.c,v 38.3 91/04/03 18:42:22 kodiak Exp Locker: kodiak $
d14 1
d19 2
a20 1
#define	D(a)	kprintf a
d23 1
a65 71

static const UBYTE shapeOrder[256] = {
#if 1
    0xB8, 0xB4, 0x60, 0xA8, 0x5E, 0x7E, 0x6F, 0xF3,
    0xF2, 0xF6, 0xF4, 0xF5, 0x6E, 0xF1, 0x63, 0xE7,
    0x65, 0xE9, 0xE8, 0xEB, 0xEA, 0x79, 0xFD, 0xFF,
    0x61, 0xE1, 0xE0, 0xE4, 0xE2, 0xE3, 0xE5, 0x75,
    0xFA, 0xF9, 0xFC, 0xFB, 0xED, 0xEC, 0xEF, 0xEE,
    0xAF, 0x4F, 0xD3, 0xD2, 0xD6, 0xD4, 0xD5, 0x4E,
    0xD1, 0x49, 0xCD, 0xCC, 0xCF, 0xCE, 0x45, 0xC9,
    0xC8, 0xCB, 0xCA, 0x59, 0xDD, 0x41, 0xC1, 0xC0,
    0xC4, 0xC2, 0xC3, 0xC5, 0x55, 0xDA, 0xD9, 0xDC,
    0xDB, 0x43, 0xC7, 0x74, 0x68, 0x6D, 0x6C, 0x72,
    0x67, 0x69, 0x70, 0x76, 0x7A, 0x64, 0x62, 0x73,
    0x66, 0x78, 0x77, 0x6A, 0x71, 0x6B, 0x54, 0x48,
    0x4D, 0x4C, 0x52, 0x47, 0x50, 0x56, 0x5A, 0x44,
    0x42, 0x53, 0x46, 0x58, 0x57, 0x4A, 0x51, 0x4B,
    0x26, 0x21, 0x3F, 0xAB, 0xBB, 0xA1, 0xBF, 0xC6,
    0xE6, 0xDF, 0xF8, 0xD8, 0xD0, 0xDE, 0xF0, 0xFE,
    0x2E, 0x2C, 0x3A, 0x3B, 0x28, 0x29, 0x5B, 0x5D,
    0x2D, 0x2F, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
    0x37, 0x38, 0x39, 0x30, 0x24, 0xA2, 0xB9, 0xB2,
    0xB3, 0xBD, 0xBC, 0xBE, 0xA3, 0x25, 0x2B, 0xB1,
    0x3D, 0xD7, 0xF7, 0xAA, 0xBA, 0xB0, 0xA7, 0xB6,
    0x2A, 0x23, 0xA5, 0xA4, 0x5C, 0xB7, 0xAE, 0xA9,
    0xAC, 0x40, 0x7B, 0x7D, 0x27, 0x22, 0xA0, 0x20,
    0xB5, 0x80, 0xAD, 0x3E, 0x3C, 0x7C, 0x5F, 0xA6,
    0x7F, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
    0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
    0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e,
    0x1f, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
#else
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
#endif
};

d74 1
a74 1
static UWORD undefKern, undefSpace;
d197 2
a198 1
UWORD imageCode(struct DiskFontHeader *dfh, UWORD code, UWORD bitstart)
d211 9
d225 16
a246 3
	if (!bitwidth)
	    return(0);

d253 1
a253 1
	    D(("truncate %ld blackHeight %ld to %ld, blackTop %ld to %ld\n",
d297 1
a297 1
	if (code == 0x80) {
d306 1
a306 1
	if (code == 0x80) {
d354 2
a355 1
    short codei, code, hiCode, ascent, descent, yOrigin;
d368 3
a370 2
    for (codei = 0; codei < 257; codei++)
	charMaps[codei] = 0;
d516 1
d519 4
d526 1
d529 3
d625 1
d627 8
a634 5
    for (codei = 0x00; codei <= 0xff; codei++) {
	code = shapeOrder[codei];
	DD(("  codei %ld code %ld $%lx\n", codei, code, code));
	error = ESetInfo(glyphEngine, OT_GlyphCode, code,
		TAG_DONE);
d692 22
d719 1
a719 1
	    if (code > hiCode) {
d727 4
a730 3
    if ((ascent+descent) > ySize)
	yBaseOrigin -= (ascent+descent-ySize)/2;
    D(("code %ld..%ld, bitwidth %ld, ascent %ld descent %ld, yBaseOrigin %ld\n",
d732 2
d788 16
a803 4
    bitstart = imageCode(dfh, 0x80, 0);	/* image undefined character */
    for (code = loCode; code <= hiCode+1; code++) {
	if (code != 0x80)
	    bitstart += imageCode(dfh, code, bitstart);
@


38.3
log
@change code flow so no characters defined doesn't cause negative AllocMem
    (which results in ERROR_NO_FREE_STORE being set)
change baseline when ascent+descent > ySize to better center characters
@
text
@d6 1
a6 1
**	$Id: genfont.c,v 38.3 91/04/03 15:15:26 kodiak Exp Locker: kodiak $
d280 3
a282 4
 	/* not rounded off, but coded to give precedence to white space */
 	kern = cbm->glm_BlackLeft+((cbm->glm_XOrigin+0x0f000)>>16);
 	space = (((cbm->glm_XOrigin&0xffff)+cbm->glm_Escapement+0xf000)>>16) -
		kern;
d289 4
a292 4
	if (cbm->glm_YOrigin < 0)
	    yOrigin = (cbm->glm_YOrigin-0x8000)>>16;
	else
	    yOrigin = (cbm->glm_YOrigin+0x8000)>>16;
d298 2
a299 2
	    D(("truncate blackHeight %ld to %ld, blackTop %ld to %ld\n",
		    blackHeight, ySize,
d304 3
a306 3
	if ((yBaseOrigin+blackTop+blackHeight-yOrigin) > ySize) {
	    D(("shift yOrigin %ld to %ld\n",
		    yOrigin, yBaseOrigin+blackTop+blackHeight-ySize));
d309 5
a313 1

d381 1
a381 1
    FIXED points;
d625 15
a639 1
    spaceWidth = ((GetTagData(OT_SpaceFactor, 0, tags) * ySize) + 0x8000) >> 16;
d641 3
a643 2
	spaceWidth = GetTagData(OT_SpaceWidth, 0, tags) * dpiY / 254
		* (points>>12) / 40000;
a644 3
    if (spaceWidth == 0)
	spaceWidth = ySize;

d712 2
a713 4
	    if (cbm->glm_YOrigin < 0)
		yOrigin = (cbm->glm_YOrigin-0x8000)>>16;
	    else
		yOrigin = (cbm->glm_YOrigin+0x8000)>>16;
d716 1
a716 1
		DD(("ascent now %ld\n", ascent));
d720 1
a720 1
		DD(("descent now %ld\n", descent));
d723 1
d736 1
a736 1
	yBaseOrigin -= (ascent+descent-ySize)*2/3;
d845 1
a845 2
	else
	    dfh->dfh_TF.tf_XSize = spaceWidth;
@


38.2
log
@initialize result so garbage is not returned when no font exists
rename variables for new GlyphMap renaming
eliminate SymbolSet tag
@
text
@d6 1
a6 1
**	$Id: genfont.c,v 38.0 91/02/25 14:43:06 kodiak Exp Locker: kodiak $
d140 1
a140 1
static UWORD ySize, spaceWidth, ascent, loCode, destMod;
d299 4
a302 1
	    blackTop = (ySize-blackHeight)/2;
d305 4
a308 2
	if ((ascent+blackTop+blackHeight-yOrigin) > ySize) {
	    yOrigin = ascent+blackTop+blackHeight-ySize;
d318 1
a318 1
		(ascent-(yOrigin-blackTop)));
d396 1
a396 1
    short codei, code, hiCode, descent, yOrigin;
d720 7
a726 2
    D(("loCode %ld, hiCode %ld, bitwidth %ld, ascent %ld, descent %ld\n",
	    loCode, hiCode, bitwidth, ascent, descent));
d746 1
a746 1
    dfh->dfh_TF.tf_Baseline = ascent-1;
d773 2
a774 3
    D(("YSize %ld, XSize %ld, Baseline %ld, Modulo %ld\n", dfh->dfh_TF.tf_YSize,
	     dfh->dfh_TF.tf_XSize, dfh->dfh_TF.tf_Baseline,
	     dfh->dfh_TF.tf_Modulo));
d834 1
@


38.0
log
@Phase 2 Alpha 1
@
text
@d6 1
a6 1
**	$Id: genfont.c,v 37.1 91/01/31 14:43:13 kodiak Exp Locker: kodiak $
d134 1
a134 1
#define  OFONT_TAGCNT	5	/* Points, DPI, DotSize, SymbolSet, DONE */
d138 1
a138 1
static struct Glyph *charMaps[257];
d267 1
a267 1
    struct Glyph *cbm;
d277 1
a277 1
	bitwidth = cbm->gly_BlackWidth;
d281 2
a282 2
 	kern = cbm->gly_BlackLeft+((cbm->gly_XOrigin+0x0f000)>>16);
 	space = (((cbm->gly_XOrigin&0xffff)+cbm->gly_Escapement+0xf000)>>16) -
d290 2
a291 2
	if (cbm->gly_YOrigin < 0)
	    yOrigin = (cbm->gly_YOrigin-0x8000)>>16;
d293 3
a295 3
	    yOrigin = (cbm->gly_YOrigin+0x8000)>>16;
	blackTop = cbm->gly_BlackTop;
	blackHeight = cbm->gly_BlackHeight;
d306 5
a310 5
	srcMod = cbm->gly_BMModulo>>1;
	srcY = ((UWORD *) (cbm->gly_BitMap+(cbm->gly_BMModulo*blackTop))) +
		(cbm->gly_BlackLeft>>4);
	srcShift = cbm->gly_BlackLeft&0xf;
	srcEnd = cbm->gly_BlackWidth+srcShift;
a372 1
    UWORD symbolSet;
d388 1
a388 1
    struct Glyph *cbm;
d408 1
a486 1
    symbolSet = GetTagData(OT_SymbolSet, dfl->dfl_SymbolSet, tags);
a501 1
	symbolSet = GetTagData(OT_SymbolSet, symbolSet, tta->tta_Tags);
d631 1
a631 1
	    OT_SymbolSet, symbolSet, TAG_DONE)) {
d643 1
a643 1
	error = ESetInfo(glyphEngine, OT_GlyphCode, 0x20202000 | code,
d649 1
a649 1
	error = EObtainInfo(glyphEngine, OT_Glyph, &cbm, TAG_DONE);
d651 1
a651 1
	    D(("EObtainInfo(OT_Glyph) failed %ld\n", error));
d657 1
a657 1
		    cbm->gly_BMModulo, cbm->gly_BMRows));
d659 1
a659 1
		    cbm->gly_BlackLeft, cbm->gly_BlackTop));
d661 1
a661 1
		    cbm->gly_BlackWidth, cbm->gly_BlackHeight));
d663 6
a668 6
		    cbm->gly_XOrigin>>16,
		    (((cbm->gly_XOrigin<0)?(((~cbm->gly_XOrigin)&0xffff))-1:
		    cbm->gly_XOrigin&0xffff)*10000)>>16,
		    cbm->gly_YOrigin>>16,
		    (((cbm->gly_YOrigin<0)?(((~cbm->gly_YOrigin)&0xffff))-1:
		    cbm->gly_YOrigin&0xffff)*10000)>>16));
d670 4
a673 4
		    cbm->gly_Escapement>>16,
		    (((cbm->gly_Escapement<0)?
		    (((~cbm->gly_Escapement)&0xffff))-1:
		    cbm->gly_Escapement&0xffff)*10000)>>16));
d675 2
a676 2
	    for (y = 0; y < cbm->gly_BMRows; y++) {
		for (x = 0; x < cbm->gly_BMModulo; x++) {
d679 1
a679 1
		    bits = cbm->gly_BitMap[y*cbm->gly_BMModulo+x];
d692 2
a693 2
	    if (cbm->gly_YOrigin < 0)
		yOrigin = (cbm->gly_YOrigin-0x8000)>>16;
d695 3
a697 3
		yOrigin = (cbm->gly_YOrigin+0x8000)>>16;
	    if (ascent < (yOrigin-cbm->gly_BlackTop)) {
		ascent = yOrigin-cbm->gly_BlackTop;
d700 2
a701 2
	    if (descent < (cbm->gly_BlackTop+cbm->gly_BlackHeight-yOrigin)) {
		descent = cbm->gly_BlackTop+cbm->gly_BlackHeight-yOrigin;
d704 1
a704 1
	    bitwidth += cbm->gly_BlackWidth;
a758 3
    ti++;
    ti->ti_Tag = OT_SymbolSet;
    ti->ti_Data = symbolSet;
@


37.1
log
@phase 1 final form
@
text
@d2 5
a6 1
**	$Id: genfont.c,v 37.0 90/11/26 12:45:11 kodiak Exp Locker: kodiak $
d39 3
a41 1
#include	"diskfonttag.h"
a42 1
#include	"bullet_protos.h"
d136 3
a138 1
static IFBITMAP *charMaps[257];
a143 13
void *getTagPtr(struct DiskfontLibrary *dfl,
	ULONG tagVal, struct TagItem *tagList)
{
    struct TagItem *ti;

    if (ti = FindTagItem(tagVal | OT_Indirect, tagList)) {
	D(("GetTagPtr $%08x: +$%lx\n", tagVal, ti->ti_Data));
	return((void *) (((ULONG) tagList) + ti->ti_Data));
    }
    D(("GetTagPtr $%08x: <not found>\n", tagVal));
    return(0);
}

d150 3
a152 1
    char otagPath[256], *s, failure;
d158 1
a158 1
    strcpy(otagPath, fontPath);
d160 1
a160 1
    s = FilePart(otagPath);
d164 1
a164 1
    D((".otag name %s\n", otagPath));
d167 1
a167 1
    if (!(otFile = Open(otagPath, MODE_OLDFILE))) {
d199 8
a206 1
    *tags = tag;		/* fill in first tag */
d208 3
a210 2
    /* validate some required data */
    if (!(s = getTagPtr(dfl, OT_Engine, tags))) {
d214 35
a248 2
    if (strcmp(s, OTE_Bullet)) {
	D(("OT_Engine \"%s\", not \"%s\"\n", s, OTE_Bullet));
d267 1
a267 1
    IFBITMAP *cbm;
d271 2
d277 1
a277 1
	bitwidth = cbm->black_width;
d281 3
a283 2
 	kern = ((cbm->left_indent*16)+cbm->xorigin+15)/16;
 	space = ((cbm->xorigin&15)+cbm->escapement+15)/16 - kern;
d290 7
d298 3
a300 3
	if (cbm->black_depth > ySize) {
	    cbm->top_indent = (ySize-cbm->black_depth)/2;
	    cbm->black_depth = ySize;
d302 9
a310 11
	if ((ascent+cbm->top_indent+cbm->black_depth-cbm->yorigin)
		> ySize) {
	    cbm->yorigin += ascent+cbm->top_indent+cbm->black_depth-
		    cbm->yorigin-ySize;
	}

	srcMod = cbm->width/2;
	srcY = ((UWORD *) (cbm->bm+(cbm->width*cbm->top_indent))) +
		(cbm->left_indent/16);
	srcShift = cbm->left_indent&0xf;
	srcEnd = cbm->black_width+srcShift;
d312 2
a313 2
	destY = ((UWORD *) dfh->dfh_TF.tf_CharData)+(bitstart/16)+(destMod*
		(ascent-(cbm->yorigin-cbm->top_indent)));
d319 1
a319 1
	for (y = cbm->black_depth; y > 0; y--) {
d359 1
a359 1
		space, kern));
a370 1
    ULONG specs[15];
d374 2
a375 1
    UWORD points, ySize2m, ySize2o, ySize2b;
d388 2
a389 2
    BOOL engineFlag;
    IFBITMAP *cbm;
d392 1
a392 1
    short codei, code, hiCode, descent;
d396 1
d407 1
a407 1
    engineFlag = 0;
d441 1
a441 1
	    s = getTagPtr(dfl, OT_BIName, tags);
d448 1
a448 1
	    s = getTagPtr(dfl, OT_IName, tags);
d455 1
a455 1
	    s = getTagPtr(dfl, OT_BName, tags);
a469 14
    /* get engine specs */
    cnt = GetTagData(OT_SpecCount, 0, tags);
    for (i = 1; i <= cnt; i++) {
	if (!(ti = FindTagItem(OT_Spec+i, tags))) {
	    if (!(ti = FindTagItem(OT_Spec|OT_Indirect+i, tags))) {
		D(("cannot FindTagItem spec 0x%lx\n", OT_Spec+i));
		goto gfEndgame;
	    }
	    specs[i-1] = ((ULONG) tags) + ti->ti_Data;
	}
	else
	    specs[i-1] = ti->ti_Data;
    }

d504 3
a506 1
	points = GetTagData(OT_PointSize, 0, tta->tta_Tags);
d555 1
a555 1
	points = (ySize * 16);
d558 2
a559 1
	ySize = points * dpiY / 72 * ySizeFactor.w.d / ySizeFactor.w.n / 16;
d619 4
a622 17
    spaceWidth = GetTagData(OT_SpaceWidth, 0, tags) * dpiY / 254
	     * points / 40000;

    D(("ySize %ld, points %ld, dpiX,Y %ld, %ld, dotX,Y %ld, %ld, space %ld\n",
	    ySize, points, dpiX, dpiY, dotX, dotY, spaceWidth));

    D(("call CGBOpenEngine...\n"));
    if (!(engineFlag = CGBOpenEngine())) {
	D(("CGBOpenEngine failed\n"));
	goto gfEndgame;
    }

    *PathPart(fontPath) = '\0';
    D(("call CGBSetFace & %ld ...\n", *specs));
    if (!CGBSetFace(fontPath, specs)) {
	D(("CGBSetFace %ld ... failed\n", *specs));
	goto gfEndgame;
d624 12
a635 5

    D(("call CGBSetTarget %ld %ld %ld %ld %ld %lc%lc...\n",
	    points, dpiX, dpiY, dotX, dotY, symbolSet>>8, symbolSet & 0xff));
    if (!CGBSetTarget(points, dpiX, dpiY, dotX, dotY, symbolSet)) {
	D(("CGBSetTarget %ld %ld %ld failed\n", points, dpiX, dpiY));
d645 12
a656 1
	if (cbm = CGBGetChar(code)) {
d658 18
a675 20
		DD(("    original yorigin %ld, escapement %ld\n",
			cbm->yorigin, cbm->escapement));

		/* correct to pixelish values (y in pixels, x in pixels*16) */
		cbm->yorigin = (cbm->yorigin+8)/16;
		cbm->escapement = (cbm->escapement * dpiX) / 254
			* points / 2500;

		DD(("    width %ld, depth %ld\n", cbm->width,
			cbm->depth));
		DD(("    left_indent %ld, top_indent %ld\n",
			cbm->left_indent,
			cbm->top_indent));
		DD(("    black_width %ld, black_depth %ld\n",
			cbm->black_width,
			cbm->black_depth));
		DD(("    xorigin %ld, yorigin %ld\n",
			cbm->xorigin,
			cbm->yorigin));
		DD(("    escapement %ld\n", cbm->escapement));
d677 3
a679 3
		for (y = 0; y < cbm->depth; y++) {
		    for (x = 0; x < cbm->width; x++) {
			UBYTE bits;
d681 6
a686 7
			bits = cbm->bm[y*cbm->width+x];
			for (i = 7; i >= 0; i--) {
			    if (bits & (1<<i))
				DD(("*"));
			    else
				DD(("-"));
			}
a687 1
		    DD(("\n"));
d689 2
d693 20
a712 17
		/* min & max */
		if (ascent < (cbm->yorigin-cbm->top_indent)) {
		    ascent = cbm->yorigin-cbm->top_indent;
		    DD(("ascent now %ld\n", ascent));
		}
		if (descent < (cbm->top_indent+cbm->black_depth-cbm->yorigin)) {
		    descent = cbm->top_indent+cbm->black_depth-cbm->yorigin;
		    DD(("descent now %ld\n", descent));
		}
		bitwidth += cbm->black_width;
		if (code < loCode) {
		    loCode = code;
		}
		if (code > hiCode) {
		    hiCode = code;
		}
	}
a737 7
    if (charMaps['n'])
	dfh->dfh_TF.tf_XSize = charMaps['n']->escapement/16;
    else
	if (spaceWidth)
	    dfh->dfh_TF.tf_XSize = spaceWidth;
	else
	    dfh->dfh_TF.tf_XSize = dfh->dfh_TF.tf_YSize;
d753 1
a753 1
    ti->ti_Tag = OT_PointSize;
d823 7
d833 5
a837 3
    if (engineFlag) {
	D(("CGBCloseEngine...\n"));
	CGBCloseEngine();
a839 2
    for (codei = 0; codei < 257; codei++)
	FreeVec(charMaps[codei]);
@


37.0
log
@alpha 3
@
text
@d2 1
a2 1
**	$Id$
d15 1
a15 1
#define DD(a)	kprintf a
d27 5
d41 1
d45 1
d54 1
d61 29
a89 29
    0x20, 0xa0, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
    0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e,
    0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
    0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e,
    0x3f, 0x40, 0x41, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4,
    0xc5, 0x42, 0x43, 0xc7, 0x44, 0x45, 0xc8, 0xc9,
    0xca, 0xcb, 0x46, 0x47, 0x48, 0x49, 0xcc, 0xcd,
    0xce, 0xcf, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0xd1,
    0x4f, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd8, 0x50,
    0x51, 0x52, 0x53, 0x54, 0x55, 0xd9, 0xda, 0xdb,
    0xdc, 0x56, 0x57, 0x58, 0x59, 0xdd, 0x5a, 0x5b,
    0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0xe0, 0xe1,
    0xe2, 0xe3, 0xe4, 0xe5, 0x62, 0x63, 0xe7, 0x64,
    0x65, 0xe8, 0xe9, 0xea, 0xeb, 0x66, 0x67, 0x68,
    0x69, 0xec, 0xed, 0xee, 0xef, 0x6a, 0x6b, 0x6c,
    0x6d, 0x6e, 0xf1, 0x6f, 0xf2, 0xf3, 0xf4, 0xf5,
    0xf6, 0xf8, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
    0xf9, 0xfa, 0xfb, 0xfc, 0x76, 0x77, 0x78, 0x79,
    0xfd, 0xff, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
    0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8,
    0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0,
    0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8,
    0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc6,
    0xd0, 0xd7, 0xde, 0xdf, 0xe6, 0xf0, 0xf7, 0xfe,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
d129 1
d133 1
a133 1
static UWORD ySize, ascent, loCode, destMod;
d137 91
a234 1
    UWORD mask;
d241 5
a245 5
	kern = ((cbm->left_indent*16)+cbm->xorigin+8)/16;
	space =  (cbm->escapement+8)/16 - kern;
	/* ensure minimal white space rules !!! */
	((UWORD *) dfh->dfh_TF.tf_CharKern)[code-loCode] = kern;
	((UWORD *) dfh->dfh_TF.tf_CharSpace)[code-loCode] = space;
a265 1
	mask = 0xffff<<srcShift;
d272 2
a273 2
	DD(("  mask $%04lx, destY $%lx, destShift %ld\n",
		mask, destY, destShift));
a277 2
		if (x < 16)
		    mask &= 0xffff<<(16-x);
d280 1
a280 1
			(((*((ULONG *) src))>>srcShift)&mask)<<destShift));
d282 1
a282 2
			(((*((ULONG *) src))>>srcShift)&mask)<<destShift;
		mask = 0xffff;
d305 1
a305 2
	    ((UWORD *) dfh->dfh_TF.tf_CharSpace)[code-loCode] =
		    dfh->dfh_TF.tf_XSize;
d307 1
a307 1
	else { 
d309 2
a310 2
	    ((UWORD *) dfh->dfh_TF.tf_CharKern)[code-loCode] = undefKern;
	    ((UWORD *) dfh->dfh_TF.tf_CharSpace)[code-loCode] = undefSpace;
d320 4
a323 2
struct DiskFontHeader * __saveds GenFont(struct DiskfontLibrary *dfl,
	char *fontPath, struct TTextAttr *tta, struct TagItem *otags)
d325 1
a325 2
    struct TagItem *ti;
    Tag specTagBase;
d327 1
a327 1
    UWORD dpiX, dpiY;
d330 1
a330 2
    UWORD points;
    ULONG setFactor;
a340 1
    void *engineHandle;
d342 2
d346 1
d348 1
a348 1
    UWORD bitwidth, bitstart;
d350 13
d364 34
a397 8
    /* validate some required data */
    if ((!(cnt = GetTagData(OT_Engine, 0, otags))) ||		/* engine tag */
	    (strcmp(((char *) otags)+cnt, OTE_Bullet)) ||	/* is bullet? */
	    (!(cnt = GetTagData(OT_SpecCount, 0, otags)))) {	/* specs? */
	D(("OT_Engine %ld or OT_SpecCount %ld failure\n",
		GetTagData(OT_Engine, 0, otags),
		GetTagData(OT_SpecCount, 0, otags)));
	return(0);
d399 1
a399 4

    /* find style */
    specTagBase = OT_NSpec;
    if (tta->tta_Style & FSF_ITALIC) {
d401 4
a404 3
	i = GetTagData(OT_SlantStyle, OTS_Upright, otags);
	if ((i == OTS_Upright) && FindTagItem(OT_ISpec1, otags))
	    specTagBase = OT_ISpec;
d406 1
a406 1
    if (tta->tta_Style & FSF_BOLD) {
d408 13
a420 4
	i = GetTagData(OT_StemWeight, OTS_Medium, otags);
	if ((i < ((OTS_Medium+OTS_SemiBold)/2)) &&
		FindTagItem(specTagBase | OT_BSpec1, otags))
	    specTagBase |= OT_BSpec;
d422 1
d425 1
d427 4
a430 4
	if (!(ti = FindTagItem(specTagBase+i, otags))) {
	    if (!(ti = FindTagItem(specTagBase|OT_Indirect+i, otags))) {
		D(("cannot FindTagItem spec 0x%lx\n", specTagBase+i));
		return(0);
d432 1
a432 1
	    specs[i-1] = ((ULONG) otags) + ti->ti_Data;
d438 19
a457 5
    dpiX = dfl->dfl_XDPI;
    dpiY = dfl->dfl_YDPI;
    dotX = dfl->dfl_DotSizeX;
    dotY = dfl->dfl_DotSizeY;
    symbolSet = dfl->dfl_SymbolSet;
a458 1
    setFactor = 0x10001;
d471 1
a471 1
	symbolSet = GetTagData(OT_SymbolSet, dfl->dfl_SymbolSet, tta->tta_Tags);
a472 1
	setFactor = GetTagData(OT_SetFactor, 0x10001, tta->tta_Tags);
d476 1
a476 1
    ySizeFactor.t = GetTagData(OT_YSizeFactor, 0x10001, otags);
d480 36
a515 8
	if (((tta->tta_Flags & FPF_DESIGNED)) &&
		(cnt = GetTagData(OT_AvailSizes, 0, otags))) {
	    /* no scaling, avail exists, find greatest smaller size */
	    sizes = (UWORD *) (((ULONG) otags) + cnt);
	    for (cnt = *sizes++; (cnt > 0) & (*sizes <= ySize); cnt--, sizes++)
		D(("  %ld <= %ld?\n", *sizes, ySize));
	    if (*--sizes)
		ySize = *sizes;
d524 1
a524 1
	ySize = points * dpiY / 72 * ySizeFactor.w.d / ySizeFactor.w.n;
a526 3
    D(("ySize %ld, points %ld, dpiX %ld, dpiY %ld, dotX %ld, dotY %ld\n",
	    ySize, points, dpiX, dpiY, dotX, dotY));

d528 3
a530 1
    ttaLocal = *tta;
d532 2
d538 48
a585 1
    /* !!! */
d587 2
a588 4
    engineHandle = 0;
    dfh = 0;
    for (codei = 0; codei < 257; codei++)
	charMaps[codei] = 0;
d591 1
a591 1
    if (!(engineHandle = CGBOpenEngine(dfl->dfl_BulletBase))) {
d593 1
a593 1
	goto gfFailure;
d598 1
a598 1
    if (!CGBSetFace(dfl->dfl_BulletBase, engineHandle, fontPath, specs)) {
d600 1
a600 1
	goto gfFailure;
d603 3
a605 2
    D(("call CGBSetTarget %ld %ld %ld...\n", points, dpiX, dpiY));
    if (!CGBSetTarget(dfl->dfl_BulletBase, engineHandle, points, dpiX, dpiY)) {
d607 1
a607 1
	goto gfFailure;
d615 2
a616 2
	D(("  codei %ld code %ld $%lx\n", codei, code, code));
	if (cbm = CGBGetChar(dfl->dfl_BulletBase, engineHandle, code)) {
d623 1
a623 1
		cbm->escapement = (cbm->escapement * dpiY) / 254
d626 2
a627 5
		memcpy(charMaps[code], cbm,
			sizeof(IFBITMAP)+(cbm->width*cbm->depth));

		DD(("    width %ld, depth %ld\n", charMaps[code]->width,
			charMaps[code]->depth));
d629 2
a630 2
			charMaps[code]->left_indent,
			charMaps[code]->top_indent));
d632 2
a633 2
			charMaps[code]->black_width,
			charMaps[code]->black_depth));
d635 3
a637 3
			charMaps[code]->xorigin,
			charMaps[code]->yorigin));
		DD(("    escapement %ld\n", charMaps[code]->escapement));
d639 2
a640 2
		for (y = 0; y < charMaps[code]->depth; y++) {
		    for (x = 0; x < charMaps[code]->width; x++) {
d643 1
a643 1
			bits = charMaps[code]->bm[y*charMaps[code]->width+x];
d679 2
a680 1
    allocSize = ((12+sizeof(struct DiskFontHeader)+7)+(16*code)+(ySize*destMod))
d683 4
a686 2
	D(("AllocMem %ld failure\n", allocSize))
	goto gfFailure;
d689 2
a690 1
    *p = allocSize;			/* set alloc size as LoadSeg would */
d695 2
a696 2
 /* dfh->dfh_TF.tf_Style = 0; */
 /* dfh->dfh_TF.tf_Flags = 0; */
d700 4
a703 1
	dfh->dfh_TF.tf_XSize = dfh->dfh_TF.tf_YSize;
d709 2
a710 1
    dfh->dfh_TF.tf_CharLoc = (APTR) ((ULONG)(dfh+1));
d718 16
d746 43
d790 5
a794 4
gfFailure:
    if (engineHandle) {
	engineHandle = 0;
	CGBCloseEngine(dfl->dfl_BulletBase, engineHandle);
d796 1
a796 1

d799 19
d819 2
a820 1
    return(dfh);
@
