head     39.1;
branch   ;
access   ;
symbols  V36_167:36.16 V36_162:36.16 V36_160:36.15 V36_157:36.14 V36_139:36.13 V36_137:36.12 V36_135:36.11 V36_125:36.9 V36_124:36.9 V36_122:36.8 V36_121:36.8 V36_116:36.8 V36_111:36.7 V36_97:36.6 V36_86:36.4 L36_84:36.2 L36_70:36.1 L35_34:35.1;
locks    ; strict;
comment  @*   @;


39.1
date     92.07.10.10.12.59;  author darren;  state Exp;
branches ;
next     39.0;

39.0
date     92.07.08.14.29.52;  author darren;  state Exp;
branches ;
next     38.5;

38.5
date     92.06.18.11.46.50;  author darren;  state Exp;
branches ;
next     38.4;

38.4
date     92.03.26.11.58.12;  author davidj;  state Exp;
branches ;
next     38.3;

38.3
date     91.04.09.21.33.17;  author kodiak;  state Exp;
branches ;
next     37.1;

37.1
date     91.01.31.14.37.31;  author kodiak;  state Exp;
branches ;
next     37.0;

37.0
date     90.11.26.12.13.58;  author kodiak;  state Exp;
branches ;
next     36.21;

36.21
date     90.05.21.08.10.42;  author kodiak;  state Exp;
branches ;
next     36.20;

36.20
date     90.05.10.03.28.42;  author kodiak;  state Exp;
branches ;
next     36.19;

36.19
date     90.05.09.21.46.20;  author kodiak;  state Exp;
branches ;
next     36.18;

36.18
date     90.05.01.02.12.17;  author kodiak;  state Exp;
branches ;
next     36.17;

36.17
date     90.04.09.05.49.00;  author kodiak;  state Exp;
branches ;
next     36.16;

36.16
date     90.03.08.15.17.20;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     90.02.26.20.15.41;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     90.02.23.13.10.26;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     90.02.19.11.41.01;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     90.02.18.18.03.00;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     90.01.30.13.05.11;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     90.01.30.13.01.23;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     90.01.09.19.13.27;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     89.09.11.12.41.39;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     89.09.08.12.02.36;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     89.05.17.12.19.48;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.05.17.12.17.53;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     89.05.16.17.48.24;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     89.05.16.17.37.59;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     88.05.27.16.40.03;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     88.05.26.17.10.04;  author kodiak;  state Exp;
branches ;
next     35.1;

35.1
date     87.12.18.14.57.19;  author kodiak;  state Exp;
branches ;
next     35.0;

35.0
date     87.12.09.16.07.14;  author kodiak;  state Exp;
branches ;
next     ;


desc
@OpenDiskFont() function
@


39.1
log
@A few comments, but only one code change.  Ignore RAM fonts of
perfect match if DPI not specified, but font is marked as DUPLICATE.
Requires the rare case of expunging the non-duplicate version, but
not the duplicate.
@
text
@/*
**      $Id: opendiskfont.c,v 39.0 92/07/08 14:29:52 darren Exp Locker: darren $
**
**      diskfont.library OpenDiskFont function
**
**	(C) Copyright 1990 Robert R. Burns
**	    All Rights Reserved
**      (C) Copyright 1989 Commodore-Amiga, Inc.
**          All Rights Reserved
*/

/*	Debug switches */


#ifdef	DEBUG
extern void kprintf(char *,...);
#define	D(a)	kprintf a
#else
#define	D(a)
#endif


/*	Includes */

#include <exec/types.h>

#include "diskfont.h"
#include "dfdata.h"

#include <exec/nodes.h>
#include <exec/lists.h>
#include <exec/ports.h>
#include <libraries/dos.h>
#include <graphics/text.h>
#include <graphics/gfxbase.h>
#include <utility/tagitem.h>
#include <diskfont/diskfonttag.h>

#include <string.h>
#undef    strcat
#undef    strcmp
#undef    strcpy
#include <clib/dos_protos.h>
#include <clib/exec_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <pragmas/exec_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/utility_pragmas.h>

#define	SysBase		dfl->dfl_SysBase
#define	DOSBase		dfl->dfl_DOSBase
#define	GfxBase		dfl->dfl_GfxBase
#define	UtilityBase	dfl->dfl_UtilityBase

#ifndef TE0F_DUPLICATE
#define TE0F_DUPLICATE 0x80
#endif

struct TextFont * __saveds GenFont(struct DiskfontLibrary *dfl, char *fontPath,
	struct TTextAttr *tta, struct FontContentsHeader *fch,
	struct TFontContents *tfc, struct TextFont *tfRam,
	WORD wRam);

extern AddDiskFont();
extern EqualAspect();


/****** diskfont.library/OpenDiskFont ********************************
*
*   NAME
*       OpenDiskFont - load and get a pointer to a disk font.
*
*   SYNOPSIS
*       font = OpenDiskFont(textAttr)
*       D0                  A0
*
*   FUNCTION
*       This function finds the font with the specified textAttr on
*       disk, loads it into memory, and returns a pointer to the font
*       that can be used in subsequent SetFont and CloseFont calls.
*       It is important to match this call with a corresponding
*       CloseFont call for effective management of font memory.
*
*       If the font is already in memory, the copy in memory is used.
*       The disk copy is not reloaded.
*
*   INPUTS
*       textAttr - a TextAttr structure that describes the text font
*               attributes desired.
*
*   RESULTS
*       D0 is zero if the desired font cannot be found.
*
*   NOTES
*       As of V36, OpenDiskFont() will automatically attempt to
*       construct a font for you if:
*
*               You have requested a font size which does not exist
*               as a designed font, and
*
*               You have not set the DESIGNED bit in the ta_Flags
*               field of the TextAttr, or TTextAttr struct.
*
*       Constructed fonts are created by scaling a designed font.
*       A designed font is one which typically resides on disk,
*       or in ROM (e.g., a font which has been designed by hand
*       using a drawing tool).  Designed fonts generally look better
*       than fonts constructed by the font scaler, but designed
*       fonts also require disk space for each font size.
*
*       Always set the DESIGNED bit if you do not want constructed fonts,
*       or use AvailFonts() to find out which font sizes already exist.
*       
*       As of V37 the diskfont.library supported built-in outline
*       fonts.  Then in V38 the outline font engine was moved to
*       a new library, "bullet.library."
*
*   BUGS
*       This routine will not work well with font names whose file
*       name components are longer than the maximum allowed
*       (30 characters).
*
*********************************************************************/
struct TextFont *PatchDiskFont(
	struct DiskfontLibrary *dfl,
	struct DiskFontHeader *dfh)
{
    struct TagItem *dfhTags;

    /* fix bugs in some font editors: */
    dfh->dfh_TF.tf_Message.mn_Node.ln_Name = dfh->dfh_Name;
    if (dfh->dfh_TF.tf_Baseline >= dfh->dfh_TF.tf_YSize)
	dfh->dfh_TF.tf_Baseline = dfh->dfh_TF.tf_YSize - 1;
    dfh->dfh_TF.tf_Flags = (dfh->dfh_TF.tf_Flags & ~FPF_ROMFONT) |
	    FPF_DISKFONT;

    /* grab any tags from dfh_Segment */
    if (dfh->dfh_TF.tf_Style & FSF_TAGGED) {
	dfh->dfh_TF.tf_Style = (dfh->dfh_TF.tf_Style & ~FSF_TAGGED);
	dfhTags = (struct TagItem *) dfh->dfh_Segment;
    }
    else
	dfhTags = 0;

    /* set the dfh_Segment */
    dfh->dfh_Segment = (((ULONG) dfh)>>2)-2;	/* two longwords before dfh */

    if (ExtendFont(&dfh->dfh_TF, dfhTags)) {
	Forbid();
	AddDiskFont(dfl, dfh);
	Permit();
	return(&dfh->dfh_TF);
    }
    return(0);
}

struct TextFont *
loadDiskFont(
	struct DiskfontLibrary *dfl,
	struct TFontContents *tfc,
	char *name,
	char *fontPath)
{
    struct DiskFontHeader *dfh;
    struct TextFont *tf;
    BPTR dfs;
    char fontFile[256], *fp;

    strcpy(fontFile, fontPath);
    fp = FilePart(fontFile);
    tf = 0;
    strcpy(fp, tfc->tfc_FileName);
    D(("LoadSeg(\"%s\")", fontFile));
    dfh = (struct DiskFontHeader *) ((((ULONG) (dfs = (BPTR)
	    LoadSeg(fontFile))) << 2) + 8);
    D((", dfh = 0x%lx\n", dfh));
    if (((ULONG) dfh) != 8) {
	if (dfh->dfh_FileID == DFH_ID) {
	    strcpy(dfh->dfh_Name, name);
	    tf = PatchDiskFont(dfl, dfh);
	}
	if (!tf)
	    UnLoadSeg(dfs);
    }
    return(tf);
}


struct TextFont *
openSimilarFont(
	struct DiskfontLibrary *dfl,
	struct TTextAttr *tta,
	struct TFontContents *tfc,
	BOOL tfcTFlag,
	UWORD tfcSize,
	BOOL scaleOKFlag,
	char *fontPath)
{
    struct TextFont *tf;

    union {
	ULONG TagDPI;
	struct {
	    UWORD DPIX;
	    UWORD DPIY;
	} Tag;
    } t1, t2;
    int y1, y2;
    short i;
    BOOL isTagAware;

    D(("openSimilarFont((,%s, %ld, 0x%02lx, 0x%02lx),,,,)\n", tta->tta_Name,
	    tta->tta_YSize, tta->tta_Style, tta->tta_Flags));
    /* look for match in ram */
    Forbid();
    tf = (struct TextFont *) &GfxBase->TextFonts;
    D(("  ram\n"));
    while (tf = (struct TextFont *)
	    FindName((struct List *) tf, tta->tta_Name)) {
	D(("    (, %ld, 0x%02lx, 0x%02lx), ", tf->tf_YSize, tf->tf_Style,
		tf->tf_Flags));

	if ((!scaleOKFlag) &&
		(!(tf->tf_Flags & (FPF_ROMFONT|FPF_DISKFONT|FPF_DESIGNED)))) {
	    D(("font already scaled\n"));
	    continue;
	}
	/* check YSize match */
	if (tf->tf_YSize != tta->tta_YSize) {
	    D(("YSize mismatch\n"));
	    continue;
	}
	/* check attributes match */
	if ((tf->tf_Style & (FSF_UNDERLINED|FSF_BOLD|FSF_ITALIC)) !=
		(tta->tta_Style & (FSF_UNDERLINED|FSF_BOLD|FSF_ITALIC))) {
	    D(("Style mismatch\n"));
	    continue;
	}

/* If tagged request, must match DPI for RAM fonts */

	isTagAware = FALSE;

	if ((tta->tta_Style & FSF_TAGGED)) { 
	    /* check aspect match */
	    t1.TagDPI = GetTagData(TA_DeviceDPI, 0, tta->tta_Tags);
	    if (t1.TagDPI) {

		isTagAware = TRUE;

/* assume 1:1 if no DPI */

		t2.TagDPI = GetTagData(TA_DeviceDPI, 0x00010001,
			((struct TextFontExtension *) tf->tf_Extension)->
			tfe_Tags);
		if (t2.TagDPI) {
		    y1 = (tta->tta_YSize * t1.Tag.DPIX) / t1.Tag.DPIY;
		    y2 = (tf->tf_YSize * t2.Tag.DPIX) / t2.Tag.DPIY;
		    D(("    tagged: %ld vs. %ld\n", y2, y1));
		    if (y2 != y1)
			continue;
		}
	    }
	}

	/* If not tag aware, make sure this is not a DUP font which cannot
	   be opened
	*/
	if(!(isTagAware))
	{
		if(((struct TextFontExtension *) tf->tf_Extension)->tfe_Flags0 & TE0F_DUPLICATE)
		{
			D(("   NOT TAG AWARE; FONT IS A DUPLCATE\n"));
			continue;
		}
	}
	/* this candidate matches */
	break;
    }

    if (tf) {
	tf->tf_Accessors++;
	D(("bumped similar tf 0x%lx accessors to %ld\n",
		tf, tf->tf_Accessors));
	Permit();
	return(tf);
    }

    Permit();

    /* look for match in contents */
    D(("  disk\n"));

    for (i = 0; i < tfcSize; i++)
    {
	D(("    (, %ld, 0x%02lx, 0x%02lx), ", tfc[i].tfc_YSize,
		tfc[i].tfc_Style, tfc[i].tfc_Flags));
	/* check YSize match */
	if (tfc[i].tfc_YSize != tta->tta_YSize)
	{
	    D(("YSize mismatch\n"));
	    continue;
	}
	/* check attributes match */
	if ((tfc[i].tfc_Style & (FSF_UNDERLINED|FSF_BOLD|FSF_ITALIC)) !=
		(tta->tta_Style & (FSF_UNDERLINED|FSF_BOLD|FSF_ITALIC)))
	{
	    D(("Style mismatch\n"));
	    continue;
	}

/**
   @@@@@@ Revisit - Darren

   This code seems wrong to me; I think what we really want here is
   to find best DPI fit given 1-N choices for matching Y size.

   Actually we really want best proportion, but I won't change the
   behavior of this code for the initial V39 release (safety).

   The problem with this code is if it fails because of a DPI mismatch,
   we end up using OpenWeighedFont(), which will try to come up with
   something closest in Y size rather than ideal proportions, and we
   are probably better off using a 1x, 1/2x, or 2x font.

   This code is a NOP for our diskfonts which do not use tags; gack!!

**/

	if ((tfcTFlag) && (tta->tta_Style & FSF_TAGGED) &&
		(tfc[i].tfc_TagCount))
	    {
	    t1.TagDPI = GetTagData(TA_DeviceDPI, 0, tta->tta_Tags);
	    if (t1.TagDPI) {
		t2.TagDPI = GetTagData(TA_DeviceDPI, 0,
			(struct TagItem *) &tfc[i].tfc_FileName[MAXFONTPATH-
			(tfc[i].tfc_TagCount*sizeof(struct TagItem))]);
		if (t2.TagDPI) {
		    y1 = (tta->tta_YSize * t1.Tag.DPIX) / t1.Tag.DPIY;
		    y2 = (tfc[i].tfc_YSize * t2.Tag.DPIX) / t2.Tag.DPIY;
		    D(("tagged: %ld vs. %ld, ", y2, y1));
		    if (y2 != y1) {
			D(("tag mismatch\n"));
			continue;
		    }
		}
	    }
	}

	D(("MATCH.  Attempt load.\n"));
	tf = loadDiskFont(dfl, tfc+i, tta->tta_Name, fontPath);
	if (tf)
	    return(tf);

    }

    return(0);				/* indicate no match */
}


struct TextFont *
openScaledFontSource(
	struct DiskfontLibrary *dfl,
	struct TTextAttr *tta,
	struct TFontContents *tfc,
	BOOL tfcTFlag,
	UWORD tfcSize,
	char *fontPath)
{
    struct TTextAttr ttta;
    struct TextFont *tf;

    ttta = *tta;

    for (;;) {
	/* look for exact size font */
	ttta.tta_YSize = tta->tta_YSize;
	if (tf = openSimilarFont(dfl, &ttta, tfc, tfcTFlag, tfcSize, 1,
		fontPath)) {
	    D(("found exact size font 0x%lx\n", tf));
	    return(tf);
	}

	/* look for double size font */
	ttta.tta_YSize = tta->tta_YSize*2;
	if (tf = openSimilarFont(dfl, &ttta, tfc, tfcTFlag, tfcSize, 0,
		fontPath)) {
	    D(("found double size font 0x%lx\n", tf));
	    return(tf);
	}

	/* look for half size font */
	if ((tta->tta_YSize & 1) == 0) {
	    /* half is an even integer */
	    ttta.tta_YSize = tta->tta_YSize/2;
	    if (tf = openSimilarFont(dfl, &ttta, tfc, tfcTFlag, tfcSize, 0,
		    fontPath)) {
		D(("found half size font 0x%lx\n", tf));
		return(tf);
	    }
	}

	/* try looser style restrictions that can be AlgoStyle'd later */
	if (ttta.tta_Style & FSF_UNDERLINED)
	    ttta.tta_Style &= ~FSF_UNDERLINED;
	else if (ttta.tta_Style & FSF_BOLD)
	    ttta.tta_Style &= ~FSF_BOLD;
	else if (ttta.tta_Style & FSF_ITALIC)
	    ttta.tta_Style &= ~FSF_ITALIC;
	else
	    break;
    }
    D(("found no applicable font\n"));
    return(0);
}


struct TextFont *
OpenWeighedFont(
	struct DiskfontLibrary *dfl,
	char *fontPath,
	struct TTextAttr *tta,		/* textAttr w/ FilePart of name */
	struct FontContentsHeader *fch,
	struct TFontContents *tfc,
	struct TextFont *tfRam,
	WORD wRam)
{
    struct TextFont *tf;
    WORD wCurr, wTemp;
    WORD wdIndex, i;

    /* grab the closest font a la OpenFont */
    D(("OpenWeighedFont(,,,,,, %ld)\n", wRam));
    do {
	wCurr = wRam;
	wdIndex = -1;
	if (fch->fch_FileID == FCH_ID) {
	    D(("FCH_ID "));
	    for (i = 0; i < fch->fch_NumEntries; i++) {
		wTemp = WeighTAMatch((struct TextAttr *) tta,
			(struct TextAttr *) (((ULONG) &tfc[i].tfc_YSize)-4), 0);
		D(("tfc[%ld] (%ld, 0x%lx, 0x%lx): %ld\n", i, tfc[i].tfc_YSize,
			tfc[i].tfc_Style, tfc[i].tfc_Flags, wTemp));
		if (wTemp > wCurr) {
		    wCurr = wTemp;
		    wdIndex = i;
		}
	    }
	}
	else {
	    D(("TFCH_ID "));
	    for (i = 0; i < fch->fch_NumEntries; i++) {
		if (tfc[i].tfc_TagCount) {
		    wTemp = WeighTAMatch((struct TextAttr *) tta,
			    (struct TextAttr *) (((ULONG) &tfc[i].tfc_YSize)-4),
			    (struct TagItem *) &tfc[i].tfc_FileName[MAXFONTPATH-
			    (tfc[i].tfc_TagCount*
			    sizeof(struct TagItem))]);
		    D(("tfc[%ld] (%ld, 0x%lx, 0x%lx, tagged): %ld\n", i,
			    tfc[i].tfc_YSize, tfc[i].tfc_Style,
			    tfc[i].tfc_Flags, wTemp));
		}
		else {
		    wTemp = WeighTAMatch((struct TextAttr *) tta,
			    (struct TextAttr *) (((ULONG) &tfc[i].tfc_YSize)-4),
			    0);
		    D(("tfc[%ld] (%ld, 0x%lx, 0x%lx, untagged): %ld\n", i,
			    tfc[i].tfc_YSize, tfc[i].tfc_Style,
			    tfc[i].tfc_Flags, wTemp));
		}
		if (wTemp > wCurr) {
		    wCurr = wTemp;
		    wdIndex = i;
		}
	    }
	}
	D(("wdIndex %ld\n", wdIndex));
	if (wdIndex >= 0) {
	    tf = loadDiskFont(dfl, tfc+wdIndex, tta->tta_Name, fontPath);
	    if (tf) {
		if (tfRam != 0) {
		    D(("close weighed ram font 0x%lx from %ld accessors\n",
			    tfRam, tfRam->tf_Accessors));
		    CloseFont(tfRam);
		}
		return(tf);
	    }
	    tfc[wdIndex].tfc_YSize = 0;	/* mark entry bad */
	}
    }
	while(wdIndex >= 0);

    return(tfRam);
}


struct TextFont * __asm DFOpenDiskFont(
	register __a6 struct DiskfontLibrary *dfl,
	register __a0 struct TTextAttr *textAttr)
{
    struct TTextAttr tta;		/* textAttr w/ FilePart of name */
    struct TextFont *tf, *tfRam, *tfSrc;
    struct DiskFontHeader *dfh;

    char fontPath[256];

    LONG fcFile, fcSize;

    struct FontContentsHeader fch;
    struct TFontContents *tfc;

    WORD wRam;

    LONG srcDPI, destDPI;

    BOOL scaleFlag;

    D(("OpenDiskFont((\"%s\", %ld, 0x%02lx, 0x%02lx)) from %s 0x%lx\n",
	    textAttr->tta_Name, textAttr->tta_YSize, textAttr->tta_Style,
	    textAttr->tta_Flags,
	    ((struct Task *) FindTask(0))->tc_Node.ln_Type == NT_PROCESS ?
	    "process" : "task", FindTask(0)));

    /* copy textAttr into tta, but with FilePart of name */
    tta = *textAttr;
    tta.tta_Name = FilePart(textAttr->tta_Name);
    if (tta.tta_YSize == 0)
	tta.tta_YSize = 1;

    /* single thread loading from disk */
    ObtainSemaphore(&dfl->dfl_BSemaphore);
    D(("  have semaphore\n"));

    wRam = 0;
    /* find best ram font */
    tfRam = OpenFont((struct TextAttr *) &tta);
    D(("  OpenFont((\"%s\", )): 0x%lx\n", tta.tta_Name, tfRam));
    if (tfRam != 0) {
	D(("    ram YSize %ld, Style 0x%02lx, Flags0x%02lx\n",
	    tfRam->tf_YSize, tfRam->tf_Style, tfRam->tf_Flags));
	/* get the weight for the resulting ram font */
	wRam = WeighTAMatch((struct TextAttr *) &tta,
		(struct TextAttr *) (((ULONG) &tfRam->tf_YSize)-4),
		((struct TextFontExtension *) tfRam->tf_Extension)->tfe_Tags);
	D(("tfRam 0x%lx, wRam %ld\n", tfRam, wRam));

        if (wRam == MAXFONTMATCHWEIGHT) {
            /* exact match: cannot get better from here! */
	    ReleaseSemaphore(&dfl->dfl_BSemaphore);
            return(tfRam);
	}
    }

    /* construct path to font from FONTS: */
    if (strchr(textAttr->tta_Name, ':'))
	strcpy(fontPath, textAttr->tta_Name);
    else {
	strcpy(fontPath, "FONTS:");
	AddPart(fontPath, textAttr->tta_Name, 256);
    }

    /* try to open the font contents file associated with the font */
    fch.fch_NumEntries = 0;
    fch.fch_FileID = OFCH_ID;
    tfc = 0;

    D(("  Open(\"%s\")", fontPath));
    if (fcFile = Open(fontPath, MODE_OLDFILE)) {
	D((": 0x%lx\n  Read()", fcFile));
	/* read and verify the font contents header */
	if ((Read(fcFile, &fch, sizeof(fch)) == sizeof(fch)) &&
		((fch.fch_FileID & 0xfff0) == FCH_ID)) {
	    fcSize = fch.fch_NumEntries*sizeof(struct TFontContents);
	    D((", n = %ld\n  AllocMem(%ld)", fch.fch_NumEntries, fcSize));
	    /* read the font contents into a buffer */
	    if ((fcSize) &&
		    (tfc = (struct FontContentsEntry *) AllocMem(fcSize, 0))) {
		D((": 0x%lx\n  Read()", tfc));
		if (fcSize != Read(fcFile, tfc, fcSize)) {
		    D((": failure\n"));
		    /* font contents read failure */
		    FreeMem(tfc, fcSize);
		    tfc = 0;
		}
	    }
	}
	D(("  Close($%lx)", fcFile));
	Close(fcFile);
	D(("\n"));
    }

    D(("tfc 0x%lx\n", tfc));
    if (!tfc)
	fch.fch_NumEntries = 0;

    if ((tfc) && (tfRam) && (fch.fch_FileID == FCH_ID) &&
	    (tta.tta_Style & FSF_TAGGED)) {

	D(("!!! RETRY WEIGHT !!!\n"));

	wRam = WeighTAMatch((struct TextAttr *) &tta,
		(struct TextAttr *) (((ULONG) &tfRam->tf_YSize)-4), 0);
    }

    /* special case outline font */
    if (fch.fch_FileID == OFCH_ID) {
	D(("outline font\n"));
	tf = GenFont(dfl, fontPath, &tta, &fch, tfc,
		tfRam, wRam);
    }

    /* redo match strategy if scaling */
    else if (!(textAttr->tta_Flags & FPF_DESIGNED)) {
	D(("scaling OK\n"));

	if (tfRam) {
	    D(("close original ram font 0x%lx from %ld accessors\n", tfRam,
		    tfRam->tf_Accessors));
	    CloseFont(tfRam);
	}

	/* scaling will occur for inexact match */
	if (tfc)
	    /* disk font available */
	    tfSrc = openScaledFontSource(dfl, &tta, tfc,
		    (BOOL) (fch.fch_FileID != FCH_ID), fch.fch_NumEntries,
		    fontPath);
	else
	    /* just rom/memory font available */
	    tfSrc = openScaledFontSource(dfl, &tta, 0, 1, 0, 0);

	if (tfSrc == 0) {
	    /* find best match for scaling that's *not* exact, *2 or /2 */
	    tta.tta_Flags |= FPF_DESIGNED;
	    tfRam = OpenFont((struct TextAttr *) &tta);
	    D(("  OpenFont((\"%s\", )): 0x%lx\n", tta.tta_Name, tfRam));
	    if (tfRam != 0) {
		/* get the weight for the resulting ram font */
		wRam = WeighTAMatch((struct TextAttr *) &tta,
			(struct TextAttr *) (((ULONG) &tfRam->tf_YSize)-4),
			((struct TextFontExtension *) tfRam->tf_Extension)->
			tfe_Tags);
		D(("tfRam 0x%lx, wRam %ld\n", tfRam, wRam));
	    }
	    else {
		wRam = 0;
	    }
	    tfSrc = OpenWeighedFont(dfl, fontPath, &tta, &fch, tfc,
		    tfRam, wRam);
	}

	tf = tfSrc;

	if (tfSrc == 0)
	    goto unDOS;

	scaleFlag = FALSE;

	/* check for differing Y size or aspect ratio */
	if (tta.tta_YSize != tfSrc->tf_YSize) scaleFlag = TRUE;
	
	if ((tta.tta_Style & FSF_TAGGED) &&
		    (ExtendFont(tfSrc,0))) {
		srcDPI = GetTagData(TA_DeviceDPI, 0x00010001,
			((struct TextFontExtension *) tfSrc->tf_Extension)->tfe_Tags);
	D(("srcDPI=$%lx\n",srcDPI));

		if (srcDPI) {
		    destDPI = GetTagData(TA_DeviceDPI, 0, tta.tta_Tags);

	D(("destDPI=$%lx\n",destDPI));

		    if (destDPI) {
			if (!EqualAspect(srcDPI, destDPI))
			{

			    scaleFlag = TRUE;
			}
		    }
		}
            }

	if (scaleFlag) {
	    /* construct scaled font */
	    dfh = (struct DiskFontHeader *) NewScaledDiskFont(tfSrc, &tta);
	    D(("scaling font 0x%lx, resulting in 0x%lx\n", tfSrc, dfh));
	    if (dfh != 0) {
		/* release source font and add new scaled font */
		D(("close source font 0x%lx from %ld accessors\n", tfSrc,
			tfSrc->tf_Accessors));
		CloseFont(tfSrc);
		tf = &dfh->dfh_TF;

		Forbid();
		AddDiskFont(dfl, dfh);
		Permit();
	    }
	}
    }
    else {
	tf = OpenWeighedFont(dfl, fontPath, &tta, &fch, tfc,
		tfRam, wRam);
    }

unDOS:
    D(("unDOS\n"));
    if (tfc) {
	D(("FreeMem(tfc)\n"));
	FreeMem(tfc, fcSize);
    }
    D(("OpenDiskFont result $%lx\n", tf));

    ReleaseSemaphore(&dfl->dfl_BSemaphore);
    return(tf);
}
@


39.0
log
@First pass at supporting multiple fonts of same Y size, name, and style
@
text
@d2 1
a2 1
**	$Id: opendiskfont.c,v 38.5 92/06/18 11:46:50 darren Exp $
d57 4
d202 1
d212 1
a212 1

d224 1
a224 1
	/* check if scaled font and scaled font OK */
d242 1
a242 1
/*	if ((tfcTFlag) && (tta->tta_Style & FSF_TAGGED)) { */
d244 1
a244 1
/* If tagged request, must match DPI for RAM fonts */
d250 6
a255 1
		t2.TagDPI = GetTagData(TA_DeviceDPI, 0,
d267 12
d295 3
a297 1
    for (i = 0; i < tfcSize; i++) {
d301 2
a302 1
	if (tfc[i].tfc_YSize != tta->tta_YSize) {
d308 2
a309 1
		(tta->tta_Style & (FSF_UNDERLINED|FSF_BOLD|FSF_ITALIC))) {
d314 18
d333 2
a334 2
		(tfc[i].tfc_TagCount)) {
	    /* check aspect match */
a351 1
	/* this candidate matches */
d356 1
d600 3
a602 1
	/* rom match weight might have included tags, remove them */
@


38.5
log
@Autodoc changes; doc changes were lost when Bob was working on
phase 2 of diskfont
@
text
@d2 1
a2 1
**	$Id: opendiskfont.c,v 38.4 92/03/26 11:58:12 davidj Exp Locker: darren $
d14 1
d208 1
d237 5
a241 1
	if ((tfcTFlag) && (tta->tta_Style & FSF_TAGGED)) {
a256 1

d504 1
d613 2
d616 8
a623 9
	if (tta.tta_YSize != tfSrc->tf_YSize)
	    scaleFlag = 1;
	else {
	    scaleFlag = 0;
	    if ((tta.tta_Style & FSF_TAGGED) &&
		    (tfSrc->tf_Style & FSF_TAGGED)) {
		srcDPI = GetTagData(TA_DeviceDPI, 0,
			((struct TextFontExtension *) tfSrc->tf_Extension)->
			tfe_Tags);
d626 3
d631 4
a634 1
			    scaleFlag = 1;
d637 2
a638 2
	    }
	}
d649 1
@


38.4
log
@changed reference to diskfonttag.h
@
text
@d2 1
a2 1
**	$Id: opendiskfont.c,v 38.3 91/04/09 21:33:17 kodiak Exp Locker: davidj $
d90 24
@


38.3
log
@(I think this was before 38.3) check in file that was not checked
out but had differences (eliminated unnecessary assignments)
@
text
@d2 1
a2 1
**	$Id: opendiskfont.c,v 37.1 91/01/31 14:37:31 kodiak Exp Locker: kodiak $
d24 1
a24 1
#include        <exec/types.h>
d26 2
a27 11
#include        "diskfont.h"
#include	"diskfonttag.h"
#include        "dfdata.h"

#include        <exec/nodes.h>
#include        <exec/lists.h>
#include        <exec/ports.h>
#include        <libraries/dos.h>
#include        <graphics/text.h>
#include	<graphics/gfxbase.h>
#include	<utility/tagitem.h>
d29 10
a38 1
#include	<string.h>
d42 8
a49 8
#include	<clib/dos_protos.h>
#include	<clib/exec_protos.h>
#include	<clib/graphics_protos.h>
#include	<clib/utility_protos.h>
#include	<pragmas/exec_pragmas.h>
#include	<pragmas/dos_pragmas.h>
#include	<pragmas/graphics_pragmas.h>
#include	<pragmas/utility_pragmas.h>
d241 1
a241 1
    
d331 1
a331 1
	
d377 1
a377 1
	    } 
d404 1
a404 1
	    } 
d452 1
a452 1
    
@


37.1
log
@change GenFont interface, change other names for export
ensure YSize is at least 1
@
text
@d2 1
a2 1
**	$Id: opendiskfont.c,v 37.0 90/11/26 12:13:58 kodiak Exp Locker: kodiak $
d315 1
a315 1
	if (tf =openSimilarFont(dfl, &ttta, tfc, tfcTFlag, tfcSize, 0,
d465 1
a465 1
    tf = tfRam = OpenFont((struct TextAttr *) &tta);
a545 1
	    tfRam = 0;
a581 2

	dfh = 0;
@


37.0
log
@alpha 2 Bullet
@
text
@d2 1
a2 1
**	$Id: opendiskfont.c,v 36.21 90/05/21 08:10:42 kodiak Exp Locker: kodiak $
d56 5
a60 2
struct DiskFontHeader * __saveds GenFont(struct DiskfontLibrary *dfl,
	char *fontPath, struct TTextAttr *tta, struct TagItem *otags);
d97 1
a97 1
struct TextFont *patchDiskFont(
d140 1
a140 2
    char *fp;

d142 2
a143 1
    fp = FilePart(fontPath);
d146 1
a146 1
    D(("LoadSeg(\"%s\")", fontPath));
d148 1
a148 1
	    LoadSeg(fontPath))) << 2) + 8);
d153 1
a153 1
	    tf = patchDiskFont(dfl, dfh);
d265 1
a265 1
			(struct TagItem *) &tfc[i].tfc_FileName[MAXFONTNAME-
d348 1
a348 1
reopenWeighedFont(
d350 1
d355 1
a355 2
	WORD wRam,
	char *fontPath)
d362 1
a362 1
    D(("reopenWeighedFont(,,,,, %ld,)\n", wRam));
d385 1
a385 1
			    (struct TagItem *) &tfc[i].tfc_FileName[MAXFONTNAME-
d434 1
a434 1
    char fontPath[256], *s;
a446 2
    struct TagItem *tags, tag;

d456 2
d521 2
d534 2
a535 31
	/* get associated .otag file */
	if (s = strrchr(fontPath, '.')) {
	    strcpy(s, OTSUFFIX);
	    D((".otag name %s\n", fontPath));
	    if (fcFile = Open(fontPath, MODE_OLDFILE)) {
		D((": 0x%lx\n  Read() .otag\n", fcFile));
		/* read and verify the .otag */
		if ((Read(fcFile, &tag, sizeof(tag)) == sizeof(tag)) &&
			(tag.ti_Tag == OT_FileIdent)) {
		    D(("  OT_FileIdent %ld\n", tag.ti_Data));
		    Seek(fcFile, 0, OFFSET_END);
		    if ((tag.ti_Data == Seek(fcFile, 0, OFFSET_BEGINNING)) &&
			    (tags = (struct TagItem *)
			    AllocMem(tag.ti_Data, 0))) {
			D(("  tags allocated\n"));
			/* this is a valid .otag file */
			if ((Read(fcFile, tags, tag.ti_Data) == tag.ti_Data)) {
			    dfh = GenFont(dfl, fontPath, &tta, tags);
			    if (dfh) {
				if (tfSrc = patchDiskFont(dfl, dfh))
				    tf = tfSrc;
			    }
			}
			FreeMem(tags, tag.ti_Data);
		    }
		}
		D(("  Close($%lx)", fcFile));
		Close(fcFile);
		D(("\n"));
	    }
	}
d575 2
a576 2
	    tfSrc = reopenWeighedFont(dfl, &tta, &fch, tfc, tfRam, wRam,
		    fontPath);
d622 2
a623 1
	tf = reopenWeighedFont(dfl, &tta, &fch, tfc, tfRam, wRam, fontPath);
@


36.21
log
@fix open counts for sources of scaled fonts
@
text
@d2 1
a2 1
**	$Id$
d6 2
d27 1
d39 3
d43 1
d45 2
d49 1
d51 4
a54 2
#define	DOSBase	dfl->dfl_DOSBase
#define	GfxBase	dfl->dfl_GfxBase
d56 2
a57 1
extern char *TailPath();
d94 33
d135 1
a135 1
    struct TagItem *dfhTags;
d140 2
a141 1
    fp = TailPath(fontPath);
a148 2
	    dfhTags = (struct TagItem *) dfh->dfh_Segment;
	    dfh->dfh_Segment = dfs;
d150 1
a150 16

	    /* fix bugs in some font editors: */
	    dfh->dfh_TF.tf_Message.mn_Node.ln_Name = dfh->dfh_Name;
	    if (dfh->dfh_TF.tf_Baseline >= dfh->dfh_TF.tf_YSize)
		dfh->dfh_TF.tf_Baseline = dfh->dfh_TF.tf_YSize - 1;

	    if (!(dfh->dfh_TF.tf_Style & FSF_TAGGED))
		dfhTags = 0;
	    dfh->dfh_TF.tf_Flags = (dfh->dfh_TF.tf_Flags & ~FPF_ROMFONT) |
		    FPF_DISKFONT;
	    if (ExtendFont(&dfh->dfh_TF, dfhTags)) {
		Forbid();
		AddDiskFont(dfh);
		Permit();
		return(&dfh->dfh_TF);
	    }
d152 2
a153 1
	UnLoadSeg(dfs);
d155 1
a155 1
    return(0);
d186 2
a187 1
    while (tf = (struct TextFont *) FindName(tf, tta->tta_Name)) {
d347 1
a347 1
	struct TTextAttr *tta,		/* textAttr w/ TailPath of name */
d427 1
a427 1
    struct TTextAttr tta;		/* textAttr w/ TailPath of name */
d431 1
a431 1
    char fontPath[256];
d444 2
d452 1
a452 1
    /* copy textAttr into tta, but with TailPath of name */
d454 5
a458 1
    tta.tta_Name = TailPath(textAttr->tta_Name);
d465 2
d472 1
a472 1
        if (wRam == MAXFONTMATCHWEIGHT)
d474 1
d476 1
d480 3
a482 2
    fontPath[0] = '\0';
    if (strrchr(textAttr->tta_Name, ':') == 0)
d484 2
a485 1
    strcat(fontPath, textAttr->tta_Name);
d489 1
d501 2
a502 1
	    if (tfc = (struct FontContentsEntry *) AllocMem(fcSize, 0)) {
d512 1
a512 1
	D(("  Close()"));
d526 36
d563 1
a563 1
    if (!(textAttr->tta_Flags & FPF_DESIGNED)) {
d640 1
a640 1
		AddDiskFont(dfh);
d650 3
a652 1
    if (tfc)
d654 4
@


36.20
log
@fix bad baselines that come along
@
text
@d2 1
a2 1
**	$Header: V36:src/workbench/libs/diskfont/RCS/opendiskfont.c,v 36.19 90/05/09 21:46:20 kodiak Exp Locker: kodiak $
d129 1
a129 1
findFont(
d149 1
a149 1
    D(("findFont((,%s, %ld, 0x%02lx, 0x%02lx),,,,)\n", tta->tta_Name,
d199 2
d256 1
a256 1
scaledFontSource(
d272 2
a273 1
	if (tf = findFont(dfl, &ttta, tfc, tfcTFlag, tfcSize, 1, fontPath)) {
d280 2
a281 1
	if (tf =findFont(dfl, &ttta, tfc, tfcTFlag, tfcSize, 0, fontPath)) {
d290 2
a291 2
	    if (tf = findFont(dfl, &ttta, tfc, tfcTFlag, tfcSize, 0,
			fontPath)) {
d313 1
a313 1
findWeighedMatch(
d327 1
a327 1
    D(("findWeighedMatch(,,,,, %ld,)\n", wRam));
d374 6
a379 1
	    if (tf) 
d381 1
d483 8
d494 1
a494 1
	    tfSrc = scaledFontSource(dfl, &tta, tfc,
d499 1
a499 7
	    tfSrc = scaledFontSource(dfl, &tta, 0, 1, 0, 0);

	/* in neither case is the original open of ram font still wanted */
	if (tfRam) {
	    CloseFont(tfRam);
	    tfRam = 0;
	}
d501 1
a501 1
	if (!tfSrc) {
d514 4
a517 1
	    tfSrc = findWeighedMatch(dfl, &tta, &fch, tfc, tfRam, wRam,
d521 2
a526 1
	tf = tfSrc;
d553 2
d564 1
a564 1
	tf = findWeighedMatch(dfl, &tta, &fch, tfc, tfRam, wRam, fontPath);
a565 3

    if ((tfRam) && (tf != tfRam))
	CloseFont(tfRam);
@


36.19
log
@require DESIGNED font for source for scaling
@
text
@d2 1
a2 1
**	$Header: V36:src/workbench/libs/diskfont/RCS/opendiskfont.c,v 36.18 90/05/01 02:12:17 kodiak Exp Locker: kodiak $
d106 4
a109 3
	    /* fix a bug in some font editors: */
	    dfh->dfh_TF.tf_Message.mn_Node.ln_Name =
		    dfh->dfh_Name;
@


36.18
log
@use Lattice strrchr instead of private rindex
@
text
@d2 1
a2 1
**	$Header: V36:src/workbench/libs/diskfont/RCS/opendiskfont.c,v 36.17 90/04/09 05:49:00 kodiak Exp Locker: kodiak $
d276 1
a276 1
	if (tf = findFont(dfl, &ttta, tfc, tfcTFlag, tfcSize, 0, fontPath)) {
d322 1
a322 1
    D(("findWeighedMatch(,,,,, %ld)\n", wRam));
d482 18
a499 4
	if (tfSrc) {
	    if (tfRam) {
		CloseFont(tfRam);
		tfRam = 0;
a500 2
	}
	else
d503 1
d510 1
@


36.17
log
@convert to both new rcs and native build
@
text
@d2 1
a2 1
**	$Header: Q:Src/diskfont/RCS/opendiskfont.c,v 36.16 90/03/08 15:17:20 kodiak Exp Locker: kodiak $
d35 1
d428 1
a428 1
    if (rindex(textAttr->tta_Name, ':') == 0)
@


36.16
log
@don't create fontPath unless sure that OpenFont didn't get sufficient font
@
text
@d2 1
a2 1
**	$Header: opendiskfont.c,v 36.15 90/02/26 20:15:41 kodiak Exp $
d9 3
d13 1
d19 4
a22 7
#include        "exec/types.h"
#include        "exec/nodes.h"
#include        "exec/lists.h"
#include        "exec/ports.h"
#include        "libraries/dos.h"
#include        "graphics/text.h"
#include	"graphics/gfxbase.h"
d27 16
a42 2
extern struct GfxBase *FetchGfxBase();
extern struct TextFont *OpenFont();
d81 5
a85 3
loadDiskFont(tfc, name, fontPath)
struct TFontContents *tfc;
char *name, *fontPath;
d127 8
a134 7
findFont(tta, tfc, tfcTFlag, tfcSize, scaleOKFlag, fontPath)
struct TTextAttr *tta;
struct TFontContents *tfc;
BOOL tfcTFlag;
UWORD tfcSize;
BOOL scaleOKFlag;
char *fontPath;
a135 1
    struct GfxBase *gfxBase;
d147 1
a147 1
    D(("findFont((%s, %ld, 0x%02lx, 0x%02lx),,,,)\n", tta->tta_Name,
a149 1
    gfxBase = FetchGfxBase();
d151 1
a151 1
    tf = (struct TextFont *) &gfxBase->TextFonts;
d226 1
a226 1
			&tfc[i].tfc_FileName[MAXFONTNAME-
d242 1
a242 1
	tf = loadDiskFont(tfc+i, tta->tta_Name, fontPath);
d251 8
a258 7
struct TextFont
*scaledFontSource(tta, tfc, tfcTFlag, tfcSize, fontPath)
struct TTextAttr *tta;
struct TFontContents *tfc;
BOOL tfcTFlag;
UWORD tfcSize;
char *fontPath;
d268 1
a268 1
	if (tf = findFont(&ttta, tfc, tfcTFlag, tfcSize, 1, fontPath)) {
d275 1
a275 1
	if (tf = findFont(&ttta, tfc, tfcTFlag, tfcSize, 0, fontPath)) {
d284 2
a285 1
	    if (tf = findFont(&ttta, tfc, tfcTFlag, tfcSize, 0, fontPath)) {
d307 8
a314 7
findWeighedMatch(tta, fch, tfc, tfRam, wRam, fontPath)
struct TTextAttr *tta;		/* textAttr w/ TailPath of name */
struct FontContentsHeader *fch;
struct TFontContents *tfc;
struct TextFont *tfRam;
WORD wRam;
char *fontPath;
d321 1
a321 1
    D(("findWeighedMatch(,,,, %ld)\n", wRam));
d328 2
a329 2
		wTemp = WeighTAMatch(tta,
			((ULONG) &tfc[i].tfc_YSize)-4, 0);
d342 3
a344 3
		    wTemp = WeighTAMatch(tta,
			    ((ULONG) &tfc[i].tfc_YSize)-4,
			    &tfc[i].tfc_FileName[MAXFONTNAME-
d352 3
a354 2
		    wTemp = WeighTAMatch(tta,
			    ((ULONG) &tfc[i].tfc_YSize)-4, 0);
d367 1
a367 1
	    tf = loadDiskFont(tfc+wdIndex, tta->tta_Name, fontPath);
d379 3
a381 3
struct TextFont
*DFCOpenDiskFont(textAttr)
struct TTextAttr *textAttr;
d394 1
a394 2
    WORD wRam, wCurr, wTemp;
    WORD wdIndex, i;
d412 1
a412 1
    tf = tfRam = OpenFont(&tta);
d416 2
a417 1
	wRam = WeighTAMatch(&tta, ((ULONG) &tfRam->tf_YSize)-4,
d464 2
a465 2
	wRam = WeighTAMatch(&tta,
		((ULONG) &tfRam->tf_YSize)-4, 0);
d474 3
a476 2
	    tfSrc = scaledFontSource(&tta, tfc, fch.fch_FileID != FCH_ID,
		    fch.fch_NumEntries, fontPath);
d479 1
a479 1
	    tfSrc = scaledFontSource(&tta, 0, 1, 0, 0);
d488 2
a489 1
	    tfSrc = findWeighedMatch(&tta, &fch, tfc, tfRam, wRam, fontPath);
d530 1
a530 1
	tf = findWeighedMatch(&tta, &fch, tfc, tfRam, wRam, fontPath);
@


36.15
log
@fix bad rindex call
@
text
@d2 1
a2 1
**	$Header: opendiskfont.c,v 36.14 90/02/23 13:10:26 kodiak Exp $
a390 6
    /* construct path to font from FONTS: */
    fontPath[0] = '\0';
    if (rindex(textAttr->tta_Name, ':') == 0)
	strcpy(fontPath, "FONTS:");
    strcat(fontPath, textAttr->tta_Name);

d404 6
@


36.14
log
@support assign paths in FONTS:
@
text
@d2 1
a2 1
**	$Header: opendiskfont.c,v 36.13 90/02/19 11:41:01 kodiak Exp $
d393 1
a393 1
    if (rindex(textAttr->tta_Name, ":") == 0)
@


36.13
log
@fix tf_Accessors of created fonts to be 1
@
text
@d2 1
a2 1
**	$Header: opendiskfont.c,v 36.12 90/02/18 18:03:00 kodiak Exp $
d66 1
a66 1
loadDiskFont(tfc, name)
d68 1
a68 1
char *name;
d73 1
d75 8
a82 3
    if ((dfh = (struct DiskFontHeader *) (( ((ULONG)
	    (dfs = (BPTR) LoadSeg(tfc->tfc_FileName))) <<2)
	    + 8)) != (struct DiskFontHeader *) 8) {
d110 1
a110 1
findFont(tta, tfc, tfcTFlag, tfcSize, scaleOKFlag, relation)
d116 1
a116 1
BOOL (*relation)();
d147 1
a147 1
	if (!(*relation)(tf->tf_YSize, tta->tta_YSize)) {
d169 1
a169 1
		    if (!(*relation)(y2, y1))
d193 1
a193 1
	if (!(*relation)(tfc[i].tfc_YSize, tta->tta_YSize)) {
d216 1
a216 1
		    if (!(*relation)(y2, y1)) {
d226 1
a226 1
	tf = loadDiskFont(tfc+i, tta->tta_Name);
a234 24
BOOL
equal(w1, w2)
WORD w1, w2;
{
    return((BOOL) (w1 == w2));
}


BOOL
greater(w1, w2)
WORD w1, w2;
{
    return((BOOL) (w1 >= w2));
}


BOOL
less(w1, w2)
WORD w1, w2;
{
    return((BOOL) (w1 <= w2));
}


d236 1
a236 1
*scaledFontSource(tta, tfc, tfcTFlag, tfcSize)
d241 1
d251 1
a251 1
	if (tf = findFont(&ttta, tfc, tfcTFlag, tfcSize, 1, equal)) {
d258 1
a258 1
	if (tf = findFont(&ttta, tfc, tfcTFlag, tfcSize, 0, equal)) {
d267 1
a267 1
	    if (tf = findFont(&ttta, tfc, tfcTFlag, tfcSize, 0, equal)) {
a272 15
#if	0
	/* look for larger font */
	ttta.tta_YSize = tta->tta_YSize;
	if (tf = findFont(&ttta, tfc, tfcTFlag, tfcSize, 0, greater)) {
	    D(("found larger font 0x%lx\n", tf));
	    return(tf);
	}

	/* look for smaller font */
	if (tf = findFont(&ttta, tfc, tfcTFlag, tfcSize, 0, less)) {
	    D(("found smaller font 0x%lx\n", tf));
	    return(tf);
	}
#endif
	
d289 1
a289 1
findWeighedMatch(tta, fch, tfc, tfRam, wRam)
d295 1
d347 1
a347 1
	    tf = loadDiskFont(tfc+wdIndex, tta->tta_Name);
d367 1
a367 2
    LONG fontDir, prevCurrDir, parentLock;
    LONG fcLock, fcFile, fcSize;
d369 2
d381 6
d391 5
a395 2
    D(("OpenDiskFont((\"%s\", %ld, 0x%02lx, 0x%02lx))\n", textAttr->tta_Name,
	    textAttr->tta_YSize, textAttr->tta_Style, textAttr->tta_Flags));
d400 1
a410 8
    /* change directory to the font directory */
    fontDir = Lock("FONTS:", SHARED_LOCK);
    if (fontDir == 0) {
	D(("FONTS: lock failure\n"));
	return(tfRam);
    }
    prevCurrDir = CurrentDir(fontDir);

d414 18
a431 15
    parentLock = 0;
    if (fcLock = Lock(textAttr->tta_Name, SHARED_LOCK)) {
        if (fcFile = Open(textAttr->tta_Name, MODE_OLDFILE)) {
            /* read and verify the font contents header */
            if ((Read(fcFile, &fch, sizeof(fch)) == sizeof(fch)) &&
		    ((fch.fch_FileID & 0xfff0) == FCH_ID)) {
		fcSize = fch.fch_NumEntries*sizeof(struct TFontContents);
		/* read the font contents into a buffer */
		if (tfc = (struct FontContentsEntry *) AllocMem(fcSize, 0)) {
		    if (fcSize != Read(fcFile, tfc, fcSize)) {
			/* font contents read failure */
			FreeMem(tfc, fcSize);
			tfc = 0;
		    }
	        }
a432 1
	    Close(fcFile);
d434 3
a436 3
	parentLock = ParentDir(fcLock);
	CurrentDir(parentLock);
	UnLock(fcLock);
d455 1
a455 1
		    fch.fch_NumEntries);
d458 1
a458 1
	    tfSrc = scaledFontSource(&tta, 0, 1, 0);
d467 1
a467 1
	    tfSrc = findWeighedMatch(&tta, &fch, tfc, tfRam, wRam);
d508 1
a508 1
	tf = findWeighedMatch(&tta, &fch, tfc, tfRam, wRam);
a516 4
    CurrentDir(prevCurrDir);
    UnLock(fontDir);
    if (parentLock != 0)
	UnLock(parentLock);
@


36.12
log
@ensure fch_NumEntries is zero for if font contents read fails
@
text
@d2 1
a2 1
**	$Header: opendiskfont.c,v 36.11 90/01/30 13:05:11 kodiak Exp $
a89 1
	    dfh->dfh_TF.tf_Accessors = 1;
@


36.11
log
@(turn off debug kprintfs)
@
text
@d2 1
a2 1
**	$Header: opendiskfont.c,v 36.10 90/01/30 13:01:23 kodiak Exp $
d441 1
@


36.10
log
@fix bugs, obsolete X..., introduce T..., rework scaling source strategy
@
text
@d2 1
a2 1
**	$Header: opendiskfont.c,v 36.9 90/01/09 19:13:27 kodiak Exp $
d9 1
d11 3
@


36.9
log
@eliminate faulty test of (null) font flag while looking for contents
match in findFont.

@
text
@d2 1
a2 1
**	$Header: opendiskfont.c,v 36.8 89/09/11 12:41:39 kodiak Exp $
d9 1
a9 1
#define	D(a)
d26 1
d62 2
a63 2
loadDiskFont(xfc, name)
struct XFontContents *xfc;
d67 1
d71 1
a71 1
	    (dfs = (BPTR) LoadSeg(xfc->xfc_FileName))) <<2)
d74 1
d82 4
a85 2
	    dfh->dfh_TF.tf_Flags = (dfh->dfh_TF.tf_Flags &
		    ~FPF_ROMFONT) | FPF_DISKFONT;
d87 6
a92 5
	    Forbid();
	    AddDiskFont(dfh);
	    Permit();

	    return(&dfh->dfh_TF);
d94 1
a94 3
	else {
	    UnLoadSeg(dfs);
	}
d101 5
a105 5
findFont(xta, xfc, xfcXFlag, xfcSize, scaleOKFlag, relation)
struct XTextAttr *xta;
struct XFontContents *xfc;
BOOL xfcXFlag;
UWORD xfcSize;
d111 8
d121 2
a122 1
    D(("findFont(%s %ld,,,,)\n", xta->xta_Name, xta->xta_YSize));
d126 22
a147 22
    tf = (struct TextFont *) FindName(&gfxBase->TextFonts, xta->xta_Name);
    while (tf)
	if (	/* scaled font and scaled font not OK */
		((!(tf->tf_Flags & (FPF_ROMFONT|FPF_DISKFONT|FPF_DESIGNED))) &&
		    (!scaleOKFlag)) ||
		/* YSize mismatch */
		(!(*relation)(tf->tf_YSize, xta->xta_YSize)) ||
		/* XSize mismatch & XSize relevant */
		((xta->xta_Flags & FPF_XTEXTATTR) &&
		    (tf->tf_XSize != xta->xta_XSize) &&
		    (xfcXFlag)) ||
		/* UNDERLINED mismatch */
		((tf->tf_Style & FSF_UNDERLINED) &&
		    (!(xta->xta_Style & FSF_UNDERLINED))) ||
		/* ITALIC mismatch */
		((tf->tf_Style & FSF_ITALIC) &&
		    (!(xta->xta_Style & FSF_ITALIC))))
	    /* get next candidate */
	    tf = (struct TextFont *) FindName(tf, xta->xta_Name);
	else
	    /* this candidate matches */
	    break;
d149 21
d179 8
a186 12
    for (i = 0; i < xfcSize; i++) {
	if (	(*relation)(xfc[i].xfc_YSize, xta->xta_YSize) /* YSize match */
		&& ((!xfcXFlag) ||			/* XSize irrelevant */
		(!(xta->xta_Flags & FPF_XTEXTATTR)) ||
		(xfc[i].xfc_XSize == xta->xta_XSize)) && /*   or match */
		((!(xfc[i].xfc_Style & FSF_UNDERLINED)) || /* Not UNDERLINED */
		(xta->xta_Style & FSF_UNDERLINED)) &&	/*   or asked for */
		((!(xfc[i].xfc_Style & FSF_ITALIC)) ||	/* Not ITALIC */
		(xta->xta_Style & FSF_ITALIC))) {	/*   or asked for */
	    tf = loadDiskFont(xfc+i, xta->xta_Name);
	    if (tf)
		return(tf);
d188 32
d251 5
a255 5
*scaledFontSource(xta, xfc, xfcXFlag, xfcSize)
struct XTextAttr *xta;
struct XFontContents *xfc;
BOOL xfcXFlag;
UWORD xfcSize;
d257 1
a257 1
    struct XTextAttr txta;
d260 1
a260 1
    txta = *xta;
d264 2
a265 1
	if (tf = findFont(&txta, xfc, xfcXFlag, xfcSize, 1, equal)) {
d271 2
a272 3
	txta.xta_YSize = xta->xta_YSize*2;
	txta.xta_XSize = xta->xta_XSize*2;
	if (tf = findFont(&txta, xfc, xfcXFlag, xfcSize, 0, equal)) {
d278 1
a278 3
	if (((xta->xta_YSize & 1) == 0) &&
		((!xfcXFlag) || (!(txta.xta_Flags & FPF_XTEXTATTR)) ||
		((xta->xta_XSize & 1) == 0))) {
d280 2
a281 3
	    txta.xta_YSize = xta->xta_YSize/2;
	    txta.xta_XSize = xta->xta_XSize/2;
	    if (tf = findFont(&txta, xfc, xfcXFlag, xfcSize, 0, equal)) {
d287 1
d289 2
a290 3
	txta.xta_YSize = xta->xta_YSize;
	txta.xta_XSize = xta->xta_XSize;
	if (tf = findFont(&txta, xfc, xfcXFlag, xfcSize, 0, greater)) {
d296 1
a296 1
	if (tf = findFont(&txta, xfc, xfcXFlag, xfcSize, 0, less)) {
d300 1
d302 7
a308 5
	/* try looser style restrictions */
	if ((txta.xta_Style & FSF_ITALIC) == 0)
	    txta.xta_Style |= FSF_ITALIC;
	else if ((txta.xta_Style & FSF_UNDERLINED) == 0)
	    txta.xta_Style |= FSF_UNDERLINED;
d317 70
d389 1
a389 1
struct XTextAttr *textAttr;
d391 1
a391 1
    struct XTextAttr xta;		/* textAttr w/ TailPath of name */
d399 1
a399 1
    struct XFontContents *xfc;
d404 1
a404 3
    /* copy textAttr into xta, but with TailPath of name */
    xta = *textAttr;
    xta.xta_Name = TailPath(textAttr->xta_Name);
d406 9
d417 1
a417 1
    tf = tfRam = OpenFont(&xta);
d420 2
a421 2
	wRam = WeighFontMatch(&xta, ((ULONG) &tfRam->tf_YSize)-4,
		tfRam->tf_XSize);
d437 1
a437 1
    xfc = 0;
d439 2
a440 2
    if (fcLock = Lock(textAttr->xta_Name, SHARED_LOCK)) {
        if (fcFile = Open(textAttr->xta_Name, MODE_OLDFILE)) {
d444 1
a444 1
		fcSize = fch.fch_NumEntries*sizeof(struct XFontContents);
d446 2
a447 2
		if (xfc = (struct FontContentsEntry *) AllocMem(fcSize, 0)) {
		    if (fcSize != Read(fcFile, xfc, fcSize)) {
d449 2
a450 2
			FreeMem(xfc, fcSize);
			xfc = 0;
d461 1
a461 1
    D(("xfc 0x%lx\n", xfc));
d463 9
a471 2
    /* match strategy depends upon whether scaling or not */
    if (!(textAttr->xta_Flags & FPF_DESIGNED)) {
d474 1
a474 1
	if (xfc)
d476 1
a476 1
	    tfSrc = scaledFontSource(&xta, xfc, fch.fch_FileID != FCH_ID,
d480 1
a480 1
	    tfSrc = scaledFontSource(&xta, 0, 1, 0);
d482 9
a494 2
	if (tfRam)
	    CloseFont(tfRam);
d496 20
a515 4
	/* check for differing X or Y size */
	if ((xta.xta_YSize != tfSrc->tf_YSize) ||
		( (xta.xta_Flags & FPF_XTEXTATTR) &&
		(xta.xta_XSize != tfSrc->tf_XSize) )) {
d517 1
a517 1
	    dfh = (struct DiskFontHeader *) NewScaledDiskFont(tfSrc, &xta);
d530 1
a530 54
	if (xfc) {
	    /* grab the closest font a la OpenFont */
	    if ((fch.fch_FileID == FCH_ID) && (tfRam) &&
		    (xta.xta_Flags & FPF_XTEXTATTR)) {
		/* rom match weight included X size, remove it */
		wRam = WeighFontMatch(&xta,
			((ULONG) &tfRam->tf_YSize)-4, 0);
	    }
	    do {
		wCurr = wRam;
		tf = tfRam;
		wdIndex = -1;
		if (fch.fch_FileID == FCH_ID) {
		    D(("FCH_ID "));
		    for (i = 0; i < fch.fch_NumEntries; i++) {
			D(("&fc[%ld].fc_YSize  0x%lx\n", i,
				&xfc[i].xfc_YSize));
			wTemp = WeighFontMatch(&xta,
				((ULONG) &xfc[i].xfc_YSize)-4, 0);
			if (wTemp > wCurr) {
			    wCurr = wTemp;
			    wdIndex = i;
			}
		    } 
		}
		else {
		    D(("XFCH_ID "));
		    for (i = 0; i < fch.fch_NumEntries; i++) {
			D(("&xfc[%ld].xfc_YSize  0x%lx\n", i,
				&xfc[i].xfc_YSize));
			wTemp = WeighFontMatch(&xta,
				((ULONG) &xfc[i].xfc_YSize)-4,
				xfc[i].xfc_XSize);
			if (wTemp > wCurr) {
			    wCurr = wTemp;
			    wdIndex = i;
			}
		    } 
		}
		D(("wdIndex %ld\n", wdIndex));
		if (wdIndex >= 0) {
		    tf = loadDiskFont(xfc+wdIndex, xta.xta_Name);
		    if (tf) 
			goto unDisk;
		    xfc[wdIndex].xfc_YSize = 0;	/* mark entry bad */
		}
	    }
		while(wdIndex >= 0);

unDisk:
	    if ((tfRam) && (tf != tfRam))
		CloseFont(tfRam);

	}
d533 2
d537 2
a538 2
    if (xfc)
	FreeMem(xfc, fcSize);
@


36.8
log
@use AddDiskFont as part of making ROMable
find already scaled fonts that are exact match
@
text
@d2 1
a2 1
**	$Header: opendiskfont.c,v 36.7 89/09/08 12:02:36 kodiak Exp $
d146 1
a146 2
	if (((tf->tf_Flags & (FPF_ROMFONT|FPF_DISKFONT|FPF_DESIGNED)) != 0) &&
		(*relation)(xfc[i].xfc_YSize, xta->xta_YSize) /* YSize match */
@


36.7
log
@completely rework bitmap scaling strategy
use WeighFontMatch if no scaling
@
text
@d2 1
a2 1
**	$Header: opendiskfont.c,v 36.6 89/05/17 12:19:48 kodiak Exp $
d22 1
a22 3
extern struct GfxBase *GfxBase;
extern struct DiskfontLibrary *DiskfontBase;

d25 1
d83 1
a83 3
	    AddFont(&dfh->dfh_TF);
	    AddTail(&DiskfontBase->dfl_DiskFonts, dfh);
	    (DiskfontBase->dfl_NumLFonts)++;
d97 1
a97 1
findFont(xta, xfc, xfcXFlag, xfcSize, relation)
d102 1
d105 1
d111 1
d113 22
a134 12
    tf = (struct TextFont *) FindName(&GfxBase->TextFonts, xta->xta_Name);
    while ((tf) &&					/* not end of list */
	    (((tf->tf_Flags & (FPF_ROMFONT|FPF_DISKFONT|FPF_DESIGNED)) == 0) ||
	    (!(*relation)(tf->tf_YSize, xta->xta_YSize)) || /* YSize match */
	    ((!xfcXFlag) &&				/* XSize irrelevant */
	    (!(xta->xta_Flags & FPF_XTEXTATTR)) &&
	    (tf->tf_XSize != xta->xta_XSize)) ||	/*   or match */
	    ((!(tf->tf_Style & FSF_UNDERLINED)) &&	/* Not UNDERLINED */
	    (xta->xta_Style & FSF_UNDERLINED)) ||	/*   or asked for */
	    ((!(tf->tf_Style & FSF_ITALIC)) &&		/* Not ITALIC */
	    (xta->xta_Style & FSF_ITALIC))))		/*   or asked for */
	tf = (struct TextFont *) FindName(tf, xta->xta_Name);
d203 1
a203 1
	if (tf = findFont(&txta, xfc, xfcXFlag, xfcSize, equal)) {
d211 1
a211 1
	if (tf = findFont(&txta, xfc, xfcXFlag, xfcSize, equal)) {
d223 1
a223 1
	    if (tf = findFont(&txta, xfc, xfcXFlag, xfcSize, equal)) {
d232 1
a232 1
	if (tf = findFont(&txta, xfc, xfcXFlag, xfcSize, greater)) {
d238 1
a238 1
	if (tf = findFont(&txta, xfc, xfcXFlag, xfcSize, less)) {
d257 1
a257 1
*OpenDiskFont(textAttr)
d356 1
a356 3
		AddFont(tf);
		AddTail(&DiskfontBase->dfl_DiskFonts, dfh);
		(DiskfontBase->dfl_NumLFonts)++;
@


36.6
log
@disable debugging
@
text
@d2 1
a2 1
**	$Header: opendiskfont.c,v 36.5 89/05/17 12:17:53 kodiak Exp $
d17 1
d22 1
a22 1
extern struct Library *GfxBase;
a27 1
#define MAXWEIGHT       32767   /* maximum possible */
d61 7
a67 6
/*                        underlined bold italic */
static int stWeight[] = { 4,         8,   16,    0,0,0,0,0 };
static int sfWeight[] = { 128,       128, 128,   0,0,0,0,0 };
/*                        rom-,diskfont,revpath,tall-,widedot,propor,design */
static int ftWeight[] = { 1,   1,       32768,  32,   32,     32,    2, 0 };
static int ffWeight[] = { 1,   1,       32768,  32,   32,     128,   2, 0 };
d69 32
a100 2
int
matchWeight(xta, fa, fx)
d102 4
a105 6
struct FontAttr {
    UWORD   fa_YSize;
    UBYTE   fa_Style;
    UBYTE   fa_Flags;
} *fa;
UWORD fx;
d107 2
a108 3
    short sDiff, fDiff;
    short mask, i;
    int result;
d110 20
a129 36
    D(("matchWeight(%ld..., %ld...): ", xta->xta_YSize, fa->fa_YSize));
    if (fa->fa_YSize) {
        /* start out with the largest weight */
        result = MAXWEIGHT;
        if ((sDiff = fa->fa_YSize - xta->xta_YSize) < 0)
            /* -64 for every pixel that the font is smaller than desired */
            result += sDiff * 64;
        else
            /* -256 for every pixel that the font is larger than desired */
            result -= sDiff * 256;
        if ((fx) && (xta->xta_Flags & FPF_XTEXTATTR)) {
	    if ((fDiff = fx - xta->xta_XSize) < 0)
	        /* -16 for every pixel that the font is smaller than desired */
	        result += fDiff * 16;
	    else
	        /* -64 for every pixel that the font is larger than desired */
	        result -= fDiff * 64;
        }
        sDiff = fa->fa_Style ^ xta->xta_Style;
        fDiff = fa->fa_Flags ^ xta->xta_Flags;
        mask = 1;
        for (i = 0; i < 7; i++) {
            if (sDiff & mask)
                if (fa->fa_Style & mask)
                    result -= sfWeight[i];
                else
                result -= stWeight[i];
            if (fDiff & mask)
                if (fa->fa_Flags & mask)
                    result -= ffWeight[i];
                else
                    result -= ftWeight[i];
            mask += mask;
        }
	D(("%ld\n", result));
        return(result);
d131 18
a148 3
    else {
	D(("-32767\n", result));
        return(-32767);
d150 2
d155 24
d180 67
d250 4
a253 3
    struct TextAttr rfa;
    struct XTextAttr xta;
    struct TextFont *bestRamFont, *result;
d256 1
d258 1
a258 4
    struct XFontContents *xfc, *wxfc;
    short weight, tweight, windex, i, j;
    struct DiskFontHeader *dfh;
    BPTR dfs;
d260 4
d266 12
a277 9
    weight = 0;
    if ((result = bestRamFont = OpenFont(&xta)) != 0) {
        rfa.ta_YSize = bestRamFont->tf_YSize;
        rfa.ta_Style = bestRamFont->tf_Style;
        rfa.ta_Flags = bestRamFont->tf_Flags;
	weight = matchWeight(&xta, &rfa.ta_YSize, bestRamFont->tf_XSize);
        if (weight == MAXWEIGHT)
            /* cannot get better from here! */
            return(result);
d279 1
d282 4
a285 1
    if (fontDir == 0) return(result);
d290 1
d300 1
d308 4
d313 41
a353 1
	D(("xfc 0x%lx\n", xfc));
d355 7
a361 1
	    /* search through the font list for the best match */
d363 3
a365 1
		windex = -1;
a367 4
		    if ((bestRamFont) && (xta.xta_Flags & FPF_XTEXTATTR)) {
			/* rom match weight included X size, remove it */
			weight = matchWeight(&xta, &rfa.ta_YSize, 0);
		    }
d371 5
a375 5
			tweight = matchWeight(&xta, &xfc[i].xfc_YSize, 0);
			if (tweight > weight) {
			    weight = tweight;
			    windex = i;
			    wxfc = &xfc[i];
d384 2
a385 1
			tweight = matchWeight(&xta, &xfc[i].xfc_YSize,
d387 3
a389 4
			if (tweight > weight) {
			    weight = tweight;
			    windex = i;
			    wxfc = &xfc[i];
d393 9
a401 10
		D(("windex %ld\n", windex));
		if (windex >= 0) {
		    parentLock = ParentDir(fcLock);
		    CurrentDir(parentLock);
		    if ((dfh = (struct DiskFontHeader *) (( ((ULONG)
			    (dfs = (BPTR) LoadSeg(wxfc->xfc_FileName))) <<2)
			    + 8)) != (struct DiskFontHeader *) 8) {
			if (dfh->dfh_FileID == DFH_ID) {
			    dfh->dfh_Segment = dfs;
			    strcpy(dfh->dfh_Name, xta.xta_Name);
d403 3
a405 3
			    /* fix a bug in some font editors: */
			    dfh->dfh_TF.tf_Message.mn_Node.ln_Name =
				    dfh->dfh_Name;
a406 25
			    dfh->dfh_TF.tf_Flags = (dfh->dfh_TF.tf_Flags &
				    ~FPF_ROMFONT) | FPF_DISKFONT;
			    dfh->dfh_TF.tf_Accessors = 1;
			    Forbid();
			    AddFont(&dfh->dfh_TF);
			    AddTail(&DiskfontBase->dfl_DiskFonts, dfh);
			    (DiskfontBase->dfl_NumLFonts)++;
			    Permit();

			    windex = -1;
			    result = &dfh->dfh_TF;
			}
			else {
			    UnLoadSeg(dfs);
			    wxfc->xfc_YSize = 0;
			}
		    }
		    else
			wxfc->xfc_YSize = 0;
		    if (parentLock != 0)
			UnLock(parentLock);
		}
	    }
		while(windex >= 0);
	    FreeMem(xfc, fcSize);
a407 2

	UnLock(fcLock);
d410 4
d416 3
a418 37

    if ((bestRamFont) && (result != bestRamFont))
	CloseFont(bestRamFont);

    /* check if a scaled font is more appropriate */
    if ((GfxBase->lib_Version > 34) && ((xta.xta_Flags & FPF_DESIGNED) == 0)) {
	dfh = 0;
	/* check for width specification */
	if (xta.xta_Flags & FPF_XTEXTATTR) {
	    /* check for differing X or Y size */
	    if ((xta.xta_YSize != result->tf_YSize) ||
		    (xta.xta_XSize != result->tf_XSize)) {
		dfh = (struct DiskFontHeader *) NewScaledDiskFont(result, &xta);
	    }
	}
	else {
	    /* check for differing aspect or Y size */
	    i = xta.xta_Flags & (FPF_TALLDOT|FPF_WIDEDOT);
	    if (i == (FPF_TALLDOT|FPF_WIDEDOT)) i = 0;
	    j = result->tf_Flags & (FPF_TALLDOT|FPF_WIDEDOT);
	    if (j == (FPF_TALLDOT|FPF_WIDEDOT)) j = 0;
	    if ((xta.xta_YSize != result->tf_YSize) || (i != j)) {
		dfh = (struct DiskFontHeader *) NewScaledDiskFont(result, &xta);
	    }
	}
	if (dfh != 0) {
	    CloseFont(result);
	    result = &dfh->dfh_TF;
	    Forbid();
	    AddFont(result);
	    AddTail(&DiskfontBase->dfl_DiskFonts, dfh);
	    (DiskfontBase->dfl_NumLFonts)++;
	    Permit();
	}
    }

    return(result);
@


36.5
log
@ensure font flags: ROMFONT clear DISKFONT set
@
text
@d2 1
a2 1
**	$Header: opendiskfont.c,v 36.4 89/05/16 17:48:24 kodiak Exp $
d9 1
a9 1
#define	D(a)	kprintf a
@


36.4
log
@debugging off
@
text
@d2 1
a2 1
**	$Header: opendiskfont.c,v 36.3 89/05/16 17:37:59 kodiak Exp $
d9 1
a9 1
#define	D(a)
d228 2
a229 1
			    dfh->dfh_TF.tf_Flags |= FPF_DISKFONT;
@


36.3
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Header$
d9 1
a9 1
#define	D(f)	f
d82 1
a82 1
    D(kprintf("matchWeight(%ld..., %ld...): ", xta->xta_YSize, fa->fa_YSize));
d116 1
a116 1
	D(kprintf("%ld\n", result));
d120 1
a120 1
	D(kprintf("-32767\n", result));
d177 1
a177 1
	D(kprintf("xfc 0x%lx\n", xfc));
d183 1
a183 1
		    D(kprintf("FCH_ID "));
d189 1
a189 1
			D(kprintf("&fc[%ld].fc_YSize  0x%lx\n", i,
d200 1
a200 1
		    D(kprintf("XFCH_ID "));
d202 1
a202 1
			D(kprintf("&xfc[%ld].xfc_YSize  0x%lx\n", i,
d213 1
a213 1
		D(kprintf("windex %ld\n", windex));
@


36.2
log
@support for X size specification with XTextAttr & XFontContents
@
text
@d1 8
@


36.1
log
@add scaling
@
text
@d1 2
d61 1
a61 1
matchWeight(xta, fc)
d63 6
a68 1
struct FontContents *fc;
d74 36
a109 26
    if (fc->fc_YSize) {
      /* start out with the largest weight */
      result = MAXWEIGHT;
      if ((sDiff = fc->fc_YSize - xta->xta_YSize) < 0)
        /* -64 for every pixel that the font is smaller than desired */
        result += sDiff * 64;
      else
        /* -256 for every pixel that the font is larger than desired */
        result -= sDiff * 256;
      sDiff = fc->fc_Style ^ xta->xta_Style;
      fDiff = fc->fc_Flags ^ xta->xta_Flags;
      mask = 1;
      for (i = 0; i < 7; i++) {
        if (sDiff & mask)
          if (fc->fc_Style & mask)
            result -= sfWeight[i];
          else
            result -= stWeight[i];
        if (fDiff & mask)
          if (fc->fc_Flags & mask)
            result -= ffWeight[i];
          else
            result -= ftWeight[i];
        mask += mask;
      }
      return(result);
d111 4
a114 2
    else
      return(-32767);
d122 1
a123 1
    struct FontContents rfc;
d128 1
a128 1
    struct FontContents *fc;
d135 1
d137 7
a143 6
      rfc.fc_YSize = bestRamFont->tf_YSize;
      rfc.fc_Style = bestRamFont->tf_Style;
      rfc.fc_Flags = bestRamFont->tf_Flags;
      if (matchWeight(&xta, &rfc) == MAXWEIGHT)
        /* cannot get better from here! */
        return(result);
d151 1
d153 15
a167 31
      if (fcFile = Open(textAttr->xta_Name, MODE_OLDFILE)) {
        /* read and verify the font contents header */
        if ((Read(fcFile, &fch, sizeof(fch)) == sizeof(fch)) &&
            (fch.fch_FileID = FCH_ID)) {
          fcSize = fch.fch_NumEntries*sizeof(*fc);
          /* read the font contents into a buffer */
          if (fc = (struct FontContentsEntry *) AllocMem(fcSize, 0)) {
            if (fcSize == Read(fcFile, fc, fcSize)) {
              /* search through the font list for the best match */
              do {
                if (bestRamFont)
                  weight = matchWeight(&xta, &rfc);
                else
                  weight = 0;
                windex = -1;
                for (i = 0; i < fch.fch_NumEntries; i++) {
                  tweight = matchWeight(&xta, &fc[i]);
                  if (tweight > weight) {
                    weight = tweight;
                    windex = i;
                  }
                }
                if (windex >= 0) {
                  parentLock = ParentDir(fcLock);
                  CurrentDir(parentLock);
                  if ((dfh = (struct DiskFontHeader *) (( ((ULONG)
                      (dfs = (BPTR) LoadSeg(fc[windex].fc_FileName))) <<2) + 8)
                      ) != (struct DiskFontHeader *) 8) {
                    if (dfh->dfh_FileID == DFH_ID) {
                      dfh->dfh_Segment = dfs;
                      strcpy(dfh->dfh_Name, xta.xta_Name);
d169 46
a214 2
                      /* fix a bug in some font editors: */
                      dfh->dfh_TF.tf_Message.mn_Node.ln_Name = dfh->dfh_Name;
d216 3
a218 7
                      dfh->dfh_TF.tf_Flags |= FPF_DISKFONT;
                      dfh->dfh_TF.tf_Accessors = 1;
                      Forbid();
                      AddFont(&dfh->dfh_TF);
                      AddTail(&DiskfontBase->dfl_DiskFonts, dfh);
                      (DiskfontBase->dfl_NumLFonts)++;
                      Permit();
d220 29
a248 23
                      windex = -1;
                      result = &dfh->dfh_TF;
                    }
                    else {
                      UnLoadSeg(dfs);
                      fc[windex].fc_YSize = 0;
                    }
                  }
                  else
                    fc[windex].fc_YSize = 0;
                  if (parentLock != 0)
                    UnLock(parentLock);
                }
              }
                while(windex >= 0);
            }
            FreeMem(fc, fcSize);
          }
        }
        Close(fcFile);
      }
      UnLock(fcLock);
    }
@


35.1
log
@ensure diskfont name is correct.
search for font path relative to directory of contents file.
@
text
@d11 2
a12 1
extern struct DiskfontLibrary *DFL;
d17 2
d47 2
a48 2
*	name components are longer than the maximum allowed
*	(30 characters).
d59 2
a60 2
matchWeight(ta, fc)
struct TextAttr *ta;
d63 3
a65 3
  short sDiff, fDiff;
  short mask, i;
  int result;
d67 27
a93 6
  if (fc->fc_YSize) {
    /* start out with the largest weight */
    result = 32767;
    if ((sDiff = fc->fc_YSize - ta->ta_YSize) < 0)
      /* -64 for every pixel that the font is smaller than desired */
      result += sDiff * 64;
d95 1
a95 22
      /* -256 for every pixel that the font is larger than desired */
      result -= sDiff * 256;
    sDiff = fc->fc_Style ^ ta->ta_Style;
    fDiff = fc->fc_Flags ^ ta->ta_Flags;
    mask = 1;
    for (i = 0; i < 7; i++) {
      if (sDiff & mask)
        if (fc->fc_Style & mask)
          result -= sfWeight[i];
        else
          result -= stWeight[i];
      if (fDiff & mask)
        if (fc->fc_Flags & mask)
          result -= ffWeight[i];
        else
          result -= ftWeight[i];
      mask += mask;
    }
    return(result);
  }
  else
    return(-32767);
d101 1
a101 1
struct TextAttr *textAttr;
d103 10
a112 10
  struct TextAttr ta;
  struct FontContents rfc;
  struct TextFont *bestRamFont, *result;
  LONG fontDir, prevCurrDir;
  LONG fcLock, fcFile, fcSize;
  struct FontContentsHeader fch;
  struct FontContents *fc;
  short weight, tweight, windex, i;
  struct DiskFontHeader *dfh;
  BPTR dfs;
d114 38
a151 34
  ta = *textAttr;
  ta.ta_Name = TailPath(textAttr->ta_Name);
  if ((result = bestRamFont = OpenFont(&ta)) != 0) {
    rfc.fc_YSize = bestRamFont->tf_YSize;
    rfc.fc_Style = bestRamFont->tf_Style;
    rfc.fc_Flags = bestRamFont->tf_Flags;
  }
  /* change directory to the font directory */
  fontDir = Lock("FONTS:", SHARED_LOCK);
  if (fontDir == 0) return(result);
  prevCurrDir = CurrentDir(fontDir);

  /* try to open the font contents file associated with the font */
  if (fcLock = Lock(textAttr->ta_Name, SHARED_LOCK)) {
    if (fcFile = Open(textAttr->ta_Name, MODE_OLDFILE)) {
      /* read and verify the font contents header */
      if ((Read(fcFile, &fch, sizeof(fch)) == sizeof(fch)) &&
          (fch.fch_FileID = FCH_ID)) {
        fcSize = fch.fch_NumEntries*sizeof(*fc);
        /* read the font contents into a buffer */
        if (fc = (struct FontContentsEntry *) AllocMem(fcSize, 0)) {
          if (fcSize == Read(fcFile, fc, fcSize)) {
            /* search through the font list for the best match */
            do {
              if (bestRamFont)
                weight = matchWeight(&ta, &rfc);
              else
                weight = 0;
              windex = -1;
              for (i = 0; i < fch.fch_NumEntries; i++) {
                tweight = matchWeight(&ta, &fc[i]);
                if (tweight > weight) {
                  weight = tweight;
                  windex = i;
d153 9
a161 9
              }
              if (windex >= 0) {
		CurrentDir(ParentDir(fcLock));
                if ((dfh = (struct DiskFontHeader *) (( ((ULONG)
                    (dfs = (BPTR) LoadSeg(fc[windex].fc_FileName))) <<2) + 8)
                    ) != (struct DiskFontHeader *) 8) {
                  if (dfh->dfh_FileID == DFH_ID) {
                    dfh->dfh_Segment = dfs;
                    strcpy(dfh->dfh_Name, ta.ta_Name);
d163 2
a164 2
                    /* fix a bug in some font editors: */
                    dfh->dfh_TF.tf_Message.mn_Node.ln_Name = dfh->dfh_Name;
d166 15
a180 9
                    dfh->dfh_TF.tf_Flags |= FPF_DISKFONT;
                    Forbid();
                    AddFont(&dfh->dfh_TF);
                    (dfh->dfh_TF.tf_Accessors)++;
                    AddTail(&DFL->dfl_DiskFonts, dfh);
                    (DFL->dfl_NumLFonts)++;
                    Permit();
                    windex = -1;
                    result = &dfh->dfh_TF;
d182 1
a182 2
                  else {
                    UnLoadSeg(dfs);
d184 2
a185 1
                  }
a186 2
                else
                  fc[windex].fc_YSize = 0;
d188 1
d190 1
a190 1
              while(windex >= 0);
a191 1
          FreeMem(fc, fcSize);
d193 1
d195 1
a195 1
      Close(fcFile);
d197 39
a235 7
    UnLock(fcLock);
  }
  CurrentDir(prevCurrDir);
  UnLock(fontDir);
  if ((bestRamFont) && (result != bestRamFont))
    CloseFont(bestRamFont);
  return(result);
@


35.0
log
@initial for V35
@
text
@d1 6
a6 6
#include	"exec/types.h"
#include	"exec/nodes.h"
#include	"exec/lists.h"
#include	"exec/ports.h"
#include	"libraries/dos.h"
#include	"graphics/text.h"
d8 2
a9 2
#include	"diskfont.h"
#include	"dfdata.h"
d27 1
a27 1
*	disk, loads it into memory, and returns a pointer to the font
d29 2
a30 2
*	It is important to match this call with a corresponding
*	CloseFont call for effective management of font memory.
d32 2
a33 2
*	If the font is already in memory, the copy in memory is used.
*	The disk copy is not reloaded.
d39 1
a39 1
*   EXCEPTIONS
d42 5
d48 1
a48 1
/*		          underlined bold italic */
d60 3
a62 3
    short sDiff, fDiff;
    short mask, i;
    int result;
d64 24
a87 26
    if (fc->fc_YSize) {
	/* start out with the largest weight */
	result = 32767;
	if ((sDiff = fc->fc_YSize - ta->ta_YSize) < 0)
	    /* -64 for every pixel that the font is smaller than desired */
	    result += sDiff * 64;
	else
	    /* -256 for every pixel that the font is larger than desired */
	    result -= sDiff * 256;
	sDiff = fc->fc_Style ^ ta->ta_Style;
	fDiff = fc->fc_Flags ^ ta->ta_Flags;
	mask = 1;
	for (i = 0; i < 7; i++) {
	    if (sDiff & mask)
		if (fc->fc_Style & mask)
		    result -= sfWeight[i];
		else
		    result -= stWeight[i];
	    if (fDiff & mask)
		if (fc->fc_Flags & mask)
		    result -= ffWeight[i];
		else
		    result -= ftWeight[i];
	    mask += mask;
	}
	return(result);
d89 4
a92 2
    else
	return(-32767);
d100 10
a109 10
    struct TextAttr ta;
    struct FontContents rfc;
    struct TextFont *bestRamFont, *result;
    LONG fontDir, prevCurrDir;
    LONG fcLock, fcFile, fcSize;
    struct FontContentsHeader fch;
    struct FontContents *fc;
    short weight, tweight, windex, i;
    struct DiskFontHeader *dfh;
    BPTR dfs;
d111 11
a121 11
    ta = *textAttr;
    ta.ta_Name = TailPath(textAttr->ta_Name);
    if ((result = bestRamFont = OpenFont(&ta)) != 0) {
	rfc.fc_YSize = bestRamFont->tf_YSize;
	rfc.fc_Style = bestRamFont->tf_Style;
	rfc.fc_Flags = bestRamFont->tf_Flags;
    }
    /* change directory to the font directory */
    fontDir = Lock("FONTS:", SHARED_LOCK);
    if (fontDir == 0) return(result);
    prevCurrDir = CurrentDir(fontDir);
d123 61
a183 64
    /* try to open the font contents file associated with the font */
    if (fcLock = Lock(textAttr->ta_Name, SHARED_LOCK)) {
	if (fcFile = Open(textAttr->ta_Name, MODE_OLDFILE)) {
	    /* read and verify the font contents header */
	    if ((Read(fcFile, &fch, sizeof(fch)) == sizeof(fch)) &&
		    (fch.fch_FileID = FCH_ID)) {
		fcSize = fch.fch_NumEntries*sizeof(*fc);
		/* read the font contents into a buffer */
		if (fc = (struct FontContentsEntry *) AllocMem(fcSize, 0)) {
		    if (fcSize == Read(fcFile, fc, fcSize)) {
			/* search through the font list for the best match */
			do {
			    if (bestRamFont)
				weight = matchWeight(&ta, &rfc);
			    else
				weight = 0;
			    windex = -1;
			    for (i = 0; i < fch.fch_NumEntries; i++) {
				tweight = matchWeight(&ta, &fc[i]);
				if (tweight > weight) {
				    weight = tweight;
				    windex = i;
				}
			    }
			    if (windex >= 0) {
				if ((dfh = (struct DiskFontHeader *)
					  ((
					    ((ULONG)
					      (dfs = (BPTR)
						LoadSeg(fc[windex].fc_FileName)
					      )
					    )
					  <<2) + 8)
					) != (struct DiskFontHeader *) 8) {
				    if (dfh->dfh_FileID == DFH_ID) {
					dfh->dfh_Segment = dfs;
					strcpy(dfh->dfh_Name, ta.ta_Name);
					dfh->dfh_TF.tf_Flags |= FPF_DISKFONT;
					Forbid();
					AddFont(&dfh->dfh_TF);
					(dfh->dfh_TF.tf_Accessors)++;
					AddTail(&DFL->dfl_DiskFonts, dfh);
					(DFL->dfl_NumLFonts)++;
					Permit();
					windex = -1;
					result = &dfh->dfh_TF;
				    }
				    else {
					UnLoadSeg(dfs);
					fc[windex].fc_YSize = 0;
				    }
				}
				else
				    fc[windex].fc_YSize = 0;
			    }
			}
			    while(windex >= 0);
		    }
		    FreeMem(fc, fcSize);
		}
	    }
	    Close(fcFile);
	}
	UnLock(fcLock);
d185 7
a191 5
    CurrentDir(prevCurrDir);
    UnLock(fontDir);
    if ((bestRamFont) && (result != bestRamFont))
	CloseFont(bestRamFont);
    return(result);
@
