head     38.35;
branch   ;
access   ;
symbols  ;
locks    davidj:38.35; strict;
comment  @ * @;


38.35
date     93.04.27.12.36.12;  author vertex;  state Exp;
branches ;
next     38.34;

38.34
date     93.04.06.14.14.40;  author vertex;  state Exp;
branches ;
next     38.33;

38.33
date     93.03.25.18.31.18;  author vertex;  state Exp;
branches ;
next     38.32;

38.32
date     93.01.20.11.44.47;  author vertex;  state Exp;
branches ;
next     38.31;

38.31
date     93.01.05.09.52.50;  author vertex;  state Exp;
branches ;
next     38.30;

38.30
date     92.12.04.10.21.26;  author vertex;  state Exp;
branches ;
next     38.29;

38.29
date     92.08.18.17.34.17;  author vertex;  state Exp;
branches ;
next     38.28;

38.28
date     92.07.31.17.27.03;  author vertex;  state Exp;
branches ;
next     38.27;

38.27
date     92.07.20.16.24.31;  author vertex;  state Exp;
branches ;
next     38.26;

38.26
date     92.07.02.15.37.12;  author vertex;  state Exp;
branches ;
next     38.25;

38.25
date     92.06.20.16.23.56;  author vertex;  state Exp;
branches ;
next     38.24;

38.24
date     92.06.08.18.45.48;  author vertex;  state Exp;
branches ;
next     38.23;

38.23
date     92.05.30.12.23.39;  author vertex;  state Exp;
branches ;
next     38.22;

38.22
date     92.05.08.12.05.49;  author vertex;  state Exp;
branches ;
next     38.21;

38.21
date     92.04.23.15.44.35;  author vertex;  state Exp;
branches ;
next     38.20;

38.20
date     92.04.07.09.49.17;  author vertex;  state Exp;
branches ;
next     38.19;

38.19
date     92.03.30.11.04.30;  author vertex;  state Exp;
branches ;
next     38.18;

38.18
date     92.03.27.14.16.23;  author vertex;  state Exp;
branches ;
next     38.17;

38.17
date     92.03.26.16.11.31;  author vertex;  state Exp;
branches ;
next     38.16;

38.16
date     92.03.25.10.24.21;  author vertex;  state Exp;
branches ;
next     38.15;

38.15
date     92.03.23.18.13.05;  author vertex;  state Exp;
branches ;
next     38.14;

38.14
date     92.03.19.09.54.20;  author vertex;  state Exp;
branches ;
next     38.13;

38.13
date     92.03.12.14.58.57;  author vertex;  state Exp;
branches ;
next     38.12;

38.12
date     92.03.03.13.33.05;  author vertex;  state Exp;
branches ;
next     38.11;

38.11
date     92.03.02.12.50.03;  author vertex;  state Exp;
branches ;
next     38.10;

38.10
date     92.02.21.09.08.07;  author davidj;  state Exp;
branches ;
next     38.9;

38.9
date     92.02.17.17.18.10;  author davidj;  state Exp;
branches ;
next     38.8;

38.8
date     92.02.17.15.24.41;  author davidj;  state Exp;
branches ;
next     38.7;

38.7
date     92.02.14.16.35.00;  author davidj;  state Exp;
branches ;
next     38.6;

38.6
date     92.02.12.16.32.01;  author davidj;  state Exp;
branches ;
next     38.5;

38.5
date     92.02.04.16.28.50;  author vertex;  state Exp;
branches ;
next     38.4;

38.4
date     92.01.17.13.07.05;  author vertex;  state Exp;
branches ;
next     38.3;

38.3
date     92.01.16.15.33.11;  author vertex;  state Exp;
branches ;
next     38.2;

38.2
date     92.01.15.17.10.36;  author vertex;  state Exp;
branches ;
next     38.1;

38.1
date     92.01.10.15.43.17;  author vertex;  state Exp;
branches ;
next     ;


desc
@ASL file requester
@


38.35
log
@Fixed array size spec, causing Enforcer hits
@
text
@
/* includes */
#include <exec/types.h>
#include <exec/memory.h>
#include <intuition/intuition.h>
#include <intuition/gadgetclass.h>
#include <intuition/sghooks.h>
#include <libraries/gadtools.h>
#include <dos/dos.h>
#include <dos/datetime.h>
#include <utility/tagitem.h>
#include <graphics/regions.h>
#include <graphics/gfx.h>
#include <graphics/gfxbase.h>
#include <graphics/gfxmacros.h>
#include <graphics/rpattr.h>
#include <devices/inputevent.h>
#include <utility/hooks.h>
#include <workbench/startup.h>
#include <workbench/workbench.h>
#include <string.h>
#include <math.h>

#include <clib/exec_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/dos_protos.h>
#include <clib/intuition_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <clib/locale_protos.h>
#include <clib/icon_protos.h>
#include <clib/wb_protos.h>
#include <clib/layers_protos.h>

#include <pragmas/exec_pragmas.h>
#include <pragmas/gadtools_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/utility_pragmas.h>
#include <pragmas/locale_pragmas.h>
#include <pragmas/icon_pragmas.h>
#include <pragmas/wb_pragmas.h>
#include <pragmas/layers_pragmas.h>

#include "asl.h"
#include "aslbase.h"
#include "aslutils.h"
#include "filereq.h"
#include "asllists.h"
#include "layout.h"
#include "requtils.h"


/*****************************************************************************/


#define LocaleBase ri->ri_LocaleInfo.li_LocaleBase
#define catalog    ri->ri_LocaleInfo.li_Catalog


/*****************************************************************************/


/* stored in ln_Type field */
#define FILETYPE   1
#define DIRTYPE    2
#define VOLUMETYPE 3
#define ASSIGNTYPE 4

#define ln_Selected ln_Pri


struct FileEntry
{
    struct Node      fe_Link;
    UWORD            fe_Pad;
    struct DateStamp fe_Date;
    LONG             fe_Size;
};

struct DirEntry
{
    struct Node      de_Link;
    UWORD	     de_Pad;
    struct DateStamp de_Date;
};

struct AssignEntry
{
    struct Node ae_Link;
};

struct VolumeEntry
{
    struct Node     ve_Link;
    UWORD           ve_Pad;
    STRPTR          ve_DeviceName;
    ULONG           ve_BlocksUsed;
    ULONG           ve_NumBlocks;
    ULONG           ve_BytesPerBlock;
    struct MsgPort *ve_HandlerTask;
};


/*****************************************************************************/


#define SHIFTKEYS (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT)
#define ALTKEYS   (IEQUALIFIER_LALT | IEQUALIFIER_RALT)


/*****************************************************************************/


#define FR_NOP        0
#define FR_OK         1
#define FR_CANCEL     2
#define FR_PREVNAME   3
#define FR_NEXTNAME   4
#define FR_PARENT     5
#define FR_VOLUMES    6
#define FR_DELETE     7
#define FR_PATTERN    8
#define FR_DRAWER     9
#define FR_FILE       10
#define FR_LISTSCROLL 11
#define FR_LISTCLICK  12
#define FR_RESTORE    13


/*****************************************************************************/


static struct ASLMenu far AM[] =
{
    {NM_TITLE,  FR_NOP,      MSG_ASL_CONTROL_MENU},
      {NM_ITEM, FR_PREVNAME, MSG_ASL_CONTROL_LASTNAME},
      {NM_ITEM, FR_NEXTNAME, MSG_ASL_CONTROL_NEXTNAME},
      {NM_ITEM, FR_NOP,      MSG_BARLABEL},
      {NM_ITEM, FR_RESTORE,  MSG_ASL_CONTROL_RESTORE},
      {NM_ITEM, FR_PARENT,   MSG_ASL_CONTROL_PARENT},
      {NM_ITEM, FR_VOLUMES,  MSG_ASL_CONTROL_VOLUMES},
      {NM_ITEM, FR_DELETE,   MSG_ASL_CONTROL_DELETE},
      {NM_ITEM, FR_NOP,      MSG_BARLABEL},
      {NM_ITEM, FR_OK,       MSG_ASL_CONTROL_OK},
      {NM_ITEM, FR_CANCEL,   MSG_ASL_CONTROL_CANCEL},

    {NM_END,    FR_NOP,	     MSG_BARLABEL}
};


/*****************************************************************************/


/* Template for the file requester */
static struct ASLGadget far AG[] =
{
    {HGROUP_KIND,   FR_NOP,        0, MSG_NOTHING,            {  4,-16,  -8, 14}, 1, 0, 0,},
    {BUTTON_KIND,   FR_OK,         0, MSG_ASL_OK_GAD,         {  4,-16,   0,  0}, 1, 0, 0,},
    {BUTTON_KIND,   FR_VOLUMES,    0, MSG_ASL_FR_VOLUMES_GAD, { 78,-16,   0,  0}, 1, 0, 1,},
    {BUTTON_KIND,   FR_PARENT,     0, MSG_ASL_FR_PARENT_GAD,  {152,-16,   0,  0}, 1, 0, 2,},
    {BUTTON_KIND,   FR_CANCEL,     0, MSG_ASL_CANCEL_GAD,     {-74,-16,   0,  0}, 1, 0, 0,},

    {VGROUP_KIND,   FR_NOP,        0, MSG_NOTHING,            {  4,-64,  -8, 46}, 2, 0, 0,},
    {STRING_KIND,   FR_PATTERN,    0, MSG_ASL_FR_PATTERN_GAD, {  0,  0,  -1,  0}, 2, 0, 1,},
    {STRING_KIND,   FR_DRAWER,     0, MSG_ASL_FR_DRAWER_GAD,  {  0,  0,  -1,  0}, 2, 0, 0,},
    {STRING_KIND,   FR_FILE,       0, MSG_ASL_FR_FILE_GAD,    {  0,  0,  -1,  0}, 2, 0, 0,},

    {DGROUP_KIND,   FR_NOP,        0, MSG_NOTHING,            {  4,  2,  -8,-68}, 3, 0, 2,},
    {SCROLLER_KIND, FR_LISTSCROLL, 0, MSG_NOTHING,            {-18,  0,  18,  0}, 3, 0, 0,},
    {GENERIC_KIND,  FR_LISTCLICK,  0, MSG_NOTHING,            {  0,  0, -18,  0}, 3, 0, 0,},

    {END_KIND,}
};

#define	POSGAD		1
#define	VOLUMEGAD	2
#define	PARENTGAD	3
#define	NEGGAD		4

#define	PATTERNGAD	6
#define	DRAWERGAD	7
#define	FILEGAD		8

#define	SCROLLERGAD	10
#define	LISTGAD		11

#define MINLIGHTHEIGHT 3


/*****************************************************************************/


static VOID InitFileList(struct ExtFileReq *fr)
{
struct Node *node;

    while (node = RemHead((struct List *)&fr->fr_FileList))
    {
        if (node->ln_Type == VOLUMETYPE)
            FreeVec(((struct VolumeEntry *)node)->ve_DeviceName);

        FreeVec(node);
    }

    FreeList((struct List *)&fr->fr_TempFileList);

    fr->fr_MaxNameLen   = 10;
    fr->fr_MaxSizeLen   = strlen(GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_DRAWER));
    fr->fr_TopItem      = 0;
    fr->fr_OldTopItem   = 0;
    fr->fr_OldItemCnt   = 0;
    fr->fr_DisplayValid = FALSE;
    fr->fr_ItemCnt      = 0;
    fr->fr_TempItemCnt  = 0;
    fr->fr_FullRender   = TRUE;
}


/*****************************************************************************/


static VOID InsertListEntry(struct ExtFileReq *fr, struct Node *newEntry)
{
UWORD               nameLen;
struct FileEntry   *file;
struct VolumeEntry *volume;
STRPTR              name;

    fr->fr_ItemCnt++;
    fr->fr_DisplayValid = FALSE;

    nameLen = strlen(newEntry->ln_Name);
    if (nameLen > fr->fr_MaxNameLen)
        fr->fr_MaxNameLen = nameLen;

    if (newEntry->ln_Type == FILETYPE)
    {
        file = (struct FileEntry *)newEntry;
        if (file->fe_Size >= 1000000)
        {
            fr->fr_MaxSizeLen = 11;
        }
        else if (file->fe_Size >= 1000)
        {
            if (fr->fr_MaxSizeLen < 7)
            {
                fr->fr_MaxSizeLen = 7;
            }
        }
    }
    else if (newEntry->ln_Type == VOLUMETYPE)
    {
        volume = (struct VolumeEntry *)newEntry;
        if (name = volume->ve_DeviceName)
        {
            nameLen = strlen(name);
            if (nameLen > fr->fr_MaxSizeLen)
                fr->fr_MaxSizeLen = nameLen;
        }
    }

    EnqueueAlpha2((struct List *)&fr->fr_FileList,newEntry);
}


/*****************************************************************************/


static VOID RemoveListEntry(struct ExtFileReq *fr, STRPTR name)
{
struct Node *node;

    if (node = FindNameNC(&fr->fr_FileList,FilePart(name)))
    {
        Remove(node);
        fr->fr_ItemCnt--;
        fr->fr_DisplayValid = FALSE;
        FreeVec(node);
    }
}


/*****************************************************************************/


#define FORMAT_DEF 4

static VOID ConvDate(struct DateStamp *ds, STRPTR string)
{
struct DateTime dt;
char            date[LEN_DATSTRING];
char            time[LEN_DATSTRING];

    dt.dat_Stamp   = *ds;
    dt.dat_Format  = FORMAT_DEF;
    dt.dat_Flags   = NULL;
    dt.dat_StrDay  = NULL;
    dt.dat_StrDate = date;
    dt.dat_StrTime = time;

    string[0] = 0;
    if (DateToStr(&dt))
    {
        strcpy(string, date);
        strcat(string, " ");
        strcat(string, time);
    }
}


/*****************************************************************************/


#define ROLLOVER_POINT 9999

static VOID ConvVolumeData(struct ExtFileReq *fr, ULONG blocksUsed, ULONG numBlocks,
                           ULONG bytesPerBlock, STRPTR string)
{
ULONG used, free, percent, total;
char  freechar, usedchar;

    string[0] = 0;

    total   = numBlocks;
    used    = blocksUsed;
    percent = (((used * 100) + (total>>1)) / total);
    total  *= bytesPerBlock;
    used   *= bytesPerBlock;
    free    = total - used;

    freechar=usedchar='K';

    if ((free >>= 10) > ROLLOVER_POINT)
    {
        freechar='M';
        free >>= 10;
    }

    if ((used >>= 10) > ROLLOVER_POINT)
    {
        usedchar='M';
        used >>= 10;
    }

    sprintf(string,GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_VOLUME_INFO),percent,free,freechar,used,usedchar);
}


/*****************************************************************************/


static VOID RenderEntry(struct ExtFileReq *fr, struct Node *entry, struct Rectangle *rect)
{
struct RastPort    *rp;
struct FileEntry   *file;
struct DirEntry    *dir;
struct VolumeEntry *volume;
char                line[120];
char                date[120];
char                volSize[80];
UWORD               frontPen, backPen;
STRPTR              ptr;
STRPTR              name;
struct TextExtent   extent;
WORD                x0,x1;
WORD                y;
UWORD               sizeLen;
STRPTR              drawer;

    if (FRF_DOSAVEMODE & fr->fr_Options)
    {
        frontPen = fr->fr_LVBackPen;
        backPen  = fr->fr_LVTextPen;

        if ((entry->ln_Type == DIRTYPE) || (entry->ln_Type == ASSIGNTYPE))
            if (fr->fr_LVHighTextPen != backPen)
                frontPen = fr->fr_LVHighTextPen;

        if (entry->ln_Selected)
        {
            frontPen = fr->fr_LVTextPen;
            backPen  = fr->fr_LVBackPen;
        }
    }
    else
    {
        frontPen = fr->fr_LVTextPen;
        backPen  = fr->fr_LVBackPen;

        if ((entry->ln_Type == DIRTYPE) || (entry->ln_Type == ASSIGNTYPE))
            frontPen = fr->fr_LVHighTextPen;

        if (entry->ln_Selected)
        {
            frontPen = fr->fr_LVFillTextPen;
            backPen  = fr->fr_LVFillBackPen;
        }
    }

    sizeLen = 0;
    name    = entry->ln_Name;
    switch (entry->ln_Type)
    {
        case FILETYPE  : file = (struct FileEntry *)entry;
                         ConvDate(&file->fe_Date,date);
                         sprintf(line,"%lU",file->fe_Size);
                         sizeLen = strlen(line);
                         strcat(line,"  ");
                         strcat(line,date);
                         break;

        case DIRTYPE   : dir = (struct DirEntry *)entry;
                         ConvDate(&dir->de_Date,date);
                         drawer  = GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_DRAWER);
                         sizeLen = strlen(drawer);
                         sprintf(line,"%s  %s",drawer,date);
                         break;

        case ASSIGNTYPE: strcpy(line,GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_ASSIGN));
                         sizeLen = strlen(line);
                         strcpy(date,name);
                         strcat(date,":");
                         name = date;    /* use 'date' as our name buffer */
                         break;

        case VOLUMETYPE: volume = (struct VolumeEntry *)entry;

                         if (!(ptr = volume->ve_DeviceName))
                             ptr = GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_VOLUME);

                         sizeLen = strlen(ptr);
                         if (volume->ve_HandlerTask)
                             ConvVolumeData(fr,volume->ve_BlocksUsed,volume->ve_NumBlocks,volume->ve_BytesPerBlock,volSize);
                         else
                             volSize[0] = 0;
                         sprintf(line,"%s  %s",ptr,volSize);
                         break;
    }

    rp = &fr->fr_Store->rs_LVRPort;

    SetABPenDrMd(rp,frontPen,backPen,JAM2);

    y = rect->MinY+(((rect->MaxY - rect->MinY + 1) - rp->TxHeight) / 2) + rp->TxBaseline + 1;

    Move(rp,rect->MinX+2,y);
    Text(rp,name,TextFit(rp,name,strlen(name),&extent,NULL,1,rect->MaxX-rect->MinX-3,32767));
    x0 = rp->cp_x;

    x1 = rect->MinX+2+(fr->fr_MaxNameLen+2+fr->fr_MaxSizeLen-sizeLen)*rp->TxWidth;
    if (x1 < rect->MaxX)
    {
       Move(rp,x1,y);
       Text(rp,line,TextFit(rp,line,strlen(line),&extent,NULL,1,rect->MaxX-x1,32767));
    }

    SetAPen(rp,backPen);
    RectFill(rp,rect->MinX,rect->MinY+1,rect->MinX+1,rect->MaxY);
    RectFill(rp,rect->MinX,rect->MinY,rect->MaxX,rect->MinY);

    if ((x0 < x1-1) && (x1 < rect->MaxX-1))
        RectFill(rp,x0,rect->MinY,x1-1,rect->MaxY);

    if (rp->cp_x <= rect->MaxX)
        RectFill(rp,rp->cp_x,rect->MinY+1,rect->MaxX,rect->MaxY);
}


/*****************************************************************************/


static VOID CreateVolumeList(struct ExtFileReq *fr)
{
struct DosList     *dl;
struct VolumeEntry *volume;
struct AssignEntry *assign;
struct MinList      hold;
STRPTR              name;
UWORD               len;
D_S(struct InfoData,id);

    fr->fr_MaxNameLen = 1;
    fr->fr_MaxSizeLen = strlen(GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_VOLUME));
    len = strlen(GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_ASSIGN));
    if (len > fr->fr_MaxSizeLen)
        fr->fr_MaxSizeLen = len;

    NewList((struct List *)&hold);

    dl = LockDosList(LDF_VOLUMES|LDF_ASSIGNS|LDF_READ);
    while (dl = NextDosEntry(dl,LDF_VOLUMES|LDF_ASSIGNS|LDF_READ))
    {
        name = (STRPTR)((ULONG)dl->dol_Name * 4);
        if (dl->dol_Type == DLT_VOLUME)
        {
            if (!dl->dol_Task || DoPkt1(dl->dol_Task,ACTION_DISK_INFO,(ULONG)id >> 2))
            {
                if (volume = AllocNamedNode2(sizeof(struct VolumeEntry),VOLUMETYPE,&name[1]))
                {
                    volume->ve_Link.ln_Type  = VOLUMETYPE;
                    volume->ve_NumBlocks     = id->id_NumBlocks;
                    volume->ve_BytesPerBlock = id->id_BytesPerBlock;
                    volume->ve_BlocksUsed    = id->id_NumBlocksUsed;
                    volume->ve_HandlerTask   = dl->dol_Task;
                    AddTail((struct List *)&hold,(struct Node *)volume);
                }
            }
        }
        else if ((dl->dol_Type == DLT_DIRECTORY)
             ||  (dl->dol_Type == DLT_LATE)
             ||  (dl->dol_Type == DLT_NONBINDING))
        {
            if (assign = AllocNode(sizeof(struct AssignEntry) + (ULONG)name[0] + 2))
            {
                assign->ae_Link.ln_Name     = (STRPTR)((ULONG)assign + sizeof(struct AssignEntry) + 1);
                assign->ae_Link.ln_Type     = ASSIGNTYPE;
                assign->ae_Link.ln_Name[-1] = ASSIGNTYPE;
                CopyMem(&name[1],assign->ae_Link.ln_Name,(ULONG)name[0]);
                InsertListEntry(fr,(struct Node *)assign);
            }
        }
    }

    dl = LockDosList(LDF_DEVICES|LDF_READ);
    while (dl = NextDosEntry(dl,LDF_DEVICES|LDF_READ))
    {
        volume = (struct VolumeEntry *)hold.mlh_Head;
        while (volume->ve_Link.ln_Succ)
        {
            if (volume->ve_HandlerTask && (volume->ve_HandlerTask == dl->dol_Task))
            {
                name = (STRPTR)((ULONG)dl->dol_Name * 4);
                if (volume->ve_DeviceName = AllocVec((ULONG)name[0]+3,MEMF_CLEAR|MEMF_ANY))
                {
                    CopyMem(name,volume->ve_DeviceName,(ULONG)name[0]+1);
                    strcat(volume->ve_DeviceName,")");
                    volume->ve_DeviceName[0] = '(';
                }
                break;
            }
            volume = (struct VolumeEntry *)volume->ve_Link.ln_Succ;
        }
    }

    UnLockDosList(LDF_DEVICES|LDF_READ);
    UnLockDosList(LDF_VOLUMES|LDF_ASSIGNS|LDF_READ);

    while (volume = (struct VolumeEntry *)RemHead((struct List *)&hold))
        InsertListEntry(fr,(struct Node *)volume);
}


/*****************************************************************************/


static VOID ReducePath(STRPTR path)
{
UWORD diff,len,i,j,start;

    len = strlen(path);

    i = len;
    while (len > 1)
    {
        if ((path[len-1] == '/') && (path[len-2] != '/') && (path[len-2] != ':'))
            path[--len] = 0;

        i--;
        if ((i == 0) || (path[i] == ':') || (path[i-1] == ':'))
            return;

        if ((i > 1) && (path[i] == '/') && (path[i-1] == '/') && (path[i-2] != ':') && (path[i-2] != '/'))
        {
            start = i;
            i -= 2;
            while ((i > 0) && (path[i] != ':') && (path[i] != '/'))
                i--;

            if ((path[i] == ':') || (path[i] == '/'))
                i++;

            j    = i;
            diff = start-i+1;
            len  -= diff;
            while (j < len)
            {
                path[j] = path[j+diff];
                j++;
            }
            path[len] = 0;
            i = len;
        }
    }
}


/*****************************************************************************/


ULONG GetMaxPen(struct RastPort *rp)
{
struct TagItem tags[2];
ULONG          result;

    tags[0].ti_Tag  = RPTAG_MaxPen;
    tags[0].ti_Data = (ULONG)&result;
    tags[1].ti_Tag  = TAG_DONE;

    GetRPAttrsA(rp,tags);

    return(result);   /* the compiler says this is not initialized, it's wrong! */
}


/*****************************************************************************/


static VOID RenderLV(struct ExtFileReq *fr)
{
UWORD             yPos;
UWORD             i,start,end;
LONG              scrCnt,dy;
struct Node      *node;
struct Rectangle  rect;
ULONG             oldMaxPen;

    start = 0;

    if (!fr->fr_DisplayValid)
    {
        end = fr->fr_VisibleItems;
    }
    else if (fr->fr_TopItem != fr->fr_OldTopItem)
    {
        scrCnt = fr->fr_TopItem - fr->fr_OldTopItem;

        if (abs(scrCnt)+1 < fr->fr_VisibleItems)
        {
            dy = scrCnt * fr->fr_ItemHeight;

            if (dy<0)
            {
                end = -scrCnt;
            }
            else
            {
                start = fr->fr_VisibleItems-scrCnt;
                end   = fr->fr_VisibleItems;
            }

            oldMaxPen = GetMaxPen(fr->fr_ReqInfo.ri_Window->RPort);
            SetMaxPen(fr->fr_ReqInfo.ri_Window->RPort,GetMaxPen(&fr->fr_Store->rs_LVRPort));

            LockLayerInfo(&fr->fr_ReqInfo.ri_Window->WScreen->LayerInfo);
            InstallLayerHook(fr->fr_ReqInfo.ri_Window->WLayer,LAYERS_NOBACKFILL);
            ScrollWindowRaster(fr->fr_ReqInfo.ri_Window,0,dy,
                               fr->fr_LVLeft,fr->fr_LVTop,
                               fr->fr_LVLeft+fr->fr_LVWidth-1,
                               fr->fr_LVTop+fr->fr_ItemHeight*fr->fr_VisibleItems-1);
            InstallLayerHook(fr->fr_ReqInfo.ri_Window->WLayer,LAYERS_BACKFILL);
            UnlockLayerInfo(&fr->fr_ReqInfo.ri_Window->WScreen->LayerInfo);

            SetMaxPen(fr->fr_ReqInfo.ri_Window->RPort,oldMaxPen);
        }
        else
        {
            end = fr->fr_VisibleItems;
        }
    }
    else
    {
        return;
    }

    i    = start + fr->fr_TopItem;
    yPos = fr->fr_LVTop+start*fr->fr_ItemHeight;

    node = fr->fr_FileList.lh_Head;
    while (i-- && node->ln_Succ)
	node = node->ln_Succ;

    rect.MinX = fr->fr_LVLeft;
    rect.MaxX = fr->fr_LVLeft+fr->fr_LVWidth-1;
    while (start < end)
    {
        if (!node->ln_Succ)
            break;

        rect.MinY = yPos;
        rect.MaxY = yPos+fr->fr_ItemHeight-1;
        RenderEntry(fr,node,&rect);
        node = node->ln_Succ;

        yPos = yPos + fr->fr_ItemHeight;
        start++;
    }

    if (!fr->fr_DisplayValid && (start < fr->fr_VisibleItems) && (fr->fr_FullRender))
    {
        if (FRF_DOSAVEMODE & fr->fr_Options)
            SetAPen(&fr->fr_Store->rs_LVRPort,fr->fr_LVTextPen);
        else
            SetAPen(&fr->fr_Store->rs_LVRPort,fr->fr_LVBackPen);

        RectFill(&fr->fr_Store->rs_LVRPort,
                 fr->fr_LVLeft,yPos,
                 fr->fr_LVLeft+fr->fr_LVWidth-1,
                 fr->fr_LVTop+fr->fr_LVHeight-1);

        fr->fr_FullRender = FALSE;
    }

    fr->fr_OldTopItem   = fr->fr_TopItem;
    fr->fr_OldItemCnt   = fr->fr_ItemCnt;
    fr->fr_DisplayValid = TRUE;
}


/*****************************************************************************/


static VOID DoFRGadgets(struct ExtFileReq *fr)
{
struct ReqInfo *ri;

    ri = &fr->fr_ReqInfo;

    if (FRF_DOPATTERNS & fr->fr_Options)
    {
       SetGadgetAttr(ri,PATTERNGAD,GTST_MaxChars, sizeof(fr->fr_PatternString),
                                   GTST_String,   fr->fr_PatternString,
                                   TAG_DONE);
    }

    SetGadgetAttr(ri,DRAWERGAD,GTST_MaxChars, sizeof(fr->fr_DrawerString),
                               GTST_String,   fr->fr_DrawerString,
                               TAG_DONE);

    if (!(FRF_DRAWERSONLY & fr->fr_Options2))
    {
        SetGadgetAttr(ri,FILEGAD,GTST_EditHook, &fr->fr_FileHook,
                                 GTST_MaxChars, sizeof(fr->fr_FileString),
                                 GTST_String,   fr->fr_FileString,
                                 TAG_DONE);
    }

    SetGadgetAttr(ri,SCROLLERGAD,GTSC_Visible, fr->fr_VisibleItems,
                                 GTSC_Total,   fr->fr_ItemCnt,
                                 GTSC_Top,     fr->fr_TopItem,
                                 GTSC_Arrows,  9,
                                 PGA_Freedom,  LORIENT_VERT,
                                 GA_Immediate, TRUE,
                                 GA_RelVerify, TRUE,
                                 TAG_DONE);
}


/*****************************************************************************/


static VOID LimitTopItem(struct ExtFileReq *fr)
{
    if (fr->fr_TopItem + fr->fr_VisibleItems > fr->fr_ItemCnt)
    {
        if (fr->fr_ItemCnt > fr->fr_VisibleItems)
        {
            fr->fr_TopItem = fr->fr_ItemCnt - fr->fr_VisibleItems;
        }
        else
        {
            fr->fr_TopItem = 0;
        }
    }
}


/*****************************************************************************/


static WORD GetMax(struct ExtFileReq *fr, LONG pen, ...)
{
struct DrawInfo *di;
WORD             maxPen;
LONG            *ptr;

    di     = fr->fr_ReqInfo.ri_DrawInfo;
    maxPen = 0;
    ptr    = &pen;
    while (*ptr != -1)
    {
        if (di->dri_Pens[*ptr] > maxPen)
            maxPen = di->dri_Pens[*ptr];

        ptr++;
    }

    return(maxPen);
}


/*****************************************************************************/


static BOOL CreateFRGadgets(struct ExtFileReq *fr)
{
struct ReqInfo  *ri = &fr->fr_ReqInfo;
struct TextFont *defFont;
struct Gadget   *gad;
struct DrawInfo *di;

    FreeLayoutGadgets(ri,TRUE);

    DoFRGadgets(fr);

    if (LayoutGadgets(ri,LGM_CREATE))
    {
	gad              = ri->ri_Template[LISTGAD].ag_Gadget;
        gad->Flags       = GFLG_GADGHNONE;
        gad->Activation  = GACT_IMMEDIATE;
        gad->GadgetType |= GTYP_BOOLGADGET;
        gad->GadgetID    = FR_LISTCLICK;

        AddGList(ri->ri_Window,ri->ri_Gadgets,-1,-1,NULL);
        RefreshGList(ri->ri_Gadgets,ri->ri_Window,NULL,-1);
        GT_RefreshWindow(ri->ri_Window,NULL);

        di      = ri->ri_DrawInfo;
        defFont = fr->fr_ReqInfo.ri_Window->RPort->Font;
        if (defFont->tf_Flags & FPF_PROPORTIONAL)
            defFont = GfxBase->DefaultFont;

        fr->fr_LVTextPen     = di->dri_Pens[TEXTPEN];
        fr->fr_LVBackPen     = di->dri_Pens[BACKGROUNDPEN];
        fr->fr_LVHighTextPen = di->dri_Pens[HIGHLIGHTTEXTPEN];
        fr->fr_LVFillTextPen = di->dri_Pens[FILLTEXTPEN];
        fr->fr_LVFillBackPen = di->dri_Pens[FILLPEN];

        fr->fr_Store->rs_LVRPort = *fr->fr_ReqInfo.ri_Window->RPort;
        fr->fr_LVLeft       = gad->LeftEdge+2;
        fr->fr_LVTop        = gad->TopEdge+1;
        fr->fr_LVWidth      = gad->Width-4;
        fr->fr_LVHeight     = gad->Height-2;
        fr->fr_ItemHeight   = defFont->tf_YSize+1;
        fr->fr_VisibleItems = fr->fr_LVHeight / fr->fr_ItemHeight;
        fr->fr_DisplayValid = FALSE;

        SetFont(&fr->fr_Store->rs_LVRPort,defFont);
        SetDrMd(&fr->fr_Store->rs_LVRPort,JAM2);

        SetMaxPen(&fr->fr_Store->rs_LVRPort,GetMax(fr,TEXTPEN,
                                                      BACKGROUNDPEN,
                                                      HIGHLIGHTTEXTPEN,
                                                      FILLTEXTPEN,
                                                      FILLPEN,
                                                      -1));

        LimitTopItem(fr);

        SetGadgetAttr(ri,SCROLLERGAD,GTSC_Visible, fr->fr_VisibleItems,
                                     GTSC_Top,     fr->fr_TopItem,
                                     TAG_DONE);


        fr->fr_MSpace = TextLength(ri->ri_Window->RPort,"m",1);

        return(TRUE);
    }

    return(FALSE);
}


/*****************************************************************************/


static VOID RenderFRDisplay(struct ExtFileReq *fr)
{
struct Gadget *gad;
struct Gadget *dgad;

    if (FRF_DOSAVEMODE & fr->fr_Options)
        SetAPen(&fr->fr_Store->rs_LVRPort,fr->fr_LVTextPen);
    else
        SetAPen(&fr->fr_Store->rs_LVRPort,fr->fr_LVBackPen);

    RectFill(&fr->fr_Store->rs_LVRPort,fr->fr_LVLeft,fr->fr_LVTop,
                                       fr->fr_LVLeft+fr->fr_LVWidth-1,
                                       fr->fr_LVTop+fr->fr_LVHeight-1);

    gad = fr->fr_ReqInfo.ri_Template[LISTGAD].ag_Gadget;
    AslDrawBevelBox(fr->fr_ReqInfo.ri_Window,
                    gad->LeftEdge-fr->fr_ReqInfo.ri_Window->BorderLeft,
                    gad->TopEdge-fr->fr_ReqInfo.ri_Window->BorderTop,
                    gad->Width,
                    gad->Height,
                    GT_VisualInfo, fr->fr_ReqInfo.ri_VisualInfo,
                    TAG_DONE);

    dgad = fr->fr_ReqInfo.ri_Template[DRAWERGAD].ag_Gadget;

    fr->fr_LightLeft   = gad->LeftEdge;
    fr->fr_LightTop    = dgad->TopEdge+1;
    fr->fr_LightWidth  = fr->fr_MSpace*2-1;
    fr->fr_LightHeight = (WORD)dgad->Height-4;

    if (fr->fr_LightHeight >= MINLIGHTHEIGHT)
    {
        AslDrawBevelBox(fr->fr_ReqInfo.ri_Window,fr->fr_LightLeft-fr->fr_ReqInfo.ri_Window->BorderLeft,
                                                 fr->fr_LightTop-fr->fr_ReqInfo.ri_Window->BorderTop,
                                                 fr->fr_LightWidth,fr->fr_LightHeight,
                                                 GT_VisualInfo, fr->fr_ReqInfo.ri_VisualInfo,
                                                 GTBB_Recessed, TRUE,
                                                 TAG_DONE);
    }
}


/*****************************************************************************/


static VOID SetStrValue(struct ExtFileReq *fr, WORD id, STRPTR text)
{
    SetGadgetAttr(&fr->fr_ReqInfo,id,GTST_String, text,
                                     TAG_DONE);
}


/*****************************************************************************/


static VOID ActivateGad(struct ExtFileReq *fr, UWORD currentGad, UWORD quals)
{
UWORD          next, prev;
struct Gadget *gad;

    if (quals & ALTKEYS)
        return;

    gad = NULL;
    while (!gad)
    {
        switch (currentGad)
        {
            case PATTERNGAD: next = DRAWERGAD;
                             prev = FILEGAD;
                             break;

            case DRAWERGAD : next = FILEGAD;
                             prev = PATTERNGAD;
                             break;

            case FILEGAD   : next = 0;
                             prev = DRAWERGAD;
                             break;
        }

        if (quals & SHIFTKEYS)
        {
            currentGad = prev;
        }
        else if (next != 0)
        {
            currentGad = next;
        }
        else
        {
            return;
        }
        gad = fr->fr_ReqInfo.ri_Template[currentGad].ag_Gadget;
    }

    ActivateGadget(gad,fr->fr_ReqInfo.ri_Window,NULL);
}


/*****************************************************************************/


LONG FixedParsePattern(STRPTR str, APTR buffer, ULONG bufSize)
{
LONG result;

    result = ParsePatternNoCase(str,buffer,bufSize);

    if (result < 0)
        ParsePatternNoCase("#?",buffer,bufSize);

    return(result);
}


/*****************************************************************************/


static VOID ParsePat(struct ExtFileReq *fr)
{
    FixedParsePattern(fr->fr_Pattern,fr->fr_Store->rs_ParsedPattern,sizeof(fr->fr_Store->rs_ParsedPattern));
}


/*****************************************************************************/


static VOID FRPreserve(struct ExtFileReq *fr)
{
    strcpy(fr->fr_Store->rs_OriginalFile,fr->fr_File);
    strcpy(fr->fr_Store->rs_OriginalDrawer,fr->fr_Drawer);
    strcpy(fr->fr_Store->rs_OriginalPattern,fr->fr_Pattern);
}


/*****************************************************************************/


static VOID FRRestore(struct ExtFileReq *fr)
{
    strcpy(fr->fr_File,fr->fr_Store->rs_OriginalFile);
    strcpy(fr->fr_Drawer,fr->fr_Store->rs_OriginalDrawer);
    strcpy(fr->fr_Pattern,fr->fr_Store->rs_OriginalPattern);
    ParsePat(fr);
}


/*****************************************************************************/


static VOID InsertList(struct ExtFileReq *fr)
{
struct Node *node;

    if (fr->fr_TempItemCnt)
    {
        SetGadgetAttr(&fr->fr_ReqInfo,SCROLLERGAD,GTSC_Total,fr->fr_ItemCnt+fr->fr_TempItemCnt,
                                                  TAG_DONE);

        fr->fr_TempItemCnt = 0;
    }

    while (node = RemHead((struct List *)&fr->fr_TempFileList))
	InsertListEntry(fr,node);
}


/*****************************************************************************/


static BOOL MakeDrawer(struct ExtFileReq *fr)
{
BOOL               created = FALSE;
struct DiskObject *diskObj;
struct EasyStruct  est;
BPTR               lock;
WORD               len;

    len = strlen(fr->fr_Drawer);
    if ((len > 0) && ((fr->fr_Drawer[len-1] != '/') && (fr->fr_Drawer[len-1] != ':')))
    {
        est.es_StructSize   = sizeof(struct EasyStruct);
        est.es_Flags        = 0;
        est.es_Title        = GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_NEWDIR_TITLE);
        est.es_TextFormat   = GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_NEWDIR_PROMPT);
        est.es_GadgetFormat = GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_NEWDIR_GAD);

        if (EasyRequestArgs(fr->fr_ReqInfo.ri_Window,&est,NULL,&fr->fr_Drawer))
        {
            if (lock = CreateDir(fr->fr_Drawer))
            {
                created = TRUE;
                UnLock(lock);
                if (diskObj = GetDefDiskObject(WBDRAWER))
                {
                    PutDiskObject(fr->fr_Drawer,diskObj);
                    FreeDiskObject(diskObj);
                }
            }

	    if (!created)
		DisplayBeep(NULL);
        }
    }

    return (created);
}


/*****************************************************************************/


static BOOL DeleteFiles(struct ExtFileReq *fr)
{
BOOL              getDir = FALSE;
STRPTR            buffer;
LONG              len;
struct EasyStruct est;

    InsertList(fr);

    len = strlen(fr->fr_DrawerString) + strlen(fr->fr_FileString) + 10;
    if (buffer = AllocVec(len,MEMF_ANY))
    {
	strcpy(buffer,fr->fr_DrawerString);
	AddPart(buffer,fr->fr_FileString,len);
        ReducePath(buffer);

        est.es_StructSize   = sizeof(struct EasyStruct);
        est.es_Flags        = 0;
        est.es_Title        = GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_DELETE_TITLE);;
        est.es_TextFormat   = GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_DELETE_PROMPT);
        est.es_GadgetFormat = GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_DELETE_GAD);

        if (EasyRequestArgs(fr->fr_ReqInfo.ri_Window,&est,NULL,&buffer))
        {
            if (DeleteFile(buffer))
	    {
		RemoveListEntry(fr,buffer);

                if (DeleteDiskObject(buffer))
                {
                    strcat(buffer,".info");
                    RemoveListEntry(fr,buffer);
                }

                if (strlen(fr->fr_FileString))
		{
		    fr->fr_FileString[0] = 0;
                    SetStrValue(fr,FILEGAD,"");
		    fr->fr_DisplayValid = FALSE;
		    fr->fr_FullRender   = TRUE;
		}
		else
                {
                    len = strlen(fr->fr_DrawerString);
                    if ((len == 0) || (fr->fr_DrawerString[len-1] == '/') || (fr->fr_DrawerString[len-1] == ':'))
                        strcat(fr->fr_DrawerString,"/");
                    else
                        strcat(fr->fr_DrawerString,"//");

                    ReducePath(fr->fr_DrawerString);
                    SetStrValue(fr,DRAWERGAD,fr->fr_DrawerString);
                    getDir = TRUE;
                }
	    }
	    else
	    {
                DisplayBeep(NULL);
	    }
        }

	FreeVec(buffer);
    }

    LimitTopItem(fr);
    RenderLV(fr);
    SetGadgetAttr(&fr->fr_ReqInfo,SCROLLERGAD,GTSC_Total, fr->fr_ItemCnt,
                                              GTSC_Top,   fr->fr_TopItem,
                                              TAG_DONE);

    return(getDir);
}


/*****************************************************************************/


/* returns TRUE if directory needs to be rescanned */
static BOOL SelectEntry(struct ExtFileReq *fr, struct Node *entry, UWORD quals,
                        BOOL clickedOn)
{
struct Node *node;
BOOL         getDir = FALSE;

    if ((FRF_DOSAVEMODE & fr->fr_Options)
    || (!(FRF_DOMULTISELECT & fr->fr_Options))
    || (!(quals & SHIFTKEYS)))
    {
        node = fr->fr_FileList.lh_Head;
        while (node)
        {
            node->ln_Selected = FALSE;
            node = node->ln_Succ;
        }
    }

    if (entry->ln_Type == FILETYPE)
    {
        entry->ln_Selected = TRUE;
        strcpy(fr->fr_FileString,entry->ln_Name);
        SetStrValue(fr,FILEGAD,fr->fr_FileString);
    }
    else if (clickedOn)
    {
        if (entry->ln_Type == DIRTYPE)
        {
            AddPart(fr->fr_DrawerString,entry->ln_Name,sizeof(fr->fr_DrawerString));
        }
        else
        {
            strcpy(fr->fr_DrawerString,entry->ln_Name);
            if ((entry->ln_Type == VOLUMETYPE) || (entry->ln_Type == ASSIGNTYPE))
                strcat(fr->fr_DrawerString,":");
        }
        SetStrValue(fr,DRAWERGAD,fr->fr_DrawerString);
        getDir = TRUE;
    }
    else
    {
        entry->ln_Selected = TRUE;

        strcpy(fr->fr_FileString,entry->ln_Name);
	if (entry->ln_Type == DIRTYPE)
	    strcat(fr->fr_FileString,"/");
	else if ((entry->ln_Type == VOLUMETYPE) || (entry->ln_Type == ASSIGNTYPE))
	    strcat(fr->fr_FileString,":");

        SetStrValue(fr,FILEGAD,fr->fr_FileString);
    }

    fr->fr_DisplayValid = FALSE;
    RenderLV(fr);

    return(getDir);
}


/*****************************************************************************/


static VOID FreeMultiArgs(struct ExtFileReq *fr)
{
    if (fr->fr_ArgList)
    {
        UnLock(fr->fr_ArgList->wa_Lock);

        while (fr->fr_NumArgs--)
            FreeVec(fr->fr_ArgList[fr->fr_NumArgs].wa_Name);

        FreeVec(fr->fr_ArgList);
        fr->fr_ArgList = NULL;
    }
}


/*****************************************************************************/


static BOOL QuitFR(struct ExtFileReq *fr, BOOL cancelled, BPTR dirLock)
{
struct Node *node;
ULONG        cnt;

    if (dirLock)
        WaitPort(&fr->fr_Store->rs_PacketPort);   /* wait for packet return */

    if (cancelled)
    {
        UnLock(dirLock);
        return(FALSE);
    }

    if ((FRF_DOMULTISELECT & fr->fr_Options) && (!(FRF_DOSAVEMODE & fr->fr_Options)))
    {
	if (!dirLock)
	    dirLock = Lock(fr->fr_DrawerString, ACCESS_READ);
	    if (!dirLock)
	        return(FALSE);

        fr->fr_NumArgs = 0;
        cnt            = 0;
        node           = fr->fr_FileList.lh_Head;
        while (node->ln_Succ)
        {
            if (node->ln_Selected)
                cnt++;
            node = node->ln_Succ;
        }

        /* add one to the count, to include the string gadget contents */
        if (fr->fr_ArgList = AllocVec(sizeof(struct WBArg)*(cnt+1),MEMF_CLEAR|MEMF_ANY))
        {
            fr->fr_NumArgs = cnt;

            cnt  = 0;
            node = fr->fr_FileList.lh_Head;
            while (node->ln_Succ)
            {
                if (node->ln_Selected)
                {
                    fr->fr_ArgList[cnt].wa_Lock = dirLock;
                    if (!(fr->fr_ArgList[cnt].wa_Name = AllocVec(strlen(node->ln_Name)+1,MEMF_ANY)))
                    {
                        FreeMultiArgs(fr);
                        return(FALSE);
                    }

                    strcpy(fr->fr_ArgList[cnt].wa_Name,node->ln_Name);
                    cnt++;
                }
                node = node->ln_Succ;
            }

            if (fr->fr_FileString[0])
            {
                node = FindNameNC(&fr->fr_FileList,fr->fr_FileString);

                if (!node || (!node->ln_Selected))
                {
                    fr->fr_ArgList[cnt].wa_Lock = dirLock;
                    if (!(fr->fr_ArgList[cnt].wa_Name = AllocVec(strlen(fr->fr_FileString)+1,MEMF_ANY)))
                    {
                        FreeMultiArgs(fr);
                        return(FALSE);
                    }
                    fr->fr_NumArgs++;
                    strcpy(fr->fr_ArgList[cnt].wa_Name,fr->fr_FileString);
                }
            }
        }
	else
	{
	    UnLock(dirLock);
	}
    }
    else
    {
        UnLock(dirLock);
    }

    return(TRUE);
}


/*****************************************************************************/


static BOOL UserFilters(struct ExtFileReq *fr)
{
BOOL result;

    result = TRUE;
    if (fr->fr_CallOldFilter && fr->fr_ReqInfo.ri_OldHook)
    {
         result = (CallFunc(fr->fr_ReqInfo.ri_OldHook,FRF_FILTERFUNC,(ULONG)&fr->fr_Store->rs_AP,(ULONG)PUBLIC_FR(fr),fr->fr_ReqInfo.ri_A4) == 0);
    }

    if (result && fr->fr_FilterFunc)
    {
         result = CallHookPkt(fr->fr_FilterFunc,PUBLIC_FR(fr),&fr->fr_Store->rs_AP);
    }

    return(result);
}


/*****************************************************************************/


static VOID CursorSelect(struct ExtFileReq *fr, struct Gadget *gadget,
                         UWORD icode, UWORD quals)
{
struct Node    *node;
struct ReqInfo *ri;
BOOL            found;
ULONG           num;
ULONG           top;
UWORD           len;
UWORD           cnt;
BOOL            stringBased;

    ri = &fr->fr_ReqInfo;
    InsertList(fr);

    if (!IsListEmpty(&fr->fr_FileList))
    {
        top = fr->fr_TopItem;
        if (quals & ALTKEYS)
        {
            if (icode == CURSORUP)
            {
                SelectEntry(fr,fr->fr_FileList.lh_Head,0,FALSE);
                top = 0;
            }
            else
            {
                SelectEntry(fr,fr->fr_FileList.lh_TailPred,0,FALSE);
                if (fr->fr_ItemCnt > fr->fr_VisibleItems)
                    top = fr->fr_ItemCnt - fr->fr_VisibleItems;
                else
                    top = 0;
            }
        }
        else
        {
	    node = fr->fr_FileList.lh_Head;
	    while (node->ln_Succ && !node->ln_Selected)
	        node = node->ln_Succ;

            stringBased = FALSE;
            if (!node->ln_Succ)
            {
                stringBased = TRUE;
                if (len = strlen(fr->fr_FileString))
                    if ((fr->fr_FileString[len-1] == '/') || (fr->fr_FileString[len-1] == ':'))
                        fr->fr_FileString[len-1] = 0;

                if (!(node = FindClosest(&fr->fr_FileList,fr->fr_FileString)))
                    node = fr->fr_FileList.lh_TailPred;
            }

            cnt = 1;
            if ((quals & SHIFTKEYS) && (fr->fr_VisibleItems > 1))
                cnt = fr->fr_VisibleItems-1;

            found = FALSE;
            if (stringBased && (Stricmp(node->ln_Name,fr->fr_FileString)))
            {
                found = TRUE;
            }
            else if (icode == CURSORUP)
            {
                while ((node != fr->fr_FileList.lh_Head) && cnt)
                {
                    node = node->ln_Pred;
                    found = TRUE;
                    cnt--;
                }
            }
            else if (icode == CURSORDOWN)
            {
                while ((node != fr->fr_FileList.lh_TailPred) && cnt)
                {
                    node = node->ln_Succ;
                    found = TRUE;
                    cnt--;
                }
            }

            if (found)
            {
                SelectEntry(fr,node,0,FALSE);

                num = FindNodeNum((struct List *)&fr->fr_FileList,node);

                if (num < fr->fr_TopItem)
                    top = num;

                if (num > fr->fr_TopItem + fr->fr_VisibleItems - 1)
                    top = num - fr->fr_VisibleItems + 1;
            }
        }

        fr->fr_TopItem = top;
        RenderLV(fr);
        SetGadgetAttr(&fr->fr_ReqInfo,SCROLLERGAD,GTSC_Top, top,
                                                  TAG_DONE);
    }

    if (gadget)
	ActivateGadget(gadget,ri->ri_Window,NULL);
}


/*****************************************************************************/


static VOID DriveLight(struct ExtFileReq *fr, UWORD pen)
{
    if (fr->fr_LightHeight >= MINLIGHTHEIGHT)
    {
        SetAPen(fr->fr_ReqInfo.ri_Window->RPort,fr->fr_ReqInfo.ri_DrawInfo->dri_Pens[pen]);
        RectFill(fr->fr_ReqInfo.ri_Window->RPort,fr->fr_LightLeft+2,
                                                 fr->fr_LightTop+1,
                                                 fr->fr_LightLeft+fr->fr_LightWidth-3,
                                                 fr->fr_LightTop+fr->fr_LightHeight-2);
    }
}


/*****************************************************************************/


static VOID ActivateMajorGuy(struct ExtFileReq *fr)
{
    if (FRF_DRAWERSONLY & fr->fr_Options2)
        ActivateGadget(fr->fr_ReqInfo.ri_Template[DRAWERGAD].ag_Gadget,fr->fr_ReqInfo.ri_Window,NULL);
    else
        ActivateGadget(fr->fr_ReqInfo.ri_Template[FILEGAD].ag_Gadget,fr->fr_ReqInfo.ri_Window,NULL);
}


/*****************************************************************************/


static BOOL DoParent(struct ExtFileReq *fr)
{
UWORD len;
BPTR  lock;
BPTR  parent;
BOOL  getVolumes;

    getVolumes = TRUE;
    if (lock = Lock(fr->fr_DrawerString,ACCESS_READ))
    {
        if (parent = ParentDir(lock))
        {
            len = strlen(fr->fr_DrawerString);
            if ((len == 0) || (fr->fr_DrawerString[len-1] == '/') || (fr->fr_DrawerString[len-1] == ':'))
                strcat(fr->fr_DrawerString,"/");
            else
                strcat(fr->fr_DrawerString,"//");

            ReducePath(fr->fr_DrawerString);
            SetStrValue(fr,DRAWERGAD,fr->fr_DrawerString);
            getVolumes = FALSE;

            UnLock(parent);
        }
        UnLock(lock);
    }

    return(getVolumes);
}


/*****************************************************************************/


static BOOL HandleFRIDCMP(struct ExtFileReq *fr)
{
struct IntuiMessage   *intuiMsg;
ULONG                  class;
UWORD                  icode;
WORD                   mouseY;
UWORD                  quals;
struct Gadget         *gadget;
struct Window         *window;
ULONG                  seconds;
ULONG                  micros;
struct MenuItem       *menuItem;
struct ReqInfo        *ri;
struct Node           *node;
struct Node           *entry;
BOOL                   getDir, getVolumes, new, volumes;
STRPTR                 ptr;
BPTR                   lock;
BOOL                   accept;
BOOL                   newsize;
char                   infoPat[48];
struct FileLock       *lockPtr;
struct FileEntry      *file;
struct DirEntry       *dir;
struct Gadget         *gad;
struct AppMessage     *appMsg;
struct FileInfoBlock  *fib;
struct StandardPacket *packet;
struct FRStore        *store;
ULONG                  tickCnt;
BOOL                   firstBatch;
struct Node           *oldEntry;
ULONG                  oldSeconds;
ULONG                  oldMicros;
ULONG                  mask;
BOOLEAN                clearTempPat;

    ri           = &fr->fr_ReqInfo;
    volumes      = FALSE;
    getDir       = TRUE;
    getVolumes   = FALSE;
    lock         = NULL;
    newsize      = FALSE;
    store        = fr->fr_Store;
    fib          = &store->rs_AC.an_Info;
    packet       = &store->rs_StdPkt;
    clearTempPat = TRUE;

    mask = (1L<<store->rs_PacketPort.mp_SigBit) | (1L<<store->rs_AppPort.mp_SigBit);

    FixedParsePattern("#?.(INFO|BACKDROP)",infoPat,sizeof(infoPat));
    ParsePat(fr);

    ptr = FilePart(fr->fr_DrawerString);
    if (FixedParsePattern(ptr,store->rs_TempPattern,sizeof(store->rs_TempPattern)) > 0)
    {
        *ptr         = 0;
        clearTempPat = FALSE;
        SetStrValue(fr,DRAWERGAD,fr->fr_DrawerString);
    }

    ActivateMajorGuy(fr);

    while (TRUE)
    {
        if (getDir)
        {
            oldEntry   = NULL;
            oldSeconds = 0;      /* not needed, but keeps compiler from complaining of uninitialized var */
            oldMicros  = 0;
            tickCnt    = 0;
            firstBatch = TRUE;

            if (clearTempPat)
                store->rs_TempPattern[0] = 0;
            clearTempPat = TRUE;

            InitFileList(fr);

            if (!getVolumes)
            {
                RenderLV(fr);
                SetGadgetAttr(ri,SCROLLERGAD,
                              GTSC_Visible, fr->fr_VisibleItems,
                              GTSC_Total,   0,
                              GTSC_Top,     0,
                              TAG_DONE);
            }
            DriveLight(fr,FILLPEN);

            if (lock)
            {
                WaitPort(&store->rs_PacketPort);   /* wait for packet return */
                GetMsg(&store->rs_PacketPort);     /* get packet out of port */
                UnLock(lock);
                lock = NULL;
            }

            if (!getVolumes)
            {
                volumes = FALSE;
                if (lock = Lock(fr->fr_DrawerString,ACCESS_READ))
                {
                    if (Examine(lock,fib) && (fib->fib_DirEntryType > 0))
                    {
                        packet->sp_Pkt.dp_Type = ACTION_EXAMINE_NEXT;
                        packet->sp_Pkt.dp_Arg1 = lock;
                        packet->sp_Pkt.dp_Arg2 = (ULONG)fib >> 2;
                        lockPtr                = (struct FileLock *)((ULONG)lock << 2);
                        SendPkt(&packet->sp_Pkt,lockPtr->fl_Task,&store->rs_PacketPort);
                        store->rs_AC.an_Lock   = lock;
                    }
                    else
                    {
                        UnLock(lock);
                        lock = NULL;
                        DisplayBeep(ri->ri_Screen);
                        getVolumes = TRUE;
                    }
                }
                else if (IoErr() != ERROR_ACTION_NOT_KNOWN)
                {
                    DriveLight(fr,BACKGROUNDPEN);
                    if (FRF_DOSAVEMODE & fr->fr_Options)
                    {
                        getVolumes = !(MakeDrawer(fr));
                    }
                    else
                    {
                        DisplayBeep(ri->ri_Screen);
                        getVolumes = TRUE;
                    }
                }
            }

            if (getVolumes)
            {
                volumes = TRUE;
                CreateVolumeList(fr);

                RenderLV(fr);
                SetGadgetAttr(ri,SCROLLERGAD,
                              GTSC_Visible, fr->fr_VisibleItems,
                              GTSC_Total,   fr->fr_ItemCnt,
                              GTSC_Top,     0,
                              TAG_DONE);

                DriveLight(fr,BACKGROUNDPEN);
            }
            getDir     = FALSE;
            getVolumes = FALSE;
        }

        window = ri->ri_Window;
        if (newsize || (LAYERREFRESH & window->WLayer->Flags))
        {
             LockLayerInfo(&window->WScreen->LayerInfo);

             GT_BeginRefresh(window);
             if (newsize)
                 GT_EndRefresh(window,TRUE);

             RenderFRDisplay(fr);
             fr->fr_DisplayValid = FALSE;
             RenderLV(fr);

             if (lock)
                 DriveLight(fr,FILLPEN);

             if (!newsize)
                 GT_EndRefresh(window,TRUE);

             UnlockLayerInfo(&window->WScreen->LayerInfo);

             newsize = FALSE;
        }

        intuiMsg = GetReqMsg(ri,PUBLIC_FR(fr),NULL,mask);

        if (GetMsg(&store->rs_PacketPort))
        {
            if (packet->sp_Pkt.dp_Res1)
            {
                packet->sp_Pkt.dp_Type = ACTION_EXAMINE_NEXT;
                packet->sp_Pkt.dp_Arg1 = lock;
                packet->sp_Pkt.dp_Arg2 = (ULONG)fib >> 2;
                lockPtr                = (struct FileLock *)((ULONG)lock << 2);

                store->rs_AP.ap_Info = store->rs_AC.an_Info;

                SendPkt(&packet->sp_Pkt,lockPtr->fl_Task,&store->rs_PacketPort);

                BtoC(store->rs_AP.ap_Info.fib_FileName,store->rs_AP.ap_Info.fib_FileName);

                accept = TRUE;
                if ((store->rs_AP.ap_Info.fib_DirEntryType < 0) || (FRF_FILTERDRAWERS & fr->fr_Options2))
                {
                    accept = (((store->rs_AP.ap_Info.fib_DirEntryType > 0) || (!(FRF_DRAWERSONLY & fr->fr_Options2)))
                             && (!(FRF_REJECTICONS & fr->fr_Options2) || !MatchPatternNoCase(infoPat,store->rs_AP.ap_Info.fib_FileName))
                             && (!fr->fr_AcceptPattern || MatchPatternNoCase(fr->fr_AcceptPattern,store->rs_AP.ap_Info.fib_FileName))
                             && (!fr->fr_RejectPattern || !MatchPatternNoCase(fr->fr_RejectPattern,store->rs_AP.ap_Info.fib_FileName))
                             && (UserFilters(fr))
                             && (!store->rs_TempPattern[0] || MatchPatternNoCase(store->rs_TempPattern,store->rs_AP.ap_Info.fib_FileName))
                             && (!store->rs_ParsedPattern[0] || MatchPatternNoCase(store->rs_ParsedPattern,store->rs_AP.ap_Info.fib_FileName)));
                }
                else if (store->rs_AP.ap_Info.fib_DirEntryType > 0)
                {
                    accept = UserFilters(fr);
                }

                if (accept)
                {
                    node = NULL;
                    if (store->rs_AP.ap_Info.fib_DirEntryType > 0)
                    {
                        if (dir = AllocNamedNode2(sizeof(struct DirEntry),DIRTYPE,store->rs_AP.ap_Info.fib_FileName))
                        {
                            dir->de_Link.ln_Type = DIRTYPE;
                            dir->de_Date = store->rs_AP.ap_Info.fib_Date;
                            node = (struct Node *)dir;
                        }
                    }
                    else
                    {
                        if (file = AllocNamedNode2(sizeof(struct FileEntry),FILETYPE,store->rs_AP.ap_Info.fib_FileName))
                        {
                            file->fe_Link.ln_Type = FILETYPE;
                            file->fe_Date = store->rs_AP.ap_Info.fib_Date;
                            file->fe_Size = store->rs_AP.ap_Info.fib_Size;
                            node = (struct Node *)file;
                        }
                    }

                    if (node)
                    {
                        if ((fr->fr_OldItemCnt < fr->fr_VisibleItems) || (firstBatch))
                        {
                            if (fr->fr_ItemCnt == 0)
                                tickCnt = 0;

                            InsertListEntry(fr,node);
                            if (tickCnt > 4)
                            {
                                tickCnt    = 0;
                                firstBatch = FALSE;
                                RenderLV(fr);
                            }
                        }
                        else
                        {
                            AddTail((struct List *)&fr->fr_TempFileList,node);
                            fr->fr_TempItemCnt++;
                        }
                    }
                }
            }
            else
            {
                UnLock(lock);
                lock = NULL;

                SetGadgetAttr(ri,SCROLLERGAD,GTSC_Total,fr->fr_ItemCnt+fr->fr_TempItemCnt,
                                             TAG_DONE);

                RenderLV(fr);
                DriveLight(fr,BACKGROUNDPEN);
            }
        }

        while (appMsg = (struct AppMessage *)GetMsg(&store->rs_AppPort))
        {
            ActivateWindow(ri->ri_Window);

            if (appMsg->am_NumArgs)
            {
                NameFromLock(appMsg->am_ArgList->wa_Lock,fr->fr_DrawerString,sizeof(fr->fr_DrawerString));
                SetStrValue(fr,DRAWERGAD,fr->fr_DrawerString);
                getDir = TRUE;

                if ((appMsg->am_ArgList->wa_Name) && (strlen(appMsg->am_ArgList->wa_Name) > 0))
                {
                    strcpy(fr->fr_FileString,appMsg->am_ArgList->wa_Name);
                    SetStrValue(fr,FILEGAD,fr->fr_FileString);
                }
            }

            ReplyMsg((struct Message *)appMsg);
        }

        if (intuiMsg)
        {
            class   = intuiMsg->Class;
            icode   = intuiMsg->Code;
            gadget  = (struct Gadget *)intuiMsg->IAddress;
            window  = intuiMsg->IDCMPWindow;
            mouseY  = intuiMsg->MouseY;
            quals   = intuiMsg->Qualifier;
            seconds = intuiMsg->Seconds;
            micros  = intuiMsg->Micros;
            GT_ReplyIMsg(intuiMsg);

            if (gad = ri->ri_Template[PATTERNGAD].ag_Gadget)
                strcpy(fr->fr_PatternString,((struct StringInfo *)gad->SpecialInfo)->Buffer);

            if (gad = ri->ri_Template[DRAWERGAD].ag_Gadget)
                strcpy(fr->fr_DrawerString,((struct StringInfo *)gad->SpecialInfo)->Buffer);

            if (gad = ri->ri_Template[FILEGAD].ag_Gadget)
                strcpy(fr->fr_FileString,((struct StringInfo *)gad->SpecialInfo)->Buffer);

            switch (class)
            {
                case IDCMP_REFRESHWINDOW: break;

                case IDCMP_ACTIVEWINDOW : ActivateMajorGuy(fr);
                                          break;

                case IDCMP_CLOSEWINDOW  : return(QuitFR(fr,TRUE,lock));

                case IDCMP_MENUPICK     : while (icode != MENUNULL)
                                          {
                                              menuItem = ItemAddress(ri->ri_Menus,icode);
                                              switch ((UWORD)MENU_USERDATA(menuItem))
                                              {
                                                  case FR_CANCEL  : return(QuitFR(fr,TRUE,lock));
                                                  case FR_OK      : return(QuitFR(fr,FALSE,lock));

                                                  case FR_RESTORE : FRRestore(fr);
                                                                    SetStrValue(fr,FILEGAD,fr->fr_FileString);
                                                                    SetStrValue(fr,DRAWERGAD,fr->fr_DrawerString);
                                                                    SetStrValue(fr,PATTERNGAD,fr->fr_PatternString);
                                                                    getDir = TRUE;
                                                                    break;

                                                  case FR_PARENT  : getDir     = TRUE;
                                                                    getVolumes = DoParent(fr);
                                                                    break;

                                                  case FR_VOLUMES : getDir     = TRUE;
                                                                    getVolumes = !volumes;
                                                                    break;

                                                  case FR_DELETE  : getDir = DeleteFiles(fr);
                                                                    break;

                                                  case FR_PREVNAME: CursorSelect(fr,NULL,CURSORUP,quals);
								    break;

                                                  case FR_NEXTNAME: CursorSelect(fr,NULL,CURSORDOWN,quals);
                                                                    break;

                                                  default         : break;
                                              }
                                              icode = menuItem->NextSelect;
                                          }
                                          ActivateMajorGuy(fr);
                                          break;

                case IDCMP_MOUSEBUTTONS : if (icode == SELECTUP)
                                          {
                                              window->Flags &= ~(WFLG_RMBTRAP);
                                              ActivateMajorGuy(fr);
                                              break;
                                          }
                                          else if (icode == MENUDOWN)
                                          {
                                              if (oldEntry)
                                              {
                                                  oldEntry->ln_Selected = FALSE;
                                                  oldEntry = NULL;
                                                  SetStrValue(fr,FILEGAD,"");
                                                  fr->fr_FileString[0] = 0;
                                                  fr->fr_DisplayValid = FALSE;
                                                  RenderLV(fr);
                                              }
                                              window->Flags &= ~(WFLG_RMBTRAP);
                                          }
                                          else if ((icode == MIDDLEDOWN) && (!(quals & (SHIFTKEYS|ALTKEYS))))
                                          {
                                              getDir     = TRUE;
                                              getVolumes = !volumes;
                                          }
                                          break;

                case IDCMP_GADGETUP     : if ((gadget->GadgetType & STRGADGET) && (icode == -1))
                                          {
                                              ActivateGadget(gadget,window,NULL);
                                              break;
                                          }

                case IDCMP_MOUSEMOVE    :
                case IDCMP_GADGETDOWN   : switch ((UWORD)gadget->GadgetID)
                                          {
                                              case FR_CANCEL    : return(QuitFR(fr,TRUE,lock));
                                              case FR_OK        : return(QuitFR(fr,FALSE,lock));

                                              case FR_LISTSCROLL: fr->fr_TopItem = icode;
                                                                  InsertList(fr);
                                                                  RenderLV(fr);
                                                                  break;

                                              case FR_LISTCLICK : window->Flags |= WFLG_RMBTRAP;
                                                                  icode = (mouseY - (WORD)fr->fr_LVTop) / fr->fr_ItemHeight;
                                                                  if (icode < fr->fr_VisibleItems)
                                                                  {
                                                                      icode += fr->fr_TopItem;
                                                                      entry = fr->fr_FileList.lh_Head;
                                                                      while (icode-- && entry->ln_Succ)
                                                                          entry = entry->ln_Succ;

                                                                      if (entry->ln_Succ)
                                                                      {
                                                                          getDir = SelectEntry(fr,entry,quals,TRUE);

                                                                          if ((entry == oldEntry)
                                                                          && (!(FRF_DOSAVEMODE & fr->fr_Options))
                                                                          && (DoubleClick(oldSeconds,oldMicros,seconds,micros)))
                                                                              return(QuitFR(fr,FALSE,lock));

                                                                          oldEntry   = entry;
                                                                          oldSeconds = seconds;
                                                                          oldMicros  = micros;
                                                                      }
                                                                      else
                                                                      {
                                                                          oldEntry = NULL;
                                                                      }
                                                                  }
                                                                  break;

                                              case FR_PARENT    : getDir     = TRUE;
                                                                  getVolumes = DoParent(fr);
                                                                  ActivateMajorGuy(fr);
                                                                  break;

                                              case FR_VOLUMES   : getDir     = TRUE;
                                                                  getVolumes = !volumes;
                                                                  ActivateMajorGuy(fr);
                                                                  break;

                                              case FR_PATTERN   : ActivateGad(fr,PATTERNGAD,quals);
                                                                  getDir = TRUE;
                                                                  ParsePat(fr);
                                                                  break;

                                              case FR_DRAWER    : ReducePath(fr->fr_DrawerString);
                                                                  ptr = FilePart(fr->fr_DrawerString);
                                                                  if (FixedParsePattern(ptr,store->rs_TempPattern,sizeof(store->rs_TempPattern)) > 0)
                                                                  {
                                                                      *ptr = 0;
                                                                      clearTempPat = FALSE;
                                                                  }
                                                                  else
                                                                  {
                                                                      store->rs_TempPattern[0] = 0;
                                                                  }

                                                                  SetStrValue(fr,DRAWERGAD,fr->fr_DrawerString);
                                                                  ActivateGad(fr,DRAWERGAD,quals);
                                                                  getDir = TRUE;
                                                                  break;

                                              case FR_FILE      : if ((icode == CURSORUP) || (icode == CURSORDOWN))
                                                                  {
								      CursorSelect(fr,gadget,icode,quals);
                                                                  }
                                                                  else
                                                                  {
                                                                      ptr = FilePart(fr->fr_FileString);
                                                                      if (ptr == fr->fr_FileString)
                                                                      {
                                                                          if ((FRF_DOPATTERNS & fr->fr_Options)
                                                                          &&  (FixedParsePattern(fr->fr_FileString,store->rs_ParsedPattern,sizeof(store->rs_ParsedPattern)) > 0))
                                                                          {
                                                                              strcpy(fr->fr_PatternString,fr->fr_FileString);
                                                                              SetStrValue(fr,PATTERNGAD,fr->fr_PatternString);
                                                                              SetStrValue(fr,FILEGAD,"");
                                                                              getDir = TRUE;
                                                                          }
                                                                          else if ((quals & ALTKEYS) || icode == 9)
                                                                          {
                                                                              ActivateGad(fr,FILEGAD,quals);
                                                                          }
                                                                          else if (!(quals & SHIFTKEYS))
                                                                          {
                                                                              return(QuitFR(fr,FALSE,lock));
                                                                          }
                                                                      }
                                                                      else
                                                                      {
                                                                          new = FALSE;
                                                                          if (stpchr(fr->fr_FileString,':'))
                                                                          {
                                                                              fr->fr_DrawerString[0] = 0;
                                                                              new = TRUE;
                                                                          }

                                                                          if (ptr != fr->fr_FileString)
                                                                          {
                                                                              AddPart(fr->fr_DrawerString,fr->fr_FileString,sizeof(fr->fr_DrawerString));
                                                                              strcpy(fr->fr_FileString,ptr);
                                                                              ptr    = FilePart(fr->fr_DrawerString);
                                                                              ptr[0] = 0;
                                                                              new    = TRUE;
                                                                          }

                                                                          if (new)
                                                                          {
                                                                              ReducePath(fr->fr_DrawerString);
                                                                              SetStrValue(fr,DRAWERGAD,fr->fr_DrawerString);
                                                                          }

                                                                          if ((FRF_DOPATTERNS & fr->fr_Options)
                                                                          &&  (FixedParsePattern(fr->fr_FileString,store->rs_ParsedPattern,sizeof(store->rs_ParsedPattern)) > 0))
                                                                          {
                                                                              SetStrValue(fr,PATTERNGAD,fr->fr_FileString);
                                                                              strcpy(fr->fr_PatternString,fr->fr_FileString);
                                                                              SetStrValue(fr,FILEGAD,"");
                                                                              getDir = TRUE;
                                                                          }
                                                                          else
                                                                          {
                                                                              SetStrValue(fr,FILEGAD,fr->fr_FileString);
                                                                              if (new)
                                                                              {
                                                                                  getDir = TRUE;
                                                                              }
                                                                          }
                                                                      }

                                                                      if (getDir)
                                                                          ActivateGadget(gadget,window,NULL);
                                                                      else
                                                                          ActivateGad(fr,FILEGAD,quals);
                                                                      ParsePat(fr);
                                                                  }
                                                                  break;

                                              default           : break;
                                          }
                                          break;

                case IDCMP_NEWSIZE      : if (!CreateFRGadgets(fr))
                                              return(QuitFR(fr,TRUE,lock));
                                          newsize = TRUE;
                                          InsertList(fr);
                                          break;

                case IDCMP_INTUITICKS   : tickCnt++;
                                          if (fr->fr_ZoomOnFileSig >= 0)
                                          {
                                              if (SetSignal(0,1L << fr->fr_ZoomOnFileSig) & (1L << fr->fr_ZoomOnFileSig))
                                              {
                                                  InsertList(fr);

                                                  if (!IsListEmpty(&fr->fr_FileList))
                                                  {
                                                      if (!(node = FindClosest(&fr->fr_FileList,fr->fr_FileString)))
                                                          node = fr->fr_FileList.lh_TailPred;

                                                      fr->fr_TopItem = FindNodeNum(&fr->fr_FileList,node);
                                                      LimitTopItem(fr);

                                                      SetGadgetAttr(ri,SCROLLERGAD,GTSC_Top, fr->fr_TopItem,
                                                                                   TAG_DONE);
                                                      RenderLV(fr);
                                                  }
                                              }
                                          }
                                          break;

                case IDCMP_RAWKEY       : if ((icode == CURSORUP) || (icode == CURSORDOWN))
                			      CursorSelect(fr,NULL,icode,quals);
                			  else if (icode & IECODE_UP_PREFIX)
                			      ActivateMajorGuy(fr);
                			  break;

                case IDCMP_DISKINSERTED :
                case IDCMP_DISKREMOVED  : getDir     = volumes;
                                          getVolumes = volumes;
                                          break;
            }
        }
    }
}


/*****************************************************************************/


static VOID ProcessFRTags(struct ExtFileReq *fr, struct TagItem *tagList)
{
struct TagItem *tag;
struct TagItem *tags = tagList;
ULONG           data;

    while (tag = NextTagItem(&tags))
    {
        data = tag->ti_Data;
        switch(tag->ti_Tag)
        {
            case ASLFR_InitialFile     : strncpy(fr->fr_FileString,(STRPTR)data,sizeof(fr->fr_FileString));
                                         break;

            case ASLFR_InitialDrawer   : strncpy(fr->fr_DrawerString,(STRPTR)data,sizeof(fr->fr_DrawerString));
                                         break;

            case ASLFR_InitialPattern  : strncpy(fr->fr_PatternString,(STRPTR)data,sizeof(fr->fr_PatternString));
                                         break;

            case ASLFR_RejectPattern   : fr->fr_RejectPattern = (APTR)data;
                                         break;

            case ASLFR_AcceptPattern   : fr->fr_AcceptPattern = (APTR)data;
                                         break;

            case ASLFR_HookFunc        : fr->fr_ReqInfo.ri_OldHook = (APTR)data;
                                         break;

            case ASLFR_FilterFunc      : fr->fr_FilterFunc = (struct Hook *)data;
                                         break;

            case ASLFR_Flags1          : fr->fr_Options                 = (ULONG)data;
                                         fr->fr_ReqInfo.ri_CallOldHook  = (BOOL)(data & FRF_INTUIFUNC);
                                         fr->fr_CallOldFilter           = (BOOL)(data & FRF_FILTERFUNC);
                                         fr->fr_ReqInfo.ri_PrivateIDCMP = (BOOL)(data & FRF_PRIVATEIDCMP);
                                         break;

            case ASLFR_Flags2          : fr->fr_Options2 = (ULONG)data;
                                         break;

            case ASLFR_UserData        : fr->fr_UserData = (APTR)data;
                                         break;

            default                    : ProcessStdTag(&fr->fr_ReqInfo,tag);
                                         break;
        }
    }

    fr->fr_Options = AslPackBoolTags(fr->fr_Options,tagList,
                                     ASLFR_DoPatterns,    FRF_DOPATTERNS,
                                     ASLFR_DoMultiSelect, FRF_DOMULTISELECT,
                                     ASLFR_DoSaveMode,    FRF_DOSAVEMODE,
                                     TAG_DONE);

    fr->fr_Options2 = AslPackBoolTags(fr->fr_Options2,tagList,
                                      ASLFR_DrawersOnly,   FRF_DRAWERSONLY,
                                      ASLFR_FilterDrawers, FRF_FILTERDRAWERS,
                                      ASLFR_RejectIcons,   FRF_REJECTICONS,
                                      TAG_DONE);
}



/*****************************************************************************/


#undef SysBase

static ULONG ASM EditHook(REG(a0) struct Hook *hook,
                          REG(a2) struct SGWork *sgw,
                          REG(a1) ULONG *msg)
{
struct ExtFileReq *fr = hook->h_Data;
struct Library    *SysBase = (*((struct Library **) 4));

    if (*msg != SGH_KEY)
        return(0);

    if (sgw->IEvent->ie_Qualifier & IEQUALIFIER_RCOMMAND)
    {
        switch (sgw->IEvent->ie_Code)
        {
            case 0x67     :
            case KEYCODE_Q:
            case KEYCODE_Z:
            case KEYCODE_X: if (fr->fr_ZoomOnFileSig >= 0)
                                Signal(fr->fr_ReqInfo.ri_Window->UserPort->mp_SigTask,1L << fr->fr_ZoomOnFileSig);
                            break;

            default       : sgw->Actions = SGA_REUSE | SGA_END;
                            sgw->Code    = -1;
                            break;
        }
    }
    else if ((sgw->IEvent->ie_Code == CURSORUP)
         ||  (sgw->IEvent->ie_Code == CURSORDOWN))
    {
        sgw->Actions |= SGA_END;
        sgw->Code     = sgw->IEvent->ie_Code;
    }
    else if (sgw->EditOp != EO_NOOP)
    {
        if (fr->fr_ZoomOnFileSig >= 0)
            Signal(fr->fr_ReqInfo.ri_Window->UserPort->mp_SigTask,1L << fr->fr_ZoomOnFileSig);
    }

    return (1);
}

#define SysBase AslBase->ASL_SysBase


/*****************************************************************************/


struct ExtFileReq *AllocFileRequest(struct TagItem *tagList)
{
struct ExtFileReq *fr;

    if (fr = AllocVec(sizeof(struct ExtFileReq),MEMF_CLEAR|MEMF_ANY))
    {
	NewList(&fr->fr_FileList);
	NewList((struct List *)&fr->fr_TempFileList);

        fr->fr_ReqInfo.ri_Coords.Left   = 30;
        fr->fr_ReqInfo.ri_Coords.Top    = 20;
        fr->fr_ReqInfo.ri_Coords.Width  = 318;
        fr->fr_ReqInfo.ri_Coords.Height = 178;

        fr->fr_ReqInfo.ri_TitleID     = MSG_ASL_FR_TITLE;
        fr->fr_ReqInfo.ri_IDCMPFlags  = IDCMP_MENUPICK | IDCMP_REFRESHWINDOW | IDCMP_CLOSEWINDOW | IDCMP_NEWSIZE | IDCMP_RAWKEY | IDCMP_ACTIVEWINDOW | IDCMP_INTUITICKS | IDCMP_MOUSEBUTTONS | IDCMP_DISKINSERTED | IDCMP_DISKREMOVED | SCROLLERIDCMP | BUTTONIDCMP;
        fr->fr_ReqInfo.ri_WindowFlags = WFLG_DRAGBAR | WFLG_DEPTHGADGET | WFLG_CLOSEGADGET | WFLG_SIZEGADGET | WFLG_SIMPLE_REFRESH | WFLG_ACTIVATE | WFLG_SIZEBBOTTOM;

        fr->fr_Pattern = fr->fr_PatternString;
        fr->fr_Drawer  = fr->fr_DrawerString;
        fr->fr_File    = fr->fr_FileString;

        strcpy(fr->fr_PatternString,"#?");

        ProcessFRTags(fr,tagList);

        fr->fr_Coords = fr->fr_ReqInfo.ri_Coords;

	fr->fr_FileHook.h_Entry = EditHook;
	fr->fr_FileHook.h_Data  = fr;
    }

    return(fr);
}


/*****************************************************************************/


APTR FileRequest(struct ExtFileReq *fr, struct TagItem *tagList)
{
struct ReqInfo *ri     = &fr->fr_ReqInfo;
struct ASLLib  *asl    = AslBase;
LONG            error  = ERROR_NO_FREE_STORE;
BOOL            result = FALSE;
struct Process *process;
struct Message *msg;
struct FRStore *store;

    FreeMultiArgs(fr);
    if (store = fr->fr_Store = PrepareRequester(ri,AG,sizeof(AG),sizeof(struct FRStore)))
    {
        ProcessFRTags(fr,tagList);
        PrepareLocale(&fr->fr_ReqInfo);

        /* Do requester specific layout */
        if (!(FRF_DOPATTERNS & fr->fr_Options))
        {
            ri->ri_Template[PATTERNGAD].ag_LOGroup = 0;
        }

        if (FRF_DRAWERSONLY & fr->fr_Options2)
        {
            ri->ri_Template[FILEGAD].ag_LOGroup = 0;
        }

        FRPreserve(fr);

        process                         = (struct Process *)FindTask(NULL);
        store->rs_PacketPort.mp_Flags   = PA_SIGNAL;
        store->rs_PacketPort.mp_SigTask = (struct Task *)process;
        store->rs_PacketPort.mp_SigBit  = process->pr_MsgPort.mp_SigBit;
        NewList(&store->rs_PacketPort.mp_MsgList);

        store->rs_AppPort.mp_Flags   = PA_SIGNAL;
        store->rs_AppPort.mp_SigTask = (struct Task *)process;
        store->rs_AppPort.mp_SigBit  = process->pr_MsgPort.mp_SigBit;
        NewList(&store->rs_AppPort.mp_MsgList);

        store->rs_StdPkt.sp_Msg.mn_Node.ln_Name = (STRPTR)&store->rs_StdPkt.sp_Pkt;
        store->rs_StdPkt.sp_Pkt.dp_Link         = &store->rs_StdPkt.sp_Msg;
        store->rs_AP.ap_Current                 = &store->rs_AC;

        if (OpenRequester(ri,AM))
        {
            fr->fr_ZoomOnFileSig = AllocSignal(-1);

            if (asl->ASL_WorkbenchBase = OpenLibrary("workbench.library",37))
                fr->fr_AppWindow = AddAppWindowA(0,0,ri->ri_Window,&store->rs_AppPort,NULL);

            if (CreateFRGadgets(fr))
            {
                error = 0;

                InitFileList(fr);

                RenderFRDisplay(fr);

                result = HandleFRIDCMP(fr);

                InitFileList(fr);
            }

            if (fr->fr_AppWindow)
            {
                RemoveAppWindow(fr->fr_AppWindow);
                fr->fr_AppWindow = NULL;

                while (msg = GetMsg(&store->rs_AppPort))
                    ReplyMsg(msg);
            }
            CloseLibrary(asl->ASL_WorkbenchBase);

            if (fr->fr_ZoomOnFileSig >= 0)
                FreeSignal(fr->fr_ZoomOnFileSig);

            CloseRequester(ri);
        }

        fr->fr_Coords = ri->ri_Coords;

        if (!result)
            FRRestore(fr);

        CleanupRequester(ri,store);
    }

    SetIoErr(error);

    /* kludge to keep old sw running. Turns out old versions of ASL were
     * returning the file name in D0 instead of a BOOL. We keep doing this...
     */
    if (result)
        return(fr->fr_File);

    return(NULL);
}


/*****************************************************************************/


VOID FreeFileRequest(struct ExtFileReq *fr)
{
    FreeMultiArgs(fr);
    FreeVec(fr);
}
@


38.34
log
@Added comment
@
text
@a176 2
#define	NUMGADGETS 14

a188 1

d2285 1
a2285 1
    if (store = fr->fr_Store = PrepareRequester(ri,AG,NUMGADGETS * sizeof(struct ASLGadget),sizeof(struct FRStore)))
@


38.33
log
@Made directories highlight when you move around using the cursor keys in a 
directory listing
@
text
@d616 1
a616 1
    return(result);
@


38.32
log
@User filters are now called for directories
@
text
@d1212 2
@


38.31
log
@Now uses ScrollWindowRaster() instead of ScrollRasterBF() to compensate for an
  Intuition bug
@
text
@d1734 4
@


38.30
log
@Fixed bug where LED would stay on when
  creating a new directory in save mode
@
text
@d16 1
d605 18
d630 1
d656 3
d661 4
a664 4
            ScrollRasterBF(&fr->fr_Store->rs_LVRPort,0,dy,
                           fr->fr_LVLeft,fr->fr_LVTop,
                           fr->fr_LVLeft+fr->fr_LVWidth-1,
                           fr->fr_LVTop+fr->fr_ItemHeight*fr->fr_VisibleItems-1);
d667 2
d855 6
a860 9
        if (GfxBase->LibNode.lib_Version >= 39)
        {
            SetMaxPen(&fr->fr_Store->rs_LVRPort,GetMax(fr,TEXTPEN,
                                                          BACKGROUNDPEN,
                                                          HIGHLIGHTTEXTPEN,
                                                          FILLTEXTPEN,
                                                          FILLPEN,
                                                          -1));
        }
@


38.29
log
@Removed more V37 code
@
text
@d1630 1
@


38.28
log
@Removed from V37 support code
Fixed rendering of selected items so it always works
@
text
@a454 1
    Move(rp,x1,y);
d456 4
a459 1
        Text(rp,line,TextFit(rp,line,strlen(line),&extent,NULL,1,rect->MaxX-x1,32767));
a961 5
/* This function compensates for a bug in the V37 DOS ParsePatternNoCase()
 * It is not needed starting with V39 DOS and can mostly be replaced by a call
 * to ParsePatternNoCase(). Note that the check for result < 0 and related
 * actions are still needed though.
 */
d964 1
a964 12
WORD   len;
STRPTR str2;
LONG   result;

    len  = strlen(str);
    if (str2 = AllocVec(len+1,MEMF_ANY))
    {
        while (len >= 0)
        {
            str2[len] = ToUpper(str[len]);
            len--;
        }
a965 3
        str = str2;
    }

a966 2

    FreeVec(str2);
@


38.27
log
@Remove V37 support
@
text
@d410 1
a410 5
                         if (fr->fr_ReqInfo.ri_LocaleInfo.li_LocaleBase && fr->fr_ReqInfo.ri_LocaleInfo.li_LocaleBase->lb_SysPatches)
                             sprintf(line,"%lU",file->fe_Size);
                         else
                             sprintf(line,"%lu",file->fe_Size);

d455 1
a456 2
    {
        Move(rp,x1,y);
a457 1
    }
@


38.26
log
@Fixed multiselect
@
text
@d450 1
a450 2
    SetAPen(rp,frontPen);
    SetBPen(rp,backPen);
d640 8
a647 18
            if (GfxBase->LibNode.lib_Version >= 39)
            {
                LockLayerInfo(&fr->fr_ReqInfo.ri_Window->WScreen->LayerInfo);
                InstallLayerHook(fr->fr_ReqInfo.ri_Window->WLayer,LAYERS_NOBACKFILL);
                ScrollRasterBF(&fr->fr_Store->rs_LVRPort,0,dy,
                               fr->fr_LVLeft,fr->fr_LVTop,
                               fr->fr_LVLeft+fr->fr_LVWidth-1,
                               fr->fr_LVTop+fr->fr_ItemHeight*fr->fr_VisibleItems-1);
                InstallLayerHook(fr->fr_ReqInfo.ri_Window->WLayer,LAYERS_BACKFILL);
                UnlockLayerInfo(&fr->fr_ReqInfo.ri_Window->WScreen->LayerInfo);
            }
            else
            {
                ScrollRaster(&fr->fr_Store->rs_LVRPort,0,dy,
                             fr->fr_LVLeft,fr->fr_LVTop,
                             fr->fr_LVLeft+fr->fr_LVWidth-1,
                             fr->fr_LVTop+fr->fr_ItemHeight*fr->fr_VisibleItems-1);
            }
d831 1
a832 1
        SetFont(&fr->fr_Store->rs_LVRPort,defFont);
@


38.25
log
@Corrected memoration problem when allocated file nodes for the display list
Added call to PrepareLocale()
@
text
@d1281 2
d1286 2
a1287 2
        node = fr->fr_FileList.lh_Head;
        while (node)
d1301 1
a1301 1
            while (node)
d1320 1
a1320 1
                node = FindClosest(&fr->fr_FileList,fr->fr_FileString);
d1322 1
a1322 1
                if (!node || Stricmp(node->ln_Name,fr->fr_FileString) || (!node->ln_Selected))
d1325 1
a1325 1
                    if (!(fr->fr_ArgList[cnt].wa_Name = AllocVec(strlen(node->ln_Name)+1,MEMF_ANY)))
d1331 1
a1331 1
                    strcpy(fr->fr_ArgList[cnt].wa_Name,node->ln_Name);
@


38.24
log
@Now checks for failure of ParsePatternNoCase()
Now compensates for bug in V37 ParsePatternNoCase()
@
text
@d1770 1
a1770 1
                    if ((fr->fr_OldItemCnt < fr->fr_VisibleItems) || (firstBatch))
d1772 4
a1775 2
                        if (fr->fr_ItemCnt == 0)
                            tickCnt = 0;
d1777 9
a1785 2
                        InsertListEntry(fr,node);
                        if (tickCnt > 4)
d1787 2
a1788 3
                            tickCnt    = 0;
                            firstBatch = FALSE;
                            RenderLV(fr);
a1790 5
                    else
                    {
			AddTail((struct List *)&fr->fr_TempFileList,node);
                        fr->fr_TempItemCnt++;
                    }
d2296 1
@


38.23
log
@Multiselect mode now includes the name in the string gadget
Hitting a qualifier key while the File gadget is active no longer causes
  the file list to be reshuffled
Changed from using MEMF_PUBLIC to using MEMF_ANY
Entering a pattern in the File gadget is not treated as a pattern if there is
  no pattern gadget
Increased size of date buffer for bogus dates
@
text
@d977 37
d1016 1
a1016 1
    ParsePatternNoCase(fr->fr_Pattern,fr->fr_Store->rs_ParsedPattern,sizeof(fr->fr_Store->rs_ParsedPattern));
d1592 1
a1592 1
    ParsePatternNoCase("#?.(INFO|BACKDROP)",infoPat,sizeof(infoPat));
d1596 1
a1596 1
    if (ParsePatternNoCase(ptr,store->rs_TempPattern,sizeof(store->rs_TempPattern)))
d1981 1
a1981 1
                                                                  if (ParsePatternNoCase(ptr,store->rs_TempPattern,sizeof(store->rs_TempPattern)))
d2006 1
a2006 1
                                                                          &&  (ParsePatternNoCase(fr->fr_FileString,store->rs_ParsedPattern,sizeof(store->rs_ParsedPattern))))
d2047 1
a2047 1
                                                                          &&  (ParsePatternNoCase(fr->fr_FileString,store->rs_ParsedPattern,sizeof(store->rs_ParsedPattern))))
a2384 8
}


/*****************************************************************************/


VOID FlushFileCaches(VOID)
{
@


38.22
log
@Fixed handling of cursor keys in volume list
@
text
@d362 2
a363 2
char                line[80];
char                date[80];
d542 1
a542 1
                if (volume->ve_DeviceName = AllocVec((ULONG)name[0]+3,MEMF_CLEAR|MEMF_PUBLIC))
d1081 1
a1081 1
    if (buffer = AllocVec(len,MEMF_PUBLIC))
d1255 2
a1256 1
        if (cnt && (fr->fr_ArgList = AllocVec(sizeof(struct WBArg)*cnt,MEMF_CLEAR|MEMF_PUBLIC)))
d1267 1
a1267 1
                    if (!(fr->fr_ArgList[cnt].wa_Name = AllocVec(strlen(node->ln_Name)+1,MEMF_PUBLIC)))
d1278 17
d2009 2
a2010 1
                                                                          if (ParsePatternNoCase(fr->fr_FileString,store->rs_ParsedPattern,sizeof(store->rs_ParsedPattern)))
d2188 1
a2188 1
    else
d2207 1
a2207 1
    if (fr = AllocVec(sizeof(struct ExtFileReq),MEMF_CLEAR|MEMF_PUBLIC))
@


38.21
log
@Now uses the screen font for the font list if the font is monospaced. If not,
  it falls back to the system default font.
@
text
@d366 1
d405 1
d429 3
d436 2
a437 2
                         if (!(name = volume->ve_DeviceName))
                             name = GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_VOLUME);
d439 1
a439 1
                         sizeLen = strlen(name);
d444 1
a444 1
                         sprintf(line,"%s  %s",name,volSize);
d456 1
a456 1
    Text(rp,entry->ln_Name,TextFit(rp,entry->ln_Name,strlen(entry->ln_Name),&extent,NULL,1,rect->MaxX-rect->MinX-3,32767));
d522 1
a522 1
            if (assign = AllocNode(sizeof(struct AssignEntry) + (ULONG)name[0] + 3))
a527 1
                strcat(assign->ae_Link.ln_Name,":");
d1181 1
a1181 2
            if (entry->ln_Type == VOLUMETYPE)
            {
a1182 1
            }
d1192 1
a1192 1
	else if (entry->ln_Type == VOLUMETYPE)
d1327 1
d1353 11
a1363 3
            if (len = strlen(fr->fr_FileString))
                if (fr->fr_FileString[len-1] == '/')
                    fr->fr_FileString[len-1] = 0;
d1365 3
a1367 2
            if (!(node = FindClosest(&fr->fr_FileList,fr->fr_FileString)))
                node = fr->fr_FileList.lh_TailPred;
d1374 1
a1374 1
            if (Stricmp(node->ln_Name,fr->fr_FileString))
a1379 1

@


38.20
log
@Fixed incorrect display update after deleting a file
@
text
@d819 3
a821 1
        defFont = GfxBase->DefaultFont;
@


38.19
log
@The M-space is correctly recalculated on every window resizing which fixes problems
  with the LED sometimes being rendered with the wrong size
@
text
@d219 1
a219 1
    fr->fr_FirstRender  = TRUE;
d689 1
a689 1
    if (!fr->fr_DisplayValid && (start < fr->fr_VisibleItems) && (fr->fr_FirstRender))
d701 1
a701 1
        fr->fr_FirstRender = FALSE;
d1104 1
@


38.18
log
@*** empty log message ***
@
text
@d855 3
a2260 2
                fr->fr_MSpace = TextLength(ri->ri_Window->RPort,"m",1);

@


38.17
log
@Now accepts a pattern in the Drawer gadget even if there is no pattern gadget
@
text
@d1518 1
a1518 3
    mask = (1L<<store->rs_PacketPort.mp_SigBit);
    if (fr->fr_AppPort)
        mask |= (1L<<fr->fr_AppPort->mp_SigBit);
d1731 1
a1731 1
        if (fr->fr_AppPort)
d1733 7
a1739 3
            while (appMsg = (struct AppMessage *)GetMsg(fr->fr_AppPort))
            {
                ActivateWindow(ri->ri_Window);
d1741 1
a1741 1
                if (appMsg->am_NumArgs)
d1743 2
a1744 9
                    NameFromLock(appMsg->am_ArgList->wa_Lock,fr->fr_DrawerString,sizeof(fr->fr_DrawerString));
                    SetStrValue(fr,DRAWERGAD,fr->fr_DrawerString);
                    getDir = TRUE;

                    if ((appMsg->am_ArgList->wa_Name) && (strlen(appMsg->am_ArgList->wa_Name) > 0))
                    {
                        strcpy(fr->fr_FileString,appMsg->am_ArgList->wa_Name);
                        SetStrValue(fr,FILEGAD,fr->fr_FileString);
                    }
d1746 1
d1748 1
a1748 2
                ReplyMsg((struct Message *)appMsg);
            }
d2240 5
d2251 1
a2251 4
            fr->fr_ZoomOnFileSig = -1;
            if (fr->fr_AppPort = CreateMsgPort())
            {
                fr->fr_ZoomOnFileSig = fr->fr_AppPort->mp_SigBit;
d2253 2
a2254 3
                if (asl->ASL_WorkbenchBase = OpenLibrary("workbench.library",37))
                    fr->fr_AppWindow = AddAppWindowA(0,0,ri->ri_Window,fr->fr_AppPort,NULL);
            }
d2276 1
a2276 1
                while (msg = GetMsg(fr->fr_AppPort))
a2278 1
            DeleteMsgPort(fr->fr_AppPort);
d2280 3
@


38.16
log
@Removed kludge code for broken 39.46 Kickstart
@
text
@d197 1
a197 1
VOID InitFileList(struct ExtFileReq *fr)
d226 1
a226 1
VOID InsertListEntry(struct ExtFileReq *fr, struct Node *newEntry)
d273 1
a273 1
VOID RemoveListEntry(struct ExtFileReq *fr, STRPTR name)
d292 1
a292 1
VOID ConvDate(struct DateStamp *ds, STRPTR string)
d320 2
a321 2
VOID ConvVolumeData(struct ExtFileReq *fr, ULONG blocksUsed, ULONG numBlocks,
                    ULONG bytesPerBlock, STRPTR string)
d356 1
a356 1
VOID RenderEntry(struct ExtFileReq *fr, struct Node *entry, struct Rectangle *rect)
d476 1
a476 1
VOID CreateVolumeList(struct ExtFileReq *fr)
d561 1
a561 1
VOID ReducePath(STRPTR path)
d605 1
a605 1
VOID RenderLV(struct ExtFileReq *fr)
d713 1
a713 1
VOID DoFRGadgets(struct ExtFileReq *fr)
d752 1
a752 1
VOID LimitTopItem(struct ExtFileReq *fr)
d771 1
a771 1
WORD GetMax(struct ExtFileReq *fr, LONG pen, ...)
d795 1
a795 1
BOOL CreateFRGadgets(struct ExtFileReq *fr)
d865 1
a865 1
VOID RenderFRDisplay(struct ExtFileReq *fr)
d910 1
a910 1
VOID SetStrValue(struct ExtFileReq *fr, WORD id, STRPTR text)
d920 1
a920 1
VOID ActivateGad(struct ExtFileReq *fr, UWORD currentGad, UWORD quals)
d968 1
a968 1
VOID ParsePat(struct ExtFileReq *fr)
d977 1
a977 1
VOID FRPreserve(struct ExtFileReq *fr)
d988 1
a988 1
VOID FRRestore(struct ExtFileReq *fr)
d1000 1
a1000 1
VOID InsertList(struct ExtFileReq *fr)
d1020 1
a1020 1
BOOL MakeDrawer(struct ExtFileReq *fr)
d1062 1
a1062 1
BOOL DeleteFiles(struct ExtFileReq *fr)
d1138 2
a1139 2
BOOL SelectEntry(struct ExtFileReq *fr, struct Node *entry, UWORD quals,
                 BOOL clickedOn)
d1200 1
a1200 1
VOID FreeMultiArgs(struct ExtFileReq *fr)
d1218 1
a1218 1
BOOL QuitFR(struct ExtFileReq *fr, BOOL cancelled, BPTR dirLock)
d1287 1
a1287 1
BOOL UserFilters(struct ExtFileReq *fr)
d1309 2
a1310 2
VOID CursorSelect(struct ExtFileReq *fr, struct Gadget *gadget,
                  UWORD icode, UWORD quals)
d1408 1
a1408 1
VOID DriveLight(struct ExtFileReq *fr, UWORD pen)
d1424 1
a1424 1
VOID ActivateMajorGuy(struct ExtFileReq *fr)
d1436 1
a1436 1
BOOL DoParent(struct ExtFileReq *fr)
d1470 1
a1470 1
BOOL HandleFRIDCMP(struct ExtFileReq *fr)
d1505 1
d1507 10
a1516 9
    ri         = &fr->fr_ReqInfo;
    volumes    = FALSE;
    getDir     = TRUE;
    getVolumes = FALSE;
    lock       = NULL;
    newsize    = FALSE;
    store      = fr->fr_Store;
    fib        = &store->rs_AC.an_Info;
    packet     = &store->rs_StdPkt;
a1521 1

d1525 8
d1545 4
d1673 1
d1913 12
a1924 1
                                                                  SetStrValue(fr, DRAWERGAD, fr->fr_DrawerString);
d1981 1
a1981 1
                                                                              SetStrValue(fr, PATTERNGAD, fr->fr_FileString);
d1983 1
a1983 1
                                                                              SetStrValue(fr, FILEGAD, "");
d2056 1
a2056 1
VOID ProcessFRTags(struct ExtFileReq *fr, struct TagItem *tagList)
d2125 3
a2127 3
ULONG ASM EditHook(REG(a0) struct Hook *hook,
                   REG(a2) struct SGWork *sgw,
                   REG(a1) ULONG *msg)
d2251 4
a2254 1
            fr->fr_ZoomOnFileSig = AllocSignal(-1);
a2255 1
            if (fr->fr_AppPort = CreateMsgPort())
d2258 1
a2273 3

            if (fr->fr_ZoomOnFileSig >= 0)
                FreeSignal(fr->fr_ZoomOnFileSig);
@


38.15
log
@Now uses ScrollRasterBF() and SetMaxPen() under V39 for better looking and
faster scrolling list.

Reenabled optimal list view refreshing code. I disabled it a few revs
back for testing and forgot to turn it back on. No wonder things seemed
sluggish.

Fixed bug with file deletion leaving scroller in an illegal state
(it wasn't getting told that the number of items had changed)
@
text
@a603 6
VOID Blah(VOID)
{
}

struct Hook hk;

d637 1
a637 2
            if ((GfxBase->LibNode.lib_Version > 39)
            ||  ((GfxBase->LibNode.lib_Version == 39) && (GfxBase->LibNode.lib_Revision > 39)))
a638 1
                hk.h_Entry = (APTR)Blah;
d640 1
a640 1
                InstallLayerHook(fr->fr_ReqInfo.ri_Window->WLayer,&hk);
@


38.14
log
@Fixed crash on memory allocation failure

Fixed problem with trying to access the menus after clicking on a file
once. The window was being left in RMBTRAP state.

Fixed enforcer hits when there was not enough signal bits to allocate
the app window port

The second column in the file requester is now sized dynamically based
on the string length of the longest string to display in that column.
This means there is usually less empty space in the requester and more
information is visible.

Fixed bug where it was passing a BSTR to the file requester filtering
functions instead of a regular C string

Does better pen selections in Save mode for file requester list view
@
text
@d32 1
d43 1
d191 3
d215 1
d290 2
d299 1
a299 1
    dt.dat_Format  = FORMAT_DOS;
d604 6
d643 20
a662 4
            ScrollRaster(&fr->fr_Store->rs_LVRPort,0,dy,
                         fr->fr_LVLeft,fr->fr_LVTop,
                         fr->fr_LVLeft+fr->fr_LVWidth-1,
                         fr->fr_LVTop+fr->fr_ItemHeight*fr->fr_VisibleItems-1);
d713 1
d779 24
d826 1
a826 1
        di      = fr->fr_ReqInfo.ri_DrawInfo;
d847 10
d901 1
a901 1
    fr->fr_LightHeight = dgad->Height-4;
d903 10
a912 7
    AslDrawBevelBox(fr->fr_ReqInfo.ri_Window,fr->fr_LightLeft-fr->fr_ReqInfo.ri_Window->BorderLeft,
                                             fr->fr_LightTop-fr->fr_ReqInfo.ri_Window->BorderTop,
                                             fr->fr_LightWidth,fr->fr_LightHeight,
                                             GT_VisualInfo, fr->fr_ReqInfo.ri_VisualInfo,
                                             GTBB_Recessed, TRUE,
                                             TAG_DONE);
}
a1011 3
    while (node = RemHead((struct List *)&fr->fr_TempFileList))
	InsertListEntry(fr,node);

d1014 1
a1014 2
        fr->fr_TempItemCnt = 0;
        SetGadgetAttr(&fr->fr_ReqInfo,SCROLLERGAD,GTSC_Total,fr->fr_ItemCnt,
d1017 1
d1019 3
d1132 1
d1134 3
d1418 9
a1426 6
    SetAPen(fr->fr_ReqInfo.ri_Window->RPort,fr->fr_ReqInfo.ri_DrawInfo->dri_Pens[pen]);
    RectFill(fr->fr_ReqInfo.ri_Window->RPort,fr->fr_LightLeft+2,
                                             fr->fr_LightTop+1,
                                             fr->fr_LightLeft+fr->fr_LightWidth-3,
                                             fr->fr_LightTop+fr->fr_LightHeight-2);
}
d1622 2
d1638 2
d1694 1
a1694 1
                    if ((fr->fr_ItemCnt < fr->fr_VisibleItems) || (firstBatch))
d1700 1
a1700 1
                        if ((tickCnt > 4) || (fr->fr_ItemCnt == fr->fr_VisibleItems))
@


38.13
log
@Second column in volume list is generally not as pushed off to the right
as in previous versions, making more of the volume information visible.

Now clears the list view and resets the prop gadget as soon as a new
directory is loaded, instead of after completing the Examine() call
on the directory. This makes things look better on slow devices.

Added "drive LED" simulation. The light turns on whenever a directory is
in the process of being loaded and turns off when the directory is
completely loaded.

Clicking the middle mouse button when neither shift or alt keys are held
down brings up the volume list.

Selecting any menu item, clicking in the list view, on the Volumes gadget
or the Parent gadgets now activates the File gadget (or Drawer gadget if
in directory-only mode)

Selecting Parent will no longer put excessive / at the end of the
Drawer string whenever the root of the current FS has been reached

Using the up/down cursor keys in the File gadget now handles
works consistently. ALT-Cursor brings you to the top/bottom of the file
list, SHIFT-Cursor moves you by one viewful, and the cursor keys by
themselves move you one item at a time

Typing text in the File gadget now causes the list view to resync
and display files which start by the same letter

Fixed bug where it would sometimes not completely fill in the listview
until the directory scan was complete. This was mostly noticeable on
floppies.

Fixed hanging bug when attempting to display the volume list when a
volume had some locks on it but was not currently mounted (was sending
a packet to a NULL dol_Task field!).

Fixed memory loss when deleting files

Fixed scrolling list confusion after deleting a file

Fixed list view refreshing bug when a DOS requester was opened

Fixed bug in directory path reduction code which was reading one byte
past the start of an allocation

Fixed bug where repeated up/down cursor keys would eventually deactivate
the File string gadget
@
text
@d206 2
a207 1
    fr->fr_MaxNameLen   = 15;
d222 4
a225 1
UWORD nameLen;
d234 26
d362 2
d370 4
d395 1
d401 1
a401 1
                             sprintf(line,"%8lU  %s",file->fe_Size,date);
d403 5
a407 1
                             sprintf(line,"%8lu  %s",file->fe_Size,date);
d412 3
a414 1
                         sprintf(line,"%s  %s",GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_DRAWER),date);
d418 1
d426 1
d431 1
a431 1
                         sprintf(line,"%-10.10s %s",name,volSize);
d446 1
a446 1
    x1 = rect->MinX+2+(fr->fr_MaxNameLen+2)*rp->TxWidth;
d475 1
d479 4
d780 1
a780 1
        fr->fr_Store->rs_LVRPort      = *fr->fr_ReqInfo.ri_Window->RPort;
a1229 1
         fr->fr_Store->rs_AC.an_Info = fr->fr_Store->rs_AP.ap_Info;
d1233 1
a1233 1
    if (result)
d1235 1
a1235 1
         result = (!fr->fr_FilterFunc) || CallHookPkt(fr->fr_FilterFunc,PUBLIC_FR(fr),&fr->fr_Store->rs_AP);
d1437 1
d1446 1
a1446 1
    fib        = &store->rs_AP.ap_Info;
d1449 5
a1494 1
                    store->rs_AC.an_Lock = lock;
d1502 1
d1564 1
a1564 2
        intuiMsg = GetReqMsg(ri,PUBLIC_FR(fr),NULL,
			     ((1L<<store->rs_PacketPort.mp_SigBit) | (1L<<fr->fr_AppPort->mp_SigBit)));
d1575 1
a1575 4
                BtoC(store->rs_AP.ap_Info.fib_FileName,store->rs_FIBFileName);
                store->rs_FIBDirEntryType = fib->fib_DirEntryType;
                store->rs_FIBSize         = fib->fib_Size;
                store->rs_FIBDate         = fib->fib_Date;
d1579 2
d1582 1
a1582 1
                if ((store->rs_FIBDirEntryType < 0) || (FRF_FILTERDRAWERS & fr->fr_Options2))
d1584 4
a1587 4
                    accept = (((store->rs_FIBDirEntryType > 0) || (!(FRF_DRAWERSONLY & fr->fr_Options2)))
                             && (!(FRF_REJECTICONS & fr->fr_Options2) || !MatchPatternNoCase(infoPat,store->rs_FIBFileName))
                             && (!fr->fr_AcceptPattern || MatchPatternNoCase(fr->fr_AcceptPattern,store->rs_FIBFileName))
                             && (!fr->fr_RejectPattern || !MatchPatternNoCase(fr->fr_RejectPattern,store->rs_FIBFileName))
d1589 1
a1589 1
                             && (!store->rs_ParsedPattern[0] || MatchPatternNoCase(store->rs_ParsedPattern,store->rs_FIBFileName)));
d1594 2
a1595 1
                    if (store->rs_FIBDirEntryType > 0)
d1597 1
a1597 1
                        if (dir = AllocNamedNode2(sizeof(struct DirEntry),DIRTYPE,store->rs_FIBFileName))
d1600 1
a1600 1
                            dir->de_Date = store->rs_FIBDate;
d1606 1
a1606 1
                        if (file = AllocNamedNode2(sizeof(struct FileEntry),FILETYPE,store->rs_FIBFileName))
d1609 2
a1610 2
                            file->fe_Date = store->rs_FIBDate;
                            file->fe_Size = store->rs_FIBSize;
a1613 1
                }
a1614 2
                if (accept)
                {
d1743 2
a1809 2

                                                                  ActivateMajorGuy(fr);
d2143 1
a2143 1
        process                                = (struct Process *)FindTask(NULL);
@


38.12
log
@No longer modifies the FIB used in the packet IO
Has much less packet turn around time, thus improving throughput
@
text
@d63 2
a64 3
#define FILETYPE   0
#define DIRTYPE    1
#define ASSIGNTYPE 2
d66 1
d137 1
a137 1
      {NM_ITEM, FR_NOP,      NM_BARLABEL},
d142 1
a142 1
      {NM_ITEM, FR_NOP,      NM_BARLABEL},
d146 1
a146 1
    {NM_END,    FR_NOP,	     NM_BARLABEL}
d221 1
a221 3
struct Node        *node;
struct VolumeEntry *volume;
UWORD               nameLen;
d224 1
d230 10
a239 2
    node = fr->fr_FileList.lh_Head;
    volume = (struct VolumeEntry *) newEntry;
d241 1
a241 1
    if ((newEntry->ln_Type == VOLUMETYPE) && (!volume->ve_DeviceName))
d243 4
a246 23
        volume = (struct VolumeEntry *) node;
        while (node->ln_Succ && (node->ln_Type == VOLUMETYPE) && volume->ve_DeviceName)
        {
	    node = node->ln_Succ;
            volume = (struct VolumeEntry *) node;
        }
    }

    if ((newEntry->ln_Type == DIRTYPE) || (newEntry->ln_Type == ASSIGNTYPE))
    {
        while (node->ln_Succ && ((node->ln_Type == FILETYPE) || (node->ln_Type == VOLUMETYPE)))
        {
	    node = node->ln_Succ;
        }
    }

    while (node->ln_Succ)
    {
        if ((Stricmp(node->ln_Name, newEntry->ln_Name) > 0) ||
            ((newEntry->ln_Type == FILETYPE) || (newEntry->ln_Type == VOLUMETYPE)) &&
            ((node->ln_Type == DIRTYPE) || (node->ln_Type == ASSIGNTYPE)))
	    break;
        node = node->ln_Succ;
a247 1
    Insert(&fr->fr_FileList,newEntry,node->ln_Pred);
a332 5
    rp     = &fr->fr_Store->rs_LVRPort;
    file   = (struct FileEntry *)entry;
    dir    = (struct DirEntry *)entry;
    volume = (struct VolumeEntry *)entry;

d361 2
a362 1
        case FILETYPE  : ConvDate(&file->fe_Date,date);
d369 2
a370 1
        case DIRTYPE   : ConvDate(&dir->de_Date,date);
d377 2
a378 1
        case VOLUMETYPE: ConvVolumeData(fr,volume->ve_BlocksUsed,volume->ve_NumBlocks,volume->ve_BytesPerBlock,volSize);
d381 5
d390 2
d428 1
a428 1
struct VolumeEntry *hold;
d432 3
a434 1
    hold = NULL;
d442 1
a442 1
            if (volume = AllocNamedNode(sizeof(struct VolumeEntry),&name[1]))
d444 1
a444 3
                volume->ve_Link.ln_Type = VOLUMETYPE;

                if (DoPkt1(dl->dol_Task,ACTION_DISK_INFO,(ULONG)id >> 2))
d446 1
d451 1
a451 6
                    volume->ve_Link.ln_Succ  = (struct Node *)hold;
                    hold                     = volume;
                }
                else
                {
                    FreeVec(volume);
d459 1
a459 1
            if (assign = AllocNode(sizeof(struct AssignEntry) + (ULONG)name[0] + 2))
d461 3
a463 2
                assign->ae_Link.ln_Name = (STRPTR)((ULONG)assign + sizeof(struct AssignEntry));
                assign->ae_Link.ln_Type = ASSIGNTYPE;
d474 2
a475 2
        volume = (struct VolumeEntry *)hold;
        while (volume)
d477 1
a477 1
            if (volume->ve_HandlerTask == dl->dol_Task)
d495 2
a496 6
    while (hold)
    {
        volume = (struct VolumeEntry *)hold->ve_Link.ln_Succ;
        InsertListEntry(fr,(struct Node *)hold);
        hold = volume;
    }
a513 2
        else if ((path[len-1] == '/') && (path[len-2] == '/') && (path[len-3] == ':'))
            path[--len] = 0;
d575 1
a575 1
                start = fr->fr_VisibleItems-scrCnt-1;
d679 19
d742 1
a742 11
        if (fr->fr_TopItem + fr->fr_VisibleItems > fr->fr_ItemCnt)
        {
            if (fr->fr_ItemCnt > fr->fr_VisibleItems)
            {
                fr->fr_TopItem = fr->fr_ItemCnt - fr->fr_VisibleItems;
            }
            else
            {
                fr->fr_TopItem = 0;
            }
        }
d761 1
d780 15
a794 1
}
d894 1
a894 1
    while (node = RemHead(&fr->fr_TempFileList))
d899 1
a899 3
        fr->fr_TempItemCnt  = 0;
        fr->fr_DisplayValid = FALSE;

d954 1
a954 1
BOOL              getdir = FALSE;
a955 1
struct Node      *node;
d958 2
a959 1
LONG		  ofs;
d961 2
a962 3
    ofs = strlen (fr->fr_DrawerString) + strlen (fr->fr_FileString) + 10;
    len = ofs + ofs + 1;
    if (buffer = AllocMem (len, MEMF_CLEAR))
d964 2
a965 2
	strcpy (buffer, fr->fr_DrawerString);
	AddPart (buffer, fr->fr_FileString, len);
d974 1
a974 1
        if (EasyRequestArgs(fr->fr_ReqInfo.ri_Window, &est, NULL, &buffer))
d976 1
a976 2
	    strcpy (&buffer[ofs], FilePart (buffer));
            if (DeleteFile (buffer))
d978 3
a980 3
		if (node = FindNameNC (&fr->fr_FileList, &buffer[ofs]))
		    Remove (node);
                if (DeleteDiskObject (buffer))
d982 2
a983 3
                    strcat (&buffer[ofs], ".info");
                    if (node = FindNameNC (&fr->fr_FileList, &buffer[ofs]))
                        Remove (node);
d986 1
a986 1
                if (strlen (fr->fr_FileString))
d989 1
a989 1
                    SetStrValue(fr,FILEGAD,fr->fr_FileString);
a990 1
		    RenderLV (fr);
d1002 1
a1002 1
                    getdir = TRUE;
d1006 3
a1008 1
		DisplayBeep (NULL);
d1010 2
a1011 1
	FreeMem (buffer, len);
d1013 4
a1016 1
    return (getdir);
d1144 1
a1144 1
                    if (!(fr->fr_ArgList[cnt].wa_Name = AllocVec(strlen(node->ln_Name)+1,MEMF_CLEAR|MEMF_PUBLIC)))
d1150 1
a1150 1
                    strcat(fr->fr_ArgList[cnt].wa_Name,node->ln_Name);
d1204 2
d1231 4
d1238 4
d1249 2
a1250 1
                if (node != fr->fr_FileList.lh_Head)
d1254 1
d1259 1
a1259 1
                if (node != fr->fr_FileList.lh_TailPred)
d1263 1
d1295 59
a1369 1
UWORD                  len;
d1402 1
a1402 8
    if (FRF_DRAWERSONLY & fr->fr_Options2)
    {
        ActivateGadget(ri->ri_Template[DRAWERGAD].ag_Gadget,ri->ri_Window,NULL);
    }
    else
    {
        ActivateGadget(ri->ri_Template[FILEGAD].ag_Gadget,ri->ri_Window,NULL);
    }
d1416 11
d1475 9
a1486 7

            RenderLV(fr);
            SetGadgetAttr(ri,SCROLLERGAD,
                          GTSC_Visible, fr->fr_VisibleItems,
                          GTSC_Total,   fr->fr_ItemCnt,
                          GTSC_Top,     0,
                          TAG_DONE);
d1500 3
d1543 1
a1543 1
                        if (dir = AllocNamedNode(sizeof(struct DirEntry),store->rs_FIBFileName))
d1552 1
a1552 1
                        if (file = AllocNamedNode(sizeof(struct FileEntry),store->rs_FIBFileName))
d1570 1
a1570 2
                        fr->fr_DisplayValid = FALSE;
                        if (tickCnt > 4)
d1579 1
a1579 1
			AddTail(&fr->fr_TempFileList,node);
d1589 2
a1590 3
                SetGadgetAttr(ri,SCROLLERGAD,
                              GTSC_Total,fr->fr_ItemCnt+fr->fr_TempItemCnt,
                              TAG_DONE);
d1592 2
a1593 2
                if (!fr->fr_DisplayValid)
                    RenderLV(fr);
d1645 1
a1645 4
                case IDCMP_ACTIVEWINDOW : if (FRF_DRAWERSONLY & fr->fr_Options2)
                                              ActivateGadget(ri->ri_Template[DRAWERGAD].ag_Gadget,ri->ri_Window,NULL);
                                          else
                                              ActivateGadget(ri->ri_Template[FILEGAD].ag_Gadget,ri->ri_Window,NULL);
d1665 2
a1666 9
                                                  case FR_PARENT  : len = strlen(fr->fr_DrawerString);
                                                                    if ((len == 0) || (fr->fr_DrawerString[len-1] == '/') || (fr->fr_DrawerString[len-1] == ':'))
                                                                        strcat(fr->fr_DrawerString,"/");
                                                                    else
                                                                        strcat(fr->fr_DrawerString,"//");

                                                                    ReducePath(fr->fr_DrawerString);
                                                                    SetStrValue(fr,DRAWERGAD,fr->fr_DrawerString);
                                                                    getDir = TRUE;
d1673 1
a1673 4
                                                  case FR_DELETE  : if (getDir = DeleteFiles(fr))
								    {
                                                                        SetStrValue(fr,FILEGAD,"");
								    }
d1686 1
d1706 5
d1757 2
d1761 3
a1763 9
                                              case FR_PARENT    : len = strlen(fr->fr_DrawerString);
                                                                  if ((len == 0) || (fr->fr_DrawerString[len-1] == '/') || (fr->fr_DrawerString[len-1] == ':'))
                                                                      strcat(fr->fr_DrawerString,"/");
                                                                  else
                                                                      strcat(fr->fr_DrawerString,"//");

                                                                  ReducePath(fr->fr_DrawerString);
                                                                  SetStrValue(fr,DRAWERGAD,fr->fr_DrawerString);
                                                                  getDir = TRUE;
d1768 1
d1868 20
d1892 2
d1976 2
d1982 3
d1995 3
a1997 1
            case KEYCODE_X: break;
d2010 5
d2019 1
d2021 1
d2029 1
a2029 1
    if (fr = AllocVec(sizeof(struct ExtFileReq), MEMF_CLEAR | MEMF_PUBLIC))
d2032 1
a2032 1
	NewList(&fr->fr_TempFileList);
d2040 1
a2040 1
        fr->fr_ReqInfo.ri_IDCMPFlags  = IDCMP_MENUPICK | IDCMP_REFRESHWINDOW | IDCMP_CLOSEWINDOW | IDCMP_INTUITICKS | IDCMP_NEWSIZE | IDCMP_RAWKEY | IDCMP_ACTIVEWINDOW | IDCMP_MOUSEBUTTONS | IDCMP_DISKINSERTED | IDCMP_DISKREMOVED | SCROLLERIDCMP | BUTTONIDCMP;
d2104 2
d2112 2
d2124 3
@


38.11
log
@Removed excessive calls to RectFill() when first displaying a
directory. In a file requester with 20 items displayed, that can mean up
to 200 less moderately large RectFills.

Substantually faster directory reading scheme when reading a fast HD
or RAM:. The requester now tries to read as many files as possible in .5
seconds. If the time out expires, or all files have been read, the display
is updated for the first time. On the average, most directories on a HD
can be read during the time out period. The result is much less rendering,
and much faster total loading time.

It is now possible to cancel a selection by clicking on it with the left
mouse button, and while the button is still down, clicking the right one.
This matches the behavior of Workbench and other system things.

No longer asks you to create a directory when entering a name ending in :
in the drawer gadget.

No longer asks you to create a directory when it is incapable of scanning a
directory because of an ERROR_ACTION_NOT_KNOWN error. This is to avoid
stuff like PIPE: causing silly requesters to be brought up.

Pressing RETURN in the File gadget while it is empty no longer signifies
Cancel. This is for compatibility (unfortunately) with V37.

An empty pattern string is now considered equivalent to "#?" for
compatibility with V37.

In the volume list, no longer puts a colon after the name of devices, and
uses parenthesis to surround the name instead of angled brackets. That is,
you get (DF0), not <DF0:>

Will now update the volume list whenever a volume is inserted or
removed

Fixed potentially damaging memory allocation bug. Was allocating a string
like if it was a BCPL string, taking the length from byte 0 even if
it was regular C string.

Fixed bug introduced in last version where clicking one item below the last
one, selected a non-existant item.

Fixed bug with double-click not working consistently. If you clicked
on a file just once, then trying to double-click on it later did not
work.

Fixed bug with not emptying its AppWindow port before deleting it.

Entering a pattern in the file gadget now updates the pattern gadget
correctly. It was using the pattern, but never updating the pattern gadget.

Entering a pattern in the file gadget normally copies any pattern to the
Pattern gadget automatically. This was being done even if there was no
pattern gadget. The result was the patterns were being applied, but could
not be viewed.

When displaying the list of volumes, the word "Assign" is now correctly
taken from the current catalog instead of being hardcoded.
@
text
@d1304 1
d1317 3
a1319 2
    fib        = &fr->fr_Store->rs_AP.ap_Info;
    packet     = &fr->fr_Store->rs_StdPkt;
d1347 2
a1348 2
                WaitPort(&fr->fr_Store->rs_PacketPort);   /* wait for packet return */
                GetMsg(&fr->fr_Store->rs_PacketPort);     /* get packet out of port */
d1358 1
a1358 1
                    fr->fr_Store->rs_AC.an_Lock = lock;
d1365 1
a1365 1
                        SendPkt(&packet->sp_Pkt,lockPtr->fl_Task,&fr->fr_Store->rs_PacketPort);
d1423 1
a1423 1
			     ((1L<<fr->fr_Store->rs_PacketPort.mp_SigBit) | (1L<<fr->fr_AppPort->mp_SigBit)));
d1425 1
a1425 1
        if (GetMsg(&fr->fr_Store->rs_PacketPort))
d1434 7
d1442 1
a1442 2
                sprintf(fr->fr_Store->rs_AP.ap_Info.fib_FileName,"%b",(STRPTR)((ULONG)fr->fr_Store->rs_AP.ap_Info.fib_FileName / 4));
                if ((fib->fib_DirEntryType < 0) || (FRF_FILTERDRAWERS & fr->fr_Options2))
d1444 4
a1447 4
                    accept = (((fib->fib_DirEntryType > 0) || (!(FRF_DRAWERSONLY & fr->fr_Options2)))
                             && (!(FRF_REJECTICONS & fr->fr_Options2) || !MatchPatternNoCase(infoPat,fib->fib_FileName))
                             && (!fr->fr_AcceptPattern || MatchPatternNoCase(fr->fr_AcceptPattern,fib->fib_FileName))
                             && (!fr->fr_RejectPattern || !MatchPatternNoCase(fr->fr_RejectPattern,fib->fib_FileName))
d1449 1
a1449 1
                             && (!fr->fr_Store->rs_ParsedPattern[0] || MatchPatternNoCase(fr->fr_Store->rs_ParsedPattern,fib->fib_FileName)));
d1454 1
a1454 1
                    if (fib->fib_DirEntryType > 0)
d1456 1
a1456 1
                        if (dir = AllocNamedNode(sizeof(struct DirEntry),fib->fib_FileName))
d1459 1
a1459 1
                            dir->de_Date = fib->fib_Date;
d1465 1
a1465 1
                        if (file = AllocNamedNode(sizeof(struct FileEntry),fib->fib_FileName))
d1468 2
a1469 2
                            file->fe_Date = fib->fib_Date;
                            file->fe_Size = fib->fib_Size;
a1474 2
                SendPkt(&packet->sp_Pkt,lockPtr->fl_Task,&fr->fr_Store->rs_PacketPort);

d1479 3
d1717 1
a1717 1
                                                                          &&  (ParsePatternNoCase(fr->fr_FileString,fr->fr_Store->rs_ParsedPattern,sizeof(fr->fr_Store->rs_ParsedPattern))))
d1757 1
a1757 1
                                                                          if (ParsePatternNoCase(fr->fr_FileString,fr->fr_Store->rs_ParsedPattern,sizeof(fr->fr_Store->rs_ParsedPattern)))
d1961 1
d1964 1
a1964 1
    if (fr->fr_Store = PrepareRequester(ri,AG,NUMGADGETS * sizeof(struct ASLGadget),sizeof(struct FRStore)))
d1982 4
a1985 4
        fr->fr_Store->rs_PacketPort.mp_Flags   = PA_SIGNAL;
        fr->fr_Store->rs_PacketPort.mp_SigTask = (struct Task *)process;
        fr->fr_Store->rs_PacketPort.mp_SigBit  = process->pr_MsgPort.mp_SigBit;
        NewList(&fr->fr_Store->rs_PacketPort.mp_MsgList);
d1987 3
a1989 3
        fr->fr_Store->rs_StdPkt.sp_Msg.mn_Node.ln_Name = (STRPTR)&fr->fr_Store->rs_StdPkt.sp_Pkt;
        fr->fr_Store->rs_StdPkt.sp_Pkt.dp_Link         = &fr->fr_Store->rs_StdPkt.sp_Msg;
        fr->fr_Store->rs_AP.ap_Current                 = &fr->fr_Store->rs_AC;
d2029 1
a2029 1
        CleanupRequester(ri,fr->fr_Store);
@


38.10
log
@cleaned up.
@
text
@a53 2
#define	DB(x)	;
#define	DL(x)	;
a54 2
/*****************************************************************************/

d62 1
d68 2
a69 12
struct ListEntry
{
#if 1
    struct Node       le_Node;
#else

    struct ListEntry *le_Next;  /* must be first field in structure! */
    UWORD             le_Type;
    BOOL	      le_Selected;
    STRPTR            le_Name;
#endif
};
d73 2
a74 1
    struct ListEntry fe_Link;
a75 1
    ULONG            fe_Prot;
d81 2
a82 1
    struct ListEntry de_Link;
a83 1
    ULONG            de_Prot;
d88 1
a88 1
    struct ListEntry ae_Link;
d93 8
a100 7
    struct ListEntry ve_Link;
    STRPTR           ve_DeviceName;
    ULONG            ve_BlocksUsed;
    ULONG            ve_NumBlocks;
    ULONG            ve_BytesPerBlock;
    struct MsgPort  *ve_HandlerTask;
};
d116 1
a116 1
#define FR_LASTNAME   3
d135 1
a135 1
      {NM_ITEM, FR_LASTNAME, MSG_ASL_CONTROL_LASTNAME},
d194 1
a194 4
struct ListEntry *node;
struct ListEntry *next;
struct List      *list;
ULONG             cnt;
d196 1
a196 2
    cnt = 2;
    while (cnt--)
d198 5
a202 4
        if (cnt)
            list = &fr->fr_FileList;
        else
            list = &fr->fr_TempFileList;
d204 1
a204 14
	if (list->lh_TailPred != (struct Node *) list)
	{
	    node = (struct ListEntry *) list->lh_Head;
            while (next = node->le_Node.ln_Succ)
            {
		Remove (&node->le_Node);
		if (node->le_Node.ln_Type == VOLUMETYPE)
		    FreeVec (((struct VolumeEntry *)node)->ve_DeviceName);
		FreeVec (node);
		node = next;
            }
	}
	NewList (list);
    }
d212 1
a212 1
    fr->fr_SelectedCnt  = 0;
d219 1
a219 1
VOID InsertListEntry(struct ExtFileReq *fr, struct ListEntry *newEntry)
d221 1
a221 1
struct ListEntry   *node;
d227 1
a227 1
    nameLen = strlen(newEntry->le_Node.ln_Name);
d234 1
a234 1
    if ((newEntry->le_Node.ln_Type == VOLUMETYPE) && (!volume->ve_DeviceName))
d237 1
a237 1
        while (node->le_Node.ln_Succ && (node->le_Node.ln_Type == VOLUMETYPE) && volume->ve_DeviceName)
d239 1
a239 1
	    node = node->le_Node.ln_Succ;
d244 1
a244 1
    if ((newEntry->le_Node.ln_Type == DIRTYPE) || (newEntry->le_Node.ln_Type == ASSIGNTYPE))
d246 1
a246 2
        while (node->le_Node.ln_Succ &&
	       ((node->le_Node.ln_Type == FILETYPE) || (node->le_Node.ln_Type == VOLUMETYPE)))
d248 5
a252 5
	    node = node->le_Node.ln_Succ;
        }
    }

    while (node->le_Node.ln_Succ)
d254 3
a256 3
        if ((Stricmp(node->le_Node.ln_Name, newEntry->le_Node.ln_Name) > 0) ||
            ((newEntry->le_Node.ln_Type == FILETYPE) || (newEntry->le_Node.ln_Type == VOLUMETYPE)) &&
            ((node->le_Node.ln_Type == DIRTYPE) || (node->le_Node.ln_Type == ASSIGNTYPE)))
d258 1
a258 1
        node  = node->le_Node.ln_Succ;
d260 1
a260 1
    Insert (&fr->fr_FileList, newEntry, node->le_Node.ln_Pred);
d263 1
d266 1
d331 1
a331 1
VOID RenderEntry(struct ExtFileReq *fr, struct ListEntry *entry, struct Rectangle *rect)
d344 1
d356 1
a356 1
        if (entry->le_Node.ln_Pri)
d367 1
a367 1
        if ((entry->le_Node.ln_Type == DIRTYPE) || (entry->le_Node.ln_Type == ASSIGNTYPE))
d370 1
a370 1
        if (entry->le_Node.ln_Pri)
d377 1
a377 1
    switch (entry->le_Node.ln_Type)
d390 1
a390 1
        case ASSIGNTYPE: sprintf(line,"Assign");
d403 4
a406 2
    Move(rp,rect->MinX+2,rect->MinY+(((rect->MaxY - rect->MinY + 1) - rp->TxHeight) / 2) + rp->TxBaseline + 1);
    Text(rp,entry->le_Node.ln_Name,TextFit(rp,entry->le_Node.ln_Name,strlen(entry->le_Node.ln_Name),&extent,NULL,1,rect->MaxX-rect->MinX-3,32767));
d410 5
a414 3
    Move(rp,x1,rect->MinY+(((rect->MaxY - rect->MinY + 1) - rp->TxHeight) / 2) + rp->TxBaseline + 1);
    if (rp->cp_x < rect->MaxX)
        Text(rp,line,TextFit(rp,line,strlen(line),&extent,NULL,1,rect->MaxX-rp->cp_x-3,32767));
d417 4
a420 3
    RectFill(rp,rect->MinX,rect->MinY,rect->MinX+1,rect->MaxY);
    if (x0 < x1-1)
    {
a421 2
        RectFill(rp,rect->MinX,rect->MinY,rect->MaxX,rect->MinY);
    }
d423 2
a424 4
    if (rp->cp_x < rect->MaxX)
    {
        RectFill(rp,rp->cp_x,rect->MinY,rect->MaxX,rect->MaxY);
    }
d448 1
a448 1
            if (volume = AllocNode(sizeof(struct VolumeEntry) + (ULONG)name[0] + 2))
d450 1
a450 3
                volume->ve_Link.le_Node.ln_Name = (STRPTR)((ULONG)volume + sizeof(struct VolumeEntry));
                volume->ve_Link.le_Node.ln_Type = VOLUMETYPE;
                CopyMem(&name[1],volume->ve_Link.le_Node.ln_Name,(ULONG)name[0]);
d458 1
a458 1
                    volume->ve_Link.le_Node.ln_Succ  = (struct ListEntry *)hold;
d461 4
d473 5
a477 5
                assign->ae_Link.le_Node.ln_Name = (STRPTR)((ULONG)assign + sizeof(struct AssignEntry));
                assign->ae_Link.le_Node.ln_Type = ASSIGNTYPE;
                CopyMem(&name[1],assign->ae_Link.le_Node.ln_Name,(ULONG)name[0]);
                strcat(assign->ae_Link.le_Node.ln_Name,":");
                InsertListEntry(fr,(struct ListEntry *)assign);
d491 1
a491 1
                if (volume->ve_DeviceName = AllocVec((ULONG)name[0]+4,MEMF_CLEAR|MEMF_PUBLIC))
d494 2
a495 2
                    strcat(volume->ve_DeviceName,":>");
                    volume->ve_DeviceName[0] = '<';
d499 1
a499 1
            volume = (struct VolumeEntry *)volume->ve_Link.le_Node.ln_Succ;
d508 2
a509 2
        volume = (struct VolumeEntry *)hold->ve_Link.le_Node.ln_Succ;
        InsertListEntry(fr,(struct ListEntry *)hold);
d569 1
a569 1
struct ListEntry *node;
a572 1
    end   = 0;
d596 4
a599 3
            ScrollRaster(&fr->fr_Store->rs_LVRPort,0,dy,fr->fr_LVLeft,fr->fr_LVTop,
                                              fr->fr_LVLeft+fr->fr_LVWidth-1,
                                              fr->fr_LVTop+fr->fr_ItemHeight*fr->fr_VisibleItems-1);
d606 4
d613 8
a620 2
    node = NULL;
    if (fr->fr_FileList.lh_TailPred != (struct Node *) &fr->fr_FileList)
d622 10
a631 3
	node = fr->fr_FileList.lh_Head;
	while (i-- && node->le_Node.ln_Succ)
	    node = node->le_Node.ln_Succ;
d634 1
a634 1
    while (start < end)
d636 2
a637 9
        if (node && node->le_Node.ln_Succ)
        {
            rect.MinX = fr->fr_LVLeft;
            rect.MinY = yPos;
            rect.MaxX = fr->fr_LVLeft+fr->fr_LVWidth-1;
            rect.MaxY = yPos+fr->fr_ItemHeight-1;
            RenderEntry(fr,node,&rect);
            node = node->le_Node.ln_Succ;
        }
d639 6
a644 8
        {
            if (FRF_DOSAVEMODE & fr->fr_Options)
                SetAPen(&fr->fr_Store->rs_LVRPort,fr->fr_LVTextPen);
            else
                SetAPen(&fr->fr_Store->rs_LVRPort,fr->fr_LVBackPen);
            RectFill(&fr->fr_Store->rs_LVRPort,fr->fr_LVLeft,yPos,fr->fr_LVLeft+fr->fr_LVWidth-1,
                                     yPos+fr->fr_ItemHeight-1);
        }
d646 1
a646 2
        yPos = yPos + fr->fr_ItemHeight;
        start++;
d653 1
d656 1
d665 8
a672 12
       SetGadgetAttr (ri,PATTERNGAD,
		     GTST_EditHook, &fr->fr_FileHook,
		     GTST_MaxChars,sizeof(fr->fr_PatternString),
                     GTST_String,  fr->fr_PatternString,
                     TAG_DONE);
    }

    SetGadgetAttr (ri,DRAWERGAD,
		  GTST_EditHook, &fr->fr_FileHook,
		  GTST_MaxChars,sizeof(fr->fr_DrawerString),
                  GTST_String,  fr->fr_DrawerString,
                  TAG_DONE);
d677 2
a678 2
                                 GTST_MaxChars,sizeof(fr->fr_FileString),
                                 GTST_String,  fr->fr_FileString,
d681 1
d692 1
d785 1
a785 1
                    GT_VisualInfo,fr->fr_ReqInfo.ri_VisualInfo,
d793 1
a793 1
VOID SetStrValue (struct ExtFileReq *fr, WORD id, STRPTR text)
d795 2
a796 1
    SetGadgetAttr (&fr->fr_ReqInfo, id, GTST_String, text, TAG_DONE);
d885 4
a888 2
BOOL              update;
struct ListEntry *node;
d890 1
a890 1
    if (update = (fr->fr_TempFileList.lh_TailPred != (struct Node *) &fr->fr_TempFileList))
d892 5
a896 11
	while (node = RemHead (&fr->fr_TempFileList))
	    InsertListEntry (fr, node);
    }
    NewList (&fr->fr_TempFileList);
    fr->fr_TempItemCnt = 0;

    if (update)
    {
        SetGadgetAttr(&fr->fr_ReqInfo,SCROLLERGAD,
                      GTSC_Total,fr->fr_ItemCnt,
                      TAG_DONE);
a897 1
        fr->fr_DisplayValid = FALSE;
a906 1
BOOL               oktocreate = TRUE;
d908 1
a908 1
struct DiskObject *dob;
d911 1
a911 6
LONG               len;

    len = strlen (fr->fr_Drawer) - 1;
    if ((len >= 0) &&
	((fr->fr_Drawer[len] == '/') || (fr->fr_Drawer[len] == ':')))
	oktocreate = FALSE;
d913 2
a914 1
    if (oktocreate)
d924 1
a924 1
            if (lock = CreateDir (fr->fr_Drawer))
d927 2
a928 2
                UnLock (lock);
                if (dob = GetDefDiskObject (WBDRAWER))
d930 2
a931 2
                    PutDiskObject (fr->fr_Drawer, dob);
                    FreeDiskObject (dob);
d936 1
a936 1
		DisplayBeep (NULL);
d939 1
d951 1
a951 1
struct ListEntry *node;
d1017 2
a1018 1
BOOL SelectEntry(struct ExtFileReq *fr, struct ListEntry *entry, UWORD quals)
d1020 2
a1021 2
struct ListEntry *node;
BOOL              getDir = FALSE;
d1030 2
a1031 2
            node->le_Node.ln_Pri = FALSE;
            node = node->le_Node.ln_Succ;
a1033 1
    entry->le_Node.ln_Pri = TRUE;
d1035 1
a1035 1
    if (entry->le_Node.ln_Type == FILETYPE)
d1037 2
a1038 1
        strcpy(fr->fr_FileString,entry->le_Node.ln_Name);
d1041 1
a1041 1
    else
d1043 1
a1043 1
        if (entry->le_Node.ln_Type == DIRTYPE)
d1045 1
a1045 1
            AddPart(fr->fr_DrawerString,entry->le_Node.ln_Name,sizeof(fr->fr_DrawerString));
d1049 2
a1050 2
            strcpy(fr->fr_DrawerString,entry->le_Node.ln_Name);
            if (entry->le_Node.ln_Type == VOLUMETYPE)
d1058 10
d1099 2
a1100 2
struct ListEntry *node;
ULONG             cnt;
a1102 1
    {
a1103 2
        GetMsg(&fr->fr_Store->rs_PacketPort);     /* get packet out of port */
    }
d1116 2
a1117 1
        fr->fr_NumArgs = cnt  = 0;
d1121 1
a1121 1
            if (node->le_Node.ln_Pri)
d1123 1
a1123 1
            node = node->le_Node.ln_Succ;
d1134 1
a1134 1
                if (node->le_Node.ln_Pri)
d1137 1
a1137 1
                    if (!(fr->fr_ArgList[cnt].wa_Name = AllocVec(strlen(node->le_Node.ln_Name)+1,MEMF_CLEAR|MEMF_PUBLIC)))
d1143 1
a1143 1
                    strcat(fr->fr_ArgList[cnt].wa_Name,node->le_Node.ln_Name);
d1146 1
a1146 1
                node = node->le_Node.ln_Succ;
d1151 1
a1151 1
	    UnLock (dirLock);
d1189 2
a1190 1
static VOID findbestname (struct ExtFileReq *fr)
d1192 5
a1196 21
struct ListEntry *node;
ULONG             onum = fr->fr_TopItem;
ULONG             num;

    num = 0;
    if (node = (struct ListEntry *)FindClosest((struct List *)&fr->fr_FileList, fr->fr_FileString))
        num = FindNodeNum((struct List *)&fr->fr_FileList, node);

    if (num < fr->fr_TopItem)
	onum = num;
    if (num > fr->fr_TopItem + fr->fr_VisibleItems - 1)
	onum = num - fr->fr_VisibleItems + 1;

    if (onum != fr->fr_TopItem)
    {
	fr->fr_TopItem = onum;
	SetGadgetAttr(&fr->fr_ReqInfo, SCROLLERGAD, GTSC_Top, fr->fr_TopItem, TAG_DONE);
    }
}

/*****************************************************************************/
d1198 2
a1199 5
void CursorSelect (struct ExtFileReq *fr, struct Gadget *gadget, UWORD icode, UWORD quals)
{
struct ListEntry      *node;
struct ReqInfo        *ri;
BOOL                   found = FALSE;
d1201 1
a1201 3
    ri   = &fr->fr_ReqInfo;
    InsertList (fr);
    if (node = (struct ListEntry *) FindClosest (&fr->fr_FileList, fr->fr_FileString))
d1203 4
a1206 7
	if ((icode == 27) || Stricmp (node->le_Node.ln_Name, fr->fr_FileString))
	{
	    found = TRUE;
	}
	else if (icode == CURSORUP)
	{
            if (node != (struct ListEntry *) fr->fr_FileList.lh_Head)
d1208 2
a1209 2
                node = node->le_Node.ln_Pred;
		found = TRUE;
d1211 1
a1211 4
	}
	else if (icode == CURSORDOWN)
	{
            if (node != (struct ListEntry *) fr->fr_FileList.lh_TailPred)
d1213 5
a1217 2
                node = node->le_Node.ln_Succ;
		found = TRUE;
d1219 46
a1264 11
        }
    }

    if (found)
    {
	SelectEntry (fr, node, quals);
        strcpy (fr->fr_FileString, node->le_Node.ln_Name);
	if (node->le_Node.ln_Type == DIRTYPE)
	    strcat (fr->fr_FileString, "/");
        SetStrValue (fr, FILEGAD, fr->fr_FileString);
        findbestname (fr);
d1266 1
a1266 1
    RenderLV (fr);
d1268 1
a1268 1
	ActivateGadget (gadget,ri->ri_Window,NULL);
d1271 1
d1284 2
d1288 2
a1289 2
struct ListEntry      *node;
struct ListEntry      *entry;
d1301 1
a1301 3
struct AppMessage     *amsg;
ULONG                  newSeconds;
ULONG                  newMicros;
d1304 5
d1318 1
d1335 5
a1339 3
            fr->fr_LastEntry   = NULL;
            fr->fr_LastSeconds = 0;
            fr->fr_LastMicros  = 0;
d1373 1
a1373 1
                else
d1441 1
a1441 1
                             && (MatchPatternNoCase(fr->fr_Store->rs_ParsedPattern,fib->fib_FileName)));
d1448 1
a1448 1
                        if (dir = AllocNode(sizeof(struct DirEntry) + (ULONG)fib->fib_FileName[0] + 2))
d1450 1
a1450 3
                            dir->de_Link.le_Node.ln_Name = (STRPTR)((ULONG)dir + sizeof(struct DirEntry));
                            dir->de_Link.le_Node.ln_Type = DIRTYPE;
                            strcpy(dir->de_Link.le_Node.ln_Name,fib->fib_FileName);
d1452 1
a1452 2
                            dir->de_Prot = fib->fib_Protection;
                            node = (struct ListEntry *)dir;
d1457 1
a1457 1
                        if (file = AllocNode(sizeof(struct FileEntry) + (ULONG)fib->fib_FileName[0] + 2))
d1459 1
a1459 3
                            file->fe_Link.le_Node.ln_Name = (STRPTR)((ULONG)file + sizeof(struct FileEntry));
                            file->fe_Link.le_Node.ln_Type = FILETYPE;
                            strcpy(file->fe_Link.le_Node.ln_Name,fib->fib_FileName);
a1460 1
                            file->fe_Prot = fib->fib_Protection;
d1462 1
a1462 1
                            node = (struct ListEntry *)file;
d1471 1
a1471 1
                    if (fr->fr_ItemCnt < fr->fr_VisibleItems)
d1475 6
a1480 1
                        RenderLV(fr);
d1484 1
a1484 1
			AddTail (&fr->fr_TempFileList, node);
d1497 3
d1505 1
a1505 1
            while (amsg = (struct AppMessage *) GetMsg(fr->fr_AppPort))
d1509 1
a1509 1
                if (amsg->am_NumArgs)
d1511 2
a1512 2
                    NameFromLock (amsg->am_ArgList->wa_Lock, fr->fr_DrawerString, 256);
                    SetStrValue (fr, DRAWERGAD, fr->fr_DrawerString);
d1515 1
a1515 1
                    if ((amsg->am_ArgList->wa_Name) && (strlen (amsg->am_ArgList->wa_Name) > 0))
d1517 2
a1518 2
                        strcpy (fr->fr_FileString, amsg->am_ArgList->wa_Name);
                        SetStrValue (fr, FILEGAD, fr->fr_FileString);
d1522 1
a1522 1
                ReplyMsg ((struct Message *) amsg);
d1528 8
a1535 6
            class  = intuiMsg->Class;
            icode  = intuiMsg->Code;
            gadget = (struct Gadget *)intuiMsg->IAddress;
            window = intuiMsg->IDCMPWindow;
            mouseY = intuiMsg->MouseY;
            quals  = intuiMsg->Qualifier;
d1595 1
a1595 1
                                                  case FR_LASTNAME: CursorSelect (fr, NULL, CURSORUP, quals);
d1597 4
a1600 1
                                                  case FR_NEXTNAME: CursorSelect (fr, NULL, CURSORDOWN, quals);
d1607 20
a1626 6
                case IDCMP_MOUSEMOVE    :
                case IDCMP_GADGETDOWN   :
                case IDCMP_GADGETUP     :
                                          if ((class==IDCMP_GADGETUP) &&
                                              (gadget->GadgetType & STRGADGET) &&
                                              (icode == (-1)))
d1632 2
a1633 1
                                          switch ((UWORD)gadget->GadgetID)
d1643 2
a1644 1
                                              case FR_LISTCLICK : icode = (mouseY - (WORD)fr->fr_LVTop) / fr->fr_ItemHeight;
d1649 2
a1650 2
                                                                      while (icode-- && entry)
                                                                          entry = entry->le_Node.ln_Succ;
d1652 1
a1652 1
                                                                      if (entry)
d1654 6
a1659 1
                                                                          getDir = SelectEntry(fr,entry,quals);
d1661 7
a1667 12
                                                                          if ((entry == fr->fr_LastEntry)
                                                                          && (!(FRF_DOSAVEMODE & fr->fr_Options)))
                                                                          {
                                                                              CurrentTime(&newSeconds,&newMicros);
                                                                              if (DoubleClick(fr->fr_LastSeconds,fr->fr_LastMicros,newSeconds,newMicros))
                                                                                  return(QuitFR(fr,FALSE,lock));
                                                                          }
                                                                          else
                                                                          {
                                                                              fr->fr_LastEntry = entry;
                                                                              CurrentTime(&fr->fr_LastSeconds,&fr->fr_LastMicros);
                                                                          }
a1687 5
                                                                  if (!fr->fr_PatternString[0])
                                                                  {
                                                                      strcpy(fr->fr_PatternString,"#?");
                                                                      SetStrValue(fr,PATTERNGAD,fr->fr_PatternString);
                                                                  }
d1698 1
a1698 2
                                              case FR_FILE      : ptr = FilePart(fr->fr_FileString);
                                                                  if (ptr == fr->fr_FileString)
d1700 1
a1700 19
                                                                      if (ParsePatternNoCase(fr->fr_FileString,fr->fr_Store->rs_ParsedPattern,sizeof(fr->fr_Store->rs_ParsedPattern)))
                                                                      {
                                                                          SetStrValue(fr,PATTERNGAD,fr->fr_PatternString);
                                                                          strcpy(fr->fr_PatternString,fr->fr_FileString);
                                                                          SetStrValue(fr,FILEGAD,"");
                                                                          getDir = TRUE;
                                                                      }
                                                                      else if ((icode==27) || (icode==CURSORUP) || (icode==CURSORDOWN))
                                                                      {
									  CursorSelect (fr, gadget, icode, quals);
                                                                      }
                                                                      else if ((quals & ALTKEYS) || icode == 9)
                                                                      {
                                                                          ActivateGad(fr,FILEGAD,quals);
                                                                      }
                                                                      else if (!(quals & SHIFTKEYS))
                                                                      {
                                                                          return(QuitFR(fr,fr->fr_FileString[0] == '\0',lock));
                                                                      }
d1704 2
a1705 2
                                                                      new = FALSE;
                                                                      if (stpchr(fr->fr_FileString,':'))
d1707 16
a1722 2
                                                                          fr->fr_DrawerString[0] = 0;
                                                                          new = TRUE;
d1724 1
a1724 2

                                                                      if (ptr != fr->fr_FileString)
d1726 6
a1731 6
                                                                          AddPart(fr->fr_DrawerString,fr->fr_FileString,sizeof(fr->fr_DrawerString));
                                                                          strcpy(fr->fr_FileString,ptr);
                                                                          ptr    = FilePart(fr->fr_DrawerString);
                                                                          ptr[0] = 0;
                                                                          new    = TRUE;
                                                                      }
d1733 8
a1740 5
                                                                      if (new)
                                                                      {
                                                                          ReducePath(fr->fr_DrawerString);
                                                                          SetStrValue(fr,DRAWERGAD,fr->fr_DrawerString);
                                                                      }
a1741 10
                                                                      if (ParsePatternNoCase(fr->fr_FileString,fr->fr_Store->rs_ParsedPattern,sizeof(fr->fr_Store->rs_ParsedPattern)))
                                                                      {
                                                                          SetStrValue(fr, PATTERNGAD, fr->fr_FileString);
                                                                          strcpy(fr->fr_PatternString,fr->fr_FileString);
                                                                          SetStrValue(fr, FILEGAD, "");
                                                                          getDir = TRUE;
                                                                      }
                                                                      else
                                                                      {
                                                                          SetStrValue(fr,FILEGAD,fr->fr_FileString);
d1744 9
d1755 8
d1764 6
a1770 6

                                                                  if (getDir)
                                                                      ActivateGadget(gadget,window,NULL);
                                                                  else
                                                                      ActivateGad(fr,FILEGAD,quals);
                                                                  ParsePat(fr);
d1783 2
a1784 1
                case IDCMP_INTUITICKS   : break;
d1786 2
a1787 2
                case IDCMP_RAWKEY       : if ((icode == 27) || (icode == CURSORUP) || (icode == CURSORDOWN))
                			      CursorSelect (fr, NULL, icode, quals);
d1790 4
d1863 1
d1865 1
a1865 2
    ProcessMemoryBox (&fr->fr_ReqInfo);
}
d1867 1
d1870 3
a1872 7
/*****************************************************************************/
#if 0
struct ExtFileReq *fr = (struct ExtFileReq *)hook->h_Data;
    if (sgw->IEvent->ie_Qualifier & ALTED)
#endif

ULONG ASM fileh (REG(a0) struct Hook *hook, REG(a2) struct SGWork *sgw, REG(a1) ULONG *msg)
d1874 4
a1877 1
    if (*msg == SGH_KEY)
d1879 1
a1879 18
	kprintf ("code=0x%lx\n", (ULONG)sgw->IEvent->ie_Code);
	if (sgw->IEvent->ie_Qualifier & IEQUALIFIER_RCOMMAND)
	{
	    switch (sgw->IEvent->ie_Code)
	    {
		case 0x67:
		case KEYCODE_Q:
		case KEYCODE_Z:
		case KEYCODE_X:
		    break;

		default:
		    sgw->Actions = SGA_REUSE | SGA_END;
		    sgw->Code = -1;
		    break;
	    }
	}
        else if (sgw->IEvent->ie_Code == CURSORUP)
d1881 19
a1899 21
            sgw->Actions |= SGA_END;
	    sgw->Code = CURSORUP;
        }
        else if (sgw->IEvent->ie_Code == CURSORDOWN)
        {
            sgw->Actions |= SGA_END;
	    sgw->Code = CURSORDOWN;
        }
	/* ESC */
        else if (sgw->IEvent->ie_Code == 0x45)
        {
            sgw->Actions |= SGA_END;
	    sgw->Code = 27;
        }
        return(1);
    }
    else
    {
        return(0);
    }
}
d1911 2
a1912 2
	NewList (&fr->fr_FileList);
	NewList (&fr->fr_TempFileList);
d1914 4
a1917 4
        fr->fr_ReqInfo.ri_LeftEdge    = 0;
        fr->fr_ReqInfo.ri_TopEdge     = 0;
        fr->fr_ReqInfo.ri_Width       = 318;
        fr->fr_ReqInfo.ri_Height      = 178;
d1920 1
a1920 1
        fr->fr_ReqInfo.ri_IDCMPFlags  = IDCMP_MENUPICK | IDCMP_REFRESHWINDOW | IDCMP_CLOSEWINDOW | IDCMP_INTUITICKS | IDCMP_NEWSIZE | IDCMP_RAWKEY | IDCMP_ACTIVEWINDOW | LISTVIEWIDCMP | SCROLLERIDCMP | BUTTONIDCMP | CYCLEIDCMP;
d1931 1
a1931 4
        fr->fr_LeftEdge = fr->fr_ReqInfo.ri_LeftEdge;
        fr->fr_TopEdge  = fr->fr_ReqInfo.ri_TopEdge;
        fr->fr_Width    = fr->fr_ReqInfo.ri_Width;
        fr->fr_Height   = fr->fr_ReqInfo.ri_Height;
d1933 2
a1934 3
	/* Initialize the edit hook */
	fr->fr_FileHook.h_Entry = fileh;
	fr->fr_FileHook.h_Data = fr;
d1951 1
d2004 3
d2014 1
a2014 4
        fr->fr_LeftEdge = ri->ri_LeftEdge;
        fr->fr_TopEdge  = ri->ri_TopEdge;
        fr->fr_Width    = ri->ri_Width;
        fr->fr_Height   = ri->ri_Height;
@


38.9
log
@fixed Multiselect problems
@
text
@d679 12
a690 8
       SetGadgetAttr(ri,PATTERNGAD,GTST_MaxChars,sizeof(fr->fr_PatternString),
                                   GTST_String,  fr->fr_PatternString,
                                   TAG_DONE);
    }

    SetGadgetAttr(ri,DRAWERGAD,GTST_MaxChars,sizeof(fr->fr_DrawerString),
                               GTST_String,  fr->fr_DrawerString,
                               TAG_DONE);
d1238 1
a1238 2
	if ((node->le_Node.ln_Type == FILETYPE) &&
	    ((icode == 27) || Stricmp (node->le_Node.ln_Name, fr->fr_FileString)))
d1247 1
a1247 2
		if (node->le_Node.ln_Type == FILETYPE)
		    found = TRUE;
d1255 1
a1255 2
                if (node->le_Node.ln_Type == FILETYPE)
		    found = TRUE;
d1264 2
d1596 10
a1605 1
                case IDCMP_GADGETUP     : switch ((UWORD)gadget->GadgetID)
a1741 1

d1846 18
a1863 1
        if (sgw->IEvent->ie_Code == CURSORUP)
@


38.8
log
@fixed keyboard select problem
@
text
@d55 1
a257 1
    DB (kprintf ("I: 0x%lx : %s : %ld\n", newEntry, newEntry->le_Node.ln_Name, nameLen));
a647 2
	    DB (kprintf ("node=0x%lx : 0x%lx [%s] : type=%ld\n",
		node, node->le_Node.ln_Name, node->le_Node.ln_Name, (ULONG)node->le_Node.ln_Type));
d1125 4
a1128 1
        cnt  = 0;
d1137 1
a1137 1
        if (fr->fr_ArgList = AllocVec(sizeof(struct WBArg)*cnt,MEMF_CLEAR|MEMF_PUBLIC))
d1160 4
a1452 1
			    DB (kprintf("F: [%s]\n", fib->fib_FileName));
@


38.7
log
@implemented next & previous.
@
text
@a1214 3

    InsertList (fr);
    RenderLV (fr);
d1226 1
d1261 1
a1261 1

@


38.6
log
@packet in the wrong place
@
text
@d54 1
a54 1
#define	DB(x)	x
d72 4
d80 1
d205 1
d207 1
a207 1
struct ListEntry *list;
d214 1
a214 1
            list = fr->fr_FileList;
d216 1
a216 1
            list = fr->fr_TempFileList;
d218 13
a230 9
        while (list)
        {
            if (list->le_Type == VOLUMETYPE)
                FreeVec(((struct VolumeEntry *)list)->ve_DeviceName);

            next = list->le_Next;
            FreeVec(list);
            list = next;
        }
a232 2
    fr->fr_FileList     = NULL;
    fr->fr_TempFileList = NULL;
d248 1
a248 2
struct ListEntry   *previous;
struct ListEntry   *current;
d254 1
a254 1
    nameLen = strlen(newEntry->le_Name);
d257 1
a257 38

    current  = fr->fr_FileList;
    previous = (struct ListEntry *)&fr->fr_FileList;

    volume = (struct VolumeEntry *)newEntry;
    if ((newEntry->le_Type == VOLUMETYPE) && (!volume->ve_DeviceName))
    {
        volume = (struct VolumeEntry *)current;
        while (current && (current->le_Type == VOLUMETYPE) && volume->ve_DeviceName)
        {
            previous = current;
            current  = current->le_Next;
            volume = (struct VolumeEntry *)current;
        }
    }

    if ((newEntry->le_Type == DIRTYPE) || (newEntry->le_Type == ASSIGNTYPE))
    {
        while (current && ((current->le_Type == FILETYPE) || (current->le_Type == VOLUMETYPE)))
        {
            previous = current;
            current  = current->le_Next;
        }
    }

    while (current)
    {
        if ((Stricmp(current->le_Name,newEntry->le_Name) > 0)
        || ((newEntry->le_Type == FILETYPE) || (newEntry->le_Type == VOLUMETYPE))
         && ((current->le_Type == DIRTYPE) || (current->le_Type == ASSIGNTYPE)))
        {
            newEntry->le_Next = previous->le_Next;
            previous->le_Next = newEntry;
            return;
        }
        previous = current;
        current  = current->le_Next;
    }
d259 2
a260 7
    previous->le_Next = newEntry;
    newEntry->le_Next = NULL;
}


/*****************************************************************************/

d262 28
a289 19
VOID RemoveListEntry(struct ExtFileReq *fr, struct ListEntry *entry)
{
struct ListEntry *previous;
struct ListEntry *current;

    current  = fr->fr_FileList;
    previous = (struct ListEntry *)&fr->fr_FileList;

    while (current)
    {
        if (current == entry)
        {
            previous->le_Next = current->le_Next;
            fr->fr_ItemCnt--;
            break;
        }
        previous = current;
        current  = current->le_Next;
    }
a291 1

a293 1

d382 1
a382 1
        if (entry->le_Selected)
d393 1
a393 1
        if ((entry->le_Type == DIRTYPE) || (entry->le_Type == ASSIGNTYPE))
d396 1
a396 1
        if (entry->le_Selected)
d403 1
a403 1
    switch (entry->le_Type)
d430 1
a430 1
    Text(rp,entry->le_Name,TextFit(rp,entry->le_Name,strlen(entry->le_Name),&extent,NULL,1,rect->MaxX-rect->MinX-3,32767));
d475 3
a477 3
                volume->ve_Link.le_Name = (STRPTR)((ULONG)volume + sizeof(struct VolumeEntry));
                volume->ve_Link.le_Type = VOLUMETYPE;
                CopyMem(&name[1],volume->ve_Link.le_Name,(ULONG)name[0]);
d485 1
a485 1
                    volume->ve_Link.le_Next  = (struct ListEntry *)hold;
d496 4
a499 4
                assign->ae_Link.le_Name = (STRPTR)((ULONG)assign + sizeof(struct AssignEntry));
                assign->ae_Link.le_Type = ASSIGNTYPE;
                CopyMem(&name[1],assign->ae_Link.le_Name,(ULONG)name[0]);
                strcat(assign->ae_Link.le_Name,":");
d522 1
a522 1
            volume = (struct VolumeEntry *)volume->ve_Link.le_Next;
d531 1
a531 1
        volume = (struct VolumeEntry *)hold->ve_Link.le_Next;
d552 2
d630 1
d632 7
a638 5

    node = fr->fr_FileList;
    i    = start+fr->fr_TopItem;
    while (i-- && node)
        node = node->le_Next;
d642 1
a642 1
        if (node)
d648 2
d651 1
a651 1
            node = node->le_Next;
a670 1

a672 1

d692 1
a692 1
        SetGadgetAttr(ri,FILEGAD, /* GTST_EditHook, &fr->fr_FileHook, */
d901 1
a901 2
    update = (fr->fr_TempFileList != NULL);
    while (node = fr->fr_TempFileList)
d903 2
a904 3
        node = node->le_Next;
        InsertListEntry(fr,fr->fr_TempFileList);
        fr->fr_TempFileList = node;
d906 2
d933 2
a934 1
    if ((len >= 0) && (fr->fr_Drawer[len] == '/'))
d957 3
a961 3

    if (!created)
	DisplayBeep (NULL);
d971 1
a971 1
BOOL              deleted = FALSE;
d973 1
d976 1
a976 1

d978 2
a979 1
    len = strlen (fr->fr_DrawerString) + strlen (fr->fr_FileString) + 4;
d984 1
a984 1
        ReducePath(fr->fr_DrawerString);
d992 1
a992 1
        if (EasyRequestArgs(fr->fr_ReqInfo.ri_Window, &est, NULL, &buffer)) /* &fr->fr_File)) */
d994 1
a994 4
	    /* For those times that you have an Icon but no File. */
            if (DeleteDiskObject (buffer))
                deleted = TRUE;

a995 3
                deleted = TRUE;

	    if (!strlen (fr->fr_FileString))
d997 23
a1019 5
		len = strlen(fr->fr_DrawerString);
                if ((len == 0) || (fr->fr_DrawerString[len-1] == '/') || (fr->fr_DrawerString[len-1] == ':'))
                    strcat(fr->fr_DrawerString,"/");
                else
                    strcat(fr->fr_DrawerString,"//");
d1021 4
a1024 2
                ReducePath(fr->fr_DrawerString);
                SetStrValue(fr,DRAWERGAD,fr->fr_DrawerString);
d1026 2
a1028 1

d1031 1
a1031 5

    if (!deleted)
	DisplayBeep (NULL);

    return (deleted);
d1048 1
a1048 1
        node = fr->fr_FileList;
d1051 2
a1052 2
            node->le_Selected = FALSE;
            node = node->le_Next;
d1055 1
a1055 1
    entry->le_Selected = TRUE;
d1057 1
a1057 1
    if (entry->le_Type == FILETYPE)
d1059 1
a1059 1
        strcpy(fr->fr_FileString,entry->le_Name);
d1064 1
a1064 1
        if (entry->le_Type == DIRTYPE)
d1066 1
a1066 1
            AddPart(fr->fr_DrawerString,entry->le_Name,sizeof(fr->fr_DrawerString));
d1070 2
a1071 2
            strcpy(fr->fr_DrawerString,entry->le_Name);
            if (entry->le_Type == VOLUMETYPE)
d1128 1
a1128 1
        node = fr->fr_FileList;
d1131 1
a1131 1
            if (node->le_Selected)
d1133 1
a1133 1
            node = node->le_Next;
d1141 1
a1141 1
            node = fr->fr_FileList;
d1144 1
a1144 1
                if (node->le_Selected)
d1147 1
a1147 1
                    if (!(fr->fr_ArgList[cnt].wa_Name = AllocVec(strlen(node->le_Name)+1,MEMF_CLEAR|MEMF_PUBLIC)))
d1153 1
a1153 1
                    strcat(fr->fr_ArgList[cnt].wa_Name,node->le_Name);
d1156 1
a1156 1
                node = node->le_Next;
d1195 76
d1438 3
a1440 3
                            dir->de_Link.le_Name = (STRPTR)((ULONG)dir + sizeof(struct DirEntry));
                            dir->de_Link.le_Type = DIRTYPE;
                            strcpy(dir->de_Link.le_Name,fib->fib_FileName);
d1450 4
a1453 3
                            file->fe_Link.le_Name = (STRPTR)((ULONG)file + sizeof(struct FileEntry));
                            file->fe_Link.le_Type = FILETYPE;
                            strcpy(file->fe_Link.le_Name,fib->fib_FileName);
d1474 1
a1474 2
                        node->le_Next = fr->fr_TempFileList;
                        fr->fr_TempFileList = node;
a1536 1
                                          {
a1537 1
                                          }
a1538 1
                                          {
a1539 1
                                          }
d1559 11
a1569 1
                                                  case FR_PARENT  :
d1580 3
a1582 2
                                                  case FR_LASTNAME:
                                                  case FR_NEXTNAME:
d1605 1
a1605 1
                                                                      entry = fr->fr_FileList;
d1607 1
a1607 1
                                                                          entry = entry->le_Next;
d1670 4
d1744 3
a1746 1
                case IDCMP_RAWKEY       : break;
d1817 38
d1867 3
d1891 4
a1894 3
/*
        initHook (&fr->fr_FileHook, fileh);
 */
@


38.5
log
@DoubleClick now works
Disabled double-click in save mode
Packet IO is now done in a private port instead of the process pr_msgPort
@
text
@d54 1
d56 2
d946 1
a946 1
VOID MakeDrawer(struct ExtFileReq *fr)
d948 48
d998 35
a1032 14
    est.es_StructSize   = sizeof(struct EasyStruct);
    est.es_Flags        = 0;
    est.es_Title        = GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_NEWDIR_TITLE);
    est.es_TextFormat   = GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_NEWDIR_PROMPT);
    est.es_GadgetFormat = GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_NEWDIR_GAD);

    if (EasyRequestArgs(fr->fr_ReqInfo.ri_Window,&est,NULL,&fr->fr_Drawer))
    {
        /*!!! create the directory !!!*/
    }
}


/*****************************************************************************/
d1034 2
d1037 2
a1038 3
VOID DeleteFiles(struct ExtFileReq *fr)
{
struct EasyStruct est;
d1040 2
a1041 11
    est.es_StructSize   = sizeof(struct EasyStruct);
    est.es_Flags        = 0;
    est.es_Title        = GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_DELETE_TITLE);;
    est.es_TextFormat   = GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_DELETE_PROMPT);
    est.es_GadgetFormat = GetString(&fr->fr_ReqInfo.ri_LocaleInfo,MSG_ASL_FR_DELETE_GAD);

    if (EasyRequestArgs(fr->fr_ReqInfo.ri_Window,&est,NULL,&fr->fr_File))
    {
        /*!!! delete the file !!!*/
    }
}
a1223 1
struct Process        *process;
a1239 1
    process    = (struct Process *)FindTask(NULL);
d1298 1
a1298 1
                        MakeDrawer(fr);
a1351 1
                SendPkt(&packet->sp_Pkt,lockPtr->fl_Task,&fr->fr_Store->rs_PacketPort);
d1394 2
d1501 4
a1504 1
                                                  case FR_DELETE  : DeleteFiles(fr);
@


38.4
log
@*** empty log message ***
@
text
@a1056 1
struct Process   *process;
d1060 2
a1061 3
        process = (struct Process *)FindTask(NULL);
        WaitPort(&process->pr_MsgPort);   /* wait for packet return */
        GetMsg(&process->pr_MsgPort);     /* get packet out of port */
a1165 1
BOOL                   retval;
a1175 1
    retval     = FALSE;
d1204 2
a1205 2
                WaitPort(&process->pr_MsgPort);   /* wait for packet return */
                GetMsg(&process->pr_MsgPort);     /* get packet out of port */
d1222 1
a1222 1
                        SendPkt(&packet->sp_Pkt,lockPtr->fl_Task,&process->pr_MsgPort);
d1280 1
a1280 1
			     ((1L<<process->pr_MsgPort.mp_SigBit) | (1L<<fr->fr_AppPort->mp_SigBit)));
d1282 1
a1282 1
        if (GetMsg(&process->pr_MsgPort))
d1290 1
a1332 2
                SendPkt(&packet->sp_Pkt,lockPtr->fl_Task,&process->pr_MsgPort);

d1473 2
a1474 1
                                                                          if (entry == fr->fr_LastEntry)
d1536 1
a1536 3
                                                                          if (fr->fr_FileString[0])
                                                                              return(TRUE);
                                                                          return(FALSE);
d1593 1
a1593 1
                                              return(FALSE);
a1604 2

    return (retval);
d1722 1
d1741 6
@


38.3
log
@*** empty log message ***
@
text
@a716 1

d719 1
d774 12
d787 1
d1127 1
a1127 1
         result = (fr->fr_ReqInfo.ri_OldHook(FRF_FILTERFUNC,(ULONG)&fr->fr_Store->rs_AP,(ULONG)fr) == 0);
d1132 1
a1132 1
         result = (!fr->fr_FilterFunc) || CallHookPkt(fr->fr_FilterFunc,fr,&fr->fr_Store->rs_AP);
d1283 1
a1283 1
        intuiMsg = GetReqMsg(ri,fr,NULL,
@


38.2
log
@*** empty log message ***
@
text
@a387 1
struct AssignEntry *assign;
a399 1
    assign = (struct AssignEntry *)entry;
d1114 1
a1114 1
         result = (BOOL)fr->fr_ReqInfo.ri_OldHook(FRF_FILTERFUNC,(ULONG)&fr->fr_Store->rs_AP,(ULONG)fr);
a1136 1
struct Gadget         *act;
d1174 9
d1219 1
a1219 1
                        DisplayBeep(fr->fr_ReqInfo.ri_Screen);
d1231 1
a1231 1
                        DisplayBeep(fr->fr_ReqInfo.ri_Screen);
d1246 1
a1246 1
            SetGadgetAttr(&fr->fr_ReqInfo,SCROLLERGAD,
d1253 1
a1253 1
        window = fr->fr_ReqInfo.ri_Window;
d1270 1
a1270 1
        intuiMsg = GetReqMsg(&fr->fr_ReqInfo,fr,NULL,
d1327 1
a1327 1
                    if (fr->fr_ItemCnt <= fr->fr_VisibleItems)
d1346 1
a1346 1
                SetGadgetAttr(&fr->fr_ReqInfo, SCROLLERGAD,
d1356 1
a1356 1
                ActivateWindow (fr->fr_ReqInfo.ri_Window);
d1385 1
a1385 1
            if (gad = fr->fr_ReqInfo.ri_Template[PATTERNGAD].ag_Gadget)
d1388 1
a1388 1
            if (gad = fr->fr_ReqInfo.ri_Template[DRAWERGAD].ag_Gadget)
d1391 1
a1391 1
            if (gad = fr->fr_ReqInfo.ri_Template[FILEGAD].ag_Gadget)
d1398 10
d1412 1
a1412 1
                                              menuItem = ItemAddress(fr->fr_ReqInfo.ri_Menus,icode);
d1443 1
a1443 2
                case IDCMP_GADGETUP     : act = NULL;
                                          switch ((UWORD)gadget->GadgetID)
d1591 1
a1591 2
                case IDCMP_INTUITICKS   :
                                          break;
d1684 1
a1684 1
        fr->fr_ReqInfo.ri_IDCMPFlags  = IDCMP_MENUPICK | IDCMP_REFRESHWINDOW | IDCMP_CLOSEWINDOW | IDCMP_INTUITICKS | IDCMP_NEWSIZE | IDCMP_RAWKEY | LISTVIEWIDCMP | SCROLLERIDCMP | BUTTONIDCMP | CYCLEIDCMP;
@


38.1
log
@Initial V38 RCS checkin
@
text
@d197 3
a199 4
struct ListEntry   *next;
struct VolumeEntry *volume;
struct ListEntry   *list;
ULONG               cnt;
d209 1
a209 2
        volume = (struct VolumeEntry *)list;
        while (volume)
d211 2
a212 4
            if (volume->ve_Link.le_Type == VOLUMETYPE)
                FreeVec(volume->ve_DeviceName);
            volume = (struct VolumeEntry *)volume->ve_Link.le_Next;
        }
a213 2
        while (list)
        {
a1111 1
    sprintf(fr->fr_Store->rs_AP.ap_Info.fib_FileName,"%b",(STRPTR)((ULONG)fr->fr_Store->rs_AP.ap_Info.fib_FileName / 4));
d1277 1
d1296 1
a1296 1
                            CopyMem(&fib->fib_FileName[1],dir->de_Link.le_Name,(ULONG)fib->fib_FileName[0]);
d1308 1
a1308 1
                            CopyMem(&fib->fib_FileName[1],file->fe_Link.le_Name,(ULONG)fib->fib_FileName[0]);
d1410 4
a1413 1
                                                  case FR_VOLUMES :
@
