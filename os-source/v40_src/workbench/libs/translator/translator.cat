	TTL	'$Header: trname.asm,v 36.0 89/05/24 10:11:02 kodiak Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: trname.asm,v 36.0 89/05/24 10:11:02 kodiak Exp $
*
* $Locker:  $
*
* $Log:	trname.asm,v $
*   Revision 36.0  89/05/24  10:11:02  kodiak
*   *** empty log message ***
*   
* Revision 32.2  86/06/24  13:15:36  sam
* autodoc updates
* 
* Revision 32.1  86/01/22  01:18:01  sam
* placed under source control
* 
*
**********************************************************************
	SECTION reader

* ****** Included Files ***********************************************

    INCLUDE	'assembly.i'
    INCLUDE	'translator_rev.i'
    INCLUDE	'exec/types.i'
    INCLUDE	'exec/nodes.i'
    INCLUDE	'exec/strings.i'
    INCLUDE	'exec/resident.i'


* ****** Imported Globals *********************************************



* ****** Imported Functions *******************************************



* ****** Exported *****************************************************

    XDEF	TranslatorName
    XDEF	TranslatorIdStr



TranslatorIdStr:
		VSTRING


*------ Name String  -------------------------------------------

TranslatorName:
		STRING  'translator.library'



	END
	TTL	'$Header: library.asm,v 36.1 89/05/24 10:44:04 kodiak Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: library.asm,v 36.1 89/05/24 10:44:04 kodiak Exp $
*
* $Locker:  $
*
* $Log:	library.asm,v $
*   Revision 36.1  89/05/24  10:44:04  kodiak
*   remove unreferenced includes, equates
*   
*   Revision 36.0  89/05/24  10:11:09  kodiak
*   *** empty log message ***
*   
* Revision 32.2  86/06/24  13:14:33  sam
* autodoc updates
* 
* Revision 32.1  86/01/22  01:16:59  sam
* placed under source control
* 
*
**********************************************************************
               SECTION reader
_AbsExecBase	EQU	4


* ****** Included Files **********************************************


	INCLUDE 'assembly.i'
 	INCLUDE 'exec/types.i'
	INCLUDE 'exec/nodes.i'
	INCLUDE 'exec/lists.i'
	INCLUDE 'exec/strings.i'
	INCLUDE 'exec/initializers.i'
	INCLUDE 'exec/memory.i'
	INCLUDE 'exec/interrupts.i'
	INCLUDE 'exec/ports.i'
	INCLUDE 'exec/libraries.i'
	INCLUDE 'exec/devices.i'
	INCLUDE 'exec/io.i'
	INCLUDE 'exec/tasks.i'
	INCLUDE 'exec/resident.i'
	INCLUDE 'exec/execbase.i'
	INCLUDE 'exec/ables.i'
	INCLUDE 'exec/errors.i'


        INCLUDE	'translator_rev.i'
	INCLUDE 'private.i'



* ***** Imported Functions *******************************************


	EXTERN_SYS FreeMem
	EXTERN_SYS MakeLibrary
	EXTERN_SYS AddLibrary


 	XREF	TranslatorName
	XREF	Reader

	


* ***** Exported Functions *******************************************

*	XDEF	TRInit



* ***** Local Definitions **********************************************




* ****** Library/Translator/Initialize **********************************
*
*   NAME
*	Initialize -- initialize the Translator library
*
*   SYNOPSIS
*	Error = Initialize(), SysLib
*	D0		  	A6
*
*   FUNCTION
*	Initializes the Translator library from nothing.  Called by
*	the first call to OpenLibrary.  The TRInit entry point must
*	be the first code section of the first code hunk in the .ld
*	file.  This is necessary because we don't use the romtag
*	mechanism.
*
*   INPUTS
*
*
*   RESULTS
*
*
*   SEE ALSO
*
*
* *********************************************************************
*
*
*   REGISTER USAGE
*
*   IMPLEMENTATION
*
*



TRInit:
		MOVEM.L A2/A6/D3,-(SP)
		MOVE.L	A0,D3			;Cache the segment list ptr
		MOVE.L	_AbsExecBase,A6


*		;------ Call the library initialization routine
		LEA	libFuncInit(PC),A0
		LEA	libStructInit(PC),A1
		SUB.L   A2,A2
		MOVE.L	#TR_SIZE,D0
		CALLSYS MakeLibrary
		TST.L	D0
		BEQ	Init_MakeBad


Init_Success:
*		;------ Managed to get this far, everything else should be simple
		MOVE.L	D0,A2			;Copy device pointer
		MOVE.L  A6,TR_SYSLIB(A2)	;Store pointer to system library
		MOVE.L	D3,TR_SEGLIST(A2)	;Store segment list pointer


*		;------ Add the library
		MOVE.L	A2,A1
		CALLSYS AddLibrary


*		;------ Everything worked, return NULL
		MOVEQ   #-1,D0


Init_End:
		MOVEM.L (SP)+,A2/A6/D3
		RTS


Init_MakeBad:
 		MOVEQ	#0,D0
		BRA.S	Init_End

		


******* translator.library/OpenLibrary *****************************************
*
*    NAME
*	OpenLibrary - Grants access to the translator library
*
*    SYNOPSIS
*	TranslatorBase = OpenLibrary( "translator.library", 0 );
*	D0		 	       A1		   D0	
*
*	extern LONG TranslatorBase;
*	STRPTR library_name;
*	WORD version_number;
*
*    FUNCTION
*	The open routine grants access to the translator library
*	and returns a pointer to the library node.  The name
*	"TranslatorBase" must be used and it must be declared
*	to be external and LONG.
*
*    INPUTS
*	library_name - "translator.library"
*	version_number      - 0
*	
*    RESULTS
*	TranslatorBase - a pointer to the base address of the translator
*			 library, which must be declared as extern LONG.
*
*    BUGS	
*
*    SEE ALSO
*	translator.library/CloseLibrary, exec/libraries.h
********************************************************************************
*
*
*   REGISTER USAGE
*
*
*   IMPLEMENTATION
*
*


TROpen:		
                TST.W   LIB_OPENCNT(A6)		        ;Driver already open?
		BNE.S   Is_Open				;Yes


*               ;------ First time driver has been opened.
		NOP


Is_Open:
*		;------ Increment open count
		ADDQ.W	#1,LIB_OPENCNT(A6)

	
Open_End:
		BCLR	#UNITB_EXPUNGE,LIB_FLAGS(A6)	;Clear the delayed expnge bit
		MOVE.L	A6,D0
		RTS





******* translator.library/CloseLibrary ****************************************
*
*    NAME
*	CloseLibrary - Closes the translator library
*
*    SYNOPSIS
*	CloseLibrary(TranslatorBase)
*		     A1
*
*	extern LONG TranslatorBase;
*
*    FUNCTION
*	The CloseLibrary routine is called when the user no longer
*	needs the translator library.  CloseLibrary reduces the
*	open count, and if zero and the expunge bit is on, expunges
*	the library.
*
*    INPUTS
*	TranslatorBase - The library base address returned from OpenLibrary.
*
*    RESULTS
*	The opencount of the translator library is decremented, and if it 
*	becomes zero, the library may be expunged from memory.
*
*    BUGS
*
*    SEE ALSO
*	translator.library/OpenLibrary, exec/libraries.h
********************************************************************************
*
*
*   REGISTER USAGE
*
*
*   IMPLEMENTAION
*
*


TRClose:

*	;------	Reduce device open count.  If last close, jump to Expunge
	MOVEQ	#0,D0			;!!!sam 8/30/85!!!
	SUBQ.W  #1,LIB_OPENCNT(A6)
	BNE.S	Close_NotLast
	BTST	#UNITB_EXPUNGE,LIB_FLAGS(A6)
	BEQ.S	Close_NotLast
	MOVE.L	A1,-(SP)
	BSR	TRExpunge		;Returns segment list ptr in D0
	MOVE.L	(SP)+,A1

Close_NotLast:
	RTS





* ****** Library/Translator/Expunge ***********************************
*
*   NAME
*	Expunge
*
*   SYNOPSIS
*	Expunge(devNode)
*		   A6
*
*   FUNCTION
*	Releases all memory and removes the library from the system
*	list.
*
*   INPUTS
*
*
*   RESULTS
*
*
*   SEE ALSO
*
*
* *********************************************************************
*
*
*   REGISTER USAGE
*
*
*   IMPLEMENTAION
*
*

TRExpunge:
	MOVEM.L	A3/A6/D3,-(SP)
	MOVE.L	A6,A3
	MOVE.L	_AbsExecBase,A6


*	;------ Last close?  If so, release fixed buffers
	TST.W	LIB_OPENCNT(A3)
	BEQ.S	ExDev
	BSET	#UNITB_EXPUNGE,LIB_FLAGS(A3)
	MOVEQ	#0,D0
	BRA.S	ExReturn


ExDev:
*       ;------ Remove the library
        MOVE.L  A3,A1
        REMOVE


*	;------	Remove library node
	MOVE.L	TR_SEGLIST(A3),D3
	MOVE.L	A3,A1
	MOVEQ	#0,D0			*!!!sam 8/31/85!!!
	MOVEQ	#0,D1			*!!!sam 8/31/85!!!
	MOVE.W	LIB_NEGSIZE(A3),D0	*!!!sam 8/31/85!!!
	SUB.L	D0,A1			*!!!sam 8/31/85!!!
	MOVE.W	LIB_POSSIZE(A3),D1	*!!!sam 8/31/85!!!
	ADD.L	D1,D0			*!!!sam 8/31/85!!!
*	MOVE.L	#TR_SIZE,D0		*!!!sam 8/31/85!!!
	CALLSYS	FreeMem
	MOVE.L	D3,D0


ExReturn:	
	MOVEM.L	(SP)+,A3/A6/D3
	RTS




* ****** Library/Translator/Null ****************************************
*
*   NAME
*	Null -- provide a dummy entry point
*
*   SYNOPSIS
*	Zero = Null(), DevNode
*	D0	       A6
*
*   FUNCTION
*	Be a constant source of zero's for unimplemented routines.
*
*   RESULTS
*	Zero -- Always return 0 in D0
*
*
*   SEE ALSO
*	SLNullFunc
*
*
* ********************************************************************

TRExtFunc:
TRNull:
		MOVEQ	#0,D0
		RTS





		XDEF libStructInit
libStructInit:

*		;------ Initialize the device
		INITBYTE	LN_TYPE,NT_LIBRARY
		INITLONG	LN_NAME,TranslatorName
		INITWORD	LIB_REVISION,REVISION
		INITWORD	LIB_VERSION,VERSION
		INITBYTE	LIB_FLAGS,LIBF_SUMUSED!LIBF_CHANGED
		INITWORD	LIB_OPENCNT,0
		
		DC.L		0


*		;------ Device function table

		XDEF libFuncInit
libFuncInit:
		DC.L	TROpen		; - 6
		DC.L	TRClose		; - C
		DC.L	TRExpunge	; -12 
		DC.L	TRExtFunc	; -18
		DC.L	Reader		; -1E
		DC.L	-1		; END OF TABLE MARKER

libFuncEnd:

libFuncSize	EQU	(libFuncEnd-libFuncInit)

		END



	TTL	'$Header: translator.asm,v 36.0 89/05/24 10:11:16 kodiak Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: translator.asm,v 36.0 89/05/24 10:11:16 kodiak Exp $
*
* $Locker:  $
*
* $Log:	translator.asm,v $
*   Revision 36.0  89/05/24  10:11:16  kodiak
*   *** empty log message ***
*   
* Revision 32.2  86/06/24  13:15:02  sam
* autodoc updates
* 
* Revision 32.1  86/01/22  01:17:52  sam
* placed under source control
* 
*
**********************************************************************
       	SECTION		reader




******* translator.library/Translate *******************************************
*
*    NAME
*	Translate - Converts an English string into phonemes
*
*    SYNOPSIS
*	rtnCode = Translate(instring, inlen, outbuf, outlen)
*	D0		    A0	      D0     A1	     D1
*
*	LONG rtnCode;
*	CPTR instring;
*	LONG inlen;
*	CPTR outbuf;
*	LONG outlen;
*
*    FUNCTION
*	The translate function converts an English string into
*	a string of phonetic codes suitable as input to the
*	narrator device.  
*
*    INPUTS
*	instring - pointer to English string
*	inlen	 - length of English string
*	outbuf   - a char array which will hold the phonetic codes
*	outlen   - the length of the output array
*	
*
*    RESULTS
*	rtnCode - 
*	    Translate will return a zero if no error has occured.
*	    The only error that can occur is overflowing the output
*	    buffer.  If Translate determines that an overflow will
*	    occur, it will stop the translation at a word boundary
*	    before the overflow happens.  If this occurs, Translate
*	    will return a negative number whose absolute value 
*	    indicates where in the INPUT string Translate stopped.
*	    The user can then use the offset -rtnCode from the
*	    beginning of the buffer in a subsequent Translate call
*	    to continue the translation where s/he left off.
*	
*    BUGS
*
*    SEE ALSO
*	translator.device/OpenLibrary, translator.device/CloseLibrary
********************************************************************************
*
*
*   REGISTER USAGE
*
*
*   IMPLEMENTAION
*
*
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                                   ;
*                  ENGLISH TO ARPABET TRANSLATOR                    ;
*                                                                   ;
*         CONVERTS ASCII ENGLISH STRING TO ASCII PHONETIC           ;
*         REPRESENTATION.  USES AN EXPANDED NRL RULE SYSTEM.        ;
*                                                                   ;
*         D0 - SCRATCH REGISTER         D1 - LETTER/SCRATCH         ;
*         D2 - SIZE OF HANDLE           D3 - WORD LENGTH            ;
*         D4 - LETTER FEATURE           D5 - SCRATCH                ;
*         D6 - VARIED                   D7 - DIRECTION TO FETCH     ;
*                                                                   ;
*         A0 - ENGLISH INPUT            A1 - PHONETIC OUTPUT        ;
*         A2 - BEG OF CNTR OF RULE      A3 - END OF CNTR OF RULE    ;
*         A4 - FEATURE MATRIX           A5 - PTR TO WORD BUFFER     ;
*         A6 - RULE BASE                A7 - STACK                  ;
*                                                                   ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	XDEF	Reader

*-------- SOME HANDY EQUATES

MAC	  EQU	    0
AMIGA     EQU       1


*-------- FRAME OFFSETS (FROM A5)

EXCPSHAN  EQU       0		;OFFSET TO EXCEPTIONS HANDLE
RULESHAN  EQU       4		;OFFSET TO RULES HANDLE
STOUTOFF  EQU       8		;OFFSET TO START OF OUTPUT
STINPOFF  EQU	    12		;OFFSET TO START OF INPUT
OUTPTR	  EQU	    16		;OFFSET TO ACCENTING RULE LAST POS
ACCFLAG	  EQU	    20		;OFFSET TO ACCENTING RULE FLAG
WORDBOFF  EQU       22		;OFFSET TO START OF WORD BUFFER
INLENOFF  EQU       130		;OFFSET TO INPUT LENGTH
OUTHDOFF  EQU       182		;OFFSET TO OUTPUT HANDLE

SYMCNT    EQU       12        	;NUMBER OF SPECIAL SYMBOLS
MAXLTRS   EQU       100        	;MAX NUMBER OF LETTERS IN A WORD


SYMBOL    EQU       $1
DIGIT     EQU       $2
UAFF      EQU       $4
VOICED    EQU       $8
SIBILANT  EQU       $10
CONS      EQU       $20
VOWEL     EQU       $40
LETTER    EQU       $80
FRONT     EQU       $100
IGNORE    EQU       $200
KEYWORD   EQU       $400
WORDBRK	  EQU	    $800

SYMBOLBIT  EQU        0
DIGITBIT   EQU        1
UAFFBIT    EQU        2
VOICEDBIT  EQU        3
SIBILBIT   EQU        4
CONSBIT    EQU        5
VOWELBIT   EQU        6
LETTERBIT  EQU        7
FRONTBIT   EQU        8
IGNOREBIT  EQU        9
KEYWORDBIT EQU        10
WORDBRKBIT EQU	      11



*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
*                  INITIALIZATION CODE                    ;
*                                                         ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


	  IFNE	     MAC		;INITIALIZATION, MAC VERSION:

*-------- INSURE NON-NIL OUTPUT HANDLE


          MOVE.L    4(SP),A0            ;    GET OUTPUT HANDLE
          CMP.L     #0,A0               ;    NIL?
          BNE.S     GOTHANDLE           ;    NO, BRANCH
          MOVE.W    #nilHandleErr,D0    ;    YES, SET HANDLE ERROR


*-------- NIL HANDLE, RETURN AN ERROR

HANDLERR  MOVE.L    (SP),8(SP)          ;    MOVE RTN ADDR
          ADDQ.L    #8,SP               ;    FIX STACK
          MOVE.W    D0,4(SP)            ;    SET ERROR RC
          RTS


*-------- HAVE A NON-NIL HANDLE. IF HANDLESIZE <> 0 WE HAVE A BUFFER
*         IF =0 WE WILL ALLOCATE A 1K BUFFER

GOTHANDLE MOVE.L    (A0),D0             ;    GET MASTER POINTER
          AND.L     LO3BYTES,D0         ;    USE 24 BIT ADDRESSING
          BNE.S     GOTBUFFER           ;    BRANCH IF HAVE A BUFFER,
          MOVE.L    #1024,D0            ;    ELSE, ALLOCATE 1K BUFFER
*          _ReallocHandle                ;
          BNE.S     HANDLERR            ;    ERROR, PROPIGATE ERR CODE D0


*-------- GOT A BUFFER, LOCK IT AND DEREFERENCE TO POINTER

*GOTBUFFER _HLock                        ;    LOCK IT
          BNE.S     HANDLERR            ;    CANT, PROPIGATE ERR CODE (D0)
*          _GetHandleSize                ;    GET LOGICAL BLOCK SIZE
          MOVE.L    D0,D2               ;    SET D2 TO LOGICAL BLOCK SIZE
          MOVE.L    (A0),D0             ;    DEREFERNCE HANDLE
	  AND.L     LO3BYTES,D0 	;    USE 24 BIT ADDRESSING
	  MOVE.L    D0,A1		;    PUT IN A0
          ENDC

*-------- END OF MAC INITIALIZATION ------------------------------------




*          IFNE      AMIGA               ;INITIALIZATION, AMIGA VERSION:
*Reader	  MOVE.L    4(SP),A1            ;    GET ADDRESS OF OUTPUT BFR
*          ENDC

*-------- END OF AMIGA INITIALIZATION ----------------------------------





*          MOVE.L    12(SP),A0           ;GET ENGLISH STRING
*          MOVE.L    8(SP),D0            ;GET ENGLISH STRING LENGTH
*	  IFNE	    AMIGA
*	  MOVE.L    16(SP),D1           ;GET LENGTH OF OUTPUT (AMIGA ONLY)
*	  ENDC

Reader    MOVEM.L   A2-A6/D2-D7,-(SP)   ;SAVE REGISTERS
	  IFNE	    AMIGA
	  MOVE.L    D1,D2
	  SUBQ.L    #5,D2		;REDUCE MAX OUTPUT TO INSURE NO OVERFLOW
	  ENDC

*-------- ;Create stack frame

	  MOVE.L    D0,-(SP)		;SAVE LENGTH OF INPUT IN FRAME
	  
          MOVE.L    #'    ',D0  	;CLEAR WORD BUFFER (108 BYTES)
          MOVEQ     #26,D1
CLEARWDBF MOVE.L    D0,-(SP)
          DBF       D1,CLEARWDBF

	  CLR.W	    -(SP)		;ACCENTING CODE - ACCFLAG	  
	  MOVE.L    A1,-(SP)		;ACCENTING CODE - LAST POS PTR

	  MOVE.L    A0,-(SP)		;START OF INPUT
          MOVE.L    A1,-(SP)            ;SAVE START OF OUTPUT
	  CLR.L     -(SP)		;SPACE FOR RULES HANDLE	  
	  CLR.L     -(SP)		;SPACE FOR EXCEPTIONS HANDLE	  

          MOVE.L    SP,A5		;SAVE FRAME POINTER

	  IFNE	    MAC
	  MOVE.L    A0,A2		;SAVE POINTER TO ENGLISH STRING
	  MOVE.L    A1,A4		;SAVE POINTER TO START OF OUTPUT
	  MOVE.W    #129,-(SP)		;GET RULES
	  BSR       GetRuleSet
	  BNE.S	    ERROR
	  MOVE.L    A0,RULESHAN(A5)	;SAVE IN FRAME
 	  
 	  MOVE.W    #130,-(SP)		;GET EXCEPTIONS
	  BSR	    GetRuleSet
	  BEQ.S	    GOTEXCP		;GOT EXCEPTIONS
	  CMP.W	    #memFullErr,D0	;CHECK RETURN CODE
	  BNE.S	    GOTEXCP		;EXCEPTIONS NOT FOUND, ONLY USE RULES

*-------- Could not load exceptions into memory, fatal error

	  MOVE.L    RULESHAN(A5),A0	;GET RULES HANDLE
	  MOVE.W    D0,-(SP)		;SAVE ERROR RETURN
*	  _HPurge			;MAKE RULES RESOURCE PURGEABLE
	  MOVE.W    (SP)+,D0		;RESTORE ERROR RETURN
	  BRA.S	    ERROR		;RETURN

GOTEXCP   MOVE.L    A0,EXCPSHAN(A5)	;SAVE EXCEPTIONS HANDLE IN FRAME
	  BEQ.S	    NOEXCPS		;EXCPS HANDLE NIL, NO EXCPS
*	  _HLock			;LOCK EXCPS HANDLE
NOEXCPS	  MOVE.L    RULESHAN(A5),A0	;GET RULES HANDLE
*	  _HLock			;LOCK IT

	  MOVE.L    A2,A0		;RESTORE ENGLISH POINTER
	  MOVE.L    A4,A1		;RESTORE START OF OUTPUT POINTER
	  ENDC

	  IFNE	    AMIGA
	  MOVE.L    #0,EXCPSHAN(A5)	;    NO EXCPS ARE TO BE USED
	  ENDC

          MOVEQ     #0,D0		;CLEAR SOME REGISTERS (DON'T CLEAR D2!!)
          MOVEQ     #0,D1
          MOVEQ     #0,D3
          MOVEQ     #0,D4
          MOVEQ     #0,D5
          MOVEQ     #0,D6
          MOVEQ     #0,D7

	  LEA	    WORDBOFF+2(A5),A2	;POINTER TO BEGINNING OF WORD BUFFER
          LEA       FEATURES,A4         ;POINTER TO LETTER FEATURES

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
*         MAIN LOOP.                                      ;
*         1)  CHECK TO SEE IF A '#' WAS INSERTED,         ;
*             INDICATING THAT THE INPUT STRING HAS BEEN   ;
*             ENTIRELY PROCESSED,                         ;
*         2)  IF NOT END OF WORD, CONTINUE PROCESSING     ;
*             WITH NEXT LETTER/COMBINATION,               ;
*         3)  IF END OF WORD, CALL PRE-PROCESSOR FOR      ;
*             NEXT WORD.                                  ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

WORDC     CMPI.B    #'#',-1(A1)
          BEQ       RETURN              ;IF "#" INSERTED, END OF STRING
          CMPI.B    #' ',-1(A2)         ;IF BLANK PROCESSED, GET NEXT WORD
          BNE       WORDC1

NEXTWORD:
          BSR       PREPROC             ;GET NEXT WORD FROM ENGLISH
          MOVE.W    D3,-(SP)		;SAVE RETURN CODE    
          BSR       ACCENTER		;ACCENT THE PREVIOUS WORD
	  MOVE.W    (SP)+,D3		;RESTORE RETURN CODE
          BMI.S     FIXUP               ;OVERFLOW MAX # LTRS IN WORD
          BEQ.S     RETURN              ;NOTHING LEFT, GO AWAY
	  LEA	    WORDBOFF+2(A5),A2	;POINT TO BEGINNING OF STRING
          BRA.S     WORDC0

ERROR     MOVE.W    D0,D1               ;SET BAD RETURN CODE
          BRA.S     FIXUP               ;COMMON RETURN CODE

RETURN    MOVEQ     #0,D1
	  BSR	    ACCENTER
	  IFNE	AMIGA
	  MOVE.B    #0,-1(A1)		;Change # to a NULL
	  ENDC


FIXUP:
	  IFNE	    MAC	
	  MOVE.W    D1,-(SP)		;SAVE RETURN CODE
	  MOVE.L    RULESHAN(A5),A0	;GET RULES HANDLE
	  CMP.L	    #0,A0		;NIL?
	  BEQ.S	    FIX1		;YES, SKIP
*	  _HUnlock			;UNLOCK RESOURCE
*	  _HPurge			;MAKE IT PURGEABLE
FIX1	  MOVE.L    EXCPSHAN(A5),A0	;GET EXCEPTIONS HANDLE
	  CMP.L     #0,A0		;NIL?
	  BEQ.S	    FIX2		;YES, SKIP
*	  _HUnlock			;UNLOCK IT
*	  _HPurge			;MAKE IT PURGEABLE
FIX2	  MOVE.W    (SP)+,D1		;RESTORE RETURN CODE
	  ENDC

          MOVE.L    A1,D0               ;GET CURRENT OUTPUT POS
          SUB.L     STOUTOFF(A5),D0     ;COMPUTE LENGTH OF OUTPUT

          ADD.L     #134,SP             ;REMOVE FRAME FROM STACK
          MOVEM.L   (SP)+,A2-A6/D2-D7   ;RESTORE REGISTERS

          IFNE      MAC                 ;MACINTOSH CLEANUP
          MOVE.L    4(SP),A0            ;   GET OUTPUT HANDLE
*          _SetHandleSize                ;   SET SIZE TO OUTPUT SIZE
*          _HUnlock                      ;   UNLOCK HANDLE
          ENDC

	  IFNE 	MAC
          MOVE.L    (SP),12(SP)         ;MOVE RETURN ADDRESS
          ADD.L     #12,SP              ;REMOVE PARMS FROM STACK
          MOVE.W    D1,4(SP)            ;STORE RETURN CODE
	  ENDC

	  IFNE	AMIGA
	  MOVE.W    D1,D0
	  EXT.L	    D0
	  ENDC

          RTS                           ;RETURN TO PASCAL

WORDC0	  MOVE.L    EXCPSHAN(A5),A6	;DO EXCPS RULES
	  CMP.L	    #0,A6		;NIL?
	  BEQ.S	    WORDC1		;YES, SKIP EXCPS
	  MOVE.L    (A6),A6		;DEREFERENCE TO POINTER
	  BSR	    CINDEX		;FIND RULE GROUP
	  BSR	    CHECK		;DO EXCP CHECKING
	  BEQ.S	    WORDC1		;NO EXCP RULE APPLIED, DO BASIC RULES
	  BMI	    ERROR		;REPLACE OVFL, COULD NOT GET MORE MEM
	  BRA	    WORDC		;EXCP RULE APPLIED, GET NEXT WORD

WORDC1	  MOVE.L    RULESHAN(A5),A6	;DO BASIC RULES
	  MOVE.L    (A6),A6		;DEREFERENCE TO POINTER
	  IFNE	    AMIGA
	  LEA	    RULEBASE,A6
	  ENDC
	  BSR	    CINDEX		;FIND RULE GROUP
	  BSR	    CHECK		;DO EXCP CHECKING
	  TST.W	    D7
	  BMI	    ERROR		;REPLACE OVFL, COULD NOT GET MORE MEM
	  BRA	    WORDC		;EXCP RULE APPLIED, GET NEXT WORD

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
*              DO RULE CHECKING				  ;
*                                                         ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CHECK	BSR	CHKCENTR		;CHECK CENTER CONTEXT
	BNE.S	NEXTRULE		;UNSUCCESSFUL
	MOVE.L	A2,-(SP)		;SAVE PTR TO BEG OF CENTER
	MOVE.L	A3,-(SP)		;SAVE PTR TO END OF CENTER
	BSR	CHKLEFT			;CHECK LEFT CONTEXT
	BNE	LNEXTRULE		;UNSUCCESSFUL
	BSR	CHKRIGHT		;CHECK RIGHT CONTEXT
	BNE	LNEXTRULE		;UNSUCCESSFUL
	BSR 	REPLACE			;DO REPLACEMENT
	MOVE.L	(SP)+,A2		;MAKE END OF CENTER, BEG OF CENTER
	ADDQ.L	#4,SP			;REMOVE OLD BEG OF CENTER
	RTS


*------ Find next rule in ruleset
LNEXTRULE 	MOVE.L	(SP)+,A3	;REMOVE END OF CENTER
		MOVE.L	(SP)+,A2	;REMOVE BEG OF CENTER
NEXTRULE	MOVE.B	(A6)+,D7	;GET NEXT CHAR FROM RULE
		CMP.B	#'\',D7		;END OF RULE?
		BEQ.S	CHECK		;YES
		CMP.B	#'`',D7		;OTHER END OF RULE?
		BEQ.S	CHECK		;YES
		BRA.S	NEXTRULE	;NOT END OF RULE, KEEP LOOKING

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
*              COMPUTE INDEX INTO RULESET		  ;
*	A2 - Pointer to next char in word		  ;
*	A6 - Pointer to EXCP/RULE set			  ;
*	A4 - Features					  ;
*							  ;
*	RETURNS:					  ;
*	D1 - SCRATCH					  ;
*	D4 - Features					  ;
*	A6 - Pointer to letter group of rules		  ;
*                                                         ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CINDEX	MOVEQ	#0,D1		;CLEAR SCRATCH REG
	MOVE.B	(A2),D1		;GET CHAR FROM WORD BUFFER
	MOVE.W	D1,D4		;COPY
	LSL.W	#1,D4		;SHIFT FOR FEAT INDEX
	MOVE.W	0(A4,D4),D4	;GET FEATURES
	BTST	#LETTERBIT,D4   ;LETTER?
	BNE.S	CLETTER		;YES

CSYMBOL	MOVE.B	#'Z'+1,D1	;SET RULE PTR TO 'Z'+1 RULESET
	BTST	#DIGITBIT,D4	;DIGIT?
	BNE.S	CLETTER		;YES, USE 'Z'+1 RULES
CDIGIT  ADDQ.B	#1,D1		;NO, USE 'Z'+2 RULES

CLETTER	SUB.B	#'A',D1		;CONVERT TO 'A OFFSET'
	LSL.W	#2,D1		;ADJUST FOR RULE INDEXING
	MOVE.L	0(A6,D1),A3	;GET OFFSET LETTER RULE GROUP
	ADD.L	A3,A6		;CREATE PTR TO RULE GROUP
	RTS

	IFNE	MAC
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
*              READ A RULESET FROM DISK			  ;
*                                                         ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

GetRuleSet:
	MOVE.L	(SP)+,A0	;GET RETURN ADDR
	MOVE.W	(SP)+,D7	;GET RESOURCE ID
	MOVE.L  A0,-(SP)	;RESTORE RETURN ADDR
	MOVEQ	#0,D0		;SET GOOD RETURN CODE
	MOVE.L  xxxxx,A0	;ADDR OF RULE RESOURCE
	RTS			;RETURN

	ENDC
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
*              CHECK CENTER PORTION OF RULE               ;
*                                                         ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CHKCENTR  MOVEQ     #0,D6               ;CLEAR INDEX INTO RULE
          MOVEQ     #-1,D7              ;SET TEMP REG
          MOVE.L    A2,A3

*         FIND '[', BEGINS CENTER PORTION OF RULE

CLTR1     MOVE.B    0(A6,D6),D5         ;GET BYTE FROM RULE
          ADDQ.W    #1,D6               ;BUMP RULE INDEX
          CMP.B     #'[',D5             ;IS RULE CHAR='['?
          BNE.S     CLTR1               ;NO, KEEP LOOKING
          ADD.W     D6,D7               ;D7 POINTS TO '['
          SWAP      D6                  ;D6 = POS OF CENTER,0
          MOVE.W    D7,D6               ;D6 = POS OF CENTER, POS OF '['
          SWAP      D6                  ;D6 = POS OF '[', POS OF CENTER

*         CHECK CENTER PORTION.  ONLY LETTER MATCHING IS ALLOWED.
*         CONTINUE CHECKING UNTIL ']' (RIGHT CONTEXT DELIMITER)
*         IS FOUND.

CLTR2     MOVE.B    0(A6,D6),D5         ;GET RULE CHAR
          ADDQ.W    #1,D6               ;BUMP RULE INDEX
          CMP.B     #']',D5             ;END OF CENTER CONTEXT?
          BEQ.S     CENTRTN             ;YES, CHECK LEFT CONTEXT
          CMP.B     (A3)+,D5            ;RULE CHAR MATCH ENG CHAR?
          BEQ.S     CLTR2               ;YES, CONTINUE WITH NEXT RULE CHAR

CENTRTN   RTS

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
*            CHECK 'LEFT' PORTION OF RULE                 ;
*                                                         ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CHKLEFT   SWAP      D6                  ;POS OF RIGHT CONTEXT, POS OF '['

CHKLEFT1  SUBQ.W    #1,D6               ;MOVE LEFT ONE CHAR
          BMI.S     CHKLEFTR            ;DONE, RETURN WITH GOOD RC
          MOVE.B    0(A6,D6),D5         ;GET RULE CHAR
          MOVE.W    D5,D4
          LSL.B     #1,D4               ;FEATURE MATRIX INDEX
          MOVE.W    0(A4,D4),D4         ;GET FEATURES
          BTST      #KEYWORDBIT,D4      ;SPECIAL SYMBOL?
          BNE.S     LSYMBOL             ;YES
          CMP.B     -(A2),D5            ;NO, COMPARE WITH LEFT CHAR
          BEQ.S     CHKLEFT1            ;IF MATCH, CONTINUE
	  RTS
CHKLEFTR  MOVE.W    #$04,CCR		;SET SUCCESSFUL RC
	  RTS

LSYMBOL   MOVEQ     #1,D7               ;SET LEFT MOVING FETCH
          BSR       SYMHDLR             ;GO DO SYMBOL CHECKING
          BNE.S     CHKLEFT1            ;RULE WAS SUCCESSFUL
	  MOVE.W    #$00,CCR		;UNSUCCESSFUL RC
	  RTS



*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
*            CHECK 'RIGHT' PORTION OF RULE                ;
*                                                         ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CHKRIGHT  MOVE.L    4(SP),A2            ;GET RIGHT POINTER INTO A2
          SWAP      D6                  ;RESTORE RIGHT CONTEXT POINTER
*                                       ;   IN LOWER HALF OF D6
CHKR1     MOVE.B    0(A6,D6),D5         ;GET RULE CHAR
          ADDQ.W    #1,D6
          CMP.B     #'=',D5             ;END OF RIGHT CONTEXT?
          BEQ.S     CHKRRTN             ;YES, DO REPLACEMENT
          MOVE.W    D5,D4
          LSL.B     #1,D4
          MOVE.W    0(A4,D4),D4         ;GET FEATURES
          BTST      #KEYWORDBIT,D4      ;SPECIAL SYMBOL?
          BNE.S     RSYMBOL             ;YES, TRY SYMBOL
          CMP.B     (A2)+,D5            ;NO, COMPARE WITH RULE CHAR
          BEQ.S     CHKR1               ;IF MATCH, CONTINUE CHECKING
CHKRRTN   RTS

RSYMBOL   MOVEQ     #-1,D7              ;SET RIGHT FETCHES
          BSR       SYMHDLR             ;GO DO SYMBOL CHECKING
          BNE.S     CHKR1               ;RULE WAS SUCCESSFUL
	  MOVE.W    #$00,CCR		;SET RC (BAD)
	  RTS


*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
*       EVERYTHING IS JUST GREAT, DO REPLACEMENT          ;
*                                                         ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

REPLACE:
*         FIND LENGTH OF REPLACEMENT TEXT

          MOVE.W    D6,D7               ;CURRENT POS
          SUBQ.W    #1,D7               ;BACKUP IN PREPARATION
REPL1     ADDQ.W    #1,D7               ;MOVE FORWARD ONE CHAR
	  MOVE.B    0(A6,D7),D0		;GET RULE CHAR
          CMP.B     #'\',D0		;AT END?
          BEQ.S     REPL1X              ;YES
	  CMP.B     #'`',D0		;AT END?
	  BNE.S	    REPL1		;NO, CONTINUE LOOKING
REPL1X    SUB.W     D6,D7               ;COMPUTE LENGTH OF REPL TEXT
	  BNE.S	    REPL2		;
	  RTS				;ZERO REPLACEMENT LENGTH

*         INSURE THAT REPLACEMENT TEXT WILL FIT IN OUTPUT

REPL2     MOVE.L    A1,D0               ;GET CURRENT POS
          SUB.L     STOUTOFF(A5),D0     ;COMPUTE NUMBER OF BYTES IN OUTPUT
          ADD.W     D7,D0               ;NEW LENGTH
          CMP.W     D2,D0               ;BIGGER THAN BLOCK SIZE?
          BGE.S     OVERFLOW            ;YES, DO OVERFLOW PROCESSING

*         NEW TEXT FITS IN OUTPUT

DOREPLCE  AND.L     #$0000FFFF,D6       ;CLEAR UPPER HALF OF D6
          ADD.L     D6,A6               ;POINT A6 TO BEG OF REPL TEXT
	  MOVE.W    D7,-(SP)		;SAVE LENGTH OF REPLACEMENT
          BRA.S     REPBLOOP            ;BEGIN LOOP
REPLOOP   MOVE.B    (A6)+,(A1)+         ;MOVE CHARS
REPBLOOP  DBF       D7,REPLOOP          ;LOOP FOR LENGTH OF REPL TEXT
	  MOVE.W    (SP)+,D7		;RESTORE REPLACEMENT LENGTH
* If last rule did not output a letter, don't flip accent flag
	MOVE.L	D0,-(SP)
	MOVEQ	#0,D0
	MOVE.B	-1(A1),D0	;get last char of output
	ADD.W	D0,D0
	MOVE.W	0(A4,D0),D0
	BTST	#LETTERBIT,D0	;a letter?
	BEQ.S	REPLOOP1	;no, don't flip flag
* If last rule was an exception, clear the accent flag
	BSET	#0,ACCFLAG(A5)
	CMP.B	#'`',(A6)	;from an exception?
	BNE.S	REPLOOP1	;no, branch
	BCLR	#0,ACCFLAG(A5)	;yes, clear accent flag
REPLOOP1 MOVE.L (SP)+,D0
	RTS
*
          IFNE      MAC                 ;OVERFLOW, MAC VERSION
OVERFLOW  MOVE.L    A0,-(SP)            ;   SAVE A0
          MOVE.L    OUTHDOFF(A5),A0     ;   GET OUTPUT HANDLE
*	  _HUnlock			;   UNLOCK HANDLE
*          _GetHandleSize                ;   GET CURRENT HANDLE SIZE
          ADD.L     #1024,D0            ;   GROW BY 1K BYTES
          MOVE.L    D0,D2               ;   SET NEW OUTPUT SIZE LIMIT
*          _SetHandleSize                ;   DO THE GROWING
	  MOVE.L    D0,D1		;   SAVE THE RC
*	  _HLock			;   LOCK HANDLE
	  MOVE.L    A1,D0		;   COPY CURRENT POS OF OUTPUT
	  SUB.L	    STOUTOFF(A5),D0	;   COMPUTE LENGTH OF OUTPUT
	  ADD.L     (A0),D0		;   COMPUTE NEW POSITION
	  AND.L	    LO3BYTES,D0		;   USE 24 BIT ADDR
	  MOVE.L    D0,A1		;   CURRENT POS INTO A1
	  MOVE.L    (A0),D0	 	;   DEREFERENCE HANDLE
	  AND.L     LO#BYTES,D0		;   24 BIT ADDR
	  MOVE.L    D0,STOUTOFF(A5)	;   RESET BEGINNING OF OUTPUT
          MOVE.L    (SP)+,A0            ;   RESTORE A0
	  MOVE.L    D1,D0		;   CHECK RETURN CODE
	  BEQ.S     DOREPLACE	 	;   ABLE TO GROW, CONTINUE
	  RTS				;   CAN'T GROW, RETURN WITH ERROR 
          ENDC

          IFNE      AMIGA               ;OVERFLOW, AMIGA VERSION
OVERFLOW:
	  MOVEQ     #0,D0
	  MOVE.B    -1(A1),D0		;WAS LAST CHAR INSERTED A WORD BREAK?	
	  LSL.W	    #1,D0
	  MOVE.W    0(A4,D0),D0
	  BTST	    #WORDBRKBIT,D0
	  BNE.S     OVERFL1		;YES
OVERFL2	  MOVEQ	    #0,D0
	  MOVE.B    -(A1),D0
	  LSL.W	    #1,D0
	  MOVE.W    0(A4,D0),D0
	  BTST	    #WORDBRKBIT,D0
	  BEQ.S     OVERFL2
	  LEA	    1(A1),A1
	  
OVERFL1	  MOVE.B    #0,(A1)+            ;PUT IN A NULL
*          MOVE.B    #0,(A1)           	;NULL TERMINATE STRING
          SUB.L     D3,A0               ;ADJUST ENGLISH STRING POINTER
	  MOVE.L    A0,D0
	  SUB.L	    STINPOFF(A5),D0
	  NEG.L	    D0	  
	  MOVE.L    D0,D1
	  MOVE.L    D0,D7
	  RTS
          ENDC


*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
*           GIVEN A SPECIAL SYMBOL IN D5, FIND AND        ;
*           EXECUTE THE APPROPRIATE ROUTINE               ;
*                                                         ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SYMHDLR   LEA       SYMLIST,A3          ;LIST OF SPECIAL SYMBOLS
          MOVE.W    #SYMCNT-1,D0
SYMHDLR1  CMP.B     (A3)+,D5
          DBEQ      D0,SYMHDLR1
          NEG.W     D0
          ADD.W     #SYMCNT-1,D0
          LSL.W     #2,D0               ;FOUND OFFSET TO SPECIAL SYMBOL
          LEA       SYMBASE,A3          ;GET BASE OF SYMBOL ROUTINES

          IFNE      MAC                 ;COMPUTE ROUTINE ADDRESS, MAC
          MOVE.L    0(A3,D0),D0         ;GET SPECIFIC SYMBOL ROUTINE
          LEA       READER,A3
          ADD.L     D0,A3               ;ADD IN START OF PGM FOR OFFSET
          ENDC

          IFNE      AMIGA               ;COMPUTE ROUTINE ADDRESS, AMIGA
          MOVE.L    0(A3,D0),A3         ;GET SPECIFIC SYMBOL ROUTINE
          ENDC

          JSR       (A3)                ;GO DO IT
          RTS                           ;AND RETURN



*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
*      FETCHES A CHARACTER FROM THE 'WORD' BUFFER         ;
*      INTO D1 AND ASSOCIATED FEATURES INTO D4.           ;
*      ON ENTRY D7 CONTAINS A +IVE VALUE IF THE CHAR      ;
*      IS TO BE FETCHED FROM THE LEFT AND A -IVE VALUE    ;
*      IF THE FETCHING IS TO BE DONE FROM THE RIGHT       ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FETCH     TST.W     D7                  ;CHECK D7
          BMI.S     FETCH1              ;-IVE, LOOK TO THE RIGHT
          MOVE.B    -(A2),D1            ;GET CHAR ON LEFT
          BRA.S     FETCH2              ;GO GET FEATURES
FETCH1    MOVE.B    (A2)+,D1            ;GET CHAR ON RIGHT
FETCH2    MOVEQ     #0,D4
          MOVE.B    D1,D4
          LSL.B     #1,D4
          MOVE.W    0(A4,D4),D4         ;GET FEATURES
          RTS



*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
*      THE FOLLOWING SUBROUTINES HANDLE CHECKS FOR        ;
*      THE VARIOUS SPECIAL SYMBOLS THAT COULD APPEAR      ;
*      IN A RULE.  ALL SET CC = 0 IF THE RULE DOES NOT    ;
*      APPLY, AND INSURE CC != 0 IF RULE DOES APPLY.      ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


*
*         CHECK FOR A SINGLE VOWEL
*

SVOWEL    BSR       FETCH               ;GET CHAR (AND FEATURES) FROM ENG
          BTST      #VOWELBIT,D4        ;DO TEST FOR VOWEL
          RTS


*
*         CHECK FOR ONE OR MORE CONSONANT
*

OMCONS    BSR       FETCH               ;GET NEXT CHAR
          BTST      #CONSBIT,D4
          BEQ.S     OMCONS1             ;NOT A CONSONANT, RULE FAILS
OMCONS0   BSR       FETCH               ;AT LEAST ONE CONS, KEEP LOOKING
          BTST      #CONSBIT,D4         ;
          BNE.S     OMCONS0             ;GET EM ALL
          MOVE.W    #$08,CCR            ;SET N BIT, CLEAR Z BIT, GOOD RTN
OMCONS1   RTS
*
*         CHECK FOR A SINGLE VOICED CONSONANT
*

SVCONS    BSR       FETCH               ;GET CHAR AND FEATURES
          BTST      #VOICEDBIT,D4       ;VOICED?
          BEQ.S     SVCONS1             ;NO, RETURN
          BTST      #CONSBIT,D4         ;CONSONANT?
SVCONS1   RTS                           ;RETURN, RC IS IMPLICITLY SET


*
*         CHECK FOR A SINGLE CONSONANT FOLLOWED BY AN 'I' OR 'E'
*

SCONSIE   BSR       FETCH               ;GET CHAR AND FEATURES
          BTST      #CONSBIT,D4         ;CONSONANT?
          BEQ.S     SCONSIE2            ;NO, RETURN
          BSR       FETCH               ;GET NEXT CHAR AND FEATURES
          CMP.B     #'I',D1             ;IS IT AN 'I'?
          BEQ.S     SCONSIE1            ;YES
          CMP.B     #'E',D1             ;IS IT AN 'E'?
          BEQ.S     SCONSIE1            ;YES
          MOVE.W    #$04,CCR            ;NO, BAD RETURN, SET Z BIT
          RTS                           ;   AND RETURN
SCONSIE1  MOVE.W    #$08,CCR            ;SET N BIT, GOOD RETURN
SCONSIE2  RTS


*
*         CHECK FOR ONE OF THE FOLLOWING SUFFIXES:
*         E, ES, ED, ER, ING, ELY, ERS OR INGS.
*

SUFFIXES  BSR       FETCH
          CMP.B     #'E',D1             ;IS IT AN E?
          BNE.S     SUFFI               ;NO, TRY AN I ENDING SUFFIX
          BSR       FETCH
          BTST      #LETTERBIT,D4
          BEQ.S     SUFFOK
          CMP.B     #'S',D1
          BEQ.S     SUFFCK              ;ES
          CMP.B     #'D',D1
          BEQ.S     SUFFCK              ;ED
          CMP.B     #'R',D1
*         BEQ.S     SUFFCK              ;ER		!!!sam 10/26/85!!!
          BEQ.S     SUFFS               ;ER		!!!sam 10/26/85!!!
          CMP.B     #'L',D1
          BNE.S     SUFFNO
          BSR       FETCH
          CMP.B     #'Y',D1
          BEQ.S     SUFFCK              ;ELY
          BRA.S     SUFFNO
SUFFI     BSR       FETCH
          CMP.B     #'N',D1
          BNE.S     SUFFNO
          BSR       FETCH
          CMP.B     #'G',D1
          BNE.S     SUFFNO              ;ING
SUFFS     BSR       FETCH				!!!sam 10/26/85!!!
          BTST      #LETTERBIT,D4			!!!sam 10/26/85!!!
          BEQ.S     SUFFOK				!!!sam 10/26/85!!!
          CMP.B     #'S',D1				!!!sam 10/26/85!!!
          BNE.S     SUFFNO              ;INGS OR ERS	!!!sam 10/26/85!!!
SUFFCK    BSR       FETCH
          BTST      #LETTERBIT,D4
          BEQ.S     SUFFOK
SUFFNO    MOVE.W    #$04,CCR            ;BAD RETURN
          RTS
SUFFOK    MOVE.W    #$08,CCR            ;GOOD RETURN
          RTS


*
*         CHECK FOR A SIBILANT
*

SIBIL     BSR       FETCH
          BTST      #SIBILBIT,D4
          RTS


*
*         CHECK FOR A CONSONANT WITH A U AFFECTATION
*

CUAFF     BSR       FETCH
          BTST      #UAFFBIT,D4
          RTS


*
*         CHECK FOR A SINGLE CONSONANT
*

SCONS     BSR       FETCH
          BTST      #CONSBIT,D4
          RTS


*
*         CHECK FOR A FRONT VOWEL
*

FVOWEL    BSR       FETCH
          BTST      #FRONTBIT,D4
          RTS


*
*         CHECK FOR ZERO OR MORE CONSONANT
*

ZMCONS    BSR       FETCH
          BTST      #CONSBIT,D4
          BNE.S     ZMCONS
          ADD.L     D7,A2               ;FIXUP A2
          MOVE.W    #$08,CCR            ;GOOD RC
          RTS


*
*         CHECK FOR A SINGLE NUMERAL (DIGIT)
*

SNUM      BSR       FETCH
          BTST      #DIGITBIT,D4
          RTS


*
*         CHECK FOR ZERO OR MORE NUMERALS (DIGITS)
*

ZMNUMS    BSR       FETCH
          BTST      #DIGITBIT,D4
          BNE.S     ZMNUMS
          ADD.L     D7,A2               ;FIXUP A2
          MOVE.W    #$08,CCR            ;GOOD RETURN
          RTS


*
*         CHECK FOR A NON LETTER
*

NONLTR    BSR       FETCH
          BTST      #LETTERBIT,D4       ;LETTER BIT ON?
          BNE.S     NONLTR1             ;YES, RULE FAILS
          MOVE.W    #$08,CCR            ;RULE CHECKS, SET GOOD RETURN
          RTS
NONLTR1   MOVE.W    #$04,CCR            ;RULE FAILS, SET BAD RETURN
          RTS




*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
*                     PREPROCESSOR                        ;
*                                                         ;
*      CURRENTLY THE PREPROCESSOR ISOLATES WORDS,         ;
*      CHECKS TO SEE THAT THE CHARACTERS ARE VALID        ;
*      ASCII CODES, AND CONVERTS LOWER CASE TO UPPER      ;
*      CASE.  THE LENGTH OF THE WORD IS RETURNED IN       ;
*      D3.                                                ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PREPROC   LEA	    WORDBOFF(A5),A2     ;POINTER TO WORD BUFFER
          MOVE.B    0(A2,D3),(A2)+      ;GET LAST CHAR OF PREVIOUS WORD
          MOVE.B    #' ',(A2)+          ;MOVE IN A BLANK
          MOVEQ     #0,D0               ;CLEAR SOME REGS
          MOVEQ     #0,D1
          MOVEQ     #0,D3
          TST.L     INLENOFF(A5)
          BLE.S     PREATEND
PREMAIN   MOVE.B    D1,D0
          MOVE.B    (A0)+,D1            ;GET CHAR FROM ENGLISH STRING
	  IFNE	    AMIGA               ;IF AMIGA,
	  BNE.S	    PRENOTNUL		;   IF NEXT CHAR IS A NULL, PROCESS
	  MOVE.L    #1,INLENOFF(A5)	;   THIS WORD, THEN TERMINATE INPUT
	  ENDC
PRENOTNUL CMP.B     #' ',D1             ;CHECK AGAINST ASCII BLANK
          BGE.S     PREAT0              ;GREATER OR EQUAL, USE CHAR
          MOVE.B    #' ',D1             ;NOT AN ASCII CHAR, SUBST A BLANK
PREAT0    CMP.B     #$7F,D1             ;CHECK AGAINST DEL CHAR
          BNE.S     PREAT00             ;NOT A DEL
          MOVE.B    #' ',D1             ;NOT AN ASCII CHAR, SUBST A BLANK
PREAT00   CMP.B     #'a',D1             ;CHECK FOR LOWER CASE
          BLT.S     PRENOTLC
          CMP.B     #'z',D1
          BGT.S     PRENOTLC
          SUB.B     #'a'-'A',D1         ;IF LOWER CASE, CONVERT TO UC

PRENOTLC  CMP.B     #']',D1             ;RT BRACKET (RULE DELIM) MUST BE
          BNE.S     PREAT1              ;   REMOVED TO PREVENT DEATH
          MOVE.B    #' ',D1             ;   INSERT A BLANK IN ITS PLACE
PREAT1    ADDQ.W    #1,D3               ;BUMP COUNT OF LETTERS IN WORD
          CMP.W     #MAXLTRS,D3         ;OVERFLOW?
          BGT.S     PREERROR
          MOVE.B    D1,(A2)+            ;MOVE CHAR TO WORD
          CMP.B     #' ',D0             ;WAS LAST CHAR A BLANK
          BEQ.S     PREWRDND            ;YES, RETURN
          SUBQ.L    #1,INLENOFF(A5)     ;REDUCE COUNT OF REMAINING LTRS
          BEQ.S     PREGONE             ;IF ZERO, INSERT '#' AND GO AWAY
          CMP.B     #'#',D1             ;HAVE WE REACHED END OF INPUT STRING
          BNE.S     PREMAIN             ;NO, CONTINUE
          CMP.B     #'#',D0             ;MAYBE, LOOK FURTHER
          BNE.S     PREMAIN             ;NO, CONTINUE
          CMP.B     #2,D3               ;IF ONLY 2
          BNE.S     PRETEST
PREATEND:
          MOVE.B    #'#',(A1)+
          MOVEQ     #0,D3
          RTS

PRETEST   SUBQ.L    #1,A0               ;YES, BACK UP TO '##'S IN ENGLISH
          MOVE.B    #' ',-2(A2)         ;ADD A BLANK AFTER LAST WORD
          SUBQ.W    #1,D3               ;FIXUP COUNT OF LETTERS

PREWRDND  SUBQ.L    #1,A0               ;A0 --> 1ST LETTER OF NEXT WORD
          SUBQ.W    #1,D3               ;REDUCE LENGTH OF WORD
          RTS

PREERROR  MOVEQ     #-3,D1              ;SET FOR BAD RETURN
          RTS

PREGONE   MOVE.B    #' ',(A2)+
          MOVE.B    #' ',(A2)+
          RTS


*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*								    ;
*                     ACCENTING POSTPROCESSER			    ;   
*   Accent the first syllable of the previous word if not accented  ; 
*   already and if last replace did not come from an exception.     ;
*							            ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ACCENTER: 
        BTST    #0,ACCFLAG(A5)  ;should we accent?
	BEQ     SQUEAK1	        ;no, bypass
	MOVEM.L D0/D1/A0/A2/A3,-(SP) ;save regs (never touch A1)
	MOVE.L	A1,D0		;compute total len of replacements
	SUB.L	OUTPTR(A5),D0
	CMP.W	#3,D0		;at least 3 chars?
	BLT.S	SQUEAK		;no, get out
	MOVE.L	OUTPTR(A5),A0	;yes, look for a number
SCANUM	MOVEQ	#0,D0
	MOVE.B	(A0)+,D0	;get a char
	ADD.W	D0,D0		;shift for feat index
	MOVE.W	0(A4,D0),D0	;get feature
	BTST	#DIGITBIT,D0	;a number?
	BNE.S	SQUEAK		;yes, get out
	CMP.L	A0,A1		;scan whole word?
	BGT	SCANUM		;no, keep scanning
	MOVE.L	OUTPTR(A5),A0	;yes, find first vowel (if any)
	LEA	VOWTBL,A2	;get vowel table address
FINDVOW1 MOVE.B	(A0)+,D0	;get 1st char
	LSL.W	#8,D0		;shift to hi byte
	MOVE.B	(A0),D0		;get 2nd char
	MOVEQ	#NUMVOW-1,D1
	MOVE.L	A2,A3		;point to vowel table
FINDVOW CMP.W	(A3)+,D0	;a vowel?
	BEQ.S	ITSAVOW		;yes, branch
	DBF	D1,FINDVOW	;no, keep looking
	CMP.L	A0,A1		;searched whole word?
	BGT	FINDVOW1	;no, get next letter pair

* Ran out of letters - no vowel in word.

	BRA.S	SQUEAK		;get out

* First vowel located - insert an accent number

ITSAVOW	ADDQ.L	#1,A0		;point to insertion spot
        MOVE.L  A1,A2		;point to word end
INSRT1	MOVE.B	-(A2),1(A2)	;move right portion over one
	CMP.L	A2,A0
	BNE	INSRT1
	MOVE.B	#'4',(A0)	;put in number
	ADDQ.L	#1,A1		;increment output pointer
*
SQUEAK	MOVEM.L	(SP)+,D0/D1/A0/A2/A3
SQUEAK1 MOVE.L	A1,OUTPTR(A5)	;save new starting point
*
SQUEAK2 RTS

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
*         SPECIAL SYMBOL ROUTINES JUMP TABLE              ;
*                                                         ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


SYMBASE   DC.L      SVOWEL              ;POUND
          DC.L      OMCONS              ;STAR
          DC.L      SVCONS              ;PERIOD
          DC.L      SCONSIE             ;DOLLAR
          DC.L      SUFFIXES            ;PERCENT
          DC.L      SIBIL               ;AMPERSAND
          DC.L      CUAFF               ;AT SIGN
          DC.L      SCONS               ;CARET
          DC.L      FVOWEL              ;PLUS
          DC.L      ZMCONS              ;COLON
          DC.L      SNUM                ;QUESTION
          DC.L      ZMNUMS              ;UNDERBAR
          DC.L      NONLTR              ;BLANK


*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
*                FEATURE MATRIX                           ;
*                                                         ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


FEATURES  DC.W      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CONTROL
          DC.W      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;   CODES
          DC.W      SYMBOL+KEYWORD+WORDBRK                  ;BLANK
          DC.W      SYMBOL+WORDBRK              ;!
          DC.W      SYMBOL              ;'
          DC.W      SYMBOL+KEYWORD+WORDBRK      ;#
          DC.W      SYMBOL+KEYWORD      ;$
          DC.W      SYMBOL+KEYWORD      ;%
          DC.W      SYMBOL+KEYWORD      ;&
          DC.W      SYMBOL              ;'
          DC.W      SYMBOL+WORDBRK              ;(
          DC.W      SYMBOL+WORDBRK              ;)
          DC.W      SYMBOL+KEYWORD      ;*
          DC.W      SYMBOL+KEYWORD      ;+
          DC.W      SYMBOL+WORDBRK              ;,
          DC.W      SYMBOL+WORDBRK              ;-
          DC.W      SYMBOL+KEYWORD+WORDBRK      ;.
          DC.W      SYMBOL              ;/
          DC.W      DIGIT               ;0
          DC.W      DIGIT               ;1
          DC.W      DIGIT               ;2
          DC.W      DIGIT               ;3
          DC.W      DIGIT               ;4
          DC.W      DIGIT               ;5
          DC.W      DIGIT               ;6
          DC.W      DIGIT               ;7
          DC.W      DIGIT               ;8
          DC.W      DIGIT               ;9
          DC.W      SYMBOL+KEYWORD      ;:
          DC.W      SYMBOL              ;;
          DC.W      SYMBOL              ;<
          DC.W      SYMBOL              ;=
          DC.W      SYMBOL              ;>
          DC.W      SYMBOL+KEYWORD+WORDBRK      ;?
          DC.W      SYMBOL+KEYWORD      ;@
          DC.W      LETTER+VOWEL                  ;A
          DC.W      LETTER+CONS+VOICED            ;B
          DC.W      LETTER+CONS+SIBILANT          ;C
          DC.W      LETTER+CONS+VOICED+UAFF       ;D
          DC.W      LETTER+VOWEL+FRONT            ;E
          DC.W      LETTER+CONS                   ;F
          DC.W      LETTER+CONS+VOICED+SIBILANT   ;G
          DC.W      LETTER+CONS                   ;H
          DC.W      LETTER+VOWEL+FRONT            ;I
          DC.W      LETTER+CONS+VOICED+SIBILANT+UAFF  ;J
          DC.W      LETTER+CONS                   ;K
          DC.W      LETTER+CONS+VOICED+UAFF       ;L
          DC.W      LETTER+CONS+VOICED            ;M
          DC.W      LETTER+CONS+VOICED+UAFF       ;N
          DC.W      LETTER+VOWEL                  ;O
          DC.W      LETTER+CONS                   ;P
          DC.W      LETTER+CONS                   ;Q
          DC.W      LETTER+CONS+VOICED+UAFF       ;R
          DC.W      LETTER+CONS+SIBILANT+UAFF     ;S
          DC.W      LETTER+CONS+UAFF              ;T
          DC.W      LETTER+VOWEL                  ;U
          DC.W      LETTER+CONS+VOICED            ;V
          DC.W      LETTER+CONS+VOICED            ;W
          DC.W      LETTER+CONS+SIBILANT          ;X
          DC.W      LETTER+VOWEL+FRONT            ;Y
          DC.W      LETTER+CONS+VOICED+SIBILANT+UAFF  ;Z
          DC.W      SYMBOL              ;[
          DC.W      SYMBOL              ;\
          DC.W      SYMBOL              ;]
          DC.W      SYMBOL+KEYWORD      ;^
          DC.W      SYMBOL+KEYWORD      ;_
          DC.W      SYMBOL              ;`
          DC.W      0,0,0,0,0,0,0,0,0,0,0,0,0     ;LOWER CASE
          DC.W      0,0,0,0,0,0,0,0,0,0,0,0,0     ;LETTERS
          DC.W      SYMBOL              ;{
          DC.W      SYMBOL              ;|
          DC.W      SYMBOL              ;}
          DC.W      SYMBOL              ;~
          DC.W      0                   ;DEL



*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
*       SPECIAL SYMBOLS USED IN LETTER TO SOUND RULES     ;
*                                                         ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SYMLIST   DC.B      '#'       ;1 OR MORE VOWELS
          DC.B      '*'       ;1 OR MORE CONSONANTS
          DC.B      '.'       ;A VOICED CONSONANT
          DC.B      '$'       ;SINGLE CONSONANT FOLLOWED BY 'I' OR 'E'
          DC.B      '%'       ;SUFFIX (E, ES, ED, ER, ING, ELY)
          DC.B      '&'       ;A SIBILANT
          DC.B      '@'       ;A CONSONANT FOLLOWED BY A LONG U
          DC.B      '^'       ;A SINGLE CONSONANT
          DC.B      '+'       ;A FRONT VOWEL (I, E, Y)
          DC.B      ':'       ;0 OR MORE CONSONANTS
          DC.B      '?'       ;A SINGLE DIGIT
          DC.B      '_'       ;0 OR MORE DIGITS
          DC.B      ' '       ;NON-LETTER

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							 ;
*        LIST OF VOWELS FOR ACCENTING ROUTINE            ;
*							 ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NUMVOW  EQU	15
VOWTBL	DC.W	'IH'
	DC.W	'EH'
	DC.W	'AA'
	DC.W	'AE'
	DC.W	'IY'
	DC.W	'AO'
	DC.W	'AH'
	DC.W	'ER'
	DC.W	'OH'
	DC.W	'EY'
	DC.W	'AY'
	DC.W	'OY'
	DC.W	'AW'
	DC.W	'OW'
	DC.W	'UW'


	IFNE	AMIGA
	INCLUDE	'ltrrules.i'
	ENDC

************************

          IFNE	    MAC
FILENAME  DC.W      15
          DC.W      'MacinTalk Rules'
	  ENDC


          END 


