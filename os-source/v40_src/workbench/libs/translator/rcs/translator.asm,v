head     36.5;
branch   ;
access   ;
symbols  V36_9:36.5 V36_6:36.3 V36_5:36.2 V36_1:36.0;
locks    ; strict;
comment  @*   @;


36.5
date     90.05.30.17.43.20;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     90.05.30.17.29.03;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     90.05.01.16.09.49;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     90.04.09.15.58.48;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     90.04.09.14.37.25;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     89.05.24.10.11.16;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


36.5
log
@convert some Bxx & BSR to short
@
text
@**
**	$Id: translator.asm,v 36.4 90/05/30 17:29:03 kodiak Exp Locker: kodiak $
**
**	translator library code
**
**	(C) Copyright 1986,1990 Commodore-Amiga, Inc.
**	    All Rights Reserved
**
	SECTION translator


******* translator.library/Translate *******************************************
*
*    NAME
*	Translate -- Convert an English string into narrator device phonemes.
*
*    SYNOPSIS
*	rtnCode = Translate(inString, inLength, outBuffer, outLength)
*	D0		    A0	      D0	A1	   D1
*
*	LONG Translate( STRPTR inString, LONG inLength, STRPTR outBuffer,
*	    LONG outlen );
*
*    FUNCTION
*	The translate function converts an English string into
*	a string of phonetic codes suitable as input to the
*	narrator device.  
*
*    INPUTS
*	inString - pointer to English string
*	inLength - length of English string
*	outBuffer - a char array which will hold the phonetic codes
*	outLength - the length of the output array
*
*    RESULTS
*	rtnCode - zero if no error has occured.
*	    The only error that can occur is overflowing the outBuffer.
*	    If Translate() determines that an overflow will occur, it
*	    will stop the translation at a word boundary before the
*	    overflow happens.  If this occurs, rtnCode will be a
*	    negative number whose absolute value indicates where in
*	    inString Translate() stopped.  The user can then use the
*	    offset -rtnCode from the beginning of inString in a
*	    subsequent Translate() call to continue the translation.
*
*    SEE ALSO
*	narrator.device/CMD_WRITE
*
********************************************************************************
*
*   IDEAS FOR ENHANCEMENT
*	required rules, optional exception table
*
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*								    ;
*		   ENGLISH TO ARPABET TRANSLATOR		    ;
*								    ;
*	  CONVERTS ASCII ENGLISH STRING TO ASCII PHONETIC	    ;
*	  REPRESENTATION.  USES AN EXPANDED NRL RULE SYSTEM.	    ;
*								    ;
*	  D0 - SCRATCH REGISTER		D1 - LETTER/SCRATCH	    ;
*	  D2 - SIZE OF HANDLE		D3 - WORD LENGTH	    ;
*	  D4 - LETTER FEATURE		D5 - SCRATCH		    ;
*	  D6 - VARIED			D7 - DIRECTION TO FETCH	    ;
*								    ;
*	  A0 - ENGLISH INPUT		A1 - PHONETIC OUTPUT	    ;
*	  A2 - BEG OF CNTR OF RULE	A3 - END OF CNTR OF RULE    ;
*	  A4 - FEATURE MATRIX		A5 - PTR TO WORD BUFFER	    ;
*	  A6 - RULE BASE		A7 - STACK		    ;
*								    ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	XDEF	TLTranslate

*-------- FRAME OFFSETS (FROM A5)

EXCPSHAN  EQU	    0		;OFFSET TO EXCEPTIONS HANDLE
RULESHAN  EQU	    4		;OFFSET TO RULES HANDLE
STOUTOFF  EQU	    8		;OFFSET TO START OF OUTPUT
STINPOFF  EQU	    12		;OFFSET TO START OF INPUT
OUTPTR	  EQU	    16		;OFFSET TO ACCENTING RULE LAST POS
ACCFLAG	  EQU	    20		;OFFSET TO ACCENTING RULE FLAG
WORDBOFF  EQU	    22		;OFFSET TO START OF WORD BUFFER
INLENOFF  EQU	    130		;OFFSET TO INPUT LENGTH
OUTHDOFF  EQU	    182		;OFFSET TO OUTPUT HANDLE

SYMCNT	  EQU	    12		;NUMBER OF SPECIAL SYMBOLS [not including ' ']
MAXLTRS	  EQU	    100		;MAX NUMBER OF LETTERS IN A WORD


SYMBOL	  EQU	    $1
DIGIT	  EQU	    $2
UAFF	  EQU	    $4
VOICED	  EQU	    $8
SIBILANT  EQU	    $10
CONS	  EQU	    $20
VOWEL	  EQU	    $40
LETTER	  EQU	    $80
FRONT	  EQU	    $100
IGNORE	  EQU	    $200
KEYWORD	  EQU	    $400
WORDBRK	  EQU	    $800

SYMBOLBIT  EQU	      0
DIGITBIT   EQU	      1
UAFFBIT	   EQU	      2
VOICEDBIT  EQU	      3
SIBILBIT   EQU	      4
CONSBIT	   EQU	      5
VOWELBIT   EQU	      6
LETTERBIT  EQU	      7
FRONTBIT   EQU	      8
IGNOREBIT  EQU	      9
KEYWORDBIT EQU	      10
WORDBRKBIT EQU	      11



*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							  ;
*							  ;
*		   INITIALIZATION CODE			  ;
*							  ;
*							  ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


TLTranslate:
	  MOVEM.L   A2-A6/D2-D7,-(SP)	;SAVE REGISTERS

	  MOVE.L    D1,D2
	  SUBQ.L    #5,D2		;REDUCE MAX OUTPUT TO INSURE NO OVERFLOW

*-------- ;Create stack frame

	  MOVE.L    D0,-(SP)		;SAVE LENGTH OF INPUT IN FRAME
	  
	  MOVE.L    #'	  ',D0		;CLEAR WORD BUFFER (108 BYTES)
	  MOVEQ	    #26,D1
CLEARWDBF MOVE.L    D0,-(SP)
	  DBF	    D1,CLEARWDBF

	  CLR.W	    -(SP)		;ACCENTING CODE - ACCFLAG	  
	  MOVE.L    A1,-(SP)		;ACCENTING CODE - LAST POS PTR

	  MOVE.L    A0,-(SP)		;START OF INPUT
	  MOVE.L    A1,-(SP)		;SAVE START OF OUTPUT
	  CLR.L	    -(SP)		;SPACE FOR RULES HANDLE	  
	  CLR.L	    -(SP)		;SPACE FOR EXCEPTIONS HANDLE	  

	  MOVE.L    SP,A5		;SAVE FRAME POINTER

	  MOVE.L    #0,EXCPSHAN(A5)	;    NO EXCPS ARE TO BE USED !!!

	  MOVEQ	    #0,D0		;CLEAR SOME REGISTERS (DON'T CLEAR D2!!)
	  MOVEQ	    #0,D1
	  MOVEQ	    #0,D3
	  MOVEQ	    #0,D4
	  MOVEQ	    #0,D5
	  MOVEQ	    #0,D6
	  MOVEQ	    #0,D7

	  LEA	    WORDBOFF+2(A5),A2	;POINTER TO BEGINNING OF WORD BUFFER
	  LEA	    FEATURES,A4		;POINTER TO LETTER FEATURES

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							  ;
*							  ;
*	  MAIN LOOP.					  ;
*	  1)  CHECK TO SEE IF A '#' WAS INSERTED,	  ;
*	      INDICATING THAT THE INPUT STRING HAS BEEN	  ;
*	      ENTIRELY PROCESSED,			  ;
*	  2)  IF NOT END OF WORD, CONTINUE PROCESSING	  ;
*	      WITH NEXT LETTER/COMBINATION,		  ;
*	  3)  IF END OF WORD, CALL PRE-PROCESSOR FOR	  ;
*	      NEXT WORD.				  ;
*							  ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

WORDC	  CMPI.B    #'#',-1(A1)
	  BEQ.S	    RETURN		;IF "#" INSERTED, END OF STRING
	  CMPI.B    #' ',-1(A2)		;IF BLANK PROCESSED, GET NEXT WORD
	  BNE.S	    WORDC1

NEXTWORD:
	  BSR	    PREPROC		;GET NEXT WORD FROM ENGLISH
	  MOVE.W    D3,-(SP)		;SAVE RETURN CODE    
	  BSR	    ACCENTER		;ACCENT THE PREVIOUS WORD
	  MOVE.W    (SP)+,D3		;RESTORE RETURN CODE
	  BMI.S	    FIXUP		;OVERFLOW MAX # LTRS IN WORD
	  BEQ.S	    RETURN		;NOTHING LEFT, GO AWAY
	  LEA	    WORDBOFF+2(A5),A2	;POINT TO BEGINNING OF STRING
	  BRA.S	    WORDC0

ERROR	  MOVE.W    D0,D1		;SET BAD RETURN CODE
	  BRA.S	    FIXUP		;COMMON RETURN CODE

RETURN	  MOVEQ	    #0,D1
	  BSR	    ACCENTER

	  MOVE.B    #0,-1(A1)		;Change # to a NULL


FIXUP:

	  MOVE.L    A1,D0		;GET CURRENT OUTPUT POS
	  SUB.L	    STOUTOFF(A5),D0	;COMPUTE LENGTH OF OUTPUT

	  ADD.L	    #134,SP		;REMOVE FRAME FROM STACK
	  MOVEM.L   (SP)+,A2-A6/D2-D7	;RESTORE REGISTERS

	  MOVE.W    D1,D0
	  EXT.L	    D0

	  RTS				;RETURN TO PASCAL

WORDC0	  MOVE.L    EXCPSHAN(A5),A6	;DO EXCPS RULES
	  CMP.L	    #0,A6		;NIL?
	  BEQ.S	    WORDC1		;YES, SKIP EXCPS
	  MOVE.L    (A6),A6		;DEREFERENCE TO POINTER
	  BSR.S	    CINDEX		;FIND RULE GROUP
	  BSR.S	    CHECK		;DO EXCP CHECKING
	  BEQ.S	    WORDC1		;NO EXCP RULE APPLIED, DO BASIC RULES
	  BMI	    ERROR		;REPLACE OVFL, COULD NOT GET MORE MEM
	  BRA.S	    WORDC		;EXCP RULE APPLIED, GET NEXT WORD

WORDC1
;KODIAK	  MOVE.L    RULESHAN(A5),A6	;DO BASIC RULES
;KODIAK	  MOVE.L    (A6),A6		;DEREFERENCE TO POINTER
	  LEA	    RULEBASE,A6
	  BSR.S	    CINDEX		;FIND RULE GROUP
	  BSR.S	    CHECK		;DO EXCP CHECKING
	  TST.W	    D7
	  BMI	    ERROR		;REPLACE OVFL, COULD NOT GET MORE MEM
	  BRA.S	    WORDC		;EXCP RULE APPLIED, GET NEXT WORD

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							  ;
*							  ;
*	       DO RULE CHECKING				  ;
*							  ;
*							  ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CHECK	BSR.S	CHKCENTR		;CHECK CENTER CONTEXT
	BNE.S	NEXTRULE		;UNSUCCESSFUL
	MOVE.L	A2,-(SP)		;SAVE PTR TO BEG OF CENTER
	MOVE.L	A3,-(SP)		;SAVE PTR TO END OF CENTER
	BSR.S	CHKLEFT			;CHECK LEFT CONTEXT
	BNE.S	LNEXTRULE		;UNSUCCESSFUL
	BSR	CHKRIGHT		;CHECK RIGHT CONTEXT
	BNE.S	LNEXTRULE		;UNSUCCESSFUL
	BSR	REPLACE			;DO REPLACEMENT
	MOVE.L	(SP)+,A2		;MAKE END OF CENTER, BEG OF CENTER
	ADDQ.L	#4,SP			;REMOVE OLD BEG OF CENTER
	RTS


*------ Find next rule in ruleset
LNEXTRULE	MOVE.L	(SP)+,A3	;REMOVE END OF CENTER
		MOVE.L	(SP)+,A2	;REMOVE BEG OF CENTER
NEXTRULE	MOVE.B	(A6)+,D7	;GET NEXT CHAR FROM RULE
		CMP.B	#'\',D7		;END OF RULE?
		BEQ.S	CHECK		;YES
		CMP.B	#'`',D7		;OTHER END OF RULE?
		BEQ.S	CHECK		;YES
		BRA.S	NEXTRULE	;NOT END OF RULE, KEEP LOOKING

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							  ;
*							  ;
*	       COMPUTE INDEX INTO RULESET		  ;
*	A2 - Pointer to next char in word		  ;
*	A6 - Pointer to EXCP/RULE set			  ;
*	A4 - Features					  ;
*							  ;
*	RETURNS:					  ;
*	D1 - SCRATCH					  ;
*	D4 - Features					  ;
*	A6 - Pointer to letter group of rules		  ;
*							  ;
*							  ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CINDEX	MOVEQ	#0,D1		;CLEAR SCRATCH REG
	MOVE.B	(A2),D1		;GET CHAR FROM WORD BUFFER
	MOVE.W	D1,D4		;COPY
	LSL.W	#1,D4		;SHIFT FOR FEAT INDEX
	MOVE.W	0(A4,D4),D4	;GET FEATURES
	BTST	#LETTERBIT,D4	;LETTER?
	BNE.S	CLETTER		;YES

CSYMBOL MOVE.B	#'Z'+1,D1	;SET RULE PTR TO 'Z'+1 RULESET
	BTST	#DIGITBIT,D4	;DIGIT?
	BNE.S	CLETTER		;YES, USE 'Z'+1 RULES
CDIGIT	ADDQ.B	#1,D1		;NO, USE 'Z'+2 RULES

CLETTER SUB.B	#'A',D1		;CONVERT TO 'A OFFSET'
	LSL.W	#2,D1		;ADJUST FOR RULE INDEXING
	MOVE.L	0(A6,D1),A3	;GET OFFSET LETTER RULE GROUP
	ADD.L	A3,A6		;CREATE PTR TO RULE GROUP
	RTS

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							  ;
*							  ;
*	       CHECK CENTER PORTION OF RULE		  ;
*							  ;
*							  ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CHKCENTR  MOVEQ	    #0,D6		;CLEAR INDEX INTO RULE
	  MOVEQ	    #-1,D7		;SET TEMP REG
	  MOVE.L    A2,A3

*	  FIND '[', BEGINS CENTER PORTION OF RULE

CLTR1	  MOVE.B    0(A6,D6),D5		;GET BYTE FROM RULE
	  ADDQ.W    #1,D6		;BUMP RULE INDEX
	  CMP.B	    #'[',D5		;IS RULE CHAR='['?
	  BNE.S	    CLTR1		;NO, KEEP LOOKING
	  ADD.W	    D6,D7		;D7 POINTS TO '['
	  SWAP	    D6			;D6 = POS OF CENTER,0
	  MOVE.W    D7,D6		;D6 = POS OF CENTER, POS OF '['
	  SWAP	    D6			;D6 = POS OF '[', POS OF CENTER

*	  CHECK CENTER PORTION.	 ONLY LETTER MATCHING IS ALLOWED.
*	  CONTINUE CHECKING UNTIL ']' (RIGHT CONTEXT DELIMITER)
*	  IS FOUND.

CLTR2	  MOVE.B    0(A6,D6),D5		;GET RULE CHAR
	  ADDQ.W    #1,D6		;BUMP RULE INDEX
	  CMP.B	    #']',D5		;END OF CENTER CONTEXT?
	  BEQ.S	    CENTRTN		;YES, CHECK LEFT CONTEXT
	  CMP.B	    (A3)+,D5		;RULE CHAR MATCH ENG CHAR?
	  BEQ.S	    CLTR2		;YES, CONTINUE WITH NEXT RULE CHAR

CENTRTN	  RTS

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							  ;
*							  ;
*	     CHECK 'LEFT' PORTION OF RULE		  ;
*							  ;
*							  ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CHKLEFT	  SWAP	    D6			;POS OF RIGHT CONTEXT, POS OF '['

CHKLEFT1  SUBQ.W    #1,D6		;MOVE LEFT ONE CHAR
	  BMI.S	    CHKLEFTR		;DONE, RETURN WITH GOOD RC
	  MOVE.B    0(A6,D6),D5		;GET RULE CHAR
	  MOVE.W    D5,D4
	  LSL.B	    #1,D4		;FEATURE MATRIX INDEX
	  MOVE.W    0(A4,D4),D4		;GET FEATURES
	  BTST	    #KEYWORDBIT,D4	;SPECIAL SYMBOL?
	  BNE.S	    LSYMBOL		;YES
	  CMP.B	    -(A2),D5		;NO, COMPARE WITH LEFT CHAR
	  BEQ.S	    CHKLEFT1		;IF MATCH, CONTINUE
	  RTS
CHKLEFTR  MOVE.W    #$04,CCR		;SET SUCCESSFUL RC
	  RTS

LSYMBOL	  MOVEQ	    #1,D7		;SET LEFT MOVING FETCH
	  BSR	    SYMHDLR		;GO DO SYMBOL CHECKING
	  BNE.S	    CHKLEFT1		;RULE WAS SUCCESSFUL
	  MOVE.W    #$00,CCR		;UNSUCCESSFUL RC
	  RTS



*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							  ;
*							  ;
*	     CHECK 'RIGHT' PORTION OF RULE		  ;
*							  ;
*							  ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CHKRIGHT  MOVE.L    4(SP),A2		;GET RIGHT POINTER INTO A2
	  SWAP	    D6			;RESTORE RIGHT CONTEXT POINTER
*					;   IN LOWER HALF OF D6
CHKR1	  MOVE.B    0(A6,D6),D5		;GET RULE CHAR
	  ADDQ.W    #1,D6
	  CMP.B	    #'=',D5		;END OF RIGHT CONTEXT?
	  BEQ.S	    CHKRRTN		;YES, DO REPLACEMENT
	  MOVE.W    D5,D4
	  LSL.B	    #1,D4
	  MOVE.W    0(A4,D4),D4		;GET FEATURES
	  BTST	    #KEYWORDBIT,D4	;SPECIAL SYMBOL?
	  BNE.S	    RSYMBOL		;YES, TRY SYMBOL
	  CMP.B	    (A2)+,D5		;NO, COMPARE WITH RULE CHAR
	  BEQ.S	    CHKR1		;IF MATCH, CONTINUE CHECKING
CHKRRTN	  RTS

RSYMBOL	  MOVEQ	    #-1,D7		;SET RIGHT FETCHES
	  BSR	    SYMHDLR		;GO DO SYMBOL CHECKING
	  BNE.S	    CHKR1		;RULE WAS SUCCESSFUL
	  MOVE.W    #$00,CCR		;SET RC (BAD)
	  RTS


*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							  ;
*							  ;
*	EVERYTHING IS JUST GREAT, DO REPLACEMENT	  ;
*							  ;
*							  ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

REPLACE:
*	  FIND LENGTH OF REPLACEMENT TEXT

	  MOVE.W    D6,D7		;CURRENT POS
	  SUBQ.W    #1,D7		;BACKUP IN PREPARATION
REPL1	  ADDQ.W    #1,D7		;MOVE FORWARD ONE CHAR
	  MOVE.B    0(A6,D7),D0		;GET RULE CHAR
	  CMP.B	    #'\',D0		;AT END?
	  BEQ.S	    REPL1X		;YES
	  CMP.B	    #'`',D0		;AT END?
	  BNE.S	    REPL1		;NO, CONTINUE LOOKING
REPL1X	  SUB.W	    D6,D7		;COMPUTE LENGTH OF REPL TEXT
	  BNE.S	    REPL2		;
	  RTS				;ZERO REPLACEMENT LENGTH

*	  INSURE THAT REPLACEMENT TEXT WILL FIT IN OUTPUT

REPL2	  MOVE.L    A1,D0		;GET CURRENT POS
	  SUB.L	    STOUTOFF(A5),D0	;COMPUTE NUMBER OF BYTES IN OUTPUT
	  ADD.W	    D7,D0		;NEW LENGTH
	  CMP.W	    D2,D0		;BIGGER THAN BLOCK SIZE?
	  BGE.S	    OVERFLOW		;YES, DO OVERFLOW PROCESSING

*	  NEW TEXT FITS IN OUTPUT

DOREPLCE  AND.L	    #$0000FFFF,D6	;CLEAR UPPER HALF OF D6
	  ADD.L	    D6,A6		;POINT A6 TO BEG OF REPL TEXT
	  MOVE.W    D7,-(SP)		;SAVE LENGTH OF REPLACEMENT
	  BRA.S	    REPBLOOP		;BEGIN LOOP
REPLOOP	  MOVE.B    (A6)+,(A1)+		;MOVE CHARS
REPBLOOP  DBF	    D7,REPLOOP		;LOOP FOR LENGTH OF REPL TEXT
	  MOVE.W    (SP)+,D7		;RESTORE REPLACEMENT LENGTH
* If last rule did not output a letter, don't flip accent flag
	MOVE.L	D0,-(SP)
	MOVEQ	#0,D0
	MOVE.B	-1(A1),D0	;get last char of output
	ADD.W	D0,D0
	MOVE.W	0(A4,D0),D0
	BTST	#LETTERBIT,D0	;a letter?
	BEQ.S	REPLOOP1	;no, don't flip flag
* If last rule was an exception, clear the accent flag
	BSET	#0,ACCFLAG(A5)
	CMP.B	#'`',(A6)	;from an exception?
	BNE.S	REPLOOP1	;no, branch
	BCLR	#0,ACCFLAG(A5)	;yes, clear accent flag
REPLOOP1 MOVE.L (SP)+,D0
	RTS
*

OVERFLOW:
	  MOVEQ	    #0,D0
	  MOVE.B    -1(A1),D0		;WAS LAST CHAR INSERTED A WORD BREAK?	
	  LSL.W	    #1,D0
	  MOVE.W    0(A4,D0),D0
	  BTST	    #WORDBRKBIT,D0
	  BNE.S	    OVERFL1		;YES
OVERFL2	  MOVEQ	    #0,D0
	  MOVE.B    -(A1),D0
	  LSL.W	    #1,D0
	  MOVE.W    0(A4,D0),D0
	  BTST	    #WORDBRKBIT,D0
	  BEQ.S	    OVERFL2
	  LEA	    1(A1),A1
	  
OVERFL1	  MOVE.B    #0,(A1)+		;PUT IN A NULL
*	   MOVE.B    #0,(A1)		;NULL TERMINATE STRING
	  SUB.L	    D3,A0		;ADJUST ENGLISH STRING POINTER
	  MOVE.L    A0,D0
	  SUB.L	    STINPOFF(A5),D0
	  NEG.L	    D0	  
	  MOVE.L    D0,D1
	  MOVE.L    D0,D7
	  RTS


*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							  ;
*							  ;
*	    GIVEN A SPECIAL SYMBOL IN D5, FIND AND	  ;
*	    EXECUTE THE APPROPRIATE ROUTINE		  ;
*							  ;
*							  ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SYMHDLR	  LEA	    SYMLIST,A3		;LIST OF SPECIAL SYMBOLS
	  MOVE.W    #SYMCNT-1,D0
SYMHDLR1  CMP.B	    (A3)+,D5
	  DBEQ	    D0,SYMHDLR1
	  NEG.W	    D0
	  ADD.W	    #SYMCNT-1,D0
	  LSL.W	    #2,D0		;FOUND OFFSET TO SPECIAL SYMBOL
	  LEA	    SYMBASE,A3		;GET BASE OF SYMBOL ROUTINES

	  MOVE.L    0(A3,D0),A3		;GET SPECIFIC SYMBOL ROUTINE

	  JSR	    (A3)		;GO DO IT
	  RTS				;AND RETURN



*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							  ;
*							  ;
*      FETCHES A CHARACTER FROM THE 'WORD' BUFFER	  ;
*      INTO D1 AND ASSOCIATED FEATURES INTO D4.		  ;
*      ON ENTRY D7 CONTAINS A +IVE VALUE IF THE CHAR	  ;
*      IS TO BE FETCHED FROM THE LEFT AND A -IVE VALUE	  ;
*      IF THE FETCHING IS TO BE DONE FROM THE RIGHT	  ;
*							  ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FETCH	  TST.W	    D7			;CHECK D7
	  BMI.S	    FETCH1		;-IVE, LOOK TO THE RIGHT
	  MOVE.B    -(A2),D1		;GET CHAR ON LEFT
	  BRA.S	    FETCH2		;GO GET FEATURES
FETCH1	  MOVE.B    (A2)+,D1		;GET CHAR ON RIGHT
FETCH2	  MOVEQ	    #0,D4
	  MOVE.B    D1,D4
	  LSL.B	    #1,D4
	  MOVE.W    0(A4,D4),D4		;GET FEATURES
	  RTS



*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							  ;
*							  ;
*      THE FOLLOWING SUBROUTINES HANDLE CHECKS FOR	  ;
*      THE VARIOUS SPECIAL SYMBOLS THAT COULD APPEAR	  ;
*      IN A RULE.  ALL SET CC = 0 IF THE RULE DOES NOT	  ;
*      APPLY, AND INSURE CC != 0 IF RULE DOES APPLY.	  ;
*							  ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


*
*	  CHECK FOR A SINGLE VOWEL
*

SVOWEL	  BSR.S	    FETCH		;GET CHAR (AND FEATURES) FROM ENG
	  BTST	    #VOWELBIT,D4	;DO TEST FOR VOWEL
	  RTS


*
*	  CHECK FOR ONE OR MORE CONSONANT
*

OMCONS	  BSR.S	    FETCH		;GET NEXT CHAR
	  BTST	    #CONSBIT,D4
	  BEQ.S	    OMCONS1		;NOT A CONSONANT, RULE FAILS
OMCONS0	  BSR.S	    FETCH		;AT LEAST ONE CONS, KEEP LOOKING
	  BTST	    #CONSBIT,D4		;
	  BNE.S	    OMCONS0		;GET EM ALL
	  MOVE.W    #$08,CCR		;SET N BIT, CLEAR Z BIT, GOOD RTN
OMCONS1	  RTS
*
*	  CHECK FOR A SINGLE VOICED CONSONANT
*

SVCONS	  BSR.S	    FETCH		;GET CHAR AND FEATURES
	  BTST	    #VOICEDBIT,D4	;VOICED?
	  BEQ.S	    SVCONS1		;NO, RETURN
	  BTST	    #CONSBIT,D4		;CONSONANT?
SVCONS1	  RTS				;RETURN, RC IS IMPLICITLY SET


*
*	  CHECK FOR A SINGLE CONSONANT FOLLOWED BY AN 'I' OR 'E'
*

SCONSIE	  BSR.S	    FETCH		;GET CHAR AND FEATURES
	  BTST	    #CONSBIT,D4		;CONSONANT?
	  BEQ.S	    SCONSIE2		;NO, RETURN
	  BSR.S	    FETCH		;GET NEXT CHAR AND FEATURES
	  CMP.B	    #'I',D1		;IS IT AN 'I'?
	  BEQ.S	    SCONSIE1		;YES
	  CMP.B	    #'E',D1		;IS IT AN 'E'?
	  BEQ.S	    SCONSIE1		;YES
	  MOVE.W    #$04,CCR		;NO, BAD RETURN, SET Z BIT
	  RTS				;   AND RETURN
SCONSIE1  MOVE.W    #$08,CCR		;SET N BIT, GOOD RETURN
SCONSIE2  RTS


*
*	  CHECK FOR ONE OF THE FOLLOWING SUFFIXES:
*	  E, ES, ED, ER, ING, ELY, ERS OR INGS.
*

SUFFIXES  BSR.S	    FETCH
	  CMP.B	    #'E',D1		;IS IT AN E?
	  BNE.S	    SUFFI		;NO, TRY AN I ENDING SUFFIX
	  BSR.S	    FETCH
	  BTST	    #LETTERBIT,D4
	  BEQ.S	    SUFFOK
	  CMP.B	    #'S',D1
	  BEQ.S	    SUFFCK		;ES
	  CMP.B	    #'D',D1
	  BEQ.S	    SUFFCK		;ED
	  CMP.B	    #'R',D1
*	  BEQ.S	    SUFFCK		;ER		!!!sam 10/26/85!!!
	  BEQ.S	    SUFFS		;ER		!!!sam 10/26/85!!!
	  CMP.B	    #'L',D1
	  BNE.S	    SUFFNO
	  BSR	    FETCH
	  CMP.B	    #'Y',D1
	  BEQ.S	    SUFFCK		;ELY
	  BRA.S	    SUFFNO
SUFFI	  BSR	    FETCH
	  CMP.B	    #'N',D1
	  BNE.S	    SUFFNO
	  BSR	    FETCH
	  CMP.B	    #'G',D1
	  BNE.S	    SUFFNO		;ING
SUFFS	  BSR	    FETCH				!!!sam 10/26/85!!!
	  BTST	    #LETTERBIT,D4			!!!sam 10/26/85!!!
	  BEQ.S	    SUFFOK				!!!sam 10/26/85!!!
	  CMP.B	    #'S',D1				!!!sam 10/26/85!!!
	  BNE.S	    SUFFNO		;INGS OR ERS	!!!sam 10/26/85!!!
SUFFCK	  BSR	    FETCH
	  BTST	    #LETTERBIT,D4
	  BEQ.S	    SUFFOK
SUFFNO	  MOVE.W    #$04,CCR		;BAD RETURN
	  RTS
SUFFOK	  MOVE.W    #$08,CCR		;GOOD RETURN
	  RTS


*
*	  CHECK FOR A SIBILANT
*

SIBIL	  BSR	    FETCH
	  BTST	    #SIBILBIT,D4
	  RTS


*
*	  CHECK FOR A CONSONANT WITH A U AFFECTATION
*

CUAFF	  BSR	    FETCH
	  BTST	    #UAFFBIT,D4
	  RTS


*
*	  CHECK FOR A SINGLE CONSONANT
*

SCONS	  BSR	    FETCH
	  BTST	    #CONSBIT,D4
	  RTS


*
*	  CHECK FOR A FRONT VOWEL
*

FVOWEL	  BSR	    FETCH
	  BTST	    #FRONTBIT,D4
	  RTS


*
*	  CHECK FOR ZERO OR MORE CONSONANT
*

ZMCONS	  BSR	    FETCH
	  BTST	    #CONSBIT,D4
	  BNE.S	    ZMCONS
	  ADD.L	    D7,A2		;FIXUP A2
	  MOVE.W    #$08,CCR		;GOOD RC
	  RTS


*
*	  CHECK FOR A SINGLE NUMERAL (DIGIT)
*

SNUM	  BSR	    FETCH
	  BTST	    #DIGITBIT,D4
	  RTS


*
*	  CHECK FOR ZERO OR MORE NUMERALS (DIGITS)
*

ZMNUMS	  BSR	    FETCH
	  BTST	    #DIGITBIT,D4
	  BNE.S	    ZMNUMS
	  ADD.L	    D7,A2		;FIXUP A2
	  MOVE.W    #$08,CCR		;GOOD RETURN
	  RTS


*
*	  CHECK FOR A NON LETTER
*

NONLTR	  BSR	    FETCH
	  BTST	    #LETTERBIT,D4	;LETTER BIT ON?
	  BNE.S	    NONLTR1		;YES, RULE FAILS
	  MOVE.W    #$08,CCR		;RULE CHECKS, SET GOOD RETURN
	  RTS
NONLTR1	  MOVE.W    #$04,CCR		;RULE FAILS, SET BAD RETURN
	  RTS




*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							  ;
*							  ;
*		      PREPROCESSOR			  ;
*							  ;
*      CURRENTLY THE PREPROCESSOR ISOLATES WORDS,	  ;
*      CHECKS TO SEE THAT THE CHARACTERS ARE VALID	  ;
*      ASCII CODES, AND CONVERTS LOWER CASE TO UPPER	  ;
*      CASE.  THE LENGTH OF THE WORD IS RETURNED IN	  ;
*      D3.						  ;
*							  ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PREPROC	  LEA	    WORDBOFF(A5),A2	;POINTER TO WORD BUFFER
	  MOVE.B    0(A2,D3),(A2)+	;GET LAST CHAR OF PREVIOUS WORD
	  MOVE.B    #' ',(A2)+		;MOVE IN A BLANK
	  MOVEQ	    #0,D0		;CLEAR SOME REGS
	  MOVEQ	    #0,D1
	  MOVEQ	    #0,D3
	  TST.L	    INLENOFF(A5)
	  BLE.S	    PREATEND
PREMAIN	  MOVE.B    D1,D0
	  MOVE.B    (A0)+,D1		;GET CHAR FROM ENGLISH STRING

	  BNE.S	    PRENOTNUL		;   IF NEXT CHAR IS A NULL, PROCESS
	  MOVE.L    #1,INLENOFF(A5)	;   THIS WORD, THEN TERMINATE INPUT

PRENOTNUL CMP.B	    #' ',D1		;CHECK AGAINST ASCII BLANK
	  BGE.S	    PREAT0		;GREATER OR EQUAL, USE CHAR
	  MOVE.B    #' ',D1		;NOT AN ASCII CHAR, SUBST A BLANK
PREAT0	  CMP.B	    #$7F,D1		;CHECK AGAINST DEL CHAR
	  BNE.S	    PREAT00		;NOT A DEL
	  MOVE.B    #' ',D1		;NOT AN ASCII CHAR, SUBST A BLANK
PREAT00	  CMP.B	    #'a',D1		;CHECK FOR LOWER CASE
	  BLT.S	    PRENOTLC
	  CMP.B	    #'z',D1
	  BGT.S	    PRENOTLC
	  SUB.B	    #'a'-'A',D1		;IF LOWER CASE, CONVERT TO UC

PRENOTLC  CMP.B	    #']',D1		;RT BRACKET (RULE DELIM) MUST BE
	  BNE.S	    PREAT1		;   REMOVED TO PREVENT DEATH
	  MOVE.B    #' ',D1		;   INSERT A BLANK IN ITS PLACE
PREAT1	  ADDQ.W    #1,D3		;BUMP COUNT OF LETTERS IN WORD
	  CMP.W	    #MAXLTRS,D3		;OVERFLOW?
	  BGT.S	    PREERROR
	  MOVE.B    D1,(A2)+		;MOVE CHAR TO WORD
	  CMP.B	    #' ',D0		;WAS LAST CHAR A BLANK
	  BEQ.S	    PREWRDND		;YES, RETURN
	  SUBQ.L    #1,INLENOFF(A5)	;REDUCE COUNT OF REMAINING LTRS
	  BEQ.S	    PREGONE		;IF ZERO, INSERT '#' AND GO AWAY
	  CMP.B	    #'#',D1		;HAVE WE REACHED END OF INPUT STRING
	  BNE.S	    PREMAIN		;NO, CONTINUE
	  CMP.B	    #'#',D0		;MAYBE, LOOK FURTHER
	  BNE.S	    PREMAIN		;NO, CONTINUE
	  CMP.B	    #2,D3		;IF ONLY 2
	  BNE.S	    PRETEST
PREATEND:
	  MOVE.B    #'#',(A1)+
	  MOVEQ	    #0,D3
	  RTS

PRETEST	  SUBQ.L    #1,A0		;YES, BACK UP TO '##'S IN ENGLISH
	  MOVE.B    #' ',-2(A2)		;ADD A BLANK AFTER LAST WORD
	  SUBQ.W    #1,D3		;FIXUP COUNT OF LETTERS

PREWRDND  SUBQ.L    #1,A0		;A0 --> 1ST LETTER OF NEXT WORD
	  SUBQ.W    #1,D3		;REDUCE LENGTH OF WORD
	  RTS

PREERROR  MOVEQ	    #-3,D1		;SET FOR BAD RETURN
	  RTS

PREGONE	  MOVE.B    #' ',(A2)+
	  MOVE.B    #' ',(A2)+
	  RTS


*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*								    ;
*		      ACCENTING POSTPROCESSER			    ;	
*   Accent the first syllable of the previous word if not accented  ; 
*   already and if last replace did not come from an exception.	    ;
*								    ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ACCENTER: 
	BTST	#0,ACCFLAG(A5)	;should we accent?
	BEQ.S	SQUEAK1		;no, bypass
	MOVEM.L D0/D1/A0/A2/A3,-(SP) ;save regs (never touch A1)
	MOVE.L	A1,D0		;compute total len of replacements
	SUB.L	OUTPTR(A5),D0
	CMP.W	#3,D0		;at least 3 chars?
	BLT.S	SQUEAK		;no, get out
	MOVE.L	OUTPTR(A5),A0	;yes, look for a number
SCANUM	MOVEQ	#0,D0
	MOVE.B	(A0)+,D0	;get a char
	ADD.W	D0,D0		;shift for feat index
	MOVE.W	0(A4,D0),D0	;get feature
	BTST	#DIGITBIT,D0	;a number?
	BNE.S	SQUEAK		;yes, get out
	CMP.L	A0,A1		;scan whole word?
	BGT.S	SCANUM		;no, keep scanning
	MOVE.L	OUTPTR(A5),A0	;yes, find first vowel (if any)
	LEA	VOWTBL,A2	;get vowel table address
FINDVOW1 MOVE.B (A0)+,D0	;get 1st char
	LSL.W	#8,D0		;shift to hi byte
	MOVE.B	(A0),D0		;get 2nd char
	MOVEQ	#NUMVOW-1,D1
	MOVE.L	A2,A3		;point to vowel table
FINDVOW CMP.W	(A3)+,D0	;a vowel?
	BEQ.S	ITSAVOW		;yes, branch
	DBF	D1,FINDVOW	;no, keep looking
	CMP.L	A0,A1		;searched whole word?
	BGT.S	FINDVOW1	;no, get next letter pair

* Ran out of letters - no vowel in word.

	BRA.S	SQUEAK		;get out

* First vowel located - insert an accent number

ITSAVOW ADDQ.L	#1,A0		;point to insertion spot
	MOVE.L	A1,A2		;point to word end
INSRT1	MOVE.B	-(A2),1(A2)	;move right portion over one
	CMP.L	A2,A0
	BNE.S	INSRT1
	MOVE.B	#'4',(A0)	;put in number
	ADDQ.L	#1,A1		;increment output pointer
*
SQUEAK	MOVEM.L (SP)+,D0/D1/A0/A2/A3
SQUEAK1 MOVE.L	A1,OUTPTR(A5)	;save new starting point
*
SQUEAK2 RTS

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							  ;
*							  ;
*	  SPECIAL SYMBOL ROUTINES JUMP TABLE		  ;
*							  ;
*							  ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


SYMBASE	  DC.L	    SVOWEL		;POUND
	  DC.L	    OMCONS		;STAR
	  DC.L	    SVCONS		;PERIOD
	  DC.L	    SCONSIE		;DOLLAR
	  DC.L	    SUFFIXES		;PERCENT
	  DC.L	    SIBIL		;AMPERSAND
	  DC.L	    CUAFF		;AT SIGN
	  DC.L	    SCONS		;CARET
	  DC.L	    FVOWEL		;PLUS
	  DC.L	    ZMCONS		;COLON
	  DC.L	    SNUM		;QUESTION
	  DC.L	    ZMNUMS		;UNDERBAR
	  DC.L	    NONLTR		;BLANK


*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							  ;
*							  ;
*		 FEATURE MATRIX				  ;
*							  ;
*							  ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


FEATURES  DC.W	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0	    ;CONTROL
	  DC.W	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0	    ;	CODES
	  DC.W	    SYMBOL+KEYWORD+WORDBRK		    ;BLANK
	  DC.W	    SYMBOL+WORDBRK		;!
	  DC.W	    SYMBOL		;'
	  DC.W	    SYMBOL+KEYWORD+WORDBRK	;#
	  DC.W	    SYMBOL+KEYWORD	;$
	  DC.W	    SYMBOL+KEYWORD	;%
	  DC.W	    SYMBOL+KEYWORD	;&
	  DC.W	    SYMBOL		;'
	  DC.W	    SYMBOL+WORDBRK		;(
	  DC.W	    SYMBOL+WORDBRK		;)
	  DC.W	    SYMBOL+KEYWORD	;*
	  DC.W	    SYMBOL+KEYWORD	;+
	  DC.W	    SYMBOL+WORDBRK		;,
	  DC.W	    SYMBOL+WORDBRK		;-
	  DC.W	    SYMBOL+KEYWORD+WORDBRK	;.
	  DC.W	    SYMBOL		;/
	  DC.W	    DIGIT		;0
	  DC.W	    DIGIT		;1
	  DC.W	    DIGIT		;2
	  DC.W	    DIGIT		;3
	  DC.W	    DIGIT		;4
	  DC.W	    DIGIT		;5
	  DC.W	    DIGIT		;6
	  DC.W	    DIGIT		;7
	  DC.W	    DIGIT		;8
	  DC.W	    DIGIT		;9
	  DC.W	    SYMBOL+KEYWORD	;:
	  DC.W	    SYMBOL		;;
	  DC.W	    SYMBOL		;<
	  DC.W	    SYMBOL		;=
	  DC.W	    SYMBOL		;>
	  DC.W	    SYMBOL+KEYWORD+WORDBRK	;?
	  DC.W	    SYMBOL+KEYWORD	;@@
	  DC.W	    LETTER+VOWEL		  ;A
	  DC.W	    LETTER+CONS+VOICED		  ;B
	  DC.W	    LETTER+CONS+SIBILANT	  ;C
	  DC.W	    LETTER+CONS+VOICED+UAFF	  ;D
	  DC.W	    LETTER+VOWEL+FRONT		  ;E
	  DC.W	    LETTER+CONS			  ;F
	  DC.W	    LETTER+CONS+VOICED+SIBILANT	  ;G
	  DC.W	    LETTER+CONS			  ;H
	  DC.W	    LETTER+VOWEL+FRONT		  ;I
	  DC.W	    LETTER+CONS+VOICED+SIBILANT+UAFF  ;J
	  DC.W	    LETTER+CONS			  ;K
	  DC.W	    LETTER+CONS+VOICED+UAFF	  ;L
	  DC.W	    LETTER+CONS+VOICED		  ;M
	  DC.W	    LETTER+CONS+VOICED+UAFF	  ;N
	  DC.W	    LETTER+VOWEL		  ;O
	  DC.W	    LETTER+CONS			  ;P
	  DC.W	    LETTER+CONS			  ;Q
	  DC.W	    LETTER+CONS+VOICED+UAFF	  ;R
	  DC.W	    LETTER+CONS+SIBILANT+UAFF	  ;S
	  DC.W	    LETTER+CONS+UAFF		  ;T
	  DC.W	    LETTER+VOWEL		  ;U
	  DC.W	    LETTER+CONS+VOICED		  ;V
	  DC.W	    LETTER+CONS+VOICED		  ;W
	  DC.W	    LETTER+CONS+SIBILANT	  ;X
	  DC.W	    LETTER+VOWEL+FRONT		  ;Y
	  DC.W	    LETTER+CONS+VOICED+SIBILANT+UAFF  ;Z
	  DC.W	    SYMBOL		;[
	  DC.W	    SYMBOL		;\
	  DC.W	    SYMBOL		;]
	  DC.W	    SYMBOL+KEYWORD	;^
	  DC.W	    SYMBOL+KEYWORD	;_
	  DC.W	    SYMBOL		;`
	  DC.W	    0,0,0,0,0,0,0,0,0,0,0,0,0	  ;LOWER CASE
	  DC.W	    0,0,0,0,0,0,0,0,0,0,0,0,0	  ;LETTERS
	  DC.W	    SYMBOL		;{
	  DC.W	    SYMBOL		;|
	  DC.W	    SYMBOL		;}
	  DC.W	    SYMBOL		;~
	  DC.W	    0			;DEL



*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							  ;
*							  ;
*	SPECIAL SYMBOLS USED IN LETTER TO SOUND RULES	  ;
*							  ;
*							  ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SYMLIST	  DC.B	    '#'	      ;1 OR MORE VOWELS
	  DC.B	    '*'	      ;1 OR MORE CONSONANTS
	  DC.B	    '.'	      ;A VOICED CONSONANT
	  DC.B	    '$'	      ;SINGLE CONSONANT FOLLOWED BY 'I' OR 'E'
	  DC.B	    '%'	      ;SUFFIX (E, ES, ED, ER, ING, ELY)
	  DC.B	    '&'	      ;A SIBILANT
	  DC.B	    '@@'	      ;A CONSONANT FOLLOWED BY A LONG U
	  DC.B	    '^'	      ;A SINGLE CONSONANT
	  DC.B	    '+'	      ;A FRONT VOWEL (I, E, Y)
	  DC.B	    ':'	      ;0 OR MORE CONSONANTS
	  DC.B	    '?'	      ;A SINGLE DIGIT
	  DC.B	    '_'	      ;0 OR MORE DIGITS
	  DC.B	    ' '	      ;NON-LETTER [never actually compared in dbeq loop]

*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*							 ;
*	 LIST OF VOWELS FOR ACCENTING ROUTINE		 ;
*							 ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NUMVOW	EQU	15
VOWTBL	DC.W	'IH'
	DC.W	'EH'
	DC.W	'AA'
	DC.W	'AE'
	DC.W	'IY'
	DC.W	'AO'
	DC.W	'AH'
	DC.W	'ER'
	DC.W	'OH'
	DC.W	'EY'
	DC.W	'AY'
	DC.W	'OY'
	DC.W	'AW'
	DC.W	'OW'
	DC.W	'UW'


	INCLUDE 'ltrrules.i'

************************


	  END 


@


36.4
log
@fix enforcer hits
@
text
@d2 1
a2 1
**	$Id: translator.asm,v 36.3 90/05/01 16:09:49 kodiak Exp Locker: kodiak $
d4 1
a4 1
**      translator library code
d6 2
a7 2
**      (C) Copyright 1986,1990 Commodore-Amiga, Inc.
**          All Rights Reserved
d9 1
a9 1
	SECTION	translator
d19 1
a19 1
*	D0                  A0        D0        A1         D1
d55 16
a70 16
*                                                                   ;
*                  ENGLISH TO ARPABET TRANSLATOR                    ;
*                                                                   ;
*         CONVERTS ASCII ENGLISH STRING TO ASCII PHONETIC           ;
*         REPRESENTATION.  USES AN EXPANDED NRL RULE SYSTEM.        ;
*                                                                   ;
*         D0 - SCRATCH REGISTER         D1 - LETTER/SCRATCH         ;
*         D2 - SIZE OF HANDLE           D3 - WORD LENGTH            ;
*         D4 - LETTER FEATURE           D5 - SCRATCH                ;
*         D6 - VARIED                   D7 - DIRECTION TO FETCH     ;
*                                                                   ;
*         A0 - ENGLISH INPUT            A1 - PHONETIC OUTPUT        ;
*         A2 - BEG OF CNTR OF RULE      A3 - END OF CNTR OF RULE    ;
*         A4 - FEATURE MATRIX           A5 - PTR TO WORD BUFFER     ;
*         A6 - RULE BASE                A7 - STACK                  ;
*                                                                   ;
d77 3
a79 3
EXCPSHAN  EQU       0		;OFFSET TO EXCEPTIONS HANDLE
RULESHAN  EQU       4		;OFFSET TO RULES HANDLE
STOUTOFF  EQU       8		;OFFSET TO START OF OUTPUT
d83 3
a85 3
WORDBOFF  EQU       22		;OFFSET TO START OF WORD BUFFER
INLENOFF  EQU       130		;OFFSET TO INPUT LENGTH
OUTHDOFF  EQU       182		;OFFSET TO OUTPUT HANDLE
d87 2
a88 2
SYMCNT    EQU       12        	;NUMBER OF SPECIAL SYMBOLS [not including ' ']
MAXLTRS   EQU       100        	;MAX NUMBER OF LETTERS IN A WORD
d91 11
a101 11
SYMBOL    EQU       $1
DIGIT     EQU       $2
UAFF      EQU       $4
VOICED    EQU       $8
SIBILANT  EQU       $10
CONS      EQU       $20
VOWEL     EQU       $40
LETTER    EQU       $80
FRONT     EQU       $100
IGNORE    EQU       $200
KEYWORD   EQU       $400
d104 11
a114 11
SYMBOLBIT  EQU        0
DIGITBIT   EQU        1
UAFFBIT    EQU        2
VOICEDBIT  EQU        3
SIBILBIT   EQU        4
CONSBIT    EQU        5
VOWELBIT   EQU        6
LETTERBIT  EQU        7
FRONTBIT   EQU        8
IGNOREBIT  EQU        9
KEYWORDBIT EQU        10
d120 5
a124 5
*                                                         ;
*                                                         ;
*                  INITIALIZATION CODE                    ;
*                                                         ;
*                                                         ;
d129 1
a129 1
	  MOVEM.L   A2-A6/D2-D7,-(SP)   ;SAVE REGISTERS
d138 2
a139 2
          MOVE.L    #'    ',D0  	;CLEAR WORD BUFFER (108 BYTES)
          MOVEQ     #26,D1
d141 1
a141 1
          DBF       D1,CLEARWDBF
d147 3
a149 3
          MOVE.L    A1,-(SP)            ;SAVE START OF OUTPUT
	  CLR.L     -(SP)		;SPACE FOR RULES HANDLE	  
	  CLR.L     -(SP)		;SPACE FOR EXCEPTIONS HANDLE	  
d151 1
a151 1
          MOVE.L    SP,A5		;SAVE FRAME POINTER
d155 7
a161 7
          MOVEQ     #0,D0		;CLEAR SOME REGISTERS (DON'T CLEAR D2!!)
          MOVEQ     #0,D1
          MOVEQ     #0,D3
          MOVEQ     #0,D4
          MOVEQ     #0,D5
          MOVEQ     #0,D6
          MOVEQ     #0,D7
d164 1
a164 1
          LEA       FEATURES,A4         ;POINTER TO LETTER FEATURES
d167 11
a177 11
*                                                         ;
*                                                         ;
*         MAIN LOOP.                                      ;
*         1)  CHECK TO SEE IF A '#' WAS INSERTED,         ;
*             INDICATING THAT THE INPUT STRING HAS BEEN   ;
*             ENTIRELY PROCESSED,                         ;
*         2)  IF NOT END OF WORD, CONTINUE PROCESSING     ;
*             WITH NEXT LETTER/COMBINATION,               ;
*         3)  IF END OF WORD, CALL PRE-PROCESSOR FOR      ;
*             NEXT WORD.                                  ;
*                                                         ;
d180 4
a183 4
WORDC     CMPI.B    #'#',-1(A1)
          BEQ       RETURN              ;IF "#" INSERTED, END OF STRING
          CMPI.B    #' ',-1(A2)         ;IF BLANK PROCESSED, GET NEXT WORD
          BNE       WORDC1
d186 3
a188 3
          BSR       PREPROC             ;GET NEXT WORD FROM ENGLISH
          MOVE.W    D3,-(SP)		;SAVE RETURN CODE    
          BSR       ACCENTER		;ACCENT THE PREVIOUS WORD
d190 2
a191 2
          BMI.S     FIXUP               ;OVERFLOW MAX # LTRS IN WORD
          BEQ.S     RETURN              ;NOTHING LEFT, GO AWAY
d193 1
a193 1
          BRA.S     WORDC0
d195 2
a196 2
ERROR     MOVE.W    D0,D1               ;SET BAD RETURN CODE
          BRA.S     FIXUP               ;COMMON RETURN CODE
d198 1
a198 1
RETURN    MOVEQ     #0,D1
d206 2
a207 2
          MOVE.L    A1,D0               ;GET CURRENT OUTPUT POS
          SUB.L     STOUTOFF(A5),D0     ;COMPUTE LENGTH OF OUTPUT
d209 2
a210 2
          ADD.L     #134,SP             ;REMOVE FRAME FROM STACK
          MOVEM.L   (SP)+,A2-A6/D2-D7   ;RESTORE REGISTERS
d215 1
a215 1
          RTS                           ;RETURN TO PASCAL
d221 2
a222 2
	  BSR	    CINDEX		;FIND RULE GROUP
	  BSR	    CHECK		;DO EXCP CHECKING
d225 1
a225 1
	  BRA	    WORDC		;EXCP RULE APPLIED, GET NEXT WORD
d231 2
a232 2
	  BSR	    CINDEX		;FIND RULE GROUP
	  BSR	    CHECK		;DO EXCP CHECKING
d235 1
a235 1
	  BRA	    WORDC		;EXCP RULE APPLIED, GET NEXT WORD
d238 5
a242 5
*                                                         ;
*                                                         ;
*              DO RULE CHECKING				  ;
*                                                         ;
*                                                         ;
d245 1
a245 1
CHECK	BSR	CHKCENTR		;CHECK CENTER CONTEXT
d249 2
a250 2
	BSR	CHKLEFT			;CHECK LEFT CONTEXT
	BNE	LNEXTRULE		;UNSUCCESSFUL
d252 2
a253 2
	BNE	LNEXTRULE		;UNSUCCESSFUL
	BSR 	REPLACE			;DO REPLACEMENT
d260 1
a260 1
LNEXTRULE 	MOVE.L	(SP)+,A3	;REMOVE END OF CENTER
d270 3
a272 3
*                                                         ;
*                                                         ;
*              COMPUTE INDEX INTO RULESET		  ;
d281 2
a282 2
*                                                         ;
*                                                         ;
d290 1
a290 1
	BTST	#LETTERBIT,D4   ;LETTER?
d293 1
a293 1
CSYMBOL	MOVE.B	#'Z'+1,D1	;SET RULE PTR TO 'Z'+1 RULESET
d296 1
a296 1
CDIGIT  ADDQ.B	#1,D1		;NO, USE 'Z'+2 RULES
d298 1
a298 1
CLETTER	SUB.B	#'A',D1		;CONVERT TO 'A OFFSET'
d305 5
a309 5
*                                                         ;
*                                                         ;
*              CHECK CENTER PORTION OF RULE               ;
*                                                         ;
*                                                         ;
d312 3
a314 3
CHKCENTR  MOVEQ     #0,D6               ;CLEAR INDEX INTO RULE
          MOVEQ     #-1,D7              ;SET TEMP REG
          MOVE.L    A2,A3
d316 1
a316 1
*         FIND '[', BEGINS CENTER PORTION OF RULE
d318 8
a325 8
CLTR1     MOVE.B    0(A6,D6),D5         ;GET BYTE FROM RULE
          ADDQ.W    #1,D6               ;BUMP RULE INDEX
          CMP.B     #'[',D5             ;IS RULE CHAR='['?
          BNE.S     CLTR1               ;NO, KEEP LOOKING
          ADD.W     D6,D7               ;D7 POINTS TO '['
          SWAP      D6                  ;D6 = POS OF CENTER,0
          MOVE.W    D7,D6               ;D6 = POS OF CENTER, POS OF '['
          SWAP      D6                  ;D6 = POS OF '[', POS OF CENTER
d327 3
a329 3
*         CHECK CENTER PORTION.  ONLY LETTER MATCHING IS ALLOWED.
*         CONTINUE CHECKING UNTIL ']' (RIGHT CONTEXT DELIMITER)
*         IS FOUND.
d331 6
a336 6
CLTR2     MOVE.B    0(A6,D6),D5         ;GET RULE CHAR
          ADDQ.W    #1,D6               ;BUMP RULE INDEX
          CMP.B     #']',D5             ;END OF CENTER CONTEXT?
          BEQ.S     CENTRTN             ;YES, CHECK LEFT CONTEXT
          CMP.B     (A3)+,D5            ;RULE CHAR MATCH ENG CHAR?
          BEQ.S     CLTR2               ;YES, CONTINUE WITH NEXT RULE CHAR
d338 1
a338 1
CENTRTN   RTS
d341 5
a345 5
*                                                         ;
*                                                         ;
*            CHECK 'LEFT' PORTION OF RULE                 ;
*                                                         ;
*                                                         ;
d348 1
a348 1
CHKLEFT   SWAP      D6                  ;POS OF RIGHT CONTEXT, POS OF '['
d350 10
a359 10
CHKLEFT1  SUBQ.W    #1,D6               ;MOVE LEFT ONE CHAR
          BMI.S     CHKLEFTR            ;DONE, RETURN WITH GOOD RC
          MOVE.B    0(A6,D6),D5         ;GET RULE CHAR
          MOVE.W    D5,D4
          LSL.B     #1,D4               ;FEATURE MATRIX INDEX
          MOVE.W    0(A4,D4),D4         ;GET FEATURES
          BTST      #KEYWORDBIT,D4      ;SPECIAL SYMBOL?
          BNE.S     LSYMBOL             ;YES
          CMP.B     -(A2),D5            ;NO, COMPARE WITH LEFT CHAR
          BEQ.S     CHKLEFT1            ;IF MATCH, CONTINUE
d364 3
a366 3
LSYMBOL   MOVEQ     #1,D7               ;SET LEFT MOVING FETCH
          BSR       SYMHDLR             ;GO DO SYMBOL CHECKING
          BNE.S     CHKLEFT1            ;RULE WAS SUCCESSFUL
d373 5
a377 5
*                                                         ;
*                                                         ;
*            CHECK 'RIGHT' PORTION OF RULE                ;
*                                                         ;
*                                                         ;
d380 15
a394 15
CHKRIGHT  MOVE.L    4(SP),A2            ;GET RIGHT POINTER INTO A2
          SWAP      D6                  ;RESTORE RIGHT CONTEXT POINTER
*                                       ;   IN LOWER HALF OF D6
CHKR1     MOVE.B    0(A6,D6),D5         ;GET RULE CHAR
          ADDQ.W    #1,D6
          CMP.B     #'=',D5             ;END OF RIGHT CONTEXT?
          BEQ.S     CHKRRTN             ;YES, DO REPLACEMENT
          MOVE.W    D5,D4
          LSL.B     #1,D4
          MOVE.W    0(A4,D4),D4         ;GET FEATURES
          BTST      #KEYWORDBIT,D4      ;SPECIAL SYMBOL?
          BNE.S     RSYMBOL             ;YES, TRY SYMBOL
          CMP.B     (A2)+,D5            ;NO, COMPARE WITH RULE CHAR
          BEQ.S     CHKR1               ;IF MATCH, CONTINUE CHECKING
CHKRRTN   RTS
d396 3
a398 3
RSYMBOL   MOVEQ     #-1,D7              ;SET RIGHT FETCHES
          BSR       SYMHDLR             ;GO DO SYMBOL CHECKING
          BNE.S     CHKR1               ;RULE WAS SUCCESSFUL
d404 5
a408 5
*                                                         ;
*                                                         ;
*       EVERYTHING IS JUST GREAT, DO REPLACEMENT          ;
*                                                         ;
*                                                         ;
d412 1
a412 1
*         FIND LENGTH OF REPLACEMENT TEXT
d414 3
a416 3
          MOVE.W    D6,D7               ;CURRENT POS
          SUBQ.W    #1,D7               ;BACKUP IN PREPARATION
REPL1     ADDQ.W    #1,D7               ;MOVE FORWARD ONE CHAR
d418 3
a420 3
          CMP.B     #'\',D0		;AT END?
          BEQ.S     REPL1X              ;YES
	  CMP.B     #'`',D0		;AT END?
d422 1
a422 1
REPL1X    SUB.W     D6,D7               ;COMPUTE LENGTH OF REPL TEXT
d426 1
a426 1
*         INSURE THAT REPLACEMENT TEXT WILL FIT IN OUTPUT
d428 5
a432 5
REPL2     MOVE.L    A1,D0               ;GET CURRENT POS
          SUB.L     STOUTOFF(A5),D0     ;COMPUTE NUMBER OF BYTES IN OUTPUT
          ADD.W     D7,D0               ;NEW LENGTH
          CMP.W     D2,D0               ;BIGGER THAN BLOCK SIZE?
          BGE.S     OVERFLOW            ;YES, DO OVERFLOW PROCESSING
d434 1
a434 1
*         NEW TEXT FITS IN OUTPUT
d436 2
a437 2
DOREPLCE  AND.L     #$0000FFFF,D6       ;CLEAR UPPER HALF OF D6
          ADD.L     D6,A6               ;POINT A6 TO BEG OF REPL TEXT
d439 3
a441 3
          BRA.S     REPBLOOP            ;BEGIN LOOP
REPLOOP   MOVE.B    (A6)+,(A1)+         ;MOVE CHARS
REPBLOOP  DBF       D7,REPLOOP          ;LOOP FOR LENGTH OF REPL TEXT
d461 1
a461 1
	  MOVEQ     #0,D0
d466 1
a466 1
	  BNE.S     OVERFL1		;YES
d472 1
a472 1
	  BEQ.S     OVERFL2
d475 3
a477 3
OVERFL1	  MOVE.B    #0,(A1)+            ;PUT IN A NULL
*          MOVE.B    #0,(A1)           	;NULL TERMINATE STRING
          SUB.L     D3,A0               ;ADJUST ENGLISH STRING POINTER
d487 6
a492 6
*                                                         ;
*                                                         ;
*           GIVEN A SPECIAL SYMBOL IN D5, FIND AND        ;
*           EXECUTE THE APPROPRIATE ROUTINE               ;
*                                                         ;
*                                                         ;
d495 8
a502 8
SYMHDLR   LEA       SYMLIST,A3          ;LIST OF SPECIAL SYMBOLS
          MOVE.W    #SYMCNT-1,D0
SYMHDLR1  CMP.B     (A3)+,D5
          DBEQ      D0,SYMHDLR1
          NEG.W     D0
          ADD.W     #SYMCNT-1,D0
          LSL.W     #2,D0               ;FOUND OFFSET TO SPECIAL SYMBOL
          LEA       SYMBASE,A3          ;GET BASE OF SYMBOL ROUTINES
d504 1
a504 1
          MOVE.L    0(A3,D0),A3         ;GET SPECIFIC SYMBOL ROUTINE
d506 2
a507 2
          JSR       (A3)                ;GO DO IT
          RTS                           ;AND RETURN
d512 8
a519 8
*                                                         ;
*                                                         ;
*      FETCHES A CHARACTER FROM THE 'WORD' BUFFER         ;
*      INTO D1 AND ASSOCIATED FEATURES INTO D4.           ;
*      ON ENTRY D7 CONTAINS A +IVE VALUE IF THE CHAR      ;
*      IS TO BE FETCHED FROM THE LEFT AND A -IVE VALUE    ;
*      IF THE FETCHING IS TO BE DONE FROM THE RIGHT       ;
*                                                         ;
d522 10
a531 10
FETCH     TST.W     D7                  ;CHECK D7
          BMI.S     FETCH1              ;-IVE, LOOK TO THE RIGHT
          MOVE.B    -(A2),D1            ;GET CHAR ON LEFT
          BRA.S     FETCH2              ;GO GET FEATURES
FETCH1    MOVE.B    (A2)+,D1            ;GET CHAR ON RIGHT
FETCH2    MOVEQ     #0,D4
          MOVE.B    D1,D4
          LSL.B     #1,D4
          MOVE.W    0(A4,D4),D4         ;GET FEATURES
          RTS
d536 7
a542 7
*                                                         ;
*                                                         ;
*      THE FOLLOWING SUBROUTINES HANDLE CHECKS FOR        ;
*      THE VARIOUS SPECIAL SYMBOLS THAT COULD APPEAR      ;
*      IN A RULE.  ALL SET CC = 0 IF THE RULE DOES NOT    ;
*      APPLY, AND INSURE CC != 0 IF RULE DOES APPLY.      ;
*                                                         ;
d547 1
a547 1
*         CHECK FOR A SINGLE VOWEL
d550 3
a552 3
SVOWEL    BSR       FETCH               ;GET CHAR (AND FEATURES) FROM ENG
          BTST      #VOWELBIT,D4        ;DO TEST FOR VOWEL
          RTS
d556 1
a556 1
*         CHECK FOR ONE OR MORE CONSONANT
d559 8
a566 8
OMCONS    BSR       FETCH               ;GET NEXT CHAR
          BTST      #CONSBIT,D4
          BEQ.S     OMCONS1             ;NOT A CONSONANT, RULE FAILS
OMCONS0   BSR       FETCH               ;AT LEAST ONE CONS, KEEP LOOKING
          BTST      #CONSBIT,D4         ;
          BNE.S     OMCONS0             ;GET EM ALL
          MOVE.W    #$08,CCR            ;SET N BIT, CLEAR Z BIT, GOOD RTN
OMCONS1   RTS
d568 1
a568 1
*         CHECK FOR A SINGLE VOICED CONSONANT
d571 5
a575 5
SVCONS    BSR       FETCH               ;GET CHAR AND FEATURES
          BTST      #VOICEDBIT,D4       ;VOICED?
          BEQ.S     SVCONS1             ;NO, RETURN
          BTST      #CONSBIT,D4         ;CONSONANT?
SVCONS1   RTS                           ;RETURN, RC IS IMPLICITLY SET
d579 1
a579 1
*         CHECK FOR A SINGLE CONSONANT FOLLOWED BY AN 'I' OR 'E'
d582 11
a592 11
SCONSIE   BSR       FETCH               ;GET CHAR AND FEATURES
          BTST      #CONSBIT,D4         ;CONSONANT?
          BEQ.S     SCONSIE2            ;NO, RETURN
          BSR       FETCH               ;GET NEXT CHAR AND FEATURES
          CMP.B     #'I',D1             ;IS IT AN 'I'?
          BEQ.S     SCONSIE1            ;YES
          CMP.B     #'E',D1             ;IS IT AN 'E'?
          BEQ.S     SCONSIE1            ;YES
          MOVE.W    #$04,CCR            ;NO, BAD RETURN, SET Z BIT
          RTS                           ;   AND RETURN
SCONSIE1  MOVE.W    #$08,CCR            ;SET N BIT, GOOD RETURN
d597 2
a598 2
*         CHECK FOR ONE OF THE FOLLOWING SUFFIXES:
*         E, ES, ED, ER, ING, ELY, ERS OR INGS.
d601 37
a637 37
SUFFIXES  BSR       FETCH
          CMP.B     #'E',D1             ;IS IT AN E?
          BNE.S     SUFFI               ;NO, TRY AN I ENDING SUFFIX
          BSR       FETCH
          BTST      #LETTERBIT,D4
          BEQ.S     SUFFOK
          CMP.B     #'S',D1
          BEQ.S     SUFFCK              ;ES
          CMP.B     #'D',D1
          BEQ.S     SUFFCK              ;ED
          CMP.B     #'R',D1
*         BEQ.S     SUFFCK              ;ER		!!!sam 10/26/85!!!
          BEQ.S     SUFFS               ;ER		!!!sam 10/26/85!!!
          CMP.B     #'L',D1
          BNE.S     SUFFNO
          BSR       FETCH
          CMP.B     #'Y',D1
          BEQ.S     SUFFCK              ;ELY
          BRA.S     SUFFNO
SUFFI     BSR       FETCH
          CMP.B     #'N',D1
          BNE.S     SUFFNO
          BSR       FETCH
          CMP.B     #'G',D1
          BNE.S     SUFFNO              ;ING
SUFFS     BSR       FETCH				!!!sam 10/26/85!!!
          BTST      #LETTERBIT,D4			!!!sam 10/26/85!!!
          BEQ.S     SUFFOK				!!!sam 10/26/85!!!
          CMP.B     #'S',D1				!!!sam 10/26/85!!!
          BNE.S     SUFFNO              ;INGS OR ERS	!!!sam 10/26/85!!!
SUFFCK    BSR       FETCH
          BTST      #LETTERBIT,D4
          BEQ.S     SUFFOK
SUFFNO    MOVE.W    #$04,CCR            ;BAD RETURN
          RTS
SUFFOK    MOVE.W    #$08,CCR            ;GOOD RETURN
          RTS
d641 1
a641 1
*         CHECK FOR A SIBILANT
d644 3
a646 3
SIBIL     BSR       FETCH
          BTST      #SIBILBIT,D4
          RTS
d650 1
a650 1
*         CHECK FOR A CONSONANT WITH A U AFFECTATION
d653 3
a655 3
CUAFF     BSR       FETCH
          BTST      #UAFFBIT,D4
          RTS
d659 1
a659 1
*         CHECK FOR A SINGLE CONSONANT
d662 3
a664 3
SCONS     BSR       FETCH
          BTST      #CONSBIT,D4
          RTS
d668 1
a668 1
*         CHECK FOR A FRONT VOWEL
d671 3
a673 3
FVOWEL    BSR       FETCH
          BTST      #FRONTBIT,D4
          RTS
d677 1
a677 1
*         CHECK FOR ZERO OR MORE CONSONANT
d680 6
a685 6
ZMCONS    BSR       FETCH
          BTST      #CONSBIT,D4
          BNE.S     ZMCONS
          ADD.L     D7,A2               ;FIXUP A2
          MOVE.W    #$08,CCR            ;GOOD RC
          RTS
d689 1
a689 1
*         CHECK FOR A SINGLE NUMERAL (DIGIT)
d692 3
a694 3
SNUM      BSR       FETCH
          BTST      #DIGITBIT,D4
          RTS
d698 1
a698 1
*         CHECK FOR ZERO OR MORE NUMERALS (DIGITS)
d701 6
a706 6
ZMNUMS    BSR       FETCH
          BTST      #DIGITBIT,D4
          BNE.S     ZMNUMS
          ADD.L     D7,A2               ;FIXUP A2
          MOVE.W    #$08,CCR            ;GOOD RETURN
          RTS
d710 1
a710 1
*         CHECK FOR A NON LETTER
d713 7
a719 7
NONLTR    BSR       FETCH
          BTST      #LETTERBIT,D4       ;LETTER BIT ON?
          BNE.S     NONLTR1             ;YES, RULE FAILS
          MOVE.W    #$08,CCR            ;RULE CHECKS, SET GOOD RETURN
          RTS
NONLTR1   MOVE.W    #$04,CCR            ;RULE FAILS, SET BAD RETURN
          RTS
d725 10
a734 10
*                                                         ;
*                                                         ;
*                     PREPROCESSOR                        ;
*                                                         ;
*      CURRENTLY THE PREPROCESSOR ISOLATES WORDS,         ;
*      CHECKS TO SEE THAT THE CHARACTERS ARE VALID        ;
*      ASCII CODES, AND CONVERTS LOWER CASE TO UPPER      ;
*      CASE.  THE LENGTH OF THE WORD IS RETURNED IN       ;
*      D3.                                                ;
*                                                         ;
d737 10
a746 10
PREPROC   LEA	    WORDBOFF(A5),A2     ;POINTER TO WORD BUFFER
          MOVE.B    0(A2,D3),(A2)+      ;GET LAST CHAR OF PREVIOUS WORD
          MOVE.B    #' ',(A2)+          ;MOVE IN A BLANK
          MOVEQ     #0,D0               ;CLEAR SOME REGS
          MOVEQ     #0,D1
          MOVEQ     #0,D3
          TST.L     INLENOFF(A5)
          BLE.S     PREATEND
PREMAIN   MOVE.B    D1,D0
          MOVE.B    (A0)+,D1            ;GET CHAR FROM ENGLISH STRING
d751 11
a761 11
PRENOTNUL CMP.B     #' ',D1             ;CHECK AGAINST ASCII BLANK
          BGE.S     PREAT0              ;GREATER OR EQUAL, USE CHAR
          MOVE.B    #' ',D1             ;NOT AN ASCII CHAR, SUBST A BLANK
PREAT0    CMP.B     #$7F,D1             ;CHECK AGAINST DEL CHAR
          BNE.S     PREAT00             ;NOT A DEL
          MOVE.B    #' ',D1             ;NOT AN ASCII CHAR, SUBST A BLANK
PREAT00   CMP.B     #'a',D1             ;CHECK FOR LOWER CASE
          BLT.S     PRENOTLC
          CMP.B     #'z',D1
          BGT.S     PRENOTLC
          SUB.B     #'a'-'A',D1         ;IF LOWER CASE, CONVERT TO UC
d763 17
a779 17
PRENOTLC  CMP.B     #']',D1             ;RT BRACKET (RULE DELIM) MUST BE
          BNE.S     PREAT1              ;   REMOVED TO PREVENT DEATH
          MOVE.B    #' ',D1             ;   INSERT A BLANK IN ITS PLACE
PREAT1    ADDQ.W    #1,D3               ;BUMP COUNT OF LETTERS IN WORD
          CMP.W     #MAXLTRS,D3         ;OVERFLOW?
          BGT.S     PREERROR
          MOVE.B    D1,(A2)+            ;MOVE CHAR TO WORD
          CMP.B     #' ',D0             ;WAS LAST CHAR A BLANK
          BEQ.S     PREWRDND            ;YES, RETURN
          SUBQ.L    #1,INLENOFF(A5)     ;REDUCE COUNT OF REMAINING LTRS
          BEQ.S     PREGONE             ;IF ZERO, INSERT '#' AND GO AWAY
          CMP.B     #'#',D1             ;HAVE WE REACHED END OF INPUT STRING
          BNE.S     PREMAIN             ;NO, CONTINUE
          CMP.B     #'#',D0             ;MAYBE, LOOK FURTHER
          BNE.S     PREMAIN             ;NO, CONTINUE
          CMP.B     #2,D3               ;IF ONLY 2
          BNE.S     PRETEST
d781 3
a783 3
          MOVE.B    #'#',(A1)+
          MOVEQ     #0,D3
          RTS
d785 3
a787 3
PRETEST   SUBQ.L    #1,A0               ;YES, BACK UP TO '##'S IN ENGLISH
          MOVE.B    #' ',-2(A2)         ;ADD A BLANK AFTER LAST WORD
          SUBQ.W    #1,D3               ;FIXUP COUNT OF LETTERS
d789 3
a791 3
PREWRDND  SUBQ.L    #1,A0               ;A0 --> 1ST LETTER OF NEXT WORD
          SUBQ.W    #1,D3               ;REDUCE LENGTH OF WORD
          RTS
d793 2
a794 2
PREERROR  MOVEQ     #-3,D1              ;SET FOR BAD RETURN
          RTS
d796 3
a798 3
PREGONE   MOVE.B    #' ',(A2)+
          MOVE.B    #' ',(A2)+
          RTS
d803 1
a803 1
*                     ACCENTING POSTPROCESSER			    ;   
d805 2
a806 2
*   already and if last replace did not come from an exception.     ;
*							            ;
d809 2
a810 2
        BTST    #0,ACCFLAG(A5)  ;should we accent?
	BEQ     SQUEAK1	        ;no, bypass
d824 1
a824 1
	BGT	SCANUM		;no, keep scanning
d827 1
a827 1
FINDVOW1 MOVE.B	(A0)+,D0	;get 1st char
d836 1
a836 1
	BGT	FINDVOW1	;no, get next letter pair
d844 2
a845 2
ITSAVOW	ADDQ.L	#1,A0		;point to insertion spot
        MOVE.L  A1,A2		;point to word end
d848 1
a848 1
	BNE	INSRT1
d852 1
a852 1
SQUEAK	MOVEM.L	(SP)+,D0/D1/A0/A2/A3
d858 5
a862 5
*                                                         ;
*                                                         ;
*         SPECIAL SYMBOL ROUTINES JUMP TABLE              ;
*                                                         ;
*                                                         ;
d866 13
a878 13
SYMBASE   DC.L      SVOWEL              ;POUND
          DC.L      OMCONS              ;STAR
          DC.L      SVCONS              ;PERIOD
          DC.L      SCONSIE             ;DOLLAR
          DC.L      SUFFIXES            ;PERCENT
          DC.L      SIBIL               ;AMPERSAND
          DC.L      CUAFF               ;AT SIGN
          DC.L      SCONS               ;CARET
          DC.L      FVOWEL              ;PLUS
          DC.L      ZMCONS              ;COLON
          DC.L      SNUM                ;QUESTION
          DC.L      ZMNUMS              ;UNDERBAR
          DC.L      NONLTR              ;BLANK
d882 5
a886 5
*                                                         ;
*                                                         ;
*                FEATURE MATRIX                           ;
*                                                         ;
*                                                         ;
d890 74
a963 74
FEATURES  DC.W      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CONTROL
          DC.W      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;   CODES
          DC.W      SYMBOL+KEYWORD+WORDBRK                  ;BLANK
          DC.W      SYMBOL+WORDBRK              ;!
          DC.W      SYMBOL              ;'
          DC.W      SYMBOL+KEYWORD+WORDBRK      ;#
          DC.W      SYMBOL+KEYWORD      ;$
          DC.W      SYMBOL+KEYWORD      ;%
          DC.W      SYMBOL+KEYWORD      ;&
          DC.W      SYMBOL              ;'
          DC.W      SYMBOL+WORDBRK              ;(
          DC.W      SYMBOL+WORDBRK              ;)
          DC.W      SYMBOL+KEYWORD      ;*
          DC.W      SYMBOL+KEYWORD      ;+
          DC.W      SYMBOL+WORDBRK              ;,
          DC.W      SYMBOL+WORDBRK              ;-
          DC.W      SYMBOL+KEYWORD+WORDBRK      ;.
          DC.W      SYMBOL              ;/
          DC.W      DIGIT               ;0
          DC.W      DIGIT               ;1
          DC.W      DIGIT               ;2
          DC.W      DIGIT               ;3
          DC.W      DIGIT               ;4
          DC.W      DIGIT               ;5
          DC.W      DIGIT               ;6
          DC.W      DIGIT               ;7
          DC.W      DIGIT               ;8
          DC.W      DIGIT               ;9
          DC.W      SYMBOL+KEYWORD      ;:
          DC.W      SYMBOL              ;;
          DC.W      SYMBOL              ;<
          DC.W      SYMBOL              ;=
          DC.W      SYMBOL              ;>
          DC.W      SYMBOL+KEYWORD+WORDBRK      ;?
          DC.W      SYMBOL+KEYWORD      ;@@
          DC.W      LETTER+VOWEL                  ;A
          DC.W      LETTER+CONS+VOICED            ;B
          DC.W      LETTER+CONS+SIBILANT          ;C
          DC.W      LETTER+CONS+VOICED+UAFF       ;D
          DC.W      LETTER+VOWEL+FRONT            ;E
          DC.W      LETTER+CONS                   ;F
          DC.W      LETTER+CONS+VOICED+SIBILANT   ;G
          DC.W      LETTER+CONS                   ;H
          DC.W      LETTER+VOWEL+FRONT            ;I
          DC.W      LETTER+CONS+VOICED+SIBILANT+UAFF  ;J
          DC.W      LETTER+CONS                   ;K
          DC.W      LETTER+CONS+VOICED+UAFF       ;L
          DC.W      LETTER+CONS+VOICED            ;M
          DC.W      LETTER+CONS+VOICED+UAFF       ;N
          DC.W      LETTER+VOWEL                  ;O
          DC.W      LETTER+CONS                   ;P
          DC.W      LETTER+CONS                   ;Q
          DC.W      LETTER+CONS+VOICED+UAFF       ;R
          DC.W      LETTER+CONS+SIBILANT+UAFF     ;S
          DC.W      LETTER+CONS+UAFF              ;T
          DC.W      LETTER+VOWEL                  ;U
          DC.W      LETTER+CONS+VOICED            ;V
          DC.W      LETTER+CONS+VOICED            ;W
          DC.W      LETTER+CONS+SIBILANT          ;X
          DC.W      LETTER+VOWEL+FRONT            ;Y
          DC.W      LETTER+CONS+VOICED+SIBILANT+UAFF  ;Z
          DC.W      SYMBOL              ;[
          DC.W      SYMBOL              ;\
          DC.W      SYMBOL              ;]
          DC.W      SYMBOL+KEYWORD      ;^
          DC.W      SYMBOL+KEYWORD      ;_
          DC.W      SYMBOL              ;`
          DC.W      0,0,0,0,0,0,0,0,0,0,0,0,0     ;LOWER CASE
          DC.W      0,0,0,0,0,0,0,0,0,0,0,0,0     ;LETTERS
          DC.W      SYMBOL              ;{
          DC.W      SYMBOL              ;|
          DC.W      SYMBOL              ;}
          DC.W      SYMBOL              ;~
          DC.W      0                   ;DEL
d968 5
a972 5
*                                                         ;
*                                                         ;
*       SPECIAL SYMBOLS USED IN LETTER TO SOUND RULES     ;
*                                                         ;
*                                                         ;
d975 13
a987 13
SYMLIST   DC.B      '#'       ;1 OR MORE VOWELS
          DC.B      '*'       ;1 OR MORE CONSONANTS
          DC.B      '.'       ;A VOICED CONSONANT
          DC.B      '$'       ;SINGLE CONSONANT FOLLOWED BY 'I' OR 'E'
          DC.B      '%'       ;SUFFIX (E, ES, ED, ER, ING, ELY)
          DC.B      '&'       ;A SIBILANT
          DC.B      '@@'       ;A CONSONANT FOLLOWED BY A LONG U
          DC.B      '^'       ;A SINGLE CONSONANT
          DC.B      '+'       ;A FRONT VOWEL (I, E, Y)
          DC.B      ':'       ;0 OR MORE CONSONANTS
          DC.B      '?'       ;A SINGLE DIGIT
          DC.B      '_'       ;0 OR MORE DIGITS
          DC.B      ' '       ;NON-LETTER [never actually compared in dbeq loop]
d991 1
a991 1
*        LIST OF VOWELS FOR ACCENTING ROUTINE            ;
d995 1
a995 1
NUMVOW  EQU	15
d1013 1
a1013 1
	INCLUDE	'ltrrules.i'
d1018 1
a1018 1
          END 
@


36.3
log
@put SYMCNT back to 12 and document unreferenced ' ' symbol
@
text
@d2 1
a2 1
**	$Id: translator.asm,v 36.2 90/04/09 15:58:48 kodiak Exp Locker: kodiak $
d227 3
a229 2
WORDC1	  MOVE.L    RULESHAN(A5),A6	;DO BASIC RULES
	  MOVE.L    (A6),A6		;DEREFERENCE TO POINTER
@


36.2
log
@resident tag version
upped SYMCNT to include space
@
text
@d2 1
a2 1
**	$Id$
d87 1
a87 1
SYMCNT    EQU       13        	;NUMBER OF SPECIAL SYMBOLS (WAS 12 for V34)
d986 1
a986 1
          DC.B      ' '       ;NON-LETTER
@


36.1
log
@remove MAC and AMIGA defines and remove all vestiges of MAC code
update documentation
@
text
@d1 9
a9 31
	TTL	'$Header: translator.asm,v 36.0 89/05/24 10:11:16 kodiak Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1986, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
* $Header: translator.asm,v 36.0 89/05/24 10:11:16 kodiak Exp $
*
* $Locker: kodiak $
*
* $Log:	translator.asm,v $
*   Revision 36.0  89/05/24  10:11:16  kodiak
*   *** empty log message ***
*   
* Revision 32.2  86/06/24  13:15:02  sam
* autodoc updates
* 
* Revision 32.1  86/01/22  01:17:52  sam
* placed under source control
* 
*
**********************************************************************
       	SECTION		reader
a11 2


a50 6
*
*   REGISTER USAGE
*
*
*   IMPLEMENTAION
*
d73 1
a73 1
	XDEF	Reader
d87 1
a87 1
SYMCNT    EQU       12        	;NUMBER OF SPECIAL SYMBOLS	!!! = 13
d128 2
a129 1
Reader    MOVEM.L   A2-A6/D2-D7,-(SP)   ;SAVE REGISTERS
@


36.0
log
@*** empty log message ***
@
text
@d1 1
a1 1
	TTL	'$Header: translator.asm,v 32.2 86/06/24 13:15:02 sam Exp $'
d15 1
a15 1
* $Header: translator.asm,v 32.2 86/06/24 13:15:02 sam Exp $
d17 1
a17 1
* $Locker:  $
d20 3
d39 1
a39 1
*	Translate - Converts an English string into phonemes
d42 2
a43 2
*	rtnCode = Translate(instring, inlen, outbuf, outlen)
*	D0		    A0	      D0     A1	     D1
d45 2
a46 5
*	LONG rtnCode;
*	CPTR instring;
*	LONG inlen;
*	CPTR outbuf;
*	LONG outlen;
d54 4
a57 5
*	instring - pointer to English string
*	inlen	 - length of English string
*	outbuf   - a char array which will hold the phonetic codes
*	outlen   - the length of the output array
*	
d60 9
a68 13
*	rtnCode - 
*	    Translate will return a zero if no error has occured.
*	    The only error that can occur is overflowing the output
*	    buffer.  If Translate determines that an overflow will
*	    occur, it will stop the translation at a word boundary
*	    before the overflow happens.  If this occurs, Translate
*	    will return a negative number whose absolute value 
*	    indicates where in the INPUT string Translate stopped.
*	    The user can then use the offset -rtnCode from the
*	    beginning of the buffer in a subsequent Translate call
*	    to continue the translation where s/he left off.
*	
*    BUGS
d71 2
a72 1
*	translator.device/OpenLibrary, translator.device/CloseLibrary
d81 2
a104 6
*-------- SOME HANDY EQUATES

MAC	  EQU	    0
AMIGA     EQU       1


d117 1
a117 1
SYMCNT    EQU       12        	;NUMBER OF SPECIAL SYMBOLS
d158 1
a158 1
	  IFNE	     MAC		;INITIALIZATION, MAC VERSION:
a159 62
*-------- INSURE NON-NIL OUTPUT HANDLE


          MOVE.L    4(SP),A0            ;    GET OUTPUT HANDLE
          CMP.L     #0,A0               ;    NIL?
          BNE.S     GOTHANDLE           ;    NO, BRANCH
          MOVE.W    #nilHandleErr,D0    ;    YES, SET HANDLE ERROR


*-------- NIL HANDLE, RETURN AN ERROR

HANDLERR  MOVE.L    (SP),8(SP)          ;    MOVE RTN ADDR
          ADDQ.L    #8,SP               ;    FIX STACK
          MOVE.W    D0,4(SP)            ;    SET ERROR RC
          RTS


*-------- HAVE A NON-NIL HANDLE. IF HANDLESIZE <> 0 WE HAVE A BUFFER
*         IF =0 WE WILL ALLOCATE A 1K BUFFER

GOTHANDLE MOVE.L    (A0),D0             ;    GET MASTER POINTER
          AND.L     LO3BYTES,D0         ;    USE 24 BIT ADDRESSING
          BNE.S     GOTBUFFER           ;    BRANCH IF HAVE A BUFFER,
          MOVE.L    #1024,D0            ;    ELSE, ALLOCATE 1K BUFFER
*          _ReallocHandle                ;
          BNE.S     HANDLERR            ;    ERROR, PROPIGATE ERR CODE D0


*-------- GOT A BUFFER, LOCK IT AND DEREFERENCE TO POINTER

*GOTBUFFER _HLock                        ;    LOCK IT
          BNE.S     HANDLERR            ;    CANT, PROPIGATE ERR CODE (D0)
*          _GetHandleSize                ;    GET LOGICAL BLOCK SIZE
          MOVE.L    D0,D2               ;    SET D2 TO LOGICAL BLOCK SIZE
          MOVE.L    (A0),D0             ;    DEREFERNCE HANDLE
	  AND.L     LO3BYTES,D0 	;    USE 24 BIT ADDRESSING
	  MOVE.L    D0,A1		;    PUT IN A0
          ENDC

*-------- END OF MAC INITIALIZATION ------------------------------------




*          IFNE      AMIGA               ;INITIALIZATION, AMIGA VERSION:
*Reader	  MOVE.L    4(SP),A1            ;    GET ADDRESS OF OUTPUT BFR
*          ENDC

*-------- END OF AMIGA INITIALIZATION ----------------------------------





*          MOVE.L    12(SP),A0           ;GET ENGLISH STRING
*          MOVE.L    8(SP),D0            ;GET ENGLISH STRING LENGTH
*	  IFNE	    AMIGA
*	  MOVE.L    16(SP),D1           ;GET LENGTH OF OUTPUT (AMIGA ONLY)
*	  ENDC

Reader    MOVEM.L   A2-A6/D2-D7,-(SP)   ;SAVE REGISTERS
	  IFNE	    AMIGA
a161 1
	  ENDC
d182 1
a182 13
	  IFNE	    MAC
	  MOVE.L    A0,A2		;SAVE POINTER TO ENGLISH STRING
	  MOVE.L    A1,A4		;SAVE POINTER TO START OF OUTPUT
	  MOVE.W    #129,-(SP)		;GET RULES
	  BSR       GetRuleSet
	  BNE.S	    ERROR
	  MOVE.L    A0,RULESHAN(A5)	;SAVE IN FRAME
 	  
 	  MOVE.W    #130,-(SP)		;GET EXCEPTIONS
	  BSR	    GetRuleSet
	  BEQ.S	    GOTEXCP		;GOT EXCEPTIONS
	  CMP.W	    #memFullErr,D0	;CHECK RETURN CODE
	  BNE.S	    GOTEXCP		;EXCEPTIONS NOT FOUND, ONLY USE RULES
a183 22
*-------- Could not load exceptions into memory, fatal error

	  MOVE.L    RULESHAN(A5),A0	;GET RULES HANDLE
	  MOVE.W    D0,-(SP)		;SAVE ERROR RETURN
*	  _HPurge			;MAKE RULES RESOURCE PURGEABLE
	  MOVE.W    (SP)+,D0		;RESTORE ERROR RETURN
	  BRA.S	    ERROR		;RETURN

GOTEXCP   MOVE.L    A0,EXCPSHAN(A5)	;SAVE EXCEPTIONS HANDLE IN FRAME
	  BEQ.S	    NOEXCPS		;EXCPS HANDLE NIL, NO EXCPS
*	  _HLock			;LOCK EXCPS HANDLE
NOEXCPS	  MOVE.L    RULESHAN(A5),A0	;GET RULES HANDLE
*	  _HLock			;LOCK IT

	  MOVE.L    A2,A0		;RESTORE ENGLISH POINTER
	  MOVE.L    A4,A1		;RESTORE START OF OUTPUT POINTER
	  ENDC

	  IFNE	    AMIGA
	  MOVE.L    #0,EXCPSHAN(A5)	;    NO EXCPS ARE TO BE USED
	  ENDC

d229 1
a229 1
	  IFNE	AMIGA
a230 1
	  ENDC
a233 14
	  IFNE	    MAC	
	  MOVE.W    D1,-(SP)		;SAVE RETURN CODE
	  MOVE.L    RULESHAN(A5),A0	;GET RULES HANDLE
	  CMP.L	    #0,A0		;NIL?
	  BEQ.S	    FIX1		;YES, SKIP
*	  _HUnlock			;UNLOCK RESOURCE
*	  _HPurge			;MAKE IT PURGEABLE
FIX1	  MOVE.L    EXCPSHAN(A5),A0	;GET EXCEPTIONS HANDLE
	  CMP.L     #0,A0		;NIL?
	  BEQ.S	    FIX2		;YES, SKIP
*	  _HUnlock			;UNLOCK IT
*	  _HPurge			;MAKE IT PURGEABLE
FIX2	  MOVE.W    (SP)+,D1		;RESTORE RETURN CODE
	  ENDC
a240 13
          IFNE      MAC                 ;MACINTOSH CLEANUP
          MOVE.L    4(SP),A0            ;   GET OUTPUT HANDLE
*          _SetHandleSize                ;   SET SIZE TO OUTPUT SIZE
*          _HUnlock                      ;   UNLOCK HANDLE
          ENDC

	  IFNE 	MAC
          MOVE.L    (SP),12(SP)         ;MOVE RETURN ADDRESS
          ADD.L     #12,SP              ;REMOVE PARMS FROM STACK
          MOVE.W    D1,4(SP)            ;STORE RETURN CODE
	  ENDC

	  IFNE	AMIGA
a242 1
	  ENDC
a257 1
	  IFNE	    AMIGA
a258 1
	  ENDC
a331 1
	IFNE	MAC
a334 17
*              READ A RULESET FROM DISK			  ;
*                                                         ;
*                                                         ;
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

GetRuleSet:
	MOVE.L	(SP)+,A0	;GET RETURN ADDR
	MOVE.W	(SP)+,D7	;GET RESOURCE ID
	MOVE.L  A0,-(SP)	;RESTORE RETURN ADDR
	MOVEQ	#0,D0		;SET GOOD RETURN CODE
	MOVE.L  xxxxx,A0	;ADDR OF RULE RESOURCE
	RTS			;RETURN

	ENDC
*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*                                                         ;
*                                                         ;
a486 23
          IFNE      MAC                 ;OVERFLOW, MAC VERSION
OVERFLOW  MOVE.L    A0,-(SP)            ;   SAVE A0
          MOVE.L    OUTHDOFF(A5),A0     ;   GET OUTPUT HANDLE
*	  _HUnlock			;   UNLOCK HANDLE
*          _GetHandleSize                ;   GET CURRENT HANDLE SIZE
          ADD.L     #1024,D0            ;   GROW BY 1K BYTES
          MOVE.L    D0,D2               ;   SET NEW OUTPUT SIZE LIMIT
*          _SetHandleSize                ;   DO THE GROWING
	  MOVE.L    D0,D1		;   SAVE THE RC
*	  _HLock			;   LOCK HANDLE
	  MOVE.L    A1,D0		;   COPY CURRENT POS OF OUTPUT
	  SUB.L	    STOUTOFF(A5),D0	;   COMPUTE LENGTH OF OUTPUT
	  ADD.L     (A0),D0		;   COMPUTE NEW POSITION
	  AND.L	    LO3BYTES,D0		;   USE 24 BIT ADDR
	  MOVE.L    D0,A1		;   CURRENT POS INTO A1
	  MOVE.L    (A0),D0	 	;   DEREFERENCE HANDLE
	  AND.L     LO#BYTES,D0		;   24 BIT ADDR
	  MOVE.L    D0,STOUTOFF(A5)	;   RESET BEGINNING OF OUTPUT
          MOVE.L    (SP)+,A0            ;   RESTORE A0
	  MOVE.L    D1,D0		;   CHECK RETURN CODE
	  BEQ.S     DOREPLACE	 	;   ABLE TO GROW, CONTINUE
	  RTS				;   CAN'T GROW, RETURN WITH ERROR 
          ENDC
a487 1
          IFNE      AMIGA               ;OVERFLOW, AMIGA VERSION
a511 1
          ENDC
a531 7
          IFNE      MAC                 ;COMPUTE ROUTINE ADDRESS, MAC
          MOVE.L    0(A3,D0),D0         ;GET SPECIFIC SYMBOL ROUTINE
          LEA       READER,A3
          ADD.L     D0,A3               ;ADD IN START OF PGM FOR OFFSET
          ENDC

          IFNE      AMIGA               ;COMPUTE ROUTINE ADDRESS, AMIGA
a532 1
          ENDC
d775 1
a775 1
	  IFNE	    AMIGA               ;IF AMIGA,
d778 1
a778 1
	  ENDC
a1040 1
	IFNE	AMIGA
a1041 1
	ENDC
a1043 5

          IFNE	    MAC
FILENAME  DC.W      15
          DC.W      'MacinTalk Rules'
	  ENDC
@
