head     39.7;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @* @;


39.7
date     93.10.01.10.24.48;  author vertex;  state Exp;
branches ;
next     39.6;

39.6
date     93.06.18.09.21.36;  author vertex;  state Exp;
branches ;
next     39.5;

39.5
date     93.06.18.09.18.32;  author vertex;  state Exp;
branches ;
next     39.4;

39.4
date     93.04.01.17.09.10;  author vertex;  state Exp;
branches ;
next     39.3;

39.3
date     93.02.09.14.18.52;  author vertex;  state Exp;
branches ;
next     39.2;

39.2
date     93.01.19.13.04.49;  author vertex;  state Exp;
branches ;
next     39.1;

39.1
date     93.01.19.13.00.28;  author vertex;  state Exp;
branches ;
next     38.15;

38.15
date     92.04.27.09.48.22;  author vertex;  state Exp;
branches ;
next     38.14;

38.14
date     92.04.27.09.29.07;  author vertex;  state Exp;
branches ;
next     38.13;

38.13
date     92.03.31.12.04.35;  author vertex;  state Exp;
branches ;
next     38.12;

38.12
date     92.03.23.09.18.56;  author vertex;  state Exp;
branches ;
next     38.11;

38.11
date     92.03.17.17.16.39;  author vertex;  state Exp;
branches ;
next     38.10;

38.10
date     92.03.16.11.54.32;  author vertex;  state Exp;
branches ;
next     38.9;

38.9
date     92.02.03.10.39.58;  author vertex;  state Exp;
branches ;
next     38.8;

38.8
date     91.11.07.14.05.01;  author vertex;  state Exp;
branches ;
next     38.7;

38.7
date     91.10.24.12.19.21;  author vertex;  state Exp;
branches ;
next     38.6;

38.6
date     91.10.02.13.07.33;  author vertex;  state Exp;
branches ;
next     38.5;

38.5
date     91.07.25.12.59.11;  author vertex;  state Exp;
branches ;
next     38.4;

38.4
date     91.07.18.15.41.17;  author vertex;  state Exp;
branches ;
next     38.3;

38.3
date     91.07.16.11.07.57;  author vertex;  state Exp;
branches ;
next     38.2;

38.2
date     91.07.02.17.02.20;  author vertex;  state Exp;
branches ;
next     38.1;

38.1
date     91.06.26.15.20.17;  author vertex;  state Exp;
branches ;
next     ;


desc
@Documentation for locale.library
@


39.7
log
@*** empty log message ***
@
text
@
******* locale.library/--structures-- ****************************************
*
*	The Locale structure is the main public structure provided by
*	locale.library. The structure is defined in <libraries/locale.h>
*	and consists of the following fields:
*
*	STRPTR loc_LocaleName
*	    Locale's name.
*
*	STRPTR loc_LanguageName
*	    The language of the driver bound to this locale.
*
*	STRPTR loc_PrefLanguages[10]
*	    The ordered list of preferred languages for this locale.
*
*	ULONG loc_Flags
*	    Locale flags. Currently always 0.
*
*	ULONG loc_CodeSet
*	    Specifies the code set required by this locale. Currently, this
*	    value is always 0.
*
*	ULONG loc_CountryCode
*	    The international country code.
*
*	ULONG loc_TelephoneCode
*	    The international telephone code for the country.
*
*	LONG loc_GMTOffset
*	    The offset in minutes of the current location from GMT.
*	    Positive indicates a Westerly direction from GMT,
*	    negative Easterly.
*
*	UBYTE loc_MeasuringSystem
*	    The measuring system being used.
*
*	STRPTR loc_DateTimeFormat
*	    The date and time format string, ready to pass to FormatDate()
*
*	STRPTR loc_DateFormat
*	    The date format string.
*
*	STRPTR loc_TimeFormat
*	    The time format string.
*
*	STRPTR loc_ShortDateTimeFormat
*	    The short date and time format string, ready to pass to
*	    FormatDate()
*
*	STRPTR loc_ShortDateFormat
*	    The short date format string.
*
*	STRPTR loc_ShortTimeFormat
*	    The short time format string.
*
*	STRPTR loc_DecimalPoint
*	    The decimal point character used to format non-monetary quantities.
*
*	STRPTR loc_GroupSeparator
*	    The characters used to separate groups of digits before the
*	    decimal-point character in formatted non-monetary quantities.
*
*	STRPTR loc_FracGroupSeparator
*	    The characters used to separate groups of digits after the
*	    decimal-point character in formatted non-monetary quantities.
*
*	STRPTR loc_Grouping
*	    A string whose elements indicate the size of each group of digits
*	    before the decimal-point character in formatted non-monetary
*	    quantities.
*
*	STRPTR loc_FracGrouping
*	    A string whose elements indicate the size of each group of digits
*	    after the decimal-point character in formatted non-monetary
*	    quantities.
*
*	STRPTR loc_MonDecimalPoint
*	    The decimal-point used to format monetary quantities.
*
*	STRPTR loc_MonGroupSeparator
*	    The separator for groups of digits before the decimal-point in
*	    monetary quantities.
*
*	STRPTR loc_MonFracGroupSeparator
*	    The separator for groups of digits after the decimal-point in
*	    monetary quantities.
*
*	STRPTR loc_MonGrouping
*	    A string whose elements indicate the size of each group of digits
*	    before the decimal-point character in monetary quantities.
*
*	STRPTR loc_MonFracGrouping
*	    A string whose elements indicate the size of each group of digits
*	    after the decimal-point character in monetary quantities.
*
*	UBYTE loc_MonFracDigits
*	    The number of fractional digits (those after the decimal-point)
*	    to be displayed in a formatted monetary quantity.
*
*	UBYTE loc_MonIntFracDigits
*	    The number of fractional digits (those after the decimal-point)
*	    to be displayed in an internationally formatted monetary quantity.
*
*	STRPTR loc_MonCS
*	    The local currency symbol applicable to the current locale.
*
*	STRPTR loc_MonSmallCS
*	    The currency symbol for small amounts.
*
*	STRPTR loc_MonIntCS
*	    The international currency symbol applicable to the current
*	    locale. The first three characters contain the alphabetic
*	    international currency symbol in accordance with those specified
*	    in ISO 4217 Codes for the Representation of Currency and Funds.
*	    The fourth character (immediately preceding the NULL) is the
*	    character used to separate the international currency symbol from
*	    the monetary quantity.
*
*	STRPTR loc_MonPositiveSign
*	    The string used to indicate a non-negative monetary quantity.
*
*	UBYTE loc_MonPositiveSpaceSep
*	    Specifies the number of spaces separating the currency symbol from
*	    the non-negative monetary quantity.
*
*	UBYTE loc_MonPositiveSignPos
*	    Set to a value indicating the positioning of loc_MonPositiveSign
*	    for a non-negative monetary quantity.
*
*	UBYTE loc_MonPositiveCSPos
*	    Set to 1 or 0 if loc_MonCS respectively precedes or succeeds
*	    the value for a non-negative monetary quantity.
*
*	STRPTR loc_MonNegativeSign
*	    The string used to indicate a negative monetary quantity.
*
*	UBYTE loc_MonNegativeSpaceSep
*	    Specifies the number of spaces separating the currency symbol from
*	    the negative monetary quantity.
*
*	UBYTE loc_MonNegativeSignPos
*	    Set to a value indicating the positioning of loc_MonNegativeSign
*	    for a negative monetary quantity.
*
*	UBYTE loc_MonNegativeCSPos
*	    Set to 1 or 0 if loc_MonCS respectively precedes or succeeds
*	    the value for a negative monetary quantity.
*
*
*	The grouping tables pointed to by loc_Grouping, loc_FracGrounping,
*	loc_MonGrouping, and loc_MonFracGrouping contain a stream of bytes
*	with the following values:
*
*	    255		No further grouping is to be performed.
*
*	    0		The previous element is to be repeatedly used for the
*			remainder of the digits.
*
*	    1..254	The integer value is the number of digits that comprise
*			the current group. The next element is examined to
*			determine the size of the next group of digits before
*			the current group.
*
*	The values of loc_MonPositiveSignPos and loc_MonNegativeSignPos are
*	interpreted according to the following:
*
*	    0		Parentheses surround the quantity and currency symbol
*
*	    1		The sign string precedes the quantity and
*			currency symbol
*
*	    2		The sign string succeeds the quantity and
*			currency symbol
*
*	    3		The sign string immediately precedes the
*			currency symbol
*
*	    4		The sign string immediately succeeds the
*			currency symbol.
*
******************************************************************************


******* locale.library/--rexxhost-- ******************************************
*
*   HOST INTERFACE
*	locale.library provides an ARexx function host interface that enables
*	ARexx programs to take advantage of system localization. The
*	functions provided by the interface are directly related to the
*	functions described herein, with the differences mostly being
*	in the way they are called.
*
*	The function host library vector is located at offset -30 from the
*	library. This is the value you provide to ARexx in the AddLib()
*	function call.
*
*   FUNCTIONS
*	CloseCatalog (CATALOG/N/A)
*	ConvToLower (CHARACTER/A)
*	ConvToUpper (CHARACTER/A)
*	GetCatalogStr (CATALOG/A,STRING/N/A,DEFAULT/A)
*	IsAlNum (CHARACTER/A)
*	IsAlpha (CHARACTER/A)
*	IsCntrl (CHARACTER/A)
*	IsDigit (CHARACTER/A)
*	IsGraph (CHARACTER/A)
*	IsLower (CHARACTER/A)
*	IsPrint (CHARACTER/A)
*	IsPunct (CHARACTER/A)
*	IsSpace (CHARACTER/A)
*	IsUpper (CHARACTER/A)
*	IsXDigit (CHARACTER/A)
*	OpenCatalog (NAME/A,BUILTINLANGUAGE/A,VERSION/N/A)
*	Strncmp (STRING1/A,STRING2/A,TYPE/N/A)
*
*   EXAMPLE
*	/* localetest.rexx */
*
*	/* Make sure locale is loaded as a function host */
*	IF ~SHOW(L,'locale.library') THEN DO
*	  CALL ADDLIB('locale.library',0,-30)
*	END;
*
*	say ConvToLower("A");
*	say ConvToUpper("b");
*	say IsAlpha("1");
*
*	catalog = OpenCatalog("sys/workbench.catalog","english",0);
*	say GetCatalogStr(catalog,34,"default");
*	say CloseCatalog(catalog);
*	say StrnCmp("test","test",2);
*
******************************************************************************


******* locale.library/--environment_vars-- **********************************
*
*	Starting with V40, locale.library maintains a global environment
*	variable called "Language" which contains the name of the current
*	default language as used in the system. This is the name of the
*	language associated with the Locale structure returned by
*	OpenLocale(NULL).
*
*   EXAMPLE
*	From a shell:
*
*		Echo "The system language currently is: $Language"
*
*	will print the name of the current system language ("english",
*	"français", etc)
*
******************************************************************************


******* locale.library/CloseCatalog ******************************************
*
*   NAME
*	CloseCatalog -- close a message catalog. (V38)
*
*   SYNOPSIS
*	CloseCatalog(catalog);
*	             A0
*
*	VOID CloseCatalog(struct Catalog *);
*
*   FUNCTION
*	Concludes access to a message catalog. The usage count of the
*	catalog is decremented. When this count reaches 0, the catalog
*	can be expunged from system memory whenever a memory panic occurs.
*
*   INPUTS
*	catalog - the message catalog to close. A NULL catalog is a valid
*		  parameter and is simply ignored.
*
*   SEE ALSO
*	OpenCatalog(), GetCatalogStr()
*
******************************************************************************


******* locale.library/CloseLocale *******************************************
*
*   NAME
*	CloseLocale -- close a locale. (V38)
*
*   SYNOPSIS
*	CloseLocale(locale);
*	            A0
*
*	VOID CloseLocale(struct Locale *);
*
*   FUNCTION
*	Concludes access to a locale.
*
*   INPUTS
*	locale - an opened locale. A NULL locale is a valid
*		 parameter and is simply ignored.
*
*   SEE ALSO
*	OpenLocale(), <libraries/locale.h>
*
******************************************************************************


******* locale.library/ConvToUpper *******************************************
*
*   NAME
*	ConvToUpper -- convert a character to upper case. (V38)
*
*   SYNOPSIS
*	char = ConvToUpper(locale,character);
*	D0	           A0     D0
*
*	ULONG ConvToUpper(struct Locale *,ULONG);
*
*   FUNCTION
*	This function tests if the character specified is lower case. If it is
*	then the upper case version of that character is returned, and if it
*	isn't then the original character is returned.
*
*   INPUTS
*	locale - the locale to use for the conversion
*	character - the character to convert
*
*   RESULT
*	char - a (possibly) converted character
*
*   NOTE
*	This function requires a full 32-bit character be passed-in in order
*	to support multi-byte character sets.
*
******************************************************************************


******* locale.library/ConvToLower *******************************************
*
*   NAME
*	ConvToLower -- convert a character to lower case. (V38)
*
*   SYNOPSIS
*	char = ConvToLower(locale,character);
*	D0	           A0     D0
*
*	ULONG ConvToLower(struct Locale *,ULONG);
*
*   FUNCTION
*	This function tests if the character specified is upper case. If it is
*	then the lower case version of that character is returned, and if it
*	isn't then the original character is returned.
*
*   INPUTS
*	locale - the locale to use for the conversion
*	character - the character to convert
*
*   RESULT
*	char - a (possibly) converted character
*
*   NOTE
*	This function requires a full 32-bit character be passed-in in order
*	to support multi-byte character sets.
*
******************************************************************************


******* locale.library/FormatDate ********************************************
*
*   NAME
*	FormatDate -- generate a date string based on a date formatting
*		      template. (V38)
*
*   SYNOPSIS
*	FormatDate(locale,fmtTemplate,date,putCharFunc);
*	           A0     A1          A2   A3
*
*	VOID FormatDate(struct Locale *,STRPTR,struct DateStamp *,
*	                struct Hook *);
*
*   FUNCTION
*	This function processes a formatting template and generates
*	a stream of bytes that's sent one character at a time to the
*	putCharFunc callback hook.
*
*   INPUTS
*	locale - the locale to use for the formatting
*	fmtTemplate - the NULL-terminated template describing the desired
*		      format for the date. This is constructed just like
*		      C-language printf() statements, except that different
*		      formatting codes are used. Just like in C, formatting
*		      codes start with a % followed by the formatting command.
*		      The following commands are accepted by this function:
*
*	                %a - abbreviated weekday name
*	                %A - weekday name
*	                %b - abbreviated month name
*	                %B - month name
*	                %c - same as "%a %b %d %H:%M:%S %Y"
*	                %C - same as "%a %b %e %T %Z %Y"
*	                %d - day number with leading 0s
*	                %D - same as "%m/%d/%y"
*	                %e - day number with leading spaces
*	                %h - abbreviated month name
*	                %H - hour using 24-hour style with leading 0s
*	                %I - hour using 12-hour style with leading 0s
*	                %j - julian date
*	                %m - month number with leading 0s
*	                %M - the number of minutes with leading 0s
*	                %n - insert a linefeed
*	                %p - AM or PM strings
*	                %q - hour using 24-hour style
*	                %Q - hour using 12-hour style
*	                %r - same as "%I:%M:%S %p"
*	                %R - same as "%H:%M"
*	                %S - number of seconds with leadings 0s
*	                %t - insert a tab character
*	                %T - same as "%H:%M:%S"
*	                %U - week number, taking Sunday as first day of week
*	                %w - weekday number
*	                %W - week number, taking Monday as first day of week
*	                %x - same as "%m/%d/%y"
*	                %X - same as "%H:%M:%S"
*	                %y - year using two digits with leading 0s
*	                %Y - year using four digits with leading 0s
*
*	              If the template parameter is NULL, a single NULL byte
*		      is sent to putCharFunc.
*	date - the date to format into a string
*	putCharFunc - a callback hook invoked for every character generated,
*		      including for the terminating NULL character. The hook
*		      is called with:
*
*		 	A0 - address of Hook structure
*			A1 - character for hook to process (not a pointer!)
*	                A2 - locale pointer
*
*   SEE ALSO
*	ParseDate(), <libraries/locale.h>, <dos/dos.h>
*
******************************************************************************


******* locale.library/FormatString ******************************************
*
*   NAME
*	FormatString -- format data into a character stream. (V38)
*
*   SYNOPSIS
*	next = FormatString(locale,fmtTemplate,dataStream,putCharFunc);
*	D0                  A0     A1          A2         A3
*
*	APTR FormatString(struct Locale *,STRPTR,APTR,struct Hook *);
*
*   FUNCTION
*	This function performs C-language-like formatting of a data stream,
*	outputting the result a character at a time. Where % formatting
*	commands are found in the formatting template, they are replaced with
*	the corresponding elements in 'dataStream'. %% must be used in the
*	string if a % is desired in the output.
*
*	An extension to the standard C-language printf() conventions used
*	by FormatString() is argument position specification. Specifying the
*	argument position lets the order of the % commands change while the
*	arguments provided remain the same. Using the C printf() call as an
*	example:
*	    printf("%d eyes, %d feet and %d ears",eyes,feet,ears);
*	    printf("%3$d ears, %1$d eyes and %2$d feet",eyes,feet,ears);
*	These two statements would produce the following output:
*	    "2 eyes, 3 feet and 4 ears" for the first
*	    "4 ears, 2 eyes and 3 feet" for the second
*
*	The argument positioning feature lets you change the format string
*	being processed while keeping the data stream the same. This is
*	an invaluable tool when translating strings to different languages.
*
*   INPUTS
*	locale - the locale to use for the formatting
*	fmtTemplate - a C-language-like NULL-terminated format string,
*		      with the following supported % options:
*
*	  %[arg_pos$][flags][width][.limit][length]type
*
*	  arg_pos - ordinal position of the argument for this command within
*		    the array of arguments pointed to by 'dataStream'
*	    $     - must follow the arg_pos value, if specified
*	  flags   - only one allowed. '-' specifies left justification.
*	  width   - field width. If the first character is a '0', the
*	            field is padded with leading 0s.
*	    .     - must precede the field limit value, if specified
*	  limit   - maximum number of characters to output from a string.
*	            (only valid for %s or %b).
*	  length  - size of input data defaults to word (16-bit) for types c,
*		    d, u and x, 'l' changes this to long (32-bit).
*	  type    - supported types are:
*	                  b - BSTR, data is 32-bit BPTR to byte count followed
*	                      by a byte string. A NULL BPTR is treated as an
*			      empty string.
*	                  d - signed decimal
*			  D - signed decimal using the locale's formatting
*			      conventions
*			  u - unsigned decimal
*			  U - unsigned decimal using the locale's formatting
*			      conventions
*	                  x - hexadecimal with hex digits in uppercase
*			  X - hexadecimal with hex digits in lowercase
*	                  s - string, a 32-bit pointer to a NULL-terminated
*	                      byte string. A NULL pointer is treated
*	                      as an empty string.
*	                  c - character
*
*	              If the formatting template parameter is NULL, the
*		      function returns without outputting anything. Note the
*		      meaning of %x and %X are swapped with respect to
*		      standard C conventions. This is for compatibility with
*		      exec.library/RawDoFmt().
*
*	dataStream - a stream of data that is interpreted according to
*		     the format string. Often this is a pointer into
*		     the task's stack.
*	putCharFunc - a callback hook invoked for every character generated,
*		      including for the terminating NULL character. The hook
*		      is called with:
*
*		 	A0 - address of Hook structure
*			A1 - character for hook to process (not a pointer!)
*	                A2 - locale pointer
*
*		     the function is called with a NULL char at the end of
*		     the format string.
*
*   RESULT
*	next - A pointer to beyond the last data element used in 'dataStream'
*	       (the next argument that would have been processed).
*	       This allows multiple formatting passes to be made using the
*	       same data.
*
*   WARNING
*	This function formats word values in the data stream. If your compiler
*	defaults to longs, you must add an "l" to your specifications. This
*	can get strange for characters, which might look like "%lc".
*
*   SEE ALSO
*	exec.library/RawDoFmt()
*
*****************************************************************************


******* locale.library/GetCatalogStr ***************************************
*
*   NAME
*	GetCatalogStr -- get a string from a message catalog. (V38)
*
*   SYNOPSIS
*	string = GetCatalogStr(catalog,stringNum,defaultString);
*	D0                     A0      D0        A1
*
*	STRPTR GetCatalogStr(struct Catalog *,LONG,STRPTR);
*
*   FUNCTION
*	This function returns a specific string within a message catalog.
*	If the catalog parameter is NULL, or the requested message does not
*	exist, then defaultString is returned.
*
*   INPUTS
*	catalog - a message catalog as obtained from OpenCatalog(), or NULL
*	stringNum - a message number within the catalog
*	defaultString - string to return in case "catalog" is NULL or
*	                "stringNum" can't be found
*
*   RESULT
*	string - a pointer to a NULL-terminated string. The returned string
*		 is READ-ONLY, do NOT modify! This string pointer is valid
*		 only as long as the catalog remains open.
*
*   SEE ALSO
*	OpenCatalog(), CloseCatalog()
*
******************************************************************************


******* locale.library/GetLocaleStr *******************************************
*
*   NAME
*	GetLocaleStr -- get a standard string from a locale. (V38)
*
*   SYNOPSIS
*	string = GetLocaleStr(locale,stringNum);
*	D0                    A0     D0
*
*	STRPTR GetLocaleStr(struct Locale *,ULONG);
*
*   FUNCTION
*	This function returns a specific string associated with the given
*	locale.
*
*   INPUTS
*	locale - a valid locale
*	stringNum - the number of the string to get a pointer to. See the
*		    constants defined in <libraries/locale.h> for the
*		    possible values.
*
*   RESULT
*	string - a pointer to a NULL-terminated string, or NULL if the
*		 requested string number was out of bounds. The returned
*		 string is READ-ONLY, do NOT modify! This string pointer
*		 is valid only as long as the locale remains open.
*
*   SEE ALSO
*	OpenLocale(), CloseLocale(), <libraries/locale.h>
*
******************************************************************************


******* locale.library/IsXXXX ************************************************
*
*   NAME
*	IsXXXX -- determine whether a character is of a certain type. (V38)
*
*   SYNOPSIS
*	state = IsXXXX(locale,character);
*	D0	       A0     D0
*
*	BOOL IsXXXX(struct Locale *,ULONG);
*
*   FUNCTION
*	These functions determine whether the character specified is of a
*	certain type, according to the supplied locale.
*
*	IsAlNum() - test if alphanumeric character
*	IsAlpha() - test if alphabetical character
*	IsCntrl() - test if control character
*	IsDigit() - test if decimal digit character
*	IsGraph() - test if visible character
*	IsLower() - test if lower case character
*	IsPrint() - test if blank
*	IsPunct() - test if punctuation character
*	IsSpace() - test if white space character
*	IsUpper() - test if upper case character
*	IsXDigit() - test if hexadecimal digit
*
*   INPUTS
*	locale - the locale to use for the test
*	character - the character to test
*
*   RESULT
*	state - TRUE if the character is of the required type, FALSE otherwise
*
*   NOTE
*	These functions require full 32-bit characters be passed-in in order
*	to support multi-byte character sets.
*
******************************************************************************


******* locale.library/OpenCatalog *****************************************
*
*   NAME
*	OpenCatalogA -- open a message catalog. (V38)
*	OpenCatalog -- varargs stub for OpenCatalogA(). (V38)
*
*   SYNOPSIS
*	catalog = OpenCatalogA(locale,name,tagList);
*	D0                     A0     A1   A2
*
*	struct Catalog *OpenCatalogA(struct Locale *,STRPTR,struct TagItem *);
*
*	catalog = OpenCatalog(locale,name,firstTag, ...);
*
*	struct Catalog *OpenCatalog(struct Locale *,STRPTR,Tag, ...);
*
*   FUNCTION
*	This function opens a message catalog. Catalogs contain all the
*	text strings that an application uses. These strings can easily
*	be replaced by strings in a different language, which causes the
*	application to magically start operating in that new language.
*
*	Catalogs originally come from disk files. This function searches for
*	them in the following places:
*
*		PROGDIR:Catalogs/languageName/name
*		LOCALE:Catalogs/languageName/name
*
*	where languageName is the name of the language associated with the
*	locale parameter. So assuming an application called WizPaint:
*
*		catalog = OpenCatalog(NULL,
*				      "WizPaint.catalog",
*				      OC_BuiltInLanguage,"english",
*				      TAG_DONE);
*
*	Passing NULL as first parameter to OpenCatalog() indicates you
*	wish to use the system's default locale. Assuming the default locale
*	specifies "deutsch" as language, OpenCatalog() tries to open the
*	catalog as:
*
*		PROGDIR:Catalogs/deutsch/WizPaint.catalog
*
*	and if that file is not found, then OpenCatalog() tries to open it
*	as:
*
*		LOCALE:Catalogs/deutsch/WizPaint.catalog
*
*	PROGDIR: is not always checked before LOCALE: is. If the volume which
*	PROGDIR: is assigned to is NOT currently mounted, and if the one
*	which LOCALE: is assigned to IS mounted, then LOCALE: is checked
*	first, followed by PROGDIR: if needed. This is done in order to
*	minimize the number of disk swaps on floppy systems.
*
*	The OC_BuiltInLanguage tag specifies the language of the strings
*	that are built into the application. If the language of the
*	built-in strings matches that of the locale, then no catalog
*	need be loaded from disk and the built-in strings can be used
*	directly.
*
*	locale.library caches text catalogs in order to minimize disk
*	access. As such, OpenCatalog() may or may not cause disk access.
*	This fact should be taken into consideration. Unused catalogs are
*	automatically flushed from the system when there is not enough
*	memory. When there is disk access, it is possible a DOS requester
*	may be opened asking for a volume to be inserted. You can avoid this
*	requester opening by setting your process' pr_WindowPtr field to -1.
*
*   INPUTS
*	locale - the locale for which the catalog should be opened, or NULL.
*		 When NULL, then the system's default locale is used. This
*		 should generally be NULL
*	name - the NULL-terminated name of the catalog to open, typically
*	       the application name with a ".catalog" extension
*	tagList - pointer to an array of tags providing optional extra
*		  parameters, or NULL
*
*   TAGS
*	OC_BuiltInLanguage (STRPTR) - language of built-in strings of the
*				      application. That is, this tag identifies
*				      the language used for the "defaultString"
*				      parameter used in the GetCatalogStr()
*				      function. Default is "english". Providing
*				      this tag and setting its value to NULL
*				      indicates that there are no built-in
*				      strings.
*
*	OC_BuiltInCodeSet (ULONG) - code set of built-in strings. Default is 0.
*				    THIS TAG SHOULD ALWAYS BE SET TO 0 FOR NOW.
*
*	OC_Language (STRPTR) - language explicitly requested for the catalog.
*			       A catalog of this language will be returned if
*			       possible, otherwise a catalog in one of the
*			       user's preferred languages. This tag should
*			       normally not be provided as it overrides the
*			       user's preferences.
*
*	OC_Version (UWORD) - catalog version number required. Default is 0
*			     which means to accept any version of the catalog
*			     that is found. Note that if a version is
*			     specified, the catalog's version much match it
*			     exactly. This is different from version numbers
*			     used by OpenLibrary().
*
*   RESULT
*	catalog - a message catalog to use with GetCatalogStr() or NULL.
*		  A NULL result does not necessarily indicate an error.
*		  If OpenCatalog() determines that the built-in strings of
*		  the application can be used instead of an external catalog
*		  from disk, then NULL is returned. To determine whether
*		  a NULL result actually indicates an error, look at the
*		  return value of dos.library/IoErr(). 0 means no error.
*
*		  GetCatalogStr() interprets a NULL catalog as meaning to use
*		  the built-in strings.
*
*   NOTE
*	In most cases, failing to open a catalog should not be considered a
*	fatal error, and the application should continue operating and
*	simply use the built-in set of strings instead of the disk-based
*	catalog. Note that GetCatalogStr() accepts a NULL catalog pointer for
*	this very reason.
*
*	Also note that displaying an error message when a catalog fails to
*	open can be a meaningless endeavor as the message is likely in a
*	language the user does not understand.
*
*   SEE ALSO
*	CloseCatalog(), GetCatalogStr()
*
******************************************************************************


******* locale.library/OpenLocale ********************************************
*
*   NAME
*	OpenLocale -- open a locale. (V38)
*
*   SYNOPSIS
*	locale = OpenLocale(name);
*	D0                  A0
*
*	struct Locale *OpenLocale(STRPTR);
*
*   FUNCTION
*	This function opens a named locale. Locales contain many parameters
*	that an application needs to consider when being integrated into
*	different languages, territories and customs. Using the information
*	stored in a locale instead of hard-coding it into an application,
*	lets the application dynamically adapt to the user's environment.
*
*	Locales originally come from disk files which are created by the
*	user using the Locale preferences editor. Passing a NULL instead of
*	a name causes this function to return the current default locale.
*	This is what most applications will do.
*
*	Every locale specifies a language, and special language drivers
*	must be loaded from disk depending on which language is being used.
*	These files include for example:
*
*		LOCALE:Languages/français.language
*		LOCALE:Languages/dansk.language
*		LOCALE:Languages/italiano.language
*
*   INPUTS
*	name - the NULL-terminated name of the locale to open, or NULL to open
*	       the current default locale. This should generally be NULL. The
*	       name you supply must be a pathname leading to a locale
*	       preferences file. This is an IFF PREF file as saved by
*	       Locale prefs, that can contain both LCLE and CTRY chunks.
*	       See <prefs/locale.h> for definitions.
*
*   RESULT
*	locale - a pointer to an initialized Locale structure, or NULL if the
*		 locale could not be loaded. In the case of a NULL return, the
*		 DOS IoErr() function can be called to obtain more information
*		 on the failure.
*
*		 When passing a NULL name parameter to this function, you are
*		 guaranteed a valid return.
*
*   SEE ALSO
*	CloseLocale(), <libraries/locale.h>, <prefs/locale.h>
*
******************************************************************************


******* locale.library/ParseDate *********************************************
*
*   NAME
*	ParseDate -- interpret a string according to the date formatting
*		     template and convert it into a DateStamp. (V38)
*
*   SYNOPSIS
*	state = ParseDate(locale,date,fmtTemplate,getCharFunc);
*	D0	          A0     A1   A2          A3
*
*	BOOL ParseDate(struct Locale *,struct DateStamp *,STRPTR,struct Hook *);
*
*   FUNCTION
*	This function converts a stream of characters into an AmigaDOS
*	DateStamp structure. The characters are obtained from the
*	getCharFunc callback hook and the formatting template is used
*	to direct the parse.
*
*   INPUTS
*	locale - the locale to use for the formatting
*	date - place to put the converted date, this may be NULL in which
*	       case this routine can be used to simply validate a date
*	fmtTemplate - the date template describing the expected format of the
*		      data. See FormatDate() documentation for a description of
*		      date templates. The following formatting controls from
*		      FormatDate() can be used in ParseDate():
*	                %a %A %b %B %d %e %h %H %I %m %M %p %S %y %Y
*	getCharFunc - a callback hook invoked whenever a character is required.
*		      The hook should return the next character to process,
*		      with a NULL character to indicate the end of the string.
*		      The hook is called with:
*
*		 	A0 - address of Hook structure
*	                A1 - locale pointer
*			A2 - NULL
*
*	              The hook returns the character to process in D0. Note
*		      that a complete 32-bit result is expected in D0, not
*		      just 8 bits.
*
*   RESULT
*	state - TRUE if the parsing went OK, or FALSE if the input did not
*		match the template
*
*   SEE ALSO
*	FormatDate(), <dos/dos.h>
*
******************************************************************************


*****i* locale.library/SetDefaultLocale **************************************
*
*   NAME
*	SetDefaultLocale -- specify the default locale for the system. (V38)
*
*   SYNOPSIS
*	old = SetDefaultLocale(locale);
*	D0                     A0
*
*	struct Locale *SetDefaultLocale(struct Locale *);
*
*   FUNCTION
*	Changes the system's idea of the default locale. The previous
*	default locale is returned.
*
*   INPUTS
*	locale - the locale to use as default
*
*   RESULT
*	old - the previous default locale
*
*   NOTE
*	The first call to this function causes locale.library to patch the
*	ROM to provide it with localization. Thus once a call to this routine
*	is made, the library can no longer be expunged from memory.
*
*   BUGS
*	Once a locale has been made a default locale, its memory is
*	never reclaimed and remains allocated until the next system
*	reboot. This is exacerbated when the new locale being set uses
*	a different language, as the DOS message catalog for the previous
*	language also remains in memory.
*
*   SEE ALSO
*	OpenLocale(), CloseLocale(), <libraries/locale.h>
*
******************************************************************************


******* locale.library/StrnCmp ***********************************************
*
*   NAME
*	StrnCmp -- localized string comparison. (V38)
*
*   SYNOPSIS
*	result = StrnCmp(locale,string1,string2,length,type);
*	D0               A0     A1      A2      D0     D1
*
*	LONG StrnCmp(struct Locale *,STRPTR,STRPTR,LONG,ULONG);
*
*   FUNCTION
*	Compares string1 to string2 according to the collation information
*	provided by the locale and returns an integer greater than,
*	equal to, or less than zero, accordingly as the string pointed to
*	by string1 is greater than, equal to, or less than the string
*	pointed to by string2.
*
*	The length parameter specifies how many characters to compare, or if
*	the length is specified as -1 then the strings are compared until
*	a NULL is encountered.
*
*	The type parameter dictates how the comparison is to be performed.
*
*   INPUTS
*	locale - the locale to use for this comparison
*	string1	- NULL-terminated string
*	string2	- NULL-terminated string
*	length - the maximum number of characters to be compared, or -1 to
*		 compare all characters until a NULL is encountered
*	type - describes how the comparison is to be performed. The following
*	       values can be passed:
*		 SC_ASCII causes an ASCII-based case-insensitive comparison
*		 to be performed. SC_ASCII is the fastest of the comparison
*		 types, but it uses ASCII ordering and considers accented
*		 characters different than their non-accented counterparts.
*
*		 SC_COLLATE1 causes the characters to be compared using their
*		 primary sorting order. This effectively produces a comparison
*		 that ignores letter case and diacritical marks. That is,
*		 letters such as "e" and "é" are treated as if they were both
*		 "e".
*
*		 SC_COLLATE2 causes the characters to be compared using both
*		 their primary and secondary sorting order. SC_COLLATE2 is
*		 slower than SC_COLLATE1. This is the type of comparison to
*		 use when sorting data to be presented to the user. It operates
*		 in two passes. First it performs a comparison equivalent to
*		 SC_COLLATE1. If both strings compare the same, then a second
*		 pass is made using the secondary sorting order, which gives
*		 finer resolution to the comparison. For example, SC_COLLATE1
*		 would return the following strings as identical:
*		    "père"  and  "pere"
*		 since SC_COLLATE1 ignores diacritical marks. SC_COLLATE2
*		 would make a second pass over the string comparing
*		 diacritical marks instead of actual characters.
*
*   RESULT
*	result - relationship between string1 and string2
*			<0 means string1 < string2
*			=0 means string1 = string2
*			>0 means string1 > string2
*
*   SEE ALSO
*	OpenLocale(), CloseLocale(), StrConvert()
*
******************************************************************************


******* locale.library/StrConvert ********************************************
*
*   NAME
*	StrConvert -- transform a string according to collation information.
*		      (V38)
*
*   SYNOPSIS
*	length = StrConvert(locale,string,buffer,bufferSize,type);
*	D0                  A0     A1     A2     D0         D1
*
*	ULONG StrConvert(struct Locale *,STRPTR,APTR,ULONG,ULONG);
*
*   FUNCTION
*	This function transforms the passed string and places the resulting
*	into the supplied buffer. No more than bufferSize bytes are copied
*	into the buffer.
*
*	The transformation is such that if the C strcmp() function is applied
*	to two transformed strings, it returns a value corresponding to
*	the result returned by the StrnCmp() function applied to the two
*	original strings.
*
*   INPUTS
*	locale - the locale to use for the transformation
*	string - NULL-terminated string to transform
*	buffer - buffer where to put the transformed string
*	bufferSize - maximum number of bytes to deposit in the buffer
*	             StrConvert() may require more storage than
*		     the unconverted string does
*	type - describes how the transformation is to be performed. See
*	       the documentation on StrnCmp() for more information on the
*	       comparison types available
*
*   RESULT
*	length - length of the transformed string which is the number of bytes
*		 deposited in the buffer minus 1 (since strings are NULL-
*		 terminated)
*
*   SEE ALSO
*	StrnCmp(), <libraries/locale.h>
*
******************************************************************************

@


39.6
log
@*** empty log message ***
@
text
@d820 5
a824 1
*	       the current default locale. This should generally be NULL.
d836 1
a836 1
*	CloseLocale(), <libraries/locale.h>
@


39.5
log
@*** empty log message ***
@
text
@d469 1
a469 1
*           "4 ears, 2 eyes and 3 feet" for the second
@


39.4
log
@Minor tweak
@
text
@d373 2
a374 2
*	FormatDate(locale,string,date,putCharFunc);
*	           A0     A1     A2   A3
d386 38
a423 38
*	string - the NULL-terminated template describing the desired format
*		 for the date. This is constructed just like C-language
*		 printf() statements, except that different formatting codes
*	         are used. Just like in C, formatting codes start with a
*	         % followed by the formatting command. The following
*		 commands are accepted by this function:
*
*	             %a - abbreviated weekday name
*	             %A - weekday name
*	             %b - abbreviated month name
*	             %B - month name
*	             %c - same as "%a %b %d %H:%M:%S %Y"
*	             %C - same as "%a %b %e %T %Z %Y"
*	             %d - day number with leading 0s
*	             %D - same as "%m/%d/%y"
*	             %e - day number with leading spaces
*	             %h - abbreviated month name
*	             %H - hour using 24-hour style with leading 0s
*	             %I - hour using 12-hour style with leading 0s
*	             %j - julian date
*	             %m - month number with leading 0s
*	             %M - the number of minutes with leading 0s
*	             %n - insert a linefeed
*	             %p - AM or PM strings
*	             %q - hour using 24-hour style
*	             %Q - hour using 12-hour style
*	             %r - same as "%I:%M:%S %p"
*	             %R - same as "%H:%M"
*	             %S - number of seconds with leadings 0s
*	             %t - insert a tab character
*	             %T - same as "%H:%M:%S"
*	             %U - week number, taking Sunday as first day of week
*	             %w - weekday number
*	             %W - week number, taking Monday as first day of week
*	             %x - same as "%m/%d/%y"
*	             %X - same as "%H:%M:%S"
*	             %y - year using two digits with leading 0s
*	             %Y - year using four digits with leading 0s
d425 2
a426 2
*	         If the template parameter is NULL, a single NULL byte
*		 is sent to putCharFunc.
d448 2
a449 2
*	next = FormatString(locale,string,dataStream,putCharFunc);
*	D0                  A0     A1     A2         A3
d456 2
a457 2
*	commands are found in the string, they are replaced with the
*	corresponding elements in 'dataStream'. %% must be used in the
d469 1
a469 1
*            "4 ears, 2 eyes and 3 feet" for the second
d477 2
a478 2
*	string - a C-language-like NULL-terminated format string,
*		 with the following supported % options:
d510 5
a514 4
*	         If the string parameter is NULL, the function returns without
*		 outputting anything. Note the meaning of %x and %X are
*		 swapped with respect to standard C conventions. This is for
*		 compatibility with exec.library/RawDoFmt().
d844 2
a845 2
*	state = ParseDate(locale,date,template,getCharFunc);
*	D0	          A0     A1   A2       A3
d859 5
a863 5
*	template - the date template describing the expected format of the
*		   data. See FormatDate() documentation for a description of
*		   date templates. The following formatting controls from
*		   FormatDate() can be used in ParseDate():
*	             %a %A %b %B %d %e %h %H %I %m %M %p %S %y %Y
@


39.3
log
@Bumped to V40
Bumped to V40
@
text
@d32 2
@


39.2
log
@*** empty log message ***
@
text
@d237 1
a237 1
*	Starting with V39, locale.library maintains a global environment
@


39.1
log
@Added mention of the Language environment var
@
text
@d235 1
a235 1
******* locale.library/--environment variables-- *****************************
@


38.15
log
@*** empty log message ***
@
text
@d234 16
@


38.14
log
@Added documentation for %Q and %q for FormatDate()
@
text
@d389 2
a390 2
*	             %q - hour using 24-hour style with leading 0s
*	             %Q - hour using 12-hour style with leading 0s
@


38.13
log
@Minor addition to the OpenCatalog() entry for the RexxHost
@
text
@d382 2
a383 2
*	             %H - hour using 24-hour style
*	             %I - hour using 12-hour style
d389 2
@


38.12
log
@Minor details...
@
text
@d212 1
a212 1
*	OpenCatalog (NAME/A,BUILTIN/A,VERSION/N/A)
@


38.11
log
@Fixed sample Rexx script
@
text
@d781 4
a784 2
*	Locales originally come from disk files. This function searches for
*	them as:
a785 3
*		name
*		SYS:Prefs/Presets/name
*
d790 1
a790 1
*		LOCALE:Languages/francais.language
d836 4
a839 2
*		   data. See FormatDate() above for a description of date
*		   templates.
d887 1
a887 1
*	the library cannot be expunged from memory.
@


38.10
log
@Minor correction in FormatString() entry
@
text
@d227 1
a227 1
*	catalog = OpenCatalog("workbench.catalog","english",0);
@


38.9
log
@Fixed prototype for FormatString() entry
@
text
@d465 1
a465 1
*	    .     - must precede the field width value, if specified
d712 4
a715 1
*				      function. Default is "english".
@


38.8
log
@Changed all RESULTS to RESULT
@
text
@d428 1
a428 1
*	APTR FormatString(struct LocaleBase *,STRPTR,APTR,struct Hook *);
@


38.7
log
@Formatting correction
@
text
@d305 1
a305 1
*   RESULTS
d335 1
a335 1
*   RESULTS
d506 1
a506 1
*   RESULTS
d545 1
a545 1
*   RESULTS
d577 1
a577 1
*   RESULTS
d620 1
a620 1
*   RESULTS
d731 1
a731 1
*   RESULTS
d796 1
a796 1
*   RESULTS
d849 1
a849 1
*   RESULTS
d877 1
a877 1
*   RESULTS
d955 1
a955 1
*   RESULTS
d1000 1
a1000 1
*   RESULTS
@


38.6
log
@Fixed some syntax errors
Changed entry for OpenCatalog() to describe new PROGDIR:/LOCALE: strategy
@
text
@d480 2
a481 1
*	                  x - hexadecimal
d488 4
a491 1
*		 outputting anything.
d678 1
a678 1
*       PROGDIR: is not always checked before LOCALE: is. If the volume which
@


38.5
log
@Corrected typos
@
text
@d18 1
a18 2
*	    Locale flags. The single current flag specifies whether daylight
*	    savings time should be used in the system.
d77 1
a77 1
*	    The decimal point used to format monetary quantities.
d80 1
a80 1
*	    The separator for groups of digits before the decimal point in
d84 1
a84 1
*	    The separator for groups of digits after the decimal point in
d119 1
a119 2
*	    The string used to indicate a nonnegative-valued formatted monetary
*	    quantity.
d134 1
a134 2
*	    The string used to indicate a negative-valued monetary
*	    quantity.
d138 1
a138 1
*	    the non-negative monetary quantity.
d142 1
a142 1
*	    for a negative formatted monetary quantity.
d146 1
a146 1
*	    the value for a negative formatted monetary quantity.
d538 2
a539 1
*	defaultString - string to return in case "stringNum" can't be found
d674 6
d780 1
a780 1
*	Every locale specifies a language, and special language files
d823 1
a823 1
*	as a grammar for the parser.
@


38.4
log
@Corrected FormatString() entry
Added new fields to --structures-- entry
@
text
@d125 1
a125 1
*	    the numeric value
d132 1
a132 1
*	    Set to 1 or 0 if loc_MonCS respectively preceeds or succeeds
d141 1
a141 1
*	    the numeric value
d148 1
a148 1
*	    Set to 1 or 0 if loc_MonCS respectively preceeds or succeeds
d161 1
a161 1
*	    other	The integer value is the number of digits that comprise
d171 1
a171 1
*	    1		The sign string preceeds the quantity and
d177 1
a177 1
*	    3		The sign string immediately preceeds the
d368 1
a368 1
*	string - the null-terminated template describing the desired format
d457 1
a457 1
*	string - a C-language-like null-terminated format string,
d467 2
a468 2
*	            field is padded with leading 0's.
*	    .     - must preceed the field width value, if specified
d484 1
a484 1
*	                  s - string, a 32-bit pointer to a null-terminated
d544 1
a544 1
*	string - a pointer to a null-terminated string. The returned string
d576 1
a576 1
*	string - a pointer to a null-terminated string, or NULL if the
d692 1
a692 1
*		 When NULL, then the system's default locale is used. ThisPassing
d694 2
a695 2
*	name - the null-terminated name of the catalog to open, typically
*	       the application name with a ".catalog" extemsion
d711 2
a712 2
*			       possible, or one a catalog in one of the user's
*			       preferred languages otherwise. This tag should
a731 3
*		  Passing a NULL locale parameter always makes this routine
*		  return NULL.
*
d785 1
a785 1
*	name - the null-terminated name of the locale to open, or NULL to open
d916 2
a917 2
*	string1	- null-terminated string
*	string2	- null-terminated string
d983 1
a983 1
*	string - null-terminated string to transform
d986 1
a986 1
*	             StrConvert() may require more storage than what
d988 2
a989 2
*	type - describes how the tranformation is to be performed. See
*	       the documentation for StrnCmp() for more information on the
d994 1
a994 1
*		 deposited in the buffer minus 1 (since strings are null-
@


38.3
log
@Remove background entry
Added docs for OC_Language tag
@
text
@d46 10
d59 6
a64 2
*	STRPTR loc_ThousandSeparator
*	    The character used to separate groups of digits before the
d67 1
a67 1
*	STRPTR loc_GroupingTable
d69 2
a70 1
*	    in formatted non-monetary quantities.
d72 4
a75 3
*	STRPTR loc_RadixChar
*	    The character to separate groups of numbers after the decimal
*	    point.
d80 1
a80 1
*	STRPTR loc_MonThousandSeparator
d84 9
a92 1
*	STRPTR loc_MonGroupingTable
d94 9
a102 1
*	    in monetary quantities.
d124 1
a124 1
*	    Specifies the number of spaces separating the sign from
d140 1
a140 1
*	    Specifies the number of spaces separating the sign from
a150 8
*	UBYTE loc_MonFracDigits
*	    The number of fractional digits (those after the decimal-point)
*	    to be displayed in a formatted monetary quantity.
*
*	UBYTE loc_MonIntFracDigits
*	    The number of fractional digits (those after the decimal-point)
*	    to be displayed in an internationally formatted monetary quantity.
*
d152 3
a154 3
*	The grouping tables pointed to by loc_GroupingTable and
*	loc_MonGroupingTable contain a stream of bytes with the following
*	values:
d447 3
a449 2
*	These two statements would produce the same output since the
*	second statement specifies the correct argument numbers.
d653 2
a654 2
*		PROGDIR:languageName/name
*		LOCALE:languageName/name
d669 1
a669 1
*		PROGDIR:deutsch/WizPaint.catalog
d674 1
a674 1
*		LOCALE:deutsch/WizPaint.catalog
@


38.2
log
@Documented ARexx function host
@
text
@a1 236
******* locale.library/--background-- ****************************************
*
*	Overview
*	--------
*	Localization is the process by which software dynamically adapts
*	to different locales. A locale is made up of a set of attributes
*	describing a language, a set of cultural and lingual
*	conventions, a physical location, etc...
*
*	Without standardized system support to help deal with localization
*	issues, the task of localizing applications is significant.
*	There needs to be several different versions of every
*	application, each specially adapted to run in particular
*	languages or countries.
*
*	Given the importance of the international market to the Amiga,
*	it is imperative that the operating system provide services to
*	facilitate, and thus encourage, application software
*	localization. This is where locale.library comes in.
*
*	locale.library is an Amiga shared library offering services to
*	let applications transparently adapt to any locale the user has
*	chosen. Functions are provided for formatted information
*	display, text catalogs, character attribute acquisition, and
*	more.
*
*
*	What And Where
*	--------------
*	System localization is accomplished via:
*
*	  - a standard Amiga library called locale.library stored in
*	    LIBS:
*
*	  - a locale preferences file stored in ENV:sys/locale.prefs
*
*	  - a set of files describing country-specific data stored in
*	    LOCALE:Countries/
*
*	  - a set of language drivers stored in LOCALE:Languages/
*
*	  - a Locale prefs editor stored in SYS:Prefs
*
*	  - application-specific text catalogs stored in PROGDIR: or in
*	    LOCALE:
*
*	The library implements the actual localization facilities.
*	Around two dozen functions are available to access and
*	manipulate locales and catalogs.
*
*	Language drivers implement much of the functionality found in
*	locale.library. Each locale is bound automatically to a single
*	language driver. The driver offers services needed by the
*	higher-level functions in the library.
*
*	Finally, text catalogs are lists of words and sentences used
*	by applications. By adding new catalogs, developers and
*	users are able to easily adapt applications to different
*	languages.
*
*
*	How Do The Pieces Fit
*	---------------------
*	The two most basic routines in the library are OpenLocale() and
*	CloseLocale(). OpenLocale() returns a pointer to a Locale structure,
*	which can then be used with most of the other functions in the library.
*	A Locale structure describes all the attributes necessary to localize
*	an application.
*
*	During the OpenLocale() call, a language driver is automatically
*	bound to a locale. The language driver bound to the locale
*	depends on the list of preferred languages specified by the user.
*	There is one driver per supported language. Drivers are easy to
*	write and new ones can be added by C= or third parties to
*	support new languages as demand arises.
*
*	The language drivers offer specific services needed by the
*	library to implement its functionality. This currently strictly
*	involves text manipulation functions specifically adapted to the
*	language at hand. For example, sorting text behaves differently
*	from language to language and needs to be taken care of by
*	specialized code.
*
*	Message catalogs are a simple means for an application to
*	separate the strings of a program from the actual executable. By
*	adding new message catalogs, the application can be made to
*	support new languages and to display all of its output in the
*	desired language.
*
*	Message catalogs are loaded in memory via the OpenCatalog()
*	function. Two of the parameters required by this function are a
*	locale and a catalog name. The locale is provided since it contains
*	the list of the user's preferred languages. Based on these languages,
*	OpenCatalog() attempts to find the best catalog possible from the
*	series of catalogs provided by the application.
*
*	Once a message catalog is in memory, any string it contains can
*	be retrieved from it using the GetCatalogStr() routine. The
*	routine expects a number specifying which string of the catalog
*	is to be returned. Sparse numbering of the strings is supported
*	providing the most convenience possible to the application
*	writer.
*
*
*	Disk Structure
*	--------------
*	locale.library reads 3 kinds of files from disk:
*
*	  - IFF-format locale files
*	  - IFF-format message catalogs
*	  - .library-format language drivers
*
*	The information describing a locale is stored in a normal IFF PREF
*	file in the LCLE chunk. A standard prefs editor is provided to let
*	the user adjust all the parameters of the locale and create new locale
*	prefs files on disk. The default prefs file is read in by IPrefs.
*
*	Since locale files are prefs files, they are stored in the
*	standard place for prefs files. Namely, the default prefs
*	file is:
*
*	    ENV:sys/locale.prefs
*
*	and when OpenLocale() is called, locale files are searched for as:
*
*	    SYS:Prefs/Presets/localeName.prefs
*
*	Each locale has a single language driver bound to it. When a locale
*	is loaded in memory, a language driver is also loaded and
*	automatically bound to the locale. The language drivers are
*	located in LOCALE:Languages. For example:
*
*	    LOCALE:Languages/dansk.language
*	    LOCALE:Languages/francais.language
*	    LOCALE:Languages/italiano.language
*
*	A language driver is an Amiga shared library providing around a
*	dozen functions for string and character-oriented operations that
*	need to be adapted depending on the language being used. The way
*	each function is implemented is hidden to locale.library, allowing
*	maximum flexibility for the driver when dealing with complex
*	languages.
*
*	The final type of disk file is the message catalog. Message
*	catalogs use an IFF format compatible with what AppBuilder
*	outputs, which is basically a simple text table. Compression may
*	eventually be applied to the text tables, although this is likely
*	overkill considering the average size of these catalogs. The MakeCat
*	utility can be used to generate these catalog files.
*
*	Each locale has a list of preferred languages bound to it. When a
*	message catalog is accessed via the OpenCatalog() function,
*	locale.library attempts to find a catalog in one of the locale's
*	preferred languages. OpenCatalog() looks in two different places for
*	message catalogs:
*
*	    PROGDIR:languageName/catalogName.catalog
*	    LOCALE:languageName/catalogName.catalog
*
*	languageName is one of the locale's preferred languages.
*	catalogName is the name of the catalog the application
*	wishes to open. Typically, catalogName is the name of the
*	application.
*
*	Looking in the LOCALE: directory for catalogs lets the user put
*	message catalogs for small applications (system tools for
*	example) into a single directory, or even simpler on a single
*	disk called LOCALE. In addition, using LOCALE: gives
*	applications loaded as resident the ability to load in catalogs.
*	Since resident applications do not get the benefit of PROGDIR:,
*	LOCALE: becomes the automatic fall-back.
*
*	Of course, language drivers and catalogs are transparently cached by
*	locale.library and get flushed whenever a memory panic occurs and when
*	their respective use count is 0.
*
*
*	String Processing
*	-----------------
*	A locale specifies special date and time formatting strings. These
*	strings describe exactly how the date and time are to be displayed
*	and interpreted. The FormatDate() routine is provided to convert
*	an AmigaDOS DateStamp structure into a localized date string, while
*	the ParseDate() routine converts from a string to a DateStamp
*	structure.
*
*	The grammar of most languages requires that subjects, objects, adverbs
*	and complements be written out in a specific order. This order varies
*	from language to language. For example:
*	  "Put volume Workbench in drive DF0:"
*	might be said as:
*	  "Put in drive DF0: volume Workbench"
*	in a language other than English.
*
*	To address the ordering problem, a patch to exec.library/RawDoFmt()
*	is applied by the SetPatch program to add support for parameter
*	ordering independence.
*
*
*	Patching Kickstart
*	------------------
*	When IPrefs is run, it instructs locale.library to patch several ROM
*	routines to transparently provide them with localized behavior. Because
*	of this patching, once IPrefs has been run, locale.library is
*	impossible to expunge from memory.
*
*
*	Compatibility
*	-------------
*	In a world where inter-platform compatibility is increasingly
*	important, it is a significant advantage to adhere as closely as
*	possible to adopted standards. This makes developing and porting
*	applications on the Amiga much easier, thus encouraging it.
*
*	locale.library offers the necessary services in order to
*	implement a fully compatible X/Open - ANSI/C implementation of
*	localization support. Simple wrapper functions need to be
*	provided by compiler writers to fully implement the standard,
*	but the nuts and bolts of the functionality is in the library.
*
*
*	Thinking Ahead
*	--------------
*	locale.library provides for easy and virtually unlimited
*	expansion. All character manipulation routines are defined as
*	accepting 32-bit characters, allowing future support for
*	multi-byte character sets.
*
*	Since all language-specific text manipulation is implemented
*	within the language drivers, the library does not impose any
*	artificial limitation on the simplicity or complexity of the
*	algorithms used within the drivers.
*
******************************************************************************


d197 1
a197 4
*	OPTIONS RESULTS
*	PARSE ARG word file line
*
*	/* Make sure hyper is loaded as a function host */
d683 7
@


38.1
log
@Initial V38 RCS checkin
@
text
@d20 1
a20 1
*	localization. This is where locaie.library comes in.
d394 55
@
