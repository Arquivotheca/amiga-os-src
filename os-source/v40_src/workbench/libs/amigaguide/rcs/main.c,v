head     39.12;
branch   ;
access   ;
symbols  ;
locks    davidj:39.12; strict;
comment  @ * @;


39.12
date     93.06.17.14.03.03;  author davidj;  state Exp;
branches ;
next     39.11;

39.11
date     93.05.07.09.56.49;  author davidj;  state Exp;
branches ;
next     39.10;

39.10
date     93.03.23.16.06.37;  author davidj;  state Exp;
branches ;
next     39.9;

39.9
date     93.03.22.16.48.08;  author davidj;  state Exp;
branches ;
next     39.8;

39.8
date     92.08.31.17.04.45;  author davidj;  state Exp;
branches ;
next     39.7;

39.7
date     92.08.13.13.13.19;  author davidj;  state Exp;
branches ;
next     39.6;

39.6
date     92.08.03.16.57.57;  author davidj;  state Exp;
branches ;
next     39.5;

39.5
date     92.07.23.17.17.17;  author davidj;  state Exp;
branches ;
next     39.4;

39.4
date     92.06.26.02.50.26;  author davidj;  state Exp;
branches ;
next     39.3;

39.3
date     92.06.23.03.13.33;  author davidj;  state Exp;
branches ;
next     39.2;

39.2
date     92.06.19.03.43.00;  author davidj;  state Exp;
branches ;
next     39.1;

39.1
date     92.06.05.04.01.26;  author davidj;  state Exp;
branches ;
next     39.0;

39.0
date     92.06.01.12.17.10;  author davidj;  state Exp;
branches ;
next     ;


desc
@initial RCS
@


39.12
log
@clean up
@
text
@/* main.c
 *
 */

#include <graphics/gfxbase.h>
#include <datatypes/datatypesclass.h>
#include "amigaguidebase.h"

/*****************************************************************************/

#include "amigaguide_rev.h"

/*****************************************************************************/

extern STRPTR ARexxPortName (struct AmigaGuideLib * ag, AREXXCONTEXT ac);

/*****************************************************************************/

static void GetScreenName (struct AmigaGuideLib *ag, struct Screen *scr, STRPTR buffer)
{
    struct PubScreenNode *psn;
    BOOL got = FALSE;
    struct List *lh;
    struct Node *ln;

    /* Clear out any old name */
    memset (buffer, 0, MAXPUBSCREENNAME);
    strncpy (buffer, scr->DefaultTitle, MAXPUBSCREENNAME);

    /* Search through the public list */
    if (lh = LockPubScreenList ())
    {
	for (ln = (struct Node *) lh->lh_Head; ln->ln_Succ && (got == FALSE); ln = ln->ln_Succ)
	{
	    psn = (struct PubScreenNode *) ln;
	    if (psn->psn_Screen == scr)
	    {
		strcpy (buffer, ln->ln_Name);
		got = TRUE;
	    }
	}

	UnlockPubScreenList ();
    }
}

/*****************************************************************************/

void MainLoop (struct AmigaGuideLib *ag, struct Client * cl)
{
    struct NewAmigaGuide *nag = cl->cl_NAG;
    struct Screen *scr = NULL;
    BOOL error = FALSE;
    BPTR old;

    /* Clear the error return value */
    SetIoErr (0);

    if (nag->nag_ClientPort && ag->ag_RexxSysBase)
    {
	if (!(cl->cl_RexxHandle = InitARexx (ag, nag->nag_ClientPort, "guide", (LONG) (cl->cl_Flags & AGF_UNIQUE))))
	{
	    cl->cl_ErrorLevel = RETURN_FAIL;
	    cl->cl_ErrorNumber = ERR_CANT_CREATE_PORT;
	    error = TRUE;
	}
    }

    if ((error == FALSE) && CreateMsgPorts (ag, cl))
    {
	cl->cl_Going = TRUE;
	cl->cl_Trigger.MethodID = DTM_TRIGGER;

	if (!(cl->cl_Screen = nag->nag_Screen))
	    scr = cl->cl_Screen = LockPubScreen (nag->nag_PubScreen);

	/* We have to have a screen to open on! */
	if (cl->cl_Screen)
	{
	    GetScreenName (ag, cl->cl_Screen, cl->cl_ScreenNameBuffer);

	    /* Get the default font */
#undef	GfxBase
	    cl->cl_TFont = ((struct GfxBase *) ag->ag_GfxBase)->DefaultFont;
#define	GfxBase	ag->ag_GfxBase
	    cl->cl_TAttr.ta_Name  = cl->cl_TFont->tf_Message.mn_Node.ln_Name;
	    cl->cl_TAttr.ta_YSize = cl->cl_TFont->tf_YSize;
	    cl->cl_TAttr.ta_Style = cl->cl_TFont->tf_Style;
	    cl->cl_TAttr.ta_Flags = cl->cl_TFont->tf_Flags;

	    /* Get the GadTools visual information */
	    if (cl->cl_VI = GetVisualInfoA (cl->cl_Screen, NULL))
	    {
		/* Get the Intuition screen draw information */
		if (cl->cl_DrInfo = GetScreenDrawInfo (cl->cl_Screen))
		{
		    /* See if we have a lock on a directory */
		    if (nag->nag_Lock)
			old = CurrentDir (DupLock(nag->nag_Lock));
		    else
			old = SetCurrentDirELVO (ag, NULL, nag->nag_Name);

		    if (IoErr () == 0)
		    {
			if (cl->cl_DataObject = NewDTObject (nag->nag_Name,
							     DTA_ARexxPortName,	(ULONG) ARexxPortName (ag, cl->cl_RexxHandle),
							     DTA_TextAttr,	(ULONG) & cl->cl_TAttr,
							     DTA_NodeName,	(ULONG) nag->nag_Node,
							     DTA_TopVert,	nag->nag_Line,
							     GA_Immediate,	TRUE,
							     GA_RelVerify,	TRUE,
							     AGA_HelpGroup,	cl->cl_HelpGroup,
							     AGA_HomeDir,	old,
							     TAG_DONE))
			{
			    if (cl->cl_Process || OpenAGWindow (ag, cl))
			    {
				struct AmigaGuideMsg *agm;

				cl->cl_ErrorLevel = cl->cl_ErrorNumber = 0L;

				/* Allocate a message to send */
				if (cl->cl_AsyncPort)
				{
				    if (agm = AllocPVec (ag, ag->ag_MemoryPool, AGMSIZE))
				    {
					/* Initialize the message */
					agm->agm_Type = ActiveToolID;
					agm->agm_Msg.mn_Node.ln_Type = NT_MESSAGE;
					agm->agm_Msg.mn_ReplyPort = cl->cl_ChildPort;
					agm->agm_Msg.mn_Length = AGMSIZE;

					/* Send the message */
					PutMsg (cl->cl_AsyncPort, (struct Message *) agm);
				    }
				    else
				    {
					cl->cl_ErrorLevel = RETURN_FAIL;
					cl->cl_ErrorNumber = AGERR_NOT_ENOUGH_MEMORY;
				    }
				}

				if (cl->cl_ErrorLevel == 0)
				{
				    HandleEvents (ag, cl);

				    PrintComplete (ag, cl);

				    CloseAGWindow (ag, cl);

				    /* Clear the IO error field */
				    cl->cl_ErrorLevel = RETURN_OK;
				    cl->cl_ErrorNumber = 0;
				    SetIoErr (0);
				}
			    }
			    else
			    {
				cl->cl_ErrorLevel = RETURN_FAIL;
				cl->cl_ErrorNumber = ERR_CANT_OPEN_WINDOW;
			    }

			    /* Free the data object */
			    DisposeDTObject (cl->cl_DataObject);
			}
			else
			{
			    cl->cl_ErrorLevel  = RETURN_FAIL;
			    cl->cl_ErrorNumber = ERR_CANT_OPEN_DATABASE;	/* IoErr(); */
			}

			/* Unwind */
			UnLock (CurrentDir (old));
		    }
		    else
		    {
			cl->cl_ErrorLevel  = RETURN_FAIL;
			cl->cl_ErrorNumber = ERR_CANT_OPEN_DATABASE;
		    }

		    /* Free the screen draw information */
		    FreeScreenDrawInfo (cl->cl_Screen, cl->cl_DrInfo);
		}
		else
		{
		    cl->cl_ErrorLevel = RETURN_FAIL;
		    cl->cl_ErrorNumber = ERR_CANT_OPEN_WINDOW;
		}

		/* Free the visual information */
		FreeVisualInfo (cl->cl_VI);
	    }
	    else
	    {
		cl->cl_ErrorLevel = RETURN_FAIL;
		cl->cl_ErrorNumber = ERR_CANT_OPEN_WINDOW;
	    }

	    /* Unlock any screen that we may have locked */
	    if (scr)
		UnlockPubScreen (NULL, scr);
	}
	else
	{
	    cl->cl_ErrorLevel = RETURN_FAIL;
	    cl->cl_ErrorNumber = ERR_CANT_OPEN_WINDOW;
	}

	if (cl->cl_AsyncPort && cl->cl_ErrorLevel)
	{
	    struct AmigaGuideMsg *agm;
	    BOOL die = FALSE;

	    /* The port is dead */
	    cl->cl_Flags |= AGF_PORTDEAD;

	    /* Allocate a message to send */
	    if (agm = AllocPVec (ag, ag->ag_MemoryPool, AGMSIZE))
	    {
		/* Initialize the message */
		agm->agm_Type = ToolStatusID;
		agm->agm_Msg.mn_Node.ln_Type = NT_MESSAGE;
		agm->agm_Msg.mn_ReplyPort = cl->cl_ChildPort;
		agm->agm_Msg.mn_Length = AGMSIZE;
		agm->agm_Pri_Ret = cl->cl_ErrorLevel;
		agm->agm_Sec_Ret = cl->cl_ErrorNumber;

		/* Send the message */
		PutMsg (cl->cl_AsyncPort, (struct Message *) agm);

		while (!die)
		{
		    WaitPort (cl->cl_ChildPort);
		    die = HandleAmigaGuideMsgs (ag, cl, agm);
		}
	    }
	}

	/* Delete the message ports */
	DeleteMsgPort (cl->cl_ChildPort);
	DeleteMsgPort (cl->cl_AWPort);
	DeleteMsgPort (cl->cl_IDCMPPort);
	cl->cl_ChildPort = cl->cl_AWPort = cl->cl_IDCMPPort = NULL;
    }
    else
    {
	cl->cl_ErrorLevel = RETURN_FAIL;
	cl->cl_ErrorNumber = ERR_CANT_CREATE_PORT;
    }

    FreeARexx (ag, cl->cl_RexxHandle);

    cl->cl_Flags |= AGF_DONE;
}

/*****************************************************************************/

BOOL CreateMsgPorts (struct AmigaGuideLib *ag, struct Client * cl)
{

    if (cl->cl_IDCMPPort = CreateMsgPort ())
    {
	if (cl->cl_AWPort = CreateMsgPort ())
	{
	    if (cl->cl_AsyncPort)
	    {
		if (cl->cl_ChildPort = CreateMsgPort ())
		{
		    return (TRUE);
		}
	    }
	    else
	    {
		return (TRUE);
	    }
	    DeleteMsgPort (cl->cl_AWPort);
	}
	DeleteMsgPort (cl->cl_IDCMPPort);
    }

    cl->cl_ChildPort = NULL;
    cl->cl_AWPort = NULL;
    cl->cl_IDCMPPort = NULL;

    return (FALSE);
}

/*****************************************************************************/

struct Window *OpenAGWindow (struct AmigaGuideLib *ag, struct Client * cl)
{
    LoadSnapShot (ag, cl);
    GetAttr (DTA_NominalHoriz, cl->cl_DataObject, &cl->cl_TotHoriz);
    GetAttr (DTA_NominalVert, cl->cl_DataObject, &cl->cl_TotVert);
    if (cl->cl_TotHoriz == 0)
	cl->cl_TotHoriz = cl->cl_Prefs.p_Window.Width;
    if (cl->cl_TotVert == 0)
	cl->cl_TotVert = cl->cl_Prefs.p_Window.Height;

    /* Build the window */
    if (cl->cl_WinObject = NewObject (ag->ag_WindowClass, NULL,
				      WA_Activate,	!(cl->cl_Flags & AGF_NOACTIVATE),
				      WA_Left,		cl->cl_Prefs.p_Window.Left,
				      WA_Top,		cl->cl_Prefs.p_Window.Top,
				      WA_InnerWidth,	cl->cl_TotHoriz + 4,
				      WA_InnerHeight,	cl->cl_TotVert + 2,
				      WA_PubScreen,	cl->cl_Screen,
				      WA_HelpGroup,	cl->cl_HelpGroup,
				      WOA_Title,	(ULONG)GetAmigaGuideStringLVO (ag, TITLE_LOADING),
				      WOA_VisualInfo,	cl->cl_VI,
				      WOA_DrawInfo,	cl->cl_DrInfo,
				      WOA_IDCMPPort,	cl->cl_IDCMPPort,
				      WOA_AWPort,	cl->cl_AWPort,
				      WOA_TextAttr,	&cl->cl_TAttr,
				      ICA_TARGET,	ICTARGET_IDCMP,
				      TAG_DONE))
    {
	/* Get the window pointers */
	GetAttr (WOA_Window, cl->cl_WinObject, (ULONG *) & cl->cl_Window);
	DoMethod (cl->cl_WinObject, WOM_ADDVIEW, (ULONG) cl->cl_DataObject, NULL);
    }
    return (cl->cl_Window);
}

/*****************************************************************************/

VOID CloseAGWindow (struct AmigaGuideLib *ag, struct Client * cl)
{

    if (cl->cl_Window)
    {
	DoMethod (cl->cl_WinObject, WOM_REMVIEW, (ULONG) cl->cl_DataObject);
	DisposeObject (cl->cl_WinObject);
	cl->cl_WinObject = NULL;
	cl->cl_Window = NULL;
    }
}

/*****************************************************************************/

ULONG ProcessStrCommand (struct AmigaGuideLib *ag, struct Client * cl, STRPTR cmd)
{
    ULONG retval = 1L;

    if (Stricmp (cmd, "QUIT") == 0)
    {
	cl->cl_Going = FALSE;
    }
    else
    {
	if (cl->cl_Window == NULL)
	{
	    OpenAGWindow (ag, cl);
	}

	if (Stricmp (cmd, "WINDOWTOFRONT") == 0)
	{
	    WindowToFront (cl->cl_Window);
	}
	else if (Stricmp (cmd, "WINDOWTOBACK") == 0)
	{
	    WindowToBack (cl->cl_Window);
	}
	else if (Stricmp (cmd, "ACTIVATEWINDOW") == 0)
	{
	    ActivateWindow (cl->cl_Window);
	}
	else if (Stricmp (cmd, "ZOOMWINDOW") == 0)
	{
	    if (!(cl->cl_Window->Flags & WFLG_ZOOMED))
		ZipWindow (cl->cl_Window);
	}
	else if (Stricmp (cmd, "UNZOOMWINDOW") == 0)
	{
	    if (cl->cl_Window->Flags & WFLG_ZOOMED)
		ZipWindow (cl->cl_Window);
	}
	else
	{
	    struct dtTrigger dtt;

	    dtt.MethodID = DTM_TRIGGER;
	    dtt.dtt_GInfo = NULL;
	    dtt.dtt_Function = STM_COMMAND;
	    dtt.dtt_Data = cmd;
	    retval = DoGadgetMethodA ((struct Gadget *) cl->cl_DataObject, cl->cl_Window, NULL, (Msg) &dtt);
	}
    }
    return retval;
}

/*****************************************************************************/

LONG OpenNewData (struct AmigaGuideLib *ag, struct Client * cl, ULONG stype)
{
    struct dtTrigger dtt;
    struct DataType *dtn;
    LONG retval = 0L;
    BPTR lock;

    /* Show that we're loading a new object */
    setattrs (ag, cl->cl_WinObject, WOA_Title, (ULONG) GetAmigaGuideStringLVO (ag, TITLE_LOADING), TAG_DONE);

    if (stype == DTST_FILE)
    {
	sprintf (cl->cl_TempBuffer, "LINK \"%s/Main\"", cl->cl_NameBuffer);
	dtt.MethodID = DTM_TRIGGER;
	dtt.dtt_GInfo = NULL;
	dtt.dtt_Function = STM_COMMAND;
	dtt.dtt_Data = cl->cl_TempBuffer;

	retval = DoGadgetMethodA ((struct Gadget *) cl->cl_DataObject, cl->cl_Window, NULL, (Msg) &dtt);
    }

    if (retval == 0)
    {
	if (cl->cl_DataObject)
	{
	    DoMethod ((Object *) cl->cl_WinObject, WOM_REMVIEW, (ULONG) cl->cl_DataObject);

	    SetAPen (cl->cl_Window->RPort, 0);
	    RectFill (cl->cl_Window->RPort,
		      cl->cl_Window->BorderLeft,
		      cl->cl_Window->BorderTop,
		      cl->cl_Window->Width - cl->cl_Window->BorderRight - 1,
		      cl->cl_Window->Height - cl->cl_Window->BorderBottom - 1);

	    DisposeDTObject (cl->cl_DataObject);
	}

	if (cl->cl_DataObject = NewDTObject (cl->cl_NameBuffer,
					     GA_Immediate,	TRUE,
					     GA_RelVerify,	TRUE,
					     AGA_HelpGroup,	cl->cl_HelpGroup,
					     DTA_SourceType,	stype,
					     DTA_TextAttr,	(ULONG) & cl->cl_TAttr,
					     TAG_DONE))
	{
	    DoMethod (cl->cl_WinObject, WOM_ADDVIEW, (ULONG) cl->cl_DataObject, NULL);
	    retval = 1L;
	}
	else
	{
	    cl->cl_ErrorNumber = IoErr ();

	    if (lock = Lock (cl->cl_NameBuffer, ACCESS_READ))
	    {
		if (dtn = ObtainDataTypeA (DTST_FILE, (APTR) lock, NULL))
		{
		    if (Stricmp (dtn->dtn_Header->dth_Name, "directory") == 0)
			retval = 2;
		    ReleaseDataType (dtn);
		}
		UnLock (lock);
	    }

	    if (retval == 0)
	    {
		PrintF (ag, cl, 2, cl->cl_ErrorNumber, FilePart (cl->cl_NameBuffer));

		/* Clear the sliders */
		SetGadgetAttrs ((struct Gadget *)cl->cl_WinObject, cl->cl_Window, NULL,
			  DTA_TopVert, 0L,
			  DTA_TopHoriz, 0L,
			  DTA_TotalVert, 0L,
			  DTA_TotalHoriz, 0L,
			  TAG_DONE);
	    }
	    else
	    {
		setattrs (ag, cl->cl_WinObject, WOA_Title, (ULONG) GetAmigaGuideStringLVO (ag, TITLE_AMIGAGUIDE), TAG_DONE);
	    }

	    /* Clear the window pointer */
	    setwindowpointer (ag, cl->cl_Window, WA_Pointer, NULL, TAG_DONE);
	}
    }
    return retval;
}

/*****************************************************************************/

BOOL HandleAmigaGuideMsgs (struct AmigaGuideLib *ag, struct Client * cl, struct AmigaGuideMsg * dagm)
{
    struct AmigaGuideMsg *agm;
    BOOL die = FALSE;

    while (agm = (struct AmigaGuideMsg *) GetMsg (cl->cl_ChildPort))
    {
	if (agm == dagm)
	    die = TRUE;

	if (agm->agm_Msg.mn_Node.ln_Type == NT_MESSAGE)
	{
	    switch (agm->agm_Type)
	    {
		case ShutdownToolID:
		    cl->cl_Going = FALSE;
		    die = TRUE;
		    break;

		case ToolCmdID:
		    strcpy (cl->cl_WorkText, agm->agm_Data);
		    if (!(cl->cl_Flags & AGF_PORTDEAD))
			ProcessStrCommand (ag, cl, cl->cl_WorkText);
		    break;
	    }
	    ReplyMsg ((struct Message *) agm);
	}
	else if (agm->agm_Msg.mn_Node.ln_Type == NT_REPLYMSG)
	{
	    /* Return the message to the pool */
	    FreePVec (ag, ag->ag_MemoryPool, agm);
	}
    }
    return die;
}

/*****************************************************************************/

void HandleEvents (struct AmigaGuideLib *ag, struct Client * cl)
{
    struct MenuItem *menuitem;
    struct IntuiMessage *imsg;
    struct AppMessage *amsg;
    LONG error = RETURN_OK;
    struct TagItem *attrs;
    struct RexxMsg *rmsg;
    struct WBArg *wbarg;
    struct TagItem *tag;
    STRPTR text = NULL;
    BOOL die = FALSE;
    ULONG sigpr;
    ULONG siga;
    ULONG sigw;
    ULONG sigr;
    ULONG sigc;
    ULONG sigp;
    UWORD id;

    /* Get the signal bits */
    siga = 1L << cl->cl_AWPort->mp_SigBit;
    sigc = (cl->cl_ChildPort) ? (1L << cl->cl_ChildPort->mp_SigBit) : 0L;
    sigw = 1L << cl->cl_IDCMPPort->mp_SigBit;
    sigp = ARexxSignal (ag, cl->cl_RexxHandle);

    /* Keep going until we are told to stop */
    while (cl->cl_Going)
    {
	/*******************************/
	/* Any damage to take care of? */
	/*******************************/
	if (cl->cl_Window && (LAYERREFRESH & cl->cl_Window->WLayer->Flags))
	{
	    BeginRefresh (cl->cl_Window);
	    EndRefresh (cl->cl_Window, TRUE);
	}

	sigpr = NULL;
	if (cl->cl_PrintWin)
	{
	    sigpr = 1L << cl->cl_PrintWin->UserPort->mp_SigBit;
	}

	/* Wait for something to happen */
	sigr = Wait (siga | sigc | sigw | sigp | sigpr | SIGBREAKF_CTRL_C | SIGBREAKF_CTRL_F);

	/************/
	/* Aborted? */
	/************/
	if (sigr & SIGBREAKF_CTRL_C)
	{
	    cl->cl_Going = FALSE;
	}

	/**************/
	/* Activated? */
	/***************/
	if (sigr & SIGBREAKF_CTRL_F)
	{
	    if (cl->cl_Window)
	    {
		if (cl->cl_Window->Flags & WFLG_ZOOMED)
		    ZipWindow (cl->cl_Window);
		WindowToFront (cl->cl_Window);
		ActivateWindow (cl->cl_Window);
	    }
	}

	/******************/
	/* Printer window */
	/******************/
	if ((sigr & sigpr) && cl->cl_PrintWin)
	{
	    if (SysReqHandler (cl->cl_PrintWin, NULL, FALSE) == 0)
	    {
		DoMethod (cl->cl_DataObject, DTM_ABORTPRINT, NULL);
	    }
	}

	/*****************/
	/* ARexx message */
	/*****************/
	if (cl->cl_RexxHandle && (sigr & sigp))
	{
	    rmsg = GetARexxMsg (ag, cl->cl_RexxHandle);

	    /* Make sure it is something we can handle */
	    if (rmsg == REXX_RETURN_ERROR)
	    {
		/* Put the error message here someday... */
	    }
	    else if (rmsg)
	    {
		strcpy (cl->cl_WorkText, ARG0 (rmsg));
		ProcessStrCommand (ag, cl, cl->cl_WorkText);
		ReplyARexxMsg (ag, cl->cl_RexxHandle, rmsg, text, error);
	    }
	}

	/************************/
	/* Asynchronous message */
	/************************/
	if (sigr & sigc)
	{
	    die = HandleAmigaGuideMsgs (ag, cl, NULL);
	}

	/*********************/
	/* AppWindow message */
	/*********************/
	if (sigr & siga)
	{
	    ActivateWindow (cl->cl_Window);
	    setwindowpointer (ag, cl->cl_Window, WA_BusyPointer, TRUE, TAG_DONE);

	    while (amsg = (struct AppMessage *) GetMsg (cl->cl_AWPort))
	    {
		if (amsg->am_NumArgs)
		{
		    wbarg = amsg->am_ArgList;
		    NameFromLock (wbarg->wa_Lock, cl->cl_NameBuffer, NAMEBUFSIZE);
		    AddPart (cl->cl_NameBuffer, wbarg->wa_Name, NAMEBUFSIZE);

		    if (OpenNewData (ag, cl, DTST_FILE) == 2)
		    {
			if (FileRequest (ag, cl, 0, GetAmigaGuideStringLVO (ag, TITLE_SELECT_FILE_TO_OPEN), GetAmigaGuideStringLVO (ag, LABEL_OPEN), cl->cl_NameBuffer))
			{
			    OpenNewData (ag, cl, DTST_FILE);
			}
		    }
		}

		ReplyMsg ((struct Message *) amsg);
	    }
	}

	/*********************/
	/* Intuition message */
	/*********************/
	while (imsg = (struct IntuiMessage *) GetMsg (cl->cl_IDCMPPort))
	{
	    switch (imsg->Class)
	    {
		case IDCMP_MENUPICK:
		    id = imsg->Code;
		    while ((id != MENUNULL) && cl->cl_Going)
		    {
			menuitem = ItemAddress (imsg->IDCMPWindow->MenuStrip, id);
			ProcessCommand (ag, cl, (ULONG) MENU_USERDATA (menuitem), imsg);
			id = menuitem->NextSelect;
		    }
		    break;

		case IDCMP_CLOSEWINDOW:
		    cl->cl_Going = FALSE;
		    break;

		case IDCMP_MOUSEBUTTONS:
		    setwindowpointer (ag, cl->cl_Window, WA_Pointer, NULL, TAG_DONE);
		    break;

		case IDCMP_GADGETUP:
		    setwindowpointer (ag, cl->cl_Window, WA_Pointer, NULL, TAG_DONE);
		    {
			switch (((struct Gadget *) imsg->IAddress)->GadgetID)
			{
			    case GID_CONTENTS:
				cl->cl_Trigger.dtt_Function = STM_CONTENTS;
				DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, (Msg) &cl->cl_Trigger);
				break;

			    case GID_INDEX:
				cl->cl_Trigger.dtt_Function = STM_INDEX;
				DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, (Msg) &cl->cl_Trigger);
				break;

			    case GID_HELP:
				break;

			    case GID_RETRACE:
				cl->cl_Trigger.dtt_Function = STM_RETRACE;
				DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, (Msg) &cl->cl_Trigger);
				break;

			    case GID_BROWSEP:
				cl->cl_Trigger.dtt_Function = STM_BROWSE_PREV;
				DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, (Msg) &cl->cl_Trigger);
				break;

			    case GID_BROWSEN:
				cl->cl_Trigger.dtt_Function = STM_BROWSE_NEXT;
				DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, (Msg) &cl->cl_Trigger);
				break;
			}
		    }
		    break;

		case IDCMP_RAWKEY:
		    switch (imsg->Code)
		    {
			    /* Shift Tab */
			case 66:
			    Navigate (ag, cl, AC_FIELD_PREV, FALSE);
			    break;

			    /* Up Arrow */
			case 76:
			    if (imsg->Qualifier & ALTED)
				Navigate (ag, cl, AC_TOP, TRUE);
			    else if (imsg->Qualifier & SHIFTED)
				Navigate (ag, cl, AC_PAGE_UP, TRUE);
			    else
				Navigate (ag, cl, AC_UNIT_UP, TRUE);
			    break;

			    /* Down Arrow */
			case 77:
			    if (imsg->Qualifier & ALTED)
				Navigate (ag, cl, AC_BOTTOM, TRUE);
			    else if (imsg->Qualifier & SHIFTED)
				Navigate (ag, cl, AC_PAGE_DOWN, TRUE);
			    else
				Navigate (ag, cl, AC_UNIT_DOWN, TRUE);
			    break;

			    /* Right Arrow */
			case 78:
			    if (imsg->Qualifier & ALTED)
				Navigate (ag, cl, AC_FAR_RIGHT, TRUE);
			    else if (imsg->Qualifier & SHIFTED)
				Navigate (ag, cl, AC_PAGE_RIGHT, TRUE);
			    else
				Navigate (ag, cl, AC_UNIT_RIGHT, TRUE);
			    break;

			    /* Left Arrow */
			case 79:
			    if (imsg->Qualifier & ALTED)
				Navigate (ag, cl, AC_FAR_LEFT, TRUE);
			    else if (imsg->Qualifier & SHIFTED)
				Navigate (ag, cl, AC_PAGE_LEFT, TRUE);
			    else
				Navigate (ag, cl, AC_UNIT_LEFT, TRUE);
			    break;
		    }
		    break;

		case IDCMP_VANILLAKEY:
		    switch (imsg->Code)
		    {
			    /* Backspace */
			case 8:
			    Navigate (ag, cl, AC_PAGE_UP, TRUE);
			    break;

			    /* Tab */
			case 9:
			    if (imsg->Qualifier & SHIFTED)
				Navigate (ag, cl, AC_FIELD_PREV, FALSE);
			    else
				Navigate (ag, cl, AC_FIELD_NEXT, FALSE);
			    break;

			    /* Return */
			case 13:
			    Navigate (ag, cl, AC_ACTIVATE_FIELD, FALSE);
			    break;

			    /* Space */
			case 32:
			    Navigate (ag, cl, AC_PAGE_DOWN, TRUE);
			    break;

			case '/':
			    Navigate (ag, cl, AC_RETRACE, FALSE);
			    break;

			case '<':
			    Navigate (ag, cl, AC_NODE_PREV, FALSE);
			    break;

			case '>':
			    Navigate (ag, cl, AC_NODE_NEXT, FALSE);
			    break;

			case 'q':
			case 'Q':
			case 27:
			    cl->cl_Going = FALSE;
			    break;
		    }
		    break;

		case IDCMP_IDCMPUPDATE:
		    attrs = (struct TagItem *) imsg->IAddress;

		    if (tag = FindTagItem (DTA_ErrorLevel, attrs))
		    {
			cl->cl_ErrorNumber = GetTagData (DTA_ErrorNumber, NULL, attrs);
			PrintF (ag, cl, 2, cl->cl_ErrorNumber, (STRPTR) GetTagData (DTA_ErrorString,NULL,attrs));
		    }

		    if (tag = FindTagItem (DTA_PrinterStatus, attrs))
		    {
			PrintComplete (ag, cl);

			if (tag->ti_Data)
			{
			    PrintF (ag, cl, 1, 5100 + tag->ti_Data, NULL);
			}
		    }

		    if (tag = FindTagItem (DTA_Busy, attrs))
		    {
			if (tag->ti_Data)
			    setwindowpointer (ag, cl->cl_Window, WA_BusyPointer, TRUE, TAG_DONE);
			else
			    setwindowpointer (ag, cl->cl_Window, WA_Pointer, NULL, TAG_DONE);
		    }

		    if (tag = FindTagItem (DTA_Title, attrs))
			setattrs (ag, cl->cl_WinObject, WOA_Title, tag->ti_Data, TAG_DONE);

#if 0
		    if (tag = FindTagItem (DTA_Sync, attrs))
			setattrs (ag, cl->cl_WinObject, WOA_Sync, tag->ti_Data, TAG_DONE);
#endif
		    break;
	    }

	    ReplyMsg ((struct Message *) imsg);
	}

	if (!cl->cl_Going && !die && cl->cl_Process)
	{
	    CloseAGWindow (ag, cl);
	    cl->cl_Going = TRUE;
	}
    }
}


/*****************************************************************************/

VOID Navigate (struct AmigaGuideLib *ag, struct Client * cl, LONG cmd, BOOL needvisual)
{
    LONG otoph, toph, vish, toth;
    LONG otopv, topv, visv, totv;

    if (needvisual)
    {
	GetDTAttrs (cl->cl_DataObject,
		    DTA_TopVert, &topv,
		    DTA_VisibleVert, &visv,
		    DTA_TotalVert, &totv,
		    DTA_TopHoriz, &toph,
		    DTA_VisibleHoriz, &vish,
		    DTA_TotalHoriz, &toth,
		    TAG_DONE);
	otoph = toph;
	otopv = topv;
    }

    switch (cmd)
    {
	case AC_TOP:
	    topv = 0;
	    break;

	case AC_BOTTOM:
	    topv = totv - visv;
	    break;

	case AC_FAR_LEFT:
	    toph = 0;
	    break;

	case AC_FAR_RIGHT:
	    toph = toth - vish;
	    break;

	case AC_UNIT_UP:
	    topv--;
	    break;

	case AC_UNIT_DOWN:
	    topv++;
	    break;

	case AC_UNIT_LEFT:
	    toph--;
	    break;

	case AC_UNIT_RIGHT:
	    toph++;
	    break;

	case AC_PAGE_UP:
	    topv -= (visv - 1);
	    break;

	case AC_PAGE_DOWN:
	    topv += (visv - 1);
	    break;

	case AC_PAGE_LEFT:
	    toph -= (vish - 1);
	    break;

	case AC_PAGE_RIGHT:
	    toph += (vish - 1);
	    break;

	case AC_FIELD_NEXT:
	    cl->cl_Trigger.dtt_Function = STM_NEXT_FIELD;
	    DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, (Msg) &cl->cl_Trigger);
	    break;

	case AC_FIELD_PREV:
	    cl->cl_Trigger.dtt_Function = STM_PREV_FIELD;
	    DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, (Msg) &cl->cl_Trigger);
	    break;

	case AC_ACTIVATE_FIELD:
	    cl->cl_Trigger.dtt_Function = STM_ACTIVATE_FIELD;
	    DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, (Msg) &cl->cl_Trigger);
	    break;

	case AC_NODE_NEXT:
	    cl->cl_Trigger.dtt_Function = STM_BROWSE_NEXT;
	    DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, (Msg) &cl->cl_Trigger);
	    break;

	case AC_NODE_PREV:
	    cl->cl_Trigger.dtt_Function = STM_BROWSE_PREV;
	    DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, (Msg) &cl->cl_Trigger);
	    break;

	case AC_RETRACE:
	    cl->cl_Trigger.dtt_Function = STM_RETRACE;
	    DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, (Msg) &cl->cl_Trigger);
	    break;
    }

    if (needvisual)
    {
	if (topv < 0)
	    topv = 0;
	if (toph < 0)
	    toph = 0;
	if (topv > totv - visv)
	    topv = totv - visv;
	if (toph > toth - vish)
	    toph = toth - vish;

	if ((topv != otopv) || (toph != otoph))
	{
	    SetGadgetAttrs ((struct Gadget *)cl->cl_WinObject, cl->cl_Window, NULL,
			DTA_TopVert, topv,
			DTA_TopHoriz, toph,
			DTA_Sync, TRUE,
			TAG_DONE);
	}
    }
}

/*****************************************************************************/

void ProcessCommand (struct AmigaGuideLib *ag, struct Client * cl, ULONG id, struct IntuiMessage * imsg)
{
    struct Window *win = cl->cl_Window;
    struct DTSpecialInfo *si = NULL;
    ULONG left, top, width, height;
    struct dtGeneral dtg;
    BOOL change = FALSE;
    struct Gadget *g;

    if (!id)
	return;

    if (g = G (cl->cl_DataObject))
	si = (struct DTSpecialInfo *) g->SpecialInfo;

    switch (id)
    {
	case MMC_OPEN:
	    if (FileRequest (ag, cl, 0, GetAmigaGuideStringLVO (ag, TITLE_SELECT_FILE_TO_OPEN), GetAmigaGuideStringLVO (ag, LABEL_OPEN), cl->cl_NameBuffer))
	    {
		OpenNewData (ag, cl, DTST_FILE);
	    }
	    break;

	case MMC_SAVEAS:
	    if (cl->cl_DataObject)
	    {
		SaveObject (ag, cl, DTWM_RAW);
	    }
	    break;

	case MMC_PRINT:
	    if (cl->cl_DataObject)
	    {
		PrintObject (ag, cl, 0);
	    }
	    break;

	case MMC_ABOUT:
	    if (cl->cl_DataObject)
	    {
		AboutObject (ag, cl);
	    }
	    break;

	case MMC_QUIT:
	    cl->cl_Going = FALSE;
	    break;

	case MMC_MARK:
	    if (si)
	    {
		si->si_Flags |= DTSIF_DRAGSELECT;
		SetBlockPointer (ag, win);
	    }
	    break;

	case MMC_COPY:
	    dtg.MethodID = DTM_COPY;
	    DoDTMethodA (cl->cl_DataObject, win, NULL, (Msg) &dtg);
	    break;

	/* WINDOW menu */
	case MMC_MINIMIZE:
	    left   = cl->cl_Window->LeftEdge;
	    top    = cl->cl_Window->TopEdge;
	    width  = cl->cl_Window->MinWidth;
	    height = cl->cl_Window->MinHeight;
	    change = TRUE;
	    break;

	case MMC_NORMAL:
	    left   = cl->cl_Window->LeftEdge;
	    top    = cl->cl_Window->TopEdge;
	    width  = 0;
	    height = 0;
	    if (cl->cl_DataObject)
	    {
		GetDTAttrs (cl->cl_DataObject,
			    DTA_NominalHoriz,	&width,
			    DTA_NominalVert,	&height,
			    TAG_DONE);
	    }

	    if (width == 0)
		width  = cl->cl_Window->RPort->TxWidth * 80;
	    if (height == 0)
		height = cl->cl_Window->RPort->TxHeight * 24;
	    width  += 4 + cl->cl_Window->BorderLeft + cl->cl_Window->BorderRight;
	    height += 2 + cl->cl_Window->BorderTop  + cl->cl_Window->BorderBottom;
	    change = TRUE;
	    break;

	case MMC_MAXIMIZE:
	    left   = 0;
	    top    = 0;
	    width  = cl->cl_Window->WScreen->Width;
	    height = cl->cl_Window->WScreen->Height;
	    change = TRUE;
	    break;

	case MMC_SAVE_AS_DEFAULTS:
	    SaveSnapShot (ag, cl);
	    break;
    }

    if (change)
	ChangeWindowBox (cl->cl_Window, left, top, width, height);
}

/*****************************************************************************/

VOID AboutObject (struct AmigaGuideLib *ag, struct Client * cl)
{
    struct EasyStruct es;
    struct DataType *dtn;

    GetDTAttrs (cl->cl_DataObject, DTA_DataType, (ULONG) & dtn, TAG_DONE);

    es.es_StructSize = sizeof (struct EasyStruct);
    es.es_Flags = 0;
    es.es_Title = GetAmigaGuideStringLVO (ag, TITLE_AMIGAGUIDE);
    es.es_TextFormat = "AmigaGuide %ld.%ld (%s)\n%s %s";
    es.es_GadgetFormat = GetAmigaGuideStringLVO (ag, LABEL_CONTINUE);

    easyrequest (ag, cl->cl_Window, &es, VERSION, REVISION, DATE, dtn->dtn_Header->dth_Name, GetDTString (dtn->dtn_Header->dth_GroupID));
}
@


39.11
log
@duplock's the nag_lock
@
text
@d6 1
d8 3
d15 1
a15 9
#define	DA(x)	;
#define	DB(x)	;
#define	DC(x)	;
#define	DT(x)	;
#define	DG(x)	;
#define	DL(x)	;
#define	DK(x)	;
#define	DM(x)	;
 /* Message */
a55 2
    DB (kprintf ("\n\nMainLoop\n"));

a96 3
		    DB (kprintf ("nag_Name 0x%lx [%s]\n", nag->nag_Name, nag->nag_Name));
		    DB (kprintf ("nag_Node 0x%lx [%s]\n", nag->nag_Node, ((nag->nag_Node) ? nag->nag_Node : "NULL")));

d105 5
a109 2
			DB (kprintf ("newdtobject '%s', %ld\n", nag->nag_Name, nag->nag_Line));
			if (cl->cl_DataObject = newdtobject (ag, nag->nag_Name,
d113 1
a113 3
							     DTA_TextAttr,	(ULONG) & cl->cl_TAttr,
							     DTA_NodeName,	(ULONG) nag->nag_Node,
							     DTA_TopVert,	nag->nag_Line,
a133 1
					DB (kprintf ("send ActiveToolID\n"));
a167 2
			    DB (kprintf ("couldn't open '%s', %ld\n", nag->nag_Name, IoErr ()));

a176 1
			DB (kprintf ("Couldn't find the file\n"));
a208 1
	DM (kprintf ("async=0x%lx, level=%ld, number=%ld\n", cl->cl_AsyncPort, cl->cl_ErrorLevel, cl->cl_ErrorNumber));
a228 1
		DM (kprintf ("put error message : level=%ld, value=%ld\n", cl->cl_ErrorLevel, cl->cl_ErrorNumber));
a232 1
		    DM (kprintf ("wait for reply\n"));
a233 1
		    DM (kprintf ("received reply\n"));
a234 1
		    DM (kprintf ("pulled messages\n"));
a235 1
		DM (kprintf ("all done now.\n"));
d301 1
a301 1
    if (cl->cl_WinObject = newobject (ag, ag->ag_WindowClass, NULL,
d431 1
a431 1
	if (cl->cl_DataObject = newdtobject (ag, cl->cl_NameBuffer,
d462 1
a462 5
#if 0
		setattrs (ag, cl->cl_WinObject,
#else
		setgadgetattrs (ag, (struct Gadget *)cl->cl_WinObject, cl->cl_Window,
#endif
d566 9
a574 1
	sigr = Wait (siga | sigc | sigw | sigp | sigpr);
d576 14
a719 1
		    DK (kprintf ("raw %ld\n", (LONG) imsg->Code));
a723 1
			    DB (kprintf ("shift tab\n"));
a769 1
		    DK (kprintf ("van %ld\n", (LONG) imsg->Code));
a778 1
			    DB (kprintf ("tab\n"));
d873 1
a873 1
	getdtattrs (ag, cl->cl_DataObject,
d979 1
a979 6
	    DB (kprintf ("topv=%ld, toph=%ld\n", topv, toph));
#if 0
	    setdtattrs (ag, cl->cl_DataObject, cl->cl_Window,
#else
	    setgadgetattrs (ag, (struct Gadget *)cl->cl_WinObject, cl->cl_Window,
#endif
d1068 1
a1068 1
		getdtattrs (ag, cl->cl_DataObject,
d1107 1
a1107 1
    getdtattrs (ag, cl->cl_DataObject, DTA_DataType, (ULONG) & dtn, TAG_DONE);
@


39.10
log
@passes nag_Lock correctly
@
text
@d108 1
a108 1
			old = CurrentDir (nag->nag_Lock);
@


39.9
log
@determines public screen name
@
text
@d92 1
a92 1
	    cl->cl_TAttr.ta_Name = cl->cl_TFont->tf_Message.mn_Node.ln_Name;
a104 1
		    old = SetCurrentDirELVO (ag, NULL, nag->nag_Name);
d106 6
d114 1
a114 2
			DB (kprintf ("newdtobject\n"));
			DL (kprintf ("line=%ld\n", (LONG) nag->nag_Line));
d116 6
a121 6
							     GA_Immediate, TRUE,
							     GA_RelVerify, TRUE,
							     AGA_HelpGroup, cl->cl_HelpGroup,
							     DTA_TextAttr, (ULONG) & cl->cl_TAttr,
							     DTA_NodeName, (ULONG) nag->nag_Node,
							     DTA_TopVert, nag->nag_Line,
d177 3
a179 1
			    cl->cl_ErrorLevel = RETURN_FAIL;
d189 1
a189 1
			cl->cl_ErrorLevel = RETURN_FAIL;
@


39.8
log
@check GetARexxMsg return value for errors.
@
text
@a17 1

d23 31
a53 1
void MainLoop (struct AmigaGuideLib * ag, struct Client * cl)
d86 2
d155 5
d270 1
a270 1
BOOL CreateMsgPorts (struct AmigaGuideLib * ag, struct Client * cl)
d302 1
a302 1
struct Window *OpenAGWindow (struct AmigaGuideLib * ag, struct Client * cl)
d339 1
a339 1
VOID CloseAGWindow (struct AmigaGuideLib * ag, struct Client * cl)
d353 1
a353 1
ULONG ProcessStrCommand (struct AmigaGuideLib * ag, struct Client * cl, STRPTR cmd)
d398 1
a398 1
	    retval = DoGadgetMethodA ((struct Gadget *) cl->cl_DataObject, cl->cl_Window, NULL, &dtt);
d406 1
a406 1
LONG OpenNewData (struct AmigaGuideLib * ag, struct Client * cl, ULONG stype)
d424 1
a424 1
	retval = DoGadgetMethodA ((struct Gadget *) cl->cl_DataObject, cl->cl_Window, NULL, &dtt);
d499 1
a499 1
BOOL HandleAmigaGuideMsgs (struct AmigaGuideLib * ag, struct Client * cl, struct AmigaGuideMsg * dagm)
d537 1
a537 1
void HandleEvents (struct AmigaGuideLib * ag, struct Client * cl)
d684 1
a684 1
				DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, &cl->cl_Trigger);
d689 1
a689 1
				DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, &cl->cl_Trigger);
d697 1
a697 1
				DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, &cl->cl_Trigger);
d702 1
a702 1
				DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, &cl->cl_Trigger);
d707 1
a707 1
				DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, &cl->cl_Trigger);
d864 1
a864 1
VOID Navigate (struct AmigaGuideLib * ag, struct Client * cl, LONG cmd, BOOL needvisual)
d935 1
a935 1
	    DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, &cl->cl_Trigger);
d940 1
a940 1
	    DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, &cl->cl_Trigger);
d945 1
a945 1
	    DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, &cl->cl_Trigger);
d950 1
a950 1
	    DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, &cl->cl_Trigger);
d955 1
a955 1
	    DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, &cl->cl_Trigger);
d960 1
a960 1
	    DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, &cl->cl_Trigger);
d993 1
a993 1
void ProcessCommand (struct AmigaGuideLib * ag, struct Client * cl, ULONG id, struct IntuiMessage * imsg)
d1052 1
a1052 1
	    DoDTMethodA (cl->cl_DataObject, win, NULL, &dtg);
d1105 1
a1105 1
VOID AboutObject (struct AmigaGuideLib * ag, struct Client * cl)
@


39.7
log
@tracks help group
@
text
@d564 8
a571 1
	    if (rmsg = GetARexxMsg (ag, cl->cl_RexxHandle))
@


39.6
log
@cleaned
@
text
@d83 1
d284 1
d408 3
a412 2
					     GA_Immediate,	TRUE,
					     GA_RelVerify,	TRUE,
@


39.5
log
@*** empty log message ***
@
text
@d267 1
a267 3
    struct IBox box;

    LoadSnapShot (ag, cl, &box);
d271 1
a271 1
	cl->cl_TotHoriz = box.Width;
d273 1
a273 1
	cl->cl_TotVert = box.Height;
d278 2
a279 2
				      WA_Left,		box.Left,
				      WA_Top,		box.Top,
d435 1
d437 7
a443 2
			  DTA_TotalVert,	0L,
			  DTA_TotalHoriz,	0L,
d932 1
d934 3
d1069 1
a1069 1
    es.es_TextFormat = "AmigaGuide %ld.%ld (%s)\nWritten by David N. Junod\n\nContents Type: %s %s";
@


39.4
log
@fixed SIPC messages.
synced with MultiView
@
text
@d378 1
a378 1
    setattrs (ag, cl->cl_WinObject, DTA_Title, (ULONG) GetAmigaGuideStringLVO (ag, TITLE_LOADING), TAG_DONE);
d444 1
a444 1
		setattrs (ag, cl->cl_WinObject, DTA_Title, (ULONG) GetAmigaGuideStringLVO (ag, TITLE_AMIGAGUIDE), TAG_DONE);
d789 8
@


39.3
log
@*** empty log message ***
@
text
@d19 3
d24 1
a24 1
void MainLoop (struct AmigaGuideLib *ag, struct Client *cl)
d31 2
d38 1
a38 1
	if (!(cl->cl_RexxHandle = InitARexx (ag, nag->nag_ClientPort, "guide", (LONG)(cl->cl_Flags & AGF_UNIQUE))))
d40 2
a41 2
	    cl->cl_Pri_Ret = RETURN_FAIL;
	    cl->cl_Sec_Ret = ERR_CANT_CREATE_PORT;
d46 1
a46 1
    if ((error==FALSE) && CreateMsgPorts (ag, cl))
d61 1
a61 1
	    cl->cl_TAttr.ta_Name  = cl->cl_TFont->tf_Message.mn_Node.ln_Name;
d72 2
a73 1
		    DB (kprintf ("nag_Name %s\n", nag->nag_Name));
d76 1
a76 10
		    DB (kprintf ("nag_Node 0x%lx [%s]\n", nag->nag_Node, ((nag->nag_Node) ? nag->nag_Node : "NULL")));
		    DB (kprintf ("newdtobject\n"));
		    DL (kprintf ("line=%ld\n", (LONG)nag->nag_Line));
		    if (cl->cl_DataObject = newdtobject (ag, nag->nag_Name,
							 GA_Immediate,	TRUE,
							 GA_RelVerify,	TRUE,
							 DTA_TextAttr,	(ULONG)&cl->cl_TAttr,
							 DTA_NodeName,	(ULONG)nag->nag_Node,
							 DTA_TopVert,	nag->nag_Line,
							 TAG_DONE))
d78 9
a86 1
			if (cl->cl_Process || OpenAGWindow (ag, cl))
d88 3
a90 1
			    HandleEvents (ag, cl);
d92 29
a120 1
			    PrintComplete (ag, cl);
d122 11
a132 1
			    CloseAGWindow (ag, cl);
d136 2
a137 2
			    cl->cl_Pri_Ret = RETURN_FAIL;
			    cl->cl_Sec_Ret = ERR_CANT_OPEN_WINDOW;
d140 2
a141 2
			/* Free the data object */
			DisposeDTObject (cl->cl_DataObject);
d145 3
a147 2
			cl->cl_Pri_Ret = RETURN_FAIL;
			cl->cl_Sec_Ret = ERR_CANT_OPEN_DATABASE;	/* IoErr(); */
a149 3
		    /* Unwind */
		    CurrentDir (old);

d155 2
a156 2
		    cl->cl_Pri_Ret = RETURN_FAIL;
		    cl->cl_Sec_Ret = ERR_CANT_OPEN_WINDOW;
d164 2
a165 2
		cl->cl_Pri_Ret = RETURN_FAIL;
		cl->cl_Sec_Ret = ERR_CANT_OPEN_WINDOW;
d174 2
a175 2
	    cl->cl_Pri_Ret = RETURN_FAIL;
	    cl->cl_Sec_Ret = ERR_CANT_OPEN_WINDOW;
d178 36
d218 1
d222 2
a223 2
	cl->cl_Pri_Ret = RETURN_FAIL;
	cl->cl_Sec_Ret = ERR_CANT_CREATE_PORT;
d233 1
a233 1
BOOL CreateMsgPorts (struct AmigaGuideLib *ag, struct Client *cl)
d235 1
d244 1
a244 16
		    struct AmigaGuideMsg *agm;

		    /* Allocate a message to send */
		    if (agm = AllocPVec (ag, ag->ag_MemoryPool, AGMSIZE))
		    {
			/* Initialize the message */
			agm->agm_Type		     = ActiveToolID;
			agm->agm_Msg.mn_Node.ln_Type = NT_MESSAGE;
			agm->agm_Msg.mn_ReplyPort    = cl->cl_ChildPort;
			agm->agm_Msg.mn_Length       = AGMSIZE;

			/* Send the message */
			PutMsg (cl->cl_AsyncPort, (struct Message *) agm);
			return (TRUE);
		    }
		    DeleteMsgPort (cl->cl_ChildPort);
d265 1
a265 1
struct Window *OpenAGWindow (struct AmigaGuideLib *ag, struct Client *cl)
a266 1
    struct NewAmigaGuide *nag = cl->cl_NAG;
d271 1
a271 1
    GetAttr (DTA_NominalVert,  cl->cl_DataObject, &cl->cl_TotVert);
d279 14
a292 14
				  WA_Activate,		!(cl->cl_Flags & AGF_NOACTIVATE),
				  WA_Left,		box.Left,
				  WA_Top,		box.Top,
				  WA_InnerWidth,	cl->cl_TotHoriz + 4,
				  WA_InnerHeight,	cl->cl_TotVert + 2,
				  WA_PubScreen,		cl->cl_Screen,
				  WOA_Title,		nag->nag_Name,
				  WOA_VisualInfo,	cl->cl_VI,
				  WOA_DrawInfo,		cl->cl_DrInfo,
				  WOA_IDCMPPort,	cl->cl_IDCMPPort,
				  WOA_AWPort,		cl->cl_AWPort,
				  WOA_TextAttr,		&cl->cl_TAttr,
				  ICA_TARGET,		ICTARGET_IDCMP,
				  TAG_DONE))
d295 1
a295 1
	GetAttr (WOA_Window, cl->cl_WinObject, (ULONG *)&cl->cl_Window);
d303 1
a303 1
VOID CloseAGWindow (struct AmigaGuideLib *ag, struct Client *cl)
d305 1
d308 1
a308 1
	DoMethod (cl->cl_WinObject, WOM_REMVIEW, (ULONG)cl->cl_DataObject);
d317 1
a317 1
ULONG ProcessStrCommand (struct AmigaGuideLib *ag, struct Client *cl, STRPTR cmd)
d328 1
d330 27
d358 6
a363 32
        if (Stricmp (cmd, "WINDOWTOFRONT") == 0)
        {
            WindowToFront (cl->cl_Window);
        }
        else if (Stricmp (cmd, "WINDOWTOBACK") == 0)
        {
            WindowToBack (cl->cl_Window);
        }
        else if (Stricmp (cmd, "ACTIVATEWINDOW") == 0)
        {
            ActivateWindow (cl->cl_Window);
        }
        else if (Stricmp (cmd, "ZOOMWINDOW") == 0)
        {
            if (!(cl->cl_Window->Flags & WFLG_ZOOMED))
                ZipWindow (cl->cl_Window);
        }
        else if (Stricmp (cmd, "UNZOOMWINDOW") == 0)
        {
            if (cl->cl_Window->Flags & WFLG_ZOOMED)
                ZipWindow (cl->cl_Window);
        }
        else
        {
            struct dtTrigger dtt;

            dtt.MethodID     = DTM_TRIGGER;
            dtt.dtt_GInfo    = NULL;
            dtt.dtt_Function = STM_COMMAND;
            dtt.dtt_Data     = cmd;
            retval = DoGadgetMethodA ((struct Gadget *)cl->cl_DataObject, cl->cl_Window, NULL, &dtt);
        }
d370 1
a370 1
VOID OpenNewData (struct AmigaGuideLib *ag, struct Client *cl, ULONG stype)
d373 6
a378 1
    ULONG retval = 0L;
d383 2
a384 2
	dtt.MethodID     = DTM_TRIGGER;
	dtt.dtt_GInfo    = NULL;
d386 1
a386 1
	dtt.dtt_Data     = cl->cl_TempBuffer;
d388 1
a388 1
	retval = DoGadgetMethodA ((struct Gadget *)cl->cl_DataObject, cl->cl_Window, NULL, &dtt);
d393 4
a396 2
        if (cl->cl_DataObject)
        {
d404 2
a405 3
            DoMethod ((Object *) cl->cl_WinObject, WOM_REMVIEW, (ULONG) cl->cl_DataObject);
            DisposeDTObject (cl->cl_DataObject);
        }
d408 5
a412 4
					 GA_Immediate, TRUE,
					 GA_RelVerify, TRUE,
					 DTA_TextAttr, (ULONG)&cl->cl_TAttr,
					 TAG_DONE))
d415 1
d419 30
a448 1
	    /* Unable to open object!!! */
d451 1
d456 39
a494 1
void HandleEvents (struct AmigaGuideLib *ag, struct Client *cl)
a496 1
    struct AmigaGuideMsg *agm;
d500 1
d559 1
a559 1
		strcpy (cl->cl_WorkText, ARG0 (rmsg) );
d570 1
a570 27
	    while (agm = (struct AmigaGuideMsg *) GetMsg (cl->cl_ChildPort))
	    {
		if (agm->agm_Msg.mn_Node.ln_Type == NT_MESSAGE)
		{
		    switch (agm->agm_Type)
		    {
			case ShutdownToolID:
			    cl->cl_Going = FALSE;
			    die = TRUE;
			    break;

			case ToolCmdID:
			    strcpy (cl->cl_WorkText, agm->agm_Data);
			    ProcessStrCommand (ag, cl, cl->cl_WorkText);
			    break;

			default:
			    break;
		    }
		    ReplyMsg ((struct Message *) agm);
		}
		else if (agm->agm_Msg.mn_Node.ln_Type == NT_REPLYMSG)
		{
		    /* Return the message to the pool */
		    FreePVec (ag, ag->ag_MemoryPool, agm);
		}
	    }
d589 7
a595 1
		    OpenNewData (ag, cl, DTST_FILE);
d630 1
a630 1
			switch (((struct Gadget *)imsg->IAddress)->GadgetID)
d664 1
a664 1
		    DK (kprintf ("raw %ld\n", (LONG)imsg->Code));
d667 1
a667 1
			/* Shift Tab */
d673 1
a673 1
			/* Up Arrow */
d683 1
a683 1
			/* Down Arrow */
d693 1
a693 1
			/* Right Arrow */
d703 1
a703 1
			/* Left Arrow */
d716 1
a716 1
		    DK (kprintf ("van %ld\n", (LONG)imsg->Code));
d719 1
a719 1
			/* Backspace */
d724 1
a724 1
			/* Tab */
d733 1
a733 1
			/* Return */
d738 1
a738 1
			/* Space */
d757 1
a757 1
			case  27:
d764 3
a766 1
		    if (tag = FindTagItem (DTA_PrinterStatus, (struct TagItem *) imsg->IAddress))
d768 6
d782 1
a782 1
		    if (tag = FindTagItem (DTA_Busy, (struct TagItem *) imsg->IAddress))
d806 1
a806 1
VOID Navigate (struct AmigaGuideLib *ag, struct Client *cl, LONG cmd, BOOL needvisual)
d814 6
a819 6
		    DTA_TopVert,	&topv,
		    DTA_VisibleVert,	&visv,
		    DTA_TotalVert,	&totv,
		    DTA_TopHoriz,	&toph,
		    DTA_VisibleHoriz,	&vish,
		    DTA_TotalHoriz,	&toth,
d908 8
a915 20
        if (topv < 0)
            topv = 0;
        if (toph < 0)
            toph = 0;
        if (topv > totv - visv)
            topv = totv - visv;
        if (toph > toth - vish)
            toph = toth - vish;

        if ((topv != otopv) || (toph != otoph))
        {
            DB (kprintf ("topv=%ld, toph=%ld\n", topv, toph));
            setdtattrs (ag, cl->cl_DataObject, cl->cl_Window,
                        DTA_TopVert,	topv,
                        DTA_TopHoriz,	toph,
			DTA_Sync,	TRUE,
                        TAG_DONE);
        }
    }
}
d917 12
d931 1
a931 1
void ProcessCommand (struct AmigaGuideLib *ag, struct Client *cl, ULONG id, struct IntuiMessage *imsg)
d935 1
d937 1
a937 1
    ULONG width, height;
d955 7
d993 9
d1003 12
a1014 2
	    GetAttr (DTA_NominalHoriz, cl->cl_DataObject, &width);
	    GetAttr (DTA_NominalVert, cl->cl_DataObject, &height);
d1016 1
a1016 4
		width = win->Width;
	    else
		width += 4 + win->BorderLeft + win->BorderRight;

d1018 12
a1029 5
		height = win->Height;
	    else
		height += 2 + win->BorderTop + win->BorderBottom + cl->cl_TAttr.ta_YSize + 6;

	    ChangeWindowBox (win, win->LeftEdge, win->TopEdge, width, height);
d1036 3
d1043 1
a1043 1
VOID AboutObject (struct AmigaGuideLib *ag, struct Client *cl)
d1048 1
a1048 1
    getdtattrs (ag, cl->cl_DataObject, DTA_DataType, (ULONG)&dtn, TAG_DONE);
d1050 4
a1053 4
    es.es_StructSize   = sizeof (struct EasyStruct);
    es.es_Flags        = 0;
    es.es_Title        = GetAmigaGuideStringLVO (ag, TITLE_AMIGAGUIDE);
    es.es_TextFormat   = "AmigaGuide %ld.%ld (%s)\nWritten by David N. Junod\n\nContents Type: %s %s";
@


39.2
log
@added keyboard shortcuts
@
text
@a242 1
	SaveSnapShot (ag, cl);
d867 4
@


39.1
log
@*** empty log message ***
@
text
@d17 1
d540 52
d593 1
d596 3
a598 3
			case 'q':
			case 'Q':
			    cl->cl_Going = FALSE;
d601 17
a617 3
			case '/':
			    cl->cl_Trigger.dtt_Function = STM_RETRACE;
			    DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, &cl->cl_Trigger);
d620 2
a621 3
			case 9:
			    cl->cl_Trigger.dtt_Function = STM_ACTIVATE_FIELD;
			    DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, &cl->cl_Trigger);
d625 1
a625 2
			    cl->cl_Trigger.dtt_Function = STM_BROWSE_PREV;
			    DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, &cl->cl_Trigger);
d629 1
a629 2
			    cl->cl_Trigger.dtt_Function = STM_BROWSE_NEXT;
			    DoDTMethodA (cl->cl_DataObject, cl->cl_Window, NULL, &cl->cl_Trigger);
d631 6
d669 126
@


39.0
log
@initial RCS
@
text
@d7 1
d16 1
d71 1
d84 2
a230 1
	AddStandardMenu (ag, cl);
a240 1
	FreeStandardMenu (ag, cl);
d302 48
d362 1
d388 6
d395 12
a406 1
	sigr = Wait (siga | sigc | sigw | sigp);
d471 1
a471 25
		    sprintf (cl->cl_WorkText, "LINK \"%s/Main\"", cl->cl_NameBuffer);
		    if (!ProcessStrCommand (ag, cl, cl->cl_WorkText))
		    {
			if (cl->cl_DataObject)
			{
			    SetAPen (cl->cl_Window->RPort, 0);
			    RectFill (cl->cl_Window->RPort,
				      cl->cl_Window->BorderLeft,
				      cl->cl_Window->BorderTop + cl->cl_TAttr.ta_YSize + 6,
				      cl->cl_Window->Width - cl->cl_Window->BorderRight - 1,
				      cl->cl_Window->Height - cl->cl_Window->BorderBottom - 1);

			    DoMethod (cl->cl_WinObject, WOM_REMVIEW, (ULONG) cl->cl_DataObject);
			    DisposeDTObject (cl->cl_DataObject);
			}

			if (cl->cl_DataObject = newdtobject (ag, cl->cl_NameBuffer,
							 GA_Immediate, TRUE,
							 GA_RelVerify, TRUE,
							 DTA_TextAttr, (ULONG)&cl->cl_TAttr,
							 TAG_DONE))
			{
			    DoMethod (cl->cl_WinObject, WOM_ADDVIEW, (ULONG) cl->cl_DataObject, NULL);
			}
		    }
d572 6
a577 1
			PrintComplete (ag, cl, (LONG) tag->ti_Data);
d619 7
d633 7
d673 18
@
