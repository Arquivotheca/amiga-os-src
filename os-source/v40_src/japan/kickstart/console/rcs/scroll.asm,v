head     36.45;
branch   ;
access   ;
symbols  V39_4:36.41 V37_157:36.41 V37_149:36.41 V37_136:36.40 V37_133:36.40 V37_110:36.38 V37_98:36.37 V37_85:36.37 V37_63:36.36 V37_36:36.35 V37_15:36.35 V37_10:36.34 V37_7:36.34 V37_2:36.34 V36_558:36.34 V36_554:36.33 V36_552:36.33 V36_549:36.32 V36_548:36.32 V36_547:36.32 V36_546:36.32 V36_545:36.32 V36_544:36.32 V36_543:36.32 V36_542:36.32 V36_540:36.31 V36_539:36.31 V36_538:36.31 V36_537:36.30 V36_536:36.29 V36_529:36.27 V36_527:36.26 V36_525:36.26 V36_524:36.26 V36_523:36.26 V36_522:36.26 V36_521:36.26 V36_520:36.26 V36_519:36.26 V36_518:36.26 V36_495:36.25 V36_491:36.25 V36_486:36.25 V36_482:36.24 V36_476:36.23 V36_471:36.23 V36_465:36.23 V36_463:36.23 V36_461:36.23 V36_460:36.23 V36_453:36.23 V36_447:36.23 V36_442:36.22 V36_429:36.22 V36_423:36.22 V36_413:36.21 V36_394:36.20 V36_387:36.19 V36_382:36.19 V36_381:36.19 V36_379:36.18 V36_373:36.18 V36_367:36.17 V36_361:36.16 V36_359:36.16 V36_357:36.16 V36_353:36.15 V36_346:36.15 V36_343:36.15 V36_338:36.15 V36_332:36.15 V36_327:36.14 V36_321:36.13 V36_319:36.13 V36_318:36.13 V36_316:36.13 V36_313:36.13 V36_311:36.13 V36_310:36.13 V36_300:36.13 V36_299:36.13 V36_297:36.12 V36_295:36.12 V36_278:36.11 V36_274:36.10 V36_221:36.7 V36_205:36.4 V36_171:36.2 V36_167:36.2 V36_165:36.1 V36_153:36.1 V36_146:36.1 V36_140:36.0;
locks    ; strict;
comment  @*   @;


36.45
date     92.03.23.12.45.13;  author darren;  state Exp;
branches ;
next     36.44;

36.44
date     92.03.19.12.53.18;  author darren;  state Exp;
branches ;
next     36.43;

36.43
date     92.03.19.12.50.54;  author darren;  state Exp;
branches ;
next     36.42;

36.42
date     92.03.17.14.28.13;  author darren;  state Exp;
branches ;
next     36.41;

36.41
date     91.05.06.01.08.53;  author darren;  state Exp;
branches ;
next     36.40;

36.40
date     91.04.28.22.18.58;  author darren;  state Exp;
branches ;
next     36.39;

36.39
date     91.04.28.21.51.08;  author darren;  state Exp;
branches ;
next     36.38;

36.38
date     91.04.12.18.37.33;  author darren;  state Exp;
branches ;
next     36.37;

36.37
date     91.03.13.16.45.53;  author darren;  state Exp;
branches ;
next     36.36;

36.36
date     91.02.22.14.21.35;  author darren;  state Exp;
branches ;
next     36.35;

36.35
date     91.01.23.16.20.30;  author darren;  state Exp;
branches ;
next     36.34;

36.34
date     91.01.03.18.52.18;  author darren;  state Exp;
branches ;
next     36.33;

36.33
date     90.12.13.19.03.19;  author darren;  state Exp;
branches ;
next     36.32;

36.32
date     90.11.12.17.38.04;  author darren;  state Exp;
branches ;
next     36.31;

36.31
date     90.11.06.11.19.38;  author darren;  state Exp;
branches ;
next     36.30;

36.30
date     90.11.05.17.46.02;  author darren;  state Exp;
branches ;
next     36.29;

36.29
date     90.11.02.08.02.11;  author darren;  state Exp;
branches ;
next     36.28;

36.28
date     90.11.01.11.23.07;  author darren;  state Exp;
branches ;
next     36.27;

36.27
date     90.10.15.16.00.34;  author darren;  state Exp;
branches ;
next     36.26;

36.26
date     90.06.07.13.58.44;  author kodiak;  state Exp;
branches ;
next     36.25;

36.25
date     90.05.25.16.14.26;  author kodiak;  state Exp;
branches ;
next     36.24;

36.24
date     90.05.24.17.35.16;  author kodiak;  state Exp;
branches ;
next     36.23;

36.23
date     90.04.25.17.33.08;  author kodiak;  state Exp;
branches ;
next     36.22;

36.22
date     90.04.17.11.48.49;  author kodiak;  state Exp;
branches ;
next     36.21;

36.21
date     90.04.13.13.32.48;  author kodiak;  state Exp;
branches ;
next     36.20;

36.20
date     90.04.12.17.06.21;  author kodiak;  state Exp;
branches ;
next     36.19;

36.19
date     90.04.02.10.47.33;  author kodiak;  state Exp;
branches ;
next     36.18;

36.18
date     90.03.03.14.55.49;  author kodiak;  state Exp;
branches ;
next     36.17;

36.17
date     90.03.02.16.22.55;  author kodiak;  state Exp;
branches ;
next     36.16;

36.16
date     90.03.01.07.17.13;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     90.01.30.16.42.26;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     90.01.29.10.39.05;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     89.12.14.17.03.32;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     89.12.08.17.52.55;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     89.12.07.15.51.28;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     89.12.04.22.55.38;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     89.12.03.16.36.25;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     89.12.02.11.37.14;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     89.11.07.12.59.47;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     89.11.06.17.23.59;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.11.06.14.19.09;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     89.11.04.17.12.02;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     89.11.04.16.04.32;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     89.09.11.12.59.33;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     89.07.07.13.27.21;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     89.07.05.15.23.08;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


36.45
log
@Just use scroll mask for scrolling.  MinMask is calculated into
ScrollMask at SGR time; more efficient, and works as intended.
@
text
@**
**	$Id: scroll.asm,v 36.44 92/03/19 12:53:18 darren Exp Locker: darren $
**
**      scroll display and character map
**
**      (C) Copyright 1989 Commodore-Amiga, Inc.
**          All Rights Reserved
**
	SECTION	console

**	Includes

	INCLUDE	"cddata.i"

	INCLUDE "debug.i"

**	Exports

	XDEF	PackMap
	XDEF	UnpackMap
	XDEF	InsDelChar
	XDEF	InsDelLine
	XDEF	ScrollYDisplay
	XDEF	ResetBuffer

**	Imports

	XLVO	ScrollRaster		; Graphics
	XLVO	SetBPen			;

	XREF	ClearRaster		; clear.asm
	XREF	RestoreRP


	XREF	CursDisable
	XREF	CursEnable
	XREF	CursUpdate

	XREF	_packSorted
	XREF	_unpackSortedLine


**	Assumptions

	IFNE	cm_BufferYL-cm_BufferXL-2
	FAIL	"cm_BufferXL not before cm_BufferYL: recode"
	ENDC

*------ PackMapLine --------------------------------------------------
*
*   NAME
*	PackMapLine
*
*   SYNOPSIS
*	lineWrap = PackMapLine(consoleUnit, displayLine)
*	D0                     A2           D2
*
*   RESULTS
*	lineWrap - non-zero if lineWrap occurred
*

;
;   d2	displayLine, then cm_BufferWidth
;   d3	buffer X position
;   d4	buffer Y position
;   d5	decrementing display line width
;   d6	IMPLICITNL flag
;
;   a0	incrementing character display line
;   a1	incrementing attribute display line
;   a2	console unit
;   a3	incrementing buffer line array
;   a4	incrementing character buffer
;   a5	incrementing attribute buffer
;
PackMapLine:
		movem.l	d2-d6/a3-a5,-(a7)

		;--	find width of display line
		move.w	cu_CM+cm_DisplayWidth(a2),d5
		cmp.w	cu_DisplayYL(a2),d2
		blt.s	pmlFindDisplay
		bgt.s	pmlPackEmptyLine
		move.w	cu_DisplayXL(a2),d5
		bra.s	pmlFindDisplay
pmlPackEmptyLine:
		moveq	#0,d5
		bra.s	pmlEmptyLine

		;--	find start of display line to pack from
pmlFindDisplay:
		lsl.w	#2,d2
		move.l	cu_CM+cm_AttrDispLines(a2),a0
		move.l	0(a0,d2.w),a0
		move.l	a0,a1
		add.l	cu_CM+cm_AttrToChar(a2),a0
		add.l	a1,a1
pmlEmptyLine:
		move.w	cu_CM+cm_BufferWidth(a2),d2

		;--	    get start of buffer
		movem.w	cu_CM+cm_BufferXL(a2),d3/d4
		move.w	d4,d0
		lsl.w	#2,d0
		move.l	cu_CM+cm_AttrBufLines(a2),a3
		add.w	d0,a3
		move.l	(a3)+,a5

		;--	    check if display line is valid
		tst.w	d5
		beq.s	pmlCheckEmpty		; no display

		;--	    check for IMPLICITNL
		move.w	(a1),d6
		and.w	#CMAF_IMPLICITNL,d6
		bne.s	pmlPackALine

		;--	    check for empty buffer
pmlCheckEmpty
		tst.w	d3
		bne.s	pmlNewBLine
		tst.w	d4
		beq.s	pmlPackALine

		;--	    start new explicit line
pmlNewBLine:
		;--		clear rest of this line in buffer
		add.w	d3,a5
		add.l	a5,a5

		sub.w	d2,d3
		neg.w	d3
		bra.s	pmlnblClearDBF
pmlnblClearLoop:
		clr.w	(a5)+
pmlnblClearDBF:
		dbf	d3,pmlnblClearLoop

		;--		reset line pointers
		addq.w	#1,d4
		cmp.w	cu_CM+cm_BufferHeight(a2),d4
		blt.s	pmlnblNextLine

		bsr.s	scrollBufferUp1		; preserves a0/a1
		subq.l	#4,a3
		subq.w	#1,d4

pmlnblNextLine:
		move.l	(a3)+,a5
		moveq	#0,d3

pmlPackALine:
		add.w	d3,a5
		move.l	a5,a4
		add.l	cu_CM+cm_AttrToChar(a2),a4
		add.l	a5,a5

		bra.s	pmlDBF

		;--	pack
pmlLoop:
		;--	    check for buffer wrap
		cmp.w	d2,d3
		blt.s	pmlCopy

		;--		wrap destination
		addq.w	#1,d4		; bump buffer Y
		;--		check for full buffer
		cmp.w	cu_CM+cm_BufferHeight(a2),d4
		blt.s	pmlWrapNextLine

		bsr.s	scrollBufferUp1		; preserves a0/a1
		subq.l	#4,a3
		subq.w	#1,d4

pmlWrapNextLine:
		move.l	(a3)+,a5
		moveq	#0,d3		; zero buffer X
		move.l	a5,a4
		add.l	cu_CM+cm_AttrToChar(a2),a4
		add.l	a5,a5
		move.w	#CMAF_IMPLICITNL,d6	; set lineWrap


		;--	    copy character and attribute
pmlCopy:
		move.b	(a0)+,d0	; character
		move.w	(a1)+,d1	; attribute
		bpl.s	pmlDone		;   not RENDERED

		addq.w	#1,d3
		move.b	d0,(a4)+	; copy this character
		and.w	#~(CMAF_IMPLICITNL!CMAF_HIGHLIGHT!CMAF_SELECTED),d1
		or.w	d6,d1
		move.w	d1,(a5)+	;   and attribute
		move.w	#CMAF_IMPLICITNL,d6	; set lineWrap

pmlDBF:
		dbf	d5,pmlLoop

pmlDone:
		movem.w	d3/d4,cu_CM+cm_BufferXL(a2)
		movem.l	(a7)+,d2-d6/a3-a5
		rts


;------ scrollBufferUp1 ----------------------------------------------
;
;   a2	console unit
;
;	preserves a0/a1
;
scrollBufferUp1:
		movem.l	a0-a1,-(a7)
		move.l	cu_CM+cm_AttrBufLines(a2),a0
		lea	4(a0),a1
		move.l	(a0),d0
		move.w	cu_CM+cm_BufferHeight(a2),d1
		subq.w	#2,d1
		bmi.s	sbu1Done
sbu1Loop:
		move.l	(a1)+,(a0)+
		dbf	d1,sbu1Loop
		move.l	d0,(a0)+
sbu1Done:
		movem.l	(a7)+,a0-a1
		rts


;------	sortMap ------------------------------------------------------
;
;   d2	map width
;   d3	map current limit (XxxxxxYL)
;   d4	slot 0 offset (address/2)
;   d5	== BufferLines for Buf, == -1 for Disp
;   a3	AttrXxxxLines array base
;
sortMap:
		;-- sort lines in buffer
;   d6	Work (free) memory index
;   d7	Target (next) slot index
		;-- get working store in space between buffer and display
		move.w	d5,d6		; initial free index
		move.w	d3,d7		; decrementing target from limit

		;-- move this target slot to associated memory location
smSortSlotLoop:
		;--	check if target memory already empty
		cmp.w	d7,d6
		beq.s	smTargetReady

		;--	see who is in target memory
		move.w	d7,d1		; construct target memory address/2
		mulu	d2,d1		;
		add.l	d4,d1		;
		move.w	d3,d0		; limit interesting tenants to valid
		move.l	a3,a0
		;--	    find matching entry
smFindTenantLoop:
		cmp.l	(a0)+,d1
		dbeq	d0,smFindTenantLoop
		bne.s	smTargetReady	; tenant is inconsequential

		sub.w	d3,d0		; recover tenant's index
		neg.w	d0		;

		cmp.w	d7,d0		; see if target memory already correct
		beq.s	smSortSlotDBF

		;--	save memory contents in work (free) memory
		move.w	d6,d0		; construct work memory address
		muls	d2,d0		;
		add.l	d4,d0		;
		move.l	d0,-(a0)	; patch slot pointer
		;--	    set source and destination, attr and char
		move.l	d1,a0
		move.l	a0,a1
		add.l	cu_CM+cm_AttrToChar(a2),a0
		add.l	a1,a1
		move.l	d0,a4
		move.l	a4,a5
		add.l	cu_CM+cm_AttrToChar(a2),a4
		add.l	a5,a5
		move.w	d2,d0
		bra.s	smCopyWorkDBF
		;--	    copy tenant in target memory to work memory
smCopyWorkLoop:
		move.b	(a0)+,(a4)+
		move.w	(a1)+,(a5)+
smCopyWorkDBF:
		dbf	d0,smCopyWorkLoop


		;--	copy target to target memory
smTargetReady:
		move.w	d7,d0
		move.w	d7,d1
		lsl.w	#2,d0
		move.l	0(a3,d0.w),a0
		mulu	d2,d1
		add.l	d4,d1

		cmp.l	a0,d1		; check if target already correct
		beq.s	smSortSlotDBF

		;--	    get next work (free) slot index
		move.l	a0,d6
		sub.l	d4,d6
		divs	d2,d6
		;--	    fix up target slot
		move.l	d1,0(a3,d0.w)
		;--	    set source and destination, attr and char
		move.l	a0,a1
		add.l	cu_CM+cm_AttrToChar(a2),a0
		add.l	a1,a1
		move.l	d1,a4
		move.l	d1,a5
		add.l	cu_CM+cm_AttrToChar(a2),a4
		add.l	a5,a5
		move.w	d2,d0
		bra.s	smCopyDBF
		;--	    copy target to target memory
smCopyLoop:
		move.b	(a0)+,(a4)+
		move.w	(a1)+,(a5)+
smCopyDBF:
		dbf	d0,smCopyLoop


smSortSlotDBF:
		dbf	d7,smSortSlotLoop
		rts


*------ ResetBuffer --------------------------------------------------
*
*   NAME
*       ResetBuffer
*
*   SYNOPSIS
*       void ResetBuffer(consoleUnit)
*                        A2
*
*   NOTES
*       This routine is to be called when explicitly clearing
*       BufferXL/YL - e.g., on a FormFeed which clears the display
*       map, and the Buffer map.
*
*       Its been determined that the existing buffer may need to
*       be resorted before clearing BufferXL/YL, which is what this
*       does.
*
*   ASSUMPTIONS
*       The caller has checked to make sure that the console unit
*       has a character map.
*
ResetBuffer:     
		movem.l	d0-d7/a0-a5,-(a7)
		bsr.s	SortBuffer
		clr.l	cu_CM+cm_BufferXL(a2)		; and YL
		movem.l	(a7)+,d0-d7/a0-a5
emptybuffer:
		rts

*------ SortBuffer --------------------------------------------------
*
*   NAME
*       SorttBuffer
*
*   SYNOPSIS
*       void SortBuffer(consoleUnit)
*                        A2
*
*   NOTES
*       Sorts off-screen buffer.
*
*   ASSUMPTIONS
*       The caller has checked to make sure that the console unit
*       has a character map.
*
** Used by PackMap() below and ResetBuffer()

SortBuffer:
		move.w	cu_CM+cm_BufferWidth(a2),d2
		move.l	cu_CM+cm_BufferStart(a2),d4
		move.w	cu_CM+cm_BufferHeight(a2),d5
		move.l	cu_CM+cm_AttrBufLines(a2),a3
		move.l	cu_CM+cm_BufferXL(a2),d3	; test both, get Y
		bne	sortMap				; if already empty
							; nothing to sort
		rts

*------ PackMap ------------------------------------------------------
*
*   NAME
*	PackMap
*
*   SYNOPSIS
*	PackMap(consoleUnit)
*	        A2
*
PackMap:
		movem.l	d2-d7/a3-a5,-(a7)

;   d2	map width
;   d3	map current limit (XxxxxxYL)
;   d4	slot 0 offset (address/2)
;   d5	== BufferHeight for Buf, == -1 for Disp
;   a3	AttrXxxxLines array base
		;-- sort lines in buffer
		bsr.s	SortBuffer

		;-- sort lines in display
pmSortDisplay:
		move.w	cu_CM+cm_DisplayWidth(a2),d2
		move.l	cu_DisplayXL(a2),d3		; test both, get Y
		beq	pmDone
		move.l	cu_CM+cm_DisplayStart(a2),d4
		moveq	#-1,d5
		move.l	cu_CM+cm_AttrDispLines(a2),a3
		bsr	sortMap


		moveq	#0,d0
		move.b	cu_BgColor(a2),d0
		lsl.w	#CMAS_BGPEN,d0
		or.w	#CMAF_RENDERED,d0
		move.l	d0,-(a7)
		move.w	cu_YCP(a2),d0
		move.l	d0,-(a7)
		move.w	cu_XCP(a2),d0
		move.l	d0,-(a7)
		move.w	cu_DisplayYL(a2),d0
		move.l	d0,-(a7)
		move.w	cu_DisplayXL(a2),d0
		move.l	d0,-(a7)
		pea	cu_CM(a2)
		bsr	_packSorted
		lea	24(a7),a7

		;	    (packSorted clears selection as side effect)
		bclr	#CUB_SELECTED,cu_Flags(a2)
		beq.s	pmScrollBuffer

		and.b	#CDS_SELECTMASK,cd_SelectFlags(a6)
		clr.l	cd_SelectedUnit(a6)
		bclr	#CUB_CURSSELECT,cu_CursorFlags(a2)

		;--	    scroll buffer
pmScrollBuffer:
		move.w	cu_CM+cm_BufferYL(a2),d0
		move.w	cu_CM+cm_BufferLines(a2),d1
		sub.w	d1,d0
		blt.s	pmDone

		;--	    scroll up buffer
		addq.w	#1,d0
		sub.w	d0,cu_CM+cm_BufferYL(a2)
		add.w	d0,d1
		move.w	cu_CM+cm_BufferWidth(a2),d2
		mulu	d2,d0
		mulu	d2,d1
		move.l	cu_CM+cm_BufferStart(a2),a0
		move.l	a0,a1
		add.l	cu_CM+cm_AttrToChar(a2),a0
		add.l	a1,a1

;-- old scrollMap in sorted environment
;
;	d0	character increment to scroll (+: up,  -: down)
;	d1	scroll field character size
;

		cmp.l	d0,d1		; scroll increment vs. field size
		ble.s	pmUpClrAll	; clear everything (?) ok, but I fail
					; to see how we ever fail this test.
					; Looks like hold-over code; I'll leave
					; it alone for now. -darren-
					;
					; we get here when the packed map
					; overflows into our work area
					; (there is an extra 50% of buffer
					; allocated at map alloc time)
					;
					; scroll up packed buffer, and
					; throw away what we can't use
				
		lea	0(a0,d0.l),a3	; get source as per increment
		add.l	d0,d0		;
		lea	0(a1,d0.l),a4	;
		lsr.l	#1,d0		;
		sub.l	d0,d1		; get characters to copy

		move.l	d0,d2
		swap	d2		; for double DBF loop

		move.l	d1,d3
		swap	d3		; for double DBF loop

		bra.s	pmUpCopyDBF
pmUpCopyLoop:
		move.b	(a3)+,(a0)+	; copy character
		move.w	(a4)+,(a1)+	; copy attribute
pmUpCopyDBF:
		dbf	d1,pmUpCopyLoop
		dbf	d3,pmUpCopyLoop
		bra.s	pmUpClrDBF
pmUpClrLoop:
		clr.w	(a1)+		; empty attribute
					; clear rest of attribute buffer
pmUpClrDBF:
		dbf	d0,pmUpClrLoop
		dbf	d2,pmUpClrLoop
		bra.s	pmDone

pmUpClrAll:
		move.l	d1,d0		; clear entire scroll field

		move.l	d0,d2
		swap	d2		; for double DBF loop

		bra.s	pmUpClrDBF

pmDone:
		movem.l	(a7)+,d2-d7/a3-a5
		rts



*------ UnpackMap ----------------------------------------------------
*
*   NAME
*	UnpackMap
*
*   SYNOPSIS
*	UnpackMap(consoleUnit)
*	          A2
*
UnpackMap:
		movem.l	d2-d3,-(a7)
		;-- set Display variables
		movem.w	cu_XMax(a2),d0/d1		; and cu_YMax
		addq.w	#1,d0
		addq.w	#1,d1
		movem.w	d0/d1,cu_CM+cm_DisplayWidth(a2)	; and cm_DisplayHeight
		;-- find display memory store
		move.l	d0,d2				; save DisplayWidth
		mulu	d1,d0
		sub.l	cu_CM+cm_AllocSize(a2),d0
		neg.l	d0				; first CharDisp index
		add.l	cu_CM+cm_AllocBuffer(a2),d0	; first CharDisp byte
		sub.l	cu_CM+cm_AttrToChar(a2),d0	; first AttrDisp byte/2
		move.l	d0,d3				; save it
		move.l	d0,cu_CM+cm_DisplayStart(a2)	;
		;--	fill AttrDispLines
		move.l	cu_CM+cm_AttrDispLines(a2),a0
		bra.s	umAttrDispLinesDBF
umAttrDispLinesLoop:
		move.l	d0,(a0)+
		add.l	d2,d0
umAttrDispLinesDBF:
		dbf	d1,umAttrDispLinesLoop

		sub.l	cu_CM+cm_BufferStart(a2),d3
		divu	cu_CM+cm_BufferWidth(a2),d3
		subq	#1,d3			; spare used by PackMap sort
		cmp.w	cu_CM+cm_BufferLines(a2),d3
		ble.s	umBufferHeightOK
		move.w	cu_CM+cm_BufferLines(a2),d3
umBufferHeightOK:
		move.w	d3,cu_CM+cm_BufferHeight(a2)

		;--	test for empty buffer
		tst.l	cu_CM+cm_BufferXL(a2)	; and BufferYL
		beq.s	umEmpty

		move.w	cu_CM+cm_DisplayHeight(a2),d2
		clr.w	cu_DisplayXL(a2)
		move.w	d2,d0
		subq.w	#1,d0
		move.w	d0,cu_DisplayYL(a2)
		moveq	#0,d3
		move.w	#CMAF_CURSOR,-(a7)	; cursorMask argument
		pea	cu_YCP(a2)
		pea	cu_XCP(a2)
		pea	8(a7)
		pea	cu_DisplayYL(a2)
		pea	cu_DisplayXL(a2)
		bra.s	umDBF

		;--	unpack each line
umLoop:
		move.l	d2,-(a7)
		pea	cu_CM(a2)
		bsr	_unpackSortedLine
		addq.l	#8,a7
		add.w	d0,d3
umDBF:
		dbf	d2,umLoop

		lea	22(a7),a7

		;--	handle partial unpacking
		move.w	d3,d0
		beq.s	umCursUpdate

		moveq	#0,d1
		bsr.s	scrollDisp

		sub.w	d3,cu_YCP(a2)
		sub.w	d3,cu_DisplayYL(a2)
umCursUpdate:
		bsr	CursUpdate

		movem.l	(a7)+,d2-d3
		rts

umEmpty:
		clr.l	cu_XCP(a2)		; and YCP
		clr.l	cu_DisplayXL(a2)	; and DisplayYL
		bra.s	umCursUpdate


;------ scrollDisp ----------------------------------------------------
;
;   d0	scroll amount (+ up, - down)
;   d1	scroll origin
;   a2	console unit
;

;   d0	source offset
;   d1	destination offset
;   d2	offset limit
;   d3	decrementing scroll height
;   d4	cache
;   d5  shift increment
;   a0	shifted cm_AttrDispLines origin
;   a1	address temporary
;   a4	address of slot now in cache

scrollDisp:
		movem.l	d2-d5/a4,-(a7)
		move.w	cu_CM+cm_DisplayHeight(a2),d3
		sub.w	d1,d3		; scroll height
		move.w	d3,d2
		lsl.w	#2,d2		; offset limit
		lsl.w	#2,d1
		move.l	cu_CM+cm_AttrDispLines(a2),a0
		add.w	d1,a0		; shifted cm_AttrDispLines origin

		lsl.w	#2,d0		; first source offset
		move.w	d0,d5		;   and shift increment
		moveq	#0,d1		; first destination offset
		move.l	a0,a4
		move.l	(a4),d4		; cache first destination
		tst.w	d0
		bra.s	sdBound
sdLoop:
		lea	0(a0,d0.w),a1		; address of source
		cmp.l	a1,a4			; check if source is in cache
		bne.s	sdStandard

		;--	end of cycle, bump to next cycle
		move.l	d4,0(a0,d1.w)		; copy cache to dest
		addq.w	#4,d0			; bump to next cycle
		cmp.w	d2,d0			; limit source
		blt.s	sdNextCycleDest		;
		sub.w	d2,d0			;   adjust to within limit
sdNextCycleDest:
		lea	0(a0,d0.w),a4
		move.l	(a4),d4			; cache destination
		bra.s	sdNextSource

		;--	standard cycle
sdStandard:
		move.l	(a1),0(a0,d1.w)		; copy source to dest
sdNextSource:
		move.w	d0,d1			; old source is new dest
		add.w	d5,d0			; bump source by increment
sdBound:
		bpl.s	sdBoundUpper
		add.w	d2,d0
		bra.s	sdDBF
sdBoundUpper:
		cmp.w	d2,d0			; limit source
		blt.s	sdDBF			;
		sub.w	d2,d0			;   adjust to within limit
sdDBF:
		dbf	d3,sdLoop

sdDone:
		movem.l	(a7)+,d2-d5/a4
		rts


*------ ScrollYDisplay -----------------------------------------------
*
*   NAME
*	ScrollYDisplay - convert character units to raster units and scroll
*
*   SYNOPSIS
*	ScrollYDisplay(consoleUnit, increment)
*	               a2           d0
*
*---------------------------------------------------------------------
ScrollYDisplay:
		movem.l	d2-d5/a4-a5,-(a7)
		tst.l	cu_CM+cm_AllocSize(a2)
		beq.s	sydSR

		move.w	d0,d5		; save increment
		;-- find scroll direction
		bpl.s	sydUp
		beq.s	sydDone

		;--	scroll down
		;--	    scroll off bottom of display
		moveq	#0,d1
		bsr	insDelLine
		bra.s	sydDone

		;--	scroll up
sydUp:
		;--	    gobble top into buffer
		move.w	d5,d3		; for <increment> lines
		moveq	#0,d2		; from top of display
sydUpLineLoop:

	PRINTF	DBG_FLOW,<'D2=%lx'>,D2

		bsr	PackMapLine
		addq.w	#1,d2
		cmp.w	d2,d3
		bgt.s	sydUpLineLoop

		move.w	d5,d0
sydSR:
		moveq	#0,d1
		bsr	insDelLine

sydDone:
		movem.l	(a7)+,d2-d5/a4-a5
		rts


*------ InsDelChar ---------------------------------------------------
*
*   NAME
*	InsDelChar - insert or delete characters on line
*
*   SYNOPSIS
*	InsDelChar(consoleUnit, increment)
*	           a2           d0
*
*---------------------------------------------------------------------
InsDelChar:
		movem.l	d2-d6/a4-a5,-(a7)

		;-- check for degenerate case
		tst.w	d0
		beq	iclDone

		;-- check whether any chars are displayed here
		move.w	cu_DisplayYL(a2),d3
		move.w	cu_DisplayXL(a2),d2
		bne.s	iclHaveDYL
		move.w	cu_XMax(a2),d2
		addq.w	#1,d2
		subq.w	#1,d3
iclHaveDYL:
		move.w	d2,d6			; cache massaged XL

		movem.w	cu_XCP(a2),d4/d5
		cmp.w	d5,d3

		blt	iclDone			; SIGNED compare!!!
						; e.g., d3 = -1
		bne.s	iclScroll

		;-- this ins/del is on the last display line
		sub.w	d4,d2
		ble	iclDone

		;--     set the new DisplayYL (could be less than
		;--	what it was (e.g., if XL was == 0, YL may be
		;--	on previous line - calculated upon entry of
		;--	subroutine)
		;--
		;--	We have determined that we are inserting, or
		;--	deleting on the last line of the display (last
		;--	valid line in map, but note that we came up
		;--	with a massaged value for DisplaYL above)

		move.w	d3,cu_DisplayYL(a2)

		;-- check whether scrolling or clearing is appropriate
		tst.w	d0			; check increment
		bpl.s	iclDelete


		;--	check if clearing instead of inserting is OK
		sub.w	cu_XMax(a2),d4		; XCP - XMax
		cmp.w	d0,d4
		bgt	iclClear		; clear d2 chars from CP

		;--	update DisplayXL
		move.w	d6,d1			; DisplayXL calculated
		sub.w	d0,d1			; add increment
		cmp.w	cu_XMax(a2),d1
		ble.s	icliSetDisplayXL
		move.w	d6,d1
icliSetDisplayXL:
		move.w	d1,cu_DisplayXL(a2)
		move.w	d1,d4

iclInsertScroll:
		;--	check if character map insertion is needed
		tst.l	cu_CM+cm_AllocSize(a2)
		beq	iclSR

		movem.w	cu_XCP(a2),d2/d3	; and cu_YCP
		lsl.w	#2,d3
		move.l	cu_CM+cm_AttrDispLines(a2),a0
		move.l	0(a0,d3.w),a0
		add.w	d4,a0			; new DisplayXL or DisplayWidth
		move.l	a0,a1
		add.l	cu_CM+cm_AttrToChar(a2),a0
		move.l	a0,a4
		move.l	a1,a5
		add.l	a1,a1
		add.w	d0,a4
		add.w	d0,a5
		add.l	a5,a5
		sub.w	d2,d4
		add.w	d0,d4
		bra.s	icliShiftDBF
		;--	    shift characters to the right
icliShiftLoop:
		move.b	-(a4),-(a0)
		move.w	-(a5),-(a1)
icliShiftDBF:
		dbf	d4,icliShiftLoop

		move.w	d0,d4
		neg.w	d4
		bra.s	icliFillDBF
		;--	    fill space with blanks
icliFillLoop:
		move.b	#' ',-(a0)
		move.w	#CMAF_RENDERED,-(a1)
icliFillDBF:
		dbf	d4,icliFillLoop
		bra.s	iclSR


iclScroll:
		move.w	cu_CM+cm_DisplayWidth(a2),d4
		tst.w	d0			; check increment
		bmi	iclInsertScroll
		bra.s	iclDeleteScroll


		;--	check if clearing instead of deleting is OK
iclDelete:


		cmp.w	d0,d2
		ble.s	iclClear		; clear d2 chars from CP

		;--	update DisplayXL
		move.w	d6,d4			; DisplayXL (massaged)

		clr.w	cu_DisplayXL(a2)	; 0 minimum

		sub.w	d0,d4
		bmi.s	iclDelMin

		move.w	d4,cu_DisplayXL(a2)
iclDelMin:
		add.w	d0,d4			; negative cond. caught below

iclDeleteScroll:
		;--	check if character map deletion is needed
		tst.l	cu_CM+cm_AllocSize(a2)
		beq.s	iclSR

		movem.w	cu_XCP(a2),d2/d3	; and cu_YCP
		lsl.w	#2,d3
		move.l	cu_CM+cm_AttrDispLines(a2),a0
		move.l	0(a0,d3.w),a0
		add.w	d2,a0			; XCP
		move.l	a0,a1
		add.l	cu_CM+cm_AttrToChar(a2),a0
		move.l	a0,a4
		move.l	a1,a5
		add.l	a1,a1
		add.w	d0,a4			; XCP + increment
		add.w	d0,a5
		add.l	a5,a5

		sub.w	d2,d4			; old DisplayXL or DisplayWidth
		sub.w	d0,d4			;   minus XCP minus increment

		tst.w	d4
		bmi.s	icldShiftNone

		bra.s	icldShiftDBF
		;--	    shift characters to the left
icldShiftLoop:
		move.b	(a4)+,(a0)+
		move.w	(a5)+,(a1)+
icldShiftDBF:
		dbf	d4,icldShiftLoop

icldShiftNone:
		move.w	d0,d4			; get size of cleared space
		bra.s	icldClearDBF
		;--	    clear vacated cells
icldClearLoop:
		clr.w	(a1)+
icldClearDBF:
		dbf	d4,icldClearLoop


iclSR:
		bsr	scrollChar

iclDone:
		movem.l	(a7)+,d2-d6/a4-a5
		rts


iclClear:
		move.w	cu_XCP(a2),d0
		mulu	cu_XRSize(a2),d0
		add.w	cu_XROrigin(a2),d0

		move.w	cu_YCP(a2),d1
		mulu	cu_YRSize(a2),d1
		add.w	cu_YROrigin(a2),d1

		mulu	cu_XRSize(a2),d2
		add.w	d0,d2
		subq.w	#1,d2

		move.w	d1,d3
		add.w	cu_YRSize(a2),d3
		subq.w	#1,d3

		bsr	CursDisable
		bsr	ClearRaster
		bsr	CursEnable

		;--	set the new DisplayXL to the CP on this line
		move.w	cu_XCP(a2),cu_DisplayXL(a2)
		bra.s	iclDone


*------ InsDelLine ---------------------------------------------------
*
*   NAME
*	InsDelLine - insert or delete lines in a display
*
*   SYNOPSIS
*	InsDelLine(consoleUnit, increment)
*	           a2           d0
*	insDelLine(consoleUnit, increment, ycp)
*	           a2           d0         d1
*
*---------------------------------------------------------------------
;
;   d0	increment (positive is delete)
;   d1	number of lines actually displayed after insdel point (inclusive)
;   d2	cu_YCP, insdel point
;   d3	temp, then increment
;   d4	temp
;   d5	temp
;
InsDelLine:
		move.w	cu_YCP(a2),d1

insDelLine:
		movem.l	d2-d5,-(a7)
		;-- check for degenerate case
		tst.w	d0
		beq	idlDone

		move.w	d1,d2

		;-- check whether any lines are displayed here
		move.w	cu_DisplayYL(a2),d1
		tst.w	cu_DisplayXL(a2)
		bne.s	idlHaveDYL
		subq.w	#1,d1
idlHaveDYL:
		sub.w	d2,d1
		blt	idlDone
		addq.w	#1,d1			; displayed lines: 1..n

		;-- check whether scrolling or clearing is appropriate
		tst.w	d0			; check increment
		bpl	idlDelete

		;--	check if clearing instead of inserting is OK
		move.w	d2,d3
		sub.w	cu_YMax(a2),d3		; YCP - YMax
		cmp.w	d0,d3			; -insert ? -remaining_space
		bgt	idlClear		; clear d1 lines at CP

		;--	set the new Display.L
		move.w	cu_DisplayYL(a2),d4
		sub.w	d0,d4			; add increment
		cmp.w	cu_YMax(a2),d4
		ble.s	idliSetDisplayYL
		;--	     bound DisplayYL, find DisplayXL if mapped
		move.w	d4,d3
		move.w	cu_YMax(a2),d4
		move.w	cu_XMax(a2),d5
		addq.w	#1,d5
		tst.l	cu_CM+cm_AllocSize(a2)
		beq.s	idliSetDisplayXL

		;--	     find last char in line that will be the last line
		sub.w	d4,d3
		neg.w	d3
		add.w	d4,d3
		lsl.w	#2,d3
		move.l	cu_CM+cm_AttrDispLines(a2),a0
		move.l	0(a0,d3.w),a0
		add.w	d5,a0
		add.l	a0,a0
idliFindDisplayXLLoop:
		tst.w	-(a0)
		dbmi	d5,idliFindDisplayXLLoop
		bmi.s	idliSetDisplayXL
		moveq	#0,d5

idliSetDisplayXL:
		move.w	d5,cu_DisplayXL(a2)

idliSetDisplayYL:
		move.w	d4,cu_DisplayYL(a2)

		;--	check if character map insertion is needed
		tst.l	cu_CM+cm_AllocSize(a2)
		beq.s	idlSR

		move.w	d0,d3
		move.w	d2,d1
		bsr	scrollDisp

		;--	    fill empty space with empty lines
		move.w	d2,d4
		lsl.w	#2,d4
		move.l	cu_CM+cm_AttrDispLines(a2),a0
		add.w	d4,a0
		move.w	d3,d5
		neg.w	d5
		bra.s	idliFillYDBF

idliFillYLoop:
		move.l	(a0)+,a1
		add.l	a1,a1
		move.w	cu_CM+cm_DisplayWidth(a2),d4
		bra.s	idliFillXDBF

idliFillXLoop:
		clr.w	(a1)+
idliFillXDBF:
		dbf	d4,idliFillXLoop

idliFillYDBF:
		dbf	d5,idliFillYLoop

		bra.s	idlSRD3

idlDelete:
		;--	check if clearing instead of deleting is OK
		cmp.w	d0,d1
		ble.s	idlClear		; clear d1 lines at CP

		;--	set the new Display.L
		sub.w	d0,cu_DisplayYL(a2)

		;--	check if character map deletion is needed
		tst.l	cu_CM+cm_AllocSize(a2)
		beq.s	idlSR

		move.w	d0,d3
		move.w	d2,d1
		bsr	scrollDisp

idlSRD3:
		move.w	d3,d0

idlSR:
		bsr.s	scrollLine

idlDone:
		movem.l	(a7)+,d2-d5
		rts


idlClear:
		;--	set the new Display.L to the beginning of this line
		clr.w	cu_DisplayXL(a2)
		move.w	d2,cu_DisplayYL(a2)

		;--	clear the rectangle
		mulu	cu_YRSize(a2),d1
		move.w	d1,d3

		move.w	d2,d1
		mulu	cu_YRSize(a2),d1
		add.w	cu_YROrigin(a2),d1
		add.w	d1,d3
		subq.w	#1,d3

		move.w	cu_XROrigin(a2),d0
		move.w	cu_XRExtant(a2),d2
		
		bsr	CursDisable
		bsr	ClearRaster
		bsr	CursEnable

		bra.s	idlDone


;------ raster scroll routines ---------------------------------------
;
;   INPUT
;	d0	delta
;	d2	scrollLine YCP
;	a2	unit
;	a6	device
;   MODIFIED
;	d0-d5/a0-a1
;
scrollLine:
		move.w	d2,d3
		mulu	cu_YRSize(a2),d3
		add.w	cu_YROrigin(a2),d3
		bra.s	scrollSRLine
		
scrollChar:
		muls	cu_XRSize(a2),d0
		beq.s	scrollRts
		moveq	#0,d1
		move.w	cu_XCP(a2),d2
		mulu	cu_XRSize(a2),d2
		add.w	cu_XROrigin(a2),d2
		move.w	cu_YCP(a2),d3
		mulu	cu_YRSize(a2),d3
		add.w	cu_YROrigin(a2),d3
		move.l	d3,d5
		add.w	cu_YRSize(a2),d5
		subq.w	#1,d5
		bra.s	scrollSRChar

scrollRts:
		rts

scrollDisplay:
		move.w	cu_YROrigin(a2),d3
		ext.l	d3

scrollSRLine:
		move.w	d0,d1
		beq.s	scrollRts
		moveq	#0,d0
		muls	cu_YRSize(a2),d1
		move.w	cu_XROrigin(a2),d2
		ext.l	d2
		move.w	cu_YRExtant(a2),d5
		ext.l	d5

scrollSRChar:
		btst	#CUB_TOOSMALL,cu_Flags(a2)
		bne.s	scrollRts
		move.w	cu_XRExtant(a2),d4
		ext.l	d4
		bsr	CursDisable
		movem.w	d0/d1,-(a7)		; save rectangle origin
		move.b	cu_BgColor(a2),d0
		lea	cd_RastPort(a6),a1
		LINKGFX SetBPen

		movem.w	(a7)+,d0/d1
		lea	cd_RastPort(a6),a1

		; Fix bug in conceal mode, and avoid cursor
		; droppings.  Conceal mode used to set rp_Mask
		; to 0, so clears/scrolls didn't work at all -
		; real bad since the screen is not synced with
		; the character map.
		;
		; Also optimize scrolling

		move.b	cu_ScrollMask(a2),rp_Mask(a1)
		
		LINKGFX	ScrollRaster

		bsr	RestoreRP
		bra	CursEnable


	END
@


36.44
log
@Oops, forgot to mention change to scroll down.  Use to unpack map
lines to fill in vacated area.  Except this would crash if the
display lines > window lines.  Also is not compatable with smart
refresh windows which dont fill vacated area.  Worse of all, it
didnt even window refresh, which meant you didnt see it fill till
you resized the window, or uncovered the damaga
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.43 92/03/19 12:50:54 darren Exp Locker: darren $
d1188 3
d1196 2
d1199 1
a1199 4
		move.b	cu_MinMask(a2),d0
		or.b	cu_ScrollMask(a2),d0

		move.b	d0,cd_RastPort+rp_Mask(a6)
a1200 2
		movem.w	(a7)+,d0/d1
		lea	cd_RastPort(a6),a1
@


36.43
log
@Now uses optimized scrolling mask, plus a min mask which I
may use later on for compatability with existing software which
uses graphics library functions in console window rendering areas.
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.42 92/03/17 14:28:13 darren Exp Locker: darren $
@


36.42
log
@New code for scrolling text down.  No longer tries to fill in vacated
portion with character map data, hence fixing a possible crashing bug
if UnpackMapLine was called with D2 > cu_YMax.  Also makes behavior
consistent with smart refresh consoles, and it wasn't redrawing the
screen anyway, so you didn't see the unpacked text!  PackMapLine()
no longer dereferences A0,D2.w if D2 is invalid.
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.41 91/05/06 01:08:53 darren Exp Locker: darren $
d1187 12
d1202 1
@


36.41
log
@More code added (needed) to fix bug with resize of HUGE console
windows (more math overflow related problems) - pmScrollBuffer
modified to use LONG math and loops instead of WORD sized math/loops.
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.40 91/04/28 22:18:58 darren Exp Locker: darren $
d88 1
d98 1
a98 1

a528 127
*------ UnpackMapLine ------------------------------------------------
*
*   NAME
*	UnpackMapLine
*
*   SYNOPSIS
*	exhausted = UnpackMapLine(consoleUnit, displayLine)
*	                          A2           D2
*

;   d0	DisplayWidth
;   d1	BufferWidth
;   d2	displayLine, then temp
;   d3	BufferYL
;   a0	decrementing character display line
;   a1	decrementing attribute display line
;   a2	console unit
;   a3	buffer line array
;   a4	character buffer
;   a5	attribute buffer

UnpackMapLine:
		movem.l	d2-d4/a3-a5,-(a7)

		;--	check for degenerate case
		tst.l	cu_CM+cm_BufferXL(a2)	; and cu_CM+cm_BufferYL
		beq	umlExhausted

		;--	get end of display line to fill
		lsl.w	#2,d2
		move.l	cu_CM+cm_AttrDispLines(a2),a0
		move.l	0(a0,d2.w),a0
		move.w	cu_CM+cm_DisplayWidth(a2),d0
		add.w	d0,a0
		move.l	a0,a1
		add.l	cu_CM+cm_AttrToChar(a2),a0
		add.l	a1,a1

		;--	find start of buffer source
		move.w	cu_CM+cm_BufferYL(a2),d1
		lsl.w	#2,d1
		move.l	cu_CM+cm_AttrBufLines(a2),a3
		add.w	d1,a3
		move.w	cu_CM+cm_BufferWidth(a2),d1
		move.l	(a3),a4
		move.l	a4,a5
		add.l	cu_CM+cm_AttrToChar(a2),a4
		add.l	a5,a5

		moveq	#0,d2
		moveq	#0,d3
		move.w	cu_CM+cm_BufferXL(a2),d2
		beq.s	umlClearDBF

		;--	this line non-empty, unpack from it
		divu	d0,d2		; chop buffer line into display sized
		move.l	d2,d3		;   pieces
		swap	d3		; get last character in display line
		tst.w	d3		; check if remainder at boundary
		bne.s	umlHaveRemainder
		move.w	d0,d3
		subq.w	#1,d2
umlHaveRemainder:
		mulu	d0,d2		; get line offset into buffer/new XL
		move.w	d2,cu_CM+cm_BufferXL(a2)

		add.w	d0,d2		; get tail of buffer
		add.w	d2,a4
		add.w	d2,d2
		add.w	d2,a5
		sub.w	d3,d0
		bra.s	umlClearDBF

		;--	clear tail of display line
umlClearLoop:
		subq.l	#1,a0
		clr.w	-(a1)
		subq.l	#1,a4
		subq.l	#2,a5
umlClearDBF:
		dbf	d0,umlClearLoop

		bra.s	umlFillDBF

		;--	fill display from buffer
umlFillLoop:
		move.b	-(a4),-(a0)
		move.w	-(a5),-(a1)
umlFillDBF:
		dbf	d3,umlFillLoop

		;--	check for line exhausted
umlCheckLineExhausted:
		tst.w	cu_CM+cm_BufferXL(a2)
		bne.s	umlDone
		move.w	cu_CM+cm_BufferYL(a2),d2
		beq.s	umlDone

		;--	    this line empty, back up one
		subq.w	#1,d2
		move.w	d2,cu_CM+cm_BufferYL(a2)

		;--	    find last character in prior line
		move.l	-(a3),a5
		add.w	d1,a5
		add.l	a5,a5

umlFindXLLoop:
		tst.w	-(a5)		; check RENDERED
		bmi.s	umlFoundXL
		subq.w	#1,d1
		bne.s	umlFindXLLoop

umlFoundXL:
		move.w	d1,cu_CM+cm_BufferXL(a2)

umlDone:
		moveq	#0,d0

umlRts:
		movem.l	(a7)+,d2-d4/a3-a5
		rts


umlExhausted:
		moveq	#1,d0
		bra.s	umlRts
a529 1

a719 10

		;--	    fill in top from buffer
		move.w	d5,d2
		neg.w	d2
		bra.s	sydDownFillDBF
sydDownFillLoop:
		bsr	UnpackMapLine
sydDownFillDBF:
		dbf	d2,sydDownFillLoop

a721 1

d728 3
@


36.40
log
@See previous note; also now makes sure we use Massaged DisplayXL
when deleting.
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.39 91/04/28 21:51:08 darren Exp Locker: darren $
d473 19
a491 4
	;-- 4/12/91 - change next line to a LONG compare for
	;-- larger dimension screens (e.g., 2048x900 with a
	;-- topaz 8 font results in calculations too big to
	;-- be done via WORD compare
d493 6
a498 7
		cmp.l	d0,d1		; scroll increment vs. field size
		ble.s	pmUpClrAll	; clear everything
		lea	0(a0,d0.w),a3	; get source as per increment
		add.w	d0,d0		;
		lea	0(a1,d0.w),a4	;
		lsr.w	#1,d0		;
		sub.w	d0,d1		; get characters to copy
d505 1
d509 1
d512 1
d516 5
a520 1
		move.w	d1,d0		; clear entire scroll field
@


36.39
log
@Fix for InsDelChar(); updates DisplayYL using massaged value in the
case of inserting, or deleting on the last valid line of the display.
Note this fixes the case of DisplayXL==0, so that DisplayYL is
really the previous line, and DisplayXL is really XMax.  Seen in Shell
windows when using BKSP to delete a line which wrapped (sent as
backspace, and delete char sequences).
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.38 91/04/12 18:37:33 darren Exp Locker: darren $
d985 1
a985 1
		move.w	cu_DisplayXL(a2),d4
@


36.38
log
@PackMap() - changed a cmp.w to a cmp.l - fixes bug noted with big
virtual screens where the window would be cleared on resize (actually
its a relationship between screen dimensions, font size, and
outputting enough text to fill the off-screen buffer).
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.37 91/03/13 16:45:53 darren Exp Locker: darren $
d898 12
d979 1
@


36.37
log
@Fix for crashing bug - e.g., move to last line in ED, insert text
until it scrolls off the end of the line.  Move to top of file + 1 line.
Note message is printed on bottom line, and then a CLEAR TO EOL is done
when the cursor is moved again.  DisplayXL is now 0, so real DisplayXL is
XMax+1; existing code calced this at top, but forgot to do so later on,
and used DisplayXL again as is.
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.36 91/02/22 14:21:35 darren Exp Locker: darren $
d472 7
a478 1
		cmp.w	d0,d1		; scroll increment vs. field size
@


36.36
log
@New call - ResetBuffer().  Sorts the off-screen buffer before clearing
BufferXL/YL.  Fixes a bug found when the off-screen buf ptrs are rolled
(e.g., output a lot of text), and FormFeed was only clearing BufferXL/YL
without sorting the buffers first.  Subsequent text on a new size operation
could have old junk in the off-screen buffer moved into the display buffer.
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.35 91/01/23 16:20:30 darren Exp Locker: darren $
d865 1
a865 1
		movem.l	d2-d5/a4-a5,-(a7)
d879 2
d884 2
a885 1
		blt	iclDone
d903 1
a903 1
		move.w	cu_DisplayXL(a2),d1
d907 1
a907 2
		move.w	cu_XMax(a2),d1
		addq.w	#1,d1
d1024 1
a1024 1
		movem.l	(a7)+,d2-d5/a4-a5
@


36.35
log
@Uses shared code in clear.asm to restore RastPort values.  A little
smaller.
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.34 91/01/03 18:52:18 darren Exp Locker: darren $
d24 1
a48 1

d334 58
d410 1
a410 7
		move.w	cu_CM+cm_BufferWidth(a2),d2
		move.l	cu_CM+cm_BufferXL(a2),d3	; test both, get Y
		beq.s	pmSortDisplay
		move.l	cu_CM+cm_BufferStart(a2),d4
		move.w	cu_CM+cm_BufferHeight(a2),d5
		move.l	cu_CM+cm_AttrBufLines(a2),a3
		bsr	sortMap
@


36.34
log
@Bug fix for case of scroll down when lines are scrolled
off the display - calculation of DisplayXL hosed, and
reading bogus memory - see also clip.asm
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.33 90/12/13 19:03:19 darren Exp Locker: darren $
a24 1

d30 2
a31 1
	XREF	ClearRaster
d33 1
d1231 1
a1231 5
		move.l	cu_Minterms(a2),cd_RastPort+rp_minterms(a6)
		move.l	cu_Minterms+4(a2),cd_RastPort+rp_minterms+4(a6)
		move.b	cu_FgPen(a2),cd_RastPort+rp_FgPen(a6)
		move.b	cu_BgPen(a2),cd_RastPort+rp_BgPen(a6)
		move.b	cu_DrawMode(a2),cd_RastPort+rp_DrawMode(a6)
d1233 1
@


36.33
log
@Fixes bug when scrolling using some color combinations.
e.g., - write some lines of text which force a scroll -
colors for background was being improperly set to the
global background color instead of the character cell color.
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.32 90/11/12 17:38:04 darren Exp Locker: darren $
d1066 1
@


36.32
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.31 90/11/06 11:19:38 darren Exp Locker: darren $
d1232 2
@


36.31
log
@Fixes extra character in map bug related to
deleting characters on last valid line.
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.30 90/11/05 17:46:02 darren Exp Locker: darren $
@


36.30
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.29 90/11/02 08:02:11 darren Exp $
a911 1
		addq.w	#1,d4			;FIX!!!!
d913 1
a913 1
		sub.w	d0,cu_DisplayXL(a2)
d916 2
d919 3
a921 1
		add.w	d0,d4			;FIX!!!!
@


36.29
log
@short branch optimizations
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.28 90/11/01 11:23:07 darren Exp Locker: darren $
@


36.28
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.27 90/10/15 16:00:34 darren Exp Locker: darren $
d142 1
a142 1
		bsr	scrollBufferUp1		; preserves a0/a1
d170 1
a170 1
		bsr	scrollBufferUp1		; preserves a0/a1
d838 1
a838 1
		bpl	iclDelete
d894 1
a894 1
		bra	iclSR
d901 1
a901 1
		bra	iclDeleteScroll
d908 1
a908 1
		ble	iclClear		; clear d2 chars from CP
d1133 1
a1133 1
		bsr	scrollLine
@


36.27
log
@Added code to fix a bug when inserting/deleting
characters.  Typically displayed when cursors
is on col 0, last line of display.  Plus added
a bit of code which guarantees that a loop
cannot be entered if the counter starts out as
negative.
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.26 90/06/07 13:58:44 kodiak Exp Locker: darren $
d15 1
d828 1
d838 1
a838 1
		bpl.s	iclDelete
d894 1
a894 1
		bra.s	iclSR
d900 2
a901 2
		bmi.s	iclInsertScroll
		bra.s	iclDeleteScroll
d906 1
d908 1
a908 1
		ble.s	iclClear		; clear d2 chars from CP
d912 1
d914 1
a914 2
		;-- Fix - convert a 0-x type number to
		;-- a 1-x type number as required by the code below
a915 1
		addq.w	#1,d4			;0-x -> 1-x number
d917 2
a918 8
		move.w	d4,cu_DisplayXL(a2)	;adjust DisplayXL
		add.w	d0,d4			;restore D4

* -- old code; broken as XL falls below 0, and d4 starts out as a 0
*		sub.w	d0,cu_DisplayXL(a2)
*


a939 3

		;-- Fix for serious trashing bug if
		;-- d4 goes negative.
@


36.26
log
@send new parameters to functions in pack.c
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.25 90/05/25 16:14:26 kodiak Exp Locker: kodiak $
a908 1
		sub.w	d0,cu_DisplayXL(a2)
d910 13
d944 7
d959 1
@


36.25
log
@fixes bugs in character map updating when inserting or deleting lines
fixes bug in degenerate case deleting or inserting zero characters
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.24 90/05/24 17:35:16 kodiak Exp Locker: kodiak $
d370 4
d384 1
a384 1
		lea	20(a7),a7
d629 6
a638 4
		pea	cu_YCP(a2)
		pea	cu_XCP(a2)
		pea	cu_DisplayYL(a2)
		pea	cu_DisplayXL(a2)
d642 1
a642 1
		lea	24(a7),a7
d646 2
@


36.24
log
@set DisplayYL correctly when clearing instead of scrolling
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.23 90/04/25 17:33:08 kodiak Exp Locker: kodiak $
d645 1
d665 1
d672 1
a672 1
;   d3	decrementing display height
d675 1
a675 1
;   a0	AttrDispLines 
d681 5
a685 6
		lsl.w	#2,d0
		move.w	d0,d5
		moveq	#0,d1
		move.w	cu_CM+cm_DisplayHeight(a2),d2
		move.w	d2,d3
		lsl.w	#2,d2
d687 5
d693 1
a693 1
		move.l	(a4),d4			; cache first destination
d807 1
a807 1
		beq	idlDone
d834 1
a834 1
		bgt	iclClear		; clear d2 lines at CP
d897 1
a897 1
		ble.s	iclClear		; clear d2 lines at CP
d932 7
d940 1
d984 1
a984 1
*	           a2           d0
d988 3
a990 3
;   d0	increment
;   d1	number of lines actually displayed after CP (inclusive)
;   d2	cu_YCP
d1018 1
a1018 1
		bpl.s	idlDelete
d1032 2
d1039 3
a1041 2
		move.w	cu_YMax(a2),d4
		move.w	d4,d3
d1064 1
d1105 1
@


36.23
log
@ensure cd_SelectedUnit doesn't go NIL
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.22 90/04/17 11:48:49 kodiak Exp Locker: kodiak $
d1101 5
a1121 3
		;--	set the new Display.L to the beginning of this line
		clr.w	cu_DisplayXL(a2)
		move.w	cu_YMax(a2),cu_DisplayYL(a2)
@


36.22
log
@Don't store selected attribute for data saved off-display.
@
text
@d2 1
a2 1
**	$Id: scroll.asm,v 36.21 90/04/13 13:32:48 kodiak Exp Locker: kodiak $
d384 3
a387 1
		and.b	#CDS_SELECTMASK,cd_SelectFlags(a6)
d391 1
@


36.21
log
@use Id instead of Header for 4.x rcs
@
text
@d2 1
a2 1
**	$Id$
d190 1
a190 1
		and.w	#~CMAF_IMPLICITNL,d1
d382 5
@


36.20
log
@bound origin & window size, and move TOOSMALL to just skip graphics rendering
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/scroll.asm,v 36.19 90/04/02 10:47:33 kodiak Exp Locker: kodiak $
@


36.19
log
@for 4.x rcs
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/scroll.asm,v 36.18 90/03/03 14:55:49 kodiak Exp Locker: kodiak $
d1164 2
@


36.18
log
@first cut @@ code to set console background color
@
text
@d2 1
a2 1
**	$Header: scroll.asm,v 36.17 90/03/02 16:22:55 kodiak Exp $
@


36.17
log
@fixes insert character bug
@
text
@d2 1
a2 1
**	$Header: scroll.asm,v 36.16 90/03/01 07:17:13 kodiak Exp $
d28 1
d1166 3
d1170 3
a1172 1
		bsr	CursDisable
d1174 3
@


36.16
log
@fix scroll up clearing boundary case (papa bug)
@
text
@d2 1
a2 1
**	$Header: scroll.asm,v 36.15 90/01/30 16:42:26 kodiak Exp $
d795 2
a796 2
		movem.w	cu_DisplayXL(a2),d2/d3
		tst.w	d2
d807 1
d819 1
a819 1
		ble	iclClear		; clear d2 lines at CP
d943 1
d945 1
d1104 1
d1106 1
@


36.15
log
@fix B6444: INSERT CSI is not functioning
@
text
@d2 1
a2 1
**	$Header: scroll.asm,v 36.14 90/01/29 10:39:05 kodiak Exp $
d998 1
a998 1
		bge	idlClear		; clear d1 lines at CP
@


36.14
log
@fix cursor up beyond top bug
@
text
@d2 1
a2 1
**	$Header: scroll.asm,v 36.13 89/12/14 17:03:32 kodiak Exp $
d850 1
d859 2
@


36.13
log
@different damage refresh strategy: should always clear damage
@
text
@d2 1
a2 1
**	$Header: scroll.asm,v 36.12 89/12/08 17:52:55 kodiak Exp $
d670 1
a670 1
		lsl	#2,d0
d679 2
a680 1
		bra.s	sdDBF
d703 5
d994 2
a995 2
		cmp.w	d0,d3
		ble	idlClear		; clear d1 lines at CP
d1014 1
d1040 1
d1110 1
@


36.12
log
@use packing functions in pack.c
@
text
@d2 1
a2 1
**	$Header: scroll.asm,v 36.11 89/12/07 15:51:28 kodiak Exp $
a1148 1
		bset	#CDB_SCROLL,cd_Flags(a6)
@


36.11
log
@fix initial condition failure in UnpackMap for new display -- was trashing $0
@
text
@d2 1
a2 1
**	$Header: scroll.asm,v 36.10 89/12/04 22:55:38 kodiak Exp $
d35 2
d38 1
d346 1
a346 1
;   d5	== BufferLines for Buf, == -1 for Disp
d353 1
a353 1
		move.w	cu_CM+cm_BufferLines(a2),d5
a366 9
		;-- pack sorted buffer
		moveq	#0,d2
pmLoop:
		move.w	cu_CM+cm_DisplayWidth(a2),d1
		cmp.w	cu_DisplayYL(a2),d2
		bgt	pmTrim
		bne.s	pmHaveXWidth
		move.w	cu_DisplayXL(a2),d1
pmHaveXWidth:
d368 12
a379 25
;-- pack line in sorted environment
;
;   d0	IMPLICITNL flag
;   d1	remaining line width
;   d2	displayLine, then cm_BufferWidth
;   d3	char temp
;   d4	attr temp
;   d5	cm_CharBuffer offset
;   d6	attribute buffer offset
;   d7	lineWrap
;   a0	cm_CharBuffer line origin
;   a1	cm_AttrBuffer line origin
;   a2	console unit
;   a3	incrementing cm_CharDisplay
;   a4	incrementing cm_AttrDisplay
;
		move.l	d2,-(a7)
		;--	find start of display line to pack from
		move.w	cu_CM+cm_DisplayWidth(a2),d0
		mulu	d0,d2
		move.l	cu_CM+cm_DisplayStart(a2),a3
		add.w	d2,a3
		move.l	a3,a4
		add.l	cu_CM+cm_AttrToChar(a2),a3
		add.l	a4,a4
a380 6
		;--	find start of buffer to pack to
		move.w	cu_CM+cm_BufferWidth(a2),d2
		move.w	cu_CM+cm_BufferYL(a2),d3
		mulu	d2,d3
		move.w	cu_CM+cm_BufferXL(a2),d5
		moveq	#0,d7
a381 83
		;--	    check for IMPLICITNL
		move.w	(a4),d0
		and.w	#CMAF_IMPLICITNL,d0
		bne.s	pmPackALine

		;--	    check for empty buffer
		move.w	d3,d6
		add.w	d5,d6
		beq.s	pmPackALine

		;--	    start new explicit line
		;--		clear rest of this line in buffer
		move.l	cu_CM+cm_BufferStart(a2),a1
		add.w	d6,a1
		add.l	a1,a1
		sub.w	d2,d5
		neg.w	d5
		bra.s	pmClearBufferDBF
pmClearBufferLoop:
		clr.w	(a1)+
pmClearBufferDBF:
		dbf	d5,pmClearBufferLoop
		;--		reset line pointers
		moveq	#0,d5 
		add.w	d2,d3
		moveq	#1,d7		; show line wrap

pmPackALine:
		move.l	cu_CM+cm_BufferStart(a2),a0
		add.w	d3,a0
		add.w	d5,a0
		move.l	a0,a1
		add.l	cu_CM+cm_AttrToChar(a2),a0
		add.l	a1,a1

		bra.s	pmDBF

		;--	pack
pmALineLoop:
		;--	    check for buffer wrap
		cmp.w	d2,d5
		blt.s	pmCopy

		;--		wrap destination
		move.w	#CMAF_IMPLICITNL,d0	; set lineWrap
		moveq	#0,d5		; zero XL (character offset)
		add.w	d2,d3		; bump character line origin
		move.l	cu_CM+cm_BufferStart(a2),a0
		add.w	d3,a0
		move.l	a0,a1
		add.l	cu_CM+cm_AttrToChar(a2),a0
		add.l	a1,a1
		moveq	#1,d7		; show line wrap

		;--	    copy character and attribute
pmCopy:
		move.w	(a4)+,d4	; attribute
		bpl.s	pmLineDone	;   not RENDERED

		move.b	(a3)+,(a0)+	; copy character
		and.w	#~CMAF_IMPLICITNL,d4
		or.w	d0,d4
		move.w	d4,(a1)+	;   and attribute
		addq.w	#1,d5		; bump character offset
		move.w	#CMAF_IMPLICITNL,d0	; set lineWrap

pmDBF:
		dbf	d1,pmALineLoop

pmLineDone:
		move.w	d5,cu_CM+cm_BufferXL(a2)
		bne.s	pmPartial

		moveq	#1,d7

pmPartial:
		add.w	d7,cu_CM+cm_BufferYL(a2)
		move.l	(a7)+,d2

		addq.w	#1,d2
		bra	pmLoop


a382 1
pmTrim:
d605 5
d611 4
d620 8
a627 1
		bsr	UnpackMapLine
a631 44
		;--	set YCP
		move.w	cu_YMax(a2),d0
		sub.w	d3,d0
		bpl.s	umNonEmpty

		clr.l	cu_XCP(a2)		; and YCP
		bra.s	umCursUpdate

umNonEmpty:
		move.w	d0,cu_YMax(a2)

		;--	find XCP
		lsl.w	#2,d0
		move.l	cu_CM+cm_AttrDispLines(a2),a0
		move.l	0(a0,d0.w),a0
		move.w	cu_CM+cm_DisplayWidth(a2),d1
		add.w	d1,a0
		add.l	a0,a0
		move.w	d1,d2
umFindXCPLoop:
		tst.w	-(a0)
		dbmi	d1,umFindXCPLoop
		bmi.s	umFoundXCP
		moveq	#0,d1

umFoundXCP:
		cmp.w	d2,d1
		bne.s	umCacheXCP

		;--	    line is full: put XCP on next line
		addq.w	#1,cu_YCP(a2)
		tst.w	d3		; check if empty lines exist at top
		bne.s	umCache0XCP

		moveq	#0,d2		; repack from top of display
		bsr	PackMapLine
		moveq	#1,d3		; top line is now "empty"

umCache0XCP:
		moveq	#0,d1

umCacheXCP:
		move.w	d1,cu_XCP(a2)

d638 2
a640 1
		move.l	cu_XCP(a2),cu_DisplayXL(a2)	; and YCP/DisplayYL
d645 5
@


36.10
log
@checkin for release on Monday 4 Dec -- map w/ indirect line buffers
@
text
@d2 1
a2 1
**	$Header: scroll.asm,v 36.9 89/12/03 16:36:25 kodiak Exp $
d726 3
a728 1
		move.w	cu_YMax(a2),cu_YCP(a2)
d730 6
a736 2
		move.w	cu_CM+cm_DisplayWidth(a2),d1
		move.w	cu_YMax(a2),d0		; cm_DisplayHeight - 1
d740 1
a755 1
		moveq	#0,d1
d757 1
a757 1
		bne.s	umCacheXCP
d761 3
a763 1
		addq.w	#1,d3
d770 1
a770 1
		tst.w	d3
a771 4
		sub.w	d3,cu_YCP(a2)
		bpl.s	umScrollUp
		clr.l	cu_XCP(a2)		; and YCP
		bra.s	umCursUpdate
a772 2
umScrollUp:
		move.w	d3,d0
@


36.9
log
@Sunday checkin
@
text
@d2 1
a2 1
**	$Header: scroll.asm,v 36.8 89/12/02 11:37:14 kodiak Exp $
d223 1
a223 13
*------ PackMap ------------------------------------------------------
*
*   NAME
*	PackMap
*
*   SYNOPSIS
*	PackMap(consoleUnit)
*	        A2
*
PackMap:
		movem.l	d2-d5/a3-a5,-(a7)

		;-- sort lines in buffer
d225 5
a229 4
;   d2	BufferWidth	: slot index is (AttrBufLines contents - d3)/d2
;   d3	slot 0 offset	: (address/2)
;   d4	Work (free) memory index
;   d5	Target (next) slot index
d231 4
a234 2
;   a3  AllocBuffer, == AttrBufLines
;
d236 2
a237 8
		movem.w	cu_CM+cm_BufferWidth(a2),d2/d4	; and BufferHeight
		move.w	cu_CM+cm_BufferLines(a2),d3
		move.l	cu_CM+cm_AllocBuffer(a2),a3
		lsl.w	#3,d3
		ext.l	d3
		add.l	a3,d3
		lsr.l	#1,d3
		move.w	d4,d5		; decrementing target from BufferHeight
a238 2
		bra	pmSortSlotDBF

d240 1
a240 1
pmSortSlotLoop:
d242 2
a243 2
		cmp.w	d5,d4
		beq.s	pmssTargetReady
d246 1
a246 1
		move.w	d5,d1		; construct target memory address
d248 2
a249 2
		add.l	d3,d1		;
		move.w	cu_CM+cm_BufferHeight(a2),d0
d252 1
a252 1
pmssFindTenantLoop:
d254 2
a255 6
		dbeq	d0,pmssFindTenantLoop
		beq.s	pmssFoundTenantLoop
		moveq	#0,d0		; (must be working store)
pmssFoundTenantLoop:
		sub.w	cu_CM+cm_BufferHeight(a2),d0
		neg.w	d0
d257 2
a258 2
		cmp.w	d5,d0		; see if target memory already correct
		beq.s	pmSortSlotDBF
d260 3
d264 3
a266 3
		move.w	d4,d0		; construct work memory address
		mulu	d2,d0		;
		add.l	d3,d0		;
d269 1
a269 2
		move.l	d0,a0
		move.l	d1,a4
d273 1
d278 3
a280 3
		bra.s	pmssCopyWorkDBF
		;--	    copy target memory to work memory
pmssCopyWorkLoop:
d283 2
a284 2
pmssCopyWorkDBF:
		dbf	d0,pmssCopyWorkLoop
d288 3
a290 3
pmssTargetReady:
		move.w	d5,d0
		move.w	d5,d1
d294 1
a294 1
		add.l	d3,d1
d297 1
a297 1
		beq.s	pmSortSlotDBF
d300 3
a302 3
		move.l	a0,d4
		sub.l	d3,d4
		divu	d2,d4
a303 1
		move.l	d1,a4
d309 2
a310 1
		move.l	a4,a5
d314 1
a314 1
		bra.s	pmssCopyDBF
d316 1
a316 1
pmssCopyLoop:
d319 2
a320 2
pmssCopyDBF:
		dbf	d0,pmssCopyLoop
d323 3
a325 2
pmSortSlotDBF:
		dbf	d5,pmSortSlotLoop
d328 11
a338 3
		;-- pack display into buffer
		;--	override buffer height limit
		move.w	cu_CM+cm_BufferLines(a2),cu_CM+cm_BufferHeight(a2)
d340 25
a364 1
		;--	start with first display line
d366 7
d374 112
a485 6
		;--	pack all displayed lines 
		move.w	cu_DisplayYL(a2),d3
pmLoop:
		cmp.w	d3,d2
		bgt.s	pmDone
		bsr	PackMapLine
d487 1
a487 1
		bra.s	pmLoop
d490 48
d539 1
a539 1
		movem.l	(a7)+,d2-d5/a3-a5
d696 1
d706 1
a706 7
		move.l	cu_CM+cm_AllocBuffer(a2),a0
		move.w	cu_CM+cm_BufferLines(a2),d0
		lsl.w	#3,d0			; space for two line buffers
		add.w	d0,a0			; address of first AttrBuf
		add.l	d3,d3			; address of first AttrDisp
		sub.l	a0,d3			
		lsr.l	#1,d3			; non-display buffer elements
d709 4
@


36.8
log
@
@
text
@d2 1
a2 1
**	$Header$
d89 1
d238 1
a238 1
;   d3	slot 0 offset	:
d246 2
a247 2
		move.l	cm_AllocBuffer(a2),a3
		move.w	d4,d3
d251 1
d266 1
a266 1
		moveq	#-1,d0
d272 5
a276 1
		not.w	d0
d411 1
a411 1
		move.l	-(a3),a4
d428 1
a428 1
		subq	#1,d2
d470 1
a470 1
		move.l	(a3),a5
d537 1
d539 1
d554 3
a556 2
		movem.w	cu_CM+cm_DisplayWidth(a2),d1/d2
		lsl.w	#2,d2
d558 1
a558 1
		move.l	0(a0,d2.w),a0
d614 7
a620 5
;   d2	scroll increment
;   d3	offset limit
;   d4	decrementing display height
;   a0	AttrDispLines
;   a1	cache for first destination
d623 1
a623 1
		movem.l	d2-d4,-(a7)
d625 1
d627 3
a629 4
		move.w	d0,d2
		move.w	cu_CM+cm_DisplayHeight(a2),d3
		move.w	d3,d4
		lsl.w	#2,d3
d631 2
a632 1
		move.l	(a0),a1			; cache first destination
d635 22
a656 4
		move.l	0(a0,d0.w),0(a0,d1.w)	; copy source to dest
		move.w	d0,d1			; next dest is old source
		add.w	d2,d0			; bump source by increment
		cmp.w	d3,d0			; limit source
d658 1
a658 1
		sub.w	d3,d0			;   adjust to within limit
d660 1
a660 1
		dbf	d4,sdLoop
d662 2
a663 3
		move.l	a1,0(a0,d1.w)		; finish rotate from cache

		movem.l	(a7)+,d2-d4
d992 1
a992 1
		move.w	cu_CM+cm_DisplayWidth,d4
@


36.7
log
@trim packed map to full screen so no overlapping when unpacking
@
text
@d1 9
a9 36
	TTL    '$Header: scroll.asm,v 36.6 89/11/06 17:23:59 kodiak Exp $'
**********************************************************************
*
*			--------------
*   scroll.asm		CONSOLE DEVICE	scroll display and character map
*			--------------
*
*   Copyright 1985, 1987, 1989 Commodore-Amiga Inc.
*
*   Source Control	$Locker: kodiak $
*
*   $Log:	scroll.asm,v $
*   Revision 36.6  89/11/06  17:23:59  kodiak
*   pack fixed, checkin before unpack work
*   
*   Revision 36.5  89/11/06  14:19:09  kodiak
*   better resizing cursor placement
*   
*   Revision 36.4  89/11/04  17:12:02  kodiak
*   fix ScrollYDisplay buffer scrolling
*   (mostly :-)
*   
*   Revision 36.3  89/11/04  16:04:32  kodiak
*   first near-to-working resize/remap code
*   
*   Revision 36.2  89/09/11  12:59:33  kodiak
*   export ScrollDMap
*   
*   Revision 36.1  89/07/07  13:27:21  kodiak
*   private SCROLL flag, set so to remove dependency in LAYERREFRESH
*   
*   Revision 36.0  89/07/05  15:23:08  kodiak
*   *** empty log message ***
*   
*
**********************************************************************
d11 1
a11 1
	SECTION		rawinput
d13 1
a13 1
*------ Included Files -----------------------------------------------
a14 1
	INCLUDE		"cddata.i"
d16 1
a16 1
	INCLUDE		"hardware/custom.i"
d18 5
a23 1
*------ Imported Functions -------------------------------------------
d25 1
a25 4
	XLVO	DisownBlitter		; Graphics
	XLVO	OwnBlitter		;
	XLVO	ScrollRaster		;
	XLVO	WaitBlit		;
d27 4
d36 1
a36 1
*------ Exported Functions -------------------------------------------
d38 3
a40 5
	XDEF	PackMap
	XDEF	UnpackMap
	XDEF	InsDelChar
	XDEF	InsDelLine
	XDEF	ScrollYDisplay
a56 2
;   d0	IMPLICITNL flag
;   d1	remaining cm_DisplayWidth
d58 7
a64 7
;   d3	char temp
;   d4	attr temp
;   d5	cm_CharBuffer offset
;   d6	cm_AttrBuffer offset
;   d7	lineWrap
;   a0	cm_CharBuffer line origin
;   a1	cm_AttrBuffer line origin
d66 3
a68 2
;   a3	incrementing cm_CharDisplay
;   a4	incrementing cm_AttrDisplay
d71 12
a82 1
		movem.l	d2-d7/a3-a4,-(a7)
d84 6
a89 7
		move.w	cu_CM+cm_DisplayWidth(a2),d1
		mulu	d1,d2
		move.l	cu_CM+cm_CharDisplay(a2),a3
		add.w	d2,a3
		move.l	cu_CM+cm_AttrDisplay(a2),a4
		add.w	d2,d2
		add.w	d2,a4
a90 1
		;--	find start of buffer to pack to
a91 4
		move.w	cu_BufferYL(a2),d3
		mulu	d2,d3
		move.w	cu_BufferXL(a2),d5
		moveq	#0,d7
d93 12
d106 2
a107 2
		move.w	(a4),d0
		and.w	#CMAF_IMPLICITNL,d0
d111 4
a114 2
		move.w	d3,d6
		add.w	d5,d6
d118 1
d120 11
a130 10
		move.l	cu_CM+cm_AttrBuffer(a2),a1
		add.w	d6,d6
		add.w	d6,a1
		sub.w	d2,d5
		neg.w	d5
		bra.s	pmlClearBufferDBF
pmlClearBufferLoop:
		clr.w	(a1)+
pmlClearBufferDBF:
		dbf	d5,pmlClearBufferLoop
d132 3
a134 3
		moveq	#0,d5 
		add.w	d2,d3
		moveq	#1,d7
d136 8
d145 4
a148 5
		move.l	cu_CM+cm_CharBuffer(a2),a0
		add.w	d3,a0
		move.l	cu_CM+cm_AttrBuffer(a2),a1
		add.w	d3,d3
		add.w	d3,a1
a149 2
		move.w	d5,d6
		add.w	d6,d6
d155 1
a155 1
		cmp.w	d2,d5
d159 4
a162 7
		move.w	#CMAF_IMPLICITNL,d0	; set lineWrap
		moveq	#0,d5		; zero XL (character offset)
		moveq	#0,d6		;   and attribute offset
		add.w	d2,a0		; bump character line origin
		add.w	d2,a1		;   and attribute line origin
		add.w	d2,a1		;
		moveq	#1,d7		; show lineWrap
d164 13
d179 2
a180 2
		move.b	(a3)+,d3	; character
		move.w	(a4)+,d4	; attribute
d183 6
a188 7
		move.b	d3,0(a0,d5.w)	; copy this character
		and.w	#~CMAF_IMPLICITNL,d4
		or.w	d0,d4
		move.w	d4,0(a1,d6.w)	;   and attribute
		addq.w	#1,d5		; bump character offset
		addq.w	#2,d6		;   and attribute offset
		move.w	#CMAF_IMPLICITNL,d0	; set lineWrap
d191 1
a191 1
		dbf	d1,pmlLoop
d194 2
a195 7
		move.w	d5,cu_BufferXL(a2)
		bne.s	pmlPartial
		moveq	#1,d7
pmlPartial:
		add.w	d7,cu_BufferYL(a2)
		move.l	d7,d0
		movem.l	(a7)+,d2-d7/a3-a4
d199 23
d232 112
a343 1
		movem.l	d2/d3,-(a7)
d345 2
a347 3
		cmp.w	cu_YCP(a2),d3
		bge.s	pmLoop
		move.w	cu_YCP(a2),d3
d350 1
a350 1
		bgt.s	pmTrim
a354 6
		;--	    scroll buffer
pmTrim:
		move.w	cu_BufferYL(a2),d0
		move.w	cu_CM+cm_BufferMaxHeight(a2),d1
		sub.w	d1,d0
		blt.s	pmDone
a355 12
		;--	    scroll up buffer
		addq.w	#1,d0
		sub.w	d0,cu_BufferYL(a2)
		add.w	d0,d1
		move.w	cu_CM+cm_BufferWidth(a2),d2
		mulu	d2,d0
		mulu	d2,d1
		moveq	#0,d2
		move.l	cu_CM+cm_CharBuffer(a2),a0
		move.l	cu_CM+cm_AttrBuffer(a2),a1
		bsr	scrollMap

d357 1
a357 1
		movem.l	(a7)+,d2/d3
d371 2
a372 2
;   d0	cm_DisplayWidth
;   d1	cm_BufferWidth
d374 3
a376 3
;   d3	cu_BufferYL
;   a0	decrementing cm_CharDisplay
;   a1	decrementing cm_AttrDisplay
d378 3
a380 2
;   a3	cm_CharBuffer offset
;   a4	cm_AttrBuffer offset
d383 4
a386 5
		movem.l	d2-d4/a3-a4,-(a7)
	IFNE	cu_BufferYL-cu_BufferXL-2
	FAIL	"cu_BufferXL not before cu_BufferYL: recode"
	ENDC
		tst.l	cu_BufferXL(a2)	; and cu_BufferYL
d390 3
d394 4
a397 7
		addq.w	#1,d2
		mulu	d0,d2
		move.l	cu_CM+cm_CharDisplay(a2),a0
		add.w	d2,a0
		move.l	cu_CM+cm_AttrDisplay(a2),a1
		add.w	d2,d2
		add.w	d2,a1
d400 4
d405 4
a408 7
		move.w	d1,d2
		mulu	cu_BufferYL(a2),d2
		move.l	cu_CM+cm_CharBuffer(a2),a3
		add.w	d2,a3
		move.l	cu_CM+cm_AttrBuffer(a2),a4
		add.w	d2,d2
		add.w	d2,a4
d412 1
a412 1
		move.w	cu_BufferXL(a2),d2
d425 1
a425 1
		move.w	d2,cu_BufferXL(a2)
d428 1
a428 1
		add.w	d2,a3
d430 1
a430 1
		add.w	d2,a4
d438 2
a439 2
		subq.l	#1,a3
		subq.l	#2,a4
d447 2
a448 2
		move.b	-(a3),-(a0)
		move.w	-(a4),-(a1)
d454 1
a454 1
		tst.w	cu_BufferXL(a2)
d456 1
a456 1
		move.w	cu_BufferYL(a2),d2
a459 1
		move.w	d2,d6
d461 1
a461 1
		move.w	d2,cu_BufferYL(a2)
d464 4
a467 4
		mulu	d1,d6
		move.l	cu_CM+cm_AttrBuffer(a2),a4
		add.w	d6,d6
		add.w	d6,a4
d469 1
a469 1
		tst.w	-(a4)		; check RENDERED
d475 1
a475 1
		move.w	d1,cu_BufferXL(a2)
d481 1
a481 1
		movem.l	(a7)+,d2-d4/a3-a4
a499 1
		tst.w	cu_CM(a2)	;!!!
d501 2
a502 2
		;--	set Display variables
		move.w	cu_XMax(a2),d0
d504 18
a521 16
		move.w	d0,cu_CM+cm_DisplayWidth(a2)
		move.w	cu_YMax(a2),d2
		addq.w	#1,d2
		move.w	d2,cu_CM+cm_DisplayHeight(a2)
		mulu	d2,d0
		sub.w	cu_CM+cm_Elements(a2),d0
		neg.w	d0
		moveq	#0,d1
		move.w	d0,d1
		move.l	cu_CM+cm_CharBuffer(a2),a0
		add.w	d0,a0
		move.l	a0,cu_CM+cm_CharDisplay(a2)
		move.l	cu_CM+cm_AttrBuffer(a2),a0
		add.w	d0,d0
		add.w	d0,a0
		move.l	a0,cu_CM+cm_AttrDisplay(a2)
d523 9
a531 2
		divu	cu_CM+cm_BufferWidth(a2),d1
		move.w	d1,cu_CM+cm_BufferHeight(a2)
d546 6
a551 6
		move.w	cu_CM+cm_Elements(a2),d0
		move.l	cu_CM+cm_AttrBuffer(a2),a0
		add.w	d0,d0
		add.w	d0,a0

		move.w	cu_CM+cm_DisplayWidth(a2),d1
d555 1
d557 1
a557 2
		subq.w	#1,d1
		bgt.s	umFindXCPLoop
d572 1
d582 1
a582 2
		clr.w	cu_XCP(a2)
		clr.w	cu_YCP(a2)
d586 2
a587 6
		move.w	cu_CM+cm_DisplayWidth(a2),d0
		move.w	d0,d1
		mulu	d3,d0
		mulu	cu_CM+cm_DisplayHeight(a2),d1
		moveq	#0,d2
		bsr	ScrollDMap
d590 1
d597 41
d650 1
a650 1
		tst.w	cu_CM+cm_Elements(a2)
d655 1
a656 1
		bmi.s	sydDown
d658 17
d676 1
a678 4
		cmp.w	cu_CM+cm_DisplayHeight(a2),d3
		ble.s	sydUpBounded
		move.w	cu_CM+cm_DisplayHeight(a2),d3
sydUpBounded:
a685 48
		;--	    scroll buffer
		move.w	cu_BufferYL(a2),d0
		move.w	cu_CM+cm_BufferHeight(a2),d1
		sub.w	d1,d0
		blt.s	sydUpDisplay

		;--	    scroll up buffer
		addq.w	#1,d0
		sub.w	d0,cu_BufferYL(a2)
		add.w	d0,d1
		move.w	cu_CM+cm_BufferWidth(a2),d2
		mulu	d2,d0
		mulu	d2,d1
		moveq	#0,d2
		move.l	cu_CM+cm_CharBuffer(a2),a0
		move.l	cu_CM+cm_AttrBuffer(a2),a1
		bsr	scrollMap

		;--	    scroll up display
sydUpDisplay:
		move.w	cu_CM+cm_DisplayWidth(a2),d0
		move.w	d0,d1
		mulu	d5,d0
		mulu	cu_CM+cm_DisplayHeight(a2),d1
		moveq	#0,d2
		bsr	ScrollDMap

		bra.s	sydmSR

		;--	scroll down
sydDown:
		;--	    scroll off bottom of display
		move.w	cu_CM+cm_DisplayWidth(a2),d1
		muls	d1,d0
		mulu	cu_CM+cm_DisplayHeight(a2),d1
		moveq	#0,d2
		bsr.s	ScrollDMap	; scroll off bottom

		;--	    fill in top from buffer
		move.w	d5,d2
		neg.w	d2
sydDownFill:
		beq.s	sydmSR
		bsr	UnpackMap
		subq.w	#1,d2
		bra.s	sydDownFill

sydmSR:
a686 1

d688 2
a689 1
		bsr	sDisplay
a707 2
		tst.w	cu_CM+cm_Elements(a2)
		beq.s	sycSR
d709 3
a711 9
		move.w	d0,d5
		move.w	cu_CM+cm_DisplayWidth(a2),d1
		move.w	cu_YCP(a2),d2
		move.w	cu_XCP(a2),d3
		mulu	d1,d2
		add.w	d3,d2
		sub.w	d3,d1
		bsr.s	ScrollDMap
		move.w	d5,d0
d713 12
a724 2
sycSR:
		bsr	sChar
d726 111
d841 24
d873 2
d877 8
d886 1
a886 4
		movem.l	d2-d5/a4-a5,-(a7)
		move.w	cu_CM+cm_DisplayWidth(a2),d1
		mulu	cu_CM+cm_DisplayHeight(a2),d1
		beq.s	sylSR
d888 5
a892 8
		move.w	d0,d5
		move.w	cu_CM+cm_DisplayWidth(a2),d3
		muls	d3,d0		; character increment
		move.w	cu_YCP(a2),d2
		mulu	d3,d2		; character offset
		sub.w	d2,d1		; from offset to bottom
		bsr.s	ScrollDMap
		move.w	d5,d0
d894 1
a894 2
sylSR:
		bsr	sLine
d896 9
a904 2
		movem.l	(a7)+,d2-d5/a4-a5
		rts
d906 3
d910 89
a998 40
*------ ScrollDMap ----------------------------------------------------
*
*   NAME
*	ScrollDMap - scroll the character map
;
;	d0	character increment to scroll (+: up,  -: down)
;	d1	scroll field character size
;	d2	scroll field character offset
;
ScrollDMap:
		move.l	cu_CM+cm_CharDisplay(a2),a0
		move.l	cu_CM+cm_AttrDisplay(a2),a1
scrollMap:
		movem.l	d2/a4-a5,-(a7)
		add.w	d2,a0		; adjust buffers for field offset
		add.w	d2,d2		;
		add.w	d2,a1		;
		tst.w	d0
		beq.s	smRts
		bmi.s	smDown
		cmp.w	d0,d1		; scroll increment vs. field size
		ble.s	smUpClrAll	; clear everything
		lea	0(a0,d0.w),a4	; get source as per increment
		add.w	d0,d0		;
		lea	0(a1,d0.w),a5	;
		lsr.w	#1,d0		;
		sub.w	d0,d1		; get characters to copy
		bra.s	smUpCopyDBF
smUpCopyLoop:
		move.b	(a4)+,(a0)+	; copy character
		move.w	(a5)+,(a1)+	; copy attribute
smUpCopyDBF:
		dbf	d1,smUpCopyLoop
		bra.s	smUpClrDBF
smUpClrLoop:
		clr.w	(a1)+		; empty attribute
smUpClrDBF:
		dbf	d0,smUpClrLoop
smRts:
		movem.l	(a7)+,d2/a4-a5
a1000 3
smUpClrAll:
		move.w	d1,d0		; clear entire scroll field
		bra.s	smUpClrDBF
d1002 3
d1006 5
a1010 25
smDown:
		add.w	d1,a0		; adjust buffers for field size
		add.w	d1,d1		;
		add.w	d1,a1		;
		lsr.w	#1,d1		;
		lea	0(a0,d0.w),a4	; get source as per increment
		add.w	d0,d0		;
		lea	0(a1,d0.w),a5	;
		asr.w	#1,d0		;
		neg.w	d0		; get absolute value of scroll increment
		cmp.w	d0,d1		; scroll increment vs. field size
		ble.s	smDownClrAll	; clear everything
		sub.w	d0,d1		; get characters to copy
		bra.s	smDownCopyDBF
smDownCopyLoop:
		move.b	-(a4),-(a0)	; copy character
		move.w	-(a5),-(a1)	; copy attribute
smDownCopyDBF:
		dbf	d1,smDownCopyLoop
		bra.s	smDownClrDBF
smDownClrLoop:
		clr.w	-(a1)		; empty attribute
smDownClrDBF:
		dbf	d0,smDownClrLoop
		bra.s	smRts
d1012 4
a1015 3
smDownClrAll:
		move.w	d1,d0		; clear entire scroll field
		bra.s	smDownClrDBF
d1017 4
d1022 1
d1032 2
a1033 2
sLine:
		move.w	cu_YCP(a2),d3
d1036 1
a1036 1
		bra.s	sSRLine
d1038 1
a1038 1
sChar:
d1040 1
a1040 1
		beq.s	sRts
d1051 1
a1051 1
		bra.s	sSRChar
d1053 1
a1053 1
sRts:
d1056 1
a1056 1
sDisplay:
d1060 1
a1060 1
sSRLine:
d1062 1
a1062 1
		beq.s	sRts
d1070 1
a1070 1
sSRChar:
@


36.6
log
@pack fixed, checkin before unpack work
@
text
@d1 1
a1 1
	TTL    '$Header: scroll.asm,v 36.5 89/11/06 14:19:09 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 3
d213 1
a213 1
		bgt.s	pmDone
d218 19
d270 1
a270 1
		;--	get start of display line to fill
d272 1
d291 1
d293 1
a293 1
		beq.s	umlClearLoop
d306 2
d311 2
d314 12
a325 2
		;--	fill from buffer
		moveq	#0,d2
d327 4
a330 6
		cmp.w	d3,d2
		bge.s	umlClearLoop
		move.b	(a3)+,(a0)+
		move.w	(a4)+,(a1)+
		addq.w	#1,d2
		bra.s	umlFillLoop
a331 8
		;--	clear remainder of line
umlClearLoop:
		cmp.w	d0,d2
		bge.s	umlCheckLineExhausted
		clr.w	(a1)+
		addq.w	#1,d2
		bra.s	umlClearLoop

d510 2
a511 3
		neg.w	d0
		add.w	d1,d0
		bgt.s	sydUpDisplay
@


36.5
log
@better resizing cursor placement
@
text
@d1 1
a1 1
	TTL    '$Header: scroll.asm,v 36.4 89/11/04 17:12:02 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker: kodiak $
d13 3
d489 1
@


36.4
log
@fix ScrollYDisplay buffer scrolling
(mostly :-)
@
text
@d1 1
a1 1
	TTL    '$Header: scroll.asm,v 36.3 89/11/04 16:04:32 kodiak Exp $'
d13 4
d50 1
d202 3
a204 3
		tst.w	cu_DisplayXL(a2)
		bne.s	pmLoop
		subq.w	#1,d3
d387 31
d420 1
a420 1
		beq.s	umDone
d422 1
a422 1
		bpl.s	umSomething
d425 1
a425 1
		bra.s	umDone
d427 1
a427 1
umSomething:
d435 2
a436 13
		;--	find XCP
		move.w	cu_YCP(a2),d0
		addq.w	#1,d0
		move.w	cu_CM+cm_DisplayWidth(a2),d1
		mulu	d1,d0
		move.l	cu_CM+cm_AttrDisplay(a2),a0
		add.w	d0,d0
		add.w	d0,a0
umFindXCPLoop:
		subq.w	#1,d1
		ble.s	umFoundXCP
		tst.w	-(a0)
		beq.s	umFindXCPLoop
a437 6
		addq.w	#1,d1		;!!! what if at end!!!

umFoundXCP:
		move.w	d1,cu_XCP(a2)

umDone:
@


36.3
log
@first near-to-working resize/remap code
@
text
@d1 1
a1 1
	TTL    '$Header: scroll.asm,v 36.2 89/09/11 12:59:33 kodiak Exp $'
d13 3
d435 1
a435 1
		move.w	cu_CM+cm_Elements(a2),d1
d460 2
a461 1
		sub.w	d1,d0
a469 1
		beq.s	sydUpDisplay
d477 4
a480 2
		move.w	d5,d0
		muls	cu_CM+cm_DisplayWidth(a2),d0
d482 1
a482 1
		bsr.s	ScrollDMap
d489 3
a491 1
		muls	cu_CM+cm_DisplayWidth(a2),d0
@


36.2
log
@export ScrollMap
@
text
@d1 1
a1 1
	TTL    '$Header: scroll.asm,v 36.1 89/07/07 13:27:21 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 3
d36 4
a39 4
	XREF_GFX	DisownBlitter
	XREF_GFX	OwnBlitter
	XREF_GFX	ScrollRaster
	XREF_GFX	WaitBlit
d47 2
a50 1
	XDEF	ScrollMap
d54 366
d432 1
a432 1
		move.w	cu_BufferSize(a2),d1
d435 32
a466 2
		move.w	d0,d5
		muls	cu_BufferWidth(a2),d0
d468 6
a473 1
		bsr.s	ScrollMap
d475 3
d479 21
d503 1
d520 1
a520 1
		tst.w	cu_BufferSize(a2)
d524 1
a524 1
		move.w	cu_BufferWidth(a2),d1
d530 1
a530 1
		bsr.s	ScrollMap
d552 2
a553 1
		move.w	cu_BufferSize(a2),d1
d557 1
a557 1
		move.w	cu_BufferWidth(a2),d3
d562 1
a562 1
		bsr.s	ScrollMap
d572 1
a572 1
*------ ScrollMap ----------------------------------------------------
d575 1
a575 1
*	ScrollMap - scroll the character map
a579 2
;   DESTROYED
;	d0-d2/a0-a1/a4-a5
d581 4
a584 1
ScrollMap:
a585 2
		move.l	cu_CharBuffer(a2),a0
		move.l	cu_AttrBuffer(a2),a1
d650 1
a650 1
;------ raster scroll routines
a704 87


	IFD	BLITTER_SCROLL

*------ ScrollBufferUp -----------------------------------------------
*
*	ScrollBufferUp(y0, dy)
*	               d0  d1
*
ScrollBufferUp:
		movem.l	d2-d4/a3,-(a7)
	    ;-- get the blitter
		LINKGFX	OwnBlitter
		LINKGFX	WaitBlit
		move.l	_custom,a3

		;-- set the modulos and controls
		moveq	#0,d0
		move.w	d0,bltbmod(a3)
		move.w	d0,bltdmod(a3)
		move.w	d0,bltcon1(a3)

		move.w	cu_BufferWidth(a2),d3
		move.l	cu_BufferHeight(a2),d4
		;-- find the origin of source and destination
		move.w	d1,d2			; save ysize
		add.w	d0,d1			; y1
		mulu	d3,d0			; destination offset
		sub.l	d1,d4			; check if any source exists
						;   also calculate rows to clr
		bgt.s	sbuScroll
		;--	set up to just clear attributes
		add.l	d1,d4			; recover BufferHeight
		sub.l	d0,d4			; get rows to clear
		add.l	d0,d0
		move.l	cu_AttrBuffer(a2),a0
		add.l	d0,a0
		move.l	a0,bltdpt(a3)
		bra.s	sbuClr

sbuScroll:
		mulu	d3,d1			; source offset
		move.w	#$05cc,bltcon0(a2)	; copy B to D
		;-- set character source and destination
		move.l	cu_CharBuffer(a2),a0
		move.l	a0,a1
		add.l	d0,a0
		add.l	d1,a1
		move.l	a0,bltdpt(a3)
		move.l	a1,bltbpt(a3)

		;-- calculate the size and fire up the blt
		lsl.w	#6,d2
		lsr.w	#1,d3
		or.w	d3,d2
		move.w	d2,bltsize(a3)

		;-- set attribute source and destination
		add.l	d0,d0
		add.l	d1,d1
		move.l	cu_AttrBuffer(a2),a0
		move.l	a0,a1
		add.l	d0,a0
		add.l	d1,a1
		LINKGFX	WaitBlit
		move.l	a0,bltdpt(a3)
		move.l	a1,bltbpt(a3)

		;-- calculate the size and fire up the blt
		add.w	d3,d2
		move.w	d2,bltsize(a3)
		LINKGFX	WaitBlit
		add.w	d3,d3

sbuClr:
		move.w	#$0100,bltcon0(a2)	; clear D for remainder
		lsl.w	#6,d4
		or.w	d3,d4
		move.w	d4,bltsize(a3)

		LINKGFX	DisownBlitter
		LINKGFX	WaitBlit
		movem.l	(a7)+,d2-d4/a3

		rts

	ENDC	; BLITTER_SCROLL
@


36.1
log
@private SCROLL flag, set so to remove dependency in LAYERREFRESH
@
text
@d1 1
a1 1
	TTL    '$Header: scroll.asm,v 36.0 89/07/05 15:23:08 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker: kodiak $
d13 3
a43 1
	XDEF	ScrollYDisplay
d46 2
d68 1
a68 1
		bsr.s	sMap
d100 1
a100 1
		bsr.s	sMap
d131 1
a131 1
		bsr.s	sMap
d141 4
a144 1
; - - -	character scroll
d152 2
a153 1
sMap:
d181 1
d213 1
a213 2
sRts:
		rts
d249 3
@


36.0
log
@*** empty log message ***
@
text
@d1 1
a1 1
	TTL    '$Header$'
d10 1
a10 1
*   Source Control	$Locker$
d12 4
a15 1
*   $Log$
d25 1
d27 1
d30 2
d33 1
d260 1
d264 87
@
