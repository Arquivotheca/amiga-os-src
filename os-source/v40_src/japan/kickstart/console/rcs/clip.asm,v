head     41.0;
branch   ;
access   ;
symbols  V39_4:36.46 V37_157:36.46 V37_149:36.46 V37_136:36.46 V37_133:36.46 V37_110:36.46 V37_98:36.45 V37_85:36.45 V37_63:36.45 V37_36:36.45 V37_15:36.45 V37_10:36.44 V37_7:36.43 V37_2:36.43 V36_558:36.43 V36_554:36.42 V36_552:36.42 V36_549:36.41 V36_548:36.40 V36_547:36.38 V36_546:36.37 V36_545:36.36 V36_544:36.35 V36_543:36.35 V36_542:36.35 V36_540:36.35 V36_539:36.34 V36_538:36.33 V36_537:36.33 V36_536:36.33 V36_529:36.32 V36_527:36.32 V36_525:36.32 V36_524:36.32 V36_523:36.32 V36_522:36.32 V36_521:36.30 V36_520:36.30 V36_519:36.28 V36_518:36.28 V36_495:36.28 V36_491:36.27 V36_486:36.26 V36_482:36.24 V36_476:36.24 V36_471:36.24 V36_465:36.24 V36_463:36.24 V36_461:36.23 V36_460:36.23 V36_453:36.23 V36_447:36.23 V36_442:36.22 V36_429:36.21 V36_423:36.21 V36_413:36.20 V36_394:36.19 V36_387:36.19 V36_382:36.19 V36_381:36.19 V36_379:36.18 V36_373:36.18 V36_367:36.18 V36_361:36.17 V36_359:36.16 V36_357:36.15 V36_353:36.15 V36_346:36.14 V36_343:36.13 V36_338:36.12 V36_332:36.12 V36_327:36.12 V36_321:36.12 V36_319:36.12 V36_318:36.12 V36_316:36.12 V36_313:36.12 V36_311:36.11 V36_310:36.11 V36_300:36.11 V36_299:36.11 V36_297:36.11 V36_295:36.11 V36_278:36.11 V36_274:36.11 V36_221:36.9 V36_205:36.9 V36_171:36.8 V36_167:36.8 V36_165:36.7 V36_153:36.5 V36_146:36.5 V36_140:36.5 V36_129:36.5 V36_113:36.5 V36_56:36.4 V36_53:36.2 V36_51:36.2 V36_45:36.2;
locks    ; strict;
comment  @@;


41.0
date     93.05.07.13.28.20;  author darren;  state Exp;
branches ;
next     36.47;

36.47
date     92.03.24.16.25.18;  author darren;  state Exp;
branches ;
next     36.46;

36.46
date     91.04.12.17.40.58;  author darren;  state Exp;
branches ;
next     36.45;

36.45
date     91.01.23.16.08.57;  author darren;  state Exp;
branches ;
next     36.44;

36.44
date     91.01.21.11.15.00;  author darren;  state Exp;
branches ;
next     36.43;

36.43
date     91.01.03.18.54.19;  author darren;  state Exp;
branches ;
next     36.42;

36.42
date     90.12.13.11.03.16;  author darren;  state Exp;
branches ;
next     36.41;

36.41
date     90.12.03.12.22.18;  author darren;  state Exp;
branches ;
next     36.40;

36.40
date     90.12.02.06.03.10;  author darren;  state Exp;
branches ;
next     36.39;

36.39
date     90.12.02.05.23.05;  author darren;  state Exp;
branches ;
next     36.38;

36.38
date     90.11.30.22.28.07;  author darren;  state Exp;
branches ;
next     36.37;

36.37
date     90.11.30.00.29.49;  author darren;  state Exp;
branches ;
next     36.36;

36.36
date     90.11.29.23.19.20;  author darren;  state Exp;
branches ;
next     36.35;

36.35
date     90.11.09.21.23.22;  author darren;  state Exp;
branches ;
next     36.34;

36.34
date     90.11.07.15.20.56;  author darren;  state Exp;
branches ;
next     36.33;

36.33
date     90.11.02.08.09.41;  author darren;  state Exp;
branches ;
next     36.32;

36.32
date     90.08.13.17.59.20;  author darren;  state Exp;
branches ;
next     36.31;

36.31
date     90.08.13.11.15.16;  author darren;  state Exp;
branches ;
next     36.30;

36.30
date     90.07.26.11.38.15;  author darren;  state Exp;
branches ;
next     36.29;

36.29
date     90.07.26.11.14.09;  author darren;  state Exp;
branches ;
next     36.28;

36.28
date     90.05.30.14.23.16;  author kodiak;  state Exp;
branches ;
next     36.27;

36.27
date     90.05.29.18.22.19;  author kodiak;  state Exp;
branches ;
next     36.26;

36.26
date     90.05.25.16.13.30;  author kodiak;  state Exp;
branches ;
next     36.25;

36.25
date     90.05.25.15.57.23;  author kodiak;  state Exp;
branches ;
next     36.24;

36.24
date     90.05.14.23.15.19;  author kodiak;  state Exp;
branches ;
next     36.23;

36.23
date     90.04.25.17.29.55;  author kodiak;  state Exp;
branches ;
next     36.22;

36.22
date     90.04.20.09.45.22;  author kodiak;  state Exp;
branches ;
next     36.21;

36.21
date     90.04.17.11.20.12;  author kodiak;  state Exp;
branches ;
next     36.20;

36.20
date     90.04.13.13.32.23;  author kodiak;  state Exp;
branches ;
next     36.19;

36.19
date     90.04.02.10.47.11;  author kodiak;  state Exp;
branches ;
next     36.18;

36.18
date     90.03.02.16.21.02;  author kodiak;  state Exp;
branches ;
next     36.17;

36.17
date     90.03.01.17.42.28;  author kodiak;  state Exp;
branches ;
next     36.16;

36.16
date     90.03.01.17.14.40;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     90.02.26.20.25.07;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     90.02.22.09.56.56;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     90.02.21.18.40.20;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     89.12.15.22.42.09;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     89.12.04.22.55.31;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     89.12.02.11.36.30;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     89.11.04.15.59.49;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     89.09.15.15.37.07;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     89.08.21.15.08.28;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     89.08.21.12.59.51;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.06.28.12.27.09;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     89.04.19.16.16.32;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     89.04.17.15.34.23;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     89.01.10.16.45.36;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     88.09.19.17.03.42;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


41.0
log
@First pass code - highlight whole double EUC bytes if
Japanese font.  Should be a NOP if not using an EUC
font, and about as fast as it use to be - slower if
Japanese mode, but who cares?  We are drag seleecting.
@
text
@**
**	$Id: clip.asm,v 36.47 92/03/24 16:25:18 darren Exp Locker: darren $
**
**      manipulate a console clip
**
**      (C) Copyright 1989,1990 Commodore-Amiga, Inc.
**          All Rights Reserved
**
	SECTION	console

**	Includes

	INCLUDE		"cddata.i"

	INCLUDE		"intuition/intuition.i"
	INCLUDE		"utility/hooks.i"

	INCLUDE		"debug.i"

DEBUG_DETAIL	SET	0

**	Exports

	XDEF	SelectAbort
	XDEF	SelectClip


**	Imports

	XLVO	AllocVec		; Exec
	XLVO	FreeVec			;
	XLVO	ObtainSemaphore		;
	XLVO	ReleaseSemaphore	;

	XLVO	PeekQualifier		; Input

	XREF	LockDRPort
	XREF	UnLockRPort

	XREF	UpdateHighlight


**	Assumptions

	IFNE	(CMAB_SELECTED/8)-1
	FAIL	"CMAB_SELECTED not in high byte, recode"
	ENDC
	IFNE	cd_SelectedAnchorX-cd_SelectedAnchorY+2
	FAIL	"cd_SelectedAnchorY does not follow cd_SelectedAnchorX, recode"
	ENDC
	IFNE	cd_SelectedTailX-cd_SelectedTailY+2
	FAIL	"cd_SelectedTailY does not follow cd_SelectedTailX, recode"
	ENDC
	IFNE	cd_SelectedAnchorX-cd_SelectedTailX+4
	FAIL	"cd_SelectedTail does not follow cd_SelectedAnchor, recode"
	ENDC
	IFNE	(CMAB_IMPLICITNL/8)-1
	FAIL	"CMAB_IMPLICITNL not in high byte, recode"
	ENDC


*------ SelectAbort --------------------------------------------------
SelectAbort:

		bclr	#CUB_SELECTED,cu_Flags(a2)
		beq.s	saDone		;.s!

		and.b	#CDS_SELECTMASK,cd_SelectFlags(a6)
		clr.l	cd_SelectedUnit(a6)
		bclr	#CUB_CURSSELECT,cu_CursorFlags(a2)

saChkBuffered:
		tst.l	cu_CM+cm_AllocSize(a2)
		beq.s	saDone		;.s!

		;-- clear CMAB_SELECTED in display attributes
		move.l	d2,-(a7)
		move.l	cu_CM+cm_AttrDispLines(a2),a0
		move.w	cu_DisplayXL(a2),d0
		move.w	cu_DisplayYL(a2),d1
		move.w	d1,d2		; adjust a0 to end of display
		addq.w	#1,d2		;
		lsl.w	#2,d2		;
		add.w	d2,a0		;

		move.w	cu_CM+cm_DisplayWidth(a2),d2

saClearYLoop:
		move.l	-(a0),a1
		add.l	a1,a1
		move	#$4,ccr		; zero

		bra.s	saClearXDBF
saClearXLoop:
		bclr	#CMAB_SELECTED&7,(a1)
		addq.l	#2,a1
saClearXDBF:
		dbne	d0,saClearXLoop
		bne.s	saSetXDBF

		move.w	d2,d0
saClearYDBF:
		dbf	d1,saClearYLoop

		bra.s	saHighlightDone	; nothing set, no need for highlight


saSetYLoop:
		move.l	-(a0),a1
		add.l	a1,a1
		bra.s	saSetXDBF

saSetXLoop:
		bclr	#CMAB_SELECTED&7,(a1)
		addq.l	#2,a1
saSetXDBF:
		dbf	d0,saSetXLoop

		move.w	d2,d0
saSetYDBF:
		dbf	d1,saSetYLoop

		bsr	UpdateHighlight

saHighlightDone:
		move.l	(a7)+,d2

saDone:
		bclr	#CDIB_COPY,cd_InputFlags(a6)
		rts


*------ SelectClip ---------------------------------------------------
*
*   cd_SelectFlags SELECTDOWN tells that the select button is down
*   cd_SelectFlags EXTENDED tells that the select button is extended
*   cd_SelectFlags CIRCLING tells that drag select criteria not yet
*	established, and neither has origin of that criteria
*   cd_SelectFlags DRAGGING tells that drag select criteria not yet
*	established
*   cd_SelectFlags SELECTING tells that selection anchor found
*   cd_SelectFlags TICKING tells whether the timer is in use to
*	tick for action
*   cd_SelectedUnit and cu_Flags SELECTED tells which unit has a
*	highlighted area
*
*   called w/ shared lock on USemaphore, so cd_Active won't go away
*
SelectClip:
		movem.l	d2-d7/a2-a5,-(a7)

		move.l	cd_Active(a6),d0
		beq	scDone

		move.l	cd_SelectedUnit(a6),d1	;new selection unit
		beq.s	sc_sameone

		cmp.l	d1,d0			;if same one as before?
		beq.s	sc_sameone

		btst	#CDSB_SELECTDOWN,cd_SelectFlags(a6)
		beq	scDone

		movea.l	d1,a2			;else clear old, and exit
						;this time.
		bsr	scClearSelect
		bra	scDone

sc_sameone:
		movea.l	d0,a2			;clip started
						;or continued

		btst	#CDSB_SELECTDOWN,cd_SelectFlags(a6)
		beq	scUp

		;-- verify the current mouse SELECTDOWN state

		move.w	cd_MouseQual(a6),d0
		
		;button down if left mouse button, or
		;left ALT, and left AMIGA keys are down

		bclr	#IEQUALIFIERB_LEFTBUTTON,d0
		bne.s	scDown

		;@@@@@@ -- note that this is hard coded for now,
		;    -- and therefore cannot be remapped.
		;

		and.w	#IEQUALIFIER_LALT!IEQUALIFIER_LCOMMAND,d0
		cmp.w	#IEQUALIFIER_LALT!IEQUALIFIER_LCOMMAND,d0
		bne	scUp

		;-- get mouse position and convert to display position
scDown:
		move.l	cu_Window(a2),a0

		;-- grab mouse position atomically!
		;-- THIS IS AN ATOMIC OPERATION - LEAVE ME

		move.l	wd_MouseY(a0),d0

		;MouseY is first, then MouseX in Window for sorting purposes
		move.w	d0,cd_MouseX(a6)
		swap.w	d0
		move.w	d0,cd_MouseY(a6)

		moveq	#0,d1		; show nothing clipped to bounds
		;--	get x position
		moveq	#0,d2

*		move.w	wd_MouseX(a0),d2
		move.w	cd_MouseX(a6),d2

		sub.w	cu_XROrigin(a2),d2
		bpl.s	scGenXCP
		moveq	#0,d2
		moveq	#1,d1
scGenXCP:
		divu	cu_XRSize(a2),d2
		;--	get y position
		moveq	#0,d3

*		move.w	wd_MouseY(a0),d3
		move.w	cd_MouseY(a6),d3

		sub.w	cu_YROrigin(a2),d3
		bpl.s	scGenYCP
		moveq	#0,d3
		moveq	#1,d1
scGenYCP:
		divu	cu_YRSize(a2),d3
		;--	bound y position


		move.w	cu_XMax(a2),d0

		cmp.w	cu_DisplayYL(a2),d3
		ble.s	scBoundX
		moveq	#1,d1
		move.w	cu_DisplayXL(a2),d2
		move.w	cu_DisplayYL(a2),d3
		;--	bound x position
scBoundX:
		cmp.w	d0,d2
		ble.s	scBounded	;!!! was 'ble'
					;DisplayWidth == cu_XMax + 1
		moveq	#1,d1

		;-- limit drag selection to x bounds
		move.w	d0,d2		;was move.w d0,d2 - overflow

		;--	check if already dragging or selecting
scBounded:

		;-- check what's happening now
		move.b	cd_SelectFlags(a6),d0
		and.b	#CDSF_DRAGGING!CDSF_SELECTING,d0
		bne.s	scActive

		tst	d1
		beq.s	scDragging
		;--	nothing happening, but outside drag anchor limit
		bset	#CDSB_CIRCLING,cd_SelectFlags(a6)
sc2Done:
		bra	scDone

scDragging:
		;--	nothing happening, start to drag
		bset	#CDSB_DRAGGING,cd_SelectFlags(a6)

*		move.w	wd_MouseX(a0),cd_SelectDownMX(a6)
*		move.w	wd_MouseY(a0),cd_SelectDownMY(a6)
		move.l	cd_MouseX(a6),cd_SelectDownMX(a6)	;and Y

		movem.w	d2/d3,cd_SelectDownCPX(a6)

		lea	cd_SelectDownCPX(a6),a0
		bsr	BoundCPX_Head

		bra.s	sc2Done

scActive:
		btst	#CDSB_SELECTING,cd_SelectFlags(a6)
		bne	scOld

		;--	look for drag criteria
*		move.w	wd_MouseX(a0),d0
		move.w	cd_MouseX(a6),d0

		sub.w	cd_SelectDownMX(a6),d0
		bpl.s	scnPosXDiff
		neg.w	d0
scnPosXDiff:
		move.w	d0,d1
		add.w	d0,d0
		add.w	d0,d0
		cmp.w	cu_XRSize(a2),d0
		bge.s	scnSelecting

*		move.w	wd_MouseY(a0),d0
		move.w	cd_MouseY(a6),d0

		sub.w	cd_SelectDownMY(a6),d0
		bpl.s	scnPosYDiff
		neg.w	d0
scnPosYDiff:
		move.w	d0,d1
		add.w	d0,d0
		add.w	d0,d0
		cmp.w	cu_YRSize(a2),d0
		blt.s	sc2Done

scnSelecting:
		;-- recover original select down origin
		movem.w	cd_SelectDownCPX(a6),d2/d3

		bset	#CDSB_SELECTING,cd_SelectFlags(a6)

		;-- is this selection new, or extended?

		tst.l	cd_SelectedUnit(a6)
		beq.s	scnNewAnchor

		btst	#CDSB_EXTENDED,cd_SelectFlags(a6)
		bne.s	scExtended

scnNew:
		;-- unselect the previously selected area

		bsr	LockDRPort
		move.b	cd_SelectFlags(a6),d4
		bsr	SelectAbort
		move.b	d4,cd_SelectFlags(a6)
		bsr	UnLockRPort

scnNewAnchor:
		;-- select the mouse position
		move.l	a2,cd_SelectedUnit(a6)
		bset	#CUB_SELECTED,cu_Flags(a2)

		bsr	LockDRPort

		movem.w	d2/d3,cd_SelectedAnchorX(a6)
		movem.w	d2/d3,cd_SelectedTailX(a6)

		bsr	BoundCPX_Both

		movem.w	cd_SelectedAnchorX(a6),d2/d3

		move.l	cu_CM+cm_AttrDispLines(a2),a0
		lsl.w	#2,d3
		move.l	0(a0,d3.w),a0
		add.w	d2,a0
		add.l	a0,a0

		;some code to fix that half char artifact

		tst.w	d2		;if first column, always start
		beq.s	scStartSelect
		tst.w	(a0)
		bmi.s	scStartSelect	;if a valid character, start select
		tst.w	-2(a0)
		bmi.s	scStartSelect
		bset	#CDSB_CIRCLING,cd_SelectFlags(a6)
		bra.s	scStartCircle

scStartSelect:
		move.w	cd_SelectedTailX(a6),d1
		sub.w	d2,d1		;should be 0 or 1

		;if Japanese, could be 2 chars - will always be 1
		;if not Japanese mode - this code use to assume Anchor
		;and Tail were always equal

scInitialSelect:
		bset	#CMAB_SELECTED&7,(a0)
		addq.w	#2,a0
		dbf	d1,scInitialSelect

scStartCircle:

		bsr	UpdateHighlight

		bsr	UnLockRPort
		bra	scDone

		;-- selection intermediate action
scOld:
		bsr	LockDRPort
		bra.s	scContinue


scExtended:
		bsr	LockDRPort
		;-- compare current w/ direction of anchor to tail
		move.w	cd_SelectedTailY(a6),d0
		cmp.w	cd_SelectedAnchorY(a6),d0
		bgt.s	scForward
		blt.s	scReverse
		move.w	cd_SelectedTailX(a6),d0
		cmp.w	cd_SelectedAnchorX(a6),d0
		bgt.s	scForward
		blt.s	scReverse
		bra.s	scContinue

		;-- check if current is before anchor
scForward:
		cmp.w	cd_SelectedAnchorY(a6),d3
		bgt.s	scContinue
		blt.s	scReversal
		cmp.w	cd_SelectedAnchorX(a6),d2
		bge.s	scContinue
		bra.s	scReversal

		;-- check if current is after anchor
scReverse:
		cmp.w	cd_SelectedAnchorY(a6),d3
		blt.s	scContinue
		bgt.s	scReversal
		cmp.w	cd_SelectedAnchorX(a6),d2
		ble.s	scContinue

scReversal:
		;-- exchange anchor and tail
		move.l	cd_SelectedAnchorX(a6),d0
		move.l	cd_SelectedTailX(a6),cd_SelectedAnchorX(a6)
		move.l	d0,cd_SelectedTailX(a6)

		;-- set new selection extent
scContinue:
		;-- clear currently selected extent
		;--	check for change in tail

		bsr	BoundCPX_Both	;bound Anchor & Tail

		movem.w	cd_SelectedTailX(a6),d0/d1
		cmp.w	d0,d2
		bne.s	sccGetAnchor
		cmp.w	d1,d3
		beq	scUnlock	; no change in tail

sccGetAnchor:
		movem.w	cd_SelectedAnchorX(a6),d4/d5

		;--	check which is first, tail or anchor
		cmp.w	d1,d5
		bgt.s	scClear
		blt.s	sccSwap
		cmp.w	d0,d4
		bge.s	scClear
sccSwap:
		exg	d0,d4
		exg	d1,d5

		;--	clear d0/d1 to d4/d5
scClear:
		sub.w	d1,d5

		move.w	cu_XMax(a2),d6	; cm_DisplayWidth-1

		move.l	cu_CM+cm_AttrDispLines(a2),a4
		lsl.w	#2,d1
		add.w	d1,a4

sccYLoop:
		move.l	(a4)+,a3
		add.w	d0,a3
		add.l	a3,a3
		tst.w	d5
		bne.s	sccHaveMaxX
		move.w	d4,d6
sccHaveMaxX:
		move.w	d6,d1
		sub.w	d0,d1

sccXLoop:
		bclr	#CMAB_SELECTED&7,(a3)
		addq.l	#2,a3
		dbf	d1,sccXLoop

		moveq	#0,d0

sccYDBF:
		dbf	d5,sccYLoop


		;--	set newly selected extent

		movem.w	d2/d3,cd_SelectedTailX(a6)
		bsr	BoundCPX_Both
		movem.w	cd_SelectedAnchorX(a6),d4/d5
		movem.w	cd_SelectedTailX(a6),d2/d3

		;--	check which is first, new tail or anchor
		cmp.w	d3,d5
		bgt.s	scSet
		blt.s	scsSwap
		cmp.w	d2,d4
		bge.s	scSet
scsSwap:
		exg	d2,d4
		exg	d3,d5

		;--	set d2/d3 to d4/d5
scSet:
		cmp.w	cu_YCCP(a2),d3
		bgt.s	scsCursOutSpan	; cursor < span
		bne.s	scsChkCursYHi
		cmp.w	cu_XCCP(a2),d2
		bgt.s	scsCursOutSpan	; cursor < span
scsChkCursYHi:
		cmp.w	cu_YCCP(a2),d5
		blt.s	scsCursOutSpan	; cursor > span
		bne.s	scsCursInSpan
		cmp.w	cu_XCCP(a2),d4
		blt.s	scsCursOutSpan	; cursor > span
scsCursInSpan:
		bset	#CUB_CURSSELECT,cu_CursorFlags(a2)
		bra.s	scsChkNRender


scsCursOutSpan:
		bclr	#CUB_CURSSELECT,cu_CursorFlags(a2)

scsChkNRender:	move.w	d3,d0
	
		moveq	#$FFFFFFFF,d3	;bit pattern - all 1's

		cmp.w	cu_DisplayYL(a2),d5
		bne.s	scsRender	;not last line

		cmp.w	cu_DisplayXL(a2),d4
		blt.s	scsRender	;if less than 1st invalid X
					;position, its renderable

		;-- turn off rendered, and highlight bit of 1st
		;-- invalid character in buffer.

		move.w	#(~(CMAF_RENDERED!CMAF_HIGHLIGHT))&$FFFF,d3
scsRender:

		sub.w	d0,d5

		move.w	cu_XMax(a2),d6	; cm_DisplayWidth-1

		moveq	#0,d7		; assume initially not prior rendered
		tst.w	d2
		bne.s	scsHavePrior
		move.w	#CMAF_SELECTED,d7 ; ensure first char on line selected
scsHavePrior:
		move.l	cu_CM+cm_AttrDispLines(a2),a4
		lsl.w	#2,d0
		add.w	d0,a4

scsYLoop:
		move.l	(a4)+,a3
		add.w	d2,a3
		add.l	a3,a3
		tst.w	d5
		bne.s	scsHaveMaxX
		move.w	d4,d6
scsHaveMaxX:
		move.w	d6,d1
		sub.w	d2,d1

scsXLoop:
		move.w	(a3),d0
		and.w	#CMAF_RENDERED,d0
		lsr.w	#CMAB_RENDERED-CMAB_SELECTED,d0
		or.w	d0,d7
		or.w	d7,(a3)+
		move.w	d0,d7
		dbf	d1,scsXLoop

		moveq	#0,d2
		move.w	#CMAF_SELECTED,d7 ; ensure first char on line selected

* scsYDBF:
		dbf	d5,scsYLoop
		and.w	d3,-(a3)	;clears SELECT & HIGHLIGHT bits
					;if outside range of valid
					;x/y characters


		;--	update highlight
		bsr	UpdateHighlight

scUnlock:
		bsr	UnLockRPort

scDone:
		bclr	#CDIB_COPY,cd_InputFlags(a6)

		movem.l	(a7)+,d2-d7/a2-a5
		rts


*********************************************************************
*
* This bit of code use to be called when the user drag selected,
* and let up on the mouse button.  It still is, but
*
* It is now recalled when the user presses RIGHT AMIGA C.  The key
* press is caught by the inputhandler which signals the console.device
* task.  A bit is also set in a new field in console.device base.
*
* This new field is used now, and will be used in the future as
* a means of indicating the user pressed a key(s) which are trapped
* by the console device input handler as having some special
* meaning.
*
* Remember that we DONT want the input handler doing much work, so
* it is correct to signal the task to do anything which is time
* consuming.
*
* In this case the user selects a piece of text, and verifies it
* by pressing RIGHT AMIGA C.  The COPY bit in cd_InputFlags
* is immediately cleared if all the conditions in the following
* code are not met.  Any such bits in this field must be cleared
* immediately - so that they don't hang around being left as
* TRUE long after the keypress, or other such event occured.
*

scUp:
		;-- check if any selection in progress
TEMPMASK	EQU	(~(CDSF_CIRCLING!CDSF_DRAGGING!CDSF_SELECTDOWN))&$ff
		and.b	#TEMPMASK,cd_SelectFlags(a6)

************************************************************
* No longer care if we are selecting - may copy later
*		btst	#CDSB_SELECTING,cd_SelectFlags(a6)
*		beq.s	scDone

		;-- make sure it's the active unit
		btst	#CUB_SELECTED,cu_Flags(a2)
		beq.s	scDone

		;-- make sure its the selected unit
		movea.l	cd_SelectedUnit(a6),a0
		cmpa.l	a0,a2
		bne.s	scDone

		;-- make sure the user pressed Right Amiga C
		
		btst	#CDIB_COPY,cd_InputFlags(a6)
		beq.s	scDone

		lea	cd_SelectionSemaphore(a6),a0
		LINKEXE	ObtainSemaphore

		;-- clear out old selection
		move.l	cd_SelectionSnip(a6),d0
		beq.s	scuNoOldClip
		move.l	d0,a1
		subq.w	#1,snip_Access(a1)
		bpl.s	scuNoOldClip
		LINKEXE	FreeVec

scuNoOldClip:
	    ;-- first implementation: store chars, tabs, and line terminators
		movem.w	cd_SelectedAnchorX(a6),d2/d3/d4/d5
		cmp.w	d3,d5
		bgt.s	scuOrdered
		blt.s	scuSwap
		cmp.w	d2,d4
		bge.s	scuOrdered
scuSwap:
		exg	d2,d4
		exg	d3,d5


		;--	get memory for clip
scuOrdered:
		move.w	d5,d0
		sub.w	d3,d0
		addq.w	#1,d0			; for each line, full width
		move.w	cu_CM+cm_DisplayWidth(a2),d1
		addq.w	#1,d1			; linefeeds may occur
		mulu	d1,d0
		sub.w	d2,d0			; unused chars on first line
		sub.w	d4,d1			; unused chars on last line
		sub.w	d1,d0			;   (d1 was width+1, and
		add.w	#3+snip_Data,d0		;   bounds are inclusive,
						;   and null terminated)
		moveq	#0,d1
		LINKEXE	AllocVec
		move.l	d0,cd_SelectionSnip(a6)
		beq	scFailClipData
		move.l	d0,a5
		clr.w	snip_Access(a5)
		addq.l	#snip_Data,a5

		;-- copy from d2/d3 to d4/d5
		sub.w	d3,d5		; # of lines -1 for dbf loop

		move.w	cu_XMax(a2),d6	; cm_DisplayWidth-1


		move.l	cu_CM+cm_AttrDispLines(a2),a4
		lsl.w	#2,d3
		add.w	d3,a4
		moveq	#0,d3		; show first line

scuYLoop:
		move.l	(a4)+,a3
		add.w	d2,a3
		move.l	a3,a0
		add.l	cu_CM+cm_AttrToChar(a2),a0
		add.l	a3,a3		; A3 = attribute map, A0 = char map
		tst.w	d3
		beq.s	scuStartLine
		move.w	(a3),d0		; get attribute
		bpl.s	scuLineSeperator ; not renderable, put in seperator now
		and.w	#CMAF_IMPLICITNL,d0
		bne.s	scuStartLine	; implicit newline, no seperator
scuLineSeperator:
		move.b	#$0a,(a5)+	; insert explicit line seperator
scuStartLine:
		tst.w	d5		; for last line, special case
		bne.s	scuHaveMaxX
		move.w	d4,d6		; max X is in D4
scuHaveMaxX:
		move.w	d6,d1		; calc length of last line
		sub.w	d2,d1		; length of line -1 for dbf loop
		move.w	d1,d0

scuXLoop:
		;check for these bits:
		; RENDERED
		; bogus character at end of map is cleared above

		tst.w	(a3)+
		bpl.s	scuYNext	;quick check for CMAF_RENDERED
					;assumes CMAF_RENDERED is high bit

		move.b	(a0)+,(a5)+
		dbf	d1,scuXLoop

scuYNext:
		moveq	#0,d2
		moveq	#1,d3		; not first line

scuYDBF:
		dbf	d5,scuYLoop

		;-- check what was ended on
		cmp.w	d0,d1		; already got NL at scuLineSeperator?
		beq.s	scuDone		;   yes
		addq.w	#1,d1		; cmp.w #-1,d1
		beq.s	scuDone		; ended on renderable character

		;--	insert a line terminator
		move.b	#$0a,(a5)+	; add newline if ended on
					; bogus character

		;-- determine selection text length
scuDone:
		clr.b	(a5)		; null termination not in actual
		move.l	cd_SelectionSnip(a6),a0
		sub.l	a0,a5
		subq.l	#snip_Data,a5
		move.w	a5,snip_Length(a0)

		pea	snip_Data(a0)
		move.l	a5,-(a7)
scuCallHooks:
		clr.l	-(a7)		; type zero message
		move.l	cd_SelectionHooks(a6),a5
scuHookLoop:
		move.l	(a5),d0
		beq.s	scuHooksDone
		move.l	a5,a0
		move.l	d0,a5
		move.l	a7,a1
		pea	scuHookLoop(pc)		; jsr   (h_Entry(a1))
		move.l	h_Entry(a0),-(a7)	; bra.s scuHookLoop
		rts				;

scuHooksDone:
		lea	12(a7),a7
		lea	cd_SelectionSemaphore(a6),a0
		LINKEXE	ReleaseSemaphore

		bsr.s	scClearSelect
		bra	scDone

scFailClipData:
		clr.l	-(a7)		; null buffer
		clr.l	-(a7)		; zero actual
		bra.s	scuCallHooks

scClearSelect:
		bsr	LockDRPort
		bsr	SelectAbort
		bsr	UnLockRPort
		rts

*------ BoundCPX -----------------------------------------------------
*
*   This is not all that time critical - bound a long word CPX/CPY
*   to the beginning of an EUC bounðary or end of EUC boundary if
*   Japanese mode is enabled.  Save registers, etc., so that this code
*   is slow, but safe (who cares - we are drag selecting anyway)
*
*   A0 - address of long word CPX/CPY to bound
*   A2 - conunit
*   A6 - console device
*
*   D0 used by Beg/End bounding functions

BoundCPX_Both:
	; this code exits quickly if not in Japanese mode

		IS_JAPANESE
		BEQ_S	FindEUC_Ignore			;CC equal

		bsr.s	BoundCPX_End
	;	fall through


	; assume Anchor is < Tail, bound Anchor to beg of EUC
	; if Anchor > Tail, then bound Anchor at end of EUC pair

BoundCPX_Beg:
		lea	cd_SelectedAnchorX(a6),a0
		lea	cd_SelectedTailX(a6),a1

		move.w	2(a1),d0
		cmp.w	2(a0),d0			;is Tail Y < Anchor Y?
		bcs.s	BoundCPX_Tail
		bne.s	BoundCPX_Head			;if not same line, don't compare x
		move.w	(a1),d0
		cmp.w	(a0),d0				;is Tail X < Anchor X?
		bcs.s	BoundCPX_Tail


BoundCPX_Head:
	PRINTF	DBG_FLOW,<'CD--Head $%lx'>,(A0)

		bsr.s	FindEUC_State
		bge.s	FindEUC_Ignore			;alread head or not EUC

		sub.w	#1,(a0)				; decrement X
		rts

BoundCPX_End:

	; assume Anchor is < Tail, bound Tail to end of EUC
	; if Anchor > Tail, then bound Tail at head of EUC pair

		lea	cd_SelectedTailX(a6),a0
		lea	cd_SelectedAnchorX(a6),a1

		move.w	2(a0),d0
		cmp.w	2(a1),d0			;is Tail Y < Anchor Y?
		bcs.s	BoundCPX_Head
		bne.s	BoundCPX_Tail			;if not same line, don't compare x
		move.w	(a0),d0
		cmp.w	(a1),d0				;is Tail X < Anchor X?
		bcs.s	BoundCPX_Head


BoundCPX_Tail:
	PRINTF	DBG_FLOW,<'CD--Tail $%lx'>,(A0)

		bsr.s	FindEUC_State
		ble.s	FindEUC_Ignore			;already tail or not EUC

		addq.w	#1,(a0)				; increment X

FindEUC_Ignore:
		rts

*
* Determine if X byte is not EUC, BEGIN EUC, END EUC, or invalid (not EUC)
*
* in
*   A0 pointer to long word (x and y position)
* return
*   All registers preserved
*   CC 0 not EUC, 1 BEG EUC, -1 END EUC
*

FindEUC_State:
	; this code exits quickly if not in Japanese mode

		IS_JAPANESE
		beq.s	FindEUC_Ignore			;CC equal

		movem.l	d1-d5/a1/a3/a4,-(sp)

		move.l	(a0),d2				;x & y
		move.w	d2,d3				;D3 = y
		swap	d2				;D2 = x

		lsl.w	#2,d3
		move.l	cu_CM+cm_AttrDispLines(a2),a3
		move.l	0(a3,d3.w),a3
		move.l	a3,a4
		add.l	cu_CM+cm_AttrToChar(a2),a3	;chars
		add.l	a4,a4				; attributes

	; now scan forward line to find state of x (not EUC, beg EUC, end EUC)

		move.w	d2,d1				;already a 0 based number for DBF loop
		moveq	#00,d4				;assume not EUC

bpx_findeucstate:		

		moveq	#00,d5				;invalid state | not EUC

		move.b	(a3)+,d3			;cache for compare below

		tst.w	(a4)+				;high bit set if valid
		bpl.s	EUC_Invalid

		cmp.b	#EUC_LOCHAR,d3
		bcs.s	bpx_nextbyte

		addq.w	#1,d4				;0->1 beg EUC | 1->2 end EUC | 2->3 beg EUC
		move.w	d4,d5

		cmp.w	#2,d4
		bls.s	bpx_nextbyte

		moveq	#1,d5				;back to first byte stage

bpx_nextbyte:
		move.w	d5,d4
		dbf	d1,bpx_findeucstate
		
	; If beginning of EUC pair, next byte of line must be a valid second
	; EUC byte

		cmp.w	#1,d4
		bne.s	FoundEUC_Done

		moveq	#00,d5

	; If X is end of line, EUC byte is invalid

		addq.w	#1,d2				; x position is 0 based
		cmp.w	cu_CM+cm_DisplayWidth(a2),d2	; DisplayWidth is 1 based
		beq.s	EUC_Invalid

	; check if next EUC byte is valid, and an end of EUC pair

		tst.w	(a4)
		bpl.s	EUC_Invalid

		move.b	(a3),d3
		cmp.b	#EUC_LOCHAR,d3
		bcs.s	EUC_Invalid			; not really EUC

		move.w	d4,d5

EUC_Invalid:
		move.w	d5,d4

FoundEUC_Done:

	PUSHWORD	d4
	PRINTF	DBG_FLOW,<'CD--EUC STATE %ld'>
	POPLONG		1

		cmp.w	#2,d4
		bne.s	return_EUC_State
		moveq	#-1,d4
return_EUC_State:
		tst.w	d4				;set CC
		movem.l	(sp)+,d1-d5/a1/a3/a4		;CC not affected

		rts


	END
@


36.47
log
@First pass at using input events for mouse tracking instead
of PeekQualifier() - makes it possible to use tablet drivers/etc.
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.46 91/04/12 17:40:58 darren Exp $
d20 2
d255 1
d277 4
d346 5
d369 8
d378 3
d434 3
d489 3
d493 1
a493 1
		movem.w	d2/d3,cd_SelectedTailX(a6)
d798 179
@


36.46
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.45 91/01/23 16:08:57 darren Exp Locker: darren $
d175 2
a176 4
		move.l	a6,a5
		move.l	cd_HandlerIOR+IO_DEVICE(a6),a6
		CALLLVO	PeekQualifier
		move.l	a5,a6
@


36.45
log
@Kodiak's fix to clear the rendered bit of the 1st invalid character
in the map could be faked out by dragging above the 1st invalid
character, and then moving the cursor down to past the 1st invalid
character on the last line.  Change of bne.s to blt.s; removed one
extra branch instruction too.
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.44 91/01/21 11:15:00 darren Exp Locker: darren $
@


36.44
log
@Fix for the spurious character highlighting bug
finally tracked down to a reproducable case
in VI when inserting, or deleting empty lines.

Also removed some extra code.
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.43 91/01/03 18:54:19 darren Exp Locker: darren $
d501 2
d504 1
a504 1
		bne.s	scsNoNRender
d507 2
a508 1
		bne.s	scsNoNRender	;oops, don't render this one
d510 3
d514 1
a514 1
		bra.s	scsSpan
a515 5
scsNoNRender:

		moveq	#$FFFFFFFF,d3	;bit pattern - all 1's

scsSpan:
@


36.43
log
@Support code for change to scroll.asm.  DisplayXL
limited to XMax for case when DisplayYL is == YMax.
Smaller too - got rid of some redundant code.
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.42 90/12/13 11:03:16 darren Exp Locker: darren $
a237 3
** grr, this was right the first time
**		move.w	cu_CM+cm_DisplayWidth(a2),d0	;was cu_XMax(a2)

d314 4
a317 1
		move.l	cd_SelectedUnit(a6),d1
a319 3
		cmp.l	d1,a2
		bne.s	scnNew

d324 1
a324 2
		;-- unselect the (now inactive) selected unit
		move.l	d1,a2
a331 2
		movea.l	cd_Active(a6),a2

a434 6
		move.w	cu_CM+cm_DisplayWidth(a2),d6	;was cu_XMax(a2)
************************
* D1 can go negative - wrong
* No change in code size
*
*		move.w	cu_XMax(a2),d6	; cm_DisplayWidth-1
d436 2
d517 1
a517 6
		move.w	cu_CM+cm_DisplayWidth(a2),d6	;was cu_XMax(a2)
************************
* D1 can go negative - wrong
* No change in code size
*
*		move.w	cu_XMax(a2),d6	; cm_DisplayWidth-1
a670 5
* Appears to do nothing here, so I use this register
* and set it to 0 later on.
*
*		moveq	#0,d7		; assume initially not rendered
*
a717 7

		;-- reset D7 to 0 as above - who knows what this does
		;-- later on, if used at all?
		;-- I set this just to be -safe- for now
		;-- since its previous use was not documented above.

		moveq	#00,d7
@


36.42
log
@Fix for extra character added to snip when a long wrapped line
is copied.
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.41 90/12/03 12:22:18 darren Exp Locker: darren $
d242 1
a242 2
		blt.s	scBoundX
		beq.s	scLimitY
a245 2
scLimitY:
		move.w	cu_DisplayXL(a2),d0
d249 1
a249 1
		blt.s	scBounded	;!!! was 'ble'
@


36.41
log
@Fix for a bug which creeped in - junk when drag selecting
last line of text.
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.40 90/12/02 06:03:10 darren Exp Locker: darren $
d687 1
a687 7
		move.w	cu_CM+cm_DisplayWidth(a2),d6	;was cu_XMax(a2)

************************
* D1 can go negative - wrong
* No change in code size
*
*		move.w	cu_XMax(a2),d6	; cm_DisplayWidth-1
@


36.40
log
@Put back some previous code to get around that race
condition.
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.39 90/12/02 05:23:05 darren Exp Locker: darren $
d236 1
a236 3
		;--	!!!!!!!!!!!!!!!!!!!!!!!!!!!
		;--	!!Should be DisplayWidth?!!
		;--	!!!!!!!!!!!!!!!!!!!!!!!!!!!
d238 2
a239 1
		move.w	cu_CM+cm_DisplayWidth(a2),d0	;was cu_XMax(a2)
d257 1
a257 1
		move.w	cu_XMax(a2),d2	;was move.w d0,d2 - overflow
@


36.39
log
@Fixes spurious characters in map bug while highlighting.  Fixes
half-character artifacts, and left-over bits.  Fixes extended
select feature.
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.38 90/11/30 22:28:07 darren Exp Locker: darren $
a164 6

		;fix race condition

*		move.l	cd_Active(a6),d0
*		cmp.l	(a7),d0

d334 5
a338 7
		bsr	scClearSelect

**		bsr	LockDRPort
**		move.b	cd_SelectFlags(a6),d4
**		bsr	SelectAbort
**		move.b	d4,cd_SelectFlags(a6)
**		bsr	UnLockRPort
a341 3
**		cmpa.l	(a7),a2
**		bne	scDone

d794 1
a794 3
		bsr	LockDRPort
		bsr	SelectAbort		;and clear highlight
		bsr	UnLockRPort
a803 1
		move.b	cd_SelectFlags(a6),d4
a804 1
		move.b	d4,cd_SelectFlags(a6)
@


36.38
log
@A change in behavior slipped in when fixing the last race
condition bug - you could RIGHT AMIGA C in another window, and
have your highlighted area go away without actually pasting.
Tested again - race condition problem still resolved, and
preferred behavior of RA-C restored.
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.37 90/11/30 00:29:49 darren Exp Locker: darren $
d165 6
d262 4
a265 1
		move.w	d0,d2		; limit X to display
d332 2
a333 1
		btst	#CDSB_EXTENDED,d0
d339 13
a351 6
		bsr	LockDRPort
		move.b	cd_SelectFlags(a6),d4
		bsr	SelectAbort
		move.b	d4,cd_SelectFlags(a6)
		bsr	UnLockRPort
		move.l	cd_Active(a6),a2
d367 13
d381 1
d384 1
d596 1
d805 3
a807 1
		bsr.s	scClearSelect
d817 3
a819 1
		bsr	SelectAbort		;and clear highlight
a821 1

@


36.37
log
@Another shot at that bug when another window goes active
while drag selecting.
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.36 90/11/29 23:19:20 darren Exp Locker: darren $
d153 1
a153 1
		move.l	cd_SelectedUnit(a6),d1
d156 1
a156 1
		cmp.l	d1,d0
d159 2
a160 1
		movea.l	d1,a2
d162 2
d165 1
a166 3
		move.l	cd_Active(a6),d0
		beq	scDone

d168 2
a169 1
		movea.l	d0,a2
d772 1
a772 1
		bsr	scClearSelect
@


36.36
log
@Bug fix - found a race condition - if you were drag selecting
while a new window became active, you'd get into a situation
in which there was confusion (also enforcer hits, lockups,
etc.).
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.35 90/11/09 21:23:22 darren Exp Locker: darren $
d150 5
a154 2
		move.l	cd_SelectedUnit(a6),d0
		bne.s	sc_sameone
d156 7
d165 1
d167 1
a167 1
		move.l	d0,a2
d770 1
a770 3
		bsr	LockDRPort
		bsr	SelectAbort		;and clear highlight
		bsr	UnLockRPort
d777 6
@


36.35
log
@Fix for crashing when dragging past left
edge of window (right if viewed from the
user perspective).  Also examines window
mouse coordinates atomically now - one
atomic copy.
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.34 90/11/07 15:20:56 darren Exp Locker: darren $
d150 3
d155 1
@


36.34
log
@Added code to support RIGHT AMIGA C.
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.33 90/11/02 08:09:41 darren Exp Locker: darren $
d64 1
a64 1
		beq	saDone		;.s!
d72 1
a72 1
		beq	saDone		;.s!
d180 11
d194 4
a197 1
		move.w	wd_MouseX(a0),d2
d206 4
a209 1
		move.w	wd_MouseY(a0),d3
d257 5
a261 2
		move.w	wd_MouseX(a0),cd_SelectDownMX(a6)
		move.w	wd_MouseY(a0),cd_SelectDownMY(a6)
d270 3
a272 1
		move.w	wd_MouseX(a0),d0
d283 3
a285 1
		move.w	wd_MouseY(a0),d0
d407 7
a413 1
		move.w	cu_XMax(a2),d6	; cm_DisplayWidth-1
d493 7
a499 1
		move.w	cu_XMax(a2),d6	; cm_DisplayWidth - 1
d649 7
a655 1
		move.w	cu_XMax(a2),d6	; cm_DisplayWidth - 1
@


36.33
log
@short branch optimizations
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.32 90/08/13 17:59:20 darren Exp Locker: darren $
d18 1
d62 1
d64 1
a64 1
		beq.s	saDone
d72 1
a72 1
		beq.s	saDone
d127 1
d510 1
d515 26
a540 1
		;-- cut selection
d545 6
a550 2
		bclr	#CDSB_SELECTING,cd_SelectFlags(a6)
		beq.s	scDone
d555 10
d713 3
@


36.32
log
@Bug fix: Now recognizes Left Alt/
Left Amiga as a left mouse down
event.
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.30 90/07/26 11:38:15 darren Exp $
d164 1
a164 1
		bne	scDown
d280 1
a280 1
		bne	scExtended
@


36.31
log
@Changed fix for erroneous character
in display map (end of map) to
be more robust.
@
text
@d159 3
a161 2
		btst	#IEQUALIFIERB_LEFTBUTTON,d0
		beq	scUp
d163 11
d175 1
@


36.30
log
@No significant change.  Change use
of vertical bar for OR to an
exclamation mark.
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.29 90/07/26 11:14:09 darren Exp Locker: darren $
d184 8
a191 1
		move.w	cu_XMax(a2),d0
d203 2
a204 1
		ble.s	scBounded
d423 1
a423 1
		bra.s	scsSpan
d425 1
d429 15
d445 2
a446 1
		sub.w	d3,d5
d454 2
a455 2
		lsl.w	#2,d3
		add.w	d3,a4
d480 1
a480 1
scsYDBF:
d482 3
d595 2
a596 2
		; RENDERED | SELECTED | HIGHLIGHT
		;
d598 1
a598 1
		move.w	(a3)+,d7
a600 6

		;if rendered, check for SELECTED & HIGHLIGHT bits

		andi.w	#CMAF_SELECTED!CMAF_HIGHLIGHT,d7
		cmpi.w	#CMAF_SELECTED!CMAF_HIGHLIGHT,d7
		bne	scuYNext
@


36.29
log
@Bug fix.  Erroneous character when marking
the last possible character in a block.
Fixed by checking for selected, and
highlighted flag.  NL inserted in clip
if block ends on a bogus character.
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.28 90/05/30 14:23:16 kodiak Exp Locker: darren $
d576 2
a577 2
		andi.w	#CMAF_SELECTED|CMAF_HIGHLIGHT,d7
		cmpi.w	#CMAF_SELECTED|CMAF_HIGHLIGHT,d7
@


36.28
log
@notice left button up using new PeekQualifier input.device function
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.27 90/05/29 18:22:19 kodiak Exp Locker: kodiak $
d6 1
a6 1
**      (C) Copyright 1989 Commodore-Amiga, Inc.
d527 10
a536 3
		sub.w	d3,d5
		move.w	cu_XMax(a2),d6	; cm_DisplayWidth + 1
		moveq	#0,d7		; assume initially not rendered
d547 1
a547 1
		add.l	a3,a3
d550 1
a550 1
		move.w	(a3),d0
d557 1
a557 1
		tst.w	d5
d559 1
a559 1
		move.w	d4,d6
d561 2
a562 2
		move.w	d6,d1
		sub.w	d2,d1
d566 14
a579 2
		tst.w	(a3)+
		bpl.s	scuYNext
d590 4
d595 2
d604 2
a605 2
		move.b	#$0a,(a5)+

@


36.27
log
@will not initiate a selection when not over a character
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.26 90/05/25 16:13:30 kodiak Exp Locker: kodiak $
d32 2
d148 1
a148 1
		beq.s	sc2Done
d150 1
a150 1
		;-- handle mouse button up
d154 8
d473 2
a474 1
		and.b	#(~(CDSF_CIRCLING!CDSF_DRAGGING))&$ff,cd_SelectFlags(a6)
@


36.26
log
@USemaphore lock redundant: removed.
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.25 90/05/25 15:57:23 kodiak Exp Locker: kodiak $
d130 2
d146 1
a146 1
		beq	scDone
d154 11
a164 1
		move.w	cu_XMax(a2),d0
d168 4
a171 1
		bmi	scDone
d173 2
d176 6
a181 1
		blt.s	scHaveMaxX
d183 2
a184 8
		subq.w	#1,d0
		move.w	cu_DisplayYL(a2),d3
scHaveMaxX:
		moveq	#0,d2
		move.w	wd_MouseX(a0),d2
		sub.w	cu_XROrigin(a2),d2
		bmi	scDone
		divu	cu_XRSize(a2),d2
d186 2
a187 1
		ble.s	scCheckInProgress
d189 2
a191 1
scCheckInProgress:
d195 9
d209 1
a209 1
		bra	scDone
d236 1
a236 1
		blt	scDone
d242 1
a242 4
		move.b	cd_SelectFlags(a6),d0
		bclr	#CDSB_DRAGGING,d0
		bset	#CDSB_SELECTING,d0
		move.b	d0,cd_SelectFlags(a6)
d463 1
a463 1
		bclr	#CDSB_DRAGGING,cd_SelectFlags(a6)
@


36.25
log
@ensures active window is not null before performing clip highlight
operations on it
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.24 90/05/14 23:15:19 kodiak Exp Locker: kodiak $
a29 1
	XLVO	ObtainSemaphoreShared	;
d138 2
a142 3
		lea	cd_USemaphore(a6),a0
		LINKEXE	ObtainSemaphoreShared

a431 3
		lea	cd_USemaphore(a6),a0
		LINKEXE	ReleaseSemaphore

@


36.24
log
@better snip notification code
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.23 90/04/25 17:29:55 kodiak Exp Locker: kodiak $
d30 1
d141 7
a147 1
		move.l	cd_Active(a6),a2
d434 3
@


36.23
log
@ensure cd_SelectedUnit doesn't go NIL
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.22 90/04/20 09:45:22 kodiak Exp Locker: kodiak $
d562 1
a562 1
		move.l	h_Entry(a1),-(a7)	; bra.s scuHookLoop
@


36.22
log
@first semi-tested big clip support
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.21 90/04/17 11:20:12 kodiak Exp $
d60 3
a63 1
		and.b	#CDS_SELECTMASK,cd_SelectFlags(a6)
d66 1
d135 2
a136 2
*   cu_Flags SELECTED tells whether this is the SelectedUnit w/ a
*	hilighted area
a432 2
CDSF_MASK	SET	(~(CDSF_DRAGGING!CDSF_SELECTING))&$ff
		and.b	#CDSF_MASK,cd_SelectFlags(a6)
d434 2
a435 1
		move.l	a2,d0		; is there an active unit?
d437 1
a453 1
		move.l	cd_SelectedUnit(a6),a2
@


36.21
log
@cursor-in-selection is now specially ghosted
@
text
@d2 1
a2 1
**	$Id: clip.asm,v 36.20 90/04/13 13:32:23 kodiak Exp Locker: kodiak $
d27 2
a28 3
	XLVO	AllocMem		; Exec
	XLVO	Forbid			;
	XLVO	FreeMem			;
a29 1
	XLVO	Permit			;
a33 2
	XREF	PutBBuff
	XREF	CDRead
d442 1
a442 1
		move.l	cd_SelectionSize(a6),d0
d444 4
a447 2
		move.l	cd_SelectionText(a6),a1
		LINKEXE	FreeMem
d474 1
a474 1
		addq.w	#3,d0			;   bounds are inclusive,
a475 1
		move.l	d0,cd_SelectionSize(a6)
d477 2
a478 2
		LINKEXE	AllocMem
		move.l	d0,cd_SelectionText(a6)
d481 2
d543 4
a546 2
		sub.l	cd_SelectionText(a6),a5
		move.w	a5,cd_SelectionActual(a6)
d548 2
a550 4
		move.l	cd_SelectionText(a6),-(a7)
		moveq	#0,d0
		move.w	cd_SelectionActual(a6),d0
		move.l	d0,-(a7)
d571 2
a572 2
		clr.l	cd_SelectionSize(a6)
		clr.w	cd_SelectionActual(a6)
@


36.20
log
@use Id instead of Header for 4.x rcs
@
text
@d2 1
a2 1
**	$Id$
d66 1
d364 19
@


36.19
log
@for 4.x rcs
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/clip.asm,v 36.18 90/03/02 16:21:02 kodiak Exp Locker: kodiak $
@


36.18
log
@Fixes select guru bug (typo)
@
text
@d2 1
a2 1
**	$Header: clip.asm,v 36.17 90/03/01 17:42:28 kodiak Exp $
@


36.17
log
@set up a2 for scUp, and abort if null
@
text
@d2 1
a2 1
**	$Header: clip.asm,v 36.16 90/03/01 17:14:40 kodiak Exp $
d528 1
a528 1
		move.l	cd_SelectionText(a5),-(a7)
@


36.16
log
@don't grab selection upon cursor up when there is no selection
@
text
@d2 1
a2 1
**	$Header: clip.asm,v 36.15 90/02/26 20:25:07 kodiak Exp $
d140 1
a145 1
		move.l	cd_Active(a6),a2
d417 2
a419 2
		beq.s	scDone
		tst.l	cd_SelectedUnit(a6)
@


36.15
log
@call hooks when selection changes
@
text
@d2 1
a2 1
**	$Header: clip.asm,v 36.14 90/02/22 09:56:56 kodiak Exp $
d418 2
@


36.14
log
@reduce to drag select criteria to 1/4 cell size from 1/2 cell size
@
text
@d2 1
a2 1
**	$Header: clip.asm,v 36.13 90/02/21 18:40:20 kodiak Exp $
d16 1
d30 1
d32 1
d420 3
d454 2
a455 1
		addq.w	#2,d0			;   bounds are inclusive)
d460 1
a460 1
		beq.s	scFailClipData
d521 1
d524 23
d552 1
a552 1
		bra	scDone
@


36.13
log
@first cut at drag-select
@
text
@d2 1
a2 1
**	$Header: clip.asm,v 36.12 89/12/15 22:42:09 kodiak Exp $
d186 1
d188 1
d197 2
@


36.12
log
@fix highlight at Display.L
@
text
@d2 1
a2 1
**	$Header: clip.asm,v 36.11 89/12/04 22:55:31 kodiak Exp $
d60 1
a60 1
		bclr.b	#CUB_SELECTING,cu_Flags(A2)
d125 6
a130 6
*   cu_SelectFlags SELECT tells that the select action is starting or
*	in progress
*   cu_SelectFlags EXTENDED tells that the select action starting or
*	in progress is extended
*   cu_SelectFlags TICKED tells that this action is in progress
*   cu_SelectFlags TICKING tells whether the timer is in use to
d132 1
a132 1
*   cu_Flags SELECTING tells whether this is the SelectedUnit w/ a
a134 22
*   Possibilities
*	if not SELECT
*	    if SELECTING
*		copy the current range to the clip store
*	else SELECT
*	    get cursor location current
*	    if not TICKED and not EXTENDED  or  not SELECTING
*		if SelectedUnit != NULL
*		    SelectAbort SelectedUnit
*		set SelectedUnit to Active
*		render current to current
*		set anchor and tail to current
*	    else TICKED and/or EXTENDED  and  SELECTING
*		if not TICKED
*		    if current < anchor
*			exchange anchor tail
*		if current > tail
*		    render tail+1 to current
*		else current <= tail
*		    render current to tail
*		set tail to current
*	
d138 1
a138 1
		btst	#CDSB_SELECT,cd_SelectFlags(a6)
d164 1
a164 1
		;-- check if any selection in progress
d166 9
a174 2
		btst	#CUB_SELECTING,cu_Flags(a2)
		beq.s	scNew
d176 27
d204 5
a208 2
		and.b	#CDSF_EXTENDED!CDSF_TICKED,d0
		bne.s	scOld
d210 4
a213 3
scNew:
		move.l	cd_SelectedUnit(a6),d0
		beq.s	scsNew
d215 1
d217 1
a217 1
		move.l	d0,a2
d225 1
a225 1
scsNew:
d228 1
a228 1
		bset	#CUB_SELECTING,cu_Flags(a2)
d248 1
a249 2
		btst	#CDSB_TICKED,cd_SelectFlags(a6)
		bne.s	scContinue
d251 2
d407 2
d410 1
a410 1
		btst	#CUB_SELECTING,cu_Flags(a2)
@


36.11
log
@checkin for release on Monday 4 Dec -- map w/ indirect line buffers
@
text
@d2 1
a2 1
**	$Header: clip.asm,v 36.10 89/12/02 11:36:30 kodiak Exp $
d175 1
@


36.10
log
@checkpoint after line buffer coding completed,
and just after start of line length coding
@
text
@d2 1
a2 1
**	$Header$
d50 3
d70 1
d72 4
d77 1
a77 1
		bra.s	saClearYDBF
d80 4
a83 8
		move.w	cu_CM+cm_DisplayWidth(a2),d0
		tst.w	d1
		bne.s	saClearHaveXCount
		move.w	cu_DisplayXL(a2),d0
saClearHaveXCount:
		move.l	(a0)+,a1
		add.w	a1,a1
		moveq	#0,d2		; clear CCR
a84 1

d86 2
a87 2
		bclr	#CMAB_SELECTED&7,(a0)
		addq.l	#2,a0
d92 1
d95 1
d100 2
a101 8
		move.w	cu_CM+cm_DisplayWidth(a2),d0
		tst.w	d1
		bne.s	saSetHaveXCount
		move.w	cu_DisplayXL(a2),d0
saSetHaveXCount:
		move.l	(a0)+,a1
		add.w	a1,a1
		moveq	#0,d2		; clear CCR
d105 2
a106 2
		bclr	#CMAB_SELECTED&7,(a0)
		addq.l	#2,a0
d110 1
d173 1
a173 2
		bge	scDone
		bne.s	scHaveMaxX
d175 1
d183 2
a184 1
		bge	scDone
d186 1
d217 3
a219 3
		lsl	#2,d2
		move.l	0(a0,d2.w),a0
		add.w	d3,a0
d294 2
a295 3
		move.w	cu_CM+cm_DisplayWidth(a2),d6
		subq	#1,d6
		move.l	cu_CM+cm_AttrDispLines(a2),a0
d297 1
a297 2
		move.l	0(a0,d1.w),a4
		bra.s	sccYDBF
d338 1
a338 2
		move.w	cu_CM+cm_DisplayWidth(a2),d6
		subq	#1,d6
d344 1
a344 1
		move.l	cu_CM+cm_AttrDispLines(a2),a0
d346 1
a346 2
		move.l	0(a0,d3.w),a4
		bra.s	scsYDBF
d401 1
a401 2
		movem.w	cd_SelectedAnchorX(a6),d2/d3
		movem.w	cd_SelectedTailX(a6),d4/d5
d433 1
a433 2
		move.w	cu_CM+cm_DisplayWidth(a2),d6
		subq	#1,d6
d435 1
a435 1
		move.l	cu_CM+cm_AttrDispLines(a2),a0
d437 1
a437 1
		move.l	0(a0,d3.w),a4
a438 1
		bra.s	scuYDBF
d448 6
a453 3
		btst.b	#CMAB_IMPLICITNL&7,(a3)
		bne.s	scuStartLine
		move.b	#$0a,(a5)+	; insert explicit line terminator
d455 4
d461 1
d464 1
a464 1
		move.w	(a3)+,d0
a466 1
		moveq	#0,d7
a471 1
		or.w	d0,d7		; cache if selected non-rendered
d478 4
a481 2
		btst	#CMAB_SELECTED,d7
		beq.s	scuDone
@


36.9
log
@restructure map variables
use XLVO macro scheme
@
text
@d1 9
a9 10
	TTL	'$Header: clip.asm,v 36.8 89/09/15 15:37:07 kodiak Exp $'
**********************************************************************
*
*			--------------
*   clip.asm		CONSOLE DEVICE	manipulate a console clip
*			--------------
*
*   Copyright 1988 Commodore-Amiga Inc.
*
**********************************************************************
d11 1
a11 1
	SECTION		rawinput
a12 2
*------ Included Files -----------------------------------------------

a14 1
	INCLUDE		"exec/memory.i"
d18 1
a18 3
	IFNE	(CMAB_SELECTED/8)-1
	FAIL	"CMAB_SELECTED not in high byte, recode"
	ENDC
d20 2
a22 1
*------ Imported Names -----------------------------------------------
d24 2
d31 4
a34 4
	XREF		LockDRPort
	XREF		UnLockRPort
	XREF		PutBBuff
	XREF		CDRead
d36 1
a36 1
	XREF		UpdateHighlight
d39 1
a39 1
*------ Exported Functions -------------------------------------------
d41 12
a52 2
	XDEF		SelectAbort
	XDEF		SelectClip
d54 1
d57 3
a59 1
		BCLR	#CUB_SELECTING,cu_Flags(A2)
d61 1
a61 1
		move.w	cu_CM+cm_Elements(a2),d0
d64 4
a67 3
		move.l	cu_CM+cm_AttrBuffer(a2),a0
		moveq	#0,d1		; clear CCR
		bra.s	saClearClearDb
d69 14
a82 1
saClearClearLoop:
d85 3
a87 4
saClearClearDb:
		dbne	d0,saClearClearLoop
		bne.s	saClearSetDb
		bra.s	saDone
d89 17
a105 1
saClearSetLoop:
d108 2
a109 2
saClearSetDb:
		dbf	d0,saClearSetLoop
d111 3
d116 3
a119 2
		clr.l	cd_SelectedUnit(a6)
		and.b	#CDS_SELECTMASK,cd_SelectFlags(a6)
d158 1
a158 1
		movem.l	d2-d7/a2-a3,-(a7)
d163 1
a163 1
		;-- get mouse position and convert to display buffer offset
d166 4
a169 3
		moveq	#0,d0
		move.w	wd_MouseX(a0),d0
		sub.w	cu_XROrigin(a2),d0
d171 6
a176 3
		divu	cu_XRSize(a2),d0
		cmp.w	cu_XMax(a2),d0
		bgt	scDone
d178 2
a179 2
		move.w	wd_MouseY(a0),d2
		sub.w	cu_YROrigin(a2),d2
d181 3
a183 5
		divu	cu_YRSize(a2),d2
		cmp.w	cu_YMax(a2),d2
		bgt	scDone
		mulu	cu_CM+cm_DisplayWidth(a2),d2
		add.w	d0,d2
d199 1
a199 1
		move.b	cd_SelectFlags(a6),d3
d201 1
a201 1
		move.b	d3,cd_SelectFlags(a6)
d206 1
d211 10
a220 4
		move.w	d2,d0
		add.w	d0,d0
		move.l	cu_CM+cm_AttrDisplay(a2),a0
		bset	#CMAB_SELECTED&7,0(a0,d0.w)
a222 2
		move.w	d2,cd_SelectedAnchorOffset(a6)
		move.w	d2,cd_SelectedTailOffset(a6)
d233 2
a234 2
		move.w	cd_SelectedTailOffset(a6),d0
		cmp.w	cd_SelectedAnchorOffset(a6),d0
d237 4
d245 4
a248 1
		cmp.w	cd_SelectedAnchorOffset(a6),d2
d254 4
a257 1
		cmp.w	cd_SelectedAnchorOffset(a6),d2
d262 3
a264 3
		move.w	cd_SelectedAnchorOffset(a6),d0
		move.w	cd_SelectedTailOffset(a6),cd_SelectedAnchorOffset(a6)
		move.w	d0,cd_SelectedTailOffset(a6)
d268 7
a274 6
		;--	clear currently selected extent
		movem.w	cd_SelectedAnchorOffset(a6),d0-d1
		cmp.w	d1,d2
		beq.s	scUnlock	; no change in tail
		sub.w	d0,d1
;!!!		beq.s	scSetContinue	; no need to clear if anchor == tail
d276 8
a283 1
		move.l	cu_CM+cm_AttrDisplay(a2),a0
d285 3
a287 2
		add.w	d1,d0
		neg.w	d1
d289 1
a289 1
		;--	clear anchor to tail
d291 7
a297 2
		add.w	d0,d0
		add.w	d0,a0
d299 10
a308 5
		;--	clear current selection
scClearLoop:
		bclr	#CMAB_SELECTED&7,(a0)
		addq.l	#2,a0
		dbf	d1,scClearLoop
d310 4
d315 6
d322 8
a329 5
;!!!scSetContinue:
		move.l	cu_CM+cm_AttrDisplay(a2),a0
		move.w	cd_SelectedAnchorOffset(a6),d0
		move.w	d2,d1
		sub.w	d0,d1
d331 3
a333 2
		add.w	d1,d0
		neg.w	d1
d335 1
a335 1
		;--	set anchor to tail
d337 12
a348 14
		moveq	#0,d5		; initially not prior rendered char
		moveq	#0,d4		; save offset for below
		move.w	d0,d4		;
		add.w	d0,d0		; convert to word offset
		add.w	d0,a0		; get attribute start word
		move.w	cu_CM+cm_DisplayWidth(a2),d3
		divu	d3,d4		; calculate distance to next line
		swap	d4		;   break after selection start
		subq	#1,d3		; (need BufferWidth-1 for later)
		tst.w	d4		; (special case: selection starts on
		beq.s	scsLoop		;   beginning of line)
		sub.w	d3,d4		; 
		neg.w	d4		;
		addq.w	#1,d4		;
d350 13
a362 8
		;--	set current selection
scsLoop:
		subq.w	#1,d4
		bpl.s	scsChkAttr
		move.w	d3,d4
		move.w	#CMAF_SELECTED,d5 ; ensure first char on line selected
scsChkAttr:
		move.w	(a0),d0
d365 4
a368 4
		or.w	d0,d5
		or.w	d5,(a0)+
		move.w	d0,d5
		dbf	d1,scsLoop
d370 2
a371 2
		;--	set new tail offset
		move.w	d2,cd_SelectedTailOffset(a6)
d373 4
d384 1
a384 1
		movem.l	(a7)+,d2-d7/a2-a3
d387 1
d396 1
a396 1
		beq.s	scNoOldClip
d400 1
a400 1
scNoOldClip:
d403 13
a415 7
		moveq	#0,d0
		move.w	cd_SelectedAnchorOffset(a6),d2
		move.w	cd_SelectedTailOffset(a6),d3
		sub.w	d2,d3
		bpl.s	scuOrdered
		add.w	d3,d2
		neg.w	d3
d417 10
a426 3
		move.w	d3,d0
		addq.w	#1,d0		; start & end are inclusive
		add.w	cu_CM+cm_DisplayHeight(a2),d0	; linefeeds may occur
d432 1
a432 1
		move.l	d0,a3
d434 10
a443 7
		;-- initialize a0/a1 to char/attr start
		move.l	cu_CM+cm_CharDisplay(a2),a0
		add.w	d2,a0
		move.l	cu_CM+cm_AttrDisplay(a2),a1
		move.w	d2,d0
		add.w	d0,d0
		add.w	d0,a1
d445 14
a458 8
		;-- adjust d2 as col counter
		move.w	cu_CM+cm_DisplayWidth(a2),d5
		divu	d5,d2
		swap	d2		; get remainder
		sub.w	d5,d2
		neg.w	d2
		move.w	d2,d4		; "last rendered counter"
		bra.s	scuChkRendered
d460 6
a465 6
		;-- loop thru character buffer
scuLoop:
		addq.l	#1,a0		; increment char buffer
		addq.l	#2,a1		; increment attr buffer
		subq.w	#1,d2		; decrement col counter
		bgt.s	scuChkRendered	; check for line wrap
d467 4
a470 3
		;--	    beginning of new line
		move.w	d5,d2		; restart col counter
		move.w	d5,d4		; restart last rendered counter
d472 2
a473 6
		;--	    check line termination
	IFNE	(CMAB_IMPLICITNL/8)-1
	FAIL	"CMAB_IMPLICITNL not in high byte, recode"
	ENDC
		btst.b	#CMAB_IMPLICITNL&7,(a1)
		bne.s	scuChkRendered
a474 1
		move.b	#$0a,(a3)+	; insert explicit line terminator
a475 28
scuChkRendered:
		move.w	(a1),d0
		bpl.s	scuNext

		;--	rendered character
		;--	    check for preceeding whitespace
		sub.w	d2,d4
		subq	#2,d4
		ble.s	scuPutCharacter

		;--	    first implementation: spaces, not tabs
scuPendingWhitespaceLoop:
		move.b	#$20,(a3)+
		dbf	d4,scuPendingWhitespaceLoop

		;--	output character
scuPutCharacter:
		move.b	(a0),(a3)+
		move.w	d2,d4		; set last rendered counter

		moveq	#0,d6		; no pending selected non-rendered
		bra.s	scuDbf

scuNext:
		or.w	d0,d6
scuDbf:
		dbf	d3,scuLoop

d477 1
a477 1
		btst	#CMAB_SELECTED,d6
a479 1
scuTrailingLT:
d481 1
a481 1
		move.b	#$0a,(a3)+
d486 2
a487 2
		sub.l	cd_SelectionText(a6),a3
		move.w	a3,cd_SelectionActual(a6)
@


36.8
log
@move paste code to inputhandler.asm
@
text
@d1 1
a1 1
	TTL	'$Header: clip.asm,v 36.7 89/08/21 15:08:28 kodiak Exp $'
d22 2
a23 2
	IFNE	(CUAB_SELECTED/8)-1
	FAIL	"CUAB_SELECTED not in high byte, recode"
d29 4
a32 4
	XREF_EXE	AllocMem
	XREF_EXE	Forbid
	XREF_EXE	FreeMem
	XREF_EXE	Permit
d51 1
a51 1
		move.w	cu_BufferSize(a2),d0
d54 1
a54 1
		move.l	cu_AttrBuffer(a2),a0
d59 1
a59 1
		bclr	#CUAB_SELECTED&7,(a0)
d67 1
a67 1
		bclr	#CUAB_SELECTED&7,(a0)
d120 1
a120 1
		;-- get mouse position and convert to buffer offset
d137 1
a137 1
		mulu	cu_BufferWidth(a2),d2
a138 1
		add.w	cu_BufferOffset(a2),d2
d167 2
a168 2
		move.l	cu_AttrBuffer(a2),a0
		bset	#CUAB_SELECTED&7,0(a0,d0.w)
d215 1
a215 1
		move.l	cu_AttrBuffer(a2),a0
d227 1
a227 1
		bclr	#CUAB_SELECTED&7,(a0)
d234 1
a234 1
		move.l	cu_AttrBuffer(a2),a0
d249 1
a249 1
		move.w	cu_BufferWidth(a2),d3
d264 1
a264 1
		move.w	#CUAF_SELECTED,d5 ; ensure first char on line selected
d267 2
a268 2
		and.w	#CUAF_RENDERED,d0
		lsr.w	#CUAB_RENDERED-CUAB_SELECTED,d0
d312 1
a312 1
		add.w	cu_BufferHeight(a2),d0	; linefeeds may occur
d321 1
a321 1
		move.l	cu_CharBuffer(a2),a0
d323 1
a323 1
		move.l	cu_AttrBuffer(a2),a1
d329 1
a329 1
		move.w	cu_BufferWidth(a2),d5
d349 2
a350 2
	IFNE	(CUAB_IMPLICITNL/8)-1
	FAIL	"CUAB_IMPLICITNL not in high byte, recode"
d352 1
a352 1
		btst.b	#CUAB_IMPLICITNL&7,(a1)
d386 1
a386 1
		btst	#CUAB_SELECTED,d6
@


36.7
log
@better clip, still problems w/ NL & tabs tho...
@
text
@d1 1
a1 1
	TTL	'$Header: clip.asm,v 36.6 89/08/21 12:59:51 kodiak Exp $'
a45 1
	XDEF		PasteClip
a404 36


*------ PasteClip ----------------------------------------------------
PasteClip:
		movem.l	d2/a2-a4,-(a7)
		move.l	cd_Active(a6),a2
		move.l	cd_SelectionText(a6),a3
		lea	cu_ReadBuffer(A2),a4
		move.w	cd_SelectionActual(a6),d2
		bra.s	pcDBF
pcLoop:
		move.b	(a3)+,d0
		cmp.b	#$0a,d0
		bne.s	pcPut
		move.b	#$0d,d0		; convert LF to CR
pcPut:
		move.l	a4,a0
		BSR	PutBBuff
pcDBF:
		dbf	d2,pcLoop

		;-- check if this satisfied a read
		LINKEXE	Forbid
		TSTBUFFER cu_ReadBuffer(A2)
		BEQ.S	readPermit
		MOVE.L	MP_MSGLIST(A2),A1
		TST.L	(A1)
		BEQ.S	readPermit

		BSR	CDRead

readPermit:
		LINKEXE Permit

		movem.l	(a7)+,d2/a2-a4
		rts
@


36.6
log
@first cut at keeping highlight/select information in attribute array
@
text
@d1 1
a1 1
	TTL	'$Header: clip.asm,v 36.5 89/06/28 12:27:09 kodiak Exp $'
d215 1
a215 1
		beq.s	scSetContinue	; no need to clear if anchor == tail
d235 1
a235 1
scSetContinue:
d254 1
d259 1
a260 1

d389 1
a389 1
		bne.s	scuDone
@


36.5
log
@terminate clips w/ linefeed, convert linefeed to carriage return at paste
@
text
@d1 1
a1 1
	TTL	'$Header: clip.asm,v 36.4 89/04/19 16:16:32 kodiak Exp $'
d22 5
a33 3
	XREF_GFX	RectFill
	XREF_GFX	SetDrMd

d39 1
d41 1
a43 1
	XDEF		SelectHiLight
d48 3
a50 15
*------	SelectHiLight ------------------------------------------------
*	d0,d1,d2,d3
*	c0,r0,c1,r1
*
SelectHiLight:
		movem.l	d2-d7,-(a7)
		;-- ensure c0,r0 is less than c1,r1
		cmp.w	d1,d3
		bgt.s	shlRender
		bne.s	shlSwap01
		cmp.w	d0,d2
		bge.s	shlRender
shlSwap01:
		exg	d0,d2
		exg	d1,d3
d52 2
a53 34
		;-- hilight area from c0,r0 to c1,r1
shlRender:
		;-- set drawing mode
		movem.w	d0-d1,-(a7)
		moveq	#RP_COMPLEMENT,d0
		lea	cd_RastPort(a6),a1
		LINKGFX	SetDrMd
		movem.w	(a7)+,d0-d1
		clr.l	cd_RastPort+rp_AreaPtrn(A6)
		;-- save stuff
		move.w	d2,d6		; save final col
		move.w	d3,d7		;   and row
		move.w	d1,d5		; running row
		;-- calculate beginning x
		MULU	cu_XRSize(A2),D0
		ADD.W	cu_XROrigin(A2),D0
		;-- calculate beginning y
		MULU	cu_YRSize(a2),d1
		ADD.W	cu_YROrigin(a2),d1
		move.w	d1,d4		; running y
		;-- loop for rows
shlRowLoop:
		lea	cd_RastPort(a6),a1
		move.w	d4,d1
		EXT.L	D1
		add.w	cu_YRSize(a2),d4
		move.w	d4,d3
		subq.w	#1,d3
		EXT.L	D3
		cmp.w	d5,d7		; check rows
		beq.s	shlLastRow
		move.w	cu_XRExtant(a2),d2
		EXT.L	D2
		LINKGFX RectFill
d55 3
a57 4
		move.w	cu_XROrigin(a2),d0
		EXT.L	D0
		addq.w	#1,d5
		bra.s	shlRowLoop
d59 7
a65 8
		;-- calculate ending x
shlLastRow:
		addq	#1,d6
		mulu	cu_XRSize(a2),d6
		ADD.W	cu_XROrigin(A2),D6
		subq.l	#1,d6
		move.l	d6,d2
		LINKGFX RectFill
d67 5
a71 4
		;-- restore minterm info
		move.b	cu_DrawMode(A2),cd_RastPort+rp_DrawMode(A6)
		move.l	cu_Minterms(a2),cd_RastPort+rp_minterms(a6)
		move.l	cu_Minterms+4(a2),cd_RastPort+rp_minterms+4(a6)
d73 1
a73 2
		movem.l	(a7)+,d2-d7
		rts
d75 1
a75 6
*------ SelectAbort --------------------------------------------------
SelectAbort:
		BCLR	#CUB_SELECTING,cu_Flags(A2)
		movem.l	d2-d3,-(a7)
		movem.w	cd_SelectionStartX(a6),d0-d3
		bsr	SelectHiLight
a77 1
		movem.l	(a7)+,d2-d3
d80 1
d98 1
a98 1
*	    get cursor location curXY
d103 2
a104 2
*		render curXY to curXY
*		set startXY and endXY to curXY
d107 7
a113 7
*		    if curXY < startXY
*			exchange startXY endXY
*		if curXY > endXY
*		    render endXY+1 to curXY
*		else curXY <= endXY
*		    render curXY to endXY
*		set endXY to curXY
d121 1
a121 1
		;-- get mouse position and convert to character position
d124 3
a126 3
		moveq	#0,d4
		move.w	wd_MouseX(a0),d4
		sub.w	cu_XROrigin(a2),d4
d128 2
a129 2
		divu	cu_XRSize(a2),d4
		cmp.w	cu_XMax(a2),d4
d131 3
a133 2
		move.w	wd_MouseY(a0),d5
		sub.w	cu_YROrigin(a2),d5
d135 2
a136 2
		divu	cu_YRSize(a2),d5
		cmp.w	cu_YMax(a2),d5
d138 3
d151 1
a151 1
		beq.s	scSetNew
d156 1
a156 1
		move.b	cd_SelectFlags(a6),d7
d158 1
a158 1
		move.b	d7,cd_SelectFlags(a6)
d162 1
a162 1
scSetNew:
d167 5
a171 5
		move.w	d4,d0
		move.w	d5,d1
		move.w	d4,d2
		move.w	d5,d3
		bsr	SelectHiLight
d173 2
a174 4
		move.w	d4,cd_SelectionStartX(a6)
		move.w	d5,cd_SelectionStartY(a6)
		move.w	d4,cd_SelectionEndX(a6)
		move.w	d5,cd_SelectionEndY(a6)
d179 2
d183 4
a186 3
		;-- compare curXY w/ direction of startXY to endXY
		move.w	cd_SelectionEndY(a6),d0
		sub.w	cd_SelectionStartY(a6),d0
a188 4
		move.w	cd_SelectionEndX(a6),d0
		sub.w	cd_SelectionStartX(a6),d0
		bgt.s	scForward
		blt.s	scReverse
d191 1
a191 1
		;-- check if curXY is before startXY
d193 1
a193 3
		cmp.w	cd_SelectionStartY(a6),d5
		bgt.s	scContinue
		cmp.w	cd_SelectionStartX(a6),d4
d197 1
a197 1
		;-- check if curXY is after startXY
d199 1
a199 3
		cmp.w	cd_SelectionStartY(a6),d5
		blt.s	scContinue
		cmp.w	cd_SelectionStartX(a6),d4
d201 1
d203 4
a206 7
		;-- exchange startXY and endXY
		move.w	cd_SelectionStartX(a6),d0
		move.w	cd_SelectionEndX(a6),cd_SelectionStartX(a6)
		move.w	d0,cd_SelectionEndX(a6)
		move.w	cd_SelectionStartY(a6),d0
		move.w	cd_SelectionEndY(a6),cd_SelectionStartY(a6)
		move.w	d0,cd_SelectionEndY(a6)
d208 1
a208 1
		;-- render new selection patch
d210 6
a215 7
		;--	get currently rendered patch
		movem.w	cd_SelectionStartX(a6),d0-d3
		;--	check for no change
		cmp.w	d2,d4
		bne.s	scGetOldDirection
		cmp.w	d3,d5
		beq	scDone
d217 4
a220 16
		;--	check for crossover case
scGetOldDirection:
		move.w	d3,d6
		sub.w	d1,d6
		bne.s	scGetNewDirection
		move.w	d2,d6
		sub.w	d0,d6
scGetNewDirection:
		move.w	d5,d7
		sub.w	d1,d7
		bne.s	scCompareDirections
		move.w	d4,d7
		sub.w	d0,d7
scCompareDirections:
		eor.w	d6,d7		; compare sign bits
		bpl.s	scSameDirection
d222 4
a225 8
		cmp.w	d0,d2
		bne.s	sccoCheckSet
		cmp.w	d1,d3
		bne.s	sccoCheckSet
		;--	startXY == endXY, just set to curXY
		tst.w	d7
		bpl.s	sccoCurRight
		bra.s	sccoCurLeft
d227 5
a231 10
		;--	check to see if setting needed
sccoCheckSet:
		cmp.w	d0,d4
		bne.s	sccoClear
		cmp.w	d1,d5
		bne.s	sccoClear
		;--	startXY == curXY, just clear endXY
		tst.w	d6		; which direction start to end?
		bmi	scBumpDownD0D1	; clear endXY to startXY-1
		bra.s	scBumpUpD0D1	; clear startXY+1 to endXY
a232 4
		;--	clear in old direction, then set in new direction
sccoClear:
		tst.w	d6		; which direction start to end?
		bmi.s	scCrossOldEndLeft
d234 9
a242 10
		;--	clear startXY+1 to endXY
		addq.w	#1,d0
		cmp.w	cu_XMax(a2),d0
		ble.s	sccoslHiLight
		moveq	#0,d0
		addq.w	#1,d1
sccoslHiLight:
		bsr	LockDRPort
		bsr	SelectHiLight
		bsr	UnLockRPort
d244 14
a257 6
		;--	set curXY to startXY-1
		movem.w	cd_SelectionStartX(a6),d0-d1
sccoCurLeft:
		move.w	d4,d2
		move.w	d5,d3
		bra.s	scBumpDownD0D1
d260 14
a273 10
		;--	clear endXY to startXY-1
scCrossOldEndLeft:
		sub.w	#1,d0
		bpl.s	sccoelHiLight
		move.w	cu_XMax(a2),d0
		subq.w	#1,d1
sccoelHiLight:
		bsr	LockDRPort
		bsr	SelectHiLight
		bsr	UnLockRPort
d275 2
a276 6
		;--	set startXY+1 to curXY
		movem.w	cd_SelectionStartX(a6),d0-d1
sccoCurRight:
		move.w	d4,d2
		move.w	d5,d3
		bra.s	scBumpUpD0D1
d278 2
d281 1
a281 61
		;--	either clear or set once to move endXY to curXY
scSameDirection:
		move.w	d4,d0
		move.w	d5,d1
		tst.w	d6		; which direction start to end?
		bmi.s	scEndLeft

		;--	start left, end right
		;--	check which to modify: endXY or curXY
		cmp.w	d3,d5
		blt.s	scBumpUpD0D1	; curXY+1 to endXY
		bgt.s	scBumpUpD2D3	; endXY+1 to curXY
		cmp.w	d2,d4
		blt.s	scBumpUpD0D1	; curXY+1 to endXY

		;--	render endXY+1 to curXY
scBumpUpD2D3:
		addq.w	#1,d2
		cmp.w	cu_XMax(a2),d2
		ble.s	scHiLight
		moveq	#0,d2
		addq.w	#1,d3
		bra.s	scHiLight

		;--	render curXY+1 to endXY
scBumpUpD0D1:
		addq.w	#1,d0
		cmp.w	cu_XMax(a2),d0
		ble.s	scHiLight
		moveq	#0,d0
		addq.w	#1,d1
		bra.s	scHiLight


		;--	end left, start right
scEndLeft:
		;--	check which to modify: endXY or curXY
		cmp.w	d3,d5
		blt.s	scBumpDownD2D3	; curXY to endXY-1
		bgt.s	scBumpDownD0D1	; endXY to curXY-1
		cmp.w	d2,d4
		blt.s	scBumpDownD2D3	; curXY to endXY-1

		;--	render curXY-1 to endXY
scBumpDownD0D1:
		sub.w	#1,d0
		bpl.s	scHiLight
		move.w	cu_XMax(a2),d0
		subq.w	#1,d1
		bra.s	scHiLight

		;--	render curXY to endXY-1
scBumpDownD2D3:
		sub.w	#1,d2
		bpl.s	scHiLight
		move.w	cu_XMax(a2),d2
		subq.w	#1,d3

scHiLight:
		bsr	LockDRPort
		bsr	SelectHiLight
a283 3
		;-- set endXY to curXY
		movem.w	d4-d5,cd_SelectionEndX(a6)

d299 1
d301 1
d303 7
a309 15
		move.w	cu_BufferWidth(a2),d2
	    ;-- first pass: just store characters and line terminators
		move.w	d2,d0
		addq.w	#1,d0		; for line terminators
		movem.w	cd_SelectionStartX(a6),d4-d7
		move.w	d5,d1
		mulu	d0,d1
		add.w	d4,d1
		mulu	d7,d0
		add.w	d6,d0
		sub.l	d1,d0
		bge.s	scuOrdered
		exg	d4,d6
		exg	d5,d7
		neg.l	d0
d311 3
a313 1
		addq.l	#1,d0		; start & end are inclusive
a321 3
		move.w	d5,d0
		mulu	d2,d0
		add.w	d4,d0
d323 1
a323 1
		add.l	d0,a0
d325 3
a327 4
		add.l	d0,a1
		add.l	d0,a1
		moveq	#0,d3		; no pending spaces
		subq.w	#1,d2		; col end is inclusive
d329 8
a336 11
		;-- loop to last row
scuRowLoop:
		cmp.w	d5,d7
		bne.s	scuColLoop
		exg	d6,d2		; last row is only partial
		;-- loop to last col
scuColLoop:
		cmp.w	d4,d2
		blt.s	scuNextRow
		tst.w	(a1)+
		bpl.s	scuWhiteSpace
d338 32
a369 2
		bra.s	scuPendingBlanksDBF
scuPendingBlanksLoop:
d371 1
a371 3
scuPendingBlanksDBF:
		dbf	d3,scuPendingBlanksLoop
		moveq	#0,d3
d373 4
a376 2
		move.b	(a0)+,(a3)+
		bra.s	scuNextCol
d378 2
a379 3
scuWhiteSpace:
		addq.w	#1,a0
		addq.w	#1,d3
d381 4
a384 3
scuNextCol:
		addq.w	#1,d4
		bra.s	scuColLoop
d386 6
a391 6
scuNextRow:
		cmp.w	d5,d7
		beq.s	scuChkTermination
		moveq	#0,d3
		moveq	#0,d4
		addq.w	#1,d5
a392 1
		bra.s	scuRowLoop
a393 16
		;-- check if ended on whitespace
scuChkTermination:
		tst.w	d3
		beq.s	scuDone
		bra.s	scuChkWhiteCol

scuLastRow:
		tst.w	(a1)+
		bmi.s	scuDone		; not whitespace, so no linefeed
		addq.w	#1,d4
		;-- check if only whitespace remains in this row
scuChkWhiteCol:
		cmp.w	d4,d6
		bge.s	scuLastRow

		move.b	#$0a,(a3)+	; only whitespace, so linefeed
@


36.4
log
@render hilight to correct window
@
text
@d1 1
a1 1
	TTL	'$Header: clip.asm,v 36.3 89/04/17 15:34:23 kodiak Exp $'
d33 1
a33 1
	XREF		UnLockDRPort
a113 1
		MOVE.L	cu_AreaPtrn(a2),cd_RastPort+rp_AreaPtrn(A6)
d125 1
a125 1
		and.b	#CDS_CLEARMASK,cd_SelectFlags(a6)
d203 1
a203 1
		bsr	UnLockDRPort
d216 1
a216 1
		bsr	UnLockDRPort
d322 1
a322 1
		bsr	UnLockDRPort
d341 1
a341 1
		bsr	UnLockDRPort
d412 1
a412 1
		bsr	UnLockDRPort
d474 1
a474 1
		move.w	d6,d2		; last row is only partial
d502 1
a502 1
		beq.s	scuDone
d509 18
d548 4
@


36.3
log
@correct branch cases for cut bounding
only clear appropriate bits in cd_SelectFlags
@
text
@d1 1
a1 1
	TTL	'$Header: clip.asm,v 36.2 89/01/10 16:45:36 kodiak Exp $'
d121 1
d211 1
d217 1
d306 1
a306 1
		bmi.s	scBumpDownD0D1	; clear endXY to startXY-1
d321 1
d323 1
d340 1
d342 1
d411 1
d413 1
@


36.2
log
@*** empty log message ***
@
text
@d1 1
a1 1
	TTL	'$Header: clip.asm,v 36.1 88/09/19 17:03:42 kodiak Exp $'
d125 1
a125 1
		clr.b	cd_SelectFlags(a6)
d178 1
a178 1
		ble	scDone
d184 1
a184 1
		ble	scDone
@


36.1
log
@*** empty log message ***
@
text
@d1 1
a1 1
	TTL	'$Header$'
d175 1
a175 1
		bmi.s	scZeroX
d178 1
a178 6
		ble.s	scGotX
		move.w	cu_XMax(a2),d4
		bra.s	scGotX
scZeroX:
		moveq	#0,d4
scGotX:
d181 1
a182 1
		bmi.s	scZeroY
d184 1
a184 6
		ble.s	scGotY
		move.w	cu_YMax(a2),d5
		bra.s	scGotY
scZeroY:
		moveq	#0,d5
scGotY:
d415 4
@
