head     38.35;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


38.35
date     92.11.17.10.18.30;  author vertex;  state Exp;
branches ;
next     38.34;

38.34
date     92.11.16.12.53.57;  author vertex;  state Exp;
branches ;
next     38.33;

38.33
date     92.08.19.17.59.20;  author vertex;  state Exp;
branches ;
next     38.32;

38.32
date     92.08.10.17.27.12;  author vertex;  state Exp;
branches ;
next     38.31;

38.31
date     92.08.06.16.19.46;  author vertex;  state Exp;
branches ;
next     38.30;

38.30
date     92.07.23.15.57.35;  author vertex;  state Exp;
branches ;
next     38.29;

38.29
date     92.06.30.10.38.49;  author vertex;  state Exp;
branches ;
next     38.28;

38.28
date     92.06.27.14.36.33;  author vertex;  state Exp;
branches ;
next     38.27;

38.27
date     92.06.03.17.45.34;  author vertex;  state Exp;
branches ;
next     38.26;

38.26
date     92.05.08.10.02.10;  author vertex;  state Exp;
branches ;
next     38.25;

38.25
date     92.05.05.16.54.34;  author vertex;  state Exp;
branches ;
next     38.24;

38.24
date     92.04.27.10.20.58;  author vertex;  state Exp;
branches ;
next     38.23;

38.23
date     92.04.22.11.02.31;  author vertex;  state Exp;
branches ;
next     38.22;

38.22
date     92.03.20.16.26.58;  author vertex;  state Exp;
branches ;
next     38.21;

38.21
date     92.03.13.10.55.28;  author vertex;  state Exp;
branches ;
next     38.20;

38.20
date     92.03.11.17.56.28;  author vertex;  state Exp;
branches ;
next     38.19;

38.19
date     92.03.05.12.43.03;  author vertex;  state Exp;
branches ;
next     38.18;

38.18
date     92.03.03.12.01.02;  author vertex;  state Exp;
branches ;
next     38.17;

38.17
date     92.03.02.11.00.58;  author vertex;  state Exp;
branches ;
next     38.16;

38.16
date     92.02.26.11.56.48;  author vertex;  state Exp;
branches ;
next     38.15;

38.15
date     92.02.14.11.11.48;  author vertex;  state Exp;
branches ;
next     38.14;

38.14
date     92.02.13.11.19.59;  author vertex;  state Exp;
branches ;
next     38.13;

38.13
date     92.02.13.09.47.50;  author vertex;  state Exp;
branches ;
next     38.12;

38.12
date     92.01.20.17.43.13;  author vertex;  state Exp;
branches ;
next     38.11;

38.11
date     91.12.30.09.11.30;  author vertex;  state Exp;
branches ;
next     38.10;

38.10
date     91.12.03.13.04.27;  author vertex;  state Exp;
branches ;
next     38.9;

38.9
date     91.12.02.15.51.17;  author vertex;  state Exp;
branches ;
next     38.8;

38.8
date     91.12.02.11.58.12;  author vertex;  state Exp;
branches ;
next     38.7;

38.7
date     91.11.22.17.54.11;  author vertex;  state Exp;
branches ;
next     38.6;

38.6
date     91.11.20.10.33.36;  author vertex;  state Exp;
branches ;
next     38.5;

38.5
date     91.11.14.13.22.57;  author vertex;  state Exp;
branches ;
next     38.4;

38.4
date     91.11.14.13.14.06;  author vertex;  state Exp;
branches ;
next     38.3;

38.3
date     91.11.01.13.30.28;  author vertex;  state Exp;
branches ;
next     38.2;

38.2
date     91.11.01.10.28.42;  author vertex;  state Exp;
branches ;
next     38.1;

38.1
date     91.10.31.12.13.09;  author vertex;  state Exp;
branches ;
next     ;


desc
@Disk formatting program
@


38.35
log
@ADDED JAPAN SUPPORT
@
text
@
/* BUG: If ACTION_FORMAT is not recognized by a handler, this program
 *      assumes a 512-byte block size
 */

/* includes */
#include <exec/types.h>
#include <exec/errors.h>
#include <exec/memory.h>
#include <dos/dos.h>
#include <dos/dosextens.h>
#include <dos/filehandler.h>
#include <dos/dosasl.h>
#include <workbench/startup.h>
#include <workbench/workbench.h>
#include <devices/trackdisk.h>
#include <intuition/intuition.h>
#include <intuition/gadgetclass.h>
#include <graphics/text.h>
#include <internal/crossdos.h>
#include <string.h>
#include <stdio.h>

/* prototypes */
#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/dos_protos.h>
#include <clib/graphics_protos.h>
#include <clib/icon_protos.h>
#include <clib/utility_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/locale_protos.h>
#include <clib/diskfont_protos.h>

/* direct ROM interface */
#include <pragmas/exec_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/icon_pragmas.h>
#include <pragmas/utility_pragmas.h>
#include <pragmas/gadtools_pragmas.h>
#include <pragmas/locale_pragmas.h>
#include <pragmas/diskfont_pragmas.h>

/* application includes */
#include "texttable.h"
#include "format_rev.h"


/****************************************************************************/


/* because <dos/dos.h> has these incorrectly defined in 2.04 */
#ifdef ID_INTER_DOS_DISK
#undef ID_INTER_DOS_DISK
#endif

#ifdef ID_INTER_FFS_DISK
#undef ID_INTER_FFS_DISK
#endif

#define WORDSPERBLOCK	  128
#define HASHSIZE	  (WORDSPERBLOCK - 56)
#define NUMBMPAGES	  26
#define T_SHORT	          2
#define ST_ROOT	          1
#define ID_BAD_DISK       (0x42414400L) /* 'BAD\0' */
#define ID_BUSY_DISK      (0x42555359L) /* 'BUSY'  */
#define ID_INTER_DOS_DISK (0x444F5302L)	/* 'DOS\2' */
#define ID_INTER_FFS_DISK (0x444F5303L)	/* 'DOS\3' */
#define ID_DC_DOS_DISK    (0x444F5304L) /* 'DOS\4' */
#define ID_DC_FFS_DISK    (0x444F5305L) /* 'DOS\5' */

struct RootBlock
{
    ULONG            rb_Type;
    ULONG            rb_HeaderKey;
    ULONG            rb_HighSeqNum;
    ULONG            rb_HashSize;
    ULONG            rb_Reserved;
    ULONG            rb_CheckSum;
    ULONG            rb_HashTable[HASHSIZE];
    ULONG            rb_BMFlag;
    ULONG            rb_BitMapPages[NUMBMPAGES];
    struct DateStamp rb_LastDate;
    UBYTE            rb_DiskName[52];
    struct DateStamp rb_CreateDate;
    ULONG            rb_HashChain;
    ULONG            rb_Parent;
    ULONG            rb_Extension;
    ULONG            rb_SecondaryType;
};


/****************************************************************************/


struct TextAttr topazAttr =
{
    "coral.font",
     16,
     FS_NORMAL,
     FPF_DISKFONT
};


/****************************************************************************/


#define TEMPLATE       "DEVICE=DRIVE/K/A,NAME/K/A,OFS/S,FFS/S,INTL=INTERNATIONAL/S,NOINTL=NOINTERNATIONAL/S,DIRCACHE/S,NODIRCACHE/S,NOICONS/S,QUICK/S" VERSTAG
#define OPT_DEVICE     0
#define OPT_NAME       1
#define OPT_OFS        2
#define OPT_FFS	       3
#define OPT_INTL       4
#define OPT_NOINTL     5
#define OPT_DIRCACHE   6
#define OPT_NODIRCACHE 7
#define OPT_NOICONS    8
#define OPT_QUICK      9
#define OPT_COUNT      10


/****************************************************************************/


#define MAXERRORS      2
#define BIGDRIVESIZE   (1024*1024*2)   /* 2 Megs */
#define NAMELENGTH     30

#define ERROR_BAD_DISK 1
#define ERROR_NO_TRASH 2


/****************************************************************************/


struct GlobalData
{
    APTR               gd_DOSBase;
    APTR               gd_IntuitionBase;
    APTR               gd_GadToolsBase;
    APTR               gd_UtilityBase;
    APTR               gd_GfxBase;
    APTR               gd_DiskfontBase;
    struct LocaleInfo  gd_LocaleInfo;

    struct Screen     *gd_Screen;
    struct Window     *gd_Window;
    APTR               gd_VisualInfo;
    struct DrawInfo   *gd_DrawInfo;
    struct TextFont   *gd_Font;
    ULONG              gd_IntuiSig;
    struct Gadget     *gd_LastAdded;
    struct Gadget     *gd_Gadgets;
    char	       gd_WindowTitle[80];

    char               gd_OldVolumeName[NAMELENGTH+1];
    char               gd_DeviceName[NAMELENGTH+1];
    char               gd_VolumeName[NAMELENGTH+1];
    BOOL               gd_Trashcan;
    BOOL               gd_Quick;
    BOOL               gd_OFS;
    BOOL               gd_FFS;
    BOOL               gd_Intl;
    BOOL               gd_NoIntl;
    BOOL	       gd_DirCache;
    BOOL	       gd_NoDirCache;
    BOOL               gd_GUI;
    WORD	       gd_Pad;
    struct DosList    *gd_DeviceNode;

    ULONG              gd_BytesPerBlock;
    ULONG              gd_NumBlocks;
    ULONG              gd_BlocksUsed;
    ULONG              gd_DiskType;
    char               gd_Capacity[80];

    ULONG              gd_NumberCyl;
    ULONG              gd_CurrentCyl;
    ULONG              gd_LowCyl;
};

#define DOSBase       global->gd_DOSBase
#define IntuitionBase global->gd_IntuitionBase
#define GadToolsBase  global->gd_GadToolsBase
#define UtilityBase   global->gd_UtilityBase
#define GfxBase       global->gd_GfxBase
#define DiskfontBase  global->gd_DiskfontBase
#define LocaleBase    global->gd_LocaleInfo.li_LocaleBase


/****************************************************************************/


#define BTOCSTR(bstr)  ((STRPTR)((ULONG)BADDR(bstr) + 1))
#define D_S(type,name) char a_##name[sizeof(type)+3]; \
		       type *name = (type *)((LONG)(a_##name+3) & ~3);

#define GetStr(str)   (GetString(&global->gd_LocaleInfo,str))
#define CheckBreak()  (CheckSignal(global->gd_IntuiSig | SIGBREAKF_CTRL_C))
#define PrintErr(err) (PrintFault(err,GetStr(MSG_FMT_FAILED_TITLE)))

LONG Initialize(struct GlobalData *global);
VOID WBExplain(struct GlobalData *global);
BOOL ReallyFormat(struct GlobalData *global);
LONG GetFSInfo(struct GlobalData *global);
BOOL FindVolumeDevice(struct GlobalData *global, struct MsgPort *volumeHandler);

VOID VPrintF(struct GlobalData *global, STRPTR str, STRPTR arg1, ... );
VOID PrintF(struct GlobalData *global, AppStringsID str, STRPTR arg1, ... );
VOID kprintf(STRPTR,...);

BOOL OpenFmtWindow(struct GlobalData *global);
BOOL EditFmtOptions(struct GlobalData *global);
VOID CloseFmtWindow(struct GlobalData *global);
BOOL SelectFmtDevice(struct GlobalData *global);


/****************************************************************************/


#define GAUGE_LEFT     8
#define GAUGE_RIGHT    416
#define GAUGE_TOP      28
#define GAUGE_BOTTOM   69
#define GAUGE_WIDTH    (GAUGE_RIGHT-GAUGE_LEFT+1)
#define GAUGE_HEIGHT   (GAUGE_BOTTOM-GAUGE_TOP+1)


/****************************************************************************/


LONG main(VOID)
{
struct InfoData __aligned  infoData;
struct GlobalData          gd;
struct GlobalData         *global;
struct Library            *SysBase = (*((struct Library **) 4));
struct Process            *process;
struct WBStartup          *WBenchMsg = NULL;
struct WBArg              *wbarg;
LONG                       wbcnt;
struct RdArgs             *rdargs;
LONG                       opts[OPT_COUNT];
STRPTR                     volName;
STRPTR                     devName;
LONG                       failureCode  = ERROR_INVALID_RESIDENT_LIBRARY;
UWORD                      i;
BPTR                       parent;
char                       ch;
BOOL                       abort;
BOOL			   printFailure;
char                       str[80];

    memset(&gd,0,sizeof(struct GlobalData));
    global = &gd;

    process = (struct Process *)FindTask(NULL);
    if (!process->pr_CLI)
    {
        WaitPort(&process->pr_MsgPort);
        WBenchMsg = (struct WBStartup *)GetMsg(&process->pr_MsgPort);
    }

    DOSBase        = OpenLibrary("dos.library",39);
    IntuitionBase  = OpenLibrary("intuition.library",39);
    GfxBase        = OpenLibrary("graphics.library",39);
    UtilityBase    = OpenLibrary("utility.library",39);
    GadToolsBase   = OpenLibrary("gadtools.library",39);
    DiskfontBase   = OpenLibrary("diskfont.library",39);
    global->gd_GUI = (process->pr_CLI == NULL);

    if (DOSBase && IntuitionBase && GfxBase && UtilityBase && GadToolsBase && DiskfontBase)
    {
        if (LocaleBase = OpenLibrary("locale.library",38))
            global->gd_LocaleInfo.li_Catalog = OpenCatalogA(NULL,"sys/system.catalog",NULL);

        if (WBenchMsg)
        {
            strcpy(global->gd_VolumeName,GetStr(MSG_FMT_EMPTY_DISK));
            global->gd_Quick      = FALSE;
            global->gd_Trashcan   = TRUE;
            global->gd_OFS        = FALSE;
            global->gd_FFS        = FALSE;
            global->gd_Intl       = FALSE;
            global->gd_NoIntl     = FALSE;
            global->gd_DirCache   = FALSE;
            global->gd_NoDirCache = FALSE;

            /* We might want to read the Format program icon to find tooltypes
             * describing the default options instead of always initing to
             * fixed defaults.
             */

            failureCode  = ERROR_INVALID_COMPONENT_NAME;
            printFailure = TRUE;
            wbarg        = WBenchMsg->sm_ArgList;
            wbcnt        = WBenchMsg->sm_NumArgs;

            if (wbcnt == 1)   /* double-click of Format icon */
            {
                failureCode = ERROR_NO_FREE_STORE;
                if (OpenFmtWindow(global))
                {
                    failureCode = 0;
                    if (SelectFmtDevice(global))
                    {
                        global->gd_OFS        = FALSE;
                        global->gd_FFS        = FALSE;
                        global->gd_Intl       = FALSE;
                        global->gd_NoIntl     = FALSE;
                        global->gd_DirCache   = FALSE;
                        global->gd_NoDirCache = FALSE;
                        if (!(failureCode = GetFSInfo(global)))
                            if (EditFmtOptions(global))
                                if (ReallyFormat(global))
                                    if (failureCode = Initialize(global))
                                        printFailure = FALSE;
                    }
                }
                CloseFmtWindow(global);
            }
            else if (wbcnt > 1)
            {
                UnLock(wbarg->wa_Lock);
                wbarg->wa_Lock = NULL;

                while (--wbcnt)
                {
                    wbarg++;
                    if (wbarg->wa_Lock && wbarg->wa_Name)
                    {
                        /* there is a lock, so this is a previously formatted disk */

                        if (parent = ParentDir(wbarg->wa_Lock))
                        {
                            UnLock(parent);
                            failureCode = ERROR_OBJECT_WRONG_TYPE;
                            break;
                        }

                        if (IoErr() || !Info(wbarg->wa_Lock,&infoData))
                        {
                            failureCode = IoErr();
                            break;
                        }

                        if (!FindVolumeDevice(global,((struct DosList *)BADDR(infoData.id_VolumeNode))->dol_Task))
                        {
                            failureCode = ERROR_OBJECT_WRONG_TYPE;
                            break;
                        }

                        UnLock(wbarg->wa_Lock);
                        wbarg->wa_Lock = NULL;
                    }
                    else
                    {
                        /* wbarg did not have a lock, must be an uninitialized disk */
                        strcpy(global->gd_DeviceName,wbarg->wa_Name);
                    }

                    if (failureCode = GetFSInfo(global))
                        break;

                    if (OpenFmtWindow(global))
	            {
                        if (!EditFmtOptions(global))
                            break;

                        if (ReallyFormat(global))
                        {
                            if (failureCode = Initialize(global))
                            {
                                printFailure = FALSE;
                                break;
                            }
                        }
                    }
                    else
                    {
                        failureCode = ERROR_NO_FREE_STORE;
                        break;
                    }
                }
                CloseFmtWindow(global);
            }

            if (printFailure && failureCode)
            {
                Fault(failureCode,NULL,str,sizeof(str));
                PrintF(global,MSG_FMT_FAILED_DOS,str);
            }
        }
        else
        {
            memset(opts,0,sizeof(opts));

            if (rdargs = ReadArgs(TEMPLATE,opts,NULL))
            {
                volName               =  (STRPTR)opts[OPT_NAME];
                devName               =  (STRPTR)opts[OPT_DEVICE];
                global->gd_OFS        =  (BOOL)opts[OPT_OFS];
                global->gd_FFS        =  (BOOL)opts[OPT_FFS];
                global->gd_Intl       =  (BOOL)opts[OPT_INTL];
                global->gd_NoIntl     =  (BOOL)opts[OPT_NOINTL];
                global->gd_DirCache   =  (BOOL)opts[OPT_DIRCACHE];
                global->gd_NoDirCache =  (BOOL)opts[OPT_NODIRCACHE];
                global->gd_Quick      =  (BOOL)opts[OPT_QUICK];
                global->gd_Trashcan   = !(BOOL)opts[OPT_NOICONS];

                i = 0;
                while ((i <= NAMELENGTH) && volName[i] && (volName[i] != ':') && (volName[i] != '/'))
                    i++;

                if ((strlen(devName) <= NAMELENGTH) && (volName[i] == 0))
                {
                    strcpy(global->gd_DeviceName,devName);
                    strcpy(global->gd_VolumeName,volName);

                    if (!(failureCode = GetFSInfo(global)))
                    {
                        VPrintF(global,GetStr(MSG_FMT_PLEASEINSERT),global->gd_DeviceName);
                        Flush(Output());

                        ch    = 0;
                        abort = FALSE;
                        if (IsInteractive(Input()))
                        {
                            while (WaitForChar(Input(),30))
                            {
                                if (Read(Input(),&ch,1) != 1)
                                    ch = -1;
                            }

                            ch    = -1;
                            while (TRUE)
                            {
                                if (WaitForChar(Input(),100000))
                                {
                                    if (Read(Input(),&ch,1) == 1)
                                        break;
                                }
                                else if (CheckBreak())
                                {
                                    abort = TRUE;
                                    break;
                                }
                            }
                        }

                        if (!abort)
                        {
                            if (ch != '\n')
                                Read(Input(),&ch,1);

                            PutStr("\2330 p\n");  /* turn off cursor */
                            failureCode = Initialize(global);
                            PutStr("\233 p");     /* turn on cursor  */
                        }
                        else
                        {
                            PutStr("\n");
                            failureCode = ERROR_BREAK;
                            PrintFault(ERROR_BREAK,NULL);
                        }
                    }
                    else
                    {
                        PrintErr(failureCode);
                    }
                }
                else
                {
                    failureCode = ERROR_INVALID_COMPONENT_NAME;
                    PrintErr(ERROR_INVALID_COMPONENT_NAME);
                }
                FreeArgs(rdargs);
            }
            else
            {
                failureCode = IoErr();
                PrintErr(failureCode);
            }
        }

        if (LocaleBase)
        {
            CloseCatalog(global->gd_LocaleInfo.li_Catalog);
            CloseLibrary(LocaleBase);
        }
    }

    if (DOSBase)
    {
        SetIoErr(failureCode);
        CloseLibrary(DiskfontBase);
        CloseLibrary(GadToolsBase);
        CloseLibrary(UtilityBase);
        CloseLibrary(GfxBase);
        CloseLibrary(IntuitionBase);
        CloseLibrary(DOSBase);
    }

    if (WBenchMsg)
    {
        Forbid();
        ReplyMsg(WBenchMsg);
    }

    if (!failureCode)
        return(RETURN_OK);

    if (failureCode == ERROR_BREAK)
        return(RETURN_WARN);

    return(RETURN_FAIL);
}


/****************************************************************************/


#define GetFSSM(global,device) ((struct FileSysStartupMsg *)(device->dol_misc.dol_handler.dol_Startup * 4))


/****************************************************************************/


#define ROLLOVER_POINT 9999


LONG GetFSInfo(struct GlobalData *global)
{
struct InfoData __aligned  infoData;
struct FileSysStartupMsg  *fssm;
struct DosEnvec           *env;
UWORD                      i;
struct DosList            *dl;
char                       colonName[NAMELENGTH+2];
ULONG                      used;
ULONG                      percent;
ULONG                      total;
char                       totalchar;
ULONG                      msg;

    i = 0;
    while ((global->gd_VolumeName[i] != ':') && global->gd_VolumeName[i])
        i++;
    global->gd_VolumeName[i] = 0;

    i = 0;
    while ((global->gd_DeviceName[i] != ':') && global->gd_DeviceName[i])
        i++;
    global->gd_DeviceName[i] = 0;

    global->gd_OldVolumeName[0] = 0;
/*
kprintf("GFSI: 1\n");
*/
    dl = LockDosList(LDF_DEVICES | LDF_VOLUMES | LDF_READ);
    if (global->gd_DeviceNode = FindDosEntry(dl,global->gd_DeviceName,LDF_DEVICES | LDF_READ))
    {
/*
kprintf("GFSI: 2, searching for %b\n",global->gd_DeviceNode->dol_Name);
*/
        sprintf(global->gd_DeviceName,"%b",global->gd_DeviceNode->dol_Name);
        while (dl = NextDosEntry(dl,LDF_VOLUMES | LDF_READ))
        {
            if (dl->dol_Task == global->gd_DeviceNode->dol_Task)
            {
/*
kprintf("GFSI: 3, found match with %b\n",dl->dol_Name);
*/
                sprintf(global->gd_OldVolumeName,"%b",dl->dol_Name);
                break;
            }
        }
    }
    UnLockDosList(LDF_DEVICES | LDF_VOLUMES | LDF_READ);

    if (!global->gd_DeviceNode)
    {
/*
kprintf("GFSI: 4, did find match\n");
*/
        return(ERROR_DEVICE_NOT_MOUNTED);
    }

    strcpy(colonName,global->gd_DeviceName);
    strcat(colonName,":");
/*
kprintf("GFSI: 5, calling IsFileSystem on %s\n",colonName);
*/
    if (!IsFileSystem(colonName))
        return(ERROR_OBJECT_WRONG_TYPE);
/*
kprintf("GFSI: 6, calling GetFSSM()\n");
*/
    if (!(fssm = GetFSSM(global,global->gd_DeviceNode)))
        return(ERROR_OBJECT_WRONG_TYPE);

    if (!(env = (struct DosEnvec *)BADDR(fssm->fssm_Environ)))
        return(ERROR_OBJECT_WRONG_TYPE);
/*
kprintf("GFSI: 7, sending a ACTION_DISK_INFO to %lx\n",global->gd_DeviceNode->dol_Task);
*/
    if (!DoPkt1(global->gd_DeviceNode->dol_Task,ACTION_DISK_INFO,MKBADDR(&infoData)))
        return(ERROR_NO_DISK);
/*
kprintf("GFSI: 8\n");
*/

    global->gd_BlocksUsed    = infoData.id_NumBlocksUsed;
    global->gd_BytesPerBlock = env->de_SizeBlock*4;
    global->gd_NumBlocks     = env->de_BlocksPerTrack * env->de_Surfaces * (env->de_HighCyl-env->de_LowCyl+1);
    global->gd_DiskType      = ID_DOS_DISK;

    if (global->gd_NumBlocks == 0)
    {
        global->gd_NumBlocks = infoData.id_NumBlocks;
        if (global->gd_NumBlocks == 0)
        {
            return(ERROR_OBJECT_WRONG_TYPE);
        }
    }

    if (env->de_TableSize >= DE_DOSTYPE)
    {
        global->gd_DiskType = env->de_DosType;
        if ((global->gd_DiskType == ID_FFS_DISK) || (global->gd_DiskType == ID_INTER_FFS_DISK) || (global->gd_DiskType == ID_DC_FFS_DISK))
            global->gd_FFS = TRUE;

        if ((global->gd_DiskType == ID_INTER_DOS_DISK) || (global->gd_DiskType == ID_INTER_FFS_DISK))
            global->gd_Intl = TRUE;

        if ((global->gd_DiskType == ID_DC_DOS_DISK) || (global->gd_DiskType == ID_DC_FFS_DISK))
            global->gd_DirCache = TRUE;
    }

    if (global->gd_OldVolumeName[0])
        msg = MSG_FMT_CAPACITY_1;
    else
        msg = MSG_FMT_CAPACITY_2;

    total   = global->gd_NumBlocks;
    used    = global->gd_BlocksUsed;
    percent = (((used * 100) + (total>>1)) / total);
    total  *= global->gd_BytesPerBlock;

    totalchar = 'K';
    if ((total >>= 10) > ROLLOVER_POINT)
    {
        totalchar='M';
        total >>= 10;
    }

    sprintf(global->gd_Capacity,GetStr(msg),total,totalchar,percent);
    return(0);
}


/****************************************************************************/


BOOL FindVolumeDevice(struct GlobalData *global, struct MsgPort *volumeHandler)
{
struct DosList *dl;
BOOL            state;

    state = FALSE;
    dl    = LockDosList(LDF_DEVICES | LDF_READ);
    while (dl = NextDosEntry(dl,LDF_DEVICES | LDF_READ))
    {
	if (dl->dol_Task == volumeHandler)
	{
	    state = TRUE;
            sprintf(global->gd_DeviceName,"%b",dl->dol_Name);
            break;
	}
    }

    UnLockDosList(LDF_DEVICES | LDF_READ);

    return(state);
}


/****************************************************************************/


BOOL OpenFmtWindow(struct GlobalData *global)
{
struct TagItem tags[10];

    if (global->gd_Window)
        return(TRUE);

    if (global->gd_Screen = LockPubScreen(NULL))
    {
        if (global->gd_DrawInfo = GetScreenDrawInfo(global->gd_Screen))
        {
            if (global->gd_VisualInfo = GetVisualInfoA(global->gd_Screen,NULL))
            {
                if (global->gd_Font = OpenDiskFont(&topazAttr))
                {
                    tags[0].ti_Tag  = WA_Title;
                    tags[0].ti_Data = (ULONG)GetStr(MSG_FMT_FORMAT_TITLE);
                    tags[1].ti_Tag  = WA_InnerWidth;
                    tags[1].ti_Data = 424;
                    tags[2].ti_Tag  = WA_InnerHeight;
                    tags[2].ti_Data = 200;
                    tags[3].ti_Tag  = WA_Flags;
                    tags[3].ti_Data = WFLG_SMART_REFRESH | WFLG_ACTIVATE | WFLG_DRAGBAR | WFLG_DEPTHGADGET | WFLG_NOCAREREFRESH;
                    tags[4].ti_Tag  = WA_AutoAdjust;
                    tags[4].ti_Data = TRUE;
                    tags[5].ti_Tag  = WA_PubScreen;
                    tags[5].ti_Data = (ULONG)global->gd_Screen;
                    tags[6].ti_Tag  = WA_IDCMP;
                    tags[6].ti_Data = CHECKBOXIDCMP | BUTTONIDCMP | STRINGIDCMP | LISTVIEWIDCMP | IDCMP_DISKINSERTED | IDCMP_DISKREMOVED;
                    tags[7].ti_Tag  = TAG_DONE;

                    if (global->gd_Window = OpenWindowTagList(NULL,tags))
                    {
                        SetFont(global->gd_Window->RPort,global->gd_Font);
                        global->gd_IntuiSig = (1L << global->gd_Window->UserPort->mp_SigBit);
                        return(TRUE);
                    }
                }
            }
        }
    }
    CloseFmtWindow(global);

    return(FALSE);
}


/*****************************************************************************/


struct Node *FindNameNC(struct GlobalData *global, struct List *list, STRPTR name)
{
struct Node *node;
WORD         result;

    node = list->lh_Head;
    while (node->ln_Succ)
    {
        result = Stricmp(name,node->ln_Name);
        if (result == 0)
            return(node);

	node = node->ln_Succ;
    }

    return(NULL);
}


/****************************************************************************/


struct Gadget *CreateFmtGadget(struct GlobalData *global, ULONG kind,
                               struct NewGadget *ng, ULONG tags, ...)
{
    ng->ng_TextAttr   = &topazAttr;
    ng->ng_UserData   = 0;
    ng->ng_Flags      = NULL;
    ng->ng_VisualInfo = global->gd_VisualInfo;
    ng->ng_GadgetText = GetStr((ULONG)ng->ng_GadgetText);

    return(global->gd_LastAdded = CreateGadgetA(kind,global->gd_LastAdded,ng,(struct TagItem *)&tags));
}


/****************************************************************************/


VOID DrawBB(struct GlobalData *global, WORD x, WORD y,
                                       WORD w, WORD h, ULONG tags, ...)
{
    DrawBevelBoxA(global->gd_Window->RPort,x+global->gd_Window->BorderLeft,
                                           y+global->gd_Window->BorderTop,
                                           w,h,(struct TagItem *)&tags);
}


/****************************************************************************/


VOID PlaceText(struct GlobalData *global, STRPTR text, WORD x, WORD y)
{
struct Window   *window;
struct RastPort *rp;

    window = global->gd_Window;
    rp     = window->RPort;

    SetAPen(rp,global->gd_DrawInfo->dri_Pens[TEXTPEN]);
    Move(rp,x+window->BorderLeft,y+window->BorderTop);
    Text(rp,text,strlen(text));
}


/****************************************************************************/


VOID PutTick(struct GlobalData *global, WORD left)
{
struct Window *window;

    window = global->gd_Window;
    RectFill(window->RPort,window->BorderLeft+left,
                           window->BorderTop+GAUGE_BOTTOM+1,
                           window->BorderLeft+left+1,
                           window->BorderTop+GAUGE_BOTTOM+2);
}


/****************************************************************************/


VOID SetGadgetAttr(struct GlobalData *global, struct Gadget *gad, ULONG tags, ...)
{
    GT_SetGadgetAttrsA(gad,global->gd_Window,NULL,(struct TagItem *)&tags);
}


/****************************************************************************/


#define CMD_NOP         0
#define CMD_FORMAT      1
#define CMD_QUICKFORMAT 2
#define CMD_CANCEL      3
#define CMD_ABORT       4
#define CMD_FFS         5
#define CMD_INTL        6
#define CMD_DC          7
#define CMD_DEVICE      8  /* in select device window */
#define CMD_CONTINUE    9  /* in select device window */


BOOL EditFmtOptions(struct GlobalData *global)
{
struct Library      *SysBase = (*((struct Library **) 4));
struct NewGadget     ng;
struct IntuiMessage *intuiMsg;
struct Window       *window;
struct Gadget       *volumeGad;
struct Gadget       *trashGad;
struct Gadget       *ffsGad;
struct Gadget       *intlGad;
struct Gadget       *info1Gad;
struct Gadget       *info2Gad;
struct Gadget       *info3Gad;
struct Gadget       *quickGad;
BOOL                 result;
BOOL                 exitLoop;
STRPTR               str;
char                 string0[80];
char                 string1[80];
char                 string2[80];
BOOL                 printInfo;
BOOL                 oldIntl;
struct Gadget       *dcGad;

    result             = FALSE;
    window             = global->gd_Window;
    global->gd_Gadgets = CreateContext(&global->gd_LastAdded);

    strncpy(global->gd_WindowTitle,GetStr(MSG_FMT_FORMAT_TITLE),sizeof(global->gd_WindowTitle));
    strncat(global->gd_WindowTitle," - ",sizeof(global->gd_WindowTitle));
    strncat(global->gd_WindowTitle,global->gd_DeviceName,sizeof(global->gd_WindowTitle));
    SetWindowTitles(window,global->gd_WindowTitle,(STRPTR)-1);

    SetAPen(window->RPort,global->gd_DrawInfo->dri_Pens[BACKGROUNDPEN]);
    RectFill(window->RPort,window->BorderLeft,window->BorderTop,
                           window->Width-window->BorderRight-1,
                           window->Height-window->BorderBottom-1);

    ng.ng_TopEdge    = window->BorderTop+6;
    ng.ng_LeftEdge   = window->BorderLeft+192;
    ng.ng_Width      = 232;
    ng.ng_Height     = 20;
    ng.ng_GadgetText = (STRPTR)MSG_FMT_INFO_GAD;
    ng.ng_GadgetID   = CMD_NOP;

    info1Gad = CreateFmtGadget(global,TEXT_KIND,&ng,GTTX_Clipped,TRUE,
                                                    TAG_DONE);

    ng.ng_TopEdge    = window->BorderTop+27;
    ng.ng_GadgetText = (STRPTR)MSG_FMT_NOTHING;
    info2Gad = CreateFmtGadget(global,TEXT_KIND,&ng,GTTX_Clipped, TRUE,
                                                    TAG_DONE);

    ng.ng_TopEdge    = window->BorderTop+48;
    ng.ng_GadgetText = (STRPTR)MSG_FMT_NOTHING;
    info3Gad = CreateFmtGadget(global,TEXT_KIND,&ng,GTTX_Clipped, TRUE,
                                                    TAG_DONE);

    ng.ng_TopEdge    = window->BorderTop+69;
    ng.ng_Width      = 226;
    ng.ng_Height     = 20;
    ng.ng_GadgetText = (STRPTR)MSG_FMT_VOLUMENAME_GAD;
    ng.ng_GadgetID   = CMD_NOP;

    volumeGad = CreateFmtGadget(global,STRING_KIND,&ng,GTST_String,   global->gd_VolumeName,
                                                       GTST_MaxChars, NAMELENGTH,
                                                       TAG_DONE);
                                 
    ng.ng_TopEdge    = window->BorderTop+90;
    ng.ng_Width      = 20;
    ng.ng_Height     = 20;
    ng.ng_GadgetText = (STRPTR)MSG_FMT_TRASH_GAD;
    ng.ng_GadgetID   = CMD_NOP;

    trashGad = CreateFmtGadget(global,CHECKBOX_KIND,&ng,GTCB_Checked, global->gd_Trashcan,
                                                        TAG_DONE);

    ffsGad  = NULL;
    intlGad = NULL;
    dcGad   = NULL;

    if ((global->gd_DiskType >= ID_DOS_DISK) && (global->gd_DiskType <= ID_DC_FFS_DISK))
    {
        ng.ng_TopEdge    = window->BorderTop+111;
        ng.ng_Width      = 20;
        ng.ng_GadgetText = (STRPTR)MSG_FMT_FFS_GAD;
        ng.ng_GadgetID   = CMD_FFS;

        ffsGad = CreateFmtGadget(global,CHECKBOX_KIND,&ng,GTCB_Checked, global->gd_FFS,
                                                          TAG_DONE);

        ng.ng_TopEdge    = window->BorderTop+132;
        ng.ng_Width      = 20;
        ng.ng_GadgetText = (STRPTR)MSG_FMT_INTL_GAD;
        ng.ng_GadgetID   = CMD_INTL;

        intlGad = CreateFmtGadget(global,CHECKBOX_KIND,&ng,GTCB_Checked, global->gd_Intl || global->gd_DirCache,
        						   GA_Disabled,  global->gd_DirCache,
                                                           TAG_DONE);

        ng.ng_TopEdge    = window->BorderTop+153;
        ng.ng_Width      = 20;
        ng.ng_GadgetText = (STRPTR)MSG_FMT_DIRCACHE_GAD;
        ng.ng_GadgetID   = CMD_DC;

        dcGad = CreateFmtGadget(global,CHECKBOX_KIND,&ng,GTCB_Checked,global->gd_DirCache,
                                                         TAG_DONE);
    }

    ng.ng_TopEdge    = window->BorderTop+176;
    ng.ng_LeftEdge   = window->BorderLeft+8;
    ng.ng_Width      = 134;
    ng.ng_GadgetText = (STRPTR)MSG_FMT_FORMAT_GAD;
    ng.ng_GadgetID   = CMD_FORMAT;

    CreateFmtGadget(global,BUTTON_KIND,&ng,TAG_DONE);

    ng.ng_LeftEdge   = window->BorderLeft+145;
    ng.ng_GadgetText = (STRPTR)MSG_FMT_QFORMAT_GAD;
    ng.ng_GadgetID   = CMD_QUICKFORMAT;

/* GA_Disabled was commented out because the check for the old volume name
 * is insufficient. The correct check would be to attepmt to read the first
 * and last cylinder of the device. If that works, then the disk can support
 * quick format. No time to do this now, so we just punt.
 */
    quickGad = CreateFmtGadget(global,BUTTON_KIND,&ng,/* GA_Disabled,(global->gd_OldVolumeName[0] == 0), */
                                                      TAG_DONE);

    ng.ng_LeftEdge   = window->BorderLeft+282;
    ng.ng_GadgetText = (STRPTR)MSG_FMT_CANCEL_GAD;
    ng.ng_GadgetID   = CMD_CANCEL;

    CreateFmtGadget(global,BUTTON_KIND,&ng,TAG_DONE);

    if (global->gd_LastAdded)
    {
        AddGList(window,global->gd_Gadgets,-1,-1,NULL);
        RefreshGList(global->gd_Gadgets,window,NULL,-1);
        GT_RefreshWindow(window,NULL);

        ActivateGadget(volumeGad,window,NULL);

        printInfo = TRUE;
        oldIntl   = global->gd_Intl;

        exitLoop = FALSE;
        while (!exitLoop)
        {
            if (printInfo)
            {
                sprintf(string0,GetStr(MSG_FMT_DEVNAME),global->gd_DeviceName);
                if (global->gd_OldVolumeName[0] == 0)
                {
                    strcpy(string1,global->gd_Capacity);
                    string2[0] = 0;
                }
                else
                {
                    sprintf(string1,GetStr(MSG_FMT_VOLNAME),global->gd_OldVolumeName);
                    strcpy(string2,global->gd_Capacity);
                }

                SetGadgetAttr(global,info1Gad,GTTX_Text,string0,TAG_DONE);
                SetGadgetAttr(global,info2Gad,GTTX_Text,string1,TAG_DONE);
                SetGadgetAttr(global,info3Gad,GTTX_Text,string2,TAG_DONE);

                printInfo = FALSE;
            }

            WaitPort(window->UserPort);
            if (intuiMsg = GT_GetIMsg(window->UserPort))
            {
                switch (intuiMsg->Class)
                {
                    case IDCMP_DISKINSERTED  :
                    case IDCMP_DISKREMOVED   : GetFSInfo(global);
                                               printInfo = TRUE;
                                               SetGadgetAttr(global,quickGad,GA_Disabled,(global->gd_OldVolumeName[0] == 0),
                                                                             TAG_DONE);
                                               break;

                    case IDCMP_GADGETUP      :
                    case IDCMP_GADGETDOWN    : switch (((struct Gadget *)intuiMsg->IAddress)->GadgetID)
                                               {
                                                   case CMD_FORMAT      : global->gd_Quick = FALSE;
                                                                          result = TRUE;
                                                                          exitLoop = TRUE;
                                                                          break;

                                                   case CMD_QUICKFORMAT : global->gd_Quick = TRUE;
                                                                          result = TRUE;
                                                                          exitLoop = TRUE;
                                                                          break;

                                                   case CMD_CANCEL      : exitLoop = TRUE;
                                                                          break;

                                                   case CMD_INTL        : oldIntl = ((GFLG_SELECTED & intlGad->Flags) != 0);
                                                                          break;

                                                   case CMD_DC          : SetGadgetAttr(global,intlGad,GA_Disabled, (GFLG_SELECTED & dcGad->Flags),
                                                                                                       GTCB_Checked, oldIntl || (GFLG_SELECTED & dcGad->Flags),
                                                                                                       TAG_DONE);
                                                                          break;

                                                   default              : break;
                                               }
                }

                GT_ReplyIMsg(intuiMsg);
            }
        }

        RemoveGList(window,global->gd_Gadgets,-1);

        ModifyIDCMP(window,IDCMP_GADGETUP);

        if (result)
        {
            if (intlGad)
            {
                global->gd_Intl   = (SELECTED & intlGad->Flags);
                global->gd_NoIntl = !(SELECTED & intlGad->Flags);
            }

            if (ffsGad)
            {
                global->gd_OFS = !(SELECTED & ffsGad->Flags);
                global->gd_FFS = (SELECTED & ffsGad->Flags);
            }

            if (dcGad)
            {
                global->gd_DirCache   = (SELECTED & dcGad->Flags);
                global->gd_NoDirCache = !(SELECTED & dcGad->Flags);
            }

            global->gd_Trashcan = (SELECTED & trashGad->Flags);
            strcpy(global->gd_VolumeName,((struct StringInfo *)volumeGad->SpecialInfo)->Buffer);

            SetAPen(window->RPort,global->gd_DrawInfo->dri_Pens[BACKGROUNDPEN]);
            RectFill(window->RPort,window->BorderLeft,window->BorderTop,
                                   window->Width-window->BorderRight-1,
                                   window->Height-window->BorderBottom-1);

            FreeGadgets(global->gd_Gadgets);
            global->gd_Gadgets   = NULL;
            global->gd_LastAdded = NULL;

            if (!global->gd_Quick)
            {
                SizeWindow(window,0,-53);

                str = GetStr(MSG_FMT_FORMATTING_HDR);
                PlaceText(global,str,(window->Width-TextLength(window->RPort,str,strlen(str))) / 2,GAUGE_TOP-6);

                DrawBB(global,GAUGE_LEFT,GAUGE_TOP,GAUGE_WIDTH,GAUGE_HEIGHT,GTBB_Recessed,TRUE,
                                                                            GT_VisualInfo, global->gd_VisualInfo,
                                                                            TAG_DONE);

                SetAPen(window->RPort,global->gd_DrawInfo->dri_Pens[TEXTPEN]);
                PutTick(global,GAUGE_LEFT);
                PutTick(global,GAUGE_LEFT+(GAUGE_WIDTH/4));
                PutTick(global,GAUGE_LEFT+(GAUGE_WIDTH/2));
                PutTick(global,GAUGE_LEFT+((GAUGE_WIDTH/4)*3));
                PutTick(global,GAUGE_RIGHT-1);

                PlaceText(global,"0%",GAUGE_LEFT,GAUGE_TOP+GAUGE_HEIGHT+12);
                PlaceText(global,"50%",GAUGE_LEFT+(GAUGE_WIDTH/2)-12,GAUGE_TOP+GAUGE_HEIGHT+12);
                PlaceText(global,"100%",GAUGE_RIGHT-32,GAUGE_TOP+GAUGE_HEIGHT+12);

                global->gd_Gadgets = CreateContext(&global->gd_LastAdded);

                ng.ng_TopEdge    = window->BorderTop+176;
                ng.ng_LeftEdge   = window->BorderLeft+146;
                ng.ng_Width      = 134;
                ng.ng_GadgetText = (STRPTR)MSG_FMT_STOP_GAD;
                ng.ng_GadgetID   = CMD_ABORT;

                CreateFmtGadget(global,BUTTON_KIND,&ng,TAG_DONE);

                if (global->gd_LastAdded)
                {
                    AddGList(window,global->gd_Gadgets,-1,-1,NULL);
                    RefreshGList(global->gd_Gadgets,window,NULL,-1);
                    GT_RefreshWindow(window,NULL);
                }
                else
                {
                    result = FALSE;
                }
            }
        }
    }

    return(result);
}


/****************************************************************************/


VOID NewList(struct List *list)
{
    list->lh_Head     = (struct Node *)&list->lh_Tail;
    list->lh_Tail     = NULL;
    list->lh_TailPred = (struct Node *)&list->lh_Head;
}


/*****************************************************************************/


VOID GetDeviceList(struct GlobalData *global, struct List *list)
{
struct Library *SysBase = (*((struct Library **) 4));
struct DosList *dl;
struct Node    *device;
STRPTR          name;
struct Node    *node;
struct List     temp;

    while (device = RemHead(list))
        FreeVec(device);

    NewList(&temp);

    dl = LockDosList(LDF_DEVICES|LDF_READ);
    while (dl = NextDosEntry(dl,LDF_DEVICES|LDF_READ))
    {
        name = (STRPTR)((ULONG)dl->dol_Name * 4);
        strcpy(global->gd_DeviceName,&name[1]);

        if (device = AllocVec(sizeof(struct Node) + (ULONG)name[0] + 2 + 100,MEMF_CLEAR|MEMF_PUBLIC))
        {
            device->ln_Name = (STRPTR)((ULONG)device + sizeof(struct Node));
            CopyMem(&name[1],device->ln_Name,(ULONG)name[0]);
/*
kprintf("GDL: 1, %s\n",device->ln_Name);
*/
            node = temp.lh_Head;
            while (node->ln_Succ)
            {
                if (Stricmp(node->ln_Name,device->ln_Name) >= 0)
                    break;
                node = node->ln_Succ;
            }
            Insert(&temp,(struct Node *)device,node->ln_Pred);
        }
    }

    UnLockDosList(LDF_DEVICES|LDF_READ);

    while (node = RemHead(&temp))
    {
        strcpy(global->gd_DeviceName,node->ln_Name);
        if (GetFSInfo(global) == 0)
        {
            strcat(node->ln_Name," (");
            strcat(node->ln_Name,global->gd_Capacity);
            strcat(node->ln_Name,")");
            AddTail(list,node);
        }
        else
        {
            FreeVec(node);
        }
    }
}


/****************************************************************************/


BOOL SelectFmtDevice(struct GlobalData *global)
{
struct Library      *SysBase = (*((struct Library **) 4));
struct NewGadget     ng;
struct IntuiMessage *intuiMsg;
struct Window       *window;
struct Gadget       *devicesGad;
struct Gadget       *continueGad;
BOOL                 result;
BOOL                 exitLoop;
WORD                 devNum;
UWORD                i;
ULONG                oldMicros;
ULONG                oldSecs;
struct List          deviceList;
struct Node         *node;

    result             = FALSE;
    window             = global->gd_Window;
    global->gd_Gadgets = CreateContext(&global->gd_LastAdded);
    devNum             = 0;
    oldMicros          = 0;
    oldSecs            = 0;

    NewList(&deviceList);
    GetDeviceList(global,&deviceList);

    ng.ng_TopEdge    = window->BorderTop+20;
    ng.ng_LeftEdge   = window->BorderLeft+8;
    ng.ng_Width      = 408;
    ng.ng_Height     = 143; 
    ng.ng_GadgetText = (STRPTR)MSG_FMT_SELECTDEV_GAD;
    ng.ng_GadgetID   = CMD_DEVICE;

    devicesGad = CreateFmtGadget(global,LISTVIEW_KIND,&ng,GTLV_Labels,       &deviceList,
                                                          GTLV_ShowSelected, NULL,
                                                          GTLV_Selected,     ~0,
                                                          LAYOUTA_SPACING, 4,
                                                          GTLV_ScrollWidth,  18,
                                                          TAG_DONE);

    ng.ng_TopEdge    = window->BorderTop+178;
    ng.ng_LeftEdge   = window->BorderLeft+8;
    ng.ng_Width      = 134;
    ng.ng_Height     = 20;
    ng.ng_GadgetText = (STRPTR)MSG_FMT_CONTINUE_GAD;
    ng.ng_GadgetID   = CMD_CONTINUE;

    continueGad = CreateFmtGadget(global,BUTTON_KIND,&ng,GA_Disabled, TRUE,
                                                         TAG_DONE);

    ng.ng_LeftEdge   = window->BorderLeft+282;
    ng.ng_GadgetText = (STRPTR)MSG_FMT_CANCEL_GAD;
    ng.ng_GadgetID   = CMD_CANCEL;

    CreateFmtGadget(global,BUTTON_KIND,&ng,TAG_DONE);

    if (global->gd_LastAdded)
    {
        AddGList(window,global->gd_Gadgets,-1,-1,NULL);
        RefreshGList(global->gd_Gadgets,window,NULL,-1);
        GT_RefreshWindow(window,NULL);

        exitLoop = FALSE;
        while (!exitLoop)
        {
            WaitPort(window->UserPort);
            if (intuiMsg = GT_GetIMsg(window->UserPort))
            {
                switch (intuiMsg->Class)
                {
                    case IDCMP_DISKINSERTED  :
                    case IDCMP_DISKREMOVED   : SetGadgetAttr(global,devicesGad,GTLV_Labels,~0,
                                                                               TAG_DONE);
                                               GetDeviceList(global,&deviceList);
                                               SetGadgetAttr(global,devicesGad,GTLV_Labels,      &deviceList,
                                                                               GTLV_Selected,    devNum,
                                                                               GTLV_MakeVisible, devNum,
                                                                               TAG_DONE);
                                               break;

                    case IDCMP_GADGETUP      :
                    case IDCMP_GADGETDOWN    : switch (((struct Gadget *)intuiMsg->IAddress)->GadgetID)
                                               {
                                                   case CMD_DEVICE      : SetGadgetAttr(global,continueGad,GA_Disabled,FALSE,
                                                                                                           TAG_DONE);
                                                                          devNum = intuiMsg->Code;
                                                                          if (!DoubleClick(oldSecs,oldMicros,intuiMsg->Seconds,intuiMsg->Micros))
                                                                          {
                                                                              oldSecs   = intuiMsg->Seconds;
                                                                              oldMicros = intuiMsg->Micros;
                                                                              break;
                                                                          }
                                                   case CMD_CONTINUE    : result = TRUE;
                                                   case CMD_CANCEL      : exitLoop = TRUE;
                                                                          break;

                                                   default              : break;
                                               }
                }

                GT_ReplyIMsg(intuiMsg);
            }
        }

        RemoveGList(window,global->gd_Gadgets,-1);
    }

    while (node = RemHead(&deviceList))
    {
        if (devNum == 0)
        {
            i = 0;
            while (node->ln_Name[i] != ' ')
            {
                global->gd_DeviceName[i] = node->ln_Name[i];
                i++;
            }
            global->gd_DeviceName[i] = 0;
        }
        devNum--;
        FreeVec(node);
    }

    FreeGadgets(global->gd_Gadgets);
    global->gd_Gadgets = NULL;

    if (result && !GetFSInfo(global))
        return(TRUE);

    return(FALSE);
}


/****************************************************************************/


VOID CloseFmtWindow(struct GlobalData *global)
{
    if (global->gd_Window)
        CloseWindow(global->gd_Window);

    if (global->gd_DrawInfo)
        FreeScreenDrawInfo(global->gd_Screen,global->gd_DrawInfo);

    if (global->gd_VisualInfo)
        FreeVisualInfo(global->gd_VisualInfo);

    if (global->gd_Screen)
        UnlockPubScreen(NULL,global->gd_Screen);

    if (global->gd_Font)
        CloseFont(global->gd_Font);

    FreeGadgets(global->gd_Gadgets);

    global->gd_Window     = NULL;
    global->gd_DrawInfo   = NULL;
    global->gd_VisualInfo = NULL;
    global->gd_Screen     = NULL;
    global->gd_Font       = NULL;
    global->gd_Gadgets    = NULL;
}


/****************************************************************************/


BOOL CreateTrashcan(struct GlobalData *global, STRPTR deviceName)
{
struct Library    *SysBase = (*((struct Library **) 4));
struct Library    *IconBase;
BPTR               lock;
BPTR               oldCD;
BPTR               new;
struct DiskObject *diskObj;
BOOL               result;

    result = FALSE;

    if (lock = Lock(deviceName,ACCESS_READ))
    {
        oldCD = CurrentDir(lock);
        if (new = CreateDir("Trashcan"))
        {
            UnLock(new);

            if (IconBase = OpenLibrary("icon.library",37))
            {
                if (diskObj = (struct DiskObject *)GetDefDiskObject(WBGARBAGE))
                {
                    result = PutDiskObject("Trashcan",diskObj);
                    FreeDiskObject(diskObj);
                }
                CloseLibrary(IconBase);
            }
        }
        CurrentDir(oldCD);
        UnLock(lock);
    }

    return(result);
}


/****************************************************************************/


VOID VPrintF(struct GlobalData *global, STRPTR str, STRPTR arg1, ... )
{
    VPrintf(str,(LONG *)&arg1);
}


/*****************************************************************************/


VOID PrintF(struct GlobalData *global, AppStringsID str, STRPTR arg1, ... )
{
struct EasyStruct est;

    if (!global->gd_GUI)
    {
        VPrintf(GetStr(str),(LONG *)&arg1);
        VPrintf("\n",NULL);
    }
    else
    {
        est.es_StructSize   = sizeof(struct EasyStruct);
        est.es_Flags        = 0;
        est.es_Title        = GetStr(MSG_FMT_FAILED_TITLE);
        est.es_TextFormat   = GetStr(str);
        est.es_GadgetFormat = GetStr(MSG_FMT_CANCEL_GAD);

        EasyRequestArgs(NULL,&est,NULL,&arg1);
    }
}


/*****************************************************************************/


BOOL WriteProtect(struct GlobalData *global, STRPTR deviceName)
{
struct EasyStruct est;
ULONG             idcmp;

    est.es_StructSize   = sizeof(struct EasyStruct);
    est.es_Flags        = 0;
    est.es_Title        = GetStr(MSG_FMT_REQUEST_TITLE);
    est.es_TextFormat   = GetStr(MSG_FMT_WRITEPROTECT);
    est.es_GadgetFormat = GetStr(MSG_FMT_WRITEPROTECT_GAD);

    idcmp = IDCMP_DISKINSERTED;

    return (EasyRequestArgs(NULL,&est,&idcmp,&deviceName) != 0);
}


/*****************************************************************************/


BOOL ReallyFormat(struct GlobalData *global)
{
struct EasyStruct est;
STRPTR            name;
ULONG             msg;
char              prompt[200];
STRPTR            args[1];
BOOL              biggy;
BOOL              result;

    if (global->gd_OldVolumeName[0] == 0)
    {
        name = global->gd_DeviceName;
        msg  = MSG_FMT_CONFIRM_2;
    }
    else
    {
        name = global->gd_OldVolumeName;
        msg  = MSG_FMT_CONFIRM_1;
    }

    sprintf(prompt,GetStr(msg),name,global->gd_Capacity);
    args[0] = prompt;

    est.es_StructSize   = sizeof(struct EasyStruct);
    est.es_Flags        = 0;
    est.es_Title        = GetStr(MSG_FMT_REQUEST_TITLE);
    est.es_TextFormat   = "%s";
    est.es_GadgetFormat = GetStr(MSG_FMT_CONFIRM_GAD);

    biggy = ((global->gd_NumBlocks * global->gd_BytesPerBlock) > BIGDRIVESIZE);
    if ((result = EasyRequestArgs(NULL,&est,NULL,&args)) && biggy)
    {
        sprintf(prompt,GetStr(MSG_FMT_CONFIRM_3),global->gd_DeviceName,global->gd_Capacity);
        result = EasyRequestArgs(NULL,&est,NULL,&args);
    }

    return(result);
}


/*****************************************************************************/


VOID ShowProgress(struct GlobalData *global, BOOL writing, BOOL forceUpdate)
{
struct Window *window;
ULONG          currentCyl, totalCyl;

    currentCyl = global->gd_CurrentCyl-global->gd_LowCyl;
    totalCyl   = global->gd_NumberCyl;

    if (totalCyl >= 1000)
    {
        if (currentCyl % 50 == 0)
            forceUpdate = TRUE;
    }
    else if (totalCyl >= 100)
    {
        if (currentCyl % 10 == 0)
            forceUpdate = TRUE;
    }
    else
    {
        forceUpdate = TRUE;
    }

    if (forceUpdate)
    {
        if (!global->gd_GUI)
        {
            if (writing)
                VPrintF(global,GetStr(MSG_FMT_FORMATTING),(STRPTR)currentCyl,(STRPTR)(totalCyl-currentCyl-1));
            else
                VPrintF(global,GetStr(MSG_FMT_VERIFYING),(STRPTR)currentCyl,(STRPTR)(totalCyl-currentCyl-1));
        }
        else if (window = global->gd_Window)
        {
            SetAPen(window->RPort,global->gd_DrawInfo->dri_Pens[FILLPEN]);

            RectFill(window->RPort,window->BorderLeft+GAUGE_LEFT+2,
                                   window->BorderTop+GAUGE_TOP+1,
                                   window->BorderLeft+GAUGE_LEFT+((GAUGE_WIDTH-5)*currentCyl/totalCyl)+2,
                                   window->BorderTop+GAUGE_BOTTOM-1);
        }
    }
}


/*****************************************************************************/


VOID ShowComplete(struct GlobalData *global)
{
    if (!global->gd_GUI)
    {
        VPrintF(global,"%s","\n");
    }
}


/*****************************************************************************/


VOID ShowIniting(struct GlobalData *global)
{
struct Window *window;
STRPTR         str;

    if (!global->gd_GUI)
    {
        PrintF(global,MSG_FMT_INITING,NULL);
    }
    else if (window = global->gd_Window)
    {
        SetAPen(window->RPort,global->gd_DrawInfo->dri_Pens[BACKGROUNDPEN]);
        RectFill(window->RPort,window->BorderLeft,window->BorderTop,
                               window->Width-window->BorderRight-1,
                               window->Height-window->BorderBottom-1);
        str = GetStr(MSG_FMT_INITING);
        PlaceText(global,str,(window->Width-TextLength(window->RPort,str,strlen(str))) / 2,
                             (window->Height - window->RPort->TxHeight - window->BorderTop - window->BorderBottom) / 2 + window->RPort->TxBaseline);
    }
}


/****************************************************************************/


LONG DoFormat(struct GlobalData *global, struct DosList *deviceNode,
              BOOL ofs, BOOL ffs,
              BOOL intl, BOOL nointl,
              BOOL dircache, BOOL nodircache,
              BOOL quick,
              STRPTR volumeName)
{
struct Library            *SysBase = (*((struct Library **) 4));
struct InfoData __aligned  infoData;
char            __aligned  volumeNameB[40];
struct MsgPort            *fsPort;
struct FileSysStartupMsg  *fssm;
struct DosEnvec           *env;
ULONG                      memType;
LONG                       wordsPerBlk;
LONG                       bytesPerBlk;
LONG                       lowCyl;
LONG                       highCyl;
LONG                       blocksPerCyl;
LONG			   blocksPerDisk;
LONG                       bytesPerCyl;
LONG                       rootBlk;
struct IOStdReq           *devIO;
struct MsgPort            *devPort;
struct RootBlock          *root;
LONG                      *cylinder;
LONG                       error;
LONG                       i, cyl, sum;
LONG                      *p;
UBYTE                      failCnt;
BOOL                       write;
ULONG                      dosType;
ULONG                      maxTrans;
ULONG                      transCnt;
ULONG                      transSize;

    fsPort = deviceNode->dol_Task;

    error = ERROR_NO_DISK;
    if (DoPkt1(fsPort,ACTION_DISK_INFO,MKBADDR(&infoData)))
    {
        /* check if disk present */
        if (infoData.id_DiskType != ID_NO_DISK_PRESENT)
        {
            /* check volume for inhibited already */
            error = ERROR_OBJECT_IN_USE;
            if (infoData.id_DiskType != ID_BUSY_DISK)
            {
                error = ERROR_DISK_WRITE_PROTECTED;
                if (infoData.id_DiskState != ID_WRITE_PROTECTED)
                {
                    /* extract the disk parameters */
                    fssm = GetFSSM(global,deviceNode);
                    env  = (struct DosEnvec *)BADDR(fssm->fssm_Environ);

                    memType = MEMF_CHIP | MEMF_CLEAR;
                    dosType = ID_DOS_DISK;

                    if (env->de_TableSize >= DE_DOSTYPE)
                        dosType = env->de_DosType;

                    if (ffs && ((dosType == ID_DOS_DISK) || (dosType == ID_INTER_DOS_DISK) || (dosType == ID_DC_DOS_DISK)))
                        dosType = dosType + 1;  /* OFS --> FFS */

                    if (ofs && ((dosType == ID_FFS_DISK) || (dosType == ID_INTER_FFS_DISK) || (dosType == ID_DC_FFS_DISK)))
                        dosType = dosType - 1;  /* FFS --> OFS */

                    if (dircache && ((dosType == ID_DOS_DISK) || (dosType == ID_FFS_DISK)))
                        dosType = dosType + 4;  /* OFS/FFS --> QFS */

                    if (nodircache && ((dosType == ID_DC_DOS_DISK) || (dosType == ID_DC_FFS_DISK)))
                        dosType = dosType - 4;  /* QFS --> OFS/FFS */

                    if (intl && ((dosType == ID_DOS_DISK) || (dosType == ID_FFS_DISK)))
                        dosType = dosType + 2;  /* NOINTL --> INTL */

                    if (nointl && ((dosType == ID_INTER_DOS_DISK) || (dosType == ID_INTER_FFS_DISK)))
                        dosType = dosType - 2;  /* INTL --> NOINTL */

                    if (env->de_TableSize >= DE_BUFMEMTYPE)
                        memType = env->de_BufMemType | MEMF_CLEAR;

                    wordsPerBlk   = env->de_SizeBlock;
                    bytesPerBlk   = wordsPerBlk * 4;
                    blocksPerCyl  = env->de_BlocksPerTrack * env->de_Surfaces;
                    lowCyl        = env->de_LowCyl;
                    highCyl       = env->de_HighCyl;
                    blocksPerDisk = blocksPerCyl * (highCyl - lowCyl + 1);
                    bytesPerCyl   = bytesPerBlk * blocksPerCyl;
                    rootBlk       = (blocksPerDisk - 1 + env->de_Reserved) >> 1;
                    maxTrans      = bytesPerCyl;

                    if (env->de_TableSize >= DE_MAXTRANSFER)
                        maxTrans = env->de_MaxTransfer;

                    if (maxTrans > bytesPerCyl)
                        maxTrans = bytesPerCyl;

                    if (maxTrans > 65536)   /* no reason for this number, just sounds good to me */
                    {
                        if (bytesPerBlk < 65536)
                            maxTrans = (65536 / bytesPerBlk) * bytesPerBlk;
                        else
                            maxTrans = bytesPerBlk;
                    }

                    global->gd_NumberCyl = highCyl-lowCyl+1;

                    error   = ERROR_NO_FREE_STORE;
                    devPort = CreateMsgPort();
                    if (devIO = (struct IOStdReq *)CreateIORequest(devPort,sizeof(struct IOStdReq)))
                    {
                        error = ERROR_BREAK;
                        if (!CheckBreak())
                        {
                            error = ERROR_NO_DISK;
                            if (DoPkt1(fsPort,ACTION_INHIBIT,DOSTRUE))
                            {
                                error = IOERR_OPENFAIL;
                                if (!OpenDevice(BTOCSTR(fssm->fssm_Device),fssm->fssm_Unit,devIO,fssm->fssm_Flags))
                                {
                                    error = 0;
                                    if (!quick)
                                    {
                                        /* do the track-level formatting */
                                        error = ERROR_NO_FREE_STORE;
                                        if (cylinder = AllocVec(maxTrans,memType))
                                        {
                                            error = 0;
                                            cyl   = lowCyl;

                                            global->gd_CurrentCyl = cyl;
                                            global->gd_LowCyl     = cyl;
                                            ShowProgress(global,TRUE,TRUE);

                                            while ((cyl <= highCyl) && !error)
                                            {
                                                global->gd_CurrentCyl = cyl;
                                                for (i = 0; i < maxTrans / 4; i++)
                                                    cylinder[i] = cyl - lowCyl << 16 | i | dosType;

                                                if (cyl == lowCyl)
                                                    cylinder[0] = ID_BAD_DISK;

                                                failCnt   = 0;
                                                transCnt  = 0;
                                                transSize = maxTrans;
                                                write     = TRUE;
                                                while (TRUE)
                                                {
                                                    if (CheckBreak())
                                                    {
                                                        error = ERROR_BREAK;
                                                        break;
                                                    }

                                                    if (write)
                                                        devIO->io_Command = TD_FORMAT;
                                                    else
                                                        devIO->io_Command = CMD_READ;

                                                    devIO->io_Data   = cylinder;
                                                    devIO->io_Length = transSize;
                                                    devIO->io_Offset = cyl * bytesPerCyl + transCnt;

                                                    ShowProgress(global,write,FALSE);

                                                    transCnt += transSize;

                                                    if (error = DoIO(devIO))
                                                    {
                                                        ShowProgress(global,write,TRUE);
                                                        failCnt++;
                                                    }
                                                    else if (!write)
                                                    {
                                                        break;
                                                    }
                                                    else if (transCnt == bytesPerCyl)
                                                    {
                                                        write     = FALSE;
                                                        transCnt  = 0;
                                                        transSize = maxTrans;
                                                    }
                                                    else if (transSize > bytesPerCyl - transCnt)
                                                    {
                                                        transSize = bytesPerCyl - transCnt;
                                                    }

                                                    if (failCnt > MAXERRORS)
                                                    {
                                                        break;
                                                    }
                                                }
                                                cyl++;
                                            }
                                            ShowProgress(global,write,TRUE);
                                            ShowComplete(global);
                                        }
                                        FreeVec(cylinder);
                                    }

                                    if (!error)
                                    {
                                        ShowIniting(global);

                                        /* now put a root block on this sucker */
                                        volumeNameB[0] = strlen(volumeName);
                                        strcpy(&volumeNameB[1],volumeName);

                                        if (!DoPkt2(fsPort,ACTION_FORMAT,MKBADDR(volumeNameB),dosType)
                                        && ((error = IoErr()) == ERROR_ACTION_NOT_KNOWN))
                                        {
                                            /* try the old fashion way, then */
                                            error = ERROR_NO_FREE_STORE;
                                            if (root = AllocVec(bytesPerBlk,memType))
                                            {
                                                root->rb_Type          = T_SHORT;
                                                root->rb_HashSize      = HASHSIZE;
                                                root->rb_SecondaryType = ST_ROOT;
                                                root->rb_BMFlag        = 0;

                                                DateStamp(&root->rb_CreateDate);
                                                DateStamp(&root->rb_LastDate);

                                                root->rb_DiskName[0] = strlen(volumeName);
                                                strcpy(&root->rb_DiskName[1],volumeName);

                                                root->rb_CheckSum = sum = 0;
                                                for (i = 0, p = (LONG *)root; i < wordsPerBlk; sum = sum + *p++, i++);
                                                root->rb_CheckSum = -sum;

                                                devIO->io_Command = CMD_WRITE;
                                                devIO->io_Data    = root;
                                                devIO->io_Length  = bytesPerBlk;
                                                devIO->io_Offset  = rootBlk * bytesPerBlk + lowCyl * bytesPerCyl;
                                                error = DoIO(devIO);

                                                if (!error)
                                                {
                                                    /* make disk look valid (boot block) */
                                                    cylinder = (LONG *)root;
                                                    for (i = 0; i < wordsPerBlk; i++)
                                                        cylinder[i] = dosType;

                                                    devIO->io_Command = CMD_WRITE;
                                                    devIO->io_Length  = bytesPerBlk;
                                                    devIO->io_Offset  = lowCyl * bytesPerCyl;
                                                    devIO->io_Data    = cylinder;
                                                    error = DoIO(devIO);
                                                }

                                                FreeVec(root);
                                            }
                                        }
                                    }

                                    if (!error)
                                    {
                                        devIO->io_Command = CMD_UPDATE;
                                        devIO->io_Length  = 0;
                                        devIO->io_Offset  = 0;
                                        devIO->io_Data    = 0;
                                        error = DoIO(devIO);
                                    }

                                    if (!error)
                                    {
                                        devIO->io_Command = CMD_CLEAR;
                                        devIO->io_Length  = 0;
                                        devIO->io_Offset  = 0;
                                        devIO->io_Data    = 0;
                                        error = DoIO(devIO);
                                    }

                                    /* turn disk motor off */
                                    devIO->io_Command = TD_MOTOR;
                                    devIO->io_Length  = 0;
                                    devIO->io_Offset  = 0;
                                    devIO->io_Data    = 0;
                                    DoIO(devIO);

                                    CloseDevice(devIO);
                                }
                                DoPkt1(fsPort,ACTION_INHIBIT,DOSFALSE);

                                if (!error)
                                {
                                    /* wait for drive to get ready. Need time for file
                                     * system to validate before we can sanction it as
                                     * valid, and maybe write a trashcan to it
                                     */

                                    error = ERROR_NOT_A_DOS_DISK;
                                    i = 0;
                                    while (i < 100)
                                    {
                                        Delay(15);
                                        if (DoPkt1(fsPort,ACTION_DISK_INFO,MKBADDR(&infoData)))
                                        {
                                            if (infoData.id_DiskState != ID_VALIDATING)
                                            {
                                                if ((infoData.id_DiskType == dosType)
                                                ||  (infoData.id_DiskType >= ID_DOS_DISK)
                                                &&  (infoData.id_DiskType <= ID_DC_FFS_DISK))
                                                {
                                                    error = 0;
                                                    break;
                                                }
                                            }
                                        }
                                        i++;
                                    }
                                }
                            }
                        }
                    }
                    DeleteMsgPort(devPort);
                    DeleteIORequest(devIO);
                }
            }
        }
    }

    return(error);
}


/****************************************************************************/


LONG Initialize(struct GlobalData *global)
{
LONG   error;
char   dosString[100];
STRPTR deviceName;

    deviceName = global->gd_DeviceName;

    while (TRUE)
    {
        error = DoFormat(global,global->gd_DeviceNode,
                         global->gd_OFS,global->gd_FFS,
                         global->gd_Intl,global->gd_NoIntl,
                         global->gd_DirCache,global->gd_NoDirCache,
                         global->gd_Quick,global->gd_VolumeName);

        if ((error != ERROR_DISK_WRITE_PROTECTED) && (error != TDERR_WriteProt))
            break;

        if (!WriteProtect(global,deviceName))
        {
            error = ERROR_DISK_WRITE_PROTECTED;
            break;
        }
    }

    if (!error && global->gd_Trashcan)
    {
        strcpy(dosString,deviceName);
        strcat(dosString,":");
        if (!CreateTrashcan(global,dosString))
            error = ERROR_NO_TRASH;
    }

    if (error)
    {
        if ((error != ERROR_BREAK) && (!global->gd_GUI))
            VPrintF(global,"%s: ",GetStr(MSG_FMT_FAILED_TITLE));

        switch (error)
        {
            case ERROR_NO_TRASH      : PrintF(global,MSG_FMT_FAILED_TRASHCAN,global->gd_VolumeName);
                                       return(0);

            case IOERR_OPENFAIL      : PrintF(global,MSG_FMT_FAILED_NODEVICE,deviceName);
                                       return(ERROR_DEVICE_NOT_MOUNTED);

            case TDERR_DiskChanged   : PrintF(global,MSG_FMT_FAILED_DISKCHANGED,deviceName);
                                       return(ERROR_NO_DISK);

            case TDERR_WriteProt     : error = ERROR_DISK_WRITE_PROTECTED;

            case TDERR_SeekError     : if (error == TDERR_SeekError)
                                           error = ERROR_SEEK_ERROR;

            default                  : if (error >= ERROR_NO_FREE_STORE)
                                       {
                                           if ((error != ERROR_BREAK) || (!global->gd_GUI))
                                           {
                                               Fault(error,NULL,dosString,sizeof(dosString));
                                               PrintF(global,MSG_FMT_FAILED_DOS,dosString);
                                           }
                                           return(error);
                                       }

            case TDERR_BadSecPreamble:
            case TDERR_BadSecID      :
            case TDERR_BadHdrSum     :
            case TDERR_BadSecSum     :
            case TDERR_TooFewSecs    :
            case TDERR_BadSecHdr     : PrintF(global,MSG_FMT_FAILED_BADCYL,(STRPTR)global->gd_CurrentCyl);
                                       return(ERROR_NOT_A_DOS_DISK);

        }
    }

    return(0);
}
@


38.34
log
@Made it open diskfont library, and changed the font to coral.font
@
text
@d33 1
d44 1
d227 1
a227 1
#define GAUGE_BOTTOM   39
d714 1
a714 1
                    tags[2].ti_Data = 141;
d888 1
a888 1
    ng.ng_Height     = 10;
d895 1
a895 1
    ng.ng_TopEdge    = window->BorderTop+15;
d900 1
a900 1
    ng.ng_TopEdge    = window->BorderTop+24;
d905 1
a905 1
    ng.ng_TopEdge    = window->BorderTop+44;
d907 1
a907 1
    ng.ng_Height     = 14;
d914 2
a915 2

    ng.ng_TopEdge    = window->BorderTop+60;
d917 1
a917 1
    ng.ng_Height     = 14;
d930 1
a930 1
        ng.ng_TopEdge    = window->BorderTop+74;
d938 1
a938 1
        ng.ng_TopEdge    = window->BorderTop+88;
d947 1
a947 1
        ng.ng_TopEdge    = window->BorderTop+102;
d956 1
a956 1
    ng.ng_TopEdge    = window->BorderTop+124;
d1121 1
a1121 1
                ng.ng_TopEdge    = window->BorderTop+71;
d1249 1
a1249 1
    ng.ng_TopEdge    = window->BorderTop+18;
d1252 1
a1252 1
    ng.ng_Height     = 100;
d1259 1
a1259 1
                                                          LAYOUTA_SPACING,   1,
d1263 1
a1263 1
    ng.ng_TopEdge    = window->BorderTop+124;
d1266 1
a1266 1
    ng.ng_Height     = 14;
@


38.33
log
@Fixed non-localization of "Directory Caching" string
Now uses new GTTX_Clipped tag to avoid volume names running off the right side of
  the window
Now deals with 30 characters volume names correctly
@
text
@d99 2
a100 2
    "topaz.font",
     8,
d102 1
a102 1
     FPF_ROMFONT
d144 1
d188 1
d270 1
d273 1
a273 1
    if (DOSBase && IntuitionBase && GfxBase && UtilityBase && GadToolsBase)
d497 1
d705 1
a705 1
                if (global->gd_Font = OpenFont(&topazAttr))
@


38.32
log
@Fixed gadget positioning in "Select Device" window
No longer auto-selects a device in that window, the user has to click on one
  explicitly
@
text
@d156 3
a158 3
    char               gd_OldVolumeName[NAMELENGTH];
    char               gd_DeviceName[NAMELENGTH];
    char               gd_VolumeName[NAMELENGTH];
d410 1
a410 1
                while ((i < NAMELENGTH) && volName[i] && (volName[i] != ':') && (volName[i] != '/'))
d536 1
a536 1
char                       colonName[NAMELENGTH+1];
d767 1
a767 4
    if (ng->ng_GadgetText == (STRPTR)999)
        ng->ng_GadgetText = "Directory Caching:";
    else
        ng->ng_GadgetText = GetStr((ULONG)ng->ng_GadgetText);
d881 1
a881 1
    ng.ng_Width      = 226;
d886 2
a887 1
    info1Gad = CreateFmtGadget(global,TEXT_KIND,&ng,TAG_DONE);
d891 2
a892 1
    info2Gad = CreateFmtGadget(global,TEXT_KIND,&ng,TAG_DONE);
d896 2
a897 1
    info3Gad = CreateFmtGadget(global,TEXT_KIND,&ng,TAG_DONE);
d943 1
a943 1
        ng.ng_GadgetText = (STRPTR)999;   /* !!!! TEMPORARY !!!! */
@


38.31
log
@*** empty log message ***
@
text
@d1223 1
d1246 1
a1246 1
    ng.ng_Height     = 80;
d1252 1
a1252 1
                                                          GTLV_Selected,     0,
d1257 1
a1257 1
    ng.ng_TopEdge    = window->BorderTop+110;
d1264 2
a1265 1
    CreateFmtGadget(global,BUTTON_KIND,&ng,TAG_DONE);
d1300 3
a1302 1
                                                   case CMD_DEVICE      : devNum = intuiMsg->Code;
@


38.30
log
@Changed handling of dir cache/intl mode checkboxes in relation to one another
@
text
@d554 3
a556 1

d560 3
d568 3
d579 4
d584 1
d588 3
a590 1

d593 3
a595 1

d601 3
a603 1

d606 3
d1179 3
a1181 1

@


38.29
log
@*** empty log message ***
@
text
@d843 1
d915 1
a915 1
        intlGad = CreateFmtGadget(global,CHECKBOX_KIND,&ng,GTCB_Checked, global->gd_Intl,
a924 1
                                                         GA_Disabled, global->gd_Intl,
d963 1
d1017 1
a1017 1
                                                   case CMD_INTL        : SetGadgetAttr(global,dcGad,GA_Disabled,(GFLG_SELECTED & intlGad->Flags),TAG_DONE);
d1020 3
a1022 1
                                                   case CMD_DC          : SetGadgetAttr(global,intlGad,GA_Disabled,(GFLG_SELECTED & dcGad->Flags),TAG_DONE);
@


38.28
log
@Now auto-activates Volume string gadget
Now correctly handles failure to validate. Was checking infoData structure are the
  wrong time.
@
text
@d1869 1
d1878 7
a1884 2
                                                error = ERROR_NOT_A_DOS_DISK;
                                                break;
a1888 6

                                    if (!error)
                                        if ((infoData.id_DiskType != dosType)
                                        &&  (infoData.id_DiskType < ID_DOS_DISK)
                                        &&  (infoData.id_DiskType > ID_DC_FFS_DISK))
                                            error = ERROR_NOT_A_DOS_DISK;
@


38.27
log
@Removed conditional code, DCFS now always enabled
@
text
@d960 2
d1876 2
d1879 1
d1884 5
a1888 4
                                    if ((infoData.id_DiskType != dosType)
                                    &&  (infoData.id_DiskType < ID_DOS_DISK)
                                    &&  (infoData.id_DiskType > ID_DC_FFS_DISK))
                                        error = ERROR_NOT_A_DOS_DISK;
@


38.26
log
@Expanded size of prompt buffer in ReallyFormat()
@
text
@d109 1
a109 2
#define TEMPLATE_37    "DEVICE=DRIVE/K/A,NAME/K/A,OFS/S,FFS/S,INTL=INTERNATIONAL/S,NOINTL=NOINTERNATIONAL/S,NOICONS/S,QUICK/S" VERSTAG
#define TEMPLATE_39    "DEVICE=DRIVE/K/A,NAME/K/A,OFS/S,FFS/S,INTL=INTERNATIONAL/S,NOINTL=NOINTERNATIONAL/S,DIRCACHE/S,NODIRCACHE/S,NOICONS/S,QUICK/S" VERSTAG
d263 5
a267 5
    DOSBase        = OpenLibrary("dos.library",37);
    IntuitionBase  = OpenLibrary("intuition.library",37);
    GfxBase        = OpenLibrary("graphics.library",37);
    UtilityBase    = OpenLibrary("utility.library",37);
    GadToolsBase   = OpenLibrary("gadtools.library",37);
d395 2
a396 6
#ifdef DCFS
            rdargs = ReadArgs(TEMPLATE_39,opts,NULL);
#else
            rdargs = ReadArgs(TEMPLATE_37,opts,NULL);
#endif
            if (rdargs)
a403 1
#ifdef DCFS
a407 4
#else
                global->gd_Quick      =  (BOOL)opts[OPT_QUICK-2];
                global->gd_Trashcan   = !(BOOL)opts[OPT_NOICONS-2];
#endif
a685 1
#ifdef DCFS
a686 4
#else
                    tags[2].ti_Data = 127;
#endif

a842 2

#ifdef DCFS
a843 1
#endif
a896 1
#ifdef DCFS
a897 1
#endif
a914 1
#ifdef DCFS
a915 1
#endif
a917 1
#ifdef DCFS
a925 1
#endif
a927 1
#ifdef DCFS
a928 4
#else
    ng.ng_TopEdge    = window->BorderTop+110;
#endif

a1013 1
#ifdef DCFS
d1019 1
a1019 1
#endif
a1045 1
#ifdef DCFS
a1050 1
#endif
a1065 1
#ifdef DCFS
d1067 1
a1067 3
#else
                SizeWindow(window,0,-39);
#endif
d1260 3
a1262 2
                                               SetGadgetAttr(global,devicesGad,GTLV_Labels,   &deviceList,
                                                                               GTLV_Selected, devNum,
@


38.25
log
@No longer disables Quick Format gadget, was not working right
@
text
@d1484 1
a1484 1
char              prompt[120];
@


38.24
log
@*** empty log message ***
@
text
@d969 6
a974 1
    quickGad = CreateFmtGadget(global,BUTTON_KIND,&ng,GA_Disabled,(global->gd_OldVolumeName[0] == 0),
@


38.23
log
@Added code to deal with devices returning 0 for BlocksPerTrack
@
text
@a824 28
VOID PrintInfo(struct GlobalData *global, struct Gadget *gad0,
	       struct Gadget *gad1, struct Gadget *gad2)
{
char string0[80];
char string1[80];
char string2[80];

    sprintf(string0,GetStr(MSG_FMT_DEVNAME),global->gd_DeviceName);
    if (global->gd_OldVolumeName[0] == 0)
    {
        strcpy(string1,global->gd_Capacity);
        string2[0] = 0;
    }
    else
    {
        sprintf(string1,GetStr(MSG_FMT_VOLNAME),global->gd_OldVolumeName);
        strcpy(string2,global->gd_Capacity);
    }

    SetGadgetAttr(global,gad0,GTTX_Text,string0,TAG_DONE);
    SetGadgetAttr(global,gad1,GTTX_Text,string1,TAG_DONE);
    SetGadgetAttr(global,gad2,GTTX_Text,string2,TAG_DONE);
}


/****************************************************************************/


d854 4
d935 1
d937 1
d947 1
d984 1
a984 1
        PrintInfo(global,info1Gad,info2Gad,info3Gad);
d989 21
d1017 1
a1017 1
                                               PrintInfo(global,info1Gad,info2Gad,info3Gad);
d1039 3
a1042 1
                                                                          global->gd_DirCache = (GFLG_SELECTED & dcGad->Flags);
@


38.22
log
@Fixed validation check, again
@
text
@d602 9
@


38.21
log
@Builds the device list in a different way, to avoid making dos calls while the
  DOS device list semaphore is locked
@
text
@d1898 2
a1899 4
                                    &&  !((infoData.id_DiskType >= ID_DOS_DISK)
                                        && (infoData.id_DiskType <= ID_DC_FFS_DISK)
                                        && (dosType >= ID_DOS_DISK)
                                        && (dosType <= ID_DC_FFS_DISK)))
@


38.20
log
@Added code to support DOS\4 and DOS\5 file systems
Removed conditional code for magical CrossDOS kludge
@
text
@d1154 1
a1154 1
char            data[100];
d1159 2
d1167 1
a1167 1
        if (GetFSInfo(global) == 0)
d1169 5
a1173 2
            sprintf(data," (%s)",global->gd_Capacity);
            if (device = AllocVec(sizeof(struct Node) + (ULONG)name[0] + 2 + strlen(data),MEMF_CLEAR|MEMF_PUBLIC))
d1175 3
a1177 12
                device->ln_Name = (STRPTR)((ULONG)device + sizeof(struct Node));
                CopyMem(&name[1],device->ln_Name,(ULONG)name[0]);
                strcat(device->ln_Name,data);

                node = list->lh_Head;
                while (node->ln_Succ)
                {
                    if (Stricmp(node->ln_Name,device->ln_Name) >= 0)
                        break;
                    node = node->ln_Succ;
                }
                Insert(list,(struct Node *)device,node->ln_Pred);
d1179 1
d1184 16
@


38.19
log
@Fixed incorrect delay after formatting. We gotta wait until the file system
  is truly ready before writing to it.
CreateTrashcan() now obtains a shared lock on the device name instead of a 
  write lock. This would cause it to fail if Workbench happened to be looking
  at the device at the same time, following the uninhibit
@
text
@d70 2
d109 13
a121 1
#ifndef CROSSDOSKLUDGE
a122 10
#define TEMPLATE     "DEVICE=DRIVE/K/A,NAME/K/A,OFS/S,FFS/S,INTL=INTERNATIONAL/S,NOINTL=NOINTERNATIONAL/S,NOICONS/S,QUICK/S" VERSTAG
#define OPT_DEVICE   0
#define OPT_NAME     1
#define OPT_OFS      2
#define OPT_FFS	     3
#define OPT_INTL     4
#define OPT_NOINTL   5
#define OPT_NOICONS  6
#define OPT_QUICK    7
#define OPT_COUNT    8
a123 17
#else

#define TEMPLATE     "DEVICE=DRIVE/K/A,NAME/K/A,OFS/S,FFS/S,INTL=INTERNATIONAL/S,NOINTL=NOINTERNATIONAL/S,NOICONS/S,QUICK/S,CROSSDOS/S" VERSTAG
#define OPT_DEVICE   0
#define OPT_NAME     1
#define OPT_OFS      2
#define OPT_FFS	     3
#define OPT_INTL     4
#define OPT_NOINTL   5
#define OPT_NOICONS  6
#define OPT_QUICK    7
#define OPT_CROSSDOS 8
#define OPT_COUNT    8

#endif


d155 1
d166 2
a167 1
    BOOL 	       gd_PCFormat;
d169 1
d279 8
a286 6
            global->gd_Quick    = FALSE;
            global->gd_Trashcan = TRUE;
            global->gd_OFS      = FALSE;
            global->gd_FFS      = FALSE;
            global->gd_Intl     = FALSE;
            global->gd_NoIntl   = FALSE;
d306 6
a311 4
                        global->gd_OFS    = FALSE;
                        global->gd_FFS    = FALSE;
                        global->gd_Intl   = FALSE;
                        global->gd_NoIntl = FALSE;
d396 6
a401 1
            if (rdargs = ReadArgs(TEMPLATE,opts,NULL))
d403 14
a416 10
                volName             =  (STRPTR)opts[OPT_NAME];
                devName             =  (STRPTR)opts[OPT_DEVICE];
                global->gd_OFS      =  (BOOL)opts[OPT_OFS];
                global->gd_FFS      =  (BOOL)opts[OPT_FFS];
                global->gd_Intl     =  (BOOL)opts[OPT_INTL];
                global->gd_NoIntl   =  (BOOL)opts[OPT_NOINTL];
                global->gd_Quick    =  (BOOL)opts[OPT_QUICK];
                global->gd_Trashcan = !(BOOL)opts[OPT_NOICONS];
#ifdef CROSSDOSKLUDGE
                global->gd_PCFormat =  (BOOL)opts[OPT_CROSSDOS];
d418 1
a529 2
#ifdef CROSSDOSKLUDGE

a531 3
#else

#define ACTION_GET_FSSM 35
a532 19
struct FileSysStartupMsg *GetFSSM(struct GlobalData *global,
                                  struct DosList *device)
{
struct FileSysStartupMsg *fssm;
ULONG                     dosType;

    dosType = ID_DOS_DISK;
    if (global->gd_PCFormat)
        dosType = ID_MSDOS_DISK;

    if (fssm = (struct FileSysStartupMsg *)DoPkt1(global->gd_DeviceNode->dol_Task,ACTION_GET_FSSM,dosType))
        return(fssm);

    return((struct FileSysStartupMsg *)(device->dol_misc.dol_handler.dol_Startup * 4));
}

#endif


d606 1
a606 1
        if ((global->gd_DiskType == ID_FFS_DISK) || (global->gd_DiskType == ID_INTER_FFS_DISK))
d611 3
d687 3
a689 1
#ifndef CROSSDOSKLUDGE
a690 2
#else
                    tags[2].ti_Data = 141;
d692 1
d751 4
a754 1
    ng->ng_GadgetText = GetStr((ULONG)ng->ng_GadgetText);
d851 1
a851 1
#define CMD_PC          7
d874 2
a875 3
#ifdef CROSSDOSKLUDGE
struct Gadget       *pcGad;
struct CrossDOSLock *sem;
d882 5
d930 2
a931 2
#ifdef CROSSDOSKLUDGE
    pcGad   = NULL;
d934 1
a934 1
    if ((global->gd_DiskType >= ID_DOS_DISK) && (global->gd_DiskType <= ID_INTER_FFS_DISK))
a943 1

d950 1
d953 8
a960 12
#ifdef CROSSDOSKLUDGE
        sem = (struct CrossDOSLock *)FindSemaphore(" CrossDOS ");
        if (sem && FindNameNC(global,&sem->cdl_Handlers,global->gd_DeviceName))
        {
            ng.ng_TopEdge    = window->BorderTop+104;
            ng.ng_Width      = 20;
            ng.ng_GadgetText = (STRPTR)MSG_FMT_CROSSDOS_GAD;
            ng.ng_GadgetID   = CMD_PC;

            pcGad = CreateFmtGadget(global,CHECKBOX_KIND,&ng,GTCB_Checked, global->gd_PCFormat,
                                                             TAG_DONE);
        }
d964 1
a964 1
#ifdef CROSSDOSKLUDGE
d969 1
d1029 3
a1031 13
#ifdef CROSSDOSKLUDGE
                                                   case CMD_FFS         :
                                                   case CMD_INTL        : if (pcGad)
                                                                          {
                                                                              SetGadgetAttr(global,pcGad,GTCB_Checked,FALSE,TAG_DONE);
                                                                              global->gd_PCFormat = FALSE;
                                                                          }
                                                                          break;

                                                   case CMD_PC          : SetGadgetAttr(global,ffsGad,GTCB_Checked,FALSE,TAG_DONE);
                                                                          SetGadgetAttr(global,intlGad,GTCB_Checked,FALSE,TAG_DONE);
                                                                          global->gd_FFS  = FALSE;
                                                                          global->gd_Intl = FALSE;
d1059 3
a1061 2
#ifdef CROSSDOSKLUDGE
            if (pcGad)
d1063 2
a1064 1
                global->gd_PCFormat = (SELECTED & pcGad->Flags);
d1067 1
d1082 1
a1082 1
#ifdef CROSSDOSKLUDGE
d1580 4
a1583 1
              BOOL ofs, BOOL ffs, BOOL intl, BOOL nointl, BOOL quick,
d1635 19
a1653 9
#ifdef CROSSDOSKLUDGE
                    if (global->gd_PCFormat)
                    {
                        dosType = ID_MSDOS_DISK;
                    }
                    else
                    {
#endif
                        dosType = ID_DOS_DISK;
d1655 2
a1656 2
                        if (env->de_TableSize >= DE_DOSTYPE)
                            dosType = env->de_DosType;
a1657 14
                        if (ffs && ((dosType == ID_DOS_DISK) || (dosType == ID_INTER_DOS_DISK)))
                            dosType = dosType + 1;  /* OFS --> FFS */

                        if (ofs && ((dosType == ID_FFS_DISK) || (dosType == ID_INTER_FFS_DISK)))
                            dosType = dosType - 1;  /* FFS --> OFS */

                        if (intl && ((dosType == ID_DOS_DISK) || (dosType == ID_FFS_DISK)))
                            dosType = dosType + 2;  /* NOINTL --> INTL */

                        if (nointl && ((dosType == ID_INTER_DOS_DISK) || (dosType == ID_INTER_FFS_DISK)))
                            dosType = dosType - 2;  /* INTL --> NOINTL */
#ifdef CROSSDOSKLUDGE
                    }
#endif
d1884 5
a1888 1
                                    if (infoData.id_DiskType != dosType)
d1919 3
a1921 1
                         global->gd_OFS,global->gd_FFS,global->gd_Intl,global->gd_NoIntl,
@


38.18
log
@Now understands MaxTransfer values for HDs
@
text
@a211 1
BOOL CreateTrashcan(struct GlobalData *global, STRPTR deviceName);
d1387 1
a1387 1
    if (lock = Lock(deviceName,ACCESS_WRITE))
a1591 1
    Delay(75);
d1887 7
a1893 1
                                    if (DoPkt1(fsPort,ACTION_DISK_INFO,MKBADDR(&infoData)))
d1895 2
a1896 1
                                        if (infoData.id_DiskType == ID_UNREADABLE_DISK)
d1898 2
a1899 1
                                            error = ERROR_NOT_A_DOS_DISK;
d1901 1
d1903 3
@


38.17
log
@No longer overwrites the right edge of the fuel gauge by one pixel when a format
  operation completes
@
text
@a1616 1
LONG			   wordsPerCyl;
d1629 3
a1688 1
                    wordsPerCyl   = wordsPerBlk * blocksPerCyl;
d1691 1
d1693 14
d1727 1
a1727 1
                                        if (cylinder = AllocVec(bytesPerCyl,memType))
d1739 1
a1739 1
                                                for (i = 0; i < wordsPerCyl; i++)
d1745 4
a1748 2
                                                failCnt = 0;
                                                write   = TRUE;
d1763 2
a1764 2
                                                    devIO->io_Length = bytesPerCyl;
                                                    devIO->io_Offset = cyl * bytesPerCyl;
d1768 2
d1779 7
a1785 1
                                                    else
d1787 1
a1787 1
                                                        write = FALSE;
@


38.16
log
@Now handles new volumes being inserted while in the "Select Device"
  listview correctly under a V37 ROM
Now listens for disk insertion events in its "disk is write-protected"
  requester
Window is a bit wider for better support of long volume names in
  a localized environment
Ghosts the "Quick Format" gadget if it is not a viable option
@
text
@d1552 1
a1552 1
                                   window->BorderLeft+GAUGE_LEFT+((GAUGE_WIDTH-5)*currentCyl/totalCyl)+3,
@


38.15
log
@Added LISTVIEWIDCMP
@
text
@d20 1
d107 1
a107 10
#define TEMPLATE    "DEVICE=DRIVE/K/A,NAME/K/A,OFS/S,FFS/S,INTL=INTERNATIONAL/S,NOINTL=NOINTERNATIONAL/S,NOICONS/S,QUICK/S" VERSTAG
#define OPT_DEVICE  0
#define OPT_NAME    1
#define OPT_OFS     2
#define OPT_FFS	    3
#define OPT_INTL    4
#define OPT_NOINTL  5
#define OPT_NOICONS 6
#define OPT_QUICK   7
#define OPT_COUNT   8
d109 24
d134 3
d178 1
d233 1
a233 1
#define GAUGE_RIGHT    386
d413 3
a415 1

d527 30
d610 1
a610 1
    if (!(fssm = (struct FileSysStartupMsg *)BADDR(global->gd_DeviceNode->dol_misc.dol_volume.dol_LockList)))
d703 1
a703 1
                    tags[1].ti_Data = 394;
d705 1
d707 3
d736 22
d863 5
a867 2
#define CMD_DEVICE      5  /* in select device window */
#define CMD_CONTINUE    6  /* in select device window */
d883 1
d888 5
d904 1
a904 1
    ng.ng_Width      = 196;
a911 3
    ng.ng_LeftEdge   = window->BorderLeft+192;
    ng.ng_Width      = 196;
    ng.ng_Height     = 10;
a912 2
    ng.ng_GadgetID   = CMD_NOP;

a915 3
    ng.ng_LeftEdge   = window->BorderLeft+192;
    ng.ng_Width      = 196;
    ng.ng_Height     = 10;
a916 2
    ng.ng_GadgetID   = CMD_NOP;

d920 1
a920 1
    ng.ng_Width      = 196;
a928 1

d938 6
d949 1
a949 1
        ng.ng_GadgetID   = CMD_NOP;
d958 1
a958 1
        ng.ng_GadgetID   = CMD_NOP;
d962 14
a975 5
    }
    else
    {
        ffsGad  = NULL;
        intlGad = NULL;
d978 3
d982 1
d984 1
a984 1
    ng.ng_Width      = 123;
d990 1
a990 2

    ng.ng_LeftEdge   = window->BorderLeft+136;
d994 2
a995 1
    CreateFmtGadget(global,BUTTON_KIND,&ng,TAG_DONE);
d997 1
a997 1
    ng.ng_LeftEdge   = window->BorderLeft+263;
d1022 2
d1042 15
d1082 6
a1087 1

d1102 3
d1106 1
a1106 1

d1128 2
a1129 2
                ng.ng_LeftEdge   = window->BorderLeft+138;
                ng.ng_Width      = 119;
d1241 1
a1241 1
    ng.ng_Width      = 378;
d1255 1
a1255 1
    ng.ng_Width      = 119;
d1262 1
a1262 1
    ng.ng_LeftEdge   = window->BorderLeft+267;
d1286 2
a1287 1
                                               SetGadgetAttr(global,devicesGad,GTLV_Labels, &deviceList,
d1453 1
d1461 3
a1463 1
    return (EasyRequestArgs(NULL,&est,NULL,&deviceName));
a1635 4
        /* extract the disk parameters */
        fssm = (struct FileSysStartupMsg *)BADDR(deviceNode->dol_misc.dol_volume.dol_LockList);
        env  = (struct DosEnvec *)BADDR(fssm->fssm_Environ);

d1646 4
d1651 9
a1659 1
                    dosType = ID_DOS_DISK;
d1661 2
a1662 2
                    if (env->de_TableSize >= DE_DOSTYPE)
                        dosType = env->de_DosType;
d1664 8
a1671 8
                    if (ffs && ((dosType == ID_DOS_DISK) || (dosType == ID_INTER_DOS_DISK)))
                        dosType = dosType + 1;  /* OFS --> FFS */

                    if (ofs && ((dosType == ID_FFS_DISK) || (dosType == ID_INTER_FFS_DISK)))
                        dosType = dosType - 1;  /* FFS --> OFS */

                    if (intl && ((dosType == ID_DOS_DISK) || (dosType == ID_FFS_DISK)))
                        dosType = dosType + 2;  /* NOINTL --> INTL */
d1673 5
a1677 3
                    if (nointl && ((dosType == ID_INTER_DOS_DISK) || (dosType == ID_INTER_FFS_DISK)))
                        dosType = dosType - 2;  /* INTL --> NOINTL */

@


38.14
log
@More work on returning correct errors
Now sets its disks to ID_BAD_DISK so WB will show them as ???? instead of FORM
@
text
@d661 1
a661 1
                    tags[6].ti_Data = CHECKBOXIDCMP | BUTTONIDCMP | STRINGIDCMP | IDCMP_DISKINSERTED | IDCMP_DISKREMOVED;
@


38.13
log
@Now makes its window smaller when it starts to format
Now centers the "Initializing disk..." message vertically
No longer says "***Break" in a requester when aborting from WB
Now returns ERROR_OBJECT_IN_USE if a device is already inhibited when
  it tries to format
Returns a correct error message if there is a media error instead of saying
  "Error 1"
The state of the FFS gadget is now consistent when entering using the device
  selection window
@
text
@d65 1
a65 1
#define ID_FORM_DISK      (0x464F524DL) /* 'FORM'  */
d478 1
a478 5
        if (failureCode == ERROR_NO_TRASH)
            SetIoErr(0);
        else
            SetIoErr(failureCode);

d495 1
a495 1
    if ((failureCode == ERROR_BREAK) || (failureCode == ERROR_NO_TRASH))
d1593 1
a1593 1
                                                    cylinder[0] = ID_FORM_DISK;
a1753 23
LONG MapError(LONG error)
{
    switch (error)
    {
        case TDERR_DiskChanged: return(ERROR_NO_DISK);

        case TDERR_WriteProt  : return(ERROR_DISK_WRITE_PROTECTED);

        case TDERR_SeekError  : return(ERROR_SEEK_ERROR);

        case ERROR_NO_TRASH   : return(ERROR_NO_TRASH);

        default               : if (error >= ERROR_NO_FREE_STORE)
                                    return(error);

                                return(ERROR_BAD_DISK);
    }
}


/****************************************************************************/


d1768 1
a1768 1
        if (MapError(error) != ERROR_DISK_WRITE_PROTECTED)
d1793 2
a1794 7
            case TDERR_BadSecPreamble:
            case TDERR_BadSecID      :
            case TDERR_BadHdrSum     :
            case TDERR_BadSecSum     :
            case TDERR_TooFewSecs    :
            case TDERR_BadSecHdr     : PrintF(global,MSG_FMT_FAILED_BADCYL,(STRPTR)global->gd_CurrentCyl);
                                       break;
d1797 1
a1797 1
                                       break;
d1800 1
a1800 1
                                       break;
d1802 1
a1802 2
            case ERROR_NO_TRASH      : PrintF(global,MSG_FMT_FAILED_TRASHCAN,global->gd_VolumeName);
                                       break;
d1804 2
a1805 1
            case ERROR_BREAK         : break;
d1807 1
a1807 1
            default                  : if (MapError(error) == ERROR_BAD_DISK)
d1809 6
a1814 2
                                           PrintF(global,MSG_FMT_FAILED_BADCYL,(STRPTR)global->gd_CurrentCyl);
                                           return(ERROR_NOT_A_DOS_DISK);
d1816 9
a1824 6
                                       else
                                       {
                                            Fault(MapError(error),NULL,dosString,sizeof(dosString));
                                            PrintF(global,MSG_FMT_FAILED_DOS,dosString);
                                       }
                                       break;
a1825 1
        return(MapError(error));
@


38.12
log
@No longer hangs if input is redirected to NIL:
@
text
@d2 1
a2 1
/* BUG: If ACTION_FORMAT_DISK is not recognized by the handler, this program
d294 11
a304 4
                        if (EditFmtOptions(global))
                            if (ReallyFormat(global))
                                if (failureCode = Initialize(global))
                                    printFailure = FALSE;
d477 5
a481 1
        SetIoErr(failureCode);
d483 6
a488 5
    CloseLibrary(GadToolsBase);
    CloseLibrary(UtilityBase);
    CloseLibrary(GfxBase);
    CloseLibrary(IntuitionBase);
    CloseLibrary(DOSBase);
d989 2
d1011 1
a1011 1
                ng.ng_TopEdge    = window->BorderTop+75;
d1470 2
a1471 1
        PlaceText(global,str,(window->Width-TextLength(window->RPort,str,strlen(str))) / 2,GAUGE_TOP-6);
d1473 1
a1473 1
    Delay(50);
d1520 2
a1521 2
        /* check volume for inhibited already, or no disk in drive */
        if ((infoData.id_DiskType != ID_NO_DISK_PRESENT) && (infoData.id_DiskType != ID_BUSY_DISK))
d1523 46
a1568 45
            error = ERROR_DISK_WRITE_PROTECTED;
            if (infoData.id_DiskState != ID_WRITE_PROTECTED)
            {
                memType = MEMF_CHIP | MEMF_CLEAR;
                dosType = ID_DOS_DISK;

                if (env->de_TableSize >= DE_DOSTYPE)
                    dosType = env->de_DosType;

                if (ffs && ((dosType == ID_DOS_DISK) || (dosType == ID_INTER_DOS_DISK)))
                    dosType = dosType + 1;  /* OFS --> FFS */

                if (ofs && ((dosType == ID_FFS_DISK) || (dosType == ID_INTER_FFS_DISK)))
                    dosType = dosType - 1;  /* FFS --> OFS */

                if (intl && ((dosType == ID_DOS_DISK) || (dosType == ID_FFS_DISK)))
                    dosType = dosType + 2;  /* NOINTL --> INTL */

                if (nointl && ((dosType == ID_INTER_DOS_DISK) || (dosType == ID_INTER_FFS_DISK)))
                    dosType = dosType - 2;  /* INTL --> NOINTL */

                if (env->de_TableSize >= DE_BUFMEMTYPE)
                    memType = env->de_BufMemType | MEMF_CLEAR;

                wordsPerBlk   = env->de_SizeBlock;
                bytesPerBlk   = wordsPerBlk * 4;
                blocksPerCyl  = env->de_BlocksPerTrack * env->de_Surfaces;
                lowCyl        = env->de_LowCyl;
                highCyl       = env->de_HighCyl;
                blocksPerDisk = blocksPerCyl * (highCyl - lowCyl + 1);
                wordsPerCyl   = wordsPerBlk * blocksPerCyl;
                bytesPerCyl   = bytesPerBlk * blocksPerCyl;
                rootBlk       = (blocksPerDisk - 1 + env->de_Reserved) >> 1;

                global->gd_NumberCyl = highCyl-lowCyl+1;

                error   = ERROR_NO_FREE_STORE;
                devPort = CreateMsgPort();
                if (devIO = (struct IOStdReq *)CreateIORequest(devPort,sizeof(struct IOStdReq)))
                {
                    error = ERROR_BREAK;
                    if (!CheckBreak())
                    {
                        error = ERROR_NO_DISK;
                        if (DoPkt1(fsPort,ACTION_INHIBIT,DOSTRUE))
d1570 2
a1571 2
                            error = IOERR_OPENFAIL;
                            if (!OpenDevice(BTOCSTR(fssm->fssm_Device),fssm->fssm_Unit,devIO,fssm->fssm_Flags))
d1573 2
a1574 2
                                error = 0;
                                if (!quick)
d1576 2
a1577 3
                                    /* do the track-level formatting */
                                    error = ERROR_NO_FREE_STORE;
                                    if (cylinder = AllocVec(bytesPerCyl,memType))
d1579 6
a1584 6
                                        error = 0;
                                        cyl   = lowCyl;

                                        global->gd_CurrentCyl = cyl;
                                        global->gd_LowCyl     = cyl;
                                        ShowProgress(global,TRUE,TRUE);
a1585 2
                                        while ((cyl <= highCyl) && !error)
                                        {
d1587 2
a1588 5
                                            for (i = 0; i < wordsPerCyl; i++)
                                                cylinder[i] = cyl - lowCyl << 16 | i | dosType;

                                            if (cyl == lowCyl)
                                                cylinder[0] = ID_FORM_DISK;
d1590 1
a1590 3
                                            failCnt = 0;
                                            write   = TRUE;
                                            while (TRUE)
d1592 3
a1594 5
                                                if (CheckBreak())
                                                {
                                                    error = ERROR_BREAK;
                                                    break;
                                                }
d1596 2
a1597 4
                                                if (write)
                                                    devIO->io_Command = TD_FORMAT;
                                                else
                                                    devIO->io_Command = CMD_READ;
d1599 3
a1601 12
                                                devIO->io_Data   = cylinder;
                                                devIO->io_Length = bytesPerCyl;
                                                devIO->io_Offset = cyl * bytesPerCyl;

                                                ShowProgress(global,write,FALSE);

                                                if (error = DoIO(devIO))
                                                {
                                                    ShowProgress(global,write,TRUE);
                                                    failCnt++;
                                                }
                                                else if (!write)
d1603 30
a1632 6
                                                    break;
                                                }
                                                else
                                                {
                                                    write = FALSE;
                                                }
d1634 4
a1637 3
                                                if (failCnt > MAXERRORS)
                                                {
                                                    break;
d1639 1
d1641 2
a1642 1
                                            cyl++;
d1644 1
a1644 2
                                        ShowProgress(global,write,TRUE);
                                        ShowComplete(global);
a1645 2
                                    FreeVec(cylinder);
                                }
d1647 3
a1649 3
                                if (!error)
                                {
                                    ShowIniting(global);
d1651 3
a1653 3
                                    /* now put a root block on this sucker */
                                    volumeNameB[0] = strlen(volumeName);
                                    strcpy(&volumeNameB[1],volumeName);
d1655 2
a1656 6
                                    if (!DoPkt2(fsPort,ACTION_FORMAT,MKBADDR(volumeNameB),dosType)
                                    && ((error = IoErr()) == ERROR_ACTION_NOT_KNOWN))
                                    {
                                        /* try the old fashion way, then */
                                        error = ERROR_NO_FREE_STORE;
                                        if (root = AllocVec(bytesPerBlk,memType))
d1658 8
a1665 4
                                            root->rb_Type          = T_SHORT;
                                            root->rb_HashSize      = HASHSIZE;
                                            root->rb_SecondaryType = ST_ROOT;
                                            root->rb_BMFlag        = 0;
d1667 5
a1671 15
                                            DateStamp(&root->rb_CreateDate);
                                            DateStamp(&root->rb_LastDate);

                                            root->rb_DiskName[0] = strlen(volumeName);
                                            strcpy(&root->rb_DiskName[1],volumeName);

                                            root->rb_CheckSum = sum = 0;
                                            for (i = 0, p = (LONG *)root; i < wordsPerBlk; sum = sum + *p++, i++);
                                            root->rb_CheckSum = -sum;

                                            devIO->io_Command = CMD_WRITE;
                                            devIO->io_Data    = root;
                                            devIO->io_Length  = bytesPerBlk;
                                            devIO->io_Offset  = rootBlk * bytesPerBlk + lowCyl * bytesPerCyl;
                                            error = DoIO(devIO);
d1673 3
a1675 6
                                            if (!error)
                                            {
                                                /* make disk look valid (boot block) */
                                                cylinder = (LONG *)root;
                                                for (i = 0; i < wordsPerBlk; i++)
                                                    cylinder[i] = dosType;
d1678 1
d1680 1
a1680 2
                                                devIO->io_Offset  = lowCyl * bytesPerCyl;
                                                devIO->io_Data    = cylinder;
d1682 16
d1699 2
d1702 16
a1717 2
                                            FreeVec(root);
                                        }
a1718 1
                                }
d1720 2
a1721 3
                                if (!error)
                                {
                                    devIO->io_Command = CMD_UPDATE;
d1725 3
a1727 1
                                    error = DoIO(devIO);
d1729 1
d1733 1
a1733 23
                                    devIO->io_Command = CMD_CLEAR;
                                    devIO->io_Length  = 0;
                                    devIO->io_Offset  = 0;
                                    devIO->io_Data    = 0;
                                    error = DoIO(devIO);
                                }

                                /* turn disk motor off */
                                devIO->io_Command = TD_MOTOR;
                                devIO->io_Length  = 0;
                                devIO->io_Offset  = 0;
                                devIO->io_Data    = 0;
                                DoIO(devIO);

                                CloseDevice(devIO);
                            }
                            DoPkt1(fsPort,ACTION_INHIBIT,DOSFALSE);

                            if (!error)
                            {
                                if (DoPkt1(fsPort,ACTION_DISK_INFO,MKBADDR(&infoData)))
                                {
                                    if (infoData.id_DiskType == ID_UNREADABLE_DISK)
d1735 4
a1738 1
                                        error = ERROR_NOT_A_DOS_DISK;
d1744 2
a1746 2
                DeleteMsgPort(devPort);
                DeleteIORequest(devIO);
d1768 2
d1815 1
a1815 1
        if (error != ERROR_BREAK)
d1837 12
a1848 2
            default                  : Fault(MapError(error),NULL,dosString,sizeof(dosString));
                                       PrintF(global,MSG_FMT_FAILED_DOS,dosString);
@


38.11
log
@Cleaned up source a bit
Fixed calling SetIoErr() even if dos.library didn't open!
@
text
@d212 2
a213 2
#define GAUGE_LEFT     20
#define GAUGE_RIGHT    374
d401 1
a401 8
                        ch = 0;
                        while (WaitForChar(Input(),30))
                        {
                            if (Read(Input(),&ch,1) != 1)
                                ch = -1;
                        }

                        ch    = -1;
d403 1
a403 1
                        while (TRUE)
d405 1
a405 1
                            if (WaitForChar(Input(),100000))
d407 2
a408 2
                                if (Read(Input(),&ch,1) == 1)
                                    break;
d410 3
a412 1
                            else if (CheckBreak())
d414 10
a423 2
                                abort = TRUE;
                                break;
d991 1
a991 1
                PlaceText(global,"0%",GAUGE_LEFT-6,GAUGE_TOP+GAUGE_HEIGHT+12);
d993 1
a993 1
                PlaceText(global,"100%",GAUGE_RIGHT-14,GAUGE_TOP+GAUGE_HEIGHT+12);
@


38.10
log
@*** empty log message ***
@
text
@d2 4
a50 12
#define NAMELENGTH     30
#define ERROR_BAD_DISK 1
#define ERROR_NO_TRASH 2

#undef BADDR
#define BADDR( bptr )   (((long)bptr) << 2)
#define BTOCSTR(bstr)   ((TEXT *)(BADDR(bstr) + 1))


/****************************************************************************/


d65 1
d82 1
a82 1
    UBYTE            rb_DiskName[13*4];
d106 1
a106 1
#define TEMPLATE    "DEVICE=DRIVE/K/A,NAME/K/A,OFS/S,FFS/S,NOICONS/S,QUICK/S,INTL=INTERNATIONAL/S,NOINTL=NOINTERNATIONAL/S" VERSTAG
d111 4
a114 4
#define OPT_NOICONS 4
#define OPT_QUICK   5
#define OPT_INTL    6
#define OPT_NOINTL  7
d121 11
a137 1
    APTR               gd_IconBase;
a139 1
    struct Process    *gd_Process;
d159 1
a176 1
#define IconBase      global->gd_IconBase
d184 3
a186 3
#define MAXERRORS    2
#define BIGDRIVESIZE (1024*1024*2)   /* 2 Megs */

a187 3
/****************************************************************************/


a207 3
#define D_S(type,name) char a_##name[sizeof(type)+3]; \
		       type *name = (type *)((LONG)(a_##name+3) & ~3);

d225 19
a243 19
struct InfoData __aligned       infoData;
struct GlobalData               gd;
struct GlobalData              *global;
struct Library                 *SysBase = (*((struct Library **) 4));
struct Process                 *process;
struct WBStartup               *WBenchMsg = NULL;
struct WBArg                   *wbarg;
LONG                            wbcnt;
struct RdArgs                  *rdargs;
LONG                            opts[OPT_COUNT];
STRPTR                          volName;
STRPTR                          devName;
LONG                            failureCode  = ERROR_INVALID_RESIDENT_LIBRARY;
UWORD                           i;
BPTR                            parent;
char                            ch;
BOOL                            abort;
BOOL			        printFailure;
char                            str[80];
d255 6
a260 7
    DOSBase            = OpenLibrary("dos.library",37);
    IntuitionBase      = OpenLibrary("intuition.library",37);
    GfxBase            = OpenLibrary("graphics.library",37);
    UtilityBase        = OpenLibrary("utility.library",37);
    GadToolsBase       = OpenLibrary("gadtools.library",37);
    IconBase           = NULL;
    global->gd_Process = process;
d277 5
d287 1
a287 1
            if (wbcnt == 1)
d382 2
a385 2
                global->gd_Intl     =  (BOOL)opts[OPT_INTL];
                global->gd_NoIntl   =  (BOOL)opts[OPT_NOINTL];
d466 2
a467 1
    SetIoErr(failureCode);
d469 3
a471 1
    CloseLibrary(IconBase);
a472 1
    CloseLibrary(GfxBase);
a473 2
    CloseLibrary(UtilityBase);
    CloseLibrary(GadToolsBase);
a665 1

d1245 1
d1261 1
a1261 4
            if (!IconBase)
                IconBase = OpenLibrary("icon.library",37);

            if (IconBase)
d1268 1
d1295 1
a1295 1
    if (global->gd_Process->pr_CLI)
d1402 1
a1402 1
        if (global->gd_Process->pr_CLI)
d1427 1
a1427 1
    if (global->gd_Process->pr_CLI)
d1442 1
a1442 1
    if (global->gd_Process->pr_CLI)
d1463 2
a1464 1
              BOOL ofs, BOOL ffs, BOOL intl, BOOL nointl, BOOL quick, STRPTR volumeName)
d1503 1
a1503 1
        if ((env->de_TableSize < DE_DOSTYPE) || (infoData.id_DiskType != ID_NO_DISK_PRESENT))
d1575 1
a1575 1
                                                cylinder[0] = (('B'<<24) | ('A'<<16) | ('D'<<8) | ('\0'));
d1640 4
a1643 4
                                            root->rb_Type           = T_SHORT;
                                            root->rb_HashSize       = HASHSIZE;
                                            root->rb_SecondaryType  = ST_ROOT;
                                            root->rb_BMFlag         = 0;
@


38.9
log
@*** empty log message ***
@
text
@d274 1
a274 1
            strcpy(global->gd_VolumeName,"Empty");
d879 1
a879 1
    ng.ng_Width      = 119;
d886 1
a886 1
    ng.ng_LeftEdge   = window->BorderLeft+138;
d892 1
a892 1
    ng.ng_LeftEdge   = window->BorderLeft+267;
@


38.8
log
@Fixed formatting routine when ACTION_FORMAT doesn't work
@
text
@d167 1
d246 1
d282 4
a285 3
            failureCode = ERROR_INVALID_COMPONENT_NAME;
            wbarg       = WBenchMsg->sm_ArgList;
            wbcnt       = WBenchMsg->sm_NumArgs;
d296 2
a297 1
                                failureCode = Initialize(global);
d353 1
d367 1
a367 1
            if (failureCode)
d724 1
a724 1
                           window->BorderTop+GAUGE_BOTTOM,
d982 1
a982 1
                SetAPen(window->RPort,global->gd_DrawInfo->dri_Pens[SHADOWPEN]);
d1379 1
a1379 1
VOID ShowProgress(struct GlobalData *global, BOOL writing)
d1382 1
d1384 14
a1397 1
    if (global->gd_Process->pr_CLI)
d1399 1
a1399 4
        if (writing)
            VPrintF(global,GetStr(MSG_FMT_FORMATTING),(STRPTR)global->gd_CurrentCyl,(STRPTR)(global->gd_NumberCyl-global->gd_CurrentCyl-1));
        else
            VPrintF(global,GetStr(MSG_FMT_VERIFYING),(STRPTR)global->gd_CurrentCyl,(STRPTR)(global->gd_NumberCyl-global->gd_CurrentCyl-1));
d1401 2
a1402 1
    else if (window = global->gd_Window)
d1404 10
a1413 1
        SetAPen(window->RPort,global->gd_DrawInfo->dri_Pens[FILLPEN]);
d1415 5
a1419 4
        RectFill(window->RPort,window->BorderLeft+GAUGE_LEFT+2,
                               window->BorderTop+GAUGE_TOP+1,
                               window->BorderLeft+GAUGE_LEFT+((GAUGE_WIDTH-5)*global->gd_CurrentCyl/global->gd_NumberCyl)+3,
                               window->BorderTop+GAUGE_BOTTOM-1);
d1564 5
d1597 1
a1597 1
                                                ShowProgress(global,write);
d1601 1
d1620 1
@


38.7
log
@Better error reporting when running from WB
Cleaned up failure path that was causing enforcer hits
@
text
@d1610 1
a1610 1
                                            root->rb_BMFlag         = -1;
a1617 1
                                            for (i = 1, *(p = (LONG *)&root[1]) = 0; i < wordsPerBlk; *p -= p[i++]);
@


38.6
log
@No longer gets confused about break events when formatting
@
text
@a294 6

                if (failureCode == ERROR_NO_FREE_STORE)
                {
                    Fault(ERROR_NO_FREE_STORE,NULL,str,sizeof(str));
                    PrintF(global,MSG_FMT_FAILED_DOS,str);
                }
d308 1
d312 1
d317 2
d320 1
d323 2
d326 1
a355 2
                        Fault(ERROR_NO_FREE_STORE,NULL,str,sizeof(str));
                        PrintF(global,MSG_FMT_FAILED_DOS,str);
d361 6
d1221 1
a1221 1
    if (global->gd_Font);
@


38.5
log
@Removed WBExplain stuff
@
text
@d933 2
@


38.4
log
@Now brings up a device list when run from WB with no disk selected
@
text
@a244 1
BOOL                            error;
a282 1
            error       = TRUE;
a285 1
                error = FALSE;
a310 1
                    error = TRUE;
a337 2
                    error = FALSE;

a360 3

            if (error)
                WBExplain(global);
a1315 17
}


/*****************************************************************************/


VOID WBExplain(struct GlobalData *global)
{
struct EasyStruct est;

    est.es_StructSize   = sizeof(struct EasyStruct);
    est.es_Flags        = 0;
    est.es_Title        = GetStr(MSG_FMT_EXPLAIN_TITLE);
    est.es_TextFormat   = GetStr(MSG_FMT_EXPLAIN);
    est.es_GadgetFormat = GetStr(MSG_FMT_EXPLAIN_GAD);

    EasyRequestArgs(NULL,&est,NULL,NULL);
@


38.3
log
@Now has OFS and NOINTL command-line options and supporting code
@
text
@d14 1
d206 1
d208 2
d211 1
d286 21
a306 1
            if (wbcnt > 1)
d345 1
a345 1
                    {
d773 2
d798 5
a853 1
        ng.ng_Height     = 14;
a862 1
        ng.ng_Height     = 14;
d1014 188
@


38.2
log
@Fixed bug with file system having no FileSysStartupMsg or environment vector (RAM:)
@
text
@d58 4
a61 6
#define WORDSPERBLOCK	128
#define HASHSIZE	(WORDSPERBLOCK - 56)
#define NUMBMPAGES	26
#define T_SHORT	        2
#define ST_ROOT	        1
#define ID_BUSY_DISK    0x42555359
d63 13
d112 1
a112 1
#define TEMPLATE    "DEVICE=DRIVE/K/A,NAME/K/A,FFS/S,NOICONS/S,QUICK/S,INTL=INTERNATIONAL/S" VERSTAG
d115 7
a121 5
#define OPT_FFS	    2
#define OPT_NOICONS 3
#define OPT_QUICK   4
#define OPT_INTL    5
#define OPT_COUNT   6
d152 1
d155 1
d271 1
d274 1
d353 1
d358 1
d537 1
a537 1
        if ((global->gd_DiskType == ID_FFS_DISK) || (global->gd_DiskType == ID_FFS_DISK+2))
d540 1
a540 1
        if ((global->gd_DiskType == ID_DOS_DISK+2) || (global->gd_DiskType == ID_FFS_DISK+2))
d818 1
a818 1
    if ((global->gd_DiskType >= ID_DOS_DISK) && (global->gd_DiskType <= ID_DOS_DISK+3))
d916 5
a920 1
                global->gd_Intl = (SELECTED & intlGad->Flags);
d922 2
d925 1
d1238 1
a1238 1
              BOOL ffs, BOOL intl, BOOL quick, STRPTR volumeName)
d1288 2
a1289 2
                if (ffs && (dosType == ID_DOS_DISK))
                    dosType = ID_FFS_DISK;
d1291 3
d1295 4
a1298 1
                    dosType = dosType + 2;
d1535 1
a1535 1
                         global->gd_FFS,global->gd_Intl,
@


38.1
log
@Initial V38 RCS checkin
@
text
@d501 6
a508 3

    fssm = (struct FileSysStartupMsg *)BADDR(global->gd_DeviceNode->dol_misc.dol_volume.dol_LockList);
    env  = (struct DosEnvec *)BADDR(fssm->fssm_Environ);
@
