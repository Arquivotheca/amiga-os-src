/*
 *  libinit.c  -  This is the standard library init...
 *
 *  It calls the custom init routines in jcc_custom.c
 *  The routines in this file should not be changed.
 *
 */
#include <exec/types.h>
#include <exec/nodes.h>
#include <exec/resident.h>
#include <exec/libraries.h>
#include <libraries/dos.h>

#include <clib/exec_protos.h>
#include <clib/dos_protos.h>

#include <pragmas/exec_pragmas.h>
#include <pragmas/dos_pragmas.h>

#include <string.h>

/* This includes the revision information */
#include "jcc_rev.h"

#include "jccbase.h"

/* The prototypes for the custom library init and expunge */
BOOL __saveds __asm CustomLibInit(register __a6 struct JCCLibrary *libbase);
void __saveds __asm CustomLibExpunge(register __a6 struct JCCLibrary *libbase);

typedef LONG (*PFL)();   /* pointer to function returning 32-bit int */

/* library initialization table, used for AUTOINIT libraries */
struct InitTable
{
    ULONG   *it_DataSize;       /* library data space size         */
    PFL     *it_FuncTable;      /* table of entry points           */
    APTR    it_DataInit;        /* table of data initializers      */
    PFL     it_InitFunc;        /* initialization function to run  */
};

/* my function table (Generated by Blink) */
extern PFL _LibFuncTab[];

extern char __far RESLEN;
extern long __far NEWDATAL;	/* Generated by BLINK */

#define DATAWORDS ((long)&NEWDATAL)

/* We need to define this for the following table */
ULONG __asm _LibInit(register __a0 APTR seglist,register __d0 struct JCCLibrary *libbase);

struct InitTable __far _LibInitTab =
{
    (long *)(&RESLEN+sizeof(struct JCCLibrary)),
    _LibFuncTab,
    NULL,			/* will initialize my own data */
    _LibInit,
};

/* Need this to determine start of MERGED DATA */
extern long far _Libmergeddata;

/* Supplied by BLink */
extern char __far _LibName[];

/* Supplied as part of our libent.a */
extern char __far _VerString[];

/*
 * The following #define is to give the EXEC call #pragmas (which were changed
 * to "libcall SysBase" to use the absolute location known also as AbsExecBase.
 * This is needed during the base level expunge call...
 */
#define SysBase (*((ULONG *)4))

/*
 * This function is called when the library is first loaded.
 * It does the library structure initialization and calls the custom library
 * initialization routine which should setup any custom library stuff and open
 * any other libraries that will be needed.
 *
 * Note that this routine can not change as the setup must happen in this order.
 */
ULONG __asm _LibInit(register __a0 APTR seglist,register __d0 struct JCCLibrary *libbase)
{
    long *sdata, *reloc;
    char *ddata;
    long nrelocs;

    libbase->jl_SegList = (ULONG)seglist;

    /* init. library structure (since I don't do automatic data init.) */
    libbase->jl_Lib.lib_Node.ln_Type = NT_LIBRARY;
    libbase->jl_Lib.lib_Node.ln_Name =  _LibName;
    libbase->jl_Lib.lib_Flags = LIBF_SUMUSED | LIBF_CHANGED;
    libbase->jl_Lib.lib_Version = VERSION;
    libbase->jl_Lib.lib_Revision = REVISION;
    libbase->jl_Lib.lib_IdString = (APTR)_VerString;

    /* The +4 is a wasted long word, where _Libmergeddata is. */
    ddata = (char *)&libbase->jl_Data + 4;
    sdata = (long *)&_Libmergeddata;
    memcpy(ddata, (char *)sdata, DATAWORDS*4);

    sdata = sdata + DATAWORDS;
    nrelocs = *sdata++;
    while (nrelocs > 0)
	{
        reloc = (long *)((long)ddata + *sdata++);
        *reloc += (long)ddata;
        nrelocs--;
	}

    if (CustomLibInit((struct JCCLibrary *)libbase)) return((ULONG)libbase);
    else return(NULL);
}


/*
 * This is the entry point that is called when the system wishes that the library
 * free itself.  The library should only free itself if there are no outstanding
 * open libraries. This routine calls the custom expunge routine where any
 * custom resources that need to be freed are.
 *
 *  *** NOTE ***  This routine *MUST* *NEVER* *BREAK* *FORBID*
 *                That is, it must not do *ANYTHING* that could
 *                cause a Wait() to happen...
 *
 *                Also note that it is best to use a little stack as possible as
 *		  you are being called from some other process's context.
 */
ULONG __saveds __asm _LibExpunge(register __a6 struct JCCLibrary *libbase)
{
    ULONG seglist = 0;
    LONG  libsize;

    libbase->jl_Lib.lib_Flags |= LIBF_DELEXP;
    if (libbase->jl_Lib.lib_OpenCnt == 0)
	{
        CustomLibExpunge((struct JCCLibrary *)libbase);

        /* really expunge: remove libbase and freemem */

        seglist = libbase->jl_SegList;
        Remove((struct Node *)libbase);

        libsize = libbase->jl_Lib.lib_NegSize + libbase->jl_Lib.lib_PosSize;
        FreeMem((char *)libbase - libbase->jl_Lib.lib_NegSize,(LONG)libsize);
	}

    /* return NULL or real seglist */
    return((ULONG)seglist);
}


/*
 * This is the entry point that is called when the library is opened by an
 * application.  It mainly changes the OpenCount and the delayed expunge flags...
 */
LONG __asm _LibOpen(register __a6 struct JCCLibrary *libbase)
{
    /* mark us as having another customer */
    libbase->jl_Lib.lib_OpenCnt++;

    /* clear delayed expunges (standard procedure) */
    libbase->jl_Lib.lib_Flags &= ~LIBF_DELEXP;

    return((LONG)libbase);
}


/*
 * This is the entry point that is called when the library is closed by an
 * application.  The main use here is to change the open count and to check
 * for delayed expunge calls...
 */
ULONG __asm _LibClose(register __a6 struct JCCLibrary *libbase)
{
    ULONG retval = 0;

    if ((--libbase->jl_Lib.lib_OpenCnt == 0) &&
                    (libbase->jl_Lib.lib_Flags & LIBF_DELEXP))
	{
        /*
         * no more people have me open,
         * and I have a delayed expunge pending
         */
        retval = _LibExpunge(libbase); /* return segment list */
	}

    return(retval);
}
