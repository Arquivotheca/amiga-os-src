head     1.3;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.3
date     93.04.20.10.23.46;  author kaori;  state Exp;
branches ;
next     1.2;

1.2
date     93.01.11.17.47.24;  author kaori;  state Exp;
branches ;
next     1.1;

1.1
date     92.12.17.12.02.28;  author kaori;  state Exp;
branches ;
next     ;


desc
@EUC/JIS/S-JIS conversion functions.
@


1.3
log
@Support tags.
@
text
@/*
 *  conversion.c - conversion library functions...
 *
 */
#include <exec/types.h>
#include <exec/libraries.h>

#include <clib/exec_protos.h>
#include <clib/utility_protos.h>

#include <pragmas/exec_pragmas.h>
#include <pragmas/utility_pragmas.h>

#include <dos.h>
#include <stdio.h>
#include <string.h>

#include "jcc.h"
#include "jccbase.h"

#define JCCBase		((struct JCCLibrary *)getreg(REG_A6))
#define UtilityBase	(JCCBase->jl_UtilityBase)

/**********    debug macros     **********/
#define MYDEBUG  0
void kprintf(UBYTE *fmt,...);
#define bug kprintf
#if MYDEBUG
#define D(x) (x);
#else
#define D(x) ;
#endif /* MYDEBUG */
/********** end of debug macros **********/

extern VOID __saveds __asm
han2zen(register __a0 LONG *one,
        register __a1 LONG *two,
        register __d0 LONG nigori,
        register __d1 LONG maru);

LONG __saveds __asm
KanjiIn(register __d0 LONG outcode,
        register __a0 UBYTE *outbuf)
{
	LONG wlen;

	switch(outcode)
	{
		case CTYPE_NEWJIS:
			*outbuf++ = ESC;
			*outbuf++ = '$';
			*outbuf   = 'B';
			wlen = 3;
			break;
		case CTYPE_OLDJIS:
			*outbuf++ = ESC;
			*outbuf++ = '$';
			*outbuf   = '@@';
			wlen = 3;
			break;
		case CTYPE_NECJIS:
			*outbuf++ = ESC;
			*outbuf   = 'K';
			wlen = 2;
			break;
		default:
			wlen = 0;
			break;
	}
	return wlen;
}

LONG __saveds __asm
KanjiOut(register __d0 LONG outcode,
         register __a0 UBYTE *outbuf)
{
	LONG wlen;

	switch(outcode)
	{
		case CTYPE_NEWJIS:
		case CTYPE_OLDJIS:
			*outbuf++ = ESC;
			*outbuf++ = '(';
			*outbuf   = 'J';
			wlen = 3;
			break;
		case CTYPE_NECJIS:
			*outbuf++ = ESC;
			*outbuf   = 'H';
			wlen = 2;
			break;
		default:
			wlen = 0;
			break;
	}
	return wlen;
}

LONG __saveds __asm
writebuf(register __d0 LONG p1,
         register __d1 LONG p2,
         register __a0 UBYTE *outbuf)
{
	*outbuf++ = p1;
	*outbuf   = p2;

	return (2);
}

int __saveds __asm
isodd(register __d0 int number)
{
	return((number % 2) ? 1 : 0);
}

/* Shift-JIS to JIS */
VOID __saveds __asm
LIBEightToSeven(register __a0 LONG *p1, register __a1 LONG *p2)
{
	LONG temp;

	temp = *p2;
	if ((*p2 >= 0x40) && (*p2 <= 0x9e))
		*p2 -= 0x1f;
	else if ((*p2 >= 0x9f) && (*p2 <= 0xfc))
		*p2 -= 0x7e;
	if ((temp > 0x7f) && (temp <= 0x9e))
		(*p2)--;
	if ((*p1 >= 0x81) && (*p1 <= 0x9f))
	{
		if ((temp >= 0x40) && (temp <= 0x9e))
			*p1 = ((*p1 - 0x71) * 2) + 1;
		else if ((temp >= 0x9f) && (temp <= 0xfc))
			*p1 = (*p1 - 0x70) * 2;
	}
	else if ((*p1 >= 0xe0) && (*p1 <= 0xef))
	{
		if ((temp >= 0x40) && (temp <= 0x9e))
			*p1 = ((*p1 - 0xb1) * 2) + 1;
		else if ((temp >= 0x9f) && (temp <= 0xfc))
			*p1 = (*p1 - 0xb0) * 2;
	}
}

/* JIS to Shift-JIS */
VOID __saveds __asm
LIBSevenToEight(register __a0 LONG *p1, register __a1 LONG *p2)
{
	if (isodd(*p1))
		*p2 += 31;
	else
		*p2 += 126;
	if ((*p2 >= 127) && (*p2 < 158))
		(*p2)++;
	if ((*p1 >= 33) && (*p1 <= 94))
	{
		if (isodd(*p1))
			*p1 = ((*p1 - 1) / 2) + 113;
		else if (!isodd(*p1))
			*p1 = (*p1 / 2) + 112;
	}
	else if ((*p1 >= 95) && (*p1 <= 126))
	{
		if (isodd(*p1))
			*p1 = ((*p1 - 1) / 2) + 177;
		else if (!isodd(*p1))
			*p1 = (*p1 / 2) + 176;
	}
}

VOID __saveds __asm
eight2seven(register __a0 LONG *p1, register __a1 LONG *p2)
{
	/*
	 * PC98 "GAIJI" kluge. Mostly for "KEISEN" (line).
	 * PC98 is using strange code for "KEISEN", which 1st byte is "0x86".
	 * When we detect this code, just replace 2byte JIS code of "SPACE".
	 */
#if 0
	if (*p1 > 0x84 && *p1 < 0x88)
	{
		*p1 = 0x21;
		*p2 = 0x21;
		return;
	}
#endif

	LIBEightToSeven(p1, p2);
}

VOID __saveds __asm
seven2eight(register __a0 LONG *p1, register __a1 LONG *p2)
{
	/*
	 * PC98 "GAIJI" kluge. Mostly for "KEISEN" (line).
	 * PC98 is using strange code for "KEISEN", which 1st byte is "0x86".
	 * So that when we detect JIS standard "KEISEN" code,
	 * just replace 2byte S-JIS code of "SPACE" to avoid showing
	 * incorrect display in the other machine.
	 */
#if 0
	if (*p1 > 0x27 && *p1 < 0x30)
	{
		*p1 = 0x81;
		*p2 = 0x40;
		return;
	}
#endif

	LIBSevenToEight(p1, p2);
}

VOID __saveds __asm
pop(register __a0 LONG *p, register __a1 UBYTE *jcc_b)
{
	*p = *jcc_b;
	*jcc_b = 0x00;
}

/* JIS to JIS */
LONG __saveds __asm
seven2seven(register __a0 struct JConversionCodeSet *jcc,
            register __a1 UBYTE *inbuf,
            register __a2 UBYTE *outbuf,
    	    register __d0 LONG length)
{
	LONG p1, p2;
	LONG rcnt = 0;
	LONG wcnt = 0;
	LONG rlen;

	if (length == -1)
		rlen = strlen(inbuf);
	else
		rlen = length;

	D(bug("seven2seven:rlen = %ld\n", rlen));

	if (length == -1)
	{
		if (jcc->jcc_FirstByte)
		{
			pop(&p1, &jcc->jcc_FirstByte);
			goto SECONDBYTE_JIS_JIS;
		}
		if (jcc->jcc_ESC[0] == ESC)
		{
			pop(&p1, &(jcc->jcc_ESC[0]));
			if (jcc->jcc_ESC[1] == '$'
			 || jcc->jcc_ESC[1] == '(')
			{
				pop(&p2, &(jcc->jcc_ESC[1]));
				goto ESC_THIRD_JIS_JIS;
			}
			goto ESC_SECOND_JIS_JIS;
		}
	}

	while (rcnt < rlen)
	{
		p1 = inbuf[rcnt++];
		switch (p1)
		{
			case ESC:
				if (rcnt >= rlen)
				{
					if (length == -1)	/* continuous string */
					{
						jcc->jcc_ESC[0] = ESC;
						break;
					}
					else			/* single string convert */
					{
						if (jcc->jcc_ShiftedIn)
						{
							jcc->jcc_ShiftedIn = FALSE;
							wcnt += KanjiOut(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
						}
						break;
					}
				}
ESC_SECOND_JIS_JIS:
				p2 = inbuf[rcnt++];
				if      (p2 == 'K')
					jcc->jcc_ShiftedIn = TRUE;
				else if (p2 == 'H')
					jcc->jcc_ShiftedIn = FALSE;
				else if ((p2 == '$') || (p2 == '('))
				{
					if (rcnt >= rlen)
					{
						if (length == -1)	/* continuous string */
						{
							jcc->jcc_ESC[0] = p1;
							jcc->jcc_ESC[1] = p2;
							break;
						}
						else			/* single string convert */
						{
							if (jcc->jcc_ShiftedIn)
							{
								jcc->jcc_ShiftedIn = FALSE;
								wcnt += KanjiOut(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
							}
							break;
						}
					}
ESC_THIRD_JIS_JIS:
					rcnt++;		/* junk */
					if (p2 == '$')
						jcc->jcc_ShiftedIn = TRUE;
					if (p2 == '(')
						jcc->jcc_ShiftedIn = FALSE;
				}
				if (jcc->jcc_ShiftedIn)
					wcnt += KanjiIn(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
				else
					wcnt += KanjiOut(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
				break;

			case LF:
				if (jcc->jcc_ShiftedIn)
				{
					jcc->jcc_ShiftedIn = FALSE;
					wcnt += KanjiOut(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
				}
				outbuf[wcnt++] = p1;
				break;
			case FF:
				break;
			default:
				if (jcc->jcc_ShiftedIn)
				{
					if (rcnt >= rlen)
					{
						if (length == -1)	/* continuous string */
						{
							jcc->jcc_FirstByte = p1;
							break;
						}
						else			/* single string convert */
						{
							if (jcc->jcc_ShiftedIn)
							{
								jcc->jcc_ShiftedIn = FALSE;
								wcnt += KanjiOut(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
							}
							break;
						}
					}
SECONDBYTE_JIS_JIS:
					p2 = inbuf[rcnt++];
					wcnt += writebuf(p1, p2, &outbuf[wcnt]);
				}
				else
				{
					outbuf[wcnt++] = p1;
				}
				break;
		}
	}
	return wcnt;
}

/* JIS to EUC */
LONG __saveds __asm
seven2euc(register __a0 struct JConversionCodeSet *jcc,
          register __a1 UBYTE *inbuf,
          register __a2 UBYTE *outbuf,
          register __d0 LONG length)
{
	LONG p1, p2;
	LONG rcnt = 0;
	LONG wcnt = 0;
	LONG rlen;

	if (length == -1)
		rlen = strlen(inbuf);
	else
		rlen = length;

	D(bug("seven2euc:rlen = %ld\n", rlen));

	if (length == -1)
	{
		if (jcc->jcc_FirstByte)
		{
			pop(&p1, &jcc->jcc_FirstByte);
			goto SECONDBYTE_JIS_EUC;
		}
		if (jcc->jcc_ESC[0] == ESC)
		{
			if (jcc->jcc_ESC[1] == '$'
			 || jcc->jcc_ESC[1] == '(')
			{
				pop(&p1, &(jcc->jcc_ESC[0]));
				pop(&p2, &(jcc->jcc_ESC[1]));
				goto ESC_THIRD_JIS_EUC;
			}
			pop(&p1, &(jcc->jcc_ESC[0]));
			goto ESC_SECOND_JIS_EUC;
		}
	}

	while (rcnt < rlen)
	{
		p1 = inbuf[rcnt++];
		switch (p1)
		{
			case ESC:
				if (rcnt >= rlen)
				{
					if (length == -1)	/* continuous string */
					{
						jcc->jcc_ESC[0] = ESC;
						break;
					}
					else			/* single string convert */
						break;
				}
ESC_SECOND_JIS_EUC:
				p2 = inbuf[rcnt++];
				if      (p2 == 'K')
					jcc->jcc_ShiftedIn = TRUE;
				else if (p2 == 'H')
					jcc->jcc_ShiftedIn = FALSE;
				else if ((p2 == '$') || (p2 == '('))
				{
					if (rcnt >= rlen)
					{
						if (length == -1)	/* continuous string */
						{
							jcc->jcc_ESC[0] = p1;
							jcc->jcc_ESC[1] = p2;
							break;
						}
						else			/* single string convert */
							break;
					}
ESC_THIRD_JIS_EUC:
					rcnt++;		/* junk */
					if (p2 == '$')
						jcc->jcc_ShiftedIn = TRUE;
					if (p2 == '(')
						jcc->jcc_ShiftedIn = FALSE;
				}
				break;
			case LF:
				if (jcc->jcc_ShiftedIn)
				{
					jcc->jcc_ShiftedIn = FALSE;
				}
				outbuf[wcnt++] = p1;
				break;
			case FF:
				break;
			default:
				if (jcc->jcc_ShiftedIn)
				{
					if (rcnt >= rlen)
					{
						if (length == -1)	/* continuous string */
						{
							jcc->jcc_FirstByte = p1;
							break;
						}
						else			/* single string convert */
							break;
					}
SECONDBYTE_JIS_EUC:
					p2 = inbuf[rcnt++];
					wcnt += writebuf(p1+0x80, p2+0x80, &outbuf[wcnt]);
				}
				else
				{
					outbuf[wcnt++] = p1;
				}
				break;
		}
	}
	return wcnt;
}

/* JIS to Shift-JIS */
LONG __saveds __asm
seven2shift(register __a0 struct JConversionCodeSet *jcc,
            register __a1 UBYTE *inbuf,
            register __a2 UBYTE *outbuf,
            register __d0 LONG length)
{
	LONG p1, p2;
	LONG rcnt = 0;
	LONG wcnt = 0;
	LONG rlen;

	if (length == -1)
		rlen = strlen(inbuf);
	else
		rlen = length;

	D(bug("seven2shift:rlen = %ld\n", rlen));

	if (length == -1)
	{
		if (jcc->jcc_FirstByte)
		{
			pop(&p1, &jcc->jcc_FirstByte);
			goto SECONDBYTE_JIS_SJS;
		}
		if (jcc->jcc_ESC[0] == ESC)
		{
			if (jcc->jcc_ESC[1] == '$'
			 || jcc->jcc_ESC[1] == '(')
			{
				pop(&p1, &(jcc->jcc_ESC[0]));
				pop(&p2, &(jcc->jcc_ESC[1]));
				goto ESC_THIRD_JIS_SJS;
			}
			pop(&p1, &(jcc->jcc_ESC[0]));
			goto ESC_SECOND_JIS_SJS;
		}
	}

	while (rcnt < rlen)
	{
		p1 = inbuf[rcnt++];
		switch (p1)
		{
			case ESC:
				if (rcnt >= rlen)
				{
					if (length == -1)	/* continuous string */
					{
						jcc->jcc_ESC[0] = ESC;
						break;
					}
					else			/* single string convert */
						break;
				}
ESC_SECOND_JIS_SJS:
				p2 = inbuf[rcnt++];
				if      (p2 == 'K')
					jcc->jcc_ShiftedIn = TRUE;
				else if (p2 == 'H')
					jcc->jcc_ShiftedIn = FALSE;
				else if ((p2 == '$') || (p2 == '('))
				{
					if (rcnt >= rlen)
					{
						if (length == -1)	/* continuous string */
						{
							jcc->jcc_ESC[0] = p1;
							jcc->jcc_ESC[1] = p2;
							break;
						}
						else			/* single string convert */
							break;
					}
ESC_THIRD_JIS_SJS:
					rcnt++;		/* junk */
					if (p2 == '$')
						jcc->jcc_ShiftedIn = TRUE;
					if (p2 == '(')
						jcc->jcc_ShiftedIn = FALSE;
				}
				break;
			case FF:
				break;
			default:
				if (jcc->jcc_ShiftedIn)
				{
					if (rcnt >= rlen)
					{
						if (length == -1)	/* continuous string */
						{
							jcc->jcc_FirstByte = p1;
							break;
						}
						else			/* single string convert */
							break;
					}
SECONDBYTE_JIS_SJS:
					p2 = inbuf[rcnt++];
					seven2eight(&p1, &p2);
					wcnt += writebuf(p1, p2, &outbuf[wcnt]);
				}
				else
				{
					outbuf[wcnt++] = p1;
				}
				break;
		}
	}
	return wcnt;
}

/* EUC to JIS */
LONG __saveds __asm
euc2seven(register __a0 struct JConversionCodeSet *jcc,
          register __a1 UBYTE *inbuf,
          register __a2 UBYTE *outbuf,
          register __d0 LONG length)
{
	LONG p1, p2, p3, p4;
	LONG rcnt = 0;
	LONG wcnt = 0;
	LONG rlen;
	LONG nigori = FALSE, maru = FALSE;

	if (length == -1)
		rlen = strlen(inbuf);
	else
		rlen = length;

	D(bug("euc2seven:rlen = %ld\n", rlen));

	if (length == -1)
	{
		if (jcc->jcc_FirstByte)
		{
			pop(&p1, &jcc->jcc_FirstByte);
			goto SECONDBYTE_EUC_JIS;
		}
		if (jcc->jcc_HanKata[0])
		{
			pop(&p1, &(jcc->jcc_HanKata[0]));
			if (jcc->jcc_HanKata[1])
			{
				pop(&p2, &(jcc->jcc_HanKata[1]));
				if (jcc->jcc_HanKata[2])
				{
					pop(&p3, &(jcc->jcc_HanKata[2]));
					goto HANKATA_FORTHBYTE_EUC_JIS;
				}
				goto HANKATA_THIRDBYTE_EUC_JIS;
			}
			goto HANKATA_SECONDBYTE_EUC_JIS;
		}
	}

	while (rcnt < rlen)
	{
		p1 = inbuf[rcnt++];
		switch (p1)
		{
			case LF:
				if (jcc->jcc_ShiftedIn)
				{
					jcc->jcc_ShiftedIn = FALSE;
					wcnt += KanjiOut(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
				}
				outbuf[wcnt++] = p1;
				break;
			case FF:
				break;
			default:
				if (IS_EUC_BYTE(p1))
				{
					if (rcnt >= rlen)
					{
						if (length == -1)	/* continuous string */
						{
							jcc->jcc_FirstByte = p1;
							break;
						}
						else			/* single string convert */
						{
							if (jcc->jcc_ShiftedIn)
							{
								jcc->jcc_ShiftedIn = FALSE;
								wcnt += KanjiOut(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
							}
							break;
						}
					}
SECONDBYTE_EUC_JIS:
					p2 = inbuf[rcnt++];
					if (IS_EUC_BYTE(p2))
					{
						p1 -= 0x80;
						p2 -= 0x80;
						if (!jcc->jcc_ShiftedIn)
						{
							jcc->jcc_ShiftedIn = TRUE;
							wcnt += KanjiIn(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
						}
						wcnt += writebuf(p1, p2, &outbuf[wcnt]);
					}
				}
				else if (p1 == 0x8e)	/* EUC half size 1st byte */
				{
					if (rcnt >= rlen)
					{
						if (length == -1)	/* continuous string */
						{
							jcc->jcc_HanKata[0] = p1;
							break;
						}
						else			/* single string convert */
						{
							if (jcc->jcc_ShiftedIn)
							{
								jcc->jcc_ShiftedIn = FALSE;
								wcnt += KanjiOut(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
							}
							break;
						}
					}
HANKATA_SECONDBYTE_EUC_JIS:
					p2 = inbuf[rcnt++];
					if (IS_HANKATA(p2))
					{
						if (rcnt >= rlen)
						{
							if (length == -1)	/* continuous string */
							{
								jcc->jcc_HanKata[0] = p1;
								jcc->jcc_HanKata[1] = p2;
								break;
							}
							else			/* single string convert */
							{
								p1 = p2;
								han2zen(&p1, &p2, 0, 0);
								eight2seven(&p1, &p2);
								if (!jcc->jcc_ShiftedIn)
								{
									jcc->jcc_ShiftedIn = TRUE;
									wcnt += KanjiIn(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
								}
								wcnt += writebuf(p1, p2, &outbuf[wcnt]);
								if (jcc->jcc_ShiftedIn)
								{
									jcc->jcc_ShiftedIn = FALSE;
									wcnt += KanjiOut(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
								}
								break;
							}
						}
HANKATA_THIRDBYTE_EUC_JIS:
						p3 = inbuf[rcnt++];
						if (p3 == 0x8e)	/* EUC half size 1st byte */
						{
							if (rcnt >= rlen)
							{
								if (length == -1)	/* continuous string */
								{
									jcc->jcc_HanKata[0] = p1;
									jcc->jcc_HanKata[1] = p2;
									jcc->jcc_HanKata[2] = p3;
									break;
								}
								else
								{
									p1 = p2;
									han2zen(&p1, &p2, 0, 0);
									eight2seven(&p1, &p2);
									if (!jcc->jcc_ShiftedIn)
									{
										jcc->jcc_ShiftedIn = TRUE;
										wcnt += KanjiIn(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
									}
									wcnt += writebuf(p1, p2, &outbuf[wcnt]);
									if (jcc->jcc_ShiftedIn)
									{
										jcc->jcc_ShiftedIn = FALSE;
										wcnt += KanjiOut(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
									}
									break;
								}
							}
HANKATA_FORTHBYTE_EUC_JIS:
							nigori = maru = FALSE;
							p4 = inbuf[rcnt++];

							p1 = p2;
							if (IS_NIGORI(p1, p4))	/* Next is dakuten */
								nigori = TRUE;
							else if (IS_MARU(p1, p4))	/* Next is maru */
								maru = TRUE;
							else	/* just HANKATA */
							{
								han2zen(&p1, &p2, nigori, maru);
								eight2seven(&p1, &p2);
								if (!jcc->jcc_ShiftedIn)
								{
									jcc->jcc_ShiftedIn = TRUE;
									wcnt += KanjiIn(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
								}
								wcnt += writebuf(p1, p2, &outbuf[wcnt]);

								rcnt--;
								p1 = p3;
								goto HANKATA_SECONDBYTE_EUC_JIS;
							}
						}
						else
							rcnt--;

						p1 = p2;
						han2zen(&p1, &p2, nigori, maru);
						eight2seven(&p1, &p2);
						if (!jcc->jcc_ShiftedIn)
						{
							jcc->jcc_ShiftedIn = TRUE;
							wcnt += KanjiIn(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
						}
					}
					wcnt += writebuf(p1, p2, &outbuf[wcnt]);
				}
				else
				{
					if (jcc->jcc_ShiftedIn)
					{
						jcc->jcc_ShiftedIn = FALSE;
						wcnt += KanjiOut(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
					}
					outbuf[wcnt++] = p1;
				}
				break;
		}
	}
	return wcnt;
}

/* EUC to EUC */
LONG __saveds __asm
euc2euc(register __a0 struct JConversionCodeSet *jcc,
        register __a1 UBYTE *inbuf,
        register __a2 UBYTE *outbuf,
        register __d0 LONG length,
        register __d1 ULONG textfilter)
{
	LONG p1, p2, p3, p4;
	LONG rcnt = 0;
	LONG wcnt = 0;
	LONG rlen;
	LONG nigori = FALSE, maru = FALSE;

	if (length == -1)
		rlen = strlen(inbuf);
	else
		rlen = length;

	D(bug("euc2euc:rlen = %ld\n", rlen));

	if (length == -1)
	{
		if (jcc->jcc_FirstByte)
		{
			pop(&p1, &jcc->jcc_FirstByte);
			goto SECONDBYTE_EUC_EUC;
		}
		if (jcc->jcc_HanKata[0])
		{
			pop(&p1, &(jcc->jcc_HanKata[0]));
			if (jcc->jcc_HanKata[1])
			{
				pop(&p2, &(jcc->jcc_HanKata[1]));
				if (jcc->jcc_HanKata[2])
				{
					pop(&p3, &(jcc->jcc_HanKata[2]));
					goto HANKATA_FORTHBYTE_EUC_EUC;
				}
				goto HANKATA_THIRDBYTE_EUC_EUC;
			}
			goto HANKATA_SECONDBYTE_EUC_EUC;
		}
	}

	while (rcnt < rlen)
	{
		p1 = inbuf[rcnt++];
		switch (p1)
		{
			case LF:
				if (textfilter)	/* add 0x0d */
					outbuf[wcnt++] = CR;
				outbuf[wcnt++] = LF;
				break;
			case FF:
				break;
			default:
				if (IS_EUC_BYTE(p1))
				{
					if (rcnt >= rlen)
					{
						if (length == -1)	/* continuous string */
						{
							jcc->jcc_FirstByte = p1;
							break;
						}
						else			/* single string convert */
							break;
					}
SECONDBYTE_EUC_EUC:
					p2 = inbuf[rcnt++];
					if (IS_EUC_BYTE(p2))
					{
						wcnt += writebuf(p1, p2, &outbuf[wcnt]);
					}
				}
				else if (p1 == 0x8e)	/* EUC half size 1st byte */
				{
					if (rcnt >= rlen)
					{
						if (length == -1)	/* continuous string */
						{
							jcc->jcc_HanKata[0] = p1;
							break;
						}
						else			/* single string convert */
							break;
					}
HANKATA_SECONDBYTE_EUC_EUC:
					p2 = inbuf[rcnt++];
					if (IS_HANKATA(p2))
					{
						if (rcnt >= rlen)
						{
							if (length == -1)	/* continuous string */
							{
								jcc->jcc_HanKata[0] = p1;
								jcc->jcc_HanKata[1] = p2;
								break;
							}
							else			/* single string convert */
							{
								p1 = p2;
								han2zen(&p1, &p2, 0, 0);
								eight2seven(&p1, &p2);
								wcnt += writebuf(p1+0x80, p2+0x80, &outbuf[wcnt]);
								break;
							}
						}
HANKATA_THIRDBYTE_EUC_EUC:
						p3 = inbuf[rcnt++];
						if (p3 == 0x8e)	/* EUC half size 1st byte */
						{
							if (rcnt >= rlen)
							{
								if (length == -1)	/* continuous string */
								{
									jcc->jcc_HanKata[0] = p1;
									jcc->jcc_HanKata[1] = p2;
									jcc->jcc_HanKata[2] = p3;
									break;
								}
								else
								{
									p1 = p2;
									han2zen(&p1, &p2, 0, 0);
									eight2seven(&p1, &p2);
									wcnt += writebuf(p1+0x80, p2+0x80, &outbuf[wcnt]);
									break;
								}
							}
HANKATA_FORTHBYTE_EUC_EUC:
							nigori = maru = FALSE;
							p4 = inbuf[rcnt++];

							p1 = p2;
							if (IS_NIGORI(p1, p4))	/* Next is dakuten */
								nigori = TRUE;
							else if (IS_MARU(p1, p4))	/* Next is maru */
								maru = TRUE;
							else	/* just HANKATA */
							{
								han2zen(&p1, &p2, nigori, maru);
								eight2seven(&p1, &p2);
								wcnt += writebuf(p1+0x80, p2+0x80, &outbuf[wcnt]);

								rcnt--;
								p1 = p3;
								goto HANKATA_SECONDBYTE_EUC_EUC;
							}
						}
						else
							rcnt--;

						p1 = p2;
						han2zen(&p1, &p2, nigori, maru);
						eight2seven(&p1, &p2);
						p1 += 0x80;
						p2 += 0x80;
					}
					wcnt += writebuf(p1, p2, &outbuf[wcnt]);
				}
				else
				{
					outbuf[wcnt++] = p1;
				}
				break;
		}
	}
	return wcnt;
}

/* EUC to Shift-JIS */
LONG __saveds __asm
euc2shift(register __a0 struct JConversionCodeSet *jcc,
          register __a1 UBYTE *inbuf,
          register __a2 UBYTE *outbuf,
          register __d0 LONG length,
          register __d1 LONG textfilter)
{
	LONG p1, p2, p3, p4;
	LONG rcnt = 0;
	LONG wcnt = 0;
	LONG rlen;
	LONG nigori = FALSE, maru = FALSE;

	if (length == -1)
		rlen = strlen(inbuf);
	else
		rlen = length;

	D(bug("euc2shift:rlen = %ld\n", rlen));

	if (length == -1)
	{
		if (jcc->jcc_FirstByte)
		{
			pop(&p1, &jcc->jcc_FirstByte);
			goto SECONDBYTE_EUC_SJIS;
		}
		if (jcc->jcc_HanKata[0])
		{
			pop(&p1, &(jcc->jcc_HanKata[0]));
			if (jcc->jcc_HanKata[1])
			{
				pop(&p2, &(jcc->jcc_HanKata[1]));
				if (jcc->jcc_HanKata[2])
				{
					pop(&p3, &(jcc->jcc_HanKata[2]));
					goto HANKATA_FORTHBYTE_EUC_SJIS;
				}
				goto HANKATA_THIRDBYTE_EUC_SJIS;
			}
			goto HANKATA_SECONDBYTE_EUC_SJIS;
		}
	}

	while (rcnt < rlen)
	{
		p1 = inbuf[rcnt++];
		switch (p1)
		{
			case LF:
				if (textfilter)	/* add 0x0d */
					outbuf[wcnt++] = CR;
				outbuf[wcnt++] = LF;
				break;
			case FF:
				break;
			default:
				if (IS_EUC_BYTE(p1))
				{
					if (rcnt >= rlen)
					{
						if (length == -1)	/* continuous string */
						{
							jcc->jcc_FirstByte = p1;
							break;
						}
						else			/* single string convert */
							break;
					}
SECONDBYTE_EUC_SJIS:
					p2 = inbuf[rcnt++];
					if (IS_EUC_BYTE(p2))
					{
						p1 -= 0x80;
						p2 -= 0x80;
						seven2eight(&p1, &p2);
						wcnt += writebuf(p1, p2, &outbuf[wcnt]);
					}
				}
				else if (p1 == 0x8e)	/* EUC half size 1st byte */
				{
					if (rcnt >= rlen)
					{
						if (length == -1)	/* continuous string */
						{
							jcc->jcc_HanKata[0] = p1;
							break;
						}
						else			/* single string convert */
							break;
					}
HANKATA_SECONDBYTE_EUC_SJIS:
					p2 = inbuf[rcnt++];
					if (IS_HANKATA(p2))
					{
						if (rcnt >= rlen)
						{
							if (length == -1)	/* continuous string */
							{
								jcc->jcc_HanKata[0] = p1;
								jcc->jcc_HanKata[1] = p2;
								break;
							}
							else			/* single string convert */
							{
								p1 = p2;
								han2zen(&p1, &p2, 0, 0);
								wcnt += writebuf(p1, p2, &outbuf[wcnt]);
								break;
							}
						}
HANKATA_THIRDBYTE_EUC_SJIS:
						p3 = inbuf[rcnt++];
						if (p3 == 0x8e)	/* EUC half size 1st byte */
						{
							if (rcnt >= rlen)
							{
								if (length == -1)	/* continuous string */
								{
									jcc->jcc_HanKata[0] = p1;
									jcc->jcc_HanKata[1] = p2;
									jcc->jcc_HanKata[2] = p3;
									break;
								}
								else
								{
									p1 = p2;
									han2zen(&p1, &p2, 0, 0);
									wcnt += writebuf(p1, p2, &outbuf[wcnt]);
									break;
								}
							}
HANKATA_FORTHBYTE_EUC_SJIS:
							nigori = maru = FALSE;
							p4 = inbuf[rcnt++];

							p1 = p2;
							if (IS_NIGORI(p1, p4))	/* Next is dakuten */
								nigori = TRUE;
							else if (IS_MARU(p1, p4))	/* Next is maru */
								maru = TRUE;
							else	/* just HANKATA */
							{
								han2zen(&p1, &p2, 0, 0);
								wcnt += writebuf(p1, p2, &outbuf[wcnt]);

								rcnt--;
								p1 = p3;
								goto HANKATA_SECONDBYTE_EUC_SJIS;
							}
						}
						else
							rcnt--;

						p1 = p2;
						han2zen(&p1, &p2, nigori, maru);
					}
					wcnt += writebuf(p1, p2, &outbuf[wcnt]);
				}
				else
				{
					outbuf[wcnt++] = p1;
				}
				break;
		}
	}
	return wcnt;
}

/* Shift-JIS to JIS */
LONG __saveds __asm
shift2seven(register __a0 struct JConversionCodeSet *jcc,
            register __a1 UBYTE *inbuf,
            register __a2 UBYTE *outbuf,
            register __d0 LONG length)
{
	LONG p1, p2;
	LONG rcnt = 0;
	LONG wcnt = 0;
	LONG rlen;
	LONG nigori = FALSE, maru = FALSE;

	if (length == -1)
		rlen = strlen(inbuf);
	else
		rlen = length;

	D(bug("shift2seven:rlen = %ld\n", rlen));

	if (length == -1)
	{
		if (jcc->jcc_FirstByte)
		{
			pop(&p1, &jcc->jcc_FirstByte);
			goto SECONDBYTE_SJIS_JIS;
		}
		if (jcc->jcc_HanKata[0])
		{
			pop(&p1, &(jcc->jcc_HanKata[0]));
			goto HANKATA_SECONDBYTE_SJIS_JIS;
		}
	}

	while (rcnt < rlen)
	{
		p1 = inbuf[rcnt++];
		switch (p1)
		{
			case CR:
			case LF:
				if (jcc->jcc_ShiftedIn)
				{
					jcc->jcc_ShiftedIn = FALSE;
					wcnt += KanjiOut(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
				}
				outbuf[wcnt++] = LF;
				break;
			case NULL:
			case FF:
				break;
			default:
				if (IS_SJIS_BYTE1(p1))
				{
					if (rcnt >= rlen)
					{
						if (length == -1)	/* continuous string */
						{
							jcc->jcc_FirstByte = p1;
							break;
						}
						else			/* single string convert */
						{
							if (jcc->jcc_ShiftedIn)
							{
								jcc->jcc_ShiftedIn = FALSE;
								wcnt += KanjiOut(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
							}
							break;
						}
					}
SECONDBYTE_SJIS_JIS:
					p2 = inbuf[rcnt++];
					if (IS_SJIS_BYTE2(p2))
					{
						eight2seven(&p1, &p2);
						if (!jcc->jcc_ShiftedIn)
						{
							jcc->jcc_ShiftedIn = TRUE;
							wcnt += KanjiIn(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
						}
						wcnt += writebuf(p1, p2, &outbuf[wcnt]);
					}
				}
				else if (IS_HANKATA(p1))
				{
					if (rcnt >= rlen)
					{
						if (length == -1)	/* continuous string */
						{
							jcc->jcc_HanKata[0] = p1;
							break;
						}
						else			/* single string convert */
						{
							han2zen(&p1, &p2, 0, 0);
							eight2seven(&p1, &p2);
							if (!jcc->jcc_ShiftedIn)
							{
								jcc->jcc_ShiftedIn = TRUE;
								wcnt += KanjiIn(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
							}
							wcnt += writebuf(p1, p2, &outbuf[wcnt]);
							if (jcc->jcc_ShiftedIn)
							{
								jcc->jcc_ShiftedIn = FALSE;
								wcnt += KanjiOut(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
							}
							break;
						}
					}
					else
					{
HANKATA_SECONDBYTE_SJIS_JIS:
						nigori = maru = FALSE;
						p2 = inbuf[rcnt++];

						if (IS_NIGORI(p1, p2))	/* Next is dakuten */
							nigori = TRUE;
						else if (IS_MARU(p1, p2))	/* Next is maru */
							maru = TRUE;
						else
							rcnt--;

						han2zen(&p1, &p2, nigori, maru);
					}
					eight2seven(&p1, &p2);
					if (!jcc->jcc_ShiftedIn)
					{
						jcc->jcc_ShiftedIn = TRUE;
						wcnt += KanjiIn(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
					}
					wcnt += writebuf(p1, p2, &outbuf[wcnt]);
				}
				else
				{
					if (jcc->jcc_ShiftedIn)
					{
						jcc->jcc_ShiftedIn = FALSE;
						wcnt += KanjiOut(jcc->jcc_WhatOutputCode, &outbuf[wcnt]);
					}
					outbuf[wcnt++] = p1;
				}
				break;
		}
	}
	return wcnt;
}

/* Shift-JIS to EUC */
LONG __saveds __asm
shift2euc(register __a0 struct JConversionCodeSet *jcc,
          register __a1 UBYTE *inbuf,
          register __a2 UBYTE *outbuf,
          register __d0 LONG length,
          register __d1 ULONG hankatatype,
          register __d2 UBYTE udhankata,
          register __d3 ULONG textfilter)

{
	LONG p1, p2;
	LONG rcnt = 0;
	LONG wcnt = 0;
	LONG rlen;
	LONG nigori = FALSE, maru = FALSE;

	if (length == -1)
		rlen = strlen(inbuf);
	else
		rlen = length;

	D(bug("shift2euc:rlen = %ld\n", rlen));

	if (length == -1)
	{
		if (jcc->jcc_FirstByte)
		{
			pop(&p1, &jcc->jcc_FirstByte);
			goto SECONDBYTE_SJIS_EUC;
		}
		if (jcc->jcc_HanKata[0])
		{
			pop(&p1, &(jcc->jcc_HanKata[0]));
			goto HANKATA_SECONDBYTE_SJIS_EUC;
		}
	}

	while (rcnt < rlen)
	{
		p1 = inbuf[rcnt++];
		switch (p1)
		{
			case CR:
				if (textfilter)	/* remove 0x0d */
					break;
				else
					outbuf[wcnt++] = CR;
				break;
			case LF:
				outbuf[wcnt++] = LF;
				break;
			case NULL:
			case FF:
			case PCEOF:
				break;
			default:
				if (IS_SJIS_BYTE1(p1))
				{
					if (rcnt >= rlen)
					{
						if (length == -1)	/* continuous string */
						{
							jcc->jcc_FirstByte = p1;
							break;
						}
						else			/* single string convert */
							break;
					}
SECONDBYTE_SJIS_EUC:
					p2 = inbuf[rcnt++];
					if (IS_SJIS_BYTE2(p2))
					{
						eight2seven(&p1, &p2);
						wcnt += writebuf(p1+0x80, p2+0x80, &outbuf[wcnt]);
					}
				}
				else if (IS_HANKATA(p1))
				{
					if (rcnt >= rlen)
					{
						if (hankatatype == JCT_EUCHanKata)
							wcnt += writebuf(0x8e, p1, &outbuf[wcnt]);
						else if (hankatatype == JCT_UDHanKata)
							outbuf[wcnt++] = udhankata;
						else
						{
							if (length == -1)	/* continuous string */
							{
								jcc->jcc_HanKata[0] = p1;
								break;
							}
							else			/* single string convert */
							{
								han2zen(&p1, &p2, 0, 0);
								eight2seven(&p1, &p2);
								wcnt += writebuf(p1+0x80, p2+0x80, &outbuf[wcnt]);
							}
						}
					}
					else
					{
HANKATA_SECONDBYTE_SJIS_EUC:
						if (hankatatype == JCT_EUCHanKata)
							wcnt += writebuf(0x8e, p1, &outbuf[wcnt]);
						else if (hankatatype == JCT_UDHanKata)
							outbuf[wcnt++] = udhankata;
						else
						{
							nigori = maru = FALSE;
							p2 = inbuf[rcnt++];

							if (IS_NIGORI(p1, p2))	/* Next is dakuten */
								nigori = TRUE;
							else if (IS_MARU(p1, p2))	/* Next is maru */
								maru = TRUE;
							else
								rcnt--;

							han2zen(&p1, &p2, nigori, maru);
							eight2seven(&p1, &p2);
							wcnt += writebuf(p1+0x80, p2+0x80, &outbuf[wcnt]);
						}
					}
				}
				else
				{
					outbuf[wcnt++] = p1;
				}
				break;
		}
	}
	return wcnt;
}

/* Shift-JIS to Shift-JIS */
LONG __saveds __asm
shift2shift(register __a0 struct JConversionCodeSet *jcc,
            register __a1 UBYTE *inbuf,
            register __a2 UBYTE *outbuf,
            register __d0 LONG length,
            register __d1 ULONG hankatatype,
            register __d2 UBYTE udhankata,
            register __d3 ULONG textfilter)
{
	LONG p1, p2;
	LONG rcnt = 0;
	LONG wcnt = 0;
	LONG rlen;
	LONG nigori = FALSE, maru = FALSE;

	if (length == -1)
		rlen = strlen(inbuf);
	else
		rlen = length;

	D(bug("shift2shift:rlen = %ld\n", rlen));

	if (length == -1)
	{
		if (jcc->jcc_FirstByte)
		{
			pop(&p1, &jcc->jcc_FirstByte);
			goto SECONDBYTE_SJIS_SJIS;
		}
		if (jcc->jcc_HanKata[0])
		{
			pop(&p1, &(jcc->jcc_HanKata[0]));
			goto HANKATA_SECONDBYTE_SJIS_SJIS;
		}
	}

	while (rcnt < rlen)
	{
		p1 = inbuf[rcnt++];
		switch (p1)
		{
			case CR:
				if (textfilter)	/* remove 0x0d */
					break;
				else
					outbuf[wcnt++] = CR;
				break;
			case LF:
				outbuf[wcnt++] = LF;
				break;
			case NULL:
			case FF:
			case PCEOF:
				break;
			default:
				if (IS_SJIS_BYTE1(p1))
				{
					if (rcnt >= rlen)
					{
						if (length == -1)	/* continuous string */
						{
							jcc->jcc_FirstByte = p1;
							break;
						}
						else			/* single string convert */
							break;
					}
SECONDBYTE_SJIS_SJIS:
					p2 = inbuf[rcnt++];
					if (IS_SJIS_BYTE2(p2))
					{
						wcnt += writebuf(p1, p2, &outbuf[wcnt]);
					}
				}
				else if (IS_HANKATA(p1))
				{
					if (rcnt >= rlen)
					{
						if (hankatatype == JCT_SJISHanKata)
							outbuf[wcnt++] = p1;
						else if (hankatatype == JCT_UDHanKata)
							outbuf[wcnt++] = udhankata;
						else
						{
							if (length == -1)	/* continuous string */
							{
								jcc->jcc_HanKata[0] = p1;
								break;
							}
							else			/* single string convert */
							{
								han2zen(&p1, &p2, 0, 0);
								wcnt += writebuf(p1, p2, &outbuf[wcnt]);
							}
						}
					}
					else
					{
HANKATA_SECONDBYTE_SJIS_SJIS:
						if (hankatatype == JCT_SJISHanKata)
							outbuf[wcnt++] = p1;
						else if (hankatatype == JCT_UDHanKata)
							outbuf[wcnt++] = udhankata;
						else
						{
							nigori = maru = FALSE;
							p2 = inbuf[rcnt++];

							if (IS_NIGORI(p1, p2))	/* Next is dakuten */
								nigori = TRUE;
							else if (IS_MARU(p1, p2))	/* Next is maru */
								maru = TRUE;
							else
								rcnt--;

							han2zen(&p1, &p2, nigori, maru);
							wcnt += writebuf(p1, p2, &outbuf[wcnt]);
						}
					}
				}
				else
				{
					outbuf[wcnt++] = p1;
				}
				break;
		}
	}
	return wcnt;
}

LONG __saveds __asm
LIBJStringConvertA(register __a0 struct JConversionCodeSet *jcc,
                   register __a1 UBYTE *inbuf,
                   register __a2 UBYTE *outbuf,
                   register __d0 LONG incode,
                   register __d1 LONG outcode,
                   register __d2 LONG length,
                   register __a3 struct TagItem *taglist)
{
	LONG wcnt = -1;
	LONG hankatatype = 0;

	BOOL euchankata = GetTagData(JCT_EUCHanKata, FALSE ,taglist);
	BOOL sjishankata = GetTagData(JCT_SJISHanKata, FALSE ,taglist);
	UBYTE udhankata = GetTagData(JCT_UDHanKata, 0x00 ,taglist);
	BOOL textfilter = GetTagData(JCT_TextFilter, FALSE ,taglist);

	if (udhankata)
	{
		hankatatype = JCT_UDHanKata;
	}
	else
	{
		if (outcode == CTYPE_EUC)
			if (euchankata)
				hankatatype = JCT_EUCHanKata;
		if (outcode == CTYPE_SJIS)
			if (sjishankata)
				hankatatype = JCT_SJISHanKata;
	}

	jcc->jcc_WhatInputCode = incode;
	jcc->jcc_WhatOutputCode = outcode;

	switch(incode)
	{
		case CTYPE_NEWJIS:
		case CTYPE_OLDJIS:
		case CTYPE_NECJIS:
			switch(outcode)
			{
				case CTYPE_NEWJIS:
				case CTYPE_OLDJIS:
				case CTYPE_NECJIS:
					wcnt = seven2seven(jcc, inbuf, outbuf, length);
					outbuf[wcnt] = 0x00;
					break;
				case CTYPE_EUC:
					wcnt = seven2euc(jcc, inbuf, outbuf, length);
					outbuf[wcnt] = 0x00;
					break;
				case CTYPE_SJIS:
					wcnt = seven2shift(jcc, inbuf, outbuf, length);
					outbuf[wcnt] = 0x00;
					break;
				deault:
					break;
			}
			break;
		case CTYPE_EUC:
			switch(outcode)
			{
				case CTYPE_NEWJIS:
				case CTYPE_OLDJIS:
				case CTYPE_NECJIS:
					wcnt = euc2seven(jcc, inbuf, outbuf, length);
					outbuf[wcnt] = 0x00;
					break;
				case CTYPE_EUC:
					wcnt = euc2euc(jcc, inbuf, outbuf, length, textfilter);
					outbuf[wcnt] = 0x00;
					break;
				case CTYPE_SJIS:
					wcnt = euc2shift(jcc, inbuf, outbuf, length, textfilter);
					outbuf[wcnt] = 0x00;
					break;
				default:
					break;
			}
			break;
		case CTYPE_SJIS:
			switch(outcode)
			{
				case CTYPE_NEWJIS:
				case CTYPE_OLDJIS:
				case CTYPE_NECJIS:
					wcnt = shift2seven(jcc, inbuf, outbuf, length);
					outbuf[wcnt] = 0x00;
					break;
				case CTYPE_EUC:
					wcnt = shift2euc(jcc, inbuf, outbuf, length, hankatatype, udhankata, textfilter);
					outbuf[wcnt] = 0x00;
					break;
				case CTYPE_SJIS:
					wcnt = shift2shift(jcc, inbuf, outbuf, length, hankatatype, udhankata, textfilter);
					outbuf[wcnt] = 0x00;
					break;
				default:
					break;
			}
			break;
		default:
			break;
	}
	return wcnt;
}
@


1.2
log
@Remove dead assignment.
@
text
@d9 2
d12 1
d14 1
d22 1
d24 4
a27 2
/************************** My debug stuff ***************************/
#define MYDEBUG	0
d29 1
a29 4
#define DBFLAG	0
void kprintf(UBYTE *, ...);
extern UBYTE b[40];
#define D(FMT,ARG) if(DBFLAG) {sprintf(b,FMT,ARG);kprintf("%s\n",b);}
d31 9
a39 3
#define D(FMT,ARG) ;
#endif
/*********************************************************************/
d42 2
a43 2
LIBKanjiIn(register __d0 LONG outcode,
	register __a0 UBYTE *outbuf)
a44 1
	LONG rlen = strlen(outbuf);
d50 3
a52 1
			sprintf(&outbuf[rlen], "%c%s", ESC, NEW_KI);
d56 3
a58 1
			sprintf(&outbuf[rlen], "%c%s", ESC, OLD_KI);
d62 2
a63 1
			sprintf(&outbuf[rlen], "%c%s", ESC, NEC_KI);
d74 2
a75 2
LIBKanjiOut(register __d0 LONG outcode,
	 register __a0 UBYTE *outbuf)
a76 1
	LONG rlen = strlen(outbuf);
a81 3
			sprintf(&outbuf[rlen], "%c%s", ESC, NEW_KO);
			wlen = 3;
			break;
d83 3
a85 1
			sprintf(&outbuf[rlen], "%c%s", ESC, OLD_KO);
d89 2
a90 1
			sprintf(&outbuf[rlen], "%c%s", ESC, NEC_KO);
d100 11
d119 1
a119 1
eight2seven(register __a0 LONG *p1, register __a1 LONG *p2)
d124 5
a128 5
	if ((*p2 >= 64) && (*p2 <= 158))
		*p2 -= 31;
	else if ((*p2 >= 159) && (*p2 <= 252))
		*p2 -= 126;
	if ((temp > 127) && (temp <= 158))
d130 1
a130 1
	if ((*p1 >= 129) && (*p1 <= 159))
d132 11
a142 11
		if ((temp >= 64) && (temp <= 158))
			*p1 = ((*p1 - 113) * 2) + 1;
		else if ((temp >= 159) && (temp <= 252))
			*p1 = (*p1 - 112) * 2;
	}
	else if ((*p1 >= 224) && (*p1 <= 239))
	{
		if ((temp >= 64) && (temp <= 158))
			*p1 = ((*p1 - 177) * 2) + 1;
		else if ((temp >= 159) && (temp <= 252))
			*p1 = (*p1 - 176) * 2;
d148 1
a148 1
seven2eight(register __a0 LONG *p1, register __a1 LONG *p2)
d173 21
a193 1
pop(register __a0 LONG *p, register __a1 UBYTE *jcc_b)
d195 17
a211 2
	*p = *jcc_b;
	*jcc_b = 0x00;
a213 1
/* This function converts Shift-JIS. */
d215 1
a215 4
han2zen(register __a0 LONG *one,
	register __a1 LONG *two,
	register __d0 LONG nigori,
	register __d1 LONG maru)
d217 2
a218 266
	switch (*one)
	{
		case 0xa1:	/* Japanese period */
			*one = 0x81;
			*two = 0x42;
			break;
		case 0xa2:	/* kagikakko right up */
			*one = 0x81;
			*two = 0x75;
			break;
		case 0xa3:      /* kagikakko left down */
			*one = 0x81;
			*two = 0x76;
			break;
		case 0xa4:     /* Japanese comma */
			*one = 0x81;
			*two = 0x41;
			break;
		case 0xa5:      /* center dot */
			*one = 0x81;
			*two = 0x45;
			break;
		case 0xa6:	/* wo */
			*one = 0x83;
			*two = 0x92;
			break;
		case 0xa7:	/* lower a */
			*one = 0x83;
			*two = 0x40;
			break;
		case 0xa8:	/* lower i */
			*one = 0x83;
			*two = 0x42;
			break;
		case 0xa9:	/* lower u */
			*one = 0x83;
			*two = 0x44;
			break;
		case 0xaa:	/* lower e */
			*one = 0x83;
			*two = 0x46;
			break;
		case 0xab:	/* lower o */
			*one = 0x83;
			*two = 0x48;
			break;
		case 0xac:	/* lower ya */
			*one = 0x83;
			*two = 0x83;
			break;
		case 0xad:	/* lower yu */
			*one = 0x83;
			*two = 0x85;
			break;
		case 0xae:	/* lower yo */
			*one = 0x83;
			*two = 0x87;
			break;
		case 0xaf:	/* lower tsu */
			*one = 0x83;
			*two = 0x62;
			break;
		case 0xb0:	/* nobashi - */
			*one = 0x81;
			*two = 0x5b;
			break;
		case 0xb1:	/* a */
			*one = 0x83;
			*two = 0x41;
			break;
		case 0xb2:	/* i */
			*one = 0x83;
			*two = 0x43;
			break;
		case 0xb3:	/* u */
			*one = 0x83;
			*two = 0x45;
			break;
		case 0xb4:	/* e */
			*one = 0x83;
			*two = 0x47;
			break;
		case 0xb5:	/* o */
			*one = 0x83;
			*two = 0x49;
			break;
		case 0xb6:	/* ka */
			*one = 0x83;
			*two = 0x4a;
			break;
		case 0xb7:	/* ki */
			*one = 0x83;
			*two = 0x4c;
			break;
		case 0xb8:	/* ku */
			*one = 0x83;
			*two = 0x4e;
			break;
		case 0xb9:	/* ke */
			*one = 0x83;
			*two = 0x50;
			break;
		case 0xba:	/* ko */
			*one = 0x83;
			*two = 0x52;
			break;
		case 0xbb:	/* sa */
			*one = 0x83;
			*two = 0x54;
			break;
		case 0xbc:	/* si */
			*one = 0x83;
			*two = 0x56;
			break;
		case 0xbd:	/* su */
			*one = 0x83;
			*two = 0x58;
			break;
		case 0xbe:	/* se */
			*one = 0x83;
			*two = 0x5a;
			break;
		case 0xbf:	/* so */
			*one = 0x83;
			*two = 0x5c;
			break;
		case 0xc0:	/* ta */
			*one = 0x83;
			*two = 0x5e;
			break;
		case 0xc1:	/* ti */
			*one = 0x83;
			*two = 0x60;
			break;
		case 0xc2:	/* tu */
			*one = 0x83;
			*two = 0x63;
			break;
		case 0xc3:	/* te */
			*one = 0x83;
			*two = 0x65;
			break;
		case 0xc4:	/* to */
			*one = 0x83;
			*two = 0x67;
			break;
		case 0xc5:	/* na */
			*one = 0x83;
			*two = 0x69;
			break;
		case 0xc6:	/* ni */
			*one = 0x83;
			*two = 0x6a;
			break;
		case 0xc7:	/* nu */
			*one = 0x83;
			*two = 0x6b;
			break;
		case 0xc8:	/* ne */
			*one = 0x83;
			*two = 0x6c;
			break;
		case 0xc9:	/* no */
			*one = 0x83;
			*two = 0x6d;
			break;
		case 0xca:	/* ha */
			*one = 0x83;
			*two = 0x6e;
			break;
		case 0xcb:	/* hi */
			*one = 0x83;
			*two = 0x71;
			break;
		case 0xcc:	/* fu */
			*one = 0x83;
			*two = 0x74;
			break;
		case 0xcd:	/* he */
			*one = 0x83;
			*two = 0x77;
			break;
		case 0xce:	/* ho */
			*one = 0x83;
			*two = 0x7a;
			break;
		case 0xcf:	/* ma */
			*one = 0x83;
			*two = 0x7d;
			break;
		case 0xd0:	/* mi */
			*one = 0x83;
			*two = 0x7e;
			break;
		case 0xd1:	/* mu */
			*one = 0x83;
			*two = 0x80;
			break;
		case 0xd2:	/* me */
			*one = 0x83;
			*two = 0x81;
			break;
		case 0xd3:	/* mo */
			*one = 0x83;
			*two = 0x82;
			break;
		case 0xd4:	/* ya */
			*one = 0x83;
			*two = 0x84;
			break;
		case 0xd5:	/* yu */
			*one = 0x83;
			*two = 0x86;
			break;
		case 0xd6:	/* yo */
			*one = 0x83;
			*two = 0x88;
			break;
		case 0xd7:	/* ra */
			*one = 0x83;
			*two = 0x89;
			break;
		case 0xd8:	/* ri */
			*one = 0x83;
			*two = 0x8a;
			break;
		case 0xd9:	/* ru */
			*one = 0x83;
			*two = 0x8b;
			break;
		case 0xda:	/* re */
			*one = 0x83;
			*two = 0x8c;
			break;
		case 0xdb:	/* ro */
			*one = 0x83;
			*two = 0x8d;
			break;
		case 0xdc:	/* wa */
			*one = 0x83;
			*two = 0x8f;
			break;
		case 0xdd:	/* n */
			*one = 0x83;
			*two = 0x93;
			break;
		case 0xde:	/* dakuten */
			*one = 0x81;
			*two = 74;
			break;
		case 0xdf:	/* maru */
			*one = 0x81;
			*two = 75;
			break;
	}
	if (nigori)
	{
		if (((*two >= 0x4a) && (*two <= 0x67))	/* from "ka" to "to" */
		 || ((*two >= 0x6e) && (*two <= 0x7a)))	/* from "ha" to "ho" */
			(*two)++;
		else if ((*one == 0x83) && (*two == 0x45)) /* "u" */
			*two = 0x94;	/* "bu" */
	}
	else if ((maru)
		 && ((*two >= 0x6e) && (*two <= 0x7a)))	/* from "ha" to "ho" */
		*two += 2;
d224 3
a226 2
	    register __a1 UBYTE *inbuf,
	    register __a2 UBYTE *outbuf)
d229 1
a229 1
	LONG rcnt = 0;
d231 6
a236 1
	LONG rlen = strlen(inbuf);
d238 1
a238 1
	D("seven2seven/rlen = %ld", rlen);
d240 8
a247 10
	if (jcc->jcc_FirstByte)
	{
		pop(&p1, &jcc->jcc_FirstByte);
		goto SECONDBYTE_JIS_JIS;
	}
	if (jcc->jcc_ESC[0] == ESC)
	{
		pop(&p1, &(jcc->jcc_ESC[0]));
		if (jcc->jcc_ESC[1] == '$'
		 || jcc->jcc_ESC[1] == '(')
d249 8
a256 2
			pop(&p2, &(jcc->jcc_ESC[1]));
			goto ESC_THIRD_JIS_JIS;
a257 1
		goto ESC_SECOND_JIS_JIS;
d265 1
a265 14
		    case ESC:
			if (rcnt >= rlen)
			{
				jcc->jcc_ESC[0] = ESC;
				break;
			}
ESC_SECOND_JIS_JIS:
			p2 = inbuf[rcnt++];
			if      (p2 == 'K')
				jcc->jcc_ShiftedIn = TRUE;
			else if (p2 == 'H')
				jcc->jcc_ShiftedIn = FALSE;
			else if ((p2 == '$') || (p2 == '('))
			{
d268 14
a281 3
					jcc->jcc_ESC[0] = p1;
					jcc->jcc_ESC[1] = p2;
					break;
d283 3
a285 5
ESC_THIRD_JIS_JIS:
				/* 39.2 - p3 was dead assignment */
				/* p3 = inbuf[rcnt++]; */
				rcnt++;		/* junk */
				if (p2 == '$')
d287 1
a287 1
				if (p2 == '(')
d289 35
a323 21
			}
			if (jcc->jcc_ShiftedIn)
				wcnt += LIBKanjiIn(jcc->jcc_WhatOutputCode, outbuf);
			else
				wcnt += LIBKanjiOut(jcc->jcc_WhatOutputCode, outbuf);
			break;

		case NL:
			if (jcc->jcc_ShiftedIn)
			{
				jcc->jcc_ShiftedIn = FALSE;
				wcnt += LIBKanjiOut(jcc->jcc_WhatOutputCode, outbuf);
			}
			outbuf[wcnt++] = p1;
			break;
		case FF:
			break;
		default:
			if (jcc->jcc_ShiftedIn)
			{
				if (rcnt >= rlen)
d325 2
a326 2
					jcc->jcc_FirstByte = p1;
					break;
d328 24
d353 8
a360 9
				p2 = inbuf[rcnt++];
				outbuf[wcnt++] = p1;
				outbuf[wcnt++] = p2;
			}
			else
			{
				outbuf[wcnt++] = p1;
			}
			break;
a362 1

a363 1

d369 3
a371 2
	  register __a1 UBYTE *inbuf,
	  register __a2 UBYTE *outbuf)
d374 27
a400 16
	LONG rcnt = 0;
	LONG wcnt = 0;
	LONG rlen = strlen(inbuf);

	D("seven2euc/rlen = %ld", rlen);

	if (jcc->jcc_FirstByte)
	{
		pop(&p1, &jcc->jcc_FirstByte);
		goto SECONDBYTE_JIS_EUC;
	}
	if (jcc->jcc_ESC[0] == ESC)
	{
		if (jcc->jcc_ESC[1] == '$'
		 || jcc->jcc_ESC[1] == '(')
		{
d402 1
a402 2
			pop(&p2, &(jcc->jcc_ESC[1]));
			goto ESC_THIRD_JIS_EUC;
a403 2
		pop(&p1, &(jcc->jcc_ESC[0]));
		goto ESC_SECOND_JIS_EUC;
d411 1
a411 14
		    case ESC:
			if (rcnt >= rlen)
			{
				jcc->jcc_ESC[0] = ESC;
				break;
			}
ESC_SECOND_JIS_EUC:
			p2 = inbuf[rcnt++];
			if      (p2 == 'K')
				jcc->jcc_ShiftedIn = TRUE;
			else if (p2 == 'H')
				jcc->jcc_ShiftedIn = FALSE;
			else if ((p2 == '$') || (p2 == '('))
			{
d414 7
a420 3
					jcc->jcc_ESC[0] = p1;
					jcc->jcc_ESC[1] = p2;
					break;
d422 3
a424 5
ESC_THIRD_JIS_EUC:
				/* 39.2 - p3 was dead assignment */
				/* p3 = inbuf[rcnt++]; */
				rcnt++;		/* junk */
				if (p2 == '$')
d426 1
a426 1
				if (p2 == '(')
d428 23
a450 15
			}
			break;
		    case NL:
			if (jcc->jcc_ShiftedIn)
			{
				jcc->jcc_ShiftedIn = FALSE;
			}
			outbuf[wcnt++] = p1;
			break;
		    case FF:
			break;
		    default:
			if (jcc->jcc_ShiftedIn)
			{
				if (rcnt >= rlen)
d452 1
a452 2
					jcc->jcc_FirstByte = p1;
					break;
d454 17
d472 8
a479 11
				p2 = inbuf[rcnt++];
				p1 += 0x80;
				p2 += 0x80;
				outbuf[wcnt++] = p1;
				outbuf[wcnt++] = p2;
			}
			else
			{
				outbuf[wcnt++] = p1;
			}
			break;
d488 3
a490 2
	     register __a1 UBYTE *inbuf,
	     register __a2 UBYTE *outbuf)
d493 27
a519 16
	LONG rcnt = 0;
	LONG wcnt = 0;
	LONG rlen = strlen(inbuf);

	D("seven2shift/rlen = %ld", rlen);

	if (jcc->jcc_FirstByte)
	{
		pop(&p1, &jcc->jcc_FirstByte);
		goto SECONDBYTE_JIS_SJS;
	}
	if (jcc->jcc_ESC[0] == ESC)
	{
		if (jcc->jcc_ESC[1] == '$'
		 || jcc->jcc_ESC[1] == '(')
		{
d521 1
a521 2
			pop(&p2, &(jcc->jcc_ESC[1]));
			goto ESC_THIRD_JIS_SJS;
a522 2
		pop(&p1, &(jcc->jcc_ESC[0]));
		goto ESC_SECOND_JIS_SJS;
d530 1
a530 14
		    case ESC:
			if (rcnt >= rlen)
			{
				jcc->jcc_ESC[0] = ESC;
				break;
			}
ESC_SECOND_JIS_SJS:
			p2 = inbuf[rcnt++];
			if      (p2 == 'K')
				jcc->jcc_ShiftedIn = TRUE;
			else if (p2 == 'H')
				jcc->jcc_ShiftedIn = FALSE;
			else if ((p2 == '$') || (p2 == '('))
			{
d533 7
a539 3
					jcc->jcc_ESC[0] = p1;
					jcc->jcc_ESC[1] = p2;
					break;
d541 3
a543 5
ESC_THIRD_JIS_SJS:
				/* 39.2 - p3 was dead assignment */
				/* p3 = inbuf[rcnt++]; */
				rcnt++;		/* junk */
				if (p2 == '$')
d545 1
a545 1
				if (p2 == '(')
d547 1
a547 8
			}
			break;
		    case FF:
			break;
		    default:
			if (jcc->jcc_ShiftedIn)
			{
				if (rcnt >= rlen)
d549 17
a565 2
					jcc->jcc_FirstByte = p1;
					break;
d567 16
d584 9
a592 10
				p2 = inbuf[rcnt++];
				seven2eight(&p1, &p2);
				outbuf[wcnt++] = p1;
				outbuf[wcnt++] = p2;
			}
			else
			{
				outbuf[wcnt++] = p1;
			}
			break;
d601 3
a603 2
	  register __a1 UBYTE *inbuf,
	  register __a2 UBYTE *outbuf)
d608 7
a614 1
	LONG rlen = strlen(inbuf);
d616 1
a616 1
	D("euc2seven/rlen = %ld", rlen);
d618 11
a628 38
	if (jcc->jcc_FirstByte)
	{
		pop(&p1, &jcc->jcc_FirstByte);
		goto SECONDBYTE_EUC_JIS;
	}
	if (jcc->jcc_HanKata[0])
	{
		pop(&p1, &(jcc->jcc_HanKata[0]));
		if (jcc->jcc_HanKata[1])
		{
			pop(&p2, &(jcc->jcc_HanKata[1]));
			if (jcc->jcc_HanKata[2])
			{
				pop(&p3, &(jcc->jcc_HanKata[2]));
				goto HANKATA_FORTHBYTE_EUC_JIS;
                        }
			goto HANKATA_THIRDBYTE_EUC_JIS;
                }
		goto HANKATA_SECONDBYTE_EUC_JIS;
	}

	while (rcnt < rlen)
	{
		p1 = inbuf[rcnt++];
		switch (p1)
		{
		    case NL:
			if (jcc->jcc_ShiftedIn)
			{
				jcc->jcc_ShiftedIn = FALSE;
				wcnt += LIBKanjiOut(jcc->jcc_WhatOutputCode, outbuf);
			}
			outbuf[wcnt++] = p1;
			break;
		    case FF:
			break;
		    default:
			if (IS_EUC_BYTE(p1))
d630 2
a631 1
				if (rcnt >= rlen)
d633 2
a634 2
					jcc->jcc_FirstByte = p1;
					break;
d636 13
a648 3
SECONDBYTE_EUC_JIS:
				p2 = inbuf[rcnt++];
				if (IS_EUC_BYTE(p2))
d650 2
a651 7
					p1 -= 0x80;
					p2 -= 0x80;
					if (!jcc->jcc_ShiftedIn)
					{
						jcc->jcc_ShiftedIn = TRUE;
						wcnt += LIBKanjiIn(jcc->jcc_WhatOutputCode, outbuf);
					}
d654 5
a658 5
				outbuf[wcnt++] = p2;
			}
			else if (p1 == 0x8e)	/* EUC half size 1st byte */
			{
				if (rcnt >= rlen)
d660 30
a689 2
					jcc->jcc_HanKata[0] = p1;
					break;
d691 1
a691 3
HANKATA_SECONDBYTE_EUC_JIS:
				p2 = inbuf[rcnt++];
				if (IS_HANKATA(p2))
a692 2
					LONG nigori = FALSE, maru = FALSE;

d695 14
a708 3
						jcc->jcc_HanKata[0] = p1;
						jcc->jcc_HanKata[1] = p2;
						break;
d710 3
a712 3
HANKATA_THIRDBYTE_EUC_JIS:
					p3 = inbuf[rcnt++];
					if (p3 == 0x8e)	/* EUC half size 1st byte */
d716 24
a739 4
							jcc->jcc_HanKata[0] = p1;
							jcc->jcc_HanKata[1] = p2;
							jcc->jcc_HanKata[2] = p3;
							break;
d741 32
d774 5
a778 6
						nigori = maru = FALSE;
                                        	p4 = inbuf[rcnt++];
						if (p4 == 0xde)	/* Next is dakuten ? */
						{
							/* Check it's possible for hankata to have dakuten. */
							if (IS_NIGORI(p1))
d780 17
d798 7
a804 4
						else if (IS_MARU(p1, p4))
							/* Next is maru ? */
							maru = TRUE;
						else	/* just HANKATA */
d806 2
a807 3
							rcnt--;
							p1 = p3;
							goto HANKATA_SECONDBYTE_EUC_JIS;
d810 5
a814 6
					else
						rcnt--;

					han2zen(&p1, &p2, nigori, maru);
					eight2seven(&p1, &p2);
					if (!jcc->jcc_ShiftedIn)
d816 2
a817 2
						jcc->jcc_ShiftedIn = TRUE;
						wcnt += LIBKanjiIn(jcc->jcc_WhatOutputCode, outbuf);
d819 1
d821 1
a821 13
				outbuf[wcnt++] = p1;
				outbuf[wcnt++] = p2;
			}
			else
			{
				if (jcc->jcc_ShiftedIn)
				{
					jcc->jcc_ShiftedIn = FALSE;
					wcnt += LIBKanjiOut(jcc->jcc_WhatOutputCode, outbuf);
				}
				outbuf[wcnt++] = p1;
			}
			break;
a823 1

d830 4
a833 2
	register __a1 UBYTE *inbuf,
	register __a2 UBYTE *outbuf)
d838 7
a844 1
	LONG rlen = strlen(inbuf);
d846 1
a846 1
	D("euc2euc/rlen = %ld", rlen);
d848 38
a885 32
	if (jcc->jcc_FirstByte)
	{
		pop(&p1, &jcc->jcc_FirstByte);
		goto SECONDBYTE_EUC_EUC;
	}
	if (jcc->jcc_HanKata[0])
	{
		pop(&p1, &(jcc->jcc_HanKata[0]));
		if (jcc->jcc_HanKata[1])
		{
			pop(&p2, &(jcc->jcc_HanKata[1]));
			if (jcc->jcc_HanKata[2])
			{
				pop(&p3, &(jcc->jcc_HanKata[2]));
				goto HANKATA_FORTHBYTE_EUC_EUC;
                        }
			goto HANKATA_THIRDBYTE_EUC_EUC;
                }
		goto HANKATA_SECONDBYTE_EUC_EUC;
	}

	while (rcnt < rlen)
	{
		p1 = inbuf[rcnt++];
		switch (p1)
		{
		    case FF:
			break;
		    default:
			if (IS_EUC_BYTE(p1))
			{
				if (rcnt >= rlen)
d887 10
a896 3
					jcc->jcc_FirstByte = p1;
					break;
				}
d898 5
a902 13
				p2 = inbuf[rcnt++];
				if (IS_EUC_BYTE(p2))
				{
					outbuf[wcnt++] = p1;
					outbuf[wcnt++] = p2;
				}
			}
			else if (p1 == 0x8e)	/* EUC half size 1st byte */
			{
				if (rcnt >= rlen)
				{
					jcc->jcc_HanKata[0] = p1;
					break;
d904 1
a904 3
HANKATA_SECONDBYTE_EUC_EUC:
				p2 = inbuf[rcnt++];
				if (IS_HANKATA(p2))
a905 2
					LONG nigori = FALSE, maru = FALSE;

d908 7
a914 3
						jcc->jcc_HanKata[0] = p1;
						jcc->jcc_HanKata[1] = p2;
						break;
d916 3
a918 3
HANKATA_THIRDBYTE_EUC_EUC:
					p3 = inbuf[rcnt++];
					if (p3 == 0x8e)	/* EUC half size 1st byte */
d922 14
a935 4
							jcc->jcc_HanKata[0] = p1;
							jcc->jcc_HanKata[1] = p2;
							jcc->jcc_HanKata[2] = p3;
							break;
d937 22
d960 5
a964 6
						nigori = maru = FALSE;
                                        	p4 = inbuf[rcnt++];
						if (p4 == 0xde)	/* Next is dakuten ? */
						{
							/* Check it's possible for hankata to have dakuten. */
							if (IS_NIGORI(p1))
d966 12
d979 1
a979 5
						else if (IS_MARU(p1, p4))
							/* Next is maru ? */
							maru = TRUE;
						else	/* just HANKATA */
						{
d981 6
a986 3
							p1 = p3;
							goto HANKATA_SECONDBYTE_EUC_EUC;
						}
d988 5
a992 7
					else
						rcnt--;

					han2zen(&p1, &p2, nigori, maru);
					eight2seven(&p1, &p2);
					p1 += 0x80;
					p2 += 0x80;
d994 1
a994 8
				outbuf[wcnt++] = p1;
				outbuf[wcnt++] = p2;
			}
			else
			{
				outbuf[wcnt++] = p1;
			}
			break;
d1003 4
a1006 2
	  register __a1 UBYTE *inbuf,
	  register __a2 UBYTE *outbuf)
d1011 7
a1017 1
	LONG rlen = strlen(inbuf);
d1019 1
a1019 1
	D("euc2shift/rlen = %ld", rlen);
d1021 38
a1058 32
	if (jcc->jcc_FirstByte)
	{
		pop(&p1, &jcc->jcc_FirstByte);
		goto SECONDBYTE_EUC_SJIS;
	}
	if (jcc->jcc_HanKata[0])
	{
		pop(&p1, &(jcc->jcc_HanKata[0]));
		if (jcc->jcc_HanKata[1])
		{
			pop(&p2, &(jcc->jcc_HanKata[1]));
			if (jcc->jcc_HanKata[2])
			{
				pop(&p3, &(jcc->jcc_HanKata[2]));
				goto HANKATA_FORTHBYTE_EUC_SJIS;
                        }
			goto HANKATA_THIRDBYTE_EUC_SJIS;
                }
		goto HANKATA_SECONDBYTE_EUC_SJIS;
	}

	while (rcnt < rlen)
	{
		p1 = inbuf[rcnt++];
		switch (p1)
		{
		    case FF:
			break;
		    default:
			if (IS_EUC_BYTE(p1))
			{
				if (rcnt >= rlen)
d1060 10
a1069 3
					jcc->jcc_FirstByte = p1;
					break;
				}
d1071 8
a1078 16
				p2 = inbuf[rcnt++];
				if (IS_EUC_BYTE(p2))
				{
					p1 -= 0x80;
					p2 -= 0x80;
                                        seven2eight(&p1, &p2);
				}
				outbuf[wcnt++] = p1;
				outbuf[wcnt++] = p2;
			}
			else if (p1 == 0x8e)	/* EUC half size 1st byte */
			{
				if (rcnt >= rlen)
				{
					jcc->jcc_HanKata[0] = p1;
					break;
d1080 1
a1080 3
HANKATA_SECONDBYTE_EUC_SJIS:
				p2 = inbuf[rcnt++];
				if (IS_HANKATA(p2))
a1081 2
					LONG nigori = FALSE, maru = FALSE;

d1084 7
a1090 3
						jcc->jcc_HanKata[0] = p1;
						jcc->jcc_HanKata[1] = p2;
						break;
d1092 3
a1094 3
HANKATA_THIRDBYTE_EUC_SJIS:
					p3 = inbuf[rcnt++];
					if (p3 == 0x8e)	/* EUC half size 1st byte */
d1098 13
a1110 4
							jcc->jcc_HanKata[0] = p1;
							jcc->jcc_HanKata[1] = p2;
							jcc->jcc_HanKata[2] = p3;
							break;
d1112 21
d1134 5
a1138 6
						nigori = maru = FALSE;
                                        	p4 = inbuf[rcnt++];
						if (p4 == 0xde)	/* Next is dakuten ? */
						{
							/* Check it's possible for hankata to have dakuten. */
							if (IS_NIGORI(p1))
d1140 11
d1152 1
a1152 5
						else if (IS_MARU(p1, p4))
							/* Next is maru ? */
							maru = TRUE;
						else	/* just HANKATA */
						{
d1154 3
a1156 3
							p1 = p3;
							goto HANKATA_SECONDBYTE_EUC_SJIS;
						}
d1158 5
a1162 4
					else
						rcnt--;

					han2zen(&p1, &p2, nigori, maru);
d1164 1
a1164 8
				outbuf[wcnt++] = p1;
				outbuf[wcnt++] = p2;
			}
			else
			{
				outbuf[wcnt++] = p1;
			}
			break;
d1173 3
a1175 2
	    register __a1 UBYTE *inbuf,
	    register __a2 UBYTE *outbuf)
d1178 34
a1211 38
	LONG rcnt = 0;
	LONG wcnt = 0;
	LONG rlen = strlen(inbuf);

	D("shift2seven/rlen = %ld", rlen);

	if (jcc->jcc_FirstByte)
	{
		pop(&p1, &jcc->jcc_FirstByte);
		goto SECONDBYTE_SJIS_JIS;
	}
	if (jcc->jcc_HanKata[0])
	{
		pop(&p1, &(jcc->jcc_HanKata[0]));
		goto HANKATA_SECONDBYTE_SJIS_JIS;
	}

	while (rcnt < rlen)
	{
		p1 = inbuf[rcnt++];
		switch (p1)
		{
		    case CR:
		    case NL:
			if (jcc->jcc_ShiftedIn)
			{
				jcc->jcc_ShiftedIn = FALSE;
				wcnt += LIBKanjiOut(jcc->jcc_WhatOutputCode, outbuf);
			}
			outbuf[wcnt++] = NL;
			break;
		    case NULL:
		    case FF:
			break;
		    default:
			if (IS_SJIS_BYTE1(p1))
			{
				if (rcnt >= rlen)
d1213 2
a1214 2
					jcc->jcc_FirstByte = p1;
					break;
d1216 25
d1242 13
a1254 2
				p2 = inbuf[rcnt++];
				if (IS_SJIS_BYTE2(p2))
d1256 40
d1300 1
a1300 1
						wcnt += LIBKanjiIn(jcc->jcc_WhatOutputCode, outbuf);
d1302 1
d1304 1
a1304 6
				outbuf[wcnt++] = p1;
				outbuf[wcnt++] = p2;
			}
			else if (IS_HANKATA(p1))
			{
				if (rcnt >= rlen)
d1306 6
a1311 2
					jcc->jcc_HanKata[0] = p1;
					break;
d1313 1
a1313 36
HANKATA_SECONDBYTE_SJIS_JIS:
				{
				LONG nigori = FALSE, maru = FALSE;
				p2 = inbuf[rcnt++];
				if (p2 == 0xde)	/* Next is dakuten ? */
				{
					/* Check it's possible for hankata to have dakuten. */
					if (IS_NIGORI(p1))
						nigori = TRUE;
				}
				else if (IS_MARU(p1, p2))
					/* Next is maru ? */
					maru = TRUE;
				else
					rcnt--;
				han2zen(&p1, &p2, nigori, maru);
				}
				eight2seven(&p1, &p2);
				if (!jcc->jcc_ShiftedIn)
				{
					jcc->jcc_ShiftedIn = TRUE;
					wcnt += LIBKanjiIn(jcc->jcc_WhatOutputCode, outbuf);
				}
				outbuf[wcnt++] = p1;
				outbuf[wcnt++] = p2;
			}
			else
			{
				if (jcc->jcc_ShiftedIn)
				{
					jcc->jcc_ShiftedIn = FALSE;
					wcnt += LIBKanjiOut(jcc->jcc_WhatOutputCode, outbuf);
				}
				outbuf[wcnt++] = p1;
			}
			break;
a1315 1

d1322 55
a1376 37
	  register __a1 UBYTE *inbuf,
	  register __a2 UBYTE *outbuf)
{
	LONG p1, p2;
	LONG rcnt = 0;
	LONG wcnt = 0;
	LONG rlen = strlen(inbuf);

	D("shift2euc/rlen = %ld", rlen);

	if (jcc->jcc_FirstByte)
	{
		pop(&p1, &jcc->jcc_FirstByte);
		goto SECONDBYTE_SJIS_EUC;
	}
	if (jcc->jcc_HanKata[0])
	{
		pop(&p1, &(jcc->jcc_HanKata[0]));
		goto HANKATA_SECONDBYTE_SJIS_EUC;
	}

	while (rcnt < rlen)
	{
		p1 = inbuf[rcnt++];
		switch (p1)
		{
		    case CR:
		    case NL:
			outbuf[wcnt++] = NL;
			break;
		    case NULL:
		    case FF:
			break;
		    default:
			if (IS_SJIS_BYTE1(p1))
			{
				if (rcnt >= rlen)
d1378 10
a1387 3
					jcc->jcc_FirstByte = p1;
					break;
				}
d1389 6
a1394 6
				p2 = inbuf[rcnt++];
				if (IS_SJIS_BYTE2(p2))
				{
					eight2seven(&p1, &p2);
					p1 += 0x80;
					p2 += 0x80;
d1396 1
a1396 6
				outbuf[wcnt++] = p1;
				outbuf[wcnt++] = p2;
			}
			else if (IS_HANKATA(p1))
			{
				if (rcnt >= rlen)
d1398 45
a1442 2
					jcc->jcc_HanKata[0] = p1;
					break;
d1444 1
a1444 1
HANKATA_SECONDBYTE_SJIS_EUC:
d1446 1
a1446 14
				LONG nigori = FALSE, maru = FALSE;
				p2 = inbuf[rcnt++];
				if (p2 == 0xde)	/* Next is dakuten ? */
				{
					/* Check it's possible for hankata to have dakuten. */
					if (IS_NIGORI(p1))
						nigori = TRUE;
				}
				else if (IS_MARU(p1, p2))
					/* Next is maru ? */
					maru = TRUE;
				else
					rcnt--;
				han2zen(&p1, &p2, nigori, maru);
d1448 1
a1448 11
				eight2seven(&p1, &p2);
				p1 += 0x80;
				p2 += 0x80;
				outbuf[wcnt++] = p1;
				outbuf[wcnt++] = p2;
			}
			else
			{
				outbuf[wcnt++] = p1;
			}
			break;
d1457 54
a1510 37
	    register __a1 UBYTE *inbuf,
	    register __a2 UBYTE *outbuf)
{
	LONG p1, p2;
	LONG rcnt = 0;
	LONG wcnt = 0;
	LONG rlen = strlen(inbuf);

	D("shift2shift/rlen = %ld", rlen);

	if (jcc->jcc_FirstByte)
	{
		pop(&p1, &jcc->jcc_FirstByte);
		goto SECONDBYTE_SJIS_SJIS;
	}
	if (jcc->jcc_HanKata[0])
	{
		pop(&p1, &(jcc->jcc_HanKata[0]));
		goto HANKATA_SECONDBYTE_SJIS_SJIS;
	}

	while (rcnt < rlen)
	{
		p1 = inbuf[rcnt++];
		switch (p1)
		{
		    case CR:
		    case NL:
			outbuf[wcnt++] = NL;
			break;
		    case NULL:
		    case FF:
			break;
		    default:
			if (IS_SJIS_BYTE1(p1))
			{
				if (rcnt >= rlen)
d1512 10
a1521 3
					jcc->jcc_FirstByte = p1;
					break;
				}
d1523 5
a1527 5
				p2 = inbuf[rcnt++];
				if (IS_SJIS_BYTE2(p2))
				{
					outbuf[wcnt++] = p1;
					outbuf[wcnt++] = p2;
d1529 1
a1529 4
			}
			else if (IS_HANKATA(p1))
			{
				if (rcnt >= rlen)
d1531 43
a1573 2
					jcc->jcc_HanKata[0] = p1;
					break;
d1575 1
a1575 1
HANKATA_SECONDBYTE_SJIS_SJIS:
d1577 1
a1577 14
				LONG nigori = FALSE, maru = FALSE;
				p2 = inbuf[rcnt++];
				if (p2 == 0xde)	/* Next is dakuten ? */
				{
					/* Check it's possible for hankata to have dakuten. */
					if (IS_NIGORI(p1))
						nigori = TRUE;
				}
				else if (IS_MARU(p1, p2))
					/* Next is maru ? */
					maru = TRUE;
				else
					rcnt--;
				han2zen(&p1, &p2, nigori, maru);
d1579 1
a1579 8
				outbuf[wcnt++] = p1;
				outbuf[wcnt++] = p2;
			}
			else
			{
				outbuf[wcnt++] = p1;
			}
			break;
d1586 29
a1614 8
LIBJStringConvert(register __a0 struct JConversionCodeSet *jcc,
		  register __a1 UBYTE *inbuf,
		  register __a2 UBYTE *outbuf,
		  register __d0 LONG incode,
		  register __d1 LONG outcode/*,
		  register __d2 LONG length*/)
{
	LONG wcnt;
d1621 67
a1687 57
	    case CTYPE_NEWJIS:
	    case CTYPE_OLDJIS:
	    case CTYPE_NECJIS:
		switch(outcode)
		{
		    case CTYPE_NEWJIS:
		    case CTYPE_OLDJIS:
		    case CTYPE_NECJIS:
			wcnt = seven2seven(jcc, inbuf, outbuf);
			break;
		    case CTYPE_EUC:
			wcnt = seven2euc(jcc, inbuf, outbuf);
			break;
		    case CTYPE_SJIS:
			wcnt = seven2shift(jcc, inbuf, outbuf);
			break;
		    deault:
			break;
		}
		break;
	    case CTYPE_EUC:
		switch(outcode)
		{
		    case CTYPE_NEWJIS:
		    case CTYPE_OLDJIS:
		    case CTYPE_NECJIS:
			wcnt = euc2seven(jcc, inbuf, outbuf);
			break;
		    case CTYPE_EUC:
			wcnt = euc2euc(jcc, inbuf, outbuf);
                    	break;
		    case CTYPE_SJIS:
			wcnt = euc2shift(jcc, inbuf, outbuf);
			break;
		    default:
		    	break;
		}
		break;
	    case CTYPE_SJIS:
		switch(outcode)
		{
		    case CTYPE_NEWJIS:
		    case CTYPE_OLDJIS:
		    case CTYPE_NECJIS:
			wcnt = shift2seven(jcc, inbuf, outbuf);
			break;
		    case CTYPE_EUC:
			wcnt = shift2euc(jcc, inbuf, outbuf);
                    	break;
		    case CTYPE_SJIS:
			wcnt = shift2shift(jcc, inbuf, outbuf);
			break;
		    default:
		    	break;
		}
	    default:
	    	break;
@


1.1
log
@Initial revision
@
text
@d436 1
a436 1
	LONG p1, p2, p3;
d486 3
a488 1
				p3 = inbuf[rcnt++];	/* junk */
d541 1
a541 1
	LONG p1, p2, p3;
d592 3
a594 1
				p3 = inbuf[rcnt++];	/* junk */
d641 1
a641 1
	LONG p1, p2, p3;
d692 3
a694 1
				p3 = inbuf[rcnt++];	/* junk */
@
