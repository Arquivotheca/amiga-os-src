head     39.7;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


39.7
date     92.08.13.16.46.32;  author vertex;  state Exp;
branches ;
next     39.6;

39.6
date     92.07.31.16.45.23;  author vertex;  state Exp;
branches ;
next     39.5;

39.5
date     92.07.08.20.52.21;  author vertex;  state Exp;
branches ;
next     39.4;

39.4
date     92.06.26.18.05.49;  author vertex;  state Exp;
branches ;
next     39.3;

39.3
date     92.06.22.17.25.51;  author vertex;  state Exp;
branches ;
next     39.2;

39.2
date     92.06.22.16.49.43;  author vertex;  state Exp;
branches ;
next     39.1;

39.1
date     92.06.22.16.17.21;  author vertex;  state Exp;
branches ;
next     38.22;

38.22
date     92.03.24.17.58.13;  author vertex;  state Exp;
branches ;
next     38.21;

38.21
date     92.03.17.15.26.22;  author vertex;  state Exp;
branches ;
next     38.20;

38.20
date     92.02.24.16.20.27;  author vertex;  state Exp;
branches ;
next     38.19;

38.19
date     92.02.10.10.45.16;  author vertex;  state Exp;
branches ;
next     38.18;

38.18
date     91.11.24.17.56.51;  author vertex;  state Exp;
branches ;
next     38.17;

38.17
date     91.11.13.09.57.28;  author vertex;  state Exp;
branches ;
next     38.16;

38.16
date     91.11.11.14.04.46;  author vertex;  state Exp;
branches ;
next     38.15;

38.15
date     91.11.11.13.49.54;  author vertex;  state Exp;
branches ;
next     38.14;

38.14
date     91.11.08.09.48.56;  author vertex;  state Exp;
branches ;
next     38.13;

38.13
date     91.11.07.13.14.05;  author vertex;  state Exp;
branches ;
next     38.12;

38.12
date     91.10.11.17.16.56;  author vertex;  state Exp;
branches ;
next     38.11;

38.11
date     91.09.20.11.08.19;  author vertex;  state Exp;
branches ;
next     38.10;

38.10
date     91.08.28.12.05.47;  author vertex;  state Exp;
branches ;
next     38.9;

38.9
date     91.08.27.11.15.05;  author vertex;  state Exp;
branches ;
next     38.8;

38.8
date     91.08.27.11.09.40;  author vertex;  state Exp;
branches ;
next     38.7;

38.7
date     91.08.20.10.07.57;  author vertex;  state Exp;
branches ;
next     38.6;

38.6
date     91.08.12.13.17.32;  author vertex;  state Exp;
branches ;
next     38.5;

38.5
date     91.08.06.17.11.49;  author vertex;  state Exp;
branches ;
next     38.4;

38.4
date     91.08.06.17.04.30;  author vertex;  state Exp;
branches ;
next     38.3;

38.3
date     91.07.15.10.57.06;  author vertex;  state Exp;
branches ;
next     38.2;

38.2
date     91.07.10.17.31.11;  author vertex;  state Exp;
branches ;
next     38.1;

38.1
date     91.07.10.10.08.07;  author vertex;  state Exp;
branches ;
next     ;


desc
@Prefs editor shell - Palette custom interface
@


39.7
log
@Adjusted presets to be nicer
@
text
@
/* includes */
#include <exec/types.h>
#include <exec/libraries.h>
#include <exec/ports.h>
#include <exec/memory.h>
#include <exec/execbase.h>
#include <intuition/intuition.h>
#include <intuition/screens.h>
#include <intuition/gadgetclass.h>
#include <intuition/icclass.h>
#include <graphics/text.h>
#include <graphics/displayinfo.h>
#include <graphics/view.h>
#include <libraries/gadtools.h>
#include <libraries/locale.h>
#include <dos/dos.h>
#include <gadgets/colorwheel.h>
#include <gadgets/gradientslider.h>
#include <string.h>

/* prototypes */
#include <clib/exec_protos.h>
#include <clib/iffparse_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/intuition_protos.h>
#include <clib/graphics_protos.h>
#include <clib/alib_protos.h>
#include <clib/utility_protos.h>
#include <clib/dos_protos.h>

/* direct ROM interface */
#include <pragmas/exec_pragmas.h>
#include <pragmas/iffparse_pragmas.h>
#include <pragmas/gadtools_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/utility_pragmas.h>
#include <pragmas/dos_pragmas.h>

/* application includes */
#include "pe_custom.h"
#include "pe_strings.h"
#include "pe_utils.h"
#include "sample.h"
#include "extent.h"
#include "pe_iff.h"


#define SysBase ed->ed_SysBase


/*****************************************************************************/


struct LoadRGBTable
{
    UWORD NumColors;
    UWORD FirstColor;
    ULONG Red;
    ULONG Green;
    ULONG Blue;
};


/*****************************************************************************/


#define Make32(sixteen) ((((ULONG)sixteen)<<16) | (ULONG)sixteen)
ULONG Make16(ULONG value, ULONG bits);
static VOID __asm PenCallBack(register __a0 struct Hook *hook, register __a1 struct LVDrawMsg *msg, register __a2 struct Node *node);


/*****************************************************************************/


/* ILBM Color register structure */
struct ColorRegister
{
    UBYTE red, green, blue;
};

#define	ID_ILBM	MAKE_ID('I','L','B','M')
#define	ID_CMAP	MAKE_ID('C','M','A','P')


/*****************************************************************************/


UBYTE far NodeMap[] =
{
    BACKGROUNDPEN,
    TEXTPEN,
    HIGHLIGHTTEXTPEN,
    SHINEPEN,
    SHADOWPEN,
    FILLPEN,
    FILLTEXTPEN,
    BARBLOCKPEN,
    BARDETAILPEN
};

UBYTE far DefaultPens[] =
{
    0,	/* DETAILPEN		 */
    1,	/* BLOCKPEN		 */
    1,	/* TEXTPEN		 */
    2,	/* SHINEPEN		 */
    1,	/* SHADOWPEN		 */
    3,	/* FILLPEN		 */
    1,	/* FILLTEXTPEN		 */
    0,	/* BACKGROUNDPEN	 */
    2,	/* HIGHLIGHTTEXTPEN 	 */
    1,	/* BARDETAILPEN	 	 */
    2,	/* BARBLOCKPEN	 	 */
    1	/* BARTRIMPEN	 	 */
};

UWORD far DefaultColors[] =
{
    0x0AAA,	/*  Color 0 (gray) */
    0x0000,	/*  Color 1 (black) */
    0x0FFF,	/*  Color 2 (white) */
    0x068B,	/*  Color 3 (baby-blue) */
    0x0E44,
    0x05D5,
    0x004D,
    0x0E90
};


/*****************************************************************************/


struct Preset
{
    ULONG Colors[8];  /* 8 bits for red/green/blue each per longword */
};


struct Preset far Presets[] =
{
    /* Tint */
    {
        0x00BBAA99,  /* beige */
        0x00000022,
        0x00FFFFFF,
        0x006688BB,  /* blue */
        0x00EE4444,
        0x0055DD55,
        0x000044DD,
        0x00EE9900
    },

    /* Pharaoh */
    {
        0x0088AACC,     /* blue-gray */
        0x00000022,
        0x00FFFFFF,
        0x00FFCC99,     /* gold */
        0x000000F0,
        0x00F92121,
        0x0052F276,
        0x00DFA526
    },

    /* Sunset */
    {
        0x0088AACC, /* blue-gray */
        0x00000022,
        0x00FFFFFF,
        0x00EE9977, /* orange */
        0x00D9FF09,
        0x00F02D31,
        0x0038F238,
        0x004449F0
    },

    /* Ocean */
    {
        0x0055BBAA, /* ocean green */
        0x00000022,
        0x00EEEEFF,
        0x005577AA, /* ocean blue */
        0x00F6F600,
        0x006251F0,
        0x0000F000,
        0x00F03010
    },

    /* Steel */
    {
        0x0099BBDD, /* blue-gray */
        0x00000022,
        0x00FFFFFF,
        0x006688BB,
        0x00B2DEFF,
        0x00FFA11C,
        0x00F04487,
        0x00BFFF90
    },

    /* Chocolate */
    {
        0x00AA9988, /* med-brown */
        0x00332211,
        0x00FFEEEE,
        0x00FFDDBB, /* tan-gold */
        0x00EE4444,
        0x0055DD55,
        0x00CFDBFF,
        0x000044DD
    },

    /* Pewter */
    {
        0x00CCCCBB,
        0x00000033,
        0x00FFFFFF,
        0x0099AABB, /* gray */
        0x00EE4444,
        0x0055DD55,
        0x00E0F088,
        0x000044DD
    },

    /* Wine */
    {
        0x00CC9999,
        0x00000022,
        0x00FFEEEE,
        0x00BB6677,
        0x00E0F088,
        0x007946E8,
        0x0060C752,
        0x0089EAC8
    },

    /* A2024 */
    {
        0x0A09060, /* Hedley light-gray (brown) */
        0x0000020, /* Hedley black */
        0x0F0F0F0, /* Hedley white */
        0x0707090, /* Hedley dark-gray (blue) */
	0x0F0C0C0,
	0x0B08010,
	0x030D030,
	0x0F03010
    }
};

VOID SetColors(EdDataPtr ed);


/*****************************************************************************/


#define IFFPrefChunkCnt 3
static LONG far IFFPrefChunks[] =
{
    ID_PREF, ID_PRHD,
    ID_PREF, ID_PALT,
    ID_ILBM, ID_CMAP
};


/*****************************************************************************/


static struct PrefHeader far IFFPrefHeader =
{
    0,   /* version */
    0,   /* type    */
    0    /* flags   */
};


/*****************************************************************************/


EdStatus InitEdData(EdDataPtr ed)
{
UWORD    i;
EdStatus result;

    result = ES_NO_COLORWHEEL;
    if (ed->ed_ColorWheelBase = OpenLibrary("gadgets/colorwheel.gadget",39))
    {
        result = ES_NO_GRADIENT;
        if (ed->ed_GradientSliderBase = OpenLibrary("gadgets/gradientslider.gadget",39))
        {
            result = ES_NO_MEMORY;
            if (ed->ed_WBScreen = LockPubScreen("Workbench"))
            {
                for (i = 0; i < MAXCOLORS; i++)
                {
                    ed->ed_PrefsDefaults.pap_Colors[i].ColorIndex = i;
                    ed->ed_PrefsDefaults.pap_Colors[i].Red        = Make16((DefaultColors[i] / 256) % 16,4);
                    ed->ed_PrefsDefaults.pap_Colors[i].Green      = Make16((DefaultColors[i] / 16) % 16,4);
                    ed->ed_PrefsDefaults.pap_Colors[i].Blue       = Make16(DefaultColors[i] % 16,4);
                }
                ed->ed_PrefsDefaults.pap_Colors[MAXCOLORS].ColorIndex = -1;

                for (i = 0; i < NUM_KNOWNPENS; i++)
                {
                    ed->ed_PrefsDefaults.pap_4ColorPens[i] = DefaultPens[i];
                    ed->ed_PrefsDefaults.pap_8ColorPens[i] = DefaultPens[i];
                }
                ed->ed_PrefsDefaults.pap_4ColorPens[NUM_KNOWNPENS] = ~0;
                ed->ed_PrefsDefaults.pap_8ColorPens[NUM_KNOWNPENS] = ~0;

                ed->ed_PrefsWork    = ed->ed_PrefsDefaults;
                ed->ed_PrefsInitial = ed->ed_PrefsDefaults;

                ed->ed_PenCallBack.h_Entry = (APTR)PenCallBack;
                ed->ed_PenCallBack.h_Data  = ed;

                ed->ed_SlidersRGB = TRUE;

                return(ES_NORMAL);
            }
            CloseLibrary(ed->ed_GradientSliderBase);
        }
        CloseLibrary(ed->ed_ColorWheelBase);
    }

    return(result);
}


/*****************************************************************************/


VOID CleanUpEdData(EdDataPtr ed)
{
    if (ed->ed_Cancelled)
    {
        ed->ed_PrefsWork = ed->ed_PrefsInitial;
        SetColors(ed);
    }

    UnlockPubScreen(NULL,ed->ed_WBScreen);
    CloseLibrary(ed->ed_ColorWheelBase);
    CloseLibrary(ed->ed_GradientSliderBase);
}


/*****************************************************************************/


/* any reference to colors 4-7 must be changed to PEN_C3 to PEN_C0 */
VOID MapUp(EdDataPtr ed)
{
UWORD i;

    for (i = 0; i < NUM_KNOWNPENS; i++)
    {
        if (ed->ed_PrefsWork.pap_8ColorPens[i] >= 4)
            ed->ed_PrefsWork.pap_8ColorPens[i] += PEN_C3 - 4;
    }
}


/* any reference to PEN_C3 to PEN_C0 must be changed to colors 4-7 */
VOID MapDown(EdDataPtr ed)
{
UWORD i;

    for (i = 0; i < NUM_KNOWNPENS; i++)
    {
        if (ed->ed_PrefsWork.pap_8ColorPens[i] >= PEN_C3)
            ed->ed_PrefsWork.pap_8ColorPens[i] -= PEN_C3 - 4;
    }
}


/*****************************************************************************/


EdStatus ReadPrefs(EdDataPtr ed, struct IFFHandle *iff, struct ContextNode *cn)
{
struct ColorRegister creg;
LONG                 error;
UWORD                i;

    if (cn->cn_ID == ID_PALT && cn->cn_Type == ID_PREF)
    {
        if (ReadChunkBytes(iff,&ed->ed_PrefsWork,sizeof(struct PalettePrefs)) == sizeof(struct PalettePrefs))
        {
            MapDown(ed);
            return(ES_NORMAL);
        }
        return(ES_IFFERROR);
    }
    else if (cn->cn_ID == ID_CMAP || cn->cn_Type == ID_ILBM)
    {
        i = 0;
        while ((i < MAXCOLORS) && ((error = ReadChunkBytes(iff,&creg,sizeof(struct ColorRegister))) == sizeof(struct ColorRegister)))
        {
            ed->ed_PrefsWork.pap_Colors[i].Red   = Make32(Make16(creg.red,8));
            ed->ed_PrefsWork.pap_Colors[i].Green = Make32(Make16(creg.green,8));
            ed->ed_PrefsWork.pap_Colors[i].Blue  = Make32(Make16(creg.blue,8));
            i++;
        }

        if (error < 0)
            return(ES_IFFERROR);

        return(ES_NORMAL);
    }

    return(ES_IFF_UNKNOWNCHUNK);
}


EdStatus OpenPrefs(EdDataPtr ed, STRPTR name)
{
    return(ReadIFF(ed,name,IFFPrefChunks,IFFPrefChunkCnt,ReadPrefs));
}


/*****************************************************************************/


EdStatus WritePrefs(EdDataPtr ed, struct IFFHandle *iff, struct ContextNode *cn)
{
    MapUp(ed);

    if (!PushChunk(iff,0,ID_PALT,sizeof(struct PalettePrefs)))
    {
        if (WriteChunkBytes(iff,&ed->ed_PrefsWork,sizeof(struct PalettePrefs)) == sizeof(struct PalettePrefs))
        {
            if (!PopChunk(iff))
            {
                MapDown(ed);
                return(ES_NORMAL);
            }
        }
    }

    MapDown(ed);

    return(ES_IFFERROR);
}


EdStatus SavePrefs(EdDataPtr ed, STRPTR name)
{
    ed->ed_PrefsWork.pap_4ColorPens[BARTRIMPEN] = ed->ed_PrefsWork.pap_4ColorPens[BARDETAILPEN];
    ed->ed_PrefsWork.pap_8ColorPens[BARTRIMPEN] = ed->ed_PrefsWork.pap_8ColorPens[BARDETAILPEN];

    return(WriteIFF(ed,name,&IFFPrefHeader,WritePrefs));
}


/*****************************************************************************/


VOID SetGadgetAttrsP(EdDataPtr ed, struct Gadget * gad, ULONG tags,...)
{
    SetGadgetAttrsA(gad,ed->ed_Window,NULL,(struct TagItem *)&tags);
}


/*****************************************************************************/


VOID DrawBB(EdDataPtr ed, WORD left, WORD top, WORD width, WORD height, ULONG tags, ...)
{
    DrawBevelBoxA(window->RPort,left + window->BorderRight, top + window->BorderTop,
                                 width,height,(struct TagItem *)&tags);
}


/*****************************************************************************/


struct Screen *OpenPrefsScreen(EdDataPtr ed, ULONG tag1,...)
{
    return (OpenScreenTagList(NULL, (struct TagItem *)&tag1));
}


/*****************************************************************************/


#define NW_WIDTH     616
#define NW_HEIGHT    184
#define	NW_IDCMP     (IDCMP_IDCMPUPDATE | IDCMP_MOUSEBUTTONS | IDCMP_MENUPICK | IDCMP_REFRESHWINDOW | IDCMP_INTUITICKS | BUTTONIDCMP | SLIDERIDCMP | LISTVIEWIDCMP)
#define	NW_FLAGS     (WFLG_ACTIVATE | WFLG_DEPTHGADGET | WFLG_DRAGBAR | WFLG_SIMPLE_REFRESH)
#define NW_MINWIDTH  NW_WIDTH
#define NW_MINHEIGHT NW_HEIGHT
#define NW_MAXWIDTH  NW_WIDTH
#define NW_MAXHEIGHT NW_HEIGHT
#define ZOOMWIDTH    200

struct EdMenu far EM[] = {
    {NM_TITLE,  MSG_PROJECT_MENU,           EC_NOP,       0},
      {NM_ITEM, MSG_PROJECT_OPEN,           EC_OPEN,      0},
      {NM_ITEM, MSG_PROJECT_SAVE_AS,        EC_SAVEAS,    0},
      {NM_ITEM, MSG_NOTHING,                EC_NOP,       0},
      {NM_ITEM, MSG_PROJECT_QUIT,           EC_CANCEL,    0},

    {NM_TITLE,  MSG_EDIT_MENU,              EC_NOP,       0},
      {NM_ITEM, MSG_EDIT_RESET_TO_DEFAULTS, EC_RESETALL,  0},
      {NM_ITEM, MSG_EDIT_LAST_SAVED,        EC_LASTSAVED, 0},
      {NM_ITEM, MSG_EDIT_RESTORE,           EC_RESTORE,   0},
      {NM_ITEM, MSG_PAL_EDIT_PRESETS,	    EC_PRESET1,   0},
        {NM_SUB,MSG_PAL_EDIT_PRESET1,	    EC_PRESET1,   0},
        {NM_SUB,MSG_PAL_EDIT_PRESET2,	    EC_PRESET2,   0},
        {NM_SUB,MSG_PAL_EDIT_PRESET3,	    EC_PRESET3,   0},
        {NM_SUB,MSG_PAL_EDIT_PRESET4,	    EC_PRESET4,   0},
        {NM_SUB,MSG_PAL_EDIT_PRESET5,	    EC_PRESET5,   0},
        {NM_SUB,MSG_PAL_EDIT_PRESET6,	    EC_PRESET6,   0},
        {NM_SUB,MSG_PAL_EDIT_PRESET7,	    EC_PRESET7,   0},
        {NM_SUB,MSG_PAL_EDIT_PRESET8,	    EC_PRESET8,   0},
        {NM_SUB,MSG_NOTHING,                EC_NOP,       0},
        {NM_SUB,MSG_PAL_EDIT_PRESET9,	    EC_PRESET9,   0},   /* A2024 preset */

    {NM_TITLE,  MSG_OPTIONS_MENU,           EC_NOP,       0},
      {NM_ITEM, MSG_OPTIONS_SAVE_ICONS,     EC_SAVEICONS, CHECKIT|MENUTOGGLE},
      {NM_ITEM, MSG_PAL_OPTIONS_COLORMODEL, EC_RGBMODEL,  0},
        {NM_SUB,MSG_PAL_OPTIONS_RGB,	    EC_RGBMODEL,  CHECKIT|MENUTOGGLE},
        {NM_SUB,MSG_PAL_OPTIONS_HSB,	    EC_HSBMODEL,  CHECKIT|MENUTOGGLE},

    {NM_END,    MSG_NOTHING,                EC_NOP, 0}
};

#define A2024_ITEM      19
#define COLORMODEL_ITEM 22

/* main display gadgets */
struct EdGadget far EG[] = {
    {BUTTON_KIND,   8,    168,  87,  14, MSG_SAVE_GAD,         EC_SAVE,         0},
    {BUTTON_KIND,   264,  168,  87,  14, MSG_USE_GAD,          EC_USE,          0},
    {BUTTON_KIND,   521,  168,  87,  14, MSG_CANCEL_GAD,       EC_CANCEL,       0},

    {BUTTON_KIND,   315,  145,  293, 14, MSG_PAL_SHOW_SAMPLE,  EC_SHOWSAMPLE,   0},

    {PALETTE_KIND,  15,   6,    288, 20, MSG_NOTHING,          EC_COLORPALETTE, 0},
    {SLIDER_KIND,   145,  121,  157, 11, MSG_NOTHING,          EC_SLIDER1,      0},
    {SLIDER_KIND,   145,  133,  157, 11, MSG_NOTHING,          EC_SLIDER2,      0},
    {SLIDER_KIND,   145,  145,  157, 11, MSG_NOTHING,          EC_SLIDER3,      0},

    {LISTVIEW_KIND, 315,  21,  293, 116,  MSG_NOTHING,          EC_PENS,         0},
    {PALETTE_KIND,  315,  133, 293,  20,  MSG_NOTHING,          EC_PENPALETTE,   0},

    {CYCLE_KIND,    315,  3,   293,  14, MSG_NOTHING,          EC_COLORMODE,    0},
};


/*****************************************************************************/


ULONG CheckBitRange(EdDataPtr ed, UBYTE bit)
{
    if (bit > HIGHBITSPERGUN)
        bit = HIGHBITSPERGUN;

    if (bit < LOWBITSPERGUN)
        bit = LOWBITSPERGUN;
/*
    if (bit < HIGHBITSPERGUN)
        bit = LOWBITSPERGUN;
*/
    return((ULONG)bit);
}


/*****************************************************************************/


BOOL GetScreen(EdDataPtr ed, UWORD editDepth, UWORD scrWidth, UWORD scrHeight)
{
UWORD                i;
BOOL                 ok;
struct DimensionInfo dimInfo;
ULONG                wbmode;
BOOL                 usewb;
UWORD                scrDepth;
UWORD                numAllocated;
UWORD                maxColors;

    ed->ed_Screen = ed->ed_WBScreen;

    if (editDepth == 1)
    {
        ed->ed_ColorTable[0] = 0;
        ed->ed_ColorTable[1] = 1;
    }
    else
    {
        ok    = TRUE;
        usewb = TRUE;

        /* allocate the exclusive colors we need for editing on the WB */
        for (i = 0; i < 8; i++)
        {
            ed->ed_ColorTable[i] = ObtainPen(ed->ed_WBScreen->ViewPort.ColorMap,-1,
                                             0,0,0,PEN_NO_SETCOLOR|PEN_EXCLUSIVE);
            if (ed->ed_ColorTable[i] == -1)
            {
                /* not enough pens on the WB screen for our needs */
                ok = FALSE;
                break;
            }
        }
        numAllocated = i;

        /* see what we could get out of a custom screen in the same mode */
        wbmode = GetVPModeID(&ed->ed_WBScreen->ViewPort);
        GetDisplayInfoData(NULL,(APTR)&dimInfo,sizeof(struct DimensionInfo),DTAG_DIMS,wbmode);
        scrDepth = dimInfo.MaxDepth;

        if (!ok || (ed->ed_WBScreen->BitMap.Depth < 5))
        {
            /* There are not enough pens on the WB to allow color editing,
             * or the WB screen has less than 32 colors, which means the
             * wheel would not look so hot.
             *
             * Let's figure out if we can do better by opening a custom
             * screen.
             */

            maxColors = (1 << scrDepth);

            if (maxColors >= numAllocated + 8)     /* 8 being the maximum number of pens used by the UI */
                usewb = FALSE;    /* more pens available on a separate screen than on WB, so use a separate screen */

            if (usewb && !ok)
            {
                /* So here we know we don't have enough WB pens, but we
                 * also know we can't get more pens on a custom screen...
                 * Sheshh, life is tough.
                 *
                 * The solution to this problem is to simply fall back
                 * and use the UI pens for color editing. Note that if
                 * we did get some pens allocated, use those for the lower
                 * colors (background and text) since these are the most
                 * likely colors to be edited by the user. Free all other
                 * colors we might have gotten, so that the color wheel,
                 * and the gradient slider have something to play with.
                 */

                 while (numAllocated > 2)
                 {
                     numAllocated--;
                     ReleasePen(ed->ed_WBScreen->ViewPort.ColorMap,ed->ed_ColorTable[numAllocated]);
                 }

                 i = numAllocated;
                 while (i < 8)
                 {
                     if (i < 4)
                         ed->ed_ColorTable[i] = i;
                     else
                         ed->ed_ColorTable[i] = i + (1 << ed->ed_Screen->BitMap.Depth) - 8;
                     i++;
                 }
            }
            else if (!usewb)
            {
                /* Now we've decided to open on a custom screen */

                /* release all pens on the WB since we ain't using 'em */
                while (numAllocated > 0)
                {
                    numAllocated--;
                    ReleasePen(ed->ed_WBScreen->ViewPort.ColorMap,ed->ed_ColorTable[numAllocated]);
                }

                while ((1<<scrDepth) > 8 + 8 + MAXWHEELPENS + 16)
                    scrDepth--;

                if (scrDepth < dimInfo.MaxDepth)
                    scrDepth++;

                if (ed->ed_Screen = OpenPrefsScreen(ed,
                                              SA_LikeWorkbench, TRUE,
                                              SA_Title,         GetString(&ed->ed_LocaleInfo,MSG_PREFS_NAME),
                                              SA_Width,         scrWidth,
                                              SA_Height,        scrHeight,
                                              SA_Depth,         scrDepth,
                                              SA_FullPalette,   TRUE,
                                              SA_Interleaved,   TRUE,
                                              SA_DisplayID,     wbmode,
                                              SA_PubName,       "PALETTE",
                                              SA_PubTask,       FindTask(NULL),
                                              SA_PubSig,        SIGBREAKB_CTRL_E,
                                              TAG_DONE))
                {
                    PubScreenStatus(ed->ed_Screen,0);

                    /* allocate the editing pens on the custom screen */
                    for (i = 0; i < 8; i++)
                    {
                        ed->ed_ColorTable[i] = ObtainPen(ed->ed_Screen->ViewPort.ColorMap,-1,0,0,0,PEN_EXCLUSIVE | PEN_NO_SETCOLOR);
                        numAllocated++;
                    }
                }
                else
                {
                    return(FALSE);
                }
            }
        }
        ed->ed_NumColorsAllocated = numAllocated;
    }

    return(TRUE);
}


/*****************************************************************************/


BOOL InitDisp(EdDataPtr ed)
{
UWORD height, depth;

    depth = ed->ed_WBScreen->BitMap.Depth;
    if (depth > MAXDEPTH)
        depth = MAXDEPTH;

    ed->ed_Depth = depth;
    ed->ed_4ColorMode = (depth == 2);

    if (depth == 1)
    {
        height = 92;
    }
    else
    {
        height = NW_HEIGHT;
        if (ed->ed_WBScreen->Height - ed->ed_WBScreen->WBorTop - ed->ed_WBScreen->Font->ta_YSize - 1 >= NW_HEIGHT + 95)
        {
            ed->ed_EmbeddedSample = TRUE;
            height += 95;
        }
    }

    if (GetScreen(ed,depth,NW_WIDTH + ed->ed_WBScreen->WBorLeft + ed->ed_WBScreen->WBorRight,
                           height + ed->ed_WBScreen->WBorTop + ed->ed_WBScreen->Font->ta_YSize + 1
                           + ed->ed_WBScreen->BarHeight + 3))
    {
        return(TRUE);
    }

    return(FALSE);
}


/*****************************************************************************/


BOOL CreateDisplay(EdDataPtr ed)
{
UWORD              zoomSize[4];
ULONG              id;
UWORD		   depth;
struct DisplayInfo di;
struct EdMenu      stash[sizeof(EM)/sizeof(struct EdMenu)];
UWORD              i;
UWORD              height;
UWORD              width;
UWORD              wsize;
UWORD              left;
struct MenuItem   *item1;
struct MenuItem   *item2;

    zoomSize[0] = -1;
    zoomSize[1] = -1;
    zoomSize[2] = ZOOMWIDTH;
    zoomSize[3] = ed->ed_Screen->WBorTop + ed->ed_Screen->Font->ta_YSize + 1;

    ed->ed_ColorModeLabels[0] = GetString(&ed->ed_LocaleInfo,MSG_PAL_4COLOR_MODE);
    ed->ed_ColorModeLabels[1] = GetString(&ed->ed_LocaleInfo,MSG_PAL_MULTICOLOR_MODE);

    CopyMem(EM,stash,sizeof(stash));

    depth = ed->ed_Depth;

    if (depth == 1)
    {
        height = 92;
        width  = 309;

        /* We don't allow HSB sliders when in monochrome, because we
         * don't have a color wheel to handle conversions for us
         */
        stash[COLORMODEL_ITEM].em_Type = NM_IGNORE;
        stash[COLORMODEL_ITEM+1].em_Type = NM_IGNORE;
        stash[COLORMODEL_ITEM+2].em_Type = NM_IGNORE;
    }
    else
    {
        width  = NW_WIDTH;
        height = NW_HEIGHT;
        if (ed->ed_Screen->Height - ed->ed_Screen->WBorTop - ed->ed_Screen->Font->ta_YSize - 1 >= NW_HEIGHT + 95)
        {
            ed->ed_EmbeddedSample = TRUE;
            height += 95;
        }
    }

    if ((!GetDisplayInfoData(NULL,(APTR)&di,sizeof(struct DisplayInfo),DTAG_DISP,A2024_MONITOR_ID))
    || (di.NotAvailable))
    {
        /* if there's no A2024 installed in this machine, zap the menu item */
        stash[A2024_ITEM-1].em_Type = NM_IGNORE;
        stash[A2024_ITEM].em_Type = NM_IGNORE;
    }

    id = GetVPModeID(&ed->ed_WBScreen->ViewPort);
    if (!GetDisplayInfoData(NULL,(APTR)&di,sizeof(struct DisplayInfo),DTAG_DISP,id))
        return(FALSE);

    ed->ed_RedBits   = CheckBitRange(ed,di.RedBits);
    ed->ed_GreenBits = CheckBitRange(ed,di.GreenBits);
    ed->ed_BlueBits  = CheckBitRange(ed,di.BlueBits);

    NewList(&ed->ed_PenList);
    for (i=0; i<9; i++)
    {
        ed->ed_PenNodes[i].ln_Name = GetString(&ed->ed_LocaleInfo,i+MSG_PAL_BACKGROUND_PEN);
        ed->ed_PenNodes[i].ln_Pri  = i;
        AddTail(&ed->ed_PenList,&ed->ed_PenNodes[i]);
    }

    if (depth > 1)
    {
        /* figure out the width of the color wheel in order to make it as
         * square as possible (square wheel, yeah I know :-)
         */

        wsize = 91 * ed->ed_DrawInfo->dri_Resolution.Y / ed->ed_DrawInfo->dri_Resolution.X;
        if (wsize < 30)
            wsize = 30;
        else if (wsize > 293 - 21)
            wsize = 293 - 21;

        left = (293 - (wsize + 21)) / 2 + 10 + ed->ed_Screen->WBorLeft;

        ed->ed_GradPens[31]         = ~0;
        ed->ed_GradPens[30]         = ObtainBestPenA(ed->ed_Screen->ViewPort.ColorMap,0,0,0,NULL);
        ed->ed_NumGradPensAllocated = 1;
        ed->ed_FirstGradPen         = 30;

        ed->ed_GradientSlider = (struct Gadget *)NewPrefsObject(ed,NULL,"gradientslider.gadget",
                                               GA_Left,        left + wsize + 3,
                                               GA_Top,         28 + ed->ed_Screen->WBorTop + ed->ed_Screen->Font->ta_YSize + 1,
                                               GA_Width,       18,
                                               GA_Height,      91,
                                               GA_ID,          EC_GRADIENTSLIDER,
                                               GA_RelVerify,   TRUE,
                                               GA_Immediate,   TRUE,
                                               PGA_Freedom,    LORIENT_VERT,
                                               ICA_TARGET,     ICTARGET_IDCMP,
                                               TAG_END);

        ed->ed_ColorWheel = (struct Gadget *)NewPrefsObject(ed,NULL,"colorwheel.gadget",
                                                   GA_Left,        left,
                                                   GA_Top,         28 + ed->ed_Screen->WBorTop + ed->ed_Screen->Font->ta_YSize + 1,
                                                   GA_Width,       wsize,
                                                   GA_Height,      91,
                                                   GA_ID,          EC_COLORWHEEL,
                                                   GA_Previous,    ed->ed_GradientSlider,
                                                   GA_RelVerify,   TRUE,
                                                   GA_Immediate,   TRUE,
                                                   WHEEL_Screen,   ed->ed_Screen,
                                                   WHEEL_GradientSlider, ed->ed_GradientSlider,
                                                   WHEEL_Abbrv,    GetString(&ed->ed_LocaleInfo,MSG_PAL_WHEEL_ABBRV),
                                                   WHEEL_MaxPens,  MAXWHEELPENS,
                                                   ICA_TARGET,     ICTARGET_IDCMP,
                                                   TAG_END);

        if (ed->ed_GradientSlider)
        {
            /* allocate pens for the gradient slider */
            i = 30;
            while (i > 0)
            {
                i--;
                ed->ed_GradPens[i] = ObtainPen(ed->ed_Screen->ViewPort.ColorMap,-1,0,0,0,PEN_EXCLUSIVE | PEN_NO_SETCOLOR);
                if (ed->ed_GradPens[i] == -1)
                    break;

                ed->ed_NumGradPensAllocated++;
                ed->ed_FirstGradPen = i;
            }

            SetGadgetAttrsP(ed,ed->ed_GradientSlider,GRAD_PenArray,&ed->ed_GradPens[ed->ed_FirstGradPen],
                                                     TAG_DONE);
        }
    }

    RenderGadgets(ed);

    if ((ed->ed_LastAdded)
    &&  (ed->ed_Menus = CreatePrefsMenus(ed,stash))
    &&  (ed->ed_Window = OpenPrefsWindow(ed,WA_InnerWidth,    width,
                                            WA_InnerHeight,   height,
                                            WA_MinWidth,      NW_MINWIDTH,
                                            WA_MinHeight,     height,
                                            WA_MaxWidth,      NW_MAXWIDTH,
                                            WA_MaxHeight,     NW_MAXHEIGHT,
                                            WA_IDCMP,         NW_IDCMP,
                                            WA_Flags,         NW_FLAGS,
                                            WA_Zoom,          zoomSize,
                                            WA_AutoAdjust,    TRUE,
                                            WA_CustomScreen,  ed->ed_Screen,
                                            WA_Title,         GetString(&ed->ed_LocaleInfo,MSG_PAL_NAME),
                                            WA_NewLookMenus,  TRUE,
                                            WA_Gadgets,       ed->ed_Gadgets,
                                            TAG_DONE)))
    {
        if (ed->ed_GradientSlider)
        {
            AddGList(window, ed->ed_GradientSlider, 0, 2, NULL);
            RefreshGList(ed->ed_GradientSlider, window, NULL, 2);
        }

        if (depth > 1)
        {
            item1 = ItemAddress(ed->ed_Menus,FULLMENUNUM(2,1,0));
            item2 = item1->NextItem;

            item1->MutualExclude = 2;
            item2->MutualExclude = 1;

            item1->Flags &= ~CHECKED;
            item2->Flags &= ~CHECKED;
        }

        if (ed->ed_Screen != ed->ed_WBScreen)
        {
            UnlockPubScreen(NULL,ed->ed_WBScreen);
            ed->ed_WBScreen = NULL;
        }

        return(TRUE);
    }

    DisposeDisplay(ed);
    return(FALSE);
}


/*****************************************************************************/


VOID ClosePrefsWindow(EdDataPtr ed, struct Window *wp, BOOL others)
{
struct IntuiMessage *msg;
struct Node         *succ;

    if (wp)
    {
        ClearMenuStrip(wp);

        if (wp->UserPort)
        {
            Forbid();

            msg = (struct IntuiMessage *) wp->UserPort->mp_MsgList.lh_Head;
            while (succ = msg->ExecMessage.mn_Node.ln_Succ)
            {
                if (msg->IDCMPWindow == wp)
                {
                    Remove(msg);
                    ReplyMsg(msg);
                }
                msg = (struct IntuiMessage *) succ;
            }

            if (others)
                wp->UserPort = NULL;

            ModifyIDCMP(wp,NULL);
            Permit();
        }

        CloseWindow(wp);
    }
}


/*****************************************************************************/


VOID DisposeDisplay(EdDataPtr ed)
{
UWORD i;

    ClosePrefsWindow(ed,ed->ed_SampleWindow,TRUE);
    ClosePrefsWindow(ed,ed->ed_Window,FALSE);

    FreeMenus(ed->ed_Menus);
    FreeGadgets(ed->ed_Gadgets);

    for (i = 0; i < ed->ed_NumColorsAllocated; i++)
        ReleasePen(ed->ed_Screen->ViewPort.ColorMap,ed->ed_ColorTable[i]);

    for (i = ed->ed_FirstGradPen; i < ed->ed_FirstGradPen + ed->ed_NumGradPensAllocated; i++)
        ReleasePen(ed->ed_Screen->ViewPort.ColorMap,ed->ed_GradPens[i]);

    if (ed->ed_ColorWheel)
        DisposeObject(ed->ed_ColorWheel);

    if (ed->ed_GradientSlider)
        DisposeObject(ed->ed_GradientSlider);

    if (ed->ed_Screen != ed->ed_WBScreen)
    {
        while (!CloseScreen(ed->ed_Screen))
            Wait(SIGBREAKF_CTRL_E);

        ed->ed_Screen = NULL;
    }
}


/*****************************************************************************/


static VOID __asm PenCallBack(register __a0 struct Hook *hook,
                              register __a1 struct LVDrawMsg *msg,
                              register __a2 struct Node *node)
{
EdDataPtr          ed    = hook->h_Data;
struct RastPort   *rp    = msg->lvdm_RastPort;
UBYTE              state = msg->lvdm_State;
struct TextExtent  extent;
ULONG              fit;
WORD               x,y;
WORD               slack;
ULONG              apen;
ULONG              bpen;
UWORD             *uipens = msg->lvdm_DrawInfo->dri_Pens;
STRPTR             name;
UWORD             *pens;

    if (ed->ed_Depth <= 2)
        pens = ed->ed_PrefsWork.pap_4ColorPens;
    else
        pens = ed->ed_PrefsWork.pap_8ColorPens;

    apen = uipens[FILLTEXTPEN];
    bpen = uipens[FILLPEN];
    if (state == LVR_NORMAL)
    {
        apen = uipens[TEXTPEN];
        bpen = uipens[BACKGROUNDPEN];
    }
    SetABPenDrMd(rp,apen,bpen,JAM2);

    name = node->ln_Name;

    fit = TextFit(rp,name,strlen(name),&extent,NULL,1,
                  msg->lvdm_Bounds.MaxX-msg->lvdm_Bounds.MinX-3-20,
                  msg->lvdm_Bounds.MaxY-msg->lvdm_Bounds.MinY+1);

    slack = (msg->lvdm_Bounds.MaxY - msg->lvdm_Bounds.MinY) - (extent.te_Extent.MaxY - extent.te_Extent.MinY);

    x = msg->lvdm_Bounds.MinX - extent.te_Extent.MinX + 2 + 20;
    y = msg->lvdm_Bounds.MinY - extent.te_Extent.MinY + ((slack+1) / 2);

    extent.te_Extent.MinX += x - 20;
    extent.te_Extent.MaxX += x;
    extent.te_Extent.MinY += y;
    extent.te_Extent.MaxY += y;

    Move(rp,x,y);
    Text(rp,name,fit);

    x -= 20;

    SetAPen(rp,bpen);
    FillOldExtent(rp,&msg->lvdm_Bounds,&extent.te_Extent,GfxBase);
    RectFill(rp,x+17,y-6,x+19,y+1);

    SetAPen(rp,ed->ed_ColorTable[pens[NodeMap[node->ln_Pri]]]);
    RectFill(rp,x+2,y-5,x+14,y);

    if (state == LVR_SELECTED)
        SetAPen(rp,uipens[FILLTEXTPEN]);
    else
        SetAPen(rp,uipens[TEXTPEN]);

    RectFill(rp,x,y-6,x+16,y-6);
    RectFill(rp,x,y-5,x+1,y);
    RectFill(rp,x+15,y-5,x+16,y);
    RectFill(rp,x,y+1,x+16,y+1);
}


/*****************************************************************************/


/* "value" is in the current bit size */
ULONG Make16(ULONG value, ULONG bits)
{
ULONG result;
ULONG mask;

    if (bits == 16)
        return(value);

    mask   = value << (16 - bits);
    result = 0;
    while (mask)
    {
        result |= mask;
        mask    = mask >> bits;
    }

    return(result);
}


/*****************************************************************************/


VOID SetRGB16(EdDataPtr ed, UWORD color, ULONG r, ULONG g, ULONG b)
{
    SetRGB32(&ed->ed_Screen->ViewPort,color,Make32(r),Make32(g),Make32(b));
}


/*****************************************************************************/


VOID SetColors(EdDataPtr ed)
{
UWORD                color;
UWORD		     maxColor;
struct ColorSpec    *cspec;
struct LoadRGBTable  lrt[MAXCOLORS+1];

    if (ed->ed_Screen)
    {
        cspec    = ed->ed_PrefsWork.pap_Colors;
        maxColor = (1<<ed->ed_Depth);

        for (color = 0; color < maxColor; color++)
        {
            lrt[color].NumColors  = 1;
            lrt[color].FirstColor = ed->ed_ColorTable[color];
            lrt[color].Red        = Make32(cspec[color].Red);
            lrt[color].Green      = Make32(cspec[color].Green);
            lrt[color].Blue       = Make32(cspec[color].Blue);
/*
kprintf("        0x00%02lx%02lx%02lx,\n",lrt[color].Red / (256*256*256),
                                 lrt[color].Green / (256*256*256),
                                 lrt[color].Blue / (256*256*256));
*/
        }
        lrt[maxColor].NumColors = 0;

        LoadRGB32(&ed->ed_Screen->ViewPort,(ULONG *)lrt);
    }
}


/*****************************************************************************/


#define HUE_SIDE (0xffff / 6 + 1)

static VOID ConvertHSB2RGB(struct ColorWheelHSB *hsb, struct ColorWheelRGB *rgb)
{
ULONG i, f, p, q, t, v;

    if (hsb->cw_Saturation == 0)
    {
        rgb->cw_Red = rgb->cw_Green = rgb->cw_Blue = hsb->cw_Brightness;
    }
    else
    {
        v = hsb->cw_Brightness;
        i = hsb->cw_Hue / HUE_SIDE;
        f = (hsb->cw_Hue % HUE_SIDE) * 6;
        f += f >> 14;

        p = hsb->cw_Brightness * (0xffff - hsb->cw_Saturation) >> 16;
        q = hsb->cw_Brightness * (0xffff - (hsb->cw_Saturation * f >> 16)) >> 16;
        t = hsb->cw_Brightness * (0xffff - (hsb->cw_Saturation * (0xffff - f) >> 16)) >> 16;

        switch (i)
        {
            case 0: rgb->cw_Red = v; rgb->cw_Green = t; rgb->cw_Blue = p; break;
            case 1: rgb->cw_Red = q; rgb->cw_Green = v; rgb->cw_Blue = p; break;
            case 2: rgb->cw_Red = p; rgb->cw_Green = v; rgb->cw_Blue = t; break;
            case 3: rgb->cw_Red = p; rgb->cw_Green = q; rgb->cw_Blue = v; break;
            case 4: rgb->cw_Red = t; rgb->cw_Green = p; rgb->cw_Blue = v; break;
            case 5: rgb->cw_Red = v; rgb->cw_Green = p; rgb->cw_Blue = q; break;
        }
    }
}


/*****************************************************************************/


VOID DoWheel(EdDataPtr ed)
{
struct ColorSpec *cspec;

    cspec = &ed->ed_PrefsWork.pap_Colors[ed->ed_CurrentColor];

    SetGadgetAttrsP(ed,ed->ed_ColorWheel,WHEEL_Red,   Make32(cspec->Red),
                                         WHEEL_Green, Make32(cspec->Green),
                                         WHEEL_Blue,  Make32(cspec->Blue),
                                         TAG_DONE);
}


/*****************************************************************************/


VOID DoBrightness(EdDataPtr ed)
{
struct ColorWheelHSB  hsb;
struct ColorWheelRGB  rgb;
UWORD                 i,j;
struct LoadRGBTable   lrt[32];

    GetAttr(WHEEL_HSB,ed->ed_ColorWheel,(ULONG *)&hsb);

    hsb.cw_Hue        = (hsb.cw_Hue        >> 16);
    hsb.cw_Saturation = (hsb.cw_Saturation >> 16);

    /* set all colors except the last, which is always black */
    i = ed->ed_FirstGradPen;
    j = 0;
    while (i < ed->ed_NumGradPensAllocated + ed->ed_FirstGradPen - 1)
    {
        hsb.cw_Brightness = 0xffff * (ed->ed_NumGradPensAllocated - (i - ed->ed_FirstGradPen)) / ed->ed_NumGradPensAllocated;
        ConvertHSB2RGB(&hsb,&rgb);

        lrt[j].NumColors  = 1;
        lrt[j].FirstColor = ed->ed_GradPens[i];
        lrt[j].Red        = Make32(rgb.cw_Red);
        lrt[j].Green      = Make32(rgb.cw_Green);
        lrt[j].Blue       = Make32(rgb.cw_Blue);
        i++;
        j++;
    }

    lrt[j].NumColors = 0;

    LoadRGB32(&ed->ed_Screen->ViewPort,(ULONG *)lrt);
}


/*****************************************************************************/


VOID DoSliders(EdDataPtr ed)
{
struct ColorSpec     *cspec;
struct EdGadget       eg;
struct ColorWheelHSB  hsb;
ULONG                 level1, level2, level3;
UWORD                 max1, max2, max3;

    if (ed->ed_SlidersRGB)
    {
        cspec  = &ed->ed_PrefsWork.pap_Colors[ed->ed_CurrentColor];
        level1 = cspec->Red >> (HIGHBITSPERGUN-ed->ed_RedBits);
        max1   = (1<<ed->ed_RedBits)-1;
        level2 = cspec->Green >> (HIGHBITSPERGUN-ed->ed_GreenBits);
        max2   = (1<<ed->ed_GreenBits)-1;
        level3 = cspec->Blue >> (HIGHBITSPERGUN-ed->ed_BlueBits);
        max3   = (1<<ed->ed_BlueBits)-1;
    }
    else
    {
        GetAttr(WHEEL_HSB,ed->ed_ColorWheel,(ULONG *)&hsb);
        level1 = (hsb.cw_Hue >> 24);
        max1   = 255;
        level2 = (hsb.cw_Saturation >> 24);
        max2   = 255;
        level3 = (hsb.cw_Brightness >> 24);
        max3   = 255;
    }

    eg = EG[5];
    if (ed->ed_Depth == 1)
        eg.eg_TopEdge = 30;

    ed->ed_Slider1 = DoPrefsGadget(ed,&eg,ed->ed_Slider1,
                                      GTSL_Level,       level1,
                                      GTSL_Min,         0,
                                      GTSL_Max,         max1,
                                      GTSL_MaxLevelLen, 3,
                                      GTSL_LevelFormat, "%3ld",
                                      GA_RelVerify,     TRUE,
                                      GA_Immediate,     TRUE,
                                      TAG_DONE);

    eg = EG[6];
    if (ed->ed_Depth == 1)
        eg.eg_TopEdge = 42;

    ed->ed_Slider2 = DoPrefsGadget(ed,&eg,ed->ed_Slider2,
                                        GTSL_Level,       level2,
                                        GTSL_Min,         0,
                                        GTSL_Max,         max2,
                                        GTSL_MaxLevelLen, 3,
                                        GTSL_LevelFormat, "%3ld",
                                        GA_RelVerify,     TRUE,
                                        GA_Immediate,     TRUE,
                                        TAG_DONE);

    eg = EG[7];
    if (ed->ed_Depth == 1)
        eg.eg_TopEdge = 55;

    ed->ed_Slider3 = DoPrefsGadget(ed,&eg,ed->ed_Slider3,
                                       GTSL_Level,       level3,
                                       GTSL_Min,         0,
                                       GTSL_Max,         max3,
                                       GTSL_MaxLevelLen, 3,
                                       GTSL_LevelFormat, "%3ld",
                                       GA_RelVerify,     TRUE,
                                       GA_Immediate,     TRUE,
                                       TAG_DONE);
}


/*****************************************************************************/


VOID RenderSliderNames(EdDataPtr ed)
{
struct RastPort *rp = window->RPort;
STRPTR           str;
UWORD            len, plen;
UWORD            i;
ULONG            offset;
ULONG            y;

    SetABPenDrMd(rp,ed->ed_DrawInfo->dri_Pens[TEXTPEN],
                    ed->ed_DrawInfo->dri_Pens[BACKGROUNDPEN],
                    JAM2);

    offset = MSG_PAL_RED_GAD;
    y      = 129;

    if (ed->ed_Depth == 1)
        y = 38;

    if (!ed->ed_SlidersRGB)
        offset = MSG_PAL_HUE_GAD;

    i = 0;
    while (i < 3)
    {
       str  = GetString(&ed->ed_LocaleInfo,i+offset),
       len  = strlen(str);
       plen = TextLength(rp,str,len);
       Move(rp,110+window->BorderLeft-plen,y+window->BorderTop + 12*i);
       Text(rp,str,len);
       i++;
    }
}


/*****************************************************************************/


VOID RenderDisplay(EdDataPtr ed)
{
BOOL refresh;

    /* if either window is in refresh state, only redraw that one, and
     * not the other window
     */

    refresh = FALSE;
    if ((WFLG_WINDOWREFRESH & window->Flags)
    ||  (ed->ed_SampleWindow && (WFLG_WINDOWREFRESH & ed->ed_SampleWindow->Flags)))
        refresh = TRUE;

    if (ed->ed_EmbeddedSample)
    {
        if (!refresh || (window->Flags & WFLG_WINDOWREFRESH))
        {
            SetAPen(window->RPort,ed->ed_DrawInfo->dri_Pens[SHADOWPEN]);
            RectFill(window->RPort,window->BorderLeft,
                                   window->BorderTop + 186,
                                   window->Width - window->BorderRight - 1,
                                   window->BorderTop + 186);

            SetAPen(window->RPort,ed->ed_DrawInfo->dri_Pens[SHINEPEN]);
            RectFill(window->RPort,window->BorderLeft,
                                   window->BorderTop + 187,
                                   window->Width - window->BorderRight - 1,
                                   window->BorderTop + 187);

            if (ed->ed_Depth <= 2)
                RenderSample(ed,ed->ed_PrefsWork.pap_4ColorPens,TRUE);
            else
                RenderSample(ed,ed->ed_PrefsWork.pap_8ColorPens,TRUE);
        }
    }

    if (ed->ed_SampleWindow)
    {
        if (!refresh || (ed->ed_SampleWindow->Flags & WFLG_WINDOWREFRESH))
        {
            if (ed->ed_Depth <= 2)
                RenderSample(ed,ed->ed_PrefsWork.pap_4ColorPens,TRUE);
            else
                RenderSample(ed,ed->ed_PrefsWork.pap_8ColorPens,TRUE);
        }
    }

    if (!refresh || (window->Flags & WFLG_WINDOWREFRESH))
    {
        if (ed->ed_Depth > 1)
        {
            DrawBB(ed,8,3,299,156,GT_VisualInfo,ed->ed_VisualInfo,
                                  TAG_DONE);
        }

        RenderSliderNames(ed);
    }
}


/*****************************************************************************/


VOID RenderGadgets(EdDataPtr ed)
{
UWORD            depth;
UWORD           *pens;
struct EdGadget  eg;

    depth = ed->ed_Depth;

    if (!ed->ed_LastAdded)
    {
	ed->ed_LastAdded = CreateContext(&ed->ed_Gadgets);

        eg = EG[0];
        if (depth == 1)
            eg.eg_TopEdge = 75;
        DoPrefsGadget(ed, &eg, NULL, TAG_DONE);

        eg = EG[1];
        if (depth == 1)
        {
            eg.eg_LeftEdge = 111;
            eg.eg_TopEdge = 75;
        }
        DoPrefsGadget(ed, &eg, NULL, TAG_DONE);

        eg = EG[2];
        if (depth == 1)
        {
            eg.eg_LeftEdge = 214;
            eg.eg_TopEdge = 75;
        }
        DoPrefsGadget(ed, &eg, NULL, TAG_DONE);

        if (!ed->ed_EmbeddedSample)
            DoPrefsGadget(ed, &EG[3], NULL, TAG_DONE);

        DoPrefsGadget(ed, &EG[10], NULL, GTCY_Labels, &ed->ed_ColorModeLabels,
                                         GTCY_Active, !ed->ed_4ColorMode,
                                         TAG_DONE);

        ed->ed_Slider1      = NULL;
        ed->ed_Slider2      = NULL;
        ed->ed_Slider3      = NULL;
        ed->ed_PenPalette   = NULL;
        ed->ed_ColorPalette = NULL;
        ed->ed_Pens         = NULL;

        ed->ed_ColorPalette = DoPrefsGadget(ed, &EG[4], ed->ed_ColorPalette,
                                            GTPA_Depth,          depth,
                                            GTPA_IndicatorWidth, 40,
                                            GTPA_ColorTable,     ed->ed_ColorTable,
                                            TAG_DONE);
    }

    if (ed->ed_Depth <= 2)
        pens = ed->ed_PrefsWork.pap_4ColorPens;
    else
        pens = ed->ed_PrefsWork.pap_8ColorPens;

    SetColors(ed);

    eg = EG[8];
    if (!ed->ed_EmbeddedSample)
        eg.eg_Height -= 12;

    ed->ed_Pens = DoPrefsGadget(ed,&eg,ed->ed_Pens,
                                GTLV_Labels,       &ed->ed_PenList,
                                GTLV_ShowSelected, NULL,
                                GTLV_ScrollWidth,  19,
                                GTLV_ItemHeight,   12,
                                GTLV_CallBack,     &ed->ed_PenCallBack,
                                GTLV_Selected,     ed->ed_CurrentPen,
                                GTLV_MaxPen,       255,
                                TAG_DONE);

    eg = EG[9];
    if (!ed->ed_EmbeddedSample)
        eg.eg_TopEdge -= 12;

    ed->ed_PenPalette = DoPrefsGadget(ed, &eg, ed->ed_PenPalette,
                                      GTPA_Depth,          depth,
                                      GTPA_Color,          ed->ed_ColorTable[pens[NodeMap[ed->ed_PenNodes[ed->ed_CurrentPen].ln_Pri]]],
                                      GTPA_IndicatorWidth, 40,
                                      GTPA_ColorTable,     ed->ed_ColorTable,
                                      GA_Disabled,         ed->ed_CurrentPen < 2,
                                      TAG_DONE);

    DoSliders(ed);
    DoWheel(ed);
    DoBrightness(ed);

    if (window)
        RenderSample(ed,pens,FALSE);
}


/*****************************************************************************/


VOID ProcessSpecialCommand(EdDataPtr ed, EdCommand ec)
{
UWORD                 icode;
BOOL                  docolor;
struct Preset        *preset;
UWORD                 i,color;
struct ColorSpec     *cspec;
UWORD                *pens;
UWORD                 zoomSize[4];
struct ColorWheelRGB  rgb;
BOOL                  dohsb;

    icode   = ed->ed_CurrentMsg.Code;
    docolor = FALSE;
    dohsb   = FALSE;
    color   = ed->ed_CurrentColor;
    cspec   = ed->ed_PrefsWork.pap_Colors;

    if (ed->ed_Depth <= 2)
        pens = ed->ed_PrefsWork.pap_4ColorPens;
    else
        pens = ed->ed_PrefsWork.pap_8ColorPens;

    switch (ec)
    {
	case EC_COLORMODE    : RemoveGList(window, ed->ed_Gadgets, -1);
                               FreeGadgets(ed->ed_Gadgets);
                               ed->ed_Gadgets   = NULL;
                               ed->ed_LastAdded = NULL;

                               ed->ed_4ColorMode = (icode == 0);
                               ed->ed_Depth      = icode+2;
                               RenderGadgets(ed);

                               if (ed->ed_LastAdded)
                               {
                                   AddGList(window, ed->ed_Gadgets, -1, -1, NULL);
                                   RefreshGList(ed->ed_Gadgets, window, NULL, -1);
                                   GT_RefreshWindow(window, NULL);
                               }
                               break;

        case EC_COLORWHEEL   : GetAttr(WHEEL_RGB,ed->ed_ColorWheel,(ULONG *)&rgb);
                               cspec[color].Red   = (rgb.cw_Red   >> 16);
                               cspec[color].Green = (rgb.cw_Green >> 16);
                               cspec[color].Blue  = (rgb.cw_Blue  >> 16);
                               SetColors(ed);
                               DoSliders(ed);
                               DoBrightness(ed);
                               break;

        case EC_SHOWSAMPLE   : if (ed->ed_SampleWindow)
                               {
                                   WindowToFront(ed->ed_SampleWindow);
                               }
                               else
                               {
                                   zoomSize[0] = -1;
                                   zoomSize[1] = -1;
                                   zoomSize[2] = ZOOMWIDTH;
                                   zoomSize[3] = ed->ed_Screen->WBorTop + ed->ed_Screen->Font->ta_YSize + 1;

                                   if (ed->ed_SampleWindow = OpenPrefsWindow(ed,
                                                 WA_InnerWidth,    NW_WIDTH,
                                                 WA_InnerHeight,   93,
                                                 WA_MinWidth,      NW_MINWIDTH,
                                                 WA_MinHeight,     NW_MINHEIGHT,
                                                 WA_MaxWidth,      NW_MAXWIDTH,
                                                 WA_MaxHeight,     NW_MAXHEIGHT,
                                                 WA_Flags,         NW_FLAGS | WFLG_CLOSEGADGET,
                                                 WA_Zoom,          zoomSize,
                                                 WA_AutoAdjust,    TRUE,
                                                 WA_CustomScreen,  ed->ed_Screen,
                                                 WA_Title,         GetString(&ed->ed_LocaleInfo,MSG_PAL_SAMPLE_TITLE),
                                                 WA_NewLookMenus,  TRUE,
                                                 TAG_DONE))
                                   {
                                       ed->ed_SampleWindow->UserPort = ed->ed_Window->UserPort;
                                       ModifyIDCMP(ed->ed_SampleWindow,IDCMP_CLOSEWINDOW | IDCMP_REFRESHWINDOW);

                                       SetFont(ed->ed_SampleWindow->RPort,ed->ed_Font);
                                       RenderSample(ed,pens,TRUE);
                                   }
                                   else
                                   {
                                       DisplayBeep(NULL);
                                   }
                               }
                               break;

        case EC_CLOSEGADGET  : ClosePrefsWindow(ed,ed->ed_SampleWindow,TRUE);
                               ed->ed_SampleWindow = NULL;
                               break;

        case EC_PENPALETTE   : i = 0;
                               while (icode != ed->ed_ColorTable[i])
                                   i++;
                               pens[NodeMap[ed->ed_CurrentPen]] = i;

                               RenderSample(ed,pens,FALSE);
                               SetGadgetAttr(ed,ed->ed_Pens,
                                             GTLV_Labels,   &ed->ed_PenList,
                                             GTLV_Selected, ed->ed_CurrentPen,
                                             TAG_DONE);

                               /* FALLS THROUGH! */

        case EC_PENS         : if (ec == EC_PENS)
                               {
                                   ed->ed_CurrentPen = icode;
                                   SetGadgetAttr(ed,ed->ed_PenPalette,
                                                 GTPA_Color,  ed->ed_ColorTable[pens[NodeMap[ed->ed_PenNodes[icode].ln_Pri]]],
                                                 GA_Disabled, ed->ed_CurrentPen < 2,
                                                 TAG_DONE);

                                   icode = ed->ed_ColorTable[pens[NodeMap[ed->ed_PenNodes[icode].ln_Pri]]];
                               }
                               SetGadgetAttr(ed,ed->ed_ColorPalette,
                                             GTPA_Color,  icode,
                                             TAG_DONE);

                               /* FALLS THROUGH! */

        case EC_COLORPALETTE : i = 0;
                               while (icode != ed->ed_ColorTable[i])
                                   i++;

                               ed->ed_CurrentColor = i;
                               DoWheel(ed);
                               DoBrightness(ed);
                               DoSliders(ed);
                               break;

        case EC_SLIDER1      : if (ed->ed_SlidersRGB)
                               {
                                   cspec[color].Red = Make16(icode,ed->ed_RedBits);
                                   docolor = TRUE;
                               }
                               else
                               {
                                   SetGadgetAttrsP(ed,ed->ed_ColorWheel,
                                                   WHEEL_Hue, Make32(Make16(icode,8)),
                                                   TAG_DONE);
                                   dohsb = TRUE;
                               }
                               break;

        case EC_SLIDER2      : if (ed->ed_SlidersRGB)
                               {
                                   cspec[color].Green = Make16(icode,ed->ed_GreenBits);
                                   docolor = TRUE;
                               }
                               else
                               {
                                   SetGadgetAttrsP(ed,ed->ed_ColorWheel,
                                                   WHEEL_Saturation, Make32(Make16(icode,8)),
                                                   TAG_DONE);
                                   dohsb = TRUE;
                               }
                               break;

        case EC_SLIDER3      : if (ed->ed_SlidersRGB)
                               {
                                   cspec[color].Blue = Make16(icode,ed->ed_BlueBits);
                                   docolor = TRUE;
                               }
                               else
                               {
                                   SetGadgetAttrsP(ed,ed->ed_ColorWheel,
                                                   WHEEL_Brightness, Make32(Make16(icode,8)),
                                                   TAG_DONE);
                                   dohsb = TRUE;
                               }
                               break;

        case EC_PRESET1      :
        case EC_PRESET2      :
        case EC_PRESET3      :
        case EC_PRESET4      :
        case EC_PRESET5      :
        case EC_PRESET6      :
        case EC_PRESET7      :
        case EC_PRESET8      :
        case EC_PRESET9      : preset = &Presets[ec-EC_PRESET1];
                               for (i = 0; i < MAXCOLORS; i++)
                               {
                                   cspec[i].Red   = Make16((preset->Colors[i] / 65536) % 256,8);
                                   cspec[i].Green = Make16((preset->Colors[i] / 256) % 256,8);
                                   cspec[i].Blue  = Make16((preset->Colors[i] % 256),8);
                               }

                               for (i = 0; i < NUM_KNOWNPENS; i++)
                               {
                                   ed->ed_PrefsWork.pap_4ColorPens[i] = DefaultPens[i];
                                   ed->ed_PrefsWork.pap_8ColorPens[i] = DefaultPens[i];
                               }

                               SetColors(ed);
                               RenderSample(ed,pens,FALSE);
                               SetGadgetAttr(ed,ed->ed_PenPalette,
                                             GTPA_Color, ed->ed_ColorTable[pens[NodeMap[ed->ed_PenNodes[ed->ed_CurrentPen].ln_Pri]]],
                                             TAG_DONE);
                               SetGadgetAttr(ed,ed->ed_Pens,
                                             GTLV_Labels,   &ed->ed_PenList,
                                             GTLV_Selected, ed->ed_CurrentPen,
                                             TAG_DONE);
                               DoWheel(ed);
                               DoBrightness(ed);
                               DoSliders(ed);
                               break;

        case EC_RGBMODEL     : ed->ed_SlidersRGB = TRUE;
                               RenderSliderNames(ed);
                               DoSliders(ed);
                               break;

        case EC_HSBMODEL     : ed->ed_SlidersRGB = FALSE;
                               RenderSliderNames(ed);
                               DoSliders(ed);
                               break;
    }

    if (docolor)
    {
        SetRGB16(ed,ed->ed_ColorTable[color],cspec[color].Red,cspec[color].Green,cspec[color].Blue);
        DoWheel(ed);
        DoBrightness(ed);
    }

    if (dohsb)
    {
        GetAttr(WHEEL_RGB,ed->ed_ColorWheel,(ULONG *)&rgb);
        cspec[color].Red   = (rgb.cw_Red   >> 16);
        cspec[color].Green = (rgb.cw_Green >> 16);
        cspec[color].Blue  = (rgb.cw_Blue  >> 16);
        SetRGB16(ed,ed->ed_ColorTable[color],cspec[color].Red,cspec[color].Green,cspec[color].Blue);
        DoBrightness(ed);
    }
}


/*****************************************************************************/


VOID GetSpecialCmdState(EdDataPtr ed, EdCommand ec, CmdStatePtr state)
{
    state->cs_Available = TRUE;
    state->cs_Selected  = FALSE;

    if (ec == EC_RGBMODEL)
        state->cs_Selected = ed->ed_SlidersRGB;

    if (ec == EC_HSBMODEL)
        state->cs_Selected = !ed->ed_SlidersRGB;
}


/*****************************************************************************/


EdCommand GetCommand(EdDataPtr ed)
{
    if (ed->ed_CurrentMsg.Class == IDCMP_IDCMPUPDATE)
        return(EC_COLORWHEEL);

    return(EC_NOP);
}
@


39.6
log
@Fixed hang in 2 color mode

Switching from 8 to 4 color mode no longer leaves some garbage pixels to the right
  of the topmost palette gadget

When switching to 8 color mode while running from a 4 color WB, no longer trashes
  color registers. Enough colors are always allocated.

@
text
@d137 1
a137 1
    UWORD Colors[8];
d145 8
a152 8
        0x0BA9,  /* beige */
        0x0002,
        0x0FFF,
        0x068B,  /* blue */
	0x0FCC,
	0x0B81,
	0x03D3,
	0x0F31
d157 8
a164 8
        0x08AC,     /* blue-gray */
        0x0002,
        0x0FFF,
        0x0FC9,     /* gold */
	0x000F,
	0x0E71,
	0x03D3,
	0x0F31
d169 8
a176 8
        0x08AC, /* blue-gray */
        0x0002,
        0x0FFF,
        0x0E97, /* orange */
	0x0EE0,
	0x000F,
	0x03D3,
	0x0F31
d181 8
a188 8
        0x05BA, /* ocean green */
        0x0002,
        0x0EEF,
        0x057A, /* ocean blue */
	0x0EE0,
	0x000F,
	0x00F0,
	0x0F31
d193 8
a200 8
        0x09BD, /* blue-gray */
        0x0002,
        0x0FFF,
        0x068B, /* dark blue-gray */
	0x000C,
	0x0091,
	0x0FF1,
	0x0F31
d205 8
a212 8
        0x0A98, /* med-brown */
        0x0321,
        0x0FEE,
        0x0FDB, /* tan-gold */
	0x0FCC,
	0x0B81,
	0x03D3,
	0x0F31
d217 8
a224 8
        0x0CCB,
        0x0003,
        0x0FFF,
        0x09AB, /* gray */
	0x0FCC,
	0x0B81,
	0x03D3,
	0x0F31
d229 8
a236 8
        0x0C99,
        0x0002,
        0x0FEE,
        0x0B67,
	0x0FCC,
	0x0B81,
	0x03D3,
	0x0F31
d241 8
a248 8
        0x0A96, /* Hedley light-gray (brown) */
        0x0002, /* Hedley black */
        0x0FFF, /* Hedley white */
        0x0779, /* Hedley dark-gray (blue) */
	0x0FCC,
	0x0B81,
	0x03D3,
	0x0F31
d1152 5
d1719 1
a1719 1
                               for (i=0; i<MAXCOLORS; i++)
d1721 3
a1723 3
                                   cspec[i].Red   = Make16((preset->Colors[i] / 256) % 16,4);
                                   cspec[i].Green = Make16((preset->Colors[i] / 16) % 16,4);
                                   cspec[i].Blue  = Make16(preset->Colors[i] % 16,4);
d1726 1
a1726 1
                               for (i=0; i<NUM_KNOWNPENS; i++)
@


39.5
log
@Uses LoadRGB32() when possible
Added support for Mode gadget
Clicking on the pen listview or palette automatically selects the 
  corresponding color in the wheel's palette
Can now load ILBM-CMAP chunks for backwards compatibility
Adjusted value that determines when a seperate sample window is needed, no
  more chopped off windows
@
text
@d125 4
a128 4
    0x0FCC,
    0x0B81,
    0x03D3,
    0x0F31
d540 1
a540 1
    {PALETTE_KIND,  13,   6,    292, 20, MSG_NOTHING,          EC_COLORPALETTE, 0},
d597 1
a597 1
        for (i = 0; i < (1 << editDepth); i++)
d652 1
a652 1
                 while (i < (1<<editDepth))
d672 1
a672 1
                while ((1<<scrDepth) > 8 + (1<<editDepth) + MAXWHEELPENS + 16)
d695 1
a695 1
                    for (i = 0; i < (1 << editDepth); i++)
d917 5
a921 2
        AddGList(window, ed->ed_GradientSlider, 0, 2, NULL);
        RefreshGList(ed->ed_GradientSlider, window, NULL, 2);
@


39.4
log
@Changed a few uses of WBScreen to just Screen
Correctly terminates default pens arrays with ~0 insteda of just FF
Correctly updates the pen list when switching to presets
@
text
@d56 14
d77 13
d258 1
a258 1
#define IFFPrefChunkCnt 2
d262 2
a263 1
    ID_PREF, ID_PALT
d382 3
a384 2
    if (cn->cn_ID != ID_PALT || cn->cn_Type != ID_PREF)
        return(ES_IFF_UNKNOWNCHUNK);
d386 1
a386 1
    if (ReadChunkBytes(iff,&ed->ed_PrefsWork,sizeof(struct PalettePrefs)) == sizeof(struct PalettePrefs))
d388 21
a408 1
        MapDown(ed);
d412 1
a412 1
    return(ES_IFFERROR);
d534 3
a536 3
    {BUTTON_KIND,   8,    168,  87,  14, MSG_SAVE_GAD,         EC_SAVE,       0},
    {BUTTON_KIND,   264,  168,  87,  14, MSG_USE_GAD,          EC_USE,        0},
    {BUTTON_KIND,   521,  168,  87,  14, MSG_CANCEL_GAD,       EC_CANCEL,     0},
d538 1
a538 1
    {BUTTON_KIND,   315,  141,  293, 14, MSG_PAL_SHOW_SAMPLE, EC_SHOWSAMPLE,  0},
d541 3
a543 3
    {SLIDER_KIND,   145,  121,  157, 11, MSG_NOTHING,          EC_SLIDER1,          0},
    {SLIDER_KIND,   145,  133,  157, 11, MSG_NOTHING,          EC_SLIDER2,        0},
    {SLIDER_KIND,   145,  145,  157, 11, MSG_NOTHING,          EC_SLIDER3,         0},
d545 5
a549 3
    {LISTVIEW_KIND, 315,  3,   293, 136, MSG_NOTHING,          EC_PENS,         0},
    {PALETTE_KIND,  315,  139, 293, 20,  MSG_NOTHING,          EC_PENPALETTE,   0}
};
d672 1
a672 1
                while ((1<<scrDepth) > 8 + (1<<editDepth) + 26 + 16)
d726 1
d735 1
a735 1
        if (ed->ed_WBScreen->Height - ed->ed_WBScreen->WBorTop - ed->ed_WBScreen->Font->ta_YSize - 1 >= 148 + 95)
a767 1
struct EdGadget    eg;
d776 3
d799 1
a799 1
        if (ed->ed_Screen->Height - ed->ed_Screen->WBorTop - ed->ed_Screen->Font->ta_YSize - 1 >= 148 + 95)
a829 31
    ed->ed_LastAdded = CreateContext(&ed->ed_Gadgets);

    eg = EG[0];
    if (depth == 1)
        eg.eg_TopEdge = 75;
    DoPrefsGadget(ed, &eg, NULL, TAG_DONE);

    eg = EG[1];
    if (depth == 1)
    {
        eg.eg_LeftEdge = 111;
        eg.eg_TopEdge = 75;
    }
    DoPrefsGadget(ed, &eg, NULL, TAG_DONE);

    eg = EG[2];
    if (depth == 1)
    {
        eg.eg_LeftEdge = 214;
        eg.eg_TopEdge = 75;
    }
    DoPrefsGadget(ed, &eg, NULL, TAG_DONE);

    if (!ed->ed_EmbeddedSample)
        DoPrefsGadget(ed, &EG[3], NULL, TAG_DONE);

    DoPrefsGadget(ed, &EG[4], NULL, GTPA_Depth,          depth,
                                    GTPA_IndicatorWidth, 40,
                                    GTPA_ColorTable,     ed->ed_ColorTable,
                                    TAG_DONE);

d844 4
a847 6
        if (ed->ed_LastAdded)
        {
            ed->ed_GradPens[31]         = ~0;
            ed->ed_GradPens[30]         = ObtainBestPenA(ed->ed_Screen->ViewPort.ColorMap,0,0,0,NULL);
            ed->ed_NumGradPensAllocated = 1;
            ed->ed_FirstGradPen         = 30;
d849 11
a859 14
            ed->ed_LastAdded =
            ed->ed_GradientSlider  = (struct Gadget *)NewPrefsObject(ed,NULL,"gradientslider.gadget",
                                                   GA_Left,        left + wsize + 3,
                                                   GA_Top,         28 + ed->ed_Screen->WBorTop + ed->ed_Screen->Font->ta_YSize + 1,
                                                   GA_Width,       18,
                                                   GA_Height,      91,
                                                   GA_ID,          EC_GRADIENTSLIDER,
                                                   GA_Previous,    ed->ed_LastAdded,
                                                   GA_RelVerify,   TRUE,
                                                   GA_Immediate,   TRUE,
                                                   PGA_Freedom,    LORIENT_VERT,
                                                   ICA_TARGET,     ICTARGET_IDCMP,
                                                   TAG_END);
        }
d861 1
a861 4
        if (ed->ed_LastAdded)
        {
            ed->ed_LastAdded =
            ed->ed_ColorWheel = (struct Gadget *)NewPrefsObject(ed,NULL,"colorwheel.gadget",
d867 1
a867 1
                                                   GA_Previous,    ed->ed_LastAdded,
d873 1
a875 1
        }
d877 1
a877 1
        if (ed->ed_LastAdded)
d917 3
d932 6
d1040 1
a1040 1
    if (ed->ed_WBScreen->BitMap.Depth <= 2)
a1096 2
#define Make32(sixteen) ((((ULONG)sixteen)<<16) | (ULONG)sixteen)

d1132 4
a1135 3
UWORD             color;
UWORD		  maxColor;
struct ColorSpec *cspec;
d1139 2
a1140 1
        cspec = ed->ed_PrefsWork.pap_Colors;
a1141 1
        maxColor = (1<<ed->ed_Depth);
d1143 12
a1154 3
            SetRGB16(ed,ed->ed_ColorTable[color],cspec[color].Red,cspec[color].Green,cspec[color].Blue);
    }
}
d1215 4
a1218 3
struct ColorWheelHSB hsb;
struct ColorWheelRGB rgb;
UWORD                i;
d1225 1
a1225 1
    /* set all colors except the the last, which is always black */
d1227 1
d1232 6
a1237 1
        SetRGB16(ed, ed->ed_GradPens[i], rgb.cw_Red, rgb.cw_Green, rgb.cw_Blue);
d1239 1
d1241 4
d1394 1
a1394 1
            if (ed->ed_WBScreen->BitMap.Depth <= 2)
d1405 1
a1405 1
            if (ed->ed_WBScreen->BitMap.Depth <= 2)
d1412 1
a1412 1
    if (ed->ed_Depth > 1)
d1414 7
a1420 2
        DrawBB(ed,8,3,299,156,GT_VisualInfo,ed->ed_VisualInfo,
                              TAG_DONE);
a1421 2

    RenderSliderNames(ed);
d1434 50
a1483 2
    if (ed->ed_WBScreen->BitMap.Depth <= 2)
        pens  = ed->ed_PrefsWork.pap_4ColorPens;
d1485 1
a1485 3
        pens  = ed->ed_PrefsWork.pap_8ColorPens;

    depth = ed->ed_Depth;
a1487 3
    DoSliders(ed);
    DoWheel(ed);
    DoBrightness(ed);
d1491 1
a1491 1
        eg.eg_Height -= 24;
d1505 1
a1505 1
        eg.eg_TopEdge -= 24;
d1515 4
d1545 1
a1545 1
    if (ed->ed_WBScreen->BitMap.Depth <= 2)
d1552 17
a1620 7
        case EC_PENS         : ed->ed_CurrentPen = icode;
                               SetGadgetAttr(ed,ed->ed_PenPalette,
                                             GTPA_Color,  ed->ed_ColorTable[pens[NodeMap[ed->ed_PenNodes[icode].ln_Pri]]],
                                             GA_Disabled, ed->ed_CurrentPen < 2,
                                             TAG_DONE);
                               break;

d1631 18
a1648 1
                               break;
d1653 1
@


39.3
log
@*** empty log message ***
@
text
@d89 1
a89 2
    1,	/* BARTRIMPEN	 	 */
    ~0
d276 1
a276 1
                for (i = 0; i <= NUM_KNOWNPENS; i++)
d281 2
d723 1
a723 1
    zoomSize[3] = ed->ed_WBScreen->WBorTop + ed->ed_WBScreen->Font->ta_YSize + 1;
d819 1
a819 1
        left = (293 - (wsize + 21)) / 2 + 10 + ed->ed_WBScreen->WBorLeft;
d831 1
a831 1
                                                   GA_Top,         28 + ed->ed_WBScreen->WBorTop + ed->ed_WBScreen->Font->ta_YSize + 1,
d848 1
a848 1
                                                   GA_Top,         28 + ed->ed_WBScreen->WBorTop + ed->ed_WBScreen->Font->ta_YSize + 1,
a1526 1

d1606 4
@


39.2
log
@*** empty log message ***
@
text
@d260 1
a260 1
    if (ed->ed_ColorWheelBase = OpenLibrary("colorwheel.class",39))
d263 1
a263 1
        if (ed->ed_GradientSliderBase = OpenLibrary("gradientslider.class",39))
d828 1
a828 1
            ed->ed_GradientSlider  = (struct Gadget *)NewPrefsObject(ed,NULL,"gradientslidergclass",
d845 1
a845 1
            ed->ed_ColorWheel = (struct Gadget *)NewPrefsObject(ed,NULL,"colorwheelgclass",
@


39.1
log
@Brand new interface with color wheel and pen spec editing.

Way too much stuff changed for me to document it all!
@
text
@d488 1
a488 1
    {BUTTON_KIND,   316,  141,  309, 14, MSG_PAL_SHOW_SAMPLE, EC_SHOWSAMPLE,  0},
@


38.22
log
@Removed WA_Left and WA_Top
@
text
@a7 1
#include <devices/keymap.h>
d11 1
d14 1
a14 1
#include <libraries/asl.h>
d18 2
a19 1
#include <dos/exall.h>
a23 1
#include <clib/dos_protos.h>
d30 1
a30 1
#include <clib/asl_protos.h>
a33 1
#include <pragmas/dos_pragmas.h>
d39 1
a39 1
#include <pragmas/asl_pragmas.h>
d45 3
a47 1
#include "ilbm.h"
d56 2
a57 2
ULONG Make8(EdDataPtr ed, ULONG value, ULONG bits);
ULONG Make32(EdDataPtr ed, ULONG eight);
d62 32
a93 2

UWORD far Defaults[] =
d99 5
a103 13
    0x000F,	/*  Color 4 (bright blue) */
    0x0F0F,	/*  Color 5 (magenta) */
    0x00FF,	/*  Color 6 (cyan) */
    0x0FFF,	/*  Color 7 (white) */
    0x0620,	/*  Color 8 (brown) */
    0x0E50,	/*  Color 9 (rust) */
    0x09F1,	/*  Color 10 (bright green) */
    0x0EB0,	/*  Color 11 (amber) */
    0x055F,	/*  Color 12 (blue) */
    0x092F,	/*  Color 13 (purple) */
    0x00F8,	/*  Color 14 (green) */
    0x0CCC,	/*  Color 15 (gray) */
};
d111 1
a111 1
    UWORD Colors[4];
d123 4
d135 4
d147 4
d159 4
d171 4
d183 4
d195 4
d207 4
d219 4
d232 2
a233 1
VOID ProcessArgs(EdDataPtr ed, struct DiskObject *diskObj)
d235 3
a237 2
    ed->ed_PubScreenName = "Workbench";
}
d243 1
a243 1
struct ColorArray
d245 3
a247 1
    ULONG Red, Green, Blue;
d251 3
d256 11
a266 33
UWORD              i;
#if (MAXCOLORS > 16)
UWORD              color
UWORD              maxColor;
struct ColorArray  colors;
#endif

    for (i=0; i<16; i++)
    {
        ed->ed_PrefsDefaults.pp_Colors[i].red   = Make8(ed,(Defaults[i] / 256) % 16,4);
        ed->ed_PrefsDefaults.pp_Colors[i].green = Make8(ed,(Defaults[i] / 16) % 16,4);
        ed->ed_PrefsDefaults.pp_Colors[i].blue  = Make8(ed,Defaults[i] % 16,4);
    }

    if (ed->ed_WBScreen = LockPubScreen("Workbench"))
    {
#if (MAXCOLORS > 16)
        maxColor = (1<<ed->ed_WBScreen->BitMap.Depth);
        if (maxColor > MAXCOLORS)
            maxColor = MAXCOLORS;
        else if (maxColor < 32)
            maxColor = 32;

        for (i=16; i<maxColor; i++)
        {
            if (GfxBase->lib_Version >= 39)
            {
                GetRGB32(ed->ed_WBScreen->ViewPort.ColorMap,i,1,(ULONG *)&colors);
                ed->ed_PrefsDefaults.pp_Colors[i].red   = colors.Red >> 24;
                ed->ed_PrefsDefaults.pp_Colors[i].green = colors.Green >> 24;
                ed->ed_PrefsDefaults.pp_Colors[i].blue  = colors.Blue >> 24;
            }
            else
d268 22
a289 1
                color = GetRGB4(ed->ed_WBScreen->ViewPort.ColorMap,i);
d291 3
a293 4
                ed->ed_PrefsDefaults.pp_Colors[i].red   = Make8(ed,(color >> 8) % 16,4);
                ed->ed_PrefsDefaults.pp_Colors[i].green = Make8(ed,(color >> 4) % 16,4);
                ed->ed_PrefsDefaults.pp_Colors[i].blue  = Make8(ed,color % 16,4);
            }
d295 1
a295 5
#endif
        ed->ed_PrefsWork    = ed->ed_PrefsDefaults;
        ed->ed_PrefsInitial = ed->ed_PrefsDefaults;

        return(ES_NORMAL);
d298 1
a298 1
    return(ES_NO_MEMORY);
d312 1
d314 31
d351 15
d368 45
a412 3
struct IFFHandle *iff;
EdStatus          status;
BPTR              file;
d414 9
a422 32
    ed->ed_ErrorFileName = name;

    if (file = Open(name,MODE_OLDFILE))
    {
        status = ES_NO_MEMORY;
        if (iff = AllocIFF())
        {
            iff->iff_Stream = (ULONG)file;
            InitIFFasDOS(iff);

	    status = ES_IFFERROR;
            if (!OpenIFF(iff,IFFF_READ))
            {
                if (!StopChunk(iff,ID_ILBM,ID_CMAP))
                    if (!ParseIFF(iff,IFFPARSE_SCAN))
                        if (ReadChunkRecords(iff,&ed->ed_PrefsWork,sizeof(struct ColorRegister),MAXCOLORS))
                            status = ES_NORMAL;

                CloseIFF(iff);
            }
            FreeIFF(iff);
        }
        Close(file);
    }
    else
    {
        status = ES_DOSERROR;
        ed->ed_SecondaryResult = IoErr();
    }

    return(status);
}
d428 1
a428 1
EdStatus SavePrefs(EdDataPtr ed, STRPTR name)
d430 5
a434 69
struct IFFHandle    *iff;
EdStatus             status;
BPTR		     file;
struct BitMapHeader  bmhd;
struct PalettePrefs *pref;
UWORD		     empty = 0;

    pref                  = &ed->ed_PrefsWork;
    bmhd.w                = 16;
    bmhd.h                = 1;
    bmhd.x                = 0;
    bmhd.y                = 0;
    bmhd.nplanes          = MAXDEPTH;
    bmhd.Masking          = mskNone;
    bmhd.Compression      = cmpNone;
    bmhd.pad1             = 0;
    bmhd.TransparentColor = 0;
    bmhd.XAspect          = 10;
    bmhd.YAspect          = 11;
    bmhd.PageWidth        = 320;
    bmhd.PageHeight       = 200;

    ed->ed_ErrorFileName = name;

    if (file = Open(name,MODE_NEWFILE))
    {
        status = ES_NO_MEMORY;
        if (iff = AllocIFF())
        {
            iff->iff_Stream = (ULONG)file;
            InitIFFasDOS(iff);

            status = ES_IFFERROR;
            if (!OpenIFF(iff,IFFF_WRITE))
            {
                if (!PushChunk(iff,ID_ILBM,ID_FORM,IFFSIZE_UNKNOWN))

                    if (!PushChunk(iff,0,ID_BMHD,sizeof(struct BitMapHeader)))
                        if (WriteChunkBytes(iff,&bmhd,sizeof(struct BitMapHeader)) == sizeof(struct BitMapHeader))
                            if (!PopChunk(iff))

                                if (!PushChunk(iff,0,ID_CMAP,IFFSIZE_UNKNOWN))
                                    if (WriteChunkRecords(iff,pref->pp_Colors,sizeof(struct ColorRegister),1<<MAXDEPTH) == (1<<MAXDEPTH))
                                        if (!PopChunk(iff))

                                            if (!PushChunk(iff,0,ID_BODY,2))
                                                if (WriteChunkBytes(iff,&empty,2) == 2)
                                                    if (!PopChunk(iff))

                                                        if (!PopChunk(iff))
                                                            status = ES_NORMAL;
                CloseIFF(iff);
            }
            FreeIFF(iff);
        }
        Close(file);
        SetProtection(name,FIBF_EXECUTE);
    }
    else
    {
        status = ES_DOSERROR;
        ed->ed_SecondaryResult = IoErr();
    }

    return(status);
}


/*****************************************************************************/
d437 3
a439 3
#define NW_WIDTH     310
#define NW_HEIGHT    91
#define	NW_IDCMP     (IDCMP_MOUSEBUTTONS | IDCMP_MENUPICK | IDCMP_REFRESHWINDOW | IDCMP_INTUITICKS | BUTTONIDCMP | CHECKBOXIDCMP | SLIDERIDCMP | CYCLEIDCMP | TEXTIDCMP | LISTVIEWIDCMP)
d448 5
a452 5
    {NM_TITLE,  MSG_PROJECT_MENU,           EC_NOP, 0},
      {NM_ITEM, MSG_PROJECT_OPEN,           EC_OPEN, 0},
      {NM_ITEM, MSG_PROJECT_SAVE_AS,        EC_SAVEAS, 0},
      {NM_ITEM, MSG_NOTHING,                EC_NOP, 0},
      {NM_ITEM, MSG_PROJECT_QUIT,           EC_CANCEL, 0},
d454 2
a455 2
    {NM_TITLE,  MSG_EDIT_MENU,              EC_NOP, 0},
      {NM_ITEM, MSG_EDIT_RESET_TO_DEFAULTS, EC_RESETALL, 0},
d457 12
a468 12
      {NM_ITEM, MSG_EDIT_RESTORE,           EC_RESTORE, 0},
      {NM_ITEM, MSG_PAL_EDIT_PRESETS,	    EC_PRESET1, 0},
        {NM_SUB,MSG_PAL_EDIT_PRESET1,	    EC_PRESET1, 0},
        {NM_SUB,MSG_PAL_EDIT_PRESET2,	    EC_PRESET2, 0},
        {NM_SUB,MSG_PAL_EDIT_PRESET3,	    EC_PRESET3, 0},
        {NM_SUB,MSG_PAL_EDIT_PRESET4,	    EC_PRESET4, 0},
        {NM_SUB,MSG_PAL_EDIT_PRESET5,	    EC_PRESET5, 0},
        {NM_SUB,MSG_PAL_EDIT_PRESET6,	    EC_PRESET6, 0},
        {NM_SUB,MSG_PAL_EDIT_PRESET7,	    EC_PRESET7, 0},
        {NM_SUB,MSG_PAL_EDIT_PRESET8,	    EC_PRESET8, 0},
        {NM_SUB,MSG_NOTHING,                EC_NOP, 0},
        {NM_SUB,MSG_PAL_EDIT_PRESET9,	    EC_PRESET9, 0},
d470 1
a470 1
    {NM_TITLE,  MSG_OPTIONS_MENU,           EC_NOP, 0},
d472 3
d479 3
d484 3
a486 3
    {BUTTON_KIND,   8,    74,  87,  14, MSG_SAVE_GAD,         EC_SAVE,    0},
    {BUTTON_KIND,   111,  74,  87,  14, MSG_USE_GAD,          EC_USE,     0},
    {BUTTON_KIND,   215,  74,  87,  14, MSG_CANCEL_GAD,       EC_CANCEL,  0},
d488 10
a497 5
    {SLIDER_KIND,   122,  27,  180, 11, MSG_PAL_RED_GAD,          EC_RED,     0},
    {SLIDER_KIND,   122,  40,  180, 11, MSG_PAL_GREEN_GAD,        EC_GREEN,   0},
    {SLIDER_KIND,   122,  53,  180, 11, MSG_PAL_BLUE_GAD,         EC_BLUE,    0},
    {PALETTE_KIND,  50,   3,   252, 20, MSG_NOTHING,          EC_PALETTE, 0}
};
d521 182
d709 6
d716 2
a717 3
UWORD              extra;
struct EdMenu      stash[sizeof(EM)/sizeof(struct EdMenu)];
UWORD              maxBit;
d722 1
a722 1
    zoomSize[3] = ed->ed_Screen->WBorTop + ed->ed_Screen->Font->ta_YSize + 1;
d725 26
d754 3
a756 1
        CopyMem(&stash[20],&stash[18],3*sizeof(struct EdMenu));
d759 1
a759 1
    id = GetVPModeID(&ed->ed_Screen->ViewPort);
d761 23
d785 2
a786 2
        FreeMenus(ed->ed_Menus);
        return(FALSE);
d788 1
d790 2
a791 1
    if (GfxBase->lib_Version >= 39)
d793 2
a794 17
        ed->ed_RedBits   = CheckBitRange(ed,di.RedBits);
        ed->ed_GreenBits = CheckBitRange(ed,di.GreenBits);
        ed->ed_BlueBits  = CheckBitRange(ed,di.BlueBits);
    }
    else
    {
        maxBit = 0;
        while (di.PaletteRange > 1)
        {
            maxBit++;
            di.PaletteRange = di.PaletteRange / 2;
        }
        maxBit = maxBit / 3;

        ed->ed_RedBits   = CheckBitRange(ed,maxBit);
        ed->ed_GreenBits = ed->ed_RedBits;
        ed->ed_BlueBits  = ed->ed_RedBits;
d796 23
d820 6
a825 3
    depth = ed->ed_Screen->BitMap.Depth;
    if (depth > MAXDEPTH)
        depth = MAXDEPTH;
d827 14
a840 3
    extra = 0;
    if (depth > 4)
        extra = 40;
d842 18
a859 1
    ed->ed_LastAdded = CreateContext(&ed->ed_Gadgets);
d861 10
a870 3
    eg = EG[0];
    eg.eg_TopEdge += extra;
    DoPrefsGadget(ed,&eg,NULL,TAG_DONE);
d872 3
a874 3
    eg = EG[1];
    eg.eg_TopEdge += extra;
    DoPrefsGadget(ed,&eg,NULL,TAG_DONE);
d876 4
a879 3
    eg = EG[2];
    eg.eg_TopEdge += extra;
    DoPrefsGadget(ed,&eg,NULL,TAG_DONE);
a882 9
    eg = EG[6];
    eg.eg_LeftEdge -= extra;
    eg.eg_Width    += extra;
    eg.eg_Height   += extra;
    DoPrefsGadget(ed,&eg,NULL,GTPA_Depth,          depth,
                              GTPA_Color,          0,
                              GTPA_IndicatorWidth, 40+extra,
                              TAG_DONE);

d885 2
a886 2
    &&  (ed->ed_Window = OpenPrefsWindow(ed,WA_InnerWidth,    NW_WIDTH,
                                            WA_InnerHeight,   NW_HEIGHT+extra,
d888 1
a888 1
                                            WA_MinHeight,     NW_MINHEIGHT,
d895 1
a895 1
                                            WA_PubScreen,     ed->ed_Screen,
d901 12
d924 1
a924 1
VOID DisposeDisplay(EdDataPtr ed)
d926 4
a929 1
    if (ed->ed_Window)
d931 25
a955 2
        ClearMenuStrip(ed->ed_Window);
        CloseWindow(ed->ed_Window);
d957 13
d972 47
a1018 1
}
d1020 36
d1057 4
a1060 1
/*****************************************************************************/
d1062 11
d1074 2
a1075 2
/* value is in the current bit size */
ULONG Make8(EdDataPtr ed, ULONG value, ULONG bits)
d1080 1
a1080 1
    if (bits == 8)
d1083 1
a1083 1
    mask   = value << (8 - bits);
d1098 1
a1098 1
ULONG Make32(EdDataPtr ed, ULONG eight)
d1100 1
a1100 1
    return( (eight<<24) + (eight<<16) + (eight<<8) + eight );
d1107 1
a1107 1
VOID SetRGB8(EdDataPtr ed, UWORD color, ULONG r, ULONG g, ULONG b)
d1109 28
a1136 2
    if (GfxBase->lib_Version >= 39)
        SetRGB32(&ed->ed_Screen->ViewPort,color,Make32(ed,r),Make32(ed,g),Make32(ed,b));
d1138 20
a1157 1
        SetRGB4(&ed->ed_Screen->ViewPort,color,r >> 4,g >> 4,b >> 4);
d1164 1
a1164 1
VOID SetColors(EdDataPtr ed)
d1166 1
a1166 3
UWORD                 color;
UWORD		      maxColor;
struct ColorRegister *prefs;
d1168 33
a1200 9
    prefs = ed->ed_PrefsWork.pp_Colors;

    maxColor = (1<<ed->ed_Screen->BitMap.Depth);
    if (maxColor > MAXCOLORS)
        maxColor = MAXCOLORS;

    for (color = 0; color < maxColor; color++)
        SetRGB8(ed,color,prefs[color].red,prefs[color].green,prefs[color].blue);
}
d1208 1
a1208 2
UWORD                 color;
struct ColorRegister *prefs;
d1210 3
a1212 1
UWORD                 extra;
d1214 24
a1237 6
    extra = 0;
    if ((MAXDEPTH > 4) && (ed->ed_Screen->BitMap.Depth > 4))
        extra = 40;

    color = ed->ed_CurrentColor;
    prefs = ed->ed_PrefsWork.pp_Colors;
d1239 2
a1240 4
    eg = EG[3];
    eg.eg_TopEdge += extra;
    ed->ed_Red = DoPrefsGadget(ed,&eg,ed->ed_Red,
                                      GTSL_Level,       prefs[color].red >> (HIGHBITSPERGUN-ed->ed_RedBits),
d1242 1
a1242 1
                                      GTSL_Max,         (1<<ed->ed_RedBits)-1,
d1249 6
a1254 4
    eg = EG[4];
    eg.eg_TopEdge += extra;
    ed->ed_Green = DoPrefsGadget(ed,&eg,ed->ed_Green,
                                        GTSL_Level,       prefs[color].green >> (HIGHBITSPERGUN-ed->ed_GreenBits),
d1256 1
a1256 1
                                        GTSL_Max,         (1<<ed->ed_GreenBits)-1,
d1263 6
a1268 4
    eg = EG[5];
    eg.eg_TopEdge += extra;
    ed->ed_Blue = DoPrefsGadget(ed,&eg,ed->ed_Blue,
                                       GTSL_Level,       prefs[color].blue >> (HIGHBITSPERGUN-ed->ed_BlueBits),
d1270 1
a1270 1
                                       GTSL_Max,         (1<<ed->ed_BlueBits)-1,
d1282 98
d1382 12
d1395 31
a1425 1
    SetColors(ed);
a1434 1
BOOL                  refresh;
d1438 5
a1442 1
struct ColorRegister *prefs;
a1444 1
    refresh = FALSE;
d1446 1
d1448 6
a1453 1
    prefs   = ed->ed_PrefsWork.pp_Colors;
d1457 164
a1620 36
        case EC_PALETTE     : ed->ed_CurrentColor = icode;
                              refresh = TRUE;
                              break;

        case EC_RED         : prefs[color].red = Make8(ed,icode,ed->ed_RedBits);
                              docolor = TRUE;
                              break;

        case EC_GREEN       : prefs[color].green = Make8(ed,icode,ed->ed_GreenBits);
                              docolor = TRUE;
                              break;

        case EC_BLUE        : prefs[color].blue = Make8(ed,icode,ed->ed_BlueBits);
                              docolor = TRUE;
                              break;

        case EC_PRESET1     :
        case EC_PRESET2     :
        case EC_PRESET3     :
        case EC_PRESET4     :
        case EC_PRESET5     :
        case EC_PRESET6     :
        case EC_PRESET7     :
        case EC_PRESET8     :
        case EC_PRESET9     : preset = &Presets[ec-EC_PRESET1];
                              for (i=0; i<4; i++)
                              {
                                  prefs[i].red   = Make8(ed,(preset->Colors[i] / 256) % 16,4);
                                  prefs[i].green = Make8(ed,(preset->Colors[i] / 16) % 16,4);
                                  prefs[i].blue  = Make8(ed,preset->Colors[i] % 16,4);
                              }
                              SetColors(ed);
                              refresh = TRUE;
                              break;

        default             : break;
d1624 5
a1628 1
        SetRGB8(ed,color,prefs[color].red,prefs[color].green,prefs[color].blue);
d1630 10
a1639 3
    if (refresh)
        DoSliders(ed);
}
d1649 18
@


38.21
log
@Now supports N bits per gun, for N < 8
@
text
@a374 2
#define NW_LEFT      0
#define NW_TOP       0
d459 2
a460 2
    zoomSize[0] = NW_LEFT;
    zoomSize[1] = NW_TOP;
d534 1
a534 3
    &&  (ed->ed_Window = OpenPrefsWindow(ed,WA_Left,          NW_LEFT,
                                            WA_Top,           NW_TOP,
                                            WA_InnerWidth,    NW_WIDTH,
@


38.20
log
@Fixed bug in screens with more than MAXDEPTH planes
@
text
@d55 1
a55 1
ULONG Make8(EdDataPtr ed, ULONG four);
d190 4
a193 1
UWORD              i,color,maxColor;
d195 1
d199 3
a201 3
        ed->ed_PrefsDefaults.pp_Colors[i].red   = Make8(ed,(Defaults[i] / 256) % 16);
        ed->ed_PrefsDefaults.pp_Colors[i].green = Make8(ed,(Defaults[i] / 16) % 16);
        ed->ed_PrefsDefaults.pp_Colors[i].blue  = Make8(ed,Defaults[i] % 16);
d226 3
a228 3
                ed->ed_PrefsDefaults.pp_Colors[i].red   = Make8(ed,(color >> 8) % 16);
                ed->ed_PrefsDefaults.pp_Colors[i].green = Make8(ed,(color >> 4) % 16);
                ed->ed_PrefsDefaults.pp_Colors[i].blue  = Make8(ed,color % 16);
d439 1
a439 1

d442 1
a442 1

d459 1
d473 6
a478 3
    di.RedBits   = LOWBITSPERGUN;
    di.GreenBits = LOWBITSPERGUN;
    di.BlueBits  = LOWBITSPERGUN;
d482 8
a489 2
        id = GetVPModeID(&ed->ed_Screen->ViewPort);
        if (!GetDisplayInfoData(NULL,(APTR)&di,sizeof(struct DisplayInfo),DTAG_DISP,id))
d491 2
a492 2
            FreeMenus(ed->ed_Menus);
            return(FALSE);
d494 5
a500 4
    ed->ed_RedBits   = CheckBitRange(ed,di.RedBits);
    ed->ed_GreenBits = CheckBitRange(ed,di.GreenBits);
    ed->ed_BlueBits  = CheckBitRange(ed,di.BlueBits);

d580 2
a581 1
ULONG Make8(EdDataPtr ed, ULONG four)
d583 16
a598 2
    return( (four<<4) + four );
}
d731 1
a731 5
        case EC_RED         : if (ed->ed_RedBits == LOWBITSPERGUN)
                                  prefs[color].red = Make8(ed,icode);
                              else
                                  prefs[color].red = icode;

d735 1
a735 5
        case EC_GREEN       : if (ed->ed_GreenBits == LOWBITSPERGUN)
                                  prefs[color].green = Make8(ed,icode);
                              else
                                  prefs[color].green = icode;

d739 1
a739 5
        case EC_BLUE        : if (ed->ed_BlueBits == LOWBITSPERGUN)
                                  prefs[color].blue = Make8(ed,icode);
                              else
                                  prefs[color].blue = icode;

d754 3
a756 3
                                  prefs[i].red   = Make8(ed,(preset->Colors[i] / 256) % 16);
                                  prefs[i].green = Make8(ed,(preset->Colors[i] / 16) % 16);
                                  prefs[i].blue  = Make8(ed,preset->Colors[i] % 16);
@


38.19
log
@No longer shows A2024 preset when no A2024 is available
@
text
@d623 1
a623 1
    if (ed->ed_Screen->BitMap.Depth > 4)
@


38.18
log
@Fixed presets
@
text
@d202 1
d227 1
a227 1

d454 1
d461 7
d520 1
a520 1
    &&  (ed->ed_Menus = CreatePrefsMenus(ed,EM))
@


38.17
log
@No longers calls SetRGB4/32() for each color whenever a new color is selected
@
text
@d731 1
@


38.16
log
@*** empty log message ***
@
text
@d606 1
a606 1
VOID RenderGadgets(EdDataPtr ed)
d655 5
d661 3
d741 1
a741 1
        RenderGadgets(ed);
@


38.15
log
@Changes for new prefs shell
@
text
@d628 2
a629 1
                                      GA_RELVERIFY,     TRUE,
d640 2
a641 1
                                        GA_RELVERIFY,     TRUE,
d652 2
a653 1
                                       GA_RELVERIFY,     TRUE,
@


38.14
log
@Removed kprintf()
@
text
@a605 9

VOID RenderDisplay(EdDataPtr ed)
{
}


/*****************************************************************************/


a659 8
VOID SyncTextGadgets(EdDataPtr ed)
{
}


/*****************************************************************************/


a730 9
}


/*****************************************************************************/


EdCommand GetCommand(EdDataPtr ed)
{
    return(EC_NOP);
@


38.13
log
@Correctly clones colors > 15 from the current WB screen if the prefs file being
  loaded doesn't have these colors.
@
text
@a259 1
kprintf("2: red=%ld, green=%ld,blue=%ld\n",ed->ed_PrefsWork.pp_Colors[17].red,ed->ed_PrefsWork.pp_Colors[17].green,ed->ed_PrefsWork.pp_Colors[17].blue);
@


38.12
log
@Removed redundant GTSL_Level tag
@
text
@d205 2
d208 1
a208 1
        for (i=17; i<maxColor; i++)
d220 3
a222 2
                ed->ed_PrefsDefaults.pp_Colors[i].red   = Make8(ed,(color >> 256) % 16);
                ed->ed_PrefsDefaults.pp_Colors[i].green = Make8(ed,(color >> 16) % 16);
d260 1
@


38.11
log
@Added SyncTextGadgets() support
@
text
@a644 1
                                        GTSL_Level,       prefs[color].green >> (HIGHBITSPERGUN-ed->ed_GreenBits),
@


38.10
log
@Now gets its initial default palette from the Workbench screen instead of the
  default public screen
Now keeps the screen locked until it is done poking its colors
@
text
@a455 5
    if (!(ed->ed_Menus = CreatePrefsMenus(ed,EM)))
    {
	return(FALSE);
    }

d507 19
a525 23
    if (!ed->ed_LastAdded)
    {
        DisposeDisplay(ed);
        return(FALSE);
    }

    if (!(ed->ed_Window = OpenPrefsWindow(ed,WA_Left,          NW_LEFT,
                                             WA_Top,           NW_TOP,
                                             WA_InnerWidth,    NW_WIDTH,
                                             WA_InnerHeight,   NW_HEIGHT+extra,
                                             WA_MinWidth,      NW_MINWIDTH,
                                             WA_MinHeight,     NW_MINHEIGHT,
                                             WA_MaxWidth,      NW_MAXWIDTH,
                                             WA_MaxHeight,     NW_MAXHEIGHT,
                                             WA_IDCMP,         NW_IDCMP,
                                             WA_Flags,         NW_FLAGS,
                                             WA_Zoom,          zoomSize,
                                             WA_AutoAdjust,    TRUE,
                                             WA_PubScreen,     ed->ed_Screen,
                                             WA_Title,         GetString(&ed->ed_LocaleInfo,MSG_PAL_NAME),
                                             WA_NewLookMenus,  TRUE,
                                             WA_Gadgets,       ed->ed_Gadgets,
                                             TAG_DONE)))
d527 1
a527 2
        DisposeDisplay(ed);
	return(FALSE);
d530 2
a531 1
    return(TRUE);
d661 8
@


38.9
log
@Made color indicator wider when >4 plane
@
text
@a190 1
struct Screen     *sp;
d200 1
a200 1
    if (sp = LockPubScreen(NULL))
d202 1
a202 1
        maxColor = (1<<sp->BitMap.Depth);
d210 1
a210 1
                GetRGB32(sp->ViewPort.ColorMap,i,1,(ULONG *)&colors);
d217 1
a217 1
                color = GetRGB4(sp->ViewPort.ColorMap,i);
d223 5
a227 1
        UnlockPubScreen(NULL,sp);
d230 1
a230 4
    ed->ed_PrefsWork    = ed->ed_PrefsDefaults;
    ed->ed_PrefsInitial = ed->ed_PrefsDefaults;

    return(ES_NORMAL);
d244 1
@


38.8
log
@Corrected >4 plane operation
Made window taller when in >4 plane 
@
text
@d503 3
a505 1
    eg.eg_Height += extra;
d508 1
a508 1
                              GTPA_IndicatorWidth, 40,
@


38.7
log
@Now uses DoPrefsGadget instead of CreatePrefsGadget for better look upon window
  opening
@
text
@d182 5
d190 3
a192 1
UWORD i;
d201 26
d447 2
d464 1
a464 1
    if (GfxBase->lib_Version >= 38)
d482 4
d487 4
a490 3
    DoPrefsGadget(ed,&EG[0],NULL,TAG_DONE);
    DoPrefsGadget(ed,&EG[1],NULL,TAG_DONE);
    DoPrefsGadget(ed,&EG[2],NULL,TAG_DONE);
d492 8
d502 6
a507 4
    DoPrefsGadget(ed,&EG[6],NULL,GTPA_Depth,          depth,
                                 GTPA_Color,          0,
                                 GTPA_IndicatorWidth, 40,
                                 TAG_DONE);
d518 1
a518 1
                                             WA_InnerHeight,   NW_HEIGHT,
d579 1
a579 1
    if (GfxBase->lib_Version >= 38)
d592 1
d597 5
a601 1
    for (color = 0; color < (1<<ed->ed_Screen->BitMap.Depth); color++)
d622 6
d632 33
a664 27
    ed->ed_Red = DoPrefsGadget(ed,&EG[3],ed->ed_Red,
                                         GTSL_Level,       prefs[color].red >> (HIGHBITSPERGUN-ed->ed_RedBits),
                                         GTSL_Min,         0,
                                         GTSL_Max,         (1<<ed->ed_RedBits)-1,
                                         GTSL_MaxLevelLen, 3,
                                         GTSL_LevelFormat, "%3ld",
                                         GA_RELVERIFY,     TRUE,
                                         TAG_DONE);

    ed->ed_Green = DoPrefsGadget(ed,&EG[4],ed->ed_Green,
                                           GTSL_Level,       prefs[color].green >> (HIGHBITSPERGUN-ed->ed_GreenBits),
                                           GTSL_Min,         0,
                                           GTSL_Max,         (1<<ed->ed_GreenBits)-1,
                                           GTSL_MaxLevelLen, 3,
                                           GTSL_LevelFormat, "%3ld",
                                           GTSL_Level,       prefs[color].green >> (HIGHBITSPERGUN-ed->ed_GreenBits),
                                           GA_RELVERIFY,     TRUE,
                                           TAG_DONE);

    ed->ed_Blue = DoPrefsGadget(ed,&EG[5],ed->ed_Blue,
                                          GTSL_Level,       prefs[color].blue >> (HIGHBITSPERGUN-ed->ed_BlueBits),
                                          GTSL_Min,         0,
                                          GTSL_Max,         (1<<ed->ed_BlueBits)-1,
                                          GTSL_MaxLevelLen, 3,
                                          GTSL_LevelFormat, "%3ld",
                                          GA_RELVERIFY,     TRUE,
                                          TAG_DONE);
@


38.6
log
@Now uses WA_Gadgets to add the gadgets to the window
@
text
@d410 4
a413 6
UWORD                  zoomSize[4];
ULONG                  id;
UWORD		       depth;
struct DisplayInfo     di;
UWORD                 color;
struct ColorRegister *prefs;
a446 3
    color = ed->ed_CurrentColor;
    prefs = ed->ed_PrefsWork.pp_Colors;

d448 3
a450 3
    CreatePrefsGadget(ed,&EG[0],TAG_DONE);
    CreatePrefsGadget(ed,&EG[1],TAG_DONE);
    CreatePrefsGadget(ed,&EG[2],TAG_DONE);
d452 1
a452 28
    ed->ed_Red = CreatePrefsGadget(ed,&EG[3],GTSL_Min,         0,
                                             GTSL_Max,         (1<<ed->ed_RedBits)-1,
                                             GTSL_MaxLevelLen, 3,
                                             GTSL_LevelFormat, "%3ld",
                                             GTSL_Level,       prefs[color].red >> (HIGHBITSPERGUN-ed->ed_RedBits),
                                             GA_RELVERIFY,     TRUE,
                                             TAG_DONE);

    ed->ed_Green = CreatePrefsGadget(ed,&EG[4],GTSL_Min,         0,
                                               GTSL_Max,         (1<<ed->ed_GreenBits)-1,
                                               GTSL_MaxLevelLen, 3,
                                               GTSL_LevelFormat, "%3ld",
                                               GTSL_Level,       prefs[color].green >> (HIGHBITSPERGUN-ed->ed_GreenBits),
                                               GA_RELVERIFY,     TRUE,
                                               TAG_DONE);

    ed->ed_Blue = CreatePrefsGadget(ed,&EG[5],GTSL_Min,         0,
                                              GTSL_Max,         (1<<ed->ed_BlueBits)-1,
                                              GTSL_MaxLevelLen, 3,
                                              GTSL_LevelFormat, "%3ld",
                                              GTSL_Level,       prefs[color].blue >> (HIGHBITSPERGUN-ed->ed_BlueBits),
                                              GA_RELVERIFY,     TRUE,
                                              TAG_DONE);

    CreatePrefsGadget(ed,&EG[6],GTPA_Depth,          depth,
                                GTPA_Color,          0,
                                GTPA_IndicatorWidth, 40,
                                TAG_DONE);
d454 4
d571 27
a597 8
    SetGadgetAttr(ed,ed->ed_Red,GTSL_Level,prefs[color].red >> (HIGHBITSPERGUN-ed->ed_RedBits),
                                TAG_DONE);

    SetGadgetAttr(ed,ed->ed_Green,GTSL_Level,prefs[color].green >> (HIGHBITSPERGUN-ed->ed_GreenBits),
                                  TAG_DONE);

    SetGadgetAttr(ed,ed->ed_Blue,GTSL_Level,prefs[color].blue >> (HIGHBITSPERGUN-ed->ed_BlueBits),
                                 TAG_DONE);
@


38.5
log
@No longer uses EC_CUSTOMCANCEL
@
text
@a444 21
    if (!(ed->ed_Window = OpenPrefsWindow(ed,WA_Left,          NW_LEFT,
                                             WA_Top,           NW_TOP,
                                             WA_InnerWidth,    NW_WIDTH,
                                             WA_InnerHeight,   NW_HEIGHT,
                                             WA_MinWidth,      NW_MINWIDTH,
                                             WA_MinHeight,     NW_MINHEIGHT,
                                             WA_MaxWidth,      NW_MAXWIDTH,
                                             WA_MaxHeight,     NW_MAXHEIGHT,
                                             WA_IDCMP,         NW_IDCMP,
                                             WA_Flags,         NW_FLAGS,
                                             WA_Zoom,          zoomSize,
                                             WA_AutoAdjust,    TRUE,
                                             WA_PubScreen,     ed->ed_Screen,
                                             WA_Title,         GetString(&ed->ed_LocaleInfo,MSG_PAL_NAME),
                                             WA_NewLookMenus,  TRUE,
                                             TAG_DONE)))
    {
        FreeMenus(ed->ed_Menus);
	return(FALSE);
    }

d493 22
d524 5
a528 2
    ClearMenuStrip(ed->ed_Window);
    CloseWindow(ed->ed_Window);
@


38.4
log
@Changes for new prefs shell
Less flickering when window opens
@
text
@d167 1
d169 1
d206 5
d350 1
a350 1
      {NM_ITEM, MSG_PROJECT_QUIT,           EC_CUSTOMCANCEL, 0},
d378 1
a378 1
    {BUTTON_KIND,   215,  74,  87,  14, MSG_CANCEL_GAD,       EC_CUSTOMCANCEL,  0},
a627 5
        case EC_CUSTOMCANCEL: ed->ed_Quit      = TRUE;
                              ed->ed_PrefsWork = ed->ed_PrefsInitial;
                              SetColors(ed);
                              break;

@


38.3
log
@Changes for new pe_strings.c prefs shell module
@
text
@d210 1
a210 1
EdStatus OpenPrefs(EdDataPtr ed, STRPTR name, APTR destPrefs)
d231 1
a231 1
                        if (ReadChunkRecords(iff,destPrefs,sizeof(struct ColorRegister),MAXCOLORS))
d253 1
a253 1
EdStatus SavePrefs(EdDataPtr ed, STRPTR name, APTR sourPrefs)
d262 1
a262 1
    pref                  = sourPrefs;
d403 6
a408 4
UWORD              zoomSize[4];
ULONG              id;
UWORD		   depth;
struct DisplayInfo di;
d463 3
d475 1
d483 1
d491 1
d503 1
a503 3
        CloseWindow(ed->ed_Window);
        FreeMenus(ed->ed_Menus);
        FreeGadgets(ed->ed_Gadgets);
a506 6
    SetFont(ed->ed_Window->RPort,ed->ed_Font);
    SetMenuStrip(ed->ed_Window,ed->ed_Menus);
    AddGList(ed->ed_Window,ed->ed_Gadgets,-1,-1,NULL);
    RefreshGList(ed->ed_Gadgets,ed->ed_Window,NULL,-1);
    GT_RefreshWindow(ed->ed_Window,NULL);

d613 1
a613 1
    icode   = ed->ed_CurrentMsg->Code;
a698 3

    if (ec == EC_SAVEICONS)
        state->cs_Selected = ed->ed_SaveIcons;
@


38.2
log
@Changes for new prefs shell
@
text
@d44 1
a44 1
#include "texttable.h"
d349 9
a357 9
      {NM_ITEM, MSG_EDIT_PRESETS,	    EC_PRESET1, 0},
        {NM_SUB,MSG_EDIT_PRESET1,	    EC_PRESET1, 0},
        {NM_SUB,MSG_EDIT_PRESET2,	    EC_PRESET2, 0},
        {NM_SUB,MSG_EDIT_PRESET3,	    EC_PRESET3, 0},
        {NM_SUB,MSG_EDIT_PRESET4,	    EC_PRESET4, 0},
        {NM_SUB,MSG_EDIT_PRESET5,	    EC_PRESET5, 0},
        {NM_SUB,MSG_EDIT_PRESET6,	    EC_PRESET6, 0},
        {NM_SUB,MSG_EDIT_PRESET7,	    EC_PRESET7, 0},
        {NM_SUB,MSG_EDIT_PRESET8,	    EC_PRESET8, 0},
d359 1
a359 1
        {NM_SUB,MSG_EDIT_PRESET9,	    EC_PRESET9, 0},
d373 3
a375 3
    {SLIDER_KIND,   122,  27,  180, 11, MSG_RED_GAD,          EC_RED,     0},
    {SLIDER_KIND,   122,  40,  180, 11, MSG_GREEN_GAD,        EC_GREEN,   0},
    {SLIDER_KIND,   122,  53,  180, 11, MSG_BLUE_GAD,         EC_BLUE,    0},
d449 1
a449 1
                                             WA_Title,         EDITOR_NAME,
@


38.1
log
@Initial V38 RCS checkin
@
text
@d171 10
a193 2

    ed->ed_Args[OPT_SCREEN] = (ULONG)"Workbench";
@
