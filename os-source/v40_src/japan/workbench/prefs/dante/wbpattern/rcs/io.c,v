head     38.9;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


38.9
date     92.07.31.15.38.49;  author davidj;  state Exp;
branches ;
next     38.8;

38.8
date     92.07.29.14.36.59;  author davidj;  state Exp;
branches ;
next     38.7;

38.7
date     92.06.16.15.00.16;  author davidj;  state Exp;
branches ;
next     38.6;

38.6
date     92.06.12.00.42.56;  author davidj;  state Exp;
branches ;
next     38.5;

38.5
date     92.06.10.02.20.51;  author davidj;  state Exp;
branches ;
next     38.4;

38.4
date     92.03.02.11.18.41;  author davidj;  state Exp;
branches ;
next     38.3;

38.3
date     92.01.23.10.50.02;  author davidj;  state Exp;
branches ;
next     38.2;

38.2
date     91.11.26.13.36.52;  author davidj;  state Exp;
branches ;
next     38.1;

38.1
date     91.11.12.10.54.58;  author Unknown;  state Exp;
branches ;
next     ;


desc
@wbpattern file i/o
@


38.9
log
@wasn't null terminating the buffer.
@
text
@/* io.c
 *
 */

#include "wbpattern.h"

/*****************************************************************************/

#define SIZEPERPLANE	(16 * sizeof(UWORD))
#define	WBPHSIZE	(sizeof(struct WBPatHeader))

/*****************************************************************************/

/* The PrefHeader structure this editor outputs */
static struct PrefHeader far IFFPrefHeader =
{
    0,				/* version */
    0,				/* type    */
    0				/* flags   */
};

/*****************************************************************************/

/* The IFF chunks known to this prefs editor. IFFPrefChunkCnt says how many
 * chunks there are
 */
#define IFFPrefChunkCnt 2
static LONG far IFFPrefChunks[] =
{
    ID_PREF, ID_PRHD,
    ID_PREF, ID_PTRN,
};

/*****************************************************************************/

VOID UpdateSketch (EdDataPtr ed)
{

    if (ed->ed_GSketch)
    {
	/* Show that the bitmap has been updated */
	setgadgetattrs (ed, ed->ed_GSketch,
			SPA_Update, TRUE,
			TAG_DONE);

	/* Draw the repeat area */
	RefreshRepeats (ed);
    }
}

/*****************************************************************************/

EdStatus ReadPrefs(EdDataPtr ed, struct IFFHandle *iff, struct ContextNode *cn)
{
    struct BitMap *bm = &ed->ed_Temp;
    EdStatus result = ES_IFFERROR;
    struct WBPatternPrefs *wbp;
    struct WBPatternPrefs tmp;
    BOOL ok = TRUE;
    WORD plane;

    if (cn->cn_ID != ID_PTRN || cn->cn_Type != ID_PREF)
        return(ES_IFF_UNKNOWNCHUNK);

    if (ReadChunkBytes(iff, &tmp, sizeof(struct WBPatternPrefs)) == sizeof(struct WBPatternPrefs))
    {
        result = ES_NORMAL;

	wbp = &ed->ed_PrefsWork.ep_WBP[tmp.wbp_Which];
	CopyMem (&tmp, wbp, sizeof (struct WBPatternPrefs));

	if (wbp->wbp_Flags & WBPF_PATTERN)
	{
	    for (plane = 0; plane < bm->Depth; plane++)
	    {
		if (plane < wbp->wbp_Depth)
		{
		    if (ok)
		    {
			if (ReadChunkBytes (iff, (char *)bm->Planes[plane], SIZEPERPLANE) != SIZEPERPLANE)
			    ok = FALSE;
		    }
		    else
		    {
			result = ES_DOSERROR;
			ed->ed_SecondaryResult = IoErr ();
		    }
		}
		else if (plane < 3)
		    memset (bm->Planes[plane], 0, SIZEPERPLANE);
	    }

	    if (ok)
		bltbm (bm, 0, 0,
		       &ed->ed_PrefsWork.ep_BMap,
		       wbp->wbp_Which * ed->ed_Width, 0,
		       ed->ed_Width, ed->ed_Height,
		       0xC0, 0xFF, NULL, ed->ed_GfxBase);
	}
	else
	{
	    ReadChunkBytes (iff, (char *)&ed->ed_PrefsWork.ep_Path[tmp.wbp_Which][0], wbp->wbp_DataLength);

	    /* NULL terminate the buffer */
	    ed->ed_PrefsWork.ep_Path[tmp.wbp_Which][wbp->wbp_DataLength] = 0;
	}

	/* Set the current type */
	ed->ed_Type  = 0x1 & (ed->ed_PrefsWork.ep_WBP[(ed->ed_Which/ed->ed_Width)].wbp_Flags);
    }

    return(result);
}

/*****************************************************************************/

EdStatus OpenPrefs (EdDataPtr ed, STRPTR name)
{
    EdStatus result;

    result = ReadIFF (ed, name, IFFPrefChunks, IFFPrefChunkCnt, ReadPrefs);

    /* Update the sketchpad */
    UpdateSketch (ed);

    return (result);
}

/*****************************************************************************/

EdStatus WritePrefs (EdDataPtr ed, struct IFFHandle * iff, struct ContextNode * cn)
{
    EdStatus result = ES_NORMAL;
    UWORD depth = ed->ed_Depth;
    struct WBPatternPrefs *wbp;
    struct BitMap *bm;
    BOOL ok = TRUE;
    WORD i, j, k;
    WORD found;
    char *ptr;

    if (ed->ed_Screen)
	depth = MIN (ed->ed_Depth, ed->ed_Screen->BitMap.Depth);
    depth = MIN (depth, 3);

    for (i = 0; i < 3; i++)
    {
	wbp = &ed->ed_PrefsWork.ep_WBP[i];
	wbp->wbp_Which = i;
	if (!(PushChunk (iff, 0, ID_PTRN, IFFSIZE_UNKNOWN)))
	{
	    if (wbp->wbp_Flags & WBPF_PATTERN)
	    {
		bm = &ed->ed_Temp;
		bltbm (&ed->ed_PrefsWork.ep_BMap,
		       (i * ed->ed_Width), 0,
		       bm, 0, 0, ed->ed_Width, ed->ed_Height,
		       0xC0, 0xFF, NULL, ed->ed_GfxBase);

		/* See if there is anything in the bitmap */
		for (j = found = 0; (j < depth) && (found == 0); j++)
		{
		    ptr = (char *)bm->Planes[j];
		    for (k = 0; (k < SIZEPERPLANE) && (found == 0); k++)
		    {
			if (ptr[k])
			    found++;
		    }
		}

		/* Fill in the pref structure */
		wbp->wbp_DataLength = ed->ed_Height * 2L * depth;
		wbp->wbp_Revision   = 0;
		wbp->wbp_Depth      = (found) ? depth : 0;
	    }
	    else
		wbp->wbp_DataLength = strlen (&ed->ed_PrefsWork.ep_Path[i][0]);

	    if (WriteChunkBytes (iff, wbp, sizeof (struct WBPatternPrefs)) == sizeof (struct WBPatternPrefs))
	    {
		if (wbp->wbp_Flags & WBPF_PATTERN)
		{
		    for (j = 0; j < depth; j++)
		    {
			if (ok)
			{
			    if (WriteChunkBytes (iff, (char *)bm->Planes[j], SIZEPERPLANE) != SIZEPERPLANE)
			    {
				ok = FALSE;
			    }
			}
			else
			{
			    result = ES_DOSERROR;
			    ed->ed_SecondaryResult = IoErr ();
			}
		    }
		}
		else
		    WriteChunkBytes (iff, (char *)&ed->ed_PrefsWork.ep_Path[i][0], wbp->wbp_DataLength);

		PopChunk (iff);
	    }
	}
    }
    return (result);
}

/*****************************************************************************/

EdStatus SavePrefs (EdDataPtr ed, STRPTR name)
{
    return (WriteIFF (ed, name, &IFFPrefHeader, WritePrefs));
}

/*****************************************************************************/

/* Data created by ILBMer, written by David N. Junod */

#include <exec/types.h>
#include <graphics/gfx.h>

static UBYTE chip Presets_P0[] =
{
    0xFF, 0xFC, 0x2A, 0xAA, 0x7F, 0xFE, 0x00, 0x00, 0xFF,
    0xFD, 0x95, 0x55, 0x40, 0x00, 0x00, 0x01, 0xFF, 0xFF,
    0xCA, 0xAB, 0x40, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x65,
    0x56, 0x40, 0x00, 0x10, 0x05, 0xFF, 0xFF, 0x32, 0xAC,
    0x40, 0x00, 0x00, 0x01, 0xFC, 0x7F, 0x19, 0x58, 0x40,
    0x00, 0x00, 0x01, 0xFC, 0xFF, 0x0C, 0xB0, 0x40, 0x00,
    0x00, 0x01, 0xFC, 0xFF, 0x06, 0x60, 0x40, 0x00, 0x00,
    0x01, 0xFC, 0xFF, 0x02, 0x40, 0x40, 0x00, 0x00, 0x01,
    0xFD, 0xFF, 0x01, 0x80, 0x40, 0x00, 0x00, 0x01, 0xFF,
    0xFF, 0x03, 0xC0, 0x40, 0x00, 0x00, 0x01, 0xFF, 0xFF,
    0x07, 0x60, 0x40, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x0E,
    0xB0, 0x40, 0x00, 0x00, 0x01, 0x7F, 0xFC, 0x1D, 0x58,
    0x40, 0x00, 0x10, 0x05, 0xFF, 0xFC, 0x3A, 0xAC, 0x40,
    0x00, 0x00, 0x01, 0xFF, 0xFC, 0x75, 0x56, 0x00, 0x00,
    0x7F, 0xFF, 0xAA, 0xAA, 0x00, 0x00, 0x49, 0x51, 0x00,
    0x00, 0x55, 0x55, 0x00, 0x00, 0x25, 0x48, 0x22, 0x05,
    0xAA, 0xAA, 0x00, 0x02, 0x04, 0x91, 0x01, 0x11, 0x55,
    0x55, 0x00, 0x02, 0x8A, 0x12, 0x10, 0x01, 0xAA, 0xAA,
    0x00, 0x0A, 0x10, 0xA8, 0x20, 0x25, 0x55, 0x55, 0x00,
    0x0A, 0x45, 0x04, 0x00, 0x01, 0xAA, 0xAA, 0x00, 0x2A,
    0x08, 0x51, 0x00, 0x05, 0x55, 0x55, 0x00, 0x2A, 0x05,
    0x05, 0x20, 0x21, 0xAA, 0xAA, 0x00, 0xAA, 0x82, 0x48,
    0x00, 0x01, 0x55, 0x55, 0x00, 0x2A, 0x12, 0x02, 0x08,
    0x05, 0xAA, 0xAA, 0x03, 0xEA, 0x04, 0x94, 0x00, 0x01,
    0x55, 0x55, 0x00, 0x0A, 0x10, 0x09, 0x20, 0x11, 0xAA,
    0xAA, 0x0F, 0xFA, 0x01, 0x12, 0x08, 0x45, 0x55, 0x55,
    0x00, 0x02, 0x40, 0x40, 0x20, 0x01, 0xAA, 0xAA, 0x3F,
    0xFE, 0x0A, 0x14, 0x12, 0x25, 0x55, 0x55, 0x00, 0x00,
    0x10, 0xA0, 0x7F, 0xFF,
};

static UBYTE chip Presets_P1[] =
{
    0x7F, 0xFE, 0xAA, 0xAB, 0x00, 0x00, 0xFF, 0xFF, 0x7F,
    0xFE, 0xD5, 0x57, 0x00, 0x02, 0x80, 0x00, 0xFF, 0xFF,
    0x6A, 0xAE, 0x00, 0x02, 0xA0, 0x08, 0xFF, 0xFF, 0x35,
    0x5C, 0x00, 0x02, 0x80, 0x00, 0xFF, 0xFF, 0x1A, 0xB8,
    0x00, 0x02, 0x80, 0x00, 0xFF, 0xFF, 0x0D, 0x70, 0x00,
    0x02, 0x80, 0x00, 0xFE, 0x7F, 0x06, 0xE0, 0x00, 0x02,
    0x80, 0x00, 0xFE, 0x7F, 0x03, 0xC0, 0x00, 0x02, 0x80,
    0x00, 0xFE, 0x7F, 0x01, 0x80, 0x00, 0x02, 0x80, 0x00,
    0xFE, 0x7F, 0x03, 0x40, 0x00, 0x02, 0x80, 0x00, 0xFF,
    0xFF, 0x06, 0x60, 0x00, 0x02, 0x80, 0x00, 0xFF, 0xFF,
    0x0D, 0x30, 0x00, 0x02, 0x80, 0x00, 0xFF, 0xFF, 0x1A,
    0x98, 0x00, 0x02, 0xA0, 0x08, 0xFF, 0xFF, 0x35, 0x4C,
    0x00, 0x02, 0x80, 0x00, 0x7F, 0xFE, 0x6A, 0xA6, 0x3F,
    0xFE, 0x80, 0x00, 0x7F, 0xFE, 0xD5, 0x53, 0x00, 0x00,
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x51, 0xFF,
    0xFE, 0x00, 0x00, 0x7F, 0xFC, 0x25, 0x48, 0xA2, 0x04,
    0x00, 0x00, 0x40, 0x00, 0x04, 0x91, 0x81, 0x10, 0x00,
    0x00, 0x5F, 0xF0, 0x8A, 0x12, 0x90, 0x00, 0x00, 0x00,
    0x50, 0x00, 0x10, 0xA8, 0xA0, 0x24, 0x00, 0x00, 0x57,
    0xC0, 0x45, 0x04, 0x80, 0x00, 0x00, 0x00, 0x54, 0x00,
    0x08, 0x51, 0x80, 0x04, 0x00, 0x00, 0x55, 0x00, 0x05,
    0x05, 0xA0, 0x20, 0x00, 0x00, 0x54, 0x00, 0x82, 0x48,
    0x80, 0x00, 0x00, 0x00, 0x54, 0x00, 0x12, 0x02, 0x88,
    0x04, 0x00, 0x00, 0x50, 0x00, 0x04, 0x94, 0x80, 0x00,
    0x00, 0x00, 0x50, 0x00, 0x10, 0x09, 0xA0, 0x10, 0x00,
    0x00, 0x40, 0x00, 0x01, 0x12, 0x88, 0x44, 0x00, 0x00,
    0x40, 0x00, 0x40, 0x40, 0xA0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0A, 0x14, 0x92, 0x24, 0x00, 0x00, 0x00, 0x00,
    0x10, 0xA0, 0x00, 0x00,
};

struct BitMap Presets =
{
    8,				/* BytesPerRow */
    32,				/* Rows */
    0x0,			/* Flags */
    2,				/* Depth */
    NULL,			/* Pad */
    Presets_P0,
    Presets_P1,
};

/*****************************************************************************/

VOID CopyFromDefault (EdDataPtr ed)
{
}
@


38.8
log
@save as depth of 0 if no pattern
@
text
@d101 1
d103 4
@


38.7
log
@maximum of 3 deep bitmap
@
text
@a6 2
#define	DB(x)	;

a69 1
	DB (kprintf ("%ld\n", (ULONG)tmp.wbp_Which));
a73 1
	    DB (kprintf (" pattern : bm %ld, p %ld\n", (LONG)bm->Depth, (LONG)wbp->wbp_Depth));
a80 2
			{
			    DB (kprintf (" couldn't read\n"));
a81 5
			}
			else
			{
			    DB (kprintf (" read %ld bytes\n", SIZEPERPLANE));
			}
a86 1
			DB (kprintf (" dos error %ld\n", ed->ed_SecondaryResult));
a89 3
		{
		    /* Set additional planes to zero */
		    DB (kprintf (" plane %ld < %ld\n", (ULONG)plane, (ULONG)wbp->wbp_Depth));
a90 1
		}
a93 2
	    {
		DB (kprintf (" screen=0x%lx\n", ed->ed_Screen));
a98 1
	    }
a100 1
	{
a101 2
	    DB (kprintf (" picture %s\n", &ed->ed_PrefsWork.ep_Path[tmp.wbp_Which][0]));
	}
a115 1
    DB (kprintf ("OpenPrefs %s\n", name));
d133 3
a135 1
    WORD i, j;
d149 18
a166 1
		DB (kprintf (" pattern\n"));
d169 1
a169 1
		wbp->wbp_Depth      = depth;
a171 1
	    {
a172 2
		DB (kprintf (" picture [%s] %ld\n", &ed->ed_PrefsWork.ep_Path[i][0], (ULONG)wbp->wbp_DataLength));
	    }
a177 6
		    bm = &ed->ed_Temp;
		    bltbm (&ed->ed_PrefsWork.ep_BMap,
			   (i * ed->ed_Width), 0,
			   bm, 0, 0, ed->ed_Width, ed->ed_Height,
			   0xC0, 0xFF, NULL, ed->ed_GfxBase);

a190 1
			    DB (kprintf (" dos error %ld\n", ed->ed_SecondaryResult));
a194 1
		{
a195 1
		}
a207 1
    DB (kprintf ("SavePrefs %s\n", name));
@


38.6
log
@updated file format
@
text
@d77 1
a77 1
	    DB (kprintf (" pattern\n"));
d101 1
a101 1
		else
d160 1
@


38.5
log
@use new file format
@
text
@d121 2
a122 1
	    DB (kprintf (" picture %s\n", wbp->wbp_Path));
d124 3
a169 1
		/* wbp->wbp_Path[0]    = 0; */
d176 2
a177 1
		DB (kprintf (" picture\n"));
d206 4
@


38.4
log
@updated error message
@
text
@d8 3
d16 22
d55 1
a55 1
EdStatus openprefs (EdDataPtr ed, STRPTR name)
d57 4
a60 3
    struct BitMap *bm = &(ed->ed_Temp);
    EdStatus result = ES_NO_MEMORY;
    struct WBPatHeader *PatHeader;
a61 1
    LONG iolength;
a62 1
    BPTR fileh;
d64 2
a65 1
    ed->ed_ErrorFileName = name;
d67 1
a67 1
    if (PatHeader = (struct WBPatHeader *) AllocMem (WBPHSIZE, MEMF_CLEAR))
d69 7
a75 1
	if (fileh = Open (name, MODE_OLDFILE))
d77 2
a78 4
	    /* Read the header */
	    result = ES_IFFERROR;
	    if ((((iolength = Read (fileh, (char *) PatHeader, WBPHSIZE)) == WBPHSIZE) &&
		 ((PatHeader->Depth * SIZEPERPLANE) == PatHeader->DataLength)))
d80 1
a80 3
		result = ES_NORMAL;

		for (plane = 0; plane < bm->Depth; plane++)
d82 1
a82 1
		    if (plane < PatHeader->Depth)
d84 1
a84 1
			if (ok)
d86 2
a87 3
			    iolength = Read (fileh, (char *) bm->Planes[plane],
					     SIZEPERPLANE);
			    ok = (iolength == SIZEPERPLANE);
d91 1
a91 2
			    result = ES_DOSERROR;
			    ed->ed_SecondaryResult = IoErr ();
d96 3
a98 2
			/* Set additional planes to zero */
			memset (bm->Planes[plane], 0, SIZEPERPLANE);
d101 6
d109 9
a117 1
	    Close (fileh);
d121 1
a121 2
	    result = ES_DOSERROR;
	    ed->ed_SecondaryResult = IoErr ();
a122 11

	FreeMem (PatHeader, WBPHSIZE);
    }

    if (result == ES_NORMAL)
    {
	bltbm (&(ed->ed_Temp), 0, 0,
	       &(ed->ed_PrefsWork.wp_BMap),
	       ed->ed_Which, 0,
	       ed->ed_Width, ed->ed_Height,
	       0xC0, 0xFF, NULL, ed->ed_GfxBase);
d125 1
a125 1
    return (result);
a131 1
    UWORD owhich = ed->ed_Which;
d134 2
a135 24
    ed->ed_ErrorFileName = name;

    if (strcmp (name, ENV_NAME) == 0)
    {
	ed->ed_Which = 0;
	openprefs (ed, BDROP_ENV_NAME);

	ed->ed_Which = ed->ed_Width;
	result = openprefs (ed, WIN_ENV_NAME);
    }
    else if (strcmp (name, ARC_NAME) == 0)
    {
	ed->ed_Which = 0;
	openprefs (ed, BDROP_ARC_NAME);

	ed->ed_Which = ed->ed_Width;
	result = openprefs (ed, WIN_ARC_NAME);
    }
    else
    {
	result = openprefs (ed, name);
    }

    ed->ed_Which = owhich;
d145 1
a145 1
EdStatus saveprefs (EdDataPtr ed, STRPTR name)
d147 4
a150 4
    struct BitMap *bm = &(ed->ed_Temp);
    EdStatus result = ES_NO_MEMORY;
    struct WBPatHeader *PatHeader;
    register WORD i;
d152 1
a152 3
    LONG iolength;
    UWORD depth;
    BPTR fileh;
d154 2
a155 1
    ed->ed_ErrorFileName = name;
d157 1
a157 3
    depth = MIN (ed->ed_Depth, ed->ed_Screen->BitMap.Depth);

    if (PatHeader = (struct WBPatHeader *) AllocMem (WBPHSIZE, MEMF_CLEAR))
d159 3
a161 14
	PatHeader->DataLength = ed->ed_Height * 2L * depth;
	PatHeader->Revision = 0;
	PatHeader->Depth = depth;

	result = ES_NORMAL;

	bltbm (
		  &(ed->ed_PrefsWork.wp_BMap),
		  ed->ed_Which, 0,
		  &(ed->ed_Temp), 0, 0,
		  ed->ed_Width, ed->ed_Height,
		  0xC0, 0xFF, NULL, ed->ed_GfxBase);

	if (fileh = Open (name, MODE_NEWFILE))
d163 1
a163 1
	    if (Write (fileh, (char *) PatHeader, WBPHSIZE) == WBPHSIZE)
d165 5
a169 13
		for (i = 0; i < bm->Depth; i++)
		{
		    if (ok)
		    {
			iolength = Write (fileh, (char *) bm->Planes[i], SIZEPERPLANE);
			ok = (iolength == SIZEPERPLANE);
		    }
		    else
		    {
			result = ES_DOSERROR;
			ed->ed_SecondaryResult = IoErr ();
		    }
		}
d173 1
a173 2
		result = ES_DOSERROR;
		ed->ed_SecondaryResult = IoErr ();
d176 27
a202 1
	    Close (fileh);
d204 2
a205 7
	    /* Clear the execute file attribute */
	    SetProtection (name, FIBF_EXECUTE);
	}
	else
	{
	    result = ES_DOSERROR;
	    ed->ed_SecondaryResult = IoErr ();
a206 2

	FreeMem (PatHeader, WBPHSIZE);
d215 2
a216 29
    UWORD owhich = ed->ed_Which;
    EdStatus result;

    ed->ed_ErrorFileName = name;

    if (strcmp (name, ENV_NAME) == 0)
    {
	ed->ed_Which = 0;
	saveprefs (ed, BDROP_ENV_NAME);

	ed->ed_Which = ed->ed_Width;
	result = saveprefs (ed, WIN_ENV_NAME);
    }
    else if (strcmp (name, ARC_NAME) == 0)
    {
	ed->ed_Which = 0;
	saveprefs (ed, BDROP_ARC_NAME);

	ed->ed_Which = ed->ed_Width;
	result = saveprefs (ed, WIN_ARC_NAME);
    }
    else
    {
	result = saveprefs (ed, name);
    }

    ed->ed_Which = owhich;

    return (result);
a225 1
#if 1
d228 29
a256 29
    0xFF,0xFC,0x2A,0xAA,0x7F,0xFE,0x00,0x00,0xFF,
    0xFD,0x95,0x55,0x40,0x00,0x00,0x01,0xFF,0xFF,
    0xCA,0xAB,0x40,0x00,0x00,0x01,0xFF,0xFF,0x65,
    0x56,0x40,0x00,0x10,0x05,0xFF,0xFF,0x32,0xAC,
    0x40,0x00,0x00,0x01,0xFC,0x7F,0x19,0x58,0x40,
    0x00,0x00,0x01,0xFC,0xFF,0x0C,0xB0,0x40,0x00,
    0x00,0x01,0xFC,0xFF,0x06,0x60,0x40,0x00,0x00,
    0x01,0xFC,0xFF,0x02,0x40,0x40,0x00,0x00,0x01,
    0xFD,0xFF,0x01,0x80,0x40,0x00,0x00,0x01,0xFF,
    0xFF,0x03,0xC0,0x40,0x00,0x00,0x01,0xFF,0xFF,
    0x07,0x60,0x40,0x00,0x00,0x01,0xFF,0xFF,0x0E,
    0xB0,0x40,0x00,0x00,0x01,0x7F,0xFC,0x1D,0x58,
    0x40,0x00,0x10,0x05,0xFF,0xFC,0x3A,0xAC,0x40,
    0x00,0x00,0x01,0xFF,0xFC,0x75,0x56,0x00,0x00,
    0x7F,0xFF,0xAA,0xAA,0x00,0x00,0x49,0x51,0x00,
    0x00,0x55,0x55,0x00,0x00,0x25,0x48,0x22,0x05,
    0xAA,0xAA,0x00,0x02,0x04,0x91,0x01,0x11,0x55,
    0x55,0x00,0x02,0x8A,0x12,0x10,0x01,0xAA,0xAA,
    0x00,0x0A,0x10,0xA8,0x20,0x25,0x55,0x55,0x00,
    0x0A,0x45,0x04,0x00,0x01,0xAA,0xAA,0x00,0x2A,
    0x08,0x51,0x00,0x05,0x55,0x55,0x00,0x2A,0x05,
    0x05,0x20,0x21,0xAA,0xAA,0x00,0xAA,0x82,0x48,
    0x00,0x01,0x55,0x55,0x00,0x2A,0x12,0x02,0x08,
    0x05,0xAA,0xAA,0x03,0xEA,0x04,0x94,0x00,0x01,
    0x55,0x55,0x00,0x0A,0x10,0x09,0x20,0x11,0xAA,
    0xAA,0x0F,0xFA,0x01,0x12,0x08,0x45,0x55,0x55,
    0x00,0x02,0x40,0x40,0x20,0x01,0xAA,0xAA,0x3F,
    0xFE,0x0A,0x14,0x12,0x25,0x55,0x55,0x00,0x00,
    0x10,0xA0,0x7F,0xFF,
d261 29
a289 29
    0x7F,0xFE,0xAA,0xAB,0x00,0x00,0xFF,0xFF,0x7F,
    0xFE,0xD5,0x57,0x00,0x02,0x80,0x00,0xFF,0xFF,
    0x6A,0xAE,0x00,0x02,0xA0,0x08,0xFF,0xFF,0x35,
    0x5C,0x00,0x02,0x80,0x00,0xFF,0xFF,0x1A,0xB8,
    0x00,0x02,0x80,0x00,0xFF,0xFF,0x0D,0x70,0x00,
    0x02,0x80,0x00,0xFE,0x7F,0x06,0xE0,0x00,0x02,
    0x80,0x00,0xFE,0x7F,0x03,0xC0,0x00,0x02,0x80,
    0x00,0xFE,0x7F,0x01,0x80,0x00,0x02,0x80,0x00,
    0xFE,0x7F,0x03,0x40,0x00,0x02,0x80,0x00,0xFF,
    0xFF,0x06,0x60,0x00,0x02,0x80,0x00,0xFF,0xFF,
    0x0D,0x30,0x00,0x02,0x80,0x00,0xFF,0xFF,0x1A,
    0x98,0x00,0x02,0xA0,0x08,0xFF,0xFF,0x35,0x4C,
    0x00,0x02,0x80,0x00,0x7F,0xFE,0x6A,0xA6,0x3F,
    0xFE,0x80,0x00,0x7F,0xFE,0xD5,0x53,0x00,0x00,
    0x80,0x00,0x00,0x00,0x00,0x00,0x49,0x51,0xFF,
    0xFE,0x00,0x00,0x7F,0xFC,0x25,0x48,0xA2,0x04,
    0x00,0x00,0x40,0x00,0x04,0x91,0x81,0x10,0x00,
    0x00,0x5F,0xF0,0x8A,0x12,0x90,0x00,0x00,0x00,
    0x50,0x00,0x10,0xA8,0xA0,0x24,0x00,0x00,0x57,
    0xC0,0x45,0x04,0x80,0x00,0x00,0x00,0x54,0x00,
    0x08,0x51,0x80,0x04,0x00,0x00,0x55,0x00,0x05,
    0x05,0xA0,0x20,0x00,0x00,0x54,0x00,0x82,0x48,
    0x80,0x00,0x00,0x00,0x54,0x00,0x12,0x02,0x88,
    0x04,0x00,0x00,0x50,0x00,0x04,0x94,0x80,0x00,
    0x00,0x00,0x50,0x00,0x10,0x09,0xA0,0x10,0x00,
    0x00,0x40,0x00,0x01,0x12,0x88,0x44,0x00,0x00,
    0x40,0x00,0x40,0x40,0xA0,0x00,0x00,0x00,0x00,
    0x00,0x0A,0x14,0x92,0x24,0x00,0x00,0x00,0x00,
    0x10,0xA0,0x00,0x00,
d294 5
a298 5
    8,		/* BytesPerRow */
    32,		/* Rows */
    0x0,	/* Flags */
    2,		/* Depth */
    NULL,	/* Pad */
a301 87

#else
static UBYTE chip Presets_plane0[] =
{
    0xFF, 0xFC, 0x2A, 0xAA, 0x7F, 0xFC, 0x00, 0x00,
    0xFF, 0xFD, 0x95, 0x55, 0x40, 0x00, 0x00, 0x01,
    0xFF, 0xFF, 0xCA, 0xAB, 0x40, 0x00, 0x00, 0x01,
    0xFF, 0xFF, 0x65, 0x56, 0x40, 0x00, 0x10, 0x05,
    0xFF, 0xFF, 0x32, 0xAC, 0x40, 0x00, 0x00, 0x01,
    0xFC, 0x7F, 0x19, 0x58, 0x40, 0x00, 0x00, 0x01,
    0xFC, 0xFF, 0x0C, 0xB0, 0x40, 0x00, 0x00, 0x01,
    0xFC, 0xFF, 0x06, 0x60, 0x40, 0x00, 0x00, 0x01,
    0xFC, 0xFF, 0x02, 0x40, 0x40, 0x00, 0x00, 0x01,
    0xFD, 0xFF, 0x01, 0x80, 0x40, 0x00, 0x00, 0x01,
    0xFF, 0xFF, 0x03, 0xC0, 0x40, 0x00, 0x00, 0x01,
    0xFF, 0xFF, 0x07, 0x60, 0x40, 0x00, 0x00, 0x01,
    0xFF, 0xFF, 0x0E, 0xB0, 0x40, 0x00, 0x00, 0x01,
    0x7F, 0xFC, 0x1D, 0x58, 0x40, 0x00, 0x10, 0x05,
    0xFF, 0xFC, 0x3A, 0xAC, 0x00, 0x00, 0x00, 0x01,
    0xFF, 0xFC, 0x75, 0x56, 0x00, 0x00, 0x7F, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x49, 0x11, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x20, 0x48, 0x22, 0x05,
    0x00, 0x00, 0x00, 0x01, 0x04, 0x81, 0x01, 0x11,
    0x00, 0x00, 0x00, 0x01, 0x8A, 0x12, 0x10, 0x01,
    0x00, 0x00, 0x00, 0x05, 0x10, 0xA8, 0x20, 0x25,
    0x00, 0x00, 0x00, 0x05, 0x45, 0x04, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x15, 0x08, 0x51, 0x00, 0x05,
    0x00, 0x00, 0x00, 0x15, 0x05, 0x04, 0x20, 0x21,
    0x00, 0x00, 0x00, 0x55, 0x80, 0x48, 0x00, 0x01,
    0x00, 0x00, 0x00, 0xD5, 0x12, 0x02, 0x08, 0x05,
    0x00, 0x00, 0x00, 0x15, 0x04, 0x94, 0x00, 0x01,
    0x00, 0x00, 0x03, 0xF5, 0x10, 0x09, 0x20, 0x11,
    0x00, 0x00, 0x00, 0x05, 0x01, 0x12, 0x08, 0x45,
    0x00, 0x00, 0x0F, 0xFD, 0x40, 0x40, 0x20, 0x01,
    0x00, 0x00, 0x00, 0x01, 0x0A, 0x14, 0x12, 0x25,
    0x00, 0x00, 0x3F, 0xFF, 0x10, 0xA0, 0x7F, 0xFF,
};

static UBYTE chip Presets_plane1[] =
{
    0x7F, 0xFE, 0xAA, 0xAB, 0x00, 0x00, 0xFF, 0xFE,
    0x7F, 0xFE, 0xD5, 0x57, 0x00, 0x02, 0x80, 0x00,
    0xFF, 0xFF, 0x6A, 0xAE, 0x00, 0x02, 0xA0, 0x08,
    0xFF, 0xFF, 0x35, 0x5C, 0x00, 0x02, 0x80, 0x00,
    0xFF, 0xFF, 0x1A, 0xB8, 0x00, 0x02, 0x80, 0x00,
    0xFF, 0xFF, 0x0D, 0x70, 0x00, 0x02, 0x80, 0x00,
    0xFE, 0x7F, 0x06, 0xE0, 0x00, 0x02, 0x80, 0x00,
    0xFE, 0x7F, 0x03, 0xC0, 0x00, 0x02, 0x80, 0x00,
    0xFE, 0x7F, 0x01, 0x80, 0x00, 0x02, 0x80, 0x00,
    0xFE, 0x7F, 0x03, 0x40, 0x00, 0x02, 0x80, 0x00,
    0xFF, 0xFF, 0x06, 0x60, 0x00, 0x02, 0x80, 0x00,
    0xFF, 0xFF, 0x0D, 0x30, 0x00, 0x02, 0x80, 0x00,
    0xFF, 0xFF, 0x1A, 0x98, 0x00, 0x02, 0xA0, 0x08,
    0xFF, 0xFF, 0x35, 0x4C, 0x00, 0x02, 0x80, 0x00,
    0x7F, 0xFE, 0x6A, 0xA6, 0x3F, 0xFE, 0x80, 0x00,
    0x7F, 0xFE, 0xD5, 0x53, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0xAA, 0x00, 0x00, 0x49, 0x11, 0xFF, 0xFE,
    0xAA, 0xAA, 0x7F, 0xFE, 0x20, 0x48, 0xA2, 0x04,
    0xAA, 0xAA, 0x40, 0x00, 0x04, 0x81, 0x81, 0x10,
    0xAA, 0xAA, 0x5F, 0xF8, 0x8A, 0x12, 0x90, 0x00,
    0x55, 0x55, 0x50, 0x00, 0x10, 0xA8, 0xA0, 0x24,
    0x55, 0x55, 0x57, 0xE0, 0x45, 0x04, 0x80, 0x00,
    0x55, 0x55, 0x54, 0x00, 0x08, 0x51, 0x80, 0x04,
    0x55, 0x55, 0x55, 0x80, 0x05, 0x04, 0xA0, 0x20,
    0x55, 0x55, 0x55, 0x00, 0x80, 0x48, 0x80, 0x00,
    0x55, 0x55, 0x54, 0x00, 0x12, 0x02, 0x88, 0x04,
    0x55, 0x55, 0x54, 0x00, 0x04, 0x94, 0x80, 0x00,
    0x55, 0x55, 0x50, 0x00, 0x10, 0x09, 0xA0, 0x10,
    0xAA, 0xAA, 0x50, 0x00, 0x01, 0x12, 0x88, 0x44,
    0xAA, 0xAA, 0x40, 0x00, 0x40, 0x40, 0xA0, 0x00,
    0xAA, 0xAA, 0x40, 0x00, 0x0A, 0x14, 0x92, 0x24,
    0xAA, 0xAA, 0x00, 0x00, 0x10, 0xA0, 0x00, 0x00,
};

struct BitMap Presets =
{
    8,			/* BytesPerRow */
    32,			/* Rows */
    0x0,		/* Flags */
    2,			/* Depth */
    NULL,		/* Pad */

    /* Planes */
    Presets_plane0,
    Presets_plane1,
};
#endif
@


38.3
log
@updated presets.
@
text
@d40 2
d47 1
d107 2
d151 2
d216 2
@


38.2
log
@problem with ed_Which
@
text
@d243 79
d406 1
@


38.1
log
@initial rcs checkin
@
text
@d89 1
a89 1
	       (ed->ed_Width << ed->ed_Which), 0,
d109 1
a109 1
	ed->ed_Which = 1;
d117 1
a117 1
	ed->ed_Which = 1;
d158 1
a158 1
		  (ed->ed_Width << ed->ed_Which), 0,
d215 1
a215 1
	ed->ed_Which = 1;
d223 1
a223 1
	ed->ed_Which = 1;
@
