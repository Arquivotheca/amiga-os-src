/* io.c
 *
 */

#include "wbpattern.h"

/*****************************************************************************/

#define SIZEPERPLANE	(16 * sizeof(UWORD))
#define	WBPHSIZE	(sizeof(struct WBPatHeader))

/*****************************************************************************/

/* The PrefHeader structure this editor outputs */
static struct PrefHeader far IFFPrefHeader =
{
    0,				/* version */
    0,				/* type    */
    0				/* flags   */
};

/*****************************************************************************/

/* The IFF chunks known to this prefs editor. IFFPrefChunkCnt says how many
 * chunks there are
 */
#define IFFPrefChunkCnt 2
static LONG far IFFPrefChunks[] =
{
    ID_PREF, ID_PRHD,
    ID_PREF, ID_PTRN,
};

/*****************************************************************************/

VOID UpdateSketch (EdDataPtr ed)
{

    if (ed->ed_GSketch)
    {
	/* Show that the bitmap has been updated */
	setgadgetattrs (ed, ed->ed_GSketch,
			SPA_Update, TRUE,
			TAG_DONE);

	/* Draw the repeat area */
	RefreshRepeats (ed);
    }
}

/*****************************************************************************/

EdStatus ReadPrefs(EdDataPtr ed, struct IFFHandle *iff, struct ContextNode *cn)
{
    struct BitMap *bm = &ed->ed_Temp;
    EdStatus result = ES_IFFERROR;
    struct WBPatternPrefs *wbp;
    struct WBPatternPrefs tmp;
    BOOL ok = TRUE;
    WORD plane;

    if (cn->cn_ID != ID_PTRN || cn->cn_Type != ID_PREF)
        return(ES_IFF_UNKNOWNCHUNK);

    if (ReadChunkBytes(iff, &tmp, sizeof(struct WBPatternPrefs)) == sizeof(struct WBPatternPrefs))
    {
        result = ES_NORMAL;

	wbp = &ed->ed_PrefsWork.ep_WBP[tmp.wbp_Which];
	CopyMem (&tmp, wbp, sizeof (struct WBPatternPrefs));

	if (wbp->wbp_Flags & WBPF_PATTERN)
	{
	    for (plane = 0; plane < bm->Depth; plane++)
	    {
		if (plane < wbp->wbp_Depth)
		{
		    if (ok)
		    {
			if (ReadChunkBytes (iff, (char *)bm->Planes[plane], SIZEPERPLANE) != SIZEPERPLANE)
			    ok = FALSE;
		    }
		    else
		    {
			result = ES_DOSERROR;
			ed->ed_SecondaryResult = IoErr ();
		    }
		}
		else if (plane < 3)
		    memset (bm->Planes[plane], 0, SIZEPERPLANE);
	    }

	    if (ok)
		bltbm (bm, 0, 0,
		       &ed->ed_PrefsWork.ep_BMap,
		       wbp->wbp_Which * ed->ed_Width, 0,
		       ed->ed_Width, ed->ed_Height,
		       0xC0, 0xFF, NULL, ed->ed_GfxBase);
	}
	else
	{
	    ReadChunkBytes (iff, (char *)&ed->ed_PrefsWork.ep_Path[tmp.wbp_Which][0], wbp->wbp_DataLength);

	    /* NULL terminate the buffer */
	    ed->ed_PrefsWork.ep_Path[tmp.wbp_Which][wbp->wbp_DataLength] = 0;
	}

	/* Set the current type */
	ed->ed_Type  = 0x1 & (ed->ed_PrefsWork.ep_WBP[(ed->ed_Which/ed->ed_Width)].wbp_Flags);
    }

    return(result);
}

/*****************************************************************************/

EdStatus OpenPrefs (EdDataPtr ed, STRPTR name)
{
    EdStatus result;

    result = ReadIFF (ed, name, IFFPrefChunks, IFFPrefChunkCnt, ReadPrefs);

    /* Update the sketchpad */
    UpdateSketch (ed);

    return (result);
}

/*****************************************************************************/

EdStatus WritePrefs (EdDataPtr ed, struct IFFHandle * iff, struct ContextNode * cn)
{
    EdStatus result = ES_NORMAL;
    UWORD depth = ed->ed_Depth;
    struct WBPatternPrefs *wbp;
    struct BitMap *bm;
    BOOL ok = TRUE;
    WORD i, j, k;
    WORD found;
    char *ptr;

    if (ed->ed_Screen)
	depth = MIN (ed->ed_Depth, ed->ed_Screen->BitMap.Depth);
    depth = MIN (depth, 3);

    for (i = 0; i < 3; i++)
    {
	wbp = &ed->ed_PrefsWork.ep_WBP[i];
	wbp->wbp_Which = i;
	if (!(PushChunk (iff, 0, ID_PTRN, IFFSIZE_UNKNOWN)))
	{
	    if (wbp->wbp_Flags & WBPF_PATTERN)
	    {
		bm = &ed->ed_Temp;
		bltbm (&ed->ed_PrefsWork.ep_BMap,
		       (i * ed->ed_Width), 0,
		       bm, 0, 0, ed->ed_Width, ed->ed_Height,
		       0xC0, 0xFF, NULL, ed->ed_GfxBase);

		/* See if there is anything in the bitmap */
		for (j = found = 0; (j < depth) && (found == 0); j++)
		{
		    ptr = (char *)bm->Planes[j];
		    for (k = 0; (k < SIZEPERPLANE) && (found == 0); k++)
		    {
			if (ptr[k])
			    found++;
		    }
		}

		/* Fill in the pref structure */
		wbp->wbp_DataLength = ed->ed_Height * 2L * depth;
		wbp->wbp_Revision   = 0;
		wbp->wbp_Depth      = (found) ? depth : 0;
	    }
	    else
		wbp->wbp_DataLength = strlen (&ed->ed_PrefsWork.ep_Path[i][0]);

	    if (WriteChunkBytes (iff, wbp, sizeof (struct WBPatternPrefs)) == sizeof (struct WBPatternPrefs))
	    {
		if (wbp->wbp_Flags & WBPF_PATTERN)
		{
		    for (j = 0; j < depth; j++)
		    {
			if (ok)
			{
			    if (WriteChunkBytes (iff, (char *)bm->Planes[j], SIZEPERPLANE) != SIZEPERPLANE)
			    {
				ok = FALSE;
			    }
			}
			else
			{
			    result = ES_DOSERROR;
			    ed->ed_SecondaryResult = IoErr ();
			}
		    }
		}
		else
		    WriteChunkBytes (iff, (char *)&ed->ed_PrefsWork.ep_Path[i][0], wbp->wbp_DataLength);

		PopChunk (iff);
	    }
	}
    }
    return (result);
}

/*****************************************************************************/

EdStatus SavePrefs (EdDataPtr ed, STRPTR name)
{
    return (WriteIFF (ed, name, &IFFPrefHeader, WritePrefs));
}

/*****************************************************************************/

/* Data created by ILBMer, written by David N. Junod */

#include <exec/types.h>
#include <graphics/gfx.h>

static UBYTE chip Presets_P0[] =
{
    0xFF, 0xFC, 0x2A, 0xAA, 0x7F, 0xFE, 0x00, 0x00, 0xFF,
    0xFD, 0x95, 0x55, 0x40, 0x00, 0x00, 0x01, 0xFF, 0xFF,
    0xCA, 0xAB, 0x40, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x65,
    0x56, 0x40, 0x00, 0x10, 0x05, 0xFF, 0xFF, 0x32, 0xAC,
    0x40, 0x00, 0x00, 0x01, 0xFC, 0x7F, 0x19, 0x58, 0x40,
    0x00, 0x00, 0x01, 0xFC, 0xFF, 0x0C, 0xB0, 0x40, 0x00,
    0x00, 0x01, 0xFC, 0xFF, 0x06, 0x60, 0x40, 0x00, 0x00,
    0x01, 0xFC, 0xFF, 0x02, 0x40, 0x40, 0x00, 0x00, 0x01,
    0xFD, 0xFF, 0x01, 0x80, 0x40, 0x00, 0x00, 0x01, 0xFF,
    0xFF, 0x03, 0xC0, 0x40, 0x00, 0x00, 0x01, 0xFF, 0xFF,
    0x07, 0x60, 0x40, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x0E,
    0xB0, 0x40, 0x00, 0x00, 0x01, 0x7F, 0xFC, 0x1D, 0x58,
    0x40, 0x00, 0x10, 0x05, 0xFF, 0xFC, 0x3A, 0xAC, 0x40,
    0x00, 0x00, 0x01, 0xFF, 0xFC, 0x75, 0x56, 0x00, 0x00,
    0x7F, 0xFF, 0xAA, 0xAA, 0x00, 0x00, 0x49, 0x51, 0x00,
    0x00, 0x55, 0x55, 0x00, 0x00, 0x25, 0x48, 0x22, 0x05,
    0xAA, 0xAA, 0x00, 0x02, 0x04, 0x91, 0x01, 0x11, 0x55,
    0x55, 0x00, 0x02, 0x8A, 0x12, 0x10, 0x01, 0xAA, 0xAA,
    0x00, 0x0A, 0x10, 0xA8, 0x20, 0x25, 0x55, 0x55, 0x00,
    0x0A, 0x45, 0x04, 0x00, 0x01, 0xAA, 0xAA, 0x00, 0x2A,
    0x08, 0x51, 0x00, 0x05, 0x55, 0x55, 0x00, 0x2A, 0x05,
    0x05, 0x20, 0x21, 0xAA, 0xAA, 0x00, 0xAA, 0x82, 0x48,
    0x00, 0x01, 0x55, 0x55, 0x00, 0x2A, 0x12, 0x02, 0x08,
    0x05, 0xAA, 0xAA, 0x03, 0xEA, 0x04, 0x94, 0x00, 0x01,
    0x55, 0x55, 0x00, 0x0A, 0x10, 0x09, 0x20, 0x11, 0xAA,
    0xAA, 0x0F, 0xFA, 0x01, 0x12, 0x08, 0x45, 0x55, 0x55,
    0x00, 0x02, 0x40, 0x40, 0x20, 0x01, 0xAA, 0xAA, 0x3F,
    0xFE, 0x0A, 0x14, 0x12, 0x25, 0x55, 0x55, 0x00, 0x00,
    0x10, 0xA0, 0x7F, 0xFF,
};

static UBYTE chip Presets_P1[] =
{
    0x7F, 0xFE, 0xAA, 0xAB, 0x00, 0x00, 0xFF, 0xFF, 0x7F,
    0xFE, 0xD5, 0x57, 0x00, 0x02, 0x80, 0x00, 0xFF, 0xFF,
    0x6A, 0xAE, 0x00, 0x02, 0xA0, 0x08, 0xFF, 0xFF, 0x35,
    0x5C, 0x00, 0x02, 0x80, 0x00, 0xFF, 0xFF, 0x1A, 0xB8,
    0x00, 0x02, 0x80, 0x00, 0xFF, 0xFF, 0x0D, 0x70, 0x00,
    0x02, 0x80, 0x00, 0xFE, 0x7F, 0x06, 0xE0, 0x00, 0x02,
    0x80, 0x00, 0xFE, 0x7F, 0x03, 0xC0, 0x00, 0x02, 0x80,
    0x00, 0xFE, 0x7F, 0x01, 0x80, 0x00, 0x02, 0x80, 0x00,
    0xFE, 0x7F, 0x03, 0x40, 0x00, 0x02, 0x80, 0x00, 0xFF,
    0xFF, 0x06, 0x60, 0x00, 0x02, 0x80, 0x00, 0xFF, 0xFF,
    0x0D, 0x30, 0x00, 0x02, 0x80, 0x00, 0xFF, 0xFF, 0x1A,
    0x98, 0x00, 0x02, 0xA0, 0x08, 0xFF, 0xFF, 0x35, 0x4C,
    0x00, 0x02, 0x80, 0x00, 0x7F, 0xFE, 0x6A, 0xA6, 0x3F,
    0xFE, 0x80, 0x00, 0x7F, 0xFE, 0xD5, 0x53, 0x00, 0x00,
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x51, 0xFF,
    0xFE, 0x00, 0x00, 0x7F, 0xFC, 0x25, 0x48, 0xA2, 0x04,
    0x00, 0x00, 0x40, 0x00, 0x04, 0x91, 0x81, 0x10, 0x00,
    0x00, 0x5F, 0xF0, 0x8A, 0x12, 0x90, 0x00, 0x00, 0x00,
    0x50, 0x00, 0x10, 0xA8, 0xA0, 0x24, 0x00, 0x00, 0x57,
    0xC0, 0x45, 0x04, 0x80, 0x00, 0x00, 0x00, 0x54, 0x00,
    0x08, 0x51, 0x80, 0x04, 0x00, 0x00, 0x55, 0x00, 0x05,
    0x05, 0xA0, 0x20, 0x00, 0x00, 0x54, 0x00, 0x82, 0x48,
    0x80, 0x00, 0x00, 0x00, 0x54, 0x00, 0x12, 0x02, 0x88,
    0x04, 0x00, 0x00, 0x50, 0x00, 0x04, 0x94, 0x80, 0x00,
    0x00, 0x00, 0x50, 0x00, 0x10, 0x09, 0xA0, 0x10, 0x00,
    0x00, 0x40, 0x00, 0x01, 0x12, 0x88, 0x44, 0x00, 0x00,
    0x40, 0x00, 0x40, 0x40, 0xA0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0A, 0x14, 0x92, 0x24, 0x00, 0x00, 0x00, 0x00,
    0x10, 0xA0, 0x00, 0x00,
};

struct BitMap Presets =
{
    8,				/* BytesPerRow */
    32,				/* Rows */
    0x0,			/* Flags */
    2,				/* Depth */
    NULL,			/* Pad */
    Presets_P0,
    Presets_P1,
};

/*****************************************************************************/

VOID CopyFromDefault (EdDataPtr ed)
{
}
