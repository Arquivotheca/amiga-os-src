head     38.9;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


38.9
date     92.10.01.14.39.46;  author vertex;  state Exp;
branches ;
next     38.8;

38.8
date     92.06.08.20.25.34;  author vertex;  state Exp;
branches ;
next     38.7;

38.7
date     92.03.27.13.09.14;  author vertex;  state Exp;
branches ;
next     38.6;

38.6
date     92.03.27.12.52.25;  author vertex;  state Exp;
branches ;
next     38.5;

38.5
date     92.03.25.13.21.33;  author vertex;  state Exp;
branches ;
next     38.4;

38.4
date     92.02.27.10.34.51;  author vertex;  state Exp;
branches ;
next     38.3;

38.3
date     92.02.25.14.32.32;  author vertex;  state Exp;
branches ;
next     38.2;

38.2
date     92.02.24.10.32.28;  author vertex;  state Exp;
branches ;
next     38.1;

38.1
date     92.02.21.11.08.20;  author vertex;  state Exp;
branches ;
next     ;


desc
@CrossDOS controller program
@


38.9
log
@Fixed bug where the window would not open when there was no
L:FileSystem_Trans directory, or no file within it. (B18879)

Fixed incorrect cleanup path in case of errors while scanning directories.
The bug would cause a crash the next time the window was opened.

Now only notifies CrossDOS handler tasks of changes in settings when
new settings differ from the old ones.

No longer has the CrossDOS semaphore locked when it locks the DOS device
list. This could potentially cause deadlocks, although none have been
reported so far.

Fixed bug where translation files were opened and read, but never closed.
(B18936)

Fixed bug that would cause a crash under 2.0 or harmless Enforcer hits
under 3.0. To reproduce, start the CrossDOS commodity and copy a large file
to PC0 (devs:Kickstart for example). While the copy is in progress, pick
PC0 from the CrossDOS commodity and change its text filtering setting. Now
click the close gadget of the commodity program. The window stays open
until the large write operation completes. As soon as this happens, the
window closes, and a crash occurs under 2.0.
@
text
@
#include <exec/types.h>
#include <exec/libraries.h>
#include <exec/memory.h>
#include <devices/inputevent.h>
#include <intuition/intuitionbase.h>
#include <intuition/intuition.h>
#include <intuition/gadgetclass.h>
#include <libraries/commodities.h>
#include <dos/dos.h>
#include <dos/dosextens.h>
#include <dos/filehandler.h>
#include <dos/exall.h>
#include <string.h>

#include <clib/exec_protos.h>
#include <clib/graphics_protos.h>
#include <clib/intuition_protos.h>
#include <clib/commodities_protos.h>
#include <clib/icon_protos.h>
#include <clib/dos_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/utility_protos.h>

#include <pragmas/exec_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/commodities_pragmas.h>
#include <pragmas/icon_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/gadtools_pragmas.h>
#include <pragmas/utility_pragmas.h>

#include "ce_custom.h"
#include "ce_window.h"
#include "ce_strings.h"
#include "crossdos.h"


/*****************************************************************************/


extern struct Library       *SysBase;
extern struct IntuitionBase *IntuitionBase;
extern struct Library       *CxBase;
extern struct Library       *IconBase;
extern struct Library       *GfxBase;
extern struct Library       *DOSBase;
extern struct Library       *GadToolsBase;
extern struct Library       *UtilityBase;
extern LONG                  cxSignal;
extern CxObj                *cxBroker;
extern struct Gadget        *cxGadgets;
extern struct Menu          *cxMenus;
extern struct Window        *cxWindow;
extern APTR                  cxVisualInfo;
extern struct DrawInfo      *cxDrawInfo;
extern BOOL                  cxPopUp;

/* from IntuiMessage */
ULONG             class;
UWORD             icode;
struct Gadget    *gad;

struct TextFont   *topazFont;
struct Gadget     *deviceGad;
struct Gadget     *filterGad;
struct Gadget     *transGad;
struct Gadget     *transListGad;

STRPTR      *transArray;
struct List  transList;
struct List  handlerList;
struct Node  dummyNode;

struct Node *currentHandler;
BOOL         doFilter;
BOOL         doTrans;
STRPTR       transType;

struct DiskObject *cdcDiskObj;


/*****************************************************************************/


#define CMD_NOP       0
#define CMD_SAVE      1
#define CMD_HIDE      2
#define CMD_QUIT      3
#define CMD_DEVICES   4
#define CMD_FILTER    5
#define CMD_TRANS     6
#define CMD_TRANSLIST 7
#define CMD_NEWDISK   8

#define CROSSDOS_TRANS "L:FileSystem_Trans"
#define CROSSDOS_NAME  "« CrossDOS »"


/*****************************************************************************/


struct TextAttr far topazAttr =
{
    "topaz.font",
    8,
    FS_NORMAL,
    FPF_ROMFONT
};


/*****************************************************************************/


VOID RefreshGads(VOID);
BOOL ProcessCommand(UWORD cmd);
VOID ProcessHandlerList(BOOL initial);
BOOL BuildTransList(STRPTR directory, STRPTR pattern, WORD strip);
VOID HandlerInfo(STRPTR handlerName, BOOL *doFilter, BOOL *doTrans, STRPTR *transType);
VOID NewList(struct List *list);
VOID kprintf(STRPTR,...);
VOID HandlerControl(STRPTR handlerName, BOOL doFilter, BOOL doTrans, STRPTR transType);
VOID Terminate(VOID);
VOID EmptyList(struct List *list);


/*****************************************************************************/


BOOL ProcessCustomArgs(struct WBStartup *wbMsg, struct DiskObject *diskObj,
                       ULONG *cliOpts)
{
STRPTR *ptr;
STRPTR  name;
UWORD   i,j;
char    handler[50];
char    transName[50];
BOOL    allocated;

    NewList(&handlerList);
    NewList(&transList);
    transArray = NULL;

    allocated = FALSE;
    if (!(cdcDiskObj = diskObj))
    {
        cdcDiskObj = GetDiskObject("PROGDIR:CrossDOS");
        allocated = TRUE;
    }

    if (cdcDiskObj && (ptr = cdcDiskObj->do_ToolTypes))
    {
        while (name = *ptr)
        {
            if (name[0] == '«')
            {
                i = 1;
                while ((name[i] != ',') && (name[i]))
                {
                    handler[i-1] = name[i];
                    i++;
                }
                handler[i-1] = 0;

                if (name[i] == ',')
                {
                    i++;
                    if (name[i] == ',')
                    {
                        doFilter = FALSE;
                    }
                    else
                    {
                        doFilter = TRUE;
                        while (name[i] && (name[i] != '»') && (name[++i] != ','))
                        {
                        }
                    }

                    if (name[i])
                    {
                        i++;
                        if (name[i] == ',')
                        {
                            doTrans = FALSE;
                        }
                        else
                        {
                            doTrans = TRUE;
                            while (name[i] && (name[i] != '»') && (name[++i] != ','))
                            {
                            }
                        }

                        j = 0;
                        if (name[i] == ',')
                        {
                            i++;
                            while (name[i] && (name[i] != '»'))
                                transName[j++] = name[i++];
                        }
                        transName[j] = 0;

                        HandlerControl(handler,doFilter,doTrans,transName);
                    }
                }
            }
            ptr++;
        }
    }

    if (cdcDiskObj && allocated)
    {
        FreeDiskObject(cdcDiskObj);
        cdcDiskObj = NULL;
    }

    return(TRUE);
}


/*****************************************************************************/


VOID ProcessCustomCxMsg(ULONG cmd)
{
}


/*****************************************************************************/


VOID ProcessCustomCxSig()
{
    if (currentHandler)
    {
        HandlerInfo(currentHandler->ln_Name,&doFilter,&doTrans,&transType);
        RefreshGads();
    }
}


/*****************************************************************************/


VOID ProcessCustomCxCmd(ULONG cmd)
{
}


/*****************************************************************************/


BOOL ProcessIntuiMsg(struct IntuiMessage *intuiMsg)
{
BOOL             ok;
UWORD            menuNum;
struct MenuItem *menuItem;

    class = intuiMsg->Class;
    icode = intuiMsg->Code;
    gad   = intuiMsg->IAddress;
    GT_ReplyIMsg(intuiMsg);

    ok = TRUE;
    switch (class)
    {
        case IDCMP_CLOSEWINDOW  : ok = ProcessCommand(CMD_HIDE);
                                  break;

        case IDCMP_REFRESHWINDOW: RefreshWindow(TRUE);
                                  break;

        case IDCMP_MENUPICK     : menuNum = icode;
                                  while ((menuNum != MENUNULL) && (ok))
                                  {
                                      menuItem = ItemAddress(cxMenus,menuNum);
                                      ok = ProcessCommand((UWORD)MENU_USERDATA(menuItem));

                                      if (cxMenus == NULL)
                                          break;

                                      menuNum = menuItem->NextSelect;
                                  }
                                  break;

        case IDCMP_DISKINSERTED : ok = ProcessCommand(CMD_NEWDISK);
                                  break;

        case IDCMP_GADGETUP     :
        case IDCMP_GADGETDOWN   : ok = ProcessCommand((UWORD)gad->UserData);
                                  break;
    }

    return(ok);
}


/*****************************************************************************/


BOOL CreateCustomGadgets(VOID)
{
struct NewGadget  ng;
struct Gadget    *gad;

    SetFont(cxWindow->RPort,topazFont);

    currentHandler = NULL;
    transType      = NULL;
    doFilter       = FALSE;
    doTrans        = FALSE;

    ProcessHandlerList(TRUE);
    if (BuildTransList(CROSSDOS_TRANS,"#?.crossdos",9))
    {
        if (gad = CreateContext(&cxGadgets))
        {
            /* Some invariants */
            ng.ng_TextAttr   = &topazAttr;
            ng.ng_GadgetID   = 0;
            ng.ng_Flags      = 0;
            ng.ng_VisualInfo = cxVisualInfo;

            ng.ng_LeftEdge   = cxWindow->BorderLeft+8;
            ng.ng_TopEdge    = cxWindow->BorderTop+6;
            ng.ng_Width      = 110;
            ng.ng_Height     = 53;
            ng.ng_GadgetText = NULL;
            ng.ng_UserData   = (APTR)CMD_DEVICES;

            deviceGad = CreateGadget(LISTVIEW_KIND,gad,&ng,GTLV_Labels, &handlerList,
                                                           GTLV_ShowSelected, NULL,
                                                           LAYOUTA_SPACING,   1,
                                                           GTLV_ScrollWidth,  18,
                                                           TAG_DONE);

            ng.ng_LeftEdge   = cxWindow->BorderLeft+131;
            ng.ng_TopEdge    = cxWindow->BorderTop+5;
            ng.ng_Width      = 16;
            ng.ng_Height     = 16;
            ng.ng_GadgetText = GetString(MSG_CD_FILTER_GAD);
            ng.ng_Flags      = PLACETEXT_RIGHT;
            ng.ng_UserData   = (APTR)CMD_FILTER;

            filterGad = CreateGadget(CHECKBOX_KIND,deviceGad,&ng,GTCB_Checked,FALSE,
                                                                 GA_Disabled, TRUE,
                                                                 TAG_DONE);

            ng.ng_TopEdge    = cxWindow->BorderTop+18;
            ng.ng_Width      = 16;
            ng.ng_Height     = 16;
            ng.ng_GadgetText = GetString(MSG_CD_TRANS_GAD);
            ng.ng_UserData   = (APTR)CMD_TRANS;

            transGad = CreateGadget(CHECKBOX_KIND,filterGad,&ng,GTCB_Checked,FALSE,
                                                                GA_Disabled, TRUE,
                                                                TAG_DONE);

            ng.ng_TopEdge    = cxWindow->BorderTop+45;
            ng.ng_Width      = 178;
            ng.ng_Height     = 14;
            ng.ng_GadgetText = GetString(MSG_CD_TRANSTYPE_GAD);
            ng.ng_Flags      = PLACETEXT_ABOVE;
            ng.ng_UserData   = (APTR)CMD_TRANSLIST;

            transListGad = CreateGadget(CYCLE_KIND,transGad,&ng,GTCY_Labels, transArray,
                                                                GA_Disabled, currentHandler == NULL,
                                                                TAG_DONE);

            if (transListGad)
            {
                AddGList(cxWindow,cxGadgets,-1,-1,NULL);
                RefreshGList(cxGadgets,cxWindow,NULL,-1);
                GT_RefreshWindow(cxWindow,NULL);
                return(TRUE);
            }

            FreeGadgets(cxGadgets);
            cxGadgets = NULL;
        }
    }

    Terminate();

    return(FALSE);
}


/*****************************************************************************/


struct NewMenu NM[] =
{
    {NM_TITLE,  NULL,        0, 0, 0, (APTR)CMD_NOP,  },
      {NM_ITEM, NULL,        0, 0, 0, (APTR)CMD_SAVE, },
      {NM_ITEM, NM_BARLABEL, 0, 0, 0, (APTR)CMD_NOP,  },
      {NM_ITEM, NULL,        0, 0, 0, (APTR)CMD_HIDE, },
      {NM_ITEM, NULL,        0, 0, 0, (APTR)CMD_QUIT, },

    {NM_END,    0,           0, 0, 0, (APTR)CMD_NOP,  }
};



VOID DoItem(WORD itemNum, AppStringsID label)
{
    if (NM[itemNum].nm_Type != NM_TITLE)
    {
        NM[itemNum].nm_Label   = (APTR)((ULONG)GetString(label)+2);
        NM[itemNum].nm_CommKey = GetString(label);
    }
    else
    {
        NM[itemNum].nm_Label = GetString(label);
    }
}


/*****************************************************************************/


BOOL CreateCustomMenus(VOID)
{
    DoItem(0,MSG_PROJECT_MENU);
    DoItem(1,MSG_CD_PROJECT_SAVE);
    DoItem(3,MSG_PROJECT_HIDE);
    DoItem(4,MSG_PROJECT_QUIT);

    if (cxMenus = CreateMenusA(NM,NULL))
    {
        if (LayoutMenus(cxMenus,cxVisualInfo,GTMN_NewLookMenus,TRUE,
                                             TAG_DONE))
        {
            SetMenuStrip(cxWindow,cxMenus);
            return(TRUE);
        }
        FreeMenus(cxMenus);
        cxMenus = NULL;
    }
    return(FALSE);
}


/*****************************************************************************/


VOID SaveCDCIcon(VOID)
{
STRPTR             *ttypes;
STRPTR             *new;
BOOL                allocated;
UWORD               i;
UWORD               len;
UWORD               cnt;
struct Node        *node;
BOOL                doFilter;
BOOL                doTrans;
STRPTR              transType;

    allocated = FALSE;
    if (!cdcDiskObj)
    {
        cdcDiskObj = GetDiskObject("PROGDIR:CrossDOS");
        allocated = TRUE;
    }

    if (cdcDiskObj)
    {
        i    = 0;
        node = handlerList.lh_Head;
        while (node->ln_Succ)
        {
            i++;
            node = node->ln_Succ;
        }

        if (ttypes = cdcDiskObj->do_ToolTypes)
        {
            cnt = 0;
            while (ttypes[cnt])
            {
                if (ttypes[cnt][0] != '«')
                    i++;
                cnt++;
            }
        }

        if (new = AllocVec((i+1)*4,MEMF_CLEAR))
        {
            i    = 0;
            node = handlerList.lh_Head;
            while (node->ln_Succ)
            {
                HandlerInfo(node->ln_Name,&doFilter,&doTrans,&transType);
                len = strlen(node->ln_Name) + 7 + 7 + 4;
                if (transType)
                    len += strlen(transType) + 1;

                if (new[i] = AllocVec(len,MEMF_CLEAR))
                {
                    strcpy(new[i],"«");
                    strcat(new[i],node->ln_Name);
                    strcat(new[i],",");
                    if (doFilter)
                        strcat(new[i],"FILTER");
                    strcat(new[i],",");
                    if (doTrans)
                        strcat(new[i],"TRANS");
                    strcat(new[i],",");
                    if (transType)
                        strcat(new[i],transType);
                    strcat(new[i],"»");
                }
                i++;
                node = node->ln_Succ;
            }

            if (ttypes)
            {
                cnt = 0;
                while (ttypes[cnt])
                {
                    if (ttypes[cnt][0] != '«')
                    {
                        new[i++] = ttypes[cnt];
                    }
                    cnt++;
                }
            }

            cdcDiskObj->do_ToolTypes = new;
            PutDiskObject("PROGDIR:CrossDOS",cdcDiskObj);
            cdcDiskObj->do_ToolTypes = ttypes;

            i    = 0;
            node = handlerList.lh_Head;
            while (node->ln_Succ)
            {
                FreeVec(new[i++]);
                node = node->ln_Succ;
            }
            FreeVec(new);
        }
    }

    if (cdcDiskObj && allocated)
    {
        FreeDiskObject(cdcDiskObj);
        cdcDiskObj = NULL;
    }
}


/*****************************************************************************/


VOID NewList(struct List *list)
{
    list->lh_Head     = (struct Node *)&list->lh_Tail;
    list->lh_Tail     = NULL;
    list->lh_TailPred = (struct Node *)&list->lh_Head;
}


/*****************************************************************************/


struct Node *FindNameNC(struct List *list, STRPTR name)
{
struct Node *node;
WORD         result;

    node = list->lh_Head;
    while (node->ln_Succ)
    {
        result = Stricmp(name,node->ln_Name);
        if (result == 0)
            return(node);

	node = node->ln_Succ;
    }

    return(NULL);
}


/*****************************************************************************/


struct Node *FindNum(struct List *list, UWORD number)
{
struct Node *node;

    node = list->lh_Head;
    while (number--)
	node = node->ln_Succ;

    return (node);
}


/*****************************************************************************/


ULONG FindNodeNum(struct List *list, STRPTR name)
{
struct Node *node;
struct Node *current;
ULONG        number;

    if (!name)
        name = dummyNode.ln_Name;

    node = FindNameNC(list,name);

    number  = 0;
    current = list->lh_Head;

    while (current != node)
    {
	current = current->ln_Succ;
	number++;
    }

    return(number);
}


/*****************************************************************************/


VOID HandlerControl(STRPTR handlerName, BOOL doFilter, BOOL doTrans, STRPTR transType)
{
struct CrossDOSLock    *sem;
struct CrossDOSHandler *hdlr;
struct CrossDOSTrans   *trans;
struct DosList         *dl;
struct MsgPort         *replyPort;
struct DosPacket       *packet;
BPTR                    file;
char                    transName[60];
UWORD                   flags;
BOOL                    result;
UWORD                   len;
BOOL                    sent;
BOOL                    changed;

    Forbid();

    if (!(sem = (struct CrossDOSLock *)FindSemaphore(CROSSDOS_NAME)))
    {
        if (sem = AllocVec(sizeof(struct CrossDOSLock)+strlen(CROSSDOS_NAME)+1,MEMF_CLEAR))
        {
            sem->cdl_StructSize = sizeof(struct CrossDOSLock);
            InitSemaphore(sem);
            sem->cdl_Lock.ss_Link.ln_Name = (STRPTR)((ULONG)sem+sizeof(struct CrossDOSLock));
            strcpy(sem->cdl_Lock.ss_Link.ln_Name,CROSSDOS_NAME);
            NewList(&sem->cdl_Handlers);
            NewList(&sem->cdl_TransTables);
            AddSemaphore(sem);
        }
    }

    if (sem)
        ObtainSemaphore(sem);

    Permit();

    if (sem)
    {
        changed = FALSE;

        if (hdlr = (struct CrossDOSHandler *)FindNameNC(&sem->cdl_Handlers,handlerName))
        {
            trans = NULL;
            if (transType && (transType != dummyNode.ln_Name))
            {
                strcpy(transName,transType);
                len = strlen(transName);
                if ((len < 9) || Stricmp(&transName[len-9],".crossdos"))
                    strcat(transName,".crossdos");

                if (!(trans = (struct CrossDOSTrans *)FindNameNC(&sem->cdl_TransTables,transName)))
                {
                    if (trans = AllocVec(sizeof(struct CrossDOSTrans)+strlen(transName)+1,MEMF_CLEAR))
                    {
                        /* Once added to the list of translation
                         * tables, this memory should never be deallocated
                         * as CrossDOS can refer to it async
                         */

                        trans->cdt_StructSize = sizeof(struct CrossDOSTrans);
                        trans->cdt_Link.ln_Name = (STRPTR)((ULONG)trans+sizeof(struct CrossDOSTrans));
                        strcpy(trans->cdt_Link.ln_Name,transName);

                        strcpy(transName,CROSSDOS_TRANS);
                        AddPart(transName,trans->cdt_Link.ln_Name,sizeof(transName));

                        result = FALSE;
                        if (file = Open(transName,MODE_OLDFILE))
                        {
                            if (Read(file,trans->cdt_AToM,512) == 512)
                            {
                                /* The above Read() call fills in both cdt_AToM and cdt_MToA */
                                AddTail(&sem->cdl_TransTables,trans);
                                result = TRUE;
                            }
                            Close(file);
                        }

                        if (!result)
                        {
                            FreeVec(trans);
                            trans = NULL;
                        }
                    }
                }
            }

            flags = 0;
            if (doFilter)
                flags |= CDF_FILTER;

            if (doTrans)
                flags |= CDF_TRANSLATE;

            if ((hdlr->cdh_Flags != flags) || (hdlr->cdh_TransTable != trans))
                changed = TRUE;

            hdlr->cdh_Flags      = flags;
            hdlr->cdh_TransTable = trans;
        }

        ReleaseSemaphore(sem);

        if (changed)
        {
            if (replyPort = CreateMsgPort())
            {
                if (packet = AllocDosObject(DOS_STDPKT,0))
                {
                    sent = FALSE;

                    dl = LockDosList(LDF_DEVICES|LDF_READ);
                    if (dl = FindDosEntry(dl,handlerName,LDF_DEVICES | LDF_READ))
                    {
                        if (dl->dol_Task)
                        {
                            packet->dp_Type = ACTION_EVENT;
                            SendPkt(packet,dl->dol_Task,replyPort);
                            sent = TRUE;
                        }
                    }
                    UnLockDosList(LDF_DEVICES|LDF_READ);

                    if (sent)
                        WaitPort(replyPort);

                    FreeDosObject(DOS_STDPKT,packet);
                }
                DeleteMsgPort(replyPort);
            }
        }
    }
}


/*****************************************************************************/


VOID HandlerInfo(STRPTR handlerName, BOOL *doFilter, BOOL *doTrans, STRPTR *transType)
{
struct CrossDOSLock    *sem;
struct CrossDOSHandler *hdlr;

    *doFilter  = FALSE;
    *doTrans   = FALSE;
    *transType = NULL;

    Forbid();

    if (sem = (struct CrossDOSLock *)FindSemaphore(CROSSDOS_NAME))
        ObtainSemaphoreShared(sem);

    Permit();

    if (sem)
    {
        if (hdlr = (struct CrossDOSHandler *)FindNameNC(&sem->cdl_Handlers,handlerName))
        {
            if (CDF_FILTER & hdlr->cdh_Flags)
                *doFilter = TRUE;

            if (CDF_TRANSLATE & hdlr->cdh_Flags)
                *doTrans = TRUE;

            if (hdlr->cdh_TransTable)
                *transType = hdlr->cdh_TransTable->cdt_Link.ln_Name;
        }

        ReleaseSemaphore(sem);
    }
}


/*****************************************************************************/


VOID ProcessHandlerList(BOOL initial)
{
struct CrossDOSLock    *sem;
struct CrossDOSHandler *hdlr;
struct Node            *new;
struct Node            *node;
struct Task            *task;

    Forbid();

    if (sem = (struct CrossDOSLock *)FindSemaphore(CROSSDOS_NAME))
        ObtainSemaphore(sem);

    Permit();

    if (sem)
    {
        task = FindTask(NULL);

        hdlr = (struct CrossDOSHandler *)sem->cdl_Handlers.lh_Head;
        while (hdlr->cdh_Link.ln_Succ)
        {
            if (initial)
            {
                if (new = AllocVec(sizeof(struct Node) + strlen(hdlr->cdh_Link.ln_Name) + 1,MEMF_CLEAR))
                {
                    new->ln_Name = (STRPTR)((ULONG)new + sizeof(struct Node));
                    strcpy(new->ln_Name,hdlr->cdh_Link.ln_Name);

                    node = handlerList.lh_Head;
                    while (node->ln_Succ)
                    {
                        if (Stricmp(node->ln_Name,new->ln_Name) >= 0)
                            break;
                        node = node->ln_Succ;
                    }
                    Insert(&handlerList,(struct Node *)new,node->ln_Pred);
                }

                if (!hdlr->cdh_NotifyTask)
                {
                    hdlr->cdh_NotifyTask   = task;
                    hdlr->cdh_NotifySigBit = cxSignal;
                }
            }
            else
            {
                if (hdlr->cdh_NotifyTask == task)
                {
                    hdlr->cdh_NotifyTask   = NULL;
                    hdlr->cdh_NotifySigBit = 0;
                }
            }

            hdlr = (struct CrossDOSHandler *)hdlr->cdh_Link.ln_Succ;
        }

        ReleaseSemaphore(sem);
    }
}


/*****************************************************************************/


BOOL BuildTransList(STRPTR directory, STRPTR pattern, WORD strip)
{
UBYTE                exAllBuffer[512];
struct ExAllControl *eac;
struct ExAllData    *ead;
BPTR                 lock;
BOOL                 more;
char                 pat[20];
BOOL                 ok;
UWORD                len;
STRPTR		     name;
struct Node         *node;
struct Node         *new;
UWORD                cnt;

    dummyNode.ln_Name = "ASCII-7";
    AddHead(&transList,&dummyNode);

    cnt = 2;  /* 1 for the dummy node, 1 for the empty slot at the end of the array */

    ok = FALSE;
    if (eac = (struct ExAllControl *) AllocDosObject(DOS_EXALLCONTROL,0))
    {
        ParsePatternNoCase(pattern,pat,20);
        eac->eac_LastKey     = 0;
        eac->eac_MatchString = pat;

        ok = TRUE;
        if (lock = Lock(directory,ACCESS_READ))
        {
            do
            {
                more = ExAll(lock,(struct ExAllData *)exAllBuffer,sizeof(exAllBuffer),ED_TYPE,eac);
                if ((!more) && (IoErr() != ERROR_NO_MORE_ENTRIES))
                {
                    ok = FALSE;
                    break;
                }

                if (eac->eac_Entries > 0)
                {
                    ead = (struct ExAllData *) exAllBuffer;
                    do
                    {
                        if (ead->ed_Type < 0)
                        {
		            name = (STRPTR)ead->ed_Name;
		    	    len  = strlen(name) - strip;

			    if (new = AllocVec(sizeof(struct Node)+len+1,MEMF_CLEAR))
		            {
			        new->ln_Name = (STRPTR)((ULONG)new + sizeof(struct Node));
                                CopyMem(name,new->ln_Name,len);

                                node = transList.lh_Head;
                                while (node->ln_Succ)
                                {
                                    if (Stricmp(node->ln_Name,new->ln_Name) >= 0)
                                        break;
                                    node = node->ln_Succ;
                                }
                                Insert(&transList,new,node->ln_Pred);
                                cnt++;
			    }
                            else
                            {
                                ok = FALSE;
                                break;
                            }
                        }
                        ead = ead->ed_Next;
                    }
                    while (ead);
                }
            }
            while (more);

            UnLock(lock);
        }
        else
        {
            if (IoErr() != ERROR_OBJECT_NOT_FOUND)
                ok = FALSE;
        }

        FreeDosObject(DOS_EXALLCONTROL,eac);
    }

    if (ok && (transArray = AllocVec(cnt*4,MEMF_CLEAR)))
    {
        node = transList.lh_Head;
        cnt  = 0;
        while (node->ln_Succ)
        {
            transArray[cnt++] = node->ln_Name;
            node = node->ln_Succ;
        }
    }
    else
    {
        ok = FALSE;
    }

    return(ok);
}


/*****************************************************************************/


VOID EmptyList(struct List *list)
{
struct Node *node;

    while (node = RemHead(list))
    {
        if (node != &dummyNode)
            FreeVec(node);
    }
}


/*****************************************************************************/


VOID Terminate(VOID)
{
    ProcessHandlerList(FALSE);
    EmptyList(&handlerList);
    EmptyList(&transList);
    FreeVec(transArray);
    transArray = NULL;
    currentHandler = NULL;
}


/*****************************************************************************/


VOID RefreshGads(VOID)
{
char transName[32];

    GT_SetGadgetAttrs(filterGad,cxWindow,NULL,GTCB_Checked, doFilter,
                                              GA_Disabled,  currentHandler == NULL,
                                              TAG_DONE);

    GT_SetGadgetAttrs(transGad,cxWindow,NULL,GTCB_Checked, doTrans,
                                             GA_Disabled,  currentHandler == NULL,
                                             TAG_DONE);

    if (transType)
    {
        strcpy(transName,transType);
        transName[strlen(transName)-9] = 0;
    }
    else
    {
        strcpy(transName,dummyNode.ln_Name);
    }

    GT_SetGadgetAttrs(transListGad,cxWindow,NULL,GTCY_Active, FindNodeNum(&transList,transName),
                                                 GA_Disabled, currentHandler == NULL,
                                                 TAG_DONE);
}


/*****************************************************************************/


VOID RefreshWindow(BOOL refreshEvent)
{
    if (refreshEvent)
    {
        GT_BeginRefresh(cxWindow);
        GT_EndRefresh(cxWindow,TRUE);
    }
}


/*****************************************************************************/


BOOL ProcessCommand(UWORD cmd)
{
struct Node *node;
char         temp[50];

    switch (cmd)
    {
        case CMD_HIDE       : DisposeWindow();
                              Terminate();
                              break;

        case CMD_QUIT       : return(FALSE);

        case CMD_SAVE       : SaveCDCIcon();
                              break;

        case CMD_DEVICES    : currentHandler = FindNum(&handlerList,icode);
                              HandlerInfo(currentHandler->ln_Name,&doFilter,&doTrans,&transType);
                              RefreshGads();
                              break;

        case CMD_FILTER     : if (currentHandler)
                              {
                                  doFilter = (GFLG_SELECTED & filterGad->Flags);
                                  HandlerControl(currentHandler->ln_Name,doFilter,doTrans,transType);
                              }
                              break;

        case CMD_TRANS      : if (currentHandler)
                              {
                                  doTrans = (GFLG_SELECTED & transGad->Flags);
                                  HandlerControl(currentHandler->ln_Name,doFilter,doTrans,transType);
                              }
                              break;

        case CMD_TRANSLIST  : if (currentHandler)
                              {
                                  node = FindNum(&transList,icode);
                                  transType = node->ln_Name;
                                  HandlerControl(currentHandler->ln_Name,doFilter,doTrans,transType);
                              }
                              break;

        case CMD_NEWDISK    : temp[0] = 0;
                              if (currentHandler)
                              {
                                  stccpy(temp,currentHandler->ln_Name,sizeof(temp));
                                  currentHandler = NULL;
                              }

                              GT_SetGadgetAttrs(deviceGad,cxWindow,NULL,GTLV_Labels, ~0,
                                                                        TAG_DONE);

                              ProcessHandlerList(FALSE);
                              EmptyList(&handlerList);
                              ProcessHandlerList(TRUE);

                              if (currentHandler = FindNameNC(&handlerList,temp))
                                  HandlerInfo(currentHandler->ln_Name,&doFilter,&doTrans,&transType);

                              GT_SetGadgetAttrs(deviceGad,cxWindow,NULL,GTLV_Labels,   &handlerList,
                                                                        GTLV_Selected, FindNodeNum(&handlerList,temp),
                                                                        TAG_DONE);

                              RefreshGads();
                              break;
    }

    return(TRUE);
}


/*****************************************************************************/


BOOL CreateCustomCx(CxObj *broker)
{
    if (topazFont = OpenFont(&topazAttr))
    {
        return(TRUE);
    }

    return(FALSE);
}


/*****************************************************************************/


VOID DisposeCustomCx(VOID)
{
    CloseFont(topazFont);
    Terminate();
}
@


38.8
log
@Fixed dead lock problem when fiddling with the gadgets while a disk is inserted
@
text
@a13 2
#include <internal/crossdos.h>
#include <prefs/crossdos.h>
d37 1
a382 1
        Terminate();
d384 3
d643 1
a643 1
char                    transName[TRANSLATETABLENAMESIZE+30];
d648 1
d654 1
a654 1
        if (sem = AllocVec(sizeof(struct CrossDOSLock)+strlen(CROSSDOS_NAME)+1,MEMF_CLEAR|MEMF_PUBLIC))
d673 3
a675 1
        if (replyPort = CreateMsgPort())
d677 2
a678 1
            if (packet = AllocDosObject(DOS_STDPKT,0))
d680 20
a699 10
                sent = FALSE;
                if (hdlr = (struct CrossDOSHandler *)FindNameNC(&sem->cdl_Handlers,handlerName))
                {
                    trans = NULL;
                    if (transType && (transType != dummyNode.ln_Name))
                    {
                        strcpy(transName,transType);
                        len = strlen(transName);
                        if ((len < 9) || Stricmp(&transName[len-9],".crossdos"))
                            strcat(transName,".crossdos");
d701 2
a702 1
                        if (!(trans = (struct CrossDOSTrans *)FindNameNC(&sem->cdl_TransTables,transName)))
d704 1
a704 1
                            if (trans = AllocVec(sizeof(struct CrossDOSTrans)+strlen(transName)+1,MEMF_CLEAR|MEMF_PUBLIC))
d706 3
a708 28
                                /* Once added to the list of translation
                                 * tables, this memory should never be deallocated
                                 * as CrossDOS can refer to it async
                                 */

                                trans->cdt_StructSize = sizeof(struct CrossDOSTrans);
                                trans->cdt_Link.ln_Name = (STRPTR)((ULONG)trans+sizeof(struct CrossDOSTrans));
                                strcpy(trans->cdt_Link.ln_Name,transName);

                                strcpy(transName,CROSSDOS_TRANS);
                                AddPart(transName,trans->cdt_Link.ln_Name,sizeof(transName));

                                result = FALSE;
                                if (file = Open(transName,MODE_OLDFILE))
                                {
                                    if (Read(file,trans->cdt_AToM,512) == 512)
                                    {
                                        /* The above Read() call fills in both cdt_AToM and cdt_MToA */
                                        AddTail(&sem->cdl_TransTables,trans);
                                        result = TRUE;
                                    }
                                }

                                if (!result)
                                {
                                    FreeVec(trans);
                                    trans = NULL;
                                }
d710 1
d712 19
a730 1
                    }
d732 3
a734 3
                    flags = 0;
                    if (doFilter)
                        flags |= CDF_FILTER;
d736 1
a736 2
                    if (doTrans)
                        flags |= CDF_TRANSLATE;
d738 7
a744 2
                    hdlr->cdh_Flags      = flags;
                    hdlr->cdh_TransTable = trans;
a756 1
                }
d758 2
a759 1
                ReleaseSemaphore(sem);
d761 3
a763 4
                if (sent)
                    WaitPort(replyPort);

                FreeDosObject(DOS_STDPKT,packet);
a764 1
            DeleteMsgPort(replyPort);
d835 1
a835 1
                if (new = AllocVec(sizeof(struct Node) + strlen(hdlr->cdh_Link.ln_Name) + 1,MEMF_CLEAR|MEMF_PUBLIC))
d838 1
a838 1
                    CopyMem(hdlr->cdh_Link.ln_Name,new->ln_Name,strlen(hdlr->cdh_Link.ln_Name)+1);
d903 1
a905 1
            ok = TRUE;
d925 1
a925 1
			    if (new = AllocVec(sizeof(struct Node)+len+1,MEMF_PUBLIC|MEMF_CLEAR))
d955 6
d964 1
a964 1
    if (ok && (transArray = AllocVec(cnt*4,MEMF_CLEAR|MEMF_PUBLIC)))
d1008 1
@


38.7
log
@*** empty log message ***
@
text
@d639 2
d646 1
d671 1
a671 1
        if (hdlr = (struct CrossDOSHandler *)FindNameNC(&sem->cdl_Handlers,handlerName))
d673 1
a673 2
            trans = NULL;
            if (transType && (transType != dummyNode.ln_Name))
d675 2
a676 6
                strcpy(transName,transType);
                len = strlen(transName);
                if ((len < 9) || Stricmp(&transName[len-9],".crossdos"))
                    strcat(transName,".crossdos");

                if (!(trans = (struct CrossDOSTrans *)FindNameNC(&sem->cdl_TransTables,transName)))
d678 2
a679 1
                    if (trans = AllocVec(sizeof(struct CrossDOSTrans)+strlen(transName)+1,MEMF_CLEAR|MEMF_PUBLIC))
d681 4
a684 4
                        /* Once added to the list of translation
                         * tables, this memory should never be deallocated
                         * as CrossDOS can refer to it async
                         */
d686 1
a686 9
                        trans->cdt_StructSize = sizeof(struct CrossDOSTrans);
                        trans->cdt_Link.ln_Name = (STRPTR)((ULONG)trans+sizeof(struct CrossDOSTrans));
                        strcpy(trans->cdt_Link.ln_Name,transName);

                        strcpy(transName,CROSSDOS_TRANS);
                        AddPart(transName,trans->cdt_Link.ln_Name,sizeof(transName));

                        result = FALSE;
                        if (file = Open(transName,MODE_OLDFILE))
d688 1
a688 1
                            if (Read(file,trans->cdt_AToM,512) == 512)
d690 28
a717 3
                                /* The above Read() call fills in both cdt_AToM and cdt_MToA */
                                AddTail(&sem->cdl_TransTables,trans);
                                result = TRUE;
d720 11
d732 4
a735 1
                        if (!result)
d737 3
a739 2
                            FreeVec(trans);
                            trans = NULL;
d742 1
a743 1
            }
d745 1
a745 3
            flags = 0;
            if (doFilter)
                flags |= CDF_FILTER;
d747 2
a748 5
            if (doTrans)
                flags |= CDF_TRANSLATE;

            hdlr->cdh_Flags      = flags;
            hdlr->cdh_TransTable = trans;
d750 1
a750 7
            dl = LockDosList(LDF_DEVICES|LDF_READ);
            if (dl = FindDosEntry(dl,handlerName,LDF_DEVICES | LDF_READ))
            {
                if (dl->dol_Task)
                {
                    DoPkt0(dl->dol_Task,ACTION_EVENT);
                }
d752 1
a752 1
            UnLockDosList(LDF_DEVICES|LDF_READ);
a753 2

        ReleaseSemaphore(sem);
a754 1

d1030 1
a1031 2

    if (refreshEvent)
d1033 1
d1086 1
a1086 1
                                  strncpy(temp,currentHandler->ln_Name,sizeof(temp));
@


38.6
log
@Now reads the icon tooltypes even when run from the shell
@
text
@d212 1
d214 4
a217 5
        if (allocated)
        {
            FreeDiskObject(cdcDiskObj);
            cdcDiskObj = NULL;
        }
d545 1
d547 4
a550 5
        if (allocated)
        {
            FreeDiskObject(cdcDiskObj);
            cdcDiskObj = NULL;
        }
@


38.5
log
@Fixed icon saving
@
text
@d140 1
d146 6
a151 1
    cdcDiskObj = diskObj;
d153 1
a153 1
    if (diskObj && (ptr = diskObj->do_ToolTypes))
d212 6
a461 1

d464 2
a465 5
        if (IconBase || (IconBase = OpenLibrary("icon.library",37)))
        {
            cdcDiskObj = GetDiskObject("PROGDIR:CrossDOS");
            allocated = TRUE;
        }
@


38.4
log
@Made window a bit larger
@
text
@d518 1
a518 1
                        new[i] = ttypes[cnt];
d528 2
d532 1
a532 2
                i++;
                FreeVec(new[i]);
@


38.3
log
@Correctly handles translation table searching
Correctly NULL terminates array of translation tables for cycle gadget
@
text
@d351 1
a351 1
            ng.ng_Width      = 174;
@


38.2
log
@Now checks for IDCMP_DISKINSERTED
@
text
@d638 1
a638 1
    if (!(sem = (struct CrossDOSLock *)FindSemaphore(CROSSDOSNAME)))
d640 1
a640 1
        if (sem = AllocVec(sizeof(struct CrossDOSLock)+strlen(CROSSDOSNAME)+1,MEMF_CLEAR|MEMF_PUBLIC))
d645 1
a645 1
            strcpy(sem->cdl_Lock.ss_Link.ln_Name,CROSSDOSNAME);
d666 1
a666 1
                if ((len > 9) && Stricmp(&transName[len-9],".crossdos"))
d856 1
a856 1
    cnt = 1;
d926 1
a926 2
            transArray[cnt] = node->ln_Name;
            cnt++;
@


38.1
log
@Initial V38 RCS checkin
@
text
@d96 1
a120 1
ULONG FindNodeNum(struct List *list, STRPTR name);
d126 1
d277 3
d983 9
a991 2
    strcpy(transName,transType);
    transName[strlen(transName)-9] = 0;
d1018 1
d1056 24
@
