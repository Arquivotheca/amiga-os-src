head     38.21;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


38.21
date     92.10.22.11.56.04;  author vertex;  state Exp;
branches ;
next     38.20;

38.20
date     92.10.16.18.47.56;  author vertex;  state Exp;
branches ;
next     38.19;

38.19
date     92.04.30.17.36.18;  author vertex;  state Exp;
branches ;
next     38.18;

38.18
date     92.03.27.13.14.29;  author vertex;  state Exp;
branches ;
next     38.17;

38.17
date     92.03.27.13.02.31;  author vertex;  state Exp;
branches ;
next     38.16;

38.16
date     92.03.27.12.16.23;  author vertex;  state Exp;
branches ;
next     38.15;

38.15
date     92.03.25.13.30.53;  author vertex;  state Exp;
branches ;
next     38.14;

38.14
date     92.03.23.15.17.26;  author vertex;  state Exp;
branches ;
next     38.13;

38.13
date     92.03.12.13.00.46;  author vertex;  state Exp;
branches ;
next     38.12;

38.12
date     92.02.25.11.23.18;  author vertex;  state Exp;
branches ;
next     38.11;

38.11
date     92.02.18.16.59.56;  author vertex;  state Exp;
branches ;
next     38.10;

38.10
date     92.02.11.16.07.07;  author vertex;  state Exp;
branches ;
next     38.9;

38.9
date     92.02.10.11.48.42;  author vertex;  state Exp;
branches ;
next     38.8;

38.8
date     91.12.03.12.47.30;  author vertex;  state Exp;
branches ;
next     38.7;

38.7
date     91.11.22.13.10.57;  author vertex;  state Exp;
branches ;
next     38.6;

38.6
date     91.11.12.10.20.00;  author vertex;  state Exp;
branches ;
next     38.5;

38.5
date     91.11.12.10.16.54;  author vertex;  state Exp;
branches ;
next     38.4;

38.4
date     91.11.11.18.06.34;  author vertex;  state Exp;
branches ;
next     38.3;

38.3
date     91.10.28.14.14.06;  author vertex;  state Exp;
branches ;
next     38.2;

38.2
date     91.10.24.11.07.36;  author vertex;  state Exp;
branches ;
next     38.1;

38.1
date     91.10.24.09.49.40;  author vertex;  state Exp;
branches ;
next     ;


desc
@FKey commodity
@


38.21
log
@Removing debugging output
@
text
@
#include <exec/types.h>
#include <exec/libraries.h>
#include <exec/memory.h>
#include <devices/inputevent.h>
#include <intuition/intuitionbase.h>
#include <intuition/intuition.h>
#include <intuition/gadgetclass.h>
#include <libraries/commodities.h>
#include <graphics/displayinfo.h>
#include <graphics/text.h>
#include <graphics/gfxmacros.h>
#include <hardware/custom.h>
#include <hardware/dmabits.h>
#include <dos/dostags.h>
#include <rexx/storage.h>
#include <string.h>

#include <clib/exec_protos.h>
#include <clib/layers_protos.h>
#include <clib/intuition_protos.h>
#include <clib/commodities_protos.h>
#include <clib/icon_protos.h>
#include <clib/graphics_protos.h>
#include <clib/dos_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/utility_protos.h>
#include <clib/rexxsyslib_protos.h>

#include <pragmas/exec_pragmas.h>
#include <pragmas/layers_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/commodities_pragmas.h>
#include <pragmas/icon_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/gadtools_pragmas.h>
#include <pragmas/utility_pragmas.h>
#include <pragmas/rexxsyslib_pragmas.h>

#include "ce_custom.h"
#include "ce_window.h"
#include "ce_strings.h"


/*****************************************************************************/


VOID kprintf(STRPTR,...);

struct KeySequence
{
    struct Node        fk_Node;
    UWORD	       fk_Cmd;
    STRPTR	       fk_Args;

    /* for use with CMD_INSERT command */
    struct InputEvent *fk_KeyEvents;
};


/*****************************************************************************/


extern struct Library       *SysBase;
extern struct IntuitionBase *IntuitionBase;
extern struct Library       *CxBase;
extern struct Library       *IconBase;
extern struct Library       *GfxBase;
extern struct Library       *DOSBase;
extern struct Library       *GadToolsBase;
extern struct Library       *UtilityBase;
extern LONG                  cxSignal;
extern struct MsgPort       *cxPort;
extern CxObj                *cxBroker;
extern struct Gadget        *cxGadgets;
extern struct Menu          *cxMenus;
extern struct Window        *cxWindow;
extern APTR                  cxVisualInfo;
extern struct DrawInfo      *cxDrawInfo;

/* from IntuiMessage */
ULONG              class;
UWORD              icode;
struct Gadget     *gad;

struct Gadget      *keysGad;
struct Gadget      *addGad;
struct Gadegt      *removeGad;
struct Gadget      *seqGad;
struct Gadget      *cmdGad;
struct Gadget      *argGad;
STRPTR              cmdLabels[9];
struct List         keyList;
struct KeySequence *currentKey;
CxObj              *mainFilter;
struct DiskObject  *fkeyDiskObj;
struct Library     *RexxSysBase;


/*****************************************************************************/


struct InputXpression filterIX =
{
    IX_VERSION,
    IECLASS_RAWKEY,

    0,
    0,

    0,
    0,
    0
};


/*****************************************************************************/


/* UI commands */
#define CMD_NOP        0
#define CMD_HIDE       1
#define CMD_QUIT       2
#define CMD_KEYLIST    3
#define CMD_ADD        4
#define CMD_REMOVE     5
#define CMD_SEQUENCE   6
#define CMD_COMMAND    7
#define CMD_ARGS       8
#define CMD_SAVE       9


/*****************************************************************************/


/* Hot key commands */
#define CMD_CYCLEW   0
#define CMD_CYCLES   1
#define CMD_MAKEBIG  2
#define CMD_MAKESMAL 3
#define CMD_TOGGLE   4
#define CMD_INSERT   5
#define CMD_PROGRAM  6
#define CMD_AREXX    7


/*****************************************************************************/


/* Name of hot key commands, for icon tool types */
STRPTR Commands[] =
{
    "CYCLE",
    "CYCLESCREEN",
    "MAKEBIG",
    "MAKESMALL",
    "ZIPWINDOW",
    "INSERT",
    "RUN",
    "AREXX",
    NULL
};


/*****************************************************************************/


#define CONSOLE_SPEC "CON:0/25/640/150/FKey/AUTO/CLOSE/WAIT"


/*****************************************************************************/


struct TextAttr far topazAttr =
{
    "topaz.font",
    8,
    FS_NORMAL,
    FPF_ROMFONT
};


/*****************************************************************************/


BOOL ProcessCommand(UWORD cmd);
struct InputEvent * __stdargs InvertString(STRPTR,APTR);
VOID __stdargs FreeIEvents(struct InputEvent *);


/*****************************************************************************/


VOID NewList(struct List *list)
{
    list->lh_Head     = (struct Node *)&list->lh_Tail;
    list->lh_Tail     = NULL;
    list->lh_TailPred = (struct Node *)&list->lh_Head;
}


/*****************************************************************************/


struct Node *FindNum(struct List *list, UWORD number)
{
struct Node *node;

    node = list->lh_Head;
    while (node->ln_Succ && number--)
	node = node->ln_Succ;

    if (node->ln_Succ)
        return(node);

    return(NULL);
}


/*****************************************************************************/


ULONG FindNodeNum(struct List *list, struct Node *node)
{
struct Node *current;
ULONG        number;

    number  = 0;
    current = list->lh_Head;

    while (current != node)
    {
	current = current->ln_Succ;
	number++;
    }

    return(number);
}


/*****************************************************************************/


LONG WB2CLI(struct WBStartup *wbMsg, ULONG defaultStack)
{
struct Process		    *process;
struct CommandLineInterface *cli;
struct MsgPort		    *wbPort;
struct Process		    *wbProc;
struct CommandLineInterface *wbCLI;
ULONG			    *wbPath;
ULONG			    *lastPath;
ULONG			    *tmp;
STRPTR                       prompt;

    process = (struct Process *)FindTask(NULL);
    cli     = BADDR(process->pr_CLI);

    if (!cli && wbMsg && (cli = AllocDosObjectTagList(DOS_CLI,NULL)))
    {
        cli->cli_DefaultStack  = ((defaultStack+3) / 4);
        process->pr_CLI        = MKBADDR(cli);
        process->pr_Flags     |= PRF_FREECLI;

        Forbid();

        if (wbPort = wbMsg->sm_Message.mn_ReplyPort)
        {
            if ((wbPort->mp_Flags & PF_ACTION) == PA_SIGNAL)
            {
                if (wbProc = wbPort->mp_SigTask)
                {
                    if (wbProc->pr_Task.tc_Node.ln_Type == NT_PROCESS)
                    {
                        if (wbCLI = BADDR(wbProc->pr_CLI))
                        {
			    prompt = BADDR(wbCLI->cli_Prompt);
                            if (prompt)
                                SetPrompt(&(prompt[1]));

                            wbPath   = BADDR(wbCLI->cli_CommandDir);
                            lastPath = &(cli->cli_CommandDir);
                            while (wbPath)
                            {
                                if (wbPath[1])
                                {
                                    if (tmp = AllocVec(8,MEMF_CLEAR))
                                    {
                                        if (!(tmp[1] = DupLock(wbPath[1])))
                                        {
                                            FreeVec(tmp);
                                            break;
                                        }
                                        lastPath[0] = MKBADDR(tmp);
                                        lastPath    = tmp;
                                    }
                                    else
                                    {
                                        break;
                                    }
                                }

                                wbPath = BADDR(wbPath[0]);
                            }
                        }
                    }
                }
            }
        }

        Permit();
    }

    return((LONG)cli);
}


/*****************************************************************************/


VOID CycleWindows(VOID)
{
LONG           lock;
struct Window *window;
struct Screen *screen;
struct Layer  *rearLayer = NULL;
struct Layer  *layer;
struct Window *layerWindow;

    lock = LockIBase(0);

    if (window = IntuitionBase->ActiveWindow)
    {
        screen = window->WScreen;

        /* find rearmost layer which is not a backdrop window,
         * nor the bar layer, nor a WBENCHWINDOW
         */
        for (layer = screen->LayerInfo.top_layer; layer; layer = layer->back)
        {
            layerWindow = (struct Window *) layer->Window;

            if ((layer != screen->BarLayer)
            && (!(layer->Flags & LAYERBACKDROP))
            && (layerWindow))
            {
                rearLayer = layer;
            }
        }
    }

    UnlockIBase(lock);

    if (rearLayer)
    {
        layerWindow = (struct Window *) rearLayer->Window;
        WindowToFront(layerWindow);
        ActivateWindow(layerWindow);
    }
}


/*****************************************************************************/


VOID CycleScreens(VOID)
{
    ScreenToBack(IntuitionBase->FirstScreen);
}


/*****************************************************************************/


VOID ToggleWindow(VOID)
{
struct Window *window;

    if (window = IntuitionBase->ActiveWindow)
        if (!(window->IDCMPFlags & IDCMP_SIZEVERIFY))
            if (window->Flags & WFLG_HASZOOM)
                ZipWindow(window);
}


/*****************************************************************************/


#define IMINWIDTH  40
#define IMINHEIGHT 30
#define MIN(A,B)   (((A)<(B))?(A):(B))
#define MAX(A,B)   (((A)>(B))?(A):(B))


VOID WindowSize(BOOL makeBig)
{
ULONG          lock;
struct Window *window;
struct Screen *screen;
SHORT          deltaw = 0;
SHORT          deltah = 0;
ULONG          sizing = FALSE;

    lock = LockIBase(0);

    if (window = IntuitionBase->ActiveWindow)
    {
        screen = window->WScreen;

        if (makeBig)
        {
            deltaw = MIN(screen->Width - window->LeftEdge, (unsigned) window->MaxWidth) - window->Width;
            deltah = MIN(screen->Height - window->TopEdge, (unsigned) window->MaxHeight) - window->Height;
        }
        else
        {
            deltaw = MAX(window->MinWidth, IMINWIDTH) - window->Width;
            deltah = MAX(window->MinHeight, IMINHEIGHT) - window->Height;
        }

        sizing = (window->Flags & WFLG_SIZEGADGET) && (!(window->IDCMPFlags & IDCMP_SIZEVERIFY));
    }

    UnlockIBase(lock);

    if (sizing)
        SizeWindow(window,deltaw,deltah);
}


/*****************************************************************************/


VOID StartProgram(STRPTR progName)
{
BPTR file;

    if (file = Open(CONSOLE_SPEC,MODE_NEWFILE))
    {
        if (SystemTags(progName,SYS_UserShell, TRUE,
                                SYS_Asynch,    TRUE,
                                SYS_Input,     file,
                                SYS_Output,    NULL,
                                TAG_DONE))
        {
            Close(file);
        }
    }
}


/*****************************************************************************/


VOID StartScript(STRPTR scriptName)
{
APTR            arg;
struct RexxMsg *msg;
struct MsgPort *rexx;
struct Process *process;

    process = (struct Process *)FindTask(NULL);

    if (rexx = FindPort("AREXX"))
    {
        if (RexxSysBase = OpenLibrary("rexxsyslib.library",36))
        {
            if (arg = CreateArgstring(scriptName,strlen(scriptName)))
            {
                if (msg = CreateRexxMsg(&process->pr_MsgPort,NULL,NULL))
                {
                    msg->rm_Action  = RXCOMM;
                    msg->rm_Args[0] = arg;
                    msg->rm_Stdin   = NULL;
                    msg->rm_Stdout  = NULL;

                    Forbid();
                    if (rexx = FindPort("AREXX"))
                    {
                        PutMsg(rexx,msg);
                        WaitPort(&process->pr_MsgPort);
                        GetMsg(&process->pr_MsgPort);
                    }
                    Permit();

                    DeleteRexxMsg(msg);
                }
                DeleteArgstring(arg);
            }
            CloseLibrary(RexxSysBase);
        }
    }
}


/*****************************************************************************/


struct KeySequence *GetSequence(STRPTR sequence, UWORD cmd, STRPTR args)
{
struct KeySequence *key;
UWORD               len;

    len = sizeof(struct KeySequence) + strlen(sequence) + 2;

    if (cmd >= CMD_INSERT)
        len += strlen(args);

    if (key = AllocVec(len,MEMF_CLEAR))
    {
        key->fk_Node.ln_Name = (APTR)((ULONG)key+sizeof(struct KeySequence));
        key->fk_Cmd          = cmd;
        key->fk_Args         = (APTR)((ULONG)key->fk_Node.ln_Name + strlen(sequence)+1);
        strcpy(key->fk_Node.ln_Name,sequence);

        if (cmd >= CMD_INSERT)
        {
            strcpy(key->fk_Args,args);

            if (cmd == CMD_INSERT)
                key->fk_KeyEvents = InvertString(args,NULL);
        }
    }

    return(key);
}


/*****************************************************************************/


VOID FreeSequence(struct KeySequence *key)
{
    FreeIEvents(key->fk_KeyEvents);
    FreeVec(key);
}


/*****************************************************************************/


struct KeySequence *UpdateSequence(struct KeySequence *key, STRPTR sequence,
                                   STRPTR args)
{
struct KeySequence *new;

    if (key)
    {
        if (new = GetSequence(sequence,key->fk_Cmd,args))
        {
            Insert(&keyList,new,key);
            Remove(key);
            FreeSequence(key);
            return(new);
        }
    }

    return(key);
}


/*****************************************************************************/


VOID SaveFKeyIcon(VOID)
{
STRPTR             *ttypes;
STRPTR             *new;
BOOL                allocated;
UWORD               i;
UWORD               len;
UWORD               cnt;
struct KeySequence *key;

    allocated = FALSE;
    if (!fkeyDiskObj)
    {
        fkeyDiskObj = GetDiskObject("PROGDIR:FKey");
        allocated = TRUE;
    }

    if (fkeyDiskObj)
    {
        i   = 0;
        key = (struct KeySequence *)keyList.lh_Head;
        while (key->fk_Node.ln_Succ)
        {
            i++;
            key = (struct KeySequence *)key->fk_Node.ln_Succ;
        }

        if (ttypes = fkeyDiskObj->do_ToolTypes)
        {
            cnt = 0;
            while (ttypes[cnt])
            {
                if (ttypes[cnt][0] != '«')
                    i++;
                cnt++;
            }
        }

        if (new = AllocVec((i+1)*4,MEMF_CLEAR))
        {
            i   = 0;
            key = (struct KeySequence *)keyList.lh_Head;
            while (key->fk_Node.ln_Succ)
            {
                len = sizeof(struct KeySequence)+strlen(key->fk_Node.ln_Name)+strlen(key->fk_Args)+6;
                if (new[i] = AllocVec(len,MEMF_CLEAR))
                {
                    strcpy(new[i],"«");
                    strcat(new[i],key->fk_Node.ln_Name);
                    strcat(new[i],"» ");
                    strcat(new[i],Commands[key->fk_Cmd]);

                    if (key->fk_Cmd >= CMD_INSERT)
                    {
                        strcat(new[i]," ");
                        strcat(new[i],key->fk_Args);
                    }
                }
                i++;
                key = (struct KeySequence *)key->fk_Node.ln_Succ;
            }

            if (ttypes)
            {
                cnt = 0;
                while (ttypes[cnt])
                {
                    if (ttypes[cnt][0] != '«')
                    {
                        new[i++] = ttypes[cnt];
                    }
                    cnt++;
                }
            }

            fkeyDiskObj->do_ToolTypes = new;
            PutDiskObject("PROGDIR:FKey",fkeyDiskObj);
            fkeyDiskObj->do_ToolTypes = ttypes;

            i   = 0;
            key = (struct KeySequence *)keyList.lh_Head;
            while (key->fk_Node.ln_Succ)
            {
                FreeVec(new[i++]);
                key = (struct KeySequence *)key->fk_Node.ln_Succ;
            }
            FreeVec(new);
        }

        if (allocated)
        {
            FreeDiskObject(fkeyDiskObj);
            fkeyDiskObj = NULL;
        }
    }
}


/*****************************************************************************/


BOOL ProcessCustomArgs(struct WBStartup *wbMsg, struct DiskObject *diskObj,
                       ULONG *cliOpts)
{
STRPTR             *ptr;
STRPTR              name;
STRPTR              cmd;
UWORD               i,j;
UWORD               cmdCnt;
struct KeySequence *key;
struct Node        *node;
BOOL                allocated;

    NewList(&keyList);

    allocated = FALSE;
    if (!(fkeyDiskObj = diskObj))
    {
        fkeyDiskObj = GetDiskObject("PROGDIR:FKey");
        allocated = TRUE;
    }

    if (fkeyDiskObj && (ptr = fkeyDiskObj->do_ToolTypes))
    {
        while (name = *ptr)
        {
            if (name[0] == '«')
            {
                i = 0;
                name++;
                while (name[i] && (name[i] != '»'))
                    i++;

                if (name[i] == '»')
                {
                    name[i] = 0;

                    /* at this point, "name" contains the kbd sequence */

                    /* skip spaces */
                    j = 0;
                    cmd = &name[i+1];
                    while (cmd[j] && (cmd[j] == ' '))
                        j++;

                    cmd = &cmd[j];
                    while (cmd[j] && (cmd[j] != ' '))
                        j++;

                    cmd[j] = 0;

                    /* at this point, "cmd" has the name of the cmd to execute */

                    if (j)
                    {
                        cmdCnt = 0;
                        while (Commands[cmdCnt])
                        {
                            if (Stricmp(Commands[cmdCnt],cmd) == 0)
                            {
                                if (key = GetSequence(name,cmdCnt,&cmd[j+1]))
                                {
                                    node = keyList.lh_Head;
                                    while (node->ln_Succ)
                                    {
                                        if (Stricmp(node->ln_Name,key->fk_Node.ln_Name) >= 0)
                                            break;
                                        node = node->ln_Succ;
                                    }
                                    Insert(&keyList,(struct Node *)key,node->ln_Pred);
                                }
                                break;
                            }
                            cmdCnt++;
                        }
                        cmd[j] = ' ';
                    }
                    name[i] = '»';
                }
            }
            ptr++;
        }
    }

    if (fkeyDiskObj && allocated)
    {
        FreeDiskObject(fkeyDiskObj);
        fkeyDiskObj = NULL;
    }

    WB2CLI(wbMsg,4096);
    return(TRUE);
}


/*****************************************************************************/


VOID ProcessCustomCxMsg(ULONG cmd)
{
struct KeySequence *key;
struct KeySequence *check;

    key   = (struct KeySequence *)cmd;
    check = (struct KeySequence *)keyList.lh_Head;

    while (check->fk_Node.ln_Succ)
    {
        if (check == key)
        {
            switch (key->fk_Cmd)
            {
                case CMD_CYCLEW   : CycleWindows();
                                    break;

                case CMD_CYCLES   : CycleScreens();
                                    break;

                case CMD_MAKEBIG  : WindowSize(TRUE);
                                    break;

                case CMD_MAKESMAL : WindowSize(FALSE);
                                    break;

                case CMD_TOGGLE   : ToggleWindow();
                                    break;

                case CMD_PROGRAM  : StartProgram(key->fk_Args);
                                    break;

                case CMD_AREXX    : StartScript(key->fk_Args);
                                    break;
            }
            return;
        }
        check = (struct KeySequence *)check->fk_Node.ln_Succ;
    }
}


/*****************************************************************************/


VOID ProcessCustomCxSig()
{
}


/*****************************************************************************/


VOID ProcessCustomCxCmd(ULONG cmd)
{
}


/*****************************************************************************/


BOOL ProcessIntuiMsg(struct IntuiMessage *intuiMsg)
{
BOOL             ok;
UWORD            menuNum;
struct MenuItem *menuItem;

    class = intuiMsg->Class;
    icode = intuiMsg->Code;
    gad   = intuiMsg->IAddress;
    GT_ReplyIMsg(intuiMsg);

    ok = TRUE;
    switch (class)
    {
        case IDCMP_CLOSEWINDOW  : ok = ProcessCommand(CMD_HIDE);
                                  break;

        case IDCMP_REFRESHWINDOW: RefreshWindow(TRUE);
                                  break;

        case IDCMP_MENUPICK     : menuNum = icode;
                                  while ((menuNum != MENUNULL) && (ok))
                                  {
                                      menuItem = ItemAddress(cxMenus,menuNum);
                                      ok = ProcessCommand((UWORD)MENU_USERDATA(menuItem));

                                      if (cxMenus == NULL)
                                          break;

                                      menuNum = menuItem->NextSelect;
                                  }
                                  break;

        case IDCMP_GADGETUP     :
        case IDCMP_GADGETDOWN   : ok = ProcessCommand((UWORD)gad->UserData);
                                  break;
    }

    return(ok);
}


/*****************************************************************************/


BOOL CreateCustomGadgets(VOID)
{
struct NewGadget  ng;
struct Gadget    *gad;

    currentKey   = NULL;

    cmdLabels[0] = GetString(MSG_FK_CMD_CYCLEW);
    cmdLabels[1] = GetString(MSG_FK_CMD_CYCLES);
    cmdLabels[2] = GetString(MSG_FK_CMD_MAKEBIG);
    cmdLabels[3] = GetString(MSG_FK_CMD_MAKESMALL);
    cmdLabels[4] = GetString(MSG_FK_CMD_TOGGLE);
    cmdLabels[5] = GetString(MSG_FK_CMD_INSERT);
    cmdLabels[6] = GetString(MSG_FK_CMD_PROGRAM);
    cmdLabels[7] = GetString(MSG_FK_CMD_AREXX);
    cmdLabels[8] = NULL;

    if (gad = CreateContext(&cxGadgets))
    {
	/* Some invariants */
        ng.ng_TextAttr   = &topazAttr;
        ng.ng_GadgetID   = 0;
        ng.ng_Flags      = 0;
        ng.ng_VisualInfo = cxVisualInfo;

        ng.ng_TopEdge    = cxWindow->BorderTop+16;
        ng.ng_LeftEdge   = cxWindow->BorderLeft+8;
        ng.ng_Width      = 260;
        ng.ng_Height     = 62;
        ng.ng_GadgetText = GetString(MSG_FK_DEFKEYS_GAD);
        ng.ng_UserData   = (APTR)CMD_KEYLIST;

        keysGad = CreateGadget(LISTVIEW_KIND,gad,&ng,GTLV_Labels,       &keyList,
                                                     LAYOUTA_SPACING,   1,
                                                     GTLV_ScrollWidth,  18,
                                                     GTLV_ShowSelected, NULL,
                                                     TAG_DONE);

        ng.ng_TopEdge    = cxWindow->BorderTop+74;
        ng.ng_LeftEdge   = cxWindow->BorderLeft+8;
        ng.ng_Width      = 260;
        ng.ng_Height     = 14;
        ng.ng_GadgetText = NULL;
        ng.ng_UserData   = (APTR)CMD_SEQUENCE;

        seqGad = CreateGadget(STRING_KIND,keysGad,&ng,GA_Disabled,   TRUE,
                                                      GTST_MaxChars, 39,
                                                      TAG_DONE);

        ng.ng_TopEdge    = cxWindow->BorderTop+88;
        ng.ng_LeftEdge   = cxWindow->BorderLeft+8;
        ng.ng_Width      = 130;
        ng.ng_Height     = 14;
        ng.ng_GadgetText = GetString(MSG_FK_ADDKEY_GAD);
        ng.ng_UserData   = (APTR)CMD_ADD;

        addGad = CreateGadget(BUTTON_KIND,seqGad,&ng,TAG_DONE);

        ng.ng_TopEdge    = cxWindow->BorderTop+88;
        ng.ng_LeftEdge   = cxWindow->BorderLeft+138;
        ng.ng_Width      = 130;
        ng.ng_Height     = 14;
        ng.ng_GadgetText = GetString(MSG_FK_REMKEY_GAD);
        ng.ng_UserData   = (APTR)CMD_REMOVE;

        removeGad = CreateGadget(BUTTON_KIND,addGad,&ng,GA_Disabled, TRUE,
							TAG_DONE);

        ng.ng_TopEdge    = cxWindow->BorderTop+31;
        ng.ng_LeftEdge   = cxWindow->BorderLeft+276;
        ng.ng_Width      = 240;
        ng.ng_Height     = 14;
        ng.ng_GadgetText = GetString(MSG_FK_CMD_GAD);
        ng.ng_Flags      = PLACETEXT_ABOVE;
        ng.ng_UserData   = (APTR)CMD_COMMAND;

        cmdGad = CreateGadget(CYCLE_KIND,removeGad,&ng,GTCY_Labels, &cmdLabels,
                                                       GA_Disabled, TRUE,
						       TAG_DONE);

        ng.ng_TopEdge    = cxWindow->BorderTop+67;
        ng.ng_LeftEdge   = cxWindow->BorderLeft+276;
        ng.ng_Width      = 240;
        ng.ng_Height     = 14;
        ng.ng_GadgetText = GetString(MSG_FK_PARMS_GAD);
        ng.ng_Flags      = PLACETEXT_ABOVE;
        ng.ng_UserData   = (APTR)CMD_ARGS;

        if (argGad = CreateGadget(STRING_KIND,cmdGad,&ng,GA_Disabled,   TRUE,
                                                         GTST_MaxChars, 255,
							 TAG_DONE))
        {
            AddGList(cxWindow,cxGadgets,-1,-1,NULL);
            RefreshGList(cxGadgets,cxWindow,NULL,-1);
            GT_RefreshWindow(cxWindow,NULL);
            return(TRUE);
        }
        FreeGadgets(cxGadgets);
        cxGadgets = NULL;
    }
    return(FALSE);
}


/*****************************************************************************/


struct NewMenu NM[] =
{
    {NM_TITLE,  NULL,        0, 0, 0, (APTR)CMD_NOP,  },
      {NM_ITEM, NULL,        0, 0, 0, (APTR)CMD_SAVE, },
      {NM_ITEM, NM_BARLABEL, 0, 0, 0, (APTR)CMD_NOP,  },
      {NM_ITEM, NULL,        0, 0, 0, (APTR)CMD_HIDE, },
      {NM_ITEM, NULL,        0, 0, 0, (APTR)CMD_QUIT, },

    {NM_END,    0,           0, 0, 0, (APTR)CMD_NOP,  }
};


/*****************************************************************************/


VOID DoItem(WORD itemNum, AppStringsID label)
{
    if (NM[itemNum].nm_Type != NM_TITLE)
    {
        NM[itemNum].nm_Label   = (APTR)((ULONG)GetString(label)+2);
        NM[itemNum].nm_CommKey = GetString(label);
    }
    else
    {
        NM[itemNum].nm_Label = GetString(label);
    }
}


/*****************************************************************************/


BOOL CreateCustomMenus(VOID)
{
    DoItem(0,MSG_PROJECT_MENU);
    DoItem(1,MSG_FK_SAVE);
    DoItem(3,MSG_PROJECT_HIDE);
    DoItem(4,MSG_PROJECT_QUIT);

    if (cxMenus = CreateMenusA(NM,NULL))
    {
        if (LayoutMenus(cxMenus,cxVisualInfo,GTMN_NewLookMenus,TRUE,
                                             TAG_DONE))
        {
            SetMenuStrip(cxWindow,cxMenus);
            return(TRUE);
        }
        FreeMenus(cxMenus);
        cxMenus = NULL;
    }
    return(FALSE);
}


/*****************************************************************************/


VOID UpdateFilters(VOID)
{
struct KeySequence *key;
CxObj              *localFilter;

    DeleteCxObjAll(mainFilter);
    if (mainFilter = CxFilter(NULL))
    {
        key = (struct KeySequence *)keyList.lh_Head;
        while (key->fk_Node.ln_Succ)
        {
            if (localFilter = CxFilter(key->fk_Node.ln_Name))
            {
                if (key->fk_Cmd == CMD_INSERT)
                {
                    AttachCxObj(localFilter,CxTranslate(key->fk_KeyEvents));
                }
                else
                {
                    AttachCxObj(localFilter,CxSender(cxPort,(ULONG)key));
                    AttachCxObj(localFilter,CxTranslate(NULL));
                }
            }

            AttachCxObj(mainFilter,localFilter);
            key = (struct KeySequence *)key->fk_Node.ln_Succ;
        }

        AttachCxObj(cxBroker,mainFilter);
    }
}


/*
VOID PrintKeyList(STRPTR hdr)
{
struct KeySequence *key;

        kprintf("\n%s\n",hdr);
        key = (struct KeySequence *)keyList.lh_Head;
        while (key->fk_Node.ln_Succ)
        {
            kprintf("Sequence = %s, cmd = %ld, args = '%s', events = %lx\n",key->fk_Node.ln_Name,key->fk_Cmd,key->fk_Args,key->fk_KeyEvents);
            key = (struct KeySequence *)key->fk_Node.ln_Succ;
        }

}
*/


/*****************************************************************************/


VOID RefreshWindow(BOOL refreshEvent)
{
    if (refreshEvent)
    {
        GT_BeginRefresh(cxWindow);
        GT_EndRefresh(cxWindow,TRUE);
    }
}


/*****************************************************************************/


BOOL ProcessCommand(UWORD cmd)
{
struct KeySequence *key;
BOOL                refreshGads;
BOOL                updateFilters;
struct Gadget      *activate;
IX                  ix;
struct EasyStruct   ez;

    activate       = NULL;
    refreshGads    = FALSE;
    updateFilters  = FALSE;

    if (cxWindow)
    {
        GT_SetGadgetAttrs(keysGad,cxWindow,NULL,GTLV_Labels, ~0,
                                                TAG_DONE);

        if (((struct StringInfo *)seqGad->SpecialInfo)->Buffer[0])
        {
            currentKey = UpdateSequence(currentKey,((struct StringInfo *)seqGad->SpecialInfo)->Buffer,
                                                   ((struct StringInfo *)argGad->SpecialInfo)->Buffer);
        }
        else
        {
            if (currentKey)
            {
                Remove(currentKey);
                FreeSequence(currentKey);
                currentKey    = NULL;
                refreshGads   = TRUE;
                updateFilters = TRUE;
            }
        }
    }

    switch (cmd)
    {
        case CMD_SAVE       : UpdateFilters();
                              SaveFKeyIcon();
        		      break;

        case CMD_HIDE       : DisposeWindow();
                              UpdateFilters();
                              return(TRUE);
                              break;

        case CMD_QUIT       : return(FALSE);

        case CMD_KEYLIST    : currentKey  = (struct KeySequence *)FindNum(&keyList,icode);
                              refreshGads = TRUE;
                              activate    = seqGad;
                              break;

        case CMD_ADD        : if (key = GetSequence("",cmdGad->GadgetID,""))
                              {
                                  AddTail(&keyList,key);
                                  currentKey    = key;
                                  refreshGads   = TRUE;
                                  activate      = seqGad;
                                  updateFilters = TRUE;
                              }
                              break;

        case CMD_REMOVE     : if (currentKey)
                              {
                                  Remove(currentKey);
                                  FreeSequence(currentKey);
                                  currentKey    = NULL;
                                  refreshGads   = TRUE;
                                  updateFilters = TRUE;
                              }
                              break;

        case CMD_SEQUENCE   : if (currentKey)
                              {
                                  if (ParseIX(((struct StringInfo *)seqGad->SpecialInfo)->Buffer,&ix) != 0)
                                  {
                                      ez.es_StructSize   = sizeof(struct EasyStruct);
                                      ez.es_Flags        = 0;
                                      ez.es_Title        = GetString(MSG_FK_BADKEY_TITLE);
                                      ez.es_TextFormat   = GetString(MSG_FK_BADKEY_PROMPT);
                                      ez.es_GadgetFormat = GetString(MSG_FK_BADKEY_GAD);
                                      EasyRequestArgs(cxWindow,&ez,0,NULL);

                                      activate = seqGad;
                                  }
                                  else if (!(argGad->Flags & GFLG_DISABLED))
                                  {
                                      activate = argGad;
                                  }
                                  updateFilters = TRUE;
                              }
                              break;

        case CMD_COMMAND    : if (currentKey)
                              {
                                  GT_SetGadgetAttrs(argGad,cxWindow,NULL,GA_Disabled, icode < CMD_INSERT,
                                                                         TAG_DONE);
                                  cmdGad->GadgetID   = icode;
                                  currentKey->fk_Cmd = icode;
                                  updateFilters      = TRUE;

                                  currentKey = UpdateSequence(currentKey,((struct StringInfo *)seqGad->SpecialInfo)->Buffer,
                                                                         ((struct StringInfo *)argGad->SpecialInfo)->Buffer);
                              }
                              break;

        case CMD_ARGS       : if (currentKey)
                              {
                                  activate      = seqGad;
                                  updateFilters = TRUE;
                              }
                              break;
    }

    if (updateFilters)
        UpdateFilters();

    if (refreshGads)
    {
        if (currentKey)
        {
            GT_SetGadgetAttrs(removeGad,cxWindow,NULL,GA_Disabled, FALSE,
                                                      TAG_DONE);

            GT_SetGadgetAttrs(seqGad,cxWindow,NULL,GA_Disabled, FALSE,
                                                   GTST_String, currentKey->fk_Node.ln_Name,
                                                   TAG_DONE);

            GT_SetGadgetAttrs(cmdGad,cxWindow,NULL,GA_Disabled, FALSE,
                                                   GTCY_Active, currentKey->fk_Cmd,
                                                   TAG_DONE);

            GT_SetGadgetAttrs(argGad,cxWindow,NULL,GA_Disabled, currentKey->fk_Cmd < CMD_INSERT,
                                                   GTST_String, currentKey->fk_Args,
                                                   TAG_DONE);
        }
        else
        {
            GT_SetGadgetAttrs(removeGad,cxWindow,NULL,GA_Disabled,TRUE,
                                                      TAG_DONE);

            GT_SetGadgetAttrs(seqGad,cxWindow,NULL,GA_Disabled, TRUE,
                                                   GTST_String, "",
                                                   TAG_DONE);

            GT_SetGadgetAttrs(cmdGad,cxWindow,NULL,GA_Disabled,TRUE,
                                                   TAG_DONE);

            GT_SetGadgetAttrs(argGad,cxWindow,NULL,GA_Disabled, TRUE,
                                                   GTST_String, "",
                                                   TAG_DONE);
        }
    }

    if (activate)
        ActivateGadget(activate,cxWindow,NULL);

    if (cxWindow)
    {
        if (currentKey)
        {
            GT_SetGadgetAttrs(keysGad,cxWindow,NULL,GTLV_Labels,   &keyList,
                                                    GTLV_Selected, FindNodeNum((struct List *)&keyList,(struct Node *)currentKey),
                                                    TAG_DONE);
        }
        else
        {
            GT_SetGadgetAttrs(keysGad,cxWindow,NULL,GTLV_Labels, &keyList,
                                                    TAG_DONE);
        }
    }

    return(TRUE);
}


/*****************************************************************************/


BOOL CreateCustomCx(CxObj *broker)
{
    mainFilter = NULL;
    UpdateFilters();

    return(TRUE);
}


/*****************************************************************************/


VOID DisposeCustomCx(VOID)
{
struct KeySequence *key;

    while (key = (struct KeySequence *)RemHead(&keyList))
        FreeSequence(key);
}
@


38.20
log
@When there was a key sequence in FKey that has as command "Insert Text"
and had a string associated with it, switching the command to
something else, and coming back to "Insert Text" would cause the current
string to be "forgotten". To get it back, you had to click in the
text gadget and press RETURN. This is now fixed. (B18673)

Selecting a command such as "Insert Text", then typing in a string as
argument would cause that string to be bound to the key sequence forever.
That is, even if the command was switched to something like "Cycle Windows
the string argument would be saved out to disk and reloaded in memory
the next time the program ran. This was incorrect as the command didn't
have anything to do with the string. String arguments are now discarded fo
those commands that don't support them.

The active key sequence is now correctly highlighted in the list view.
                                                                          
@
text
@d1067 1
d1081 1
a1083 1

a1107 2

PrintKeyList("1 - ");
@


38.19
log
@Fixed incorrect handling of CMD_HIDE function, would access illegal memory
@
text
@d288 1
a288 1
                                    if (tmp = AllocVec(8,MEMF_CLEAR|MEMF_PUBLIC))
d346 1
a346 2
            && (layerWindow)
            && (!(layerWindow->Flags & WFLG_WBENCHWINDOW)))
d505 6
a510 2
    len = sizeof(struct KeySequence) + strlen(sequence) + strlen(args) + 2;
    if (key = AllocVec(len,MEMF_CLEAR|MEMF_PUBLIC))
d516 4
a519 1
        strcpy(key->fk_Args,args);
d521 3
a523 2
        if (cmd == CMD_INSERT)
            key->fk_KeyEvents = InvertString(args,NULL);
d617 6
a622 2
                    strcat(new[i]," ");
                    strcat(new[i],key->fk_Args);
d703 3
d715 5
a719 1
                    if (cmd[j] == ' ')
a720 2
                        cmd[j] = 0;

d895 13
d915 3
a917 15
        seqGad = CreateGadget(STRING_KIND,gad,&ng,GA_Disabled,   TRUE,
                                                  GTST_MaxChars, 39,
						  TAG_DONE);

        ng.ng_TopEdge    = cxWindow->BorderTop+16;
        ng.ng_LeftEdge   = cxWindow->BorderLeft+8;
        ng.ng_Width      = 260;
        ng.ng_Height     = 62;
        ng.ng_GadgetText = GetString(MSG_FK_DEFKEYS_GAD);
        ng.ng_UserData   = (APTR)CMD_KEYLIST;

        keysGad = CreateGadget(LISTVIEW_KIND,seqGad,&ng,GTLV_Labels,       &keyList,
                                                        LAYOUTA_SPACING,   1,
                                                        GTLV_ScrollWidth,  18,
                                                        TAG_DONE);
d926 1
a926 1
        addGad = CreateGadget(BUTTON_KIND,keysGad,&ng,TAG_DONE);
d1067 16
d1108 1
a1108 3
    activate      = NULL;
    refreshGads   = FALSE;
    updateFilters = FALSE;
d1110 4
d1203 3
@


38.18
log
@*** empty log message ***
@
text
@a380 2
    Forbid();    /* Not very useful, but we are trying at least... :-) */

a384 2

    Permit();
a776 2
                case CMD_INSERT   : break;

a1029 2
                AttachCxObj(localFilter,CxSender(cxPort,(ULONG)key));

d1036 1
d1110 1
@


38.17
log
@*** empty log message ***
@
text
@d738 1
a738 1
    if (allocated)
@


38.16
log
@Now looks at the icon to find the currently defined keys even when started from the shell
@
text
@a573 1

d670 1
d674 6
a679 2
    if (!diskObj)
        diskObj = GetDiskObject("PROGDIR:FKey");
d681 1
a681 3
    fkeyDiskObj = diskObj;

    if (diskObj && (ptr = diskObj->do_ToolTypes))
d736 6
@


38.15
log
@Fixed freeing of memory after saving an icon
@
text
@d577 2
a578 5
        if (IconBase || (IconBase = OpenLibrary("icon.library",37)))
        {
            fkeyDiskObj = GetDiskObject("PROGDIR:FKey");
            allocated = TRUE;
        }
d673 3
@


38.14
log
@Wasn't preserving existing tool types correctly when saving a new icon
@
text
@d642 2
d646 1
a646 2
                i++;
                FreeVec(new[i]);
@


38.13
log
@Fixed Enforcer hits when cliking on New Key a lot without entering a key sequence
@
text
@d632 1
a632 1
                        new[i] = ttypes[cnt];
@


38.12
log
@Frees all memory when failing due to lack of memory
Removed useless calls to create objects on init
@
text
@d211 1
a211 1
    while (number--)
d214 4
a217 1
    return (node);
@


38.11
log
@Fixed access of IntuiMessage->Code field after having replied the message
@
text
@d1017 8
a1024 1
    mainFilter = CxFilter(NULL);
d1026 9
a1034 5
    key = (struct KeySequence *)keyList.lh_Head;
    while (key->fk_Node.ln_Succ)
    {
        localFilter = CxFilter(key->fk_Node.ln_Name);
        AttachCxObj(localFilter,CxSender(cxPort,(ULONG)key));
d1036 2
a1037 7
        if (key->fk_Cmd == CMD_INSERT)
        {
            AttachCxObj(localFilter,CxTranslate(key->fk_KeyEvents));
        }
        else
        {
            AttachCxObj(localFilter,CxTranslate(NULL));
d1040 1
a1040 2
        AttachCxObj(mainFilter,localFilter);
        key = (struct KeySequence *)key->fk_Node.ln_Succ;
a1041 2

    AttachCxObj(cxBroker,mainFilter);
d1240 1
a1240 2
    mainFilter = CxFilter(NULL);
    AttachCxObj(broker,mainFilter);
@


38.10
log
@Now updates the filters before closing the window or saving the FKey
@
text
@d823 1
a823 1
        case IDCMP_MENUPICK     : menuNum = intuiMsg->Code;
@


38.9
log
@Fixed excessive opening of icon.library
@
text
@a1 1

d49 2
d252 1
d275 4
a709 4
/*
                                    AddTail(&keyList,key);
*/

d1023 1
a1023 1
        AttachCxObj(localFilter,CxSender(cxPort,(LONG)key));
d1075 1
d1096 2
a1097 1
        case CMD_SAVE       : SaveFKeyIcon();
d1101 1
@


38.8
log
@Move gadgets a bit
@
text
@d568 1
a568 1
        if (IconBase = OpenLibrary("icon.library",37))
@


38.7
log
@Now preserves unknown tooltypes
Now sorts keyboard list upon startup
No longer allows blank keyboard sequences
@
text
@d868 1
a868 1
        ng.ng_Flags      = NULL;
d894 1
a894 1
        ng.ng_TopEdge    = cxWindow->BorderTop+91;
d896 1
a896 1
        ng.ng_Width      = 128;
d903 3
a905 3
        ng.ng_TopEdge    = cxWindow->BorderTop+91;
        ng.ng_LeftEdge   = cxWindow->BorderLeft+140;
        ng.ng_Width      = 128;
d914 2
a915 2
        ng.ng_LeftEdge   = cxWindow->BorderLeft+324;
        ng.ng_Width      = 224;
d927 1
a927 1
        ng.ng_Width      = 320;
@


38.6
log
@*** empty log message ***
@
text
@d556 1
a556 1
APTR                ttypes;
d561 1
d585 11
d616 13
a628 1
            ttypes = fkeyDiskObj->do_ToolTypes;
d663 1
d703 2
d706 11
d1065 4
d1073 16
a1088 2
        currentKey = UpdateSequence(currentKey,((struct StringInfo *)seqGad->SpecialInfo)->Buffer,
                                               ((struct StringInfo *)argGad->SpecialInfo)->Buffer);
a1089 4

    activate      = NULL;
    refreshGads   = FALSE;
    updateFilters = FALSE;
@


38.5
log
@New StartScript() now uses the smart way of running scripts
@
text
@d461 1
a461 1
    if (RexxSysBase = OpenLibrary("rexxsyslib.library",36))
d463 1
a463 1
        if (arg = CreateArgstring(scriptName,strlen(scriptName)))
d465 1
a465 1
            if (msg = CreateRexxMsg(&process->pr_MsgPort,NULL,NULL))
d467 15
a481 4
                msg->rm_Action  = RXCOMM;
                msg->rm_Args[0] = arg;
                msg->rm_Stdin   = NULL;
                msg->rm_Stdout  = NULL;
d483 1
a483 6
                Forbid();
                if (rexx = FindPort("AREXX"))
                {
                    PutMsg(rexx,msg);
                    WaitPort(&process->pr_MsgPort);
                    GetMsg(&process->pr_MsgPort);
d485 1
a485 3
                Permit();

                DeleteRexxMsg(msg);
d487 1
a487 1
            DeleteArgstring(arg);
a488 1
        CloseLibrary(RexxSysBase);
@


38.4
log
@Enabled new look menus
@
text
@d17 1
d29 1
d40 1
d97 1
d454 4
a457 1
char name[265];
d459 28
a486 3
    strcpy(name,"RX ");
    strcat(name,scriptName);
    StartProgram(name);
d950 1
a950 2
    if (cxMenus = CreateMenus(NM,GTMN_NewLookMenus,TRUE,
                                 TAG_DONE))
d952 2
a953 1
        if (LayoutMenus(cxMenus,cxVisualInfo,TAG_DONE))
@


38.3
log
@Fixed bug with crashing when closing window
@
text
@d918 1
a918 1
    if (cxMenus = CreateMenus(NM,/* GTMN_NewLookMenus,TRUE, */
@


38.2
log
@Fixed "Run ARexx Script" function
@
text
@d992 7
a998 2
    GT_SetGadgetAttrs(keysGad,cxWindow,NULL,GTLV_Labels, ~0,
                                            TAG_DONE);
a1002 2
    currentKey    = UpdateSequence(currentKey,((struct StringInfo *)seqGad->SpecialInfo)->Buffer,
                                              ((struct StringInfo *)argGad->SpecialInfo)->Buffer);
d1121 1
a1121 1
    if (currentKey)
d1123 11
a1133 8
        GT_SetGadgetAttrs(keysGad,cxWindow,NULL,GTLV_Labels,   &keyList,
                                                GTLV_Selected, FindNodeNum((struct List *)&keyList,(struct Node *)currentKey),
                                                TAG_DONE);
    }
    else
    {
        GT_SetGadgetAttrs(keysGad,cxWindow,NULL,GTLV_Labels, &keyList,
                                                TAG_DONE);
@


38.1
log
@Initial V38 RCS checkin
@
text
@d450 1
a450 1
BPTR file;
a451 15
    if (file = Open(CONSOLE_SPEC,MODE_NEWFILE))
    {
        if (SystemTags("RX",SYS_UserShell, TRUE,
                            SYS_Asynch,    TRUE,
                            SYS_Input,     file,
                            SYS_Output,    NULL,
                            NP_Arguments,  scriptName,
                            TAG_DONE))
        {
            Close(file);
        }
    }
/*
char name[300];

a454 1
*/
@
