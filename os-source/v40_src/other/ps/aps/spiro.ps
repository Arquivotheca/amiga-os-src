%!PS-Adobe-1.0

%   This program generates a Spirograph(tm) image centered on the page
%   according to the three parameters bigR, littleR, and a.  Images are
%   generated by calculating successive positions of the cycloid generated
%   by rolling a small disk inside a larger ring, with a "pen" placed some
%   distance from the center of the disk.
%
%   bigR is the radius of the "outer" circle (the ring, in Spirograph(tm))
%   littleR is the radius of the "inner" circle (the disk)
%   a is the distance of the "pen" from the center of the inner circle.
%
%   Since the program calculates the total angle through which to
%   parameterize (i.e. how long it has to roll the disk around in the
%   ring) by looking for a greatest common divisor, the values of the
%   parameters bigR, littleR, and a MUST be integers.
%
%   If you're interested, the parametric equations which describe a
%   Spirograph(tm) image are given by:
%
%         x = (R - r) * cos(theta) + a * cos(phi)
%         y = (R - r) * sin(theta) + a * sin(phi),
%
%   where phi = ((R - r) / r) * theta.
%
%   This program was written by Christopher Tate, and is hereby placed
%   into the public domain.  Anyone may freely borrow from or modify
%   this program without permission.  Have fun!

/bigR 295 def         % just change these to define a new image
/littleR 150 def       % littleR should be less than bigR
/a 45 def            % a need not be smaller than littleR

% Euclid's Greatest Common Divisor algorithm to find gcd(m, n)
% Calling process:  m n *gcd* result

/gcd
{
   3 dict begin      % isolate these variables from the rest of the program
   /m exch def /n exch def
   /r m n mod def
   {
      r 0 eq {exit} if      % quit when r equals zero
      /m n def
      /n r def
      /r m n mod def
   } loop
   n                        % put result on the stack
   end                      % restore the original dictionary context
} bind def

0 0 639 399  %clippath pathbbox      % find the bounding box of the page

/ury exch def          % remember Upper Right y
/urx exch def          % remember URx
/lly exch def          % remember LLy
/llx exch def          % remember LLx

urx llx sub 2 div llx add
ury lly sub 2 div lly add
translate              % move the origin to the center of the page

/diff bigR littleR sub def              % diff = R - r
/frac 1.0 bigR littleR div sub def      % frac = 1.0 - (R/r)

0 setlinewidth           % sufficiently thin lines
newpath
diff a add 0 moveto        % set initial position

/limit 360 littleR mul bigR littleR gcd div def    % how far we need to go

0 10 limit                  % this is the main loop
{
   dup frac mul /phi exch def       % calculate phi
   /theta exch def                  % recalculate theta
   theta cos diff mul phi cos a mul add   % this is x
   theta sin diff mul phi sin a mul add   % this is y
   2 copy lineto stroke moveto      % same as x y lineto stroke x y moveto
} bind for

showpage
