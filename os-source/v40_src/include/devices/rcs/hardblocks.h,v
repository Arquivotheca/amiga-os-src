head     36.2;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


36.2
date     90.11.06.23.52.55;  author bryce;  state Exp;
branches ;
next     36.1;

36.1
date     90.07.11.14.46.40;  author bryce;  state Exp;
branches ;
next     36.0;

36.0
date     89.06.05.15.14.00;  author kodiak;  state Exp;
branches ;
next     1.2;

1.2
date     89.03.09.11.50.43;  author kodiak;  state Exp;
branches ;
next     1.1;

1.1
date     88.07.12.13.55.24;  author kodiak;  state Exp;
branches ;
next     1.0;

1.0
date     88.07.11.15.32.49;  author kodiak;  state Exp;
branches ;
next     0.9;

0.9
date     88.06.20.12.57.48;  author kodiak;  state Exp;
branches ;
next     0.8;

0.8
date     88.06.17.18.38.42;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


36.2
log
@Include types.h
@
text
@#ifndef	DEVICES_HARDBLOCKS_H
#define	DEVICES_HARDBLOCKS_H
/*
**	$Id: hardblocks.h,v 36.1 90/07/11 14:46:40 bryce Exp Locker: bryce $
**
**	File System identifier blocks for hard disks
**
**	(C) Copyright 1988,1989 Commodore-Amiga, Inc.
**	    All Rights Reserved
*/

#ifndef EXEC_TYPES_H
#include "exec/types.h"
#endif /* EXEC_TYPES_H */


/*--------------------------------------------------------------------
 *
 *	This file describes blocks of data that exist on a hard disk
 *	to describe that disk.  They are not generically accessable to
 *	the user as they do not appear on any DOS drive.  The blocks
 *	are tagged with a unique identifier, checksummed, and linked
 *	together.  The root of these blocks is the RigidDiskBlock.
 *
 *	The RigidDiskBlock must exist on the disk within the first
 *	RDB_LOCATION_LIMIT blocks.  This inhibits the use of the zero
 *	cylinder in an AmigaDOS partition: although it is strictly
 *	possible to store the RigidDiskBlock data in the reserved
 *	area of a partition, this practice is discouraged since the
 *	reserved blocks of a partition are overwritten by "Format",
 *	"Install", "DiskCopy", etc.  The recommended disk layout,
 *	then, is to use the first cylinder(s) to store all the drive
 *	data specified by these blocks: i.e. partition descriptions,
 *	file system load images, drive bad block maps, spare blocks,
 *	etc.
 *
 *	Though only 512 byte blocks are currently supported by the
 *	file system, this proposal tries to be forward-looking by
 *	making the block size explicit, and by using only the first
 *	256 bytes for all blocks but the LoadSeg data.
 *
 *------------------------------------------------------------------*/

/*
 *  NOTE
 *	optional block addresses below contain $ffffffff to indicate
 *	a NULL address, as zero is a valid address
 */
struct RigidDiskBlock {
    ULONG   rdb_ID;		/* 4 character identifier */
    ULONG   rdb_SummedLongs;	/* size of this checksummed structure */
    LONG    rdb_ChkSum;		/* block checksum (longword sum to zero) */
    ULONG   rdb_HostID;		/* SCSI Target ID of host */
    ULONG   rdb_BlockBytes;	/* size of disk blocks */
    ULONG   rdb_Flags;		/* see below for defines */
    /* block list heads */
    ULONG   rdb_BadBlockList;	/* optional bad block list */
    ULONG   rdb_PartitionList;	/* optional first partition block */
    ULONG   rdb_FileSysHeaderList; /* optional file system header block */
    ULONG   rdb_DriveInit;	/* optional drive-specific init code */
				/* DriveInit(lun,rdb,ior): "C" stk & d0/a0/a1 */
    ULONG   rdb_Reserved1[6];	/* set to $ffffffff */
    /* physical drive characteristics */
    ULONG   rdb_Cylinders;	/* number of drive cylinders */
    ULONG   rdb_Sectors;	/* sectors per track */
    ULONG   rdb_Heads;		/* number of drive heads */
    ULONG   rdb_Interleave;	/* interleave */
    ULONG   rdb_Park;		/* landing zone cylinder */
    ULONG   rdb_Reserved2[3];
    ULONG   rdb_WritePreComp;	/* starting cylinder: write precompensation */
    ULONG   rdb_ReducedWrite;	/* starting cylinder: reduced write current */
    ULONG   rdb_StepRate;	/* drive step rate */
    ULONG   rdb_Reserved3[5];
    /* logical drive characteristics */
    ULONG   rdb_RDBBlocksLo;	/* low block of range reserved for hardblocks */
    ULONG   rdb_RDBBlocksHi;	/* high block of range for these hardblocks */
    ULONG   rdb_LoCylinder;	/* low cylinder of partitionable disk area */
    ULONG   rdb_HiCylinder;	/* high cylinder of partitionable data area */
    ULONG   rdb_CylBlocks;	/* number of blocks available per cylinder */
    ULONG   rdb_AutoParkSeconds; /* zero for no auto park */
    ULONG   rdb_Reserved4[2];
    /* drive identification */
    char    rdb_DiskVendor[8];
    char    rdb_DiskProduct[16];
    char    rdb_DiskRevision[4];
    char    rdb_ControllerVendor[8];
    char    rdb_ControllerProduct[16];
    char    rdb_ControllerRevision[4];
    ULONG   rdb_Reserved5[10];
};

#define	IDNAME_RIGIDDISK	0x5244534B	/* 'RDSK' */

#define	RDB_LOCATION_LIMIT	16

#define	RDBFB_LAST	0	/* no disks exist to be configured after */
#define	RDBFF_LAST	0x01L	/*   this one on this controller */
#define	RDBFB_LASTLUN	1	/* no LUNs exist to be configured greater */
#define	RDBFF_LASTLUN	0x02L	/*   than this one at this SCSI Target ID */
#define	RDBFB_LASTTID	2	/* no Target IDs exist to be configured */
#define	RDBFF_LASTTID	0x04L	/*   greater than this one on this SCSI bus */
#define	RDBFB_NORESELECT 3	/* don't bother trying to perform reselection */
#define	RDBFF_NORESELECT 0x08L	/*   when talking to this drive */
#define	RDBFB_DISKID	4	/* rdb_Disk... identification valid */
#define	RDBFF_DISKID	0x10L
#define	RDBFB_CTRLRID	5	/* rdb_Controller... identification valid */
#define	RDBFF_CTRLRID	0x20L

/*------------------------------------------------------------------*/
struct BadBlockEntry {
    ULONG   bbe_BadBlock;	/* block number of bad block */
    ULONG   bbe_GoodBlock;	/* block number of replacement block */
};

struct BadBlockBlock {
    ULONG   bbb_ID;		/* 4 character identifier */
    ULONG   bbb_SummedLongs;	/* size of this checksummed structure */
    LONG    bbb_ChkSum;		/* block checksum (longword sum to zero) */
    ULONG   bbb_HostID;		/* SCSI Target ID of host */
    ULONG   bbb_Next;		/* block number of the next BadBlockBlock */
    ULONG   bbb_Reserved;
    struct BadBlockEntry bbb_BlockPairs[61]; /* bad block entry pairs */
    /* note [61] assumes 512 byte blocks */
};

#define	IDNAME_BADBLOCK		0x42414442	/* 'BADB' */

/*------------------------------------------------------------------*/
struct PartitionBlock {
    ULONG   pb_ID;		/* 4 character identifier */
    ULONG   pb_SummedLongs;	/* size of this checksummed structure */
    LONG    pb_ChkSum;		/* block checksum (longword sum to zero) */
    ULONG   pb_HostID;		/* SCSI Target ID of host */
    ULONG   pb_Next;		/* block number of the next PartitionBlock */
    ULONG   pb_Flags;		/* see below for defines */
    ULONG   pb_Reserved1[2];
    ULONG   pb_DevFlags;	/* preferred flags for OpenDevice */
    UBYTE   pb_DriveName[32];	/* preferred DOS device name: BSTR form */
				/* (not used if this name is in use) */
    ULONG   pb_Reserved2[15];	/* filler to 32 longwords */
    ULONG   pb_Environment[17];	/* environment vector for this partition */
    ULONG   pb_EReserved[15];	/* reserved for future environment vector */
};

#define	IDNAME_PARTITION	0x50415254	/* 'PART' */

#define	PBFB_BOOTABLE	0	/* this partition is intended to be bootable */
#define	PBFF_BOOTABLE	1L	/*   (expected directories and files exist) */
#define	PBFB_NOMOUNT	1	/* do not mount this partition (e.g. manually */
#define	PBFF_NOMOUNT	2L	/*   mounted, but space reserved here) */

/*------------------------------------------------------------------*/
struct FileSysHeaderBlock {
    ULONG   fhb_ID;		/* 4 character identifier */
    ULONG   fhb_SummedLongs;	/* size of this checksummed structure */
    LONG    fhb_ChkSum;		/* block checksum (longword sum to zero) */
    ULONG   fhb_HostID;		/* SCSI Target ID of host */
    ULONG   fhb_Next;		/* block number of next FileSysHeaderBlock */
    ULONG   fhb_Flags;		/* see below for defines */
    ULONG   fhb_Reserved1[2];
    ULONG   fhb_DosType;	/* file system description: match this with */
				/* partition environment's DE_DOSTYPE entry */
    ULONG   fhb_Version;	/* release version of this code */
    ULONG   fhb_PatchFlags;	/* bits set for those of the following that */
				/*   need to be substituted into a standard */
				/*   device node for this file system: e.g. */
				/*   0x180 to substitute SegList & GlobalVec */
    ULONG   fhb_Type;		/* device node type: zero */
    ULONG   fhb_Task;		/* standard dos "task" field: zero */
    ULONG   fhb_Lock;		/* not used for devices: zero */
    ULONG   fhb_Handler;	/* filename to loadseg: zero placeholder */
    ULONG   fhb_StackSize;	/* stacksize to use when starting task */
    LONG    fhb_Priority;	/* task priority when starting task */
    LONG    fhb_Startup;	/* startup msg: zero placeholder */
    LONG    fhb_SegListBlocks;	/* first of linked list of LoadSegBlocks: */
				/*   note that this entry requires some */
				/*   processing before substitution */
    LONG    fhb_GlobalVec;	/* BCPL global vector when starting task */
    ULONG   fhb_Reserved2[23];	/* (those reserved by PatchFlags) */
    ULONG   fhb_Reserved3[21];
};

#define	IDNAME_FILESYSHEADER	0x46534844	/* 'FSHD' */

/*------------------------------------------------------------------*/
struct LoadSegBlock {
    ULONG   lsb_ID;		/* 4 character identifier */
    ULONG   lsb_SummedLongs;	/* size of this checksummed structure */
    LONG    lsb_ChkSum;		/* block checksum (longword sum to zero) */
    ULONG   lsb_HostID;		/* SCSI Target ID of host */
    ULONG   lsb_Next;		/* block number of the next LoadSegBlock */
    ULONG   lsb_LoadData[123];	/* data for "loadseg" */
    /* note [123] assumes 512 byte blocks */
};

#define	IDNAME_LOADSEG		0x4C534547	/* 'LSEG' */

#endif	/* DEVICES_HARDBLOCKS_H */
@


36.1
log
@Change $Header to $Id so makemeta won't gripe.  Grumble!
@
text
@d4 1
a4 1
**	$Id: /usr/machines/ghostwheel/commodore/amiga/V36/src/include/devices/RCS/hardblocks.h,v 36.0 89/06/05 15:14:00 kodiak Exp Locker: bryce $
d11 5
@


36.0
log
@make standard include format
@
text
@d4 1
a4 1
**	$Header$
@


1.2
log
@convert IDNAMEs from shifted char expressions to hex numbers
@
text
@d4 1
a4 3
**	$Filename: devices/hardblocks.h $
**	$Revision: 1.1 $
**	$Date: 88/07/12 13:55:24 $
d8 1
a8 1
**	(C) Copyright 1988 Commodore-Amiga, Inc.
@


1.1
log
@final for 1.3 includes
@
text
@d5 2
a6 2
**	$Revision: 1.0 $
**	$Date: 88/07/11 15:32:49 $
d89 1
a89 1
#define	IDNAME_RIGIDDISK	(('R'<<24)|('D'<<16)|('S'<<8)|('K'))
d123 1
a123 1
#define	IDNAME_BADBLOCK		(('B'<<24)|('A'<<16)|('D'<<8)|('B'))
d142 1
a142 1
#define	IDNAME_PARTITION	(('P'<<24)|('A'<<16)|('R'<<8)|('T'))
d180 1
a180 1
#define	IDNAME_FILESYSHEADER	(('F'<<24)|('S'<<16)|('H'<<8)|('D'))
d193 1
a193 1
#define	IDNAME_LOADSEG		(('L'<<24)|('S'<<16)|('E'<<8)|('G'))
@


1.0
log
@For 1.3 release
@
text
@d5 2
a6 2
**	$Revision: 0.9 $
**	$Date: 88/06/20 12:57:48 $
d77 1
a77 1
    ULONG   rdb_AutoParkSeconds	/* zero for no auto park */
@


0.9
log
@move rdb_Park
move Version in file system header
@
text
@d5 2
a6 3
**	$Release: 1.4 $
**	$Revision: 0.8 $
**	$Date: 88/06/17 18:38:42 $
d10 2
a11 1
**	(C) Copyright 1988 Kodiak Software
d58 1
d63 2
a64 2
    UWORD   rdb_Heads;		/* number of drive heads */
    UWORD   rdb_Interleave;	/* interleave */
d66 1
a66 1
    ULONG   rdb_Reserved2[4];
d72 2
a73 1
    ULONG   rdb_ReservedBlocks;	/* i.e. the first partitionable block */
d77 2
a78 1
    ULONG   rdb_Reserved4[4];
d91 1
a91 1
#define	RDB_LOCATION_LIMIT	10
d99 2
d107 19
d145 3
a147 1
#define	PBFF_BOOTABLE	1L	/* (expected directories and files exist) */
d194 2
@


0.8
log
@*** empty log message ***
@
text
@d6 2
a7 2
**	$Revision$
**	$Date$
d64 2
a65 1
    ULONG   rdb_Reserved2[5];
d69 1
a69 2
    ULONG   rdb_Park;		/* landing zone cylinder */
    ULONG   rdb_Reserved3[4];
d131 1
a131 2
    ULONG   fhb_Version;	/* release version of this code */
    ULONG   fhb_Reserved1;
d134 1
d151 1
a151 1
    ULONG   fhb_Reserved3[22];
@
