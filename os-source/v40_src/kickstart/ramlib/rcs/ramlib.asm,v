head     36.29;
branch   ;
access   ;
symbols  V40_2:36.29 V40_1:36.27 V39_5:36.26 V39_4:36.26 V39_3:36.25 V39_2:36.24 V37_13:36.23 V37_11:36.23 V37_10:36.22 V37_2:36.21 V36_133:36.21 V36_129:36.20 V36_121:36.19 V36_119:36.18 V36_118:36.17 V36_116:36.16 V36_115:36.15 V36_114:36.14 V36_111:36.13 V36_90:36.12 V36_89:36.12 V36_84:36.10 V36_82:36.9 V36_80:36.8 V36_66:36.7 V36_50:36.6 V36_41:36.4 V36_40:36.3 V36_39:36.2 V36_38:36.0;
locks    ; strict;
comment  @*   @;


36.29
date     93.03.05.10.01.38;  author mks;  state Exp;
branches ;
next     36.28;

36.28
date     93.03.05.09.43.43;  author mks;  state Exp;
branches ;
next     36.27;

36.27
date     93.02.15.16.20.59;  author mks;  state Exp;
branches ;
next     36.26;

36.26
date     92.05.11.15.08.44;  author mks;  state Exp;
branches ;
next     36.25;

36.25
date     92.04.20.09.47.47;  author mks;  state Exp;
branches ;
next     36.24;

36.24
date     92.02.03.09.03.51;  author mks;  state Exp;
branches ;
next     36.23;

36.23
date     91.02.08.22.07.27;  author darren;  state Exp;
branches ;
next     36.22;

36.22
date     91.02.07.12.49.03;  author darren;  state Exp;
branches ;
next     36.21;

36.21
date     90.11.16.17.19.42;  author darren;  state Exp;
branches ;
next     36.20;

36.20
date     90.06.14.16.35.04;  author kodiak;  state Exp;
branches ;
next     36.19;

36.19
date     90.05.14.11.57.20;  author kodiak;  state Exp;
branches ;
next     36.18;

36.18
date     90.05.03.14.36.50;  author kodiak;  state Exp;
branches ;
next     36.17;

36.17
date     90.05.02.16.52.42;  author kodiak;  state Exp;
branches ;
next     36.16;

36.16
date     90.04.13.11.36.20;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     90.04.02.11.11.53;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     90.03.21.09.58.45;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     90.03.07.13.48.29;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     89.11.24.14.27.55;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     89.10.10.17.53.57;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     89.09.19.16.20.16;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     89.09.12.11.48.20;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     89.08.07.15.59.42;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     89.08.06.19.58.06;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     89.07.24.17.53.26;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.07.24.14.28.29;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     89.06.05.14.20.29;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     89.04.18.16.08.53;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     89.04.12.11.04.39;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     89.04.12.08.14.22;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     89.02.17.13.33.42;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


36.29
log
@Now lets 0-7 go as special device names
@
text
@**
**	$Id: ramlib.asm,v 36.28 93/03/05 09:43:43 mks Exp Locker: mks $
**
**      ramlib module
**
**      (C) Copyright 1985,1989 Commodore-Amiga, Inc.
**          All Rights Reserved
**

	SECTION	ramlib,code

**	Includes

	INCLUDE	"ramlib.i"
	INCLUDE	"internal/librarytags.i"

	INCLUDE	"ramlib_rev.i"

	IFND	AG_CreateProc
AG_CreateProc	EQU	$000B0000	; CreateProc failed
	ENDC


**	Imports

	XLVO	Alert				; Exec
	XLVO	AllocMem			;
	XLVO	CloseDevice			;
	XLVO	CloseLibrary			;
	XLVO	OpenDevice			;
	XLVO	OpenLibrary			;
	XLVO	TaggedOpenLibrary		;
	XLVO	PutMsg				;
	XLVO	RemDevice			;
	XLVO	RemLibrary			;
	XLVO	SetFunction			;
	XLVO	WaitPort			;
	XLVO	AddMemHandler			;

	XLVO	CreateProc			; DOS
	XLVO	UnLoadSeg			;

	XREF	EndModule
	XREF	FindOnList
	XREF	LoadModule
	XREF	ProcSegment

	TASK_ABLES


**	Assumptions

	IFNE	rl_DosBase
	FAIL	"rl_DosBase not zero: recode references below"
	ENDC


**********************************************************************
*
*   The ramlib code will perform the following operations from the task
*   of the invoker of OpenModule [which *may* be ramlib.process]:
*
*   1.	Search in memory for the library.  If library is not found,
*	skip to 2.  If the version is sufficient, return success.  If
*	the library open count is non-zero the library is in use:
*	return failure.  Otherwise, try to remove this copy of the
*	library.  If the library is successfully removed, skip to 2.
*	Otherwise, the library is still in memory: return failure.
*
*   2.	Check if running on the ramlib.process.  If so, call LoadModule
*	directly.  Otherwise, create a message describing the module
*	and send it to the ramlib request message port and wait on the
*	reply.
*
*   3.	Return success if the library is then found in memory and had a
*	sufficient version, fail if not.
*
*   The ramlib.process will loop on the following:
*
*   4.	Wait at the request message port for a module request, invoke
*	LoadModule, and reply the message.
*
*   LoadModule will perform the following:
*
*   5.	Search in the rom resident tags for the module.  If module is
*	not found, skip to 6.  Otherwise, InitResident() the module and
*	return.
*
*   6.	Create the file name for the module -- if no ':' exists in the
*	name already, prepend DEVS: or LIBS: to the name.  LoadSeg the
*	module.  Look for a resident tag in the loaded image -- if not
*	found, initialize with a jump to the first executable
*	instruction and return.
*
*   7.	Check the version and the library name in the resident tag and
*	if sufficient and a name match, InitResident the image and
*	return.  UnLoadSeg a useless image and return.
*


**********************************************************************
*   Module resident tag and initialization code
*
residentTag:					; STRUCTURE RT,0
		dc.w	RTC_MATCHWORD		;   UWORD RT_MATCHWORD
		dc.l	residentTag		;   APTR  RT_MATCHTAG
		dc.l	EndModule		;   APTR  RT_ENDSKIP
		dc.b	RTF_AFTERDOS		;   UBYTE RT_FLAGS
		dc.b	VERSION			;   UBYTE RT_VERSION
		dc.b	0			;   UBYTE RT_TYPE
		dc.b	-100			;   BYTE  RT_PRI
		dc.l	RLName			;   APTR  RT_NAME
		dc.l	RLID			;   APTR  RT_IDSTRING
		dc.l	RLInit			;   APTR  RT_INIT
						;   LABEL RT_SIZE

RLName		dc.b	'ramlib',0
RLID		VSTRING
		ds.w	0

RLInit:
		movem.l	d2-d4/a2-a3/a5,-(a7)

		moveq	#RamLib_SIZEOF,d0
		move.l	#MEMF_PUBLIC!MEMF_CLEAR,d1
		CALLLVO	AllocMem
		move.l	d0,ex_RamLibPrivate(a6)

	;Never	bne.s	iMemOK
	;Never	ALERT	AN_RAMLib!AG_NoMemory

iMemOK:
		move.l	d0,a5
		moveq.l	#OLTAG_DOS,d0
		CALLLVO	TaggedOpenLibrary

		move.l	d0,(a5)			; rl_DosBase

	;Never	bne.s	iDosOK
	;Never	ALERT	AN_RAMLib!AG_OpenLib!AO_DOSLib

iDosOK:
		move.l	a6,-(a7)
		move.l	d0,a6
		;-- initialize rl_LoadPort.mp_MsgList
		lea	rl_LoadPort+MP_MSGLIST(a5),a0
		NEWLIST	a0

		;-- fire up ramlib process
		lea	RLName(pc),a0
		move.l	a0,d1
		moveq	#0,d2
		lea	ProcSegment(pc),a0
		move.l	a0,d3
		lsr.l	#2,d3
		move.l	#2048,d4
		CALLLVO	CreateProc
		move.l	(a7)+,a6
		tst.l	d0

	;Never	bne.s	iWedge
	;Never	ALERT	AN_RAMLib!AG_CreateProc

		;-- take over the exec entry points
iWedge:
		lea	WedgeTable(pc),a2
		lea	rl_OriginalExecJmp(a5),a3

iWedgeLoop:
		move.w	(a2)+,d0
		beq.s	iWedgeDone
		move.w	#$4EF9,(a3)+	; jmp (addr).l
		move.l	2(a6,d0.w),(a3)+
		move.w	(a2)+,d1
		lea	WedgeTable(pc,d1.w),a0
		exg	a0,d0
		move.l	a6,a1
		CALLLVO	SetFunction
		bra.s	iWedgeLoop

iWedgeDone:
*
*******************************************************************************
*
* Now, we need to register with the memory handler in EXEC...
*
* We add our handler at priority 0 in the memory handler lists...
*
		lea	rl_MemHandler(a5),a1	; Point at handler structure
*
		; LN_PRI is already 0...
		lea	RLName(pc),a0		; Get the name...
		move.l	a0,LN_NAME(a1)		; Set name...
		; IS_DATA is not needed by RAMLIB
		lea	FlushIt(pc),a0		; The code we will run...
		move.l	a0,IS_CODE(a1)		; IS_CODE
*
		CALLLVO	AddMemHandler		; Add us to the system...
*
*******************************************************************************
*
		move.l	a5,d0
		movem.l	(a7)+,d2-d4/a2-a3/a5
		rts


		;-- list the exec routines to be replaced
		;   by lvo offset and local PC offset, and
		;   define offsets in rl_ExecEntries
WEDGEOFFSET	SET	0

WEDGE	MACRO
		dc.w	_LVO\1
		dc.w	RL\1-WedgeTable
OEJ\1		EQU	WEDGEOFFSET
WEDGEOFFSET	SET	WEDGEOFFSET+6
	ENDM

WedgeTable:
		WEDGE	CloseDevice
		WEDGE	CloseLibrary
		WEDGE	RemDevice
		WEDGE	RemLibrary
		WEDGE	OpenDevice
		WEDGE	OpenLibrary
		dc.l	0			; End of list NULL...
*
*******************************************************************************
*
* The RAMLIB MemHandler IS_CODE entry point...
*
* This entry point is called by V39 EXEC when a memory allocation failed.
* At the point this happens EXEC has already put us into Forbid() and
* we promise not to break the Forbid()...
*
FlushIt:	; This is the handler code
		; We are passed a pointer to struct MemHandler
		; in a0, the value of is_Data in a1 and
		; a pointer to the interrupt structure in a2
		; and ExecBase in a6.
		; We must not break forbid!!!
*
		move.l	a2,-(sp)		; Need some play room...
		sub.l	a1,a1			; Clear a1...
		move.l	memh_Flags(a0),d0	; Get the flags...
		btst.l	#MEMHB_RECYCLE,d0	; Are we in RECYCLE mode?
		bne.s	Continue_Flush		; If so, continue flush...
*
* Ok, so this is the first time into the flush for this allocation.  We
* need to mark the devices and libraries as not being flush yet...
*
		bra.s	Flag_Loop		; Jump into the loop...
Flag_NotDone:	bclr.b	#LIBB_EXP0CNT,LIB_FLAGS(a1)	; Clear done flag...
Flag_Loop:	bsr.s	Next_LibDev		; Get next Library/Device
		bne.s	Flag_NotDone		; Loop until all done...
		; Note that a1 is now NULL again...
*
* Ok, so we need to check for the next library to flush...
* To find the next one, we will loop here until we find one that has
* LIB_OPENCNT == 0 and the EXP0CNT flag is 0.
*
Continue_Flush:	bsr.s	Next_LibDev		; Get next one...
		beq.s	FlushIt_Exit		; No more, we exit...
		; Note, d0 is NULL if we take this branch...
		tst.w	LIB_OPENCNT(a1)		; Check if open...
		bne.s	Continue_Flush		; If open, skip...
		bset.b	#LIBB_EXP0CNT,LIB_FLAGS(a1)	; Check/set flag...
		bne.s	Continue_Flush		; Continue looking...
*
* Ok, so we have one that seems to be ready for expunge and has not yet
* been expunged in this failed AllocMem()...  Thus, call RemDevice()
* or RemLibrary() as needed.  (Next_LibDev set that up for me...)
* Then, set the return result to try the allocation again and call
* me if it failed...
*
		jsr	(a2)			; Call RemXXXX()
		moveq.l	#MEM_TRY_AGAIN,d0	; Tell handler to try again...
*
* This is where we exit...  D0 is set up as needed and we just clean up
* and return to EXEC.  Whatever magic needs to happen will happen there...
*
FlushIt_Exit:	move.l	(sp)+,a2		; restore registers...
		rts
*
*******************************************************************************
*
* A little routine that will loop from the first node given until no
* more.  Given a NULL it will get the first node.  The nodes are the
* library and device list nodes...
*
* Input:	a1 - Current library/device node...
*		a6 - ExecBase...
* Output:	a2 - Function Pointer to RemLibrary() or RemDevice()
*		a1 - Next library/device node...
*		d0 - Same as a1 (used to set the flag)
*		Z flags - Set if no more (a1 is also NULL)
*
Next_LibDev:	move.l	a1,d0			; Check the input for NULL
		bne.s	Next_One		; If not NULL, we do next...
		lea	DeviceList(a6),a1	; Point at "0" Dev node...
		lea	_LVORemDevice(a6),a2	; RemDevice for device list
Next_One:	move.l	LN_SUCC(a1),a1		; Get next one...
		tst.l	LN_SUCC(a1)		; Is it end of list?
		bne.s	Next_Done		; We are done...
		lea	DeviceList+LH_TAIL(a6),a0	; Get tail...
		cmp.l	a1,a0			; Is it end of device list?
		bne.s	Next_End		; If not, no more...
		lea	LibList(a6),a1		; Point at "0" Lib node...
		lea	_LVORemLibrary(a6),a2	; RemLibrary for library list
		bra.s	Next_One		; Get the next node...
*
Next_End:	sub.l	a1,a1			; Clear return (NULL)
Next_Done	move.l	a1,d0			; Set the return flags...
		rts				; Exit with a1 and flags set
*
*******************************************************************************
*


**********************************************************************
*   Wedges that deal with module expunging
*

;------ RLRemDevice
RLRemDevice:
		moveq	#OEJRemDevice,d0
		bra.s	closeCommon

;------ RLRemLibrary
RLRemLibrary:
		moveq	#OEJRemLibrary,d0
		bra.s	closeCommon

;------ RLCloseDevice
RLCloseDevice:
		moveq	#OEJCloseDevice,d0
		bra.s	closeCommon

;------ RLCloseLibrary
RLCloseLibrary:
		moveq	#OEJCloseLibrary,d0

closeCommon:
		move.l	ex_RamLibPrivate(a6),a0
		jsr	rl_OriginalExecJmp(a0,d0.w)
		move.l	d0,d1
		beq.s	rlRts

		move.l	a6,-(a7)
		move.l	ex_RamLibPrivate(a6),a0
		move.l	(a0),a6			; rl_DosBase
		CALLLVO	UnLoadSeg
		move.l	(a7)+,a6

rlRts:
		rts


**********************************************************************
*
*   The ramlib code will perform the following operations from the task
*   of the invoker of OpenModule [which *may* be ramlib.process]:
*
*   1.	Try exec version of Open for module.  If module is not found,
*	skip to 2.  If the version is sufficient, return success.  If
*	the library open count is non-zero the library is in use:
*	return failure.  Otherwise, try to remove this copy of the
*	library.  If the library is successfully removed, skip to 2.
*	Otherwise, the library is still in memory: return failure.
*
*   2.	Check if running on the ramlib.process.  If so, call LoadModule
*	directly.  Otherwise, create a message describing the module
*	and send it to the ramlib request message port and wait on the
*	reply.
*
*   3.	Return success if the library is then found in memory and had a
*	sufficient version, fail if not.
*

;   a4	OpenParms
;   a5	RamLib
;   a6	SysBase

;------ tailName
tailName:
		move.l	ex_RamLibPrivate(a6),a5	; load local variables
		move.l	a1,a2			; save original name
		move.l	a1,a4			; guess tail
		move.l	a1,d2			; We need trash for a bit...
		subq.l	#8,d2			; Subtract 8...
		bcs.s	tnRts			; Less than 8...
tnLoop:
		move.b	(a1)+,d2
		beq.s	tnRts
		cmp.b	#'/',d2
		beq.s	tnNewTail
		cmp.b	#':',d2
		bne.s	tnLoop
tnNewTail:
		move.l	a1,a4
		bra.s	tnLoop
tnRts:
		rts


;------ RLOpenDevice
RLOpenDevice:
		movem.l	OR_SAVEREGS,-(a7)
		move.l	a0,a1
		bsr.s	tailName
		move.l	a4,a0
		move.l	or_A1(a7),a1
		jsr	rl_OriginalExecJmp+OEJOpenDevice(a5)
		move.l	d0,d2
		beq.s	omExecDone

		;--	exec open failed try loading from process
		lea	-OpenParms_SIZEOF(a7),a7
		move.l	a4,op_OpenName(a7)
		move.l	a7,a4
		clr.b	op_OpenLibFlag(a4)
		move.l	#'DEVS',op_MergedName(a4)
		lea	DeviceList(a6),a0
		move.l	a0,op_ExecList(a4)
		bra.s	omAttemptLoad


;------ RLOpenLibrary
RLOpenLibrary:
		movem.l	OR_SAVEREGS,-(a7)
		bsr.s	tailName
		move.l	a4,a1
		jsr	rl_OriginalExecJmp+OEJOpenLibrary(a5)
		move.l	d0,d2
		bne.s	omExecDone

		;--	exec open failed try loading from process
		lea	-OpenParms_SIZEOF(a7),a7
		move.l	a4,op_OpenName(a7)
		move.l	a7,a4
		st.b	op_OpenLibFlag(a4)
		move.l	#'LIBS',op_MergedName(a4)
		lea	LibList(a6),a0
		move.l	a0,op_ExecList(a4)
		bsr	FindOnList
		beq.s	omAttemptLoad

		;--	check if failure due to wrong version
		move.l	d0,a1
		move.w	OpenParms_SIZEOF+or_D0+2(a4),d0
		cmp.w	LIB_VERSION(a1),d0
		ble.s	omFail

		;--	    try to expunge old library
		FORBID

		tst.w	LIB_OPENCNT(a1)
		bne.s	olRemLibrary


omPermitFail:
		PERMIT

omFail:
		move.l	d2,d0

omDone:
		lea	OpenParms_SIZEOF(a7),a7
omExecDone:
		addq.l	#8,a7
		movem.l	(a7)+,OR_RESTOREREGS
		rts


olRemLibrary:
		CALLLVO	RemLibrary

		PERMIT
		;--	fall thru to omAttemptLoad


omAttemptLoad:
		;--	create load name
		move.l	a2,op_ReqName(a4)
		lea	op_MergedName(a4),a0
		move.l	a2,a1
		move.l	a0,op_LoadName(a4)	; guess won't find ':'
		addq.l	#4,a0			; bump past DEVS or LIBS
		moveq	#':',d2
		move.b	d2,(a0)+
		moveq	#00,d0			; limit length of name
lnLoop:
		addq.b	#1,d0
		beq.s	omFinalOpen		; if wraps, fail LoadModule

		move.b	(a1)+,d1
		move.b	d1,(a0)+
		beq.s	lnEnd
		cmp.b	d2,d1
		bne.s	lnLoop
		move.l	a2,op_LoadName(a4)

lnEnd:
		;-- check if this is already ramlib.process
		move.l	ThisTask(a6),d0
		cmp.l	rl_LoadPort+MP_SIGTASK(a5),d0
		bne.s	omUseRamlibProc

		bsr	LoadModule

omFinalOpen:
		move.l	op_OpenName(a4),a0
		tst.b	op_OpenLibFlag(a4)
		bne.s	omFinalOpenLib

		;--	final OpenDevice
		move.l	OpenParms_SIZEOF+or_D0(a4),d0
		move.l	OpenParms_SIZEOF+or_D1(a4),d1
		move.l	OpenParms_SIZEOF+or_A1(a4),a1
		jsr	rl_OriginalExecJmp+OEJOpenDevice(a5)
		bra	omDone

omFinalOpenLib:
		move.l	OpenParms_SIZEOF+or_D0(a4),d0
		move.l	a0,a1		; op_OpenName
		jsr	rl_OriginalExecJmp+OEJOpenLibrary(a5)
		bra	omDone

omUseRamlibProc:
		move.l	d0,a0
		cmp.b	#NT_PROCESS,LN_TYPE(a0)
		beq.s	omFromProcess

		;--	task has no CurrentDir or HomeDir

		clr.l	op_CurrentDir(a4)
		clr.l	op_HomeDir(a4)

		;-- called from task, but up until 2/7/91 we
		;-- has been using ramlib's process windowptr.
		;-- therefore because I DONT want to change existing
		;-- 2.0 behavior, use 0 here instead of -1.

		clr.l	op_WindowPtr(a4)

		bra.s	omQueueMsg

omFromProcess:
		move.l	pr_CurrentDir(a0),op_CurrentDir(a4)
		move.l	pr_HomeDir(a0),op_HomeDir(a4)
		move.l	pr_WindowPtr(a0),op_WindowPtr(a4)

		;-- set up message and reply port on stack
omQueueMsg:
		lea	op_LMPort(a4),a1
		move.l	a1,op_SR_LMMsg+MN_REPLYPORT(a4)
		;--	clr MP_FLAGS & set MP_SIGBIT
		move.w	#SIGB_SINGLE,MP_FLAGS(a1)
		move.l	d0,MP_SIGTASK(a1)
		lea	MP_MSGLIST(a1),a1
		NEWLIST	a1

		lea	rl_LoadPort(a5),a0
		lea	op_SR_LMMsg(a4),a1
		CALLLVO	PutMsg
		lea	op_LMPort(a4),a0
		CALLLVO	WaitPort
		;-- (no need to fix up message port on stack)
		bra	omFinalOpen

	END
@


36.28
log
@Added support for NULL as the name to OpenDevice/OpenLibrary...
For the timer.device hack...
@
text
@d2 1
a2 1
**	$Id: ramlib.asm,v 36.27 93/02/15 16:20:59 mks Exp Locker: mks $
d389 3
a391 2
		move.l	a1,d2			; Check if NULL...
		beq.s	tnRts			; NULL string, RTS...
@


36.27
log
@Removed alerts that should (can not) ever happen...
@
text
@d2 1
a2 1
**	$Id: ramlib.asm,v 36.26 92/05/11 15:08:44 mks Exp Locker: mks $
d389 2
@


36.26
log
@Fixed the trashing of registers in the init code!
Bad Kodiak!!!
@
text
@d2 1
a2 1
**	$Id: ramlib.asm,v 36.25 92/04/20 09:47:47 mks Exp Locker: mks $
a127 1
		bne.s	iMemOK
d129 2
a130 1
		ALERT	AN_RAMLib!AG_NoMemory
a137 1
		bne.s	iDosOK
d139 2
a140 1
		ALERT	AN_RAMLib!AG_OpenLib!AO_DOSLib
a159 1
		bne.s	iWedge
d161 2
a162 1
		ALERT	AN_RAMLib!AG_CreateProc
@


36.25
log
@Changed to use TaggedOpenLibrary()
@
text
@d2 1
a2 1
**	$Id: ramlib.asm,v 36.24 92/02/03 09:03:51 mks Exp Locker: mks $
d122 1
a122 1
		movem.l	a2-a3/a5,-(a7)
d203 1
a203 1
		movem.l	(a7)+,a2-a3/a5
@


36.24
log
@Changed RAMLIB to use the new (V39) EXEC expunge memory handlers...
No longer SetFunctions the AllocMem() call.
@
text
@d2 1
a2 1
**	$Id: ramlib.asm,v 36.23 91/02/08 22:07:27 darren Exp Locker: mks $
d15 1
d32 1
a117 2
DLName		dc.b	'dos.library',0

d134 2
a135 3
		lea	DLName(pc),a1
		moveq	#36,d0
		CALLLVO	OpenLibrary
@


36.23
log
@Go with 0 for default pr_WindowPtr for tasks.
@
text
@d2 1
a2 1
**	$Id: ramlib.asm,v 36.22 91/02/07 12:49:03 darren Exp Locker: darren $
d36 1
d172 1
a172 1
		bpl.s	iWedgeDone
d183 20
a220 1
		WEDGE	AllocMem
d227 55
a281 6
		dc.l	0			; positive



**********************************************************************
*   AllocMem wedge
d283 1
a283 25

AMNQ_SAVEREGS	REG	d2/d3/d4/d5/d6/d7/a2/a3/a4
AMNQ_SAVEPARMS	EQU	10*4

;------ RLAllocMem (size:d0, type:d1)
RLAllocMem:
		move.l	d1,-(a7)	; in the order of movem.l d0-d1,-(a7)
		move.l	d0,-(a7)	;   but sets condition code for d0
		beq.s	amAllocDone

		FORBID

		;-- try the original alloc
		move.l	ex_RamLibPrivate(a6),a0
		jsr	rl_OriginalExecJmp+OEJAllocMem(a0)

		tst.l	d0
		beq.s	amNotQuick

amPermit:
		PERMIT

amAllocDone:
		addq.l	#8,a7
		tst.l	d0
d285 34
a318 114

amNotQuick:
		;-- the call failed.  try and free stuff
		;
		;	go thru *both* the device and the library lists
		;	from low priority to high priority.
		;
		;	pass 1:
		;	    clear all LIBF_EXP0CNTs
		;	pass 2:
		;	    /* hit all subsystems */
		;	    NOTE: pass 2 cannot be performed because
		;		the Manx environment "library" has no
		;		expunge jump vector.
		;	pass 3:
		;	    hit all subsystems w/ lib_OpenCnt == 0 and not
		;		    LIBF_EXP0CNT.
		;	    loop in pass 3 till nothing done in a pass
		;
		;	a hit is described to be:
		;	    if lib_OpenCnt == 0 set LIBF_EXP0CNT
		;	    Expunge()
		;	    if Expunge() result, UnLoadSeg it
		;	    reattempt memory allocation
		;
		movem.l	AMNQ_SAVEREGS,-(a7)

		lea	amnqPass1(pc),a2
		bsr.s	amnqPass
		lea	amnqPass3(pc),a2

amnqPass3Loop:
		moveq	#0,d2		; show no hits this pass
		bsr.s	amnqPass
		tst.w	d2
		bne.s	amnqPass3Loop

		;-- still no memory.  Mark failure in appropriate places.
		movem.l	(a7)+,AMNQ_SAVEREGS

		;--	DOS Process needs Result2 set to ERROR_NO_FREE_STORE
		move.l	ThisTask(a6),a0
		cmp.b	#NT_PROCESS,LN_TYPE(a0)
		bne.s	amPermit

		moveq	#ERROR_NO_FREE_STORE,d1
		move.l	d1,pr_Result2(a0)
		bra.s	amPermit


amnqPass:
		move.l	DeviceList+LH_TAILPRED(a6),d3
		lea	_LVORemDevice(a6),a3
		move.l	LibList+LH_TAILPRED(a6),d4
		lea	_LVORemLibrary(a6),a4
		move.w	#-129,d6	; lower than possible priority
		bra.s	amnqpLoop

amnqpSwapLibDev:
		exg	d3,d4
		exg	a3,a4
		move.w	d5,d6
amnqpLoop:
		move.l	d3,a1
		move.l	LN_PRED(a1),d7
		beq.s	amnpqEmptyPri
		move.b	LN_PRI(a1),d5
		ext.w	d5
		bra.s	amnqpCheckLibDev

amnpqEmptyPri:
		move.w	#128,d5		; higher than possible priority

		;-- check if still working with the lowest list
amnqpCheckLibDev:
		cmp.w	d5,d6
		blt.s	amnqpSwapLibDev

		move.l	d7,d3
		beq.s	amnqpRts

		jsr	(a2)

		bra.s	amnqpLoop


amnqPass1:
		bclr.b	#LIBB_EXP0CNT,LIB_FLAGS(a1)
amnqpRts:
		rts


amnqPass3:
		tst.w	LIB_OPENCNT(a1)
		bne.s	amnqpRts
		bset.b	#LIBB_EXP0CNT,LIB_FLAGS(a1)
		bne.s	amnqpRts
		moveq	#1,d2		; show hit in this pass

		jsr	(a3)		; RemLibrary or RemDevice

		;-- try the alloc again
		movem.l	AMNQ_SAVEPARMS+4(a7),d0-d1
		move.l	ex_RamLibPrivate(a6),a0
		jsr	rl_OriginalExecJmp+OEJAllocMem(a0)

		tst.l	d0
		beq.s	amnqpRts

		;-- success: bail out
		addq.l	#8,a7		; pop Pass and PassN returns
		movem.l	(a7)+,AMNQ_SAVEREGS
		bra	amPermit

@


36.22
log
@Propagate calling processes pr_WindowPtr field to ramlib's process.
Set ramlib's process pr_WindowPtr field to 0 for tasks to preserve
existing 2.0 behavior.
@
text
@d2 1
a2 1
**	$Id: ramlib.asm,v 36.21 90/11/16 17:19:42 darren Exp Locker: darren $
@


36.21
log
@Fixes crash bug if a path name longer than 255
characters is used.
@
text
@d2 1
a2 1
**	$Id: ramlib.asm,v 36.20 90/06/14 16:35:04 kodiak Exp Locker: darren $
d568 1
d571 8
d584 1
d602 1
a602 1
		bra.s	omFinalOpen
@


36.20
log
@split stack usage so OpenDevice/OpenLibrary of in-core modules
uses 1.3-compatible amount.
@
text
@d2 1
a2 1
**	$Id: ramlib.asm,v 36.19 90/05/14 11:57:20 kodiak Exp Locker: kodiak $
d524 1
d526 3
@


36.19
log
@o   propagates pr_CurrentDir and pr_HomeDir to ramlib process for it's use
    if invoker is a process, and sets them to zero if invoker is a task.
@
text
@d2 1
a2 1
**	$Id: ramlib.asm,v 36.18 90/05/03 14:36:50 kodiak Exp Locker: kodiak $
a49 3
	IFNE	op_ParmRegs
	FAIL	"op_ParmRegs not zero: recode references below"
	ENDC
d416 23
d441 1
a441 5
		movem.l	OP_SAVEREGS,-(a7)
		lea	-OpenParms_SIZEOF(a7),a7
		move.l	a7,a4
		movem.l	d0-d1/a1,(a4)	; op_ParmRegs(a4)
		move.l	#'DEVS',op_MergedName(a4)
d444 2
a445 2

		movem.l	op_ParmRegs+4(a4),d1/a1
d448 1
a448 1
		beq.s	omDone
d450 4
d455 1
d458 1
a458 1
		bra	omAttemptLoad
a460 53
;------ tailName
tailName:
		;--	OK, so it's nothing to do w/ tailName but it's shared
		move.l	ex_RamLibPrivate(a6),a5

		;--	initialize for tailName
		move.l	a1,op_ReqName(a4)
		lea	op_MergedName(a4),a2
		move.l	a2,op_LoadName(a4)	; guess won't find ':'
		addq.l	#4,a2			; bump past DEVS or LIBS
		moveq	#':',d2
		move.b	d2,(a2)+

		;--	now tailName stuff
tnBump:
		move.l	a1,a0
tnNoBump:
		move.b	(a1)+,d1
		move.b	d1,(a2)+
		beq.s	tnEnd
		cmp.b	d2,d1
		bgt.s	tnNoBump
		beq.s	tnVolSpecified
		cmp.b	#'/',d1
		bne.s	tnNoBump
		bra.s	tnBump

tnEnd:
		move.l	a0,op_OpenName(a4)
		rts

tnVolSpecified:
		move.l	op_ReqName(a4),op_LoadName(a4)
		bra.s	tnBump



;------ exit code
omPermitFail:
		PERMIT

omFail:
		move.l	d2,d0


omDone:
		;-- fix up stack
		lea	OpenParms_SIZEOF(a7),a7
		movem.l	(a7)+,OP_SAVEREGS
		rts



d463 1
a463 5
		movem.l	OP_SAVEREGS,-(a7)
		lea	-OpenParms_SIZEOF(a7),a7
		move.l	a7,a4
		move.l	d0,(a4)		; op_ParmRegs(a4)
		move.l	#'LIBS',op_MergedName(a4)
d465 1
a465 4

		move.l	ex_RamLibPrivate(a6),a5

		move.l	a0,a1
d468 1
a468 1
		bne.s	omDone
d470 4
d475 1
d481 1
a481 1
		;-- check if failure due to wrong version
d483 1
a483 1
		move.w	op_ParmRegs+2(a4),d0
d487 1
a487 1
		;-- try to expunge old library
d491 1
a491 1
		bne.s	omPermitFail
d493 16
d512 1
a513 1
		;-- fall thru to omAttemptLoad
d515 16
a530 6
;------
;   d2	current failure code
;   a0	ExecList
;   a4	OpenParms
;   a5	RamLib
;   a6	SysBase
d532 1
a532 1
omAttemptLoad:
d546 3
a548 1
		movem.l	(a4),d0-d1/a1	; op_ParmRegs(a4)
d553 1
a553 1
		move.l	(a4),d0		; op_ParmRegs(a4)
@


36.18
log
@do not expunge for AllocMem(0, ...)
@
text
@d2 1
a2 1
**	$Id: ramlib.asm,v 36.17 90/05/02 16:52:42 kodiak Exp Locker: kodiak $
d544 1
a544 1
		bne.s	omUseProcess
d564 14
a577 1
omUseProcess:
d579 1
@


36.17
log
@ensure modules were not initialized by prior opens queued ahead of this one
@
text
@d2 1
a2 1
**	$Id: ramlib.asm,v 36.16 90/04/13 11:36:20 kodiak Exp Locker: kodiak $
d223 3
a225 1
		movem.l	d0-d1,-(a7)
d239 1
@


36.16
log
@use Id instead of Header for 4.x rcs
@
text
@d2 1
a2 1
**	$Id$
d434 1
a434 1
		bra	omChkExistant
d510 1
a510 1
		beq.s	omNonExistant
d528 1
a528 2
		move.l	op_ExecList(a4),a0
		;-- fall thru to omChkExistant
d537 1
a537 6
omChkExistant:
		;-- check if name already on exec list
		bsr	FindOnList
		bne.s	omFail

omNonExistant:
@


36.15
log
@for rcs 4.x header change
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/ramlib/RCS/ramlib.asm,v 36.14 90/03/21 09:58:45 kodiak Exp Locker: kodiak $
@


36.14
log
@correctly test for already running in ramlib process
@
text
@d2 1
a2 1
**	$Header: ramlib.asm,v 36.13 90/03/07 13:48:29 kodiak Exp $
@


36.13
log
@split ramlib and removed code to check libs/ on all disks and prompt user
this release concurrent w/ adding loadmod.asm and proc.asm -- which use
new ramlib process to find module to initialize from rom or disk
@
text
@d2 1
a2 1
**	$Header: ramlib.asm,v 36.12 89/11/24 14:27:55 kodiak Exp $
d545 1
d552 1
a557 1
		move.l	op_OpenName(a4),a0
d563 1
a563 1
		move.l	op_OpenName(a4),a1
a572 1
		move.l	ThisTask(a6),d0
@


36.12
log
@rename ramlib.library to just ramlib
@
text
@d2 1
a2 1
**	$Header: ramlib.asm,v 36.11 89/10/10 17:53:57 kodiak Exp $
d12 1
a12 1
**	Included Files
d14 1
a14 17
	NOLIST
	INCLUDE	"exec/types.i"
	INCLUDE	"exec/nodes.i"
	INCLUDE	"exec/lists.i"
	INCLUDE	"exec/libraries.i"
	INCLUDE	"exec/memory.i"
	INCLUDE	"exec/execbase.i"
	INCLUDE	"exec/alerts.i"
	INCLUDE	"exec/ables.i"
	INCLUDE	"exec/initializers.i"
	INCLUDE	"exec/resident.i"
	INCLUDE	"exec/execbase.i"
	INCLUDE	"exec/errors.i"
	INCLUDE	"libraries/dos.i"
	INCLUDE	"libraries/dosextens.i"
	INCLUDE	"intuition/intuition.i"
	LIST
a15 4
	IFND	LIBB_EXP0CNT
LIBB_EXP0CNT	EQU	4
	ENDC

d18 3
a20 1
**	Imported Names
a21 3
XLVO	MACRO
	XREF	_LVO\1
	ENDM
d23 1
a23 22
	XLVO	AddTail
	XLVO	Alert
	XLVO	AllocMem
	XLVO	CloseDevice
	XLVO	CloseLibrary
	XLVO	FindName
	XLVO	FindResident
	XLVO	Forbid
	XLVO	FreeMem
	XLVO	InitResident
	XLVO	OpenDevice
	XLVO	OpenLibrary
	XLVO	Permit
	XLVO	PutMsg
	XLVO	RemDevice
	XLVO	RemLibrary
	XLVO	Remove
	XLVO	SetFunction
	XLVO	SetSignal
	XLVO	Signal
	XLVO	Wait
	XLVO	WaitPort
d25 11
a35 5
	XLVO	CurrentDir
	XLVO	LoadSeg
	XLVO	Lock
	XLVO	UnLoadSeg
	XLVO	UnLock
d37 2
a38 3
	XLVO	BuildEasyRequestArgs
	XLVO	FreeSysRequest
	XLVO	SysReqHandler
d40 4
d48 1
a48 3
**********************************************************************
*   Local Definitions
*
d50 3
a52 17
CALLLVO	MACRO
		jsr	_LVO\1(a6)
	ENDM

;
;   module data, pointed to by ex_RamLibPrivate in ExecBase
;
RL_NUMENTRIES	EQU	7

    STRUCTURE	RamLib,0
	ULONG	rl_DosBase			; must be zero
	ULONG	rl_IntuiBase
	STRUCT	rl_OriginalExecJmp,RL_NUMENTRIES*6
	STRUCT	rl_LockList,MLH_SIZE
	STRUCT	rl_CancelledForever,MLH_SIZE
	LABEL   RamLib_SIZEOF

d54 1
a54 1
	FAIL	"recode rl_DosBase references below"
a56 15
;
;   this is the stuff that must be saved every open (kept in A2)
;   the offsets are actually negative (because we use LINK).
;
 STRUCTURE OpenParms,0
	APTR	Fop_FileName
	APTR	Fop_OpenName
	STRUCT	Fop_ParmRegs,3*4	; d0/d1/a1, or d0
	LABEL	Fop_SaveRegs		; d2/a3/a4/a5/a6
	ULONG	Fop_D2
	ULONG	Fop_A3
	ULONG	Fop_A4
	ULONG	Fop_A5
	ULONG	Fop_A6
	LABEL	OpenParms_SIZEOF
a57 58
;   the registers preserved in op_SaveRegs
OP_SAVEREGS	REG	d2/a3/a4/a5/a6

;   the real (negative) offsets
DEFOP	MACRO
\1	EQU	(F\1-OpenParms_SIZEOF)
	ENDM

	DEFOP	op_FileName
	DEFOP	op_OpenName
	DEFOP	op_ParmRegs
	DEFOP	op_SaveRegs
	DEFOP	op_D2
	DEFOP	op_A3
	DEFOP	op_A4
	DEFOP	op_A5
	DEFOP	op_A6

;
;   this is stuff that is needed only if we need to initialize the lib/dev
;   (kept in A3)
;
 STRUCTURE ExtendedParms,0
	STRUCT	ep_Node,LN_SIZE
	APTR	ep_Static
	APTR	ep_ExecList
	ULONG   ep_Result
	ULONG	ep_Segment
	ULONG	ep_OldDir
	APTR    ep_ReqWindow
	STRUCT	ep_PreventList,MLH_SIZE
	STRUCT	ep_AttemptedVolList,MLH_SIZE
	STRUCT	ep_Port,MP_SIZE
	STRUCT	ep_Msg,MN_SIZE
	ALIGNLONG
	STRUCT	ep_Packet,dp_SIZEOF
	LABEL	ExtendedParms_SIZEOF

ep_NoMemCode	EQU	LN_PRI			; use unused byte

;   the entry pointed to by ep_Static
 STRUCTURE StaticParms,0
	APTR	sp_OpenFunction
	STRUCT	sp_DirName,8
	APTR	sp_Failure

	IFNE	sp_OpenFunction
	FAIL	"sp_OpenFunction not zero, recode below"
	ENDC

;   an entry on ep_AttemptedVolList
 STRUCTURE AttemptedVol,MLN_SIZE
	BPTR	av_LockB
	BPTR	av_TaskPort
	UBYTE	av_Dismounted
	LABEL	AttemptedVol_SIZEOF


a58 1
*   static data (here to ensure longword alignment for first two)
d60 39
a98 4
		;-- ensure the bstrs here are longword aligned
DevStatic	dc.l	OldOpenDevice
		dc.b	4,'DEVS:',0,0
		dc.l	IOERR_OPENFAIL	; OpenDevice failure
a99 3
LibStatic	dc.l	OldOpenLibrary
		dc.b	4,'LIBS:',0,0
		dc.l	0		; OpenLibrary failure
a100 41

odEasyStruct	dc.l	es_SIZEOF
		dc.l	0
		dc.l	0
		dc.l	odTextFormat
		dc.l	ocGadFormat

ol0EasyStruct	dc.l	es_SIZEOF
		dc.l	0
		dc.l	0
		dc.l	ol0TextFormat
		dc.l	ocGadFormat

olvEasyStruct	dc.l	es_SIZEOF
		dc.l	0
		dc.l	0
		dc.l	olvTextFormat
		dc.l	ocGadFormat


odTextFormat	dc.b	'Please insert disk with file',10
		dc.b	'devs/%s',10
		dc.b	'in any drive.',0
ol0TextFormat	dc.b	'Please insert disk with file',10
		dc.b	'libs/%s',10
		dc.b	'in any drive.',0
olvTextFormat	dc.b	'Please insert disk with file',10
		dc.b	'libs/%s',10
		dc.b	'(version %ld or greater)',10
		dc.b	'in any drive.',0
ocGadFormat	dc.b	'Retry|Retry All Disks|Cancel Forever|Cancel',0


RamLibName	dc.b	'ramlib',0
DosLibName	dc.b	'dos.library',0
IntuiLibName	dc.b	'intuition.library',0

RamLibID	VSTRING
		ds.w	0


d104 1
a104 1
ResidentTag:					; STRUCTURE RT,0
d106 1
a106 1
		dc.l	ResidentTag		;   APTR  RT_MATCHTAG
d112 3
a114 3
		dc.l	RamLibName		;   APTR  RT_NAME
		dc.l	RamLibID		;   APTR  RT_IDSTRING
		dc.l	RamLibInit		;   APTR  RT_INIT
d116 8
a123 1
RamLibInit:
d127 1
a127 1
		moveq	#MEMF_PUBLIC,d1
d136 2
a137 2
		lea	DosLibName(pc),a1
		moveq	#0,d0
d146 5
a150 3
		lea	IntuiLibName(pc),a1
		moveq	#0,d0
		CALLLVO	OpenLibrary
d152 12
a163 2
		move.l	d0,rl_IntuiBase(a5)
		bne.s	iIntuiOK
d165 1
a165 1
		ALERT	AN_RAMLib!AG_OpenLib!AO_Intuition
a166 1
iIntuiOK:
d168 1
a184 6
		;-- initialize rl_LockList
		NEWLIST	a3
		;-- initialize rl_CancelledForever
		lea	rl_CancelledForever(a5),a0
		NEWLIST	a0

d283 1
a283 1
		bne.s	amfCheckOpen
d287 1
a288 4
		;--	note if during library or device initialization
amfCheckOpen:
		move.l	ex_RamLibPrivate(a6),a1
		move.l	rl_LockList(a1),d1
a289 8
amfExtendedParmLoop:
		move.l	d1,a1
		move.l	(a1),d1
		beq.s	amPermit
		move.b	#1,ep_NoMemCode(a1)
		bra.s	amfExtendedParmLoop


a395 1
*   Open Wedges
d397 18
d418 5
a422 3
		link	a2,#-OpenParms_SIZEOF
		movem.l	d0-d1/a1,op_ParmRegs(a2)
		movem.l	OP_SAVEREGS,op_SaveRegs(a2)
d424 1
a424 1
		bsr.s	TailName
d426 1
a426 3
		move.l	ex_RamLibPrivate(a6),a5

		movem.l	op_ParmRegs+4(a2),d1/a1
d429 1
a429 1
		beq.s	openImmediate
d431 4
a434 3
		lea	DeviceList(a6),a3
		lea	DevStatic(pc),a4
		bra.s	openChkExistant
d437 14
a450 3
;------ TailName
TailName:
		move.l	a1,op_FileName(a2)
a452 2
tnReload:
		moveq	#':',d1
d454 2
a455 4
		cmp.b	(a1)+,d1
		blt.s	tnNoBump
		beq.s	tnBump
		move.b	-1(a1),d1
d457 3
d461 1
a461 1
		bne.s	tnReload
d463 1
d465 1
a465 1
		move.l	a0,op_OpenName(a2)
d468 3
d472 4
a475 2
;------ openFail/openImmediate
openPermitFail:
d478 1
a478 1
openFail:
d481 5
a485 3
openImmediate:
		movem.l	op_SaveRegs(a2),OP_SAVEREGS
		unlk	a2
d489 1
d492 6
a497 4
		link	a2,#-OpenParms_SIZEOF
		move.l	d0,op_ParmRegs(a2)
		movem.l	OP_SAVEREGS,op_SaveRegs(a2)
		bsr.s	TailName
d504 1
a504 1
		bne.s	openImmediate
d506 3
a508 3
		lea	LibList(a6),a3
		lea	LibStatic(pc),a4
		move.l	a3,a0
d510 1
a510 1
		beq.s	openNonExistant
d514 1
a514 1
		move.w	op_ParmRegs+2(a2),d0
d516 1
a516 1
		ble.s	openFail
d522 1
a522 1
		bne.s	openPermitFail
a526 1
		;-- fall thru to openChkExistant
d528 3
d532 5
a536 1
;	( openParms:a2, list:a3, static:a4, ramlib:a5, execbase:a6 )
d538 1
a538 1
openChkExistant:
a539 1
		move.l	a3,a0
d541 1
a541 1
		bne.s	openFail
d543 4
a546 7
openNonExistant:
	IFNE	0	; remove for alpha 15 -- put back when FindResident in exec
		;-- check if this is a DOS process
		move.l	ThisTask(a6),a0
		cmp.b	#NT_PROCESS,LN_TYPE(a0)
		bne	ocFail
	ENDC
d548 1
a548 6
		;-- allocate memory for work
		move.l	#ExtendedParms_SIZEOF,d0
		move.l	#MEMF_CLEAR,d1
		CALLLVO	AllocMem
		tst.l	d0
		beq	ocFail
d550 3
a552 9
		;-- initialize extended parameters
		exg	d0,a3
		move.l	d0,ep_ExecList(a3)
		move.l	a4,ep_Static(a3)
		move.l	sp_Failure(a4),ep_Result(a3)
		lea	ep_PreventList(a3),a0
		NEWLIST	a0
		lea	ep_AttemptedVolList(a3),a0
		NEWLIST	a0
d554 5
a558 5
		;--	initialize packet interface structures
		move.w	#SIGB_SINGLE,ep_Port+MP_FLAGS(a3)
		move.l	ThisTask(a6),ep_Port+MP_SIGTASK(a3)
		lea	ep_Port+MP_MSGLIST(a3),a0
		NEWLIST	a0
d560 5
a564 2
		lea	ep_Packet(a3),a1
		move.l	a1,ep_Msg+LN_NAME(a3)
d566 10
a575 13
		lea	ep_Msg(a3),a0
		move.l	a0,(a1)		; dp_Link
		addq.l	#dp_Type-dp_Link,a1
		moveq	#ACTION_LOCATE_OBJECT,d0
		move.l	d0,(a1)+	; dp_Type
		addq.l	#dp_Arg1-dp_Res1,a1
		clr.l	(a1)+		; dp_Arg1: Lock
		move.l	a4,d0
		addq.l	#sp_DirName,d0
		lsr.l	#2,d0
		move.l	d0,(a1)+	; dp_Arg2: Name (BSTR)
		moveq	#SHARED_LOCK,d0
		move.l	d0,(a1)+	; dp_Arg3: Mode
d577 2
a578 237
		;-- prevent multiple openers
ocPrevent:
		FORBID

ocpRetry:
		;-- make sure the dev/lib is not on the exec list
		bsr	FindExecList
		bne.s	ocpAppeared

		;-- see if the dev/lib is already locked
		lea	rl_LockList(a5),a0
		bsr	FindOnList
		beq.s	ocpGotLock

		;-- it is locked.  d0 has who we will sleep on
		move.l	d0,a0
		lea	ep_PreventList(a0),a0
		move.l	a3,a1
		CALLLVO	AddTail

		;-- now sleep until we are woken up
		moveq	#SIGF_SINGLE,d0
		CALLLVO	Wait
		bra.s	ocpRetry

ocpAppeared:
		;-- The device reappeared on the list -- try one last open
		PERMIT

		bra.s	ocLastTry

ocpGotLock:
		;-- we got the lock.  tell everyone else
		move.l	op_OpenName(a2),LN_NAME(a3)
		lea	rl_LockList(a5),a0
		move.l	a3,a1
		CALLLVO	AddTail

		PERMIT

		;-- see if we can find a resident tag
		move.l	op_OpenName(a2),a1
		CALLLVO	FindResident
		tst.l	d0
		beq.s	ocTryDisks

		;-- we have a rom resident tag.  go and initialize it
		move.l	d0,a1
		moveq	#0,d1
		CALLLVO	InitResident

ocLastTry:
		;-- try the call again
		bsr	OriginalOpen
		bra	ocResult

ocTryDisks:
	IFNE	1	; change this when already tested above
		;-- check if this is a DOS process
		move.l	ThisTask(a6),a0
		cmp.b	#NT_PROCESS,LN_TYPE(a0)
		bne	ocResult		; with failure
	ENDC

		;-- get the current directory
		moveq	#0,d1			; root directory
		move.l	(a5),a6			; rl_DosBase
		CALLLVO	CurrentDir
		move.l	d0,ep_OldDir(a3)

		;-- get an AttemptedVol entry
		bsr	GetAV
		beq	ocRestoreCD

		;-- try and get a lock on the DEVS:/LIBS: directory
		move.l	ep_Static(a3),d1
		addq.l	#sp_DirName+1,d1
		move.l	#SHARED_LOCK,d2
		move.l	(a5),a6			; rl_DosBase
		CALLLVO	Lock

		;-- get associated volume
		move.l	d0,d1
		beq	ocFindVolume

		lsl.l	#2,d0
		move.l	d0,a0
		move.l	fl_Task(a0),av_TaskPort(a4)


		;-- try to load file in dir in d1
ocTryLoad:
		move.l	d1,av_LockB(a4)

		;-- set the current directory
		move.l	(a5),a6			; rl_DosBase
		CALLLVO	CurrentDir

		;-- try and load the library in
		move.l	op_FileName(a2),d1
		CALLLVO	LoadSeg

		move.l	d0,ep_Segment(a3)
		beq	ocNextVolume

		;-- well we loaded in something.  try and find a romtag
ocNextSegment:
		lsl.l	#2,d0		; convert from BPTR to APTR
		beq.s	ocNoRamTag	; no more segments to check
		move.l	d0,a0
		move.l	-4(a0),d1	; length of segment (in bytes)
		move.l	(a0)+,d0	; cache next segment BPTR
		sub.l	#6+RT_SIZE,d1	; subtract segment header
					; + sizeof resident tag
		bls.s	ocNextSegment

ocRamTagSearch:
		subq.l	#2,d1
		bls.s	ocNextSegment

		cmp.w	#RTC_MATCHWORD,(a0)+
		bne.s	ocRamTagSearch

		lea	-RT_MATCHTAG(a0),a1
		cmp.l	(a0),a1
		bne.s	ocRamTagSearch

		;-- we found a ram tag

		;-- is this OpenLibrary or OpenDevice
		tst.l	ep_Result(a3)	; device failure is non-zero
		bne.s	ocDevice

		;-- check library version
		move.l	op_ParmRegs(a2),d0
		cmp.b	RT_VERSION(a1),d0
		bgt.s	ocRamInitUnload

		;-- check dev/lib name
ocDevice:
		move.l	op_OpenName(a2),a0

		move.l	RT_NAME(a1),a4
ocNameCheck:
		move.b	(a0)+,d0
		beq.s	ocNameNull
		cmp.b	(a4)+,d0
		bne.s	ocNameEnd
		bra.s	ocNameCheck
ocNameNull:
		tst.b	(a4)
ocNameEnd:
		bne.s	ocRamInitUnload

ocRamTagInit:
		move.l	ep_Segment(a3),d1
		move.l	op_A6(a2),a6	; restore SysBase
		CALLLVO	InitResident
		bra.s	ocRamInitOK


		;-- module image inappropriate
ocRamInitUnload:
		move.l	ep_Segment(a3),d1
		move.l	(a5),a6			; rl_DosBase
		CALLLVO	UnLoadSeg
		bra.s	ocNextVolume


		;-- no ram tag found
ocNoRamTag:
		move.l	ep_Segment(a3),a0
		move.l	a0,d0
		lsl.l	#2,d0
		move.l	d0,a1
		jsr	4(a1)

ocRamInitOK:
		;-- try the open again
		move.l	op_A6(a2),a6	; restore SysBase
		bsr	OriginalOpen
		bne	ocRestoreCD

		;-- look for another volume to search in
ocNextVolume:
		;--	check for memory problem with previous attempt
		tst.b	ep_NoMemCode(a3)
		bne	ocRestoreCD

		bsr	GetAV
		beq	ocRestoreCD

ocFindVolume:
		move.l	op_A6(a2),a6	; restore SysBase
		FORBID
		;-- find start of list
		move.l	(a5),a0		; get DosLibrary *	; rl_DosBase
		move.l	dl_Root(a0),a0	; get RootNode *
		move.l	rn_Info(a0),d0	; get Info BPTR
		lsl.l	#2,d0
		move.l	d0,a0
		move.l	di_DevInfo(a0),d0	; get Device List BPTR
ocVolLoop:
		;-- check if at end of list
		beq.s	ocEndVolSearch
		lsl.l	#2,d0
		move.l	d0,a0
		;-- check for a volume in the drive
		cmp.l	#DLT_VOLUME,dl_Type(a0)	; check if volume entry
		bne.s	ocVolNext
		;-- check for an active task
		move.l	dl_Task(a0),d0		; save volume task
		beq.s	ocVolNext

		;-- check if already attempted
		move.l	ep_AttemptedVolList(a3),d1
ocCheckAttempted:
		move.l	d1,a1
		move.l	(a1),d1
		beq.s	ocEndVolSearch		; not already attempted
		cmp.l	av_TaskPort(a1),d0
		bne.s	ocCheckAttempted

ocVolNext:
		move.l	(a0),d0			; get next device entry BPTR
		bne.s	ocVolLoop

ocEndVolSearch:
		PERMIT
		move.l	d0,av_TaskPort(a4)
		beq.s	ocRequestor

		;-- locate a DEVS/LIBS drawer on this volume
		lea	ep_Port(a3),a0		; set reply port
		move.l	a0,ep_Packet+dp_Port(a3)
		move.l	d0,a0
		lea	ep_Msg(a3),a1
d580 1
a580 1
		lea	ep_Port(a3),a0
d582 2
a583 381
		move.l	d0,a1
		CALLLVO	Remove

		move.l	ep_Packet+dp_Res1(a3),d1
		bne	ocTryLoad
		bra	ocNextVolume


ocRequestor:
		bsr	FreeAV		; remove/free this AttemptedVol entry

		;-- check if appropriate to put up a requestor
ocCheckRequestor:
		lea	rl_CancelledForever(a5),a0
		move.l	op_OpenName(a2),a1
		move.l	op_A6(a2),a6	; restore SysBase
		CALLLVO	FindName
		tst.l	d0
		bne	ocRestoreCD

ocGetWindow:
		;-- extract the process window pointer for user interaction
		move.l	ThisTask(a6),a0
		move.l	pr_WindowPtr(a0),a0
		cmp.w	#-1,a0
		beq	ocRestoreCD	; no interaction if == -1

		;-- prompt the user
		move.l	a3,-(a7)
		move.l	#DISKREMOVED!DISKINSERTED,d0

		;--	is this OpenLibrary or OpenDevice
		tst.l	ep_Result(a3)		; device failure is non-zero
		bne.s	ocDevicePrompt

		move.l	op_ParmRegs(a2),-(a7)	; version
		beq.s	ocAnyLibraryPrompt
		lea	olvEasyStruct(pc),a1
		bra.s	ocPrompt

ocAnyLibraryPrompt:
		lea	ol0EasyStruct(pc),a1
		bra.s	ocPrompt

ocDevicePrompt:
		subq.l	#4,a7
		lea	odEasyStruct(pc),a1

ocPrompt:
		move.l	op_OpenName(a2),-(a7)
		move.l	a7,a3			; Args
		move.l	rl_IntuiBase(a5),a6

		CALLLVO	BuildEasyRequestArgs
		addq.l	#8,a7
		move.l	(a7)+,a3

		move.l	d0,ep_ReqWindow(a3)
		beq.s	ocSatisfiedReq
		move.l	d0,a0			; Window
		cmp.w	#1,a0
		beq.s	ocSatisfiedReq

ocSysReq:
		moveq	#1,d0			; wait for input
		move.l	ep_ReqWindow(a3),a0
		subq.l	#4,a7
		move.l	a7,a1			; IDCMPFlagsPtr
		move.l	rl_IntuiBase(a5),a6
		CALLLVO	SysReqHandler

		move.l	(a7)+,d1		; IDCMPFlags
		tst.l	d0
		bpl.s	ocRemoveReq

		moveq	#1,d0			; (set to "retry")

	IFNE	DISKINSERTED-$8000
	FAIL	"DISKINSERTED not bit 15, recode"
	ENDC
		btst.l	#15,d1
		bne.s	ocRemoveReq

		;--	this must be DISKREMOVED
		bsr	RemoveAlteredDisks
		bra.s	ocSysReq

ocRemoveReq:
		move.l	d0,-(a7)
		move.l	ep_ReqWindow(a3),a0
		move.l	rl_IntuiBase(a5),a6
		CALLLVO	FreeSysRequest
		move.l	(a7)+,d0

ocSatisfiedReq:
		tst.l	d0
		beq.s	ocRestoreCD

		subq.l	#2,d0			; cmp.l	#2,d0
		bne.s	ocCheckCancelForever

		;-- remove all AttemptedVol entries
		move.l	ep_AttemptedVolList(a3),d2
ocRemoveAll:
		move.l	d2,a4
		move.l	(a4),d2
		beq	ocNextVolume

		bsr	FreeAV
		bra.s	ocRemoveAll


ocCheckCancelForever:
		subq	#1,d0			; cmp.l	#3,d0
		bne.s	ocRetry

		;-- store name on rl_CancelledForever list
		;--	find name length
		move.l	op_OpenName(a2),a0
		moveq	#-1,d0
occcfLoop1:
		tst.b	(a0)+
		dbeq	d0,occcfLoop1

		neg.l	d0

		;--	allocate memory for node
		add.w	#LN_SIZE,d0
		moveq	#0,d1
		move.l	op_A6(a2),a6	; restore SysBase
		CALLLVO	AllocMem
		tst.l	d0
		beq.s	ocRestoreCD

		;--	copy name into node
		move.l	op_OpenName(a2),a0
		move.l	d0,a1
		lea	LN_SIZE(a1),a1
		move.l	a1,LN_NAME-LN_SIZE(a1)
occcfLoop2:
		move.b	(a0)+,(a1)+
		bne.s	occcfLoop2

		;--	add node to list
		lea	rl_CancelledForever(a5),a0
		move.l	d0,a1
		CALLLVO	AddTail

		bra.s	ocRestoreCD


ocRetry:
		bsr	RemoveAlteredDisks
		bra	ocNextVolume



		;-- restore the current directory
ocRestoreCD:
		move.l	ep_OldDir(a3),d1
		move.l	(a5),a6			; rl_DosBase
		CALLLVO	CurrentDir

		;-- empty the AttemptedVolList
		move.l	ep_AttemptedVolList(a3),d2
ocUnLockLoop:
		move.l	d2,a4
		move.l	(a4),d2
		beq.s	ocResult

		;--	free the AttemptedVol entry
ocFreeAV:
		bsr	FreeAV
		bra.s	ocUnLockLoop


ocResult:
		;-- turn opens back on
		move.l	op_A6(a2),a6	; restore SysBase
		FORBID

		;-- take us off the naming list
		move.l	a3,a1
		CALLLVO	Remove

		PERMIT

		;-- now wake everyone else up
		move.l	ep_PreventList(a3),d2

		;-- I do something ugly (but ever so slightly legal) here:
		;   I never Remove the node off of our list.  Why?  because
		;   I will never reaccess either the node or the list.
		;   <poof...>
ocaLoop:
		move.l	d2,a1
		move.l	(a1),d2
		beq.s	ocaEnd

		move.l	ep_Port+MP_SIGTASK(a1),a1
		moveq	#SIGF_SINGLE,d0
		CALLLVO	Signal

		bra.s	ocaLoop

ocaEnd:
		;-- give the extended memory back
		move.l	ep_Result(a3),d2
		move.l	a3,a1
		move.l	#ExtendedParms_SIZEOF,d0
		CALLLVO	FreeMem

		move.l	d2,d0
ocRestore:
		movem.l	op_SaveRegs(a2),OP_SAVEREGS
		unlk	a2
		rts

ocFail:
		move.l	sp_Failure(a4),d0
		bra.s	ocRestore


;------	OriginalOpen ( openParms:a2, extraParms:a3, ramlib:a5, execbase:a6 )
;
;	this routine does not return a value: callers use the condition codes
;
OriginalOpen:
		move.l	ep_Static(a3),a0
		move.l	(a0),a0		; sp_OpenFunction
		jmp	(a0)

OldOpenLibrary:
		move.l	op_ParmRegs(a2),d0
		move.l	op_OpenName(a2),a1
		jsr	rl_OriginalExecJmp+OEJOpenLibrary(a5)
		move.l	d0,ep_Result(a3)
		bra.s	ooCheckResult

OldOpenDevice:
		movem.l	op_ParmRegs(a2),d0-d1/a1
		move.l	op_OpenName(a2),a0
		jsr	rl_OriginalExecJmp+OEJOpenDevice(a5)
		move.l	d0,ep_Result(a3)
		eori	#4,ccr		; invert the sense of the return value

ooCheckResult:
		bne.s	ooEnd

		;-- did the open fail because the dev/lib did not exist?

;------ FindExecList/FindOnList
FindExecList:
		move.l	ep_ExecList(a3),a0
FindOnList:
		move.l	op_OpenName(a2),a1
		CALLLVO	FindName

		;-- get the condition codes set right
		tst.l	d0

ooEnd:
		rts


;------	GetAV ( openParms:a2, extraParms:a3, ramlib:a5, execbase:a6 )
;
;	returns clear AttemptedVol structure in a4 & condition code
GetAV:
		;-- add this lock & volume to the list of attempts
		moveq	#AttemptedVol_SIZEOF,d0
		move.l	#MEMF_CLEAR,d1
		move.l	op_A6(a2),a6	; restore SysBase
		CALLLVO	AllocMem
		tst.l	d0
		beq.s	gavEnd

		move.l	d0,a4
		lea	ep_AttemptedVolList(a3),a0
		;--	ADDHEAD
		move.l	(a0),d0
		move.l	a4,(a0)
		movem.l	d0/a0,(a4)
		move.l	d0,a0
		move.l	a4,LN_PRED(a0)	; sets non-zero condition

gavEnd:
		rts


;------	FreeAV ( openParms:a2, attemptedVol:a4, ramlib:a5 )
;
;	remove AttemptedVol structure in a4
;
FreeAV:
		;--	REMOVE AttemptedVol entry
		move.l	(a4),a0
		move.l	LN_PRED(a4),a1
		move.l	a0,(a1)
		move.l	a1,LN_PRED(a0)

		;--	UnLock volume lock
		move.l	av_LockB(a4),d1
		beq.s	favFreeMem
		move.l	(a5),a6			; rl_DosBase
		CALLLVO	UnLock

		;--	FreeMem AttemptedVol entry
favFreeMem:
		move.l	a4,a1
		moveq	#AttemptedVol_SIZEOF,d0
		move.l	op_A6(a2),a6	; restore SysBase
		CALLLVO	FreeMem
		rts


;------	RemoveAlteredDisks
RemoveAlteredDisks:
		;-- scan AttemptedVolList
		move.l	ep_AttemptedVolList(a3),d2
radLoop:
		move.l	d2,a4
		move.l	(a4),d2
		bne.s	radCheckDismount

		rts

radCheckDismount:
		;-- scan DOS device list for volume
		move.l	op_A6(a2),a6	; restore SysBase
		FORBID
		;--	find start of list
		move.l	(a5),a0		; get DosLibrary *	; rl_DosBase
		move.l	dl_Root(a0),a0	; get RootNode *
		move.l	rn_Info(a0),d0	; get Info BPTR
		lsl.l	#2,d0
		move.l	d0,a0
		move.l	di_DevInfo(a0),d0	; get Device List BPTR
radVolLoop:
		;--	check if at end of list
		beq.s	radDismounted
		lsl.l	#2,d0
		move.l	d0,a0
		;--	check for a volume in the drive
		cmp.l	#DLT_VOLUME,dl_Type(a0)	; check if volume entry
		bne.s	radVolNext
		;--	check for an active task
		move.l	dl_Task(a0),d0		; save volume task
		beq.s	radVolNext

		cmp.l	av_TaskPort(a4),d0
		bne.s	radVolNext

		PERMIT
		bra.s	radCheckAltered

radVolNext:
		move.l	(a0),d0			; get next device entry BPTR
		bne.s	radVolLoop

radDismounted:
		PERMIT

		;--	free altered AttemptedVol entry
radFreeAV:
		bsr.s	FreeAV
		bra.s	radLoop

		;--	check for altered lock
radCheckAltered:
		move.l	av_LockB(a4),d1
		beq.s	radLoop

		lsl.l	#2,d1
		move.l	d1,a0
		tst.l	fl_Access(a0)	; altered lock == 0
		bne.s	radLoop
		bra.s	radFreeAV


EndModule:
@


36.11
log
@expunge pass 2 removed because the Manx "environment" library both has
no expunge jump vector and is compiled into folks' released code.
@
text
@d2 1
a2 4
**      $Filename ramlib.asm $
**      $Release: 1.4 $
**      $Revision: 36.10 $
**      $Date: 89/09/19 16:20:16 $
a8 1
**	$Header: ramlib.asm,v 36.10 89/09/19 16:20:16 kodiak Exp $
d225 1
a225 1
RamLibName	dc.b	'ramlib.library',0
@


36.10
log
@search *all* segments for resident tag
@
text
@d4 2
a5 2
**      $Revision: 36.9 $
**      $Date: 89/09/12 11:48:20 $
d12 1
a12 1
**	$Header: ramlib.asm,v 36.9 89/09/12 11:48:20 kodiak Exp $
d373 4
a376 1
		;	    hit all subsystems
a391 2
		lea	amnqPass2(pc),a2
		bsr.s	amnqPass
d466 1
a466 1
amnqPass2:
d468 1
a468 1
		bne.s	amnqpHit
d470 2
a472 1
amnqpHit:
a487 8

amnqPass3:
		tst.w	LIB_OPENCNT(a1)
		bne.s	amnqpRts
		bset.b	#LIBB_EXP0CNT,LIB_FLAGS(a1)
		bne.s	amnqpRts
		moveq	#1,d2		; show hit in this pass
		bra.s	amnqpHit
@


36.9
log
@fix faulty search of first rom tag
@
text
@d4 2
a5 2
**      $Revision: 36.8 $
**      $Date: 89/08/07 15:59:42 $
d12 1
a12 1
**	$Header: ramlib.asm,v 36.8 89/08/07 15:59:42 kodiak Exp $
d793 1
d795 1
d797 3
a799 2
		move.l	-4(a0),d0	; length of segment (in bytes)
		sub.l	#6+RT_SIZE,d0	; subtract segment header
d801 1
a801 2
		bls.s	ocNoRamTag
		addq.l	#4,a0
d804 2
a805 2
		subq.l	#2,d0
		bls.s	ocNoRamTag
@


36.8
log
@Use new BuildEasyRequest stuff
@
text
@d4 2
a5 2
**      $Revision: 36.7 $
**      $Date: 89/08/06 19:58:06 $
d12 1
a12 1
**	$Header: ramlib.asm,v 36.7 89/08/06 19:58:06 kodiak Exp $
a795 1
		addq.l	#4,a0
d798 2
@


36.7
log
@enhance Expunge() significantly
return failure w/o prompt when out of memory when loading new lib/dev
@
text
@d4 2
a5 2
**      $Revision: 36.6 $
**      $Date: 89/07/24 17:53:26 $
d12 1
a12 1
**	$Header: ramlib.asm,v 36.6 89/07/24 17:53:26 kodiak Exp $
a35 1

a39 1

d42 2
a47 2
**	Imported Names

d77 3
a79 1
	XLVO	AutoFormatRequestArgs
d81 1
d86 3
d93 21
a113 2
; this is the stuff that must be saved every open (kept in A2)
; the offsets are actually negative (because we use LINK).
d126 1
d129 1
a129 1
; now for the real ones
d144 4
a147 7
 STRUCTURE StaticParms,0
	APTR	sp_OpenFunction
	STRUCT	sp_DirName,8
	APTR	sp_Failure

; this is stuff that is needed only if we need to initialize the lib/dev
; (kept in A3)
d155 1
a159 1
	BYTE	ep_NoMemCode
d164 13
a182 1
RL_NUMENTRIES	EQU	7
a183 13
    STRUCTURE	RamLib,0
	ULONG	rl_DosBase			; must be zero
	ULONG	rl_IntuiBase
	STRUCT	rl_OriginalExecJmp,RL_NUMENTRIES*6
	STRUCT	rl_LockList,MLH_SIZE
	STRUCT	rl_CancelledForever,MLH_SIZE
	LABEL   RamLib_SIZEOF

	IFNE	rl_DosBase
	FAIL	"recode rl_DosBase references below"
	ENDC


d185 2
d196 44
a312 1

d333 1
a333 1
		dc.b	0			; positive
a335 3
RamLibName	dc.b	'ramlib.library',0
DosLibName	dc.b	'dos.library',0
IntuiLibName	dc.b	'intuition.library',0
a336 4
RamLibID	VSTRING
		ds.w	0


d338 2
d496 3
d535 4
d630 1
a630 1

a906 2
		clr.b	av_Dismounted(a1)	; mark as still mounted

a932 11
		;-- remove/free the unused AttemptedVol entries
		move.b	#1,av_Dismounted(a4)	; mark this one for deletion
		move.l	ep_AttemptedVolList(a3),d2

ocRemDismountedLoop:
		move.l	d2,a4
		move.l	(a4),d2
		beq.s	ocCheckRequestor

		tst.b	av_Dismounted(a4)
		beq.s	ocRemDismountedLoop
a933 1
		bra.s	ocRemDismountedLoop
d952 2
a953 5
		move.l	a2,-(a7)
		move.l	a0,d0			; Window
		move.l	#DISKREMOVED!DISKINSERTED,-(a7)
		move.l	a7,d1			; IDCMP_ptr
		move.l	ep_Static(a3),a0
d961 1
a961 1
		lea	olvTextFmt(pc),a0
d965 1
a965 1
		lea	ol0TextFmt(pc),a0
d970 1
a970 1
		lea	odTextFmt(pc),a0
d974 1
a974 2
		lea	ocGadFmt(pc),a1		; GadFmt
		move.l	a7,a2			; Args
d977 3
a979 1
		CALLLVO	AutoFormatRequestArgs
d981 5
a985 2
		lea	12(a7),a7
		move.l	(a7)+,a2
d987 9
d997 23
d1038 1
a1038 1
		bne.s	ocRemoveAlteredEntry
d1075 3
a1077 7
		;-- scan AttemptedVolList
ocRemoveAlteredEntry:
		move.l	ep_AttemptedVolList(a3),d2
ocRemoveAltered:
		move.l	d2,a4
		move.l	(a4),d2
		beq	ocNextVolume
a1078 2
		;--	guess: mark volume as dismounted
		move.b	#1,av_Dismounted(a4)
a1079 3
		;--	check for altered lock
		move.l	av_LockB(a4),d1
		beq.s	ocRemoveAltered
a1080 11
		;--	remove altered directory from AttemptedVolList
		lsl.l	#2,d1
		move.l	d1,a0
		tst.l	fl_Access(a0)	; altered lock == 0
		bne.s	ocRemoveAltered

		;--	free altered AttemptedVol entry
		bsr.s	FreeAV
		bra.s	ocRemoveAltered


d1087 1
a1087 1
		;-- unlock all locks on the AttemptedVolList
a1093 6
		;--	unlock
		move.l	av_LockB(a4),d1
		beq.s	ocFreeAV
		move.l	(a5),a6			; rl_DosBase
		CALLLVO	UnLock

d1096 1
a1096 1
		bsr.s	FreeAV
a1098 6
FreeAV:
		;--	REMOVE AttemptedVol entry
		move.l	(a4),a0
		move.l	LN_PRED(a4),a1
		move.l	a0,(a1)
		move.l	a1,LN_PRED(a0)
a1099 8
		;--	FreeMem AttemptedVol entry
		move.l	a4,a1
		moveq	#AttemptedVol_SIZEOF,d0
		move.l	op_A6(a2),a6	; restore SysBase
		CALLLVO	FreeMem
		rts


d1147 1
a1147 1
;	GetAV ( openParms:a2, extraParms:a3, ramlib:a5, execbase:a6 )
d1149 1
a1149 24
;	returns clear AttemptedVol structure in a4 & condition code
GetAV:
		;-- add this lock & volume to the list of attempts
		moveq	#AttemptedVol_SIZEOF,d0
		move.l	#MEMF_CLEAR,d1
		move.l	op_A6(a2),a6	; restore SysBase
		CALLLVO	AllocMem
		tst.l	d0
		beq.s	gavEnd

		move.l	d0,a4
		lea	ep_AttemptedVolList(a3),a0
		;--	ADDHEAD
		move.l	(a0),d0
		move.l	a4,(a0)
		movem.l	d0/a0,(a4)
		move.l	d0,a0
		move.l	a4,LN_PRED(a0)	; sets non-zero condition

gavEnd:
		rts


;	OriginalOpen ( openParms:a2, extraParms:a3, ramlib:a5, execbase:a6 )
a1150 2
;	this routine does not return a value: callers use the condition codes

d1153 1
a1153 1
		move.l	(a0),a0
d1174 2
d1189 11
a1199 11
odTextFmt	dc.b	'Please insert disk with file|'
		dc.b	'devs/%s|'
		dc.b	'in any drive.',0
ol0TextFmt	dc.b	'Please insert disk with file|'
		dc.b	'libs/%s|'
		dc.b	'in any drive.',0
olvTextFmt	dc.b	'Please insert disk with file|'
		dc.b	'libs/%s|'
		dc.b	'(version %ld or greater)|'
		dc.b	'in any drive.',0
ocGadFmt	dc.b	'Retry|Retry All Disks|Cancel Forever|Cancel',0
d1201 102
a1302 1
		ds.w	0
@


36.6
log
@add "Cancel Forever" feature
@
text
@d4 2
a5 2
**      $Revision: 36.5 $
**      $Date: 89/07/24 14:28:29 $
d12 1
a12 1
**	$Header: ramlib.asm,v 36.5 89/07/24 14:28:29 kodiak Exp $
d36 6
d138 1
d281 3
a304 2
		movem.l	d2/a2,-(a7)

d306 20
a325 3
		move.l	LibList(a6),d2
		lea	_LVORemLibrary(a6),a2
		bsr.s	FreeLibs
d327 5
a331 3
		move.l	DeviceList(a6),d2
		lea	_LVORemDevice(a6),a2
		bsr.s	FreeLibs
d333 5
a337 1
		movem.l	(a7)+,d2/a2
d339 2
a340 1
		movem.l	(a7),d0-d1
d342 71
d414 1
d419 1
a419 1
		bne.s	amPermit
d421 4
a424 4
		;-- still no memory.  See if this is a dos process
		move.l	ThisTask(a6),a0
		cmp.b	#NT_PROCESS,LN_TYPE(a0)
		bne.s	amPermit
a425 4
		;--	it is.  Set result 2 to the right error value
		moveq	#ERROR_NO_FREE_STORE,d1
		move.l	d1,pr_Result2(a0)
		bra.s	amPermit
d427 1
a427 6
;	FreeLibs ( list:d2, call:a2 )
FreeLibs:
		move.l	d2,a1
		move.l	(a1),d2
		beq.s	rlRts

d429 5
a433 1
		bne.s	FreeLibs
a434 2
		jsr	(a2)
		bra.s	FreeLibs
d677 7
d778 8
a792 1
		bra.s	ocRamInitOK
a793 5
ocRamInitUnload:
		move.l	ep_Segment(a3),d1
		move.l	(a5),a6			; rl_DosBase
		CALLLVO	UnLoadSeg

d802 4
d859 2
d864 1
a864 1
		bra.s	ocNextVolume
d895 1
a895 2
		move.l	a0,d0		;	cmp.l	#-1,a0
		addq.l	#1,d0		;
@


36.5
log
@first pass w/ AutoFormatRequestArgs use
@
text
@d4 2
a5 2
**      $Revision: 36.4 $
**      $Date: 89/06/05 14:20:29 $
d12 1
a12 1
**	$Header: ramlib.asm,v 36.4 89/06/05 14:20:29 kodiak Exp $
d148 2
a149 1
	STRUCT	rl_LockList,LH_SIZE		; must be after DevStatic
d231 3
d763 1
a763 1
		beq.s	ocGetWindow
d770 9
d826 1
a826 1
		bne.s	ocRemoveAlteredEntry
d835 1
a835 1
		bsr.s	FreeAV
d839 39
a911 1

d1055 1
a1055 2
odTextFmt	dc.b	'Looking for system device.|'
		dc.b	'Please insert disk with file|'
d1058 1
a1058 2
ol0TextFmt	dc.b	'Looking for system library.|'
		dc.b	'Please insert disk with file|'
d1061 1
a1061 2
olvTextFmt	dc.b	'Looking for system library.|'
		dc.b	'Please insert disk with file|'
d1065 1
a1065 1
ocGadFmt	dc.b	'Retry|Retry All|Cancel',0
@


36.4
log
@resident pri -100 for RTF_AFTERDOS
@
text
@d4 2
a5 2
**      $Revision: 36.3 $
**      $Date: 89/04/18 16:08:53 $
d12 1
a12 1
**	$Header: ramlib.asm,v 36.3 89/04/18 16:08:53 kodiak Exp $
d73 1
a73 1
	XLVO	AutoRequest
d772 1
a772 1
		beq.s	ocRestoreCD	; no interaction if == -1
d775 27
a801 8
		movem.l	d3/a2/a3,-(a7)
		lea	IARBody(pc),a1
		lea	IARPText(pc),a2
		lea	IARNText(pc),a3
		move.l	#DISKREMOVED!DISKINSERTED,d0
		moveq	#0,d1
		move.l	#IARWIDTH,d2
		moveq	#IARHEIGHT,d3
d803 6
a808 2
		CALLLVO	AutoRequest
		movem.l	(a7)+,d3/a2/a3
d812 14
d827 1
d1004 14
a1017 22
IARBody:
		dc.b	AUTOFRONTPEN,AUTOBACKPEN,AUTODRAWMODE,0
		dc.w	AUTOLEFTEDGE+10,AUTOTOPEDGE+2
		dc.l	AUTOITEXTFONT,IARTBody1,IARBody2
IARBody2	dc.b	AUTOFRONTPEN,AUTOBACKPEN,AUTODRAWMODE,0
		dc.w	AUTOLEFTEDGE+10,AUTOTOPEDGE+2+11
		dc.l	AUTOITEXTFONT,IARTBody2,0
IARPText:
		dc.b	AUTOFRONTPEN,AUTOBACKPEN,AUTODRAWMODE,0
		dc.w	AUTOLEFTEDGE,AUTOTOPEDGE
		dc.l	AUTOITEXTFONT,IARTPText,0
IARNText:
		dc.b	AUTOFRONTPEN,AUTOBACKPEN,AUTODRAWMODE,0
		dc.w	AUTOLEFTEDGE,AUTOTOPEDGE
		dc.l	AUTOITEXTFONT,IARTNText,0

IARTBody1	dc.b	'Could not find a device or library',0
IARTBody2	dc.b	'(this requestor will get better)',0
IARTPText	dc.b	'Retry',0
IARTNText	dc.b	'Cancel',0
IARWIDTH	EQU	320
IARHEIGHT	EQU	60
@


36.3
log
@1.  temporarily remove check for process before using dos
2.  DeviceList, not DevList, in exec
@
text
@d4 2
a5 2
**      $Revision: 36.2 $
**      $Date: 89/04/12 11:04:39 $
d12 1
a12 1
**	$Header: ramlib.asm,v 36.2 89/04/12 11:04:39 kodiak Exp $
d173 1
a173 1
		dc.b	-120			;   BYTE  RT_PRI
@


36.2
log
@defer PERMIT a little longer when locking an open of a device/library
set the condition code for AllocMem result
@
text
@d4 2
a5 2
**      $Revision: 36.1 $
**      $Date: 89/04/12 08:14:22 $
d12 1
a12 1
**	$Header: ramlib.asm,v 36.1 89/04/12 08:14:22 kodiak Exp $
d386 1
a386 1
		lea	DevList(a6),a3
d472 1
d477 1
@


36.1
log
@set RTF_AFTERDOS, priority -120
@
text
@d4 2
a5 2
**      $Revision: 36.0 $
**      $Date: 89/02/17 13:33:42 $
d12 1
a12 1
**	$Header: ramlib.asm,v 36.0 89/02/17 13:33:42 kodiak Exp $
d287 1
a549 2
		PERMIT

d555 2
d575 1
a575 1
		moveq	#0,d1		; root directory
@


36.0
log
@merged ramlib source
@
text
@d4 2
a5 2
**      $Revision: 36.2 $
**      $Date: 89/01/06 17:27:29 $
d12 1
a12 1
**	$Header$
d167 10
a176 10
		dc.w    RTC_MATCHWORD		;   UWORD RT_MATCHWORD
		dc.l    ResidentTag		;   APTR  RT_MATCHTAG
		dc.l    EndModule		;   APTR  RT_ENDSKIP
		dc.b    0			;   UBYTE RT_FLAGS
		dc.b    VERSION			;   UBYTE RT_VERSION
		dc.b    0			;   UBYTE RT_TYPE
		dc.b    0			;   BYTE  RT_PRI
		dc.l    RamLibName		;   APTR  RT_NAME
		dc.l    RamLibID		;   APTR  RT_IDSTRING
		dc.l    RamLibInit		;   APTR  RT_INIT
@
