head     36.43;
branch   ;
access   ;
symbols  V39_4:36.39 V37_157:36.39 V37_149:36.38 V37_136:36.38 V37_133:36.38 V37_110:36.38 V37_98:36.38 V37_85:36.38 V37_63:36.38 V37_36:36.38 V37_15:36.34 V37_10:36.34 V37_7:36.33 V37_2:36.33 V36_558:36.33 V36_554:36.33 V36_552:36.32 V36_549:36.32 V36_548:36.32 V36_547:36.32 V36_546:36.32 V36_545:36.32 V36_544:36.32 V36_543:36.32 V36_542:36.31 V36_540:36.30 V36_539:36.30 V36_538:36.30 V36_537:36.30 V36_536:36.30 V36_529:36.29 V36_527:36.29 V36_525:36.28 V36_524:36.26 V36_523:36.26 V36_522:36.24 V36_521:36.23 V36_520:36.23 V36_519:36.22 V36_518:36.22 V36_495:36.22 V36_491:36.22 V36_486:36.22 V36_482:36.22 V36_476:36.22 V36_471:36.22 V36_465:36.20 V36_463:36.20 V36_461:36.20 V36_460:36.20 V36_453:36.19 V36_447:36.19 V36_442:36.19 V36_429:36.18 V36_423:36.18 V36_413:36.18 V36_394:36.16 V36_387:36.16 V36_382:36.16 V36_381:36.16 V36_379:36.15 V36_373:36.15 V36_367:36.15 V36_361:36.15 V36_359:36.15 V36_357:36.15 V36_353:36.15 V36_346:36.15 V36_343:36.15 V36_338:36.15 V36_332:36.14 V36_327:36.14 V36_321:36.14 V36_319:36.14 V36_318:36.13 V36_316:36.12 V36_313:36.12 V36_311:36.12 V36_310:36.12 V36_300:36.12 V36_299:36.12 V36_297:36.12 V36_295:36.12 V36_278:36.12 V36_274:36.12 V36_221:36.10 V36_205:36.9 V36_171:36.8 V36_167:36.7 V36_165:36.6 V36_153:36.6 V36_146:36.5 V36_140:36.5 V36_129:36.3 V36_113:36.2 V36_56:36.1 V36_53:36.1 V36_51:36.1 V36_45:36.1 L36_42:36.1;
locks    ; strict;
comment  @*   @;


36.43
date     92.06.16.10.44.16;  author darren;  state Exp;
branches ;
next     36.42;

36.42
date     92.05.27.15.48.51;  author darren;  state Exp;
branches ;
next     36.41;

36.41
date     92.05.19.13.57.06;  author darren;  state Exp;
branches ;
next     36.40;

36.40
date     92.05.19.12.29.14;  author darren;  state Exp;
branches ;
next     36.39;

36.39
date     91.05.22.13.23.31;  author darren;  state Exp;
branches ;
next     36.38;

36.38
date     91.02.14.14.56.04;  author darren;  state Exp;
branches ;
next     36.37;

36.37
date     91.02.12.09.32.28;  author darren;  state Exp;
branches ;
next     36.36;

36.36
date     91.02.08.19.49.53;  author darren;  state Exp;
branches ;
next     36.35;

36.35
date     91.02.04.14.27.35;  author darren;  state Exp;
branches ;
next     36.34;

36.34
date     91.01.18.14.26.00;  author darren;  state Exp;
branches ;
next     36.33;

36.33
date     90.12.18.10.41.35;  author darren;  state Exp;
branches ;
next     36.32;

36.32
date     90.11.28.19.12.14;  author darren;  state Exp;
branches ;
next     36.31;

36.31
date     90.11.20.18.47.29;  author darren;  state Exp;
branches ;
next     36.30;

36.30
date     90.11.01.11.21.45;  author darren;  state Exp;
branches ;
next     36.29;

36.29
date     90.10.11.15.28.29;  author darren;  state Exp;
branches ;
next     36.28;

36.28
date     90.10.11.14.17.55;  author darren;  state Exp;
branches ;
next     36.27;

36.27
date     90.10.11.13.16.33;  author darren;  state Exp;
branches ;
next     36.26;

36.26
date     90.09.13.18.11.37;  author darren;  state Exp;
branches ;
next     36.25;

36.25
date     90.09.13.18.09.43;  author darren;  state Exp;
branches ;
next     36.24;

36.24
date     90.08.13.11.48.36;  author darren;  state Exp;
branches ;
next     36.23;

36.23
date     90.07.26.11.05.43;  author darren;  state Exp;
branches ;
next     36.22;

36.22
date     90.05.16.11.44.03;  author kodiak;  state Exp;
branches ;
next     36.21;

36.21
date     90.05.16.11.34.48;  author kodiak;  state Exp;
branches ;
next     36.20;

36.20
date     90.05.11.11.41.58;  author kodiak;  state Exp;
branches ;
next     36.19;

36.19
date     90.04.20.09.45.33;  author kodiak;  state Exp;
branches ;
next     36.18;

36.18
date     90.04.16.18.22.55;  author kodiak;  state Exp;
branches ;
next     36.17;

36.17
date     90.04.13.13.32.40;  author kodiak;  state Exp;
branches ;
next     36.16;

36.16
date     90.04.02.10.47.25;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     90.02.21.14.04.17;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     89.12.19.13.27.41;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     89.12.19.11.03.25;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     89.12.02.11.37.00;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     89.11.27.12.50.45;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     89.11.07.12.57.41;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     89.11.04.16.03.37;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     89.09.29.12.05.25;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     89.09.15.15.41.16;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     89.07.10.18.17.49;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.07.05.15.18.16;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     89.06.30.18.04.06;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     89.06.28.19.14.24;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     89.06.28.12.34.48;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     88.09.19.10.15.56;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     88.09.06.19.52.03;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


36.43
log
@Remove setting/clearing of cursor Q & N draw flags.
@
text
@**
**	$Id: open.asm,v 36.42 92/05/27 15:48:51 darren Exp Locker: darren $
**
**      open a console unit
**
**      (C) Copyright 1985,1987,1989,1990 Commodore-Amiga, Inc.
**          All Rights Reserved
**
	SECTION	console

**	Includes

	INCLUDE	"cddata.i"

	INCLUDE	"exec/errors.i"
	INCLUDE	"exec/initializers.i"
	INCLUDE	"exec/memory.i"
	INCLUDE	"exec/execbase.i"
	INCLUDE	"exec/ables.i"

	INCLUDE	"devices/input.i"
	INCLUDE	"intuition/intuitionbase.i"
	INCLUDE "internal/librarytags.i"
	INCLUDE	"debug.i"

**	Exports

	XDEF	CDOpen
	XDEF	CDClose
	XDEF	FreeBuffer


**	Imports

	XLVO	AddHead			; Exec
	XLVO	AllocMem		;
	XLVO	DoIO			;
	XLVO	FreeMem			;
	XLVO	InitStruct		;
	XLVO	ObtainSemaphore		;
	XLVO	OpenLibrary		;
	XLVO	TaggedOpenLibrary	; V39
	XLVO	CloseLibrary		;
	XLVO	ReleaseSemaphore	;
	XLVO	Remove			;
	XLVO	Permit			;

	XLVO	DisposeRegion		; Graphics
	XLVO	NewRegion		;

	XLVO	LockIBase		; Intuition
	XLVO	UnlockIBase		;

	XLVO	AskKeyMapDefault	; Keymap

	XREF	CDName

	XREF	WriteReset

	XREF	RefreshDamage		;refresh.asm

	XREF	LockDRPort		;able
	XREF	UnLockRPort

	XREF	ReSizeUnit		;wreset


**	Assumptions

	IFNE	CONU_LIBRARY+1
	FAIL	"constant CONU_LIBRARY not -1"
	ENDC

	IFNE	CONU_STANDARD
	FAIL	"constant CONU_STANDARD not 0"
	ENDC

	IFNE	CONU_CHARMAP&1-1
	FAIL	"low bit not set in constant CONU_CHARMAP"
	ENDC

	IFNE	CONU_SNIPMAP&1-1
	FAIL	"low bit not set in constant CONU_SNIPMAP"
	ENDC


******* console.device/OpenDevice **********************************************
*
*    NAME
*	OpenDevice -- a request to open a Console device
*
*    SYNOPSIS
*	error = OpenDevice("console.device", unit, IOStdReq, flags )
*	d0		    a0               d0    a1        d1
*
*    FUNCTION
*	The open routine grants access to a device.  There are two
*	fields in the IOStdReq block that will be filled in: the
*	io_Device field and possibly the io_Unit field.
*
*	As of (V37) the flags field may also be filled in with
*	a value described below (see conunit.h or conunit.i).
*
*	This open command differs from most other device open commands
*	in that it requires some information to be supplied in the
*	io_Data field of the IOStdReq block.  This initialization
*	information supplies the window that is used by the console
*	device for output.
*
*	The unit number that is a standard parameter for an open call
*	is used specially by this device.  See conunit.h, or conunit.i
*	for defined valid unit numbers.
*
*
*	unit number: -1 (CONU_LIBRARY)
*
*		Used to get a pointer to the device library vector
*	which is returned in the io_Device field of the IOStdReq
*	block.  No actual console is opened.  You must still close
*	the device when you are done with it.
*
*	unit number: 0 (CONU_STANDARD)
*
*		A unit number of zero binds the supplied window to
*	a unique console.  Sharing a console must be done at a level
*	higher than the device.
*
*
*	unit number: 1 (CONU_CHARMAP) (V36)
*
*		A unit number of one is similar to a unit number of
*	zero, but a console map is also created, and maintained by
*	the console.device.  The character map is used by the console
*	device to restore obscured portions of windows which are
*	revealed, and to redraw a window after a resize.  Character
*	mapped console.device windows must be opened as SIMPLE REFRESH
*	windows.
*
*		The character map is currently for internal use
*	only, and is not accessible by the programmer.  The character
*	map stores characters, attributes, and style information for
*	each character written with the CMD_WRITE command. 
*
*	unit number: 3 (CONU_SNIPMAP) (V36)
*
*		A unit number of three is similar to a unit number
*	of one, but also gives the user the ability to highlight
*	text with the mouse which can be copied by pressing
*	RIGHT AMIGA C.  See NOTES below.
*
*
*	flags: 0 (CONFLAG_DEFAULT)
*
*		The flags field should be set to 0 under V34, or less.
*
*	flags: 1 (CONFLAG_NODRAW_ON_NEWSIZE) (V37)
*
*		The flags field can be set to 0, or 1 as of V37.  The
*	flags field is ignored under V36, so can be set, though it
*	will have no effect.  When set to 1, it means that you don't
*	want the console.device to redraw the window when the window
*	size is changed (assuming you have opened the console.device
*	with a character map - unit numbers 1, or 3).  This flag is
*	ignored if you have opened a console.device with a unit
*	number of 0.  Typically you would use this flag when you
*	want to perform your own window refresh on a newsize, and
*	you want the benefits of a character mapped console.
*	
*    IO REQUEST
*	io_Data		struct Window *window
*			This is the window that will be used for this
*			console.  It must be supplied if the unit in
*			the OpenDevice call is 0 (see above).  The
*			RPort of this window is potentially in use by
*			the console whenever there is an outstanding
*			write command.
*    INPUTS
*	"console.device" - a pointer to the name of the device to be opened.
*	unit - the unit number to open on that device.
*	IOStdReq - a pointer to a standard request block
*	0 - a flag field of zero (CONFLAG_DEFAULT)
*	1 - a flag field of one  (CONFLAG_NODRAW_ON_NEWSIZE) (V37)
*
*    RESULTS
*	error - zero if successful, else an error is returned.
*	
*    NOTES
*	As noted above, opening the console.device with a unit number of 3
*	allows the user to drag select text, and copy the selection with
*	RIGHT AMIGA C.  The snip is copied to a private buffered managed
*	by the console.device (as of V36).  The snip can be copied to
*	any console.device window unless you are running a console to
*	clipboard utility such as that provided with V37.
*
*	The user pastes text into console.device windows by pressing
*	RIGHT AMIGA V.  Both RIGHT AMIGA V, and RIGHT AMIGA C are swallowed
*	by the console.device (unless you have asked for key presses as
*	RAW INPUT EVENTS).  Text pasted in this way appears in the
*	console read stream as if the user had typed all of the characters
*	manually.  Additional input (e.g., user input, RAW INPUT EVENTS)
*	are queued up after pastes.  Pastes can theoretically be quite
*	large, though they are no larger than the amount of text
*	which is visible in a console.device window.
*
*	When running the console to clipboard utility, text snips
*	are copied to the clipboard.device, and RIGHT AMIGA V key
*	presses are broadcast as an escape sequence as part of the 
*	console.device read stream ("<CSI>0 v" - $9B,$30,$20,$76).
*
*	It is left up to the application to decide what to do when this
*	escape sequence is received.  Ideally the application
*	will read the contents of the clipboard, and paste the text
*	by using successive writes to the console.device.
*
*	Because the contents of the clipboard.device can be quite
*	large, your program should limit the size of writes to something
*	reasonable (e.g., no more than 1K characters per CMD_WRITE, and
*	ideally no more than 256 characters per write).  Your program
*	should continue to read events from the console.device looking
*	for user input, and possibly RAW INPUT EVENTS.  How you decide
*	to deal with these events is left up to the application.
*
*	If you are using a character mapped console you should receive
*	Intuition events as RAW INPUT EVENTS from the console.device.
*	By doing this you will hear about these events after the console
*	device does.  This allows the console.device to deal with events
*	such as window resizing, and refresh before your application.
*
*    BUGS
*
*    SEE ALSO
*	exec/io.h, intuition/intuition.h
*
********************************************************************************

CDOpen:
		movem.l d2-d4/a2-a4,-(sp)
		move.l	d0,d2			; cache unit #
		move.l	a1,a3			; cache iorequest
		move.l	d1,d4			; cache flags field


;-- Not needed, we dont expunge!
;--
;--		bclr	#LIBB_DELEXP,LIB_FLAGS(a6)

		tst.w	LIB_OPENCNT(a6)
		bne.s	bumpOpen
		
	;-- better open Intuition now
	;-- 
	;-- if opening Intuition breaks Forbid(), we should be
	;-- fine since the next task would come along right behind
	;-- us only to find that LIB_OPENCNT is 0, and also try
	;-- to open Intuition.  At worst intuition is opened
	;-- twice which causes zilch problems for us.


		moveq	#OLTAG_INTUITION,d0
		LINKEXE	TaggedOpenLibrary
		move.l	d0,cd_IntuitionLib(a6)
                beq	openILError


	;-- Set up cd_ActiveWindow() value with currently active
	;-- window (0 isn't good enough for an initial value).

		;--	acquire active window
		move.l	a6,a2
		move.l	cd_IntuitionLib(a6),a6
		moveq	#0,d0
		CALLLVO	LockIBase
		move.l	ib_ActiveWindow(a6),cd_ActiveWindow(a2)
		move.l	d0,a0
		CALLLVO	UnlockIBase
		move.l	a2,a6

bumpOpen:
		addq.w	#1,LIB_OPENCNT(a6)		

	;-- check for use as a library only
	;-- unit will be equal to -1

		cmpi.l	#CONU_LIBRARY,d2
		bne.s	regularOpen
		move.l	d2,IO_UNIT(a3)
		bra	opendone

regularOpen:

	;-- screen for bogus unit #'s
	;-- as of V36, this leaves 0, 1, and 3 as good numbers

		cmpi.l	#CONU_SNIPMAP,d2
		bhi	openError

		cmpi.l	#2,d2		;grr - no good constant available
		beq	openError

	;-- make sure we have somekind of pointer to a window

		tst.l	IO_DATA(a3)
		beq	openError

	;------ try to allocate a unit
		move.l	#cu_SIZE,d0
		move.l	#MEMF_PUBLIC!MEMF_CLEAR,d1
		LINKEXE AllocMem
		tst.l	d0
		beq	openError
		move.l	d0,a2

	;------ initialize the unit
		lea	unitInitData(pc),a1
		move.l	#cu_SIZE,d0
		LINKEXE InitStruct

		move.l	d2,cu_DevUnit(a2)

		;-- applicable to V36 unit #'s for console map
		;-- 1 means no redraw on new size

		move.b	d4,cu_SpecialModes(a2)


	;------ get ClipRegion
		LINKGFX	NewRegion
		move.l	d0,cu_ClipRegion(a2)
		beq	openCRErr

	;------ initialize the unit command queue
		lea     MP_MSGLIST(a2),a0
		NEWLIST a0

	;------ get window parameter
		move.l	IO_DATA(a3),cu_Window(a2)

	;------ input key map
		LINKKEY	AskKeyMapDefault
		move.l	d0,a0
		lea	cu_KeyMapStruct(a2),a1
		moveq	#(km_SIZEOF/4)-1,d0
copyKeyMapStruct:
		move.l	(a0)+,(a1)+
		dbf	d0,copyKeyMapStruct
		
	;-- get a TmpRas and AreaPtrn memory
	;-- if this if the first window using the console.device
	;
	;-- Note that Forbid() could have been broken above
	;-- if we opened Intuition.  We are back in Forbid now to avoid
	;-- racing ahead of our buffer allocation, and to
	;-- safely determine initial cursor state (active/inactive)
	;-- for this window.
	;
	;-- Note that we'll look at console's idea of whats currently
	;-- active, and we'll get activation state changes later via
	;-- the console input handler.
	;

		tst.l	cd_WindowCount(a6)
		bne.s	addunit

		move.l	#4096,d0		; 1Kx32 bits
		move.l	d0,tr_Size+cd_TmpRas(a6)
		addq	#4,d0			; 2 words for AreaPtrn
		moveq	#MEMF_CHIP,d1
		LINKEXE	AllocMem
		move.l	d0,cd_AreaPtrn(a6)
		beq	openTmpError

		move.b	#1,cd_RastPort+rp_AreaPtSz(a6)
		addq	#4,d0
		move.l	d0,tr_RasPtr+cd_TmpRas(a6)
		lea	cd_TmpRas(a6),a0
		move.l	a0,rp_TmpRas+cd_RastPort(a6)

addunit:
	;-- increment open window count NOW!

		addq.l	#1,cd_WindowCount(a6)


	;-- Set initial cursor state, initialize unit struct, and 
	;-- add to list of console units.

		move.l	cd_ActiveWindow(a6),d0
		beq.s	notactive
		cmp.l	cu_Window(a2),d0
		bne.s	notactive
isActive:
		move.l	a2,cd_Active(a6)
		bset	#CUB_ISACTIVE,cu_States(a2)
notactive:

	;-- stash unit pointer in io request

		move.l	a2,IO_UNIT(a3)

	;-- set/reset console unit now, before adding it the list
	;-- of console units.
	;
	;-- WriteReset() does rendering, and will obtain layer's
	;-- locks while examining the window structure (e.g., size,
	;-- font, etc.)
	;
	;-- We can't safely have any layer's locks inside of the
	;-- exclusive semaphore below, or we can dead-lock because
	;-- Intuition may own LockLayerInfo, or a lock this
	;-- window's layer.
	;

		bsr     WriteReset		;can break Forbid()
		beq.s	nomap_fail

	;
	;-- Add to list of console units; semaphore is exclusive.
	;
	;-- The console inputhandler, and console task can look
	;-- at this list (shared semaphore), but neither can look
	;-- at the list while adding, or removing units from the
	;-- list (e.g., at OpenDevice time, and CloseDevice time).
	;


		lea	cd_USemaphore(a6),a0
		LINKEXE	ObtainSemaphore

		lea     cd_UHead(a6),a0
		move.l  a2,a1
		ADDHEAD

		lea	cd_USemaphore(a6),a0
		LINKEXE	ReleaseSemaphore

	;-- refresh cursor, or any damage that might have happened
	;-- after I inited the console unit, but before it was added
	;-- to the unit list

		bsr	LockDRPort

	;-- obtain activation state - layers are locked, no more changes
	;-- in activation can occur.
	;
	;-- cd_Active might change on us if:
	;
	;-- Closing an active console window (in which case its not this
	;-- one, and cd_Active won't match this unit anyway).
	;
	;-- If an input event occurs before we make the test, in which case
	;
	;    cd_Active is going to change soon - we'll catch it later, and
	;    can't actually render until we UnLockRPort, or
	;
	;    cd_Active has been changed by the inputhandler, in which
	;    case our test is in-sync with reality (at worst we handle
	;    the event later, and redraw yet one more time).
	;
	;    The test is atomic
	;


		bclr	#CUB_ISACTIVE,cu_States(a2)
		cmp.l	cd_Active(a6),a2		;atomic test
		bne.s	notCUActive
		bset	#CUB_ISACTIVE,cu_States(a2)

notCUActive:

	;
	;-- recalc window borders, and redraw everything, which isn't
	;-- much at this point
	;
		bsr	ReSizeUnit
		bsr	UnLockRPort

	;--
	;-- GFA BASIC KLUDGE!!!
	;--
	;-- Assumes that a0 contains windowptr on exit.

		movea.l	IO_DATA(a3),a0
	;--
	;-- Final exit point
	;--

opendone:
		moveq	#0,d0

		movem.l (sp)+,d2-d4/a2-a4
		rts

	;-- Allocation of the character map must have failed; cleanup

nomap_fail:

		;-- free TmpRas and AreaPtrn memory
		subq.l	#1,cd_WindowCount(a6)	;atomic
		bne.s	usingtmpras

		movea.l	cd_AreaPtrn(a6),a1
		move.l	#4100,d0		; 1Kx32 + 4
		LINKEXE	FreeMem

usingtmpras:
		cmp.l	cd_Active(a6),a2	;still the active window?
		bne.s	notcdactive
		clr.l	cd_Active(a6)		;no console window active for now

notcdactive:
	;-- free up memory so far

openTmpError:

		move.l	cu_ClipRegion(a2),a0
		LINKGFX	DisposeRegion


	;-- Release memory for console unit structure

openCRErr:
		move.l	a2,a1
		move.l	#cu_SIZE,d0
		LINKEXE FreeMem


	;-- Error, decrement usage counter

openError:
		subq.w	#1,LIB_OPENCNT(a6)

	;-- Set error, and clear IO_DEVICE field

openILError:
		moveq	#IOERR_OPENFAIL,d0
		clr.l	IO_DEVICE(a3)
		move.b	d0,IO_ERROR(a3)
		bra.s	opendone


unitInitData:
	;------ initialize the unit command queue
	    INITLONG	LN_NAME,CDName
	    INITBYTE	LN_TYPE,NT_MSGPORT
	    INITLONG	LN_NAME,CDName
	    INITBYTE	MP_MSGLIST+LH_TYPE,NT_MESSAGE

	    INITBYTE	cu_RPNestCnt,-1		; initially "dropped"
	    INITBYTE	cu_CDNestCnt,-1		; initially enabled (and hide)
*	    INITBYTE	cu_CursorFlags,CUF_CURSQDRAW!CUF_CURSNDRAW
*	    INITBYTE    cu_IHead,0		;head of token list (input)
*	    INITBYTE	cu_ITail,0		;tail of token list (task)
	    INITBYTE	cu_States,CUF_FIRSTTIME	;First time through!

		dc.w	0


*****i* console.device/CloseDevice ************************************
*
*    NAME
*       Close -- close the console device
*
*    SYNOPSIS
*       CloseDevice(IOStdReq)
*
*    FUNCTION
*	This function closes software access to the console device,
*	and informs the system that access to this device/unit which was
*	previously opened has been concluded.  The device may perform
*	certain house-cleaning	operations.  The I/O request structure
*	is now free to be recycled.
*
*    INPUTS
*	IOStdReq - pointer to an IOStdReq structure, set by OpenDevice
*
*    BUGS
*
*    SEE ALSO
*	console.device/function/OpenDevice, exec/io.h
*
********************************************************************************


*------ console.device/Close -----------------------------------------
*
*   NAME
*	Close - terminate access to a device
*
*   SYNOPSIS
*	Close(iORequest), consoleDev
*	      a1	  a6
*
*   FUNCTION
*	The close routine notifies a device that it will no longer
*	be using the device.  The driver will clear the IO_DEVICE
*	and IO_UNIT entries in the iORequest structure.
*
*	The open count on the device will be decremented, and if it
*	falls to zero and an Expunge is pending, the Expunge will
*	take place.
*
*---------------------------------------------------------------------
CDClose:
		movem.l	a2/a3,-(sp)
		move.l	a1,a3		    ; save I/O Request
		move.l	IO_UNIT(a3),a2
		cmpa	#-1,a2		; check if open only for library
		beq	closeLibrary


		;-- ensure not highlighting here
		btst	#CUB_SELECTED,cu_Flags(a2)
		beq.s	closeUnlink

		and.b	#CDS_SELECTMASK,cd_SelectFlags(a6)
		clr.l	cd_SelectedUnit(a6)

		;-- unlink from the device unit list
closeUnlink:
		lea	cd_USemaphore(a6),a0
		LINKEXE	ObtainSemaphore

		move.l	a2,a1
		lea	cd_UHead(a6),a0
		LINKEXE Remove
		cmp.l	cd_Active(a6),a2
		bne.s	closeUnit
		clr.l	cd_Active(a6)

closeUnit:
		;-- free TmpRas and AreaPtrn memory
		subq.l	#1,cd_WindowCount(a6)
		bne.s	leaveTmpRas		

		movea.l	cd_AreaPtrn(a6),a1
		move.l	#4100,d0		; 1Kx32 + 4
		LINKEXE	FreeMem

leaveTmpRas:

		lea	cd_USemaphore(a6),a0
		LINKEXE	ReleaseSemaphore

	    ;-- do unit specific close stuff
		move.l	cu_ClipRegion(a2),a0
		LINKGFX	DisposeRegion

		bsr.s	FreeBuffer

		move.l	a2,a1
		move.l	#cu_SIZE,d0
		LINKEXE FreeMem

	    ;-- do generic close stuff
		move.l	a3,a1
closeLibrary:
		movem.l	(sp)+,a2/a3

	    ;-- clear out the pointers
		moveq	#0,d0
		move.l	d0,IO_UNIT(a1)
		move.l	d0,IO_DEVICE(a1)

	    ;-- check if this is the last close

		subq.w	#1,LIB_OPENCNT(a6)
		bne.s	closeRts

		move.l	cd_IntuitionLib(a6),a1
		LINKEXE	CloseLibrary

closeRts:
		rts


FreeBuffer:
		move.l	cu_CM+cm_AllocSize(a2),d0
		beq.s	fbRts
		move.l	cu_CM+cm_AllocBuffer(a2),d1
		beq.s	fbClearSize
		move.l	d1,a1
		move.l	a6,-(a7)
		move.l	cd_ExecLib(a6),a6
		CALLLVO	FreeMem
		move.l	(a7)+,a6

fbClearSize:
		clr.l	cu_CM+cm_AllocSize(a2)

fbRts:
		rts


	END
@


36.42
log
@Bail out if wreset fails due to lack of memory (only if asking for
character mapped console, but very common for shell windows).
Remove extra Forbid/Permit code - we are already in Forbid()/Permit()
as part of OpenDevice().  Saves ROM space for this addition.
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.41 92/05/19 13:57:06 darren Exp Locker: darren $
d472 1
a472 2
	;-- much at this point (plus turn cursor on - first time it will
	;-- actually be drawn)
a473 7
	;-- The Cursor Never Draw flag might already be cleared if
	;-- the initial window size was too small to render in, in
	;-- which case the never draw hack is turned off for the life
	;-- of this console window.
	;

		bclr	#CUB_CURSNDRAW,cu_CursorFlags(a2)
d550 1
a550 1
	    INITBYTE	cu_CursorFlags,CUF_CURSQDRAW!CUF_CURSNDRAW
@


36.41
log
@Use tagged open library to save ROM space
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.40 92/05/19 12:29:14 darren Exp Locker: darren $
d351 1
a351 1
	;-- if we opened Intuition.  Forbid now to avoid
a360 3
		move.l	cd_ExecLib(a6),a4
		FORBID	a4,NOFETCH

a395 2
		PERMIT	a4,NOFETCH

d409 1
a409 1
	;-- Intuition may own LockLayerInfo, or a lock our this
d413 2
a414 1
		bsr     WriteReset
d501 18
a521 2

		PERMIT	a4,NOFETCH
@


36.40
log
@Remove initialization of console map semaphore
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.39 91/05/22 13:23:31 darren Exp Locker: darren $
d23 1
a23 1

d42 1
d259 2
a260 3
		lea	ILName(pc),a1
		moveq	#00,d0
		LINKEXE	OpenLibrary
a552 2
ILName		dc.b	'intuition.library',0
		dc.w	0
@


36.39
log
@Rework of OpenDevice() code to avoid dead-lock situation.  OpenDevice
a console, grab menu button, pull-down WB menus after window is
opened by an application, but before console finishes in OpenDevice.
If an input event comes down the chain, console's input handler could
deadlock (OpenDevice is unable to get LockLayerInfo, and console's
inputhandler is unable to get the unit semaphore).
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.38 91/02/14 14:56:04 darren Exp Locker: darren $
a56 2
	XREF	InitMapSemaphore

a333 3

	;--	initialize character map semaphore
		bsr	InitMapSemaphore
@


36.38
log
@Autodoc stuff
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.37 91/02/12 09:32:28 darren Exp Locker: darren $
d19 2
d45 1
d61 8
a351 3
		lea	cd_USemaphore(a6),a0
		LINKEXE	ObtainSemaphore

d354 11
d366 3
d378 1
a378 1
		beq.s	openTmpError
d387 1
a387 2
	;-- everthing has succeeded, so modify IO_UNIT, and
	;-- add to list of console units.
d389 1
a389 1
		move.l	a2,IO_UNIT(a3)
a390 3
		lea     cd_UHead(a6),a0
		move.l  a2,a1
		ADDHEAD
d392 2
a394 3
	;------ see if unit is the active window
	;------ and set initial state flag

d404 1
a404 1
	;-- increment open window count NOW!
d406 1
a406 1
		addq.l	#1,cd_WindowCount(a6)
d408 15
d425 10
d436 7
d445 49
d510 1
a510 1
	;-- Release semaphore, and free up memory so far
a512 2
		lea	cd_USemaphore(a6),a0
		LINKEXE	ReleaseSemaphore
d514 2
d541 1
d550 2
a551 2
	    INITBYTE	cu_CDNestCnt,-1		; initially enabled
	    INITBYTE	cu_CursorFlags,CUF_CURSQDRAW
@


36.37
log
@Spelling corrections - AUTODOCS
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.36 91/02/08 19:49:53 darren Exp Locker: darren $
d80 1
a80 1
*	OpenDevice - a request to open a Console device
@


36.36
log
@No need to clear the delayed expunge bit; we dont expunge.
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.35 91/02/04 14:27:35 darren Exp Locker: darren $
d130 1
a130 1
*	only, and is not accessable by the programmer.  The character
@


36.35
log
@Tracks window count now, and AllocMem/FreeMem's 4100 byte CHIP ram
buffer when window count is != 0.  Fix - now decreases open count
if open fails.  CloseDevice code - no longer calls expunge, and
frees 4100 byte buffer when ok.  KLUDGE for GFA BASIC - reg dependency
on A0 == windowptr.
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.34 91/01/18 14:26:00 darren Exp Locker: darren $
a231 2
	;-- note that there is nomore expunge code
	;-- despite this instruction
d233 3
a235 1
		bclr	#LIBB_DELEXP,LIB_FLAGS(a6)
@


36.34
log
@Fix autodocs; character mapped windows MUST have a SIMPLE REFRESH
window for now.
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.33 90/12/18 10:41:35 darren Exp Locker: darren $
d232 2
a233 2
		lea	cd_USemaphore(a6),a0	; lockout race conditions
		LINKEXE	ObtainSemaphore		; DoIO breaks Forbid()
d237 10
a246 2
		move.w	LIB_OPENCNT(a6),d1
		bne.s	bumpOpen		;.s!
a248 1
		;-- better open Intuition now
d253 1
a253 1
                beq	fatalerror
d256 2
a257 10
		;-- first open
		;--	add input handler
		sub.w	#MP_SIZE,a7
		move.l	a7,a0
		bsr	initSyncIO
		lea	cd_HandlerIS(a6),a0
		move.l	a0,IO_DATA(a1)
		move.w	#IND_ADDHANDLER,IO_COMMAND(a1)
		LINKEXE	DoIO			; could break Forbid()!
		add.w	#MP_SIZE,a7
d269 2
a270 1
		moveq	#0,d1
d272 3
a274 3
bumpOpen:
		addq.w	#1,d1
		move.w	d1,LIB_OPENCNT(a6)
d278 1
a278 1
		bra	openRts		;and release semaphore
a280 2
		; we are synced up - we dont need this semaphore
		; for right now, so let any competition run.
d282 2
a283 2
		lea	cd_USemaphore(a6),a0
		LINKEXE	ReleaseSemaphore
a284 1

d286 1
a286 1
		bhi	openErr
d289 1
a289 1
		beq	openErr
d291 2
d294 1
a294 1
		beq	openErr
d296 1
a296 1
	    ;------ try to allocate a unit
d301 1
a301 1
		beq	openErr
d316 2
a317 1
	    ;------ get ClipRegion
d322 1
a322 1
	    ;------ initialize the unit command queue
d325 2
a326 2
	    
		;--	initialize character map semaphore
d329 1
a329 1
	    ;------ get window parameter
d332 1
a332 1
	    ;------ input key map
a340 2
		move.l	a2,IO_UNIT(a3)

d344 26
d374 4
a377 1
	    ;------ see if this is the active unit
d379 1
a379 1
		beq.s	isActive
d381 1
a381 1
		bne.s	activeDone
d385 1
a385 1
activeDone:
d387 4
a392 2

openRts:
d396 11
a406 1
openBail:
d412 12
d429 9
a437 1
openErr:
d441 1
a441 1
		bra.s	openBail
a442 5
fatalerror:
		lea	cd_USemaphore(a6),a0
		LINKEXE	ReleaseSemaphore
		bra.s	openErr

d512 1
a512 1
		beq.s	closeLibrary
d535 10
d568 2
a569 1
	    ;-- check if this should now be expunged
a575 11
		sub.w	#MP_SIZE,a7
		move.l	a7,a0
		bsr.s	initSyncIO
		move.w	#IND_REMHANDLER,IO_COMMAND(a1)
		LINKEXE	DoIO
		add.w	#MP_SIZE,a7

		btst	#LIBB_DELEXP,LIB_FLAGS(a6)
		beq.s	closeRts
		jmp	LIB_EXPUNGE(a6)

a597 28
*------ initSyncIO ---------------------------------------------------
*
*   NAME
*	initSyncIO - initialize cd_HandlerIOR for synchronous use
*
*   SYNOPSYS
*	initSyncIO(msgPort)
*	           a0
*
*---------------------------------------------------------------------
initSyncIO:
		move.b	#NT_MSGPORT,LN_TYPE(a0)
		clr.b	MP_FLAGS(a0)
		move.b	#SIGF_SINGLE,MP_SIGBIT(a0)
		move.l	cd_ExecLib(a6),a1
		move.l	ThisTask(a1),MP_SIGTASK(a0)

		lea	cd_HandlerIOR(a6),a1
		move.l	a0,MN_REPLYPORT(a1)

		lea	MP_MSGLIST(a0),a0
		;	NEWLIST a0
		move.l	a0,LH_TAILPRED(a0)
		addq.l	#4,a0
		clr.l	(a0)
		move.l	a0,-(a0)
		rts
	
@


36.33
log
@Some cleanup of autodocs.
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.32 90/11/28 19:12:14 darren Exp Locker: darren $
d125 3
a127 3
*	revealed, and to redraw a window after a resize.  So typically
*	you would use a SIMPLE_REFRESH window when asking the console
*	device to create a character map.
@


36.32
log
@Now opens Intuition library on first open, and
closes it on last close.  No longer opens it in
init code.
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.31 90/11/20 18:47:29 darren Exp Locker: darren $
d209 1
a209 1
*       should continue to read events from the console.device looking
d212 6
@


36.31
log
@New documentation regarding the new flags option (V37),
and some new NOTES describing how the pasting mechanism works,
what a "<CSI>0 v" means, how to deal with it, etc.  Some old
docs re: requiring that programmers get RAW INPUT events when
using units 1, or 3 removed.
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.30 90/11/01 11:21:45 darren Exp Locker: darren $
d40 1
d227 1
a227 1
		LINKEXE	ObtainSemaphore
d234 9
d293 1
a293 1
		moveq	#MEMF_PUBLIC,d1
d378 5
d393 2
a394 2
	    INITBYTE    cu_IHead,0		;head of token list (input)
	    INITBYTE	cu_ITail,0		;tail of token list (task)
d399 3
d501 3
@


36.30
log
@New code added for a new input handling scheme which tracks
history of events.
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.29 90/10/11 15:28:29 darren Exp Locker: darren $
d22 1
d82 1
a82 1
*	error = OpenDevice("console.device", unit, IOStdReq, 0 )
d90 3
d137 3
a139 3
*	text with the mouse which can be pasted into to other
*	console.device windows by pressing the RIGHT-AMIGA key, and
*	the key labeled "V".
d141 17
d170 3
a172 2
*	0 - a flag field of zero
*	
d177 34
a210 13
*	The console device receives input events from the input.device.
*	It is important that your application not block events generated
*	by Intuition else console.device will not hear about them.  IDCMP
*	messages are placed back into the input food chain after
*	your application replies to the message(s).  At some later
*	time they are received by the console.device via an input
*	handler.
*
*	Those using the console map feature should receive intuition
*	events from console.device instead of using an IDCMP.  This can
*	be done by sending the command sequence for RAW INPUT EVENTS,
*	and reading from the console.device.  By doing this, you will
*	hear about IDCMP messages after the console.device does.
d220 4
a223 3
		movem.l d2-d3/a2-a4,-(sp)
		move.l	d0,d2
		move.l	a1,a3
d296 5
d354 1
a354 1
		movem.l (sp)+,d2-d3/a2-a4
@


36.29
log
@Documentation change
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.28 90/10/11 14:17:55 darren Exp Locker: darren $
d187 1
a187 1
		bne.s	bumpOpen
d292 1
a294 2
		bset	#CUB_FIRSTTIME,cu_States(a2)

d329 3
@


36.28
log
@Slight changes to docs.
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.27 90/10/11 13:16:33 darren Exp Locker: darren $
d163 1
a163 1
*	Those using the console map feature should received intuition
@


36.27
log
@Changes to AUTO_DOCS
New info for V36 unit numbers.
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.26 90/09/13 18:11:37 darren Exp Locker: darren $
d100 1
a100 1
*       unit number: -1 (CONU_LIBRARY)
d134 1
a134 1
*       console.device windows by pressing the RIGHT-AMIGA key, and
@


36.26
log
@Code has also been added to weed out
bogus unit #'s upon startup.
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.25 90/09/13 18:09:43 darren Exp Locker: darren $
d96 2
a97 7
*	is used specially by this device.  A unit of -1 indicates that
*	no actual console is to be opened, and is used to get a pointer 
*	to the device library vector ( which will be returned in the
*	io_Device field of the IOStdReq block ).  A unit of zero binds 
*	the supplied window to a unique console.  Sharing a console
*	must be done at a level higher than the device.  There are no
*	other valid unit numbers.
d99 38
d147 1
a147 1
*	unit - the unit number to open on that device (0, or -1).
d154 15
@


36.25
log
@State flag - first time through set
for special cases (e.g., window
starts out tiny).
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.27 90/09/13 18:12:44 darren Exp $
@


36.24
log
@Fix potential bug - potential for
a race condition during open.
DoIO() could break Forbid(), so
1st time through could result in a
race condition.  Semaphore used.
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.23 90/07/26 11:05:43 darren Exp $
d167 1
a167 1
		cmpi.l	#-1,d2
d179 7
d246 2
d250 1
d255 1
d270 1
a270 1
		bra.s	openRts
@


36.23
log
@Included some conditional assumptions
regarding the 4 possible unit #'s
when opening a console unit.  Necessary
because of the code (e.g., wreset.asm
checks bit 0 for conmap/snip)
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.22 90/05/16 11:44:03 kodiak Exp Locker: darren $
d6 1
a6 1
**      (C) Copyright 1985,1987,1989 Commodore-Amiga, Inc.
d133 3
d149 1
a149 1
		LINKEXE	DoIO
d170 1
a170 1
		bra	openRts
d173 6
d241 1
d246 1
a246 1
openRts:
@


36.22
log
@Notices closing a window in the middle of highlighting and makes it safe
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.21 90/05/16 11:34:48 kodiak Exp Locker: kodiak $
d55 18
@


36.21
log
@Fixes initalization so that active window is known
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.20 90/05/11 11:41:58 kodiak Exp Locker: kodiak $
d299 9
a307 1
	    ;------ unlink from the device unit list
@


36.20
log
@fix Init/Expunge/Open/Close to DoIO at Open/Close time, not Init/Expunge time
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.19 90/04/20 09:45:33 kodiak Exp Locker: kodiak $
d20 1
a41 2
	XLVO	AskKeyMapDefault	; Keymap

d45 5
d120 2
d130 11
a216 4
	    ;------ Get the intuition library
		tst.l	cd_IntuitionLib(a6)
		bne.s	openDone
		lea	ILName(pc),a1
a217 5
		LINKEXE OpenLibrary
		move.l	d0,cd_IntuitionLib(a6)

openDone:
		moveq	#0,d0
a231 5

ILName:
		dc.b	'intuition.library'
		dc.b	0
		ds.w	0
@


36.19
log
@first semi-tested big clip support
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.18 90/04/16 18:22:55 kodiak Exp Locker: kodiak $
d18 2
d33 1
d107 4
d112 18
a129 2
		addq.w	#1,LIB_OPENCNT(a6)
		cmpi.l	#-1,d0
d131 2
a132 2
		move.l	d0,IO_UNIT(a1)
		rts
a134 4
		movem.l d2-d3/a2-a4,-(sp)
		move.l	d0,d2
		move.l	a1,a3

d334 8
d367 30
a396 1
		END
@


36.18
log
@sniff cursor ghosting compatibility problems
@
text
@d2 1
a2 1
**	$Id: open.asm,v 36.17 90/04/13 13:32:40 kodiak Exp Locker: kodiak $
a220 4

	    INITWORD	cu_ReadBuffer+bf_StoreSize,READBSIZE
	    INITWORD	cu_PICBuffer+bf_StoreSize,PICBSIZE
	    INITWORD	cu_PNPBuffer+bf_StoreSize,PNPBSIZE
@


36.17
log
@use Id instead of Header for 4.x rcs
@
text
@d2 1
a2 1
**	$Id$
d57 1
a57 1
*	D0		    A0               D0    A1        D1
d104 6
a109 6
		BCLR	#LIBB_DELEXP,LIB_FLAGS(A6)
		ADDQ.W	#1,LIB_OPENCNT(A6)
		CMPI.L	#-1,D0
		BNE.S	regularOpen
		MOVE.L	D0,IO_UNIT(A1)
		RTS
d112 1
a112 1
		MOVEM.L D2-D3/A2-A4,-(SP)
d114 1
a114 1
		MOVE.L	A1,A3
d116 2
a117 2
		tst.L	IO_DATA(A3)
		BEQ	openErr
d120 2
a121 2
		MOVE.L	#cu_SIZE,D0
		MOVEQ	#MEMF_PUBLIC,D1
d123 3
a125 3
		TST.L	D0
		BEQ	openErr
		MOVE.L	D0,A2
d128 2
a129 2
		LEA	unitInitData(PC),A1
		MOVE.L	#cu_SIZE,D0
d140 2
a141 2
		LEA     MP_MSGLIST(A2),A0
		NEWLIST A0
d147 1
a147 1
		MOVE.L	IO_DATA(A3),cu_Window(A2)
d152 2
a153 2
		LEA	cu_KeyMapStruct(A2),A1
		MOVEQ	#(km_SIZEOF/4)-1,D0
d155 2
a156 2
		MOVE.L	(A0)+,(A1)+
		DBF	D0,copyKeyMapStruct
d158 1
a158 1
		MOVE.L	A2,IO_UNIT(A3)
d163 2
a164 2
		LEA     cd_UHead(A6),A0
		MOVE.L  A2,A1
d168 4
a171 4
		MOVE.L	cd_ActiveWindow(A6),D0
		BEQ.S	isActive
		CMP.L	cu_Window(A2),D0
		BNE.S	activeDone
d173 1
a173 1
		MOVE.L	A2,cd_Active(A6)
d176 1
a176 1
		BSR     WriteReset
d182 4
a185 4
		TST.L	cd_IntuitionLib(A6)
		BNE.S	openDone
		LEA	ILName(PC),A1
		MOVEQ	#0,D0
d187 1
a187 1
		MOVE.L	D0,cd_IntuitionLib(A6)
d190 1
a190 1
		MOVEQ	#0,D0
d192 2
a193 2
		MOVEM.L (SP)+,D2-D3/A2-A4
		RTS
d196 2
a197 2
		MOVE.L	A2,A1
		MOVE.L	#cu_SIZE,D0
d201 4
a204 4
		MOVEQ	#IOERR_OPENFAIL,D0
		CLR.L	IO_DEVICE(A3)
		MOVE.B	D0,IO_ERROR(A3)
		BRA.S	openRts
d207 3
a209 3
		DC.B	'intuition.library'
		DC.B	0
		DS.W	0
d220 1
d226 1
a226 1
		DC.W	0
d261 1
a261 1
*	      A1	  A6
d274 5
a278 5
		MOVEM.L	A2/A3,-(SP)
		MOVE.L	A1,A3		    ; save I/O Request
		MOVE.L	IO_UNIT(A3),A2
		CMPA	#-1,A2		; check if open only for library
		BEQ.S	closeLibrary
d285 2
a286 2
		MOVE.L	A2,A1
		LEA	cd_UHead(A6),A0
d288 3
a290 3
		CMP.L	cd_Active(A6),A2
		BNE.S	closeUnit
		CLR.L	cd_Active(A6)
d302 2
a303 2
		MOVE.L	A2,A1
		MOVE.L	#cu_SIZE,D0
d307 1
a307 1
		MOVE.L	A3,A1
d309 1
a309 1
		MOVEM.L	(SP)+,A2/A3
@


36.16
log
@for 4.x rcs
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/open.asm,v 36.15 90/02/21 14:04:17 kodiak Exp Locker: kodiak $
@


36.15
log
@first cut private map locking solution, snapshot to allow release of
pack fix
@
text
@d2 1
a2 1
**	$Header: open.asm,v 36.14 89/12/19 13:27:41 kodiak Exp $
@


36.14
log
@autodoc update
@
text
@d2 1
a2 1
**	$Header: open.asm,v 36.13 89/12/19 11:03:25 kodiak Exp $
a31 1
	XLVO	InitSemaphore		;
d45 2
d144 1
a144 2
		lea	cu_MSemaphore(a2),a0
		LINKEXE	InitSemaphore
@


36.13
log
@eliminate private ObtainSemaphoreShared & ReleaseSemaphore -- use exec's
@
text
@d2 1
a2 1
**	$Header: open.asm,v 36.12 89/12/02 11:37:00 kodiak Exp $
d49 1
a49 1
******* console.device/function/OpenDevice *************************************
d98 1
a98 1
*	console.device/function/CloseDevice, exec/io.h, intuition/intuition.h
d227 1
a227 1
******* console.device/function/CloseDevice ************************************
@


36.12
log
@
@
text
@d2 1
a2 1
**	$Header$
d36 1
a45 2
	XREF	ReleaseSemaphore

d179 1
a179 1
		bsr	ReleaseSemaphore
d293 1
a293 1
		bsr	ReleaseSemaphore
@


36.11
log
@first cut at line buffers
@
text
@d1 9
a9 52
	TTL	'$Header: open.asm,v 36.10 89/11/07 12:57:41 kodiak Exp $'
**********************************************************************
*
*			--------------
*   open.asm		CONSOLE DEVICE	open a console unit
*			--------------
*
*   Copyright 1985, 1987 Commodore-Amiga Inc.
*
*   Source Control	$Locker: kodiak $
*
*   $Log:	open.asm,v $
*   Revision 36.10  89/11/07  12:57:41  kodiak
*   first cut at cu_MSemaphore
*   
*   Revision 36.9  89/11/04  16:03:37  kodiak
*   restructure map variables
*   use XLVO macro strategy
*   
*   Revision 36.8  89/09/29  12:05:25  kodiak
*   move close library code from dev.asm to here
*   
*   Revision 36.7  89/09/15  15:41:16  kodiak
*   remove XREF to CDExpunge (obsolete)
*   
*   Revision 36.6  89/07/10  18:17:49  kodiak
*   free buffers allocated for char mapped console at close time
*   init CDNestCnt to -1
*   
*   Revision 36.5  89/07/05  15:18:16  kodiak
*   cu_BufferSize is UWORD (was ULONG)
*   
*   Revision 36.4  89/06/30  18:04:06  kodiak
*   (release USemaphore even when closing inactive window)
*   
*   Revision 36.3  89/06/28  19:14:24  kodiak
*   better avoidance of cursor spoor
*   
*   Revision 36.2  89/06/28  12:34:48  kodiak
*   protect cd_Unit list for exclusive access
*   
*   Revision 36.1  88/09/19  10:15:56  kodiak
*   add character map and pseudo-clipboard support
*   
*   Revision 36.0  88/09/06  19:52:03  kodiak
*   *** empty log message ***
*   
*   Revision 35.0  87/10/26  11:13:22  kodiak
*   initial from V34, but w/ stripped log
*   
*
**********************************************************************
d11 1
a11 1
	SECTION		rawinput
d13 1
a13 1
*------ Included Files -----------------------------------------------
d15 3
a17 1
	INCLUDE		"cddata.i"
a18 3
	INCLUDE		"exec/errors.i"
	INCLUDE		"exec/initializers.i"
	INCLUDE		"exec/memory.i"
d20 1
d22 3
a24 1
*------ Imported Names -----------------------------------------------
d26 3
d43 1
a43 1
	XREF		CDName
d45 1
a45 1
	XREF		ReleaseSemaphore
d47 1
a47 1
	XREF		WriteReset
a49 7
*------ Exported Functions -------------------------------------------

	XDEF		CDOpen
	XDEF		CDClose
	XDEF		FreeBuffers


d213 1
a213 1
*	;------ initialize the unit command queue
d281 1
a281 1
*	    ;------ unlink from the device unit list
d296 1
a296 1
*	    ;-- do unit specific close stuff
d300 1
a300 1
		bsr.s	FreeBuffers
d306 1
a306 1
*	    ;-- do generic close stuff
a329 1

d331 1
a331 1
		beq.s	fbAB
d337 2
@


36.10
log
@first cut at cu_MSemaphore
@
text
@d1 1
a1 1
	TTL	'$Header: open.asm,v 36.9 89/11/04 16:03:37 kodiak Exp $'
d13 3
d372 2
a373 4
FreeBuffers:
		movem.l	d2/a6,-(a7)
		moveq	#0,d2
		move.w	cu_CM+cm_Elements(a2),d2
a374 1
		move.l	cd_ExecLib(a6),a6
d376 1
a376 1
		move.l	cu_CM+cm_CharBuffer(a2),d1
d379 2
a380 1
		move.l	d2,d0
d382 3
a384 9
fbAB:
		move.l	cu_CM+cm_AttrBuffer(a2),d1
		beq.s	fbBS
		move.l	d1,a1
		move.l	d2,d0
		add.l	d0,d0
		CALLLVO	FreeMem
fbBS:
		clr.w	cu_CM+cm_Elements(a2)
a385 1
		movem.l	(a7)+,d2/a6
@


36.9
log
@restructure map variables
use XLVO macro strategy
@
text
@d1 1
a1 1
	TTL	'$Header: open.asm,v 36.8 89/09/29 12:05:25 kodiak Exp $'
d13 4
d67 1
d184 4
@


36.8
log
@move close library code from dev.asm to here
@
text
@d1 1
a1 1
	TTL	'$Header: open.asm,v 36.7 89/09/15 15:41:16 kodiak Exp $'
d13 3
d60 7
a66 7
	XREF_EXE	AddHead
	XREF_EXE	AllocMem
	XREF_EXE	FreeMem
	XREF_EXE	InitStruct
	XREF_EXE	ObtainSemaphore
	XREF_EXE	OpenLibrary
	XREF_EXE	Remove
d68 1
a68 1
	XREF_KEY	AskKeyMapDefault
d70 2
a71 2
	XREF_GFX	DisposeRegion
	XREF_GFX	NewRegion
d363 1
a363 1
		move.w	cu_BufferSize(a2),d2
d367 1
a367 1
		move.l	cu_CharBuffer(a2),d1
d371 1
a371 1
		CALLEXE	FreeMem
d373 1
a373 1
		move.l	cu_AttrBuffer(a2),d1
d378 1
a378 1
		CALLEXE	FreeMem
d380 1
a380 1
		clr.w	cu_BufferSize(a2)
@


36.7
log
@remove XREF to CDExpunge (obsolete)
@
text
@d1 1
a1 1
	TTL	'$Header: open.asm,v 36.6 89/07/10 18:17:49 kodiak Exp $'
d13 3
a75 1
	XREF		Close
a76 1

d338 1
a338 1
closeLibrary
d340 15
a354 1
		BRA	Close
@


36.6
log
@free buffers allocated for char mapped console at close time
init CDNestCnt to -1
@
text
@d1 1
a1 1
	TTL	'$Header: open.asm,v 36.5 89/07/05 15:18:16 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 4
a67 1
	XREF		CDExpunge
@


36.5
log
@cu_BufferSize is UWORD (was ULONG)
@
text
@d1 1
a1 1
	TTL	'$Header: open.asm,v 36.4 89/06/30 18:04:06 kodiak Exp $'
d13 3
d246 1
d326 2
d337 1
@


36.4
log
@(release USemaphore even when closing inactive window)
@
text
@d1 1
a1 1
	TTL	'$Header: open.asm,v 36.3 89/06/28 19:14:24 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker: kodiak $
d13 3
d334 2
a335 1
		move.l	cu_BufferSize(a2),d2
d352 1
a352 1
		clr.l	cu_BufferSize(a2)
@


36.3
log
@better avoidance of cursor spoor
@
text
@d1 1
a1 1
	TTL	'$Header: open.asm,v 36.2 89/06/28 12:34:48 kodiak Exp $'
d13 3
d311 1
a314 1
closeUnit:
@


36.2
log
@protect cd_Unit list for exclusive access
@
text
@d1 1
a1 1
	TTL	'$Header: open.asm,v 36.1 88/09/19 10:15:56 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 3
a184 10
		BSR     WriteReset

	    ;------ Get the intuition library
		TST.L	cd_IntuitionLib(A6)
		BNE.S	checkActive
		LEA	ILName(PC),A1
		MOVEQ	#0,D0
		LINKEXE OpenLibrary
		MOVE.L	D0,cd_IntuitionLib(A6)

a185 1
checkActive:
d194 2
d199 9
@


36.1
log
@add character map and pseudo-clipboard support
@
text
@d1 1
a1 1
	TTL	'$Header: open.asm,v 36.0 88/09/06 19:52:03 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker: kodiak $
d13 3
d42 1
d54 2
a56 3
	XREF		CursInit
	XREF		CursExpunge
	XREF		CursEnable
d175 3
a181 2
		BSR     CursInit

a183 2
		BSR	CursEnable

d202 3
d295 3
d305 3
a309 2
		BSR	CursExpunge

@


36.0
log
@*** empty log message ***
@
text
@d1 1
a1 1
    TTL    '$Header: open.asm,v 35.0 87/10/26 11:13:22 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 3
d62 1
d128 1
d131 1
a131 1
		MOVE.L	IO_DATA(A3),D0
d147 2
d313 24
@
