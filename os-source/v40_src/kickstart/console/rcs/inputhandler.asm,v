head     36.36;
branch   ;
access   ;
symbols  V39_4:36.34 V37_157:36.34 V37_149:36.33 V37_136:36.33 V37_133:36.33 V37_110:36.33 V37_98:36.32 V37_85:36.32 V37_63:36.32 V37_36:36.32 V37_15:36.30 V37_10:36.30 V37_7:36.30 V37_2:36.30 V36_558:36.30 V36_554:36.30 V36_552:36.30 V36_549:36.30 V36_548:36.30 V36_547:36.30 V36_546:36.30 V36_545:36.30 V36_544:36.30 V36_543:36.30 V36_542:36.30 V36_540:36.29 V36_539:36.28 V36_538:36.27 V36_537:36.27 V36_536:36.27 V36_529:36.25 V36_527:36.25 V36_525:36.25 V36_524:36.25 V36_523:36.25 V36_522:36.25 V36_521:36.25 V36_520:36.25 V36_519:36.25 V36_518:36.25 V36_495:36.25 V36_491:36.24 V36_486:36.24 V36_482:36.24 V36_476:36.24 V36_471:36.24 V36_465:36.23 V36_463:36.23 V36_461:36.22 V36_460:36.22 V36_453:36.21 V36_447:36.21 V36_442:36.21 V36_429:36.20 V36_423:36.20 V36_413:36.20 V36_394:36.19 V36_387:36.19 V36_382:36.19 V36_381:36.19 V36_379:36.18 V36_373:36.18 V36_367:36.18 V36_361:36.18 V36_359:36.18 V36_357:36.18 V36_353:36.18 V36_346:36.18 V36_343:36.18 V36_338:36.17 V36_332:36.17 V36_327:36.16 V36_321:36.16 V36_319:36.15 V36_318:36.14 V36_316:36.13 V36_313:36.12 V36_311:36.12 V36_310:36.12 V36_300:36.12 V36_299:36.12 V36_297:36.12 V36_295:36.12 V36_278:36.12 V36_274:36.12 V36_221:36.10 V36_205:36.10 V36_171:36.9 V36_167:36.9 V36_165:36.8 V36_153:36.8 V36_146:36.8 V36_140:36.8 V36_129:36.7 V36_113:36.6 V36_56:36.5 V36_53:36.3 V36_51:36.3 V36_45:36.2 L36_42:36.1;
locks    ; strict;
comment  @*   @;


36.36
date     92.12.15.08.31.10;  author darren;  state Exp;
branches ;
next     36.35;

36.35
date     92.03.24.16.26.34;  author darren;  state Exp;
branches ;
next     36.34;

36.34
date     91.05.22.13.47.51;  author darren;  state Exp;
branches ;
next     36.33;

36.33
date     91.04.12.17.40.12;  author darren;  state Exp;
branches ;
next     36.32;

36.32
date     91.02.14.14.55.06;  author darren;  state Exp;
branches ;
next     36.31;

36.31
date     91.02.04.14.29.38;  author darren;  state Exp;
branches ;
next     36.30;

36.30
date     90.11.20.18.39.05;  author darren;  state Exp;
branches ;
next     36.29;

36.29
date     90.11.09.20.26.23;  author darren;  state Exp;
branches ;
next     36.28;

36.28
date     90.11.07.15.22.05;  author darren;  state Exp;
branches ;
next     36.27;

36.27
date     90.11.02.08.31.09;  author darren;  state Exp;
branches ;
next     36.26;

36.26
date     90.11.01.11.21.16;  author darren;  state Exp;
branches ;
next     36.25;

36.25
date     90.05.30.14.23.39;  author kodiak;  state Exp;
branches ;
next     36.24;

36.24
date     90.05.16.11.34.31;  author kodiak;  state Exp;
branches ;
next     36.23;

36.23
date     90.05.14.23.15.27;  author kodiak;  state Exp;
branches ;
next     36.22;

36.22
date     90.05.11.09.57.09;  author kodiak;  state Exp;
branches ;
next     36.21;

36.21
date     90.04.20.09.45.26;  author kodiak;  state Exp;
branches ;
next     36.20;

36.20
date     90.04.13.13.32.31;  author kodiak;  state Exp;
branches ;
next     36.19;

36.19
date     90.04.02.10.47.18;  author kodiak;  state Exp;
branches ;
next     36.18;

36.18
date     90.02.21.18.40.26;  author kodiak;  state Exp;
branches ;
next     36.17;

36.17
date     90.01.30.15.56.18;  author kodiak;  state Exp;
branches ;
next     36.16;

36.16
date     90.01.15.10.08.56;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     89.12.19.13.27.26;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     89.12.19.11.03.18;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     89.12.17.19.35.34;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     89.12.02.11.36.47;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     89.11.27.12.52.35;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     89.11.04.16.03.08;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     89.09.15.15.42.14;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     89.07.05.15.18.11;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     89.06.28.19.14.20;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     89.06.28.14.13.43;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.04.19.16.17.11;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     89.04.17.15.35.25;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     89.01.01.15.19.25;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     89.01.10.16.46.31;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     88.09.19.10.15.47;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     88.09.06.19.51.48;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


36.36
log
@Move qualifier bit tracking inside of rawmouse class test so that we
do not stop tracking because of some other event.  This was an intended
change for V39 3.0, but didn't quite make it.
@
text
@**
**	$Id: inputhandler.asm,v 36.35 92/03/24 16:26:34 darren Exp Locker: darren $
**
**      console device input handler
**
**      (C) Copyright 1985,1989 Commodore-Amiga, Inc.
**          All Rights Reserved
**
	SECTION	console

**	Includes

	INCLUDE	"cddata.i"

	INCLUDE	"exec/ables.i"
	INCLUDE	"debug.i"
**	Exports

	XDEF	CDInputHandler


**	Imports

	XLVO	ObtainSemaphoreShared	; Exec
	XLVO	Permit			;
	XLVO	RawDoFmt		;
	XLVO	ReleaseSemaphore	;
	XLVO	Signal			;

	XLVO	MapRawKey		; Keymap

	XREF	PutReadData
	XREF	PutReadSnip

	XREF	ReSizePost

	XREF	CDRead


**	Assumptions

	IFNE	IEQUALIFIERB_LEFTBUTTON/8-1
	FAIL	"IEQUALIFIERB_LEFTBUTTON not in high byte, recode"
	ENDC
	IFNE	IEQUALIFIERB_MULTIBROADCAST/8-1
	FAIL	"IEQUALIFIERB_MULTIBROADCAST not in high byte, recode"
	ENDC
	IFNE	IEQUALIFIERB_REPEAT/8-1
	FAIL	"IEQUALIFIERB_REPEAT not in high byte, recode"
	ENDC
	IFNE	IEQUALIFIERB_RCOMMAND/8
	FAIL	"IEQUALIFIERB_RCOMMAND not in low byte, recode"
	ENDC


******* console.device/CDInputHandler ********************************
*
*    NAME
*	CDInputHandler -- handle an input event for the console device
*
*    SYNOPSIS
*	events = CDInputHandler(events, consoleDevice)
*		       a0      a1
*
*    FUNCTION
*	Accept input events from the producer, which is usually the
*	rom input.task.
*
*    INPUTS
*	events - a pointer to a list of input events.
*	consoleDevice - a pointer to the library base address of the
*	    console device.  This has the same value as ConsoleDevice
*	    described below.
*
*    RESULTS
*	events - a pointer to a list of input events not used by this
*	    handler.
*
*    NOTES
*	This function is available for historical reasons.  It is
*	preferred that input events be fed to the system via the
*	WriteEvent command of the input.device.
*
*	This function is different from standard device commands in
*	that it is a function in the console device library vectors.
*	In order to obtain a valid library base pointer for the 
*	console device (a.k.a. ConsoleDevice) call
*	OpenDevice("console.device", -1, IOStdReq, 0),
*	and then grab the io_Device pointer field out of the IOStdReq
*	and use as ConsoleDevice.
*
*    BUGS
*
*    SEE ALSO
*	input.device
*
********************************************************************************

*****************************************************
* Add an event to an input list (circular)
*
* Only adds new events - no duplicates.
* Refresh, and resize are cumulative, and the
* same except a special bit is set in the unit
* structure which means resize happened.  One refresh,
* or full redraw suffices for multiple refresh/resize events.
* Resize can also be caught before the event happens because
* the window height/width values are tracked, and checked.
*
* The main use of the token system is activation/inactivation
* tracking.  This is because an event such as refresh followed
* by activation requires that the console be refreshed in
* the inactive state (to get the cursor right), and then
* made active by redrawing the cursor.
*
* IN: a2 = console unit addr
*     d4 = event token (byte)
*
* USED: a1 = ptr to event in list
*       d3 = offset (head)
*
* All registers must be preserved by the caller - this is
* intended for speedy insertion of event tokens.  See cddata.i
* for bit definitions.
*

AddEvent:
		lea	cu_IList(a2),a1

		moveq	#00,d3
		move.b	cu_IHead(a2),d3
		cmp.b	cu_ITail(a2),d3	;load in register
		beq.s	addevent

		;-- compare with last event
		;-- refresh/resize are cumulative

		subq.b	#1,d3
		cmp.b	0(a1,d3),d4	;compare tokens
		beq.s	sameevent
		addq.b	#1,d3

addevent:
		move.b	d4,0(a1,d3)	;flag info

		;update head last so task can't jump ahead
		;though due to Exec's task scheduling, the
		;task can't be running while we are in this
		;code.
		addq.b	#1,d3		;wraps around	
		move.b	d3,cu_IHead(a2)					
		
sameevent:
                rts

FindEventConsole:
		move.l	cd_UHead(a6),d0		; get unit list
		move.l	ie_EventAddress(a3),d1	; get event window

fcLoop:
		move.l	d0,a0
		move.l	(a0),d0
		beq.s	fcNotFound
		cmp.l	cu_Window(a0),d1
		bne.s	fcLoop

		move.l	a0,d0
fcNotFound:
		rts

		cnop	0,4

CDInputHandler:
		movem.l	d2-d4/a2-a4/a6,-(a7)
		link	a5,#-((CD_CONVBUFSIZE+1)&$fffe)	; ensure even

		move.l	a1,a6		; get console device base
		move.l	a0,d0
		beq	cdihRts
		move.l	a0,a3
		moveq	#0,d2


		lea	cd_USemaphore(a6),a0
		LINKEXE	ObtainSemaphoreShared


loopEvents:
		move.b	ie_Class(a3),d0
		cmpi.b	#IECLASS_EVENT,d0
		bne	checkMultibroadcast

		;-- check for IECLASS_EVENT IECODE_NEWACTIVE
		move.w	ie_Code(a3),d0
		subq.w	#IECODE_NEWACTIVE,d0
		bne.s	checkNewsizeEvent

		;-- a new intuition window is active
		;--	indicate old active unit is no longer active
		move.l	cd_Active(a6),a2
		move.l	a2,d0
		beq.s	findNewActive

		;-- ADD MAKEINACTIVE EVENT
		moveq	#IPF_ISACTIVE!IPF_MAKEINACTIVE,d4 ;was Active before
		bsr	AddEvent


findNewActive:
		;--	find new active unit
		clr.l	cd_Active(a6)		; guess not console unit

		;--	    save new active window
		move.l	ie_EventAddress(a3),cd_ActiveWindow(a6)
		bsr.s	FindEventConsole
		beq.s	checkOldA

		move.l	d0,a2
		move.l	a2,cd_Active(a6)

		and.b	#CDS_SELECTMASK,cd_SelectFlags(a6)

		;-- ADD EVENT

		moveq	#IPF_MAKEACTIVE,d4	;was not active before
		bsr	AddEvent

checkOldA:
		move.l	#CDSIGF_NEWACTIVE,d0
		move.l	a2,d1			; something to signal about?
		bne.s	signalTC
		bra	dispatchActive


		;-- check for IECLASS_EVENT IECODE_NEWSIZE
checkNewsizeEvent:
		subq.w	#IECODE_NEWSIZE-IECODE_NEWACTIVE,d0
		bne.s	checkRefreshEvent
		bsr	FindEventConsole
		beq	chkNextEvent

		move.l	d0,a2
		bsr	ReSizePost

		;-- ADD EVENT

		moveq	#IPF_REDRAW,d4
		cmp.l	cd_Active(a6),a2
		bne.s	setNewSize
		bset	#IPB_ISACTIVE,d4
setNewSize:
		bsr	AddEvent

* Old code - seems wrong as it won't signal in the event of
* no character map when a resize happens (yet it should)
* because I may have to force the cursor into visible range,
* and clean up clipped bits of text around the borders.
*		bra.s	dispatchA2
*
		bra.s	sigRefresh


		;-- check for IECLASS_EVENT IECODE_REFRESH
checkRefreshEvent:
		subq.w	#IECODE_REFRESH-IECODE_NEWSIZE,d0
		bne.s	dispatchWindow

		;-- check for a refresh on a buffered console
		bsr	FindEventConsole
		beq.s	chkNextEvent

		move.l	d0,a2
		tst.l	cu_CM+cm_AllocSize(a2)
		beq.s	dispatchA2

		bset	#CUB_REFRESH,cu_Flags(a2)

		;-- ADD EVENT

		moveq	#IPF_REDRAW,d4
		cmpa.l	cd_Active(a6),a2
		bne.s	setDamaged
		bset	#IPB_ISACTIVE,d4
setDamaged:
		bsr	AddEvent

sigRefresh:
		move.l	#CDSIGF_REFRESH,d0

		;-- signal task that something happened
signalTC:
		lea	cd_TC(a6),a1
		LINKEXE	Signal
		bra.s	dispatchWindow


checkMultibroadcast:
		btst	#IEQUALIFIERB_MULTIBROADCAST&7,ie_Qualifier(a3)
		beq.s	notMultibroadcast

		;-- dispatch input for all console windows
		move.l	cd_UHead(a6),a2		; get first unit
nextDUnit:
		tst.l	(a2)
		beq.s	chkNextEvent	; no more units
		bsr	dispatchEvent
		move.l	(a2),a2		; next unit
		bra.s	nextDUnit


notMultibroadcast:
		;-- see if the event specifies the window

		;-- As of 36.4130 of intuition.library, SIZEWINDOW,
		;-- and CHANGEWINDOW are broadcast with an event
		;-- address.  The old assumption worked only when the
		;-- user had manually activated a console.device window,
		;-- and moved, or resized it.  If a window was moved/sized
		;-- under program control (when it was not active), these
		;-- two classes would be sent to the active console window
		;-- even though they had nothing whatsoever to do with
		;-- that window.  If there was no active console window,
		;-- they would be lost.

IEWINDOWCLASS1	EQU	(1<<IECLASS_REQUESTER)!(1<<IECLASS_REFRESHWINDOW)
IEWINDOWCLASS2	EQU	(1<<IECLASS_ACTIVEWINDOW)!(1<<IECLASS_INACTIVEWINDOW)
IEWINDOWCLASS3	EQU	(1<<IECLASS_SIZEWINDOW)!(1<<IECLASS_CHANGEWINDOW)
IEWINDOWCLASS	EQU	IEWINDOWCLASS1!IEWINDOWCLASS2!IEWINDOWCLASS3

		move.l	#IEWINDOWCLASS,d1
		btst	d0,d1
		beq.s	dispatchActive


dispatchWindow:
		;-- dispatch input for window in event
		bsr	FindEventConsole
		beq.s	chkNextEvent
		move.l	d0,a2
		bra.s	dispatchA2

dispatchActive:
		;-- dispatch input for active console
		move.l	cd_Active(a6),d0
		beq.s	chkNextEvent
		move.l	d0,a2

dispatchA2:
		;-- dispatch input for console unit
		bsr.s	dispatchEvent

chkNextEvent:
		move.l	(a3),d0
		beq.s	endEvents
		move.l	d0,a3
		bra	loopEvents

endEvents:
		tst	d2
		beq.s	releaseUSem

		;-- satisfy any pending read with the new data
		move.l	cd_UHead(a6),a2		; get first unit
loopReadUnit:
		tst.l	(a2)
		beq.s	releaseUSem		; no more units
		bclr	#DUB_DISPATCH,du_Flags(a2)
		beq.s	nextReadUnit

		;--	satisfy data posted to this unit
		move.l	cd_ExecLib(a6),a0
		FORBID	a0,NOFETCH

		move.l	MP_MSGLIST(a2),a1
		tst.l	(a1)
		beq.s	ruPermit

		bsr	CDRead
ruPermit:
		move.l	cd_ExecLib(a6),a0
		PERMIT	a0,NOFETCH

nextReadUnit:
		move.l	(a2),a2		; next unit
		bra.s	loopReadUnit

releaseUSem:
		lea	cd_USemaphore(a6),a0
		LINKEXE	ReleaseSemaphore

cdihRts:
		moveq	#0,d0
		unlk	a5
		movem.l	(a7)+,d2-d4/a2-a4/a6
		rts


;***
;***	dispatchEvent - pass the event to unit a2
;***
dispatchEvent:
		moveq	#0,d0
		move.b	ie_Class(a3),d0

		cmpi.b	#IECLASS_RAWMOUSE,d0
		bne.s	deNoSelect

		;-- cache most current qualifier bits

		move.w	ie_Qualifier(a3),cd_MouseQual(a6)

		btst	#1,cu_DevUnit+3(a2)	; check if highlight enabled
		beq.s	deNoSelect
		tst.l	cu_CM+cm_AllocSize(a2)	; check for character map
		beq.s	deNoSelect

		move.w	ie_Code(a3),d1
		cmpi.w	#IECODE_LBUTTON,d1
		bne.s	deNoSelect

		and.b	#CDS_SELECTMASK,cd_SelectFlags(a6)
		move.w	ie_Qualifier(a3),d1
		and.w	#IEQUALIFIER_LSHIFT!IEQUALIFIER_RSHIFT,d1
		beq.s	deStdSelect
		;--	extended selection
		or.b	#CDSF_SELECTDOWN!CDSF_EXTENDED,cd_SelectFlags(a6)
		bra.s	deSelectSignal
		;--	normal selection
deStdSelect:
		or.b	#CDSF_SELECTDOWN,cd_SelectFlags(a6)

deSelectSignal:
		move.l	d0,-(a7)
		move.l	#CDSIGF_SELECT,d0
		lea	cd_TC(a6),a1

		LINKEXE	Signal
		move.l	(a7)+,d0

deNoSelect:
		cmpi.b	#IECLASS_MAX,d0
		bhi	checkRepeatFlush
		move.w	d0,d1
		andi.w	#07,d0
		lsr.w	#3,d1
		lea	cu_RawEvents(a2),a0
		btst	d0,0(a0,d1.w)
		beq	checkRepeatFlush
	    ;------ build the input event control sequence
		move.l	ie_TimeStamp+TV_MICRO(a3),d0
		bclr	#31,d0			; ensure not negative
		move.l	d0,-(a7)
		move.l	ie_TimeStamp+TV_SECS(a3),d0
		bclr	#31,d0			; ensure not negative
		move.l	d0,-(a7)
		moveq	#0,d0
		move.w	ie_Y(a3),d0
		move.l	d0,-(a7)
		move.w	ie_X(a3),d0
		move.l	d0,-(a7)
		move.w	ie_Qualifier(a3),d0
		move.l	d0,-(a7)
		move.w	ie_Code(a3),d0
		move.l	d0,-(a7)
		moveq	#0,d0
		move.b	ie_SubClass(a3),d0
		move.w	d0,-(a7)
		move.b	ie_Class(a3),d0
		move.w	d0,-(a7)
		move.l	a7,a1
		movem.l	a2/a3,-(a7)
		lea	ieFormat(pc),a0
		lea	-CD_CONVBUFSIZE(a5),a3
		lea	rawPutConvBuff(pc),a2
		LINKEXE	RawDoFmt
		movem.l	(a7)+,a2/a3
		lea	28(a7),a7

		;--	determine size of input event control sequence
		lea	-CD_CONVBUFSIZE(a5),a0
		moveq	#-1,d0
peSizeLoop:
		tst.b	(a0)+
		dbeq	d0,peSizeLoop
		not.w	d0
		bra	normalKey	;was .s!

ieFormat:
		dc.b	$9B
		dc.b	'%d;%d;%ld;%ld;%ld;%ld;%ld;%ld|'
		dc.b	0
		ds.w	0


rawPutConvBuff:
		move.b	d0,(a3)+
		rts

		;-- check for repeat-ahead flush
checkRepeatFlush:
		btst.b	#IEQUALIFIERB_REPEAT&7,ie_Qualifier(a3)
		beq.s	convertKey

		lea	MP_MSGLIST(a2),a1
		cmp.l	LH_TAIL+LN_PRED(a1),a1
		beq	ckRts		; no pending reader -- flush repeat

		;-- convert keycode into buffer
convertKey:
		move.l	a2,-(a7)	; save the unit
		move.l	a3,a0
		lea	-CD_CONVBUFSIZE(a5),a1
		move.l	#CD_CONVBUFSIZE,d1
		lea	cu_KeyMapStruct(a2),a2
		LINKKEY	MapRawKey
		move.l	(a7)+,a2	; restore the unit

		tst.w	d0		; get buffer actual
		beq.s	ckRts		;   nothing there

		;-- check for paste here
		cmp.w	#1,d0
		bne.s	normalKey
		btst.b	#IEQUALIFIERB_RCOMMAND,ie_Qualifier+1(a3)
		beq.s	normalKey
		move.b	-CD_CONVBUFSIZE(a5),d1
		and.b	#$df,d1
		cmp.b	#'V',d1
		bne.s	ifCopy

		;--	paste last selection
		bsr	PutReadSnip
		bra.s	nkDispatchDone

		;--	copy selection
ifCopy:		cmp.b	#'C',d1
		bne.s	normalKey
		
		bset	#CDIB_COPY,cd_InputFlags(a6)

		;--  signal task

		move.l	d0,-(sp)
		move.l	#CDSIGF_SELECT,d0
		lea	cd_TC(a6),a1
		LINKEXE	Signal
		move.l	(sp)+,d0		
		bra.s	nkDispatchDone

normalKey:
		lea	-CD_CONVBUFSIZE(a5),a0
		bsr	PutReadData

nkDispatchDone:
		tst.l	d0
		beq.s	ckRts

		bset	#DUB_DISPATCH,du_Flags(a2)
		moveq	#1,d2

ckRts:
		rts


	END
@


36.35
log
@Cache qualifier for mouse tracking
@
text
@d2 1
a2 1
**	$Id: inputhandler.asm,v 36.34 91/05/22 13:47:51 darren Exp Locker: darren $
a188 4
		;-- cache most current qualifier bits

		move.w	ie_Qualifier(a3),cd_MouseQual(a6)

d405 7
a415 3

		cmpi.b	#IECLASS_RAWMOUSE,d0
		bne.s	deNoSelect
@


36.34
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: inputhandler.asm,v 36.33 91/04/12 17:40:12 darren Exp Locker: darren $
d189 4
@


36.33
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: inputhandler.asm,v 36.32 91/02/14 14:55:06 darren Exp Locker: darren $
@


36.32
log
@Autodoc stuff
@
text
@d2 1
a2 1
**	$Id: inputhandler.asm,v 36.31 91/02/04 14:29:38 darren Exp Locker: darren $
@


36.31
log
@Added some comments / played with an idea / no code changes.
@
text
@d2 1
a2 1
**	$Id: inputhandler.asm,v 36.30 90/11/20 18:39:05 darren Exp Locker: darren $
d59 1
a59 1
*	CDInputHandler - handle an input event for the console device
@


36.30
log
@Fix for SIZEWINDOW/CHANGEWINDOW class messages from
Intuition - works with Intuition rev .4130, or later.  Now
broadcasts RAWINPUT events to the right window instead
of the active console window.
@
text
@d2 1
a2 1
**	$Id: inputhandler.asm,v 36.29 90/11/09 20:26:23 darren Exp Locker: darren $
d176 1
d183 1
d187 1
d256 2
a257 1
*
@


36.29
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: inputhandler.asm,v 36.28 90/11/07 15:22:05 darren Exp $
d309 12
d323 3
a325 1
IEWINDOWCLASS	EQU	IEWINDOWCLASS1!IEWINDOWCLASS2
@


36.28
log
@Added code to support RIGHT AMIGA C.
@
text
@d2 1
a2 1
**	$Id: inputhandler.asm,v 36.27 90/11/02 08:31:09 darren Exp Locker: darren $
@


36.27
log
@short branch optimizations
@
text
@d2 1
a2 1
**	$Id: inputhandler.asm,v 36.26 90/11/01 11:21:16 darren Exp Locker: darren $
d464 1
a464 1
		bra.s	normalKey
d484 1
a484 1
		beq.s	ckRts		; no pending reader -- flush repeat
d507 8
d516 4
d521 5
a525 2
		;--	copy selection, not 'V'
		bsr	PutReadSnip
@


36.26
log
@New code added for a new input handling scheme which tracks
history of events.
@
text
@d2 1
a2 1
**	$Id: inputhandler.asm,v 36.25 90/05/30 14:23:39 kodiak Exp Locker: darren $
d270 1
a270 1
		beq	dispatchA2
d464 1
a464 1
		bra	normalKey
d497 1
a497 1
		beq	ckRts		;   nothing there
@


36.25
log
@notice left button up using new PeekQualifier input.device function
@
text
@d2 1
a2 1
**	$Id: inputhandler.asm,v 36.24 90/05/16 11:34:31 kodiak Exp Locker: kodiak $
d16 1
a16 1

d98 58
d171 1
a172 1

d174 1
a174 1
		movem.l	d2/d4/a2-a4/a6,-(a7)
a199 1
		bset	#CUB_NEWACTIVE,cu_Flags(a2)
d201 5
d209 1
d217 1
a218 1
		bset	#CUB_NEWACTIVE,cu_Flags(a2)
d220 5
d229 1
a229 1
		bra.s	dispatchActive
d237 1
a237 1
		beq.s	chkNextEvent
a240 1
		bra.s	dispatchA2
d242 1
d244 15
d273 11
d286 1
d376 1
a376 1
		movem.l	(a7)+,d2/d4/a2-a4/a6
d414 1
d526 1
@


36.24
log
@Fixes reporting of events via raw event control sequence
@
text
@d2 1
a2 1
**	$Id: inputhandler.asm,v 36.23 90/05/14 23:15:27 kodiak Exp $
d302 1
a302 1
		bne.s	deCheckUpSelect
d307 2
a308 4
		bne.s	deXSelect
		or.b	#CDSF_SELECTDOWN,cd_SelectFlags(a6)
		bra.s	deSelectSignal
deXSelect:
d311 3
a313 8

deCheckUpSelect:
		btst	#CDSB_SELECTDOWN,cd_SelectFlags(a6)
		beq.s	deNoSelect
		btst	#IEQUALIFIERB_LEFTBUTTON&7,ie_Qualifier(a3)
		bne.s	deNoSelect

		and.b	#CDS_SELECTMASK!CDSF_SELECTING,cd_SelectFlags(a6)
@


36.23
log
@better button up code
@
text
@d2 1
a2 1
**	$Id: inputhandler.asm,v 36.22 90/05/11 09:57:09 kodiak Exp Locker: kodiak $
d45 3
d199 1
a199 1
		btst	#IEQUALIFIERB_MULTIBROADCAST,ie_Qualifier(a3)
d372 1
a372 1
		tst.b	(a1)+
@


36.22
log
@catch more cases of left button up when mixed w/ right button activity
@
text
@d2 1
a2 1
**	$Id: inputhandler.asm,v 36.21 90/04/20 09:45:26 kodiak Exp Locker: kodiak $
d317 1
a317 1
		and.b	#CDS_SELECTMASK,cd_SelectFlags(a6)
@


36.21
log
@first semi-tested big clip support
@
text
@d2 1
a2 1
**	$Id: inputhandler.asm,v 36.20 90/04/13 13:32:31 kodiak Exp Locker: kodiak $
d42 3
d312 3
a314 1
		cmpi.w	#IECODE_LBUTTON!IECODE_UP_PREFIX,d1
@


36.20
log
@use Id instead of Header for 4.x rcs
@
text
@d2 1
a2 1
**	$Id$
d15 1
d24 1
a24 2
	XLVO	Forbid			; Exec
	XLVO	ObtainSemaphoreShared	;
d32 2
a33 2
	XREF	PutBBuff
	XREF	SizeBuff
d252 3
a254 1
		LINKEXE	Forbid
d261 2
a262 1
		LINKEXE	Permit
d323 1
a323 1
		bhi	convertKey
d329 1
a329 1
		beq	convertKey
d358 1
a358 1
		add.w	#28,a7
d362 1
a362 1
		moveq	#-1,d4
d364 3
a366 11
		tst.b	(a0)+
		dbeq	d4,peSizeLoop
		not.w	d4

		;--	get room available in read buffer
		lea	cu_ReadBuffer(a2),a0
		bsr	SizeBuff
		sub.w	cu_ReadBuffer+bf_StoreSize(a2),d0
		neg.w	d0

		;--	copy input into buffer
a368 1

d380 10
a389 1
	    ;------ the input device specs are kept up to date for the window
d394 1
a394 1
		moveq	#CD_CONVBUFSIZE,d1
d399 2
a400 2
		move.w	d0,d4			; get copy buffer size
		beq	ckRts			;   nothing there
a401 16
		;-- check for repeat-ahead flush
		btst.b	#IEQUALIFIERB_REPEAT&7,ie_Qualifier(a3)
		beq.s	ckAvailBuff

		lea	MP_MSGLIST(a2),a1
		cmp.l	LH_TAIL+LN_PRED(a1),a1
		beq.s	ckRts		; no pending reader -- flush repeat


		;--	get room available in read buffer
ckAvailBuff:
		lea	cu_ReadBuffer(a2),a0
		bsr	SizeBuff
		sub.w	cu_ReadBuffer+bf_StoreSize(a2),d0
		neg.w	d0

d403 1
a403 1
		cmp.w	#1,d4
d412 2
a413 17
		;--	copy selection, not 'P'
		move.w	cd_SelectionActual(a6),d4
		cmp.w	d0,d4			; check if enough room
		bgt.s	ckRts			;   no, don't copy any of it

		move.l	cd_SelectionText(a6),a4
		bra.s	pcDBF
pcLoop:
		move.b	(a4)+,d0
		cmp.b	#$0a,d0
		bne.s	pcPut
		move.b	#$0d,d0		; convert LF to CR
pcPut:
		lea	cu_ReadBuffer(a2),a0
		bsr	PutBBuff
pcDBF:
		dbf	d4,pcLoop
a415 1

d417 2
a418 10
		cmp.w	d0,d4			; check if enough room
		bgt.s	ckRts			;   no, don't copy any of it
		lea	-CD_CONVBUFSIZE(a5),a4	; get beginning of copy buffer
		bra.s	nkDBF			; go to end of copy loop
nkLoop:
		move.b	(a4)+,d0
		lea	cu_ReadBuffer(a2),a0
		bsr	PutBBuff
nkDBF:
		dbf	d4,nkLoop
d421 3
@


36.19
log
@for 4.x rcs
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/inputhandler.asm,v 36.18 90/02/21 18:40:26 kodiak Exp Locker: kodiak $
@


36.18
log
@first cut at drag-select
@
text
@d2 1
a2 1
**	$Header: inputhandler.asm,v 36.17 90/01/30 15:56:18 kodiak Exp $
@


36.17
log
@fix B6410: make paste 'P', not 'V'
@
text
@d2 1
a2 1
**	$Header: inputhandler.asm,v 36.16 90/01/15 10:08:56 kodiak Exp $
d295 1
a297 4
		beq.s	deNoSelect
		and.b	#CDS_SELECTMASK,cd_SelectFlags(a6)
		move.w	ie_Qualifier(a3),d1
		and.w	#IEQUALIFIER_LALT!IEQUALIFIER_RALT,d1
d299 1
a299 1
		or.b	#CDSF_SELECT,cd_SelectFlags(a6)
d302 1
a302 1
		or.b	#CDSF_SELECT!CDSF_EXTENDED,cd_SelectFlags(a6)
@


36.16
log
@don't corrupt event w/ ObtainSemaphore
@
text
@d2 1
a2 1
**	$Header: inputhandler.asm,v 36.15 89/12/19 13:27:26 kodiak Exp $
d425 1
a425 1
		cmp.b	#'P',d1
@


36.15
log
@autodoc update
@
text
@d2 1
a2 1
**	$Header: inputhandler.asm,v 36.14 89/12/19 11:03:18 kodiak Exp $
d115 1
a121 1
		move.l	d0,a3
d201 1
a201 1
		bsr.s	dispatchEvent
d235 3
a237 1
		bne	loopEvents
d239 1
@


36.14
log
@eliminate private ObtainSemaphoreShared & ReleaseSemaphore -- use exec's
@
text
@d2 1
a2 1
**	$Header: inputhandler.asm,v 36.13 89/12/17 19:35:34 kodiak Exp $
d50 1
a50 1
******* console.device/function/CDInputHandler ***********************
@


36.13
log
@fix cursor ghosting when non-console window activated
@
text
@d2 1
a2 1
**	$Header: inputhandler.asm,v 36.12 89/12/02 11:36:47 kodiak Exp $
d24 1
d27 1
a34 3
	XREF	ObtainSemaphoreShared
	XREF	ReleaseSemaphore

d118 1
a118 1
		bsr	ObtainSemaphoreShared
d264 1
a264 1
		bsr	ReleaseSemaphore
@


36.12
log
@checkpoint after line buffer coding completed,
and just after start of line length coding
@
text
@d2 1
a2 1
**	$Header$
a147 1
		move.l	#CDSIGF_NEWACTIVE,d0
d153 1
@


36.11
log
@first cut at line buffers
@
text
@d2 1
a2 1
**	$Header: inputhandler.asm,v 36.10 89/11/04 16:03:08 kodiak Exp $
d4 1
a4 1
**	console.device input handler
d9 1
d11 1
a11 1
	SECTION		rawinput
d13 1
a13 1
*------ Included Files -----------------------------------------------
a14 1
	INCLUDE		"cddata.i"
d16 1
d18 1
a18 1
*------ Imported Names -----------------------------------------------
d20 3
d30 2
a31 2
	XREF		PutBBuff
	XREF		SizeBuff
d33 2
a34 2
	XREF		ObtainSemaphoreShared
	XREF		ReleaseSemaphore
d36 1
a36 1
	XREF		ReSizePost
d38 1
a38 1
	XREF		CDRead
d41 1
a41 1
*------ Exported Functions -------------------------------------------
d43 6
a48 1
	XDEF		CDInputHandler
a400 3
	IFNE	IEQUALIFIERB_REPEAT/8-1
	FAIL	"IEQUALIFIERB_REPEAT not in high byte, recode"
	ENDC
a418 3
	IFNE	IEQUALIFIERB_RCOMMAND/8
	FAIL	"IEQUALIFIERB_RCOMMAND not in low byte, recode"
	ENDC
@


36.10
log
@restructure map variables
use XLVO macro strategy
@
text
@d2 1
a2 1
**	$Header: inputhandler.asm,v 36.9 89/09/15 15:42:14 kodiak Exp $
d172 1
a172 1
		tst.w	cu_CM+cm_Elements(a2)
d274 1
a274 1
		tst.w	cu_CM+cm_Elements(a2)	; check for character map
@


36.9
log
@use *shift* left for select, *alt shift* for extended select,
right command P for paste
restructure event code so the control sequence is all or none
use new intuition IECODE_EVENT for REFRESH and NEWSIZE
@
text
@d2 1
a2 1
**	$Header$
d19 4
a22 4
	XREF_EXE	Forbid
	XREF_EXE	Permit
	XREF_EXE	RawDoFmt
	XREF_EXE	Signal
d24 1
a24 1
	XREF_KEY	MapRawKey
d172 1
a172 1
		tst.w	cu_BufferSize(a2)
d274 1
a274 1
		tst.w	cu_BufferSize(a2)	; check for character map
@


36.8
log
@cu_BufferSize is UWORD (was ULONG)
@
text
@d1 8
a8 53
	TTL    '$Header: inputhandler.asm,v 36.7 89/06/28 19:14:20 kodiak Exp $'
**********************************************************************
*                                                                    *
*   Copyright 1985, Commodore-Amiga Inc.   All rights reserved.      *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030                                     *
*                                                                    *
**********************************************************************
*
*	Console device input handler
*
*   Source Control
*   --------------
*   $Header: inputhandler.asm,v 36.7 89/06/28 19:14:20 kodiak Exp $
*
*   $Locker: kodiak $
*
*   $Log:	inputhandler.asm,v $
*   Revision 36.7  89/06/28  19:14:20  kodiak
*   better avoidance of cursor spoor
*   
*   Revision 36.6  89/06/28  14:13:43  kodiak
*   signal window activation for cursor ghosting
*   obtain shared lock for unit reading
*   
*   Revision 36.5  89/04/19  16:17:11  kodiak
*   fix cd_SelectFlags usage to avoid sending timer io twice
*   
*   Revision 36.4  89/04/17  15:35:25  kodiak
*   only clear appropriate bits in cd_SelectFlags
*   
*   Revision 36.3  89/01/01  15:19:25  kodiak
*   fix refresh of consoles
*   
*   Revision 36.2  89/01/10  16:46:31  kodiak
*   *** empty log message ***
*   
*   Revision 36.1  88/09/19  10:15:47  kodiak
*   add character map and pseudo-clipboard support
*   
*   Revision 36.0  88/09/06  19:51:48  kodiak
*   *** empty log message ***
*   
*   Revision 35.0  87/10/26  11:12:47  kodiak
*   initial from V34, but w/ stripped log
*   
*
**********************************************************************
d24 2
a28 2
	XREF		_LVORawKeyConvert

a39 1
	XDEF		rawPutBBuff
d49 1
a49 1
*		       A0      A1
d84 17
d102 6
a107 6
		MOVEM.L	D2/D4/A2-A4/A6,-(A7)
		LINK	A5,#-((CD_CONVBUFSIZE+1)&$fffe)	; ensure even
		MOVE.L	A1,A6		; get console device base
		MOVE.L	A0,D0
		BEQ	cdihRts
		MOVEQ	#0,D2
d113 4
a116 5
		MOVE.L	D0,A3
		CMPI.B	#IECLASS_EVENT,ie_Class(A3)
		BNE.S	activeCorrect
		CMPI.W	#IECODE_NEWACTIVE,ie_Code(A3)
		BNE.S	activeCorrect
d118 10
a127 5
	    ;------ a new intuition window is active
		move.l	#CDSIGF_NEWACTIVE,d0
		move.l	cd_Active(a6),d1
		beq.s	findAUnit
		move.l	d1,a2
d130 7
a136 5
findAUnit:
		CLR.L	cd_Active(A6)		; guess not console unit
		MOVE.L	ie_EventAddress(A3),A1	; get new active window
		MOVE.L	A1,cd_ActiveWindow(A6)	;   and save it
		MOVE.L	cd_UHead(A6),A2		; get first unit
d138 4
a141 11
nextAUnit:
		TST.L	(A2)
		BEQ	checkOldA
		CMP.L	cu_Window(A2),A1
		BEQ.S	newAUnit
		MOVE.L	(A2),A2		; next unit
		BRA.S	nextAUnit

newAUnit:	
		MOVE.L	A2,cd_Active(A6)
		and.b	#CDS_CLEARMASK,cd_SelectFlags(a6)
a142 1
		bra.s	signalTC
d145 1
a145 1
		tst.l	d1
d147 1
a147 1
		bra.s	chkNextEvent
d150 6
a155 13
activeCorrect:
		cmpi.b	#IECLASS_REFRESHWINDOW,ie_Class(a3)
		bne.s	checkMultibroadcast
	    ;-- check for a refresh on a buffered console
		MOVE.L	ie_EventAddress(A3),A1	; get refreshed window
		MOVE.L	cd_UHead(A6),A2		; get first unit
nextRUnit:
		TST.L	(A2)
		BEQ	chkNextEvent	; cannot find unit, no refresh
		CMP.L	cu_Window(A2),A1
		BEQ.S	foundRUnit
		MOVE.L	(A2),A2		; next unit
		BRA.S	nextRUnit
d157 15
a171 1
foundRUnit:
d173 2
a174 1
		beq	chkNextEvent
d181 1
a181 1
		bra.s	chkNextEvent
d185 2
a186 2
		BTST	#IEQUALIFIERB_MULTIBROADCAST,ie_Qualifier(A3)
		BEQ.S	activeOnly
d188 2
a189 2
;------ dispatch input for all console windows
		MOVE.L	cd_UHead(A6),A2		; get first unit
d191 5
a195 6
		TST.L	(A2)
		BEQ.S	chkNextEvent	; no more units
		BSR	dispatchEvent
		ASR.W	#1,D2
		MOVE.L	(A2),A2		; next unit
		BRA.S	nextDUnit
d198 8
a205 5
;------ dispatch input for active window
activeOnly:
		MOVE.L	cd_Active(A6),D0
		BEQ	chkNextEvent
		MOVE.L	D0,A2
d207 8
a214 4
		; check for resize special case
		CMPI.B	#IECLASS_SIZEWINDOW,ie_Class(A3)
		BNE.S	dispatchActive
		BSR	ReSizePost
d216 4
a219 1
		BSR.S	dispatchEvent
d221 4
d226 2
a227 2
		MOVE.L	(A3),D0
		BNE	loopEvents
d229 2
a230 5
		TST	D2
		BEQ.S	releaseUSem
	    ;------ satisfy any pending read with the new data
		BTST	#14,D2			; check for multibroadcast
		BEQ.S	pendingActive
d232 18
a249 1
		MOVE.L	cd_UHead(A6),A2		; get first unit
d251 2
a252 5
		TST.L	(A2)
		BEQ.S	releaseUSem		; no more units
		BSR.S	satisfyEvent
		MOVE.L	(A2),A2		; next unit
		BRA.S	nextReadUnit
a253 6
pendingActive:
		MOVE.L	cd_Active(A6),D0
		BEQ.S	releaseUSem
		MOVE.L	D0,A2
		BSR.S	satisfyEvent

d259 4
a262 4
		MOVEQ	#0,D0
		UNLK	A5
		MOVEM.L	(A7)+,D2/D4/A2-A4/A6
		RTS
d266 1
a266 1
;***	satisfyEvent - pass the event to unit A2
d268 3
a270 5
satisfyEvent:
		LINKEXE	Forbid
		MOVE.L	MP_MSGLIST(A2),A1
		TST.L	(A1)
		BEQ.S	cdihPermit
d272 1
a272 13
		BSR	CDRead
cdihPermit:
		LINKEXE	Permit
		RTS


;***
;***	dispatchEvent - pass the event to unit A2
;***
dispatchEvent:
		MOVEQ	#0,D0
		MOVE.B	ie_Class(A3),D0
		btst	#1,cu_DevUnit+3(a2)
d274 1
a274 1
		tst.w	cu_BufferSize(a2)
d276 1
d279 3
a281 1
		cmpi.w	#IECODE_LBUTTON,ie_Code(a3)
d283 1
a283 2
		bset.b	#CDSB_ACTIVE,cd_SelectFlags(a6)
		beq.s	deNoPaste
d286 4
a290 1
		and.b	#CDS_SELECTMASK,cd_SelectFlags(a6)
a293 1
		and.b	#CDS_SELECTMASK,cd_SelectFlags(a6)
d296 1
d298 3
a300 2
		cmpi.w	#IECODE_LBUTTON!IECODE_UP_PREFIX,ie_Code(a3)
		bne.s	deNoPaste
d302 1
a308 1
		bra.s	deNoPaste
a309 1
		;-- check for paste
d311 11
a321 8
		CMPI.B	#IECLASS_MENULIST,d0
		beq.s	dePaste
		cmpi.b	#IECLASS_RAWMOUSE,d0
		bne.s	deNoPaste
		cmpi.w	#IECODE_RBUTTON,ie_Code(a3)
		bne.s	deNoPaste

dePaste:
d323 22
a344 41
		move.l	#CDSIGF_PASTE,d0
		lea	cd_TC(a6),a1
		LINKEXE	Signal
		move.l	(a7)+,d0
		
deNoPaste:
		CMPI.B	#IECLASS_MAX,D0
		BHI	convertKey
		MOVE.W	D0,D1
		ANDI.W	#07,D0
		LSR.W	#3,D1
		LEA	cu_RawEvents(A2),A0
		BTST	D0,0(A0,D1.W)
		BEQ	convertKey
	    ;------ build the input event control sequence
		MOVE.L	ie_TimeStamp+TV_MICRO(A3),D0
		BCLR	#31,D0			; ensure not negative
		MOVE.L	D0,-(A7)
		MOVE.L	ie_TimeStamp+TV_SECS(A3),D0
		BCLR	#31,D0			; ensure not negative
		MOVE.L	D0,-(A7)
		MOVEQ	#0,D0
		MOVE.W	ie_Y(A3),D0
		MOVE.L	D0,-(A7)
		MOVE.W	ie_X(A3),D0
		MOVE.L	D0,-(A7)
		MOVE.W	ie_Qualifier(A3),D0
		MOVE.L	D0,-(A7)
		MOVE.W	ie_Code(A3),D0
		MOVE.L	D0,-(A7)
		MOVEQ	#0,D0
		MOVE.B	ie_SubClass(A3),D0
		MOVE.W	D0,-(A7)
		MOVE.B	ie_Class(A3),D0
		MOVE.W	D0,-(A7)
		MOVE.L	A7,A1
		MOVEM.L	A2/A3,-(A7)
		LEA	ieFormat(PC),A0
		LEA	cu_ReadBuffer(A2),A3
		LEA	rawPutBBuff(PC),A2
		LINKEXE	Forbid
d346 2
a347 5
		LINKEXE	Permit
		MOVEM.L	(A7)+,A2/A3
		ADD.W	#28,A7
		OR.W	#$8000,D2
		RTS
d349 18
d368 4
a371 4
		DC.B	$9B
		DC.B	'%d;%d;%ld;%ld;%ld;%ld;%ld;%ld|'
		DC.B	0
		DS.W	0
d374 3
a376 7
rawPutBBuff:
		TST	D0
		BEQ.S	1$
		MOVE.L	A3,A0
		BSR	PutBBuff
1$
		RTS
d380 7
a386 8
		MOVE.L	(A3),A4		; stash the next event
		CLR.L	(A3)		; only convert this event
		MOVE.L	A2,-(A7)	; save the unit
		MOVE.L	A3,A0
		LEA	-CD_CONVBUFSIZE(A5),A1
		MOVEQ	#CD_CONVBUFSIZE,D1
		LEA	cu_KeyMapStruct(A2),A2
		CALLLIB _LVORawKeyConvert
d388 2
a389 19
		MOVE.L	(A7)+,A2	; restore the unit
		MOVE.L	A4,(A3)		; restore next event
		MOVE.W	D0,D4			; get copy buffer size
		BEQ.S	3$			;   nothing there
		LEA	cu_ReadBuffer(A2),A0
		BSR	SizeBuff
		SUB.W	cu_ReadBuffer+bf_StoreSize(A2),D0
		NEG.W	D0
		CMP.W	D0,D4			; check if enough room
		BGT.S	3$			;   no, don't copy any of it
		LEA	-CD_CONVBUFSIZE(A5),A4	; get beginning of copy buffer
		BRA.S	2$			; go to end of copy loop
1$
		MOVE.B	(A4)+,D0
		LEA	cu_ReadBuffer(A2),A0
		BSR	PutBBuff
2$
		DBF	D4,1$
		OR.W	#$8000,D2
d391 6
a396 2
3$
		RTS
d398 3
d403 60
a462 1
		END
@


36.7
log
@better avoidance of cursor spoor
@
text
@d1 1
a1 1
	TTL    '$Header: inputhandler.asm,v 36.6 89/06/28 14:13:43 kodiak Exp $'
d19 1
a19 1
*   $Header: inputhandler.asm,v 36.6 89/06/28 14:13:43 kodiak Exp $
d21 1
a21 1
*   $Locker:  $
d24 3
d196 1
a196 1
		tst.l	cu_BufferSize(a2)
d293 1
a293 1
		tst.l	cu_BufferSize(a2)
@


36.6
log
@signal window activation for cursor ghosting
obtain shared lock for unit reading
@
text
@d1 1
a1 1
	TTL    '$Header: inputhandler.asm,v 36.5 89/04/19 16:17:11 kodiak Exp $'
d19 1
a19 1
*   $Header: inputhandler.asm,v 36.5 89/04/19 16:17:11 kodiak Exp $
d24 4
d146 2
a147 1
		move.l	cd_Active(a6),d0
d149 1
a149 1
		move.l	d0,a2
d160 1
a160 1
		BEQ	chkNextEvent
a168 2

fountAUnit:
a169 1
		move.l	#CDSIGF_NEWACTIVE,d0
d171 5
@


36.5
log
@fix cd_SelectFlags usage to avoid sending timer io twice
@
text
@d1 1
a1 1
	TTL    '$Header: inputhandler.asm,v 36.4 89/04/17 15:35:25 kodiak Exp $'
d19 1
a19 1
*   $Header: inputhandler.asm,v 36.4 89/04/17 15:35:25 kodiak Exp $
d21 1
a21 1
*   $Locker: kodiak $
d24 3
d67 3
d131 3
d140 1
d142 6
d152 1
d155 1
a155 1
		BEQ	chkNextEvent	; cannot find unit, no active
d165 6
d187 1
a187 1
		beq.s	checkMultibroadcast
d189 3
a192 1
		move.l	#CDSIGF_REFRESH,d0
d194 1
d196 1
d206 1
a206 1
		BSR.S	dispatchEvent
d230 1
a230 1
		BEQ.S	cdihRts
d238 1
a238 1
		BEQ.S	cdihRts		; no more units
d245 1
a245 1
		BEQ.S	cdihRts
d248 5
d311 3
d321 1
@


36.4
log
@only clear appropriate bits in cd_SelectFlags
@
text
@d1 1
a1 1
	TTL    '$Header: inputhandler.asm,v 36.3 89/01/01 15:19:25 kodiak Exp $'
d19 1
a19 1
*   $Header: inputhandler.asm,v 36.3 89/01/01 15:19:25 kodiak Exp $
d24 3
d146 1
d257 2
d262 1
a262 1
		and.b	#CDS_CLEARMASK,cd_SelectFlags(a6)
d266 1
a266 1
		and.b	#CDS_CLEARMASK,cd_SelectFlags(a6)
d271 2
a272 2
		bne.s	deNoSelect
		and.b	#CDS_CLEARMASK,cd_SelectFlags(a6)
@


36.3
log
@fix refresh of consoles
@
text
@d1 1
a1 1
	TTL    '$Header: inputhandler.asm,v 36.2 89/01/10 16:46:31 kodiak Exp $'
d19 1
a19 1
*   $Header: inputhandler.asm,v 36.2 89/01/10 16:46:31 kodiak Exp $
d21 1
a21 1
*   $Locker:  $
d24 3
d256 2
a257 1
		move.b	#CDSF_SELECT,cd_SelectFlags(a6)
d260 2
a261 1
		move.b	#CDSF_SELECT!CDSF_EXTENDED,cd_SelectFlags(a6)
d266 1
a266 1
		clr.b	cd_SelectFlags(a6)
@


36.2
log
@*** empty log message ***
@
text
@d1 1
a1 1
	TTL    '$Header: inputhandler.asm,v 36.1 88/09/19 10:15:47 kodiak Exp $'
d19 1
a19 1
*   $Header: inputhandler.asm,v 36.1 88/09/19 10:15:47 kodiak Exp $
d21 1
a21 1
*   $Locker: kodiak $
d24 3
a141 2
		tst.l	cu_BufferSize(a2)
		beq.s	checkMultibroadcast
d156 2
@


36.1
log
@add character map and pseudo-clipboard support
@
text
@d1 1
a1 1
	TTL    '$Header: inputhandler.asm,v 36.0 88/09/06 19:51:48 kodiak Exp $'
d19 1
a19 1
*   $Header: inputhandler.asm,v 36.0 88/09/06 19:51:48 kodiak Exp $
d21 1
a21 1
*   $Locker:  $
d24 3
a55 1
	XREF		RefreshUnit
a247 2
		btst	#IEQUALIFIERB_RCOMMAND,d1
		beq.s	deNoSelect
@


36.0
log
@*** empty log message ***
@
text
@d1 1
a1 1
	TTL    '$Header: inputhandler.asm,v 35.0 87/10/26 11:12:47 kodiak Exp $'
d19 1
a19 1
*   $Header: inputhandler.asm,v 35.0 87/10/26 11:12:47 kodiak Exp $
d24 3
d45 1
d53 1
d137 22
d197 1
a197 1
nextRUnit:
d202 1
a202 1
		BRA.S	nextRUnit
d237 43
@
