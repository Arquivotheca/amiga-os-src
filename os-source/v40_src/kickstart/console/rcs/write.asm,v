head     36.73;
branch   ;
access   ;
symbols  V39_4:36.64 V37_157:36.64 V37_149:36.64 V37_136:36.64 V37_133:36.64 V37_110:36.64 V37_98:36.64 V37_85:36.64 V37_63:36.63 V37_36:36.62 V37_15:36.60 V37_10:36.59 V37_7:36.59 V37_2:36.59 V36_558:36.59 V36_554:36.58 V36_552:36.57 V36_549:36.55 V36_548:36.55 V36_547:36.55 V36_546:36.55 V36_545:36.55 V36_544:36.55 V36_543:36.54 V36_542:36.54 V36_540:36.52 V36_539:36.52 V36_538:36.52 V36_537:36.52 V36_536:36.51 V36_529:36.47 V36_527:36.47 V36_525:36.46 V36_524:36.46 V36_523:36.45 V36_522:36.45 V36_521:36.44 V36_520:36.44 V36_519:36.44 V36_518:36.44 V36_495:36.40 V36_491:36.39 V36_486:36.39 V36_482:36.38 V36_476:36.38 V36_471:36.37 V36_465:36.36 V36_463:36.36 V36_461:36.36 V36_460:36.36 V36_453:36.36 V36_447:36.34 V36_442:36.33 V36_429:36.32 V36_423:36.31 V36_413:36.31 V36_394:36.30 V36_387:36.28 V36_382:36.27 V36_381:36.27 V36_379:36.26 V36_373:36.25 V36_367:36.24 V36_361:36.24 V36_359:36.24 V36_357:36.24 V36_353:36.24 V36_346:36.24 V36_343:36.24 V36_338:36.23 V36_332:36.23 V36_327:36.23 V36_321:36.23 V36_319:36.23 V36_318:36.23 V36_316:36.23 V36_313:36.23 V36_311:36.23 V36_310:36.23 V36_300:36.22 V36_299:36.21 V36_297:36.19 V36_295:36.19 V36_278:36.19 V36_274:36.18 V36_221:36.14 V36_205:36.13 V36_171:36.12 V36_167:36.12 V36_165:36.8 V36_153:36.7 V36_146:36.6 V36_140:36.5 V36_129:36.4 V36_113:36.3 V36_56:36.2 V36_53:36.2 V36_51:36.2 V36_45:36.2 L36_42:36.1;
locks    ; strict;
comment  @*   @;


36.73
date     92.12.15.10.44.26;  author darren;  state Exp;
branches ;
next     36.72;

36.72
date     92.09.17.14.26.27;  author darren;  state Exp;
branches ;
next     36.71;

36.71
date     92.06.16.10.46.05;  author darren;  state Exp;
branches ;
next     36.70;

36.70
date     92.03.26.14.27.52;  author darren;  state Exp;
branches ;
next     36.69;

36.69
date     92.03.26.13.49.54;  author darren;  state Exp;
branches ;
next     36.68;

36.68
date     92.03.24.17.02.45;  author darren;  state Exp;
branches ;
next     36.67;

36.67
date     92.03.24.12.12.37;  author darren;  state Exp;
branches ;
next     36.66;

36.66
date     92.03.23.12.46.34;  author darren;  state Exp;
branches ;
next     36.65;

36.65
date     92.03.19.12.43.53;  author darren;  state Exp;
branches ;
next     36.64;

36.64
date     91.03.13.16.45.00;  author darren;  state Exp;
branches ;
next     36.63;

36.63
date     91.02.22.13.22.12;  author darren;  state Exp;
branches ;
next     36.62;

36.62
date     91.02.14.14.57.51;  author darren;  state Exp;
branches ;
next     36.61;

36.61
date     91.02.12.09.31.52;  author darren;  state Exp;
branches ;
next     36.60;

36.60
date     91.01.23.16.16.23;  author darren;  state Exp;
branches ;
next     36.59;

36.59
date     91.01.03.18.51.13;  author darren;  state Exp;
branches ;
next     36.58;

36.58
date     90.12.26.15.06.43;  author darren;  state Exp;
branches ;
next     36.57;

36.57
date     90.12.12.15.39.14;  author darren;  state Exp;
branches ;
next     36.56;

36.56
date     90.12.03.15.09.02;  author darren;  state Exp;
branches ;
next     36.55;

36.55
date     90.11.29.19.45.43;  author darren;  state Exp;
branches ;
next     36.54;

36.54
date     90.11.20.18.50.12;  author darren;  state Exp;
branches ;
next     36.53;

36.53
date     90.11.14.13.37.42;  author darren;  state Exp;
branches ;
next     36.52;

36.52
date     90.11.05.18.04.29;  author darren;  state Exp;
branches ;
next     36.51;

36.51
date     90.11.02.07.59.53;  author darren;  state Exp;
branches ;
next     36.50;

36.50
date     90.11.01.16.51.55;  author darren;  state Exp;
branches ;
next     36.49;

36.49
date     90.11.01.16.35.26;  author darren;  state Exp;
branches ;
next     36.48;

36.48
date     90.11.01.11.24.47;  author darren;  state Exp;
branches ;
next     36.47;

36.47
date     90.10.11.15.29.31;  author darren;  state Exp;
branches ;
next     36.46;

36.46
date     90.10.08.11.25.51;  author darren;  state Exp;
branches ;
next     36.45;

36.45
date     90.08.13.13.57.32;  author darren;  state Exp;
branches ;
next     36.44;

36.44
date     90.06.07.13.57.05;  author kodiak;  state Exp;
branches ;
next     36.43;

36.43
date     90.06.07.10.33.05;  author kodiak;  state Exp;
branches ;
next     36.42;

36.42
date     90.06.06.16.24.51;  author kodiak;  state Exp;
branches ;
next     36.41;

36.41
date     90.06.06.14.29.40;  author kodiak;  state Exp;
branches ;
next     36.40;

36.40
date     90.05.30.17.11.18;  author kodiak;  state Exp;
branches ;
next     36.39;

36.39
date     90.05.25.13.46.57;  author kodiak;  state Exp;
branches ;
next     36.38;

36.38
date     90.05.21.23.46.24;  author kodiak;  state Exp;
branches ;
next     36.37;

36.37
date     90.05.16.11.35.21;  author kodiak;  state Exp;
branches ;
next     36.36;

36.36
date     90.05.10.17.55.34;  author kodiak;  state Exp;
branches ;
next     36.35;

36.35
date     90.05.10.16.59.50;  author kodiak;  state Exp;
branches ;
next     36.34;

36.34
date     90.05.01.14.02.49;  author kodiak;  state Exp;
branches ;
next     36.33;

36.33
date     90.04.20.09.45.46;  author kodiak;  state Exp;
branches ;
next     36.32;

36.32
date     90.04.17.14.55.40;  author kodiak;  state Exp;
branches ;
next     36.31;

36.31
date     90.04.13.13.33.05;  author kodiak;  state Exp;
branches ;
next     36.30;

36.30
date     90.04.12.17.06.42;  author kodiak;  state Exp;
branches ;
next     36.29;

36.29
date     90.04.11.17.54.01;  author kodiak;  state Exp;
branches ;
next     36.28;

36.28
date     90.04.10.11.37.30;  author kodiak;  state Exp;
branches ;
next     36.27;

36.27
date     90.04.02.10.47.47;  author kodiak;  state Exp;
branches ;
next     36.26;

36.26
date     90.03.06.11.25.46;  author kodiak;  state Exp;
branches ;
next     36.25;

36.25
date     90.03.03.14.55.57;  author kodiak;  state Exp;
branches ;
next     36.24;

36.24
date     90.02.21.18.40.39;  author kodiak;  state Exp;
branches ;
next     36.23;

36.23
date     89.12.15.17.50.02;  author kodiak;  state Exp;
branches ;
next     36.22;

36.22
date     89.12.15.11.09.19;  author kodiak;  state Exp;
branches ;
next     36.21;

36.21
date     89.12.14.17.13.32;  author kodiak;  state Exp;
branches ;
next     36.20;

36.20
date     89.12.14.17.03.52;  author kodiak;  state Exp;
branches ;
next     36.19;

36.19
date     89.12.07.15.52.10;  author kodiak;  state Exp;
branches ;
next     36.18;

36.18
date     89.12.04.22.55.50;  author kodiak;  state Exp;
branches ;
next     36.17;

36.17
date     89.12.03.16.36.33;  author kodiak;  state Exp;
branches ;
next     36.16;

36.16
date     89.12.02.11.37.37;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     89.11.27.12.49.10;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     89.11.10.12.19.40;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     89.11.04.16.06.10;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     89.09.15.15.39.17;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     89.09.11.16.47.54;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     89.09.11.13.00.18;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     89.08.30.10.51.22;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     89.08.21.12.54.04;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     89.07.10.18.19.45;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     89.07.07.13.28.54;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.07.05.15.23.21;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     89.06.28.19.14.36;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     89.06.28.13.38.17;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     88.11.14.16.04.51;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     88.09.19.10.16.20;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     88.09.06.19.52.49;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


36.73
log
@Doc changes; better explain optimized scrolling, and why programmers
cannot rely on specific behavior
@
text
@**
**	$Id: write.asm,v 36.72 92/09/17 14:26:27 darren Exp Locker: darren $
**
**      workhorse console write command
**
**      (C) Copyright 1985,1989,1990 Commodore-Amiga, Inc.
**          All Rights Reserved
**
	SECTION	console

**	Includes

	INCLUDE	"cddata.i"

	INCLUDE	"graphics/text.i"
	INCLUDE	"intuition/intuition.i"
	INCLUDE	"intuition/intuitionbase.i"

**	Exports

	XDEF	CDCBWrite
	XDEF	CDWrite

	XDEF	G0Handler
	XDEF	sgrPrimary
	XDEF	sgrNewMask

**	Imports


	XLVO	Forbid			; Exec
	XLVO	Permit			;
	XLVO	RawDoFmt		;
	XLVO	ObtainSemaphore		;
	XLVO	ReleaseSemaphore	;

	XLVO	Text			; Graphics
	XLVO	SetAPen			;
	XLVO	SetBPen			;
	XLVO	SetDrMd			;
	XLVO	SetSoftStyle		;

	XLVO	InstallClipRegion	; Layers

	XLVO	DisplayBeep		; Intuition

	XREF	PutReadByte

	XREF	EndCommand
	XREF	WriteReset

	XREF	LockDRPort
	XREF	UnLockRPort
	XREF	CursDisable
	XREF	CursEnable
	XREF	CursOn
	XREF	CursOff
	XREF	CursUpdate
	XREF	CursDown
	XREF	CursLeft
	XREF	CursRight
	XREF	CursUp
	XREF	CursRender
	XREF	ScrollYDisplay
	XREF	InsDelChar
	XREF	InsDelLine
	XREF	ClearEOL
	XREF	ClearEOD
	XREF	ClearDisplay
	XREF	RestoreRP
	XREF	Tab
	XREF	BackTab
	XREF	SetTab
	XREF	ClearTab
	XREF	ClearTabs
	XREF	ReSizeUnit
	XREF	RefreshDamage
	XREF	RefreshUnit
	XREF	SelectAbort
	XREF	IfNewSize

	XREF	CDRead

	XREF	GetEvents		; task


**	Assumptions

	IFNE	cu_PNPData-cu_PNPCurr-2
	FAIL	"cu_PNPData does not follow cu_PNPCurr"
	ENDC
	IFNE	RP_INVERSVID-4
	FAIL	"RP_INVERSVID not bit 2, recode"
	ENDC
	IFNE	CUB_IMPLICITNL-7
	FAIL	"CUB_IMPLICITNL not sigh bit, recode"
	ENDC

**	Assumptions

	IFNE	CONU_LIBRARY+1
	FAIL	"constant CONU_LIBRARY not -1"
	ENDC

	IFNE	CONU_STANDARD
	FAIL	"constant CONU_STANDARD not 0"
	ENDC

	IFNE	CONU_CHARMAP&1-1
	FAIL	"low bit not set in constant CONU_CHARMAP"
	ENDC

	IFNE	CONU_SNIPMAP&1-1
	FAIL	"low bit not set in constant CONU_SNIPMAP"
	ENDC

** Special Comments

**	Reserve <CSI><parameters>]
**
**	For third party developers - used by Bill Hawes DisplayHandler
**					--Darren--
**

******* console.device/CMD_WRITE *************************************
*
*   NAME
*	CMD_WRITE -- Write ANSI text to the console display.
*
*   FUNCTION
*	Write a text record to the display.  Interpret the ANSI
*	control characters in the data as described below.  Note
*	that the RPort of the console window is in use while this
*	write command is pending.
*
*   IO REQUEST INPUT
*	io_Message	mn_ReplyPort set if quick I/O is not possible
*	io_Device	preset by the call to OpenDevice
*	io_Unit		preset by the call to OpenDevice
*	io_Command	CMD_WRITE
*	io_Flags	IOF_QUICK if quick I/O possible, else zero
*	io_Length	sizeof(*buffer), or -1 if io_Data is null
*			terminated
*	io_Data		a pointer to a buffer containing the ANSI text
*			to write to the console device.
*
*   IO REQUEST RESULTS
*	io_Error	the error result (no errors are reported as of V36)
*	io_Actual	the number of bytes written from io_Data
*	io_Length	zero
*	io_Data		original io_Data plus io_Actual
*
*   ANSI CODES SUPPORTED
*
*	Codes are specified in the standard fashion for ANSI documents,
*	as the two 4 bit nibbles that comprise the character code,
*	high nibble first, separated by a slash.  Thus 01/11 (ESC) is
*	a character with the hex value 1B (or the decimal value 27).
*
*	A character on the Amiga falls into one of the following four
*	ranges:
*	00/ 0-01/15	C0: ASCII control characters.  See below.
*	02/ 0-07/15	G0: ASCII graphic characters.  These characters
*			have an image that is displayed.  Note that the
*			DEL character is displayed by the Console Device:
*			it is not treated as control character here.
*	08/ 0-09/15	C1: ANSI 3.41 control characters.  See below.
*	10/ 0-15/15	G1: ECMA 94 Latin 1 graphic characters.
*
*	Independent Control Functions (no introducer) --
*	Code	Name	Definition
*	-----	---	----------------------------------------------
*	00/ 7	BEL	BELL: actually an Intuition DisplayBeep()
*	00/ 8	BS	BACKSPACE
*	00/ 9	HT	HORIZONTAL TAB
*	00/10	LF	LINE FEED
*	00/11	VT	VERTICAL TAB
*	00/12	FF	FORM FEED
*	00/13	CR	CARRIAGE RETURN
*	00/14	SO	SHIFT OUT: causes all subsequent G0 (ASCII)
*			characters to be shifted to G1 (ECMA 94/1)
*			characters.
*	00/15	SI	SHIFT IN: cancels the effect of SHIFT OUT.
*	01/11	ESC	ESCAPE
*
*	Code or Esc Name Definition
*	-----	--- ---- ---------------------------------------------
*	08/ 4	D   IND	 INDEX: move the active position down one line.
*	08/ 5	E   NEL	 NEXT LINE
*	08/ 8	H   HTS  HORIZONTAL TABULATION SET
*	08/13	M   RI	 REVERSE INDEX
*	09/11	[   CSI	 CONTROL SEQUENCE INTRODUCER: see next list
*
*	ISO Compatible Escape Sequences (introduced by Esc) --
*	Esc   Name Definition
*	----- ---- ---------------------------------------------------
*	c     RIS  RESET TO INITIAL STATE: reset the console display.
*
*	Control Sequences, with the number of indicated parameters.
*	i.e. <CSI><parameters><control sequence letter(s)>.  Note the
*	last entries consist of a space and a letter.  CSI is either
*	9B or Esc[.  A minus after the number of parameters (#p)
*	indicates less is valid.  Parameters are separated by
*	semicolons, e.g. Esc[14;80H sets the cursor position to row
*	14, column 80.
*	CSI #p	Name Definition
*	--- --- ---- -------------------------------------------------
*	@@   1-	ICH  INSERT CHARACTER
*	A   1-	CUU  CURSOR UP
*	B   1-	CUD  CURSOR DOWN
*	C   1-	CUF  CURSOR FORWARD
*	D   1-	CUB  CURSOR BACKWARD
*	E   1-	CNL  CURSOR NEXT LINE
*	F   1-	CPL  CURSOR PRECEDING LINE
*	H   2-	CUP  CURSOR POSITION
*	I   1-	CHT  CURSOR HORIZONTAL TABULATION
*	J   1-	ED   ERASE IN DISPLAY (only to end of display)
*	K   1-	EL   ERASE IN LINE (only to end of line)
*	L   1-	IL   INSERT LINE
*	M   1-	DL   DELETE LINE
*	P   1-	DCH  DELETE CHARACTER
*	R   2	CPR  CURSOR POSITION REPORT (in Read stream only)
*	S   1-	SU   SCROLL UP
*	T   1-	SD   SCROLL DOWN
*	W   n	CTC  CURSOR TABULATION CONTROL
*	Z   1-	CBT  CURSOR BACKWARD TABULATION
*	f   2-	HVP  HORIZONTAL AND VERTICAL POSITION
*	g   1-	TBC  TABULATION CLEAR
*	h   n	SM   SET MODE: see modes below.
*	l   n	RM   RESET MODE: see modes below.
*	m   n	SGR  SELECT GRAPHIC RENDITION
*	n   1-	DSR  DEVICE STATUS REPORT
*	t   1-	aSLPP SET PAGE LENGTH (private Amiga sequence)
*	u   1-	aSLL  SET LINE LENGTH (private Amiga sequence)
*	x   1-	aSLO  SET LEFT OFFSET (private Amiga sequence)
*	y   1-	aSTO  SET TOP OFFSET (private Amiga sequence)
*	{   n	aSRE  SET RAW EVENTS (private Amiga sequence)
*	|   8	aIER  INPUT EVENT REPORT (private Amiga Read sequence)
*	}   n	aRRE  RESET RAW EVENTS (private Amiga sequence)
*	~   1	aSKR  SPECIAL KEY REPORT (private Amiga Read sequence)
*	 p  1-	aSCR  SET CURSOR RENDITION (private Amiga sequence)
*	 q  0	aWSR  WINDOW STATUS REQUEST (private Amiga sequence)
*	 r  4	aWBR  WINDOW BOUNDS REPORT (private Amiga Read sequence)
*	 s  0	aSDSS SET DEFAULT SGR SETTINGS (private Amiga sequence-V39)
*	 v  1	aRAV  RIGHT AMIGA V PRESS (private Amiga Read sequence-V37)
*
*	Modes, set with <CSI><mode-list>h, and cleared with
*	<CSI><mode-list>l, where the mode-list is one or more of the
*	following parameters, separated by semicolons --
*	Mode	Name Definition
*	------- ---- -------------------------------------------------
*	20	LNM  LINEFEED NEWLINE MODE: if a linefeed is a newline
*	>1	ASM  AUTO SCROLL MODE: if scroll at bottom of window
*	?7	AWM  AUTO WRAP MODE: if wrap at right edge of window
*
*    NOTES
*	The console.device recognizes these SGR sequences.
*	Note that some of these are new to V36.
*
*	SGR (SELECT GRAPHICS RENDITION)
*		Selects colors, and other display characteristics
*		for text.
*
*	Syntax:
*		<ESC>[graphic-rendition...m
*
*	Example:
*		<ESC>[1;7m   (sets bold, and reversed text)
*
*	Parameters:
*
*		0	- Normal colors, and attributes
*		1	- Set bold
*		2	- Set faint (secondary color)
*		3	- Set italic
*		4	- Set underscore
*		7	- Set reversed character/cell colors
*		8	- Set concealed mode.
*		22	- Set normal color, not bold	(V36)
*		23	- Italic off			(V36)
*		24	- Underscore off		(V36)
*		27	- Reversed off			(V36)
*		28	- Concealed off			(V36)
*
*		30-37	- Set character color
*		39	- Reset to default character color
*
*		40-47	- Set character cell color
*		49	- Reset to default character cell color
*
*		>0-7	- Set background color		(V36)
*			  Used to set the background color before
*			  any text is written.  The numeric parameter
*			  is prefixed by ">".  This also means that if
*			  you issue an SGR command with more than one
*			  parameter, you must issue the digit only
*			  parameters first, followed by any prefixed
*			  parameters.	  			  
*
*	V39 console.device takes advantage of the ability to mask
*	bitplanes for faster scrolling, clearing, and rendering.
*	The actual number of bitplanes scrolled depends on which
*	colors you set via the SGR sequences.  For those using
*	the defaults of PEN color 1, and cell color 0, console.device
*	only needs to scroll 1 bitplane.  The actual number
*	of bitplanes scrolled is reset when ESCc is sent, and when
*	the console window is entirely cleared (e.g., FF).  In
*	general this should cause no compatability problems, unless
*	you are mixing console rendering with graphic.library calls
*	in the same portions of your window.  Console.device considers
*	the number of bitplanes it must scroll, and the screen display
*	depth so that interleaved bitplane scrolling can be taken
*	advantage of in cases where performance is not significantly
*	affected (interleaved scrolling, and masking are mutually
*	exclusive).  The determination of how many planes to scroll
*	is undefined, and may change in the future.
*
*	V39 console.device supports a new private sequence (aSDSS)
*	intended for use by users who prefer to change their default
*	SGR settings.  When this private Amiga sequence is sent to the
*	console, the current Pen color, Cell color, Text style, and
*	Reverse mode (on or off), are set as defaults.  When ESC[0m
*	is issued, the settings are restored to the preferred settings.
*	ESC[39m, and ESC[49m are likewise affected.  In general
*	applications should not make use of this private sequence as it
*	is intended for users who would normally include it as part of
*	their shell startup script.  The normal defaults are reset
*	when ESCc is issued.
*
*    BUGS
*	Does not correctly display cursor in SuperBitMap layers for
*	versions prior to V36.
*
*	Concealed mode should not be used prior to V39 console.device.
*	Prior to V39 concealed mode masked all rastport output, the
*	effect of which varied.  As of V39, text output is simply
*	hidden by setting the pen colors.  Scrolling, clearing,
*	cursor rendering, etc., are unaffected.  For maximum
*	compatability it is recommended you simply set the colors
*	yourself, and not used concealed mode.
*
*	V36-V37 character mapped mode console.device windows could
*	crash, or behave erratically if you scroll text DOWN more
*	than a full window's worth of text.  This bug has been fixed
*	in V39 console.  The only work-around is to avoid sending
*	scroll down, or cursor up commands which exceed the window
*	rows (this is not a problem for unit 0 console windows).
*
*    SEE ALSO
*	ROM Kernel Manual (Volume 1), exec/io.h
*	
********************************************************************************

CDCBWrite	EQU	-1

CDWrite:
		movem.l d2-d7/a2-a4,-(a7)
		move.l	a1,a3		    ; save I/O Request
		move.l	IO_UNIT(a3),a2
		clr.l	IO_ACTUAL(a3)

CDMulti_Write:
		moveq	#00,d7
		not.b	d7			;255L

		lea	cd_EVSemaphore(a6),a0
		LINKEXE	ObtainSemaphore

		bsr	LockDRPort

		bsr	GetEvents		;handle pending events

		lea	cd_EVSemaphore(a6),a0
		LINKEXE	ReleaseSemaphore

		bsr	IfNewSize		;last moment check for a new size
		beq.s	wCheckSelecting		;which didnt get sent to the inputhandler
		bsr	ReSizeUnit		;task yet - RARE/May never happend

wCheckSelecting:

		;-- check for active selection
		btst	#CUB_SELECTED,cu_Flags(a2)
		beq.s	wSetAttrs
		bsr	SelectAbort

wSetAttrs:
		;-- set RastPort attributes
		move.l	cu_Mask(a2),cd_RastPort+rp_Mask(a6)	;FgPen/BgPen/AOLPen

		move.b	cu_DrawMode(a2),cd_RastPort+rp_DrawMode(a6)
		move.l	cu_Minterms(a2),cd_RastPort+rp_minterms(a6)
		move.l	cu_Minterms+4(a2),cd_RastPort+rp_minterms+4(a6)
		move.l	cu_Font(a2),cd_RastPort+rp_Font(a6)
		move.w	cu_AlgoStyle(a2),cd_RastPort+rp_AlgoStyle(a6)
		move.l	cu_TxHeight(a2),cd_RastPort+rp_TxHeight(a6)
		move.l	cu_TxBaseline(a2),cd_RastPort+rp_TxBaseline(a6)

		move.l	IO_LENGTH(a3),d0
		beq.s	done
		cmpi.l	#-1,d0
		bne.s	loop1

		moveq	#-1,d0
		move.l	IO_DATA(a3),a0
getNum:
		tst.b	(a0)+
		dbeq	d0,getNum
		not.l	d0		; null character is not in string
		move.l	d0,IO_LENGTH(a3)
		beq.s	done

loop1:
		;simple means of handling this problem of windows being
		;too small to render in.  We don't lose old info in the
		;buffer map, but we do ignore any attempts to write data.
		;
		;given ROM space, and time limits, this seems to be a
		;reasonable solution.  1.3 would blow up when you wrote
		;text via console.device too a tiny window.
		;

		btst	#CUB_TOOSMALL,cu_Flags(a2)
		bne.s	done


loop:
		tst.l	d7
		bmi.s	done

		;HACK here to support those who mixed text, and graphics
		;and relied on dumb console.device scrolling, and clearing
		;under <= V34 console.device.  Example: Disney Animator!
		;
		;This hack lies about DisplayXL/YL - sets them to max
		;for each write, hence maximum scrolls are always
		;done for non-character mapped windows (UNIT 0).
		

		btst	#0,cu_DevUnit+3(a2)
		bne.s	mappedunit
		move.l	cu_XMax(a2),cu_DisplayXL(a2)	;and Y
		addq.w	#1,cu_DisplayXL(a2)		;+1 past last possible position

mappedunit:
		move.l	IO_DATA(a3),a0
		clr.w	d0
		move.b	(a0),d0
		move.w	cu_PState(a2),d1
		lsl	#2,d1
		lea	parseTable(pc),a1
		move.l	0(a1,d1.w),a1
		jsr	(a1)
		tst.l	IO_LENGTH(a3)
		bne.s	loop

		moveq	#00,d7				;all done

done:
 		tst.l	cu_CM+cm_AllocSize(a2)
 		beq.s	unlockDR
 		;-- check for LAYERREFRESH generated here
 		move.l	cd_RastPort+rp_Layer(a6),a0
 		move.w	lr_Flags(a0),d0
 		and.w	#LAYERREFRESH,d0
 		beq.s	unlockDR
 		
 		bsr	RefreshDamage

unlockDR:
		bsr	UnLockRPort

	;------ Deal with pending events (layers unlocked)

		bclr	#CUB_CTRLG,cu_States(a2)
		beq.s	nobell

		move.l	cu_Window(a2),a0
		move.l	wd_WScreen(a0),a0
		LINKINT	DisplayBeep

nobell:
		tst.l	d7
		bmi	CDMulti_Write

	;------ check if this satisfied a read
		LINKEXE	Forbid
		move.w	cu_ReadLastIn(a2),d0
		cmp.w	cu_ReadLastOut(a2),d0
		beq.s	readPermit
		move.l	MP_MSGLIST(a2),a1
		tst.l	(a1)
		beq.s	readPermit

		bsr	CDRead

readPermit:
		LINKEXE Permit

		move.l	a3,a1
		movem.l (a7)+,d2-d7/a2-a4
		moveq	#0,d0
		bra	EndCommand

*------ Parse Table --------------------------------------------------

parseTable:
		dc.l	vanillaP    ;normal character
		dc.l	escP	    ;escape pending
		dc.l	escIP	    ;intermediate escape pending
		dc.l	csiPP	    ;CSI parameters pending
		dc.l	csiIP	    ;CSI intermediate pending


E3FpHandler:
CSIIHandler:
E3FtHandler:
E2FpHandler:
nil:
nextChar:
		addq.l	#1,IO_DATA(a3)
		addq.l	#1,IO_ACTUAL(a3)
		subq.l	#1,d7
		subq.l	#1,IO_LENGTH(a3)
		rts


*------ vanillaP -----------------------------------------------------
*
*   vanillaP -- characters not preceeded by an introducer
*
vanillaP:
		move.w	d0,d1
		btst	#7,d0	    ;check if in C0-GL or C1-GR
		bne.s	c1GR
		andi.w	#$0060,d1   ;check if control
		beq.s	c0Ctrl	    ;  go perform C0 control
		move.l	cu_GLHandler(a2),a1
		jmp	(a1)	    ;go perform GL code

c0Ctrl:
		bra	C0Handler   ;go perform C0 code

c1GR:
		andi.w	#$0060,d1   ;check if control
		beq	C1Handler	; go perform C1 code
		bra	G1Handler   ;go perform GR code

*------ escP ---------------------------------------------------------
*
*   escP -- unparameterized escape sequences
*
escP:
		btst	#7,d0	;check for 8-bit characters (an error)
		bne.s	escErr
		btst	#6,d0	;check for Fe, Fs groups
		bne.s	escFeOrFs
		btst	#5,d0	;check for control codes (an error)
		bne.s	escIOrFp

*   00-$1F: a control code
escErr:
		clr.w	cu_PState(a2)
		bra.s	vanillaP    ;invoke VanillaP "recursively"

escIOrFp:
		btst    #4,d0		; check for I group
		bne.s	escFp

*   20-$2F: an intermediate character
		bsr.s	putPIC
		move.w	#cu_PSESCI,cu_PState(a2)    ;update the parse state
		bra	nextChar

*   30-$3F: a private escape sequence
escFp:
		bra	    E2FpHandler	; (there are initially none)

escFeOrFs:
		bclr	#6,d0
		bclr	#5,d0	;check for C1 control sequence
		bne.s	escFs

*   40-$5F: a means of specifying controls from the C1 set
		clr.w	cu_PState(a2)
		bra	C1Handler

*   60-$7F: ISO standard escape sequences
escFs:
		bra	E2FsHandler


;------ putPIC -------------------------------------------------------
putPIC:
		lea	cu_PICNext(a2),a0
		move.w	(a0),d1
		move.b	d0,cu_PICData-cu_PICNext(a0,d1.w)
		addq.w	#1,d1
		cmp.w	#PICBSIZE,d1
		bge.s	ppicDone
		move.w	d1,(a0)
ppicDone:
		rts


*------ escIP --------------------------------------------------------
*
*   escIP -- parameterized escape sequences
*
escIPContd:
		move.l	IO_DATA(a3),a0
		clr.w	d0
		move.b	(a0),d0
escIP:
		btst	#7,d0	;check for 8-bit characters (an error)
		bne	escErr
		btst	#6,d0	;check for Ft group
		bne.s	escIFt
		btst	#5,d0	;check for control codes (an error)
		beq	escErr
		btst	#4,d0	;check for I group
		bne.s	escIFp

*   20-$2F: an intermediate character
		bsr.s	putPIC

		addq.l	#1,IO_DATA(a3)
		addq.l	#1,IO_ACTUAL(a3)
		subq.l	#1,d7
		subq.l	#1,IO_LENGTH(a3)
		bne.s	escIPContd
		rts

*   30-$3F: a private escape sequence
escIFp:
		bsr	E3FpHandler ;(there are initially none)
		bra	clearPS

*   40-$7F: standard parameterized escape sequences
escIFt:
		bsr	E3FtHandler ;(there are initially none)
		bra	clearPS

*------ csiPP --------------------------------------------------------
*
*   csiPP -- gather CSI parameters
*
csiPPContd:
		move.l	IO_DATA(a3),a0
		clr.w	d0
		move.b	(a0),d0
csiPP:
		btst	#7,d0	;check for 8-bit characters (an error)
		bne	escErr
		bclr	#6,d0	;check F group
		bne	csiF
		btst	#5,d0	;check for control codes (an error)
		beq	escErr
		btst	#4,d0	;check for P parameters
		bne.s	csiP

*   20-$2F: an intermediate character
		clr.w	cu_PICNext(a2)
		bsr	putPIC
		move.w	#cu_PSCSII,cu_PState(a2)    ;update the parse state
		bra	nextChar

*   30-$3F: numeric parameters
csiP:
		lea	cu_PNPCurr(a2),a0
		move.w	(a0),d1
		cmp.b	#'9',d0
		bgt.s	csiPDelimit
		move.w	d0,d2
		move.w	cu_PNPData-cu_PNPCurr(a0,d1.w),d0
		cmpi.w	#-5,d0
		bne.s	csiPMore
		moveq	#0,d0
csiPMore:
		and.w	#$0F,d2
		muls	#10,d0
		bmi.s	csiPPrivMul
		add.w	d2,d0
updatePWord:
		move.w	d0,cu_PNPData-cu_PNPCurr(a0,d1.w)

csiPNext:
		addq.l	#1,IO_DATA(a3)
		addq.l	#1,IO_ACTUAL(a3)
		subq.l	#1,d7
		subq.l	#1,IO_LENGTH(a3)
		bne	csiPPContd
		rts

csiPPrivMul:
		sub.w	d2,d0
		bra.s	updatePWord

csiPDelimit:
		sub.w	#';',d0
		bne.s	csiPPrivate
		addq.w	#2,d1
		cmp.w	#PNPBSIZE,d1
		blt.s	csiBoundedPNP
		subq.w	#2,d1
csiBoundedPNP:
		move.w	#-5,cu_PNPData-cu_PNPCurr(a0,d1.w)
		move.w	d1,(a0)
		bra.s	csiPNext

csiPPrivate:
		bmi.s	csiPNext
		neg.w	d0		; initialize parameter for private
		bra.s	updatePWord	;   use -- the collection ranges are:
					;   <    -1[n]*
					;   =    -2[n]*
					;   >    -3[n]*
					;   ?    -4[n]*
					;
					;   nil  -5
					;   eop  -6


*   40-$7F: a completed control sequence, sans any intermediate
csiF:
		bsr.s	eopPNP

		cmpi.b	#$2F,d0
		bhi.s	csiFp
		bsr	CSIHandler

clearPS:
		clr.w	cu_PState(a2)
		rts

csiFp:
		bsr	CSIpHandler
		bra.s	clearPS


eopPNP:
		;--	mark parameter eop and reset cu_PNPCurr for reading
		lea	cu_PNPCurr(a2),a0
		move.w	(a0),d1
		cmp.w	#PNPBSIZE-2,d1
		bge.s	epnpMark
		addq.w	#2,d1
epnpMark:
		move.w	#-6,cu_PNPData-cu_PNPCurr(a0,d1.w)
		clr.w	(a0)
		rts


*------ csiIP --------------------------------------------------------
*
*   csiIP -- gather CSI intermediates
*
csiIPContd:
		move.l	IO_DATA(a3),a0
		clr.w	d0
		move.b	(a0),d0
csiIP:
		btst	#7,d0	;check for 8-bit characters (an error)
		bne	escErr
		bclr	#6,d0	;check F group
		bne.s	csiIF
		btst	#5,d0	;check for control codes (an error)
		beq	escErr
		btst	#4,d0	;check for P parameters
		bne	escErr

*   20-$2F: an intermediate character
		bsr	putPIC

		addq.l	#1,IO_DATA(a3)
		addq.l	#1,IO_ACTUAL(a3)
		subq.l	#1,d7
		subq.l	#1,IO_LENGTH(a3)
		bne.s	csiIPContd
		rts

*   40-$7F: a completed control sequence, with intermediate(s)
csiIF:
		bsr.s	eopPNP

		cmpi.b	#$2F,d0
		bhi.s	csiIFp
		bsr	CSIIHandler
		bra.s	clearPS

csiIFp:
		bsr	CSIIpHandler
		bra.s	clearPS


*------ G0Handler -----------------------------------------------------
*
*   G0Handler -- process vanilla characters from left code table
*
*   NOTE: as an extended capability, this also allows 8th bit set chars
*
G0Handler:
		move.l	a0,a4		;save string start
	    ;-- find the number of contiguous vanilla characters
		move.l	IO_LENGTH(a3),d1
g0Loop:
		move.b	(a0)+,d0
		and.b	#$60,d0		; check if control
		beq.s	gHandler	;
		subq.l	#1,d1
		bne.s	g0Loop		; there are possibly more controls

gHandler:
	    ;-- get number of vanilla characters
		move.l	IO_LENGTH(a3),d2
		sub.l	d1,d2		; get number of chars to output

g1Entry:
		bsr	CursDisable

	    ;-- get the amount of text outputable on the current line
nextLine:
		moveq	#00,d3		; clear upper word
		move.w	cu_XCP(a2),d1
		move.w	cu_XMax(a2),d3
		sub.w	d1,d3
		addq.w	#1,d3
		cmp.l	d3,d2
		bge.s	willWrap
		move.w	d2,d3
willWrap:

	    ;-- set up address registers and output Text
		;-- ensure the text CP is correct
		move.w	cu_XCP(a2),d1
		beq.s	installClipRegPosition
		move.w	d1,d0
		add.w	d3,d0
		cmp.w	cu_XMax(a2),d0
		ble.s	genXOrigin
		;--	the text position indicates to use the clip region
installClipRegPosition:
		;--	    check if already installed
		btst.b	#CDB_CLIPINSTALLED,cd_Flags(a6)
		bne.s	genXOrigin

		;--	    check if algorithmic style forces it
		move.b	cu_AlgoStyle(a2),d0
		and.w	#FSF_BOLD!FSF_ITALIC,d0
		bne.s	installClipReg

		;--	    check if kernless font makes it not necessary
		btst	#CUB_KERNLESS,cu_Flags(a2)
		bne.s	genXOrigin

		;--	install the clip region
installClipReg: 
		bset.b	#CDB_CLIPINSTALLED,cd_Flags(a6)
		move.l	cd_RastPort+rp_Layer(a6),a0
		move.l	cu_ClipRegion(a2),a1
		LINKLAY	InstallClipRegion
		move.l	d0,cd_PrevClipRegion(a6)
		move.w	cu_XCP(a2),d1

genXOrigin:
		lea	cd_RastPort(a6),a1
		mulu	cu_XRSize(a2),d1
		add.w	cu_XROrigin(a2),d1
		move.w	d1,rp_cp_x(a1)
		move.w	cu_YCP(a2),d1
		mulu	cu_YRSize(a2),d1
		add.w	cu_YROrigin(a2),d1
		add.w	cu_TxBaseline(a2),d1
		move.w	d1,rp_cp_y(a1)
		moveq	#0,d0
		move.w	d3,d0
		move.l	a4,a0
		LINKGFX Text

	    ;-- fill the buffers if appropriate
		tst.l	cu_CM+cm_AllocSize(a2)	; check if buffered
		beq	updateWriteCount

		movem.l	d2-d5/a4,-(a7)

		;-- build text attribute
		move.b	cu_AlgoStyle(a2),d4
		lsl.w	#CMAS_SOFTSTYLE-CMAS_BGPEN,d4
		or.b	cu_BgPen(a2),d4
		lsl.w	#CMAS_BGPEN,d4
		;	check CONCEALED: set FgPen == BgPen if CONCEALED
		tst.b	cu_ConcealMask(a2)
		beq.s	notConcealed
		or.b	cu_BgPen(a2),d4
		bra.s	chkDrawMode

notConcealed:
		or.b	cu_FgPen(a2),d4

chkDrawMode:
		btst.b	#2,cu_DrawMode(a2)	; RP_INVERSVID
		beq.s	chkImplicit
		bset	#CMAB_INVERSVID,d4

chkImplicit:
		tst.b	cu_Flags(a2)		; btst #CUB_IMPLICITNL,
		bpl.s	setRendered
		bset	#CMAB_IMPLICITNL,d4

setRendered:
		bset	#CMAB_RENDERED,d4

		;used for fill attribute - fill with valid
		;spaces of background color for pen/cell

		move.w	#CMAF_RENDERED,d5		;set rendered bit
		move.b	cu_BgColor(a2),d0
		move.b	d0,d1
		lsl.b	#CMAS_BGPEN,d1
		or.b	d0,d5
		or.b	d1,d5

		;--	ensure buffer is initialized to CP
		movem.w	cu_XCP(a2),d0/d1
		cmp.w	cu_DisplayYL(a2),d1
		blt.s	checkTabbed
		bgt.s	initMapGap
		cmp.w	cu_DisplayXL(a2),d0
		beq	fillBuffer
		blt.s	checkTabbed
		bra.s	initLineGap

		;--	initialize empty lines between Display.L and CP
initMapGap:
		move.w	cu_DisplayYL(a2),d0
		sub.w	d0,d1			; lines count
		lsl.w	#2,d0			; y line start pointer offset
		move.l	cu_CM+cm_AttrDispLines(a2),a0
		add.w	d0,a0
		move.w	cu_DisplayXL(a2),d0	; x offset for first line
		move.w	cu_XMax(a2),d2		; cm_DisplayWidth - 1
		bra.s	initMapYDBF
initMapYLoop:
		move.l	(a0)+,a1
		add.w	d0,a1
		sub.w	d2,d0
		bgt.s	initMapXDone
		neg.w	d0
		add.l	a1,a1
initMapXLoop:
		clr.w	(a1)+
		dbf	d0,initMapXLoop
initMapXDone:
		moveq	#0,d0
initMapYDBF:
		dbf	d1,initMapYLoop

		movem.w	cu_XCP(a2),d0/d1

checkTabbed:
		tst.w	d0
		bne.s	checkLeft
		btst.b	#CUB_TABBED,cu_Flags(a2)
		beq.s	checkLeft
		tst.w	d1
		beq.s	checkLeft
		;--	initialize end of previous line to blanks
		subq.w	#1,d1
		lsl.w	#2,d1
		move.l	cu_CM+cm_AttrDispLines(a2),a0
		add.w	d1,a0
		move.l	(a0),a1
		move.w	cu_CM+cm_DisplayWidth(a2),d0
		add.w	d0,a1
		move.l	a1,a0
		add.l	cu_CM+cm_AttrToChar(a2),a0
		add.l	a1,a1
		bra.s	tabbedLineDBF
tabbedLineLoop:
		tst.w	-(a1)
		bmi.s	tabbedDone
		move.b	#' ',-(a0)
		move.w	d5,(a1)
tabbedLineDBF:
		dbf	d0,tabbedLineLoop

tabbedDone:
		movem.w	cu_XCP(a2),d0/d1
		bra.s	checkLeft

initLineGap:
		move.w	cu_DisplayXL(a2),d1	; x start offset
		sub.w	d1,d0			; fill count
		exg	d0,d1			; offset in d0, count in d1
		bra.s	fillLineGap

checkLeft:
		tst.w	d0
		beq.s	fillBuffer
		cmp.w	cu_DisplayYL(a2),d1
		blt.s	checkLeftByLooking
		beq.s	checkLeftOnDYL
		move.w	d0,d1
		moveq	#0,d0			; offset in d0, count in d1
		bra.s	fillLineGap

checkLeftOnDYL:
		cmp.w	cu_DisplayXL(a2),d0
		beq.s	fillBuffer
		bgt.s	initLineGap

checkLeftByLooking:
		lsl.w	#2,d1			; y line start pointer offset
		move.l	cu_CM+cm_AttrDispLines(a2),a0
		move.l	0(a0,d1.w),a1
		add.w	d0,a1
		add.l	a1,a1
		move.w	d0,d1
checkLeftLoop:
		tst.w	-(a1)
		dbmi	d0,checkLeftLoop
		bmi.s	checkLeftCount
		moveq	#0,d0

checkLeftCount:
		sub.w	d0,d1
		bge.s	fillLineGap

fillBuffer:
		moveq	#0,d1			; zero fill count

		;--	fill to left with spaces
fillLineGap:
		move.w	cu_YCP(a2),d2
		lsl.w	#2,d2			; y line start pointer offset
		move.l	cu_CM+cm_AttrDispLines(a2),a0
		move.l	0(a0,d2.w),a0
		add.w	d0,a0
		move.l	a0,a1
		add.l	cu_CM+cm_AttrToChar(a2),a0
		add.l	a1,a1
		bra.s	fillLineDBF
fillLineLoop:
		move.b	#' ',(a0)+
		move.w	d5,(a1)+
fillLineDBF:
		dbf	d1,fillLineLoop


		;--	set TABBED attribute for first character
		bclr.b	#CUB_TABBED,cu_Flags(a2)
		beq.s	fillBufferDBF
		bset	#CMAB_TABBED,d4
		bra.s	fillBufferDBF


		;--	fill buffer
fillBufferLoop:
		move.b	(a4)+,(a0)+
		move.w	d4,(a1)+
		bclr	#CMAB_TABBED,d4
fillBufferDBF:
		dbf	d3,fillBufferLoop

		movem.l	(a7)+,d2-d5/a4

	    ;-- update the count
updateWriteCount:
		add.l	d3,IO_DATA(a3)
		add.l	d3,IO_ACTUAL(a3)
		sub.l	d3,IO_LENGTH(a3)
		sub.l	d3,d7

	    ;-- update cm_Display.L
		movem.w	cu_XCP(a2),d0/d1
		add.w	d3,d0
		cmp.w	cu_DisplayYL(a2),d1
		blt.s	g0CursUpdate
		bgt.s	g0UpdateDisplayL
		cmp.w	cu_DisplayXL(a2),d0
		ble.s	g0CursUpdate
g0UpdateDisplayL:
		movem.w	d0/d1,cu_DisplayXL(a2)

	    ;-- move cursor right
g0CursUpdate:
		move.w	d3,d0		;one blip per character
		bsr	CursRight

	    ;-- check if more characters
		add.w	d3,a4		;update string pointer
		sub.l	d3,d2		;update vanilla count
		bhi	nextLine

g0CursEnable:
		bra	CursEnable	; bsr ... rts


*------ G1Handler -----------------------------------------------------
*
*   G1Handler -- process vanilla characters from right code table
*
*   NOTE: this sets the most significant bit and handles one at a time
*
G1Handler:
		moveq	#1,d2		; output one character
		move.b	(a0),d0
		or.b	#$80,d0		; set the msb in the character
		move.b	d0,-(a7)
		move.l	a7,a4		; point to 8-bit-set character
		bsr	g1Entry
		addq.l	#2,a7		; move.b ,-(a7) pushes 2 bytes
		rts


*------ C0Handler ----------------------------------------------------
*
*	C0Handler -- execute a control character from the C0 set.
C0Handler:
		add.b	d0,d0
		move.w	c0Table(pc,d0.w),d0
		jmp	c0Table(pc,d0.w)

c0Table:
		dc.w	nil-c0Table ;NUL
		dc.w	nil-c0Table ;SOH
		dc.w	nil-c0Table ;STX
		dc.w	nil-c0Table ;ETX
		dc.w	nil-c0Table ;EOT
		dc.w	nil-c0Table ;ENQ
		dc.w	nil-c0Table ;ACK
		dc.w	c0BEL-c0Table ;Bell
		dc.w	c0BS-c0Table  ;BackSpace
		dc.w	c0HT-c0Table  ;Horizontal Tab
		dc.w	c0LF-c0Table  ;Line Feed
		dc.w	c0VT-c0Table  ;Vertical Tab
		dc.w	c0FF-c0Table  ;Form Feed
		dc.w	c0CR-c0Table  ;Carriage Return
		dc.w	c0SO-c0Table  ;Shift Out
		dc.w	c0SI-c0Table  ;Shift In
		dc.w	nil-c0Table ;DLE
		dc.w	nil-c0Table ;DC1
		dc.w	nil-c0Table ;DC2
		dc.w	nil-c0Table ;DC3
		dc.w	nil-c0Table ;DC4
		dc.w	nil-c0Table ;NAK
		dc.w	nil-c0Table ;SYN
		dc.w	nil-c0Table ;ETB
		dc.w	nil-c0Table ;CAN
		dc.w	nil-c0Table ;EOM
		dc.w	nil-c0Table ;SUB
		dc.w	c0ESC-c0Table ;Escape introducer
		dc.w	nil-c0Table ;File Seperator
		dc.w	nil-c0Table ;Group Seperator
		dc.w	nil-c0Table ;Record Seperator
		dc.w	nil-c0Table ;Unit Seperator

*- - -	BEL  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Bell
*
c0BEL:
		bset	#CUB_CTRLG,cu_States(a2)
		moveq	#00,d7			;break write

		bra	nextChar


*- - -	BS   - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   BackSpace
*
c0BS:
		moveq	#1,d0
		bsr	CursLeft
		bra	nextChar

*- - -	HT   - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Horizontal Tab
*
c0HT:
		bsr	Tab
		bra	nextChar

*- - -	LF   - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*- - -	IND  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Line Feed
*   Index
*
c0LF:
		btst	#(M_LNM&07),cu_Modes+(M_LNM/8)(a2)
		bne.s	NEL
IND:
		bclr	#CUB_IMPLICITNL,cu_Flags(a2)
		bne	nextChar
		moveq	#1,d0
		bsr	CursDown
		bsr	updateRPCP
		bra	nextChar

*- - -	VT   - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*- - -	RI   - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Vertical Tab
*   Reverse Index
*
c0VT:
RI:
		moveq	#1,d0
		bsr	CursUp
		bra	nextChar

*- - -	FF   - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Form Feed
*
c0FF:
		
		clr.l	cu_XCP(a2)   ;set to upper left corner

		lea	cd_RastPort(a6),a1
		;-- ensure the text CP is correct
		move.w	cu_XROrigin(a2),d1
		move.w	d1,rp_cp_x(a1)
		move.w	cu_YROrigin(a2),d1
		add.w	cu_TxBaseline(a2),d1
		move.w	d1,rp_cp_y(a1)
		bsr	ClearDisplay

		;-- Cursor is already cleared, so just redraw
		;-- cursor pattern cleared by ClearDisplay()

		clr.l	cu_XCCP(a2)
		and.b	#(~(CUF_IMPLICITNL!CUF_TABBED))&$ff,cu_Flags(a2)
		bsr	CursRender

		bra	nextChar

*- - -	CPL  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Cursor Previous Line
*
CPL:
		bsr	cu
		bclr	#CUB_IMPLICITNL,cu_Flags(a2)
		bne	nextChar
		bsr	CursUp
		bra.s	c0CR

*- - -	CNL  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Cursor Next Line
*
CNL:
		bsr	cu
		bra.s	nextLines

*- - -	NEL  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   NEw Line
*
NEL:
		moveq	#1,d0
nextLines:
		bclr	#CUB_IMPLICITNL,cu_Flags(a2)
		bne	nextChar
		bsr	CursDown
	;-- that was linefeed, now fall thru to CR

*- - -	CR   - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Carriage Return
*
c0CR:
		clr.w	cu_XCP(a2)   ;set to rht margin
		bsr	CursUpdate
		bra	nextChar


*- - -	SO   - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Shift Out
*
c0SO:
		move.l	#G1Handler,cu_GLHandler(a2)
		bra	nextChar

*- - -	SI   - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Shift In
*
c0SI:
		move.l	#G0Handler,cu_GLHandler(a2)
		bra	nextChar

*- - -	ESC  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Escape
*
c0ESC:
		move.w	#cu_PSESC,cu_PState(a2)
		clr.w	cu_PICNext(a2)
		bra	nextChar

*- - -	HTS  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Horizontal Tabulation Set
*
HTS:
		bsr	SetTab
		bra	nextChar

*- - -	CSI  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Control Sequence Introducer
*
CSI:
		move.w	#cu_PSCSI,cu_PState(a2)
		;	cu_PNPCurr = 0, cu_PNPData(a2) = -5
		move.l	#$0000fffb,cu_PNPCurr(a2)
		bra	nextChar


*------ C1Handler ----------------------------------------------------
*
*	C1Handler -- execute a control character from the C1 set.
C1Handler:
		add.b	d0,d0	    ;also gets rid of msb
		move.w	c1Table(pc,d0.w),d0
		jmp	c1Table(pc,d0.w)

c1Table:
		dc.w	nil-c1Table ; future standard
		dc.w	nil-c1Table ; future standard
		dc.w	nil-c1Table ; future standard
		dc.w	nil-c1Table ; future standard
		dc.w	IND-c1Table ; INDEX: move the active position down one line
		dc.w	NEL-c1Table ; NEXT LINE:
		dc.w	nil-c1Table ; START OF SELECTED AREA:
		dc.w	nil-c1Table ; END OF SELECTED AREA:
		dc.w	HTS-c1Table ; HORIZONTAL TABULATION SET:
		dc.w	nil-c1Table ; HORIZONTAL TABULATION WITH JUSTIFICATION:
		dc.w	nil-c1Table ; VERTICAL TABULATION SET:
		dc.w	nil-c1Table ; PARTIAL LINE DOWN:
		dc.w	nil-c1Table ; PARTIAL LINE UP:
		dc.w	RI-c1Table  ; REVERSE INDEX:
		dc.w	nil-c1Table ; SINGLE SHIFT TWO:
		dc.w	nil-c1Table ; SINGLE SHIFT THREE:
		dc.w	nil-c1Table ; DEVICE CONTROL STRING:
		dc.w	nil-c1Table ; PRIVATE USE ONE:
		dc.w	nil-c1Table ; PRIVATE USE TWO:
		dc.w	nil-c1Table ; SET TRANSMIT STATE:
		dc.w	nil-c1Table ; CANCEL CHARACTER
		dc.w	nil-c1Table ; MESSAGE WAITING
		dc.w	nil-c1Table ; START OF PROTECTED AREA
		dc.w	nil-c1Table ; END OF PROTECTED AREA
		dc.w	nil-c1Table ; future standard
		dc.w	nil-c1Table ; future standard
		dc.w	nil-c1Table ; future standard
		dc.w	CSI-c1Table ; CONTROL SEQUENCE INTRODUCER: see next list
		dc.w	nil-c1Table ; STRING TERMINATOR
		dc.w	nil-c1Table ; OPERATING SYSTEM COMMAND
		dc.w	nil-c1Table ; PRIVACY MESSAGE
		dc.w	nil-c1Table ; APPLICATION PROGRAM COMMAND

*------ E2FsHandler ---------------------------------------------------
*
*   E2FsHandler -- process standard ISO escape sequence
*
E2FsHandler:
		cmpi.b	#3,d0
		beq.s	resetFs	    ; RIS  RESET TO INITIAL STATE

escEnd:
		clr.w	cu_PState(a2)
		bra	nextChar

resetFs:
		bsr	WriteReset
		bra.s	escEnd


*------ CSIHandler ---------------------------------------------------
*
*	CSIHandler -- execute a single character CSI function
*
CSIHandler:
		add.b	d0,d0	    ;also gets rid of msb
		move.w	csiTable(pc,d0.w),d0
		jmp	csiTable(pc,d0.w)

csiTable:
		dc.w	ICH-csiTable	; INSERT CHARACTER
		dc.w	CUU-csiTable	; CURSOR UP
		dc.w	CUD-csiTable	; CURSOR DOWN
		dc.w	CUF-csiTable	; CURSOR FORWARD
		dc.w	CUB-csiTable	; CURSOR BACKWARD
		dc.w	CNL-csiTable	; CURSOR NEXT LINE
		dc.w	CPL-csiTable	; CURSOR PRECEEDING LINE
		dc.w	nil-csiTable	; CURSOR HORIZONTAL ABSOLUTE
		dc.w	CUP-csiTable	; CURSOR POSITION
		dc.w	CHT-csiTable	; CURSOR HORIZONTAL TABULATION
		dc.w	ED-csiTable	; ERASE IN DISPLAY
		dc.w	EL-csiTable	; ERASE IN LINE
		dc.w	IL-csiTable	; INSERT LINE
		dc.w	DL-csiTable	; DELETE LINE
		dc.w	nil-csiTable	; ERASE IN FIELD
		dc.w	nil-csiTable	; ERASE IN AREA
		dc.w	DCH-csiTable	; DELETE CHARACTER
		dc.w	nil-csiTable	; SELECT EDITING EXTENT MODE
		dc.w	nil-csiTable	; CURSOR POSITION REPORT
		dc.w	SU-csiTable	; SCROLL UP
		dc.w	SD-csiTable	; SCROLL DOWN
		dc.w	nil-csiTable	; NEXT PAGE
		dc.w	nil-csiTable	; PREVIOUS PAGE
		dc.w	CTC-csiTable	; CURSOR TABULATION CONTROL
		dc.w	nil-csiTable	; ERASE CHARACTER
		dc.w	nil-csiTable	; CURSOR VERTICAL TABULATION
		dc.w	CBT-csiTable	; CURSOR BACKWARD TABULATION
		dc.w	nil-csiTable	;
		dc.w	nil-csiTable	;
		dc.w	nil-csiTable	;
		dc.w	nil-csiTable	;
		dc.w	nil-csiTable	;
		dc.w	nil-csiTable	; HORIZONTAL POSITION ABSOLUTE
		dc.w	nil-csiTable	; HORIZONTAL POSITION RELATIVE
		dc.w	nil-csiTable	; REPEAT
		dc.w	nil-csiTable	; DEVICE ATTRIBUTES
		dc.w	nil-csiTable	; VERTICAL POSITION ABSOLUTE
		dc.w	nil-csiTable	; VERTICAL POSITION RELATIVE
		dc.w	HVP-csiTable	; HORIZONTAL AND VERTICAL POSITION
		dc.w	TBC-csiTable	; TABULATION CLEAR
		dc.w	SMo-csiTable	; SET MODE
		dc.w	nil-csiTable	; MEDIA COPY
		dc.w	nil-csiTable	;
		dc.w	nil-csiTable	;
		dc.w	RM-csiTable	; RESET MODE
		dc.w	SGR-csiTable	; SELECT GRAPHIC RENDITION
		dc.w	DSR-csiTable	; DEVICE STATUS REPORT
		dc.w	nil-csiTable	; DEFINE AREA QUALIFICATION

getPNPWord:
		lea	cu_PNPCurr(a2),a0
		move.w	(a0),d1
		move.w	cu_PNPData-cu_PNPCurr(a0,d1.w),d0
		addq.w	#2,d1
		cmp.w	#-6,d0
		beq.s	lastGPNPWord
		move.w	d1,(a0)		; guaranteed non-zero
lastGPNPWord:
		rts

*- - -	CUU  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   CUrsor Up
*
CUU:
		bsr.s	cu
		bsr	CursUp
		bra	nextChar

*- - -	CUD  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   CUrsor Down
*
CUD:
		bsr.s	cu
		bsr	CursDown
		bra	nextChar

cu:
		bsr.s	getPNPWord
		tst.w	d0
		bgt.s	cuSpecified
		moveq	#1,d0		    ;default is 1
cuSpecified:
		rts

*- - -	CUF  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   CUrsor Forward
*
CUF:
		bsr.s	cu
		bsr	CursRight
		bra	nextChar

*- - -	CUB  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   CUrsor Backward
*
CUB:
		bsr.s	cu
		bsr	CursLeft
		bra	nextChar

*- - -	CUP  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*- - -	HVP  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*	CUrsor Position
*	Horizontal and Vertical Position
*
CUP:
HVP:
		bsr.s	cu
		cmp.w	cu_YMax(a2),d0
		bgt.s	cupYMax
		subq.w	#1,d0
cupYSet:	
		move.w	d0,cu_YCP(a2)

		bsr.s	cu
		cmp.w	cu_XMax(a2),d0
		bgt.s	cupXMax
		subq.w	#1,d0
cupXSet:	
		move.w	d0,cu_XCP(a2)
		bsr	CursUpdate
		bra	nextChar

cupYMax:
		move.w	cu_YMax(a2),d0
		bra.s	cupYSet

cupXMax:
		move.w	cu_XMax(a2),d0
		bra.s	cupXSet

*- - -	CHT  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*	Cursor Horizontal Tabulation
*
CHT:
		bsr	cu
		move.w	d0,-(a7)
chtLoop:
		bsr	Tab
		subq.w	#1,(a7)
		bne.s	chtLoop
		addq.w	#2,a7
		bra	nextChar


*- - -	ICH  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Insert CHaracter
*
ICH:
		bsr	cu
		neg.w	d0
		bsr	InsDelChar
		bra	nextChar


*- - -	DCH  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Delete CHaracter
*
DCH:
		bsr	cu
		bsr	InsDelChar
		bra	nextChar


*- - -	IL - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Insert Line
*
IL:
		bsr	cu
		neg.w	d0
		bsr	InsDelLine
		bra	nextChar


*- - -	DL - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Delete Line
*
DL:
		bsr	cu
		bsr	InsDelLine
		bra	nextChar


*- - -	EL - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Erase in Line
*
EL:
		bsr.s	updateRPCP
		bsr	CursDisable
		bsr	ClearEOL
		bsr	CursEnable
		bra	nextChar


*- - -	ED - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Erase in Display
*
ED:
		bsr.s	updateRPCP
		bsr	CursDisable

		bsr	cu
		subq.w	#2,d0
		bne.s	edEOD
		;-- erase entire display
		bsr	ClearDisplay
		bra.s	edCE

edEOD:
		;-- erase to end of display
		bsr	ClearEOD

edCE:
		bsr	CursEnable
		bra	nextChar

*------ updateRPCP ---------------------------------------------------
*
*	ensure the text CP is correct
*
updateRPCP:
		lea	cd_RastPort(a6),a1
		move.w	cu_XCP(a2),d1
		mulu	cu_XRSize(a2),d1
		add.w	cu_XROrigin(a2),d1
		move.w	d1,rp_cp_x(a1)
		move.w	cu_YCP(a2),d1
		mulu	cu_YRSize(a2),d1
		add.w	cu_YROrigin(a2),d1
		add.w	cu_TxBaseline(a2),d1
		move.w	d1,rp_cp_y(a1)
		rts


*- - -	SU   - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Scroll Up
*
SU:
		bsr	cu
		lea	cd_RastPort(a6),a1
		bsr	CursDisable
		bsr	ScrollYDisplay
		bsr	CursEnable
		bra	nextChar

*- - -	SD   - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Scroll Down
*
SD:
		bsr	cu
		neg.w	d0
		lea	cd_RastPort(a6),a1
		bsr	CursDisable
		bsr	ScrollYDisplay
		bsr	CursEnable
		bra	nextChar


*- - -	CTC  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*	Cursor Tabulation Control
*
CTC:
		bsr	getPNPWord
		beq	nextChar
		tst.w	d0
		bmi.s	ctcSetTab
		cmpi.w	#CTC_HSETTAB,d0
		beq.s	ctcSetTab
		cmpi.w	#CTC_HCLRTAB,d0
		beq.s	ctcClrTab
		cmpi.w	#4,d0
		beq.s	ctcClrTabs
		cmpi.w	#CTC_HCLRTABSALL,d0
		bne.s	CTC
ctcClrTabs:
		bsr	ClearTabs
		bra.s	CTC
ctcClrTab:
		bsr	ClearTab
		bra.s	CTC
ctcSetTab:
		bsr	SetTab
		bra.s	CTC


*- - -	CBT  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*	Cursor Backward Tabulation
*
CBT:
		bsr	cu
		move.w	d0,-(a7)
cbtLoop:
		bsr	BackTab
		subq.w	#1,(a7)
		bne.s	cbtLoop
		addq.w	#2,a7
		bra	nextChar


*- - -	TBC  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*	Tabulation Clear
*
TBC:
		bsr	getPNPWord
		beq	nextChar
		tst.w	d0
		bmi.s	tbcClrTab
		cmpi.w	#TBC_HCLRTAB,d0
		beq.s	tbcClrTab
		cmpi.w	#TBC_HCLRTABSALL,d0
		bne.s	TBC

		bsr	ClearTabs
		bra.s	TBC
tbcClrTab:
		bsr	ClearTab
		bra.s	TBC

		
*- - -	SMo  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Set Mode
*
SMo:
		bsr	getPNPWord
		beq	nextChar
		bsr.s	checkM
		bmi.s	SMo
		bset	d1,0(a0,d0.w)
		bra.s	SMo


checkM:
		tst.w	d0
		bpl.s	stdM
		cmp.w	#PM_ASM,d0
		bne.s	checkAWM
		moveq	#PMB_ASM,d0
		bra.s	validM
checkAWM:
		cmp.w	#PM_AWM,d0
		bne.s	unknownM
		moveq	#PMB_AWM,d0
		bra.s	validM
stdM:
		cmp.w	#M_LNM,d0
		bgt.s	unknownM
validM:
		move.w	d0,d1
		lsr.w	#3,d0
		andi.w	#7,d1
		lea	cu_Modes(a2),a0
		rts
unknownM:
		moveq	#-1,d0
		rts

*- - -	RM   - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Reset Mode
*
RM:
		bsr	getPNPWord
		beq	nextChar
		bsr.s	checkM
		bmi.s	RM
		bclr	d1,0(a0,d0.w)
		bra.s	RM


*- - -	SGR  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Set Graphic Rendition
*
SGR:
		bsr	getPNPWord
		beq.s	sgrNextChar
		tst.w	d0
		bpl.s	sgrSpecified
		;--	check for ">n": background color
		neg.w	d0
		cmp.w	#5,d0
		beq.s	sgrDefault
		;--	look for 300..363 [0..63], 30..39 [0-9], 3 []
		cmp.w	#364,d0
		bge.s	sgrNextChar	; ignore outside 0..63
		sub.w	#300,d0
		bge.s	sgrSetExplicitBG ; 300..363 [0..63]
		add.w	#300-30,d0
		bmi.s	sgrChkDefaultBG	; could be 3 []
		cmp.w	#10,d0
		bge.s	sgrNextChar	; ignore if not 30..39 [0-9]

		;--	set global background color
sgrSetExplicitBG:
		bset	#CUFB_FIXEDBG,cu_FixedFlags(a2)
sgrSetGlobBG:
		cmp.b	cu_BgColor(a2),d0
		beq.s	sgrNextChar
		move.b	d0,cu_BgColor(a2)

		bsr	sgrNewMask

		tst.l	cu_CM+cm_AllocSize(a2)
		beq.s	sgrNextChar

		bsr	RefreshUnit
sgrNextChar:

		bra	nextChar

sgrChkDefaultBG:
		cmp.w	#3-30,d0	; just ">" ?
		bne.s	sgrNextChar
		;--	    default
		bclr	#CUFB_FIXEDBG,cu_FixedFlags(a2)
		move.b	cu_BgPen(a2),d0
		bra.s	sgrSetGlobBG


		;--	set standard SGR code
sgrDefault:
		moveq	#0,d0		; default is zero

sgrSpecified:
		cmpi.w	#SGR_DEFAULTBG,d0
		bgt.s	SGR

		move.w	d0,d1
		add.b	d1,d1
		move.w	sgrTable(pc,d1.w),d1
		jsr	sgrTable(pc,d1.w)

		bra.s	SGR


sgrTable:
		dc.w	sgrPrimary-sgrTable	; PRIMARY RENDITION
		dc.w	sgrBold-sgrTable	; BOLD
		dc.w	sgrFgFaint-sgrTable	; SECONDARY COLOR
		dc.w	sgrItalic-sgrTable	; ITALIC
		dc.w	sgrUnderscore-sgrTable	; UNDERSCORE
		dc.w	sgrRRts-sgrTable	; SLOW BLINK
		dc.w	sgrRRts-sgrTable	; FAST BLINK
		dc.w	sgrReverse-sgrTable	; NEGATIVE (REVERSE) IMAGE
		dc.w	sgrConcealed-sgrTable	; CONCEALED
		dc.w	sgrRRts-sgrTable	; CROSSED OUT

		dc.w	sgrRRts-sgrTable	; PRIMARY FONT
		dc.w	sgrRRts-sgrTable	; FIRST ALTERNATE FONT
		dc.w	sgrRRts-sgrTable	; SECOND ALTERNATIVE FONT
		dc.w	sgrRRts-sgrTable	; THIRD ALTERNATIVE FONT
		dc.w	sgrRRts-sgrTable	; FOURTH ALTERNATIVE FONT
		dc.w	sgrRRts-sgrTable	; FIFTH ALTERNATIVE FONT
		dc.w	sgrRRts-sgrTable	; SIXTH ALTERNATIVE FONT
		dc.w	sgrRRts-sgrTable	; SEVENTH ALTERNATIVE FONT
		dc.w	sgrRRts-sgrTable	; EIGHTH ALTERNATIVE FONT
		dc.w	sgrRRts-sgrTable	; NINTH ALTERNATE FONT

		dc.w	sgrRRts-sgrTable	; FRAKTUR
		dc.w	sgrRRts-sgrTable	; DOUBLY UNDERLINED
		dc.w	sgrNormal-sgrTable	; NORMAL COLOR, NOT BOLD
		dc.w	sgrNotItalic-sgrTable	; NOT ITALIC, NOT FRAKTUR
		dc.w	sgrNotUnderscore-sgrTable ; NOT UNDERLINED
		dc.w	sgrRRts-sgrTable	; STEADY, NOT BLINKING
		dc.w	sgrRRts-sgrTable	; reserved
		dc.w	sgrPositive-sgrTable	; POSITIVE IMAGE
		dc.w	sgrRevealed-sgrTable	; REVEALED
		dc.w	sgrRRts-sgrTable	; NOT CROSSED OUT

		dc.w	sgrFgColor-sgrTable	; BLACK DISPLAY
		dc.w	sgrFgColor-sgrTable	; RED DISPLAY
		dc.w	sgrFgColor-sgrTable	; GREEN DISPLAY
		dc.w	sgrFgColor-sgrTable	; YELLOW DISPLAY
		dc.w	sgrFgColor-sgrTable	; BLUE DISPLAY
		dc.w	sgrFgColor-sgrTable	; MAGENTA DISPLAY
		dc.w	sgrFgColor-sgrTable	; CYAN DISPLAY
		dc.w	sgrFgColor-sgrTable	; WHITE DISPLAY
		dc.w	sgrRRts-sgrTable	; reserved
		dc.w	sgrFgDefault-sgrTable	; DEFAULT DISPLAY

		dc.w	sgrBgColor-sgrTable	; BLACK BACKGROUND
		dc.w	sgrBgColor-sgrTable	; RED BACKGROUND
		dc.w	sgrBgColor-sgrTable	; GREEN BACKGROUND
		dc.w	sgrBgColor-sgrTable	; YELLOW BACKGROUND
		dc.w	sgrBgColor-sgrTable	; BLUE BACKGROUND
		dc.w	sgrBgColor-sgrTable	; MAGENTA BACKGROUND
		dc.w	sgrBgColor-sgrTable	; CYAN BACKGROUND
		dc.w	sgrBgColor-sgrTable	; WHITE BACKGROUND
		dc.w	sgrRRts-sgrTable	; reserved
		dc.w	sgrBgDefault-sgrTable	; DEFAULT BACKGROUND


* -   -	SGR PRIMARY	-   -   -   -   -   -   -   -   -   -   -   -
*
*	PRIMARY RENDITION
*
sgrPrimary:
	; unset concealed, and reset BgPen for first call through
	; sgrNewMask

		clr.b	cu_ConcealMask(a2)
		clr.b	cu_BgPen(a2)

		move.b	cu_NormDMode(a2),d0
***		moveq	#RP_JAM2,d0
		bsr.s	setDrawMode

		bsr	sgrFgDefault
		bsr	sgrBgDefault

		moveq	#0,d0
		moveq	#FSF_BOLD+FSF_ITALIC+FSF_UNDERLINED,d1

	; if style has not been set, use defaults above

		tst.b	cu_NormStyle(a2)
		beq.s	setSoftStyle		; bsr ... rts

	; else restore using last saved defaults

		move.w	cu_NormAlgoStyle(a2),cu_AlgoStyle(a2)	;&TxFlags
		rts

* -   -	SGR BOLD	-   -   -   -   -   -   -   -   -   -   -   -
*
*	BOLD
*
sgrBold:
		moveq	#FSF_BOLD,d0
setBold:
		moveq	#FSF_BOLD,d1
		bra.s	setSoftStyle

* -   -	SGR ITALIC	-   -   -   -   -   -   -   -   -   -   -   -
*
*	ITALIC
*
sgrItalic:
		moveq	#FSF_ITALIC,d0
setItalic:
		moveq	#FSF_ITALIC,d1
setSoftStyle:

		lea	cd_RastPort(a6),a1
		LINKGFX	SetSoftStyle
		move.w	cd_RastPort+rp_AlgoStyle(a6),cu_AlgoStyle(a2)
sgrRRts:
		rts

* -   -	SGR UNDERSCORE	-   -   -   -   -   -   -   -   -   -   -   -
*
*	UNDERSCORE
*
sgrUnderscore:
		moveq	#FSF_UNDERLINED,d0
setUnderscore:
		moveq	#FSF_UNDERLINED,d1
		bra.s	setSoftStyle

* -   -	SGR NEGATIVE	-   -   -   -   -   -   -   -   -   -   -   -
*
*	NEGATIVE (REVERSE) IMAGE
*
sgrReverse:
		moveq	#RP_JAM2+RP_INVERSVID,d0
setDrawMode:
		move.b	d0,cu_ConcealDRMD(a2)
		tst.b	cu_ConcealMask(a2)
		bne.s	setConcealMD

setDRMD:
		lea	cd_RastPort(a6),a1
		LINKGFX	SetDrMd
		move.b	cd_RastPort+rp_DrawMode(a6),cu_DrawMode(a2)
		move.l	cd_RastPort+rp_minterms(a6),cu_Minterms(a2)
		move.l	cd_RastPort+rp_minterms+4(a6),cu_Minterms+4(a2)
setConcealMD:
		rts

* -   -	SGR CONCEALED	-   -   -   -   -   -   -   -   -   -   -   -
*
*	CONCEALED
*
sgrConcealed:
		move.b	#-1,cu_ConcealMask(a2)

	; cache pens

		move.b	cu_FgPen(a2),cu_ConcealFG(a2)
		move.b	cu_BgPen(a2),cu_ConcealBG(a2)

		moveq	#RP_JAM2,d0
		bsr.s	setDRMD

		move.b	cu_BgPen(a2),d0
		bsr.s	sgrSetAPen

		move.b	cu_BgPen(a2),d0
		bra.s	sgrSetBPen


* -   -	SGR NORMAL  - 	-   -   -   -   -   -   -   -   -   -   -   -
*
*	NORMAL COLOR, NOT BOLD
*
sgrNormal:
		moveq	#0,d0
		bsr.s	setBold
		bra.s	sgrFgDefault

* -   -	SGR NOT ITALIC	-   -   -   -   -   -   -   -   -   -   -   -
*
*	NOT ITALIC, NOT FRAKTUR
*
sgrNotItalic:
		moveq	#0,d0
		bra.s	setItalic

* -   -	SGR NOT UNDERLINED  -   -   -   -   -   -   -   -   -   -   -
*
*	NOT UNDERLINED

*
sgrNotUnderscore:
		moveq	#0,d0
		bra.s	setUnderscore

* -   -	SGR POSITIVE    -   -   -   -   -   -   -   -   -   -   -   -
*
*	NOT INVERSE VIDEO
*
sgrPositive:
		moveq	#RP_JAM2,d0
		bra.s	setDrawMode

* -   -	SGR REVEALED    -   -   -   -   -   -   -   -   -   -   -   -
*
*	NOT CONCEALED
*
sgrRevealed:

		clr.b	cu_ConcealMask(a2)

		move.b	cu_ConcealDRMD(a2),d0
		bsr.s	setDRMD

		move.b	cu_ConcealFG(a2),d0
		bsr.s	sgrSetAPen

		move.b	cu_ConcealBG(a2),d0
		bra.s	sgrSetBPen


* -   -	SGR DISPLAY	-   -   -   -   -   -   -   -   -   -   -   -
*
*	all DISPLAY colors
*
sgrFgFaint:
		moveq	#32,d0
		bra.s	sgrFgColor
sgrFgDefault:
		moveq	#30,d0
		add.b	cu_NormFG(a2),d0
sgrFgColor:
		sub.b	#30,d0
		move.b	d0,cu_ConcealFG(a2)
		tst.b	cu_ConcealMask(a2)
		bne.s	sgrConcealPen
sgrSetAPen:		
		move.b	d0,cu_FgPen(a2)
		lea	cd_RastPort(a6),a1
		LINKGFX	SetAPen
		move.l	cd_RastPort+rp_minterms(a6),cu_Minterms(a2)
		move.l	cd_RastPort+rp_minterms+4(a6),cu_Minterms+4(a2)
		bra.s	sgrNewMask
sgrConcealPen:
		rts

* -   -	SGR BACKGROUND	-   -   -   -   -   -   -   -   -   -   -   -
*
*	all BACKGROUND colors
*
sgrBgDefault:
		;--FIX, confusing BgColor with cell color

		move.b	cu_NormBG(a2),d0

*		moveq	#00,d0
*
*		move.b	cu_BgColor(a2),d0
		bra.s	sgrbcEntry

sgrBgColor:
		sub.b	#40,d0
sgrbcEntry:
		move.b	d0,cu_ConcealBG(a2)
		tst.b	cu_ConcealMask(a2)
		bne.s	sgrConcealPen
sgrSetBPen:
		move.b	d0,cu_BgPen(a2)
		lea	cd_RastPort(a6),a1
		LINKGFX	SetBPen
		move.l	cd_RastPort+rp_minterms(a6),cu_Minterms(a2)
		move.l	cd_RastPort+rp_minterms+4(a6),cu_Minterms+4(a2)

	; fall through

* -   -	SGR NEW MASK	-   -   -   -   -   -   -   -   -   -   -   -
*
*	recalc new drawing masks for faster scroll/clear/draw
*
sgrNewMask:

		move.b	cu_ScrollMask(a2),d0
		or.b	cu_BgPen(a2),d0
		or.b	cu_FgPen(a2),d0
		or.b	cu_BgColor(a2),d0

	; for a mask of 1, always use as is

		cmp.b	#1,d0
		beq.s	sgrsetNewMask

	; if 3 planes, use interleave scrolling (rare case)

		cmp.b	#3,d0
		bhi.s	sgrsetAllMask

	; 2 planes - common case for colors; see if reasonable
	; to mask, or scroll all based on depth of bitmap target

		cmp.b	#3,cu_Depth(a2)
		bhi.s	sgrsetNewMask		;4-8 planes; optimize

	; use mask of $FF (so we can get interleave scrolls)

sgrsetAllMask:
		moveq	#-1,d0

	
sgrsetNewMask:
		
	; use MinMask to disable masking for non V39 screens

		or.b	cu_MinMask(a2),d0

		move.b	d0,cu_ScrollMask(a2)
		move.b	d0,cu_Mask(a2)

		move.b	d0,cd_RastPort+rp_Mask(a6)
		rts


*- - -	DSR  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Device Status Report
*

DSR:
		bsr	getPNPWord
		cmp.w	#DSR_CPR,d0
		bne	nextChar

		LINKEXE	Forbid
		moveq	#0,d0
		move.w  cu_XCP(a2),d0
		addq.w	#1,d0
		move.l	d0,-(a7)
		move.w  cu_YCP(a2),d0
		addq.w	#1,d0
		move.l	d0,-(a7)
		move.l  a7,a1
		lea	dsrFormat(pc),a0
		lea	rawPutBBuff(pc),a2
		LINKEXE	RawDoFmt
		move.l	IO_UNIT(a3),a2
		addq.w	#8,a7
		LINKEXE	Permit
		bra	nextChar


dsrFormat:
		dc.b	$9B
		dc.b	'%ld;%ldR'
		dc.b	0
		ds.w	0

rawPutBBuff:
		tst.b	d0
		beq.s	rpbRts
		movem.l	a2/a6,-(a7)
		move.l	IO_UNIT(a3),a2
		move.l	IO_DEVICE(a3),a6
		bsr	PutReadByte
		movem.l	(a7)+,a2/a6
rpbRts:
		rts


*------ CSIpHandler --------------------------------------------------
*
*	CSIpHandler -- execute a single character private CSI function
*
CSIpHandler:
		sub.b	#$34,d0
		bmi	nextChar
		add.b	d0,d0	    ;also gets rid of msb
		move.w	csipTable(pc,d0.w),d0
		jmp	csipTable(pc,d0.w)

csipTable:

		dc.w	aSLPP-csipTable	; Set Page Length
		dc.w	aSLL-csipTable	; Set Line Length
		dc.w	nil-csipTable	;
		dc.w	nil-csipTable	;
		dc.w	aSLO-csipTable	; Set Left Offset
		dc.w	aSTO-csipTable	; Set Top Offset
		dc.w	nil-csipTable	;
		dc.w	aSRE-csipTable	; Set Raw Events
		dc.w	nil-csipTable	; (report raw events: read only)
		dc.w	aRRE-csipTable	; Reset Raw Events
		dc.w	nil-csipTable	; (report function keys: read only)
		dc.w	nil-csipTable	; ERROR


*- - -	aSLPP  - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Set Page Length
*
aSLPP:
		bsr	CursDisable
		bsr	getPNPWord
		tst.w	d0
		bmi.s	offSPL
		bset	#CUFB_FIXEDPL,cu_FixedFlags(a2)
		subq.w	#1,d0
		move.w	d0,cu_FixedYMax(a2)
		bra.s	setSize
offSPL:
		bclr	#CUFB_FIXEDPL,cu_FixedFlags(a2)
		bra.s	setSize


*- - -	aSLL - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Set Line Length
*
aSLL:
		bsr	CursDisable
		bsr	getPNPWord
		tst.w	d0
		bmi.s	offSLL
		bset	#CUFB_FIXEDLL,cu_FixedFlags(a2)
		subq.w	#1,d0
		move.w	d0,cu_FixedXMax(a2)
		bra.s	setSize
offSLL:
		bclr	#CUFB_FIXEDLL,cu_FixedFlags(a2)

setSize:
		bsr	ReSizeUnit
		bsr	CursEnable
		bra	nextChar


*- - -	aSLO - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Set Left Offset
*
aSLO:
		bsr	CursDisable
		bsr	getPNPWord
		tst.w	d0
		bmi.s	offSLO
		bset	#CUFB_FIXEDLO,cu_FixedFlags(a2)
		move.w	d0,cu_XROrigin(a2)
		bra.s	setSize
offSLO:
		bclr	#CUFB_FIXEDLO,cu_FixedFlags(a2)
		bra.s	setSize


*- - -	aSTO - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Set Top Offset
*
aSTO:
		bsr	CursDisable
		bsr	getPNPWord
		tst.w	d0
		bmi.s	offSTO
		bset	#CUFB_FIXEDTO,cu_FixedFlags(a2)
		move.w	d0,cu_YROrigin(a2)
		bra.s	setSize
offSTO:
		bclr	#CUFB_FIXEDTO,cu_FixedFlags(a2)
		bra.s	setSize


*- - -	aSRE - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Set Raw Events
*
aSRE:
		bsr	getPNPWord
		beq	nextChar
		cmp.w	#IECLASS_MAX,d0
		bhi.s	aSRE		; bgt unsigned
		move.w	d0,d1
		lsr.w	#3,d0
		andi.w	#7,d1
		lea	cu_RawEvents(a2),a0
		bset	d1,0(a0,d0.w)
		bra.s	aSRE


*- - -	aRRE - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Reset Raw Events
*
aRRE:
		bsr	getPNPWord
		beq	nextChar
		cmp.w	#IECLASS_MAX,d0
		bhi.s	aRRE		; bgt unsigned
		move.w	d0,d1
		lsr.w	#3,d0
		andi.w	#7,d1
		lea	cu_RawEvents(a2),a0
		bclr	d1,0(a0,d0.w)
		bra.s	aRRE


*------ CSIIpHandler -------------------------------------------------
*
*	CSIIpHandler -- a CSI function with private intermediate(s)
*
CSIIpHandler:
		;--	only handle ' ' intermediate
		cmp.w	#1,cu_PICNext(a2)
		bne	nextChar
		cmpi.b	#' ',cu_PICData(a2)
		bne	nextChar

		sub.b	#$30,d0
		beq.s	aSCR			; SET CURSOR RENDITION
		subq.b	#1,d0
		beq.s	aWSR			; WINDOW STATUS REPORT
		subq.b	#2,d0			; SET DEFAULT SGR SETTINGS
		bne	nextChar


* - - aSDSS - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*	Save current FG/BG COLOR as defaults (for defaults, and ESC0m)
*	Save current PEN STYLE(s) & DRAW MODE for ESC[0m
*
aSDSS:
		move.b	cu_FgPen(a2),cu_NormFG(a2)
		move.b	cu_BgPen(a2),cu_NormBG(a2)
		move.b	cu_ConcealDRMD(a2),cu_NormDMode(a2)
		move.w	cu_AlgoStyle(a2),cu_NormAlgoStyle(a2)
		move.b	#1,cu_NormStyle(a2)
		bra	nextChar

*- - -	aSCR - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Set Cursor Rendition
*
aSCR:

		bsr	CursDisable
		bsr	getPNPWord
		tst.w	d0
		bne.s	onSCR
		bsr	CursOff
		bra.s	endSCR
onSCR:
		bsr	CursOn
endSCR:
		bsr	CursEnable
		bra	nextChar


*- - -	aWSR - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Window Status Report
*
aWSR:
		LINKEXE	Forbid
		moveq	#0,d0
		move.w  cu_XMax(a2),d0
		addq.w	#1,d0
		move.l	d0,-(a7)
		move.w  cu_YMax(a2),d0
		addq.w	#1,d0
		move.l	d0,-(a7)
		move.l  a7,a1
		lea	wsrFormat(pc),a0
		lea	rawPutBBuff(pc),a2
		LINKEXE	RawDoFmt
		move.l	IO_UNIT(a3),a2
		addq.w	#8,a7
		LINKEXE	Permit
		bra	nextChar


wsrFormat:
		dc.b	$9B
		dc.b	'1;1;%ld;%ld r'
		dc.b	0
		ds.w	0


	END
@


36.72
log
@Spelling change
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.71 92/06/16 10:46:05 darren Exp Locker: darren $
d310 7
a316 1
*	in the same portions of your window.
@


36.71
log
@Remove clearing of Q draw flag; this kludge is being removed
for V39 console
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.70 92/03/26 14:27:52 darren Exp Locker: darren $
d344 1
a344 1
*	ROM Kernal Manual (Volume 1), exec/io.h
@


36.70
log
@change BEQ_S to beq.s
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.69 92/03/26 13:49:54 darren Exp Locker: darren $
a873 5
                ;-- Text has been written, so questionable
		;-- draw hack is cleared.

		bclr	#CUB_CURSQDRAW,cu_CursorFlags(a2)
		
a2377 1
		bclr	#CUB_CURSQDRAW,cu_CursorFlags(a2)
@


36.69
log
@Now supports new sequence (aSDSS) so that current SGR settings can
be saved as defaults
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.68 92/03/24 17:02:45 darren Exp Locker: darren $
d2360 1
a2360 1
		BEQ_S	aWSR			; WINDOW STATUS REPORT
@


36.68
log
@Move sub.l from d7 stuff so as not to effect CC
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.67 92/03/24 12:12:37 darren Exp Locker: darren $
a18 1

d234 12
a245 11
*	u   1-	aSLL SET LINE LENGTH (private Amiga sequence)
*	x   1-	aSLO SET LEFT OFFSET (private Amiga sequence)
*	y   1-	aSTO SET TOP OFFSET (private Amiga sequence)
*	{   n	aSRE SET RAW EVENTS (private Amiga sequence)
*	|   8	aIER INPUT EVENT REPORT (private Amiga Read sequence)
*	}   n	aRRE RESET RAW EVENTS (private Amiga sequence)
*	~   1	aSKR SPECIAL KEY REPORT (private Amiga Read sequence)
*	 p  1-	aSCR SET CURSOR RENDITION (private Amiga sequence)
*	 q  0	aWSR WINDOW STATUS REQUEST (private Amiga sequence)
*	 r  4	aWBR WINDOW BOUNDS REPORT (private Amiga Read sequence)
*	 v  1	aRAV RIGHT AMIGA V PRESS (private Amiga Read sequence-V37)
d312 12
d1915 2
a1916 1
		moveq	#RP_JAM2,d0
d1918 4
d1924 10
a1933 3
		bsr.s	setSoftStyle
		bsr	sgrFgDefault
		bra	sgrBgDefault		; bsr ... rts
d1954 1
d2073 2
a2074 1
		moveq	#31,d0
d2097 3
a2099 1
		moveq	#00,d0
d2360 16
a2375 1
		beq.s	aWSR			; WINDOW STATUS REPORT
a2376 1

@


36.67
log
@First pass at fixing the problem with long writes; now breaks
layers lock approx every 256 characters.  Also move DisplayBeep()
out of layer lock to fix deadlock bug.

Scroll optimization code modified yet again.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.66 92/03/23 12:46:34 darren Exp Locker: darren $
d505 1
a506 1
		subq.l	#1,d7
d611 1
a612 1
		subq.l	#1,d7
d672 1
a673 1
		subq.l	#1,d7
d759 1
a760 1
		subq.l	#1,d7
@


36.66
log
@First pass at creating a mask which is smarter... try to set
a mask which is a balance between the advantages of interleaved
scrolling, and optimize scrolling.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.65 92/03/19 12:43:53 darren Exp Locker: darren $
d339 1
a339 1
		movem.l d2-d6/a2-a4,-(a7)
d344 4
d410 3
d439 2
a451 1

d455 13
d483 1
a483 1
		movem.l (a7)+,d2-d6/a2-a4
a486 1

d506 1
d612 1
d673 1
d760 1
d1059 1
d1150 3
a1152 3
		move.l	cu_Window(a2),a0
		move.l	wd_WScreen(a0),a0
		LINKINT	DisplayBeep
d2107 4
a2110 20
	; use mask of all planes if calced mask is <= 1/2 display depth
	;
	; Depth      DepthMask   ScrollMask    Result
	;
	; 1          0           2-7           $FF
	; 2          1           2-7           $FF
	; 3          1           2-7           $FF
	; 4          2           2             $02	(== 1 plane too!)
	; 4          2           3-7           $FF      (== use interleave scroll)
	; 5          2           2             $02
	; 5          2           3-7           $FF
	; 6          3           2-3           $02-$03	(flicker possible)
	; 6          3           4-7           $FF
	; 7          3           2-3           $02-$03	(flicker possible)
	; 7          3           4-7           $FF
	; 8          4           2-4	       $02-$04	(flicker possible)
	; 8          4           5-7           $FF

		cmp.b	cu_DepthMask(a2),d0	;already 1/2
		bls.s	sgrsetNewMask
d2112 5
a2116 1
	; else mask all planes
d2118 3
d2135 1
@


36.65
log
@New autodocs for scroll fix bug, optimized scrolling, and concealed
mode.  Concealed mode no longer masks all graphics operations (which
incidently killed scrolling, clearing, and the cursor - yikes!).  Now
just changes pen colors.  SGR now calcs minimum # of bitplanes to
scroll/render in for speedy scrolls/draws.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.64 91/03/13 16:45:00 darren Exp Locker: darren $
d278 1
a278 1
*		8	- Set concealed mode.           (V36)
d1872 3
d1876 2
d2076 37
@


36.64
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.63 91/02/22 13:22:12 darren Exp Locker: darren $
d27 1
d278 1
a278 1
*		8	- Set concealed mode.
d300 12
d316 15
d367 5
a371 5
		move.l	cu_Mask(a2),cd_RastPort+rp_Mask(a6)
		bsr	RestoreRP
**		move.b	cu_DrawMode(a2),cd_RastPort+rp_DrawMode(a6)
**		move.l	cu_Minterms(a2),cd_RastPort+rp_minterms(a6)
**		move.l	cu_Minterms+4(a2),cd_RastPort+rp_minterms+4(a6)
d839 1
a839 1
		;-- drag hack is cleared.
d855 2
a856 2
		tst.b	cu_Mask(a2)
		bne.s	notConcealed
d1775 2
d1782 1
d1806 1
d1872 1
a1872 2
		moveq	#-1,d0			; $0FF
		bsr.s	setMask
d1923 5
d1933 1
d1941 16
a1956 7
		moveq	#0,d0
setMask:
		bsr	CursDisable
		lea	cd_RastPort(a6),a1
		move.b	d0,rp_Mask(a1)
		move.b	d0,cu_Mask(a2)
		bra	CursEnable	; bsr ... rts
d1997 12
a2008 2
		moveq	#-1,d0			; $0FF
		bra.s	setMask
d2021 4
d2030 2
d2049 4
d2058 18
a2077 1

d2082 1
@


36.63
log
@No change
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.62 91/02/14 14:57:51 darren Exp Locker: darren $
@


36.62
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.61 91/02/12 09:31:52 darren Exp Locker: darren $
@


36.61
log
@Spelling corrections - AUTODOCS.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.60 91/01/23 16:16:23 darren Exp Locker: darren $
@


36.60
log
@Fix for bug in FF handling.  Used CursUpdate() to restore cursor which
checks to see if cursor has moved, and if not, doesn't draw the cursor.
Result being that cursor gets cleared, and never redrawn if its already
at 0,0.  Also attributes screwy after ClearDisplay (not restoring
DrawMode - fixed in clear.asm).  New code is a subset of CursUpdate().
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.59 91/01/03 18:51:13 darren Exp Locker: darren $
d157 1
a157 1
*	high nibble first, seperated by a slash.  Thus 01/11 (ESC) is
d194 1
a194 1
*	ISO Compatable Escape Sequences (introduced by Esc) --
d203 2
a204 2
*	indicates less is valid.  Parameters are seperated by
*	semicolins, e.g. Esc[14;80H sets the cursor position to row
d214 1
a214 1
*	F   1-	CPL  CURSOR PRECEEDING LINE
d248 1
a248 1
*	following parameters, seperated by semicolins --
@


36.59
log
@Remove reseting of attributes on FF; to be ANSI proper,
and V34 compatable - this may have to go back into the
Shell if users desire it.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.58 90/12/26 15:06:43 darren Exp Locker: darren $
a27 1

d63 1
d70 1
d340 4
a343 3
		move.b	cu_DrawMode(a2),cd_RastPort+rp_DrawMode(a6)
		move.l	cu_Minterms(a2),cd_RastPort+rp_minterms(a6)
		move.l	cu_Minterms+4(a2),cd_RastPort+rp_minterms+4(a6)
d1154 1
a1156 6
		;-- Fix for 1.3 compatability
		;-- resets attributes, and colors after
		;-- CTRL L

**		bsr	sgrPrimary

d1165 7
a1171 1
		bsr	CursUpdate
@


36.58
log
@Document SGR's V34-V36
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.57 90/12/12 15:39:14 darren Exp Locker: darren $
d243 1
a243 1
*	 v  1	aRAV RIGHT AMIGA V PRESS (private amiga Read sequence-V37)
d1158 1
a1158 1
		bsr	sgrPrimary
@


36.57
log
@Fixes - disable rendering optimizations for non-character mapped
unit 0 windows.  Also fixes a problem with filling white-space.
White space is now filled attributes of valid character, and
fg/bg pen colors set to global background color.  Also put
a single last check for window size change - should never be executed - safety.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.56 90/12/03 15:09:02 darren Exp Locker: darren $
d253 44
@


36.56
log
@Added comment regarding reserving CSI "]" for
developers - being used by Bill Hawes in DisplayHandler.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.55 90/11/29 19:45:43 darren Exp Locker: darren $
d85 1
d98 18
d276 1
a276 1
		bsr	GetEvents	;handle pending events
d281 6
d306 1
a306 1
		bne.s	loop
d317 1
a317 1
loop:
a325 1
		;actual == 0L set above
d329 10
d340 7
a357 1

d773 1
a773 1
		movem.l	d2-d4/a4,-(a7)
d802 10
d872 1
a872 1
		move.w	d4,(a1)
d934 1
a934 1
		move.w	d4,(a1)+
d954 1
a954 1
		movem.l	(a7)+,d2-d4/a4
@


36.55
log
@Bug fix - vanilla text lines longer then 32K not handled
properly; border trashing, confusion, etc.  Should be no
change in code size - couple of changes only on register
operations (promotion of .w size to .l size).
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.54 90/11/20 18:50:12 darren Exp Locker: darren $
d97 7
@


36.54
log
@Documentation change - addition of a new private Amiga
read sequence (V37).  aRAV == "<CSI>0 v" means the user
pressed RIGHT AMIGA V, and wants to paste some text from
the clipboard.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.53 90/11/14 13:37:42 darren Exp Locker: darren $
d665 1
a665 1
		cmp.w	d3,d2
d923 1
a923 1
		sub.w	d3,d2		;update vanilla count
@


36.53
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.52 90/11/05 18:04:29 darren Exp Locker: darren $
d217 1
@


36.52
log
@Sigh, put back some code which checks layers refresh damage bit
after a write - I had assumed I'd get a message after a scroll
raster, or other such condition.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.51 90/11/02 07:59:53 darren Exp Locker: darren $
@


36.51
log
@branch.s optimization
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.50 90/11/01 16:51:55 darren Exp Locker: darren $
d311 9
a319 9
*		tst.l	cu_CM+cm_AllocSize(a2)
*		beq.s	unlockDR
*		;-- check for LAYERREFRESH generated here
*		move.l	cd_RastPort+rp_Layer(a6),a0
*		move.w	lr_Flags(a0),d0
*		and.w	#LAYERREFRESH,d0
*		beq.s	unlockDR
*		
*		bsr	RefreshDamage
@


36.50
log
@Removed some extra baggage following the small window
size fix-up.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.49 90/11/01 16:35:26 darren Exp Locker: darren $
a17 1
	INCLUDE	"debug.i"
d461 1
a461 1
		bne	escIFp
@


36.49
log
@A simple patch added for windows which are too small to render
in.  This is not what I'd like to do in an ideal world, but
time constraints, and rom-space limit the amount of effort spent
on handling the unusual case of tiny windows.  Now, we write
nothing, and exit cleanly with io_Actual set to 0.  Simple, and neat.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.48 90/11/01 11:24:47 darren Exp Locker: darren $
a18 1
	INCLUDE	"kputs.i"
d286 9
a294 1
		;actual == 0L
d660 1
a660 3
		moveq	#1,d3		; 1 if too small, else clear upper word
		btst	#CUB_TOOSMALL,cu_Flags(a2)
		bne	updateWriteCount
a719 1
textOutputDone:
@


36.48
log
@New input handling code.  Now handles pending events using a 
general purpose routine which also tracks history of events,
and window activation states.  A semaphore is used before
accessing the code which access the list of events.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.47 90/10/11 15:29:31 darren Exp Locker: darren $
d19 1
d287 5
d303 1
d305 9
a313 9
		tst.l	cu_CM+cm_AllocSize(a2)
		beq.s	unlockDR
		;-- check for LAYERREFRESH generated here
		move.l	cd_RastPort+rp_Layer(a6),a0
		move.w	lr_Flags(a0),d0
		and.w	#LAYERREFRESH,d0
		beq.s	unlockDR
		
		bsr	RefreshDamage
d655 1
a655 1
		bne	textOutputDone
@


36.47
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.46 90/10/08 11:25:51 darren Exp Locker: darren $
d17 2
d36 2
d80 1
d84 1
d245 3
d250 1
a250 4
		;-- quick check for any pending things
		move.b	cu_Flags(a2),d0
		and.b	#CUF_RESIZE!CUF_REFRESH!CUF_SELECTED,d0
		beq.s	wSetAttrs
d252 2
a253 4
		;-- check for pending resize
		bclr	#CUB_RESIZE,cu_Flags(a2)
		beq.s	wCheckTooSmall
		bsr	ReSizeUnit
a254 13
wCheckTooSmall:
		;-- check for pending refresh
		tst.l	cu_CM+cm_AllocSize(a2)
		beq.s	wCheckSelecting
		move.l	cd_RastPort+rp_Layer(a6),a0
		move.w	lr_Flags(a0),d0
		and.w	#LAYERREFRESH,d0
		beq.s	wCheckSelecting

		bclr	#CUB_REFRESH,cu_Flags(a2)
		bsr	RefreshDamage

wCheckSelecting:
@


36.46
log
@Fix for background/cell character
handling.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.45 90/08/13 13:57:32 darren Exp Locker: darren $
@


36.45
log
@Fix bug with memacs - now if
text is drawn, or cursor rendition
set, then the cursor is always drawn from
then on ... see also cursor.asm
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.44 90/06/07 13:57:05 kodiak Exp $
d1051 6
d1871 5
a1875 1
		move.b	cu_BgColor(a2),d0
d1877 1
@


36.44
log
@space saving by recoding btst to tst of sign bit for CUB_IMPLICITNL
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.43 90/06/07 10:33:05 kodiak Exp Locker: kodiak $
d6 1
a6 1
**      (C) Copyright 1985,1989 Commodore-Amiga, Inc.
d678 1
a678 1
		bset.b	#CDB_CLIPINSTALLED,cd_Flags(a6)
d691 2
a692 1
installClipReg:
d714 3
d718 2
d2081 2
@


36.43
log
@change way CONCEALED characters are stored to make them RENDERED, but
with same Fg & Bg color.  So RENDERED is set from beginning to end
of line.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.42 90/06/06 16:24:51 kodiak Exp Locker: kodiak $
d88 3
d740 2
a741 2
		btst.b	#CUB_IMPLICITNL,cu_Flags(a2)
		beq.s	setRendered
@


36.42
log
@set background color of empty cells before tabs to the current
character background color
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.41 90/06/06 14:29:40 kodiak Exp Locker: kodiak $
a717 1
		moveq	#0,d4
d719 1
a719 1
		lsl.b	#CMAS_SOFTSTYLE-CMAS_BGPEN,d4
d722 7
d731 1
d738 1
a738 1
		beq.s	chkConcealed
d741 1
a741 3
chkConcealed:
		tst.b	cu_Mask(a2)
		beq.s	initToCP
a743 1

a744 1
initToCP:
@


36.41
log
@makes cu_BgColor the same as cu_BgPen upon ^L unless otherwise specified
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.40 90/05/30 17:11:18 kodiak Exp Locker: kodiak $
d378 1
a378 1
		beq.s	c1Ctrl	    ;  go perform C1 control
a380 3
c1Ctrl:
		bra	C1Handler   ;go perform C1 code

d715 1
a715 1
		movem.l	d2-d3/a4,-(a7)
d717 23
d741 1
d801 1
a801 1
		move.w	#CMAF_RENDERED,(a1)
d863 1
a863 1
		move.w	#CMAF_RENDERED,(a1)+
d868 1
a868 18
		;--	build text attribute
		moveq	#0,d2
		move.b	cu_AlgoStyle(a2),d2
		lsl.b	#CMAS_SOFTSTYLE-CMAS_BGPEN,d2
		or.b	cu_BgPen(a2),d2
		lsl.w	#CMAS_BGPEN,d2
		or.b	cu_FgPen(a2),d2

		btst.b	#2,cu_DrawMode(a2)	; RP_INVERSVID
		beq.s	chkImplicit
		bset	#CMAB_INVERSVID,d2

chkImplicit:
		btst.b	#CUB_IMPLICITNL,cu_Flags(a2)
		beq.s	chkTabbed
		bset	#CMAB_IMPLICITNL,d2

chkTabbed:
a869 5
		beq.s	chkConcealed
		bset	#CMAB_TABBED,d2

chkConcealed:
		tst.b	cu_Mask(a2)
d871 1
a871 1
		bset	#CMAB_RENDERED,d2
d874 2
d878 2
a879 2
		move.w	d2,(a1)+
		bclr	#CMAB_TABBED,d2
a881 1
		movem.l	(a7)+,d2-d3/a4
d883 2
d923 1
a923 1
		moveq	#1,d2		;output one character
d926 2
a927 3
		move.w	d0,-(a7)
		move.l	a7,a4		;point to 8-bit-set character
		addq	#1,a4		;
d929 1
a929 1
		addq.l	#2,a7
@


36.40
log
@correctly initializes character map when tabs are used
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.39 90/05/25 13:46:57 kodiak Exp Locker: kodiak $
d911 1
a911 2
		bsr	CursEnable
		rts
d1597 1
a1597 1
		beq	nextChar
d1604 1
d1606 1
a1606 3
		bge	nextChar
		cmp.w	#300,d0
		blt.s	sgrChk3n
d1608 3
a1610 4
		bra.s	sgrSetGlobBG
sgrChk3n:
		sub.w	#30,d0
		bmi.s	sgrChk3
d1612 1
a1612 6
		bge	nextChar
		bra.s	sgrSetGlobBG
sgrChk3:
		cmp.w	#3-30,d0	; just ">" ?
		bne	nextChar
		moveq	#0,d0		; default
d1615 2
d1619 1
a1619 1
		beq	nextChar
d1623 1
a1623 1
		beq	nextChar
d1626 1
d1629 9
a1707 2
sgrRRts:
		rts
d1723 1
a1723 2
		bsr	sgrBgDefault
		rts
d1747 1
d1785 1
a1785 2
		bsr	CursEnable
		rts
@


36.39
log
@one more stab making SGR w/ no parameter work
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.38 90/05/21 23:46:24 kodiak Exp Locker: kodiak $
d797 13
a809 1
checkingLeftOK:
@


36.38
log
@fix bounds of cu result
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.37 90/05/16 11:35:21 kodiak Exp $
a577 2
		cmp.w	#-5,cu_PNPData-cu_PNPCurr(a0,d1.w)
		beq.s	epnpMark
a1246 1
		move.w	d1,(a0)
d1248 3
a1272 1
		beq.s	cuDefault
a1274 1
cuDefault:
a1857 1
		beq	nextChar
a1930 1
		beq.s	offSPL
a1948 1
		beq.s	offSLL
a1970 1
		beq.s	offSLO
a1987 1
		beq.s	offSTO
a2056 1
		beq.s	onSCR
@


36.37
log
@no longer need check if intuition is open
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.36 90/05/10 17:55:34 kodiak Exp Locker: kodiak $
d1274 2
a1275 2
		cmp.w	#-5,d0
		bne.s	cuSpecified
@


36.36
log
@fix parsing of aSCR
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.35 90/05/10 16:59:50 kodiak Exp Locker: kodiak $
a969 2
		tst.l	cd_IntuitionLib(a6)
		beq.s	noIntuition
a972 1
noIntuition:
@


36.35
log
@set up a2/a6 inside rawdofmt callback
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.34 90/05/01 14:02:49 kodiak Exp Locker: kodiak $
a2014 2
		tst.w	d0
		bmi.s	aSRE
d2016 1
a2016 1
		bgt.s	aSRE
a2031 2
		tst.w	d0
		bmi.s	aRRE
d2033 1
a2033 1
		bgt.s	aRRE
d2069 1
a2069 1
		bmi.s	onSCR
@


36.34
log
@Uses background color as default background pen instead of zero.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.33 90/04/20 09:45:46 kodiak Exp Locker: kodiak $
a1875 1
		movem.l	a2/a3,-(a7)
a1876 1
		move.l	a2,a3
d1879 1
a1879 1
		movem.l	(a7)+,a2/a3
d1894 3
a1896 1
		exg	a2,a3
d1898 1
a1898 1
		exg	a2,a3
a2096 1
		movem.l	a2/a3,-(a7)
a2097 1
		move.l	a2,a3
d2100 1
a2100 1
		movem.l	(a7)+,a2/a3
@


36.33
log
@first semi-tested big clip support
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.32 90/04/17 14:55:40 kodiak Exp $
d1844 2
a1845 1
		moveq	#40,d0
d1848 1
@


36.32
log
@fix resize of wrapped tabs
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.31 90/04/13 13:33:05 kodiak Exp Locker: kodiak $
d45 1
a45 5
	XREF	SizeBuff
	XREF	PutBBuff
	XREF	PutWBuff
	XREF	GetBBuff
	XREF	GetWBuff
d82 3
d320 2
a321 1
		TSTBUFFER cu_ReadBuffer(a2)
d401 2
a402 1
escIOrFp    BTST    #4,d0   ;check for I group
d406 1
a406 2
		lea	cu_PICBuffer(a2),a0
		bsr	PutBBuff
d411 2
a412 1
escFp	    BRA	    E2FpHandler ;(there are initially none)
d428 13
d460 1
a460 2
		lea	cu_PICBuffer(a2),a0
		bsr	PutBBuff
d497 2
a498 3
		FLUSHBUFFER	cu_PICBuffer(a2)	; leaves d0 alone
		lea	cu_PICBuffer(a2),a0
		bsr	PutBBuff
d504 3
a506 2
		LEALASTIN	cu_PNPBuffer(a2),a0
		cmpi.b	#'9',d0
d509 1
a509 1
		move.w	(a0),d0
d519 1
a519 1
		move.w	d0,(a0)
d535 7
a541 3
		moveq	#-5,d0
		lea	cu_PNPBuffer(a2),a0
		bsr	PutWBuff
d552 3
d559 2
d574 15
d608 1
a608 2
		lea	cu_PICBuffer(a2),a0
		bsr	PutBBuff
d618 2
d1107 1
a1107 1
		FLUSHBUFFER	cu_PICBuffer(a2)
d1124 2
a1125 4
		FLUSHBUFFER	cu_PNPBuffer(a2)
		moveq	#-5,d0
		lea	cu_PNPBuffer(a2),a0
		bsr	PutWBuff
d1247 7
a1253 4
getPPWord:
		lea	cu_PNPBuffer(a2),a0
		bsr	GetWBuff
		tst.l	d0
d1275 4
a1278 4
		bsr.s	getPPWord
		bmi.s	cuDefault
		tst.w	d0
		bgt.s	cuSpecified
d1475 2
a1476 2
		bsr	getPPWord
		bmi	nextChar
d1518 2
a1519 2
		bsr	getPPWord
		bmi	nextChar
d1539 2
a1540 2
		bsr	getPPWord
		bmi	nextChar
d1577 2
a1578 2
		bsr	getPPWord
		bmi	nextChar
d1590 2
a1591 2
		bsr	getPPWord
		bmi	nextChar
d1635 4
a1638 3
		add.b	d0,d0
		move.w	sgrTable(pc,d0.w),d0
		jsr	sgrTable(pc,d0.w)
d1676 8
a1683 8
		dc.w	sgrFgColor0-sgrTable	; BLACK DISPLAY
		dc.w	sgrFgColor1-sgrTable	; RED DISPLAY
		dc.w	sgrFgColor2-sgrTable	; GREEN DISPLAY
		dc.w	sgrFgColor3-sgrTable	; YELLOW DISPLAY
		dc.w	sgrFgColor4-sgrTable	; BLUE DISPLAY
		dc.w	sgrFgColor5-sgrTable	; MAGENTA DISPLAY
		dc.w	sgrFgColor6-sgrTable	; CYAN DISPLAY
		dc.w	sgrFgColor7-sgrTable	; WHITE DISPLAY
d1687 8
a1694 8
		dc.w	sgrBgColor0-sgrTable	; BLACK BACKGROUND
		dc.w	sgrBgColor1-sgrTable	; RED BACKGROUND
		dc.w	sgrBgColor2-sgrTable	; GREEN BACKGROUND
		dc.w	sgrBgColor3-sgrTable	; YELLOW BACKGROUND
		dc.w	sgrBgColor4-sgrTable	; BLUE BACKGROUND
		dc.w	sgrBgColor5-sgrTable	; MAGENTA BACKGROUND
		dc.w	sgrBgColor6-sgrTable	; CYAN BACKGROUND
		dc.w	sgrBgColor7-sgrTable	; WHITE BACKGROUND
d1799 1
d1825 2
a1826 2
sgrFgColor0:
		moveq	#0,d0
a1827 1
sgrFgColor1:
d1829 1
a1829 20
		moveq	#1,d0
		bra.s	sgrFgColor
sgrFgColor2:
sgrFgFaint:
		moveq	#2,d0
		bra.s	sgrFgColor
sgrFgColor3:
		moveq	#3,d0
		bra.s	sgrFgColor
sgrFgColor4:
		moveq	#4,d0
		bra.s	sgrFgColor
sgrFgColor5:
		moveq	#5,d0
		bra.s	sgrFgColor
sgrFgColor6:
		moveq	#6,d0
		bra.s	sgrFgColor
sgrFgColor7:
		moveq	#7,d0
d1831 1
a1842 1
sgrBgColor0:
d1844 1
a1844 22
		moveq	#0,d0
		bra.s	sgrBgColor
sgrBgColor1:
		moveq	#1,d0
		bra.s	sgrBgColor
sgrBgColor2:
		moveq	#2,d0
		bra.s	sgrBgColor
sgrBgColor3:
		moveq	#3,d0
		bra.s	sgrBgColor
sgrBgColor4:
		moveq	#4,d0
		bra.s	sgrBgColor
sgrBgColor5:
		moveq	#5,d0
		bra.s	sgrBgColor
sgrBgColor6:
		moveq	#6,d0
		bra.s	sgrBgColor
sgrBgColor7:
		moveq	#7,d0
d1846 1
d1860 3
a1862 2
		bsr	getPPWord
		cmpi.l	#DSR_CPR,d0
d1876 1
a1876 1
		lea	cu_ReadBuffer(a2),a3
d1894 3
a1896 2
		move.l	a3,a0
		bsr	PutBBuff
d1906 2
a1907 1
		sub.b	#$30,d0
d1913 1
a1913 4
		dc.w	nil-csipTable	;
		dc.w	nil-csipTable	;
		dc.w	nil-csipTable	;
		dc.w	nil-csipTable	;
d1934 2
a1935 1
		bsr	getPPWord
d1937 1
a1937 1
		ble.s	offSPL
d1953 2
a1954 1
		bsr	getPPWord
d1956 1
a1956 1
		ble.s	offSLL
d1976 2
a1977 1
		bsr	getPPWord
d1994 2
a1995 1
		bsr	getPPWord
d2011 2
a2012 2
		bsr	getPPWord
		bmi	nextChar
d2030 2
a2031 2
		bsr	getPPWord
		bmi	nextChar
d2049 5
a2053 10
		move.l	d0,-(a7)
		lea	cu_PICBuffer(a2),a0
		bsr	GetBBuff
		cmpi.l	#' ',d0			; only handle ' '
		bne	popD0NextChar
		lea	cu_PICBuffer(a2),a0
		bsr	SizeBuff		; only one intermediate
		tst.l	d0
		bne.s	popD0NextChar
		move.l	(a7)+,d0
d2056 3
a2058 6
		add.b	d0,d0	    ;also gets rid of msb
		move.w	csii20pTable(pc,d0.w),d0
		jmp	csii20pTable(pc,d0.w)

popD0NextChar:
		addq.l	#4,a7
a2060 17
csii20pTable:
		dc.w	aSCR-csii20pTable	; SET CURSOR RENDITION
		dc.w	aWSR-csii20pTable	; WINDOW STATUS REQUEST
		dc.w	nil-csii20pTable	; WINDOW BOUNDS REPORT
		dc.w	nil-csii20pTable	;
		dc.w	nil-csii20pTable	;
		dc.w	nil-csii20pTable	;
		dc.w	nil-csii20pTable	;
		dc.w	nil-csii20pTable	;
		dc.w	nil-csii20pTable	;
		dc.w	nil-csii20pTable	;
		dc.w	nil-csii20pTable	;
		dc.w	nil-csii20pTable	;
		dc.w	nil-csii20pTable	;
		dc.w	nil-csii20pTable	;
		dc.w	nil-csii20pTable	;
		dc.w	nil-csii20pTable	;
a2061 2


d2068 2
a2069 1
		bsr	getPPWord
d2071 1
a2071 1
		bne.s	onSCR
d2097 1
a2097 1
		lea	cu_ReadBuffer(a2),a3
d2111 1
@


36.31
log
@use Id instead of Header for 4.x rcs
@
text
@d2 1
a2 1
**	$Id$
d687 1
a687 1
		blt.s	checkLeft
d690 2
a691 2
		beq.s	fillBuffer
		blt.s	checkLeft
d719 1
a719 4
		move.w	cu_XCP(a2),d1
		beq.s	fillBuffer
		moveq	#0,d0			; offset in d0, count in d1
		bra.s	fillLineGap
d721 31
d761 1
d813 1
a813 1
		beq.s	chkConcealed
d816 5
d830 1
@


36.30
log
@bound origin & window size, and move TOOSMALL to just skip graphics rendering
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/write.asm,v 36.29 90/04/11 17:54:01 kodiak Exp Locker: kodiak $
@


36.29
log
@bound user specified window limits to actual limits
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/write.asm,v 36.28 90/04/10 11:37:30 kodiak Exp Locker: kodiak $
d241 1
a241 1
		and.b	#CUF_TOOSMALL!CUF_RESIZE!CUF_REFRESH!CUF_SELECTED,d0
a249 4
		;-- check for renderable area
		btst	#CUB_TOOSMALL,cu_Flags(a2)
		bne	unlockDR

d619 3
a622 1
		moveq	#0,d3
d677 1
d818 1
a818 1
g0CursUpdate
@


36.28
log
@fix default SGR w no parameters
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/write.asm,v 36.27 90/04/02 10:47:47 kodiak Exp Locker: kodiak $
d1904 1
a1904 1
		move.w	d0,cu_YMax(a2)
d1922 1
a1922 1
		move.w	d0,cu_XMax(a2)
@


36.27
log
@for 4.x rcs
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/write.asm,v 36.26 90/03/06 11:25:46 kodiak Exp Locker: kodiak $
d1520 1
a1520 1
		bpl.s	sgrStandard
d1523 2
d1555 1
a1555 3
sgrStandard:
		tst.w	d0
		bpl.s	sgrSpecified
@


36.26
log
@changed background color from private control sequence to private
parameter of SGR sequence a la Tek 4106/4107/4109/CX terminals
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.25 90/03/03 14:55:57 kodiak Exp $
@


36.25
log
@first cut @@ code to set console background color
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.24 90/02/21 18:40:39 kodiak Exp $
a209 1
*	 s  1-	aSBC SET BACKGROUND COLOR (private Amiga sequence)
d1520 35
a2033 1
		dc.w	aSBC-csii20pTable	;
d2046 1
a2097 22

*- - -	aSBC - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Set Background Color
*
aSBC:
		bsr	getPPWord
		tst.w	d0
		bge.s	asbcHaveColor

		moveq	#0,d0		; default

asbcHaveColor:
		cmp.b	cu_BgColor(a2),d0
		beq	nextChar

		tst.l	cu_CM+cm_AllocSize(a2)
		beq	nextChar

		move.b	d0,cu_BgColor(a2)
		bsr	RefreshUnit
		bra	nextChar
@


36.24
log
@first cut at drag-select
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.23 89/12/15 17:50:02 kodiak Exp $
d78 1
d210 1
d222 2
a223 1
*	Does not display cursor in SuperBitMap layers.
d2000 1
a2012 1
		dc.w	nil-csii20pTable	;
d2064 22
@


36.23
log
@Only InstallClipRegion when necessary
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.22 89/12/15 11:09:19 kodiak Exp $
d239 1
a239 1
		and.b	#CUF_TOOSMALL!CUF_RESIZE!CUF_REFRESH!CUF_SELECTING,d0
d265 1
a265 1
		bclr	#CUB_SELECTING,cu_Flags(a2)
@


36.22
log
@eliminate damage after resize so redundant refresh doesn't occur
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.21 89/12/14 17:13:32 kodiak Exp $
d240 1
a240 1
		beq.s	wInstallClipReg
d266 1
a266 1
		beq.s	wInstallClipReg
a268 7
wInstallClipReg:
		;-- install the clip region
		move.l	cd_RastPort+rp_Layer(a6),a0
		move.l	cu_ClipRegion(a2),a1
		LINKLAY	InstallClipRegion
		move.l	d0,cd_PrevClipRegion(a6)

d308 1
a308 1
		beq.s	wUninstallClipReg
d313 1
a313 1
		beq.s	wUninstallClipReg
a317 5
wUninstallClipReg:
		move.l	cd_RastPort+rp_Layer(a6),a0
		move.l	cd_PrevClipRegion(a6),a1
		LINKLAY	InstallClipRegion

a629 2
		moveq	#0,d0
		move.w	d3,d0
a631 2
		move.l	a4,a0
		lea	cd_RastPort(a6),a1
d634 30
d672 3
@


36.21
log
@(eliminate unused XLVOs)
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.20 89/12/14 17:03:52 kodiak Exp $
a77 1
	XREF	RefreshUnit
@


36.20
log
@different damage refresh strategy: should always clear damage
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.19 89/12/07 15:52:10 kodiak Exp $
d41 1
a41 3
	XLVO	BeginUpdate		; Layers
	XLVO	EndUpdate		;
	XLVO	InstallClipRegion	;
@


36.19
log
@fix initialization of beginning of line caused when NL NL followed by TAB
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.18 89/12/04 22:55:50 kodiak Exp $
d79 1
a80 1
	XREF	RefreshWindow
a239 2
		bclr	#CDB_SCROLL,cd_Flags(a6)

d256 1
a256 1
		bclr	#CUB_REFRESH,cu_Flags(a2)
d258 4
a261 1
		bsr	RefreshWindow
d263 3
a278 8
		;-- get LAYERREFRESH flag
		tst.l	cu_CM+cm_AllocSize(a2)
		beq.s	wSetAttrs
		move.l	cd_RastPort+rp_Layer(a6),a0
		move.w	lr_Flags(a0),d0
		and.w	#LAYERREFRESH,d0
		move.w	d0,cd_LayerRefresh(a6)

a319 2
		bclr	#CDB_SCROLL,cd_Flags(a6)
		beq.s	wUninstallClipReg
d325 1
a325 3
		;-- perform BeginUpdate/Refresh/EndUpdate
		move.l	cd_RastPort+rp_Layer(a6),a0
		LINKLAY	BeginUpdate
a326 15
		bsr	RefreshUnit

		LINKEXE	Forbid
		moveq	#0,d0
		tst.w	cd_LayerRefresh(a6)
		seq	d0		; so TRUE if no prev damage, else FALSE
		move.l	cd_RastPort+rp_Layer(a6),a0
		LINKLAY	EndUpdate

		move.l	cd_RastPort+rp_Layer(a6),a0
		move.w	lr_Flags(a0),d0
		and.w	#~LAYERREFRESH,d0
		or.w	cd_LayerRefresh(a6),d0
		move.w	d0,lr_Flags(a0)
		LINKEXE	Permit
@


36.18
log
@checkin for release on Monday 4 Dec -- map w/ indirect line buffers
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.17 89/12/03 16:36:33 kodiak Exp $
d727 1
a727 1
		move.w	cu_XCP(a2),d0
d729 2
@


36.17
log
@Sunday checkin
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.16 89/12/02 11:37:37 kodiak Exp $
d710 1
a710 2
		move.w	cu_CM+cm_DisplayWidth(a2),d2
		subq.w	#1,d2
d715 3
a718 1
		move.w	d2,d0
d722 1
@


36.16
log
@
@
text
@d2 1
a2 1
**	$Header$
d737 13
a749 3
		lsl.w	#1,d1			; y line length pointer offset
		move.l	cu_CM+cm_DispLineLengths(a2),a0
		move.w	0(a0,d1.w),d1
a803 14
		;-- update display line length
		move.w	cu_YCP(a2),d1
		lsl.w	#1,d1			; y line length pointer offset
		move.l	cu_CM+cm_DispLineLengths(a2),a0
		add.w	d1,a0			; line length word
		move.w	cu_XCP(a2),d0
		beq.s	updateLineLength
		;--	this is the first write on this line: check DisplayYL
updateLineLength:
		add.w	d3,d0
		cmp.w	(a0),d0
		ble.s	updateWriteCount
		move.w	d0,(a0)

d814 1
a814 1
		blt.s	g0CursEnable
d817 1
a817 1
		ble.s	g0CursEnable
d822 1
@


36.15
log
@first cut at line buffers
@
text
@d1 9
a9 70
	TTL	'$Header: write.asm,v 36.14 89/11/10 12:19:40 kodiak Exp $'
**********************************************************************
*
*			--------------
*   write.asm		CONSOLE DEVICE	workhorse console write command
*			--------------
*
*   Copyright 1985, 1987 Commodore-Amiga Inc.
*
*   Source Control	$Locker: kodiak $
*
*   $Log:	write.asm,v $
*   Revision 36.14  89/11/10  12:19:40  kodiak
*   document io_Data bumping
*   
*   Revision 36.13  89/11/04  16:06:10  kodiak
*   restructure map variables
*   use XLVO macro strategy
*   update Display.L variables
*   
*   Revision 36.12  89/09/15  15:39:17  kodiak
*   implement SGR 2x codes
*   
*   Revision 36.11  89/09/11  16:47:54  kodiak
*   *** empty log message ***
*   
*   Revision 36.10  89/09/11  13:00:18  kodiak
*   ensure no holes in rendering between character and left edge
*   
*   Revision 36.9  89/08/30  10:51:22  kodiak
*   updated autodoc again
*   
*   Revision 36.8  89/08/21  12:54:04  kodiak
*   keep CMA,IMPLICITNL current in attribute array
*   
*   Revision 36.7  89/07/10  18:19:45  kodiak
*   recode use of attribute fields in attribute buffer
*   
*   Revision 36.6  89/07/07  13:28:54  kodiak
*   use SCROLL flag, not LAYERREFRESH flag to trigger Update
*   fix uninstallcliprect call to have layer in a0 always
*   
*   Revision 36.5  89/07/05  15:23:21  kodiak
*   move scrolling to scroll.asm
*   only refresh windows w/ character maps
*   
*   Revision 36.4  89/06/28  19:14:36  kodiak
*   better avoidance of cursor spoor
*   
*   Revision 36.3  89/06/28  13:38:17  kodiak
*   implement update of scroll damage
*   implement Esc[2J
*   
*   Revision 36.2  88/11/14  16:04:51  kodiak
*   coalesce NEG, SUB #1 into NOT
*   
*   Revision 36.1  88/09/19  10:16:20  kodiak
*   add character map and pseudo-clipboard support
*   
*   Revision 36.0  88/09/06  19:52:49  kodiak
*   *** empty log message ***
*   
*   Revision 35.1  87/10/26  12:58:28  kodiak
*   Change rendering strategy to use a single shared device RastPort
*   Disable cursor only once around multi-line vanilla character writes
*   
*   Revision 35.0  87/10/26  11:14:42  kodiak
*   initial from V34, but w/ stripped log
*   
**********************************************************************
d11 1
a11 1
	SECTION		rawinput
d13 1
a13 1
*------ Included Files -----------------------------------------------
d15 2
a16 1
	INCLUDE		"cddata.i"
a17 2
	INCLUDE		"graphics/text.i"
	INCLUDE		"intuition/intuition.i"
d19 1
d21 2
a22 1
*------ Imported Names -----------------------------------------------
d24 2
a26 1
*------ Imported Functions -------------------------------------------
d28 3
d47 5
a51 5
	XREF		SizeBuff
	XREF		PutBBuff
	XREF		PutWBuff
	XREF		GetBBuff
	XREF		GetWBuff
d53 2
a54 2
	XREF		EndCommand
	XREF		WriteReset
d56 26
a81 26
	XREF		LockDRPort
	XREF		UnLockRPort
	XREF		CursDisable
	XREF		CursEnable
	XREF		CursOn
	XREF		CursOff
	XREF		CursUpdate
	XREF		CursDown
	XREF		CursLeft
	XREF		CursRight
	XREF		CursUp
	XREF		ScrollYDisplay
	XREF		InsDelChar
	XREF		InsDelLine
	XREF		ClearEOL
	XREF		ClearEOD
	XREF		ClearDisplay
	XREF		Tab
	XREF		BackTab
	XREF		SetTab
	XREF		ClearTab
	XREF		ClearTabs
	XREF		ReSizeUnit
	XREF		RefreshUnit
	XREF		RefreshWindow
	XREF		SelectAbort
d83 1
a83 1
	XREF		CDRead
d86 1
a86 1
*------ Exported Functions -------------------------------------------
d88 3
a90 2
	XDEF		CDCBWrite
	XDEF		CDWrite
a91 1
	XDEF		G0Handler
a92 3
	XDEF		sgrPrimary


d640 1
a640 1
*	    ;-- find the number of contiguous vanilla characters
d650 1
a650 1
*	    ;-- get number of vanilla characters
d657 1
a657 1
*	    ;-- get the amount of text outputable on the current line
d671 1
a671 1
*	    ;-- set up address registers and output Text
d674 1
a674 1
*		;-- ensure the text CP is correct
d692 72
d772 1
a772 4
	IFNE	RP_INVERSVID-4
	FAIL	"RP_INVERSVID not bit 2, recode"
	ENDC
		btst.b	#2,cu_DrawMode(a2)
d783 1
a783 1
		beq.s	findBuffer
d785 1
d787 1
a787 34

		;--	find buffer origin
findBuffer:
		move.w	cu_YCP(a2),d0		; y line
		lsl.w	#2,d0			; y line start pointer offset

		move.w	cu_XCP(a2),d1		; x offset

		;--	    get current position
		move.l	cu_CM+cm_CharDispLines(a2),a0
		move.l	cu_CM+cm_AttrDispLines(a2),a1
		move.l	0(a0,d0.w),a0
		move.l	0(a1,d0.w),a1
		add.w	d1,a0
		add.w	d1,a1
		add.w	a1,a1


		;--	ensure left neighbor
		subq.w	#1,d1
		blt.s	fillBuffersDBF		; no need to fill left from BOL
		tst.b	-2(a1)
		bmi.s	fillBuffersDBF		; left neighbor exists

		movem.l	a0-a1,-(a7)
fillLeftLoop:
		move.b	#' ',-(a0)
		move.w	#CMAF_RENDERED,-(a1)
		tst.b	-2(a1)
		dbmi	d1,fillLeftLoop
		movem.l	(a7)+,a0-a1

		bra.s	fillBuffersDBF
fillBuffersLoop:
d790 2
a791 2
fillBuffersDBF:
		dbf	d3,fillBuffersLoop
d794 13
d808 1
a808 1
*	    ;-- update the count
d814 12
a825 1
*	    ;-- move cursor right
d829 1
a829 1
*	    ;-- check if more characters
a833 10
	    ;-- update cu_Display.L
		move.l	cu_XCP(a2),d1
		cmp.w	cu_DisplayYL(a2),d1
		blt.s	g0CursEnable
		bgt.s	g0UpdateDisplayL
		cmp.l	cu_DisplayXL(a2),d1
		blt.s	g0CursEnable
g0UpdateDisplayL:
		move.l	d1,cu_DisplayXL(a2)

d967 1
a967 1
*		;-- ensure the text CP is correct
d1007 1
a1007 1
*	;-- that was linefeed, now fall thru to CR
@


36.14
log
@document io_Data bumping
@
text
@d1 1
a1 1
	TTL	'$Header: write.asm,v 36.13 89/11/04 16:06:10 kodiak Exp $'
d13 3
d335 1
a335 1
		tst.w	cu_CM+cm_Elements(a2)
d380 1
a380 1
		tst.w	cu_CM+cm_Elements(a2)
d746 1
a746 1
		tst.w	cu_CM+cm_Elements(a2)	; check if buffered
d748 1
d750 2
a751 5
		move.w	cu_YCP(a2),d0		; find buffer origin
		mulu	cu_CM+cm_DisplayWidth(a2),d0
		move.w	cu_XCP(a2),d1
		ext.l	d1
		add.l	d1,d0
d773 1
a773 1
		beq.s	ensureLeftNeighbor
d776 21
a796 8
ensureLeftNeighbor:
		move.l	cu_CM+cm_CharDisplay(a2),a0
		move.l	cu_CM+cm_AttrDisplay(a2),a1
		add.l	d0,a0
		add.l	d0,d0
		add.l	d0,a1
		tst.w	d1
		beq.s	fillBuffersDBF		; no need to fill left from BOL
d799 2
a800 1
		bra.s	fillLeftDB
a804 1
fillLeftDB:
d806 1
a807 6
startBufferFill:
		move.l	cu_CM+cm_CharDisplay(a2),a0
		move.l	cu_CM+cm_AttrDisplay(a2),a1
		add.l	d0,a0
		add.l	d0,d0
		add.l	d0,a1
d818 1
a818 1
updateWriteCount
@


36.13
log
@restructure map variables
use XLVO macro strategy
update Display.L variables
@
text
@d1 1
a1 1
	TTL	'$Header: write.asm,v 36.12 89/09/15 15:39:17 kodiak Exp $'
d13 5
d160 1
a160 1
*   IO REQUEST
d170 6
@


36.12
log
@implement SGR 2x codes
@
text
@d1 1
a1 1
	TTL	'$Header: write.asm,v 36.11 89/09/11 16:47:54 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 3
d26 1
a26 1
*   keep CUA,IMPLICITNL current in attribute array
d79 3
a81 3
	XREF_EXE	Forbid
	XREF_EXE	Permit
	XREF_EXE	RawDoFmt
d83 5
a87 5
	XREF_GFX	Text
	XREF_GFX	SetAPen
	XREF_GFX	SetBPen
	XREF_GFX	SetDrMd
	XREF_GFX	SetSoftStyle
d89 3
a91 3
	XREF_LAY	BeginUpdate
	XREF_LAY	EndUpdate
	XREF_LAY	InstallClipRegion
d93 1
a93 1
	XREF_INT	DisplayBeep
d321 1
a321 1
		tst.w	cu_BufferSize(a2)
d366 1
a366 1
		tst.w	cu_BufferSize(a2)
d732 1
a732 1
		tst.w	cu_BufferSize(a2)	; check if buffered
d736 1
a736 1
		mulu	cu_BufferWidth(a2),d0
d742 1
a742 1
		lsl.b	#CUAS_SOFTSTYLE-CUAS_BGPEN,d2
d744 1
a744 1
		lsl.w	#CUAS_BGPEN,d2
d752 1
a752 1
		bset	#CUAB_INVERSVID,d2
d757 1
a757 1
		bset	#CUAB_IMPLICITNL,d2
d762 1
a762 1
		bset	#CUAB_RENDERED,d2
d765 2
a766 2
		move.l	cu_CharBuffer(a2),a0
		move.l	cu_AttrBuffer(a2),a1
d777 1
a777 1
		move.w	#CUAF_RENDERED,-(a1)
d783 2
a784 2
		move.l	cu_CharBuffer(a2),a0
		move.l	cu_AttrBuffer(a2),a1
d796 1
d812 11
@


36.11
log
@*** empty log message ***
@
text
@d1 1
a1 1
	TTL	'$Header: write.asm,v 36.10 89/09/11 13:00:18 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker: kodiak $
d13 3
a97 2
	XREF		rawPutBBuff

d439 1
a439 1
		RTS
d535 1
a535 1
		RTS
d595 1
a595 1
		RTS
d627 1
a627 1
		RTS
d660 1
a660 1
		RTS
d809 1
a809 1
		RTS
d827 1
a827 1
		RTS
d1160 1
a1160 1
		RTS
d1188 1
a1188 1
		RTS
d1347 1
a1347 1
		RTS
d1473 1
a1473 1
		RTS
d1476 1
a1476 1
		RTS
d1515 1
a1515 1
		dc.w	sgrFaint-sgrTable	; SECONDARY COLOR
d1522 2
a1523 1
		dc.w	sgrRRts-sgrTable	; reserved
d1526 7
a1532 7
		dc.w	sgrRRts-sgrTable	; ...
		dc.w	sgrRRts-sgrTable	;
		dc.w	sgrRRts-sgrTable	;
		dc.w	sgrRRts-sgrTable	;
		dc.w	sgrRRts-sgrTable	;
		dc.w	sgrRRts-sgrTable	;
		dc.w	sgrRRts-sgrTable	;
d1534 1
d1536 10
a1545 9
		dc.w	sgrRRts-sgrTable	;
		dc.w	sgrRRts-sgrTable	;
		dc.w	sgrRRts-sgrTable	;
		dc.w	sgrRRts-sgrTable	;
		dc.w	sgrRRts-sgrTable	;
		dc.w	sgrRRts-sgrTable	;
		dc.w	sgrRRts-sgrTable	;
		dc.w	sgrRRts-sgrTable	;
		dc.w	sgrRRts-sgrTable	;
d1556 1
d1568 1
a1568 1
		RTS
a1575 1
		lea	cd_RastPort(a6),a1
d1577 1
a1577 3
		move.b	d0,rp_Mask(a1)
		move.b	d0,cu_Mask(a2)
		lea	cd_RastPort(a6),a1
d1579 1
a1579 3
		LINKGFX	SetDrMd
		move.b	cd_RastPort+rp_DrawMode(a6),cu_DrawMode(a2)
		lea	cd_RastPort(a6),a1
d1585 1
a1585 1
		RTS
a1591 1
		lea	cd_RastPort(a6),a1
d1593 1
a1596 10
* -   -	SGR FAINT	-   -   -   -   -   -   -   -   -   -   -   -
*
*	SECONDARY COLOR
*
sgrFaint:
		lea	cd_RastPort(a6),a1
		moveq	#2,d0
		LINKGFX	SetAPen
		RTS

a1601 1
		lea	cd_RastPort(a6),a1
d1603 1
d1606 1
d1609 1
a1609 1
		RTS
a1615 1
		lea	cd_RastPort(a6),a1
d1617 1
d1626 2
a1628 1
		moveq	#RP_JAM2+RP_INVERSVID,d0
d1633 1
a1633 1
		RTS
d1640 3
d1644 4
a1647 3
		clr.b	rp_Mask(a1)
		clr.b	cu_Mask(a2)
		RTS
d1649 41
d1702 1
d1725 1
a1725 1
		RTS
d1761 1
a1761 1
		RTS
d1798 8
@


36.10
log
@ensure no holes in rendering between character and left edge
@
text
@d1 1
a1 1
	TTL	'$Header: write.asm,v 36.9 89/08/30 10:51:22 kodiak Exp $'
d13 3
d729 1
a729 1
		beq.s	updateWriteCount
@


36.9
log
@updated autodoc again
@
text
@d1 1
a1 1
	TTL	'$Header: write.asm,v 36.8 89/08/21 12:54:04 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 3
d246 1
a246 1
*	~   1	aSKR spECIAL KEY REPORT (private Amiga Read sequence)
d723 1
d754 1
a754 1
		beq.s	startBufferFill
d756 18
@


36.8
log
@keep CUA,IMPLICITNL current in attribute array
@
text
@d1 1
a1 1
	TTL	'$Header: write.asm,v 36.7 89/07/10 18:19:45 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker: kodiak $
d13 3
d134 1
a134 1
******* console.device/command/Write *******************************************
d136 2
a137 2
*    NAME
*	Write - write text to the display
d139 5
a143 4
*    FUNCTION
*	Write a text record to the display.  Note that the RPort of
*	the console window is in use while this write command is
*	pending.
d145 1
a145 1
*    IO REQUEST
d151 3
a153 3
*	io_Length	sizeof(*buffer), or -1 if null terminated
*	io_Data		char buffer[]
*			a pointer to a buffer containing the ANSI text
d156 1
a156 1
*    ANSI CODES SUPPORTED
d158 15
d176 1
a176 1
*	00/ 7	BEL	BELL (actually a DisplayBeep)
d183 4
a186 2
*	00/14	SO	SHIFT OUT
*	00/15	SI	SHIFT IN
d191 2
a192 2
*	08/ 4	D   IND	 INDEX: move the active position down one line
*	08/ 5	E   NEL	 NEXT LINE:
d194 1
a194 1
*	08/13	M   RI	 REVERSE INDEX:
d200 1
a200 1
*	c     RIS  RESET TO INITIAL STATE
d232 2
a233 2
*	h   n	SM   SET MODE
*	l   n	RM   RESET MODE
@


36.7
log
@recode use of attribute fields in attribute buffer
@
text
@d1 1
a1 1
	TTL	'$Header: write.asm,v 36.6 89/07/07 13:28:54 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 3
d719 5
d725 2
a726 1
		bset	#CUAB_INVERSVID,d2
@


36.6
log
@use SCROLL flag, not LAYERREFRESH flag to trigger Update
fix uninstallcliprect call to have layer in a0 always
@
text
@d1 1
a1 1
	TTL	'$Header: write.asm,v 36.5 89/07/05 15:23:21 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker: kodiak $
d13 4
d219 1
a219 1
*	~   1	aSKR SPECIAL KEY REPORT (private Amiga Read sequence)
d244 4
a247 4
		MOVEM.L D2-D6/A2-A4,-(A7)
		MOVE.L	A1,A3		    ; save I/O Request
		MOVE.L	IO_UNIT(A3),A2
		CLR.L	IO_ACTUAL(A3)
d249 1
a249 1
		BSR	LockDRPort
d259 3
a261 3
		BCLR	#CUB_RESIZE,cu_Flags(A2)
		BEQ.S	wCheckTooSmall
		BSR	ReSizeUnit
d265 1
a265 1
		BTST	#CUB_TOOSMALL,cu_Flags(a2)
d269 3
a271 3
		BCLR	#CUB_REFRESH,cu_Flags(A2)
		BEQ.S	wCheckSelecting
		BSR	RefreshWindow
d275 3
a277 3
		BCLR	#CUB_SELECTING,cu_Flags(A2)
		BEQ.S	wInstallClipReg
		BSR	SelectAbort
d296 8
a303 8
		MOVE.L	cu_Mask(A2),cd_RastPort+rp_Mask(A6)
		MOVE.b	cu_DrawMode(A2),cd_RastPort+rp_DrawMode(A6)
		MOVE.L	cu_Minterms(A2),cd_RastPort+rp_minterms(A6)
		MOVE.L	cu_Minterms+4(A2),cd_RastPort+rp_minterms+4(A6)
		MOVE.L	cu_Font(A2),cd_RastPort+rp_Font(A6)
		MOVE.W	cu_AlgoStyle(A2),cd_RastPort+rp_AlgoStyle(A6)
		MOVE.L	cu_TxHeight(A2),cd_RastPort+rp_TxHeight(A6)
		MOVE.L	cu_TxBaseline(A2),cd_RastPort+rp_TxBaseline(A6)
d305 4
a308 4
		MOVE.L	IO_LENGTH(A3),D0
		BEQ.S	done
		CMPI.L	#-1,D0
		BNE.S	loop
d310 2
a311 2
		MOVEQ	#-1,D0
		MOVE.L	IO_DATA(A3),A0
d313 5
a317 5
		TST.B	(A0)+
		DBEQ	D0,getNum
		NOT.L	D0		; null character is not in string
		MOVE.L	D0,IO_LENGTH(A3)
		BEQ.S	done
d320 5
a324 5
		MOVE.L	IO_DATA(A3),A0
		CLR.W	D0
		MOVE.B	(A0),D0
		MOVE.W	cu_PState(A2),D1
		LSL	#2,D1
d326 1
a326 1
		move.l	0(A1,d1.w),a1
d328 2
a329 2
		TST.L	IO_LENGTH(A3)
		BNE.S	loop
d368 1
a368 1
		BSR	UnLockRPort
d372 5
a376 5
		TSTBUFFER cu_ReadBuffer(A2)
		BEQ.S	readPermit
		MOVE.L	MP_MSGLIST(A2),A1
		TST.L	(A1)
		BEQ.S	readPermit
d378 1
a378 1
		BSR	CDRead
d383 2
a384 2
		MOVE.L	A3,A1
		MOVEM.L (A7)+,D2-D6/A2-A4
d386 1
a386 1
		BRA	EndCommand
d392 5
a396 5
		DC.L	vanillaP    ;normal character
		DC.L	escP	    ;escape pending
		DC.L	escIP	    ;intermediate escape pending
		DC.L	csiPP	    ;CSI parameters pending
		DC.L	csiIP	    ;CSI intermediate pending
d405 3
a407 3
		ADDQ.L	#1,IO_DATA(A3)
		ADDQ.L	#1,IO_ACTUAL(A3)
		SUBQ.L	#1,IO_LENGTH(A3)
d416 7
a422 7
		MOVE.W	D0,D1
		BTST	#7,D0	    ;check if in C0-GL or C1-GR
		BNE.S	c1GR
		ANDI.W	#$0060,D1   ;check if control
		BEQ.S	c0Ctrl	    ;  go perform C0 control
		MOVE.L	cu_GLHandler(A2),A1
		JMP	(A1)	    ;go perform GL code
d425 1
a425 1
		BRA	C0Handler   ;go perform C0 code
d428 3
a430 3
		ANDI.W	#$0060,D1   ;check if control
		BEQ.S	c1Ctrl	    ;  go perform C1 control
		BRA	G1Handler   ;go perform GR code
d433 1
a433 1
		BRA	C1Handler   ;go perform C1 code
d440 6
a445 6
		BTST	#7,D0	;check for 8-bit characters (an error)
		BNE.S	escErr
		BTST	#6,D0	;check for Fe, Fs groups
		BNE.S	escFeOrFs
		BTST	#5,D0	;check for control codes (an error)
		BNE.S	escIOrFp
d449 2
a450 2
		CLR.W	cu_PState(A2)
		BRA.S	vanillaP    ;invoke VanillaP "recursively"
d452 2
a453 2
escIOrFp    BTST    #4,D0   ;check for I group
		BNE.S	escFp
d456 4
a459 4
		LEA	cu_PICBuffer(A2),A0
		BSR	PutBBuff
		MOVE.W	#cu_PSESCI,cu_PState(A2)    ;update the parse state
		BRA	nextChar
d465 3
a467 3
		BCLR	#6,D0
		BCLR	#5,D0	;check for C1 control sequence
		BNE.S	escFs
d470 2
a471 2
		CLR.W	cu_PState(A2)
		BRA	C1Handler
d475 1
a475 1
		BRA	E2FsHandler
d483 3
a485 3
		MOVE.L	IO_DATA(A3),A0
		CLR.W	D0
		MOVE.B	(A0),D0
d487 8
a494 8
		BTST	#7,D0	;check for 8-bit characters (an error)
		BNE	escErr
		BTST	#6,D0	;check for Ft group
		BNE.S	escIFt
		BTST	#5,D0	;check for control codes (an error)
		BEQ	escErr
		BTST	#4,D0	;check for I group
		BNE	escIFp
d497 2
a498 2
		LEA	cu_PICBuffer(A2),A0
		BSR	PutBBuff
d500 4
a503 4
		ADDQ.L	#1,IO_DATA(A3)
		ADDQ.L	#1,IO_ACTUAL(A3)
		SUBQ.L	#1,IO_LENGTH(A3)
		BNE.S	escIPContd
d508 2
a509 2
		BSR	E3FpHandler ;(there are initially none)
		BRA	clearPS
d513 2
a514 2
		BSR	E3FtHandler ;(there are initially none)
		BRA	clearPS
d521 3
a523 3
		MOVE.L	IO_DATA(A3),A0
		CLR.W	D0
		MOVE.B	(A0),D0
d525 8
a532 8
		BTST	#7,D0	;check for 8-bit characters (an error)
		BNE	escErr
		BCLR	#6,D0	;check F group
		BNE	csiF
		BTST	#5,D0	;check for control codes (an error)
		BEQ	escErr
		BTST	#4,D0	;check for P parameters
		BNE.S	csiP
d535 5
a539 5
		FLUSHBUFFER	cu_PICBuffer(A2)	; leaves D0 alone
		LEA	cu_PICBuffer(A2),A0
		BSR	PutBBuff
		MOVE.W	#cu_PSCSII,cu_PState(A2)    ;update the parse state
		BRA	nextChar
d543 8
a550 8
		LEALASTIN	cu_PNPBuffer(A2),A0
		CMPI.B	#'9',D0
		BGT.S	csiPDelimit
		MOVE.W	D0,D2
		MOVE.W	(A0),D0
		CMPI.W	#-5,D0
		BNE.S	csiPMore
		MOVEQ	#0,D0
d552 4
a555 4
		AND.W	#$0F,D2
		MULS	#10,D0
		BMI.S	csiPPrivMul
		ADD.W	D2,D0
d557 1
a557 1
		MOVE.W	D0,(A0)
d560 4
a563 4
		ADDQ.L	#1,IO_DATA(A3)
		ADDQ.L	#1,IO_ACTUAL(A3)
		SUBQ.L	#1,IO_LENGTH(A3)
		BNE	csiPPContd
d567 2
a568 2
		SUB.W	D2,D0
		BRA.S	updatePWord
d571 6
a576 6
		SUB.W	#';',D0
		BNE.S	csiPPrivate
		MOVEQ	#-5,D0
		LEA	cu_PNPBuffer(A2),A0
		BSR	PutWBuff
		BRA.S	csiPNext
d579 3
a581 3
		BMI.S	csiPNext
		NEG.W	D0		; initialize parameter for private
		BRA.S	updatePWord	;   use -- the collection ranges are:
d590 3
a592 3
		CMPI.B	#$2F,D0
		BHI.S	csiFp
		BSR	CSIHandler
d595 1
a595 1
		CLR.W	cu_PState(A2)
d599 2
a600 2
		BSR	CSIpHandler
		BRA.S	clearPS
d608 3
a610 3
		MOVE.L	IO_DATA(A3),A0
		CLR.W	D0
		MOVE.B	(A0),D0
d612 8
a619 8
		BTST	#7,D0	;check for 8-bit characters (an error)
		BNE	escErr
		BCLR	#6,D0	;check F group
		BNE.S	csiIF
		BTST	#5,D0	;check for control codes (an error)
		BEQ	escErr
		BTST	#4,D0	;check for P parameters
		BNE	escErr
d622 2
a623 2
		LEA	cu_PICBuffer(A2),A0
		BSR	PutBBuff
d625 4
a628 4
		ADDQ.L	#1,IO_DATA(A3)
		ADDQ.L	#1,IO_ACTUAL(A3)
		SUBQ.L	#1,IO_LENGTH(A3)
		BNE.S	csiIPContd
d633 4
a636 4
		CMPI.B	#$2F,D0
		BHI.S	csiIFp
		BSR	CSIIHandler
		BRA.S	clearPS
d639 2
a640 2
		BSR	CSIIpHandler
		BRA.S	clearPS
d650 1
a650 1
		MOVE.L	A0,A4		;save string start
d652 1
a652 1
		MOVE.L	IO_LENGTH(A3),D1
d654 5
a658 5
		MOVE.B	(A0)+,D0
		AND.B	#$60,D0		; check if control
		BEQ.S	gHandler	;
		SUBQ.L	#1,D1
		BNE.S	g0Loop		; there are possibly more controls
d662 2
a663 2
		MOVE.L	IO_LENGTH(A3),D2
		SUB.L	D1,D2		; get number of chars to output
d666 1
a666 1
		BSR	CursDisable
d670 8
a677 8
		MOVE.W	cu_XCP(A2),D1
		MOVEQ	#0,D3
		MOVE.W	cu_XMax(A2),D3
		SUB.W	D1,D3
		ADDQ.W	#1,D3
		CMP.W	D3,D2
		BGE.S	willWrap
		MOVE.W	D2,D3
d679 2
a680 2
		MOVEQ	#0,D0
		MOVE.W	D3,D0
d683 1
a683 1
		MOVE.L	A4,A0
d686 9
a694 9
		MOVE.W	cu_XCP(A2),D1
		MULU	cu_XRSize(A2),D1
		ADD.W	cu_XROrigin(A2),D1
		MOVE.W	D1,rp_cp_x(A1)
		MOVE.W	cu_YCP(A2),D1
		MULU	cu_YRSize(A2),D1
		ADD.W	cu_YROrigin(A2),D1
		ADD.W	cu_TxBaseline(A2),D1
		MOVE.W	D1,rp_cp_y(A1)
d705 6
a710 5
		move.b	cu_BgPen(a2),d1
		lsl.b	#4,d1
		move.b	cu_FgPen(a2),d2
		and.b	#$f,d2
		or.b	d2,d1
d712 7
a718 4
		move.b	cu_DrawMode(a2),d2
		and.b	#RP_INVERSVID,d2	; RP_INVERSVID == 4
		lsl.b	#2,d2			; move to bit 4
		or.b	cu_AlgoStyle(a2),d2
d721 1
a721 1
		bset	#7,d2
a723 2
		lsl.w	#8,d2
		or.b	d1,d2
d739 3
a741 3
		ADD.L	D3,IO_DATA(A3)
		ADD.L	D3,IO_ACTUAL(A3)
		SUB.L	D3,IO_LENGTH(A3)
d744 2
a745 2
		MOVE.W	D3,D0		;one blip per character
		BSR	CursRight
d748 3
a750 3
		ADD.W	D3,A4		;update string pointer
		SUB.W	D3,D2		;update vanilla count
		BHI	nextLine
d752 1
a752 1
		BSR	CursEnable
d763 8
a770 8
		MOVEQ	#1,D2		;output one character
		MOVE.B	(A0),D0
		OR.B	#$80,D0		; set the msb in the character
		MOVE.W	D0,-(A7)
		MOVE.L	A7,A4		;point to 8-bit-set character
		ADDQ	#1,A4		;
		BSR	g1Entry
		ADDQ.L	#2,A7
d778 3
a780 3
		ADD.B	D0,D0
		MOVE.W	c0Table(PC,D0.W),D0
		JMP	c0Table(PC,D0.W)
d783 32
a814 32
		DC.W	nil-c0Table ;NUL
		DC.W	nil-c0Table ;SOH
		DC.W	nil-c0Table ;STX
		DC.W	nil-c0Table ;ETX
		DC.W	nil-c0Table ;EOT
		DC.W	nil-c0Table ;ENQ
		DC.W	nil-c0Table ;ACK
		DC.W	c0BEL-c0Table ;Bell
		DC.W	c0BS-c0Table  ;BackSpace
		DC.W	c0HT-c0Table  ;Horizontal Tab
		DC.W	c0LF-c0Table  ;Line Feed
		DC.W	c0VT-c0Table  ;Vertical Tab
		DC.W	c0FF-c0Table  ;Form Feed
		DC.W	c0CR-c0Table  ;Carriage Return
		DC.W	c0SO-c0Table  ;Shift Out
		DC.W	c0SI-c0Table  ;Shift In
		DC.W	nil-c0Table ;DLE
		DC.W	nil-c0Table ;DC1
		DC.W	nil-c0Table ;DC2
		DC.W	nil-c0Table ;DC3
		DC.W	nil-c0Table ;DC4
		DC.W	nil-c0Table ;NAK
		DC.W	nil-c0Table ;SYN
		DC.W	nil-c0Table ;ETB
		DC.W	nil-c0Table ;CAN
		DC.W	nil-c0Table ;EOM
		DC.W	nil-c0Table ;SUB
		DC.W	c0ESC-c0Table ;Escape introducer
		DC.W	nil-c0Table ;File Seperator
		DC.W	nil-c0Table ;Group Seperator
		DC.W	nil-c0Table ;Record Seperator
		DC.W	nil-c0Table ;Unit Seperator
d821 4
a824 4
		TST.L	cd_IntuitionLib(A6)
		BEQ.S	noIntuition
		MOVE.L	cu_Window(A2),A0
		MOVE.L	wd_WScreen(A0),A0
d827 1
a827 1
		BRA	nextChar
d835 3
a837 3
		MOVEQ	#1,D0
		BSR	CursLeft
		BRA	nextChar
d844 2
a845 2
		BSR	Tab
		BRA	nextChar
d854 2
a855 2
		BTST	#(M_LNM&07),cu_Modes+(M_LNM/8)(A2)
		BNE.S	NEL
d857 6
a862 6
		BCLR	#CUB_IMPLICITNL,cu_Flags(A2)
		BNE	nextChar
		MOVEQ	#1,D0
		BSR	CursDown
		BSR	updateRPCP
		BRA	nextChar
d872 3
a874 3
		MOVEQ	#1,D0
		BSR	CursUp
		BRA	nextChar
d881 1
a881 1
		CLR.L	cu_XCP(A2)   ;set to upper left corner
d885 7
a891 7
		MOVE.W	cu_XROrigin(A2),D1
		MOVE.W	D1,rp_cp_x(A1)
		MOVE.W	cu_YROrigin(A2),D1
		ADD.W	cu_TxBaseline(A2),D1
		MOVE.W	D1,rp_cp_y(A1)
		BSR	ClearDisplay
		BSR	CursUpdate
d893 1
a893 1
		BRA	nextChar
d900 5
a904 5
		BSR	cu
		BCLR	#CUB_IMPLICITNL,cu_Flags(A2)
		BNE	nextChar
		BSR	CursUp
		BRA.S	c0CR
d911 2
a912 2
		BSR	cu
		BRA.S	nextLines
d919 1
a919 1
		MOVEQ	#1,D0
d921 3
a923 3
		BCLR	#CUB_IMPLICITNL,cu_Flags(A2)
		BNE	nextChar
		BSR	CursDown
d931 3
a933 3
		CLR.W	cu_XCP(A2)   ;set to rht margin
		BSR	CursUpdate
		BRA	nextChar
d941 2
a942 2
		MOVE.L	#G1Handler,cu_GLHandler(A2)
		BRA	nextChar
d949 2
a950 2
		MOVE.L	#G0Handler,cu_GLHandler(A2)
		BRA	nextChar
d957 3
a959 3
		MOVE.W	#cu_PSESC,cu_PState(A2)
		FLUSHBUFFER	cu_PICBuffer(A2)
		BRA	nextChar
d966 2
a967 2
		BSR	SetTab
		BRA	nextChar
d974 6
a979 6
		MOVE.W	#cu_PSCSI,cu_PState(A2)
		FLUSHBUFFER	cu_PNPBuffer(A2)
		MOVEQ	#-5,D0
		LEA	cu_PNPBuffer(A2),A0
		BSR	PutWBuff
		BRA	nextChar
d986 3
a988 3
		ADD.B	D0,D0	    ;also gets rid of msb
		MOVE.W	c1Table(PC,D0.W),D0
		JMP	c1Table(PC,D0.W)
d991 32
a1022 32
		DC.W	nil-c1Table ; future standard
		DC.W	nil-c1Table ; future standard
		DC.W	nil-c1Table ; future standard
		DC.W	nil-c1Table ; future standard
		DC.W	IND-c1Table ; INDEX: move the active position down one line
		DC.W	NEL-c1Table ; NEXT LINE:
		DC.W	nil-c1Table ; START OF SELECTED AREA:
		DC.W	nil-c1Table ; END OF SELECTED AREA:
		DC.W	HTS-c1Table ; HORIZONTAL TABULATION SET:
		DC.W	nil-c1Table ; HORIZONTAL TABULATION WITH JUSTIFICATION:
		DC.W	nil-c1Table ; VERTICAL TABULATION SET:
		DC.W	nil-c1Table ; PARTIAL LINE DOWN:
		DC.W	nil-c1Table ; PARTIAL LINE UP:
		DC.W	RI-c1Table  ; REVERSE INDEX:
		DC.W	nil-c1Table ; SINGLE SHIFT TWO:
		DC.W	nil-c1Table ; SINGLE SHIFT THREE:
		DC.W	nil-c1Table ; DEVICE CONTROL STRING:
		DC.W	nil-c1Table ; PRIVATE USE ONE:
		DC.W	nil-c1Table ; PRIVATE USE TWO:
		DC.W	nil-c1Table ; SET TRANSMIT STATE:
		DC.W	nil-c1Table ; CANCEL CHARACTER
		DC.W	nil-c1Table ; MESSAGE WAITING
		DC.W	nil-c1Table ; START OF PROTECTED AREA
		DC.W	nil-c1Table ; END OF PROTECTED AREA
		DC.W	nil-c1Table ; future standard
		DC.W	nil-c1Table ; future standard
		DC.W	nil-c1Table ; future standard
		DC.W	CSI-c1Table ; CONTROL SEQUENCE INTRODUCER: see next list
		DC.W	nil-c1Table ; STRING TERMINATOR
		DC.W	nil-c1Table ; OPERATING SYSTEM COMMAND
		DC.W	nil-c1Table ; PRIVACY MESSAGE
		DC.W	nil-c1Table ; APPLICATION PROGRAM COMMAND
d1029 2
a1030 2
		CMPI.B	#3,D0
		BEQ.S	resetFs	    ; RIS  RESET TO INITIAL STATE
d1033 2
a1034 2
		CLR.W	cu_PState(A2)
		BRA	nextChar
d1037 2
a1038 2
		BSR	WriteReset
		BRA.S	escEnd
d1046 3
a1048 3
		ADD.B	D0,D0	    ;also gets rid of msb
		MOVE.W	csiTable(PC,D0.W),D0
		JMP	csiTable(PC,D0.W)
d1051 48
a1098 48
		DC.W	ICH-csiTable	; INSERT CHARACTER
		DC.W	CUU-csiTable	; CURSOR UP
		DC.W	CUD-csiTable	; CURSOR DOWN
		DC.W	CUF-csiTable	; CURSOR FORWARD
		DC.W	CUB-csiTable	; CURSOR BACKWARD
		DC.W	CNL-csiTable	; CURSOR NEXT LINE
		DC.W	CPL-csiTable	; CURSOR PRECEEDING LINE
		DC.W	nil-csiTable	; CURSOR HORIZONTAL ABSOLUTE
		DC.W	CUP-csiTable	; CURSOR POSITION
		DC.W	CHT-csiTable	; CURSOR HORIZONTAL TABULATION
		DC.W	ED-csiTable	; ERASE IN DISPLAY
		DC.W	EL-csiTable	; ERASE IN LINE
		DC.W	IL-csiTable	; INSERT LINE
		DC.W	DL-csiTable	; DELETE LINE
		DC.W	nil-csiTable	; ERASE IN FIELD
		DC.W	nil-csiTable	; ERASE IN AREA
		DC.W	DCH-csiTable	; DELETE CHARACTER
		DC.W	nil-csiTable	; SELECT EDITING EXTENT MODE
		DC.W	nil-csiTable	; CURSOR POSITION REPORT
		DC.W	SU-csiTable	; SCROLL UP
		DC.W	SD-csiTable	; SCROLL DOWN
		DC.W	nil-csiTable	; NEXT PAGE
		DC.W	nil-csiTable	; PREVIOUS PAGE
		DC.W	CTC-csiTable	; CURSOR TABULATION CONTROL
		DC.W	nil-csiTable	; ERASE CHARACTER
		DC.W	nil-csiTable	; CURSOR VERTICAL TABULATION
		DC.W	CBT-csiTable	; CURSOR BACKWARD TABULATION
		DC.W	nil-csiTable	;
		DC.W	nil-csiTable	;
		DC.W	nil-csiTable	;
		DC.W	nil-csiTable	;
		DC.W	nil-csiTable	;
		DC.W	nil-csiTable	; HORIZONTAL POSITION ABSOLUTE
		DC.W	nil-csiTable	; HORIZONTAL POSITION RELATIVE
		DC.W	nil-csiTable	; REPEAT
		DC.W	nil-csiTable	; DEVICE ATTRIBUTES
		DC.W	nil-csiTable	; VERTICAL POSITION ABSOLUTE
		DC.W	nil-csiTable	; VERTICAL POSITION RELATIVE
		DC.W	HVP-csiTable	; HORIZONTAL AND VERTICAL POSITION
		DC.W	TBC-csiTable	; TABULATION CLEAR
		DC.W	SMo-csiTable	; SET MODE
		DC.W	nil-csiTable	; MEDIA COPY
		DC.W	nil-csiTable	;
		DC.W	nil-csiTable	;
		DC.W	RM-csiTable	; RESET MODE
		DC.W	SGR-csiTable	; SELECT GRAPHIC RENDITION
		DC.W	DSR-csiTable	; DEVICE STATUS REPORT
		DC.W	nil-csiTable	; DEFINE AREA QUALIFICATION
d1101 3
a1103 3
		LEA	cu_PNPBuffer(A2),A0
		BSR	GetWBuff
		TST.L	D0
d1111 3
a1113 3
		BSR.S	cu
		BSR	CursUp
		BRA	nextChar
d1120 3
a1122 3
		BSR.S	cu
		BSR	CursDown
		BRA	nextChar
d1125 4
a1128 4
		BSR.S	getPPWord
		BMI.S	cuDefault
		TST.W	D0
		BGT.S	cuSpecified
d1130 1
a1130 1
		MOVEQ	#1,D0		    ;default is 1
d1139 3
a1141 3
		BSR.S	cu
		BSR	CursRight
		BRA	nextChar
d1148 3
a1150 3
		BSR.S	cu
		BSR	CursLeft
		BRA	nextChar
d1160 4
a1163 4
		BSR.S	cu
		CMP.W	cu_YMax(A2),D0
		BGT.S	cupYMax
		SUBQ.W	#1,D0
d1165 1
a1165 1
		MOVE.W	D0,cu_YCP(A2)
d1167 4
a1170 4
		BSR.S	cu
		CMP.W	cu_XMax(A2),D0
		BGT.S	cupXMax
		SUBQ.W	#1,D0
d1172 3
a1174 3
		MOVE.W	D0,cu_XCP(A2)
		BSR	CursUpdate
		BRA	nextChar
d1177 2
a1178 2
		MOVE.W	cu_YMax(A2),D0
		BRA.S	cupYSet
d1181 2
a1182 2
		MOVE.W	cu_XMax(A2),D0
		BRA.S	cupXSet
d1189 2
a1190 2
		BSR	cu
		MOVE.W	D0,-(A7)
d1192 5
a1196 5
		BSR	Tab
		SUBQ.W	#1,(A7)
		BNE.S	chtLoop
		ADDQ.W	#2,A7
		BRA	nextChar
d1204 2
a1205 2
		BSR	cu
		NEG.W	D0
d1207 1
a1207 1
		BRA	nextChar
d1215 1
a1215 1
		BSR	cu
d1217 1
a1217 1
		BRA	nextChar
d1225 2
a1226 2
		BSR	cu
		NEG.W	D0
d1236 1
a1236 1
		BSR	cu
d1246 5
a1250 5
		BSR.S	updateRPCP
		BSR	CursDisable
		BSR	ClearEOL
		BSR	CursEnable
		BRA	nextChar
d1258 2
a1259 2
		BSR.S	updateRPCP
		BSR	CursDisable
d1265 1
a1265 1
		BSR	ClearDisplay
d1270 1
a1270 1
		BSR	ClearEOD
d1273 2
a1274 2
		BSR	CursEnable
		BRA	nextChar
d1282 9
a1290 9
		MOVE.W	cu_XCP(A2),D1
		MULU	cu_XRSize(A2),D1
		ADD.W	cu_XROrigin(A2),D1
		MOVE.W	D1,rp_cp_x(A1)
		MOVE.W	cu_YCP(A2),D1
		MULU	cu_YRSize(A2),D1
		ADD.W	cu_YROrigin(A2),D1
		ADD.W	cu_TxBaseline(A2),D1
		MOVE.W	D1,rp_cp_y(A1)
d1299 1
a1299 1
		BSR	cu
d1301 4
a1304 4
		BSR	CursDisable
		BSR	ScrollYDisplay
		BSR	CursEnable
		BRA	nextChar
d1311 2
a1312 2
		BSR	cu
		NEG.W	D0
d1314 4
a1317 4
		BSR	CursDisable
		BSR	ScrollYDisplay
		BSR	CursEnable
		BRA	nextChar
d1325 12
a1336 12
		BSR	getPPWord
		BMI	nextChar
		TST.W	D0
		BMI.S	ctcSetTab
		CMPI.W	#CTC_HSETTAB,D0
		BEQ.S	ctcSetTab
		CMPI.W	#CTC_HCLRTAB,D0
		BEQ.S	ctcClrTab
		CMPI.W	#4,D0
		BEQ.S	ctcClrTabs
		CMPI.W	#CTC_HCLRTABSALL,D0
		BNE.S	CTC
d1338 2
a1339 2
		BSR	ClearTabs
		BRA.S	CTC
d1341 2
a1342 2
		BSR	ClearTab
		BRA.S	CTC
d1344 2
a1345 2
		BSR	SetTab
		BRA.S	CTC
d1353 2
a1354 2
		BSR	cu
		MOVE.W	D0,-(A7)
d1356 5
a1360 5
		BSR	BackTab
		SUBQ.W	#1,(A7)
		BNE.S	cbtLoop
		ADDQ.W	#2,A7
		BRA	nextChar
d1368 8
a1375 8
		BSR	getPPWord
		BMI	nextChar
		TST.W	D0
		BMI.S	tbcClrTab
		CMPI.W	#TBC_HCLRTAB,D0
		BEQ.S	tbcClrTab
		CMPI.W	#TBC_HCLRTABSALL,D0
		BNE.S	TBC
d1377 2
a1378 2
		BSR	ClearTabs
		BRA.S	TBC
d1380 2
a1381 2
		BSR	ClearTab
		BRA.S	TBC
d1389 6
a1394 6
		BSR	getPPWord
		BMI	nextChar
		BSR.S	checkM
		BMI.S	SMo
		BSET	D1,0(A0,D0.W)
		BRA.S	SMo
d1398 6
a1403 6
		TST.W	D0
		BPL.S	stdM
		CMP.W	#PM_ASM,D0
		BNE.S	checkAWM
		MOVEQ	#PMB_ASM,D0
		BRA.S	validM
d1405 4
a1408 4
		CMP.W	#PM_AWM,D0
		BNE.S	unknownM
		MOVEQ	#PMB_AWM,D0
		BRA.S	validM
d1410 2
a1411 2
		CMP.W	#M_LNM,D0
		BGT.S	unknownM
d1413 4
a1416 4
		MOVE.W	D0,D1
		LSR.W	#3,D0
		ANDI.W	#7,D1
		LEA	cu_Modes(A2),A0
d1419 1
a1419 1
		MOVEQ	#-1,D0
d1427 6
a1432 6
		BSR	getPPWord
		BMI	nextChar
		BSR.S	checkM
		BMI.S	RM
		BCLR	D1,0(A0,D0.W)
		BRA.S	RM
d1440 5
a1444 5
		BSR	getPPWord
		BMI	nextChar
		TST.W	D0
		BPL.S	sgrSpecified
		MOVEQ	#0,D0		; default is zero
d1447 2
a1448 2
		CMPI.W	#SGR_DEFAULTBG,D0
		BGT.S	SGR
d1450 4
a1453 4
		ADD.B	D0,D0
		MOVE.W	sgrTable(PC,D0.W),D0
		JSR	sgrTable(PC,D0.W)
		BRA.S	SGR
d1457 50
a1506 50
		DC.W	sgrPrimary-sgrTable	; PRIMARY RENDITION
		DC.W	sgrBold-sgrTable	; BOLD
		DC.W	sgrFaint-sgrTable	; SECONDARY COLOR
		DC.W	sgrItalic-sgrTable	; ITALIC
		DC.W	sgrUnderscore-sgrTable	; UNDERSCORE
		DC.W	sgrRRts-sgrTable	; SLOW BLINK
		DC.W	sgrRRts-sgrTable	; FAST BLINK
		DC.W	sgrReverse-sgrTable	; NEGATIVE (REVERSE) IMAGE
		DC.W	sgrConcealed-sgrTable	; CONCEALED
		DC.W	sgrRRts-sgrTable	; reserved
		DC.W	sgrRRts-sgrTable	; PRIMARY FONT
		DC.W	sgrRRts-sgrTable	; FIRST ALTERNATE FONT
		DC.W	sgrRRts-sgrTable	; ...
		DC.W	sgrRRts-sgrTable	;
		DC.W	sgrRRts-sgrTable	;
		DC.W	sgrRRts-sgrTable	;
		DC.W	sgrRRts-sgrTable	;
		DC.W	sgrRRts-sgrTable	;
		DC.W	sgrRRts-sgrTable	;
		DC.W	sgrRRts-sgrTable	; NINTH ALTERNATE FONT
		DC.W	sgrRRts-sgrTable	; FRAKTUR
		DC.W	sgrRRts-sgrTable	;
		DC.W	sgrRRts-sgrTable	;
		DC.W	sgrRRts-sgrTable	;
		DC.W	sgrRRts-sgrTable	;
		DC.W	sgrRRts-sgrTable	;
		DC.W	sgrRRts-sgrTable	;
		DC.W	sgrRRts-sgrTable	;
		DC.W	sgrRRts-sgrTable	;
		DC.W	sgrRRts-sgrTable	;
		DC.W	sgrFgColor0-sgrTable	; BLACK DISPLAY
		DC.W	sgrFgColor1-sgrTable	; RED DISPLAY
		DC.W	sgrFgColor2-sgrTable	; GREEN DISPLAY
		DC.W	sgrFgColor3-sgrTable	; YELLOW DISPLAY
		DC.W	sgrFgColor4-sgrTable	; BLUE DISPLAY
		DC.W	sgrFgColor5-sgrTable	; MAGENTA DISPLAY
		DC.W	sgrFgColor6-sgrTable	; CYAN DISPLAY
		DC.W	sgrFgColor7-sgrTable	; WHITE DISPLAY
		DC.W	sgrRRts-sgrTable	; reserved
		DC.W	sgrFgDefault-sgrTable	; DEFAULT DISPLAY
		DC.W	sgrBgColor0-sgrTable	; BLACK BACKGROUND
		DC.W	sgrBgColor1-sgrTable	; RED BACKGROUND
		DC.W	sgrBgColor2-sgrTable	; GREEN BACKGROUND
		DC.W	sgrBgColor3-sgrTable	; YELLOW BACKGROUND
		DC.W	sgrBgColor4-sgrTable	; BLUE BACKGROUND
		DC.W	sgrBgColor5-sgrTable	; MAGENTA BACKGROUND
		DC.W	sgrBgColor6-sgrTable	; CYAN BACKGROUND
		DC.W	sgrBgColor7-sgrTable	; WHITE BACKGROUND
		DC.W	sgrRRts-sgrTable	; reserved
		DC.W	sgrBgDefault-sgrTable	; DEFAULT BACKGROUND
d1517 3
a1519 3
		MOVEQ	#-1,D0			; $0FF
		MOVE.B	D0,rp_Mask(A1)
		MOVE.B	D0,cu_Mask(A2)
d1521 1
a1521 1
		MOVEQ	#RP_JAM2,D0
d1525 2
a1526 2
		MOVEQ	#0,D0
		MOVEQ	#FSF_BOLD+FSF_ITALIC+FSF_UNDERLINED,D1
d1528 2
a1529 2
		BSR	sgrFgDefault
		BSR	sgrBgDefault
d1538 2
a1539 2
		MOVEQ	#FSF_BOLD,D0
		MOVEQ	#FSF_BOLD,D1
d1548 1
a1548 1
		MOVEQ	#2,D0
d1558 2
a1559 2
		MOVEQ	#FSF_ITALIC,D0
		MOVEQ	#FSF_ITALIC,D1
d1571 2
a1572 2
		MOVEQ	#FSF_UNDERLINED,D0
		MOVEQ	#FSF_UNDERLINED,D1
d1581 1
a1581 1
		MOVEQ	#RP_JAM2+RP_INVERSVID,D0
d1594 1
a1594 1
		CLR.B	rp_Mask(A1)
d1603 2
a1604 2
		MOVEQ	#0,D0
		BRA.S	sgrFgColor
d1607 2
a1608 2
		MOVEQ	#1,D0
		BRA.S	sgrFgColor
d1610 2
a1611 2
		MOVEQ	#2,D0
		BRA.S	sgrFgColor
d1613 2
a1614 2
		MOVEQ	#3,D0
		BRA.S	sgrFgColor
d1616 2
a1617 2
		MOVEQ	#4,D0
		BRA.S	sgrFgColor
d1619 2
a1620 2
		MOVEQ	#5,D0
		BRA.S	sgrFgColor
d1622 2
a1623 2
		MOVEQ	#6,D0
		BRA.S	sgrFgColor
d1625 1
a1625 1
		MOVEQ	#7,D0
d1627 1
a1629 1
		move.b	cd_RastPort+rp_FgPen(a6),cu_FgPen(a2)
d1640 2
a1641 2
		MOVEQ	#0,D0
		BRA.S	sgrBgColor
d1643 2
a1644 2
		MOVEQ	#1,D0
		BRA.S	sgrBgColor
d1646 2
a1647 2
		MOVEQ	#2,D0
		BRA.S	sgrBgColor
d1649 2
a1650 2
		MOVEQ	#3,D0
		BRA.S	sgrBgColor
d1652 2
a1653 2
		MOVEQ	#4,D0
		BRA.S	sgrBgColor
d1655 2
a1656 2
		MOVEQ	#5,D0
		BRA.S	sgrBgColor
d1658 2
a1659 2
		MOVEQ	#6,D0
		BRA.S	sgrBgColor
d1661 1
a1661 1
		MOVEQ	#7,D0
d1663 1
a1665 1
		move.b	cd_RastPort+rp_BgPen(a6),cu_BgPen(a2)
d1676 3
a1678 3
		BSR	getPPWord
		CMPI.L	#DSR_CPR,D0
		BNE	nextChar
d1681 12
a1692 12
		MOVEQ	#0,D0
		MOVE.W  cu_XCP(A2),D0
		ADDQ.W	#1,D0
		MOVE.L	D0,-(A7)
		MOVE.W  cu_YCP(A2),D0
		ADDQ.W	#1,D0
		MOVE.L	D0,-(A7)
		MOVE.L  A7,A1
		MOVEM.L	A2/A3,-(A7)
		LEA	dsrFormat(PC),A0
		LEA	cu_ReadBuffer(A2),A3
		LEA	rawPutBBuff(PC),A2
d1694 2
a1695 2
		MOVEM.L	(A7)+,A2/A3
		ADDQ.W	#8,A7
d1697 1
a1697 1
		BRA	nextChar
d1701 4
a1704 4
		DC.B	$9B
		DC.B	'%ld;%ldR'
		DC.B	0
		DS.W	0
d1712 4
a1715 4
		SUB.B	#$30,D0
		ADD.B	D0,D0	    ;also gets rid of msb
		MOVE.W	csipTable(PC,D0.W),D0
		JMP	csipTable(PC,D0.W)
d1718 16
a1733 16
		DC.W	nil-csipTable	;
		DC.W	nil-csipTable	;
		DC.W	nil-csipTable	;
		DC.W	nil-csipTable	;
		DC.W	aSLPP-csipTable	; Set Page Length
		DC.W	aSLL-csipTable	; Set Line Length
		DC.W	nil-csipTable	;
		DC.W	nil-csipTable	;
		DC.W	aSLO-csipTable	; Set Left Offset
		DC.W	aSTO-csipTable	; Set Top Offset
		DC.W	nil-csipTable	;
		DC.W	aSRE-csipTable	; Set Raw Events
		DC.W	nil-csipTable	; (report raw events: read only)
		DC.W	aRRE-csipTable	; Reset Raw Events
		DC.W	nil-csipTable	; (report function keys: read only)
		DC.W	nil-csipTable	; ERROR
d1741 8
a1748 8
		BSR	CursDisable
		BSR	getPPWord
		TST.W	D0
		BLE.S	offSPL
		BSET	#CUFB_FIXEDPL,cu_FixedFlags(A2)
		SUBQ.W	#1,D0
		MOVE.W	D0,cu_YMax(A2)
		BRA.S	setSize
d1750 2
a1751 2
		BCLR	#CUFB_FIXEDPL,cu_FixedFlags(A2)
		BRA.S	setSize
d1759 8
a1766 8
		BSR	CursDisable
		BSR	getPPWord
		TST.W	D0
		BLE.S	offSLL
		BSET	#CUFB_FIXEDLL,cu_FixedFlags(A2)
		SUBQ.W	#1,D0
		MOVE.W	D0,cu_XMax(A2)
		BRA.S	setSize
d1768 1
a1768 1
		BCLR	#CUFB_FIXEDLL,cu_FixedFlags(A2)
d1771 3
a1773 3
		BSR	ReSizeUnit
		BSR	CursEnable
		BRA	nextChar
d1781 7
a1787 7
		BSR	CursDisable
		BSR	getPPWord
		TST.W	D0
		BMI.S	offSLO
		BSET	#CUFB_FIXEDLO,cu_FixedFlags(A2)
		MOVE.W	D0,cu_XROrigin(A2)
		BRA.S	setSize
d1789 2
a1790 2
		BCLR	#CUFB_FIXEDLO,cu_FixedFlags(A2)
		BRA.S	setSize
d1798 7
a1804 7
		BSR	CursDisable
		BSR	getPPWord
		TST.W	D0
		BMI.S	offSTO
		BSET	#CUFB_FIXEDTO,cu_FixedFlags(A2)
		MOVE.W	D0,cu_YROrigin(A2)
		BRA.S	setSize
d1806 2
a1807 2
		BCLR	#CUFB_FIXEDTO,cu_FixedFlags(A2)
		BRA.S	setSize
d1815 12
a1826 12
		BSR	getPPWord
		BMI	nextChar
		TST.W	D0
		BMI.S	aSRE
		CMP.W	#IECLASS_MAX,D0
		BGT.S	aSRE
		MOVE.W	D0,D1
		LSR.W	#3,D0
		ANDI.W	#7,D1
		LEA	cu_RawEvents(A2),A0
		BSET	D1,0(A0,D0.W)
		BRA.S	aSRE
d1834 12
a1845 12
		BSR	getPPWord
		BMI	nextChar
		TST.W	D0
		BMI.S	aRRE
		CMP.W	#IECLASS_MAX,D0
		BGT.S	aRRE
		MOVE.W	D0,D1
		LSR.W	#3,D0
		ANDI.W	#7,D1
		LEA	cu_RawEvents(A2),A0
		BCLR	D1,0(A0,D0.W)
		BRA.S	aRRE
d1853 10
a1862 10
		MOVE.L	D0,-(A7)
		LEA	cu_PICBuffer(A2),A0
		BSR	GetBBuff
		CMPI.L	#' ',D0			; only handle ' '
		BNE	popD0NextChar
		LEA	cu_PICBuffer(A2),A0
		BSR	SizeBuff		; only one intermediate
		TST.L	D0
		BNE.S	popD0NextChar
		MOVE.L	(A7)+,D0
d1864 4
a1867 4
		SUB.B	#$30,D0
		ADD.B	D0,D0	    ;also gets rid of msb
		MOVE.W	csii20pTable(PC,D0.W),D0
		JMP	csii20pTable(PC,D0.W)
d1870 2
a1871 2
		ADDQ.L	#4,A7
		BRA	nextChar
d1874 16
a1889 16
		DC.W	aSCR-csii20pTable	; SET CURSOR RENDITION
		DC.W	aWSR-csii20pTable	; WINDOW STATUS REQUEST
		DC.W	nil-csii20pTable	; WINDOW BOUNDS REPORT
		DC.W	nil-csii20pTable	;
		DC.W	nil-csii20pTable	;
		DC.W	nil-csii20pTable	;
		DC.W	nil-csii20pTable	;
		DC.W	nil-csii20pTable	;
		DC.W	nil-csii20pTable	;
		DC.W	nil-csii20pTable	;
		DC.W	nil-csii20pTable	;
		DC.W	nil-csii20pTable	;
		DC.W	nil-csii20pTable	;
		DC.W	nil-csii20pTable	;
		DC.W	nil-csii20pTable	;
		DC.W	nil-csii20pTable	;
d1898 6
a1903 6
		BSR	CursDisable
		BSR	getPPWord
		TST.W	D0
		BNE.S	onSCR
		BSR	CursOff
		BRA.S	endSCR
d1905 1
a1905 1
		BSR	CursOn
d1907 2
a1908 2
		BSR	CursEnable
		BRA	nextChar
d1917 12
a1928 12
		MOVEQ	#0,D0
		MOVE.W  cu_XMax(A2),D0
		ADDQ.W	#1,D0
		MOVE.L	D0,-(A7)
		MOVE.W  cu_YMax(A2),D0
		ADDQ.W	#1,D0
		MOVE.L	D0,-(A7)
		MOVE.L  A7,A1
		MOVEM.L	A2/A3,-(A7)
		LEA	wsrFormat(PC),A0
		LEA	cu_ReadBuffer(A2),A3
		LEA	rawPutBBuff(PC),A2
d1930 2
a1931 2
		MOVEM.L	(A7)+,A2/A3
		ADDQ.W	#8,A7
d1933 1
a1933 1
		BRA	nextChar
d1937 4
a1940 4
		DC.B	$9B
		DC.B	'1;1;%ld;%ld r'
		DC.B	0
		DS.W	0
@


36.5
log
@move scrolling to scroll.asm
only refresh windows w/ character maps
@
text
@d1 1
a1 1
	TTL	'$Header: write.asm,v 36.4 89/06/28 19:14:36 kodiak Exp $'
d13 4
a65 1
	XREF_GFX	ScrollRaster
d247 2
d282 1
a282 1
		;-- preserve and clear LAYERREFRESH flag
a288 1
		and.w	#~LAYERREFRESH,lr_Flags(a0)
d331 2
d336 1
a336 1
		beq.s	restoreLayerRefresh
d338 1
a338 1
		;-- perform BeginUpdate/Refresh/EndUpdate(true)
d344 1
a350 1
restoreLayerRefresh:
d356 1
d359 1
@


36.4
log
@better avoidance of cursor spoor
@
text
@d1 1
a1 1
	TTL	'$Header: write.asm,v 36.3 89/06/28 13:38:17 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 3
a82 2
	XREF		CursClear
	XREF		CursRefresh
d92 3
a94 1
	XREF		ScrollYText
d247 1
a247 1
		beq.s	wSetAttrs
d267 1
a267 1
		BEQ.S	wSetAttrs
d270 1
a270 1
wSetAttrs:
d278 2
d286 1
d324 2
a332 2
		bsr	CursClear

a343 2
		bsr	CursRefresh

d351 1
d685 1
a685 1
		tst.l	cu_BufferSize(a2)	; check if buffered
a1189 1
		MOVEM.L	D2-D5,-(A7)
d1192 1
a1192 4
		BSR.S	idChar
		LINKGFX	ScrollRaster
		BSR	CursEnable
		MOVEM.L	(A7)+,D2-D5
a1194 19
idChar:
		MULS	cu_XRSize(A2),D0
		MOVEQ	#0,D1
		MOVE.W  cu_XCP(A2),D2
		MULU    cu_XRSize(A2),D2
		ADD.W   cu_XROrigin(A2),D2
		EXT.L	D2
		MOVE.W  cu_YCP(A2),D3
		MULU    cu_YRSize(A2),D3
		ADD.W   cu_YROrigin(A2),D3
		EXT.L	D3
		MOVE.W	cu_XRExtant(A2),D4
		EXT.L	D4
		MOVE.L	D3,D5
		ADD.W	cu_YRSize(A2),D5
		SUBQ.W	#1,D5
		BSR	CursDisable
		lea	cd_RastPort(a6),a1
		RTS
a1200 1
		MOVEM.L	D2-D5,-(A7)
d1202 1
a1202 4
		BSR.S	idChar
		LINKGFX	ScrollRaster
		BSR	CursEnable
		MOVEM.L	(A7)+,D2-D5
a1210 1
		MOVEM.L	D2-D5,-(A7)
a1211 45
		move.l	cu_BufferSize(a2),d4	; end of characters
		beq.s	ilSR
		;-- scroll buffer down
		move.l	cu_CharBuffer(a2),a0
		move.l	cu_AttrBuffer(a2),a1
		move.w	d0,d5
		move.w	cu_BufferWidth(a2),d3
		mulu	d3,d0			; gap width
		move.w	cu_YCP(a2),d1
		addq.w	#1,d1
		mulu	d3,d1			; start of gap
		move.l	d1,d2

		move.l	d4,d3
		sub.l	d0,d3			; new end of characters

		lea	0(a0,d4.l),a4
		add.l	d4,d4
		lea	0(a1,d4.l),a5

		sub.l	d3,d1
		neg.l	d1			; new character count
		bmi.s	ilsbClrAll

		add.l	d3,a0
		add.l	d3,d3
		add.l	d3,a1
		bra.s	ilsbCopyDBF
ilsbCopyLoop:
		move.b	-(a0),-(a4)
		move.w	-(a1),-(a5)
ilsbCopyDBF:
		dbf	d1,ilsbCopyLoop
		bra.s	ilsbClrDBF
ilsbClrAll:
		sub.l	d2,d4			; from gap to end
		move.w	d4,d0
		bra.s	ilsbClrDBF
ilsbClrLoop:
		clr.w	-(a5)
ilsbClrDBF:
		dbf	d0,ilsbClrLoop
		move.w	d5,d0

ilSR:
d1213 2
a1214 5
		BSR.S	idLine
		LINKGFX	ScrollRaster
		BSR	CursEnable
		MOVEM.L	(A7)+,D2-D5
		BRA	nextChar
a1215 17
idLine:
		MOVE.W	D0,D1
		MOVEQ	#0,D0
		MULS	cu_YRSize(A2),D1
		MOVE.W	cu_XROrigin(A2),D2
		EXT.L	D2
		MOVE.W  cu_YCP(A2),D3
		MULU    cu_YRSize(A2),D3
		ADD.W   cu_YROrigin(A2),D3
		EXT.L	D3
		MOVE.W	cu_XRExtant(A2),D4
		EXT.L	D4
		MOVE.W	cu_YRExtant(A2),D5
		EXT.L	D5
		BSR	CursDisable
		lea	cd_RastPort(a6),a1
		RTS
a1221 1
		MOVEM.L	D2-D5,-(A7)
d1223 2
a1224 12
		move.l	cu_BufferSize(a2),d4	; end of characters
		beq.s	dlSR
		;-- scroll buffer up
		move.l	cu_CharBuffer(a2),a0
		move.l	cu_AttrBuffer(a2),a1
		move.w	d0,d5
		move.w	cu_BufferWidth(a2),d3
		mulu	d3,d0			; gap width
		move.w	cu_YCP(a2),d1
		addq.w	#1,d1
		mulu	d3,d1			; new start of characters
		move.l	d1,d3
a1225 2
		move.l	d1,d2
		add.l	d0,d2			; old end of characters
a1226 36
		add.l	d1,a0
		add.l	d1,d1
		add.l	d1,a1

		sub.l	d2,d4			; new character count
		bmi.s	dlsbClrAll

		lea	0(a0,d2.l),a4
		add.l	d2,d2
		lea	0(a1,d2.l),a5

		bra.s	dlsbCopyDBF
dlsbCopyLoop:
		move.b	(a4)+,(a0)+
		move.w	(a5)+,(a1)+
dlsbCopyDBF:
		dbf	d4,dlsbCopyLoop
		bra.s	dlsbClrDBF
dlsbClrAll:
		sub.l	d3,d4			; from gap to end
		move.w	d4,d0
		bra.s	dlsbClrDBF
dlsbClrLoop:
		clr.w	(a1)+
dlsbClrDBF:
		dbf	d0,dlsbClrLoop
		move.w	d5,d0

dlSR:
		BSR	idLine
		LINKGFX	ScrollRaster
		BSR	CursEnable
		MOVEM.L	(A7)+,D2-D5
		BRA	nextChar


d1288 1
a1288 1
		BSR	ScrollYText
d1301 1
a1301 1
		BSR	ScrollYText
@


36.3
log
@implement update of scroll damage
implement Esc[2J
@
text
@d1 1
a1 1
	TTL	'$Header: write.asm,v 36.2 88/11/14 16:04:51 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker: kodiak $
d13 4
d80 2
d243 1
a243 1
		and.b	#CUB_TOOSMALL!CUB_RESIZE!CUB_REFRESH!CUB_SELECTING,d0
d325 3
d338 2
d342 4
a345 2
		move.w	cd_LayerRefresh(a6),d0
		or.w	d0,lr_Flags(a0)
@


36.2
log
@coalesce NEG, SUB #1 into NOT
@
text
@d1 1
a1 1
	TTL	'$Header: write.asm,v 36.1 88/09/19 10:16:20 kodiak Exp $'
d13 3
d57 2
d75 1
a75 1
	XREF		UnLockDRPort
d87 2
a88 1
	XREF		ClearScreen
d96 1
d237 1
a237 1
		and.b	#CUB_RESIZE!CUB_REFRESH!CUB_SELECTING,d0
d242 1
a242 1
		BEQ.S	wCheckRefresh
d245 5
a249 1
wCheckRefresh:
d253 1
a253 1
		BSR	RefreshUnit
d268 8
d277 1
a277 2
		MOVE.W	cu_DrawMode(A2),cd_RastPort+rp_DrawMode(A6)
		MOVE.L	cu_AreaPtrn(A2),cd_RastPort+rp_AreaPtrn(A6)
d305 3
a307 2
		MOVE.L	parseTable(PC,D1.W),A1
		JSR	(A1)
d312 1
d314 20
d337 2
a338 1
		BSR	UnLockDRPort
d358 11
a380 9
*------ Parse Table --------------------------------------------------

parseTable:
		DC.L	vanillaP    ;normal character
		DC.L	escP	    ;escape pending
		DC.L	escIP	    ;intermediate escape pending
		DC.L	csiPP	    ;CSI parameters pending
		DC.L	csiIP	    ;CSI intermediate pending

d858 1
a858 3
		BSR	CursDisable
		BSR	ClearScreen
		BSR	CursEnable
d1370 13
a1382 1
		BSR	ClearScreen
@


36.1
log
@add character map and pseudo-clipboard support
@
text
@d1 1
a1 1
	TTL	'$Header: write.asm,v 36.0 88/09/06 19:52:49 kodiak Exp $'
d13 3
d271 1
a273 1

d277 1
a277 2
		NEG.L	D0
		SUBQ.W	#1,D0	;null character is not in string
@


36.0
log
@*** empty log message ***
@
text
@d1 1
a1 1
	TTL	'$Header: write.asm,v 35.1 87/10/26 12:58:28 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 3
d51 2
d66 2
a67 2
	XREF		TakeRPort
	XREF		DropRPort
d77 1
a77 1
	XREF		ScrollText
d86 2
d223 31
a253 1
		BSR	TakeRPort
d291 3
a293 1
		BSR	DropRPort
d295 2
d621 14
d636 24
d661 1
d673 1
a673 1
		BHI.S	nextLine
d1130 2
a1132 1
		NEG.L	D0
d1139 1
a1139 2
		BSR	cu
		MULU	cu_XRSize(A2),D0
d1164 1
d1178 47
a1225 1
		NEG.L	D1
d1232 1
a1232 2
		BSR	cu
		MOVE.L	D0,D1
d1234 1
a1234 1
		MULU	cu_YRSize(A2),D1
d1255 47
a1301 1
		BSR.S	idLine
a1354 3
		MOVE.W	D0,D1
		EXT.L	D1
		MOVEQ	#0,D0
d1357 1
a1357 1
		BSR	ScrollText
d1367 1
a1367 4
		MOVE.W	D0,D1
		NEG.W	D1
		EXT.L	D1
		MOVEQ	#0,D0
d1370 1
a1370 1
		BSR	ScrollText
d1800 1
a1800 1
		BSET	#CUB_FIXEDPL,cu_Flags(A2)
d1805 1
a1805 1
		BCLR	#CUB_FIXEDPL,cu_Flags(A2)
d1818 1
a1818 1
		BSET	#CUB_FIXEDLL,cu_Flags(A2)
d1823 1
a1823 1
		BCLR	#CUB_FIXEDLL,cu_Flags(A2)
d1840 1
a1840 1
		BSET	#CUB_FIXEDLO,cu_Flags(A2)
d1844 1
a1844 1
		BCLR	#CUB_FIXEDLO,cu_Flags(A2)
d1857 1
a1857 1
		BSET	#CUB_FIXEDTO,cu_Flags(A2)
d1861 1
a1861 1
		BCLR	#CUB_FIXEDTO,cu_Flags(A2)
@
