head     36.29;
branch   ;
access   ;
symbols  V39_4:36.27 V37_157:36.27 V37_149:36.27 V37_136:36.27 V37_133:36.27 V37_110:36.27 V37_98:36.27 V37_85:36.27 V37_63:36.27 V37_36:36.27 V37_15:36.27 V37_10:36.26 V37_7:36.26 V37_2:36.26 V36_558:36.26 V36_554:36.26 V36_552:36.26 V36_549:36.26 V36_548:36.26 V36_547:36.26 V36_546:36.26 V36_545:36.26 V36_544:36.26 V36_543:36.26 V36_542:36.26 V36_540:36.25 V36_539:36.25 V36_538:36.25 V36_537:36.25 V36_536:36.25 V36_529:36.23 V36_527:36.23 V36_525:36.22 V36_524:36.21 V36_523:36.21 V36_522:36.21 V36_521:36.21 V36_520:36.21 V36_519:36.21 V36_518:36.21 V36_495:36.21 V36_491:36.21 V36_486:36.21 V36_482:36.21 V36_476:36.21 V36_471:36.21 V36_465:36.21 V36_463:36.21 V36_461:36.21 V36_460:36.21 V36_453:36.21 V36_447:36.21 V36_442:36.21 V36_429:36.21 V36_423:36.21 V36_413:36.20 V36_394:36.19 V36_387:36.18 V36_382:36.18 V36_381:36.18 V36_379:36.17 V36_373:36.17 V36_367:36.17 V36_361:36.17 V36_359:36.17 V36_357:36.17 V36_353:36.17 V36_346:36.17 V36_343:36.17 V36_338:36.16 V36_332:36.16 V36_327:36.16 V36_321:36.16 V36_319:36.16 V36_318:36.16 V36_316:36.16 V36_313:36.16 V36_311:36.16 V36_310:36.15 V36_300:36.14 V36_299:36.13 V36_297:36.12 V36_295:36.12 V36_278:36.12 V36_274:36.12 V36_221:36.10 V36_205:36.10 V36_171:36.9 V36_167:36.9 V36_165:36.9 V36_153:36.8 V36_146:36.7 V36_140:36.6 V36_129:36.5 V36_113:36.4 V36_56:36.3 V36_53:36.2 V36_51:36.1 V36_45:36.1;
locks    ; strict;
comment  @*   @;


36.29
date     92.03.20.14.37.30;  author darren;  state Exp;
branches ;
next     36.28;

36.28
date     92.03.19.12.49.23;  author darren;  state Exp;
branches ;
next     36.27;

36.27
date     91.01.23.16.12.07;  author darren;  state Exp;
branches ;
next     36.26;

36.26
date     90.11.13.14.04.30;  author darren;  state Exp;
branches ;
next     36.25;

36.25
date     90.11.01.15.42.58;  author darren;  state Exp;
branches ;
next     36.24;

36.24
date     90.11.01.11.22.14;  author darren;  state Exp;
branches ;
next     36.23;

36.23
date     90.10.11.15.28.49;  author darren;  state Exp;
branches ;
next     36.22;

36.22
date     90.10.11.14.08.48;  author darren;  state Exp;
branches ;
next     36.21;

36.21
date     90.04.17.11.21.58;  author kodiak;  state Exp;
branches ;
next     36.20;

36.20
date     90.04.13.13.32.46;  author kodiak;  state Exp;
branches ;
next     36.19;

36.19
date     90.04.12.17.06.15;  author kodiak;  state Exp;
branches ;
next     36.18;

36.18
date     90.04.02.10.47.31;  author kodiak;  state Exp;
branches ;
next     36.17;

36.17
date     90.02.21.18.40.31;  author kodiak;  state Exp;
branches ;
next     36.16;

36.16
date     89.12.15.21.50.13;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     89.12.15.17.49.50;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     89.12.15.11.08.27;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     89.12.14.17.03.26;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     89.12.02.11.37.09;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     89.11.27.13.25.38;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     89.11.04.16.04.06;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     89.08.21.12.59.55;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     89.07.10.18.18.19;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     89.07.06.14.27.42;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     89.07.05.15.53.13;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.06.28.19.14.27;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     89.06.28.12.37.27;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     89.04.19.17.05.46;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     89.02.20.13.11.35;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     89.01.10.17.04.26;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     89.01.10.15.42.59;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


36.29
log
@Remove extra code; let RestoreRP do all
@
text
@**
**	$Id: refresh.asm,v 36.28 92/03/19 12:49:23 darren Exp $
**
**      refresh a console unit
**
**      (C) Copyright 1989 Commodore-Amiga, Inc.
**          All Rights Reserved
**
	SECTION	console

**	Includes

	INCLUDE	"cddata.i"

	INCLUDE	"intuition/intuition.i"

	INCLUDE	"debug.i"

**	Exports

	XDEF	RefreshUnit
	XDEF	RefreshDamage
	XDEF	IfNewSize

**	Imports

	XREF	_custom

	XLVO	AndRectRegion		; Graphics
	XLVO	SetAPen			;
	XLVO	SetBPen			;
	XLVO	SetDrMd			;
	XLVO	SetSoftStyle		;
	XLVO	Text			;

	XLVO	BeginUpdate		; Layers
	XLVO	EndUpdate		;

	XREF	LockDRPort
	XREF	UnLockRPort

	XREF	ClearScreen
	XREF	CursRefresh
	XREF	RestoreRP

	XREF	UpdateHighlight

	XREF	ReSizeUnit		;wreset

*------ RefreshDamage ------------------------------------------------
*
*   a2	unit data
*
RefreshDamage:
		bsr	LockDRPort

		;-- check for window size changes

		bsr.s	IfNewSize
		bne.s	rdResize

		btst	#CUB_TOOSMALL,cu_Flags(a2)
		bne.s	rdUnlock

		move.l	cd_RastPort+rp_Layer(a6),a0
		move.l	lr_DamageList(a0),d0
		beq.s	rdBeginUpdate

		move.l	d0,a0
		lea	cu_ClipRect(a2),a1
		LINKGFX	AndRectRegion

rdBeginUpdate:
		move.l	cd_RastPort+rp_Layer(a6),a0
		LINKLAY	BeginUpdate
		tst.l	d0
		beq.s	rdAbortUpdate

		tst.l	cu_CM+cm_AllocSize(a2)	; check if map exists
		beq.s	rdEndUpdate

		bsr.s	RefreshUnit

rdEndUpdate:
		moveq	#1,d0
		move.l	cd_RastPort+rp_Layer(a6),a0
		LINKLAY	EndUpdate    

		move.l	cd_RastPort+rp_Layer(a6),a0
		and.w	#~LAYERREFRESH,lr_Flags(a0)

rdUnlock:
		bsr	UnLockRPort

rdDone:
		rts


rdAbortUpdate:
		move.l	cd_RastPort+rp_Layer(a6),a0
		LINKLAY	EndUpdate
		bra.s	rdUnlock

rdResize:
		bsr	ReSizeUnit
		bra.s	rdUnlock


*------ Check for a newsize condition --------------------------------
*
*   a2  unit data
*
*   Quick check for RESIZE flag followed by a check for window
*   width, and height compared against last cached values.
*
*   != means a return of TRUE (yes, newsize)
*   == means a return of FALSE (not newsize)
*
IfNewSize:
		btst	#CUB_RESIZE,cu_Flags(a2)
		bne.s	newsize

		movea.l	cu_Window(a2),a0
		move.w	wd_Height(a0),d0
		cmp.w	cu_WHeight(a2),d0
		bne.s	newsize

		move.w	wd_Width(a0),d0
		cmp.w	cu_WWidth(a2),d0

newsize:	rts
				

*------ RefreshUnit --------------------------------------------------
*
*   a2	unit data
*

;
;   d3	current attributes
;   d4	incrementing X line position
;   d5	X max
;   d6	decrementing Y line counter
;   d7	Y raster position
;
;   a2	console unit
;   a3	running attribute line
;   a4	cm_AttrDispLines array
;   a6	console device
;
RefreshUnit:
		movem.l	d2-d7/a3-a4,-(a7)

		btst	#CUB_TOOSMALL,cu_Flags(a2)
		bne	ruDone

	;-- Refresh everything, regardless of concealed mode, or
	;-- optimized scrolling

		move.l	cu_Mask(a2),cd_RastPort+rp_Mask(a6)

		move.b	#$FF,cd_RastPort+rp_Mask(a6)

		move.l	cu_Font(a2),cd_RastPort+rp_Font(a6)
		move.l	cu_TxHeight(a2),cd_RastPort+rp_TxHeight(a6)
		move.l	cu_TxBaseline(a2),cd_RastPort+rp_TxBaseline(a6)

	;-- first pass at this problem: render all text

		bsr	ClearScreen

		;-- initialize variables
		move.w	cu_CM+cm_DisplayWidth(a2),d5
		move.w	cu_DisplayYL(a2),d6
		move.w	cu_YROrigin(a2),d7
		add.w	cu_TxBaseline(a2),d7
		sub.w	cu_YRSize(a2),d7

		move.l	cu_CM+cm_AttrDispLines(a2),a4

		moveq	#0,d2			; clear high bytes
		moveq	#0,d3			; current attrs

	    ;-- render this row
ruRowLoop:
		moveq	#0,d4
		tst.w	d6
		bne.s	ruHaveXMax
		move.w	cu_DisplayXL(a2),d5
ruHaveXMax:
		add.w	cu_YRSize(a2),d7
		move.l	(a4)+,a3
		add.l	a3,a3

		;-- find start of characters to render
ruColLoop:
		addq.w	#1,d4
		cmp.w	d4,d5
		blt	ruRowDBF
		move.w	(a3),d2
		and.w	#~CMAF_HIGHLIGHT,d2
		move.w	d2,(a3)+
		bpl.s	ruColLoop

		;-- ensure the attributes for the first character are set
		move.l	d2,d0
		and.w	#CMAM_SOFTSTYLE,d0
		move.w	d3,d1
		and.w	#CMAM_SOFTSTYLE,d1
		cmp.w	d0,d1
		bne.s	ruSetSoftStyle
		tst.w	d3
		bmi.s	ruChkDrawMode
ruSetSoftStyle:
		lsr.w	#CMAS_SOFTSTYLE,d0
		lea	cd_RastPort(a6),a1
		moveq	#(CMAM_SOFTSTYLE>>CMAS_SOFTSTYLE),d1
		LINKGFX	SetSoftStyle

ruChkDrawMode:
		move.l	d2,d0
		and.w	#CMAF_INVERSVID,d0
		move.w	d3,d1
		and.w	#CMAF_INVERSVID,d1
		cmp.w	d0,d1
		bne.s	ruSetDrawMode
		tst.w	d3
		bmi.s	ruAttrCurrent
ruSetDrawMode:
		tst.w	d0
		beq.s	ruStdDrawMode
		moveq	#RP_INVERSVID!RP_JAM2,d0
		bra.s	ruSetDrawModeCall
ruStdDrawMode:
		moveq	#RP_JAM2,d0
ruSetDrawModeCall:
		lea	cd_RastPort(a6),a1
		LINKGFX	SetDrMd

ruAttrCurrent:
		;--	ensure the color for the first character is set
		move.l	d2,d0
		and.w	#CMAM_FGPEN,d0
		move.w	d3,d1
		and.w	#CMAM_FGPEN,d1
		cmp.w	d0,d1
		bne.s	ruSetFGColor
		tst.w	d3
		bmi.s	ruChkBGColor
ruSetFGColor:
		lea	cd_RastPort(a6),a1
		LINKGFX	SetAPen

ruChkBGColor:
		move.l	d2,d0
		and.w	#CMAM_BGPEN,d0
		move.w	d3,d1
		and.w	#CMAM_BGPEN,d1
		cmp.w	d0,d1
		bne.s	ruSetBGColor
		tst.w	d3
		bmi.s	ruColorCurrent

ruSetBGColor:
		lsr.w	#CMAS_BGPEN,d0
		lea	cd_RastPort(a6),a1
		LINKGFX	SetBPen

ruColorCurrent:
		move.w	d2,d3			; save current attributes

		;-- ensure the text CP is correct
		lea	cd_RastPort(a6),a1
		move.w	d4,d1
		subq.w	#1,d1
		mulu	cu_XRSize(a2),d1
		add.w	cu_XROrigin(a2),d1
		move.w	d1,rp_cp_x(a1)
		move.w	d7,rp_cp_y(a1)

		;-- find the matching location in the character array
		move.l	a3,d0
		lsr.l	#1,d0
		subq.l	#1,d0
		add.l	cu_CM+cm_AttrToChar(a2),d0
		move.l	d0,a0

	    ;-- count the characters to render in this line
		move.w	d4,d1			; save start column + 1
ruCountLength:
		addq.w	#1,d4
		cmp.w	d4,d5
		blt.s	ruHaveLength
		move.w	(a3),d0
		and.w	#~CMAF_HIGHLIGHT,d0
		move.w	d0,(a3)+
		cmp.w	d0,d3
		beq.s	ruCountLength
ruHaveLength:
		move.w	d4,d0
		sub.w	d1,d0
		ext.l	d0

		LINKGFX	Text

		subq.w	#1,d4
		subq.l	#2,a3

		bra	ruColLoop

ruRowDBF:
		dbf	d6,ruRowLoop

		bsr	CursRefresh

		btst	#CUB_SELECTED,cu_Flags(a2)
		beq.s	ruRestoreRP

		bsr	UpdateHighlight

		;-- restore RastPort attributes
ruRestoreRP:
		bsr	RestoreRP

ruDone:
		bclr	#CUB_REFRESH,cu_Flags(a2)
		movem.l	(a7)+,d2-d7/a3-a4
		rts

	END
@


36.28
log
@Refresh window does every plane, regardless of scrolling
optimized mask - don't want to leave droppings.
@
text
@d2 1
a2 1
**	$Id: refresh.asm,v 36.27 91/01/23 16:12:07 darren Exp Locker: darren $
a322 1
		move.l	cu_Mask(a2),cd_RastPort+rp_Mask(a6)
@


36.27
log
@Uses subroutine in clear.asm to restore RastPort values; smaller.
Also wasn't reseting the upper 4 minterm bytes after a redraw
- by good luck seems to have worked out ok (this has been there
for a long time).
@
text
@d2 1
a2 1
**	$Id: refresh.asm,v 36.26 90/11/13 14:04:30 darren Exp Locker: darren $
d157 7
a163 1
		move.b	#$ff,cd_RastPort+rp_Mask(a6)
@


36.26
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: refresh.asm,v 36.25 90/11/01 15:42:58 darren Exp Locker: darren $
a42 1

d44 1
d318 1
a318 2
		move.b	cu_DrawMode(a2),cd_RastPort+rp_DrawMode(a6)
		move.l	cu_Minterms(a2),cd_RastPort+rp_minterms(a6)
@


36.25
log
@Change for small windows such that newsize is now checked
for before the check for tiny window.
@
text
@d2 1
a2 1
**	$Id: refresh.asm,v 36.24 90/11/01 11:22:14 darren Exp Locker: darren $
@


36.24
log
@New code added for a new input handling scheme which tracks
history of events - resolves (hopefully) race conditions whic
result in an improperly drawn cursor.
@
text
@d2 1
a2 1
**	$Id: refresh.asm,v 36.23 90/10/11 15:28:49 darren Exp $
a54 3
		btst	#CUB_TOOSMALL,cu_Flags(a2)
		bne.s	rdDone

d61 3
@


36.23
log
@Change for a fix to prevent
window border trashing. See
wreset.asm, and task.asm
@
text
@d2 1
a2 1
**	$Id: refresh.asm,v 36.22 90/10/11 14:08:48 darren Exp Locker: darren $
d17 1
d23 1
d48 1
d60 5
d79 3
d84 1
d87 1
a87 1
		LINKLAY	EndUpdate
d104 30
d322 1
@


36.22
log
@Fix for window border trashing.  New function
to dispose of damage lists used by task.asm
@
text
@d2 1
a2 1
**	$Id: refresh.asm,v 36.21 90/04/17 11:21:58 kodiak Exp Locker: darren $
a21 1
	XDEF	ThrowAwayDamage
a90 29

*------ Throws away a damage list
* a2 unit data
* a6 device base
*
* This is only to be used when the damage is list is truly not needed
* anymore, such as after a full redraw inside of lock layers.
*

ThrowAwayDamage:
		;-- not entirely sure if BeginUpdate() returns a 16
		;-- bit, or 32 value.  Clear D0 just to be sure.

		moveq	#00,d0
		move.l	cd_RastPort+rp_Layer(a6),a0
		LINKLAY	BeginUpdate

		;-- if D0 is false, well, its ok
		;-- we are doing the right thing here
		;-- by calling EndUpdate(l,FALSE)

		move.l	cd_RastPort+rp_Layer(a6),a0
		LINKLAY	EndUpdate

		move.l	cd_RastPort+rp_Layer(a6),a0
		and.w	#~LAYERREFRESH,lr_Flags(a0)

		rts

@


36.21
log
@cursor-in-selection is now specially ghosted
@
text
@d2 1
a2 1
**	$Id: refresh.asm,v 36.20 90/04/13 13:32:46 kodiak Exp Locker: kodiak $
d22 1
a23 1

d92 28
@


36.20
log
@use Id instead of Header for 4.x rcs
@
text
@d2 1
a2 1
**	$Id$
d268 1
d271 1
a271 1
		beq.s	ruCursRefresh
a274 3
ruCursRefresh:
		bsr	CursRefresh

d276 1
@


36.19
log
@bound origin & window size, and move TOOSMALL to just skip graphics rendering
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/refresh.asm,v 36.18 90/04/02 10:47:31 kodiak Exp Locker: kodiak $
@


36.18
log
@for 4.x rcs
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/refresh.asm,v 36.17 90/02/21 18:40:31 kodiak Exp Locker: kodiak $
d53 3
d81 1
a81 1
rdUnlock
d83 2
d114 3
d282 1
@


36.17
log
@first cut at drag-select
@
text
@d2 1
a2 1
**	$Header: refresh.asm,v 36.16 89/12/15 21:50:13 kodiak Exp $
@


36.16
log
@restore unit fg/bg/drawmode/minterms after RefreshUnit
@
text
@d2 1
a2 1
**	$Header: refresh.asm,v 36.15 89/12/15 17:49:50 kodiak Exp $
d261 1
a261 1
		btst	#CUB_SELECTING,cu_Flags(a2)
@


36.15
log
@Only InstallClipRegion when necessary
@
text
@d2 1
a2 1
**	$Header: refresh.asm,v 36.14 89/12/15 11:08:27 kodiak Exp $
d268 5
@


36.14
log
@eliminate damage after resize so redundant refresh doesn't occur
@
text
@d2 1
a2 1
**	$Header: refresh.asm,v 36.13 89/12/14 17:03:26 kodiak Exp $
d28 2
a29 1
	XLVO	SetAPen			; Graphics
d55 9
@


36.13
log
@different damage refresh strategy: should always clear damage
@
text
@d2 1
a2 1
**	$Header: refresh.asm,v 36.12 89/12/02 11:37:09 kodiak Exp $
d56 2
d68 1
d71 6
@


36.12
log
@
@
text
@d2 1
a2 1
**	$Header$
d21 1
a21 1
	XDEF	RefreshWindow
d34 2
a35 2
	XLVO	BeginRefresh		; Intuition
	XLVO	EndRefresh		;
d37 1
a37 1
	XREF	LockIRPort
d47 1
a47 1
*------ RefreshWindow ------------------------------------------------
d51 2
a52 2
RefreshWindow:
		bsr	LockIRPort
d54 2
a55 2
		move.l	cu_Window(a2),a0
		LINKINT	BeginRefresh
d59 6
a64 3
		move.l	cu_Window(a2),a0
		moveq	#1,d0			; TRUE
		LINKINT	EndRefresh
@


36.11
log
@first cut at line buffers
@
text
@d1 9
a9 10
	TTL    '$Header: refresh.asm,v 36.10 89/11/04 16:04:06 kodiak Exp $'
**********************************************************************
*
*			--------------
*   refresh.asm		CONSOLE DEVICE	refresh a console unit
*			--------------
*
*   Copyright 1988 Commodore-Amiga Inc.
*
**********************************************************************
d11 1
a11 1
	SECTION		rawinput
d13 1
a13 1
*------ Included Files -----------------------------------------------
d15 1
a15 1
	INCLUDE		"cddata.i"
a16 1
	INCLUDE		"exec/memory.i"
d18 1
a18 1
	INCLUDE		"intuition/intuition.i"
d20 2
a22 1
*------ Imported Names -----------------------------------------------
d24 1
a24 1
	XREF		_custom
d26 2
d37 2
a38 2
	XREF		LockIRPort
	XREF		UnLockRPort
d40 1
a40 1
	XREF		ClearScreen
d42 1
a42 1
	XREF		CursRefresh
d44 1
a44 1
	XREF		UpdateHighlight
a46 6
*------ Exported Functions -------------------------------------------

	XDEF		RefreshUnit
	XDEF		RefreshWindow


d71 13
d85 1
a85 1
		movem.l	d2-d5/a3-a5,-(a7)
d92 1
a92 1
		clr.l	cu_DisplayXL(a2)	; and cu_DisplayYL(a2)
a93 1
	;-- first pass at this problem: render all text
d96 7
d104 1
d106 1
a106 2
		moveq	#-1,d4			; character row
		moveq	#0,d5			; current attrs
d109 12
a120 2
ruNextRow:
		moveq	#0,d3
d122 3
a124 11
		cmp.w	cu_YMax(a2),d4
		bgt	ruHiLight

		move.l	(a5)+,a4
		add.l	a4,a4

	    ;-- find start of characters to render
ruCheckCol:
		cmp.w	cu_XMax(a2),d3
		bgt	ruNextRow
		move.w	(a4),d2
d126 2
a127 4
		move.w	d2,(a4)+
		bmi.s	ruStartRender
		addq.w	#1,d3
		bra.s	ruCheckCol
d129 1
a129 9
ruStartRender:
	    ;-- find the matching location in the character array
		move.l	a4,d0
		lsr.l	#1,d0
		sub.l	cu_CM+cm_Attributes(a2),d0
		add.l	cu_CM+cm_Characters(a2),d0
		move.l	d0,a3

	    ;-- ensure the attributes for the first character are set
d132 1
a132 1
		move.w	d5,d1
d136 1
a136 1
		tst.w	d5
d147 1
a147 1
		move.w	d5,d1
d151 1
a151 1
		tst.w	d5
d165 1
a165 1
	    ;-- ensure the color for the first character is set
d168 1
a168 1
		move.w	d5,d1
d172 1
a172 1
		tst.w	d5
d181 1
a181 1
		move.w	d5,d1
d185 1
a185 1
		tst.w	d5
d194 1
a194 1
		move.w	d2,d5			; save current attributes
d196 1
a196 1
	    ;-- ensure the text CP is correct
d198 2
a199 1
		move.w	d3,d1
d203 1
a203 5
		move.w	d4,d1
		mulu	cu_YRSize(a2),d1
		add.w	cu_YROrigin(a2),d1
		add.w	cu_TxBaseline(a2),d1
		move.w	d1,rp_cp_y(a1)
d205 7
d213 1
a213 1
		move.w	d3,d1			; save start column
d215 4
a218 4
		addq.w	#1,d3
		cmp.w	cu_XMax(a2),d3
		bgt.s	ruHaveLength
		move.w	(a4),d0
d220 3
a222 6
		move.w	d0,(a4)+
		cmp.w	d0,d5
		bne.s	ruHaveLength2
		bra.s	ruCountLength
ruHaveLength2:
		subq.l	#2,a4
d224 1
a224 1
		move.w	d3,d0
d227 1
a227 1
		move.l	a3,a0
d230 2
a231 2
		;-- set cu_Display.L
		movem.w	d3/d4,cu_DisplayXL(a2)	; and cu_DisplayYL(a2)
d233 1
a233 1
		bra	ruCheckCol
d235 2
d238 1
a238 1
ruHiLight:
d247 1
a247 1
		movem.l	(a7)+,d2-d5/a3-a5
@


36.10
log
@restructure map variables
set Display.L bounds
@
text
@d1 1
a1 1
	TTL    '$Header: refresh.asm,v 36.9 89/08/21 12:59:55 kodiak Exp $'
d77 1
a77 1
		movem.l	d2-d5/a3-a4,-(a7)
d89 1
a89 1
		move.l	cu_CM+cm_AttrDisplay(a2),a4
d91 1
a91 2
		moveq	#0,d3			; character column
		moveq	#0,d4			; character row
d95 3
a97 1
ruCheckRow:
d101 3
a108 1
		bmi.s	ruStartRender
d111 1
d115 1
a116 3
ruStartRender:
		and.w	#~CMAF_HIGHLIGHT,d2
		move.w	d2,(a4)+
a117 1
		sub.l	cu_CM+cm_AttrDisplay(a2),d0
d119 3
a121 2
		move.l	cu_CM+cm_CharDisplay(a2),a3
		lea	-1(a3,d0.l),a3
a228 12
	    ;-- skip to next row
ruNextRow:
		move.w	cu_CM+cm_DisplayWidth(a2),d0
		sub.w	cu_XMax(a2),d0
		subq.w	#1,d0
		add.w	d0,a4
		add.w	d0,a4
		moveq	#0,d3
		addq.w	#1,d4
		bra	ruCheckRow


d238 1
a238 1
		movem.l	(a7)+,d2-d5/a3-a4
@


36.9
log
@first cut at keeping highlight/select information in attribute array
@
text
@d1 1
a1 1
	TTL    '$Header: refresh.asm,v 36.8 89/07/10 18:18:19 kodiak Exp $'
d27 5
a31 5
	XREF_GFX	SetAPen
	XREF_GFX	SetBPen
	XREF_GFX	SetDrMd
	XREF_GFX	SetSoftStyle
	XREF_GFX	Text
d33 2
a34 2
	XREF_INT	BeginRefresh
	XREF_INT	EndRefresh
d84 2
d89 1
a89 1
		move.l	cu_AttrBuffer(a2),a4
d106 1
a106 1
		and.w	#~CUAF_HIGHLIGHT,d2
d113 1
a113 1
		and.w	#~CUAF_HIGHLIGHT,d2
d116 1
a116 1
		sub.l	cu_AttrBuffer(a2),d0
d118 1
a118 1
		move.l	cu_CharBuffer(a2),a3
d123 1
a123 1
		and.w	#CUAM_SOFTSTYLE,d0
d125 1
a125 1
		and.w	#CUAM_SOFTSTYLE,d1
d131 1
a131 1
		lsr.w	#CUAS_SOFTSTYLE,d0
d133 1
a133 1
		moveq	#(CUAM_SOFTSTYLE>>CUAS_SOFTSTYLE),d1
d138 1
a138 1
		and.w	#CUAF_INVERSVID,d0
d140 1
a140 1
		and.w	#CUAF_INVERSVID,d1
d159 1
a159 1
		and.w	#CUAM_FGPEN,d0
d161 1
a161 1
		and.w	#CUAM_FGPEN,d1
d172 1
a172 1
		and.w	#CUAM_BGPEN,d0
d174 1
a174 1
		and.w	#CUAM_BGPEN,d1
d181 1
a181 1
		lsr.w	#CUAS_BGPEN,d0
d207 1
a207 1
		and.w	#~CUAF_HIGHLIGHT,d0
d221 3
d229 1
a229 1
		move.w	cu_BufferWidth(a2),d0
@


36.8
log
@recode use of attribute fields in attribute buffer
@
text
@d1 1
a1 1
	TTL    '$Header: refresh.asm,v 36.7 89/07/06 14:27:42 kodiak Exp $'
d43 1
a43 1
	XREF		SelectHiLight
d102 1
a102 1
		move.w	(a4)+,d2
d104 2
d111 2
d204 4
a207 1
		cmp.w	(a4)+,d5
d238 1
a238 2
		movem.w	cd_SelectionStartX(a6),d0-d3
		bsr	SelectHiLight
@


36.7
log
@move unreferenced code for blitter scroll of character map to scroll.asm
@
text
@d1 1
a1 1
	TTL    '$Header: refresh.asm,v 36.6 89/07/05 15:53:13 kodiak Exp $'
d54 1
a54 1
*   A2	unit data
d57 1
a57 1
		BSR	LockIRPort
d74 1
a74 1
*   A2	unit data
d80 3
a82 3
		MOVE.L	cu_Font(A2),cd_RastPort+rp_Font(A6)
		MOVE.L	cu_TxHeight(A2),cd_RastPort+rp_TxHeight(A6)
		MOVE.L	cu_TxBaseline(A2),cd_RastPort+rp_TxBaseline(A6)
d91 1
a91 1
		moveq	#-1,d5			; current attrs
d103 1
a103 2
		btst	#15,d2
		bne.s	ruStartRender
d114 1
d117 1
a117 1
		and.w	#$0f00,d0
d119 1
a119 1
		and.w	#$0f00,d1
d121 5
a125 2
		beq.s	ruChkDrawMode
		lsr.w	#8,d0
d127 1
a127 1
		moveq	#$7,d1
d129 1
d132 1
a132 1
		and.w	#$3000,d0
d134 1
a134 1
		and.w	#$3000,d1
d136 11
a146 3
		beq.s	ruAttrCurrent
		rol.w	#6,d0			; move RP_INVERSEVID back
		or.b	#RP_JAM2,d0
d153 1
a153 1
		and.w	#$000f,d0
d155 1
a155 1
		and.w	#$000f,d1
d157 4
a160 1
		beq.s	ruChkBGColor
d163 1
d166 1
a166 1
		and.w	#$00f0,d0
d168 1
a168 1
		and.w	#$00f0,d1
d170 6
a175 2
		beq.s	ruColorCurrent
		lsr.w	#4,d0
d180 1
a180 1
		move.w	d2,d5			; save current color
d184 9
a192 9
		MOVE.W	d3,D1
		MULU	cu_XRSize(A2),D1
		ADD.W	cu_XROrigin(A2),D1
		MOVE.W	D1,rp_cp_x(A1)
		MOVE.W	d4,D1
		MULU	cu_YRSize(A2),D1
		ADD.W	cu_YROrigin(A2),D1
		ADD.W	cu_TxBaseline(A2),D1
		MOVE.W	D1,rp_cp_y(A1)
@


36.6
log
@delete CursClear (not needed)
@
text
@d1 1
a1 1
	TTL    '$Header: refresh.asm,v 36.5 89/06/28 19:14:27 kodiak Exp $'
a19 2
	INCLUDE		"hardware/custom.i"

a26 2
	XREF_GFX	DisownBlitter
	XREF_GFX	OwnBlitter
a31 1
	XREF_GFX	WaitBlit
a218 82

*------ ScrollBufferUp -----------------------------------------------
*
*	ScrollBufferUp(y0, dy)
*	               d0  d1
*
ScrollBufferUp:
		movem.l	d2-d4/a3,-(a7)
	    ;-- get the blitter
		LINKGFX	OwnBlitter
		LINKGFX	WaitBlit
		move.l	_custom,a3

		;-- set the modulos and controls
		moveq	#0,d0
		move.w	d0,bltbmod(a3)
		move.w	d0,bltdmod(a3)
		move.w	d0,bltcon1(a3)

		move.w	cu_BufferWidth(a2),d3
		move.l	cu_BufferHeight(a2),d4
		;-- find the origin of source and destination
		move.w	d1,d2			; save ysize
		add.w	d0,d1			; y1
		mulu	d3,d0			; destination offset
		sub.l	d1,d4			; check if any source exists
						;   also calculate rows to clr
		bgt.s	sbuScroll
		;--	set up to just clear attributes
		add.l	d1,d4			; recover BufferHeight
		sub.l	d0,d4			; get rows to clear
		add.l	d0,d0
		move.l	cu_AttrBuffer(a2),a0
		add.l	d0,a0
		move.l	a0,bltdpt(a3)
		bra.s	sbuClr

sbuScroll:
		mulu	d3,d1			; source offset
		move.w	#$05cc,bltcon0(a2)	; copy B to D
		;-- set character source and destination
		move.l	cu_CharBuffer(a2),a0
		move.l	a0,a1
		add.l	d0,a0
		add.l	d1,a1
		move.l	a0,bltdpt(a3)
		move.l	a1,bltbpt(a3)

		;-- calculate the size and fire up the blt
		lsl.w	#6,d2
		lsr.w	#1,d3
		or.w	d3,d2
		move.w	d2,bltsize(a3)

		;-- set attribute source and destination
		add.l	d0,d0
		add.l	d1,d1
		move.l	cu_AttrBuffer(a2),a0
		move.l	a0,a1
		add.l	d0,a0
		add.l	d1,a1
		LINKGFX	WaitBlit
		move.l	a0,bltdpt(a3)
		move.l	a1,bltbpt(a3)

		;-- calculate the size and fire up the blt
		add.w	d3,d2
		move.w	d2,bltsize(a3)
		LINKGFX	WaitBlit
		add.w	d3,d3

sbuClr:
		move.w	#$0100,bltcon0(a2)	; clear D for remainder
		lsl.w	#6,d4
		or.w	d3,d4
		move.w	d4,bltsize(a3)

		LINKGFX	DisownBlitter
		LINKGFX	WaitBlit
		movem.l	(a7)+,d2-d4/a3

		RTS
@


36.5
log
@better avoidance of cursor spoor
@
text
@d1 1
a1 1
	TTL    '$Header: refresh.asm,v 36.4 89/06/28 12:37:27 kodiak Exp $'
a45 1
	XREF		CursClear
a66 2
		bsr	CursClear

a68 2
		bsr	CursRefresh

d214 1
a214 1
		beq.s	ruDone
d219 3
a221 1
ruDone:
@


36.4
log
@seperate refresh code into RefreshUnit as part of scrolling support
@
text
@d1 1
a1 1
	TTL    '$Header: refresh.asm,v 36.3 89/04/19 17:05:46 kodiak Exp $'
d46 2
a47 1
	XREF		CursRender
d68 2
d72 2
a95 2
;	    ;-- clear vesteges of the old cursor
;		bsr	CursClear
d219 1
a219 1
		beq.s	ruCurs
a222 3

ruCurs:
		bsr	CursRender
@


36.3
log
@don't lock layers before BeginRefresh
@
text
@d1 1
a1 1
	TTL    '$Header: refresh.asm,v 36.2 89/02/20 13:11:35 kodiak Exp $'
d42 4
a45 1
	XREF		UnLockIRPort
d47 1
a47 1
	XREF		CursClear
d54 1
d57 1
a57 1
*------ RefreshUnit --------------------------------------------------
d61 1
a61 3
RefreshUnit:
		movem.l	d2-d5/a3-a4,-(a7)

d67 17
a84 1
		MOVE.L	cu_AreaPtrn(A2),cd_RastPort+rp_AreaPtrn(A6)
d90 3
a92 2
	    ;-- clear vesteges of the old cursor
		bsr	CursClear
d216 1
a216 1
		beq.s	ruEnd
d221 1
a221 3
ruEnd:
		btst	#CUB_CURSON,cu_Flags(a2)
		beq.s	ruUnLock
d223 2
a224 5
ruUnLock
		move.l	cu_Window(a2),a0
		moveq	#1,d0			; TRUE
		LINKINT	EndRefresh
		bsr	UnLockIRPort
@


36.2
log
@clear old cursor before update
@
text
@d1 1
a1 1
	TTL    '$Header: refresh.asm,v 36.1 89/01/10 17:04:26 kodiak Exp $'
d41 2
a42 2
	XREF		LockDRPort
	XREF		UnLockDRPort
d60 1
a60 1
		BSR	LockDRPort
d210 1
a210 1
		bsr	UnLockDRPort
@


36.1
log
@*** empty log message ***
@
text
@d1 1
a1 1
	TTL    '$Header$'
d44 1
d72 3
@


36.0
log
@new for V36
@
text
@@
