head     36.30;
branch   ;
access   ;
symbols  V39_4:36.24 V37_157:36.23 V37_149:36.23 V37_136:36.23 V37_133:36.23 V37_110:36.23 V37_98:36.23 V37_85:36.23 V37_63:36.22 V37_36:36.21 V37_15:36.20 V37_10:36.19 V37_7:36.19 V37_2:36.19 V36_558:36.19 V36_554:36.19 V36_552:36.19 V36_549:36.18 V36_548:36.18 V36_547:36.18 V36_546:36.18 V36_545:36.18 V36_544:36.18 V36_543:36.18 V36_542:36.18 V36_540:36.18 V36_539:36.18 V36_538:36.18 V36_537:36.18 V36_536:36.18 V36_529:36.18 V36_527:36.18 V36_525:36.18 V36_524:36.18 V36_523:36.17 V36_522:36.17 V36_521:36.17 V36_520:36.17 V36_519:36.17 V36_518:36.17 V36_495:36.16 V36_491:36.16 V36_486:36.16 V36_482:36.16 V36_476:36.16 V36_471:36.16 V36_465:36.16 V36_463:36.16 V36_461:36.16 V36_460:36.16 V36_453:36.16 V36_447:36.16 V36_442:36.15 V36_429:36.14 V36_423:36.14 V36_413:36.14 V36_394:36.12 V36_387:36.11 V36_382:36.11 V36_381:36.11 V36_379:36.10 V36_373:36.10 V36_367:36.9 V36_361:36.9 V36_359:36.9 V36_357:36.9 V36_353:36.9 V36_346:36.9 V36_343:36.9 V36_338:36.9 V36_332:36.9 V36_327:36.9 V36_321:36.9 V36_319:36.9 V36_318:36.9 V36_316:36.9 V36_313:36.9 V36_311:36.9 V36_310:36.9 V36_300:36.9 V36_299:36.9 V36_297:36.9 V36_295:36.9 V36_278:36.9 V36_274:36.9 V36_221:36.7 V36_205:36.7 V36_171:36.6 V36_167:36.6 V36_165:36.6 V36_153:36.5 V36_146:36.4 V36_140:36.4 V36_129:36.3 V36_113:36.2 V36_56:36.1 V36_53:36.1 V36_51:36.1 V36_45:36.1 L36_42:36.1;
locks    ; strict;
comment  @*   @;


36.30
date     92.05.19.10.29.37;  author darren;  state Exp;
branches ;
next     36.29;

36.29
date     92.05.18.13.05.55;  author darren;  state Exp;
branches ;
next     36.28;

36.28
date     92.03.24.11.17.17;  author darren;  state Exp;
branches ;
next     36.27;

36.27
date     92.03.24.11.09.45;  author darren;  state Exp;
branches ;
next     36.26;

36.26
date     92.03.20.14.45.26;  author darren;  state Exp;
branches ;
next     36.25;

36.25
date     92.03.19.12.47.08;  author darren;  state Exp;
branches ;
next     36.24;

36.24
date     92.03.16.11.42.16;  author darren;  state Exp;
branches ;
next     36.23;

36.23
date     91.03.13.16.45.35;  author darren;  state Exp;
branches ;
next     36.22;

36.22
date     91.02.22.14.20.58;  author darren;  state Exp;
branches ;
next     36.21;

36.21
date     91.02.14.14.54.48;  author darren;  state Exp;
branches ;
next     36.20;

36.20
date     91.01.23.16.11.12;  author darren;  state Exp;
branches ;
next     36.19;

36.19
date     90.12.13.19.00.57;  author darren;  state Exp;
branches ;
next     36.18;

36.18
date     90.10.08.11.26.47;  author darren;  state Exp;
branches ;
next     36.17;

36.17
date     90.06.06.14.29.37;  author kodiak;  state Exp;
branches ;
next     36.16;

36.16
date     90.04.23.16.23.56;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     90.04.20.09.45.19;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     90.04.16.18.22.48;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     90.04.13.13.32.20;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     90.04.12.17.04.35;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     90.04.02.10.47.09;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     90.03.03.14.55.46;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     89.12.03.16.36.20;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     89.12.02.11.36.26;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     89.11.04.15.58.34;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     89.08.21.12.46.51;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.07.10.18.16.59;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     89.07.05.15.17.51;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     89.06.28.19.13.39;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     89.06.28.12.24.21;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     88.09.19.10.15.24;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     88.09.06.19.51.22;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


36.30
log
@Set borderfill state bit on clear screen.  Cache current draw mode
at time of bit set.  Defer filling border until unlock of rastport
semaphore
@
text
@**
**      $Id: clear.asm,v 36.29 92/05/18 13:05:55 darren Exp Locker: darren $
**
**      clear areas of the console
**
**      (C) Copyright 1985,1989,1991,1992 Commodore-Amiga, Inc.
**          All Rights Reserved
**
	SECTION	console

**	Includes

	INCLUDE	"cddata.i"

	INCLUDE	"debug.i"

**	Exports

	XDEF		CDClear
	XDEF		CDCBClear

	XDEF		ClearEOL
	XDEF		ClearEOD
	XDEF		ClearDisplay
	XDEF		ClearScreen
	XDEF		ClearRaster
	XDEF		RestoreRP


**	Imports

	XLVO	SetAPen			; Graphics
	XLVO	RectFill		;
	XLVO	SetDrMd			;

	XREF	ResetBuffer		; scroll

	XREF	sgrNewMask		; write

**	Assumptions

	IFNE	CUFB_FIXEDBG-7
	FAIL	"CUFB_FIXEDBG not most significant bit"
	ENDC
	IFNE	cu_ReadLastOut-cu_ReadLastIn-2
	FAIL	"cu_ReadLastOut does not follow cu_ReadLastIn"
	ENDC
	IFNE	cu_YCP-cu_XCP-2
	FAIL	"cu_YCP does not follow cu_XCP"
	ENDC
	IFNE	cu_DisplayYL-cu_DisplayXL-2
	FAIL	"cu_DisplayYL does not follow cu_DisplayXL"
	ENDC
	IFNE	RP_JAM2-1
	FAIL	"RP_JAM2 not bit 0, recode"
	ENDC
	IFNE	RP_INVERSVID-4
	FAIL	"RP_INVERSVID not bit 2, recode"
	ENDC


******* console.device/CMD_CLEAR *************************************
*
*    NAME
*	CMD_CLEAR -- Clear console input buffer.
*
*    FUNCTION
*	Remove from the console input buffer any reports waiting to
*	satisfy read requests.
*
*    IO REQUEST INPUT
*	io_Message	mn_ReplyPort set if quick I/O is not possible
*	io_Device	preset by the call to OpenDevice
*	io_Unit		preset by the call to OpenDevice
*	io_Command	CMD_CLEAR
*	io_Flags	IOB_QUICK set if quick I/O is possible, else 0
*
*    SEE ALSO
*	exec/io.h, devices/console.h
*
**********************************************************************

CDCBClear	EQU	-1

CDClear:
		move.l	IO_UNIT(a1),a0
		clr.l	cu_ReadLastIn(a0)	; and cu_ReadLastOut
		rts


*------	ClearEOL -----------------------------------------------------
*
*   NAME
*	ClearEOL - clear from current position to end of line
*
*---------------------------------------------------------------------
ClearEOL:
		movem.l d2-d3,-(a7)

		;-- find clearing area
		movem.w	cu_XCP(a2),d0/d1		; and cu_YCP
		move.w	cu_XMax(a2),d2			; right bound
		addq.w	#1,d2				;

		;--	check for new display.L
		cmp.w	cu_DisplayYL(a2),d1
		bne.s	ceolHaveEOD
		cmp.w	cu_DisplayXL(a2),d0
		bge.s	ceolDone
		move.w	cu_DisplayXL(a2),d2	; right bound
		move.w	d0,cu_DisplayXL(a2)	; new Display.L

ceolHaveEOD:
		tst.l	cu_CM+cm_AllocSize(a2)
		beq.s	ceolCR

		;-- clear buffer area
		lsl.w	#2,d1
		move.l	cu_CM+cm_AttrDispLines(a2),a0
		move.l	0(a0,d1.w),a0

		add.w	d0,a0
		add.l	a0,a0

		sub.w	d0,d2
		bra.s	ceolCBDBF
ceolCBLoop:
		clr.w	(a0)+
ceolCBDBF:
		dbf	d2,ceolCBLoop

		;-- clear raster area
ceolCR:
		bsr	clearEOL
ceolDone:
		movem.l	(a7)+,d2-d3
		rts


*------	ClearEOD -----------------------------------------------------
*
*   NAME
*	ClearEOD -- clear from current position to end of RastPort
*
*---------------------------------------------------------------------
ClearEOD:
		movem.l d2-d3,-(a7)

		tst.l	cu_XCP(a2)		; and cu_YCP
		beq.s	cdEntry

		tst.l	cu_CM+cm_AllocSize(a2)
		beq.s	ceodCR

		;-- check for new display.L
		movem.w	cu_XCP(a2),d0/d1	; and cu_YCP
		movem.w	cu_DisplayXL(a2),d2/d3	; and cm_DisplayYL

		;--	check for anything to clear
		cmp.w	d3,d1
		bgt.s	ceodDone
		bne.s	ceodNewEOD

		cmp.w	d2,d0
		bge.s	ceodDone

ceodNewEOD:
		movem.w	d0/d1,cu_DisplayXL(a2)	; and cm_DisplayYL

		;-- clear raster area
ceodCR:
		bsr.s	clearEOL

		move.w	cu_XROrigin(a2),d0
		move.w	cu_YCP(a2),d1
		addq.w	#1,d1
		mulu	cu_YRSize(a2),d1
		add.w	cu_YROrigin(a2),d1
		bsr.s	clearEODEntry
ceodDone:
		movem.l	(a7)+,d2-d3
		rts


*------	ClearScreen ------------------------------------------------------
*
*   NAME
*	ClearScreen -- clear raster display
*
*---------------------------------------------------------------------
ClearScreen:
		movem.l	d2-d3,-(a7)

		movem.l	d0-d1,-(a7)
		moveq	#RP_JAM2,d0
		lea	cd_RastPort(a6),a1
		LINKGFX SetDrMd
		movem.l	(a7)+,d0-d1
		bra.s	cdCR


*------	ClearDisplay -----------------------------------------------------
*
*   NAME
*	ClearDisplay -- clear entire display
*
*---------------------------------------------------------------------
ClearDisplay:
		movem.l d2-d3,-(a7)
cdEntry:
		;-- show cursor is not rendered
		clr.l	cu_CursorPattern(a2)
		;-- clear display and off screen buffers
		clr.l	cu_DisplayXL(a2)	; and cu_DisplayYL

		bsr	ResetBuffer	
**		clr.l	cu_CM+cm_BufferXL(a2)	; and cm_BufferYL

		;--FIX!! confusing background & cell char
		;--they are different, so I dont mix them
		;--like the original code below


*		tst	cu_FixedFlags(a2)	; btst #CUFB_FIXEDBG,
*		bmi.s	cdCR
*		move.b	cu_BgPen(a2),cu_BgColor(a2)
*

		;-- reset optimal scrolling mask having cleared the screen

		move.b	#1,cu_ScrollMask(a2)
		bsr	sgrNewMask

cdCR:
		;-- delay border/edge fill, and cache last draw mode

		move.b	cd_RastPort+rp_DrawMode(a6),cu_ClearDrMd(a2)

		bset	#CUB_BORDERFILL,cu_States(a2)

		move.w	cu_XROrigin(a2),d0
		move.w	cu_YROrigin(a2),d1

		bsr.s	clearEODEntry

		movem.l	(a7)+,d2-d3
		rts

;---------------------------------------------------------------------
clearEOL:
		move.w	cu_XCP(a2),d0
		mulu	cu_XRSize(a2),d0
		add.w	cu_XROrigin(a2),d0
		move.w	cu_YCP(a2),d1
		mulu	cu_YRSize(a2),d1
		add.w	cu_YROrigin(a2),d1
		move.l	d1,d3
		add.w	cu_YRSize(a2),d3
		subq.w	#1,d3
		bra.s	clearEOLEntry


clearEODEntry:
		move.w	cu_YRExtant(a2),d3
clearEOLEntry:
		move.w	cu_XRExtant(a2),d2
; drop		bsr.s	ClearRaster
; thru		rts


*------ ClearRaster --------------------------------------------------
*
*   NAME
*	ClearRaster - clear a rectangle of the raster port
*
*   SYNOPSIS
*	error = ClearRaster(xl, yl, xu, yu)
*			    d0  d1  d2  d3
*
*   FUNCTION
*	This function sets a rectangle in the RastPort to the
*	background color for DrawMode 1, or zero otherwise
*
*---------------------------------------------------------------------
ClearRaster:
		;-- ensure that the result is a positive rectangle
		cmp.w	d0,d2
		blt.s	noClearing
		cmp.w	d1,d3
		blt.s	noClearing
		btst	#CUB_TOOSMALL,cu_Flags(a2)
		bne.s	noClearing

		movem.w	d0/d1,-(a7)		; save rectangle origin
		move.b	cu_BgColor(a2),d0
		lea	cd_RastPort(a6),a1
		LINKGFX SetAPen
		clr.l	cd_RastPort+rp_AreaPtrn(a6)

		movem.w	(a7)+,d0/d1

		lea	cd_RastPort(a6),a1

		; Fix bug in conceal mode, and avoid cursor
		; droppings.  Conceal mode used to set rp_Mask
		; to 0, so clears/scrolls didn't work at all -
		; real bad since the screen is not synced with
		; the character map.

		move.b	#$FF,rp_Mask(a1)

		LINKGFX RectFill

		;-- FALL THROUGH

;------ Restore shared RastPort drawing values ---------------------------------------
;
;   INPUT
;	a2	unit
;	a6	device
;
RestoreRP:
		move.l	cu_Mask(a2),cd_RastPort+rp_Mask(a6)
		move.l	cu_Minterms(a2),cd_RastPort+rp_minterms(a6)
		move.l	cu_Minterms+4(a2),cd_RastPort+rp_minterms+4(a6)
		move.b	cu_DrawMode(a2),cd_RastPort+rp_DrawMode(a6)
noClearing:
		rts

	END
@


36.29
log
@Clear up to FullX/YRExtant now; may be up to border instead of
just up to (max chars * chars)-1
@
text
@d2 1
a2 1
**      $Id: clear.asm,v 36.28 92/03/24 11:17:17 darren Exp Locker: darren $
d235 1
a235 1
		bsr.s	clearScreen
d237 9
a248 1

d262 1
a262 3
clearScreen:
		move.w	cu_XROrigin(a2),d0
		move.w	cu_YROrigin(a2),d1
d264 1
a264 1
		move.w	cu_FullYRExtant(a2),d3
d266 1
a266 1
		move.w	cu_FullXRExtant(a2),d2
@


36.28
log
@Changed mind; don't want to come up with a mask of 0 ever
@
text
@d2 1
a2 1
**	$Id: clear.asm,v 36.27 92/03/24 11:09:45 darren Exp Locker: darren $
d6 1
a6 1
**      (C) Copyright 1985,1989 Commodore-Amiga, Inc.
d258 1
a258 1
		move.w	cu_YRExtant(a2),d3
d260 1
a260 1
		move.w	cu_XRExtant(a2),d2
@


36.27
log
@Reset ScrollMask as 0 so we can make masks of 0-6 for optimal
2 plane scrolling.
@
text
@d2 1
a2 1
**	$Id: clear.asm,v 36.26 92/03/20 14:45:26 darren Exp Locker: darren $
d231 1
a231 1
		clr.b	cu_ScrollMask(a2)
@


36.26
log
@move mask reset before cdCR label
@
text
@d2 1
a2 1
**	$Id: clear.asm,v 36.25 92/03/19 12:47:08 darren Exp Locker: darren $
d231 1
a231 1
		move.b	#1,cu_ScrollMask(a2)
@


36.25
log
@Clearing explicitly clears all bitplanes always to avoid leaving
droppings (e.g., cursor in borders) as part of new scrolling
optimization.  Since clearing is generally only a small part
of the window, its not a priority to optimize on per case bases.
@
text
@d2 1
a2 1
**	$Id: clear.asm,v 36.24 92/03/16 11:42:16 darren Exp Locker: darren $
a228 3
cdCR:
		bsr.s	clearScreen

d233 3
@


36.24
log
@Fix CMD_CLEAR.  Now uses A0 for IO_UNIT reference; was using junk
via register A2???  Looks like a pure typo since much of the code
uses A2 for a console unit pointer.
@
text
@d2 1
a2 1
**	$Id: clear.asm,v 36.23 91/03/13 16:45:35 darren Exp Locker: darren $
d15 2
d38 2
d232 5
d293 1
d297 9
d317 1
a319 2
		move.b	cu_FgPen(a2),cd_RastPort+rp_FgPen(a6)
		move.b	cu_BgPen(a2),cd_RastPort+rp_BgPen(a6)
@


36.23
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: clear.asm,v 36.22 91/02/22 14:20:58 darren Exp Locker: darren $
d83 1
a83 1
		clr.l	cu_ReadLastIn(a2)	; and cu_ReadLastOut
@


36.22
log
@Now calls ResetBuffer in scroll.asm to clear BufferXL/YL.  See scroll.asm
@
text
@d2 1
a2 1
**	$Id: clear.asm,v 36.21 91/02/14 14:54:48 darren Exp Locker: darren $
@


36.21
log
@Autodoc stuff
@
text
@d2 1
a2 1
**	$Id: clear.asm,v 36.20 91/01/23 16:11:12 darren Exp Locker: darren $
d27 1
d34 2
d211 3
a213 1
		clr.l	cu_CM+cm_BufferXL(a2)	; and cm_BufferYL
@


36.20
log
@Shared RastPort restore code; used in 3 places - also insures full
restore of attributes after a clear operation.
@
text
@d2 1
a2 1
**	$Id: clear.asm,v 36.19 90/12/13 19:00:57 darren Exp Locker: darren $
d58 1
a58 1
*	Clear -- Clear console input buffer.
@


36.19
log
@Fixes bug with INVERSID mode, and refreshing screen for
some color combinations - ClearScreen now sets draw mode
to normal JAM2 for a clearscreen - called on reset, and
when a refresh is needed.
@
text
@d2 1
a2 1
**	$Id: clear.asm,v 36.18 90/10/08 11:26:47 darren Exp Locker: darren $
d25 1
a26 1

a32 1

d284 9
d296 2
@


36.18
log
@Fix for background/cell character
handling.
@
text
@d2 1
a2 1
**	$Id: clear.asm,v 36.17 90/06/06 14:29:37 kodiak Exp Locker: darren $
a14 1

d31 1
d128 1
a128 1
		bsr.s	clearEOL
d187 6
@


36.17
log
@makes cu_BgColor the same as cu_BgPen upon ^L unless otherwise specified
@
text
@d2 1
a2 1
**	$Id: clear.asm,v 36.16 90/04/23 16:23:56 kodiak Exp Locker: kodiak $
d204 10
a213 3
		tst	cu_FixedFlags(a2)	; btst #CUFB_FIXEDBG,
		bmi.s	cdCR
		move.b	cu_BgPen(a2),cu_BgColor(a2)
@


36.16
log
@first cut: clear off screen buffers if clearing *entire* display
@
text
@d2 1
a2 1
**	$Id: clear.asm,v 36.15 90/04/20 09:45:19 kodiak Exp Locker: kodiak $
d36 3
d204 3
@


36.15
log
@first semi-tested big clip support
@
text
@d2 1
a2 1
**	$Id: clear.asm,v 36.14 90/04/16 18:22:48 kodiak Exp Locker: kodiak $
d139 4
d147 1
a147 1
		movem.w	cu_XCP(a2),d0/d1		; and cu_YCP
d195 2
a196 1
	    ;-- show cursor is not rendered
d198 3
a200 5

;		tst.l	cu_CM+cm_AllocSize(a2)
;		beq.s	cdCR

		clr.l	cu_DisplayXL(a2)		; and cm_DisplayYL
@


36.14
log
@sniff cursor ghosting compatibility problems
@
text
@d2 1
a2 1
**	$Id: clear.asm,v 36.13 90/04/13 13:32:20 kodiak Exp Locker: kodiak $
d36 3
d78 1
a78 1
		FLUSHBUFFER	cu_ReadBuffer(a0)
@


36.13
log
@use Id instead of Header for 4.x rcs
@
text
@d2 1
a2 1
**	$Id$
d188 2
a189 2
	    ;-- clear cursor rendered flags
		and.b	#~(CUF_CURSBLOCK!CUF_CURSGHOST)&$ff,cu_CursorFlags(a2)
@


36.12
log
@bound origin & window size, and move TOOSMALL to just skip graphics rendering
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/clear.asm,v 36.11 90/04/02 10:47:09 kodiak Exp Locker: kodiak $
@


36.11
log
@for 4.x rcs
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/clear.asm,v 36.10 90/03/03 14:55:46 kodiak Exp Locker: kodiak $
d247 2
@


36.10
log
@first cut @@ code to set console background color
@
text
@d2 1
a2 1
**	$Header: clear.asm,v 36.9 89/12/03 16:36:20 kodiak Exp $
@


36.9
log
@Sunday checkin
@
text
@d2 1
a2 1
**	$Header: clear.asm,v 36.8 89/12/02 11:36:26 kodiak Exp $
d249 1
a250 10
		moveq	#0,d0
		btst.b	#0,cd_RastPort+rp_DrawMode(a6)	; RP_JAM2
		beq.s	isClear
		btst.b	#2,cd_RastPort+rp_DrawMode(a6)	; RP_INVERSVID
		beq.s	isBgPen
		move.b	rp_FgPen(a1),d0
		bra.s	isClear
isBgPen:
		move.b	rp_BgPen(a1),d0
isClear:
@


36.8
log
@checkpoint after line buffer coding completed,
and just after start of line length coding
@
text
@d2 1
a2 1
**	$Header$
d106 1
a106 1
		lsl.w	#2,d0
d108 1
a108 1
		move.l	0(a0,d0.w),a0
a118 11

		;-- check for better display.L
		tst.w	d0
		beq.s	ceolCR
		;--	roll back display.L to end of previous line
		subq.w	#1,d1
		blt.s	ceolCR			; special case (0,0)
		move.w	d1,cu_DisplayYL(a2)
		add.w	d1,d1
		move.l	cu_CM+cm_DispLineLengths(a2),a0
		move.w	0(a0,d1.w),cu_DisplayXL(a2)
@


36.7
log
@restructure map variables
@
text
@d1 9
a9 43
	TTL    '$Header: clear.asm,v 36.6 89/08/21 12:46:51 kodiak Exp $'
**********************************************************************
*								     *
*			--------------
*   clear.asm		CONSOLE DEVICE	clear areas of the console
*			--------------
*
*   Copyright 1985, 1987 Commodore-Amiga Inc.
*
*   Source Control	$Locker: kodiak $
*
*   $Log:	clear.asm,v $
*   Revision 36.6  89/08/21  12:46:51  kodiak
*   RectFill takes word parameters, no extension to longs necessary
*   
*   Revision 36.5  89/07/10  18:16:59  kodiak
*   fix bug when inverse in ClearRaster (set RastPort in a1)
*   
*   Revision 36.4  89/07/05  15:17:51  kodiak
*   cu_BufferSize is UWORD (was ULONG)
*   
*   Revision 36.3  89/06/28  19:13:39  kodiak
*   better avoidance of cursor spoor
*   
*   Revision 36.2  89/06/28  12:24:21  kodiak
*   rename ClearScreen to ClearEOD
*   add ClearDisplay to support Esc[2J
*   add new ClearScreen that just clears raster for RefreshUnit
*       (part of scroll damage fixing code)
*   
*   Revision 36.1  88/09/19  10:15:24  kodiak
*   add character map and pseudo-clipboard support
*   
*   Revision 36.0  88/09/06  19:51:22  kodiak
*   *** empty log message ***
*   
*   Revision 35.1  87/10/26  12:57:11  kodiak
*   Change rendering strategy to use a single shared device RastPort
*   
*   Revision 35.0  87/10/26  11:11:59  kodiak
*   initial from V34, but w/ stripped log
*
**********************************************************************
d11 1
a11 1
	SECTION		rawinput
d13 1
a13 1
*------ Included Files -----------------------------------------------
a14 1
	INCLUDE		"cddata.i"
d16 1
a16 1
	INCLUDE		"graphics/text.i"
a17 9

*------ Imported Functions -------------------------------------------

	XLVO	SetAPen			; Graphics
	XLVO	RectFill		;


*------ Exported Functions -------------------------------------------

d28 22
d87 16
a102 1
		move.w	cu_CM+cm_DisplayWidth(a2),d1
d104 6
a109 9
	    ;-- clear buffer area
		move.w	cu_YCP(a2),d0
		mulu	d1,d0
		move.w	cu_XCP(a2),d2
		add.w	d2,d0
		sub.w	d2,d1
		subq.w	#1,d1
		move.l	cu_CM+cm_AttrDisplay(a2),a0
		add.w	d0,d0
d111 3
d118 1
a118 1
		dbf	d1,ceolCBLoop
d120 12
a131 1
	    ;-- clear raster area
d133 4
a136 10
		move.w	cu_XCP(a2),d0
		mulu	cu_XRSize(a2),d0
		add.w	cu_XROrigin(a2),d0
		move.w	cu_YCP(a2),d1
		mulu	cu_YRSize(a2),d1
		add.w	cu_YROrigin(a2),d1
		move.l	d1,d3
		add.w	cu_YRSize(a2),d3
		subq.w	#1,d3
		bra.s	cEOLEntry
d147 1
a147 3
		bsr.s	ClearEOL
		move.w	cu_CM+cm_DisplayWidth(a2),d1
		mulu	cu_CM+cm_DisplayHeight(a2),d1
a148 13
	    ;-- clear buffer area
		move.w	cu_YCP(a2),d0
		addq.w	#1,d0
		mulu	cu_CM+cm_DisplayWidth(a2),d0
		sub.w	d0,d1
		move.l	cu_CM+cm_AttrDisplay(a2),a0
		add.l	d0,d0
		add.l	d0,a0
		bra.s	ceodCBDBF
ceodCBLoop:
		clr.w	(a0)+
ceodCBDBF:
		dbf	d1,ceodCBLoop
d150 16
a165 1
	    ;-- clear raster area
d167 2
a168 1
		moveq	#0,d0
d174 4
a177 1
		bra.s	cEODEntry
a198 9
	    ;-- clear buffer area
		move.w	cu_CM+cm_Elements(a2),d0
		move.l	cu_CM+cm_AttrBuffer(a2),a0
		bra.s	cdCBDBF
cdCBLoop:
		clr.w	(a0)+
cdCBDBF:
		dbf	d0,cdCBLoop

d202 5
a206 1
	    ;-- clear raster area
d208 20
a227 1
		moveq	#0,d0
a228 1
		moveq	#0,d1
d230 1
a230 2
cEODEntry:
		moveq	#0,d3
d232 1
a232 2
cEOLEntry:
		moveq	#0,d2
d234 2
a235 1
		bsr.s	ClearRaster
a236 2
		movem.l (a7)+,d2-d3
		rts
a237 1

d262 1
a262 4
	IFNE	RP_JAM2-1
	FAIL	"RP_JAM2 not bit 0, recode"
	ENDC
		btst.b	#0,cd_RastPort+rp_DrawMode(a6)
d264 1
a264 4
	IFNE	RP_INVERSVID-4
	FAIL	"RP_INVERSVID not bit 2, recode"
	ENDC
		btst.b	#2,cd_RastPort+rp_DrawMode(a6)
@


36.6
log
@RectFill takes word parameters, no extension to longs necessary
@
text
@d1 1
a1 1
	TTL    '$Header: clear.asm,v 36.5 89/07/10 18:16:59 kodiak Exp $'
d13 3
d56 2
a57 2
	XREF_GFX	SetAPen
	XREF_GFX	RectFill
d65 2
a66 2
	XDEF	    ClearEOL
	XDEF	    ClearEOD
d68 2
a69 2
	XDEF	    ClearScreen
	XDEF	    ClearRaster
d72 1
a72 1
******* console.device/command/Clear *******************************************
d75 1
a75 1
*	Clear - clear console input buffer
d78 2
a79 2
*	Remove from the input buffer any reports waiting to satisfy
*	read requests.
d81 1
a81 1
*    IO REQUEST
a87 2
*    BUGS
*
d91 2
a92 2
********************************************************************************

d98 1
a98 1
		RTS
d109 1
a109 1
		tst.w	cu_BufferSize(a2)
a112 1
		move.w	cu_BufferWidth(a2),d1
d118 1
a118 1
		move.l	cu_AttrBuffer(a2),a0
d150 2
a151 1
		move.w	cu_BufferSize(a2),d1
d156 1
a156 1
		mulu	cu_BufferWidth(a2),d0
d158 1
a158 1
		move.l	cu_AttrBuffer(a2),a0
d198 2
a199 2
		move.w	cu_BufferSize(a2),d0
		move.l	cu_AttrBuffer(a2),a0
d224 1
a224 1
		RTS
d277 1
a277 1
		RTS
@


36.5
log
@fix bug when inverse in ClearRaster (set RastPort in a1)
@
text
@d1 1
a1 1
	TTL    '$Header: clear.asm,v 36.4 89/07/05 15:17:51 kodiak Exp $'
d13 3
d247 1
a247 1
		movem.l	d0/d1,-(a7)		; save rectangle origin
d267 1
a267 1
		movem.l	(a7)+,d0/d1
a269 4
		ext.l	d0
		ext.l	d1
		ext.l	d2
		ext.l	d3
@


36.4
log
@cu_BufferSize is UWORD (was ULONG)
@
text
@d1 1
a1 1
	TTL    '$Header: clear.asm,v 36.3 89/06/28 19:13:39 kodiak Exp $'
d13 3
d92 2
a93 2
		MOVE.L	IO_UNIT(A1),A0
		FLUSHBUFFER	cu_ReadBuffer(A0)
d104 1
a104 1
		MOVEM.L D2-D3,-(A7)
d126 9
a134 9
		MOVE.W	cu_XCP(A2),D0
		MULU	cu_XRSize(A2),D0
		ADD.W	cu_XROrigin(A2),D0
		MOVE.W	cu_YCP(A2),D1
		MULU	cu_YRSize(A2),D1
		ADD.W	cu_YROrigin(A2),D1
		MOVE.L	D1,D3
		add.w	cu_YRSize(A2),D3
		SUBQ.W	#1,D3
d145 2
a146 2
		MOVEM.L D2-D3,-(A7)
		BSR.S	ClearEOL
d165 3
a167 3
		MOVEQ	#0,D0
		MOVE.W	cu_XROrigin(A2),D0
		MOVE.W	cu_YCP(A2),D1
d169 2
a170 2
		MULU	cu_YRSize(A2),D1
		ADD.W	cu_YROrigin(A2),D1
d192 1
a192 1
		MOVEM.L D2-D3,-(A7)
d207 2
a208 2
		MOVEQ	#0,D0
		MOVE.W	cu_XROrigin(A2),D0
d210 1
a210 1
		move.W	cu_YROrigin(A2),D1
d212 2
a213 2
		MOVEQ	#0,D3
		MOVE.W	cu_YRExtant(A2),D3
d215 3
a217 3
		MOVEQ	#0,D2
		MOVE.W	cu_XRExtant(A2),D2
		BSR.s	ClearRaster
d219 1
a219 1
		MOVEM.L (A7)+,D2-D3
d230 1
a230 1
*			    D0  D1  D2  D3
d239 4
a242 4
		CMP.W	D0,D2
		BLT.S	noClearing
		CMP.W	D1,D3
		BLT.S	noClearing
d244 1
a244 4
		MOVEM.L	D0/D1,-(A7)		; save rectangle origin
		MOVEQ	#0,D0
		CMP.B	#RP_JAM2,cd_RastPort+rp_DrawMode(a6)
		BNE.S	isClear
d246 15
a260 1
		MOVE.B	rp_BgPen(A1),D0
d264 1
a264 1
		MOVEM.L	(A7)+,D0/D1
d267 4
a270 4
		EXT.L	D0
		EXT.L	D1
		EXT.L	D2
		EXT.L	D3
d275 1
a275 1
		MOVE.B	cu_FgPen(a2),cd_RastPort+rp_FgPen(A6)
@


36.3
log
@better avoidance of cursor spoor
@
text
@d1 1
a1 1
	TTL    '$Header: clear.asm,v 36.2 89/06/28 12:24:21 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 3
d102 1
a102 1
		tst.l	cu_BufferSize(a2)
d144 1
a144 1
		move.l	cu_BufferSize(a2),d1
d150 1
a150 1
		sub.l	d0,d1
d191 1
a191 1
		move.l	cu_BufferSize(a2),d0
@


36.2
log
@rename ClearScreen to ClearEOD
add ClearDisplay to support Esc[2J
add new ClearScreen that just clears raster for RefreshUnit
    (part of scroll damage fixing code)
@
text
@d1 1
a1 1
	TTL    '$Header: clear.asm,v 36.1 88/09/19 10:15:24 kodiak Exp $'
d13 6
d196 3
a211 2

		and.b	#~(CUF_CURSBLOCK!CUF_CURSGHOST)&$ff,cu_CursorFlags(a2)
@


36.1
log
@add character map and pseudo-clipboard support
@
text
@d1 1
a1 1
	TTL    '$Header: clear.asm,v 36.0 88/09/06 19:51:22 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker: kodiak $
d13 3
d48 2
a113 1
		lea	cd_RastPort(A6),A1
a119 2
		MOVEQ	#0,D2
		MOVE.W	cu_XRExtant(A2),D2
d123 1
a123 3
		BSR	ClearRaster
		MOVEM.L (A7)+,D2-D3
		RTS
d126 1
a126 1
*------	ClearScreen --------------------------------------------------
d129 1
a129 1
*	ClearScreen - clear from current position to end of RastPort
d132 1
a132 1
ClearScreen:
d136 1
a136 1
		beq.s	csCR
d145 2
a146 2
		bra.s	csCBDBF
csCBLoop:
d148 2
a149 2
csCBDBF:
		dbf	d1,csCBLoop
d152 1
a152 2
csCR:
		lea	cd_RastPort(A6),A1
d159 41
d202 4
a205 3
		MOVEQ	#0,D3
		MOVE.W	cu_YRExtant(A2),D3
		BSR	ClearRaster
d239 1
a239 1
		clr.L	cd_RastPort+rp_AreaPtrn(A6)
a250 1
		MOVE.L	cu_AreaPtrn(a2),cd_RastPort+rp_AreaPtrn(A6)
@


36.0
log
@*** empty log message ***
@
text
@d1 1
a1 1
	TTL    '$Header: clear.asm,v 35.1 87/10/26 12:57:11 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 3
d88 21
d110 6
a115 5
		MOVE.W	rp_cp_x(A1),D0
		EXT.L	D0
		MOVE.W	rp_cp_y(A1),D1
		SUB.W	rp_TxBaseline(A1),D1
		EXT.L	D1
d119 1
a119 2
		MOVE.L	rp_Font(A1),A0
		ADD.W	tf_YSize(A0),D3
d135 18
d156 4
a159 5
		MOVE.W	rp_cp_y(A1),D1
		SUB.W	rp_TxBaseline(A1),D1
		MOVE.L	rp_Font(A1),A0
		ADD.W	tf_YSize(A0),D1
		EXT.L	D1
d198 1
@
