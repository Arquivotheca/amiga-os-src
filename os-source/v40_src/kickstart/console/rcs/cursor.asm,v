head     36.29;
branch   ;
access   ;
symbols  V39_4:36.24 V37_157:36.24 V37_149:36.23 V37_136:36.23 V37_133:36.23 V37_110:36.23 V37_98:36.23 V37_85:36.23 V37_63:36.23 V37_36:36.23 V37_15:36.22 V37_10:36.22 V37_7:36.22 V37_2:36.22 V36_558:36.22 V36_554:36.22 V36_552:36.22 V36_549:36.22 V36_548:36.22 V36_547:36.22 V36_546:36.22 V36_545:36.22 V36_544:36.22 V36_543:36.22 V36_542:36.22 V36_540:36.22 V36_539:36.22 V36_538:36.22 V36_537:36.22 V36_536:36.22 V36_529:36.19 V36_527:36.19 V36_525:36.19 V36_524:36.19 V36_523:36.19 V36_522:36.18 V36_521:36.17 V36_520:36.17 V36_519:36.17 V36_518:36.17 V36_495:36.17 V36_491:36.17 V36_486:36.17 V36_482:36.17 V36_476:36.17 V36_471:36.17 V36_465:36.17 V36_463:36.17 V36_461:36.17 V36_460:36.17 V36_453:36.17 V36_447:36.17 V36_442:36.17 V36_429:36.17 V36_423:36.15 V36_413:36.15 V36_394:36.13 V36_387:36.12 V36_382:36.12 V36_381:36.12 V36_379:36.11 V36_373:36.11 V36_367:36.11 V36_361:36.11 V36_359:36.11 V36_357:36.11 V36_353:36.11 V36_346:36.11 V36_343:36.11 V36_338:36.11 V36_332:36.11 V36_327:36.10 V36_321:36.10 V36_319:36.10 V36_318:36.10 V36_316:36.10 V36_313:36.10 V36_311:36.10 V36_310:36.10 V36_300:36.10 V36_299:36.10 V36_297:36.10 V36_295:36.10 V36_278:36.10 V36_274:36.10 V36_221:36.9 V36_205:36.9 V36_171:36.8 V36_167:36.8 V36_165:36.8 V36_153:36.7 V36_146:36.7 V36_140:36.6 V36_129:36.4 V36_113:36.3 V36_56:36.2 V36_53:36.2 V36_51:36.1 V36_45:36.1 L36_42:36.1;
locks    ; strict;
comment  @*   @;


36.29
date     92.06.16.10.47.43;  author darren;  state Exp;
branches ;
next     36.28;

36.28
date     92.03.23.14.26.38;  author darren;  state Exp;
branches ;
next     36.27;

36.27
date     92.03.23.13.17.45;  author darren;  state Exp;
branches ;
next     36.26;

36.26
date     92.03.23.12.43.53;  author darren;  state Exp;
branches ;
next     36.25;

36.25
date     92.03.19.12.46.08;  author darren;  state Exp;
branches ;
next     36.24;

36.24
date     91.05.22.13.47.22;  author darren;  state Exp;
branches ;
next     36.23;

36.23
date     91.02.06.12.20.33;  author darren;  state Exp;
branches ;
next     36.22;

36.22
date     90.11.02.08.13.13;  author darren;  state Exp;
branches ;
next     36.21;

36.21
date     90.11.01.15.16.24;  author darren;  state Exp;
branches ;
next     36.20;

36.20
date     90.11.01.11.19.56;  author darren;  state Exp;
branches ;
next     36.19;

36.19
date     90.09.13.18.13.22;  author darren;  state Exp;
branches ;
next     36.18;

36.18
date     90.08.13.13.59.33;  author darren;  state Exp;
branches ;
next     36.17;

36.17
date     90.04.17.15.53.17;  author kodiak;  state Exp;
branches ;
next     36.16;

36.16
date     90.04.17.14.55.34;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     90.04.16.18.22.52;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     90.04.13.13.32.26;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     90.04.12.17.06.03;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     90.04.02.10.47.14;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     90.01.30.15.55.49;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     89.12.02.11.36.34;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     89.11.03.12.24.39;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     89.08.21.12.51.04;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     89.07.06.14.26.53;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     89.07.05.15.52.59;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.07.05.15.16.41;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     89.06.28.19.14.16;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     89.06.28.12.28.40;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     89.02.20.13.11.09;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     88.09.19.10.15.30;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     88.09.06.19.51.27;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


36.29
log
@Remove kludge which checks for drawing over the cursor; needed
ROM space for V39
@
text
@**
**	$Id: cursor.asm,v 36.28 92/03/23 14:26:38 darren Exp Locker: darren $
**
**      enable and render console cursor
**
**      (C) Copyright 1985,1987,1989,1990 Commodore-Amiga, Inc.
**          All Rights Reserved
**
	SECTION	console

**	Includes

	INCLUDE	"cddata.i"

	INCLUDE	"intuition/intuition.i"
	INCLUDE	"intuition/intuitionbase.i"

	INCLUDE	"debug.i"

**	Exports

	XDEF	CursOn
	XDEF	CursOff
	XDEF	CursRefresh
	XDEF	CursRender
	XDEF	CursDisable
	XDEF	CursEnable
	XDEF	CursUpdate
	XDEF	CursUp
	XDEF	CursDown
	XDEF	CursLeft
	XDEF	CursRight

	XDEF	IfGhostCursor

**	Imports

	XLVO	ReadPixel		; Graphics
	XLVO	RectFill		;
	XLVO	SetDrMd			;
	XLVO	SetAPen			;

	XLVO	InstallClipRegion	; Layers

	XREF	ScrollYDisplay


**	Assumptions

*------ IfGhostCursor ----------------------------------------------
*
*   NAME
*	IfGhostCursor - check if ghosting is allowed for this window
*			we can't properly ghost simple/non mapped type
*
*   SYNOPSIS
*	zero flag (T/F) = IfGhostCursor(consoleUnit)
*	                                  a2
*	a0 - used as window ptr
*	d0 - used
*---------------------------------------------------------------------
IfGhostCursor:
		tst.l	cu_CM+cm_AllocSize(a2)	;buffered?
		bne.s	IfGhostExit
		
		move.l	cu_Window(a2),a0
		move.l	wd_Flags(a0),d0
		andi.l	#REFRESHBITS,d0
		cmpi.l	#SIMPLE_REFRESH,d0
				
IfGhostExit:	rts



*------ CursOn ------------------------------------------------------
*
*   NAME
*	CursOn - turn on text cursor
*
*   SYNOPSIS
*	CursOn(consoleUnit)
*	      a2
*
*---------------------------------------------------------------------

crPatterns:
		dc.l	$00000000	; off inactive unselected
		dc.l	$5555aaaa	; on  inactive unselected
		dc.l	$00000000	; off inactive selected
		dc.l	$5555aaaa	; on  inactive selected
		dc.l	$00000000	; off active   unselected
		dc.l	$ffffffff	; on  active   unselected
		dc.l	$00000000	; off active   selected
		dc.l	$0000ffff	; on  active   selected

CursRefresh:
		clr.l	cu_CursorPattern(a2)
		bra.s	CursRender

CursOn:
		bset	#CUB_CURSON,cu_CursorFlags(a2)

CursRender:
		;-- get cursor flags, ensuring CUF_CURSACTIVE set if active
		
		;-- special case for SIMPLE refresh, no map
		;-- always active cursor in this rare case - can't use EOR
		;-- drawing, and undrawing.

		bsr.s	IfGhostCursor
		beq.s	SetActive

		moveq	#0,d1

		btst	#CUB_ISACTIVE,cu_States(a2)
		beq.s	crGotActive

SetActive:
		moveq	#CUF_CURSACTIVE,d1
crGotActive:
		or.b	cu_CursorFlags(a2),d1

		;-- check for disabled cursor
crCheckNest:
		tst.b	cu_CDNestCnt(a2)
		bmi.s	crNotDisabled
		bclr	#CUB_CURSON,d1
crNotDisabled:

		;-- get desired pattern & xor needed to create it

		move.l	crPatterns(pc,d1.w),d0
		move.l	cu_CursorPattern(a2),d1
		move.l	d0,cu_CursorPattern(a2)
		eor.l	d0,d1

		beq.s	crDone		; zero xor means no change needed

		;--	ensure window big enough for any rendering
		btst	#CUB_TOOSMALL,cu_Flags(a2)
		bne.s	crtoosmall

		;-- render cursor
		movem.l	d2-d6,-(a7)

		;both .s!!!
		bsr.s	crGetCursRectangle
		bgt.s	crRectangleDone

		move.b	cd_RastPort+rp_DrawMode(a6),d6
		move.l	cd_AreaPtrn(a6),a0
		move.l	d1,(a0)
		addq.l	#1,d1
		beq.s	crSolid
		move.l	a0,d1

crSolid:
		move.l	d1,cd_RastPort+rp_AreaPtrn(a6)

		moveq	#RP_COMPLEMENT,d0
		lea	cd_RastPort(a6),a1
		LINKGFX	SetDrMd

		move.l	d4,d0
		move.l	d5,d1
		lea	cd_RastPort(a6),a1
		move.b	cu_CursorMask(a2),rp_Mask(a1)
		LINKGFX	RectFill

		lea	cd_RastPort(a6),a1
		move.b	cu_Mask(a2),rp_Mask(a1)
		moveq	#0,d0
		move.b	d6,d0
		LINKGFX	SetDrMd

crRectangleDone:
		movem.l	(a7)+,d2-d6

crDone:
		rts

crtoosmall:
		clr.l	cu_CursorPattern(a2)	;reset cursor pattern

		rts


;------ crGetCursRectangle
;
;   RESULT
;   d2,d3	rectangle max X Y
;   d4,d5	rectangle min X Y
;   ccr		"gt" indicates empty rectangle
;
crGetCursRectangle:
		move.w	cu_XCCP(a2),d4
		mulu	cu_XRSize(a2),d4
		add.w	cu_XROrigin(a2),d4
		move.w	d4,d2
		add.w	cu_XRSize(a2),d2
		subq.w	#1,d2
		cmp.w	cu_XRExtant(a2),d2
		ble.s	crgcrXOK
		move.w	cu_XRExtant(a2),d2
		cmp.w	d2,d4
		bgt.s	crgcrDone
crgcrXOK:
		move.w	cu_YCCP(a2),d5
		mulu	cu_YRSize(a2),d5
		add.w	cu_YROrigin(a2),d5
		move.w	d5,d3
		add.w	cu_YRSize(a2),d3
		subq.w	#1,d3
		cmp.w	cu_YRExtant(a2),d3
		ble.s	crgcrDone
		move.w	cu_YRExtant(a2),d3
		cmp.w	d3,d5
crgcrDone:
		rts


*------ CursOff -----------------------------------------------------
*
*   NAME
*	CursOff - turn off text cursor
*
*   SYNOPSIS
*	CursOff(consoleUnit)
*		a2
*
*---------------------------------------------------------------------
CursOff:
		bclr	#CUB_CURSON,cu_CursorFlags(a2)
		bra	CursRender


*------ CursDisable -------------------------------------------------
*
*   NAME
*	CursDisable - turn off text cursor temporarily
*
*   SYNOPSIS
*	CursDisable(consoleUnit)
*		    a2
*
*---------------------------------------------------------------------
CursDisable:
		addq.b	#1,cu_CDNestCnt(a2)
		bgt.s	cdDeferred

cdSaveRegsRender:
		movem.l d0-d1/a0-a1,-(sp)
		bsr	CursRender
		movem.l	(sp)+,d0-d1/a0-a1
cdDeferred:
		rts


*------ CursEnable --------------------------------------------------
*
*   NAME
*	CursEnable - cancel the effect of a CursDisable
*
*   SYNOPSIS
*	CursEnable(consoleUnit)
*		   a2
*
*---------------------------------------------------------------------
CursEnable:
		subq.b	#1,cu_CDNestCnt(a2)
		bpl.s	cdDeferred
		bra.s	cdSaveRegsRender


*------ CursUpdate --------------------------------------------------
*
*   NAME
*	CursUpdate - update cursor at new position
*
*   SYNOPSIS
*	CursUpdate(consoleUnit)
*		   a2
*
*---------------------------------------------------------------------
CursUpdate:
		moveq	#0,d0
		move.l	cu_XCP(a2),d1
		cmp.l	cu_XCCP(a2),d1
		beq.s	cupNoChange

		and.b	#(~(CUF_IMPLICITNL!CUF_TABBED))&$ff,cu_Flags(a2)
		bsr.s	CursDisable
		move.l	d1,cu_XCCP(a2)
		bsr.s	CursEnable
cupNoChange:
		rts


*------ CursUp ------------------------------------------------------
*
*   NAME
*	CursUp - cursor position up
*
*   SYNOPSIS
*	CursUp(consoleUnit)
*	       a2
*
*---------------------------------------------------------------------
CursUp:
		move.w	cu_YCP(a2),d1
		sub.w	d0,d1
		bcs.s	cUpWrap
		move.w	d1,cu_YCP(a2)
		bra.s	CursUpdate

cUpWrap:
		clr.w	cu_YCP(a2)
		btst	#(PMB_ASM&07),cu_Modes+(PMB_ASM/8)(a2)
		beq.s	cVertBound
	;-- scroll for the remaining
scrollVert:
		move.w	d1,d0
		bsr	ScrollYDisplay
cVertBound:
		bra.s	CursUpdate


*------ CursDown ----------------------------------------------------
*
*   NAME
*	CursDown - cursor position down
*
*   SYNOPSIS
*	CursDown(consoleUnit)
*		 a2
*
*---------------------------------------------------------------------
CursDown:
		move.w	cu_YCP(a2),d1
		add.w	d0,d1
		cmp.w	cu_YMax(a2),d1
		bhi.s	cDownWrap
		move.w	d1,cu_YCP(a2)
		bra.s	CursUpdate

cDownWrap:
	;-- scroll for the remaining
		move.w	cu_YMax(a2),cu_YCP(a2)
		btst	#(PMB_ASM&07),cu_Modes+(PMB_ASM/8)(a2)
		beq.s	cVertBound
		sub.w	cu_YMax(a2),d1
		bra.s	scrollVert


*------ CursRight ---------------------------------------------------
*
*   NAME
*	CursRight - cursor position right
*
*   SYNOPSIS
*	CursRight(consoleUnit)
*		  a2
*
*---------------------------------------------------------------------
CursRight:
		add.w	cu_XCP(a2),d0
		cmp.w	cu_XMax(a2),d0
		bhi.s	cRightWrap
		move.w	d0,cu_XCP(a2)
cRightBound:
		bra.s	CursUpdate

cRightWrap:
		btst	#(PMB_AWM&07),cu_Modes+(PMB_AWM/8)(a2)
		bne.s	cRightAutoWrap
		move.w	cu_XMax(a2),cu_XCP(a2)
		bra.s	cRightBound
cRightAutoWrap:
	;-- wrap for the remaining
		clr.w	cu_XCP(a2)
		sub.w	cu_XMax(a2),d0
		subq	#1,d0
		move.w	d0,-(a7)
		moveq	#1,d0
		bsr.s	CursDown
		move.w	(a7)+,d0
		bne.s	CursRight
		bset	#CUB_IMPLICITNL,cu_Flags(a2)
		rts


*------ CursLeft ----------------------------------------------------
*
*   NAME
*	CursLeft - cursor position left
*
*   SYNOPSIS
*	CursLeft(consoleUnit)
*		 a2
*
*---------------------------------------------------------------------
CursLeft:
		move.w	cu_XCP(a2),d1
		sub.w	d0,d1
		bcs.s	cLeftWrap
		move.w	d1,cu_XCP(a2)
cLeftBound:
		bra	CursUpdate

cLeftWrap:
		btst	#(PMB_AWM&07),cu_Modes+(PMB_AWM/8)(a2)
		bne.s	cLeftAutoWrap
		clr.w	cu_XCP(a2)
		bra.s	cLeftBound
cLeftAutoWrap:
	;-- wrap for the remaining
		move.w	cu_XMax(a2),cu_XCP(a2)
		neg.w	d1
		subq	#1,d1
		move.w	d1,-(a7)
		moveq	#1,d0
		bsr	CursUp
		move.w	(a7)+,d0
		bra.s	CursLeft

	END
@


36.28
log
@Mask expected source pen # with CursorMask in code which checks
for munged cursor
@
text
@d2 1
a2 1
**	$Id: cursor.asm,v 36.27 92/03/23 13:17:45 darren Exp Locker: darren $
a49 5
	IFNE	CUB_CURSQDRAW-7
	FAIL	"CU CURSQDRAW not msb in byte"
	ENDC


d86 10
a121 111
		bpl	crCheckNest

		;-- determine if cursor drawing is disallowed
		btst	#CUB_CURSNDRAW,d1
		bne	crDone

		;-- determine if drawing is permissable
		bclr	#CUB_CURSQDRAW,d1
		btst	#CUB_CURSON,d1
		beq	crTempActive	; no way to tell if no cursor
		;--	1. has the cursor moved visibly?
		tst.l	cu_XCCP(a2)
		beq.s	crReadRect
		move.b	d1,d0
		bclr	#CUB_CURSACTIVE,d0
		move.b	d0,cu_CursorFlags(a2)
		bra	crCheckNest
		;--	2. is the cursor still rendered as expected?
crReadRect:
		movem.l	d1-d7,-(a7)
		bsr	crGetCursRectangle
		bgt	crPTempActive	; no way to tell if no cursor

		;--	read rastport and compare w/ expected cursor pattern
		sub.w	d4,d2		; width-1
		move.w	d2,d6		; save width-1
		swap	d6
		move.w	d4,d6		; save x origin
		sub.w	d5,d3		; height-1
crRRLoop:
		move.w	d4,d0
		move.w	d5,d1
		lea	cd_RastPort(a6),a1
		LINKGFX	ReadPixel
		tst.l	d0
		BMI_S	crRRNext	; cannot read pixel (obscured?)

		;--	match w/ position in pattern
		move.b	cu_BgColor(a2),d1
		btst	#0,d4
		bne.s	crRRXO
		btst	#0,d5
		bne.s	crRRXEYO
		btst	#1,cu_CursorPattern(a2)
		bra.s	crRRFgBg
crRRXEYO:
		btst	#0,cu_CursorPattern(a2)
		bra.s	crRRFgBg
crRRDepths:
		dc.b	$00,$01,$03,$07,$0f,$1f,$3f,$7f,$ff,0
crRRXO:
		btst	#0,d5
		bne.s	crRRXOYO
		btst	#1,cu_CursorPattern+2(a2)
		bra.s	crRRFgBg
crRRXOYO:
		btst	#0,cu_CursorPattern+2(a2)
crRRFgBg:
		beq.s	crRRBg
		not.b	d1
crRRBg:
;		;--	don't need to check if selected because this code
;		;--	is only executed if the cursor never moves, and no
;		;--	selection is possible
;		btst	#CUB_CURSSELECT,cu_CursorFlags(a2)
;		beq.s	crRRMask
;		not.b	d1
;crRRMask:
		moveq	#0,d7
		move.l	cd_RastPort+rp_BitMap(a6),a0
		move.b	bm_Depth(a0),d7
		move.b	crRRDepths(pc,d7.w),d7
	
	;;
	;; Test is meaningless since its going to be $FF, or $00
	;; for old style concealed mode code (no longer works the same)
	;;
	;;	and.b	cd_RastPort+rp_Mask(a6),d7

		and.b	d7,d0
		and.b	d7,d1

	;;
	;; Mask expected color with CursorMask to obtain true color
	;; drawn at this position
	;;
		and.b	cu_CursorMask(a2),d1

		cmp.b	d0,d1
		bne.s	crPNeverDraw
crRRNext:
		addq.w	#1,d4
		dbf	d2,crRRLoop
		addq.w	#1,d5
		move.w	d6,d4		; recover x origin
		swap	d6
		move.w	d6,d2		; recover width-1
		swap	d6
		dbf	d3,crRRLoop

		;--	temporarily OK to ghost
		movem.l	(a7)+,d1-d7
		bra.s	crCheckNest

crPNeverDraw:
		movem.l	(a7)+,d1-d7
		bset	#CUB_CURSNDRAW,cu_CursorFlags(a2)
		bra	crDone

crPTempActive:
		movem.l	(a7)+,d1-d7
a122 15
crTempActive:
		or.b	#CUF_CURSACTIVE,d1
		bra.s	crCheckNest

crPatterns:
		dc.l	$00000000	; off inactive unselected
		dc.l	$5555aaaa	; on  inactive unselected
		dc.l	$00000000	; off inactive selected
		dc.l	$5555aaaa	; on  inactive selected
		dc.l	$00000000	; off active   unselected
		dc.l	$ffffffff	; on  active   unselected
		dc.l	$00000000	; off active   selected
		dc.l	$0000ffff	; on  active   selected


a128 5
		;-- Clear this for the case of QUESTIONABLE draw
		;-- flag cleared, but NEVER draw flag was set if
		;-- the window was resized before any text was
		;-- written.  Yields bogus offsets into array,
		;-- and the NEVER draw flag isn't really true.
a129 2
		bclr	#CUB_CURSNDRAW,d1

d187 1
a290 2
		bclr	#CUB_CURSQDRAW,cu_CursorFlags(a2)
		
@


36.27
log
@Use cursor mask to determine if the cursor has been munged - this
is the horrible ReadPixel kludge which checks for folks that draw
over the cursor
@
text
@d2 1
a2 1
**	$Id: cursor.asm,v 36.26 92/03/23 12:43:53 darren Exp Locker: darren $
d191 2
a192 1
	;; Use CursorMask for testing if cursor munged
a195 2
		and.b	cu_CursorMask(a2),d7

d198 7
@


36.26
log
@Use a variable for cursor mask, so I can set it to $FF for
compatability with existing screens.
@
text
@d2 1
a2 1
**	$Id: cursor.asm,v 36.25 92/03/19 12:46:08 darren Exp Locker: darren $
d152 1
a152 1
		bmi.s	crRRNext	; cannot read pixel (obscured?)
d189 8
a196 1
		and.b	cd_RastPort+rp_Mask(a6),d7
@


36.25
log
@Cursor is now drawn with a mask of 2 planes regardless of number
of screen planes.
@
text
@d2 1
a2 1
**	$Id: cursor.asm,v 36.24 91/05/22 13:47:22 darren Exp Locker: darren $
d282 1
a282 1
		move.b	#3,rp_Mask(a1)		; always 2 planes
@


36.24
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: cursor.asm,v 36.23 91/02/06 12:20:33 darren Exp Locker: darren $
d282 1
d286 1
@


36.23
log
@Bug fix - if window resized before any text drawn, QDRAW flag is set,
and NDRAW flag gets set (bitmap imagery changed, so NEVER draw flag set).
Then the QDRAW flag gets cleared when text is written, and now both
NDRAW & QDRAW are set - yielding a bogus offset into array of patterns.
Fixed - clear NDRAW flag if QDRAW flag cleared.
@
text
@d2 1
a2 1
**	$Id: cursor.asm,v 36.22 90/11/02 08:13:13 darren Exp Locker: darren $
@


36.22
log
@short branch optimizations
@
text
@d2 1
a2 1
**	$Id: cursor.asm,v 36.21 90/11/01 15:16:24 darren Exp Locker: darren $
d237 8
d246 1
@


36.21
log
@Fix for SIMPLE REFRESH windows without a map - cursor
ghosting disabled in this rare case since I can't toggle
ghosted imagery on/off if damage occurs to the window.
@
text
@d2 1
a2 1
**	$Id: cursor.asm,v 36.20 90/11/01 11:19:56 darren Exp Locker: darren $
d243 1
a243 1
		beq	crDone		; zero xor means no change needed
d247 1
a247 1
		bne	crtoosmall
@


36.20
log
@New code for handling of cursor state tracking.
@
text
@d2 1
a2 1
**	$Id: cursor.asm,v 36.19 90/09/13 18:13:22 darren Exp Locker: darren $
d34 1
d55 25
d100 7
d113 1
@


36.19
log
@Code changes - needed for special case
if window is opened too small to render
in.
@
text
@d2 1
a2 1
**	$Id: cursor.asm,v 36.19 90/09/13 17:07:57 darren Exp $
d16 1
d74 1
d76 4
a79 2
		cmp.l	cd_Active(a6),a2
		bne.s	crGotActive
d208 1
d218 1
d228 1
@


36.18
log
@Fix bug - if cursor position is ever
updated, then questionable drawing
is turned off.
@
text
@d2 1
a2 1
**	$Id: cursor.asm,v 36.17 90/04/17 15:53:17 kodiak Exp $
d17 1
a20 1
	XDEF	CursInit
a52 17
*------ CursInit ----------------------------------------------------
*
*   NAME
*	CursInit - initialize text cursor variables
*
*   SYNOPSIS
*	CursInit(consoleUnit)
*		 a2
*
*---------------------------------------------------------------------
CursInit:
		move.b	#CUF_CURSON!CUF_CURSQDRAW,cu_CursorFlags(a2)	; on
		clr.l	cu_CursorPattern(a2)		; no display
		clr.b	cu_CDNestCnt(a2)		; disabled 1 deep
		rts


d208 1
a208 1
		bne	crDone
d245 4
@


36.17
log
@eliminate unused XLVOs
@
text
@d2 1
a2 1
**	$Id: cursor.asm,v 36.16 90/04/17 14:55:34 kodiak Exp Locker: kodiak $
d6 1
a6 1
**      (C) Copyright 1985,1987,1989 Commodore-Amiga, Inc.
d365 3
@


36.16
log
@fix resize of wrapped tabs
@
text
@d2 1
a2 1
**	$Id: cursor.asm,v 36.15 90/04/16 18:22:52 kodiak Exp Locker: kodiak $
a34 3

	XLVO	AllocMem		; Exec
	XLVO	FreeMem			;
@


36.15
log
@sniff cursor ghosting compatibility problems
@
text
@d2 1
a2 1
**	$Id: cursor.asm,v 36.14 90/04/13 13:32:26 kodiak Exp Locker: kodiak $
d368 1
a368 1
		bclr	#CUB_IMPLICITNL,cu_Flags(a2)	; clear IMPLICITNL
@


36.14
log
@use Id instead of Header for 4.x rcs
@
text
@d2 1
a2 1
**	$Id$
d39 2
a40 1
	XLVO	RectFill		; Graphics
d49 7
d67 2
a68 1
		move.b	#CUF_CURSON,cu_CursorFlags(a2)	; on, no display
a82 17
CursPatternTable:
		dc.l	$00000000	; off, unblocked, unghosted, inactive
		dc.l	$aaaa5555	; on, unblocked, unghosted, inactive
		dc.l	$ffffffff	; off, blocked, unghosted, inactive
		dc.l	$5555aaaa	; on, blocked, unghosted, inactive
		dc.l	$aaaa5555	; off, unblocked, ghosted, inactive
		dc.l	$00000000	; on, unblocked, ghosted, inactive
		dc.l	0		; off, blocked, ghosted, inactive
		dc.l	0		; on, blocked, ghosted, inactive
		dc.l	$00000000	; off, unblocked, unghosted, active
		dc.l	$ffffffff	; on, unblocked, unghosted, active
		dc.l	$ffffffff	; off, blocked, unghosted, active
		dc.l	$00000000	; on, blocked, unghosted, active
		dc.l	$aaaa5555	; off, unblocked, ghosted, active
		dc.l	$5555aaaa	; on, unblocked, ghosted, active
;		dc.l	0		; off, blocked, ghosted, active
;		dc.l	0		; on, blocked, ghosted, active
d84 3
a86 17
CursFlagsTable:
		dc.b	$00		; off, unblocked, unghosted, inactive
		dc.b	$04		; on, unblocked, unghosted, inactive
		dc.b	$02		; off, blocked, unghosted, inactive
		dc.b	$06		; on, blocked, unghosted, inactive
		dc.b	$04		; off, unblocked, ghosted, inactive
		dc.b	$00		; on, unblocked, ghosted, inactive
		dc.b	0		; off, blocked, ghosted, inactive
		dc.b	0		; on, blocked, ghosted, inactive
		dc.b	$00		; off, unblocked, unghosted, active
		dc.b	$02		; on, unblocked, unghosted, active
		dc.b	$02		; off, blocked, unghosted, active
		dc.b	$00		; on, blocked, unghosted, active
		dc.b	$04		; off, unblocked, ghosted, active
		dc.b	$06		; on, unblocked, ghosted, active
;		dc.b	0		; off, blocked, ghosted, active
;		dc.b	0		; on, blocked, ghosted, active
a87 1

d92 1
d99 116
d219 8
a228 4
		move.b	CursFlagsTable(pc,d1.w),d0
		lsl.w	#2,d1
		move.l	CursPatternTable(pc,d1.w),d1
		beq	crDone
d230 2
a231 1
		eor.b	d0,cu_CursorFlags(a2)
d233 2
a234 1
		move.w	d2,-(a7)
d236 1
a236 1
		move.b	cd_RastPort+rp_DrawMode(a6),d2
d249 2
a251 21
		movem.l	d2/d3,-(a7)
		move.w	cu_XCCP(a2),d0
		cmp.w	cu_XMax(a2),d0
		ble.s	crXBounded
		bsr.s	crInstallClipRegion
crXBounded:
		mulu	cu_XRSize(a2),d0
		add.w	cu_XROrigin(a2),d0
		move.w	cu_YCCP(a2),d1
		cmp.w	cu_YMax(a2),d1
		ble.s	crYBounded
		bsr.s	crInstallClipRegion
crYBounded:
		mulu	cu_YRSize(a2),d1
		add.w	cu_YROrigin(a2),d1
		move.w	d0,d2
		add.w	cu_XRSize(a2),d2
		subq.w	#1,d2
		move.w	d1,d3
		add.w	cu_YRSize(a2),d3
		subq.w	#1,d3
a252 1
		movem.l	(a7)+,d2/d3
d256 1
a256 1
		move.b	d2,d0
d259 2
a260 1
		move.w	(a7)+,d2
d266 31
a296 13
crInstallClipRegion:
		;--	    check if already installed
		bset.b	#CDB_CLIPINSTALLED,cd_Flags(a6)
		bne.s	cricrRts

		movem.l	d0-d1/a0-a1,-(a7)
		move.l	cd_RastPort+rp_Layer(a6),a0
		move.l	cu_ClipRegion(a2),a1
		LINKLAY	InstallClipRegion
		move.l	d0,cd_PrevClipRegion(a6)
		movem.l	(a7)+,d0-d1/a0-a1

cricrRts:
a297 22



CursRefresh:
		tst.b	cu_CDNestCnt(a2)
		bpl.s	crDone
		moveq	#0,d1
		move.b	cu_CursorFlags(a2),d0
		bclr	#CUB_CURSBLOCK,d0
		bne.s	crBlock
		bclr	#CUB_CURSGHOST,d0
		beq.s	crRender
		;--	ghosted
		moveq	#CUF_CURSON,d1
crRender:
		move.b	d0,cu_CursorFlags(a2)
		bra	crNotDisabled

crBlock:
		moveq	#CUF_CURSACTIVE!CUF_CURSON,d1
		bra.s	crRender

@


36.13
log
@bound origin & window size, and move TOOSMALL to just skip graphics rendering
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/cursor.asm,v 36.12 90/04/02 10:47:14 kodiak Exp Locker: kodiak $
@


36.12
log
@for 4.x rcs
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/cursor.asm,v 36.11 90/01/30 15:55:49 kodiak Exp Locker: kodiak $
d125 2
@


36.11
log
@fix B6369: Console cursor removal corrupts window border
@
text
@d2 1
a2 1
**	$Header: cursor.asm,v 36.10 89/12/02 11:36:34 kodiak Exp $
@


36.10
log
@checkpoint after line buffer coding completed,
and just after start of line length coding
@
text
@d2 1
a2 1
**	$Header$
d43 2
d150 4
d157 4
d182 15
@


36.9
log
@coalesce XREF_XXX into XLVO
@
text
@d1 9
a9 48
	TTL    '$Header: cursor.asm,v 36.8 89/08/21 12:51:04 kodiak Exp $'
**********************************************************************
*
*			--------------
*   cursor.asm		CONSOLE DEVICE	enable and render console cursor
*			--------------
*
*   Copyright 1985, 1987 Commodore-Amiga Inc.
*
*   Source Control	$Locker: kodiak $
*
*   $Log:	cursor.asm,v $
*   Revision 36.8  89/08/21  12:51:04  kodiak
*   RectFill takes word parameters, working w/ longs not necessary
*   (also lowerasm.sed)
*   
*   Revision 36.7  89/07/06  14:26:53  kodiak
*   remove unused ScrollRaster XREF_GFX
*   
*   Revision 36.6  89/07/05  15:52:59  kodiak
*   delete CursClear (not needed)
*   
*   Revision 36.5  89/07/05  15:16:41  kodiak
*   move ScrollYText out to scroll.asm (where it's called ScrollYDisplay)
*   
*   Revision 36.4  89/06/28  19:14:16  kodiak
*   better avoidance of cursor spoor
*   
*   Revision 36.3  89/06/28  12:28:40  kodiak
*   add support for cursor ghosting in inactive windows
*   usurp use of rp_AreaPtrn and rp_AreaPtSz from users of ConUnit structure
*   
*   Revision 36.2  89/02/20  13:11:09  kodiak
*   add CursClear function
*   
*   Revision 36.1  88/09/19  10:15:30  kodiak
*   add character map and pseudo-clipboard support
*   
*   Revision 36.0  88/09/06  19:51:27  kodiak
*   *** empty log message ***
*   
*   Revision 35.1  87/10/26  12:57:20  kodiak
*   Change rendering strategy to use a single shared device RastPort
*   
*   Revision 35.0  87/10/26  11:12:12  kodiak
*   initial from V34, but w/ stripped log
*
**********************************************************************
d11 1
a11 1
	SECTION		rawinput
d13 1
a13 1
*------ Included Files -----------------------------------------------
d15 1
a15 2
	INCLUDE		"cddata.i"
	INCLUDE		"intuition/intuition.i"
d18 1
a18 1
*------ Imported Names -----------------------------------------------
a19 14
*------ Imported Functions -------------------------------------------

	XLVO	AllocMem		; Exec
	XLVO	FreeMem			;

	XLVO	RectFill		; Graphics
	XLVO	SetDrMd			;
	XLVO	SetAPen			;

	XREF	ScrollYDisplay


*------ Exported Functions -------------------------------------------

d34 12
d293 1
a293 1
*	;-- scroll for the remaining
d320 1
a320 1
*	;-- scroll for the remaining
d352 1
a352 1
*	;-- wrap for the remaining
d389 1
a389 1
*	;-- wrap for the remaining
@


36.8
log
@RectFill takes word parameters, working w/ longs not necessary
(also lowerasm.sed)
@
text
@d1 1
a1 1
	TTL    '$Header: cursor.asm,v 36.7 89/07/06 14:26:53 kodiak Exp $'
d13 4
d62 2
a63 2
	XREF_EXE	AllocMem
	XREF_EXE	FreeMem
d65 3
a67 3
	XREF_GFX	RectFill
	XREF_GFX	SetDrMd
	XREF_GFX	SetAPen
@


36.7
log
@remove unused ScrollRaster XREF_GFX
@
text
@d1 1
a1 1
	TTL    '$Header: cursor.asm,v 36.6 89/07/05 15:52:59 kodiak Exp $'
d13 3
d91 1
a91 1
*		 A2
d107 1
a107 1
*	      A2
d170 1
a170 1
		MOVE.B	cd_RastPort+rp_DrawMode(A6),d2
d179 2
a180 2
		MOVEQ	#RP_COMPLEMENT,D0
		lea	cd_RastPort(A6),A1
d183 14
a196 14
		lea	cd_RastPort(A6),A1
		MOVEM.L	D2/D3,-(A7)
		MOVE.W	cu_XCCP(A2),D0
		MULU	cu_XRSize(A2),D0
		ADD.W	cu_XROrigin(A2),D0
		MOVE.W	cu_YCCP(A2),D1
		MULU	cu_YRSize(A2),D1
		ADD.W	cu_YROrigin(A2),D1
		MOVE.L	D0,D2
		ADD.W	cu_XRSize(A2),D2
		SUBQ.W	#1,D2
		MOVE.L	D1,D3
		ADD.W	cu_YRSize(A2),D3
		SUBQ.W	#1,D3
d198 1
a198 1
		MOVEM.L	(A7)+,D2/D3
d200 3
a202 3
		lea	cd_RastPort(A6),A1
		MOVEQ	#0,D0
		MOVE.B	d2,D0
d241 1
a241 1
*		A2
d256 1
a256 1
*		    A2
d260 2
a261 2
		ADDQ.B	#1,cu_CDNestCnt(A2)
		BGT.S	cdDeferred
d264 1
a264 1
		MOVEM.L D0-D1/A0-A1,-(SP)
d266 1
a266 1
		MOVEM.L	(SP)+,D0-D1/A0-A1
d268 1
a268 1
		RTS
d278 1
a278 1
*		   A2
d282 2
a283 2
		SUBQ.B	#1,cu_CDNestCnt(A2)
		BPL.S	cdDeferred
d294 1
a294 1
*		   A2
d298 8
a305 8
		MOVEQ	#0,D0
		MOVE.L	cu_XCP(A2),D1
		CMP.L	cu_XCCP(A2),D1
		BEQ.S	cupNoChange
		BCLR	#CUB_IMPLICITNL,cu_Flags(A2)	; clear IMPLICITNL
		BSR.s	CursDisable
		MOVE.L	D1,cu_XCCP(A2)
		BSR.s	CursEnable
d307 1
a307 1
		RTS
d317 1
a317 1
*	       A2
d321 5
a325 5
		MOVE.W	cu_YCP(A2),D1
		SUB.W	D0,D1
		BCS.S	cUpWrap
		MOVE.W	D1,cu_YCP(A2)
		BRA.S	CursUpdate
d328 3
a330 3
		CLR.W	cu_YCP(A2)
		BTST	#(PMB_ASM&07),cu_Modes+(PMB_ASM/8)(A2)
		BEQ.S	cVertBound
d334 1
a334 1
		BSR	ScrollYDisplay
d336 1
a336 1
		BRA.S	CursUpdate
d346 1
a346 1
*		 A2
d350 6
a355 6
		MOVE.W	cu_YCP(A2),D1
		ADD.W	D0,D1
		CMP.W	cu_YMax(A2),D1
		BHI.S	cDownWrap
		MOVE.W	D1,cu_YCP(A2)
		BRA.s	CursUpdate
d359 5
a363 5
		MOVE.W	cu_YMax(A2),cu_YCP(A2)
		BTST	#(PMB_ASM&07),cu_Modes+(PMB_ASM/8)(A2)
		BEQ.S	cVertBound
		SUB.W	cu_YMax(A2),D1
		BRA.S	scrollVert
d373 1
a373 1
*		  A2
d377 4
a380 4
		ADD.W	cu_XCP(A2),D0
		CMP.W	cu_XMax(A2),D0
		BHI.S	cRightWrap
		MOVE.W	D0,cu_XCP(A2)
d382 1
a382 1
		BRA.s	CursUpdate
d385 4
a388 4
		BTST	#(PMB_AWM&07),cu_Modes+(PMB_AWM/8)(A2)
		BNE.S	cRightAutoWrap
		MOVE.W	cu_XMax(A2),cu_XCP(A2)
		BRA.S	cRightBound
d391 10
a400 10
		CLR.W	cu_XCP(A2)
		SUB.W	cu_XMax(A2),D0
		SUBQ	#1,D0
		MOVE.W	D0,-(A7)
		MOVEQ	#1,D0
		BSR.S	CursDown
		MOVE.W	(A7)+,D0
		BNE.S	CursRight
		BSET	#CUB_IMPLICITNL,cu_Flags(A2)
		RTS
d410 1
a410 1
*		 A2
d414 4
a417 4
		MOVE.W	cu_XCP(A2),D1
		SUB.W	D0,D1
		BCS.S	cLeftWrap
		MOVE.W	D1,cu_XCP(A2)
d419 1
a419 1
		BRA	CursUpdate
d422 4
a425 4
		BTST	#(PMB_AWM&07),cu_Modes+(PMB_AWM/8)(A2)
		BNE.S	cLeftAutoWrap
		CLR.W	cu_XCP(A2)
		BRA.S	cLeftBound
d428 8
a435 8
		MOVE.W	cu_XMax(A2),cu_XCP(A2)
		NEG.W	D1
		SUBQ	#1,D1
		MOVE.W	D1,-(A7)
		MOVEQ	#1,D0
		BSR	CursUp
		MOVE.W	(A7)+,D0
		BRA.S	CursLeft
@


36.6
log
@delete CursClear (not needed)
@
text
@d1 1
a1 1
	TTL    '$Header: cursor.asm,v 36.5 89/07/05 15:16:41 kodiak Exp $'
d13 3
a60 1
	XREF_GFX	ScrollRaster
@


36.5
log
@move ScrollYText out to scroll.asm (where it's called ScrollYDisplay)
@
text
@d1 1
a1 1
	TTL    '$Header: cursor.asm,v 36.4 89/06/28 19:14:16 kodiak Exp $'
d13 3
a67 1
	XDEF	CursClear
d159 1
a159 1
		beq.s	crDone
a163 3
		MOVEQ	#RP_COMPLEMENT,D0
		bsr.s	cRender
		move.w	(a7)+,d2
a164 5
crDone:
		rts


cRender:
d174 1
a198 1
		RTS
d200 1
a200 6
CursClear:
		movem.l	d2-d3,-(a7)
		lea	cd_RastPort(A6),A1
		move.b	rp_FgPen(a1),d3
		moveq	#0,d0
		LINKGFX	SetAPen
d202 1
a202 10
		MOVEQ	#RP_JAM2,D0
		moveq	#$ffffffff,d1
		bsr	cRender

		lea	cd_RastPort(A6),A1
		moveq	#0,d0
		move.b	d3,d0
		LINKGFX	SetAPen
		movem.l	(a7)+,d2-d3
crDisabled:
d206 2
d210 1
a210 1
		bpl.s	crDisabled
@


36.4
log
@better avoidance of cursor spoor
@
text
@d1 1
a1 1
	TTL    '$Header: cursor.asm,v 36.3 89/06/28 12:28:40 kodiak Exp $'
d13 3
d57 3
a75 1
	XDEF	ScrollYText
a76 1

a161 1
		MOVE.B	cd_RastPort+rp_DrawMode(A6),d2
d171 1
a208 1
		MOVE.B	rp_DrawMode(A1),d2
d347 1
a347 1
		BSR	ScrollYText
a448 89


*------ ScrollYText --------------------------------------------------
*
*   NAME
*	ScrollYText - convert character units to raster units and scroll
*
*   SYNOPSIS
*	ScrollYText(consoleUnit)
*		    A2
*
*---------------------------------------------------------------------
ScrollYText:
		MOVEM.L	D2-D5/a4-a5,-(A7)
		move.w	d0,d5
		beq	sytDone
		move.l	cu_BufferSize(a2),d2
		beq.s	sytSR
	    ;-- scroll buffer
		move.l	cu_CharBuffer(a2),a0
		move.l	cu_AttrBuffer(a2),a1
		tst.w	d0
		bmi.s	sytSBYDown
		;-- scroll buffer up
		mulu	cu_BufferWidth(a2),d0
		sub.l	d0,d2
		lea	0(a0,d0.l),a4
		add.l	d0,d0
		lea	0(a1,d0.l),a5
		lsr.l	#1,d0
		bra.s	sytsbyuCopyDBF
sytsbyuCopyLoop:
		move.b	(a4)+,(a0)+
		move.w	(a5)+,(a1)+
sytsbyuCopyDBF:
		dbf	d2,sytsbyuCopyLoop
		bra.s	sytsbyuClrDBF
sytsbyuClrLoop:
		clr.w	(a1)+
sytsbyuClrDBF:
		dbf	d0,sytsbyuClrLoop
		bra.s	sytSBDone

		;-- scroll buffer down
sytSBYDown:
		neg.w	d0
		mulu	cu_BufferWidth(a2),d0
		lea	0(a0,d2.l),a4
		add.l	d2,d2
		lea	0(a1,d2.l),a5
		lsr.l	#1,d2
		sub.l	d0,d2
		add.l	d2,a0
		add.l	d2,d2
		add.l	d2,a1
		lsr.l	#1,d2
		bra.s	sytsbydCopyDBF
sytsbydCopyLoop:
		move.b	-(a0),-(a4)
		move.w	-(a1),-(a5)
sytsbydCopyDBF:
		dbf	d2,sytsbydCopyLoop
		bra.s	sytsbydClrDBF
sytsbydClrLoop:
		clr.w	-(a5)
sytsbydClrDBF:
		dbf	d0,sytsbydClrLoop
sytSBDone:
		move.w	d5,d0
	    ;-- scroll raster
sytSR:
		lea	cd_RastPort(A6),A1
		moveq	#0,d0
		MULS	cu_YRSize(A2),D5
		move.l	d5,d1
		MOVE.W	cu_XROrigin(A2),D2
		EXT.L	D2
		MOVE.W	cu_YROrigin(A2),D3
		EXT.L	D3
		MOVE.W	cu_XRExtant(A2),D4
		EXT.L	D4
		MOVE.W	cu_YRExtant(A2),D5
		EXT.L	D5
		BSR	CursDisable
		LINKGFX	ScrollRaster
		BSR	CursEnable
sytDone:
		MOVEM.L	(A7)+,D2-D5/a4-a5
		RTS
@


36.3
log
@add support for cursor ghosting in inactive windows
usurp use of rp_AreaPtrn and rp_AreaPtSz from users of ConUnit structure
@
text
@d1 1
a1 1
	TTL    '$Header: cursor.asm,v 36.2 89/02/20 13:11:09 kodiak Exp $'
d13 4
d60 1
d140 3
a142 4
		move.l	cu_Window(a2),a0
		move.l	wd_Flags(a0),d1
		and.l	#WINDOWACTIVE,d1
		beq.s	crGotActive
d219 2
d222 20
a241 2
		and.b	#~(CUF_CURSBLOCK!CUF_CURSGHOST)&$ff,cu_CursorFlags(a2)
		rts
@


36.2
log
@add CursClear function
@
text
@d1 1
a1 1
	TTL    '$Header: cursor.asm,v 36.1 88/09/19 10:15:30 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 3
d35 1
a52 1
	XDEF	CursExpunge
d74 2
a75 2
*	error = CursInit(consoleUnit)
*	D0		   A2
d79 3
a81 3
		CLR.L	cu_AreaPtrn(A2)	; cursor pattern is fill
		CLR.B	cu_AreaPtSz(A2)
		MOVEQ	#0,D0
a82 3
CursExpunge:
coDeferredRts1:
		RTS
a83 13

*------ CursExpunge -------------------------------------------------
*
*   NAME
*	CursExpunge - expunge text cursor
*
*   SYNOPSIS
*	CursExpunge(consoleUnit)
*		    A2
*
*---------------------------------------------------------------------


d94 37
d132 1
a132 4
		BSET	#CUB_CURSON,cu_Flags(A2)
		BNE.S	coDeferredRts1
		TST.B	cu_CDNestCnt(A2)
		BPL.S	coDeferredRts1
d135 18
d158 2
d162 1
d164 8
d207 1
d215 2
d231 2
a232 5
		BCLR	#CUB_CURSON,cu_Flags(A2)
		BEQ.S	coDeferredRts2
		TST.B	cu_CDNestCnt(A2)
		BPL.S	coDeferredRts2
		BRA	CursRender
a245 1
		MOVEM.L D0-D1/A0-A1,-(SP)
a247 3
		BTST	#CUB_CURSON,cu_Flags(A2)
		BEQ.S	cdDeferred
		BSR	CursRender
d249 4
a253 2
		MOVEM.L	(SP)+,D0-D1/A0-A1
coDeferredRts2:
a267 1
		MOVEM.L D0-D1/A0-A1,-(SP)
d270 1
a270 4
		BTST	#CUB_CURSON,cu_Flags(A2)
		BEQ.S	cdDeferred
		BSR	CursRender
		BRA.S	cdDeferred
d289 1
a289 1
		BSR	CursDisable
d291 1
a291 1
		BSR	CursEnable
d341 1
a341 1
		BRA	CursUpdate
d368 1
a368 1
		BRA	CursUpdate
@


36.1
log
@add character map and pseudo-clipboard support
@
text
@d1 1
a1 1
	TTL    '$Header: cursor.asm,v 36.0 88/09/06 19:51:27 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker: kodiak $
d13 3
d43 1
d48 13
a60 12
	XDEF	    CursInit
	XDEF	    CursExpunge
	XDEF	    CursOn
	XDEF	    CursOff
	XDEF	    CursRender
	XDEF	    CursDisable
	XDEF	    CursEnable
	XDEF	    CursUpdate
	XDEF	    CursUp
	XDEF	    CursDown
	XDEF	    CursLeft
	XDEF	    CursRight
d62 1
a62 1
	XDEF	    ScrollYText
d114 8
a122 2
		MOVE.B	rp_DrawMode(A1),-(A7)
		MOVEQ	#RP_COMPLEMENT,D0
d124 1
a125 1

d144 1
a144 1
		MOVE.B	(A7)+,D0
d147 18
@


36.0
log
@*** empty log message ***
@
text
@d1 1
a1 1
	TTL    '$Header: cursor.asm,v 35.1 87/10/26 12:57:20 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 3
d48 1
d57 1
a57 1
	XDEF		ScrollText
d108 1
a108 1
cOnOff:
d153 1
a153 1
		BRA	cOnOff
d172 1
a172 1
		BSR	cOnOff
d196 1
a196 1
		BSR	cOnOff
a244 1
		MOVEQ	#0,D0
d246 2
a247 2
		EXT.L	D1
		BSR	ScrollText
a274 1
		MOVEQ	#0,D0
d351 1
a351 1
*------ ScrollText ---------------------------------------------------
d354 1
a354 1
*	ScrollText - convert character units to raster units and scroll
d357 2
a358 2
*	ScrollText(consoleUnit)
*		   A2
d361 59
a419 2
ScrollText:
		MOVEM.L	D2-D5,-(A7)
d421 3
a423 2
		MULS	cu_XRSize(A2),D0
		MULS	cu_YRSize(A2),D1
d435 2
a436 1
		MOVEM.L	(A7)+,D2-D5
@
