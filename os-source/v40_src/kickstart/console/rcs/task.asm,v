head     36.29;
branch   ;
access   ;
symbols  V39_4:36.28 V37_157:36.28 V37_149:36.27 V37_136:36.27 V37_133:36.27 V37_110:36.27 V37_98:36.27 V37_85:36.27 V37_63:36.27 V37_36:36.27 V37_15:36.26 V37_10:36.26 V37_7:36.26 V37_2:36.26 V36_558:36.26 V36_554:36.26 V36_552:36.26 V36_549:36.24 V36_548:36.24 V36_547:36.24 V36_546:36.24 V36_545:36.24 V36_544:36.24 V36_543:36.24 V36_542:36.24 V36_540:36.24 V36_539:36.23 V36_538:36.22 V36_537:36.22 V36_536:36.22 V36_529:36.20 V36_527:36.20 V36_525:36.19 V36_524:36.18 V36_523:36.18 V36_522:36.18 V36_521:36.18 V36_520:36.18 V36_519:36.18 V36_518:36.18 V36_495:36.17 V36_491:36.17 V36_486:36.16 V36_482:36.15 V36_476:36.15 V36_471:36.15 V36_465:36.15 V36_463:36.15 V36_461:36.15 V36_460:36.15 V36_453:36.15 V36_447:36.15 V36_442:36.15 V36_429:36.15 V36_423:36.15 V36_413:36.15 V36_394:36.14 V36_387:36.14 V36_382:36.14 V36_381:36.14 V36_379:36.13 V36_373:36.13 V36_367:36.13 V36_361:36.12 V36_359:36.12 V36_357:36.12 V36_353:36.12 V36_346:36.12 V36_343:36.12 V36_338:36.11 V36_332:36.11 V36_327:36.11 V36_321:36.11 V36_319:36.11 V36_318:36.11 V36_316:36.10 V36_313:36.10 V36_311:36.10 V36_310:36.10 V36_300:36.10 V36_299:36.10 V36_297:36.9 V36_295:36.9 V36_278:36.9 V36_274:36.9 V36_221:36.8 V36_205:36.8 V36_171:36.7 V36_167:36.7 V36_165:36.6 V36_153:36.5 V36_146:36.5 V36_140:36.5 V36_129:36.5 V36_113:36.4 V36_56:36.3 V36_53:36.2 V36_51:36.2 V36_45:36.2 L36_42:36.1;
locks    ; strict;
comment  @*   @;


36.29
date     93.03.05.16.59.49;  author darren;  state Exp;
branches ;
next     36.28;

36.28
date     91.05.22.13.48.13;  author darren;  state Exp;
branches ;
next     36.27;

36.27
date     91.02.04.14.30.11;  author darren;  state Exp;
branches ;
next     36.26;

36.26
date     90.12.13.19.44.26;  author darren;  state Exp;
branches ;
next     36.25;

36.25
date     90.12.12.17.21.03;  author darren;  state Exp;
branches ;
next     36.24;

36.24
date     90.11.09.20.26.08;  author darren;  state Exp;
branches ;
next     36.23;

36.23
date     90.11.07.15.20.26;  author darren;  state Exp;
branches ;
next     36.22;

36.22
date     90.11.01.15.15.01;  author darren;  state Exp;
branches ;
next     36.21;

36.21
date     90.11.01.11.23.34;  author darren;  state Exp;
branches ;
next     36.20;

36.20
date     90.10.11.15.30.53;  author darren;  state Exp;
branches ;
next     36.19;

36.19
date     90.10.11.14.09.25;  author darren;  state Exp;
branches ;
next     36.18;

36.18
date     90.06.07.13.56.27;  author kodiak;  state Exp;
branches ;
next     36.17;

36.17
date     90.05.29.18.22.26;  author kodiak;  state Exp;
branches ;
next     36.16;

36.16
date     90.05.25.16.10.04;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     90.04.13.13.32.58;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     90.04.02.10.47.43;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     90.03.02.10.37.09;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     90.02.21.18.40.34;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     89.12.19.11.03.32;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     89.12.14.17.03.41;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     89.12.02.11.37.28;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     89.11.03.12.24.53;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     89.09.15.15.40.44;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     89.08.21.12.52.31;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.06.28.19.14.31;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     89.06.28.13.33.33;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     89.04.17.15.35.54;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     89.01.10.16.46.56;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     88.09.19.10.16.05;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     88.09.06.19.52.34;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


36.29
log
@Use new smaller calling convention for opening
timer & input device - saves ROM
@
text
@**
**	$Id: task.asm,v 36.28 91/05/22 13:48:13 darren Exp Locker: darren $
**
**      console task
**
**      (C) Copyright 1989 Commodore-Amiga, Inc.
**          All Rights Reserved
**
	SECTION	console

**	Includes

	INCLUDE	"cddata.i"

	INCLUDE	"exec/execbase.i"
	INCLUDE	"devices/timer.i"
	INCLUDE "internal/librarytags.i"

	INCLUDE	"debug.i"

**	Exports

	XDEF	CDTaskStart
	XDEF	GetEvents		;exported (see write.asm)
					;Semaphore access required



**	Imports

	XLVO	GetMsg			; Exec
	XLVO	ObtainSemaphoreShared	;
	XLVO	ObtainSemaphore		;
	XLVO	OpenDevice		;
	XLVO	ReleaseSemaphore	;
	XLVO	Wait			;

	XREF	LockDRPort		;able.asm
	XREF	UnLockRPort		;able.asm
	XREF	RefreshDamage		;refresh.asm
	XREF	ReSizeUnit
	XREF	SelectClip

	XREF	IfNewSize		;refresh.asm
	XREF	IfGhostCursor		;cursor.asm

	XREF	CursRender

*---------------------------------------------------------------------
		CNOP	0,4
CDTaskStart:
		;--	grab the device base
		move.l	4(sp),a5

		;--	allocate hard coded signals
		move.l	cd_ExecLib(a5),a6	; set up a6 == SysBase
		move.l	ThisTask(a6),a1
		or.l	#CDSIG_HARDCODED,TC_SIGALLOC(a1)

		;--	initialize timer port
		lea	cd_TPort(a5),a0
		move.l	a0,cd_TIOR+MN_REPLYPORT(a5)
		move.b	#NT_MSGPORT,cd_TPort+LN_TYPE(a5)
		move.w	#CDSIGB_TICK,cd_TPort+MP_FLAGS(a5) ; FLAGS=0, SIGBIT=b
		move.l	a1,cd_TPort+MP_SIGTASK(a5)
		lea	cd_TPort+MP_MSGLIST(a5),a0
		NEWLIST	a0

		suba.l	a0,a0			;ODTAG_TIMER
	;;	lea	TDName(pc),a0
		moveq	#UNIT_VBLANK,d0
		lea	cd_TIOR(a5),a1
		moveq	#0,d1
		CALLLVO	OpenDevice

		lea	cd_USemaphore(a5),a0
		CALLLVO	ObtainSemaphoreShared

		move.l	a5,a6			; set up a6 == ConsoleDevice

taskPrimeTick:
		move.b	cd_SelectFlags(a6),d0
		move.b	d0,d1
		and.b	#CDSF_CIRCLING!CDSF_DRAGGING!CDSF_SELECTING,d1
		beq.s	taskWait
		btst	#CDSB_SELECTDOWN,d0
		beq.s	taskWait
		bset	#CDSB_TICKING,d0
		bne.s	taskWait
		move.b	d0,cd_SelectFlags(a6)

		move.l	cd_TIOR+IO_DEVICE(a6),d0
		beq.s	taskWait
		lea	cd_TIOR(a6),a1
		move.w	#TR_ADDREQUEST,IO_COMMAND(a1)
		clr.b	IO_FLAGS(a1)
		moveq	#CD_TEVENTSECS,d1
		move.l	d1,IOTV_TIME+TV_SECS(a1)
		move.l	#CD_TEVENTMICRO,IOTV_TIME+TV_MICRO(a1)
		move.l	a6,-(a7)
		move.l	d0,a6
		jsr	DEV_BEGINIO(a6)
		move.l	(a7)+,a6

	;-- wait for signal
taskWait:
		lea	cd_USemaphore(a6),a0
		LINKEXE	ReleaseSemaphore

		move.l	#CDSIG_HARDCODED,d0
		LINKEXE	Wait
		move.l	d0,d7

		lea	cd_USemaphore(a6),a0
		LINKEXE	ObtainSemaphoreShared


		;safety feature - if I were to awake without any
		;windows, just ignore this stuff.

		tst.l	cd_WindowCount(a6)
		beq	taskPrimeTick

		;-- EVENT LIST

		move.l	d7,d0
		andi.l	#CDSIGF_NEWACTIVE!CDSIGF_REFRESH,d0
		beq.s	checkSelect

		;-- loops through list of console units looking
		;-- for new events (tail != head)
		;
		;-- Refresh, and Newsize are handled by the same
		;-- routine.  If newsize, a full redraw is done
		;-- throwing away the damage.
		;
		;-- The active bit in cu_States reflects the window's
		;-- activation state at the time the event occured.
		;-- This is necessary for proper cursor drawing,
		;-- and restoration.

		move.l	d7,-(sp)		;preserve D7

		lea	cd_EVSemaphore(a6),a0
		LINKEXE	ObtainSemaphore

		lea	cd_UHead(a6),a2		;loop through units
get_events:
		bsr.s	GetEvents		;handle pending events

next_unit:	move.l	(a2),a2
                tst.l	(a2)
		bne.s	get_events


		lea	cd_EVSemaphore(a6),a0
		LINKEXE	ReleaseSemaphore

		move.l	(sp)+,d7		;restore D7

checkSelect:
		btst	#CDSIGB_SELECT,d7
		beq.s	checkTick

		bsr	SelectClip

checkTick:
		btst	#CDSIGB_TICK,d7
		beq	taskPrimeTick
		lea	cd_TPort(a6),a0
		LINKEXE	GetMsg

		bclr	#CDSB_TICKING,cd_SelectFlags(a6)
		beq	taskPrimeTick

		bsr	SelectClip

		bra	taskPrimeTick

***************************************************************************
* Removes events from list of events maintained in each window structure.
* 
* This routine only updates the tail index - the inputhandler which
* adds tokens only updates the head of the list.  Tokens pulled off
* after updating tail.
*
* Function is exported so that it can be used before writing text to update
* any pending things.  Protected by a semaphore such that only one task
* at a time can remove tokens.
*
* The active state bit held for each window is updated within this routine
* to reflect the proper active state needed to properly draw, and undraw
* the cursor at the time the event happened.
*
* Continguous refresh, and newsize events are accumulated, and are added
* as only one event by the inputhandler.
*
* register usage:
*
* IN - a2 points to unit structure
*
* USED - d1 index into list
*        d0 holds token removed from list
*        

GetEvents:

		lea	cu_IList(a2),a0
		moveq	#00,d1
		move.b	cu_ITail(a2),d1
		cmp.b	cu_IHead(a2),d1
		beq.s	GotEvents


		; update tail (1 instruction) - remove token after
		; bumping index.

		addq.b	#1,cu_ITail(a2)
		move.b	0(a0,d1),d0

		btst	#IPB_MAKEACTIVE,d0
		beq.s	ifinactive

		bset	#CUB_ISACTIVE,cu_States(a2)
fix_cursor:
		;ignore cursor updating if this is a SIMPLE
		;refresh, non-character mapped console

		bsr	IfGhostCursor
		beq.s	GetEvents

		;
		;ignore cursor updating if resize pending
		;fixes cursor border trashing if activate followed
		;by newsize before these can be handled.
		;
		;case - activate window by clicking on sizing
		;gadget, and drag smaller such that a window
		;border clips the cursor.  Do NOT release mouse
		;button before dragging - The call to LockDRPort
		;is put on hold until the mouse button is released.
		;

		bsr	LockDRPort

		bsr	IfNewSize
		bne.s	skipAhead

		bsr	CursRender
skipAhead:
		bsr	UnLockRPort
		bra.s	GetEvents

ifinactive:	btst	#IPB_MAKEINACTIVE,d0
		beq.s	ifdamaged

		bclr	#CUB_ISACTIVE,cu_States(a2)
		bra.s	fix_cursor

ifdamaged:
		bclr	#CUB_ISACTIVE,cu_States(a2)
		btst	#IPB_ISACTIVE,d0
		beq.s	notactive
		bset	#CUB_ISACTIVE,cu_States(a2)
notactive:
		bsr	RefreshDamage
		bra.s	GetEvents

GotEvents:	rts


	END
@


36.28
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: task.asm,v 36.27 91/02/04 14:30:11 darren Exp Locker: darren $
d17 1
a49 1
TDName		dc.b	'timer.device',0
d69 2
a70 1
		lea	TDName(pc),a0
@


36.27
log
@Safety check - now checks for window count != 0, and if 0,
ignore signals.  Should never get a signal, but the extra two
lines of code don't hurt should someone signal us spuriously.
@
text
@d2 1
a2 1
**	$Id: task.asm,v 36.26 90/12/13 19:44:26 darren Exp Locker: darren $
@


36.26
log
@Some simple checking for some junk down the input stream
which might wake up the task, and try to execute code
possibly causing problems.  Little code for some extra
safety.
@
text
@d2 1
a2 1
**	$Id: task.asm,v 36.25 90/12/12 17:21:03 darren Exp Locker: darren $
d117 2
a118 2
		;safety feature - if I were to awake before opening
		;Intuition, or being open, I just ignore this stuff.
d120 1
a120 1
		tst.w	LIB_OPENCNT(a6)
@


36.25
log
@Guarantee long word alignment of code.
@
text
@d2 1
a2 1
**	$Id: task.asm,v 36.24 90/11/09 20:26:08 darren Exp Locker: darren $
d115 7
@


36.24
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: task.asm,v 36.23 90/11/07 15:20:26 darren Exp $
d50 1
a50 1
		ds.w	0
@


36.23
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: task.asm,v 36.22 90/11/01 15:15:01 darren Exp Locker: darren $
@


36.22
log
@Fix for SIMPLE REFRESH windows without a map - cursor
ghosting disabled in this rare case since I can't toggle
ghosted imagery on/off if damage occurs to the window.
@
text
@d2 1
a2 1
**	$Id: task.asm,v 36.21 90/11/01 11:23:34 darren Exp Locker: darren $
@


36.21
log
@New code added for a new input handling scheme which tracks
a history of events - hope is to resolve race conditions which
result in cursor redraw problems.
@
text
@d2 1
a2 1
**	$Id: task.asm,v 36.20 90/10/11 15:30:53 darren Exp Locker: darren $
d44 1
d218 6
a236 1

@


36.20
log
@Code to handle extraneous damage
checking, and removal centralized in
one routine - see wreset.asm
@
text
@d2 1
a2 1
**	$Id: task.asm,v 36.19 90/10/11 14:09:25 darren Exp Locker: darren $
d18 1
d23 2
d27 1
d32 1
d43 2
a46 2

	
d115 1
d117 3
a119 12
		btst	#CDSIGB_NEWACTIVE,d7
		beq.s	checkRefresh
	    ;-- find units needing cursor updating
		move.l	cd_UHead(a6),a2		; get first unit
loopAUnit:
		tst.l	(a2)
		beq.s	checkRefresh	; cannot find unit, no refresh
		bclr	#CUB_NEWACTIVE,cu_Flags(a2)
		beq.s	nextAUnit
		bsr	LockDRPort
		bsr	CursRender
		bsr	UnLockRPort
d121 11
a131 3
nextAUnit:
		move.l	(a2),a2		; next unit
		bra.s	loopAUnit
d133 1
d135 2
a136 3
checkRefresh:
		btst	#CDSIGB_REFRESH,d7
		beq.s	checkSelect
d138 3
a140 5
	    ;-- find unit to refresh
		move.l	cd_UHead(a6),a2		; get first unit
loopRUnit:
		tst.l	(a2)
		beq	checkSelect	; cannot find unit, no refresh
d142 3
a144 3
		bclr	#CUB_RESIZE,cu_Flags(a2)
		beq.s	checkRUnit
		bsr	LockDRPort
a145 1
		bsr	ReSizeUnit
d147 2
a148 2
		bsr	UnLockRPort
		bra.s	nextRUnit
d150 1
a150 4
checkRUnit:
		bclr	#CUB_REFRESH,cu_Flags(a2)
		beq.s	nextRUnit
		bsr	RefreshDamage
a151 4
nextRUnit:
		move.l	(a2),a2		; next unit
		bra.s	loopRUnit

d170 86
@


36.19
log
@Fix for window border trashing.  Now disposes
of damage lists inside of lock layers if
we have just processed a resize event.
@
text
@d2 1
a2 1
**	$Id: task.asm,v 36.18 90/06/07 13:56:27 kodiak Exp Locker: darren $
a34 1
	XREF	ThrowAwayDamage		;refresh.asm
a132 10
		;-- This code was changed because of race condition.
		;-- it now does a refresh and newsize condition
		;-- as one event only.  It turns out we are already
		;-- doing a full redraw anyway for a new size, so
		;-- the damage lists are not only unneeded, but may
		;-- be wrong since they are accumulated, and can include
		;-- regions outside of the desired drawing area after
		;-- a resize.  As a side benefit, the new code is also
		;-- faster than the old code.

d145 1
a145 6
		bclr	#CUB_REFRESH,cu_Flags(a2)
		beq.s	nextunit

		bsr	ThrowAwayDamage

nextunit:	bsr	UnLockRPort
@


36.18
log
@space saving by keeping exec in a6 during task initialization
@
text
@d2 1
a2 1
**	$Id: task.asm,v 36.17 90/05/29 18:22:26 kodiak Exp Locker: kodiak $
d32 4
a35 3
	XREF	LockDRPort
	XREF	UnLockRPort
	XREF	RefreshDamage
d134 10
d149 1
d153 1
d155 8
a162 1
		bsr	UnLockRPort
@


36.17
log
@will not initiate a selection when not over a character
@
text
@d2 1
a2 1
**	$Id: task.asm,v 36.16 90/05/25 16:10:04 kodiak Exp Locker: kodiak $
d47 1
a47 1
		move.l	4(sp),a6
d50 2
a51 2
		move.l	cd_ExecLib(a6),a1
		move.l	ThisTask(a1),a1
d55 6
a60 6
		lea	cd_TPort(a6),a0
		move.l	a0,cd_TIOR+MN_REPLYPORT(a6)
		move.b	#NT_MSGPORT,cd_TPort+LN_TYPE(a6)
		move.w	#CDSIGB_TICK,cd_TPort+MP_FLAGS(a6) ; FLAGS=0, SIGBIT=b
		move.l	a1,cd_TPort+MP_SIGTASK(a6)
		lea	cd_TPort+MP_MSGLIST(a6),a0
d65 1
a65 1
		lea	cd_TIOR(a6),a1
d67 1
a67 1
		LINKEXE	OpenDevice
d69 4
a72 2
		lea	cd_USemaphore(a6),a0
		LINKEXE	ObtainSemaphoreShared
@


36.16
log
@remove unneeded load of cd_Active
@
text
@d2 1
a2 1
**	$Id: task.asm,v 36.15 90/04/13 13:32:58 kodiak Exp Locker: kodiak $
d75 1
a75 1
		and.b	#CDSF_DRAGGING!CDSF_SELECTING,d1
@


36.15
log
@use Id instead of Header for 4.x rcs
@
text
@d2 1
a2 1
**	$Id$
a72 1
		move.l	cd_Active(a6),a2
@


36.14
log
@for 4.x rcs
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/task.asm,v 36.13 90/03/02 10:37:09 kodiak Exp Locker: kodiak $
@


36.13
log
@Allocates console.device's hard coded signals in Task structure
@
text
@d2 1
a2 1
**	$Header: task.asm,v 36.12 90/02/21 18:40:34 kodiak Exp $
@


36.12
log
@first cut at drag-select
@
text
@d2 1
a2 1
**	$Header: task.asm,v 36.11 89/12/19 11:03:32 kodiak Exp $
d46 1
a46 1
	;------ Grab the device base
d49 6
d58 2
a59 4
		clr.b	cd_TPort+MP_FLAGS(a6)
		move.b	#CDSIGB_TICK,cd_TPort+MP_SIGBIT(a6)
		move.l	cd_ExecLib(a6),a0
		move.l	ThisTask(a0),cd_TPort+MP_SIGTASK(a6)
@


36.11
log
@eliminate private ObtainSemaphoreShared & ReleaseSemaphore -- use exec's
@
text
@d2 1
a2 1
**	$Header: task.asm,v 36.10 89/12/14 17:03:41 kodiak Exp $
d47 1
a47 1
		MOVE.L	4(SP),A6
d49 5
a53 5
		LEA	cd_TPort(A6),A0
		MOVE.L	A0,cd_TIOR+MN_REPLYPORT(A6)
		MOVE.B	#NT_MSGPORT,cd_TPort+LN_TYPE(A6)
		CLR.B	cd_TPort+MP_FLAGS(A6)
		MOVE.B	#CDSIGB_TICK,cd_TPort+MP_SIGBIT(a6)
d56 2
a57 2
		LEA	cd_TPort+MP_MSGLIST(A6),A0
		NEWLIST	A0
d61 1
a61 1
		LEA	cd_TIOR(A6),A1
d70 3
a72 1
		btst	#CUB_SELECTING,cu_Flags(a2)
d74 1
a74 1
		btst	#CDSB_SELECT,cd_SelectFlags(a6)
d76 1
a76 1
		bset	#CDSB_TICKING,cd_SelectFlags(a6)
d78 1
d80 1
a80 1
		MOVE.L	cd_TIOR+IO_DEVICE(A6),d0
d82 3
a84 3
		LEA	cd_TIOR(A6),A1
		MOVE.W	#TR_ADDREQUEST,IO_COMMAND(A1)
		CLR.B	IO_FLAGS(A1)
d86 2
a87 2
		MOVE.L	d1,IOTV_TIME+TV_SECS(A1)
		MOVE.L	#CD_TEVENTMICRO,IOTV_TIME+TV_MICRO(A1)
d90 1
a90 1
		JSR	DEV_BEGINIO(A6)
d109 1
a109 1
		MOVE.L	cd_UHead(A6),A2		; get first unit
d111 4
a114 4
		TST.L	(A2)
		BEQ.s	checkRefresh	; cannot find unit, no refresh
		BCLR	#CUB_NEWACTIVE,cu_Flags(A2)
		BEQ.S	nextAUnit
d116 1
a116 1
		BSR	CursRender
d120 2
a121 2
		MOVE.L	(A2),A2		; next unit
		BRA.S	loopAUnit
d129 1
a129 1
		MOVE.L	cd_UHead(A6),A2		; get first unit
d131 4
a134 4
		TST.L	(A2)
		BEQ	checkSelect	; cannot find unit, no refresh
		BCLR	#CUB_RESIZE,cu_Flags(A2)
		BEQ.S	checkRUnit
d136 1
a136 1
		BSR	ReSizeUnit
d145 2
a146 2
		MOVE.L	(A2),A2		; next unit
		BRA.S	loopRUnit
a162 1
		bset	#CDSB_TICKED,cd_SelectFlags(a6)
a163 1
		bclr	#CDSB_TICKED,cd_SelectFlags(a6)
@


36.10
log
@different damage refresh strategy: should always clear damage
@
text
@d2 1
a2 1
**	$Header: task.asm,v 36.9 89/12/02 11:37:28 kodiak Exp $
d27 1
d29 1
a39 2
	XREF	ObtainSemaphoreShared
	XREF	ReleaseSemaphore
d66 1
a66 1
		bsr	ObtainSemaphoreShared
d93 1
a93 1
		bsr	ReleaseSemaphore
d100 1
a100 1
		bsr	ObtainSemaphoreShared
@


36.9
log
@
@
text
@d2 1
a2 1
**	$Header$
d32 1
a32 1
	XREF	RefreshWindow
d139 1
a139 1
		bsr	RefreshWindow
@


36.8
log
@coalesce XREF_XXX into XLVO
@
text
@d1 9
a9 11
	TTL	'$Header: task.asm,v 36.7 89/09/15 15:40:44 kodiak Exp $'
**********************************************************************
*
*			--------------
*   task.asm		CONSOLE DEVICE	task
*			--------------
*
*   Copyright 1988 Commodore-Amiga Inc.
*
**********************************************************************
	SECTION		rawinput
d11 1
a11 1
*------ Included Files -----------------------------------------------
d13 1
a13 1
	INCLUDE		"cddata.i"
d15 2
a16 1
	INCLUDE		"exec/execbase.i"
a17 1
	INCLUDE		"devices/timer.i"
d19 1
d21 1
a21 1
*------ Imported Functions -------------------------------------------
d23 3
d30 5
a34 5
	XREF		LockDRPort
	XREF		UnLockRPort
	XREF		RefreshWindow
	XREF		ReSizeUnit
	XREF		SelectClip
d36 1
a36 1
	XREF		CursRender
d38 2
a39 2
	XREF		ObtainSemaphoreShared
	XREF		ReleaseSemaphore
a40 4

*------ Exported Globals ---------------------------------------------

	XDEF		CDTaskStart
@


36.7
log
@move paste code to inputhandler.asm
@
text
@d1 1
a1 1
	TTL	'$Header: task.asm,v 36.6 89/08/21 12:52:31 kodiak Exp $'
d24 3
a26 3
	XREF_EXE	GetMsg
	XREF_EXE	OpenDevice
	XREF_EXE	Wait
@


36.6
log
@don't tick after selection is finished
@
text
@d1 1
a1 1
	TTL	'$Header: task.asm,v 36.5 89/06/28 19:14:31 kodiak Exp $'
a32 1
	XREF		PasteClip
d155 1
a155 1
		beq.s	checkPaste
d160 1
a160 1
		beq.s	checkPaste
d166 1
a166 3
checkPaste:
		btst	#CDSIGB_PASTE,d7
		beq	taskPrimeTick
a167 5
		bsr	PasteClip

		bra	taskPrimeTick
	
	
@


36.5
log
@better avoidance of cursor spoor
@
text
@d1 1
a1 1
	TTL	'$Header: task.asm,v 36.4 89/06/28 13:33:33 kodiak Exp $'
d74 2
@


36.4
log
@new signal/action for cursor activation
@
text
@d1 1
a1 1
	TTL	'$Header: task.asm,v 36.3 89/04/17 15:35:54 kodiak Exp $'
d103 1
d106 1
a106 1
	    ;-- find unit to refresh
d112 1
a112 1
		BEQ.S	checkAUnit
a116 4
checkAUnit:
		btst	#CUB_REFRESH,cu_Flags(a2)
		beq.s	nextRUnit
		bsr	RefreshWindow
d125 1
d138 1
a138 1
		btst	#CUB_REFRESH,cu_Flags(a2)
d141 1
@


36.3
log
@rearrange tick posting code
@
text
@d1 1
a1 1
	TTL	'$Header: task.asm,v 36.2 89/01/10 16:46:56 kodiak Exp $'
d29 2
a30 2
	XREF		UnLockDRPort
	XREF		RefreshUnit
d35 1
d37 4
d68 3
d93 4
a96 2
SIGNALS		SET	CDSIGF_REFRESH!CDSIGF_SELECT!CDSIGF_TICK!CDSIGF_PASTE
		move.l	#SIGNALS,d0
d100 26
d137 1
a137 1
		bsr	UnLockDRPort
d142 1
a142 1
		bsr	RefreshUnit
d174 2
@


36.2
log
@*** empty log message ***
@
text
@d1 1
a1 1
	TTL	'$Header: task.asm,v 36.1 88/09/19 10:16:05 kodiak Exp $'
a48 1
		move.l	cd_ExecLib(a6),a0
d52 1
d70 2
d75 2
a76 1
		MOVE.L	#CD_TEVENTSECS,IOTV_TIME+TV_SECS(A1)
a78 2
		MOVE.L	IO_DEVICE(A1),d0
		beq.s	tptBailOut
a80 1
tptBailOut:
@


36.1
log
@add character map and pseudo-clipboard support
@
text
@d1 1
a1 1
	TTL	'$Header: task.asm,v 36.0 88/09/06 19:52:03 kodiak Exp $'
d64 2
a65 1
		btst	#CDSB_SELECT,cd_SelectFlags(a6)
@


36.0
log
@*** empty log message ***
@
text
@d1 2
a2 5
	IFNE		TV_SIZE-8
	FAIL		"recode MOVEM statements that move time values"
	ENDC

*------ console.device task ------------------------------------------
d4 3
a6 3
*   Handle the following signals:
*	PORT		A command has been posted to the message port
*	IEVENT		An I/O read has been satisfied
d8 4
a11 6
*---------------------------------------------------------------------
IDTaskStart:
	;------ Grab the arguments
		MOVE.L	4(SP),A5
		MOVE.L	8(SP),A4
		MOVE.L	A5,A6
d13 1
a13 13
		LEA	id_Unit(A5),A0
		BSR	InitMsgPort
		MOVEQ	#0,D7
		BSET	D0,D7			; save for signal mask
		MOVE.L	D7,D6
		LEA	id_IEPort(A5),A0
		MOVE.L	A0,id_RIOR+MN_REPLYPORT(A5)
		MOVE.L	A0,id_SIOR+MN_REPLYPORT(A5)
		MOVE.L	A0,id_TIOR+MN_REPLYPORT(A5)
		MOVE.L	A0,id_MIOR+MN_REPLYPORT(A5)
		MOVE.L	A0,id_KIOR+MN_REPLYPORT(A5)
		BSR	InitMsgPort
		BSET	D0,D7			; save for signal mask
d15 1
a15 1
		MOVE.L	A4,A6
d17 1
a17 3
	;------ Wait for someone to use input.task before setting up reads
		MOVE.L	D7,D0
		CALLEXE Wait
d19 1
a19 2
		MOVE.L	D0,D2			    ; save signals
		BSR.S	openGameport
a20 3
*	    ;------ Fire up reads to the input devices
		BSR	readTimer
		BRA	checkPort	; go read the port that started this
d22 1
a22 1
;---------------------------------------------------------------------
d24 3
a26 8
taskWait:
*	    ;------ Wait for something to do
		BTST	#DUB_STOPPED,id_Unit+du_Flags(A5)
		BEQ.S	regularWait
	    ;------ Stopped: wait for start signal
		MOVE.L	D6,D0
		CALLEXE Wait
		BRA.S	continue
d28 6
a33 3
regularWait:
		MOVE.L	D7,D0
		CALLEXE Wait
a34 5
		BTST	#DUB_STOPPED,id_Unit+du_Flags(A5)
		BEQ.S	continue
	    ;------ Stopped: ensure wakeup is for start signal only
		MOVE.L	D0,D2		; save start signal
		AND.L	D6,D2
d36 1
a36 7
		MOVE.L	D7,D1		; set IE signal again if set
		EOR.L	D6,D1
		MOVE.L	D1,D5
		AND.L	D0,D5
		BEQ.S	checkIE
		CALLEXE	SetSignal
		BRA.S	checkIE
d38 8
a45 2
continue:
		MOVE.L	D0,D2			    ; save signals
d47 9
a55 15
checkIE:
		MOVE.B	id_IEPort+MP_SIGBIT(A5),D0
		EXT.W	D0
		BTST	D0,D2
		BEQ	checkReGameport
*	    ;------ See who it is
readIEPort:
		LEA	id_IEPort(A5),A0
		CALLEXE	GetMsg
		TST.L	D0
		BEQ	checkReGameport		; no more messages
		LEA	id_TIOR(A5),A1
		CMP.L	A1,D0
		BEQ.S	gotTimer
		BRA.S	readIEPort		; bad message!
d57 5
a61 10
*	    ;------ Dispatch Timer
gotTimer:
		LEA	id_TData(A5),A3
		MOVE.L	timerEventTemplate(PC),ie_Class(A3)
		CLR.L	ie_X(A3)
		BSR	readTime
		MOVEM.L	D3-D4,ie_TimeStamp(A3)
		BSR	DispatchEvents
		BSR	readTimer
		BRA.S	readIEPort
d63 5
a67 5
checkPort:
		MOVE.B	id_Unit+MP_SIGBIT(A5),D1
		EXT.W	D1
		BTST	D1,D2
		BEQ	taskWait
d69 12
a80 4
*	    ;------ check if a command is at the command port
		MOVE.L	id_Unit+MP_MSGLIST(A5),A1
		TST.L	(A1)
		BEQ	taskWait
d82 6
a87 8
		MOVE.W	IO_COMMAND(A1),D0
		BCLR    #IOB_QUICK,IO_FLAGS(A1)	; jimm: 8/1/86
		SUB.W	#IND_ADDHANDLER,D0
		LSL.W	#2,D0
		LEA	cmdVectors(PC),A0
		MOVE.L	0(A0,D0.W),A0
		JSR	(A0)
		BRA	taskWait
d89 12
d102 7
a108 4
cmdVectors:
		DC.L	IDAddHandler
		DC.L	IDRemHandler
		DC.L	IDWriteEvent
d110 3
a112 4
timerEventTemplate:
		DC.B	IECLASS_TIMER
		DC.B	0
		DC.W	0
d114 1
d116 5
a120 8
*------ readTimer -----------------------------------------------------
readTimer:
		LEA	id_TIOR(A5),A1
		MOVE.W	#TR_ADDREQUEST,IO_COMMAND(A1)
		CLR.B	IO_FLAGS(A1)
		MOVE.L	#ID_TEVENTSECS,IOTV_TIME+TV_SECS(A1)
		MOVE.L	#ID_TEVENTMICRO,IOTV_TIME+TV_MICRO(A1)
		BRA.S	sendIO
d122 2
d125 3
a127 10
*------ readTime ------------------------------------------------------
readTime:
		LEA	id_SIOR(A5),A1
		MOVE.W	#TR_GETSYSTIME,IO_COMMAND(A1)
		MOVE.B	#IOF_QUICK,IO_FLAGS(A1)
		BSR.S	sendIO
		LEA	id_SIOR(A5),A1
		CALLEXE	WaitIO
		MOVEM.L	id_SIOR+IOTV_TIME(A5),D3-D4
		RTS
d129 3
d133 1
a133 18
*------ DispatchEvents ------------------------------------------------
DispatchEvents:
		MOVE.L	A3,A0
		CLR.L	ie_NextEvent(A3)
		MOVE.L	id_HandlerList(A5),A4
handlerLoop:
		TST.L	(A4)
		BEQ.S	dRts
		MOVE.L	IS_CODE(A4),A2
		MOVE.L	IS_DATA(A4),A1
		MOVE.L	(A4),A4
		JSR	(A2)
		TST.L	D0		; no sense propagating nothing
		BEQ.S	dRts
		MOVE.L	D0,A0
		BRA.S	handlerLoop
dRts:
		RTS
d135 3
a137 1
		END
@
