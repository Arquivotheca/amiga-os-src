head     36.49;
branch   ;
access   ;
symbols  V39_4:36.39 V37_157:36.37 V37_149:36.36 V37_136:36.36 V37_133:36.36 V37_110:36.36 V37_98:36.36 V37_85:36.36 V37_63:36.36 V37_36:36.35 V37_15:36.35 V37_10:36.35 V37_7:36.35 V37_2:36.35 V36_558:36.35 V36_554:36.35 V36_552:36.35 V36_549:36.34 V36_548:36.34 V36_547:36.34 V36_546:36.34 V36_545:36.34 V36_544:36.34 V36_543:36.34 V36_542:36.34 V36_540:36.32 V36_539:36.32 V36_538:36.32 V36_537:36.32 V36_536:36.31 V36_529:36.28 V36_527:36.27 V36_525:36.26 V36_524:36.26 V36_523:36.25 V36_522:36.24 V36_521:36.23 V36_520:36.23 V36_519:36.23 V36_518:36.23 V36_495:36.23 V36_491:36.23 V36_486:36.23 V36_482:36.23 V36_476:36.23 V36_471:36.23 V36_465:36.23 V36_463:36.23 V36_461:36.23 V36_460:36.23 V36_453:36.23 V36_447:36.23 V36_442:36.23 V36_429:36.22 V36_423:36.22 V36_413:36.22 V36_394:36.21 V36_387:36.19 V36_382:36.19 V36_381:36.19 V36_379:36.18 V36_373:36.18 V36_367:36.18 V36_361:36.17 V36_359:36.17 V36_357:36.17 V36_353:36.17 V36_346:36.17 V36_343:36.17 V36_338:36.17 V36_332:36.17 V36_327:36.17 V36_321:36.17 V36_319:36.17 V36_318:36.17 V36_316:36.17 V36_313:36.17 V36_311:36.17 V36_310:36.17 V36_300:36.16 V36_299:36.15 V36_297:36.14 V36_295:36.13 V36_278:36.13 V36_274:36.13 V36_221:36.10 V36_205:36.8 V36_171:36.7 V36_167:36.7 V36_165:36.6 V36_153:36.5 V36_146:36.4 V36_140:36.3 V36_129:36.2 V36_113:36.2 V36_56:36.1 V36_53:36.1 V36_51:36.1 V36_45:36.1 L36_42:36.1;
locks    ; strict;
comment  @*   @;


36.49
date     92.07.17.11.17.50;  author darren;  state Exp;
branches ;
next     36.48;

36.48
date     92.06.16.10.45.15;  author darren;  state Exp;
branches ;
next     36.47;

36.47
date     92.05.27.15.46.51;  author darren;  state Exp;
branches ;
next     36.46;

36.46
date     92.05.19.10.10.43;  author darren;  state Exp;
branches ;
next     36.45;

36.45
date     92.05.18.13.04.57;  author darren;  state Exp;
branches ;
next     36.44;

36.44
date     92.04.02.15.07.29;  author darren;  state Exp;
branches ;
next     36.43;

36.43
date     92.03.26.13.48.06;  author darren;  state Exp;
branches ;
next     36.42;

36.42
date     92.03.24.08.54.43;  author darren;  state Exp;
branches ;
next     36.41;

36.41
date     92.03.23.12.48.19;  author darren;  state Exp;
branches ;
next     36.40;

36.40
date     92.03.19.12.50.12;  author darren;  state Exp;
branches ;
next     36.39;

36.39
date     92.03.16.13.18.46;  author darren;  state Exp;
branches ;
next     36.38;

36.38
date     92.03.16.13.00.06;  author darren;  state Exp;
branches ;
next     36.37;

36.37
date     91.05.22.13.48.37;  author darren;  state Exp;
branches ;
next     36.36;

36.36
date     91.02.22.14.24.18;  author darren;  state Exp;
branches ;
next     36.35;

36.35
date     90.12.13.21.43.03;  author darren;  state Exp;
branches ;
next     36.34;

36.34
date     90.11.20.18.37.09;  author darren;  state Exp;
branches ;
next     36.33;

36.33
date     90.11.14.13.37.27;  author darren;  state Exp;
branches ;
next     36.32;

36.32
date     90.11.05.17.45.37;  author darren;  state Exp;
branches ;
next     36.31;

36.31
date     90.11.02.08.00.35;  author darren;  state Exp;
branches ;
next     36.30;

36.30
date     90.11.01.16.34.27;  author darren;  state Exp;
branches ;
next     36.29;

36.29
date     90.11.01.11.24.24;  author darren;  state Exp;
branches ;
next     36.28;

36.28
date     90.10.15.16.00.00;  author darren;  state Exp;
branches ;
next     36.27;

36.27
date     90.10.11.15.30.11;  author darren;  state Exp;
branches ;
next     36.26;

36.26
date     90.10.08.11.27.17;  author darren;  state Exp;
branches ;
next     36.25;

36.25
date     90.09.13.18.10.53;  author darren;  state Exp;
branches ;
next     36.24;

36.24
date     90.08.13.11.18.53;  author darren;  state Exp;
branches ;
next     36.23;

36.23
date     90.04.20.09.45.40;  author kodiak;  state Exp;
branches ;
next     36.22;

36.22
date     90.04.13.13.33.00;  author kodiak;  state Exp;
branches ;
next     36.21;

36.21
date     90.04.12.17.06.37;  author kodiak;  state Exp;
branches ;
next     36.20;

36.20
date     90.04.11.17.53.57;  author kodiak;  state Exp;
branches ;
next     36.19;

36.19
date     90.04.02.10.47.44;  author kodiak;  state Exp;
branches ;
next     36.18;

36.18
date     90.03.02.16.22.18;  author kodiak;  state Exp;
branches ;
next     36.17;

36.17
date     89.12.15.17.49.55;  author kodiak;  state Exp;
branches ;
next     36.16;

36.16
date     89.12.15.11.09.12;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     89.12.14.17.03.45;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     89.12.10.11.26.51;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     89.12.04.22.55.46;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     89.12.02.11.37.33;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     89.11.27.12.49.30;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     89.11.07.12.59.02;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     89.11.06.14.19.30;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     89.11.04.16.05.36;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     89.09.15.15.40.01;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     89.08.21.12.59.58;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.07.10.18.19.26;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     89.07.07.13.28.11;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     89.07.05.15.24.38;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     89.06.28.13.35.37;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     88.09.19.10.16.11;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     88.09.06.19.52.44;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


36.49
log
@Now use mask of -1 for cursor drawing to be the same as intuition
cursors, and all around consistent with existing applications.
Suggest bar style cursor for 4.0KS.
@
text
@**
**      $Id: wreset.asm,v 36.48 92/06/16 10:45:15 darren Exp Locker: darren $
**
**      reset and/or resize console unit
**
**      (C) Copyright 1985,1987,1989,1990,1991,1992 Commodore-Amiga, Inc.
**          All Rights Reserved
**
	SECTION	console

**	Includes

	INCLUDE	"cddata.i"

	INCLUDE	"exec/memory.i"

	INCLUDE	"intuition/intuition.i"

	INCLUDE	"debug.i"

**	Exports

	XDEF	WriteReset
	XDEF	ReSizePost
	XDEF	ReSizeUnit


**	Imports

	XLVO	AllocMem		; Exec

	XLVO	ClearRegion		; Graphics
	XLVO	FontExtent		;
	XLVO	OrRectRegion		;

	XLVO	BeginUpdate		; Layers
	XLVO	EndUpdate		;
	XLVO	InstallClipRegion	;

	XREF	LockDRPort
	XREF	UnLockRPort

	XREF	CursDisable
	XREF	CursEnable
	XREF	CursUpdate

	XREF	ClearRaster
	XREF	ClearScreen

	XREF	PackMap			;scroll
	XREF	UnpackMap
	XREF	ScrollYDisplay
	XREF	ResetBuffer

	XREF	InitTabs

	XREF	G0Handler

	XREF	RefreshUnit

	XREF	sgrPrimary

	XREF	FreeBuffer


*------ WriteReset ---------------------------------------------------
*
*   a2	unit data
*
WriteReset:
		movem.l	d2-d5,-(a7)

		bsr	LockDRPort

		move.l	cu_Mask(a2),cd_RastPort+rp_Mask(a6)

		bsr	CursDisable

		bsr	InitTabs

		move.l	#G0Handler,cu_GLHandler(a2)

		clr.w	cu_PState(a2)
		clr.l	cu_XCP(a2)		; also cu_YCP(a2)
		clr.l	cu_DisplayXL(a2)	; also cu_DisplayYL(a2)
		clr.l	cu_XMinShrink(a2)	; also cu_YMinShrink(a2)

		move.w	#9999,d0
		move.w	d0,cu_XRExtant(a2)	; absurdly large so that the
		move.w	d0,cu_YRExtant(a2)	;   GetBorders d6/d7 is used
						;   to clear.

		move.w  d0,cu_FullXRExtant(a2)
		move.w  d0,cu_FullYRExtant(a2)

		or.b	#CUF_CURSON,cu_CursorFlags(a2)	; turn on cursor

		moveq	#PMB_AWM/8,d0
		lea	cu_Modes(a2),a0
wrClrModes:
		clr.b	(a0)+
		dbf	d0,wrClrModes
		bset	#M_LNM&07,cu_Modes+(M_LNM/8)(a2)
		bset	#PMB_ASM&07,cu_Modes+(PMB_ASM/8)(a2)
		bset	#PMB_AWM&07,cu_Modes+(PMB_AWM/8)(a2)

		move.l	cu_Window(a2),a1
		move.l	wd_RPort(a1),a0

		move.b	#0,cu_AOLPen(a2)
		move.l	rp_Font(a0),cu_Font(a2)
		move.w	rp_AlgoStyle(a0),cu_AlgoStyle(a2)	; & TxFlags
		move.l	rp_TxHeight(a0),cu_TxHeight(a2)		; & TxWidth
		move.l	rp_TxBaseline(a0),cu_TxBaseline(a2)	; & TxSpacing

		move.w	cu_TxWidth(a2),d0
		add.w	cu_TxSpacing(a2),d0
		move.w	d0,cu_XRSize(a2)
		move.w	cu_TxHeight(a2),cu_YRSize(a2)

		;--	initialize cu_Flags
		and.b	#CU_RESET0MASK,cu_Flags(a2)

		lea	-te_SIZEOF(a7),a7
		move.l	rp_Font(a0),a0
		move.l	a7,a1
		LINKGFX	FontExtent
		move.w	cu_XRSize(a2),d0
		tst.w	te_Extent+ra_MinX(a7)
		bmi.s	wrHaveKernless		; not kernless
		cmp.w	te_Extent+ra_MaxX(a7),d0
		ble.s	wrHaveKernless		; not kernless within spacing

		bset.b	#CUB_KERNLESS,cu_Flags(a2)

wrHaveKernless:
		lea	te_SIZEOF(a7),a7

		;-- cache bitmap depth (no touch D0!)

		move.l	cu_Window(a2),a0
		move.l	wd_RPort(a0),a1
		move.l	rp_BitMap(a1),a1
		move.b	bm_Depth(a1),cu_Depth(a2)
		
		move.l	wd_WScreen(a0),a1
	;;;	move.w	sc_Flags(a1),d1

		move.b	#$FF,cu_CursorMask(a2)	;all planes by default

	;;;	and.w	#PENSHARED,d1
	;;;	beq.s	wrNotPenShared

	;;;	move.b	#$03,cu_CursorMask(a2)	;pen shared, mask cursor (2 planes)

wrNotPenShared:

	;;;;;
	;; New code to calculate x/y dimensions for char map.
	;;
	;; Uses Intuition Screen size - as of V39 we have interleaved
	;; bitmaps, and the BytesPerRow is bogus (is depth * old
	;; meaning of BytesPerRow)
	;;;;;

		;-- initialize the buffers if necessary
		btst	#0,cu_DevUnit+3(a2)
		beq	wrSetPens

		move.l	wd_Flags(a0),d1

		and.l	#REFRESHBITS,d1
		cmp.l	#SIMPLE_REFRESH,d1
		bne	wrSetPens

		moveq	#7,d2			;get maximum X width
		add.w	sc_Width(a1),d2		;screen width + 7 for rounding
		and.b	#%11111000,d2		;rounded to nearest byte

	;;;	move.l	cd_RastPort+rp_BitMap(a6),a0
	;;;	moveq	#0,d2
	;;;	move.w	bm_BytesPerRow(a0),d2	; get maximum X width
	;;;	lsl.l	#3,d2			; convert to pixels
		divu	d0,d2			; convert to char X locations
		move.w	d2,cu_CM+cm_BufferWidth(a2)
		clr.w	cu_CM+cm_BufferHeight(a2)

		moveq	#0,d3

		move.w	sc_Height(a1),d3

	;;;	move.w	bm_Rows(a0),d3		; get maximum Y height
		divu	cu_YRSize(a2),d3	; convert to char Y locations
		move.w	d3,cu_CM+cm_BufferLines(a2) ; (and save)
		move.w	d3,d0
		addq.w	#1,d0			; get number of char locations,
		mulu	d2,d0			;   which is 1.5 times the
		move.l	d0,d1			;   maximum number displayed
		lsr.l	#1,d1			;   with an extra line thrown
		add.l	d1,d0			;   in.
		move.l	d0,d5

		ext.l	d3
		lsl.l	#3,d3			; two line buffers
		move.l	d3,d4
		add.l	d0,d4			; one char buffer space
		add.l	d0,d4			; and one attr buffer space
		add.l	d0,d4			;

		clr.l	cu_CM+cm_BufferXL(a2)	; also cm_BufferYL

		;--	check if buffer allocation is OK
		cmp.l	cu_CM+cm_AllocSize(a2),d4
		beq.s	wrBufferLines

wrAllocBuffer:
		bsr	FreeBuffer		; free any old ones
		move.l	d4,cu_CM+cm_AllocSize(a2)
		move.l	d4,d0
		moveq	#0,d1

		LINKEXE	AllocMem
		move.l	d0,cu_CM+cm_AllocBuffer(a2)
		beq	wrBufAllocFail

wrBufferLines:
		;--	fill AttrBufLines
		;--	    generate first attribute line address/2
		move.l	cu_CM+cm_AllocBuffer(a2),a0
		add.l	a0,d3
		lsr.l	#1,d3			; Note: Attr index is address/2
		move.l	d3,cu_CM+cm_BufferStart(a2)

		;--	    calculate cm_AttrToChar
		move.l	a0,d0			; calculate char buffer address
		add.l	cu_CM+cm_AllocSize(a2),d0
		sub.l	d5,d0			;   character buffer start
		sub.l	d3,d0
		move.l	d0,cu_CM+cm_AttrToChar(a2)

		;--	    setup for filling cm_BufferLines elements
		move.w	cu_CM+cm_BufferLines(a2),d0
		ext.l	d2			; cm_BufferWidth
		bra.s	wrAttrBufLinesDBF

		;--	    fill array
wrAttrBufLinesLoop:
		move.l	d3,(a0)+
		add.l	d2,d3
wrAttrBufLinesDBF:
		dbf	d0,wrAttrBufLinesLoop

		move.l	a0,cu_CM+cm_AttrDispLines(a2)

wrSetPens:

		;-- FIX!!  Now resets background
		;-- color for a reset

		clr.b	cu_BgColor(a2)
		bclr	#CUFB_FIXEDBG,cu_FixedFlags(a2)

		; Clear all bitplanes this time through

		moveq	#01,d0

		move.b	d0,cu_MinMask(a2)	;1 plane minimum for scrolls
		move.b	d0,cu_ScrollMask(a2)	;reset

		;initialize Primary drawing colors, modes, styles, etc

		move.b	d0,cu_NormFG(a2)		;pen 1
		clr.b	cu_NormBG(a2)			;pen 0
		clr.b	cu_NormStyle(a2)		;flag OFF

		move.b	#RP_JAM2,cu_NormDMode(a2)	;DrawMode

		bsr	sgrPrimary

		bsr	ReSizeUnit

		bclr	#CUB_FIRSTTIME,cu_States(a2)	;clear 1st time

		move.w	cu_XROrigin(a2),cd_RastPort+rp_cp_x(a6)
		move.w	cu_YROrigin(a2),d0
		add.w	cu_TxBaseline(a2),d0
		move.w	d0,cd_RastPort+rp_cp_y(a6)

		bsr	CursUpdate

		bsr	CursEnable

		moveq	#01,d2				;TRUE

wrAbort:
		bsr	UnLockRPort

		move.l	d2,d0				;CC set
		movem.l	(a7)+,d2-d5			;MOVEM (no touch CC)

		rts

wrBufAllocFail:
		bsr	FreeBuffer

	; continue if this is not the first time through this code

		btst	#CUB_FIRSTTIME,cu_States(a2)
		beq.s	wrSetPens

	;
	; else return failure for OpenDevice() - simple refresh without
	; a character map (as requested!) works so lousy, there is
	; little point in trying to use it - better for the user
	;

		moveq	#00,d2				;FAILED
		bra.s	wrAbort

*------ GetBorders ---------------------------------------------------
*
*   a2	unit data
*
*   d6,d7: width, height returned
*
GetBorders:
		move.l	cu_Window(a2),a0
		move.l	wd_Flags(a0),d0
		and.l	#GIMMEZEROZERO,d0
		beq.s	noGimme00

		btst	#CUFB_FIXEDLO,cu_FixedFlags(a2)
		bne.s	fixedXRO00
		clr.w	cu_XROrigin(a2)
fixedXRO00:
		move.w	wd_Width(a0),d6			; width
		move.b	wd_BorderLeft(a0),d1		; left
		ext.w	d1
		sub.w	d1,d6
		move.b	wd_BorderRight(a0),d1
		ext.w	d1
		sub.w	d1,d6
		sub.w	cu_XROrigin(a2),d6

		btst	#CUFB_FIXEDTO,cu_FixedFlags(a2)
		bne.s	fixedYRO00
		clr.w	cu_YROrigin(a2)
fixedYRO00:
		move.w	wd_Height(a0),d7		; height
		move.b	wd_BorderTop(a0),d1		; top
		ext.w	d1
		sub.w	d1,d7
		move.b	wd_BorderBottom(a0),d1
		ext.w	d1
		sub.w	d1,d7
		sub.w	cu_XROrigin(a2),d7
		bra.s	gotBorders

noGimme00:
		btst	#CUFB_FIXEDLO,cu_FixedFlags(a2)
		bne.s	fixedXRO
		move.b	wd_BorderLeft(a0),d1		; left
		ext.w	d1
		move.w	d1,cu_XROrigin(a2)
fixedXRO:
		move.w	wd_Width(a0),d6			; width
		sub.w	cu_XROrigin(a2),d6
		move.b	wd_BorderRight(a0),d1
		ext.w	d1
		sub.w	d1,d6

		btst	#CUFB_FIXEDTO,cu_FixedFlags(a2)
		bne.s	fixedYRO
		move.b	wd_BorderTop(a0),d1		; top
		ext.w	d1
		move.w	d1,cu_YROrigin(a2)
fixedYRO:
		move.w	wd_Height(a0),d7		; height
		sub.w	cu_YROrigin(a2),d7
		move.b	wd_BorderBottom(a0),d1
		ext.w	d1
		sub.w	d1,d7

gotBorders:
		tst.w	d6
		bpl.s	gbBoundD7
		clr.w	d6
gbBoundD7:
		tst.w	d7
		bpl.s	gbRts
		clr.w	d7
gbRts:
		rts


*------ ReSizePost ---------------------------------------------------
*
*   a2	unit data
*
ReSizePost:
		movem.l	d6/d7,-(a7)
		bsr	GetBorders

		cmp.w	cu_XMinShrink(a2),d6
		bge.s	postY
		move.w	d6,cu_XMinShrink(a2)
postY:
		cmp.w	cu_YMinShrink(a2),d7
		bge.s	postPost
		move.w	d7,cu_YMinShrink(a2)
postPost:
		bset	#CUB_RESIZE,cu_Flags(a2)
		movem.l	(a7)+,d6/d7
		rts


*------ ReSizeUnit ---------------------------------------------------
*
*   a2	console unit
*
ReSizeUnit:

		movem.l	d2-d7,-(a7)


	    ;-- pack character map
		tst.l	cu_CM+cm_AllocSize(a2)	; check if map exists
		beq.s	rsuGetBorders		;   no map to pack

		tst.b	cu_SpecialModes(a2)	; maybe no redraw needed
		beq.s	rsuPackMap

		; Use the ResetBuffer call which sorts the off-screen
		; map before clearing BufferXL/YL - there is now
		; nothing left in the off-screen map after this call

		bsr	ResetBuffer

		; lie - say there is nothing in the display either

		bsr	ResetXY

		; We get a real fast pack, and unpack in this case,
		; But we also have to make sure that these selection
		; bits are cleared out since this code won't be
		; executed when the special NODRAW on resize
		; flag is set.

		;	    (packSorted clears selection as side effect)
		bclr	#CUB_SELECTED,cu_Flags(a2)
		beq.s	rsuPackMap

		and.b	#CDS_SELECTMASK,cd_SelectFlags(a6)
		clr.l	cd_SelectedUnit(a6)
		bclr	#CUB_CURSSELECT,cu_CursorFlags(a2)

rsuPackMap:
		bsr	PackMap

rsuGetBorders:

		bsr	GetBorders		; also sets ROrigin

		move.w	#9999,d4		; initialize large
		move.w	d4,d5

	    ;-- clear out right edge if this is buffered or smart refresh
**		tst.l	cu_CM+cm_AllocSize(a2)	; check if buffered
**		bne.s	rsuClearRightEdge

		move.l	cu_Window(a2),a0
		move.l	wd_Flags(a0),d0
		and.l	#REFRESHBITS,d0

		cmpi.l	#SUPER_BITMAP,d0
		beq.s	rsuRebound

	;-- clear out right, and bottom edge (calcing limits below) for
	;-- smart refresh, or even simple refresh which lacks a character map
	;-- 
	;-- Unlike the previous code which tried to do a clear bottom edge
	;-- only for SIMPLE_REFRESH, this also does right edge (why not???),
	;-- but works better because we calc D2/D3 instead of using junk -
	;-- certainly no worse than before this fix which cleared to D2/D3
	;-- which was junk!


	    ;-- clear the right edge
rsuClearRightEdge:
		;-- get the origin of the last destroyed (leftmost) char
		moveq	#0,d0
		move.w	cu_XMinShrink(a2),d0
		move.w	cu_XRSize(a2),d1
		divu	d1,d0
		move.w	d0,d4			; save origin of clearing
		mulu	cu_XRSize(a2),d0
		add.w	cu_XROrigin(a2),d0

		;-- get the lessor of the old x region or the smaller new one
		move.w	d6,d2
		add.w	cu_XROrigin(a2),d2
		subq	#1,d2
		cmp.w	cu_XRExtant(a2),d2
		ble.s	rsucre1
		move.w	cu_XRExtant(a2),d2
rsucre1:
		move.w	cu_YROrigin(a2),d1
		;-- get the lessor of the old y region or the smaller new one
		move.w	d7,d3
		add.w	cu_YROrigin(a2),d3
		subq	#1,d3
		cmp.w	cu_YRExtant(a2),d3
		ble.s	rsucre2
		move.w	cu_YRExtant(a2),d3
rsucre2:
		bsr	ClearRaster

	    ;-- clear out bottom edge
		;-- get the origin of the last destroyed (topmost) char
rsuClearBottomEdge:
		moveq	#0,d1
		move.w	cu_YMinShrink(a2),d1
		move.w	cu_YRSize(a2),d0
		divu	d0,d1
		move.w	d1,d5			; save origin of clearing
		mulu	cu_YRSize(a2),d1
		add.w	cu_YROrigin(a2),d1
		move.w	cu_XROrigin(a2),d0

		bsr	ClearRaster


	;-- rebound the window
rsuRebound:
		bclr	#CUB_TOOSMALL,cu_Flags(a2)
		moveq	#0,d0
		move.w	d6,d0
		move.w	cu_XRSize(a2),d1
		divu	d1,d0
		subq.w	#1,d0
		btst	#CUFB_FIXEDLL,cu_FixedFlags(a2)
		beq.s	xHaveMax
		cmp.w	cu_FixedXMax(a2),d0
		ble.s	xHaveMax
		move.w	cu_FixedXMax(a2),d0
xHaveMax:
		move.w	d0,cu_XMax(a2)
		bpl.s	xExtant
		bset	#CUB_TOOSMALL,cu_Flags(a2)
		bra.s	tooSmallBailOut
xExtant:
		move.w	cu_XMax(a2),d0
		addq.w	#1,d0
		mulu	cu_XRSize(a2),d0
		subq.w	#1,d0
		move.w	cu_XROrigin(a2),d1
		add.w	d1,d0
		move.w	d0,cu_XRExtant(a2)
		move.w	d0,d2

		btst	#CUFB_FIXEDLL,cu_FixedFlags(a2)
		bne.s	maxxedge
		move.w	d6,d2
		add.w	d1,d2
		subq.w	#1,d2
maxxedge:
		move.w	d2,cu_FullXRExtant(a2)
		move.w	d1,cu_ClipRect+ra_MinX(a2)
		move.w	d0,cu_ClipRect+ra_MaxX(a2)

		moveq	#0,d0
		move.w	d7,d0
		move.w	cu_YRSize(a2),d1
		divu	d1,d0
		subq.w	#1,d0
		btst	#CUFB_FIXEDPL,cu_FixedFlags(a2)
		beq.s	yHaveMax
		cmp.w	cu_FixedYMax(a2),d0
		ble.s	yHaveMax
		move.w	cu_FixedYMax(a2),d0
yHaveMax:
		move.w	d0,cu_YMax(a2)
		bpl.s	yExtant
		bset	#CUB_TOOSMALL,cu_Flags(a2)

tooSmallBailOut:
		
		bsr	ResetXY
		clr.l	cu_CursorPattern(a2)	; pattern cleared
						; pattern unknown

		btst	#CUB_FIRSTTIME,cu_States(a2)
		beq	reprimeShrink

**
** These flags are no longer defined -- Darren (cursor kludge removed
** for ROM space V39)
**
**		bclr	#CUB_CURSNDRAW,cu_CursorFlags(a2)
**		bclr	#CUB_CURSQDRAW,cu_CursorFlags(a2)

		tst.l	cu_CM+cm_AllocSize(a2)	; check if buffered
		beq	reprimeShrink

		bsr	UnpackMap
		bra	reprimeShrink

yExtant:

		move.w	cu_YMax(a2),d0
		addq.w	#1,d0
		mulu	cu_YRSize(a2),d0
		subq	#1,d0
		move.w	cu_YROrigin(a2),d1
		add.w	d1,d0
		move.w	d0,cu_YRExtant(a2)
		move.w	d0,d2

		btst	#CUFB_FIXEDPL,cu_FixedFlags(a2)
		bne.s	maxyedge

		move.w	d7,d2
		add.w	d1,d2
		subq.w	#1,d2
maxyedge:
		move.w	d2,cu_FullYRExtant(a2)
		move.w	d1,cu_ClipRect+ra_MinY(a2)
		move.w	d0,cu_ClipRect+ra_MaxY(a2)

	;-- set the ClipRegion
		move.l	cu_ClipRegion(a2),a0
		LINKGFX	ClearRegion
		move.l	cu_ClipRegion(a2),a0
		lea	cu_ClipRect(a2),a1
		LINKGFX	OrRectRegion

		tst.l	cu_CM+cm_AllocSize(a2)	; check if buffered
		beq.s	rsuDisableCursor
		
		;-- refresh unit
		bsr	CursDisable
		bsr	UnpackMap

		;-- install the clip region
		bset.b	#CDB_CLIPINSTALLED,cd_Flags(a6)
		bne.s	rsuRefreshUnit

		move.l	cd_RastPort+rp_Layer(a6),a0
		move.l	cu_ClipRegion(a2),a1
		LINKLAY	InstallClipRegion
		move.l	d0,cd_PrevClipRegion(a6)

rsuRefreshUnit:
		bsr	RefreshUnit

		;-- throw away any damage
		move.l	cd_RastPort+rp_Layer(a6),a0
		move.l	lr_DamageList(a0),d0
		beq.s	rsuNoDamage
		move.l	d0,a0
		LINKGFX	ClearRegion
rsuNoDamage:
		bsr	ThrowAwayDamage


		bra.s	restoreCursor

	;-- disable the cursor, i.e. insure it is not imaged
rsuDisableCursor
		bsr	ThrowAwayDamage

		move.w	cu_XCP(a2),d0
		cmp.w	d0,d4		; check if already cleared
		ble.s	rsuCursorAlreadyClear 
		move.w	cu_YCP(a2),d1
		cmp.w	d1,d5		; check if already cleared
		ble.s	rsuCursorAlreadyClear 
		bsr	CursDisable	; perform a real disable
		bra.s	repositionCursor

rsuCursorAlreadyClear:
		addq.b	#1,cu_CDNestCnt(a2)	; fake a disable
		clr.l	cu_CursorPattern(a2)	; FIX!! - we dont really
						; have a cursor pattern now

	;-- reposition the cursor if this is not a superbitmap window
repositionCursor:
		move.l	cu_Window(a2),a0
		move.l	wd_Flags(a0),d0
		and.l	#SUPER_BITMAP,d0
		bne.s	restoreCursor

		move.w	cu_XCP(a2),d0
		cmp.w	cu_XMax(a2),d0
		ble.s	cursXOK

		;-- FIX!! get rid of double cursors

		addq.w	#1,cu_YCP(a2)
		move.w	cu_XMax(a2),cu_XCP(a2)
		move.w	cu_XMax(a2),cu_XCCP(a2)

cursXOK:
		move.w	cu_YCP(a2),d0
		cmp.w	cu_YMax(a2),d0
		ble.s	restoreCursor

		clr.w	cu_XCP(a2)
		clr.w	cu_XCCP(a2)		;FIX!! for double cursors

		move.w	cu_YMax(a2),cu_YCP(a2)
		move.w	cu_YCP(a2),cu_YCCP(a2)	;FIX as above

		moveq	#1,d0
		bsr	ScrollYDisplay

restoreCursor:
		bsr	CursEnable

reprimeShrink:
		move.w	#9999,cu_XMinShrink(a2)	; absurdly large, yet not large
		move.w	#9999,cu_YMinShrink(a2)	;   enough such that adding a
						;   valid origin makes them go
						;   negative
		
		bclr	#CUB_RESIZE,cu_Flags(a2)

		bclr	#CUB_REFRESH,cu_Flags(a2)

		;save width, and height within lock layers

		move.l	cu_Window(a2),a0
		move.w	wd_Width(a0),cu_WWidth(a2)
		move.w	wd_Height(a0),cu_WHeight(a2)

		movem.l (a7)+,d2-d7
		rts


*------ Throw Away Damage areas ----------------------------------------------
*
*   a2	console unit
*
ThrowAwayDamage:

		move.l	cd_RastPort+rp_Layer(a6),a0
		LINKLAY	BeginUpdate

		move.l	cd_RastPort+rp_Layer(a6),a0
		LINKLAY	EndUpdate
		move.l	cd_RastPort+rp_Layer(a6),a0
		and.w	#~LAYERREFRESH,lr_Flags(a0)
		rts

*------ ResetXY ----------------------------------------------
*
*   a2	console unit
*

ResetXY:
		clr.l	cu_XCP(a2)		; and cu_YCP
		clr.l	cu_XCCP(a2)		; and cu_YCCP
		clr.l	cu_XMax(a2)		; and cu_YMax
		clr.l	cu_DisplayXL(a2)	; and DisplayYL

		rts

	END


@


36.48
log
@Remove clearing of Q & N draw cursor flags
@
text
@d2 1
a2 1
**      $Id: wreset.asm,v 36.47 92/05/27 15:46:51 darren Exp Locker: darren $
a145 1
	;;;	move.l	cu_Window(a2),a0
d147 1
a147 1
		move.w	sc_Flags(a1),d1
d151 2
a152 2
		and.w	#PENSHARED,d1
		beq.s	wrNotPenShared
d154 1
a154 1
		move.b	#$03,cu_CursorMask(a2)	;pen shared, mask cursor (2 planes)
@


36.47
log
@Return failure in wreset() if console map could not be allocated.
Also fix border trash on redraw of simple refresh window without
a map - fall through to code which calculates extent of rectangle
instead of branching around to code which clears bottom border only
(so D2/D3 are now also correct, as are D4/D5 used later on).
@
text
@d2 1
a2 1
**      $Id: wreset.asm,v 36.46 92/05/19 10:10:43 darren Exp Locker: darren $
d596 6
a601 2
		bclr	#CUB_CURSNDRAW,cu_CursorFlags(a2)
		bclr	#CUB_CURSQDRAW,cu_CursorFlags(a2)
@


36.46
log
@Just calc what XR/YRExtant should be IF not in fixed page length/lines
mode.  Do nothing else for now with these, but cache them in new
private variables.  Used for border fill code later on.
@
text
@d2 1
a2 1
**      $Id: wreset.asm,v 36.45 92/05/18 13:04:57 darren Exp Locker: darren $
d222 1
d294 3
d299 2
a300 1
		movem.l	(a7)+,d2-d5
d306 2
a307 1
		bra	wrSetPens
d309 2
d312 9
d469 2
a470 2
		tst.l	cu_CM+cm_AllocSize(a2)	; check if buffered
		bne.s	rsuClearRightEdge
d475 12
a486 2
		cmpi.l	#SMART_REFRESH,d0
		bne.s	rsuCheckSBM
d488 1
a517 1
		bra.s	rsuClearBottomEdge
a518 3
rsuCheckSBM:
		cmpi.l	#SUPER_BITMAP,d0
		beq.s	rsuRebound
@


36.45
log
@Set clip region, and clear up to full border if not in fixed
line length/page length modes.
@
text
@d2 1
a2 1
**      $Id: wreset.asm,v 36.44 92/04/02 15:07:29 darren Exp Locker: darren $
a20 1

d476 1
a476 1
		cmp.w	cu_FullXRExtant(a2),d2
d478 1
a478 1
		move.w	cu_FullXRExtant(a2),d2
d485 1
a485 1
		cmp.w	cu_FullYRExtant(a2),d3
d487 1
a487 1
		move.w	cu_FullYRExtant(a2),d3
a488 1

d536 1
d540 3
a542 3
		move.w	d6,d0
		add.w	d1,d0
		subq.w	#1,d0
d544 1
a544 1
		move.w	d0,cu_FullXRExtant(a2)
d590 1
d595 3
a597 3
		move.w	d7,d0
		add.w	d1,d0
		subq.w	#1,d0
d599 1
a599 1
		move.w	d0,cu_FullYRExtant(a2)
@


36.44
log
@Set Cursor depth mask to 2 planes max if PEN sharing enabled, else
old behavior of all planes
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.43 92/03/26 13:48:06 darren Exp Locker: darren $
d88 4
a91 2
		move.w	#9999,cu_XRExtant(a2)	; absurdly large so that the
		move.w	#9999,cu_YRExtant(a2)	;   GetBorders d6/d7 is used
d94 3
d477 1
a477 1
		cmp.w	cu_XRExtant(a2),d2
d479 1
a479 1
		move.w	cu_XRExtant(a2),d2
d486 1
a486 1
		cmp.w	cu_YRExtant(a2),d3
d488 1
a488 1
		move.w	cu_YRExtant(a2),d3
d538 8
d591 9
@


36.43
log
@Initialize defaults for ESC[0m, ESC[39m, and ESC[49m - are now
variables instead of hard coded constants
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.42 92/03/24 08:54:43 darren Exp Locker: darren $
d135 1
a135 1
		;-- cache bitmap depth
d138 3
a140 3
		move.l	wd_RPort(a0),a0
		move.l	rp_BitMap(a0),a0
		move.b	bm_Depth(a0),cu_Depth(a2)
d142 21
d166 1
a166 1
		move.l	cu_Window(a2),a0
d168 1
a172 8
	;;;;;
	;; New code to calculate x/y dimensions for char map.
	;;
	;; Uses Intuition Screen size - as of V39 we have interleaved
	;; bitmaps, and the BytesPerRow is bogus (is depth * old
	;; meaning of BytesPerRow)
	;;;;;
		move.l	wd_WScreen(a0),a0
d174 1
a174 1
		add.w	sc_Width(a0),d2		;screen width + 7 for rounding
d187 1
a187 1
		move.w	sc_Height(a0),d3
a259 2

		move.b	#3,cu_CursorMask(a2)	;2 planes for highlight
@


36.42
log
@Cache just bitmap depth instead of a mask
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.41 92/03/23 12:48:19 darren Exp $
d206 1
a206 1
		beq.s	wrBufAllocFail
d253 8
@


36.41
log
@Calc 1/2 bitmap depth for determining if scroll mask should be
optimized, or $FF (interleave scrolling needs $FF).  Also
init CursorMask, MinMask, and ScrollMask before sgrPrimary()
so everything is inited/reset at reset time.
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.40 92/03/19 12:50:12 darren Exp Locker: darren $
d135 1
a135 1
		;-- Make a bitmap depth mask [1/2 of actual] (no touch D0)
d140 1
a140 6
		moveq	#-1,d2
		move.b	bm_Depth(a0),d1
		lsl.w	d1,d2
		not.b	d2
		sub.b	d2,d2
		move.b	d2,cu_DepthMask(a2)
@


36.40
log
@Minor change to support optimized scrolling.  
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.39 92/03/16 13:18:46 darren Exp Locker: darren $
d135 12
d211 1
a211 1
		beq	wrBufAllocFail
d252 6
a257 1
		move.b	#1,cu_MinMask(a2)	;1 plane minimum for scrolls
@


36.39
log
@Mask lower 3 bits of # of pixels to avoid allocating 1 extra column of
data for smaller size fonts (e.g., 647+7/6 wide font = 654/6 = 109!  Though
(647+7)&0xF8 = 650 and 650/6 = 108.xxxx.  Infact we could get by with
647/6, which is equal to 107.xxxx, but for now [max compatability], I'll
go with 108, which is closer to the same number we'd get using bm_BytesPerRow
).
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.38 92/03/16 13:00:06 darren Exp Locker: darren $
d199 1
a199 1
		beq.s	wrBufAllocFail
d237 4
@


36.38
log
@Calculate character map dimensions based on screen size.  BytesPerRow is
no longer usable as of V39 graphics (now has interleaved bitmaps, and
that means BytesPerRow can be DEPTH too large for existing calculations)
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.37 91/05/22 13:48:37 darren Exp Locker: darren $
d154 1
@


36.37
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.36 91/02/22 14:24:18 darren Exp Locker: darren $
d6 1
a6 1
**      (C) Copyright 1985,1987,1989,1990 Commodore-Amiga, Inc.
d144 15
a158 4
		move.l	cd_RastPort+rp_BitMap(a6),a0
		moveq	#0,d2
		move.w	bm_BytesPerRow(a0),d2	; get maximum X width
		lsl.l	#3,d2			; convert to pixels
d164 4
a167 1
		move.w	bm_Rows(a0),d3		; get maximum Y height
@


36.36
log
@Now calls ResetBuffer() instead of clearing BufferXL/YL - see Scroll.asm
- the code will call the routine if the window is resized, and redrawing
has been turned off by way of OpenDevice() with a flag value of 1.
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.35 90/12/13 21:43:03 darren Exp Locker: darren $
@


36.35
log
@Fix for double cursor in X direction - non character
mapped windows.
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.34 90/11/20 18:37:09 darren Exp Locker: darren $
d51 1
a51 1
	XREF	PackMap
d54 1
d362 3
a364 2
		; lie - say there is nothing in the display,
		; and nothing in the history buffer
d366 4
a370 1
		clr.l	cu_CM+cm_BufferXL(a2)	; also cm_BufferYL
@


36.34
log
@Fix for a scroll bug - simple refresh windows with no character
map accumulated damage when resized; damage is now thrown away.
Also an enhancement - new flag value can be set to tell console
device you dont want it to redraw after a resize (if units
1, or 3).
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.33 90/11/14 13:37:27 darren Exp Locker: darren $
d594 3
a596 1
		move.w	cu_XCP(a2),cu_XCCP(a2)
a597 2
		addq.w	#1,cu_YCP(a2)
		clr.w	cu_XCP(a2)
@


36.33
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.32 90/11/05 17:45:37 darren Exp Locker: darren $
d358 24
d496 4
a499 6

		clr.l	cu_XCP(a2)	; and cu_YCP
		clr.l	cu_XCCP(a2)	; and cu_YCCP	;FIXED!!!
		clr.l	cu_XMax(a2)	; and cu_YMax
		clr.l	cu_DisplayXL(a2)	;and DisplayYL
		clr.l	cu_CursorPattern(a2)	;FIXED!!!
d558 2
a559 10
		move.l	cd_RastPort+rp_Layer(a6),a0
		LINKLAY	BeginUpdate
*		tst.l	d0
*		beq.s	rsuAbortUpdate
*		moveq	#1,d0
*rsuAbortUpdate:
		move.l	cd_RastPort+rp_Layer(a6),a0
		LINKLAY	EndUpdate
		move.l	cd_RastPort+rp_Layer(a6),a0
		and.w	#~LAYERREFRESH,lr_Flags(a0)
d565 2
d632 29
@


36.32
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.31 90/11/02 08:00:35 darren Exp $
@


36.31
log
@branch.s optimizations
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.30 90/11/01 16:34:27 darren Exp Locker: darren $
@


36.30
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.29 90/11/01 11:24:24 darren Exp Locker: darren $
d125 1
a125 1
		bmi	wrHaveKernless		; not kernless
d183 1
a183 1
		beq	wrBufAllocFail
@


36.29
log
@New input handling code.
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.28 90/10/15 16:00:00 darren Exp Locker: darren $
@


36.28
log
@Additional code added for handling of
windows which are too small to render in.
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.27 90/10/11 15:30:11 darren Exp Locker: darren $
d474 1
a474 5

		;-- Fix, previous, and current are 0 now

		clr.l	cu_XCCP(a2)	; and cu_YCCP

d477 1
a478 4
		;-- Fix, we dont really have a cursor pattern

		clr.l	cu_CursorPattern(a2)

d538 4
a541 4
		tst.l	d0
		beq.s	rsuAbortUpdate
		moveq	#1,d0
rsuAbortUpdate:
d605 2
a607 1
		beq.s	re_nodamage
d609 1
a609 3
		;-- throw away damage - resize just done
		;-- not entirely sure if BeginUpdate() returns a 16
		;-- bit, or 32 value.  Clear D0 just to be sure.
d611 3
a613 3
		moveq	#00,d0
		move.l	cd_RastPort+rp_Layer(a6),a0
		LINKLAY	BeginUpdate
a614 11
		;-- if D0 is false, well, its ok
		;-- we are doing the right thing here
		;-- by calling EndUpdate(l,FALSE)

		move.l	cd_RastPort+rp_Layer(a6),a0
		LINKLAY	EndUpdate

		move.l	cd_RastPort+rp_Layer(a6),a0
		and.w	#~LAYERREFRESH,lr_Flags(a0)

re_nodamage:
@


36.27
log
@Change for a fix to prevent window border
trashing.  No matter who calls
Resize unit, we clear old damage info.
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.26 90/10/08 11:27:17 darren Exp Locker: darren $
d474 5
d482 1
d484 2
d491 3
@


36.26
log
@Fix for background/cell character
handling, and cursor handling when
windows without character maps
are resized.
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.25 90/09/13 18:10:53 darren Exp Locker: darren $
d600 23
d627 2
@


36.25
log
@New, special case handling for 
window too small to start.
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.27 90/09/13 17:06:34 darren Exp $
d215 7
d558 2
d566 1
a566 1
		bne	restoreCursor
d571 5
d584 2
d587 2
@


36.24
log
@Fix for bug:  If window was made very small,
a subsequent resize larger would result in
a confused display map.  DisplayXL/YL are
now cleared if size is set toosmall to
render.
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.23 90/04/20 09:45:40 kodiak Exp $
d19 1
d21 1
d78 1
d183 1
a183 1
		beq.s	wrBufAllocFail
d219 2
d227 1
d238 1
a238 1
		bra.s	wrSetPens
d343 1
d346 1
d354 1
d398 1
d416 1
d465 1
d470 8
d481 1
@


36.23
log
@first semi-tested big clip support
@
text
@d2 1
a2 1
**	$Id: wreset.asm,v 36.22 90/04/13 13:33:00 kodiak Exp Locker: kodiak $
d6 1
a6 1
**      (C) Copyright 1985,1987,1989 Commodore-Amiga, Inc.
d456 2
@


36.22
log
@use Id instead of Header for 4.x rcs
@
text
@d2 1
a2 1
**	$Id$
a78 3

		FLUSHBUFFER	cu_PICBuffer(a2)
		FLUSHBUFFER	cu_PNPBuffer(a2)
@


36.21
log
@bound origin & window size, and move TOOSMALL to just skip graphics rendering
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/wreset.asm,v 36.20 90/04/11 17:53:57 kodiak Exp Locker: kodiak $
@


36.20
log
@bound user specified window limits to actual limits
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/wreset.asm,v 36.19 90/04/02 10:47:44 kodiak Exp Locker: kodiak $
d458 1
@


36.19
log
@for 4.x rcs
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/console/RCS/wreset.asm,v 36.18 90/03/02 16:22:18 kodiak Exp Locker: kodiak $
a414 2
		btst	#CUFB_FIXEDLL,cu_FixedFlags(a2)
		bne.s	xExtant
d420 6
a440 2
		btst	#CUFB_FIXEDPL,cu_FixedFlags(a2)
		bne.s	yExtant
d446 6
@


36.18
log
@hard code bit number for CONUB_CHARMAP equate, which has gone away
@
text
@d2 1
a2 1
**	$Header: wreset.asm,v 36.17 89/12/15 17:49:55 kodiak Exp $
@


36.17
log
@Only InstallClipRegion when necessary
@
text
@d2 1
a2 1
**	$Header: wreset.asm,v 36.16 89/12/15 11:09:12 kodiak Exp $
d135 1
a135 1
		btst	#CONUB_CHARMAP,cu_DevUnit+3(a2)
@


36.16
log
@eliminate damage after resize so redundant refresh doesn't occur
@
text
@d2 1
a2 1
**	$Header: wreset.asm,v 36.15 89/12/14 17:03:45 kodiak Exp $
d32 1
a89 1
		and.b	#CU_RESET0MASK,cu_Flags(a2)
d103 1
a103 1
		move.l	wd_RPort(a1),a1
d106 4
a109 4
		move.l	rp_Font(a1),cu_Font(a2)
		move.w	rp_AlgoStyle(a1),cu_AlgoStyle(a2)	; & TxFlags
		move.l	rp_TxHeight(a1),cu_TxHeight(a2)		; & TxWidth
		move.l	rp_TxBaseline(a1),cu_TxBaseline(a2)	; & TxSpacing
d116 18
d470 7
d478 3
d486 1
a486 6
		tst.l	cu_CM+cm_AllocSize(a2)	; check if buffered
		beq.s	rsuDisableCursor
		
		;-- refresh unit
		bsr	CursDisable
		bsr	UnpackMap
a546 4

		move.l	cd_RastPort+rp_Layer(a6),a0
		move.l	cd_PrevClipRegion(a6),a1
		LINKLAY	InstallClipRegion
@


36.15
log
@different damage refresh strategy: should always clear damage
@
text
@d2 1
a2 1
**	$Header: wreset.asm,v 36.14 89/12/10 11:26:51 kodiak Exp $
d34 3
a36 1
	XLVO	InstallClipRegion	; Layers
d461 1
d465 19
@


36.14
log
@fix Esc-c
@
text
@d2 1
a2 1
**	$Header: wreset.asm,v 36.13 89/12/04 22:55:46 kodiak Exp $
d22 3
a24 3
	XDEF		WriteReset
	XDEF		ReSizePost
	XDEF		ReSizeUnit
a461 1
		bclr	#CUB_REFRESH,cu_Flags(a2)
@


36.13
log
@checkin for release on Monday 4 Dec -- map w/ indirect line buffers
@
text
@d2 1
a2 1
**	$Header: wreset.asm,v 36.12 89/12/02 11:37:33 kodiak Exp $
d82 1
d149 2
@


36.12
log
@
@
text
@d2 1
a2 1
**	$Header: wreset.asm,v 36.11 89/11/27 12:49:30 kodiak Exp $
d168 1
@


36.11
log
@first cut at line buffers
@
text
@d2 1
a2 1
**	$Header: wreset.asm,v 36.10 89/11/07 12:59:02 kodiak Exp $
d9 1
d11 1
a11 1
	SECTION		rawinput
d13 1
a13 1
*------ Included Files -----------------------------------------------
d15 1
a15 1
	INCLUDE		"cddata.i"
d17 1
a17 1
	INCLUDE		"exec/memory.i"
a18 1
	INCLUDE		"intuition/intuition.i"
d20 1
d22 3
a24 1
*------ Imported Names -----------------------------------------------
d26 3
d36 2
a37 2
	XREF		LockDRPort
	XREF		UnLockRPort
d39 3
a41 3
	XREF		CursDisable
	XREF		CursEnable
	XREF		CursUpdate
d43 2
a44 2
	XREF		ClearRaster
	XREF		ClearScreen
d46 3
a48 3
	XREF		PackMap
	XREF		UnpackMap
	XREF		ScrollYDisplay
d50 1
a50 1
	XREF		InitTabs
d52 1
a52 1
	XREF		G0Handler
d54 1
a54 1
	XREF		RefreshUnit
d56 1
a56 1
	XREF		sgrPrimary
d58 1
a58 1
	XREF		FreeBuffer
a60 7
*------ Exported Functions -------------------------------------------

	XDEF		WriteReset
	XDEF		ReSizePost
	XDEF		ReSizeUnit


d66 1
a66 1
		movem.l	d2-d4,-(a7)
d140 1
a140 1
		move.l	d0,cm_Elements(a2)
d143 1
a143 1
		lsl.l	#4,d3			; four line buffers
d163 2
d168 9
a176 1
		ext.l	d2
d178 1
a178 1
		move.w	d0,d1
d180 2
d188 1
a188 9
		move.l	cu_CM+cm_AllocBuffer(a2),a1
		add.l	cu_CM+cm_AllocSize(a2),a1
		sub.l	cu_CM+cm_Elements(a2),a1
		bra.s	wrCharBufLinesDBF
wrCharBufLinesLoop:
		move.l	a1,(a0)+
		add.l	d2,a1
wrCharBufLinesDBF:
		dbf	d1,wrCharBufLinesLoop
d205 1
a205 1
		movem.l	(a7)+,d2-d4
@


36.10
log
@add cm_BufferMaxHeight
clear REFRESH bit (but this still isn't all right) after resize's refresh
@
text
@d2 1
a2 1
**	$Header: wreset.asm,v 36.9 89/11/06 14:19:30 kodiak Exp $
d52 1
a52 1
	XREF		FreeBuffers
d131 11
a141 9
		moveq	#0,d4
		move.w	bm_Rows(a0),d4		; get maximum Y height
		divu	cu_YRSize(a2),d4	; convert to char Y locations
		move.w	d4,cu_CM+cm_BufferMaxHeight(a2) ; (and save)
		addq.w	#1,d4			; get number of char locations,
		mulu	d2,d4			;   which is 1.5 times the
		move.w	d4,d2			;   maximum number displayed
		lsr.w	#1,d2			;   with an extra line thrown
		add.w	d2,d4			;   in.
d143 7
d151 2
a152 4
		move.l	cu_CM+cm_AttrBuffer(a2),a0 ; preload for clearing
		cmp.w	cu_CM+cm_Elements(a2),d4
		beq.s	wrClearBuffer
		bsr	FreeBuffers		; free any old ones
d154 3
a156 1
		move.w	d4,cu_CM+cm_Elements(a2)
d160 1
a160 1
		move.l	d0,cu_CM+cm_CharBuffer(a2)
a161 7
		move.l	d4,d0
		add.l	d0,d0
		move.l	#MEMF_CLEAR,d1		; no need to clear below
		LINKEXE	AllocMem
		move.l	d0,cu_CM+cm_AttrBuffer(a2)
		beq.s	wrBufAllocFail
		bra.s	wrSetPens
d163 13
a175 4
wrClearBufferLoop:
		clr.w	(a0)+
wrClearBuffer:
		dbf	d4,wrClearBufferLoop
d177 10
d207 1
a207 1
		bsr	FreeBuffers
d316 1
a316 1
		tst.w	cu_CM+cm_Elements(a2)	; check if map exists
d328 1
a328 1
		tst.w	cu_CM+cm_Elements(a2)	; check if buffered
d449 1
a449 1
		tst.w	cu_CM+cm_Elements(a2)	; check if buffered
@


36.9
log
@better resizing cursor placement
@
text
@d2 1
a2 1
**	$Header: wreset.asm,v 36.8 89/11/04 16:05:36 kodiak Exp $
d134 1
d434 1
@


36.8
log
@first near-to-working resize/remap code
@
text
@d2 1
a2 1
**	$Header$
d28 2
d421 6
d430 1
d433 1
a433 1
		bra.s	reprimeShrink
d473 4
@


36.7
log
@handle case where resize creates area too small to render characters into
@
text
@d1 8
a8 42
	TTL    '$Header: wreset.asm,v 36.6 89/08/21 12:59:58 kodiak Exp $'
**********************************************************************
*
*			--------------
*   wreset.asm		CONSOLE DEVICE	reset a console unit
*			--------------
*
*   Copyright 1985, 1987 Commodore-Amiga Inc.
*
*   Source Control	$Locker: kodiak $
*
*   $Log:	wreset.asm,v $
*   Revision 36.6  89/08/21  12:59:58  kodiak
*   first cut at keeping highlight/select information in attribute array
*   
*   Revision 36.5  89/07/10  18:19:26  kodiak
*   work on cursor rendering in superbitmap window
*   
*   Revision 36.4  89/07/07  13:28:11  kodiak
*   move CursEnable so super bitmap windows have a cursor
*   
*   Revision 36.3  89/07/05  15:24:38  kodiak
*   cu_BufferSize is UWORD (was ULONG)
*   use public CONUB_CHARMAP unit flag equate
*   
*   Revision 36.2  89/06/28  13:35:37  kodiak
*   implement TOOSMALL flag for windows too small to render into
*   rework cursor initialization
*   
*   Revision 36.1  88/09/19  10:16:11  kodiak
*   add character map and pseudo-clipboard support
*   
*   Revision 36.0  88/09/06  19:52:44  kodiak
*   *** empty log message ***
*   
*   Revision 35.1  87/10/26  12:58:19  kodiak
*   Change rendering strategy to use a single shared device RastPort
*   
*   Revision 35.0  87/10/26  11:14:21  kodiak
*   initial from V34, but w/ stripped log
*   
**********************************************************************
d23 1
a23 1
	XREF_EXE	AllocMem
d25 2
a26 2
	XREF_GFX	ClearRegion
	XREF_GFX	OrRectRegion
a33 1
	XREF		ScrollYDisplay
d36 1
d38 4
d46 2
d126 2
a127 3
		addq.w	#1,d2			; ensure it's even
		and.w	#$fffe,d2		;   for blitter use
		move.w	d2,cu_BufferWidth(a2)
d132 5
a136 2
		move.w	d4,cu_BufferHeight(a2)
		mulu	d2,d4			; get number of char locations
d139 2
a140 2
		move.l	cu_AttrBuffer(a2),a0	; preload for clearing
		cmp.w	cu_BufferSize(a2),d4
d144 1
a144 1
		move.w	d4,cu_BufferSize(a2)
d148 1
a148 1
		move.l	d0,cu_CharBuffer(a2)
d154 1
a154 1
		move.l	d0,cu_AttrBuffer(a2)
d286 1
a286 1
*   a2	unit data
d291 7
a299 1
	    ;-- set defaults for cleared character positions
d302 3
a304 3
	    ;-- clear out right edge if this is a smart refresh window
	    ;	or buffered
		tst.w	cu_BufferSize(a2)	; check if buffered
d306 1
d360 1
d419 7
d427 1
d430 1
a430 1
		ble.s	alreadyCleared 
d433 1
a433 1
		ble.s	alreadyCleared 
d437 1
a437 1
alreadyCleared:
d440 1
a441 1
	;-- reposition the cursor if this is not a superbitmap window
d455 1
a455 1
		ble.s	cursYOK
a460 56

cursYOK:
	;-- clear obsolete areas of the character map
		move.w	cu_BufferSize(a2),d6	; check if buffered
		beq.s	restoreCursor

		move.w	cu_XMax(a2),d2
		move.w	cu_YMax(a2),d5
	    ;-- ensure the selection is correctly bounded
	IFNE	0	;!!!
		btst	#CUB_SELECTING,cu_Flags(a2)
		beq.s	rsuClrMap
		cmp.w	cd_SelectionStartX(a6),d2
		bge.s	rsuChkSelEndX
		move.w	d2,cd_SelectionStartX(a6)
rsuChkSelEndX:
		cmp.w	cd_SelectionEndX(a6),d2
		bge.s	rsuChkSelStartY
		move.w	d2,cd_SelectionEndX(a6)
rsuChkSelStartY:
		cmp.w	cd_SelectionStartY(a6),d5
		bge.s	rsuChkSelEndY
		move.w	d5,cd_SelectionStartY(a6)
rsuChkSelEndY:
		cmp.w	cd_SelectionEndY(a6),d5
		bge.s	rsuClrMap
		move.w	d5,cd_SelectionEndY(a6)
	ENDC
	    ;-- clear the character map
rsuClrMap:
		move.l	cu_AttrBuffer(a2),a0
		moveq	#0,d0		; running buffer offset
		moveq	#0,d1		; running row
		addq.w	#1,d2
		move.w	cu_BufferWidth(a2),d3
		moveq	#0,d4		; running line end offset
rsuClrRightMapBumpY:
		cmp.w	d5,d1
		bgt.s	rsuClrBottomMapLoop
		addq.w	#1,d1		; next row
		add.w	d2,d0
		add.w	d2,a0
		add.w	d2,a0
		add.w	d3,d4
rsuClrRightMapLoop:
		cmp.w	d4,d0
		bge.s	rsuClrRightMapBumpY
		clr.w	(a0)+
		addq.w	#1,d0
		bra.s	rsuClrRightMapLoop
rsuClrBottomMapLoop:
		cmp.w	d6,d0
		bge.s	restoreCursor
		clr.w	(a0)+
		addq.w	#1,d0
		bra.s	rsuClrBottomMapLoop
@


36.6
log
@first cut at keeping highlight/select information in attribute array
@
text
@d1 1
a1 1
	TTL    '$Header: wreset.asm,v 36.5 89/07/10 18:19:26 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 3
d90 1
a90 1
*   A2	unit data
d95 1
a95 1
		BSR	LockDRPort
d97 1
a97 1
		MOVE.L	cu_Mask(A2),cd_RastPort+rp_Mask(A6)
d99 2
a100 2
		BSR	CursDisable
		BSR	InitTabs
d102 1
a102 1
		MOVE.L	#G0Handler,cu_GLHandler(A2)
d104 2
a105 2
		FLUSHBUFFER	cu_PICBuffer(A2)
		FLUSHBUFFER	cu_PNPBuffer(A2)
d107 5
a111 5
		CLR.W	cu_PState(A2)
		CLR.L	cu_XCP(A2)		; also cu_YCP(A2)
		CLR.L	cu_XMinShrink(A2)	; also cu_YMinShrink(A2)
		MOVE.W	#9999,cu_XRExtant(A2)	; absurdly large so that the
		MOVE.W	#9999,cu_YRExtant(A2)	;   GetBorders D6/D7 is used
d113 1
a113 1
		and.b	#CU_RESET0MASK,cu_Flags(A2)
d117 2
a118 2
		MOVEQ	#PMB_AWM/8,D0
		LEA	cu_Modes(A2),A0
d120 5
a124 5
		CLR.B	(A0)+
		DBF	D0,wrClrModes
		BSET	#M_LNM&07,cu_Modes+(M_LNM/8)(A2)
		BSET	#PMB_ASM&07,cu_Modes+(PMB_ASM/8)(A2)
		BSET	#PMB_AWM&07,cu_Modes+(PMB_AWM/8)(A2)
d130 4
a133 4
		MOVE.L	rp_Font(A1),cu_Font(A2)
		MOVE.W	rp_AlgoStyle(A1),cu_AlgoStyle(A2)	; & TxFlags
		MOVE.L	rp_TxHeight(A1),cu_TxHeight(a2)		; & TxWidth
		MOVE.L	rp_TxBaseline(A1),cu_TxBaseline(A2)	; & TxSpacing
d135 4
a138 4
		MOVE.W	cu_TxWidth(A2),d0
		ADD.W	cu_TxSpacing(A2),d0
		MOVE.W	D0,cu_XRSize(A2)
		MOVE.W	cu_TxHeight(A2),cu_YRSize(A2)
d190 1
a190 1
		BSR	sgrPrimary
d192 1
a192 1
		BSR	ReSizeUnit
d194 4
a197 4
		MOVE.W	cu_XROrigin(A2),cd_RastPort+rp_cp_x(A6)
		MOVE.W	cu_YROrigin(A2),D0
		ADD.W	cu_TxBaseline(A2),D0
		MOVE.W	D0,cd_RastPort+rp_cp_y(A6)
d199 2
a200 2
		BSR	CursUpdate
		BSR	CursEnable
d202 1
a202 1
		BSR	UnLockRPort
d206 1
a206 1
		RTS
d215 1
a215 1
*   A2	unit data
d217 1
a217 1
*   D6,D7: width, height returned
d220 4
a223 4
		MOVE.L	cu_Window(A2),A0
		MOVE.L	wd_Flags(A0),D0
		AND.L	#GIMMEZEROZERO,D0
		BEQ.S	noGimme00
d225 3
a227 3
		BTST	#CUFB_FIXEDLO,cu_FixedFlags(A2)
		BNE.S	fixedXRO00
		CLR.W	cu_XROrigin(A2)
d229 8
a236 8
		MOVE.W	wd_Width(A0),D6			; width
		MOVE.B	wd_BorderLeft(A0),D1		; left
		EXT.W	D1
		SUB.W	D1,D6
		MOVE.B	wd_BorderRight(A0),D1
		EXT.W	D1
		SUB.W	D1,D6
		SUB.W	cu_XROrigin(A2),D6
d238 3
a240 3
		BTST	#CUFB_FIXEDTO,cu_FixedFlags(A2)
		BNE.S	fixedYRO00
		CLR.W	cu_YROrigin(A2)
d242 9
a250 9
		MOVE.W	wd_Height(A0),D7		; height
		MOVE.B	wd_BorderTop(A0),D1		; top
		EXT.W	D1
		SUB.W	D1,D7
		MOVE.B	wd_BorderBottom(A0),D1
		EXT.W	D1
		SUB.W	D1,D7
		SUB.W	cu_XROrigin(A2),D7
		BRA.S	gotBorders
d253 5
a257 5
		BTST	#CUFB_FIXEDLO,cu_FixedFlags(A2)
		BNE.S	fixedXRO
		MOVE.B	wd_BorderLeft(A0),D1		; left
		EXT.W	D1
		MOVE.W	D1,cu_XROrigin(A2)
d259 5
a263 5
		MOVE.W	wd_Width(A0),D6			; width
		SUB.W	cu_XROrigin(A2),D6
		MOVE.B	wd_BorderRight(A0),D1
		EXT.W	D1
		SUB.W	D1,D6
d265 5
a269 5
		BTST	#CUFB_FIXEDTO,cu_FixedFlags(A2)
		BNE.S	fixedYRO
		MOVE.B	wd_BorderTop(A0),D1		; top
		EXT.W	D1
		MOVE.W	D1,cu_YROrigin(A2)
d271 5
a275 5
		MOVE.W	wd_Height(A0),D7		; height
		SUB.W	cu_YROrigin(A2),D7
		MOVE.B	wd_BorderBottom(A0),D1
		EXT.W	D1
		SUB.W	D1,D7
d286 1
a286 1
		RTS
d291 1
a291 1
*   A2	unit data
d294 2
a295 2
		MOVEM.L	D6/D7,-(A7)
		BSR	GetBorders
d297 3
a299 3
		CMP.W	cu_XMinShrink(A2),D6
		BGE.S	postY
		MOVE.W	D6,cu_XMinShrink(A2)
d301 3
a303 3
		CMP.W	cu_YMinShrink(A2),D7
		BGE.S	postPost
		MOVE.W	D7,cu_YMinShrink(A2)
d305 3
a307 3
		BSET	#CUB_RESIZE,cu_Flags(A2)
		MOVEM.L	(A7)+,D6/D7
		RTS
d312 1
a312 1
*   A2	unit data
d315 1
a315 1
		MOVEM.L	D2-D7,-(A7)
d317 1
a317 1
		BSR	GetBorders		; also sets ROrigin
d326 5
a330 5
		MOVE.L	cu_Window(A2),A0
		MOVE.L	wd_Flags(A0),D0
		AND.L	#REFRESHBITS,D0
		CMPI.L	#SMART_REFRESH,D0
		BNE.S	rsuCheckSBM
d335 7
a341 7
		MOVEQ	#0,D0
		MOVE.W	cu_XMinShrink(A2),D0
		MOVE.W	cu_XRSize(A2),D1
		DIVU	D1,D0
		MOVE.W	D0,D4			; save origin of clearing
		MULU	cu_XRSize(A2),D0
		ADD.W	cu_XROrigin(A2),D0
d344 6
a349 6
		MOVE.W	D6,D2
		ADD.W	cu_XROrigin(A2),D2
		SUBQ	#1,D2
		CMP.W	cu_XRExtant(A2),D2
		BLE.S	rsucre1
		MOVE.W	cu_XRExtant(A2),D2
d351 1
a351 1
		MOVE.W	cu_YROrigin(A2),D1
d353 6
a358 6
		MOVE.W	D7,D3
		ADD.W	cu_YROrigin(A2),D3
		SUBQ	#1,D3
		CMP.W	cu_YRExtant(A2),D3
		BLE.S	rsucre2
		MOVE.W	cu_YRExtant(A2),D3
d360 1
a360 1
		BSR	ClearRaster
d364 1
a364 1
		CMPI.L	#SUPER_BITMAP,D0
d369 9
a377 9
		MOVEQ	#0,D1
		MOVE.W	cu_YMinShrink(A2),D1
		MOVE.W	cu_YRSize(A2),D0
		DIVU	D0,D1
		MOVE.W	D1,D5			; save origin of clearing
		MULU	cu_YRSize(A2),D1
		ADD.W	cu_YROrigin(A2),D1
		MOVE.W	cu_XROrigin(A2),D0
		BSR	ClearRaster
d381 9
a389 8
		BTST	#CUFB_FIXEDLL,cu_FixedFlags(A2)
		BNE.S	xExtant
		MOVEQ	#0,D0
		MOVE.W	D6,D0
		MOVE.W	cu_XRSize(A2),D1
		DIVU	D1,D0
		SUBQ.W	#1,D0
		MOVE.W	D0,cu_XMax(A2)
d392 1
d394 7
a400 7
		MOVE.W	cu_XMax(A2),D0
		ADDQ.W	#1,D0
		MULU	cu_XRSize(A2),D0
		SUBQ.W	#1,D0
		move.W	cu_XROrigin(A2),D1
		ADD.W	d1,D0
		MOVE.W	D0,cu_XRExtant(A2)
d404 8
a411 8
		BTST	#CUFB_FIXEDPL,cu_FixedFlags(A2)
		BNE.S	yExtant
		MOVEQ	#0,D0
		MOVE.W	D7,D0
		MOVE.W	cu_YRSize(A2),D1
		DIVU	D1,D0
		SUBQ.W	#1,D0
		MOVE.W	D0,cu_YMax(A2)
d414 5
d420 7
a426 7
		MOVE.W	cu_YMax(A2),D0
		ADDQ.W	#1,D0
		MULU	cu_YRSize(A2),D0
		SUBQ	#1,D0
		move.W	cu_YROrigin(A2),D1
		ADD.W	d1,D0
		MOVE.W	D0,cu_YRExtant(A2)
d438 8
a445 8
		MOVE.W	cu_XCP(A2),D0
		CMP.W	D0,D4		; check if already cleared
		BLE.S	alreadyCleared 
		MOVE.W	cu_YCP(A2),D1
		CMP.W	D1,D5		; check if already cleared
		BLE.S	alreadyCleared 
		BSR	CursDisable	; perform a real disable
		BRA.S	repositionCursor
d448 1
a448 1
		ADDQ.B	#1,cu_CDNestCnt(A2)	; fake a disable
d452 4
a455 4
		MOVE.L	cu_Window(A2),A0
		MOVE.L	wd_Flags(A0),D0
		AND.L	#SUPER_BITMAP,D0
		BNE	reprimeShrink
d457 5
a461 5
		MOVE.W	cu_XCP(A2),D0
		CMP.W	cu_XMax(A2),D0
		BLE.S	cursXOK
		ADDQ.W	#1,cu_YCP(A2)
		CLR.W	cu_XCP(A2)
d463 3
a465 3
		MOVE.W	cu_YCP(A2),D0
		CMP.W	cu_YMax(A2),D0
		BLE.S	cursYOK
d467 4
a470 4
		CLR.W	cu_XCP(A2)
		MOVE.W	cu_YMax(A2),cu_YCP(A2)
		MOVEQ	#1,D0
		BSR	ScrollYDisplay
d475 1
a475 1
		beq.s	reprimeShrink
d523 1
a523 1
		bge.s	reprimeShrink
d528 3
d532 2
a533 4
		BSR	CursEnable

		MOVE.W	#9999,cu_XMinShrink(A2)	; absurdly large, yet not large
		MOVE.W	#9999,cu_YMinShrink(A2)	;   enough such that adding a
d536 2
a537 2
		MOVEM.L (A7)+,D2-D7
		RTS
@


36.5
log
@work on cursor rendering in superbitmap window
@
text
@d1 1
a1 1
	TTL    '$Header: wreset.asm,v 36.4 89/07/07 13:28:11 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker: kodiak $
d13 3
d470 1
d488 1
@


36.4
log
@move CursEnable so super bitmap windows have a cursor
@
text
@d1 1
a1 1
	TTL    '$Header: wreset.asm,v 36.3 89/07/05 15:24:38 kodiak Exp $'
d13 3
a58 1
	XREF		CursInit
d93 1
d109 1
a109 1
		bsr	CursInit
@


36.3
log
@cu_BufferSize is UWORD (was ULONG)
use public CONUB_CHARMAP unit flag equate
@
text
@d1 1
a1 1
	TTL    '$Header: wreset.asm,v 36.2 89/06/28 13:35:37 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 4
a456 2
		BSR	CursEnable

d511 2
@


36.2
log
@implement TOOSMALL flag for windows too small to render into
rework cursor initialization
@
text
@d1 1
a1 1
	TTL    '$Header: wreset.asm,v 36.1 88/09/19 10:16:11 kodiak Exp $'
d13 4
d56 1
a56 1
	XREF		ScrollYText
d128 1
a128 1
		btst	#0,cu_DevUnit+3(a2)
d153 1
a153 1
		cmp.l	cu_BufferSize(a2),d4
d157 1
a157 1
		move.l	d4,cu_BufferSize(a2)
d311 1
a311 1
		tst.l	cu_BufferSize(a2)	; check if buffered
d450 1
a450 1
		BSR	ScrollYText
d456 1
a456 1
		move.l	cu_BufferSize(a2),d6	; check if buffered
@


36.1
log
@add character map and pseudo-clipboard support
@
text
@d1 1
a1 1
	TTL    '$Header: wreset.asm,v 36.0 88/09/06 19:52:44 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker: kodiak $
d13 3
d46 1
a46 1
	XREF		UnLockDRPort
d48 1
d80 1
a81 1
		MOVE.L	cu_AreaPtrn(A2),cd_RastPort+rp_AreaPtrn(A6)
a82 1
		BSR	CursDisable
d96 4
a99 1
		MOVE.B	#CUF_CURSON,cu_Flags(A2)
d185 1
a185 1
		BSR	UnLockDRPort
d372 2
d393 2
@


36.0
log
@*** empty log message ***
@
text
@d1 1
a1 1
	TTL    '$Header: wreset.asm,v 35.1 87/10/26 12:58:19 kodiak Exp $'
d10 1
a10 1
*   Source Control	$Locker:  $
d13 3
d30 2
d37 2
d42 2
a43 2
	XREF		TakeRPort
	XREF		DropRPort
d48 1
a48 1
	XREF		ScrollText
d58 1
d60 1
d73 3
a75 1
		BSR	TakeRPort
d117 50
d179 4
a182 1
		BSR	DropRPort
d185 3
d189 1
d202 1
a202 1
		BTST	#CUB_FIXEDLO,cu_Flags(A2)
d206 1
a206 1
		MOVE.W	wd_Width(A0),D0			; width
d209 1
a209 1
		SUB.W	D1,D0
d212 2
a213 3
		SUB.W	D1,D0
		SUB.W	cu_XROrigin(A2),D0
		MOVE.W	D0,D6
d215 1
a215 1
		BTST	#CUB_FIXEDTO,cu_Flags(A2)
d219 1
a219 1
		MOVE.W	wd_Height(A0),D0			; height
d222 1
a222 1
		SUB.W	D1,D0
d225 2
a226 3
		SUB.W	D1,D0
		SUB.W	cu_XROrigin(A2),D0
		MOVE.W	D0,D7
d230 1
a230 1
		BTST	#CUB_FIXEDLO,cu_Flags(A2)
d236 2
a237 2
		MOVE.W	wd_Width(A0),D0			; width
		SUB.W	cu_XROrigin(A2),D0
d240 1
a240 2
		SUB.W	D1,D0
		MOVE.W	D0,D6
d242 1
a242 1
		BTST	#CUB_FIXEDTO,cu_Flags(A2)
d248 2
a249 2
		MOVE.W	wd_Height(A0),D0			; height
		SUB.W	cu_YROrigin(A2),D0
d252 1
a252 2
		SUB.W	D1,D0
		MOVE.W	D0,D7
d255 8
d296 7
a302 1
	;-- clear out any dross if this is a smart refresh window
d307 1
a307 1
		BNE.S	cbe
d310 1
d325 1
a325 1
		BLE.S	cre1
d327 1
a327 1
cre1:
d334 1
a334 1
		BLE.S	cre2
d336 1
a336 1
cre2:
d338 1
d340 6
a345 2
	    ;-- get the origin of the last destroyed (topmost) char
cbe:
d357 2
a358 1
		BTST	#CUB_FIXEDLL,cu_Flags(A2)
d377 1
a377 1
		BTST	#CUB_FIXEDPL,cu_Flags(A2)
d421 1
a421 1
		BNE.S	noReposition
d435 2
a436 3
		MOVEQ	#0,D0
		MOVEQ	#1,D1
		BSR	ScrollText
d441 54
a494 1
noReposition:
@
