head     1.2;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @@;


1.2
date     90.04.06.16.02.49;  author dale;  state Exp;
branches ;
next     1.1;

1.1
date     89.09.16.09.39.26;  author dale;  state Exp;
branches ;
next     ;


desc
@@


1.2
log
@new RCS
@
text
@
*******************************************************************************
*
*	$Header:
*
*******************************************************************************
;	Copyright 1986, Gene H. Olson
;	All Rights Reserved.

;	:ts=8 bk=0 ma=1

	idnt	CXADJ5

	include	"float.i"

	xdef	_CXADJ5		; Adjust after multiply/divide

	xref	_CXUNF5		; Underflow handler
	xref	_CXOVF5		; Overflow handler


;**************************************************************
;**	Adjust exponent and mantissa after multiply/divide    *
;**************************************************************

;**	Entry:
;**		d0,d1 = multiply/divide mantissa
;**		d4 = result sign
;**		d5 = result exponent
;**	Exit:
;**		d0,d1 = floating point result
;**	Uses:
;**		d2

_CXADJ5:

;**	Denormalize 1 bit if necessary.
;DEBUG	equ 1

	ifd	DEBUG
	move.l	d0,-(sp)
	move.l	d1,-(sp)
	addq.l	#8,sp
	endc

	btst	#25,d0
	beq.s	adj10
;	cmp.l	#$02000000,d0	; Need to shift right?
;	blt.s	adj10		; - no

	lsr.l	#1,d0		; Shift right
	roxr.l	#1,d1

	tst.w	d5		; Check exponent
	bge.s	adj20		; - normalized
	bra.s	adj11

;*****
;*****	Handle underflow.
;*****

adj10:
	sub.w	#16,d5		; Adjust exponent
	bge.s	adj20		; - normalized

;*****	Form denormalize shift count.

adj11:
	neg.w	d5		; Negate exponent
	lsr.w	#4,d5		; Form shift count
	add.w	#4,d5

;**	Check for underflow

	cmp.w	#57,d5		; Shift count > 57 ?
	ble.s	adj13		; - no

	bra	_CXUNF5		; - underflow

;**	Normalize 16 bit chunks

adj12:
	move.w	d0,d1		; Shift right 16
	clr.w	d0
	swap	d0
	swap	d1

adj13:
	sub.w	#16,d5		; Shift count > 16 ?
	bgt.s	adj12		; - no

	add.w	#16,d5

;**	Denormalize 1-16 bits

	move.l	d0,d2		; Shift right by count
	lsr.l	d5,d0
	ror.l	d5,d2
	lsr.l	d5,d1
	eor.l	d0,d2
	eor.l	d2,d1

;**	Do final rounding.  It is possible that the rounding
;**	will overflow into the exponent position.  That's okay
;**	and gives the correct result.

;	kill rounding dale
;	moveq	#0,d2		; Round
;	addx.l	d2,d1
;	addx.l	d2,d0

	swap	d0		; Add sign
	eor.w	d4,d0
	swap	d0
	rts			; return

;*****
;*****	Process normalized result.
;*****

adj20:

;**	Shift and round.

	move.l	d0,d2		; Shift right 4
	lsr.l	#4,d0
	ror.l	#4,d2
	lsr.l	#4,d1
	eor.l	d0,d2
	eor.l	d2,d1

;	kill round, dale
;	moveq	#0,d2		; Round
;	addx.l	d2,d1
;	addx.l	d2,d0

;**	Form magnitude result.  The previous round may have
;**	overflowed into the exponent field.  However this still
;**	gives the correct result if the exponent is added
;**	arithmetically, and the hidden bit subtracted out.

	swap	d0
	add.w	d5,d0		; Add in exponent

	cmp.w	#$7ff0,d0	; Did it overflow?
	blt.s	adj21		; - no

	bra	_CXOVF5		; Overflow

;**	Form final result

adj21:
	eor.w	d4,d0		; Add sign
	swap	d0
	rts

	end
@


1.1
log
@Initial revision
@
text
@@
