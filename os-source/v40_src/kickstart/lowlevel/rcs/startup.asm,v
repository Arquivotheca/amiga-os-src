head     40.21;
branch   ;
access   ;
symbols  V40_35:40.20 rel40_34:40.19 rel40_33:40.19 rel40_32:40.17 rel40_29:40.17 rel40_28:40.17 rel40_27:40.16 rel40_26:40.16 rel40_25:40.15 rel40_24:40.14 rel40_23:40.14 rel40_22:40.13 rel40_21:40.13 rel40_20:40.12 rel40_19:40.11 rel40_18:40.10 rel40_17:40.10 rel40_16:40.10 rel40_15:40.9 rel40_14:40.8 rel40_13:40.7 rel40_12:40.6 rel40_11:40.5 rel40_4:40.0 rel40_3:40.0 rel40_2:39.13 rel40_1:39.13 rel39_7:39.12 rel39_6:39.9 rel39_5:39.8 rel39_4:39.6 rel39_3:39.5 rel39_2:39.4 rel39_1:39.3;
locks    ; strict;
comment  @* @;


40.21
date     93.07.30.16.26.50;  author vertex;  state Exp;
branches ;
next     40.20;

40.20
date     93.07.30.16.09.03;  author vertex;  state Exp;
branches ;
next     40.19;

40.19
date     93.05.21.11.17.44;  author gregm;  state Exp;
branches ;
next     40.18;

40.18
date     93.05.18.15.02.59;  author gregm;  state Exp;
branches ;
next     40.17;

40.17
date     93.05.05.09.55.45;  author gregm;  state Exp;
branches ;
next     40.16;

40.16
date     93.04.21.09.54.58;  author Jim2;  state Exp;
branches ;
next     40.15;

40.15
date     93.04.20.14.18.59;  author Jim2;  state Exp;
branches ;
next     40.14;

40.14
date     93.04.19.13.38.57;  author Jim2;  state Exp;
branches ;
next     40.13;

40.13
date     93.04.14.14.12.59;  author Jim2;  state Exp;
branches ;
next     40.12;

40.12
date     93.04.13.15.35.09;  author Jim2;  state Exp;
branches ;
next     40.11;

40.11
date     93.04.06.12.34.47;  author Jim2;  state Exp;
branches ;
next     40.10;

40.10
date     93.03.31.18.57.11;  author Jim2;  state Exp;
branches ;
next     40.9;

40.9
date     93.03.26.17.38.02;  author Jim2;  state Exp;
branches ;
next     40.8;

40.8
date     93.03.23.14.48.03;  author Jim2;  state Exp;
branches ;
next     40.7;

40.7
date     93.03.19.11.38.48;  author Jim2;  state Exp;
branches ;
next     40.6;

40.6
date     93.03.15.16.28.08;  author Jim2;  state Exp;
branches ;
next     40.5;

40.5
date     93.03.12.20.12.08;  author Jim2;  state Exp;
branches ;
next     40.4;

40.4
date     93.03.10.19.56.19;  author Jim2;  state Exp;
branches ;
next     40.3;

40.3
date     93.03.10.12.25.17;  author Jim2;  state Exp;
branches ;
next     40.2;

40.2
date     93.03.08.10.52.40;  author Jim2;  state Exp;
branches ;
next     40.1;

40.1
date     93.03.02.13.32.24;  author Jim2;  state Exp;
branches ;
next     40.0;

40.0
date     93.02.19.17.47.31;  author Jim2;  state Exp;
branches ;
next     39.13;

39.13
date     93.01.29.17.47.12;  author Jim2;  state Exp;
branches ;
next     39.12;

39.12
date     93.01.19.15.48.08;  author Jim2;  state Exp;
branches ;
next     39.11;

39.11
date     93.01.18.13.40.23;  author Jim2;  state Exp;
branches ;
next     39.10;

39.10
date     93.01.15.14.07.18;  author Jim2;  state Exp;
branches ;
next     39.9;

39.9
date     93.01.13.15.01.14;  author Jim2;  state Exp;
branches ;
next     39.8;

39.8
date     93.01.07.15.59.08;  author Jim2;  state Exp;
branches ;
next     39.7;

39.7
date     93.01.07.14.31.43;  author Jim2;  state Exp;
branches ;
next     39.6;

39.6
date     93.01.05.12.16.08;  author Jim2;  state Exp;
branches ;
next     39.5;

39.5
date     92.12.17.18.18.23;  author Jim2;  state Exp;
branches ;
next     39.4;

39.4
date     92.12.14.15.03.57;  author Jim2;  state Exp;
branches ;
next     39.3;

39.3
date     92.12.11.14.17.25;  author Jim2;  state Exp;
branches ;
next     39.2;

39.2
date     92.12.09.18.16.57;  author Jim2;  state Exp;
branches ;
next     39.1;

39.1
date     92.12.08.16.50.48;  author Jim2;  state Exp;
branches ;
next     39.0;

39.0
date     92.12.07.16.08.39;  author Jim2;  state Exp;
branches ;
next     ;


desc
@This is the startup code for the game library.
@


40.21
log
@CHanged the way DISK_BASED is referenced
@
text
@******************************************************************************
*
*       $Id: startup.asm,v 40.20 93/07/30 16:09:03 vertex Exp Locker: vertex $
*
******************************************************************************
*
*       $Log:	startup.asm,v $
* Revision 40.20  93/07/30  16:09:03  vertex
* Autodoc and include cleanup
*
* Revision 40.19  93/05/21  11:17:44  gregm
* Added a moveq #0,d0 to GetLanguageSelection().  Otherwise, garbage would've filled
* the top 24 bits.
*
* Revision 40.18  93/05/18  15:02:59  gregm
* Jim was doing a CDREbootDefault() at Init time.
* Jerry informed me that the CD_INFO command won't return realisitic
* information for the default reboot behavior until well after that time.
* I now set the field to a negative value, and the first time someone
* tries to set the value, I do the query then (first) to find the
* current, or perceived default setting.
*
* Revision 40.17  93/05/05  09:55:45  gregm
* init code for port 2, 3 added, plus init code for clearing the RJP jump vectors.
*
* Revision 40.16  93/04/21  09:54:58  Jim2
* Reserved space for six additional vectors at the end of
* the jump table.
*
* Revision 40.15  93/04/20  14:18:59  Jim2
* Finally got around to updating the end label to reflect
* lowlevel rather than game.
*
* Revision 40.14  93/04/19  13:38:57  Jim2
* Played around with the comments.  Moved the storing of
* the original EasyRequest vector to the memory turd.
*
* Revision 40.13  93/04/14  14:12:59  Jim2
* Oops forgot to save a2 in SetLanguageSelection
*
* Revision 40.12  93/04/13  15:35:09  Jim2
* Changed the priority to 1 to allow ram kicking.
*
* Revision 40.11  93/04/06  12:34:47  Jim2
* Made the expunge code safe for the ROM version.
*
* Revision 40.10  93/03/31  18:57:11  Jim2
* Added code to support the VBlank counter for graphic <40.
* Also for closing graphic.library on an expunge (CI103).
* Adding the port stuff to CDDefault means it must be moved
* to after the setting up of the port.
*
* Revision 40.9  93/03/26  17:38:02  Jim2
* Open the PotGo resource at init time.  Also use the VBlank
* counter in graphics base (V40 and beyond).
*
* Revision 40.8  93/03/23  14:48:03  Jim2
* Corrected name for VBlank interrupts.
*
* Revision 40.7  93/03/19  11:38:48  Jim2
* Made allowances for a seperate disk base version of the library
* which has to be able to run on processesor that do not have
* 68020s or better.  Sucked in the joyport initialization and expunge code.
* The ROM version does not contain the expunge code.
*
* Revision 40.6  93/03/15  16:28:08  Jim2
* Fixed error in SetLanguageSelection.
*
* Revision 40.5  93/03/12  20:12:08  Jim2
* Actually made SetLanguageSelection not crash.
*
* Revision 40.4  93/03/10  19:56:19  Jim2
* Got expunge to work and managed to leave something in memory
* so we don't need to clean up the setfunction on EasyRequest.
*
* Revision 40.3  93/03/10  12:25:17  Jim2
* Let strap read the languages out of nonvolatile into utilitybase.
*
* Revision 40.2  93/03/08  10:52:40  Jim2
* Added accessing the nonvolatile memory to get the language.
* Set function of EasyRequest as a means of killing the system
* requesters.
*
* Revision 40.1  93/03/02  13:32:24  Jim2
* Changed all but the end reference from game to lowlevel.
* Removed the anim calls.
*
* Revision 40.0  93/02/19  17:47:31  Jim2
* First instruction is now moveq.l #-1 not #0.
*
* Revision 39.13  93/01/29  17:47:12  Jim2
* Added the ROMTAG flag RTF_COLDSTART.  This allows the library to
* be found prior to DOS running.
*
* Revision 39.12  93/01/19  15:48:08  Jim2
* Language is stored in UtilBase not GameBase.
*
* Revision 39.11  93/01/18  13:40:23  Jim2
* Changed method for determining CD default behavior.  Expunges
* all ReadJoyPort allocations.
*
* Revision 39.10  93/01/15  14:07:18  Jim2
* Removed SetKeyThresh, SetKeyPeriod and SetTimerInterval.
* Added LVOs for AddVBlankInt and RemVBlankInt.
*
* Revision 39.9  93/01/13  15:01:14  Jim2
* Removed KeyboardInterruptExtender.  Intialized the structures
* used for autorepeat of the keyboard.
*
* Revision 39.8  93/01/07  15:59:08  Jim2
* Added intitialization of port controller state.
*
* Revision 39.7  93/01/07  14:31:43  Jim2
* Cleaned up comments, minimized include file list and changed
* the initial LVO table back to relative.
*
* Revision 39.6  93/01/05  12:16:08  Jim2
* Added keyboard support.  Also renamed some routines to
* make them nicer sounding.  And moved ReadJoyPort to first
* non-standard function.
*
* Revision 39.5  92/12/17  18:18:23  Jim2
* Added LVOs for working with CIA timer interrupts.  Also
* changed the names for the routines dealing with the animation.
* And added the LVO for elapsed time.
*
* Revision 39.4  92/12/14  15:03:57  Jim2
* During testing had difficulty with relative offsets for the LVOs.
* Changed to absolute.
*
* Revision 39.3  92/12/11  14:17:25  Jim2
* Removed all of the currently implemented LVO other than
* the standard four:  open, close, expunge, and extra.
*
* Revision 39.2  92/12/09  18:16:57  Jim2
* Got the autodoc comments added and implemented the LVO for
* TurnOffRequesters.
*
* Revision 39.1  92/12/08  16:50:48  Jim2
* Now it actually opens, closes, expunges and TakeOverSystem.
*
* Revision 39.0  92/12/07  16:08:39  Jim2
* Initial release prior to testing.
*
*
*       (C) Copyright 1992,1993 Commodore-Amiga, Inc.
*           All Rights Reserved
*
******************************************************************************

        INCLUDE 'exec/macros.i'
        INCLUDE 'exec/lists.i'
        INCLUDE 'exec/resident.i'
        INCLUDE 'exec/libraries.i'
        INCLUDE 'exec/initializers.i'
        INCLUDE 'exec/ports.i'
        INCLUDE 'exec/memory.i'
        INCLUDE 'exec/execbase.i'

        INCLUDE 'graphics/gfxbase.i'

        INCLUDE 'intuition/preferences.i'

        INCLUDE 'utility/utility.i'

        INCLUDE 'devices/timer.i'

        INCLUDE 'hardware/cia.i'
        INCLUDE 'hardware/custom.i'
        INCLUDE 'hardware/intbits.i'

        INCLUDE 'resources/potgo.i'

        INCLUDE 'a/JoyPortInternal.i'
        INCLUDE 'macros.i'
        INCLUDE 'lowlevel.i'
        INCLUDE 'lowlevelbase.i'                ;Library base.
        INCLUDE 'lowlevel_rev.i'                ;Version string.

                XREF    _custom
                                ;a/SystemControl.asm
                XREF    SystemControlA
                                ;a/Timer.asm
                XREF    RemTimerInt
                XREF    AddTimerInt
                XREF    StopTimerInt
                XREF    StartTimerInt
                XREF    ElapsedTime
        IFD     MC68000
                XREF    ElapsedTime000
        ENDC
                XREF    CIAARESOURCE
                                ;a/ReadJoyPort.asm
                XREF    ReadJoyPort
                XREF    RJP_VBlank_Int
                XREF    SetJoyPortAttrs
                                ;a/Keyboard.asm
                XREF    GetKey
                XREF    QueryKeys
                XREF    AddKBInt
                XREF    RemKBInt
                XREF    KeyboardInterruptExtender
                                ;a/VBlank.asm
                XREF    AddVBlankInt
                XREF    RemVBlankInt
                                ;a/CDReboot.asm
                XREF    CDRebootDefault
                                ;a/Requesters.asm
                XREF    KillReq
                XREF    RestoreReq
                                ;EndMarker.ob
                XREF    LowLevel_end            ;Label placed at the end of the library at link time.

                                ;Amiga.lib
                XREF    _LVOElapsedTime
                XREF    _LVOEasyRequestArgs

                XREF	_LVOFreeNVData
*
*******************************************************************************
*
* Just a block to prevent illegal entry...
*
                moveq   #-1,d0
                rts
*
*******************************************************************************
*
* Also used for the Reserved function...
*
entry_reserved: moveq   #0,d0
                rts

*
*******************************************************************************
*
initLDescrip:
                dc.w    RTC_MATCHWORD   ; RT_MATCHWORD
                dc.l    initLDescrip    ; RT_MATCHTAG
                dc.l    LowLevel_end    ; RT_ENDSKIP
                dc.b    RTF_COLDSTART|RTF_AUTOINIT      ; RT_FLAGS
                dc.b    VERSION         ; RT_VERSION
                dc.b    NT_LIBRARY      ; RT_TYPE
                dc.b    1               ; RT_PRI
                dc.l    subsysName      ; RT_NAME
                dc.l    VERSTR          ; RT_IDSTRING
                dc.l    inittable       ; RT_INIT
*
*******************************************************************************
*
inittable:      dc.l ll_SIZE
                dc.l vectors
                dc.l initStruct
                dc.l initFunc
*
*******************************************************************************
*
* Define the vectors as needed...
*
V_DEF           MACRO
                DC.W    entry_\1-vectors
                ENDM
VEC_DEF         MACRO
                DC.W    \1+(*-vectors)
                ENDM

vectors:
                DC.W    -1
                V_DEF   open
                V_DEF   close
                V_DEF   expunge
                V_DEF   reserved
                VEC_DEF ReadJoyPort
                VEC_DEF GetLanguageSelection
                VEC_DEF SetLanguageSelection
                VEC_DEF GetKey
                VEC_DEF QueryKeys
                VEC_DEF AddKBInt
                VEC_DEF RemKBInt
                VEC_DEF SystemControlA
                VEC_DEF AddTimerInt
                VEC_DEF RemTimerInt
                VEC_DEF StopTimerInt
                VEC_DEF StartTimerInt
                VEC_DEF ElapsedTime
                VEC_DEF AddVBlankInt
                VEC_DEF RemVBlankInt
                VEC_DEF KillReq
                VEC_DEF RestoreReq
                VEC_DEF SetJoyPortAttrs
                V_DEF   reserved
                V_DEF   reserved
                V_DEF   reserved
                V_DEF   reserved
                V_DEF   reserved
                DC.W    -1

initStruct:
                INITWORD        LIB_REVISION,REVISION
                INITBYTE        ll_TaskPri,100
                DC.L    0

*****l* Startup.asm/initFunc *************************************************
*
*   NAME
*       initFunc - Initialization function for a graphic library structure
*
*   SYNOPSIS
*       InitLib = SystemControlA (LibBase, SegList, ExecBase)
*       D0                        D0       A1       A6
*
*   FUNCTION
*       After handling the standard library intialization the lowlevel library
*       specific initialization is done.
*
*   INPUTS
*       LibBase - Pointer to the memory allocated for the library base.
*       SegList - Pointer to the memory allocated and loaded with the
*                 library code.
*       ExecBase - Pointer to the base of exec.library.
*
*   RESULT
*       Either returns the library base if sucessful, or NULL if there is
*       a problem in intialization.
*
******************************************************************************
initFunc:       movem.l d7/a5/a6,-(sp)          ;Need two address registers.
                move.l  d0,a5                   ;Get library base into a5.
                move.l  a6,ll_ExecBase(a5)      ;Store ExecBase.
                move.l  a0,ll_SegList(a5)       ;Save seglist.


                                ;lowlevel library specific initialization.
        IFD     MC68000
                move.w  AttnFlags(a6),d0
                and.w   #AFF_68020!AFF_68030!AFF_68040,d0
                bne.s   2$
                                ;Replace 68020 ElapsedTime with 68000 ElapsedTime
                move.l  a5,a1
                move.w  #_LVOElapsedTime,d0     ;load a function offset
                lea     ElapsedTime000(pc),a0   ;load a the replacement function POINTER
                exg     a0,d0
                JSRLIB  SetFunction             ;do the magic
2$:
        ENDC
                lea     POTGORESOURCE(pc),a1
                JSRLIB  OpenResource
                move.l  d0,ll_PotGoResource(a5) ;Get a pointer to the POTGO resource.
                                ;
                                ;Initialize the structures for handling the
                                ;reading of the ports.  This includes the structures
                                ;used in InstallInputMap() and the GamePort
                                ;VBlank interrupt replacement.
                                ;
                move.b  #JP_STATUSF_FIRST_INIT_REQ,ll_Port0State+lljp_Status(a5)
                move.b  #JP_STATUSF_FIRST_INIT_REQ,ll_Port1State+lljp_Status(a5)
                moveq.l #0,d0
                move.l  d0,ll_Port0State+lljp_RJPVector(a5)
                move.l  d0,ll_Port1State+lljp_RJPVector(a5)
                move.l  d0,ll_Port2State+lljp_RJPVector(a5)
                move.l  d0,ll_Port3State+lljp_RJPVector(a5)
                lea     ll_Port0State+lljp_AddSafely(a5),a0
                JSRLIB  InitSemaphore
                lea     ll_Port1State+lljp_AddSafely(a5),a0
                JSRLIB  InitSemaphore
                lea.l   ll_MsgPortSemaphore(a5),a0
                JSRLIB  InitSemaphore
                move.b  #NT_INTERRUPT,ll_RJP_Vblank_IS+LN_TYPE(a5)
                move.l  LN_NAME(a5),ll_RJP_Vblank_IS+LN_NAME(a5)
                lea     RJP_VBlank_Int(pc),a1
                move.l  a1,ll_RJP_Vblank_IS+IS_CODE(a5)
                move.l  a5,ll_RJP_Vblank_IS+IS_DATA(a5)
                moveq   #-1,d0
                                ;Nesting counts start at -1.
                move.b  d0,ll_NestOwn(a5)
                move.b  d0,ll_NestReq(a5)
                move.b  d0,ll_NestKillIn(a5)
                move.b  d0,ll_Port0State+lljp_NestCnt(a5)
                move.b  d0,ll_Port1State+lljp_NestCnt(a5)
                move.w  d0,ll_LastKey+2(a5)     ;LastKey set to FF.
                                ;
                                ;Set up the structures used in controlling the
                                ;extended keyboard interrupt.
                                ;
                move.b  #NT_INTERRUPT,ll_KBExtend+LN_TYPE(a5)
                move.l  LN_NAME(a5),ll_KBExtend+LN_NAME(a5)
                move.l  a5,ll_KBExtend+IS_DATA(a5)      ;Data is the lowlevel.library base.
                lea     KeyboardInterruptExtender(pc),a1
                move.l  a1,ll_KBExtend+IS_CODE(a5)
                lea     ll_KBInterrupts(a5),a1
                NEWLIST a1                      ;Initialize the list of user keyboard interrupts.
                                ;
                                ;In order to kill all requesters we actually need
                                ;to patch intuition.  Since intuition does not
                                ;expunge there is no need to hold it open after
                                ;we get the information we need.
                                ;However, since it is bad form to un-SetFunction
                                ;we leave the patch in memory.  Since we occasionally
                                ;need a port structure, the patch is stuck onto
                                ;a port.  This makes it possible to find it.
                                ;
                move.l  LN_NAME(a5),a1
                JSRLIB  FindPort
                move.l  d0,ll_ERSetFunction(a5)
                bne.w   SetFunced               ;If we found our port, then we have the setfunction data.

                move.l  #llsf_Size+VERSTR-subsysName,d0
                move.l  #MEMF_CLEAR,d1
                JSRLIB  AllocMem                ;Get the memory required for the port and patch.
                move.l  d0,ll_ERSetFunction(a5)
                beq     init_fail
                                ;Got enough memory.  Initialize the port.
                move.l  d0,a1
                move.l  #PA_IGNORE,MP_FLAGS(a1)
                move.b  #-1,LN_PRI(a1)
                lea     MP_MSGLIST(a1),a0
                NEWLIST a0
                move.l  a1,-(sp)
                lea     llsf_Size(a1),a0
                move.l  a0,LN_NAME(a1)
                move.l  LN_NAME(a5),a1
CopyName:       move.b  (a1)+,(a0)+             ;Copy the name of the library to the port.
                bne.s   CopyName
                                ;
                                ;Name is all copied.  The port initialization is
                                ;now complete.  So let's add the port to the public
                                ;list.  Then we can start on the patch.
                                ;
                move.l  (sp)+,a1
                JSRLIB  AddPort
                lea     IntuitionName(pc),a1
                move.l  #37,d0                  ;Any version.
                JSRLIB  OpenLibrary
                tst.l   d0                      ;EasyRequest does not exist before v37 in Intuition.
                beq.w   init_fail               ;If NULL, we failed!

                move.l  ll_ERSetFunction(a5),a1
                lea     llsf_RTS(a1),a0         ;The code must be complete before we
                move.l  a0,llsf_Routine(a1)     ;SetFunction, so just RTS immediately.
                move.l  #$2F3AFFFA,llsf_Move(a1)
                move.w  #$7000,llsf_Clear(a1)
                move.w  #$4E75,llsf_RTS(a1)
                lea     llsf_Move(a1),a1
                move.l  #_LVOEasyRequestArgs,a0
                exg     d0,a1
                movem.l d0/a0/a1,-(sp)
                JSRLIB  CacheClearU             ;We've just created code in the data cache, flush them.
                movem.l (sp)+,d0/a0/a1
                JSRLIB  SetFunction
                move.l  ll_ERSetFunction(a5),a1
                move.l  d0,llsf_Original(a1)
                move.l  d0,llsf_Routine(a1)     ;Change the patch to point at the orginal vector.
                JSRLIB  CacheClearU             ;We've just changed code in the data cache, flush.
SetFunced:                      ;EasyRequest is now properly SetFunctioned.
                lea     UtilName(pc),a1         ;"utility.library"
                JSRLIB  OldOpenLibrary
                move.l  d0,ll_UtilBase(a5)      ;Store utility base
                beq.w   init_fail               ;If NULL, we failed!
                                ;
                                ;Found and opened Utility Library.
                                ;ReadJoyPort() needs a counter for VBlanks.
                                ;
                lea     GFXNAME(pc),a1
                move.l  #40,d0
                JSRLIB  OpenLibrary
                tst.l   d0                      ;There is a VBlank counter in v40 of graphics.

        IFGT     DISK_BASED
                                ;
                                ;If we are disk based then we need to be able to
                                ;fall back if graphics v40 is not present.
                                ;
                bne.s   init_UseGFX
                                ;The fallback is adding yet another VBlank interrupt.
                lea     ll_VBlankCNTR(a5),a1
                move.b  #NT_INTERRUPT,LN_TYPE(a1)
                move.l  LN_NAME(a5),LN_NAME(a1) ;Yet something else sharing the name of the library.
                lea     VBlankCNTR(pc),a0
                move.l  a0,IS_CODE(a1)
                lea     ll_VBlankCount(a5),a0
                move.l  a0,IS_DATA(a1)
                moveq   #INTB_VERTB,d0
                JSRLIB  AddIntServer
                lea     ll_VBlankCount(a5),a1   ;Move the address of the actual counter into a1.
                bra.s   init_SetVBCntr
        ELSE
                                ;Fail if we are ROM and graphics v40 is not present.
                beq.w   init_NoCounter
        ENDC

init_UseGFX:    move.l  d0,a0
                lea     gb_VBCounter(a0),a1     ;Set a1 to point to the actual counter.
init_SetVBCntr: move.l  a1,ll_VBCounter(a5)     ;Save the address of the counter into the library base.
*                bsr     CDRebootDefault         ;Establish the default behaviour of the system for when the CD is removed.
                move.w  #-1,ll_DefaultCDReboot(a5) ; flag it as "unknown"
                                ;Need some temporary variables.
TEMP_SIZE       set     0
                ARRAYVAR Request,IOTV_SIZE
                ALLOCLOCALS sp                  ;Need a timerrequest to open the timer device.
                lea     TIMERDEVICE(pc),a0
                move.l  sp,a1
                move.l  #UNIT_MICROHZ,d0
                moveq   #0,d1
                JSRLIB  OpenDevice              ;Open the microhz timer.
                tst.b   d0                      ;Test the return value from OpenDevice.
                                ;Successful open of timer.device.
                bne.s   NoTimer
                move.l  Request+IO_DEVICE(sp),a6
                move.l  a6,ll_TimerDevice(a5)   ;Save the pointer to the timer device.
                move.l  sp,a0
                JSRLIB  ReadEClock
                move.l  d0,ll_EClockConversion(a5)      ;Get the number of E clocks per second.
                                ;Open keyboard.device.  Reuse the timerrequest.
                move.l  ll_ExecBase(a5),a6
                lea     KEYBDEVICE(pc),a0
                move.l  sp,a1                   ;Still have temporary variables on the stack.
                moveq   #0,d0
                move.l  d0,d1
                JSRLIB  OpenDevice              ;Open keyboard.device.
                tst.b   d0                      ;Test the return value from OpenDevice.
                bne.s   NoKeyBoard
                                ;Successful open of keyboard.device.
                move.l  Request+IO_DEVICE(sp),ll_KBDevice(a5)
                                ;
                                ;CIAA resource timer B_SP is used by keyboard.device.
                                ;the interrupt attached there is the keyboard
                                ;interrupt.  AddICRVector to this timer will return
                                ;a pointer to the interrupt structure.
                                ;
                lea     CIAARESOURCE(pc),a1
                JSRLIB  OpenResource
                move.l  d0,a6
                move.w  #CIAICRB_SP,d0
                JSRLIB  AddICRVector
                move.l  d0,ll_KBOrig(a5)        ;Save the normal keyboard interrupt.
                move.l  d0,a1
                move.w  #CIAICRB_SP,d0
                JSRLIB  RemICRVector            ;Remove the keyboard interrupt service routine.
                lea     ll_KBExtend(a5),a1
                move.w  #CIAICRB_SP,d0
                JSRLIB  AddICRVector            ;Replace it with ours.
                move.l  a5,d0                   ;Set return value
                DONELOCALS sp                   ;Clear the stack.
                bra.s   init_go

NoKeyBoard:                     ;Could not open keyboard.device, however ...
                                ;timer.device was opened so close it before failing.

                move.l  ll_TimerDevice(a5),Request+IO_DEVICE(sp)
                move.l  sp,a1
                JSRLIB  CloseDevice             ;Close the microhz timer.
NoTimer:                        ;Timer.device is not open, however...
                DONELOCALS sp                   ;Clear the stack.
init_NoCounter:                 ;utility.libary was opened so close it before failing.
                move.l  ll_UtilBase(a5),a1
                JSRLIB  CloseLibrary            ;Close the utility library.
init_fail:      moveq   #0,d0                   ;Mark failure.
init_go         movem.l (sp)+,d7/a5/a6          ;Restore the address registers.
                rts

*****l* Startup.asm/entry_open ***********************************************
*
*   NAME
*       entry_open - Open the lowlevel library.
*
*   SYNOPSIS
*       LowLevelBase = entry_open(LowLevelBase)
*       D0                        A6
*
*   FUNCTION
*       Increments the library count and returns the pointer to the
*       library base.
*
*   INPUTS
*       LowLevelBase - Pointer to the base of the LowLevel library.
*
*   RESULT
*       Returns the library base.
*
******************************************************************************
entry_open:
                addq.w  #1,LIB_OPENCNT(a6)      ;Count the open
                move.l  a6,d0                   ;Return library base
                rts

*****l* Startup.asm/entry_close **********************************************
*
*   NAME
*       entry_close - Close the lowlevel library.
*
*   SYNOPSIS
*       entry_close(LowLevelBase)
*                   A6
*
*   FUNCTION
*       Decrements the library count.
*
*       This library does not autoexpunge.
*
*   INPUTS
*       LowLevelBase - Pointer to the base of the low level library.
*
*   RESULT
*       NONE
*
*
******************************************************************************
entry_close:    subq.w  #1,LIB_OPENCNT(a6)      ;Count the close
                moveq   #0,d0
                rts

*****l* Startup.asm/entry_expunge ********************************************
*
*   NAME
*       entry_expunge - Remove the lowlevel library from memory.
*
*   SYNOPSIS
*       entry_expunge(LowLevelBase)
*                     A6
*
*   FUNCTION
*       All of library specific resources are returned.  Then the library
*       size is calculated and the library is removed from the list of
*       libraries and the memory for the library is freed.
*
*       The ROM based version of this library cannot be expunged.
*
*   INPUTS
*       LowLevelBase - Pointer to the base of the LowLevel library.
*
*   RESULT
*       NONE
*
******************************************************************************
entry_expunge:

                moveq   #0,d0

        IFGT    DISK_BASED
                tst.w   LIB_OPENCNT(a6)         ;Check if Zero opens.
                bne.w   expunge_done            ;If non-zero, we don't go

                movem.l a5-a6,-(sp)             ;Need a couple of address registers.
                move.l  a6,a5
                move.l  ll_ExecBase(a5),a6
                lea     CIAARESOURCE(pc),a1
                JSRLIB  OpenResource
                move.l  d0,a6
                move.w  #CIAICRB_SP,d0
                lea     ll_KBExtend(a5),a1
                JSRLIB  RemICRVector            ;Remove our keyboard service routine.
                move.l  ll_KBOrig(a5),a1
                move.l  #CIAICRB_SP,d0
                JSRLIB  AddICRVector            ;Put back the original keyboard service routine.
                move.l  ll_ExecBase(a5),a6
                move.l  ll_UtilBase(a5),a1
                JSRLIB  CloseLibrary            ;Close utility.library.
                                ;
                                ;If we added our own VBlank handler let's remove it.
                                ;If not we ought to be good and close graphics.
                                ;
                lea     GFXNAME(pc),a1
                move.l  #40,d0
                JSRLIB  OpenLibrary
                tst.l   d0
                beq.s   RemoveVBCNTR            ;Our handler was added iff graphics v40 could not be opened.
                                ;
                                ;If we could open graphics v40, then we need to close
                                ;it twice.  Once for this open and once for the open
                                ;at our init time.
                                ;
                move.l  d0,-(sp)
                move.l  d0,a1
                JSRLIB  CloseLibrary
                move.l  (sp)+,a1
                JSRLIB  CloseLibrary
                bra.s   DoneVBCNTR

RemoveVBCNTR:   lea     ll_VBlankCNTR(a5),a1
                moveq   #INTB_VERTB,d0
                JSRLIB  RemIntServer            ;Remove our VBlank handler
DoneVBCNTR:

TEMP_SIZE       set     0
                ARRAYVAR Request,IOTV_SIZE
                ALLOCLOCALS sp                  ;Need a timerrequest to close the timer device.
                move.l  ll_TimerDevice(a5),Request+IO_DEVICE(sp)
                move.l  sp,a1
                JSRLIB  CloseDevice             ;Close the microhz timer.
                move.l  ll_KBDevice(a5),Request+IO_DEVICE(sp)
                move.l  sp,a1
                JSRLIB  CloseDevice             ;Close keyboard.device.
                DONELOCALS sp                   ;Clear the stack.
                                ;Clean up any mischief caused by ReadJoyPort().
                bclr    #JP_STATUSB_VBLANK_ACQUIRED,ll_Port0State+lljp_Status(a5)
                beq.s   4$                      ;Did we replace the gameport VBlank interrupt.

                moveq   #INTB_VERTB,d0
                lea     ll_RJP_Vblank_IS(a5),a1
                JSRLIB  RemIntServer            ;Remove our replacement.
                moveq   #INTB_VERTB,d0
                move.l  ll_RJP_Saved_IS(a5),a1
                JSRLIB  AddIntServer            ;Restore the orginal.
                bset    #JP_STATUSB_FIRST_INIT_REQ,ll_Port0State+lljp_Status(a5)        ;Do not try to return the POTGO bits.
4$:             move.l  ll_PotGoResource(a5),a6
                btst    #JP_STATUSB_FIRST_INIT_REQ,ll_Port0State+lljp_Status(a5)
                bne.s   ee_NotAlloc0            ;Were the Potgo bits allocated for port 0.
                                ;Yes, so return them.
                move.w  #$0F00,d0
                JSRLIB  FreePotBits
ee_NotAlloc0:   btst    #JP_STATUSB_FIRST_INIT_REQ,ll_Port1State+lljp_Status(a5)
                bne.s   ee_NotAlloc1            ;Were the Potgo bits allocated for port 1.
                                ;Yes so return them.
                move.w  #$F000,d0
                JSRLIB  FreePotBits
ee_NotAlloc1:   move.l  ll_ExecBase(a5),a6
                                ;Free my own library (we have no openers)
                move.l  a5,a1
                CLEAR   d0
                move.w  LIB_NEGSIZE(a5),d0      ;Get negative size
                sub.l   d0,a1                   ;Point at start of library
                add.w   LIB_POSSIZE(a5),d0      ;Add in positive size
                                ;Now, set up for the exit...
                movem.l d2,-(sp)                ;Save
                move.l  ll_SegList(a5),d2       ;Get seglist...
                movem.l d0/a1,-(sp)             ;Save these...
                move.l  a5,a1                   ;We need to remove ourselves from
                JSRLIB  Remove                  ;the library list...
                movem.l (sp)+,d0/a1             ;Restore these...
                JSRLIB  FreeMem                 ;Free the memory...
                move.l  d2,d0                   ;Get seglist into return...
                movem.l (sp)+,d2                ;Restore
                movem.l (sp)+,a5-a6

        ENDC
expunge_done:   rts                             ;Return from expunge...


*****i* lowlevel.library/SetLanguageSelection ********************************
*
*   NAME
*       SetLanguageSelection - Sets the current language selection
*
*   SYNOPSIS
*       SetLanguageSelection (Language)
*                             d1
*
*   FUNCTION
*       Sets the default language in utility.library.
*
*   NOTE
*       This function must be called by a process.
*
*   INPUTS
*       Language - User specified language.
*
*   RESULT
*       NONE
*
******************************************************************************
SetLanguageSelection
                movem.l d1/a2/a5/a6,-(sp)
                move.l  a6,a5
                move.l  ll_UtilBase(a5),a0
                move.b  d1,ub_Language(a0)      ;Set the language in utility base.
                                ;
                                ;Set the language in nonvolatile.library.  This
                                ;cannot be done reliably unless we are a process.
                                ;
                move.l  ll_ExecBase(a5),a6
                lea     NVName(pc),a1
                JSRLIB  OldOpenLibrary
                move.l  d0,-(sp)
                beq.s   NoNV
                                ;Alright, nonvolatile library opened.
                move.l  d0,a6
                lea     VERSTR-1(pc),a0
                move.l  a0,a1
                CLEAR   d1
                JSRLIB  GetCopyNV               ;Get the system area from the NVRAM.
                move.l  4(sp),d1                ;Get the language back.
                move.l  d0,-(sp)
                beq.s   sls_Exit
                                ;Get the system area.
                move.l  d0,a2
                move.b  d1,(a2)                 ;Store the language in the system area.
                lea     VERSTR-1(pc),a0
                move.l  a0,a1
                CLEAR   d1
                JSRLIB  StoreNV                 ;Store back the system area to the NVRAM.
sls_Exit:       move.l  (sp)+,a0                ;Restore the pointer to the system area.
                JSRLIB  FreeNVData              ;Free whatever GetCopyNV returned.
NoNV:           move.l  (sp)+,a1                ;Restore nonvolatile.library base.
                move.l  ll_ExecBase(a5),a6
                JSRLIB  CloseLibrary            ;Close nonvolatile.
                movem.l (sp)+,d1/a2/a5/a6
                rts

******* lowlevel.library/GetLanguageSelection ********************************
*
*   NAME
*	GetLanguageSelection -- returns the current language selection. (V40)
*
*   SYNOPSIS
*	language = GetLanguageSelection();
*	D0
*
*	ULONG GetLanguageSelection (VOID);
*
*   FUNCTION
*	Determine what the user has specified as a language.
*
*   RESULT
*	language - user specified language, or zero if none has yet been
*		   specified. See <libraries/lowlevel.h> for a definition
*		   of the currently supported language.
*
*   SEE ALSO
*	<libraries/lowlevel.h>, locale.doc
*
******************************************************************************
GetLanguageSelection
                move.l  ll_UtilBase(a6),a0
                moveq.l #0,d0
                move.b  ub_Language(a0),d0
                rts

*****l* lowlevel.library/VBlankCNTR ******************************************
*
*   NAME
*       VBlankCNTR - Counts VBlanks
*
******************************************************************************
VBlankCNTR
                addq.l  #1,(a1)
                CLEAR   d0
                rts

subsysName      LOWLEVELNAME
VERSTR:         VSTRING
UtilName:       dc.b    'utility.library',0
NVName          dc.b    'nonvolatile.library',0
IntuitionName   dc.b    'intuition.library',0
GFXNAME         dc.b    'graphics.library',0
TIMERDEVICE     dc.b    'timer.device',0
KEYBDEVICE      dc.b    'keyboard.device',0
POTGORESOURCE:  POTGONAME
                END
@


40.20
log
@Autodoc and include cleanup
@
text
@d3 1
a3 1
*       $Id: startup.asm,v 40.19 93/05/21 11:17:44 gregm Exp Locker: gregm $
d7 4
a10 1
*       $Log:   startup.asm,v $
d468 1
a468 1
        IFD     DISK_BASED
d639 1
a639 1
        IFD     DISK_BASED
@


40.19
log
@Added a moveq #0,d0 to GetLanguageSelection().  Otherwise, garbage would've filled
the top 24 bits.
@
text
@d3 1
a3 1
*       $Id: startup.asm,v 40.18 93/05/18 15:02:59 gregm Exp Locker: gregm $
d8 4
d214 2
d363 2
d789 1
a789 1
                JSRLIB  FreeNV                  ;Free whatever GetCopyNV returned.
d799 1
a799 1
*       GetLanguageSelection - Returns the current language selection.
d802 12
a813 7
*       Language = GetLanguageSelection()
*       d0
*
*       ULONG GetLanguageSelection (VOID)
*
*   FUNCTION
*       Determine what the user has specified as a language.
d815 2
a816 6
*   INPUTS
*       NONE
*
*   RESULT
*       Language - User specified language, or zero if none has yet been
*                  specified.
@


40.18
log
@Jim was doing a CDREbootDefault() at Init time.
Jerry informed me that the CD_INFO command won't return realisitic
information for the default reboot behavior until well after that time.
I now set the field to a negative value, and the first time someone
tries to set the value, I do the query then (first) to find the 
current, or perceived default setting.
@
text
@d3 1
a3 1
*       $Id: startup.asm,v 40.17 93/05/05 09:55:45 gregm Exp Locker: gregm $
d8 8
d812 1
@


40.17
log
@init code for port 2, 3 added, plus init code for clearing the RJP jump vectors.
@
text
@d3 1
a3 1
*       $Id: startup.asm,v 40.16 93/04/21 09:54:58 Jim2 Exp $
d8 3
d475 2
a476 1
                bsr     CDRebootDefault         ;Establish the default behaviour of the system for when the CD is removed.
@


40.16
log
@Reserved space for six additional vectors at the end of
the jump table.
@
text
@d3 1
a3 1
*	$Id: startup.asm,v 40.15 93/04/20 14:18:59 Jim2 Exp Locker: Jim2 $
d7 5
a11 1
*	$Log:	startup.asm,v $
d128 2
a129 2
*	(C) Copyright 1992,1993 Commodore-Amiga, Inc.
*	    All Rights Reserved
d133 62
a194 61
	INCLUDE	'exec/macros.i'
	INCLUDE	'exec/lists.i'
	INCLUDE 'exec/resident.i'
	INCLUDE	'exec/libraries.i'
	INCLUDE	'exec/initializers.i'
	INCLUDE	'exec/ports.i'
	INCLUDE	'exec/memory.i'
	INCLUDE	'exec/execbase.i'

	INCLUDE	'graphics/gfxbase.i'

	INCLUDE	'intuition/preferences.i'

	INCLUDE 'utility/utility.i'

	INCLUDE	'devices/timer.i'

	INCLUDE	'hardware/cia.i'
	INCLUDE	'hardware/custom.i'
	INCLUDE	'hardware/intbits.i'

	INCLUDE	'resources/potgo.i'

	INCLUDE	'a/JoyPortInternal.i'
	INCLUDE	'macros.i'
	INCLUDE	'lowlevel.i'
	INCLUDE	'lowlevelbase.i'		;Library base.
	INCLUDE	'lowlevel_rev.i'		;Version string.

		XREF	_custom
				;a/SystemControl.asm
		XREF	SystemControlA
				;a/Timer.asm
		XREF	RemTimerInt
		XREF	AddTimerInt
		XREF	StopTimerInt
		XREF	StartTimerInt
		XREF	ElapsedTime
	IFD	MC68000
		XREF	ElapsedTime000
	ENDC
		XREF	CIAARESOURCE
				;a/ReadJoyPort.asm
		XREF	ReadJoyPort
		XREF	RJP_VBlank_Int
				;a/Keyboard.asm
		XREF	GetKey
		XREF	QueryKeys
		XREF	AddKBInt
		XREF	RemKBInt
		XREF	KeyboardInterruptExtender
				;a/VBlank.asm
		XREF	AddVBlankInt
		XREF	RemVBlankInt
				;a/CDReboot.asm
		XREF	CDRebootDefault
				;a/Requesters.asm
		XREF	KillReq
		XREF	RestoreReq
				;EndMarker.ob
		XREF	LowLevel_end		;Label placed at the end of the library at link time.
d196 3
a198 3
				;Amiga.lib
		XREF	_LVOElapsedTime
		XREF	_LVOEasyRequestArgs
d204 2
a205 2
		moveq	#-1,d0
		rts
d211 2
a212 2
entry_reserved:	moveq	#0,d0
		rts
d218 10
a227 10
		dc.w	RTC_MATCHWORD	; RT_MATCHWORD
		dc.l	initLDescrip	; RT_MATCHTAG
		dc.l	LowLevel_end	; RT_ENDSKIP
		dc.b	RTF_COLDSTART|RTF_AUTOINIT	; RT_FLAGS
		dc.b	VERSION		; RT_VERSION
		dc.b	NT_LIBRARY	; RT_TYPE
		dc.b	1		; RT_PRI
		dc.l	subsysName	; RT_NAME
		dc.l	VERSTR		; RT_IDSTRING
		dc.l	inittable	; RT_INIT
d231 4
a234 4
inittable:	dc.l ll_SIZE
		dc.l vectors
		dc.l initStruct
		dc.l initFunc
d240 6
a245 6
V_DEF		MACRO
		DC.W	entry_\1-vectors
		ENDM
VEC_DEF		MACRO
		DC.W	\1+(*-vectors)
		ENDM
d248 29
a276 29
		DC.W	-1
		V_DEF	open
		V_DEF	close
		V_DEF	expunge
		V_DEF	reserved
		VEC_DEF	ReadJoyPort
		VEC_DEF	GetLanguageSelection
		VEC_DEF	SetLanguageSelection
		VEC_DEF	GetKey
		VEC_DEF	QueryKeys
		VEC_DEF	AddKBInt
		VEC_DEF	RemKBInt
		VEC_DEF	SystemControlA
		VEC_DEF	AddTimerInt
		VEC_DEF	RemTimerInt
		VEC_DEF	StopTimerInt
		VEC_DEF	StartTimerInt
		VEC_DEF	ElapsedTime
		VEC_DEF	AddVBlankInt
		VEC_DEF	RemVBlankInt
		VEC_DEF	KillReq
		VEC_DEF	RestoreReq
		V_DEF	reserved
		V_DEF	reserved
		V_DEF	reserved
		V_DEF	reserved
		V_DEF	reserved
		V_DEF	reserved
		DC.W	-1
d279 3
a281 3
		INITWORD	LIB_REVISION,REVISION
		INITBYTE	ll_TaskPri,100
		DC.L	0
d286 1
a286 1
*	initFunc - Initialization function for a graphic library structure
d289 35
a323 35
*	InitLib = SystemControlA (LibBase, SegList, ExecBase)
*	D0			  D0	   A1	    A6
*
*   FUNCTION
*	After handling the standard library intialization the lowlevel library
*	specific initialization is done.
*
*   INPUTS
*	LibBase - Pointer to the memory allocated for the library base.
*	SegList	- Pointer to the memory allocated and loaded with the
*		  library code.
*	ExecBase - Pointer to the base of exec.library.
*
*   RESULT
*	Either returns the library base if sucessful, or NULL if there is
*	a problem in intialization.
*
******************************************************************************
initFunc:	movem.l	d7/a5/a6,-(sp)		;Need two address registers.
		move.l	d0,a5			;Get library base into a5.
		move.l	a6,ll_ExecBase(a5)	;Store ExecBase.
		move.l	a0,ll_SegList(a5)	;Save seglist.


				;lowlevel library specific initialization.
	IFD	MC68000
		move.w	AttnFlags(a6),d0
		and.w	#AFF_68020!AFF_68030!AFF_68040,d0
	        bne.s	2$
				;Replace 68020 ElapsedTime with 68000 ElapsedTime
		move.l	a5,a1
		move.w	#_LVOElapsedTime,d0	;load a function offset
		lea	ElapsedTime000(pc),a0	;load a the replacement function POINTER
		exg	a0,d0
		JSRLIB	SetFunction		;do the magic
d325 212
a536 207
	ENDC
		lea	POTGORESOURCE(pc),a1
		JSRLIB	OpenResource
		move.l	d0,ll_PotGoResource(a5)	;Get a pointer to the POTGO resource.
				;
				;Initialize the structures for handling the
				;reading of the ports.  This includes the structures
				;used in InstallInputMap() and the GamePort
				;VBlank interrupt replacement.
				;
		move.b	#JP_STATUSF_FIRST_INIT_REQ,ll_Port0State+lljp_Status(a5)
		move.b	#JP_STATUSF_FIRST_INIT_REQ,ll_Port1State+lljp_Status(a5)
		lea	ll_Port0State+lljp_AddSafely(a5),a0
		JSRLIB	InitSemaphore
		lea	ll_Port1State+lljp_AddSafely(a5),a0
		JSRLIB	InitSemaphore
		move.b	#NT_INTERRUPT,ll_RJP_Vblank_IS+LN_TYPE(a5)
		move.l	LN_NAME(a5),ll_RJP_Vblank_IS+LN_NAME(a5)
		lea	RJP_VBlank_Int(pc),a1
		move.l	a1,ll_RJP_Vblank_IS+IS_CODE(a5)
		move.l	a5,ll_RJP_Vblank_IS+IS_DATA(a5)
		moveq	#-1,d0
				;Nesting counts start at -1.
		move.b	d0,ll_NestOwn(a5)
		move.b	d0,ll_NestReq(a5)
		move.b	d0,ll_NestKillIn(a5)
		move.b	d0,ll_Port0State+lljp_NestCnt(a5)
		move.b	d0,ll_Port1State+lljp_NestCnt(a5)
		move.w	d0,ll_LastKey+2(a5)	;LastKey set to FF.
				;
				;Set up the structures used in controlling the
				;extended keyboard interrupt.
				;
		move.b	#NT_INTERRUPT,ll_KBExtend+LN_TYPE(a5)
		move.l	LN_NAME(a5),ll_KBExtend+LN_NAME(a5)
		move.l	a5,ll_KBExtend+IS_DATA(a5)	;Data is the lowlevel.library base.
		lea	KeyboardInterruptExtender(pc),a1
		move.l	a1,ll_KBExtend+IS_CODE(a5)
		lea	ll_KBInterrupts(a5),a1
		NEWLIST a1			;Initialize the list of user keyboard interrupts.
				;
				;In order to kill all requesters we actually need
				;to patch intuition.  Since intuition does not
				;expunge there is no need to hold it open after
				;we get the information we need.
				;However, since it is bad form to un-SetFunction
				;we leave the patch in memory.  Since we occasionally
				;need a port structure, the patch is stuck onto
				;a port.  This makes it possible to find it.
				;
		move.l	LN_NAME(a5),a1
		JSRLIB	FindPort
		move.l	d0,ll_ERSetFunction(a5)
		bne.w	SetFunced		;If we found our port, then we have the setfunction data.

		move.l	#llsf_Size+VERSTR-subsysName,d0
		move.l	#MEMF_CLEAR,d1
		JSRLIB	AllocMem		;Get the memory required for the port and patch.
		move.l	d0,ll_ERSetFunction(a5)
		beq	init_fail
				;Got enough memory.  Initialize the port.
		move.l	d0,a1
		move.l	#PA_IGNORE,MP_FLAGS(a1)
		move.b	#-1,LN_PRI(a1)
		lea	MP_MSGLIST(a1),a0
		NEWLIST	a0
		move.l	a1,-(sp)
		lea	llsf_Size(a1),a0
		move.l	a0,LN_NAME(a1)
		move.l	LN_NAME(a5),a1
CopyName:	move.b	(a1)+,(a0)+		;Copy the name of the library to the port.
		bne.s	CopyName
				;
				;Name is all copied.  The port initialization is
				;now complete.  So let's add the port to the public
				;list.  Then we can start on the patch.
				;
		move.l	(sp)+,a1
		JSRLIB	AddPort
		lea	IntuitionName(pc),a1
		move.l	#37,d0			;Any version.
		JSRLIB	OpenLibrary
		tst.l	d0			;EasyRequest does not exist before v37 in Intuition.
		beq.w	init_fail		;If NULL, we failed!

		move.l	ll_ERSetFunction(a5),a1
		lea	llsf_RTS(a1),a0		;The code must be complete before we
		move.l	a0,llsf_Routine(a1)	;SetFunction, so just RTS immediately.
		move.l	#$2F3AFFFA,llsf_Move(a1)
		move.w	#$7000,llsf_Clear(a1)
		move.w	#$4E75,llsf_RTS(a1)
		lea	llsf_Move(a1),a1
		move.l	#_LVOEasyRequestArgs,a0
		exg	d0,a1
		movem.l	d0/a0/a1,-(sp)
		JSRLIB	CacheClearU		;We've just created code in the data cache, flush them.
		movem.l	(sp)+,d0/a0/a1
		JSRLIB	SetFunction
		move.l	ll_ERSetFunction(a5),a1
		move.l	d0,llsf_Original(a1)
		move.l	d0,llsf_Routine(a1)	;Change the patch to point at the orginal vector.
		JSRLIB	CacheClearU		;We've just changed code in the data cache, flush.
SetFunced:			;EasyRequest is now properly SetFunctioned.
		lea	UtilName(pc),a1		;"utility.library"
		JSRLIB	OldOpenLibrary
		move.l	d0,ll_UtilBase(a5)	;Store utility base
		beq.w	init_fail		;If NULL, we failed!
				;
				;Found and opened Utility Library.
				;ReadJoyPort() needs a counter for VBlanks.
				;
		lea	GFXNAME(pc),a1
		move.l	#40,d0
		JSRLIB	OpenLibrary
		tst.l	d0			;There is a VBlank counter in v40 of graphics.

	IFD	DISK_BASED
				;
				;If we are disk based then we need to be able to
				;fall back if graphics v40 is not present.
				;
		bne.s	init_UseGFX
				;The fallback is adding yet another VBlank interrupt.
		lea	ll_VBlankCNTR(a5),a1
		move.b	#NT_INTERRUPT,LN_TYPE(a1)
		move.l	LN_NAME(a5),LN_NAME(a1)	;Yet something else sharing the name of the library.
		lea	VBlankCNTR(pc),a0
		move.l	a0,IS_CODE(a1)
		lea	ll_VBlankCount(a5),a0
		move.l	a0,IS_DATA(a1)
		moveq	#INTB_VERTB,d0
		JSRLIB	AddIntServer
		lea	ll_VBlankCount(a5),a1	;Move the address of the actual counter into a1.
		bra.s	init_SetVBCntr
	ELSE
				;Fail if we are ROM and graphics v40 is not present.
		beq.w	init_NoCounter
	ENDC

init_UseGFX:	move.l	d0,a0
		lea	gb_VBCounter(a0),a1	;Set a1 to point to the actual counter.
init_SetVBCntr:	move.l	a1,ll_VBCounter(a5)	;Save the address of the counter into the library base.
		bsr	CDRebootDefault		;Establish the default behaviour of the system for when the CD is removed.
				;Need some temporary variables.
TEMP_SIZE	set	0
		ARRAYVAR Request,IOTV_SIZE
		ALLOCLOCALS sp			;Need a timerrequest to open the timer device.
		lea	TIMERDEVICE(pc),a0
		move.l	sp,a1
		move.l	#UNIT_MICROHZ,d0
		moveq	#0,d1
		JSRLIB	OpenDevice		;Open the microhz timer.
		tst.b	d0			;Test the return value from OpenDevice.
				;Successful open of timer.device.
		bne.s	NoTimer
		move.l	Request+IO_DEVICE(sp),a6
		move.l	a6,ll_TimerDevice(a5)	;Save the pointer to the timer device.
		move.l	sp,a0
		JSRLIB	ReadEClock
		move.l	d0,ll_EClockConversion(a5)	;Get the number of E clocks per second.
				;Open keyboard.device.  Reuse the timerrequest.
		move.l	ll_ExecBase(a5),a6
		lea	KEYBDEVICE(pc),a0
		move.l	sp,a1			;Still have temporary variables on the stack.
		moveq	#0,d0
		move.l	d0,d1
		JSRLIB	OpenDevice		;Open keyboard.device.
		tst.b	d0			;Test the return value from OpenDevice.
		bne.s	NoKeyBoard
				;Successful open of keyboard.device.
		move.l	Request+IO_DEVICE(sp),ll_KBDevice(a5)
				;
				;CIAA resource timer B_SP is used by keyboard.device.
				;the interrupt attached there is the keyboard
				;interrupt.  AddICRVector to this timer will return
				;a pointer to the interrupt structure.
				;
		lea	CIAARESOURCE(pc),a1
		JSRLIB	OpenResource
		move.l	d0,a6
		move.w	#CIAICRB_SP,d0
		JSRLIB	AddICRVector
		move.l	d0,ll_KBOrig(a5)	;Save the normal keyboard interrupt.
		move.l	d0,a1
		move.w	#CIAICRB_SP,d0
		JSRLIB	RemICRVector		;Remove the keyboard interrupt service routine.
		lea	ll_KBExtend(a5),a1
		move.w	#CIAICRB_SP,d0
		JSRLIB	AddICRVector		;Replace it with ours.
		move.l	a5,d0			;Set return value
		DONELOCALS sp			;Clear the stack.
		bra.s	init_go

NoKeyBoard:			;Could not open keyboard.device, however ...
				;timer.device was opened so close it before failing.

		move.l	ll_TimerDevice(a5),Request+IO_DEVICE(sp)
		move.l	sp,a1
		JSRLIB	CloseDevice		;Close the microhz timer.
NoTimer:			;Timer.device is not open, however...
		DONELOCALS sp			;Clear the stack.
init_NoCounter:			;utility.libary was opened so close it before failing.
		move.l	ll_UtilBase(a5),a1
		JSRLIB	CloseLibrary		;Close the utility library.
init_fail:	moveq	#0,d0			;Mark failure.
init_go		movem.l	(sp)+,d7/a5/a6		;Restore the address registers.
		rts
d541 1
a541 1
*	entry_open - Open the lowlevel library.
d544 2
a545 2
*	LowLevelBase = entry_open(LowLevelBase)
*	D0			  A6
d548 2
a549 2
*	Increments the library count and returns the pointer to the
*	library base.
d552 1
a552 1
*	LowLevelBase - Pointer to the base of the LowLevel library.
d555 1
a555 1
*	Returns the library base.
d559 3
a561 3
		addq.w	#1,LIB_OPENCNT(a6)	;Count the open
		move.l	a6,d0			;Return library base
		rts
d566 1
a566 1
*	entry_close - Close the lowlevel library.
d569 2
a570 2
*	entry_close(LowLevelBase)
*		    A6
d573 1
a573 1
*	Decrements the library count.
d575 1
a575 1
*	This library does not autoexpunge.
d578 1
a578 1
*	LowLevelBase - Pointer to the base of the low level library.
d581 1
a581 1
*	NONE
d585 3
a587 3
entry_close:	subq.w	#1,LIB_OPENCNT(a6)	;Count the close
		moveq	#0,d0
		rts
d592 1
a592 1
*	entry_expunge - Remove the lowlevel library from memory.
d595 12
a606 12
*	entry_expunge(LowLevelBase)
*		      A6
*
*   FUNCTION
*	All of library specific resources are returned.  Then the library
*	size is	calculated and the library is removed from the list of
*	libraries and the memory for the library is freed.
*
*	The ROM based version of this library cannot be expunged.
*
*   INPUTS
*	LowLevelBase - Pointer to the base of the LowLevel library.
d609 1
a609 1
*	NONE
d614 1
a614 1
		moveq	#0,d0
d616 39
a654 39
	IFD	DISK_BASED
		tst.w	LIB_OPENCNT(a6)		;Check if Zero opens.
		bne.w	expunge_done		;If non-zero, we don't go

		movem.l	a5-a6,-(sp)		;Need a couple of address registers.
		move.l	a6,a5
		move.l	ll_ExecBase(a5),a6
		lea	CIAARESOURCE(pc),a1
		JSRLIB	OpenResource
		move.l	d0,a6
		move.w	#CIAICRB_SP,d0
		lea	ll_KBExtend(a5),a1
		JSRLIB	RemICRVector		;Remove our keyboard service routine.
		move.l	ll_KBOrig(a5),a1
		move.l	#CIAICRB_SP,d0
		JSRLIB	AddICRVector		;Put back the original keyboard service routine.
		move.l	ll_ExecBase(a5),a6
		move.l	ll_UtilBase(a5),a1
		JSRLIB	CloseLibrary		;Close utility.library.
				;
				;If we added our own VBlank handler let's remove it.
				;If not we ought to be good and close graphics.
				;
		lea	GFXNAME(pc),a1
		move.l	#40,d0
		JSRLIB	OpenLibrary
		tst.l	d0
		beq.s	RemoveVBCNTR		;Our handler was added iff graphics v40 could not be opened.
				;
				;If we could open graphics v40, then we need to close
				;it twice.  Once for this open and once for the open
				;at our init time.
				;
		move.l	d0,-(sp)
		move.l	d0,a1
		JSRLIB	CloseLibrary
		move.l	(sp)+,a1
		JSRLIB	CloseLibrary
		bra.s	DoneVBCNTR
d656 3
a658 3
RemoveVBCNTR:	lea	ll_VBlankCNTR(a5),a1
		moveq	#INTB_VERTB,d0
		JSRLIB	RemIntServer		;Remove our VBlank handler
d661 50
a710 50
TEMP_SIZE	set	0
		ARRAYVAR Request,IOTV_SIZE
		ALLOCLOCALS sp			;Need a timerrequest to close the timer device.
		move.l	ll_TimerDevice(a5),Request+IO_DEVICE(sp)
		move.l	sp,a1
		JSRLIB	CloseDevice		;Close the microhz timer.
		move.l	ll_KBDevice(a5),Request+IO_DEVICE(sp)
		move.l	sp,a1
		JSRLIB	CloseDevice		;Close keyboard.device.
		DONELOCALS sp			;Clear the stack.
				;Clean up any mischief caused by ReadJoyPort().
		bclr	#JP_STATUSB_VBLANK_ACQUIRED,ll_Port0State+lljp_Status(a5)
		beq.s	4$			;Did we replace the gameport VBlank interrupt.

		moveq	#INTB_VERTB,d0
		lea	ll_RJP_Vblank_IS(a5),a1
		JSRLIB	RemIntServer		;Remove our replacement.
		moveq	#INTB_VERTB,d0
		move.l	ll_RJP_Saved_IS(a5),a1
		JSRLIB	AddIntServer		;Restore the orginal.
		bset	#JP_STATUSB_FIRST_INIT_REQ,ll_Port0State+lljp_Status(a5)	;Do not try to return the POTGO bits.
4$:		move.l	ll_PotGoResource(a5),a6
		btst	#JP_STATUSB_FIRST_INIT_REQ,ll_Port0State+lljp_Status(a5)
		bne.s	ee_NotAlloc0		;Were the Potgo bits allocated for port 0.
				;Yes, so return them.
		move.w	#$0F00,d0
		JSRLIB	FreePotBits
ee_NotAlloc0:	btst	#JP_STATUSB_FIRST_INIT_REQ,ll_Port1State+lljp_Status(a5)
		bne.s	ee_NotAlloc1		;Were the Potgo bits allocated for port 1.
				;Yes so return them.
		move.w	#$F000,d0
		JSRLIB	FreePotBits
ee_NotAlloc1:	move.l	ll_ExecBase(a5),a6
				;Free my own library (we have no openers)
		move.l	a5,a1
		CLEAR	d0
		move.w	LIB_NEGSIZE(a5),d0	;Get negative size
		sub.l	d0,a1			;Point at start of library
		add.w	LIB_POSSIZE(a5),d0	;Add in positive size
				;Now, set up for the exit...
		movem.l	d2,-(sp)		;Save
		move.l	ll_SegList(a5),d2	;Get seglist...
		movem.l	d0/a1,-(sp)		;Save these...
		move.l	a5,a1			;We need to remove ourselves from
		JSRLIB	Remove			;the library list...
		movem.l	(sp)+,d0/a1		;Restore these...
		JSRLIB	FreeMem			;Free the memory...
		move.l	d2,d0			;Get seglist into return...
		movem.l	(sp)+,d2		;Restore
		movem.l	(sp)+,a5-a6
d712 2
a713 2
	ENDC
expunge_done:	rts				;Return from expunge...
d719 1
a719 1
*	SetLanguageSelection - Sets the current language selection
d722 2
a723 2
*	SetLanguageSelection (Language)
*			      d1
d726 1
a726 1
*	Sets the default language in utility.library.
d729 1
a729 1
*	This function must be called by a process.
d732 1
a732 1
*	Language - User specified language.
d735 1
a735 1
*	NONE
d739 36
a774 36
		movem.l	d1/a2/a5/a6,-(sp)
		move.l	a6,a5
		move.l	ll_UtilBase(a5),a0
		move.b	d1,ub_Language(a0)	;Set the language in utility base.
				;
				;Set the language in nonvolatile.library.  This
				;cannot be done reliably unless we are a process.
				;
		move.l	ll_ExecBase(a5),a6
		lea	NVName(pc),a1
		JSRLIB	OldOpenLibrary
		move.l	d0,-(sp)
		beq.s	NoNV
				;Alright, nonvolatile library opened.
		move.l	d0,a6
		lea	VERSTR-1(pc),a0
		move.l	a0,a1
		CLEAR	d1
		JSRLIB	GetCopyNV		;Get the system area from the NVRAM.
		move.l	4(sp),d1		;Get the language back.
		move.l	d0,-(sp)
		beq.s	sls_Exit
				;Get the system area.
		move.l	d0,a2
		move.b	d1,(a2)			;Store the language in the system area.
		lea	VERSTR-1(pc),a0
		move.l	a0,a1
		CLEAR	d1
		JSRLIB	StoreNV			;Store back the system area to the NVRAM.
sls_Exit:	move.l	(sp)+,a0		;Restore the pointer to the system area.
		JSRLIB	FreeNV			;Free whatever GetCopyNV returned.
NoNV:		move.l	(sp)+,a1		;Restore nonvolatile.library base.
		move.l	ll_ExecBase(a5),a6
		JSRLIB	CloseLibrary		;Close nonvolatile.
		movem.l	(sp)+,d1/a2/a5/a6
		rts
d779 1
a779 1
*	GetLanguageSelection - Returns the current language selection.
d782 2
a783 2
*	Language = GetLanguageSelection()
*	d0
d785 1
a785 1
*	ULONG GetLanguageSelection (VOID)
d788 1
a788 1
*	Determine what the user has specified as a language.
d791 1
a791 1
*	NONE
d794 2
a795 2
*	Language - User specified language, or zero if none has yet been
*		   specified.
d799 3
a801 3
		move.l	ll_UtilBase(a6),a0
		move.b	ub_Language(a0),d0
		rts
d806 1
a806 1
*	VBlankCNTR - Counts VBlanks
d810 3
a812 3
		addq.l	#1,(a1)
		CLEAR	d0
		rts
d814 10
a823 10
subsysName	LOWLEVELNAME
VERSTR:		VSTRING
UtilName:	dc.b	'utility.library',0
NVName		dc.b	'nonvolatile.library',0
IntuitionName	dc.b	'intuition.library',0
GFXNAME		dc.b	'graphics.library',0
TIMERDEVICE	dc.b	'timer.device',0
KEYBDEVICE	dc.b	'keyboard.device',0
POTGORESOURCE:	POTGONAME
		END
@


40.15
log
@Finally got around to updating the end label to reflect
lowlevel rather than game.
@
text
@d3 1
a3 1
*	$Id: startup.asm,v 40.14 93/04/19 13:38:57 Jim2 Exp Locker: Jim2 $
d8 4
d265 6
@


40.14
log
@Played around with the comments.  Moved the storing of
the original EasyRequest vector to the memory turd.
@
text
@d3 1
a3 1
*	$Id: startup.asm,v 40.13 93/04/14 14:12:59 Jim2 Exp Locker: Jim2 $
d8 4
d185 1
a185 1
		XREF	Game_end		;Label placed at the end of the library at link time.
d211 1
a211 1
		dc.l	Game_end	; RT_ENDSKIP
@


40.13
log
@Oops forgot to save a2 in SetLanguageSelection
@
text
@d3 1
a3 1
*	$Id: startup.asm,v 40.12 93/04/13 15:35:09 Jim2 Exp Locker: Jim2 $
d8 3
a143 1

a149 1

a150 7




		XREF	_LVOEasyRequestArgs


a179 3

		XREF	_ciaasdr

d185 1
a189 1
* Also used for the Reserved function...
a195 1
* Just a block to prevent illegal entry...
d275 1
a275 24
*	specific initialization is done.  The specific initialization is
*	the following:
*
*	    -	Initialize internal state variables used to determine type
*		of controller.
*	    -	Initialize the nesting counts to -1.
*	    -	Set the Last key to -1, no qualifiers
*	    -	Initialize the keyboard interrupt replacement interrupt
*		structure.
*	    -	Initialize the list for keyboard interrupt extenders.
*	    -	Determine the default CD reboot behaviour.
*	    -	SetFunction EasyRequest to allow for requesters to be
*		disabled.
*	    -	Open the nonvolatile.library and find the current language
*		selection.
*	    -	Open the utility.library.  This is needed for tag list
*		walking.
*	    -	Open a UNIT_MICROHZ timer.device.
*	    -	Retrieve the number of E Clocks per second.
*	    -	Open the keyboard.device.
*	    -	Retrieve the pointer to the current keyboard interrupt
*		structure.
*	    -	Remove the current keyboard interrupt structure.
*	    -	Add our keyboard interrupt structure in the loop.
d299 1
a299 1
				;Replace 68020 elapsed time with 68000
d301 2
a302 2
		move.w	#_LVOElapsedTime,d0		;load a function offset
		lea	ElapsedTime000(pc),a0		;load a the replacement function POINTER
d304 2
a305 1
		JSRLIB	SetFunction			;do the magic
d307 1
a307 3


2$:		lea	POTGORESOURCE(pc),a1
d309 7
a315 1
		move.l	d0,ll_PotGoResource(a5)
d322 2
a323 2
		move.b	#NT_INTERRUPT,ll_RJP_Vblank_IS+LN_TYPE(a5)	; init type
		move.l	LN_NAME(a5),ll_RJP_Vblank_IS+LN_NAME(a5)				; init name
d325 4
a328 3
		move.l	a1,ll_RJP_Vblank_IS+IS_CODE(a5)				; init code pointer
		move.l	a5,ll_RJP_Vblank_IS+IS_DATA(a5)				; init data pointer
		moveq	#-1,d0			;Nesting counts start at -1.
d335 4
d345 1
a345 1
		NEWLIST a1			;Initialize, to zero, the list keyboard interrupts.
d351 4
d359 1
a359 1
		bne.w	SetFunced
d363 1
a363 1
		JSRLIB	AllocMem
d366 1
d376 1
a376 1
CopyName:	move.b	(a1)+,(a0)+
d378 5
a382 1

a384 1

d388 1
a388 1
		tst.l	d0
d390 1
d392 2
a393 2
		lea	expunge_done,a0
		move.l	a0,llsf_Routine(a1)
d401 1
a401 1
		JSRLIB	CacheClearU
a403 1
		move.l	d0,ll_EasyRequest(a5)
d405 5
a409 3
		move.l	d0,llsf_Routine(a1)
		JSRLIB	CacheClearU
SetFunced:	lea	UtilName(pc),a1		;"utility.library"
d413 4
a416 1

d420 1
a420 1
		tst.l	d0
d423 4
d428 1
a428 1

d430 2
a431 2
		move.b	#NT_INTERRUPT,LN_TYPE(a1)	; init type
		move.l	LN_NAME(a5),LN_NAME(a1)	; init name
d433 1
a433 1
		move.l	a0,IS_CODE(a1)		; init code pointer
d435 1
a435 1
		move.l	a0,IS_DATA(a1)		; init data pointer
d438 1
a438 1
		lea	ll_VBlankCount(a5),a1
a439 1

d441 1
a441 1

a442 1

d446 4
a449 5
		lea	gb_VBCounter(a0),a1
init_SetVBCntr:	move.l	a1,ll_VBCounter(a5)

		bsr	CDRebootDefault
				;Open timer.device
d466 1
a466 1
				;Open keyboard.device.
d477 1
a477 1

d482 1
a482 1

d575 3
a577 4
*	Closes the Utility libray and frees the library base.  First all of
*	library specific resources are returned.  Then the library size is
*	calculated and the library is removed from the list of libraries
*	and the memory for the library is freed.
d579 1
a579 7
*	The specific library resources are the following:
*	    -	Remove the extended keyboard interrupt and replace the
*		orginal one.
*	    -	Close utility.library.
*	    -	Close the microhertz timer.
*	    -	Close keyboard.device.
*	    -	Resources associated with ReadJoyPort.
d598 1
a599 1
		move.l	ll_ExecBase(a5),a6
d601 1
a601 1
		move.l	d0,a6			;Get pointer to CIAA resource.
d611 4
a614 1

d619 6
a624 2
		beq.s	RemoveVBCNTR

d632 1
a632 2
RemoveVBCNTR:
		lea	ll_VBlankCNTR(a5),a1
d634 1
a634 1
		JSRLIB	RemIntServer
d647 11
a657 9
		bclr	#JP_STATUSB_VBLANK_ACQUIRED,ll_Port0State+lljp_Status(a5)	; has it been acquired ?
		beq.s	4$				; if no, j to skip
		moveq	#INTB_VERTB,d0			; d0 gets interrupt number
		lea	ll_RJP_Vblank_IS(a5),a1		; a1 gets ptr to our entry
		JSRLIB	RemIntServer			; remove entry from list
		moveq	#INTB_VERTB,d0			; d0 gets interrupt number
		move.l	ll_RJP_Saved_IS(a5),a1		; a1 gets ptr to GP entry
		JSRLIB	AddIntServer			; add entry to list
		bset	#JP_STATUSB_FIRST_INIT_REQ,ll_Port0State+lljp_Status(a5)
d660 2
a661 2
		bne.s	ee_NotAlloc0

d665 2
a666 2
		bne.s	ee_NotAlloc1

d704 3
d718 5
a722 2
		move.b	d1,ub_Language(a0)		;Set the language in utility base.
				;Set the language in nonvolatile.library
d728 1
a728 1

d733 2
a734 2
		JSRLIB	GetCopyNV			;Get the system area from the NVRAM.
		move.l	4(sp),d1			;Get the language back.
d739 1
a739 1
		move.b	d1,(a2)
d743 4
a746 4
		JSRLIB	StoreNV				;Store back the system area to the NVRAM.
sls_Exit:	move.l	(sp)+,a0
		JSRLIB	FreeNV				;Free whatever GetCopyNV returned.
NoNV:		move.l	(sp)+,a1
d748 1
a748 1
		JSRLIB	CloseLibrary
@


40.12
log
@Changed the priority to 1 to allow ram kicking.
@
text
@d3 1
a3 1
*	$Id: startup.asm,v 40.11 93/04/06 12:34:47 Jim2 Exp Locker: Jim2 $
d8 3
d720 1
a720 1
		movem.l	d1/a5/a6,-(sp)
d751 1
a751 1
		movem.l	(sp)+,d1/a5/a6
@


40.11
log
@Made the expunge code safe for the ROM version.
@
text
@d3 1
a3 1
*	$Id: startup.asm,v 40.10 93/03/31 18:57:11 Jim2 Exp Locker: Jim2 $
d8 3
d218 1
a218 1
		dc.b	0		; RT_PRI
@


40.10
log
@Added code to support the VBlank counter for graphic <40.
Also for closing graphic.library on an expunge (CI103).
Adding the port stuff to CDDefault means it must be moved
to after the setting up of the port.
@
text
@d3 1
a3 1
*	$Id: Startup.asm,v 40.9 93/03/26 17:38:02 Jim2 Exp Locker: Jim2 $
d7 7
a13 1
*	$Log:	Startup.asm,v $
a165 1
		XREF	RJP_Joy_Direction
d599 2
@


40.9
log
@Open the PotGo resource at init time.  Also use the VBlank
counter in graphics base (V40 and beyond).
@
text
@d3 1
a3 1
*	$Id: Startup.asm,v 40.8 93/03/23 14:48:03 Jim2 Exp Locker: Jim2 $
d8 4
d315 1
d335 4
a338 15
		move.l	#JP_TYPE_UNKNOWN,d7
		move.w	joy0dat+_custom,d7				; d7 gets port 0 data
		bsr	RJP_Joy_Direction
		bne.s	Port0NotJoy

		and.l	#~JP_TYPE_MASK,d7
		or.l	#JP_TYPE_JOYSTK,d7
Port0NotJoy:	move.l	d7,ll_Port0State+lljp_PreviousValue(a5)		; update port 0 status flag
		move.w	joy1dat+_custom,d7				; d7 gets port 1 data
		bsr	RJP_Joy_Direction
		bne.s	Port1NotJoy

		and.l	#~JP_TYPE_MASK,d7
		or.l	#JP_TYPE_JOYSTK,d7
Port1NotJoy:	move.l	d1,ll_Port1State+lljp_PreviousValue(a5)		; update port 1 status flag
a357 1
		bsr	CDRebootDefault
d390 1
a390 1
		move.l	#36,d0			;Any version.
d420 18
d440 3
a442 1
		move.l	d0,a0
d444 1
a444 1
		move.l	a1,ll_VBCounter(a5)
d446 1
d532 2
a533 1
entry_open:	addq.w	#1,LIB_OPENCNT(a6)	;Count the open
d615 19
d768 10
a777 1

@


40.8
log
@Corrected name for VBlank interrupts.
@
text
@a0 1
*
d3 1
a3 1
*	$Id: Startup.asm,v 40.7 93/03/19 11:38:48 Jim2 Exp Locker: Jim2 $
d8 3
d111 2
d123 2
d156 1
a156 1
		XREF	POTGORESOURCE
d306 1
a306 1
initFunc:	movem.l	a5/a6,-(sp)		;Need two address registers.
d325 4
a328 1
2$:		move.b	#JP_STATUSF_FIRST_INIT_REQ,ll_Port0State+lljp_Status(a5)
d330 15
a344 5
		move.l	#JP_TYPE_UNKNOWN,d1
		move.w	joy0dat+_custom,d1				; d1 gets port 0 data
		move.l	d1,ll_Port0State+lljp_PreviousValue(a5)		; update port 0 status flag
		move.w	joy1dat+_custom,d1				; d1 gets port 1 data
		move.l	d1,ll_Port1State+lljp_PreviousValue(a5)		; update port 1 status flag
d423 10
d491 1
a491 1
				;utility.libary was opened so close it before failing.
d495 1
a495 1
init_go		movem.l	(sp)+,a5/a6		;Restore the address registers.
d619 1
a619 3
4$:		lea	POTGORESOURCE(pc),a1
		JSRLIB	OpenResource
		move.l	d0,a6
d741 1
d744 1
@


40.7
log
@Made allowances for a seperate disk base version of the library
which has to be able to run on processesor that do not have
68020s or better.  Sucked in the joyport initialization and expunge code.
The ROM version does not contain the expunge code.
@
text
@d4 1
a4 1
*	$Id: Startup.asm,v 40.6 93/03/15 16:28:08 Jim2 Exp Locker: Jim2 $
d9 6
d327 1
a327 1
		move.l	LN_NAME(a6),ll_RJP_Vblank_IS+LN_NAME(a5)				; init name
@


40.6
log
@Fixed error in SetLanguageSelection.
@
text
@d4 1
a4 1
*	$Id: Startup.asm,v 40.5 93/03/12 20:12:08 Jim2 Exp Locker: Jim2 $
d9 3
d101 1
d110 2
d114 1
d116 1
d121 2
d137 3
d143 2
a144 2
		XREF	ReadJoyPortInit
		XREF	ReadJoyPortExpunge
d164 3
d300 25
a324 1
		bsr	ReadJoyPortInit
d333 1
d545 1
a545 2
	IFGT 1
		moveq.l	#0,d0			;Clear d0
d575 23
a597 1
		bsr	ReadJoyPortExpunge
d600 1
@


40.5
log
@Actually made SetLanguageSelection not crash.
@
text
@d4 1
a4 1
*	$Id: Startup.asm,v 40.4 93/03/10 19:56:19 Jim2 Exp Locker: Jim2 $
d9 3
d597 3
a599 2
		move.l	d0,a0
		move.b	d1,(a0)
@


40.4
log
@Got expunge to work and managed to leave something in memory
so we don't need to clean up the setfunction on EasyRequest.
@
text
@d4 1
a4 1
*	$Id: Startup.asm,v 40.3 93/03/10 12:25:17 Jim2 Exp Locker: Jim2 $
d9 4
d111 2
a284 1
		move.b	d0,ll_NestReqAll(a5)
d286 2
d354 1
a354 1
 				;Open timer.device
d467 1
a467 1
;		rts
d574 2
a575 1
		movem.l	a5/a6,-(sp)
a585 1
		move.l	d1,-(sp)			;Don't want to lose the language.
d590 1
a590 1
		move.l	(sp)+,d1			;Get the language back.
d599 1
a599 1
sls_Exit:	move.l	(sp)+,a1
d604 1
a604 1
		movem.l	(sp)+,a5/a6
@


40.3
log
@Let strap read the languages out of nonvolatile into utilitybase.
@
text
@d4 1
a4 1
*	$Id: Startup.asm,v 40.2 93/03/08 10:52:40 Jim2 Exp Locker: Jim2 $
d9 3
d89 2
a217 3
		INITLONG	ll_ER_Location,expunge_done
		INITLONG	ll_ER_move,$2F3AFFFA
		INITLONG	ll_ER_clear_rts,$70004E75
d295 25
d325 7
a331 2
		move.l	d0,-(sp)
		lea	ll_ER_move(a5),a1
d334 3
a337 1
		move.l	d0,ll_ER_Location(a5)
d339 4
a342 4
		move.l	(sp)+,a1
		JSRLIB	CloseLibrary

		lea	UtilName(pc),a1		;"utility.library"
d494 1
a494 1
	IFGT -1
a513 14
		move.l	ll_NVBase(a5),a1
		JSRLIB	CloseLibrary
		lea	IntuitionName(pc),a1
		CLEAR	d0			;Any version.
		JSRLIB	OpenLibrary
		move.l	d0,-(sp)
		move.l	ll_EasyRequest(a5),a1
		move.l	#_LVOEasyRequestArgs,a0
		exg	d0,a1
 clr.b 0
		JSRLIB	SetFunction
 clr.b 1
		move.l	(sp)+,a1
		JSRLIB	CloseLibrary
d575 1
a575 1
		beq.w	NoNV
@


40.2
log
@Added accessing the nonvolatile memory to get the language.
Set function of EasyRequest as a means of killing the system
requesters.
@
text
@d4 1
a4 1
*	$Id: Startup.asm,v 40.1 93/03/02 13:32:24 Jim2 Exp Locker: Jim2 $
d9 5
d143 9
a151 1
entry_reserved:	moveq	#-1,d0
a215 1
		INITWORD	LIB_VERSION,VERSION
d294 1
a294 1
		CLEAR	d0			;Any version.
d309 1
a309 2
		CLEAR	d0			;Any version.
		JSRLIB	OpenLibrary
a312 19
		lea	NVName(pc),a1
		CLEAR	d0
		JSRLIB	OpenLibrary
		move.l	d0,ll_NVBase(a5)
		beq.w	NoNV
				;Opened nonvolatile.library
		move.l	ll_NVBase(a5),a6
		lea	VERSTR-1(pc),a0
		move.l	a0,a1
		CLEAR	d1
		JSRLIB	GetCopyNV			;Get the system area from the NVRAM.
		tst.l	d0
		beq.s	NoNVRAMLang
				;Get the system area.
		move.l	d0,a1
		move.l	ll_UtilBase(a5),a0
		move.b	(a0),ub_Language(a0)		;Set the language in utility base.
NoNVRAMLang: 	JSRLIB	FreeNV				;Free whatever GetCopyNV returned.
		move.l	ll_ExecBase(a5),a6
d371 1
a371 5
				;nonvolatile.libary was opened so close it before failing.
		move.l	ll_NVBase(a5),a1
		JSRLIB	CloseLibrary		;Close the utility library.

NoNV:				;utility.libary was opened so close it before failing.
d426 1
a426 1
		rts
d486 1
a486 1
		lea	ll_EasyRequest(a5),a1
d489 1
d491 1
d534 1
a534 1
*			      d0
d547 2
a548 2
		move.l	a6,-(sp)
		move.l	ll_UtilBase(a6),a0
d550 8
a557 1
		move.l	ll_NVBase(a6),a6
d574 4
a577 1
		move.l	(sp)+,a6
d603 2
a604 4
		move.l	a6,-(sp)
		move.l	ll_UtilBase(a6),a6
		move.b	ub_Language(a6),d0
		move.l	(sp)+,a6
@


40.1
log
@Changed all but the end reference from game to lowlevel.
Removed the anim calls.
@
text
@d4 1
a4 1
*	$Id: Startup.asm,v 40.0 93/02/19 17:47:31 Jim2 Exp Locker: Jim2 $
d9 4
d80 1
d96 4
d124 3
d160 1
a160 1
		dc.l 0
d195 2
d199 9
a223 1
*	    -	Set the priority used in system take over to 100
a225 4
*	    -	Clear the task pointer that identifies the system owner.
*	    -	Clear the code pointer in the timer interrupt structure,
*		identifing that no one yet owns the interrupt.
*	    -	Mark the languages as unspecified.
a227 1
*	    -	Initialize the shutdown startup animation semaphore.
d230 4
a258 7
		clr.w	LIB_OPENCNT(a5)		;Clear the open count
		lea	subsysName(pc),a0	;Get the name...
		move.l	a0,LN_NAME(a5)		;...into ln_Name field.
		lea	VERSTR(pc),a0		;Get ID string...
		move.l	a0,LIB_IDSTRING(a5)	;...store it.
		move.w	#VERSION,LIB_VERSION(a5)	;Set up version.
		move.w	#REVISION,LIB_REVISION(a5)	;And revision.
a261 1
		move.b	#100,ll_TaskPri(a5)	;Set up highest priority.
d265 1
a267 10
		moveq	#0,d0
		move.w	d0,ll_LastKey(a5)	;LastKey set to no qualifiers.
		move.l	d0,ll_SystemOwner(a5)	;No one owns the system yet.
		move.l  d0,ll_CIATimer+llct_TimerInt+IS_CODE(a5)	;Nor the interrupt. (other fields initialized when used.)
		move.l	d0,ll_VBlankInt(a5)
				;Intialize the keyboard interrupt structure.
		move.l	d0,ll_KBExtend+LN_SUCC(a5)
		move.l	d0,ll_KBExtend+LN_PRED(a5)
		move.b	d0,ll_KBExtend+LN_PRI(a5)
		move.l	d0,ll_KBExtend+LN_NAME(a5)
a271 2
		lea	ll_ShutdownSemaphore(a5),a0	;Set up the semaphore used for animiation shutdown.
		JSRLIB	InitSemaphore			;InitSemaphore(a0>ptr to Semaphore, a6>ExecBase)
d275 21
d297 1
a297 1
		moveq	#0,d0			;Any version.
d301 21
a321 1
				;Open timer.device
d379 5
a383 1
				;utility.libary was opened so close it before failing.
d470 4
a473 1
entry_expunge:	moveq.l	#0,d0			;Clear d0
d492 13
d532 2
d558 19
a576 2
		move.l	ll_UtilBase(a6),a6
		move.b	d1,ub_Language(a6)
d610 1
d614 2
@


40.0
log
@First instruction is now moveq.l #-1 not #0.
@
text
@d4 1
a4 1
*	$Id: Startup.asm,v 39.13 93/01/29 17:47:12 Jim2 Exp Locker: Jim2 $
d9 3
d87 2
a88 2
	INCLUDE	'gamebase.i'			;Library base.
	INCLUDE	'game_rev.i'			;Version string.
a92 3
				;a/Anim.asm
		XREF	BeginShutdownAnim
		XREF	WaitShutdownAnim
d146 1
a146 1
inittable:	dc.l gm_SIZE
a168 2
		VEC_DEF	BeginShutdownAnim
		VEC_DEF	WaitShutdownAnim
d195 1
a195 1
*	After handling the standard library intialization the Game library
d236 2
a237 2
		move.l	a6,gm_ExecBase(a5)	;Store ExecBase.
		move.l	a0,gm_SegList(a5)	;Save seglist.
d246 1
a246 1
				;Game library specific initialization.
d248 1
a248 1
		move.b	#100,gm_TaskPri(a5)	;Set up highest priority.
d250 4
a253 4
		move.b	d0,gm_NestOwn(a5)
		move.b	d0,gm_NestReq(a5)
		move.b	d0,gm_NestKillIn(a5)
		move.w	d0,gm_LastKey+2(a5)	;LastKey set to FF.
d255 4
a258 4
		move.w	d0,gm_LastKey(a5)	;LastKey set to no qualifiers.
		move.l	d0,gm_SystemOwner(a5)	;No one owns the system yet.
		move.l  d0,gm_CIATimer+gmct_TimerInt+IS_CODE(a5)	;Nor the interrupt. (other fields initialized when used.)
		move.l	d0,gm_VBlankInt(a5)
d260 6
a265 6
		move.l	d0,gm_KBExtend+LN_SUCC(a5)
		move.l	d0,gm_KBExtend+LN_PRED(a5)
		move.b	d0,gm_KBExtend+LN_PRI(a5)
		move.l	d0,gm_KBExtend+LN_NAME(a5)
		move.b	#NT_INTERRUPT,gm_KBExtend+LN_TYPE(a5)
		move.l	a5,gm_KBExtend+IS_DATA(a5)	;Data is the game.library base.
d267 2
a268 2
		move.l	a1,gm_KBExtend+IS_CODE(a5)
		lea	gm_ShutdownSemaphore(a5),a0	;Set up the semaphore used for animiation shutdown.
d270 1
a270 1
		lea	gm_KBInterrupts(a5),a1
d276 1
a276 1
		move.l	d0,gm_UtilBase(a5)	;Store utility base
d291 1
a291 1
		move.l	a6,gm_TimerDevice(a5)	;Save the pointer to the timer device.
d294 1
a294 1
		move.l	d0,gm_EClockConversion(a5)	;Get the number of E clocks per second.
d296 1
a296 1
		move.l	gm_ExecBase(a5),a6
d305 1
a305 1
		move.l	Request+IO_DEVICE(sp),gm_KBDevice(a5)
d317 1
a317 1
		move.l	d0,gm_KBOrig(a5)	;Save the normal keyboard interrupt.
d321 1
a321 1
		lea	gm_KBExtend(a5),a1
d331 1
a331 1
		move.l	gm_TimerDevice(a5),Request+IO_DEVICE(sp)
d337 1
a337 1
		move.l	gm_UtilBase(a5),a1
d346 1
a346 1
*	entry_open - Open the game library.
d349 2
a350 2
*	GameBase = entry_open(GameBase)
*	D0		      A6
d357 1
a357 1
*	GameBase - Pointer to the base of the Game library.
d370 1
a370 1
*	entry_close - Close the game library.
d373 1
a373 1
*	entry_close(GameBase)
d382 1
a382 1
*	GameBase - Pointer to the base of the Game library.
d396 1
a396 1
*	entry_expunge - Remove the game library from memory.
d399 1
a399 1
*	entry_expunge(GameBase)
d417 1
a417 1
*	GameBase - Pointer to the base of the Game library.
d430 1
a430 1
		move.l	gm_ExecBase(a5),a6
d434 1
a434 1
		lea	gm_KBExtend(a5),a1
d436 1
a436 1
		move.l	gm_KBOrig(a5),a1
d439 2
a440 2
		move.l	gm_ExecBase(a5),a6
		move.l	gm_UtilBase(a5),a1
d445 1
a445 1
		move.l	gm_TimerDevice(a5),Request+IO_DEVICE(sp)
d448 1
a448 1
		move.l	gm_KBDevice(a5),Request+IO_DEVICE(sp)
d460 1
a460 1
		move.l	gm_SegList(a5),d2	;Get seglist...
d472 1
a472 1
*****i* game.library/SetLanguageSelection ***********************************
d493 1
a493 1
		move.l	gm_UtilBase(a6),a6
d498 1
a498 1
******* game.library/GetLanguageSelection ************************************
d522 1
a522 1
		move.l	gm_UtilBase(a6),a6
d528 1
a528 1
subsysName	GAMENAME
@


39.13
log
@Added the ROMTAG flag RTF_COLDSTART.  This allows the library to
be found prior to DOS running.
@
text
@d4 1
a4 1
*	$Id: startup.asm,v 39.13 93/01/29 17:40:51 Jim2 Exp $
d8 5
a12 1
*	$Log:	startup.asm,v $
d126 1
a126 1
entry_reserved:	moveq	#0,d0
@


39.12
log
@Language is stored in UtilBase not GameBase.
.,
@
text
@d4 1
a4 1
*	$Id: startup.asm,v 39.11 93/01/18 13:40:23 Jim2 Exp Locker: Jim2 $
d9 3
d132 1
a132 1
		dc.b	RTF_AUTOINIT	; RT_FLAGS
@


39.11
log
@Changed method for determining CD default behavior.  Expunges
all ReadJoyPort allocations.
@
text
@d4 1
a4 1
*	$Id: startup.asm,v 39.10 93/01/15 14:07:18 Jim2 Exp Locker: Jim2 $
d9 4
d69 2
d164 1
a164 1
		VEC_DEF	LanguageSelection
d247 1
a252 1
		move.l	d0,gm_Language(a5)	;Language is unknown.
d474 1
a474 1
*			      d1
d477 1
a477 1
*	Save the language selection into the base of the Game library.
d487 4
a490 1
		move.l	d1,gm_Language(a6)
d493 1
a493 1
******* game.library/LanguageSelection ***************************************
d496 1
a496 1
*	LanguageSelection - Returns the current language selection.
d499 1
a499 1
*	Language = LanguageSelection()
d502 1
a502 1
*	ULONG LanguageSelection (VOID)
d515 5
a519 2
LanguageSelection
		move.l	gm_Language(a6),d0
@


39.10
log
@Removed SetKeyThresh, SetKeyPeriod and SetTimerInterval.
Added LVOs for AddVBlankInt and RemVBlankInt.
@
text
@d4 1
a4 1
*	$Id: startup.asm,v 39.9 93/01/13 15:01:14 Jim2 Exp Locker: Jim2 $
d9 4
a79 1
		XREF	GameAnimPort
d90 1
d100 2
d174 1
a174 1
******l initFunc *************************************************************
d188 1
a188 1
*	    -	Initialize internal state variable used to determine type
d190 1
a190 1
*	    -	Set the priority used in system take over to 127
d192 1
a192 1
*	    -	Set the Last key to 0, not depressed.
a199 1
*	    -	Initialize the keyboard buffer semaphore.
d201 1
a201 2
*	    -	Use GetPrefs to intialize the keyboard repeat values.
*	    -	Mark whether this is the game machine, or not.
d214 3
a216 3
*	SegList	- Pointer to the memory allocated and loaded with the library
*		  code.
*	ExecBase - Pointer to the base of the Exec library.
d236 1
a236 1
		jsr	ReadJoyPortInit
d241 1
a241 1
		move.w	d0,gm_LastKey+2(a5)	;LastKey set to 0.
d243 1
a243 1
		move.w	d0,gm_LastKey(a5)	;LastKey set to 0.
d261 1
a261 12

				;The game machine will have a port for shutting down
				;the startup animation.  If that port exists, we are
				;in the game machine.

		lea	GameAnimPort(pc),a1
		JSRLIB	FindPort
		tst.l	d0
		beq.s	NotInGamesMachine	;If not animation port, we are not in the game machine.
		moveq	#1,d0
NotInGamesMachine:
		move.b	d0,gm_GameMachine(a5)
d300 1
d316 1
d318 1
a319 1
				;timer.device was opened so close it before failing.
a324 1

d332 1
a332 1
******l entry_open ***********************************************************
d356 1
a356 1
******l entry_close **********************************************************
d382 1
a382 1
******l entry_expunge ********************************************************
d392 12
a403 1
*	Closes the Utility libray and frees the library base.
d415 1
d441 2
a442 3
*
* Free my own library (we have no openers)
*
d447 1
a447 3
*
* Now, set up for the exit...
*
a457 1
*
d461 1
a461 1
******l SetLanguageSelection *************************************************
d490 1
a490 1
*	Language = LanguageSelection
d493 2
a508 7







@


39.9
log
@Removed KeyboardInterruptExtender.  Intialized the structures
used for autorepeat of the keyboard.
@
text
@d4 1
a4 1
*	$Id: startup.asm,v 39.8 93/01/07 15:59:08 Jim2 Exp Locker: Jim2 $
d9 4
a81 1
		XREF	SetTimerInterval
a82 1
		XREF	ConvertToFracTime
a91 2
		XREF	KeySetThresh
		XREF	KeySetPeriod
d93 3
a157 2
		VEC_DEF	KeySetThresh
		VEC_DEF	KeySetPeriod
a162 1
		VEC_DEF	SetTimerInterval
d164 2
d237 1
d239 1
a239 4
		move.l	d0,gm_LastKey(a5)	;LastKey set to 0.
		bset	#7,gm_LastKey(a5)	;No key pressed.
		move.w	d0,gm_KeyTail(a5)
		move.w	d0,gm_KeyHead(a5)
d243 1
a254 2
		lea	gm_KeyBufSemaphore(a5),a0
		JSRLIB	InitSemaphore
a256 22
		lea	IntuitionName(pc),a1	;"intuition.library"
		moveq	#0,d0			;Any version.
		JSRLIB	OpenLibrary
		tst.l	d0
		beq	init_fail		;The very unlikely possiblity that open fails.
		move.l	d0,a6			;Get ready to call an intuition function
TEMP_SIZE	set	0
		ARRAYVAR Pref,pf_DoubleClick
		ALLOCLOCALS sp			;Make room for a partional Preference structure.
		move.l	sp,a0
		move.l	#pf_DoubleClick,d0	;Need KeyRptSpeed, and KeyRptDelay.
		JSRLIB	GetPrefs
		move.l	a6,a1
		move.l	gm_ExecBase(a5),a6
		JSRLIB	CloseLibrary		;Don't need the library any more.
		add.l	#pf_KeyRptSpeed,sp	;Advance the pointer to the pf_KeyRptSpeed.
		movem.l	(sp)+,d0-d1		;Two long words in the correct order.  Advanced to next field
		jsr	ConvertToFracTime
		move.l	d0,gm_KeyRepDefault(a5)	;Save as a fixed point number.
		movem.l	(sp)+,d0-d1		;Two long words in the correct order.  Cleared all data from stack.
		jsr	ConvertToFracTime
		move.l	d0,gm_KeyThreshDefault(a5)	;Save as a fixed pointer number.
d485 1
a485 1
*	LanguageSelection - Returns the current language selection
a516 1
IntuitionName:	dc.b	'intuition.library',0
@


39.8
log
@Added intitialization of port controller state.
@
text
@d4 1
a4 1
*	$Id: startup.asm,v 39.7 93/01/07 14:31:43 Jim2 Exp Locker: Jim2 $
d9 3
d55 2
d80 1
d86 2
a87 2
		XREF	LastKeyPressed
		XREF	GetPressedKeys
d90 3
d151 2
a152 2
		VEC_DEF	LastKeyPressed
		VEC_DEF	GetPressedKeys
d155 2
d184 1
a184 1
*	    -	Set the Last key to $FF.
d192 1
d194 1
d231 1
a231 1
		move.b	#$7F,gm_TaskPri(a5)	;Set up highest priority.
a234 1
		move.w	d0,gm_LastKey(a5)	;LastKey set to -1.
d236 4
d254 2
d258 22
a531 75
*****i* game.library/KeyboardInterruptExtender *******************************
*
*   NAME
*	KeyboardInterruptExtender - Extends the functionality of the keyboard
*				    interrupt.
*
*   SYNOPSIS
*	KeyBoardInterrupt(GameBase)
*			  a0
*
*   FUNCTION
*	This is a kind of SetFunction for the keyboard interrupt.  During the
*	development of the game library it was decided to add functionality
*	the the existing keyboard.device.  In particular it was desireable to
*	get the last key hit and piggyback on top the the keyboard interrupt.
*
*	These two functions were best handled by replacing the keyboard
*	interrupt.  However, this is not practical for a library that is
*	intended to work on many platforms.  So this routine was developed to
*	place a wrapper around the existing keyboard interrupt.
*
*	When invoked this routine grabs the current keyboard key.  Then the
*	orginal keyboard interrupt is invoked to handle all of the hand
*	shaking.  Once this is done the key is checked.  If it is a keypress
*	and not a modifier, it is stored as the last key press.  Next the
*	value is checked againsts the keyboard control codes.  If it is not
*	one of these, the list of user keyboard interrupts is called.
*
*   INPUTS
*	GameBase - Pointer to game.library.  This is not in a6 since this
*		   function is an interrupt.
*
*   RESULT
*	NONE
*
*
******************************************************************************
KeyboardInterruptExtender
		movem.l	d2/a5-a6,-(sp)
		move.l	a1,a6			;Get game base into a6.
		moveq	#0,d2			;clear upper byte
		move.b	_ciaasdr,d2		;get the key.
		not.b	d2			;signal is active low
		ror.b	#1,d2			;move up/down to sign bit
		move.l	gm_KBOrig(a6),a0
		move.l	IS_DATA(a0),a1
		move.l	IS_CODE(a0),a5
		JSR     (A5)			;Execute the keyboard interrupt.
		btst	#7,d2			;If the most significant bit is set it is a key release.
		bne.s	KeyUp
		cmp.w	#$78,d2			;$78 is reset don't give it to the user.
		beq.s	NoChange
		move.w	d2,d1			;Checking to see if it is modifier key trashes the keycode.
		and.w	#$78,d1			;Modifier keys are in the range 60-67 inclusive.
		cmp.w	#60,d1
		beq.s	KeyUp

		move.w	d2,gm_LastKey(a6)	;Ok, it passed, remember it.
KeyUp		move.w	d2,d0
		subi.w	#$F9,d2
		bpl.s	NoChange		;Codes above $F8 are special control codes, the user doesn't want them.
		move.l	gm_KBInterrupts+MLH_HEAD(a6),a1
		bra.s	Test			;Get ready to scan the list, do it with a bottom testing loop.
ProcessList:	move.l	IS_CODE(a1),a5
		move.l	IS_DATA(a1),a1
		JSR     (A5)			;Execute the users interrupt.
		move.l	(sp)+,a1		;Restore the list pointer.
		move.w	(sp)+,d0		;Restore the key.
Test:		move.w	d0,-(sp)		;Remember the key.
		move.l	MLN_SUCC(a1),-(sp)	;Remember the list pointer.
		bne.s	ProcessList
		addq	#6,sp			;Remove the pointer from the stack.
NoChange:	movem.l	(sp)+,d2/a5-a6
		rts

d540 1
@


39.7
log
@Cleaned up comments, minimized include file list and changed
the initial LVO table back to relative.
@
text
@d4 1
a4 1
*	$Id: startup.asm,v 39.6 93/01/05 12:16:08 Jim2 Exp Locker: Jim2 $
d9 4
d78 1
d169 2
d217 1
@


39.6
log
@Added keyboard support.  Also renamed some routines to
make them nicer sounding.  And moved ReadJoyPort to first
non-standard function.
@
text
@d4 1
a4 1
*	$Id: Startup.asm,v 39.5 92/12/17 18:18:23 Jim2 Exp Locker: Jim2 $
d8 6
a13 1
*	$Log:	Startup.asm,v $
d38 1
a38 1
*	(C) Copyright 1992 Commodore-Amiga, Inc.
d42 1
a42 3
*
* System include files...
*
a43 2
	INCLUDE 'exec/types.i'
	INCLUDE 'exec/nodes.i'
a44 1
	INCLUDE	'exec/memory.i'
a45 1
	INCLUDE	'exec/execbase.i'
a52 6
	INCLUDE	'v:src/kickstart/rawinput/kbdata.i'


*
* Useful macros
*
d54 2
a55 7

	INCLUDE	'systemcontrol.i'

*
* Version string include file
*
	INCLUDE	'game_rev.i'
d82 2
a83 14
*
*******************************************************************************
*
	XREF	_AbsExecBase
*
*******************************************************************************
*
*
*******************************************************************************
*
* The library structure ...
*

	INCLUDE	'gamebase.i'
a91 5
*
*
*******************************************************************************
*
		XREF	Game_end
d96 11
a106 12
initLDescrip:				; STRUCTURE RT,0
		dc.w	RTC_MATCHWORD	; UWORD RT_MATCHWORD
		dc.l	initLDescrip	; APTR  RT_MATCHTAG
		dc.l	Game_end	; APTR  RT_ENDSKIP
		dc.b	RTF_AUTOINIT	; UBYTE RT_FLAGS
		dc.b	VERSION		; UBYTE RT_VERSION
		dc.b	NT_LIBRARY	; UBYTE RT_TYPE
		dc.b	0		; BYTE  RT_PRI
		dc.l	subsysName	; APTR  RT_NAME
		dc.l	VERSTR		; APTR  RT_IDSTRING
		dc.l	inittable	; APTR  RT_INIT
					; LABEL RT_SIZE
d123 1
a123 1
		DC.W	\1-vectors
a125 18
*vectors:
*		DC.W	-1
*		V_DEF	open
*		V_DEF	close
*		V_DEF	expunge
*		V_DEF	reserved
*		VEC_DEF	BeginShutdownAnim
*		VEC_DEF	WaitShutdownAnim
*		VEC_DEF	LanguageSelection
*		VEC_DEF	GetJoyPortEvent
*		VEC_DEF	GetLastKeyPressed
*		VEC_DEF	GetPressedKeys
*		VEC_DEF	SetTimer
*		VEC_DEF	CheckTimer
*		VEC_DEF	AddTimerInt
*		VEC_DEF	RemTimerInt
*		VEC_DEF	SystemControlA
*		DC.W	-1
d127 22
a148 21
		dc.l	entry_open
		dc.l	entry_close
		dc.l	entry_expunge
		dc.l	entry_reserved
		dc.l	ReadJoyPort
		dc.l	BeginShutdownAnim
		dc.l	WaitShutdownAnim
		dc.l	LanguageSelection
		dc.l	SetLanguageSelection
		dc.l	LastKeyPressed
		dc.l	GetPressedKeys
		dc.l	AddKBInt
		dc.l	RemKBInt
		dc.l	SystemControlA
		dc.l	AddTimerInt
		dc.l	RemTimerInt
		dc.l	StopTimerInt
		dc.l	StartTimerInt
		dc.l	SetTimerInterval
		dc.l	ElapsedTime
		dc.l	-1
d165 2
d168 8
a175 2
*	    -	Point the start of the list of processes the game library
*		knows about to a preallocated structure.
d178 7
d197 11
a207 11
initFunc:	movem.l	a5/a6,-(sp)			; Save library base...
		move.l	d0,a5
		move.l	a6,gm_ExecBase(a5)		; Store ExecBase...
		move.l	a0,gm_SegList(a5)		; Save seglist...
		clr.w	LIB_OPENCNT(a5)			; Clear the open count
		lea	subsysName(pc),a0		; Get the name
		move.l	a0,LN_NAME(a5)			;  into ln_Name field
		lea	VERSTR(pc),a0			; Get ID string...
		move.l	a0,LIB_IDSTRING(a5)		; Store it...
		move.w	#VERSION,LIB_VERSION(a5)	; Set up version
		move.w	#REVISION,LIB_REVISION(a5)	;   and revision...
d209 3
a211 3
					;Game library specific initialization.
		move.b	#$7F,gm_TaskPri(a5)		; Set up highest priority.
		moveq	#-1,d0				;Nesting counts start at -1.
d214 1
a214 1
		move.w	d0,gm_LastKey(a5)	;LastKey and LastBuffer set to -1.
d216 12
a227 3
		move.l	d0,gm_SystemOwner(a5)		;No one owns the system yet.
		move.l  d0,gm_CIATimer+gmct_TimerInt+IS_CODE(a5)	;Initialize the timer interrupt structure.
		move.l	d0,gm_Language(a5)
d231 1
a231 1
		NEWLIST a1
d233 4
d240 2
a241 2
		beq.s	NotInGamesMachine		;If not animation port, we are not in the game machine.
		move.s	#1,gm_GameMachine(a5)
d243 7
a249 7
		lea	UtilName(pc),a1			; "utility.library"
		moveq	#0,d0				; Any version...
		JSRLIB	OpenLibrary			; Open it...
		move.l	d0,gm_UtilBase(a5)		; Store utility base
		beq.w	init_fail			; If NULL, we failed!
							;Open timer.device

d252 1
a252 1
		ALLOCLOCALS sp				;Need a timerrequest to open the timer device.
d257 3
a259 2
		JSRLIB	OpenDevice			;Open the microhz timer.
		tst.b	d0				;Test the return value from OpenDevice.
d262 1
a262 1
		move.l	a6,gm_TimerDevice(a5)		;Save the pointer to the timer device.
d266 1
a266 1
							;Open keyboard.device.
d269 1
a269 1
		move.l	sp,a1				;Still have temporary variables on the stack.
d272 2
a273 2
		JSRLIB	OpenDevice			;Open the keyboard device.
		tst.b	d0				;Test the return value from OpenDevice.
d275 2
d278 10
a287 7
		move.l	Request+IO_DEVICE(sp),gm_KBDevice(a5)
		lea	CIAARESOURCE(pc),a1	;CIAA resource timer B_SP is used
		JSRLIB	OpenResource		;by keyboard.device.  The interrupt
		move.l	d0,a6			;attached is the keyboard interrupt.
		move.w	#CIAICRB_SP,d0		;AddICRVector to this timer will
		JSRLIB	AddICRVector		;return a pointer to the interrupt
		move.l	d0,KBOrig(pc)		;structure.  Save it.
d291 1
a291 2
		move.l	a5,KBExtend+IS_DATA(pc)
		lea	KBExtend(pc),a1
d294 2
a295 2
		move.l	a5,d0				; Set return value
		DONELOCALS sp				;Clear the stack.
d297 3
a299 1
NoKeyBoard:
d302 3
a304 1
		JSRLIB	CloseDevice			;Close the microhz timer.
d306 1
a306 2
NoTimer:						;Open failed.
		DONELOCALS sp				;Clear the stack.
d308 3
a310 3
		JSRLIB	CloseLibrary			;Close the utility library.
init_fail:	moveq	#0,d0				;Mark failure.
init_go		movem.l	(sp)+,a5/a6
d347 1
a347 2
*	Decrements the library count and frees anything associated with the
*	current task.
d359 1
a359 1
entry_close:	subq.w	#1,LIB_OPENCNT(a6)	; Count the close
d382 4
a385 4
entry_expunge:	moveq.l	#0,d0			; Clear d0
		tst.w	LIB_OPENCNT(a6)		; Check if Zero
		bne.w	expunge_done		; If non-zero, we don't go
		movem.l	a5-a6,-(sp)
d392 1
a392 1
		lea	KBExtend(pc),a1
d394 1
a394 1
		move.l	KBOrig(pc),a1
d414 3
a416 3
		move.w	LIB_NEGSIZE(a5),d0	; Get negative size
		sub.l	d0,a1			; Point at start of library
		add.w	LIB_POSSIZE(a5),d0	; Add in positive size
d420 9
a428 9
		movem.l	d2,-(sp)		; Save
		move.l	gm_SegList(a5),d2	; Get seglist...
		movem.l	d0/a1,-(sp)		; Save these...
		move.l	a5,a1			; We need to remove ourselves from
		JSRLIB	Remove			; the library list...
		movem.l	(sp)+,d0/a1		; Restore these...
		JSRLIB	FreeMem			; Free the memory...
		move.l	d2,d0			; Get seglist into return...
		movem.l	(sp)+,d2		; Restore
d431 1
a431 1
expunge_done:	rts				; Return from expunge...
d492 1
a492 1
*			  a0	  d1
d494 21
a514 14
*
*	VOID GetMultipleKeys(UBYTE *, UBYTE)
*
*   FUNCTION
*	Calling this function causes the key board to be scanned for keys.
*	The keys are scanned in increasing numerical order by their raw key
*	code.  This function returns all depressed keys encountered in this
*	scan until ArraySize keys have been read.
*
*   INPUTS
*	KeyArray - Pointer to memory into which the raw codes for the keys
*		   are placed.  If there are not enough keys to fill this
*		   array FF is placed after the last valid key.
*	ArraySize - Size of KeyArray in bytes.
a518 2
*   SEE ALSO:
*	GetPressedKey
d524 2
a525 2
		moveq	#0,d2			; clear upper byte
		move.b	_ciaasdr,d2		; get the key.
d528 1
a528 1
		move.l	KBOrig(pc),a0
d544 1
a544 1
		bpl.s	NoChange
d546 1
a546 1
		bra.s	Test
d550 4
a553 4
		move.l	(sp)+,a1
		move.w	(sp)+,d0
Test:		move.w	d0,-(sp)
		move.l	MLN_SUCC(a1),-(sp)
a565 8
KBExtend:	dc.l	0			;LN_SUCC
		dc.l	0			;LN_PRED
		dc.b	NT_INTERRUPT		;LN_TYPE
		dc.b	0			;LN_PRI
		dc.l	0			;LN_NAME
		dc.l	0			;IS_DATA
		dc.l	KeyboardInterruptExtender;IS_CODE
KBOrig		ds.l	1
@


39.5
log
@Added LVOs for working with CIA timer interrupts.  Also 
changed the names for the routines dealing with the animation.
And added the LVO for elapsed time.
@
text
@d4 1
a4 1
*	$Id: Startup.asm,v 39.4 92/12/14 15:03:57 Jim2 Exp Locker: Jim2 $
d9 5
d51 6
d70 1
a70 1

d72 5
a76 2
		XREF	BeginKillStartupAnim
		XREF	WaitKillStartupAnim
d83 10
a92 2

		XREF	GameAnimPort
d162 2
a163 2
*		VEC_DEF	BeginKillStartupAnim
*		VEC_DEF	WaitKillStartupAnim
d179 3
a181 2
		dc.l	BeginKillStartupAnim
		dc.l	WaitKillStartupAnim
d183 2
a184 2
		dc.l	GetJoyPortEvent
		dc.l	GetLastKeyPressed
d186 2
d229 5
a233 4
initFunc:	move.l	d0,a1				; Pointer to base
		move.l	a6,gm_ExecBase(a1)		; Store ExecBase...
		move.l	a0,gm_SegList(a1)		; Save seglist...
		clr.w	LIB_OPENCNT(a1)			; Clear the open count
d235 1
a235 1
		move.l	a0,LN_NAME(a1)			;  into ln_Name field
d237 3
a239 3
		move.l	a0,LIB_IDSTRING(a1)		; Store it...
		move.w	#VERSION,LIB_VERSION(a1)	; Set up version
		move.w	#REVISION,LIB_REVISION(a1)	;   and revision...
d242 1
a242 1
		move.b	#$7F,gm_TaskPri(a1)		; Set up highest priority.
d244 3
a246 2
		move.b	d0,gm_NestOwn(a1)
		move.b	d0,gm_NestReq(a1)
d248 4
a251 4
		move.l	d0,gm_SystemOwner(a1)		;No one owns the system yet.
		move.l  d0,gm_CIATimer+gmct_TimerInt+IS_CODE(a1)	;Initialize the timer interrupt structure.
		move.l	a1,-(sp)			; Save library base...
		lea	gm_ShutdownSemaphore(a1),a0	;Set up the semaphore used for animiation shutdown.
d253 2
d260 1
a260 2
		move.l	(sp),a1				;Get the library base.
		move.s	#1,gm_GameMachine(a1)
d265 3
a267 3
		move.l	(sp),a1				; Restore library base
		move.l	d0,gm_UtilBase(a1)		; Store utility base
		beq.s	init_nogo			; If NULL, we failed!
d277 40
a316 1
		move.l	Request+IO_DEVICE(sp),d1	;Put the base pointer into d1.
d318 1
a318 5
		move.l	(sp),a1				;Restore the game library base.
		tst.b	d0				;Test the return value from OpenDevice.
		beq.s	OpenedTimer
							;Open failed.
		move.l	gm_UtilBase(a1),a1
d320 2
a321 15
		moveq	#0,d0				;Mark failure.
		bra.s	init_nogo
OpenedTimer	move.l	d1,gm_TimerDevice(a1)
		move.l	d1,a6
TEMP_SIZE	set	0
		ARRAYVAR Dummy,8
		ALLOCLOCALS sp				;Need a timerrequest to open the timer device.
		move.l	sp,a0			;This was just utilized during OpenDevice.
		JSRLIB	ReadEClock
		DONELOCALS sp
		move.l	(sp),a1
		move.l	d0,gm_EClockConversion(a1)
		move.l	a1,d0				; Set return value
		move.l	gm_ExecBase(a1),a6
init_nogo:	addq.l	#4,sp				;Restore the stack (has library base on it).
d347 1
d396 1
a396 2
		bne.s	expunge_done		; If non-zero, we don't go

d399 10
d411 1
a411 1
		JSRLIB	CloseLibrary
d414 1
a414 1
		ALLOCLOCALS sp				;Need a timerrequest to open the timer device.
d417 5
a421 3
		JSRLIB	CloseDevice			;Open the microhz timer.
		DONELOCALS sp				;Clear the stack.

d446 47
d496 68
a563 6
LanguageSelection
GetJoyPortEvent
GetLastKeyPressed
GetPressedKeys
RebootOnDiskRemove
		moveq	#1,d0
d568 3
d572 9
a581 1
VERSTR:		VSTRING
d583 1
@


39.4
log
@During testing had difficulty with relative offsets for the LVOs.
Changed to absolute.
@
text
@d4 1
a4 1
*	$Id: Startup.asm,v 39.3 92/12/11 14:17:25 Jim2 Exp Locker: Jim2 $
d9 4
d35 1
d44 2
d56 1
a56 1
	INCLUDE	'gamelib_rev.i'
d63 8
a71 2
		XDEF	vectors

d163 1
a163 2
		dc.l	SetTimer
		dc.l	CheckTimer
d166 5
a170 2
		dc.l	SystemControlA
		DC.l	-1
d217 1
a217 1
		moveq	#-1,d0
d222 1
d224 2
d228 1
a228 1
		CALLSYS	FindPort
d230 2
a231 1
		beq.s	NotInGamesMachine
d236 2
a237 2
		CALLSYS	OpenLibrary			; Open it...
		move.l	(sp)+,a1			; Restore library base
d240 29
d270 3
a272 1
init_nogo:	rts
d351 8
a358 2
		CALLSYS	CloseLibrary

d374 1
a374 1
		CALLSYS	Remove			; the library list...
d376 1
a376 1
		CALLSYS	FreeMem			; Free the memory...
a390 4
SetTimer
CheckTimer
AddTimerInt
RemTimerInt
a398 1
GameAnimPort	dc.b	'Startup Animation',0
d400 1
@


39.3
log
@Removed all of the currently implemented LVO other than
the standard four:  open, close, expunge, and extra.
@
text
@d4 1
a4 1
*	$Id: startup.asm,v 39.2 92/12/09 18:16:57 Jim2 Exp Locker: Jim2 $
d8 5
a12 1
*	$Log:	startup.asm,v $
d54 4
d121 18
d140 16
a155 17
		DC.W	-1
		V_DEF	open
		V_DEF	close
		V_DEF	expunge
		V_DEF	reserved
		VEC_DEF	ShutdownAnim
		VEC_DEF	WaitAnim
		VEC_DEF	LanguageSelection
		VEC_DEF	GetJoyPortEvent
		VEC_DEF	GetLastKeyPressed
		VEC_DEF	GetPressedKeys
		VEC_DEF	SetTimer
		VEC_DEF	CheckTimer
		VEC_DEF	AddTimerInt
		VEC_DEF	RemTimerInt
		VEC_DEF	SystemControlA
		DC.W	-1
a330 2
ShutdownAnim
WaitAnim
@


39.2
log
@Got the autodoc comments added and implemented the LVO for
TurnOffRequesters.
@
text
@d4 1
a4 1
*	$Id: startup.asm,v 39.1 92/12/08 16:50:48 Jim2 Exp Locker: Jim2 $
d9 4
d49 1
a49 4
		XREF	OwnSystem
		XREF	GiveupSystem
		XREF	NoRequesters
		XREF	OnRequesters
a118 2
		VEC_DEF	TakeOverSystem
		VEC_DEF	TurnOffRequesters
a120 1
		VEC_DEF	RebootOnDiskRemove
d177 3
a181 2
		lea	InitProc(pc),a0
		move.l	a0,gm_ProcList(a1)
d183 7
d191 1
a191 1
		moveq.l	#0,d0				; Any version...
d209 2
a210 6
*	Increments the library count and adds the process to the list of
*	processes known.
*
*	Don't forget, there is nothing to prevent someone from multiply
*	opening the game library in a single process.  So check for the
*	existance before adding a new structure.
d219 2
a220 51
entry_open:	move.l	a5,-(sp)
		movea.l	a6,a5
		move.l	gm_ExecBase(a5),a6
		CALLSYS Forbid			;Forbid (a6>ExecBase)
		moveq	#0,d0
		move.l	d0,a1
		CALLSYS	FindTask		;FindTask (a1>Null:Current Task, a6>ExecBase)
						;The Current task pointer is in d0.
		move.l	d0,a1
		move.l	gm_ProcList(a5),a0
		tst.l	gbpi_Process(a0)
		beq.s	FoundProcess		;If the elements has not yet been used the process pointer is NULL.
						;Check the process pointer against the stored information.
SearchList:	cmpa.l	gbpi_Process(a0),a1
		beq.s	FoundProcess
						;The process pointer does not match
						;the current process.
		tst.l	gbpi_Next(a0)
		beq.s	AddNewProcess
						;There still remain more structures to
						;check.
		move.l	gbpi_Next(a0),a0
		bra.s	SearchList

						;A new element needs to be created to
						;store the information on this process.

AddNewProcess:  movem.l a0-a1,-(sp)		;Save the pointers.
		moveq	#gbpi_SIZE,d0
		move.l	#MEMF_CLEAR,d1
		CALLSYS	AllocMem		;AllocMem(d0>#bytes, d1>type, a6>ExecBase)
		movem.l	(sp)+,a0-a1		;Restore the pointers
		move.l	d0,gbpi_Next(a0)	;The new structure is the next to be used.
		move.l	d0,a0			;Advance to that structure.
		moveq	#0,d0
		tst.l	a0
		beq.s	FailedOpen		;If a NULL was returned there was a error.

		moveq	#-1,d0
		move.l	d0,gbpi_Window(a0)	;The Window pointer must be initialized to -1.
						;Store the process pointer and the window pointer.
FoundProcess:	move.l	a1,gbpi_Process(a0)
		addi.w	#1,gbpi_OpenCnt(a0)
						;Permit and exit

		addq.w	#1,LIB_OPENCNT(a5)	;Count the open
		move.l	a5,d0			;Return library base
FailedOpen:
		CALLSYS	Permit			;Permit (a6>ExecBase)
		move.l	(sp)+,a5

d235 1
a235 2
*	This library does not autoexpunge, however it does free any memory
*	associated with any process that is nolonger using it.
a242 31
*   REGISTER Usage:
*	d0 - Various temporary values.
*	a0 - The gbpi that points to the gpbi that contains information on this
*	     process.
*	a1 - The gpbi that contains information on this process.
*	a4 - The task pointer.  A pointer used for coping THE NEXT gpbi on top
*	     of the no longer utilized gpbi.
*	a5 - Library base
*	a6 - SysBase
*
*   ALGORTHIM
*	Forbid()
*	ProcPtr=FindTask(NULL)
*	Walk=Save=GameBase->ProcList
*	while (Walk->Process = ProcPtr)
*	    Save=Walk
*	    Walk=Walk->Next
*	    if (Walk == NULL)
*		goto exit:
*	if (--(Walk->OpenCnt) == 0)
*	    if (Walk->Next != NULL)
*	        copy(Walk->Next,Walk,sizeof(gbpi))
*	    else
*	        Save->Next=Null
*	    if (Walk != Save)	Not the first element.
*	        FreeMem(Walk, sizeof(gpbi)
*	    else
*	        Walk->Process = NULL
*	DecrementLibraryCounter(GameLib)
*	exit:
*	Permit()
d245 1
a245 4
entry_close:	movem.l	a4-a5,-(sp)
		movea.l	a6,a5
		move.l	gm_ExecBase(a5),a6
		CALLSYS Forbid		;Forbid (a6>ExecBase)
a246 46
		move.l	d0,a1
		CALLSYS	FindTask	;FindTask (a1>Null:Current Task, a6>ExecBase)
					;The Current task pointer is in d0.
		move.l	d0,a4
		move.l	gm_ProcList(a5),a0
		move.l	a0,a1		;Initialize Walk and Save.
Search:		cmpa.l	gbpi_Process(a1),a4
		beq.s	Matched		;The process info has been found.
		move.l	a1,a0
		move.l	gbpi_Next(a1),a1
		tst.l	a1
		beq.s	FailedClose	;This should never ever happen.
		bra.s	Search
					;Found the structure for the process.
Matched:	subi.w	#1,gbpi_OpenCnt(a1)
		bne.s	DecrementLibCnt	;Multiple opened, wait for the last one.
					;The current process no longer wants this library.
		tst.l	gbpi_Next(a1)
		beq.s	NoNext
					;Copy the next gbpi structure on top of this one.
		move.l	a0,-(sp)
		move.l	gbpi_Next(a1),a4
		moveq	#gbpi_SIZE,d0
					;This is the copy loop
MoveData:	move.b	(a4)+,(a1)+
		dbne.s	d0,MoveData
		move.l	(sp)+,a1
		bra.s	Free
					;There is no next gpbi structure, so unhook this one.
NoNext:		moveq	#0,d0
		move.l	d0,gbpi_Next(a0)

Free:		cmpa.l	a0,a1
		beq.s	NullProcess
					;There is a structure to free.
		moveq	#gbpi_SIZE,d0
		CALLSYS	FreeMem		;AllocMem(d0>#bytes, d1>type, a6>ExecBase)
		bra.s	DecrementLibCnt
					;There is no structure to free.
NullProcess:	move.l	d0,gbpi_Process(a1)

DecrementLibCnt:
		subq.w	#1,LIB_OPENCNT(a6)	; Count the close
FailedClose:
		CALLSYS	Permit		;Permit (a6>ExecBase)
		movem.l	(sp)+,a4-a5
d272 1
a272 1
		move.l	a5,-(sp)
d298 1
a298 1
		move.l	(sp)+,a5
a301 178
******* game.library/TakeOverSystem ******************************************
*
*   NAME
*	TakeOverSystem - Shutdown or reenable multitasking.
*
*   SYNOPSIS
*	Success = TakeOverSystem (systemState)
*	D0			  D1
*
*	BOOL TakeOverSystem (BOOL);
*
*   FUNCTION
*	This function can used by a process to either take over the CPU, or
*	if the task already owns the CPU, to relinquish the CPU.
*
*	Once a task has issued this call no other task will ever be allowed
*	to use the CPU until the owning task either does a wait, or
*	reliquishes the CPU - USE WITH CAUSION.  Any calls to the OS that
*	involve multitasking will also be held up as long as any task has
*	taken over the CPU.
*
*	Since multitasking is reenabled during a wait has been issued, it is
*	possible for this call to fail (second task requesting the system
*	after the first has done a wait).  Check the return value.
*
*   INPUTS
*	SystemState - boolean that determines whether the multitasking is to
*		      be shutdown or reenabled.
*
*   RESULT
*	result - when attempting a shutdown of multitask indicates success,
*		 or failure.
*
*   SEE ALSO
*	SystemControl
*
******************************************************************************
TakeOverSystem
		tst.w	d1
		bne	OwnSystem
		jmp	GiveupSystem


******* game.library/TurnOffRequesters ***************************************
*
*   NAME
*	TurnOffRequesters - Inhibit any requestors that might arise from this
*		process.
*
*   SYNOPSIS
*	TurnOffRequesters (reqestorState)
*			   D1
*
*	TurnOffRequesters (BOOL);
*
*   FUNCTION
*	This function can used by a process to either surpress any
*	requesters from being generated from this process, or allow
*	requesters.
*
*	????This function does not disable file system requesters.
*
*	These are the reasons when you would NOT want turn off system
*	requesters:
*
*	    -	You don't want them turned off.
*	    -	You are not doing anything that would cause a system
*		requester to appear.
*	    -	The only thing that could cause a requester to appear is the
*		lack of a CD in the drive and you have "Reset on disk
*		removal" FORCED ON, therefore a requester can't appear.
*	    -	Item 3 is true, AND all other disk I/O is done through
*		nonvolatile.library (nonvolatile.library turns off requesters
*		when it needs to).
*
*	To help narrow down your options a bit, let me say the following:  If
*	you are programming a game, you should never want a system requester
*	to appear, so item 1 should never apply to you.  If your game gets
*	loaded, begins running, and never access a dos function again, then
*	item 2 will apply.  Otherwise, if you are intermittently going back
*	to the CD after your application has begun, you will either need to
*	turn off requesters, or FORCE ON reset on removal of the CD.  If your
*	application is a game, and you are allowing users to save high
*	scores, game position, etc...; you SHOULD be doing so through the
*	nonvolatile.library, and therefore,item 4 should be equivalent to
*	item 3.
*
*	To summarize, if you are programming a game, you should NOT NEED to
*	turn off requesters if any of the following apply:
*
*	    -	You are not calling any dos functions after your game has
*		loaded.
*	    -   Reset on removal of the CD is FORCED ON.
*
*	NOTE: nonvolatile.library should always be used for loading saving
*	user data.
*
*	Non-Game titles:
*
*	If your CD application requires more complex operations than
*	nonvolatile.library provides, by all means, use the traditional
*	methods.  Nonvolatile.library is provided to make saving relatively
*	small amounts of user data (game high scores, game position/equipment
*	information, etc...) to the best available device (NVRAM, floppy,
*	harddisk, etc...) an easy exercise.  It is provided for your
*	convenience.  Use it when practical, but if it is not powerful enough
*	for your needs (because you want to render 3-D images to disk or
*	something), use traditional methods.  Nonvolatile.library is designed
*	for small amounts of high-score-like information.
*
*   INPUTS
*	SystemState - boolean that determines whether the requesters are
*		      inhibited, or allowed.
*
*   RESULT
*	result - indicates success, or failure.  Failure can occur if a task that
*		 has not explictly opened game library utilizies this function.
*
*   SEE ALSO
*	SystemControl
*
******************************************************************************
TurnOffRequesters
		tst.w	d1
		bne	NoRequesters
		jmp	OnRequesters


******* game.library/SystemControlA ********************************************
*
*   NAME
*	SystemControlA - Method for selectively disabling OS features.
*	SystemControl - varargs stuv for SystemControlA().
*
*   SYNOPSIS
*	Success = SystemControlA (tagList)
*	D0			  A2
*
*	ULONG SystemControlA (struct TagItem *);
*
*	Success = SystemControl(firsttag, ...)
*
*	ULONG SystemControl(Tag, ...);
*
*   FUNCTION
*	This function can be used to selectively enable and disable various
*	of the system features.
*
*	This call takes a tag list and some of the features can be duplicated
*	by other calls in the Game Library.
*
*   INPUTS
*	tagList - pointer to an array of tags listing the features of the system
*		  to be enabled/disabled.
*
*   TAGS
*	STAG_OWNSYS:
*	TRUE - Disables multitasking, identical to TakeOverSystem.
*	FALSE - Enables multitaasking, identical to TakeOverSystem.
*
*	STAG_KILLREQ:
*	TRUE - Disables requesters, identical to TurnOffRequesters.
*	FALSE - Enables requesters, identical to TurnOffRequesters.
*
*   RESULT
*	result - when attempting a shutdown of multitask indicates success,
*		 or failure.
*
*   SEE ALSO
*	TakeOverSystem, TurnOffRequesters
*
*******************************************************************************
SystemControlA

TEMP_SIZE	set	0			;Determine the number of bytes wanted for local variables
		LONGVAR	TagState
		LONGVAR	ReturnValue
		LONGVAR	GameBase
a302 12
		ALLOCLOCALS sp			;Make some local variables on the stack.
		move.l	a1,TagState_l(sp)	;Save the pointer to the Taglist.
		moveq	#0,d0
		move.l	d0,ReturnValue_l(sp)	;A return value of zero means no error.
		move.l	a6,GameBase_l(sp)	;Place the Game Library base on the stack.
		move.l	gm_UtilBase(a6),a6
tagparse:
		lea	TagState_l(sp),a0
		CALLSYS	NextTagItem		;NextTagItem(a6>UtilBase, a0>**TagItem)
						;Points to the tag to be handled, or NULL if complete.
		tst.l	d0
		beq.s	donetags
a303 14
		move.l	d0,a0
		move.l	(a0)+,d0		;Tag into d0.
		move.l	(a0)+,d1		;Tag data into d1.
		sub.l	#STAG_OWNSYS,d0		;Lowest numbered tag is STAG_OWNSYS.
		bne.s	not_ownsystem
						;STAG_OWNSYS.
		move.l	GameBase_l(sp),a6
		jsr	TakeOverSystem		;TakeOverSystem(a6>GameBase, d1>TRUE/FALSE)
						;d0 indicates success, or failure.
		tst.l	d0
		bne.s	tagparse
						;TakeOverSystemFailed, record that.
		ori.l	#GAMF_CANTOWN,ReturnValue_l(sp)
		bra.s	tagparse
a304 16
not_ownsystem:	subq.l	#1,d0
		bne.s	not_killreq
						;STAG_KILLREQ
		move.l	GameBase_l(sp),a6
		jsr	TurnOffRequesters	;TurnOffRequesters(a6>GameBase, d1>TRUE/FALSE)
						;d0 indicates success, or failure.
		tst.l	d0
		bne.s	tagparse
						;TakeOverSystemFailed, record that.
		ori.l	#GAMF_CANTKILLREQ,ReturnValue_l(sp)
		bra.s	tagparse
not_killreq:	bra.s	tagparse
						;Completed parseing the tag list.
donetags:	move.l	ReturnValue_l(sp),d0
		DONELOCALS sp
		rts
a307 1
ResetOnDiskRemove
a320 9
*
*******************************************************************************
* Allocate storage for the first process in the process list.
*
InitProc:	DC.W	0
		DC.W	0
		DC.L	0				;Process Pointer
		DC.L	-1				;Window Pointer
		DC.L	0				;Pointer to the next gbpi.
d324 1
@


39.1
log
@Now it actually opens, closes, expunges and TakeOverSystem.
@
text
@d1 1
d4 1
a4 1
*	$Id: startup.asm,v 39.0 92/12/07 16:08:39 Jim2 Exp Locker: Jim2 $
d9 3
d47 2
a48 14
*		XREF	TurnOffRequesters
*		XREF	RestoreRequesters
*		XREF	ShutdownAnim
*		XREF	WaitAnim
*		XREF	ResetOnDiskRemove
*		XREF	LanguageSelection
*		XREF	GetJoyPortEvent
*		XREF	GetLastKeyPressed
*		XREF	GetPressedKeys
*		XREF	SetTimer
*		XREF	CheckTimer
*		XREF	AddTimerInt
*		XREF	RemTimerInt
*
d134 20
d155 5
a159 1
*******************************************************************************
d161 3
a163 1
* Initialized the library base as we know it...
d165 1
a168 4
		moveq	#0,d0
		move.l	d0,gm_SystemOwner(a1)		;No one owns the system yet.
		lea	InitProc(pc),a0
		move.l	a0,gm_ProcList(a1)
a169 1
		move.b	#$7F,gm_TaskPri(a1)		; Set up highest priority.
d176 7
d192 17
d210 2
a211 1
*******************************************************************************
d213 2
a214 1
* A call to Open...  Rather simple.
d216 52
a267 2
entry_open:	addq.w	#1,LIB_OPENCNT(a6)	; Count the open
		move.l	a6,d0			; Return library base
d269 12
d282 8
a289 1
*******************************************************************************
d291 31
a321 1
* Again, rather simple.  We will not auto-expunge on a close.
d323 52
a374 2
entry_close:	subq.w	#1,LIB_OPENCNT(a6)	; Count the close
		moveq	#0,d0			; return 0
d376 12
d389 2
a390 1
*******************************************************************************
d392 2
a393 1
* This is the expunge vector.
d395 1
a405 11
		move.l	gm_ProcList(a5),a1
		move.l	#gbpi_SIZE,d0
FreeProcessInfo:
		move.l	gbpi_Next(a1),a1
		tst.l	a1
		beq.s	DoneFree
		movem.l	d0/a1,-(sp)
		CALLSYS	FreeMem
		movem.l	(sp)+,d0/a1
		bra	FreeProcessInfo
DoneFree:
d430 1
a430 1
****** TakeOverSystem ********************************************************
d436 1
a436 1
*	Success = TakeOverSystem (SystemState)
d442 12
a453 2
*	This function can used by a process to either take over the CPU, or if
*	the task already owns the CPU, to relinquish the CPU.
d455 3
a457 12
*	Once a task has issued this call no other task will ever be allowed to
*	use the CPU until the owning task either does a wait, or reliquishes
*	the CPU - USE WITH CAUSION.  Any calls to the OS that involve multitasking
*	will also be held up as long as any task has taken over the CPU.
*
*	Since multitasking is reenable after a wait has been issued, it is
*	possible for this call to fail (second task requesting the system after
*	the first has done a wait).  Check the return value.
*
*   INPUTS
*	SystemState - boolean that determines whether the multitasking is to be
*		      shutdown or reenabled.
d460 2
a461 2
*	result - when attempting a shutdown of multitask indicates success, or
*		 failure.
d473 86
a558 1
****** SystemControlA ********************************************************
d562 1
d565 6
a570 2
*	Success = SystemControlA (TypeOfControl)
*	D0			  D0
d572 1
a572 1
*	ULONG TakeOverSystem (TagItem);
d574 10
a583 16
*   FUNCTION
*	This function can used by a process to either take over the CPU, or if
*	the task already owns the CPU, to relinquish the CPU.
*
*	Once a task has issued this call no other task will ever be allowed to
*	use the CPU until the owning task either does a wait, or reliquishes
*	the CPU - USE WITH CAUSION.  Any calls to the OS that involve multitasking
*	will also be held up as long as any task has taken over the CPU.
*
*	Since multitasking is reenable after a wait has been issued, it is
*	possible for this call to fail (second task requesting the system after
*	the first has done a wait).  Check the return value.
*
*   INPUTS
*	SystemState - boolean that determines whether the multitasking is to be
*		      shutdown or reenabled.
d585 9
d595 2
a596 2
*	result - when attempting a shutdown of multitask indicates success, or
*		 failure.
d599 1
a599 1
*	SystemControl
d601 1
a601 1
******************************************************************************/
d604 1
a604 1
TEMP_SIZE	set	0
d607 1
d609 2
a610 1
		ALLOCLOCALS sp
d612 2
a613 2
		move.l	d0,ReturnValue_l(sp)
		move.l	a6,-(sp)
d616 3
a618 2
		lea	TagState_l,a0
		CALLSYS	NextTagItem
d621 1
d623 3
a625 3
		move.l	(a0)+,d0
		move.l	(a0)+,d1
		sub.l	#STAG_OWNSYS,d0
d627 4
a630 2
		move.l	(sp),a6
		jsr	TakeOverSystem
d633 1
d636 15
a650 3
not_ownsystem:  bra.s	tagparse
donetags:	move.l	(sp)+,a6
		move.l	ReturnValue_l(sp),d0
a653 1
TurnOffRequesters
d674 3
a676 1
InitProc:	DC.L	0				;Process Pointer
@


39.0
log
@Initial release prior to testing.
@
text
@d3 1
a3 1
*	$Id$
d7 3
a9 1
*	$Log$
d11 1
d116 3
d126 14
a139 14
		DC.W	TakeOverSystem
		DC.W	TurnOffRequesters
		DC.W	ShutdownAnim
		DC.W	WaitAnim
		DC.W	RebootOnDiskRemove
		DC.W	LanguageSelection
		DC.W	GetJoyPortEvent
		DC.W	GetLastKeyPressed
		DC.W	GetPressedKeys
		DC.W	SetTimer
		DC.W	CheckTimer
		DC.W	AddTimerInt
		DC.W	RemTimerInt
		DC.W	SystemControlA
a143 8
* Allocate storage for the first process in the process list.
*
InitProc:	DC.L	0				;Process Pointer
		DC.L	-1				;Window Pointer
		DC.L	0				;Pointer to the next gbpi.

*
*******************************************************************************
d153 1
a153 1
		move.l	a0,gm_ProcList
d206 1
d217 4
a220 5
		move.l	a5,a6
		move.w	LIB_NEGSIZE(a6),d0	; Get negative size
		sub.l	d0,a5			; Point at start of library
		add.w	LIB_POSSIZE(a6),d0	; Add in positive size
		move.l	(sp)+,a5
d224 2
a225 4
		movem.l	d2/a6,-(sp)		; Save
		move.l	gm_SegList(a6),d2	; Get seglist...
		move.l	a6,a0			; Store library base...
		move.l	gm_ExecBase(a6),a6	; Get ExecBase
d227 1
a227 1
		move.l	a0,a1			; We need to remove ourselves from
d232 2
a233 1
		movem.l	(sp)+,d2/a6		; Restore
d365 8
d374 1
a374 1
UtilName:	dc.b	'Utility.library',0
@
