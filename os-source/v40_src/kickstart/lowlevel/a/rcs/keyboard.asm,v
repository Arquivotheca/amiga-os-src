head     40.11;
branch   ;
access   ;
symbols  V40_35:40.11 rel40_34:40.10 rel40_33:40.10 rel40_32:40.10 rel40_29:40.10 rel40_28:40.10 rel40_27:40.9 rel40_26:40.9 rel40_25:40.9 rel40_24:40.8 rel40_23:40.8 rel40_22:40.8 rel40_21:40.8 rel40_20:40.8 rel40_19:40.8 rel40_18:40.8 rel40_17:40.8 rel40_16:40.8 rel40_15:40.6 rel40_14:40.6 rel40_13:40.5 rel40_12:40.5 rel40_11:40.5 rel40_4:40.0 rel40_3:40.0 rel40_2:39.4 rel40_1:39.4 rel39_7:39.4 rel39_6:39.2 rel39_5:39.1 rel39_4:39.0;
locks    ; strict;
comment  @* @;


40.11
date     93.07.30.16.07.39;  author vertex;  state Exp;
branches ;
next     40.10;

40.10
date     93.05.05.09.54.40;  author gregm;  state Exp;
branches ;
next     40.9;

40.9
date     93.04.20.14.16.10;  author Jim2;  state Exp;
branches ;
next     40.8;

40.8
date     93.03.31.18.44.30;  author Jim2;  state Exp;
branches ;
next     40.7;

40.7
date     93.03.31.18.14.41;  author Jim2;  state Exp;
branches ;
next     40.6;

40.6
date     93.03.23.14.41.12;  author Jim2;  state Exp;
branches ;
next     40.5;

40.5
date     93.03.10.12.22.18;  author Jim2;  state Exp;
branches ;
next     40.4;

40.4
date     93.03.04.11.58.06;  author Jim2;  state Exp;
branches ;
next     40.3;

40.3
date     93.03.04.11.45.40;  author Jim2;  state Exp;
branches ;
next     40.2;

40.2
date     93.03.02.13.25.09;  author Jim2;  state Exp;
branches ;
next     40.1;

40.1
date     93.03.01.16.02.18;  author Jim2;  state Exp;
branches ;
next     40.0;

40.0
date     93.02.19.16.48.18;  author Jim2;  state Exp;
branches ;
next     39.4;

39.4
date     93.01.18.13.24.31;  author Jim2;  state Exp;
branches ;
next     39.3;

39.3
date     93.01.15.13.48.39;  author Jim2;  state Exp;
branches ;
next     39.2;

39.2
date     93.01.13.13.38.23;  author Jim2;  state Exp;
branches ;
next     39.1;

39.1
date     93.01.07.14.20.24;  author Jim2;  state Exp;
branches ;
next     39.0;

39.0
date     93.01.05.11.59.40;  author Jim2;  state Exp;
branches ;
next     ;


desc
@Handles the keyboard.device extention functions.
@


40.11
log
@Autodoc and include cleanup
@
text
@******************************************************************************
*
*       $Id: keyboard.asm,v 40.10 93/05/05 09:54:40 gregm Exp Locker: gregm $
*
******************************************************************************
*
*       $Log:	keyboard.asm,v $
* Revision 40.10  93/05/05  09:54:40  gregm
* autodoc spelling errors fixed.
*
* Revision 40.9  93/04/20  14:16:10  Jim2
* Corrected AddKBInt behaviour when it fails to add the interrupt.
* Polished the comments.
*
* Revision 40.8  93/03/31  18:44:30  Jim2
* I should know better than to check it in before testing.  I coded
* up the port stuff incorrectly.
*
* Revision 40.7  93/03/31  18:14:41  Jim2
* The RKMs documente a6 as being scratch in an interrupt.  This
* is not the case in KeyboardExtender (CI 106).  Also I forgot
* to add the port to this DoIO.
*
* Revision 40.6  93/03/23  14:41:12  Jim2
* Polished autodocs.
*
* Revision 40.5  93/03/10  12:22:18  Jim2
* Cleaned up the results of Vertex code walkthrough.
*
* Revision 40.4  93/03/04  11:58:06  Jim2
* Oops, tst.l cannot be done to an address register unless 020 or better.
*
* Revision 40.3  93/03/04  11:45:40  Jim2
* AddKBInt properly returns a NULL when it does not allocate
* a new interrupt.  RemKBInt checks for a NULL before it does
* it's work.
*
* Revision 40.2  93/03/02  13:25:09  Jim2
* Changed all of the references from game.library to lowlevel.library
*
* Revision 40.1  93/03/01  16:02:18  Jim2
* Added NOTEs to the autodoc to warn people away from these routines.
*
* Revision 40.0  93/02/19  16:48:18  Jim2
* Corrected autodoc format for SEE ALSO.
*
* Revision 39.4  93/01/18  13:24:31  Jim2
* Cleaned up comments.  In QueryKeys require one less register.
*
* Revision 39.3  93/01/15  13:48:39  Jim2
* Removed the keyboard repeat stuff (KeySetThresh and KeySetPeriod)
* this simplified GetKeys.
*
* Revision 39.2  93/01/13  13:38:23  Jim2
* Dropped LastKey and PressedKeys.  Moved the interrupt extender
* from the startup routine.  Added KeySetThresh, KeySetPeriod
* and GetKey.  PressedKeys was superceeded by QueryKeys.  The setting of the
* delays was not tested.
*
* Revision 39.1  93/01/07  14:20:24  Jim2
* Tested and corrected.
*
* Revision 39.0  93/01/05  11:59:40  Jim2
* Initial Release - Untested.
*
*
*       (C) Copyright 1993 Commodore-Amiga, Inc.
*           All Rights Reserved
*
******************************************************************************

        INCLUDE 'exec/macros.i'
        INCLUDE 'exec/nodes.i'
        INCLUDE 'exec/interrupts.i'
        INCLUDE 'exec/memory.i'
        INCLUDE 'exec/io.i'
        INCLUDE 'exec/tasks.i'

        INCLUDE 'devices/keyboard.i'

        INCLUDE '/macros.i'
        INCLUDE '/lowlevelbase.i'


                XREF    _ciaasdr

                XDEF    GetKey
                XDEF    QueryKeys
                XDEF    AddKBInt
                XDEF    RemKBInt
                XDEF    KeyboardInterruptExtender

******* lowlevel.library/QueryKeys *******************************************
*
*   NAME
*	QueryKeys -- return the states for a set of keys. (V40)
*
*   SYNOPSIS
*	QueryKeys(queryArray, arraySize);
*	          A0          D1
*
*	VOID QueryKeys(struct KeyQuery *, UBYTE);
*
*   FUNCTION
*	Scans the keyboard to determine which of the rawkey codes
*	listed in the QueryArray are currently pressed. The state for each
*	key is returned in the array.
*
*	This function may be invoked from within an interrupt, but the size
*	of QueryArray should be kept as small as possible.
*
*	This is a low level function that does not fit the normal Amiga
*	multitasking model. The values returned have no knowledge
*	of which window/screen currently has input focus.
*
*   INPUTS
*	queryArray - an array of KeyQuery structures. The kq_KeyCode fields
*		     of these structures should be filled with the rawkey
*		     codes you wish to query about. Upon return from this
*		     function, the kq_Pressed field of these structures
*		     will be set to TRUE if the associated key is down,
*	             and FALSE if not.
*	arraySize - number of key code entries in queryArray
*
*   SEE ALSO
*	<libraries/lowlevel.h>
*
******************************************************************************
QueryKeys
                movem.l d2/a2/a5/a6,-(sp)
                move.l  a6,a5
                move.b  d1,d2                   ;Store the array size.
                move.l  a0,a2                   ;Store the array pointer.
                                ;Set up a port structure in case the DoIO blocks.
                move.l  ll_ExecBase(a6),a6
                CLEARA  a1
                JSRLIB  FindTask
                move.l  ll_ERSetFunction(a5),a0
                move.l  d0,MP_SIGTASK(a0)       ; SigTask
                move.b  #SIGB_SINGLE,MP_SIGBIT(a0)      ; SigBit
                move.b  #PA_SIGNAL,MP_FLAGS(a0) ; Signal...
TEMPSIZE        set     0
                ARRAYVAR Request,IOSTD_SIZE     ;Need an IO Request.
                ARRAYVAR Matrix,16              ;And room for the keyboard matrix.
                ALLOCLOCALS sp
                move.l  a0,Request+MN_REPLYPORT(sp)
                move.l  sp,a1                   ;Pointer to IO request.
                move.l  ll_KBDevice(a5),IO_DEVICE(a1)
                move.w  #KBD_READMATRIX,IO_COMMAND(a1)
                lea     Matrix(sp),a0           ;Pointer to the keyboard matrix.
                move.l  a0,IO_DATA(a1)
                move.l  #16,IO_LENGTH(a1)       ;Largest possible value.  This could be a problem with kickstart v33/v34.
                JSRLIB  DoIO                    ;Get the keyboard matrix.  This will return immediately.
                tst.b   d0
                bne.s   Exit

Loop:           move.w  (a2)+,d1                ;Get raw keycode to be tested.
                move.w  d1,d0
                and.w   #$0007,d0               ;Which bit within the byte.
                lsr     #3,d1                   ;Which Byte within the matrix
                btst    d0,Matrix(sp,d1.w)

                                ;The following four lines of code can be replaced
                                ;by this line twice.    sne     (a2)+


                beq.s   KeyIsUp
                move.w  #$FFFF,(a2)+            ;Key down
                bra.s   LoopTest
KeyIsUp:        move.w  #$0000,(a2)+            ;Key up
LoopTest:       subq.b  #1,d2                   ;Completed test for one keycode.
                bne.s   Loop
Exit:           move.l  Request+MN_REPLYPORT(sp),a0
                DONELOCALS sp
                move.b  #PA_IGNORE,MP_FLAGS(a0) ;Don't even think about using the port without changing the task.
                movem.l (sp)+,d2/a2/a5/a6
                rts

******* lowlevel.library/AddKBInt ********************************************
*
*   NAME
*	AddKBInt -- adds a routine to the keyboard interrupt. (V40)
*
*   SYNOPSIS
*	intHandle = AddKBInt(intRoutine, intData);
*	D0                   A0          A1
*
*	APTR AddKBInt(APTR, APTR);
*
*   FUNCTION
*	This routine extends the functionality of the keyboard interrupt to
*	include intRoutine. Since this is an extention of the normal
*	keyboard interrupt all of the keyboard handshaking is handled. The
*	keyboard error codes are filtered out and not passed to intRoutine.
*
*	The routine is called whenever the user enters a key on the
*	keyboard.
*
*	The routine is called from within an interrupt, so normal
*	restrictions apply. The routine must preserve the following
*	registers: A2, A3, A4, A7, D2-D7. Other registers are
*	scratch, except for D0, which MUST BE SET TO 0 upon
*	exit. On entry to the routine, A1 holds 'intData' and A5
*	holds 'intRoutine', and D0 contains the rawkey code read
*	from the keyboard.
*
*	The routine is not called when a reset is received from the
*	keyboard.
*
*	This is a low level function that does not fit the normal Amiga
*	multitasking model. The interrupt installed will have no knowledge
*	of which window/screen currently has input focus.
*
*	If your program is to exit without reboot, you MUST call RemKBInt()
*	before exiting.
*
*	Only one interrupt routine may be added to the system.  ALWAYS
*	check the return value in case some other task has previously
*	used this function.
*
*   INPUTS
*	intRoutine - the routine to invoke every vblank. This routine should
*		     be as short as possible to minimize its effect on overall
*		     system performance.
*	intData - data passed to the routine in register A1. If more than one
*		  long word of data is required this should be a pointer to
*		  a structure that contains the required data.
*
*   RESULT
*	intHandle - a handle used to manipulate the interrupt, or NULL
*		    if it was not possible to attach the routine.
*
*   SEE ALSO
*	RemKBInt()
*
******************************************************************************
AddKBInt
                movem.l a0-a1/a5-a6,-(sp)
                move.l  a6,a5
                move.l  ll_ExecBase(a5),a6
                move.l  #IS_SIZE,d0
                move.l  #MEMF_PUBLIC|MEMF_CLEAR,d1
                JSRLIB  AllocMem                ;Get memory for an interrupt structure.
                tst.l   d0
                beq.s   akbi_NoMem

                move.l  d0,a1
                move.b  #NT_INTERRUPT,LN_TYPE(a1)
                move.l  (sp)+,IS_CODE(a1)
                move.l  (sp)+,IS_DATA(a1)       ;Initialize the structure.
                move.l  LN_NAME(a5),LN_NAME(a1)
                lea     ll_KBInterrupts(a5),a0
                JSRLIB  Forbid                  ;Forbid does not change a0,a1
                IFNOTEMPTY a0,akbi_ErrorExit    ;Limit ourselves to one interrupt.
                ADDHEAD                         ;Add it to the list of interrupts.
                JSRLIB  Permit                  ;Permit does not change a1
                move.l  a1,d0                   ;The pointer to the interrupt structure is returned.
                movem.l (sp)+,a5-a6
                rts

akbi_ErrorExit: JSRLIB  Permit                  ;Permit does not change a1
                move.l  #IS_SIZE,d0
                JSRLIB  FreeMem                 ;Didn't add it so return the memory.
                CLEAR   d0
                subq.l  #8,sp
akbi_NoMem      movem.l (sp)+,a0-a1/a5-a6
                rts

******* lowlevel.library/RemKBInt ********************************************
*
*  NAME
*	RemKBInt -- remove a previously installed keyboard interrupt. (V40)
*
*  SYNOPSIS
*	RemKBInt(intHandle);
*	         A1
*
*	VOID RemKBInt(APTR);
*
*  FUNCTION
*	Remove a keyboard interrupt routine previously added with AddKBInt().
*
*  INPUTS
*	intHandle - handle obtained from AddKBInt(). This may be NULL,
*		    in which case this function does nothing.
*
*  SEE ALSO
*	AddKBInt()
*
******************************************************************************
RemKBInt
                cmp.l   #0,a0
                beq.s   rki_Exit                ;Check for NULL.
                                ;Non-Null handle.
                move.l  a6,-(sp)
                move.l  ll_ExecBase(a6),a6
                move.l  a1,-(sp)                ;Although Forbid() and Permit()...
                JSRLIB  Forbid                  ;... don't change a1 REMOVE does.
                REMOVE
                JSRLIB  Permit
                move.l  (sp)+,a1
                move.l  #IS_SIZE,d0
                JSRLIB  FreeMem                 ;Free the memory.
                move.l  (sp)+,a6
rki_Exit:       rts

*****i* lowlevel.library/KeyboardInterruptExtender ***************************
*
*   NAME
*	KeyboardInterruptExtender - Extends the functionality of the keyboard
*	                            interrupt.
*
*   SYNOPSIS
*	KeyBoardInterrupt(LowLevelBase)
*	                  a1
*
*   FUNCTION
*	This is a kind of SetFunction for the keyboard interrupt.  During the
*	development of the lowlevel library it was decided to add functionality
*	the the existing keyboard.device.  In particular it was desireable to
*	get the last key hit and piggyback on top the the keyboard interrupt.
*
*	These two functions were best handled by replacing the keyboard
*	interrupt.  However, this is not practical for a library that is
*	intended to work on many platforms.  So this routine was developed to
*	place a wrapper around the existing keyboard interrupt.
*
*	When invoked this routine grabs the current keyboard key.  Then the
*	orginal keyboard interrupt is invoked to handle all of the hand
*	shaking.  Once this is done the key is checked.  If it is a modifier
*	its bit within last KeyPressed is toggled.  If it is a non-modifier
*	keypress, it is stored as the last key press.  If the code is a key
*	release it is checked against the last key pressed.  If they match
*	the last key pressed is changed to none.  As long as the key code is
*	not a keyboard error the list of user keyboard interrupts is called.
*
*	This is a low level function that does not fit the normal Amiga
*	multitasking model. The values returned by this function are
*	not modified by which window/screen currently has input focus.
*
*   INPUTS
*	LowLevelBase - Pointer to lowlevel.library.  This is not in a6 since this
*	           function is an interrupt.
*
*   RESULT
*	NONE
******************************************************************************
KeyboardInterruptExtender
                movem.l d2/a4-a6,-(sp)
                move.l  a1,a4                   ;Get LowLevel base into a4.
                moveq   #0,d2                   ;clear upper byte
                move.b  _ciaasdr,d2             ;get the key.
                not.b   d2                      ;signal is active low
                ror.b   #1,d2                   ;move up/down to sign bit
                move.l  ll_KBOrig(a4),a0
                move.l  IS_DATA(a0),a1
                move.l  IS_CODE(a0),a5
                JSR     (A5)                    ;Execute the original keyboard interrupt.
                cmp.w   #$78,d2                 ;$78 is reset don't give it to the user.
                beq.b   NoChange
                                ;Not reset.
                move.w  d2,d1                   ;Checking to see if it is modifier key trashes the keycode.
                and.w   #$78,d1                 ;Modifier keys are in the range 60-67 inclusive.
                cmp.w   #$60,d1
                bne.s   PassKey
                                ;Modifier key code.
                move.w  ll_LastKey(a4),d0       ;Get the modifier word
                move.w  d2,d1
                and.w   #$07,d1                 ;Which modifer is to be changed?
                bchg    d1,d0                   ;Change it.
                move.w  d0,ll_LastKey(a4)       ;Save the new modifier.
                bra.s   DoneNewKey

PassKey:        btst    #7,d2                   ;If the most significant bit is set it is a key release.
                bne.s   KeyUp
                                ;Non modifier key press.
                move.w  d2,ll_LastKey+2(a4)     ;Ok, remember the key.
                bra.s   DoneNewKey

KeyUp:                          ;Non modifier key release.
                move.w  d2,d1
                bclr    #7,d1
                cmp.w   ll_LastKey+2(a4),d1     ;Was it the last key pressed?
                bne.s   DoneNewKey
                                ;LastKey has been released.
                or.w    #$FF,ll_LastKey+2(a4)
DoneNewKey:     move.w  d2,d0                   ;Codes above $F8 are special...
                subi.w  #$F9,d2                 ;...control codes, the user...
                bpl.s   NoChange                ;...doesn't want them.

                move.l  ll_KBInterrupts+MLH_HEAD(a4),a1
                bra.s   Test                    ;Get ready to scan the list, do it with a bottom testing loop.
ProcessList:    move.l  IS_CODE(a1),a5
                move.l  IS_DATA(a1),a1
                JSR     (a5)                    ;Execute the users interrupt.
                move.l  (sp)+,a1                ;Restore the list pointer.
                move.w  (sp)+,d0                ;Restore the key.
Test:           move.w  d0,-(sp)                ;Remember the key.
                move.l  MLN_SUCC(a1),-(sp)      ;Remember the list pointer.
                bne.s   ProcessList

                addq    #6,sp                   ;Remove the pointer from the stack.
NoChange:       movem.l (sp)+,d2/a4-a6
                rts

******* lowlevel.library/GetKey **********************************************
*
*   NAME
*	GetKey -- returns the currently pressed rawkey code and qualifiers.
*		  (V40)
*
*   SYNOPSIS
*	key = GetKey();
*	D0
*
*	ULONG GetKey(VOID);
*
*   FUNCTION
*	This function returns the currently pressed non-qualifier key and
*	all pressed qualifiers.
*
*	This function is safe within an interrupt.
*
*	This is a low level function that does not fit the normal Amiga
*	multitasking model. The values returned by this function are
*	not modified by which window/screen currently has input focus.
*
*   RESULT
*	key - key code for the last non-qualifier key pressed in the low
*	      order word. If no key is pressed this word will be FF. The
*	      upper order word contains the qualifiers which can be found
*	      within the long word as follows:
*	                Qualifier               Key
*	                LLKB_LSHIFT             Left Shift
*	                LLKB_RSHIFT             Rigt Shift
*	                LLKB_CAPSLOCK           Caps Lock
*	                LLKB_CONTROL            Control
*	                LLKB_LALT               Left Alt
*	                LLKB_RALT               Right Alt
*	                LLKB_LAMIGA             Left Amiga
*	                LLKB_RAMIGA             Right Amiga
*
*   SEE ALSO
*	<libraries/lowlevel.h>
*
******************************************************************************
GetKey
                move.l  ll_LastKey(a6),d0
                rts

                end
@


40.10
log
@autodoc spelling errors fixed.
@
text
@d3 1
a3 1
*       $Id: Keyboard.asm,v 40.9 93/04/20 14:16:10 Jim2 Exp $
d7 4
a10 1
*       $Log:   Keyboard.asm,v $
d96 1
a96 1
*       QueryKeys - Returns the states for a set of keys.
d99 2
a100 2
*       QueryKeys (QueryArray, ArraySize)
*                  a0          d1
d102 1
a102 1
*       VOID QueryKeys(struct KeyQuery *, UBYTE)
d105 6
a110 3
*       Scans the keyboard to determines which, if any, of the raw key codes
*       listed in the QueryArray are currently pressed.  The state for each
*       code is returned in the array.
d112 3
a114 7
*       This function may be invoked from within an interrupt, but the size
*       of QueryArray should be kept as small as possible.
*
*   NOTE
*       This is a low level function that does not fit the normal Amgia
*       multitasking model.  The values returned have no knowledge
*       of which window/screen currently has input focus.
d117 10
a126 4
*       QueryArray - Pointer to a block of memory that consists of raw key
*                    codes alternated with the state, filled in by this
*                    function, of that key.
*       ArraySize - Number of keycode entries in QueryArray.
a127 2
*   RESULT
*       NONE
d182 1
a182 1
*       AddKBInt - Adds routine to the keyboard interrupt.
d185 2
a186 2
*       Handle = AddKBInt(IntRoutine, IntData)
*       d0                a0          a1
d188 1
a188 1
*       APTR AddKBInt(APTR, APTR)
d191 25
a215 4
*       This routine extends the functionality of the keyboard interrupt to
*       include IntRoutine.  Since this is an extention of the normal
*       keyboard interrupt all of the keyboard handshaking is handled.  The
*       keyboard error codes are filtered out and not passed to IntRoutine.
d217 3
a219 31
*       When a keyboard interrupt occurs the routine pointed to by
*       InitRoutine is called.  As with any other assembly routines d0, d1,
*       a0 and a1 can be considered scratch, all other registers must have
*       their values preserved.  However, upon exit d0 MUST be cleared.
*       When the IntRoutine is invoked a1 will contain IntData; also d0 will
*       contain the raw key code read from the keyboard.
*
*       IntRoutine will not be called when a reset is received from the
*       keyboard.
*
*   NOTE
*       The routine added should be as short as possible since it will
*       be run for every keypress and release.
*
*       This is a low level function that does not fit the normal Amgia
*       multitasking model.  The interrupt installed will have no knowledge
*       of which window/screen currently has input focus.
*
*       If your program is to exit without reboot, you MUST call RemKBInt()
*       before exiting.
*
*       Only one interrupt routine may be added to the system.  ALWAYS
*       check the return value in case some other task has previously
*       used this function.
*
*       The Exec Interrupt structure is used for controlling the invocation
*       of IntRoutine.  All of the register conventions of interrupt server
*       are observed.  This means two additional scratch registers are
*       available; a5 (which will contain the address of IntRoutine) and a6.
*       The priority used (not that it matters since only one routine is
*       possible) is zero.
d222 6
a227 6
*       IntRoutine - Pointer to the interrupt routine invoked every
*                    keyboard interrupt.
*       IntData - Data passed to the interrupt routine in register a1.
*                 If more than one long word of data is required this
*                 should be a pointer to structure that contains the
*                 required data.
d230 5
a234 2
*       Handle - Pointer to the handle used in manipulating the interrupt.
*                NULL if it was not possible create the interrupt.
a235 2
*   SEE ALSO:
*       RemKBInt ()
d270 1
d272 1
a272 1
*       RemKBInt - Remove a previously installed keyboard interrupt.
d275 2
a276 2
*       RemKBInt(Handle)
*                a1
d278 1
a278 1
*       VOID RemKBInt(APTR)
d281 1
a281 2
*       Remove a keyboard interrupt routine previously added with AddKBInt.
*       Additionally, any resources involved in the interrupt will be freed.
d284 2
a285 2
*       Handle - Pointer to the handle returned from AddKBInt.  This can
*                be NULL.
d287 2
a288 2
*  RESULT
*       NONE
a289 2
*  SEE ALSO:
*       AddKBInt ()
d310 2
a311 2
*       KeyboardInterruptExtender - Extends the functionality of the keyboard
*                                   interrupt.
d314 2
a315 2
*       KeyBoardInterrupt(LowLevelBase)
*                         a1
d318 18
a335 4
*       This is a kind of SetFunction for the keyboard interrupt.  During the
*       development of the lowlevel library it was decided to add functionality
*       the the existing keyboard.device.  In particular it was desireable to
*       get the last key hit and piggyback on top the the keyboard interrupt.
d337 3
a339 18
*       These two functions were best handled by replacing the keyboard
*       interrupt.  However, this is not practical for a library that is
*       intended to work on many platforms.  So this routine was developed to
*       place a wrapper around the existing keyboard interrupt.
*
*       When invoked this routine grabs the current keyboard key.  Then the
*       orginal keyboard interrupt is invoked to handle all of the hand
*       shaking.  Once this is done the key is checked.  If it is a modifier
*       its bit within last KeyPressed is toggled.  If it is a non-modifier
*       keypress, it is stored as the last key press.  If the code is a key
*       release it is checked against the last key pressed.  If they match
*       the last key pressed is changed to none.  As long as the key code is
*       not a keyboard error the list of user keyboard interrupts is called.
*
*   NOTE
*       This is a low level function that does not fit the normal Amgia
*       multitasking model.  The values returned by this function are
*       not modified by which window/screen currently has input focus.
d342 2
a343 2
*       LowLevelBase - Pointer to lowlevel.library.  This is not in a6 since this
*                  function is an interrupt.
d346 1
a346 1
*       NONE
d409 2
a410 1
*       GetKey - Returns the currently pressed raw key code and qualifiers.
d413 2
a414 2
*       Key = GetKey ()
*       d0
d416 1
a416 1
*       ULONG GetKey (VOID)
d419 4
a422 2
*       This function returns the currently pressed non-qualifier key and
*       all pressed qualifiers.
d424 3
a426 1
*       This function is safe within an interrupt.
d428 14
a441 4
*   NOTE
*       This is a low level function that does not fit the normal Amgia
*       multitasking model.  The values returned by this function are
*       not modified by which window/screen currently has input focus.
d443 2
a444 2
*   INPUTS
*       NONE
a445 14
*   RESULT
*       Key - key code for the last non-qualifier key pressed is in the low
*             order word.  If no key is pressed this word will be FF.  The
*             upper order word contains the qualifiers which can be found
*             within the long word as follows:
*                       Qualifier               Key
*                       LLKB_LSHIFT             Left Shift
*                       LLKB_RSHIFT             Rigt Shift
*                       LLKB_CAPSLOCK           Caps Lock
*                       LLKB_CONTROL            Control
*                       LLKB_LALT               Left Alt
*                       LLKB_RALT               Right Alt
*                       LLKB_LAMIGA             Left Amiga
*                       LLKB_RAMIGA             Right Amiga
@


40.9
log
@Corrected AddKBInt behaviour when it fails to add the interrupt.
Polished the comments.
@
text
@d3 1
a3 1
*	$Id: Keyboard.asm,v 40.8 93/03/31 18:44:30 Jim2 Exp Locker: Jim2 $
d7 5
a11 1
*	$Log:	Keyboard.asm,v $
d64 2
a65 2
*	(C) Copyright 1993 Commodore-Amiga, Inc.
*	    All Rights Reserved
d69 20
a88 20
	INCLUDE	'exec/macros.i'
	INCLUDE 'exec/nodes.i'
	INCLUDE	'exec/interrupts.i'
	INCLUDE	'exec/memory.i'
	INCLUDE	'exec/io.i'
	INCLUDE 'exec/tasks.i'

	INCLUDE 'devices/keyboard.i'

	INCLUDE	'/macros.i'
	INCLUDE	'/lowlevelbase.i'


		XREF	_ciaasdr

		XDEF	GetKey
		XDEF	QueryKeys
		XDEF	AddKBInt
		XDEF	RemKBInt
		XDEF	KeyboardInterruptExtender
d93 1
a93 1
*	QueryKeys - Returns the states for a set of keys.
d96 2
a97 2
*	QueryKeys (QueryArray, ArraySize)
*		   a0	       d1
d99 1
a99 1
*	VOID QueryKeys(struct KeyQuery *, UBYTE)
d102 3
a104 3
*	Scans the keyboard to determines which, if any, of the raw key codes
*	listed in the QueryArray are currently pressed.  The state for each
*	code is returned in the array.
d106 2
a107 2
*	This function may be invoked from within an interrupt, but the size
*	of QueryArray should be kept as small as possible.
d110 3
a112 3
*	This is a low level function that does not fit the normal Amgia
*	multitasking model.  The values returned have no knowledge
*	of which window/screen currently has input focus.
d115 4
a118 4
*	QueryArray - Pointer to a block of memory that consists of raw key
*		     codes alternated with the state, filled in by this
*		     function, of that key.
*	ArraySize - Number of keycode entries in QueryArray.
d121 1
a121 1
*	NONE
d124 48
a171 48
		movem.l	d2/a2/a5/a6,-(sp)
		move.l	a6,a5
		move.b	d1,d2			;Store the array size.
		move.l	a0,a2			;Store the array pointer.
				;Set up a port structure in case the DoIO blocks.
		move.l	ll_ExecBase(a6),a6
		CLEARA	a1
		JSRLIB	FindTask
		move.l	ll_ERSetFunction(a5),a0
		move.l	d0,MP_SIGTASK(a0)	; SigTask
		move.b	#SIGB_SINGLE,MP_SIGBIT(a0)	; SigBit
		move.b	#PA_SIGNAL,MP_FLAGS(a0)	; Signal...
TEMPSIZE	set	0
		ARRAYVAR Request,IOSTD_SIZE	;Need an IO Request.
		ARRAYVAR Matrix,16		;And room for the keyboard matrix.
		ALLOCLOCALS sp
		move.l	a0,Request+MN_REPLYPORT(sp)
		move.l	sp,a1			;Pointer to IO request.
		move.l	ll_KBDevice(a5),IO_DEVICE(a1)
		move.w	#KBD_READMATRIX,IO_COMMAND(a1)
		lea	Matrix(sp),a0		;Pointer to the keyboard matrix.
		move.l	a0,IO_DATA(a1)
		move.l	#16,IO_LENGTH(a1)	;Largest possible value.  This could be a problem with kickstart v33/v34.
		JSRLIB	DoIO			;Get the keyboard matrix.  This will return immediately.
		tst.b	d0
		bne.s	Exit

Loop:		move.w	(a2)+,d1		;Get raw keycode to be tested.
		move.w	d1,d0
		and.w	#$0007,d0		;Which bit within the byte.
		lsr	#3,d1			;Which Byte within the matrix
		btst	d0,Matrix(sp,d1.w)

				;The following four lines of code can be replaced
				;by this line twice.	sne	(a2)+


		beq.s	KeyIsUp
		move.w	#$FFFF,(a2)+		;Key down
		bra.s	LoopTest
KeyIsUp:	move.w	#$0000,(a2)+		;Key up
LoopTest:	subq.b	#1,d2			;Completed test for one keycode.
		bne.s	Loop
Exit:		move.l	Request+MN_REPLYPORT(sp),a0
		DONELOCALS sp
		move.b	#PA_IGNORE,MP_FLAGS(a0)	;Don't even think about using the port without changing the task.
		movem.l	(sp)+,d2/a2/a5/a6
		rts
d176 1
a176 1
*	AddKBInt - Adds routine to the keyboard interrupt.
d179 2
a180 2
*	Handle = AddKBInt(IntRoutine, IntData)
*	d0		  a0	      a1
d182 1
a182 1
*	APTR AddKBInt(APTR, APTR)
d185 4
a188 4
*	This routine extends the functionality of the keyboard interrupt to
*	include IntRoutine.  Since this is an extention of the normal
*	keyboard interrupt all of the keyboard handshaking is handled.  The
*	keyboard error codes are filtered out and not passed to IntRoutine.
d190 6
a195 6
*	When a keyboard interrupt occurs the routine pointed to by
*	InitRoutine is called.  As with any other assembly routines d0, d1,
*	a0 and a1 can be considered scratch, all other registers must have
*	their values preserved.  However, upon exit d0 MUST be cleared.
*	When the IntRoutine is invoked a1 will contain IntData; also d0 will
*	contain the raw key code read from the keyboard.
d197 2
a198 2
*	IntRoutine will not be called when a reset is recieved from the
*	keyboard.
d201 2
a202 2
*	The routine added should be as short as possible since it will
*	be run for every keypress and release.
d204 17
a220 17
*	This is a low level function that does not fit the normal Amgia
*	multitasking model.  The interrupt installed will have no knowledge
*	of which window/screen currently has input focus.
*
*	If your program is to exit without reboot, you MUST call RemKBInt()
*	before exiting.
*
*	Only one interrupt routine may be added to the system.  ALWAYS
*	check the return value in case some other task has previously
*	used this function.
*
*	The Exec Interrupt structure is used for controlling the invokation
*	of IntRoutine.  All of the register conventions of interrupt server
*	are observed.  This means two additional scratch registers are
*	available; a5 (which will contain the address of IntRoutine) and a6.
*	The priority used (not that it matters since only one routine is
*	possible) is zero.
d223 6
a228 6
*	IntRoutine - Pointer to the interrupt routine invoked every
*		     keyboard interrupt.
*	IntData - Data passed to the interrupt routine in register a1.
*		  If more than one long word of data is required this
*		  should be a pointer to structure that contains the
*		  required data.
d231 2
a232 2
*	Handle - Pointer to the handle used in manipulating the interrupt.
*		 NULL if it was not possible create the interrupt.
d235 1
a235 1
*	RemKBInt ()
d238 30
a267 30
		movem.l	a0-a1/a5-a6,-(sp)
		move.l	a6,a5
		move.l	ll_ExecBase(a5),a6
		move.l	#IS_SIZE,d0
		move.l	#MEMF_PUBLIC|MEMF_CLEAR,d1
		JSRLIB	AllocMem		;Get memory for an interrupt structure.
		tst.l	d0
		beq.s	akbi_NoMem

		move.l	d0,a1
		move.b	#NT_INTERRUPT,LN_TYPE(a1)
		move.l	(sp)+,IS_CODE(a1)
		move.l	(sp)+,IS_DATA(a1)	;Initialize the structure.
		move.l	LN_NAME(a5),LN_NAME(a1)
		lea	ll_KBInterrupts(a5),a0
		JSRLIB	Forbid			;Forbid does not change a0,a1
		IFNOTEMPTY a0,akbi_ErrorExit	;Limit ourselves to one interrupt.
		ADDHEAD				;Add it to the list of interrupts.
		JSRLIB	Permit			;Permit does not change a1
		move.l	a1,d0			;The pointer to the interrupt structure is returned.
		movem.l	(sp)+,a5-a6
		rts

akbi_ErrorExit:	JSRLIB	Permit			;Permit does not change a1
		move.l	#IS_SIZE,d0
		JSRLIB	FreeMem			;Didn't add it so return the memory.
		CLEAR	d0
		subq.l	#8,sp
akbi_NoMem	movem.l	(sp)+,a0-a1/a5-a6
		rts
d271 1
a271 1
*	RemKBInt - Remove a previously installed keyboard interrupt.
d274 2
a275 2
*	RemKBInt(Handle)
*		 a1
d277 1
a277 1
*	VOID RemKBInt(APTR)
d280 2
a281 2
*	Remove a keyboard interrupt routine previously added with AddKBInt.
*	Additionally, any resources involved in the interrupt will be freed.
d284 2
a285 2
*	Handle - Pointer to the handle returned from AddKBInt.  This can
*		 be NULL.
d288 1
a288 1
*	NONE
d291 1
a291 1
*	AddKBInt ()
d294 14
a307 14
		cmp.l	#0,a0
		beq.s	rki_Exit		;Check for NULL.
				;Non-Null handle.
		move.l	a6,-(sp)
		move.l	ll_ExecBase(a6),a6
		move.l	a1,-(sp)		;Although Forbid() and Permit()...
		JSRLIB	Forbid			;... don't change a1 REMOVE does.
		REMOVE
		JSRLIB	Permit
		move.l	(sp)+,a1
		move.l	#IS_SIZE,d0
		JSRLIB	FreeMem			;Free the memory.
		move.l	(sp)+,a6
rki_Exit:	rts
d312 2
a313 2
*	KeyboardInterruptExtender - Extends the functionality of the keyboard
*				    interrupt.
d316 2
a317 2
*	KeyBoardInterrupt(LowLevelBase)
*			  a1
d320 4
a323 4
*	This is a kind of SetFunction for the keyboard interrupt.  During the
*	development of the lowlevel library it was decided to add functionality
*	the the existing keyboard.device.  In particular it was desireable to
*	get the last key hit and piggyback on top the the keyboard interrupt.
d325 13
a337 13
*	These two functions were best handled by replacing the keyboard
*	interrupt.  However, this is not practical for a library that is
*	intended to work on many platforms.  So this routine was developed to
*	place a wrapper around the existing keyboard interrupt.
*
*	When invoked this routine grabs the current keyboard key.  Then the
*	orginal keyboard interrupt is invoked to handle all of the hand
*	shaking.  Once this is done the key is checked.  If it is a modifier
*	its bit within last KeyPressed is toggled.  If it is a non-modifier
*	keypress, it is stored as the last key press.  If the code is a key
*	release it is checked against the last key pressed.  If they match
*	the last key pressed is changed to none.  As long as the key code is
*	not a keyboard error the list of user keyboard interrupts is called.
d340 3
a342 3
*	This is a low level function that does not fit the normal Amgia
*	multitasking model.  The values returned by this function are
*	not modified by which window/screen currently has input focus.
d345 2
a346 2
*	LowLevelBase - Pointer to lowlevel.library.  This is not in a6 since this
*		   function is an interrupt.
d349 1
a349 1
*	NONE
d352 52
a403 52
		movem.l	d2/a4-a6,-(sp)
		move.l	a1,a4			;Get LowLevel base into a4.
		moveq	#0,d2			;clear upper byte
		move.b	_ciaasdr,d2		;get the key.
		not.b	d2			;signal is active low
		ror.b	#1,d2			;move up/down to sign bit
		move.l	ll_KBOrig(a4),a0
		move.l	IS_DATA(a0),a1
		move.l	IS_CODE(a0),a5
		JSR     (A5)			;Execute the original keyboard interrupt.
		cmp.w	#$78,d2			;$78 is reset don't give it to the user.
		beq.b	NoChange
				;Not reset.
		move.w	d2,d1			;Checking to see if it is modifier key trashes the keycode.
		and.w	#$78,d1			;Modifier keys are in the range 60-67 inclusive.
		cmp.w	#$60,d1
		bne.s	PassKey
				;Modifier key code.
		move.w	ll_LastKey(a4),d0	;Get the modifier word
		move.w	d2,d1
		and.w	#$07,d1			;Which modifer is to be changed?
		bchg	d1,d0			;Change it.
		move.w	d0,ll_LastKey(a4)	;Save the new modifier.
		bra.s	DoneNewKey

PassKey:	btst	#7,d2			;If the most significant bit is set it is a key release.
 		bne.s	KeyUp
				;Non modifier key press.
		move.w	d2,ll_LastKey+2(a4)	;Ok, remember the key.
		bra.s	DoneNewKey

KeyUp:				;Non modifier key release.
		move.w	d2,d1
		bclr	#7,d1
		cmp.w	ll_LastKey+2(a4),d1	;Was it the last key pressed?
		bne.s	DoneNewKey
				;LastKey has been released.
		or.w	#$FF,ll_LastKey+2(a4)
DoneNewKey:	move.w	d2,d0			;Codes above $F8 are special...
		subi.w	#$F9,d2			;...control codes, the user...
		bpl.s	NoChange		;...doesn't want them.

		move.l	ll_KBInterrupts+MLH_HEAD(a4),a1
		bra.s	Test			;Get ready to scan the list, do it with a bottom testing loop.
ProcessList:	move.l	IS_CODE(a1),a5
		move.l	IS_DATA(a1),a1
		JSR     (a5)			;Execute the users interrupt.
		move.l	(sp)+,a1		;Restore the list pointer.
		move.w	(sp)+,d0		;Restore the key.
Test:		move.w	d0,-(sp)		;Remember the key.
		move.l	MLN_SUCC(a1),-(sp)	;Remember the list pointer.
		bne.s	ProcessList
d405 3
a407 3
		addq	#6,sp			;Remove the pointer from the stack.
NoChange:	movem.l	(sp)+,d2/a4-a6
		rts
d412 1
a412 1
*	GetKey - Returns the currently pressed raw key code and qualifiers.
d415 2
a416 2
*	Key = GetKey ()
*	d0
d418 1
a418 1
*	ULONG GetKey (VOID)
d421 2
a422 2
*	This function returns the currently pressed non-qualifier key and
*	all pressed qualifiers.
d424 1
a424 1
*	This function is safe within an interrupt.
d427 3
a429 3
*	This is a low level function that does not fit the normal Amgia
*	multitasking model.  The values returned by this function are
*	not modified by which window/screen currently has input focus.
d432 1
a432 1
*	NONE
d435 13
a447 13
*	Key - key code for the last non-qualifier key pressed is in the low
*	      order word.  If no key is pressed this word will be FF.  The
*	      upper order word contains the qualifiers which can be found
*	      within the long word as follows:
*			Qualifier		Key
*			LLKB_LSHIFT		Left Shift
*			LLKB_RSHIFT		Rigt Shift
*			LLKB_CAPSLOCK		Caps Lock
*			LLKB_CONTROL		Control
*			LLKB_LALT		Left Alt
*			LLKB_RALT		Right Alt
*			LLKB_LAMIGA		Left Amiga
*			LLKB_RAMIGA		Right Amiga
d450 2
a451 2
		move.l	ll_LastKey(a6),d0
		rts
d453 1
a453 1
		end
@


40.8
log
@I should know better than to check it in before testing.  I coded
up the port stuff incorrectly.
@
text
@d3 1
a3 1
*	$Id: Keyboard.asm,v 40.7 93/03/31 18:14:41 Jim2 Exp Locker: Jim2 $
d8 4
a77 1

a79 1

a85 1

d98 1
a98 1
*	Scans the keyboard t0 determines which, if any, of the raw key codes
d124 1
d142 1
a142 1
		move.l	#16,IO_LENGTH(a1)
d152 5
d165 1
a165 1
		move.b	#PA_IGNORE,MP_FLAGS(a0)
a192 1
*
d211 7
d250 1
a250 1
		IFNOTEMPTY	a0,akbi_ErrorExit	;Limit ourselves to one interrupt.
d259 1
a259 1
		JSRLIB	FreeMem
d261 1
d291 2
a292 1
		beq.s	rki_Exit
d295 2
a296 2
		move.l	a1,-(sp)
		JSRLIB	Forbid
d301 1
a301 1
		JSRLIB	FreeMem
d349 1
a349 1
		move.l	a1,a4			;Get LowLevel base into a6.
d357 1
a357 1
		JSR     (A5)			;Execute the keyboard interrupt.
d379 2
a380 1
KeyUp:		move.w	d2,d1
d382 1
a382 1
		cmp.w	ll_LastKey+2(a4),d1
d386 3
a388 3
DoneNewKey:	move.w	d2,d0
		subi.w	#$F9,d2
		bpl.s	NoChange		;Codes above $F8 are special control codes, the user doesn't want them.
@


40.7
log
@The RKMs documente a6 as being scratch in an interrupt.  This
is not the case in KeyboardExtender (CI 106).  Also I forgot
to add the port to this DoIO.
@
text
@d3 1
a3 1
*	$Id: Keyboard.asm,v 40.6 93/03/23 14:41:12 Jim2 Exp Locker: Jim2 $
d8 5
d123 7
d134 1
d136 1
a136 1
		move.l	ll_KBDevice(a6),IO_DEVICE(a1)
a140 8
		move.l	ll_ExecBase(a6),a6
		CLEARA	a1
		JSRLIB	FindTask
		move.l	ll_ERSetFunction(a5),a0
		move.l	d0,MP_SIGTASK(a0)	; SigTask
		move.b	#SIGB_SINGLE,MP_SIGBIT(a0)	; SigBit
		move.b	#PA_SIGNAL,MP_FLAGS(a0)	; Signal...
		move.l	a0,Request+MN_REPLYPORT(sp)
@


40.6
log
@Polished autodocs.
@
text
@d3 1
a3 1
*	$Id: Keyboard.asm,v 40.5 93/03/10 12:22:18 Jim2 Exp Locker: Jim2 $
d8 3
d61 1
d114 2
a115 1
		movem.l	d2/a2/a6,-(sp)
d129 7
d139 1
d151 4
a154 2
Exit:		DONELOCALS sp
		movem.l	(sp)+,d2/a2/a6
d328 2
a329 2
		movem.l	d2/a5-a6,-(sp)
		move.l	a1,a6			;Get LowLevel base into a6.
d334 1
a334 1
		move.l	ll_KBOrig(a6),a0
d346 1
a346 1
		move.w	ll_LastKey(a6),d0	;Get the modifier word
d350 1
a350 1
		move.w	d0,ll_LastKey(a6)	;Save the new modifier.
d356 1
a356 1
		move.w	d2,ll_LastKey+2(a6)	;Ok, remember the key.
d361 1
a361 1
		cmp.w	ll_LastKey+2(a6),d1
d364 1
a364 1
		or.w	#$FF,ll_LastKey+2(a6)
d369 1
a369 1
		move.l	ll_KBInterrupts+MLH_HEAD(a6),a1
d373 1
a373 1
		JSR     (A5)			;Execute the users interrupt.
d381 1
a381 1
NoChange:	movem.l	(sp)+,d2/a5-a6
@


40.5
log
@Cleaned up the results of Vertex code walkthrough.
@
text
@d3 1
a3 1
*	$Id: Keyboard.asm,v 40.4 93/03/04 11:58:06 Jim2 Exp Locker: Jim2 $
d8 3
d149 1
a149 1
*	d0		     a0		 a1
d151 1
a151 1
*	APTR = AddKBInt(APTR, APTR)
d162 4
a165 3
*	their values preserved.  When the IntRoutine is invoked a1 will
*	contain IntData; also d0 will contain the raw key code read from the
*	keyboard.
d171 3
a187 3
*		     NOTE:  This routine should be as short as possible
*		     since this routine is run within the keyboard
*		     interrupt.
d239 1
a239 1
*	RemKBInt(APTR)
@


40.4
log
@Oops, tst.l cannot be done to an address register unless 020 or better.
@
text
@d3 1
a3 1
*	$Id: Keyboard.asm,v 40.3 93/03/04 11:45:40 Jim2 Exp Locker: Jim2 $
d8 3
a197 2
		lea	ll_KBInterrupts(a6),a0
		IFNOTEMPTY	a0,akbi_ErrorExit	;Limit ourselves to one interrupt.
d204 1
a204 1
		beq.s	akbi_ErrorExit
d210 1
d212 2
d215 1
d220 3
a222 1
akbi_ErrorExit	movem.l	(sp)+,a0-a1/a5-a6
d224 1
@


40.3
log
@AddKBInt properly returns a NULL when it does not allocate
a new interrupt.  RemKBInt checks for a NULL before it does
it's work.
@
text
@d3 1
a3 1
*	$Id: Keyboard.asm,v 40.2 93/03/02 13:25:09 Jim2 Exp Locker: Jim2 $
d8 5
d244 1
a244 1
		tst.l	a0
@


40.2
log
@Changed all of the references from game.library to lowlevel.library
@
text
@d3 1
a3 1
*	$Id: Keyboard.asm,v 40.1 93/03/01 16:02:18 Jim2 Exp Locker: Jim2 $
d8 3
d211 1
d229 2
a230 2
*	Handle - Pointer to the handle returned from AddKBInt.  This must
*		 not be NULL or serious problems will occur.
d239 2
d251 1
a251 1
		rts
@


40.1
log
@Added NOTEs to the autodoc to warn people away from these routines.
@
text
@d3 1
a3 1
*	$Id: Keyboard.asm,v 40.0 93/02/19 16:48:18 Jim2 Exp Locker: Jim2 $
d8 3
d48 1
a48 1
	INCLUDE	'/gamebase.i'
d62 1
a62 1
******* game.library/QueryKeys ***********************************************
d104 1
a104 1
		move.l	gm_KBDevice(a6),IO_DEVICE(a1)
d109 1
a109 1
		move.l	gm_ExecBase(a6),a6
d128 1
a128 1
******* game.library/AddKBInt ************************************************
d187 1
a187 1
		lea	gm_KBInterrupts(a6),a0
d190 1
a190 1
		move.l	gm_ExecBase(a5),a6
d201 1
a201 1
		lea	gm_KBInterrupts(a5),a0
d210 1
a210 1
******* game.library/RemKBInt ************************************************
d236 1
a236 1
		move.l	gm_ExecBase(a6),a6
d247 1
a247 1
*****i* game.library/KeyboardInterruptExtender *******************************
d254 1
a254 1
*	KeyBoardInterrupt(GameBase)
d259 1
a259 1
*	development of the game library it was decided to add functionality
d283 1
a283 1
*	GameBase - Pointer to game.library.  This is not in a6 since this
d291 1
a291 1
		move.l	a1,a6			;Get game base into a6.
d296 1
a296 1
		move.l	gm_KBOrig(a6),a0
d308 1
a308 1
		move.w	gm_LastKey(a6),d0	;Get the modifier word
d312 1
a312 1
		move.w	d0,gm_LastKey(a6)	;Save the new modifier.
d318 1
a318 1
		move.w	d2,gm_LastKey+2(a6)	;Ok, remember the key.
d323 1
a323 1
		cmp.w	gm_LastKey+2(a6),d1
d326 1
a326 1
		or.w	#$FF,gm_LastKey+2(a6)
d331 1
a331 1
		move.l	gm_KBInterrupts+MLH_HEAD(a6),a1
d346 1
a346 1
******* game.library/GetKey **************************************************
d377 8
a384 8
*			GKB_LSHIFT		Left Shift
*			GKB_RSHIFT		Rigt Shift
*			GKB_CAPSLOCK		Caps Lock
*			GKB_CONTROL		Control
*			GKB_LALT		Left Alt
*			GKB_RALT		Right Alt
*			GKB_LAMIGA		Left Amiga
*			GKB_RAMIGA		Right Amiga
d387 1
a387 1
		move.l	gm_LastKey(a6),d0
@


40.0
log
@Corrected autodoc format for SEE ALSO.
@
text
@d3 1
a3 1
*	$Id: Keyboard.asm,v 39.4 93/01/18 13:24:31 Jim2 Exp Locker: Jim2 $
d8 3
d78 5
d152 4
a155 2
*	NOTE:  If your program is to exit without reboot, you MUST call
*	RemKBInt before exiting.
d157 5
a161 2
*	NOTE:  Only one interrupt routine may be added to the system.
*	ALWAYS check the return value in case some other task has previously
d274 5
a284 2
*
*
d360 5
a381 1
*
@


39.4
log
@Cleaned up comments.  In QueryKeys require one less register.
@
text
@d3 1
a3 1
*	$Id: Keyboard.asm,v 39.3 93/01/15 13:48:39 Jim2 Exp Locker: Jim2 $
d8 3
d167 1
a167 1
*	RemKBInt
d216 1
a216 1
*	AddKBInt
@


39.3
log
@Removed the keyboard repeat stuff (KeySetThresh and KeySetPeriod)
this simplified GetKeys.
@
text
@d3 1
a3 1
*	$Id: Keyboard.asm,v 39.2 93/01/13 13:38:23 Jim2 Exp Locker: Jim2 $
d8 4
d69 3
d75 1
a75 1
*		     functions, of that key.
d82 1
a82 1
		movem.l	d2/a2-a3/a6,-(sp)
d92 2
a93 2
		lea	Matrix(sp),a3		;Pointer to the keyboard matrix.
		move.l	a3,IO_DATA(a1)
d96 1
a96 1
		JSRLIB	DoIO			;Get the keyboard matrix.
d103 1
a103 1
		bset	d0,0(a3,d1.b)
d111 1
a111 1
		movem.l	(sp)+,d2/a2-a3/a6
d131 6
a136 5
*	When a keyboard interrupt occurs the routine pointed to by IntRoutine
*	is called.  As with any other assembly routine d0, d1, a0 and a1 can
*	be considered scratch, all other registers must have their values
*	preserved.  When the IntRoutine is invoked a1 will contain IntData;
*	also d0 will contain the raw key code read from the keyboard.
d144 3
a146 3
*	NOTE:  Only one interrupt routine may be added to the system.  ALWAYS
*	check the return value in case some other task has previously used
*	this function.
d152 2
a153 1
*		     since this routine is run within the keyboard interrupt.
d169 1
a169 1
		IFNOTEMPTY	a0,akbi_ErrorExit
d184 1
a184 1
		move.l	a1,d0
d206 2
a207 2
*	Handle - Pointer to the handle returned from AddKBInt.  This must not
*		    not be NULL or serious problems will occur.
d216 1
a216 1
		move.l	a6,-(sp)		;Save the parameter and scratch registers.
d236 1
a236 1
*			  a0
d251 6
a256 4
*	shaking.  Once this is done the key is checked.  If it is a keypress
*	and not a modifier, it is stored as the last key press.  Next the
*	value is checked againsts the keyboard control codes.  If it is not
*	one of these, the list of user keyboard interrupts is called.
d280 1
d285 1
d292 1
d295 1
d298 1
d303 1
d308 1
d319 1
d331 1
a331 1
*	D0
d336 4
a339 2
*	This function returns the currently pressed non-qualifier key and all
*	pressed	qualifiers.
@


39.2
log
@Dropped LastKey and PressedKeys.  Moved the interrupt extender
from the startup routine.  Added KeySetThresh, KeySetPeriod
and GetKey.  PressedKeys was superceeded by QueryKeys.  The setting of the delays was not tested.
@
text
@d3 1
a3 1
*	$Id: Keyboard.asm,v 39.1 93/01/07 14:20:24 Jim2 Exp Locker: Jim2 $
d8 6
a37 3
			;Timer.asm
		XREF	ElapsedTime
		XREF	ConvertToFracTime
a41 1
*		XDEF	LastKeyPressed
a45 2
		XDEF	KeySetThresh
		XDEF	KeySetPeriod
a48 34
******* game.library/LastKeyPressed *******************************************
*
*   NAME
*	LastKeyPressed - Returns the raw code for the last key that was pressed.
*
*   SYNOPSIS
*	Key = LastKeyPressed ()
*	D0
*
*	UBYTE LastKeyPressed (VOID)
*
*   FUNCTION
*	This function mointors the keyboard interrupt.  Whenever a key is
*	pressed this function notes it.  When called by the user this
*	function returns the raw code for the last key pressed.
*
*	This function does not remember the key if the user presses any of
*	the modifier keys (Shift, Ctrl, Alt, or Amiga).
*
*	Since this function only remembers a single key press this function
*	cannot be used for checking the case (upper vs. lower) of a key.
*
*
*   INPUTS
*	NONE
*
*   RESULT
*	Key - key code for the last non-modifier key pressed.
*
******************************************************************************
LastKeyPressed
		move.w	gm_LastKey(a6),d0
		rts

d61 3
a63 3
*	Scans the keyboard and the determines which, if any, of the raw key
*	codes listed in the QueryArray are currently pressed.  The state for
*	each code is returned in the array.
d68 1
a68 1
*		     functions, of that key
d113 1
a113 1
*	IntHandle = AddKBInt(IntRoutine, IntData)
d119 4
a122 5
*	Calling this routine causes the system extend the functionality of
*	the keyboard interrupt.  Since this is an extention of the normal
*	keyboard interrupt all of the keyboard handshaking is handled
*	for you.  The input is filtered so that none of the keyboard error
*	codes are passed along to your routine.
d127 2
a128 3
*	preserved.  When the interrupt routine is invoked a1 will contain
*	the value passed to this routine as IntData; also d0 will contain
*	the raw key code recieved from the keyboard.
d136 3
a138 4
*	NOTE:  Only one interrupt routine may be added to the system.  Thus,
*	even if you only use the function once in your program; checking the
*	return value MUST be done in case some other task has already installed
*	a keyboard interrupt.
d142 1
a142 1
*		     keyboard interrupt
d151 2
a152 2
*	IntHandle - Pointer to the handle used in manipulating the interrupt.
*		    NULL if it was not possible create the interrupt.
d187 1
a187 1
*	RemKBInt(IntHandle)
d193 2
a194 3
*	Calling this routine causes the system to remove a keyboard interrupt
*	routine previously added with AddKBInt.  Additionally any resources
*	involved in the interrupt will be freed.
d197 1
a197 1
*	IntHandle - Pointer to the handle returned from AddKBInt.  This must
a262 1
		bsr	UpdateKey
d268 1
a268 1
		beq.w	NoChange
a280 2
		lea	gm_KeyContext(a6),a0
		bsr	ElapsedTime		;Get the current time.
a281 11
		bclr	#7,gm_LastKey(a6)	;Mark this
		move.w	gm_KeyTail(a6),d1
		move.w	d1,d0
		addq.w	#4,d0
		andi.w	#(GMKBBUFFSIZE-1),d0
		cmp.w	gm_KeyHead(a6),d0
		beq.s	LostData
		move.w	d0,gm_KeyTail(a6)
		move.l	gm_LastKey(a6),gm_KeyBuff(a6,d1.w)
LostData:	move.l	gm_KeyRepDefault(a6),gm_KeyRepeat(a6)
		move.l	gm_KeyThreshDefault(a6),gm_KeyThresh(a6)
d283 3
a285 2
KeyUp:		bclr	#7,d2
		cmp.w	gm_LastKey+2(a6),d2
d287 1
a287 1
		bset	#7,gm_LastKey(a6)
d308 1
a308 1
*	GetKey - Returns the 'currently' pressed raw key code and quaifiers.
d317 2
a318 3
*	This function returns the currently pressed key and all pressed
*	qualifiers.  This function handles the autorepeating if a key is
*	held down.
d322 15
a336 16
*
*   RESULT
*	Key - key code for the last non-modifier key pressed is in the low
*	      order word.  The upper order word contains the qualifiers.
*	      The qualifiers are given, within this word, in the same bits
*	      as returned by PeekQualifiers:
*			Bit	Qualifier			Key
*			0	IEQUALIFIER_LSHIFT		Left Shift
*			1	IEQUALIFIER_RSHIFT		Rigt Shift
*			2	IEQUALIFIER_CAPSLOCK		Caps Lock
*			3	IEQUALIFIER_CONTROL		Control
*			4	IEQUALIFIER_LALT		Left Alt
*			5	IEQUALIFIER_RALT		Right Alt
*			6	IEQUALIFIER_LAMIGA		Left Amiga
*			7	IEQUALIFIER_RAMIGA		Right Amiga
*	      If no key is pressed a -1 will be returned.
a337 3
*   SEE ALSO
*	KeySetThresh, KeySetPeriod
*
d340 1
a340 156
		bsr.s	UpdateKey
		move.w	gm_KeyHead(a6),d1
		cmp.w	gm_KeyTail(a6),d1	;Is the buffer empty?
		bne.s	ReturnKey
		moveq	#-1,d0			;Yes, return -1.
		rts
ReturnKey:	move.l	gm_KeyBuff(a6,d1.w),d0	;Get next buffer entry.
		addq.w	#4,d1
		andi.w	#(GMKBBUFFSIZE-1),d1
		move.w	d1,gm_KeyHead(a6)	;and advance the head of the buffer.
		rts


*****l* game.library/UpdateKey ***********************************************
*
*   NAME
*	UpdateKey - Adds the currently pressed key to the key buffer as needed.
*
*   SYNOPSIS
*	UpdateKey ()
*
*   FUNCTION
*	This function handles the autorepeat for a key.
*
*	Rather than utilize timers and a seperate task this autorepeat runs
*	only during keyboard interrupts and when the library is queried for
*	the last keystroke.
*
*	To start this routine determines how long it has been since it was
*	last invoked.  Then the time delta is compared to see if sufficient
*	time has elapsed to start autorepeat.  If so the remaining time,
*	delta - keythreshold, is compared to the repeat delay.  This
*	comparision to repeat delay is iterated until the remaining time
*	become zero.
*
*   INPUTS
*	NONE
*
*   RESULT
*	NONE
*
******************************************************************************
UpdateKey
		movem.l	d2/a5-a6,-(sp)
		move.l	a6,a5
		move.l	gm_ExecBase(a5),a6
*		JSRLIB	Disable			;Don't want interrupts...
		lea	gm_KeyBufSemaphore(a5),a0
*		JSRLIB	ObtainSemaphore		;...since this would be a bad thing.
		move.l	gm_LastKey(a5),d2
		bmi.s	NotHeld			;The high order bit will be set when there is no key pressed.
		lea	gm_KeyContext(a5),a0
		move.l	a5,a6
		bsr	ElapsedTime		;How long since the last key was processed?
		sub.l	gm_KeyThresh(a5),d0
		bpl.s	Thresh
						;There still is time until the repeat threshold is reached.
		neg.l	d0
		move.l	d0,gm_KeyThresh(a5)	;Save the remaining time until threshold
		bra.s	NotHeld
Thresh:
*  clr.b 1						;Repeat threshold reached.
		moveq	#0,d1
		move.l	d1,gm_KeyThresh(a5)	;Save a threshold delay of zero so we drop right to here next time.
RepeatLoop:
		sub.l	gm_KeyRepeat(a5),d0	;Check time until next repeat.
		bmi.s	DoneRepeat
* clr.b 2
		move.w	gm_KeyTail(a5),d1
		move.w	d1,d0
		addq.w	#4,d0
		andi.w	#(GMKBBUFFSIZE-1),d0
		cmp.w	gm_KeyHead(a5),d0
		beq.s	NotHeld			;When the tail is one less than the head the buffer is full.
		move.w	d0,gm_KeyTail(a5)	;Store new tail pointer.
		move.l	d2,gm_KeyBuff(a5,d1.w)	;Store new keypress.
		move.l	gm_KeyRepDefault(a5),gm_KeyRepeat(a5)	;Reset repeat delay.
		bra.s	RepeatLoop
DoneRepeat:					;d0 contains difference between repeat delay and elapsed time.
		neg.l	d0			;need to negate it.
		move.l	d0,gm_KeyRepeat(a5)	;and remember it.
NotHeld:	lea	gm_KeyBufSemaphore(a5),a0
*		JSRLIB	ReleaseSemaphore	;Done, release semaphore.
*		JSRLIB	Enable			;Allow interrupts.
		movem.l	(sp)+,d2/a5-a6
		rts


******* game.library/KeySetThresh ********************************************
*
*   NAME
*	KeySetThresh - Set the time a key is held before autorepeat.
*
*   SYNOPSIS
*	KeySetThresh (ThreshSec, ThreshMicro)
*		      d0	 d1
*
*	VOID KeySetThresh (ULONG, ULONG)
*
*   FUNCTION
*	This function sets the amount of time a key must be depressed before
*	autorepeat begins.
*
*   INPUTS
*	ThreshSec - Number of seconds before autorepeat.  Values greater
*		    than sixteen bits (about 16 hours) will result in
*		    unexpected results.
*	ThreshMicro - Number of microseconds (in addition to the seconds
*		      above) before autorepeat.  Values less than about 500
*		      are not recommended if ThreshSec is zero.
*
*   RESULT
*	NONE
*
*   SEE ALSO
*	GetKey, KeySetPeriod
*
******************************************************************************
KeySetThresh
		bsr.s	ConvertToFracTime
		move.l	d1,gm_KeyThreshDefault(a6)
		rts

******* game.library/KeySetPeriod ********************************************
*
*   NAME
*	KeySetPeriod - Set the time between the repeating of a key.
*
*   SYNOPSIS
*	KeySetPeriod (PeriodSec, PeriodMicro)
*		      d0	 d1
*
*	VOID KeySetPeriod (ULONG, ULONG)
*
*   FUNCTION
*	This function sets the amount of time a key must be depressed once
*	autorepeat begins until the key is repeated.
*
*   INPUTS
*	PeriodSec - Number of seconds between autorepeats.  Values greater
*		    than sixteen bits (about 16 hours) will result in
*		    unexpected results.
*	PeriodMicro - Number of microseconds (in addition to the seconds
*		      above) between autorepeats.  Values less than about
*		      500 are not recommended if PeriodSec is zero.
*
*   RESULT
*	NONE
*
*   SEE ALSO
*	GetKey, KeySetThresh
*
******************************************************************************
KeySetPeriod
		bsr.s	ConvertToFracTime
		move.l	d0,gm_KeyRepDefault(a6)
@


39.1
log
@Tested and corrected.
@
text
@d3 1
a3 1
*	$Id: Keyboard.asm,v 39.0 93/01/05 11:59:40 Jim2 Exp Locker: Jim2 $
d8 3
d32 5
d38 4
a41 2
		XDEF	LastKeyPressed
		XDEF	GetPressedKeys
d44 3
d83 1
a83 1
******* game.library/GetPressedKeys ******************************************
d86 12
a97 1
*	GetPressedKeys - Returns the raw code for multiple depressed keys.
d99 5
a103 18
*   SYNOPSIS
*	GetPressedKeys (KeyArray, ArraySize)
*			a0	  d1
*
*
*	VOID GetMultipleKeys(UBYTE *, UBYTE)
*
*   FUNCTION
*	Calling this function causes the key board to be scanned for keys.
*	The keys are scanned in increasing numerical order by their raw key
*	code.  This function returns all depressed keys encountered in this
*	scan until ArraySize keys have been read.
*
*   INPUTS
*	KeyArray - Pointer to memory into which the raw codes for the keys
*		   are placed.  If there are not enough keys to fill this
*		   array FF is placed after the last valid key.
*	ArraySize - Size of KeyArray in bytes.
a106 4
*
*   SEE ALSO:
*	GetPressedKey
*
d108 2
a109 2
GetPressedKeys
		movem.l	d2-d4/a2-a3/a6,-(sp)
d125 12
a136 18
		bne.s	ErrorExit
		move.l	IO_ACTUAL(sp),d4	;Get number of byte in matrix.
		subq.l	#1,d4
		moveq	#0,d0			;Initialize raw key code.
Loop:		moveq	#7,d3			;Eight bits per byte.
		move.b	(a3)+,d1		;Get byte from matrix.
ByteLoop:	lsr.b	#1,d1
		bcc.s	NotDepressed		;Test least signficant bit.
		move.b	d0,(a2)+		;If set store raw key code...
		subq.b	#1,d2			;... and decrement # of bytes left.
NotDepressed:	addq.b	#1,d0			;Moving to next raw key code.
		tst.b	d2			;Have we filled the array?
		dbeq	d3,ByteLoop		;Completed byte?
		dbeq	d4,Loop			;Completed Matrix?
		beq.s	Exit			;Filled array?
						;There is extra space in the array.
						;FF is the token for completed parsing.
ErrorExit:	move.b	#-1,(a2)
d138 1
a138 1
		movem.l	(sp)+,d2-d4/a2-a3/a6
d257 296
@


39.0
log
@Initial Release - Untested.
@
text
@d3 1
a3 1
*	$Id: $
d7 3
a9 1
*	$Log: $
d11 2
a12 1
*	(C) Copyright 1992 Commodore-Amiga, Inc.
d16 1
a16 3
*
* System include files...
*
a17 1
	INCLUDE 'exec/types.i'
d19 1
a19 1
	INCLUDE	'exec/lists.i'
a20 3
	INCLUDE 'exec/resident.i'
	INCLUDE	'exec/execbase.i'
	INCLUDE	'exec/libraries.i'
a24 4

*
* Neat macros
*
d26 1
a34 7
*
*******************************************************************************
*
* The library structure ...
*

	INCLUDE	'/gamebase.i'
d102 1
a102 1
		movem.l	d2-d3/a2-a3/a6,-(sp)
d104 1
a104 1
		move.l	a1,a2			;Store the array pointer.
d106 2
a107 2
		ARRAYVAR Request IOSTD_SIZE	;Need an IO Request.
		ARRAYVAR Matrix 16		;And room for the keyboard matrix.
d119 2
a120 2
		move.l	IO_ACTUAL(sp),d2	;Get number of byte in matrix.
		subq.l	#1,d2
d124 2
a125 2
ByteLoop:	lsl.b	#1,d1
		beq.s	NotDepressed		;Test least signficant bit.
d130 2
a131 2
		dbne	d3,ByteLoop		;Completed byte?
		dbne	d2,Loop			;Completed Matrix?
d135 1
a135 1
ErrorExit:	move.s	#-1,(a2)
d137 1
a137 1
		movem.l	(sp)+,d2-d3/a2-a3/a6
d143 1
a143 1
*	AddKBInt - Adds routine to the list executed on a keyboard interrupt.
d155 2
a156 1
*	for you.  Also any input continues to be available to the system.
d162 1
a162 1
*	the value passed to this routine as IntData; also d2 will contain
d168 2
a169 2
*	NOTE:  If your program is to exit without reboot, you MUST match all
*	calls to this function with calls to RemKBInt before exiting.
d171 4
a174 3
*	NOTE:  Even if you only use the function once in your program;
*	checking the return value will make your program more tolerant
*	for mulititasking on the Amiga computer platforms.
d179 2
d195 2
d201 1
a201 1
		JSRLIB	AllocMem
d208 1
a208 1
		move.l	(sp)+,IS_DATA(a1)
d210 1
a210 1
		ADDHEAD
@
