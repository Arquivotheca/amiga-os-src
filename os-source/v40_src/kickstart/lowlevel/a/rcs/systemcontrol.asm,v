head     40.10;
branch   ;
access   ;
symbols  V40_35:40.10 rel40_34:40.9 rel40_33:40.9 rel40_32:40.9 rel40_29:40.9 rel40_28:40.9 rel40_27:40.8 rel40_26:40.8 rel40_25:40.8 rel40_24:40.7 rel40_23:40.7 rel40_22:40.7 rel40_21:40.7 rel40_20:40.7 rel40_19:40.7 rel40_18:40.7 rel40_17:40.7 rel40_16:40.7 rel40_15:40.6 rel40_14:40.6 rel40_13:40.5 rel40_12:40.5 rel40_11:40.5 rel40_4:40.0 rel40_3:40.0 rel40_2:40.0 rel40_1:40.0 rel39_7:39.6 rel39_6:39.4 rel39_5:39.3 rel39_4:39.2 rel39_3:39.1 rel39_2:39.1 rel39_1:39.0;
locks    ; strict;
comment  @* @;


40.10
date     93.07.30.16.05.40;  author vertex;  state Exp;
branches ;
next     40.9;

40.9
date     93.05.05.09.52.18;  author gregm;  state Exp;
branches ;
next     40.8;

40.8
date     93.04.20.14.27.38;  author Jim2;  state Exp;
branches ;
next     40.7;

40.7
date     93.03.31.18.51.13;  author Jim2;  state Exp;
branches ;
next     40.6;

40.6
date     93.03.23.14.41.35;  author Jim2;  state Exp;
branches ;
next     40.5;

40.5
date     93.03.12.20.29.47;  author Jim2;  state Exp;
branches ;
next     40.4;

40.4
date     93.03.10.12.23.21;  author Jim2;  state Exp;
branches ;
next     40.3;

40.3
date     93.03.08.10.49.49;  author Jim2;  state Exp;
branches ;
next     40.2;

40.2
date     93.03.02.13.23.21;  author Jim2;  state Exp;
branches ;
next     40.1;

40.1
date     93.03.01.16.12.00;  author Jim2;  state Exp;
branches ;
next     40.0;

40.0
date     93.02.11.17.33.24;  author Jim2;  state Exp;
branches ;
next     39.6;

39.6
date     93.01.19.15.44.21;  author Jim2;  state Exp;
branches ;
next     39.5;

39.5
date     93.01.18.13.32.26;  author Jim2;  state Exp;
branches ;
next     39.4;

39.4
date     93.01.13.13.43.28;  author Jim2;  state Exp;
branches ;
next     39.3;

39.3
date     93.01.07.14.22.44;  author Jim2;  state Exp;
branches ;
next     39.2;

39.2
date     93.01.05.12.08.04;  author Jim2;  state Exp;
branches ;
next     39.1;

39.1
date     92.12.14.14.32.59;  author Jim2;  state Exp;
branches ;
next     39.0;

39.0
date     92.12.11.14.03.18;  author Jim2;  state Exp;
branches ;
next     ;


desc
@Tag controlled function that can be used to selectively
take over parts of the system.
@


40.10
log
@Autodoc and include cleanup
@
text
@******************************************************************************
*
*	$Id: systemcontrol.asm,v 40.9 93/05/05 09:52:18 gregm Exp $
*
******************************************************************************
*
*	$Log:	systemcontrol.asm,v $
* Revision 40.9  93/05/05  09:52:18  gregm
* autodoc changes ...
* changed the ntsc (effective) value from 16667 to 16666, which causes a
* division to be "closer to correct" in the default values.
*
* Revision 40.8  93/04/20  14:27:38  Jim2
* Changed the autodoc for the SCON_StopInput tag.
*
* Revision 40.7  93/03/31  18:51:13  Jim2
* Oops, InstallInputMap can fail.  Even more so now.
*
* Revision 40.6  93/03/23  14:41:35  Jim2
* Polished autodocs.
*
* Revision 40.5  93/03/12  20:29:47  Jim2
* Added the two new tags to add and remove the routines that translate
* joysticks/game controllers to rawkey codes.  Also changed the
* structure of the main routine to use a jump table while parsing
* the tags.  Finally, altered the system ownership so it only
* applies to the two important tags TakeOverSys and KillInput.
*
* Revision 40.4  93/03/10  12:23:21  Jim2
* Cleaned up the results of Vertex code walkthrough.
*
* Revision 40.3  93/03/08  10:49:49  Jim2
* Corrected the register assignment in the autodoc.
*
* Revision 40.2  93/03/02  13:23:21  Jim2
* Changed all references from game.library to lowlevel.library.
*
* Revision 40.1  93/03/01  16:12:00  Jim2
* Added note to remind people about the nature of the beast.
*
* Revision 40.0  93/02/11  17:33:24  Jim2
* Change to use the new single include file.
*
* Revision 39.6  93/01/19  15:44:21  Jim2
* Added SCON_StopInput.
*
* Revision 39.5  93/01/18  13:32:26  Jim2
* Cleaned comments.  Changed tag to SCON_TakeOverSys from SCON_OwnSys.
*
* Revision 39.4  93/01/13  13:43:28  Jim2
* Added the tag SCON_CDReboot to the function descriptin.
*
* Revision 39.3  93/01/07  14:22:44  Jim2
* Cleaned up comments and minimized the specific include files.
*
* Revision 39.2  93/01/05  12:08:04  Jim2
* Documentation correction for SystemControlA.
*
* Revision 39.1  92/12/14  14:32:59  Jim2
* Tested the code for backing out and for clearing the process
* that can work with the system.
*
* Revision 39.0  92/12/11  14:03:18  Jim2
* Initial Release.
*
*
*
*	(C) Copyright 1992,1993 Commodore-Amiga, Inc.
*	    All Rights Reserved
*
******************************************************************************

        INCLUDE 'exec/macros.i'
        INCLUDE 'utility/tagitem.i'

        INCLUDE '/macros.i'
        INCLUDE '/lowlevel.i'
        INCLUDE '/lowlevelbase.i'

                XDEF    SystemControlA

                XREF    TakeOverSystem
                XREF    CDRebootOnRemove
                XREF    TurnOffRequesters
                XREF    TrashInput
                                ;InputMap.asm
                XREF    InstallInputMap
                XREF    UnInstallInputMap


******* lowlevel.library/SystemControlA ***************************************
*
*   NAME
*	SystemControlA - Method for selectively disabling OS features. (V40)
*	SystemControl - varargs stub for SystemControlA().
*
*   SYNOPSIS
*	failTag = SystemControlA(tagList);
*	D0                       A1
*
*	ULONG SystemControlA(struct TagItem *);
*
*	failTag = SystemControl(firstTag, ...);
*
*	ULONG SystemControl(Tag, ...);
*
*   FUNCTION
*	This function is used to alter the operation of the system. Some of
*	the alterations involve controlling what are normally regarded as
*	system resources. In order to minimize confusion only one task is
*	allowed to control any part of the system resources. This prevents
*	the possiblity of two tasks fighting, each controlling a part of the
*	system. If a tag is identified as task exclusive, it means that
*	only one task can hold (set to TRUE) that tag. If
*	another task attempts to set the same tag to TRUE, the call to
*	SystemControl() will fail.
*
*	It is important to remember that SystemControl() can fail.
*
*	This is a low level function and certain tags do not fit the normal
*	Amiga multitasking model.
*
*   INPUTS
*	tagList - pointer to an array of tags listing the features of the
*	          system to be enabled/disabled.
*
*   TAGS
*	SCON_TakeOverSys (BOOL)
*		TRUE -	Takes over the CPU to ensure that a program gets every
*			ounce of CPU time (with the exception of crucial
*			interrupts). When in this mode, the CPU will belong
*			completely to the program. Task switching will be
*			disabled and the program will get all CPU cycles. This
*			means any calls to the OS that involve multitasking in
*			some way will not execute correctly. Other tasks will
*			not run until this tag is used with FALSE. However,
*			during a Wait() on a signal, multitasking will
*			automatically be turned back on until the signal is
*			received. Once received, multitasking will again be
*			disabled and the CPU will be exclusive to the owning
*			program.
*		FALSE - Relinquishes the CPU and reenables multitasking.
*			This tag is task exculsive. This tag nests. A task may
*			take over the CPU several times before relinquishing
*			it.
*
*	SCON_KillReq (BOOL)
*	       TRUE - 	Disables system requesters.  These are the reasons for
*			NOT disabling system requesters:
*
*	                    1- No calls in the program will cause a system
*			       requester.
*	                    2- The only thing that could cause a requester
*			       to appear is the lack of a CD in the drive and
*			       SCON_CDReboot is set to CDReboot_On, therefore a
*			       requester can't appear.
*	    		    3- The only disk I/O is via a CD with SCON_CDReboot
*			       set to CDReboot_On and/or nonvolatile.library.
*
*	    		When requesters should not be disabled.
*	    		GAME PROGRAMS:
*	    		No DOS calls are used after loading; or SCON_CDReboot
*			is CDReboot_On; and nonvolatile.library is used for
*			loading and saving user data.
*
*	    		This fits the above case since; After loading either
*			DOS calls are not used fitting reason 1, or the game
*			is accessing the CD and has SCON_CDReboot set to
*			CDReboot_On fitting reason 2. The game accesses high
*			scores, game position, etc through nonvolatile.library,
*			fitting reason 3.
*
*		FALSE -	Enables requesters for the program.
*
*	    This tag nests. Tasks may disable requesters several times before
*	    enabling them.  However, there must be a matching number of calls.
*
*	SCON_CDReboot (ULONG)
*		CDReboot_On - Ejecting the CD will cause a reboot of the
*			system. Use this only if the program cannot deal with
*			error conditions.
*		CDReboot_Off - Ejecting the CD will not cause a reboot of the
*	    		system. Use this if the program needs to insert CDs
*			while running.
*		CDReboot_Default - Restore the default reboot behavior for this
*			system. This should be used upon exit, if this tag had
*			been used to change the reboot behaviour. For the CD32
* 			this value is synonomous with CDReboot_On. For Amiga
*			computers this value is synonomous with CDReboot_Off.
*
*	    Note that the default reboot behavior differs depending on the
*	    platform. If a program requires a specific behavior it must
*	    use this function to set the behavior. For example, a CD audio
*	    mixer would use this tag with the data CDReboot_Off. This will
*	    allow the changing of audio CDs on the game machine as well as
*	    Amiga computers.
*
*	    If, however, there is no error detection code at all this tag
*	    should be used with the data CDReboot_On.
*
*	    It is hoped that no program will require CDReboot_On. If all
*	    programs check for error condition and recover gracefully such a
*	    call should never be necessary. With the default behavior the
*	    CD32 will always reset on disk ejects, and programs
*	    run from Amiga computers will not reset. Thus, leaving the
*	    default will increase the market for a program to include both
*	    types of platforms.
*
*	    This tag does not nest.
*
*	SCON_StopInput (BOOL) - When TRUE, stops input.device from using any
*	    CPU cycles. Also prevents input.device from passing along any
*	    events from either the keyboard and/or port 0.
*
*	    This tag is task exclusive. This tag is NOT reversible.
*	    Attempting to reverse will result in confused/garbled input
*	    events.
*
*	SCON_AddCreateKeys (ULONG) - Starts creating rawkey codes for the
*	    joystick/game controller on the given unit. The unit value is
*	    checked for validity and must be either 0 or 1. Each different unit
*	    used results in some code added to the VBlank interrupt chain.
*	    This tag nests. The tag SCON_RemCreateKeys is used to undo this
*	    tag. Tasks may create rawkey codes several times before stopping
*	    them.
*
*	    Note that when operating in an Intuition window, the controller's
*	    blue button is the equivilent of the mouse menu button. Therefore,
*	    Intuition will be capturing most blue button events. If
*	    notificiation of these events is important, review the
*	    documentation for WFLG_RMBTRAP in the
*	    intuition.library/OpenWindow() autodoc.
*
*	SCON_RemCreateKeys (ULONG) - stops rawkey codes for the joystick/game
*	    controller on the given unit. The unit value is checked for
*	    validity and must be either 0 or 1.
*
*   RESULT
*	failTag - zero if all tags succeeded. A non-zero return indicates a
*		  tag that has failed. It is possible that other tags may
*	          fail as well.
*
*	          If any tag fails there will be no change in the system due
*	          to other tags.
*
*   SEE ALSO
*	<libraries/lowlevel.h>
*
*******************************************************************************
*
*	d7      Task executing
*	a5      LowLevelBase
*	a6      ExecBase
*
*******************************************************************************
SystemControlA
                movem.l d7/a4-a6,-(sp)
                move.l  a6,a5

TEMP_SIZE       set     0                       ;Determine the number of bytes wanted for local variables
                LONGVAR TagState
                LONGVAR UndoTag

                ALLOCLOCALS sp                  ;Make some local variables on the stack.
                move.l  a1,TagState_l(sp)       ;Save the pointer to the Taglist.
                move.l  a1,UndoTag_l(sp)
                move.l  ll_ExecBase(a5),a6
                CLEARA  a1
                JSRLIB  FindTask                ;FindTask (a1>Null:Current Task, a6>ExecBase)
                move.l  d0,d7

tagparse:       move.l  ll_UtilBase(a5),a6
                lea     TagState_l(sp),a0
                JSRLIB  NextTagItem             ;NextTagItem(a6>UtilBase, a0>**TagItem)
                move.l  ll_ExecBase(a5),a6
                                ;d0 points to the tag to be handled, or NULL if complete.
                tst.l   d0
                bne.s   sc_NewTag
                                ;Completed parseing the tag list.
donetags:       DONELOCALS sp
                move.l  d0,-(sp)
                move.b  ll_NestOwn(a5),d0
                and.b   ll_NestKillIn(a5),d0
                bpl.s   StillControl
                sub.l   ll_SystemOwner(a5),d7
                bne.s   StillControl
                move.l  d7,ll_SystemOwner(a5)   ;No one owns any part of the system.
StillControl:   movem.l (sp)+,d0/d7/a4-a6
                rts

sc_NewTag:      move.l  d0,a0
                move.l  (a0)+,d0                ;Tag into d0.
                move.l  (a0)+,d1                ;Tag data into d1.
                sub.l   #SCON_TakeOverSys,d0    ;Lowest numbered tag is SCON_TakeOverSys.
                bmi.s   tagparse
                cmp.w   #SCON_RemCreateKeys-SCON_TakeOverSys,d0
                bgt.s   tagparse
                rol.w   #1,d0
                move.w  sc_JumpTable(pc,d0.w),d0
                jmp     sc_JumpTable(pc,d0.w)

sc_JumpTable:   dc.w    sc_TakeOverSys-sc_JumpTable
                dc.w    sc_KillReq-sc_JumpTable
                dc.w    sc_CDReboot-sc_JumpTable
                dc.w    sc_StopInput-sc_JumpTable
                dc.w    sc_AddCreateKeys-sc_JumpTable
                dc.w    sc_RemCreateKeys-sc_JumpTable




sc_TakeOverSys: move.l  #SCON_TakeOverSys,d0
                bsr     TestOwner
                bne     sc_Undo
                bsr     TakeOverSystem          ;TakeOverSystem(a5>GameBase, d1>TRUE/FALSE)
                bra.s   tagparse

sc_KillReq:     exg     a5,a6
                bsr     TurnOffRequesters       ;TurnOffRequesters(a6>GameBase, d1>TRUE/FALSE)
                exg     a5,a6
                bra.s   tagparse
                                ;SCON_CDReboot
sc_CDReboot:    bsr     CDRebootOnRemove        ;CDRebootOnRemove(a5>GameBase, d1>FORCEON,OFF,DEFAULT)
                tst.l   d0
                beq.s   tagparse

                move.l  #SCON_CDReboot,d0
                bra     sc_Undo
                                ;SCON_StopInput
sc_StopInput:   move.l  #SCON_StopInput,d0
                bsr     TestOwner
                bne     sc_Undo
                bsr     TrashInput
                bra     tagparse

sc_AddCreateKeys:
                move.l  #SCON_AddCreateKeys,d0
                cmp.l   #1,d1
                bgt.s   sc_Undo

                move.l  d1,d0
                mulu.w  #lljp_SIZE,d1
                lea     ll_Port0State(a5,d1.l),a4
                lea     lljp_AddSafely(a4),a0
                JSRLIB  ObtainSemaphore
                                ;
                                ;It is possible to fail during the add, so we need
                                ;to complete the addition before letting any other
                                ;process believe it can use the interrupts.
                                ;
                                ;It is not necessary to protect the removing, or
                                ;the adding in the backout since it should not
                                ;fail.  The port is available, the only problem
                                ;might be with the memory.
                                ;
                addq.b  #1,lljp_NestCnt(a4)
                bne.s   ValidAdd

                bsr     InstallInputMap
                move.l  d0,lljp_InputHandle(a4)
                bne.s   ValidAdd
                lea     lljp_AddSafely(a4),a0
                JSRLIB  ReleaseSemaphore
                move.l  #SCON_AddCreateKeys,d0
                bra.s   sc_Undo

ValidAdd:       lea     lljp_AddSafely(a4),a0
                JSRLIB  ReleaseSemaphore
                bra     tagparse

sc_RemCreateKeys:
                move.l  #SCON_RemCreateKeys,d0
                cmp.l   #1,d1
                bgt.s   sc_Undo

                move.l  d1,d0
                mulu.w  #lljp_SIZE,d1
                lea     ll_Port0State(a5,d1.l),a4
                subq.b  #1,lljp_NestCnt(a4)
                bpl     tagparse

                move.l  lljp_InputHandle(a4),a0
                bsr     UnInstallInputMap
                bra     tagparse

sc_Undo         move.l  UndoTag_l(sp),a1
                bsr.s   BackOutSysCon
                bra     donetags



*****l* a/SystemControl.asm/TestOwner ****************************************
*
*   NAME
*	TestOwner - Determines whether the current Task owns the system.
*
*   SYNOPSIS
*	TestOwner (TaskPtr, LowLevelBase, ExecBase)
*	           d7       a5            a6
*
*   FUNCTION
*	If no task owns the system changes the system owner to the current
*	task.  Sets the condition code as to whether the system owner task
*	is equal to the current task.
*
*   NOTE
*	MUST preserve the values in d0 and d1.
*
*
******************************************************************************
TestOwner
                JSRLIB  Forbid
                tst.l   ll_SystemOwner(a5)
                bne.s   to_Owned

                move.l  d7,ll_SystemOwner(a5)
to_Owned:       JSRLIB  Permit
                                ;
                                ;It is of course possible for the other task
                                ;which previously owned the system to come
                                ;along and release it between the permit and
                                ;this statement, but we don't care since we
                                ;have not set ourselves as owner.
                                ;
                cmp.l   ll_SystemOwner(a5),d7
                rts

*****l* a/SystemControl.asm/BackOutSysCon ************************************
*
*   NAME
*	BackOutSysCon - Undo any tags executed by SystemControlA before the
*	                failed tag.
*
*   SYNOPSIS
*	BackOutSysCon (tagItemPtr, FailedTag)
*	               a1          d0
*
*   FUNCTION
*	Rewalks the tag list passed to SystemControlA until the failed tag
*	is encountered.  Before processing each tag the data associated with
*	that tag is inverted.
*
******************************************************************************
BackOutSysCon
                movem.l d0/d7,-(sp)
                move.l  d0,d7
                move.l  a1,-(sp)
NextTag         move.l  ll_UtilBase(a5),a6
                lea     (sp),a0
                JSRLIB  NextTagItem             ;NextTagItem(a6>UtilBase, a0>**TagItem)
                move.l  ll_ExecBase(a5),a6
                                ;d0 points to the tag to be handled, or NULL if complete.
                move.l  d0,a0
                move.l  (a0)+,d0                ;Tag into d0.
                cmp.l   d0,d7
                bne.s   bosc_NewTag
                                ;Completed parseing the tag list.
                move.l  (sp)+,a1
                movem.l (sp)+,d0/d7
                rts

bosc_NewTag:    move.l  (a0)+,d1                ;Tag data into d1.
                sub.l   #SCON_TakeOverSys,d0    ;Lowest numbered tag is SCON_TakeOverSys.
                bmi.s   NextTag
                cmp.w   #SCON_RemCreateKeys-SCON_TakeOverSys,d0
                bgt.s   NextTag

                rol.w   #1,d0
                move.w  bosc_JumpTable(pc,d0.w),d0
                jmp     bosc_JumpTable(pc,d0.w)


bosc_JumpTable: dc.w    bosc_TakeOverSys-bosc_JumpTable
                dc.w    bosc_KillReq-bosc_JumpTable
                dc.w    bosc_CDReboot-bosc_JumpTable
                dc.w    bosc_StopInput-bosc_JumpTable
                dc.w    bosc_AddCreateKeys-bosc_JumpTable
                dc.w    bosc_RemCreateKeys-bosc_JumpTable




bosc_TakeOverSys:
                bsr.s   InvertBOOL
                bsr     TakeOverSystem          ;TakeOverSystem(a5>GameBase, d1>TRUE/FALSE)
                bra.s   NextTag

bosc_KillReq:   bsr.s   InvertBOOL
                exg     a5,a6
                bsr     TurnOffRequesters       ;TurnOffRequesters(a6>GameBase, d1>TRUE/FALSE)
                exg     a5,a6
                bra.s   NextTag
                                ;SCON_CDReboot
bosc_CDReboot:  cmp.l   #1,d1
                bpl.s   1$
                eori.s  #1,d1
1$:             bsr     CDRebootOnRemove        ;CDRebootOnRemove(a5>GameBase, d1>FORCEON,OFF,DEFAULT)
                bra.s   NextTag
                                ;SCON_StopInput
bosc_StopInput: bsr.s   InvertBOOL
                bsr     TrashInput
                bra.s   NextTag

bosc_RemCreateKeys:
                move.l  d1,d0
                mulu.w  #lljp_SIZE,d1
                lea     ll_Port0State(a5,d1.l),a4
                addq.b  #1,lljp_NestCnt(a4)
                bne     NextTag

                bsr     InstallInputMap
                move.l  d0,lljp_InputHandle(a4)
                bra     NextTag

bosc_AddCreateKeys:
                move.l  d1,d0
                mulu.w  #lljp_SIZE,d1
                lea     ll_Port0State(a5,d1.l),a4
                subq.b  #1,lljp_NestCnt(a4)
                bpl     NextTag

                move.l  lljp_InputHandle(a4),d0
                bsr     UnInstallInputMap
                bra     NextTag


*****l* a/SystemControl.asm/InvertBOOL ***************************************
*
*   NAME
*	InvertBOOL - Invert the boolean variable.
*
*   SYNOPSIS
*	InvertBOOL (Bool)
*	            d1
*
*   FUNCTION
*	Takes the current value in d1, determines if it is TRUE, or FALSE and
*	then inverts it.
*
*	TRUE is non-zero, FALSE is zero.
*
******************************************************************************
InvertBOOL
                tst.w   d1
                seq     d1
                rts


                END
@


40.9
log
@autodoc changes ...
changed the ntsc (effective) value from 16667 to 16666, which causes a 
division to be "closer to correct" in the default values.
@
text
@d3 1
a3 1
*       $Id: systemcontrol.asm,v 40.8 93/04/20 14:27:38 Jim2 Exp $
d7 6
a12 1
*       $Log:   systemcontrol.asm,v $
d68 2
a69 2
*       (C) Copyright 1992,1993 Commodore-Amiga, Inc.
*           All Rights Reserved
d94 2
a95 2
*       SystemControlA - Method for selectively disabling OS features.
*       SystemControl - varargs stub for SystemControlA().
d98 2
a99 2
*       FalTag = SystemControlA (tagList)
*       d0                       a1
d101 1
a101 1
*       ULONG SystemControlA (struct TagItem *);
d103 1
a103 1
*       Failure = SystemControl(firsttag, ...)
d105 1
a105 1
*       ULONG SystemControl(Tag, ...);
d108 11
a118 11
*       This function is used to alter the operation of the system.  Some of
*       the alterations involving controlling what are normally regarded as
*       system resources.  In order to minimize confusion only one task is
*       allowed to control any part of the system resources.  This prevents
*       the possiblity of two task fighting each controlling a part of the
*       system.  If the tag is identified as task exculsive it means that
*       only one task can hold (set to TRUE) any one of the tags.  If
*       another task attempts to set any of these tags TRUE the call to
*       SystemControl will fail.
*
*       It is important to remember that SystemControlA can fail.
d120 2
a121 3
*   NOTE
*       This is a low level function and certain tags do not fit the normal
*       Amgia multitasking model.
d124 2
a125 2
*       tagList - pointer to an array of tags listing the features of the
*                 system to be enabled/disabled.
d128 105
a232 104
*       SCON_TakeOverSys:
*       TRUE - Takes over the CPU to ensure that a program gets every ounce
*           of CPU time (with the exception of crucial interrupts).  When in
*           this mode, the CPU will belong completely to the program.  Task
*           switching will be disabled and the program will get the all CPU
*           cycles.  This means any calls to the OS that involve
*           multitasking in some way will not execute.  Other tasks will not
*           run until this tag is used with the data FALSE.  However, during
*           a Wait() on a signal, multitasking will automatically be turned
*           back on until the signal is recieved.  Once recieved,
*           multitasking will again be disabled and the CPU will be
*           exclusive to the owning program.
*       FALSE - Relinquishes the CPU and reenables multitasking.
*       This tag is task exculsive.
*       This tag nests.  A task may take over the CPU several times before
*       relinquishing it.  However, there must be a matching number of
*       calls.
*
*       SCON_KillReq:
*       TRUE - Disables system requesters.  These are the reasons for NOT
*           disabling system requesters:
*
*           1   No calls in the program will cause a system requester.
*           2   The only thing that could cause a requester to appear is the
*               lack of a CD in the drive and SCON_CDReboot is CDReboot_On,
*               therefore a requester can't appear.
*           3   The only disk I/O is via a CD with SCON_CDReboot set to
*               CDReboot_On and/or nonvolatile.library.
*
*           When requesters should not be disabled.
*           GAME PROGRAMS:
*           No DOS calls are used after loading; or SCON_CDReboot is
*           CDReboot_On; and nonvolatile.library is used for loading and
*           saving user data.
*
*           This fits the above case since; After loading either DOS calls
*           are not used fitting reason 1, or the game is accessing the CD
*           and has SCON_CDReboot set to CDReboot_On fitting reason 2.  The
*           game accesses high scores, game position, etc through the
*           nonvolatile.library  meeting the reason 3.
*       FALSE - Enables requesters for the program.
*       This tag nests.  Tasks may disable requesters several times before
*       enabling them.  However, there must be a matching number of calls.
*
*       SCON_CDReboot:
*       CDReboot_On - Ejecting the CD will cause a reboot of the system.
*           Use this only if the program cannot deal with error conditions.
*       CDReboot_Off - Ejecting the CD will not cause a reboot of the
*           system.  Use this if the program needs to insert CDs while
*           running.
*       CDReboot_Default - Restore the default reboot behaviour for this
*           system.  This should be used upon exit, if this tag had been
*           used to change the reboot behaviour.  For the game machine this
*           value is synonomous with CDReboot_On.  For Amiga computers this
*           value is synonomous with CDReboot_Off.
*
*           NOTE:  The default reboot behaviour differs depending on the
*           platform.  If an program requires a specific behaviour it must
*           use this function to set the behaviour.  For example, a CD audio
*           mixer would use this tag with the data CDReboot_Off.  This will
*           allow the changing of audio CDs on the game machine as well as
*           Amiga computers.
*
*           If, however, there is no error detection code at all this tag
*           should be used with the data CDReboot_On.
*
*           It is hoped that no program will require CDReboot_On.  If all
*           programs check for error condition and recover gracefully such a
*           call should never be necessary.  With the default behavior the
*           games machine will always reset on disk ejects, and programs
*           run from Amiga will not reset.  Thus the leaving the default
*           will increase the market for a program to include both types of
*           platforms.
*       This tag does not nest.
*
*       SCON_StopInput:
*       TRUE - Stop input.device from using any CPU.  Also prevents
*           input.device from passing along any events from either the
*           keyboard and/or port 0.
*       This tag is task exclusive.
*       This tag is NOT reversable.  Attempting to reverse will result in
*       confused/garbled input events.
*
*       SCON_AddCreateKeys:
*       unit - Create raw keycodes for the joystick/game controller on unit.
*           The unit value is checked for validity and must be either zero,
*           or one.  Each different unit value results in some code added to
*           the VBlank interrupt chain.
*       This tag nests.  The tag SCON_RemCreateKeys is used to undo this
*       tag.  Tasks may create keycodes several times before stopping them.
*       However, there must be a matching number of calls.
*
*       NOTE:
*       When operating in an intuition Window, the controller's blue button
*       is the equivilent of the mouse menu button -- therefore, intuition
*       will be capturing most blue button events.  If notificiation of
*       these events is important, review the documentation for WFLG_RMBTRAP
*       in the intuition.library/OpenWindow() autodoc.
*
*       SCON_RemCreateKeys:
*       unit - Stop raw keycodes for the joystick/game controller on unit.
*           The unit value is checked for validity and must be either zero,
*           or one.
*       This tag is used to match SCON_AddCreateKeys.
d234 4
d239 6
a244 3
*       FailTag - Zero if all tags succeeded.  If non zero indicates a tag
*                 that has failed.  It is possible that other tags may
*                 fail as well.
d246 2
a247 2
*                 If any tag fails there will be no change in the system due
*                 to other tags.
d251 3
a253 3
*       d7      Task executing
*       a5      LowLevelBase
*       a6      ExecBase
d395 1
a395 1
*       TestOwner - Determines whether the current Task owns the system.
d398 2
a399 2
*       TestOwner (TaskPtr, LowLevelBase, ExecBase)
*                  d7       a5            a6
d402 3
a404 3
*       If no task owns the system changes the system owner to the current
*       task.  Sets the condition code as to whether the system owner task
*       is equal to the current task.
d407 1
a407 1
*       MUST preserve the values in d0 and d1.
d431 2
a432 2
*       BackOutSysCon - Undo any tags executed by SystemControlA before the
*                       failed tag.
d435 2
a436 2
*       BackOutSysCon (tagItemPtr, FailedTag)
*                      a1          d0
d439 3
a441 4
*       Rewalks the tag list passed to SystemControlA until the failed tag
*       is encountered.  Before processing each tag the data associated with
*       that tag is inverted.
*
d530 1
a530 1
*       InvertBOOL - Invert the boolean variable.
d533 2
a534 2
*       InvertBOOL (Bool)
*                   d1
d537 2
a538 2
*       Takes the current value in d1, determines if it is TRUE, or FALSE and
*       then inverts it.
d540 1
a540 1
*       TRUE is non-zero, FALSE is zero.
@


40.8
log
@Changed the autodoc for the SCON_StopInput tag.
@
text
@d3 1
a3 1
*	$Id: systemcontrol.asm,v 40.7 93/03/31 18:51:13 Jim2 Exp Locker: Jim2 $
d7 4
a10 1
*	$Log:	systemcontrol.asm,v $
d63 2
a64 2
*	(C) Copyright 1992,1993 Commodore-Amiga, Inc.
*	    All Rights Reserved
d68 2
a69 2
	INCLUDE	'exec/macros.i'
	INCLUDE 'utility/tagitem.i'
d71 13
a83 13
	INCLUDE	'/macros.i'
	INCLUDE	'/lowlevel.i'
	INCLUDE	'/lowlevelbase.i'

		XDEF	SystemControlA

		XREF	TakeOverSystem
		XREF	CDRebootOnRemove
		XREF	TurnOffRequesters
		XREF	TrashInput
				;InputMap.asm
		XREF	InstallInputMap
		XREF	UnInstallInputMap
d86 1
a86 1
******* LowLevel.library/SystemControlA ***************************************
d89 2
a90 2
*	SystemControlA - Method for selectively disabling OS features.
*	SystemControl - varargs stub for SystemControlA().
d93 2
a94 2
*	FalTag = SystemControlA (tagList)
*	d0			 a1
d96 1
a96 1
*	ULONG SystemControlA (struct TagItem *);
d98 1
a98 1
*	Failure = SystemControl(firsttag, ...)
d100 1
a100 1
*	ULONG SystemControl(Tag, ...);
d103 9
a111 9
*	This function is used to alter the operation of the system.  Some of
*	the alterations involving controlling what are normally regarded as
*	system resources.  In order to minimize confusion only one task is
*	allowed to control any part of the system resources.  This prevents
*	the possiblity of two task fighting each controlling a part of the
*	system.  If the tag is identified as task exculsive it means that
*	only one task can hold (set to TRUE) any one of the tags.  If
*	another task attempts to set any of these tags TRUE the call to
*	SystemControl will fail.
d113 1
a113 1
*	It is important to remember that SystemControlA can fail.
d116 2
a117 2
*	This is a low level function and certain tags do not fit the normal
*	Amgia multitasking model.
d120 2
a121 2
*	tagList - pointer to an array of tags listing the features of the
*		  system to be enabled/disabled.
d124 104
a227 97
*	SCON_TakeOverSys:
*	TRUE - Takes over the CPU to ensure that a program gets every ounce
*	    of CPU time (with the exception of crucial interrupts).  When in
*	    this mode, the CPU will belong completely to the program.  Task
*	    switching will be disabled and the program will get the all CPU
*	    cycles.  This means any calls to the OS that involve
*	    multitasking in some way will not execute.  Other tasks will not
*	    run until this tag is used with the data FALSE.  However, during
*	    a Wait() on a signal, multitasking will automatically be turned
*	    back on until the signal is recieved.  Once recieved,
*	    multitasking will again be disabled and the CPU will be
*	    exclusive to the owning program.
*	FALSE - Relinquishes the CPU and reenables multitasking.
*	This tag is task exculsive.
*	This tag nests.  A task may take over the CPU several times before
*	relinquishing it.  However, there must be a matching number of
*	calls.
*
*	SCON_KillReq:
*	TRUE - Disables system requesters.  These are the reasons for NOT
*	    disabling system requesters:
*
*	    1	No calls in the program will cause a system requester.
*	    2	The only thing that could cause a requester to appear is the
*		lack of a CD in the drive and SCON_CDReboot is CDReboot_On,
*		therefore a requester can't appear.
*	    3	The only disk I/O is via a CD with SCON_CDReboot set to
*		CDReboot_On and/or nonvolatile.library.
*
*	    When requesters should not be disabled.
*	    GAME PROGRAMS:
*	    No DOS calls are used after loading; or SCON_CDReboot is
*	    CDReboot_On; and nonvolatile.library is used for loading and
*	    saving user data.
*
*	    This fits the above case since; After loading either DOS calls
*	    are not used fitting reason 1, or the game is accessing the CD
*	    and has SCON_CDReboot set to CDReboot_On fitting reason 2.  The
*	    game accesses high scores, game position, etc through the
*	    nonvolatile.library  meeting the reason 3.
*	FALSE - Enables requesters for the program.
*	This tag nests.  Tasks may disable requesters several times before
*	enabling them.  However, there must be a matching number of calls.
*
*	SCON_CDReboot:
*	CDReboot_On - Ejecting the CD will cause a reboot of the system.
*	    Use this only if the program cannot deal with error conditions.
*	CDReboot_Off - Ejecting the CD will not cause a reboot of the
*	    system.  Use this if the program needs to insert CDs while
*	    running.
*	CDReboot_Default - Restore the default reboot behaviour for this
*	    system.  This should be used upon exit, if this tag had been
*	    used to change the reboot behaviour.  For the game machine this
*	    value is synonomous with CDReboot_On.  For Amiga computers this
*	    value is synonomous with CDReboot_Off.
*
*	    NOTE:  The default reboot behaviour differs depending on the
*	    platform.  If an program requires a specific behaviour it must
*	    use this function to set the behaviour.  For example, a CD audio
*	    mixer would use this tag with the data CDReboot_Off.  This will
*	    allow the changing of audio CDs on the game machine as well as
*	    Amiga computers.
*
*	    If, however, there is no error detection code at all this tag
*	    should be used with the data CDReboot_On.
*
*	    It is hoped that no program will require CDReboot_On.  If all
*	    programs check for error condition and recover gracefully such a
*	    call should never be necessary.  With the default behavior the
*	    games machine will always reset on disk ejects, and programs
*	    run from Amiga will not reset.  Thus the leaving the default
*	    will increase the market for a program to include both types of
*	    platforms.
*	This tag does not nest.
*
*	SCON_StopInput:
*	TRUE - Stop input.device from using any CPU.  Also prevents
*	    input.device from passing along any events from either the
*	    keyboard and/or port 0.
*	This tag is task exclusive.
*	This tag is NOT reversable.  Attempting to reverse will result in
*	confused/garbled input events.
*
*	SCON_AddCreateKeys:
*	unit - Create raw keycodes for the joystick/game controller on unit.
*	    The unit value is checked for validity and must be either zero,
*	    or one.  Each different unit value results in some code added to
*	    the VBlank interrupt chain.
*	This tag nests.  The tag SCON_RemCreateKeys is used to undo this
*	tag.  Tasks may create keycodes several times before stopping them.
*	However, there must be a matching number of calls.
*
*	SCON_RemCreateKeys:
*	unit - Stop raw keycodes for the joystick/game controller on unit.
*	    The unit value is checked for validity and must be either zero,
*	    or one.
*	This tag is used to match SCON_AddCreateKeys.
d230 3
a232 3
*	FailTag - Zero if all tags succeeded.  If non zero indicates a tag
*		  that has failed.  It is possible that other tags may
*		  fail as well.
d234 2
a235 2
*		  If any tag fails there will be no change in the system due
*		  to other tags.
d239 3
a241 3
*	d7	Task executing
*	a5	LowLevelBase
*	a6	ExecBase
d245 2
a246 2
		movem.l	d7/a4-a6,-(sp)
		move.l	a6,a5
d248 75
a322 75
TEMP_SIZE	set	0			;Determine the number of bytes wanted for local variables
		LONGVAR	TagState
		LONGVAR	UndoTag

		ALLOCLOCALS sp			;Make some local variables on the stack.
		move.l	a1,TagState_l(sp)	;Save the pointer to the Taglist.
		move.l	a1,UndoTag_l(sp)
		move.l	ll_ExecBase(a5),a6
		CLEARA	a1
		JSRLIB	FindTask		;FindTask (a1>Null:Current Task, a6>ExecBase)
		move.l	d0,d7

tagparse:	move.l	ll_UtilBase(a5),a6
		lea	TagState_l(sp),a0
		JSRLIB	NextTagItem		;NextTagItem(a6>UtilBase, a0>**TagItem)
		move.l	ll_ExecBase(a5),a6
				;d0 points to the tag to be handled, or NULL if complete.
		tst.l	d0
		bne.s	sc_NewTag
				;Completed parseing the tag list.
donetags:	DONELOCALS sp
		move.l	d0,-(sp)
		move.b	ll_NestOwn(a5),d0
		and.b	ll_NestKillIn(a5),d0
		bpl.s	StillControl
		sub.l	ll_SystemOwner(a5),d7
		bne.s	StillControl
		move.l	d7,ll_SystemOwner(a5)	;No one owns any part of the system.
StillControl:	movem.l	(sp)+,d0/d7/a4-a6
		rts

sc_NewTag:	move.l	d0,a0
		move.l	(a0)+,d0		;Tag into d0.
		move.l	(a0)+,d1		;Tag data into d1.
		sub.l	#SCON_TakeOverSys,d0	;Lowest numbered tag is SCON_TakeOverSys.
		bmi.s	tagparse
		cmp.w	#SCON_RemCreateKeys-SCON_TakeOverSys,d0
		bgt.s	tagparse
		rol.w	#1,d0
		move.w	sc_JumpTable(pc,d0.w),d0
		jmp	sc_JumpTable(pc,d0.w)

sc_JumpTable:	dc.w	sc_TakeOverSys-sc_JumpTable
		dc.w	sc_KillReq-sc_JumpTable
		dc.w	sc_CDReboot-sc_JumpTable
		dc.w	sc_StopInput-sc_JumpTable
		dc.w	sc_AddCreateKeys-sc_JumpTable
		dc.w	sc_RemCreateKeys-sc_JumpTable




sc_TakeOverSys: move.l	#SCON_TakeOverSys,d0
		bsr	TestOwner
		bne	sc_Undo
		bsr	TakeOverSystem		;TakeOverSystem(a5>GameBase, d1>TRUE/FALSE)
		bra.s	tagparse

sc_KillReq:	exg	a5,a6
		bsr	TurnOffRequesters	;TurnOffRequesters(a6>GameBase, d1>TRUE/FALSE)
		exg	a5,a6
		bra.s	tagparse
				;SCON_CDReboot
sc_CDReboot:	bsr	CDRebootOnRemove	;CDRebootOnRemove(a5>GameBase, d1>FORCEON,OFF,DEFAULT)
		tst.l	d0
		beq.s	tagparse

		move.l	#SCON_CDReboot,d0
		bra	sc_Undo
				;SCON_StopInput
sc_StopInput:	move.l	#SCON_StopInput,d0
		bsr	TestOwner
		bne	sc_Undo
		bsr	TrashInput
		bra	tagparse
d325 3
a327 3
		move.l	#SCON_AddCreateKeys,d0
		cmp.l	#1,d1
		bgt.s	sc_Undo
d329 25
a353 25
		move.l	d1,d0
		mulu.w	#lljp_SIZE,d1
		lea	ll_Port0State(a5,d1.l),a4
		lea	lljp_AddSafely(a4),a0
		JSRLIB	ObtainSemaphore
				;
				;It is possible to fail during the add, so we need
				;to complete the addition before letting any other
				;process believe it can use the interrupts.
				;
				;It is not necessary to protect the removing, or
				;the adding in the backout since it should not
				;fail.  The port is available, the only problem
				;might be with the memory.
				;
		addq.b	#1,lljp_NestCnt(a4)
		bne.s	ValidAdd

		bsr	InstallInputMap
		move.l	d0,lljp_InputHandle(a4)
		bne.s	ValidAdd
		lea	lljp_AddSafely(a4),a0
		JSRLIB	ReleaseSemaphore
		move.l	#SCON_AddCreateKeys,d0
		bra.s	sc_Undo
d355 3
a357 3
ValidAdd:	lea	lljp_AddSafely(a4),a0
		JSRLIB	ReleaseSemaphore
		bra	tagparse
d360 3
a362 3
		move.l	#SCON_RemCreateKeys,d0
		cmp.l	#1,d1
		bgt.s	sc_Undo
d364 13
a376 13
		move.l	d1,d0
		mulu.w	#lljp_SIZE,d1
		lea	ll_Port0State(a5,d1.l),a4
		subq.b	#1,lljp_NestCnt(a4)
		bpl	tagparse

		move.l	lljp_InputHandle(a4),a0
		bsr	UnInstallInputMap
		bra	tagparse

sc_Undo		move.l	UndoTag_l(sp),a1
		bsr.s	BackOutSysCon
		bra	donetags
d383 1
a383 1
*	TestOwner - Determines whether the current Task owns the system.
d386 2
a387 2
*	TestOwner (TaskPtr, LowLevelBase, ExecBase)
*		   d7	    a5		  a6
d390 3
a392 3
*	If no task owns the system changes the system owner to the current
*	task.  Sets the condition code as to whether the system owner task
*	is equal to the current task.
d395 1
a395 1
*	MUST preserve the values in d0 and d1.
d400 3
a402 3
		JSRLIB	Forbid
		tst.l	ll_SystemOwner(a5)
		bne.s	to_Owned
d404 11
a414 11
		move.l	d7,ll_SystemOwner(a5)
to_Owned:	JSRLIB	Permit
				;
				;It is of course possible for the other task
				;which previously owned the system to come
				;along and release it between the permit and
				;this statement, but we don't care since we
				;have not set ourselves as owner.
				;
		cmp.l	ll_SystemOwner(a5),d7
		rts
d419 2
a420 2
*	BackOutSysCon - Undo any tags executed by SystemControlA before the
*			failed tag.
d423 2
a424 2
*	BackOutSysCon (tagItemPtr, FailedTag)
*		       a1	   d0
d427 3
a429 3
*	Rewalks the tag list passed to SystemControlA until the failed tag
*	is encountered.  Before processing each tag the data associated with
*	that tag is inverted.
d434 34
a467 34
		movem.l	d0/d7,-(sp)
		move.l	d0,d7
		move.l	a1,-(sp)
NextTag		move.l	ll_UtilBase(a5),a6
		lea	(sp),a0
		JSRLIB	NextTagItem		;NextTagItem(a6>UtilBase, a0>**TagItem)
		move.l	ll_ExecBase(a5),a6
				;d0 points to the tag to be handled, or NULL if complete.
		move.l	d0,a0
		move.l	(a0)+,d0		;Tag into d0.
		cmp.l	d0,d7
		bne.s	bosc_NewTag
				;Completed parseing the tag list.
		move.l	(sp)+,a1
		movem.l	(sp)+,d0/d7
		rts

bosc_NewTag:	move.l	(a0)+,d1		;Tag data into d1.
		sub.l	#SCON_TakeOverSys,d0	;Lowest numbered tag is SCON_TakeOverSys.
		bmi.s	NextTag
		cmp.w	#SCON_RemCreateKeys-SCON_TakeOverSys,d0
		bgt.s	NextTag

		rol.w	#1,d0
		move.w	bosc_JumpTable(pc,d0.w),d0
		jmp	bosc_JumpTable(pc,d0.w)


bosc_JumpTable:	dc.w	bosc_TakeOverSys-bosc_JumpTable
		dc.w	bosc_KillReq-bosc_JumpTable
		dc.w	bosc_CDReboot-bosc_JumpTable
		dc.w	bosc_StopInput-bosc_JumpTable
		dc.w	bosc_AddCreateKeys-bosc_JumpTable
		dc.w	bosc_RemCreateKeys-bosc_JumpTable
d473 3
a475 3
		bsr.s	InvertBOOL
		bsr	TakeOverSystem		;TakeOverSystem(a5>GameBase, d1>TRUE/FALSE)
		bra.s	NextTag
d477 15
a491 15
bosc_KillReq:	bsr.s	InvertBOOL
		exg	a5,a6
		bsr	TurnOffRequesters	;TurnOffRequesters(a6>GameBase, d1>TRUE/FALSE)
		exg	a5,a6
		bra.s	NextTag
				;SCON_CDReboot
bosc_CDReboot:	cmp.l	#1,d1
		bpl.s	1$
		eori.s	#1,d1
1$:		bsr	CDRebootOnRemove	;CDRebootOnRemove(a5>GameBase, d1>FORCEON,OFF,DEFAULT)
		bra.s	NextTag
				;SCON_StopInput
bosc_StopInput:	bsr.s	InvertBOOL
		bsr	TrashInput
		bra.s	NextTag
d494 5
a498 5
		move.l	d1,d0
		mulu.w	#lljp_SIZE,d1
		lea	ll_Port0State(a5,d1.l),a4
		addq.b	#1,lljp_NestCnt(a4)
		bne	NextTag
d500 3
a502 3
		bsr	InstallInputMap
		move.l	d0,lljp_InputHandle(a4)
		bra	NextTag
d505 9
a513 9
		move.l	d1,d0
		mulu.w	#lljp_SIZE,d1
		lea	ll_Port0State(a5,d1.l),a4
		subq.b	#1,lljp_NestCnt(a4)
		bpl	NextTag

		move.l	lljp_InputHandle(a4),d0
		bsr	UnInstallInputMap
		bra	NextTag
d519 1
a519 1
*	InvertBOOL - Invert the boolean variable.
d522 2
a523 2
*	InvertBOOL (Bool)
*		    d1
d526 2
a527 2
*	Takes the current value in d1, determines if it is TRUE, or FALSE and
*	then inverts it.
d529 1
a529 1
*	TRUE is non-zero, FALSE is zero.
d533 3
a535 3
		tst.w	d1
		seq	d1
		rts
d538 1
a538 1
		END
@


40.7
log
@Oops, InstallInputMap can fail.  Even more so now.
@
text
@d3 1
a3 1
*	$Id: SystemControl.asm,v 40.6 93/03/23 14:41:35 Jim2 Exp Locker: Jim2 $
d7 4
a10 1
*	$Log:	SystemControl.asm,v $
a199 2
*	FALSE - Reenables input.device.  Before this happens any buffered
*	    keyboard and port 0 events are cleared.
d201 2
a202 2
*	This tag nests.  A task may stop intput several times before
*	reenabling.  However, there must be a matching number of calls.
@


40.6
log
@Polished autodocs.
@
text
@d3 1
a3 1
*	$Id: SystemControl.asm,v 40.5 93/03/12 20:29:47 Jim2 Exp Locker: Jim2 $
d8 3
d262 3
a264 1
		clr.l	ll_SystemOwner(a5)	;No one owns any part of the system.
d305 1
a305 1
		bra.s	sc_Undo
d308 2
a309 2
		bsr.s	TestOwner
		bne.s	sc_Undo
d321 12
d334 1
a334 1
		bne	tagparse
d338 8
@


40.5
log
@Added the two new tags to add and remove the routines that translate
joysticks/game controllers to rawkey codes.  Also changed the
structure of the main routine to use a jump table while parsing
the tags.  Finally, altered the system ownership so it only
applies to the two important tags TakeOverSys and KillInput.
@
text
@d3 1
a3 1
*	$Id: SystemControl.asm,v 40.4 93/03/10 12:23:21 Jim2 Exp Locker: Jim2 $
d8 7
d84 2
a85 2
*	Faliure = SystemControlA (tagList)
*	d0			  a1
d216 6
a221 2
*	Failure - The tags, if any failed.  Or zero if all tags succeeded.
*	          Or -1 if all tags will fail.
@


40.4
log
@Cleaned up the results of Vertex code walkthrough.
@
text
@a0 1
*
d3 1
a3 1
*	$Id: SystemControl.asm,v 40.3 93/03/08 10:49:49 Jim2 Exp Locker: Jim2 $
d8 3
d65 3
d87 9
a95 2
*	This function can be used to selectively enable and disable various
*	features of the system.
d97 1
a97 4
*	In order to mantain system integrity, only one process many control
*	any part of the system.  This prevents the possiblity of a second
*	task 'pulling the rug out' from another process.  As a result, it is
*	possible for the first call to SystemControlA to fail.
d100 2
a101 3
*	This is a low level function that does not fit the normal Amgia
*	multitasking model.  This is assured by in this function by only
*	allowing a single process on own any part of the system.
d120 5
a124 1
*	FALSE - Reliquishes the CPU and reenables multitasking.
d149 2
d181 1
d189 18
d213 6
d220 1
a220 1
		movem.l	a5/a6,-(sp)
a225 1
		LONGVAR	ReturnValue
a229 1
		clr.l	ReturnValue_l(sp)	;A return value of zero means no error.
a230 1
		JSRLIB	Forbid			;Forbid(a6>ExecBase)
d233 1
a233 11
				;The Current task pointer is in d0.
		tst.l	ll_SystemOwner(a5)
		bne.s	SomeOneControlsSystem
		move.l	d0,ll_SystemOwner(a5)
SomeOneControlsSystem:
		move.l	ll_ExecBase(a5),a6
		JSRLIB	Permit			;Permit(a6>ExecBase)
		sub.l	ll_SystemOwner(a5),d0
		beq.s	tagparse
		moveq	#-1,d0
		bra.s	DoneSystemControlA
d238 1
a238 1
		move.l	a5,a6
d241 10
a250 1
		beq.s	donetags
d252 1
a252 1
		move.l	d0,a0
d256 21
a276 3
		bne.s	not_ownsystem
				;SCON_OwnSys.
		bsr	TakeOverSystem		;TakeOverSystem(a6>GameBase, d1>TRUE/FALSE)
d279 1
a279 3
not_ownsystem:	subq.l	#1,d0
		bne.s	not_killreq
				;SCON_KillReq
d281 1
a282 3

not_killreq:	subq.l	#1,d0
		bne.s	not_CDReboot
d284 1
a284 1
		bsr	CDRebootOnRemove	;CDRebootOnRemove(a6>GameBase, d1>FORCEON,OFF,DEFAULT)
d289 39
a327 2
		move.l	d0,ReturnValue_l(sp)
		lea	UndoTag_l(sp),a1
d329 1
a329 1
		bra.s	donetags
d331 25
a355 5
not_CDReboot:	subq.l	#1,d0
		bne.s	not_KillInput
				;SCON_StopInput
		bsr	TrashInput
		bra.s	tagparse
d357 10
a366 11
not_KillInput	bra.s	tagparse
				;Completed parseing the tag list.
donetags:	move.b	ll_NestOwn(a5),d0
		and.b	ll_NestReq(a5),d0
		bpl.s	StillControl
		moveq	#0,d0
		move.l	d0,ll_SystemOwner(a5)	;No one owns any part of the system.
StillControl:	move.l	ReturnValue_l(sp),d0
DoneSystemControlA:
		DONELOCALS sp
		movem.l	(sp)+,a5/a6
d387 1
a387 2
		movem.l	d7/a5-a6,-(sp)
		move.l	a6,a5
d391 1
a391 1
		move.l	(sp),a0
d393 2
a394 2
		move.l	a5,a6
				;d0 Points to the tag to be handled, or NULL if complete.
d398 7
a404 2
		beq.s	CompletedBackout
		move.l	(a0)+,d1		;Tag data into d1.
d406 20
a425 2
		bne.s	not_unownsystem
				;SCON_OwnSys.
d427 1
a427 1
		bsr	TakeOverSystem		;TakeOverSystem(a6>GameBase, d1>TRUE/FALSE)
d430 2
a431 5
not_unownsystem:
		subq.l	#1,d0
		bne.s	not_unkillreq
				;SCON_KillReq
		bsr.s	InvertBOOL
d433 1
a434 3

not_unkillreq:	subq.l	#1,d0
		bne.s	not_unCDReboot
d436 1
a436 1
		cmp.l	#1,d0
d438 2
a439 8
		eori.s	#1,d0
1$:		bsr	CDRebootOnRemove	;CDRebootOnRemove(a6>GameBase, d1>FORCEON,OFF,DEFAULT)
		tst.l	d0
		bne.s	NextTag

		move.l	#SCON_CDReboot,d0
		move.l	d0,ReturnValue_l(sp)
		lea	UndoTag_l(sp),a1
a440 2
not_unCDReboot:	subq.l	#1,d0
		bne.s	not_unKillInput
d442 1
a442 1
		bsr.s	InvertBOOL
d445 23
a467 6
not_unKillInput: bra.s	NextTag
				;Completed parseing the tag list.
CompletedBackout:
		move.l	(sp)+,a1
		movem.l	(sp)+,d7/a5-a6
		rts
@


40.3
log
@Corrected the register assignment in the autodoc.
@
text
@d4 1
a4 1
*	$Id: SystemControl.asm,v 40.2 93/03/02 13:23:21 Jim2 Exp Locker: Jim2 $
d9 3
d192 1
a192 2
		moveq	#0,d0
		move.l	d0,ReturnValue_l(sp)	;A return value of zero means no error.
d195 1
a195 2
		moveq	#0,d0
		move.l	d0,a1
d223 1
a223 1
		jsr	TakeOverSystem		;TakeOverSystem(a6>GameBase, d1>TRUE/FALSE)
d229 1
a229 1
		jsr	TurnOffRequesters	;TurnOffRequesters(a6>GameBase, d1>TRUE/FALSE)
d235 1
a235 1
		jsr	CDRebootOnRemove	;CDRebootOnRemove(a6>GameBase, d1>FORCEON,OFF,DEFAULT)
d242 1
a242 1
		jsr	BackOutSysCon
d299 2
a300 2
		jsr	InvertBOOL
		jsr	TakeOverSystem		;TakeOverSystem(a6>GameBase, d1>TRUE/FALSE)
d307 2
a308 2
		jsr	InvertBOOL
		jsr	TurnOffRequesters	;TurnOffRequesters(a6>GameBase, d1>TRUE/FALSE)
d317 1
a317 1
1$:		jsr	CDRebootOnRemove	;CDRebootOnRemove(a6>GameBase, d1>FORCEON,OFF,DEFAULT)
d328 2
a329 2
		jsr	InvertBOOL
		jsr	TrashInput
d356 1
a356 4
		bne.s	1$
		moveq	#1,d1
		rts
1$:		moveq	#0,d1
@


40.2
log
@Changed all references from game.library to lowlevel.library.
@
text
@d4 1
a4 1
*	$Id: SystemControl.asm,v 40.1 93/03/01 16:12:00 Jim2 Exp Locker: Jim2 $
d9 3
d70 1
a70 1
*	d0			  a2
@


40.1
log
@Added note to remind people about the nature of the beast.
@
text
@d4 1
a4 1
*	$Id: SystemControl.asm,v 40.0 93/02/11 17:33:24 Jim2 Exp Locker: Jim2 $
d9 3
d48 2
a49 2
	INCLUDE	'/game.i'
	INCLUDE	'/gamebase.i'
d59 1
a59 1
******* game.library/SystemControlA ********************************************
d175 2
a181 1
		LONGVAR	GameBase
d188 1
a188 2
		move.l	a6,GameBase_l(sp)	;Place the Game Library base on the stack.
		move.l	gm_ExecBase(a6),a6
d194 1
a194 2
		move.l	GameBase_l(sp),a6
		tst.l	gm_SystemOwner(a6)
d196 1
a196 1
		move.l	d0,gm_SystemOwner(a6)
d198 1
a198 1
		move.l	gm_ExecBase(a6),a6
d200 1
a200 2
		move.l	GameBase_l(sp),a6
		sub.l	gm_SystemOwner(a6),d0
d203 1
a203 1
		bra.w	DoneSystemControlA
d205 1
a205 1
tagparse:	move.l	gm_UtilBase(a6),a6
d208 1
a218 1
		move.l	GameBase_l(sp),a6
a224 1
		move.l	GameBase_l(sp),a6
a230 1
		move.l	GameBase_l(sp),a6
a243 1
		move.l	GameBase_l(sp),a6
d249 2
a250 3
donetags:	move.l	GameBase_l(sp),a6
		move.b	gm_NestOwn(a6),d0
		and.b	gm_NestReq(a6),d0
d253 1
a253 1
		move.l	d0,gm_SystemOwner(a6)	;No one owns any part of the system.
d257 1
d278 2
a279 1
		movem.l	d7/a6,-(sp)
a280 1
		move.l	gm_UtilBase(a6),a6
d282 2
a283 1
NextTag		move.l	(sp),a0
d285 1
a295 1
		move.l	GameBase_l(sp),a6
a303 1
		move.l	GameBase_l(sp),a6
d313 1
a313 2
1$:		move.l	GameBase_l(sp),a6
		jsr	CDRebootOnRemove	;CDRebootOnRemove(a6>GameBase, d1>FORCEON,OFF,DEFAULT)
a324 1
		move.l	GameBase_l(sp),a6
d326 2
a327 2
		bra.w	NextTag
not_unKillInput: bra.w	NextTag
d331 1
a331 1
		movem.l	(sp)+,d7/a6
@


40.0
log
@Change to use the new single include file.
@
text
@d4 1
a4 1
*	$Id: SystemControl.asm,v 39.6 93/01/19 15:44:21 Jim2 Exp Locker: Jim2 $
d9 3
d81 5
d92 1
a92 1
*	TRUE - Takes over the CPU to ensure that an program gets every ounce
d131 1
a131 1
*	    Use this only if the program cannot deal with error condition.
@


39.6
log
@Added SCON_StopInput.
@
text
@d4 1
a4 1
*	$Id: SystemControl.asm,v 39.5 93/01/18 13:32:26 Jim2 Exp Locker: Jim2 $
d9 3
d42 1
a42 1
	INCLUDE	'/systemcontrol.i'
@


39.5
log
@Cleaned comments.  Changed tag to SCON_TakeOverSys from SCON_OwnSys.
@
text
@d4 1
a4 1
*	$Id: SystemControl.asm,v 39.4 93/01/13 13:43:28 Jim2 Exp Locker: Jim2 $
d9 3
d47 1
d148 7
d191 1
a191 1
		bra.s	DoneSystemControlA
d231 8
a238 1
not_CDReboot:	bra.s	tagparse
d312 9
a320 1
not_unCDReboot:	bra.s	NextTag
@


39.4
log
@Added the tag SCON_CDReboot to the function descriptin.
@
text
@d4 1
a4 1
*	$Id: SystemControl.asm,v 39.3 93/01/07 14:22:44 Jim2 Exp Locker: Jim2 $
d9 3
d54 1
a54 1
*	D0			  A2
d64 1
a64 1
*	of the system features.
d72 2
a73 2
*	tagList - pointer to an array of tags listing the features of the system
*		  to be enabled/disabled.
d76 12
a87 12
*	SCON_OwnSys:
*	TRUE - Takes over the CPU to ensure that your application gets every
*	    ounce of CPU time (with the exception of crucial interrupts).
*	    When in this mode, the CPU will belong completely to you.  Task
*	    switching will be disabled and your task will get the full
*	    attention of the CPU.  This means that if you make calls to the
*	    OS that involved multitasking in some way, don't expect anything
*	    to happen.  Other tasks will not run until you again use this tag
*	    with FALSE.  However, if you decide you want to Wait() on a
*	    signal, multitasking will automatically be turn back on until
*	    your signal is recieved.  Once recieved, multitasking will again
*	    be disabled and the CPU will be exclusively yours.
d91 2
a92 2
*	TRUE - Disables system requesters.  These are the reasons when you
*	    would NOT want turn off system requesters:
d94 19
a112 24
*	    -	You don't want them turned off.
*	    -	You are not doing anything that would cause a system
*		requester to appear.
*	    -	The only thing that could cause a requester to appear is the
*		lack of a CD in the drive and you have "Reset on disk
*		removal" FORCED ON, therefore a requester can't appear.
*	    -	The only disk I/O is via a CD with "Reset on disk removal"
*		FORCED ON and/or nonvolatile.library.
*
*	    When you would not want to disable requesters.
*	    GAME TITLES:
*	    You do NOT NEED to disable requesters if: You are not calling any
*	    DOS functions after your game has loaded; or "Reset on removal"
*	    of the CD is FORCED ON; and nonvolatile.library is used for
*	    loading and saving user data.
*
*	    This fits the above case since; you should never want a system
*	    requester to appear thus the first does not apply.  After loading
*	    either DOS functions are not accessed meeting the second reason,
*	    or your application is accessing the CD and has "Reset on disk
*	    removed" FORCED ON meeting the third reason.  The game accesses
*	    high scores, game position, etc... through the
*	    nonvolatile.library  meeting the final reason.
*	FALSE - Enables requesters for your process.
d115 5
a119 5
*	CDReboot_On - Ejecting the CD will cause a reboot of the system.  Use
*	    this only if the title cannot deal with error condition.
*	CDReboot_Off - Ejecting the CD will not cause a reboot of the system.
*	    Use this if you want to be able to insert CDs while your title
*	    is running
d121 4
a124 4
*	    system.  This should be used upon exit, if your title has
*	    utilized this tag to change the reboot behaviour.  For the game
*	    machine this value is synonomous with CDReboot_On.  For Amiga
*	    computers this value is synonomous with CDReboot_Off.
d127 5
a131 5
*	    platform.  If a title requires a specific behaviour it must
*	    use this function to set this behaviour.
*	    If, for example, a CD audio mixer would use this tag with the
*	    data CDReboot_Off.  This will allow the changing of audio CDs
*	    on the game machine as well as Amiga computers.
d136 2
a137 2
*	    It is hoped that no title will require CDReboot_On.  If all
*	    titles check for error condition and recover gracefully such a
d140 3
a142 2
*	    run from Amiga will not reset.  This increases the market for a
*	    title to include both types of platforms.
a162 1

d168 1
a168 1
						;The Current task pointer is in d0.
a172 1

d185 1
a185 1
						;Points to the tag to be handled, or NULL if complete.
d192 1
a192 1
		sub.l	#SCON_OwnSys,d0		;Lowest numbered tag is STAG_OWNSYS.
d194 1
a194 1
						;SCON_OwnSys.
d201 1
a201 1
						;SCON_KillReq
d205 1
d208 1
a208 1
						;SCON_CDReboot
d213 1
d219 1
d221 1
a221 1
						;Completed parseing the tag list.
d227 1
a227 1
		move.l	d0,gm_SystemOwner(a6)
d233 1
a233 1
******l BackOutSysCon ********************************************************
d244 3
a246 3
*	Rewalks the tag list passed to SystemControlA until the failed tag is
*	encountered.  Before processing each tag the data associated with that
*	tag is inverted.
d257 1
a257 1
						;Points to the tag to be handled, or NULL if complete.
d263 1
a263 1
		sub.l	#SCON_OwnSys,d0		;Lowest numbered tag is STAG_OWNSYS.
d265 1
a265 1
						;SCON_OwnSys.
d274 1
a274 1
						;SCON_KillReq
d279 1
d282 1
a282 1
						;SCON_CDReboot
d290 1
d295 1
a295 1
						;Completed parseing the tag list.
d301 1
a301 1
******l InvertBOOL ***********************************************************
a314 1
*
@


39.3
log
@Cleaned up comments and minimized the specific include files.
@
text
@d4 1
a4 1
*	$Id: SystemControl.asm,v 39.2 93/01/05 12:08:04 Jim2 Exp Locker: Jim2 $
d9 3
d115 29
@


39.2
log
@Documentation correction for SystemControlA.
@
text
@d4 1
a4 1
*	$Id: SystemControl.asm,v 39.1 92/12/14 14:32:59 Jim2 Exp Locker: Jim2 $
d9 3
d21 1
a21 1
*	(C) Copyright 1992 Commodore-Amiga, Inc.
d25 3
a27 10
*
* System include files...
*
	INCLUDE 'exec/types.i'
	INCLUDE 'exec/nodes.i'
	INCLUDE	'exec/lists.i'
	INCLUDE	'exec/memory.i'
	INCLUDE 'exec/resident.i'
	INCLUDE	'exec/execbase.i'
	INCLUDE	'exec/libraries.i'
a28 3
*
* Useful macros
*
a29 1

d31 1
a38 7
*
*******************************************************************************
*
* The library structure ...
*

	INCLUDE	'/gamebase.i'
d134 1
a134 1
		CALLSYS	Forbid			;Forbid(a6>ExecBase)
d137 1
a137 1
		CALLSYS	FindTask		;FindTask (a1>Null:Current Task, a6>ExecBase)
d146 1
a146 1
		CALLSYS	Permit			;Permit(a6>ExecBase)
d155 1
a155 1
		CALLSYS	NextTagItem		;NextTagItem(a6>UtilBase, a0>**TagItem)
d224 1
a224 1
		CALLSYS	NextTagItem		;NextTagItem(a6>UtilBase, a0>**TagItem)
@


39.1
log
@Tested the code for backing out and for clearing the process
that can work with the system.
@
text
@d4 1
a4 1
*	$Id: SystemControl.asm,v 39.0 92/12/11 14:03:18 Jim2 Exp Locker: Jim2 $
d9 4
d74 4
a77 2
*	This call takes a tag list and some of the features can be duplicated
*	by other calls in the Game Library.
@


39.0
log
@Initial Release.
@
text
@d4 1
a4 1
*	$Id: $
d8 3
a10 1
*	$Log: $
d13 1
d190 1
a190 1
		bne.s	tagparse
d202 2
a203 1
		move.l	d0,gm_SystemOwner
d230 3
a232 2
		lea	TagState_l(sp),a0
NextTag		CALLSYS	NextTagItem		;NextTagItem(a6>UtilBase, a0>**TagItem)
d271 1
@
