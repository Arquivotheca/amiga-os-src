head     40.6;
branch   ;
access   ;
symbols  V40_35:40.6 rel40_34:40.5 rel40_33:40.5 rel40_32:40.5 rel40_29:40.5 rel40_28:40.5 rel40_27:40.4 rel40_26:40.4 rel40_25:40.4 rel40_24:40.4 rel40_23:40.4 rel40_22:40.4 rel40_21:40.4 rel40_20:40.4 rel40_19:40.4 rel40_18:40.4 rel40_17:40.4 rel40_16:40.4 rel40_15:40.4 rel40_14:40.4 rel40_13:40.2 rel40_12:40.2 rel40_11:40.2 rel40_4:40.0 rel40_3:40.0 rel40_2:39.5 rel40_1:39.5 rel39_7:39.5 rel39_6:39.3 rel39_5:39.2 rel39_4:39.1 rel39_3:39.0;
locks    ; strict;
comment  @* @;


40.6
date     93.07.30.16.06.11;  author vertex;  state Exp;
branches ;
next     40.5;

40.5
date     93.05.05.09.47.19;  author gregm;  state Exp;
branches ;
next     40.4;

40.4
date     93.03.23.14.40.49;  author Jim2;  state Exp;
branches ;
next     40.3;

40.3
date     93.03.22.12.04.11;  author Jim2;  state Exp;
branches ;
next     40.2;

40.2
date     93.03.10.12.22.48;  author Jim2;  state Exp;
branches ;
next     40.1;

40.1
date     93.03.02.13.25.24;  author Jim2;  state Exp;
branches ;
next     40.0;

40.0
date     93.02.19.16.50.33;  author Jim2;  state Exp;
branches ;
next     39.5;

39.5
date     93.01.18.13.27.48;  author Jim2;  state Exp;
branches ;
next     39.4;

39.4
date     93.01.15.13.51.17;  author Jim2;  state Exp;
branches ;
next     39.3;

39.3
date     93.01.13.13.41.02;  author Jim2;  state Exp;
branches ;
next     39.2;

39.2
date     93.01.07.14.21.10;  author Jim2;  state Exp;
branches ;
next     39.1;

39.1
date     93.01.05.12.04.50;  author Jim2;  state Exp;
branches ;
next     39.0;

39.0
date     92.12.17.18.06.00;  author Jim2;  state Exp;
branches ;
next     ;


desc
@CIA timer functions.  Also the EClock based interval timer.
@


40.6
log
@Autodoc and include cleanup
@
text
@******************************************************************************
*
*       $Id: timer.asm,v 40.5 93/05/05 09:47:19 gregm Exp $
*
******************************************************************************
*
*       $Log:	timer.asm,v $
* Revision 40.5  93/05/05  09:47:19  gregm
* Jim added comments, but left this checked out.  No code changes.
*
* Revision 40.4  93/03/23  14:40:49  Jim2
* Polished autodocs.
*
* Revision 40.3  93/03/22  12:04:11  Jim2
* Forgot to save before releasing 40.12.
*
* Seperated out the 020 ElapsedTime code.  Tested to see if SetTimeInterval
* would benefit from 020 code.  The answer is no.  While examining
* the 020 ElapsedTime code I came up with a slight improvement.
* The correction on the shift (Revision 40.1) was incorrect.  Rather
* it was bringing in the least significant byte of the remainder.
*
* Revision 40.2  93/03/10  12:22:48  Jim2
* Cleaned up the results of Vertex code walkthrough.
*
* Revision 40.1  93/03/02  13:25:24  Jim2
* Changed all references from game.library to lowlevel.library.
* Corrected error that prevented single shot timers from working.
* The final shift on the time (non 020) needs to be long
* word to get the full range for the timer.
*
* Revision 40.0  93/02/19  16:50:33  Jim2
* Corrected autodoc format for SEE ALSO.
*
* Revision 39.5  93/01/18  13:27:48  Jim2
* Cleaned up comments.
*
* Revision 39.4  93/01/15  13:51:17  Jim2
* Removed the parameter for setting the time interval from AddTimeInt.
* Deleted the functions SetTimeInterval and ConvertToFracTime.
* Added two parameters (TimeInterval and Continuous) to StartTimerInt.
* When an interrupt is added it is added stopped, with any
* pending interrupt cleared.
*
* Revision 39.3  93/01/13  13:41:02  Jim2
* Added ConvertToFracTime and corrected some comments
*
* Revision 39.2  93/01/07  14:21:10  Jim2
* Added 020, or better, code with conditional.  Did not test
* the new code.
*
* Revision 39.1  93/01/05  12:04:50  Jim2
* Made CIAARESOURCE externally visible for keyboard work.
* Corrected the size used when retrieving the timer parameter
* for RemICRVector.
*
* Revision 39.0  92/12/17  18:06:00  Jim2
* Initial release, was tested.
*
*
*       (C) Copyright 1992,1993 Commodore-Amiga, Inc.
*           All Rights Reserved
*
******************************************************************************

        INCLUDE 'exec/macros.i'
        INCLUDE 'exec/types.i'
        INCLUDE 'exec/nodes.i'
        INCLUDE 'exec/lists.i'
        INCLUDE 'exec/memory.i'
        INCLUDE 'exec/io.i'

        INCLUDE 'resources/cia.i'
        INCLUDE 'hardware/cia.i'

        INCLUDE '/macros.i'
        INCLUDE '/lowlevelbase.i'

                XDEF    AddTimerInt
                XDEF    RemTimerInt
                XDEF    StartTimerInt
                XDEF    StopTimerInt
                XDEF    ElapsedTime
                XDEF    CIAARESOURCE

                XREF    _ciaa
                XREF    _ciab

******* lowlevel.library/AddTimerInt *****************************************
*
*   NAME
*	AddTimerInt -- adds an interrupt that is executed at regular
*		       intervals. (V40)
*
*   SYNOPSIS
*	intHandle = AddTimerInt(intRoutine, intData);
*	D0                      A0          A1
*
*	APTR AddTimerInt(APTR, APTR);
*
*   FUNCTION
*	Calling this routine causes the system to allocate a CIA timer
*	and set up 'intRoutine' to service any interrupts caused by the timer.
*	Although the timer is allocated it is neither running, nor enabled.
*	StartIntTimer() must be called to establish the time interval and
*	start the timer.
*
*	The routine is called from within an interrupt, so normal
*	restrictions apply. The routine must preserve the following
*	registers: A2, A3, A4, A7, D2-D7. Other registers are
*	scratch, except for D0, which MUST BE SET TO 0 upon
*	exit. On entry to the routine, A1 holds 'intData' and A5
*	holds 'intRoutine'.
*
*	Only a single CIA timer will be allocated by this routine. So this
*	routine may only be called once without an intervening call to
*	RemTimerInt().
*
*	The CIA timer used by this routine is not guaranteed to always be
*	the same. This routine utilizes the CIA resource and uses an
*	unallocated CIA timer.
*
*	If your program is to exit without reboot, you MUST match all
*	calls to this function with calls to RemTimerInt() before exiting.
*
*	Even if you only use the function once in your program; checking
*	the return value will make your program more tolerant for
*	mulititasking on the Amiga computer platforms.
*
*   INPUTS
*	intRoutine - the routine to invoke upon timer interrupts. This routine
*		     should be as short as possible to minimize its effect on
*		     overall system performance.
*	intData - data passed to the routine in register A1. If more than one
*		  long word of data is required this should be a pointer to
*		  a structure that contains the required data.
*
*   RESULT
*	intHandle - a handle used to manipulate the interrupt, or NULL
*		    if it was not possible to attach the routine.
*
*   SEE ALSO
*	RemTimerInt(), StopTimerInt(), StartTimerInt()
*
******************************************************************************
AddTimerInt
                movem.l a0-a1/a4-a6,-(sp)       ;Store the parameters and some scratch registers.
                move.l  a6,a5
                move.l  ll_ExecBase(a6),a6
                JSRLIB  Forbid                  ;Only one interval timer is allowed.

                                ;We don't want to get multiple invokations of
                                ;lowlevel.library both thinking they can change it.

                tst.l   ll_CIATimer+llct_TimerInt+IS_CODE(a5)
                beq.s   2$
                                ;The interrupt is currently in use.
                JSRLIB  Permit
                movem.l (sp)+,a0-a1/a4-a6
                CLEAR   d0                      ;Set up the return value.
                rts

2$              movem.l (sp)+,a0-a1             ;Fortunately, the way movem works this is OK.
                lea     ll_CIATimer(a5),a4      ;Get the pointer to the CIA timer data
                                                ;structure and initialize it.
                move.l  a0,llct_TimerInt+IS_CODE(a4)
                move.l  a1,llct_TimerInt+IS_DATA(a4)
                clr.b   llct_TimerInt+LN_PRI(a4)
                move.b  #NT_INTERRUPT,llct_TimerInt+LN_TYPE(a4)
                move.l  LN_NAME(a5),llct_TimerInt+LN_NAME(a4)
                JSRLIB  Permit                  ;It is now safe to reinitialize multitasking.
                                ;
                                ;The only mechanism for finding a free timer
                                ;interrupt is to add the interrupts.  However,
                                ;if the interrupts are enabled the interrupt code
                                ;could be called before everything is completely
                                ;set up.  In order to prevent this from happening
                                ;disable the interrupts.
                                ;
                JSRLIB  Disable
                lea     CIAARESOURCE(pc),a1
                                ;Try to allocate a timer in CIAA.
                jsr     FindFreeTimer           ;a6 points to the CIAA resource.
                bpl.s   Opened                  ;The last move determines whether a timer was found.
                move.l  ll_ExecBase(a5),a6
                lea     CIABRESOURCE(pc),a1
                                ;Try to allocate a timer in CIAB.
                jsr     FindFreeTimer           ;a6 points to the CIAB resource.
                bpl.s   Opened

                                ;The last move determines whether a timer was found.
                                ;No timer was found, so clear the marker about a
                                ;an allocated interrupt; restore the
                                ;stack and address registers; and
                                ;return an NULL.

                moveq.l #0,d0
                move.l  d0,llct_TimerInt+IS_CODE(a4)
                move.l  ll_ExecBase(a5),a6
                bra.s   ExitTryCIA
Opened:                         ;Have allocated a CIA timer.
                move.l  a6,llct_Resource(a4)
                move.w  d0,llct_WhichTimer(a4)

                                ;Determine which timer is to be started and set d0 to
                                ;the offset to the register and d1 to the data to be
                                ;written.

                bne.s   TimerB
                move.l  #ciacra,d1
                move.l  #(CIAICRF_TA<<16)|CIACRAF_TODIN|CIACRAF_PBON|CIACRAF_RUNMODE|CIACRAF_OUTMODE|CIACRAF_SPMODE,d0
                move.l  #_ciaa,a1
                bra.s   Doit
TimerB:         move.l  #ciacrb,d1
                move.l  #(CIAICRF_TB<<16)|CIACRBF_ALARM|CIACRBF_PBON|CIACRBF_RUNMODE|CIACRBF_OUTMODE,d0
                move.l  #_ciab,a1
Doit            and.b   d0,0(a1,d1)             ;Touch the register in an atomic fashion.
                swap    d0
                JSRLIB  SetICR                  ;Clear any pending interrupt.
                move.l  ll_ExecBase(a5),a6
                move.l  a4,d0
ExitTryCIA:     JSRLIB  Enable                  ;Allow interrupts to happen
                movem.l (sp)+,a4-a6
                rts

******* lowlevel.library/StopTimerInt ****************************************
*
*   NAME
*	StopTimerInt -- stop the timer associated with the timer interrupt.
*			(V40)
*
*   SYNOPSIS
*	StopTimerInt(intHandle);
*	             A1
*
*	VOID StopTimerInt(APTR);
*
*   FUNCTION
*	Stops the timer associated with the timer interrupt handle passed.
*	This is used to stop a continuous timer started by
*	StartTimerInt().
*
*   INPUTS
*	intHandle - handle obtained from AddTimerInt().
*
*   SEE ALSO
*	AddTimerInt(), RemTimerInt(), StartTimerInt()
*
******************************************************************************
StopTimerInt
                tst.w   llct_WhichTimer(a1)

                                ;Determine which timer is to be started and set d0 to
                                ;the offset to the register and d1 to the data to be
                                ;written.

                bne.s   stopTimerB
                move.l  #ciacra,d1
                move.w  #CIACRAF_TODIN|CIACRAF_PBON|CIACRAF_RUNMODE|CIACRAF_OUTMODE|CIACRAF_SPMODE,d0
                move.l  #_ciaa,a1
                bra.s   stop
stopTimerB:     move.l  #ciacrb,d1
                move.w  #CIACRBF_ALARM|CIACRBF_PBON|CIACRBF_RUNMODE|CIACRBF_OUTMODE,d0
                move.l  #_ciab,a1
stop:           and.b   d0,0(a1,d1)             ;Touch the register in an atomic fashion.
                rts

******* lowlevel.library/StartTimerInt ***************************************
*
*   NAME
*	StartTimerInt -- start the timer associated with the timer interrupt.
*			 (V40)
*
*   SYNOPSIS
*	StartTimerInt(intHandle, timeInterval, continuous);
*	              A1         D0            D1
*
*	VOID StartTimerInt(APTR, ULONG, BOOL);
*
*   FUNCTION
*	This routine starts a stopped timer that is assocatied with a
*	timer interrupt created by AddTimerInt().
*
*   INPUTS
*	intHandle - handle obtained from AddTimerInt().
*	timeInterval - number of micoseconds between interrupts. The
*	               maximum value allowed is 90,000. If higher values
*	               are passed there will be unexpected results.
*	continuous - FALSE for a one shot interrupt. TRUE for multiple
*	             interrupts.
*
*   SEE ALSO
*	AddTimerInt(), RemTimerInt(), StopTimerInt()
*
******************************************************************************
StartTimerInt
                movem.l d1-d3,-(sp)             ;Save the handle.
                tst.w   llct_WhichTimer(a1)

                                ;Determine which timer is to be started and set d2 to
                                ;the offset to the register, d3 to the data to be
                                ;written and a1 to the base register for the time
                                ;interval.

                bne.s   startTimerB
                move.l  #ciacra,d2
                move.l  #ciatalo,a1
                move.l  #(CIACRAF_START<<16)|CIACRAF_TODIN|CIACRAF_PBON|CIACRAF_OUTMODE|CIACRAF_SPMODE,d3
                move.l  #_ciaa,a0
                bra.s   start
startTimerB:    move.l  #ciacrb,d2
                move.l  #ciatblo,a1
                move.l  #(CIACRBF_START<<16)|CIACRBF_ALARM|CIACRBF_PBON|CIACRBF_OUTMODE,d3
                move.l  #_ciab,a0
start:          and.b   d3,0(a0,d2)             ;Stop any timer
                tst.w   d1
                bne.s   ConMode
                or.b    #CIACRAF_RUNMODE,0(a0,d2)
ConMode:        move.l  ll_EClockConversion(a6),d1
                lsr.l   #1,d0                   ;Ignore the least significant bit.
                lsr.l   #4,d1                   ;Ignore the four least significant bits of the EClocks/second.
                                ;
                                ;All of this ignoring results in a sixteen bit by
                                ;sixteen bit multiply.  Since only the upper order
                                ;sixteen bits of the final answer are useful this
                                ;ignoring is meanless.
                                ;
                mulu.w  d1,d0
                divu.w  #31250,d0               ;Only want the high order sixteen bits.
                                ;
                                ;The preceeding four lines can be replaced by
                                ;the following two lines:
                                ;mulu.l d1,d0
                                ;divu.l #100000,d0
                                ;however this will acutally execute slower so
                                ;there really is no need for 020 > specific
                                ;code at this time.
                                ;
                bne.s   1$
                addq.b  #1,d0                   ;Can't have an interval of zero, must be at least one.
1$              add.l   a0,a1
                move.b  d0,(a1)                 ;Write the low byte.
                lsr.w   #8,d0                   ;Get the high byte in a position to be written.
                move.b  d0,ciatbhi-ciatblo(a1)  ;Write the high byte.
                tst.w   2(sp)
                beq.s   SingleShot
                swap    d3
                or.b    d3,0(a0,d2)             ;Touch the register in an atomic fashion.
SingleShot:     movem.l (sp)+,d1-d3
                rts

******* lowlevel.library/RemTimerInt *****************************************
*
*   NAME
*	RemTimerInt -- remove a previously installed timer interrupt. (V40)
*
*   SYNOPSIS
*	RemTimerInt(intHandle);
*	            A1
*
*	VOID RemTimerInt(APTR);
*
*   FUNCTION
*	Removes a timer interrupt routine previously installed with
*	AddTimerInt.
*
*   INPUTS
*	intHandle - handle obtained from AddTimerInt(). This may be NULL,
*		    in which case this function does nothing.
*
*   SEE ALSO
*	AddTimerInt(), StopTimerInt(), StartTimerInt()
*
******************************************************************************
RemTimerInt
                move.l  a6,-(sp)                ;Save the parameter and scratch registers.
                move.l  a1,-(sp)                ;Check for NULL.
                beq.s   rti_Error

                move.w  llct_WhichTimer(a1),d0  ;Get the parameters for RemICRVector.
                move.l  llct_Resource(a1),a6
                JSRLIB  RemICRVector
                movem.l (sp)+,a1                ;Restore the registers.
                clr.l   IS_CODE(a1)             ;Clear the marker for the allocated Timer Interrupt.
                move.l  (sp)+,a6
                rts

rti_Error       movem.l (sp)+,a1/a6
                rts

*****l* a/timer.asm/FindFreeTimer ********************************************
*  NAME
*	FindTimerTimer - Trys to own a CIA timer.
*
*  SYNOPSIS
*	Failure = FindTimerTimer(ExecBase, resName, Interrupt, CIAResource, TimerAlloc)
*	NFlag                    a6        a1       a4         a6           d0
*
*  FUNCTION
*	Opens the indicated CIA resource.  Then attempts to install the
*	interrupt routine for the A timer.  If it is unsuccessful then
*	the B timer is tried.
*
*  INPUTS
*	ExecBase - Pointer to ExecBase.
*	resName - Name of CIA resource to be opened.
*	Interrupt - Pointer to the interrupt structure to be added.
*
*  RESULT
*	Failure - Set if no timer was owned.
*	CIAResource - Points to the opened resource.
*	TimerAlloc - Identifies which timer was actually owned.
*
******************************************************************************
FindFreeTimer:
                JSRLIB  OpenResource
                move.l  d0,a6                   ;d0 is the return from OpenResource.
                move.l  a4,a1                   ;Ready the interrupt pointer.
                move.w  #CIAICRB_TA,d0          ;Other parameter is the timer.
                move.w  d0,-(sp)                ;Remember which timer is being tried.
                JSRLIB  AddICRVector
                tst.l   d0
                beq.s   OK
                                ;Could not allocate timer A, try timer B.
                move.l  a4,a1                   ;Ready the interrupt pointer.
                move.w  #CIAICRB_TB,d0          ;Other parmeter is the timer.
                move.w  d0,(sp)                 ;Remember which timer is being tried.
                                                ;Not pushed, previous value was never popped.
                JSRLIB  AddICRVector
                tst.l   d0
                beq.s   OK
                                ;Could not allocate timer B - Failure.
                move.w  #-1,(sp)                ;The word at the pointer indicates which timer, well, this is no timer.
OK:             move.w  (sp)+,d0                ;Return the allocated timer in d0.
                                                ;Set the N flag to indicate success/failure.
                rts

******* lowlevel.library/ElapsedTime *****************************************
*
*   NAME
*	ElapsedTime -- returns the time elapsed since it was last called. (V40)
*
*   SYNOPSIS
*	fractionalSeconds = ElapsedTime(context);
*	D0                              A0
*
*	ULONG ElapsedTime(struct EClockVal *);
*
*   FUNCTION
*	This function utilizes the timer.device/ReadEClock() function to get
*	an accurate elapsed time value. Since the context needs to be
*	established the first call to this routine will return a nonsense
*	value.
*
*	The return value for this function only allows for sixteen bits
*	worth for the integer number of seconds and sixteen bits for the
*	factional number of seconds.
*
*	With sixteen bits worth of integer seconds this function can be
*	used to timer an interval up to about 16 hours. If the actual time
*	interval is larger this function will return this maximum value.
*
*	The sixteen bits for fractional seconds gives a resolution of
*	approximately 20 microseconds. However, it is not recomended
*	to expect this function to be accurate for a time interval of
*	less than 200 microseconds.
*
*   INPUTS
*	context - pointer to an EClockVal structure. The first time you
*		  call this function, you should initialize the structure
*		  to 0s. You should then reuse the same structure for
*		  subsequent calls to this function, as this is how the
*		  elapsed time is calculated.
*
*   RESULT
*	fractionalSeconds - The elapsed time as a fixed point 32-bit
*	                    number with the point fixed in the middle.
*	                    That is, the upper order sixteen bits represent
*	                    the number of seconds elapsed. The low order
*	                    sixteen bit represent the fractional number of
*	                    seconds elapsed. This value is limited to about
*	                    sixteen hours. Although this value is precise
*	                    to nearly 20 microseconds it is only accurate to
*	                    within 200 microseconds.
*
*   WARNING
*	The first call to this function will return a non-sense value. Only
*	rely on its result starting with the second call.
*
*   SEE ALSO
*	timer.device/ReadEClock()
*
******************************************************************************
        OPT     P=68020
ElapsedTime
                movem.l d2-d3/a6,-(sp)          ;Need a few registers.
                move.l  4(a0),-(sp)
                move.l  (a0),-(sp)              ;Copy the last EClock value to the stack.
                move.l  ll_TimerDevice(a6),a6
                JSRLIB  ReadEClock
                movem.l (a0)+,d1/d2             ;Get new EClock value in d1:d2.
                sub.l   4(sp),d2                ;Subtract low order EClock long word.
                move.l  (sp)+,d3                ;Get old EClock value in d3.
                addq    #4,sp                   ;Clear old EClock value from stack.
                subx.l  d3,d1                   ;Subtract high order EClock long word including borrow.
                bpl.s   2$

                neg.l   d2
                negx.l  d1
2$:             swap    d1                      ;Multiply by 2^16.
                tst.w   d1
                bne.s   et_Overflow

                swap    d2
                move.w  d2,d1
                clr.w   d2
                divu.l  d0,d1:d2                ;Divide 64bit/32bit get 32bit Rem:32bit Quo
                bvs.s   et_Overflow
                move.l  d2,d0

        OPT     P=68000

et_Exit         movem.l (sp)+,d2-d3/a6          ;Restore scratch registers.
                rts

et_Overflow:    moveq   #-1,d0
                bra.s   et_Exit


                XDEF    ElapsedTime000

*
*
* NOTE to self:  This code assume the E Clocks per second is 20 bit number.
*	         If this ever changes the code needs to be rewritten.
ElapsedTime000
                movem.l d2-d3/a6,-(sp)          ;Need a few registers.
                move.l  4(a0),-(sp)
                move.l  (a0),-(sp)              ;Copy the last EClock value to the stack.
                move.l  ll_TimerDevice(a6),a6
                JSRLIB  ReadEClock
                movem.l (a0)+,d1/d2             ;Get new EClock value in d1:d2.
                sub.l   4(sp),d2                ;Subtract low order EClock long word.
                move.l  (sp)+,d3                ;Get old EClock value in d3.
                addq    #4,sp                   ;Clear old EClock value from stack.
                subx.l  d3,d1                   ;Subtract high order EClock long word including borrow.
                bpl.s   1$

                neg.l   d2
                negx.l  d1
1$:             cmp.l   #$F,d1
                bgt.s   et_Overflow
                                ;vanilla 68000 code can only do 32bit/16bit.
                                ;Tick/sec is twenty bits so shift everyone over four.
                lsr.l   #4,d0
                and.w   #$000F,d1
                and.w   #$FFF0,d2
                or.w    d1,d2
                ror.l   #4,d2
                divu.w  d0,d2
                bvs.s   et_Overflow
                move.l  d2,d1
                swap    d2
                clr.w   d1
                divu.w  d0,d1
                move.w  d1,d2

                move.l  d2,d0
                movem.l (sp)+,d2-d3/a6          ;Restore scratch registers.
                rts



CIAARESOURCE    CIAANAME
CIABRESOURCE    CIABNAME
                end
@


40.5
log
@Jim added comments, but left this checked out.  No code changes.
@
text
@d3 1
a3 1
*       $Id: Timer.asm,v 40.4 93/03/23 14:40:49 Jim2 Exp Locker: Jim2 $
d7 4
a10 1
*       $Log:   Timer.asm,v $
a89 8
*  NAME
*       AddTimerInt - Adds an interrupt that is executed at regular intervals
*
*  SYNOPSIS
*       TimerIntHandle = AddTimerInt(IntRoutine, IntData)
*       d0                           a0          a1
*
*       APTR AddTimerInt(APTR, APTR)
d91 3
a93 36
*  FUNCTION
*       Calling this routine causes the system to allocate a CIA timer
*       and set up IntRoutine to service any interrupts caused by the timer.
*       Although the timer is allocated it is neither running, nor enabled.
*       StartIntTimer() must be called to establish the time interval and
*       start the timer.
*
*       When the interrupts occur the routine pointed to by IntRoutine is
*       called.  As with any other assembly routines d0, d1, a0 and a1 can
*       be considered scratch, all other registers must have their values
*       preserved.  However, upon exit d0 MUST be cleared.  When the
*       interrupt routine is invoked a1 will contain the value passed to
*       this routine as IntData.
*
*       Only a single CIA timer will be allocated by this routine.  So this
*       routine may only be called once without an intervening call to
*       RemTimerInt().
*
*       The CIA timer used by this routine is not guaranteed to always be
*       the same.  This routine utilizes the CIA resource and uses an
*       unallocated CIA timer.
*
*  NOTE
*       If your program is to exit without reboot, you MUST match all
*       calls to this function with calls to RemTimerInt() before exiting.
*
*       Even if you only use the function once in your program; checking
*       the return value will make your program more tolerant for
*       mulititasking on the Amiga computer platforms.
*
*       An Exec Interrupt structure is created when adding the interupt.
*       All of the register conventions of interrupt server are observed
*       when invoking IntRoutine.  This means two additional scratch
*       registers are available; a5 (which will contain the address of
*       IntRoutine) and a6.  The priority used (not that it matters since
*       only one routine is possible) is zero.
d95 46
a140 7
*  INPUTS
*       IntRoutine - Pointer to the interrupt routine invoked every
*                    TimeInterval
*       IntData - Data passed to the interrupt routine in register a1.
*                 If more than one long word of data is required this
*                 should be a pointer to structure that contains the
*                 required data.
d142 2
a143 4
*  RESULT
*       TimerIntHandle - Pointer to the handle used in manipulating the
*                        timer interrupt.  NULL if it was not possible
*                        create the interrupt.
a144 2
*  SEE ALSO:
*       RemTimerInt(), StopTimerInt(), StartTimerInt()
a226 6
*  NAME
*       StopTimerInt - Stop the timer associated with the timer interrupt.
*
*  SYNOPSIS
*       StopTimerInt(TimerIntHandle)
*                    a1
d228 3
a230 1
*       VOID StopTimerInt(APTR)
d232 13
a244 8
*  FUNCTION
*       Calling this routine causes the system stop the timer associated
*       with the timer interrupt handle passed.
*
*  INPUTS
*       TimerIntHandle - Pointer to the handle returned from AddTimerInt().
*                        This must not be NULL or serious problems will
*                        occur.
d246 2
a247 2
*  RESULT
*       NONE
a248 2
*  SEE ALSO:
*       AddTimerInt(), RemTimerInt(), StartTimerInt()
a268 8
*  NAME
*       StartTimerInt - Start the timer associated with the timer interrupt.
*
*  SYNOPSIS
*       StartTimerInt(TimerIntHandle, TimeInterval, Continuous)
*                     a1              d0            d1
*
*       VOID StartTimerInt(APTR, ULONG, BOOL)
d270 3
a272 4
*  FUNCTION
*       This routine restarts a stopped timer that is assocatied with a
*       timer interrupt created by AddTimerInt().  Before the timer is
*       started the time interval is reset.
d274 17
a290 9
*  INPUTS
*       TimerIntHandle - Pointer to the handle returned from AddTimerInt().
*                        This must not be NULL or serious problems will
*                        occur.
*       TimeInterval - Number of micoseconds between interrupts.  The
*                      maximum value allowed is 90,000.  If higher values
*                      are passed there will be unexpected results.
*       Continuous - FALSE for a one shot interrupt.  TRUE for multiple
*                    interrupts.
d292 2
a293 2
*  RESULT
*       NONE
a294 2
*  SEE ALSO:
*       AddTimerInt(), RemTimerInt(), StopTimerInt()
a352 6
*  NAME
*       RemTimerInt - Remove the previously installed timer interrupt.
*
*  SYNOPSIS
*       RemTimerInt(TimerIntHandle)
*                   a1
d354 2
a355 1
*       VOID RemTimerInt(APTR)
d357 13
a369 8
*  FUNCTION
*       Calling this routine causes the system to remove a timer interrupt
*       routine previously added with AddTimerInt.  Additionally any timer
*       resources involved in the timer interval will be freed.
*
*  INPUTS
*       TimerIntHandle - Pointer to the handle returned from AddTimerInt().
*                        This value may be NULL.
d371 2
a372 2
*  RESULT
*       NONE
a373 2
*  SEE ALSO:
*       AddTimerInt(), StopTimerInt(), StartTimerInt()
d393 1
a393 1
*       FindTimerTimer - Trys to own a CIA timer.
d396 17
a412 12
*       Failure = FindTimerTimer(ExecBase, resName, Interrupt, CIAResource, TimerAlloc)
*       NFlag                    a6        a1       a4         a6           d0
*
*  FUNCTION
*       Opens the indicated CIA resource.  Then attempts to install the
*       interrupt routine for the A timer.  If it is unsuccessful then
*       the B timer is tried.
*
*  INPUTS
*       ExecBase - Pointer to ExecBase.
*       resName - Name of CIA resource to be opened.
*       Interrupt - Pointer to the interrupt structure to be added.
a413 5
*  RESULT
*       Failure - Set if no timer was owned.
*       CIAResource - Points to the opened resource.
*       TimerAlloc - Identifies which timer was actually owned.
*
a438 6
*  NAME
*       ElapsedTime - Returns the time elapsed since it was last called.
*
*  SYNOPSIS
*       FractionalSeconds = ElapsedTime(Context)
*       d0                              a0
d440 2
a441 1
*       ULONG ElapsedTime(struct EClockVal *)
d443 46
a488 24
*  FUNCTION
*       This function utilizes the timer.device call ReadEClock to get an
*       accurate elaspsed time value.  Since the context needs to be
*       established the first call to this routine will return a nonsense
*       value.
*
*  NOTE
*       The return value for this function only allows for sixteen bits
*       worth for the integer number of seconds and sixteen bits for the
*       factional number of seconds.
*
*       With sixteen bits worth of integer seconds this function can be
*       used to timer an interval up to about 16 hours.  If the actual time
*       interval is larger this function will return this maximum value.
*
*       The sixteen bits for fractional seconds gives a resolution of
*       approximately 20 microseconds.  However, it is not recomended
*       to expect this function to be accurate for a time interval of
*       less than 200 microseconds.
*
*  INPUTS
*       Context - Pointer to an EClockVal structure, two ULONGs.  This was
*                 the value returned from ReadEClock() when this function
*                 was last called.
d490 2
a491 10
*  RESULT
*       FractionalSeconds - The elapsed time as a fixed point thirty two
*                           bit number with the point fixed in the middle.
*                           That is, the upper order sixteen bits represent
*                           the number of seconds elapsed.  The low order
*                           sixteen bit represent the fractional number of
*                           seconds elapsed.  This value is limited to about
*                           sixteen hours.  Although this value is precise
*                           to nearly 20 microseconds it is only accurate to
*                           within 200 microseconds.
a492 2
*  SEE ALSO:
*       timer.device/ReadEClock()
d535 1
a535 1
*                If this ever changes the code needs to be rewritten.
@


40.4
log
@Polished autodocs.
@
text
@d3 1
a3 1
*	$Id: Timer.asm,v 40.3 93/03/22 12:04:11 Jim2 Exp Locker: Jim2 $
d7 4
a10 1
*	$Log:	Timer.asm,v $
d58 2
a59 2
*	(C) Copyright 1992,1993 Commodore-Amiga, Inc.
*	    All Rights Reserved
d63 19
a81 29
	IFD	BETTER_FASTER
		OPT p=68020
	ENDC

	INCLUDE	'exec/macros.i'
	INCLUDE 'exec/types.i'
	INCLUDE 'exec/nodes.i'
	INCLUDE	'exec/lists.i'
	INCLUDE	'exec/memory.i'
	INCLUDE	'exec/io.i'

	INCLUDE 'resources/cia.i'
	INCLUDE 'hardware/cia.i'

	INCLUDE	'/macros.i'
	INCLUDE	'/lowlevelbase.i'



		XDEF	AddTimerInt
		XDEF	RemTimerInt
		XDEF	StartTimerInt
		XDEF	StopTimerInt
		XDEF	ElapsedTime
		XDEF	CIAARESOURCE

		XREF	_ciaa
		XREF	_ciab

d83 2
d88 1
a88 1
*	AddTimerInt - Adds an interrupt that is executed at regular intervals
d91 22
a112 22
*	TimerIntHandle = AddTimerInt(IntRoutine, IntData)
*	d0			     a0		 a1
*
*	APTR AddTimerInt(APTR, APTR)
*
*  FUNCTION
*	Calling this routine causes the system to allocate a CIA timer
*	and set up IntRoutine to service any interrupts cause by the timer.
*	Although the timer is allocated it is neither running, nor enabled.
*	StartIntTimer must be called to establish the time interval and
*	start the timer.
*
*	When the interrupts occur the routine pointed to by IntRoutine is
*	called.  As with any other assembly routines d0, d1, a0 and a1 can
*	be considered scratch, all other registers must have their values
*	preserved.  However, upon exit d0 MUST be cleared.  When the
*	interrupt routine is invoked a1 will contain the value passed to
*	this routine as IntData.
*
*	Only a single CIA timer will be allocated by this routine.  So this
*	routine may only be called once without an intervening call to
*	RemTimerInt.
d114 3
a116 3
*	The CIA timer used by this routine is not guaranteed to always be
*	the same.  This routine utilizes the CIA resource and uses an
*	unallocated CIA timer.
d119 2
a120 2
*	If your program is to exit without reboot, you MUST match all
*	calls to this function with calls to RemTimerInt before exiting.
d122 19
a140 12
*	Even if you only use the function once in your program; checking
*	the return value will make your program more tolerant for
*	mulititasking on the Amiga computer platforms.
*
*  INPUTS
*	IntRoutine - Pointer to the interrupt routine invoked every
*		     TimeInterval
*	IntData - Data passed to the interrupt routine in register a1.
*		  If more than one long word of data is required this
*		  should be a pointer to structure that contains the
*		  required data.
*
d142 3
a144 3
*	TimerIntHandle - Pointer to the handle used in manipulating the
*			 timer interrupt.  NULL if it was not possible
*			 create the interrupt.
d147 1
a147 1
*	RemTimerInt(), StopTimerInt(), StartTimerInt()
d150 4
a153 4
		movem.l	a0-a1/a4-a6,-(sp)	;Store the parameters and some scratch registers.
		move.l	a6,a5
		move.l	ll_ExecBase(a6),a6
		JSRLIB	Forbid			;Only one interval timer is allowed.
d155 73
a227 65
				;We don't want to get multiple invokations of
				;lowlevel.library both thinking they can change it.

		tst.l	ll_CIATimer+llct_TimerInt+IS_CODE(a5)
		beq.s	2$
				;The interrupt is currently in use.
		JSRLIB	Permit
		movem.l	(sp)+,a0-a1/a4-a6
		CLEAR	d0			;Set up the return value.
		rts

2$		movem.l	(sp)+,a0-a1		;Fortunately, the way movem works this is OK.
		lea	ll_CIATimer(a5),a4	;Get the pointer to the CIA timer data
						;structure and initialize it.
		move.l	a0,llct_TimerInt+IS_CODE(a4)
		move.l	a1,llct_TimerInt+IS_DATA(a4)
		clr.b	llct_TimerInt+LN_PRI(a4)
		move.b	#NT_INTERRUPT,llct_TimerInt+LN_TYPE(a4)
		move.l	LN_NAME(a5),llct_TimerInt+LN_NAME(a4)
		JSRLIB	Permit			;It is now safe to reinitialize multitasking.
		JSRLIB	Disable			;But now disable interrupts
		lea	CIAARESOURCE(pc),a1
				;Try to allocate a timer in CIAA.
		jsr	FindFreeTimer		;a6 points to the CIAA resource.
		bpl.s	Opened			;The last move determines whether a timer was found.
		move.l	ll_ExecBase(a5),a6
		lea	CIABRESOURCE(pc),a1
				;Try to allocate a timer in CIAB.
		jsr	FindFreeTimer		;a6 points to the CIAB resource.
		bpl.s	Opened

				;The last move determines whether a timer was found.
				;No timer was found, so clear the marker about a
				;an allocated interrupt; restore the
				;stack and address registers; and
				;return an NULL.

		moveq.l	#0,d0
		move.l	d0,llct_TimerInt+IS_CODE(a4)
		move.l	ll_ExecBase(a5),a6
		bra.s	ExitTryCIA
						;Have allocated a CIA timer.
Opened:		move.l	a6,llct_Resource(a4)
		move.w	d0,llct_WhichTimer(a4)

				;Determine which timer is to be started and set d0 to
				;the offset to the register and d1 to the data to be
				;written.

		bne.s	TimerB
		move.l	#ciacra,d1
		move.l	#(CIAICRF_TA<<16)|CIACRAF_TODIN|CIACRAF_PBON|CIACRAF_RUNMODE|CIACRAF_OUTMODE|CIACRAF_SPMODE,d0
		move.l	#_ciaa,a1
		bra.s	Doit
TimerB:		move.l	#ciacrb,d1
		move.l	#(CIAICRF_TB<<16)|CIACRBF_ALARM|CIACRBF_PBON|CIACRBF_RUNMODE|CIACRBF_OUTMODE,d0
		move.l	#_ciab,a1
Doit		and.b	d0,0(a1,d1)		;Touch the register in an atomic fashion.
		swap	d0
		JSRLIB	SetICR			;Clear any pending interrupt.
		move.l	ll_ExecBase(a5),a6
		move.l	a4,d0
ExitTryCIA:	JSRLIB	Enable			;Allow interrupts to happen
		movem.l	(sp)+,a4-a6
		rts
d231 1
a231 1
*	StopTimerInt - Stop the timer associated with the timer interrupt.
d234 13
a246 13
*	StopTimerInt(TimerIntHandle)
*		     a1
*
*	VOID StopTimerInt(APTR)
*
*  FUNCTION
*	Calling this routine causes the system stop the timer associated
*	with the timer interrupt handle passed.
*
*  INPUTS
*	TimerIntHandle - Pointer to the handle returned from AddTimerInt.
*			 This must not be NULL or serious problems will
*			 occur.
d249 1
a249 1
*	NONE
d252 1
a252 1
*	AddTimerInt(), RemTimerInt(), StartTimerInt()
d255 1
a255 1
		tst.w	llct_WhichTimer(a1)
d257 14
a270 14
				;Determine which timer is to be started and set d0 to
				;the offset to the register and d1 to the data to be
				;written.

		bne.s	stopTimerB
		move.l	#ciacra,d1
		move.w	#CIACRAF_TODIN|CIACRAF_PBON|CIACRAF_RUNMODE|CIACRAF_OUTMODE|CIACRAF_SPMODE,d0
		move.l	#_ciaa,a1
		bra.s	stop
stopTimerB:	move.l	#ciacrb,d1
		move.w	#CIACRBF_ALARM|CIACRBF_PBON|CIACRBF_RUNMODE|CIACRBF_OUTMODE,d0
		move.l	#_ciab,a1
stop:		and.b	d0,0(a1,d1)		;Touch the register in an atomic fashion.
		rts
d274 1
a274 1
*	StartTimerInt - Start the timer associated with the timer interrupt.
d277 19
a295 19
*	StartTimerInt(TimerIntHandle, TimeInterval, Continuous)
*		      a1	      d0	    d1
*
*	VOID StartTimerInt(APTR, ULONG, BOOL)
*
*  FUNCTION
*	This routine restarts a stopped timer that is assocatied with a
*	timer interrupt created by AddTimerInt.  Before the timer is started
*	the time interval is reset.
*
*  INPUTS
*	TimerIntHandle - Pointer to the handle returned from AddTimerInt.
*			 This must not be NULL or serious problems will
*			 occur.
*	TimeInterval - Number of micoseconds between interrupts.  The
*		       maximum value allowed is 90,000.  If higher values
*		       are passed there will be unexpected results.
*	Continuous - FALSE for a one shot interrupt.  TRUE for multiple
*		     interrupts.
d298 1
a298 1
*	NONE
d301 1
a301 1
*	AddTimerInt(), RemTimerInt(), StopTimerInt()
d304 2
a305 2
		movem.l	d1-d3,-(sp)		;Save the handle.
		tst.w	llct_WhichTimer(a1)
d307 51
a357 50
				;Determine which timer is to be started and set d2 to
				;the offset to the register, d3 to the data to be
				;written and a1 to the base register for the time
				;interval.

		bne.s	startTimerB
		move.l	#ciacra,d2
		move.l	#ciatalo,a1
		move.l	#(CIACRAF_START<<16)|CIACRAF_TODIN|CIACRAF_PBON|CIACRAF_OUTMODE|CIACRAF_SPMODE,d3
		move.l	#_ciaa,a0
		bra.s	start
startTimerB:	move.l	#ciacrb,d2
		move.l	#ciatblo,a1
		move.l	#(CIACRBF_START<<16)|CIACRBF_ALARM|CIACRBF_PBON|CIACRBF_OUTMODE,d3
		move.l	#_ciab,a0
start:		and.b	d3,0(a0,d2)		;Stop any timer
		tst.w	d1
		bne.s	ConMode
		or.b	#CIACRAF_RUNMODE,0(a0,d2)
ConMode:	move.l	ll_EClockConversion(a6),d1
		lsr.l	#1,d0			;Ignore the least significant bit.
		lsr.l	#4,d1			;Ignore the four least significant bits of the EClocks/second.
						;All of this ignoring results in a
						;sixteen bit by sixteen bit multiply.
						;Since only the upper order sixteen
						;bits of the final answer are useful
						;this ignoring is meanless.
		mulu.w	d1,d0
		divu.w	#31250,d0		;Only want the high order sixteen bits.
				;
				;The preceeding four lines can be replaced by
				;the following two lines:
				;mulu.l	d1,d0
				;divu.l	#100000,d0
				;however this will acutally execute slower so
				;there really is no need for 020 > specific
				;code at this time.
				;
		bne.s	1$
		addq.b	#1,d0			;Can't have an interval of zero, must be at least one.
1$		add.l	a0,a1
		move.b	d0,(a1)			;Write the low byte.
		lsr.w	#8,d0			;Get the high byte in a position to be written.
		move.b	d0,ciatbhi-ciatblo(a1)	;Write the high byte.
		tst.w	2(sp)
		beq.s	SingleShot
		swap	d3
		or.b	d3,0(a0,d2)		;Touch the register in an atomic fashion.
SingleShot:	movem.l	(sp)+,d1-d3
		rts
d361 1
a361 1
*	RemTimerInt - Remove the previously installed timer interrupt.
d364 13
a376 14
*	RemTimerInt(TimerIntHandle)
*		    a1
*
*	VOID RemTimerInt(APTR)
*
*  FUNCTION
*	Calling this routine causes the system to remove a timer interrupt
*	routine previously added with AddTimerInt.  Additionally any timer
*	resources involved in the timer interval will be freed.
*
*  INPUTS
*	TimerIntHandle - Pointer to the handle returned from AddTimerInt.
*			 This must not be NULL or serious problems will
*			 occur.
d379 1
a379 1
*	NONE
d382 1
a382 1
*	AddTimerInt(), StopTimerInt(), StartTimerInt()
d385 3
a387 3
		move.l	a6,-(sp)		;Save the parameter and scratch registers.
		move.l	a1,-(sp)
		beq.s	rti_Error
d389 7
a395 7
		move.w	llct_WhichTimer(a1),d0	;Get the parameters for RemICRVector.
		move.l	llct_Resource(a1),a6
		JSRLIB	RemICRVector
		movem.l	(sp)+,a1		;Restore the registers.
		clr.l	IS_CODE(a1)		;Clear the marker for the allocated Timer Interrupt.
		move.l	(sp)+,a6
		rts
d397 2
a398 2
rti_Error	movem.l	(sp)+,a1/a6
		rts
d402 1
a402 1
*	FindTimerTimer - Trys to own a CIA timer.
d405 17
a421 16
*	Failure = FindTimerTimer(ExecBase, resName, Interrupt, CIAResource, TimerAlloc)
*	NFlag			 a6	   a1	    a4	       a6	    d0
*
*  FUNCTION
*	Opens the indicated CIA resource.  Then attempts to install the
*	interrupt routine for the A timer.  If it is unsuccessful then
*	the B timer is tried.
*
*  INPUTS
*	ExecBase - Pointer to ExecBase.
*	resName - Name of CIA resource to be opened.
*	Interrupt - Pointer to the interrupt structure to be added.
*  RESULT
*	Failure - Set if no timer was owned.
*	CIAResource - Points to the opened resource.
*	TimerAlloc - Identifies which timer was actually owned.
d425 21
a445 21
		JSRLIB	OpenResource
		move.l	d0,a6			;d0 is the return from OpenResource.
		move.l	a4,a1			;Ready the interrupt pointer.
		move.w	#CIAICRB_TA,d0		;Other parameter is the timer.
		move.w	d0,-(sp)		;Remember which timer is being tried.
		JSRLIB	AddICRVector
		tst.l	d0
		beq.s	OK
				;Could not allocate timer A, try timer B.
		move.l	a4,a1			;Ready the interrupt pointer.
		move.w	#CIAICRB_TB,d0		;Other parmeter is the timer.
		move.w	d0,(sp)			;Remember which timer is being tried.
						;Not pushed, previous value was never popped.
		JSRLIB	AddICRVector
		tst.l	d0
		beq.s	OK
				;Could not allocate timer B - Failure.
		move.w	#-1,(sp)		;The word at the pointer indicates which timer, well, this is no timer.
OK:		move.w	(sp)+,d0		;Return the allocated timer in d0.
						;Set the N flag to indicate success/failure.
		rts
d449 1
a449 1
*	ElapsedTime - Returns the time elapsed since it was last called.
d452 10
a461 10
*	FractionalSeconds = ElapsedTime(Context)
*	d0				a0
*
*	ULONG ElapsedTime(struct EClockVal *)
*
*  FUNCTION
*	This function utilizes the timer.device call ReadEClock to get an
*	accurate elaspsed time value.  Since the context needs to be
*	established the first call to this routine will return a nonsense
*	value.
d464 3
a466 3
*	The return value for this function only allows for sixteen bits
*	worth for the integer number of seconds and sixteen bits for the
*	factional number of seconds.
d468 24
a491 24
*	With sixteen bits worth of integer seconds this function can be
*	used to timer an interval upto about 16 hours.  If the actual time
*	interval is larger this function will return this maximum value.
*
*	The sixteen bits for fractional seconds gives a resolution of
*	approximately 20 microseconds.  However, it is not recomended
*	to expect this function to be accurate for a time interval of
*	less than 200 microseconds.
*
*  INPUTS
*	Context - Pointer to an EClockVal structure, two ULONGs.  This was
*		  the value returned from ReadEClock when this function was
*		  last called.
*
*  RESULT
*	FractionalSeconds - The elapsed time as a fixed point thirty two
*			    bit number with the point fixed in the middle.
*			    That is, the upper order sixteen bits represent
*			    the number of seconds elapsed.  The low order
*			    sixteen bit represent the fractional number of
*			    seconds elapsed.  This value is limited to about
*			    sixteen hours.  Although this value is precise
*			    to nearly 20 microseconds it is only accurate to
*			    within 200 microseconds.
d494 1
a494 1
*	timer.device/ReadEClock()
d496 1
a496 1
	OPT	P=68020
d498 33
a530 33
		movem.l	d2-d3/a6,-(sp)		;Need a few registers.
		move.l	4(a0),-(sp)
		move.l	(a0),-(sp)		;Copy the last EClock value to the stack.
		move.l	ll_TimerDevice(a6),a6
		JSRLIB	ReadEClock
		movem.l	(a0)+,d1/d2		;Get new EClock value in d1:d2.
		sub.l	4(sp),d2		;Subtract low order EClock long word.
		move.l	(sp)+,d3		;Get old EClock value in d3.
		addq	#4,sp			;Clear old EClock value from stack.
		subx.l	d3,d1			;Subtract high order EClock long word including borrow.
		bpl.s	2$

		neg.l	d2
		negx.l	d1
2$:		swap	d1			;Multiply by 2^16.
		tst.w	d1
		bne.s	et_Overflow

		swap	d2
		move.w	d2,d1
		clr.w	d2
		divu.l	d0,d1:d2		;Divide 64bit/32bit get 32bit Rem:32bit Quo
		bvs.s	et_Overflow
		move.l	d2,d0

	OPT	P=68000

et_Exit		movem.l	(sp)+,d2-d3/a6		;Restore scratch registers.
		rts

et_Overflow:	moveq	#-1,d0
		bra.s	et_Exit

d532 1
a532 1
		XDEF	ElapsedTime000
d537 1
a537 1
*		 If this ever changes the code needs to be rewritten.
d539 35
a573 35
		movem.l	d2-d3/a6,-(sp)		;Need a few registers.
		move.l	4(a0),-(sp)
		move.l	(a0),-(sp)		;Copy the last EClock value to the stack.
		move.l	ll_TimerDevice(a6),a6
		JSRLIB	ReadEClock
		movem.l	(a0)+,d1/d2		;Get new EClock value in d1:d2.
		sub.l	4(sp),d2		;Subtract low order EClock long word.
		move.l	(sp)+,d3		;Get old EClock value in d3.
		addq	#4,sp			;Clear old EClock value from stack.
		subx.l	d3,d1			;Subtract high order EClock long word including borrow.
		bpl.s	1$

		neg.l	d2
		negx.l	d1
1$:		cmp.l	#$F,d1
		bgt.s	et_Overflow
				;vanilla 68000 code can only do 32bit/16bit.
				;Tick/sec is twenty bits so shift everyone over four.
		lsr.l	#4,d0
		and.w	#$000F,d1
		and.w	#$FFF0,d2
		or.w	d1,d2
		ror.l	#4,d2
		divu.w	d0,d2
		bvs.s	et_Overflow
		move.l	d2,d1
		swap	d2
		clr.w	d1
		divu.w	d0,d1
		move.w	d1,d2

		move.l	d2,d0
		movem.l	(sp)+,d2-d3/a6		;Restore scratch registers.
		rts

d576 3
a578 3
CIAARESOURCE	CIAANAME
CIABRESOURCE	CIABNAME
		end
@


40.3
log
@Forgot to save before releasing 40.12.

Seperated out the 020 ElapsedTime code.  Tested to see if SetTimeInterval
would benefit from 020 code.  The answer is no.  While examining
the 020 ElapsedTime code I came up with a slight improvement.
The correction on the shift (Revision 40.1) was incorrect.  Rather
it was bringing in the least significant byte of the remainder.
@
text
@d3 1
a3 1
*	$Id: Timer.asm,v 40.2 93/03/10 12:22:48 Jim2 Exp Locker: Jim2 $
d8 9
d123 2
a124 1
*	NOTE:  If your program is to exit without reboot, you MUST match all
d127 3
a129 3
*	NOTE:  Even if you only use the function once in your program;
*	checking the return value will make your program more tolerant
*	for mulititasking on the Amiga computer platforms.
@


40.2
log
@Cleaned up the results of Vertex code walkthrough.
@
text
@d3 1
a3 1
*	$Id: Timer.asm,v 40.1 93/03/02 13:25:24 Jim2 Exp Locker: Jim2 $
d8 3
d102 3
a104 2
*	preserved.  When the interrupt routine is invoked a1 will contain
*	the value passed to this routine as IntData.
a306 1
	IFND	BETTER_FASTER
d315 10
a324 6
		divu.w	#15625,d0		;Only want the high order sixteen bits.
		lsr.l	#1,d0
	ELSE
		mulu.l	d1,d0
		divu.l	#100000,d0
	ENDC
d442 14
d475 38
d517 1
a517 1
ElapsedTime
d526 1
d528 6
a533 2
		addq	#4,sp			;Clear old EClock value from stack.
	IFND	BETTER_FASTER
d537 13
a549 28
		asr.l	#1,d1			;Use arithmetic shift so we can check sign bit at the end.
		roxr.l	#1,d2
		asr.l	#1,d1
		roxr.l	#1,d2
		asr.l	#1,d1
		roxr.l	#1,d2
		asr.l	#1,d1
		roxr.l	#1,d2
		tst.l	d1
		bpl.s	1$
		neg.l	d2			;No such thing as negative time, must have rolled over.  Complement.
1$:		divu.w	d0,d2
		swap	d2			;Get the whole number of seconds in high word.
		moveq	#0,d1
		move.w	d2,d1
		swap	d1			;Take the remainder shift it to a high word.
		divu.w	d0,d1			;and get the fraction in low order word (is quotiant of this calculation).
	ELSE
		tst.l	d1			;No such thing as negative time, must have rolled over.  Complment.
		bpl.s	2$
		neg.l	d2
		negx.l	d1
2$:		divu.l	d0,d1:d2		;Divide 64bit/32bit get 32bit Rem:32bit Quo
		swap	d2			;Want the low order sixteen bits of the quotient in the high word.
		lsr.l	#4,d1			;Only want the high order sixteen bits of the remander (is 20 bits).
	ENDC
		move.l	d2,d0			;Move the whole number to d0 high order word.
		move.w	d1,d0			;Move the fraction into low order d0.
@


40.1
log
@Changed all references from game.library to lowlevel.library.
Corrected error that prevented single shot timers from working.
The final shift on the time (non 020) needs to be long
word to get the full range for the timer.
@
text
@d3 1
a3 1
*	$Id: Timer.asm,v 40.0 93/02/19 16:50:33 Jim2 Exp Locker: Jim2 $
d8 6
d147 1
a147 1
		moveq	#0,d0			;Set up the return value.
d155 1
a155 2
		moveq	#0,d1
		move.b	d1,llct_TimerInt+LN_PRI(a4)
d157 1
a157 2
		lea	TIMERINT(pc),a0
		move.l	a0,llct_TimerInt+LN_NAME(a4)
d191 1
d195 2
a196 2
Doit		move.l	LIB_SIZE(a6),a1		;Get the CIA base address in a1.
		and.b	d0,0(a1,d1)		;Touch the register in an atomic fashion.
d240 1
d244 2
a245 3
stop:		move.l	llct_Resource(a1),a1
		move.l	LIB_SIZE(a1),a1		;Get the CIA base address in a1.
		and.b	d0,0(a1,d1)		;Touch the register in an atomic fashion.
a280 2
		move.l	llct_Resource(a1),a0
		move.l	LIB_SIZE(a0),a0		;Get the CIA base address in a1.
d292 1
d297 1
d358 4
a361 2
		movem.l	a1/a5-a6,-(sp)		;Save the parameter and scratch registers.
		move.l	a6,a5
d365 6
a370 3
		movem.l	(sp)+,a1/a5-a6		;Restore the registers.
		moveq	#0,d0
		move.l	d0,IS_CODE(a1)		;Clear the marker for the allocated Timer Interrupt.
a507 1
TIMERINT	dc.b	'lowlevel.library CIA timer',0
@


40.0
log
@Corrected autodoc format for SEE ALSO.
@
text
@d3 1
a3 1
*	$Id: Timer.asm,v 39.5 93/01/18 13:27:48 Jim2 Exp Locker: Jim2 $
d8 3
d57 1
a57 1
	INCLUDE	'/gamebase.i'
d73 1
a73 1
******* game.library/AddTimerInt *********************************************
d130 1
a130 1
		move.l	gm_ExecBase(a6),a6
d134 1
a134 1
				;game.library both thinking they can change it.
d136 1
a136 1
		tst.l	gm_CIATimer+gmct_TimerInt+IS_CODE(a5)
d145 1
a145 1
		lea	gm_CIATimer(a5),a4	;Get the pointer to the CIA timer data
d147 2
a148 2
		move.l	a0,gmct_TimerInt+IS_CODE(a4)
		move.l	a1,gmct_TimerInt+IS_DATA(a4)
d150 2
a151 2
		move.b	d1,gmct_TimerInt+LN_PRI(a4)
		move.b	#NT_INTERRUPT,gmct_TimerInt+LN_TYPE(a4)
d153 1
a153 1
		move.l	a0,gmct_TimerInt+LN_NAME(a4)
d160 1
a160 1
		move.l	gm_ExecBase(a5),a6
d173 2
a174 2
		move.l	d0,gmct_TimerInt+IS_CODE(a4)
		move.l	gm_ExecBase(a5),a6
d177 2
a178 2
Opened:		move.l	a6,gmct_Resource(a4)
		move.w	d0,gmct_WhichTimer(a4)
d194 1
a194 1
		move.l	gm_ExecBase(a5),a6
d200 1
a200 1
******* game.library/StopTimerInt ********************************************
d226 1
a226 1
		tst.w	gmct_WhichTimer(a1)
d238 1
a238 1
stop:		move.l	gmct_Resource(a1),a1
d243 1
a243 1
******* game.library/StartTimerInt *******************************************
d276 1
a276 1
		move.l	gmct_Resource(a1),a0
d278 1
a278 1
		tst.w	gmct_WhichTimer(a1)
d292 3
a294 2
		move.l	#(CIACRBF_START<<16)|CIACRAF_TODIN|CIACRAF_PBON|CIACRAF_OUTMODE|CIACRAF_SPMODE,d3
start:		tst.w	d1
d296 2
a297 3
		or.b	#CIACRAF_RUNMODE,d3
ConMode:	and.b	d3,0(a0,d2)		;Stop any timer
		move.l	gm_EClockConversion(a6),d1
d308 1
a308 1
		lsr.w	#1,d0
d326 1
a326 1
******* game.library/RemTimerInt *********************************************
d355 2
a356 2
		move.w	gmct_WhichTimer(a1),d0	;Get the parameters for RemICRVector.
		move.l	gmct_Resource(a1),a6
d409 1
a409 1
******* game.library/ElapsedTime *********************************************
d452 1
a452 1
		move.l	gm_TimerDevice(a6),a6
d498 1
a498 1
TIMERINT	dc.b	'game.library CIA timer',0
@


39.5
log
@Cleaned up comments.
@
text
@d3 1
a3 1
*	$Id: timer.asm,v 39.4 93/01/15 13:51:17 Jim2 Exp Locker: Jim2 $
d7 4
a10 1
*	$Log:	timer.asm,v $
d122 1
a122 1
*	RemTimerInt, StopTimerInt, StartTimerInt
d220 1
a220 1
*	AddTimerInt, RemTimerInt, StartTimerInt
d269 1
a269 1
*	AddTimerInt, RemTimerInt, StopTimerInt
d347 1
a347 1
*	AddTimerInt, StopTimerInt, StartTimerInt
d439 1
a439 1
*	timer.device/ReadEClock
@


39.4
log
@Removed the parameter for setting the time interval from AddTimeInt.
Deleted the functions SetTimeInterval and ConvertToFracTime.
Added two parameters (TimeInterval and Continuous) to StartTimerInt.
When an interrupt is added it is added stopped, with any
pending interrupt cleared.
@
text
@d3 1
a3 1
*	$Id: Timer.asm,v 39.3 93/01/13 13:41:02 Jim2 Exp Locker: Jim2 $
d7 8
a14 1
*	$Log:	Timer.asm,v $
d75 1
a75 1
*	APTR = AddTimerInt(APTR, APTR)
d85 1
a85 1
*	called.  As with any other assembly routine d0, d1, a0 and a1 can
d126 4
a129 3
						;We don't want to get multiple invokations
						;of the game library both thinking
						;they can change it.
d132 1
a132 1
						;The interrupt is currently in use.
d151 1
a151 1
						;Try to allocate a timer in CIAA.
d156 1
a156 1
						;Try to allocate a timer in CIAB.
d159 1
d165 1
d173 6
a178 4
		bne.s	TimerB		;Determine which timer is to be
						;started and set d0 to the offset
						;to the register and d1 to the
						;data to be written.
d196 1
a196 1
*	StopTimerInt - Stop the timer assocaiate with the timer interrupt.
d202 1
a202 1
*	StopTimerInt(APTR)
d221 6
a226 4
		bne.s	stopTimerB		;Determine which timer is to be
						;started and set d0 to the offset
						;to the register and d1 to the
						;data to be written.
d245 1
a245 1
*	StartTimerInt(APTR, ULONG, BOOL)
d248 3
a250 3
*	This routine restarts a stopped timer that is assocatied with a timer
*	interrupt created by AddTimerInt.  Before the timer is started the
*	time interval is reset.
d273 7
a279 4
		bne.s	startTimerB		;Determine which timer is to be
						;started and set d0 to the offset
						;to the register and d1 to the
						;data to be written.
d328 1
a328 1
*	RemTimerInt(APTR)
d357 1
a357 5




*****l* FindFreeTimer ********************************************************
a364 2
*	RemTimerInt(APTR)
*
d389 1
a389 1
						;Could not allocate timer A, try timer B.
d397 1
a397 1
						;Could not allocate timer B - Failure.
d411 1
a411 1
*	ULONG = ElapsedTime(struct EClockVal *)
d454 2
a455 3
						;vanilla 68000 code can only do
						;32bit/16bit.  Tick/sec is twenty bits
						;so shift everyone over four.
@


39.3
log
@Added ConvertToFracTime and corrected some comments
@
text
@d3 1
a3 1
*	$Id: timer.asm,v 39.2 93/01/07 14:21:10 Jim2 Exp Locker: Jim2 $
d7 4
a10 1
*	$Log:	timer.asm,v $
a49 1
		XDEF	SetTimerInterval
a52 1
		XDEF	ConvertToFracTime
d65 2
a66 2
*	TimerIntHandle = AddTimerInt(IntRoutine, IntData, TimeInterval)
*	d0			     a0		 a1	  d0
d68 1
a68 1
*	APTR = AddTimerInt(APTR, APTR, ULONG)
d72 4
a75 1
*	to produce interrupts every TimeInterval.
a104 3
*	TimeInterval - Number of micoseconds to wait.  The maximum value
*		       allowed is 90,000.  If higher values are passed there
*		       will be unexpected results.
d107 3
a109 3
*	TimerIntHandle - Pointer to the handle used in manipulating the timer
*			 interrupt.  NULL if it was not possible create the
*			 interrupt.
d112 1
a112 1
*	RemTimerInt, StopTimerInt, StartTimerInt, SetTimerInterval
d115 1
a115 1
		movem.l	d0/a0-a1/a4-a6,-(sp)	;Store the parameters and some scratch registers.
d126 1
a126 1
		movem.l	(sp)+,d0/a0-a1/a4-a6
d130 1
a130 1
2$		movem.l	(sp)+,d0/a0-a1		;Fortunately, the way movem works this is OK.
d141 1
a141 1
		move.l	d0,-(sp)		;Save the TimeInterval, it was not possible to leave it on the stack previously.
d150 6
a155 5
		bpl.s	Opened			;The last move determines whether a timer was found.
						;No timer was found, so clear the marker about a
						;an allocated interrupt; restore the
						;stack and address registers; and
						;return an NULL.
d158 2
a159 2
		movem.l	(sp)+,d1/a4-a6
		rts
d163 18
a180 3
		move.l	a4,a1			;Set up for a call to SetTimerInt.
		movem.l	(sp)+,d0/a4-a6
		bsr.s	SetTimerInterval
d182 1
a182 3
		;Fall into StartTimerInt

******* game.library/StartTimerInt *******************************************
d184 1
a184 1
*	StartTimerInt - Start the timer associated with the timer interrupt.
d187 2
a188 2
*	StartTimerInt(TimerIntHandle)
*		      a1
d190 1
a190 1
*	StartTimerInt(APTR)
d193 2
a194 3
*	This routine restarts a stopped timer that is assocatied with a timer
*	interrupt created by AddTimerInt.  Before the timer is started the
*	time interval is reset.
d198 2
a199 1
*			 This must not be NULL or serious problems will occur.
d205 1
a205 1
*	AddTimerInt, RemTimerInt, StopTimerInt, SetTimerInterval
d207 1
a207 2
StartTimerInt
		move.l	a1,-(sp)		;Save the handle.
d209 2
a210 2
		bne.s	startTimerB		;Determine which timer is to be
						;stopped and set d0 to the offset
d213 6
a218 6
		move.l	#ciacra,d0
		move.w	#CIACRAF_START,d1
		bra.s	start
startTimerB:	move.l	#ciacrb,d0
		move.w	#CIACRBF_START,d1
start:		move.l	gmct_Resource(a1),a1
d220 13
a232 18
		or.b	d1,0(a1,d0)		;Touch the register in an atomic fashion.
		move.l	(sp)+,d0		;Set up the return value.
						;This is not strictly necessary for
						;this routine, but it allows us to
						;fall through from AddTimerInt.

		rts

******* game.library/SetTimerInterval ****************************************
*  NAME
*	SetTimerInterval - Change the interval used by a timer interrupt.
*
*  SYNOPSIS
*	SetTimerInterval(TimerIntHandle, TimeInterval)
*			 a1		 d0
*
*	SetTimerInterval(APTR, ULONG)
*
d234 3
a236 2
*	Changes the interval between interrupts for a timer interrupt created
*	by AddTimerInt.
d240 7
a246 4
*			 This must not be NULL or serious problems will occur.
*	TimeInterval - Number of micoseconds between interrupts.  The maximum
*		       value allowed is 90,000.  If higher values are passed
*		       there will be unexpected results.
d252 1
a252 1
*	AddTimerInt, RemTimerInt, StopTimerInt, StartTimerInt
d254 20
a273 5
*
*
* NOTE to self:  The 68000 code assume the E Clocks per second is 20 bit number.
*		 If this ever changes the code needs to be rewritten.
SetTimerInterval
d292 9
a300 13
1$		movem.l	d0/a1,-(sp)		;Save the parameters.
		jsr	StopTimerInt
		movem.l	(sp)+,d1/a1		;Restore the parameters.
		move.l	gmct_Resource(a1),a0
		move.l	LIB_SIZE(a0),a0		;Get the base address of the CIA.
		tst.w	gmct_WhichTimer(a1)	;Determine which timers registers to hit.
		bne.s	setTimerB
		add.l	#ciatalo,a0		;Offset for timer A.
		bra.s	set
setTimerB:	add.l	#ciatblo,a0		;Offset for timer B.
set:		move.b	d1,(a0)			;Write the low byte.
		lsr.w	#8,d1			;Get the high byte in a position to be written.
		move.b	d1,ciatbhi-ciatblo(a0)	;Write the high byte.
d320 2
a321 1
*			 This must not be NULL or serious problems will occur.
d327 1
a327 1
*	AddTimerInt, StopTimerInt, StartTimerInt, SetTimerInterval
a340 44
******* game.library/StopTimerInt ********************************************
*  NAME
*	StopTimerInt - Stop the timer assocaiate with the timer interrupt.
*
*  SYNOPSIS
*	StopTimerInt(TimerIntHandle)
*		     a1
*
*	StopTimerInt(APTR)
*
*  FUNCTION
*	Calling this routine causes the system stop the timer associated with
*	the timer interrupt handle passed.
*
*  INPUTS
*	TimerIntHandle - Pointer to the handle returned from AddTimerInt.
*			 This must not be NULL or serious problems will occur.
*
*  RESULT
*	NONE
*
*  SEE ALSO:
*	AddTimerInt, RemTimerInt, StartTimerInt, SetTimerInterval
******************************************************************************
StopTimerInt
		move.l	a1,-(sp)		;Save the handle.
		tst.w	gmct_WhichTimer(a1)
		bne.s	stopTimerB		;Determine which timer is to be
						;started and set d0 to the offset
						;to the register and d1 to the
						;data to be written.
		move.l	#ciacra,d0
		move.w	#CIACRAF_TODIN|CIACRAF_PBON|CIACRAF_OUTMODE|CIACRAF_SPMODE,d1
		bra.s	stop
stopTimerB:	move.l	#ciacrb,d0
		move.w	#CIACRBF_ALARM|CIACRBF_PBON|CIACRBF_OUTMODE,d1
stop:		move.l	gmct_Resource(a1),a1
		move.l	LIB_SIZE(a1),a1		;Get the CIA base address in a1.
		and.b	d1,0(a1,d0)		;Touch the register in an atomic fashion.
		move.l	(sp)+,d0		;This is not necessary.  However, it
						;is done as a side effect as a
						;parallel to StartTimerInt.
		rts

a475 39
		rts

*****i* game.library/ConvertToFracTime ***************************************
*  NAME
*	ConvertToFracTime - Takes from Seconds and microseconds to 32 fixed
*			    point time.
*
*  SYNOPSIS
*	FracTime = ConvertToFracTime(Seconds, Microseconds)
*	d0			     d0	      d1
*
*	ULONG = ConvertToFracTime(ULONG, ULONG)
*
*  FUNCTION
*	Takes a time values in two long words representing seconds and
*	mircoseconds and converts it to a single long word.  This long
*	word is fractional seconds.  The value has a fixed binary point
*	in the middle.
*
*	a0 and a1 are preserved by this function.
*
*  INPUTS
*	Seconds - Seconds to be converted.
*	Microseconds - microseconds to be converted.
*
*  RESULT
*	FracTime - The time expressed as a fixed point thirty two bit number
*		   with the point fixed in the middle.  That is, the upper
*		   order sixteen bits represent the number of seconds.  The
*		   low order sixteen bit represent the fractional number of
*		   seconds.
*
******************************************************************************
ConvertToFracTime
		swap	d0			;Move the low order sixteen bits of the seconds to the high order word.
		lsl.l	#8,d1
		lsl.l	#2,d1
		divu.w	#15625,d1
		move.w	d1,d0
@


39.2
log
@Added 020, or better, code with conditional.  Did not test
the new code.
@
text
@d3 1
a3 1
*	$Id: timer.asm,v 39.1 93/01/05 12:04:50 Jim2 Exp Locker: Jim2 $
d8 4
d51 1
d419 1
a419 1
*	ULONG = AddTimerInt(struct EClockVal *)
d438 4
a441 1
*			    seconds elapsed.
d496 40
@


39.1
log
@Made CIAARESOURCE externally visible for keyboard work.
Corrected the size used when retrieving the timer parameter
for RemICRVector.
@
text
@d3 1
a3 1
*	$Id: timer.asm,v 39.0 92/12/17 18:06:00 Jim2 Exp Locker: Jim2 $
d8 5
d17 1
a17 1
*	(C) Copyright 1992 Commodore-Amiga, Inc.
d21 5
a25 3
*
* System include files...
*
a30 3
	INCLUDE 'exec/resident.i'
	INCLUDE	'exec/execbase.i'
	INCLUDE	'exec/libraries.i'
a35 5


*
* Neat macros
*
d37 1
a51 7
*
*******************************************************************************
*
* The library structure ...
*

	INCLUDE	'/gamebase.i'
d140 1
a140 1
		move.l	ExecBase(a5),a6
d158 48
a205 1
		;Fall into SetTimerInterval
d207 1
d236 4
d241 2
a243 1
		move.l	gm_EClockConversion(a6),d1
d251 1
a251 1
		divu.w	#15625,d0			;Only want the high order sixteen bits.
d253 4
a271 48

		;Fall into StartTimerInt

******* game.library/StartTimerInt *******************************************
*  NAME
*	StartTimerInt - Start the timer associated with the timer interrupt.
*
*  SYNOPSIS
*	StartTimerInt(TimerIntHandle)
*		      a1
*
*	StartTimerInt(APTR)
*
*  FUNCTION
*	This routine restarts a stopped timer that is assocatied with a timer
*	interrupt created by AddTimerInt.  Before the timer is started the
*	time interval is reset.
*
*  INPUTS
*	TimerIntHandle - Pointer to the handle returned from AddTimerInt.
*			 This must not be NULL or serious problems will occur.
*
*  RESULT
*	NONE
*
*  SEE ALSO:
*	AddTimerInt, RemTimerInt, StopTimerInt, SetTimerInterval
******************************************************************************
StartTimerInt
		move.l	a1,-(sp)		;Save the handle.
		tst.w	gmct_WhichTimer(a1)
		bne.s	startTimerB		;Determine which timer is to be
						;stopped and set d0 to the offset
						;to the register and d1 to the
						;data to be written.
		move.l	#ciacra,d0
		move.w	#CIACRAF_START,d1
		bra.s	start
startTimerB:	move.l	#ciacrb,d0
		move.w	#CIACRBF_START,d1
start:		move.l	gmct_Resource(a1),a1
		move.l	LIB_SIZE(a1),a1		;Get the CIA base address in a1.
		or.b	d1,0(a1,d0)		;Touch the register in an atomic fashion.
		move.l	(sp)+,d0		;Set up the return value.
						;This is not strictly necessary for
						;this routine, but it allows us to
						;fall through from AddTimerInt.

d438 4
d453 1
d466 1
a466 1
		tst	d1
d468 1
a468 1
		neg	d2			;No such thing as negative time, must have rolled over.  Complement.
d475 9
@


39.0
log
@Initial release, was tested.
@
text
@d3 1
a3 1
*	$Id:  $
d7 3
a9 1
*	$Log: $
d11 1
d47 1
d300 1
a300 1
		move.l	gmct_WhichTimer(a1),d0	;Get the parameters for RemICRVector.
@
