head     40.21;
branch   ;
access   ;
symbols  V40_35:40.21 rel40_34:40.20 rel40_33:40.20 rel40_32:40.20 rel40_29:40.20 rel40_28:40.20 rel40_27:40.19 rel40_26:40.19 rel40_25:40.19 rel40_24:40.18 rel40_23:40.17 rel40_22:40.16 rel40_21:40.15 rel40_20:40.15 rel40_19:40.14 rel40_18:40.14 rel40_17:40.13 rel40_16:40.11 rel40_15:40.10 rel40_14:40.7 rel40_13:40.7 rel40_12:40.6 rel40_11:40.6 rel40_4:40.1 rel40_3:40.1 rel40_2:40.0 rel40_1:40.0 rel39_7:39.11 rel39_6:39.8 rel39_5:39.4 rel39_4:39.1;
locks    ; strict;
comment  @* @;


40.21
date     93.07.30.16.06.49;  author vertex;  state Exp;
branches ;
next     40.20;

40.20
date     93.05.05.09.48.36;  author gregm;  state Exp;
branches ;
next     40.19;

40.19
date     93.04.20.14.17.33;  author Jim2;  state Exp;
branches ;
next     40.18;

40.18
date     93.04.19.14.25.47;  author Jim2;  state Exp;
branches ;
next     40.17;

40.17
date     93.04.19.13.41.44;  author Jim2;  state Exp;
branches ;
next     40.16;

40.16
date     93.04.15.14.25.38;  author Jim2;  state Exp;
branches ;
next     40.15;

40.15
date     93.04.13.15.36.11;  author Jim2;  state Exp;
branches ;
next     40.14;

40.14
date     93.04.02.11.35.26;  author Jim2;  state Exp;
branches ;
next     40.13;

40.13
date     93.04.01.18.09.41;  author Jim2;  state Exp;
branches ;
next     40.12;

40.12
date     93.04.01.13.59.09;  author Jim2;  state Exp;
branches ;
next     40.11;

40.11
date     93.03.31.18.47.32;  author Jim2;  state Exp;
branches ;
next     40.10;

40.10
date     93.03.26.17.41.10;  author Jim2;  state Exp;
branches ;
next     40.9;

40.9
date     93.03.26.14.10.35;  author Jim2;  state Exp;
branches ;
next     40.8;

40.8
date     93.03.26.11.18.32;  author Jim2;  state Exp;
branches ;
next     40.7;

40.7
date     93.03.19.11.31.44;  author Jim2;  state Exp;
branches ;
next     40.6;

40.6
date     93.03.12.20.21.51;  author Jim2;  state Exp;
branches ;
next     40.5;

40.5
date     93.03.10.19.52.45;  author Jim2;  state Exp;
branches ;
next     40.4;

40.4
date     93.03.04.11.53.54;  author Jim2;  state Exp;
branches ;
next     40.3;

40.3
date     93.03.02.13.24.24;  author Jim2;  state Exp;
branches ;
next     40.2;

40.2
date     93.03.01.16.01.34;  author Jim2;  state Exp;
branches ;
next     40.1;

40.1
date     93.02.19.17.48.13;  author Jim2;  state Exp;
branches ;
next     40.0;

40.0
date     93.02.11.17.33.03;  author Jim2;  state Exp;
branches ;
next     39.12;

39.12
date     93.01.20.13.18.48;  author brummer;  state Exp;
branches ;
next     39.11;

39.11
date     93.01.19.14.20.07;  author brummer;  state Exp;
branches ;
next     39.10;

39.10
date     93.01.18.18.03.29;  author brummer;  state Exp;
branches ;
next     39.9;

39.9
date     93.01.14.10.48.43;  author brummer;  state Exp;
branches ;
next     39.8;

39.8
date     93.01.12.16.58.41;  author brummer;  state Exp;
branches ;
next     39.7;

39.7
date     93.01.12.10.56.12;  author brummer;  state Exp;
branches ;
next     39.6;

39.6
date     93.01.11.16.04.55;  author brummer;  state Exp;
branches ;
next     39.5;

39.5
date     93.01.11.15.33.03;  author brummer;  state Exp;
branches ;
next     39.4;

39.4
date     93.01.07.15.57.27;  author brummer;  state Exp;
branches ;
next     39.3;

39.3
date     93.01.07.15.38.52;  author brummer;  state Exp;
branches ;
next     39.2;

39.2
date     93.01.05.12.28.45;  author Jim2;  state Exp;
branches ;
next     39.1;

39.1
date     93.01.05.12.02.14;  author Jim2;  state Exp;
branches ;
next     39.0;

39.0
date     92.12.21.11.41.18;  author Jim2;  state Exp;
branches ;
next     ;


desc
@Gives a common interface to the game developer for the various
devices that can be used on the serial ports.
@


40.21
log
@Autodoc and include cleanup
@
text
@******************************************************************************
*
*	$Id: readjoyport.asm,v 40.20 93/05/05 09:48:36 gregm Exp Locker: gregm $
*
******************************************************************************
*
*	$Log:   readjoyport.asm,v $
* Revision 40.20  93/05/05  09:48:36  gregm
* LOts of changes.
*  (1) SetJoyPortAttrs() added.  Allows API for locking a controller in.
*  (2) Several optimizations were taken; move's where better than lea's, etc.
*  (3) Different versions of the code for different port #'s, different
*      controller types, etc.  Fixes mouse->joystick confusion, and speeds things
*      up.
*  (4) On port 0 & port 1 game controller code, when 'locked', we only clock in the
*      first 6 bits of the buttons.  HUGE savings.
*  (5) ReadJoyPort() was modified to redirect call when a controller type is locked in.
*
* Revision 40.19  93/04/20  14:17:33  Jim2
* Polished the Autodoc.
*
* Revision 40.18  93/04/19  14:25:47  Jim2
* Playing with the fire line must be inside the critical section.
*
* Revision 40.17  93/04/19  13:41:44  Jim2
* Removed some dead lines.  Improved the comments.  Reset the
* first time init flag if the allocation of the Potgo resources
* fail.
*
* Revision 40.16  93/04/15  14:25:38  Jim2
* Drive the fire button output low before changing it to an
* output.
*
* Revision 40.15  93/04/13  15:36:11  Jim2
* Play with the comments.  Change the initial delay to be
* five CIA accesses.  Move the raising of the clock to
* just before the dropping.
*
* Revision 40.14  93/04/02  11:35:26  Jim2
* Forgot when I changed d4 to be a bit to correct the reading
* of the fire button.
*
* Revision 40.13  93/04/01  18:09:41  Jim2
* Well this is the best I can do for now for optimizing
*
* Revision 40.12  93/04/01  13:59:09  Jim2
* Played with the delay to get CDGS to recognise hot insertion
* of the game controller
*
* Revision 40.11  93/03/31  18:47:32  Jim2
* One last try at minimizing the possiblity of transitioning
* incorrectly from unknown to joystick (CI49).  The initial
* read for a port is now taken at the same time the resources
* are aquired.  This means it is quite possible for the first
* read to return unknown.  However, it reduces possibly greatly
* the time between the first and second read.
*
* Also there were timing problems reading the joy pad as
* a result of allowing the code to run on 68000.  Doubling
* the delay while clocking was sufficient (CI114).
*
* Revision 40.10  93/03/26  17:41:10  Jim2
* Removed the transition from Unknown to Mouse state.  Always force this through the mouse state.
*
* Revision 40.9  93/03/26  14:10:35  Jim2
* Removed call to OpenResource.  Documented how/when this routine
* is safe from interrupts.
*
* Revision 40.8  93/03/26  11:18:32  Jim2
* Altered the test for possible joystick while in mouse state.
* Added a bit to allow direct transitions from the unknown state
* to the joystick state.
*
* Revision 40.7  93/03/19  11:31:44  Jim2
* Absorbed the resource grabbing code.  Changed the program flow
* to handle double controllers.
*
* Revision 40.6  93/03/12  20:21:51  Jim2
* Moved the status information to a port specific location which is what
* is actually placed into a2 rather than just a pointer to the
* last value read.
*
* Revision 40.5  93/03/10  19:52:45  Jim2
* The method for updating ll_Port?Status did not work well with
* the use of these fields for general ReadJoyPort status stuff, so
* I grew the seperate status stuff a new filed in the library base.
*
* Revision 40.4  93/03/04  11:53:54  Jim2
* Tumbled the code ordering and added support for returning the
* buttons for an unknown controller.
*
* Revision 40.3  93/03/02  13:24:24  Jim2
* Changed all of the references from game.library to lowlevel.library.
*
* Revision 40.2  93/03/01  16:01:34  Jim2
* Added NOTE to the autodoc to show the true nature of the beast.
*
* Revision 40.1  93/02/19  17:48:13  Jim2
* Brought the autodoc in line with standard format.  Added
* better description for the game controller buttons.  Removed
* Dave's controller picture.
*
* Revision 40.0  93/02/11  17:33:03  Jim2
* Change to use the new single include file.
*
* Revision 39.12  93/01/20  13:18:48  brummer
* fix autodoc tab alignment
*
* Revision 39.11  93/01/19  14:20:07  brummer
* Update AUTODOC with diagram of the Game Controller
*
* Revision 39.10  93/01/18  18:03:29  brummer
* Seperated initialization code into seperate module
* Updated to use "almost semaphore" with gameport and new initialization code
* Updated to prevent reentrance because of game controller clocking
* Updated Autodocs
*
* Revision 39.9  93/01/14  10:48:43  brummer
* Fix to prevent invalid game controller clocks on Jim's 4000.  Further
* testing on other platforms is still necessary.
*
* Revision 39.8  93/01/12  16:58:41  brummer
* Fixed the previous fix.
*
* Revision 39.7  93/01/12  10:56:12  brummer
* Fix to extra mouse state check added in previous rev,
* Updated comments in code to reflect actions in each state.
*
* Revision 39.6  93/01/11  16:04:55  brummer
* Add temporary fix for right mouse button being stuck on when mouse is in port 1.
*
* Revision 39.5  93/01/11  15:33:03  brummer
* Added extra test to mouse state to prevent sperious returns of
* joystick type.
*
* Revision 39.4  93/01/07  15:57:27  brummer
* Added /gamebase.i to the include file list.
*
* Revision 39.3  93/01/07  15:38:52  brummer
* Updated to support dynamic changing controller types.
* Added 1 extra CIA delay after enabling game ctlr MUX.
*
* Revision 39.2  93/01/05  12:28:45  Jim2
* *** empty log message ***
*
* Revision 39.1  93/01/05  12:02:14  Jim2
* Renamed from GetJoyPortEvent.asm.  Also changed the bit flag
* defintions.
*
* Revision 39.0  92/12/21  11:41:18  Jim2
* Initial Release.
*
*
*
*	(C) Copyright 1992 Commodore-Amiga, Inc.
*	    All Rights Reserved
*
******************************************************************************

                NOLIST
                INCLUDE "exec/ables.i"
                INCLUDE "exec/interrupts.i"
                INCLUDE "exec/io.i"
                INCLUDE "exec/lists.i"
                INCLUDE "exec/macros.i"
                INCLUDE "exec/memory.i"
                INCLUDE "exec/nodes.i"
                INCLUDE "exec/strings.i"
                INCLUDE "exec/types.i"
                INCLUDE "hardware/custom.i"
                INCLUDE "hardware/cia.i"
                INCLUDE "hardware/intbits.i"
                LIST
                INCLUDE "JoyPortInternal.i"
                INCLUDE "/lowlevelbase.i"
                INCLUDE "/macros.i"
                INCLUDE "/lowlevel.i"


                XREF    _intena
                XREF    _custom
                XREF    _ciaa

                SECTION code

                XDEF    ReadJoyPort
                XDEF    SetJoyPortAttrs
                XDEF    RJP_VBlank_Int
                XDEF    RJP_Joy_Direction

******* lowlevel.library/ReadJoyPort *****************************************
*
*   NAME
*	ReadJoyPort -- return the state of the selected joy/mouse port. (V40)
*
*   SYNOPSIS
*	portState = ReadJoyPort(portNumber);
*	D0                      D0
*
*	ULONG ReadJoyPort(ULONG);
*
*   FUNCTION
*	This function is used to determine what device is attached to the
*	joy port and the current position/button state. The user may attach
*	a mouse, game controller, or joystick to the port and this function
*	will dynamically detect which device is attached and return the
*	appropriatly formatted portState.
*
*	To determine the type of controller that is attached, this function
*	clocks the game controller and/or interprets changes in the joy
*	port data. Valid clocked data from the game controller is immediately
*	detected. However, to accuratly determine if a mouse or joystick is
*	attached, several calls to this function are required along with some
*	movement at the joy port by the user.
*
*	This function always executes immediatly.
*
*	This is a low level single threaded function that does not fit the
*	normal Amiga multitasking model. Only one task can be executing
*	this routine at any time. All others will return immediately with
*	JP_TYPE_NOTAVAIL.
*
*	The nature of this routine is not meant to encourage non-multitasking
*	friendly programming practices like polling loops. If your task
*	is waiting for a transition to be returned use a WaitTOF() between
*	calls to minimize the total system impact.
*
*	When called the first time, for each port, this function attempts to
*	acquire certain system resources. In order to aquire these resources
*	this function MUST be called from a task, or a DOS process. If this
*	function fails to aquire the necessary resources, it will
*	return with JP_TYPE_NOTAVAIL. Once the resources are aquired (return
*	value other than JP_TYPE_NOTAVAIL) this function may be used in
*	interrupts.
*
*   INPUTS
*	portNumber - port to read, in the range 0 to 3.
*
*   RESULT
*	portState - bit map that identifies the device and the current
*	            state of that device. The format of the bit map is
*	            dependant on the type of device attached.
*
*	            The following constants from <libraries/lowlevel.h>
*	            are used to determine which device is attached and
*	            the state of that device.
*
*	            The type of device can be determined by applying
*	            the mask JP_TYPE_MASK to the return value and comparing
*	            the resultant value with the following:
*
*	                JP_TYPE_NOTAVAIL        port data unavailable
*	                JP_TYPE_GAMECTLR        game controller
*	                JP_TYPE_MOUSE           mouse
*	                JP_TYPE_JOYSTK          joystick
*	                JP_TYPE_UNKNOWN         unknown device
*
*	            If type = JP_TYPE_GAMECTLR the bit map of portState is:
*	                JPF_BUTTON_BLUE         Blue - Stop
*	                JPF_BUTTON_RED          Red - Select
*	                JPF_BUTTON_YELLOW       Yellow - Repeat
*	                JPF_BUTTON_GREEN        Green - Shuffle
*	                JPF_BUTTON_FORWARD      Charcoal - Forward
*	                JPF_BUTTON_REVERSE      Charcoal - Reverse
*	                JPF_BUTTON_PLAY         Grey - Play/Pause
*	                JPF_JOY_UP              Up
*	                JPF_JOY_DOWN            Down
*	                JPF_JOY_LEFT            Left
*	                JPF_JOY_RIGHT           Right
*
*	            If type = JP_TYPE_JOYSTK the bit map of portState is:
*	                JPF_BUTTON_BLUE         Right
*	                JPF_BUTTON_RED          Fire
*	                JPF_JOY_UP              Up
*	                JPF_JOY_DOWN            Down
*	                JPF_JOY_LEFT            Left
*	                JPF_JOY_RIGHT           Right
*
*	            If type = JP_TYPE_MOUSE the bit map of portState is:
*	                JPF_BUTTON_BLUE         Right mouse
*	                JPF_BUTTON_RED          Left mouse
*	                JPF_BUTTON_PLAY         Middle mouse
*	                JP_MVERT_MASK           Mask for vertical counter
*	                JP_MHORZ_MASK           Mask for horizontal counter
*
*   SEE ALSO
*	SetJoyPortAttrs()
*
******************************************************************************
*
* The following registers are used thoughtout the routine
*	d4 - Bit in the CIA for the fire line.
*	d5 - Word flag for accessing the output enable for the middle mouse button.
*	d6 - Used for building the return value.
*	d7 - Value read from the correct joyport.
*	a2 - Points to port specific structure.
*	a3 - Points to the base of the custom registers
*	a4 - Points to the base of the CIA  A chip
*	a5 - Lowlevel.base
*
******************************************************************************

                XDEF    ReadJoyPort
PortOffsetTable:
                dc.w    ll_Port0State,ll_Port1State,ll_Port2State,ll_Port3State

ReadJoyPort:

** Painful redirection code.  I hate to do it, but it's necessary.  A little
** pain here saves MUCH more time later.

               move.w  d0,d1                               ; save port #
               add.b   d1,d1                               ; times 2 -- each table entry=2
               lea.l   PortOffsetTable,a0                  ;
               move.w  0(a0,d1.w),d1                       ; get base offset for that struct
               lea.l   0(a6,d1.w),a0                       ; get ptr to correct state struct
               move.l  lljp_RJPVector(a0),d1               ; grab contents of vector
               beq.s   201$                                ; if no redirect, use sensing code
               move.l  d1,a0                               ; else move ptr to address reg
               jmp     (a0)                                ; and jmp there.
201$

* regular code

                movem.l d2-d7/a2-a6,-(sp)

                move.l  #_custom,a3
                move.l  #_ciaa,a4
                move.l  a6,a5
                move.l  #JP_TYPE_NOTAVAIL,d6                ;Intialize the return value to NotAvail
                move.l  d0,d2
                cmp.l   #3,d2
                bhi     RJP_NotEntered                      ;Is this a valid port?
                                                            ;Yes, valid port.
                move.l  a0,a2                               ;Use the precalced state ptr

                btst.b  #0,d2
                bne.s   rjp_InPort1
                                                            ;Init Port 0 register.
                bset    #JP_STATUSB_ALREADYRUNNING,lljp_Status(a2)      ; is this reentrance ?
                bne     RJP_NotEntered                      ;if yes, j to exit

                move.l  #(joy0dat<<16),d7                   ;Save the offset for possibly reading the game controller again.
                move.w  joy0dat(a3),d7                      ;d7 now contains the port value, preserve d7.
                move.w  #CIAB_GAMEPORT0,d4
                move.w  #POTGOF_OE8,d5
                btst    #JP_STATUSB_VBLANK_ACQUIRED,lljp_Status(a2)
                bne.s   RJP_DonePortSetup                   ;Do we need to try getting the VBlank interrupt?
                                                            ;Yes, this must be the first time through here.
                move.l  ll_ExecBase(a5),a6
                                                            ;
                                                            ;Disable interrupts and find gameport.device on
                                                            ;the list.
                                                            ;
                move.l  IVVERTB+IV_DATA(a6),a0              ; a0 gets vert blank list
                lea     GAMEPORT_INT(pc),a1                 ; a1 gets ptr to name we're lookin fo
                JSRLIB  Forbid                              ;Don't want anyone else mucking with the list at the same time.
                JSRLIB  FindName                            ; d0 gets ptr to IS
                beq.s   2$                                  ;If not found, do nothing.
                                                            ;Entry found, save pointer and remove it from list.
                bset    #JP_STATUSB_VBLANK_ACQUIRED,lljp_Status(a2)     ; set acquired flag
                bclr    #JP_STATUSB_FIRST_INIT_REQ,lljp_Status(a2)
                move.l  d0,ll_RJP_Saved_IS(a5)              ; save ptr to gameport IS
                move.l  d0,a1                               ; a1 gets entry to remove
                moveq   #INTB_VERTB,d0                      ; d0 gets interrupt number
                JSRLIB  RemIntServer                        ; remove entry from list
                                                            ;Add ReadJoyPort's entry to the list.
                moveq   #INTB_VERTB,d0                      ; d0 gets interrupt number
                lea     ll_RJP_Vblank_IS(a5),a1             ; a1 gets ptr to our entry
                JSRLIB  AddIntServer                        ; add entry to list
2$:                                                         ;Enable interrupts.
                JSRLIB  Permit
                bsr     RJP_Joy_Direction
                beq.s   Port0Joy                            ;Was the initial reading a valid mouse?
                                                            ;
                                                            ;The joyport reading was for a mouse.  So set the
                                                            ;mouse as the current state.  Also set the count to
                                                            ;maximum.
                                                            ;
                or.l    #JP_TYPE_MOUSE|(JP_MOUSE_2_RECHECK<<16),d7
                bra.s   WritePort0
                                                            ;Can't tell for sure what type of controller is attached.
Port0Joy:       or.l    #JP_TYPE_UNKNOWN,d7
WritePort0:     move.l  d7,lljp_PreviousValue(a2)           ;Set the previous counter to be the current counter.
                bra.s   RJP_DonePortSetup


                                                            ;Init port 1 registers :
rjp_InPort1:
                bset    #JP_STATUSB_ALREADYRUNNING,ll_Port0State+lljp_Status(a5)      ; is this reentrance ?
                bne     RJP_NotEntered                      ; if yes, j to exit

                move.l  #(joy1dat<<16),d7                   ;Save the offset for possibly reading the game controller again.
                move.w  joy1dat(a3),d7                      ;d7 now contains the port value, preserve d7.
                move.w  #CIAB_GAMEPORT1,d4
                move.w  #POTGOF_OE12,d5
RJP_DonePortSetup:                                          ;All port specific initialization is complete.
                move.l  ll_PotGoResource(a5),a6
                                                            ;Determine if first call init is required :
                bclr    #JP_STATUSB_FIRST_INIT_REQ,lljp_Status(a2)
                beq.s   RJP_PortInited                      ;if no, j to continue
                                                            ;Establish default type of controller, Mouse or Unknown.
                bsr     RJP_Joy_Direction
                beq.s   InitUnknown
                                                            ;The reading can only be a mouse.
                or.l    #JP_TYPE_MOUSE|(JP_MOUSE_2_RECHECK<<16),d7
                bra.s   DoneInit

InitUnknown:    or.l    #JP_TYPE_UNKNOWN,d7
DoneInit:       move.l  d7,lljp_PreviousValue(a2)           ;Set the initial port reading.
                                                            ;Generate the map of POTGO bits to be aquired.
                move.w  d5,d1
                lsr.w   #1,d1
                or.w    d5,d1
                move.w  d1,d0
                lsl.w   #2,d1
                or.w    d1,d0
                move.w  d0,d3
                JSRLIB  AllocPotBits
                cmp.w   d3,d0
                beq.s   RJP_PortInited                      ;Did we get the bits we wanted?
                                                            ;
                                                            ;No, free the bits be did get and reset the flag
                                                            ;so we will try again the next time through.
                                                            ;
                JSRLIB  FreePotBits
                bset    #JP_STATUSB_FIRST_INIT_REQ,lljp_Status(a2)
                bra     RJP_NotAvail_State

RJP_PortInited:                                             ;Check to see if we are a double controller.
rjp_NotDoubleController:                                    ;Init common registers.
                move.w  (a2),d2                             ;Get the count for the port.
                and.w   #$00FF,d2                           ;The count is in the low order byte.
                bne.s   RJP_NoGameTest

; *****************************************************************************
;
; The following block will clock the button settings out of the game
; controller.  The bits will be collected and returned in d1.
;
;       requires:       a2 = ptr to JoyPortState
;                       a3 = ptr to custom register base
;                       a4 = ptr to ciaa register base
;                       d4 = bit mask for Fire Button
;                       d5 = mask to set appropriate Output Enable for Mux
;
RJP_Clock_Game_Ctlr:

                bset    #JP_STATUSB_CLOCKING_CTLR,lljp_Status(a2)       ; critical section flag

                bset    d4,ciaddra(a4)                      ;Set direction for fire button.
                bclr    d4,ciapra(a4)                       ;Lower the clock.
                                                            ;
                                                            ;Enable game controller mux (enable the middle
                                                            ;button as an output and send it a low).
                                                            ;
                move.w  d5,d1
                lsr.w   #1,d1
                or.w    d5,d1                               ;d1 has the mask of bits to be changed.
                move.l  d1,-(sp)                            ;Save the mask for restoring.
                move.w  d5,d0                               ;Output a 0.
                JSRLIB  WritePotgo
                move.l  #_custom+potinp,a0                  ;Get read address into a register this decreases the time in the loop.
                move.w  d5,d1
                lsl.w   #1,d1                               ;Get mask for reading controller data.
                                                            ; Set loop counter and clear temp data register.
                CLEAR   d3
                moveq   #8,d0                               ; d0 is loop counter
                btst    #JP_STATUSB_2nd_CTLR,lljp_Status(a2)
                beq.s   rjp_GameStartHere
                                                            ;The double controller requires being clocked nine extra times.
                add.w   #9,d0
                bra.s   rjp_GameStartHere
                                                            ; Loop for all bits :
RJP_Clock_Game_Ctlr_Loop:
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
rjp_GameStartHere:
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                move.w  (a0),d2                             ; d2 gets POTGOR data
                                                            ;Clock for next value.
                bset    d4,ciapra(a4)                       ;Make the clock high
                bclr    d4,ciapra(a4)                       ;Lower the clock.
                                                            ;Munge the button data bit into d3.
                and.w   d1,d2
                bne.s   6$                                  ;Buttons are active low.
                                                            ;The button was pressed.
                bset    d0,d3                               ;set button down in temp reg.
6$:             dbra    d0,RJP_Clock_Game_Ctlr_Loop         ; loop for all bits
                                                            ;
                                                            ;Disable game controller mux (enable the middle
                                                            ;button as an output and send it a high).
                                                            ;
                move.l  (sp)+,d1
                move.w  d1,d0
                JSRLIB  WritePotgo
                bclr    d4,ciaddra(a4)                      ;Restore direction of fire button to input :
                bclr    #JP_STATUSB_CLOCKING_CTLR,lljp_Status(a2)       ; critical section flag
                and.w   #$1FF,d3                            ;Only want to return low order bits for a double controller.
                lsr.w   #1,d3
                bcc.s   RJP_NoGameTest                      ;Last bit clocked must be high for the controller.

                cmp.b   #$FF,d3
                bne     RJP_GameCtlr_State                  ;Next to last bit must be a zero for the controller.
                                                            ;The port is not contected to a controller.
RJP_NoGameTest:
                btst    #JP_STATUSB_2nd_CTLR,lljp_Status(a2)
                bne.s   RJP_NotAvail_State                  ;If this port is for a double controller and
                                                            ;we don't detected it it can't be used.
; *****************************************************************************
;
; The following section will take the raw button data from a Joyport and
; update the appropriate bits in the return value d6.  The buttons that will
; be updated are FIRE, RIGHT, and MIDDLE.
;
;       On Entry:       a3 = ptr to custom register base
;                       a4 = ptr to ciaa register base
;                       d4 = bit mask for the Fire Button.
;                       d5 = mask for Output Enable for the middle button.

                move.w  d5,d1                               ;Assemble the mask for setting the buttons to one.
                lsr.w   #1,d1
                or.w    d5,d1
                move.w  d1,d0
                lsl.w   #2,d1
                or.w    d1,d0
                move.w  d0,d1
                JSRLIB  WritePotgo                          ;Clear any accumulated button state.

                                                            ;Get fire button.
                move.b  ciapra(a4),d1                       ;d1 gets fire button state
                btst    d4,d1
                bne.s   1$                                  ;All buttons are active low.

                ori.l   #JPF_BTN2,d6                        ;set fire button in temp reg
1$:                                                         ;Get right button.
                move.w  potinp(a3),d1                       ;d1 gets POTGOR data
                not.w   d1                                  ;make data high active
                move.w  d1,d2                               ;save for later use
                lsr.w   #1,d1                               ;Shift so we can use the output enable as the mask.
                and.w   d5,d1                               ;Clear all except right button
                beq.s   2$                                  ;Test the right button.

                ori.l   #JPF_BTN1,d6                        ;set right button in temp reg
2$:                                                         ;Get middle button.
                move.w  d2,d1                               ;d1 gets saved data
                lsl.w   #1,d1                               ;Shift so we can use the output enable as the mask.
                and.w   d5,d1                               ;Clear all except middle button.
                beq.s   3$                                  ;Test the middle button.

                ori.l   #JPF_BTN7,d6                        ;set middle button in temp reg
3$:             move.l  (a2),d2                             ;Get the prevous controller type.
                and.l   #(3<<28),d2                         ;There are only four possible values.
                beq.s   RJP_Unknown_State
                                                            ;We've masked it down to one of the four.
                rol.l   #5,d2                               ;Shift the type so it can be used as an offset into a jump table.
                move.w  RJP_State_JTBL-2(pc,d2.w),d2
                jmp     RJP_State_JTBL(pc,d2.w)

RJP_Return:                                                 ;Restore registers and exit.
                move.w  d7,2(a2)                            ;joyport reading for next time.
RJP_NotAvail_State:

RJP_1st_CTLR:   bclr    #JP_STATUSB_ALREADYRUNNING,lljp_Status+ll_Port0State(a5)      ; clr for reentrance
RJP_NotEntered
                move.l  d6,d0
                movem.l (sp)+,d2-d7/a2-a6
                rts
;
; ReadJoyPort state jump table :
;
RJP_State_JTBL: dc.w    RJP_Unknown_State-RJP_State_JTBL        ;Was Game controller, now must be unknown.
                dc.w    RJP_Mouse_State-RJP_State_JTBL          ;Was mouse.
                dc.w    RJP_Joystk_State-RJP_State_JTBL         ;Was joystick.



; *****************************************************************************
;
; The following section will handle controller STATE = UNKNOWN.  The
; actions for this state are :
;
;       If there is a change in the port data try the joystick state.
;
;       On Entry:       a2 = ptr to port status word
;                       d6 = Current built return value.
;                       d7 = joyport data
;
;       On Exit:        Set new state.
;
RJP_Unknown_State:

                                                            ;Determine if Joy Port data has changed :
                cmp.w   2(a2),d7
                bne     ms_ChangeToJoy                      ;The joystick state will vector to the correct state based on the reading.

UnknownComplete:
                or.l    #JP_TYPE_UNKNOWN,d6                 ;Set the return state.
                move.w  #(JP_TYPE_UNKNOWN>>16),(a2)         ;Remember the state for next time.
                bra     RJP_Return                          ;Let's ge out of here.

; *****************************************************************************
;
; The following section will handle controller STATE = GAMECTLR.  The
; actions for this state are :
;
;       - Guard against someone inserting the mouse and holding down the
;         fire button.  This looks like a game controller, but we must be
;         transitioning from the unknown state.
;       - Get the buttons in the correct register and location.
;       - Reread the current position in case we are a double controller.
;       - Call subroutine to translate the direction values.
;       - Jump to common return location with return value in d6.
;
;       On Entry:       a2 = ptr to port status word
;                       d3 = button state.
;                       d7(high order word) = Offset of mouse counter register.
;
;       On Exit:        d6 updated with current controller state and jump to common exit
;
RJP_GameCtlr_State:

                move.w  #(JP_TYPE_GAMECTLR>>16),d0
                cmp.w   (a2),d0
                beq.s   RJP_FinishGame                      ;If the old value is a game controller no problem.
                                                            ;
                                                            ;The old value was not a game controller.

                move.w  d0,-(sp)
                move.w  d5,d1                               ; Clear the output enables that were probably set
                lsl.w   #2,d1                               ; by the joy/mouse read code.  For the game controller,
                or.w    d5,d1                               ; they should be INPUTS.
                moveq.l #0,d0                               ; They ought stay in this state until a possible
                JSRLIB  WritePotgo                          ; joystick/mouse comes into play.
                move.w  (sp)+,d0

                                                            ;Reclock so we don't get misled.
                                                            ;
                move.w  d0,(a2)                             ;Remember this type just incase.
                bra     RJP_Clock_Game_Ctlr
                                                            ;We're really sure we're a game controller.
RJP_FinishGame:
                swap    d3                                  ; move button data to return location
                move.l  d3,d6                               ; update return value
                swap    d7
                move.w  0(a3,d7.w),d7                       ;Read the joystick direction.  Needed for the double controller.
                bsr     RJP_Joy_Direction                   ; d0 gets direction values in 0..3
                or.w    d0,d6                               ; update return value
                ori.l   #JP_TYPE_GAMECTLR,d6                ; set controller type field
                bra     RJP_Return

; *****************************************************************************
;
; The following section will handle controller STATE = MOUSE.  The
; actions for this state are :
;
;               - No change do nothng.
;               - Check for a valid joystick.  If one is found decrement the
;                 counter.  When the counter gets to zero change state to
;                 joystick.
;
;       On Entry:       a2 = ptr to port status word
;                       d6 = Buttons pressed
;                       d7 = Joyport data
;
;       On Exit:        d6 updated with return value and jump to common exit
;
;       Regs used:      d0,a0
;
RJP_Mouse_State:
                                                            ;Determine if there is any change in port data.
                cmp.w   2(a2),d7
                beq.s   CompleteMouse
                                                            ;Data has changed check for possible joystick.
                bsr.s   RJP_Joy_Direction
                bne.s   RJP_Mouse_State_06                  ;If not a joystick reset counter and exit.
                                                            ;
                                                            ;Reading could be a joystick, check to see how
                                                            ;quickly it is changing.
                                                            ;
                move.l  ll_VBCounter(a5),a0
                move.l  (a0),d0                             ;Get the current VBlank count.
                sub.l   lljp_LastVBlank(a2),d0
                beq.s   ms_PossibleMouse                    ;Is it the same as the last VBlank count?
                                                            ;No the VBlank counter has changed.
                subq.l  #1,d0
                bge.s   ms_ManyVB                           ;Has at least one complete VBlank happened?
                                                            ;Yep.
                bset    #JP_STATUSB_WAS_JOY,lljp_Status(a2)     ;Remember there has been a joystick like event.
                bne.s   RJP_Mouse_State_06                  ;Two consecutive joystick values.  Not really a joystick.

ms_ManyVB:                                                  ;Ok we have a nice joystick value remember the
                                                            ;VBlank counter and decrement the count of joystick
                                                            ;events.  Once it reaches zero change to the
                                                            ;joystick state.
                                                            ;
                move.l  (a0),lljp_LastVBlank(a2)
                move.w  (a2),d0                             ;Get the count.
                subq.w  #1,d0
                cmp.w   #(JP_TYPE_MOUSE>>16),d0             ;The count also has the type, so if
                blt.s   ms_ChangeToJoy                      ;type changed the count went to -1.
                                                            ;Still a mouse.
                move.w  d0,(a2)                             ;Remember the new count.
                bra.s   ms_PossibleJoy

RJP_Mouse_State_06:                                         ;Not a joystick event remember the VBlank count.
                move.l  ll_VBCounter(a5),a0
                move.l  (a0),lljp_LastVBlank(a2)
ms_PossibleMouse:                                           ;A definite mouse event reset the counter and clear
                                                            ;the flag that show the last event was a joystick
                                                            ;event.
                move.w  #(JP_TYPE_MOUSE>>16)!JP_MOUSE_2_RECHECK,d0      ;reset counter.
                move.w  d0,(a2)                             ;and save it.
CompleteMouse:  and.b   #~JP_STATUSF_WAS_JOY,lljp_Status(a2)    ;Clear the joystick event flag.
ms_PossibleJoy: or.w    d7,d6                               ;Put mouse counters into the return value.
                ori.l   #JP_TYPE_MOUSE,d6                   ;Put the controller type into the return value.
                bra     RJP_Return                          ;Go to the common exit

ms_ChangeToJoy: move.w  #(JP_TYPE_JOYSTK>>16)!1,(a2)        ;Recheck, because it could be a game controller.


; *****************************************************************************
;
; The following subroutine will handle controller STATE = JOYSTK.  The
; actions for this state are :
;
;       - Call routine to get direction status and update return value
;       - Determine if data is valid for joystick :
;               - If not valid for joystick, clear counter and set state = MOUSE
;                 in saved state and jump to mouse state routine
;       - Decrement counter in saved status
;       - If the counter has not underflowed, return joystick type data
;               - underflow reset counter
;
;       On Entry:       a2 = ptr to port status word
;                       d6 = Buttons pressed
;                       d7 = Joyport data
;
;       On Exit:        d6 updated with return value and jump to common exit
;
;       Regs used:      d0
;
RJP_Joystk_State:
                                                            ;Call routine to get direction status.
                bsr.s   RJP_Joy_Direction                   ;d0 gets direction values in 0..3
                beq.s   RJP_Joystk_State_08                 ;Are the directions valid for joystick?
                                                            ;Data is invalid, go to mouse state.
                move.w  #(JP_TYPE_MOUSE>>16)|JP_MOUSE_2_RECHECK,(a2)
                bra     RJP_Mouse_State

RJP_Joystk_State_08:                                        ;Data is valid delay for several times before
                                                            ;checking for other controller.
                                                            ;
                move.w  d0,d6                               ;Save the directions into the return value.
                move.w  (a2),d0                             ;Get the count.
                sub.w   #1,d0
                cmp.w   #(JP_TYPE_JOYSTK>>16),d0            ;The count also has the type, so if
                bge.s   UpdateJoystk                        ;type changed the count went to -1.
                                                            ;Counter has gone to -1, reset.
                move.w  #(JP_TYPE_JOYSTK>>16)|JP_JOYSTK_2_RECHECK,d0
UpdateJoystk:   move.w  d0,(a2)                             ;Remember the counter.
                ori.l   #JP_TYPE_JOYSTK,d6                          ;set controller type field
                bra     RJP_Return

; *****************************************************************************
;
; The following subroutine will take the raw direction data from a Joy
; Port and update the appropriate bits for returning in d0.  The values
; will also be validated.
;
;       On Entry:       d7 = Reading from the joypot
;
;       On Exit:        d0 = bits 3..0 updated with direction status
;                       d1 = nonzero if data is not valid for joystick
;                       Cond Code = EQ if data is valid for joystick
;                       Cond Code = NE if data is not valid for joystick
;
;       Regs used:      d0,d1
;
RJP_Joy_Direction:
                move.w  d7,d1                               ; d1 gets port data
                move.w  d1,d0
                lsr.w   #1,d0                               ;Move left and write over top of up and down.
                eor.w   d0,d1                               ;Derive up and down.
                and.w   #JOYDATF_Y0|JOYDATF_X0,d1           ;Mask out non-joystick bits.
                and.w   #JOYDATF_Y0|JOYDATF_X0,d0           ;Mask out non-joystick bits.
                ror.b   #1,d0                               ;Roll right to bit 7 so it is adjacent to left.
                ror.b   #1,d1                               ;Roll down to bit 7 so it is adjacent to up.
                lsr.w   #7,d0                               ;Shift left,right to the correct places.
                lsr.w   #5,d1                               ;Shift up,down to the correct place.
                or.w    d1,d0                               ;Assemble the answer in d0.
                move.b  d0,d1
                lsr.b   #1,d1                               ;line up left on top of right and up on top of down.
                and.b   #~JPF_JOY_LEFT,d1                   ;Don't want to be distracted by a diagonal to the left and down.
                and.b   d0,d1                               ;This will be non-zero if opposite directions are true.
                rts

; *****************************************************************************
;
; The following subroutine will be a server on the Vertical Blank
; interrupt list.  The purpose of this routine is to allow GAMEPORT server to
; run only when the ReadJoyPort function is NOT clocking the controller.
; A flag in the Gamebase will be set by RJP_Clock_Game_Ctlr routine during
; its critical clocking section.
; This server will be added by the RJP_First_Call_Init routine.
;
; The following actions will be taken :
;
;       - Determine if the Critical section is being executed by RJP_Clock_Game_Ctlr
;               - If yes, return
;               - If no, call GAMEPORT interrupt server
;
;       On Entry:       a1 = pointer to IS_DATA (game library base)
;                       a5 = vector to interrupt code
;
;       On Exit:        vector to GAMEPORT Vblank server or
;                       return to exec (Z flag must be set)
;
;       Regs used:      d0
;
RJP_VBlank_Int:
                                                            ;Determine if critical section is active.
                btst    #JP_STATUSB_CLOCKING_CTLR,ll_Port0State+lljp_Status(a1) ; critical section active ?
                bne.s   RJP_Vblank_Int_08                   ; if yes, j to skip GAMEPORT server
                                                            ;
                                                            ;Critical section not active, vector to GAMEPORT
                                                            ;server.
                                                            ;
                move.l  ll_RJP_Saved_IS(a1),a1              ; a1 gets pointer to GAMEPORT int structure
                move.l  IS_CODE(a1),a5                      ; a5 gets GAMEPORT int code vector
                move.l  IS_DATA(a1),a1                      ; a1 gets GAMEPORT int data pointer
                jmp     (a5)                                ; jump to GAMEPORT interrupt server

RJP_Vblank_Int_08:                                          ;Critical section is active, return to exec :
                moveq.l #0,d0                               ; set Z flag
                rts                                         ; return to exec

******* lowlevel.library/SetJoyPortAttrsA ***********************************
*
*   NAME
*	SetJoyPortAttrsA -- change the attributes of a port.  (V40.27)
*	SetJoyPortAttrs -- varargs stub for SetJoyPortAttrsA().  (V40.27)
*
*   SYNOPSIS
*	success = SetJoyPortAttrsA(portNumber, tagList);
*	D0                         D0          A1
*
*	BOOL SetJoyPortAttrsA(ULONG, struct TagItem *);
*
*	Success = SetJoyPortAttrs(portNumber, firstTag, ...);
*
*	BOOL SetJoyPortAttrs(Tag, ...);
*
*
*   FUNCTION
*	This function allows modification of several attributes held by
*	ReadJoyPort() about both it's operation and the type of controller
*	currently plugged into the port.
*
*	ReadJoyPort()'s default behavior is to attempt to automatically
*	sense the type of controller plugged into any given port, when
*	asked to read that port. This behavior is beneficial, to allow
*	simple detection of the type of controller plugged into the port.
*	Unfortunately, rare cases are possible where extremely fine
*	mouse movements appear to be real joystick movements. Also, this
*	ability to auto-sense the controller type causes most reads to
*	take longer than if there were no auto-sensing.
*
*	SetJoyPortAttrs() is intended to provide for both of these cases.
*	It allows the programmer to notify ReadJoyPort() to stop spending
*	time attempting to sense which type of controller is in use -- and,
*	optionally, to force ReadJoyPort() into utilizing a certain
*	controller type.
*
*   INPUTS
*	portNumber - the joyport in question (0-3).
*	tagList - a pointer to an array of tags providing parameters
*	          to SetJoyPortAttrs(); if NULL, the function
*	          will return TRUE, but do nothing.
*
*   TAGS
*	SJA_Type (ULONG) - Sets the current controller type to the mouse,
*			joystick, or game controller. Supply one of
*			SJA_TYPE_GAMECTLR, SJA_TYPE_MOUSE, SJA_TYPE_JOYSTK,
*			or SJA_TYPE_AUTOSENSE. If SJA_TYPE_AUTOSENSE is used,
*			ReadJoyPort() will attempt to determine the type of
*			controller plugged into the given port automatically.
*			If one of the other types is used, ReadJoyPort() will
*			make no attempt to read the given controller as
*			anything other than the type specified. The default
*			type is SJA_AUTOSENSE.
*
*	             	Note -- if you set the type to anything other than
*	             	auto-sense, it's your responsibility to return it
*	             	to auto-sense mode before exiting.
*
*	SJA_Reinitialize (VOID) - Return a given port to it's initial state,
*		     	forcing a port to deallocate any allocated resources;
*	             	return the implied type to SJA_TYPE_AUTOSENSE.
*
*   RESULT
*	success - TRUE if everything went according to plan, or FALSE upon
*		  failure
*
*   SEE ALSO
*	ReadJoyPort(), <libraries/lowlevel.h>
*
******************************************************************************
SetJoyPortAttrs:
                movem.l     d0/d2/a2/a3,-(sp)

* Save d0, a1, our parameters, on the stack, and then utilize some code snipped
* from ReadJoyPort() to initialize things.  Icky!  A stateless and state-full
* model all mixed up!  Don't blame me -- it's not my fault.  :'|

                movem.l     d0/a1/a5/a6,-(sp)
                move.l      a6,a5
                lea.l       ll_Port0State(a6),a2
                btst        #JP_STATUSB_VBLANK_ACQUIRED,lljp_Status(a2)
                bne.s       3$                                  ;Do we need to try getting the VBlank interrupt?
                                                                ;Yes, this must be the first time through here.
                move.l      ll_ExecBase(a5),a6
                                                                ;
                                                                ;Disable interrupts and find gameport.device on
                                                                ;the list.
                                                                ;
                move.l      IVVERTB+IV_DATA(a6),a0              ; a0 gets vert blank list
                lea         GAMEPORT_INT(pc),a1                 ; a1 gets ptr to name we're lookin fo
                JSRLIB      Forbid                              ;Don't want anyone else mucking with the list at the same time.
                JSRLIB      FindName                            ; d0 gets ptr to IS
                beq.s       2$                                  ;If not found, do nothing.
                                                                ;Entry found, save pointer and remove it from list.
                bset        #JP_STATUSB_VBLANK_ACQUIRED,lljp_Status(a2)     ; set acquired flag
                bclr        #JP_STATUSB_FIRST_INIT_REQ,lljp_Status(a2)
                move.l      d0,ll_RJP_Saved_IS(a5)              ; save ptr to gameport IS
                move.l      d0,a1                               ; a1 gets entry to remove
                moveq       #INTB_VERTB,d0                      ; d0 gets interrupt number
                JSRLIB      RemIntServer                        ; remove entry from list
                                                                ;Add ReadJoyPort's entry to the list.
                moveq       #INTB_VERTB,d0                      ; d0 gets interrupt number
                lea         ll_RJP_Vblank_IS(a5),a1             ; a1 gets ptr to our entry
                JSRLIB      AddIntServer                        ; add entry to list
2$:                                                             ;Enable interrupts.
                JSRLIB      Permit
3$
                movem.l     (sp)+,d0/a1/a5/a6

* And now ... the normal code for SetJoyPortAttrs():

                cmp.l       #3,d0                   * Check port # for vailidity.
                bls.s       0$                      * If okay, continue
                moveq.l     #0,d0                   * else, set return value to FALSE
                bra         999$                    * and branch to the exit.
0$

                add.b       d0,d0                   * times 2 -- each table entry=2
                lea.l       PortOffsetTable,a0      *
                move.w      0(a0,d0.w),d0           * get base offset for that struct
                lea.l       0(a6,d0.w),a3           * get ptr to correct state struct

                moveq.l     #0,d2                   * d2 = -1, 0, 1.  Defines whether to unlock, do nothing, or lock
                move.l      a1,-(sp)                * tstate = tagptr (tstate = longword on stack)
1$              move.l      sp,a2                   * save &tstate
                move.l      a6,-(sp)                * Save library base
                move.l      ll_UtilBase(a6),a6      * Get UtilityBase
                move.l      a2,a0                   * get &tstate
                JSRLIB      NextTagItem             * d0 = NextTagItem(&tstate)
                move.l      (sp)+,a6                * recover library base
                tst.l       d0                      * end of taglist?
                beq         100$                    * yep, leave.
                move.l      d0,a0

                cmp.l       #SJA_Type,ti_Tag(a0)    * Is this tag SJA_Type?
                bne.s       11$
                move.l      ti_Data(a0),d0          * Get new type
                bne.s       111$                    * If not SJA_TYPE_SENSE, goto 101$
                moveq.l     #-1,d2                  * Set flag to "unlock"
                bra.s       112$
111$
                moveq       #12,d1                  * If a specific type, shift it into
                lsl.w       d1,d0                   * the top 4 bits of the word
                move.w      lljp_PreviousValue(a3),d1  * get old type
                and.w       #$00ff,d1                  * Mask out type bits in the old
                and.w       #$ff00,d0                  * mask out anything other than type in the new
                or.w        d0,d1                      * add new type to old
                move.w      d1,lljp_PreviousValue(a3)  * save it in the structure
                moveq.l     #1,d2                   * Set flag to "lock"
112$

11$             cmp.l       #SJA_Reinitialize,ti_Tag(a0)
                bne.s       12$


                moveq.l     #0,d0
                move.l      d0,lljp_RJPVector(a3)   * Clear jump vector (reset to autosense)

* Free potgo bits, if allocated
                FORBID
                bset        #JP_STATUSB_FIRST_INIT_REQ,lljp_Status(a3)
                bne.s       113$

                move.l      4(sp),d0                * Get port #
                bne.s       114$
                moveq.l     #0,d0
                move.w      #$0000,d0               * Port 0 bits can't be freed -- we don't own them.  What a kludge!!!
                bra.s       115$
114$            cmp.l       #1,d0                   * Port 1?
                bne.s       113$
                moveq.l     #0,d0
                move.w      #$F000,d0               * Port 1 bits
115$            move.l      a6,-(sp)
                move.l      ll_PotGoResource(a6),a6 * Get PotGoBase
                JSRLIB      FreePotBits
                move.l      (sp)+,a6
113$            PERMIT

12$

99$             bra         1$                      * Loop for next
100$
                tst.b       d2                      * What should we do?
                beq.s       101$                    * nothing ... to 101$
                bmi.s       102$                    * unlock ... to 102$
;                                                   * lock ... fall through
* Given port # and controller type, secure from the jump table the correct
* address for users to go to.
* Port = 0 to 3, controller type is also 0 to 3 (0 is worthless)
* Table entry = Port*4+Type
                moveq       #12,d0
                move.w      lljp_PreviousValue(a3),d1
                lsr.w       d0,d1                   * Controller type shift down
                move.l      4(sp),d0                * Fetch port # from the stack
                lsl.b       #2,d0                   * Port * 4
                or.b        d1,d0                   * d0 = table entry #
                lsl.b       #1,d0                   * times two, as each entry is a word
                lea.l       LockJMPTable,a0
                move.w      0(a0,d0.w),d0           * Get offset from table
                lea.l       0(a0,d0.w),a0           * Add that offset to our table ptr, get real ptr
                move.l      a0,lljp_RJPVector(a3)   * Store the pointer.

                bra.s       101$


102$            moveq.l     #0,d0                   * NULL out ptr, therefore UNLOCK
                move.l      d0,lljp_RJPVector(a3)   * And fall through ...

101$
                addq.l      #4,sp                   * remove tstate storage

                moveq.l     #1,d0                   * return TRUE

999$            movem.l     (sp)+,d0/d2/a2/a3
                rts

LockJMPTable:
                dc.w        Nothing-LockJMPTable    * Port 0, Controller unknown
                dc.w        Game0Lck-LockJMPTable   * Port 0, Game Controller
                dc.w        Mouse0Lck-LockJMPTable  * Port 0, Mouse
                dc.w        Joy0Lck-LockJMPTable    * Port 0, Joystick

                dc.w        Nothing-LockJMPTable    * Port 1, Controller unknown
                dc.w        Game1Lck-LockJMPTable   * Port 1, Game Controller
                dc.w        Mouse1Lck-LockJMPTable  * Port 1, Mouse
                dc.w        Joy1Lck-LockJMPTable    * Port 1, Joystick

                dc.w        Nothing-LockJMPTable    * Port 2, Controller unknown
                dc.w        Game2Lck-LockJMPTable   * Port 2, Game Controller
                dc.w        Nothing-LockJMPTable    * Port 2, Mouse (Not possible)
                dc.w        Nothing-LockJMPTable    * Port 2, Joystick (Not possible)

                dc.w        Nothing-LockJMPTable    * Port 3, Controller unknown
                dc.w        Game3Lck-LockJMPTable   * Port 3, Game Controller
                dc.w        Nothing-LockJMPTable    * Port 3, Mouse (Not possible)
                dc.w        Nothing-LockJMPTable    * Port 3, Joystick (Not possible)


** Nothing entry point -- for when the controller type is unknown;
**                        simply return.
Nothing:
                moveq.l     #0,d0
                rts

** Mouse1Lck -- Mouse (locked), port 1
**
Mouse1Lck:
                movem.l     d2/d4/a3-a5/a6,-(sp)
                move.l      a6,a5
                bset        #JP_STATUSB_ALREADYRUNNING,lljp_Status+ll_Port0State(a5) ;Clear that bit in lljp_Status of the Port 0 jp structure
                bne.s       999$

                move.w      #$f000,d1                       * Make the middle button an INPUT
                move.w      d1,d0
                move.l      ll_PotGoResource(a6),a6
                JSRLIB      WritePotgo

                move.l      #_custom,a3
                move.l      #_ciaa,a4
                move.w      #CIAB_GAMEPORT1,d4

                moveq.l     #0,d2
                move.b      ciapra(a4),d1
                btst        d4,d1
                bne.s       1$
                or.l        #JPF_BTN2,d2
1$

                move.w      potinp(a3),d1
                btst        #12,d1
                bne.s       2$
                or.l        #JPF_BTN7,d2
2$

                btst        #14,d1
                bne.s       3$
                or.l        #JPF_BTN1,d2
3$
                move.l      #JP_TYPE_MOUSE,d0
                move.w      joy1dat(a3),d0
                or.l        d2,d0

                bclr        #JP_STATUSB_ALREADYRUNNING,lljp_Status+ll_Port0State(a5) ;Clear that bit in lljp_Status of the Port 0 jp structure

                movem.l     (sp)+,d2/d4/a3-a5/a6
                rts

999$            moveq.l     #0,d0
                movem.l     (sp)+,d2/d4/a3-a5/a6
                rts


** Mouse0Lck -- Mouse (locked), port 0
**
Mouse0Lck:
                movem.l     d2/d4/a3-a5/a6,-(sp)
                move.l      a6,a5
                bset        #JP_STATUSB_ALREADYRUNNING,lljp_Status+ll_Port0State(a5) ;Clear that bit in lljp_Status of the Port 0 jp structure
                bne.s       999$

                move.w      #$f00,d1                       * Make the middle button an INPUT
                move.w      #$f00,d0
                move.l      ll_PotGoResource(a6),a6
                JSRLIB      WritePotgo

                move.l      #_custom,a3
                move.l      #_ciaa,a4
                move.w      #CIAB_GAMEPORT0,d4

                moveq.l     #0,d2
                move.b      ciapra(a4),d1
                btst        d4,d1
                bne.s       1$
                or.l        #JPF_BTN2,d2
1$

                move.w      potinp(a3),d1
                btst        #8,d1
                bne.s       2$
                or.l        #JPF_BTN7,d2
2$

                btst        #10,d1
                bne.s       3$
                or.l        #JPF_BTN1,d2
3$
                move.l      #JP_TYPE_MOUSE,d0
                move.w      joy0dat(a3),d0
                or.l        d2,d0

                bclr        #JP_STATUSB_ALREADYRUNNING,lljp_Status+ll_Port0State(a5) ;Clear that bit in lljp_Status of the Port 0 jp structure

                movem.l     (sp)+,d2/d4/a3-a5/a6
                rts

999$            moveq.l     #0,d0
                movem.l     (sp)+,d2/d4/a3-a5/a6
                rts


** Joy0Lck -- Joystick (locked), port 0
**
Joy0Lck:
                movem.l     d2/d4/a3-a5/a6,-(sp)
                move.l      a6,a5
                bset        #JP_STATUSB_ALREADYRUNNING,lljp_Status+ll_Port0State(a5) ;Clear that bit in lljp_Status of the Port 0 jp structure
                bne.s       999$

                move.w      #$f00,d1                       * Make the middle button an INPUT
                move.w      #$f00,d0
                move.l      ll_PotGoResource(a6),a6
                JSRLIB      WritePotgo

                move.l      #_custom,a3
                move.l      #_ciaa,a4
                move.w      #CIAB_GAMEPORT0,d4

                moveq.l     #0,d2
                move.b      ciapra(a4),d1
                btst        d4,d1
                bne.s       1$
                or.l        #JPF_BTN2,d2
1$

                move.w      potinp(a3),d1
                btst        #8,d1
                bne.s       2$
                or.l        #JPF_BTN7,d2
2$

                btst        #10,d1
                bne.s       3$
                or.l        #JPF_BTN1,d2
3$

                move.w  joy0dat(a3),d1                      ; Read UDLR

                move.w  d1,d0
                lsr.w   #1,d0                               ;Move left and write over top of up and down.
                eor.w   d0,d1                               ;Derive up and down.
                and.w   #JOYDATF_Y0|JOYDATF_X0,d1           ;Mask out non-joystick bits.
                and.w   #JOYDATF_Y0|JOYDATF_X0,d0           ;Mask out non-joystick bits.
                ror.b   #1,d0                               ;Roll right to bit 7 so it is adjacent to left.
                ror.b   #1,d1                               ;Roll down to bit 7 so it is adjacent to up.
                lsr.w   #7,d0                               ;Shift left,right to the correct places.
                lsr.w   #5,d1                               ;Shift up,down to the correct place.
                or.w    d1,d0                               ;Assemble the answer in d0.

                or.l    d2,d0                               ; combine buttons & switches
                or.l    #JP_TYPE_JOYSTK,d0                  ; code = game controller

                bclr    #JP_STATUSB_ALREADYRUNNING,lljp_Status+ll_Port0State(a5) ;Clear that bit in lljp_Status of the Port 0 jp structure

                movem.l     (sp)+,d2/d4/a3-a5/a6
                rts

999$            moveq.l     #0,d0
                movem.l     (sp)+,d2/d4/a3-a5/a6
                rts



** Joy1Lck -- Joystick (locked), port 1
**
Joy1Lck:
                movem.l     d2/d4/a3-a5/a6,-(sp)
                move.l      a6,a5
                moveq.l     #0,d0
                bset        #JP_STATUSB_ALREADYRUNNING,lljp_Status+ll_Port0State(a5) ;Clear that bit in lljp_Status of the Port 0 jp structure
                bne.s       999$

                move.w      #$f000,d1                       * Make the middle button an INPUT
                move.w      #$f000,d0
                move.l      ll_PotGoResource(a6),a6
                JSRLIB      WritePotgo

                move.l      #_custom,a3
                move.l      #_ciaa,a4
                move.w      #CIAB_GAMEPORT1,d4

                moveq.l     #0,d2
                move.b      ciapra(a4),d1
                btst        d4,d1
                bne.s       1$
                or.l        #JPF_BTN2,d2
1$

                move.w      potinp(a3),d1
                btst        #12,d1
                bne.s       2$
                or.l        #JPF_BTN7,d2
2$

                btst        #14,d1
                bne.s       3$
                or.l        #JPF_BTN1,d2
3$

                move.w  joy1dat(a3),d1                      ; Read UDLR

                move.w  d1,d0
                lsr.w   #1,d0                               ;Move left and write over top of up and down.
                eor.w   d0,d1                               ;Derive up and down.
                and.w   #JOYDATF_Y0|JOYDATF_X0,d1           ;Mask out non-joystick bits.
                and.w   #JOYDATF_Y0|JOYDATF_X0,d0           ;Mask out non-joystick bits.
                ror.b   #1,d0                               ;Roll right to bit 7 so it is adjacent to left.
                ror.b   #1,d1                               ;Roll down to bit 7 so it is adjacent to up.
                lsr.w   #7,d0                               ;Shift left,right to the correct places.
                lsr.w   #5,d1                               ;Shift up,down to the correct place.
                or.w    d1,d0                               ;Assemble the answer in d0.

                or.l    d2,d0                               ; combine buttons & switches
                or.l    #JP_TYPE_JOYSTK,d0                  ; code = game controller

                bclr    #JP_STATUSB_ALREADYRUNNING,lljp_Status+ll_Port0State(a5) ;Clear that bit in lljp_Status of the Port 0 jp structure

                movem.l     (sp)+,d2/d4/a3-a5/a6
                rts

999$            moveq.l     #0,d0
                movem.l     (sp)+,d2/d4/a3-a5/a6
                rts



** Game0Lck -- Game controller (locked), port 0.
**
Game0Lck:
                movem.l     a2-a4/a6/d2-d4,-(sp)
                lea.l       ll_Port0State(a6),a2

                bset        #JP_STATUSB_ALREADYRUNNING,lljp_Status(a2)
                bne         99$

                move.l      #_custom,a3
                move.l      #_ciaa,a4
                move.w      #CIAB_GAMEPORT0,d4



                bset    #JP_STATUSB_CLOCKING_CTLR,lljp_Status(a2)       ; critical section flag

                bset    d4,ciaddra(a4)                      ;Set direction for fire button.
                bclr    d4,ciapra(a4)                       ;Lower the clock.
                                                            ;
                                                            ;Enable game controller mux (enable the middle
                                                            ;button as an output and send it a low).
                                                            ;

                move.l  ll_PotGoResource(a6),a6
                move.w  #$200,d0                            ;Output a 0.
                move.w  #$300,d1
                JSRLIB  WritePotgo
                move.l  #_custom+potinp,a0                  ;Get read address into a register this decreases the time in the loop.
                move.w  #$400,d1
                                                            ; Set loop counter and clear temp data register.
                CLEAR   d3
                moveq   #6,d0                               ; d0 is loop counter
                bra.s   1$
                                                            ; Loop for all bits :
0$
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
1$
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                move.w  (a0),d2                             ; d2 gets POTGOR data
                                                            ;Clock for next value.
                bset    d4,ciapra(a4)                       ;Make the clock high
                bclr    d4,ciapra(a4)                       ;Lower the clock.
                                                            ;Munge the button data bit into d3.
                and.w   d1,d2
                bne.s   6$                                  ;Buttons are active low.
                                                            ;The button was pressed.
                bset    d0,d3                               ;set button down in temp reg.
6$:             dbra    d0,0$                               ; loop for all bits
                                                            ;
                                                            ;Disable game controller mux (enable the middle
                                                            ;button as an output and send it a high).
                                                            ;
                move.w  #$300,d0
                move.w  d0,d1
                JSRLIB  WritePotgo
                bclr    d4,ciaddra(a4)                      ;Restore direction of fire button to input :
                bclr    #JP_STATUSB_CLOCKING_CTLR,lljp_Status(a2)       ; critical section flag

*	        lsr.w   #1,d3                               ; dump worthless bit.
                lsl.w   #1,d3
                swap    d3                                  ; move buttons to high word

                move.w  joy0dat(a3),d1                      ; Read UDLR

                move.w  d1,d0
                lsr.w   #1,d0                               ;Move left and write over top of up and down.
                eor.w   d0,d1                               ;Derive up and down.
                and.w   #JOYDATF_Y0|JOYDATF_X0,d1           ;Mask out non-joystick bits.
                and.w   #JOYDATF_Y0|JOYDATF_X0,d0           ;Mask out non-joystick bits.
                ror.b   #1,d0                               ;Roll right to bit 7 so it is adjacent to left.
                ror.b   #1,d1                               ;Roll down to bit 7 so it is adjacent to up.
                lsr.w   #7,d0                               ;Shift left,right to the correct places.
                lsr.w   #5,d1                               ;Shift up,down to the correct place.
                or.w    d1,d0                               ;Assemble the answer in d0.

                or.l    d3,d0                               ; combine buttons & switches
                or.l    #JP_TYPE_GAMECTLR,d0                ; code = game controller

                bclr    #JP_STATUSB_ALREADYRUNNING,lljp_Status(a2)
99$
                movem.l (sp)+,a2-a4/a6/d2-d4
                rts


** Game1Lck -- Game controller (locked), port 1.
**
Game1Lck:
                movem.l     a2-a4/a6/d2-d4,-(sp)
                lea.l       ll_Port1State(a6),a2

                bset        #JP_STATUSB_ALREADYRUNNING,lljp_Status-ll_Port1State+ll_Port0State(a2)
                bne         99$

                move.l      #_custom,a3
                move.l      #_ciaa,a4
                move.w      #CIAB_GAMEPORT1,d4



                bset    #JP_STATUSB_CLOCKING_CTLR,lljp_Status-ll_Port1State+ll_Port0State(a2)       ; critical section flag

                bset    d4,ciaddra(a4)                      ;Set direction for fire button.
                bclr    d4,ciapra(a4)                       ;Lower the clock.
                                                            ;
                                                            ;Enable game controller mux (enable the middle
                                                            ;button as an output and send it a low).
                                                            ;

                move.l  ll_PotGoResource(a6),a6
                move.w  #$2000,d0                            ;Output a 0.
                move.w  #$3000,d1
                JSRLIB  WritePotgo
                move.l  #_custom+potinp,a0                  ;Get read address into a register this decreases the time in the loop.
                move.w  #$4000,d1
                                                            ; Set loop counter and clear temp data register.
                CLEAR   d3
                moveq   #6,d0                               ; d0 is loop counter
                bra.s   1$
                                                            ; Loop for all bits :
0$
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
1$
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                move.w  (a0),d2                             ; d2 gets POTGOR data
                                                            ;Clock for next value.
                bset    d4,ciapra(a4)                       ;Make the clock high
                bclr    d4,ciapra(a4)                       ;Lower the clock.
                                                            ;Munge the button data bit into d3.
                and.w   d1,d2
                bne.s   6$                                  ;Buttons are active low.
                                                            ;The button was pressed.
                bset    d0,d3                               ;set button down in temp reg.
6$:             dbra    d0,0$                               ; loop for all bits
                                                            ;
                                                            ;Disable game controller mux (enable the middle
                                                            ;button as an output and send it a high).
                                                            ;
                move.w  #$3000,d0
                move.w  d0,d1
                JSRLIB  WritePotgo
                bclr    d4,ciaddra(a4)                      ;Restore direction of fire button to input :
                bclr    #JP_STATUSB_CLOCKING_CTLR,lljp_Status-ll_Port1State+ll_Port0State(a2)       ; critical section flag

*	        lsr.w   #1,d3                               ; dump worthless bit.
                lsl.w   #1,d3
                swap    d3                                  ; move buttons to high word

                move.w  joy1dat(a3),d1                      ; Read UDLR

                move.w  d1,d0
                lsr.w   #1,d0                               ;Move left and write over top of up and down.
                eor.w   d0,d1                               ;Derive up and down.
                and.w   #JOYDATF_Y0|JOYDATF_X0,d1           ;Mask out non-joystick bits.
                and.w   #JOYDATF_Y0|JOYDATF_X0,d0           ;Mask out non-joystick bits.
                ror.b   #1,d0                               ;Roll right to bit 7 so it is adjacent to left.
                ror.b   #1,d1                               ;Roll down to bit 7 so it is adjacent to up.
                lsr.w   #7,d0                               ;Shift left,right to the correct places.
                lsr.w   #5,d1                               ;Shift up,down to the correct place.
                or.w    d1,d0                               ;Assemble the answer in d0.

                or.l    d3,d0                               ; combine buttons & switches
                or.l    #JP_TYPE_GAMECTLR,d0                ; code = game controller

                bclr    #JP_STATUSB_ALREADYRUNNING,lljp_Status-ll_Port1State+ll_Port0State(a2)
99$
                movem.l (sp)+,a2-a4/a6/d2-d4
                rts


** Game2Lck -- Game controller (locked), port 2.  A Double Controller.  2nd from 0.
**
Game2Lck:
                movem.l     a2-a4/a6/d2-d4,-(sp)
                lea.l       ll_Port2State(a6),a2

                bset        #JP_STATUSB_ALREADYRUNNING,lljp_Status-ll_Port2State+ll_Port0State(a2)
                bne         99$

                move.l      #_custom,a3
                move.l      #_ciaa,a4
                move.w      #CIAB_GAMEPORT0,d4



                bset    #JP_STATUSB_CLOCKING_CTLR,lljp_Status-ll_Port2State+ll_Port0State(a2)       ; critical section flag

                bset    d4,ciaddra(a4)                      ;Set direction for fire button.
                bclr    d4,ciapra(a4)                       ;Lower the clock.
                                                            ;
                                                            ;Enable game controller mux (enable the middle
                                                            ;button as an output and send it a low).
                                                            ;

                move.l  ll_PotGoResource(a6),a6
                move.w  #$200,d0                            ;Output a 0.
                move.w  #$300,d1
                JSRLIB  WritePotgo
                move.l  #_custom+potinp,a0                  ;Get read address into a register this decreases the time in the loop.
                move.w  #$400,d1
                                                            ; Set loop counter and clear temp data register.
                CLEAR   d3
                moveq   #17,d0                              ; d0 is loop counter
                bra.s   1$
                                                            ; Loop for all bits :
0$
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
1$
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                move.w  (a0),d2                             ; d2 gets POTGOR data
                                                            ;Clock for next value.
                bset    d4,ciapra(a4)                       ;Make the clock high
                bclr    d4,ciapra(a4)                       ;Lower the clock.
                                                            ;Munge the button data bit into d3.
                and.w   d1,d2
                bne.s   6$                                  ;Buttons are active low.
                                                            ;The button was pressed.
                bset    d0,d3                               ;set button down in temp reg.
6$:             dbra    d0,0$                               ; loop for all bits
                                                            ;
                                                            ;Disable game controller mux (enable the middle
                                                            ;button as an output and send it a high).
                                                            ;
                move.w  joy0dat(a3),d2                      ; Read UDLR
;                                                           ; Read UDLR here.  Dan tells me that
;                                                           ; duals are likely to multiplex between
;                                                           ; the two UDLR sets between clocking out
;                                                           ; the first and second sets of 8 bits.

                move.w  #$300,d0
                move.w  d0,d1
                JSRLIB  WritePotgo
                bclr    d4,ciaddra(a4)                      ;Restore direction of fire button to input :
                bclr    #JP_STATUSB_CLOCKING_CTLR,lljp_Status-ll_Port2State+ll_Port0State(a2)       ; critical section flag

*	        lsr.w   #1,d3                               ; dump worthless bit.
                lsl.w   #1,d3
                swap    d3                                  ; move buttons to high word


                move.w  d2,d0
                lsr.w   #1,d0                               ;Move left and write over top of up and down.
                eor.w   d0,d2                               ;Derive up and down.
                and.w   #JOYDATF_Y0|JOYDATF_X0,d2           ;Mask out non-joystick bits.
                and.w   #JOYDATF_Y0|JOYDATF_X0,d0           ;Mask out non-joystick bits.
                ror.b   #1,d0                               ;Roll right to bit 7 so it is adjacent to left.
                ror.b   #1,d2                               ;Roll down to bit 7 so it is adjacent to up.
                lsr.w   #7,d0                               ;Shift left,right to the correct places.
                lsr.w   #5,d2                               ;Shift up,down to the correct place.
                or.w    d2,d0                               ;Assemble the answer in d0.

                or.l    d3,d0                               ; combine buttons & switches
                or.l    #JP_TYPE_GAMECTLR,d0                ; code = game controller

                bclr    #JP_STATUSB_ALREADYRUNNING,lljp_Status-ll_Port2State+ll_Port0State(a2)
99$
                movem.l (sp)+,a2-a4/a6/d2-d4
                rts


** Game3Lck -- Game controller (locked), port 3.  A double controller.  2nd from 1.
**
Game3Lck:
                movem.l     a2-a4/a6/d2-d4,-(sp)
                lea.l       ll_Port3State(a6),a2

                bset        #JP_STATUSB_ALREADYRUNNING,lljp_Status-ll_Port3State+ll_Port0State(a2) ;Test & set that bit in lljp_Status of the Port 0 jp structure
                bne         99$

                move.l      #_custom,a3
                move.l      #_ciaa,a4
                move.w      #CIAB_GAMEPORT1,d4



                bset    #JP_STATUSB_CLOCKING_CTLR,lljp_Status-ll_Port3State+ll_Port0State(a2)       ; critical section flag

                bset    d4,ciaddra(a4)                      ;Set direction for fire button.
                bclr    d4,ciapra(a4)                       ;Lower the clock.
                                                            ;
                                                            ;Enable game controller mux (enable the middle
                                                            ;button as an output and send it a low).
                                                            ;

                move.l  ll_PotGoResource(a6),a6
                move.w  #$2000,d0                           ;Output a 0.
                move.w  #$3000,d1
                JSRLIB  WritePotgo
                move.l  #_custom+potinp,a0                  ;Get read address into a register this decreases the time in the loop.
                move.w  #$4000,d1
                                                            ; Set loop counter and clear temp data register.
                CLEAR   d3
                moveq   #17,d0                              ; d0 is loop counter
                bra.s   1$
                                                            ; Loop for all bits :
0$
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
1$
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                tst.b   ciapra(a4)
                move.w  (a0),d2                             ; d2 gets POTGOR data
                                                            ;Clock for next value.
                bset    d4,ciapra(a4)                       ;Make the clock high
                bclr    d4,ciapra(a4)                       ;Lower the clock.
                                                            ;Munge the button data bit into d3.
                and.w   d1,d2
                bne.s   6$                                  ;Buttons are active low.
                                                            ;The button was pressed.
                bset    d0,d3                               ;set button down in temp reg.
6$:             dbra    d0,0$                               ; loop for all bits
                                                            ;

                move.w  joy0dat(a3),d2                      ; Read UDLR
;                                                           ; Read UDLR here.  Dan tells me that
;                                                           ; duals are likely to multiplex between
;                                                           ; the two UDLR sets between clocking out
;                                                           ; the first and second sets of 8 bits.

                                                            ;Disable game controller mux (enable the middle
                                                            ;button as an output and send it a high).
                                                            ;
                move.w  #$3000,d0
                move.w  d0,d1
                JSRLIB  WritePotgo
                bclr    d4,ciaddra(a4)                      ;Restore direction of fire button to input :
                bclr    #JP_STATUSB_CLOCKING_CTLR,lljp_Status-ll_Port3State+ll_Port0State(a2)       ; critical section flag

*	        lsr.w   #1,d3                               ; dump worthless bit.
                lsl.w   #1,d3
                swap    d3                                  ; move buttons to high word

                move.w  d2,d0
                lsr.w   #1,d0                               ;Move left and write over top of up and down.
                eor.w   d0,d2                               ;Derive up and down.
                and.w   #JOYDATF_Y0|JOYDATF_X0,d2           ;Mask out non-joystick bits.
                and.w   #JOYDATF_Y0|JOYDATF_X0,d0           ;Mask out non-joystick bits.
                ror.b   #1,d0                               ;Roll right to bit 7 so it is adjacent to left.
                ror.b   #1,d2                               ;Roll down to bit 7 so it is adjacent to up.
                lsr.w   #7,d0                               ;Shift left,right to the correct places.
                lsr.w   #5,d2                               ;Shift up,down to the correct place.
                or.w    d2,d0                               ;Assemble the answer in d0.

                or.l    d3,d0                               ; combine buttons & switches
                or.l    #JP_TYPE_GAMECTLR,d0                ; code = game controller

                bclr    #JP_STATUSB_ALREADYRUNNING,lljp_Status-ll_Port3State+ll_Port0State(a2) ;Clear that bit in lljp_Status of the Port 0 jp structure
99$
                movem.l (sp)+,a2-a4/a6/d2-d4
                rts





GAMEPORT_INT:   dc.b    'gameport.device',0


        END
@


40.20
log
@LOts of changes.
 (1) SetJoyPortAttrs() added.  Allows API for locking a controller in.
 (2) Several optimizations were taken; move's where better than lea's, etc.
 (3) Different versions of the code for different port #'s, different 
     controller types, etc.  Fixes mouse->joystick confusion, and speeds things
     up.
 (4) On port 0 & port 1 game controller code, when 'locked', we only clock in the
     first 6 bits of the buttons.  HUGE savings.
 (5) ReadJoyPort() was modified to redirect call when a controller type is locked in.
@
text
@d3 1
a3 1
*       $Id: readjoyport.asm,v 40.19 93/04/20 14:17:33 Jim2 Exp $
d7 12
a18 1
*       $Log:   readjoyport.asm,v $
d155 2
a156 2
*       (C) Copyright 1992 Commodore-Amiga, Inc.
*           All Rights Reserved
a182 1
                XREF    _kprintf
d194 1
a194 1
*       ReadJoyPort - Return the state of the selected joy/mouse port.
d197 2
a198 2
*       PortState = ReadJoyPort(PortNumber)
*       d0                      d0
d200 1
a200 1
*       ULONG ReadJoyPort(ULONG)                            ;
d203 32
a234 34
*       This function is used to determine what device is attached to the
*       joy port and the current position/button state.  The user may attach
*       a Mouse, Game Controller, or Joystick to the port and this function
*       will dynamically detect which device is attached and return the
*       appropriatly formatted PortState.
*
*       To determine the type of controller that is attached, this function
*       will clock the Game Controller and/or interpret changes in the joy
*       port data.  Valid clocked data from the Game Controller is immediately
*       detected.  However, to accuratly determine if a mouse or joystick is
*       attached, several calls to this function are required along with some
*       movement at the joy port by the user.
*
*       This function always executes immediatly.
*
*   NOTE
*       This is a low level single threaded function that does not fit the
*       normal Amgia multitasking model.  Only one process can be executing
*       this routine at any time.  All others will return immediately with
*       JP_TYPE_NOTAVAIL.
*
*       The nature of this routine is not meant to encourage nonmultitasking
*       friendly programming practices like polling loops.  If your task
*       is waiting for a transition to be returned use a WaitTOF() between
*       calls to minimize the total system impact.
*
*       When called the first time for each port this function attempts to
*       acquire certain system resources.  In order to aquire these resources
*       this function MUST be called from a task, or a DOS process.  If this
*       function fails to aquire the necessary resources the function will
*       return with JP_TYPE_NOTAVAIL.  Once the resources are aquired (return
*       value other than JP_TYPE_NOTAVAIL) this function may be used in
*       interrupts.
*
d237 1
a237 2
*       PortNumber - Unsigned long that selects the port to read.  This
*                    value should be in the range of 0..3.
d240 3
a242 3
*       PortState - Bit map that identifys the device and the current
*                   state of that device.  The format of the bit map is
*                   dependant on the type of device attached.
d244 41
a284 42
*                   The following constants (defined in
*                   <libraries/lowlevel.i> and <libraries/lowlevel.h>)
*                   can be used to determine which device is attached and
*                   the state of that device :
*
*                   The type of device can be determined by applying
*                   the mask JP_TYPE_MASK to the return value and comparing
*                   the resultant value with the following:
*
*                       JP_TYPE_NOTAVAIL        port data unavailable
*                       JP_TYPE_GAMECTLR        game controller
*                       JP_TYPE_MOUSE           mouse
*                       JP_TYPE_JOYSTK          joystick
*                       JP_TYPE_UNKNOWN         unknown device
*
*                   If type = JP_TYPE_GAMECTLR the bit map of PortState is:
*                       JPF_BUTTON_BLUE         Blue - Stop
*                       JPF_BUTTON_RED          Red - Select
*                       JPF_BUTTON_YELLOW       Yellow - Repeat
*                       JPF_BUTTON_GREEN        Green - Shuffle
*                       JPF_BUTTON_FORWARD      Charcoal - Forward
*                       JPF_BUTTON_REVERSE      Charcoal - Reverse
*                       JPF_BUTTON_PLAY         Grey - Play/Pause
*                       JPF_JOY_UP              Up
*                       JPF_JOY_DOWN            Down
*                       JPF_JOY_LEFT            Left
*                       JPF_JOY_RIGHT           Right
*
*                   If type = JP_TYPE_JOYSTK the bit map of PortState is:
*                       JPF_BUTTON_BLUE         Right
*                       JPF_BUTTON_RED          Fire
*                       JPF_JOY_UP              Up
*                       JPF_JOY_DOWN            Down
*                       JPF_JOY_LEFT            Left
*                       JPF_JOY_RIGHT           Right
*
*                   If type = JP_TYPE_MOUSE the bit map of PortState is:
*                       JPF_BUTTON_BLUE         Right mouse
*                       JPF_BUTTON_RED          Left mouse
*                       JPF_BUTTON_PLAY         Middle mouse
*                       JP_MVERT_MASK           Mask for vertical counter
*                       JP_MHORZ_MASK           Mask for horizontal counter
d286 3
d292 8
a299 8
*       d4 - Bit in the CIA for the fire line.
*       d5 - Word flag for accessing the output enable for the middle mouse button.
*       d6 - Used for building the return value.
*       d7 - Value read from the correct joyport.
*       a2 - Points to port specific structure.
*       a3 - Points to the base of the custom registers
*       a4 - Points to the base of the CIA  A chip
*       a5 - Lowlevel.base
d843 1
a843 1
******* lowlevel.library/SetJoyPortAttrsA **********************************
d846 2
a847 2
*       SetJoyPortAttrsA -- change the attributes of a port.  (V40.27)
*       SetJoyPortAttrs -- varargs stub for SetJoyPortAttrsA().  (V40.27)
d850 2
a851 2
*       Success = SetJoyPortAttrsA(port, taglist)
*       d0                         d0     a1
d853 1
a853 1
*       BOOL SetJoyPortAttrsA(ULONG, struct TagItem *);
d855 1
a855 1
*       Success = SetJoyPortAttrs(port, firstTag, ...)
d857 1
a857 1
*       BOOL SetJoyPortAttrs(ULONG, tag1, tag2, ... );
d861 3
a863 3
*       This function allows modification of several attributes held by
*       ReadJoyPort() about both it's operation and the type of controller
*       currently plugged into the port.
d865 14
a878 15
*   NOTES
*       ReadJoyPort()'s default behavior is to attempt to automatically
*       sense the type of controller plugged into any given port, when
*       asked to read that port.  This behavior is beneficial, to allow
*       simple detection of the type of controller plugged into the port.
*       Unfortunately, rare cases are possible where extremely fine
*       mouse movements appear to be real joystick movements.  Also, this
*       ability to auto-sense the controller type causes most reads to
*       take longer than if there were no auto-sensing.
*
*       SetJoyPortAttrs() is intended to provide for both of these cases.
*       It allows the programmer to notify ReadJoyPort() to stop spending
*       time attempting to sense which type of controller is in use -- and,
*       optionally, to force ReadJoyPort() into utilizing a certain
*       controller type.
d881 4
a884 4
*       port       - The joyport in question (0-3).
*       taglist    - A pointer to an array of tags providing parameters
*                    to SetJoyPortAttrs(); if NULL, the function
*                    will return TRUE, but do nothing.
d887 14
a900 1
*       All kinds:
d902 3
a904 13
*       SJA_Type   - If provided, sets the current controller type to
*                    the mouse, joystick, or game controller.  ti_Data can
*                    be one of SJA_TYPE_GAMECTLR, SJA_TYPE_MOUSE,
*                    SJA_TYPE_JOYSTK, or SJA_TYPE_AUTOSENSE.  If
*                    SJA_TYPE_AUTOSENSE is used, ReadJoyPort() will attempt
*                    to determine the type of controller plugged into the
*                    given port automatically.  If one of the other types
*                    is used, ReadJoyPort() will make no attempt to read
*                    the given controller as anything other than the
*                    type specified.  The default type is SJA_AUTOSENSE.
*                    Note -- if you set the type to anything other than
*                    autosense, it's your responsibility to return it
*                    to autosense mode before exiting.
d907 2
a908 2
*       Success    - A boolean defining success or failure of the function.
*
d910 2
d959 6
a964 8
0$              moveq.l     #0,d1
05$             tst.b       d0                      * Essentially, do d1 = Port * sizeof(struct JoyPortState)
                beq.s       06$                     * Cheaper than MULS, as Port is < 4.
                add.l       #lljp_SIZE,d1
                subq        #1,d0
                bra.s       05$
06$
                lea.l       ll_Port0State(a6,d1.l),a3 * Calculate a pointer to the correct JoyPortState structure
d968 2
a969 2
                move.l      sp,a2                   * save &tstate
1$              move.l      a6,-(sp)                * Save library base
d975 1
a975 1
                beq.s       100$                    * yep, leave.
d995 30
a1024 2
11$
99$             bra.s       1$                      * Loop for next
d1374 1
a1374 1
*               lsr.w   #1,d3                               ; dump worthless bit.
d1465 1
a1465 1
*               lsr.w   #1,d3                               ; dump worthless bit.
d1562 1
a1562 1
*               lsr.w   #1,d3                               ; dump worthless bit.
d1659 1
a1659 1
*               lsr.w   #1,d3                               ; dump worthless bit.
@


40.19
log
@Polished the Autodoc.
@
text
@d3 1
a3 1
*	$Id: readjoyport.asm,v 40.18 93/04/19 14:25:47 Jim2 Exp Locker: Jim2 $
d7 4
a10 1
*	$Log:	readjoyport.asm,v $
d103 1
a103 1
* Updated to use "almost semiphore" with gameport and new initialization code
d144 2
a145 2
*	(C) Copyright 1992 Commodore-Amiga, Inc.
*	    All Rights Reserved
d149 31
a179 30
	NOLIST
        INCLUDE "exec/ables.i"
        INCLUDE	"exec/interrupts.i"
	INCLUDE	"exec/io.i"
        INCLUDE	"exec/lists.i"
	INCLUDE	"exec/macros.i"
	INCLUDE	"exec/memory.i"
        INCLUDE	"exec/nodes.i"
	INCLUDE "exec/strings.i"
        INCLUDE "exec/types.i"
	INCLUDE "hardware/custom.i"
        INCLUDE	"hardware/cia.i"
	INCLUDE "hardware/intbits.i"
	LIST
	INCLUDE "JoyPortInternal.i"
	INCLUDE	"/lowlevelbase.i"
	INCLUDE	"/macros.i"
	INCLUDE	"/lowlevel.i"


        XREF	_intena
	XREF	_custom
	XREF	_ciaa


        SECTION code

		XDEF	ReadJoyPort
		XDEF	RJP_VBlank_Int
		XDEF	RJP_Joy_Direction
d184 1
a184 1
*	ReadJoyPort - Return the state of the selected joy/mouse port.
d187 2
a188 2
*	PortState = ReadJoyPort(PortNumber)
*	d0			d0
d190 1
a190 1
*	ULONG ReadJoyPort(ULONG);
d193 12
a204 12
*	This function is used to determine what device is attached to the
*	joy port and the current position/button state.  The user may attach
*	a Mouse, Game Controller, or Joystick to the port and this function
*	will dynamically detect which device is attached and return the
*	appropriatly formatted PortState.
*
*	To determine the type of controller that is attached, this function
*	will clock the Game Controller and/or interpret changes in the joy
*	port data.  Valid clocked data from the Game Controller is immediatly
*	detected.  However, to accuratly determine if a mouse or joystick is
*	attached, several calls to this function are required along with some
*	movement at the joy port by the user.
d206 1
a206 1
*	This function always executes immediatly.
d209 4
a212 4
*	This is a low level single threaded function that does not fit the
*	normal Amgia multitasking model.  Only one process can be executing
*	this routine at any time.  All others will return immediately with
*	JP_TYPE_NOTAVAIL.
d214 12
a225 12
*	The nature of this routine is not meant to encourage nonmultitasking
*	friendly programming practices like polling loops.  If your task
*	is waiting for a transition to be returned use a WaitTOF() between
*	calls to minimize the total system impact.
*
*	When called the first time for each port this function attempts to
*	acquire certain system resources.  In order to aquire these resources
*	this function MUST be called from a task, or a DOS process.  If this
*	function fails to aquire the necessary resources the function will
*	return with JP_TYPE_NOTAVAIL.  Once the resources are aquired (return
*	value other than JP_TYPE_NOTAVAIL) this function may be used in
*	interrupts.
d229 2
a230 2
*	PortNumber - Unsigned long that selects the port to read.  This
*                    value should be in the range of 0..1.
d233 3
a235 3
*	PortState - Bit map that identifys the device and the current
*		    state of that device.  The format of the bit map is
*	            dependant on the type of device attached.
d237 42
a278 42
*	            The following constants (defined in
*		    <libraries/lowlevel.i> and <libraries/lowlevel.h>)
*	            can be used to determine which device is attached and
*	            the state of that device :
*
*		    The type of device can be determined by applying
*		    the mask JP_TYPE_MASK to the return value and comparing
*		    the resultant value with the following:
*
*			JP_TYPE_NOTAVAIL	port data unavailable
*			JP_TYPE_GAMECTLR	game controller
*			JP_TYPE_MOUSE		mouse
*			JP_TYPE_JOYSTK		joystick
*			JP_TYPE_UNKNOWN		unknown device
*
*	            If type = JP_TYPE_GAMECTLR the bit map of PortState is:
*			JPF_BUTTON_BLUE		Blue - Stop
*			JPF_BUTTON_RED		Red - Select
*			JPF_BUTTON_YELLOW	Yellow - Repeat
*			JPF_BUTTON_GREEN	Green - Shuffle
*			JPF_BUTTON_FORWARD	Charcoal - Forward
*			JPF_BUTTON_REVERSE	Charcoal - Reverse
*			JPF_BUTTON_PLAY		Grey - Play/Pause
*			JPF_JOY_UP		Up
*			JPF_JOY_DOWN		Down
*			JPF_JOY_LEFT		Left
*			JPF_JOY_RIGHT		Right
*
*	            If type = JP_TYPE_JOYSTK the bit map of PortState is:
*			JPF_BUTTON_BLUE		Right
*			JPF_BUTTON_RED		Fire
*			JPF_JOY_UP		Up
*			JPF_JOY_DOWN		Down
*			JPF_JOY_LEFT		Left
*			JPF_JOY_RIGHT		Right
*
*	            If type = JP_TYPE_MOUSE the bit map of PortState is:
*			JPF_BUTTON_BLUE		Right mouse
*			JPF_BUTTON_RED		Left mouse
*			JPF_BUTTON_PLAY		Middle mouse
*			JP_MVERT_MASK		Mask for vertical counter
*			JP_MHORZ_MASK		Mask for horizontal counter
d283 8
a290 8
*	d4 - Bit in the CIA for the fire line.
*	d5 - Word flag for accessing the output enable for the middle mouse button.
*	d6 - Used for building the return value.
*	d7 - Value read from the correct joyport.
*	a2 - Points to port specific structure.
*	a3 - Points to the base of the custom registers
*	a4 - Points to the base of the CIA  A chip
*	a5 - Lowlevel.base
d294 4
a297 1
	XDEF	ReadJoyPort
d299 3
a301 112
	        movem.l	d2-d7/a2-a6,-(sp)
	lea	_custom,a3			; a3 gets base of custom registers
	lea	_ciaa,a4
		move.l	a6,a5
		move.l	#JP_TYPE_NOTAVAIL,d6	;Intialize the return value to NotAvail
		move.l	d0,d2
		cmp.l	#1,d2
		bgt	RJP_NotEntered		;Is this a valid port?
				;Yes, valid port.
		lsr.l	#1,d2
		bcs.s	rjp_InPort1		;if yes, j to setup regs
				;Init Port 0 register.
	        lea	ll_Port0State(a5),a2	;Active port information structure
		bset	#JP_STATUSB_ALREADYRUNNING,lljp_Status(a2)	; is this reentrance ?
		bne	RJP_NotEntered		;if yes, j to exit

		move.l	#(joy0dat<<16),d7	;Save the offset for possibly reading the game controller again.
		move.w	joy0dat(a3),d7		;d7 now contains the port value, preserve d7.
		move.w	#CIAB_GAMEPORT0,d4
		move.w	#POTGOF_OE8,d5
		btst	#JP_STATUSB_VBLANK_ACQUIRED,lljp_Status(a2)
		bne.s	RJP_DonePortSetup	;Do we need to try getting the VBlank interrupt?
				;Yes, this must be the first time through here.
		move.l	ll_ExecBase(a5),a6
				;
				;Disable interrupts and find gameport.device on
				;the list.
				;
		move.l	IVVERTB+IV_DATA(a6),a0	; a0 gets vert blank list
		lea	GAMEPORT_INT(pc),a1	; a1 gets ptr to name we're lookin fo
		JSRLIB	Forbid			;Don't want anyone else mucking with the list at the same time.
		JSRLIB	FindName		; d0 gets ptr to IS
		beq.s	2$			;If not found, do nothing.
				;Entry found, save pointer and remove it from list.
		bset	#JP_STATUSB_VBLANK_ACQUIRED,lljp_Status(a2)	; set acquired flag
		bclr	#JP_STATUSB_FIRST_INIT_REQ,lljp_Status(a2)
		move.l	d0,ll_RJP_Saved_IS(a5)	; save ptr to gameport IS
		move.l	d0,a1			; a1 gets entry to remove
		moveq	#INTB_VERTB,d0		; d0 gets interrupt number
		JSRLIB	RemIntServer		; remove entry from list
				;Add ReadJoyPort's entry to the list.
		moveq	#INTB_VERTB,d0		; d0 gets interrupt number
		lea	ll_RJP_Vblank_IS(a5),a1	; a1 gets ptr to our entry
		JSRLIB	AddIntServer		; add entry to list
2$:				;Enable interrupts.
		JSRLIB	Permit
		bsr	RJP_Joy_Direction
		beq.s	Port0Joy		;Was the initial reading a valid mouse?
				;
				;The joyport reading was for a mouse.  So set the
				;mouse as the current state.  Also set the count to
				;maximum.
				;
		or.l	#JP_TYPE_MOUSE|(JP_MOUSE_2_RECHECK<<16),d7
		bra.s	WritePort0
				;Can't tell for sure what type of controller is attached.
Port0Joy:	or.l	#JP_TYPE_UNKNOWN,d7
WritePort0:	move.l	d7,lljp_PreviousValue(a2)	;Set the previous counter to be the current counter.
		bra.s	RJP_DonePortSetup


				;Init port 1 registers :
rjp_InPort1:	lea	ll_Port1State(a5),a2	;Active port information structure.
		bset	#JP_STATUSB_ALREADYRUNNING,lljp_Status(a2)	; is this reentrance ?
		bne	RJP_NotEntered		; if yes, j to exit

		move.l	#(joy1dat<<16),d7	;Save the offset for possibly reading the game controller again.
		move.w	joy1dat(a3),d7		;d7 now contains the port value, preserve d7.
		move.w	#CIAB_GAMEPORT1,d4
		move.w	#POTGOF_OE12,d5
RJP_DonePortSetup:		;All port specific initialization is complete.
		move.l	ll_PotGoResource(a5),a6
				;Determine if first call init is required :
		bclr	#JP_STATUSB_FIRST_INIT_REQ,lljp_Status(a2)
		beq.s	RJP_PortInited		;if no, j to continue
				;Establish default type of controller, Mouse or Unknown.
		bsr	RJP_Joy_Direction
		beq.s	InitUnknown
				;The reading can only be a mouse.
		or.l	#JP_TYPE_MOUSE|(JP_MOUSE_2_RECHECK<<16),d7
		bra.s	DoneInit

InitUnknown:	or.l	#JP_TYPE_UNKNOWN,d7
DoneInit:	move.l	d7,lljp_PreviousValue(a2)	;Set the initial port reading.
				;Generate the map of POTGO bits to be aquired.
		move.w	d5,d1
		lsr.w	#1,d1
		or.w	d5,d1
		move.w	d1,d0
		lsl.w	#2,d1
		or.w	d1,d0
		move.w	d0,d3
		JSRLIB	AllocPotBits
		cmp.w	d3,d0
		beq.s	RJP_PortInited		;Did we get the bits we wanted?
				;
				;No, free the bits be did get and reset the flag
				;so we will try again the next time through.
				;
		JSRLIB	FreePotBits
		bset	#JP_STATUSB_FIRST_INIT_REQ,lljp_Status(a2)
		bra	RJP_NotAvail_State

RJP_PortInited:			;Check to see if we are a double controller.
		lsr.l	#1,d2
		bcc.s	rjp_NotDoubleController
				;If we are a double controller go to the second record for the port.
		add.l	#ll_Port2State-ll_Port0State,a2
rjp_NotDoubleController:	;Init common registers.
		move.w	(a2),d2			;Get the count for the port.
		and.w	#$00FF,d2		;The count is in the low order byte.
		bne.s	RJP_NoGameTest
d303 124
d432 5
a436 5
;	requires:	a2 = ptr to JoyPortState
;			a3 = ptr to custom register base
;			a4 = ptr to ciaa register base
;			d4 = bit mask for Fire Button
;			d5 = mask to set appropriate Output Enable for Mux
d440 1
a440 1
		bset	#JP_STATUSB_CLOCKING_CTLR,lljp_Status(a2)	; critical section flag
d442 24
a465 24
		bset	d4,ciaddra(a4)		;Set direction for fire button.
		bclr	d4,ciapra(a4)		;Lower the clock.
				;
				;Enable game controller mux (enable the middle
				;button as an output and send it a low).
				;
		move.w	d5,d1
		lsr.w	#1,d1
		or.w	d5,d1			;d1 has the mask of bits to be changed.
		move.l	d1,-(sp)		;Save the mask for restoring.
		move.w	d5,d0			;Output a 0.
		JSRLIB	WritePotgo
		move.l	#_custom+potinp,a0	;Get read address into a register this decreases the time in the loop.
		move.w	d5,d1
		lsl.w	#1,d1			;Get mask for reading controller data.
				; Set loop counter and clear temp data register.
		CLEAR	d3
		moveq	#8,d0			; d0 is loop counter
		btst	#JP_STATUSB_2nd_CTLR,lljp_Status(a2)
		beq.s	rjp_GameStartHere
				;The double controller requires being clocked nine extra times.
		add.w	#9,d0
		bra.s	rjp_GameStartHere
				; Loop for all bits :
d467 3
a469 3
		tst.b	ciapra(a4)
		tst.b	ciapra(a4)
		tst.b	ciapra(a4)
d471 27
a497 27
		tst.b	ciapra(a4)
		tst.b	ciapra(a4)
		tst.b	ciapra(a4)
		tst.b	ciapra(a4)
		tst.b	ciapra(a4)
		move.w	(a0),d2			; d2 gets POTGOR data
				;Clock for next value.
		bset	d4,ciapra(a4)		;Make the clock high
		bclr	d4,ciapra(a4)		;Lower the clock.
				;Munge the button data bit into d3.
		and.w	d1,d2
		bne.s	6$			;Buttons are active low.
				;The button was pressed.
		bset	d0,d3			;set button down in temp reg.
6$:		dbra	d0,RJP_Clock_Game_Ctlr_Loop	; loop for all bits
				;
				;Disable game controller mux (enable the middle
				;button as an output and send it a high).
				;
		move.l	(sp)+,d1
		move.w	d1,d0
		JSRLIB	WritePotgo
		bclr	d4,ciaddra(a4)		;Restore direction of fire button to input :
		bclr	#JP_STATUSB_CLOCKING_CTLR,lljp_Status(a2)	; critical section flag
		and.w	#$1FF,d3		;Only want to return low order bits for a double controller.
		lsr.w	#1,d3
		bcc.s	RJP_NoGameTest		;Last bit clocked must be high for the controller.
d499 3
a501 3
		cmp.b	#$FF,d3
		bne	RJP_GameCtlr_State	;Next to last bit must be a zero for the controller.
				;The port is not contected to a controller.
d503 3
a505 2
		btst	#JP_STATUSB_2nd_CTLR,lljp_Status(a2)
		bne.s	RJP_NotAvail_State	;If this port is for a double controller and we don't detected it it can't be used.
d512 4
a515 4
;	On Entry:	a3 = ptr to custom register base
;			a4 = ptr to ciaa register base
;			d4 = bit mask for the Fire Button.
;			d5 = mask for Output Enable for the middle button.
d517 38
a554 37
		move.w	d5,d1			;Assemble the mask for setting the buttons to one.
		lsr.w	#1,d1
		or.w	d5,d1
		move.w	d1,d0
		lsl.w	#2,d1
		or.w	d1,d0
		move.w	d0,d1
		JSRLIB	WritePotgo		;Clear any accumulated button state.
				;Get fire button.
		move.b	ciapra(a4),d1		;d1 gets fire button state
		btst	d4,d1
		bne.s	1$			;All buttons are active low.

		ori.l	#JPF_BTN2,d6		;set fire button in temp reg
1$:				;Get right button.
		move.w	potinp(a3),d1		;d1 gets POTGOR data
		not.w	d1			;make data high active
		move.w	d1,d2			;save for later use
		lsr.w	#1,d1			;Shift so we can use the output enable as the mask.
		and.w	d5,d1			;Clear all except right button
		beq.s	2$			;Test the right button.

		ori.l	#JPF_BTN1,d6		;set right button in temp reg
2$:				;Get middle button.
		move.w	d2,d1			;d1 gets saved data
		lsl.w	#1,d1			;Shift so we can use the output enable as the mask.
		and.w	d5,d1			;Clear all except middle button.
		beq.s	3$			;Test the middle button.

		ori.l	#JPF_BTN7,d6		;set middle button in temp reg
3$:		move.l	(a2),d2			;Get the prevous controller type.
		and.l	#(3<<28),d2		;There are only four possible values.
		beq.s	RJP_Unknown_State
				;We've masked it down to one of the four.
		rol.l	#5,d2			;Shift the type so it can be used as an offset into a jump table.
		move.w	RJP_State_JTBL-2(pc,d2.w),d2
		jmp	RJP_State_JTBL(pc,d2.w)
d556 2
a557 2
RJP_Return:			;Restore registers and exit.
		move.w	d7,2(a2)		;joyport reading for next time.
a558 2
		btst	#JP_STATUSB_2nd_CTLR,lljp_Status(a2)
		beq.s	RJP_1st_CTLR		;The block out for the double controller is stored in the first data for the primary controller of the port.
d560 1
a560 2
		sub.l	#ll_Port2State-ll_Port0State,a2
RJP_1st_CTLR:	bclr	#JP_STATUSB_ALREADYRUNNING,lljp_Status(a2)	; clr for reentrance
d562 3
a564 3
		move.l	d6,d0
	        movem.l	(sp)+,d2-d7/a2-a6
		rts
d568 3
a570 3
RJP_State_JTBL: dc.w	RJP_Unknown_State-RJP_State_JTBL	;Was Game controller, now must be unknown.
		dc.w	RJP_Mouse_State-RJP_State_JTBL		;Was mouse.
		dc.w	RJP_Joystk_State-RJP_State_JTBL		;Was joystick.
d579 1
a579 1
;	If there is a change in the port data try the joystick state.
d581 3
a583 3
;	On Entry:	a2 = ptr to port status word
;			d6 = Current built return value.
;			d7 = joyport data
d585 1
a585 1
;	On Exit: 	Set new state.
d589 3
a591 3
			;Determine if Joy Port data has changed :
		cmp.w	2(a2),d7
		bne	ms_ChangeToJoy		;The joystick state will vector to the correct state based on the reading.
d594 3
a596 3
		or.l	#JP_TYPE_UNKNOWN,d6	;Set the return state.
		move.w	#(JP_TYPE_UNKNOWN>>16),(a2)	;Remember the state for next time.
		bra	RJP_Return		;Let's ge out of here.
d603 11
a613 11
;	- Guard against someone inserting the mouse and holding down the
;	  fire button.  This looks like a game controller, but we must be
;	  transitioning from the unknown state.
;	- Get the buttons in the correct register and location.
;	- Reread the current position in case we are a double controller.
;	- Call subroutine to translate the direction values.
;	- Jump to common return location with return value in d6.
;
;	On Entry:	a2 = ptr to port status word
;			d3 = button state.
;			d7(high order word) = Offset of mouse counter register.
d615 1
a615 1
;	On Exit:        d6 updated with current controller state and jump to common exit
d619 19
a637 10
		move.w	#(JP_TYPE_GAMECTLR>>16),d0
		cmp.w	(a2),d0
		beq.s	RJP_FinishGame		;If the old value is a game controller no problem.
				;
				;The old value was not a game controller.
				;Reclock so we don't get misled.
				;
		move.w	d0,(a2)			;Remember this type just incase.
		bra	RJP_Clock_Game_Ctlr
				;We're really sure we're a game controller.
d639 8
a646 8
		swap	d3			; move button data to return location
        	move.l	d3,d6			; update return value
		swap	d7
		move.w	0(a3,d7.w),d7		;Read the joystick direction.  Needed for the double controller.
		bsr	RJP_Joy_Direction	; d0 gets direction values in 0..3
        	or.w	d0,d6			; update return value
		ori.l	#JP_TYPE_GAMECTLR,d6	; set controller type field
		bra	RJP_Return
d653 4
a656 4
;		- No change do nothng.
;		- Check for a valid joystick.  If one is found decrement the
;		  counter.  When the counter gets to zero change state to
;		  joystick.
d658 3
a660 3
;	On Entry:	a2 = ptr to port status word
;			d6 = Buttons pressed
;			d7 = Joyport data
d662 1
a662 1
;	On Exit: 	d6 updated with return value and jump to common exit
d664 1
a664 1
;	Regs used: 	d0,a0
d667 49
a715 49
				;Determine if there is any change in port data.
		cmp.w	2(a2),d7
		beq.s	CompleteMouse
				;Data has changed check for possible joystick.
		bsr.s	RJP_Joy_Direction
		bne.s	RJP_Mouse_State_06	;If not a joystick reset counter and exit.
				;
				;Reading could be a joystick, check to see how
				;quickly it is changing.
				;
		move.l	ll_VBCounter(a5),a0
		move.l	(a0),d0			;Get the current VBlank count.
		sub.l	lljp_LastVBlank(a2),d0
		beq.s	ms_PossibleMouse	;Is it the same as the last VBlank count?
				;No the VBlank counter has changed.
		subq.l	#1,d0
		bne.s	ms_ManyVB		;Has at least one complete VBlank happened?
				;Yep.
		bset	#JP_STATUSB_WAS_JOY,lljp_Status(a2)	;Remember there has been a joystick like event.
		bne.s	RJP_Mouse_State_06	;Two consecutive joystick values.  Not really a joystick.

ms_ManyVB:			;Ok we have a nice joystick value remember the
				;VBlank counter and decrement the count of joystick
				;events.  Once it reaches zero change to the
				;joystick state.
				;
		move.l	(a0),lljp_LastVBlank(a2)
		move.w	(a2),d0			;Get the count.
		subq.w	#1,d0
		cmp.w	#(JP_TYPE_MOUSE>>16),d0	;The count also has the type, so if
		blt.s	ms_ChangeToJoy		;type changed the count went to -1.
				;Still a mouse.
		move.w	d0,(a2)			;Remember the new count.
		bra.s	ms_PossibleJoy

RJP_Mouse_State_06:		;Not a joystick event remember the VBlank count.
		move.l	ll_VBCounter(a5),a0
		move.l	(a0),lljp_LastVBlank(a2)
ms_PossibleMouse:		;A definite mouse event reset the counter and clear
				;the flag that show the last event was a joystick
				;event.
		move.w	#(JP_TYPE_MOUSE>>16)!JP_MOUSE_2_RECHECK,d0	;reset counter.
		move.w	d0,(a2)			;and save it.
CompleteMouse:	and.b	#~JP_STATUSF_WAS_JOY,lljp_Status(a2)	;Clear the joystick event flag.
ms_PossibleJoy:	or.w	d7,d6			;Put mouse counters into the return value.
		ori.l	#JP_TYPE_MOUSE,d6	;Put the controller type into the return value.
		bra	RJP_Return		;Go to the common exit

ms_ChangeToJoy:	move.w	#(JP_TYPE_JOYSTK>>16)!1,(a2)	;Recheck, because it could be a game controller.
d723 11
a733 11
;	- Call routine to get direction status and update return value
;	- Determine if data is valid for joystick :
;		- If not valid for joystick, clear counter and set state = MOUSE
;		  in saved state and jump to mouse state routine
;	- Decrement counter in saved status
;	- If the counter has not underflowed, return joystick type data
;		- underflow reset counter
;
;	On Entry:	a2 = ptr to port status word
;			d6 = Buttons pressed
;			d7 = Joyport data
d735 1
a735 1
;	On Exit:	d6 updated with return value and jump to common exit
d737 1
a737 1
;	Regs used:	d0
d740 20
a759 20
				;Call routine to get direction status.
		bsr.s	RJP_Joy_Direction	;d0 gets direction values in 0..3
		beq.s	RJP_Joystk_State_08	;Are the directions valid for joystick?
				;Data is invalid, go to mouse state.
		move.w	#(JP_TYPE_MOUSE>>16)|JP_MOUSE_2_RECHECK,(a2)
		bra	RJP_Mouse_State

RJP_Joystk_State_08:		;Data is valid delay for several times before
				;checking for other controller.
				;
		move.w	d0,d6			;Save the directions into the return value.
		move.w	(a2),d0			;Get the count.
		sub.w	#1,d0
		cmp.w	#(JP_TYPE_JOYSTK>>16),d0	;The count also has the type, so if
		bge.s	UpdateJoystk		;type changed the count went to -1.
				;Counter has gone to -1, reset.
		move.w	#(JP_TYPE_JOYSTK>>16)|JP_JOYSTK_2_RECHECK,d0
UpdateJoystk:	move.w	d0,(a2)			;Remember the counter.
	ori.l	#JP_TYPE_JOYSTK,d6		;set controller type field
	bra	RJP_Return
d767 1
a767 1
;	On Entry:	d7 = Reading from the joypot
d769 4
a772 4
;	On Exit:	d0 = bits 3..0 updated with direction status
;			d1 = nonzero if data is not valid for joystick
;			Cond Code = EQ if data is valid for joystick
;			Cond Code = NE if data is not valid for joystick
d774 1
a774 1
;	Regs used:	d0,d1
d777 16
a792 16
		move.w	d7,d1			; d1 gets port data
		move.w	d1,d0
		lsr.w	#1,d0			;Move left and write over top of up and down.
		eor.w	d0,d1			;Derive up and down.
		and.w	#JOYDATF_Y0|JOYDATF_X0,d1	;Mask out non-joystick bits.
		and.w	#JOYDATF_Y0|JOYDATF_X0,d0	;Mask out non-joystick bits.
		ror.b	#1,d0			;Roll right to bit 7 so it is adjacent to left.
		ror.b	#1,d1			;Roll down to bit 7 so it is adjacent to up.
		lsr.w	#7,d0			;Shift left,right to the correct places.
		lsr.w	#5,d1			;Shift up,down to the correct place.
		or.w	d1,d0			;Assemble the answer in d0.
		move.b	d0,d1
		lsr.b	#1,d1			;line up left on top of right and up on top of down.
		and.b	#~JPF_JOY_LEFT,d1	;Don't want to be distracted by a diagonal to the left and down.
		and.b	d0,d1			;This will be non-zero if opposite directions are true.
		rts
d805 3
a807 3
;	- Determine if the Critical section is being executed by RJP_Clock_Game_Ctlr
;		- If yes, return
;		- If no, call GAMEPORT interrupt server
d809 5
a813 5
;	On Entry:	a1 = pointer to IS_DATA (game library base)
;			a5 = vector to interrupt code
;
;	On Exit:	vector to GAMEPORT Vblank server or
;			return to exec (Z flag must be set)
d815 1
a815 1
;	Regs used:	d0
d818 827
a1644 15
				;Determine if critical section is active.
		btst	#JP_STATUSB_CLOCKING_CTLR,ll_Port0State+lljp_Status(a1)	; critical section active ?
		bne.s	RJP_Vblank_Int_08	; if yes, j to skip GAMEPORT server
				;
				;Critical section not active, vector to GAMEPORT
				;server.
				;
		move.l	ll_RJP_Saved_IS(a1),a1	; a1 gets pointer to GAMEPORT int structure
		move.l	IS_CODE(a1),a5		; a5 gets GAMEPORT int code vector
		move.l	IS_DATA(a1),a1		; a1 gets GAMEPORT int data pointer
		jmp	(a5)			; jump to GAMEPORT interrupt server

RJP_Vblank_Int_08:				;Critical section is active, return to exec :
		moveq.l	#0,d0			; set Z flag
		rts				; return to exec
a1645 1
GAMEPORT_INT:	dc.b	'gameport.device',0
d1647 1
@


40.18
log
@Playing with the fire line must be inside the critical section.
@
text
@d3 1
a3 1
*	$Id: readjoyport.asm,v 40.17 93/04/19 13:41:44 Jim2 Exp Locker: Jim2 $
d8 3
d215 7
a221 3
*	This routine may be used in interrupts if first called (with the
*	same port) before the interrupt handler is install.  This is due to
*	this routine aquiring system resources on the first call.
@


40.17
log
@Removed some dead lines.  Improved the comments.  Reset the
first time init flag if the allocation of the Potgo resources
fail.
@
text
@d3 1
a3 1
*	$Id: readjoyport.asm,v 40.16 93/04/15 14:25:38 Jim2 Exp Locker: Jim2 $
d8 5
d411 1
d413 1
a414 1
		bset	d4,ciaddra(a4)		;Set direction for fire button.
a423 1
		bset	#JP_STATUSB_CLOCKING_CTLR,lljp_Status(a2)	; critical section flag
d464 1
a465 1
		bclr	d4,ciaddra(a4)		;Restore direction of fire button to input :
@


40.16
log
@Drive the fire button output low before changing it to an
output.
@
text
@d3 1
a3 1
*	$Id: readjoyport.asm,v 40.15 93/04/13 15:36:11 Jim2 Exp Locker: Jim2 $
d8 4
d290 1
a290 1
		bcs	rjp_InPort1		;if yes, j to setup regs
d310 1
a310 1
		JSRLIB	Disable			; DISABLE !!!!
d325 1
a325 2
		JSRLIB	Enable			; ENABLE !!!!
		and.w	#$FFFF,d7		;This is a nonsence line.
d355 1
a355 2
				;Generate the map of potgo bits required.
		and.w	#$FFFF,d7		;This is a nonsence line.
d357 2
a358 2
		beq.s	InitUnknown		;Was the initial reading

d363 2
a364 3
DoneInit:	move.l	d7,lljp_PreviousValue(a2)		; update port 1 status flag


d374 5
a378 2
		beq.s	RJP_PortInited

d380 1
d383 2
a384 1
RJP_PortInited:	lsr.l	#1,d2
d386 1
a386 1

d389 3
a391 3
		move.w	(a2),d2
		and.w	#$00FF,d2
		bne	RJP_NoGameTest
d401 1
a401 1
;			d4 = mask to set appropriate Fire Button for clocking
a402 1
;	Regs used:      d1,d2,d3,d6
d408 5
a412 5
		bset	d4,ciaddra(a4)			;Set direction for fire button :

;
; Enable game controller mux (enable output and send it a low) :
;
d420 4
a423 7
		move.l	#_custom+potinp,a0

	move.w	d5,d1
	lsl.w	#1,d1				;Get mask for reading controller data.
;
; Set loop counter and clear temp data register :
;
d425 1
a425 1
	moveq	#8,d0				; d0 is loop counter
d428 1
a428 1

d431 1
a431 4

;
; Loop for all bits :
;
d443 1
a443 4

;
; Clock for next value :
;
d446 10
a455 14
;
; Munge the button data bit into d3 :
;
	and.w	d1,d2				; is button down ? (low active)
	bne.s	6$				; if no, j to skip bit set
	bset	d0,d3				; set button down in temp reg
6$:	dbra	d0,RJP_Clock_Game_Ctlr_Loop	; loop for all bits




;
; Disable game controller mux (enable output and send it a high) :
;
d457 1
a457 1
		move.w	d1,d0			;Output a 1.
d459 1
a459 2
	bclr	#JP_STATUSB_CLOCKING_CTLR,lljp_Status(a2)	; critical section flag

a460 3



a461 1

d463 1
a463 1
		bcc.s	RJP_NoGameTest
d466 2
a467 2
		bne	RJP_GameCtlr_State

d470 1
a470 1
		bne.s	RJP_NotAvail_State
d479 2
a480 4
;			d4 = mask to set appropriate Fire Button for clocking
;			d5 = mask to set appropriate Output Enable for Mux
;
;
d482 1
a482 1
		move.w	d5,d1
d490 2
a491 5
;
; Get fire button :
;

	move.b	ciapra(a4),d1			; d1 gets fire button state
d493 1
a493 22
		bne.s	1$
	ori.l	#JPF_BTN2,d6			; set fire button in temp reg
;
; Get right button :
;
1$:
	move.w	potinp(a3),d1			; d1 gets POTGOR data
	not.w	d1				; make data high active
	move.w	d1,d2				; save for later use
	lsr.w	#1,d1				; shift to OE position
	and.w	d5,d1				; clear all except right button
	beq.s	2$				; j if not set
	ori.l	#JPF_BTN1,d6			; set right button in temp reg
;
; Get middle button :
;
2$:	move.w	d2,d1				; d1 gets saved data
	lsl.w	#1,d1				; shift to OE position
	and.w	d5,d1				; clear all except middle button
	beq.s	3$				; j if not set
	ori.l	#JPF_BTN7,d6			; set middle button in temp reg
3$:
d495 15
d511 3
a513 2
		move.l	(a2),d2
		and.l	#(3<<28),d2
d515 2
a516 2

		rol.l	#5,d2
d519 2
a520 4
;
; Restore registers and exit :
;
RJP_Return:
d524 1
a524 1
		beq.s	RJP_1st_CTLR
d530 2
a531 2
        movem.l	(sp)+,d2-d7/a2-a6
	rts
d535 3
a537 3
RJP_State_JTBL: dc.w	RJP_Unknown_State-RJP_State_JTBL	; state 1
		dc.w	RJP_Mouse_State-RJP_State_JTBL		; state 2
		dc.w	RJP_Joystk_State-RJP_State_JTBL		; state 3
d543 1
a543 1
; The following subroutine will handle controller STATE = UNKNOWN.  The
d546 1
a546 2
;	If there is a change in the port data try the mouse state.
;
d552 1
a552 2
;	On Exit: 	set new state and jump to appropriate state
;			or return last saved state
a553 2
;	Regs used: 	d2,d3
;
d556 3
a558 5
;
; Determine if Joy Port data has changed :
;
		cmp.w	2(a2),d7			; has data changed ?
		bne	ms_ChangeToJoy
d561 3
a563 3
		or.l	#JP_TYPE_UNKNOWN,d6
		move.w	#(JP_TYPE_UNKNOWN>>16),(a2)
		bra	RJP_Return
a564 2


d567 1
a567 1
; The following subroutine will handle controller STATE = GAMECTLR.  The
d570 7
a576 2
;	- Call subroutine to get direction values
;	- Jump to common return location with return value in d6
d580 1
a580 2
;			d4 = mask to set appropriate Fire Button for clocking
;			d7 = JoyPortData.
a583 2
;	Regs used:	d4,(subroutine call d0,d1,d2)
;
d588 5
a592 4
		beq.s	RJP_FinishGame

	PUTCHAR #'r'

d595 1
a595 1

d597 2
a598 3
	swap	d3				; move button data to return location
        move.l	d3,d6				; update return value

d601 4
a605 7
	bsr	RJP_Joy_Direction		; d0 gets direction values in 0..3
        or.w	d0,d6				; update return value
	ori.l	#JP_TYPE_GAMECTLR,d6		; set controller type field
	bra	RJP_Return			; j to return



d608 1
a608 1
; The following subroutine will handle controller STATE = MOUSE.  The
d611 4
a614 1
;
d622 1
a622 1
;	Regs used: 	d0,d1,d2,d4
d625 2
a626 5

;
; Determine if there is any change in port data :
;
		cmp.w	2(a2),d7			; has data changed ?
d628 1
a628 1

d630 5
a634 2
		bne.s	RJP_Mouse_State_06		;Not valid joystick data

d636 1
a636 1
		move.l	(a0),d0
d638 2
a639 2
		beq.s	ms_PossibleMouse

d641 4
a644 1
		bne.s	ms_ManyVB
d646 7
a652 5
		bset	#JP_STATUSB_WAS_JOY,lljp_Status(a2)
		bne.s	RJP_Mouse_State_06		;Two consecutive joystick values.  Not really a joystick.

ms_ManyVB:	move.l	(a0),lljp_LastVBlank(a2)
		move.w	(a2),d0
d654 4
a657 4
		cmp.w	#(JP_TYPE_MOUSE>>16),d0
		blt.s	ms_ChangeToJoy

		move.w	d0,(a2)
d660 1
a660 1
RJP_Mouse_State_06:
d663 7
a669 5
ms_PossibleMouse:
		move.w	#(JP_TYPE_MOUSE>>16)!JP_MOUSE_2_RECHECK,d0	; reset counter
		move.w	d0,(a2)
CompleteMouse:	and.b	#~JP_STATUSF_WAS_JOY,lljp_Status(a2)
ms_PossibleJoy:	or.w	d7,d6			;Put counters into the return value.
d683 2
a684 2
;		- If not valid for joystick, clear counter and set state = MOUSE in saved state
;		  and jump to mouse state routine
d695 1
a695 1
;	Regs used:	d0, d4(subroutine call d1,d2)
d698 6
d705 5
a709 16
;
; Call routine to get direction status :
;
	bsr.s	RJP_Joy_Direction		; d4 gets direction values in 0..3
	beq.s	RJP_Joystk_State_08		; if yes, j to incr delay
;
; Data is invalid, go to mouse state :
;
		move.w	#(JP_TYPE_MOUSE>>16)|JP_MOUSE_2_RECHECK,(a2)
	bra	RJP_Mouse_State			;
;
; Data is valid delay for several times befor checking for other controller :
;
RJP_Joystk_State_08:
		move.w	d0,d6
		move.w	(a2),d0
d711 3
a713 3
		cmp.w	#(JP_TYPE_JOYSTK>>16),d0
		bge.s	UpdateJoystk

d715 2
a716 2
UpdateJoystk:	move.w	d0,(a2)
	ori.l	#JP_TYPE_JOYSTK,d6		; set controller type field
a718 2


d722 1
a722 1
; Port and update the appropriate bits for returning in d4.  The values
a734 1

a735 2


a751 2


d776 15
a790 18
;
; Determine if critical section is active :
;
	btst	#JP_STATUSB_CLOCKING_CTLR,ll_Port0State+lljp_Status(a1)	; critical section active ?
	bne.s	RJP_Vblank_Int_08		; if yes, j to skip GAMEPORT server
;
; Critical section not active, vector to GAMEPORT server :
;
	move.l	ll_RJP_Saved_IS(a1),a1		; a1 gets pointer to GAMEPORT int structure
	move.l	IS_CODE(a1),a5			; a5 gets GAMEPORT int code vector
	move.l	IS_DATA(a1),a1			; a1 gets GAMEPORT int data pointer
	jmp	(a5)                            ; jump to GAMEPORT interrupt server
;
; Critical section is active, return to exec :
;
RJP_Vblank_Int_08:
	moveq.l	#0,d0				; set Z flag
	rts					; return to exec
@


40.15
log
@Play with the comments.  Change the initial delay to be
five CIA accesses.  Move the raising of the clock to
just before the dropping.
@
text
@d3 1
a3 1
*	$Id: readjoyport.asm,v 40.14 93/04/02 11:35:26 Jim2 Exp Locker: Jim2 $
d8 5
d402 1
@


40.14
log
@Forgot when I changed d4 to be a bit to correct the reading
of the fire button.
@
text
@d3 1
a3 1
*	$Id: readjoyport.asm,v 40.13 93/04/01 18:09:41 Jim2 Exp $
d8 4
d257 3
a259 3
* Current theory clocks this routine at under 90 microseconds.
*
* The following registers are used thought the routine
d262 1
d264 2
d287 1
a287 2
		move.l	#(joy0dat<<16),d7

d289 2
a290 2
		move.w	#CIAB_GAMEPORT0,d4	; d4 gets mask for fire button
		move.w	#POTGOF_OE8,d5		; d5 gets mask for mux enable
d292 3
a294 2
		bne.s	RJP_DonePortSetup
		move.l	ll_ExecBase(a5),a6	; a6 gets exec base pointer
d303 1
a303 1
		beq.s	2$			; if not found, jump to return
d317 1
a317 1
		and.w	#$FFFF,d7
d319 6
a324 2
		beq.s	Port0Joy

d327 1
a327 1

d329 1
a329 2
WritePort0:	move.l	d7,lljp_PreviousValue(a2)		; update port 0 status flag

d334 1
a334 1
rjp_InPort1:	lea	ll_Port1State(a5),a2	; a2 gets ptr to port 1 status flag
d338 1
a338 1
		move.l	#(joy1dat<<16),d7
d340 3
a342 3
		move.w	#CIAB_GAMEPORT1,d4	; d4 gets mask for fire button
		move.w	#POTGOF_OE12,d5		; d5 gets mask for mux enable
RJP_DonePortSetup:
d345 1
a345 1
		bclr	#JP_STATUSB_FIRST_INIT_REQ,lljp_Status(a2)	; is init required ?
d348 1
a348 1
		and.w	#$FFFF,d7
d350 1
a350 1
		beq.s	InitUnknown
d380 1
a380 1
		bne.s	RJP_NoGameTest
d428 1
a428 2
		bset	d4,ciapra(a4)		;Make the clock high
		tst.b	ciapra(a4)		;Delay from the clock edge for signal propagation.
d431 1
a436 1
rjp_GameStartHere:
d442 1
@


40.13
log
@Well this is the best I can do for now for optimizing
@
text
@d3 1
a3 1
*	$Id: readjoyport.asm,v 40.12 93/04/01 13:59:09 Jim2 Exp Locker: Jim2 $
d8 3
d492 1
d494 2
a495 3
	not.b	d1				; make data high active
	and.b	d4,d1				; clear all except fire button
	beq.s	1$				; j if not set
@


40.12
log
@Played with the delay to get CDGS to recognise hot insertion
of the game controller
@
text
@d3 1
a3 1
*	$Id: readjoyport.asm,v 40.11 93/03/31 18:47:32 Jim2 Exp Locker: Jim2 $
d8 4
d263 1
a263 1
	lea	_ciaa,a4			; a4 gets base of cia regs
d271 1
a271 1
		bcs.s	rjp_InPort1		;if yes, j to setup regs
d277 2
d280 1
a280 1
		move.w	#CIAF_GAMEPORT0,d4	; d4 gets mask for fire button
d307 1
a307 1
		and.l	#$FFFF,d7
d325 1
d327 1
a327 1
		move.w	#CIAF_GAMEPORT1,d4	; d4 gets mask for fire button
d335 1
a335 1
		and.l	#$FFFF,d7
d367 1
a367 1
		bne	RJP_NoGameTest
a382 2
		bset	#JP_STATUSB_CLOCKING_CTLR,lljp_Status(a2)	; critical section flag

d384 1
a384 6
;
; Set direction for fire button :
;
	move.b	ciaddra(a4),d1			; d1 gets ddra data
	or.b	d4,d1				; set fire as output
	move.b	d1,ciaddra(a4)			; update ddra register
d392 1
d394 1
d396 1
d398 2
d403 1
d405 5
a409 1
	moveq.l	#0,d3				; d3 is temp data reg
d415 11
a426 11
		move.b	ciapra(a4),d1		; delay after enable
		move.b	ciapra(a4),d1		; * delay after enable
		move.b	ciapra(a4),d1		; delay abount 3 us
		move.b	ciapra(a4),d1		;
		move.b	ciapra(a4),d1		; delay abount 3 us
		move.b	ciapra(a4),d1		;
		move.b	ciapra(a4),d1		; delay abount 3 us
		move.b	ciapra(a4),d1		;

	move.w	potinp(a3),d2			; d2 gets POTGOR data

d430 1
a430 12
	move.b	ciapra(a4),d1  			; d1 low gets pra data
	or.b	d4,d1				; clear fire bit
	eor.b	d4,d1				;
	move.b	d1,ciapra(a4)			; update pra register

	tst.w	d0				; is this last iteration ?
	beq.s	4$ 				; if yes, j to skip giving clock

;	move.b	ciapra(a4),d1			; d1 low gets pra data
	or.b	d4,d1				; set fire bit
	move.b	d1,ciapra(a4)			; update pra register
4$:
a433 2
	move.w	d5,d1				; d1 gets output enable
	lsl.w	#1,d1				; shift for RT data position
a438 2
		btst	#JP_STATUSB_2nd_CTLR,lljp_Status(a2)
		beq.s	rjp_FinishGame
a439 4
		bset	#JP_STATUSB_2nd_TIME,lljp_Status(a2)
		bne.s   rjp_FinishGame
		btst	#0,d3
		bne	RJP_Clock_Game_Ctlr
a440 2
rjp_FinishGame
		bclr	#JP_STATUSB_2nd_TIME,lljp_Status(a2)
d445 1
a445 3
		move.w	d5,d1
		lsr.w	#1,d1
		or.w	d5,d1			;d1 has the mask of bits to be changed.
d448 3
a451 7
;
; Restore direction of fire button to input :
;
	move.b	ciaddra(a4),d1			; d1 gets ddra data
	or.b	d4,d1				; clear fire as output
	eor.b	d4,d1				;
	move.b	d1,ciaddra(a4)			; update ddra register
d454 1
a454 1
	bclr	#JP_STATUSB_CLOCKING_CTLR,lljp_Status(a2)	; critical section flag
d602 2
d611 4
a614 1
	bsr	RJP_Joy_Direction		; d4 gets direction values in 0..3
@


40.11
log
@One last try at minimizing the possiblity of transitioning
incorrectly from unknown to joystick (CI49).  The initial
read for a port is now taken at the same time the resources
are aquired.  This means it is quite possible for the first
read to return unknown.  However, it reduces possibly greatly
the time between the first and second read.

Also there were timing problems reading the joy pad as
a result of allowing the code to run on 68000.  Doubling
the delay while clocking was sufficient (CI114).
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 40.10 93/03/26 17:41:10 Jim2 Exp Locker: Jim2 $
d7 13
a19 1
*	$Log:	ReadJoyPort.asm,v $
d378 1
a394 5
		move.b	ciapra(a4),d1		; delay abount 3 us
		move.b	ciapra(a4),d1		;



d408 6
a413 2
		move.b	ciapra(a4),d1
		move.b	ciapra(a4),d1
d448 1
a448 1
		bne.s	RJP_Clock_Game_Ctlr
a469 2
		move.b	ciapra(a4),d1		; delay after enable
		move.b	ciapra(a4),d1		; * delay after enable
a472 1

d739 1
a739 1
	bra	RJP_Return					; j to unknown state routine
@


40.10
log
@Removed the transition from Unknown to Mouse state.  Always force this through the mouse state.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 40.9 93/03/26 14:10:35 Jim2 Exp Locker: Jim2 $
d8 3
d130 1
d245 3
a247 1
	        movem.l	d2-d7/a2-a5,-(sp)
d261 1
a261 1
		move.w	#joy0dat,d7		;d7 gets offset to port 0 data register
d289 10
d307 1
a307 1
		move.w	#joy1dat,d7		;d7 gets offset to port 1 data register
d316 11
a345 3
	lea	_custom,a3			; a3 gets base of custom registers
	lea	_ciaa,a4			; a4 gets base of cia regs
		move.w	0(a3,d7.w),d7		;d7 now contains the port value, preserve d7.
a349 1

d364 1
a364 1
	bset	#JP_STATUSB_CLOCKING_CTLR,lljp_Status(a2)	; critical section flag
d382 2
a383 2
	move.b	ciapra(a4),d1			; delay after enable
	move.b	ciapra(a4),d1			; * delay after enable
d385 2
d398 5
a402 3
	move.b	ciapra(a4),d1			; delay abount 3 us
	move.b	ciapra(a4),d1			;
;	move.w	ciapra(a4),d1			; extra delay
d458 2
a459 2
	move.b	ciapra(a4),d1			; * delay after enable
	move.b	ciapra(a4),d1			; * delay after enable
d462 1
a462 1
;	ENABLE	a1				; allow reentrance
d544 1
a544 1
        movem.l	(sp)+,d2-d7/a2-a5
@


40.9
log
@Removed call to OpenResource.  Documented how/when this routine
is safe from interrupts.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 40.8 93/03/26 11:18:32 Jim2 Exp Locker: Jim2 $
d8 4
a550 6
		beq.s	UnknownComplete			; if yes, j to chk range

		bsr	RJP_Joy_Direction
		bne.s	us_NotJoy

		bclr	#JP_STATUSB_WAS_JOY,lljp_Status(a2)
a552 2
us_NotJoy:	move.w	#(JP_TYPE_MOUSE>>16)!JP_MOUSE_2_RECHECK,(a2)
		bra.s	RJP_Mouse_State			;
d653 1
@


40.8
log
@Altered the test for possible joystick while in mouse state.
Added a bit to allow direct transitions from the unknown state
to the joystick state.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 40.7 93/03/19 11:31:44 Jim2 Exp Locker: Jim2 $
d8 5
a111 1
	INCLUDE	"resources/potgo.i"
a128 2
		XDEF	POTGORESOURCE

d167 3
d171 1
d291 1
a291 4
		move.l	ll_ExecBase(a5),a6
		lea	POTGORESOURCE(pc),a1
		JSRLIB	OpenResource
		move.l	d0,a6
d553 1
a553 1
		bne.s	ms_ChangeToJoy
d594 1
a594 1
	bsr.s	RJP_Joy_Direction		; d4 gets direction values in 0..3
d650 1
d697 1
a697 1
		or.w	d0,d6
a790 1
POTGORESOURCE:	POTGONAME
@


40.7
log
@Absorbed the resource grabbing code.  Changed the program flow
to handle double controllers.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 40.6 93/03/12 20:21:51 Jim2 Exp Locker: Jim2 $
d8 4
d123 1
d232 1
d241 1
a241 1
	        lea	ll_Port0State(a6),a2	;Active port information structure
a249 1
		move.l	a6,a5			; a5 gets library base pointer
a272 1
		move.l	a5,a6
d277 1
a277 1
rjp_InPort1:	lea	ll_Port1State(a6),a2	; a2 gets ptr to port 1 status flag
d285 1
a285 1
		move.l	ll_ExecBase(a6),a6
d319 1
d352 2
a353 2
	move.w	ciapra(a4),d1			; delay after enable
	move.w	ciapra(a4),d1			; * delay after enable
d366 2
a367 2
	move.w	ciapra(a4),d1			; delay abount 3 us
	move.w	ciapra(a4),d1			;
d424 2
a425 2
	move.w	ciapra(a4),d1			; * delay after enable
	move.w	ciapra(a4),d1			; * delay after enable
d546 7
a552 1
		move.w	#(JP_TYPE_MOUSE>>16),(a2)
d592 1
a592 1
        or.w	d4,d6				; update return value
a603 9
;	- Determine if H/V value has changed :
;		- If no change, return mouse type data
;	- Determine if change is within joystick range :
;		- If not in joystick range, reset counter in saved state and return mouse type data
;	- Determine if data is valid for joystick :
;		- If not valid for joystick, reset counter in saved state and return mouse type data
;	- Decrement counter in saved status
;	- If the counter has not underflowed return mouse type data
;		- Must be a joystick.
d620 23
a642 23
;
; Determine if data changed within joy stick range :
;
		move.w	2(a2),d0
		move.w	d7,d1
;
; Check horizontal byte :
;
	sub.b	d1,d0				; check if H value has changed
	bcc.s	2$				; if new>old, j to check for +1
	neg.b	d0                              ; change value to positive
2$:	move.b	d0,d2				; d3 gets temp value
;
; Check vertical byte :
;
4$:	lsr.w	#8,d1				; put V value in low word
	lsr.w	#8,d0				;
	sub.b	d1,d0				; check if V value has changed
	bcc.s	6$				; if new>old, j to check for +1
	neg.b	d0                              ; change value to positive
6$:	add.b	d0,d2				; add to temp value
	cmpi.b	#03,d2				; is horizontal in range ?
	ble.s	RJP_Mouse_State_08		; if yes, j to delay state change
d645 2
a647 1
MouseUpdateCount:
d649 2
a650 1
CompleteMouse:	or.w	d7,d6			;Put counters into the return value.
d653 1
a653 17
;
; Determine if data is valid for joystick :
;
RJP_Mouse_State_08:
	bsr.s	RJP_Joy_Direction		; d4 gets direction values in 0..3
	bne.s	RJP_Mouse_State_06		; if no, j to clr ctr and return
;
; decrement delay counter and check for underflow :
;
		move.w	(a2),d0
		subq.w	#1,d0
		cmp.w	#(JP_TYPE_MOUSE>>16),d0
		bge	MouseUpdateCount
;
; Must be a joystick
;
		move.w	#(JP_TYPE_JOYSTK>>16)!1,(a2)	;Recheck, because it could be a game controller.
d693 1
d698 1
a700 2
CompleteJoystk:
        or.l	d4,d6				; update return value
d714 2
a715 1
;	On Exit:	d4 = bits 3..0 updated with direction status
d719 1
a719 1
;	Regs used:	d0,d1,d2
d723 1
a724 29
	moveq	#0,d0				; d0 is temp data reg
;
; Move LF and RT directions to d0 :
;
	move.w	d7,d1				; d1 gets port data
	andi.w	#JOYDATF_Y1!JOYDATF_X1,d1	; mask out non LF and RT bits
	ror.w	#1,d1                           ; rotate to bits 0 and 8
	ror.b	#1,d1                           ; rotate bit 0 to 7
	ror.w	#7,d1                           ; rotate to bits 0 and 1
	or.b	d1,d0                           ; d0 gets LF and RT bits
;
; Move UP and DN directions to d0 :
;
	move.w	d7,d1				; d4 gets port data
	move.w	d7,d2
	andi.w	#JOYDATF_Y1!JOYDATF_X1,d1	; mask out non LF and RT bits
	andi.w	#JOYDATF_Y0!JOYDATF_X0,d2	; mask out non UP and DN bits
	ror.w	#1,d1				; rotate d4 to match position
	eor.w	d1,d2				; xor to get real UP and DN values
	ror.b	#1,d2				; rotate to bits 0 and 7
	ror.w	#5,d2				; rotate to bits 2 and 3
	or.b	d2,d0				; d0 gets UP and DN bits
				;Validate the joystick value in d4
	move.l	d0,d4				; return value in d4
	move.w	d0,d1
	andi.l	#(JPF_UP!JPF_LEFT),d0		; clear all except Up and LEFT
	andi.l	#(JPF_DOWN!JPF_RIGHT),d1	; clear all except Down and RIGHT
	lsr.b	#1,d0				;
	and.b	d0,d1				; is data valid ?
d726 15
a740 1
	rts
@


40.6
log
@Moved the status information to a port specific location which is what
is actually placed into a2 rather than just a pointer to the
last value read.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 40.5 93/03/10 19:52:45 Jim2 Exp Locker: Jim2 $
d8 5
d103 1
a113 1
	XREF	RJP_First_Call_Init
d117 5
a220 1
*	a6 - LowLevelBase.
d226 44
a269 4
        movem.l	d2-d7/a2-a5,-(sp)
		move.l	#JP_TYPE_NOTAVAIL,d6		;Intialize the return value to NotAvail
	cmp.b	#1,d0				; is port 1 selected ?
	bgt	RJP_NotAvail_State		; if above 1, return not avail
d271 1
a271 7
	beq.s	RJP_Main_04			; if yes, j to setup regs
				;Init Port 0 register :
        lea	ll_Port0State(a6),a2		; a2 gets ptr to port 0 status flag
RJP_Port0:	move.w	#joy0dat,d7		;d7 gets offset to port 0 data register
	move.w	#CIAF_GAMEPORT0,d4		; d4 gets mask for fire button
	move.w	#POTGOF_OE8,d5			; d5 gets mask for mux enable
	bra.s	RJP_Main_08			; j to continue
d273 12
a284 9
RJP_Main_04:
        lea	ll_Port1State(a6),a2		; a2 gets ptr to port 1 status flag
RJP_Port1:	move.w	#joy1dat,d7		;d7 gets offset to port 1 data register
	move.w	#CIAF_GAMEPORT1,d4		; d4 gets mask for fire button
	move.w	#POTGOF_OE12,d5			; d5 gets mask for mux enable
RJP_Main_08:
				;Test for reentrance :
	bset	#JP_STATUSB_ALREADYRUNNING,lljp_Status(a2)	; is this reentrance ?
	bne	RJP_NotEntered				; if yes, j to exit
d286 19
a304 2
	bclr	#JP_STATUSB_FIRST_INIT_REQ,lljp_Status(a2)	; is init required ?
	beq.s	RJP_Main_02			; if no, j to continue
d306 2
a307 3
	bsr	RJP_First_Call_Init		; call init routine
				;Init common registers.
RJP_Main_02:
a328 1
;	DISABLE	a1				; prevent reentrance
d341 5
a345 7
	move.w	d5,d2				; d2 gets OE for mux bit
	lsr.w	#1,d2				; shift for mux data position
	not	d2				; make mux data LOW
	move.w	potinp(a3),d1			; d1 gets POTGOR data
	or.w	d5,d1				; set output enable for mux
	and.w	d2,d1				; clear the data bit for mux
	move.w	d1,potgo(a3)			; drive controller high
d391 11
d405 5
a409 6
	move.w	d5,d2				; d2 gets output enable bit
	lsr.w	#1,d2				; shift for MID data position
	move.w	potinp(a3),d1			; d1 gets POTGOR data
	or.w	d5,d1				; set output enable for mux
	or.w	d2,d1				; set data for mux HIGH
	move.w	d1,potgo(a3)			; drive controller high
d432 2
d447 8
a466 7
	move.w	d5,d1				; d1 gets OE for this port
	lsl.w	#2,d1				; shift to OE right button position
	move.w	d5,d2				; d2 gets OE for this port
	lsl.w	#1,d2				; shift to data right button position
	or.w	d2,d1				; d1 gets OE & data high for right button
	move.w	d1,potgo(a3)			; write potgo

d489 3
a491 3
		rol.l	#6,d2
		move.l	RJP_State_JTBL-4(pc,d2.w),a0
		jmp	(a0)
d498 5
a502 1
	bclr	#JP_STATUSB_ALREADYRUNNING,lljp_Status(a2)	; clr for reentrance
d510 3
a512 4
RJP_State_JTBL:
		dc.l	RJP_Unknown_State	; state 1
		dc.l	RJP_Mouse_State         ; state 2
		dc.l	RJP_Joystk_State        ; state 3
d571 1
a571 1
		beq.s	ContinueGameCtlr
d576 1
a576 1
ContinueGameCtlr:
d767 47
@


40.5
log
@The method for updating ll_Port?Status did not work well with
the use of these fields for general ReadJoyPort status stuff, so
I grew the seperate status stuff a new filed in the library base.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 40.4 93/03/04 11:53:54 Jim2 Exp Locker: Jim2 $
d8 5
d176 11
a186 11
*			JPF_BTN1		Blue - Stop
*			JPF_BTN2		Red - Select
*			JPF_BTN3		Yellow - Repeat
*			JPF_BTN4		Green - Shuffle
*			JPF_BTN5		Charcoal - Forward
*			JPF_BTN6		Charcoal - Revers
*			JPF_BTN7		Grey - Play/Pause
*			JPF_UP			Up
*			JPF_DOWN		Down
*			JPF_LEFT		Left
*			JPF_RIGHT		Right
d189 6
a194 6
*			JPF_BTN1		Right
*			JPF_BTN2		Fire
*			JPF_UP			Up
*			JPF_DOWN		Down
*			JPF_LEFT		Left
*			JPF_RIGHT		Right
d197 3
a199 3
*			JPF_BTN1		Right mouse
*			JPF_BTN2		Left mouse
*			JPF_BTN7		Middle mouse
a216 3
;
; Test for reentrance :
;
a218 3
	bset	#JP_STATUSB_ALREADYRUNNING,ll_PortStatus(a6)	; is this reentrance ?
	bne	RJP_NotEntered				; if yes, j to exit

d221 1
a221 3
;
; Save registers :
;
d223 1
a223 3
;
; Init Port 0 register :
;
d225 1
a225 1
		move.w	#joy0dat,d7		;d7 gets offset to port 0 data register
d229 1
a229 3
;
; Init port 1 registers :
;
d232 1
a232 1
		move.w	#joy1dat,d7		;d7 gets offset to port 1 data register
a234 3
;
; Use unknown bit and port status to jump to apprpriate state handling routine :
;
d236 5
a240 4
;
; Determine if first call init is required :
;
	bclr	#JP_STATUSB_FIRST_INIT_REQ,ll_PortStatus(a6)	; is init required ?
d242 1
d244 1
a244 3
;
; Init common registers and determine which port to read :
;
d258 2
a259 1
;	requires:	a3 = ptr to custom register base
d268 1
a268 1
	bset	#JP_STATUSB_CLOCKING_CTLR,ll_PortStatus(a6)	; critical section flag
d353 1
a353 1
	bclr	#JP_STATUSB_CLOCKING_CTLR,ll_PortStatus(a6)	; critical section flag
d426 1
a426 1
	bclr	#JP_STATUSB_ALREADYRUNNING,ll_PortStatus(a6)	; clr for reentrance
@


40.4
log
@Tumbled the code ordering and added support for returning the
buttons for an unknown controller.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 40.3 93/03/02 13:24:24 Jim2 Exp Locker: Jim2 $
d8 4
d217 1
a217 1
	bset	#JP_STATUSB_ALREADYRUNNING%%8,ll_Port0State(a6)	; is this reentrance ?
d249 1
a249 1
	bclr	#JP_STATUSB_FIRST_INIT_REQ%%8,ll_Port0State(a6)	; is init required ?
d277 1
a277 1
	bset	#JP_STATUSB_CLOCKING_CTLR%%8,ll_Port1State(a6)	; critical section flag
d362 1
a362 1
	bclr	#JP_STATUSB_CLOCKING_CTLR%%8,ll_Port1State(a6)	; critical section flag
d435 1
a435 1
	bclr	#JP_STATUSB_ALREADYRUNNING%%8,ll_Port0State(a6)	; clr for reentrance
@


40.3
log
@Changed all of the references from game.library to lowlevel.library.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 40.2 93/03/01 16:01:34 Jim2 Exp Locker: Jim2 $
d8 3
d195 10
a208 4
; Save registers :
;
        movem.l	d1-d6/a1-a5,-(sp)
;
d211 2
d214 4
a217 1
	bne.s	RJP_NotAvail_State				; if yes, j to exit
d219 1
a219 7
; Determine if first call init is required :
;
	bclr	#JP_STATUSB_FIRST_INIT_REQ%%8,ll_Port0State(a6)	; is init required ?
	beq.s	RJP_Main_02			; if no, j to continue
	bsr	RJP_First_Call_Init		; call init routine
;
; Init common registers and determine which port to read :
a220 4
RJP_Main_02:
	lea	_custom,a3			; a3 gets base of custom registers
	lea	_ciaa,a4			; a4 gets base of cia regs
	cmp.b	#1,d0				; is port 1 selected ?
a221 1
	bgt.s	RJP_NotAvail_State		; if above 1, return not avail
d226 1
a226 1
        lea	_custom+joy0dat,a5		; a5 gets ptr to port 0 data register
d235 1
a235 1
        lea	_custom+joy1dat,a5		; a5 gets ptr to port 1 data register
a241 6
        move.l	(a2),d1				; d1 gets port status
        bmi.s	RJP_Unknown_State		; if unknown bit is set, j to routine
        andi.l	#JP_STATUS_TYPE_MASK,d1		; mask all except state field
        rol.l	#6,d1				; rotate to ls bits * 4
	move.l	RJP_State_JTBL(PC,d1.l),a1	;
        jmp	(a1)				; j to routine
d243 1
a243 1
; Joyport data not available, return 0 :
d245 3
a247 2
RJP_NotAvail_State:
	move.l	#JP_TYPE_NOTAVAIL,d0		; set not avail return value
d249 1
a249 1
; Restore registers and exit :
d251 7
a257 15
RJP_Return:
	bclr	#JP_STATUSB_ALREADYRUNNING%%8,ll_Port0State(a6)	; clr for reentrance
        movem.l	(sp)+,d1-d6/a1-a5
	rts
;
; ReadJoyPort state jump table :
;
RJP_State_JTBL:
		dc.l	RJP_NotAvail_State	; state 0
		dc.l	RJP_GameCtlr_State      ; state 1
		dc.l	RJP_Mouse_State         ; state 2
		dc.l	RJP_Joystk_State        ; state 3
		dc.l	RJP_Unknown_State       ; state 4


d261 2
a262 2
; The following subroutine will handle controller STATE = UNKNOWN.  The
; actions for this state are :
d264 1
a264 10
;	- Attempt to clock the game controller :
;		- If valid data returned, then STATE = GAME
;	- Determine if Joy Port data has changed :
;		- If no change, return data in last saved type, STATE is unchanged
;	- Determine type of change in Joy Port Data :
;		- If change is outside of joystick range, STATE = MOUSE
;		- If change is within joystick range, STATE = JOY
;
;	On Entry:	a2 = ptr to port status word
;			a3 = ptr to custom register base
a265 2
;			a5 = ptr to joy port data register
;			a6 = ptr to lowlevel library base
d268 1
d270 1
a270 6
;	On Exit: 	set new state and jump to appropriate state
;			or return last saved state
;
;	Regs used: 	d0,d1,d2,d3
;
RJP_Unknown_State:
d272 2
a273 59
	moveq	#0,d0				; clear return value
;
; Determine if Game Controller is available :
;
	bsr	RJP_Clock_Game_Ctlr		; d1 gets button values in 0..8
        lsr.w	#1,d1				; is this game controller ?
	bcc.s	RJP_Unknown_State_04		; if no, j to continue check
	cmp.b	#$0FF,d1			; is fire butt DN in mouse/joystk ?
	bne.s	RJP_Unknown_State_14		; if no, j to set state to game
;
; Determine if Joy Port data has changed :
;
RJP_Unknown_State_04:
	move.w	(a5),d1				; d1 gets joy port data
	move.l	(a2),d2				; d2 gets saved port data
	cmp.w	d1,d2				; has data changed ?
	bne.s	RJP_Unknown_State_06		; if yes, j to chk range
;
; No data change, return last saved type value :
;
	andi.l	#~JP_STATUSF_UNKNOWN,d2		; clr unknown bit in return value
	andi.l	#JP_STATUS_TYPE_MASK,d2		; clear all except type
	cmpi.l	#JP_TYPE_GAMECTLR,d2		; was last type = game ?
	bne.s	4$                              ; if no, j to skip
	move.l	#JP_TYPE_GAMECTLR,d0		; set type to game
	bra	RJP_Return			; j to return
4$:	cmpi.l	#JP_TYPE_MOUSE,d2		; was last type = mouse ?
	bne.s	6$				; if no, j to skip
	bra.s	RJP_Mouse_State			; j to mouse state
6$:	cmpi.l	#JP_TYPE_JOYSTK,d2		; was last type = joystick ?
	bne.s	8$				; if no, j to skip
	bra	RJP_Joystk_State		; j to joystick state
8$:	move.l	#JP_TYPE_UNKNOWN,d0		; set type to unknown
	bra	RJP_Return			; j to return
;
; Data changed, determine if change is within joystick range :
;
RJP_Unknown_State_06:
	bsr	RJP_Chk_Joystk_Range		; is data in joystick range
	bgt.s	RJP_Unknown_State_12            ; if no, j to chg to mouse state
;
; Set controller type to JOYSTK :
;
RJP_Unknown_State_10:
	move.w	#JP_TYPE_JOYSTK>>16,(a2)	; set state to JOYSTK
	bra	RJP_Joystk_State		; j to joystick state
;
; Set controller type to MOUSE :
;
RJP_Unknown_State_12:
	move.w	#JP_TYPE_MOUSE>>16,(a2)		; set state to MOUSE
	bra.s	RJP_Mouse_State			; j to mouse state
;
; Set controller type to GAMECTLR :
;
RJP_Unknown_State_14:
	move.w	#JP_TYPE_GAMECTLR>>16,(a2)	; set state to GAMECTLR
	bra.s	RJP_GameCtlr_State_06		; j to GAME STATE

a274 2

; *****************************************************************************
d276 1
a276 2
; The following subroutine will handle controller STATE = GAMECTLR.  The
; actions for this state are :
d278 3
a280 20
;	- Call subroutine to clock the game controller
;	- Verify data from controller is valid
;		- If no, set UNKNOWN bit in saved status
;		  and jump to unknown state routine
;	- Call subroutine to get direction values
;	- Jump to common return location with return value in d0
;
;	On Entry:	a2 = ptr to port status word
;			a3 = ptr to custom register base
;			a4 = ptr to ciaa register base
;			a5 = ptr to joy port data register
;			a6 = ptr to lowlevel library base
;			d4 = mask to set appropriate Fire Button for clocking
;			d5 = mask to set appropriate Output Enable for Mux
;
;	On Exit:        d0 updated with current controller state and jump to common exit
;
;	Regs used:	d0,d1,d2,d3
;
RJP_GameCtlr_State:
a281 1
	moveq	#0,d0				; clear return value
d283 1
a283 1
; Call routine to clock game controller and check for valid data :
d285 7
a291 23
	bsr	RJP_Clock_Game_Ctlr		; d1 gets button values in 0..8
        lsr.w	#1,d1				; is this game controller ?
	bcc.s	RJP_GameCtlr_State_86		; if no, j to error condition
	cmp.b	#$0FF,d1			;
	beq.s	RJP_GameCtlr_State_86
;
; Align clocked data, get direction values, and return :
;
RJP_GameCtlr_State_06:
	swap	d1				; move button data to return location
        or.l	d1,d0				; update return value
	bsr	RJP_Get_Joy_Direction		; d1 gets direction values in 0..3
        or.l	d1,d0				; update return value
	ori.l	#JP_TYPE_GAMECTLR,d0		; set controller type field
	bra	RJP_Return			; j to return
;
; Error case, controller data is not valid :
;	- set type to GAMECTLR and unknown bit in saved status
;	- jump to unknown state routine
;
RJP_GameCtlr_State_86:
	move.w	#(JP_STATUSF_UNKNOWN!JP_TYPE_GAMECTLR)>>16,(a2)	; set state
	bra	RJP_Unknown_State_04				; j to unknown state routine
d293 2
a294 1

a295 1
; *****************************************************************************
d297 1
a297 2
; The following subroutine will handle controller STATE = MOUSE.  The
; actions for this state are :
d299 2
a300 27
;
;	- Call routine to get joy port button status and update return value
;	- Read joy port H/V value and update return value
;	- Determine if H/V value has changed :
;		- If no change, return mouse type data
;	- Determine if change is within joystick range :
;		- If not in joystick range, clear counter in saved state and return mouse type data
;	- Determine if data is valid for joystick :
;		- If not valid for joystick, clear counter in saved state and return mouse type data
;	- Increment counter in saved status
;	- Determine if counter is at maximum :
;		- If not at maximum, return mouse type data
;		- If at maximum, clear counter and set unknown bit in saved status and return mouse type data
;
;	On Entry:	a2 = ptr to port status word
;			a3 = ptr to custom register base
;			a4 = ptr to ciaa register base
;			a5 = ptr to joy port data register
;			a6 = ptr to lowlevel library base
;			d4 = mask to set appropriate Fire Button for clocking
;			d5 = mask to set appropriate Output Enable for Mux
;
;	On Exit: 	d0 updated with return value and jump to common exit
;
;	Regs used: 	d0,d1,d2,d3
;
RJP_Mouse_State:
a301 1
	moveq	#0,d0				; clear return value
d303 1
a303 1
; Call routine to get button status :
d305 1
a305 42
	bsr	RJP_Get_Joy_Buttons		; d1 gets button data
	or.l	d1,d0				; update return value
;
; Read H/V position and update return value :
;
	move.w	(a5),d1				; d1 gets curr port data
	or.w	d1,d0				; update return value
	ori.l	#JP_TYPE_MOUSE,d0		; set controller type field
;
; Determine if there is any change in port data :
;
	move.l	(a2),d2				; d2 gets saved port data
	cmp.w	d1,d2				; has data changed ?
	beq	RJP_Return			; if no, j to return
;
; Determine if data changed within joy stick range :
;
	move.w	d1,2(a2)			; update saved H/V value (LS word)
	bsr	RJP_Chk_Joystk_Range		; is data in joystick range ?
	ble.s	RJP_Mouse_State_08		; if yes, j to delay state change
RJP_Mouse_State_06:
	move.w	#(JP_TYPE_MOUSE)>>16,(a2)	; clear counter
	bra	RJP_Return			; j to return
;
; Determine if data is valid for joystick :
;
RJP_Mouse_State_08:
        move.w	d0,d1				; d1 gets port data
	bsr.s	RJP_Get_Joy_Direction_02	; d1 gets direction values in 0..3
	bsr	RJP_Chk_Joystk_Valid		; is data valid for joystick ?
	bne.s	RJP_Mouse_State_06		; if no, j to clr ctr and return
;
; Increment delay counter and check for max :
;
	bsr	RJP_Incr_Port_Status_Counter	; d1 gets new counter value
	cmp.b	#JP_MOUSE_2_UNKNOWN,d1		; is counter at max ?
	blt	RJP_Return			; if no, j to return
;
; Counter is at maximum, clear counter and set state to unknown :
;
	move.w	#(JP_STATUSF_UNKNOWN!JP_TYPE_MOUSE)>>16,(a2)	; set unknown bit
	bra	RJP_Return					; j to unknown state routine
d307 4
a310 1

a311 1
; *****************************************************************************
d313 1
a313 2
; The following subroutine will handle controller STATE = JOYSTK.  The
; actions for this state are :
d315 7
a321 24
;	- Call routine to get joy port button status and update return value
;	- Call routine to get direction status and update return value
;	- Determine if data is valid for joystick :
;		- If not valid for joystick, clear counter and set state = MOUSE in saved state
;		  and jump to mouse state routine
;	- Increment counter in saved status
;	- Determine if counter is at maximum :
;		- If not at maximum, return joystick type data
;		- If at maximum, clear counter and set unknown bit in saved status
;		  and return joystick type data
;
;	On Entry:	a2 = ptr to port status word
;			a3 = ptr to custom register base
;			a4 = ptr to ciaa register base
;			a5 = ptr to joy port data register
;			a6 = ptr to lowlevel library base
;			d4 = mask to set appropriate Fire Button for clocking
;			d5 = mask to set appropriate Output Enable for Mux
;
;	On Exit:	d0 updated with return value and jump to common exit
;
;	Regs used:	d0,d1,d2,d3
;
RJP_Joystk_State:
d323 4
a326 1
	moveq	#0,d0				; clear return value
d328 1
a328 1
; Call routine to get button status :
d330 6
a335 40
	bsr.s	RJP_Get_Joy_Buttons		; d1 gets button data
	or.l	d1,d0				; update return value
;
; Call routine to get direction status :
;
	bsr.s	RJP_Get_Joy_Direction		; d1 gets direction values in 0..3
        or.l	d1,d0				; update return value
	ori.l	#JP_TYPE_JOYSTK,d0		; set controller type field
;
; Read H/V position and determine if there is any change in port data :
;
	move.w	(a5),d1				; d1 gets curr port data
	move.l	(a2),d2				; d2 gets saved port data
;	cmp.w	d1,d2				; has data changed ?
;	beq	RJP_Return			; if no, j to return
;
; Determine if data is valid :
;
	move.w	d1,2(a2)			; update saved H/V value (LS word)
	move.w	d0,d1				; d1 gets joystick return value
	bsr	RJP_Chk_Joystk_Valid		; is data valid for joystick ?
	beq.s	RJP_Joystk_State_08		; if yes, j to incr delay
;
; Data is invalid, go to mouse state :
;
	move.w	#(JP_TYPE_MOUSE)>>16,(a2)	; set state
	bra	RJP_Mouse_State			;
;
; Data is valid delay for several times befor checking for other controller :
;
RJP_Joystk_State_08:
	bsr	RJP_Incr_Port_Status_Counter	; d1 gets new counter value
	cmp.b	#JP_JOYSTK_2_UNKNOWN,d1		; is counter at max ?
	blt	RJP_Return			; if no, j to return
;
; Counter is at maximum, clear counter and set unknown bit :
;
RJP_Joystk_State_10:
	move.w	#(JP_STATUSF_UNKNOWN!JP_TYPE_JOYSTK)>>16,(a2)	; set state
	bra	RJP_Return					; j to unknown state routine
a336 3


; *****************************************************************************
d338 1
a338 4
; The following subroutine will take the raw direction data from a Joy
; Port and update the appropriate bits for returning in d1.  There are two
; entry points to this routine.  The first will read the raw data from the
; joy port the other will assume the joy port data is in d1.
d340 6
a345 16
;	On Entry:	a3 = ptr to custom register base
;			a4 = ptr to ciaa register base
;			a5 = ptr to joy port data register
;			a6 = ptr to lowlevel library base
;			d4 = mask to set appropriate Fire Button for clocking
;			d5 = mask to set appropriate Output Enable for Mux
;
;	On Exit:	d1 = bits 3..0 updated with direction status
;
;	Regs used:	d1,d2,d3
;
RJP_Get_Joy_Direction:

	move.w	(a5),d1				; d1 gets port data

RJP_Get_Joy_Direction_02:
a346 1
	moveq	#0,d3				; d3 is temp data reg
d348 1
a348 1
; Move LF and RT directions to d3 :
d350 4
a353 17
	move.w	d1,d2				; save for later use
	andi.w	#JOYDATF_Y1!JOYDATF_X1,d1	; mask out non LF and RT bits
	ror.w	#1,d1                           ; rotate to bits 0 and 8
	ror.b	#1,d1                           ; rotate bit 0 to 7
	ror.w	#7,d1                           ; rotate to bits 0 and 1
	or.b	d1,d3                           ; d3 gets LF and RT bits
;
; Move UP and DN directions to d3 :
;
	move.w	d2,d1				; d1 gets port data
	andi.w	#JOYDATF_Y1!JOYDATF_X1,d1	; mask out non LF and RT bits
	andi.w	#JOYDATF_Y0!JOYDATF_X0,d2	; mask out non UP and DN bits
	ror.w	#1,d1				; rotate d1 to match position
	eor.w	d1,d2				; xor to get real UP and DN values
	ror.b	#1,d2				; rotate to bits 0 and 7
	ror.w	#5,d2				; rotate to bits 2 and 3
	or.b	d2,d3				; d3 gets UP and DN bits
d355 2
a356 1
	move.l	d3,d1				; return value in d1
d358 2
a359 2
        rts

d361 2
d364 4
d370 2
a371 2
; The following subroutine will take the raw button data from a Joy
; Port and update the appropriate bits for returning in d1.  The buttons that will
a375 2
;			a5 = ptr to joy port data register
;			a6 = ptr to lowlevel library base
a378 1
;	On Exit:	d1 = bits 16..23 updated with button status
a379 3
;	Regs used:	d1,d2,d3
;
RJP_Get_Joy_Buttons:
a380 1
	moveq	#0,d3				; d3 is temp data reg
d388 1
a388 1
	ori.l	#JPF_BTN2,d3			; set fire button in temp reg
d406 1
a406 1
	ori.l	#JPF_BTN1,d3			; set right button in temp reg
d414 2
a415 3
	ori.l	#JPF_BTN7,d3			; set middle button in temp reg
3$:	move.l	d3,d1				; return value in d1
        rts
d418 3
d422 3
a424 1
; *****************************************************************************
d426 1
a426 2
; The following subroutine will clock the button settings out of the game
; controller.  The bits will be collected and returned in d1.
d428 8
a435 6
;	On Entry:	a3 = ptr to custom register base
;			a4 = ptr to ciaa register base
;			a5 = ptr to joy port data register
;			a6 = ptr to lowlevel library base
;			d4 = mask to set appropriate Fire Button for clocking
;			d5 = mask to set appropriate Output Enable for Mux
d437 1
a437 1
;	On Exit:        d1 = bits 8..0 updated with buttons
d439 5
a443 3
;	Regs used:      d1,d2,d3,d6
;
RJP_Clock_Game_Ctlr:
a444 2
;	DISABLE	a1				; prevent reentrance
	bset	#JP_STATUSB_CLOCKING_CTLR%%8,ll_Port1State(a6)	; critical section flag
d446 4
d451 1
a451 1
; Set direction for fire button :
a452 4
	move.b	ciaddra(a4),d1			; d1 gets ddra data
	or.b	d4,d1				; set fire as output
	move.b	d1,ciaddra(a4)			; update ddra register

d454 3
a456 1
; Enable game controller mux (enable output and send it a low) :
d458 2
a459 11
	move.w	d5,d2				; d2 gets OE for mux bit
	lsr.w	#1,d2				; shift for mux data position
	not	d2				; make mux data LOW
	move.w	potinp(a3),d1			; d1 gets POTGOR data
	or.w	d5,d1				; set output enable for mux
	and.w	d2,d1				; clear the data bit for mux
	move.w	d1,potgo(a3)			; drive controller high

	move.w	ciapra(a4),d1			; delay after enable
	move.w	ciapra(a4),d1			; * delay after enable

d461 1
a461 1
; Set loop counter and clear temp data register :
d463 1
a463 2
	moveq	#8,d6				; d6 is loop counter
	moveq	#0,d3				; d3 is temp data reg
d466 1
a466 1
; Loop for all bits :
d468 2
a469 1
RJP_Clock_Game_Ctlr_Loop:
d471 6
a476 4
	move.w	ciapra(a4),d1			; delay abount 3 us
	move.w	ciapra(a4),d1			;
;	move.w	ciapra(a4),d1			; extra delay
	move.w	potinp(a3),d2			; d2 gets POTGOR data
a477 7
;
; Clock for next value :
;
	move.b	ciapra(a4),d1  			; d1 low gets pra data
	or.b	d4,d1				; clear fire bit
	eor.b	d4,d1				;
	move.b	d1,ciapra(a4)			; update pra register
a478 2
	tst.w	d6				; is this last iteration ?
	beq.s	4$ 				; if yes, j to skip giving clock
d480 1
a480 4
;	move.b	ciapra(a4),d1			; d1 low gets pra data
	or.b	d4,d1				; set fire bit
	move.b	d1,ciapra(a4)			; update pra register
4$:
d482 2
a483 1
; Munge the button data bit into d3 :
d485 2
a486 7
	move.w	d5,d1				; d1 gets output enable
	lsl.w	#1,d1				; shift for RT data position
	and.w	d1,d2				; is button down ? (low active)
	bne.s	6$				; if no, j to skip bit set
	bset	d6,d3				; set button down in temp reg
6$:	dbra	d6,RJP_Clock_Game_Ctlr_Loop	; loop for all bits

d488 4
a491 1
; Disable game controller mux (enable output and send it a high) :
d493 1
a493 7
	move.w	d5,d2				; d2 gets output enable bit
	lsr.w	#1,d2				; shift for MID data position
	move.w	potinp(a3),d1			; d1 gets POTGOR data
	or.w	d5,d1				; set output enable for mux
	or.w	d2,d1				; set data for mux HIGH
	move.w	d1,potgo(a3)			; drive controller high

d495 1
a495 1
; Restore direction of fire button to input :
d497 1
a497 4
	move.b	ciaddra(a4),d1			; d1 gets ddra data
	or.b	d4,d1				; clear fire as output
	eor.b	d4,d1				;
	move.b	d1,ciaddra(a4)			; update ddra register
d499 3
a501 2
	move.w	ciapra(a4),d1			; * delay after enable
	move.w	ciapra(a4),d1			; * delay after enable
d503 6
a508 2
	bclr	#JP_STATUSB_CLOCKING_CTLR%%8,ll_Port1State(a6)	; critical section flag
;	ENABLE	a1				; allow reentrance
d510 4
a513 2
	move.l	d3,d1				; return value in d1
	rts
d519 19
a537 1
; The following subroutine will increment the port status counter field.
d539 1
a539 1
;	On Entry:	a2 = ptr to port status flag
d541 1
a541 15
;	On Exit:	(a2) = counter field incremented by one
;			d1 = new value counter field in low order 8 bits
;
;	Regs used:	d1
;
RJP_Incr_Port_Status_Counter:

	move.l	(a2),d1				; d1 gets port status flag
	addi.l	#$010000,d1			; increment counter field
	move.l	d1,(a2)				; update port status flags
	swap	d1				; put counter in bits 00..07
	andi.l	#$0FF,d1			; clear all except counter field
	rts


a542 1
; *****************************************************************************
d544 1
a544 2
; The following subroutine will determine if the current joy port data is
; within joy stick range of the saved joy port data.
d546 2
a547 5
;	On Entry:	d1 = current joy port data
;			d2 = saved joy port data
;
;	On Exit:	Cond Code = LE if data is in joystick range
;			Cond Code = GT if data is not in joystick range
d549 1
a549 1
;	Regs used:	d1,d2,d3
d551 2
a552 1
RJP_Chk_Joystk_Range:
d556 1
a556 1
	sub.b	d1,d2				; check if H value has changed
d558 2
a559 2
	neg.b	d2                              ; change value to positive
2$:	move.b	d2,d3				; d3 gets temp value
d564 2
a565 2
	lsr.w	#8,d2				;
	sub.b	d1,d2				; check if V value has changed
d567 79
a645 4
	neg.b	d2                              ; change value to positive
6$:	add.b	d2,d3				; add to temp value
	cmpi.b	#03,d3				; is horizontal in range ?
8$:	rts					;
d647 6
a652 6


; *****************************************************************************
;
; The following subroutine will determine if the current joy port data is
; valid for a joystick.
d654 1
a654 1
;	On Entry:	d1 = direction bits of joystick return value
d656 2
a657 1
;	On Exit:	Cond Code = EQ if data is valid for joystick
d660 1
a660 1
;	Regs used:	d1,d2
d662 2
a663 1
RJP_Chk_Joystk_Valid:
d665 29
a693 5
	move.w	d1,d2				; d2 gets return value
	andi.l	#(JPF_UP!JPF_LEFT),d1		; clear all except Up and LEFT
	andi.l	#(JPF_DOWN!JPF_RIGHT),d2	; clear all except Down and RIGHT
	lsr.b	#1,d1				;
	and.b	d1,d2				; is data valid ?
@


40.2
log
@Added NOTE to the autodoc to show the true nature of the beast.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 40.1 93/02/19 17:48:13 Jim2 Exp Locker: Jim2 $
d8 3
d88 1
a88 1
	INCLUDE	"/gamebase.i"
d90 1
a90 1
	INCLUDE	"/game.i"
d100 1
a100 1
******* game.library/ReadJoyPort *********************************************
d148 2
a149 2
*	            The following constants (defined in <libraries/game.i>
*		    and <libraries/game.h>)
d202 1
a202 1
	bset	#JP_STATUSB_ALREADYRUNNING%%8,gm_Port0State(a6)	; is this reentrance ?
d207 1
a207 1
	bclr	#JP_STATUSB_FIRST_INIT_REQ%%8,gm_Port0State(a6)	; is init required ?
d222 1
a222 1
        lea	gm_Port0State(a6),a2		; a2 gets ptr to port 0 status flag
d231 1
a231 1
        lea	gm_Port1State(a6),a2		; a2 gets ptr to port 1 status flag
d254 1
a254 1
	bclr	#JP_STATUSB_ALREADYRUNNING%%8,gm_Port0State(a6)	; clr for reentrance
d286 1
a286 1
;			a6 = ptr to game library base
d374 1
a374 1
;			a6 = ptr to game library base
d437 1
a437 1
;			a6 = ptr to game library base
d516 1
a516 1
;			a6 = ptr to game library base
d583 1
a583 1
;			a6 = ptr to game library base
d634 1
a634 1
;			a6 = ptr to game library base
d692 1
a692 1
;			a6 = ptr to game library base
d703 1
a703 1
	bset	#JP_STATUSB_CLOCKING_CTLR%%8,gm_Port1State(a6)	; critical section flag
d788 1
a788 1
	bclr	#JP_STATUSB_CLOCKING_CTLR%%8,gm_Port1State(a6)	; critical section flag
@


40.1
log
@Brought the autodoc in line with standard format.  Added
better description for the game controller buttons.  Removed
Dave's controller picture.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 40.0 93/02/11 17:33:03 Jim2 Exp Locker: Jim2 $
d8 5
d123 11
@


40.0
log
@Change to use the new single include file.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 39.12 93/01/20 13:18:48 brummer Exp Locker: Jim2 $
d8 3
d129 4
a132 3
*	            The following constants (defined in GetJoyPortEvent.i
*	            and GetJoyPortEvent.h) can be used to determine which
*	            device is attached and the state of that device :
d145 11
a155 12
*			JPF_BTN1		Right
*			JPF_BTN2		Fire
*			JPF_BTN3
*			JPF_BTN4
*			JPF_BTN5		Right ear
*			JPF_BTN6		Left ear
*			JPF_BTN7		Middle
*			JPF_RSVDBTN		Reserved
*			JPF_UP			Up direction
*			JPF_DOWN		Down direction
*			JPF_LEFT		Left direction
*			JPF_RIGHT		Right direction
d160 4
a163 4
*			JPF_UP			Up direction
*			JPF_DOWN		Down direction
*			JPF_LEFT		Left direction
*			JPF_RIGHT		Right direction
d166 3
a168 3
*			JPF_BTN1		Right mouse button
*			JPF_BTN2		Left mouse button
*			JPF_BTN7		Middle mouse button
a171 24
*
*	The following diagram shows the button configuration of the
*	Game Controller :
*
*	          JPF_BTN6                                       JPF_BTN5
*	        ----                                           ----
*	       |    |                                         |    |
*	    ---|----|-----------------------------------------|----|---
*	  /                                                             \
*	 /                                                JPF_BTN3       \
*	            JPF_UP                               --
*	|             |                                 |  |      JPF_BTN1|
*	|             |                  JPF_BTN7        --      --       |
*	|             |                 --                      |  |      |
*	| JPF_LEFT----+----JPF_RIGHT   |  |          JPF_BTN4    --       |
*	|             |                 --          --                    |
*	|             |                            |  |      JPF_BTN2     |
*	|             |                             --      --            |
*	           JPF_DOWN                                |  |
*	 \                                                  --           /
*	  \                                                             /
*	    -----------------------------------------------------------
*
*
d179 1
a179 1
        movem.l	d1-d5/a1-a5,-(sp)
d236 1
a236 1
        movem.l	(sp)+,d1-d5/a1-a5
@


39.12
log
@fix autodoc tab alignment
@
text
@d3 1
a3 1
*	$Id: Readjoyport.asm,v 39.11 93/01/19 14:20:07 brummer Exp Locker: brummer $
d7 4
a10 1
*	$Log:	Readjoyport.asm,v $
d79 1
a79 1
	INCLUDE	"/ReadJoyPort.i"
@


39.11
log
@Update AUTODOC with diagram of the Game Controller
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 39.10 93/01/18 18:03:29 brummer Exp Locker: brummer $
d7 4
a10 1
*	$Log:	ReadJoyPort.asm,v $
d170 3
a172 3
*                 JPF_BTN6                                       JPF_BTN5
*               ----                                           ----
*              |    |                                         |    |
@


39.10
log
@Seperated initialization code into seperate module
Updated to use "almost semiphore" with gameport and new initialization code
Updated to prevent reentrance because of game controller clocking
Updated Autodocs
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 39.9 93/01/14 10:48:43 brummer Exp Locker: brummer $
d8 6
d99 1
a99 1
*	appropriatly formatted state.
d105 4
a108 2
*	attached, this function requires several calls and some movement at
*	the joy port by the user.
d162 23
@


39.9
log
@Fix to prevent invalid game controller clocks on Jim's 4000.  Further
testing on other platforms is still necessary.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 39.8 93/01/12 16:58:41 brummer Exp Locker: brummer $
d8 4
d51 8
a59 1
        INCLUDE "exec/ables.i"
d62 1
a63 1
	INCLUDE	"/ReadJoyPort.i"
d66 2
a69 3
	XDEF	ReadJoyPort
	XDEF	ReadJoyPortInit

d73 1
d75 1
d84 1
a84 1
*	D0			D0
d90 11
a100 2
*	joy port and the current position/button state.  The user may have
*	a Mouse, Game Controller, or Joystick attached to the port.
d127 7
a133 7
*			JPF_BTN1		Button 1 (Right)
*			JPF_BTN2		Button 2 (Fire)
*			JPF_BTN3		Button 3
*			JPF_BTN4		Button 4
*			JPF_BTN5		Button 5 (Right ear)
*			JPF_BTN6		Button 6 (Left ear)
*			JPF_BTN7		Button 7 (Middle)
d138 1
a138 1
*			JPF_RIGHTT		Right direction
d141 2
a142 2
*			JPF_BTN1		Button 1 (Right)
*			JPF_BTN2		Button 2 (Fire)
d146 1
a146 1
*			JPF_RIGHTT		Right direction
d149 3
a151 2
*			JPF_BTN1		Button 1 (Right mouse button)
*			JPF_BTN2		Button 2 (Left mouse button)
d158 1
a158 2
        SECTION code

d165 11
d178 1
a186 1
RJP_Main_02:
a199 1

d205 1
a205 1
        bmi	RJP_Unknown_State		; if unknown bit is set, j to routine
d219 1
a221 2


a235 33
; The following subroutine will do the initialization necessary for the
; ReadJoyPort function.  This includes the following actions :
;
;	- Set the port status flag state to UNKNOWN
;	- Set the port status flag counter to 0
;	- Set the port status vertical and horizontal positions to current value
;
;	On Entry:	a5 = pointer to game base
;
;	On Exit:	Port status flags initialized
;
;	Regs used:	none
;
ReadJoyPortInit:

        movem.l	a1/d1,-(sp)				; save registers
	lea	_custom,a1				; a1 gets base of custom registers

	move.l	#(JP_STATUSF_UNKNOWN!JP_TYPE_UNKNOWN),d1; d1 gets state, ctr=0, & unknown bit
	move.w	joy0dat(a1),d1				; d1 gets port 0 data
	move.l	d1,gm_Port0State(a5)			; update port 0 status flag

	move.w	joy1dat(a1),d1				; d1 gets port 1 data
	move.l	d1,gm_Port1State(a5)			; update port 1 status flag

	movem.l	(sp)+,a1/d1				; restore registers

	rts



; *****************************************************************************
;
d251 1
d290 1
a290 1
	bra	RJP_Mouse_State			; j to mouse state
d313 1
a313 1
	bra	RJP_Mouse_State			; j to mouse state
d319 1
a319 1
	bra	RJP_GameCtlr_State_06		; j to GAME STATE
d339 1
d402 1
d444 1
a444 1
	bsr	RJP_Get_Joy_Direction_02	; d1 gets direction values in 0..3
d481 1
d495 1
a495 1
	bsr	RJP_Get_Joy_Buttons		; d1 gets button data
d500 1
a500 1
	bsr	RJP_Get_Joy_Direction		; d1 gets direction values in 0..3
d548 1
d599 1
d657 1
d667 2
a668 1
	DISABLE	a1				; prevent reentrance
d752 3
a754 1
	ENABLE	a1				; allow reentrance
@


39.8
log
@Fixed the previous fix.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 39.7 93/01/12 10:56:12 brummer Exp Locker: brummer $
d8 3
a48 2
	LIST

d51 1
d83 2
a84 2
*	PortNumber - Unsigned long that selects the port to read.  This value
*		     should be in the range of 0..1.
d102 2
a103 2
*			JP_TYPE_JOYSTK	joystick
*			JP_TYPE_UNKNOWN	unknown device
d106 12
a117 12
*			JPF_BTN1	Button 1 (Right)
*			JPF_BTN2	Button 2 (Fire)
*			JPF_BTN3	Button 3
*			JPF_BTN4	Button 4
*			JPF_BTN5	Button 5 (Right ear)
*			JPF_BTN6	Button 6 (Left ear)
*			JPF_BTN7	Button 7 (Middle)
*			JPF_RSVDBTN	Reserved
*			JPF_UP		Up direction
*			JPF_DOWN	Down direction
*			JPF_LEFT	Left direction
*			JPF_RIGHTT	Right direction
d120 6
a125 6
*			JPF_BTN1	Button 1 (Right)
*			JPF_BTN2	Button 2 (Fire)
*			JPF_UP		Up direction
*			JPF_DOWN	Down direction
*			JPF_LEFT	Left direction
*			JPF_RIGHTT	Right direction
d128 4
a131 6
*			JPF_BTN1	Button 1 (Right mouse button)
*			JPF_BTN2	Button 2 (Left mouse button)
*			JP_MVERT_MASK	Mask for mouse vertical counter
*			JP_MHORZ_MASK	Mask for mouse horizontal counter
*
*   SEE ALSO
d142 1
a142 2
        movem.l	d1/d2/d3/d4/d5/d6,-(sp)
        movem.l	a1/a2/a3/a4/a5/a6,-(sp)
d180 5
d188 1
a188 2
        movem.l	(sp)+,a1/a2/a3/a4/a5/a6
        movem.l	(sp)+,d1/d2/d3/d4/d5/d6
a191 4
RJP_NotAvail_State:
	move.l	#JP_TYPE_NOTAVAIL,d0		; set not avail return value
	bra.s	RJP_Return			;

d684 1
d745 2
@


39.7
log
@Fix to extra mouse state check added in previous rev,
Updated comments in code to reflect actions in each state.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 39.6 93/01/11 16:04:55 brummer Exp Locker: brummer $
d8 4
a513 1

d823 1
a823 1
	move.w	d0,d2				; d2 gets return value
@


39.6
log
@Add temporary fix for right mouse button being stuck on when mouse is in port 1.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPOrt.asm,v 39.5 93/01/11 15:33:03 brummer Exp Locker: brummer $
d7 4
a10 1
*	$Log:	ReadJoyPOrt.asm,v $
a233 2


d239 2
a240 2
;	- Attempt to clock the controller :
;		- If OK, then STATE = GAME
d242 1
a242 1
;		- If No, return 0, STATE = UNKNOWN
d244 2
a245 2
;		- If Horiz/Vert change, STATE = MOUSE
;		- If Direction only change, STATE = JOY
d254 2
a255 1
;	On Exit:
d257 1
a257 1
;	Regs used:
d329 2
a330 1
;		- If no, set state to UNKNOWN and jump to unknown state routine
d341 1
a341 1
;	On Exit:        d0 updated with current controller state
d343 1
a343 1
;	Regs used:	all
d383 13
d403 1
a403 1
;	On Exit:
d405 1
a405 1
;	Regs used:
d437 1
a437 1
; Increment delay counter and check for max :
d440 2
d444 3
d463 10
d481 1
a481 1
;	On Exit:
d483 1
a483 1
;	Regs used:
d510 2
d538 3
a540 1
; Port and update the appropriate bits for returning in d1.
d554 4
a561 1
	move.w	(a5),d1				; d1 gets port data
d589 2
a590 1
; Port and update the appropriate bits for returning in d1.
d611 1
a611 1
	beq	1$				; j if not set
d629 1
a629 1
	beq	2$				; j if not set
d637 1
a637 1
	beq	3$				; j if not set
d756 1
a756 1
;			d1 = new value counter field
d811 1
a811 1
;	On Entry:	d0 = current joy port data
a819 1
	move.w	d0,d1				; d1 gets return value
@


39.5
log
@Added extra test to mouse state to prevent sperious returns of 
joystick type.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 39.4 93/01/07 15:57:27 brummer Exp Locker: brummer $
d7 5
a11 1
*	$Log:	ReadJoyPort.asm,v $
d577 9
a585 1
1$:	move.w	potinp(a3),d1			; d1 gets POTGOR data
@


39.4
log
@Added /gamebase.i to the include file list.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 39.3 93/01/07 15:38:52 brummer Exp Locker: brummer $
d8 3
d413 1
d420 2
d475 1
a475 6
	move.w	d0,d1				; d1 gets return value
	move.w	d0,d2				; d2 gets return value
	andi.l	#(JPF_UP!JPF_LEFT),d1		; clear all except Up and LEFT
	andi.l	#(JPF_DOWN!JPF_RIGHT),d2	; clear all except Down and RIGHT
	lsr.b	#1,d1
	and.b	d1,d2				; is data valid ?
d752 25
@


39.3
log
@Updated to support dynamic changing controller types.
Added 1 extra CIA delay after enabling game ctlr MUX.
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 39.2 93/01/05 12:28:45 Jim2 Exp Locker: Unknown $
d8 4
d38 1
@


39.2
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Id: ReadJoyPort.asm,v 39.1 93/01/05 12:02:14 Jim2 Exp Locker: Jim2 $
d8 3
d37 1
a119 1

a124 1

d131 2
a132 2
	beq.s	GJPE_Main_04			; if yes, j to setup regs
	bgt.s	GJPE_Return_Error		; if above 1, return error
d136 3
a138 2
GJPE_Main_02:
        lea	_custom+joy0dat,a5		; a5 gets ptr to joy port 0 data
d141 1
a141 1
	bra.s	GJPE_Main_08			; j to continue
d145 3
a147 2
GJPE_Main_04:
        lea	_custom+joy1dat,a5		; a5 gets ptr to joy port 1 data
d152 1
a152 1
; Call routines to update return value :
d154 7
a160 11
GJPE_Main_08:
	moveq	#0,d0				; clear return value
        bsr.s	GJPE_Get_Ctlr_Type		; d1 get controller type in 31..28
        or.l	d1,d0				; update return value
	bsr.s	GJPE_Get_Joy_Dir		; d1 gets direction values in 0..3
        or.l	d1,d0				; update return value
	bsr.s	GJPE_Get_Buttons		; d1 gets button values in 0..8
	lsr.l	#1,d1				;
	swap	d1				; move button data to return location
        or.l	d1,d0				; update return value

d164 1
a164 1
GJPE_Return:
d169 163
a331 1
GJPE_Return_Error:
d333 26
a358 1
	bra.s	GJPE_Return			;
d361 1
d364 3
a366 2
; The following subroutine will determine the controller type and update the
; appropriate bits for returning value in d1.
d368 2
a369 1
;	On Entry:	a3 = ptr to custom register base
d375 7
a381 1
;	On Exit:	d1 = bits 31..28 updated with controller type
d383 4
a386 1
;	Regs used:	none
d388 31
a418 1
GJPE_Get_Ctlr_Type:
a419 1
	move.l	#JP_TYPE_GAMECTLR,d1
d421 19
a439 1
	rts
d441 48
d494 2
a495 2
; The following subroutine will take the raw data from a Joy port and
; update the appropriate bits for returning in d1.
d503 1
a503 1
;	On Exit:	d1 = bits 3..0 updated with direction from Joy port.
d507 1
a507 1
GJPE_Get_Joy_Dir:
d511 1
a511 1
; Move LF and RT directions to d0 :
d514 1
d521 1
a521 1
; Move UP and DN directions to d0 :
d523 1
a523 2
	move.w	(a5),d1				; d1 gets port data
	move.w	d1,d2	 			; d2 gets same
d540 49
d602 1
a602 1
GJPE_Get_Buttons:
d624 2
d635 1
a635 1
GJPE_Get_Buttons_Loop:
d639 1
d651 1
a651 1
	beq.s	1$ 				; if yes, j to skip giving clock
d656 1
a656 2

1$:
d663 1
a663 1
	bne.s	2$				; if no, j to skip bit set
d665 1
a665 2
2$:
	dbra	d6,GJPE_Get_Buttons_Loop	; loop for all bits
d688 1
d690 20
d714 32
a746 1
        END
d750 1
@


39.1
log
@Renamed from GetJoyPortEvent.asm.  Also changed the bit flag
defintions.
@
text
@d3 1
a3 1
*	$Id: $
d8 4
d40 1
a40 1
****** ReadJoyPort ***********************************************************
@


39.0
log
@Initial Release.
@
text
@d3 1
a3 1
*	$Id:  $
d7 3
a9 1
*	$Log: $
d12 1
d25 2
a26 1
	INCLUDE	"/GetJoyPortEvent.i"
d29 1
a29 1
	XDEF	GetJoyPortEvent
d36 1
a36 1
****** GetJoyPortEvent *******************************************************
d39 1
a39 1
*	GetJoyPortEvent - Return the state of the selected joy/mouse port.
d42 2
a43 2
*	PortState = GetJoyPortEvent(PortNumber)
*	D0				D0
d45 1
a45 1
*	ULONG GetJoyPortEvent(ULONG);
d67 1
a67 1
*		    the mask GJPE_TYPE_MASK to the return value and comparing
d70 33
a102 33
*			GJPE_TYPE_NOTAVAIL	port data unavailable
*			GJPE_TYPE_GAMECTLR	game controller
*			GJPE_TYPE_MOUSE		mouse
*			GJPE_TYPE_JOYSTK	joystick
*			GJPE_TYPE_UNKNOWN	unknown device
*
*	            If type = GJPE_TYPE_GAMECTLR the bit map of PortState is:
*			GJPEF_BTN1	Button 1 (Right)
*			GJPEF_BTN2	Button 2 (Fire)
*			GJPEF_BTN3	Button 3
*			GJPEF_BTN4	Button 4
*			GJPEF_BTN5	Button 5 (Right ear)
*			GJPEF_BTN6	Button 6 (Left ear)
*			GJPEF_BTN7	Button 7 (Middle)
*			GJPEF_RSVDBTN	Reserved
*			GJPEF_UPDIR	Up direction
*			GJPEF_DNDIR	Down direction
*			GJPEF_LFDIR	Left direction
*			GJPEF_RTDIR	Right direction
*
*	            If type = GJPE_TYPE_JOYSTK the bit map of PortState is:
*			GJPEF_BTN1	Button 1 (Right)
*			GJPEF_BTN2	Button 2 (Fire)
*			GJPEF_UPDIR	Up direction
*			GJPEF_DNDIR	Down direction
*			GJPEF_LFDIR	Left direction
*			GJPEF_RTDIR	Right direction
*
*	            If type = GJPE_TYPE_MOUSE the bit map of PortState is:
*			GJPEF_BTN1	Button 1 (Right mouse button)
*			GJPEF_BTN2	Button 2 (Left mouse button)
*			GJPE_MVERT_MASK	Mask for mouse vertical counter
*			GJPE_MHORZ_MASK	Mask for mouse horizontal counter
d111 1
a111 1
GetJoyPortEvent:
d187 1
a187 1
	move.l	#GJPE_TYPE_GAMECTLR,d1
@
