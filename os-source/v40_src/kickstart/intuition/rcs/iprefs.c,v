head     38.21;
branch   ;
access   ;
symbols  V40_85:38.21 V40_71:38.21 V40_68:38.21 V40_65:38.21 V40_47:38.21 V40_45:38.21 V40_37:38.21 V40_34:38.21 V40_29:38.21 V39_2415:38.21 V39_2369:38.21 V39_2339:38.20 V39_2332:38.20 V39_2275:38.19 V39_2256:38.19 V39_2210:38.19 V39_2192:38.19 V39_2084:38.19 V39_2082:38.19 V39_2076:38.19 V39_2073:38.19 V39_2058:38.19 V39_2051:38.19 V39_2031:38.19 V39_2017:38.19 V39_2012:38.18 V39_1985:38.18 V39_1933:38.18 V39_1819:38.16 V39_1805:38.16 V39_1783:38.16 V39_1695:38.15 V39_1621:38.15 V39_1620:38.15 V39_1508:38.14 V39_1485:38.14 V39_1461:38.14 V39_1458:38.13 V39_1456:38.12 V39_1405:38.11 V39_1368:38.10 V39_1360:38.10 V39_1324:38.9 V39_1147:38.7 V39_1143:38.7 V39_1141:38.7 V39_1120:38.7 V39_1116:38.7 V39_1104:38.7 V39_1100:38.7 V39_1078:38.7 V39_1073:38.7 V39_757:38.5 V39_702:38.5 V39_557:38.4 V39_553:38.4 V39_551:38.4 V39_510:38.4 V39_495:38.4 V39_416:38.4 V39_383:38.4 V39_371:38.3 V39_336:38.3 V39_323:38.3 V39_295:38.3 V39_277:38.2 V39_254:38.1 V39_222:38.1 V39_185:38.1 V39_171:38.1 V39_161:38.1 V38_159:38.1 V38_116:38.1 V38_59:38.1;
locks    ; strict;
comment  @*   @;


38.21
date     93.01.08.14.47.33;  author peter;  state Exp;
branches ;
next     38.20;

38.20
date     92.12.09.18.13.09;  author peter;  state Exp;
branches ;
next     38.19;

38.19
date     92.08.06.15.48.19;  author peter;  state Exp;
branches ;
next     38.18;

38.18
date     92.08.03.15.54.31;  author peter;  state Exp;
branches ;
next     38.17;

38.17
date     92.08.02.13.15.51;  author peter;  state Exp;
branches ;
next     38.16;

38.16
date     92.07.17.17.27.34;  author peter;  state Exp;
branches ;
next     38.15;

38.15
date     92.06.23.17.19.34;  author peter;  state Exp;
branches ;
next     38.14;

38.14
date     92.06.05.13.48.37;  author peter;  state Exp;
branches ;
next     38.13;

38.13
date     92.06.04.16.17.05;  author peter;  state Exp;
branches ;
next     38.12;

38.12
date     92.06.02.14.54.12;  author peter;  state Exp;
branches ;
next     38.11;

38.11
date     92.05.29.18.27.52;  author peter;  state Exp;
branches ;
next     38.10;

38.10
date     92.05.27.11.54.15;  author peter;  state Exp;
branches ;
next     38.9;

38.9
date     92.05.21.17.40.58;  author peter;  state Exp;
branches ;
next     38.8;

38.8
date     92.05.15.14.06.18;  author peter;  state Exp;
branches ;
next     38.7;

38.7
date     92.04.07.17.52.29;  author peter;  state Exp;
branches ;
next     38.6;

38.6
date     92.04.02.12.04.47;  author peter;  state Exp;
branches ;
next     38.5;

38.5
date     92.03.19.10.53.51;  author peter;  state Exp;
branches ;
next     38.4;

38.4
date     92.02.07.11.06.43;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     91.12.12.20.44.19;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     91.11.25.16.56.09;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.07.10.17.57.07;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.12.14.24.20;  author peter;  state Exp;
branches ;
next     ;


desc
@@


38.21
log
@Minor optimization by caching IBase->GfxBase.
@
text
@
/*** iprefs.c ************************************************************** 
 * 
 *  Intuition's interaction with New Preferences
 * 
 *  $Id: iprefs.c,v 38.20 92/12/09 18:13:09 peter Exp Locker: peter $
 *
 *  Confidential Information: Commodore-Amiga, Inc. 
 *  Copyright (C) 1989, Commodore-Amiga, Inc. 
 *  All Rights Reserved 
 * 
 ***************************************************************************/ 
 
#include "intuall.h" 
#include "preferences.h" 

#ifndef EXEC_INITIALIZERS_H
#include <exec/initializers.h>
#endif

#ifndef GRAPHICS_DISPLAYINFO_H
#include <graphics/displayinfo.h>
#endif

#ifndef GRAPHICS_MODEID_H
#include <graphics/modeid.h>
#endif

#include "pointerclass.h"

#define D(x)		;
#define DBACK(x)	;	/* backsync */
#define DSYNC(x)	;	/* sync */

/* used several places:
 * in alerts
 * as fallback if string gadget font too big
 * as rom default font.
 */
struct IFontPrefs topazprefs = {
     {{ topazprefs.ifp_TABuff.tab_NameBuff, 8, 0, 0, }, KARLA},
     NULL,
    IPF_SYSFONT,
};

/* is there enough Preferences buffer to hold 'field'?	*/
#define ENUFPREFS( field ) ( ((ULONG) OFFSET(Preferences, field) )+ \
	    sizeof(((struct Preferences *)0)->field) )

/*
 *  calls setIPrefs() with data constructed from old
 *  struct Preferences, for data which is defined in both old
 *  and new Preferences.  The following are always respected:
 *	- palette
 *	- view position
 *	- text overscan (morerows)
 *
 *  The following are respected once only (i.e. from SetPrefs() of
 * 	devs:system-configuration):
 *	- system font (size of topaz)
 *	- workbench interlace
 *	- pointer
 */
syncIPrefs( size )
int size;
{
    struct IntuitionBase *IBase = fetchIBase();
    struct Preferences *oldprefs = IBase->Preferences;

    extern struct IScreenModePrefs	DefaultScreenMode;
    union {
	struct IScreenModePrefs		screenmode;
	struct IFontPrefs	font;
	struct INewPointerPrefs	pointer;
    } p;

    D( printf("---- syncIPrefs\n") );

    if( ! TESTFLAG( IBase->Flags, SEENIPALETTE ) )
    {
	/* We only listen to colors from SetPrefs until we've received
	 * new colors, since there's more color-resolution through
	 * the new method.
	 */
	/* Here we set colors directly, instead of calling SetIPrefs
	 * with the data!
	 */
	setColorPrefs( &oldprefs->color0, WBCOLOR_FIRST4, 4 );
	setColorPrefs( &oldprefs->color17, WBCOLOR_POINTER, 3 );
	/* set up only the 7 preferences colors */
	setWBColorsGrunt( findWorkBench(), FALSE );
    }

    /* We sync font-height and ScreenMode only once, i.e. the SetPrefs of
     * devs:system-configuration:
     */
    if( ! TESTFLAG( IBase->Flags, SEENSETPREFS ) )
    {
	/* update system font, based on old FontHeight	*/
	copyTAttr( &topazprefs, &p.font );

	/* use the prefs size with topaz attr	*/
	p.font.ifp_TABuff.tab_TAttr.ta_YSize = oldprefs->FontHeight;

	DSYNC( printf("syncIP: font name = ----%s----\n",
	    p.font.ifp_TABuff.tab_NameBuff ) );

	p.font.ifp_SysFontType = IPF_SYSFONT;

	D( printf("syncIP: font prefs buffer at: %lx\n", &p.font ) );
	setIPrefs( &p.font, sizeof p.font, IP_FONT, FALSE );

	/* set up WB font, too	*/
	p.font.ifp_SysFontType = IPF_SCREENFONT;
	setIPrefs( &p.font, sizeof p.font, IP_FONT, FALSE );


	/* initialize CoolScreenMode to be Default, plus LACEWB	*/
	p.screenmode = DefaultScreenMode;
	if ( TESTFLAG( oldprefs->LaceWB, LACEWB ) )
	{
	    p.screenmode.ism_DisplayID = HIRESLACE_KEY;
	}
	DSYNC( printf("syncIP: default wb display ID: %lx\n",
	    p.screenmode.ism_DisplayID ) );
	setIPrefs( &p.screenmode, sizeof p.screenmode, IP_SCREENMODE, FALSE );
    }
    DSYNC( else
    {
	printf("syncIP: Not sync'ing old font or screen-mode\n");
    } )

    /* Were we given new pointer information? */
    if ( ( ! TESTFLAG( IBase->Flags, SEENIPOINTER ) ) &&
	( size >= ENUFPREFS( YOffset ) ) )
    {
	/* The BitMap field of the new pointer stuff holds the
	 * old SpriteData for compatible operation
	 */
	p.pointer.inp_BitMap = (struct BitMap *)oldprefs->PointerMatrix;
	/* NB:  Good old struct Preferences contains the "corrected"
	 * sprite X position, though new prefs contains the intended
	 * position, so we must de-compensate:
	 */
	p.pointer.inp_HotSpotX = oldprefs->XOffset - SPRITEERROR;
	p.pointer.inp_HotSpotY = oldprefs->YOffset;
	p.pointer.inp_XResolution = POINTERXRESN_LORES;
	p.pointer.inp_YResolution = POINTERYRESN_DEFAULT;
	p.pointer.inp_WordWidth = -1;	/* Signifies old-style pointer! */
	p.pointer.inp_Type = 0;

	setIPrefs( &p.pointer, sizeof p.pointer, IP_NEWPOINTER, FALSE );
    }
    DSYNC( else
    {
	printf("syncIP: Not sync'ing old pointer stuff\n");
    } )

    /* View position gets sync'd during RemakeDisplay(), since
     * now we're just another View poker.  All will be caught
     * in trackViewPos, which only allows this if
     * the active monitor is the default monitor:
     */
    IBase->ViewLord.DxOffset = IBase->ViewInitX + oldprefs->ViewXOffset;
    IBase->ViewLord.DyOffset = IBase->ViewInitY + oldprefs->ViewYOffset;
}


/* If we are not tracking people who poke the view and RemakeDisplay,
 * then syncViewPos is used in syncIPrefs(), else we use trackViewPos()
 * instead, which is called by RemakeDisplay().
 */


/*
 * If the active monitor is the default monitor and the View has shifted,
 * then update the database and poke the ViewLord offsets.
 *
 */

trackViewPos()
{
    struct IntuitionBase *IBase = fetchIBase();
    struct IOverscanPrefs ios;

    struct DimensionInfo	diminfo;
    ULONG			drecord;
    ULONG			default_id;

    DSYNC( printf("trackVP: ViewLord.Dx/yOffset: %ld,%ld\n",
	IBase->ViewLord.DxOffset, IBase->ViewLord.DyOffset ) );
    DSYNC( printf("trackVP: TrackViewDx/y      : %ld,%ld\n",
	IBase->TrackViewDx, IBase->TrackViewDy ) );
    D( printf("---- trackViewPos\n") );

    default_id = NTSC_MONITOR_ID|HIRES_KEY;
    if ( TESTFLAG( IBase->Flags, MACHINE_ISPAL ) )
    {
	default_id = PAL_MONITOR_ID|HIRES_KEY;
    }

    /* If the view changed and we can get default-view info,
     * then we update the database
     */
    if ( ( ( IBase->ViewLord.DxOffset != IBase->TrackViewDx ) ||
	( IBase->ViewLord.DyOffset != IBase->TrackViewDy ) )
	&& ( drecord = FindDisplayInfo( default_id ) )
	&& GDID( drecord, &diminfo, sizeof diminfo, DTAG_DIMS ) )
    {
	/* set up an IOverscanPrefs for the NTSC or PAL monitor,
	 * depending on the kind of machine (we used to just
	 * do it for the default monitor, but with promotion,
	 * the default monitor could be anything).
	 */
	ios.ios_DisplayID = default_id;
	ios.ios_ViewPos.x = IBase->ViewLord.DxOffset;
	ios.ios_ViewPos.y = IBase->ViewLord.DyOffset;
	ios.ios_Text.x = rectWidth( &diminfo.TxtOScan );
	ios.ios_Text.y = rectHeight( &diminfo.TxtOScan );
	ios.ios_Standard = diminfo.StdOScan;
	setIPrefs( &ios, sizeof ios, IP_OVERSCAN, FALSE );
	DSYNC( printf("trackVP:  After setIPrefs\n") );

    }
    DSYNC( else
    {
	printf("trackVP:  View unchanged\n");
    } )

    /* setIPrefs() sets up TrackViewDx/y as follows:
     *   - If the active monitor is the Default monitor, TrackViewDx/y
     *     will contain bounds-checked versions of what was poked into
     *     the ViewLord.
     *   - If the active monitor was something else, TrackViewDx will
     *     remain untouched.
     * We must freshen the ViewLord offsets to apply the bounds checking,
     * and to make non-default monitors immune to ViewLord poking.
     */

    IBase->ViewLord.DxOffset = IBase->TrackViewDx;
    IBase->ViewLord.DyOffset = IBase->TrackViewDy;
}


/*
 * private way to set Intuition's new preferences
 * I expect this sucker to be RIGHT on the money: no
 * validity or size checking for now.
 * Called by in-the-know surrogate process ONLY.
 *
 * setIBasePrefs knows how to call it for data in old struct
 * Preferences, using syncIPrefs().
 *
 * returns TRUE if I know what you're talking about.
 */

/* storage for a 'pheight' tall sprite, two uwords (4 bytes) per row,
 * plus two rows for top and bottom.  (Taken from init.c)
 */
#define SPR_STORAGE( pheight ) 	(( (pheight) + 2 ) << 2)

/* external entry point (from assembler interface file)	*/

SetIPrefs( p, psize, ptype  )
CPTR	p;		/* whatever data	*/
ULONG	psize;		/* how much data	*/
ULONG	ptype;		/* preferences type	*/
{
    struct IntuitionBase *IBase = fetchIBase();

    D( printf("SetIPrefs enter\n") );
    /* An external caller setting the Pointer or colors will
     * disable future SetPrefs() from causing sync for that item:
     */
    if ( ptype == IP_NEWPALETTE )
    {
	SETFLAG( IBase->Flags, SEENIPALETTE );
    }

    return ( setIPrefs( p, psize, ptype, TRUE ) );
}


#define ISCREENMODE( p ) 	(( struct IScreenModePrefs *) (p))
#define IFONT( p )	 	(( struct IFontPrefs *) (p))
#define IOVERSCAN( p ) 		(( struct IOverscanPrefs *) (p))
#define ICONTROL( p ) 		(( struct IIControlPrefs *) (p))
#define	INEWPOINTER(p)		((struct INewPointerPrefs *) (p))
#define ICOLORSPEC(p)		((struct ColorSpec *)(p))
#define IPENPREFS(p)		((struct IPenPrefs *) (p))

LONG
setIPrefs( pp, psize, ptype, backsync  )
CPTR	pp; /* whatever data	*/
ULONG	psize;		/* how much data	*/
ULONG	ptype;		/* preferences type	*/
BOOL	backsync;	/* Should we backsync?	*/
{
    struct IntuitionBase *IBase = fetchIBase();
    struct GfxBase       *GfxBase = IBase->GfxBase;
    struct IFontPrefs	*sysfontp;
    struct TextFont *OpenFont();

    ULONG			drecord;
    union {
	struct DimensionInfo	dim;
	struct MonitorInfo	mon;
    } info;
    int				cindex;
    struct ColorSpec		*cspec;
    struct Preferences		*oldprefs = IBase->Preferences;

    D( printf(" setIPrefs: prefs chunk type: %ld size: %ld\n", ptype, psize ) );

    switch ( ptype )
    {
    case IP_NEWPALETTE:
	if ( !pp ) return ( 0 );
	for (   cspec = ICOLORSPEC( pp );
		(cindex = cspec->ColorIndex) != -1;
		cspec++ )
	{
	    /* Only eleven colors are now passed */
	    if ( cindex < WBCOLOR_NUMBER )
	    {
		cindex = 3*cindex;
		IBase->WBColors[ cindex++ ] = cspec->Red >> 8;
		IBase->WBColors[ cindex++ ] = cspec->Green >> 8;
		IBase->WBColors[ cindex ] = cspec->Blue >> 8;
	    }
	}
	setWBColorsGrunt( findWorkBench(), TRUE );

#if 0
/* This code won't work any more... */
	if ( backsync )
	{
	    /* backsync colors to keep GetPrefs customers happy: */
	    CopyMem( &IBase->WBColors[0], &oldprefs->color0, 4 * sizeof (UWORD) );
	    CopyMem( &IBase->WBColors[17], &oldprefs->color17, 3 * sizeof (UWORD) );
	    DBACK( printf( "Backsync colors 0-3: %lx %lx %lx %lx, 17-19: %lx %lx %lx\n",
		oldprefs->color0, oldprefs->color1, oldprefs->color2,
		oldprefs->color3, oldprefs->color17, oldprefs->color18,
		oldprefs->color19 ) );
	}
#endif
	break;

    case IP_NEWPOINTER:
	/* setDefaultMousePointer() returns NULL for failure.
	 *
	 * For the busy pointer, it returns a pointer to the 
	 * busy-pointer bitmap, to be freed by IPrefs, or ~0
	 * if this was the first busy-pointer to be sent to us.
	 *
	 * For the default pointer, it returns a pointer to the
	 * bitmap that was passed in.
	 */
	return( setDefaultMousePointer(
		INEWPOINTER(pp)->inp_BitMap, 
		/* V39 fixes the MoveSprite() for ExtSprites.  Since we're
		 * only using ExtSprites, we no longer have to account
		 * for the classic off-by-one bug in MoveSprite()
		 * YEAH!
		 */
		INEWPOINTER(pp)->inp_HotSpotX,
		INEWPOINTER(pp)->inp_HotSpotY,
		INEWPOINTER(pp)->inp_XResolution,
		INEWPOINTER(pp)->inp_YResolution,
		INEWPOINTER(pp)->inp_WordWidth,
		INEWPOINTER(pp)->inp_Type ) );

	/* Peter 1-Apr-92: We no longer backsync the Pointer part because
	 * it's getting too hairy, and there's not much benefit.
	 */

	break;

    case IP_SCREENMODE:
	/* dimension validity checking here? or in openwb? */
	/* must be >= 640x200	*/
	IBase->CoolScreenMode = *ISCREENMODE( pp );
	D( printf("setiprefs: control: %lx\n", ISCREENMODE(pp)->ism_Control));

	/* Even though LACEWB isn't very relevant to new screen modes,
	 * people do seem to depend on it.
	 */
	if (backsync)
	{
	    struct Rectangle txto;

	    oldprefs->LaceWB &= ~LACEWB;
	    /* Same lying test as GetScreenData() uses, namely:
	     * does this mode have a text-overscan >= 400 lines?
	     */
	    if ( QueryOverscan( ISCREENMODE(pp)->ism_DisplayID, &txto,
		OSCAN_TEXT ) && ( rectHeight( &txto ) >= 400 ) )
	    {
		oldprefs->LaceWB |= LACEWB;
		DBACK( printf("LaceWB: %ld\n", oldprefs->LaceWB) );
	    }
	}
	break;

    case IP_FONT:
	 D( printf("SIP: new sys font numbered: %ld\n",
	    IFONT(pp)->ifp_SysFontType) );

	/* find which system font is changing	*/
	sysfontp = &IBase->SysFontPrefs[ IFONT(pp)->ifp_SysFontType ];
	D( printf("p.font %lx type: %ld\n", IFONT(pp),
		IFONT(pp)->ifp_SysFontType ) );

	D( printf("new font name %s, size %ld\n",
	    IFONT( pp )->ifp_TABuff.tab_NameBuff,
	    IFONT( pp )->ifp_TABuff.tab_TAttr.ta_YSize ) );

	/* try to open the sucker	*/
	if ( IFONT( pp )->ifp_Font =
		OpenFont( &IFONT( pp )->ifp_TABuff.tab_TAttr ) )
	{
	    /* report the actual size opened	*/
	    IFONT( pp )->ifp_TABuff.tab_TAttr.ta_YSize =
		IFONT(pp)->ifp_Font->tf_YSize;

	    /* close previous system font	*/
	    D( printf("-- sIP: closing font: %lx -\n", sysfontp->ifp_Font ));

	    /* ZZZ: Much as it hurts, we cannot close any font that has
	     * been used as GfxBase->DefaultFont, since InitRastPort()
	     * copies this font into your RastPort, with no way for
	     * you to relinquish this font.
	     */
	    if (( IFONT(pp)->ifp_SysFontType != IPF_SYSFONT ) &&
	        ( sysfontp->ifp_Font ) )
	    {
		CloseFont( sysfontp->ifp_Font );
	    }

	    /* ZZZ: any other protection so that OpenFont
	     * gets data with integrity?
	     */
	    Forbid();
	    copyTAttr( IFONT( pp ), sysfontp );
	    sysfontp->ifp_Font = IFONT( pp )->ifp_Font;

	    if ( IFONT(pp)->ifp_SysFontType == IPF_SYSFONT )
	    {
		D( printf("---new prefs font is system font\n") );

		/* update graphics base	*/
		GfxBase->DefaultFont = sysfontp->ifp_Font;

#if 0
		/* update Intuition (perhaps critical section here)	*/
		IBase->SysFont = sysfontp->ifp_TABuff.tab_TAttr;
#endif
	    }
	    Permit();

	    /* Peter 5-Apr-91: Now backsync Prefs->FontHeight to 8 as
	     * soon as the "System Default Text" font is changed at all.
	     * (We could have made it go to 9 if SysFont was Topaz9, and
	     * to 8 otherwise, but it wasn't worth the ROM space.
	     */
	    if ( (backsync) && ( IFONT(pp)->ifp_SysFontType == IPF_SYSFONT ) )
	    {
		oldprefs->FontHeight = 8;
	    }
	    break;
	}
	return ( 0 );		/* return success on open font	*/
	
    case IP_OVERSCAN:
	/* Starting with 3.01, we ensure legality of the Overscan Prefs
	 * values, because the legal ranges can change if the user
	 * installs or removes VGAOnly, or if he has an A2024 and
	 * uses BootMenu to switch between PAL and NTSC.
	 */
	D( printf("Overscan prefs\n" ) );

	if ( ( drecord = FindDisplayInfo( IOVERSCAN(pp)->ios_DisplayID ) )

	/* To be formally correct, we should get at least a little bit of
	 * the DimensionInfo to prove that the call will succeed when we
	 * really want it all, but Bart assures me that currently if
	 * GDID( DTAG_MNTR )works, so will GDID( DTAG_DIMS ) unless
	 * somebody has trashed the database:
	 * && GDID( drecord, &info.dim, sizeof( struct QueryHeader ), DTAG_DIMS )
	 */

	    && GDID( drecord, &info.mon, sizeof info.mon, DTAG_MNTR ) )
	{
	    /* set up view position */
	    info.mon.ViewPosition = IOVERSCAN(pp)->ios_ViewPos;
	    D( dumpPt( "viewpos before limit", info.mon.ViewPosition ) );

	    limitPoint( &info.mon.ViewPosition, &info.mon.ViewPositionRange );

	    /* If this monitor is the active monitor, then poke ViewLord. */
	    if ( info.mon.Mspc == IBase->ActiveMonitorSpec )
	    {
		IBase->TrackViewDx = IBase->ViewLord.DxOffset =
		    info.mon.ViewPosition.x;
		IBase->TrackViewDy = IBase->ViewLord.DyOffset =
		    info.mon.ViewPosition.y;
	    }
	    SetDisplayInfoData( drecord, &info.mon, sizeof info.mon, DTAG_MNTR );
	    /* check what I get back	*/
	    D( GDID( drecord, &info.mon, sizeof info.mon, DTAG_MNTR);
	       dumpPt( "viewpos reprise", info.mon.ViewPosition); )

	    GDID( drecord, &info.dim, sizeof info.dim, DTAG_DIMS );
	    /* set up std/text oscan	*/
	    info.dim.StdOScan = IOVERSCAN(pp)->ios_Standard;
	    D( dumpRect( "StdOScan before rectHull", &info.dim.StdOScan ) );
	    limitRect( &info.dim.StdOScan, &info.dim.MaxOScan );
	    rectHull( &info.dim.StdOScan, &info.dim.Nominal );
	    D( dumpRect( "StdOScan after rectHull", &info.dim.StdOScan ) );

	    info.dim.TxtOScan.MinX = info.dim.TxtOScan.MinY = 0;
	    info.dim.TxtOScan.MaxX = IOVERSCAN(pp)->ios_Text.x - 1;
	    info.dim.TxtOScan.MaxY = IOVERSCAN(pp)->ios_Text.y - 1;

	    D( dumpRect( "TxtOScan before rectHull/limitRect", &info.dim.TxtOScan ) );
	    limitRect( &info.dim.TxtOScan, &info.dim.MaxOScan );
	    rectHull( &info.dim.TxtOScan, &info.dim.Nominal );
	    D( dumpRect( "TxtOScan after rectHull/limitRect", &info.dim.TxtOScan ) );

	    SetDisplayInfoData( drecord, &info.dim, sizeof info.dim, DTAG_DIMS );
	    {
		ULONG default_id;

		/* jimm: 3/15/90: fix up gb->NormalDisplayRows/Cols
		 * to hires coords of text oscan on default monitor
		 */

		default_id = NTSC_MONITOR_ID|HIRES_KEY;
		if ( TESTFLAG( IBase->Flags, MACHINE_ISPAL ) )
		{
		    default_id = PAL_MONITOR_ID|HIRES_KEY;
		}
    
		if ( ( drecord = FindDisplayInfo( default_id ) )
		/*
		    && GDID( drecord, &info.mon, sizeof( struct QueryHeader ), DTAG_MNTR) )
		*/
		    && GDID( drecord, &info.dim, sizeof info.dim, DTAG_DIMS ) )

		{
		    /*
		     * Peter 30-Jan-91:  Maintain V34 private IntuitionBase fields
		     * MaxDisplayHeight and MaxDisplayWidth for TV*Text.
		     */
		    IBase->MaxDisplayWidth = GfxBase->NormalDisplayColumns = 
			rectWidth( &info.dim.TxtOScan );
		    IBase->MaxDisplayHeight = ( GfxBase->NormalDisplayRows = 
			rectHeight( &info.dim.TxtOScan ) ) << 1;
		    if ( backsync )
		    {
			GDID( drecord, &info.mon, sizeof info.mon, DTAG_MNTR);
			/* backsync oldprefs Row/ColumnSizeChange and ViewX/YOffset: */
			oldprefs->RowSizeChange =
			    GfxBase->NormalDisplayRows - IBase->OrigNDRows;
			oldprefs->ColumnSizeChange =
			    GfxBase->NormalDisplayColumns - IBase->OrigNDCols;
			oldprefs->ViewXOffset = info.mon.ViewPosition.x - IBase->ViewInitX;
			oldprefs->ViewYOffset = info.mon.ViewPosition.y - IBase->ViewInitY;
			DBACK( printf("Overscan backsync: R/CSizeChange: (%ld,%ld)\n",
			    oldprefs->RowSizeChange, oldprefs->ColumnSizeChange ) );
			DBACK( printf("\tViewOffset: (%ld,%ld)\n",
			    oldprefs->ViewXOffset, oldprefs->ViewYOffset ) );
		    }
		}
	    }

	    /* If backsync is false, then we are coming from SetPrefs()
	     * which will do the RemakeDisplay inside SetIBasePrefs, so
	     * we don't need one here:
	     */
	    if ( backsync )
	    {
		/* use new view position */
		RemakeDisplay();
	    }
	    break;
	}
	return(0);

    case IP_ICONTROL:
	{
	    int mon;

	    D( printf("IControl:\n" ) );

	    D( printf("metadrag: %lx\n", ICONTROL(pp)->iic_MetaDrag ) );
	    /* jimm: 6/8/90, always copy iic_MetaDrag */
	    /* if ( ICONTROL(pp)->iic_MetaDrag )  */
		IBase->MetaDragQual = ICONTROL(pp)->iic_MetaDrag;

	    /* blindly set all bits */
	    D( printf("new icontrol flags: %lx\n", ICONTROL(pp)->iic_ICFlags ));
	    IBase->NewIControl = ICONTROL(pp)->iic_ICFlags;
	    
	    /* Use SetDefaultMonitor() to change the mapping of
	     * the default monitor.
	     */
	    if ( TESTFLAG( GfxBase->ChipRevBits0, GFXF_AA_LISA ) &&
		TESTFLAG( IBase->NewIControl, IC_MODEPROMOTION ) )
	    {
		mon = DBLNTSC_MONITOR_ID >> 16;
		if ( TESTFLAG( IBase->Flags, MACHINE_ISPAL ) )
		{
		    mon = DBLPAL_MONITOR_ID >> 16;
		}
	    }
	    else
	    {
		mon = NTSC_MONITOR_ID >> 16;
		if ( TESTFLAG( IBase->Flags, MACHINE_ISPAL ) )
		{
		    mon = PAL_MONITOR_ID >> 16;
		}
	    }
	    SetDefaultMonitor( mon );

	    D( printf("keys %lc %lc %lc %lc\n",
		    ICONTROL(pp)->iic_WBtoFront,
		    ICONTROL(pp)->iic_FrontToBack,
		    ICONTROL(pp)->iic_ReqTrue,
		    ICONTROL(pp)->iic_ReqFalse ) );

	    IBase->WBtoFCode = ToUpper( ICONTROL(pp)->iic_WBtoFront );
	    IBase->FtoBCode = ToUpper( ICONTROL(pp)->iic_FrontToBack );
	    IBase->ReqTrueCode = ToUpper( ICONTROL(pp)->iic_ReqTrue );
	    IBase->ReqFalseCode = ToUpper( ICONTROL(pp)->iic_ReqFalse );

	    /* Immediately show the results of changing any coercion
	     * or promotion flags
	     */
	    RemakeDisplay();
	}
    	break;

    case IP_PENS:
	/* Copy all the pens that are sent to us, but no more than
	 * we know about.
	 */
	{
	    UWORD *pens = IBase->ScreenPens4;
	    if ( IPENPREFS(pp)->ipn_PenType )
	    {
		pens = IBase->ScreenPens8;
	    }
	    CopyMem( &IPENPREFS(pp)->ipn_FirstPen, pens,
		sizeof(UWORD) * imax( NUMDRIPENS+1, IPENPREFS(pp)->ipn_NumPens ) );
	}
	break;

    default:
	D( printf("setIPrefs: unknown type %ld, buff: %lx, size: %ld\n",
		ptype, pp, psize ) );
	return ( 0 );
    }
    return ( 1 );
}

/* Given an array of UWORD 0x0RGB colors, Set the IBase->WBColors[]
 * array in 8 bits-per-gun.
 */
setColorPrefs( prefcolor, firstcolor, numcolors )
UWORD *prefcolor;
UWORD firstcolor;
UWORD numcolors;
{
    struct IntuitionBase *IBase = fetchIBase();
    /* Start with the BLUE component of the firstcolor: */
    UBYTE *ibcolor = &IBase->WBColors[ firstcolor * 3 + 2];
    UWORD temp, i;

    while ( numcolors-- )
    {
	temp = *prefcolor++;

	for ( i = 0; i < 3; i++ )
	{
	    /* Extract the next nybble, and replicate into
	     * both nybbles:
	     */
	    *ibcolor-- = ( temp & 0x000F ) * 0x11;
	    temp >>= 4;
	}
	/* Skip to the BLUE component of the next color */
	ibcolor += 6;
    }
}
@


38.20
log
@SetIPrefs() now bounds-checks Overscan values
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.19 92/08/06 15:48:19 peter Exp Locker: peter $
d300 1
d452 1
a452 1
		IBase->GfxBase->DefaultFont = sysfontp->ifp_Font;
d555 1
a555 1
		    IBase->MaxDisplayWidth = IBase->GfxBase->NormalDisplayColumns = 
d557 1
a557 1
		    IBase->MaxDisplayHeight = ( IBase->GfxBase->NormalDisplayRows = 
d564 1
a564 1
			    IBase->GfxBase->NormalDisplayRows - IBase->OrigNDRows;
d566 1
a566 1
			    IBase->GfxBase->NormalDisplayColumns - IBase->OrigNDCols;
d608 1
a608 1
	    if ( TESTFLAG( IBase->GfxBase->ChipRevBits0, GFXF_AA_LISA ) &&
@


38.19
log
@SetPrefs'd pointers are now POINTERXRESN_LORES.  Now relies on gfx
no longer having the MoveSprite() position bug for ExtSprites.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.18 92/08/03 15:54:31 peter Exp Locker: peter $
d474 5
a496 1
	    /*** ZZZZZ: can replace this when bart gets ranges right
d498 1
a498 2
	    D( dumpPt( "viewpos after limit", info.mon.ViewPosition ) );
	    *****/
d515 2
a516 1
	    D( dumpRect( "stdoscan before rectHull", &info.dim.StdOScan ) );
d518 1
a518 1
	    D( dumpRect( "stdoscan after rectHull", &info.dim.StdOScan ) );
d524 2
a525 1
	    D( dumpRect( "text before rectHull", &info.dim.TxtOScan ) );
d527 1
a527 1
	    D( dumpRect( "text after rectHull", &info.dim.TxtOScan ) );
a529 1

@


38.18
log
@syncIPrefs() now syncs SetPrefs() of the pointer (once), using a new
size parameter.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.17 92/08/02 13:15:51 peter Exp Locker: peter $
d29 2
d142 2
a143 2
	 * sprite X position, though new prefs doesn't, so we
	 * must de-compensate:
d147 2
a148 2
	p.pointer.inp_XResolution = 0;
	p.pointer.inp_YResolution = 0;
d360 4
a363 4
		/* MoveSprite() bug: move the sprite one more to the left
		 * The data input through SetIPrefs() indicates the intended
		 * hotspot, so we offset it here to compensate for the gfx
		 * bug
d365 1
a365 1
		INEWPOINTER(pp)->inp_HotSpotX + SPRITEERROR,
@


38.17
log
@Changing overscans now backsyncs preferences based on NTSC_HIRESKEY or
PAL_HIRESKEY, instead of default HIRES_KEY.  This is needed when
promotion is on.  LACEWB backsync now based on DClip height, not DIPF_
stuff.  Cleaned up some comments.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.17 92/08/02 12:42:29 peter Exp $
d17 4
d44 4
d56 2
a57 1
 *  The following are respected once only:
a59 2
 *
 *  The following are respected only until SetIPrefs is called for that item:
d62 2
a63 1
syncIPrefs()
d131 3
a133 2
#if OLD_POINTER
    if( ! TESTFLAG( IBase->Flags, SEENIPOINTER ) )
d147 1
a147 1
	p.pointer.inp_WordWidth = 0;	/* Signifies old-style pointer! */
a155 1
#endif
a272 6
#if OLD_POINTER
    if ( ptype == IP_NEWPOINTER )
    {
	SETFLAG( IBase->Flags, SEENIPOINTER );
    }
#endif
d347 8
a354 2
	/* setDefaultMousePointer() for the busy pointer returns a
	 * pointer to the old bitmap, to be freed by IPrefs.
d358 5
a362 1
		/* movesprite bug: move the sprite one more to the left */
@


38.16
log
@SetPrefs() now can change the pointer.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.15 92/06/23 17:19:34 peter Exp Locker: peter $
d84 3
a86 2
    /*  We sync font-height and ScreenMode only once, i.e. the SetPrefs of
	devs:system-configuration: */
d149 5
a153 4
    /*  View position gets sync'd during RemakeDisplay(), since
	now we're just another View poker.  All will be caught
	in trackViewPos, which only allows this if
	the active monitor is the default monitor: */
d159 4
a162 3
/*  If we are not tracking people who poke the view and RemakeDisplay,
then syncViewPos is used in syncIPrefs(), else we use trackViewPos()
instead, which is called by RemakeDisplay(). */
d220 9
a228 9
    /*  setIPrefs() sets up TrackViewDx/y as follows:
	  - If the active monitor is the Default monitor, TrackViewDx/y
	    will contain bounds-checked versions of what was poked into
	    the ViewLord.
	  - If the active monitor was something else, TrackViewDx will
	    remain untouched.
	We must freshen the ViewLord offsets to apply the bounds checking,
	and to make non-default monitors immune to ViewLord poking.
    */
a299 1
    /*  This union saves 90 bytes of stack usage */
a302 1
	struct DisplayInfo	disp;
d329 1
a329 1
#if AAA_KLUDGES
d333 1
a333 1
	    /*  backsync colors to keep GetPrefs customers happy: */
d369 4
a372 4
#if 1
/* Compiled out to save space.  Backsyncing LACEWB isn't really
 * that important, anyways.
 */
d375 2
d378 5
a382 2
	    if ( ( drecord = FindDisplayInfo( ISCREENMODE(pp)->ism_DisplayID ) )
		&& GDID( drecord, &info.disp, sizeof info.disp, DTAG_DISP ) )
d384 1
a384 5
		/* Same lying test as GetScreenData() uses: */
		if ( info.disp.PropertyFlags & (DIPF_IS_LACE | DIPF_IS_PANELLED) )
		{
		    oldprefs->LaceWB |= LACEWB;
		}
a387 1
#endif
d464 6
a469 6
	/*  To be formally correct, we should get at least a little bit of
	    the DimensionInfo to prove that the call will succeed when we
	    really want it all, but Bart assures me that currently if
	    GDID( DTAG_MNTR )works, so will GDID( DTAG_DIMS ) unless
	    somebody has trashed the database:
	    && GDID( drecord, &info.dim, sizeof( struct QueryHeader ), DTAG_DIMS )
d511 3
a513 3
	    /* jimm: 3/15/90: fix up gb->NormalDisplayRows/Cols
	     * to hires coords of text oscan on default monitor
	     */
d515 3
a517 5
	    if ( ( drecord = FindDisplayInfo( HIRES_KEY ) )
	    /*
		&& GDID( drecord, &info.mon, sizeof( struct QueryHeader ), DTAG_MNTR) )
	    */
		&& GDID( drecord, &info.dim, sizeof info.dim, DTAG_DIMS ) )
d519 7
a525 1
	    {
d527 4
a530 8
		 * Peter 30-Jan-91:  Maintain V34 private IntuitionBase fields
		 * MaxDisplayHeight and MaxDisplayWidth for TV*Text.
		 */
		IBase->MaxDisplayWidth = IBase->GfxBase->NormalDisplayColumns = 
		    rectWidth( &info.dim.TxtOScan );
		IBase->MaxDisplayHeight = ( IBase->GfxBase->NormalDisplayRows = 
		    rectHeight( &info.dim.TxtOScan ) ) << 1;
		if ( backsync )
d532 23
a554 12
		    GDID( drecord, &info.mon, sizeof info.mon, DTAG_MNTR);
		    /*  backsync oldprefs Row/ColumnSizeChange and ViewX/YOffset: */
		    oldprefs->RowSizeChange =
			IBase->GfxBase->NormalDisplayRows - IBase->OrigNDRows;
		    oldprefs->ColumnSizeChange =
			IBase->GfxBase->NormalDisplayColumns - IBase->OrigNDCols;
		    oldprefs->ViewXOffset = info.mon.ViewPosition.x - IBase->ViewInitX;
		    oldprefs->ViewYOffset = info.mon.ViewPosition.y - IBase->ViewInitY;
		    DBACK( printf("Overscan backsync: R/CSizeChange: (%ld,%ld)\n",
			oldprefs->RowSizeChange, oldprefs->ColumnSizeChange ) );
		    DBACK( printf("\tViewOffset: (%ld,%ld)\n",
			oldprefs->ViewXOffset, oldprefs->ViewYOffset ) );
@


38.15
log
@Preferences LACEWB is no longer backsync'd (too much ROM).
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.14 92/06/05 13:48:37 peter Exp Locker: peter $
d125 16
a140 11
	p.pointer.ipp_PointerData = oldprefs->PointerMatrix,
	p.pointer.ipp_Height = 16;
	/*  NB:  Good old struct Preferences contains the "corrected"
	    sprite X position, though new prefs doesn't, so we
	    must de-compensate: */
	p.pointer.ipp_HotSpotX = oldprefs->XOffset - SPRITEERROR;
	p.pointer.ipp_HotSpotY = oldprefs->YOffset;
	p.pointer.ipp_AttachedData = NULL;
	DSYNC( printf("syncIP: pointer data at: %lx\n",
	    p.pointer.ipp_PointerData ) );
	setIPrefs( &p.pointer, sizeof p.pointer, IP_POINTER, FALSE );
a304 3
#if OLD_POINTER
    int				pointercopysize;
#endif
a356 1
#if OLD_POINTER
d358 1
a358 2
	 * it's getting too hairy.  Maybe one day if we think hard about
	 * it we'll worry about whether we want to figure this out...
d360 1
a360 25
	if ( backsync )
	{
	    /*  backsync pointer data to keep GetPrefs customers happy.
		NB:  Good old struct Preferences contains the "corrected"
		sprite X position, though new prefs doesn't: */
	    oldprefs->XOffset = IBase->DefPtrXOffset;
	    oldprefs->YOffset = IBase->DefPtrYOffset;
	    /*  Protect against setDefaultPointer freeing this memory: */
	    LOCKVIEW();
	    /*  Copy no more than 16 rows of sprite data into old-prefs */
	    pointercopysize = SPR_STORAGE( imin( IBase->DefPtrHeight, 16 ) );
	    CopyMem( IBase->DefPointer, oldprefs->PointerMatrix,
		pointercopysize );
	    /*  If the pointer is < 16 rows high, fill the tail end of
		the oldprefs data with zeroes */
	    for ( cindex = pointercopysize >> 1; /* in WORDs */
		    cindex < POINTERSIZE;
		    cindex++ )
	    {
		oldprefs->PointerMatrix[ cindex ] = 0;
	    }
	    UNLOCKVIEW();
	    DBACK( printf("Pointer backsync: offset (%ld,%ld), copied %ld bytes\n",
		oldprefs->XOffset, oldprefs->YOffset, pointercopysize) );
	}
a361 1
#endif
d368 1
a368 1
#if 0
@


38.14
log
@Now require GFXF_AA_LISA before promotion can be enabled.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.13 92/06/04 16:17:05 peter Exp Locker: peter $
d75 1
a75 1
	/* ZZZ: Here we set colors directly, instead of calling SetIPrefs
d244 1
a244 1
/* ZZZ: external entry point (do this in assmbler interface file)	*/
a292 2
    /*  ZZZ: Peter 6/6/90:  SetPrefs currently uses about 500 bytes more
	stack than under V34.  AllocMem 'info' to save another almost 90 */
d326 2
a327 1
#if AaA_KLUDGES
d393 4
d411 1
d571 4
a574 3
	    /*  If backsync is false, then we are coming from SetPrefs()
		which will do the RemakeDisplay inside SetIBasePrefs, so
		we don't need one here: */
@


38.13
log
@Now knows about both sets of Prefs DrawInfo pens.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.12 92/06/02 14:54:12 peter Exp Locker: peter $
d597 2
a598 1
	    if ( TESTFLAG( IBase->NewIControl, IC_MODEPROMOTION ) )
@


38.12
log
@setDefaultMousePointer() now takes yres parameter.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.11 92/05/29 18:27:52 peter Exp Locker: peter $
d637 9
a645 2
	CopyMem( &IPENPREFS(pp)->ipn_FirstPen, IBase->ScreenPens,
	    sizeof(UWORD) * imax( NUMDRIPENS+1, IPENPREFS(pp)->ipn_NumPens ) );
@


38.11
log
@Enabled database-based promotion.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.10 92/05/27 11:54:15 peter Exp Locker: peter $
d351 2
a352 1
		INEWPOINTER(pp)->inp_Resolution,
@


38.10
log
@New processing of WBColors.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.9 92/05/21 17:40:58 peter Exp Locker: peter $
a20 1
#if AAA_KLUDGES
a23 1
#endif
a167 2
    /*  ZZZ: Peter 6/6/90:  SetPrefs currently uses about 500 bytes more
	stack than under V34.  AllocMem diminfo to save almost 90 */
d170 1
d178 9
a186 2
    /*  If the view changed and we can get default-view info,
	then we update the database */
d189 1
a189 1
	&& ( drecord = FindDisplayInfo( HIRES_KEY ) )
d192 6
a197 2
	/* set up an IOverscanPrefs */
	ios.ios_DisplayID = HIRES_KEY;
d328 1
a328 1
#if AAA_KLUDGES
a392 1

d579 34
a612 1
	D( printf("IControl:\n" ) );
d614 10
a623 38
	D( printf("metadrag: %lx\n", ICONTROL(pp)->iic_MetaDrag ) );
	/* jimm: 6/8/90, always copy iic_MetaDrag */
	/* if ( ICONTROL(pp)->iic_MetaDrag )  */
	    IBase->MetaDragQual = ICONTROL(pp)->iic_MetaDrag;

	/* blindly set all bits */
	D( printf("new icontrol flags: %lx\n", ICONTROL(pp)->iic_ICFlags ));
	IBase->NewIControl = ICONTROL(pp)->iic_ICFlags;
#if AAA_KLUDGES
	/* Use SetDefaultMonitor() to change the mapping of
	 * the default monitor.  We only do this during
	 * silent-startup (VIRGINDISPLAY).
	 */
	if ( TESTFLAG( IBase->Flags, VIRGINDISPLAY ) &&
	   TESTFLAG( IBase->NewIControl, IC_MODEPROMOTION ) )
	{
	    SetDefaultMonitor( TESTFLAG( IBase->Flags, MACHINE_ISPAL ) ?
		DBLPAL_MONITOR_ID : DBLNTSC_MONITOR_ID );
	}
	/* And disable the kind of promotion we've had up to now */
	IBase->NewIControl &= ~IC_MODEPROMOTION;
#endif

	D( printf("keys %lc %lc %lc %lc\n",
		ICONTROL(pp)->iic_WBtoFront,
		ICONTROL(pp)->iic_FrontToBack,
		ICONTROL(pp)->iic_ReqTrue,
		ICONTROL(pp)->iic_ReqFalse ) );

        IBase->WBtoFCode = ToUpper( ICONTROL(pp)->iic_WBtoFront );
	IBase->FtoBCode = ToUpper( ICONTROL(pp)->iic_FrontToBack );
	IBase->ReqTrueCode = ToUpper( ICONTROL(pp)->iic_ReqTrue );
	IBase->ReqFalseCode = ToUpper( ICONTROL(pp)->iic_ReqFalse );

	/* Immediately show the results of changing any coercion
	 * or promotion flags
	 */
	RemakeDisplay();
d625 5
@


38.9
log
@Disabled pointer color sync/backsync.  Now handle 8 bits per gun
through IP_NEWPALETTE.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.8 92/05/15 14:06:18 peter Exp Locker: peter $
d80 2
a81 2
	setColorPrefs( &oldprefs->color0, 0, 4 );
	setColorPrefs( &oldprefs->color17, 17, 3 );
d294 1
d296 1
d309 2
a310 1
	    if ( cindex < 32 )
@


38.8
log
@New style of promotion for Spence (but compiled out for now).
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.7 92/04/07 17:52:29 peter Exp Locker: peter $
d71 14
a84 13
    /*  We always listen to colors from SetPrefs: */
    /*  ZZZ: Here we set colors directly, instead of calling SetIPrefs
	with the data! */
    CopyMem( &oldprefs->color0, &IBase->WBColors[0],
	4 * sizeof (UWORD) );
    CopyMem( &oldprefs->color17, &IBase->WBColors[17],
	3 * sizeof (UWORD) );
    /* set up only the 7 preferences colors */
    setWBColorsGrunt( findWorkBench(), FALSE );
    DSYNC( printf( "syncIP colors 0-3: %lx %lx %lx %lx, 17-19: %lx %lx %lx\n",
	IBase->WBColors[0], IBase->WBColors[1], IBase->WBColors[2],
	IBase->WBColors[3], IBase->WBColors[17], IBase->WBColors[18],
	IBase->WBColors[19] ) );
d125 1
a125 1
    if( ! TESTFLAG( IBase->Flags,  SEENIPOINTER ) )
d246 4
a249 2
    /*  An external caller setting the Pointer will disable future
	SetPrefs() from causing sync for that item: */
d254 5
d264 4
a267 4
#define ISCREENMODE( p ) 	(( struct IScreenModePrefs * ) (p))
#define IFONT( p )	 	(( struct IFontPrefs * ) (p))
#define IOVERSCAN( p ) 		(( struct IOverscanPrefs * ) (p))
#define ICONTROL( p ) 		(( struct IIControlPrefs * ) (p))
d270 1
a280 1
    struct IIControlPrefs 	*iic;
d301 1
a301 1
    case IP_PALETTE:
d309 4
a312 2
		IBase->WBColors[ cindex ] = ((cspec->Red & 0xf) << 8) +
		    ((cspec->Green & 0xf) << 4) + (cspec->Blue & 0xf);
d317 1
d328 1
a382 2


a396 2


d571 1
a571 3
	iic = (struct IIControlPrefs *) pp;

	D( printf("metadrag: %lx\n", iic->iic_MetaDrag ) );
d573 2
a574 2
	/* if ( iic->iic_MetaDrag )  */
	    IBase->MetaDragQual = iic->iic_MetaDrag;
d577 2
a578 2
	D( printf("new icontrol flags: %lx\n", iic->iic_ICFlags ));
	IBase->NewIControl = iic->iic_ICFlags;
d595 4
a598 4
		iic->iic_WBtoFront,
		iic->iic_FrontToBack,
		iic->iic_ReqTrue,
		iic->iic_ReqFalse ) );
d600 4
a603 4
        IBase->WBtoFCode = ToUpper( iic->iic_WBtoFront );
	IBase->FtoBCode = ToUpper( iic->iic_FrontToBack );
	IBase->ReqTrueCode = ToUpper( iic->iic_ReqTrue );
	IBase->ReqFalseCode = ToUpper( iic->iic_ReqFalse );
d612 8
d626 30
@


38.7
log
@Support for new new pointer prefs.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.6 92/04/02 12:04:47 peter Exp Locker: peter $
d21 6
d573 14
@


38.6
log
@Now calls setDefaultMousePointer().  No longer backsync pointer chunk.
No longer includes gfxbase.h.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.5 92/03/19 10:53:51 peter Exp Locker: peter $
d60 1
a60 1
	struct IPointerPrefs	pointer;
d117 1
a117 1

d136 1
d241 1
a241 1
    if ( ptype == IP_POINTER )
d254 1
a254 1
#define	IPOINTER(p)		((struct IPointerPrefs *) (p))
d257 1
d313 6
a318 4
    case IP_POINTER:
	setDefaultMousePointer(
		IPOINTER(pp)->ipp_PointerData, 
		IPOINTER(pp)->ipp_Height, 
d320 5
a324 3
		IPOINTER(pp)->ipp_HotSpotX + SPRITEERROR,
		IPOINTER(pp)->ipp_HotSpotY,
		IPOINTER(pp)->ipp_AttachedData );
d356 1
a357 1
	break;
@


38.5
log
@No longer updates IBase->VerifyTimeoutTotal.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.4 92/02/07 11:06:43 peter Exp Locker: peter $
a16 4
#ifndef GRAPHICS_GFXBASE_H
#include <graphics/gfxbase.h>
#endif

d312 1
a312 1
	setDefaultPointer(
d320 5
d350 1
@


38.4
log
@IPointer and friends are now DefPointer etc.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.3 91/12/12 20:44:19 peter Exp Locker: peter $
a549 4

	D( printf("timeout %ld\n", iic->iic_TimeOut ) );
	if ( iic->iic_TimeOut > 0 )
	    IBase->VerifyTimeoutTotal = iic->iic_TimeOut;
@


38.3
log
@Now uses IBase->ActiveMonitorSpec to tell when overscan preferences
should shift the View.  This is needed to handle promotion.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.2 91/11/25 16:56:09 peter Exp Locker: peter $
d316 1
a316 1
	setDefaultIPointer(
d329 3
a331 3
	    oldprefs->XOffset = IBase->IXOffset;
	    oldprefs->YOffset = IBase->IYOffset;
	    /*  Protect against setDefaultIPointer freeing this memory: */
d334 2
a335 2
	    pointercopysize = SPR_STORAGE( imin( IBase->IPtrHeight, 16 ) );
	    CopyMem( IBase->IPointer, oldprefs->PointerMatrix,
@


38.2
log
@Now calls RethinkDisplay() when IControl Prefs changes.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.1 91/07/10 17:57:07 peter Exp Locker: peter $
d469 2
a470 5
	    /*  If this monitor is the active monitor, then poke ViewLord.
		To tell this, we compare the Mspc pointer of this monitor
		to the NaturalMspc of the first screen */
	    if ( ( IBase->FirstScreen ) &&
		( info.mon.Mspc == XSC( IBase->FirstScreen )->NaturalMSpec ) )
@


38.1
log
@Cleanup of Preferences-related names to improve legibility.
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 38.0 91/06/12 14:24:20 peter Exp Locker: peter $
d577 6
@


38.0
log
@Initial V38 check-in (matches V37 release).
@
text
@d6 1
a6 1
 *  $Id: iprefs.c,v 1.23 91/04/05 16:18:46 peter Exp $
a39 34

#define NEWICONTROL 1
#if NEWICONTROL	/* new stuff */
/* ZZZ: I shouldn't really have a copy of this in here	*/
/* ===== IControl.prefs =================================================== */

/* IControl Flags (ip_ICFlags) */

struct ICPref {
    UWORD ip_TimeOut;			/* Verify timeout */
    WORD  ip_MetaDrag;			/* Meta drag mouse event */
    ULONG ip_ICFlags;			/* IControl flags (see above) */
    UBYTE ip_WBtoFront;			/* CKey: WB to front */
    UBYTE ip_FrontToBack;		/* CKey: front screen to back */
    UBYTE ip_ReqTrue;			/* CKey: Requester TRUE */
    UBYTE ip_ReqFalse;			/* CKey: Requester FALSE */
};

#else /* old stuff */
/* ===== IControl.prefs =================================================== */

struct ICPref {
    UWORD ip_TimeOut;			/* Verify timeout */
    WORD  ip_MetaDrag;			/* Meta drag mouse event */
    BOOL  ip_MagicMenu;			/* DoMagicMenu (pop screen to 0, 0) */
    UBYTE ip_WBtoFront;			/* CKey: WB to front */
    UBYTE ip_FrontToBack;		/* CKey: front screen to back */
    UBYTE ip_ReqTrue;			/* CKey: Requester TRUE */
    UBYTE ip_ReqFalse;			/* CKey: Requester FALSE */
};

#endif


d60 1
a60 1
    extern struct IWBPrefs	DefaultWBPrefs;
d62 3
a64 3
	struct IWBPrefs		wbprefs;
	struct IFontPrefs	fontprefs;
	struct IPrefsPointer	pointerprefs;
d88 1
a88 1
	copyTAttr( &topazprefs, &p.fontprefs );
d91 1
a91 1
	p.fontprefs.ifp_TABuff.tab_TAttr.ta_YSize = oldprefs->FontHeight;
d94 1
a94 1
	    p.fontprefs.ifp_TABuff.tab_NameBuff ) );
d96 1
a96 1
	p.fontprefs.ifp_SysFontType = IPF_SYSFONT;
d98 2
a99 2
	D( printf("syncIP: font prefs buffer at: %lx\n", &p.fontprefs ) );
	setIPrefs( &p.fontprefs, sizeof p.fontprefs, I_FONTPREFS, FALSE );
d102 2
a103 2
	p.fontprefs.ifp_SysFontType = IPF_WBFONT;
	setIPrefs( &p.fontprefs, sizeof p.fontprefs, I_FONTPREFS, FALSE );
d106 2
a107 2
	/* initialize CoolWBPrefs to be Default, plus LACEWB	*/
	p.wbprefs = DefaultWBPrefs;
d110 1
a110 1
	    p.wbprefs.iwb_DisplayID = HIRESLACE_KEY;
d113 2
a114 2
	    p.wbprefs.iwb_DisplayID ) );
	setIPrefs( &p.wbprefs, sizeof p.wbprefs, I_WBPREFS, FALSE );
d124 2
a125 2
	p.pointerprefs.ipp_PointerData = oldprefs->PointerMatrix,
	p.pointerprefs.ipp_Height = 16;
d129 3
a131 3
	p.pointerprefs.ipp_HotSpotX = oldprefs->XOffset - SPRITEERROR;
	p.pointerprefs.ipp_HotSpotY = oldprefs->YOffset;
	p.pointerprefs.ipp_AttachedData = NULL;
d133 2
a134 2
	    p.pointerprefs.ipp_PointerData ) );
	setIPrefs( &p.pointerprefs, sizeof p.pointerprefs, I_POINTER, FALSE );
d164 1
a164 1
    struct IMonitorPrefs	imp;
d184 8
a191 8
	/* set up a MonitorPrefs */
	imp.imp_MonitorID = HIRES_KEY;
	imp.imp_ViewPosition.X = IBase->ViewLord.DxOffset;
	imp.imp_ViewPosition.Y = IBase->ViewLord.DyOffset;
	imp.imp_TextOSDims.X = rectWidth( &diminfo.TxtOScan );
	imp.imp_TextOSDims.Y = rectHeight( &diminfo.TxtOScan );
	imp.imp_StdOScan = diminfo.StdOScan;
	setIPrefs( &imp, sizeof imp, I_MNTRPREFS, FALSE );
d244 1
a244 1
    if ( ptype == I_POINTER )
d253 5
a257 5
#define IWBPREFS( p ) 		(( struct IWBPrefs * ) (p))
#define IFONTPREFS( p ) 	(( struct IFontPrefs * ) (p))
#define IMONITORPREFS( p ) 	(( struct IMonitorPrefs * ) (p))
#define ICONTROL( p ) 		(( ULONG ) (p))
#define	IPOINTER(p)		((struct IPrefsPointer *) (p))
d268 1
a268 1
    struct ICPref 	*icp;
d289 1
a289 1
    case I_PALETTE:
d315 1
a315 1
    case I_POINTER:
d351 1
a351 1
    case I_WBPREFS:
d354 2
a355 2
	IBase->CoolWBPrefs = *IWBPREFS( pp );
	D( printf("setiprefs: control: %lx\n", IWBPREFS(pp)->iwb_Control));
d362 1
a362 1
	    if ( ( drecord = FindDisplayInfo( IWBPREFS(pp)->iwb_DisplayID ) )
d377 1
a377 1
    case I_FONTPREFS:
d379 1
a379 1
	    IFONTPREFS(pp)->ifp_SysFontType) );
d382 3
a384 3
	sysfontp = &IBase->SysFontPrefs[ IFONTPREFS(pp)->ifp_SysFontType ];
	D( printf("p.font %lx type: %ld\n", IFONTPREFS(pp),
		IFONTPREFS(pp)->ifp_SysFontType ) );
d387 2
a388 2
	    IFONTPREFS( pp )->ifp_TABuff.tab_NameBuff,
	    IFONTPREFS( pp )->ifp_TABuff.tab_TAttr.ta_YSize ) );
d391 2
a392 2
	if ( IFONTPREFS( pp )->ifp_Font =
		OpenFont( &IFONTPREFS( pp )->ifp_TABuff.tab_TAttr ) )
d395 2
a396 2
	    IFONTPREFS( pp )->ifp_TABuff.tab_TAttr.ta_YSize =
		IFONTPREFS(pp)->ifp_Font->tf_YSize;
d406 1
a406 1
	    if (( IFONTPREFS(pp)->ifp_SysFontType != IPF_SYSFONT ) &&
d416 2
a417 2
	    copyTAttr( IFONTPREFS( pp ), sysfontp );
	    sysfontp->ifp_Font = IFONTPREFS( pp )->ifp_Font;
d419 1
a419 1
	    if ( IFONTPREFS(pp)->ifp_SysFontType == IPF_SYSFONT )
d438 1
a438 1
	    if ( (backsync) && ( IFONTPREFS(pp)->ifp_SysFontType == IPF_SYSFONT ) )
d446 2
a447 2
    case I_MNTRPREFS:
	D( printf("monitor prefs\n" ) );
d449 1
a449 1
	if ( ( drecord = FindDisplayInfo( IMONITORPREFS(pp)->imp_MonitorID ) )
d462 1
a462 2
	    info.mon.ViewPosition = *((Point *)
		&IMONITORPREFS(pp)->imp_ViewPosition);
d487 1
a487 1
	    info.dim.StdOScan = IMONITORPREFS(pp)->imp_StdOScan;
d493 2
a494 2
	    info.dim.TxtOScan.MaxX = IMONITORPREFS(pp)->imp_TextOSDims.X - 1;
	    info.dim.TxtOScan.MaxY = IMONITORPREFS(pp)->imp_TextOSDims.Y - 1;
d549 1
a549 1
    case I_CONTROL:
d552 1
a552 1
	icp = (struct ICPref *) pp;
d554 8
a561 8
	D( printf("timeout %ld\n", icp->ip_TimeOut ) );
	if ( icp->ip_TimeOut > 0 )
	    IBase->VerifyTimeoutTotal = icp->ip_TimeOut;

	D( printf("metadrag: %lx\n", icp->ip_MetaDrag ) );
	/* jimm: 6/8/90, always copy ip_MetaDrag */
	/* if ( icp->ip_MetaDrag )  */
	    IBase->MetaDragQual = icp->ip_MetaDrag;
a562 1
#if NEWICONTROL
d564 2
a565 9
	D( printf("new icontrol flags: %lx\n", icp->ip_ICFlags ));
	IBase->NewIControl = icp->ip_ICFlags;
#else
	D( printf("magic menu %lx\n", icp->ip_MagicMenu ) );
	if ( icp->ip_MagicMenu )
	    SETFLAG( IBase->NewIControl, IC_DOMAGICMENU);
	else
	    CLEARFLAG( IBase->NewIControl, IC_DOMAGICMENU);
#endif
d568 4
a571 4
		icp->ip_WBtoFront,
		icp->ip_FrontToBack,
		icp->ip_ReqTrue,
		icp->ip_ReqFalse ) );
d573 4
a576 4
        IBase->WBtoFCode = ToUpper( icp->ip_WBtoFront );
	IBase->FtoBCode = ToUpper( icp->ip_FrontToBack );
	IBase->ReqTrueCode = ToUpper( icp->ip_ReqTrue );
	IBase->ReqFalseCode = ToUpper( icp->ip_ReqFalse );
@
