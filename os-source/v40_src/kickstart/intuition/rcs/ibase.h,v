head     38.30;
branch   ;
access   ;
symbols  V40_85:38.30 V40_71:38.30 V40_68:38.30 V40_65:38.29 V40_47:38.29 V40_45:38.29 V40_37:38.29 V40_34:38.29 V40_29:38.29 V39_2415:38.28 V39_2369:38.27 V39_2339:38.27 V39_2332:38.27 V39_2275:38.27 V39_2256:38.27 V39_2210:38.27 V39_2192:38.27 V39_2084:38.26 V39_2082:38.26 V39_2076:38.26 V39_2073:38.26 V39_2058:38.26 V39_2051:38.26 V39_2031:38.26 V39_2017:38.26 V39_2012:38.26 V39_1985:38.26 V39_1933:38.26 V39_1819:38.24 V39_1805:38.23 V39_1783:38.23 V39_1695:38.22 V39_1621:38.21 V39_1620:38.21 V39_1508:38.19 V39_1485:38.19 V39_1461:38.19 V39_1458:38.19 V39_1456:38.18 V39_1405:38.16 V39_1368:38.16 V39_1360:38.16 V39_1324:38.15 V39_1147:38.13 V39_1143:38.13 V39_1141:38.13 V39_1120:38.13 V39_1116:38.13 V39_1104:38.13 V39_1100:38.13 V39_1078:38.12 V39_1073:38.12 V39_757:38.8 V39_702:38.8 V39_557:38.7 V39_553:38.7 V39_551:38.7 V39_510:38.6 V39_495:38.6 V39_416:38.6 V39_383:38.5 V39_371:38.4 V39_336:38.4 V39_323:38.4 V39_295:38.4 V39_277:38.4 V39_254:38.3 V39_222:38.2 V39_185:38.2 V39_171:38.2 V39_161:38.2 V38_159:38.2 V38_116:38.2 V38_59:38.1;
locks    ; strict;
comment  @*   @;


38.30
date     93.04.15.00.57.28;  author peter;  state Exp;
branches ;
next     38.29;

38.29
date     93.02.15.21.21.51;  author peter;  state Exp;
branches ;
next     38.28;

38.28
date     93.01.12.16.18.02;  author peter;  state Exp;
branches ;
next     38.27;

38.27
date     92.11.10.17.04.38;  author peter;  state Exp;
branches ;
next     38.26;

38.26
date     92.08.03.15.53.14;  author peter;  state Exp;
branches ;
next     38.25;

38.25
date     92.08.02.12.41.50;  author peter;  state Exp;
branches ;
next     38.24;

38.24
date     92.07.28.15.13.13;  author peter;  state Exp;
branches ;
next     38.23;

38.23
date     92.07.17.17.25.26;  author peter;  state Exp;
branches ;
next     38.22;

38.22
date     92.07.07.15.19.29;  author peter;  state Exp;
branches ;
next     38.21;

38.21
date     92.06.29.10.42.50;  author peter;  state Exp;
branches ;
next     38.20;

38.20
date     92.06.23.17.17.19;  author peter;  state Exp;
branches ;
next     38.19;

38.19
date     92.06.04.16.16.28;  author peter;  state Exp;
branches ;
next     38.18;

38.18
date     92.06.03.17.26.17;  author peter;  state Exp;
branches ;
next     38.17;

38.17
date     92.06.02.14.53.31;  author peter;  state Exp;
branches ;
next     38.16;

38.16
date     92.05.27.14.24.02;  author peter;  state Exp;
branches ;
next     38.15;

38.15
date     92.05.21.17.37.55;  author peter;  state Exp;
branches ;
next     38.14;

38.14
date     92.05.15.14.04.26;  author peter;  state Exp;
branches ;
next     38.13;

38.13
date     92.04.13.16.27.18;  author peter;  state Exp;
branches ;
next     38.12;

38.12
date     92.04.09.16.25.45;  author peter;  state Exp;
branches ;
next     38.11;

38.11
date     92.04.07.17.49.20;  author peter;  state Exp;
branches ;
next     38.10;

38.10
date     92.04.02.21.37.12;  author peter;  state Exp;
branches ;
next     38.9;

38.9
date     92.04.02.12.03.15;  author peter;  state Exp;
branches ;
next     38.8;

38.8
date     92.03.19.10.52.26;  author peter;  state Exp;
branches ;
next     38.7;

38.7
date     92.03.03.16.32.30;  author peter;  state Exp;
branches ;
next     38.6;

38.6
date     92.02.11.13.41.37;  author peter;  state Exp;
branches ;
next     38.5;

38.5
date     92.02.07.11.05.33;  author peter;  state Exp;
branches ;
next     38.4;

38.4
date     91.11.25.16.55.54;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     91.11.15.18.52.07;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     91.07.25.17.05.11;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.07.10.17.54.44;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.12.14.19.24;  author peter;  state Exp;
branches ;
next     ;


desc
@@


38.30
log
@Added SpecialSpriteKill for CDGS.
@
text
@

#ifndef INTUITION_INTUITIONBASE_H
#define INTUITION_INTUITIONBASE_H 1


/*** ibase.h *********************************************************
 *
 *  the IntuitionBase structure and supporting structures (INTERNAL ONLY)
 *
 *  $Id: ibase.h,v 38.29 93/02/15 21:21:51 peter Exp Locker: peter $
 *
 *  Confidential Information: Commodore-Amiga Computer, Inc.
 *  Copyright (c) Commodore-Amiga Computer, Inc.
 ****************************************************************************/

#ifndef EXEC_TYPES_H
#include <exec/types.h>
#endif

/* */

#ifndef EXEC_LIBRARIES_H
#include <exec/libraries.h>
#endif

#ifndef GRAPHICS_GFXBASE_H
#include <graphics/gfxbase.h>
#endif

#ifndef GRAPHICS_SPRITE_H
#include <graphics/sprite.h>
#endif

#ifndef INTUITION_INTUITION_H
#include <intuition/intuition.h>
#endif

#ifndef UTILITY_HOOKS_H
#include <utility/hooks.h>
#endif

#ifndef DEVICES_INPUTEVENT_H
#include <devices/inputevent.h>
#endif


#ifndef INTUITION_CGHOOKS_H
#include "cghooks.h"
#endif

#ifndef INTUITION_SGHOOKS_H
#include "sghooks.h"
#endif


#ifndef EXEC_INTERRUPTS_H
#include <exec/interrupts.h>
#endif

#ifndef INTUITION_IPREFS_H
#include "iprefs.h"
#endif







#ifndef IESUBCLASS_NEWTABLET
/*	ie_EventAddress points to struct IEPointerNewTablet */
#define IESUBCLASS_NEWTABLET       0x03

/* The ie_EventAddress of an IECLASS_NEWPOINTERPOS event of subclass
 * IESUBCLASS_NEWTABLET points at an IENewTablet structure.
 * 
 *
 * IEQUALIFIER_RELATIVEMOUSE is not supported for IESUBCLASS_NEWTABLET.
 */

struct IENewTablet
{
    /* Pointer to a hook you wish to be called back through, in
     * order to handle scaling.  You will be provided with the
     * width and height you are expected to scale your tablet
     * to, perhaps based on some user preferences.
     * If NULL, the tablet's specified range will be mapped directly
     * to that width and height for you, and you will not be
     * called back.
     */
    struct Hook *ient_CallBack;

    /* Post-scaling coordinates and fractional coordinates.
     * DO NOT FILL THESE IN AT THE TIME THE EVENT IS WRITTEN!
     * Your driver will be called back and provided information
     * about the width and height of the area to scale the
     * tablet into.  It should scale the tablet coordinates
     * (perhaps based on some preferences controlling aspect
     * ratio, etc.) and place the scaled result into these
     * fields.  The ient_ScaledX and ient_ScaledY fields are
     * in screen-pixel resolution, but the origin ( [0,0]-point )
     * is not defined.  The ient_ScaledXFraction and
     * ient_ScaledYFraction fields represent sub-pixel position
     * information, and should be scaled to fill a UWORD fraction.
     */
    UWORD ient_ScaledX, ient_ScaledY;
    UWORD ient_ScaledXFraction, ient_ScaledYFraction;

    /* Current tablet coordinates along each axis: */
    ULONG ient_TabletX, ient_TabletY;

    /* Maximum tablet range along each axis: */
    ULONG ient_RangeX, ient_RangeY;

    /* Pointer to tag-list of additional tablet attributes.
     * See <intuition/intuition.h> for the tag values.
     */
    struct TagItem *ient_TagList;
};


#endif /* temporary definition until devices/inputevent.* learns */






/* these are the display modes for which we have corresponding parameter
 *  settings in the config arrays
 */
#define DMODECOUNT	0x0002	/* how many modes there are */
#define HIRESPICK	0x0000
#define LOWRESPICK	0x0001

#define EVENTMAX 10		/* size of event array */

/* Number of possible sprite pointer sizes, namely 16-bit, 32-bit, 64-bit */
#define POINTER_SIZES	3

/* these are the system Gadget defines */
#define RESCOUNT	2
#define HIRESGADGET	0
#define LOWRESGADGET	1

#define GADGETCOUNT	8
#define UPFRONTGADGET	0
/* #define DOWNBACKGADGET	1 */	/* obsolete */
#define ZOOMGADGET 	1
#define SIZEGADGET	2
#define CLOSEGADGET	3
#define DRAGGADGET	4	/* no image */
#define SUPFRONTGADGET	5
#define SDOWNBACKGADGET	6	/* not used */
#define SDRAGGADGET	7	/* no image */

/* jimm: 1/10/86: Intuition Locking */
/* Let me say it again: don't even think about using this information
 * in a program.
 */
#define ISTATELOCK	0	/* Intuition() not re-entrant		*/
#define	LAYERINFOLOCK	1	/* dummy lock used to check protocol	*/
#define GADGETSLOCK	2	/* gadget lists, refresh, flags		*/
#define LAYERROMLOCK	3	/* (dummy) for lock layerrom		*/
#define IBASELOCK	4	/* protexts IBase pointers and lists	*/
#define	VIEWLOCK	5	/* access to ViewLord			*/
#define VIEWCPRLOCK	6	/* Dummy for GfxBase ActiViewCprSemaphore */
#define RPLOCK		7	/* use of IBase->RP			*/

#define NUMILOCKS	8

/* Here are some other locks that aren't a normal part of the Intuition
 * locking scheme.  We put them here because it allows us to init them
 * along with the other locks.
 */
#define CLASSLOCK	NUMILOCKS+0	/* protection for class list	*/
#define ALERTLOCK	NUMILOCKS+1	/* protection against alert nesting */
#define NUMOTHERLOCKS	2

/** Intuition hook defines (in array IIHooks)	**/
#define IHOOK_SEDIT	0
#define IHOOK_STRINGG	1
#define IHOOK_PROPG	2
#define IHOOK_BOOLG	3

#define NUM_IHOOKS	4


/* ======================================================================== */
/* === Intuition Messages ================================================= */
/* ======================================================================== */

/* Standard Internal form of IntuiMessage */
struct IIntuiMessage
{
    struct IntuiMessage	iim_IntuiMessage;
    struct TabletData	*iim_TabletData;
    ULONG		iim_PrevKeys;
};

/* Internal form of IntuiMessage for WA_TabletMessages windows */
struct TIIntuiMessage
{
    struct IntuiMessage	iim_IntuiMessage;
    struct TabletData	*iim_TabletData;
    ULONG		iim_PrevKeys;
    struct TabletData	tiim_TabletDataInstance;
};

/* Convenient cast to allow access to all fields of a TIIntuiMessage */
#define IIMSG(imsg) ((struct TIIntuiMessage *)(imsg))


/* ======================================================================== */
/* === Gadget "Per List" Environment ====================================== */
/* ======================================================================== */
/*
 * this structure encapsulates a GadgetInfo plus enough cached
 * information to switch between normal and g00 gadgets in
 * the same list.
 */
struct GListEnv {
    struct GadgetInfo	ge_GInfo;

    /* two possible layers for gadgets in a window list:
     * window layer or g00 (border) layer.   All other lists use
     * just ge_Layer.
     */
    struct Layer	*ge_Layer;
    struct Layer	*ge_GZZLayer;	/* border layer for g00 windows */

    /* likewise, two different domains */
    struct IBox		ge_Domain;
    struct IBox		ge_GZZdims;
};

/* IBase->WBColors is as follows:
 * [0..3] - the first four colors of a screen
 * [4..7] - the _last_ four colors of a screen
 * [8..11] - the three pointer colors
 */

#define WBCOLOR_FIRST4	0	/* Base index for first four colors */
#define WBCOLOR_LAST4	4	/* Base index for last four colors */
#define WBCOLOR_POINTER	8	/* Base index for three pointer colors */

#define WBCOLOR_NUMBER	11	/* Number of entries */

/* ======================================================================== */
/* === IntuitionBase ====================================================== */
/* ======================================================================== */

struct Point
{
    WORD X;
    WORD Y;
};

struct LongPoint
{
    LONG LX;
    LONG LY;
};


/* IntuitionBase should never be directly modified by programs  */
/* even a little bit, guys/gals; do you hear me?	*/

/* IntuitionBase needs its fields shuffled for alignment and
 * grouping reasons.  I'm not doing it now because I want
 * the current version of Wack to still be valid for Intuition
 * from Kickstart 39.106 (3.00).
 */
struct IntuitionBase
{
    struct Library LibNode;

    struct View ViewLord;

    struct Window *ActiveWindow;
    struct Screen *ActiveScreen;

				/* poll of uses on 8/23/89:
				 *   window draggie box
				 *   menu resolution
				 *   menu rendering (swapbits)
				 *   accelerator debug
				 *   set by setScreen/setWindow
				 *   screen gadget beep
				 *   cleared if closed
				 */

    struct Screen *FirstScreen; /* for linked list of all screens	*/

    ULONG Flags;		/* definitions in intuinternal.h	*/

    WORD	MouseY, MouseX;
    ULONG	Seconds;	/* timestamp of most recent input event	*/
    ULONG	Micros;

    /***** ***** ***** ***** ***** ***** ***** ***** *****/
    /***** ***** ***** PRIVATE DATA HERE ***** ***** *****/
    /***** ***** ***** ***** ***** ***** ***** ***** *****/

    /* Peter 10-Jan-91:  To fix Tetris, we recreate V34's SimpleSprite
     * pointer.  It is at $3E8(IBase).  Private is at $50(IBase).
     * Peter 30-Jan-91:  To fix TV*Text, we recreate V34's MaxDisplayHeight
     * and MaxDisplayWidth fields.  They're at 0x542(IBase) and 0x546(IBase)
     * Locale needs a pointer to the "System Request" string.  We'll
     * re-use the 1.3 "SysBase" pointer, which is a good idea because
     * it's safe to re-use and it's near the beginning of IntuitionBase,
     * meaning nothing needs to be recompiled and our future options
     * aren't screwed by a fixed location in the middle of shifting
     * fields.  IMPORTANT: SysReqTitle can't be moved!!!
     */
    /* SpecialSpriteKill is a kludge for CDGS to safely keep Intuition
     * from using its own sprite.  When non-zero, Intuition doesn't
     * call MoveSprite() or ChangeExtSprite().
     */
#define PRIVATE_IBOFFSET	( 0x50 )
#define SYSBASE_OFFSET		( 0x60 - PRIVATE_IBOFFSET)
#define	TETRISSPRITE_OFFSET	( 0x3E8 - PRIVATE_IBOFFSET )
#define MAXDISPLAYHEIGHT_OFFSET	( 0x542 - PRIVATE_IBOFFSET )
#define TOTALPRIVATE		( 1300 )

    UBYTE	Private[ SYSBASE_OFFSET ];
    STRPTR	SysReqTitle;
    STRPTR	WBScreenTitle;
    ULONG	SpecialSpriteKill;
    UBYTE	Private2[ TETRISSPRITE_OFFSET - SYSBASE_OFFSET - 12 ];
    struct SimpleSprite *TetrisSprite;
    UBYTE	Private3[ MAXDISPLAYHEIGHT_OFFSET - TETRISSPRITE_OFFSET - 4 ];
    WORD	MaxDisplayHeight;
    WORD	Private4;
    WORD	MaxDisplayWidth;
    UBYTE	Private5[ TOTALPRIVATE - MAXDISPLAYHEIGHT_OFFSET - 6 ];


    /* --------------- base vectors ----------------------------------- */
    /* DO MOVE THESE OFFSETS WITHOUT ADJUSTING EQUATES IN IWORK.ASM 
     * this is automatically handled by standalone program offsets.c
     */
    APTR		SysBase;
    struct GfxBase	*GfxBase;
    APTR		LayersBase;
    APTR		UtilityBase;
    APTR		KeymapBase;
    struct Task		*InputDeviceTask;

    /* ---------------- Intuition State Machine ----------------------- */
    UWORD		CurrentState;
    int			(*GadgetReturn)();
    UWORD		(*SDragReturn)();
    UWORD		(*WSDReturn)();
    UWORD		(*VerifyReturn)();
    UWORD		(*DMRReturn)();
    struct InputToken	*InputToken;
    struct InputEvent	IECopy;		/* copy of recent real input event */

    /**** look at end for more ISM stuff ***/

    /* ---------------- Pools and Queues ------------------------------- */

    /* input token lists	*/
    struct List		TokenQueue;	/* accumulated input tokens	*/
    struct List		DeferredQueue;	/* tokens for next time		*/
    struct List		ITFreeList;	/* pool				*/

    /* input node lists		*/
    struct List		IEFoodList;	/* being sent along to handlers	*/
    struct List		IEQueue;	/* queueing up for next time	*/
    struct List		IEFreeList;	/* pool				*/
    struct List		IECloneList;	/* allocated copies being used */

    /* --------------- Local State ------------------------------------ */

    struct Point	ShiftBack;	/* menu magic return shift	*/
    ULONG		StartSecs;	/* measure double clicks */
    ULONG		StartMicros;

    /* ---------------- Menu Rendering and Operation ------------------ */
    /* menu/item/sub number of current display */
    USHORT		MenuDrawn;
    /* menu/item/sub number of selected (and highlights)*/
    USHORT		MenuSelected;
    USHORT		OptionList;		/* menu selection	*/

    struct RastPort	MenuRPort;
    struct ClipRect	ItemCRect;	/* for the item's display	*/
    LONG		BSZero1;	/* layers assumes this is defined */
    struct ClipRect	SubCRect;	/* for the subitem's display	*/
    LONG		BSZero2;	/* layers assumes this is defined */
			
    /* ---------------- Input Device Interface ------------------------ */
    struct IOStdReq	InputRequest;
    struct Interrupt	InputInterrupt;

    struct timerequest	IOExcess;

    /* ---------------- Active Gadget Information --------------------- */
    struct Gadget	*ActiveGadget;
    struct GListEnv	GadgetEnv;
    struct Hook		*ActiveHook;	/* hook of active gadget	*/

    /* cached by prop/bool/string GoActive hooks	*/
    struct IBox		ActiveGBox;	/* cached relativity box	*/

    /* cache for active prop gadget	*/
    struct Point	KnobOffset;	
    struct PGX		ActivePGX;	/* container, newknob		*/

    /* cache for active string gadget	*/
    struct StringExtend	*ActiveSEx;
    struct KeyMap	*KeyMap;
#define LONGBSIZE	(15)
    /* workbuffer for LONGINT gadgets	*/
    UBYTE		LongBuff[ LONGBSIZE ];

    /* ----------- Intuition's Rendering for Gadgets, Titles, ... ----- */
    /* This will be allocated on init */
    struct RastPort	*RP;
    struct Region	*OldClipRegion;		/* locks with RPort */
    struct Point    	OldScroll;		/* user's Scroll_X/Y*/

    /* ----------- Frame Rendering for Window Size/Drag --------------- */
    struct IBox		IFrame;	/* window frame for sizing/dragging	*/
    VOID   		(*frameChange)(); /* function to change IFrame	*/
    /* points to either pos or dims of ChangeBox	*/
    struct Point	*SDDelta;
    struct Point	FirstPt;	/* point from which s/d started */
    struct Point	OldPt;		/* previous point for s/d	*/
    struct IBox		ChangeBox;	/* parameter buffer for sizeDrag */
    UWORD		SizeDrag;	/*  WSD_SIZE or WSD_DRAG	*/

    /* Menu imagery:  menu checkmark and menu Amiga-key in two sizes */
    struct Image	*MenuImage[2][RESCOUNT];

    /* --- Preferences Section ---------------------------------------------- */

    LONG DoubleSeconds, DoubleMicros; /* for testing double-click timeout */

    struct Preferences *Preferences;

    /* ----------------- Workbench Interface ---------------------- */
    struct MsgPort *WBPort;

    struct Screen *HitScreen;	/* set by hitScreen() routine */

    /* ---------------------- Intuition Arbitration ---------------------- */
    struct SignalSemaphore	ISemaphore[NUMILOCKS+NUMOTHERLOCKS];

    /* ---------------------- Display Stuff ------------------------------- */
    struct MonitorSpec *ActiveMonitorSpec;
    struct ViewExtra *ViewExtra;
    WORD ViewInitX, ViewInitY;	/* View initial offsets at startup   */

    /* copies of gfxbase original display defs	*/
    UWORD	OrigNDRows;
    UWORD	OrigNDCols;

    /* ---------------------- Mouse Motion ------------------------------- */
    /* multiply ie_X/Y by this	*/
    /* this is also "ticks per hires pixel"		*/
#define MOUSESCALEX		(22)

    /* Peter 28-Nov-90:  Rather than the Y-ticks per pixel being exactly
     * constant, we fudge it a little for compatibility and common sense,
     * i.e. we adapt it to PAL and VGA, too.
     */
#define MOUSESCALEY		(26)
#define NTSC_MOUSESCALEY	(26)
#define PAL_MOUSESCALEY		(22)
#define VGA_MOUSESCALEY		(22)

    struct Point	EffectiveScaleFactor;
			/* MOUSESCALE divided by PointerTicks	*/

    /* Pointer to last screen passed to tablet callback hook */
    struct Screen	*LastTabletScreen;

    struct Rectangle	MouseLimits;
    SHORT 		HoldMinYMouse;

    /* Peter 3-Apr-91: Screen relative mouse limits to solve
     * autoscroll weirdness, and ScrollFreedom variable.
     */
    struct Rectangle	ScreenMouseLimits;
    UWORD		ScrollFreedom;

    /* Peter 3-Apr-91: IESUBCLASS_TABLET events need to know the
     * mouse's true limits, unconstrained by sizing, dragging, or
     * menu operations.
     */
    struct Rectangle	FreeMouseLimits;


    UWORD 		CursorSteady;	/* for accelerating pointer movement */
    UWORD 		CursorInc;

    /* --------------- public screen stuff ----------------------------	*/
    struct List		PubScreenList;	/* protected by LOCKIBASE()	*/
    struct PubScreenNode	*DefaultPubScreen;
    UWORD		PubScreenFlags; /* PubScreenFlags in screens.h	*/

    /* --------------- runtime debugging stuff ------------------------	*/
    UWORD		DebugFlag;	/* checked at run time		*/

#define IDF_SPRITE	(1)	/* sprite debug	*/
#define IDF_BPATTERN	(2)	/* border patrol cross hatch	*/
#define IDF_BPAUSE	(4)	/* border patrol pause		*/
#define IDF_PAUSE	(8)	/* general pause		*/
#define IDF_LOCKDEBUG	(16)	/* Lock debugging enabled	
				 * (it's disabled during initIntuition())
				 */

    struct Point	debugpt;	/* mailbox for stuff		*/

    /* --------------- "new" preferences ------------------------------	*/
    /* CoolScreenMode is what the user wants.  We also keep track
     * of the last screenmode that worked, to give a reasonable
     * fallback if the user asks for something impossible:
     */
    struct IScreenModePrefs	CoolScreenMode;
    struct IScreenModePrefs	LastScreenMode;

    struct IFontPrefs	SysFontPrefs[ 2 ];
    ULONG		NewIControl;	/* new Intuition bool prefs */
    struct Hook		*EditHook;	/* first pass stringg editing	*/

    /*** new ISM stuff that I don't want to recompile for now ***/
    struct Requester	*ActiveRequester;

    struct Window	*VerifyWindow;	  /* window we're waiting for	*/
    struct IntuiMessage	*VerifyMessage;	  /* address of pending message	*/
    ULONG		VerifyClass;	  /* menu, dmr, size, ...	*/
    UWORD		VerifyCode;	/* MENUHOT or MENUWAITING or other */
    UWORD		VerifyTimeout;
    struct Window	*AllButWindow;	/* inactive MENUVERIFY window	*/
    UWORD		MenuAbort;

    /******* put these in better homes then remake	****/
    struct List		IClassList;
    struct Hook		IIHooks[ NUM_IHOOKS ];

    /* more IControl stuff	*/
    UWORD		MetaDragQual;
    UBYTE		WBtoFCode;
    UBYTE		FtoBCode;
    UBYTE		ReqTrueCode;
    UBYTE		ReqFalseCode;

    /* a kludgy little fake semaphore (spin lock)
     * used by openSysScreen
     */
    UWORD		SysScreenProtect;

    /* reply port for asynhc msgs to WBPort	*/
    struct MsgPort	WBReplyPort;

    /* cache for imageclass pointer	*/
    struct IClass	*ImageClassPtr;

    /* new improved workbench colors storage
     * We store a byte per gun, eleven colors only
     * (first four, last four, and three pointer colors)
     */
    UBYTE	WBColors[ WBCOLOR_NUMBER * 3 ];

    /* to catch and sync View offset changes: */
    WORD		TrackViewDx, TrackViewDy;

    /* The old MOUSESCALEX and MOUSESCALEY constants (representing
     * one NTSC-lace pixel in ticks) is now set by monitor type.
     * (MouseScaleX is a bit farther down in IBase)
     */
    WORD		MouseScaleY;

    /* Peter 7-Jan-91: By keeping the Workbench screen's TextAttr
     * in a place that doesn't go away when the screen is closed,
     * MicroFiche Filer works better.
     */
    struct TAttrBuff	MFF_TAttrBuff;

    /* Non-draggable child screens result in a screen other than
     * the HitScreen being dragged.  So we use this instead.
     */
    struct Screen	*DragScreen;

    /* --------------- Sprite Pointer --------------------------------- */
    /* the ActiveGroup pointer sprite definition	*/
    BYTE		AXOffset;
    BYTE		AYOffset;

    /** jimm:dale: 11/25/85, thought we'd take a chance for glory **/
    struct SimpleSprite	*SimpleSprite;

    WORD		MouseScaleX;

    /* NEW SPRITE HANDLING:
     * 
     * These are handles to the MousePointer structures for
     * the user's preferred mouse-pointer and busy-pointer.
     * Intuition initializes these at the dawn of time,
     * and the user can change them through Preferences.
     *
     * Note that Intuition keeps allocated copies of the default
     * mouse pointer in each possible resolution.  As a result,
     * it doesn't need the BitMap any longer.  IPrefs does free
     * the xmpt_BitMap of the DefaultMousePointer right away.
     */
    struct MousePointer *DefaultMousePointer;
    struct MousePointer *DefaultBusyPointer;

    /* MousePointer structures such as those above are not
     * ready for display; their bitmaps need to be passed
     * to graphics.  This means there's a possibility of
     * failure.  In order to always be able to bring up
     * some sprites, we keep ready-to-display ExtSprites
     * version of the preferences mouse-pointer, in each
     * possible size:
     */
    struct ExtSprite *DefaultExtSprite[ POINTER_SIZES ];

    /* When we're using a custom pointer, we keep track
     * of its MousePointer structure here, because we need
     * to look at its flags and size, and so on.
     * If the default mouse-pointer is in use, this field is
     * NULL.
     */
    struct MousePointer *CustomMousePointer;

    /* When we're using a custom pointer, we keep track of
     * the ExtSprite we allocated for it, so that we can free
     * it when the time comes.
     */
    struct ExtSprite *CustomExtSprite;

    /* One of the POINTERXRESN_ flags from pointerclass.h */
    WORD PointerXRes;
    /* One of the POINTERYRESN_ flags from pointerclass.h */
    WORD PointerYRes;

    /* If menu-lending is in effect, we store the window to return to */
    struct Window *MenuLendingReturn;

    LONG PointerKilled;

    /* A blank sprite we allocate at the beginning, and use to blank
     * the pointer during transitions.
     */
    struct ExtSprite *BlankSprite;

    /* We store a pointer to the AllocVec()'d bitmap of the original
     * ROM-default busy pointer.
     */
    struct BitMap *BusyPointerBitMap;

    /* Pointer to Preferences pen-array.  One for four colors,
     * one for eight or more:
     */
    UWORD ScreenPens4[ NUMDRIPENS + 1];
    UWORD ScreenPens8[ NUMDRIPENS + 1];

    /* GadgetHelp testing occurs when the active window has gadget-help
     * mode (WMF_GADGETHELP) enabled.  To give good performance and feel,
     * we don't bother testing for GadgetHelp if the mouse is travelling
     * quickly.  Thus, we store the mouse coordinates noted at the last
     * timer tick (LastTimeX/Y).
     *
     * To avoid unnecessary work, we don't retest for GadgetHelp if 
     * the mouse position is unchanged from the last time we tested
     * (LastHelpX/Y).
     *
     * We also store the gadget that last gave help, which can be
     * NULL or ~0 for the special help messages of "not over one of
     * the help windows" or "in a help window, not over a gadget".
     * Finally, we store the last code from from a gadget's GM_HELPTEST
     * method.  These two stored values allow us to only send a fresh
     * IDCMP_GADGETHELP message when the gadget or the GM_HELPTEST result
     * changes.
     */
    WORD LastTimeX;
    WORD LastTimeY;
    WORD LastHelpX;
    WORD LastHelpY;
    struct Gadget *HelpGadget;

    /* Move this somewhere better... */
    struct LongPoint 	LongMouse;

    LONG HelpGadgetCode;

    /* It's too complex to have MakeVPort() failure trickle up
     * through function call return codes, so we have this
     * field here (protected by VIEWCPR lock and IBASELOCK, incidentally)
     * to store any non-zero MakeVPort() result:
     */
    LONG ViewFailure;

    UBYTE OverrunX, OverrunY;

    /* There is a vulnerability in the name uniqueness check
     * for public screens.  To fix this, we need a list of
     * public screens that are in the process of being opened.
     * See pubscreen.c for full gory details.
     */
    struct List		PendingPubScreens;	/* protected by LOCKIBASE()	*/
};

/* ScrollFreedom */
#define OKSCROLL_LEFT	0x0001 /* AutoScroll may scroll left */
#define OKSCROLL_RIGHT	0x0002 /* AutoScroll may scroll right */
#define OKSCROLL_UP	0x0004 /* AutoScroll may scroll up */
#define OKSCROLL_DOWN	0x0008 /* AutoScroll may scroll down */

#define OKSCROLL_ALL	(OKSCROLL_LEFT|OKSCROLL_RIGHT|OKSCROLL_UP|OKSCROLL_DOWN)

/* NewIControl Flag values	*/
#define IC_COERCE_COLORS	(0x0001) /* = Preserve Colors? */
#define IC_COERCE_LACE		(0x0002) /* = Avoid Flicker? */
#define IC_STRINGG_CTRL		(0x0004) /* = Filter out CTRL chars in strgads? */
#define IC_DOMAGICMENU		(0x0008) /* = Menu snap? */
#define IC_MODEPROMOTION	(0x0010) /* = Promote? */
#endif
@


38.29
log
@Added PendingPubScreens list.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.29 93/02/15 18:59:05 peter Exp $
d317 4
d330 2
a331 1
    UBYTE	Private2[ TETRISSPRITE_OFFSET - SYSBASE_OFFSET - 8 ];
@


38.28
log
@Added IBase->MouseScaleX to replace MOUSESCALEX.  Added WBScreenTitle
for locale.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.27 92/11/10 17:04:38 peter Exp Locker: peter $
d497 1
a497 1
    struct List		PubScreenList;	/* protected by LOCKSTATE()	*/
d697 7
a719 1

@


38.27
log
@Added comments to IControl flags.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.26 92/08/03 15:53:14 peter Exp Locker: peter $
d270 5
d324 3
a326 2
    STRPTR	*SysReqTitle;
    UBYTE	Private2[ TETRISSPRITE_OFFSET - SYSBASE_OFFSET - 4 ];
d568 3
a570 2
    /* Peter 28-Nov-90: The old MOUSESCALEY constant (one NTSC-lace
     * pixel in ticks) is now internationalized.
d592 2
a593 1
    BOOL		GotSprite1;
d695 2
@


38.26
log
@NullSpriteData now unused.  Removed unused fields, removed semaphore list.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.25 92/08/02 12:41:50 peter Exp Locker: peter $
d698 5
a702 5
#define IC_COERCE_COLORS	(0x0001)
#define IC_COERCE_LACE		(0x0002)
#define IC_STRINGG_CTRL		(0x0004)
#define IC_DOMAGICMENU		(0x0008)
#define IC_MODEPROMOTION	(0x0010)
@


38.25
log
@Marked two fields as unused.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.24 92/07/28 15:13:13 peter Exp Locker: peter $
d170 1
d173 8
d440 1
a440 2
    struct List 		SemaphoreList;	/* chain of the below */
    struct SignalSemaphore	ISemaphore[NUMILOCKS];
a549 3
    /* protection for class list	*/
    struct SignalSemaphore	IClassSemaphore;

a558 6
    /* protection against alert nesting	*/
    struct SignalSemaphore	AlertSemaphore;

#define NULL_SPRITE_ROWS	(1)	/* one row of data	*/
    UWORD			*NullSpriteData;	/* (chipmem) */

a584 1
    struct SimpleSprite	*xxxAttachedSSprite;
a585 3

    /* an actual instance we'll use, and point to with AttachedSSprite */
    struct SimpleSprite	xxxAttachedSSBuff;
@


38.24
log
@Added ViewFailure field.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.23 92/07/17 17:25:26 peter Exp Locker: peter $
d586 1
a586 1
    struct SimpleSprite	*AttachedSSprite;
d590 1
a590 1
    struct SimpleSprite	AttachedSSBuff;
d598 5
@


38.23
log
@IBase->NumPointerSizes retired.  Added IBase->BlankSprite and
IBase->HelpGadgetCode.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.22 92/07/07 15:19:29 peter Exp Locker: peter $
d680 7
@


38.22
log
@Added LastTabletScreen field.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.21 92/06/29 10:42:50 peter Exp Locker: peter $
d636 2
a637 4
    /* The number of pointer sizes (eg 16-bit, 32-bit, 64-bit) that the
     * hardware we're running on supports.  Pre-AA machines (1X) systems
     * have NPS=1, 2X AA machines have NPS=2, and 4X AA machines have
     * NPS=3.
d639 1
a639 1
    LONG NumPointerSizes;
d665 4
d676 1
d678 2
@


38.21
log
@Defined struct LongPoint and IBase->LongMouse.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.20 92/06/23 17:17:19 peter Exp Locker: peter $
d459 4
a462 1
    struct Point 	xxxMouse;
@


38.20
log
@IBase->CheckImage and IBase->AmigaIcon consolidated into a single
array.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.19 92/06/04 16:16:28 peter Exp Locker: peter $
d245 11
a255 4
struct Point {
    SHORT X;
    SHORT Y;
    };
d459 1
a459 1
    struct Point 	Mouse;
d670 2
@


38.19
log
@Now contains two sets of Preferences pens.  Removed unused GroupCounter.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.18 92/06/03 17:26:17 peter Exp Locker: peter $
d409 2
a410 2
    /* ---------------- System Gadget Templates ------------------------ */
    struct Image	*CheckImage[RESCOUNT], *AmigaIcon[RESCOUNT];
@


38.18
log
@Added new fields to support new gadget help technique.  Added new
VIEWCPRLOCK.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.17 92/06/02 14:53:31 peter Exp Locker: peter $
d638 5
a642 2
    /* Pointer to Preferences pen-array: */
    UWORD ScreenPens[ NUMDRIPENS + 1];
a662 2

    ULONG GroupCounter;
@


38.17
log
@Renamed PointerRes field to PointerXRes.  Added PointerYRes.  Added
POINTER_XDOUBLE.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.16 92/05/27 14:24:02 peter Exp Locker: peter $
d168 3
a170 2
#define RPLOCK		6	/* use of IBase->RP			*/
#define NUMILOCKS	7
d640 22
@


38.16
log
@WBColor stuff stored here now.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.15 92/05/21 17:37:55 peter Exp Locker: peter $
d615 4
a618 2
    /* One of the POINTERRESN_ flags from intuition.h */
    LONG PointerRes;
@


38.15
log
@Marked SExBuffer as unused.  Removed all unused fields.  Added
ScreenPens pointer.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.14 92/05/15 14:04:26 peter Exp Locker: peter $
d228 9
d238 1
d538 2
a539 1
     * We store a byte per gun
d541 1
a541 2
#define NUM_WB_COLORS	(32)
    UBYTE	WBColors[ NUM_WB_COLORS * 3 ];
@


38.14
log
@Added IDF_LOCKDEBUG.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.13 92/04/13 16:27:18 peter Exp Locker: peter $
a343 13
    /* --------------- Sprite Pointer --------------------------------- */
    /* the ActiveGroup pointer sprite definition	*/
    USHORT		*xxxAPointer;
    BYTE		xxxAPtrHeight;
    BYTE		xxxAPtrWidth;
    BYTE		AXOffset;
    BYTE		AYOffset;

    /** jimm:dale: 11/25/85, thought we'd take a chance for glory **/
    struct SimpleSprite	*SimpleSprite;
    struct SimpleSprite	*AttachedSSprite;
    BOOL		GotSprite1;

a351 1
    struct TmpRas	xxxMenuTmpRas;
a355 2
    struct BitMap	xxxIBitMap;	/* for the item's planes	*/
    struct BitMap	xxxSBitMap;	/* for the subitem's planes	*/
a376 1
    struct StringExtend	SExBuffer;
a389 2
    SHORT		xxxFrameHThick;	/* IFrame thickness		*/
    SHORT		xxxFrameVThick;
a390 1
    VOID   		(*xxxsizeDrag)();	/* ISizeWindow or IMoveWindow	*/
a398 2
    /* obsolete */
    struct Gadget	*xxxSysGadgets[RESCOUNT][GADGETCOUNT];
a401 5
    /* the INTUITION pointer default sprite definition */
    USHORT		*xxxDefPointer;
    BYTE		xxxDefPtrHeight;	/* height of the pointer	*/
    BYTE		xxxDefPtrWidth;	/* width of the pointer		*/
    BYTE		xxxDefPtrXOffset, xxxDefPtrYOffset; /* sprite offsets */
a404 8
    USHORT xxxcolor0;
    USHORT xxxcolor1;
    USHORT xxxcolor2;
    USHORT xxxcolor3;
    USHORT xxxcolor17;
    USHORT xxxcolor18;
    USHORT xxxcolor19;

d444 14
d480 4
d485 3
a487 1
    struct IFontPrefs	SysFontPrefs[ 3 ];	/* only plan on 2 */
a511 1
    UWORD		xxxVerifyTimeoutTotal;
d527 2
a528 2
    /* height of sprite which can be stored in memory allocated
     * for DefPointer (actual data amount is SPR_STORAGE( DefPtrHeight )
a529 6
    UWORD		xxxDefPtrBufSize;

    /* an actual instance we'll use, and point to with AttachedSSprite */
    struct SimpleSprite	AttachedSSBuff;

    /* new improved workbench colors storage	*/
d531 1
a531 1
    UWORD	WBColors[ NUM_WB_COLORS ];
a541 6
    /* Peter 20-Aug-90: We keep track of the last screenmode
     * that worked, to give a reasonable fallback if the user
     * asks for something impossible:
     */
    struct IScreenModePrefs	LastScreenMode;

a552 12
    /* Peter 3-Apr-91: IESUBCLASS_TABLET events need to know the
     * mouse's true limits, unconstrained by sizing, dragging, or
     * menu operations.
     */
    struct Rectangle	FreeMouseLimits;

    /* Peter 3-Apr-91: Screen relative mouse limits to solve
     * autoscroll weirdness, and ScrollFreedom variable.
     */
    struct Rectangle	ScreenMouseLimits;
    UWORD		ScrollFreedom;

d558 13
d624 3
@


38.13
log
@Juggled IENewTablet structure.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.12 92/04/09 16:25:45 peter Exp Locker: peter $
d494 3
@


38.12
log
@Extended FatIntuiMessage.  Temporarily added defn for new tablet
structures.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.11 92/04/07 17:49:20 peter Exp Locker: peter $
d43 5
d75 3
a77 16
struct TabletMessage
{
    /* Pointer to the active screen: */
    struct Screen *tm_Screen;

    /* The screen rectangle you are to scale to: */
    struct Rectangle *tm_ScreenRect;

    /* Non-zero if the screen or something about the screen
     * changed since the last time you were invoked:
     */
    LONG tm_ScreenChanged;
};

/* pointed to by ie_EventAddress for IECLASS_NEWPOINTERPOS,
 * and IESUBCLASS_NEWTABLET.
d82 1
a82 1
struct TabletData
d84 26
d111 1
a111 1
    LONG td_TabletX, td_TabletY;
d114 1
a114 4
    LONG td_RangeX, td_RangeY;

    /* 16 bits worth of button states */
    WORD td_Buttons;
d116 2
a117 8
    /* Stylus pressure, scaled to fill a signed WORD */
    WORD td_Pressure;

    /* Screen pixel coordinates and sub-pixel coordinates.
     * Your driver will be called back and provided information
     * about the active screen so that it may fill these fields
     * in.  The sub-pixel coordinates are to be scaled to
     * a UWORD fraction.
d119 2
a120 5
    UWORD td_ScreenX, td_ScreenY;
    UWORD td_ScreenSubX, td_ScreenSubY;

    /* Pointer to tag-list of additional tablet attributes */
    struct TagItem *td_TagList;
a121 3
    /* The hook you wish to be called back through */
    struct Hook *td_CallBack;
};
d629 1
a629 1
    /* One of the POINTERRESN_ flags from pointer.h */
@


38.11
log
@Removed HelpGadget.  Added BusyPointer.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.10 92/04/02 21:37:12 peter Exp Locker: peter $
d56 1
d58 25
d84 39
d124 3
d178 1
a178 1
/* === Intuition Geometric Primitives ===================================== */
d181 19
a199 4
struct FatIntuiMessage {
    struct IntuiMessage fim_IntuiMessage;
    ULONG  PrevKeys;
    };
@


38.10
log
@Added MenuLendingReturn and HelpGadget pointers to IBase.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.9 92/04/02 12:03:15 peter Exp Locker: peter $
d68 3
d509 6
a514 7
    /* Points to ready-to-display SimpleSprites of the preferences
     * mouse-pointer, in each possible size.
     */
    struct SimpleSprite *DefaultXSprite[ POINTER_SIZES ];

    /* Points to MousePointer structure of the preferences
     * mouse-pointer.
d517 1
d519 15
a533 2
    /* Points to the custom MousePointer that is active.
     * If the default pointer is in use, this field is NULL.
d537 3
a539 2
    /* Points to the custom SimpleSprite we're using.  If
     * If the default SimpleSprite is in use, this field is NULL.
d541 1
a541 1
    struct SimpleSprite *CustomXSprite;
d549 11
a559 2
    /* When gadget help happens, the sending gadget is stuffed
     * here temporarily:
d561 1
a561 1
    struct Gadget *HelpGadget;
@


38.9
log
@Added new fields for MousePointer support.  Now includes gfxbase.h.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.8 92/03/19 10:52:26 peter Exp Locker: peter $
d529 7
@


38.8
log
@IBase->VerifyTimeoutTotal marked as unused.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.7 92/03/03 16:32:30 peter Exp Locker: peter $
d27 4
d257 1
a257 1
    USHORT		*APointer;
d336 2
a337 2
    USHORT		*DefPointer;
    BYTE		DefPtrHeight;	/* height of the pointer	*/
d339 1
a339 1
    BYTE		DefPtrXOffset, DefPtrYOffset; /* sprite offsets */
d454 3
a456 1
    UWORD		DefPtrBufSize;
a457 1
    /* an actual instance we'll use, and point to with AttachedSSprite */
d477 1
d488 1
d494 1
d500 1
d505 24
@


38.7
log
@Added IBase->DragScreen field.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.6 92/02/11 13:41:37 peter Exp Locker: peter $
d431 1
a431 1
    UWORD		VerifyTimeoutTotal;
@


38.6
log
@IBase's FrameThick fields now unused.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.5 92/02/07 11:05:33 peter Exp Locker: peter $
d492 4
@


38.5
log
@Marked APtrHeight as unused.  IPointer and friends are now DefPointer
etc.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.4 91/11/25 16:55:54 peter Exp Locker: peter $
d314 2
a315 2
    SHORT		FrameHThick;	/* IFrame thickness		*/
    SHORT		FrameVThick;
@


38.4
log
@Defined IC_MODEPROMOTION.  Someday should switch to including
<Prefs/icontrol.h>.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.3 91/11/15 18:52:07 peter Exp Locker: peter $
d254 1
a254 1
    BYTE		APtrHeight;
d332 4
a335 4
    USHORT		*IPointer;
    BYTE		IPtrHeight;	/* height of the pointer	*/
    BYTE		xxxIPtrWidth;	/* width of the pointer		*/
    BYTE		IXOffset, IYOffset; /* sprite offsets */
d448 1
a448 1
     * for IPointer (actual data amount is SPR_STORAGE( IPBuffHeight )
d450 1
a450 1
    UWORD		IPBufSize;
@


38.3
log
@IBitMap and SBitMap and other unused fields renamed to xxx(...).
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.2 91/07/25 17:05:11 peter Exp Locker: peter $
d507 1
@


38.2
log
@The IntuiMessage in struct FatIntuiMessage is now named, so SAS
can compile it.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.1 91/07/10 17:54:44 peter Exp Locker: peter $
d255 1
a255 1
    BYTE		APtrWidth;
d272 1
a272 1
    struct TmpRas	MenuTmpRas;
d277 2
a278 2
    struct BitMap	IBitMap;	/* for the item's planes	*/
    struct BitMap	SBitMap;	/* for the subitem's planes	*/
d317 1
a317 1
    VOID   		(*sizeDrag)();	/* ISizeWindow or IMoveWindow	*/
d334 1
a334 1
    BYTE		IPtrWidth;	/* width of the pointer		*/
@


38.1
log
@Cleanup of Preferences-related names to improve legibility.
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 38.0 91/06/12 14:19:24 peter Exp Locker: peter $
d107 1
a107 1
    struct IntuiMessage;
@


38.0
log
@Initial V38 check-in (matches V37 release).
@
text
@d11 1
a11 1
 *  $Id: ibase.h,v 1.35 91/05/16 16:32:36 peter Exp $
d405 1
a405 1
    struct IWBPrefs	CoolWBPrefs;
d471 1
a471 1
    struct IWBPrefs	LastScreenMode;
@
