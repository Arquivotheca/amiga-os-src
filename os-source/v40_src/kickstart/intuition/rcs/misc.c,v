head     38.17;
branch   ;
access   ;
symbols  V40_85:38.17 V40_71:38.17 V40_68:38.17 V40_65:38.17 V40_47:38.17 V40_45:38.17 V40_37:38.17 V40_34:38.17 V40_29:38.17 V39_2415:38.17 V39_2369:38.17 V39_2339:38.17 V39_2332:38.17 V39_2275:38.17 V39_2256:38.17 V39_2210:38.17 V39_2192:38.17 V39_2084:38.16 V39_2082:38.16 V39_2076:38.16 V39_2073:38.16 V39_2058:38.16 V39_2051:38.16 V39_2031:38.16 V39_2017:38.16 V39_2012:38.16 V39_1985:38.16 V39_1933:38.16 V39_1819:38.16 V39_1805:38.16 V39_1783:38.16 V39_1695:38.16 V39_1621:38.16 V39_1620:38.16 V39_1508:38.14 V39_1485:38.14 V39_1461:38.14 V39_1458:38.14 V39_1456:38.14 V39_1405:38.14 V39_1368:38.14 V39_1360:38.14 V39_1324:38.14 V39_1147:38.12 V39_1143:38.12 V39_1141:38.12 V39_1120:38.12 V39_1116:38.12 V39_1104:38.12 V39_1100:38.12 V39_1078:38.12 V39_1073:38.12 V39_757:38.10 V39_702:38.10 V39_557:38.10 V39_553:38.10 V39_551:38.10 V39_510:38.9 V39_495:38.9 V39_416:38.9 V39_383:38.9 V39_371:38.8 V39_336:38.8 V39_323:38.8 V39_295:38.7 V39_277:38.6 V39_254:38.6 V39_222:38.5 V39_185:38.5 V39_171:38.5 V39_161:38.4 V38_159:38.4 V38_116:38.3 V38_59:38.3;
locks    ; strict;
comment  @*   @;


38.17
date     92.11.10.17.08.18;  author peter;  state Exp;
branches ;
next     38.16;

38.16
date     92.06.29.10.45.51;  author peter;  state Exp;
branches ;
next     38.15;

38.15
date     92.06.23.17.20.35;  author peter;  state Exp;
branches ;
next     38.14;

38.14
date     92.05.21.17.42.30;  author peter;  state Exp;
branches ;
next     38.13;

38.13
date     92.05.15.14.07.58;  author peter;  state Exp;
branches ;
next     38.12;

38.12
date     92.04.07.17.54.41;  author peter;  state Exp;
branches ;
next     38.11;

38.11
date     92.04.02.12.05.24;  author peter;  state Exp;
branches ;
next     38.10;

38.10
date     92.03.03.16.33.06;  author peter;  state Exp;
branches ;
next     38.9;

38.9
date     92.02.07.11.07.00;  author peter;  state Exp;
branches ;
next     38.8;

38.8
date     92.01.22.16.42.45;  author peter;  state Exp;
branches ;
next     38.7;

38.7
date     91.12.12.20.46.34;  author peter;  state Exp;
branches ;
next     38.6;

38.6
date     91.11.15.18.52.59;  author peter;  state Exp;
branches ;
next     38.5;

38.5
date     91.09.23.12.28.16;  author peter;  state Exp;
branches ;
next     38.4;

38.4
date     91.08.21.18.19.24;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     91.07.10.17.58.21;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     91.06.19.18.05.38;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.06.12.15.11.46;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.12.14.26.34;  author peter;  state Exp;
branches ;
next     ;


desc
@@


38.17
log
@Removed jfreeMem() since only one caller was left, and this saves space.
@
text
@
/*** misc.c *****************************************************************
 *
 *  File
 *
 *  $Id: misc.c,v 38.16 92/06/29 10:45:51 peter Exp Locker: peter $
 *
 *  Confidential Information: Commodore-Amiga, Inc.
 *  Copyright (c) Commodore-Amiga, Inc.
 *
 ****************************************************************************/

#define TEXTPAD 4
/*???#define DEBUG 1*/
/*#define DEBUGMOUSE*/

#include "intuall.h"

#define DFR(x)		;

#ifndef EXEC_MEMORY_H
#include <exec/memory.h>
#endif

#ifndef GRAPHICS_SPRITE_H
#include <graphics/sprite.h>
#endif

#ifndef GRAPHICS_GFXMACROS_H
#include <graphics/gfxmacros.h>
#endif

/*** intuition.library/AllocRemember ***/

CPTR AllocRemember(remember, size, flags)
struct Remember **remember;
ULONG size;
ULONG flags;
{
    struct Remember *nostalgia;

    nostalgia = *remember;
    DFR( printf("AllocR: nostalgia = %lx\n", nostalgia ) );

    if ((*remember = (struct Remember *)AllocMem(sizeof(struct Remember), 0))
	     == 0)
	{
	*remember = nostalgia;
	return(NULL);
	}

    if (((*remember)->Memory = (UBYTE *)AllocMem(size, flags)) == 0)
	{
	FreeMem(*remember, sizeof(struct Remember));
	*remember = nostalgia;
	return(NULL);
	}

    (*remember)->RememberSize = size;
    (*remember)->NextRemember = nostalgia;
    return((CPTR) (*remember)->Memory);
}


/*** intuition.library/FreeRemember ***/

FreeRemember(remember, reallyforget)
struct Remember **remember;
BOOL reallyforget;
{
    struct Remember *present, *past;

    DFR( printf("enter FreeRemember, key at %lx\n", remember));

    present = *remember;
    /* Peter 8-Aug-90: Now we NULL out *remember as early as possible
     * instead of at the end, in case the caller stored the handle in a
     * chunk which we will be freeing here
     */
    *remember = NULL;
    while (present)
	{
	past = present->NextRemember;
	DFR( printf("present %lx, past: %lx\n", present, past ) );
	if (reallyforget)
	{
	    DFR( printf("block %ld %lx,",
		present->RememberSize, present->Memory) );
	    FreeMem(present->Memory, present->RememberSize);
	}
	DFR( printf(" header: %lx.  ", present) );
	FreeMem(present, sizeof(struct Remember));
	present = past;
	DFR( printf("next Remember %lx\n", present ) );
	}
    DFR( printf("ok "));

    DFR( printf("  done \n"));
}


struct Layer *getGimmeLayer(w)
struct Window *w;
{
    struct Layer *l = w->WLayer;

    if (w->Flags & GIMMEZEROZERO) l = w->BorderRPort->Layer;

    return(l);
}

cloneRP( clonerp, rp )
struct RastPort	*clonerp;
struct RastPort	*rp;
{
    *clonerp = *rp;
    /* Peter 11-May-92: Geez, all this time we've been setting 
     * rp->Mask to -1.  That's the wrong RastPort.  How did
     * it ever work???
     *
     * Also, we now NULL-out the TmpRas of the clone.  The reason
     * is sinister.  Starting with V37, Gfx uses the TmpRas if there
     * is one for temporary storage during Text() calls.  This can
     * interfere with application usage of the TmpRas to do
     * normal operations like area-fills.
     */
    clonerp->Mask = -1;
    clonerp->TmpRas = NULL;
}

cloneRPFont( clonerp, rp )
struct RastPort	*clonerp;
struct RastPort	*rp;
{
    SetFont( clonerp, rp->Font );
    clonerp->AlgoStyle = rp->AlgoStyle;
}

BlastPatternBox( rp, box, pat, size, pena, penb, mode )
struct RastPort *rp;
struct IBox	*box;
USHORT 		*pat;
UBYTE 		pena, penb;
UBYTE		mode;
{
	BlastPattern( rp, box->Left, box->Top, 
	    boxRight( box ), boxBottom( box ),
	    pat, size, pena , penb, mode);
}

/* jimm: 4/4/86: took out layer parameter: use one in RP */
BlastPattern(RP, left, top, right, bottom, pattern, size, 
	pena, penb, mode)
struct RastPort *RP;
int left, top, right, bottom, size;
USHORT *pattern;
int pena, penb, mode;
{
    /* assume RP can be messed with
     * jimm: 2/6/86: check all cases, either using BarLayer->rp,
     * MenuRPort, or IBase->RP (locked)
     */

/** 
    printf("BP l/t/r/b: %ld/%ld/%ld/%ld size %ld\n",
    left, top, right, bottom, size);
**/

    SetAfPt(RP, pattern, size);
    SetABPenDrMd(RP, pena, penb, mode);
    SafeRectFill(RP, left, top, right, bottom);

    SetAfPt(RP, NULL, 0);	/* Peter 12-Dec-91: no ghosted string gadgets */
}


drawBox(rp, x, y, width, height, apen, mode, hthick, vthick)
struct RastPort *rp;
int x, y, width, height, hthick, vthick;
int apen, mode;
/* draws the Box */
{
    int right, bottom, i;

    right = x + width - 1;
    bottom = y + height - 1;

    SetABPenDrMd(rp, apen, 0, mode);

    /* verticals	*/
    for (i = 0; i < hthick; i++)
	{
	Move(rp, x + i, y);
	Draw(rp, x + i, bottom);
	Move(rp, right - i, y);
	Draw(rp, right - i, bottom);
	}

    x += hthick;
    right -= hthick;

    /* horizontals	*/
    for (i = 0; i < vthick; i++)
	{
	Move(rp, x, y + i);
	Draw(rp, right, y + i);
	Move(rp, x, bottom - i);
	Draw(rp, right, bottom - i);
	}
}


xorbox(rp, left, top, width, height)
struct RastPort *rp;
int left, top, width, height;
{
    rp->Mask = -1;
    xorboxmask(rp, left, top, width, height);
}
xorboxmask(rp, left, top, width, height)
struct RastPort *rp;
int left, top, width, height;
{
    /** jimm: looks like it ain't used struct SaveRPort saver; **/

    SetDrMd(rp, COMPLEMENT);
    SetAfPt(rp, NULL, 0);	/* jimm: 4/13/90: no ghosted gadgets  */
    RectFill(rp, left, top, left + width - 1, top + height - 1);
}

/*???*/
#define MENUHPADDING 4
#define MENUVPADDING 2

outbox(rp, left, top, width, height)
struct RastPort *rp;
int left, top, width, height;
{
    /*** mask = rp->Mask; **/
    /* rp->Mask = -1; already set up */

    drawBox(rp, left - MENUHPADDING, top - MENUVPADDING, 
	    width + (MENUHPADDING << 1), height + (MENUVPADDING << 1),
	    0, COMPLEMENT, MENUHPADDING, MENUVPADDING);

    /** rp->Mask = mask; ***/
}

drawBlock(rp, left, up, right, down, apen)
struct RastPort *rp;
int left, up, right, down;
int apen;
{
    rp->Mask = -1;
    SetABPenDrMd(rp, apen, 0, JAM2);
    /* jimm: 4/25/86: got to get the pattern clear */
    SetAfPt(rp, NULL, 0);

    SafeRectFill(rp, left, up, right, down);
}


/*** intuition.library/DrawImage ***/

#if 0
/* moved temporarily to imageclass.c */
DrawImage(rport, image, xoffset, yoffset)
struct RastPort *rport;
struct Image *image;
int xoffset, yoffset;
{
    while (image)
	{
	drawImageGrunt(rport, image, xoffset, yoffset);
	image = image->NextImage;
	}
}
#endif

drawImageGrunt(rport, image, xoffset, yoffset, minterm )
struct RastPort *rport;
struct Image *image;
int xoffset, yoffset;
{
    struct BitMap BMap;
    int	plane;
    unsigned int planesize;
    UBYTE	mask;
    UWORD	*planedata;

    /* jimm: 5/23/90: sanity check on image dims used to
     * be done "implicitly" by AllocMem() of planeonoff planes.
     * Now we must be explicit for compatibility.
     */
    if ( image->Height <= 0 || image->Width <= 0 ) return;

    /* initialize a bitmap */
    InitBitMap( &BMap, rport->BitMap->Depth, image->Width, image->Height );

    mask = ( 1 << 0 );	/* identifies plane 0 */

    planedata = image->ImageData;
    planesize = ( BMap.BytesPerRow * BMap.Rows ) / 2;	   /* in words */

    /* init plane pointers to one of: data, all ones, all zeroes */
    for ( plane = 0, mask = 1; plane < BMap.Depth; ++plane, mask <<= 1 )
    {
	if ( mask & image->PlanePick ) 
	{
	    BMap.Planes[ plane ] = (PLANEPTR) planedata;
	    planedata += planesize;
	}
	else if ( mask & image->PlaneOnOff )
	{
	    BMap.Planes[ plane ] = (PLANEPTR) -1;
	}
	else
	{
	    BMap.Planes[ plane ] = NULL;
	}
    }


    BltBitMapRastPort(&BMap, 0, 0, rport, xoffset + image->LeftEdge,
	    yoffset + image->TopEdge, image->Width, image->Height, minterm );
}

/*** intuition.library/DrawBorder ***/

DrawBorder(rp, border, left, top)
struct RastPort *rp;
struct Border *border;
int left, top;
{
    int i, x, y;
    SHORT *xypair;
    int trueleft, truetop;
    struct RastPort clonerp;

    cloneRP( &clonerp, rp );

    /* clonerp.Mask = -1; *already */

    while (border)
	{
	SetABPenDrMd(&clonerp, border->FrontPen, border->BackPen, border->DrawMode);
	trueleft = left + border->LeftEdge;
	truetop = top + border->TopEdge;
	xypair = border->XY;
	x = *xypair++ + trueleft;
	y = *xypair++ + truetop;
	Move(&clonerp, x, y);
	for (i = border->Count - 1; i > 0; i--)
	    {
	    x = *xypair++ + trueleft;
	    y = *xypair++ + truetop;
	    Draw(&clonerp, x, y);
	    }
	border = border->NextBorder;
	}
}


/*** intuition.library/PrintIText ***/

PrintIText(rp, itext, left, top)
struct RastPort *rp;
struct IntuiText *itext;
int left, top;
{
    printIText(rp, itext, left, top, TRUE );

    /* side-effect compatibility	*/
    return ( TRUE );
}

/* need a version which ignores pens and draw mode
 * for newlook compatible AutoRequest
 */
printIText(rp, itext, left, top,  use_it_pens_and_mode )
struct RastPort *rp;
struct IntuiText *itext;
int left, top;
{
    struct RastPort	clonerp;
    /** MODIFY: jimm 11/7/85 **/
    struct TextFont	*ISetFont();
    struct TextFont	*tmpfp = NULL;

    cloneRP( &clonerp, rp );

    /* clonerp.Mask = -1; *already */

    while (itext)
    {
	if ( use_it_pens_and_mode )
	{
	    SetABPenDrMd( &clonerp, itext->FrontPen, itext->BackPen, itext->DrawMode );
	}

	/** MODIFY: jimm 11/7/85 , default to rp font, not sys font **/
	if (itext->ITextFont != NULL)
	{
	    tmpfp = ISetFont( &clonerp, itext->ITextFont);
	}

	Move( &clonerp, left+itext->LeftEdge,
		top+itext->TopEdge+ clonerp.TxBaseline);

	/* jimm: 7/22/86: someone has to protect against
	 * NULL text pointers, don't they?!
	 */
	if (itext->IText) Text( &clonerp, itext->IText, strlen(itext->IText));

	/** MODIFY: jimm 11/7/85 **/
	if (itext->ITextFont != NULL)
	{
		ICloseFont(tmpfp);
		/* restore rp default font	*/
		cloneRPFont( &clonerp, rp );
	}

	itext = itext->NextText;
    }

    /* jimm: 9/16/88:
     * clone approach screws people expecting cp to change
     */
    rp->cp_x = clonerp.cp_x;
    rp->cp_y = clonerp.cp_y;
}


/*** intuition.library/ReportMouse ***/

#if 0	/* downcoded	*/
ReportMouse(w, bool)
struct Window *w;
BOOL bool;
{
	/* this function should be rewritten to reverse the parameters */
    /* Forbid(); */	/* jimm:5/20/86 */
    if (bool) w->Flags |= REPORTMOUSE;
    else w->Flags &= ~REPORTMOUSE;
    /* Permit(); */
}
#endif


/*** intuition.library/ItemAddress ***/

struct MenuItem *ItemAddress(menustrip, menunum)
struct Menu *menustrip;
USHORT menunum;
{
    struct Menu *menu;
    struct MenuItem *item, *sub;

    item = NULL;
    if (menu = grabMenu(menustrip, menunum))
	if (item = grabItem(menu, menunum))
	    if (sub = grabSub(item, menunum)) item = sub;

    return(item);
}


/*** intuition.library/DoubleClick ***/

BOOL
DoubleClick(startsec, startmicro, endsec, endmicro)
ULONG startsec, startmicro, endsec, endmicro;
{
    LONG longi;
    struct IntuitionBase *IBase = fetchIBase();

    if (endmicro < startmicro)
	{
	endsec--;
	endmicro += 1000000;
	}
    longi = (endsec - startsec) - IBase->DoubleSeconds;
    if (longi < 0) return(TRUE);
    if (longi == 0) 
	if (endmicro - startmicro < IBase->DoubleMicros) return(TRUE);
    return(FALSE);
}


/*** intuition.library/CurrentTime ***/

CurrentTime(secs, micros)
ULONG *secs, *micros;
{
    struct IntuitionBase *IBase = fetchIBase();

    *secs = IBase->Seconds;
    *micros = IBase->Micros;
}


/*** intuition.library/ViewAddress ***/

struct View *ViewAddress()
{
    struct IntuitionBase *IBase = fetchIBase();

    return(&IBase->ViewLord);
}


/*** intuition.library/ViewPortAddress ***/

#if 0	/* do this in the vector	*/
struct ViewPort *ViewPortAddress(window)
struct Window *window;
{
    return(&window->WScreen->ViewPort);
}
#endif


/*** intuition.library/DisplayBeep ***/

IDisplayBeep(screen)
struct Screen *screen;
{
    struct IntuitionBase *IBase = fetchIBase();

    /* flash color 0 of the window */
    LOCKIBASE();
    /* still need this lock to protect screen list, but
     * an additional Forbid() is used to protect against
     * save/restore conflicts
     */

    /* screen of NULL or ~0 means beep all screens. */
    if ( ( screen == (struct Screen *) ~0 ) || ( !screen ) )
    {
	screen = IBase->FirstScreen;
	while (screen)
	{
	    if ( !TESTFLAG( screen->Flags, SCREENHIDDEN ) )
	    {
		beepGrunt( screen );
	    }
	    screen = screen->NextScreen;
	}
    }
    else
    {
	beepGrunt(screen);
    }
    UNLOCKIBASE();
}

/* This routine does a kind of complementing of the color, but
 * which is good for grays, too.  (The simple complement of
 * a middle-gray is almost the same shade).
 * We set each color's component to 5 or 12, whichever is farther
 * from its current value.
 */
ULONG beepComplement(color)
ULONG color;
{
    if ( color > 0x88888888 )
    {
	/* If the color component is bright, return dark */
	return( 0x55555555 );
    }
    else
    {
	/* Else return bright */
	return( 0xCCCCCCCC );
    }
}

beepGrunt(screen)
struct Screen *screen;
{
    ULONG red, green, blue;

    /* Peter: 6-Aug-90
     * beepGrunt (from IDisplayBeep) is the only place where BEEPING
     * is set, so we are protected by IDB's LOCKIBASE.
     * The protocol will be: test flag, change the color, change flag.
     */
    /* is this one Beeping yet? */
    if ((screen->Flags & BEEPING) == 0)
    {
	/* Save off color zero, at 32 bits per gun.  Relies
	 * on SaveRed, SaveGreen, SaveBlue being consecutive in the
	 * XScreen structure.
	 */
	GetRGB32( screen->ViewPort.ColorMap, 0, 1, &XSC(screen)->SaveRed );

	red = beepComplement( XSC(screen)->SaveRed );
	green = beepComplement( XSC(screen)->SaveGreen );
	blue = beepComplement( XSC(screen)->SaveBlue );

	SetRGB32( &screen->ViewPort, 0, red, green, blue );

	/* Extend the beep */
	XSC(screen)->PrivateFlags |= PSF_DELAYBEEP;
	/* not Beeping yet, so start it up now */
	screen->Flags |= BEEPING;
    }
}


/* lock system shared rastport, but first lock layer rom
 * for layer passed.  if this rastport is to be layered,
 * lots of calls will lockrom, but order is layers before rp
 *
 * WARNING: because of UserClipRegions: this routine should not
 * be 'nested' since IBase->OldClipRegion, etc., get clobbered.
 * jimm made a change in drawGadgets() to avoid nesting, but if
 * it must be done, skip the save/restore of layer data if 
 * ss_NestCount > 1 (in freeRP(), too).
 *
 * V36: protect self: set mode to JAM1, Mask to ~0 guaranteed.
 */
struct RastPort *obtainRP( clonee, layer )
struct RastPort *clonee;	/* will copy this guy if non-NULL */
struct Layer *layer;
{
    struct IntuitionBase *IBase = fetchIBase();

    if ( !clonee ) return ( NULL );

    if (layer)
    {
	LockLayerRom( layer );
    }

    LOCKRP();

#ifdef DEBUG
    /* DEBUG */
    if (IBase->ISemaphore[RPLOCK].ss_NestCount > 1)
    {
	printf("double rp lock %ld.\n",IBase->ISemaphore[RPLOCK].ss_NestCount);
	Debug();
    }
#endif

    if (layer)
    {
	/* save and change some things */
	IBase->OldClipRegion = (struct Region *) InstallClipRegion(layer, NULL);

	/* So we render good whether the guy called ScrollLayer
	 * or not:
	 */
	IBase->OldScroll.X = layer->Scroll_X;
	layer->Scroll_X = 0;	/* rendering offset */

	IBase->OldScroll.Y = layer->Scroll_Y;
	layer->Scroll_Y = 0;
    }

    cloneRP( IBase->RP, clonee );

    IBase->RP->Layer = layer;

    SetDrMd( IBase->RP, JAM1 );

    return( IBase->RP );
}

/*** intuition.library/ReleaseGIRPort ***/

/* I really only need this for in-rom gadget classes.
 */
ReleaseGIRPort( rp )
struct RastPort *rp;
{
    freeRP(rp);
}

freeRP(rp)
struct RastPort *rp;	/* may be from pool */
{
    struct IntuitionBase *IBase = fetchIBase();

    if ( !rp ) return;

    if (rp->Layer) 
    {
	/* So we render good whether the guy called ScrollLayer
	 * or not:
	 */
	rp->Layer->Scroll_X = IBase->OldScroll.X;
	rp->Layer->Scroll_Y = IBase->OldScroll.Y;

	InstallClipRegion(rp->Layer, IBase->OldClipRegion);
	UnlockLayerRom(rp->Layer);
    }
    UNLOCKRP();
}

/*** intuition.library/ObtainGIRPort ***/

struct RastPort	*
ObtainGIRPort( gi )
struct GadgetInfo	*gi;
{
    if ( gi == NULL ) return ( NULL );	/* didn't lock anything */
    /* ZZZ: maybe there are "partially setup" ginfo's that
     * a gadget can use to get resolution, font, and color
     * from, but you can't render.  Also, perhaps, the
     * gadget might not be added to a window yet.
     */
    return ( obtainRP( gi->gi_RastPort, gi->gi_Layer ) );
}

@


38.16
log
@Mike downcoded a bunch of small routines, so they're gone from here.
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 38.15 92/06/23 17:20:35 peter Exp Locker: peter $
a98 7
}


jfreeMem( mem, size )
void	*mem;
{
    if ( mem && size ) FreeMem( mem, size );
@


38.15
log
@Uses regular multiply instead of umuls().
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 38.14 92/05/21 17:42:30 peter Exp Locker: peter $
a255 33

/* returns TRUE if strings match exactly	*/
jstreq( a, b )
char *a;
char *b;
{
    while ( *a )
    {
	if ( *a++ != *b++ ) return ( 0 ); /* non-terminators match	*/
    }
    return ( ! *b );			/* is b also terminated?	*/
}


jstrncpy( dest, src, num )
char	*dest;
char	*src;
{
    while ( ( num-- > 0 )  && ( *dest++ = *src++ ) );
}


strlen(text)
BYTE *text;
{
    register BYTE *cptr;

    cptr = text;
    while (*cptr) cptr++;
    return(cptr - text);
}


a723 14
imin(a, b)
{
    return (a < b? a: b);
}

imax(a, b)
{
    return (a > b? a: b);
}

iabs( a )
{
    return ( (a > 0)? a: -a );
}
@


38.14
log
@Optimized obtainRP().
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 38.13 92/05/15 14:07:58 peter Exp Locker: peter $
a329 1
    UWORD	umuls();
d343 1
a343 1
    planesize = umuls(BMap.BytesPerRow, BMap.Rows) / 2;	   /* in words */
@


38.13
log
@DisplayBeep( ~0 ) is equivalent to DB( 0 ).  This is to support some
future scheme as suggested by Talin.  cloneRP() now clears the mask
in the correct RastPort.  Also, TmpRas is cleared by cloneRP().
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 38.12 92/04/07 17:54:41 peter Exp Locker: peter $
d664 1
a664 1
struct RastPort *obtainRP(clonee, layer)
d674 1
a674 1
	LockLayerRom(layer);
d703 1
a703 2
    if (clonee) CopyMem(clonee, IBase->RP, RASTPORTUSED );
			    /* ZZZ: may rather set font */
a704 2
    IBase->RP->TmpRas = NULL;

a706 2
    /* jimm: 6/12/86: intuition don't respect no stinkin' write mask! */
    IBase->RP->Mask = ~0;
d709 1
a709 1
    return (IBase->RP);
@


38.12
log
@Removed unused vble.
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 38.11 92/04/02 12:05:24 peter Exp Locker: peter $
d124 12
a135 1
    rp->Mask = -1;
d578 2
a579 2
    if (screen) beepGrunt(screen);
    else
d590 4
@


38.11
log
@Renamed setMouse() to setMousePointer(), and it no longer takes a
window parameter.  Moved it to pointer.c.  Renamed reportMouse() to
updateMousePointer().  selectPointer() no longer takes a parameter.
SetPointer() and ClearPointer() moved to pointer.c.  Evicted
autodocs.
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 38.10 92/03/03 16:33:06 peter Exp Locker: peter $
a234 2
    USHORT mask;

d340 1
a340 1
	    BMap.Planes[ plane ] = planedata;
a418 2
    /** not used ... APTR RPfont; **/
    struct IntuitionBase *IBase = fetchIBase();
a606 1
    USHORT color0;
@


38.10
log
@Renamed private screen flags.  Now tests SCREENHIDDEN flag instead
of calling IsCompatible().
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 38.9 92/02/07 11:07:00 peter Exp Locker: peter $
a18 2
#define DSETM(x)	;
#define DSM(x)		;
d33 2
a34 88
/****** intuition.library/AllocRemember ****************************************
*
*    NAME
*	AllocRemember -- AllocMem() with tracking to make freeing easy.
*
*    SYNOPSIS
*	MemBlock = AllocRemember( RememberKey, Size, Flags )
*	D0			  A0	       D0    D1
*	
*	APTR AllocRemember( struct Remember **, ULONG, ULONG );
*
*    FUNCTION
*	This routine calls the Exec AllocMem() function for you, but also links
*	the parameters of the allocation into a master list, so that
*	you can simply call the Intuition routine FreeRemember() at a later 
*	time to deallocate all allocated memory without being required to
*	remember the details of the memory you've allocated.
*
*	This routine will have two primary uses:
*       -   Let's say that you're doing a long series of allocations in a 
*           procedure.  If any one of the allocations fails, your program
*	    may need to abort the procedure.  Abandoning ship correctly
*	    involves freeing up what memory you've already allocated.  This
*	    procedure allows you to free up that memory easily, without being
*	    required to keep track of how many allocations you've already done,
*	    what the sizes of the allocations were, or where the memory was
*	    allocated.
*
*       -   Also, in the more general case, you may do all of the allocations 
*           in your entire program using this routine.  Then, when your 
*           program is exiting, you can free it all up at once with a 
*           simple call to FreeRemember().
*
*	You create the "anchor" for the allocation master list by creating 
*	a variable that's a pointer to struct Remember, and initializing 
*	that pointer to NULL.  This is called the RememberKey.  Whenever 
*	you call AllocRemember(), the routine actually does two memory 
*	allocations, one for the memory you want and the other for a copy 
*	of a Remember structure.  The Remember structure is filled in 
*	with data describing your memory allocation, and it's linked 
*	into the master list pointed to by your RememberKey.  Then, to 
*	free up any memory that's been allocated, all you have to do is 
*	call FreeRemember() with your RememberKey.
*
*	Please read the FreeRemember() function description, too.  As you will
*	see, you can select either to free just the link nodes and keep all the 
*	allocated memory for yourself, or to free both the nodes and your memory
*	buffers.
*
*
*    INPUTS
*	RememberKey = the address of a pointer to struct Remember.  Before the
*	very first call to AllocRemember, initialize this pointer to NULL. 
*
*	Size = the size in bytes of the memory allocation.  Please refer to the
*	    exec.library/AllocMem() function for details.
*	Flags = the specifications for the memory allocation.  Please refer to 
*	    the exec.library/AllocMem() function for details.
*
*    EXAMPLE
*	struct Remember *RememberKey;
*	RememberKey = NULL;
*	buffer = AllocRemember(&RememberKey, BUFSIZE, MEMF_CHIP);
*	if (buffer)
*	{
*	    \* Use the buffer *\
*	    ...
*	}
*	FreeRemember(&RememberKey, TRUE);
*
*    RESULT
*	If the memory allocation is successful, this routine returns the byte 
*	address of your requested memory block.  Also, the node to your block 
*	will be linked into the list pointed to by your RememberKey variable.
*	If the allocation fails, this routine returns NULL and the list pointed
*	to by RememberKey, if any, will be unchanged.
*
*    BUGS
*	This function makes two allocations for each memory buffer
*	you request.  This is neither fast nor good for memory
*	fragmentation.
*
*	This function should use the exec AllocPool() function internally,
*	at least for the Remember headers.
*
*    SEE ALSO
*	FreeRemember(), exec.library/AllocMem()
*****************************************************************************/
d65 2
a66 52
/****** intuition.library/FreeRemember **************************************
*
*    NAME
*	FreeRemember -- Free memory allocated by calls to AllocRemember().
*
*    SYNOPSIS
*	FreeRemember( RememberKey, ReallyForget )
*		      A0           D0
*
*	VOID FreeRemember( struct Remember **, BOOL );
*
*    FUNCTION
*	This function frees up memory allocated by the AllocRemember() function.
*	It will either free up just the Remember structures, which supply the
*	link nodes that tie your allocations together, or it will deallocate
*	both the link nodes AND your memory buffers too.
*	
*	If you want to deallocate just the Remember structure link nodes,
*	you should set the ReallyForget argument to FALSE.  However, if you
*	want FreeRemember to really deallocate all the memory, including
*	both the Remember structure link nodes and the buffers you requested
*	via earlier calls to AllocRemember(), then you should set the 
*	ReallyForget argument to TRUE.
*
*	NOTE WELL: Once you call this function passing it FALSE, the
*	linkages between all the memory chunks are lost, and you
*	cannot subsequently use FreeRemember() to free them.
*
*    INPUTS
*	RememberKey = the address of a pointer to struct Remember.  This
*           pointer should either be NULL or set to some value (possibly
*           NULL) by a call to AllocRemember().
*	ReallyForget = a BOOL FALSE or TRUE describing, respectively, 
*           whether you want to free up only the Remember nodes or 
*           if you want this procedure to really forget about all of 
*           the memory, including both the nodes and the memory buffers 
*           referenced by the nodes.
*
*    EXAMPLE
*	struct Remember *RememberKey;
*	RememberKey = NULL;
*	AllocRemember(&RememberKey, BUFSIZE, MEMF_CHIP);
*	FreeRemember(&RememberKey, TRUE);
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	AllocRemember(), exec.library/FreeMem()
*****************************************************************************/
a166 1

d294 1
a294 74
/* this now takes just a window pointer parameter
 * result is that pointer is set to default
 * if window is null, or if window->Pointer is null
 */

setMouse(w)
struct Window *w;
{
    USHORT *IP;
    SHORT IPH, xoff, yoff;
    struct IntuitionBase *IBase = fetchIBase();

    /* protect against using freed data changed by setDefaultPointer */
    /* need LockIBase since we call reportMouse() which needs IBase lock */
    LOCKIBASE();
    LOCKVIEW();

    /** fix for mouse jumping
     * works "most of the time".
     * use the viewport of the window being activated
     * to pass to ChangeSprite.
     * Might see jump if a window is activated programmatically
     * while the sprite is not within the window's screen viewport.
     * But it should fix all cases where you click-activate a window.
     */

    if ( (w != NULL) && (w->Pointer != NULL))
    {
	IP = w->Pointer;
	IPH = w->PtrHeight;
	xoff = w->XOffset;
	yoff = w->YOffset;
    }
    else
    {
	IP = IBase->DefPointer;
	IPH = IBase->DefPtrHeight;
	xoff = IBase->DefPtrXOffset;
	yoff = IBase->DefPtrYOffset;
    }

    IBase->SimpleSprite->height = IPH;


    /* attach new pointer? */
    /* we only attach intuition pointer */

    if ((IBase->DefPointer == IP) 	/* new pointer is ours */
	&& (IBase->AttachedSSprite != NULL)	/* want attached */
	&& !IBase->GotSprite1)		/* haven't already got */
    {
	IBase->GotSprite1 = ( GetSprite(IBase->AttachedSSprite, 1) != -1 );
    }

    /* we only unattach intuition pointer */
    /* Free if we have the sprite and the new pointer isn't our own */
    if (IBase->GotSprite1 &&
	((IP != IBase->DefPointer)||(IBase->AttachedSSprite == NULL)))
    {
	FreeSprite(1);
	IBase->GotSprite1 = FALSE;
    }
	    
    IBase->APointer = IP;
    IBase->AXOffset = xoff;
    IBase->AYOffset = yoff;

    DSETM( kpause("calling report mouse") );

    reportMouse(TRUE);	/* perhaps wrong for initIntuition() */
    UNLOCKVIEW();
    UNLOCKIBASE();
}

a295 48
/****** intuition.library/DrawImage ***************************************
*
*    NAME
*	DrawImage -- Draw the specified Image structure into a RastPort.
*
*    SYNOPSIS
*	DrawImage( RastPort, Image, LeftOffset, TopOffset )
*		   A0        A1     D0          D1
*
*	VOID DrawImage( struct RastPort *, struct Image	*, WORD, WORD );
*
*    FUNCTION
*	First, sets up the draw mode and pens in the RastPort according to the
*	arguments of the Image structure.  Then, moves the image data of
*	the image argument into the RastPort, offset by the left and top
*	offsets.
*	
*	This routine does window layer clipping if you pass your window's
*	(layered) RastPort -- if you draw an image outside of your window,
*	your imagery will be clipped at the window's edge.  If you pass
*	a (non-layered) screen RastPort, you MUST be sure your image is
*	wholly contained within the rastport bounds.
*
*	If the NextImage field of the image argument is non-NULL, 
*	the next image is rendered as well, and so on until some
*	NextImage field is found to be NULL.
*
*    INPUTS
*	RastPort = pointer to the RastPort to receive image rendering
*	Image = pointer to an image structure
*	LeftOffset = the offset which will be added to the image's x coordinate
*	TopOffset = the offset which will be added to the image's y coordinate
*
*    RESULT
*	None
*
*    NOTES
*	Intuition always has and will continue to assume there are
*	at least as many planes of data pointed to by ImageData as there
*	are '1' bits in the PlanePick field.  Please ensure that
*	this is so.  (See the intuition.h include file for full details
*	on using PlanePick).
*
*    BUGS
*
*    SEE ALSO
*	DrawImageState(), EraseImage()
*****************************************************************************/
d360 2
a361 38
/****** intuition.library/DrawBorder ***************************************
*
*    NAME
*	DrawBorder -- Draw the specified Border structure into a RastPort.
*
*    SYNOPSIS
*	DrawBorder( RastPort, Border, LeftOffset, TopOffset )
*		    A0        A1      D0          D1
*
*	VOID DrawBorder( struct RastPort *, struct Border *, WORD, WORD );
*
*    FUNCTION
*	First, sets up the draw mode and pens in the RastPort according to the
*	arguments of the Border structure.  Then, draws the vectors of
*	the border argument into the RastPort, offset by the left and top
*	offsets.
*
*	As with all graphics rendering routines, the border will be clipped to
*	to the boundaries of the RastPort's layer, if it exists.  This is
*	the case with window RastPorts.
*
*	This routine will draw all borders in the NULL-terminated list linked
*	by the NextBorder field of the border argument.
*
*    INPUTS
*	RastPort = pointer to the RastPort to receive the border rendering
*	Border = pointer to a Border structure
*	LeftOffset = the offset to be added to each vector's x coordinate
*	TopOffset = the offset to be added to each vector's y coordinate
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	
*****************************************************************************/
d396 2
a397 47
/****** intuition.library/PrintIText ****************************************
*
*    NAME
*	PrintIText -- Print text described by the IntuiText argument.
*
*    SYNOPSIS
*	PrintIText( RastPort, IText, LeftOffset, TopOffset )
*		    A0        A1     D0          D1
*
*	VOID PrintIText( struct RastPort *, struct IntuiText *, WORD, WORD );
*
*    FUNCTION
*	Prints the IntuiText into the specified RastPort.  Sets up the RastPort
*	as specified by the IntuiText values, then prints the text into the
*	RastPort at the IntuiText x/y coordinates offset by the left/top 
*	arguments.  Note, though, that the IntuiText structure itself
*	may contain further text position coordinates: those coordinates
*	and the Left/TopOffsets are added to obtain the true position of
*	the text to be rendered.
*
*	This routine does window layer clipping as appropriate -- if you 
*	print text outside of your window, your characters will be 
*	clipped at the window's edge, providing you pass your window's
*	(layered) RastPort.
*
*	If the NextText field of the IntuiText argument is non-NULL, 
*	the next IntuiText is rendered as well, and so on until some
*	NextText field is NULL.
*	
*	IntuiText with the ITextFont field NULL are displayed in the
*	font of the RastPort.  If the RastPort font is also NULL, the
*	system default font, as set via the Preferences tool, will be used.
*
*    INPUTS
*	RastPort = the RastPort destination of the text
*	IText = pointer to an instance of the structure IntuiText
*	LeftOffset = left offset of the IntuiText into the RastPort
*	TopOffset = top offset of the IntuiText into the RastPort
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	
*****************************************************************************/
d468 1
a468 115
/****** intuition.library/SetPointer ****************************************
*
*    NAME
*	SetPointer -- Specify a pointer sprite image for a window.
*
*    SYNOPSIS
*	SetPointer( Window, Pointer, Height, Width, XOffset, YOffset )
*		    A0      A1       D0      D1     D2       D3
*
*	VOID SetPointer( struct Window *, UWORD *, WORD, WORD, WORD, WORD );
*
*    FUNCTION
*	Sets up the window with the sprite definition for the pointer.  
*	Then, whenever the window is the active one, the pointer 
*	image will change to the window's version.  If the window is
*	the active one when this routine is called, the change takes
*	place immediately.
*
*	The XOffset and YOffset parameters are used to offset the
*	upper-left corner of the hardware sprite image from what Intuition
*	regards as the current position of the pointer.  Another way of
*	describing it is as the offset from the "hot spot" of the pointer
*	to the top-left corner of the sprite.  For instance, if you specify 
*	offsets of zero, zero, then the top-left corner of your sprite 
*	image will be placed at the mouse position.  On the other hand, 
*	if you specify an XOffset of -7 (remember, sprites are 16 pixels 
*	wide) then your sprite will be centered over the mouse position.  
*	If you specify an XOffset of -15, the right-edge of the sprite 
*	will be over the mouse position.
*
*    INPUTS
*	Window = pointer to the window to receive this pointer definition
*	Pointer = pointer to the data definition of a sprite
*	Height = the height of the pointer
*	Width = the width of the sprite (must be less than or equal to sixteen)
*	XOffset = the offset for your sprite from the mouse position
*	YOffset = the offset for your sprite from the mouse position
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	ClearPointer(), Intuition Reference Manual or Amiga ROM
*	Kernel Manual
*****************************************************************************/
SetPointer(window, pointer, height, width, xoffset, yoffset)
struct Window *window;
USHORT *pointer;
int height, width, xoffset, yoffset;
{
    struct IntuitionBase *IBase;

    DSM( printf("SetPointer %lx for window %lx ", pointer, window));

    IBase = (struct IntuitionBase *)fetchIBase();

    window->Pointer = pointer;
    window->PtrHeight = height;
    window->PtrWidth = width;
    window->XOffset = xoffset;
    window->YOffset = yoffset;

    /*** lockIBase(ISTATELOCK); ***/	/* protect ActiveWindow */
    Forbid();
    if (IBase->ActiveWindow == window)
	{
	setMouse(window);
	}
    Permit();
    /*** unlockIBase(ISTATELOCK); ***/
    DSM( printf("done.\n"));
}


/****** intuition.library/ClearPointer ***************************************
*
*    NAME
*	ClearPointer -- Clear the mouse pointer definition from a window.
*
*    SYNOPSIS
*	ClearPointer( Window )
*		      A0
*
*	VOID ClearPointer( struct Window * );
*
*    FUNCTION
*	Clears the window of its own definition of the Intuition mouse pointer.  
*	After calling ClearPointer(), every time this window is the active 
*	one the default Intuition pointer will be the pointer displayed 
*	to the user.  If your window is the active one when this routine 
*	is called, the change will take place immediately.
*
*	Custom definitions of the mouse pointer which this function clears
*	are installed by a call to SetPointer().
*
*    INPUTS
*	Window = pointer to the window to be cleared of its pointer definition
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	SetPointer()
*****************************************************************************/
ClearPointer(window)
struct Window *window;
{
    struct IntuitionBase *IBase;
    IBase = (struct IntuitionBase *)fetchIBase();

    DSM( printf("ClearPointer window %lx\n", window));
a469 104
    window->Pointer = NULL;
    window->PtrHeight = 0;
    window->PtrWidth = 0;

    /*** lockIBase(ISTATELOCK);	 ***/ /* protect ActiveWindow */
    Forbid();
    if (IBase->ActiveWindow == window)
	{
	setMouse(window);
	}
    Permit();
    /*** unlockIBase(ISTATELOCK); ***/
    DSM( printf("end ClearPointer\n"));
}



/****** intuition.library/ReportMouse **************************************
*    NAME
*	ReportMouse -- Tell Intuition whether to report mouse movement.
*
*    SYNOPSIS
*	ReportMouse( Boolean, Window )
*		     D0       A0	<-note
*
*	VOID ReportMouse( BOOL, struct Window * );
*
*    SPECIAL NOTE
*	Some compilers and link files switch the arguments to this function
*	about in unpredictable ways.  We apologize for this confusion
*	wrapped around an error enclosing a mistake.
*	The call will take one of two forms:
*
*		ReportMouse(Boolean, Window);
*			-or-
*		ReportMouse(Window, (ULONG)Boolean);
*
*	The first form is the one that corresponds to the amiga.lib supplied
*	by Commodore.  The linker libraries and "pragmas" of some compilers
*	supply the alternate form.
*
*	A key point to remember is that the form of the function in ROM
*	has always been the same, so there has always been object code
*	compatibility.  However some care should be taken when switching
*	compilers or switching between stubs and pragmas.
*
*	From assembler the interface has always been:
*		Boolean in D0, Window in A0
*
*	Also, it is still endorsed to simply set the WFLG_REPORTMOUSE flag bit
*	in Window->Flags, or reset it, on your own.  Make the operation
*	an atomic assembly instruction (OR.W #WFLG_REPORTMOUSE,wd_Flags+2(A0)
*	where A0 contains your window pointer).  Most compilers will produce
*	an atomic operation when faced with:
*			Window->Flags |= WFLG_REPORTMOUSE;
*			Window->Flags &=~WFLG_REPORTMOUSE;
*	or else bracket the operation between Forbid()/Permit().
*
*    FUNCTION
*	Tells Intuition whether or not to broadcast mouse-movement events to
*	your window when it's the active one.  The Boolean value specifies
*	whether to start or stop broadcasting position information of
*	mouse-movement.  If the window is the active one, mouse-movement reports
*	start coming immediately afterwards.  This same routine will change
*	the current state of the GACT_FOLLOWMOUSE function of a
*	currently-selected gadget too.  
*
*	Note that calling ReportMouse() when a gadget is selected will only
*	temporarily change whether or not mouse	movements are reported while
*	that gadget remains selected; the next time the gadget is selected, its
*	GACT_FOLLOWMOUSE flag is examined anew.
*
*	Note also that calling ReportMouse() when no gadget is currently
*	selected will change the state of the window's WFLG_REPORTMOUSE flag,
*	but will have no effect on any gadget that may be subsequently
*	selected. (This is all fixed in V36.)
*
*	The ReportMouse() function is first performed when OpenWindow() 
*	is first called; if the flag WFLG_REPORTMOUSE is included among
*	the options, then all mouse-movement events are reported 
*	to the opening task and will continue to be reported
*	until ReportMouse() is called with a Boolean value of FALSE.
*	If WFLG_REPORTMOUSE is not set, then no mouse-movement reports will
*	be broadcast until ReportMouse() is called with a Boolean of TRUE.
*
*	Note that the WFLG_REPORTMOUSE flag, as managed by this routine,
*	determines IF mouse messages are to be broadcast.  Determining HOW
*	they are to be broadcast is determined by the IDCMP_MOUSEMOVE
*	IDCMPFlag.
*
*    INPUTS
*	Window = pointer to a Window structure associated with this request
*	Boolean = TRUE or FALSE value specifying whether to turn this
*             function on or off
*
*    RESULT
*	None
*
*    BUGS
*	See above
*
*    SEE ALSO
*	The Input and Output section of the Intuition Reference Manual
*****************************************************************************/
d484 2
a485 48
/****** intuition.library/ItemAddress **************************************
*
*    NAME
*	ItemAddress -- Returns the address of the specified MenuItem.
*
*    SYNOPSIS
*	Item = ItemAddress( MenuStrip, MenuNumber )
*	D0		    A0         D0
*
*	struct MenuItem *ItemAddress( struct Menu *, UWORD );
*
*    FUNCTION
*	This routine feels through the specified menu strip and returns the 
*	address of the item specified by the menu number.  Typically,
*	you will use this routine to get the address of a menu item from
*	a menu number sent to you by Intuition after user has chosen from
*	a window's menus.  
*
*       This routine requires that the arguments are well-defined.
*	MenuNumber may be equal to MENUNULL, in which case this routine returns
*	NULL.  If MenuNumber doesn't equal MENUNULL, it's presumed to be a 
*	valid item number selector for your menu strip, which includes:
*           - a valid menu number
*           - a valid item number
*           - if the item specified by the above two components has a
*             sub-item, the menu number may have a sub-item component, too.
*
*	Note that there must be BOTH a menu number and an item number.  
*	Because a sub-item specifier is optional, the address returned by
*	this routine may point to either an item or a sub-item.
*
*    INPUTS
*	MenuStrip = a pointer to the first menu in your menu strip
*	MenuNumber = the value which contains the packed data that selects
*           the menu and item (and sub-item).  See the Intuition Reference
*	    Manual for information on menu numbers.
*
*    RESULT
*	If MenuNumber == MENUNULL, this routine returns NULL,
*	else this routine returns the address of the menu item specified
*	by MenuNumber.
*
*    BUGS
*
*    SEE ALSO
*	The "Menus" chapter of the Intuition Reference Manual,
*	or the Amiga ROM Kernel Manual
*****************************************************************************/
d502 2
a503 41
/****** intuition.library/DoubleClick ****************************************
*
*    NAME
*	DoubleClick -- Test two time values for double-click timing.
*
*    SYNOPSIS
*	IsDouble = DoubleClick( StartSecs, StartMicros,
*	D0                      D0         D1
*		CurrentSecs, CurrentMicros )
*		D2           D3
*
*	BOOL DoubleClick( ULONG, ULONG, ULONG, ULONG );
*
*    FUNCTION
*	Compares the difference in the time values with the double-click 
*	timeout range that the user has set (using the "Preferences" tool) or 
*	some other program has configured into the system.  If the 
*	difference between the specified time values is within the current 
*	double-click time range, this function returns TRUE, else it 
*	returns FALSE.  
*
*       These time values can be found in input events and IDCMP messages.
*       The time values are not perfect; however, they are precise enough for 
*       nearly all applications.
*
*    INPUTS
*	StartSeconds, StartMicros = the timestamp value describing the start of
*          the double-click time period you are considering
*	CurrentSeconds, CurrentMicros = the timestamp value describing 
*          the end of the double-click time period you are considering
*
*    RESULT
*	If the difference between the supplied timestamp values is within the
*	double-click time range in the current set of Preferences, this
*	function returns TRUE, else it returns FALSE
*
*    BUGS
*
*    SEE ALSO
*	CurrentTime()
*****************************************************************************/
d524 2
a525 33
/****** intuition.library/CurrentTime ***************************************
*
*    NAME
*	CurrentTime -- Get the current time values.
*
*    SYNOPSIS
*	CurrentTime( Seconds, Micros )
*		     A0       A1
*
*	VOID CurrentTime( ULONG *, ULONG * );
*
*    FUNCTION
*	Puts copies of the current time into the supplied argument pointers.
*
*	This time value is not extremely accurate, nor is it of a very fine 
*	resolution.  This time will be updated no more than sixty times a
*	a second, and will typically be updated far fewer times a second.
*
*    INPUTS
*	Seconds = pointer to a LONG variable to receive the current seconds
*	    value
*	Micros = pointer to a LONG variable for the current microseconds value
*
*    RESULT
*	Puts the time values into the memory locations specified by the
*	    arguments
*	Return value is not defined.
*
*    BUGS
*
*    SEE ALSO
*	timer.device/TR_GETSYSTIME
*****************************************************************************/
d536 2
a537 28
/****** intuition.library/ViewAddress **************************************
*
*    NAME
*	ViewAddress -- Return the address of the Intuition View structure.
*
*    SYNOPSIS
*	view = ViewAddress()
*	D0
*
*	struct View *ViewAddress( VOID );
*
*    FUNCTION
*	Returns the address of the Intuition View structure.  If you 
*	want to use any of the graphics, text, or animation primitives 
*	in your window and that primitive requires a pointer to a view,
*	this routine will return the address of the view for you.
*
*    INPUTS
*	None
*
*    RESULT
*	Returns the address of the Intuition View structure
*   
*    BUGS
*
*    SEE ALSO
*	graphics.library
*****************************************************************************/
d546 2
a547 35
/****** intuition.library/ViewPortAddress ***********************************
*
*    NAME
*	ViewPortAddress -- Return the address of a window's viewport.
*
*    SYNOPSIS
*	ViewPort = ViewPortAddress( Window )
*	D0                          A0
*
*	struct ViewPort *ViewPortAddress( struct Window * );
*
*    FUNCTION
*	Returns the address of the viewport associated with the specified
*	window.  The viewport is actually the viewport of the screen within
*	which the window is displayed.  If you want to use any of the graphics,
*	text, or animation primitives in your window and that primitive
*	requires a pointer to a viewport, you can use this call.
*
*	This pointer is only valid as long as your window's screen remains
*	open, which is ensured by keeping your window open.
*
*    INPUTS
*	Window = pointer to the window for which you want the viewport address
*
*    RESULT
*	Returns the address of the Intuition ViewPort structure for
*	your window's screen .
*   
*    BUGS
*	This routine is unnecessary: you can just use the expression
*	&Window->WScreen->ViewPort.
*
*    SEE ALSO
*	graphics.library
*****************************************************************************/
d557 2
a558 40
/****** intuition.library/DisplayBeep ****************************************
*
*    NAME
*	DisplayBeep -- Flash the video display.
*
*    SYNOPSIS
*	DisplayBeep( Screen )
*		     A0
*
*	VOID DisplayBeep( struct Screen * );
*
*    FUNCTION
*	"Beeps" the video display by flashing the background color of the
*	specified screen.  If the screen argument is NULL, every screen
*	in the display will be beeped.  Flashing everyone's screen is not
*	a polite thing to do, so this should be reserved for dire
*	circumstances.
*
*	The reason such a routine is supported is because the Amiga has
*	no internal bell or speaker.  When the user needs to know of
*	an event that is not serious enough to require the use of a requester,
*	the DisplayBeep() function may be called.
*
*	New for V36:  Intuition now calls DisplayBeep through the 
*	external library vector.  This means that if you call SetFunction()
*	to replace DisplayBeep with an audible beep, for example, then
*	your change will affect even Intuition's calls to DisplayBeep.
*
*    INPUTS
*	Screen = pointer to a screen.  If NULL, every screen in the display
*           will be flashed
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	
*****************************************************************************/
d707 2
a708 27
/****** intuition.library/ReleaseGIRPort *************************************
*
*    NAME
*	ReleaseGIRPort -- Release a custom gadget RastPort. (V36)
*
*    SYNOPSIS
*	ReleaseGIRPort( RPort )
*			A0
*
*	VOID ReleaseGIRPort( struct RastPort * );
*
*    FUNCTION
*	The corresponding function to ObtainGIRPort(), it releases
*	arbitration used by Intuition for gadget RastPorts.
*
*    INPUTS
*	Pointer to the RastPort returned by ObtainGIRPort().
*	This pointer can be NULL, in which case nothing happens.
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	ObtainGIRPort(), Custom Gadget documentation
*****************************************************************************/
d738 2
a739 35
/****** intuition.library/ObtainGIRPort *************************************
*
*    NAME
*	ObtainGIRPort -- Set up a RastPort for a custom gadget. (V36)
*
*    SYNOPSIS
*	RPort = ObtainGIRPort( GInfo )
*	D0		       A0
*
*	struct RastPort *ObtainGIRPort( struct GadgetInfo * );
*
*    FUNCTION
*	Sets up a RastPort for use (only) by custom gadget hook routines.
*	This function must be called EACH time a hook routine needing
*	to perform gadget rendering is called, and must be accompanied
*	by a corresponding call to ReleaseGIRPort().
*
*	Note that if a hook function passes you a RastPort pointer,
*	e.g., GM_RENDER, you needn't call ObtainGIRPort() in that case.
*
*    INPUTS
*	A pointer to a GadgetInfo structure, as passed to each custom
*	gadget hook function.
*
*    RESULT
*	A pointer to a RastPort that may be used for gadget rendering.
*	This pointer may be NULL, in which case you should do no rendering.
*	You may (optionally) pass a null return value to ReleaseGIRPort().
*
*    BUGS
*
*    SEE ALSO
*	ReleaseGIRPort(), Custom Gadget documentation
*	
*****************************************************************************/
@


38.9
log
@No longer set IBase->APtrHeight.  IPointer and friends are now
DefPointer etc.
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 38.8 92/01/22 16:42:45 peter Exp Locker: peter $
d1349 4
a1352 1
	    if ( IsCompatible( screen ) ) beepGrunt(screen);
d1407 1
a1407 1
	XSC(screen)->PrivateFlags |= PRIVSCF_DELAYBEEP;
@


38.8
log
@Fixed minor autodoc typos.
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 38.7 91/12/12 20:46:34 peter Exp Locker: peter $
d445 1
a445 1
    /* protect against using freed data changed by setDefaultIPointer */
d468 4
a471 4
	IP = IBase->IPointer;
	IPH = IBase->IPtrHeight;
	xoff = IBase->IXOffset;
	yoff = IBase->IYOffset;
d480 1
a480 1
    if ((IBase->IPointer == IP) 	/* new pointer is ours */
d490 1
a490 1
	((IP != IBase->IPointer)||(IBase->AttachedSSprite == NULL)))
a496 1
    IBase->APtrHeight = IPH;
@


38.7
log
@BlastPattern() now turns off the pattern when done.
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 38.6 91/11/15 18:52:59 peter Exp Locker: peter $
d854 1
a854 1
*	ClearPointer(), Intuition Reference Manual or Amiga Rom
d1090 1
a1090 1
*	or the Amiga Rom Kernel Manual
@


38.6
log
@Deleted BLITBYTES() function; now in-line in menu.c.
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 38.5 91/09/23 12:28:16 peter Exp Locker: peter $
d307 2
@


38.5
log
@drawBlock(), drawBox(), printIText(), DrawBorder(), and BlastPattern()
now use SetABPenDrMd().
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 38.4 91/08/21 18:19:24 peter Exp Locker: peter $
a1287 9


SHORT BLITBYTES(left, right)
int left, right;
{
    return(((right & (~0xF)) - (left & (~0xF)) + 16) >> 3);
}


@


38.4
log
@Screen beep now saves 32 bits per gun.
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 38.3 91/07/10 17:58:21 peter Exp Locker: peter $
d304 1
a304 3
    SetAPen(RP, pena);
    SetBPen(RP, penb);
    SetDrMd(RP, mode);
d321 1
a321 2
    SetAPen(rp, apen);
    SetDrMd(rp, mode);
d423 1
a423 1
    SetAPen(rp, apen);
a425 1
    SetDrMd(rp, JAM2);
d673 1
a673 3
	SetAPen(&clonerp, border->FrontPen);
	SetBPen(&clonerp, border->BackPen);
	SetDrMd(&clonerp, border->DrawMode);
d772 1
a772 3
	    SetAPen( &clonerp, itext->FrontPen);
	    SetBPen( &clonerp, itext->BackPen);
	    SetDrMd( &clonerp, itext->DrawMode);
@


38.3
log
@Use SafeRectFill() instead of locally-checked RectFill().
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 38.2 91/06/19 18:05:38 peter Exp Locker: peter $
d1372 21
d1397 1
a1397 1
    UWORD red, green, blue;
d1407 3
a1409 6
	screen->SaveColor0 = color0 
		= ((UWORD *)screen->ViewPort.ColorMap->ColorTable)[0];
	/* Peter: 6-Aug-90
	 * Complementing color0 isn't very good when color0 is gray.
	 * So we set each component to 5 or 12, whichever is more
	 * extreme.
d1411 7
a1417 9
	red = green = blue = 12;
	if ( ( color0 >> 8 ) > 8 )
		red = 5;
	if ( ( ( color0 >> 4 ) & 0x0F ) > 8 )
		green = 5;
	if ( ( color0 & 0x0F ) > 8 )
		blue = 5;
	SetRGB4( &screen->ViewPort, 0, 
		red, green, blue );
@


38.2
log
@Removed obsolete code.
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 38.1 91/06/12 15:11:46 peter Exp Locker: peter $
d308 1
a308 4
    if (!( (left > right) || (top > bottom) ))
    {
	RectFill(RP, left, top, right, bottom);
    }
d431 1
a431 5
    /* jimm: 6/6/90: validity checking for tiny prop gadgets */
    if ( left <= right && up <= down )
    {
	RectFill(rp, left, up, right, down);
    }
@


38.1
log
@Added xorboxmask().  Wrote xorbox() in terms of xorboxmask().
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 36.47 91/02/12 18:16:31 peter Exp Locker: peter $
a18 6
#define SAVESCROLLVALS	1
/* ZZZ: DEBUG: WHY DO I DO THIS?	*/
/* Now we know: we render good whether the guy called ScrollLayer
 * or not.
 */

a307 7
#ifdef TRYANOTHERWAY
    /* bart - 11.18.85 prevent bad inactive dragbar rectfills */
    if (left > right) right = left;
    if (top > bottom) bottom = top;
    /* end bart - 11.18.85 */
    RectFill(RP, left, top, right, bottom);
#else
a311 2
#endif

a801 1
#ifndef NOTMEBABE	/* included 7/22/86 */
a802 3
#else
	Text( &clonerp, itext->IText, strlen(itext->IText));
#endif
a1382 2
#ifdef OLDBEEPCOLOR
#else
a1383 1
#endif
a1394 5
#ifdef OLDBEEPCOLOR
	color0 = ~color0;
	SetRGB4(&screen->ViewPort, 0, 
		(color0 >> 8), (color0 >> 4), color0);
#else
d1409 1
a1409 1
#endif
d1459 3
a1461 1
#if SAVESCROLLVALS	/* ZZZ: DEBUG: WHY DO I DO THIS?	*/
a1466 1
#endif
a1471 4
#ifdef IOWNTMPRAS
    /* jimm: 4/1/86: helps text speed, mem failure */
    IBase->RP->TmpRas = &IBase->ITmpRas;
#else
a1472 1
#endif
d1527 3
a1529 1
#if SAVESCROLLVALS	/* ZZZ: DEBUG: WHY DO I DO THIS?	*/
d1532 1
a1532 1
#endif
@


38.0
log
@Initial V38 check-in (matches V37 release).
@
text
@d6 1
a6 1
 *  $Id: misc.c,v 36.47 91/02/12 18:16:31 peter Exp $
d371 7
a379 2

    rp->Mask = -1;
@
