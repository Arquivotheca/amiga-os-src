head     38.26;
branch   ;
access   ;
symbols  V40_85:38.26 V40_71:38.26 V40_68:38.26 V40_65:38.26 V40_47:38.25 V40_45:38.25 V40_37:38.25 V40_34:38.25 V40_29:38.25 V39_2415:38.24 V39_2369:38.22 V39_2339:38.22 V39_2332:38.22 V39_2275:38.21 V39_2256:38.20 V39_2210:38.19 V39_2192:38.19 V39_2084:38.19 V39_2082:38.19 V39_2076:38.19 V39_2073:38.19 V39_2058:38.18 V39_2051:38.18 V39_2031:38.18 V39_2017:38.18 V39_2012:38.18 V39_1985:38.18 V39_1933:38.18 V39_1819:38.17 V39_1805:38.17 V39_1783:38.17 V39_1695:38.17 V39_1621:38.16 V39_1620:38.16 V39_1508:38.16 V39_1485:38.15 V39_1461:38.15 V39_1458:38.15 V39_1456:38.15 V39_1405:38.14 V39_1368:38.12 V39_1360:38.12 V39_1324:38.12 V39_1147:38.12 V39_1143:38.12 V39_1141:38.12 V39_1120:38.12 V39_1116:38.12 V39_1104:38.12 V39_1100:38.12 V39_1078:38.12 V39_1073:38.12 V39_757:38.10 V39_702:38.10 V39_557:38.10 V39_553:38.10 V39_551:38.10 V39_510:38.9 V39_495:38.9 V39_416:38.9 V39_383:38.9 V39_371:38.9 V39_336:38.9 V39_323:38.8 V39_295:38.8 V39_277:38.7 V39_254:38.6 V39_222:38.3 V39_185:38.3 V39_171:38.3 V39_161:38.3 V38_159:38.3 V38_116:38.2 V38_59:38.0;
locks    ; strict;
comment  @*   @;


38.26
date     93.04.13.22.27.55;  author peter;  state Exp;
branches ;
next     38.25;

38.25
date     93.02.15.18.58.27;  author peter;  state Exp;
branches ;
next     38.24;

38.24
date     93.01.14.14.28.22;  author peter;  state Exp;
branches ;
next     38.23;

38.23
date     93.01.12.16.16.49;  author peter;  state Exp;
branches ;
next     38.22;

38.22
date     92.12.09.18.10.35;  author peter;  state Exp;
branches ;
next     38.21;

38.21
date     92.12.04.11.56.04;  author peter;  state Exp;
branches ;
next     38.20;

38.20
date     92.11.25.15.39.10;  author peter;  state Exp;
branches ;
next     38.19;

38.19
date     92.08.24.11.40.48;  author peter;  state Exp;
branches ;
next     38.18;

38.18
date     92.08.03.15.52.52;  author peter;  state Exp;
branches ;
next     38.17;

38.17
date     92.07.07.15.17.33;  author peter;  state Exp;
branches ;
next     38.16;

38.16
date     92.06.22.12.59.43;  author peter;  state Exp;
branches ;
next     38.15;

38.15
date     92.06.02.14.53.12;  author peter;  state Exp;
branches ;
next     38.14;

38.14
date     92.05.29.18.56.31;  author peter;  state Exp;
branches ;
next     38.13;

38.13
date     92.05.29.18.26.57;  author peter;  state Exp;
branches ;
next     38.12;

38.12
date     92.04.07.17.47.18;  author peter;  state Exp;
branches ;
next     38.11;

38.11
date     92.04.02.12.02.26;  author peter;  state Exp;
branches ;
next     38.10;

38.10
date     92.03.03.16.31.35;  author peter;  state Exp;
branches ;
next     38.9;

38.9
date     92.01.28.12.41.12;  author peter;  state Exp;
branches ;
next     38.8;

38.8
date     91.12.12.20.44.02;  author peter;  state Exp;
branches ;
next     38.7;

38.7
date     91.11.25.16.55.37;  author peter;  state Exp;
branches ;
next     38.6;

38.6
date     91.11.15.18.51.38;  author peter;  state Exp;
branches ;
next     38.5;

38.5
date     91.11.13.16.36.34;  author peter;  state Exp;
branches ;
next     38.4;

38.4
date     91.11.12.16.36.27;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     91.08.21.18.16.06;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     91.07.25.17.04.53;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.07.25.15.01.48;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.12.14.15.16;  author peter;  state Exp;
branches ;
next     ;


desc
@@


38.26
log
@Makes sure scale-factors of all screens are adjusted during coercion
before legalizing screen position (which, for attached screens, can
depend on scale factors of more than one screen).
@
text
@
/*** coercion.c ***************************************************************
 *
 *  coercion.c -- new chips modes, mixed modes, gfx database
 *
 *  $Id: coercion.c,v 38.25 93/02/15 18:58:27 peter Exp Locker: peter $
 *
 *  Confidential Information: Commodore-Amiga, Inc.
 *  Copyright (c) 1989, Commodore-Amiga, Inc.
 *
 ****************************************************************************/

#include "intuall.h"
#include "preferences.h"

#define DX(x)	;	/* Exclusive screens */
#define D(x) 	;
#define DC(x) 	;	/* coercion		*/
#define DID(x)	;
#define DSDID(x)	;
#define DSNOOP(x)	;
#define DPANIC(x)	;

#ifndef GRAPHICS_DISPLAY_H
#include <graphics/display.h>
#endif

#ifndef GRAPHICS_COERCE_H
#include <graphics/coerce.h>
#endif

#ifndef GRAPHICS_DISPLAYINFO_H
#include <graphics/displayinfo.h>
#endif

/*
 * sets up everything that needs to be changed when the
 * active monitor switches, including scale factors,
 * coercion/exclusion, view position, ...
 * 'force' is as follows:
 * MEGAFORCE is expected if the monitor changed
 * FORCE is expected if someone upstream asked for FORCE (that would be
 *	if we came from RemakeDisplay() or initIntuition())
 * NOFORCE is expected if just the INTERLACE state changed.
 */
setupMonitor( force )
{
    struct IntuitionBase	*IBase = fetchIBase();

    /* WARNING: ActiveMonitorSpec was setup in monitorCheck().
     * Copy it to ViewLord now
     */
    IBase->ViewExtra->Monitor = IBase->ActiveMonitorSpec;
    SETFLAG( IBase->ViewLord.Modes, EXTEND_VSTRUCT );

    DSNOOP( printf("setupMonitor coercing all\n") );

    coerceScreens( NULL, force );	/* setup all screens for new monitor */
}


/*
 * establishes coerced screen mode information, and performs
 * scale distortions for mixed-mode screens.
 *
 * if 'onescreen' is non-NULL, then setup the mode
 * information for just this screen, else all.
 *
 * 'force' is as follows:
 * Reset view-poker tracking if MEGAFORCE
 * Rethink coercion if FORCE or MEGAFORCE
 *
 */
coerceScreens( onescreen, force )
struct Screen	*onescreen;
{
    struct IntuitionBase	*IBase = fetchIBase();
    struct MonitorInfo		minfo;
    struct Screen		*screen;
    /* gotten from monitor for frontmost screen */
    ULONG			frontid = 0;

    D( printf("\ncoerceScreens 'onescreen' %lx\n", onescreen ));

    /**************************************************************
     * Get monitor information on frontmost screen (if none: lores)
     **************************************************************/
    D( printf("coerceScreens: get frontmost info\n") );
    if ( GDID( IBase->FirstScreen? XSC(IBase->FirstScreen)->NaturalDRecord: 0,
		&minfo, sizeof( minfo ), DTAG_MNTR, 0  ) )
    {
	/* information that each screen will need to know */
	frontid = MONITOR_PART( minfo.Header.DisplayID );

	/* reset view only if we had a monitor change */
	if ( force > FORCE )
	{
	    /* Reset this upon coercion, to force tablet guys
	     * to re-inquire about screen parameters:
	     */
	    IBase->LastTabletScreen = NULL;

	    /* set view position for active monitor */
	    IBase->TrackViewDx = IBase->ViewLord.DxOffset =
		minfo.ViewPosition.x;
	    IBase->TrackViewDy = IBase->ViewLord.DyOffset =
		minfo.ViewPosition.y;

	    /* MouseScaleX and MouseScaleY are the ticks to move per
	     * IECLASS_RAWMOUSE unit, subject to acceleration and
	     * speed-scaling.  The idea is that these numbers are
	     * almost constants, but slightly tuned to be an exact
	     * multiple of pixel dimensions of that monitor's modes.
	     * Starting with the 3.01 monitors, these numbers are
	     * available from the graphics database, but prior to
	     * that, we have a kludgy little thing in Intuition
	     * to guess the mouse scales.
	     */
	    
#if 0
	    IBase->MouseScaleX = minfo.MouseTicks.x;
	    IBase->MouseScaleY = minfo.MouseTicks.y;
#else
	    IBase->MouseScaleX = *((WORD *)&minfo.pad[32]);
	    IBase->MouseScaleY = *((WORD *)&minfo.pad[34]);
#endif

	    if ( !IBase->MouseScaleY )
	    {
		IBase->MouseScaleX = MOUSESCALEX;
		/* MouseScaleY is variable, depending on the active monitor.
		 * We note that PAL_MOUSESCALEY=VGA_MOUSESCALEY<NTSC_MOUSESCALEY,
		 * and that for unknown modes, smaller is better (fewer or no
		 * skipped pixels that way).  So let's default to this number.
		 */
		IBase->MouseScaleY = PAL_MOUSESCALEY;

		switch ( frontid )
		{
		case NTSC_MONITOR_ID:
		case DBLNTSC_MONITOR_ID:
		    /* Use NTSC mouse scale factor */
		    IBase->MouseScaleY = NTSC_MOUSESCALEY;
		    break;

		case DEFAULT_MONITOR_ID:
		case A2024_MONITOR_ID:
		    /* For NTSC machines, use NTSC, else use PAL. */
		    if ( !TESTFLAG( IBase->Flags, MACHINE_ISPAL ) )
		    {
			IBase->MouseScaleY = NTSC_MOUSESCALEY;
		    }
		    break;
#if 0
		case PAL_MONITOR_ID:
		case EURO36_MONITOR_ID:
		case VGA_MONITOR_ID:
		case EURO72_MONITOR_ID:
		case DBLPAL_MONITOR_ID:
		case SUPER72_MONITOR_ID:	/* Actual scale should be 17x20, but oh well */
		    /* We already have the right value, PAL_MOUSESCALEY,
		     * or equivalently, VGA_MOUSESCALEY
		     */
		    break;
#endif
		}
	    }

	    IBase->EffectiveScaleFactor.X = IBase->MouseScaleX /
		IBase->Preferences->PointerTicks;
	    IBase->EffectiveScaleFactor.Y = IBase->MouseScaleY /
		IBase->Preferences->PointerTicks;
	}
	else
	{
	    /*  Get the new view info into the database and IBase->TrackView */
	    trackViewPos();
	}
    }
    D( else printf("sM: can't get monitor info!\n") );

    /************************************************************
     * set up each screen's mode-specific information
     ************************************************************/

    /* Peter 15-Nov-91:  New: NOFORCE means don't re-figure coercion.
     * Most old callers want to use FORCE instead of NOFORCE now.
     * This is to avoid re-figuring coercion when screen dragging
     * changes the INTERLACE state of the ViewLord.
     */
    if ( force != NOFORCE )
    {
	struct Screen *firstscreen = onescreen;
	int loop = FALSE;
	if ( !firstscreen )
	{
	    firstscreen = IBase->FirstScreen;
	    loop = TRUE;
	}
	D( else printf("coerceScreens: screen/onescreen %lx\n", onescreen ) );

	screen = firstscreen;
	while ( screen )
	{
	    D( printf("coerceScreens, screen: %lx\n", screen ) );
	    coerceScreenGrunt( screen, frontid );
	    screen = screen->NextScreen;
	    if ( !loop )
	    {
		screen = NULL;
	    }
	}

	screen = firstscreen;
	while ( screen )
	{
	    struct Rectangle legal_positions;

	    D( printf("coerceScreens, legalizing screen: %lx\n", screen ) );
	    if ( !TESTFLAG( screen->Flags, SCREENHIDDEN ) )
	    {
		/************************************************************
		 * validate screen position for this monitor
		 ************************************************************/
		D( dumpPt("original sLP", *((struct Point *) &screen->LeftEdge)) );
		screenLegalPosition( screen, &legal_positions, 0 );
		limitPoint( &screen->LeftEdge, &legal_positions);
		/* Ordinarily, a coercion is followed by a RethinkDisplay()
		 * in which the active monitor changes.  This causes a MEGAFORCE
		 * level processing, which causes the VP Dx/yOffsets to be
		 * derived from the screen Left/Top.  When not MEGAFORCE,
		 * the screen Left/Top are actually slaved to changes to the
		 * vp Dx/DyOffsets, which is needed to support some overscan
		 * techniques of old.  The problem here is that the user
		 * can change coercion preferences and cause a screen to be
		 * moved into screenLegalPosition(), without a MEGAFORCE
		 * remake happening.  But we need the VP coordinates to
		 * slave to the screen coordinates in that case, so we set
		 * the PSF_NEWSCREENOFFSETS flag to demand that.
		 */
		SETFLAG( XSC(screen)->PrivateFlags, PSF_NEWSCREENOFFSETS );
		D( dumpRect( "legal positions", &legal_positions ) );
		D( dumpPt("new sLP", *((struct Point *)&screen->LeftEdge)) );
	    }
	    screen = screen->NextScreen;
	    if ( !loop )
	    {
		screen = NULL;
	    }
	}
    }

    D( printf("cS: done: do updateMousePointer\n") );

    updateMousePointer(NULL);  /* jimm: 2/22/89: pointer jumping on monitor switch */
}

/*
 * Set NaturalDisplayID to INVALID_ID before calling for initial
 * screen setup, or I might close your monitor.
 *
 * after using this and setting up DClip, call coerceScreens()
 *
 * returns 0 if OK, else, errorcode (also will be copied
 * to ecodeptr );
 *
 * Peter 29-May-92: The new force parameter is used to handle
 * coercion.  If force is set, then we re-do the database
 * inquiries for this screen, because promotion might have
 * changed the mapping of the default monitor.
 */
setScreenDisplayID( sc, displayID, ecodeptr, force )
struct Screen	*sc;
ULONG		displayID;
ULONG		*ecodeptr;
{
    ULONG		errorcode = 0;
    CPTR		drecord;
    CPTR		FindDisplayInfo();
    struct MonitorSpec	*displayMonitorSpec();
    union {
	struct DisplayInfo	dinfo;
	struct MonitorInfo	minfo;
    } di;

    DSDID( printf("setScreenDID, sc %lx, displayID %lx, ecodeptr %lx\n",
	sc, displayID, ecodeptr ) );

    /* see if we know this mode	*/
    if ( !( drecord = FindDisplayInfo( displayID ) ) 
	|| ! GDID( drecord, &di.dinfo, sizeof( di.dinfo ), DTAG_DISP )  )
    {
	DSDID( printf("OS: can't find display ID: %lx\n", displayID ) );
	errorcode = OSERR_UNKNOWNMODE;
    }
    else
    {
	UWORD notavail = di.dinfo.NotAvailable;

	/* get some data out of the DisplayInfo record	*/
	DSDID( printf("sSDID: found drecord at %lx\n", drecord ) );

	if ( notavail )
	{
	    /* General "unavailable" code, overridden in more
	     * specific cases.
	     */
	    errorcode = OSERR_NOTAVAILABLE;
	    if ( TESTFLAG( notavail, DI_AVAIL_NOMONITOR ) )
	    {
		errorcode = OSERR_NOMONITOR;
	    }
	    if ( TESTFLAG( notavail, DI_AVAIL_NOCHIPS ) )
	    {
		errorcode = OSERR_NOCHIPS;
	    }
	}
#if 1
	/* need safe initial values in here */
	/* ZZZ: maybe not, if coerceScreens moves to IOpenScreen() */
	XSC(sc)->ScaleFactor.X = di.dinfo.Resolution.x;
	XSC(sc)->ScaleFactor.Y = di.dinfo.Resolution.y;
	XSC(sc)->PixelSpeed = di.dinfo.PixelSpeed;
#endif
	/* This denotes the initial call to setScreenDisplayID(),
	 * from within the bowels of OpenScreen()...
	 */
	if ( XSC(sc)->NaturalDisplayID == INVALID_ID )
	{
	    /* Since the DClip was created based on the initial
	     * mode, we need to store the scale-factor of that
	     * mode.  Before promotion existed, we used to just
	     * ask the database what that resolution was.  But
	     * now, the scale factor of the default mode can
	     * change as promotion changes the default monitor.
	     * So we remember the initial one, for use in scaling
	     * dclips, down in coercion.c/coerceScreenGrunt()
	     */
	    XSC(sc)->InitialScaleFactor.X = di.dinfo.Resolution.x;
	    XSC(sc)->InitialScaleFactor.Y = di.dinfo.Resolution.y;
	}

	/* jimm: 5/11/90: I need these for DUALPF, and
	 * probably other things ...
	 */
	XSC(sc)->NaturalDProperties = di.dinfo.PropertyFlags;

	/* determine image resolution (from two choices)
	 * ZZZ: this should be fancied up
	 */
	if ( di.dinfo.Resolution.x <= MOUSESCALEX )
	{
	    DSDID( printf("setting SCREENHIRES\n") );
	    SETFLAG( sc->Flags, SCREENHIRES);
	}
	else
	{
	    CLEARFLAG( sc->Flags, SCREENHIRES);
	}

	/* check to see if monitor change is being requested */
	if ( ( force ) ||
	    ( MONITOR_PART( XSC(sc)->NaturalDisplayID ) != MONITOR_PART( displayID ) ) )
	{
	    DSDID( printf("setScreenDisplayID: changing monitor %lx/%lx\n",
		XSC(sc)->NaturalDisplayID, displayID ) );

	    /* now use di. to get MonitorInfo	*/
	    if ( GDID( drecord, &di.minfo, sizeof (di.minfo), DTAG_MNTR ) )
	    {
		/* install official new monitor */
		XSC(sc)->NaturalMSpec = di.minfo.Mspc;

		/* Peter 28-Jan-92: We now have draggable Hedley screens,
		 * but they can't be dragged down below the DClip.  Such
		 * an operation doesn't make sense for MCOMPAT_NOBODY
		 * screens, so we note that property here, to pick it
		 * up later as needed.
		 */
		CLEARFLAG( XSC(sc)->PrivateFlags, PSF_INCOMPATIBLE );
		if ( di.minfo.Compatibility == MCOMPAT_NOBODY )
		{
		    SETFLAG( XSC(sc)->PrivateFlags, PSF_INCOMPATIBLE );
		}
	    }
	    else
	    {
		DSDID( printf("DTAG_MNTR failed\n") );
		errorcode = OSERR_UNKNOWNMODE;
	    }
	}

	/* setup official mode stuff */
	XSC(sc)->NaturalDRecord = drecord;
	XSC(sc)->NaturalDisplayID = displayID;

	/* set up "artifact" in viewport Modes */
	sc->ViewPort.Modes =
	    (XSC(sc)->NaturalDisplayID & 0xffff) | SPRITES;
	XSC(sc)->VPModeStash = sc->ViewPort.Modes & OLD_MODES;

	DSNOOP( printf("set mode stash for %lx to %lx\n",
	    sc, XSC(sc)->VPModeStash ) );

	/* tell graphics */
	VideoControlTags( XSC(sc)->ColorMap, 
		    VTAG_NORMAL_DISP_SET,	drecord,
		    /* jimm: 5/30/90: stash ID "alias"	*/
		    VTAG_VPMODEID_SET,		displayID,
		    TAG_DONE );
    }

    /* copy over ecodeptr only if trouble */
    if (errorcode && ecodeptr)
    {
	*ecodeptr = errorcode;
    }
    DSDID( printf("sSDID: return %lx\n", errorcode ) );
    DSDID( kpause( "end of sSDID\n") );
    return ( errorcode );
}


/*
 * sets up everything implied by the screen mode.
 * assumes these are correct in the screen:
 *	NaturalDRecord
 *	NaturalDisplayID
 *	ColorMap
 *	DClip		(in natural native pixel coord's)
 *	position	(but will be validated here)
 */
coerceScreenGrunt( s, frontmonitor )
struct Screen		*s;
ULONG			frontmonitor;
{
    struct IntuitionBase	*IBase = fetchIBase();
    /* buffer shared by several GDID calls	*/
    /* be careful out there ...			*/
    union {
	struct MonitorInfo		minfo;
	struct DisplayInfo		dinfo;
    } di;
    ULONG			coercion_flags;
    ULONG			coerced_mode;

    /************************************************************
     * coerce: set up current DRecord (for scale factors 
     * and mouse transformations) and setup current monitor spec.
     ************************************************************/

    /* We take advantage of the fact that the two coercion control
     * flags from IControl match (by design) the same properties
     * in the graphics CoerceMode() function.
     *
     * We don't pass the PROMOTE flag, because that's handled through
     * a different mechanism, and really only applies to the front screen.
     */

    coercion_flags = ( IBase->NewIControl & ( AVOID_FLICKER | PRESERVE_COLORS ) );

#ifndef IGNORE_MCOMPAT
#define IGNORE_MCOMPAT 4
#endif

    /* Ask graphics what to coerce this mode to.  Ordinarily,
     * CoerceMode() will handle exclusion based on MCOMPAT_xxx, returning
     * INVALID_ID for incompatible modes.  For the front screen, we
     * have to ask graphics to ignore compatibility relationships,
     * since it'll always be visible, so we pass the IGNORE_MCOMPAT flag.
     * You might think that calling CoerceMode() on the front screen
     * is a do-nothing operation (coercing to match its own monitor),
     * but in fact it detects when the BitMap is not properly aligned,
     * and in that case returns a lower resolution of that monitor.
     */
    if ( s == IBase->FirstScreen )
    {
	coercion_flags |= IGNORE_MCOMPAT;
    }
    coerced_mode = CoerceMode( &s->ViewPort, frontmonitor,
	coercion_flags );

    /* If the first screen or this screen is SA_Exclusive,
     * then this screen needs to be excluded, unless they're
     * of the same family (in which case it's an exclusive family).
     * NB: We can't be here if IBase->FirstScreen is NULL,
     * so not to worry!
     */
    if ( ( TESTFLAG( XSC(IBase->FirstScreen)->PrivateFlags, PSF_EXCLUSIVE ) ||
       TESTFLAG( XSC(s)->PrivateFlags, PSF_EXCLUSIVE ) ) &&
       ( screenFamily( IBase->FirstScreen ) != screenFamily( s ) ) )
    {
	DX( printf( "Screen %lx excluded due to SA_Exclusive\n", s ) );
	coerced_mode = INVALID_ID;
    }

    D( printf("natural drecord %lx, coerced ID: %lx\n", 
	XSC(s)->NaturalDRecord, coerced_mode ) );

    /* Look, we're compatible with the front screen! */
    if ( coerced_mode != INVALID_ID )
    {
	ULONG coerced_drecord;

	/************************************************************
	 * poof: you appear
	 ************************************************************/
	D( printf("do not hide screen: %lx\n", s ) );
	CLEARFLAG( s->Flags, SCREENHIDDEN );   

	coerced_drecord = FindDisplayInfo( coerced_mode );

	/* tell graphics about the coerced display mode	*/
	D( printf("coerceScreens: do VCT ... ") );
	VideoControlTags( XSC(s)->ColorMap, 
		VTAG_COERCE_DISP_SET, coerced_drecord,
		TAG_DONE );
	D( printf("coerceScreens: done VCT\n") );

	/************************************************************
	 * get scale resolution, other stuff from DisplayInfo
	 ************************************************************/
	if (GDID(coerced_drecord, &di.dinfo, sizeof(di.dinfo), DTAG_DISP ))
	{
	    XSC(s)->ScaleFactor.X = di.dinfo.Resolution.x;
	    XSC(s)->ScaleFactor.Y = di.dinfo.Resolution.y;
	    XSC(s)->PixelSpeed = di.dinfo.PixelSpeed;
	    XSC(s)->SpriteRes.X = di.dinfo.SpriteResolution.x;
	    XSC(s)->SpriteRes.Y = di.dinfo.SpriteResolution.y;

	    XSC(s)->DProperties = di.dinfo.PropertyFlags;

	    XSC(s)->SpriteFactor.X = ( di.dinfo.SpriteResolution.x * SPRITEMULT_X ) /
		XSC(s)->ScaleFactor.X;
	    XSC(s)->SpriteFactor.Y = ( di.dinfo.SpriteResolution.y * SPRITEMULT_Y ) /
		XSC(s)->ScaleFactor.Y;
	}
	DPANIC( else printf("PANIC:  can't get displayinfo in sDID\n") );
	/* ZZZ: else panic */

	/* Start with the natural DClip.  Scale it based on the
	 * initial resolution and the coerced resolution.
	 */
	XSC(s)->VPExtra->DisplayClip = XSC(s)->DClip;
	scaleConversion( &XSC(s)->VPExtra->DisplayClip.MinX,
	    XSC(s)->InitialScaleFactor, XSC(s)->ScaleFactor );
	scaleConversion( &XSC(s)->VPExtra->DisplayClip.MaxX,
	    XSC(s)->InitialScaleFactor, XSC(s)->ScaleFactor );

	D( dumpRect( "new DClip", &XSC(s)->VPExtra->DisplayClip ) );
    }
    else
    {
	/************************************************************
	 * this screen is hereby invisible by decree
	 ************************************************************/
	D( printf("SCREEN HIDDEN: %lx\n", s ) );
	SETFLAG( s->Flags, SCREENHIDDEN );   
    }
}
@


38.25
log
@No longer Open/CloseMonitor().  Fix for misaligned promoted screens.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.24 93/01/14 14:28:22 peter Exp Locker: peter $
d193 3
a195 1
	if ( onescreen )
d197 52
a248 10
	    D( printf("coerceScreens: screen/onescreen %lx\n", onescreen ) );
	    coerceScreenGrunt( onescreen, frontid );
	}
	else	/* all screens */
	{
	    for ( screen = IBase->FirstScreen; screen; screen = screen->NextScreen )
	    {
		D( printf("coerceScreens, screen: %lx\n", screen ) );

		coerceScreenGrunt( screen, frontid );
a443 1
    struct Rectangle		legal_positions;
a550 26

	/************************************************************
	 * validate screen position for this monitor
	 ************************************************************/
	D( dumpPt("original sLP", *((struct Point *) &s->LeftEdge)) );

	screenLegalPosition( s, &legal_positions, 0 );
	limitPoint( &s->LeftEdge, &legal_positions);

	/* Ordinarily, a coercion is followed by a RethinkDisplay()
	 * in which the active monitor changes.  This causes a MEGAFORCE
	 * level processing, which causes the VP Dx/yOffsets to be
	 * derived from the screen Left/Top.  When not MEGAFORCE,
	 * the screen Left/Top are actually slaved to changes to the
	 * vp Dx/DyOffsets, which is needed to support some overscan
	 * techniques of old.  The problem here is that the user
	 * can change coercion preferences and cause a screen to be
	 * moved into screenLegalPosition(), without a MEGAFORCE
	 * remake happening.  But we need the VP coordinates to
	 * slave to the screen coordinates in that case, so we set
	 * the PSF_NEWSCREENOFFSETS flag to demand that.
	 */
	SETFLAG( XSC(s)->PrivateFlags, PSF_NEWSCREENOFFSETS );

	D( dumpRect( "legal positions", &legal_positions ) );
	D( dumpPt("new sLP", *((struct Point *)&s->LeftEdge)) );
@


38.24
log
@coerceScreens() wasn't updating EffectiveScaleFactor.X, needed to
support changing MouseScaleX.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.23 93/01/12 16:16:49 peter Exp Locker: peter $
a236 1
    struct MonitorSpec	*OpenMonitor();
a326 17
		/* open new monitor, close old */
		/* ZZZ: assume success because GDID worked? */
		OpenMonitor( NULL, displayID );

		/* close old monitor, only if it's for real */
		if ( XSC(sc)->NaturalDisplayID != INVALID_ID )
		{
		    DSDID( printf("closing intial monitor %lx\n",
			XSC(sc)->NaturalDisplayID ) );

		    /* This is probably right, but since it's a no-op,
		     * why risk it? ZZZ: reinstall this and double check
		     */
		    /* ok, going for it */
		    CloseMonitor( XSC(sc)->NaturalMSpec );
		}

d419 13
a431 4
    /* We must never ask graphics about coercing the front screen.
     * That's because graphics can't know about "front screens",
     * so it'll think that an MCOMPAT_NOBODY screen is excluded,
     * regardless of where it is.  So we just take its NaturalDisplayID:
d433 1
a433 2
    coerced_mode = XSC(s)->NaturalDisplayID;
    if ( s != IBase->FirstScreen )
d435 4
a438 6
	/* Ask graphics what to coerce this mode to.  Graphics
	 * will also handle exclusion based on MCOMPAT_xxx.
	 * Incompatible modes come back as mode INVALID_ID.
	 */
	coerced_mode = CoerceMode( &s->ViewPort, frontmonitor,
	    coercion_flags );
d440 12
a451 13
	/* If the first screen or this screen is SA_Exclusive,
	 * then this screen needs to be excluded, unless they're
	 * of the same family (in which case it's an exclusive family).
	 * NB: We can't be here if IBase->FirstScreen is NULL,
	 * so not to worry!
	 */
	if ( ( TESTFLAG( XSC(IBase->FirstScreen)->PrivateFlags, PSF_EXCLUSIVE ) ||
	   TESTFLAG( XSC(s)->PrivateFlags, PSF_EXCLUSIVE ) ) &&
	   ( screenFamily( IBase->FirstScreen ) != screenFamily( s ) ) )
	{
	    DX( printf( "Screen %lx excluded due to SA_Exclusive\n", s ) );
	    coerced_mode = INVALID_ID;
	}
@


38.23
log
@IBase->MouseScaleX replaces MOUSESCALEX.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.22 92/12/09 18:10:35 peter Exp Locker: peter $
d169 2
@


38.22
log
@Now support families of exclusive screens.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.21 92/12/04 11:56:04 peter Exp Locker: peter $
d109 9
a117 4
	    /* MouseScaleY is variable, depending on the active monitor.
	     * We note that PAL_MOUSESCALEY=VGA_MOUSESCALEY<NTSC_MOUSESCALEY,
	     * and that for unknown modes, smaller is better (fewer or no
	     * skipped pixels that way).  So let's default to this number.
d119 8
a126 1
	    IBase->MouseScaleY = PAL_MOUSESCALEY;
d128 1
a128 1
	    switch ( frontid )
d130 7
a136 5
	    case NTSC_MONITOR_ID:
	    case DBLNTSC_MONITOR_ID:
		/* Use NTSC mouse scale factor */
		IBase->MouseScaleY = NTSC_MOUSESCALEY;
		break;
d138 1
a138 4
	    case DEFAULT_MONITOR_ID:
	    case A2024_MONITOR_ID:
		/* For NTSC machines, use NTSC, else use PAL. */
		if ( !TESTFLAG( IBase->Flags, MACHINE_ISPAL ) )
d140 3
d144 10
a153 2
		}
		break;
d155 10
a164 10
	    case PAL_MONITOR_ID:
	    case EURO36_MONITOR_ID:
	    case VGA_MONITOR_ID:
	    case EURO72_MONITOR_ID:
	    case DBLPAL_MONITOR_ID:
	    case SUPER72_MONITOR_ID:	/* Actual scale should be 17x20, but oh well */
		/* We already have the right value, PAL_MOUSESCALEY,
		 * or equivalently, VGA_MOUSESCALEY
		 */
		break;
d166 1
a166 1

@


38.21
log
@DBLNTSC monitor now defaults to the correct MouseScaleY.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.20 92/11/25 15:39:10 peter Exp Locker: peter $
d429 2
a430 1
	 * then this screen needs to be excluded.
d434 3
a436 2
	if ( ( TESTFLAG( XSC(IBase->FirstScreen)->PrivateFlags, PSF_EXCLUSIVE ) ) ||
	   ( TESTFLAG( XSC(s)->PrivateFlags, PSF_EXCLUSIVE ) ) )
@


38.20
log
@Now request syncing up of ViewPort positions when coercion moves a
screen.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.19 92/08/24 11:40:48 peter Exp Locker: peter $
d119 1
d134 1
d136 3
a138 2
	    case VGA70_MONITOR_ID:
	    case PAL70_MONITOR_ID:
@


38.19
log
@Modes unavailable for reasons other than no chips or no monitor now cause
OpenScreen() to fail.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.18 92/08/03 15:52:52 peter Exp Locker: peter $
d500 13
a512 2
	/* the vp position will be sync'd to the screen
	 * position, when we want, in rethinkVPorts( MEGAFORCE );
d514 1
@


38.18
log
@Uses SPRITEMULT instead of SPRITEFACTOR.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.17 92/07/07 15:17:33 peter Exp Locker: peter $
d228 2
d233 15
a247 5
	/* see if the mode is available	*/
	if ( di.dinfo.NotAvailable & DI_AVAIL_NOMONITOR )
	    errorcode = OSERR_NOMONITOR;
	if ( di.dinfo.NotAvailable & DI_AVAIL_NOCHIPS )
	    errorcode = OSERR_NOCHIPS;
@


38.17
log
@Now clear LastTabletScreen upon big remake.  Recalculate
EffectiveScaleFactor when MouseScaleY changes.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.16 92/06/22 12:59:43 peter Exp Locker: peter $
d462 1
a462 1
	    XSC(s)->SpriteFactor.X = ( di.dinfo.SpriteResolution.x << SPRITEFACTOR_X ) /
d464 1
a464 1
	    XSC(s)->SpriteFactor.Y = ( di.dinfo.SpriteResolution.y << SPRITEFACTOR_Y ) /
@


38.16
log
@SpriteFactor.Y is now exaggerated by a factor of two, to allow scaling
down, too.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.15 92/06/02 14:53:12 peter Exp Locker: peter $
d98 5
d143 3
@


38.15
log
@Now remembers y sprite res too.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.14 92/05/29 18:56:31 peter Exp Locker: peter $
d456 2
a457 2
	    XSC(s)->SpriteFactor.Y =
		di.dinfo.SpriteResolution.y / XSC(s)->ScaleFactor.Y;
@


38.14
log
@Structure copy into InitialScaleFactor no longer possible.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.13 92/05/29 18:26:57 peter Exp Locker: peter $
d449 2
a450 1
	    XSC(s)->SpriteResX = di.dinfo.SpriteResolution.x;
@


38.13
log
@Horizontal scaling of pointer hot-spot now handled.  The
setScreenDisplayID() function now takes a force parameter which is
used for promotion.  This parameter asks sSDID() to redo the database
inquiries.  Other changes to handle new style of promotion.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.12 92/04/07 17:47:18 peter Exp Locker: peter $
d249 2
a250 1
	    XSC(sc)->InitialScaleFactor = di.dinfo.Resolution;
@


38.12
log
@Calls updateMousePointer() with NULL.  VideoControlTags() stub now
comes from ROM lib.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.11 92/04/02 12:02:26 peter Exp Locker: peter $
a15 1
#define DP(x)	;	/* Promotion */
d89 1
a89 1
    if ( GDID( IBase->FirstScreen? XSC(IBase->FirstScreen)->PromotedDRecord: 0,
d180 1
a180 1
 * Set displayID to INVALID_ID before calling for initial
d187 5
d193 1
a193 1
setScreenDisplayID( sc, displayID, ecodeptr )
d235 16
d271 2
a272 1
	if ( MONITOR_PART(XSC(sc)->NaturalDisplayID)!=MONITOR_PART(displayID))
a289 4
		    /* THIS IS WRONG **
		     CloseMonitor( NULL, XSC(sc)->NaturalDisplayID );
		     ***/

d383 2
a384 2
     * We don't pass the PROMOTE flag, because that's only used for
     * the front screen.
d392 1
a392 3
     * regardless of where it is.  So we just take the promoted
     * DisplayID (which is the NaturalDisplayID when promotion is
     * off.
d394 1
a394 1
    coerced_mode = XSC(s)->PromotedDisplayID;
d448 1
d452 2
a453 2
	    XSC(s)->SpriteFactor.X =
		di.dinfo.SpriteResolution.x / XSC(s)->ScaleFactor.X;
d461 1
a461 1
	 * natural resolution and the coerced resolution.
d464 6
a469 8
	if (GDID(XSC(s)->NaturalDRecord, &di.dinfo, sizeof(di.dinfo), DTAG_DISP ))
	{
	    scaleConversion( &XSC(s)->VPExtra->DisplayClip.MinX,
		di.dinfo.Resolution, XSC(s)->ScaleFactor );
	    scaleConversion( &XSC(s)->VPExtra->DisplayClip.MaxX,
		di.dinfo.Resolution, XSC(s)->ScaleFactor );
	    D( dumpRect( "new DClip", &XSC(s)->VPExtra->DisplayClip ) );
	}
a493 83

/* Routine that figures out what the promoted monitor and mode
 * of this screen is, based on promotion preferences and this screen's
 * attributes.
 *
 * Here's a little bit on how promotion works:
 * Inside graphics.library, promotion can easily be confused with
 * coercion, since at that level, the same stuff is happening, namely
 * bringing up viewports in different modes.
 * At the Intuition level, there is a difference.
 * Coercion = showing the non-frontmost screens in a mode compatible
 * with the frontmost one, as opposed to not being able to show those
 * screens at all.  A screen, when frontmost, is visible in its
 * natural mode.
 * Promotion = substituting a suitable (say VGA) mode for the natural
 * mode, for the frontmost screen.  The other screens are then coerced
 * to match.  When promotion is enabled, the user cannot restore a
 * screen to its natural mode by bringing it to front.
 *
 * Here's what we do:  The XScreen structure now stores the
 * PromotedDisplayID, PromotedMSpec, and PromotedDRecord fields.
 * This routine calculates those fields based on the corresponding
 * "natural" values of this screen, and the promotion modes in effect.
 * Intuition uses the promoted values for the front screen in place of
 * the natural values, as appropriate.  The promoted values for
 * non-frontmost screens are ignored.  The natural values for a screen
 * (even the frontmost) are used in some places.
 */
promoteScreen( sc )
struct Screen *sc;
{
    struct IntuitionBase *IBase = fetchIBase();
    struct MonitorInfo minfo;
    ULONG promoted_mode;
    ULONG promoted_drecord;

    DP( printf("\npS: promoting screen %lx\n", sc ) );
    /* By default, we have no promotion.  We just use natural values.
     * Only if the user asks for it, and everything succeeds,
     * do we override.
     */
    XSC(sc)->PromotedMSpec = XSC(sc)->NaturalMSpec;
    XSC(sc)->PromotedDRecord = XSC(sc)->NaturalDRecord;
    XSC(sc)->PromotedDisplayID = XSC(sc)->NaturalDisplayID;
    DP( printf("pS: NaturalMSpec %lx, DRecord %lx, DisplayID %lx\n",
	XSC(sc)->NaturalMSpec, XSC(sc)->NaturalDRecord, XSC(sc)->NaturalDisplayID ) );

    /* Does the user want promotion? */
    if ( TESTFLAG( IBase->NewIControl, IC_MODEPROMOTION ) )
    {
	ULONG coercion_flags;

	/* We take advantage of the fact that the two coercion control
	 * flags from IControl match (by design) the same properties
	 * in the graphics CoerceMode() function.
	 *
	 * We force the PROMOTE flag, because we know the user asked for it.
	 */
	coercion_flags = PROMOTE |
	    ( IBase->NewIControl & ( AVOID_FLICKER | PRESERVE_COLORS ) );

	DP( printf("pS: coercion_flags = %lx\n", coercion_flags ) );
	/* CoerceMode() with the PROMOTE flag set promotes NTSC to
	 * double-NTSC, PAL to double-PAL, and leaves the rest alone
	 */
	if ( ( promoted_mode = CoerceMode( &sc->ViewPort, 0,
	    coercion_flags ) ) != INVALID_ID )
	{
	    DP( printf("ps: promoted_mode %lx\n", promoted_mode ) );
	    if ( ( promoted_drecord = FindDisplayInfo( promoted_mode ) ) &&
		GDID( promoted_drecord, &minfo, sizeof( minfo ), DTAG_MNTR ) )
	    {
		XSC(sc)->PromotedMSpec = minfo.Mspc;
		XSC(sc)->PromotedDRecord = promoted_drecord;
		XSC(sc)->PromotedDisplayID = promoted_mode;

		DP( printf("pS: PromotedMSpec %lx, DRecord %lx, DisplayID %lx\n",
		    XSC(sc)->PromotedMSpec, XSC(sc)->PromotedDRecord, XSC(sc)->PromotedDisplayID ) );
	    }
	}
    }
}

@


38.11
log
@Renamed reportMouse() to updateMousePointer().  No longer includes
gfxbase.h.  Now stores coerced PixelSpeed.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.10 92/03/03 16:31:35 peter Exp Locker: peter $
d177 1
a177 1
    updateMousePointer(FALSE);  /* jimm: 2/22/89: pointer jumping on monitor switch */
a561 8

VideoControlTags( colormap, tag1, data1 )
struct ColorMap	*colormap;
ULONG	tag1, data1;
{
    VideoControl( colormap, &tag1 );
}

@


38.10
log
@Renamed private screen flags.  Renamed SCREENEXCLUDE to SCREENHIDDEN.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.9 92/01/28 12:41:12 peter Exp Locker: peter $
a24 4
#ifndef GRAPHICS_GFXBASE_H
#include <graphics/gfxbase.h>
#endif

d175 1
a175 1
    D( printf("cS: done: do reportMouse\n") );
d177 1
a177 1
    reportMouse(FALSE);  /* jimm: 2/22/89: pointer jumping on monitor switch */
d229 1
d432 1
@


38.9
log
@setScreenDisplayID() now establishes the PRIVSCF_MCOMPAT_NOBODY flag.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.8 91/12/12 20:44:02 peter Exp Locker: peter $
d292 1
a292 1
		CLEARFLAG( XSC(sc)->PrivateFlags, PRIVSCF_MCOMPAT_NOBODY );
d295 1
a295 1
		    SETFLAG( XSC(sc)->PrivateFlags, PRIVSCF_MCOMPAT_NOBODY );
d397 2
a398 2
	if ( ( TESTFLAG( XSC(IBase->FirstScreen)->PrivateFlags, PRIVSCF_EXCLUSIVE ) ) ||
	   ( TESTFLAG( XSC(s)->PrivateFlags, PRIVSCF_EXCLUSIVE ) ) )
d416 2
a417 2
	D( printf("do not exclude screen: %lx\n", s ) );
	CLEARFLAG( s->Flags, SCREENEXCLUDE );   
d478 2
a479 2
	D( printf("SCREEN EXCLUDED: %lx\n", s ) );
	SETFLAG( s->Flags, SCREENEXCLUDE );   
@


38.8
log
@Added promoteScreen() function.  coerceScreens() now uses
PromotedDRecord to enquire about the front screen.  coerceScreenGrunt()
now takes PromotedDisplayID as the ID of the front screen.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.7 91/11/25 16:55:37 peter Exp Locker: peter $
d285 12
@


38.7
log
@Now get CoerceMode() flags from <graphics/coerce.h> (private
definitions of AVOID_FLICKER and PRESERVE_COLORS, were reversed).
Removed some obsolete code.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.6 91/11/15 18:51:38 peter Exp Locker: peter $
d16 1
d94 1
a94 1
    if ( GDID( IBase->FirstScreen? XSC(IBase->FirstScreen)->NaturalDRecord: 0,
d269 1
a269 1
		    DSDID( printf("closing intial montitor %lx\n",
d345 1
a345 1
    ULONG			coercion_flags = 0;
d353 6
a358 2
    /* Interpret IControl parameters into graphics flags for
     * the CoerceMode() function>
a359 9
    if ( TESTFLAG( IBase->NewIControl, IC_COERCE_LACE ) )
    {
	coercion_flags |= AVOID_FLICKER;
    }

    if ( TESTFLAG( IBase->NewIControl, IC_COERCE_COLORS ) )
    {
	coercion_flags |= PRESERVE_COLORS;
    }
d361 1
a361 10
#if 0
    /* We can't simply pass the PROMOTE bit through.  We'll
     * have to ask graphics for the promoted displayID of the
     * front screen, and coerce the other screens to that.
     */
    if ( TESTFLAG( IBase->NewIControl, IC_MODEPROMOTION ) )
    {
	coercion_flags |= PROMOTE;
    }
#endif
d366 3
a368 2
     * regardless of where it is.  So we just take the natural
     * DisplayID.  (Someday will be the promoted DisplayID).
d370 1
a370 1
    coerced_mode = XSC(s)->NaturalDisplayID;
d468 82
@


38.6
log
@coerceScreens() now distinguishes between FORCE (recalc coercion)
and NOFORCE (don't bother).
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.5 91/11/13 16:36:34 peter Exp Locker: peter $
d32 4
a85 3
#if 1
    WORD			compatibility;
#endif
a161 10
	/* Peter 8-Aug-91: SA_Exclusive excludes other screens */
	compatibility = minfo.Compatibility;

	if ( ( IBase->FirstScreen ) &&
	    TESTFLAG( XSC(IBase->FirstScreen)->PrivateFlags, PRIVSCF_EXCLUSIVE ) )
	{
	    DX( printf( "First screen (%lx) is SA_Exclusive\n", IBase->FirstScreen ) );
	    compatibility = MCOMPAT_NOBODY;
	}

d165 1
a165 2
	    coerceScreenGrunt( onescreen, frontid, 
		    minfo.ViewResolution, compatibility );
d173 1
a173 2
		coerceScreenGrunt( screen, frontid, 
			minfo.ViewResolution, compatibility );
d184 1
a184 1
 * Set displayID to INVALID_ID before calling for intial
a322 2
#define SCALE_DCLIPS	1

d332 1
a332 1
coerceScreenGrunt( s, frontmonitor, frontresolution, compatibility )
a334 2
Point			frontresolution;
WORD			compatibility;
a342 4
#if 0
    Point			viewResolution;
#endif
    WORD			iscompatible;	/* short bool	*/
d344 1
a344 1
    ULONG			coercion_flags;
a346 4
D( printf(" ==\ncoerceScreenGrunt screen %lx, frontmon %lx, compatibilty %lx\n",
	s, frontmonitor, compatibility ) );
    D( dumpPt( "front view resolution \n", frontresolution ) );

a350 3
#ifndef AVOID_FLICKER
#define AVOID_FLICKER	1
#endif
d352 4
a355 5
#ifndef PRESERVE_COLORS
#define PRESERVE_COLORS	2
#endif

    if ( IBase->NewIControl & IC_COERCE_LACE )
d360 1
a360 1
    if ( IBase->NewIControl & IC_COERCE_COLORS )
d365 39
a403 2
    coerced_mode = CoerceMode( &s->ViewPort, frontmonitor,
	coercion_flags );
d408 2
a409 16
    XSC(s)->DRecord = FindDisplayInfo( coerced_mode );

    /* tell graphics about the coerced display mode	*/
    D( printf("coerceScreens: do VCT ... ") );
    VideoControlTags( XSC(s)->ColorMap, 
	    VTAG_COERCE_DISP_SET, XSC(s)->DRecord,
	    TAG_DONE );
    D( printf("coerceScreens: done VCT\n") );

    /************************************************************
     * compatibility testing against active monitor
     ************************************************************/
    iscompatible = 0;	/* start 'false'	*/

    /* get monitor info for possible coerced display */
    if ( GDID( NULL, &di.minfo, sizeof( di.minfo ), DTAG_MNTR, coerced_mode ))
d411 1
a411 71
	/* new 'coerced' monitor spec */
	XSC(s)->MSpec = di.minfo.Mspc;

#if 0
	/* SA_Exclusive screens are only visible if frontmost */
	if ( TESTFLAG( XSC(s)->PrivateFlags, PRIVSCF_EXCLUSIVE ) )
	{
	    iscompatible = ( IBase->FirstScreen == s );
	    DX( printf( "This screen (%lx) is exclusive; iscompatible = %ld\n",
		s, iscompatible ) );
	}
	else
	{
	    /* decide if screen is compatible with frontmost */
	    switch ( compatibility )
	    {
	    case MCOMPAT_SELF:
		/* only shared between same monitor spec (no examples)	*/
		iscompatible = ( XSC(s)->MSpec == IBase->ActiveMonitorSpec );
		DX( printf( "This screen (%lx) is self-compatible, iscompatible = %ld\n",
		    s, iscompatible ) );
		break;

	    case MCOMPAT_NOBODY:
		/* Front screen is the only one allowed	*/
		iscompatible =  ( IBase->FirstScreen == s );
		DX( printf( "This screen (%lx) is nobody-compatible, iscompatible = %ld\n",
		    s, iscompatible ) );
		break;

	    case MCOMPAT_MIXED:
		/* vga, ntsc, pal, default: mixed modes	*/
		iscompatible = ( di.minfo.Compatibility == MCOMPAT_MIXED );
		DX( printf( "This screen (%lx) is mixed-compatible, iscompatible = %ld\n",
		    s, iscompatible ) );
		D(printf("mixed compat: isc %lx\n", iscompatible ) );
		break;
	    }
	}
#else
	DX( printf( "Compatibility %ld, Exclusive? %ld\n",
	    compatibility, TESTFLAG( XSC(s)->PrivateFlags, PRIVSCF_EXCLUSIVE ) ) );
	/* If frontmost screen is MCOMPAT_NOBODY, or this screen is
	 * SA_Exclusive, then only one screen is to be visible, and
	 * that is the frontmost one...
	 */
	if ( ( TESTFLAG( XSC(s)->PrivateFlags, PRIVSCF_EXCLUSIVE ) ) ||
	    ( compatibility == MCOMPAT_NOBODY ) )
	{
	    /* Front screen is the only one allowed	*/
	    iscompatible =  ( IBase->FirstScreen == s );
	    DX( printf( "This screen (%lx) is nobody-compatible, iscompatible = %ld\n",
		s, iscompatible ) );
	}
	else if ( compatibility == MCOMPAT_SELF )
	{
	    /* only shared between same monitor spec (no examples)	*/
	    iscompatible = ( XSC(s)->MSpec == IBase->ActiveMonitorSpec );
	    DX( printf( "This screen (%lx) is self-compatible, iscompatible = %ld\n",
		s, iscompatible ) );
	}
	else if ( compatibility == MCOMPAT_MIXED )
	{
	    /* vga, ntsc, pal, default: mixed modes	*/
	    iscompatible = ( di.minfo.Compatibility == MCOMPAT_MIXED );
	    DX( printf( "This screen (%lx) is mixed-compatible, iscompatible = %ld\n",
		s, iscompatible ) );
	    D(printf("mixed compat: isc %lx\n", iscompatible ) );
	}
#endif
    }
a412 3

    if ( iscompatible )
    {
d416 2
a417 24
	 D( printf("do not exclude screen: %lx\n", s ) );
	 CLEARFLAG( s->Flags, SCREENEXCLUDE );   

	/* copy over native/natural coords */
	XSC(s)->VPExtra->DisplayClip = XSC(s)->DClip;

#ifdef BOGUS_SCALE_DCLIPS

	/* The scaling code is useless, since the viewResolution
	 * variable is the ViewRes of the coerced mode, which is
	 * identical to the frontresolution!!!  So this was a big
	 * no-op.
	 * Maybe we want to scale the DisplayInfo.Resolution from
	 * natural to coerced.  Which would be:
	 * scaleConversion(..., naturalRes, coercedRes );
	 */


	/************************************************************
	 * scale display clip region
	 ************************************************************/
	 /* cache ViewResolution from MonitorInfo */
	viewResolution = di.minfo.ViewResolution;
	D( dumpPt( "screenVR",  viewResolution ) );
d419 1
a419 2
	/* copy over native/natural coords */
	XSC(s)->VPExtra->DisplayClip = XSC(s)->DClip;
d421 6
a426 7
	/* transform to active monitor	*/
	scaleConversion( &XSC(s)->VPExtra->DisplayClip.MinX,
	    viewResolution, frontresolution );
	scaleConversion( &XSC(s)->VPExtra->DisplayClip.MaxX,
	    viewResolution, frontresolution );
	D( dumpRect( "new DClip", &XSC(s)->VPExtra->DisplayClip ) );
#endif
d431 1
a431 1
	if (GDID(XSC(s)->DRecord, &di.dinfo, sizeof(di.dinfo), DTAG_DISP ))
d446 4
a449 1
#if SCALE_DCLIPS
a457 1
#endif
a481 216


#if 0

/* Peter: 6-Aug-90:
 * coercion tables:
 * first entry in each record  is 'natural' display id.
 * subsequent entries are coerced display id's for the
 * following user preferences: 
 *	1 - "normal"           ("Preserve Colors"/"Avoid Flicker" off)
 *	2 - NOLACE/NOKILLCOLOR ("Preserve Colors"/"Avoid Flicker" on)
 * (note that for Default->VGA conversion, we are talking about preserving colors,
 * while for VGA->Default conversion, we consider avoiding flicker).
 */

/* "coincidental" bits can be used for collapsing dualpf
 * parts of the coercion table onto the primary modes
 */
#define DPF_KEY_BITS	(0x440)	/* dualpf and pf2pri	*/

#ifndef VGA70_MONITOR_ID
#define VGA70_MONITOR_ID 0x00061000
#endif

#ifndef PAL70_MONITOR_ID
#define PAL70_MONITOR_ID 0x00071000
#endif

/* "generic" part of the VGA key which can be or'd with VGA_MONITOR_ID
 * or VGA70_MONITOR_ID
 */
#define genVGA(x)	((x) & ~MONITOR_ID_MASK)

UWORD	CToVGA[][3] = {
{ LORES_KEY,     genVGA(VGALORES_KEY),    genVGA(VGAEXTRALORES_KEY )},
{ HIRES_KEY,     genVGA(VGAPRODUCT_KEY),  genVGA(VGALORES_KEY )},
{ SUPER_KEY,     genVGA(VGAPRODUCT_KEY),  genVGA(VGAPRODUCT_KEY )},

{ LORESLACE_KEY, genVGA(VGALORES_KEY),    genVGA(VGAEXTRALORES_KEY )},
{ HIRESLACE_KEY, genVGA(VGAPRODUCT_KEY),  genVGA(VGALORES_KEY )},
{ SUPERLACE_KEY, genVGA(VGAPRODUCT_KEY),  genVGA(VGAPRODUCT_KEY )},

{ HAM_KEY,       genVGA(VGAHAM_KEY),      genVGA(VGAHAM_KEY )},
{ HAMLACE_KEY,   genVGA(VGAHAM_KEY),      genVGA(VGAHAM_KEY )},
};

#define CTOVGA_ENTRIES ( sizeof( CToVGA ) / ( 3*sizeof(UWORD) ) )

UWORD	CToDefault[][3] = {
{ genVGA(VGAEXTRALORES_KEY),     LORESLACE_KEY, LORES_KEY },
{ genVGA(VGALORES_KEY),          LORESLACE_KEY, LORES_KEY },
{ genVGA(VGAPRODUCT_KEY),        HIRESLACE_KEY, HIRES_KEY },

{ genVGA(VGALORESLACE_KEY),      LORESLACE_KEY, LORESLACE_KEY },
{ genVGA(VGAEXTRALORESLACE_KEY), LORESLACE_KEY, LORESLACE_KEY },
{ genVGA(VGAPRODUCTLACE_KEY),    HIRESLACE_KEY, HIRESLACE_KEY },

{ genVGA(VGAHAM_KEY),            HAMLACE_KEY,   HAM_KEY },
{ genVGA(VGAHAMLACE_KEY),        HAMLACE_KEY,   HAMLACE_KEY },
};

#define CTODEFAULT_ENTRIES ( sizeof( CToDefault ) / ( 3*sizeof(UWORD) ) )

/*
 * given 'natural' display mode id and 'active' monitor (by displayid),
 * find alternative display mode id, and return the record
 */
CPTR
figureCoercion( drecord, displayid, monitorid )
CPTR	drecord;
ULONG	displayid;
ULONG	monitorid;
{
    struct IntuitionBase	*IBase = fetchIBase();
    UWORD	(*ctable)[3];
    ULONG	srcmonitorid;
    ULONG	contestant;
    int		coercion_type;
    CPTR	coercedrecord;
    ULONG	coercedid = INVALID_ID;
    ULONG	dualpfbits;
    BOOL	is_pnd = FALSE;
    BOOL	is_vga = FALSE;
    int		ctable_entries;

    /* Peter 6-Aug-90: By default, coerce without special preference */
    coercion_type = 1;

    DC( printf("---\ncoercing record %lx, id %lx, to monitor id: %lx\n",
	drecord, displayid, monitorid ) );

    /* PAL/NTSC/default are irrelevant, so convert all to default. 
     * Likewise, VGA and VGA70 are equivalent, so strip that out.
     */
    switch ( MONITOR_PART( displayid ) )
    {
    case DEFAULT_MONITOR_ID:
    case PAL_MONITOR_ID:
    case NTSC_MONITOR_ID:
    case PAL70_MONITOR_ID:
	displayid &= ~ MONITOR_ID_MASK;
	/* displayid is PAL, NTSC, or default */
	is_pnd = TRUE;
	DC( printf("displayid converted to default %lx\n", displayid) );
	break;

    case VGA_MONITOR_ID:
    case VGA70_MONITOR_ID:
	displayid &= ~ MONITOR_ID_MASK;
	/* displayid is VGA or VGA70 */
	is_vga = TRUE;
	DC( printf("vga displayid stripped of monitor part%lx\n", displayid) );
	break;
    }

    /* choose coercion table for active monitor,
     * or pull off a quick-and-easy for PAL<->NTSC<->default
     * or for VGA<->VGA70
     */
    switch ( monitorid )
    {
    case DEFAULT_MONITOR_ID:
    case PAL_MONITOR_ID:
    case NTSC_MONITOR_ID:
    case PAL70_MONITOR_ID:
	ctable = CToDefault;
	ctable_entries = CTODEFAULT_ENTRIES;
	if ( IBase->NewIControl & IC_COERCE_LACE )
	{
	    /* coercion_type = 2 to avoid flicker */
	    coercion_type++;
	}
	/* if source monitor is pal/ntsc/default, then it's easy to
	 * calculate coercedid for ruling monitor.
	 */
	if (is_pnd)
	{
	    coercedid = monitorid | displayid;
	    DC( printf("pal/ntsc tricks: coercedid: %lx\n", coercedid));
	}
	break;

    case VGA_MONITOR_ID:
    case VGA70_MONITOR_ID:
	ctable = CToVGA;
	ctable_entries = CTOVGA_ENTRIES;
	if ( IBase->NewIControl & IC_COERCE_COLORS )
	{
	    /* coercion_type = 2 to preserve colors */
	    coercion_type++;
	}
	/* if source monitor is VGA or VGA70, then it's easy to
	 * calculate coercedid for ruling monitor.
	 */
	if (is_vga)
	{
	    coercedid = monitorid | displayid;
	    DC( printf("vga/vga70 tricks: coercedid: %lx\n", coercedid));
	}
	break;

    default:
	ctable = NULL;		/* will do no coercion	*/
    }

    /* if I didn't figure out the coerced id by pal/ntsc
     * tricks above, I have to look through the table
     */
    if ( coercedid == INVALID_ID && ctable != NULL )
    {
	/* extract the dualpf bits from the id, and
	 * put them back into the coerced id
	 */
	dualpfbits = displayid & DPF_KEY_BITS;
	displayid &= ~DPF_KEY_BITS;

	while ( ctable_entries-- )
	{
	    contestant = (*ctable)[0];
	    DC( printf("test against %lx\n", contestant ) );

	    if ( contestant == displayid )
	    {
		DC( printf(" a match! \n" ) );
		/* lookup the coerced id in the table record
		 * and slot for the coercion type (nokillcolor, noaddlace)
		 */
		coercedid = (*ctable)[ coercion_type ];
		DC( printf("display id %lx coerced to %lx\n",
		    displayid, (*ctable)[coercion_type] ) );

		coercedid |= dualpfbits;
		DC( printf("coercedid after adding back dualpfbits: %lx\n",
		    coercedid ) );

		/* put back in the monitor part of the ID
		 */
		coercedid |= monitorid;
		DC( printf("coercedid after monitorpart: %lx\n", coercedid  ));
		break;
	    }
	    ctable++;
	}
    }

    /* have a coercedid, hopefully not INVALID_ID */
    if ( (coercedid == INVALID_ID) ||
	 ((coercedrecord = FindDisplayInfo( coercedid )) == NULL) )
    {
	DC( printf("no coercion! coercedid = %lx\n", coercedid ));
	coercedrecord = drecord;
    }

    return ( coercedrecord );
}
#endif
@


38.5
log
@Scales DClips under coercion.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.4 91/11/12 16:36:27 peter Exp Locker: peter $
d40 5
d68 5
d154 6
a159 6
#if 1
    /* Peter 8-Aug-91: SA_Exclusive excludes other screens */
    compatibility = minfo.Compatibility;

    if ( ( IBase->FirstScreen ) &&
	TESTFLAG( XSC(IBase->FirstScreen)->PrivateFlags, PRIVSCF_EXCLUSIVE ) )
d161 2
a162 3
	DX( printf( "First screen (%lx) is SA_Exclusive\n", IBase->FirstScreen ) );
	compatibility = MCOMPAT_NOBODY;
    }
d164 2
a165 9
    if ( onescreen )
    {
	D( printf("coerceScreens: screen/onescreen %lx\n", onescreen ) );
	coerceScreenGrunt( onescreen, frontid, 
		minfo.ViewResolution, compatibility );
    }
    else	/* all screens */
    {
	for ( screen = IBase->FirstScreen; screen; screen = screen->NextScreen )
d167 3
a169 1
	    D( printf("coerceScreens, screen: %lx\n", screen ) );
d171 4
a174 1
	    coerceScreenGrunt( screen, frontid, 
d177 1
a177 11
    }
#else
    if ( onescreen )
    {
	D( printf("coerceScreens: screen/onescreen %lx\n", onescreen ) );
	coerceScreenGrunt( onescreen, frontid, 
		minfo.ViewResolution, minfo.Compatibility );
    }
    else	/* all screens */
    {
	for ( screen = IBase->FirstScreen; screen; screen = screen->NextScreen )
d179 3
a181 1
	    D( printf("coerceScreens, screen: %lx\n", screen ) );
d183 3
a185 2
	    coerceScreenGrunt( screen, frontid, 
		    minfo.ViewResolution, minfo.Compatibility );
a187 1
#endif
@


38.4
log
@No longer figures coercion, but relies on graphics/CoerceMode().
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.3 91/08/21 18:16:06 peter Exp Locker: peter $
d335 2
d359 1
d361 1
d497 15
a514 6
/* Peter 20-Nov-90:  These two #if's were an attempt to scale the
 * DClip so that coerced screens had the right DClip.  However, with
 * the fix in, a lores screen coerced into VGA-Lores behind Productivity
 * has a DClip which is only half the screen.
 */
#if 1
a517 1
#endif
a521 1
#if 1
d527 1
a527 13
#else
	if ( GDID( XSC(s)->NaturalDRecord, &di.minfo, sizeof( di.minfo ), DTAG_MNTR ))
	{
	     /* cache ViewResolution from MonitorInfo */
	    viewResolution = di.minfo.ViewResolution;
	    D( dumpPt( "screenVR",  viewResolution ) );

	    /* transform to active monitor	*/
	    scaleConversion( &XSC(s)->VPExtra->DisplayClip.MinX,
		viewResolution, frontresolution );
	    scaleConversion( &XSC(s)->VPExtra->DisplayClip.MaxX,
		viewResolution, frontresolution );
	}
a528 1
	D( dumpRect( "new DClip", &XSC(s)->VPExtra->DisplayClip ) );
d547 11
@


38.3
log
@If the front screen has PRIVSCF_EXCLUDE, all other screens are excluded.
Removed incorrect debug code.
Removed code to manage graphics.library < V38.
New custom chip rev means we no longer need CLEAR_FMODE kludge. *poof*.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.2 91/07/25 17:04:53 peter Exp Locker: peter $
a356 1
    CPTR			figureCoercion();
d360 2
d371 23
a393 2
    XSC(s)->DRecord = figureCoercion( XSC(s)->NaturalDRecord,
	XSC(s)->NaturalDisplayID, frontmonitor );
d395 1
a395 2
    D( printf("natural drecord %lx, coerced: %lx\n", 
	XSC(s)->NaturalDRecord, XSC(s)->DRecord ) );
d410 1
a410 1
    if ( GDID( XSC(s)->DRecord, &di.minfo, sizeof( di.minfo ), DTAG_MNTR ))
d574 3
d788 1
a788 1

@


38.2
log
@FMode poking kludge is now conditional on an IBase flag.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.1 91/07/25 15:01:48 peter Exp Locker: peter $
d16 1
d72 3
d143 29
d188 1
a321 9
#if AA_KLUDGES
	if ( ( fetchIBase()->GfxBase->LibNode.lib_Version > 37 ) &&
	   ( fetchIBase()->Flags & CLEAR_FMODE ) )
	{
	    XSC(sc)->VPExtra->FMode = 0;
	    XSC(sc)->VPExtra->Flags |= VPXF_HAVE_FMODE;
	}
#endif

a380 8
#if AA_KLUDGES
    if ( ( IBase->GfxBase->LibNode.lib_Version > 37 ) &&
	( IBase->Flags & CLEAR_FMODE ) )
    {
	XSC(s)->VPExtra->FMode = 0;
	XSC(s)->VPExtra->Flags |= VPXF_HAVE_FMODE;
    }
#endif
d394 9
a402 2
	/* decide if screen is compatible with frontmost */
	switch ( compatibility )
d404 16
a419 4
	case MCOMPAT_SELF:
	    /* only shared between same monitor spec (no examples)	*/
	    iscompatible = ( XSC(s)->MSpec == IBase->ActiveMonitorSpec );
	    break;
d421 19
a439 1
	case MCOMPAT_NOBODY:
d442 12
a453 3
	    break;

	case MCOMPAT_MIXED:
d456 2
a458 1
	    break;
d460 1
d462 1
a462 1
    D( else printf("can't get DRecord info %lx\n", XSC(s)->DRecord ) );
a548 1
	D( Debug() );
@


38.1
log
@Added an AA_KLUDGE to poke the FMode to zero and set the HAVE_FMODE flag.
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 38.0 91/06/12 14:15:16 peter Exp Locker: peter $
d289 2
a290 1
	if ( fetchIBase()->GfxBase->LibNode.lib_Version > 37 )
d357 2
a358 1
    if ( IBase->GfxBase->LibNode.lib_Version > 37 )
@


38.0
log
@Initial V38 check-in (matches V37 release).
@
text
@d6 1
a6 1
 *  $Id: coercion.c,v 1.21 91/04/16 15:48:55 peter Exp $
d288 8
d355 7
@
