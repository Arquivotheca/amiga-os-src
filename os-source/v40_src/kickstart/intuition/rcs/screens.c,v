head     38.52;
branch   ;
access   ;
symbols  V40_85:38.52 V40_71:38.51 V40_68:38.51 V40_65:38.51 V40_47:38.51 V40_45:38.51 V40_37:38.51 V40_34:38.50 V40_29:38.50 V39_2415:38.49 V39_2369:38.49 V39_2339:38.49 V39_2332:38.49 V39_2275:38.49 V39_2256:38.49 V39_2210:38.48 V39_2192:38.48 V39_2084:38.47 V39_2082:38.47 V39_2076:38.47 V39_2073:38.47 V39_2058:38.47 V39_2051:38.47 V39_2031:38.46 V39_2017:38.46 V39_2012:38.45 V39_1985:38.45 V39_1933:38.45 V39_1819:38.44 V39_1805:38.44 V39_1783:38.43 V39_1695:38.42 V39_1621:38.41 V39_1620:38.41 V39_1508:38.39 V39_1485:38.39 V39_1461:38.39 V39_1458:38.39 V39_1456:38.38 V39_1405:38.37 V39_1368:38.35 V39_1360:38.34 V39_1324:38.33 V39_1147:38.32 V39_1143:38.32 V39_1141:38.32 V39_1120:38.32 V39_1116:38.32 V39_1104:38.31 V39_1100:38.31 V39_1078:38.31 V39_1073:38.31 V39_757:38.27 V39_702:38.25 V39_557:38.21 V39_553:38.20 V39_551:38.19 V39_510:38.18 V39_495:38.17 V39_416:38.15 V39_383:38.15 V39_371:38.15 V39_336:38.14 V39_323:38.13 V39_295:38.12 V39_277:38.11 V39_254:38.10 V39_222:38.9 V39_185:38.9 V39_171:38.8 V39_161:38.8 V38_159:38.7 V38_116:38.6 V38_59:38.4;
locks    ; strict;
comment  @*   @;


38.52
date     93.05.05.10.43.32;  author peter;  state Exp;
branches ;
next     38.51;

38.51
date     93.03.17.17.11.49;  author peter;  state Exp;
branches ;
next     38.50;

38.50
date     93.02.15.19.03.42;  author peter;  state Exp;
branches ;
next     38.49;

38.49
date     92.11.25.15.40.49;  author peter;  state Exp;
branches ;
next     38.48;

38.48
date     92.11.10.17.09.45;  author peter;  state Exp;
branches ;
next     38.47;

38.47
date     92.08.18.10.13.38;  author peter;  state Exp;
branches ;
next     38.46;

38.46
date     92.08.06.16.59.58;  author peter;  state Exp;
branches ;
next     38.45;

38.45
date     92.08.02.12.44.15;  author peter;  state Exp;
branches ;
next     38.44;

38.44
date     92.07.24.11.29.28;  author peter;  state Exp;
branches ;
next     38.43;

38.43
date     92.07.17.17.29.05;  author peter;  state Exp;
branches ;
next     38.42;

38.42
date     92.07.08.15.25.22;  author peter;  state Exp;
branches ;
next     38.41;

38.41
date     92.06.29.10.46.50;  author peter;  state Exp;
branches ;
next     38.40;

38.40
date     92.06.23.17.21.25;  author peter;  state Exp;
branches ;
next     38.39;

38.39
date     92.06.04.16.18.03;  author peter;  state Exp;
branches ;
next     38.38;

38.38
date     92.06.03.17.34.29;  author peter;  state Exp;
branches ;
next     38.37;

38.37
date     92.05.29.18.56.49;  author peter;  state Exp;
branches ;
next     38.36;

38.36
date     92.05.29.18.29.21;  author peter;  state Exp;
branches ;
next     38.35;

38.35
date     92.05.27.16.07.32;  author peter;  state Exp;
branches ;
next     38.34;

38.34
date     92.05.27.11.55.24;  author peter;  state Exp;
branches ;
next     38.33;

38.33
date     92.05.21.17.44.00;  author peter;  state Exp;
branches ;
next     38.32;

38.32
date     92.04.14.15.46.17;  author peter;  state Exp;
branches ;
next     38.31;

38.31
date     92.04.07.17.56.47;  author peter;  state Exp;
branches ;
next     38.30;

38.30
date     92.04.02.21.40.23;  author peter;  state Exp;
branches ;
next     38.29;

38.29
date     92.04.02.12.07.31;  author peter;  state Exp;
branches ;
next     38.28;

38.28
date     92.04.01.15.07.47;  author peter;  state Exp;
branches ;
next     38.27;

38.27
date     92.03.26.18.42.53;  author peter;  state Exp;
branches ;
next     38.26;

38.26
date     92.03.26.16.38.58;  author peter;  state Exp;
branches ;
next     38.25;

38.25
date     92.03.23.11.57.47;  author peter;  state Exp;
branches ;
next     38.24;

38.24
date     92.03.21.14.52.00;  author peter;  state Exp;
branches ;
next     38.23;

38.23
date     92.03.19.15.52.32;  author peter;  state Exp;
branches ;
next     38.22;

38.22
date     92.03.18.11.49.51;  author peter;  state Exp;
branches ;
next     38.21;

38.21
date     92.03.05.09.02.56;  author peter;  state Exp;
branches ;
next     38.20;

38.20
date     92.03.04.09.29.28;  author peter;  state Exp;
branches ;
next     38.19;

38.19
date     92.03.03.16.34.05;  author peter;  state Exp;
branches ;
next     38.18;

38.18
date     92.02.21.17.03.54;  author peter;  state Exp;
branches ;
next     38.17;

38.17
date     92.02.20.12.15.40;  author peter;  state Exp;
branches ;
next     38.16;

38.16
date     92.02.17.17.15.38;  author peter;  state Exp;
branches ;
next     38.15;

38.15
date     92.02.05.15.39.03;  author peter;  state Exp;
branches ;
next     38.14;

38.14
date     92.01.28.12.39.41;  author peter;  state Exp;
branches ;
next     38.13;

38.13
date     92.01.22.16.43.24;  author peter;  state Exp;
branches ;
next     38.12;

38.12
date     91.12.12.20.44.46;  author peter;  state Exp;
branches ;
next     38.11;

38.11
date     91.11.25.16.54.24;  author peter;  state Exp;
branches ;
next     38.10;

38.10
date     91.11.15.18.53.24;  author peter;  state Exp;
branches ;
next     38.9;

38.9
date     91.10.17.14.27.57;  author peter;  state Exp;
branches ;
next     38.8;

38.8
date     91.08.29.17.53.28;  author peter;  state Exp;
branches ;
next     38.7;

38.7
date     91.08.21.18.20.06;  author peter;  state Exp;
branches ;
next     38.6;

38.6
date     91.07.25.17.05.42;  author peter;  state Exp;
branches ;
next     38.5;

38.5
date     91.07.25.15.03.21;  author peter;  state Exp;
branches ;
next     38.4;

38.4
date     91.07.10.18.00.50;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     91.06.24.12.16.03;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     91.06.19.18.06.44;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.06.12.15.12.26;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.12.14.30.14;  author peter;  state Exp;
branches ;
next     ;


desc
@@


38.52
log
@Now fail to open the screen if AttachPalExtra() fails.
@
text
@/*** screens.c ***************************************************************
 *
 *  screens.c -- mostly open/close screen and their support
 *
 *  $Id: screens.c,v 38.51 93/03/17 17:11:49 peter Exp Locker: peter $
 *
 *  Confidential Information: Commodore-Amiga, Inc.
 *  Copyright (c) Commodore-Amiga, Inc.
 *
 ****************************************************************************/

#include "intuall.h"

#ifndef EXEC_MEMORY_H
#include <exec/memory.h>
#endif

#ifndef EXEC_ALERTS_H
#include <exec/alerts.h>
#endif

#ifndef GRAPHICS_GFXNODES_H
#include <graphics/gfxnodes.h>
#endif

#ifndef GRAPHICS_DISPLAY_H
#include <graphics/display.h>
#endif

#ifndef GRAPHICS_GFXMACROS_H
#include <graphics/gfxmacros.h>
#endif

#ifndef GRAPHICS_DISPLAYINFO_H
#include <graphics/displayinfo.h>
#endif

#ifndef HARDWARE_CUSTOM_H
#include <hardware/custom.h>
#endif

#ifndef HARDWARE_DMABITS_H
#include <hardware/dmabits.h>
#endif

#ifndef UTILITY_PACK_H
#include <utility/pack.h>
#endif

#include "imageclass.h"

#define D(x)	;
#define DDPF(x)	;	/* dual playfield	*/
#define DOSS(x)	;	/* open sys screen	*/
#define DIM(x)	;	/* system images	*/
#define DPS(x)	;	/* public screens	*/
#define DCWB(x)	;	/* close workbench	*/
#define DCS(x)	;	/* CloseScreen		*/
#define DOS(x)	;	/* open screen		*/
#define DOST(x)	;	/* open screen tag dump		*/
#define DSCAN(x) ;	/* overscan		*/
#define DSG(x)	;	/* screen gadgets	*/
#define DRI(x)	;	/* debug renderinfo	*/
#define DST(x)	;	/* screen title		*/
#define DHEDLEY(x) ;	/* V35 compatibility	*/
#define DCBM(x)	;	/* custom bitmaps	*/
#define DOSF(x)	;	/* OpenScreen failure test code:
			 * Use {SA_Dummy, num} to cause failure
			 * in different places
			 */
#define DPEN(x) ;	/* Graphics ObtainPen() stuff */

ULONG GetTagDataUser();

/*** intuition.library/OpenScreen ***/


/* Peter 23-Aug-90: In KS 2.01, SA_BitMap doesn't cause CUSTOMBITMAP
 * to be set in screen->Flags.  Although this is fixed for 2.02, we have
 * publicly stated you can set this flag yourself after your screen opens
 * with no ill effects.  Remember that years from now!
 */

BYTE	loresBorders[8] = {
    1,	/* barvborder	*/
    2,	/* barhborder	*/
    4,	/* menuvborder	*/
    4,	/* menuhborder	*/
    2,	/* wbortop	*/
    4,	/* wborleft	*/
    4,	/* wborright	*/
    2,	/* wborbottom	*/
};
#if 0
#define NS(field)	(ns? (ns->field): 0)
#endif
#define NS(field)	(nscopy.field)

/* Structure to hold the screen flags before the Screen is allocated: */
struct SFlagTrap
{
    UWORD Flags;
    ULONG PrivateFlags;
};

ULONG screenFlagsPackTable[] =
{
    PACK_STARTTABLE( SA_Dummy ),

    PACK_WORDBIT( SA_Dummy, SA_ShowTitle, SFlagTrap, Flags, PKCTRL_BIT, SHOWTITLE ),
    PACK_WORDBIT( SA_Dummy, SA_Behind, SFlagTrap, Flags, PKCTRL_BIT, SCREENBEHIND ),
    PACK_WORDBIT( SA_Dummy, SA_Quiet, SFlagTrap, Flags, PKCTRL_BIT, SCREENQUIET ),
    PACK_WORDBIT( SA_Dummy, SA_AutoScroll, SFlagTrap, Flags, PKCTRL_BIT, AUTOSCROLL ),
    PACK_WORDBIT( SA_Dummy, SA_SharePens, SFlagTrap, Flags, PKCTRL_BIT, PENSHARED ),

    PACK_LONGBIT( SA_Dummy, SA_Draggable, SFlagTrap, PrivateFlags, PKCTRL_BIT, PSF_DRAGGABLE ),
    PACK_LONGBIT( SA_Dummy, SA_Exclusive, SFlagTrap, PrivateFlags, PKCTRL_BIT, PSF_EXCLUSIVE ),
    PACK_LONGBIT( SA_Dummy, SA_MinimizeISG, SFlagTrap, PrivateFlags, PKCTRL_BIT, PSF_MINIMIZEISG ),

    PACK_ENDTABLE,
};

struct Screen *
openScreen( ns )
struct NewScreen * ns ;
{
    struct TagItem *taglist = NULL;
    struct Screen *OpenScreenTagList();

    /* If an extended NewScreen was supplied, be sure to extract
     * the taglist:
     */
    if ( ( ns ) && ( TESTFLAG( ns->Type, NS_EXTENDED ) ) )
    {
	taglist = XNS(ns)->Extension;
    }

    return( OpenScreenTagList( ns, taglist ) );
}

/* default color scheme	*/
/* WARNING: keep an eye on the size of these guys */
extern UWORD	fourColorPens[ NUMDRIPENS + 1 ];
extern UWORD	twoColorPens[ NUMDRIPENS + 1 ];

/*** intuition.library/OpenScreenTagList ***/

struct Layer 	*CreateUpfrontHookLayer();
ULONG		stubReturn();

struct IScreenModePrefs DefaultScreenMode =
{
    HIRES_KEY, 
    STDSCREENWIDTH,
    STDSCREENHEIGHT,
    2,
    0
};


/* This routine is a wrapper around the real meat of OpenScreen().
 * It looks for the SA_LikeWorkbench tag, and if it finds it, makes
 * up to three attempts at opening this screen.  First, it tries
 * with the most recent ScreenMode prefs.  Second, it tries with
 * the most recent prefs that succeeded.  Lastly, it resorts to
 * the default screen mode.
 */

struct Screen *
openScreenTagList( ns, tags )
struct NewScreen *ns ;
struct TagItem	 *tags;
{
    struct Screen *sc = NULL;
    struct IScreenModePrefs *sm = NULL;
    LONG likewb;
    LONG attempt = 1;
    struct IntuitionBase *IBase = fetchIBase();
    struct Screen *realOpenScreenTagList();

    /* likewb will be zero for most screens, 1 for workbench cloners,
     * and LIKEWB_WORKBENCH for the actual Workbench screen.
     */
    if ( likewb = GetUserTagData0( SA_LikeWorkbench, tags ) )
    {
	/* Make 3 attempts to open Workbench-like screen:
	 * as preferred, as last achieved, and as default
	 */
	attempt = 3;
	sm = &IBase->CoolScreenMode;
    }

    while ( ( !sc ) && ( attempt-- ) )
    {
	sc = realOpenScreenTagList( ns, sm, tags );

	/* If the screen opened and it's the actual Workbench,
	 * then store the last mode that succeeded.
	 */
	if ( ( sc ) && ( likewb == LIKEWB_WORKBENCH ) )
	{
	    IBase->LastScreenMode = *sm;
	}

	/* Here we assume we failed to open.  The second attempt
	 * will be with the last mode that succeeded, and the
	 * third attempt will be with the default.
	 */
	sm = &IBase->LastScreenMode;
	if ( attempt == 1 )
	{
	    sm = &DefaultScreenMode;
	}
    }
    return( sc );
}

/* This is the heart of OpenScreen-processing.  This function takes
 * a NewScreen structure and a taglist.  It also takes a pointer
 * to an IScreenModePrefs structure, which, if non-NULL, is to
 * be used to initialize parameters to be Workbench-like.
 * OpenWorkBench uses this feature, as does the new SA_LikeWorkbench tag.
 */
struct Screen *
realOpenScreenTagList( ns, sm, tags )
struct NewScreen *ns;
struct IScreenModePrefs *sm;
struct TagItem	 *tags;
{
    struct	TextFont *ISetFont();
    extern UBYTE	 *SysIClassName;
    struct	TextFont *open_font;
    struct IntuitionBase *IBase = fetchIBase();
    void			*NewObject();

    /* pointers */
    struct Screen		*sc = NULL;
    struct ViewPort 		*vp;
    struct BitMap 		*bitmap;
    struct RasInfo		*rinfo;

    /* screen dimensions */
    struct IBox		screenbox;
    struct Rectangle	*dclip = NULL;
    int			stddclip = 0;

    /* public screens */
    /* if this is non-NULL, it means we have a public screen */
    struct PubScreenNode	*pubnode = NULL;
    UBYTE			*pubname = NULL;
    struct PubScreenNode 	*initPubScreen();

    /* general */
    LONG		errorcode = OSERR_NOMEM;
    ULONG		sysfont;
    ULONG  		longflags;
    ULONG  		screentype;
    int			depth;
    struct SFlagTrap	screentrap;
    struct NewScreen	nscopy;

    struct Layer_Info	*NewLayerInfo();
    struct Layer	*CreateUpfrontLayer();
    void		DisposeLayerInfo();
    LONG		DeleteLayer();
    struct BitMap	*AllocBitMap();

    DOSF(int		failnum = 0);

    DOS(printf("OPENSCREEN: %lx/%lx\n", ns, tags));

    DOS( printf(" --\nOpenScreenTagList: ns at %lx tags at %lx\n", ns, tags ) );
    DOST( dumpTagItems( NULL, tags ));

    clearWords( &nscopy, sizeof(struct NewScreen)/sizeof(WORD) );
    nscopy.Width = STDSCREENWIDTH;
    nscopy.Height = STDSCREENHEIGHT;
    nscopy.BlockPen = 1;

    if ( ns )
    {
	nscopy = *ns;
    }

    /* ---------------------------------------------------------------- */
    /* public screens.  check if it is already open, allocate a node 	*/
    /* ---------------------------------------------------------------- */
    /* The locking issues around the uniqueness test are tricky,
     * and there was a hole in V36-V39.  We want to do the uniqueness
     * test early, so we can fail quickly and without any flashing.
     * However, we can't link the pubscreen node onto the PubScreenList
     * until the screen is fully open, since apps can access that list.
     * Also, we can't hold the IBASELOCK across the guts of OpenScreen().
     * Thus, there was a time between the calls to initPubScreen()
     * and linkPubScreen() where a second screen of the same name
     * could pass the uniqueness test in initPubScreen.
     * The fix I chose for V40 was to create a second list, the
     * PendingPubScreens list, and initPubScreen() puts pubscreen nodes
     * there while still inside the same locking session as the uniqueness
     * test, which now has two lists to examine.
     */

    DOS( printf("handle pubscreen\n") );

    /* If you compile with DOSF(), you can force failure at different points
     * with different values of the unused SA_Dummy tag.
     */
    DOSF( failnum = GetUserTagData0( SA_Dummy, tags ) );
    DOSF( printf("DEBUG -- failnum %ld\n", failnum )  );

    if ( pubname = (UBYTE *) GetUserTagData0( SA_PubName, tags ) )
    {
	DOS( printf("pubname: %s.\n", pubname ) );

	/* initPubScreen updates the errorcode (only if problems)	*/
	pubnode = initPubScreen( pubname,
		    GetUserTagData0( SA_PubTask, tags ),
		    GetUserTagData( SA_PubSig, -1, tags ),
		    &errorcode );
	if ( ! pubnode )
	{
	    goto BADSCREENOPEN;
	}
	DOSF( if ( !(--failnum) ) {printf("OSFailure: initPubScreen\n"); goto BADSCREENOPEN;} );
    }


    /* ---------------------------------------------------------------- */
    /*	set up 'flags'							*/
    /* ---------------------------------------------------------------- */

    depth = NS( Depth );

    /* accumulate boolean state */
    DOS( printf(" newscreen flags (Type)  %lx\n", NS( Type ) ) );

    screentrap.Flags = (NS(Type)&~NS_EXTENDED)|SHOWTITLE;
    screentrap.PrivateFlags = PSF_DRAGGABLE;

    /* If this is a Workbench-like screen, then SHAREPENS is TRUE,
     * and depth and AUTOSCROLL depend on the supplied IScreenModePrefs.
     */
    if ( sm )
    {
	screentrap.Flags |= PENSHARED;
	screentrap.PrivateFlags |= PSF_MINIMIZEISG;
	if ( TESTFLAG( sm->ism_Control, WBAUTOSCROLL ) )
	{
	    screentrap.Flags |= AUTOSCROLL;
	}
	depth = sm->ism_Depth;
    }

    PackStructureTags( &screentrap, screenFlagsPackTable, tags );
    longflags = screentrap.Flags;

    DOS( printf("longflags accumulated %lx\n", longflags ) );

    /* screen type */
    screentype = GetUserTagData( SA_Type, NS( Type ) & SCREENTYPE, tags );

    if ( screentype != WBENCHSCREEN )
    {
	screentype = pubnode? PUBLICSCREEN: CUSTOMSCREEN;
    }
    longflags = (longflags & ~SCREENTYPE ) | screentype;

    DOS( printf("final flags/type are %lx\n", longflags ) );

#define NEWDEFAULTDEPTH (1)
    if ( !( depth = GetUserTagData( SA_Depth, depth, tags ) ))
    {
	depth = NEWDEFAULTDEPTH;
    }

    /* got to be careful here.
     * I am supposed to ignore ns->CustomBitMap if the
     * bit isn't set, but I want non-zero SA_BitMap to imply
     * custombitmap without the separate flag being set.
     */

    bitmap = NULL;

    if ( TESTFLAG( longflags, CUSTOMBITMAP ) ) bitmap = NS( CustomBitMap );

    DCBM( printf( "NewScreen.CustomBitMap = $%lx\n", bitmap ) );
    bitmap = (struct BitMap *) GetUserTagData( SA_BitMap, bitmap, tags );
    DCBM( printf( "SA_BitMap makes it = $%lx\n", bitmap ) );
    if ( bitmap )
    {
	depth = bitmap->Depth;
    }

    /* ---------------------------------------------------------------- */
    /*	allocate and link basic screen data structures, no rasters yet	*/
    /* ---------------------------------------------------------------- */
    DOS( printf("basic data structures\n") );

    {
	/* Number of colormap entries to get.  Will be 1<<depth, but
	 * never less than 32.  Can be increased by SA_ColorMapEntries.
	 */
	ULONG entries;

	entries = imax( GetUserTagData0( SA_ColorMapEntries, tags ),
	    imax( 1<<depth, 32 ) );

	/* Peter 26-Jun-91:  NB: we allocate rinfo last, since it won't
	 * be freeable until we stick it into the ViewPort later. 
	 * That way, it won't fail to get freed.
	 */
	if	(
	       (!( sc = (struct Screen *) AllocMem( 
		    sizeof( struct XScreen ), MEMF_PUBLIC | MEMF_CLEAR) ))
	    || (!(XSC(sc)->VPExtra=
		    (struct ViewPortExtra *)GfxNew(VIEWPORT_EXTRA_TYPE)))
	    || (!( XSC(sc)->ColorMap = (struct ColorMap *)GetColorMap( entries ) ))
	    || (!( rinfo = (struct RasInfo *) AllocMem( 
		    sizeof(struct RasInfo), MEMF_PUBLIC | MEMF_CLEAR) ))
	    )
	{
	    goto BADSCREENOPEN;
	}
    }

    /* init and link them all up */
    InitRastPort( &sc->RastPort );
    InitVPort( vp = &sc->ViewPort );

    /* WARNING: don't forget that InitVPort clears RasInfo pointer */
    vp->RasInfo = rinfo;

    DOSF( if ( !(--failnum) ) {printf("OSFailure: screen/VPExtra/ColorMap/RasInfo\n"); goto BADSCREENOPEN;} );

    /* NOTE: will set up second RasInfo after I've gotten 
     * display mode property flags below
     */

    DOS( printf("call videocontrol for color map %lx\n", XSC(sc)->ColorMap) );

    /* Tell graphics about attachments.
     * Peter 27-Feb-92: User can pass additional tags in
     * SA_VideoControl
     */
    VideoControlTags( XSC(sc)->ColorMap, 
		VTAG_ATTACH_CM_SET,	vp,
		VTAG_VIEWPORTEXTRA_SET,	XSC(sc)->VPExtra,
		TAG_MORE, GetUserTagData0( SA_VideoControl, tags ) );

    DOS( printf("after VCTags\n") );



    /* ---------------------------------------------------------------- */
    /*	obtain display specification from 16 or 32 bit specifiers	*/
    /* ---------------------------------------------------------------- */
    /* set up an invalid state for "old mode" */
    XSC(sc)->NaturalDisplayID = INVALID_ID;

    /* set up (uncoerced) screen mode */
    DOS( printf("displayID: %lx\n",
	GetUserTagData( SA_DisplayID, NS(ViewModes)&OLD_MODES, tags ) ) );

    /* jimm: 1/17/90: put support in for old V35 Hedley mode
     * specification
     */
    {
    struct TagItem	*tagitem;
    struct TagItem	*FindTagItem();
    ULONG		displayid;

	displayid = INVALID_ID;

	if ( tagitem = FindTagItem( NSTAG_EXT_VPMODE, tags ) )
	{
	    DHEDLEY( printf("V35 compatibility: ext_vpmode %lx\n",
		tagitem->ti_Data ));

	     if ( tagitem->ti_Data == (VPF_A2024 | VPF_TENHZ) )
	     {
		DHEDLEY( printf("doing ten hertz\n"));
		displayid = A2024TENHERTZ_KEY;
	     }
	     else if ( tagitem->ti_Data == (VPF_A2024) )
	     {
		DHEDLEY( printf("doing 15 hertz\n"));
		displayid = A2024FIFTEENHERTZ_KEY;
	     }
	}

	/* If this screen is not a V35-style Hedley display, we
	 * first look at the NewScreen ViewModes.  If a ScreenMode
	 * preferences (sm) was supplied, we use that instead.
	 * If SA_DisplayID was supplied, that overrides all.
	 */
	if ( displayid == INVALID_ID )
	{
	    displayid = NS(ViewModes) & OLD_MODES;
	    if ( sm )
	    {
		displayid = sm->ism_DisplayID;
	    }
	    displayid = GetUserTagData( SA_DisplayID, displayid, tags );
	}

	/* now try to use the deduced displayid */
	if ( setScreenDisplayID( sc, displayid, &errorcode, 0 ))
	{
	    DOS(printf("setScreenDisplayID failed, returned %lx\n",errorcode));
	    goto BADSCREENOPEN;
	}
	DOSF( if ( !(--failnum) ) {printf("OSFailure: setScreenDisplayID\n"); goto BADSCREENOPEN;} );
    }

    DOS( printf("after setScreenDisplayID\n") );

    /* (Brace for local variables).  Fail if this screen is too deep.
     */
    {
	struct DimensionInfo diminfo;

	if ( ( GDID( XSC(sc)->NaturalDRecord, &diminfo,
		sizeof( struct DimensionInfo ), DTAG_DIMS, NULL ) ) &&
	    ( depth > diminfo.MaxDepth ) )
	{
	    errorcode = OSERR_TOODEEP;
	    goto BADSCREENOPEN;
	}
	DOSF( if ( !(--failnum) ) {printf("OSFailure: too deep\n"); goto BADSCREENOPEN;} );
    }

    /*  jimm: 5/11/90: set up second RasInfo for DUALPF screens */
    /* too bad that I couldn't do a "more magic" setup for
     * "new" programs.  You can still define SA_DualPFMagic
     */
    if ( TESTFLAG( XSC(sc)->NaturalDProperties, DIPF_IS_DUALPF ) )
    {
	DDPF( printf("going for second rasinfo ") );
	if (!(vp->RasInfo->Next = (struct RasInfo *)AllocMem( 
		sizeof(struct RasInfo), MEMF_PUBLIC | MEMF_CLEAR)) )
	{
	    goto BADSCREENOPEN;
	}
	DOSF( if ( !(--failnum) ) {printf("OSFailure: RasInfo->Next\n"); goto BADSCREENOPEN;} );
	DDPF( printf(" at %lx\n", vp->RasInfo->Next ) );
    }

    /* go figure out screen dims and dclip */

    /* ---------------------------------------------------------------- */
    /*	determine screen dimensions, including STDSCREENHEIGHT/WIDTH	*/
    /* ---------------------------------------------------------------- */
    DOS( printf("screen dimensions\n") );

    /* default is {0,0,-1,-1}, which is set up in the nscopy */
    copyBox( &nscopy.LeftEdge, &screenbox );

    DOS( dumpBox("initial screenbox", &screenbox ) );

    stddclip = 0;
    /* If an IScreenModePrefs was supplied, override width, height,
     * and stddclip from there...
     */
    if ( sm )
    {
	screenbox.Width = sm->ism_Width;
	screenbox.Height = sm->ism_Height;
	stddclip = OSCAN_TEXT;
    }
    /* override with tag specs */
    screenbox.Left = GetUserTagData( SA_Left, screenbox.Left, tags );
    screenbox.Top = GetUserTagData( SA_Top, screenbox.Top, tags );
    screenbox.Width = GetUserTagData( SA_Width, screenbox.Width, tags );
    screenbox.Height = GetUserTagData( SA_Height, screenbox.Height, tags );
    
    DOS( dumpBox("screenbox after tags", &screenbox ) );

    stddclip = GetUserTagData( SA_Overscan, stddclip, tags );
    dclip = (struct Rectangle *) GetUserTagData0( SA_DClip, tags );

    /* get rectangle for display clip overscan to be used	*/
    if ( dclip )
    {
	/* specified explicitly */
	XSC(sc)->DClip = *dclip;
    }
    else
    {
	/* standard/default values */
	DOS( printf("using default or stddclip %ld\n", stddclip ) );
	displayOScan( XSC(sc)->NaturalDRecord, NULL,
		stddclip? stddclip: OSCAN_TEXT, &XSC(sc)->DClip );
    }
    DOS( dumpRect("DClip: ", &XSC(sc)->DClip ) );
    /* get overscan dims for STDSCREENWIDTH/HEIGHT
     * jimm: 3/12/89 * make STDSCREENWIDTH/HEIGHT relative
     * to the display clip specified or implied
     */

    /* convert standard screen dims to some standard overscan dims
     * and position
     */
    if (screenbox.Width == STDSCREENWIDTH)
    {
	screenbox.Width = rectWidth( &XSC(sc)->DClip );

	/* auto-setting left/top to dclip only applies if STDSCREENdims given */
	/* use DClip autoposition if NO left/top  have been
	 * provided
	 */
	if ( !ns && !FindTagItem( SA_Left, tags ) )
	{
	    screenbox.Left = XSC(sc)->DClip.MinX;
	}
	DOS( printf("stdscreenwidth: %ld\n", screenbox.Width ));
    }
    if (screenbox.Height == STDSCREENHEIGHT)
    {
	/* auto-setting left/top to dclip only applies if STDSCREENdims given */
	screenbox.Height = rectHeight( &XSC(sc)->DClip);
	if ( !ns && !FindTagItem( SA_Top, tags ) )
	{
	    screenbox.Top = XSC(sc)->DClip.MinY;
	}
	DOS( printf("stdscreenheight: %ld\n", screenbox.Height ));
    }

    /* Peter 5-Feb-92:  We need to ensure that the Workbench screen
     * is always 640x200 or bigger.  That must be done here, because
     * the routine in wbench.c that opens Workbench can get STDSCREENWIDTH
     * and STDSCREENHEIGHT, which aren't evaluated until here.
     */
    if ( screentype == WBENCHSCREEN )
    {
	screenbox.Width = imax( 640, screenbox.Width );
	screenbox.Height = imax( 200, screenbox.Height );
    }
    DOS( dumpBox("post-standard screen box:", &screenbox ) );

    /* make it so */
    copyBox( &screenbox, &sc->LeftEdge );

    /* ---------------------------------------------------------------- */
    /* finish set up of display clip region				*/
    /* ---------------------------------------------------------------- */

    /* default DClip handling: stretch text oscan out
     * to include entire display (i.e., change the default
     * dclip region now that I'm done with the STDSCREEN stuff)
     * Peter 4-Apr-91: we don't let a positive screen.TopEdge cause
     * the bottom of the DClip to be dropped.
     */
    if ( ! ( dclip  || stddclip ) )
    {
	struct Rectangle	screenrect;

	/* The bottom of the DClip should not grow if the screen
	 * was born with a screen.TopEdge > 0.
	 * (screenbox is not used from this point on, so it can
	 * be trashed in this manner.)
	 */
	screenbox.Top = imin( screenbox.Top, 0 );
	boxToRect( &screenbox, &screenrect );
	DOS( dumpRect( "screen rect", &screenrect ) );

	rectHull( &XSC(sc)->DClip, &screenrect );
	DOS( dumpRect( "OS: default dclip", &XSC(sc)->DClip ) );
    }


    /* ---------------------------------------------------------------- */
    /* Attached screens							*/
    /* ---------------------------------------------------------------- */

    /* These fields exist for attached screens.  Family is a list
     * containing nodes as follows:
     * - For a parent screen, the list contains nodes for each child
     *   and the parent itself (in depth order).
     * - For a non-attached screen, the list contains the node for the
     *   screen itself.
     * - For a child-screen, the list is empty (the screen's own node
     *   will be found on its parent's Family list).
     *
     * The actual linkage to children or parent happens inside
     * IOpenScreen(), in order to preserve the integrity of
     * the screen lists.
     */
    NewList( &XSC(sc)->Family );
    AddHead( &XSC(sc)->Family, &XSC(sc)->ChildNode );

    /* ---------------------------------------------------------------- */
    /*	viewport initialization						*/
    /* ---------------------------------------------------------------- */
    DOS( printf("viewport initialization\n") );

    /* position and dimensions	*/
    /* ZZZ: all but DWidth (DyOffset?) are set up by RemakeDisplay */
    vp->DWidth = sc->Width;

    /* ---------------------------------------------------------------- */
    /*	set up 'PrivateFlags'						*/
    /* ---------------------------------------------------------------- */

    /* Gather up PrivateFlags based on supplied tags
     * SA_Draggable defaults to TRUE, so we set that in the initial-flags.
     * Note also that setScreenDisplayID() may have already set the
     * PSF_INCOMPATIBLE flag, so we have to preserve any flags already set
     * in PrivateFlags.
     */
    XSC(sc)->PrivateFlags |= screentrap.PrivateFlags;

    /* ---------------------------------------------------------------- */
    /*	set up screen raster						*/
    /* ---------------------------------------------------------------- */

    DOS( printf("get screen raster\n") );

    /* 'bitmap' pointer was resolved earlier, since we need to know
     * this screens' depth before allocating the ColorMap.
     */
    if ( bitmap )
    {
	/* SA_BitMap implies CUSTOMBITMAP */
	
	longflags |= CUSTOMBITMAP;
    }
    else
    {
	ULONG bmflags = BMF_DISPLAYABLE | BMF_CLEAR;

	DCBM( printf( "Intuition supplies a bitmap of depth %ld, size %ld x %ld\n",
	    depth, sc->Width, sc->Height ) );

	/* Workbench-like screens get their interleaved-ness
	 * from the IScreenModePrefs.
	 */
	if ( GetUserTagData( SA_Interleaved,
	    sm ? TESTFLAG( sm->ism_Control, WBINTERLEAVED ) : FALSE,
	    tags ) )
	{
	    bmflags |= BMF_INTERLEAVED;
	}
	/* Peter 13-Feb-92:  From now on, we allocate a whole BitMap with
	 * planes, and not just the planes.  This is so there's a whole
	 * bitmap available that can be passed back from the
	 * AllocScreenBuffer(sc,SB_SCREEN_BITMAP) call.  Also, looking
	 * forward to strange new modes, we'd like to pick up hypothetically
	 * extended BitMaps.
	 * We use the new graphics.library function that takes care of
	 * allocating and initializing the BitMap and planes, while being
	 * aware of plane-alignment issues that AA brings.
	 *
	 */
	if ( !( XSC(sc)->RealBitMap = bitmap = AllocBitMap( sc->Width, sc->Height,
	    depth, bmflags, NULL ) ) )
	{
	    errorcode = OSERR_NOCHIPMEM;
	    goto BADSCREENOPEN;
	}
	DOSF( if ( !(--failnum) ) {printf("OSFailure: AllocBitMap\n"); goto BADSCREENOPEN;} );
    }

    /* The embedded bitmap in the screen is a copy of the bitmap the
     * caller supplied (for CUSTOMBITMAP) or of the bitmap we allocated.
     */
    sc->sc_BitMap = *bitmap;
    XSC(sc)->sc_BitMapCopy = *bitmap;

    /* We'd like to use a pointer to the real bitmap, but when an
     * application supplies a CUSTOMBITMAP, there is no guarantee that
     * the supplied struct BitMap will be kept around.
     * We start by assuming we can use the real bitmap, then override
     * with a pointer to &sc->sc_BitMap for CUSTOMBITMAP screens.
     */
    sc->RastPort.BitMap = bitmap;
    if ( TESTFLAG( longflags, CUSTOMBITMAP ) )
    {
	sc->RastPort.BitMap = &sc->sc_BitMap;
    }

    sc->ViewPort.RasInfo->BitMap = sc->RastPort.BitMap;

    /* ---------------------------------------------------------------- */
    /*	AttachPalExtra							*/
    /* ---------------------------------------------------------------- */

    /* Need to have ViewPort->RasInfo->BitMap in place, and ViewPort
     * modes established before calling AttachPalExtra().  
     * The PaletteExtra structure can tell us what the correct LastColor
     * is, even for HAM and EHB screens.
     */
    if ( AttachPalExtra( XSC(sc)->ColorMap, vp ) )
    {
	goto BADSCREENOPEN;
    }
    DOSF( if ( !(--failnum) ) {printf("OSFailure: AttachPalExtra\n"); goto BADSCREENOPEN;} );
    XSC(sc)->LastColor = XSC(sc)->ColorMap->PalExtra->pe_SharableColors;
    DOS( printf("after AttachPalExtra\n") );


    /* ---------------------------------------------------------------- */
    /*	screen colors							*/
    /* ---------------------------------------------------------------- */
    DOS( printf("colors time\n") );

    /* Now need to have Screen PaletteExtra set up, since setWBColorsGrunt()
     * now cares about the screen's highest settable color, which came
     * from pe_SharableColors.
     */
    /* need this be after VP linked in?  (can I move this back up?)*/
    /* initialize colors if user has specified a colorspec	*/
    /* ZZZ:
     *    do I want to actually SetRGB4? (no vp copper lists yet)
     *	  could a LoadRGB4() work out here?
     */

    DOS( printf("call setWBCG, for screen %lx\n", sc));

    /* provide for a way that screens can inherit *ALL* the default colors.
     * Workbench-like screens do this.
     */
    setWBColorsGrunt( sc, GetUserTagData( SA_FullPalette, sm, tags ) );

    DOS( printf("setWBCG returned\n") );

    /* Extra brace to make local variables */
    {
        struct ColorSpec	*cspec = NULL;
	WORD			cindex;

	if ( cspec = (struct ColorSpec *) GetUserTagData0( SA_Colors, tags ) )
	{
	    DOS( printf("colorspec at %lx\n", cspec ) );

	    while ( ( cindex = cspec->ColorIndex ) != -1 )
	    {
		SetRGB4( vp, cindex, cspec->Red, cspec->Green, cspec->Blue );
		++cspec;
	    }
	}
    }

    /* LoadRGB32() takes a table.  We allow screen openers to
     * pass that table right to us.  Note that LoadRGB32( vp, NULL )
     * is a safe NOP.
     */
    LoadRGB32( vp, GetUserTagData0( SA_Colors32, tags ) );

    /* ---------------------------------------------------------------- */
    /*	set up screen font						*/
    /* ---------------------------------------------------------------- */
    DOS( printf("screen font\n") );

    {
	struct TextAttr *font;

	/* if his font won't open, use one of the system fonts,
	 * assume it will open
	 */

	font = (struct TextAttr *) GetUserTagData( SA_Font, NS( Font ), tags );

	if ( font && (open_font = ISetFont( &sc->RastPort, font )) )
	{
	    /* use his font	*/
	    DOS( printf("use his font: %lx\n", font ) );
	    sc->Font = font;
	}
	else
	{
	    struct TAttrBuff *tbuff;

	    /* use a sysfont (he must specify a legal one) */
	    sysfont = 0;
	    /* Workbench-like screens use sysfont=1 */
	    if ( sm )
	    {
		sysfont = 1;
	    }
	    sysfont = GetUserTagData( SA_SysFont, sysfont, tags );
	    
	    DOS( printf("use a system font: %ld\n", sysfont ) );

	    /* jimm: 2/12/90: change to font inheritance: if
	     * using a special SYSFONT, window rastports will
	     * inherit the vanilla system font
	     */
	    if ( sysfont > 0 )
	    {
		SETFLAG( XSC(sc)->PrivateFlags, PSF_SCREENFONT );
	    }

	    /* Peter 9-Jan-91:  We store the Workbench screen's TextAttr
	     * in a place that doesn't go away when the wbscreen closes.
	     * This fixes MicroFiche Filer, which references (not copies)
	     * wbscreen->Font, then calls CloseWorkBench().
	     */
	    tbuff = &XSC(sc)->TAttrBuff;
	    if ( screentype == WBENCHSCREEN )
	    {
		/* Use permanent storage instead */
		tbuff = &IBase->MFF_TAttrBuff;
	    }

	    copyTAttr( &IBase->SysFontPrefs[ sysfont ], tbuff);
	    sc->Font = &tbuff->tab_TAttr;
	    DOS( printf("my font at:%lx, scFont %lx\n",
		&IBase->SysFontPrefs[sysfont], sc->Font ) );
	    open_font = ISetFont( &sc->RastPort, sc->Font );
	    /* had better work */
	}
	/* Mark that we've set the font in the screen's RastPort.
	 * closeScreenCommon() must avoid CloseFont()ing the RP.Font
	 * unless we were the opener.
	 */
	SETFLAG( XSC(sc)->PrivateFlags, PSF_SETFONT );
    }

    /* ---------------------------------------------------------------- */
    /*	initialize misc. Intuition constructs				*/
    /* ---------------------------------------------------------------- */
    DOS( printf("misc. init\n") );

    /* nscopy is initialized to have DetailPen=0, BlockPen=1 */
    sc->DetailPen = GetUserTagData( SA_DetailPen, nscopy.DetailPen, tags );
    sc->BlockPen = GetUserTagData( SA_BlockPen, nscopy.BlockPen, tags );


    sc->DefaultTitle = (UBYTE *) GetUserTagData( SA_Title,NS( DefaultTitle ), tags );
    DST( printf("title from tags/newscreen <%s>.\n", sc->DefaultTitle ) );

    if ( (!sc->DefaultTitle) && pubnode )
    {
	DST( printf("use pubnode name for title\n") );
	sc->DefaultTitle = pubnode->psn_Node.ln_Name;
    }
    sc->Title = sc->DefaultTitle;

    
    /* Flags might already have SCREENHIRES set in them	*/
    sc->Flags |= longflags;
    DOS( printf("setting sc->Flags %lx\n", sc->Flags ) );

    /* ---------------------------------------------------------------- */
    /* initialize DrawInfo						*/
    /* ---------------------------------------------------------------- */
    XSC(sc)->SDrawInfo.dri_Version = DRI_VERSION;
    XSC(sc)->SDrawInfo.dri_NumPens = NUMDRIPENS;
    XSC(sc)->SDrawInfo.dri_Font = open_font;
    XSC(sc)->SDrawInfo.dri_Depth = depth;
    XSC(sc)->SDrawInfo.dri_Resolution.X = XSC(sc)->ScaleFactor.X;
    XSC(sc)->SDrawInfo.dri_Resolution.Y = XSC(sc)->ScaleFactor.Y;


    {
	UWORD	*custompens, *scpens, *spens;
	UBYTE	dpen, bpen;

	spens = XSC(sc)->SDrawInfo.dri_Pens = XSC(sc)->SPens;

	LOCKIBASE();
	/* init pen array from one of two equal size hardcoded tables 	*/
	DRI( printf("render info pens size %ld %ld\n",
	    sizeof twoColorPens, sizeof XSC(sc)->SPens ) );

	/* Typical applications begin with the fourColorPens array.
	 * Workbench-like applications actually use the user's
	 * preferred pens.  Monochrome applications begin with the
	 * twoColorPens array.
	 * A little farther on, if neither SA_Pens or SA_LikeWorkbench
	 * is specified, we clobber the pens with the monochrome
	 * new-look.
	 */
	
	scpens = fourColorPens;
	if ( sm )
	{
	    scpens = IBase->ScreenPens4;
	    if ( depth > 2 )
	    {
		scpens = IBase->ScreenPens8;
	    }
	}
	if ( depth == 1 )
	{
	    scpens = twoColorPens;
	}

	/* Copy the selected initial pens into the Screen's
	 * DrawInfo dri_Pens:
	 */
	CopyMem( scpens, spens, sizeof(UWORD) * (NUMDRIPENS+1) );
	UNLOCKIBASE();

	/* override penspecs with (partial) list passed in SA_Pens	*/

	/* copies of Screen values	*/
	dpen = spens[ DETAILPEN ] = sc->DetailPen;
	bpen = spens[ BLOCKPEN ] = sc->BlockPen;

	
	/* If he does not specify SA_Pens, or he is not Workbench-like,
	 * he does not get full treatment:
	 */
	if ( ( custompens = (UWORD *) GetUserTagData0( SA_Pens, tags ) ) ||
	    ( sm ) )
	{
	    /* Mask pens down to the number of planes we really
	     * have.  We base this XSC(sc)->LastColor, which is correct
	     * correctly for HAM, EHB, etc.
	     */

	    LONG numpens = 0;
	    XSC(sc)->SDrawInfo.dri_Flags |= DRIF_NEWLOOK;

	    /* Copy pens, if any, until ~0 is encountered in source
	     * or destination.
	     */
	    if ( custompens )
	    {
		scpens = spens;

		while ( *custompens != ~0 && *scpens != ~0 )
		{
		    numpens++;
		    *scpens++ = *custompens++;
		}
		/* If the three "new for V39" pens are not specified,,
		 * they get V37-compatible defaults.
		 * Exception: if you pass {~0} for your pens (i.e.
		 * all you want are defaults), then you get the V39
		 * defaults.
		 */
		if ( ( numpens != 0 ) && ( numpens <= BARDETAILPEN ) )
		{
		    spens[ BARDETAILPEN ] = dpen;
		    spens[ BARBLOCKPEN ] = 
		    spens[ BARTRIMPEN ] = bpen;
		}
	    }
	    /* Now resolve the special constants that map to
	     * pens ~0 to ~3
	     */
	    scpens = spens;
	    while ( *scpens != ~0 )
	    {
		*scpens &= XSC(sc)->LastColor;
		scpens++;
	    }
	}
	/* otherwise, we rely on his (initial, screen) Detail/BlockPens	*/
	else
	{
	    int i;

	    /* if detail and block are the same, we
	     * use 0 and 1 (the defaults)
	     */
	    if ( dpen == bpen )
	    {
		dpen = 0;
		bpen = 1;
	    }

	    /* Transcript has blockpen = 0, which makes all window borders
	     * invisible.  If block = 0, we switch detail and block
             */
	    if ( bpen == 0 )
	    {
		bpen = dpen;
		dpen = 0;
	    }

	    /* Most pens are initialized to the BlockPen value,
	     * except for BARDETAILPEN and FILLTEXTPEN, which are
	     * initialized to the DetailPen value, and BACKGROUNDPEN,
	     * which is initialized to zero.
	     */
	    for ( i = TEXTPEN; i < NUMDRIPENS; i++ )
	    {
		spens[ i ] = bpen;
	    }
	    spens[ BARDETAILPEN ] =
	    spens[ FILLTEXTPEN ] = dpen;
	    spens[ BACKGROUNDPEN ] = 0;
	}
    }


    /* ---------------------------------------------------------------- */
    /*	Default checkmark and Amiga-key imagery				*/
    /* ---------------------------------------------------------------- */

    if (!( XSC(sc)->SDrawInfo.dri_CheckMark = NewObject( NULL, SysIClassName,
	SYSIA_DrawInfo, &XSC(sc)->SDrawInfo,
	SYSIA_Which, MENUCHECK,
	TAG_DONE ) ) )
    {
	goto BADSCREENOPEN;
    }

    if (!( XSC(sc)->SDrawInfo.dri_AmigaKey = NewObject( NULL, SysIClassName,
	SYSIA_DrawInfo, &XSC(sc)->SDrawInfo,
	SYSIA_Which, AMIGAKEY,
	TAG_DONE ) ) )
    {
	goto BADSCREENOPEN;
    }
    DOSF( if ( !(--failnum) ) {printf("OSFailure: AmigaKey/CheckMark\n"); goto BADSCREENOPEN;} );

    DRI( dumpDrawInfo( "screen drawinfo", &XSC(sc)->SDrawInfo ) );

    /* ---------------------------------------------------------------- */
    /*	Graphics pen-sharing (ObtainPen())				*/
    /* ---------------------------------------------------------------- */

    /* Brace for local variables */
    {
	int pen, p;
	LONG allocate, isDRIpen;
	ULONG mode;

	/* The rule for allocating colors is as follows:
	 * Any pen that's in the DrawInfo pens must be sharable, since
	 * SA_Pens is all about sharing.  Pens 17-19 are the sprite pens,
	 * and are also made sharable.
	 *
	 * For unaware public and custom, all other pens are allocated as
	 * exclusive, because the screen could be a paint program,
	 * or any program that feels free to muck with those colors.
	 *
	 * For aware public and custom screens (SA_SharePens,TRUE),
	 * all other pens are left unallocated. (The pubscreen owner can
	 * allocate some before making the screen public).
	 *
	 * The Workbench screen and other Workbench-like screens are
	 * considered "aware" (SA_SharePens, TRUE).  Additionally,
	 * on Workbench-like screens, we allocate pens ~0 and ~1, so
	 * that complementing of string gadget and console cursors tends
	 * to work.
	 *
	 * On the true Workbench screen, we also allocate colors 0 to 3
	 * and ~0 to ~3 as sharable.  This is a compromise because we want
	 * the Workbench to be as aware as possible, but some
	 * palette-sharing-unaware programs will be opening on the WB.
	 * For them, we tie down 0 to 3 (which are common rendering colors),
	 * and ~0 to ~3, (which are common complement colors).
	 */

	for ( p = 0; p <= XSC(sc)->LastColor; p++ )
	{
	    /* By default, we'll allocate this pen, and in shared mode.
	     * (shared is the default.)
	     */
	    allocate = TRUE;
	    mode = PENF_NO_SETCOLOR;

	    /* We need to know if this pen is in the DrawInfo pens */
	    isDRIpen = FALSE;
	    for ( pen = 0; pen < NUMDRIPENS; pen++ )
	    {
		if ( p == XSC(sc)->SPens[pen] )
		{
		    isDRIpen = TRUE;
		    break;
		}
	    }

	    if ( ( isDRIpen ) || ( ( p >= 17 ) && ( p <= 19 ) ) )
	    {
		/* Pens in the pen-array are intended to be shared, so
		 * that's how we'll allocate them.  Likewise for the
		 * sprite pens.  We need do nothing here.
		 */
		DPEN( printf("Pen %ld in SA_Pens or is a sprite pen.  Will be shared.\n",p ) );
	    }
	    else if ( !TESTFLAG( sc->Flags, PENSHARED ) )
	    {
		/* Screens that do not request {SA_SharePens,TRUE}
		 * must have all other pens allocated as exclusive,
		 * since it could be a paint-program or something
		 * that owns the screen.
		 */
		mode = PENF_NO_SETCOLOR | PENF_EXCLUSIVE;
		DPEN( printf("Pen %ld on unaware screen.  Will be exclusive.\n",p ) );
	    }
	    else if ( ( screentype == WBENCHSCREEN ) &&
		( ( p < 4 ) || ( p >= XSC(sc)->LastColor-3 ) ) )
	    {
		/* On the Workbench screen, pens 0 to 3 and ~0 to ~3 are
		 * allocated as shared.  We need do nothing here.
		 */
		DPEN( printf("Pen %ld on Workbench screen.  Will be shared.\n",p ) );
	    }
	    else if ( ( sm ) && ( p >= XSC(sc)->LastColor-1 ) )
	    {
		/* On LikeWorkbench screens, pens ~0 and ~1 are
		 * allocated as shared.  We need do nothing here.
		 */
		DPEN( printf("Pen %ld on WorkbenchLike screen.  Will be shared.\n",p ) );
	    }
	    else
	    {
		/* This is a custom screen, or else an aware pubscreen
		 * (i.e. one that specifies {SA_SharePens,TRUE}).
		 * Don't allocate other pens.
		 */
		allocate = FALSE;
		DPEN( printf("Pen %ld on custom or aware pubscreen.  Will be free.\n",p ) );
	    }

	    if ( allocate )
	    {
		/* PENF_NO_SETCOLOR means ignore the RGB values
		 * supplied here
		 */
		ObtainPen( XSC(sc)->ColorMap, p, 0, 0, 0, mode );
		DPEN( printf("Pen %ld obtained as mode %ld.\n", p, mode ) );
	    }
	}
    }

    /* ---------------------------------------------------------------- */
    /* initialize border sizes and gadgets (this is too rez-inflexible)	*/
    /* ---------------------------------------------------------------- */
    DOS( printf("border sizes\n") );

    {
	CopyMem( loresBorders,  &sc->BarVBorder, 8 );

	/* patch up two discrepancies	*/
	if ( IsHires( sc ) )
	{
	    sc->BarHBorder = 5;
	    sc->MenuVBorder = 2;
	}

	/* jimm: 1/16/90: allow short little screens */
	/* note: 4/8/90: BarHeight is one less than layer height */
	sc->BarHeight =
	    imin( sc->BarVBorder * 2 + sc->Font->ta_YSize, sc->Height-1 );
    }


    DSG( printf("OS: about to get system gadgets\n") );

    if ( !screenGadgets( sc ) )
    {
	DSG( printf("OS: failed to get system gadgets\n") );
	goto BADSCREENOPEN;
    }
    DOSF( if ( !(--failnum) ) {printf("OSFailure: screenGadgets\n"); goto BADSCREENOPEN;} );
    DSG( printf("OS: got system gadgets\n") );
#if 0
    /** SHRINK: WHAT USER GADGETS???!!! **/
    /* link user screen gadgets at end of sytem list */
    ((struct Gadget *) lastThing(&sc->FirstGadget))->NextGadget =
	ns->Gadgets;
#endif


    /* ---------------------------------------------------------------- */
    /*	initialize layers structures for this screen, incl. BarLayer	*/
    /* ---------------------------------------------------------------- */
    {
	struct Hook *screenbackfill;

	DOS( printf("screen layers init\n") );

	InitLayers(&sc->LayerInfo);
	if (! FattenLayerInfo(&sc->LayerInfo) )
	{
	    goto BADSCREENOPEN;
	}
	DOSF( if ( !(--failnum) ) {printf("OSFailure: FattenLayerInfo\n"); goto BADSCREENOPEN;} );

	/* New for V39:  SA_BackFill for Screen's LayerInfo backfill.
	 * Defaults to NULL, which is the good ol' layers behavior of old.
	 */
	screenbackfill = (struct Hook *)GetUserTagData0( SA_BackFill, tags );
	InstallLayerInfoHook( &sc->LayerInfo, screenbackfill );

	/*  When we create the layer, we use a stub-Hook so that the bitmap
	    doesn't get cleared, in case somebody has supplied a custom bitmap
	    with data in it already */
	if ( ( XSC(sc)->ClipLayer_Info = NewLayerInfo() ) &&
	    ( XSC(sc)->ClipLayer = CreateUpfrontHookLayer( XSC(sc)->ClipLayer_Info,
		sc->RastPort.BitMap,
		0, 0,
		sc->Width-1, sc->Height-1,
		LAYERSIMPLE | LAYERBACKDROP,
		LAYERS_NOBACKFILL,
		NULL ) ) )
	{
	    /* Specify a hook that does no backfill, so that deleting the
	     * menu clip-layer doesn't blank the bitmap.  Under V37 and early
	     * V39, we set the RastPort mask to zero to have the same effect.
	     */
	    InstallLayerInfoHook( XSC(sc)->ClipLayer_Info, LAYERS_NOBACKFILL );
	}
	else
	{
	    goto BADSCREENOPEN;
	}
	DOSF( if ( !(--failnum) ) {printf("OSFailure: ClipLayerInfo/ClipLayer\n"); goto BADSCREENOPEN;} );

	sc->BarLayer = (struct Layer *)CreateUpfrontHookLayer(
		&sc->LayerInfo,
		sc->RastPort.BitMap, 0, 0, sc->Width - 1, sc->BarHeight,
		LAYERSIMPLE | LAYERBACKDROP,
		LAYERS_NOBACKFILL,
		NULL);
	if (sc->BarLayer == NULL) goto BADSCREENOPEN;
	DOSF( if ( !(--failnum) ) {printf("OSFailure: BarLayer\n"); goto BADSCREENOPEN;} );

	/* This one merits a little explanation.  Under V37, the screen
	 * BarLayer had a do-nothing backfill hook.  This meant that
	 * creating the BarLayer did not erase the underlying data
	 * (which might have been placed in a CustomBitMap).  However,
	 * deleting a layer which obscured the BarLayer nevertheless
	 * caused the BarLayer area to be cleared, because layers would
	 * clear the area under a deleted layer as well as invoking
	 * backfill on each revealed area.
	 *
	 * V39 fixed this layers "double-clear" bug, causing an Intuition
	 * bug, namely that closing a window didn't erase the part of
	 * the window which obscured the title bar area.  We correct
	 * this by immediately setting the BarLayer hook of a SCREENQUIET
	 * screen to the same hook as the screen's Layer_Info backfill hook.
	 */
	if ( TESTFLAG( sc->Flags, SCREENQUIET ) )
	{
	    InstallLayerHook( sc->BarLayer, screenbackfill );
	}

	ISetFont(sc->BarLayer->rp, sc->Font);
	sc->BarLayer->Window = NULL;

	/* render into the BarLayer */
	DSG( printf("OS: render screenbar\n") );
	screenbar( sc );
	DSG( printf("OS: render done\n") );
    }

    /* ---------------------------------------------------------------- */
    /* link into lists, turn 'er on and let 'er rip		*/
    /* ---------------------------------------------------------------- */
    DOS( printf("OS: call state machine\n") );

    /* get in sync with state machine to link this screen
     * into the screen list.
     * also, set up the coercion stuff in there, so that no screen
     * without consistent information is ever in the list
     * when things are running freely
     */

    if ( errorcode = doISM( itOPENSCREEN, sc, tags ) )
    {
	DOS( printf("OS: doISM returned failure!!\n") );
	goto BADSCREENOPEN;
    }
#if 0
    /* Can't put a failure test here since IOpenScreen() is assumed to
     * clean up after itself when it really fails.  This fake failure
     * hardly takes care of that...
     */
    DOSF( if ( !(--failnum) ) {printf("OSFailure: itOPENSCREEN\n"); goto BADSCREENOPEN;} );
#endif

    DOS( printf( "OS:proceed with other linkages\n") );

    /* Other linkages: not state machine dependent	*/
    LOCKIBASE();

    /* link in public screen node */
    if ( pubnode )
    {
	/* If OpenScreen is extended in a way that it can fail after
	 * the pubnode is linked in, then the jFreeMem() needs to
	 * be preceded by a Remove().
	 */
	linkPubScreen( sc, pubnode );
    }

    UNLOCKIBASE();

    /*** Turn it on	***/
    DOS( printf("OST: call RemakeDisplay\n") );
    RemakeDisplay();
    DOS( printf("OST: RemDis returned\n"));

    /* move it up above	setWBColorsGrunt(sc); */

    goto OUT;	/* success	*/

BADSCREENOPEN:
    DOS( printf("badscreenopen\n") );

    /* Peter 13-Aug-90: use closeScreenCommon to save space: */
    closeScreenCommon( sc );
    sc = NULL;

    if (pubnode)
    {
	/* Only good enough since OpenScreenTagList() can't fail
	 * after the point where the pubnode is linked in to the
	 * real list.  At this point of failure, the node is on
	 * the pending screens list, so we must be sure to remove it.
	 */
	Remove( pubnode );
	FreeVec( pubnode );
    }

    {
	LONG		*errptr = NULL;

	DOS( printf("bailing out:  errorcode %ld\n", errorcode ) );

	if ( errptr = (ULONG *) GetUserTagData0( SA_ErrorCode, tags ) )
	{
	    *errptr = errorcode;
	}
    }

OUT:
    DOS( printf("returning sc:%lx\n --\n", sc ) );
    DST( kpause( "end of OpenScreenTagList." ) );

    DOS(printf("OPENSCREEN DONE, tags: %lx\n", tags));

    return(sc);
}


/*
 * Common code that frees things associated with screens, called
 * by OpenScreenTagList's failure, and by ICloseScreen.
 */

closeScreenCommon( sc )
struct Screen *sc;
{
    int gindex;

    if ( sc )
    {
	if ( sc->BarLayer )
	{
	    CloseFont( sc->BarLayer->rp->Font );
	    DeleteLayer( NULL, sc->BarLayer );
	}

	if ( XSC(sc)->ClipLayer ) 
	{
	    /* Peter 18-Nov-91: We used to set the RastPort mask to
	     * zero so the "underlying bits" aren't cleared.  Before
	     * we did this, the custom bitmap was getting cleared
	     * at this point.  V39 layers supports a NULL Layer_Info
	     * backfill hook, so we use that instead.
	     */
	    DeleteLayer( NULL, XSC(sc)->ClipLayer );
	}
	if ( XSC(sc)->ClipLayer_Info ) DisposeLayerInfo( XSC(sc)->ClipLayer_Info );

	ThinLayerInfo( &sc->LayerInfo );

	freeSysGadgets( sc->FirstGadget );
	for ( gindex = 0; gindex < GADGETCOUNT; gindex++ )
	{
	    DisposeObject( XSC(sc)->SysImages[ gindex ] );
	}

	/* Only close the font if I indeed opened it.  InitRastPort() of the
	 * screen's RastPort puts GfxBase->DefaultFont in it.  If OpenScreen()
	 * failed between the calls to InitRastPort() and the call to
	 * OpenFont(), we would CloseFont() GB->DefaultFont by mistake.
	 * We could have NULLed out RP.Font after InitRastPort(), but I
	 * feared a fontless RastPort.  This is safer.
	 */
	if ( ( sc->RastPort.Font ) && TESTFLAG( XSC(sc)->PrivateFlags, PSF_SETFONT ) )
	{
	    CloseFont( sc->RastPort.Font );
	}

	FreeColorMap( XSC(sc)->ColorMap );
	if ( XSC(sc)->VPExtra ) GfxFree( XSC(sc)->VPExtra );

	DisposeObject( XSC(sc)->SDrawInfo.dri_AmigaKey );
	DisposeObject( XSC(sc)->SDrawInfo.dri_CheckMark );

	/* Peter 28-Jan-92: HMM.  It seems we really should
	 * WaitBlit() before freeing the bitmap!!!
	 * Martin T. suggests WaitBlit() even for custom bitmap
	 * screens, to prevent some application bugs.
	 */
	WaitBlit();
	if ((sc->Flags & CUSTOMBITMAP) == 0)
	{
	    /* New graphics.library function that frees the bitmap
	     * and its planes.
	     */
	    FreeBitMap( XSC(sc)->RealBitMap );
	}

	{
	struct RasInfo *ri = sc->ViewPort.RasInfo;

	    if ( ri )
	    {
		if ( ri->Next )
		{
		    DDPF( printf("free second rasinfo at %lx\n", ri->Next ) );
		    FreeMem( ri->Next, sizeof(struct RasInfo) );
		}
		FreeMem( ri, sizeof(struct RasInfo) );
	    }
	}

	/* finally, goodbye Screen! */
	FreeMem(sc, sizeof(struct XScreen));
    }
}

/*
 * ISM portion of OpenScreen()
 *
 * Perhaps this is best thought of as being named ILinkScreen
 *
 * also coerces screen to monitor of the screen current list,
 * arbitrated with other screen list users
 *
 * Attaching screens can fail if SA_Parent points to a screen
 * that is itself a child, or if SA_Front|BackChild points to
 * a screen that is itself a parent.
 *
 * Returns zero for success, non-zero for failure.
 *
 * IMPORTANT:  The caller of this routine currently assumes that
 * this routine cleans up everything it does!
 */
LONG
IOpenScreen( sc, taglist )
struct Screen	*sc;
struct TagItem *taglist;
{
    struct IntuitionBase *IBase = fetchIBase();
    struct Screen *parent, *child;
    int whichway;
    struct TagItem *NextTagItem();
    struct MinNode *node, *succ;
    static struct Point no_point = { 0, 0 };
    LONG error = 0;

    LONG attachScreen();

    /* This screen may be a child screen (if its parent is specified
     * with SA_Parent) or a parent screen (if its children are specified
     * with SA_FrontChild or SA_BackChild), but not both.  SA_Parent
     * has priority...
     */
    if ( parent = (struct Screen *)GetUserTagData0( SA_Parent, taglist ) )
    {
	/* This screen is intended to be the child of some other screen */
	error = attachScreen( sc, parent );
    }
    else
    {
	/* This screen may be the parent of one or more screens.
	 * For _each_ such screen (specified through the SA_FrontChild
	 * and SA_BackChild tags), attach the screen and note if
	 * the programmer wanted it to come to front or to back.
	 */
	struct TagItem *tstate = taglist;
	struct TagItem *tag;

	while ( ( !error ) && ( tag = NextTagItem( &tstate ) ) )
	{
	    /* Assuming a child... */
	    if ( child = (struct Screen *) tag->ti_Data )
	    {
		if ( tag->ti_Tag == SA_FrontChild )
		{
		    SETFLAG( XSC(child)->PrivateFlags, PSF_CHILDFRONT );
		    error = attachScreen( child, sc );
		}
		else if ( tag->ti_Tag == SA_BackChild )
		{
		    CLEARFLAG( XSC(child)->PrivateFlags, PSF_CHILDFRONT );
		    error = attachScreen( child, sc );
		}
	    }
	}
    }

    if ( !error )
    {
	struct ViewPort *vp = &sc->ViewPort;

	/* When SDEPTH_INITIAL is set, the SDEPTH_INFAMILY flag has no
	 * bearing if this screen is a parent.  If it is a child, it
	 * indicates we want to be placed at the front/back of the family,
	 * not the whole list.
	 */
	whichway = SDEPTH_TOFRONT | SDEPTH_INITIAL | SDEPTH_CHILDONLY;

	if ( TESTFLAG( sc->Flags, SCREENBEHIND) )
	{
	    whichway = SDEPTH_TOBACK | SDEPTH_INITIAL | SDEPTH_CHILDONLY;
	}
	/* relinkScreen() takes care of linking the new screen into
	 * the correct place.
	 */
	LOCKIBASE();
	LOCKVIEW();
	relinkScreen( sc, whichway );

	/* coerce to proper mode */
	DOS( printf("OST: call coerceScreens\n") );
	/* Note that coerceScreens() will ensure that the screen's
	 * position is legal, which means that if the new screen is
	 * the child of some screen, then child's TopEdge is made
	 * to not exceed its parent's, so we have no further work
	 * in that regard.
	 */
	coerceScreens( sc, FORCE );

	/* jimm: 2/28/90: need to init vp offsets here, because
	 * they aren't sync'd by RemakeDisplay
	 * Peter 22-Mar-92:  Moved this to after the doISM()
	 * because inside doISM() coerceScreens() gets called,
	 * which ensures that the screen LeftEdge/TopEdge has
	 * a legal position.  We need for that to go into
	 * the VPOffsets and the stash.
	 *
	 * Peter 16-Aug-92:  Moved to inside doISM() because we
	 * need to link the screen and the viewport under the
	 * same lock-set.  This is because another task might
	 * be calling RethinkDisplay().  That function evaluates
	 * which ViewPorts are hidden based on the screen
	 * list.  However, MrgCop() works based on the View ViewPort
	 * list.  If RethinkDisplay() occured after the screen was
	 * linked but before the viewport was linked, then the
	 * screen might obscure all other screens without itself
	 * having a ViewPort.  This will cause MrgCop() to fail and
	 * result in LoadView(NULL) even though screens are present.
	 */
	XSC(sc)->VPOffsetStash.X = vp->DxOffset = sc->LeftEdge;
	XSC(sc)->VPOffsetStash.Y = vp->DyOffset = sc->TopEdge;

	/* installVPort(), inline  */
	vp->Next = IBase->ViewLord.ViewPort;
	IBase->ViewLord.ViewPort = vp;

	UNLOCKVIEW();
	UNLOCKIBASE();

	/* screenMouse(sc); * done in coerceScreens() */

	/* If the new screen has children, then we must ensure that
	 * each child-screen is adjacent (in depth) to a family member,
	 * and that each child's top edge doesn't exceed the parent's.
	 */

	for ( node = XSC(sc)->Family.mlh_Head;
	    succ = node->mln_Succ;
	    node = succ )
	{
	    /* One of the screens on the Family list is the
	     * screen itself, and we don't want to act on it.
	     */
	    if ( ( child = SCREENFROMNODE( node ) ) != sc )
	    {
		whichway = SDEPTH_TOBACK | SDEPTH_CHILDONLY;

		if ( TESTFLAG( XSC(child)->PrivateFlags, PSF_CHILDFRONT ) )
		{
		    whichway = SDEPTH_TOFRONT | SDEPTH_CHILDONLY;
		}
		relinkScreen( child, whichway );

		/* Ensure that the child's TopEdge doesn't exceed
		 * its parent's:
		 */
		IMoveScreen( child, &no_point, SPOS_REVALIDATE|SPOS_NORETHINK );
	    }
	}
    }
    else
    {
	/* Clean up EVERYTHING we did inside this function, which is 
	 * just the attachment.
	 */
	detachScreen( sc );
    }
    return( error );
}

/*
 * returns non-zero if OK
 */
displayOScan( drecord, displayID, ostype, rect )
CPTR			drecord;
ULONG			displayID;
LONG			ostype;
struct Rectangle	*rect;
{
    struct Rectangle	*doscan;
    struct DimensionInfo	diminfo;

    DSCAN( printf("dOScan: type: %lx\n", ostype ) );

    if ( GDID( drecord, &diminfo, sizeof( diminfo ), DTAG_DIMS, displayID ))
    {
	switch ( ostype )
	{
	case OSCAN_STANDARD:
	    doscan = &diminfo.StdOScan;
	    break;
	case OSCAN_MAX:	
	    doscan = &diminfo.MaxOScan;
	    break;
	case OSCAN_VIDEO:	
	    doscan = &diminfo.VideoOScan;
	    break;
#if 0
	case OSCAN_TEXT:	
#endif
	default:
	    doscan = &diminfo.TxtOScan;
	    break;
	}

	*rect = *doscan;
	DSCAN( dumpRect( "dOS returning oscan", rect ) );

	return ( 1 );
    }

    DSCAN( printf("dOScan failing: ID: %08lx\n", displayID ) );
    return ( 0 );
}


/*** intuition.library/CloseScreen ***/

CloseScreen(OScreen)
struct Screen *OScreen;
{
    DCS( printf("---\nCloseScreen entry, sc = %lx\n", OScreen ) );

    if ( ! OScreen ) return ( 1 );

    if ( doISM( itCLOSESCREEN, OScreen ) )
    {
	if ( fetchIBase()->FirstScreen == NULL)
	{
	    DCS( printf("all screens gone, openwb true\n") );
	    OpenWorkBench();	/* gives Dave a poke	*/
	}
	return ( TRUE );
    }
    return ( FALSE );
}


AlohaWorkbench(wbport) 
struct MsgPort *wbport; 
/* "aloha" in hawaiian means both hello and goodbye */ 
{ 
    DCWB( printf("AlohaWorkBench: port %lx\n", wbport ) );
    fetchIBase()->WBPort = wbport; 
} 
 
BOOL CloseWorkBench() 
{ 
    int			retval;
    struct MsgPort	*port;
    struct IntuiMessage	imsg;
    struct MsgPort	*CreateMsgPort();

    DCWB( printf("===\nCloseWorkBench enter, task %lx\n", FindTask( NULL )) );

    /* create me a private port	*/
    if ( ! ( port = CreateMsgPort( ) ) ) return ( FALSE );

    DCWB( printf("CWB: reply port at %lx\n", port ) );

    initWBMessage( &imsg, port, WBENCHCLOSE );

    /* processing the itCLOSEWB token will check to see if there 
     * is a WB screen, and if there are no application windows
     * on it.  If OK, it sends WB the message, returns
     * TRUE, and you wait for the message to come back
     * from WB before proceeding
     */

    DCWB( printf("CWB doISM itCLOSEWB, imsg = %lx\n", &imsg ) );
    retval =  doISM( itCLOSEWB, &imsg );
    DCWB( printf("CWB: doISM for itCLOSEWB returned %ld\n", retval ) );

    if ( retval )	/* doISM returns 0 if OK to try closescreen */
    {
	DCWB( printf("CWB: doISM failed\n") );
	/* failure: the message wasn't sent */
	DeleteMsgPort( port );
	return ( FALSE );
    }

    /* wait for message reply */
    DCWB( printf("CWB: doISM succeeded, wait for reply on port %lx\n",port) );
    WaitPort( port );
    DCWB( printf("CWB: reply from dave received\n") );
    DeleteMsgPort( port );

    /* now do the actual screen close, which might fail
     * if there are windows open after all this is done.
     */

    DCWB( printf("CWB: doISM itCLOSESCREEN task %lx\n", FindTask( 0L ) ) );
    if ( ! ( retval = doISM( itCLOSESCREEN, NULL ) ) )
    {
	/* close screen failed for some unknown reason,
	 * probably somebody snuck a window in there.
	 * Resummon the WB.
	 */
	DCWB( printf("screen would not close\n"));
	pokeWorkbench();	/* give dave a poke */
    }
    return ( retval );
} 

/*
 * initializes message for CloseWB or OpenWB.
 * Note that mouse, timestamp, and qualifiers are garbage.
 * The IDCMPWindow and IAddress fields are both NULL
 */
initWBMessage( imsg, replyport, code )
struct IntuiMessage	*imsg;
struct MsgPort		*replyport;
{
    imsg->ExecMessage.mn_ReplyPort  = replyport;
    imsg->Class = WBENCHMESSAGE; 
    imsg->Code = code; 
    imsg->IAddress = imsg->IDCMPWindow = NULL;
}


/*
 * if OScreen == NULL, means I'm to close Workbench
 */
ICloseScreen( OScreen )
struct Screen *OScreen;
{
    struct Screen 	*findWorkBench();
    struct IntuitionBase *IBase = fetchIBase();

    DCS(printf("ICloseScreen: screen %lx task %lx\n",OScreen,FindTask(0L)));

    /* by now, CloseWorkBench() has sent WB the news, and
     * given him a chance to clean up
     */

    /* WB  is already gone */
    if ( ! OScreen  && ! ( OScreen = findWorkBench() ) )
    {
	DCWB( printf("ICS: wbscreen already gone\n"));
	/* 4/30/90: jeez, has this been incompatible for very long? */
	return ( FALSE );
    }

    DCS( printf("ICS: screen to close %lx\n", OScreen  ) );

    /* The calls to freePubScreenNode() and delinkScreen() MUST
     * happen inside the same LOCKIBASE session.  freePubScreenNode()
     * will dispose the PSNode of the Workbench screen if there
     * are no visitors.  Later, before we delink the screen, someone
     * might trigger openSysScreen(WBENCHSCREEN) (e.g. via
     * LockPubScreen(NULL)), which finds the screen by walking
     * the screen list.  Holding the IBASELOCK around all this
     * is the protection we need.
     */

    LOCKIBASE();
    /*
     * notice that the fPSN is tested last, so that it can
     * commit to freeing the stuff and know that this screen
     * is definitely going bye-bye.
     */
    if ( OScreen->FirstWindow || ! freePubScreenNode( XSC(OScreen)->PSNode ) )
    {
	DCS( printf("ICS: window (%lx) open or visitor count failed.\n",
		OScreen->FirstWindow ));
	UNLOCKIBASE();
	return ( 0 );
    }

    /* Detach any children from this screen, and detach this screen
     * from any parent.
     */
    detachScreen( OScreen );

    /* delink ViewPort and Screen.
     * These must occur under the same lock-set because another task
     * might be calling RethinkDisplay().  That function evaluates
     * which ViewPorts are hidden based on the screen list.  However,
     * MrgCop() works based on the View ViewPort list.  If RethinkDisplay()
     * occured after the ViewPort was unlinked but while the screen
     * was still linked, then the screen might obscure all other screens
     * without itself having a ViewPort.  This will cause MrgCop() to fail
     * and result in LoadView(NULL) even though screens are present.
     */

    LOCKVIEW();

    delinkThing(&OScreen->ViewPort, &IBase->ViewLord.ViewPort);
    delinkScreen( OScreen );

    UNLOCKVIEW();
    UNLOCKIBASE();

    /* jimm: 3/22/90: do this right after delinking, before
     * freeing bitplanes
     */
    RemakeDisplay();
    freeMouse();	/* jimm: PAL: */

    FreeVPortCopLists(&OScreen->ViewPort);

    closeScreenCommon( OScreen );

    DCS( printf("ICloseScreen: think about workbench reopen\n") );

    if (IBase->FirstScreen == NULL || OScreen == IBase->ActiveScreen )
    {
	IBase->ActiveScreen = NULL;	/* probably some old bandaid */
    }


    DCS( printf( "ICloseScreen done\n" ) );

    return ( 1 );
}


/* Detach any children this screen may have, then detach this screen
 * from its parent, if any.
 */
detachScreen( sc )
{
    struct MinNode *node, *succ;

    /* Automatically detach each child screen, if any */
    for ( node = XSC( sc )->Family.mlh_Head;
	succ = node->mln_Succ;
	node = succ )
    {
	/* Although one of the screens on the Family list is the
	 * screen itself, it's harmless to detach it, so we
	 * don't bother with the usual (child != sc) test.
	 */
	attachScreen( SCREENFROMNODE( node ), NULL );
    }

    /* Automatically detach this screen from any parent */
    attachScreen( sc, NULL );
}

/*
 * returns screen with VisitorCount++
 */
struct Screen *openSysScreen(type)
USHORT type;
{
    struct Screen *workscreen;
    struct Screen *openwbscreen();
    struct IntuitionBase *IBase = fetchIBase();

    DOSS( printf("openSysScreen type: %lx\n", type));

    /*** jimm: 3/23/90: 
     * I'm not too happy about this, but a semaphore is too
     * dangerous, since OpenScreen gets semaphores, calls
     * doISM(), and so on.  This works.
     *
     * Look, beats the hell out of busyWaitForbid() from
     * the Old Days.
     *
     * This protection is to keep more than one caller from opening
     * a workbench screen.
     */
    for (;;)
    {
	Forbid();
	if ( IBase->SysScreenProtect == 0 )
	{
	    IBase->SysScreenProtect++;	/* I am in 	*/
	    Permit();
	    break;
	}
	Permit();
	WaitTOF();	/* ick	*/
    }

    /* only one caller at a time can get here	*/

    LOCKIBASE();	/* protect my march down the list	*/
			/* also keeps people from taking screen private */

    workscreen = IBase->FirstScreen;
    while (workscreen)
    {
	DOSS(printf("check screen %lx flags %lx against %lx\n", workscreen,
		workscreen->Flags & SCREENTYPE, type ));
	if ((workscreen->Flags & SCREENTYPE) == type)
	{
	    bumpPSNVisitor( XSC(workscreen)->PSNode );
	    UNLOCKIBASE();
	    goto out;
	}

	workscreen = workscreen->NextScreen;
    }
    UNLOCKIBASE();

    DOSS(printf("oSS couldn't find, call owb\n"));

    if (IBase->Flags & VIRGINDISPLAY)
    {
	IBase->LongMouse.LX = 0;
	IBase->LongMouse.LY = 0;
	IBase->Flags &= ~VIRGINDISPLAY;
    }

    /* switch replaced by if-else: 2/4/86 */
    if (type == WBENCHSCREEN) 
    {
	/* Can't have IBASELOCK when calling this.
	 */
	workscreen = openwbscreen();		/* returns with VCount++ */
	goto out;
    }
    else 
    {
	DOSS( printf("type again %lx\n", type ) );
	DOSS( Alert(AN_SysScrnType) );
    }

out:
    IBase->SysScreenProtect--;	/* I am out 	*/
    return ( workscreen );
}
@


38.51
log
@Now initialize sc_BitMapCopy as part of the fix to the BitMap poker
kludge.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.50 93/02/15 19:03:42 peter Exp Locker: peter $
d790 1
a790 2
     * is, even for HAM and EHB screens.  Just in case AttachPalExtra()
     * fails, we'll set a reasonable fallback LastColor.
d792 1
a792 2
    XSC(sc)->LastColor = ( 1 << depth ) - 1;
    if ( !AttachPalExtra( XSC(sc)->ColorMap, vp ) )
d794 1
a794 1
	XSC(sc)->LastColor = XSC(sc)->ColorMap->PalExtra->pe_SharableColors;
d796 2
@


38.50
log
@Fixed race condition that could cause LockPubScreen(NULL) to
return garbage.  No longer Open/CloseMonitor().  Fixed hole
in pubscreen name uniqueness test.  Alert() removed to save space.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.49 92/11/25 15:40:49 peter Exp Locker: peter $
d767 1
@


38.49
log
@SCREENQUIET BarLayers now have their backfill hook reset after
opening, for V37-compatible behavior.  Now rely on screenGadgets()
testing the SCREENQUIET flag.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.48 92/11/10 17:09:45 peter Exp Locker: peter $
d118 1
d288 13
a300 7
    /* do this early, since it may fail because of uniqueness test
     * ZZZ: oops: this isn't protected against somebody opening
     * a pubscreen of the same name between now and linkPubScreen()
     * below.  If we could move this down near linkPubScreen(),
     * we could probably safely hold IBASELOCK around the whole
     * session initPubScreen/linkPubScreen.  Can't hold that
     * lock around doISM(), at least.
d302 1
d346 1
d1405 3
a1407 1
	 * after the point where the pubnode is linked in
d1409 1
a1483 2
	CloseMonitor( XSC(sc)->NaturalMSpec );

d1871 12
d1892 1
a1911 1
    LOCKIBASE();
d2044 1
a2044 1
	Alert(AN_SysScrnType);
@


38.48
log
@Now call FreeMem() instead of jfreeMem().  No longer accidentally
CloseFont() the wrong font during certain OpenScreen() failures.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.47 92/08/18 10:13:38 peter Exp Locker: peter $
a74 5
/* V39 definition of layers-supplied no-op-backfill hook.  Coming soon
 * to an include-file near you! */
#ifndef LAYERS_NOBACKFILL
#define LAYERS_NOBACKFILL ((struct Hook *)1)
#endif
d1237 1
a1237 1
    if ( ! screenGadgets( sc, longflags & SCREENQUIET ) )
a1254 4
    DOS( printf("screen layers init\n") );

    InitLayers(&sc->LayerInfo);
    if (! FattenLayerInfo(&sc->LayerInfo) )
d1256 1
a1256 3
	goto BADSCREENOPEN;
    }
    DOSF( if ( !(--failnum) ) {printf("OSFailure: FattenLayerInfo\n"); goto BADSCREENOPEN;} );
d1258 1
a1258 28
    /* New for V39:  SA_BackFill for Screen's LayerInfo backfill.
     * Defaults to NULL, which is the good ol' layers behavior of old.
     */
    InstallLayerInfoHook( &sc->LayerInfo, GetUserTagData0( SA_BackFill, tags ) );

    /*  When we create the layer, we use a stub-Hook so that the bitmap
	doesn't get cleared, in case somebody has supplied a custom bitmap
	with data in it already */
    if ( ( XSC(sc)->ClipLayer_Info = NewLayerInfo() ) &&
	( XSC(sc)->ClipLayer = CreateUpfrontHookLayer( XSC(sc)->ClipLayer_Info,
	    sc->RastPort.BitMap,
	    0, 0,
	    sc->Width-1, sc->Height-1,
	    LAYERSIMPLE | LAYERBACKDROP,
	    LAYERS_NOBACKFILL,
	    NULL ) ) )
    {
	/* Specify a hook that does no backfill, so that deleting the
	 * menu clip-layer doesn't blank the bitmap.  Under V37 and early
	 * V39, we set the RastPort mask to zero to have the same effect.
	 */
	InstallLayerInfoHook( XSC(sc)->ClipLayer_Info, LAYERS_NOBACKFILL );
    }
    else
    {
	goto BADSCREENOPEN;
    }
    DOSF( if ( !(--failnum) ) {printf("OSFailure: ClipLayerInfo/ClipLayer\n"); goto BADSCREENOPEN;} );
d1260 36
a1295 10
    sc->BarLayer = (struct Layer *)CreateUpfrontHookLayer(
	    &sc->LayerInfo,
	    sc->RastPort.BitMap, 0, 0, sc->Width - 1, sc->BarHeight,
	    LAYERSIMPLE | LAYERBACKDROP,
	    LAYERS_NOBACKFILL,
	    NULL);
    if (sc->BarLayer == NULL) goto BADSCREENOPEN;
    DOSF( if ( !(--failnum) ) {printf("OSFailure: BarLayer\n"); goto BADSCREENOPEN;} );
    ISetFont(sc->BarLayer->rp, sc->Font);
    sc->BarLayer->Window = NULL;
d1297 37
a1333 4
    /* render into the BarLayer */
    DSG( printf("OS: render screenbar\n") );
    screenbar( sc );
    DSG( printf("OS: render done\n") );
@


38.47
log
@Fixed race-condition which could lead to LoadView(NULL).
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.46 92/08/06 16:59:58 peter Exp Locker: peter $
d907 5
d944 1
a944 1
    XSC(sc)->SDrawInfo.dri_Font =  open_font;
d1439 8
a1446 1
	if ( sc->RastPort.Font )
a1472 4
	/* Even though jfreeMem() can take a NULL pointer, dereferencing
	 * it to get RasInfo->Next is a bad idea...
	 */
	if ( sc->ViewPort.RasInfo )
d1474 11
a1484 4
	    DDPF( printf("free second rasinfo at %lx\n", 
		sc->ViewPort.RasInfo->Next ) );
	    jfreeMem(sc->ViewPort.RasInfo->Next, sizeof(struct RasInfo));
	    jfreeMem(sc->ViewPort.RasInfo, sizeof(struct RasInfo));
d1486 1
@


38.46
log
@Uses GetUserTagData() and GetUserTagData0().
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.45 92/08/02 12:44:15 peter Exp Locker: peter $
a1338 16
    /* jimm: 2/28/90: need to init vp offsets here, because
     * they aren't sync'd by RemakeDisplay
     * Peter 22-Mar-92:  Moved this to after the doISM()
     * because inside doISM() coerceScreens() gets called,
     * which ensures that the screen LeftEdge/TopEdge has
     * a legal position.  We need for that to go into
     * the VPOffsets and the stash.
     */
    XSC(sc)->VPOffsetStash.X = vp->DxOffset = sc->LeftEdge;
    XSC(sc)->VPOffsetStash.Y = vp->DyOffset = sc->TopEdge;

    /* installVPort(), inline  */
    vp->Next = IBase->ViewLord.ViewPort;
    IBase->ViewLord.ViewPort = vp;


d1498 1
d1549 2
d1565 2
d1578 31
d1841 12
a1852 1
    /* delinkVPort */
d1854 1
d1856 2
a1858 3

    LOCKIBASE();
    delinkScreen( OScreen );
@


38.45
log
@ColorMap pointer is now struct ColorMap *.  Now use pe_SharableColors
to determine the last settable color in the palette.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.44 92/07/24 11:29:28 peter Exp Locker: peter $
d188 1
a188 1
    if ( likewb = GetUserTagData( SA_LikeWorkbench, 0, tags ) )
d305 1
a305 1
    DOSF( failnum = GetUserTagData( SA_Dummy, 0, tags ) );
d308 1
a308 1
    if ( pubname = (UBYTE *) GetUserTagData( SA_PubName, 0, tags ) )
d314 1
a314 1
		    GetUserTagData( SA_PubTask, 0, tags ),
d401 1
a401 1
	entries = imax( GetUserTagData( SA_ColorMapEntries, 0, tags ),
d444 1
a444 1
		TAG_MORE, GetUserTagData( SA_VideoControl, NULL, tags ) );
d575 1
a575 1
    dclip = (struct Rectangle *) GetUserTagData( SA_DClip, 0, tags );
d826 1
a826 1
	if ( cspec = (struct ColorSpec *) GetUserTagData( SA_Colors, 0, tags ) )
d842 1
a842 1
    LoadRGB32( vp, GetUserTagData( SA_Colors32, NULL, tags ) );
d995 1
a995 1
	if ( ( custompens = (UWORD *) GetUserTagData( SA_Pens, 0, tags ) ) ||
d1267 1
a1267 1
    InstallLayerInfoHook( &sc->LayerInfo, GetUserTagData( SA_BackFill, NULL, tags ) );
d1396 1
a1396 1
	if ( errptr = (ULONG *) GetUserTagData( SA_ErrorCode, 0, tags ) )
d1528 1
a1528 1
    if ( parent = (struct Screen *)GetUserTagData( SA_Parent, NULL, taglist ) )
@


38.44
log
@SA_LikeWorkbench screens have pens ~0 and ~1 allocated.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.43 92/07/17 17:29:05 peter Exp Locker: peter $
d413 1
a413 1
	    || (!( XSC(sc)->ColorMap = (USHORT *) GetColorMap( entries ) ))
d779 18
d801 3
a803 2
    /* Now need to have Screen BitMap set up, since setWBColorsGrunt()
     * now cares about the screen's depth...
a844 12
    /*	AttachPalExtra							*/
    /* ---------------------------------------------------------------- */

    /* Need to have ViewPort->RasInfo->BitMap in place, and ViewPort
     * modes established before calling AttachPalExtra().
     */
    AttachPalExtra( XSC(sc)->ColorMap, vp );

    DOS( printf("after AttachPalExtra\n") );


    /* ---------------------------------------------------------------- */
d999 2
a1000 1
	     * have.
d1002 1
a1002 1
	    UWORD depthmask = (1 << depth) - 1;
d1037 1
a1037 1
		*scpens &= depthmask;
a1111 1
	LONG numcolors = 1 << depth;
d1140 1
a1140 1
	for ( p = 0; p < numcolors; p++ )
d1178 1
a1178 1
		( ( p < 4 ) || ( p >= numcolors-4 ) ) )
d1185 1
a1185 1
	    else if ( ( sm ) && ( p >= numcolors-2 ) )
@


38.43
log
@Comment change pertaining to SDEPTH_INFAMILY.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.42 92/07/08 15:25:22 peter Exp Locker: peter $
d1119 5
a1123 7
	 * The Workbench screen is considered "aware" (SA_SharePens, TRUE),
	 * but we also allocate colors 0 to 3 and ~0 to ~3 as sharable.
	 * This is a compromise because we want the Workbench to be as
	 * aware as possible, but some palette-sharing-unaware programs
	 * will be opening on the WB.  For them, we tie down 0 to 3
	 * (which are common rendering colors), and ~0 to ~3, (which are
	 * common complement colors).
d1125 6
d1177 7
@


38.42
log
@V39 DrawInfo pens are now initialized compatibly.  Now handles failure
to attach screens.  Improved failure-debug code.  I take advantage of
the fact that FreeColorMap(NULL) is now safe.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.41 92/06/29 10:46:50 peter Exp Locker: peter $
d937 1
d1071 1
d1288 1
a1288 1
    screenbar(sc);
d1546 4
a1549 3
	/* The SDEPTH_CHILDONLY flag has no bearing if this screen is
	 * not a child.  If it is a child, it indicates we want to be
	 * placed at the front/back of the family, not the whole list.
d1577 1
@


38.41
log
@Now uses IBase->LongMouse.  Now allocates sprite pens.  Fixed enforcer
hit trying to free RasInfo->Next.  Fixed bug where depthmask wasn't
being applied to pens inherited via SA_LikeWorkbench.  Renamed
openworkbench() to openwbscreen() for clarity.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.40 92/06/23 17:21:25 peter Exp Locker: peter $
d321 1
a321 1
	DOSF( if ( !(--failnum) )  goto BADSCREENOPEN );
d417 1
d419 1
a419 2

	DOSF( if ( !(--failnum) )  goto BADSCREENOPEN );
d429 2
d508 1
a508 1
	DOSF( if ( !(--failnum) )  goto BADSCREENOPEN );
d525 1
a525 1
	DOSF( if ( !(--failnum) )  goto BADSCREENOPEN );
d540 1
a540 1
	DOSF( if ( !(--failnum) )  goto BADSCREENOPEN );
d756 1
a756 1
	DOSF( if ( !(--failnum) )  goto BADSCREENOPEN );
d994 1
d1006 1
d1009 12
d1028 1
a1028 1
		*scpens = *scpens & depthmask;
d1089 1
a1089 1
    DOSF( if ( !(--failnum) )  goto BADSCREENOPEN );
d1222 1
a1222 1
    DOSF( if ( !(--failnum) )  goto BADSCREENOPEN );
d1242 1
a1242 1
    DOSF( if ( !(--failnum) )  goto BADSCREENOPEN );
d1271 1
a1271 1
    DOSF( if ( !(--failnum) )  goto BADSCREENOPEN );
d1280 1
a1280 1
    DOSF( if ( !(--failnum) )  goto BADSCREENOPEN );
d1301 1
a1301 1
    if ( doISM( itOPENSCREEN, sc, tags ) )
d1306 7
a1312 1
    DOSF( if ( !(--failnum) )  goto BADSCREENOPEN );
d1425 1
a1425 1
	for (gindex = 0; gindex < GADGETCOUNT; gindex++ )
d1437 1
a1437 1
	if ( XSC(sc)->ColorMap ) FreeColorMap( XSC(sc)->ColorMap );
d1483 5
a1487 2
 *	no failure cases
 * PZZZ: Soon to be, since attachScreen() can fail.
d1489 1
d1498 3
a1501 1
    static struct Point no_point = { 0, 0 };
d1511 1
a1511 1
	attachScreen( sc, parent );
d1523 1
a1523 1
	while ( tag = NextTagItem( &tstate ) )
d1531 1
a1531 1
		    attachScreen( child, sc );
d1536 52
a1587 1
		    attachScreen( child, sc );
d1589 6
d1598 1
a1598 34

    /* The SDEPTH_CHILDONLY flag has no bearing if this screen is
     * not a child.  If it is a child, it indicates we want to be
     * placed at the front/back of the family, not the whole list.
     */
    whichway = SDEPTH_TOFRONT | SDEPTH_INITIAL | SDEPTH_CHILDONLY;

    if ( TESTFLAG( sc->Flags, SCREENBEHIND) )
    {
	whichway = SDEPTH_TOBACK | SDEPTH_INITIAL | SDEPTH_CHILDONLY;
    }
    /* relinkScreen() takes care of linking the new screen into
     * the correct place.
     */
    relinkScreen( sc, whichway );

    /* coerce to proper mode */
    DOS( printf("OST: call coerceScreens\n") );
    /* Note that coerceScreens() will ensure that the screen's
     * position is legal, which means that if the new screen is
     * the child of some screen, then child's TopEdge is made
     * to not exceed its parent's, so we have no further work
     * in that regard.
     */
    coerceScreens( sc, FORCE );
    /* screenMouse(sc); * done in coerceScreens() */

    /* If the new screen has children, then we must ensure that
     * each child-screen is adjacent (in depth) to a family member,
     * and that each child's top edge doesn't exceed the parent's.
     */
    for ( node = XSC(sc)->Family.mlh_Head;
	succ = node->mln_Succ;
	node = succ )
d1600 2
a1601 2
	/* One of the screens on the Family list is the
	 * screen itself, and we don't want to act on it.
d1603 1
a1603 15
	if ( ( child = SCREENFROMNODE( node ) ) != sc )
	{
	    whichway = SDEPTH_TOBACK | SDEPTH_CHILDONLY;

	    if ( TESTFLAG( XSC(child)->PrivateFlags, PSF_CHILDFRONT ) )
	    {
		whichway = SDEPTH_TOFRONT | SDEPTH_CHILDONLY;
	    }
	    relinkScreen( child, whichway );

	    /* Ensure that the child's TopEdge doesn't exceed
	     * its parent's:
	     */
	    IMoveScreen( child, &no_point, SPOS_REVALIDATE|SPOS_NORETHINK );
	}
d1605 1
a1765 1
    struct MinNode *node, *succ;
d1794 4
a1797 12
    /* Automatically detach each child screen, if any */

    for ( node = XSC(OScreen)->Family.mlh_Head;
	succ = node->mln_Succ;
	node = succ )
    {
	/* Although one of the screens on the Family list is the
	 * screen itself, it's harmless to detach it, so we
	 * don't bother with the usual (child != OScreen) test.
	 */
	attachScreen( SCREENFROMNODE( node ), NULL );
    }
a1798 3
    /* Automatically detach this screen from any parent */
    attachScreen( OScreen, NULL );

d1829 24
@


38.40
log
@Now allocate a blank NewScreen structure on the stack, to save ROM.
Now use PENF_ instead of PEN_ flags.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.39 92/06/04 16:18:03 peter Exp Locker: peter $
d226 1
a226 1
 * OpenWorkbench uses this feature, as does the new SA_LikeWorkbench tag.
d995 1
a995 2
	     * or destination.  We need to do this to support
	     * the ability to specify pens ~0 to ~3
d1003 1
a1003 1
		    *scpens++ = *custompens++ & depthmask;
d1006 9
d1090 2
a1091 1
	 * SA_Pens is all about sharing.
d1130 1
a1130 1
	    if ( isDRIpen )
d1133 2
a1134 1
		 * that's how we'll allocate them.  We need do nothing here.
d1136 1
a1136 1
		DPEN( printf("Pen %ld in SA_Pens.  Will be shared.\n",p ) );
d1435 10
a1444 5
	DDPF( printf("free second rasinfo at %lx\n", 
	    sc->ViewPort.RasInfo->Next ) );
	jfreeMem(sc->ViewPort.RasInfo->Next, sizeof(struct RasInfo));
	jfreeMem(sc->ViewPort.RasInfo, sizeof(struct RasInfo));

a1711 1
    imsg->ExecMessage.mn_Node.ln_Type = NT_REPLYMSG;   /* ZZZ: ??? */
d1811 1
a1811 1
    struct Screen *openworkbench();
d1865 2
a1866 2
	IBase->Mouse.X = 0;
	IBase->Mouse.Y = 0;
d1875 1
a1875 1
	workscreen = openworkbench();		/* returns with VCount++ */
@


38.39
log
@Now knows about both sets of Prefs DrawInfo pens.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.38 92/06/03 17:34:29 peter Exp Locker: peter $
d71 1
a71 1
#define DPENS(x) ;	/* Graphics ObtainPen() stuff */
d99 1
a99 1

d101 2
a126 2
struct IBox mystdbox = { 0, 0, STDSCREENWIDTH, STDSCREENHEIGHT };

d131 1
d133 10
a142 2
    return ( OpenScreenTagList( ns, 
	( TESTFLAG( NS( Type ), NS_EXTENDED ) )? XNS(ns)->Extension: NULL ) );
d264 1
d279 10
d549 2
a550 5
    /* default is {0,0,-1,-1} */
    if ( ns )
	copyBox( &ns->LeftEdge, &screenbox );
    else
	copyBox( &mystdbox, &screenbox );
d905 3
a907 2
    sc->DetailPen =  GetUserTagData( SA_DetailPen, ns?ns->DetailPen:0, tags );
    sc->BlockPen =  GetUserTagData( SA_BlockPen, ns?ns->BlockPen:1, tags );
d928 1
a928 1
    XSC(sc)->SDrawInfo.dri_Version = RI_VERSION;
d1108 1
a1108 1
	    mode = PEN_NO_SETCOLOR;
d1126 1
a1126 1
		DPENS( printf("Pen %ld in SA_Pens.  Will be shared.\n",p ) );
d1135 2
a1136 2
		mode = PEN_NO_SETCOLOR | PEN_EXCLUSIVE;
		DPENS( printf("Pen %ld on unaware screen.  Will be exclusive.\n",p ) );
d1144 1
a1144 1
		DPENS( printf("Pen %ld on Workbench screen.  Will be shared.\n",p ) );
d1153 1
a1153 1
		DPENS( printf("Pen %ld on custom or aware pubscreen.  Will be free.\n",p ) );
d1158 1
a1158 1
		/* PEN_NO_SETCOLOR means ignore the RGB values
d1162 1
a1162 1
		DPENS( printf("Pen %ld obtained as mode %ld.\n", p, mode ) );
@


38.38
log
@OpenScreen() now fails with illegal depth.  Smartened up the
OpenScreen() failure-testing stuff.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.37 92/05/29 18:56:49 peter Exp Locker: peter $
d940 5
a944 1
	    scpens = IBase->ScreenPens;
@


38.37
log
@Took out debugging call to Debug().
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.36 92/05/29 18:29:21 peter Exp Locker: peter $
d67 3
a69 2
#define DOSF(x)	;	/* OpenScreen failure test code: */
			/* Use SA_Dummy to cause failure in difn't places
d301 1
a301 1
	DOSF( if (failnum == 1)  goto BADSCREENOPEN );
d399 1
a399 1
	DOSF( if (failnum == 2)  goto BADSCREENOPEN );
d481 1
a481 1
	if ( setScreenDisplayID( sc,  displayid, &errorcode, 0 ))
d486 1
a486 1
	DOSF( if (failnum == 3)  goto BADSCREENOPEN );
d491 15
d510 1
a510 1
    if ( TESTFLAG(  XSC(sc)->NaturalDProperties, DIPF_IS_DUALPF ) )
d518 1
a518 1
	DOSF( if (failnum == 4)  goto BADSCREENOPEN );
d737 1
a737 1
	DOSF( if (failnum == 5)  goto BADSCREENOPEN );
d1043 1
a1043 1
    DOSF( if (failnum == 6)  goto BADSCREENOPEN );
d1174 1
a1174 1
    DOSF( if (failnum == 7)  goto BADSCREENOPEN );
d1194 1
a1194 1
    DOSF( if (failnum == 8)  goto BADSCREENOPEN );
d1223 1
a1223 1
    DOSF( if (failnum == 9)  goto BADSCREENOPEN );
d1232 1
a1232 1
    DOSF( if (failnum == 10)  goto BADSCREENOPEN );
d1258 1
a1258 1
    DOSF( if (failnum == 11)  goto BADSCREENOPEN );
@


38.36
log
@The setScreenDisplayID() function now takes a force parameter which is
used for promotion.  Other changes to handle new style of promotion.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.35 92/05/27 16:07:32 peter Exp Locker: peter $
a263 1
    DOS( Debug() );
d555 1
a555 1

@


38.35
log
@Bar-pen colors weren't correctly initialized for compatible-mono screens.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.34 92/05/27 11:55:24 peter Exp Locker: peter $
d481 1
a481 1
	if ( setScreenDisplayID( sc,  displayid, &errorcode))
d553 1
a553 1
	displayOScan( NULL, XSC(sc)->NaturalDisplayID,
a662 9
    /*	Mode promotion							*/
    /* ---------------------------------------------------------------- */

    /* Now figure out what the screen's mode would be if
     * promotion is in effect, and this screen's frontmost
     */
    promoteScreen( sc );

    /* ---------------------------------------------------------------- */
d994 4
a997 2
	    /* Initialize all pens except for BARDETAILPEN and FILLTEXTPEN
	     * to the BlockPen value:
d1005 1
@


38.34
log
@Pens of ~0 gives all pens now.  Now supports SA_LikeWorkbench.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.33 92/05/21 17:44:00 peter Exp Locker: peter $
d983 2
d1003 8
a1010 6
	    spens[ TEXTPEN ] =
	    spens[ SHINEPEN ] =
	    spens[ SHADOWPEN ] =
	    spens[ HIGHLIGHTTEXTPEN ] =
	    spens[ FILLPEN ] = bpen;

@


38.33
log
@Put LOCKIBASE around access to pens.  Pens now come from IBase.  Now
call Alert() instead of execAlert().
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.32 92/04/14 15:46:17 peter Exp Locker: peter $
d137 1
a137 1
/* extern UWORD	fourColorPens[ NUMDRIPENS + 1 ]; */
d145 18
d168 56
d309 2
d317 13
d347 1
a347 2

    if ( !( depth = GetUserTagData( SA_Depth, NS( Depth ), tags ) ))
d465 5
d472 6
a477 2
	    displayid = 
		GetUserTagData( SA_DisplayID, NS(ViewModes) & OLD_MODES, tags );
d522 10
d539 2
a540 1
    stddclip = GetUserTagData( SA_Overscan, 0, tags );
a671 44
    /*	screen colors							*/
    /* ---------------------------------------------------------------- */
    DOS( printf("colors time\n") );

    /* need this be after VP linked in?  (can I move this back up?)*/
    /* initialize colors if user has specified a colorspec	*/
    /* ZZZ:
     *    do I want to actually SetRGB4? (no vp copper lists yet)
     *	  could a LoadRGB4() work out here?
     */

    DOS( printf("call setWBCG, for screen %lx\n", sc));

    /* provide for a way
     * that screens can inherit *ALL* the default colors.
     */
    setWBColorsGrunt( sc, GetUserTagData( SA_FullPalette, FALSE, tags ) );

    DOS( printf("setWBCG returned\n") );

    /* Extra brace to make local variables */
    {
        struct ColorSpec	*cspec = NULL;
	WORD			cindex;

	if ( cspec = (struct ColorSpec *) GetUserTagData( SA_Colors, 0, tags ) )
	{
	    DOS( printf("colorspec at %lx\n", cspec ) );

	    while ( ( cindex = cspec->ColorIndex ) != -1 )
	    {
		SetRGB4( vp, cindex, cspec->Red, cspec->Green, cspec->Blue );
		++cspec;
	    }
	}
    }

    /* LoadRGB32() takes a table.  We allow screen openers to
     * pass that table right to us.  Note that LoadRGB32( vp, NULL )
     * is a safe NOP.
     */
    LoadRGB32( vp, GetUserTagData( SA_Colors32, NULL, tags ) );

    /* ---------------------------------------------------------------- */
d705 6
a710 1
	if ( GetUserTagData( SA_Interleaved, FALSE, tags ) )
d754 47
d837 7
a843 1
	    sysfont = GetUserTagData( SA_SysFont, 0, tags );
d912 1
a912 1
	UWORD	*pens, *scpens, *spens;
d921 24
a944 2
	CopyMem( ( depth > 1 )? IBase->ScreenPens: twoColorPens,
	    spens, sizeof(UWORD) * (NUMDRIPENS+1) );
d953 6
a958 9
	/* The V39 BARBLOCKPEN, BARDETAILPEN, BARTRIMPEN default to the
	 * screen BlockPen and DetailPen respectively.
	 */ 
	spens[ BARBLOCKPEN ] = 
	spens[ BARTRIMPEN ] = bpen;
	spens[ BARDETAILPEN ] = dpen;

	/* only if he specifies SA_Pens does he get full treatment */
	if ( pens = (UWORD *) GetUserTagData( SA_Pens, 0, tags ) )
d960 4
a963 3

	    scpens = spens;

d966 5
a970 1
	    while ( *pens != ~0 && *scpens != ~0 )
d972 6
a977 1
		*scpens++ = *pens++;
@


38.32
log
@Use PackStructureTags() a bit.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.31 92/04/07 17:56:47 peter Exp Locker: peter $
d137 1
a137 1
extern UWORD	fourColorPens[ NUMDRIPENS + 1 ];
d795 1
d797 5
a801 4
	DRI( printf("render info pens sizes %ld %ld %ld\n",
	    sizeof fourColorPens, sizeof twoColorPens, sizeof XSC(sc)->SPens ) );
	CopyMem( ( depth > 1 )? fourColorPens: twoColorPens,
	    spens, sizeof twoColorPens );
d1681 1
a1681 1
	execAlert(AN_SysScrnType);
@


38.31
log
@Removed unused vble.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.30 92/04/02 21:40:23 peter Exp Locker: peter $
d46 4
d101 2
a102 3

/* correspondence between boolean tags and Screen.Type */
struct TagItem	ScreenFlagsMap[] =
d104 2
a105 6
    { SA_ShowTitle, SHOWTITLE },
    { SA_Behind, SCREENBEHIND },
    { SA_Quiet, SCREENQUIET },
    { SA_AutoScroll, AUTOSCROLL },
    { SA_SharePens, PENSHARED },
    { TAG_DONE }
d108 1
a108 2
/* correspondence between boolean tags and XScreen.PrivateFlags */
struct TagItem ScreenPrivateFlagsMap[] =
d110 12
a121 3
    { SA_Draggable, PSF_DRAGGABLE },
    { SA_Exclusive, PSF_EXCLUSIVE },
    { TAG_DONE }
d179 1
d238 6
a243 2
    longflags = PackBoolTags( (NS(Type)&~NS_EXTENDED)|SHOWTITLE,
		tags, ScreenFlagsMap );
d617 1
a617 3
    XSC(sc)->PrivateFlags = PackBoolTags(
	XSC(sc)->PrivateFlags | PSF_DRAGGABLE,
	tags, ScreenPrivateFlagsMap );
@


38.30
log
@On the WB, now grab pens ~0 to ~3 as shared.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.29 92/04/02 12:07:31 peter Exp Locker: peter $
a1254 1
    struct IntuitionBase	*IBase = fetchIBase();
a1406 2
    int	retval;

@


38.29
log
@No longer includes gfxbase.h.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.28 92/04/01 15:07:47 peter Exp Locker: peter $
d880 1
a880 1
	ULONG flags = 0;
d886 2
a887 2
	 * For unaware pubscreens, all other pens are allocated as
	 * exclusive, because the pubscreen could be a paint program,
d890 2
a891 2
	 * For aware pubscreens (those with {SA_SharePens,TRUE}),
	 * all other pens are unallocated. (The pubscreen owner can
d894 7
a900 2
	 * For custom screens (aware or not) we also leave the other
	 * pens unallocated, since there are no visitors to worry about.
a901 9
	 * For the Workbench screen, we make colors 0-3 sharable.
	 * This is a compromise because we want the Workbench to be
	 * as aware as possible, but some palette-sharing-unaware
	 * programs will exist there.  For them, we nail down 0-3.
	 *
	 */

	/* Public screens for which SA_SharePens is FALSE or absent
	 * end up with lots of exclusive pens.
a902 4
	if ( ( pubnode ) && ( !TESTFLAG( sc->Flags, PENSHARED ) ) )
	{
	    flags = PEN_EXCLUSIVE;
	}
d904 1
a904 1
	for ( p = 0; p < (1 << depth); p++ )
d910 1
a910 1
	    mode = 0;
d930 1
a930 1
	    else if ( flags == PEN_EXCLUSIVE )
d932 1
a932 1
		/* Pubscreens that do not request {SA_SharePens,TRUE}
d935 1
a935 1
		 * that owns the public screen.
d937 2
a938 2
		mode = PEN_EXCLUSIVE;
		DPENS( printf("Pen %ld on old pubscreen.  Will be exclusive.\n",p ) );
d940 2
a941 1
	    else if ( ( screentype == WBENCHSCREEN ) && ( p <= 3 ) )
d943 1
a943 1
		/* On the Workbench screen, pens 0-3 are
d946 1
a946 1
		DPENS( printf("Pen %ld on Workbench screen.  Will be exclusive.\n",p ) );
d963 1
a963 2
		ObtainPen( XSC(sc)->ColorMap, p, 0, 0, 0,
		    mode | PEN_NO_SETCOLOR );
@


38.28
log
@Evicted autodocs.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.27 92/03/26 18:42:53 peter Exp Locker: peter $
a19 4
#endif

#ifndef GRAPHICS_GFXBASE_H
#include <graphics/gfxbase.h>
@


38.27
log
@Now sets Screen->Flags PENSHARED if SA_SharePens is TRUE.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.26 92/03/26 16:38:58 peter Exp Locker: peter $
d79 1
a80 463
/****** intuition.library/OpenScreen ****************************************
*
*    NAME
*	OpenScreen -- Open an Intuition screen.
*
*    SYNOPSIS
*	Screen = OpenScreen( NewScreen )
*	D0		     A0
*
*	struct Screen *OpenScreen( struct NewScreen * );
*
*	or
*
*	struct Screen *OpenScreen( struct ExtNewScreen * );
*
*    FUNCTION
*	Opens an Intuition screen according to the specified parameters
*	found in the NewScreen structure.
*
*	Does all the allocations, sets up the screen structure and all
*	substructures completely, and links this screen's viewport into 
*	Intuition's View structure.
*
*	Before you call OpenScreen(), you must initialize an instance of
*	a NewScreen structure.  NewScreen is a structure that contains
*	all of the arguments needed to open a screen.  The NewScreen
*	structure may be discarded immediately after OpenScreen() returns.
*
*	The SHOWTITLE flag is set to TRUE by default when a screen is opened.
*	To change this, you must call the routine ShowTitle().
*
*    INPUTS
*	NewScreen = pointer to an instance of a NewScreen structure.
*
*	New for V36: 
*	In addition to the information contained in the NewScreen structure,
*	Intuition now recognizes extended data passed in the form
*	of an array of TagItem structures (from <utility/tagitem.h>),
*	commonly called a "tag list."
*
*	There are two ways to provide this array.  The first is to 
*	use the new Intuition entry point OpenScreenTagList() and 
*	pass the tag list as a parameter.  This is the recommended
*	method, and has a convenient format variation for C programs
*	using a variable number of arguments.
*
*	An older way used for some V36 development uses the OpenScreen()
*	entry point, and an extension of the NewScreen structure named
*	ExtNewScreen.  See the documentation of the flag NS_EXTENDED,
*	below.
*
*	While we recommend that you use OpenScreenTagList() rather than
*	OpenScreen() when using the extension tag list, we document
*	the tag ID values here, so that all parameters for opening
*	a screen can be found in one place.
*
*	NewScreen is initialized with the following information:
*	-------------------------------------------------------------
*	Left = initial x-position of your screen (should be zero for
*	releases prior to V36)
*
*	Top = initial y-position of the opening screen
*	(Note: Left and Top are specified relative to the Intuition's view,
*	in same resolution as the screen pixels.)
*
*	Width = the width for this screen's RastPort
*
*	Height = the height for his screen's RastPort, or the constant
*		STDSCREENHEIGHT to get the current default height (at
*		this time guaranteed to be at least 200 rows).  The normal
*		width and height for a particular system is stored by
*		the graphics.library in GfxBase->NormalDisplayRows and
*		GfxBase->NormalDisplayColumns.  These values will be different
*		depending on factors such as PAL video and overscan.
*
*		For V36, a new constant STDSCREENWIDTH is introduced.  It
*		serves the similar function for screen width.  Both
*		STDSCREENWIDTH and STDSCREENHEIGHT indicate that your
*		screen RastPort is to be the same dimensions as your
*		DisplayClip rectangle.  If you do not specify either a
*		standard or custom DisplayClip, the OSCAN_TEXT region
*		will be used, which corresponds to the standard dimensions
*		of V35 and earlier.
*
*		Furthermore, if you are using OpenScreenTagList(), and you
*		specify STDSCREENWIDTH, and you DO NOT provide a NewScreen
*		pointer, and you DO NOT provide SA_Left, then Intuition
*		will automatically set the LeftEdge of the screen to
*		be the left edge of the screen's DisplayClip region.
*		Likewise for STDSCREENHEIGHT and the screen's TopEdge.
*
*	Depth = number of bitplanes
*
*	DetailPen = pen number for details (like gadgets or text in title bar)
*	    The common value for this pen is 0.
*
*	BlockPen = pen number for block fills (like title bar)
*	    The common value for this pen is 1.
*
*	Type = screen type values
*	    Set these flags as desired from the set:
*	    CUSTOMSCREEN -- this is your own screen, not a system screen.
*	    CUSTOMBITMAP -- this custom screen has bit maps supplied
*		in the bitmap field of the NewScreen structure.  Intuition is
*		not to allocate any raster bitmaps.
*	    SCREENBEHIND -- your screen will be created behind all other open
*		screens.  This allows a program to prepare imagery in the
*		screen, change its colors, and so on, bringing it to the
*		front when it is presentable.
*	    SCREENQUIET -- Intuition will not render system screen gadgets or
*		screen title.  In concert with the WFLG_RMBTRAP flag on all
*		your screen's windows, this flag will prevent Intuition from
*		rendering into your screen's bitplanes.  Without WFLG_RMBTRAP
*		(or using the IDCMP_MENUVERIFY facility to cancel menu
*		operations), this flag will prevent Intuition from clearing
*		your menu bar, which is probably unacceptable.  The menu bar
*		layer may still overwrite  a portion of your screen bitmap
*		when the screen is opened.  (V36: it won't clobber your bits
*		any more.)
*	    NS_EXTENDED for this screen to use extended attributes pointed
*		to by the 'Extended' field, below.
*
*	ViewModes = the appropriate argument for the data type ViewPort.Modes.
*           These include:
*           HIRES for this screen to be HIRES width.
*           LACE for the display to switch to interlace.
*           SPRITES for this screen to use sprites (the pointer
*		sprite is always displayed)
*           DUALPF for dual-playfield mode (not supported yet)
*	    [For V36: The ViewModes field is superceded by a TagItem with
*	    tag value SA_DisplayID.]
*
*	Font = pointer to the default TextAttr structure for text in this 
*	    screen and all windows that open in this screen.  Text that uses
*	    this TextAttr includes title bars of both screen and windows,
*	    string gadgets, and menu titles.  Of course, IntuiText that
*	    specifies a NULL TextAttr field will use the screen/window default
*	    fonts.  NOTE: Intuition will *NOT* call OpenDiskFont(), so
*	    the TextAttr you supply must be in memory.  The ways to ensure
*	    that are to either use a ROM font (Topaz 8 or 9) or first
*	    call OpenDiskFont() to load the font, and don't close it
*	    until after your screen is successfully opened.
*	    [For V36: this is superceded by SA_Font and SA_SysFont.]
*
*	DefaultTitle = pointer to a line of text that will be displayed along
*	    the screen's title bar.  Null terminated, or just a NULL pointer
*           to get no text
*	    [For V36: superceded by SA_Title.]
*
*	Gadgets = This field should be set to NULL, since no user gadgets may
*	    be attached to a screen with the current versions of Intuition.
*
*	CustomBitMap = if you're not supplying a custom bitmap, this value is 
*           ignored.  However, if you have your own display memory that you
*           want used for this screen, the CustomBitMap field should point to
*	    the BitMap structure that describes your display memory.  See the
*           "Screens" chapter and the "Amiga ROM Kernel Manual" for more 
*           information about bitmaps.
*	    [For V36: this is superceded by SA_BitMap.]
*
*	[ All TagItem extensions below are new for V36.]
*	Extension = if NS_EXTENDED is set in NewScreen.Type, this pointer
*	    should point to an array (or chain of arrays) of TagItems,
*	    as defined in the include file <utility/tagitem.h>.   This
*	    field is only defined in the structure ExtNewScreen.
*	    The values to use for TagItem.ti_Tag are defined below.  We
*	    recommend that V36-specific applications use the new Intuition
*	    entry point OpenScreenTagList(), rather than using this field.
*	    The ExtNewScreen structure is a convenient way to give V36
*	    Intuition some information that V34 and earlier Intuition will
*	    ignore.
*
*	    Each TagItem is an optional tagged data structure which identifies
*	    an additional parameter to OpenScreen().  The applicable tag ID
*	    values for TagItem.ti_Tag and their corresponding data follow.
*
*	    Several of the tag items are alternative (and overriding) versions
*	    to familiar fields in NewScreen.  They are:
*
*	SA_Left
*	SA_Top
*	SA_Width
*	SA_Height
*	SA_Depth
*	SA_DetailPen
*	SA_BlockPen
*	SA_Title
*	SA_Font
*	SA_BitMap (whose existence also implies CUSTOMBITMAP). 
*
*	    Several tags are Booleans, which means that depending on whether
*	    their corresponding ti_Data field is zero (FALSE) or non-zero
*	    (TRUE), they specify Boolean attributes.  The ones corresponding
*	    to Boolean flags in the NewScreen.Type field are:
*
*	SA_ShowTitle
*	SA_Behind (equiv. to SCREENBEHIND)
*	SA_Quiet (equiv. to SCREENQUIET)
*
*	    The following tags provide extended information to Intuition
*	    when creating a screen:
*
*	SA_Type: ti_Data corresponds to the SCREENTYPE bits of the
*	    NewScreen.Type field.  This should be one of PUBLICSCREEN or
*	    CUSTOMSCREEN.  The other bits of the NewScreen.Type field
*	    must be set with the appropriate tags (SA_Behind, SA_Quiet,
*	    etc.)
*
*	SA_DisplayID: ti_Data is a 32-bit extended display mode ID
*	    as defined in <graphics/displayinfo.h>
*
*	SA_Overscan: ti_Data contains a defined constant specifying
*	    one of the system standard overscan dimensions appropriate for
*	    the display mode of the screen.  Used with the Width and
*	    Height dimensions STDSCREENWIDTH and STDSCREEN, this makes
*	    it trivial to open an overscanned or standard dimension
*	    screen.  You may also hand-pick your various dimensions
*	    for overscanned or other screens, by specifying screen position
*	    and dimensions explicitly, and by using SA_DClip to explicitly
*	    specify an overscanned DisplayClip region.
*
*	    The values for ti_Data of this tag are as follows:
*
*	    OSCAN_TEXT - Text Overscan region.  A region which is completely
*	    on screen and readable ("text safe").  A preferences data
*	    setting, this is backward equivalent with the old MoreRows,
*	    and specifies the DisplayClip and default dimensions of the
*	    Workbench screen.  This is the default.
*
*	    OSCAN_STANDARD - Also a preferences setting, this specifies
*	    a rectangle whose edges are "just out of view."  This yields
*	    the most efficient position and dimensions of on-monitor
*	    presentations, such as games and artwork.
*
*	    OSCAN_MAX - This is the largest rectangular region that the
*	    graphics library can handle "comfortably" for a given mode.
*	    Screens can smoothly scroll (hardware pan) within this region,
*	    and any DisplayClip or Screen region within this rectangle
*	    is also legal.  It is not a preferences item, but reflects
*	    the limits of the graphics hardware and software.
*
*	    OSCAN_VIDEO - This is the largest region that the graphics
*	    library can display, comfortable or not.  There is no guarantee
*	    that all smaller rectangles are valid.  This region is
*	    typically out of sight on any monitor or TV, but provides our
*	    best shot at "edge-to-edge" video generation.
*
*	    Remember, using overscan drastically effects memory use and
*	    chip memory bandwidth.  Always use the smallest (standard)
*	    overscan region that works for your application.
*
*	SA_DClip: ti_Data is a pointer to a rectangle which explicitly
*	    defines a DisplayClip region for this screen.  See QueryOverscan()
*	    for the role of the DisplayClip region.
*
*	    Except for overscan display screens, this parameter is
*	    unnecessary, and specifying a standard value using SA_Overscan
*	    is normally an easier way to get overscan.
*
*	SA_AutoScroll: this is a Boolean tag item, which specifies that
*	    this screens is to scroll automatically when the mouse pointer
*	    reaches the edge of the screen.  The operation of this requires
*	    that the screen dimensions be larger than its DisplayClip
*	    region.
*
*	SA_PubName: If this field is present (and ti_Data is non-NULL),
*	    it means that the screen is a public screen, and that
*	    the public screen name string is pointed to by ti_Data.
*	    Public screens are opened in "PRIVATE" mode and must
*	    be made public using PubScreenStatus().
*
*	SA_Pens: The ti_Data field (if non-NULL) points to a UWORD
*	    array of pen specification, as defined for struct DrawInfo.
*	    This array will be used to initialize the screen's
*	    DrawInfo.dri_Pens array.
*
*	    SA_Pens is also used to decide that a screen is ready
*	    to support the full-blown "new look" graphics.  If you
*	    want the 3D embossed look, you must provide this tag,
*	    and the ti_Data value cannot be NULL.  If it points
*	    to a "minimal" array, containing just the terminator ~0,
*	    you can specify "new look" without providing any values
*	    for the pen array.
*
*	The following two tag items specify the task and signal to be issued
*	to notify when the last "visitor" window closes on a public screen. 
*	This support is to assist envisioned public screen manager programs.
*
*	SA_PubTask:  Task to be signalled.  If absent (and SA_PubSig is
*	    valid), use the task which called OpenScreen() or
*	    OpenScreenTagList()).
*
*	SA_PubSig:  Data is a UBYTE signal number (not flag) used to notify
*	    a task when the last visitor window closes on a public screen.
*
*	SA_Colors: ti_Data points to an array of ColorSpec structures
*	    (terminated with ColorIndex = -1) which specify initial
*	    values of the screen's color palette.
*
*	SA_FullPalette: this is a Boolean attribute.  Prior to V36, there
*	    were just 7 RGB color values that Intuition maintained
*	    in its user preferences (playfield colors 0-3, and colors
*	    17-19 for the sprite).  When opening a screen, the color
*	    map for the screens viewport is first initialized by
*	    graphics (graphics.library/GetColorMap()) then these
*	    seven values are overridden to take the preferences values.
*
*	    In V36, Intuition maintains a full set of 32 preferences colors.
*	    If you specify TRUE for SA_FullPalette, Intuition will
*	    override ALL color map entries with its full suite of
*	    preferred colors.
*
*	SA_ErrorCode: ti_Data points to a ULONG in which Intuition will
*	    stick an extended error code if OpenScreen[TagList]() fails.
*	    Values are of this include 0, for success, and:
*	    OSERR_NOMONITOR	- monitor for display mode not available.
*	    OSERR_NOCHIPS	- you need newer custom chips for display mode.
*	    OSERR_NOMEM		- couldn't get normal memory
*	    OSERR_NOCHIPMEM	- couldn't get chip memory
*	    OSERR_PUBNOTUNIQUE	- public screen name already used
*	    OSERR_UNKNOWNMODE	- don't recognize display mode requested
*	    
*	    NOTE: These values are not the same as some similar return
*	    values defined in graphics.library/ModeNotAvailable().
*
*	SA_SysFont: ti_Data selects one of the system standard fonts
*	    specified in preferences.  This tag item overrides the
*	    NewScreen.Font field and the SA_Font tag item.
*
*	    Values recognized in ti_Data at present are:
*		0 - old DefaultFont, fixed-width, the default.
*		1 - Workbench screen preferred font.  You have to
*		    be very font sensitive to handle a proportional or
*		    larger than traditional screen font.
*
*	    NOTE WELL: if you select sysfont 1, windows opened on
*	    your screen will not inherit the screen font, but rather
*	    the window RastPort will be initialized to the old-style
*	    DefaultFont (sysfont 0).
*
*	Attached screen tags:  V39 supports attached screens, where
*	    one or more child screens can be associated with a parent
*	    screen.  Attached screens depth-arrange as a group, and
*	    always remain adjacent depth-wise.  Independent
*	    depth-arrangement of child screens is possible through
*	    the V39 ScreenDepth() call.  If a child screen is
*	    made non-draggable through {SA_Draggable, FALSE}, then
*	    it will drag exclusively with the parent.  Normal child
*	    screens drag independently of the parent, but are pulled
*	    down when the parent is.  Use the SA_Parent, SA_FrontChild,
*	    and SA_BackChild tags to attach screens.
*
*	SA_Parent: (New for V39) If you wish to attach this screen
*	    to an already-open parent screen, use this tag item
*	    and set ti_Data to point to the parent screen.
*	    (Ignored by V36/V37).  See also SA_FrontChild and
*	    SA_BackChild.
*
*	SA_FrontChild: (New for V39) If you wish to attach an
*	    already-open child screen to this screen, set ti_Data
*	    to point to the child screen.  The child screen will
*	    come to the front of the family defined by the
*	    parent screen you are opening.  (Ignored by V36/V37).
*	    See also SA_Parent and SA_BackChild.
*
*	SA_BackChild: (New for V39) If you wish to attach an
*	    already-open child screen to this screen, set ti_Data
*	    to point to the child screen.  The child screen will
*	    go to the back of the family defined by the parent
*	    screen you are opening.  (Ignored by V36/V37).
*	    See also SA_Parent and SA_FrontChild.
*
*	SA_BackFill: (New for V39) ti_Data is a pointer to a backfill
*	    hook for the screen's Layer_Info.  (Ignored by V36/V37).
*
*	SA_Draggable: (New for V39) ti_Data is a boolean.  Set to
*	    FALSE if you wish your screen to be non-draggable.  This
*	    tag should be used very sparingly!.  Defaults to TRUE.
*	    For child screens (see SA_Parent, SA_FrontChild, and
*	    SA_BackChild) this tag has a slightly different meaning:
*	    non-draggable child screens actually always drag exactly
*	    with the parent, as opposed to having relative freedom.
*	    (Ignored by V36/V37).  Also see ScreenPosition().
*
*	SA_Exclusive: (New for V39) ti_Data is a boolean.  Set to
*	    TRUE if you never want your screen to share the display
*	    with another screen.  This means that your screen can't
*	    be pulled down, and will not appear behind other screens
*	    that are pulled down.  Your screen may still be depth
*	    arranged, though.  Use this tag sparingly! Defaults to
*	    FALSE.  (Ignored by V36/V37).
*
*	SA_SharePens: (New for V39) For those pens in the screen's
*	    DrawInfo->dri_Pens, Intuition obtains them in shared mode
*	    (see graphics.library/ObtainPen()).  For compatibility,
*	    Intuition obtains the other pens of a public screen as
*	    PEN_EXCLUSIVE.  Screens that wish to manage the pens
*	    themselves should generally set this tag to TRUE.  This
*	    instructs Intuition to leave the other pens unallocated.
*	    Defaults to FALSE.  (Ignored by V36/V37).
*
*	SA_Colors32: (New for V39) Tag to set the screen's initial
*	    palette colors at 32 bits-per-gun.  ti_Data is a pointer
*	    to a table to be passed to the graphics.library/LoadRGB32()
*	    function.  This format supports both runs of color
*	    registers and sparse registers.  See the autodoc for that
*	    function for full details.  Any color set here has
*	    precedence over the same register set by SA_Colors.
*	    (Ignored by V36/V37).
*
*	SA_Interleaved: (New for V39) ti_Data is a boolean.  Set to
*	    TRUE to request an interleaved bitmap for your screen.
*	    Defaults to FALSE.  (Ignored by V36/V37).
*
*	SA_VideoControl: (New for V39) ti_Data points to a taglist
*	    that will be passed to VideoControl() after your screen
*	    is open.  You might use this to turn on border-sprites,
*	    for example.  (Ignored by V36/V37).
*
*	SA_ColorMapEntries: (New for V39) ti_Data is the number
*	    of entries that you wish Intuition to allocate for this
*	    screen's ColorMap.  Certain graphics.library features
*	    require a larger-than-default ColorMap.  (The default
*	    value is 1<<depth, but not less than 32).
*
*    RESULT
*	If all is well, returns the pointer to your new screen
*	If anything goes wrong, returns NULL, with further error
*	specification in the variable pointed to by the SA_ErrorCode
*	data field (V36 and later).
*
*    NOTE
*	By default, AmigaDOS requesters related to your process are put on
*	the Workbench screen (these are messages like "Disk Full").  If
*	you wish them to show up on custom screens, DOS must be told.
*	This fragment shows the procedure.  More information is available
*	in the AmigaDOS manuals.  Sample code fragment:
*
*	#include "libraries/dosextens.h"
*		...
*	struct Process	*process;
*	struct Window	*window;
*	APTR		temp;
*		...
*		process = (struct Process *) FindTask(NULL);
*		temp = process->pr_WindowPtr;	(save old value)
*		process->pr_WindowPtr = (APTR) window;
*		( use a pointer to any open window on your screen )
*			...
*		your code goes here
*			...
*		process->pr_WindowPtr = temp;
*		( restore value BEFORE CloseWindow() )
*		CloseWindow(window);
*
*    BUGS
*
*    SEE ALSO
*	OpenScreenTagList(), OpenWindow(), PrintIText(), CloseScreen(),
*	QueryOverscan() PubScreenStatus(), The Intuition Reference Manual,
*	utility/tagitem.h, graphics.library/ModeNotAvailable(),
*	diskfont.library/OpenDiskFont(), graphics.library/GetColorMap()
*****************************************************************************/
d137 1
a137 75
/****** intuition.library/OpenScreenTagList **************************
*
*   NAME	
*	OpenScreenTagList -- OpenScreen() with TagItem extension array. (V36)
*	OpenScreenTags -- Varargs stub for OpenScreenTagList. (V36)
*
*   SYNOPSIS
*	Screen = OpenScreenTagList( NewScreen, TagItems )
*	D0	  		    A0         A1
*
*	struct Screen *OpenScreenTagList( struct NewScreen *,
*		struct TagItem * );
*
*	Screen = OpenScreenTags( NewScreen, Tag1, ... )
*
*	struct Screen *OpenScreenTags( struct NewScreen *,
*		ULONG, ... );
*
*   FUNCTION
*	Provides an extension to the parameters passed to OpenScreen().
*	This extensions is in the form of (a pointer to) an array of
*	TagItem structures, which have to fields: ti_Tag, an ID identifying
*	the meaning of the other field, ti_Data.  See <utility/tagitem.h>.
*
*	The tag items can supplement or override the values in NewScreen.
*	In fact, you can pass a NULL value of the NewScreen pointer.
*	For that matter, if you pass NULL in both arguments, you'll get
*	a screen with defaults in all fields, including display mode,
*	depth, colors, dimension, title, and so on.  We ask that
*	you at least supply a title when you open a screen.
*
*	See OpenScreen() documentation for parameter specifications.
*
*   INPUTS
* 	NewScreen     - (optional) pointer to a NewScreen structure.
* 	TagItems      - (optional) pointer to (an array of) TagItem
*			structures, terminated by the value TAG_END.
*
*   RESULT
* 	Screen	- an open Intuition screen.  See OpenScreen() for
*		extended error codes when Screen is returned NULL.
*
*   EXAMPLE
*	The version using a variable number of arguments must be
*	created for each particular compiler, and may not have
*	an analogue in all versions.  For vanilla, 32-bit C
*	parameter passing conventions, this works (and will
*	appear in amiga.lib):
*    
*	struct Screen	*
*	OpenScreenTags( ns, tag1 )
*	struct NewScreen	*ns;
*	ULONG			tag1;
*	{
*	    struct Screen	*OpenScreenTagList();
*
*	    return ( OpenScreenTagList( ns, (struct TagItem *) &tag1 ) );
*	}
*
*   NOTES
*	We recommend this extension to OpenScreen() over using the
*	field ExtNewScreen.Extension.  However, the ExtNewScreen.Extension
*	is a convenient way to supply a few tags to V36 Intuition which
*	will be ignored by V34 Intuition.  See OpenScreen() documentation
*	for lots of details.
*
*   BUGS
*	
*
*   SEE ALSO
*	OpenScreen()
*
******************************************************************************
*
*/
d1415 1
a1415 40

/****** intuition.library/CloseScreen ****************************************
*
*    NAME
*	CloseScreen -- Close an Intuition screen.
*
*    SYNOPSIS
*	[Success =] CloseScreen( Screen )
*	[D0]	    		 A0
*
*	[BOOL] CloseScreen( struct Screen * );
*	\* returns BOOL in V36 and greater *\
*
*    FUNCTION
*	Unlinks the screen, unlinks the viewport, deallocates everything that
*	Intuition allocated when the screen was opened (using OpenScreen()).
*	Doesn't care whether or not there are still any windows attached to the
*	screen.  Doesn't try to close any attached windows; in fact, ignores
*	them altogether (but see below for changes in V36).
*
*	If this is the last screen to go, attempts to reopen Workbench.
*
*	New for V36: this function will refuse to close the screen
*	if there are windows open on the screen when CloseScreen() is
*	called.  This avoids the almost certain crash when a screen
*	is closed out from under a window.
*
*    INPUTS
*	Screen = pointer to the screen to be closed.
*
*    RESULT
*	New for V36: returns TRUE (1) if screen is closed,
*	returns FALSE (0) if screen had open windows when
*	called.
*
*    BUGS
*
*    SEE ALSO
*	OpenScreen()
*****************************************************************************/
@


38.26
log
@Now use modern names for DrawInfo pens.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.25 92/03/23 11:57:47 peter Exp Locker: peter $
d571 1
d1418 1
a1418 1
	BOOL allocate, isDRIpen;
d1447 1
a1447 1
	if ( ( pubnode ) && ( !GetUserTagData( SA_SharePens, FALSE, tags ) ) )
@


38.25
log
@Fixed autodocs.  Now handles SA_FrontChild and SA_BackChild.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.24 92/03/21 14:52:00 peter Exp Locker: peter $
d1333 2
a1334 2
	dpen = spens[ detailPen ] = sc->DetailPen;
	bpen = spens[ blockPen ] = sc->BlockPen;
@


38.24
log
@Major simplification/change in attached screens.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.23 92/03/19 15:52:32 peter Exp Locker: peter $
d420 31
a450 4
*	SA_Parent: (New for V39) ti_Data is a pointer to a parent
*	    screen that you wish to attach this screen to, for
*	    purposes of depth-arrangement and dragging (Ignored by
*	    V36/V37).  See also SA_FrontChild and SA_BackChild.
d458 5
a462 4
*	    For child screens (see SA_Parent) this tag has a slightly
*	    different meaning: non-draggable child screens actually
*	    always drag exactly with the parent, as opposed to
*	    having relative freedom.  (Ignored by V36/V37).
a1023 6
    /* jimm: 2/28/90: need to init vp offsets here, because
     * they aren't sync'd by RemakeDisplay
     */
    XSC(sc)->VPOffsetStash.X = vp->DxOffset = sc->LeftEdge;
    XSC(sc)->VPOffsetStash.Y = vp->DyOffset = sc->TopEdge;

d1636 11
d1808 1
d1833 1
a1833 3
	    child = (struct Screen *) tag->ti_Data;

	    if ( tag->ti_Tag == SA_FrontChild )
d1835 10
a1844 7
		SETFLAG( XSC(child)->PrivateFlags, PSF_CHILDFRONT );
		attachScreen( child, sc );
	    }
	    else if ( tag->ti_Tag == SA_BackChild )
	    {
		CLEARFLAG( XSC(child)->PrivateFlags, PSF_CHILDFRONT );
		attachScreen( child, sc );
d1864 11
a1887 1
	    static struct Point no_point = { 0, 0 };
d1899 1
a1899 1
	    IMoveScreen( child, &no_point, SMOVE_REVALIDATE );
a1901 5

    /* coerce to proper mode */
    DOS( printf("OST: call coerceScreens\n") );
    coerceScreens( sc, FORCE );
    /* screenMouse(sc); * done in coerceScreens() */
@


38.23
log
@No longer need to init ParentYOffset since that happens inside
attachScreen.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.22 92/03/18 11:49:51 peter Exp Locker: peter $
d423 1
a423 1
*	    V36/V37).  See also SetScreenAttrsA().
d1034 12
a1045 3
    /* These fields exist for attached screens.  Children is a list containing
     * a node for each (future) child.  FrontMember and BackMember point to
     * the frontmost and rearmost family member (i.e. child or self)
d1047 2
a1048 5
    NewList( &XSC(sc)->Children );
    XSC(sc)->FrontMember = XSC(sc)->BackMember = sc;

    attachScreen( sc, (struct Screen *)GetUserTagData( SA_Parent, NULL, tags ),
	FALSE );
d1602 1
a1602 1
    if ( doISM( itOPENSCREEN, sc ) )
a1682 1

d1684 1
a1684 2
    int			gindex;
    struct MinNode *child, *succ;
a1687 11
	/* Automatically detach this screen from any parent */
	attachScreen( sc, NULL, FALSE );

	/* Automatically detach any children of this screen */
	for ( child = XSC(sc)->Children.mlh_Head;
	    succ = child->mln_Succ;
	    child = succ )
	{
	    attachScreen( SCREENFROMNODE( child ), NULL, FALSE );
	}

d1759 3
d1763 1
d1765 1
a1765 1
IOpenScreen( sc )
d1767 1
d1770 5
d1776 43
a1818 1
    int whichway = SDEPTH_TOFRONT | SDEPTH_INITIAL | SDEPTH_CHILDONLY;
d1824 3
d1829 29
a1863 1

d2064 1
d2093 16
d2115 1
a2115 1
    delinkScreen( OScreen, TRUE );
a2140 33
/* Remove this screen from its family.
 * If reallydelink is TRUE, then remove it from the screen list too.
 */
delinkScreen(OScreen, reallydelink)
struct Screen *OScreen;
BOOL reallydelink;
{
    struct Screen 	*parent;
    struct IntuitionBase *IBase = fetchIBase();

    /* If this screen has a parent, and it turns out that this screen
     * is the parent's FrontMember or BackMember, then that field
     * has to be updated to the nextmost Front or Back Member...
     */
    if ( parent = XSC(OScreen)->ParentScreen )
    {
	if ( OScreen == XSC(parent)->FrontMember )
	{
	    XSC(parent)->FrontMember = OScreen->NextScreen;
	}
	if ( OScreen == XSC(parent)->BackMember )
	{
	    XSC(parent)->BackMember = (struct Screen *)previousThing( OScreen,
		&IBase->FirstScreen, 0 );
	}
    }
    if ( reallydelink )
    {
	delinkThing(OScreen, &(fetchIBase())->FirstScreen);
    }
}


a2223 186
}

/****** intuition.library/SetScreenAttrsA ***********************************
*
*    NAME
*	SetScreenAttrsA -- Change a screen's attributes. (V39)
*	SetScreenAttrs -- Varargs stub for SetScreenAttrsA() (V39)
*
*    SYNOPSIS
*	success = SetScreenAttrsA( screen, taglist )
*	D0                         A0      A1
*
*	ULONG SetScreenAttrsA( struct Screen *, struct TagItem * );
*
*	success = SetScreenAttrsA( screen, firsttag, ... )
*
*	ULONG SetScreenAttrs( struct Screen *, ULONG, ... );
*
*    FUNCTION
*	Changes several of the attributes of an already-open screen.
*	Only those tags listed here are changeable.  Consult the
*	autodoc for OpenScreen() for full detail on what those tags
*	do.
*
*	SA_Parent: ti_Data is a pointer to a parent screen that
*	    you wish to attach this screen to, for purposes of
*	    depth-arrangement and dragging.  You can detach a
*	    screen from its parent by passing in ti_Data of NULL.
*	    Note that closing a parent or child automatically
*	    detaches any children or parent respectively.
*
*	SA_Behind: If ti_Data is TRUE, requests that this screen
*	    be depth-arranged to the back of the screen list.  If
*	    the screen is a child screen and {SA_ChildOnly,TRUE}
*	    is also specified, then the screen will go to the back
*	    of its family instead.
*
*	SA_Front: If ti_Data is TRUE, requests that this screen
*	    be depth-arranged to the front of the screen list.  If
*	    the screen is a child screen and {SA_ChildOnly,TRUE}
*	    is also specified, then the screen will go to the front
*	    of its family instead.
*
*	SA_ChildOnly: Set ti_Data to TRUE to modify the behavior
*	    of SA_Front and SA_Behind to 
*
*	SA_Draggable: ti_Data is a boolean.  Set to FALSE if you
*	    wish your screen to be non-draggable.  Non-draggable
*	    child screens drag with respect to the parent only.
*	    This tag should be used very sparingly!
*
*	SA_Exclusive: ti_Data is a boolean.  Set to TRUE if you never
*	    want your screen to share the display with another screen.
*	    This means that your screen can't be pulled down, and will
*	    not appear behind other screens that are pulled down.  Your
*	    screen may still be depth arranged, though.  Use this tag
*	    sparingly!
*
*	SA_AutoScroll: this is a Boolean tag item, which specifies that
*	    this screens is to scroll automatically when the mouse pointer
*	    reaches the edge of the screen.  The operation of this requires
*	    that the screen dimensions be larger than its DisplayClip
*	    region.
*
*    INPUTS
*	Screen = pointer to the screen to be changed.
*	TagList = pointer to a taglist to operate on.
*
*    RESULT
*
*    BUGS
*
*    SEE ALSO
*	OpenScreen(), OpenScreenTagList()
*****************************************************************************/

/* THESE ARE NOT SUPPORTED YET
*
*	SA_ShowTitle: ti_Data is boolean.  Places the screen title bar
*	    in front of or behind any backdrop windows.  Also see
*	    ShowTitle().
*
*	SA_Colors: Sorry, not supported yet.
*
*	SA_Colors32: Tag to change the screen's palette colors at
*	    32 bits-per-gun.  ti_Data is a pointer to a table to be
*	    passed to the graphics.library/LoadRGB32() function.
*	    This format supports both runs of color registers and
*	    sparse registers.  See the autodoc for that function
*	    for full details.
*
*	SA_VideoControl: ti_Data points to a taglist that will be
*	    passed to VideoControl().  When you supply this tag,
*	    Intuition will call MakeScreen()/RethinkDisplay()
*	    for you.
*
*/

/* Here's a quick way to handle the various screen depth tags that
 * the caller may supply.  We can check the SDEPTH_DOIT flag to see
 * if anything interesting went by.  By masking off that bit, we then
 * have the correct flags.
 */
struct TagItem ScreenDepthMap[] =
{
    SA_Behind, SDEPTH_DOIT | SDEPTH_TOBACK,
    SA_Front,  SDEPTH_DOIT | SDEPTH_TOFRONT,
    SA_ChildOnly, SDEPTH_CHILDONLY,
};

SetScreenAttrsA( sc, taglist )
struct Screen *sc;
struct TagItem *taglist;
{
    struct TagItem *tstate = taglist;
    struct TagItem *tag;
    ULONG tidata;
    ULONG depth_flags;
    struct TagItem *NextTagItem();

    /* Pick up changes to SA_Draggable, SA_Exclusive */
    XSC(sc)->PrivateFlags = PackBoolTags( XSC(sc)->PrivateFlags,
	taglist, ScreenPrivateFlagsMap );

    /* Figure out what depth-arrangement (if any) the caller wanted */
    depth_flags = PackBoolTags( 0, taglist, ScreenDepthMap );

    while ( tag = NextTagItem( &tstate ) )
    {
	tidata = tag->ti_Data;
	switch ( tag->ti_Tag )
	{
	    case SA_AutoScroll:
		if ( tidata )
		{
		    SETFLAG( sc->Flags, AUTOSCROLL );
		}
		else
		{
		    CLEARFLAG( sc->Flags, AUTOSCROLL );
		}
		break;


#if 0 /* Currently compiled out for space reasons */
/* Is this necessary, since ShowTitle() works? (20 bytes) */
	    case SA_ShowTitle:
		ShowTitle( sc, tidata );
		break;

/* Why bother?  Use SA_Colors32 instead... */
	    case SA_Colors:
		break;

/* Well, this code is perfect, but do we really need it? (20 bytes) */
	    case SA_Colors32:
		/* At OpenScreen(), passes ti_Data to LoadRGB32() */
		LoadRGB32( &sc->ViewPort, tidata );
		break;

/* Well, this code is perfect, but do we really need it? (56 bytes) */
	    case SA_VideoControl:
		VideoControl( XSC(sc)->ColorMap, tidata );
		MakeScreen( sc );
		RethinkDisplay();
		break;
#endif
	}

	/* In the above switch statement, we merely noted which
	 * direction they wanted to depth-arrange the screen,
	 * if at all.  Now down here, based the presence or
	 * absence of SA_Parent, we attach the screen using
	 * that info or we depth-arrange regularly.
	 */
	if ( tag = FindTagItem( SA_Parent, taglist ) )
	{
	    /* Do the attachment, with re-linking */
	    attachScreen( sc, tag->ti_Data, TRUE );
	}
	else if ( TESTFLAG( depth_flags, SDEPTH_DOIT ) )
	{
	    /* Do regular depth-arrangement */
	    doISM( itDEPTHSCREEN, sc, NULL, depth_flags );
	}
    }
@


38.22
log
@Made attachScreen() function.  Added SetScreenAttrsA().  Renamed
SA_Attach to SA_Parent.  BarLayer now has a "no-backfill" hook.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.21 92/03/05 09:02:56 peter Exp Locker: peter $
d926 1
a926 2
    XSC(sc)->ParentYOffset = screenbox.Top =
	GetUserTagData( SA_Top, screenbox.Top, tags );
d2188 5
a2192 5
*	SA_Parent: (New for V39) ti_Data is a pointer to a parent
*	    screen that you wish to attach this screen to, for
*	    purposes of depth-arrangement and dragging.  You can
*	    detach a screen from its parent by passing in ti_Data
*	    of NULL.  Note that closing a parent or child automatically
d2195 26
a2220 10
*	SA_Draggable: (New for V39) ti_Data is a boolean.  Set to
*	    FALSE if you wish your screen to be non-draggable.  This
*	    tag should be used very sparingly!
*
*	SA_Exclusive: (New for V39) ti_Data is a boolean.  Set to
*	    TRUE if you never want your screen to share the display
*	    with another screen.  This means that your screen can't
*	    be pulled down, and will not appear behind other screens
*	    that are pulled down.  Your screen may still be depth
*	    arranged, though.  Use this tag sparingly!
d2242 3
a2244 3
*	SA_ShowTitle: (New for V39) ti_Data is boolean.  Places
*	    the screen title bar in front of or behind any backdrop
*	    windows.  Also see ShowTitle().
d2248 6
a2253 6
*	SA_Colors32: (New for V39) Tag to change the screen's palette
*	    colors at 32 bits-per-gun.  ti_Data is a pointer
*	    to a table to be passed to the graphics.library/LoadRGB32()
*	    function.  This format supports both runs of color
*	    registers and sparse registers.  See the autodoc for that
*	    function for full details.
d2255 3
a2257 3
*	SA_VideoControl: (New for V39) ti_Data points to a taglist
*	    that will be passed to VideoControl().  When you supply
*	    this tag, Intuition will call MakeScreen()/RethinkDisplay()
d2262 12
d2281 1
d2288 3
a2295 5
	    case SA_Parent:
		/* Do the attachment, with re-linking */
		attachScreen( sc, tidata, TRUE );
		break;

d2307 2
a2308 1
#if 0
a2312 1
#endif
a2313 1
#if 0
a2316 1
#endif
a2317 1
#if 0
a2322 1
#endif
a2323 1
#if 0
d2331 17
@


38.21
log
@Setting PrivateFlags cleared any existing flags (eg. PSF_INCOMPATIBLE).
Now depends on LoadRGB32(vp,NULL) being safe.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.20 92/03/04 09:29:28 peter Exp Locker: peter $
d420 1
a420 1
*	SA_Attach: (New for V39) ti_Data is a pointer to a parent
d423 1
a423 1
*	    V36/V37).
a424 8
*	SA_ChildDrag: (New for V39) Child screens can normally be
*	    dragged mostly independently of the parent screen.
*	    If the two screens are supposed to appear much like
*	    a single screen, then it is desirable that dragging
*	    the child be like dragging the parent.  Set ti_Data
*	    to FALSE to get a screen without independent child-drag.
*	    Defaults to TRUE.  (Ignored by V36/V37).
*
d431 4
a434 1
*	    (Ignored by V36/V37).
a550 1
    { SA_ChildDrag, PSF_CHILDDRAG },
a908 18
    /* ---------------------------------------------------------------- */
    /* Attached screens							*/
    /* ---------------------------------------------------------------- */

    /* These fields exist for attached screens.  Children is a list containing
     * a node for each (future) child.  FrontMember and BackMember point to
     * the frontmost and rearmost family member (i.e. child or self)
     */
    NewList( &XSC(sc)->Children );
    XSC(sc)->FrontMember = XSC(sc)->BackMember = sc;

    if ( XSC(sc)->ParentScreen = (struct Screen *)GetUserTagData( SA_Attach,
	NULL, tags ) )
    {
	/* Attach this child to its parent */
	AddTail( &XSC(XSC(sc)->ParentScreen)->Children, &XSC(sc)->ChildNode );
    }

d926 1
a926 1
    XSC(sc)->PullDownOffset = screenbox.Top =
d1030 15
d1112 4
a1115 4
     * SA_Draggable and SA_ChildDrag default to TRUE, so we set
     * those in the initial-flags.  Note also that setScreenDisplayID()
     * may have already set the PSF_INCOMPATIBLE flag, so we have to
     * preserve any flags already set in PrivateFlags.
d1118 1
a1118 1
	XSC(sc)->PrivateFlags | PSF_DRAGGABLE | PSF_CHILDDRAG,
d1573 1
a1573 1
	    TESTFLAG( longflags, SCREENQUIET)? LAYERS_NOBACKFILL : NULL,
d1681 1
d1685 7
a1691 1
	if ( XSC(sc)->ParentScreen )
d1693 1
a1693 1
	    Remove( &XSC(sc)->ChildNode );
d1695 1
d2023 1
a2023 1
    delinkScreen( OScreen );
d2049 4
a2052 2

delinkScreen(OScreen)
d2054 1
d2075 4
a2078 2

    delinkThing(OScreen, &(fetchIBase())->FirstScreen);
d2165 147
@


38.20
log
@Fixed defaults for SA_Draggable and SA_ChildDrag.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.19 92/03/03 16:34:05 peter Exp Locker: peter $
a1109 14
#if AA_KLUDGES
    /* Extra brace to make local variables */
    {
	ULONG *colortable;

	/* LoadRGB32() takes a table.  We allow screen openers to
	 * pass that table right to us.
	 */
	if ( colortable = (ULONG *)GetUserTagData( SA_Colors32, NULL, tags ) )
	{
	    LoadRGB32( vp, colortable );
	}
    }
#else
a1114 1
#endif
d1122 3
a1124 1
     * those in the initial-flags
d1126 2
a1127 1
    XSC(sc)->PrivateFlags = PackBoolTags( PSF_DRAGGABLE|PSF_CHILDDRAG,
@


38.19
log
@TopOffset renamed PullDown.  Renamed private screen flags.  Supports
new SA_Colors32, SA_VideoControl, and SA_ChildDrag tags.  Documented
new SA_ tags.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.18 92/02/21 17:03:54 peter Exp Locker: peter $
d1135 6
a1140 2
    /* Gather up PrivateFlags based on supplied tags */
    XSC(sc)->PrivateFlags = PackBoolTags( NULL, tags, ScreenPrivateFlagsMap );
@


38.18
log
@Renamed IScreenDepth() controls.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.17 92/02/20 12:15:40 peter Exp Locker: peter $
a419 6
*	SA_ColorMapEntries: (New for V39) ti_Data is the number
*	    of entries that you wish Intuition to allocate for this
*	    screen's ColorMap.  Certain graphics.library features
*	    require a larger-than-default ColorMap.  (The default
*	    value is 1<<depth, but not less than 32).
*
d425 8
d436 31
d468 1
a468 1
*	    true to request an interleaved bitmap for your screen.
d471 11
d541 3
a543 2
/* correspondence between boolean tags and NewScreen.Type	*/
struct TagItem	ScreenFlagsMap[] = {
d551 9
d832 4
a835 1
    /* tell graphics about attachements */
d839 1
a839 1
		TAG_DONE );
d950 1
a950 1
    XSC(sc)->TopOffset = screenbox.Top =
d1110 21
d1135 3
a1137 9
    if ( !GetUserTagData( SA_Draggable, TRUE, tags ) )
    {
	SETFLAG( XSC(sc)->PrivateFlags, PRIVSCF_NODRAG );
    }
    if ( GetUserTagData( SA_Exclusive, FALSE, tags ) )
    {
	SETFLAG( XSC(sc)->PrivateFlags, PRIVSCF_EXCLUSIVE );
    }
    
d1250 1
a1250 1
		SETFLAG( XSC(sc)->PrivateFlags, PRIVSCF_SCREENFONT );
@


38.17
log
@Now use screen->RastPort.BitMap instead of RealBitMap, since RealBitMap
no longer changes.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.16 92/02/17 17:15:38 peter Exp Locker: peter $
d869 2
a870 1
    if ( XSC(sc)->Parent = (struct Screen *)GetUserTagData( SA_Attach, NULL, tags ) )
d873 1
a873 1
	AddTail( &XSC(XSC(sc)->Parent)->Children, &XSC(sc)->ChildNode );
d1629 1
a1629 1
	if ( XSC(sc)->Parent )
d1711 1
a1711 1
    int whichway = S_TOFRONT | S_NO_DELINK;
d1715 1
a1715 1
	whichway = S_TOBACK | S_NO_DELINK;
d1997 1
a1997 1
    if ( parent = XSC(OScreen)->Parent )
@


38.16
log
@Now establish XSC(sc)->RealBitMap.  Now use XScreen->RealBitMap
instead of screen->sc_BitMap.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.15 92/02/05 15:39:03 peter Exp Locker: peter $
a1100 4
	 * NOTE WELL:  This bitmap pointer isn't installed into
	 * XSC(sc)->RealBitMap until a few lines down, so we can't
	 * have any failure conditions between here and there,
	 * else we won't be freeing the BitMap.
d1102 2
a1103 2
	if ( !( bitmap = AllocBitMap( sc->Width, sc->Height, depth,
	    bmflags, NULL ) ) )
d1108 1
d1116 11
a1126 18
    /* We'd like to keep a pointer to the real bitmap, the supplied
     * struct BitMap may not be kept around by old applications.
     * So there's a new tag that CUSTOMBITMAP applications can use
     * to help us out.  But we start by assuming we can use the real
     * bitmap.
     */
    XSC(sc)->RealBitMap = bitmap;

    if ( ( TESTFLAG( longflags, CUSTOMBITMAP ) ) &&
	( !GetUserTagData( SA_BitMapValid, FALSE, tags ) ) )
    {
	/* For compatibility, we've got to use the embedded screen
	 * bitmap for old CUSTOMBITMAP screens.
	 */
	XSC(sc)->RealBitMap = &sc->sc_BitMap;
    }

    DOSF( if (failnum == 5)  goto BADSCREENOPEN );
d1128 1
a1128 2
    sc->RastPort.BitMap = XSC(sc)->RealBitMap;
    sc->ViewPort.RasInfo->BitMap = XSC(sc)->RealBitMap;
d1494 1
a1494 1
	    XSC(sc)->RealBitMap,
d1515 1
a1515 1
	    XSC(sc)->RealBitMap, 0, 0, sc->Width - 1, sc->BarHeight,
@


38.15
log
@Now supports SA_Interleaved.  Minor autodoc fix.  CustomBitMaps through
NewScreen.Type of CUSTOMBITMAP were broken.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.14 92/01/28 12:39:41 peter Exp Locker: peter $
d640 1
a770 1
    sc->ViewPort.RasInfo->BitMap = &sc->sc_BitMap;
d1076 2
a1077 1
	/* Peter 22-Aug-90: SA_BitMap is supposed to imply CUSTOMBITMAP */
a1078 2
	/* and of course, that's an *embedded* BitMap */
	sc->sc_BitMap = *bitmap;
d1091 14
a1104 3
	/* New graphics.library function that takes care of initializing
	 * the BitMap and allocating the planes, while being aware of
	 * plane-alignment issues that AA brings.
d1106 2
a1107 2
	if ( AllocBitMapData( &sc->sc_BitMap, sc->Width, sc->Height, depth,
	     bmflags ) )
a1111 1
	DOSF( if (failnum == 5)  goto BADSCREENOPEN );
d1114 26
a1139 1
    sc->RastPort.BitMap = &sc->sc_BitMap;
d1505 1
a1505 1
	    &sc->sc_BitMap,
d1526 1
a1526 1
	    &sc->sc_BitMap, 0, 0, sc->Width - 1, sc->BarHeight,
d1691 1
a1691 1
	     * planes.
d1693 1
a1693 1
	    FreeBitMapData( &sc->sc_BitMap );
@


38.14
log
@Added missing WaitBlit() before freeing screen's bitmap.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.13 92/01/22 16:43:24 peter Exp Locker: peter $
d205 1
a205 1
*           INTERLACE for the display to switch to interlace.
d434 4
d632 2
a633 2
    ULONG  		longflags = 0;
    UWORD  		screentype;
d684 23
a938 1

d948 10
a1052 23
    /*	set up 'flags'							*/
    /* ---------------------------------------------------------------- */

    /* accumulate boolean state */
    DOS( printf(" newscreen flags (Type)  %lx\n", NS( Type ) ) );

    longflags = PackBoolTags( (NS(Type)&~NS_EXTENDED)|longflags|SHOWTITLE,
		tags, ScreenFlagsMap );
    DOS( printf("longflags accumulated %lx\n", longflags ) );

    /* screen type */
    screentype = GetUserTagData( SA_Type, NS( Type ) & SCREENTYPE, tags );

    if ( screentype != WBENCHSCREEN )
    {
	screentype = pubnode? PUBLICSCREEN: CUSTOMSCREEN;
    }
    longflags = (longflags & ~SCREENTYPE ) | screentype;

    DOS( printf("final flags/type are %lx\n", longflags ) );


    /* ---------------------------------------------------------------- */
d1078 1
a1078 1
	/* and of course, that's an *imbedded* BitMap */
d1083 2
d1088 4
d1097 1
a1097 1
	     BMF_DISPLAYABLE | BMF_CLEAR ) )
@


38.13
log
@Renamed OpenScreen() and OpenScreenTagList() so that when I call myself,
it goes through the LVO.
Clarified definition for SA_Type.
No longer test LayerInfo_extra before ThinLayerInfo(), since Mike now
guarantees safety of that.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.12 91/12/12 20:44:46 peter Exp Locker: peter $
d1629 6
@


38.12
log
@OpenScreenTagList() now calls promoteScreen().
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.11 91/11/25 16:54:24 peter Exp Locker: peter $
a267 1
*	SA_Type
d282 6
d505 1
a505 1
OpenScreen( ns )
d598 1
a598 1
OpenScreenTagList( ns, tags )
d1440 1
d1469 1
a1469 1
    DOSF( if (failnum == 8)  goto BADSCREENOPEN );
d1478 1
a1478 1
    DOSF( if (failnum == 9)  goto BADSCREENOPEN );
d1504 1
a1504 1
    DOSF( if (failnum == 10)  goto BADSCREENOPEN );
d1608 1
a1608 4
	if ( sc->LayerInfo.LayerInfo_extra )
	{
	    ThinLayerInfo( &sc->LayerInfo );
	}
@


38.11
log
@Uses new LAYERS_NOBACKFILL magic constant instead of a stub hook for
SCREENQUIET bar-layers and menu clip-layers.  Installs a no-op
layer-info backfill hook instead of poking the RastPort mask so that
disposing the menu-layer doesn't clear the underlying bits.  Now
supports SA_BackFill.  Removed PEN_NO_SETCOLOR kludge, since graphics
now has this feature.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.10 91/11/15 18:53:24 peter Exp Locker: peter $
d826 4
d964 12
d1083 4
d1257 4
d1279 4
@


38.10
log
@Fixed bug where depth of CUSTOMBITMAP screens was mis-handled.
Now calls ObtainPen() instead of AllocPalette() [name change only].
IOpenScreen() now calls coerceScreens() with FORCE.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.9 91/10/17 14:27:57 peter Exp Locker: peter $
d74 4
a77 50
#if AA_KLUDGES

/* myObtainPen() -> AllocPalette()/AllocCMEntry()/AllocColor()/ObtainPen()
 *	- implemented, but the flag asking it not to set colors is
 *	  not implented.  Also, the name is in flux.
 */


#ifndef PEN_COLOR_UNCHANGED
#define PEN_COLOR_UNCHANGED 2
#endif

#ifndef PEN_EXCLUSIVE
#define PEN_EXCLUSIVE PALETTE_EXCLUSIVE
#endif

/*
 * Obtain pen-entries from the ColorMap.  This function
 * implements the PEN_COLOR_UNCHANGED flag, which tells ObtainPen()
 * to not set the colors.
 *
 */

ULONG myObtainPen( cm, n, r, g, b, flags )
struct ColorMap *cm;
ULONG n;
ULONG r;
ULONG g;
ULONG b;
ULONG flags;

{
    ULONG colorbuf[3];

    if ( TESTFLAG( flags, PEN_COLOR_UNCHANGED ) )
    {
	/* In order to leave the color unchanged, we read it */
	GetRGB32( cm, n, 1, colorbuf );
	r = colorbuf[0];
	g = colorbuf[1];
	b = colorbuf[2];
    }
    return( ObtainPen( cm,n,r,g,b,flags ) );
}

#else

/* Someday, we can use the one in graphics.library ... */
#define myObtainPen(cm,n,r,g,b,flags) ObtainPen(cm,n,r,g,b,flags)

d426 3
a590 1
struct Hook	stubHook = { {}, stubReturn, NULL };
d1348 1
a1348 1
		/* PEN_COLOR_UNCHANGED means ignore the RGB values
d1351 2
a1352 2
		myObtainPen( XSC(sc)->ColorMap, p, 0, 0, 0,
		    mode | PEN_COLOR_UNCHANGED );
d1408 5
d1422 1
a1422 1
	    &stubHook,
d1425 5
d1441 1
a1441 1
	    TESTFLAG( longflags, SCREENQUIET)? &stubHook: NULL,
d1564 5
a1568 3
	    /* Peter 22-Jan-91: Set RastPort mask to zero so that
	     * the underlying bits aren't cleared.  Fixes bug in which
	     * custom bitmap screens were cleared during CloseScreen().
a1569 1
	    XSC(sc)->ClipLayer->rp->Mask = 0;
@


38.9
log
@SA_ColorMapEntries can no longer be used to reduce the number of entries
below the default.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.8 91/08/29 17:53:28 peter Exp Locker: peter $
d116 1
a116 1
    return( AllocPalette( cm,n,r,g,b,flags ) );
d726 17
d1081 2
a1082 4
    /* got to be careful here.
     * I am supposed to ignore ns->CustomBitMap if the
     * bit isn't set, but I want non-zero SA_BitMap to imply
     * custombitmap without the separate flag being set.
a1083 9

    bitmap = NULL;

    if ( TESTFLAG( longflags, CUSTOMBITMAP ) ) bitmap = NS( CustomBitMap );

    DCBM( printf( "NewScreen.CustomBitMap = $%lx\n", bitmap ) );
    bitmap = (struct BitMap *) GetUserTagData( SA_BitMap, bitmap, tags );
    DCBM( printf( "SA_BitMap makes it = $%lx\n", bitmap ) );

d1674 1
a1674 1
    coerceScreens( sc, NOFORCE );
@


38.8
log
@Now call AttachPalExtra() after bitmap is set up.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.7 91/08/21 18:20:06 peter Exp Locker: peter $
d734 1
a734 1
	 * never less than 32.  Can be overridden by SA_ColorMapEntries.
d738 2
a739 2
	entries = GetUserTagData( SA_ColorMapEntries, imax( 1<<depth, 32 ),
	    tags );
@


38.7
log
@Changed comments about V38 to V39.  Removed code to manage gfx < V38.
Now recognizes SA_Draggable and SA_Exclusive.
Now calls new graphics functions AllocBitMapData() and FreeBitMapData().
Now calls ObtainPen() through temp. placeholder.
New custom chip rev means we no longer need CLEAR_FMODE kludge. *poof*.
Now refers to screen->sc_BitMap instead of (equivalent) screen->BitMap,
for clarity.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.6 91/07/25 17:05:42 peter Exp Locker: peter $
a780 3
    AttachPalExtra( XSC(sc)->ColorMap, vp );

    DOS( printf("after AttachPalExtra\n") );
a782 1

d1104 8
@


38.6
log
@FMode poking kludge is now conditional on an IBase flag.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.5 91/07/25 15:03:21 peter Exp Locker: peter $
d70 1
d74 52
d461 1
a461 1
*	SA_ColorMapEntries: (New for V38) ti_Data is the number
d467 1
a467 1
*	SA_Attach: (New for V38) ti_Data is a pointer to a parent
d765 1
a765 1
    sc->ViewPort.RasInfo->BitMap = &sc->BitMap;
a772 8
#if AA_KLUDGES
    if ( ( IBase->GfxBase->LibNode.lib_Version > 37 ) &&
	( IBase->Flags & CLEAR_FMODE ) )
    {
	XSC(sc)->VPExtra->FMode = 0;
	XSC(sc)->VPExtra->Flags |= VPXF_HAVE_FMODE;
    }
#endif
d781 4
d786 1
d1050 13
d1087 1
a1087 1
	sc->BitMap = *bitmap;
a1090 2
	int	plane;

a1092 1
	InitBitMap( &sc->BitMap, depth, sc->Width, sc->Height);
d1094 6
a1099 1
	for ( plane = 0; plane < depth; plane++ )
d1101 2
a1102 11
	    if ( !(sc->BitMap.Planes[ plane ] = (PLANEPTR) AllocMem( 
		    RASSIZE(sc->Width, sc->Height),
		    MEMF_CLEAR | MEMF_PUBLIC | MEMF_CHIP ) ) )
	    {
		errorcode = OSERR_NOCHIPMEM;
		goto BADSCREENOPEN;
	    }
	    DOSF( if (failnum == 5)  goto BADSCREENOPEN );
	    DOS( printf("OpenScreen alloc plane %ld at %lx\n",
		plane, sc->BitMap.Planes[ plane ] ) );
	    DOS( printf( "rassize %ld\n", RASSIZE( sc->Width, sc->Height )) );
d1104 1
a1104 1
	/* use memf_clear SetRast(&sc->RastPort, 0);*/ 
d1220 1
a1220 1
	/* The V38 BARBLOCKPEN, BARDETAILPEN, BARTRIMPEN default to the
d1290 102
d1623 4
a1626 1
	    freeBitMapPlanes( &sc->sc_BitMap );
@


38.5
log
@OpenScreen() and CloseScreen() now handle attached screens.  Now uses
new whichway flags.  Eliminated some compiled-out code.  OpenScreen()'s
autodoc now lists SA_ColorMapEntries and SA_Attach.
Added an AA_KLUDGE to poke the FMode to zero and set the HAVE_FMODE flag.
@
text
@d5 1
a5 1
 *  $Id: screens.c,v 38.4 91/07/10 18:00:50 peter Exp Locker: peter $
d721 2
a722 1
    if ( IBase->GfxBase->LibNode.lib_Version > 37 )
@


38.4
log
@Deleted references to unused SDrawCount.  Now cache depth during
OpenScreen().  Other misc optimizations.  No longer can lose
sizeof(RasInfo) bytes if OpenScreen() fails.
Now allocates appropriate-sized ColorMap for AA chips, which
can be overridden with new SA_ColorMapEntries.
BARDETAILPEN and BARBLOCKPEN now have correct defaults.
New BARTRIMPEN.
@
text
@a0 1

d5 1
a5 1
 *  $Id: screens.c,v 38.3 91/06/24 12:16:03 peter Exp Locker: peter $
d408 11
d720 7
d806 13
d836 2
a837 1
    screenbox.Top = GetUserTagData( SA_Top, screenbox.Top, tags );
d871 1
a871 1
#if 1 /* auto-setting left/top to dclip only applies if STDSCREENdims given */
a878 1
#endif
d884 1
a884 1
#if 1 /* auto-setting left/top to dclip only applies if STDSCREENdims given */
a889 1
#endif
a892 15
#if 0 /* auto-setting left/top to dclip only applies if STDSCREENdims given */
    /* use DClip autoposition if NO left/top  have been
     * provided
     */
    if ( !ns && !FindTagItem( SA_Left, tags ) )
    {
	screenbox.Left = XSC(sc)->DClip.MinX;
    }

    if ( !ns && !FindTagItem( SA_Top, tags ) )
    {
	screenbox.Top = XSC(sc)->DClip.MinY;
    }
#endif

d1417 4
d1490 1
a1490 1
    struct IntuitionBase	*IBase = fetchIBase();;
d1492 2
d1496 1
a1496 7
	((struct Screen *)lastThing(&IBase->FirstScreen))->NextScreen = sc;
	sc->NextScreen = NULL;
    }
    else
    {
	sc->NextScreen = IBase->FirstScreen;
	IBase->FirstScreen = sc;
d1498 1
d1771 20
@


38.3
log
@No longer uses Alloc/FreeRemember().  More stuff moved into
closeScreenCommon().
@
text
@d6 1
a6 1
 *  $Id: screens.c,v 38.2 91/06/19 18:06:44 peter Exp Locker: peter $
d490 2
a491 2
extern UWORD	fourColorPens[ numDrIPens + 1 ];
extern UWORD	twoColorPens[ numDrIPens + 1 ];
a602 1
    struct ColorSpec	*cspec = NULL;
d606 1
d656 8
d669 26
a694 10
    if	(
	   (!( sc = (struct Screen *) AllocMem( 
		sizeof( struct XScreen ), MEMF_PUBLIC | MEMF_CLEAR) ))
	|| (!( rinfo = (struct RasInfo *) AllocMem( 
		sizeof(struct RasInfo), MEMF_PUBLIC | MEMF_CLEAR) ))
	|| (!(XSC(sc)->VPExtra=
		(struct ViewPortExtra *)GfxNew(VIEWPORT_EXTRA_TYPE)))
	|| (!( XSC(sc)->ColorMap = (USHORT *) GetColorMap(32) ))
	)
	goto BADSCREENOPEN;
a695 1
    DOSF( if (failnum == 2)  goto BADSCREENOPEN );
d944 1
a944 1
    if ( cspec = (struct ColorSpec *) GetUserTagData( SA_Colors, 0, tags ) )
d946 2
a947 2
	WORD	cindex;
	DOS( printf("colorspec at %lx\n", cspec ) );
d949 9
a957 4
	while ( ( cindex = cspec->ColorIndex ) != -1 )
	{
	    SetRGB4( vp, cindex, cspec->Red, cspec->Green, cspec->Blue );
	    ++cspec;
a1013 8
	int	depth;

#define NEWDEFAULTDEPTH (1)

	if ( !( depth = GetUserTagData( SA_Depth, NS( Depth ), tags ) ))
	{
	    depth = NEWDEFAULTDEPTH;
	}
d1019 1
a1019 1
	for ( plane = 0; plane < sc->BitMap.Depth; plane++ )
d1021 1
a1021 1
	    if ( !(sc->BitMap.Planes[ plane ] = (UBYTE *)AllocMem( 
d1023 1
a1023 1
		    MEMF_CLEAR | MEMF_PUBLIC | MEMF_CHIP) ))
a1123 1
    XSC(sc)->SDrawCount = -1;	/* never been used			*/
d1125 1
a1125 1
    XSC(sc)->SDrawInfo.dri_NumPens = numDrIPens;
d1127 1
a1127 1
    XSC(sc)->SDrawInfo.dri_Depth = sc->BitMap.Depth;
a1129 1
    XSC(sc)->SDrawInfo.dri_Pens = XSC(sc)->SPens;
a1130 6
    /* init pen array from one of two equal size hardcoded tables 	*/
    DRI( printf("render info pens sizes %ld %ld %ld\n",
	sizeof fourColorPens, sizeof twoColorPens, sizeof XSC(sc)->SPens ) );
    CopyMem( ( XSC(sc)->SDrawInfo.dri_Depth > 1 )? fourColorPens: twoColorPens,
	XSC(sc)->SPens, sizeof twoColorPens );
    /* override penspecs with (partial) list passed in SA_Pens	*/
d1132 1
a1132 1
	UWORD	*pens, *scpens;
d1135 10
d1146 9
a1154 2
	dpen = XSC(sc)->SPens[ detailPen ] = sc->DetailPen;
	bpen = XSC(sc)->SPens[ blockPen ] = sc->BlockPen;
d1159 2
a1160 1
	    scpens = XSC(sc)->SPens;
d1190 5
a1194 6
	    XSC(sc)->SPens[ BARBLOCKPEN ] =
	    XSC(sc)->SPens[ TEXTPEN ] =
	    XSC(sc)->SPens[ SHINEPEN ] =
	    XSC(sc)->SPens[ SHADOWPEN ] =
	    XSC(sc)->SPens[ HIGHLIGHTTEXTPEN ] = 	/* even this? */
	    XSC(sc)->SPens[ FILLPEN ] = bpen;
d1196 1
a1196 2
	    XSC(sc)->SPens[ BARDETAILPEN ] =
	    XSC(sc)->SPens[ FILLTEXTPEN ] = dpen;
@


38.2
log
@Removed !EMBOSSME and other obsolete code.
@
text
@d6 1
a6 1
 *  $Id: screens.c,v 38.1 91/06/12 15:12:26 peter Exp Locker: peter $
a585 1
    struct Remember		*rkey = NULL;
d648 1
a648 1
		    &rkey, &errorcode );
d662 1
a662 1
	   (!( sc = (struct Screen *) AllocRemember(&rkey, 
d664 1
a664 1
	|| (!( rinfo = (struct RasInfo *) AllocRemember(&rkey, 
d757 1
a757 1
	if (!(vp->RasInfo->Next = (struct RasInfo *)AllocRemember(&rkey, 
d1001 1
a1001 1
	    if ( !(sc->BitMap.Planes[ plane ] = (UBYTE *)AllocRemember(&rkey, 
d1308 4
a1321 1
    FreeRemember(&rkey, FALSE);
a1323 2
    DOS( printf("OST:FreeRemember returned\n") );

d1330 2
a1331 2
    closeScreenCommon( sc, TRUE );
    FreeRemember(&rkey, TRUE);
d1333 7
a1339 1
    sc = NULL;
d1364 1
a1364 1
 * by OpenScreenTagList's failurrm e, and by ICloseScreen.
d1367 1
a1367 1
closeScreenCommon( sc, freemonitor )
d1408 1
a1408 5
	if ( freemonitor && XSC(sc)->NaturalMSpec )
	{
	    CloseMonitor( XSC(sc)->NaturalMSpec );
	}

d1415 13
a1662 1
    struct MonitorSpec	*mspc;
a1678 2
    mspc = XSC(OScreen)->NaturalMSpec;

a1706 7
    closeScreenCommon( OScreen, FALSE );

    if ((OScreen->Flags & CUSTOMBITMAP) == 0)
    {
	freeBitMapPlanes( &OScreen->sc_BitMap );
    }

d1709 1
a1709 4
    DDPF( printf("free second rasinfo at %lx\n", 
	OScreen->ViewPort.RasInfo->Next ) );
    jfreeMem(OScreen->ViewPort.RasInfo->Next, sizeof(struct RasInfo));
    jfreeMem(OScreen->ViewPort.RasInfo, sizeof(struct RasInfo));
a1710 3
    /* finally, goodbye Screen! */
    FreeMem(OScreen, sizeof(struct XScreen));

a1717 2

    CloseMonitor( mspc );
@


38.1
log
@Enabled NewLook titlebar.
Establishes the new pens.
Now allocates and frees the standard scaled CheckMark and AmigaKey.
@
text
@d6 1
a6 1
 *  $Id: screens.c,v 36.86 91/04/10 17:46:34 peter Exp Locker: peter $
a52 2
#define QUIETHOOK	1	/* use null backfill for barlayer hook */

a568 1
#if QUIETHOOK
a571 1
#endif
a1260 1
#if QUIETHOOK
a1266 6
#else
    sc->BarLayer = (struct Layer *)CreateUpfrontHookLayer(
	    &sc->LayerInfo,
	    &sc->sc_BitMap, 0, 0, sc->Width - 1, sc->BarHeight,
	    LAYERSIMPLE | LAYERBACKDROP );
#endif
a1391 1
#if EMBOSSME
a1395 1
#endif
a1570 1
#if 1
a1571 3
#else
    struct MsgPort	*CreatePort();
#endif
a1575 1
#if 1
a1576 3
#else
    if ( ! ( port = CreatePort( NULL, 0 ) ) ) return ( FALSE );
#endif
a1596 1
#if 1
a1597 3
#else
	DeletePort( port );
#endif
a1604 1
#if 1
a1605 3
#else
    DeletePort( port );
#endif
a1611 1
#if 1
a1621 3
#else
    return ( doISM( itCLOSESCREEN, NULL ) );
#endif
a1660 1
#if 1
a1662 3
#else
	return ( TRUE );
#endif
a1732 14


#if 0	/* moved it inline	*/
installVPort(vport)
struct ViewPort *vport;
{
    struct IntuitionBase *IBase = fetchIBase();

    /* this assignment is valid whether AG.VL.ViewPort is NULL or real */
    vport->Next = IBase->ViewLord.ViewPort;
    IBase->ViewLord.ViewPort = vport;

}
#endif
@


38.0
log
@Initial V38 check-in (matches V37 release).
@
text
@d1 1
d6 1
a6 1
 *  $Id: screens.c,v 36.87 91/05/15 16:10:50 peter Exp $
d583 1
d1165 26
a1190 14
#ifdef NEWLOOK_TITLEBAR
	    XSC(sc)->SPens[ sbarfillPen ] =
#endif
	    XSC(sc)->SPens[ textPen ] =
	    XSC(sc)->SPens[ shinePen ] =
	    XSC(sc)->SPens[ shadowPen ] =
	    XSC(sc)->SPens[ hilighttextPen ] = 	/* even this? */
	    XSC(sc)->SPens[ hifillPen ] = bpen;

#ifdef NEWLOOK_TITLEBAR
	    XSC(sc)->SPens[ sbartextPen ] =
#endif
	    XSC(sc)->SPens[ hifilltextPen ] = dpen;
	}
d1192 1
d1225 1
a1225 1
    DOSF( if (failnum == 6)  goto BADSCREENOPEN );
d1263 1
a1263 1
    DOSF( if (failnum == 7)  goto BADSCREENOPEN );
d1279 1
a1279 1
    DOSF( if (failnum == 8)  goto BADSCREENOPEN );
d1305 1
a1305 1
    DOSF( if (failnum == 9)  goto BADSCREENOPEN );
d1423 3
@
