head     38.36;
branch   ;
access   ;
symbols  V40_85:38.36 V40_71:38.36 V40_68:38.36 V40_65:38.36 V40_47:38.36 V40_45:38.36 V40_37:38.36 V40_34:38.36 V40_29:38.36 V39_2415:38.36 V39_2369:38.35 V39_2339:38.34 V39_2332:38.34 V39_2275:38.33 V39_2256:38.33 V39_2210:38.33 V39_2192:38.33 V39_2084:38.33 V39_2082:38.33 V39_2076:38.33 V39_2073:38.33 V39_2058:38.33 V39_2051:38.33 V39_2031:38.33 V39_2017:38.33 V39_2012:38.33 V39_1985:38.33 V39_1933:38.33 V39_1819:38.32 V39_1805:38.31 V39_1783:38.30 V39_1695:38.30 V39_1621:38.29 V39_1620:38.29 V39_1508:38.29 V39_1485:38.28 V39_1461:38.27 V39_1458:38.27 V39_1456:38.27 V39_1405:38.26 V39_1368:38.25 V39_1360:38.25 V39_1324:38.24 V39_1147:38.22 V39_1143:38.22 V39_1141:38.22 V39_1120:38.21 V39_1116:38.21 V39_1104:38.21 V39_1100:38.21 V39_1078:38.21 V39_1073:38.21 V39_757:38.17 V39_702:38.16 V39_557:38.14 V39_553:38.14 V39_551:38.14 V39_510:38.13 V39_495:38.13 V39_416:38.11 V39_383:38.11 V39_371:38.10 V39_336:38.9 V39_323:38.9 V39_295:38.8 V39_277:38.8 V39_254:38.8 V39_222:38.7 V39_185:38.7 V39_171:38.7 V39_161:38.6 V38_159:38.6 V38_116:38.5 V38_59:38.3;
locks    ; strict;
comment  @*   @;


38.36
date     93.01.14.14.22.58;  author peter;  state Exp;
branches ;
next     38.35;

38.35
date     93.01.08.14.50.29;  author peter;  state Exp;
branches ;
next     38.34;

38.34
date     92.12.09.18.16.39;  author peter;  state Exp;
branches ;
next     38.33;

38.33
date     92.08.02.12.46.32;  author peter;  state Exp;
branches ;
next     38.32;

38.32
date     92.07.28.15.14.43;  author peter;  state Exp;
branches ;
next     38.31;

38.31
date     92.07.24.11.41.52;  author peter;  state Exp;
branches ;
next     38.30;

38.30
date     92.07.08.15.27.08;  author peter;  state Exp;
branches ;
next     38.29;

38.29
date     92.06.22.13.04.31;  author peter;  state Exp;
branches ;
next     38.28;

38.28
date     92.06.18.18.11.15;  author peter;  state Exp;
branches ;
next     38.27;

38.27
date     92.06.03.17.39.39;  author peter;  state Exp;
branches ;
next     38.26;

38.26
date     92.05.29.18.30.46;  author peter;  state Exp;
branches ;
next     38.25;

38.25
date     92.05.27.11.57.09;  author peter;  state Exp;
branches ;
next     38.24;

38.24
date     92.05.21.17.47.06;  author peter;  state Exp;
branches ;
next     38.23;

38.23
date     92.05.15.14.11.24;  author peter;  state Exp;
branches ;
next     38.22;

38.22
date     92.05.01.13.55.21;  author peter;  state Exp;
branches ;
next     38.21;

38.21
date     92.04.09.16.29.13;  author peter;  state Exp;
branches ;
next     38.20;

38.20
date     92.04.07.18.01.25;  author peter;  state Exp;
branches ;
next     38.19;

38.19
date     92.04.02.21.42.09;  author peter;  state Exp;
branches ;
next     38.18;

38.18
date     92.04.02.12.09.30;  author peter;  state Exp;
branches ;
next     38.17;

38.17
date     92.03.26.16.41.17;  author peter;  state Exp;
branches ;
next     38.16;

38.16
date     92.03.24.11.55.28;  author peter;  state Exp;
branches ;
next     38.15;

38.15
date     92.03.19.15.56.50;  author peter;  state Exp;
branches ;
next     38.14;

38.14
date     92.03.03.16.37.07;  author peter;  state Exp;
branches ;
next     38.13;

38.13
date     92.02.20.12.19.10;  author peter;  state Exp;
branches ;
next     38.12;

38.12
date     92.02.17.17.19.23;  author peter;  state Exp;
branches ;
next     38.11;

38.11
date     92.02.07.11.08.09;  author peter;  state Exp;
branches ;
next     38.10;

38.10
date     92.02.05.15.40.40;  author peter;  state Exp;
branches ;
next     38.9;

38.9
date     92.01.22.16.46.19;  author peter;  state Exp;
branches ;
next     38.8;

38.8
date     91.11.15.18.55.22;  author peter;  state Exp;
branches ;
next     38.7;

38.7
date     91.09.23.12.30.14;  author peter;  state Exp;
branches ;
next     38.6;

38.6
date     91.08.21.18.22.29;  author peter;  state Exp;
branches ;
next     38.5;

38.5
date     91.07.25.15.05.23;  author peter;  state Exp;
branches ;
next     38.4;

38.4
date     91.07.15.15.29.46;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     91.07.10.18.03.06;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     91.06.24.12.16.52;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.06.19.18.07.45;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.12.14.35.24;  author peter;  state Exp;
branches ;
next     ;


desc
@@


38.36
log
@hitScreen() now ensures IBase->HitScreen valid even when no screens
are in the system.
@
text
@
/*** windows.c ***************************************************************
 *
 *  windows.c for Windows and Screens
 *
 *  $Id: windows.c,v 38.35 93/01/08 14:50:29 peter Exp Locker: peter $
 *
 *  Confidential Information: Commodore-Amiga, Inc.
 *  Copyright (c) Commodore-Amiga, Inc.
 *
 ****************************************************************************/

#include "intuall.h"

#ifndef EXEC_MEMORY_H
#include <exec/memory.h>
#endif

#include "newlook.h"

#define DST(x)	;		/* show title		*/
#define DOW(x)	;		/* debug open window	*/
#define DGR(x)	;		/* debug getright() 	*/
#define DADD(x)	;		/* addSWGadgets()	*/
#define DEMB(x)	;		/* embossed look	*/
#define DSWT(x)	;		/* setwindowtitles	*/
#define DSW(x)	;		/* SizeWindow		*/

#define D(x)	;
#define DPS(x)	;	/* pub screens	*/
#define DCW(x)	;	/* close window	*/
#define DCW2(x)	;	/* close window	*/
#define DSIZE(x) ;	/* open window size checks */

/* = declarations ======================================================== */
struct Layer *getGimmeLayer(), *WhichLayer();
BOOL WindowLimits();

/* these arrays pair system gadget types with the
 * flags which are necessary to have them added.
 */
#define WGTYPECOUNT 5
USHORT WGadgetTypes[WGTYPECOUNT] =
    {
    WINDOWDEPTH,
    0,		/* special processing uses  'addzoom'	*/
    WINDOWSIZING,
    WINDOWCLOSE,
    WINDOWDRAG,
    };
USHORT WGadgets[WGTYPECOUNT] =
    {
    UPFRONTGADGET,
    ZOOMGADGET,
    SIZEGADGET, 
    CLOSEGADGET, 
    DRAGGADGET, 
    };




/* ======================================================================= */
/* ======================================================================= */
/* ======================================================================= */

struct Window *hitUpfront(layerhit)
struct Layer **layerhit;
/* uses global coordinates and window lists to find the window hit
 * this routine presumes that IBase->FirstScreen points to the
 * frontmost screen, and that they are sorted to the back
 * 
 * OLD WAY (V29): if a Screen is hit but no Window in the Screen is hit, call 
 * setWindow(NULL) and then setScreen() for that Screen 
 * before returning NULL
 *
 * NEW WAY (V1): if a Screen BarLayer is hit, set IBase->Flag HIT_BARLAYER and
 * don't disturb the active state of anything else
 */
{
    struct Layer *layer = NULL;
    struct Window *returnwindow;
    struct Screen *s;
    struct IntuitionBase *IBase = fetchIBase();
    struct Screen *hitScreen();

    returnwindow = NULL;

    CLEARFLAG(IBase->Flags, HIT_BARLAYER);

    if (s = hitScreen())
    {
	if (layer = WhichLayer(&s->LayerInfo, s->MouseX, s->MouseY))
	    goto LAYERHIT;
	goto SCREENHIT;
    }

    goto HITUPDONE;

LAYERHIT:
    /* we hit some layer in Screen s */
    /* did we hit the Screen BarLayer? */
    if (layer == s->BarLayer) 
    {
	returnwindow = IBase->ActiveWindow;
	SETFLAG(IBase->Flags, HIT_BARLAYER);
    }

    /* else we MUST have hit one of the Window's Layers
     * or requester layer
     */
    else
    {
	returnwindow = layer->Window;
    }

    goto HITUPDONE;

SCREENHIT:
    /* we hit a screen, but no layer in that screen */
    /* layer == NULL */
    /* returnwindow == NULL */

HITUPDONE:
    
    *layerhit = layer;
    return(returnwindow);
}

struct Screen *
hitScreen()
{
    struct IntuitionBase *IBase = fetchIBase();
    struct Screen *s;

    assertLock("hitScreen", IBASELOCK );

    for (s = IBase->FirstScreen; s; s = s->NextScreen)
    {
	if (s->ViewPort.Modes & VP_HIDE) continue;

	/* jimm: 2/25/88: use screen mouse instead of IBase->MouseX	*/

	/* this is the test to see if it is in screen	*/
	if (s->MouseY >= 0)
	{
	    return( IBase->HitScreen = ((s->MouseY >= s->Height)? NULL: s) );
	}
    }
    return( IBase->HitScreen = NULL );
}

/*** intuition.library/OpenWindow ***/


struct Window
*OpenWindow( nw )
struct ExtNewWindow *nw;
{
    struct Window *OpenWindowTagList();
    struct TagItem	*tlist = NULL;

    if ( nw && TESTFLAG( nw->Flags, NW_EXTENDED ) )
    {
	tlist = nw->Extension;

	/* A frustrating number of people put IDCMP_ACTIVEWINDOW into
	 * nw.Flags by mistake, where it's numerically equal to NW_EXTENDED.
	 * In hope of catching some of them, we look for a bad pointer,
	 * which is any odd pointer or any pointer not in RAM as reported
	 * by exec/TypeOfMem().
	 */

	if ( ( ( (ULONG) tlist ) & 1 ) || ( !TypeOfMem( tlist ) ) )
	{
	    tlist = NULL;
	}
    }
    return ( OpenWindowTagList( nw, tlist ) );
}

/*
 * default ISM processing for itOPENWIN
 * returns 0 for success: it's put back in it_Error
 */
IOpenWindow( w, superbmap, backfill )
struct Window 	*w;
struct BitMap	*superbmap;
void		*backfill;		/* layer backfill hook */
{
    struct Screen 	*sc = w->WScreen;

    /* refresh mode flags: key point is that for gimmezerozero window,
     * the larger layer is always simple refresh, and the inner one
     * is as requested in the Flags.  For normal window, the large
     * layer is the only layer, and refreshes as requested
     */
    ULONG 		refresh;
    ULONG		simple;
    ULONG		firstflags;

    struct Window	*parent;
    struct Layer	*layer = NULL;	
    struct Layer	*bdrlayer = NULL;
    struct RastPort	*rport;
    struct Layer 	*CreateUpfrontHookLayer();
    struct TextAttr	*wfont;

    DOW( printf("IOW: w %lx\n", w ) );

    /* ---------------------------------------------------------------- */
    /*	Calculate refresh mode for regular and gimmezerozero layers	*/
    /* ---------------------------------------------------------------- */

    if ((w->Flags & REFRESHBITS) == SUPER_BITMAP) refresh = LAYERSUPER;
    else if ((w->Flags & REFRESHBITS) == SIMPLE_REFRESH) refresh = LAYERSIMPLE;
    else refresh = LAYERSMART;

    simple = LAYERSIMPLE;
    if ( TESTFLAG( w->Flags, BACKDROP ) )
    {
	simple |= LAYERBACKDROP;
	refresh |= LAYERBACKDROP;
    }

    /* border layer for G00 is always simple refresh	*/
    if ( TESTFLAG( w->Flags, GIMMEZEROZERO ) )
	firstflags = simple;
    else
	firstflags = refresh;

    /* ---------------------------------------------------------------- */
    /*	Get Layers							*/
    /* ---------------------------------------------------------------- */
    LockLayerInfo( &sc->LayerInfo );

    DOW( printf("IOW: call CreateUpfrontHookLayer backfill %lx\n", 
	backfill) );
    DST( printf("IOW: about to create layer, flags %lx\n", firstflags));

    layer = CreateUpfrontHookLayer( &sc->LayerInfo, sc->RastPort.BitMap,
	    w->LeftEdge, w->TopEdge,
	    w->LeftEdge + w->Width - 1,
	    w->TopEdge + w->Height - 1,
	    firstflags, 
	    TESTFLAG( w->Flags, GIMMEZEROZERO )? NULL: backfill,
	    superbmap );

    DOW( printf("IOW: layer returned:%lx\n",layer) );

    if ( ! layer )	goto OUTBAD;

    rport = layer->rp;			/* comes already initialized	*/
    w->RPort = rport;

    /* jimm: 2/12/90: inherit vanilla font if screen has
     * used tricky new feature.
     */
    if ( TESTFLAG( XSC(sc)->PrivateFlags, PSF_SCREENFONT ) )
    {
	wfont = &fetchIBase()->SysFontPrefs[ 0 ];	/* vanilla sysfont */
    }
    else
    {
	wfont = sc->Font;
    }
    ISetFont( rport, wfont );
    w->IFont = rport->Font; /* save font just opened, for CloseWindow	*/

    layer->Window = w;
    w->WLayer = layer;

    /* if this Window is opened as BACKDROP, while the Screen is
     * supposed to have its Title behind all else, push the
     * Screen back now
     */
    if ( TESTFLAG( w->Flags, BACKDROP)  && (sc->Flags & SHOWTITLE)  )
    {
	struct Layer	*barlayer;

	/* move barlayer in front of new layer */
	DST( kpause("about to move bar layer in front of window"));

	barlayer = sc->BarLayer;
	MoveLayerInFrontOf( barlayer, layer );

	/* jimm: 1/17/90: update screenbar visuals */
	refreshScreenBar( sc );
    }

    /* ---------------------------------------------------------------- */
    /*	Get smaller GIMMEZEROZERO layer in front of border layer	*/
    /* ---------------------------------------------------------------- */
    if ( TESTFLAG( w->Flags, GIMMEZEROZERO ) )
    {
	/* large layer becomes the border layer */
	bdrlayer = layer;

	layer = CreateUpfrontHookLayer( &sc->LayerInfo, sc->RastPort.BitMap,
	    w->LeftEdge + w->BorderLeft,
	    w->TopEdge + w->BorderTop,
	    w->LeftEdge + w->Width - 1 - w->BorderRight,
	    w->TopEdge + w->Height - 1 - w->BorderBottom, 
	    refresh, 
	    backfill,
	    superbmap );

	/* move new layer in front of border layer	*/
	if ( layer == NULL || ! MoveLayerInFrontOf( layer, bdrlayer ) ) {
	    goto OUTBAD;
	}

	layer->Window = w;
	w->WLayer = layer;

	rport = layer->rp;
	rport->TmpRas = NULL;
	rport->AreaInfo = NULL;

	/* swap out old window rport and use new layer rport */
	w->BorderRPort = w->RPort;
	w->RPort = rport;
    }
    UnlockLayerInfo( &sc->LayerInfo );

    /* ---------------------------------------------------------------- */
    /*	Link window in to system					*/
    /* ---------------------------------------------------------------- */
    LOCKIBASE();

    w->Descendant = NULL;
    parent = fetchIBase()->ActiveWindow;

    if ( w->Parent = parent )
    {
	if ( parent->Descendant )
	{
	    parent->Descendant->Parent = w;
	    w->Descendant = parent->Descendant;
	}
	parent->Descendant = w;
    }

    w->NextWindow = sc->FirstWindow;
    sc->FirstWindow = w;

    UNLOCKIBASE();

    return ( 0 );	/* no error */

OUTBAD:		/* I am holding LayerInfo lock	*/
    /* delete what I got	*/
    if ( layer ) DeleteLayer( NULL, layer );
    if ( bdrlayer ) DeleteLayer( NULL, bdrlayer );
    if ( w->IFont ) CloseFont( w->IFont );
    /* Repair any damage that might have occurred during failure
     * to create a layer
     */
    BorderPatrol( w->WScreen );
    UnlockLayerInfo( &sc->LayerInfo );
    return ( 1 );
}



/*** intuition.library/CloseWindow ***/

CloseWindow(window)
struct Window *window;
{
    struct PubScreenNode *psn = NULL;

    /* right away */
    DCW2( printf("CloseWindow %lx ", window ) );
    DCW( printf("CloseWindow %lx %s.  ", window, window->Title ) );
    ModifyIDCMP(window, NULL);
    DCW( printf("CW: modifyidcmp returned ...") );

    /* We'll need to care for the public screen, if
     * this is a visitor.
     */
    if ( TESTFLAG( window->Flags, VISITOR ) )
    {
	/* make sure it's really a public screen,
	 * make sure I'm not being cheated on by a 
	 * replacement workbench screen with no PSNode!
	 */
	psn = XSC(window->WScreen)->PSNode;
    }

    /* Failure level of 2 indicates we must undo everything */
    closeWindowCommon( window, 2 );

    if ( psn )
    {
	/* Decrement the visitor count, and signal the screen's
	 * owner if this was the last visitor.
	 */
	if ( decPSNVisitor( psn ) == 0 )
	{
	    if ( psn->psn_SigTask )	/* does he want a signal	*/
	    {
		Signal( psn->psn_SigTask, 1 << psn->psn_SigBit );
	    }
	}
    }
    DCW( printf( "CloseWindow done\n") );
}


/* Window cleanup-code common to CloseWindow() and OpenWindow()-failure.
 * 'failure' = 1 indicates we didn't get to doISM in OpenWindowTagList().
 * 'failure' = 2 indicates we did, or we came from CloseWindow().
 */

closeWindowCommon( window, failure )

struct Window *window;
ULONG failure;

{
    struct IntuiMessage *message, *nextmessage;

    /* Peter 18-Dec-90: failure > 1 indicates we passed doISM.  In this
     * case, we must undo it with doISM(itCLOSEWIN).
     */
    if ( failure > 1 )
    {
	/* delink, activate Parent if I was active */
	doISM( itCLOSEWIN, window );
	DCW( printf("CW: doISM returned\n") );

	/* jimm: 6/25/86: close font i might have opened */
	/* jimm: 7/29/86: close just the font I opened   */
	CloseFont(window->IFont);
    }

    freeSysGadgets( window->FirstGadget );

    /* this linked list is safe because the window is delinked */
    message = window->MessageKey;
    while (message)
    {
	nextmessage = message->SpecialLink;
	/* Use AllocVec/FreeVec so freeing them is independent of
	 * size differences between tablet & non-tablet windows
	 */
	FreeVec( message );
	message = nextmessage;
    }

    FreeVec( window );
}

/*** intuition.library/ActivateWindow ***/

VOID
ActivateWindow(window)
struct Window *window;
{
    sendISM( itACTIVATEWIN, window, AWIN_NORMAL );
}

    
/* add the system window gadgets to the window, link them in.
 * special handling for drag gadget, since it isn't a "newstyle"
 * gadget and its height depends on the window top border height
 */
addSWGadgets(w, addzoom )
struct Window *w;
{
    ULONG flags, res;
    struct Gadget *g, *linkg;
    struct Gadget *createNewSysGadget();
    int count;
    BOOL gimme;

    /* determine resolution from screen */
    /* jimm: 8/26/86: eliminate screen parameter of addSWGadgets() */
    res = LOWRESGADGET;
    if (IsHires(w->WScreen)) res = HIRESGADGET;

    gimme = w->Flags & GIMMEZEROZERO;

    flags = w->Flags;
    linkg = (struct Gadget *) &w->FirstGadget;

    for (count = 0; count < WGTYPECOUNT; count++)
    {
	if ( ( flags & WGadgetTypes[count] ) ||
		(( WGadgets[count] == ZOOMGADGET ) && addzoom) )
	{

	    g = createNewSysGadget( w->WScreen, res, WGadgets[count], gimme );
	    /* link in new gadget to end of list */
	    if ( g )
	    {
		linkg->NextGadget = g;
		linkg = g;
		/* g->NextGadget = NULL; automatic */
	    }
	    else
	    {
		return 0;	/* caller will want to free list */
	    }

	    /* special adjustment for the height of the draggadget */
	    /* ZZZ: should be more oops? */
	    if ( WGadgets[count] == DRAGGADGET )
	    {
		g->Height = w->BorderTop - 1;
	    }
	}
    }

    /* all gadgets needed were gotten */
    return( 1 );
}


freeSysGadgets(g)
struct Gadget *g;
{
    struct Gadget *oldg, *workg;

    oldg = NULL;

    while (g)
    {
	workg = g->NextGadget;

	if (g->GadgetType & SYSGADGET)
	{
	    if (oldg) oldg->NextGadget = workg;
	    /* dispose, not free, system custom gadgets */
	    if (( g->GadgetType & GTYPEMASK ) == CUSTOMGADGET )
	    {
		DisposeObject( g );
	    }
	    else
	    {
		FreeMem(g, sizeof(struct Gadget));
	    }
	}
	else oldg = g;

	g = workg;
    }
}


int getleft(w)
struct Window *w;
/* welcome to kludge city.  here you will find me using hard-coded constants
 * rather than fetching the width values from the CloseWindow Gadgets
 * that will come someday, honest
 */
{
    if (w->Flags & WINDOWCLOSE)
    {
	return( IsHires(w->WScreen)? 30: 16);
    }
    else return(w->WScreen->WBorLeft);
}

#define GADGETPAD	(4)		/* margin before gadget */
/*
 * getright() returns the right edge of the drag-bar part.  This
 * starts at the window width.  If the window has zoom or depth
 * gadgets, the right-edge is moved accordingly.
 * We also account for GFLG_TOPBORDER GACT_RELRIGHT gadgets that
 * the application installed.
 *
 * Finally, the result has GADGETPAD taken off, for good measure.
 * One pixel is for the stripe, and the rest keep the window title
 * from abutting the last gadget.
 */
int getright( w )
struct Window	*w;
{
    struct Gadget *g;
    int	relright = 0;

    /* Snoop through the right-hand titlebar gadgets.  Application
     * gadgets that are there are GFLG_RELRIGHT and GACT_TOPBORDER.
     * For whatever reason, system gadgets in the top border are
     * not marked as TOPBORDER (though they are BORDERSNIFF).
     * So until we decide to change that, we have to look especially
     * for the two (GTYP_WUPFRONT and GTYP_WDOWNBACK, zoom and depth)
     * that we care about.
     */
    for ( g = w->FirstGadget; g; g=g->NextGadget )
    {
	UWORD sysgtype = g->GadgetType & GTYP_SYSTYPEMASK;
	if ( TESTFLAG(g->Flags, GRELRIGHT) &&
	    ( TESTFLAG( g->Activation, TOPBORDER ) ||
	    ( sysgtype == GTYP_WUPFRONT ) ||
	    ( sysgtype == GTYP_WDOWNBACK ) ) )
	{
	    DGR(printf("getright:top/rightgadget,old relright %ld\n",relright));
	    relright = imin( relright, g->LeftEdge );
	}
    }
    return ( relright + w->Width - 1 - GADGETPAD );
}

/*** intuition.library/RefreshWindowFrame ***/

RefreshWindowFrame( w )
struct Window *w;
{
    if ( knownWindow( w ) )
    {
	/* Bloody idiots are poking win->Title and calling
	 * RefreshWindowFrame(), so now I have to invalidate
	 * the WinTitleLength.  Here's to you, my chums...
	 */
	XWINDOW(w)->WinTitleLength = ~0;
	drawEmbossedBorder( w, DRAWGADGETS_ALL );
    }
}

/*
 * The draw_flags variable can be:
 *
 * DRAWGADGETS_ALL - means redraw the border and ALL gadgets in the window
 *	(used by RefreshWindowFrame(), BorderPatrol(),
 *	OpenWindowTagList(), and fixWindowBorders()).
 *
 * DRAWGADGETS_BORDER - means redraw the border, and just the gadgets
 *	clobbered by the border redraw (used by setWindow() to change
 *	activation).
 *
 * The final rendering order must be:
 *
 *	- Draw the window border fill
 *	- Draw the gadgets
 *	- Draw the window's 3D edges (after the gadgets, so the edges
 *	  "win" any fights over pixels)
 *
 * However, we've noted that it looks better if the edges get drawn
 * sooner, so that a repaired or new window's boundary becomes
 * well-defined sooner, not later.  Thus, the edges are drawn twice,
 * except that starting with 3.01, we skip the first drawing of edges
 * if draw_flags is DRAWGADGETS_BORDER, since that's just a change
 * in window activation, and our window is already well-bounded visually.
 *
 */
drawEmbossedBorder( w, draw_flags )
struct Window *w;
int draw_flags;
{
    if (! knownWindow(w)) return;

    LockLayerInfo(&w->WScreen->LayerInfo);
    LOCKGADGETS();
    if (w->BorderRPort) LockLayerRom( w->BorderRPort->Layer );
    LockLayerRom(w->WLayer);

    if ( draw_flags == DRAWGADGETS_ALL )
    {
	drawEmbossedEdges( w );
    }

    drawEmbossedWFill( w );	/* fill in border */

    drawGadgets( w, w->FirstGadget, -1, draw_flags );

    /* draw hilite/shadow edges again (!)	*/
    drawEmbossedEdges( w );

    UnlockLayerRom(w->WLayer);
    if (w->BorderRPort) UnlockLayerRom(w->BorderRPort->Layer);
    UNLOCKGADGETS();
    UnlockLayerInfo(&w->WScreen->LayerInfo);
}

/* RectFill() that filters out degenerate rect's */
SafeRectFill( rp, xmin, ymin, xmax, ymax )
struct RastPort *rp;
WORD xmin, ymin, xmax, ymax;
{
    if ( (xmax >= xmin) && (ymax >= ymin) )
    {
	RectFill( rp, xmin, ymin, xmax, ymax );
    }
}

drawEmbossedWFill( w )
struct Window *w;
{
    register struct RastPort *rp;
    register int right, bottom;
    int intop, inbottom;

    rp = obtainRP(&w->WScreen->RastPort, getGimmeLayer(w));
    /* rp->Mask = -1; already */

    /* Peter 26-Nov-90:  To reduce flashing and increase speed, we
     * will only fill INSIDE the border, trusting drawEmbossedEdges()
     * to do the rest.  That's why right and bottom are one less
     * than you'd expect.
     */
    right = w->Width - 2;
    bottom = w->Height - 2;

    /* fill borders with color for window activation */
    SetAPen(rp, embossedFillPen( w ) );

    /* inbottom is the pixel of the top embossed edge of the 
     * bottom border.  Likewise intop is the bottom embossed edge of
     * the top border.  We fill the four corners of the window in
     * the horizontal, not vertical RectFills.
     */
    inbottom = bottom - (w->BorderBottom-2);
    intop = w->BorderTop-1;

    SafeRectFill(rp, 1, intop, w->BorderLeft-2, inbottom);
    SafeRectFill(rp, right - (w->BorderRight-3), intop, right, inbottom);
    SafeRectFill(rp, 1, inbottom + 1, right, bottom);
    if ( w->BorderTop > 2 )
    {
	SafeRectFill(rp, 1, 1, right, intop - 1 );
	/* Don't bother RectFill()ing the remnant after the title */
	printEmbossedTitle( rp, w, FALSE );
    }
    freeRP(rp);
}


drawEmbossedEdges( w )
struct Window *w;
{
    register struct RastPort *rp;
    struct IBox	wbox;
    UWORD	*pens = XSC(w->WScreen)->SPens;

    if ( TESTFLAG( w->Flags, BORDERLESS ) ) return;

    rp = obtainRP(&w->WScreen->RastPort, getGimmeLayer(w));
    /* rp->Mask = -1; already */

    windowBox( w, &wbox );
    wbox.Left = wbox.Top = 0;	/* relative to window RPort */

    embossedBoxTrim( rp, &wbox,
	pens[ SHINEPEN ], pens[ SHADOWPEN ], JOINS_UPPER_LEFT_WINS );
    wbox.Left += w->BorderLeft - 1;
    wbox.Top += w->BorderTop - 1;
    wbox.Width -= (w->BorderLeft + w->BorderRight) - 2;
    wbox.Height -= (w->BorderTop + w->BorderBottom) - 2;

    embossedBoxTrim( rp, &wbox,
	pens[ SHADOWPEN ], pens[ SHINEPEN ], JOINS_UPPER_LEFT_WINS );

    freeRP(rp);
}

/*
 * refesh a possibly new  title string,
 * and refresh any gadgets you need to.
 */
updateEmbossedTitle( w )
struct Window	*w;
{
    struct RastPort	*rp;
    struct Gadget	*g;

    if ( w->BorderTop == 0 ) return;	/* compatibility */

    LockLayerInfo(&w->WScreen->LayerInfo);
    LOCKGADGETS();
    if (w->BorderRPort) LockLayerRom( w->BorderRPort->Layer );
    LockLayerRom(w->WLayer);
    rp = obtainRP( &w->WScreen->RastPort, getGimmeLayer( w ) );

    printEmbossedTitle( rp, w, TRUE );

    /* Peter 15-Jan-91: This freeRP used to be after the drawGadgets()
     * loop, but drawGadgets() itself calls obtainRP(), and you can't
     * nest those guys.
     */
    freeRP( rp );

    /* refresh all top border gadgets which were
     * not snooped out by getright
     */
    for (g = w->FirstGadget; g; g = g->NextGadget)
    {
	/* If a gadget is in the top border, and is not GRELRIGHT,
	 * we need to redraw it.  Note that we never try this
	 * for the drag-bar (which has no imagery, but only drawGadgets()
	 * knows that) because the drag-gadget is BORDERSNIFF but
	 * not explicitly TOPBORDER.
	 */
	if ( TESTFLAG(g->Activation, TOPBORDER) &&
	    ! TESTFLAG( g->Flags, GRELRIGHT ) )

	{
	    drawGadgets( w, g, 1, DRAWGADGETS_ALL );	/* refresh 1 */
	}
    }

    UnlockLayerRom(w->WLayer);
    if (w->BorderRPort) UnlockLayerRom(w->BorderRPort->Layer);
    UNLOCKGADGETS();
    UnlockLayerInfo(&w->WScreen->LayerInfo);
}

#define VBIG	(7000)

/*
 * clear old text from text portion of title bar,
 * and put new text in, if any
 */
printEmbossedTitle( rp, w, clearout )
struct RastPort	*rp;
struct Window	*w;
BOOL clearout;
{
    struct TextExtent te;
    struct Rectangle oldrect;
    int textright;
    int textleft;
    UWORD numchars;

    /* bail out if there is no title bar	*/
    if ( !w->Title  && !TESTFLAG( w->Flags, WINDOWDRAG ) ) return;

    /* text fit into title area */
    textright = getright( w );	/* and snoop out gadgets */
    textleft = getleft( w );

    oldrect = XWINDOW(w)->TitleExtent;

    /* position on baseline, at left of text region */
    Move( rp, textleft, FRAMEHTHICK + rp->TxBaseline );

    if (w->Title)
    {
	/* Peter 4-Feb-91: The WinTitleLength field stores the
	 * number of characters that fit for this window.
	 * By convention, ~0 means "unknown, recalculate and save".
	 */
	if ( ( numchars = XWINDOW(w)->WinTitleLength ) == ((UWORD)~0) )
	{
	    numchars = XWINDOW(w)->WinTitleLength =
		TextFit( rp, w->Title,
		    strlen( w->Title), &te, NULL, 1,
		    textright - textleft, VBIG );

	    TextExtent( rp, w->Title, numchars, &te );
	    XWINDOW(w)->TitleExtent = te.te_Extent;
	    offsetRect( &XWINDOW(w)->TitleExtent, textleft,
		FRAMEHTHICK + rp->TxBaseline );
	}
    }
    else
    {
	degenerateRect( &XWINDOW(w)->TitleExtent );
    }

    /* refill in any leftover title region */
    if ( clearout )
    {
	fillAround( rp, &oldrect, &XWINDOW(w)->TitleExtent, embossedFillPen( w ), ~0 );
    }

    /* print any text I might have here */
    if ( (w->Title) && ( numchars > 0 ) )
    {
	SetABPenDrMd( rp, XSC(w->WScreen)->SPens[ 
	    TESTFLAG( w->Flags,  WINDOWACTIVE )? FILLTEXTPEN: TEXTPEN ],
	    embossedFillPen( w ), JAM2 );
	/* ZZZ: do I get the right font? */

	/* I am already in position */
	Text( rp, w->Title, numchars );
    }
}

embossedFillPen( w )
struct Window	*w;
{
    long pen = XSC(w->WScreen)->SPens[ BACKGROUNDPEN ];

    if ( TESTFLAG( w->Flags, WINDOWACTIVE ) )
    {
	pen = XSC(w->WScreen)->SPens[ FILLPEN ];
    }
    return( pen );
}

/***********************************************************/

/* Sets the window as the ActiveWindow.  If the Window arg is NULL,
 * then the ActiveWindow will be NULL
 * if this Window has its own Pointer, we use it, else we use Intuition's
 *
 * Note for things in this routine that rely on IBase->ActiveWindow:
 *
 * startIdleWindow() NULL's out IBase->ActiveWindow so an
 * active window doesn't get an INACTIVATEWINDOW message and a
 * re-rendering as it closes.
 *
 * The variable "initial" is TRUE to indicate the initial activation
 * of this window.  This tells us to draw all the gadgets.
 */
setWindow( w, initial )
struct Window *w;
LONG initial;
{
    struct Window *AWindow;
    struct Screen *OldAScreen;
    struct IntuitionBase *IBase = fetchIBase();

    assertLock( "setWindow", IBASELOCK );

    /* Peter 2-Dec-90: knownWindow() returns FALSE if w==NULL */
    if (! knownWindow(w)) 
    {
	w = NULL;
    }

    /* Restore things so that we're sure that we'll send a new
     * GADGETHELP event as soon as possible:
     */
    IBase->LastTimeX = IBase->MouseX;
    IBase->LastTimeY = IBase->MouseY;
    IBase->HelpGadget = NULL;

    /* Peter 2-Dec-90:  The idea is that the only screen title which
     * may not be its default is the title of the screen of the active
     * window.
     * Thus, if we're setting "no active window" or changing
     * which screen has the active window, we have to restore the
     * title of the previous ActiveScreen (if there was one) to default.
     */
    if ( (OldAScreen = IBase->ActiveScreen ) &&
	( ( w == NULL ) || ( w->WScreen != OldAScreen ) ) )
    {
	/* Update title of the old screen if it's not the default */
	if (OldAScreen->Title != OldAScreen->DefaultTitle)
	{
	    OldAScreen->Title = OldAScreen->DefaultTitle;
	    screenbar( OldAScreen );
	}
    }

    if (AWindow = IBase->ActiveWindow) 
    {
	/* De-activate the window
	 *
	 * jimm: 5/2/86: got to let application know to
	 * let go of any layerromlock
	 */
	activeEvent(IECLASS_INACTIVEWINDOW, NULL );
	CLEARFLAG( AWindow->Flags, WINDOWACTIVE );

	/* redraw border and border gadgets only */
	drawEmbossedBorder( AWindow, DRAWGADGETS_BORDER );
    }

    /* set the system global ActiveWindow Pointer */
    IBase->ActiveWindow = w;
    IBase->MenuSelected = MENUNULL;
    IBase->MenuDrawn = MENUNULL;

    /* old one of two * activeEvent( IECLASS_EVENT, IECODE_NEWACTIVE ); */

    /* tell console device about active window change */
    activeEvent( IECLASS_EVENT, IECODE_NEWACTIVE );

    if (w == NULL)
    {
	setMousePointer();
    }
    else
    {
	resetMenu(w, ~MIDRAWN,
	    ~ISDRAWN & ~HIGHITEM & ~MENUTOGGLED, ~HIGHITEM & ~MENUTOGGLED);

	SETFLAG( w->Flags, WINDOWACTIVE );

	activeEvent(IECLASS_ACTIVEWINDOW, NULL );

	/* Screen Title Algorithm:
	 * Every time a Window is opened, it's ScreenTitle is set equal to the
	 * Title of the Screen.  Every time a Window is activated, its 
	 * ScreenTitle variable is compared with the Title variable of the Screen.
	 * If they are different, the Screen's Title variable will get a copy
	 * of the Screen's ScreenTitle variable, and the Screen Title Bar will
	 * be redrawn
	 */
	if (w->WScreen->Title != w->ScreenTitle)
	    {
	    w->WScreen->Title = w->ScreenTitle;
	    screenbar(w->WScreen);
	    }
	
	setScreen( w->WScreen );

	/** jimm: i don't know why it was here, but it's smaller now */
	windowMouse( w );

	setMousePointer();

	/* Redraw the border and the border gadgets.  However, if this is the
	 * initial activation of a window, draw all the gadgets.
	 */
	{
	    int draw_flags = DRAWGADGETS_ALL;
	    if ( !initial )
	    {
		draw_flags = DRAWGADGETS_BORDER;
	    }
	    drawEmbossedBorder( w, draw_flags );
	}
    }
}

/*** intuition.library/MenuLend ***/

/* Set up menu lending in the 'fromwindow'.  'towindow' is the
 * window whose menus are to be used, or NULL to disconnect.
 */
LendMenus( fromwindow, towindow )
struct Window *fromwindow;
struct Window *towindow;
{
    /* The XWINDOW()->MenuLend field is examined inside the
     * state machine...
     */
    LOCKSTATE(); /* OK since we're not doing any complex work here... */
    XWINDOW(fromwindow)->MenuLend = towindow;
    UNLOCKSTATE();
}

/*** intuition.library/SetWindowTitles ***/

SetWindowTitles(window, windowtitle, screentitle)
struct Window *window;
UBYTE *windowtitle, *screentitle;
{
    if ((LONG)windowtitle != -1)
    {
	window->Title = windowtitle;
	/* Mark as invalid the cached length of the window title */
	XWINDOW(window)->WinTitleLength = ~0;
	updateEmbossedTitle( window );
    }

    /* Peter 1-Feb-91:
     * SimCity calls SetWindowTitles( garbage, -1, valid_scr_title ),
     * so to help them we put in a quick kludge that is likely to
     * tell us when the first parameter is garbage or a window.
     */
    if ( ((LONG)screentitle != -1) &&
	( window->WLayer->Window == window ) )
	{
	window->ScreenTitle = screentitle;
	if (window->Flags & WINDOWACTIVE)
	    {
	    window->WScreen->Title = screentitle;
	    screenbar(window->WScreen);
	    }
	}
}


/*** intuition.library/WindowLimits ***/

/* You could pass in negative minwidth/minheight before, and that
 * snuck through this code because those variables are defined as
 * signed.  You can't turn a window inside-out because something
 * (probably around layer resizing) fails.  Anyways, it might
 * be a good idea to limit negative values to 1.
 */

BOOL WindowLimits(window, minwidth, minheight, maxwidth, maxheight)
struct Window *window;
SHORT minwidth, minheight;
USHORT maxwidth, maxheight;
{
    BOOL goodsizes;

    goodsizes = TRUE;

    if (minwidth)
    {
	if (minwidth > window->Width) goodsizes = FALSE;
	else window->MinWidth = minwidth;
    }

    if (minheight)
    {
	if (minheight > window->Height) goodsizes = FALSE;
	else window->MinHeight = minheight;
    }

    if (maxwidth)
    {
	if (maxwidth < window->Width) goodsizes = FALSE;
	else window->MaxWidth = maxwidth;
    }

    if (maxheight)
    {
	if (maxheight < window->Height) goodsizes = FALSE;
	else window->MaxHeight = maxheight;
    }

    return(goodsizes);
}


/*** intuition.library/MoveWindow ***/

MoveWindow(window, dx, dy)
struct Window *window;
int dx, dy;
{
    struct IBox	newbox;
    /* Can't convert to absolutes upon entry, since a Move-Size succession
     * would then behave differently under 2.0.
     */
    newbox.Left = dx;
    newbox.Top = dy;
    sendISMNoQuick( itCHANGEWIN, window, &newbox,
	CWSUB_MOVEDELTA | CWSUBQ_PROGRAMMATIC );
}



/*** intuition.library/SizeWindow ***/

SizeWindow(window, dx, dy)
struct Window *window;
SHORT dx, dy;
{
    struct IBox	newbox;


    DSW( printf("SizeWindow %lx, %ld/%ld\n", window, dx, dy ) );
    newbox.Width = dx;
    newbox.Height = dy;
    sendISMNoQuick( itCHANGEWIN, window, &newbox,
	CWSUB_SIZEDELTA | CWSUBQ_PROGRAMMATIC | CWSUBQ_SIZING );
}

/*** intuition.library/ChangeWindowBox ***/

ChangeWindowBox( window, l, t, w, h )
struct Window	*window;
{
    struct IBox newbox;

    newbox.Left = l;
    newbox.Top = t;
    newbox.Width = w;
    newbox.Height = h;

    /* will copy box into event */
    sendISMNoQuick( itCHANGEWIN, window, &newbox,
	CWSUB_CHANGE | CWSUBQ_PROGRAMMATIC | CWSUBQ_SIZING );
}


/*** intuition.library/WindowToFront ***/

WindowToFront(window)
struct Window *window;
{
    /* jimm: 5/11/90: better run at input device priority
     * to lessen the chance of somebody sneaking in
     * and trashing a damage list (some people don't use
     * the proper BeginRefresh() protocol, which does
     * the LockLayerInfo() ) protection.
     */
    sendISMNoQuick( itDEPTHWIN, window, NULL, WDEPTH_TOFRONT );
}

/*** intuition.library/MoveWindowInFrontOf ***/

MoveWindowInFrontOf( w, behindw )
struct Window	*w;
struct Window	*behindw;
{
    /* jimm: 5/11/90: better run at input device priority
     * to lessen the chance of somebody sneaking in
     * and trashing a damage list (some people don't use
     * the proper BeginRefresh() protocol, which does
     * the LockLayerInfo() ) protection.
     */
    sendISMNoQuick( itDEPTHWIN, w, behindw, WDEPTH_INFRONTOF );
}



/*** intuition.library/WindowToBack ***/

WindowToBack(window)
struct Window *window;
{
    /* jimm: 5/11/90: better run at input device priority
     * to lessen the chance of somebody sneaking in
     * and trashing a damage list (some people don't use
     * the proper BeginRefresh() protocol, which does
     * the LockLayerInfo() ) protection.
     */
    sendISMNoQuick( itDEPTHWIN, window, NULL, WDEPTH_TOBACK );
}


#if 0
/* Function to find out if a window is obscured by a window higher
 * up.  It needs to walk the layer list for the ordering, but it
 * had better not get confused by requester layers, which aren't
 * deemed to obscure their parent window.
 * Needs to be able to handle a layer with a NULL Window pointer
 * (eg. the bar-layer)
 */
windowObscured( win )
struct Window *win;
{
    struct Layer *l;
    struct Window *win2;
    BOOL obscured = FALSE;

    LockLayerInfo( &win->WScreen->LayerInfo );

    l = win->WScreen->LayerInfo.top_layer;

    while ( l )
    {
	/* If this layer is our window or a requester of our window,
	 * then we know we're not obscured...
	 */
	if ( ( win2 = l->Window ) == win )
	{
	    /* I'm done, not obscured! */
	    break;
	}
	else
	{
	    /* If this layer's window intersects our window, then we
	     * are obscured...
	     */
	    if ( ( win2 ) && intersectBox( (struct IBox *)&win->LeftEdge,
		(struct IBox *)&win2->LeftEdge ) )
	    {
		/* I'm done, obscured */
		obscured = TRUE;
		break;
	    }
	}
	/* Ok, move to the next layer back */
	l = l->back;
    }
    UnlockLayerInfo( &win->WScreen->LayerInfo );

    return( obscured );
}

/* Returns TRUE if the two boxes intersect, FALSE otherwise */ 
intersectBox( box1, box2 )
struct IBox *box1, *box2;
{
    struct Rectangle rect1, rect2;
    boxToRect( box1, &rect1 );
    boxToRect( box2, &rect2 );

    return( !( ( rect1.MinX > rect2.MaxX ) || ( rect2.MinX > rect1.MaxX ) ||
	( rect1.MinY > rect2.MaxY ) || ( rect2.MinY > rect1.MaxY ) ) );
}
#endif

/*** intuition.library/ScrollWindowRaster ***/


void ScrollWindowRaster( win, dx, dy, xmin, ymin, xmax, ymax )
struct Window *win;
LONG dx, dy;
LONG xmin, ymin;
LONG xmax, ymax;
{
    LockLayerInfo( &win->WScreen->LayerInfo );
    LOCKIBASE();
    ScrollRasterBF( win->RPort, dx, dy, xmin, ymin, xmax, ymax );
    /* ScrollRasterBF() only causes damage if this window is simple-refresh
     * and some bits that were obscured by another window were scrolled
     * into view.  The damage region will be that area.
     * There is no point in doing a full gadget refresh, etc., since
     * if the caller scrolled a gadget or window border, the damage
     * region will not include the bulk of the affected area.
     * The basic idea is not to scroll gadget or border imagery.
     *
     * Because of that, we skip doing BorderPatrol(), and just
     * do a quick refresh-handling here...
     */
    if ( ( win->WLayer->Flags & ( LAYERREFRESH|LAYERI_NOTIFYREFRESH ) ) ==
	( LAYERREFRESH|LAYERI_NOTIFYREFRESH ) )
    {
	win->WLayer->Flags &= ~LAYERI_NOTIFYREFRESH;

	if (win->Flags & NOCAREREFRESH)
	{
	    /* Throw away his damage */
	    BeginRefresh(win);
	    EndRefresh(win,TRUE);
	}
	else
	{
	    /* Tell him about damage */
	    windowEvent( win, IECLASS_REFRESHWINDOW, 0 );

	    /* and tell Mr. Console	*/
	    windowEvent( win, IECLASS_EVENT, IECODE_REFRESH );
	}
    }

    UNLOCKIBASE();
    UnlockLayerInfo( &win->WScreen->LayerInfo );
}
@


38.35
log
@RefreshWindowFrame() now handles window title pokers.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.34 92/12/09 18:16:39 peter Exp Locker: peter $
d147 1
a147 1
	    return(IBase->HitScreen = ((s->MouseY >= s->Height)? NULL: s));
d150 1
a150 1
    return (NULL);
@


38.34
log
@Cleaned up and simplified getright().  Fixed bug in IOpenWindow()
which could leave unrepaired damage if layer creation failed.
drawEmbossedBorder() now uses DRAWGADGETS_xxx flags, and skips the
first rendering of the window frame edges if this is just an
activation-change.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.33 92/08/02 12:46:32 peter Exp Locker: peter $
a464 11
/*** intuition.library/RefreshWindowFrame ***/

#if 0	/* vector directly to drawWidowBorder: jimm: 12/1/88 */
RefreshWindowFrame(window)
struct Window *window;
{
    drawWindowBorder(window);
}
#endif


d605 16
@


38.33
log
@Changes to handle menu-lending for menu-command keys.  Fixes another
enforcer hit in SWT() fix.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.32 92/07/28 15:14:43 peter Exp Locker: peter $
d355 5
a576 2

#if 1
d579 9
a587 4
 * kludge city has been closed indefinitely
 * NEW: now snooping application TOPBORDER GRELRIGHT gadgets
 * for better idea of right drag area.
 * If this only works for stripes, make it an option, like BOOL snoop_gads
d589 1
a589 1
int getright(w, snoop_gadgets)
a590 1
int		snoop_gadgets;	/* offset for TOBBORDER/RELRIGHT gadgets */
d592 2
a593 4
    int	respick = IsHires( w->WScreen )? HIRESPICK: LOWRESPICK;
    int	right;
    struct Gadget	*g;
    extern struct RomGadget RomGadgetDefs[RESCOUNT][GADGETCOUNT];
d595 19
a613 46
    int	relright;	/* will be some negative number	*/

    /* damn, another hardcoded kludge.  */
    if ( TESTFLAG( w->Flags, HASZOOM ) )
	relright =  
	    ((respick == HIRESPICK)? ZOOMRELRIGHT: LZOOMRELRIGHT) - GADGETPAD;
    else if ( TESTFLAG( w->Flags, WINDOWDEPTH ) )
	relright = 
	    ((respick == HIRESPICK)? DEPTHRELRIGHT: LDEPTHRELRIGHT)-GADGETPAD;
    else 
	relright = -GADGETPAD;

    right = w->Width + relright;

    /* NEW STUFF: */
    /* now snoop through the application gadgets */
    if ( snoop_gadgets )
    {
	for ( g = w->FirstGadget; g; g=g->NextGadget )
	{
	    if ( TESTFLAG(g->Flags, GRELRIGHT)
		&& TESTFLAG( g->Activation, TOPBORDER ) )
	    {
		DGR(printf("getright:top/rightgadget,old right %ld\n",right));
		right = imin( right, g->LeftEdge + (w->Width - 1) - GADGETPAD);
	    }
	}
    }
    return ( right );
}



#else
int getright(w)
struct Window *w;
/* welcome to kludge city.  here you will find me using hard-coded constants
 * rather than fetching the width values from the CloseWindow Gadgets
 * that will come someday, honest
 */
{
    /* jimm: 2/24/86: return one pixel to the left */
    if (w->Flags & WINDOWDEPTH)
    {
	return( IsHires(w->WScreen)?
		(w->Width - 54): (w->Width - 35) );
d615 1
a615 2
    /* jimm: wasn't subtracting 1 */
    else return(w->Width - 1);
a616 1
#endif
d619 24
a642 4
 * if 'border_gadgets', just redraw gadgets clobbered by
 * border redraw.  If false, redraw ALL gadgets in window.
 * Former is for setWindow (newly active or inactive).  The
 * latter is for BorderPatrol and OpenWindow (and RefeshWindowFrame)
d644 1
a644 1
drawEmbossedBorder( w, border_gadgets_only )
d646 1
a647 2
    int filter_flags = DRAWGADGETS_ALL;

d655 4
a658 1
    drawEmbossedEdges( w );
d662 1
a662 5
    if ( border_gadgets_only )
    {
	filter_flags = DRAWGADGETS_BORDER;
    }
    drawGadgets( w, w->FirstGadget, -1, filter_flags );
d826 1
a826 1
    textright = getright( w, TRUE );	/* snoop out gadgets? */
d955 2
a956 2
	/* redraw border and border gadgets */
	drawEmbossedBorder( AWindow, TRUE );
d1006 8
a1013 1
	drawEmbossedBorder( w, !initial );
@


38.32
log
@Fixed enforcer hit in window title code.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.31 92/07/24 11:41:52 peter Exp Locker: peter $
d456 1
a456 1
    sendISM( itACTIVATEWIN, window, NULL, FALSE );
a823 1
    struct Rectangle *newrectp;
a856 1
	    newrectp = &XWINDOW(w)->TitleExtent;
d861 1
a861 2
	/* Make oldrect of width/height zero */
	*((ULONG *)&oldrect.MaxX) = *((ULONG *)&oldrect.MinX);
d867 1
a867 1
	fillAround( rp, &oldrect, newrectp, embossedFillPen( w ), ~0 );
@


38.31
log
@Deleted incorrect comment.  Removed windowObscured()/intersectBox().
Stores/uses TitleExtent to fix SetWindowTitles() crumbs.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.31 92/07/24 11:29:58 peter Exp $
d864 1
a864 1
	*((ULONG *)&oldrect.MaxX) = *((ULONG *)oldrect.MinX);
@


38.30
log
@Minor comment clarification.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.29 92/06/22 13:04:31 peter Exp Locker: peter $
d822 6
a827 5
    /* struct IntuiText	itext; */
    struct TextExtent		te;
    int		textright;
    int		textleft;
    UWORD	numchars;
d836 2
a840 1
    /* print any text I might have here */
a852 1
	}
d854 5
a858 11
	/* if there's text to do, do it */
	if ( numchars > 0 )
	{
	    /* ZZZ: maybe use HIGHLIGHTTEXTPEN if active  */
	    SetABPenDrMd( rp, XSC(w->WScreen)->SPens[ 
		TESTFLAG( w->Flags,  WINDOWACTIVE )? FILLTEXTPEN: TEXTPEN ],
		embossedFillPen( w ), JAM2 );
	    /* ZZZ: do I get the right font? */

	    /* I am already in position */
	    Text( rp, w->Title, numchars );
d860 6
d867 4
d873 2
a874 2
    /* refill in any leftover title region */
    if ( ( clearout ) && ( rp->cp_x < textright ) )
d876 7
a882 3
	SetAPen( rp, embossedFillPen( w ) );
	RectFill( rp, rp->cp_x, FRAMEHTHICK,
	    textright, FRAMEHTHICK+rp->TxHeight );
d1212 1
a1212 1

d1273 1
@


38.29
log
@Removed extraneous parameter to FreeVec().
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.28 92/06/18 18:11:15 peter Exp Locker: peter $
d1022 1
a1022 1
    LOCKSTATE();
d1061 7
d1078 1
a1078 1
	{
d1081 1
a1081 1
	}
d1084 1
a1084 1
	{
d1087 1
a1087 1
	}
d1090 1
a1090 1
	{
d1093 1
a1093 1
	}
d1096 1
a1096 1
	{
d1099 1
a1099 1
	}
@


38.28
log
@setWindow() now takes an "initial-draw" parameter, instead of using
WMF_INITIALDRAWGADGETS.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.27 92/06/03 17:39:39 peter Exp Locker: peter $
d443 1
a443 1
	FreeVec(message, sizeof(struct IIntuiMessage));
@


38.27
log
@setWindow() restores gadget-help fields in IBase.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.26 92/05/29 18:30:46 peter Exp Locker: peter $
d456 1
a456 1
    sendISM( itACTIVATEWIN, window, NULL );
d900 3
d904 1
a904 1
setWindow( w )
d906 1
d1006 1
a1006 2
	drawEmbossedBorder( w, !TESTFLAG( w->MoreFlags, WMF_INITIALDRAWGADGETS ) );
	CLEARFLAG( w->MoreFlags, WMF_INITIALDRAWGADGETS );
@


38.26
log
@Fixed ScrollWindowRaster() bug where refresh was always being sent.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.25 92/05/27 11:57:09 peter Exp Locker: peter $
d915 7
@


38.25
log
@Re-instated initial drawing of embossed trim.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.24 92/05/21 17:47:06 peter Exp Locker: peter $
d1271 2
a1272 1
    if (win->Flags & NOCAREREFRESH)
d1274 12
a1285 8
	/* Throw away his damage */
	BeginRefresh(win);
	EndRefresh(win,TRUE);
    }
    else
    {
	/* Tell him about damage */
	windowEvent( win, IECLASS_REFRESHWINDOW, 0 );
d1287 3
a1289 2
	/* and tell Mr. Console	*/
	windowEvent( win, IECLASS_EVENT, IECODE_REFRESH );
@


38.24
log
@Removed ScrollWindowRaster() kludge that set missing new damage bits.
Now passes DRAWGADGETS_ALL to drawGadgets().
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.23 92/05/15 14:11:24 peter Exp Locker: peter $
d660 2
a662 3
#if 0
    drawEmbossedEdges( w );
#endif
@


38.23
log
@setWindow() asserts IBASELOCK and now gets 'initial' information from
the window itself.  itACTIVATEWIN loses it_SubCommand.  Synchronous
window activation now relies on a WMF_ flag, to fix vulnerability
against other window activators.  Removed extra call to draw window
edges.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.22 92/05/01 13:55:21 peter Exp Locker: peter $
d651 2
d665 5
a669 1
    drawGadgetsBorderFilter( w, w->FirstGadget, -1, border_gadgets_only );
d792 6
d800 1
d802 1
a802 1
	    drawGadgets(w, g, 1);	/* refresh 1 */
a1257 3
#if 000
    ULONG foo = 0;
#endif
a1259 4
#if 000
    foo = TESTFLAG( win->WLayer->Flags, LAYERREFRESH );
    CLEARFLAG( win->WLayer->Flags, LAYERREFRESH );
#endif
a1260 10
#if 000
    if ( TESTFLAG( win->WLayer->Flags, LAYERREFRESH ) )
    {
	SETFLAG( win->WLayer->Flags, LAYERREFRESH|LAYERI_GADGETREFRESH|LAYERI_NOTIFYREFRESH );
    }
    if ( foo )
    {
	SETFLAG( win->WLayer->Flags, LAYERREFRESH );
    }
#endif
@


38.22
log
@Took out 2nd BorderPatrol() parameter.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.21 92/04/09 16:29:13 peter Exp Locker: peter $
d456 1
a456 1
    sendISM( itACTIVATEWIN, window, NULL, FALSE );
d659 1
d661 1
d889 1
a889 1
setWindow( w, initial )
a890 1
BOOL initial;
d896 2
d983 2
a984 1
	drawEmbossedBorder( w, !initial );	/* do "active" border */
d1245 3
d1250 4
d1255 10
a1264 1

@


38.21
log
@Changes to handle message sizes.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.20 92/04/07 18:01:25 peter Exp Locker: peter $
d288 1
a288 7
	if ( barlayer->Flags & LAYERREFRESH )
	{
	    BeginUpdate( barlayer );
	    screenbar( sc );
	    CLEARFLAG( barlayer->Flags, LAYERREFRESH );
	    EndUpdate( barlayer, TRUE);
	}
d1245 11
a1255 4
#if 111
    /* Repair damage for this window only */
    BorderPatrol( win->WScreen, win );
#else
a1269 1
#endif
@


38.20
log
@Minor fix for SAS test-compile.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.19 92/04/02 21:42:09 peter Exp Locker: peter $
d446 4
a449 2
	/* jimm: 7/11/86: extended to hold dead-key info */
	FreeMem(message, sizeof(struct FatIntuiMessage));
@


38.19
log
@Implemented LendMenu() function.  Passes new FALSE it_SubCommand to
itACTIVATEWIN.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.18 92/04/02 12:09:30 peter Exp Locker: peter $
d82 1
a82 1
    struct Window *w, *returnwindow;
a134 1
    int localy;
a371 1
    struct IntuitionBase *IBase = fetchIBase();
d482 1
a482 1
    ULONG flags, res, type;
a654 2
    int wwidth, wheight, gzzwidth, gzzheight;

a691 2
    struct IntuitionBase *IBase = fetchIBase();
    int	pen;
a732 2
    register int right, bottom;
    struct IntuitionBase *IBase = fetchIBase();
a764 1
    int			titleright;
a765 1
    UWORD		type;
a1244 2
    LONG lock;

@


38.18
log
@Renamed setMouse() to setMousePointer(), and it no longer takes a
window parameter.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.17 92/03/26 16:41:17 peter Exp Locker: peter $
d462 1
a462 1
    sendISM( itACTIVATEWIN, window, FALSE );
d996 17
@


38.17
log
@Documented size-only zooming.  Now use modern names for DrawInfo pens.
Uses new JOINS flags for and omits thickness parameters to
embossedBoxTrim().
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.16 92/03/24 11:55:28 peter Exp Locker: peter $
d154 1
a154 779
/****** intuition.library/OpenWindow ***************************************
*
*    NAME
*	OpenWindow -- Open an Intuition window.
*
*    SYNOPSIS
*   	Window = OpenWindow( NewWindow )
*	D0                   A0
*
*	struct Window *OpenWindow( struct NewWindow * );
*
*    FUNCTION
*	Opens an Intuition window of the given dimensions and position,
*	with the properties specified in the NewWindow structure.
*	Allocates everything you need to get going.
*
*	New for V36: there is an extensive discussion of public Screens
*	and visitor windows at the end of this section.  Also,
*	you can provide extensions to the NewWindow parameters using
*	and array of TagItem structures.  See the discussion below,
*	and the documentation for the function OpenScreenTagList().
*
*	Before you call OpenWindow(), you must initialize an instance of
*	a NewWindow structure.  NewWindow is a structure that contains
*	all of the arguments needed to open a window.  The NewWindow
*	structure may be discarded immediately after it is used to open 
*	the window.
*	
*	If Type == CUSTOMSCREEN, you must have opened your own screen
*	already via a call to OpenScreen().  Then Intuition uses your screen
*	argument for the pertinent information needed to get your window
*	going.  On the other hand, if type == one of the Intuition's standard
*	screens, your screen argument is ignored.  Instead, 
*	Intuition will check to see whether or not that screen
*	already exists:  if it doesn't, it will be opened first before
*	Intuition opens your window in the standard screen.
*
*	New for V36: If you specify Type == WBENCHSCREEN, then your
*	window will appear on the Workbench screen, unless the global
*	public screen mode SHANGHAI is set, in which case your window
*	will be "hijacked" to the default public screen.  See also
*	SetPubScreenModes().
*	
*	New for V36: If the WFLG_NW_EXTENDED flag is set, it means that the
*	field 'ExtNewWindow->Extension' points to an array of TagItems, as
*	defined in intuition/tagitem.h.  This provides an extensible means
*	of providing extra parameters to OpenWindow.  For compatibility
*	reasons, we could not add the 'Extension' field to the NewWindow
*	structure, so we have define a new structure ExtNewWindow, which
*	is identical to NewWindow with the addition of the Extension field.
*
*	We recommend that rather than using ExtNewWindow.Extension, you
*	use the new Intuition function OpenWindowTagList() and its
*	varargs equivalent OpenWindowTags().  We document the window
*	attribute tag ID's (ti_Tag values) here, rather than in 
*	OpenWindowTagList(), so that you can find all the parameters
*	for a new window defined in one place.
*	
*	If the WFLG_SUPER_BITMAP flag is set, the bitmap variable must point
*	to your own bitmap.
*	
*	The DetailPen and the BlockPen are used for system rendering; for
*	instance, the title bar is first filled using the BlockPen, and then
*	the gadgets and text are rendered using DetailPen.  You can either
*	choose to supply special pens for your window, or, by setting either
*	of these arguments to -1, the screen's pens will be used instead.
*
*	Note for V36: The DetailPen and BlockPen no longer determine
*	what colors will be used for window borders, if your window
*	opens on a "full-blown new look screen."
*
*    INPUTS
*	NewWindow = pointer to an instance of a NewWindow structure.  That
*               structure is initialized with the following data:
*   -------------------------------------------------------------------------
*	Left = the initial x-position for your window
*	Top = the initial y-position for your window
*	Width = the initial width of this window
*	Height = the initial height of this window
*
*	DetailPen = pen number (or -1) for the rendering of window details
*         (like gadgets or text in title bar)
*	BlockPen = pen number (or -1) for window block fills (like title bar)
*	[For V36: Title bar colors are determined otherwise.]
*
*	Flags = specifiers for your requirements of this window, including:
*	     which system gadgets you want attached to your window:
*
*	    - WFLG_DRAGBAR allows this window to be dragged
*	    - WFLG_DEPTHGADGET lets the user depth-arrange this window
*	    - WFLG_CLOSEGADGET attaches the standard close gadget
*	    - WFLG_SIZEGADGET allows this window to be sized. 
*	    
*	    If you ask for the WFLG_SIZEGADGET gadget, you must specify one or
*	    both of the flags WFLG_SIZEBRIGHT and WFLG_SIZEBBOTTOM below; if
*	    you don't, the default is WFLG_SIZEBRIGHT.  See the following items
*	    WFLG_SIZEBRIGHT and WFLG_SIZEBBOTTOM for more details.
*
*	    - WFLG_SIZEBRIGHT is a special system gadget flag that
*	      you set to specify whether or not you want the
*	      RIGHT border adjusted to account for the physical size 
*	      of the sizing gadget.  The sizing gadget must, after
*	      all, take up room in either the right or bottom border
*	      (or both, if you like) of the window.  Setting either
*	      this or the WFLG_SIZEBBOTTOM flag selects which edge 
*	      will take up the slack.  This will be particularly
*	      useful to applications that want to use the extra space
*	      for other gadgets (like a proportional gadget and two
*	      Booleans done up to look like scroll bars) or, for
*	      for instance, applications that want every possible
*	      horizontal bit and are willing to lose lines vertically.
*	      NOTE:  if you select WFLG_SIZEGADGET, you must select 
*	      either WFLG_SIZEBRIGHT or WFLG_SIZEBBOTTOM or both.  If
*	      you select neither, the default is WFLG_SIZEBRIGHT.
*	    - WFLG_SIZEBBOTTOM is a special system gadget flag that
*	      you set to specify whether or not you want the
*	      BOTTOM border adjusted to account for the physical size 
*	      of the sizing gadget.  For details, refer to
*	      WFLG_SIZEBRIGHT above.
*
*	    - WFLG_GIMMEZEROZERO for easy but expensive output
*
*	    what type of window layer you want, either:
*	    - WFLG_SIMPLE_REFRESH
*	    - WFLG_SMART_REFRESH
*	    - WFLG_SUPER_BITMAP
*
*	    - WFLG_BACKDROP for whether or not you want this window to be one
*	      of Intuition's special backdrop windows.  See WFLG_BORDERLESS
*	      as well.
*
*	    - WFLG_REPORTMOUSE for whether or not you want to "listen" to
*	      mouse movement events whenever your window is the active
*	      one.  After you've opened your window, if you want to change
*	      you can later change the status of this via a call to
*	      ReportMouse().  Whether or not your window is listening to
*	      mouse is affected by gadgets too, since they can cause you
*	      to start getting reports too if you like.  The mouse move
*	      reports (either InputEvents or messages on the IDCMP) that
*	      you get will have the x/y coordinates of the current mouse
*	      position, relative to the upper-left corner of your window
*	      (WFLG_GIMMEZEROZERO notwithstanding).  This flag can work in
*	      conjunction with the IDCMP Flag called IDCMP_MOUSEMOVE, which
*	      allows you to listen via the IDCMP.
*
*	    - WFLG_BORDERLESS should be set if you want a window with no
*	      border padding.  Your window may have the border variables
*	      set anyway, depending on what gadgetry you've requested for
*	      the window, but you won't get the standard border lines and
*	      spacing that comes with typical windows.  
*
*	      This is a good way to take over the entire screen, since you
*	      can have a window cover the entire width of the screen using
*	      this flag.  This will work particularly well in conjunction
*	      with the WFLG_BACKDROP flag (see above), since it allows you
*	      to open a window that fills the ENTIRE screen.  NOTE:  this is
*	      not a flag that you want to set casually, since it may cause
*	      visual confusion on the screen.  The window borders are the
*	      only dependable visual division between various windows and
*	      the background screen.  Taking away that border takes away
*	      that visual cue, so make sure that your design doesn't need
*	      it at all before you proceed.
*
*	    - WFLG_ACTIVATE is the flag you set if you want this window to
*	      automatically become the active window.  The active
*	      window is the one that receives input from the keyboard and
*	      mouse.  It's usually a good idea to to have the window you
*	      open when your application first starts up be an ACTIVATED
*	      one, but all others opened later not be ACTIVATED (if the
*	      user is off doing something with another screen, for
*	      instance, your new window will change where the input is
*	      going, which would have the effect of yanking the input rug
*	      from under the user).  Please use this flag thoughtfully and
*	      carefully.
*
*	      Some notes: First, your window may or may not be active
*	      by the time this function returns.  Use the IDCMP_ACTIVEWINDOW
*	      IDCMP message to know when your window has become active.
*	      Also, be very careful not to mistakenly specify the
*	      obsolete flag names WINDOWACTIVE or ACTIVEWINDOW.  These are
*	      used in other contexts, and their values unintentionally added
*	      to your flags can cause most unfortunate results.  To avoid
*	      confusion, they are now know as WFLG_WINDOWACTIVE and
*	      IDCMP_ACTIVEWINDOW.
*
*	    - WFLG_RMBTRAP, when set, causes the right mouse button events 
*	      to be trapped and broadcast as events.  You can receive 
*	      these events through either the IDCMP or the console.
*
*	    - WFLG_NOCAREREFRESH indicates that you do not wish to
*	      be responsible for calling BeginRefresh() and EndRefresh()
*	      when your window has exposed regions (i.e., when the
*	      IDCMP_REFRESHWINDOW message would be generated).  See also
*	      the descriptions of these two functions.
*
*	    - WFLG_NW_EXTENDED (V36) indicates that NewWindow in fact points
*	      to an ExtNewWindow structure, and that the 'Extension'
*	      field points to an array of TagItem structures, with
*	      meaning described below.
*
*	IDCMPFlags = IDCMP is the acronym for Intuition Direct Communications
*	    Message Port.  (It's Intuition's sole acronym.) If any of the
*	    IDCMP Flags is selected, Intuition will create a pair of
*	    message ports and use them for direct communications with the
*	    task opening this window (as compared with broadcasting
*	    information via the Console device).  See the "Input and
*	    Output Methods" chapter of the Intuition Reference Manual for
*	    complete details.
*
*	    You request an IDCMP by setting any of these flags.  Except
*	    for the special VERIFY flags, every other flag you set tells
*	    Intuition that if a given event occurs which your program
*	    wants to know about, it is to broadcast the details of that
*	    event through the IDCMP rather than via the Console device.
*	    This allows a program to interface with Intuition directly,
*	    rather than going through the Console device.
*
*	    Many programs have elected to use IDCMP communication
*	    exclusively, and not to associate a console with their
*	    windows at all.  Some operations, such as IDCMP_MENUVERIFY,
*	    can ONLY be achieved using IDCMP.
*
*            The IDCMP flags you can set are:
*
*	    - IDCMP_REQVERIFY is the flag which, like IDCMP_SIZEVERIFY and ...
*
*	    - IDCMP_MENUVERIFY (see immediately below), specifies that you
*	      want to make sure that your graphical state is quiescent
*	      before something extraordinary happens.  In this case, the
*	      extraordinary event is that a rectangle of graphical data is
*	      about to be blasted into your Window.  If you're drawing
*	      directly into its screen, you probably will wish to make sure
*	      that you've ceased drawing before the user is allowed to bring
*	      up the DMRequest you've set up, and the same for when system
*	      has a request for the user.  Set this flag to ask for that
*	      verification step.
*
*	    - IDCMP_REQCLEAR is the flag you set to hear a message whenever
*	      a requester is cleared from your window.  If you are using
*	      IDCMP_REQVERIFY to arbitrate access to your screen's bitmap, it
*	      is safe to start your output once you have heard an
*	      IDCMP_REQCLEAR for each IDCMP_REQSET.
*
*	    - IDCMP_REQSET is a flag that you set to receive a broadcast
*	      for each requester that is opened in your window.  Compare
*	      this with IDCMP_REQCLEAR above.  This function is distinct
*	      from IDCMP_REQVERIFY.  This functions merely tells you that a
*	      requester has opened, whereas IDCMP_REQVERIFY requires you to
*	      respond before the requester is opened.
*
*	    - IDCMP_MENUVERIFY is the flag you set to have Intuition stop
*	      and wait for you to finish all graphical output to your
*	      window before rendering the menus.  Menus are currently
*	      rendered in the most memory-efficient way, which involves
*	      interrupting output to all windows in the screen before the
*	      menus are drawn.  If you need to finish your graphical
*	      output before this happens, you can set this flag to make
*	      sure that you do.
*
*	    - IDCMP_SIZEVERIFY means that you will be doing output to your
*	      window which depends on a knowledge of the current size of the
*	      window.  If the user wants to resize the window,  you may want
*	      to make sure that any queued output completes before the sizing
*	      takes place (critical text, for instance).  If this is the
*	      case, set this flag.   Then, when the user wants to size,
*	      Intuition will send you the IDCMP_SIZEVERIFY message and Wait()
*	      until you reply that it's OK to proceed with the sizing. NOTE:
*	      when we say that Intuition will Wait() until you reply, what
*	      we're really saying is that user will WAIT until you reply, which
*	      suffers the great negative potential of User-Unfriendliness.
*	      So remember:  use this flag sparingly, and, as always with any
*	      IDCMP Message you receive, reply to it promptly!  Then, after
*	      user has sized the window, you can find out about it using
*	      IDCMP_NEWSIZE.
*
*	    With all the "VERIFY" functions, it is not save to leave them
*	    enabled at any time when your task may not be able to respond
*	    for a long period.
*
*	    It is NEVER safe to call AmigaDOS, directly or indirectly, when
*	    a "VERIFY" function is active.  If AmigaDOS needs to put up a
*	    disk requester for you, your task might end up waiting for the
*	    requester to be satisfied, at the same time as Intuition is
*	    waiting for your response.  The result is a complete machine
*	    lockup.  USE ModifyIDCMP() TO TURN OFF ANY VERIFY MESSAGES
*	    BEFORE CALLING dos.library!!
*
*	    For V36: If you do not respond to the verification IntuiMessages
*	    within the user specified timeout duration, Intuition will abort
*	    the operation.  This eliminates the threat of these easy
*	    deadlocks, but can result in a confused user.  Please try
*	    hard to continue to avoid "logical deadlocks".
*
*	    - IDCMP_NEWSIZE is the flag that tells Intuition to send an IDCMP
*	      message to you after the user has resized your window.  At
*	      this point, you could examine the size variables in your
*	      window structure to discover the new size of the window.
*	      See also the IDCMP_CHANGEWINDOW IDCMP flag.
*
*	    - IDCMP_REFRESHWINDOW when set will cause a message to be sent
*	      whenever your window needs refreshing.  This flag makes
*	      sense only with WFLG_SIMPLE_REFRESH and WFLG_SMART_REFRESH
*	      windows.
*
*	    - IDCMP_MOUSEBUTTONS will get reports about mouse-button up/down
*	      events broadcast to you (Note:  only the ones that
*	      don't mean something to Intuition.  If the user clicks the
*	      select button over a gadget, Intuition deals with it and you
*	      don't find out about it through here).
*
*	    - IDCMP_MOUSEMOVE will work only if you've set the 
*	      WFLG_REPORTMOUSE flag above, or if one of your gadgets has the
*	      GACT_FOLLOWMOUSE flag set.  Then all mouse movements will be
*	      reported here, providing your window is active.
*
*	    - IDCMP_GADGETDOWN means that when the User "selects" a gadget
*	      you've created with the GACT_IMMEDIATE flag set, the fact
*	      will be broadcast through the IDCMP.
*
*	    - IDCMP_GADGETUP means that when the user "releases" a gadget that
*	      you've created with the GACT_RELVERIFY flag set, the fact
*	      will be broadcast through the IDCMP.  This message is
*	      only generated if the release is "good", such as releasing
*	      the select button over a Boolean gadget, or typing ENTER
*	      in a string gadget.
*
*	    - IDCMP_MENUPICK selects that menu number data will be sent via
*	      the IDCMP.
*
*	    - IDCMP_CLOSEWINDOW means broadcast the IDCMP_CLOSEWINDOW event
*	      through the IDCMP rather than the console.
*
*	    - IDCMP_RAWKEY selects that all IDCMP_RAWKEY events are
*	      transmitted via the IDCMP.  Note that these are absolutely RAW
*	      keycodes, which you will have to translate before using.
*	      Setting this and the MOUSE flags effectively eliminates the need
*	      to open a Console device to get input from the keyboard and
*	      mouse.  Of course, in exchange you lose all of the console
*	      features, most notably the "cooking" of input data and
*	      the systematic output of text to your window.
*
*	    - IDCMP_VANILLAKEY is for developers who don't want the hassle
*	      of IDCMP_RAWKEYS.  This flag will return all the keycodes after
*	      translation via the current country-dependent keymap.  When
*	      you set this flag, you will get IntuiMessages where the Code
*	      field has a decoded ANSI character code representing the key
*	      struck on the keyboard.  Only codes that map to a single
*	      character are returned: you can't read such keys as HELP or
*	      the function keys with IDCMP_VANILLAKEY.
*
*	      NOTE FOR V36: If you have both IDCMP_RAWKEY and IDCMP_VANILLAKEY
*	      set, Intuition will send an IDCMP_RAWKEY event for those
*	      *downstrokes* which do not map to single-byte characters
*	      ("non-vanilla" keys).  In this way you can easily detect cursor
*	      keys, function keys, and the Help key without sacrificing the
*	      convenience of IDCMP_VANILLAKEY.
*
*	    - IDCMP_INTUITICKS gives you simple timer events from Intuition
*	      when your window is the active one; it may help you avoid
*	      opening and managing the timer device.  With this flag set,
*	      you will get only one queued-up INTUITICKS message at a
*	      time.  If Intuition notices that you've been sent an
*	      IDCMP_INTUITICKS message and haven't replied to it, another
*	      message will not be sent.  Intuition receives timer events and
*	      considers sending you an IDCMP_INTUITICKS message approximately
*	      ten times a second.
*
*	    - IDCMP_DELTAMOVE gives raw (unscaled) input event delta X/Y
*	      values.  This is so you can detect mouse motion regardless of
*	      screen/window/display boundaries.  This works a little
*	      strangely: if you set both IDCMP_MOUSEMOVE and IDCMP_DELTAMOVE.
*	      IDCMPFlags, you will get IDCMP_MOUSEMOVE messages with delta
*	      x/y values in the MouseX and MouseY fields of the
*	      IDCMPMessage.
*
*	    - IDCMP_NEWPREFS indicates you wish to be notified when the
*	      system-wide Preferences changes.  For V36, there is a new
*	      environment mechanism to replace Preferences, which we
*	      recommend you consider using instead.
*
*	    - Set IDCMP_ACTIVEWINDOW and IDCMP_INACTIVEWINDOW to get messages
*	      when those events happen to your window.  Take care not to
*	      confuse this "ACTIVEWINDOW" with the familiar sounding, but
*	      totally different "WINDOWACTIVE" flag.  These two flags have
*	      been supplanted by "IDCMP_ACTIVEWINDOW" and "WFLG_WINDOWACTIVE".
*	      Use the new equivalent terms to avoid confusion.
*
*	    - Set IDCMP_DISKINSERTED or IDCMP_DISKREMOVED to learn when
*	      removable disks are inserted or removed, respectively.
*
*	    - IDCMP_IDCMPUPDATE is a new class for V36 which is used as
*	      a channel of communication from custom and boopsi gadgets
*	      to your application.
*
*	    - IDCMP_CHANGEWINDOW is a new class for V36 that will be sent
*	      to your window whenever its dimensions or position are changed
*	      by the user or the functions SizeWindow(), MoveWindow(),
*	      ChangeWindowBox(), or ZipWindow().
*
*	    - IDCMP_MENUHELP is new for V37.  If you specify the WA_MenuHelp
*	      tag when you open your window, then when the user presses the
*	      HELP key on the keyboard during a menu session, Intuition will
*	      terminate the menu session and issue this even in place of an
*	      IDCMP_MENUPICK message.
*		- NEVER follow the NextSelect link for MENUHELP messages.
*		- You will be able to hear MENUHELP for ghosted menus.
*		  (This lets you tell the user why the option is ghosted.)
*		- Be aware that you can receive a MENUHELP message whose code
*		  corresponds to a menu header or an item that has sub-items
*		  (which does not happen for MENUPICK).  The code may also be
*		  MENUNULL.
*		- LIMITATION:  if the user extend-selects some checkmarked
*		  items with the mouse, then presses MENUHELP, your
*		  application will only hear the MENUHELP report.  You
*		  must re-examine the state of your checkmarks when you
*		  get a MENUHELP.
*		- Availability of MENUHELP in V36 is not directly
*		  controllable.  We apologize...
*
*	Gadgets = the pointer to the first of a linked list of the your own 
*	      Gadgets which you want attached to this Window.  Can be NULL
*	      if you have no Gadgets of your own
*
*       CheckMark = a pointer to an instance of the struct Image where can
*	      be found the imagery you want used when any of your
*	      menu items is to be checkmarked.  If you don't want to
*	      supply your own imagery and you want to just use 
*	      Intuition's own checkmark, set this argument to NULL
*
*       Text = a null-terminated line of text to appear on the title bar of
*	      your window (may be null if you want no text)
*
*       Type = the screen type for this window.  If this equal CUSTOMSCREEN,
*	      you must have already opened a CUSTOMSCREEN (see text above).
*	      Types available include:
*		  - WBENCHSCREEN
*		  - CUSTOMSCREEN
*		  - PUBLICSCREEN (new for V36, see text below)
*
*       Screen = if your type is one of Intuition's standard screens, then
*	      this argument is ignored.  However, if Type == CUSTOMSCREEN,
*	      this must point to the structure of your own screen
*
*       BitMap = if you have specified WFLG_SUPER_BITMAP as the type of
*	       refreshing you want for this window, then this value points to a
*	       instance of the struct bitmap.  However, if the refresh type
*	       is NOT WFLG_SUPER_BITMAP, this pointer is ignored.
*
*       MinWidth, MinHeight, MaxWidth, MaxHeight = the size limits for this 
*	      window.  These must be reasonable values, which is to say that
*	      the minimums cannot be greater than the current size, nor can
*	      the maximums be smaller than the current size.  If they are,
*	      they're ignored.  Any one of these can be initialized to zero,
*	      which means that that limit will be set to the current
*	      dimension of that axis.  The limits can be changed after the
*	      Window is opened by calling the WindowLimits() routine.
*
*	      NOTE: ORIGINALLY, we stated that:
*
*	      "If you haven't requested the WFLG_SIZEGADGET option, these
*	      variables are ignored so you don't have to initialize them."
*
*	      It is now clear that a variety of programs take it upon
*	      themselves to call SizeWindow() (or ChangeWindowBox()) without
*	      your program's consent or consulting your WFLG_SIZEGADGE
*	      option.  To protect yourself against the results, we strongly
*	      urge that if you supply suitable values for these fields even
*	      if you do not specify WFLG_SIZEGADGET.
*
*	      The maximums may be LARGER than the current size, or even
*	      larger than the current screen.  The maximums should be set to
*	      the highest value your application can handle.  This allows
*	      users with larger display devices to take full advantage of
*	      your software.  If there is no good reason to limit the size,
*	      then don't.  -1 or ~0 indicates that the maximum size is only
*	      limited by the size of the window's screen.
*
*	      See also the docs on the function WindowLimits() for more
*	      information.
*
*       Extension (New for V36) = a pointer to an array (or chain of arrays)
*	    of TagItems to specify additional parameters to OpenWindow().
*	    TagItems in general are described in utility/tagitem.h,
*	    and the OpenWindow tags are defined in intuition/intuition.h
*	    and described here.  For items pertaining to Public Screens
*	    and visitor windows, please see below.
*
*	Here are the TagItem.ti_Tag values that are defined for OpenWindow
*	(and OpenWindowTagList()).
*
*	Certain tags simply override equivalent values in NewWindow,
*	and allow you to open a window using OpenWindowTagList() without
*	having a NewWindow structure at all.  In each case, cast
*	the corresponding data to ULONG and put it in ti_Data.
*
*	The compatible tag items include:
*
*	WA_Left
*	WA_Top
*	WA_Width
*	WA_Height
*	WA_DetailPen	- NOTE: only overrides NewWindow.DetailPen of -1!
*	WA_BlockPen	- NOTE: only overrides NewWindow.BlockPen of -1!
*	WA_IDCMP
*	WA_Flags	- initial values for Flags before looking at other
*			Boolean component Tag values
*	WA_Gadgets
*	WA_Title
*	WA_CustomScreen - also implies CUSTOMSCREEN property
*	WA_SuperBitMap - also implies WFLG_SUPER_BITMAP refresh mode.
*	WA_MinWidth
*	WA_MinHeight
*	WA_MaxWidth
*	WA_MaxHeight
*
*	These Boolean tag items are alternatives to the NewWindow.Flags
*	Boolean attributes with similar names.
*
*	WA_SizeGadget		- equivalent to WFLG_SIZEGADGET
*	WA_DragBar		- equivalent to WFLG_DRAGBAR
*	WA_DepthGadget		- equivalent to WFLG_DEPTHGADGET
*	WA_CloseGadget		- equivalent to WFLG_CLOSEGADGET
*	WA_Backdrop		- equivalent to WFLG_BACKDROP
*	WA_ReportMouse		- equivalent to WFLG_REPORTMOUSE
*	WA_NoCareRefresh 	- equivalent to WFLG_NOCAREREFRESH
*	WA_Borderless		- equivalent to WFLG_BORDERLESS
*	WA_Activate		- equivalent to WFLG_ACTIVATE
*	WA_RMBTrap		- equivalent to WFLG_RMBTRAP
*	WA_WBenchWindow		- equivalent to WFLG_WBENCHWINDOW
*				  (system PRIVATE)
*	WA_SimpleRefresh 	- only specify if TRUE
*	WA_SmartRefresh 	- only specify if TRUE
*	WA_SizeBRight		- equivalent to WFLG_SIZEBRIGHT
*	WA_SizeBBottom		- equivalent to WFLG_SIZEBBOTTOM
*	WA_GimmeZeroZero 	- equivalent to WFLG_GIMMEZEROZERO
*
*	The following tag items specify new attributes of a window.
*
*	WA_ScreenTitle - You can specify the screen title associated
*	    with your window this way, and avoid a call to SetWindowTitles()
*	    when your window opens.
*
*	WA_AutoAdjust - a Boolean attribute which says that it's OK
*	    to move or even shrink the dimensions of this window
*	    to fit it on the screen, within the dimension
*	    limits specified by MinWidth and MinHeight.
*	    Someday, this processing might be sensitive to the
*	    currently visible portion of the screen the window
*	    will be opening on, so don't draw too many conclusions
*	    about the auto-adjust algorithms.
*	    (Normally, this attribute defaults to FALSE.  However,
*	    if you call OpenWindowTags() or OpenWindowTagList()
*	    with a NULL NewWindow pointer, this attribute defaults
*	    to TRUE).
*
*	WA_InnerWidth
*	WA_InnerHeight - You can specify the dimensions of the interior
*	    region of your window, independent of what the border
*	    thicknesses will be.  You probably want to specify
*	    WA_AutoAdjust to allow Intuition to move your window
*	    or even shrink it so that it is completely on screen.
*
*	    Note: using these tags puts some reasonable restrictions
*	    on the gadgets you can specify as "border" gadgets when
*	    you open your window.  Since border gadgets determine
*	    the border dimensions and hence the overall dimensions of
*	    your window, those dimensions cannot be used calculating
*	    the position or dimensions of border gadgets.
*
*	    Here's the complete list of restrictions:
*	    - GACT_LEFTBORDER gadgets cannot be GFLG_RELWIDTH if
*	      WA_InnerWidth is used.
*	    - GACT_RIGHTBORDER gadgets MUST be GFLG_RELRIGHT if
*	      WA_InnerWidth is used.
*	    - GACT_TOPBORDER gadgets cannot be GFLG_RELHEIGHT if
*	      WA_InnerHeight is used.
*	    - GACT_BOTTOMBORDER gadgets MUST be GFLG_RELBOTTOM if
*	      WA_InnerHeight is used.
*
*	WA_PubScreenName - This tag item declares that you want your window
*	    to open as a visitor window on the public screen whose name
*	    is pointed to by (UBYTE *) ti_Data.
*
*	WA_PubScreen - Open as a visitor window on the public screen
*	    whose address if provided as (struct Screen *) ti_Data.
*	    To ensure that this screen remains open long enough, you
*	    must either:
*		1) Be the screen's owner
*		2) have another window already open on the screen
*		3) use LockPubScreen()
*	    Using exec.library/Forbid() is not sufficient.
*
*	    You can provide ti_Data to be NULL (zero), without any
*	    of the above precautions, to specify the default public screen.
*
*	WA_PubScreenFallBack - This Boolean attribute specifies that a
*	    visitor window should "fall back" to opening on the default
*	    public screen if the explicitly specify public screen is not
*	    available.
*
*	WA_WindowName - this visionary specification of a window
*	    rendezvous name string is not yet implemented.
*
*	WA_Colors - this equally great idea about associating a palette
*	    specification with the active window may not ever be implemented.
*
*	WA_Zoom - ti_Data points to an array of four WORD's to be used
*	    as the initial Left/Top/Width/Height of the "alternate
*	    Zoom position and dimensions."  The presence of this tag
*	    item implies that you want a Zoom gadget, even though you
*	    might not have a sizing gadget.
*	    New for V39: if the initial zoom-box left and top are
*	    both set to ~0, then Intuition will give your window
*	    "size-only" zooming, meaning that zooming the window
*	    will not affect the left/top unless the window needs
*	    to be moved on-screen.
*
*	WA_MouseQueue - This tag specifies a limit for the number
*	    of outstanding IDCMP_MOUSEMOVE IntuiMessages that Intuition
*	    will send to your window.  You can change the value of this
*	    limit after the window is open using SetMouseQueue().
*
*	WA_RptQueue - This tag specifies a limit for the number of
*	    outstanding repeated-IDCMP_RAWKEY, repeated-IDCMP_VANILLAKEY,
*	    and repeated-IDCMP_IDCMPUPDATE IntuiMessages that Intuition will
*	    send to your window.  Currently, there is no function to adjust
*	    the repeat-key queue.
*
*	WA_BackFill - ti_Data is a pointer to a Hook structure that
*	    the Layers library will call when your window needs
*	    "backfilling."  See layers.library/InstallLayerHook().
*
* 	WA_MenuHelp - ti_Data is a boolean.  If true, enables the MenuHelp
*	    feature for this window.  See IDCMP_MENUHELP above.  (Ignored
*	    in V36 and earlier).
*
*	WA_NotifyDepth - (New for V39) ti_Data is a boolean.  Set to
*	    true if you would like IDCMP_CHANGEWINDOW events sent
*	    to your window when it is depth-arranged.  Normally,
*	    such events are only sent for movement or resizing of
*	    the window.  IDCMP_CHANGEWINDOW events originating
*	    from depth-arrangement have a Code equal to CWCODE_DEPTH,
*	    as opposed to CWCODE_MOVESIZE.  (Ignored in V37 and earlier).
*
*	WA_NewLookMenus - (New for V39) ti_Data is a boolean.
*	    Requests new-look menu treatment (defaults to FALSE).
*	    Menu colors are derived from new screen pens, instead of
*	    window detail and block pens. Ignored by V36/V37.
*
*	WA_Checkmark - (ti_Data is struct Image *) Image to use as a
*	    checkmark in menus.  Starting with V39, if WA_NewLookMenus
*	    is not specified, the default will be the traditional
*	    checkmark in the original colors.  If you have requested
*	    WA_NewLookMenus, then the default will be an appropriately
*	    colored checkmark, scaled to the screen's font.
*	    Alternately, you can provide a custom one, which you
*	    candesign yourself or get from sysiclass (use this if
*	    your menu-font is different from the screen's font).
*
*	WA_AmigaKey - (ti_Data is struct Image *) (New for V39) Image
*	    to use as the Amiga-key symbol in menus.  If
*	    WA_NewLookMenus is not specified, the default will be the
*	    traditional Amiga-key symbol in the original colors.  If
*	    you've requested WA_NewLookMenus, then the default will be
*	    an appropriately colored Amiga-key, scaled to the screen's
*	    font.  Alternately, you can provide a custom one, which
*	    you can design yourself or get from sysiclass (use this if
*	    your menu-font is different from the screen's font).
*	    Ignored by V36/V37.
*
*   NOTES
*	Regarding Public Screens, you can specify a window to be a 
*	"visitor window" on a public screen in one of several ways.
*	In each case, you must be sure not to specify a NewWindow
*	type of CUSTOMSCREEN.  You should use the value PUBLICSCREEN.
*
*	There are actually several ways you can specify which screen
*	you want a visitor window to be opened on:
*
*	    1) Specify the name of the public screen WA_PubScreenName,
*	    or a NULL pointer, in ti_Data.  The name might have been
*	    provided by the user.  A NULL pointer means to use the
*	    default public screen.
*
*	    If the named screen cannot be found, the default public screen
*	    will be used if the Boolean attribute WA_PubScreenFallBack
*	    is TRUE.
*
*	    2) Specify a pointer to a public screen using the
*	    WA_PubScreen tag item.  The WA_PubScreenFallBack
*	    attribute has no effect.  You can specify the default
*	    public screen by providing a NULL pointer.
*
*	    You can also specify the pointer by setting NewWindow.Type
*	    to PUBLICSCREEN, and specifying the public screen pointer
*	    in NewWindow.Screen.  The WA_PubScreen tag item has precedent
*	    over this technique.
*
*	    Unless NULL, the screen pointer provided MUST be a valid
*	    public screen.  You may ensure this several ways:
*
*	    - Be the owner of the screen.
*	    - Have a window already open on the screen.
*	    - Use LockPubScreen() to prevent the screen from closing.
*	    - specifying the WFLG_VISITOR bit in NewWindow.Flags is not
*	      supported.
*
*	    It is anticipated that the last will be the most common method
*	    of opening public screens because you often want to examine
*	    properties of the screen your window will be using in order
*	    to compensate for differences in dimension, depth, and font.
*
*	    The standard sequence for this method is as follows:
*	    LockPubScreen()	- obtain a pointer and a promise
*	    layout window	- adapt your window to the screen you will use
*	    OpenWindow()	- using the pointer you specify
*	    UnlockPubScreen()	- once your window is open, you can let go
*				  of the lock on the public screen
*	    ... normal window even processing ...
*	    CloseWindow().
*
*	Regarding "service" windows, such as those opened for a system
*	requester or file requester associated with a given "client"window.
*	These windows should NOT be "visitor" windows.  Open them
*	using NewWindow.Type = CUSTOMSCREEN and NewWindow.Screen
*	equal to the screen of the client window (window->WScreen).
*	You can also use WA_CustomScreen, which has precedence.
*
*	This ensures that the requester service window will be allowed to
*	open on the same screen as the client window, even if that
*	screen is not a public screen, or has private status.
*
*	This has an implication for service/client protocol: when you
*	pass a window pointer to any system requester routine or
*	to a routine which creates some other other service window,
*	you MUST keep your window open until the client window
*	is closed.
*
*	If a requester service will allow a NULL client window, this
*	should indicate to open the service window on the default public
*	screen (probably Workbench).  The correct way to get a pointer 
*	to this screen is to call LockPubScreen( NULL ).  In this
*	case, you want to open as a visitor window, which means you
*	should use either PUBLICSCREEN or WA_PubScreen, described above.
*	You should call UnlockPubScreen() after your visitor window is open.
*
*	As of V36, gadgets in the right and bottom border
*	(specified with GACT_RIGHTBORDER and GACT_BOTTOMBORDER) only
*	contribute to the dimensions of the borders if they are also
*	GFLG_RELRIGHT and GFLG_RELBOTTOM, respectively.
*
*    RESULT
*	If all is well, returns the pointer to your new Window
*	If anything goes wrong, returns NULL
*
*    BUGS
*	When you open a window, Intuition will set the font of
*	the window's RastPort to the font of the window's screen.
*	This does not work right for GimmeZeroZero windows: the
*	BorderRPort RastPort has the font set correctly, but
*	Window.RPort is set up with the system default font.
*	For compatibility reasons, we won't be fixing this problem.
*
*	Also, there is a compatibility trick going on with the
*	default font of your window's RastPort if the screen's
*	font is "fancy."  See the SA_SysFont attribute described
*	under OpenScreen().
*
*	Unless you arrange otherwise, each window you open will allocate
*	a signal for your task from the 16 "user signals."
*	If no signal is available, your window will not be able
*	to be opened.  In early V36 versions and before, Intuition didn't
*	check this condition, but just left you with an unusable port.
*
*    SEE ALSO
*       OpenWindowTagList(), OpenScreen(), ModifyIDCMP(), SetWindowTitles(),
*	LockPubScreen(), SetDefaultPubScreen(), ZipWindow(),
*	layers.library/InstallLayerHook(), SetPubScreenModes()
*****************************************************************************/
d156 1
d368 2
a369 120
/****** intuition.library/CloseWindow ***************************************
*
*    NAME
*	CloseWindow -- Close an Intuition window.
*
*    SYNOPSIS
*	CloseWindow( Window )
*		     A0
*
*	VOID CloseWindow( struct Window * );
*
*    FUNCTION
*	Closes an Intuition window.  Unlinks it from the system, deallocates
*	its memory, and makes it disappear.
*
*	When this function is called, all IDCMP messages which have been sent
*	to your window are deallocated.  If the window had shared a message
*	Port with other windows, you must be sure that there are no unreplied
*	messages for this window in the message queue.  Otherwise, your program
*	will try to make use of a linked list (the queue) which contains free
*	memory (the old messages).  This will give you big problems.
*	See the code fragment CloseWindowSafely(), below.
*
*	NOTE:  If you have added a Menu strip to this Window (via
*	a call to SetMenuStrip()) you must be sure to remove that Menu strip
*	(via a call to ClearMenuStrip()) before closing your Window.
*	
*	NOTE: This function may block until it is safe to de-link and free
*	your window.  Your program may thus be suspended while the user
*	plays with gadgets, menus, or window sizes and position.
*	
*	New for V36: If your window is a "Visitor Window" (see OpenWindow)
*	CloseWindow will decrement the "visitor count" in the public screen
*	on which the window was open.  When the last visitor window is
*	closed, a signal will be sent to the public screen task, if this
*	was pre-arranged (see OpenScreen).
*
*    INPUTS
*	Window = a pointer to a Window structure
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	OpenWindow(), OpenScreen(), CloseScreen()
*
*    EXAMPLE
*    \*	CloseWindowSafely *\
*
*	\* these functions close an Intuition window
*	 * that shares a port with other Intuition
*	 * windows or IPC customers.
*	 *
*	 * We are careful to set the UserPort to
*	 * null before closing, and to free
*	 * any messages that it might have been
*	 * sent.
*	 *\
*	#include "exec/types.h"
*	#include "exec/nodes.h"
*	#include "exec/lists.h"
*	#include "exec/ports.h"
*	#include "intuition/intuition.h"
*
*	CloseWindowSafely( win )
*	struct Window *win;
*	{
*	    \* we forbid here to keep out of race conditions with Intuition *\
*	    Forbid();
*
*	    \* send back any messages for this window 
*	     * that have not yet been processed
*	     *\
*	    StripIntuiMessages( win->UserPort, win );
*
*	    \* clear UserPort so Intuition will not free it *\
*	    win->UserPort = NULL;
*
*	    \* tell Intuition to stop sending more messages *\
*	    ModifyIDCMP( win, 0L );
*
*	    \* turn multitasking back on *\
*	    Permit();
*
*	    \* and really close the window *\
*	    CloseWindow( win );
*	}
*
*	\* remove and reply all IntuiMessages on a port that
*	 * have been sent to a particular window
*	 * (note that we don't rely on the ln_Succ pointer
*	 *  of a message after we have replied it)
*	 *\
*	StripIntuiMessages( mp, win )
*	struct MsgPort *mp;
*	struct Window *win;
*	{
*	    struct IntuiMessage *msg;
*	    struct Node *succ;
*
*	    msg = (struct IntuiMessage *) mp->mp_MsgList.lh_Head;
*
*	    while( succ =  msg->ExecMessage.mn_Node.ln_Succ ) {
*
*		if( msg->IDCMPWindow ==  win ) {
*
*		    \* Intuition is about to free this message.
*		     * Make sure that we have politely sent it back.
*		     *\
*		    Remove( msg );
*
*		    ReplyMsg( msg );
*		}
*		    
*		msg = (struct IntuiMessage *) succ;
*	    }
*	}
*****************************************************************************/
d456 2
a457 41
/****** intuition.library/ActivateWindow *************************************
*
*    NAME
*	ActivateWindow -- Activate an Intuition window.
*
*    SYNOPSIS
*	ActivateWindow( Window )
*	                A0
*
*	VOID ActivateWindow( struct Window * );
*
*    FUNCTION
*	Activates an Intuition window. 
*
*	Note that this call may have its action deferred: you cannot assume
*	that when this call is made the selected window has become active. 
*	This action will be postponed while the user plays with gadgets and
*	menus, or sizes and drags windows.  You may detect when the window
*	actually has become active by the IDCMP_ACTIVEWINDOW IDCMP message.
*
*	This call is intended to provide flexibility but not to confuse the
*	user.  Please call this function synchronously with some action
*	by the user.
*
*    INPUTS
*	Window = a pointer to a Window structure
*
*    RESULT
*	None.
*
*    BUGS
*	Some versions of the documentation claimed that this function
*	had a meaningful return value under V36 and higher.  That is
*	not true.
*
*	Calling this function in a tight loop can blow out Intuition's
*	deferred action queue.
*
*    SEE ALSO
*	OpenWindow(), and the WFLG_ACTIVATE window flag
*****************************************************************************/
d466 2
a467 29
/****** intuition.library/RefreshWindowFrame ******************************
*
*    NAME
*	RefreshWindowFrame -- Ask Intuition to redraw your window border.
*
*    SYNOPSIS
*	RefreshWindowFrame( Window )
*			    A0
*
*	VOID RefreshWindowFrame( struct Window * );
*
*    FUNCTION
*	Refreshes the border of a window, including title region and all
*	of the window's gadgets.
*
*	You may use this call if you wish to update the display of your borders.
*	The expected use of this is to correct unavoidable corruption.
*
*    INPUTS
*	Window = a pointer to a Window structure
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*   
*****************************************************************************/
d959 1
a959 1
	setMouse(NULL);
d989 1
a989 1
	setMouse(w);
d998 2
a999 57
/****** intuition.library/SetWindowTitles ***********************************
*
*    NAME
*	SetWindowTitles -- Set the window's titles for both window and screen.
*
*    SYNOPSIS
*	SetWindowTitles( Window, WindowTitle, ScreenTitle )
*			 A0      A1           A2
*
*	VOID SetWindowTitles( struct Window *, UBYTE *, UBYTE * );
*
*    FUNCTION
*	Allows you to set the text which appears in the Window and/or Screen
*	title bars.
*
*	The window title appears at all times along the window title bar.
*	The window's screen title appears at the screen title bar whenever
*	this window is the active one.
*   
*	When this routine is called, your window title will be changed 
*	immediately.  If your window is the active one when this routine is 
*	called, the screen title will be changed immediately.
*   
*	You can specify a value of -1 (i.e. (UBYTE *) ~0) for either of
*	the title pointers.  This designates that you want Intuition to leave
*	the current setting of that particular title alone, and modify
*	only the other one.  Of course, you could set both to -1.
*
*	Furthermore, you can set a value of 0 (zero) for either of the
*	title pointers.  Doing so specifies that you want no title to
*	appear (the title bar will be blank).
*
*	Both of the titles are rendered in the default font of the window's
*	screen, as set using OpenScreen().
*
*	In setting the window's title, Intuition may do some other rendering
*	in the top border of your window.  If your own rendering sometimes
*	appears in your window border areas, you may want to restore the entire
*	window border frame.  The function SetWindowTitles() does not do this
*	in the newer versions.  The function RefreshWindowFrame() is provided
*	to do this kind of thing for you.
*
*    INPUTS
*	Window = pointer to your window structure
*	WindowTitle = pointer to a null-terminated text string, or set to
*           either the value of -1 (negative one) or 0 (zero)
*	ScreenTitle = pointer to a null-terminated text string, or set to
*           either the value of -1 (negative one) or 0 (zero)
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	OpenWindow(), RefreshWindowFrame(), OpenScreen()
*****************************************************************************/
d1030 2
a1031 65
/****** intuition.library/WindowLimits **************************************
*
*    NAME
*	WindowLimits -- Set the minimum and maximum limits of a window.
*
*    SYNOPSIS
*	Success = WindowLimits( Window, MinWidth, MinHeight, MaxWidth,
*	D0		        A0      D0        D1         D2
*	                        MaxHeight )
*	                        D3
*
*	BOOL WindowLimits( struct Window *, WORD, WORD, UWORD, UWORD );
*
*    FUNCTION
*	Sets the minimum and maximum limits of the window's size.  Until this
*	routine is called, the window's size limits are equal to the initial
*	values established in the OpenWindow() function.
*
*	After a call to this routine, the Window will be able to be sized
*	to any dimensions within the specified limits.
*	
*	If you don't want to change any one of the dimensions, set the limit
*	argument for that dimension to zero.  If any of the limit arguments 
*	is equal to zero, that argument is ignored and the initial setting
*	of that parameter remains undisturbed.
*   
*	If any of the arguments is out of range (minimums greater than the
*	current size, maximums less than the current size), that limit
*	will be ignored, though the others will still take effect if they
*	are in range.  If any are out of range, the return value from this
*	procedure will be FALSE.  If all arguments are valid, the return
*	value will be TRUE.
*
*	If you want your window to be able to become "as large as possible"
*	you may put -1 (i.e. ~0) in either or both Max arguments.  But
*	please note: screen sizes may vary for several reasons, and you
*	must be able to handle any possible size of window you might end
*	up with if you use this method.  Note that you can use the function
*	GetScreenData() to find out how big the screen your window appears in
*	is.  That function is particularly useful if your window is in
*	the Workbench screen.  You may also refer to the WScreen field
*	in your window structure, providing that your window remains open,
*	which will ensure that the screen remains open, and thus the
*	pointer remains valid.
*
*	If the user is currently sizing this window, the new limits will
*	not take effect until after the sizing is completed.
*
*    INPUTS
*	Window = pointer to a Window structure
*	MinWidth, MinHeight, MaxWidth, MaxHeight = the new limits for the size
*            of this window.  If any of these is set to zero, it will
*            be ignored and that setting will be unchanged.
*
*    RESULT
*	Returns TRUE if everything was in order.  If any of the parameters was
*	out of range (minimums greater than current size, maximums less than
*	current size), FALSE is returned and the errant limit request is
*	not fulfilled (though the valid ones will be).
*
*    BUGS
*
*    SEE ALSO
*	GetScreenData()
*****************************************************************************/
d1069 2
a1070 43
/****** intuition.library/MoveWindow **************************************
*
*    NAME
*	MoveWindow -- Ask Intuition to move a window.
*
*    SYNOPSIS
*	MoveWindow( Window, DeltaX, DeltaY )
*		    A0      D0      D1
*
*	VOID MoveWindow( struct Window *, WORD, WORD );
*
*    FUNCTION
*	This routine sends a request to Intuition asking to move the window 
*	the specified distance.  The delta arguments describe how far to 
*	move the window along the respective axes.  
*
*	Note that the window will not be moved immediately, but rather 
*	will be moved the next time Intuition receives an input event, 
*	which happens currently at a minimum rate of ten times per second,
*	and a maximum of sixty times a second.  
*
*	Interactions with other arbitration of Intuition data structures
*	may defer this operation longer.  For V36, you can use the new
*	IDCMP class IDCMP_CHANGEWINDOW to detect when this operation has
*	completed.
*
*	New for V36: Intuition now will do validity checking on the final
*	position.  To send absolute movements, or to move and size a
*	window in one step, use ChangeWindowBox().
*
*    INPUTS
*	Window = pointer to the structure of the Window to be moved
*	DeltaX = how far to move the Window on the x-axis
*	DeltaY = how far to move the Window on the y-axis
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	ChangeWindowBox(), SizeWindow(), WindowToFront(), WindowToBack()
*****************************************************************************/
d1087 2
a1088 52
/****** intuition.library/SizeWindow **************************************
*
*    NAME
*	SizeWindow -- Ask Intuition to size a window.
*
*    SYNOPSIS
*	SizeWindow( Window, DeltaX, DeltaY )
*		    A0      D0      D1
*
*	VOID SizeWindow( struct Window *, WORD, WORD );
*
*    FUNCTION
*	This routine sends a request to Intuition asking to size the window 
*	the specified amounts.  The delta arguments describe how much to 
*	size the window along the respective axes.  
*
*	Note that the window will not be sized immediately, but rather 
*	will be sized the next time Intuition receives an input event, 
*	which happens currently at a minimum rate of ten times per second,
*	and a maximum of sixty times a second.  You can discover when 
*	you window has finally been sized by setting the IDCMP_NEWSIZE flag
*	of the IDCMP of your window.  See the "Input and Output Methods"
*	chapter of The Intuition Reference Manual for description of the IDCMP.
*
*	New for V36: Intuition now will do validity checking on the final
*	dimensions.  To change to new absolute dimensions, or to move and
*	size a window in one step, use ChangeWindowBox().
*
*	However, limit checking against window MinWidth, MinHeight,
*	MaxWidth, and MaxHeight was not done prior to V36, and
*	these fields are still ignored (as documented) if you have
*	no sizing gadget (WFLG_SIZEGADGET is not set).  The *are*
*	respected now (V36) if WFLG_SIZEGADGET is set.
*
*	New for V36: you can determine when the change in size has
*	taken effect by receiving the IDCMP_CHANGEWINDOW IDCMP message.
*
*    INPUTS
*	Window = pointer to the structure of the window to be sized
*	DeltaX = signed value describing how much to size the window
*	 on the x-axis
*	DeltaY = signed value describing how much to size the window
*	 on the y-axis
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	ChangeWindowBox(), MoveWindow(), WindowToFront(), WindowToBack()
*****************************************************************************/
d1103 2
a1104 48
/****** intuition.library/ChangeWindowBox ***********************************
*
*    NAME
*	ChangeWindowBox -- Change window position and dimensions. (V36)
*
*    SYNOPSIS
*	ChangeWindowBox( Window, Left, Top, Width, Height )
*			 A0	 D0    D1   D2     D3
*
*	VOID ChangeWindowBox( struct Window *, WORD, WORD, WORD, WORD );
*
*    FUNCTION
*	Makes simultaneous changes in window position and dimensions,
*	in absolute (not relative) coordinates.
*
*	Like MoveWindow() and SizeWindow(), the effect of this function
*	is deferred until the next input comes along.  Unlike these 
*	functions, ChangeWindowBox() specifies absolute window position
*	and dimensions, not relative.  This makes for more reliable
*	results considering that the action is deferred, so this
*	function is typically preferable to MoveWindow() and SizeWindow()
*	paired.
*
*	You can detect that this operation has completed by receiving
*	the IDCMP_CHANGEWINDOW IDCMP message
*
*	The dimensions are limited to legal range, but you should still
*	take care to specify sensible inputs based on the window's dimension
*	limits and the size of its screen.
*
*	This function limits the position and dimensions to legal
*	values.
*
*    INPUTS
*	Window = the window to change position/dimension
*	Left, Top, Width, Height = new position and dimensions
*
*    RESULT
*	Position and dimension are changed to your specification,
*	or as close as possible.
*	Returns nothing.
*
*    BUGS
*
*    SEE ALSO
*	MoveWindow(), SizeWindow(), ZipWindow(),
*	layers.library/MoveSizeLayer()
*****************************************************************************/
d1121 2
a1122 33
/****** intuition.library/WindowToFront *************************************
*
*    NAME
*	WindowToFront -- Ask Intuition to bring a window to the front.
*
*    SYNOPSIS
*	WindowToFront( Window )
*	               A0
*
*	VOID WindowToFront( struct Window * );
*
*    FUNCTION
*	This routine sends a request to Intuition asking to bring the window 
*	in front of all other windows in the screen.
*
*	Note that the window will not be depth-arranged immediately, but rather 
*	will be arranged the next time Intuition receives an input event, 
*	which happens currently at a minimum rate of ten times per second,
*	and a maximum of sixty times a second.  
*
*	Remember that WFLG_BACKDROP windows cannot be depth-arranged.
*
*    INPUTS
*	Window = pointer to the structure of the window to be brought to front
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	MoveWindow(), SizeWindow(), WindowToBack(), MoveWindowInFrontOf()
*****************************************************************************/
d1135 2
a1136 29
/****** intuition.library/MoveWindowInFrontOf *****************************
*
*    NAME
*	MoveWindowInFrontOf -- Arrange the relative depth of a window. (V36)
*
*    SYNOPSIS
*	MoveWindowInFrontOf( Window, BehindWindow )
*			     A0      A1
*
*	VOID MoveWindowInFrontOf( struct Window *, struct Window * );
*
*    FUNCTION
*	Depth-arranges a window in front of an another window.
*	Brings out the layers.library MoveLayerInFrontOf() to the
*	Intuition user.
*
*    INPUTS
*	Window =  window to re-position in front of another window
*	BehindWindow =  window to re-position in front of
*
*    RESULT
*	Repositions window.
*
*    BUGS
*	Doesn't respect backdrop windows.
*	
*    SEE ALSO
*	WindowToFront(), WindowToBack(), layers.library/MoveLayerInFrontOf()
*****************************************************************************/
d1152 2
a1153 33
/****** intuition.library/WindowToBack **************************************
*
*    NAME
*	WindowToBack -- Ask Intuition to send a window behind others.
*
*    SYNOPSIS
*	WindowToBack( Window )
*		      A0
*
*	VOID WindowToBack( struct Window * );
*
*    FUNCTION
*	This routine sends a request to Intuition asking to send the window 
*	in back of all other windows in the screen.
*
*	Note that the window will not be depth-arranged immediately, but rather 
*	will be arranged the next time Intuition receives an input event, 
*	which happens currently at a minimum rate of ten times per second,
*	and a maximum of sixty times a second.  
*
*	Remember that WFLG_BACKDROP windows cannot be depth-arranged.
*
*    INPUTS
*	Window = pointer to the structure of the window to be sent to the back
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	MoveWindow(), SizeWindow(), WindowToFront(), MoveWindowInFrontOf()
*****************************************************************************/
d1229 2
a1230 43
/****** intuition.library/ScrollWindowRaster *********************************
*
*   NAME
*	ScrollWindowRaster -- Intuition-friendly ScrollRasterBF() (V39)
*
*   SYNOPSIS
*	ScrollWindowRaster(win, dx, dy, xmin, ymin, xmax, ymax)
*	                   A1   D0  D1  D2    D3    D4    D5
*
*	void ScrollWindowRaster(struct Window *, WORD, WORD,
*	    WORD, WORD, WORD, WORD);
*
*   FUNCTION
*	Calls graphics.library/ScrollRasterBF(), which moves
*	the bits in the raster by (dx,dy) towards (0,0)
*	The space vacated is filled by calling EraseRect().
*	Limit the scroll operation to the rectangle defined
*	by (xmin,ymin)(xmax,ymax). Bits outside will not be
*	affected. If xmax,ymax is outside the rastport then use
*	the lower right corner of the rastport.
*
*	As well, Intuition will automatically repair any gadget
*	or border damage to the window, then send you an
*	IDCMP_REFRESHWINDOW event if necessary.
*
*   INPUTS
*	win - pointer to a Window structure
*	dx,dy are integers that may be postive, zero, or negative
*	xmin,ymin - upper left of bounding rectangle
*	xmax,ymax - lower right of bounding rectangle
*
*   NOTES
*	This call uses ScrollRasterBF(), which calls EraseRect()
*	when clearing the newly exposed area. This allows use of
*	a custom layer backfill hook.
*
*   BUGS
*
*   SEE ALSO
*	graphics.library/ScrollRaster(), graphics.library/ScrollRasterBF()
*	graphics.library/EraseRect(), WA_BackFill
*
*****************************************************************************/
@


38.16
log
@Added ScrollWindowRaster() call.  Added docs for WA_NotifyDepth tag.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.15 92/03/19 15:56:50 peter Exp Locker: peter $
d765 5
d1713 2
a1714 2
    embossedBoxTrim( rp, &wbox, FRAMEHTHICK, FRAMEVTHICK,
	pens[ shinePen ], pens[ shadowPen ], 0 );
d1720 2
a1721 2
    embossedBoxTrim( rp, &wbox, FRAMEHTHICK, FRAMEVTHICK,
	pens[ shadowPen ], pens[ shinePen ], 0 );
d1817 1
a1817 1
	    /* ZZZ: maybe use hitextPen if active  */
d1819 1
a1819 1
		TESTFLAG( w->Flags,  WINDOWACTIVE )? hifilltextPen: textPen ],
d2574 1
a2574 1
*	graphics.library/EraseRect(), WA_BackFill.
@


38.15
log
@Window-depth flags have new names.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.14 92/03/03 16:37:07 peter Exp Locker: peter $
d785 8
d2527 80
@


38.14
log
@Renamed private screen flags.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.13 92/02/20 12:19:10 peter Exp Locker: peter $
d2366 1
a2366 1
    sendISMNoQuick( itDEPTHWIN, window, NULL, W_TOFRONT );
d2408 1
a2408 1
    sendISMNoQuick( itDEPTHWIN, w, behindw, W_TOMIDDLE );
d2455 1
a2455 1
    sendISMNoQuick( itDEPTHWIN, window, NULL, W_TOBACK );
@


38.13
log
@Now use screen->RastPort.BitMap instead of RealBitMap, since RealBitMap
no longer changes.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.12 92/02/17 17:19:23 peter Exp Locker: peter $
d1024 1
a1024 1
    if ( TESTFLAG( XSC(sc)->PrivateFlags, PRIVSCF_SCREENFONT ) )
@


38.12
log
@Removed references to unused itBORDERPATROL.
Now use XScreen->RealBitMap instead of screen->sc_BitMap.
Minor autodoc update.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.11 92/02/07 11:08:09 peter Exp Locker: peter $
d1006 1
a1006 1
    layer = CreateUpfrontHookLayer( &sc->LayerInfo, XSC(sc)->RealBitMap,
d1070 1
a1070 1
	layer = CreateUpfrontHookLayer( &sc->LayerInfo, XSC(sc)->RealBitMap,
@


38.11
log
@Window frame now filled in BACKGROUNDPEN, not color 0.  setWindow()
no longer has a return value.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.10 92/02/05 15:40:40 peter Exp Locker: peter $
d655 2
a656 2
*	WA_DetailPen
*	WA_BlockPen
d1006 1
a1006 1
    layer = CreateUpfrontHookLayer( &sc->LayerInfo, &sc->sc_BitMap,
d1070 1
a1070 1
	layer = CreateUpfrontHookLayer( &sc->LayerInfo, &sc->sc_BitMap,
a1316 5

	/*** if it is distant, I might not be the first
	 *** to issue BeginUpdate() (the customer)
	sendISM( itBORDERPATROL, window->WScreen );
	*****/
@


38.10
log
@Now uses/sets/clears XWindow->WinTitleLength.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.9 92/01/22 16:46:19 peter Exp Locker: peter $
d1833 7
a1839 4
    /* ZZZ: might want to soften the selection of 0 as the background pen
     */
    return (  TESTFLAG( w->Flags,  WINDOWACTIVE )?
	XSC(w->WScreen)->SPens[ hifillPen ] : 0 );
d1844 3
a1846 9
/* sets the window as the Active Window.  If the Window arg is NULL,
 * sets the system to NOWINDOW state
 *  if this Window has its own Pointer, we use it, else we use Intuition's
 *  if the window being activated labors under some extraordinary
 *  circumstances, this routine returns an exception value describing
 *  the circumstances.  Currently, these include:
 *	- window has a requester
 *	- window not found, 
 *  If there's no problem with the activation, returns 0
d1854 1
a1854 1
int setWindow( w, initial )
a1912 1
	return(SWE_NOACTIVE);	/* ain't nothing else to do */
d1914 4
d1919 17
a1935 20
    resetMenu(w, ~MIDRAWN,
	~ISDRAWN & ~HIGHITEM & ~MENUTOGGLED, ~HIGHITEM & ~MENUTOGGLED);

    SETFLAG( w->Flags, WINDOWACTIVE );

    activeEvent(IECLASS_ACTIVEWINDOW, NULL );

    /* Screen Title Algorithm:
     * Every time a Window is opened, it's ScreenTitle is set equal to the
     * Title of the Screen.  Every time a Window is activated, its 
     * ScreenTitle variable is compared with the Title variable of the Screen.
     * If they are different, the Screen's Title variable will get a copy
     * of the Screen's ScreenTitle variable, and the Screen Title Bar will
     * be redrawn
     */
    if (w->WScreen->Title != w->ScreenTitle)
	{
	w->WScreen->Title = w->ScreenTitle;
	screenbar(w->WScreen);
	}
d1937 1
a1937 1
    setScreen( w->WScreen );
d1939 2
a1940 2
    /** jimm: i don't know why it was here, but it's smaller now */
    windowMouse( w );
d1942 1
a1942 6
    setMouse(w);

    /* Redraw the border and the border gadgets.  However, if this is the
     * initial activation of a window, draw all the gadgets.
     */
    drawEmbossedBorder( w, !initial );	/* do "active" border */
d1944 5
a1948 2
    if (w->ReqCount) return (SWE_REQUEST);
    return(0);
@


38.9
log
@ActivateWindow() never did get a return value for V36.  Docs now match.
New way to handle clicking in the no-window area of a screen.  setWindow()
is no longer responsible.
The itACTIVATEWIN token is now sent with Object2 = FALSE.
setWindow() now knows to do a full gadget-redraw if it's the initial
rendering of the window border.
openWBPrefsScreen() now uses only tags, and goes through OpenScreenTagList().
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.8 91/11/15 18:55:22 peter Exp Locker: peter $
d1779 1
a1779 1
    int		numchars;
d1794 11
a1804 3
	numchars = TextFit( rp, w->Title,
	    strlen( w->Title), &te, NULL, 1,
	    textright - textleft, VBIG );
d2020 2
@


38.8
log
@Added windowObscured() function.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.7 91/09/23 12:30:14 peter Exp Locker: peter $
d1349 2
a1350 2
*	[success =] ActivateWindow( Window )
*	[D0]                        A0
d1352 1
a1352 2
*	[LONG] ActivateWindow( struct Window * );
*	\* returns LONG in V36 and higher *\
d1371 1
a1371 3
*	V35 and before: None.
*	V36 and later: returns zero if no problem queuing up
*	    the request for deferred action
d1374 3
a1376 2
*	Calling this function in a tight loop can blow out Intuition's deferred
*	action queue.
d1378 3
d1388 1
a1388 1
    sendISM( itACTIVATEWIN, window );
d1849 1
a1849 1
int setWindow( w, newascreen )
d1851 1
a1851 1
struct Screen *newascreen;
d1883 3
a1885 1
	/* jimm: 5/2/86: got to let application know to
a1906 7
	/* Peter 25-Jun-91: Clicking in the no-window area of a screen
	 * now activates that screen.
	 */
	if ( newascreen )
	{
	    setScreen( newascreen );
	}
d1939 4
a1942 2
    /* redraw border and border gadgets */
    drawEmbossedBorder( w, TRUE );	/* do "active" border */
@


38.7
log
@printEmbossedTitle() now uses SetABPenDrMd().
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.6 91/08/21 18:22:29 peter Exp Locker: peter $
d2460 62
@


38.6
log
@Changed comments about V38 to V39.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.5 91/07/25 15:05:23 peter Exp Locker: peter $
d1801 3
a1803 4
	    SetAPen( rp, XSC(w->WScreen)->SPens[ 
		TESTFLAG( w->Flags,  WINDOWACTIVE )? hifilltextPen: textPen ] );
	    SetBPen( rp, embossedFillPen( w ) );
	    SetDrMd( rp, JAM2 );
@


38.5
log
@Uses new W_TOFRONT, W_TOBACK, W_TOMIDDLE labels.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.4 91/07/15 15:29:46 peter Exp Locker: peter $
d785 1
a785 1
*	WA_NewLookMenus - (New for V38) ti_Data is a boolean.
d791 1
a791 1
*	    checkmark in menus.  Starting with V38, if WA_NewLookMenus
d800 1
a800 1
*	WA_AmigaKey - (ti_Data is struct Image *) (New for V38) Image
@


38.4
log
@Updated OpenWindow() autodoc to include WA_AmigaKey, WA_NewLookMenus,
WA_Checkmark, WA_MenuHelp.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 1.1 91/07/15 14:58:52 peter Exp $
d2369 1
a2369 1
    sendISMNoQuick( itDEPTHWIN, window, NULL, IUPFRONT );
d2411 1
a2411 1
    sendISMNoQuick( itDEPTHWIN, w, behindw, ITOMIDDLE );
d2458 1
a2458 1
    sendISMNoQuick( itDEPTHWIN, window, NULL, IBEHIND );
@


38.3
log
@Clicking in the no-window area of a screen now activates that screen.
Eliminated unneeded tconstraint in favor of NULL constraining extent
to TextFit().
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.2 91/06/24 12:16:52 peter Exp Locker: peter $
a660 1
*	WA_Checkmark
d780 30
@


38.2
log
@Now uses FreeVec() to free the window.  Removed unused local vbles.
Now uses new closeWindowCommon().
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.1 91/06/19 18:07:45 peter Exp Locker: peter $
a1745 1
    extern struct TextExtent	tconstraint;	/* a 'max' constraint */
d1765 1
a1765 1
	    strlen( w->Title), &te, &tconstraint, 1,
d1820 1
a1820 1
int setWindow( w )
d1822 1
d1876 7
@


38.1
log
@Removed !EMBOSSME and other obsolete code.
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 38.0 91/06/12 14:35:24 peter Exp Locker: peter $
a1225 5
    struct Layer *layer;
    struct RastPort *RPort;
    struct BitMap *BMap;
    struct Window *distantWindow;
    struct IntuiMessage *message, *nextmessage;
d1227 1
d1235 2
a1236 16
    /* delink, activate Parent if I was active */
    doISM( itCLOSEWIN, window );
    DCW( printf("CW: doISM returned\n") );

    /*** if it is distant, I might not be the first
     *** to issue BeginUpdate() (the customer)
    sendISM( itBORDERPATROL, window->WScreen );
    *****/

    /* jimm: 6/25/86: close font i might have opened */
    /* jimm: 7/29/86: close just the font I opened   */
    CloseFont(window->IFont);

    /* public screen stuff:
     *	decrement visitor count
     *	signal pub screen if last closer
a1239 2
	struct PubScreenNode	*psn;

d1244 12
a1255 2
	if ( XSC(window->WScreen)->PSNode )
	if ( psn = XSC(window->WScreen)->PSNode )
d1257 1
a1257 1
	    if ( decPSNVisitor( psn ) == 0 )
d1259 2
a1260 5
		if ( psn->psn_SigTask )	/* does he want a signal	*/
		{
		    Signal( psn->psn_SigTask, 1 << psn->psn_SigBit );
		}
	    }
d1263 35
d1299 1
a1299 1
    freeSysGadgets(window->FirstGadget);
d1311 1
a1311 4

    /* lastly, kiss that window goodnight */
    FreeMem(window, sizeof(struct XWindow));
    DCW( printf( "CloseWindow done\n") );
a1313 1
    
a1514 1
    int rightgadget = -1;
@


38.0
log
@Initial V38 check-in (matches V37 release).
@
text
@d6 1
a6 1
 *  $Id: windows.c,v 36.77 91/04/12 14:25:13 peter Exp $
a18 1
#if EMBOSSME
a19 1
#endif
a28 3
#define NEWHITUP	(1)

#define PATCHWBFONTS 0
a45 1
#if 1
a46 3
#else
    WINDOWSIZING,		/* converted from windowdepth for zoom */
#endif
a66 83
#if ! EMBOSSME
struct Gadget *allocGadget(RememberKey)
struct Remember **RememberKey;
{
    return((struct Gadget *)AllocRemember(RememberKey, 
	    sizeof(struct Gadget), MEMF_CLEAR));
}
#endif

#if ! EMBOSSME
/*
 * allocate a system gadget (on rememberkey parameter)
 * copy structure from system list
 * link it into some list
 */
struct Gadget	*
copySysGadget(res, type, gimme, firstg, workg, RememberKey)
USHORT res, type;
BOOL gimme;
struct Gadget **firstg, **workg;
struct Remember **RememberKey;
{
    struct IntuitionBase *IBase = fetchIBase();
    struct Gadget *g;

    if ((g = allocGadget(RememberKey)) == NULL) return(NULL);
    *g = *IBase->SysGadgets[res][type];

    if (gimme) g->GadgetType |= GZZGADGET;
    if (*firstg == NULL) *firstg = g;
    if (*workg) (*workg)->NextGadget = g;
    *workg = g;
    return( g );
}
#endif


#if 0	/* using windowBorders in wtags.c */
userBorders( w, g )
struct Window *w;
struct Gadget *g;
/* adjust the Window's Border variables to account for any of the Gadgets
 * that have BORDER flags set
 */
{
    struct GListEnv	genv;
    int temp;
    USHORT activation;
    struct Rectangle	grect;
    struct IBox		gadgetbox;

    if (!gListDomain(g, w, &genv)) goto OUT;

    while (g)
    {
	gadgetInfo(g, &genv );
	gadgetBox( g, &genv.ge_GInfo, &gadgetbox );
	activation = g->Activation;

	boxToRect( &gadgetbox, &grect );

	if (activation & LEFTBORDER)
	    if (w->BorderLeft < grect.MaxX ) w->BorderLeft = grect.MaxX;
	if (activation & RIGHTBORDER)
	    if (w->BorderRight < (temp = w->Width - gadgetbox.Left))
		w->BorderRight = temp;
	if (activation & TOPBORDER)
	    if (w->BorderTop < grect.MaxY ) w->BorderTop = grect.MaxY;
	if (activation & BOTTOMBORDER)
	{
	    if (w->BorderBottom < (temp = w->Height - gadgetbox.Top))
		w->BorderBottom = temp;
	}

	g = g->NextGadget;
    }

OUT:
    ;
}
#endif


a129 1
#if NEWHITUP
a152 1
#endif
a917 2
#define USE_HOOKLAYER	1

a941 1
#if USE_HOOKLAYER
a942 3
#else
    struct Layer 	*CreateUpfrontLayer();
#endif
a976 1
#if USE_HOOKLAYER
a983 8
#else
    layer = CreateUpfrontLayer( &sc->LayerInfo, &sc->sc_BitMap,
	    w->LeftEdge, w->TopEdge,
	    w->LeftEdge + w->Width - 1,
	    w->TopEdge + w->Height - 1,
	    firstflags, 
	    superbmap );
#endif
a1040 1
#if USE_HOOKLAYER
a1048 9
#else
	layer = CreateUpfrontLayer( &sc->LayerInfo, &sc->sc_BitMap,
	    w->LeftEdge + w->BorderLeft,
	    w->TopEdge + w->BorderTop,
	    w->LeftEdge + w->Width - 1 - w->BorderRight,
	    w->TopEdge + w->Height - 1 - w->BorderBottom, 
	    refresh, 
	    superbmap );
#endif
a1410 1
#if EMBOSSME
a1411 4
#else
	    g = copySysGadget(res, WGadgets[count], gimme,
			&firstg, &workg, RememberKey);
#endif
d1446 1
a1446 1
	{
d1450 1
a1450 1
	    {
a1451 1
#if EMBOSSME
d1461 1
a1461 4
#else
	    FreeMem(g, sizeof(struct Gadget));
#endif
	    }
d1465 1
a1465 1
	}
a1501 1
#if EMBOSSME
a1515 16
#else

    if ( TESTFLAG( w->Flags, WINDOWSIZING ) )
	rightgadget = ZOOMGADGET;
    else if ( TESTFLAG( w->Flags, WINDOWDEPTH ) )
	rightgadget = UPFRONTGADGET;

    /* return on pixel to the left, in all resolutions (?) */
    if ( rightgadget != -1 )
    {
	/* note that 'left' of these sys gadgets is negative (RELRIGHT) */
	right = w->Width + RomGadgetDefs[respick][rightgadget].l-GADGETPAD;
    }
    else right = (w->Width - 1);
#endif

a1553 2
#if EMBOSSME	/****** LOTS OF NEW STUFF FOR EMBOSSED LOOK *****/

a1574 1
#if 1	/* use drawGadgetsBorderFilter() */
a1575 32
#else
    /* do all gadgets, including the border ones */
    if ( ! border_gadgets_only )
    {
	drawGadgets(w, w->FirstGadget, -1);
    }
    else
    {
	struct Gadget	*g;

	for (g = w->FirstGadget; g; g = g->NextGadget)
	{
	    /* ZZZ: note that I assume all sysgadgets live
	     * in the border
	     */
	    if ( TESTFLAG( g->Activation, ALLBORDERS ) ||
#if 1
		/* refresh the "system" gadgets, not
		 * the gadgets that Intuition allocated,
		 * and pick up the g00 border gadgets, too.
		 */
		TESTFLAG( g->GadgetType, GZZGADGET | 0xF0 ) )
#else
		TESTFLAG( g->GadgetType, SYSGADGET ) )
#endif
	    {
		drawGadgets(w, g, 1);	/* refresh just */
	    }
	}

    }
#endif	/* use drawGadgetsBorderFilter() */
a1576 1
#if 1	/* Andy wants to see it run without this */
d1579 1
a1579 1
#endif
a1674 1
#if 1		/* using tight title region */
a1715 49
#else
updateEmbossedTitle( w )
struct Window	*w;
{
    struct RastPort	*rp;
    int			titleright;
    struct Gadget	*g;
    UWORD		type;

    LockLayerInfo(&w->WScreen->LayerInfo);
    LOCKGADGETS();
    if (w->BorderRPort) LockLayerRom( w->BorderRPort->Layer );
    LockLayerRom(w->WLayer);
    rp = obtainRP( &w->WScreen->RastPort, getGimmeLayer( w ) );

    /* a little heavy handed: redraw the entire title bar
     * from getleft() to right hand border
     */
    SetAPen( rp, embossedFillPen( w ) );
    if ( w->BorderTop )
    {
	RectFill( rp,
		getleft(w),
		FRAMEHTHICK,
		w->Width - 1 - FRAMEVTHICK,
		w->BorderTop - 1 - FRAMEHTHICK );
    }

    printEmbossedTitle( rp, w, TRUE );

    /* refresh all top border gadgets, except Close */
    for (g = w->FirstGadget; g; g = g->NextGadget)
    {
	type = 0xF0 & g->GadgetType;

	if ( TESTFLAG(g->Activation, TOPBORDER) ||
	    type == WUPFRONT || type == WZOOM )
	{
	    drawGadgets(w, g, 1);	/* refresh 1 */
	}
    }

    freeRP( rp );
    UnlockLayerRom(w->WLayer);
    if (w->BorderRPort) UnlockLayerRom(w->BorderRPort->Layer);
    UNLOCKGADGETS();
    UnlockLayerInfo(&w->WScreen->LayerInfo);
}
#endif
a1785 1
#endif 	/* EMBOSSME */
a1787 235
#if ! EMBOSSME

drawWFrame(w)
register struct Window *w;
{
    register struct RastPort *rp;
    register int right, bottom;
    struct IntuitionBase *IBase = fetchIBase();

    rp = obtainRP(&w->WScreen->RastPort, getGimmeLayer(w));

    right = w->Width - 1;
    bottom = w->Height - 1;

    rp->Mask = -1;
    SetDrMd(rp, JAM1);

    SetAPen(rp, 0);

    /* if any of the other borders is defined, erase it */

    /* ZZZ: why erase vertical borders if they are going to
     * JAM1'd anyway?  Because of "inner region?"
     */

    if (w->BorderLeft)
	RectFill(rp, 0, 0, w->BorderLeft - 1, bottom);
    if (w->BorderRight)
	RectFill(rp, right - (w->BorderRight - 1), 0, right, bottom);
    if (w->BorderBottom)
	RectFill(rp, 0, bottom - (w->BorderBottom - 1), right, bottom);

    if (!(w->Flags & BORDERLESS))
    {
	/* not Borderless, so draw the Border */
	drawBox(rp, 0, 0, w->Width, w->Height, w->BlockPen, JAM1,
		w->BorderLeft >> 1, 1);
    }

    /* fill in block */
    if (w->BorderTop) 
    {
	drawBlock(rp, 0, 0, w->Width - 1, w->BorderTop-2,w->BlockPen);
    }

    freeRP(rp);

    drawWindowTop(w, FALSE);	/* now do title and drag gadget */
    /* ZZZ: may want to inhibit refreshing topborder gadgets at this point */
}

/* locking notes: this routine gets a little screwed, in that it
 * may call RefreshGList (RefreshGadgets) which needs layerinfo
 * locks and gadgets locks (in order).  so to lock the lowly
 * rastport, these must be seized nice and early.
 */
drawWindowTop(w, gadgets_too)
struct Window *w;
BOOL gadgets_too;	/* if true, worry about gadgets in top border */
{
    int leftoffset;
    int rightoffset;
    int farrightoffset;
    int patternleft;	/* drag gadget pattern left edge */
    struct IntuiText itext;
    struct RastPort *rp;
    BOOL overdrawn = FALSE;	/* text runs into depth gadgets */
    struct Gadget *g;
    struct IntuitionBase *IBase = fetchIBase();
    extern USHORT	APattern[];

    if (w->BorderTop)
    {
	rp = obtainRP(&w->WScreen->RastPort, getGimmeLayer(w));

	rightoffset = getright(w, TRUE);	/* region inside gadgets */
	farrightoffset = getright(w, FALSE);
	patternleft = leftoffset = getleft(w);

#if 0	/* I hope I don't need this */
	/* draw the block */
	if (leftoffset < rightoffset)
	{
	    drawBlock(rp, leftoffset, 0, rightoffset,
		w->BorderTop-2,w->BlockPen);
	}
#endif

	if (w->Title)
	{
	    itext.FrontPen = w->DetailPen;
	    itext.BackPen = w->BlockPen;
	    itext.DrawMode = JAM2;
	    itext.TopEdge = 0;
	    itext.LeftEdge = 0;

	    /*???itext.ITextFont = w->WScreen->Font;*/
	    itext.ITextFont = NULL;

	    itext.IText = w->Title;	/** ZZZ: CLIP LENGTH HERE? **/
	    itext.NextText = NULL;

	    patternleft += RastPortITextLength(rp, &itext);
	    PrintIText(rp, &itext, leftoffset, 1);
	}

	/* if this Window has a drag bar, lay down the visuals */
	if ((w->Flags & WINDOWDRAG) )	/* subroutine will check that l>r */
	{
#if 1
	    /* twiddle around with the border spacing */
	    if ( patternleft+3 < farrightoffset - 1 )
	    {
		drawBlock(rp,
		    patternleft+3, 2, farrightoffset - 1, w->BorderTop - 3,	
		    w->BlockPen );
	    }

	    if ( patternleft+3 < rightoffset - 1 )
	    {
		drawWStripes( rp,
		    patternleft+3, 2, rightoffset - 1, w->BorderTop - 3,	
		    w->DetailPen, w->BlockPen );
	    }
#else
	    /* jimm: 7/19/86: subtract 3 from right offset */
	    BlastPattern(rp, 
		    patternleft, 1, 
		    rightoffset - 3, w->BorderTop - 3,
		    APattern, 3, 
		    w->DetailPen, w->BlockPen, JAM1);
#endif
	}

	/* can ditch this now, drawGadgets will take care of itself,
	 * and we like to put off locking layers and gadgets until
	 * now anyway.
	 */
	freeRP(rp);

	/* if gadgets_too, refresh all TOPBORDER user gadgets,
	 * and, if necessary, depth gadgets
	 */
	if (gadgets_too)	/* refresh top border gadgets */
	{
	USHORT type;

	    /* need gadgets lock, may later need Linfo lock,
	     * so get both, in correct order, now
	     */
	    LockLayerInfo(&w->WScreen->LayerInfo);
	    LOCKGADGETS();

	    /* did text smear into my system gadgets? */
	    overdrawn = (patternleft > farrightoffset);

	    for (g = w->FirstGadget; g; g = g->NextGadget)
	    {
		/* ZZZ: mask should be in intuition.h */
		type = 0xF0 & g->GadgetType;
		if ((g->Activation & TOPBORDER) ||
		    (overdrawn && (type == WUPFRONT || type == WZOOM)))
		{
		    drawGadgets(w, g, 1);	/* refresh 1 */
		}
	    }

	    UNLOCKGADGETS();
	    UnlockLayerInfo(&w->WScreen->LayerInfo);
	}
    }
}

#define RHARDMARGIN	(1)
#define RSOFTMARGIN	(7)
#define MINLL		(20)	/* min line length	*/
#define LEFTEXTRA	(14)	/* extra margin between text and stripes */
#define STRIPETHICK	(2)	/* res-dependent?	*/
#define SLOPE		(2)	/* tuned for non-lace	*/
 
drawWStripes( rp, left, top, right, bottom, penA, penB )
struct RastPort	*rp;
int	left, top, right, bottom;
UBYTE	penA, penB;
{
    int lineleft;
    int	lineright;
    int	rightend;
    int	bump;		/* increment		*/
    int	thickx;		/* thickness index	*/
    
    /* bevel in right edge by height, as if 45 degrees	*/
#if 1
    lineleft = left + SLOPE * (bottom - top + 1) + LEFTEXTRA;
    lineright = imax( right - RSOFTMARGIN, lineleft + MINLL );
#else
oops, slanted the wrong way
    lineright = imax( right - SLOPE * (bottom - top + 1), left + MINLL );
#endif

    SetDrMd(rp, JAM1);
    SetAPen( rp, penA );

    thickx = 0;
    while ( top <= bottom )
    {
	rightend = imin( lineright, right-RHARDMARGIN );

	/* ZZZ: need to skip some lines 	*/
	if ( (lineleft < rightend)  )
	{
	    Move( rp, lineleft, top );
	    Draw( rp, rightend, top );
	}

	thickx++;

	/* skip ahead to next stripe */
	if ( thickx >= STRIPETHICK )
	{
	    thickx = 0;		/* reset	*/
	    bump = STRIPETHICK + 1;
	}
	else
	    bump = 1;

	/* let's run this out for non-lace 2:1 pixels	*/

	top += bump;			/* next scan line	*/
	lineleft -= SLOPE * bump;	/* creep in on left	*/
	lineright -= SLOPE * bump;	/* creep out on right	*/
    }
}
#endif	/* ! EMBOSSME */

a1890 1
#if EMBOSSME
a1892 6
#else
    if (w->Title || w->Flags & WINDOWDRAG)
    {
	drawWindowTop(w, TRUE);	/* just the title and dragger */
    }
#endif
a1897 32


/*** ZZZ: note that this will dust over user gadgets in top border ***/
#if ! EMBOSSME
inactiveWindow(AWindow)
struct Window *AWindow;
{
    extern USHORT	BPattern[];
    int bottom;
    struct RastPort *RP;

    if (! knownWindow(AWindow)) return;

    AWindow->Flags &= ~WINDOWACTIVE;
    if ((AWindow->Title == NULL) && (!(AWindow->Flags & WINDOWDRAG)))
	return;

    RP = obtainRP(&AWindow->WScreen->RastPort, getGimmeLayer(AWindow)); 

    if ((bottom = AWindow->BorderTop - 3) > 0)
    {
	BlastPattern( RP,
		getleft(AWindow), 1, 
		getright(AWindow, TRUE), bottom,
		BPattern, 2, AWindow->BlockPen, 0, JAM1);
    }

    freeRP(RP);
}
#endif /* ! EMBOSSME */


a1961 1
#if EMBOSSME
a1962 4
#else
	drawWindowTop(window, TRUE);
	if (!(window->Flags & WINDOWACTIVE)) inactiveWindow(window);
#endif
a1982 37
#if !EMBOSSME
drawWindowBorder(window)
struct Window *window;
{
    int wwidth, wheight, gzzwidth, gzzheight;

    if (! knownWindow(window)) goto OUT;

    /* added by jimm to fix #1667
     *  inactiveWindow does a LockLayerInfo, so
     *  we must do it here before LockLayerRom
     */
    LockLayerInfo(&window->WScreen->LayerInfo);

    if (window->BorderRPort) LockLayerRom(window->BorderRPort->Layer);
	/** jimm: 11/18/85 layer change **/
    LockLayerRom(window->WLayer);

    drawWFrame(window);

    /* do gadgets */
    drawGadgets(window, window->FirstGadget, -1);

    if (!(window->Flags & WINDOWACTIVE)) inactiveWindow(window);

    UnlockLayerRom(window->WLayer);
    if (window->BorderRPort) UnlockLayerRom(window->BorderRPort->Layer);

    /* added by jimm */
    UnlockLayerInfo(&window->WScreen->LayerInfo);
OUT:

}
#endif



d2133 3
a2135 1
#if 1
a2139 18
#else
    /* Can't convert to absolutes upon entry, since a Move-Size succession
     * would then behave differently under 2.0.
     */
    struct Rectangle	positionlimits;

    windowBox( window, &newbox );

    newbox.Left += dx;
    newbox.Top += dy;

    /* limit position to legal values	*/
    windowPositionLimits( window, &positionlimits );
    limitPoint( &newbox.Left, &positionlimits );

    /* will copy box into event */
    sendISMNoQuick( itCHANGEWIN, window, &newbox, 0 );
#endif
@
