head     38.29;
branch   ;
access   ;
symbols  V40_85:38.29 V40_71:38.29 V40_68:38.29 V40_65:38.29 V40_47:38.29 V40_45:38.29 V40_37:38.29 V40_34:38.28 V40_29:38.28 V39_2415:38.27 V39_2369:38.27 V39_2339:38.27 V39_2332:38.27 V39_2275:38.26 V39_2256:38.26 V39_2210:38.25 V39_2192:38.24 V39_2084:38.23 V39_2082:38.23 V39_2076:38.23 V39_2073:38.23 V39_2058:38.23 V39_2051:38.23 V39_2031:38.23 V39_2017:38.23 V39_2012:38.23 V39_1985:38.23 V39_1933:38.23 V39_1819:38.21 V39_1805:38.21 V39_1783:38.21 V39_1695:38.21 V39_1621:38.21 V39_1620:38.21 V39_1508:38.21 V39_1485:38.20 V39_1461:38.20 V39_1458:38.20 V39_1456:38.20 V39_1405:38.19 V39_1368:38.17 V39_1360:38.17 V39_1324:38.16 V39_1147:38.15 V39_1143:38.15 V39_1141:38.15 V39_1120:38.15 V39_1116:38.15 V39_1104:38.15 V39_1100:38.15 V39_1078:38.15 V39_1073:38.15 V39_757:38.13 V39_702:38.13 V39_557:38.10 V39_553:38.10 V39_551:38.10 V39_510:38.9 V39_495:38.8 V39_416:38.6 V39_383:38.6 V39_371:38.6 V39_336:38.6 V39_323:38.5 V39_295:38.5 V39_277:38.4 V39_254:38.3 V39_222:38.3 V39_185:38.3 V39_171:38.3 V39_161:38.3 V38_159:38.3 V38_116:38.2 V38_59:38.1;
locks    ; strict;
comment  @*   @;


38.29
date     93.03.17.17.11.24;  author peter;  state Exp;
branches ;
next     38.28;

38.28
date     93.02.15.19.03.22;  author peter;  state Exp;
branches ;
next     38.27;

38.27
date     92.12.09.18.14.53;  author peter;  state Exp;
branches ;
next     38.26;

38.26
date     92.11.25.15.40.24;  author peter;  state Exp;
branches ;
next     38.25;

38.25
date     92.11.20.18.32.08;  author peter;  state Exp;
branches ;
next     38.24;

38.24
date     92.11.10.17.09.21;  author peter;  state Exp;
branches ;
next     38.23;

38.23
date     92.08.03.15.55.57;  author peter;  state Exp;
branches ;
next     38.22;

38.22
date     92.08.02.12.43.59;  author peter;  state Exp;
branches ;
next     38.21;

38.21
date     92.06.22.13.02.56;  author peter;  state Exp;
branches ;
next     38.20;

38.20
date     92.06.02.14.55.23;  author peter;  state Exp;
branches ;
next     38.19;

38.19
date     92.05.29.18.56.15;  author peter;  state Exp;
branches ;
next     38.18;

38.18
date     92.05.29.18.28.55;  author peter;  state Exp;
branches ;
next     38.17;

38.17
date     92.05.27.11.54.57;  author peter;  state Exp;
branches ;
next     38.16;

38.16
date     92.05.15.14.08.54;  author peter;  state Exp;
branches ;
next     38.15;

38.15
date     92.04.07.17.56.30;  author peter;  state Exp;
branches ;
next     38.14;

38.14
date     92.04.02.12.07.15;  author peter;  state Exp;
branches ;
next     38.13;

38.13
date     92.03.23.11.53.57;  author peter;  state Exp;
branches ;
next     38.12;

38.12
date     92.03.21.14.51.46;  author peter;  state Exp;
branches ;
next     38.11;

38.11
date     92.03.18.11.49.38;  author peter;  state Exp;
branches ;
next     38.10;

38.10
date     92.03.03.16.33.49;  author peter;  state Exp;
branches ;
next     38.9;

38.9
date     92.02.21.17.03.41;  author peter;  state Exp;
branches ;
next     38.8;

38.8
date     92.02.20.12.15.27;  author peter;  state Exp;
branches ;
next     38.7;

38.7
date     92.02.17.17.15.22;  author peter;  state Exp;
branches ;
next     38.6;

38.6
date     92.01.28.12.40.44;  author peter;  state Exp;
branches ;
next     38.5;

38.5
date     91.12.12.20.44.35;  author peter;  state Exp;
branches ;
next     38.4;

38.4
date     91.11.25.16.57.12;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     91.08.21.18.19.52;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     91.07.25.15.03.07;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.07.10.18.00.38;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.12.14.29.57;  author peter;  state Exp;
branches ;
next     ;


desc
@@


38.29
log
@Added sc_BitMapCopy to fix BitMap poker kludge.
@
text
@
/*** sc.h ****************************************************************
 *
 *  internal version of screens.h
 *
 *  $Id: sc.h,v 38.28 93/02/15 19:03:22 peter Exp Locker: peter $
 *
 *  Confidential Information: Commodore-Amiga Computer, Inc.
 *  Copyright (c) Commodore-Amiga Computer, Inc.
 *
 ****************************************************************************
 * CONFIDENTIAL and PROPRIETARY
 * Copyright (C) 1985, COMMODORE-AMIGA, INC.
 * All Rights Reserved
 ****************************************************************************/

#include "screens.h"

/** Screen structure with private extensions **/

/* macro to extend (cast) a screen pointer to XScreen */
#define XSC(s)	( (struct XScreen *) (s) )

/* The SpriteFactor.X value is exaggerated by four because
 * AA supports sprites whose horizontal resolution can be 1/4, 1/2,
 * double, quadruple, or the same as the screen's resolution.
 *
 * The SpriteFactor.Y value is exaggerated by two because AA supports
 * sprites whose vertical resolution can be half or double the
 * screen's resolution.
 */
#define SPRITEMULT_X	4
#define SPRITEMULT_Y	2

struct XScreen	{
    struct Screen	xs_Screen;

    /**************************************************/
    /**** Data below this point are SYSTEM PRIVATE ****/
    /**************************************************/

    struct ViewPortExtra *VPExtra;
			/* in the graphics associative cache	*/
			/* DisplayClip is in screen resolution coords */

    struct Rectangle	DClip;	
			/* in native screen coords		*/
    
    struct  PubScreenNode	*PSNode;

    /* what the screen is supposed to be (uncoerced)		*/
    struct MonitorSpec		*NaturalMSpec;
    CPTR			NaturalDRecord;
    ULONG			NaturalDisplayID;

    struct { WORD X; WORD Y;}	ScaleFactor;	/* for -to-mouse xform	*/
    ULONG			DProperties;	/* always current	*/

    /* We remember the screen's PixelSpeed and the screen's default
     * SpriteResolution.X when we figure the coerced mode
     */
    struct { WORD X; WORD Y;}	SpriteRes;

    UWORD			PixelSpeed;
    UWORD			VPModeStash;	/* secret copy to compare */

    struct TAttrBuff		TAttrBuff;	/* for snapshot		*/
    struct ColorMap		*ColorMap;	/* stash		*/
    /* SpriteFactor.X is now exaggerated by a factor of four, so we
     * can scale down too.  SpriteFactor.Y is exaggerated by a factor
     * of two, for the same reason.
     */
    struct { WORD X; WORD Y;}	SpriteFactor;	/* pixels-per-sprite pxl*/

    /* ZZZ: GADGETCOUNT from ibase.h */
    struct Image		*SysImages[ 8 ];
	
    struct DrawInfo		SDrawInfo;	/* embedded struct 	*/
    ULONG			PrivateFlags;
    ULONG			NaturalDProperties;
    struct { WORD X; WORD Y;}		VPOffsetStash;
    UWORD			SPens[ NUMDRIPENS + 1 ];
					/* terminated pen array	*/
    struct Layer_Info		*ClipLayer_Info;
    struct Layer		*ClipLayer;

    /* These fields are used if this is a parent screen.
     * Family is an exec list containing nodes as follows:
     * - For a parent screen, the list contains nodes for each child
     *   and the parent itself (in depth order).
     * - For a non-attached screen, the list contains the node for the
     *   screen itself.
     * - For a child-screen, the list is empty (the screen's own node
     *   will be found on its parent's Family list).
     */
    struct MinList		Family;		/* List of attached screens incl. self */

    /* These fields are used if this is a child screen: */
    struct MinNode		ChildNode;	/* Node on parent's list */
    struct Screen		*ParentScreen;	/* This screen's parent */
    /* Offset of child->TopEdge with respect to parentOriginY() */
    WORD			ParentYOffset;

    /* Replaces SaveColor0: 32-bit color values for screen beeping.
     * These must be together, in red/green/blue order:
     */
    ULONG			SaveRed;
    ULONG			SaveGreen;
    ULONG			SaveBlue;

    /* For custom screens, sc_BitMap was always a copy of some real bitmap.
     * Now, when Intuition allocates the bitmap (non-CUSTOMBITMAP screens)
     * it allocates a whole BitMap (not just the planes).  We keep a pointer
     * to the real bitmap here.  In such cases, RealBitMap is subject to
     * change due to double-buffering.  For CUSTOMBITMAP screens, RealBitMap
     * will be NULL.
     */
    struct BitMap		*RealBitMap;

    struct { WORD X; WORD Y;}	InitialScaleFactor;

    WORD LastColor;

    /* Offset of child->LeftEdge with respect to parentOriginX() */
    WORD ParentXOffset;

    /* The BitMap copy is used to ascertain when the screen's embedded
     * bitmap has been poked.  In V39, we used to compare the embedded
     * copy to the RealBitMap, but we found that DirectorII pokes
     * the RealBitMap (via screen.RastPort->BitMap).  When we found
     * this, we did the wrong thing, namely switching to use the
     * embedded BitMap.  Now we compare against this guaranteed-correct
     * copy.
     */
    struct BitMap sc_BitMapCopy;
};

/* Private screen flags:
 * PSF_SCREENFONT - means that one of the new SA_SysFont specifiers was
 *	used, so I'm to use the vanilla font for windows
 *	(i.e. GfxBase->DefaultFont), instead of the screen font.
 * PSF_DELAYBEEP - Set by DisplayBeep(), cleared the first time through
 *	doTiming().  This is to ensure that the beep lasts at least one
 *	vblank.
 * PSF_DRAGGABLE - Marks a draggable screen (all except those having
 *	{SA_Draggable,FALSE}).
 * PSF_EXCLUSIVE - Marks a screen made exclusive via {SA_Exclusive,TRUE}.
 * PSF_INCOMPATIBLE - Marks a screen which is exclusive by virtue of
 *	being MCOMPAT_NOBODY, according to the graphics database.
 * PSF_CHILDFRONT - When an existing child is attached to a newly opening
 *	parent, we set this flag if the attachment was done with
 *	SA_FrontChild, and clear this flag if the attachment was done
 *	with SA_BackChild.  We test this flag later to act on the request.
 * PSF_REMAKEVPORT - Set by MakeScreen() to inform rethinkVPorts() that
 *	this screen needs its copper-lists remade.
 * PSF_NEWSCREENOFFSETS - Set by coerceScreenGrunt() to indicate that the
 *	screen Left/Top should be respected over the ViewPort Dx/DyOffset
 *	because a coercion change moved the Left/Top.  (Ordinarily, unless
 *	a MEGAFORCE remake happens, we respect the ViewPort coordinates
 *	over the screen coordinates in order to support old overscan
 *	techniques.
 * PSF_SETFONT - Set by OpenScreen() after it successfully SetFont()s into
 *	the screen's RastPort.  This informs closeScreenCommon() that it's
 *	correct to CloseFont() that font.  Without this, certain OpenScreen()
 *	failures mean that cSC() would incorrectly CloseFont() the
 *	GfxBase->DefaultFont, which is what InitRastPort() placed in
 *	the screen RastPort.Font field
 * PSF_MINIMIZEISG - Corresponds to the state of SA_MinimizeISG, which
 *	is a V40 tag requesting that CalcISG() no longer ensure that
 *	the ISG is at least six laced lines.  Useful to get best appearance
 *	of your screen.
 */
#define PSF_SCREENFONT		(0x00000001)
#define PSF_DELAYBEEP		(0x00000002)
#define PSF_DRAGGABLE		(0x00000004)
#define PSF_EXCLUSIVE		(0x00000008)
#define PSF_INCOMPATIBLE	(0x00000010)
#define PSF_CHILDFRONT		(0x00000020)


#define PSF_NEWSCREENOFFSETS	(0x00000040)
#define PSF_REMAKEVPORT		(0x00000080)
#define PSF_SETFONT		(0x00000100)
#define PSF_MINIMIZEISG		(0x00000200)

/* Private Screen->Flags value meaning that this screen is hidden on account
 * of having a mode incompatible with the frontmost screen.
 */
#define SCREENHIDDEN	0x2000

/* Special private value to SA_LikeWorkbench tag used by the Workbench
 * screen only.
 */
#define LIKEWB_WORKBENCH	(~0)

/* Given a pointer to a ChildNode, return a pointer to the screen. */
#define SCREENFROMNODE(n)	((struct Screen *)( ((ULONG)n) - (ULONG)(&(((struct XScreen *)0)->ChildNode))))

/* cast to ExtNewScreen for use with Extension field 	*/
#define XNS(ns)	( (struct ExtNewScreen *) (ns) )

struct XScreenBuffer
{
	struct ScreenBuffer xsb_ScreenBuffer;	/* Instance of ScreenBuffer */
	ULONG sb_Flags;				/* Private flags, see below */
};

#define SB_FREEBITMAP	16	/* Marks bitmaps I alloc, so I know to free */

/* Macro to get at the private fields */
#define XSB(sb)	((struct XScreenBuffer *)(sb))
@


38.28
log
@Defined PSF_MINIMIZEISG.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.27 92/12/09 18:14:53 peter Exp Locker: peter $
d126 10
@


38.27
log
@Added ParentXOffset.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.26 92/11/25 15:40:24 peter Exp Locker: peter $
d158 4
d171 1
a171 1
#define PSF_NEWSCREENOFFSETS	(0X00000040)
d174 1
a174 1

@


38.26
log
@Added PSF_NEWSCREENOFFSETS.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.25 92/11/20 18:32:08 peter Exp Locker: peter $
d101 2
a102 1
    WORD			ParentYOffset;	/* Offset wrt. Parent */
d123 3
@


38.25
log
@Removed PSF_DRAGOVERRIDE.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.24 92/11/10 17:09:21 peter Exp Locker: peter $
d142 6
d162 2
@


38.24
log
@Added PSF_SETFONT to fix accidental CloseFont() during OpenScreen()
bug.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.23 92/08/03 15:55:57 peter Exp Locker: peter $
a132 3
 * PSF_DRAGOVERRIDE - The programmer can move his own non-draggable
 *	screens.  During the processing of such a call, this bit
 *	gets set.
d155 1
a155 1
#define PSF_DRAGOVERRIDE	(0x00000040)
@


38.23
log
@Uses SPRITEMULT instead of SPRITEFACTOR.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.22 92/08/02 12:43:59 peter Exp Locker: peter $
d145 6
d160 1
@


38.22
log
@ColorMap pointer is now struct ColorMap *.  Added LastColor field.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.21 92/06/22 13:02:56 peter Exp Locker: peter $
d24 7
a30 4
/* The SpriteFactor.X value is multiplied by four (2 bits) so that
 * we can use it to scale up or down, which is required for AA.
 * The SpriteFactor.Y value is multiplied by two (1 bit) so that
 * we can use it to scale up or down, which is required for AA.
d32 2
a33 2
#define SPRITEFACTOR_X	2
#define SPRITEFACTOR_Y	1
@


38.21
log
@SpriteFactor.Y is now exaggerated by a factor of two, to allow scaling
down, too.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.20 92/06/02 14:55:23 peter Exp Locker: peter $
d65 1
a65 1
    USHORT 			*ColorMap;	/* stash		*/
d117 2
@


38.20
log
@Added SpriteRes.Y field.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.19 92/05/29 18:56:15 peter Exp Locker: peter $
d26 2
d30 1
d67 2
a68 1
     * can scale down too.
@


38.19
log
@Changed InitialScaleFactor to match ScaleFactor.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.18 92/05/29 18:28:55 peter Exp Locker: peter $
d56 2
d59 1
a59 1
    UWORD			SpriteResX;
a66 1
    UWORD			VPModeStash;	/* secret copy to compare */
@


38.18
log
@Added SpriteResX field to Screen structure.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.17 92/05/27 11:54:57 peter Exp Locker: peter $
d111 1
a111 1
    Point InitialScaleFactor;
@


38.17
log
@Added LIKEWB_LIKEWORKBENCH flag.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.16 92/05/15 14:08:54 peter Exp Locker: peter $
d24 5
a49 6
    /* These are the promoted versions, used when the screen is
     * frontmost.  PromotedDisplayID is currently elsewhere in the structure.
     */
    struct MonitorSpec		*PromotedMSpec;
    CPTR			PromotedDRecord;

d53 6
d61 3
a101 3
    /* The display ID of the promoted version of this screen */
    ULONG			PromotedDisplayID;

d111 1
a111 2
    /* We remember the PixelSpeed when we figure the coerced mode */
    LONG			PixelSpeed;
@


38.16
log
@Defined new PSF_REMAKEVPORT flag.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.15 92/04/07 17:56:30 peter Exp Locker: peter $
d146 5
@


38.15
log
@Removed two unused fields.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.14 92/04/02 12:07:15 peter Exp Locker: peter $
d129 2
d139 1
@


38.14
log
@Added PixelSpeed cache.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.13 92/03/23 11:53:57 peter Exp Locker: peter $
a80 2
    struct Screen		*xxxFrontMember;	/* Frontmost child or self */
    struct Screen		*xxxBackMember;	/* Rearmost child or self */
@


38.13
log
@Added PSF_DRAGOVERRIDE definition.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.12 92/03/21 14:51:46 peter Exp Locker: peter $
d107 3
@


38.12
log
@Major simplification/change in attached screens.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.11 92/03/18 11:49:38 peter Exp Locker: peter $
d87 1
a87 1
    UWORD			ParentYOffset;	/* Offset wrt. Parent */
d118 3
d135 1
@


38.11
log
@PullDownOffset now ParentYOffset.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.10 92/03/03 16:33:49 peter Exp Locker: peter $
d71 12
a82 4
    /* These fields are used if this is a parent screen: */
    struct MinList		Children;	/* List of attached screens */
    struct Screen		*FrontMember;	/* Frontmost child or self */
    struct Screen		*BackMember;	/* Rearmost child or self */
d121 4
a124 3
 * PSF_CHILDDRAG - Marks a child screen as being independently
 *	draggable via the UI.  Dragging such a child is equivalent
 *	to dragging the parent.  Clear by {SA_ChildDrag,FALSE}. 
d131 1
a131 1
#define PSF_CHILDDRAG		(0x00000020)
@


38.10
log
@TopOffset renamed PullDown.  Renamed private screen flags.
Renamed SCREENEXCLUDE to SCREENHIDDEN.  Added PSF_CHILDDRAG.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.9 92/02/21 17:03:41 peter Exp Locker: peter $
d79 1
a79 1
    UWORD			PullDownOffset;	/* Offset wrt. Parent */
@


38.9
log
@Renamed Parent to ParentScreen.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.8 92/02/20 12:15:27 peter Exp Locker: peter $
d79 1
a79 1
    UWORD			TopOffset;	/* Offset wrt. Parent */
d101 15
a115 3
/* this flag means that one of the new SA_SysFont specifiers was
 * used, so I'll use the vanilla font for windows, rather than
 * the screen font.
d117 6
a122 9
#define PRIVSCF_SCREENFONT	(0x00000001)
/* We let one timer tick go by in delayed-beep state */
#define PRIVSCF_DELAYBEEP	(0x00000002)
/* Screen which is non-draggable by design: */
#define PRIVSCF_NODRAG		(0x00000004)
/* Screen which excludes others from the display, by designer's intent: */
#define PRIVSCF_EXCLUSIVE	(0x00000008)
/* Screen which gfx tells us is MCOMPAT_NOBODY */
#define PRIVSCF_MCOMPAT_NOBODY	(0x00000010)
d124 7
a132 3
/* Private Screen->Flags value */
#define SCREENEXCLUDE   0x2000 	/* screen has incompatible mode		*/

d142 1
a142 1
#define SB_FREEBITMAP	1	/* Marks bitmaps I alloc, so I know to free */
@


38.8
log
@Clarified comments about RealBitMap.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.7 92/02/17 17:15:22 peter Exp Locker: peter $
d78 1
a78 1
    struct Screen		*Parent;	/* This screen's parent */
@


38.7
log
@Defined XScreenBuffer structure and XSB() macro.  Added RealBitMap
to the XScreen structure.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.6 92/01/28 12:40:44 peter Exp Locker: peter $
d91 6
a96 5
    /* sc_BitMap is now always a copy of some real bitmap.
     * When Intuition allocates the bitmap, or for aware CUSTOMBITMAP
     * screens, we keep a pointer to the original real bitmap here.
     * For unaware CUSTOMBITMAP screens, RealBitMap will point
     * to &sc_BitMap.
@


38.6
log
@Defined PRIVSCF_MCOMPAT_NOBODY.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.5 91/12/12 20:44:35 peter Exp Locker: peter $
d90 8
d122 10
@


38.5
log
@Added PromotedMSpec, PromotedDRecord, and PromotedDisplayID to XScreen
structure.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.4 91/11/25 16:57:12 peter Exp Locker: peter $
d101 1
a101 1
/* Screen which excludes others from the display, by design: */
d103 2
@


38.4
log
@Marked two unused fields as such.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.3 91/08/21 18:19:52 peter Exp Locker: peter $
d45 6
a50 3
    /* use these, though: they are the coerced version	*/
    struct MonitorSpec		*xxxMSpec;
    CPTR			xxxDRecord;
d87 3
@


38.3
log
@Defined PRIVSCF_NODRAG and PRIVSCF_EXCLUDE.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.2 91/07/25 15:03:07 peter Exp Locker: peter $
d46 2
a47 2
    struct MonitorSpec		*MSpec;
    CPTR			DRecord;
@


38.2
log
@Added fields to XScreen structure to handle attached screens.
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.1 91/07/10 18:00:38 peter Exp Locker: peter $
d77 7
d93 4
@


38.1
log
@Deleted obsolete fields (14 bytes worth per screen).
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 38.0 91/06/12 14:29:57 peter Exp Locker: peter $
d67 10
d86 2
@


38.0
log
@Initial V38 check-in (matches V37 release).
@
text
@d6 1
a6 1
 *  $Id: sc.h,v 1.19 90/08/14 15:43:35 peter Exp $
a55 2
    struct Image		*CloseImage;	/* obsolete */

a58 2
    WORD			SDrawCount;
					/* use count: -1 means "fresh"	*/
d63 1
a63 2
    ULONG			scReserved[ 2 ];
    UWORD			SPens[ numDrIPens + 1 ];
a64 2
#if NO_CLIP_MENUS
#else
a66 1
#endif
@
