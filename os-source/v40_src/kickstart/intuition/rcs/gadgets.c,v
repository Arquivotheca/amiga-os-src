head     38.12;
branch   ;
access   ;
symbols  V40_85:38.12 V40_71:38.12 V40_68:38.12 V40_65:38.12 V40_47:38.12 V40_45:38.12 V40_37:38.12 V40_34:38.12 V40_29:38.12 V39_2415:38.12 V39_2369:38.11 V39_2339:38.10 V39_2332:38.10 V39_2275:38.10 V39_2256:38.10 V39_2210:38.10 V39_2192:38.10 V39_2084:38.9 V39_2082:38.9 V39_2076:38.7 V39_2073:38.7 V39_2058:38.7 V39_2051:38.7 V39_2031:38.7 V39_2017:38.7 V39_2012:38.7 V39_1985:38.7 V39_1933:38.7 V39_1819:38.7 V39_1805:38.7 V39_1783:38.7 V39_1695:38.7 V39_1621:38.6 V39_1620:38.6 V39_1508:38.6 V39_1485:38.6 V39_1461:38.6 V39_1458:38.6 V39_1456:38.6 V39_1405:38.6 V39_1368:38.6 V39_1360:38.6 V39_1324:38.6 V39_1147:38.5 V39_1143:38.5 V39_1141:38.5 V39_1120:38.5 V39_1116:38.5 V39_1104:38.5 V39_1100:38.5 V39_1078:38.5 V39_1073:38.5 V39_757:38.3 V39_702:38.2 V39_557:38.2 V39_553:38.2 V39_551:38.2 V39_510:38.2 V39_495:38.2 V39_416:38.2 V39_383:38.2 V39_371:38.2 V39_336:38.2 V39_323:38.2 V39_295:38.1 V39_277:38.1 V39_254:38.1 V39_222:38.1 V39_185:38.1 V39_171:38.1 V39_161:38.1 V38_159:38.1 V38_116:38.1 V38_59:38.0;
locks    ; strict;
comment  @*   @;


38.12
date     93.01.14.14.21.32;  author peter;  state Exp;
branches ;
next     38.11;

38.11
date     93.01.08.14.44.49;  author peter;  state Exp;
branches ;
next     38.10;

38.10
date     92.11.10.17.03.42;  author peter;  state Exp;
branches ;
next     38.9;

38.9
date     92.09.01.16.26.49;  author peter;  state Exp;
branches ;
next     38.8;

38.8
date     92.09.01.16.17.49;  author peter;  state Exp;
branches ;
next     38.7;

38.7
date     92.07.07.15.18.48;  author peter;  state Exp;
branches ;
next     38.6;

38.6
date     92.05.21.17.37.07;  author peter;  state Exp;
branches ;
next     38.5;

38.5
date     92.04.09.16.30.55;  author peter;  state Exp;
branches ;
next     38.4;

38.4
date     92.04.01.15.05.00;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     92.03.26.16.27.19;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     92.01.22.16.40.26;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.07.15.15.28.16;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.12.14.18.26;  author peter;  state Exp;
branches ;
next     ;


desc
@@


38.12
log
@NewModifyProp() now threaded through state machine.
@
text
@
/*** gadgets.c ***************************************************************
 *
 *  user-callable gadget routines
 *
 *  $Id: gadgets.c,v 38.11 93/01/08 14:44:49 peter Exp Locker: peter $
 *
 *  Confidential Information: Commodore-Amiga, Inc.
 *  Copyright (c) Commodore-Amiga, Inc.
 *
 ****************************************************************************/

#define D(x)	;

#include "intuall.h"
#include "imageclass.h"
#include "gadgetclass.h"

struct  Requester   *findGadgetRequest();
USHORT AddGList();
USHORT RemoveGList();

/*** intuition.library/AddGadget ***/

/* stub now calls AddGList() directly */


/*** intuition.library/AddGList ***/

USHORT AddGList(window, gadget, pos, numgad, requester)
struct Window *window;
struct Gadget *gadget;
UWORD pos;
UWORD numgad;
/* NB: AddGadget() historically calls here with garbage in the
 * requester parameter.  We must not look at it unless REQGADGET
 * is set!
 */
struct Requester *requester;
{
    struct Gadget *g, *lastg;
    SHORT realpos = 0;

    LOCKGADGETS();

    /* Take care of initialization issues when gadgets
     * are added to the window.  This includes setting
     * or clearing GFLG_IMAGEDISABLE according to what
     * the gadget's image says, and sending the initial
     * GM_LAYOUT method to GREL_ gadgets.
     */
    initGadgets( window, gadget, numgad );

#if 1
    if ( gadget->GadgetType & REQGADGET )
    {
	g = (struct Gadget *) &requester->ReqGadget;
    }
    else	/* window gadget */
    {
	g = (struct Gadget *) &window->FirstGadget;
	sniffWindowGadgets( window, gadget, numgad );
	/* check for border redraw conditions */
    }
#else
    /* find first gadget pointer , window or requester */
    g = (struct Gadget *) ((gadget->GadgetType & REQGADGET)? 
	&requester->ReqGadget: &window->FirstGadget);
#endif

    /* find pointer to previous gadget, real position */
    g = (struct Gadget *) nthThing(g, pos, &realpos);

    /* find last gadget in list passed in */
    lastg = (struct Gadget *) nthThing(gadget, numgad - 1, NULL);

    /* link in sublist */
    lastg->NextGadget = g->NextGadget;
    g->NextGadget = gadget;

    UNLOCKGADGETS();
    return(realpos);
}


/*** intuition.library/RemoveGadget ***/

/* stub now goes directly into RemoveGList() */


/*** intuition.library/RemoveGList ***/

USHORT RemoveGList(window, gadget, numgad)
struct Window *window;
struct Gadget *gadget;
WORD numgad;
{
    struct Gadget **firstgadget;
    struct Requester *req;
    SHORT pos = -1;

    /* protect from garbage in, as before */
    if (gadget == NULL) return ( -1 );

    /* find the requester this gadget is hooked up in, if
     * any.
     */

    if (gadget->GadgetType & REQGADGET)
    {
	req = findGadgetRequest(gadget, window);

	if (req) firstgadget = &req->ReqGadget;
	else return ( -1 );
    }
    else
    {
	firstgadget = &window->FirstGadget;
    }

    D( printf("RGL: doISM\n") );

    pos =  doISM( itREMOVEGAD, gadget, firstgadget, numgad );
    D( printf("RGL: doISM returned\n") );
    return ( pos );
}

/*
 * remove gadget sublist.
 * passed gadget of reference, first gadget in list that
 * it is a member of, and numgad (-1 means till end).
 *
 * return old position, or -1 
 */
delinkGadgetList( gadget, firstgadget, numgad )
struct Gadget	*gadget;
struct Gadget	*firstgadget;
{
    SHORT	pos;
    struct Gadget	*lastg;
    struct Gadget	*prevgadget;

    LOCKGADGETS();

    /* find previous gadget, calculate position */
    prevgadget = (struct Gadget *) previousThing(gadget, firstgadget, &pos);

    if ( prevgadget ) 
    {
	/* find last gadget in list passed in */
	lastg = (struct Gadget *) nthThing(gadget, numgad - 1, NULL);

	prevgadget->NextGadget = lastg->NextGadget;
    }
    else pos = -1;

    UNLOCKGADGETS();

    return ( pos );
}

/*
 * if gadget is in 'numgad' list starting with firstgadget
 * return true
 */
inGList( gadget, firstgadget, numgad )
struct Gadget	*gadget;
struct Gadget	*firstgadget;
{
    while ( numgad-- && firstgadget )
    {
	if ( firstgadget == gadget ) return ( TRUE );
	firstgadget = firstgadget->NextGadget;
    }
    return ( 0 );
}
/*** intuition.library/RefreshGadgets ***/

/* assembler stub calls drawGadgets() directly */


/*** intuition.library/RefreshGList ***/

/* assembler stub calls drawGadgets() directly */


/*** intuition.library/OnGadget ***/

OnGadget(gadget, ptr, req)
struct Gadget *gadget;
APTR ptr;
struct Requester *req;
{
    gadget->Flags &= ~GADGDISABLED;

    /* jimm: refresh ALL requester gadgets */
    drawGadgets( ptr, gadget, -2, DRAWGADGETS_ALL );
}

/*** intuition.library/OffGadget ***/

OffGadget(gadget, ptr, req)
struct Gadget *gadget;
APTR ptr;
struct Requester *req;
{
    gadget->Flags |= GADGDISABLED;

    /* jimm: refresh ALL requester gadgets */
    drawGadgets( ptr, gadget, -2, DRAWGADGETS_ALL );
}

/*** intuition.library/ModifyProp ***/

/*** intuition.library/NewModifyProp ***/

#if 000
/* Peter 1-Dec-90:  Some flags should not be altered.  Since I'm
 * a sucker for compatibility with perverse software, I'll chicken
 * out and only block PROPNEWLOOK :-(
 */
#define HANDS_OFF ( PROPNEWLOOK /* | PROPBORDERLESS | AUTOKNOB*/ )

NewModifyProp(gadget, aptr, req, flags, hpot, vpot, hbody, vbody, numgad)
struct Gadget *gadget;
APTR aptr;
struct Requester *req;
USHORT flags, hpot, vpot, hbody, vbody;
WORD numgad;	/* passed as -2 from ModifyProp interface	*/
{
    struct PropInfo	 *pinfo;
    struct GListEnv	genv;
    struct PGX		mypgx;

    pinfo = (struct PropInfo *)gadget->SpecialInfo;

    pinfo->Flags = (pinfo->Flags & HANDS_OFF) | (flags & ~HANDS_OFF) ;
    pinfo->HorizPot = hpot;
    pinfo->VertPot = vpot;
    pinfo->HorizBody = hbody;
    pinfo->VertBody = vbody;

    /* Jimm optimized things so that NMP() of a single gadget did
     * incremental updating instead of complete re-rendering.
     * (numgad passed as -2 from _modifyprop)
     * Peter 23-Mar-92: Now do full-redraw if the single gadget is
     * disabled, because NMP() of a disabled gadget was erasing
     * the ghosting pattern.
     */
    if ( ( numgad != 1 ) || ( TESTFLAG( gadget->Flags, GFLG_DISABLED ) ) )
    {
	drawGadgets( aptr, gadget, numgad, DRAWGADGETS_ALL );
    }
    else
    {
	if ( !gListDomain(gadget, aptr, &genv))
	{
	    return;
	}
	gadgetInfo( gadget, &genv  );

	setupPGX( gadget, &genv.ge_GInfo, &mypgx );

	/* ZZZ: relying on NewKnob being set up */

	renderNewKnob( gadget, &genv.ge_GInfo, &mypgx, NULL );
    }
}
#else
/* Peter 1-Dec-90:  Some flags should not be altered.  Since I'm
 * a sucker for compatibility with perverse software, I'll chicken
 * out and only block PROPNEWLOOK :-(
 */
#define HANDS_OFF ( PROPNEWLOOK /* | PROPBORDERLESS | AUTOKNOB*/ )
struct PropPacket
{
    UWORD Flags;
    UWORD HorizPot;
    UWORD VertPot;
    UWORD HorizBody;
    UWORD VertBody;
    UWORD NumGad;
};

NewModifyProp(gad, win, req, flags, hpot, vpot, hbody, vbody, numgad)
struct Gadget *gad;
struct Window *win;
struct Requester *req;
USHORT flags, hpot, vpot, hbody, vbody;
WORD numgad;	/* passed as -2 from ModifyProp interface	*/
{
    struct PropPacket pp;

    lockFree("NewModifyProp", LAYERINFOLOCK );
    lockFree("NewModifyProp", LAYERROMLOCK );
    lockFree("NewModifyProp", IBASELOCK );

    pp.Flags = flags;
    pp.HorizPot = hpot;
    pp.VertPot = vpot;
    pp.HorizBody = hbody;
    pp.VertBody = vbody;
    pp.NumGad = numgad;

    doISM( itMODIFYPROP, win, gad, &pp );
}

IModifyProp( gad, win, pp )
struct Gadget *gad;
struct Window *win;
struct PropPacket *pp;
{
    struct PropInfo	 *pinfo;
    struct GListEnv	genv;
    struct PGX		mypgx;

    pinfo = (struct PropInfo *)gad->SpecialInfo;

    pinfo->Flags = (pinfo->Flags & HANDS_OFF) | (pp->Flags & ~HANDS_OFF) ;
    pinfo->HorizPot = pp->HorizPot;
    pinfo->VertPot = pp->VertPot;
    pinfo->HorizBody = pp->HorizBody;
    pinfo->VertBody = pp->VertBody;

    /* Jimm optimized things so that NMP() of a single gadget did
     * incremental updating instead of complete re-rendering.
     * (numgad passed as -2 from _modifyprop)
     * Peter 23-Mar-92: Now do full-redraw if the single gadget is
     * disabled, because NMP() of a disabled gadget was erasing
     * the ghosting pattern.
     */
    if ( ( pp->NumGad != 1 ) || ( TESTFLAG( gad->Flags, GFLG_DISABLED ) ) )
    {
	drawGadgets( win, gad, pp->NumGad, DRAWGADGETS_ALL );
    }
    else
    {
	if ( !gListDomain(gad, win, &genv))
	{
	    return;
	}
	gadgetInfo( gad, &genv  );

	setupPGX( gad, &genv.ge_GInfo, &mypgx );

	/* ZZZ: relying on NewKnob being set up */

	renderNewKnob( gad, &genv.ge_GInfo, &mypgx, NULL );
    }
}
#endif

/* If this many pixels of a gadget which intersects the border is in
 * the window clear, then we don't bother BORDERSNIFFing it, since
 * we deem that enough of it is visible.
 */
#define GAD_MINVISIBLE	(4)


sniffWindowGadgets( w, g, numgad )
struct Window	*w;
struct Gadget	*g;
{
    struct GListEnv	genv;
    struct IBox		box;

    for ( ; numgad-- && g; g = g->NextGadget )
    {
	/* By default, a gadget won't be BORDERSNIFFed */
	CLEARFLAG( g->Activation, BORDERSNIFF );
	/* Gadgets that are declared as being in a window border
	 * or are system gadgets (Gadget->Type & GTYP_SYSTYPEMASK) or are
	 * GZZGADGETs are always to be redrawn.  Therefore, we
	 * mark them as BORDERSNIFFed.
	 */
	if ( TESTFLAG( g->Activation, (LEFTBORDER|RIGHTBORDER|TOPBORDER|BOTTOMBORDER) )
	    || TESTFLAG( g->GadgetType, GZZGADGET | GTYP_SYSTYPEMASK ) )
	{
	    SETFLAG( g->Activation, BORDERSNIFF );
	    continue;
	}
	/* Non-GZZGADGETs in a GIMMEZEROZERO window should never
	 * be BORDERSNIFFed. (Note by this point, we only have
	 * non-GZZGADGETs to consider).
	 * Peter 18-Jan-91: until recently, we used to never BORDERSNIFF
	 * gadgets in a BORDERLESS window, but even a BORDERLESS window
	 * can have borders, if somebody sets one of the xxxBORDER flags
	 * in one of their gadgets.  (Fixes Appetizer/Write)
	 */
	if ( TESTFLAG( w->Flags, GIMMEZEROZERO ) )
	{
	    continue;
	}

	/* get (relatively defined) box for gadget */
	if ( ! gListDomain( g, w, &genv))
	{
	    continue;
	}

	gadgetInfo( g, &genv  );
	gadgetBox( g, &genv.ge_GInfo, &box );

	/* now check box against window border dims, 
	 * and make the BORDERSNIFF bit correct.
	 *
	 * far borders take longer to check, but
	 * near borders are extremely rare.
	 *
	 * Peter 17-Aug-90: If more than GAD_MINVISIBLE pixels stick
	 * out into the window proper (or if that many pixels are beyond
	 * the bottom or right of the window, then we declare that this
	 * gadget doesn't need to be BORDERSNIFF, since it's either
	 * sufficiently reachable or so far outside the window as
	 * to be considered gone.
	 *
	 * Peter 12-Sep-90: Some prog's like Transcript use a 1x1 gadget
	 * (at x=y=0) with a solid color image to do color backfills.
	 * For them, we don't BORDERSNIFF any gadgets of size 1x1 or smaller.
	 */

	if (
	    ( ( box.Width > 1 ) || ( box.Height > 1 ) )
	    && (
	    (( box.Left >= w->Width - w->BorderRight - GAD_MINVISIBLE )
	     && ( box.Left + box.Width <= w->Width + GAD_MINVISIBLE ))
	    ||
	    (( box.Top >= w->Height - w->BorderBottom - GAD_MINVISIBLE )
	     && ( box.Top + box.Height <= w->Height + GAD_MINVISIBLE ))
	    ||
	    ( ( w->BorderLeft - box.Left ) > ( box.Width - GAD_MINVISIBLE ) )
	    ||
	    ( ( w->BorderTop - box.Top ) > ( box.Height - GAD_MINVISIBLE ) )
	       )
	    )
	{
	    SETFLAG( g->Activation, BORDERSNIFF );
	}
    }
}


/* Take care of initialization issues when gadgets
 * are added to the window.  This includes setting
 * or clearing GFLG_IMAGEDISABLE according to what
 * the gadget's image says, and sending the initial
 * GM_LAYOUT method to GREL_ gadgets.  Also sets
 * WMF_GADGETSCROLLRASTER if any gadget has the
 * GMORE_SCROLLRASTER flag set.
 */
initGadgets( win, g, numgad )
struct Window	*win;
struct Gadget	*g;
LONG		numgad;
{
    struct Image *image;
    struct GListEnv genv;
    LONG gotdomain;

    gotdomain = gListDomain( g, win, &genv );

    for ( ; numgad-- && g; g = g->NextGadget )
    {
	/* Force GFLG_IMAGEDISABLE off */
	CLEARFLAG( g->Flags, GFLG_IMAGEDISABLE );

	/* Is GadgetRender a non-NULL image? */
	if ( TESTFLAG( g->Flags, GFLG_GADGIMAGE ) && ( image = g->GadgetRender ) )
	{
	    /* Only perform GetAttr() if this is a boopsi image.
	     * Peter 1-Sep-92:  ProVector and others may be passing
	     * an uninitialized struct Image for an AUTOKNOB prop gadget.
	     * This was OK because Intuition never used fields it didn't
	     * itself initialize.
	     *
	     * Just testing for CUSTOMIMAGEDEPTH is not good enough,
	     * because the AUTOKNOB image could happen to have that value
	     * in the Depth field.  So we never ask this of imagery of
	     * AUTOKNOB PROPGADGETs.
	     */
	    if ( ( image->Depth == CUSTOMIMAGEDEPTH ) &&
		( ( ( g->GadgetType & GTYP_GTYPEMASK ) != GTYP_PROPGADGET ) ||
		( !TESTFLAG( PI(g)->Flags, AUTOKNOB ) ) ) )
	    {
		ULONG answer = 0;

		/* Does it support its own disabling? */
		GetAttr( IA_SupportsDisable, image, &answer );
		if ( answer )
		{
		    SETFLAG( g->Flags, GFLG_IMAGEDISABLE );
		}
	    }
	}

	/* If this gadget is GREL, then we must send it an initial
	 * GM_LAYOUT method, so it can establish its size.
	 */
	if ( ( gotdomain ) && ( TESTFLAG( g->Flags,
	    GFLG_RELRIGHT|GFLG_RELBOTTOM|GFLG_RELWIDTH|GFLG_RELHEIGHT|GFLG_RELSPECIAL) ) )
	{
	    gadgetInfo( g, &genv );
	    /* We send a GM_LAYOUT method to the gadget, expecting
	     * it to fill in its bounds field.  For gadgets that
	     * don't handle this method, nothing happens.
	     */
	    callHook( gadgetHook( g ), g, GM_LAYOUT, &genv.ge_GInfo, 1 );
	}	

	/* ScrollRaster() detection for boopsi gadgets is important,
	 * but it's incompatible with applications calling ScrollRaster()
	 * (really any non-Intuition damage-causing function).  We
	 * set WMF_GADGETSCROLLRASTER if we find any GMORE_SCROLLRASTER
	 * gadgets, and perform this incompatible handling for windows
	 * that have this flag.
	 */
	if ( TESTFLAG( g->Flags, GFLG_EXTENDED ) &&
	    TESTFLAG( ((struct ExtGadget *)g)->MoreFlags, GMORE_SCROLLRASTER ) )
	{
	    SETFLAG( win->MoreFlags, WMF_GADGETSCROLLRASTER );
	}
    }
}
@


38.11
log
@initGadgets() sets WMF_GADGETSCROLLRASTER if any gadget has
GMORE_SCROLLRASTER set.
@
text
@d6 1
a6 1
 *  $Id: gadgets.c,v 38.10 92/11/10 17:03:42 peter Exp Locker: peter $
d217 1
a217 2


d269 83
@


38.10
log
@Now use GTYP_SYSTYPEMASK instead of 0xF0.
@
text
@d6 1
a6 1
 *  $Id: gadgets.c,v 38.9 92/09/01 16:26:49 peter Exp Locker: peter $
d365 3
a367 1
 * GM_LAYOUT method to GREL_ gadgets.
d427 13
@


38.9
log
@Now only do the prop gadget patch when it's an AUTOKNOB.
@
text
@d6 1
a6 1
 *  $Id: gadgets.c,v 38.8 92/09/01 16:17:49 peter Exp Locker: peter $
d290 1
a290 1
	 * or are system gadgets (Gadget->Type & 0xF0) or are
d295 1
a295 1
	    || TESTFLAG( g->GadgetType, GZZGADGET | 0xF0 ) )
@


38.8
log
@Patch to fix crashes when an uninitialized image for an AUTOKNOB
happens to have a depth of -1.
@
text
@d6 1
a6 1
 *  $Id: gadgets.c,v 38.7 92/07/07 15:18:48 peter Exp Locker: peter $
d395 1
a395 1
	     * PROPGADGETS.
d398 2
a399 1
		 ( ( g->GadgetType & GTYP_GTYPEMASK ) != GTYP_PROPGADGET ) )
@


38.7
log
@No need to LOCKGADGETS() around findGadgetRequest().  Pass NULL
for new RastPort parameter to renderNewKnob().
@
text
@d6 1
a6 1
 *  $Id: gadgets.c,v 38.6 92/05/21 17:37:07 peter Exp Locker: peter $
d386 13
a398 2
	    /* Is it a boopsi image? */
	    if ( image->Depth == CUSTOMIMAGEDEPTH )
@


38.6
log
@Now passes DRAWGADGETS_ALL to drawGadgets().  RefreshGList() and
RefreshGadgets() stubs now call drawGadgets() directly.
@
text
@d6 1
a6 1
 *  $Id: gadgets.c,v 38.5 92/04/09 16:30:55 peter Exp Locker: peter $
a110 1
	LOCKGADGETS();
a111 1
	UNLOCKGADGETS();
d267 1
a267 1
	renderNewKnob( gadget, &genv.ge_GInfo, &mypgx );
@


38.5
log
@Now calls initGadgets() instead of setImageDisable().  initGadgets()
sends the initial GM_RESIZE method.
@
text
@d6 1
a6 1
 *  $Id: gadgets.c,v 38.4 92/04/01 15:05:00 peter Exp Locker: peter $
d25 1
a25 5
USHORT AddGadget(addptr, gadget, pos)
APTR addptr;
struct Gadget *gadget;
UWORD pos;
{
a26 2
    return (AddGList(addptr, gadget, pos, 1));
}
d35 4
d88 2
a89 6
USHORT RemoveGadget(window, gadget)
struct Window *window;
struct Gadget *gadget;
{
#if DEBUG
    USHORT rval;
a90 8
    printf("RemoveGadget(%lx, g=%lx)", window, gadget);
    rval = RemoveGList(window, gadget, 1);
    printf("... returns %ld\n", rval);
    return (rval);
#else
    return (RemoveGList(window, gadget, 1));
#endif
}
d181 3
a183 8
RefreshGadgets(gadgets, ptr, req)
struct Gadget *gadgets;
APTR ptr;
/* WARNING: internally, I depend on the third parameter being ignored */
{
    /* jimm: 8/26/86: refresh all gadgets in requesters */
    drawGadgets(ptr, gadgets, -2);  /* call more general routine */
}
d186 1
a186 8
RefreshGList(gadgets, ptr, req, numgad)
struct Gadget *gadgets;
APTR ptr;
struct Requester *req;
int	numgad;
{
    drawGadgets(ptr, gadgets, numgad);
}
d199 1
a199 2
    /* drawGadgets(ptr, gadget, -2); */
    RefreshGadgets(gadget, ptr);    /* I know that third parameter ignored */
d212 1
a212 2
    /* drawGadgets(ptr, gadget, -2); */
    RefreshGadgets(gadget, ptr);    /* I know that third parameter ignored */
d255 1
a255 1
	drawGadgets(aptr, gadget, numgad);
@


38.4
log
@Evicted autodocs.
@
text
@d6 1
a6 1
 *  $Id: gadgets.c,v 38.3 92/03/26 16:27:19 peter Exp Locker: peter $
d17 1
d48 5
a52 6
    /*** OUT
    initGadgets(window->WScreen, gadget, numgad);
    ***/

    /* Peter 12-Jul-91: Set or clear GFLG_IMAGEDISABLE according
     * to what the gadget's image says:
d54 1
a54 1
    setImageDisable( gadget, numgad );
d391 5
a395 2
/* Figure out if this gadget's image is smart enough to do its own
 * ghosting.  If so, sets GFLG_IMAGEDISABLE, else clears it.
d397 2
a398 1
setImageDisable( g, numgad )
d403 4
d429 14
@


38.3
log
@Fixed bug where NewModifyProp() of a ghosted prop would erase the
ghosting.
@
text
@d6 1
a6 1
 *  $Id: gadgets.c,v 38.2 92/01/22 16:40:26 peter Exp Locker: peter $
d22 1
a23 59
/****** intuition.library/AddGadget ***************************************
*
*    NAME
*	AddGadget -- Add a gadget to the gadget list of a window.
*
*    SYNOPSIS
*	RealPosition = AddGadget( Window, Gadget, Position )
*	D0			  A0      A1      D0
*
*	UWORD  AddGadget( struct Window *, struct Gadget *, UWORD );
*
*    FUNCTION
*	Adds the specified gadget to the gadget list of the given window,
*	linked in at the position in the list specified by the position 
*	argument (that is, if Position == 0, the gadget will be inserted
*	at the head of the list, and if Position == 1 then the gadget will
*	be inserted after the first gadget and before the second).  If the
*	position you specify is greater than the number of gadgets in the
*	list, your gadget will be added to the end of the list.
*	
*	Calling AddGadget() does not cause your gadget to be redisplayed.
*	The benefit of this is that you may add several gadgets without
*	having the gadget list redrawn every time.
*
*	This procedure returns the position at which your gadget was added.
*   
*	NOTE:  A relatively safe way to add the gadget to the end of the 
*	list is to specify a position of -1 (i.e., (UWORD) ~0).  That way,
*	only the 65536th (and multiples of it) will be inserted at the wrong
*	position.  The return value of the procedure will tell you where it was 
*	actually inserted.
*
*	NOTE:  The system window gadgets are initially added to the
*	front of the gadget list.  The reason for this is:  If you position
*	your own gadgets in some way that interferes with the graphical
*	representation of the system gadgets, the system's ones will be "hit"
*	first by user.  If you then start adding gadgets to the front of the
*	list, you will disturb this plan, so beware.  On the other hand, if
*	you don't violate the design rule of never overlapping your gadgets,
*	there's no problem.  
*
*	NOTE:  You may not add your own gadgets to a screen.  Gadgets may
*	be added to backdrop windows, however, which can be visually similar,
*	but also provide an IDCMP channel for gadget input messages.
*
*    INPUTS
*	Window = pointer to the window to get your gadget
*	Gadget = pointer to the new gadget
*	Position = integer position in the list for the new gadget (starting
*	    from zero as the first position in the list)
*
*    RESULT
*	Returns the position of where the gadget was actually added.
*
*    BUGS
*
*    SEE ALSO
*	AddGList(), RemoveGadget(), RemoveGList()
*****************************************************************************/
d33 1
a34 58
/****** intuition.library/AddGList ****************************************
*
*    NAME
*	AddGList -- Add a linked list of gadgets to a window or requester.
*
*    SYNOPSIS
*	RealPosition = AddGList( Window, Gadget, Position, Numgad, Requester )
*	D0                       A0      A1      D0        D1      A2
*
*	UWORD AddGList( struct Window *, struct Gadget *, UWORD, WORD,
*		struct Requester * );
*	
*    FUNCTION
*	Adds the list of gadgets to the gadget list of the given window
*	or requester linked in at the position in the list specified by
*	the position argument. 
*
*	See AddGadget() for more information about gadget list position,
*	and more information about gadgets in general.
*
*	The requester parameter will be ignored unless the GTYP_REQGADGET
*	bit is set in the GadgetType field of the first gadget in the list.
*	In that case, the gadget list is added to the requester gadgets.
*	NOTE: be sure that GTYP_REQGADGET is either set or cleared consistently
*	for all gadgets in the list.  NOTE ALSO: The window parameter
*	should point to the window that the requester (will) appear in.
*
*	Will add 'Numgad' gadgets from gadget list linked by the field
*	NextGadget, or until some NextGadget field is found to be NULL.  Does
*	not assume that the Numgad'th gadget has NextGadget equal to NULL.
*
*	NOTE WELL: In order to link your gadget list in, the NextGadget
*	field of the Numgad'th (or last) gadget will be modified.  Thus, if 
*	you are adding the first 3 gadgets from a linked list of five gadgets,
*	this call will sever the connection between your third and fourth
*	gadgets.
*
*    INPUTS
*	Window = pointer to the window to get your gadget
*	Gadget = pointer to the first gadget to be added
*	Position = integer position in the list for the new gadget
*	    (starting from zero as the first position in the list)
*	Numgad = the number of gadgets from the linked list to be added
*	    if Numgad equals -1, the entire null-terminated list of
*	    gadgets will be added.
*	Requester = the requester the gadgets will be added to if the
*	    GTYP_REQGADGET GadgetType flag is set for the first gadget
*	    in the list
*
*    RESULT
*	Returns the position of where the first gadget in the list was actually
*	added.
*
*    BUGS
*
*    SEE ALSO
*	AddGadget(), RemoveGadget(), RemoveGList()
*****************************************************************************/
d88 1
a89 46
/****** intuition.library/RemoveGadget **************************************
*
*    NAME
*	RemoveGadget -- Remove a gadget from a window.
*
*    SYNOPSIS
*	Position = RemoveGadget( Window, Gadget )
*	D0			 A0      A1
*
*	UWORD RemoveGadget( struct Window *, struct Gadget * );
*
*    FUNCTION
*	Removes the given gadget from the gadget list of the specified 
*	window.  Returns the ordinal position of the removed gadget.
*
*	If the gadget is in a requester attached the the window, this
*	routine will look for it and remove it if it is found.
*
*	If the gadget pointer points to a gadget that isn't in the
*	appropriate list, -1 is returned.  If there aren't any gadgets in the 
*	list, -1 is returned.  If you remove the 65535th gadget from the list
*	-1 is returned.
*
*    NOTES
*	New with V37: If one of the gadgets you wish to remove
*	is the active gadget, this routine will wait for the user
*	to release the mouse button before deactivating and removing
*	the gadget.
*
*    INPUTS
*	Window = pointer to the window containing the gadget or the requester
*	    containing the gadget to be removed.
*	Gadget = pointer to the gadget to be removed.  The gadget itself
*	    describes whether this is a gadget that should be removed from the
*	    window or some requester.
*
*    RESULT
*	Returns the ordinal position of the removed gadget.  If the gadget
*	wasn't found in the appropriate list, or if there are no gadgets in
*	the list, returns -1.
*
*    BUGS
*
*    SEE ALSO
*	AddGadget(), AddGList(), RemoveGList()
*****************************************************************************/
d105 1
a106 46
/****** intuition.library/RemoveGList **************************************
*
*    NAME
*	RemoveGList -- Remove a sublist of gadgets from a window.
*
*    SYNOPSIS
*	Position = RemoveGList( Window, Gadget, Numgad )
*	D0			A0	A1	D0
*
*	UWORD RemoveGList( struct Window *, struct Gadget *, WORD );
*
*    FUNCTION
*	Removes 'Numgad' gadgets from the gadget list of the specified 
*	window.  Will remove gadgets from a requester if the first
*	gadget's GadgetType flag GTYP_REQGADGET is set.
*
*	Otherwise identical to RemoveGadget().
*
*    NOTE
*	The last gadget in the list does NOT have its link zeroed.
*	New with V36: OK, last gadget's NextGadget field is set to NULL.
*	
*	New with V37: If one of the gadgets you wish to remove
*	is the active gadget, this routine will wait for the user
*	to release the mouse button before deactivating and removing
*	the gadget.
*
*    INPUTS
*	Window = pointer to the window containing the gadget or the requester
*	    containing the gadget to be removed.
*	Gadget = pointer to the gadget to be removed.  The gadget itself
*           describes whether this is a gadget that should be removed 
*           from the window or some requester.
*	Numgad = number of gadgets to be removed.  If -1, remove all gadgets
*	    to end of window gadget list
*
*    RESULT
*	Returns the ordinal position of the removed gadget.  If the gadget
*	wasn't found in the appropriate list, or if there are no gadgets in
*	the list, returns -1.
*
*    BUGS
*
*    SEE ALSO
*	RemoveGadget(), AddGadget(), AddGList()
*****************************************************************************/
d193 1
a194 75
/****** intuition.library/RefreshGadgets ************************************
*
*    NAME
*	RefreshGadgets -- Refresh (redraw) the gadget display.
*
*    SYNOPSIS
*	RefreshGadgets( Gadgets, Window, Requester )
*		        A0       A1      A2
*
*	VOID RefreshGadgets( struct Gadget *, struct Window *,
*		struct Requester * );
*
*    FUNCTION
*	Refreshes (redraws) all of the gadgets in the gadget list starting
*	from the specified gadget.  
*
*	The window parameter must point to the window which contains the
*	gadget, or which contains the requester that contains the gadget
*	The requester parameter must only be valid if the gadget has the
*	GTYP_REQGADGET flag set, a requirement for all requester gadgets.
*
*	The Pointer argument points to a Window structure.
*
*	The two main reasons why you might want to use this routine are:  
*	first, that you've modified the imagery of the gadgets in your 
*	display and you want the new imagery to be displayed; secondly, 
*	if you think that some graphic operation you just performed 
*	trashed the gadgetry of your display, this routine will refresh 
*	the imagery for you.  
*
*	Note that to modify the imagery of a gadget, you must first remove
*	that gadget from the window's gadget list, using RemoveGadget() (or
*	RemoveGList()).  After changing the image, border, text (including
*	text for a string gadget), the gadget is replaced in the gadget list
*	(using AddGadget() or AddGList()).  Adding gadgets does not cause
*	them to be displayed (refreshed), so this function, or RefreshGList()
*	is typically called.
*
*	A common technique is to set or reset the GFLG_SELECTED flag of a 
*	Boolean gadget and then call RefreshGadgets() to see it displayed
*	highlighted if and only if GFLG_SELECTED is set.  If you wish to do
*	this and be completely proper, you must RemoveGadget(), change the
*	GFLG_SELECTED flag, AddGadget(), and RefreshGadgets(), or the
*	equivalent.
*
*	The gadgets argument can be a copy of the FirstGadget variable in 
*	the Window structure that you want refreshed:  
*	the effect of this will be that all gadgets will be redrawn.  
*	However, you can selectively refresh just some of the gadgets 
*	by starting the refresh part-way into the list:  for instance, 
*	redrawing your window non-GTYP_GZZGADGET gadgets only, which you've 
*	conveniently grouped at the end of your gadget list.  
*
*	Even more control is available using the RefreshGList() routine which
*	enables you to refresh a single gadget, or number of your choice.
*
*	NOTE:  It's never safe to tinker with the gadget list yourself.  Don't
*	supply some gadget list that Intuition hasn't already processed in
*	the usual way.
*
*    INPUTS
*	Gadgets = pointer to the first in the list of gadgets wanting
*	    refreshment
*	Window = pointer to the window containing the gadget or its requester
*	Requester = pointer to a requester (ignored if gadget is not attached
*	    to a requester).
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	RefreshGList(), RemoveGadget(), RemoveGList(), AddGadget(), AddGList()
*****************************************************************************/
d203 1
a204 49
/****** intuition.library/RefreshGList ************************************
*
*    NAME
*	RefreshGList -- Refresh (redraw) a chosen number of gadgets.
*
*    SYNOPSIS
*	RefreshGList( Gadgets, Window, Requester, NumGad )
*		      A0       A1      A2         D0
*
*	VOID RefreshGList( struct Gadget *, struct Window *,
*		struct Requester *, WORD );
*
*    FUNCTION
*	Refreshes (redraws) gadgets in the gadget list starting
*	from the specified gadget.  At most NumGad gadgets are redrawn.
*	If NumGad is -1, all gadgets until a terminating NULL value
*	in the NextGadget field is found will be refreshed, making this
*	routine a superset of RefreshGadgets().
*
*	The Requester parameter can point to a Requester structure.  If 
*	the first gadget in the list has the GTYP_REQGADGET flag set, the 
*	gadget list refers to gadgets in a requester and the pointer 
*	must necessarily point to a window.  If these are not the gadgets 
*	of a requester, the requester argument may be NULL.  
*
*	Be sure to see the RefreshGadgets() function description, as this
*	function is simply an extension of that.
*   
*    INPUTS
*	Gadgets = pointer to the first in the list of gadgets wanting
*	    refreshment
*	Window = pointer to the window containing the gadget or its requester
*	Requester = pointer to a requester (ignored if Gadget is not attached
*	    to a Requester).
*	NumGad  = maximum number of gadgets to be refreshed.  A value of -1
*	  will cause all gadgets to be refreshed from gadget to the
*	  end of the list.  A value of -2 will also do this, but if 'Gadgets'
*	  points to a Requester Gadget (GTYP_REQGADGET) ALL gadgets in the
*	  requester will be refreshed (this is a mode compatible with v1.1
*	  RefreshGadgets().)
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	RefreshGadgets()
*****************************************************************************/
d215 1
a216 52
/****** intuition.library/OnGadget ********************************************
*
*    NAME
*	OnGadget -- Enable the specified gadget.
*
*    SYNOPSIS
*	OnGadget( Gadget, Window, Requester )
*		  A0      A1      A2
*
*	VOID OnGadget( struct Gadget *, struct Window *,
*		struct Requester * );
*
*    FUNCTION
*	This command enables the specified gadget.  When a gadget is
*	enabled, these things happen:
*        - its imagery is displayed normally (not ghosted)
*        - the GFLG_DISABLED flag is cleared
*        - the gadget can thereafter be selected by the user
*
*	The window parameter must point to the window which contains the
*	gadget, or which contains the requester that contains the gadget
*	The requester parameter must only be valid if the gadget has the
*	GTYP_REQGADGET flag set, a requirement for all requester gadgets.
*
*       NOTE:  it's never safe to tinker with the gadget list yourself.  Don't
*       supply some gadget that Intuition hasn't already processed in
*       the usual way.
*
*    	NOTE: for compatibility reasons, this function will refresh all
*	gadgets in a requester, and all gadgets from gadget to the 
*	end of the gadget list if gadget is in a window.
*
*	If you want to improve on this behavior, you may perform the
*	equivalent operation yourself: remove a gadget or gadgets,
*	change the state of their GFLG_DISABLED flag, replace the
*	gadgets using AddGList(), and selectively call RefreshGList().
*
*    INPUTS
*	Gadget = pointer to the gadget that you want disabled
*	Window = pointer to a window structure containing the gadget or
*	    containing the requester which contains the gadget
*	Requester = pointer to a requester (may by NULL if this isn't 
*           a requester gadget (i.e. GTYP_REQGADGET is not set)).
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	
*****************************************************************************/
d229 1
a230 52
/****** intuition.library/OffGadget *****************************************
*
*    NAME
*	OffGadget -- Disable the specified gadget.
*
*    SYNOPSIS
*	OffGadget( Gadget, Window, Requester )
*		   A0      A1      A2
*
*	VOID OffGadget( struct Gadget *, struct Window *,
*		struct Requester * );
*
*    FUNCTION
*	This command disables the specified gadget.  When a gadget is
*	disabled, these things happen:
*	     - its imagery is displayed ghosted
*	     - the GFLG_DISABLED flag is set
*	     - the gadget cannot be selected by User
*
*	The window parameter must point to the window which contains the
*	gadget, or which contains the requester that contains the gadget.
*	The requester parameter must only be valid if the gadget has the
*	GTYP_REQGADGET flag set, a requirement for all requester gadgets.
*
*       NOTE:  it's never safe to tinker with the gadget list yourself.  Don't
*       supply some gadget that Intuition hasn't already processed in
*       the usual way.
*
*    	NOTE: for compatibility reasons, this function will refresh all
*	gadgets in a requester, and all gadgets from gadget to the 
*	end of the gadget list if gadget is in a window.
*
*	If you want to improve on this behavior, you may perform the
*	equivalent operation yourself: remove a gadget or gadgets,
*	change the state of their GFLG_DISABLED flag, replace the
*	gadgets using AddGList(), and selectively call RefreshGList().
*
*    INPUTS
*	Gadget = pointer to the gadget that you want disabled
*	Window = pointer to a window structure containing the gadget or
*	    containing the requester which contains the gadget
*	Requester = pointer to a requester (may by NULL if this isn't 
*           a requester gadget (i.e. GTYP_REQGADGET is not set)).
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	AddGadget(), RefreshGadgets()
*****************************************************************************/
d243 1
d245 2
a246 106
/****** intuition.library/ModifyProp ****************************************
*
*    NAME
*	ModifyProp -- Modify the current parameters of a proportional gadget.
*
*    SYNOPSIS
*	ModifyProp( Gadget, Window, Requester, 
*		    A0	    A1	    A2
*           	    Flags, HorizPot, VertPot, HorizBody, VertBody )
*		    D0	   D1	     D2	      D3	 D4
*
*	VOID ModifyProp( struct Gadget *, struct Window *,
*		struct Requester *, UWORD, UWORD, UWORD, UWORD, UWORD );
*
*    FUNCTION
*	Modifies the parameters of the specified proportional gadget.  The 
*	gadget's internal state is then recalculated and the imagery 
*	is redisplayed in the window or requester that contains the gadget.
*
*	The requester variable can point to a requester structure.  If the 
*	gadget has the GTYP_REQGADGET flag set, the gadget is in a requester 
*	and the window pointer must point to the window of the requester.
*	If this is not the gadget of a requester, the requester argument may
*	be NULL.
*
*	NOTE: this function causes all gadgets from the proportional
*	gadget to the end of the gadget list to be refreshed, for
*	reasons of compatibility.
*	For more refined display updating, use NewModifyProp().
*
*	New for V36: ModifyProp() refreshing consists of redrawing gadgets
*	completely.  NewModifyProp() has changed this behavior (see 
*	NewModifyProp()).
*   
*    INPUTS
*	PropGadget = pointer to a proportional gadget
*	Window = pointer to the window containing the gadget or the window
*	    containing the requester containing the gadget.
*	Requester = pointer to a requester (may be NULL if this isn't 
*	    a requester gadget)
*	Flags = value to be stored in the Flags field of the PropInfo
*	HorizPot = value to be stored in the HorizPot field of the PropInfo
*	VertPot = value to be stored in the VertPot field of the PropInfo
*	HorizBody = value to be stored in the HorizBody field of the PropInfo
*	VertBody = value to be stored in the VertBody field of the PropInfo
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	NewModifyProp()
*	The Intuition Reference Manual and Amiga ROM Kernel Manual contain
*	more information on Proportional Gadgets.
*****************************************************************************/

/****** intuition.library/NewModifyProp *************************************
*
*    NAME
*	NewModifyProp -- ModifyProp(), but with selective refresh.
*
*    SYNOPSIS
*	NewModifyProp( Gadget, Window, Requester, Flags,
*		       A0      A1      A2         D0
*		HorizPot, VertPot, HorizBody, VertBody, NumGad )
*		D1        D2       D3         D4        D5
*
*	VOID NewModifyProp( struct Gadget *, struct Window *,
*		struct Requester *, UWORD, UWORD, UWORD, UWORD, UWORD, WORD );
*
*    FUNCTION
*	Performs the function of ModifyProp(), but refreshes
*	gadgets in the list as specified by the NumGad parameter. 
*	With NumGad = -1, this function is identical to ModifyProp().
*
*	New for V36: When NumGad = 1, this function will now perform
*	an incremental update of the proportional gadget knob image,
*	rather than refreshing the entire gadget.  This means much
*	less flashing when programmatically scrolling a proportional
*	gadget.
*   
*    INPUTS
*	PropGadget = pointer to a proportional gadget
*	Window = pointer to the window containing the gadget or the window
*	    containing the requester containing the gadget.
*	Requester = pointer to a requester (may be NULL if this isn't 
*	    a requester gadget)
*	Flags = value to be stored in the Flags field of the PropInfo
*	HorizPot = value to be stored in the HorizPot field of the PropInfo
*	VertPot = value to be stored in the VertPot field of the PropInfo
*	HorizBody = value to be stored in the HorizBody field of the PropInfo
*	VertBody = value to be stored in the VertBody field of the PropInfo
*	NumGad = number of gadgets to be refreshed after propgadget internals
*	    have been adjusted.  -1 means "to end of list."
*	     
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO 
*	ModifyProp()
*	The Intuition Reference Manual contains more information on
*	Proportional Gadgets.
*****************************************************************************/
@


38.2
log
@Fixed minor autodoc typo.
@
text
@d6 1
a6 1
 *  $Id: gadgets.c,v 38.1 91/07/15 15:28:16 peter Exp Locker: peter $
d806 8
a813 1
    if ( numgad != 1 ) /* numgad passed as -2 from _modifyprop */
@


38.1
log
@setImageDisable() figures out if the image or the gadget is to do
the ghosting.
@
text
@d6 1
a6 1
 *  $Id: gadgets.c,v 1.1 91/07/15 14:57:40 peter Exp $
d726 1
a726 1
*	The Intuition Reference Manual and Amiga Rom Kernel Manual contain
@


38.0
log
@Initial V38 check-in (matches V37 release).
@
text
@d6 1
a6 1
 *  $Id: gadgets.c,v 36.30 91/02/12 18:10:53 peter Exp $
d16 1
d166 5
d911 34
@
