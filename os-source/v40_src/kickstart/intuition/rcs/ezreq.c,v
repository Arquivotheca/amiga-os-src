head     38.15;
branch   ;
access   ;
symbols  V40_85:38.15 V40_71:38.15 V40_68:38.15 V40_65:38.15 V40_47:38.15 V40_45:38.15 V40_37:38.15 V40_34:38.15 V40_29:38.15 V39_2415:38.15 V39_2369:38.14 V39_2339:38.14 V39_2332:38.14 V39_2275:38.14 V39_2256:38.14 V39_2210:38.14 V39_2192:38.14 V39_2084:38.14 V39_2082:38.14 V39_2076:38.13 V39_2073:38.13 V39_2058:38.13 V39_2051:38.13 V39_2031:38.13 V39_2017:38.13 V39_2012:38.13 V39_1985:38.13 V39_1933:38.13 V39_1819:38.13 V39_1805:38.13 V39_1783:38.13 V39_1695:38.13 V39_1621:38.13 V39_1620:38.13 V39_1508:38.13 V39_1485:38.13 V39_1461:38.13 V39_1458:38.13 V39_1456:38.13 V39_1405:38.12 V39_1368:38.12 V39_1360:38.12 V39_1324:38.12 V39_1147:38.12 V39_1143:38.12 V39_1141:38.12 V39_1120:38.11 V39_1116:38.11 V39_1104:38.11 V39_1100:38.11 V39_1078:38.11 V39_1073:38.11 V39_757:38.9 V39_702:38.8 V39_557:38.7 V39_553:38.7 V39_551:38.7 V39_510:38.7 V39_495:38.6 V39_416:38.5 V39_383:38.4 V39_371:38.4 V39_336:38.3 V39_323:38.3 V39_295:38.3 V39_277:38.3 V39_254:38.3 V39_222:38.3 V39_185:38.3 V39_171:38.2 V39_161:38.2 V38_159:38.2 V38_116:38.2 V38_59:38.1;
locks    ; strict;
comment  @*   @;


38.15
date     93.01.12.16.17.38;  author peter;  state Exp;
branches ;
next     38.14;

38.14
date     92.09.01.15.04.39;  author peter;  state Exp;
branches ;
next     38.13;

38.13
date     92.06.03.17.24.28;  author peter;  state Exp;
branches ;
next     38.12;

38.12
date     92.05.01.13.51.47;  author peter;  state Exp;
branches ;
next     38.11;

38.11
date     92.04.07.17.48.23;  author peter;  state Exp;
branches ;
next     38.10;

38.10
date     92.04.01.15.04.24;  author peter;  state Exp;
branches ;
next     38.9;

38.9
date     92.03.26.16.26.09;  author peter;  state Exp;
branches ;
next     38.8;

38.8
date     92.03.18.11.48.15;  author peter;  state Exp;
branches ;
next     38.7;

38.7
date     92.02.21.17.02.42;  author peter;  state Exp;
branches ;
next     38.6;

38.6
date     92.02.17.17.11.26;  author peter;  state Exp;
branches ;
next     38.5;

38.5
date     92.02.11.13.36.57;  author peter;  state Exp;
branches ;
next     38.4;

38.4
date     92.02.05.15.38.14;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     91.10.17.14.29.06;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     91.07.25.15.02.05;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.07.10.17.54.07;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.12.14.16.36;  author peter;  state Exp;
branches ;
next     ;


desc
@@


38.15
log
@h/vResDivide() now inlined to save space.
@
text
@/*** ezreq.c *****************************************************************
 *
 *  EasyRequester 
 *
 *  $Id: ezreq.c,v 38.14 92/09/01 15:04:39 peter Exp Locker: peter $
 *
 *  Confidential Information: Commodore-Amiga, Inc.
 *  Copyright (C) 1989, Commodore-Amiga, Inc.
 *  All Rights Reserved
 *
 ****************************************************************************/

#include "intuall.h"
#include <exec/memory.h>
#include <dos/dosextens.h>
#include "ezreq.h"
#include "classusr.h"
#include "imageclass.h"
#include "gadgetclass.h"

#define D(x)	;
#define DEZ(x)	;
#define DSR(x)	;
#define DFSR(x)	;
#define DAR(x)	;
#define DMEM(x)	;

struct Window	*BuildEasyRequestArgs();
/*** intuition.library/EasyRequestArgs ***/

/* Intuitionface.asm calls this through stackSwap */

easyRequestArgs( rwin, ez, idcmp_ptr, args )
struct Window	*rwin;
struct EasyStruct *ez;
ULONG		*idcmp_ptr;
UWORD		*args;
{
    struct Window	*window;
    int			retval = 0;
    struct Window	*buildEasyRequestArgs();

    DMEM( printf("EasyRequestArgs in\n"));

    window = buildEasyRequestArgs(rwin, ez, idcmp_ptr? *idcmp_ptr: 0, args );

    /* window could be 'TRUE' or 'FALSE', as well as valid pointer */
    while ( (retval = SysReqHandler( window, idcmp_ptr, TRUE )) == -2 )
    {
	DEZ( printf("EasyR try again for input\n") );
	/* loop	*/;
    }

    DMEM( printf("EasyR free\n") );
    FreeSysRequest( window );
    DMEM( printf("EasyR returning %lx\n", retval ) );

    return ( retval );
}

/*** intuition.library/AutoRequest ***/


/* in intuitionface.asm, this gets called via stackSwap() */

BOOL
autoRequest( rwin, bodyt, goodt, badt, goodif, badif, width, height )
struct Window		*rwin;
struct IntuiText	*bodyt;
struct IntuiText	*goodt;
struct IntuiText	*badt;
ULONG			goodif;
ULONG			badif;
WORD			width;
WORD			height;
{
    int retval;
    struct Window	*window;
    ULONG		idcmp;
    APTR		buildSysRequest();

    DAR( printf("AutoRequest: rwin %lx, task %lx\n", rwin, FindTask( 0 ) ));
    DMEM( printf("AutoRequest in\n"));

    idcmp = goodif | badif;

    window = (struct Window *)buildSysRequest( rwin, 
	    bodyt, goodt, badt, idcmp, width, height);

    DAR( printf("window open\n") );

    if ( window == NULL || (int) window == 1)
    {
	return ( (int) window );
    }

    while ( (retval = SysReqHandler( window, &idcmp, TRUE )) == -2 )
    {
	/* loop	*/;
    }

    DAR( printf("AutoRequest satisfied, retval %ld\n", retval ) );

    /* do "goodflags/badflags" test	*/
    if ( retval == -1 )
    {
	retval =  ( idcmp & goodif )? 1: 0;
	DAR( printf("AutoRequest good/bad flags, retval %ld\n", retval ) );
    }

    FreeSysRequest( window );
    DAR( printf(" AR done, returning %lx\n", retval ) );

    DMEM( printf("AR done\n"));
    return ( retval );
}
/*** intuition.library/SysReqHandler ***/

/*
 * might return a gadgetid = 0, 1, ...
 * or 'no message' (-2), or 'user idcmp (-1)'
 *
 * 'no message' also can mean 'was rawkey, but wrong code'
 */
SysReqHandler( w, idcmp_ptr, wait_first )
struct Window	*w;
ULONG		*idcmp_ptr;
{
    struct IntuitionBase	*IBase = fetchIBase();
    UBYTE	code;

    int	windowval = (ULONG) w;
    struct IntuiMessage	*imsg;
    int			retval = -2;

    DSR( printf(" sRH enter\n") );

    if ( windowval == 0 || windowval == 1 )
    {
	DSR( printf("sRH says screw it, windowval %lx\n", windowval ) );
	return ( windowval );
    }

    if ( wait_first )
    {
	WaitPort( w->UserPort );
    }

    while ( retval == -2 &&
	(imsg = (struct IntuiMessage *) GetMsg( w->UserPort ) ) )
    {
	if ( imsg->Class == GADGETUP )
	{
	    retval = ((struct Gadget *) imsg->IAddress)->GadgetID;
	}
	else if ( imsg->Class == VANILLAKEY )
	{
	DSR( printf("got a vanillakey %lc (0x%lx)\n", imsg->Code, imsg->Code));

	    if ( imsg->Qualifier & IEQUALIFIER_LCOMMAND )
	    {
		/* new IControl Prefs	*/
		code = ToUpper( imsg->Code );

		if ( code == ToUpper( IBase->ReqFalseCode ) )
		    retval = 0;
		else if ( code == ToUpper( IBase->ReqTrueCode ) )
		    retval = 1;
	    }
	}
	else
	{
	    retval = -1;	/* tell him IDCMP */
	    if ( idcmp_ptr ) *idcmp_ptr = imsg->Class;
	}

	ReplyMsg( imsg );
    }
    return ( retval );
}
/*** intuition.library/BuildEasyRequestArgs ***/


/* In intuitionface.asm, this is called via stackSwap() */

struct Window	*
buildEasyRequestArgs( rwin, ez, iflags, args )
struct Window	*rwin;
struct EasyStruct *ez;
ULONG		iflags;
UWORD		*args;
{
    struct Remember	*remember = NULL;

    struct ITList	*formatITList();
    struct Window	*commonBSR();
    struct Screen	*LockPubScreen();
    struct Gadget	*createITGadget();

    struct ITList	*bodyitl = NULL;
    struct ITList	*gaditl = NULL;

    struct Window	*window = NULL;

    struct Screen	*screen = NULL;
    struct Gadget	*gadgets = NULL;
    struct Gadget	*g;
    int			id;
    struct IntuiText	*it;
    struct IntuiText	*succ_it;	/* successor	*/

    UWORD		*arglist = args;	/* varargs */

    Object		*frame = NULL;
    Object		*NewObject();

    extern UBYTE	*FrameIClassName;

    D( printf("BEasyR enter\n") );

    /* 8-Mar-91:  If I'm a process, initialize pr_Result2 to NULL */
    processFail( FALSE );

    /* pass arglists through RawDoFmt, and end up with
     * linked lists of IntuiText: one per line for body text,
     * one per gadget (for now, anyway) for gadgets
     */
    bodyitl = formatITList( ez->es_TextFormat,arglist,&arglist,&remember,'\n');
    gaditl = formatITList(ez->es_GadgetFormat,arglist,&arglist,&remember,'|');
    D( printf("BEasyR got text lists %lx %lx\n", bodyitl, gaditl) );
    if ( !( bodyitl && gaditl ) ) goto BAILOUT;

    /* get screen and gadgets early	*/
    if ( ! ( screen = rwin? rwin->WScreen: LockPubScreen( NULL ) ) )
	goto BAILOUT;
    D( printf("BEasyR: rwin at %lx, screen at %lx\n", rwin, screen ) );

    /* (screen && !rwin) means I'm on a public screen	*/

    /* get frame image object shared by gadgets	*/
    if ( ! ( frame = NewObject( NULL, FrameIClassName,
	TAG_END ) ) )
	goto BAILOUT;

    DFSR( printf("allocated frame object at %lx\n", frame ));

    /* get the gadgets, one per IntuiText for now	*/
    id = 1;
    g = (struct Gadgets *) &gadgets;	/* 'g' is 'last gadget' */
    for ( it = gaditl->itl_IText; it; it = succ_it )
    {
	succ_it = it->NextText;		/* stash successor	*/
	it->NextText = NULL;		/* break link 		*/

	/*** 
	it->FrontPen = GTEXTCOLOR;
	it->DrawMode = 0;
	it->TopEdge = GADVMARGIN;
	it->LeftEdge = GADHMARGIN ;
	***/

	if (! (g = createITGadget( screen, it, &remember, g, id++, frame ) ))
	    goto BAILOUT;
    }
    g->GadgetID = 0;	/* last one is always zero	*/

    D( printf("BEasyR calling cBSR\n") );
    window =  commonBSR( rwin, screen, ez->es_Title,
			bodyitl->itl_IText, gadgets, frame,
			iflags, &remember, TRUE );	/* do layout	*/

    /*** Don't allocate anything else on 'remember' after commonBSR() ***/

    if ( window == NULL )
    {
	D( printf("BEasyR: no window back from BSR\n") );
	goto BAILOUT;
    }

    goto DONE;

BAILOUT:
    D( printf("BEasyR freeing: bail out\n") );

    /* free boopsi gadgets here	*/
    disposeGadgetList( gadgets );

    FreeRemember( &remember, TRUE );
    DisposeObject( frame );

    /* 8-Mar-91:  If I'm a process, fail with ERROR_NO_FREE_STORE */
    processFail( TRUE );

DONE:
    D( printf("BEasyR success: %lx\n", window ) );
    if ( screen && !rwin )
    {
	D( printf("BEasyR: Unlocking pubscreen %lx\n", screen ) );
	UnlockPubScreen( NULL, screen );
    }
    return ( window );
}
/*** intuition.library/BuildSysRequest ***/


/* In intuitionface.asm, this function gets called via stackSwap()	 */

APTR
buildSysRequest( rwin, bodyt, retryt, cancelt, iflags, width, height )
struct Window		*rwin;
struct IntuiText	*bodyt;
struct IntuiText	*retryt;
struct IntuiText	*cancelt;
ULONG			iflags;
{
    struct Remember	*remember = NULL;
    struct Screen	*screen;
    struct Gadget	*gadgets = NULL;
    struct Gadget	*g;
    struct Window	*window = NULL;
    struct Window	*commonBSR();

    Object		*frame = NULL;
    Object		*NewObject();
    extern UBYTE	*FrameIClassName;

    D(printf( "In rBSR\n" ) );
    if ( ! cancelt ) return ( NULL );	/* quick check	*/

    if ( ! ( screen = rwin? rwin->WScreen: LockPubScreen( NULL ) ) )
    {
	DMEM( printf("no lock pub, bailout\n"));
	goto BAILOUT;
    }
    /* (screen && !rwin) means I'm on a public screen	*/

    /* get frame image object shared by gadgets	*/
    if ( ! ( frame = NewObject( NULL, FrameIClassName,
	TAG_END ) ) )
	goto BAILOUT;

    DFSR( printf("allocated frame object at %lx\n", frame ));

    /* create one or two gadgets from provided text	*/
    if (!(g=createITGadget( screen, cancelt, &remember, &gadgets, 0, frame)))
    {
	DMEM( printf("no cancel gadget\n"));
	goto BAILOUT;
    }

    /* try to get (optional) retry gadget, if text was provided	*/
    if ( retryt )
    {
	if (!createITGadget( screen, retryt, &remember, &gadgets, 1, frame )) 
	{
	    DMEM( printf("createITG retryg bailout\n"));
	    goto BAILOUT;
	}
    }

    window =  commonBSR( rwin, screen, NULL,
			bodyt, gadgets, frame,
			iflags, &remember, FALSE );	/* don't layout	*/
    /*** Don't allocate anything else on 'remember' after commonBSR() ***/

    if ( window == NULL )
    {
	DMEM( printf("BEasyR: no window back from BSR\n") );
	goto BAILOUT;
    }

    goto DONE;

BAILOUT:
    DMEM( printf("BSR freeing: bail out\n") );

    /* free boopsi gadgets here	*/
    disposeGadgetList( gadgets );

    FreeRemember( &remember, TRUE );
    DisposeObject( frame );

DONE:
    if ( screen && !rwin )
    {
	UnlockPubScreen( NULL, screen );
    }
    D( printf( "Exiting rBSR with window = %lx\n", window ) );
    return ( window );
}

#define	ezreqPattern	CPattern
#define ezreqPatSize	(1)

/* resolution precalculations in ticks	*/
#define VSPACETICKS	(4 * MOUSESCALEY)	/* vertical margins	*/
#define HSPACETICKS	(4 * MOUSESCALEX)	/* horiz margins	*/
#define HGADSPACETICKS	(12 * MOUSESCALEX)	/* between gadgets	*/
#define HTEXTMARGINTICKS (20 * MOUSESCALEX)	/* text in box		*/

/*
 * Common BuildSysRequest/BuildEasyRequest
 * will NOT FreeRemember if it aborts, that's up to caller
 * if I return NULL or (s Window *) 1.
 * Don't allocate anything else on 'remember' after commonBSR()!
 */
struct Window	*
commonBSR( rwin, refscreen, eztitle, itext, glist, gadgetframe,
	iflags, remkey, layout_body )
struct Window	*rwin;
struct Screen	*refscreen;
UBYTE		*eztitle;
struct IntuiText	*itext;
struct Gadget	*glist;
Object		*gadgetframe;
ULONG		iflags;
struct Remember	**remkey;
BOOL		layout_body;
{
    struct Window	*reqWindow();
    struct DrawInfo	*GetScreenDrawInfo();
    extern UWORD	ezreqPattern[];

    struct Window	*retwindow = NULL;
    struct SysReqTrack	*srt;

    int gadcount;
    struct DrawInfo	*drinfo;
    struct Image	*itextimage;
    struct Image	*textframe;
    struct IBox		framebox;
    struct IBox		gadgetbox;
    WORD		vspace, hspace;
    WORD		hgadspace;
    STRPTR		title;
    struct IBox		reqBox;
    struct Gadget	*image_gad;

    extern UBYTE	*FillRectClassName;
    extern UBYTE	*FrameIClassName;
    extern UBYTE	*ITextIClassName;
    extern UBYTE	*GadgetClassName;

    DMEM( printf("commonBSR enter glist %lx, itext %lx\n", glist, itext) );

    reqBox.Left = refscreen->WBorLeft;
    reqBox.Top =  refscreen->WBorTop + refscreen->Font->ta_YSize + 1;

    /*** allocate Image-carrying gadget and SysReqTrack	***/
    if ( !( image_gad=(struct Gadget *)AllocRemember( remkey,
	sizeof *srt + sizeof *image_gad, MEMF_CLEAR ) ) )
    {
	DMEM( printf("cBSR no requester\n") );
	goto BAILOUT;
    }
    image_gad->Flags = ( GFLG_GADGIMAGE | GFLG_GADGHNONE );

    srt = (struct SysReqTrack *) &image_gad[1];
    srt->srt_GadgetFrame = gadgetframe;

    title = (STRPTR) fetchIBase()->SysReqTitle;
    if (rwin)
    {
	title = rwin->Title;
    }
    if (eztitle)
    {
	title = eztitle;
    }

    /*** layout intuitext, if needed, and get their extent	***/
    ITextLayout( &refscreen->RastPort, itext, &framebox, layout_body,
	AUTOTOPEDGE, AUTOLEFTEDGE );

    drinfo = GetScreenDrawInfo( refscreen );

    /* calc a few resolution sensitive quantities	*/
    vspace = VSPACETICKS / drinfo->dri_Resolution.Y;
    hspace = HSPACETICKS / drinfo->dri_Resolution.X;
    hgadspace = HGADSPACETICKS / drinfo->dri_Resolution.X;

    /*** create an IText image object, and a frame for text	***/
    itextimage = (struct Image *) NewObject( NULL, ITextIClassName,
			IA_DATA, 	itext,
			IA_FGPEN,	drinfo->dri_Pens[ TEXTPEN ],
			IA_WIDTH,	framebox.Width + 2 * framebox.Left,
			IA_HEIGHT,	framebox.Height + 2 * framebox.Top,
			TAG_END );
    addGadImage( image_gad, itextimage );

    textframe = (struct Image *) NewObject( NULL, FrameIClassName,
			IA_RECESSED,	TRUE,
			TAG_END );
    addGadImage( image_gad, textframe );

    if ( ! ( itextimage && textframe ) ) 
    {
	DMEM( printf("no text image/frame\n"));
	goto BAILOUT;
    }

    /*** layout scheme revolves around the 'textframe' width ***/
    /* get nominal frame dimensions	*/
    SendMessage(  textframe, IM_FRAMEBOX,
	    &itextimage->LeftEdge, &framebox, drinfo, 0 );

    /* get nominal gadget dimensions	*/
    /* ZZZ: if we want to make gadgets vertical, do
     * it using this function.
     */
    gadcount = glistExtentBox( glist, &gadgetbox, hgadspace );

    /* textframe width adds a little space beside text,
     * and is as large as gadgets and requester window title
     */
    framebox.Width = imax( gadgetbox.Width,
	framebox.Width + 2 * ( HTEXTMARGINTICKS / drinfo->dri_Resolution.X ) );

    /* Make framebox as wide as needed for the title, but don't let the
     * title make it wider than the screen.
     * (24 and 18 are the hires/lores widths of the depth gadget)
     */
    framebox.Width = imax( framebox.Width,
	imin( ( (IsHires( refscreen )? 24: 18) +
	    reqTitleLength( &refscreen->RastPort, title ) ),
	    refscreen->Width - ( refscreen->WBorLeft + refscreen->WBorRight +
	    2*hspace )
	    ) );

    /* don't change gadgetbox.Width yet: needed in spreadG */

    framebox.Left = gadgetbox.Left = hspace + reqBox.Left;
    framebox.Top = vspace + reqBox.Top;
    gadgetbox.Top = boxBottom( &framebox ) + vspace;

    /* Peter 24-Jan-91: To ensure that the buttons fit on-screen,
     * we enforce the following relationship:
     */
     gadgetbox.Top = imin(gadgetbox.Top, refscreen->Height -
	(gadgetbox.Height + vspace ) );

    /*** position real gadgets	***/
    spreadLayoutGadgets( glist, gadcount, &gadgetbox,
	framebox.Width, hgadspace);

    /*** position frame and intuitext object	***/
    SetAttrs( textframe, 
		IA_LEFT, framebox.Left,
		IA_TOP,  framebox.Top,
		IA_WIDTH, framebox.Width,
		IA_HEIGHT, framebox.Height,
		TAG_END );

    /* get centered position of contents, relative to frame dimensions */
    SendMessage(  textframe, IM_FRAMEBOX,
	    &itextimage->LeftEdge, &framebox, drinfo, FRAMEF_SPECIFY );

    /* now, framebox has in left/top the offsets from the contents
     * origin (0,0) to the frame position.  We push the contents back
     * so that the frame position of framebox.Left/Top holds 
     */
    SetAttrs( itextimage, 
		IA_LEFT, textframe->LeftEdge - framebox.Left,
		IA_TOP, textframe->TopEdge - framebox.Top,
		TAG_END );

    /*** calculate requester box	***/
    reqBox.Width = boxRight( &textframe->LeftEdge ) - reqBox.Left + hspace + 1;
    reqBox.Height = boxBottom( &gadgetbox ) - reqBox.Top + vspace + 1;

    /* toss in the dithered rectfill background	*/
    /* re-using 'textframe' here 		*/
    textframe = NewObject( NULL, FillRectClassName,
			IA_FGPEN,	drinfo->dri_Pens[ SHINEPEN ],
			IA_LEFT,	reqBox.Left,
			IA_TOP,		reqBox.Top,
			IA_WIDTH,	reqBox.Width,
			IA_HEIGHT,	reqBox.Height,
			IA_APATTERN,	ezreqPattern,
			IA_APATSIZE,	ezreqPatSize,
			IA_MODE,	JAM2,
    
			TAG_END );
    /* It's OK if 'fillrect' object isn't successfully created.
     * addGadImage() safely does nothing if the image is NULL.
     */
    addGadImage( image_gad, textframe );

    /* Put our image gadget at the end of the gadget list */
    {
	struct Gadget *runner;
	for ( runner = glist; runner->NextGadget; runner = runner->NextGadget )
		;
	runner->NextGadget = image_gad;
    }

    /*** open window for requester	***/
    /* ZZZ: debugging test: bail out and see how graceful */
    /*** retwindow = NULL; goto BAILOUT;	***/

#if 	0	/* bailout test	*/
    if ( retwindow = NULL )	/* always fail	*/
#else
    if ( retwindow = reqWindow( rwin, refscreen, title, glist,
	reqBox.Width, reqBox.Height, iflags) )
#endif
    {

	/* OK, got window, return everything back to caller */
	srt->srt_Remember = *remkey;
	srt->srt_ReqGadgets = glist;
	srt->srt_ImageGad = image_gad;
	retwindow->UserData = (BYTE *)srt;	/* track resource */
	FreeScreenDrawInfo( refscreen, drinfo );
	DMEM( printf("return OK\n"));
	return ( retwindow );
    }
    DMEM( printf("cBSR no reqWindow\n" ) );

BAILOUT:
    DMEM( printf("commonBSR BAILOUT!!!\n"));
    /* abort: should be going to an alert here	*/
    FreeScreenDrawInfo( refscreen, drinfo );

    /* free all memory I allocated which is NOT covered
     * by FreeRemember, which my caller will be freeing.
     */
    if ( image_gad )
    {
	DMEM( printf("disposeImageList now\n"));
	disposeImageList( image_gad->GadgetRender );
    }

    /* 8-Mar-91:  If I'm a process, fail with ERROR_NO_FREE_STORE */
    processFail( TRUE );

    return ( NULL );
}

/*
 * looks like we need to tear off trailing spaces
 */
reqTitleLength( rp, title )
struct RastPort	*rp;
UBYTE		*title;
{
    int	len;
    UBYTE	*tail;

    if ( !title )
    {
	return( 0 );
    }

    len = strlen( title );

    tail = title + (len - 1);	/* point to last valid char	*/
    while ( tail > title && *tail == ' ' )
    {
	tail--;
    }

    return ( TextLength( rp, title, tail - title + 1 ) );
}

/* adds image to front of image list,
 * which means its visuals are IN BACK of other elements
 * already in list (since it's drawn first).
 */
addGadImage( gad, im )
struct Gadget	*gad;
struct Image	*im;
{
    if ( im )
    {
	im->NextImage = gad->GadgetRender;
	gad->GadgetRender = im;
    }
}


disposeGadgetList( g )
struct Gadget	*g;
{
    struct Gadget	*succ_g;
    for ( ; g; g = succ_g )
    {
	succ_g =  g->NextGadget;

	if ( (g->GadgetType & GTYPEMASK) == CUSTOMGADGET )
	{
	    DisposeObject( g );
	}
    }
}

disposeImageList( im )
struct Image	*im;
{
    struct Image	*succ_im;

    for ( ; im; im = succ_im )
    {
	DFSR( printf("im %lx, succ %lx\n", im, im->NextImage ) );
	succ_im =  im->NextImage;
	DisposeObject( im );
    }
}

struct Window	*
reqWindow( rwin, screen, title, glist, reqWidth, reqHeight, iflags )
struct Window	*rwin;
struct Screen	*screen;
UBYTE		*title;
struct Gadget 	*glist;
WORD		reqWidth;
WORD		reqHeight;
ULONG		iflags;
{
    struct IntuitionBase	*IBase = fetchIBase();
    struct Window	*w;
    struct Screen	*reqscreen;
    struct Window	*openWindowOnlyTags();
    ULONG		screentag;

    DMEM( printf("enter reqWindow\n"));

    /* By default, we're going onto a public screen */
    screentag = WA_PubScreen;

    if (rwin)	/* override Title and Type */
    {
	screentag = WA_CustomScreen;
    }

    /* Peter 2-Dec-90: Limit testing on window size will be done
     * through WA_AutoAdjust, which is on by default since we're
     * not supplying a NewWindow structure.
     *
     * WA_AutoAdjust also means that we no longer have to supply
     * values for WA_Left and WA_Top to ensure that I appear on the
     * visible part of a scrolled oversize screen.
     */

    if ( w = openWindowOnlyTags(
	WA_Flags, ( WFLG_ACTIVATE | WFLG_SIMPLE_REFRESH | WFLG_DRAGBAR |
	            WFLG_DEPTHGADGET | WFLG_NOCAREREFRESH | WFLG_RMBTRAP ),
	WA_Left, imax( 0, -screen->LeftEdge ),
	WA_Top, imax( 0, -screen->TopEdge ),
	WA_InnerWidth, reqWidth,
	WA_InnerHeight, reqHeight,

	WA_IDCMP, iflags | REQIFLAGS,
	screentag, screen,
	WA_Title, title,
	WA_Gadgets, glist,
	TAG_DONE ) )
    {
	DMEM( printf("rW: window open %lx\n", w ) );

	/* EasyRequests are automatically in the same HelpGroup
	 * as the reference window.
	 */
	if ( rwin )
	{
	    XWINDOW(w)->HelpGroup = XWINDOW(rwin)->HelpGroup;
	}

	/**** POP screen front ***/
	if ( (reqscreen = w->WScreen) != IBase->FirstScreen )
	{
	    /* IScreenDepth() will clear poppedscreen,
	     * so do it synchronously
	     */
	    ScreenDepth( reqscreen, SDEPTH_TOFRONT, NULL );
	    SETFLAG( IBase->Flags, POPPEDSCREEN );
	}
    }

OUT:

    DMEM( printf("rW to return %lx\n", w ));
    return ( w );
}

/*** intuition.library/FreeSysRequest ***/

FreeSysRequest(window)
struct Window *window;
{
    struct Screen	*reqscreen;
    struct SysReqTrack	*srt;

    DFSR( printf("FSR\n") );

    if ( window == NULL || (ULONG) window == 1 ) return;

    /* catch a pointer to my gadgets before I end the requester */
    srt = (struct SysReqTrack *)window->UserData;

    reqscreen = window->WScreen;

    /* close the requestwindow */
    CloseWindow(window);

    /*** POP screen back ***/
    if ( TESTFLAG( fetchIBase()->Flags, POPPEDSCREEN ) )
    {
	DAR( printf("pop screen back\n") );
	/* Peter 7-Jan-91:  We must depth-arrange the screen
	 * synchronously since the caller might call CloseScreen()
	 * too soon after, if I used sendISMNoQuick instead.
	 */
	ScreenDepth( reqscreen, SDEPTH_TOBACK, NULL );

	/* POPPEDSCREEN cleared inside IDepthScreen */
    }

    disposeGadgetList( srt->srt_ReqGadgets );
    disposeImageList( srt->srt_ImageGad->GadgetRender );

    /* free the things I've tracked; do FreeRemember() LAST, since
     * it free's the SysReqTrack
     */
    DFSR( printf("dispose gadget frame %lx\n", srt->srt_GadgetFrame) );

    DisposeObject( srt->srt_GadgetFrame );

    DFSR( printf("FreeRemember %lx\n", &srt->srt_Remember, TRUE) );

    FreeRemember( &srt->srt_Remember, TRUE );
}

/* Peter 8-Mar-91: DOS needs to be able to sense the difference between
 * ...Request() returning a result of zero because the user selected
 * "Cancel", and a result of zero owing to out-of-memory.  The problem
 * being addressed is that if EasyRequest() fails for lack of memory
 * on a "Software Failure" requester, DOS will believe that the user
 * selected "Reboot".
 */

processFail( fail )
BOOL fail;
{
    struct Task *FindTask();

    struct Process *myself = (struct Process *)FindTask( NULL );

    if ( myself->pr_Task.tc_Node.ln_Type == NT_PROCESS )
    {
	myself->pr_Result2 = ( fail ) ? ERROR_NO_FREE_STORE : 0;
    }
}
@


38.14
log
@EasyRequests on oversized screens once again open on the visible portion.
@
text
@d5 1
a5 1
 *  $Id: ezreq.c,v 38.13 92/06/03 17:24:28 peter Exp Locker: peter $
d478 3
a480 3
    vspace = vResDivide( drinfo, VSPACETICKS );
    hspace = hResDivide( drinfo, HSPACETICKS );
    hgadspace = hResDivide( drinfo, HGADSPACETICKS );
d517 1
a517 1
	framebox.Width + 2* hResDivide( drinfo, HTEXTMARGINTICKS ) );
@


38.13
log
@EasyRequests are automatically in the same HelpGroup as the reference
window.
@
text
@d5 1
a5 1
 *  $Id: ezreq.c,v 38.12 92/05/01 13:51:47 peter Exp Locker: peter $
d748 2
a749 2

	WA_Top, 0,
@


38.12
log
@EasyRequest windows are now RMBTrap.  EZReq screen popping now goes
through ScreenDepth() function.
@
text
@d5 1
a5 1
 *  $Id: ezreq.c,v 38.11 92/04/07 17:48:23 peter Exp Locker: peter $
d760 8
@


38.11
log
@Removed unused vble.
@
text
@d5 1
a5 1
 *  $Id: ezreq.c,v 38.10 92/04/01 15:04:24 peter Exp Locker: peter $
d747 1
a747 1
	            WFLG_DEPTHGADGET | WFLG_NOCAREREFRESH ),
d767 1
a767 1
	    doISM( itDEPTHSCREEN, reqscreen, NULL, SDEPTH_TOFRONT );
d806 1
a806 1
	doISM( itDEPTHSCREEN, reqscreen, NULL, SDEPTH_TOBACK );
@


38.10
log
@Evicted autodocs.
@
text
@d5 1
a5 1
 *  $Id: ezreq.c,v 38.9 92/03/26 16:26:09 peter Exp Locker: peter $
a77 1
    struct IntuitionBase	*IBase = fetchIBase();
a316 1
    struct IntuiText	*gtext;
d450 1
a450 1
    if ( !( image_gad=(struct Requester *)AllocRemember( remkey,
d461 1
a461 1
    title = fetchIBase()->SysReqTitle;
d483 1
a483 1
    itextimage = NewObject( NULL, ITextIClassName,
d491 1
a491 1
    textframe = NewObject( NULL, FrameIClassName,
d613 1
a613 1
	retwindow->UserData = srt;	/* track resource */
@


38.9
log
@Optimized to take advantage of the fact that WA_AutoAdjust ensures the
window is on the visible part of the display.  Now use modern names
for DrawInfo pens.
@
text
@d5 1
a5 1
 *  $Id: ezreq.c,v 38.8 92/03/18 11:48:15 peter Exp Locker: peter $
d29 1
a30 171
/****** intuition.library/EasyRequestArgs *****************************
*
*    NAME
*	EasyRequestArgs -- Easy alternative to AutoRequest(). (V36)
*	EasyRequest -- Varargs stub for EasyRequestArgs(). (V36)
*
*    SYNOPSIS
*	num = EasyRequestArgs( Window, easyStruct, IDCMP_ptr, ArgList )
*	D0                     A0      A1          A2         A3
*
*	LONG EasyRequestArgs( struct Window *, struct EasyStruct *,
*		ULONG *, APTR );
*
*	num = EasyRequest( Window, easyStruct, IDCMP_ptr, Arg1, Arg2, ... )
*
*	LONG EasyRequest( struct Window *, struct EasyStruct *,
*		ULONG *, APTR, ... );
*
*	( from intuition.h )
*	struct EasyStruct {
*	    ULONG	es_StructSize;
*	    ULONG	es_Flags;
*	    UBYTE	*es_Title;
*	    UBYTE	*es_TextFormat;
*	    UBYTE	*es_GadgetFormat;
*	};
*
*    FUNCTION
*	This function provides a simpler method of using a 'System
*	Requester' than provided by AutoRequest().  It performs layout
*	and size calculations sensitive to the current font and screen
*	resolution.
*
*	It provides for the descriptive 'body' text and the gadget
*	text to be constructed from 'printf' style format strings.
*
*	It also provides a general way for the requester to be
*	sensitive to particular IDCMP messages.
*	
*	The first function listed is the actual Intuition library
*	function.  It is passed the arguments for the formatting
*	operations as a pointer to the first argument.
*
*	The second function uses a C-style variable number of argument
*	(varargs) calling convention.  It should be implemented as
*	a call to the first function, and might be supplied by your
*	compiler vendor, in amiga.lib, or using the first example below,
*	for most C compilers.
*
*	NOTE: The formatting is done by exec.library/RawDoFmt(), so
*	be aware that to display a 32-bit integer argument, for
*	example, you must say "%ld", not "%d", since RawDoFmt() is
*	"word-oriented."
*
*	NOTE: This function switches the processor stack to ensure
*	sufficient stack space for the function to complete.
*
*    EXAMPLES
*	\* varargs interface works for most C compilers *\
*	EasyRequest( w, es, ip, arg1 )
*	struct Window	*w;
*	struct EasyStruct *es;
*	ULONG		  *ip;
*	int		  arg1;
*	{
*	    return ( EasyRequestArgs( w, es, ip, &arg1 ) );
*	}
*
*	\*********************************************\
*
*	\* typical use *\
*	struct EasyStruct volumeES = {
*	    sizeof (struct EasyStruct),
*	    0,
*	    "Volume Request",
*	    "Please insert volume %s in any drive.",
*	    "Retry|Cancel",
*	};
*	#define CANCEL	(0)
*
*	Volume	*
*	getVolume( volname )
*	UBYTE	*volname;
*	{
*	    Volume	*vptr;
*	    Volume	*findVolume();
*	    UWORD	reply;
*	    ULONG	iflags;
*
*	    iflags = IDCMP_DISKINSERTED;
*
*	while ( ((vptr = findVolume( volname )) == NULL) &&
*	 (EasyRequest( w, &volumeES, &iflags, volname ) != CANCEL) )
*		\* loop *\ ;
*
*	    \* note that in some circumstances, you will have to
*	       re-initialize the value of 'iflags'.  Here, it
*	       is either unchanged, or returned as the single
*	       IDCMPFlag value IDCMP_DISKINSERTED.  If you combine
*	       multiple  IDCMPFlag values in 'iflags,' only
*	       one will be returned, so you must reinitialize
*	       'iflags' to be the combination.
*	      *\
*	    return ( vptr );
*	}
*
*    INPUTS
*	Window = Reference window pointer, determines the screen and
*	    title of the requester window.  This can be NULL, which
*	    means the requester is to appear on the Workbench screen,
*	    or default public screen, if defined.
*	IDCMP_ptr = Pointer to IDCMP flags that you want to terminate
*		the requester.  This pointer may be NULL.
*	easyStruct = Pointer to EasyStruct structure with fields
*		interpreted as follows:
*
*	es_StructSize = sizeof (struct EasyStruct), for future extension.
*	es_Flags = 0 for now, in the future may specify other options.
*	es_Title = Title of system requester window.  If this is NULL,
*	    the title will be taken to be the same as the title of 'Window',
*	    if provided, or else "System Request."
*	es_TextFormat = Format string, a la RawDoFmt(), for message in
*	    requester body.  Lines are separated by '\n'.  Formatting
*	    '%' functions are supported exactly as in RawDoFmt().
*	es_GadgetFormat = Format string for gadgets.  Text for separate 
*	    gadgets is separated by '|'.  Format functions are supported.
*	    You MUST specify at least one gadget.
*
*	Args = Arguments for format commands.   Arguments for
*	    GadFmt follow arguments for TextFmt.
*
*    RESULT
*	0, 1, ..., N = Successive GadgetID values, for the gadgets
*	    you specify for the requester.  NOTE: The numbering
*	    from left to right is actually: 1, 2, ..., N, 0.
*	    This is for compatibility with AutoRequests which has
*	    FALSE for the rightmost gadget.
*	    
*	-1 = Means that one of the caller-supplied IDCMPFlags occurred.
*	    The IDCMPFlag value is in the longword pointed to by IDCMP_ptr.
*
*    NOTES
*	When DOS brings up EasyRequests() on your process (eg.
*	"Please insert volume XXX in any drive", they normally come
*	up on the default public screen, which is usually the Workbench
*	screen.  If you set your Process pr_WindowPtr field to point to
*	one of your windows, then DOS will bring its requesters up on the
*	same screen as that window.  A pr_WindowPtr of -1 prevents
*	requesters from coming up at all.
*	(Some FileSystem requesters cannot be redirected or supressed).
*
*    BUGS
*	Does not fall back to a recoverable alert if the requester
*	 cannot be created.
*
*	Does not handle case when gadgets don't fit or window title
*	is too long, although it does trim trailing spaces from the
*	title for calculating dimensions.
*
*    PLANS
*	Possible enhancements include: centering of text, size-sensitive
*	layout,  window-relative requester, vertical gadget layout,
*	window placement, more keyboard shortcuts.
*
*	We also reserve the use of the newline character '\n' in
*	gadget format strings for future use as a line separator.
*
*    SEE ALSO
*	exec.library/RawDoFmt(), BuildEasyRequestArgs(), SysReqHandler(), 
*	AutoRequest(), BuildSysRequest()
*****************************************************************************/
d61 1
a62 103
/****** intuition.library/AutoRequest ******************************************
*
*    NAME
*	AutoRequest -- Automatically build and get response from a requester.
*
*    SYNOPSIS
*	Response = AutoRequest( Window, BodyText, PosText, NegText, 
*	D0                      A0      A1        A2       A3
*			PosFlags, NegFlags, Width, Height )
*			D0        D1        D2     D3
*
*	BOOL AutoRequest( struct Window *, struct IntuiText *,
*		struct IntuiText *, struct IntuiText *, 
*		ULONG, ULONG, WORD, WORD );
*
*    FUNCTION
*	This procedure automatically builds a requester for you and then 
*	waits for a response from the user, or for the system to satisfy your 
*	request.  If the response is positive, this procedure returns TRUE.  
*	If the response is negative, this procedure returns FALSE.  
*
*	An IDCMPFlag specification is created by bitwise "or'ing" your
*	PosFlags, NegFlags, and the IDCMP classes IDCMP_GADGETUP and
*	IDCMP_RAWKEY.  You may specify zero flags for either the PosFlags
*	or NegFlags arguments.  
*
*	The IntuiText arguments, and the width and height values, are 
*	passed directly to the BuildSysRequest() procedure along with 
*	your window pointer and the IDCMP flags.  Please refer to 
*	BuildSysRequest() for a description of the IntuiText that you are 
*	expected to supply when calling this routine.  It's an important
*	but long-winded description that need not be duplicated here.  
*
*	If the BuildSysRequest() procedure does not return a pointer 
*	to a window, it will return TRUE or FALSE (not valid structure 
*	pointers) instead, and these BOOL values will be returned to 
*	you immediately.  
*
*	On the other hand, if a valid window pointer is returned, that 
*	window will have had its IDCMP ports and flags initialized according 
*	to your specifications.  AutoRequest() then waits for IDCMP messages 
*	on the UserPort, which satisfies one of four requirements:
*	-   either the message is of a class that matches 
*	    one of your PosFlags arguments (if you've supplied 
*	    any), in which case this routine returns TRUE.  Or
*	-   the message class matches one of your NegFlags 
*	    arguments (if you've supplied any), in which case 
*	    this routine returns FALSE.  Or
*	-   the IDCMP message is of class IDCMP_GADGETUP, which means that
*	    one of the two gadgets, as provided with the PosText and NegText 
*	    arguments, was selected by the user.  If the TRUE gadget 
*	    was selected, TRUE is returned.  If the FALSE gadget was 
*	    selected, FALSE is returned.  
*	-   Lastly, two IDCMP_RAWKEY messages may satisfy the request: those
*	    for the V and B keys with the left Amiga key depressed.
*	    These keys, satisfy the gadgets on the left or right side of
*	    the requester--TRUE or FALSE--, respectively.
*
*	    NOTE: For V36, these two keys left-Amiga-B and V are processed
*	    through the default keymap.
*
*	When the dust has settled, this routine calls FreeSysRequest() if
*	necessary to clean up the requester and any other allocated memory.
*
*	NOTE: For V36, this function now switches the processor stack
*	to ensure sufficient stack space for the function to succeed.
*
*    INPUTS
*	Window = pointer to a Window structure.  See BuildSysRequest()
*	    for a full discussion.
*	BodyText = pointer to an IntuiText structure
*	PosText = pointer to an IntuiText structure, may by NULL.
*	NegText = pointer to an IntuiText structure, MUST be valid!
*	PosFlags = flags for the IDCMP
*	NegFlags = flags for the IDCMP
*	Width, Height = the sizes to be used for the rendering of the requester 
*
*	NOTE for V36: The width and height parameters are ignored, as
*	are several other specifications in the IntuiText, to make
*	AutoRequest() requesters retroactively conform to the new look
*	designed for EasyRequest().
*
*    RESULT
*	The return value is either TRUE or FALSE.  See the text above for a 
*	complete description of the chain of events that might lead to either
*	of these values being returned.
*
*    NOTES
*	When DOS brings up AutoRequests() on your process (eg.
*	"Please insert volume XXX in any drive", they normally come
*	up on the Workbench screen.  If you set your Process pr_WindowPtr
*	field to point to one of your windows, then DOS will bring its
*	requesters up on the same screen as that window.  A pr_WindowPtr
*	of -1 prevents requesters from coming up at all.
*	(Some FileSystem requesters cannot be redirected or supressed).
*
*    BUGS
*	The requester no longer devolves into a call to DisplayAlert()
*	if there is not enough memory for the requester.
*
*    SEE ALSO
*	EasyRequest(), BuildSysRequest(), SysReqHandler()
*****************************************************************************/
d118 1
a119 130
/****** intuition.library/SysReqHandler *************************************
*
*    NAME
*	SysReqHandler -- Handle system requester input. (V36)
*
*    SYNOPSIS
*	num = SysReqHandler( Window, IDCMPFlagsPtr, WaitInput )
*	D0                   A0      A1             D0
*
*	LONG SysReqHandler( struct Window *, ULONG *, BOOL );
*
*    FUNCTION
*	Handles input for a window returned by either BuildSysRequest()
*	or BuildEasyRequest().  These functions with SysReqHandler()
*	you can perform an "asynchronous" EasyRequest() or AutoRequest().
*	That is to say, you can perform other processing while you
*	wait for the requester to be satisfied.
*
*	Each time this function is called, it will process all
*	IDCMPMessages that the window has received.  If the parameter
*	'WaitInput' is non-zero, SysReqHandler() will wait for input
*	(by calling WaitPort()) if there are no IDCMP messages.
*
*	SysReqHandler() returns the same values as EasyRequest(): A gadget
*	ID greater than equal to 0, and  -1 if one of the other IDCMP
*	events were received.
*
*	An additional value of -2 is returned if the input processed
*	does not satisfy the requester.  In this case, you might
*	perform some processing and call SysReqHandler() again.
*
*	Note: this function does NOT terminate the system request.
*	Not only must you call FreeSysRequest() to eliminate the request,
*	but you may also continue processing after an event which would
*	normally terminate a normal call to EasyRequest().
*
*    EXAMPLE
*	Implementation of EasyRequest() input loop:
*
*	window = BuildEasyRequest( ZZZZ )
*	while ( (retval = SysReqHandler( window, idcmp_ptr, TRUE )) == -2 )
*	{
*	    \* loop	*\;
*	}
*	FreeSysRequest( window );
*
*    EXAMPLE
*	Request a volume, but don't remove the requester when the
*	user inserts the wrong disk:
*
*	struct EasyStruct volumeES = {
*	    sizeof (struct EasyStruct),
*	    0,
*	    "Volume Request",
*	    "Please insert volume %s in any drive.",
*	    "Cancel"
*	};
*
*	Volume *
*	getVolume( volname )
*	UBYTE	*volname;
*	{
*	    struct Window	*window;
*	    Volume		*volume = NULL;
*	    Volume		*findVolume();
*	    int			retval;
*
*	    window = BuildEasyRequest( NULL, &volumeES, IDCMP_DISKINSERTED,
*	    	      volname );
*
*	    while ( (retval = SysReqHandler( window, NULL, TRUE )) != 0 )
*	    {
*	    	\* not cancelled yet	*\
*
*	    	\* when IDCMP_DISKINSERTED, check for volume *\
*	    	if (( retval == -1 ) && (volume = findVolume( volname )))
*		    break;
*	    }
*	    FreeSysRequest( window );
*	    return ( volume );
*	}
*
*    INPUTS
*	Window = Window pointer returned from BuildSysRequest() or
*		BuildEasyRequest().  Those functions can also return
*		values '0' or '1', and these values may also be
*		passed to SysReqHandler(), which will immediately
*		return the same value.
*
*	IDCMPFlagsPtr = If you passed application specific IDCMP
*		flags to BuildSysRequest() or BuildEasyRequest(),
*		SysReqHandler() will return -1 if that IDCMP message
*		is received.  If IDCMPFlagsPtr is non-null, it
*		points to a ULONG where the IDCMP class received
*		will be copied for your examination.
*
*		This pointer can be NULL if you have provided no
*		application specific IDCMP flags or if you do
*		not need to know which application specific IDCMP 
*		event occurred.
*
*		If you provide more than on flag in the flags variable
*		this pointer points to, you will have to refresh
*		the variable whenever -1 is returned, since the
*		variable will have been changed to show just the
*		single IDCMP Class bit that caused the return.
*
*	WaitInput = Specifies that you want SysReqHandler() to
*	        to wait for IDCMP input if there is none pending.
*
*    RESULT
*	0, 1, ..., N = Successive GadgetID values, for the gadgets
*	    you specify for the requester.  NOTE: The numbering
*	    from left to right is actually: 1, 2, ..., N, 0.
*	    This is for compatibility with AutoRequests which has
*	    FALSE for the rightmost gadget.
*	    
*	-1 = Means that one of the caller-supplied IDCMPFlags occurred.
*	    The IDCMPFlag value is in the longword pointed to by UDCMP_ptr.
*
*	-2 = input processed did not satisfy the requester. One example
*	    is a keystroke that does not satisfy the requester.  Another
*	    example is if there is no input pending and you specified
*	    FALSE for WaitInput.
*
*    BUGS
*
*    SEE ALSO
*	exec.library/WaitPort()
*****************************************************************************/
d182 1
a183 65
/****** intuition.library/BuildEasyRequestArgs ****************************
*
*    NAME
*	BuildEasyRequestArgs -- Simple creation of system request. (V36)
*	BuildEasyRequest -- Varargs stub for BuildEasyRequestArgs(). (V36)
*
*    SYNOPSIS
*	ReqWindow = BuildEasyRequestArgs( RefWindow, easyStruct, IDCMP, Args )
*	D0                                A0         A1          D0     A3
*
*	struct Window *BuildEasyRequestArgs( struct Window *,
*		struct EasyStruct *, ULONG, APTR );
*
*	ReqWindow = BuildEasyRequest( RefWindow, easyStruct, IDCMP, Arg1, ... )
*
*	struct Window *BuildEasyRequest( struct Window *,
*		struct EasyStruct *, ULONG, APTR, ... );
*
*    FUNCTION
*	This function is to EasyRequest() as BuildSysRequest() is to
*	AutoRequest(): it returns a pointer to the system requester
*	window.  The input from that window can then be processed
*	under application control.
*
*	It is recommended that this processing be done with
*	SysReqHandler(), so that future enhancement to the
*	processing will be enjoyed.
*
*	After you have determined that the requester is satisfied or
*	cancelled, you must free this requester using FreeSysRequest().
*
*	Please see the autodoc for EasyRequest().
*
*	NOTE: This function switches the processor stack to ensure
*	sufficient stack space for the function to complete.
*
*    INPUTS
*	Window = reference window for requester: determines the
*	    requester window title and screen.
*	easyStruct = pointer to EasyStruct structure, as described
*	    in the EasyRequest() autodocs.
*	IDCMP = (NOT A POINTER) provided application specific IDCMP
*	    flags for the system requester window.
*	Args = see EasyRequest()
*
*    RESULT
*	A pointer to the system request window opened.  In the event
*	of problems, you may also be returned the value '0' which
*	is to be interpreted as the "FALSE, Cancel" choice, or
*	(if you have a second gadget defined) the value '1', which
*	is to be taken to mean the equivalent of your corresponding
*	left-most gadget.
*
*	If there is a problem creating the window, a recoverable alert may
*	be substituted for the requester, and the result, either 0 or 1,
*	returned.
*
*    BUGS
*	Does not put up alternative alert.
*	See also BUGS listed for EasyRequestArgs().
*
*    SEE ALSO
*	EasyRequestArgs(), FreeSysRequest(), SysReqHandler(), 
*	BuildSysRequest(), AutoRequest()
*****************************************************************************/
d304 1
a305 164
/****** intuition.library/BuildSysRequest ************************************
*
*    NAME
*	BuildSysRequest -- Build and display a system requester.
*
*    SYNOPSIS
*	ReqWindow = BuildSysRequest( Window, BodyText, PosText, NegText, 
*	D0                           A0      A1        A2       A3
*		           IDCMPFlags, Width, Height )
*			   D0          D1     D2
*
*	struct Window *BuildSysRequest( struct Window *, struct IntuiText *,
*		struct IntuiText *, struct IntuiText *, ULONG, WORD, WORD );
*
*    FUNCTION
*	This procedure builds a system requester based on the supplied
*	information.  If all goes well and the requester is constructed,
*	this procedure returns a pointer to the window in which the requester
*	appears.  That window will have its IDCMP initialized to reflect the
*	flags found in the IDCMPFlags argument.  You may then wait on those
*	ports to detect the user's response to your requester, which response
*	may include either selecting one of the gadgets or causing some other
*	event to be noticed by Intuition (like IDCMP_DISKINSERTED, for
*	instance).  After the requester is satisfied, you should call the
*	FreeSysRequest() procedure to remove the requester and free up
*	any allocated memory.
*
*	See the autodoc for SysReqHandler() for more information on the
*	how to handle the IntuiMessages this window will receive.
*
*	The requester used by this function has the NOISYREQ flag bit set,
*	which means that the set of IDCMPFlags that may be used here
*	include IDCMP_RAWKEY, IDCMP_MOUSEBUTTONS, and others.
*   
*	In release previous to V36, if the requester could not be built,
*	this function would try to call DisplayAlert() with the same
*	information, with more or less favorable results.  In V36,
*	the requesters themselves require less memory (SIMPLEREQ), but
*	there is no alert attempt.
*
*	The function may return TRUE (1) or FALSE if it cannot post
*	the requester.  (V36 will always return FALSE, but be sure to
*	test for TRUE in case somebody reinstates the fallback alert.)
*
*	If the window argument you supply is equal to NULL, a new window will
*	be created for you in the Workbench screen, or the default
*	public screen, for V36.  If you want the requester
*	created by this routine to be bound to a particular window (i.e.,
*	to appear in the same screen as the window), you should
*	not supply a window argument of NULL.
*
*	New for V36: if you pass a NULL window pointer, the system requester
*	will appear on the default public screen, which is not always
*	the Workbench.
*
*	The text arguments are used to construct the display.  Each is a
*	pointer to an instance of the structure IntuiText.
*
*	The BodyText argument should be used to describe the nature of 
*	the requester.  As usual with IntuiText data, you may link several
*	lines of text together, and the text may be placed in various 
*	locations in the requester.  This IntuiText pointer will be stored
*	in the ReqText variable of the new requester.
*
*	The PosText argument describes the text that you want associated 
*	with the user choice of "Yes,  TRUE,  Retry,  Good."  If the requester 
*	is successfully opened, this text will be rendered in a gadget in 
*	the lower-left of the requester, which gadget will have the 
*	GadgetID field set to TRUE.  If the requester cannot be opened and 
*	the DisplayAlert() mechanism is used, this text will be rendered in 
*	the lower-left corner of the alert display with additional text 
*	specifying that the left mouse button will select this choice.  This 
*	pointer can be set to NULL, which specifies that there is no TRUE 
*	choice that can be made.
*
*	The NegText argument describes the text that you want associated 
*	with the user choice of "No,  FALSE,  Cancel,  Bad."  If the requester 
*	is successfully opened, this text will be rendered in a gadget in 
*	the lower-right of the requester, which gadget will have the 
*	GadgetID field set to FALSE.  If the requester cannot be opened and 
*	the DisplayAlert() mechanism is used, this text will be rendered in 
*	the lower-right corner of the alert display with additional text 
*	specifying that the right mouse button will select this choice.  This 
*	pointer cannot be set to NULL.  There must always be a way for the
*	user to cancel this requester.
*
*	The Positive and Negative Gadgets created by this routine have
*	the following features:
*          - GTYP_BOOLGADGET
*          - GACT_RELVERIFY
*          - GTYP_REQGADGET
*          - GACT_TOGGLESELECT
*
*	When defining the text for your gadgets, you may find it convenient
*	to use the special constants used by Intuition for the construction
*	of the gadgets.  These include defines like AUTODRAWMODE, AUTOLEFTEDGE,
*	AUTOTOPEDGE and AUTOFRONTPEN.  You can find these in your local
*	intuition.h (or intuition.i) file.
*
*	These hard-coded constants are not very resolution or font
*	sensitive, but V36 will override them to provide more modern
*	layout.
*
*	New for V36, linked lists of IntuiText are not correctly supported
*	for gadget labels.
*
*	The width and height values describe the size of the requester.  All
*	of your BodyText must fit within the width and height of your
*	requester.  The gadgets will be created to conform to your sizes.
*
*	VERY IMPORTANT NOTE:  for this release of this procedure, a new window
*	is opened in the same screen as the one containing your window. 
*	Future alternatives may be provided as a function distinct from this
*	one.
*
*	NOTE: This function will pop the screen the requester and its
*	window appears in to the front of all screens.  New for V36,
*	if the user doesn't perform any other screen arrangement before
*	finishing with the requester, a popped screen will be pushed
*	back behind.
*
*    INPUTS
*	Window = pointer to a Window structure
*	BodyText = pointer to an IntuiText structure
*	PosText = pointer to an IntuiText structure
*	NegText = pointer to an IntuiText structure
*	IDCMPFlags = the IDCMP flags you want used for the initialization of the
*           IDCMP of the window containing this requester
*	Width, Height = the size required to render your requester
*
*	NOTE for V36: the width and height you pass are ignored, as
*	are some of the parameters of your IntuiText, so that Intuition
*	can make the Requesters real nice for the new look.
*
*    RESULT
*	If the requester was successfully created, the value 
*	returned by this procedure is a pointer to the window in which the 
*	requester is rendered.  If the requester could not be created,
*	this routine might have called DisplayAlert() before returning 
*	(it depends on the version) and will pass back TRUE if the user
*	pressed the left mouse button and FALSE if the user pressed the
*	right mouse button.   If the version of Intuition doesn't 
*	call DisplayAlert(), or if it does, and there's not enough
*	memory for the alert, the value of FALSE is returned.
*
*    BUGS
*	This procedure currently opens a window in the Screen which 
*	contains the window which is passed as a parameter, or the
*	default public screen, if that parameter is NULL.  Although
*	not as originally envisioned, this will probably always be the
*	behavior of this function.
*
*	DisplayAlert() is not called in version V36.
*
*	It's almost impossible to make complete, correct account
*	of different system fonts, window border dimensions, and
*	screen resolution to get the layout of a System Requester
*	just right using this routine.  For V36, we recommend the
*	automatic layout implemented in BuildEasyRequest and EasyRequest.
*
*    SEE ALSO
*	FreeSysRequest(), DisplayAlert(), ModifyIDCMP(), exec.library/Wait(),
*	Request(), AutoRequest(), EasyRequest(), BuildEasyRequestArgs()
*****************************************************************************/
d780 1
a781 37
/****** intuition.library/FreeSysRequest ************************************
*
*    NAME
*	FreeSysRequest -- Free resources gotten by a call to BuildSysRequest().
*
*    SYNOPSIS
*	FreeSysRequest( Window )
*		        A0
*
*	VOID FreeSysRequest( struct Window * );
*
*    FUNCTION
*	This routine frees up all memory allocated by a successful call to
*	the BuildSysRequest() procedure.  If BuildSysRequest() returned a
*	pointer to a window, then you are able to wait on the message port
*	of that window to detect an event which satisfies the requester.
*	When you want to remove the requester, you call this procedure.  It
*	ends the requester and deallocates any memory used in the creation
*	of the requester.  It also closes the special window that was opened
*	for your system requester.
*
*	For V36: It's OK if you pass a NULL or a TRUE (1) value to
*	this function.  Also, this function properly disposes of
*	requesters gotten using BuildEasyRequest().
*
*    INPUTS
*	Window = value of the window pointer returned by a successful call to
*           the BuildSysRequest() procedure
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	BuildSysRequest(), AutoRequest(), CloseWindow()
*****************************************************************************/
@


38.8
log
@Fixed enforcer hit when ref-window has NULL title.  IA_EdgesOnly
defaults to FALSE so need not be spec'd.
@
text
@d5 1
a5 1
 *  $Id: ezreq.c,v 38.7 92/02/21 17:02:42 peter Exp Locker: peter $
d707 2
a708 1
    if ( ! ( frame = NewObject( NULL, FrameIClassName, TAG_END ) ) )
d968 2
a969 1
    if ( ! ( frame = NewObject( NULL, FrameIClassName, TAG_END ) ) )
d1115 1
a1115 1
			IA_FGPEN,	drinfo->dri_Pens[ textPen ],
d1369 3
a1371 3
     */

    /* The values for WA_Left and WA_Top ensure that I appear on the
d1379 1
a1381 3

	WA_Left, imax(0,-screen->LeftEdge),
	WA_Top, imax(0,-screen->TopEdge),
@


38.7
log
@Removed a comment.  Also, ezreq screen popping now affects the whole
screen family.
@
text
@d5 1
a5 1
 *  $Id: ezreq.c,v 38.6 92/02/17 17:11:26 peter Exp Locker: peter $
a1120 1
			IA_EDGESONLY,	FALSE,
d1277 5
@


38.6
log
@Fixed enforcer hit in AutoRequest().
@
text
@d5 1
a5 1
 *  $Id: ezreq.c,v 38.5 92/02/11 13:36:57 peter Exp Locker: peter $
a1389 1
#if 1
d1393 1
a1393 1
	    doISM( itDEPTHSCREEN, reqscreen, NULL, S_TOFRONT );
a1394 4
#else
	    sendISMNoQuick( itDEPTHSCREEN, reqscreen, NULL, S_TOFRONT );
	    SETFLAG( IBase->Flags, POPPEDSCREEN );
#endif
d1468 1
a1468 1
	doISM( itDEPTHSCREEN, reqscreen, NULL, S_TOBACK );
@


38.5
log
@CPattern is now of "size" 1.  Using WA_InnerWidth and WA_InnerHeight
saves space.
EasyRequests are now windows without a requester.
ITextLayout() and glistExtentBox() no longer take a numitext parameter.
@
text
@d5 1
a5 1
 *  $Id: ezreq.c,v 38.4 92/02/05 15:38:14 peter Exp Locker: peter $
d733 1
a733 1
    window =  commonBSR( rwin, screen, ez,
d1036 1
a1036 1
commonBSR( rwin, refscreen, ez, itext, glist, gadgetframe,
d1040 1
a1040 1
struct EasyStruct	*ez;
d1094 1
a1094 1
    if (ez->es_Title)
d1096 1
a1096 1
	title = ez->es_Title;
@


38.4
log
@Optimized to open the window with tags only.  Also, handling of
default requester title made simpler.
@
text
@d5 1
a5 1
 *  $Id: ezreq.c,v 38.3 91/10/17 14:29:06 peter Exp Locker: peter $
d19 1
d570 1
a570 1
		    retval = w->FirstRequest->ReqGadget->GadgetID;
d1021 1
a1021 1
#define ezreqPatSize	(2)
a1052 1
    struct Requester	*req;	/* must be NULL or valid for BAILOUT */
d1064 2
d1070 1
d1074 6
a1079 3
    /*** allocate Requester and SysReqTrack	***/
    if ( !( req=(struct Requester *)AllocRemember(
		remkey, sizeof *req + sizeof *srt, MEMF_CLEAR ) ) )
d1084 3
a1086 7
    /* Easier to use MEMF_CLEAR, and equivalent!
     *
     * InitRequester( req );
     *
     */
    /* set up tracking thing	*/
    srt  = (struct SysReqTrack *) &req[1];
d1100 1
a1100 1
    ITextLayout( &refscreen->RastPort, itext, -1, &framebox, layout_body,
d1117 1
a1117 1
    addReqImage( req, itextimage );
d1123 1
a1123 1
    addReqImage( req, textframe );
d1140 1
a1140 1
    gadcount = glistExtentBox( glist, -1, &gadgetbox, hgadspace );
d1161 2
a1162 2
    framebox.Left = gadgetbox.Left = hspace;
    framebox.Top = vspace;
d1165 1
a1165 1
    /* ZZZ Peter 24-Jan-91: To ensure that the buttons fit on-screen,
d1169 1
a1169 2
         (refscreen->WBorTop + refscreen->Font->ta_YSize + 1 +
         gadgetbox.Height + vspace ) );
a1170 1

a1195 7
#if 0 /* Already zero from InitRequester(). req is also NOREQBACKFILL */
    req->ReqText =	NULL;	/* was itext	*/
    req->ReqBorder =	NULL;
    req->BackFill =	SYSREQBACKFILL;
    req->LeftEdge = req->TopEdge =  0;
#endif

d1197 2
a1198 2
    req->Width = boxRight( &textframe->LeftEdge ) + hspace + 1;
    req->Height = boxBottom( &gadgetbox ) + vspace + 1;
a1199 6
    /*** initialize requester		***/
    /* req->ReqImage taken care of as images created */
    req->ReqGadget =	glist;
    req->Flags |=	NOISYREQ | SIMPLEREQ | USEREQIMAGE | NOREQBACKFILL;


d1204 4
a1207 2
			IA_WIDTH,	req->Width,
			IA_HEIGHT,	req->Height,
d1213 4
a1216 2
    addReqImage( req, textframe );
    /* It's OK if 'fillrect' object isn't successfully created	*/
d1218 7
d1233 2
a1234 1
    if ( retwindow = reqWindow( rwin, refscreen, title, req, iflags) )
d1240 2
d1257 1
a1257 1
    if ( req )
d1260 1
a1260 1
	disposeImageList( req->ReqImage );
d1290 1
a1290 1
/* adds image to front of ReqImage list,
d1292 1
a1292 1
 * already in list.
d1294 3
a1296 3
addReqImage( req, im )
struct Requester	*req;
struct Image		*im;
d1300 2
a1301 2
	im->NextImage = req->ReqImage;
	req->ReqImage = im;
d1335 8
a1342 6
reqWindow( rwin, screen, title, req, iflags )
struct Window		*rwin;
struct Screen		*screen;
UBYTE			*title;
struct Requester	*req;
ULONG			iflags;
a1351 5
    /* position the requester just so */
    req->TopEdge = screen->WBorTop + screen->Font->ta_YSize + 1;
    req->LeftEdge = screen->WBorLeft;


d1373 2
a1374 2
	WA_Width, req->LeftEdge + req->Width + screen->WBorRight,
	WA_Height, req->TopEdge + req->Height + screen->WBorBottom,
d1382 1
a1385 8
	if ( ! Request( req, w ) )
	{
	    DMEM( printf("Request failed!\n"));
	    CloseWindow( w );
	    w = NULL;
	    goto OUT;
	}
	D( printf("Request returned\n") );
a1449 4
    struct Gadget	*g;
    struct Gadget	*succ_g;
    struct Image	*im;
    struct Image	*succ_im;
d1451 3
d1458 2
a1459 2
    g = window->FirstRequest->ReqGadget;
    im = window->FirstRequest->ReqImage;
a1461 21
    /* close the requester in the requestwindow */
    EndRequest( window->FirstRequest, window );

    DFSR( printf("FSR\n") );

    disposeGadgetList( g );
    disposeImageList( im );

    /* free the things I've tracked; do FreeRemember() LAST, since
     * it free's the SysReqTrack
     */
    DFSR( printf("dispose gadget frame %lx\n",
	((struct SysReqTrack *)window->UserData)->srt_GadgetFrame) );

    DisposeObject(((struct SysReqTrack *)window->UserData)->srt_GadgetFrame);

    DFSR( printf("FreeRemember %lx\n", 
	&((struct SysReqTrack *)window->UserData)->srt_Remember, TRUE) );

    FreeRemember(&((struct SysReqTrack *)window->UserData)->srt_Remember, TRUE);

d1477 14
@


38.3
log
@Fixed AutoRequest() prototype.
@
text
@d5 1
a5 1
 *  $Id: ezreq.c,v 38.2 91/07/25 15:02:05 peter Exp Locker: peter $
d732 1
a732 1
    window =  commonBSR( rwin, screen, ez->es_Title,
d1035 1
a1035 1
commonBSR( rwin, refscreen, title, itext, glist, gadgetframe,
d1039 1
a1039 1
UBYTE		*title;
d1063 1
d1073 1
a1073 1
		remkey, sizeof *req + sizeof *srt, 0 ) ) )
d1078 5
a1082 1
    InitRequester( req );
d1087 10
d1152 1
a1152 1
	    reqTitleLength( &refscreen->RastPort, rwin, title ) ),
d1271 1
a1271 1
reqTitleLength( rp, w, title )
a1272 1
struct Window	*w;
a1274 1
    struct IntuitionBase	*IBase = fetchIBase();
a1277 7
    /* 'title' wins, if present, next window title, then SysReqTitle */
    if ( (title == NULL) && w )
    {
	title = w->Title;
    }
    if ( title == NULL ) title = IBase->SysReqTitle;

a1340 2
    /* struct NewWindow	nw; * *** try to reduce stack by allocating this */

a1341 1
    struct NewWindow	*nwp;
d1344 2
a1345 3
    struct Window	*OpenWindowTagList();
    struct TagItem	taglist[2];
    extern struct NewWindow	SysNewWindow;
a1348 11
    if ( !(nwp = (struct NewWindow *) AllocMem( sizeof *nwp, MEMF_CLEAR )))
    {
	DMEM( printf("no new window allocated\n"));
	return ( NULL );
    }

    DMEM( printf("got newwindow\n"));

    nwp->Flags = ( ACTIVATE | SIMPLE_REFRESH | WINDOWDRAG |
	WINDOWDEPTH | NOCAREREFRESH );

a1351 2
    nwp->Width = req->LeftEdge + req->Width + screen->WBorRight;
    nwp->Height = req->TopEdge + req->Height + screen->WBorBottom;
a1352 19
    /* Peter 2-Dec-90: Limit testing on window size will be accomplished
     * using WA_AutoAdjust.  Also, I now leave MinWidth, MinHeight,
     * MaxWidth, and MaxHeight set to zero, since that's equivalent
     * to setting them equal to width and height.
     */

    /* Peter 2-Dec-90: Let's appear on the visible part of a scrolling
     * screen.
     */

    nwp->LeftEdge = imax(0,-screen->LeftEdge);
    nwp->TopEdge = imax(0,-screen->TopEdge);

    DMEM( printf("reqWindow w %ld h %ld\n", nwp->Width, nwp->Height ) );

    nwp->IDCMPFlags = iflags | REQIFLAGS;

    /* new stuff: use default pubscreen instead of WB */
    nwp->Screen = screen;
d1354 2
a1355 3
    /* if no reference window, then I'm going on default pubscreen */
    nwp->Title = IBase->SysReqTitle;
    nwp->Type = PUBLICSCREEN;
d1359 2
a1360 16
	/* NB:  Detail and BlockPen used to be copied from rwin, but
	 * they're not used any more in the rendering of the Request.
	 */ 
	nwp->Title =  rwin->Title;
	nwp->Type = CUSTOMSCREEN;
    }

    if ( title ) nwp->Title = title;

    DMEM( printf("trying to open window w %ld h %ld\n",
		nwp->Width, nwp->Height ));

    /* Let WA_AutoAdjust fit me to the screen */
    taglist[0].ti_Tag = WA_AutoAdjust;
    taglist[0].ti_Data = TRUE;
    taglist[1].ti_Tag = TAG_DONE;
d1362 23
a1384 1
    if ( w = OpenWindowTagList( nwp, taglist ) )
a1414 1
    FreeMem( nwp, sizeof *nwp );
@


38.2
log
@Uses new S_TOFRONT and S_TOBACK labels.
@
text
@d5 1
a5 1
 *  $Id: ezreq.c,v 38.1 91/07/10 17:54:07 peter Exp Locker: peter $
d243 2
a244 1
*		struct IntuiText *, struct IntuiText *, WORD, WORD );
@


38.1
log
@Removed unneeded tests for NULL around DisposeObject().
Eliminated unused use_pubscreen.
@
text
@d5 1
a5 1
 *  $Id: ezreq.c,v 38.0 91/06/12 14:16:36 peter Exp Locker: peter $
d1425 1
a1425 1
	    doISM( itDEPTHSCREEN, reqscreen, NULL, IUPFRONT );
d1428 1
a1428 1
	    sendISMNoQuick( itDEPTHSCREEN, reqscreen, NULL, IUPFRONT );
d1527 1
a1527 1
	doISM( itDEPTHSCREEN, reqscreen, NULL, IBEHIND );
@


38.0
log
@Initial V38 check-in (matches V37 release).
@
text
@d5 1
a5 1
 *  $Id: ezreq.c,v 1.34 91/05/16 16:34:21 peter Exp $
d737 1
a737 1
    if ( window  == NULL || (ULONG) window == 1 )
d752 1
a752 1
    if (frame) DisposeObject( frame );
d992 1
a992 1
    if ( window  == NULL || (ULONG) window == 1 )
d1007 1
a1007 1
    if (frame) DisposeObject( frame );
d1200 1
a1200 1
			IA_FGPEN,	drinfo->dri_Pens[ shinePen ],
a1340 1
    BOOL		use_pubscreen = FALSE;
@
