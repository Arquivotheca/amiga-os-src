head     38.35;
branch   ;
access   ;
symbols  V40_85:38.35 V40_71:38.35 V40_68:38.35 V40_65:38.35 V40_47:38.35 V40_45:38.35 V40_37:38.35 V40_34:38.34 V40_29:38.34 V39_2415:38.33 V39_2369:38.31 V39_2339:38.31 V39_2332:38.31 V39_2275:38.31 V39_2256:38.30 V39_2210:38.29 V39_2192:38.28 V39_2084:38.27 V39_2082:38.27 V39_2076:38.27 V39_2073:38.27 V39_2058:38.26 V39_2051:38.26 V39_2031:38.25 V39_2017:38.25 V39_2012:38.23 V39_1985:38.22 V39_1933:38.22 V39_1819:38.21 V39_1805:38.20 V39_1783:38.20 V39_1695:38.20 V39_1621:38.20 V39_1620:38.20 V39_1508:38.20 V39_1485:38.19 V39_1461:38.19 V39_1458:38.19 V39_1456:38.19 V39_1405:38.18 V39_1368:38.16 V39_1360:38.16 V39_1324:38.16 V39_1147:38.15 V39_1143:38.14 V39_1141:38.14 V39_1120:38.14 V39_1116:38.14 V39_1104:38.14 V39_1100:38.14 V39_1078:38.14 V39_1073:38.14 V39_757:38.12 V39_702:38.11 V39_557:38.9 V39_553:38.9 V39_551:38.9 V39_510:38.8 V39_495:38.8 V39_416:38.8 V39_383:38.8 V39_371:38.8 V39_336:38.7 V39_323:38.7 V39_295:38.7 V39_277:38.6 V39_254:38.5 V39_222:38.4 V39_185:38.4 V39_171:38.4 V39_161:38.3 V38_159:38.3 V38_116:38.2 V38_59:38.0;
locks    ; strict;
comment  @*   @;


38.35
date     93.03.17.17.12.46;  author peter;  state Exp;
branches ;
next     38.34;

38.34
date     93.02.15.19.06.32;  author peter;  state Exp;
branches ;
next     38.33;

38.33
date     93.01.14.14.27.48;  author peter;  state Exp;
branches ;
next     38.32;

38.32
date     93.01.12.16.21.43;  author peter;  state Exp;
branches ;
next     38.31;

38.31
date     92.12.04.11.58.30;  author peter;  state Exp;
branches ;
next     38.30;

38.30
date     92.11.25.15.42.14;  author peter;  state Exp;
branches ;
next     38.29;

38.29
date     92.11.20.18.33.40;  author peter;  state Exp;
branches ;
next     38.28;

38.28
date     92.11.10.17.11.43;  author peter;  state Exp;
branches ;
next     38.27;

38.27
date     92.08.24.11.41.56;  author peter;  state Exp;
branches ;
next     38.26;

38.26
date     92.08.18.10.14.17;  author peter;  state Exp;
branches ;
next     38.25;

38.25
date     92.08.14.14.55.48;  author mks;  state Exp;
branches ;
next     38.24;

38.24
date     92.08.13.11.08.34;  author mks;  state Exp;
branches ;
next     38.23;

38.23
date     92.08.06.09.47.36;  author peter;  state Exp;
branches ;
next     38.22;

38.22
date     92.08.03.15.56.12;  author peter;  state Exp;
branches ;
next     38.21;

38.21
date     92.07.28.15.14.23;  author peter;  state Exp;
branches ;
next     38.20;

38.20
date     92.06.22.13.04.10;  author peter;  state Exp;
branches ;
next     38.19;

38.19
date     92.06.03.17.41.35;  author peter;  state Exp;
branches ;
next     38.18;

38.18
date     92.05.29.18.57.23;  author peter;  state Exp;
branches ;
next     38.17;

38.17
date     92.05.29.18.30.17;  author peter;  state Exp;
branches ;
next     38.16;

38.16
date     92.05.15.14.11.04;  author peter;  state Exp;
branches ;
next     38.15;

38.15
date     92.05.05.13.31.42;  author peter;  state Exp;
branches ;
next     38.14;

38.14
date     92.04.07.18.00.47;  author peter;  state Exp;
branches ;
next     38.13;

38.13
date     92.04.02.12.09.07;  author peter;  state Exp;
branches ;
next     38.12;

38.12
date     92.03.26.16.40.58;  author peter;  state Exp;
branches ;
next     38.11;

38.11
date     92.03.23.11.55.36;  author peter;  state Exp;
branches ;
next     38.10;

38.10
date     92.03.18.11.51.52;  author peter;  state Exp;
branches ;
next     38.9;

38.9
date     92.03.03.16.36.44;  author peter;  state Exp;
branches ;
next     38.8;

38.8
date     92.02.05.15.40.06;  author peter;  state Exp;
branches ;
next     38.7;

38.7
date     91.12.12.20.45.17;  author peter;  state Exp;
branches ;
next     38.6;

38.6
date     91.11.25.16.56.25;  author peter;  state Exp;
branches ;
next     38.5;

38.5
date     91.11.15.18.55.05;  author peter;  state Exp;
branches ;
next     38.4;

38.4
date     91.09.23.12.29.52;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     91.08.21.18.21.50;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     91.07.25.16.38.25;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.07.25.15.05.05;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.12.14.34.57;  author peter;  state Exp;
branches ;
next     ;


desc
@@


38.35
log
@In the BitMap poker detector kludge, now compare embedded BitMap
against the preserved copy, instead of the real one.  Fixes titles
made using The Director.
@
text
@/*** view.c ***************************************************************
 *
 *  view.c -- view modes, viewport, copper list stuff
 *
 *  $Id: view.c,v 38.34 93/02/15 19:06:32 peter Exp Locker: peter $
 *
 *  Confidential Information: Commodore-Amiga, Inc.
 *  Copyright (c) Commodore-Amiga, Inc.
 *
 ****************************************************************************/

/* Starting with 3.01, graphics allows a user to denote his ViewPort
 * as one where the updating of intermediate copper-lists is to be
 * skipped, for speed.  In such ViewPorts, it is essential that
 * we never MrgCop() them without first calling MakeVPort().
 */
#ifndef CMAF_NO_INTERMED_UPDATE
#define CMAF_NO_INTERMED_UPDATE	2
#endif

/* This optimization depends on GfxBase maintaining a VBlank counter.
 * the idea is that in place of WaitTOF()/FreeXXX(), we send ourselves
 * a token (reminder) to FreeXXX after the VBlank counter has had
 * a chance to change, thus taking a WaitTOF() clean out of RethinkDisplay()
 * and friends.
 */
#define WAITTOF_OPTIMIZE	0

#include "intuall.h"
#include "preferences.h"

#define D(x) 		;
#define DDP(x) 		;	/* dpaint backsync vp/screen	*/
#define DVP(x)		;
#define DC(x) 		;	/* coercion		*/
#define DSNOOP(x) 	;	/* mode snooping	*/

/* hack to sniff out VP dx/dyoffset poke-hackers	*/
#define DPAINT_BACK_SYNC	(1)
				/* rather than sync the viewport to
				 * the screen, let's try the other
				 * way around, and move the DClip too
				 */

#define LONGMATH	(1)
/* OOPS: I should have known that it wasn't worth calling the
 * existing scale routines.  I remember when the scaling was
 * not table driven, though, and was much more fun
 */

#ifndef EXEC_MEMORY_H
#include <exec/memory.h>
#endif

#ifndef EXEC_ALERTS_H
#include <exec/alerts.h>
#endif

#ifndef GRAPHICS_GFXNODES_H
#include <graphics/gfxnodes.h>
#endif

#ifndef GRAPHICS_DISPLAY_H
#include <graphics/display.h>
#endif

#ifndef GRAPHICS_DISPLAYINFO_H
#include <graphics/displayinfo.h>
#endif

#ifndef GRAPHICS_GFXMACROS_H
#include <graphics/gfxmacros.h>
#endif

#ifndef HARDWARE_CUSTOM_H
#include <hardware/custom.h>
#endif

#ifndef HARDWARE_DMABITS_H
#include <hardware/dmabits.h>
#endif

extern struct Custom custom;

/* three non-lace rows	*/
#define INTERSCREENLINES	6  /* number of interlace rows */

#define TOPMOSTLIMIT	(0)	/* screen not visible below this are VP_HIDE */


/* Calculate the inter-screen gap, according to graphics.library's
 * CalcIVG() function.  We never let the number be less than the
 * traditional INTERSCREENLINES (6 interlaced lines).
 * Returns the answer in ViewPort resolution lines.
 */

ULONG CalcISG( sc )
struct Screen *sc;
{
    struct IntuitionBase *IBase = fetchIBase();
    LONG isg;

    isg = CalcIVG( &IBase->ViewLord, &sc->ViewPort ) * XSC(sc)->ScaleFactor.Y;

    if ( ( !TESTFLAG( XSC(sc)->PrivateFlags, PSF_MINIMIZEISG ) ) && ( isg < INTERSCREENLINES * IBase->MouseScaleY ) )
    {
	isg = INTERSCREENLINES * IBase->MouseScaleY;
    }
    return( isg );
}


/*** intuition.library/MakeScreen ***/

MakeScreen(screen)
struct Screen *screen;
{
    newMakeScreen(screen, TRUE);
}

/* Pass in rethink=FALSE to get a lightweight MakeScreen(), however
 * you promise to follow-up with RethinkDisplay().  Dragging of
 * multiple screens uses this feature.
 */
newMakeScreen(screen,rethink)
struct Screen *screen;
BOOL rethink;
{
    LONG result = 0;
    struct IntuitionBase *IBase = fetchIBase();

    if ( ! screen ) return;

    /* Forbid() replaced by lockIBase(): jimm: 1/6/86 */
    LOCKIBASE();
    LOCKVIEW();

    modeSnoop( screen, 0 );	/* check to see if he's poked his modes */

    /* signal to rethinkVPorts that you need new copper lists remade */
    SETFLAG( XSC(screen)->PrivateFlags, PSF_REMAKEVPORT );

    if ( rethink )
    {
	LOCKVIEWCPR();
	IBase->ViewFailure = 0;
	DVP( printf("MakeScreen calling modeVerify\n") );
	if ( !modeVerify( NOFORCE) )
	{
	    DVP( printf("MakeScreen calling rVP\n") );
	    rethinkVPorts( NOFORCE );
	}
	result = IBase->ViewFailure;
	UNLOCKVIEWCPR();

	/* Peter 4-Feb-91:
	 * updateMousePointer() no longer happens inside rethinkVPorts(), so
	 * we've got to do our own.  See the comment at the end of
	 * rethinkVPorts() for a discussion as to why.
	 */
	updateMousePointer( IBase->SimpleSprite );

    }
    /* Permit replaced by unlockIBase() */
    UNLOCKVIEW();
    UNLOCKIBASE();
    return( result );
}

/*
 * detect and resolve mode changes done by poking viewport.modes
 */
modeSnoop( screen, force )
struct Screen	*screen;
{
    ULONG		newdisplayid;
    int			force;

    /* Fix any pokers of BitMap depth or planes that we see.
     * ProPage and ProDraw need this detector here, because
     * they poke their BitMap depth.
     */
    fixBitMapPokers( screen );

    newdisplayid = XSC(screen)->NaturalDisplayID;

    /* Most callers of modeSnoop() call with force=0.  That means,
     * only go through modeSnoop() if the VPModeStash changed.
     *
     * However, for screens of the default monitor, RemakeDisplay()
     * calls us with force=FORCE.  This means we're to call
     * setScreenDisplayID(), because the mapping of the default
     * monitor may have changed due to promotion.
     *
     * Note that the ordering in the OR expression is important,
     * since it affects the value of newdisplayid!!
     */
    if ( ( force ) ||
	( ( newdisplayid = screen->ViewPort.Modes & OLD_MODES ) !=
	XSC(screen)->VPModeStash ) )
    {
	struct Rectangle	screenrect;

	DSNOOP( printf("MakeScreen %lx MODESNOOP new mode: %lx, old mode %lx\n",
		screen, newdisplayid, XSC(screen)->VPModeStash ) );

	/* setup new mode */
	setScreenDisplayID( screen, newdisplayid, NULL, force );

	/* Under V37, we used to reset the DClip to the hull of the
	 * TextOverscan and the screen rectangle.  However, we must
	 * not reset the DClip if we come here through promotion.
	 *
	 * On balance, it was simpler to just remove the code, since
	 * mode-poking is discouraged anyways and hulling with the
	 * screen rectangle ensures non-scrollability provided no-one
	 * spoofs the screen dimensions.
	 */
	/* coerce and xform dclip */
	coerceScreens( screen, FORCE );

	DSNOOP( dumpRect("new DClip", &XSC(screen)->DClip ) );
	DSNOOP( printf("ID now set, new mode stash %lx\n",
		XSC(screen)->VPModeStash ) );

    }
    DSNOOP( else printf("MakeScreen %lx, no mode change: %lx, old mode %lx\n",
		screen, newdisplayid, XSC(screen)->VPModeStash ) );
}


fixBitMapPokers( sc )
struct Screen *sc;
{
    /* Disney Animation Studio changes the bitplane pointers in
     * the screen->sc_BitMap, then calls ScrollVPort() and
     * RethinkDisplay().  Under V37 and prior, this worked since
     * the ViewPort.RasInfo->BitMap pointed at screen->sc_BitMap.
     * ScrollVPort() remade the copper lists from the bitplane
     * pointers.
     *
     * Under V39, the RasInfo->BitMap is the RealBitMap we got
     * from AllocBitMap().  Poking sc_BitMap thus has no effect.
     * To keep Mickey smiling, we look for changes to the sc_BitMap
     * planes at RethinkDisplay() time.  If we find any, then we
     * do a one-time one-way switch to using the embedded sc_BitMap
     * instead of the RealBitMap.  From that point on, they work
     * just like V37.  To get the first frame to come out right,
     * we note that we must remake the ViewPort.
     *
     * MKS 14-Aug-92:  Now only check the valid plane pointers up
     * to the bitmap's depth.  Also, the test is only done if the
     * RasInfo BitMap itself was not poked.  Some double-buffering
     * programs do that, and we don't want to break them.
     *
     * Note that one last case is not handled by this:
     * Someone poking the plane pointers of the RasInfo->BitMap.
     * So far no one has been shown to have done this.  My feeling
     * is that it is not important since most likely they would have
     * poked the whole bitmap rather than just the plane pointers
     * since it is easier to poke just the bitmap.
     * We check against the hidden screen layer rastport bitmap
     * since the screen rastport bitmap may have been changed
     * at the same time as the RasInfo bitmap was (for rendering
     * reasons)
     */
    if (XSC(sc)->ClipLayer->rp->BitMap == sc->ViewPort.RasInfo->BitMap)
    {
	int plane;
	struct BitMap *embedded_bm = &sc->sc_BitMap;

	for ( plane = 0; plane < embedded_bm->Depth ; plane++ )
	{
	    if ( ( embedded_bm->Depth != XSC(sc)->sc_BitMapCopy.Depth ) ||
		( XSC(sc)->sc_BitMapCopy.Planes[ plane ] != embedded_bm->Planes[ plane ] ) )
		
	    {
		/* Found a bitmap plane poker (eg. Disney Animator) */
		SETFLAG( XSC(sc)->PrivateFlags, PSF_REMAKEVPORT );
		sc->RastPort.BitMap = embedded_bm;
		sc->ViewPort.RasInfo->BitMap = embedded_bm;
		XSC(sc)->ClipLayer->rp->BitMap = embedded_bm;
		sc->BarLayer->rp->BitMap = embedded_bm;
		break;
	    }
	}
    }
}


/*** intuition.library/RemakeDisplay ***/

RemakeDisplay()
/* parameter removed by jimm, 11/4/85 */
{
    struct Screen	*s;
    LONG result;
    struct IntuitionBase *IBase = fetchIBase();

    /* Forbid() replaced by lockIBase(): jimm: 1/6/86 */
    LOCKIBASE();
    LOCKVIEW();
    LOCKVIEWCPR();

    IBase->ViewFailure = 0;

    /* jimm: 5/14/90: put mode snooping for all screens in
     * here, too
     */
    {
	for ( s = fetchIBase()->FirstScreen; s; s = s->NextScreen )
	{
	    /* To handle promotion, we must force modeSnoop() if
	     * the screen's natural mode is of the default monitor
	     */
	    int force = 0;
	    if ( !MONITOR_PART( XSC(s)->NaturalDisplayID ) )
	    {
		force = FORCE;
	    }
	    modeSnoop( s, force );
	}
    }

    modeVerify( FORCE );
    remakeCopList();

    result = IBase->ViewFailure;

    /* Permit replaced by unlockIBase() */
    UNLOCKVIEWCPR();
    UNLOCKVIEW();
    UNLOCKIBASE();

    return( result );
}


/*** intuition.library/RethinkDisplay ***/

RethinkDisplay()
{
    LONG result;
    struct IntuitionBase *IBase = fetchIBase();

    LOCKIBASE();
    LOCKVIEW();
    LOCKVIEWCPR();

    IBase->ViewFailure = 0;
    /* makes all viewports if mode change occured, else minimal amount */
    DVP( printf("RethinkDisplay calling modeVerify\n") );
    if ( ! modeVerify( NOFORCE ) )
    {
	DVP( printf("RethinkDisplay calling RVP\n") );
	rethinkVPorts( NOFORCE );	/* minimal amount done here */
    }
    /* else, modeVerify remade 'em all	*/
    remakeCopList();

    result = IBase->ViewFailure;

    /* Permit replaced by unlockIBase() */
    UNLOCKVIEWCPR();
    UNLOCKVIEW();
    UNLOCKIBASE();

    return( result );
}

/** make sure IBASELOCK is set before calling **/
/*
 * if 'force' is FORCE or MEGAFORCE, will either remake or set VP_HIDE for
 * each viewport.  If MEGAFORCE, will sync up vp dx/yoffsets.
 */

#ifndef VPXF_LAST
#define VPXF_LAST	2
#endif

rethinkVPorts( force )
int		force;
{
    LONG		alltop;	/* topmost edge above which screens must peek */
    LONG		sctop;	/* screen top in mouse coordinates */
    ULONG		vpheight;	/* viewport height in mouse coords */
    LONG		show_vp;

	/* tracks topmost obscuring screen, in mouse coordinates.	*/
    struct Screen	*sc, *first_screen;
    struct ViewPort	*vport;
    struct IntuitionBase *IBase = fetchIBase();

    assertLock("rethinkVP", IBASELOCK );
    assertLock("rethinkVP", VIEWCPRLOCK );

    if ( !(sc = first_screen = IBase->FirstScreen) )
    {
	return;
    }

    /* start with top most at bottom of front screen, which
     * may well be off display, and clipped by bart.
     * everything is done in mouse coordinates
     */
    alltop = (sc->TopEdge + sc->Height) *
		XSC(sc)->ScaleFactor.Y;

    DVP( printf("first sc top: %ld\n", sc->TopEdge ));
    DVP( printf("initial alltop: %ld\n", alltop ));

    /*
     * for each screen/viewport:
     *	determine if it's visible (won't be if hedley-incompatible)
     *  set up its visible DHeight
     *  remake the viewport if the height changed or if
     *    a mode change mandates that they all be remade
     */
    for ( ; sc; sc = sc->NextScreen )
    {
	/* Fix any pokers of BitMap depth or planes that we see.
	 * Disney Animation Studio is helped by this call here,
	 * since they call ScrollVPort() then RethinkDisplay(),
	 * with no call to MakeScreen().
	 */
	fixBitMapPokers( sc );

	vport = &sc->ViewPort;
	/* For a AA-kludge, graphics needs to know which is the
	 * bottom-most viewport on the screen.  That would be the
	 * viewport of the first screen.
	 */
	XSC(sc)->VPExtra->Flags &= ~VPXF_LAST;
	if ( sc == IBase->FirstScreen )
	{
	    XSC(sc)->VPExtra->Flags |= VPXF_LAST;
	}

	/* Ordinarily, the screen Left/Top are slaved to the ViewPort
	 * Dx/yOffset, which is required in order to support various
	 * overscan techniques of old.  So we only reset the screen VP
	 * position based on the screen Left/Top under drastic circumstances,
	 * which are:
	 * - change in scan rate (=active monitor) (causes MEGAFORCE)
	 * - coercion moving a screen (causes PSF_NEWSCREENOFFSETS)
	 */
	if ( ( force == MEGAFORCE ) ||
	    TESTFLAG( XSC(sc)->PrivateFlags, PSF_NEWSCREENOFFSETS ) )
	{
	    XSC(sc)->VPOffsetStash.X =
		    vport->DxOffset = sc->LeftEdge;
	    XSC(sc)->VPOffsetStash.Y =
		    vport->DyOffset = sc->TopEdge;
	}
#if DPAINT_BACK_SYNC
	else
	{
	    WORD	delleft;
	    WORD	deltop;

	    /* move the screen and the DClip to match VP	*/
	    delleft =  vport->DxOffset - XSC(sc)->VPOffsetStash.X;
	    deltop = vport->DyOffset - XSC(sc)->VPOffsetStash.Y;

	    DDP( printf( "delleft/top %ld %ld\n", delleft, deltop));

	    if ( ( deltop ) || ( delleft ) )
	    {
		DDP( printf("detect vp poke of %ld, %ld\n",
		    delleft, deltop ) );

		/* sync up	*/
		XSC(sc)->VPOffsetStash.X =
		    sc->LeftEdge = vport->DxOffset;
		XSC(sc)->VPOffsetStash.Y =
		    sc->TopEdge = vport->DyOffset;

		/* translate dclip to shadow vp poke	*/
		offsetRect( &XSC(sc)->DClip, delleft, deltop );
		coerceScreens( sc, FORCE );
	    }
	}
#endif

	CLEARFLAG( XSC(sc)->PrivateFlags, PSF_NEWSCREENOFFSETS );

	/* Will assume this viewport is to be hidden until
	 * proven otherwise:
	 */
	show_vp = FALSE;

	/* exclude screens which are not compatible with the
	 * frontmost
	 */

	if ( !TESTFLAG( sc->Flags, SCREENHIDDEN ) )
	{
	    sctop = sc->TopEdge * XSC(sc)->ScaleFactor.Y;
	    if ( sctop < alltop && alltop > TOPMOSTLIMIT )
	    {
		/* vpheight is the amount the screen "peeks over"
		 * the ones in front (or of its own bottom edge,
		 * if it is the frontmost).
		 */
		vpheight = alltop - sctop;
		DVP( printf("vpheight in mouse coords: %ld\n", vpheight));

		vpheight /= XSC(sc)->ScaleFactor.Y;
		DVP( printf("vpheight in screen coords: %ld\n", vpheight));

		/* limit vp allowed height to actual screen height
		 * ("short screens float")
		 */
		vpheight = imin( vpheight, sc->Height );
		DVP( printf("vpheight limited: %ld\n", vpheight ) );

		/* Here's an explanation of when we call MakeVPort()
		 * on a ViewPort.  First, we always MakeVPort() if
		 * in the process of a drastic remake (force = FORCE
		 * or MEGAFORCE, indicating RethinkDisplay() or somesuch).
		 * Second, we remake if the ViewPort height changed
		 * (which could result from sliding a screen which is
		 * below us).  Third, we remake any ViewPort whose screen
		 * has PSF_REMAKEVPORT set in it.  This flag is set
		 * in MakeScreen(), in fixBitMapPokers() if a poker is caught,
		 * or when we determine in this routine that a ViewPort
		 * is hidden (either due to exclusion, geometry or
		 * MakeVPort()-failure.  So, ALWAYS remake the
		 * PSF_REMAKEVPORT guys.
		 *
		 * Starting with 3.01, graphics allows a user to
		 * denote his ViewPort as one where the updating of
		 * intermediate copper-lists is to be skipped, for
		 * speed.  In such ViewPorts, it is essential that we
		 * never MrgCop() them without first calling
		 * MakeVPort().
		 *
		 * There's no explicit check for ViewPort DxOffset/DyOffset
		 * changes, because that only happens inside screen-dragging
		 * (which calls MakeScreen()), or due to coercion (which
		 * sets the force variable).  There's actually an
		 * external reliance on that now, since we can have an
		 * off-the-bottom ViewPort, which Intuition doesn't care
		 * about, but graphics (in 3.01 and up) generates no
		 * intermediate copper lists for.  We count on MakeVPort()
		 * being called for this ViewPort if ever it's moved
		 * on-screen.  As I just said, screen-dragging and coercion
		 * are the possible ways, and they're covered.
		 */

		/* According to the geometry of the screens in the system,
		 * this ViewPort is supposed to be visible.  The only
		 * thing that will stop us now is a MakeVPort() failure.
		 */
		show_vp = TRUE;

		if ( ( force != NOFORCE ) ||
		    ( vport->DHeight != vpheight ) ||
		    TESTFLAG( XSC(sc)->PrivateFlags, PSF_REMAKEVPORT ) ||
		    TESTFLAG( XSC(sc)->ColorMap->AuxFlags, CMAF_NO_INTERMED_UPDATE ) )
		{
		    vport->DHeight = vpheight;
		    /* to coerceScreens(): rethinkScreenClip( sc ); */
		    setSpriteSpeed( sc );
		    if ( MakeVPort( &IBase->ViewLord, vport ) )
		    {
			/* Oh no!  Hide that screen! */
			show_vp = FALSE;
			IBase->ViewFailure = 1;
		    }
		}
	    }
	    DVP( else printf("rVP: hidden on account of VP coordinates out of range\n") );
	}
	DVP( else printf("rVP: excluding screen: %lx\n", sc ) );


	if ( show_vp )
	{
	    /* The screen is visible, so mark it accordingly */
	    CLEARFLAG( vport->Modes, VP_HIDE );
	    CLEARFLAG( XSC(sc)->PrivateFlags, PSF_REMAKEVPORT );

	    /* CalcISG() is an Intuition function to figure out the
	     * interscreen-gap, given a screen.  It returns an
	     * answer in ticks based on graphics.library CalcIVG().
	     */
	    alltop = sctop - CalcISG( sc );
	    DVP( printf(" last screentop: %ld\n", sctop ) );
	    DVP( printf(" alltop now left at: %ld\n", alltop ) );
	}
	else
	{
	    /* The screen is hidden on account of one of the following:
	     * - it was excluded by the front screen
	     * - its viewport coordinates are out of range
	     * - MakeVPort() failed.
	     *
	     * We set PSF_REMAKEVPORT because we want to try MakeVPort()
	     * again next time anything changes.
	     */
	    SETFLAG( vport->Modes, VP_HIDE );
	    SETFLAG( XSC(sc)->PrivateFlags, PSF_REMAKEVPORT );
	}
    }

    /* won't wrongly free up mouse if INMOUSELIMITS is set,
     * by screen drag, window size/drag, menu, ...
     */
    freeMouse();

    /* Peter 4-Feb-91:
     * If we got here as a result of a mode switch, then the screens'
     * SpriteFactors resemble the future display, not the currently
     * displayed copper lists.  In such cases, remakeCopList() is
     * imminent, and that'll fix everything up.  In fact, remakeCopList()
     * will cause updateMousePointer() to happen anyways.
     * We used to call updateMousePointer() here, but that would cause the
     * sprite to jump.  So instead, we rely on our callers to call
     * updateMousePointer(), either through remakeCopList() or directly.
     * Our callers (direct and those through modeVerify()):
     *     MakeScreen() - needs its own updateMousePointer()
     *     RethinkDisplay() - OK since it calls remakeCopList() immediately
     *     RemakeDisplay() - OK since it calls remakeCopList() immediately
     *     initIntuition() - OK since it eventually calls setPrefs() which
     *         calls setIBasePrefs() which calls RemakeDisplay()
     *
     * So we don't do this here any more:
     *
     * updateMousePointer(NULL);
     *
     */
}

/*
 * determines correct display modes (sets ScanRate and LACE)
 * if changes or 'force', syncs other display mode dependent
 * parameters (view extend, view offsets, dclip, mouse constraint)
 * and rebuilds all viewports.
 *
 * Returns TRUE if it decided to remake all viewports, so caller
 * shouldn't bother to call rethinkVPorts again.
 *
 * called by RethinkDisplay (force == NOFORCE),
 * RemakeDisplay (force == FORCE)
 *
 * might call rethinkVPorts with MEGAFORCE if monitorCheck()
 * requires global remake and sync.
 */
modeVerify( force )
int	force;
{
    int megaforce;

    assertLock("modeVerify", VIEWCPRLOCK );
    /* always do monitorCheck, but skip first laceCheck if 'force'	*/
    /* side effects of these check functions:
     *	monitorCheck sets up IBase->ActiveMonitorSpec
     *	laceCheck sets up IBase->ViewLord.Modes:INTERLACE;
     */
    if ( (megaforce = monitorCheck()) ||
	  (force != NOFORCE)  ||
	  laceCheck() )
    {
	/* set scalefactors, positions, of screens for
	 * current monitor.  If we have a monitor change, this
	 * function will resync ViewLord position to per-view
	 * preferences positions.  Otherwise,  let 'em float.
	 *
	 * If the monitor changed, we want to pass MEGAFORCE
	 * (comes from 'megaforce').  If we were called with
	 * 'force' = FORCE, we want to pass FORCE along.
	 * If none of this is true, then we're here only because
	 * laceCheck() sent us here, in which case we want NOFORCE.
	 * This avoids coercion-recalculation when the ViewPort
	 * INTERLACE changes during screen sliding.
	 *
	 */
	setupMonitor( imax(force,megaforce) );

	laceCheck();		/* recalc lace after setupMonitor()	*/

	/* here's the tricky part: we definitely want all copper lists
	 * remade, but we only want to sync viewport positions if
	 * we have a monitor change
	 */
	rethinkVPorts( imax(FORCE, megaforce) );
				/* make all vp's and clips		*/
	return ( TRUE );
    }
    return ( FALSE );
    /* caller will probably be calling rethinkVPorts( NOFORCE );	*/
}

/* returns non-FALSE if LACE state has changed
 *
 * NOTE: duplicates rethinkVPorts loop to calculate viewport visibility.
 */
laceCheck()
{
    struct IntuitionBase *IBase = fetchIBase();
    LONG alltop, sctop;
    struct Screen *sc;
    UWORD needlace = 0;
    UWORD oldlace = 0;

    /* save lace state to detect changes */
    oldlace = IBase->ViewLord.Modes & INTERLACE;

    /* starting assumption, might override below	*/
    CLEARFLAG( IBase->ViewLord.Modes, INTERLACE );

    /* this "screen visibility loop" is from rethinkVPorts,
     * where it is nicely commented
     */
    if ( sc = IBase->FirstScreen )
    {
	alltop = (sc->TopEdge + sc->Height) * XSC(sc)->ScaleFactor.Y;
    }
    for ( ; sc; sc = sc->NextScreen )
    {
	if ( TESTFLAG( sc->Flags, SCREENHIDDEN ) )
	{
	    continue;
	}
	else
	{
	    sctop = sc->TopEdge * XSC(sc)->ScaleFactor.Y;
	    if ( sctop < alltop && alltop > TOPMOSTLIMIT )
	    {
		/* set LACE bit in needlace if any of
		 * these visible screens are interlaced
		 */
		needlace |= XSC(sc)->DProperties & DIPF_IS_LACE;
		alltop = sctop - CalcISG( sc );
	    }
	}
    }

    if ( needlace ) SETFLAG( IBase->ViewLord.Modes, INTERLACE );

    /* return TRUE if lace mode has toggled */
    DSNOOP( if ( (needlace && !oldlace ) || (oldlace && !needlace ) )
	printf("laceCheck hit %lx/%lx\n", needlace, oldlace));
    return ( (needlace && !oldlace ) || (oldlace && !needlace ) );
}

/* make sure IBASELOCK is set before calling
 * sets ActiveMonitorSpec and returns MEGAFORCE if it has changed.
 */
monitorCheck()
{
    struct IntuitionBase *IBase = fetchIBase();
    struct Screen *screen;
    struct MonitorSpec *oldmspec;

    assertLock("monitorCheck", IBASELOCK );

    if ( !(screen =  IBase->FirstScreen) )
    {
	/* defaultest mode	*/
	IBase->ActiveMonitorSpec = NULL;
	return( 0 );
    }

    /* else	*/
    oldmspec = IBase->ActiveMonitorSpec;

    DSNOOP( if ( XSC(screen)->NaturalMSpec != oldmspec )
	printf("monitorCheck hit %lx/%lx\n",
	XSC(screen)->NaturalMSpec, oldmspec));
     /* Peter 8-Aug-90: Now return MEGAFORCE if FirstScreen is SCREENHIDDEN.
      * We need this to allow the user to pop an excluded screen to the front.
      */
    if ( ( (IBase->ActiveMonitorSpec = XSC(screen)->NaturalMSpec)!=oldmspec) ||
       (screen->Flags & SCREENHIDDEN) )
	return ( MEGAFORCE );
    /* else */
	return ( NOFORCE );
}


remakeCopList()
{
    struct IntuitionBase *IBase = fetchIBase();
    struct cprlist *LOFSave, *SHFSave;
    BOOL	valid_cop_lists;

    assertLock("remakeCopList", VIEWLOCK);
    assertLock("remakeCopList", VIEWCPRLOCK);

    /* first, save the pointers to the current copper lists */
    LOFSave = IBase->ViewLord.LOFCprList;
    SHFSave = IBase->ViewLord.SHFCprList;

    /* now zero out the pointers so that the next call to MrgCop() will
     * cause brand-new copper lists to be allocated and initialized
     */
    IBase->ViewLord.LOFCprList = NULL;
    IBase->ViewLord.SHFCprList = NULL;
    /* Peter 15-Nov-90: MrgCop() now returns NULL for success */
    if ( !MrgCop(&IBase->ViewLord) )
    {
	/* call LoadView() to create the display with these new copper lists */
	LoadView(&IBase->ViewLord);
	valid_cop_lists = TRUE;
	/* When the active monitor changes, graphics needs a chance
	 * to smell the sprite.  So calling updateMousePointer()
	 * here will cause MoveSprite() to happen.
	 */
	updateMousePointer( IBase->SimpleSprite );
    }
    else
    {
	/* mrgcop failure -- bart */
	LoadView(NULL);
	valid_cop_lists = FALSE;
    }

#if WAITTOF_OPTIMIZE
    /* Up until 3.00, we used to do a WaitTOF() here, then call FreeCprList()
     * on the LOFSave and SHFSave saved copper list pointers.  However,
     * we take an optimization that depends on GfxBase maintaining a VBlank
     * counter.  the idea is that in place of WaitTOF()/FreeXXX(), we send
     * ourselves a token (reminder) to FreeXXX after the VBlank counter has
     * had a chance to change, thus taking a WaitTOF() clean out of
     * RethinkDisplay() and friends.
     */
    sendISMNoQuick( itFREECPRLIST, LOFSave, SHFSave,
	IBase->GfxBase->VBCounter );
#else
    /* wait to the top of the frame to make sure that the old lists are
     * for sure no longer being displayed
     */
    WaitTOF();

    /* now, feel through the old copper list structures, freeing the memory */
    FreeCprList(LOFSave);
    FreeCprList(SHFSave);
#endif

    /* Peter 15-Nov-90: We couldn't get the copper lists the first time,
     * so retry now that the old ones are freed */
    if ( ( !valid_cop_lists ) && ( !MrgCop(&IBase->ViewLord) ) )
    {
	/* call LoadView() to create the display with these new copper lists */
	LoadView(&IBase->ViewLord);
	valid_cop_lists = TRUE;

	/* When the active monitor changes, graphics needs a chance
	 * to smell the sprite.  So calling updateMousePointer()
	 * here will cause MoveSprite() to happen.
	 */
	updateMousePointer( IBase->SimpleSprite );
    }

    if ( valid_cop_lists )
    {
	/* ZZZ: We could get away with a single updateMousePointer()
	 * in here, instead of the two above, except for the bug in which the
	 * mouse disappears if it's one scan line above the screen.
	 */

	/* According to jimm, this is needed for the very first
	 * time the display is turned on.
	 */
	ON_DISPLAY;
	ON_SPRITE;
    }
    else
    {
	IBase->ViewFailure = 1;
    }
}

@


38.34
log
@CalcISG can now not assert a minimum of 6 interlaced lines.
@
text
@d5 1
a5 1
 *  $Id: view.c,v 38.33 93/01/14 14:27:48 peter Exp Locker: peter $
d274 2
a275 2
	    if ( ( embedded_bm->Depth != sc->RastPort.BitMap->Depth ) ||
		( sc->RastPort.BitMap->Planes[ plane ] != embedded_bm->Planes[ plane ] ) )
@


38.33
log
@Now handle viewports with the skipped intermediate copperlist stuff.
@
text
@d5 1
a5 1
 *  $Id: view.c,v 38.32 93/01/12 16:21:43 peter Exp Locker: peter $
d101 1
d103 1
a103 2
    return( imax( INTERSCREENLINES * IBase->MouseScaleY,
	CalcIVG( &IBase->ViewLord, &sc->ViewPort ) * XSC(sc)->ScaleFactor.Y ) );
d105 5
@


38.32
log
@Deleted unused comment.
@
text
@d5 1
a5 1
 *  $Id: view.c,v 38.31 92/12/04 11:58:30 peter Exp Locker: peter $
d12 9
d526 7
d552 1
a552 1
		if ( (force != NOFORCE) ||
d554 2
a555 1
		    TESTFLAG( XSC(sc)->PrivateFlags, PSF_REMAKEVPORT ) )
@


38.31
log
@IsHires() and canSlide() moved to scsupp.c.
@
text
@d5 1
a5 1
 *  $Id: view.c,v 38.30 92/11/25 15:42:14 peter Exp Locker: peter $
a76 1
/* #define INTERSCREENGAP	(6 * (MOUSESCALEY)) */
@


38.30
log
@Eliminated unneeded test for MakeVPort().  Elaborated comments about
off-the-bottom ViewPorts.  Now handle coercion's requests to sync
up VP coordinates.
@
text
@d5 1
a5 1
 *  $Id: view.c,v 38.29 92/11/20 18:33:40 peter Exp Locker: peter $
a81 26

/* Returns TRUE if a screen can slide.
 *
 * A screen cannot slide if it does not have the DIPF_IS_DRAGGABLE
 * graphics database property.
 *
 * A screen cannot slide if is made non-draggable through the use
 * of the {SA_Draggable,FALSE} attribute.  This particular decision
 * can be overridden with the override parameter.
 *
 * This override is set when a programmer calls ScreenPosition() with
 * the SPOS_FORCEDRAG option.  The override is also set when Intuition
 * moves a child screen due to the parent moving.
 */
LONG canSlide( s, override )
struct Screen *s;
{
    return( TESTFLAG( XSC(s)->DProperties, DIPF_IS_DRAGGABLE ) &&
	( TESTFLAG( XSC(s)->PrivateFlags, PSF_DRAGGABLE ) || ( override ) ) );
}

BOOL IsHires(s)
struct Screen *s;
{
    return (s->Flags & SCREENHIRES);
}
@


38.29
log
@canSlide() now takes an override parameter instead of trying to
second-guess things.
@
text
@d5 1
a5 1
 *  $Id: view.c,v 38.28 92/11/10 17:11:43 peter Exp Locker: peter $
d452 7
a458 4
	/* only reset screen vp position under drastic
	 * circumstances, which are:
	 * -change in scan rate (monitorspec)
	 * -change in global lace (nope, turned that off)
d460 2
a461 1
	if ( force == MEGAFORCE )
d480 1
a480 1
	    if ( deltop || delleft )
d498 2
d530 12
a541 5
		/* remake if size changed, making all, or just
		 * now becoming visible
		 * Technique is to set PSF_REMAKEVPORT when you
		 * change something in a screen that requires
		 * new copper lists.  So, ALWAYS remake the
d543 12
d557 2
a558 1
		/* This ViewPort is supposed to be visible.  The only
a564 3
		    ( (force == MEGAFORCE)  &&
			(vport->DxOffset != sc->LeftEdge ||
			 vport->DyOffset != sc->TopEdge ) ) ||
@


38.28
log
@Added (compiled-out) code to implement VBlank optimization.
@
text
@d5 1
a5 1
 *  $Id: view.c,v 38.27 92/08/24 11:41:56 peter Exp Locker: peter $
d85 2
a86 2
 * A screen cannot slide if the graphics-database says so
 * (DIPF_IS_DRAGGABLE).
d88 3
a90 4
 * Child screens made non-draggable with {SA_Draggable,FALSE}
 * actually are non-draggable with respect to the parent,
 * so they do slide, hence we return TRUE and worry about their
 * limits elsewhere.
d92 3
a94 9
 * A non-child screen which is made non-draggable through
 * {SA_Draggable,FALSE} cannot slide.
 *
 * The ScreenPosition() call does allow the owner of a screen
 * which was made non-draggable through {SA_Draggable, FALSE}
 * to nevertheless move the screen.  During the processing of
 * such a call, PSF_DRAGOVERRIDE will be set so that we can
 * report that the screen can slide.
 *
d96 1
a96 1
BOOL CanSlide( s )
d99 2
a100 3
    return ( TESTFLAG( XSC(s)->DProperties, DIPF_IS_DRAGGABLE ) &&
	( TESTFLAG( XSC(s)->PrivateFlags, PSF_DRAGGABLE|PSF_DRAGOVERRIDE ) ||
		( XSC(s)->ParentScreen ) ) );
@


38.27
log
@Now detect bitmap depth-pokers.  Also, detection happens in both
MakeScreen() and RethinkDisplay().
@
text
@a0 1

d5 1
a5 1
 *  $Id: view.c,v 38.26 92/08/18 10:14:17 peter Exp Locker: peter $
d12 8
a377 1

d703 1
a703 1
    /* this "screen visibilty loop" is from rethinkVPorts,
d810 12
d830 1
@


38.26
log
@Minor comment/style cleanup around Mike's fix.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.25 92/08/14 14:55:48 mks Exp Locker: peter $
d193 6
d246 59
d436 4
a439 31
	/* Disney Animation Studio changes the bitplane pointers in
	 * the screen->sc_BitMap, then calls ScrollVPort() and
	 * RethinkDisplay().  Under V37 and prior, this worked since
	 * the ViewPort.RasInfo->BitMap pointed at screen->sc_BitMap.
	 * ScrollVPort() remade the copper lists from the bitplane
	 * pointers.
	 *
	 * Under V39, the RasInfo->BitMap is the RealBitMap we got
	 * from AllocBitMap().  Poking sc_BitMap thus has no effect.
	 * To keep Mickey smiling, we look for changes to the sc_BitMap
	 * planes at RethinkDisplay() time.  If we find any, then we
	 * do a one-time one-way switch to using the embedded sc_BitMap
	 * instead of the RealBitMap.  From that point on, they work
	 * just like V37.  To get the first frame to come out right,
	 * we note that we must remake the ViewPort.
	 *
	 * MKS 14-Aug-92:  Now only check the valid plane pointers up
	 * to the bitmap's depth.  Also, the test is only done if the
	 * RasInfo BitMap itself was not poked.  Some double-buffering
	 * programs do that, and we don't want to break them.
	 *
	 * Note that one last case is not handled by this:
	 * Someone poking the plane pointers of the RasInfo->BitMap.
	 * So far no one has been shown to have done this.  My feeling
	 * is that it is not important since most likely they would have
	 * poked the whole bitmap rather than just the plane pointers
	 * since it is easier to poke just the bitmap.
	 * We check against the hidden screen layer rastport bitmap
	 * since the screen rastport bitmap may have been changed
	 * at the same time as the RasInfo bitmap was (for rendering
	 * reasons)
d441 1
a441 19
	if (XSC(sc)->ClipLayer->rp->BitMap == sc->ViewPort.RasInfo->BitMap)
	{
	    int plane;
	    struct BitMap *embedded_bm = &sc->sc_BitMap;

	    for ( plane = 0; plane < embedded_bm->Depth ; plane++ )
	    {
		if ( sc->RastPort.BitMap->Planes[ plane ] != embedded_bm->Planes[ plane ] )
		{
		    /* Found a bitmap plane poker (eg. Disney Animator) */
		    SETFLAG( XSC(sc)->PrivateFlags, PSF_REMAKEVPORT );
		    sc->RastPort.BitMap = embedded_bm;
		    sc->ViewPort.RasInfo->BitMap = embedded_bm;
		    XSC(sc)->ClipLayer->rp->BitMap = embedded_bm;
		    sc->BarLayer->rp->BitMap = embedded_bm;
		    break;
		}
	    }
	}
@


38.25
log
@Well, did the final changes needed to get this double buffering
method sniffing to work.  It handles the two methods that I believe
may be used.  This should fix both Disney and RoboCity at the same
time.  (See line 390- for more information on the fix.)
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.24 92/08/13 11:08:34 mks Exp Locker: mks $
d386 6
a391 12
	 */

	/* Fixed by MKS 8/14/92
	 * Well, the original fix was invalid since it checked all
	 * of the plane pointers and not just the Depth plane pointers.
	 * This means that the garbage plane pointers were being looked
	 * at when they should not have been and it caused intuition to
	 * think that we had a bitmap poker when it was not the case.
	 * The new code now does just the depth of the bitmap.
	 * In addition, it also checks this if the RasInfo bitmap
	 * was poked and if so, does not do the screen bitmap poke
	 * test since it would show the wrong results.
d395 1
a395 1
	 * is that it is not important since mostlikely they would have
d405 2
a406 2
	int plane;
	struct BitMap *embedded_bm = &sc->sc_BitMap;
d408 3
a410 1
		for ( plane = 0; plane < embedded_bm->Depth ; plane++ )
d412 7
a418 10
			if ( sc->RastPort.BitMap->Planes[ plane ] != embedded_bm->Planes[ plane ] )
			{
				/* Found a bitmap plane poker (eg. Disney Animator) */
				SETFLAG( XSC(sc)->PrivateFlags, PSF_REMAKEVPORT );
				sc->RastPort.BitMap = embedded_bm;
				sc->ViewPort.RasInfo->BitMap = embedded_bm;
				XSC(sc)->ClipLayer->rp->BitMap = embedded_bm;
				sc->BarLayer->rp->BitMap = embedded_bm;
				break;
			}
d420 1
@


38.24
log
@Backed out fix for Disney Animation Studio until more investigation can
be done as to why this fix can not be done as is (it breaks RoboCity
and anything that does things like RoboCity does)
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.23 92/08/06 09:47:36 peter Exp Locker: mks $
a370 5
/*
 * Well, it looks like this broke RoboCity...
 * Still investigating what/why/etc.  Will check out later  -- MKS
 */
#if	0
d387 24
d412 15
a426 13
	for ( plane = 0; plane < 8; plane++ )
	{
	    struct BitMap *embedded_bm = &sc->sc_BitMap;
	    if ( sc->RastPort.BitMap->Planes[ plane ] != embedded_bm->Planes[ plane ] )
	    {
		/* Found a bitmap plane poker (eg. Disney Animator) */
		SETFLAG( XSC(sc)->PrivateFlags, PSF_REMAKEVPORT );
		sc->RastPort.BitMap = embedded_bm;
		sc->ViewPort.RasInfo->BitMap = embedded_bm;
		XSC(sc)->ClipLayer->rp->BitMap = embedded_bm;
		sc->BarLayer->rp->BitMap = embedded_bm;
		break;
	    }
a427 2
#endif

@


38.23
log
@Now detect and fix people who poke their bitmap planes (Disney Animator).
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.22 92/08/03 15:56:12 peter Exp Locker: peter $
d123 1
a123 1
	
d200 1
a200 1
     * setScreenDisplayID(), because the mapping of the default 
d371 5
d407 1
d449 1
a449 1
			    
d507 1
a507 1
		    ( vport->DHeight != vpheight ) || 
d558 1
a558 1
    /* won't wrongly free up mouse if INMOUSELIMITS is set, 
d678 1
a678 1
	{ 
d685 1
a685 1
		needlace |= XSC(sc)->DProperties & DIPF_IS_LACE;    
@


38.22
log
@Changed some comments.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.21 92/07/28 15:14:23 peter Exp Locker: peter $
d371 33
@


38.21
log
@Fixed use of ACTIVIEWCPR lock.  Now blank ViewPort if MakeVPort() fails.
MakeScreen(), RethinkDisplay(), and RemakeDisplay() now return non-zero
if failure occurs.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.20 92/06/22 13:04:10 peter Exp Locker: peter $
d218 3
a220 8
#if !AA_KLUDGES
	/* Peter 29-May-92: temporarily dropped this stuff because
	 * it interferes with promotion.  What we really want to do
	 * is something like this:
	 * If we got here because of changes to the stashed ViewModes,
	 * then we want to get an OSCAN_TEXT dclip.  If we got here
	 * on account of promotion, then we want to not change the
	 * DClip at all.
d222 4
a225 2
	 * Also, I believe the rectHull() below may be wrong for
	 * oversized screens
a226 8
	/* setup new display clip region */
	/* (assume default dclip rules) */
	displayOScan( XSC(screen)->NaturalDRecord, NULL,
		OSCAN_TEXT, &XSC(screen)->DClip );
	boxToRect( &screen->LeftEdge, &screenrect );
	rectHull( &XSC(screen)->DClip, &screenrect );
	DSNOOP( dumpRect("new DClip (before coercion)", &XSC(screen)->DClip ) );
#endif
@


38.20
log
@Any hidden viewport now has PSF_REMAKEVPORT set, so we're sure to
remake when its becomes visible again.  updateMousePointer() is now
called with the current mouse pointer (instead of NULL), so that the
sprite speed/height can be recalculated.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.19 92/06/03 17:41:35 peter Exp Locker: peter $
d143 1
a150 1
    LOCKVIEWCPR();
d159 2
d167 2
a178 1
    UNLOCKVIEWCPR();
d181 1
d257 2
d265 2
d288 2
d295 1
d303 3
d307 2
d310 1
d317 1
d322 2
d325 2
d328 2
d348 1
d356 1
d435 5
d443 2
a444 2
	/* incompatibility hides screens	*/
	if ( TESTFLAG( sc->Flags, SCREENHIDDEN ) )
a445 13
	    /* only top screen visible in hedley display,
	     * and hedley screen only visible when 
	     * frontmost.  Thus, we are hidden on account
	     * of a monitor-incompatibility.  Next time we re-appear,
	     * we certainly want to remake the viewports.
	     */
	    SETFLAG( vport->Modes, VP_HIDE );
	    SETFLAG( XSC(sc)->PrivateFlags, PSF_REMAKEVPORT );

	    DVP( printf("rVP: excluding screen: %lx\n", sc ) );
	}
	else
	{ 
d472 6
d488 6
a493 1
		    MakeVPort( &IBase->ViewLord, vport );
d495 5
d501 5
a505 3
		/* screen visible */
		CLEARFLAG( vport->Modes, VP_HIDE );
		CLEARFLAG( XSC(sc)->PrivateFlags, PSF_REMAKEVPORT );
d507 20
a526 18
		/* CalcISG() is an Intuition function to figure out the
		 * interscreen-gap, given a screen.  It returns an
		 * answer in ticks based on graphics.library CalcIVG().
		 */
		alltop = sctop - CalcISG( sc );
		DVP( printf(" last screentop: %ld\n", sctop ) );
		DVP( printf(" alltop now left at: %ld\n", alltop ) );
	    }
	    else
	    {
		/* Hidden on account of viewport coordinates
		 * out of range.  Next time we find that the
		 * screen is in range, we will want to remake
		 * the viewports, though.
		 */
		SETFLAG( vport->Modes, VP_HIDE );
		SETFLAG( XSC(sc)->PrivateFlags, PSF_REMAKEVPORT );
	    }
d578 1
d712 2
a713 2
    LOCKVIEW();
    LOCKVIEWCPR();
d780 4
a783 5

    UNLOCKVIEWCPR();
    UNLOCKVIEW();

    return( valid_cop_lists );
@


38.19
log
@Now call VIEWCPRLOCK.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.18 92/05/29 18:57:23 peter Exp Locker: peter $
d143 2
d171 1
a171 1
	updateMousePointer( NULL );
d418 2
a419 1
	     * of a monitor-incompatibility
d421 3
a423 1
	    vport->Modes |= VP_HIDE;
d482 3
a484 1
		 * out of range.
d486 2
a487 1
		vport->Modes |= VP_HIDE;
d513 1
a513 1
     * So we don't do this here no more:
d692 1
a692 1
	 * to smell the sprite.  So calling updateMousePointer(NULL)
d695 1
a695 1
	updateMousePointer( NULL );
d722 1
a722 1
	 * to smell the sprite.  So calling updateMousePointer(NULL)
d725 1
a725 1
	updateMousePointer( NULL );
d730 1
a730 1
	/* ZZZ: We could get away with a single updateMousePointer(TRUE)
@


38.18
log
@modeSnoop() no longer re-figures the DClip.  This had to be removed,
at least temporarily, for promotion.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.17 92/05/29 18:30:17 peter Exp Locker: peter $
d148 1
d173 1
d255 1
d279 1
d666 1
d734 1
@


38.17
log
@The modeSnoop() and setScreenDisplayID() functions now take a force
parameter which is used for promotion.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.16 92/05/15 14:11:04 peter Exp Locker: peter $
d210 12
d229 1
a229 1

@


38.16
log
@Gfx guys changed their minds.  They now want to use VPExtra->Flags to
denote the last viewport.  Now use PSF_REMAKEVPORT in place of private
use of VP_HIDE.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.15 92/05/05 13:31:42 peter Exp Locker: peter $
d149 1
a149 1
    modeSnoop( screen );	/* check to see if he's poked his modes */
d179 1
a179 1
modeSnoop( screen )
d183 1
d185 16
a200 2
    if ( (newdisplayid = screen->ViewPort.Modes & OLD_MODES ) !=
	XSC(screen)->VPModeStash )
d208 1
a208 1
	setScreenDisplayID( screen, newdisplayid, NULL );
d212 1
a212 1
	displayOScan( NULL, XSC(screen)->NaturalDisplayID,
a217 5
	/* Now figure out what the screen's mode would be if
	 * promotion is in effect, and this screen's frontmost
	 */
	promoteScreen( screen );

d248 9
a256 2
	    promoteScreen( s );
	    modeSnoop( s );
d629 1
a629 1
    DSNOOP( if ( XSC(screen)->PromotedMSpec != oldmspec )
d631 1
a631 1
	XSC(screen)->PromotedMSpec, oldmspec));
d635 1
a635 1
    if ( ( (IBase->ActiveMonitorSpec = XSC(screen)->PromotedMSpec)!=oldmspec) ||
@


38.15
log
@Now set VP_LAST in the bottom-most viewport, for spence.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.14 92/04/07 18:00:47 peter Exp Locker: peter $
d152 1
a152 1
    SETFLAG( screen->ViewPort.Modes, VP_HIDE );
d279 2
a280 2
#ifndef VP_LAST
#define VP_LAST	0x0200
d326 1
a326 1
	vport->Modes &= ~VP_LAST;
d329 1
a329 1
	    vport->Modes |= VP_LAST;
d382 2
a383 1
	     * frontmost
d411 1
a411 1
		 * WARNING: technique is to set VP_HIDE when you
d414 1
a414 1
		 * VP_HIDE guys.
d417 1
a417 1
		    vport->DHeight != vpheight || 
d420 2
a421 2
			 vport->DyOffset != sc->TopEdge )) ||
		    TESTFLAG( vport->Modes, VP_HIDE ))	/* see above!! */
d431 1
d443 3
@


38.14
log
@Calls updateMousePointer() with NULL or with IBase->SimpleSprite.
Minor fix for SAS test-compile.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.13 92/04/02 12:09:07 peter Exp Locker: peter $
d279 4
d322 9
@


38.13
log
@Renamed reportMouse() to updateMousePointer().  Renamed setMouse() to
setMousePointer(), and it no longer takes a window parameter.  Evicted
autodocs.  No longer includes gfxbase.h.  rethinkVPorts() calls
setSpriteSpeed().
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.12 92/03/26 16:40:58 peter Exp Locker: peter $
a142 2
    struct IntuitionBase *IBase = fetchIBase();

d168 1
a168 1
	updateMousePointer( FALSE );
a187 1
	struct Rectangle	oscanrect;
a225 2
    struct View *View;
    struct ViewPort *VPort;
d456 1
a456 1
     * updateMousePointer(FALSE);
d631 3
a633 4
	/* Peter 13-Oct-90:
	 * We need to cause ChangeSprite() when entering or leaving
	 * Hedley mode.  There's no easy way to tell when we're leaving,
	 * so call updateMousePointer( TRUE ) always.
d635 1
a635 1
	updateMousePointer( TRUE );
d661 3
a663 4
	/* Peter 13-Oct-90:
	 * We need to cause ChangeSprite() when entering or leaving
	 * Hedley mode.  There's no easy way to tell when we're leaving,
	 * so call updateMousePointer( TRUE ) always.
d665 1
a665 1
	updateMousePointer( TRUE );
@


38.12
log
@Fixed typo.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.11 92/03/23 11:55:36 peter Exp Locker: peter $
a42 4
#ifndef GRAPHICS_GFXBASE_H
#include <graphics/gfxbase.h>
#endif

d127 2
a128 44
/****** intuition.library/MakeScreen ****************************************
*
*    NAME
*	MakeScreen -- Do an Intuition-integrated MakeVPort() of a screen.
*
*    SYNOPSIS
*	MakeScreen( Screen )
*		    A0
*
*	VOID MakeScreen( struct Screen * );
*
*    FUNCTION
*	This procedure allows you to do a MakeVPort() for the viewport of your
*	custom screen in an Intuition-integrated way.  This way you can
*	do your own screen manipulations without worrying about interference
*	with Intuition's usage of the same viewport.
*
*	The operation of this function is as follows:
*	    - Block until the Intuition View structure is not in being changed.
*	    - Set the view modes correctly to reflect if there is a (visible)
*	      interlaced screen.
*	    - call MakeVPort(), passing the Intuition View and your screen's
*	      ViewPort.
*	    - Unlocks the Intuition View.
*
*	After calling this routine, you should call RethinkDisplay() to 
*	incorporate the new viewport of your custom screen into the 
*	Intuition display.
*
*	NOTE: Intuition may determine that because of a change in global
*	interlace needs that all viewports need to be remade, so
*	it may effectively call RemakeDisplay().
*
*    INPUTS
*	Screen = address of the custom screen structure
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	RethinkDisplay(), RemakeDisplay(), graphics.library/MakeVPort()
*****************************************************************************/
d166 1
a166 1
	 * reportMouse() no longer happens inside rethinkVPorts(), so
d170 1
a170 1
	reportMouse( FALSE );
d224 2
a225 37
/****** intuition.library/RemakeDisplay *************************************
*
*    NAME
*	RemakeDisplay -- Remake the entire Intuition display.
*
*    SYNOPSIS
*	RemakeDisplay()
*
*	VOID RemakeDisplay( VOID );
*
*    FUNCTION
*	This is the big one.
*
*	This procedure remakes the entire View structure for the 
*	Intuition display.  It does the equivalent of MakeScreen() for
*	every screen in the system, and then it calls the internal
*	equivalent of RethinkDisplay().
*   
*	WARNING:  This routine can take many milliseconds to run, so
*	do not use it lightly. 
*
*	Calling MakeScreen() followed by RethinkDisplay() is typically
*	a more efficient method for affecting changes to a single
*	screen's ViewPort.
*
*    INPUTS
*	None
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	MakeScreen(), RethinkDisplay(), graphics.library/MakeVPort()
*	graphics.library/MrgCop(), graphics.library/LoadView()
*****************************************************************************/
d258 2
a259 61
/****** intuition.library/RethinkDisplay ************************************
*
*    NAME
*	RethinkDisplay -- Grand manipulation of the entire Intuition display.
*
*    SYNOPSIS
*	RethinkDisplay()
*
*	VOID RethinkDisplay( VOID );
*
*    FUNCTION
*	This function performs the Intuition global display reconstruction.
*	This includes rethinking about all of the  ViewPorts and their
*	relationship to one another and reconstructing the entire display
*	based on the results of this rethinking.
*
*	Specifically, and omitting many internal details, the operation
*	consists of this:
*
*	    Determine which ViewPorts are invisible and set their VP_HIDE
*	    ViewPort Mode flag. VP_HIDE flags are also set for screens that
*	    may not be simultaneously displayed with the frontmost (V36).
*
*	    If a change to a viewport height, or changing interlace or
*	    monitor scan rates require, MakeVPort() is called for specific
*	    screen viewports.  After this phase, the intermediate Copper lists
*	    for each screen's viewport are correctly set up. 
*
*	    MrgCop() and LoadView() are then called to get these Copper lists
*	    in action, thus establishing the new state of the Intuition
*	    display.
*   
*	You may perform a MakeScreen() on your Custom Screen before calling
*	this routine.  The results will be incorporated in the new display, but
*	changing the INTERLACE ViewPort mode for one screens must be reflected
*	in the Intuition View, which is left to Intuition.
*
*	WARNING:  This routine can take several milliseconds to run, so
*	do not use it lightly. 
*
*	New for V36: This routine is substantially changed to support
*	new screen modes.  In particular, if screen rearrangement has
*	caused a change in interlace mode or scan rate, this routine
*	will remake the copper lists for each screen's viewport.
*
*    INPUTS
*	None
*
*    RESULT
*	None
*
*    BUGS
*	In V35 and earlier, an interlaced screen coming to the front
*	may not trigger a complete remake as required when the global
*	interlace state is changed.  In some cases, this can be compensated
*	for by setting the viewport DHeight field to 0 for hidden screens.
*
*    SEE ALSO
*	RemakeDisplay(), graphics.library/MakeVPort(), graphics.library/MrgCop(),
*	graphics.library/LoadView(), MakeScreen()
*****************************************************************************/
d416 1
d446 4
a449 4
     * displayed copper lists.  In such cases, remakeCopLists() is
     * imminent, and that'll fix everything up.  In fact, remakeCopLists()
     * will cause reportMouse() to happen anyways.
     * We used to call reportMouse() here, but that would cause the
d451 1
a451 1
     * reportMouse(), either through remakeCopLists() or directly.
d453 1
a453 1
     *     MakeScreen() - needs its own reportMouse()
d461 1
a461 1
     * reportMouse(FALSE);
d637 3
a639 2
	 * We need to call setMouse() when entering or leaving Hedley mode.
	 * There's no easy way to tell when we're leaving, so call it always.
d641 1
a641 1
	setMouse( IBase->ActiveWindow );
d668 3
a670 2
	 * We need to call setMouse() when entering or leaving Hedley mode.
	 * There's no easy way to tell when we're leaving, so call it always.
d672 1
a672 1
	setMouse( IBase->ActiveWindow );
d677 2
a678 2
	/* ZZZ: We could get away with a single setMouse() in here,
	 * instead of the two above, except for the bug in which the
@


38.11
log
@Renamed IsDraggable() to CanSlide().  CanSlide() now recognizes
PSF_DRAGOVERRIDE to make a non-draggable screen draggable.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.10 92/03/18 11:51:52 peter Exp Locker: peter $
d93 1
a93 1
 * The ScreenPosition() call does allow the owern of a screen
@


38.10
log
@IsDraggable() now considers child screens that are marked as non-draggable
to be draggable.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.9 92/03/03 16:36:44 peter Exp Locker: peter $
d80 1
a80 4
/* Returns if a screen is draggable.
 * A screen is considered non-draggable if the graphics-database says
 * so (DIPF_IS_DRAGGABLE), or if it is made non-draggable through
 * {SA_Draggable,FALSE} and is not a child screen.
d82 17
a98 3
 * Child screens made non-draggable actually are non-draggable
 * with respect to the parent, so they do slide, hence we call
 * them draggable here and worry about their limits elsewhere.
d100 1
a100 1
BOOL IsDraggable( s )
d104 1
a104 1
	( TESTFLAG( XSC(s)->PrivateFlags, PSF_DRAGGABLE ) ||
@


38.9
log
@Added newMakeScreen() which can run quicker in certain cases.  Renamed
private screen flags.  Renamed SCREENEXCLUDE to SCREENHIDDEN.  Removed
IsCompatible() since it only had one caller.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.8 92/02/05 15:40:06 peter Exp Locker: peter $
d80 9
d93 2
a94 1
	TESTFLAG( XSC(s)->PrivateFlags, PSF_DRAGGABLE ) );
@


38.8
log
@Deleted unused #define.  Changed when reportMouse() is called, to
eliminate certain sprite-jumping during mode-switches.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.7 91/12/12 20:45:17 peter Exp Locker: peter $
d84 1
a84 1
	!TESTFLAG( XSC(s)->PrivateFlags, PRIVSCF_NODRAG ) );
a86 6
BOOL IsCompatible( s )
struct Screen *s;
{
    return (!(s->Flags & SCREENEXCLUDE));
}

d157 11
d181 1
a181 2
    DVP( printf("MakeScreen calling modeVerify\n") );
    if ( !modeVerify( NOFORCE) )
d183 6
a188 3
	DVP( printf("MakeScreen calling rVP\n") );
	rethinkVPorts( NOFORCE );
    }
d190 6
a195 6
    /* Peter 4-Feb-91:
     * reportMouse() no longer happens inside rethinkVPorts(), so
     * we've got to do our own.  See the comment at the end of
     * rethinkVPorts() for a discussion as to why.
     */
    reportMouse( FALSE );
d197 1
d489 1
a489 1
	if ( TESTFLAG( sc->Flags, SCREENEXCLUDE ) )
d670 1
a670 1
	if ( TESTFLAG( sc->Flags, SCREENEXCLUDE ) )
d720 1
a720 1
     /* Peter 8-Aug-90: Now return MEGAFORCE if FirstScreen is SCREENEXCLUDE.
d724 1
a724 1
       (screen->Flags & SCREENEXCLUDE) )
@


38.7
log
@monitorCheck() now examines PromotedMSpec instead of NaturalMSpec, in order
to handle mode promotion.  RemakeDisplay() calls promoteScreen() for each
screen.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.6 91/11/25 16:56:25 peter Exp Locker: peter $
a17 1
#define DSCAN(x) 	;	/* double scan		*/
d183 7
d553 21
a573 1
    reportMouse(FALSE);
@


38.6
log
@Fixed bug where ViewPort offsets were only being set up when the
ViewPort was visible and MEGAFORCE was in effect.  Caused problems
with scaling DClips, where VP offsets need poking even if VP is
invisible.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.5 91/11/15 18:55:05 peter Exp Locker: peter $
d217 5
d289 1
d683 1
a683 1
    DSNOOP( if ( XSC(screen)->NaturalMSpec != oldmspec )
d685 1
a685 1
	XSC(screen)->NaturalMSpec, oldmspec));
d689 1
a689 1
    if ( ( (IBase->ActiveMonitorSpec = XSC(screen)->NaturalMSpec)!=oldmspec) ||
@


38.5
log
@rethinkVPorts() and modeSnoop() now call coerceScreens() with FORCE.
modeVerify() now calls setupMonitor() with appropriate FORCE.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.4 91/09/23 12:29:52 peter Exp Locker: peter $
d421 44
a467 3

	vport = &sc->ViewPort;

a512 42
		    /* only reset screen vp position under drastic
		     * circumstances, which are:
		     * -change in scan rate (monitorspec)
		     * -change in global lace (nope, turned that off)
		     */
		    if ( force == MEGAFORCE )
		    {
			XSC(sc)->VPOffsetStash.X =
				vport->DxOffset = sc->LeftEdge;
			XSC(sc)->VPOffsetStash.Y =
				vport->DyOffset = sc->TopEdge;
		    }
#if DPAINT_BACK_SYNC
		    else
		    {
			WORD	delleft;
			WORD	deltop;

			/* move the screen and the DClip to match VP	*/
			delleft =  vport->DxOffset - XSC(sc)->VPOffsetStash.X;
			deltop = vport->DyOffset - XSC(sc)->VPOffsetStash.Y;

			DDP( printf( "delleft/top %ld %ld\n", delleft, deltop));

			if ( deltop || delleft )
			{
			    DDP( printf("detect vp poke of %ld, %ld\n",
				delleft, deltop ) );
				    
			    /* sync up	*/
			    XSC(sc)->VPOffsetStash.X =
				sc->LeftEdge = vport->DxOffset;
			    XSC(sc)->VPOffsetStash.Y =
				sc->TopEdge = vport->DyOffset;

			    /* translate dclip to shadow vp poke	*/
			    offsetRect( &XSC(sc)->DClip, delleft, deltop );
			    coerceScreens( sc, FORCE );
			}
		    }
#endif

@


38.4
log
@Modified since CalcIVG() now returns result in ViewPort lines.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.3 91/08/21 18:21:50 peter Exp Locker: peter $
d218 1
a218 1
	coerceScreens( screen, NOFORCE );
d509 1
a509 1
			    coerceScreens( sc, NOFORCE );
d578 9
d588 1
a588 1
	setupMonitor( megaforce );
@


38.3
log
@If a screen has PRIVSCF_NODRAG set, it's not draggable.
Removed code to manage graphics.library < V38.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.2 91/07/25 16:38:25 peter Exp Locker: peter $
d103 1
a103 1
 * Returns the answer in interlaced lines.
d106 2
a107 2
WORD CalcISG( vport )
struct ViewPort *vport;
d111 3
a113 1
    return( imax( INTERSCREENLINES, 2*CalcIVG( &IBase->ViewLord, vport ) ) );
d523 2
a524 2
		 * interscreen-gap, given a ViewPort.  It returns an
		 * answer based on graphics.library CalcIVG()
d526 1
a526 1
		alltop = sctop - CalcISG( vport ) * IBase->MouseScaleY;
d635 1
a635 1
		alltop = sctop - CalcISG( &sc->ViewPort ) * IBase->MouseScaleY;
@


38.2
log
@Fixed CalcISG() to return no less than six, instead of no more than six.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.1 91/07/25 15:05:05 peter Exp $
d84 2
a85 1
    return ( TESTFLAG( XSC(s)->DProperties, DIPF_IS_DRAGGABLE ) );
d102 2
a103 2
 * traditional INTERSCREENLINES.
 * Returns the answer in interlaced lines
a110 7
#if AA_KLUDGES
    /* KLUDGE: Handle graphics < V38 */
    if ( IBase->GfxBase->LibNode.lib_Version < 38 )
    {
	return( INTERSCREENLINES );
    }
#endif
@


38.1
log
@Now uses CalcIVG() to figure the inter-screen gap when running under V38.
Contains an AA_KLUDGE to handle V37 graphics.
@
text
@d6 1
a6 1
 *  $Id: view.c,v 38.0 91/06/12 14:34:57 peter Exp Locker: peter $
d117 1
a117 2

    return( imin( INTERSCREENLINES, 2*CalcIVG( &IBase->ViewLord, vport ) ) );
@


38.0
log
@Initial V38 check-in (matches V37 release).
@
text
@d6 1
a6 1
 *  $Id: view.c,v 1.38 91/02/12 18:22:01 peter Exp $
d99 21
d121 1
d527 5
a531 1
		alltop = sctop - INTERSCREENLINES * IBase->MouseScaleY;
d640 1
a640 1
		alltop = sctop - INTERSCREENLINES * IBase->MouseScaleY;
@
