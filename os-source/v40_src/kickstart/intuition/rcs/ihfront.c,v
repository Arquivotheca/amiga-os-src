head     38.13;
branch   ;
access   ;
symbols  V40_85:38.13 V40_71:38.13 V40_68:38.13 V40_65:38.13 V40_47:38.13 V40_45:38.13 V40_37:38.13 V40_34:38.13 V40_29:38.13 V39_2415:38.13 V39_2369:38.12 V39_2339:38.11 V39_2332:38.10 V39_2275:38.10 V39_2256:38.9 V39_2210:38.9 V39_2192:38.9 V39_2084:38.9 V39_2082:38.9 V39_2076:38.9 V39_2073:38.9 V39_2058:38.9 V39_2051:38.9 V39_2031:38.9 V39_2017:38.9 V39_2012:38.9 V39_1985:38.9 V39_1933:38.9 V39_1819:38.9 V39_1805:38.9 V39_1783:38.9 V39_1695:38.9 V39_1621:38.8 V39_1620:38.8 V39_1508:38.6 V39_1485:38.6 V39_1461:38.6 V39_1458:38.6 V39_1456:38.6 V39_1405:38.6 V39_1368:38.6 V39_1360:38.5 V39_1324:38.5 V39_1147:38.5 V39_1143:38.5 V39_1141:38.5 V39_1120:38.5 V39_1116:38.5 V39_1104:38.5 V39_1100:38.5 V39_1078:38.4 V39_1073:38.4 V39_757:38.2 V39_702:38.2 V39_557:38.2 V39_553:38.2 V39_551:38.2 V39_510:38.2 V39_495:38.1 V39_416:38.1 V39_383:38.1 V39_371:38.1 V39_336:38.1 V39_323:38.1 V39_295:38.1 V39_277:38.1 V39_254:38.1 V39_222:38.1 V39_185:38.1 V39_171:38.1 V39_161:38.1 V38_159:38.1 V38_116:38.1 V38_59:38.0;
locks    ; strict;
comment  @*   @;


38.13
date     93.01.12.16.18.28;  author peter;  state Exp;
branches ;
next     38.12;

38.12
date     93.01.08.14.45.39;  author peter;  state Exp;
branches ;
next     38.11;

38.11
date     92.12.14.18.03.19;  author peter;  state Exp;
branches ;
next     38.10;

38.10
date     92.12.04.11.56.59;  author peter;  state Exp;
branches ;
next     38.9;

38.9
date     92.07.07.15.19.57;  author peter;  state Exp;
branches ;
next     38.8;

38.8
date     92.06.29.10.43.11;  author peter;  state Exp;
branches ;
next     38.7;

38.7
date     92.06.23.17.25.51;  author peter;  state Exp;
branches ;
next     38.6;

38.6
date     92.05.27.16.06.38;  author peter;  state Exp;
branches ;
next     38.5;

38.5
date     92.04.13.16.25.06;  author peter;  state Exp;
branches ;
next     38.4;

38.4
date     92.04.09.16.24.30;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     92.04.07.17.50.13;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     92.02.21.17.03.10;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.07.25.15.02.34;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.12.14.20.42;  author peter;  state Exp;
branches ;
next     ;


desc
@@


38.13
log
@Added mouse-counter overrun code.  IBase->MouseScaleX replaces
MOUSESCALEX.
@
text
@/*** ihfront.c ***************************************************************
 *
 *  ihfront.c -- input handling front end: convert ievents to tokens
 *
 *  $Id: ihfront.c,v 38.12 93/01/08 14:45:39 peter Exp Locker: peter $
 *
 *  Confidential Information: Commodore-Amiga, Inc.
 *  Copyright (C) 1989, Commodore-Amiga, Inc.
 *  All Rights Reserved
 *
 ****************************************************************************/


#define FIX_OVERRUNS	0

#include "intuall.h"
#include "preferences.h"

/*************************************************************/

#define ACCEL_ON	TESTFLAG( IBase->Preferences->EnableCLI, MOUSE_ACCEL)


#define DTAB(x)	;	/* Tablet action	*/
#define DTAB2(x)	;	/* Tablet action	*/
#define DF(x)	;	/* input front end	*/
#define DK(x)	;	/* keyboard button equiv*/
#define DC(x)	;	/* input front end	*/
#define DKBD(x)	;	/* kbd mouse		*/
#define DUP(x)	;	/* selectup		*/
#define DP(x)	;	/* pointerpos		*/

#define DEBUG_Z		0	/* D(x) x */

/* ************************************************************** */
/* 	utility routines for input event/token conversion	  */
/* ************************************************************** */

/*
 * gets a token and initializes it suitably
 * for use as input token in createInputTokens().
 *
 * Also, queues it, and returns pointer to enqueued token
 * so that caller can fill out some more fields
 */
struct InputToken	*
newIEToken( ie, command )
struct InputEvent	*ie;
enum ITCommand		command;
{
    struct InputToken	*it;
    struct InputToken *newToken();

    if ( it = newToken() )
    {
	it->it_Command = command;
	it->it_IE = ie;
	/* should never defer: find out the exceptions */
	it->it_Flags = ITF_QUICK | ITF_DONOTDEFER;
	AddTail( &fetchIBase()->TokenQueue, it );
    }
    return ( it );
}

/* ************************************************************** */
/*  Master routine for dispatching to class-specific conversions  */
/* ************************************************************** */

createInputTokens( ie )
struct InputEvent		*ie;
{
    struct InputToken	*it;
    struct LongPoint	currpoint;

    /* need to track anticipated changes to
     * IBase->LongMouse in case I get multiple
     * pointerpos events in a chain
     */
    currpoint = fetchIBase()->LongMouse;

    for ( ; ie; ie = ie->ie_NextEvent )
    {
	DF( printf("-") );
	switch ( ie->ie_Class )
	{
	case IECLASS_RAWKEY:
	    convertRawKey( ie );
	    break;
	case IECLASS_POINTERPOS:
	case IECLASS_NEWPOINTERPOS:
	    DF( printf("cIT pointerpos\n") );
	    convertPointerPos( ie, &currpoint );
	    break;
	case IECLASS_RAWMOUSE:
	    DF( printf("cIT rawmouse\n") );
	    convertMouse( ie );
	    break;
	case IECLASS_TIMER:
	    DF( printf("%%") );
	    newIEToken( ie, itTIMER );
	    break;
	case IECLASS_DISKINSERTED:
	case IECLASS_DISKREMOVED:
	    /* collapse these two, and discern by obj1	*/
	    if ( it = newIEToken( ie, itDISKCHANGE ) )
	    {
		it->it_Object1 = (CPTR) ie->ie_Class;
	    }
	    break;
	default:
	    DF( printf("unknown IECLASS: %lx\n", ie->ie_Class ) );
	    newIEToken( ie, itUNKNOWNIE );
	}
    }
}
	
/* ************************************************************** */
/*	Convert IECLASS_RAWKEY events				  */
/* ************************************************************** */

convertRawKey( ie )
struct InputEvent	*ie;
{
    struct InputToken	*it;

    DF( printf("cRK--") );

    rawkeyButtonUpClone( ie );	/* if button-up equiv.,  add a token */

    /* rawkeys are transformed into button, mousemove, or
     * command tokens, but only when left or right
     * AMIGAKEY qualified
     */
    if ( TESTFLAG( ie->ie_Qualifier, AMIGAKEYS )  )
    {
	DK( printf("cRK: amigakey\n") );

	if (   rawkeyButtonDown( ie ) 
	    || rawkeyCommandKeys( ie )
	    || rawkeyCursorKeys( ie ) )	return;
    }

    DF( printf("convertRawKey normal key\n") );

    /* survived the conversion processes.
     * add an itRAWKEY token
     */
    if ( it = newIEToken( ie, itRAWKEY ) )
    {
	it->it_Code = 0;
	MapRawKey( ie, &it->it_Code, 1, NULL );
    }
}


/* ************************************************************** *
 *	IECLASS_RAWKEY Subfunctions				  *
 * ************************************************************** *
 *	rawkeyButtonUpClone()
 *	rawkeyButtonDown()
 *	rawkeyCommandKeys()
 *	rawkeyCursorKeys()
 *
 * Each may assume that ONE of the amigakeys are held down (except
 *  rawkeyButtonUpClone() which gets called regardless).
 *
 * Each returns TRUE if they made the transformation (and
 *	queued the appropriate token).
 */

rawkeyButtonUpClone( ie )
struct InputEvent	*ie;
{
    struct IntuitionBase	*IBase = fetchIBase();
    BOOL			doit = FALSE;

    DK( printf("rBUC select Flags %lx\n",
	IBase->Flags & (COM_SELECT+COM_MENU )) );

    if ( TESTFLAG( IBase->Flags, COM_SELECT ) )
    {
	if ( ! TESTFLAG( ie->ie_Qualifier, ALTLEFT ) )
	{
	    DK( printf("com_select up\n") );
	    CLEARFLAG( IBase->Flags, COM_SELECT );
	    createMouseToken( ie, IECODE_UP_PREFIX+IECODE_LBUTTON, itSELECTUP);
	    doit = TRUE;
	}
    }
    if ( TESTFLAG( IBase->Flags, COM_MENU ) )
    {
	if ( ! TESTFLAG( ie->ie_Qualifier, ALTRIGHT ) )
	{
	    DK( printf("com_menu up\n") );
	    CLEARFLAG( IBase->Flags, COM_MENU );
	    createMouseToken( ie, IECODE_UP_PREFIX+IECODE_RBUTTON, itMENUUP);
	    doit = TRUE;
	}
    }

    return ( doit );
}

createMouseToken( ie, code, command )
struct InputEvent	*ie;
UWORD		code;
enum ITCommand	command;
{
    struct InputEvent	*cloneie;
    struct InputEvent	*cloneIEvent();

    /*
     * for buttonup:
     *	get the extra token and insert it
     */
    if ( cloneie = cloneIEvent( ie ) )
    {
	cloneie->ie_Class = IECLASS_RAWMOUSE;
	cloneie->ie_SubClass = 0;
	cloneie->ie_Code = code;
	cloneie->ie_EventAddress = NULL;
	newIEToken( cloneie, command );
    }
}

/* Return TRUE if the key event is to be swallowed because
 * it had meaning here...
 */
rawkeyButtonDown( ie )
struct InputEvent	*ie;
{
    struct IntuitionBase	*IBase = fetchIBase();
    enum ITCommand		command;
    BOOL			doit = FALSE;
    UWORD			code;

    DK( printf(" rBD ") );

    /* the amiga-left-alt transition */
    if ( TESTFLAG( ie->ie_Qualifier, ALTLEFT ) 
	&&  !TESTFLAG( IBase->Flags, COM_SELECT ) )
    {
	DK( printf("com_select down\n") );
	SETFLAG( IBase->Flags, COM_SELECT );
	command = itSELECTDOWN;
	code = IECODE_LBUTTON;
	doit = TRUE;
    }

    /*
     * the amiga-right-alt transition
     */
    else if ( TESTFLAG( ie->ie_Qualifier, ALTRIGHT )
	&& !TESTFLAG( IBase->Flags, COM_MENU ) )
    {
	DK( printf("com_menu down\n") );
	SETFLAG( IBase->Flags, COM_MENU );
	command = itMENUDOWN;
	code = IECODE_RBUTTON;
	doit = TRUE;
    }

    if ( doit )
    {
	ie->ie_Class = IECLASS_RAWMOUSE;
	ie->ie_Code = code;
	ie->ie_EventAddress = NULL;
	newIEToken( ie, command );
    }
    return ( doit );
}

/* Return TRUE if the key event is to be swallowed because
 * it had meaning here...
 *
 * Peter 27-May-92: Starting now, we call ScreenDepth()
 * directly, instead of injecting an itDEPTHSCREEN token.
 * This allows people to patch Amiga-M/N under 3.0.
 * Note that this relies on the fact that doISM() converts
 * to sendISM() if called on input.device...
 */
rawkeyCommandKeys( ie )
struct InputEvent	*ie;
{
    struct InputToken		*it;
    BOOL			doit = FALSE;
    UBYTE			code;
    struct IntuitionBase	*IBase = fetchIBase();

    DF( printf(" rCK ") );

    /* amiga qualified down-stroke */
    if ( TESTFLAG( ie->ie_Qualifier, AMIGALEFT ) &&
	    ( MapRawKey( ie, &code, 1, NULL )  == 1 ) )
    {
	struct Screen *sc;
	ULONG flags;

	code = ToUpper( code );

	if ( code == IBase->FtoBCode )
	{
	    DF( printf("amigaM BEHIND\n") );
	    sc = IBase->FirstScreen;
	    flags = SDEPTH_TOBACK;
	    doit = TRUE;
	}
	else if ( code == IBase->WBtoFCode )
	{
	    DF( printf("amigaN wbfront\n") );
	    sc = NULL;		/* NULL will be the Workbench screen */
	    flags = SDEPTH_TOFRONT;
	    doit = TRUE;
	}
	if ( doit )
	{
	    /* Peter 27-Nov-90:  Ignore screen-shuffling keys if there are
	     * no screens around, such as during BootMenu or before the initial
	     * Shell has opened.
	     */
	    if ( ( IBase->FirstScreen )
		 && ! TESTFLAG( ie->ie_Qualifier, IEQUALIFIER_REPEAT ) )
	    {
		ScreenDepth( sc, flags, NULL );
	    }   
	}
#if DEBUG_Z
this fragment will need updating before it can be used
	    case 'Z':
		if (  ! TESTFLAG( ie->ie_Qualifier, IEQUALIFIER_REPEAT )  )
		{
		    kdebug_hook();
		}
		break;
#endif
    }

    return ( doit );
}

/* Return TRUE if the key event is to be swallowed because
 * it had meaning here...
 */
rawkeyCursorKeys( ie )
struct InputEvent	*ie;
{
    struct InputToken		*it;
    BOOL			doit = TRUE;
    WORD			xmove;
    WORD			ymove;
    struct InputEvent		*cloneie;
    struct InputEvent		*cloneIEvent();
    struct IntuitionBase	*IBase = fetchIBase();

    DC( printf("rawkeyCursorKeys: class %lx, code %lx qual %lx\n",
	ie->ie_Class, ie->ie_Code, ie->ie_Qualifier ) );

    /* recognize cursors by scancode */
    switch ( ie->ie_Code )
    {
    case CURSORUP:
	DC( printf("up\n") );
	xmove = 0;
	ymove = -kbdVMouse( ie );
	break;

    case CURSORDOWN:
	DC( printf("down\n") );
	xmove = 0;
	ymove = kbdVMouse( ie );
	break;

    case CURSORLEFT:
	DC( printf("left\n") );
	xmove = -kbdHMouse( ie );
	ymove = 0;
	break;

    case CURSORRIGHT:
	DC( printf("right\n") );
	xmove = kbdHMouse( ie );
	ymove = 0;
	break;

    default:
	/* patch back if not converted */
	doit = FALSE;
    }

    /* I want to change the input event to mirror the
     * the token, but if I change the original, I think
     * input.device screws up.
     */
    if ( doit &&
	(cloneie = cloneIEvent( ie ) ) &&
	(it = newIEToken( cloneie, itMOUSEMOVE ) ) )
    {
	it->it_LongMouse.LX = xmove;
	it->it_LongMouse.LY = ymove;

	cloneie->ie_Class = IECLASS_RAWMOUSE;

#if 0
	/*** DEBUG ***/
	ie->ie_Class = 0x99;
	ie->ie_Code = IECODE_NOBUTTON;
	ie->ie_SubClass = 0;
	ie->ie_X = it->it_LongMouse.LX/IBase->MouseScaleX;
	ie->ie_Y = it->it_LongMouse.LY/IBase->MouseScaleY;
#endif

	cloneie->ie_SubClass = 0;
	cloneie->ie_Code = IECODE_NOBUTTON;

	cloneie->ie_X = it->it_LongMouse.LX/IBase->MouseScaleX;
	cloneie->ie_Y = it->it_LongMouse.LY/IBase->MouseScaleY;
    }

    return ( doit );
}

/* ************************************************************** */
/*	Convert IECLASS_POINTERPOS and IECLASS_RAWMOUSE events	  */
/* ************************************************************** */

/*
 * convert IECLASS_POINTERPOS and IECLASS_NEWPOINTERPOS to itMOUSEMOVE.
 * This version assumes ie_xy in "old" coordinates (640x400).
 * RELATIVEMOUSE qualifier means deltas (same as mousemove,
 * but without acceleration, preferences scale).
 */
convertPointerPos( ie, currpoint )
struct InputEvent	*ie;
struct LongPoint		*currpoint;
{
    struct IntuitionBase	*IBase = fetchIBase();
    struct LongPoint		mousecoord;
    BOOL			compatible = FALSE;
    struct TabletData		*tablet = NULL;

    DP( printf("cPP: Class %lx SubClass %lx Code %lx Qual %lx\n",
	ie->ie_Class, ie->ie_SubClass, ie->ie_Code, ie->ie_Qualifier ) );

    if ( ie->ie_Class == IECLASS_POINTERPOS ||
	ie->ie_SubClass == IESUBCLASS_COMPATIBLE )
    {
	compatible = TRUE;
	mousecoord.LX = ie->ie_X * IBase->MouseScaleX;
	mousecoord.LY = ie->ie_Y * IBase->MouseScaleY;
    }

    else if ( ie->ie_SubClass == IESUBCLASS_PIXEL )
    {
	struct IEPointerPixel	*iepp;

	iepp = (struct IEPointerPixel *) ie->ie_EventAddress;
	if ( iepp->iepp_Screen == NULL ) return;

	mousecoord.LX = iepp->iepp_Position.X;
	mousecoord.LY = iepp->iepp_Position.Y;
	if ( !TESTFLAG( ie->ie_Qualifier, IEQUALIFIER_RELATIVEMOUSE ) ) 
	{
	    mousecoord.LX += iepp->iepp_Screen->LeftEdge;
	    mousecoord.LY += iepp->iepp_Screen->TopEdge;
	}
	screenToLongMouse( &mousecoord, iepp->iepp_Screen );
    }

    else if ( ie->ie_SubClass == IESUBCLASS_TABLET )
    {
	struct IEPointerTablet	*iept;
	int			range;
	struct Rectangle	mlimits;

	iept = (struct IEPointerTablet *) ie->ie_EventAddress;

	/* can't handle relativemouse	*/
	CLEARFLAG( ie->ie_Qualifier, IEQUALIFIER_RELATIVEMOUSE );

	DP( printf("newpointerpos tablet\n") );

	/* resulting absolute coordinate is calculated from
	 * "extended mouse limits". 
	 * First try: current mouse limits expanded upwards
	 * to 0.
	 * Peter 3-Apr-91:  Use non-constrained mouse limits instead.
	 */
	mlimits = IBase->FreeMouseLimits;
	if ( mlimits.MinY > 0 ) mlimits.MinY = 0;

	range = rectWidth( &mlimits );
	mousecoord.LX = mlimits.MinX + 
		( range * iept->iept_Value.X )/iept->iept_Range.X;

	range = rectHeight( &mlimits );
	mousecoord.LY = mlimits.MinY + 
		( range * iept->iept_Value.Y )/iept->iept_Range.Y;
    }
    else if ( ie->ie_SubClass == IESUBCLASS_NEWTABLET )
    {
	struct IENewTablet *ient;
	struct Rectangle pointer_rect;
	LONG rangeX, rangeY;
	LONG new;
	struct Screen *ascreen = NULL;

	pointer_rect.MinX = pointer_rect.MinY = 0;
	pointer_rect.MaxX = 639;
	pointer_rect.MaxY = 399;

	/* can't handle relativemouse	*/
	CLEARFLAG( ie->ie_Qualifier, IEQUALIFIER_RELATIVEMOUSE );

	/* We're going to work out the tablet limits based on the
	 * active screen or its parent:
	 */
	if ( IBase->ActiveScreen )
	{
	    struct IBox tempbox;
	    struct Screen *screenFamily();

	    ascreen = screenFamily( IBase->ActiveScreen );

	    /* Start with the active screen's true dimensions,
	     * but ignore that it's pulled down, if at all
	     */
	    tempbox = *(struct IBox *)&ascreen->LeftEdge;
	    DTAB( dumpBox( "ascreen box", &tempbox ) );
	    tempbox.Top -= imax( 0,
		ascreen->TopEdge - XSC(ascreen)->VPExtra->DisplayClip.MinY );
	    boxToRect( &tempbox, &pointer_rect );
	    DTAB( dumpRect( "ascreen rect top-shifted", &pointer_rect ) );

	    /* Grow the screen's dimensions to include DClip */
	    rectHull( &pointer_rect, &XSC(ascreen)->VPExtra->DisplayClip);
	    DTAB2( dumpRect( "now includes dclip", &pointer_rect ) );
	}

	/* Let's do the driver a favor and tell him when the
	 * screen changes.  This allows him to trivially cache
	 * more complex screen info.
	 * LastTabletScreen needs to be reset when the tablet screen
	 * closes or when MEGAFORCE remaking happens (coercion)
	 */
	/* ZZZ: doesn't support "new" notification if multiple players
	 * are sending input-events.
	 */
	new = FALSE;
	if ( IBase->LastTabletScreen != ascreen )
	{
	    IBase->LastTabletScreen = ascreen;
	    new = TRUE;
	}

	ient = (struct IENewTablet *) ie->ie_EventAddress;

	/* Now we have the mouse-travel range for this screen! */
	rangeX = rectWidth( &pointer_rect );
	rangeY = rectHeight( &pointer_rect );

	/* The driver will fill in the ient_ScaledX, ient_ScaledY,
	 * ient_ScaledXFraction, and ient_ScaledYFraction fields
	 * based on the active screen information we pass here.
	 * We perform default scaling if the hook pointer is NULL
	 * or if the hook returns a non-NULL value, which means
	 * "reserved for future use".
	 */
	if ( ( !ient->ient_CallBack ) ||
	    ( callHook( ient->ient_CallBack, ie, ascreen, rangeX, rangeY, new ) ) )
	{
	    ULONG remainder;

	    /* Default processing: take the pointer_rect, and scale based on
	     * the range the tablet gave us to work with:
	     */
	    ient->ient_ScaledX = divMod( rangeX * ient->ient_TabletX,
		ient->ient_RangeX, &remainder );

	    ient->ient_ScaledXFraction = ( remainder << 16 ) / ient->ient_RangeX;

	    ient->ient_ScaledY = divMod( rangeY * ient->ient_TabletY,
		ient->ient_RangeY, &remainder );

	    ient->ient_ScaledYFraction = ( remainder << 16 ) / ient->ient_RangeY;

	    DTAB2( printf("Default scale, X,Y = %ld,%ld\n",
		ient->ient_ScaledX, ient->ient_ScaledY ) );
	}

	DTAB2( printf("Pulldown %ld Shifted back X,Y = %ld,%ld\n", pulldown,
	    ient->ient_ScaledX, ient->ient_ScaledY ) );
	mousecoord.LX = pointer_rect.MinX + ient->ient_ScaledX;
	mousecoord.LY = pointer_rect.MinY + ient->ient_ScaledY;
	/* This one scales the coordinate by the screen ScaleFactor, but
	 * screen LeftEdge/TopEdge is not taken into consideration.  Therefore
	 * we're done as soon as we scale.
	 */
	if ( ascreen )
	{
	    screenToLongMouse( &mousecoord, ascreen );
	}
	else
	{
	    mousecoord.LX *= MOUSESCALEX;
	    mousecoord.LY *= NTSC_MOUSESCALEY;
	}

	DTAB( printf("Final Ticks X,Y = %ld,%ld\n", mousecoord.LX, mousecoord.LY ) );

	/* Here's the catch:  Nobody else needs to know that
	 * struct TabletData is embedded in the end of struct
	 * IENewTablet!
	 */
	tablet = (struct TabletData *) &ient->ient_ScaledXFraction;
    }

    else return;

    newPointerPos( &mousecoord, ie, currpoint,
	TESTFLAG( ie->ie_Qualifier, IEQUALIFIER_RELATIVEMOUSE ), compatible, tablet );
}

/*
 * once you know where (in mouse ticks) you want to position the mouse,
 * call this routine right here.  If you 'relative' is true, then
 * newcoord is taken as a relative offset in mouse ticks.
 */
newPointerPos( newcoord, ie, currpoint,  relative, compatible, tablet )
struct LongPoint	*newcoord;
struct LongPoint	*currpoint;
struct InputEvent	*ie;
struct TabletData	*tablet;
{
    struct InputToken	*it;
    struct InputEvent	*maybecloneie;
    struct IntuitionBase	*IBase = fetchIBase();

    /* Peter 8-Mar-91:  Jack Nicklaus Unlimited Golf relies on
     * Intuition-V34's behavior of not modifying the IECLASS_POINTERPOS
     * InputEvent it supplies, even though the docs were very
     * clear in this regard.  So we try to use a copy if possible.
     * If not, we'll use the original anyways.
     */
    if ( ( !compatible ) || ( ! ( maybecloneie = cloneIEvent( ie ) ) ) )
    {
	/* Using the original is better than failing! */
	maybecloneie = ie;
    }

    if ( it = newIEToken( maybecloneie, itMOUSEMOVE ) )
    {
	/* calculate delta to desired tick position */
	it->it_LongMouse.LX = newcoord->LX;
	it->it_LongMouse.LY = newcoord->LY;

	/* Install tablet data if any */
	it->it_Tablet = tablet;

	if ( ! relative )
	{
	    /* need to convert all mousemove things into
	     * some relative coordinates, so I subtract
	     * and update a shadow copy of IBase->LongMouse.
	     * That shadow copy is used to handle multiple
	     * chained input events.
	     */
	    it->it_LongMouse.LX -= currpoint->LX;
	    it->it_LongMouse.LY  -= currpoint->LY;
	    *currpoint = *newcoord;
	}

	/* make consistent input event */
	maybecloneie->ie_Class = IECLASS_RAWMOUSE;
	maybecloneie->ie_SubClass = 0;

	/* convert to equivalent old-style dx/dy for DELTAMOVE customers */
	maybecloneie->ie_X = it->it_LongMouse.LX/IBase->MouseScaleX;
	maybecloneie->ie_Y = it->it_LongMouse.LY/IBase->MouseScaleY;

	/* Peter 30-Jan-91: Turns out that 1.3 used to heed button
	 * transitions for POINTERPOS events as well as RAWMOUSE.
	 * Sounds reasonable enough...
	 *
	 * V39 News flash!  NEWTABLET events send button transitions
	 * too, and with TabletInfo!
	 */
	if ( ( compatible ) || ( tablet ) )
	{
	    addButtonEvent( it, tablet );
	}
	/* Peter 8-Mar-91: Have to leave the code info around
	 * long enough for addButtonEvent() to see it.
	 */
	maybecloneie->ie_Code = IECODE_NOBUTTON;
    }
}

/*
 * convert IECLASS_RAWMOUSE to InputToken(s).
 * Will add itMOUSEMOVE and possibly an extra button token
 * ZZZ: WAIT A MINUTE:  This didn't work.
 *	I was trying to regularize the old voodoo where
 *	a rawmouse event was processed first as a mousemove,
 *	and then as a mouse button event.
 *
 *	The approach I put in here separated into two events,
 *	itMOUSEMOVE and itSELECTUP, for instance.  The problem is
 *	that the itMOUSEMOVE input event still has code == SELECTUP,
 *	which is processed like itSELECTUP by gadgets.  This sux,
 *	since the subsequent itSELECTUP gets passed through subsequently.
 *
 *	Two approaches are: 
 *	1) Clone a new event for the added token, and set the itMOUSEMOVE
 *	one to have its Code set to IECODE_NOBUTTON, and its qualifier
 *	cleared/set properly for the "pre-button event" conditions.
 *
 *	2) Screw it, convert to itSELECTUP, and skip the equivalent
 *	itMOUSEMOVE.  This might suck, if the input device collapses
 *	mouse events, which I assume it does: I'd miss the mouse movement
 *	associated with the up click.  So, mouse up/downs while moving
 *	would suck.
 */
convertMouse( ie )
struct InputEvent	*ie;
{
    struct InputToken	*it;
    struct IntuitionBase	*IBase = fetchIBase();

    /*
     * convert to RAWMOUSE or directly to MOUSEMOVE token,
     *
     * coordinate values:
     *	old: 640x400 pixels
     *	raw mouse ticks
     *	screen relative pixels
     *	normalized within mouse-limit boundaries (stdoscan?)
     * check IEQUALIFIER_RELATIVE
     */

    /*
     * accelerate (not for pointerpos guys)
     * scale by prefs scale ratio (not for pointerpos guys)
     * let 'er rip, even if no motion (???)
     *
     * For MOUSEBUTTON events, first put an itMOUSEMOVE
     * token in the queue, then do a mousebuttons.
     */

     /*
      * create an itMOUSEMOVE token for everything.
      * if a button is pressed, will get separate token
      */
    if ( it = newIEToken( ie, itMOUSEMOVE ) )
    {
#if FIX_OVERRUNS
	/* Correct for mouse-counter overruns */
	correctoMouse( ie );
#endif
	/* scale the mouse movement into unused slots */
	if ( ACCEL_ON ) acceloMouse( ie );

	/* ZZZ: what if I don't want ie scaled by acceloMouse()?
	 *  What I'd do is have acceloMouse operate on a Point.
	 */

	it->it_LongMouse.LX = ie->ie_X * IBase->EffectiveScaleFactor.X;
	it->it_LongMouse.LY = ie->ie_Y * IBase->EffectiveScaleFactor.Y;
    }

    addButtonEvent( it, NULL );
}

/* addButtonEvent()
 *
 * If this RAWMOUSE event or old or compatible POINTERPOS event
 * has button transitions, add a button event.
 */

addButtonEvent( it, tablet )
struct InputToken	*it;
struct TabletData *tablet;
{
    BOOL		add_a_button;
    enum ITCommand	extracommand;
    struct InputEvent	*cloneie;
    struct InputEvent *ie = it->it_IE;
    struct IntuitionBase *IBase = fetchIBase();

    /* If button, add another event.  Assume true to start */
    add_a_button = TRUE;

    switch ( ie->ie_Code )
    {
    case SELECTUP:
	DUP( printf("add a selectup\n") );
	extracommand = itSELECTUP;
	break;

    case SELECTDOWN:
	extracommand = itSELECTDOWN;
	if ( metaDrag( ie ) )
	{
	    extracommand = itMETADRAG;
	}
	break;

    case MENUDOWN:
	extracommand = itMENUDOWN;
	break;

    case MENUUP:
	extracommand = itMENUUP;
	break;

    case MIDDLEDOWN:
    case MIDDLEUP:
	extracommand = itUNKNOWNIE;	/* should let it get through */
	break;

    default:
	add_a_button = FALSE;
	break;
    }

    /* Clone an event for the extra button, and fudge the
     * InputEvent and InputToken.
     */
    if ( add_a_button )
    {
	/* In 2.0x -> 3.00, we went back and eunuched the
	 * itMOUSEMOVE event, in other words, we removed the
	 * button code and the button qualifier from the
	 * first event, leaving a pure movement event.  Then,
	 * we made a new event for the button information.
	 * 
	 * But, this is WRONG, because the pressure
	 * information associated with that MOUSEMOVE would
	 * indicate that the button transition should have
	 * already occurred.  So we send the button through
	 * first, which involves cloning the input event,
	 * removing the button-part from the original,
	 * creating a it(whatever-button) token, and slipping
	 * that token ahead of the itMOUSEMOVE token.
	 */
	if ( cloneie = cloneIEvent( ie ) )
	{
	    struct InputToken *newit;
	    ie->ie_Code = IECODE_NOBUTTON;
	    if ( newit = newIEToken( cloneie, extracommand ) )
	    {
		newit->it_Tablet = tablet;
	    }
	    /* Move the itMOUSEMOVE token to the end */
	    Remove( it );
	    AddTail( &IBase->TokenQueue, it );
	}
    }
}

#define METAQUALS (IEQUALIFIER_LSHIFT|IEQUALIFIER_RSHIFT| \
		IEQUALIFIER_CONTROL | \
		IEQUALIFIER_LCOMMAND | IEQUALIFIER_RCOMMAND | \
		IEQUALIFIER_LALT |  IEQUALIFIER_RALT)

metaDrag( ie )
struct InputEvent *ie;
{
    struct IntuitionBase	*IBase = fetchIBase();

    /* Peter 7-Aug-90: Was returning true if all four qualifiers were
     * turned off and a regular SELECTDOWN happened.
     * Now "all qualifiers off" = metadrag off
     */
    return ( (IBase->MetaDragQual) && 
	(ie->ie_Qualifier & METAQUALS) == (IBase->MetaDragQual & METAQUALS) );
}

/* ************************************************************** */
/*	Keyboard mousemove distance calculations		  */
/* ************************************************************** */


/* CURSOR_REPEAT_INIT is the number of ticks the mouse will move per
 * repeat-keystroke, before acceleration kicks in.  CURSOR_STEADY_DELAY
 * is the number of repeat-keystrokes before acceleration kicks in.
 * CURSOR_ACCEL_SLOPE is the amount that the motion will grow per
 * keystroke during acceleration.  CURSOR_MAX_SPEED is the cap on
 * acceleration.
 *
 * Maybe these should be made into factors to be multiplied by
 * IBase->MouseScaleX or MouseScaleY, but exact multiples of pixels
 * matter mostly for single taps, not repeats.
 */

#define CURSOR_STEADY_DELAY	( 20 )
#define CURSOR_ACCEL_SLOPE	(  1 * MOUSESCALEX )
#define CURSOR_MAX_SPEED	( 30 * MOUSESCALEX )
#define CURSOR_SHIFT_MOVE	( 40 * MOUSESCALEX )
#define CURSOR_REPEAT_INIT	(  3 * MOUSESCALEX )

initCursorInc( )
{
    struct IntuitionBase	*IBase = fetchIBase();

    /* if ( IBase->CursorSteady == 0 ) */
	IBase->CursorInc = CURSOR_REPEAT_INIT;	/* nah: only second time */
    IBase->CursorSteady = 0;
}

repeatCursorInc()
{
    struct IntuitionBase	*IBase = fetchIBase();


    if ( ++IBase->CursorSteady >= CURSOR_STEADY_DELAY )
    {
	DKBD( printf("ramp up\n") );
	if ( (IBase->CursorInc += CURSOR_ACCEL_SLOPE ) > CURSOR_MAX_SPEED )
	{
	    DKBD( printf("maxed out\n") );
	    IBase->CursorInc = CURSOR_MAX_SPEED;
	}
    }
    return ( IBase->CursorInc );
}

/*
 * return increment (in mouse ticks) for vertical mouse
 * motion from keyboard.  Uses qualifier only.
 */
kbdVMouse( ie )
struct InputEvent	*ie;
{
    UWORD	qual = ie->ie_Qualifier;
    int	retval;
    struct IntuitionBase	*IBase = fetchIBase();

    if ( TESTFLAG( qual, SHIFTY ) )
    {
	retval = CURSOR_SHIFT_MOVE;
	initCursorInc( );	/* reset repeat speed */
    }
    else if ( TESTFLAG( qual, IEQUALIFIER_REPEAT ) )
    {
	/* retval = IBase->MouseScaleY * 25; */

	retval = repeatCursorInc();

    }
    else	/* one pixel	*/
    {
	if ( IBase->ActiveScreen )
	{
	    DC( printf("try for a single pixel Y\n") );
	    retval = XSC(IBase->ActiveScreen)->ScaleFactor.Y;
	}
	else
	{
	    DC( printf("kVM: no active window\n") );
	    retval = IBase->MouseScaleY;
	}

	initCursorInc( );
    }

    DC( printf("kbdVMouse returning %ld\n", retval ) );
    return ( retval );
}
/*
 * return increment (in mouse ticks) for horizontal mouse
 * motion from keyboard.  Uses qualifier only.
 */
kbdHMouse( ie )
struct InputEvent	*ie;
{
    UWORD	qual = ie->ie_Qualifier;
    int	retval;
    struct IntuitionBase	*IBase = fetchIBase();

    DC( printf("kHM: qual: %lx\n", qual ) );

    if ( TESTFLAG( qual, SHIFTY ) )
    {
	retval = CURSOR_SHIFT_MOVE;
	initCursorInc( );	/* reset repeat speed */
    }
    else if ( TESTFLAG( qual, IEQUALIFIER_REPEAT ) )
    {
	/* retval = MOUSESCALEX * 25; */
	retval = repeatCursorInc();
    }
    else	/* one pixel	*/
    {
	if ( IBase->ActiveScreen )
	{
	    DC( printf("try for a single pixel X\n") );
	    retval = XSC(IBase->ActiveScreen)->ScaleFactor.X;
	}
	else
	{
	    DC( printf("kVM: no active window\n") );
	    retval = IBase->MouseScaleX;
	}

	initCursorInc( );
    }

    DC( printf("kbdHMouse returning %ld\n", retval ) );
    return ( retval );
}
@


38.12
log
@IESUBCLASS_PIXEL events with IEQUALIFIER_RELATIVEMOUSE were broken.
@
text
@d5 1
a5 1
 *  $Id: ihfront.c,v 38.11 92/12/14 18:03:19 peter Exp Locker: peter $
d14 2
d408 1
a408 1
	ie->ie_X = it->it_LongMouse.LX/MOUSESCALEX;
d415 1
a415 1
	cloneie->ie_X = it->it_LongMouse.LX/MOUSESCALEX;
d448 1
a448 1
	mousecoord.LX = ie->ie_X * MOUSESCALEX;
d677 1
a677 1
	maybecloneie->ie_X = it->it_LongMouse.LX/MOUSESCALEX;
d755 4
a859 2
#if 1

a864 1
/* ZZZ: shift means lshift, I hope */
a876 7
#else
metaDrag( ie )
struct InputEvent *ie;
{
    return ( TESTFLAG( ie->ie_Qualifier,  IEQUALIFIER_LCOMMAND) );
}
#endif
d883 17
a899 7
#define CURSOR_STEADY_DELAY	(20)
/* ZZZ: use seconds/repeat rate instead? */

#define CURSOR_ACCEL_SLOPE	(1 * MOUSESCALEX)
#define CURSOR_MAX_SPEED	(30 * MOUSESCALEX)
#define CURSOR_SHIFT_MOVE	(40 * MOUSESCALEX)
#define CURSOR_REPEAT_INIT	( 3 * MOUSESCALEX )
d1002 1
a1002 1
	    retval = MOUSESCALEX;
@


38.11
log
@When breaking button event into move/button components, now does
it in a sensible order.
@
text
@d5 1
a5 1
 *  $Id: ihfront.c,v 38.10 92/12/04 11:56:59 peter Exp Locker: peter $
d457 7
a463 2
	mousecoord.LX = iepp->iepp_Screen->LeftEdge + iepp->iepp_Position.X;
	mousecoord.LY = iepp->iepp_Screen->TopEdge + iepp->iepp_Position.Y;
@


38.10
log
@Keyboard control of mouse cursor now uses exact value even if no
window is active.
@
text
@d5 1
a5 1
 *  $Id: ihfront.c,v 38.9 92/07/07 15:19:57 peter Exp Locker: peter $
d439 3
d682 1
a682 1
	    addButtonEvent( maybecloneie, tablet );
a690 3
/*#define WILD_DRAG_OK	TESTFLAG( IBase->Preferences->EnableCLI, SCREEN_DRAG)*/
#define WILD_DRAG_OK	(1)

d759 1
a759 1
    addButtonEvent( ie, NULL );
d768 2
a769 2
addButtonEvent( ie, tablet )
struct InputEvent *ie;
a773 1
    UWORD		movequalifier;
d775 2
a776 1
    struct InputToken	*it;
d778 1
a778 2

    /* if button, add another event	*/
a779 1
    movequalifier = ie->ie_Qualifier;
a785 1
	SETFLAG( movequalifier, IEQUALIFIER_LEFTBUTTON );
d789 5
a793 3
	extracommand = (WILD_DRAG_OK && metaDrag( ie ))?
			itMETADRAG: itSELECTDOWN;
	CLEARFLAG( movequalifier, IEQUALIFIER_LEFTBUTTON );
a797 1
	CLEARFLAG( movequalifier, IEQUALIFIER_RBUTTON );
a801 1
	SETFLAG( movequalifier, IEQUALIFIER_RBUTTON );
d814 2
a815 11
#if 0
    /* This was much too soft.
     * METHOD 0: This shares an input event, and winds up being
     * two selectup's for gadgets, for example.
     */
    return ( add_a_button  &&  newIEToken( ie,  extracommand )  );
#endif

#if 0	/* this was too jerky	*/
    /* METHOD 2: forget about the corresponding itMOUSEMOVE,
     * and convert the token to a button thing.
d819 15
a833 13
	if ( it ) it->it_Command = extracommand;
	return;
    }
#endif

#if 1	/* Ahh, this is juussst right.	*/
    /* METHOD 1: clone an event for the extra button, and
     * fudge the ie_Code and ie_Qualifier of the itMOUSEMOVE
     * input event.
     */
    if ( add_a_button )
    {
	/* get a copy of the button input event */
d836 1
a836 6
	    /* Let's go back and eunuch the itMOUSEMOVE event,
	     * in other words, we remove the button code
	     * and the button qualifier from the first event,
	     * leaving a pure movement event.  Then, we'll
	     * make a new event for the button information.
	     */
d838 1
a838 6
	    ie->ie_Qualifier = movequalifier;

	    /* Button events from a NEWTABLET class get the
	     * tablet info
	     */
	    if ( it = newIEToken( cloneie, extracommand ) )
d840 1
a840 1
		it->it_Tablet = tablet;
d842 3
a846 1
#endif
@


38.9
log
@Enabled LastTabletScreen stuff.  Changes in MouseScaleY now affect
itMOUSEMOVEs.
@
text
@d5 1
a5 1
 *  $Id: ihfront.c,v 38.8 92/06/29 10:43:11 peter Exp Locker: peter $
d959 1
a959 1
	if ( IBase->ActiveWindow )
d962 1
a962 1
	    retval = XSC(IBase->ActiveWindow->WScreen)->ScaleFactor.Y;
d1001 1
a1001 1
	if ( IBase->ActiveWindow )
d1004 1
a1004 1
	    retval = XSC(IBase->ActiveWindow->WScreen)->ScaleFactor.X;
d1012 1
a1012 1
	initCursorInc( retval );
@


38.8
log
@Default tablet hook now gives sub-pixel position too.  IToken mouse
coordinates now longs.  IBase->LongMouse now used.
@
text
@d5 1
a5 1
 *  $Id: ihfront.c,v 38.7 92/06/23 17:25:51 peter Exp Locker: peter $
a538 1
#if DO_LATER
a543 1
#endif
@


38.7
log
@NEWTABLET events handle NULL ActiveWindow.
@
text
@d5 1
a5 1
 *  $Id: ihfront.c,v 38.6 92/05/27 16:06:38 peter Exp Locker: peter $
d71 1
a71 1
    struct Point	currpoint;
d74 1
a74 1
     * IBase->Mouse in case I get multiple
d77 1
a77 1
    currpoint = fetchIBase()->Mouse;
d396 2
a397 2
	it->it_Box.Left = xmove;
	it->it_Box.Top = ymove;
d406 2
a407 2
	ie->ie_X = it->it_Box.Left/MOUSESCALEX;
	ie->ie_Y = it->it_Box.Top/IBase->MouseScaleY;
d413 2
a414 2
	cloneie->ie_X = it->it_Box.Left/MOUSESCALEX;
	cloneie->ie_Y = it->it_Box.Top/IBase->MouseScaleY;
d432 1
a432 1
struct Point		*currpoint;
d435 1
a435 1
    struct Point		mousecoord;
d443 2
a444 2
	mousecoord.X = ie->ie_X * MOUSESCALEX;
	mousecoord.Y = ie->ie_Y * IBase->MouseScaleY;
d454 3
a456 3
	mousecoord.X = iepp->iepp_Screen->LeftEdge + iepp->iepp_Position.X;
	mousecoord.Y = iepp->iepp_Screen->TopEdge + iepp->iepp_Position.Y;
	screenToMouse( &mousecoord, iepp->iepp_Screen );
d482 1
a482 1
	mousecoord.X = mlimits.MinX + 
d486 1
a486 1
	mousecoord.Y = mlimits.MinY + 
d563 2
d568 2
a569 1
	    ient->ient_ScaledX = ( rangeX * ient->ient_TabletX )/ient->ient_RangeX;
d571 1
a571 1
	    ient->ient_ScaledY = ( rangeY * ient->ient_TabletY )/ient->ient_RangeY;
d573 2
a574 1
	    ient->ient_ScaledXFraction = 0;
d576 1
a576 1
	    ient->ient_ScaledYFraction = 0;
d584 2
a585 2
	mousecoord.X = pointer_rect.MinX + ient->ient_ScaledX;
	mousecoord.Y = pointer_rect.MinY + ient->ient_ScaledY;
d592 1
a592 1
	    screenToMouse( &mousecoord, ascreen );
d596 2
a597 2
	    mousecoord.X *= MOUSESCALEX;
	    mousecoord.Y *= NTSC_MOUSESCALEY;
d600 1
a600 1
	DTAB( printf("Final Ticks X,Y = %ld,%ld\n", mousecoord.X, mousecoord.Y ) );
d621 2
a622 2
struct Point		*newcoord;
struct Point		*currpoint;
d645 2
a646 2
	it->it_Box.Left = newcoord->X;	/* can do longword copy */
	it->it_Box.Top = newcoord->Y;
d655 1
a655 1
	     * and update a shadow copy of IBase->Mouse.
d659 2
a660 2
	    it->it_Box.Left -= currpoint->X;
	    it->it_Box.Top  -= currpoint->Y;
d669 2
a670 2
	maybecloneie->ie_X = it->it_Box.Left/MOUSESCALEX;
	maybecloneie->ie_Y = it->it_Box.Top/IBase->MouseScaleY;
d757 2
a758 2
	it->it_Box.Left = ie->ie_X * IBase->EffectiveScaleFactor.X;
	it->it_Box.Top = ie->ie_Y * IBase->EffectiveScaleFactor.Y;
@


38.6
log
@Amiga-M/N action now goes through ScreenDepth() function.
@
text
@d5 1
a5 1
 *  $Id: ihfront.c,v 38.5 92/04/13 16:25:06 peter Exp Locker: peter $
a491 1
	struct IBox tempbox;
d495 1
d497 3
a499 1
	struct Screen *screenFamily();
d501 3
d507 4
a510 4
	/* ZZZ: need to handle ascreen = NULL! */
	struct Screen *ascreen = screenFamily( IBase->ActiveScreen );

	ient = (struct IENewTablet *) ie->ie_EventAddress;
d512 1
a512 2
	/* can't handle relativemouse	*/
	CLEARFLAG( ie->ie_Qualifier, IEQUALIFIER_RELATIVEMOUSE );
d514 14
a527 13
	/* Start with the active screen's true dimensions,
	 * but ignore that it's pulled down, if at all
	 */
	tempbox = *(struct IBox *)&ascreen->LeftEdge;
	DTAB( dumpBox( "ascreen box", &tempbox ) );
	tempbox.Top -= imax( 0,
	    ascreen->TopEdge - XSC(ascreen)->VPExtra->DisplayClip.MinY );
	boxToRect( &tempbox, &pointer_rect );
	DTAB( dumpRect( "ascreen rect top-shifted", &pointer_rect ) );

	/* Grow the screen's dimensions to include DClip */
	rectHull( &pointer_rect, &XSC(ascreen)->VPExtra->DisplayClip);
	DTAB2( dumpRect( "now includes dclip", &pointer_rect ) );
d536 1
a536 1
	 * are dropping input-events.
d547 2
d586 10
a595 1
	screenToMouse( &mousecoord, ascreen );
d651 3
a653 1
	     * and update a shadow copy of IBase->Mouse
@


38.5
log
@Reworked how TabletData is managed.
@
text
@d5 1
a5 1
 *  $Id: ihfront.c,v 38.4 92/04/09 16:24:30 peter Exp Locker: peter $
d224 3
d271 9
d294 2
a295 2
	struct Screen *obj;
	ULONG subcommand;
d302 2
a303 2
	    obj = IBase->FirstScreen;
	    subcommand = SDEPTH_TOBACK;
d309 2
a310 2
	    obj = NULL;		/* NULL will be the Workbench screen */
	    subcommand = SDEPTH_TOFRONT;
d320 1
a320 2
		 && ! TESTFLAG( ie->ie_Qualifier, IEQUALIFIER_REPEAT ) 
		 && (it = newIEToken( ie, itDEPTHSCREEN ) ) )
d322 1
a322 6
		it->it_Object1 = (CPTR) obj;
		it->it_SubCommand = subcommand;

		/* play safe: let this be deferred */
		it->it_IE = &IBase->IECopy;
		CLEARFLAG( it->it_Flags, ITF_DONOTDEFER );
d339 3
@


38.4
log
@Removed some compiled-out code.  Put in support for IESUBCLASS_NEWTABLET.
Optimized Amiga-N/M processing.
@
text
@d5 1
a5 1
 *  $Id: ihfront.c,v 38.3 92/04/07 17:50:13 peter Exp Locker: peter $
d482 1
a482 1
	struct TabletData *td;
d496 1
a496 1
	td = (struct TabletData *) ie->ie_EventAddress;
d537 9
a545 10
	if ( td->td_CallBack )
	{
	    /* The driver will fill in the ScreenX, ScreenY,
	     * ScreenSubX, and ScreenSubY fields, based on
	     * the active screen information we pass here.
	     */
	    callHook( td->td_CallBack, ie, ascreen, rangeX, rangeY, new );
	}
	/* If no hook supplied, do we care to offer some default processing? */
	else
d547 1
a547 1
	    /* Let's take the pointer_rect, and scale based on
d550 1
a550 2
	    td->td_ScreenX = pointer_rect.MinX + 
		    ( rangeX * td->td_TabletX )/td->td_RangeX;
d552 1
a552 2
	    td->td_ScreenY = pointer_rect.MinY + 
		    ( rangeY * td->td_TabletY )/td->td_RangeY;
d554 4
d559 1
a559 1
		td->td_ScreenX, td->td_ScreenY ) );
d562 4
a565 3
	DTAB2( printf("Pulldown %ld Shifted back X,Y = %ld,%ld\n", pulldown, td->td_ScreenX, td->td_ScreenY ) );
	mousecoord.X = td->td_ScreenX;
	mousecoord.Y = td->td_ScreenY;
d572 6
a577 1
	tablet = td;
@


38.3
log
@Removed unused vble.
@
text
@d5 1
a5 1
 *  $Id: ihfront.c,v 38.2 92/02/21 17:03:10 peter Exp Locker: peter $
a17 2
/* interim definitions for new pointerpos classes */
#ifndef IECLASS_NEWPOINTERPOS
a18 64
/* A new extended-function pointer position report (see ie_SubClass defines) */
#define IECLASS_NEWPOINTERPOS	0x13

#undef IECLASS_MAX
#define IECLASS_MAX		0x13

/* ie_SubClass definitions for IECLASS_POINTERPOS */
/* like IECLASS_POINTERPOS	*/
#define	IESUBCLASS_COMPATIBLE	0x00

/* ie_EventAddress points to struct IEPointerPixel	*/
#define	IESUBCLASS_PIXEL	0x01

/* ie_EventAddress points to struct IEPointerTablet	*/
#define	IESUBCLASS_TABLET	0x02

/* pointed to by ie_EventAddress for IECLASS_NEWPOINTERPOS,
 * and IESUBCLASS_PIXEL.
 *
 * You specify a screen and pixel coordinates in that screen
 * at which you'd like the mouse to be positioned.
 * Intuition will try to oblige, but there will be restrictions
 * to positioning the pointer over offscreen pixels.
 *
 * IEQUALIFIER_RELATIVEMOUSE is supported for IESUBCLASS_PIXEL.
 */
struct IEPointerPixel	{
    struct Screen	*iepp_Screen;	/* pointer to an open screen */
    struct {				/* pixel coordinates in iepp_Screen */
	WORD	X;
	WORD	Y;
    }			iepp_Position;
};

/* pointed to by ie_EventAddress for IECLASS_NEWPOINTERPOS,
 * and IESUBCLASS_TABLET.
 *
 * You specify a range of values and a value within the range 
 * independently for each of X and Y (the minimum value of
 * the ranges is always normalized to 0).
 *
 * Intuition will position the mouse proportionally within its
 * natural mouse position rectangle limits.
 *
 * IEQUALIFIER_RELATIVEMOUSE is not supported for IESUBCLASS_TABLET.
 */
struct IEPointerTablet	{
    struct {
	UWORD	X;
	UWORD	Y;
    }			iept_Range;	/* 0 is min, these are max	*/
    struct {
	UWORD	X;
	UWORD	Y;
    }			iept_Value;	/* between 0 and iept_Range	*/

    WORD		iept_Pressure;	/* -128 to 127 (unused, set to 0)  */
};


#endif
/*************************************************************/


d22 2
d282 2
d286 1
d289 14
d311 2
a312 19
		DF( printf("amigaM BEHIND\n") );
		it->it_Object1 = (CPTR) IBase->FirstScreen;
		it->it_SubCommand = SDEPTH_TOBACK;

		/* play safe: let this be deferred */
		it->it_IE = &IBase->IECopy;
		CLEARFLAG( it->it_Flags, ITF_DONOTDEFER );
	    }
	    doit = TRUE;
	}
	else if ( code == IBase->WBtoFCode )
	{
	    if ( ( IBase->FirstScreen )
		 && ! TESTFLAG( ie->ie_Qualifier, IEQUALIFIER_REPEAT ) 
		 && (it = newIEToken( ie, itDEPTHSCREEN ) ) )
	    {
		DF( printf("amigaN wbfront\n") );
		it->it_Object1 = (CPTR) NULL;	/* will try WB	*/
		it->it_SubCommand = SDEPTH_TOFRONT;
d317 1
a317 2
	    }
	    doit = TRUE;
a318 1

d426 1
a426 5
    struct Point	mousecoord;
    struct IEPointerTablet	*iept;
    struct IEPointerPixel	*iepp;
    struct Rectangle		mlimits;
    int				range;
d428 1
d440 2
d452 4
d480 56
d537 36
d576 1
a576 1
	TESTFLAG( ie->ie_Qualifier, IEQUALIFIER_RELATIVEMOUSE ), compatible );
d584 1
a584 1
newPointerPos( newcoord, ie, currpoint,  relative, compatible )
d588 1
d612 3
d636 4
a639 1
	 * Bend over...
d641 1
a641 1
	if ( compatible )
d643 1
a643 1
	    addButtonEvent( maybecloneie );
d723 1
a723 1
    addButtonEvent( ie );
d732 1
a732 1
addButtonEvent( ie )
d734 1
d740 1
a748 1

d810 6
a815 1
	    /* go back and eunuch the itMOUSEMOVE event	*/
d819 7
a825 1
	    newIEToken( cloneie, extracommand );
@


38.2
log
@Renamed IScreenDepth() controls.
@
text
@d5 1
a5 1
 *  $Id: ihfront.c,v 38.1 91/07/25 15:02:34 peter Exp Locker: peter $
a702 1
    struct IntuitionBase	*IBase = fetchIBase();
@


38.1
log
@Uses new S_TOFRONT and S_TOBACK labels.
@
text
@d5 1
a5 1
 *  $Id: ihfront.c,v 38.0 91/06/12 14:20:42 peter Exp Locker: peter $
d360 1
a360 1
		it->it_SubCommand = S_TOBACK | S_DEPTHFAMILY;
d376 1
a376 1
		it->it_SubCommand = S_TOFRONT | S_DEPTHFAMILY;
@


38.0
log
@Initial V38 check-in (matches V37 release).
@
text
@d5 1
a5 1
 *  $Id: ihfront.c,v 1.20 91/04/05 16:17:50 peter Exp $
d360 1
a360 1
		it->it_SubCommand = IBEHIND;
d376 1
a376 1
		it->it_SubCommand = IUPFRONT;
@
