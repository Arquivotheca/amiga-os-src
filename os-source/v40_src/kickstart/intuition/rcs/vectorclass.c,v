head     38.17;
branch   ;
access   ;
symbols  V40_85:38.17 V40_71:38.16 V40_68:38.16 V40_65:38.16 V40_47:38.16 V40_45:38.16 V40_37:38.16 V40_34:38.16 V40_29:38.16 V39_2415:38.16 V39_2369:38.16 V39_2339:38.16 V39_2332:38.16 V39_2275:38.16 V39_2256:38.16 V39_2210:38.16 V39_2192:38.16 V39_2084:38.16 V39_2082:38.16 V39_2076:38.16 V39_2073:38.16 V39_2058:38.16 V39_2051:38.16 V39_2031:38.16 V39_2017:38.16 V39_2012:38.15 V39_1985:38.15 V39_1933:38.15 V39_1819:38.15 V39_1805:38.15 V39_1783:38.15 V39_1695:38.14 V39_1621:38.12 V39_1620:38.12 V39_1508:38.11 V39_1485:38.11 V39_1461:38.11 V39_1458:38.11 V39_1456:38.11 V39_1405:38.11 V39_1368:38.11 V39_1360:38.11 V39_1324:38.11 V39_1147:38.9 V39_1143:38.9 V39_1141:38.9 V39_1120:38.8 V39_1116:38.8 V39_1104:38.8 V39_1100:38.8 V39_1078:38.8 V39_1073:38.8 V39_757:38.8 V39_702:38.7 V39_557:38.7 V39_553:38.7 V39_551:38.7 V39_510:38.7 V39_495:38.7 V39_416:38.7 V39_383:38.7 V39_371:38.7 V39_336:38.7 V39_323:38.6 V39_295:38.6 V39_277:38.6 V39_254:38.6 V39_222:38.5 V39_185:38.4 V39_171:38.3 V39_161:38.2 V38_159:38.2 V38_116:38.2 V38_59:38.2;
locks    ; strict;
comment  @*   @;


38.17
date     93.05.05.10.44.24;  author peter;  state Exp;
branches ;
next     38.16;

38.16
date     92.08.06.16.59.36;  author peter;  state Exp;
branches ;
next     38.15;

38.15
date     92.07.17.17.31.22;  author peter;  state Exp;
branches ;
next     38.14;

38.14
date     92.07.08.16.20.07;  author peter;  state Exp;
branches ;
next     38.13;

38.13
date     92.07.07.15.26.11;  author peter;  state Exp;
branches ;
next     38.12;

38.12
date     92.06.23.17.22.46;  author peter;  state Exp;
branches ;
next     38.11;

38.11
date     92.05.20.15.23.18;  author peter;  state Exp;
branches ;
next     38.10;

38.10
date     92.05.15.14.10.15;  author peter;  state Exp;
branches ;
next     38.9;

38.9
date     92.05.01.13.55.48;  author peter;  state Exp;
branches ;
next     38.8;

38.8
date     92.03.26.16.40.39;  author peter;  state Exp;
branches ;
next     38.7;

38.7
date     92.01.28.12.40.14;  author peter;  state Exp;
branches ;
next     38.6;

38.6
date     91.11.15.18.54.26;  author peter;  state Exp;
branches ;
next     38.5;

38.5
date     91.11.11.13.42.10;  author peter;  state Exp;
branches ;
next     38.4;

38.4
date     91.10.17.14.27.13;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     91.09.23.12.29.28;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     91.06.24.12.16.33;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.06.12.15.13.32;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.12.14.34.34;  author peter;  state Exp;
branches ;
next     ;


desc
@@


38.17
log
@No longer leave the class semaphore locked if TmpRas fails to alloc.
@
text
@/*
 *	$Id: vectorclass.c,v 38.16 92/08/06 16:59:36 peter Exp Locker: peter $
 *
 *	scaleable images.
 *
 *	(C) Copyright 1989, 1990 Commodore-Amiga, Inc.
 *	    All Rights Reserved Worldwide
 */

#include "intuall.h"
#include <exec/memory.h>
#include "classusr.h"
#include "classes.h"
#include "imageclass.h"
#include "newlook.h"
#include <graphics/gfxmacros.h>
#include "vectorclass.h"

/* Scales a coordinate in source size to dest size.
 * This routine was smaller as a macro, until we added
 * the rounding.
 */

LONG Scale(sourcesize,destsize,coord)
LONG sourcesize;
LONG destsize;
LONG coord;
{
    return( ( ((sourcesize-1) >> 1) + ( (destsize-1) * coord ) ) / (sourcesize-1) );
}


#define OUT printf

#define IM(o)	((struct Image *) (o))

#define	D(x)		;
#define	DS(x)		;
#define	DS5(x)		;
#define	DM(x)		;
#define DO(x)		;
#define	DV(x)		;
#define DPOLY(x)	;

/* No sysiclass image currently uses more than 10 vectors, so double
 * that is a nice safe number.
 * The size of the area-buffer is 5 bytes per vector, but in WORDs.
 */

#define NUM_AREAVECTORS	20
#define AREA_WORDSIZE	( ( ( NUM_AREAVECTORS ) * 5 ) / 2 )

/* sysiclass per-object instance data */
struct SysIData {
    UWORD *si_ImageData[VS_NUMSTATES];/* ImageData for each visual state */
    UWORD si_Depth;		/* Depth of image */
    UBYTE si_States;		/* Visual states available */
};

/* class work area */
struct SysIClassData {
    struct SignalSemaphore scd_Sem;	/* Semaphore for lockout */

    UWORD scd_Width;		/* Width of work area */
    UWORD scd_Height;		/* Height of work area */
    UWORD scd_Depth;		/* Depth of work area */

    struct BitMap scd_BM;	/* Image's BitMap */
    struct RastPort scd_RP;	/* Image's RastPort */

    struct TmpRas scd_TmpRas;	/* Flood Fill TmpRas */
    UBYTE *scd_TmpRasPlane;	/* Flood Fill workspace */

    struct AreaInfo scd_Area;	/* Area Fill AreaInfo */
    WORD scd_Array[ AREA_WORDSIZE ];	/* Area Fill workspace */
};

extern struct Vector vdepth[];
extern struct Vector vsdepth[];
extern struct Vector vzoom[];
extern struct Vector vclose[];
extern struct Vector vsize[];
extern struct Vector upar[];
extern struct Vector dnar[];
extern struct Vector lfar[];
extern struct Vector rtar[];
extern struct Vector ckmk[];
extern struct Vector mutx[];
extern struct Vector mchk[];
extern struct Vector amky[];


/* DEPTH gadget */
#define VDEPTH_COUNT	9
#define VDEPTH_DW	24
#define VDEPTH_DH	11

/* Screen DEPTH gadget */

#define VSDEPTH_COUNT	9

#define VSDEPTH_DW	23
#define VSDEPTH_DH	11

/* ZOOM gadget */

#define VZOOM_COUNT	6
#define VZOOM_DW	24
#define VZOOM_DH	11

/* CLOSE gadget */
#define VCLOSE_COUNT	5
#define VCLOSE_DW	20
#define VCLOSE_DH	11

/* SIZING gadget 05/31/90 */

#define VSIZE_COUNT	4
#define VSIZE_DW	18
#define VSIZE_DH	10

/* UP ARROW gadget 05/31/90 */

#define UPAR_COUNT	2
#define UPAR_DW		18
#define UPAR_DH		11

/* DOWN ARROW gadget 05/31/90 */
/* share the up arrows' background rectangle */
/* reversed the Y of the UP arrow */

#define DNAR_COUNT	2
#define DNAR_DW		18
#define DNAR_DH		11

/* LEFT ARROW gadget 05/31/90 */

#define LFAR_COUNT	2
#define LFAR_DW		16
#define LFAR_DH		10

/* RIGHT ARROW gadget 05/31/90 */
/* share the LEFT arrows' background rectangle */
/* reversed the X of the LEFT arrow */

#define RTAR_COUNT	2
#define RTAR_DW		16
#define RTAR_DH		10


/* CHECKMARK 05/31/90 */

#define CKMK_COUNT	1
#define CKMK_DW		26
#define CKMK_DH		11

/* MUTUAL EXCLUDE 05/31/90 */

#define MUTX_COUNT	9
#define MUTX_DW		17
#define MUTX_DH		9

/* MENU-CHECKMARK 1-May-91 */

#define MCHK_COUNT	1
#define MCHK_DW		15
#define MCHK_DH		8

/* AMIGAKEY 1-May-91 */

#define AMKY_COUNT	3
#define AMKY_DW		45
#define AMKY_DH		15

struct VectorInfo VectorImages[] =
{
    /* NB: Depth width (24 or 18) is also coded into ezreq.c in the call
     * to reqTitleLength().
     */
    {	/* DEPTHIMAGE */
	{23+1,17+1,23+1,},	/*  +1 for the part of the groove in the drag */
	{11,11,11},
	vdepth,
	VDEPTH_DW, VDEPTH_DH,
	VDEPTH_COUNT,
	VS_WBORDERIMG,
	VIB_HRIGHT,
	VIF_SPECIFYHEIGHT,
    },
    {	/* ZOOMIMAGE */
	{23+1,17+1,23+1,},
	{11,11,11,},
	vzoom,
	VZOOM_DW, VZOOM_DH,
	VZOOM_COUNT,
	VS_WBORDERIMG,
	VIB_HRIGHT,
	VIF_SPECIFYHEIGHT,
    },
    {	/* SIZEIMAGE */
	{18,13,18,},
	{10,11,10,},
	vsize,
	VSIZE_DW, VSIZE_DH,
	VSIZE_COUNT,
	VS_NORMAL | VS_INANORMAL,
	VIB_BRCORN,
	0,
    },
    {	/* CLOSEIMAGE */
	{19+1,14+1,19+1,},
	{11,11,11,},
	vclose,
	VCLOSE_DW, VCLOSE_DH,
	VCLOSE_COUNT,
	VS_WBORDERIMG,
	VIB_HLEFT,
	VIF_SPECIFYHEIGHT,
    },
    {	/* SDEPTHIMAGE */
	{23,17,23,},
	{11,11,11,},
	vsdepth,
	VSDEPTH_DW, VSDEPTH_DH,
	VSDEPTH_COUNT,
	VS_NORMAL | VS_SELECTED,
	VIB_3D,
	VIF_SPECIFYHEIGHT,
    },
    {	/* LEFTIMAGE */
	{16,16,23,},
	{10,11,22,},
	lfar,
	LFAR_DW, LFAR_DH,
	LFAR_COUNT,
	VS_WBORDERIMG,
	VIB_HORIZ,
	0,
    },
    {	/* UPIMAGE */
	{18,13,23,},
	{11,11,22,},
	upar,
	UPAR_DW, UPAR_DH,
	UPAR_COUNT,
	VS_WBORDERIMG,
	VIB_VERT,
	0,
    },
    {	/* RIGHTIMAGE */
	{16,16,23,},
	{10,11,22,},
	rtar,
	RTAR_DW, RTAR_DH,
	RTAR_COUNT,
	VS_WBORDERIMG,
	VIB_HORIZ,
	0,
    },
    {	/* DOWNIMAGE */
	{18,13,23,},
	{11,11,22,},
	dnar,
	DNAR_DW, DNAR_DH,
	DNAR_COUNT,
	VS_WBORDERIMG,
	VIB_VERT,
	0,
    },
    {	/* CHECKIMAGE */
	{26,26,26,},
	{11,11,11,},
	ckmk,
	CKMK_DW, CKMK_DH,
	CKMK_COUNT,
	VS_NORMAL | VS_SELECTED,
	VIB_THICK3D,
	VIF_SPECIFYWIDTH | VIF_SPECIFYHEIGHT,
    },
    {	/* MXIMAGE */
	{17,17,17,},
	{9,9,9,},
	mutx,
	MUTX_DW, MUTX_DH,
	MUTX_COUNT,
	VS_NORMAL |VS_SELECTED,
	NULL,
	VIF_SPECIFYWIDTH | VIF_SPECIFYHEIGHT,
    },
    {	/* MENUCHECK */
	{15,9,15,},
	{8,8,8,},
	mchk,
	MCHK_DW, MCHK_DH,
	MCHK_COUNT,
	VS_NORMAL,
	VIB_INMENU,
	VIF_REFFONT | VIF_SPECIFYWIDTH | VIF_SPECIFYHEIGHT | 1 /* VIF_WMULTIPLY */,
    },
    {	/* AMIGAKEY */
	{23,14,23,},
	{8,8,8,},
	amky,
	AMKY_DW, AMKY_DH,
	AMKY_COUNT,
	VS_NORMAL,
	VIB_INMENU,
	VIF_REFFONT | VIF_SPECIFYWIDTH | VIF_SPECIFYHEIGHT | 2 /* VIF_WMULTIPLY */,
    },
};

VOID Draw1P3DBorder();
void myRectangle();
VOID drawVectorImage();
BOOL setState();
BOOL allocRenderStuff();
VOID freeRenderStuff();
BOOL allocImageMem();
VOID freeImageMem();

#define myEnd	stubReturn
int	stubReturn();
int	Move();
int	Draw();
int	AreaMove();
int	AreaDraw();
int	RectFill();
int	AreaEnd();

/* add the Vector image class to the system */
Class
*initSysIClass()
{
    ULONG dispatchSysI();
    Class *makePublicClass();
    Class *cl = NULL;
    struct SysIClassData *scd;
    extern UBYTE	*SysIClassName;
    extern UBYTE	*ImageClassName;

    if ( scd = (struct SysIClassData *) 	
      AllocMem( sizeof( struct SysIClassData ), MEMF_CLEAR | MEMF_PUBLIC ) )
    {
    	if ( cl = makePublicClass( SysIClassName, ImageClassName,
			    sizeof(struct SysIData), dispatchSysI ) )
	{
	    /* initialize the semaphore */
	    InitSemaphore( &scd->scd_Sem );

	    /* set up class data */
	    cl->cl_UserData = (ULONG) scd;

	    DO( OUT("added %s\n", SysIClassName));

	    return( cl );
	}
	else
	{
	    /* free the unused work area */
	    FreeMem( scd, sizeof *scd );
	}
    }
    return( cl );
}


/* Class dispatcher for sysimageclass.
 *
 * OM_NEW causes the rendering of the vector description into a bitmap
 *     for each supported state.
 * OM_DRAW causes the appropriate bitmap to be selected as the ImageData,
 *     and then imageclass draws it.
 * OM_DISPOSE throws everything away.
 *
 * No other methods are in use.
 *
 */

ULONG
dispatchSysI( cl, o, msg )
Class	*cl;
Object	*o;
Msg	msg;
{
    struct TagItem *tags;
    ULONG size;
    LONG width, height;
    ULONG which;
    struct VectorInfo *vi;
    Object *newobj = NULL;
    struct DrawInfo *dri;

    BOOL createStateImagery();

    switch ( msg->MethodID )
    {
    case OM_NEW:
	DO ( OUT ("\nvectorclass: OM_NEW\n"));

	tags = ((struct opSet *) msg)->ops_AttrList;

	/* now set the size and whatever else I want	 */
	which = GetUserTagData( SYSIA_Which, ~0, tags );

	dri = (struct DrawInfo *)GetUserTagData0( SYSIA_DrawInfo, tags );
	size = SYSISIZE_MEDRES;
	if ( ( dri ) && ( dri->dri_Resolution.X > MOUSESCALEX ) )
	{
	    size = SYSISIZE_LOWRES;
	}
	size = GetUserTagData( SYSIA_Size, size, tags );

	D( kprintf( "dXSysI: which %ld, size %ld\n", which, size ) );

	/* The SYSIA_Which space is sparse, and must be mapped into an index
	 * into VectorImages.
	 * WHICH       VECTORIMAGES INDEX
	 * 0 to 3   => 0 to 3
	 * 4        => missing
	 * 5        => 4
	 * 6 to 9   => missing
	 * 10 to 17 => 5 to 12
	 */
	if ( (which > 17) || (which == 4) || ( (which > 5) && (which < 10) ) )
	{
	    D( kprintf ("dXSysI: OtherImage\n") );
	    return (NULL);
	}
	else if (which == 5)
	{
	    which--;
	}
	else if (which > 5)
	{
	    which -= 5;
	}

	vi = &VectorImages[ which ];

	/* Defaults come from the table. */
	width = vi->vi_Width[ size ];
	height = vi->vi_Height[ size ];

	if ( TESTFLAG( vi->vi_Flags, VIF_REFFONT ) )
	{
	    struct TextFont *font;
	    LONG widthmul;

	    /* Size is relative to the specified font, so derive it from that.
	     * If SYSIA_ReferenceFont is NULL or missing, then use the DrawInfo
	     * font, if available.
	     */
	    font = (struct TextFont *)GetUserTagData0( SYSIA_ReferenceFont, tags );
	    if ( ( !font ) && ( dri ) )
	    {
		font = dri->dri_Font;
	    }

	    if ( font )
	    {
		struct RastPort tempRP;

		InitRastPort( &tempRP );
		SetFont( &tempRP, font );
		widthmul = vi->vi_Flags & VIF_WMULTIPLY;  /* 1 or 2 * em-space */
		/* These magic scaling values are designed to provide
		 * reasonable appearance combined with roughly compatible
		 * dimensions to V37 and earlier.
		 */
		width = widthmul * TextLength( &tempRP, "m", 1 ) + 7;

		height = imax(8, font->tf_Baseline);
	    }
	}
	if ( TESTFLAG( vi->vi_Flags, VIF_SPECIFYWIDTH ) )
	{
	    /* Allowed to override width */
	    width = GetUserTagData(IA_WIDTH, width, tags);
	}
	if ( TESTFLAG( vi->vi_Flags, VIF_SPECIFYHEIGHT ) )
	{
	    /* Allowed to override height */
	    height = GetUserTagData(IA_HEIGHT, height, tags);
	}

	/* send message to superclass asking for new object */
	if (newobj = (Object *) SSM (cl, o, msg))
	{
	    /* zoom & depth have to be shifted by 1 pixel
	     * for the groove in the drag bar
	     */
	    if ( which < 2 )
	    {
		IM(newobj)->LeftEdge = -1;
	    }
	    /* OK, let's attempt to create the imagery for each
	     * supported state of this image.
	     */
	    if ( !createStateImagery(
		    IM(newobj),			/* Object is an image */
		    INST_DATA(cl, newobj),	/* Its instance data */
		    (struct SysIClassData *)cl->cl_UserData,	/* Class data */
		    vi, width, height, dri ) )
	    {
		/* createStateImagery() cleans up after itself, but now
		 * we must dispose what the class mechanism has
		 * done so far, and fail
		 */
		CoerceMessage(cl, newobj, OM_DISPOSE);
		return( NULL );
	    }
	}

	/* return the new object (an Image) */
	return ((ULONG) newobj);

    case IM_DRAW:
	DO ( OUT ("vectorclass: IM_DRAW\n"));
	return ( (ULONG) drawSysI( cl, o, msg ) );

    case OM_DISPOSE:
	DO ( OUT ("vectorclass: OM_DISPOSE\n"));

	/* get a pointer to the instance data */

	/* free the image data */
	freeImageMem( (struct SysIData *)INST_DATA(cl,o) );

#if 0
	/* LOOK:  We're falling through to the default case! */
	/* tell the super class to dispose of the remainder */
	return( (ULONG) SSM (cl, o, msg) );
#endif

   /* Be careful: OM_DISPOSE relies on falling through to here */
    default:
	/* pass anything else to our superclass */
	DO ( OUT ("vectorclass: MethodID=%ld\n", (LONG) msg->MethodID));
	return( (ULONG) SSM (cl, o, msg) );
    }
}

/* drawSysI() is the actual render routine that puts the system image up
 * in the requested state.  The actual bitmaps for each supported state
 * were previously allocated.  All this routine has to do is to pick the
 * correct state, select the corresponding bitmap, and let our superclass
 * (imageclass) just draw the sucker.
 */

drawSysI( cl, o, msg )
Class		*cl;
Object		*o;
struct impDraw	*msg;
{
    struct SysIData *si = INST_DATA(cl,o);
    ULONG state, drawstate = msg->imp_State;
    BOOL super = FALSE;

    /* The supported IDS states are IDS_NORMAL, IDS_SELECTED,
     * and IDS_INACTIVENORMAL.  Anything else, we render as
     * IDS_NORMAL and let the superclass handle the state...
     */

    if ( ( drawstate == IDS_NORMAL ) || ( drawstate == IDS_SELECTED ) )
    {
	/* For NORMAL and SELECTED, the IDS values equate to the VSB values */
	state = drawstate;
    }
    else if ( drawstate == IDS_INACTIVENORMAL )
    {
	state = VSB_INANORMAL;
    }
    else
    {
	state = VSB_NORMAL;
	/* Let superclass try to handle the state */
	super = TRUE;
    }

    /* Set up the image for the requested visual state.  If that
     * state is not supported, we get VSB_NORMAL and let the
     * superclass handle the state...
     */
    super |= setState( IM(o), si, state, NULL );

    /*
     * if it is a supported state, then tell the superclass to draw it
     * normally (i.e. force IDS_NORMAL).  Otherwise, let the superclass
     * attempt to handle the specified state.
     */
    if (!super)
	msg->imp_State = IDS_NORMAL;

    DO( OUT ("drawSysI: state %ld (%ld)\n", msg->imp_State, drawstate));

    /* super away */
    SSM( cl, o, msg );

    /* restore stuff */
    msg->imp_State = drawstate;

    return( 1 );
}


/* Set the image data to the correct visual state.
 * Returns TRUE if the requested state is not supported, else FALSE.
 * NB: if scd is non-NULL, the scd_Sem Semaphore had better be held!
 */
BOOL
setState( im, si, state, scd )
struct Image *im;
struct SysIData *si;
LONG state;
struct SysIClassData *scd;
{
    /* If the state is not supported, we'll set this to TRUE,
     * indicating we expect the superclass to handle this state
     */
    BOOL super = FALSE;

    /* make sure that there is data for the selected state */
    if ( !( si->si_ImageData[state] ) )
    {
	super = TRUE;
	state = VSB_NORMAL;
    }

    /* point the imagedata field to the correct data block */
    im->ImageData = si->si_ImageData[ state ];
    DS( printf("setState, state %lx data %lx\n", state,im->ImageData ) );

    /* map data to bitmap planes? */
    if ( scd )
    {
	LONG image_data;
	WORD i, p;

	image_data = (LONG) im->ImageData;	/* pointer to the image data */
	p = RASSIZE( im->Width, im->Height );	/* plane size */

	/* setup the bitmap planes to point to the image data */
	for ( i = 0; i < si->si_Depth; i++ )
	{
	    scd->scd_BM.Planes[i] = (PLANEPTR) image_data;
	    image_data += p;
	}
    }

    return( super );
}


/* createStateImagery() get memory for each supported state,
 * and draws the appropriate image into that memory.
 */

BOOL createStateImagery( im, si, scd, vi, width, height, dri )
struct Image *im;
struct SysIData *si;
struct SysIClassData *scd;
struct VectorInfo *vi;
LONG width;
LONG height;
struct DrawInfo *dri;
{
    BOOL success = TRUE;

    si->si_States = vi->vi_States;
    si->si_Depth = dri->dri_Depth;
    im->Width = width;
    im->Height = height;
    /* set the unused image fields */
    im->PlanePick = (1 << si->si_Depth) - 1;
    im->PlaneOnOff = 0;
    im->NextImage = NULL;

    /* allocate the image data */
    success = allocImageMem( im, si );

    if ( success )
    {
	/* lock out all else from the SysIClass work area */
	ObtainSemaphore( &scd->scd_Sem );

	/* attempt to allocate the stuff we need for rendering */
	if ( success = allocRenderStuff( im, si, scd ) )
	{
	    LONG i;
	    ULONG state, states;

	    states = si->si_States;

	    /* setup each visual state */
	    for (i = 0; i < VS_NUMSTATES; i++)
	    {
		DS( printf("RID: state %lx\n", i ) );

		/* get the current flag */
		state = (1 << i);

		/* see if the state is supported */
		if ((states & state) && si->si_ImageData[i])
		{
		    DS( printf("states'n'state, idata at %lx\n",
			    si->si_ImageData[i] ));

		    /* set the current visual state */
		    setState( im, si, i, scd );

		    /* Let's actually turn the vector description
		     * for this state into a bitmap
		     */
		    drawVectorImage( &scd->scd_RP, vi,
			im->Width, im->Height, i, dri );
		}
		DS(else
		{
		    printf("RID:  Unsupported state %ld\n",i);
		})
	    }
	    /* free the work area */
	    freeRenderStuff( scd );
	}
	/* release the lock on the class data */
	ReleaseSemaphore( &scd->scd_Sem );
    }

    if ( !success )
    {
	freeImageMem( si );
    }

    return( success );
}

/* allocRenderStuff() sets up the stuff we need in order to render.
 * This consists initializing a BitMap, RastPort, and TmpRas, and
 * allocating a TmpRasPlane.  All this stuff (except the TmpRas plane)
 * is kept in the per-class data (SysIClassData) and arbitrated by a
 * semaphore.  Note that the BitMap planes are per image, thus allocated
 * by allocImageMem() (the pointers are established by setState().)
 */

BOOL
allocRenderStuff( im, si, scd )
struct Image *im;
struct SysIData *si;
struct SysIClassData *scd;
{
    struct BitMap *bm = &(scd->scd_BM);
    WORD width, height, raster_size;

    /* preset the variables */
    width = im->Width;
    height = im->Height;

    /* Initialize the bitmap */
    InitBitMap( bm, si->si_Depth, width, height );

    /* initialize the work rastport */
    InitRastPort( &scd->scd_RP );

    /* Link them up */
    scd->scd_RP.BitMap = &(scd->scd_BM);

    /* initialize the area fill workspace */
    clearWords( scd->scd_Array, AREA_WORDSIZE );
    InitArea( &scd->scd_Area, scd->scd_Array, NUM_AREAVECTORS );
    scd->scd_RP.AreaInfo = &scd->scd_Area;

    /* NB: Nothing above this point can fail! */

    /* obtain area fill resources */

    raster_size = RASSIZE( width, height );

    /* The free code structure basically depends on the fact that
     * TmpRasPlane is the only allocation here
     */
    if (scd->scd_TmpRasPlane = (UBYTE *) AllocVec( raster_size, MEMF_CHIP|MEMF_CLEAR  ) )
    {
	/* Initialize Flood Fill Area */
	InitTmpRas( &scd->scd_TmpRas, scd->scd_TmpRasPlane, raster_size );
	scd->scd_RP.TmpRas = &scd->scd_TmpRas;
	return( TRUE );
    }
    return( FALSE );
}


/* Free the stuff in the SysIClass data area used for rendering,
 */
VOID
freeRenderStuff( scd )
struct SysIClassData *scd;
{
    /* Peter 28-Jan-92: we really need to WaitBlit() here! */
    WaitBlit();
    FreeVec( scd->scd_TmpRasPlane );
    scd->scd_TmpRasPlane = NULL;

}


/* Allocate memory for the ImageData of each supported state */
BOOL
allocImageMem( im, si )
struct Image *im;
struct SysIData *si;
{
    WORD state;
    BOOL retval = TRUE;

    /* allocate imagery for each supported state */

    for ( state = 0; state < VS_NUMSTATES; state++ )
    {
	/* see if they asked for this state */
	if ( si->si_States & ( 1 << state ) )
	{
	    /* allocate memory for visual state. */
	    if (! ( si->si_ImageData[ state ] = (UWORD *) AllocVec(
		si->si_Depth * RASSIZE( im->Width, im->Height ),
		MEMF_CHIP | MEMF_CLEAR ) ) )
	    {
		retval = FALSE;
	    }
	}
    }
    return (retval);
}


/* Free ImageData for each state */
VOID
freeImageMem( si )
struct SysIData	*si;
{
    WORD state;

    /* Peter 28-Jan-92: we really need to WaitBlit() here! */
    WaitBlit();
    /* step thru each visual state */
    for ( state = 0; state < VS_NUMSTATES; state++ )
    {
	/* free any visual state that exists */
	FreeVec( si->si_ImageData[ state ] );
	si->si_ImageData[ state ] = NULL;
    }

}


/* drawVectorImage() draws an image based on a VectorInfo description.
 * The image is drawn into the specified rastport, in the specified
 * width and height, using the supplied DrawInfo.
 */

VOID
drawVectorImage( rport, vi, Width, Height, state, dri )
struct RastPort	*rport;
struct VectorInfo *vi;
LONG		Width;
LONG		Height;
ULONG		state;
struct DrawInfo *dri;
{
    WORD x1, y1, x2, y2;	/* current points */
    UBYTE *data;	/* vector point data */

    LONG direction;		/* direction of 3D box */
    ULONG border = 0L;		/* tack on the system 3D? */
    ULONG state_flag;		/* flags for Visual State */
    UWORD *penspec;		/* DrawInfo pens */
    UWORD penindex;		/* remapped pens */
    BOOL mono = TRUE;		/* doing a monochrome screen? */
    UBYTE vectorcount;
    UBYTE designWidth;
    UBYTE designHeight;
    UBYTE opcount;		/* operation counter */
    struct Vector *v;


    extern UBYTE Vbase;		/* Base for vector-data */


    void (*movef)();
    void (*drawf)();
    void (*rectf)();
    void (*aendf)();

    DV(printf("DVA:rp at $%lx, W/H: <%ld,%ld>, state $%lx\n",
	rport, Width, Height, state));

    /* determine direction of 3D border based on visual state */
    direction = 0;
    if (state != VSB_SELECTED)
    {
	direction++;
    }
    
    vectorcount = vi->vi_VCount;
    designWidth = vi->vi_DesignWidth;
    designHeight = vi->vi_DesignHeight;
    v = vi->vi_VList;

    /* get information for determining MONO handling */
    state_flag = (ULONG)(1 << state);
    DS5( if ( state == 5 ) printf("DV state 5, flag %lx\n", state_flag ) );

    {
	if ( dri )
	{
	    penspec = dri->dri_Pens;
	    /*  Use monochrome mode in 1 bitplane or when explicitly requested
		(for non-NewLook custom screens) */
	    if ( ( dri->dri_Flags & DRIF_NEWLOOK ) && ( dri->dri_Depth > 1 ) )
	    {
		mono = FALSE;
	    }
	}
    }

    DV( printf("screen mono:  %lx\n", mono ));
    border = vi->vi_Border;

    /* Fill background to the correct color, which defaults to BACKGROUNDPEN: */
    penindex = BACKGROUNDPEN;

    /* If it is in the window border, then it may need to be in FILLPEN: */
    if ( ( border ) & ( VIB_HLEFT | VIB_HRIGHT | VIB_VERT | VIB_HORIZ | VIB_BRCORN ) )
    {
	/* Inactive-normal and monochrome-selected gadgets stay in BACKGROUNDPEN,
	 * all others need to be in FILLPEN
	 */
	if ( !( (state == VSB_INANORMAL) || ( ( mono ) && ( state == VSB_SELECTED ) ) ) )
	{
	    penindex = FILLPEN;
	}
    }
    else if ( border & VIB_INMENU )
    {
	penindex = BARBLOCKPEN;
    }

    /* blank out the area */
    SetRast( rport, penspec[ penindex ] );

    DV ( OUT ("List 0x%lx  VState 0x%lx (%ld)", v, state_flag, (LONG)state) );

    /* loop thru the list of vectors */
    while (vectorcount--)
    {
	DV( printf("vector %lx\n", v ) );
	DS5( if ( state == 5 ) printf("DV5, v %lx\n", v ) );

	/* check if vector data needed for requested Visual State */
	if (
	       (v->v_States & state_flag) &&
	       ((mono && (v->v_Flags & VF_MONO)) ||
		(!mono && (v->v_Flags & VF_COLOR)))
	  )
	{
	    DS5( if(state==5)printf("vector data needed\n"));
	    /* compute the scaling factor */

	    /* set the RastPort information */
	    SetABPenDrMd( rport, penspec[ v->v_Flags & VF_PENMASK ], 0, JAM1 );

	    DV( printf("I'm happy,  looking at flags %lx\n", v->v_Flags  ));

	    if (v->v_Flags & VF_FILLED)
	    {
		/* fill oriented drawing routines */
		movef = AreaMove;
		drawf = AreaDraw;
		rectf = RectFill;
		aendf = AreaEnd;
	    }
	    else
	    {
		/* line oriented drawing routines */
		movef = Move;
		drawf = Draw;
		rectf = myRectangle;
		aendf = myEnd;
	    }

	    /* Calculate vector-data pointer from base/offset */
	    data = (&Vbase + v->v_DataOffset);
	    /* Number of operations is the first thing stored */
	    opcount = *data++;


	    DV( OUT (" %ld", (LONG)v->v_Flags) );

	    /* determine type of vector data */
	    if (v->v_Flags & VF_POLYGON)
	    {
		/* just like DrawBorder */
		x1 = Scale(designWidth, Width, (*data++));
		y1 = Scale(designHeight,Height,(*data++));
		DPOLY( kprintf( "MOVE: %ld,%ld\n", x1, y1 ) );
		( *movef )( rport, x1, y1 );
		/* There are opcount vertices.  So we do one movef,
		 * followed by opcount-1 drawf's.
		 * SUBTLE:  We use PREDECREMENT to give us opcount-1
		 * iterations
		 */
		while (--opcount)
		{
		    x1 = Scale(designWidth, Width, (*data++));
		    y1 = Scale(designHeight,Height,(*data++));
		    DPOLY( kprintf( "DRAW: %ld,%ld\n", x1, y1 ) );
		    ( *drawf )( rport, x1, y1 );
		}
		DPOLY( kprintf( "END\n" ) );
		( *aendf )( rport );
		DPOLY( kprintf( "A-ok\n" ) );
	    }
	    else /* VF_RECTANGLE (i.e. zero) */
	    {
		/*  There are 'opcount' rectangle-quartets */
		while (opcount--)
		{
		    x1 = Scale(designWidth, Width, (*data++));
		    y1 = Scale(designHeight,Height,(*data++));
		    x2 = Scale(designWidth, Width, (*data++));
		    y2 = Scale(designHeight,Height,(*data++));
		    ( *rectf )( rport, x1, y1, x2, y2 );
		}
	    }
	}
	DS5( else if ( state == 5)
		printf("vector data not needed!, vstate %lx\n",v->v_States));
	v++;
    }

    DV ( OUT ("time for borders\n") );

    /*
     * now do 3D border treatment, do it now so that we don't get overwritten
     * by any special backfill treatment that they may do.
     */

    /* see if it needs a 3D border of the size of the image: */
    if ( border & ( VIB_3D | VIB_VERT | VIB_HORIZ | VIB_BRCORN ) )
    {
	DV( printf(" border 3D\n"));
	/* draw 3D border around image */
	Draw1P3DBorder (penspec, rport, direction, 0, Width, Height);
	/*  Top right corner gadget needs to be in shadow: */
	if ( border & ( VIB_BRCORN | VIB_VERT ) )
	{
	    WritePixelPen( rport, penspec[ SHADOWPEN ], Width - 1, 0);
	}

	if ( border & VIB_VERT )
	{
	    WritePixelPen( rport, penspec[ SHINEPEN ], 0, Height - 1 );
	}

	/*  Special monochrome treatment of edges: */
	if ( mono )
	{
	    /*  The pen color that is not filling the frame: */
	    penindex = BACKGROUNDPEN;
	    if ( state == VSB_INANORMAL )
	    {
		penindex = FILLPEN;
	    }

	    if ( border & ( VIB_VERT | VIB_BRCORN ) )
	    {
		/*  Top edge must be visible */
		MoveDrawPen( rport, penspec[ penindex ],
		    1, 0, Width - 3, 0);
	    }

	    if ( border & ( VIB_HORIZ | VIB_BRCORN ) )
	    {
		/*  Left edge must be visible */
		MoveDrawPen( rport, penspec[ penindex ],
		    0, 1, 0, Height - 3 );
	    }

	    /* penindex is either BACKGROUNDPEN or FILLPEN, which is
	     * the color not filling the frame.  Now we want to use
	     * the color which is filling the frame.
	     * This does the trick nicely:
	     */
	    penindex =  (FILLPEN + BACKGROUNDPEN) - penindex;

	    if ( border & VIB_VERT )
	    {
		/*  Bottom edge must be invisible */
		MoveDrawPen( rport, penspec[ penindex ],
		    1, Height - 1, Width - 3, 0 );
	    }

	    if ( border & VIB_HORIZ )
	    {
		/*  Right edge must be invisible */
		MoveDrawPen( rport, penspec[ penindex ],
		    Width - 1, 1, 0, Height - 3 );
	    }
	}
    }
    /* see if it is a border image placed on the left side */
    else if (border & VIB_HLEFT)
    {
	DV( printf(" border HBL\n"));

	/* system border image, left side */
	Draw1P3DBorder( penspec, rport, direction, 0, Width - 1, Height );

	/*  Bottom left corner gadget needs to shine a pixel: */
	WritePixelPen( rport, penspec[ SHINEPEN ], 0, Height - 1 );

	/* draw the indentation on the right side of the box */
	penindex = SHINEPEN;
	if ( ( mono ) && ( state == VSB_INANORMAL ) )
	{
	    penindex = BACKGROUNDPEN;
	}

	MoveDrawPen( rport, penspec[ penindex ],
	    Width - 1, 1, 0, Height - 3 );

	if ( ( mono ) && ( state != VSB_INANORMAL ) )
	{
	    MoveDrawPen( rport, penspec[ BACKGROUNDPEN ],
		Width - 2, 1, 0, Height - 3 );
	}

	/* Continue the window border in the pixel column that is the
	 * indentation.
	 */
	WritePixelPen( rport, penspec[ SHINEPEN ], Width - 1, 0 );
	WritePixelPen( rport, penspec[ SHADOWPEN ], Width - 1, Height - 1 );
    }
    /* see if it is a border image placed on the right side */
    else if (border & VIB_HRIGHT)
    {
	DV( printf(" border HBR\n"));

	/* system border image, right side */
	Draw1P3DBorder( penspec, rport, direction, 1, Width - 1, Height );

	/* draw the indentation on the left side of the box */
	penindex = SHADOWPEN;
	if ( ( mono ) && ( state == VSB_INANORMAL ) )
	{
	    penindex = BACKGROUNDPEN;
	}

	MoveDrawPen( rport, penspec[ penindex ], 0, 1, 0, Height - 3);

	if ( ( mono ) && ( state != VSB_INANORMAL ) )
	{
	    MoveDrawPen( rport, penspec[ BACKGROUNDPEN ],
		1, 1, 0, Height - 3 );
	}


	/* Continue the window border in the pixel column that is the
	 * indentation.
	 */
	WritePixelPen( rport, penspec[ SHINEPEN ], 0, 0 );
	WritePixelPen( rport, penspec[ SHADOWPEN ], 0, Height - 1 );
    }
    /*  Does it need a thick-sided 3D border? */
    else if ( border & VIB_THICK3D )
    {
	struct IBox box;
	box.Left = box.Top = 0;
	box.Width = Width;
	box.Height = Height;
	embossedBoxTrim( rport, &box,
	    penspec[ SHINEPEN ], penspec[ SHADOWPEN ], JOINS_ANGLED );
    }

    DS5( if ( state == 5 ) printf("done with a 5'er, rp at %lx", rport ) );
    DS5( if ( state == 5 ) printf("bitmap at %lx", rport->BitMap ) );
    DS5( if ( state == 5 ) Debug() );

    DV( printf("DrawVector all done\n"));
}

/* Rendering routines:  here are a bunch of routines that draw things
 * we need.
 */

/* Draw1P3DBorder() draws a 1-pixel thick 3D border.  We should
 * convert to using embossedBoxTrim() instead.
 */

VOID
Draw1P3DBorder( Pens, rp, dir, tx, w, h )
UWORD		*Pens;
struct RastPort *rp;
LONG		dir;
LONG 		tx;
LONG 		w;
LONG 		h;
{
    LONG lrb, ulb;

    ulb = Pens[ SHINEPEN ];
    lrb = Pens[ SHADOWPEN ];
    if (dir == 0)
    {
	ulb = Pens[ SHADOWPEN ];
	lrb = Pens[ SHINEPEN ];
    }

    /* upper left border */
    MoveDrawPen( rp, ulb, tx + w - 1, 0, 1-w, 0 );
    Draw( rp, tx, h - 2 );

    /* lower right border */
    MoveDrawPen( rp, lrb, tx, h - 1, w-1, 0 );
    Draw( rp, tx + w - 1, 1 );
}

/* myRectangle() draws an outline of a rectangle, with parameters
 * compatible with RectFill().
 */
void
myRectangle( rport, x1, y1, x2, y2 )
struct RastPort	*rport;
LONG		x1;
LONG		y1;
LONG		x2;
LONG		y2;
{

    Move( rport, x1, y1 );	/* upper-left */
    Draw( rport, x2, y1 );	/* upper-right */
    Draw( rport, x2, y2 );	/* lower-right */
    Draw( rport, x1, y2 );	/* lower-left */
    Draw( rport, x1, y1 );	/* upper left */
}


/*
 * Space-savings function that writes a pixel in a given color.
 * SIDE-EFFECT:  Changes your RastPort's APen.
 */

WritePixelPen( rport, pen, x, y )
{
    SetAPen( rport, pen );
    WritePixel( rport, x, y );
}


/*
 * Space-saving function that writes a line in a given color.
 * SIDE-EFFECT:  Affects your RastPort's APen and cursor-position.
 */

MoveDrawPen( rport, pen, x, y, dx, dy )
{
    SetAPen( rport, pen );
    Move( rport, x, y );
    Draw( rport, x+dx, y+dy );
}
@


38.16
log
@Uses GetUserTagData() and GetUserTagData0().
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 38.15 92/07/17 17:31:22 peter Exp Locker: peter $
d316 2
a317 2
BOOL obtainRenderStuff();
VOID releaseRenderStuff();
d683 3
d687 1
a687 1
	if ( success = obtainRenderStuff( im, si, scd ) )
a721 1

d723 1
a723 1
	    releaseRenderStuff( scd );
d725 2
d737 6
a742 7
/* obtainRenderStuff() sets up the stuff we need in order to render.
 * This consists of obtaining a semaphore, then initializing a BitMap,
 * RastPort, and TmpRas, and allocating a TmpRasPlane.  All this stuff
 * (except the TmpRas plane) is kept in the per-class data (SysIClassData)
 * and arbitrated by the semaphore.  Note that the BitMap planes are
 * per image, thus allocated by allocImageMem() (the pointers are established
 * by setState().)
d746 1
a746 1
obtainRenderStuff( im, si, scd )
a753 3
    /* lock out all else from the SysIClass work area */
    ObtainSemaphore( &scd->scd_Sem );

d778 3
a792 1
 * and release the semaphore
d795 1
a795 1
releaseRenderStuff( scd )
a802 2
    /* release the lock on the class data */
    ReleaseSemaphore( &scd->scd_Sem );
@


38.15
log
@Fixed SYSIA_Size default.
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 38.14 92/07/08 16:20:07 peter Exp Locker: peter $
d403 1
a403 1
	which = GetTagData( SYSIA_Which, ~0, tags );
d405 1
a405 1
	dri = (struct DrawInfo *)GetTagData( SYSIA_DrawInfo, NULL, tags );
d411 1
a411 1
	size = GetTagData( SYSIA_Size, size, tags );
d453 1
a453 1
	    font = (struct TextFont *)GetTagData( SYSIA_ReferenceFont, NULL, tags );
d478 1
a478 1
	    width = GetTagData(IA_WIDTH, width, tags);
d483 1
a483 1
	    height = GetTagData(IA_HEIGHT, height, tags);
@


38.14
log
@Now fill sdepth, mx, and checkmark with BACKGROUNDPEN instead of pen zero.
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 38.13 92/07/07 15:26:11 peter Exp Locker: peter $
d404 1
a404 1
	size = GetTagData( SYSIA_Size, SYSISIZE_MEDRES, tags );
d406 6
@


38.13
log
@Narrowed widths of menu-checkmark/Amiga-key.  Changed number of
vectors in radio button.
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 38.12 92/06/23 17:22:46 peter Exp Locker: peter $
d920 1
a920 1
    /* check to see if a background fill was asked for */
d922 12
a933 14
    /* if it is in the window border, then RectFill to the right color */
    if ( ( border = vi->vi_Border ) &
	(VIB_INMENU | VIB_HLEFT | VIB_HRIGHT |
	VIB_VERT | VIB_HORIZ | VIB_BRCORN))
    {
	penindex = FILLPEN;
	if ( (state == VSB_INANORMAL)
	    || ( ( mono ) && ( state == VSB_SELECTED ) ) )
	{
	    penindex = BACKGROUNDPEN;
	}
	if ( border & VIB_INMENU )
	{
	    penindex = BARBLOCKPEN;
d935 4
a938 2
	/* blank out the area */
	SetRast( rport, penspec[ penindex ] );
d940 3
@


38.12
log
@AmigaKey lores width was wrong.
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 38.11 92/05/20 15:23:18 peter Exp Locker: peter $
d159 1
a159 1
#define MUTX_COUNT	5
d298 1
a298 1
	VIF_REFFONT | VIF_SPECIFYWIDTH | VIF_SPECIFYHEIGHT | 2 /* VIF_WMULTIPLY */,
d308 1
a308 1
	VIF_REFFONT | VIF_SPECIFYWIDTH | VIF_SPECIFYHEIGHT | 3 /* VIF_WMULTIPLY */,
d459 1
a459 1
		widthmul = vi->vi_Flags & VIF_WMULTIPLY;  /* 2 or 3 * em-space */
d464 1
a464 5
		if (size == SYSISIZE_LOWRES)
		{
		    widthmul--;
		}
		width = widthmul * TextLength( &tempRP, "m", 1 ) - 1;
@


38.11
log
@Tiny optimization.
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 38.10 92/05/15 14:10:15 peter Exp Locker: peter $
d301 1
a301 1
	{23,15,23,},
@


38.10
log
@Merged sysiclass and vectorclass into a single sysiclass.  Renamed
most flags.
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 38.9 92/05/01 13:55:48 peter Exp Locker: peter $
d1060 1
a1060 1
	if ( ( mono ) && ( border & ( VIB_VERT | VIB_HORIZ | VIB_BRCORN ) ) )
d1083 6
a1088 6
	    /*  The pen color that is filling the frame: */
	    penindex = FILLPEN;
	    if ( state == VSB_INANORMAL )
	    {
		penindex = BACKGROUNDPEN;
	    }
@


38.9
log
@Fixed a bug caused by renaming the VIF_ flags.
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 38.8 92/03/26 16:40:39 peter Exp Locker: peter $
d45 1
a45 1
/* No xsysiclass image currently uses more than 10 vectors, so double
d53 5
a57 6
/* class instance data */
struct VInstData {
    UWORD *vi_ImageData[VIS_NUMSTATES];/* ImageData for each visual state */
    ULONG vi_Size;		/* Size of ImageData */
    UWORD vi_Depth;		/* Depth of image */
    UBYTE vi_States;		/* Visual states available */
d61 2
a62 2
struct VectorClassData {
    struct SignalSemaphore vcd_Sem;	/* Semaphore for lockout */
d64 9
a72 9
    UWORD vcd_Width;		/* Width of work area */
    UWORD vcd_Height;		/* Height of work area */
    UWORD vcd_Depth;		/* Depth of work area */

    struct BitMap vcd_BM;	/* Image's BitMap */
    struct RastPort vcd_RP;	/* Image's RastPort */

    struct TmpRas vcd_TmpRas;	/* Flood Fill TmpRas */
    UBYTE *vcd_WorkSpace;	/* Flood Fill workspace */
d74 2
a75 2
    struct AreaInfo vcd_Area;	/* Area Fill AreaInfo */
    WORD vcd_Array[ AREA_WORDSIZE ];	/* Area Fill workspace */
d78 234
d314 5
a318 1
VOID DrawVectorA();
a319 2
BOOL setVIState();
struct TagItem	*FindTagItem();
d332 1
a332 1
*initVectorIClass()
d334 2
a335 2
    ULONG dispatchVectorI();
    Class *makePublicClass ();
d337 2
a338 2
    struct VectorClassData *vcd;
    extern UBYTE	*VectorIClassName;
d341 2
a342 2
    if (vcd = (struct VectorClassData *) 	
      AllocMem (sizeof (struct VectorClassData), MEMF_CLEAR | MEMF_PUBLIC))
d344 2
a345 2
    	if ( cl  = makePublicClass(  VectorIClassName, ImageClassName,
			    sizeof(struct VInstData), dispatchVectorI ) )
d348 1
a348 1
	    InitSemaphore (&(vcd->vcd_Sem));
d351 1
a351 1
	    cl->cl_UserData = (ULONG) vcd;
d353 1
a353 1
	    DO ( OUT ("added %s\n", VectorIClassName));
d355 1
a355 1
	    return (cl);
d360 1
a360 1
	    FreeMem ((APTR) vcd, sizeof *vcd);
d363 1
a363 1
    return (cl);
d367 1
a367 1
/* Class dispatcher for vectorimageclass.
d380 1
a380 1
dispatchVectorI( cl, o, msg )
d385 5
d391 3
a393 2
    struct VInstData *vi = INST_DATA(cl,o);
    BOOL renderVImages();
d400 84
d487 11
a497 2
	    /* set the attributes of the image */
	    if ( !renderVImages(
d500 2
a501 4
		    (struct VectorClassData *)cl->cl_UserData,	/* Class data */

		    GetTagData( VIA_Packet, NULL, 
			((struct opSet *)msg)->ops_AttrList ) ) )	/* packet */
d503 1
a503 1
		/* renderVImages() cleans up after itself, but now
d517 1
a517 1
	return ( (ULONG) drawVectorI( cl, o, vi, msg) );
d525 1
a525 1
	freeImageMem(vi);
d541 6
d548 1
a548 1
drawVectorI( cl, o, vi, msg )
a550 1
struct VInstData *vi;
d553 1
d564 1
a564 1
	/* For NORMAL and SELECTED, the IDS values equate to the VISB values */
d569 1
a569 1
	state = VISB_INANORMAL;
d573 1
a573 1
	state = VISB_NORMAL;
d579 1
a579 1
     * state's not supported, we get VISB_NORMAL and let the
d582 1
a582 1
    super |= setVIState( IM(o), vi, state, NULL );
d585 1
a585 1
     * if it it's a supported state, then tell the superclass to draw it
d592 1
a592 1
    DO( OUT ("drawVectorI: state %ld (%ld)\n", msg->imp_State, drawstate));
d600 1
a600 117
    return (1);
}


/* set up the wrapper needed to render.  This consists of a BitMap
 * RastPort, and TmpRas.  Note that the BitMap has no planes until
 * setVIState() establishes them.
 */

BOOL
allocWrapper( im, vi, vcd )
struct Image *im;
struct VInstData *vi;
struct VectorClassData *vcd;
{

    struct BitMap *bm = &(vcd->vcd_BM);
    WORD i, width, height, raster_size;

    /* preset the variables */
    width = im->Width;
    height = im->Height;

    /* Initialize the bitmap */
    InitBitMap( bm, vi->vi_Depth, width, height );

    /* initialize the work rastport */
    InitRastPort( &vcd->vcd_RP );

    /* Link them up */
    vcd->vcd_RP.BitMap = &(vcd->vcd_BM);

    /* initialize the area fill workspace */
    for ( i = 0; i < AREA_WORDSIZE; i++ )
	vcd->vcd_Array[i] = 0;
    InitArea( &vcd->vcd_Area, vcd->vcd_Array, NUM_AREAVECTORS );
    vcd->vcd_RP.AreaInfo = &vcd->vcd_Area;

    /* NB: Nothing above this point can fail! */

    /* obtain area fill resources */

    /* how big are the planes? */
    raster_size = RASSIZE( width, height );

    if (vcd->vcd_WorkSpace = (UBYTE *)
	AllocVec( raster_size, MEMF_CHIP+MEMF_CLEAR  ) )
    {
	/* Initialize Flood Fill Area */
	InitTmpRas( &vcd->vcd_TmpRas, vcd->vcd_WorkSpace, raster_size );

	vcd->vcd_RP.TmpRas = &vcd->vcd_TmpRas;
	return( TRUE );
    }
    return( FALSE );
}


/* free the rendering wrapper */
freeWrapper( vcd )
struct VectorClassData *vcd;
{
    /* Peter 28-Jan-92: we really need to WaitBlit() here! */
    WaitBlit();
    FreeVec( vcd->vcd_WorkSpace );
    vcd->vcd_WorkSpace = NULL;
}


/* Allocate memory for the ImageData of each supported state */
BOOL
allocImageMem( im, vi )
struct Image *im;
struct VInstData *vi;
{
    WORD i;
    BOOL retval = TRUE;

    /* preset the variables */
    vi->vi_Size = vi->vi_Depth * RASSIZE( im->Width, im->Height );

    /* allocate imagery for each supported state */

    for (i = 0; i < VIS_NUMSTATES; i++)
    {
	/* see if they asked for this state */
	if (vi->vi_States & (1 << i))
	{
	    /* allocate memory for visual state. */
	    if (! (vi->vi_ImageData[i] = (UWORD *)
	      AllocMem( vi->vi_Size, MEMF_CHIP | MEMF_CLEAR ) ) )
	    {
		retval = FALSE;
	    }
	}
    }
    return (retval);
}


/* Free ImageData for each state */
VOID
freeImageMem( vi )
struct VInstData	*vi;
{
     WORD cntr;

    /* Peter 28-Jan-92: we really need to WaitBlit() here! */
    WaitBlit();
    /* step thru each visual state */
    for ( cntr = 0; cntr < VIS_NUMSTATES; cntr++ )
    {
	/* free any visual state that exists */
	jfreeMem( (APTR) vi->vi_ImageData[cntr], vi->vi_Size );
	vi->vi_ImageData[cntr] = NULL;
    }

d606 1
a606 1
 * NB: if vcd is non-NULL, the vcd_Sem Semaphore had better be held!
d609 1
a609 1
setVIState( im, vi, state, vcd )
d611 1
a611 1
struct VInstData *vi;
d613 1
a613 1
struct VectorClassData *vcd;
d615 3
d621 1
a621 1
    if (!(vi->vi_ImageData[state]))
d624 1
a624 1
	state = IDS_NORMAL;
d628 2
a629 2
    im->ImageData = vi->vi_ImageData[state];
    DS( printf("setVIState, state %lx data %lx\n", state,im->ImageData ) );
d632 1
a632 1
    if (vcd)
d641 1
a641 1
	for (i = 0; i < vi->vi_Depth; i++)
d643 1
a643 1
	    vcd->vcd_BM.Planes[i] = (PLANEPTR) image_data;
d652 2
a653 2
/* Get memory for each supported state, and draw the appropriate
 * image into that memory.
d656 1
a656 1
BOOL renderVImages( im, vi, vcd, vip )
d658 6
a663 3
struct VInstData *vi;
struct VectorClassData *vcd;
struct VIPacket *vip;
a664 1
    struct Vector	*vlist;
d667 4
a670 4
    vi->vi_States = vip->vip_States;
    vi->vi_Depth = vip->vip_DrawInfo->dri_Depth;
    im->Width = vip->vip_Width;
    im->Height = vip->vip_Height;
d672 1
a672 1
    im->PlanePick = (1 << vi->vi_Depth) - 1;
d677 1
a677 1
    success = allocImageMem ( im, vi );
d681 2
a682 7
	/* lock out all else from the global work area */
	ObtainSemaphore (&(vcd->vcd_Sem));

	vlist = vip->vip_VList;
	DV(printf("RID:  vlist at $%lx\n", vlist));
	/* attempt to allocate the wrapper for rendering */
	if ( success = ( vlist && allocWrapper( im, vi, vcd ) ) )
d684 1
a684 1
	     LONG i;
d687 1
a687 1
	    states = vi->vi_States;
d690 1
a690 1
	    for (i = 0; i < VIS_NUMSTATES; i++)
d698 1
a698 1
		if ((states & state) && vi->vi_ImageData[i])
d701 1
a701 1
			    vi->vi_ImageData[i] ));
d704 1
a704 1
		    setVIState( im, vi, i, vcd );
d706 5
a710 4
		    /* draw the imagery */
		    D( printf("go drawv\n"));
		    DrawVectorA( &(vcd->vcd_RP),  vlist,
				 im->Width, im->Height, i, vip );
d719 1
a719 3
	    D( printf("free the wrapper for rendering\n"));
	    freeWrapper( vcd );
	    D( printf("freed.\n"));
a720 7
	DV(else
	{
	    printf("RID:  failed vlist or allocWrapper\n");
	})

	/* release the work area */
	ReleaseSemaphore (&(vcd->vcd_Sem));
d725 1
a725 1
	freeImageMem( vi );
d731 118
d850 7
a856 40
/*****i* vectorclass/DrawVectorA ********************************************
*
*   NAME
*	DrawVectorA - Scale and display a vector image.
*
*   SYNOPSIS
*	DrawVectorA (rp, v, left, top, width, height, state, taglist)
*
*	struct RastPort *rp;
*	struct Vector *v;
*	WORD left, top, width, height;
*	UWORD state;
*	struct TagItem *taglist;
*
*   FUNCTION
*	This function draws a scaleable vector image in a variety of
*	visual states.  Requires a valid DrawInfo in the taglist
*	using the VIA_DrawInfo tag.
*
*   INPUTS
*	rp	- RastPort to draw vector image into
*	v	- Pointer to a Vector structure
*	left	- The offset that will be added to the images X coords.
*	top	- The offset that will be added to the images Y coords.
*	width	- The scaled output width
*	height	- The scaled output height
*	state	- Visual state selected (see DrawImageState)
*	taglist	- Additional attributes (see vectorclass.h)
*
*   BUGS
*
*   SEE ALSO
*
****************************************************************************
*
* Created:  24-Mar-90, David N. Junod
*
* Having 3D border treatment isn't really appropriate here.  Is it?
*
*/
d859 1
a859 1
DrawVectorA( rport, v, Width, Height, state, vip )
d861 1
a861 1
struct Vector	*v;
d865 1
a865 1
struct VIPacket *vip;
d867 2
a868 2
     WORD x1, y1, x2, y2;	/* current points */
     UBYTE *data;	/* vector point data */
a872 1
    struct RastPort clonerp;	/* copy of RastPort */
a875 4
    void (*movef)();
    void (*drawf)();
    void (*rectf)();
    void (*aendf)();
d880 3
d885 6
d893 1
a893 6
    /* make a copy of the user RastPort.  cloneRP() sets Mask to -1 */
    cloneRP( &clonerp, rport );
    SetAfPt (&clonerp, NULL, 0);
    SetDrPt (&clonerp, ~0);
    BNDRYOFF (&clonerp);
    SetDrMd (&clonerp, JAM2);
d896 1
a896 1
    if (state != VISB_SELECTED)
d901 4
a904 3
    vectorcount = vip->vip_VCount;
    designWidth = vip->vip_DesignWidth;
    designHeight = vip->vip_DesignHeight;
d911 1
a911 3
	struct DrawInfo *dri;

	if ( dri = vip->vip_DrawInfo )
d927 3
a929 3
    if ( ( border = vip->vip_Border ) &
	(VIBORD_INMENU | VIBORD_HLEFT | VIBORD_HRIGHT |
	VIBORD_VERT | VIBORD_HORIZ | VIBORD_BRCORN))
d932 2
a933 2
	if ( (state == VISB_INANORMAL)
	    || ( ( mono ) && ( state == VISB_SELECTED ) ) )
d937 1
a937 1
	if ( border & VIBORD_INMENU )
d942 1
a942 1
	SetRast( &clonerp, penspec[ penindex ] );
d956 2
a957 2
	       ((mono && (v->v_Flags & VIF_MONO)) ||
		(!mono && (v->v_Flags & VIF_COLOR)))
d964 1
a964 1
	    SetABPenDrMd(&clonerp, penspec[ v->v_Flags & VIF_PENMASK ], 0, JAM1 );
d968 1
a968 1
	    if (v->v_Flags & VIF_FILLED)
d994 1
a994 1
	    if (v->v_Flags & VIF_POLYGON)
d1000 1
a1000 1
		(*movef) (&clonerp, x1, y1);
d1011 1
a1011 1
		    (*drawf) (&clonerp, x1, y1);
d1014 1
a1014 1
		(*aendf) (&clonerp);
d1017 1
a1017 1
	    else /* VIF_RECTANGLE (i.e. zero) */
d1026 1
a1026 1
		    (*rectf) (&clonerp, x1, y1, x2, y2);
d1043 1
a1043 1
    if ( border & ( VIBORD_3D | VIBORD_VERT | VIBORD_HORIZ | VIBORD_BRCORN ) )
d1047 1
a1047 1
	Draw1P3DBorder (penspec, &clonerp, direction, 0, Width, Height);
d1049 1
a1049 1
	if ( border & ( VIBORD_BRCORN | VIBORD_VERT ) )
d1051 1
a1051 1
	    WritePixelPen( &clonerp, penspec[ SHADOWPEN ], Width - 1, 0);
d1054 1
a1054 1
	if ( border & VIBORD_VERT )
d1056 1
a1056 1
	    WritePixelPen( &clonerp, penspec[ SHINEPEN ], 0, Height - 1 );
d1060 1
a1060 1
	if ( ( mono ) && ( border & ( VIBORD_VERT | VIBORD_HORIZ | VIBORD_BRCORN ) ) )
d1064 1
a1064 1
	    if ( state == VISB_INANORMAL )
d1069 1
a1069 1
	    if ( border & ( VIBORD_VERT | VIBORD_BRCORN ) )
d1072 1
a1072 1
		MoveDrawPen( &clonerp, penspec[ penindex ],
d1076 1
a1076 1
	    if ( border & ( VIBORD_HORIZ | VIBORD_BRCORN ) )
d1079 1
a1079 1
		MoveDrawPen( &clonerp, penspec[ penindex ],
d1085 1
a1085 1
	    if ( state == VISB_INANORMAL )
d1090 1
a1090 1
	    if ( border & VIBORD_VERT )
d1093 1
a1093 1
		MoveDrawPen( &clonerp, penspec[ penindex ],
d1097 1
a1097 1
	    if ( border & VIBORD_HORIZ )
d1100 1
a1100 1
		MoveDrawPen( &clonerp, penspec[ penindex ],
d1106 1
a1106 1
    else if (border & VIBORD_HLEFT)
d1111 1
a1111 1
	Draw1P3DBorder (penspec, &clonerp, direction, 0, Width - 1, Height);
d1114 1
a1114 1
	WritePixelPen( &clonerp, penspec[ SHINEPEN ], 0, Height - 1);
d1118 1
a1118 1
	if ( ( mono ) && ( state == VISB_INANORMAL ) )
d1123 2
a1124 2
	MoveDrawPen( &clonerp, penspec[ penindex ],
	    Width - 1, 1, 0, Height - 3);
d1126 1
a1126 1
	if ( ( mono ) && ( state != VISB_INANORMAL ) )
d1128 2
a1129 2
	    MoveDrawPen(&clonerp, penspec[ BACKGROUNDPEN ],
		Width - 2, 1, 0, Height - 3);
d1135 2
a1136 2
	WritePixelPen(&clonerp, penspec[ SHINEPEN ], Width - 1, 0);
	WritePixelPen(&clonerp, penspec[ SHADOWPEN ], Width - 1, Height - 1);
d1139 1
a1139 1
    else if (border & VIBORD_HRIGHT)
d1144 1
a1144 1
	Draw1P3DBorder (penspec, &clonerp, direction, 1, Width - 1, Height);
d1148 1
a1148 1
	if ( ( mono ) && ( state == VISB_INANORMAL ) )
d1153 1
a1153 1
	MoveDrawPen( &clonerp, penspec[ penindex ], 0, 1, 0, Height - 3);
d1155 1
a1155 1
	if ( ( mono ) && ( state != VISB_INANORMAL ) )
d1157 2
a1158 2
	    MoveDrawPen( &clonerp, penspec[ BACKGROUNDPEN ],
		1, 1, 0, Height - 3);
d1165 2
a1166 2
	WritePixelPen(&clonerp, penspec[ SHINEPEN ], 0, 0);
	WritePixelPen(&clonerp, penspec[ SHADOWPEN ], 0, Height - 1);
d1169 1
a1169 1
    else if ( border & VIBORD_THICK3D )
d1175 1
a1175 1
	embossedBoxTrim( &clonerp, &box,
d1179 2
a1180 2
    DS5( if ( state == 5 ) printf("done with a 5'er, rp at %lx", &clonerp ) );
    DS5( if ( state == 5 ) printf("bitmap at %lx", clonerp.BitMap ) );
d1186 7
d1195 1
a1195 1
Draw1P3DBorder( Pens, rp, dir, tx, w, h)
d1222 3
a1224 1

d1226 1
a1226 1
myRectangle( rport, x1, y1, x2, y2)
d1234 5
a1238 5
    Move (rport, x1, y1);	/* upper-left */
    Draw (rport, x2, y1);	/* upper-right */
    Draw (rport, x2, y2);	/* lower-right */
    Draw (rport, x1, y2);	/* lower-left */
    Draw (rport, x1, y1);	/* upper left */
@


38.8
log
@Minor optimizations.
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 38.7 92/01/28 12:40:14 peter Exp Locker: peter $
d671 1
a671 1
	    if (v->v_Flags & VIF_FILL)
@


38.7
log
@Added missing WaitBlit() before freeing TmpRas or image data.
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 38.6 91/11/15 18:54:26 peter Exp Locker: peter $
d15 1
d24 4
a27 4
WORD Scale(sourcesize,destsize,coord)
WORD sourcesize;
WORD destsize;
WORD coord;
d55 1
a55 1
    USHORT *vi_ImageData[VIS_NUMSTATES];/* ImageData for each visual state */
d57 1
a57 1
    USHORT vi_Depth;		/* Depth of image */
d65 3
a67 3
    USHORT vcd_Width;		/* Width of work area */
    USHORT vcd_Height;		/* Height of work area */
    USHORT vcd_Depth;		/* Depth of work area */
d351 1
a351 1
	    if (! (vi->vi_ImageData[i] = (USHORT *)
d390 1
a390 1
WORD state;
d462 2
a463 2
	     WORD i;
	    UWORD state, states;
d465 1
a465 1
	    states = (UWORD) vi->vi_States;
d473 1
a473 1
		state = (UWORD) (1 << i);
d563 3
a565 3
WORD		Width;
WORD		Height;
UWORD		state;
d571 1
a571 1
    WORD direction;		/* direction of 3D box */
d750 1
a750 1
	Draw1P3DBorder (penspec, &clonerp, direction, 0, 0, Width, Height);
d814 1
a814 2
	Draw1P3DBorder (penspec, &clonerp, direction,
			0, 0, (SHORT) (Width - 1), Height);
d847 1
a847 2
	Draw1P3DBorder (penspec, &clonerp, direction,
			1, 0, Width - 1, Height);
d874 6
a879 6
	/*  A thick border turns out to be a thin border plus
	    padding on the outsides: */
	Draw1P3DBorder (penspec, &clonerp, 1, 1, 0, Width-2, Height);
	MoveDrawPen( &clonerp, penspec[ SHINEPEN ], 0, 0, 0, Height - 1 );
	MoveDrawPen( &clonerp, penspec[ SHADOWPEN ],
	    Width - 1, 0, 0, Height - 1 );
d891 1
a891 1
Draw1P3DBorder( Pens,  rp, dir, tx, ty, w, h)
d894 4
a897 5
WORD		dir;
WORD 		tx;
WORD 		ty;
WORD 		w;
WORD 		h;
d899 1
a899 1
    WORD lrb, ulb;
d910 2
a911 7
    MoveDrawPen( rp, ulb, tx + (w - 1), ty, 1-w, 0 );
#if 0
    SetAPen (rp, ulb);
    Move (rp, (tx + (w - 1)), ty);
    Draw (rp, tx, ty);
#endif
    Draw (rp, tx, (ty + (h - 2)));
d914 2
a915 7
    MoveDrawPen( rp, lrb, tx, ty + (h - 1), w-1, 0 );
#if 0
    SetAPen (rp, lrb);
    Move (rp, tx, (ty + (h - 1)));
    Draw (rp, (tx + (w - 1)), (ty + (h - 1)));
#endif
    Draw (rp, (tx + (w - 1)), (ty + 1));
d922 4
a925 4
WORD		x1;
WORD		y1;
WORD		x2;
WORD		y2;
@


38.6
log
@Now keep three ImageData pointers per image, not eight.  Saves 40 bytes
per image.
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 38.5 91/11/11 13:42:10 peter Exp Locker: peter $
d323 2
d368 2
@


38.5
log
@A bunch of code optimizations.
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 38.4 91/10/17 14:27:13 peter Exp Locker: peter $
d82 1
a82 1
WORD setVIState();
d215 2
a216 2
    ULONG drawstate = msg->imp_State;
    UWORD state;
d218 3
a220 2
    /* Set up the image for the requested visual state.  We get back
     * that state, or IDS_NORMAL if the state's not supported.
a221 1
    state = setVIState( IM(o), vi, drawstate, NULL );
d223 22
d250 1
a250 1
    if (state == (UWORD) drawstate)
d377 2
a378 3
/* set the image data to the correct visual state
 * Returns that state, but if the requested state is not supported,
 * IDS_NORMAL is returned instead.
d381 1
a381 1
WORD
d388 2
d392 2
d395 1
d418 1
a418 1
    return (state);
d593 1
a593 1
    if (state != IDS_SELECTED)
d630 2
a631 2
	if ( (state == IDS_INACTIVENORMAL)
	    || ( ( mono ) && ( state == IDS_SELECTED ) ) )
d762 1
a762 1
	    if ( state == IDS_INACTIVENORMAL )
d783 1
a783 1
	    if ( state == IDS_INACTIVENORMAL )
d817 1
a817 1
	if ( ( mono ) && ( state == IDS_INACTIVENORMAL ) )
d825 1
a825 1
	if ( ( mono ) && ( state != IDS_INACTIVENORMAL ) )
d848 1
a848 1
	if ( ( mono ) && ( state == IDS_INACTIVENORMAL ) )
d855 1
a855 1
	if ( ( mono ) && ( state != IDS_INACTIVENORMAL ) )
@


38.4
log
@Vectorclass now expects the vector to contain a short-offset to the data.
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 38.3 91/09/23 12:29:28 peter Exp $
a17 8
/* we're going to turn off certain things during
 * integration, for a variety of reasons:
 *	rom space
 *	functionality we don't use (and this isn't public yet)
 *	purging of this rom-class
 *	per-image ram space
 */

d31 1
d81 2
a82 2
VOID FreeVInstData();
WORD SetVIVState();
a88 1
int	DrawEllipse();
a91 1
int	AreaEllipse();
d130 13
d150 2
a151 2
     struct VInstData *vi;
    BOOL setVectorIAttrs();
d161 5
a165 2
	    /* get a pointer to the instance data */
	    vi = INST_DATA (cl, newobj);
d167 2
a168 2
	    /* set the attributes of the image */
	    if ( !setVectorIAttrs (cl, newobj, msg) )
d170 4
a173 1
	    	FreeVInstData( vi );
d184 1
a184 11
	return ((ULONG) drawVectorI (cl, o, msg));
#if 0
    /* Peter 24-Jan-91: We don't support set properly, nor do we use it.
     * What would we do for error checking if it fails?
     */
    case OM_SET:
	SSM(cl, o, msg);
	setVectorIAttrs (cl, o, msg);
	return (1L);
	break;
#endif
a189 1
	vi = INST_DATA (cl, o);
d192 1
a192 1
	FreeVInstData (vi);
d194 2
d197 2
a198 5
	return ((ULONG) SSM (cl, o, msg));

    case OM_GET:
	DO ( OUT ("vectorclass: OM_GET\n"));
	/* else fall-through to superclass default	*/
d200 1
d204 1
a204 1
	return ((ULONG) SSM (cl, o, msg));
a207 34
BOOL setVectorIAttrs( cl,  o,  msg )
Class		*cl;
Object		*o;
struct opSet	*msg;
{
    struct TagItem *NextTagItem();
    BOOL RefreshImageData();
    struct TagItem *tags;
    struct TagItem *tag;
    ULONG tidata;
    struct VInstData *vi;
    BOOL	success = TRUE;

    /* initialize variables */
    tags = msg->ops_AttrList;
    vi = INST_DATA (cl, o);

    /* step through tag list */
    while (tag = NextTagItem (&tags))
    {
	tidata = tag->ti_Data;
	switch (tag->ti_Tag)
	{
	case VIA_States:	/* visual states supported */
	    vi->vi_States = tidata;
	    break;
#if 0
	case VIA_VList:
	    break;
#endif

	case VIA_Width:	/* desired width of image */
	    IM(o)->Width = (USHORT) tidata;
	    break;
d209 1
a209 22
	case VIA_Height:	/* desired height of image */
	    IM(o)->Height = (USHORT) tidata;
	    break;

	case VIA_DrawInfo:
	    vi->vi_Depth =  (( struct DrawInfo * )tidata )->dri_Depth;
	    break;

	} /* end of switch (tag) */

    } /* end of while next tag */

    DO ( OUT ("   Width %ld, Height %ld, Depth %ld,  States 0x%lx\n",
	(LONG)IM(o)->Width, (LONG)IM(o)->Height, (LONG)vi->vi_Depth,
	 (LONG)vi->vi_States) );

    success = (vi->vi_Depth) && RefreshImageData( cl, o, msg );

    return ( success );
}

drawVectorI( cl,  o,  msg  )
d212 1
a214 1
    struct VInstData *vi = INST_DATA (cl, o);
d218 4
a221 2
    /* set up the image for the requested visual state */
    state = SetVIVState ( cl, o, msg, drawstate, FALSE);
d225 2
a226 1
     * normally.  Otherwise, let the superclass attempt it's own magic.
a241 7
/* PRIVATE Initialization Routines */
BOOL
VCDAllocFill ( vcd, width, height )
struct VectorClassData	*vcd;
USHORT			width;
USHORT			height;
{
d243 4
a246 12
    if (vcd->vcd_WorkSpace = (UBYTE *)
	AllocVec( RASSIZE( width, height ), MEMF_CHIP+MEMF_CLEAR  ) )
    {
	/* Initialize Flood Fill Area */
	InitTmpRas (&vcd->vcd_TmpRas, vcd->vcd_WorkSpace,
		    RASSIZE (width, height));

	vcd->vcd_RP.TmpRas = &vcd->vcd_TmpRas;
	return (TRUE);
    }
    return (FALSE);
}
a247 1
/* setup the work area */
d249 4
a252 4
AllocWorkData( cl, o, msg )
Class	*cl;
Object	*o;
Msg	msg;
a253 1
    struct VInstData	*vi = INST_DATA (cl, o);
a254 1
    struct VectorClassData *vcd = (struct VectorClassData *) cl->cl_UserData;
d256 1
a256 2
    WORD i, p, d, w, h;
    LONG image_data;
d259 2
a260 3
    d = vi->vi_Depth;
    w = IM(o)->Width;
    h = IM(o)->Height;
d262 2
a263 2
    /* initialize the bitmap */
    InitBitMap (bm, d, w, h);
d266 4
a269 1
    InitRastPort (&vcd->vcd_RP);
d272 1
a272 1
    for (i = 0; i < AREA_WORDSIZE; i++)
d274 1
a274 1
    InitArea (&vcd->vcd_Area, vcd->vcd_Array, NUM_AREAVECTORS);
d276 2
a277 2
    /* initialize the rastports bitmap */
    vcd->vcd_RP.BitMap = &(vcd->vcd_BM);
d279 1
a279 2
    /* get a pointer on the image data */
    image_data = (LONG) IM(o)->ImageData;
d282 1
a282 1
    p = RASSIZE (w, h);
d284 5
a288 3
    /* point the bitmap planes at the image data */
    for (i = 0; i < d; ++i)
	bm->Planes[i] = (PLANEPTR) (image_data + i * p);
d290 5
a294 3
    /* obtain area fill resources */
    if (!(VCDAllocFill (vcd, w, h)))
	return (FreeWorkData (vcd, vi));
a295 2
    return (TRUE);
}
d297 2
a298 2
/* clear the work area */
FreeWorkData( vcd, vi )
a299 1
struct VInstData	*vi;
d303 1
a304 3
    /* save a step */
    return (FALSE);
}
d306 1
d308 3
a310 4
AllocVInstData( cl, o, msg )
Class	*cl;
Object	*o;
Msg	msg;
a311 1
    struct VInstData	*vi = INST_DATA (cl, o);
d313 1
a313 1
    BOOL retval = FALSE;
d316 1
a316 26
    vi->vi_Size = vi->vi_Depth * RASSIZE (IM(o)->Width, IM(o)->Height);

    /* allocate image data */
    if (vi->vi_ImageData[IDS_NORMAL] =
	(USHORT *) AllocMem (vi->vi_Size, MEMF_CHIP | MEMF_CLEAR))
    {
	/* set the visual state to normal */
	SetVIVState ( cl, o, msg, IDS_NORMAL, FALSE);

	/* allocate additional visual states */
	/* case '0' (IDS_NORMAL) is  done above	*/

	retval = TRUE;
	for (i = 1; i < VIS_NUMSTATES; i++)
	{
	    /* see if they asked for this state */
	    if (vi->vi_States & (1 << i))
	    {
		DS( printf("allocate data for state %ld\n", 1<<i ) );
		/* allocate memory for visual state.  If it can't */
		/* it doesn't bomb, it just decreases functionality */
		if (! (vi->vi_ImageData[i] = (USHORT *)
		  AllocMem (vi->vi_Size, MEMF_CHIP | MEMF_CLEAR) ) )
		{
		    retval = FALSE;
		}
d318 1
a318 2
	    } /* end of visual state */
	    DS( else printf("AVID unsupported state: %lx\n", i ) );
d320 12
a331 1
	} /* end of allocate additional states */
d336 2
d339 1
a339 1
FreeVInstData( vi )
d343 3
a345 2
    /* see if data has been allocated */
    if (vi->vi_Size)
d347 7
a353 12
	/* step thru each visual state */
	for (cntr = 0; cntr < VIS_NUMSTATES; cntr++)
	{
	    /* free any visual state that exists */
	    jfreeMem ((APTR) vi->vi_ImageData[cntr], vi->vi_Size);
	    vi->vi_ImageData[cntr] = NULL;
	}

	/* clear the size varable */
	vi->vi_Size = 0L;
    }
}
d355 5
a359 1
/* set the image data to the correct visual state */
d361 5
a365 6
SetVIVState(  cl, o, msg, vstate, needbm )
Class	*cl;
Object	*o;
Msg	msg;
WORD		vstate;
BOOL		needbm;
a366 3
    WORD state = vstate;
    struct VInstData	*vi = INST_DATA (cl, o);

d372 3
a374 2
    IM(o)->ImageData = vi->vi_ImageData[state];
    DS( printf("SetVIVState, state %lx data %lx\n", state,IM(o)->ImageData ) );
d376 1
a376 1
    if (needbm)
d378 2
a379 9
	 struct VectorClassData *vcd;
	 LONG image_data;
	 struct BitMap *bm;
	 WORD i, p;

	vcd = (struct VectorClassData *) cl->cl_UserData;
	bm = &(vcd->vcd_BM);			/* pointer to the bitmap */
	image_data = (LONG) IM(o)->ImageData;	/* pointer to the image data */
	p = RASSIZE (IM(o)->Width, IM(o)->Height);	/* plane size */
d381 3
d385 5
a389 2
	for (i = 0; i < vi->vi_Depth; ++i)
	    bm->Planes[i] = (PLANEPTR) (image_data + i * p);
d395 10
a404 5
/* upgrade the work area */
BOOL RefreshImageData( cl, o, msg )
Class		*cl;
Object		*o;
struct opSet	*msg;
a405 3
    struct VInstData	*vi = INST_DATA (cl, o);
    struct TagItem	*tags =  msg->ops_AttrList;
    struct VectorClassData *vcd = (struct VectorClassData *) cl->cl_UserData;
d409 4
a412 2
    /* free any existing image data */
    FreeVInstData (vi);
d414 3
a416 5
    IM(o)->PlanePick = (1 << vi->vi_Depth) - 1;
    IM(o)->PlaneOnOff = 0;
    IM(o)->NextImage = NULL;
    if (IM(o)->Depth != CUSTOMIMAGEDEPTH)
	IM(o)->Depth = vi->vi_Depth;
d419 1
a419 1
    success = AllocVInstData ( cl, o, msg );
d426 1
a426 1
	vlist = (struct Vector *) GetTagData( VIA_VList, NULL, tags  );
d428 2
a429 2
	/* attempt to allocate work area */
	if ( success = ( vlist && AllocWorkData ( cl, o, msg ) ) )
d451 1
a451 1
		    SetVIVState (cl, o, msg, i, TRUE);
d455 2
a456 2
		    DrawVectorA (&(vcd->vcd_RP),  vlist,
				 IM(o)->Width, IM(o)->Height, i, tags );
d465 2
a466 2
	    D( printf("free the work area\n"));
	    FreeWorkData ( vcd, vi );
d471 1
a471 1
	    printf("RID:  failed vlist or AllocWorkData\n");
d478 6
a483 1
    return ( success );
d486 1
d529 1
a529 1
DrawVectorA( rport,  anchor, Width, Height, state, taganchor)
d531 1
a531 1
struct Vector	*anchor;
d535 1
a535 1
struct TagItem	*taganchor;
a536 1
     struct Vector *v = anchor;	/* current Vector structure */
d572 3
a574 3
    vectorcount = GetTagData( VIA_VCount, NULL, taganchor );
    designWidth = GetTagData( VIA_DesignWidth, NULL, taganchor );
    designHeight = GetTagData( VIA_DesignHeight, NULL, taganchor );
d583 1
a583 1
	if ( dri = ( struct DrawInfo * )GetTagData (VIA_DrawInfo, NULL, taganchor) )
d599 1
a599 1
    if ( ( border = GetTagData(VIA_Border, NULL, taganchor) ) &
d860 1
d882 4
a885 2
    SetAPen (rp, (UBYTE) ulb);
    Move (rp, (WORD) (tx + (w - 1)), ty);
d887 2
a888 1
    Draw (rp, tx, (WORD) (ty + (h - 2)));
d891 7
a897 4
    SetAPen (rp, (UBYTE) lrb);
    Move (rp, tx, (WORD) (ty + (h - 1)));
    Draw (rp, (WORD) (tx + (w - 1)), (WORD) (ty + (h - 1)));
    Draw (rp, (WORD) (tx + (w - 1)), (WORD) (ty + 1));
d900 1
d917 1
d928 1
@


38.3
log
@DrawVectorA() now uses SetABPenDrMd().
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 38.2 91/06/24 12:16:33 peter Exp Locker: peter $
d638 1
d740 2
a741 2
	    /* set the data pointer */
	    data = v->v_Data;
@


38.2
log
@Misc. optimizations.  DrawVectorA() no longer supports LeftEdge and
TopEdge (unneeded and costly).  No longer sets up a clipping layer.
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 38.1 91/06/12 15:13:32 peter Exp Locker: peter $
d718 1
a718 2
	    SetAPen(&clonerp, penspec[ v->v_Flags & VIF_PENMASK ] );
	    SetDrMd(&clonerp, (UBYTE) JAM1);
@


38.1
log
@Provides VIBORD_INMENU treatment.
Fixed scaling error that made resulting images too small.
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 1.14 91/02/22 17:53:01 peter Exp Locker: peter $
a82 3

    struct Layer_Info *vcd_LI;	/* Layer_Info for layer manipulations */
    struct Layer *vcd_L;	/* Layer structure */
d114 2
a115 1
    if (!FindClass (VectorIClassName))	/* don't find according to Jimm */
d117 14
a130 2
	if (vcd = (struct VectorClassData *) 	
	  AllocMem (sizeof (struct VectorClassData), MEMF_CLEAR | MEMF_PUBLIC))
d132 2
a133 18
    	    if ( cl  = makePublicClass(  VectorIClassName, ImageClassName,
				sizeof(struct VInstData), dispatchVectorI ) )
	    {
		/* initialize the semaphore */
		InitSemaphore (&(vcd->vcd_Sem));

		/* set up class data */
		cl->cl_UserData = (ULONG) vcd;

		DO ( OUT ("added %s\n", VectorIClassName));

		return (cl);
	    }
	    else
	    {
		/* free the unused work area */
		FreeMem ((APTR) vcd, sizeof *vcd);
	    }
a315 23
BOOL
VCDAllocLayer( vcd, width, height )
struct VectorClassData	*vcd;
USHORT			width;
USHORT			height;
{
    struct Layer_Info	*NewLayerInfo();
    struct Layer	*CreateUpfrontLayer();

    if (vcd->vcd_LI = NewLayerInfo ())
    {
	if (vcd->vcd_L =
	    CreateUpfrontLayer (vcd->vcd_LI, &(vcd->vcd_BM),
				0, 0, (width - 1), (height - 1),
				LAYERSIMPLE, NULL))
	{
	    vcd->vcd_RP.Layer = vcd->vcd_L;
	    return (TRUE);
	}
    }
    return (FALSE);
}

a362 4
    /* obtain layer resources */
    if (!(VCDAllocLayer (vcd, w, h)))
	return (FreeWorkData (vcd, vi));

d371 2
a372 17
    if ( vcd->vcd_L)
    {
	/* ZZZ: have to make sure this is "supported"	*/
	vcd->vcd_BM.Depth = 0;
	DeleteLayer( NULL, vcd->vcd_L);
	vcd->vcd_L = NULL;
    }
    if (vcd->vcd_LI)
    {
	DisposeLayerInfo (vcd->vcd_LI);
	vcd->vcd_LI = NULL;
    }
    if ( vcd->vcd_WorkSpace )
    {
	FreeVec(  vcd->vcd_WorkSpace );
	vcd->vcd_WorkSpace = NULL;
    }
d436 1
a436 2
	    if (vi->vi_ImageData[cntr])
		FreeMem ((APTR) vi->vi_ImageData[cntr], vi->vi_Size);
d544 1
a544 1
				 0, 0, IM(o)->Width, IM(o)->Height, i, tags );
d611 1
a611 1
DrawVectorA( rport,  anchor, LeftEdge, TopEdge, Width, Height, state, taganchor)
a613 2
WORD		LeftEdge;
WORD		TopEdge;
a619 1
     struct TagItem *ti = taganchor;	/* starting tag */
d639 3
a641 3
    DV(printf("DVA:rp at $%lx, L/T/W/H: (%ld,%ld),<%ld,%ld>, state $%lx\n",
	rport, LeftEdge, TopEdge, Width, Height, state));
    /* make a copy of the user RastPort */
a642 1
    clonerp.Mask = (-1);
d679 5
a683 1
    if (ti = FindTagItem (VIA_Border, taganchor))
d685 7
a691 4
	border = ti->ti_Data;

	/* if it is in the window border, then RectFill to the right color */
	if (border & (VIBORD_INMENU | VIBORD_HLEFT | VIBORD_HRIGHT | VIBORD_VERT | VIBORD_HORIZ | VIBORD_BRCORN))
d693 1
a693 15
	    penindex = FILLPEN;
	    if ( (state == IDS_INACTIVENORMAL)
		|| ( ( mono ) && ( state == IDS_SELECTED ) ) )
	    {
		penindex = BACKGROUNDPEN;
	    }
	    if ( border & VIBORD_INMENU )
	    {
		penindex = BARBLOCKPEN;
	    }
	    SetAPen(&clonerp, penspec[ penindex ] );

	    /* blank out the area */
	    RectFill (&clonerp, LeftEdge, TopEdge,
		      (WORD) (LeftEdge + Width), (WORD) (TopEdge + Height));
d695 2
d752 2
a753 2
		x1 = LeftEdge + Scale(designWidth, Width, (*data++));
		y1 = TopEdge  + Scale(designHeight,Height,(*data++));
d763 2
a764 2
		    x1 = LeftEdge + Scale(designWidth, Width, (*data++));
		    y1 = TopEdge  + Scale(designHeight,Height,(*data++));
d777 4
a780 4
		    x1 = LeftEdge + Scale(designWidth, Width, (*data++));
		    y1 = TopEdge  + Scale(designHeight,Height,(*data++));
		    x2 = LeftEdge + Scale(designWidth, Width, (*data++));
		    y2 = TopEdge  + Scale(designHeight,Height,(*data++));
d802 1
a802 2
	Draw1P3DBorder (penspec, &clonerp, direction,
			LeftEdge, TopEdge, Width, Height);
d806 1
a806 2
	    WritePixelPen( &clonerp, penspec[ SHADOWPEN ],
		LeftEdge + Width - 1, TopEdge );
d811 1
a811 2
	    WritePixelPen( &clonerp, penspec[ SHINEPEN ],
		LeftEdge, TopEdge + Height - 1 );
d828 1
a828 2
		    LeftEdge+1, TopEdge,
		    LeftEdge + Width - 2, TopEdge );
d835 1
a835 2
		    LeftEdge, TopEdge + 1,
		    LeftEdge, TopEdge + Height - 2 );
d849 1
a849 2
		    LeftEdge+1, TopEdge + Height - 1,
		    LeftEdge + Width - 2, TopEdge + Height - 1 );
d856 1
a856 2
		    LeftEdge + Width - 1, TopEdge + 1,
		    LeftEdge + Width - 1, TopEdge + Height - 2 );
d867 1
a867 2
			LeftEdge, TopEdge,
			(SHORT) (Width - 1), Height);
d870 1
a870 2
	WritePixelPen( &clonerp, penspec[ SHINEPEN ],
	    LeftEdge, TopEdge + Height - 1);
d880 1
a880 2
	    (WORD) (LeftEdge + Width - 1), (WORD)(TopEdge + 1),
	    (WORD) (LeftEdge + Width - 1), (WORD)(TopEdge + Height - 2));
d885 1
a885 2
		(WORD) (LeftEdge + Width - 2), (WORD)(TopEdge + 1),
		(WORD) (LeftEdge + Width - 2), (WORD)(TopEdge + Height - 2));
d891 2
a892 4
	WritePixelPen(&clonerp, penspec[ SHINEPEN ],
	    (WORD) (LeftEdge + Width - 1), TopEdge);
	WritePixelPen(&clonerp, penspec[ SHADOWPEN ],
	    (WORD) (LeftEdge + Width - 1), (WORD) (TopEdge + Height - 1));
d901 1
a901 2
			(SHORT) (LeftEdge + 1), TopEdge,
			(SHORT) (Width - 1), Height);
d910 1
a910 3
	MoveDrawPen( &clonerp, penspec[ penindex ],
	    LeftEdge, (WORD)(TopEdge + 1),
	    LeftEdge, (WORD)(TopEdge + Height - 2));
d915 1
a915 2
		LeftEdge + 1, (WORD)(TopEdge + 1),
		LeftEdge + 1, (WORD)(TopEdge + Height - 2));
d922 2
a923 3
	WritePixelPen(&clonerp, penspec[ SHINEPEN ], LeftEdge, TopEdge);
	WritePixelPen(&clonerp, penspec[ SHADOWPEN ],
	    LeftEdge, (WORD) (TopEdge + Height - 1));
d930 2
a931 5
	Draw1P3DBorder (penspec, &clonerp, 1,
			LeftEdge+1, TopEdge, Width-2, Height);
	MoveDrawPen( &clonerp, penspec[ SHINEPEN ],
	    LeftEdge, TopEdge,
	    LeftEdge, TopEdge + Height - 1 );
d933 1
a933 2
	    LeftEdge + Width - 1, TopEdge,
	    LeftEdge + Width - 1, TopEdge + Height - 1 );
a937 1
    DS5( if ( state == 5 ) printf("layer at %lx", clonerp.Layer ) );
d1008 1
a1008 1
MoveDrawPen( rport, pen, x1, y1, x2, y2 )
d1011 2
a1012 2
    Move( rport, x1, y1 );
    Draw( rport, x2, y2 );
@


38.0
log
@Initial V38 check-in (matches V37 release).
@
text
@d2 1
a2 1
 *	$Id: vectorclass.c,v 1.14 91/02/22 17:53:01 peter Exp $
d36 1
a36 1
    return( ( (sourcesize >> 1) + ( destsize * coord ) ) / sourcesize );
d737 1
a737 1
	if (border & (VIBORD_HLEFT | VIBORD_HRIGHT | VIBORD_VERT | VIBORD_HORIZ | VIBORD_BRCORN))
d744 4
@
