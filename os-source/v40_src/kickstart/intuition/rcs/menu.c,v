head     38.23;
branch   ;
access   ;
symbols  V40_85:38.23 V40_71:38.23 V40_68:38.23 V40_65:38.23 V40_47:38.23 V40_45:38.23 V40_37:38.23 V40_34:38.23 V40_29:38.23 V39_2415:38.22 V39_2369:38.22 V39_2339:38.22 V39_2332:38.22 V39_2275:38.22 V39_2256:38.22 V39_2210:38.22 V39_2192:38.22 V39_2084:38.21 V39_2082:38.20 V39_2076:38.20 V39_2073:38.20 V39_2058:38.20 V39_2051:38.20 V39_2031:38.20 V39_2017:38.20 V39_2012:38.20 V39_1985:38.20 V39_1933:38.20 V39_1819:38.20 V39_1805:38.20 V39_1783:38.20 V39_1695:38.19 V39_1621:38.18 V39_1620:38.18 V39_1508:38.16 V39_1485:38.16 V39_1461:38.16 V39_1458:38.16 V39_1456:38.16 V39_1405:38.16 V39_1368:38.16 V39_1360:38.16 V39_1324:38.16 V39_1147:38.14 V39_1143:38.14 V39_1141:38.14 V39_1120:38.13 V39_1116:38.13 V39_1104:38.13 V39_1100:38.13 V39_1078:38.13 V39_1073:38.13 V39_757:38.11 V39_702:38.11 V39_557:38.10 V39_553:38.10 V39_551:38.10 V39_510:38.10 V39_495:38.10 V39_416:38.8 V39_383:38.7 V39_371:38.7 V39_336:38.7 V39_323:38.7 V39_295:38.7 V39_277:38.6 V39_254:38.6 V39_222:38.5 V39_185:38.5 V39_171:38.5 V39_161:38.5 V38_159:38.5 V38_116:38.4 V38_59:38.4;
locks    ; strict;
comment  @*   @;


38.23
date     93.02.15.19.01.55;  author peter;  state Exp;
branches ;
next     38.22;

38.22
date     92.11.10.17.07.43;  author peter;  state Exp;
branches ;
next     38.21;

38.21
date     92.09.02.10.21.52;  author peter;  state Exp;
branches ;
next     38.20;

38.20
date     92.07.17.17.27.56;  author peter;  state Exp;
branches ;
next     38.19;

38.19
date     92.07.07.15.21.41;  author peter;  state Exp;
branches ;
next     38.18;

38.18
date     92.06.29.10.45.26;  author peter;  state Exp;
branches ;
next     38.17;

38.17
date     92.06.23.17.20.10;  author peter;  state Exp;
branches ;
next     38.16;

38.16
date     92.05.21.17.42.04;  author peter;  state Exp;
branches ;
next     38.15;

38.15
date     92.05.15.14.07.32;  author peter;  state Exp;
branches ;
next     38.14;

38.14
date     92.05.01.13.53.27;  author peter;  state Exp;
branches ;
next     38.13;

38.13
date     92.04.07.17.54.15;  author peter;  state Exp;
branches ;
next     38.12;

38.12
date     92.04.01.15.06.29;  author peter;  state Exp;
branches ;
next     38.11;

38.11
date     92.03.24.11.56.45;  author peter;  state Exp;
branches ;
next     38.10;

38.10
date     92.02.20.12.14.49;  author peter;  state Exp;
branches ;
next     38.9;

38.9
date     92.02.17.17.14.19;  author peter;  state Exp;
branches ;
next     38.8;

38.8
date     92.02.11.13.39.37;  author peter;  state Exp;
branches ;
next     38.7;

38.7
date     91.12.12.20.46.11;  author peter;  state Exp;
branches ;
next     38.6;

38.6
date     91.11.15.18.52.35;  author peter;  state Exp;
branches ;
next     38.5;

38.5
date     91.08.21.18.18.55;  author peter;  state Exp;
branches ;
next     38.4;

38.4
date     91.07.10.17.57.57;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     91.06.24.12.15.20;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     91.06.19.18.05.14;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.06.12.15.11.21;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.12.14.26.08;  author peter;  state Exp;
branches ;
next     ;


desc
@@


38.23
log
@Preparations for accounting for Amiga-key size in itemExtent().
Alert() removed to save space.
@
text
@/*** menu.c *****************************************************************
 *
 *  File
 *
 *  $Id: menu.c,v 38.22 92/11/10 17:07:43 peter Exp Locker: peter $
 *
 *  Confidential Information: Commodore-Amiga, Inc.
 *  Copyright (c) Commodore-Amiga, Inc.
 *
 ****************************************************************************/

#include "intuall.h"

#ifndef EXEC_ALERTS_H
#include <exec/alerts.h>
#endif

#include <intuition/imageclass.h>

#define TEXTPAD 4

#define DEBUG 0
#define D(x)	;
#define DOOM(x)	;
#define DB(x)	;

#define SWAP_OFF_TO_SCREEN	1
#define SWAP_SCREEN_TO_OFF	0

#define swapMenuOut( sc, cr ) menuBlit( sc, (cr)->BitMap, &(cr)->bounds, SWAP_OFF_TO_SCREEN )
#define freeMenuBitMap( bm ) FreeBitMap( bm )

/* = declarations ======================================================== */

/* This function should really take a bitmap pointer instead of
 * effectively getting it out of IBase->MenuRPort.  However, that
 * cost ROM space and we can't afford it for 3.01.  Next time.
 */

menuImage(firstitem, menurect, realrect, disabled)
struct MenuItem *firstitem;
struct Rectangle *menurect;
struct Rectangle *realrect;
BOOL disabled;
{
    struct MenuItem *item;

    extern USHORT	BPattern[];
    int left, top, i, topoffset;
    int xedge;
    struct Window *AWindow;
    struct IntuiText itext;	/* used for command key only */
    UBYTE charbuf[2];

    /* jimm's stuff	*/
    struct	TextFont	*tmpfp;
    struct	TextFont	*commseqfont;
    int 			commseqindent = 0;
    int 			commseqbaseline = 0;
    struct TTextAttr		plainttattr;
    struct TextAttr		*commseqtattr;

    struct IntuitionBase *IBase = fetchIBase();
    struct RastPort *rport = &IBase->MenuRPort;

    struct	TextFont	*OpenFont();

    /* ClipRect bitmaps have to be word-aligned.  This is the
     * offset into that BitMap caused by the fact that the real
     * rectangle isn't necessarily word-aligned.
     */
    xedge = realrect->MinX & 0xF;

    D( printf("\nmenuImage:item%lx,x/yoff %ld/%ld,\n\t width/height %ld/%ld\n",
	item, xoffset, yoffset, rectWidth( realrect ), rectHeight( realrect ) ) );
    D( printf("\txedge %ld, disabled %ld\n", xedge, disabled) );

    AWindow = IBase->ActiveWindow;
    tmpfp = ISetFont(rport, AWindow->WScreen->Font);

    rport->Mask = -1;
    SetDrMd(rport, JAM2);
    SetRast(rport, XWINDOW(AWindow)->MenuBlockPen);
    drawBox(rport, xedge, 0,
	rectWidth( realrect ), rectHeight( realrect ),
	XWINDOW(AWindow)->MenuDetailPen, JAM1, 2, 1);
    itext.FrontPen = XWINDOW(AWindow)->MenuDetailPen;
    itext.DrawMode = JAM1;
    itext.ITextFont = NULL;
    itext.NextText = NULL;
    itext.IText = charbuf;

    charbuf[1] = '\0';

    /* jimm: 12/16/89: two-passes: first figure out
     * maximum command-key indentation.
     */
    for ( item = firstitem; item; item = item->NextItem )
    {
	if (item->ItemFill)
	{
	    /* use (measure) in the item's specified font */
	    itext.ITextFont = (item->Flags & ITEMTEXT)?
		    ((struct IntuiText *)item->ItemFill)->ITextFont: NULL;

	    /* could let non-text items with commseq's use previous
	     * (or "leftover") font, I suppose.
	     */

	    if (item->Flags & COMMSEQ)
	    {
		/* get the largets inset value for comsseq chars */
		charbuf[0] = item->Command;
		commseqindent = imax( commseqindent,
		    RastPortITextLength(rport, &itext) );
	    }
	}
    }

    /* now, with indentation 'commseqindent' calculated,
     * render the menu items
     */
    for ( item = firstitem; item; item = item->NextItem )
    {
	left = item->LeftEdge - menurect->MinX + xedge;
	top = item->TopEdge - menurect->MinY;
	commseqtattr = NULL;

	if (item->ItemFill)
	    {
	    if (item->Flags & ITEMTEXT)
		{
		topoffset = top+((struct IntuiText *)item->ItemFill)->TopEdge;

		DB( printf("menuImage text <%s>\n",
			((struct IntuiText *)item->ItemFill)->IText ) );

		PrintIText(rport, item->ItemFill, left, top);

		/** use the same font as (most recent) IntuiText **/
		if ( ((struct IntuiText *)item->ItemFill)->ITextFont )
		    {
		    commseqtattr = ((struct IntuiText *)item->ItemFill)->ITextFont;
		    }
		}
	    else
		{
		topoffset = top + ((struct Image *)item->ItemFill)->TopEdge;
		/* Peter 26-Mar-91: Think of this as DrawImageState(IDS_NORMAL) */
		DrawImage(rport, item->ItemFill, left, top);
		}
	    }

	/* add the checkmark as needed */
	if ((item->Flags & CHECKIT) && (item->Flags & CHECKED))
	    /* render the checkmark */
	    DrawImage(rport, AWindow->CheckMark, left, topoffset);

	/* has this baby got an equivalent command-key sequence? */
	if (item->Flags & COMMSEQ)
	{
	    /* ok, draw the amiga-glyph, and then the character */
	    /* jimm: 3/13/89 * use text length for prop. font */
	    charbuf[0] = item->Command;
	    i = left + item->Width - commseqindent - 2;

	    /*  Did we find a suitable font to render the command-key in? */
	    if ( commseqtattr )
	    {
		/* Let's try to get the same font, in plain style.
		 * First, copy the non-extended TextAttr.  Then,
		 * if the TextAttr was tagged, copy tta_Tags too.
		 * Then, clear all the style bits.
		 */
 		*((struct TextAttr *)&plainttattr) = *commseqtattr;

		if ( TESTFLAG( commseqtattr->ta_Style, FSF_TAGGED ) )
		{
		    plainttattr.tta_Tags =
			((struct TTextAttr *)commseqtattr)->tta_Tags;
		}
		/* Clear all style bits */
		plainttattr.tta_Style &= ~(FSF_UNDERLINED|FSF_BOLD|FSF_ITALIC);

		if  ( commseqfont = OpenFont( &plainttattr ) )
		{
		    commseqbaseline = commseqfont->tf_Baseline;
		    ICloseFont( commseqfont );
		    commseqtattr = &plainttattr;
		}
		else
		{
		    commseqbaseline = rport->TxBaseline;
		    commseqtattr = NULL;
		}
	    }

	    /* jimm 5/3/90: align amiga glyph at baseline	*/
	    /* Peter 16-Aug-90: Don't let it be higher than it was in 1.3 */
	    DrawImage( rport, XWINDOW(AWindow)->AmigaIcon,
		i - XWINDOW(AWindow)->AmigaIcon->Width - 2,
		topoffset + imax( 0,
		commseqbaseline - (XWINDOW(AWindow)->AmigaIcon->Height-1) ) );
	    itext.LeftEdge = i;
	    itext.TopEdge = topoffset;
	    itext.ITextFont = commseqtattr;
	    PrintIText(rport, &itext, 0, 0);
	}

	/* if disabled is true, every item is ghosted */
	if ( disabled || ((item->Flags & ITEMENABLED) == NULL) )
	    /* render the "ghosting" */
	    BlastPattern( rport, left, top, 
		    left + item->Width - 1, top + item->Height - 1,
		    BPattern, 1, XWINDOW(AWindow)->MenuBlockPen, 0, JAM1);

	/** using for(;;) loop item = item->NextItem; */
    }
    ICloseFont(tmpfp);	/* jimm: 6/26/86: */
}


#if 0
/* Nice try, but PhotonPaint II puts IntuiText underneath the
 * checkmark, so the kludge that is here is needed, but Tax-Break
 * uses XOR text in their menus, so the same kludge breaks them.
 * Someday I hope to return here and make everything well again...
 */

/* checkmarkMenu()
 * Re-render checkmarks of a displayed menu panel.
 * Pass it the first MenuItem of an itempanel,
 * or pass it the MenuItem that springs a submenu.
 */

checkmarkMenu(menu, firstitem, sub)
struct Menu *menu;
struct MenuItem *firstitem;
BOOL		sub;
{
    int xoffset, yoffset;
    struct MenuItem *item;
    int left, top, topoffset;
    struct Rectangle rect;

    struct IntuitionBase *IBase = fetchIBase();
    struct Screen *AScreen = IBase->ActiveScreen;
    struct Window *AWindow = IBase->ActiveWindow;
    struct RastPort *rport;

    /* These equations were stolen from highGrunt */
    xoffset = AScreen->BarHBorder + menu->LeftEdge;
    yoffset = (AScreen->BarHeight - 1) + AScreen->MenuVBorder;

    if (sub)
    {
	xoffset += firstitem->LeftEdge;
	yoffset += firstitem->TopEdge;
	firstitem = firstitem->SubItem;
    }

    rport = obtainRP( XSC( AScreen )->ClipLayer->rp, XSC( AScreen )->ClipLayer );

    for ( item = firstitem; item; item = item->NextItem )
    {
	if (item->Flags & CHECKIT)
	{
	    left = xoffset + item->LeftEdge;
	    top = yoffset + item->TopEdge;

	    if (item->ItemFill)
	    {
		if (item->Flags & ITEMTEXT)
		{
		    topoffset = top + ((struct IntuiText *)item->ItemFill)->TopEdge;
		}
		else
		{
		    topoffset = top + ((struct Image *)item->ItemFill)->TopEdge;
		}
	    }
	    /* add the checkmark as needed */
	    if (item->Flags & CHECKED)
	    {
		/* render the checkmark */
		DrawImage(rport, AWindow->CheckMark, left, topoffset);
	    }
	    else
	    {
		boxToRect( (struct Box *)&AWindow->CheckMark->LeftEdge, &rect );
		offsetRect( &rect, left, topoffset );

		/* ZZZ: This used to call FillRect(), which is now deleted.
		 * the new code is untested
		 */
		/* erase the checkmark's spot */
		SetAPen( rport, XWINDOW(AWindow)->MenuBlockPen );
		SafeRectFill( rport, rect.MinX, rect.MinY, rect.MaxX, rect.MaxY );

		/* For people like PhotonPaintII, who use an image
		 * to illustrate the "unchecked" state.
		 * We die on any XOR-mode text.
		 */
		if (item->Flags & ITEMTEXT)
		{
		    PrintIText(rport, item->ItemFill, left, top);
		}
		else
		{
		    DrawImage(rport, item->ItemFill, left, top);
		}
	    }
	}
    }
    freeRP( rport );
}
#endif

itemExtent( window, item, rect )
struct Window *window;
struct MenuItem *item;
struct Rectangle *rect;
{
    int i;
    APTR fill;
    struct RastPort *rp = &window->WScreen->RastPort;

    /* Item select box, as programmer provides */
    boxToRect( &item->LeftEdge, rect );

    fill = item->ItemFill;
    for ( i = 0; i < 2; i++ )
    {
	if ( fill )
	{
	    /* Let's get the extent of the imagery: */
	    struct IBox itembox;
	    WORD imheight;

	    if ( TESTFLAG( item->Flags, ITEMTEXT ) )
	    {
		struct TextAttr	*tattr;
		tattr = ((struct IntuiText *) fill)->ITextFont;

		itembox.Left = ((struct IntuiText *) fill)->LeftEdge;
		itembox.Top = ((struct IntuiText *) fill)->TopEdge;
		itembox.Width = RastPortITextLength( rp, fill );
		itembox.Height = rp->TxHeight;
		if ( tattr )
		{
		    itembox.Height = tattr->ta_YSize;
		}
	    }
	    else
	    {
		itembox = *(struct IBox *)(&((struct Image *)fill)->LeftEdge);
	    }

	    imheight = XWINDOW(window)->AmigaIcon->Height;
	    if ( TESTFLAG( item->Flags, COMMSEQ ) &&
		( itembox.Height < imheight ) )
	    {
		itembox.Height = imheight;
	    }
	    imheight = window->CheckMark->Height;
	    if ( TESTFLAG( item->Flags, CHECKIT ) && 
		( itembox.Height < imheight ) )
	    {
		itembox.Height = imheight;
	    }

	    /* After this, itembox is actually a struct Rectangle */
	    boxToRect( &itembox, &itembox );
	    /* Offset the imagery relative to the menu item,
	     * and stretch our result to include it
	     */
	    offsetRect( &itembox, item->LeftEdge, item->TopEdge );
	    rectHull( rect, &itembox );
	}
	fill = item->SelectFill;
    }
}

/* this routine feels through the item list and fills in the variables with
 *  data describing:
 *	- the leftmost position specified by any of the items
 *	- the topmost position described by the items
 *	- the exact rightmost position
 *	- the exact bottommost position.  This includes subtracting one from
 *	  the height of text characters (for the blank line)
 * These are derived by examining ItemFills (Text or Image), the
 * select box of the items, and SelectFill if any.
 *
 * Then, we include the menu border padding stuff, then enforcer certain
 * spatial relationships with respect to the parent item or menu.
 */
boxer( window, firstitem, rect, hullrect, issubmenu )
struct Window *window;
struct MenuItem *firstitem;
struct Rectangle *rect;
int issubmenu;
{
    struct Rectangle work; /* temporary rectangle for each item */
    struct MenuItem *item;
    struct Screen *screen = window->WScreen;

    degenerateRect( rect );	/* creates maximally inside out rect */

    for ( item = firstitem; item; item = item->NextItem )
    {
	itemExtent( window, item, &work );

	/* fit item into item's menu */
	rectHull( rect, &work );	/* expand total extent */
	DB( dumpRect("work", &work) );
	DB( dumpRect("rect", rect) );
    }

    if ( !issubmenu )
    {
#if 0
	if ( rect->MinY < 0 )
	{
	    Alert( AN_ItemBoxTop );	/* Why bother? */
	}
#endif
	rect->MinY = 0;
    }
    /* Add the menu panel trim */
    rect->MinX -= screen->MenuHBorder;
    rect->MinY -= screen->MenuVBorder;
    rect->MaxX += screen->MenuHBorder;
    rect->MaxY += screen->MenuVBorder;

    /* Here, we enforce certain supplied criteria:
     * A menu-panel must span the width of the menu header.
     * A submenu-panel must touch at least a corner of its parent item.
     */
    rectHull( rect, hullrect );

    DB( printf("boxer: X: %ld-%ld Y: %ld-%ld\n",
	rect->MinX, rect->MaxX, rect->MinY, rect->MaxY) );
}

struct Menu *grabMenu(menu, menuNum)
register struct Menu *menu;
register USHORT menuNum;
/* returns the address of the n-th menu in the list starting from the arg */
{
    SHORT menupick;

    if ((menupick = MENUNUM(menuNum)) == NOMENU) return(NULL);

    while (menupick-- > 0) menu = menu->NextMenu;
    return(menu);
}


struct MenuItem *grabItem(menu, menuNum)
register struct Menu *menu;
register SHORT menuNum;
/* returns the adress of the n-th item of the argument menu */
{
    SHORT itempick;
    struct MenuItem *item;

    item = menu->FirstItem;

    if ((itempick = ITEMNUM(menuNum)) == NOITEM) return(NULL);

    while (itempick-- > 0) item = item->NextItem;
    return(item);
}


struct MenuItem *grabSub(item, menuNum)
register struct MenuItem *item;
register SHORT menuNum;
/* returns the address of the n-th subitem of the argument item */
{
    SHORT subpick;
    struct MenuItem *sub;

    sub = item->SubItem;

    if ((subpick = SUBNUM(menuNum)) == NOSUB) return(NULL);

    while (subpick-- > 0) sub = sub->NextItem;
    return(sub);
}


eraseItem()
{
    struct Menu *menu;
    struct IntuitionBase *IBase = fetchIBase();

    /* swap our menu rectangle out of the Active RastPort */

    if (IBase->Flags & GOODITEMDRAWN)
    {
	swapMenuOut( IBase->ActiveScreen, &IBase->ItemCRect );
    }

    if ( IBase->ItemCRect.BitMap )
    {
	WaitBlit();
	freeMenuBitMap( IBase->ItemCRect.BitMap );
    }

    IBase->Flags &= ~ITEMDRAWN;

    if (menu = grabMenu(IBase->ActiveWindow->MenuStrip, IBase->MenuDrawn))
	menu->Flags &= ~MIDRAWN;

    SETDMENU(NOMENU);
}


eraseSub()
{
    int i;
    struct MenuItem *item;
    struct Menu *menu;
    struct IntuitionBase *IBase = fetchIBase();

    /* swap our menu rectangle out of the Active RastPort */
    if (IBase->Flags & GOODSUBDRAWN)
    {
	D( printf("eraseSub, plane 0 at %lx\n",
		IBase->SubCRect.BitMap->Planes[0] ) );
	D( printf( "rastport %lx, rpbitmap %lx, plane 0 %lx\n",
		&IBase->ActiveScreen->RastPort,
		IBase->ActiveScreen->RastPort.BitMap,
		IBase->ActiveScreen->RastPort.BitMap->Planes[0] ) );
	D( kpause("--") );
	swapMenuOut( IBase->ActiveScreen, &IBase->SubCRect );
    }
    D( else printf("eraseSub: won't do it: no goodsubdrawn\n" ) );

    if ( IBase->SubCRect.BitMap )
    {
	WaitBlit();
	freeMenuBitMap( IBase->SubCRect.BitMap );
    }

    IBase->Flags &= ~SUBDRAWN;

    i = IBase->MenuDrawn;
    if (menu = grabMenu(IBase->ActiveWindow->MenuStrip, i))
	if (item = grabItem(menu, i))
	    item->Flags &= ~ISDRAWN;

    SETDITEM(NOITEM);
}


SHORT hitMenu()
/* returns the menu number (nonshifted) or NOMENU from the current mouse
 *  position trying to collide with the menu bar
 */
{
    register struct Menu *menu;
    register int num;
    struct Point pt;
    struct IBox menubox;
    struct Screen *AScreen;
    struct IntuitionBase *IBase = fetchIBase();

    AScreen = IBase->ActiveScreen;

    /* This should have been BarHBorder, but we leave it as VBorder,
     * since it gets rendered this same wrong way
     */
    pt.X = AScreen->MouseX - AScreen->BarVBorder;
    pt.Y = AScreen->MouseY;
    menubox.Top = 0;
    menubox.Height = AScreen->BarHeight;
    num = 0;
    menu = IBase->ActiveWindow->MenuStrip;

    while (menu)
	{
	menubox.Left = menu->LeftEdge;
	menubox.Width = menu->Width;
	if ( ptInBox( pt, &menubox ) )
	    return(num);
	num++;
	menu = menu->NextMenu;
	}

    return(NOMENU);
}


USHORT hitItem()
/* returns the item number (nonshifted) or NOITEM from the current mouse
 *  position trying to collide with MenuDrawn
 */
{
    return(hitGrunt(FALSE));
}



SHORT hitSub()
/* returns the subitem number (nonshifted) or NOSUB from the current mouse
 *  position trying to collide with MenuDrawn
 */
{
    register SHORT num;

    if ((num = hitGrunt(TRUE)) == NOITEM) return (NOSUB);
    else return(num);
}


SHORT hitGrunt(subsearch)
BOOL subsearch;
/* returns the subitem number (nonshifted) or NOSUB from the current mouse
 *  position trying to collide with MenuDrawn
 */
{
    register struct Menu *menu;
    register struct MenuItem *item;
    register int num;
    struct Point rel;
    struct Screen *AScreen;
    struct IntuitionBase *IBase = fetchIBase();

    AScreen = IBase->ActiveScreen;

    num = 0;
    menu = grabMenu(IBase->ActiveWindow->MenuStrip, IBase->MenuDrawn);

    /* Peter 9-Aug-90: Fixed that off-by-four error in selecting
     * menu items:
     */
    rel.X = AScreen->MouseX - AScreen->BarHBorder - menu->LeftEdge;
    rel.Y = AScreen->MouseY - AScreen->BarHeight - AScreen->MenuVBorder + 1;

    if (subsearch)
	{
	item = grabItem(menu, IBase->MenuDrawn);
	rel.X -= item->LeftEdge;
	rel.Y -= item->TopEdge;
	item = item->SubItem;
	}
    else item = menu->FirstItem;

    while (item)
	{
	if ( ptInBox( rel, &item->LeftEdge ) )
	    return(num);
	num++;
	item = item->NextItem;
	}

    return(NOITEM);
}


highMenu()
/* highlights the menu of MenuSelected
 * presumes that the menubar is already drawn
 */
{
    struct Menu *menu;
    struct Screen *AScreen;
    struct RastPort *RP;
    struct IntuitionBase *IBase = fetchIBase();

    AScreen = IBase->ActiveScreen;

    menu = grabMenu(IBase->ActiveWindow->MenuStrip, IBase->MenuSelected);

    if (menu->Flags & MENUENABLED)
    {
	RP = obtainRP(XSC(AScreen)->ClipLayer->rp, XSC(AScreen)->ClipLayer);

    /* This should have been BarHBorder, but we leave it as VBorder,
     * since we shouldn't move the rendering, for compatibility
     */
	setMenuRPMask(RP);
	xorboxmask(RP, AScreen->BarVBorder + menu->LeftEdge, 
	    0, menu->Width, AScreen->BarHeight);
	freeRP(RP);
    }
}

/* setMenuRPMask() checks if the window has newlook-menus.  If so,
 * it sets up the Mask that will allow complement-mode operations
 * to interchange MenuDetailPen with MenuBlockPen.
 */
setMenuRPMask( rport )
struct RastPort *rport;
{
    struct IntuitionBase *IBase = fetchIBase();
    struct Window *AWindow = IBase->ActiveWindow;
    rport->Mask = -1;
    if ( TESTFLAG( AWindow->Flags, WFLG_NEWLOOKMENUS ) )
    {
	rport->Mask = XWINDOW(AWindow)->MenuDetailPen ^ XWINDOW(AWindow)->MenuBlockPen;
    }
}

highGrunt(item, left, top, AScreen)
struct MenuItem *item;
int left, top;
struct Screen *AScreen;
/* highlights the item of MenuSelected
 * presumes that the itemlist is already drawn
 */
{
    struct RastPort *RP = obtainRP(XSC(AScreen)->ClipLayer->rp, XSC(AScreen)->ClipLayer);
    APTR fill;
    ULONG state;
    struct TextFont	*tmpfp;

    switch (item->Flags & HIGHFLAGS)
	{
	case HIGHCOMP:
		setMenuRPMask(RP);
		xorboxmask(RP, left, top, item->Width, item->Height);
		RP->Mask = -1;
		break;

	case HIGHBOX:
		setMenuRPMask(RP);
		outbox(RP, left, top, item->Width, item->Height);
		RP->Mask = -1;
		break;

	case HIGHIMAGE:

	    /* Assume item is in selected-state */
	    fill = item->SelectFill;
	    state = IDS_SELECTED;
	    if (item->Flags & HIGHITEM)
	    {
		/* Item is not selected (note that HIGHITEM gets inverted below) */
		fill = item->ItemFill;
		state = IDS_NORMAL;
	    }
	    /* jimm: 7/20/86: alternate text didn't work!! */
	    if (item->Flags & ITEMTEXT)
	    {
		/* Peter 2-Apr-91: Set up default font for this RastPort */
		tmpfp = ISetFont(RP, AScreen->Font);
		PrintIText(RP, fill, left, top);
		ICloseFont(tmpfp);
	    }
	    else
	    {
		/* Peter 26-Mar-91: Pass the state to the image */
		DrawImageState(RP, fill, left, top, state, NULL);
	    }

		break;

	case HIGHNONE:
		break;
	}

    /* lastly, invert the HIGHITEM bit */
    item->Flags ^= HIGHITEM;
    freeRP(RP);
}


highItem()
/* highlights the item of MenuSelected
 * presumes that the itemlist is already drawn
 */
{
    /* conditional jimm: 7/8/86 */
    if (fetchIBase()->Flags & GOODITEMDRAWN) highPrimeGrunt(FALSE);
}


highSub()
/* highlights the subitem of MenuSelected
 * presumes that the sublist is already drawn
 */
{
    /* conditional jimm: 7/8/86 */
    if (fetchIBase()->Flags & GOODSUBDRAWN) highPrimeGrunt(TRUE);
}


highPrimeGrunt(subsearch)
BOOL subsearch;
{
    struct Menu *menu;
    struct MenuItem *item, *sub;
    int num, left, top;
    struct Screen *AScreen;
    struct IntuitionBase *IBase = fetchIBase();

    AScreen = IBase->ActiveScreen;

    num = IBase->MenuSelected;

    menu = grabMenu(IBase->ActiveWindow->MenuStrip, num);
    if ((menu->Flags & MENUENABLED) == NULL) return;

    item = grabItem(menu, num);
    if ((item->Flags & ITEMENABLED) == NULL) return;
    left = AScreen->BarHBorder + menu->LeftEdge + item->LeftEdge;
    top = (AScreen->BarHeight - 1) + AScreen->MenuVBorder + item->TopEdge;

    if (subsearch)
	{
	sub = grabSub(item, num);
	if ((sub->Flags & ITEMENABLED) == NULL) return;
	left += sub->LeftEdge;
	top += sub->TopEdge;
	item = sub;
	}

    highGrunt(item, left, top, AScreen);
}




showMStrip(w)
register struct Window *w;
/*    Displays the menu bar of the window in its screen title bar */
{
    extern USHORT	BPattern[];
    register struct Screen *s;
    register struct Menu *m;
    struct IntuiText itext;
    struct RastPort *rp;

    /** ZZZ: why? **/
    LockLayerInfo(&w->WScreen->LayerInfo);

    resetMenu(w, ~MIDRAWN, ~ISDRAWN & ~HIGHITEM & ~MENUTOGGLED, 
	    ~HIGHITEM & ~MENUTOGGLED);

    s = w->WScreen;

    forceBarFront(s);

    rp = obtainRP(s->BarLayer->rp, NULL);

    m = w->MenuStrip;

    itext.FrontPen = XWINDOW(w)->MenuDetailPen;
    itext.BackPen = XWINDOW(w)->MenuBlockPen;

    if ( !m )
    {
	/* Menuless windows always get new-look colors */
	itext.FrontPen = XSC(s)->SDrawInfo.dri_Pens[ BARDETAILPEN ];
	itext.BackPen = XSC(s)->SDrawInfo.dri_Pens[ BARBLOCKPEN ];
    }

#if 1
    drawScreenBar( rp, s, itext.BackPen );
#else
    drawBlock(rp, 0, 0, s->Width - 1, s->BarHeight-1, itext.BackPen);
    drawBlock(rp, 0, s->BarHeight, s->Width - 1, s->BarHeight,
	XSC(s)->SDrawInfo.dri_Pens[ BARTRIMPEN ]);
#endif

    itext.DrawMode = JAM2;
    itext.TopEdge = s->BarVBorder;
    itext.LeftEdge = s->BarHBorder;
    itext.ITextFont = s->Font;
    itext.NextText = NULL;

    while (m)
	{
	if (m->MenuName)
	    {
	    itext.IText = m->MenuName;
	    PrintIText(s->BarLayer->rp, &itext, m->LeftEdge, 0);
	    if (!(m->Flags & MENUENABLED))
		BlastPattern(s->BarLayer->rp,
			s->BarHBorder + m->LeftEdge, 0,
			s->BarHBorder + m->LeftEdge + m->Width - 1, 
			s->BarHeight - 1,
			BPattern, 1,
			itext.BackPen, 0, JAM1);
	    }
	m = m->NextMenu;
	}

    /** ZZZ: why? **/
    freeRP(rp);
    UnlockLayerInfo(&w->WScreen->LayerInfo);
}


removeMStrip( s )
struct Screen *s;
{
    if (s->Flags & SHOWTITLE) forceBarCenter(s);
    else forceBarBack(s);
    screenbar( s );
    BorderPatrol( s );
    /* no more MENULOCK */
    /* IBase->Flags &= ~INMENUSTATE; */
}


resetMenu(w, mflags, iflags, sflags)
struct Window *w;
USHORT mflags, iflags, sflags;
/* clears all the DRAWN flags in the entire MenuStrip */
{
    struct Menu *menu;
    struct MenuItem *item, *sub;

    if (w)
	{
	menu = w->MenuStrip;

	while (menu)
	    {
	    item = menu->FirstItem;
 	    while (item)
		{
		item->Flags &=  iflags;
		sub = item->SubItem;
 		while (sub)
		    {
		    sub->Flags &= sflags;
		    sub = sub->NextItem;
		    }
		item = item->NextItem;
		}
	    menu->Flags &= mflags;
	    menu = menu->NextMenu;
	    }
	}
}


/* Allocates a menu bitmap, given the screen, and the four extremities
 * of the rectangle.  Fails if the rectangle is degenerate vertically.
 */

struct BitMap *allocMenuBitMap( ascreen, rect )
struct Screen *ascreen;
struct Rectangle *rect;
{
    struct BitMap *bm = NULL;
    long height = rectHeight( rect );
    /* The Menu BitMap needs the same relative alignment as
     * the screen.
     */
    long width = ( rect->MaxX & (~0xF)) - (rect->MinX & (~0xF)) + 16;

    if ( height > 0 )
    {
	bm = (struct BitMap *)AllocBitMap( width, height,
	    ascreen->RastPort.BitMap->Depth, NULL,
	    ascreen->RastPort.BitMap );
    }
    return( bm );
}



/* drawItem **************************************************************
*
*NAME
*   drawItem  --  draws the item box that contains the specified item
*
*SYNOPSIS
*   drawItem(menuNumber);
*
*FUNCTION
*   Draws the box containing the item of the MenuStrip of the ActiveWindow
*   as specified by the menuNumber argument.   Wants MenuNumber to have 
*   valid menu and item components, doesn't care about subitem
*   Sets menu component of IBase->MenuDrawn to show that this menu's
*   itemlist was drawn.
*   Sets the menu's MIDRAWN flag that the menu's items were drawn
*   WARNING:  this routine does not check whether or not the menu number is
*	out of bounds!
*
*INPUTS
*   menuNumber = an Intuition menu number
*
*RESULT
*   None
*
*BUGS
*   None
*
*SEE ALSO
*   None
*/
drawItem(num)
USHORT num;
{
    struct Menu *menu;
    struct Rectangle screenrect;
    struct Screen *AScreen;
    struct IntuitionBase *IBase = fetchIBase();

    IBase->Flags &= ~GOODITEMDRAWN;

    AScreen = IBase->ActiveScreen;

    menu = grabMenu(IBase->ActiveWindow->MenuStrip, num);
    /* JazzX/Y,BeatX/Y is nothing other than a struct Rectangle
     * describing the menu's extent, calculated at SetMenuStrip()
     * time.  So let's copy that into screenrect, which must
     * be shifted by the menu trim-border and the bar-height.
     */
    screenrect = *( (struct Rectangle *) &menu->JazzX );
    offsetRect( &screenrect, menu->LeftEdge + AScreen->BarHBorder,
	AScreen->BarHeight - 1 + AScreen->MenuVBorder );

    /* make sure the menu box is onscreen */
    if (screenrect.MinX < 0)
    {
	screenrect.MaxX -= screenrect.MinX;	/* move it right some more */
	screenrect.MinX = 0;
    }

    /* Let's allocate the Item ClipRect's BitMap, complete with planes */

    if ( IBase->ItemCRect.BitMap = allocMenuBitMap( AScreen, &screenrect ) )
    {
	IBase->MenuRPort.BitMap = IBase->ItemCRect.BitMap;

	/* Render the MenuItem panel whose menu extent is in Jazz/Beat,
	 * and whose on-screen position is screenrect.
	 */
	menuImage( menu->FirstItem, (struct Rectangle *)&menu->JazzX, &screenrect,
	    !TESTFLAG( menu->Flags, MENUENABLED ) );

	IBase->ItemCRect.bounds = screenrect;

	/* swap our menu rectangle into the Active RastPort */
	if ( swapMenuIn( AScreen, &IBase->ItemCRect ) )
	{
	    IBase->Flags |= GOODITEMDRAWN;
	}
    }

    IBase->Flags |= ITEMDRAWN;
    menu->Flags |= MIDRAWN;
    SETDMENU(MENUNUM(num));
}

/* drawSub **************************************************************
*
*NAME
*   drawSub  --  draws all menus specified by the MenuNumber
*
*SYNOPSIS
*   drawSub(menuNumber);
*
*FUNCTION
*   Draws the menu piece of the MenuStrip of the ActiveWindow
*   as specified by the menuNumber argument.   Wants MenuNumber to have 
*   valid menu, item and sub components, doesn't care about subitem
*   Sets item component of IBase->MenuDrawn  to show that this item's
*   sublist was drawn
*   Sets the item's ISDRAWN flag that the item's subitems were drawn
*   WARNING:  this routine does not check whether or not the menu number is
*	out of bounds!
*
*INPUTS
*   menuNumber = an Intuition menu number
*
*RESULT
*   None
*
*BUGS
*   None
*
*SEE ALSO
*   None
*/
drawSub(num)
USHORT num;
{
    struct Menu *menu;
    struct MenuItem *item;

    struct Rectangle menurect;
    struct Rectangle screenrect;
    struct Rectangle hullrect;

    struct Screen *AScreen;
    struct IntuitionBase *IBase = fetchIBase();

    AScreen = IBase->ActiveScreen;

    IBase->Flags &= ~GOODSUBDRAWN;

    D( printf("---\ndrawSub enter, screen %lx\n", AScreen) );

    menu = grabMenu(IBase->ActiveWindow->MenuStrip, num);
    item = grabItem(menu, num);

    /* The subitem box must touch at least the corner of the parent item: */
    hullrect.MinX = item->Width - 1;
    hullrect.MinY = item->Height - 1;
    hullrect.MaxX = 0;
    hullrect.MaxY = 0;
    boxer( IBase->ActiveWindow, item->SubItem, &menurect, &hullrect, 1 );

    D( dumpRect("subitem menurect", &menurect) );

    /* The screen rectangle is the menu's rectangle, offset by the
     * item's position plus the menu trim-border and the bar-height.
     */
    screenrect = menurect;
    offsetRect( &screenrect,
	item->LeftEdge + menu->LeftEdge + AScreen->BarHBorder,
	item->TopEdge + ( AScreen->BarHeight - 1 + AScreen->MenuVBorder ) );

    D( dumpRect("offset screenrect", &screenrect) );

    D( printf("BX/YOffset %ld/%ld\n", BXOffset, BYOffset) );

    /* Let's allocate the SubItem ClipRect's BitMap, complete with planes */

    if ( IBase->SubCRect.BitMap = allocMenuBitMap( AScreen, &screenrect ) )
    {
	IBase->MenuRPort.BitMap = IBase->SubCRect.BitMap;

	/* Render the SubItem panel whose menu extent is in menurect
	 * and whose on-screen position is screenrect.
	 */
	menuImage( item->SubItem, &menurect, &screenrect,
	    !( ( menu->Flags & MENUENABLED ) && ( item->Flags & ITEMENABLED ) ) );

	IBase->SubCRect.bounds = screenrect;

	D( dumpRect("subitem SubCRect.bounds", &screenrect ) );

	if ( swapMenuIn( AScreen, &IBase->SubCRect ) )
	{
	    IBase->Flags |= GOODSUBDRAWN;
	}
    }

    IBase->Flags |= SUBDRAWN;
    item->Flags |= ISDRAWN;

    SETDITEM(ITEMNUM(num));
}
/*** intuition.library/ResetMenuStrip ***/
/*** intuition.library/SetMenuStrip ***/

BOOL
doSetMenuStrip(window, menu, recalc)
struct Window *window;
struct Menu *menu;
LONG recalc;		/* TRUE for SetMenuStrip, FALSE for ResetMenuStrip */
{
    doISM( itSETMENU, window, menu, recalc );

    return ( TRUE );
}

/*
 * called by ISM
 */
realSetMenuStrip(window, menu, precalc_sizes )
struct Window *window;
struct Menu *menu;
{
    struct Rectangle hullrect;
    struct Menu *workmenu;
    /* not used ... struct RastPort *RP; */
    int HBorder, VBorder;

    if ( precalc_sizes )
    {
	/* The item box must span at least the extent of the menu header,
	 * but we don't care what happens in the y-direction:
	 */
	hullrect.MinX = 0;
	hullrect.MinY = 32767;
	hullrect.MaxY = -32767;
	/* precalc/build this menu OK */
	workmenu = menu;
	while (workmenu)
	{
	    hullrect.MaxX = workmenu->Width - 1;

	    /* look!  it's RJ's little secret.	JaxxX/JazzY/BeatX/BeatY
	     * are none other than the menu-panel rectangle.
	     */
	    boxer( window, workmenu->FirstItem,
		((struct Rectangle *)&workmenu->JazzX), &hullrect, 0 );

	    workmenu = workmenu->NextMenu;
	}
    }

    /* link it into the window */
    window->MenuStrip = menu;
}

/*** intuition.library/ClearMenuStrip ***/

ClearMenuStrip(window)
struct Window *window;
{

    /* will delink when safe */
    doISM( itCLEARMENU, window );
}


/* called by ISM */
BOOL IOnOffMenu(window, menuNum, onOrOff)
struct Window *window;
USHORT menuNum;
BOOL onOrOff;
{
    int menupick;
    register struct Menu *menu;
    register struct MenuItem *item, *subitem;
    int  menuAnd, menuOr;
    register int  itemAnd, itemOr;

    DOOM( printf("IOOM: window %lx menustrip %lx menunum %lx onoff %lx\n",
	window, window->MenuStrip, menuNum, onOrOff ));

    if ((menupick = MENUNUM(menuNum)) == NOMENU) return;

    assertLock( "IOnOffMenu", ISTATELOCK );

    /* get the menu, item, and subitem numbers */
    menu = grabMenu(window->MenuStrip, menuNum);
    if (item = grabItem(menu, menuNum))
	subitem = grabSub(item, menuNum);

    if (onOrOff)
	{ /* we're trying to turn on this menu */
	menuOr = MENUENABLED; /* if the flag is off, then set it on */
 	menuAnd = -1; /* we want to turn the bit on , not mask it off */
	itemOr = ITEMENABLED;
	itemAnd = -1;
	}
    else
	{ /* we're trying to turn off this menu */
	menuOr = 0;		/* if the flag is on, then set it off */
 	menuAnd = ~MENUENABLED;/* want to turn the bit off, not mask it on */
	itemOr = 0;
	itemAnd = ~ITEMENABLED;
	}


    if (item == NULL) /* we want to enable the entire menu */
    {
	menu->Flags |= menuOr; /* OR in a one-bit if we want to enable */
	menu->Flags &= menuAnd; /* AND in a zero-bit to disable */
    }
    else /* we've got a menu AND an item */
    {
	/* we want to enable this item AND ALL sub-menus if any */
	if (subitem == NULL)
	{
	    item->Flags |= itemOr; /* OR in a one-bit to enable */ 
	    item->Flags &= itemAnd; /* AND in a zero-bit to disable */ 
	}
	else /* finally, we've got a subitem pick too */
	{
	    subitem->Flags |= itemOr; /* OR in a one-bit to enable */  
	    subitem->Flags &= itemAnd; /* AND in a zero-bit to disable */ 
	}
    }
}


/*** intuition.library/OnMenu ***/

BOOL OnMenu(window, menuNum)
struct Window *window;
UWORD menuNum;
{
    DOOM( printf("OnMenu %lx %lx\n", window, menuNum ) );
    return ( doISM( itONOFFMENU, window, menuNum, TRUE ) );
}
/*** intuition.library/OffMenu ***/

BOOL OffMenu(window, menuNum)
struct Window *window;
UWORD menuNum;
{
    DOOM( printf("OffMenu %lx %lx\n", window, menuNum ) );
    return ( doISM( itONOFFMENU, window, menuNum, FALSE ) );
}



/*
 * getMenu() figures out which menu, item, and subitem we're currently
 * over.
 * Maintains MenuDrawn and MenuSelected, and draws the menu display with
 * highlighting.
 *
 * NB:  MenuDrawn and MenuSelected should be set to MENUNULL before first call
 */

getMenu()
{
    UWORD subpanel_of, itempanel_of;
    UWORD sel_item, sel_sub, sel_menu;
    UWORD newsel_item, newsel_sub, newsel_menu;
    register struct MenuItem *iptr;
    struct IntuitionBase *IBase = fetchIBase();

    /* Which menu, if any, begat the itempanel? */
    itempanel_of = MENUNUM(IBase->MenuDrawn);
    /* Which item, if any, begat the subpanel? */
    subpanel_of = ITEMNUM(IBase->MenuDrawn);

    /* Which, menu, item, and subitem are selected? */
    sel_menu = MENUNUM(IBase->MenuSelected);
    sel_item = ITEMNUM(IBase->MenuSelected);
    sel_sub = SUBNUM(IBase->MenuSelected);

    /* Is there a submenu panel? */
    if (subpanel_of != NOITEM)
    {
	/* Did we hit a subitem? */
	if ((newsel_sub = hitSub()) != NOSUB)
	{
	    /* Is this a different subitem from the last one? */
	    if (newsel_sub != sel_sub)
	    {
		 /* Unhighlight the previously selected subitem, if any */
		if (sel_sub != NOSUB)
		{
		    highSub();
		}
		/* Select and highlight the new subitem, and we're done */
		SETSSUB(newsel_sub);
		highSub();
	    }
	    /* Same subitem as before, so do nothing */
	    /* we can leave, having hit a subitem and dealt with it */
	    return;
	}


	/* ELSE We didn't hit any subitems */
	{
	    /* Unhighlight the previously selected subitem, if any */
	    if (sel_sub != NOSUB)
	    {
		highSub();
		SETSSUB(NOSUB);
	    }

	    /* If we are nevertheless inside the subpanel, then we are done */
	    if ( inrect(IBase->ActiveScreen->MouseX, IBase->ActiveScreen->MouseY,
		 &IBase->SubCRect.bounds) )
	    {
		return;
	    }
	}
    }

    /* Either there was no submenu panel, or the mouse is not over it */

    /* Is there an itempanel? */
    if (itempanel_of != NOMENU)
    {
	/* Did we hit an item? */
	if ((newsel_item = hitItem()) != NOITEM)
	{
	    /* Is this a different item from the last one? */
	    if (newsel_item != sel_item)
	    {
		/* Remove the subpanel of and unhighlight the previously
		 * selected item */
		if (sel_item != NOITEM)
		{
		    if (subpanel_of != NOITEM)
		    {
			eraseSub();
		    }
		    highItem();
		}
		/* Select and highlight the new item */
		SETSITEM(newsel_item);
		highItem();
		/* Find the item itself */
		iptr = grabItem( grabMenu( IBase->ActiveWindow->MenuStrip, 
			SHIFTMENU(sel_menu) ), SHIFTITEM(newsel_item) );
		/* Does the item have a subpanel? */
		if (iptr->SubItem)
		{
		    drawSub(SHIFTITEM(newsel_item) | SHIFTMENU(sel_menu));
		    /* Did we hit something in the subpanel? */
		    if ((newsel_sub = hitSub()) != NOSUB)
		    {
			/* select and highlight this subitem */
			SETSSUB(newsel_sub);
			highSub();
		    }
		}
	    }
	    /* Same item as before, so do nothing */
	    /* we can leave, having hit an item and dealt with it */
	    return;
	}
	/* If the previously selected item had no subpanel,
	 * unhighlight it
	 */
 	if ( (sel_item != NOITEM) && (subpanel_of == NOITEM) )
	{
	    highItem();
	    SETSITEM(NOITEM);
	}
    }

    /* Either there was no itempanel, or the mouse is not over it */

    /* Which menu, if any, was hit? */
    if ((newsel_menu = hitMenu()) != NOMENU)
    {
	/* Remove its subpanel, if any */
	if (subpanel_of != NOITEM)
	{
	    eraseSub();
	    highItem();
	}
	/* Is this a different menu? */
	if (newsel_menu != sel_menu)
	{
	    /* Remove the old itempanel, if any */
	    if (itempanel_of != NOMENU)
	    {
		eraseItem();
		highMenu();
	    }

	    /* select and highlight this one and draw its itemlist */
	    SETSMENU(newsel_menu);
	    highMenu();
	    drawItem(SHIFTMENU(newsel_menu));
	}
	/* else no, this menu is the same as the last time */
	SETSSUB(NOSUB);
	SETSITEM(NOITEM);
    }
}

/* Given a screen and a ClipRect whose bounds are the desired on-screen
 * location of the menu, and whose bitmap points to a buffer holding
 * the menu, bring that menu on-screen.
 *
 * This routine attempts to allocate a spare buffer so that the menu
 * may be brought up using two simple blits.  If no memory is available,
 * it uses the SwapBitsRastPortClipRect() function, which was the
 * (slower) traditional way of bringing up menus.
 */
long
swapMenuIn( sc, cr )
struct Screen *sc;
struct ClipRect *cr;
{
    struct BitMap *swapbm;
    long result = 0;
    long width;
    long height;

    /* To prevent crashing if the menu is off-screen, contrain menu
     * ClipRect to be on-screen, and only SwapBits if not degenerate.
     */
    if ( cr->bounds.MaxX >= sc->Width )
    {
	cr->bounds.MaxX = sc->Width - 1;
    }
    if ( cr->bounds.MaxY >= sc->Height )
    {
	cr->bounds.MaxY = sc->Height - 1;
    }

    width = rectWidth( &cr->bounds );
    height = rectHeight( &cr->bounds );
    if ( ( width > 0 ) && ( height > 0 ) )
    {
	/* SwapBits() is memory efficient, but slow.  For speed,
	 * we attempt to allocate a second menu buffer, and do
	 * two straight-copy blits instead (i.e. instead of the three
	 * XOR blits inside SwapBits()).  If we can't get the memory
	 * for the second buffer, we fall back to SwapBits().
	 */
	if ( swapbm = allocMenuBitMap( sc, &cr->bounds ) )
	{
	    struct BitMap *menubm = cr->BitMap;
	    menuBlit( sc, swapbm, &cr->bounds, SWAP_SCREEN_TO_OFF );

	    menuBlit( sc, menubm, &cr->bounds, SWAP_OFF_TO_SCREEN );

	    WaitBlit();
	    freeMenuBitMap( menubm );
	    cr->BitMap = swapbm;
	}
	else
	{
	    SwapBits( &sc->RastPort, cr );
	}
	result = 1;
    }
    return( result );
}


/* Blit between off-screen bitmap and screen.  'bounds' describes
 * the bounds of the on-screen area to affect.  'toscreen' selects
 * whether the blit goes to the screen or to the off-screen bitmap.
 */

menuBlit( sc, savebm, bounds, toscreen )
struct Screen *sc;
struct BitMap *savebm;
struct Rectangle *bounds;
long toscreen;
{
    LONG sourceleft;
    LONG sourcetop;
    LONG destleft;
    LONG desttop;
    struct BitMap *sourcebm;
    struct BitMap *destbm;

    sourceleft = destleft = bounds->MinX;
    sourcetop = desttop = bounds->MinY;
    if ( toscreen )
    {
	sourcebm = savebm;
	destbm = sc->RastPort.BitMap;
	sourceleft &= 0xF;
	sourcetop = 0;
    }
    else
    {
	sourcebm = sc->RastPort.BitMap;
	destbm = savebm;
	destleft &= 0xF;
	desttop = 0;
    }
    BltBitMap( sourcebm, sourceleft, sourcetop,
	destbm, destleft, desttop,
	rectWidth( bounds ), rectHeight( bounds ), 0xC0, ~0, 0 );
}
@


38.22
log
@Major optimization in menu swap speed (avoid SwapBits if we can).  Also,
significantly restructured the menu code to save ROM.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.21 92/09/02 10:21:52 peter Exp Locker: peter $
d319 3
a321 5


itemExtent( rp, mit, rect )
struct RastPort *rp;
struct MenuItem *mit;
d326 1
d329 1
a329 1
    boxToRect( &mit->LeftEdge, rect );
d331 2
a332 1
    for ( i = 0, fill = mit->ItemFill; i < 2; i++, fill = mit->SelectFill )
d337 2
a338 1
	    struct Rectangle fillrect;
d340 1
a340 1
	    if (mit->Flags & ITEMTEXT)
d345 8
a352 4
		fillrect.MaxX = fillrect.MinX = ((struct IntuiText *) fill)->LeftEdge;
		fillrect.MinY = ((struct IntuiText *) fill)->TopEdge;
		fillrect.MaxX +=  RastPortITextLength(rp, fill) - 1;
		fillrect.MaxY =  tattr? tattr->ta_YSize  : rp->TxHeight - 1;
d356 14
a369 1
		boxToRect( &((struct Image *)fill)->LeftEdge, &fillrect);
d371 3
d377 2
a378 2
	    offsetRect( &fillrect, mit->LeftEdge, mit->TopEdge );
	    rectHull( rect, &fillrect );
d380 1
d397 3
a399 3
boxer( screen, item, rect, hullrect, issubmenu )
struct Screen *screen;
struct MenuItem *item;
d404 2
a405 1
    struct MenuItem *mit;
d409 1
a409 1
    for ( mit = item; mit; mit = mit->NextItem )
d411 1
a411 1
	itemExtent( &screen->RastPort, mit, &work );
d421 1
d424 1
a424 1
	    Alert( AN_ItemBoxTop );
d426 1
d1111 1
a1111 1
    boxer( AScreen, item->SubItem, &menurect, &hullrect, 1 );
d1197 1
a1197 1
	    boxer( window->WScreen, workmenu->FirstItem,
@


38.21
log
@Was checking FSF_TAGGED in ta_Flags instead of ta_Style.  Fixes
support for tagged TextAttrs in Intuition menus.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.20 92/07/17 17:27:56 peter Exp Locker: peter $
d27 2
d30 3
d35 6
a40 2
menuImage(firstitem, xoffset, yoffset, width, height, 
	xedge, disabled)
d42 2
a43 1
int xoffset, yoffset, width, height, xedge;
d50 1
a57 1
    struct	TextFont	*OpenFont();
d66 8
d75 1
a75 1
	item, xoffset, yoffset, width, height) );
d84 3
a86 1
    drawBox(rport, xedge, 0, width, height, XWINDOW(AWindow)->MenuDetailPen, JAM1, 2, 1);
d125 2
a126 2
	left = xoffset + item->LeftEdge;
	top = yoffset + item->TopEdge;
d321 1
a321 10
/* replaces all of topFill, leftFill, rightFill, bottomFill */
/* if fill is NULL, returns item select box, relative to itself */

/* uses MenuRPort for text calculations
 * OH GOD NO!!!!  Not the MenuRPort!  That is associated
 * with the current window/screen!!  But this is called
 * by SetMenuStrip!!!
 * jimm: 5/13/89 -- fix to use correct rastport 
 */
allFill(rp, mit, fill, rect)
a323 1
APTR	fill;
d326 7
a332 1
    if (fill == NULL)
d334 25
a358 16
	boxToRect(&mit->LeftEdge, rect);
	offsetRect(rect, -rect->MinX, -rect->MinY);
    }
    else if (mit->Flags & ITEMTEXT)
    {
	struct TextAttr	*tattr;
	tattr = ((struct IntuiText *) fill)->ITextFont;

        rect->MaxX = rect->MinX = ((struct IntuiText *) fill)->LeftEdge;
	rect->MinY = ((struct IntuiText *) fill)->TopEdge;
	rect->MaxX +=  RastPortITextLength(rp, fill) - 1;
	rect->MaxY =  tattr? tattr->ta_YSize  : rp->TxHeight - 1;
    }
    else
    {
	boxToRect( &((struct Image *)fill)->LeftEdge, rect);
d371 3
a373 1
 * NOTE:  these DO NOT include MENUH -and- VPADDING
d375 2
a376 2
boxer(rp, item, rect)
struct RastPort	*rp;
d379 1
d381 1
a381 3
    struct Rectangle ifill, sfill; /* item, select fill */
    struct Rectangle iext; /* item list rectangular extent, replace *most */
    struct Rectangle work; /* temporary: box for each item	*/
d384 1
a384 1
    degenerateRect( &iext );	/* creates maximally inside out rect	*/
d386 1
a386 1
    for (mit = item; mit; mit = mit->NextItem)
d388 1
a388 13
	/* item select, as user provides */
	boxToRect(&mit->LeftEdge, &work);

	/* relative to item, get extent for itemfill and selectfill */
	allFill( rp, mit, mit->ItemFill, &ifill);
	allFill( rp, mit, mit->SelectFill, &sfill);
	rectHull(&ifill, &sfill);	/* expand ifill to contain sfill */

        /* offset to item coordinate system */
	offsetRect(&ifill, work.MinX, work.MinY);

	/* expand item box to include fill extent */
	rectHull(&work, &ifill);	/* expand work */
d391 1
a391 1
	rectHull(&iext, &work);		/* expand total extent  */
d393 1
a393 1
	DB( dumpRect("iext", &iext) );
a394 1
    *rect = iext;	/* hand answers back */
d396 20
d417 1
a417 1
	iext.MinX, iext.MaxX, iext.MinY, iext.MaxY) );
d477 1
a477 1
	SwapBits(&IBase->ActiveScreen->RastPort, &IBase->ItemCRect);
d483 1
a483 1
	FreeBitMap( IBase->ItemCRect.BitMap );
d512 1
a512 1
	SwapBits(&IBase->ActiveScreen->RastPort, &IBase->SubCRect);
d519 1
a519 1
	FreeBitMap( IBase->SubCRect.BitMap );
d922 1
a922 1
struct BitMap *AllocMenuBitMap( ascreen, left, right, top, bottom )
d924 1
a924 1
WORD left, right, top, bottom;
d927 1
a927 1
    WORD height = bottom - top + 1;
d931 1
a931 1
    WORD width = (right & (~0xF)) - (left & (~0xF)) + 16;
d978 1
a978 3
    int MXReal;
    int BX, BXReal, BXRaster, BY, BYReal;
    int  BRight, BRReal, BBottom, BBReal, BXOffset, BYOffset;
d987 8
a994 6
    MXReal = menu->LeftEdge + AScreen->BarHBorder;

    BX = menu->JazzX;
    BY = menu->JazzY;
    BRight = menu->BeatX;
    BBottom = menu->BeatY;
a995 3
    BXReal = BX + MXReal;
    BRReal = BRight + MXReal;

d997 1
a997 1
    if (BXReal < 0)
d999 2
a1000 2
	BRReal -= BXReal;	/* move it right some more */
	BXReal = 0;
a1002 7
    BYReal = AScreen->BarHeight - 1;
    BBReal = BBottom + (AScreen->BarHeight - 1)
		+ AScreen->MenuVBorder;
    BXRaster = BXReal & 0xF;
    BXOffset = BXRaster - BX;
    BYOffset = AScreen->MenuVBorder;

d1005 1
a1005 2
    if ( !( IBase->ItemCRect.BitMap = AllocMenuBitMap( AScreen,
	BXReal, BRReal, BYReal, BBReal ) ) )
d1007 9
a1015 22
	D( printf("drawItem: can't get planes\n") );
	goto BADITEM;
    }

    IBase->MenuRPort.BitMap = IBase->ItemCRect.BitMap;

    /* draws image into the window */
    /* ignore menu top */
    menuImage(menu->FirstItem,  BXOffset, BYOffset,
		BRight - BX + 1, BBReal - BYReal + 1, BXRaster, 
		!TESTFLAG( menu->Flags, MENUENABLED) );

    IBase->ItemCRect.bounds.MinX = BXReal;
    IBase->ItemCRect.bounds.MinY = BYReal;

    /* Peter 9-Aug-90: Contrain menu ClipRect to be on-screen, and
     * only SwapBits if not degenerate.
     */
    IBase->ItemCRect.bounds.MaxX = imin(BRReal,
	AScreen->Width - 1);
    IBase->ItemCRect.bounds.MaxY = imin(BBReal,
	AScreen->Height - 1);
a1016 3
    if ( ( rectWidth( &IBase->ItemCRect.bounds ) > 0 ) &&
	( rectHeight( &IBase->ItemCRect.bounds ) > 0 ) )
    {
d1018 4
a1021 2
	SwapBits(&AScreen->RastPort, &IBase->ItemCRect);
	IBase->Flags |= GOODITEMDRAWN;
a1023 1
BADITEM:
d1065 3
a1067 2
    int MXReal;
    int IXReal, IYReal;
a1068 6
    int   BXOffset, BYOffset;
    int   BXRaster;

    struct Rectangle BRect;	/* was BX, BY, BRight, BBottom */
    struct Rectangle BRealRect;	/* was BXReal, BYReal, ... */

d1081 16
a1096 3
    MXReal = menu->LeftEdge + AScreen->BarHBorder;
    IXReal = MXReal + item->LeftEdge;
    IYReal = item->TopEdge + (AScreen->BarHeight + AScreen->MenuVBorder - 1);
d1098 1
a1098 25
    boxer( &IBase->MenuRPort, item->SubItem, &BRect);

    D( dumpRect("subitem BRect", &BRect) );

    BRect.MinX -= AScreen->MenuHBorder;
    BRect.MaxX += AScreen->MenuHBorder;
    BRect.MinY -= AScreen->MenuVBorder;
    BRect.MaxY += AScreen->MenuVBorder;

    D( dumpRect("subitem BRect adjusted", &BRect) );

    /* the subitem box's left edge must start at least at right item edge */
    if (BRect.MinX > item->Width - 1) BRect.MinX = item->Width - 1;

    /* subitem box must be as far right as the start of the item */
    if (BRect.MaxX < 0) BRect.MaxX = 0;
    if (BRect.MinY > item->Height - 1) BRect.MinY = item->Height - 1;
    if (BRect.MaxY < 0) BRect.MaxY = 0;

    BRealRect = BRect;
    D( dumpRect("BRealRect", &BRealRect) );

    offsetRect(&BRealRect, IXReal, IYReal);

    D( dumpRect("offset BRealRect", &BRealRect) );
a1099 4
    BXOffset = (BXRaster = (BRealRect.MinX & 0xF)) - BRect.MinX;

    BYOffset = -BRect.MinY;

d1104 1
a1104 2
    if ( !( IBase->SubCRect.BitMap = AllocMenuBitMap( AScreen,
	BRealRect.MinX, BRealRect.MaxX, BRect.MinY, BRect.MaxY ) ) )
d1106 7
a1112 21
	D( printf("drawSub: can't get planes\n") );
	goto BADSUBITEM;
    }

    IBase->MenuRPort.BitMap = IBase->SubCRect.BitMap;

    /* draws image into the window */
    menuImage(item->SubItem,  BXOffset, BYOffset,
	rectWidth( &BRect ), rectHeight( &BRect ), BXRaster, 
	!((menu->Flags & MENUENABLED) && (item->Flags & ITEMENABLED)) );

    IBase->SubCRect.bounds = BRealRect;

    D( dumpRect("subitem SubCRect.bounds", &IBase->SubCRect.bounds) );
    /* Peter 9-Aug-90: Contrain menu ClipRect to be on-screen, and
     * only SwapBits if not degenerate.
     */
    IBase->SubCRect.bounds.MaxX = imin(IBase->SubCRect.bounds.MaxX,
	AScreen->Width - 1);
    IBase->SubCRect.bounds.MaxY = imin(IBase->SubCRect.bounds.MaxY,
	AScreen->Height - 1);
d1114 1
a1114 12
    if ( ( rectWidth( &IBase->SubCRect.bounds ) > 0 ) &&
	( rectHeight( &IBase->SubCRect.bounds ) > 0 ) )
    {
	/* swap our menu rectangle into the Active RastPort */
	D( printf("drawSub, \n" ) );
	D( dumpCRect("subcrect", &IBase->SubCRect ) );
	D( dumpBitMap("screen rastport bitmap", 
		IBase->ActiveScreen->RastPort.BitMap ) );
	
	D( kpause("--") );
	SwapBits(&AScreen->RastPort, &IBase->SubCRect);
	D( kpause("swapbits done --") );
d1116 6
a1121 2
	IBase->Flags |= GOODSUBDRAWN;
	D( printf("drawSub: goodsubdrawn\n") );
a1123 1
BADSUBITEM:
d1150 1
a1150 1
    struct Rectangle BRect;
d1157 6
a1162 4
	/* jimm: this was screwed: can't use ActiveScreen! */
	HBorder = window->WScreen->MenuHBorder;
	VBorder = window->WScreen->MenuVBorder;

d1167 1
a1167 10
	    /* jimm: 3/13/89: perhaps would be better to use ScreenFont */
	    boxer( &window->WScreen->RastPort, workmenu->FirstItem, &BRect);

	    /* the menu's top edge must start just beneath the menu */
	    if (BRect.MinY < 0) Alert( AN_ItemBoxTop );

	    BRect.MinX -= HBorder;
	    BRect.MinY -= VBorder;
	    BRect.MaxX += HBorder;
	    BRect.MaxY += VBorder;
d1169 2
a1170 2
	    /* the item box's left edge must start at least at 
	     * the left edge of the menu
d1172 2
a1173 16
	    if (BRect.MinX > 0) BRect.MinX = 0;
	    /* item box must be as far to the right as the menu */
	    if (BRect.MaxX < (workmenu->Width - 1))
	    {
		BRect.MaxX = workmenu->Width - 1;
	    }

	    /* look!  it's RJ's little secret.	*/
#if 1
	    *((struct Rectangle *)&workmenu->JazzX) = BRect;
#else
	    workmenu->JazzX = BRect.MinX;
	    workmenu->JazzY = BRect.MinY;
	    workmenu->BeatX = BRect.MaxX;
	    workmenu->BeatY = BRect.MaxY;
#endif
d1430 101
@


38.20
log
@Now use WFLG_NEWLOOKMENUS instead of WMF_NEWLOOKMENUS so it can be
public.  Now correctly copies tagged TextAttr structures the menu
command-key font.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.19 92/07/07 15:21:41 peter Exp Locker: peter $
d157 1
a157 1
		if ( TESTFLAG( commseqtattr->ta_Flags, FSF_TAGGED ) )
@


38.19
log
@Fixed bug where menu-bar ghosting was going through an unlayered
RastPort.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.18 92/06/29 10:45:26 peter Exp Locker: peter $
d50 1
a50 1
    struct TextAttr		plaintattr;
d150 16
a165 5
		/* Let's try to get the same font, in plain style */
		plaintattr = *commseqtattr;
		/* Clear all style bits and the FSF_TAGGED bit, too! */
		plaintattr.ta_Style = FS_NORMAL;
		if  ( commseqfont = OpenFont( &plaintattr ) )
d169 1
a169 1
		    commseqtattr = &plaintattr;
d643 1
a643 1
    if ( TESTFLAG( AWindow->MoreFlags, WMF_NEWLOOKMENUS ) )
d845 1
a845 1
    screenbar(s);
@


38.18
log
@Minor optimization.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.17 92/06/23 17:20:10 peter Exp Locker: peter $
d813 1
a813 1
		BlastPattern(rp,
@


38.17
log
@Comment change.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.16 92/05/21 17:42:04 peter Exp Locker: peter $
d495 3
a497 1
    register int num, x, y, height;
d506 4
a509 3
    x = AScreen->MouseX - AScreen->BarVBorder;
    y = AScreen->MouseY;
    height = AScreen->BarHeight;
d515 3
a517 2
	if (collide(x, y, menu->LeftEdge, 0,
		menu->Width, height))
d557 2
a558 1
    register int num, relx, rely;
d568 4
a571 3
       menu items: */
    relx = AScreen->MouseX - AScreen->BarHBorder - menu->LeftEdge;
    rely = AScreen->MouseY - AScreen->BarHeight - AScreen->MenuVBorder + 1;
d576 2
a577 2
	relx -= item->LeftEdge;
	rely -= item->TopEdge;
d584 1
a584 2
	if (collide(relx, rely, item->LeftEdge, item->TopEdge,
		item->Width, item->Height))
@


38.16
log
@SetMenuStrip()/ResetMenuStrip() share a function.  Now call Alert()
instead of execAlert().
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.15 92/05/15 14:07:32 peter Exp Locker: peter $
d501 3
a503 3
    /*  ZZZ Peter 9-Aug-90: This should have been BarHBorder, but
	we leave it as VBorder, since it gets rendered this same
	wrong way */
d607 3
a609 4
    /*  ZZZ Peter 9-Aug-90: This should have been BarHBorder, but
	we leave it as VBorder, since we shouldn't move the rendering
	for compatibility */

@


38.15
log
@No longer call LOCKSTATE() in IOnOffMenu since we're already on the
state machine.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.14 92/05/01 13:53:27 peter Exp Locker: peter $
a1150 10

BOOL
ResetMenuStrip(window, menu)
struct Window *window;
struct Menu *menu;
{
    doISM( itSETMENU, window, menu, FALSE );

    return ( TRUE );
}
d1154 1
a1154 1
SetMenuStrip(window, menu)
d1157 1
d1159 1
a1159 1
    doISM( itSETMENU, window, menu, TRUE );
d1190 1
a1190 1
	    if (BRect.MinY < 0) execAlert( AN_ItemBoxTop );
@


38.14
log
@Took out 2nd BorderPatrol() parameter.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.13 92/04/07 17:54:15 peter Exp Locker: peter $
d1199 1
a1199 1
	    if (BRect.MinY < 0) execAlert(AN_ItemBoxTop);
d1262 1
a1262 1
    LOCKSTATE();	/* wait until user done with menu */
a1303 1
    UNLOCKSTATE();
@


38.13
log
@Optimization/cleanup.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.12 92/04/01 15:06:29 peter Exp Locker: peter $
d831 1
a831 1
    BorderPatrol( s, NULL );
@


38.12
log
@Evicted autodocs.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.11 92/03/24 11:56:45 peter Exp Locker: peter $
a304 2
    struct IntuitionBase *IBase = fetchIBase();

a345 1
    int temp;
a596 1
    struct Window *AWindow;
a761 1
    struct IntuitionBase *IBase = fetchIBase();
a827 2
    struct IntuitionBase *IBase = fetchIBase();

d930 1
a930 2
    struct MenuItem *item;
    int MX, MXReal, MY;
d1043 2
a1044 2
    int MX, MXReal, MY;
    int IX, IXReal, IY, IYReal;
a1183 1
    struct IntuitionBase *IBase = fetchIBase();
d1251 1
a1251 1
    int menupick, i;
@


38.11
log
@Now pass NULL for new second parameter to BorderPatrol().
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.10 92/02/20 12:14:49 peter Exp Locker: peter $
d1158 1
a1159 48
/****** intuition.library/ResetMenuStrip **************************************
*
*    NAME
*	ResetMenuStrip -- Re-attach a menu strip to a window. (V36)
*
*    SYNOPSIS
*	Success = ResetMenuStrip( Window, Menu )
*	D0		          A0      A1
*
*	BOOL ResetMenuStrip( struct Window *, struct Menu * );
*
*    FUNCTION
*	This function is simply a "fast" version of SetMenuStrip() that
*	doesn't perform the precalculations of menu page sizes that
*	SetMenuStrip() does.
*
*	You may call this function ONLY IF the menu strip and all items
*	and sub-items have not changed since the menu strip was passed to
*	SetMenuStrip(), with the following exceptions:
*
*	- You may change the CHECKED flag to turn a checkmark on or off.
*	- You may change the ITEMENABLED flag to enable/disable some
*	  MenuItem or Menu structures.
*
*	In all other ways, this function performs like SetMenuStrip().
*
*	The new sequence of events you can use is:
*	- OpenWindow()
*	- SetMenuStrip()
*	zero or more iterations of:
*	    - ClearMenuStrip()
*	    - change CHECKED or ITEMENABLED flags
*	    - ResetMenuStrip()
*	- ClearMenuStrip()
*	- CloseWindow()
*
*    INPUTS
*	Window = pointer to a Window structure
*	Menu = pointer to the first menu in the menu strip
*
*    RESULT
*	TRUE always.
*
*    BUGS
*
*    SEE ALSO
*	SetMenuStrip(), ClearMenuStrip()
****************************************************************************/
d1169 1
a1170 47
/****** intuition.library/SetMenuStrip **************************************
*
*    NAME
*	SetMenuStrip -- Attach a menu strip to a window.
*
*    SYNOPSIS
*	Success = SetMenuStrip( Window, Menu )
*	D0		        A0      A1
*
*	BOOL SetMenuStrip( struct Window *, struct Menu * );
*
*    FUNCTION
*	Attaches the menu strip to the window.  After calling this routine,
*	if the user presses the menu button, this specified menu strip
*	will be displayed and accessible by the user.
*
*	Menus with zero menu items are not allowed.
*
*	NOTE:  You should always design your menu strip changes to be a 
*	two-way operation, where for every menu strip you add to your 
*	window you should always plan to clear that strip sometime.  Even 
*	in the simplest case, where you will have just one menu strip for 
*	the lifetime of your window, you should always clear the menu strip 
*	before closing the window.  If you already have a menu strip attached 
*	to this window, the correct procedure for changing to a new menu 
*	strip involves calling ClearMenuStrip() to clear the old first.  
*
*	The sequence of events should be:
*	- OpenWindow()
*	- zero or more iterations of:
*      	- SetMenuStrip()
*      	- ClearMenuStrip()
*	- CloseWindow()
*
*    INPUTS
*	Window = pointer to a Window structure
*	Menu = pointer to the first menu in the menu strip
*
*    RESULT
*	TRUE if there were no problems.  TRUE always, since this routine
*	will wait until it is OK to proceed.
*
*    BUGS
*
*    SEE ALSO
*	ClearMenuStrip(), ResetMenuStrip()
****************************************************************************/
d1243 1
a1244 34
/****** intuition.library/ClearMenuStrip *************************************
*
*    NAME
*	ClearMenuStrip -- Clear (detach) the menu strip from the window.
*
*    SYNOPSIS
*	ClearMenuStrip( Window )
*		        A0
*
*	VOID ClearMenuStrip( struct Window * );
*
*    FUNCTION
*	Detaches the current menu strip from the window; menu strips
*	are attached to windows using the SetMenuStrip() function
*	(or, for V36, ResetMenuStrip() ).
*
*	If the menu is in use (for that matter if any menu is in use)
*	this function will block (Wait()) until the user has finished.
*
*	Call this function before you make any changes to the data
*	in a Menu or MenuItem structure which is part of a menu
*	strip linked into a window.
*
*    INPUTS
*	Window = pointer to a window structure
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	SetMenuStrip(), ResetMenuStrip()
****************************************************************************/
d1317 1
a1318 28
/****** intuition.library/OnMenu *******************************************
*
*    NAME
*	OnMenu -- Enable the given menu or menu item.
*
*    SYNOPSIS
*	OnMenu( Window, MenuNumber )
*	        A0      D0
*
*	VOID OnMenu( struct Window *, UWORD );
*
*    FUNCTION
*	This command enables a sub-item, an item, or a whole menu.
*	This depends on the contents of the data packed into MenuNumber,
*	which is described in the Intuition Reference Manual.
*
*    INPUTS
*	Window = pointer to the window
*	MenuNumber = the menu piece to be enables
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	OffMenu(), ResetMenuStrip()
****************************************************************************/
d1326 1
a1327 28
/****** intuition.library/OffMenu *******************************************
*
*    NAME
*	OffMenu -- Disable the given menu or menu item.
*
*    SYNOPSIS
*	OffMenu( Window, MenuNumber )
*		 A0      D0
*
*	VOID OffMenu( struct Window *, UWORD );
*
*    FUNCTION
*	This command disables a sub-item, an item, or a whole menu.
*	This depends on the contents of the data packed into MenuNumber,
*	which is described in the Intuition Reference Manual.
*
*    INPUTS
*	Window = pointer to the window
*	MenuNumber = the menu piece to be disabled
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	OnMenu(), ResetMenuStrip()
****************************************************************************/
@


38.10
log
@Now use screen->RastPort.BitMap instead of RealBitMap, since RealBitMap
no longer changes.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.9 92/02/17 17:14:19 peter Exp Locker: peter $
d838 1
a838 1
    BorderPatrol( s );
@


38.9
log
@Now use XScreen->RealBitMap instead of screen->sc_BitMap.  Eliminated
unused local vars.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.8 92/02/11 13:39:37 peter Exp Locker: peter $
d466 1
a466 1
	D( printf( "rastport %lx, rpbitmap %lx, scbitmap %lx, plane 0 %lx\n",
a468 1
		XSC(IBase->ActiveScreen)->RealBitMap,
d895 2
a896 1
	    XSC(ascreen)->RealBitMap->Depth, NULL, XSC(ascreen)->RealBitMap );
d1141 2
a1142 2
	D( dumpBitMap("screen bitmap", 
		XSC(IBase->ActiveScreen)->RealBitMap ) );
@


38.8
log
@BPattern is now of "size" 1.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.7 91/12/12 20:46:11 peter Exp Locker: peter $
d469 1
a469 1
		&IBase->ActiveScreen->sc_BitMap,
d896 1
a896 1
	    ascreen->sc_BitMap.Depth, NULL, &ascreen->sc_BitMap );
a940 1
    int depth;
a1059 1
    int depth;
d1142 1
a1142 1
		&IBase->ActiveScreen->sc_BitMap ) );
@


38.7
log
@Some compiled-out code no longer calls FillRect().
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.6 91/11/15 18:52:35 peter Exp Locker: peter $
d184 1
a184 1
		    BPattern, 2, XWINDOW(AWindow)->MenuBlockPen, 0, JAM1);
d819 1
a819 1
			BPattern, 2,
@


38.6
log
@Menu bitmaps now come from AllocBitMap(), to save space and also to
be copacetic with graphics' interleaved bitmaps.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.5 91/08/21 18:18:55 peter Exp Locker: peter $
d261 4
a264 1
		
d266 2
a267 1
		FillRect( rport, &rect, XWINDOW(AWindow)->MenuBlockPen );
@


38.5
log
@Deleted compiled-out dropshadow code.  Now refers to screen->sc_BitMap
instead of (equivalent) screen->BitMap, for clarity.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.4 91/07/10 17:57:57 peter Exp Locker: peter $
d435 5
a439 1
    freeBitMapPlanes( &IBase->IBitMap );
d472 5
a476 1
    freeBitMapPlanes( &IBase->SBitMap );
a488 24
freeBitMapPlanes( bm )
struct BitMap	*bm;
{
    void	**plane;
    int		rassize;
    int		depth;

    if ( bm )
    {
	plane = (void **) bm->Planes;
	depth = bm->Depth;
	rassize = bm->BytesPerRow * bm->Rows;

	WaitBlit();
	while ( depth-- > 0 )
	{
	    /* don't free dummy planes */
	    if ( *plane && (*plane != (void *)0xffffffff) )
		FreeMem( *plane++, rassize );
	}
    }
}


d874 23
d970 1
a970 3
    /* set up our menu RastPort */
    IBase->MenuRPort.BitMap = &IBase->IBitMap;
    IBase->IBitMap.Rows = BBReal - BYReal + 1;
d972 2
a973 1
    if (!getPlanes(&IBase->IBitMap, BXReal, BRReal))
d979 2
a1053 2
    int   blitbytes;	/* temp */

d1106 1
a1106 3
    /* set up our menu RastPort */
    IBase->MenuRPort.BitMap = &IBase->SBitMap;
    IBase->SBitMap.Rows = BRect.MaxY - BRect.MinY + 1;
d1108 2
a1109 1
    if (!getPlanes(&IBase->SBitMap, BRealRect.MinX, BRealRect.MaxX))
d1115 2
a1155 37

/* true if all gotten ok
 * puts NULL in failed planes
 * sets bytes per row
 */
getPlanes(bmap, x, y)
struct BitMap *bmap;
int x, y;
{
    int blitbytes;
    int i;
    LONG retval = TRUE;

    blitbytes = bmap->BytesPerRow = BLITBYTES(x, y);

    D( printf("getPlanes. bitmap at %lx, depth %ld\n", bmap, bmap->Depth));
    D( printf("getPlanes: blitbytes: %ld, rows %ld\n", blitbytes, bmap->Rows ) );
    D( if (bmap->Depth <= 0) {printf("getPlanes depth 0\n"); Debug();} )

    /* Empty menu panels are degenerate in the Y-direction: */
    if ( ( (WORD)bmap->Rows ) < 0 )
    {
	retval = FALSE;
    }

    /* all planes pointers get set to something. */
    for (i = 0; i < bmap->Depth; i++)
    {
	/* once retval FALSE, just fill pointers with NULL */
	retval = (LONG)
	    (bmap->Planes[i] =
		retval? AllocRaster(blitbytes * 8, (LONG)bmap->Rows): NULL);
	D( printf("getPlanes plane %ld at %lx\n", i, bmap->Planes[i] ) );
    }
    return ( retval );
}

@


38.4
log
@Menuless windows get new-look menu colors.  Last row of titlebar is
now rendered in BARTRIMPEN.  Now uses common drawScreenBar().
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.3 91/06/24 12:15:20 peter Exp Locker: peter $
a11 2
/*#define MENU_SHADOW*/

a66 9
#ifdef MENU_SHADOW
    /* Draw the cute little shadow */
    drawBox(rport, xedge, 0, width-2, height-1, XWINDOW(AWindow)->MenuDetailPen, JAM1, 2, 1);
    SetAPen(rport, 0);
    WritePixel(rport, xedge+width-2, 0);
    WritePixel(rport, xedge+width-1, 0);
    WritePixel(rport, xedge, height-1);
    WritePixel(rport, xedge+1, height-1);
#endif
d461 1
a461 1
		&IBase->ActiveScreen->BitMap,
a944 5
#ifdef MENU_SHADOW
    /* Add two/one for the cute shadow */
    BRight = menu->BeatX + 2;
    BBottom = menu->BeatY + 1;
#endif
a1085 5
#ifdef MENU_SHADOW
    /* Add pixel(s) for the cute shadow */
    BRect.MaxX += 2;
    BRect.MaxY++;
#endif
d1133 1
a1133 1
		&IBase->ActiveScreen->BitMap ) );
@


38.3
log
@Ghosted menu-headers were ghosted in the wrong color.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.2 91/06/19 18:05:14 peter Exp Locker: peter $
d805 2
d810 10
d821 3
a823 1
    drawBlock( rp, 0, s->BarHeight, s->Width - 1, itext.FrontPen);
a830 1
    m = w->MenuStrip;
@


38.2
log
@Removed obsolete code.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 38.1 91/06/12 15:11:21 peter Exp Locker: peter $
d830 1
a830 1
			w->BlockPen, 0, JAM1);
@


38.1
log
@Enabled NewLook titlebar.
Now uses window->MenuXXXPen fields for rendering.  Uses complement-masking
trick to get the complement colors right.
Added conditional code for adding drop-shadow to menu.
Now uses XWindow->AmigaIcon for Amiga key.
@
text
@d5 1
a5 1
 *  $Id: menu.c,v 36.35 91/04/12 14:24:29 peter Exp Locker: peter $
a28 1
#define PATCHWBFONTS 0
a29 1

a155 1
#if 1
a156 3
#else
	    i = (left+item->Width) - RastPortITextLength(rport, &itext) - 2;
#endif
a491 18
#if 0

oh, lord, let's write freeBitMapPlanes() right away

eraseGrunt(BitMap)
struct BitMap *BitMap;
{
    int i;

    /* jimm: 4/22/86: big help, this WaitBlit() */
    WaitBlit();
    for (i = 0; i < BitMap->Depth; i++)	/* all pointer valid or NULL */
	if (BitMap->Planes[i])
	    FreeRaster(BitMap->Planes[i],
		    BitMap->BytesPerRow * 8, BitMap->Rows);
}
#endif

a1511 1
#if 1
a1513 3
#else
    return(onOffMenu(window, menuNum, TRUE));
#endif
a1547 1
#if 1
a1549 3
#else
    return(onOffMenu(window, menuNum, FALSE));
#endif
@


38.0
log
@Initial V38 check-in (matches V37 release).
@
text
@a0 2


d5 1
a5 1
 *  $Id: menu.c,v 36.35 91/04/12 14:24:29 peter Exp $
d12 2
d46 1
a46 1
    UBYTE charbuf[2], res;
a66 3
    if (IsHires(IBase->ActiveScreen)) res = HIRESGADGET;
    else res = LOWRESGADGET;

d69 12
a80 4
    SetRast(rport, AWindow->BlockPen);
    drawBox(rport, xedge, 0, width, height, AWindow->DetailPen, JAM1, 2, 1);

    itext.FrontPen = AWindow->DetailPen;
d186 2
a187 2
	    DrawImage( rport, IBase->AmigaIcon[res],
		i - IBase->AmigaIcon[res]->Width - 2,
d189 1
a189 1
		commseqbaseline - (IBase->AmigaIcon[res]->Height-1) ) );
d201 1
a201 1
		    BPattern, 2, AWindow->BlockPen, 0, JAM1);
d280 1
a280 1
		FillRect( rport, &rect, AWindow->BlockPen );
d648 1
d662 3
a664 1
	xorbox(RP, AScreen->BarVBorder + menu->LeftEdge, 
d670 15
d702 3
a704 1
		xorbox(RP, left, top, item->Width, item->Height);
d708 1
d710 1
d829 2
a830 3
#ifdef NEWLOOK_TITLEBAR
    itext.FrontPen = XSC(s)->SDrawInfo.dri_Pens [ sbartextPen ];
    itext.BackPen = XSC(s)->SDrawInfo.dri_Pens [ sbarfillPen ];
d832 2
a833 3
    drawBlock(rp, 0, 0, s->Width - 1, s->BarHeight, itext.BackPen);
#else
    drawBlock(rp, 0, 0, s->Width - 1, s->BarHeight, w->BlockPen);
a834 3
    itext.FrontPen = w->DetailPen;
    itext.BackPen = w->BlockPen;
#endif
a848 8
#ifdef NEWLOOK_TITLEBAR
		BlastPattern(rp,
			s->BarHBorder + m->LeftEdge, 0,
			s->BarHBorder + m->LeftEdge + m->Width - 1, 
			s->BarHeight - 1,
			BPattern, 2,
			itext.BackPen, 0, JAM1);
#else
a854 1
#endif			
d967 5
d1113 5
@
