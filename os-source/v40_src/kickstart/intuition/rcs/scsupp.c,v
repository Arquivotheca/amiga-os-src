head     38.32;
branch   ;
access   ;
symbols  V40_85:38.32 V40_71:38.32 V40_68:38.32 V40_65:38.32 V40_47:38.32 V40_45:38.32 V40_37:38.32 V40_34:38.32 V40_29:38.31 V39_2415:38.31 V39_2369:38.31 V39_2339:38.30 V39_2332:38.30 V39_2275:38.29 V39_2256:38.28 V39_2210:38.27 V39_2192:38.26 V39_2084:38.26 V39_2082:38.26 V39_2076:38.26 V39_2073:38.26 V39_2058:38.26 V39_2051:38.26 V39_2031:38.26 V39_2017:38.26 V39_2012:38.26 V39_1985:38.26 V39_1933:38.26 V39_1819:38.25 V39_1805:38.25 V39_1783:38.25 V39_1695:38.24 V39_1621:38.23 V39_1620:38.23 V39_1508:38.22 V39_1485:38.22 V39_1461:38.22 V39_1458:38.22 V39_1456:38.22 V39_1405:38.21 V39_1368:38.21 V39_1360:38.21 V39_1324:38.21 V39_1147:38.20 V39_1143:38.20 V39_1141:38.20 V39_1120:38.19 V39_1116:38.19 V39_1104:38.19 V39_1100:38.19 V39_1078:38.19 V39_1073:38.19 V39_757:38.18 V39_702:38.16 V39_557:38.11 V39_553:38.11 V39_551:38.11 V39_510:38.10 V39_495:38.9 V39_416:38.7 V39_383:38.7 V39_371:38.7 V39_336:38.7 V39_323:38.6 V39_295:38.5 V39_277:38.5 V39_254:38.5 V39_222:38.4 V39_185:38.4 V39_171:38.4 V39_161:38.4 V38_159:38.4 V38_116:38.4 V38_59:38.3;
locks    ; strict;
comment  @*   @;


38.32
date     93.03.12.13.53.35;  author peter;  state Exp;
branches ;
next     38.31;

38.31
date     93.01.08.14.48.51;  author peter;  state Exp;
branches ;
next     38.30;

38.30
date     92.12.09.18.15.19;  author peter;  state Exp;
branches ;
next     38.29;

38.29
date     92.12.04.11.57.53;  author peter;  state Exp;
branches ;
next     38.28;

38.28
date     92.11.25.15.41.37;  author peter;  state Exp;
branches ;
next     38.27;

38.27
date     92.11.20.18.32.31;  author peter;  state Exp;
branches ;
next     38.26;

38.26
date     92.08.02.12.44.50;  author peter;  state Exp;
branches ;
next     38.25;

38.25
date     92.07.17.17.30.23;  author peter;  state Exp;
branches ;
next     38.24;

38.24
date     92.07.08.15.26.42;  author peter;  state Exp;
branches ;
next     38.23;

38.23
date     92.06.23.17.22.01;  author peter;  state Exp;
branches ;
next     38.22;

38.22
date     92.06.03.17.36.39;  author peter;  state Exp;
branches ;
next     38.21;

38.21
date     92.05.21.17.45.21;  author peter;  state Exp;
branches ;
next     38.20;

38.20
date     92.05.01.13.54.44;  author peter;  state Exp;
branches ;
next     38.19;

38.19
date     92.04.01.15.08.22;  author peter;  state Exp;
branches ;
next     38.18;

38.18
date     92.03.26.18.42.26;  author peter;  state Exp;
branches ;
next     38.17;

38.17
date     92.03.26.16.40.12;  author peter;  state Exp;
branches ;
next     38.16;

38.16
date     92.03.24.11.57.29;  author peter;  state Exp;
branches ;
next     38.15;

38.15
date     92.03.23.11.54.49;  author peter;  state Exp;
branches ;
next     38.14;

38.14
date     92.03.21.14.53.24;  author peter;  state Exp;
branches ;
next     38.13;

38.13
date     92.03.19.15.53.55;  author peter;  state Exp;
branches ;
next     38.12;

38.12
date     92.03.18.11.51.04;  author peter;  state Exp;
branches ;
next     38.11;

38.11
date     92.03.03.16.35.25;  author peter;  state Exp;
branches ;
next     38.10;

38.10
date     92.02.21.17.04.29;  author peter;  state Exp;
branches ;
next     38.9;

38.9
date     92.02.20.12.16.46;  author peter;  state Exp;
branches ;
next     38.8;

38.8
date     92.02.17.17.16.47;  author peter;  state Exp;
branches ;
next     38.7;

38.7
date     92.01.28.12.40.56;  author peter;  state Exp;
branches ;
next     38.6;

38.6
date     92.01.22.16.44.29;  author peter;  state Exp;
branches ;
next     38.5;

38.5
date     91.11.15.18.53.54;  author peter;  state Exp;
branches ;
next     38.4;

38.4
date     91.07.25.15.04.28;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     91.07.10.18.01.49;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     91.06.19.18.07.13;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.06.12.15.13.15;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.12.14.31.00;  author peter;  state Exp;
branches ;
next     ;


desc
@@


38.32
log
@Fixed bad args to FreeScreenBuffer().
@
text
@/*** scsupp.c ***************************************************************
 *
 *  scsupp.c -- screens support routines
 *
 *  $Id: scsupp.c,v 38.31 93/01/08 14:48:51 peter Exp Locker: peter $
 *
 *  Confidential Information: Commodore-Amiga, Inc.
 *  Copyright (c) Commodore-Amiga, Inc.
 *
 ****************************************************************************/

#include "intuall.h"

#ifndef EXEC_MEMORY_H
#include <exec/memory.h>
#endif

#ifndef GRAPHICS_DISPLAYINFO_H
#include <graphics/displayinfo.h>
#endif

#define D(x) 	;
#define DSG(x) 	;	/* screenGadgets*/
#define DST(x) 	;
#define DMS(x) 	;
#define DSB(x)	;	/* screenbar	*/
#define DDB(x)	;	/* double-buffering */
#define DMV(x)	;	/* SPOS_MAKEVISIBLE processing */
#define DAT(x)	;	/* Attached screens */

/* This was a cute experiment to have ScreenPosition() with the
 * SPOS_MAKEVISIBLE option slide the screen across several frames,
 * to boost visual continuity.  Someday it should be made smarter
 * and implemented, either by default or through an extra flag.
 */
#define ANIMATE_MAKEVISIBLE	0
#define ANIM_MV_FRAMES		8

/* -----------------------------------------------------------------------
 * the intimacy of the following three routines separates me from
 * all other programmers [-RJ]
 */
forceBarFront(s)
REGISTER struct Screen *s;
/* if the BarLayer is still SIMPLE_REFRESH, you probably want to
 * do a screenbar() after this call to redraw the Screen Title Bar 
 */
{
    REGISTER struct Layer_Info *LayerInfo;
    LayerInfo = &s->LayerInfo;

    LockLayerInfo(LayerInfo);
    s->BarLayer->Flags &= ~LAYERBACKDROP;
    UpfrontLayer(NULL, s->BarLayer);
    UnlockLayerInfo(LayerInfo);
}
forceBarBack(s)
REGISTER struct Screen *s;
/* after calling this routine, you probably want to do a BorderPatrol()
 * to allow any newly-revealed SIMPLE_REFRESH Windows the knowledge
 * of the required refresh
 */
{
    REGISTER struct Layer_Info *LayerInfo;
    LayerInfo = &s->LayerInfo;

    LockLayerInfo(LayerInfo);
    s->BarLayer->Flags |= LAYERBACKDROP;
    BehindLayer(NULL, s->BarLayer);
    UnlockLayerInfo(LayerInfo);
}
forceBarCenter(s)
REGISTER struct Screen *s;
/* after calling this routine, you probably want to do a BorderPatrol()
 * to allow any newly-revealed SIMPLE_REFRESH Windows the knowledge
 * of the required refresh
 */
{
    REGISTER struct Layer_Info *LayerInfo;
    LayerInfo = &s->LayerInfo;

    LockLayerInfo(LayerInfo);
    /***ZZZ: wonder about forcing to front first ***/
    forceBarFront(s);
    BehindLayer(NULL, s->BarLayer);
    s->BarLayer->Flags |= LAYERBACKDROP;
    UnlockLayerInfo(LayerInfo);
}

/* ------------------------------------------------------------------------ */


#define SGTYPECOUNT 2
USHORT SGadgetTypes[SGTYPECOUNT] =
    {
    SUPFRONTGADGET, 
    SDRAGGADGET, 		/* COUNTING on this to be last	*/
    };

/*
 * take a lesser voodoo approach to this: we know there
 * are only two system screen gadgets
 */
screenGadgets( s )
struct Screen	*s;
{
    int res = IsHires(s)? HIRESGADGET: LOWRESGADGET;
    struct Gadget	*g;
    struct Gadget	*createNewSysGadget();

    DSG( printf("screenGadgets s: %lx\n", s ) );

    /* get depth gadget */
    g = createNewSysGadget( s, res, SUPFRONTGADGET, 0 );
    DSG( printf("got depth gadget at %lx\n", g ) );
    if ( !g ) return ( 0 );

    s->FirstGadget = g;
    SETFLAG( g->GadgetType, SCRGADGET );
    if ( TESTFLAG( s->Flags, SCREENQUIET ) ) 
    {
	g->GadgetRender = NULL;	/* ZZZ: should be more oopsi */
    }

    /* get draggadget	*/
    g = createNewSysGadget( s, res, SDRAGGADGET, 0 );
    DSG( printf("got drag gadget at %lx\n", g ) );
    if ( !g ) return ( 0 );

    s->FirstGadget->NextGadget = g;
    SETFLAG( g->GadgetType, SCRGADGET );
    g->Height = s->BarHeight+1;	/* BarLayer is BarHeight+1 tall */
    DSG( printf("make drag gadget height: %ld\n", g->Height ));

    return ( 1 );
}

/*** intuition.library/MoveScreen ***/
/* Downcoded into intuitionface.asm */

/*** intuition.library/ScreenPosition ***/

ScreenPosition( screen, flags, x1, y1, x2, y2 )
struct Screen *screen;
ULONG flags;
LONG x1, y1, x2, y2;
{
    struct Rectangle rect;

    rect.MinX = x1;
    rect.MinY = y1;
    rect.MaxX = x2;
    rect.MaxY = y2;

    /* We only allow the caller to set those flags
     * defined by SPOS_USERMASK to be user-settable.
     */
    doISM( itMOVESCREEN, screen, &rect, ( flags & SPOS_USERMASK ) );

    /* Synchronous, so it's OK to pass a pointer to one of my local
     * variables.  Wouldn't work for sendISM()
     */
}


/* Prefix routine to IMoveScreen().  Internal callers of IMoveScreen()
 * generally call that routine directly.  However, callers arriving
 * via ScreenPosition() or MoveScreen() stop here first.
 * This routine validates that the screen is known, and also
 * takes care of evaluating the SPOS_MAKEVISIBLE feature.
 */
IPreMoveScreen( screen, rect, flags )
struct Screen *screen;
struct Rectangle *rect;
ULONG flags;
{
    struct IBox visibox, dclipbox;
#if ANIMATE_MAKEVISIBLE
    LONG animate = FALSE;
#endif

    if ( knownScreen( screen ) )
    {
	/* If SPOS_MAKEVISIBLE was specified, then the caller wants
	 * this screen scrolled so that the specified rect is visible.
	 */

	if ( ( flags & SPOS_TYPEMASK ) == SPOS_MAKEVISIBLE )
	{
	    /* Get visible rectangle and dclip into IBoxes,
	     * and shift dclip box to have its origin at the
	     * screen upper-left
	     */
	    rectToBox( rect, &visibox );
#if 000
	    rectToBox( &XSC(screen)->DClip, &dclipbox );
#else
	    rectToBox( &XSC(screen)->VPExtra->DisplayClip, &dclipbox );
#endif
	    DMV( printf("visibox: l/t/w/h = %ld,%ld,%ld,%ld\n",
		visibox.Left, visibox.Top, visibox.Width, visibox.Height ) );
	    DMV( printf("dclipbox: l/t/w/h = %ld,%ld,%ld,%ld\n",
		dclipbox.Left, dclipbox.Top, dclipbox.Width, dclipbox.Height ) );
	    dclipbox.Left -= screen->LeftEdge;
	    dclipbox.Top -= screen->TopEdge;
	    DMV( printf("dclipbox in screen coords: l/t/w/h = %ld,%ld,%ld,%ld\n",
		dclipbox.Left, dclipbox.Top, dclipbox.Width, dclipbox.Height ) );

	    /* Now shift the visible box to fit in the DClip */
	    boxFit( &visibox, &dclipbox, &visibox );
	    DMV( printf("visibox made to fit: l/t/w/h = %ld,%ld,%ld,%ld\n",
		visibox.Left, visibox.Top, visibox.Width, visibox.Height ) );

	    /* The distance to move the screen is the new position
	     * less the old one...
	     */
	    rect->MinX = visibox.Left - rect->MinX;
	    rect->MinY = visibox.Top - rect->MinY;
	    DMV( printf("Distance to move is %ld, %ld\n", rect->MinX, rect->MinY ) );
	    /* Convert to an SPOS_RELATIVE command */
	    flags = ( flags & ~SPOS_TYPEMASK ) | SPOS_RELATIVE;

#if ANIMATE_MAKEVISIBLE
	    animate = TRUE;
#endif
	}
#if ANIMATE_MAKEVISIBLE
	/* Move the screen in several steps, so that visual continuity
	 * between the old and new location is established.  This code
	 * was an experiment, worth keeping around for reference.
	 *
	 * To complete this, we'd want to tune the number of frames
	 * used for the motion, and also set a minimum motion, so that
	 * really short moves aren't done in ANIM_MV_FRAMES steps.
	 */
	if ( animate )
	{
	    struct Point change;
	    LONG i;

	    change = *((struct Point *)&rect->MinX);
	    rect->MinX = change.X/ANIM_MV_FRAMES;
	    rect->MinY = change.Y/ANIM_MV_FRAMES;
	    for ( i = 0; i < ANIM_MV_FRAMES; i++ )
	    {
		/* On the last pass, get all the leftover */
		if ( i == ANIM_MV_FRAMES-1 )
		{
		    *((struct Point *)&rect->MinX) = change;
		}
		IMoveScreen( screen, (struct Point *)rect, flags );
		change.X -= rect->MinX;
		change.Y -= rect->MinY;
	    }
		
	}
	else
	{
	    /* Now move the sucker... */
	    IMoveScreen( screen, (struct Point *)rect, flags );
	}
#else
	/* Now move the sucker... */
	IMoveScreen( screen, (struct Point *)rect, flags );
#endif
    }
}

IMoveScreen( screen, delta, flags )
struct Screen *screen;
struct Point	*delta; /* delta motion, unless SPOS_ABSOLUTE specified */
WORD flags;	/* magic menu can move us farther right than nml */
{
    struct Rectangle  legal_positions;
    struct Point	position;
    WORD	dx, dy;
    struct MinNode *node, *succ;
    struct Screen *child;

    DMS( printf("--- MoveScreen(%lx,%ld,%ld)\n",screen,dx,dy) );
    DMS( printf("   old position: %ld, %ld\n", screen->LeftEdge, 
	screen->TopEdge));

    /* Assumed to be deltas, but later we'll check SPOS_ABSOLUTE */
    dx = delta->X;
    dy = delta->Y;

    /* This is an "early bail-out" test.  Scram if the screen is not
     * known or no motion was requested.  If SPOS_REVALIDATE is set,
     * we stick around, since we're being asked to revalidate the
     * screen position even though no motion was requested.  If
     * SPOS_ABSOLUTE is set, it's too early to tell if any motion
     * occurred.
     */
    if ( ! ( dx || dy || (TESTFLAG( flags, SPOS_ABSOLUTE|SPOS_REVALIDATE ) ) ) )
    {
	return (FALSE);
    }

    /* If we can't slide the screen, then we have no further
     * work to do here.
     */
    if ( !canSlide( screen, TESTFLAG( flags, SPOS_FORCEDRAG ) ) )
    {
	DMS( printf("MoveScreen: non-draggable screen, not forced!\n") );
	return (FALSE);
    }

    /* get the legal positions for the screen,
     * in screen coords
     * Peter 26-Apr-91: For compatibility, programmatic screen motion
     * is unbounded at the bottom.  (Note that interactive screen
     * dragging is bounded in startScreenDrag() by the
     * establishment of mouse limits)
     */
    screenLegalPosition( screen, &legal_positions, flags|SPOS_UNBOUNDEDBOTTOM );

    /* get (proposed) new position in screen coordinates, assuming
     * that they're relative (the traditional kind)
     */
    position.X = screen->LeftEdge + dx;
    position.Y = screen->TopEdge + dy;
    if ( TESTFLAG( flags, SPOS_ABSOLUTE ) )
    {
	/* We just discovered that the caller supplied absolute
	 * coordinates instead, so grab those...
	 */
	position = *delta;
    }

    DMS( printf("MS: new proposed position: %ld, %ld\n",
	position.X, position.Y ) );

    limitPoint( &position, &legal_positions );

    DMS(printf("constrained new position: %ld, %ld\n",position.X,position.Y) );

    if ( (position.Y - screen->TopEdge) || (position.X - screen->LeftEdge) )
    {
	struct Screen *parent;

	/* Need the VIEWCPRLOCK (which is really the GfxBase->ActiViewCprSemaphore)
	 * to protect the copper lists between MakeScreen() and
	 * RethinkDisplay().  I also grab the IBASELOCK since MakeScreen()
	 * needs that, and I've got to get it before the VIEWLOCK.
	 */
	LOCKIBASE();
	LOCKVIEW();
	LOCKVIEWCPR();

	/* Is this screen a child, attached to some parent? */
	if ( parent = XSC(screen)->ParentScreen )
	{
	    /* Update its ParentYOffset wrt. the parent screen */
	    XSC(screen)->ParentYOffset = position.Y - parentOriginY( screen, parent );
	    XSC(screen)->ParentXOffset = position.X - parentOriginX( screen, parent );
	}
	doMoveScreen( screen, position.X, position.Y );

	/* If this screen has any children, move them accordingly */
	for ( node = XSC(screen)->Family.mlh_Head;
	    succ = node->mln_Succ;
	    node = succ )
	{
	    /* One of the screens on the Family list is the
	     * screen itself, and we don't want to act on it.
	     */
	    if ( ( child = SCREENFROMNODE( node ) ) != screen )
	    {
		/* X-coordinate:  if the child is draggable, it doesn't
		 * move in X, so we leave the X-coordinate unchanged.
		 * For non-draggable screens, we maintain a constant
		 * X-position with respect to the parent.
		 * Y-coordinate:  draggable or not, the screen moves
		 * to maintain the constant Y-position with respect to
		 * the parent.  Draggability affects that computation
		 * slightly in parentOffsetY().
		 */
		position.X = child->LeftEdge;
		if ( !TESTFLAG( XSC(child)->PrivateFlags, PSF_DRAGGABLE ) )
		{
		    position.X = XSC(child)->ParentXOffset + parentOriginX( child, screen );
		}
		position.Y = XSC(child)->ParentYOffset + parentOriginY( child, screen );

		/* get the legal positions for the screen,
		 * in screen coords
		 * For compatibility, programmatic screen motion
		 * is unbounded at the bottom.  (Note that interactive screen
		 * dragging is already bounded in startScreenDrag() by the
		 * establishment of mouse limits).
		 * We set SPOS_FORCEDRAG because we always want to drag
		 * (even non-draggable) child screens when the parent moves.
		 */
		screenLegalPosition( child, &legal_positions,
		    flags | SPOS_FORCEDRAG | SPOS_UNBOUNDEDBOTTOM );
		limitPoint( &position, &legal_positions);

		doMoveScreen( child, position.X, position.Y );
	    }
	}
	if ( !TESTFLAG( flags, SPOS_NORETHINK ) )
	{
	    /* And display the result */
	    RethinkDisplay();
	}
	UNLOCKVIEWCPR();
	UNLOCKVIEW();
	UNLOCKIBASE();
    }
    DMS( else printf("don't MOVE!\n") );
}

doMoveScreen( screen, x, y )

struct Screen *screen;
WORD x;
WORD y;

{
    /* rethinkVP will set vp dx/dyoffsets	*/
    XSC(screen)->VPOffsetStash.X = 
	screen->ViewPort.DxOffset = screen->LeftEdge = x;
    XSC(screen)->VPOffsetStash.Y = 
	screen->ViewPort.DyOffset = screen->TopEdge = y;

    newMakeScreen( screen, FALSE );
    screenMouse( screen );
}
/*** intuition.library/ScreenToFront ***/

/* asm stub goes through ScreenDepth() LVO */


/*** intuition.library/ScreenToBack ***/

/* asm stub goes through ScreenDepth() LVO */


/*** intuition.library/ScreenDepth ***/


LIB_ScreenDepth( screen, flags, reserved )
struct Screen *screen;
ULONG flags;
struct Screen *reserved;	/* for future support as a reference
				 * screen if we add SDEPTH_INFRONTOF
				 * and SDEPTH_BEHINDOF flags.
				 */
{
    doISM( itDEPTHSCREEN, screen, NULL, ( flags & SDEPTH_USERMASK ) );
}

/*
 * if screen is NULL, try WB screen
 */
IScreenDepth( screen, whichway )
struct Screen *screen;
{
    struct IntuitionBase *IBase = fetchIBase();
    struct Screen	*findWorkBench();

    D( printf("IScreenDepth %lx, %ld\n", screen, whichway ) );


    LOCKIBASE();

    /* need a screen here: use WB if 'screen' is NULL */
    if ( (screen)  || (screen = findWorkBench() ) )
    {

	/* Peter 11-Mar-91: In order to help IHelp and other "hostile"
	 * screen-movers, we try to ensure we have a real screen here
	 */
	if ( knownScreen( screen ) )
	{
	    CLEARFLAG( IBase->Flags, POPPEDSCREEN );
	    /* Put the screen in the right place */
	    relinkScreen( screen, whichway );
	}
    }

    UNLOCKIBASE();

    RethinkDisplay();
}
/*** intuition.library/GetScreenDrawInfo ***/

struct DrawInfo	*
GetScreenDrawInfo( s )
struct Screen	*s;
{
    return ( &XSC(s)->SDrawInfo );
}

/*** intuition.library/FreeScreenDrawInfo ***/

FreeScreenDrawInfo( s, dri )
struct Screen		*s;
struct DrawInfo	*dri;
{
}


setScreen(s)
struct Screen *s;
/* set this screen as the ActiveScreen 
 */
{
    struct IntuitionBase *IBase = fetchIBase();

    /* set the system global ActiveScreen Pointer */
    if ((IBase->ActiveScreen = s) == NULL) return;

    IBase->MenuRPort = s->RastPort;

    IBase->MenuRPort.TmpRas	= NULL;

    IBase->MenuRPort.AreaPtrn	= NULL;
    IBase->MenuRPort.Layer	= NULL;
    IBase->MenuRPort.AreaInfo	= NULL;
}

/* Common routine to draw a blank screen-bar */
drawScreenBar( rp, s, blockpen )
struct RastPort *rp;
struct Screen *s;
ULONG blockpen;

{
    drawBlock( rp, 0, 0, s->Width - 1, s->BarHeight - 1,
	blockpen );
    drawBlock( rp, 0, s->BarHeight, s->Width - 1, s->BarHeight,
	XSC(s)->SDrawInfo.dri_Pens[ BARTRIMPEN ]);
}

#define SCREEN_TEXT_LEFT	(0)

refreshScreenBar( sc )
struct Screen *sc;
{
    struct Layer *barlayer = sc->BarLayer;

    if ( TESTFLAG( barlayer->Flags, LAYERREFRESH ) )
    {
	BeginUpdate( barlayer );
	screenbar( sc );
	CLEARFLAG( barlayer->Flags, LAYERREFRESH );
	EndUpdate( barlayer, TRUE );
    }
}

/*
 * ZZZ: ISM: try to bring this under the state machine,
 * to eliminate the knownScreen() business (which I've done)
 * otherway: in OpenScreen: I know the screen is "known"
 */
screenbar( s )
register struct Screen *s;
/*    Displays the title bar of the screen argument */
{
    struct IntuiText itext;
    struct Window *w;
    struct RastPort	*rp;
    struct DrawInfo *dri;

    /* respect user's wish for silence */
    if ( (s->Flags & SCREENQUIET)) return;

    /* LockLayerInfo(&s->LayerInfo); */
    /* nobody is going to be deleting this screen,
     * or doing anything else untoward with it.
     * do I need to be protected against damage?
     * I don't think so. (rev 1.5)
     *
     * Oops, I'm wrong.  This is the protection against
     * SetWindowTitles().  Maybe that function should be
     * brought under ISM someday, but I'm going to 
     * let this back in.
     */

    LockLayerInfo(&s->LayerInfo);

    rp = s->BarLayer->rp;
    DSB( printf("barlayer rastport %lx, rp layer %lx bar layer %lx\n",	
	rp, rp->Layer, s->BarLayer ) );

    dri = &XSC(s)->SDrawInfo;
    drawScreenBar( rp, s, dri->dri_Pens[ BARBLOCKPEN ] );

    if (s->Title)
    {
	DSB( printf("new screen title %s\n", s->Title ) );
	itext.FrontPen = dri->dri_Pens[ BARDETAILPEN ];
	itext.BackPen = dri->dri_Pens[ BARBLOCKPEN ];
	itext.DrawMode = JAM2;
	itext.TopEdge = s->BarVBorder;
	itext.LeftEdge = s->BarHBorder;
	itext.ITextFont = NULL;
	itext.IText = s->Title;
	itext.NextText = NULL;
	PrintIText(s->BarLayer->rp, &itext, SCREEN_TEXT_LEFT, 0);
    }

    drawGadgets( s, s->FirstGadget, -1, DRAWGADGETS_ALL );

    UnlockLayerInfo(&s->LayerInfo);
}

/*** intuition.library/ShowTitle ***/

ShowTitle(screen, showit)
struct Screen *screen;
BOOL showit;
{
    DST( printf("ShowTitle: %lx, %ld\n", screen, showit ) );
    doISM( itSHOWTITLE, screen, NULL, showit );
}

IShowTitle(screen, showit)
struct Screen *screen;
BOOL showit;
{
    DST( printf("IShowTitle: %lx, %ld\n", screen, showit ) );
    if ( knownScreen( screen ) )
    {
	/* protect my BorderPatrol */
	LockLayerInfo( &screen->LayerInfo );

	if (showit)
	{
	    screen->Flags |= SHOWTITLE;
	    forceBarCenter(screen);
	    screenbar( screen );
	}
	else
	{
	    screen->Flags &= ~SHOWTITLE;
	    forceBarBack(screen);
	}

	BorderPatrol( screen );		/* synchronous */

	UnlockLayerInfo( &screen->LayerInfo );
    }
}

/*** intuition.library/AllocScreenBuffer ***/

/* The following silly combinations are handled thusly:
 *
 * Non-CUSTOMBITMAP, bm!=NULL				fail
 * CUSTOMBITMAP, SB_SCREEN_BITMAP set			fail
 * SB_SCREEN_BITMAP and SB_COPY_BITMAP set		copy not done
 * Non-CUSTOMBITMAP, bm=original, SB_COPY_BITMAP set
 */

struct ScreenBuffer *AllocScreenBuffer( sc, bm, flags )
struct Screen *sc;
struct BitMap *bm;
{
    struct ScreenBuffer *sb;
    struct DBufInfo *AllocDBufInfo();
    struct BitMap *AllocBitMap();
    void FreeScreenBuffer();
    DDB( printf("AllocScreenBuffer(screen %lx, bitmap %lx, flags %lx)\n",
	sc, bm, flags ) );
    /* We need an extended ScreenBuffer structure */
    if ( sb = (struct ScreenBuffer *)AllocVec( sizeof( struct XScreenBuffer ),
	MEMF_CLEAR ) )
    {
	/* Get a double-buffering handle from graphics */
	if ( sb->sb_DBufInfo = AllocDBufInfo( &sc->ViewPort ) )
	{
	    if ( TESTFLAG( flags, SB_SCREEN_BITMAP ) )
	    {
		/* Caller wants the screen's actual bitmap */
		sb->sb_BitMap = XSC(sc)->RealBitMap;
		DDB( printf("SB_SCREEN_BITMAP:  "));
		/* We would free this BitMap in the event that
		 * FreeScreenBuffer() is called on this buffer and
		 * this isn't the current buffer.
		 */
		XSB(sb)->sb_Flags = SB_FREEBITMAP;
		/* We never copy the screen to itself */
		CLEARFLAG( flags, SB_COPY_BITMAP );
	    }
	    else if ( !bm )
	    {
		/* Caller wants Intuition to create a bitmap.
		 * This screen may be CUSTOMBITMAP or not.
		 */
		sb->sb_BitMap = AllocBitMap( sc->Width, sc->Height,
			sc->RastPort.BitMap->Depth, BMF_DISPLAYABLE|BMF_CLEAR,
			sc->RastPort.BitMap );
		XSB(sb)->sb_Flags = SB_FREEBITMAP;
		DDB( printf("Allocated bitmap:  "));
	    }
	    else if ( TESTFLAG( sc->Flags, CUSTOMBITMAP ) )
	    {
		/* Caller supplied his own bitmap.  This is
		 * only allowed for CUSTOMBITMAP screens.
		 */
		sb->sb_BitMap = bm;
		DDB( printf("Custom bitmap:  "));
	    }
	    /* else we fail, on account of bm!=NULL but a non-CUSTOMBITMAP. */
	}

	/* Failure is (currently) always detectable by the sb_BitMap
	 * pointer being NULL.
	 */
	if ( !sb->sb_BitMap )
	{
	    FreeScreenBuffer( sc, sb );
	    sb = NULL;
	}
	else if ( TESTFLAG( flags, SB_COPY_BITMAP ) )
	{
	    /* Want to start subsequent buffers to match the first.
	     * We do it state-machine synchronous to ensure that
	     * the menu bar isn't up and gadgets aren't active.
	     */
	    doISM( itCOPYSCBUF, sc, sb );
	}

    }
    DDB( printf("ScreenBuffer %lx, sb_BitMap %lx, sb_DBufInfo %lx\n\n",
	sb, sb?sb->sb_BitMap:0, sb?sb->sb_DBufInfo:0 ) );
    return( sb );
}


/* Copy the screen's bitmap into the the new ScreenBuffer's BitMap.
 * We do it in a state-synchronous way to ensure that the menu bar
 * isn't up and gadgets aren't active.
 */
ICopyScreenBuffer( sc, sb )
struct Screen *sc;
struct ScreenBuffer *sb;
{
    /* Start the new ScreenBuffer's BitMap out to match the old */
    BltBitMap( sc->RastPort.BitMap, 0, 0,
	sb->sb_BitMap, 0, 0,
	sc->Width, sc->Height, 0x00C0, ~0, 0 );
}

/*** intuition.library/FreeScreenBuffer ***/


void FreeScreenBuffer( sc, sb )
struct Screen *sc;
struct ScreenBuffer *sb;
{
    DDB( printf("FreeScreenBuffer(%lx, %lx)\n", sc, sb ) );
    if ( sb )
    {
	FreeDBufInfo( sb->sb_DBufInfo );
	/* Free the bitmap if we allocated it here (or during OpenScreen()),
	 * provided it's not the one currently in use.
	 * Don't need to sync up with anything since the ChangeScreenBuffer()
	 * call returns synchronously.
	 */
	if ( ( TESTFLAG( XSB(sb)->sb_Flags, SB_FREEBITMAP ) ) &&
	    ( sb->sb_BitMap != XSC(sc)->RealBitMap ) )
	{
	    DDB( printf(" Freeing BitMap %lx\n", sb->sb_BitMap ) );
	    WaitBlit();
	    FreeBitMap( sb->sb_BitMap );
	}
	FreeVec( sb );
    }
    DDB( printf( "FSB: out\n\n" ) );
}
/*** intuition.library/ChangeScreenBuffer ***/


LONG ChangeScreenBuffer( sc, sb )
struct Screen *sc;
struct ScreenBuffer *sb;
{
    DDB( printf("doISM( itCHANGESCBUF, sc=%lx,sb=%lx )\n", sc, sb ) );
    return( !doISM( itCHANGESCBUF, sc, sb ) );
}


IChangeScreenBuffer( screen, sb )
struct Screen *screen;
struct ScreenBuffer *sb;
{
    DDB( printf( "Calling CVPBitMap(vp=%lx, bm=%lx, dbi=%lx)\n",
	&screen->ViewPort, sb->sb_BitMap, sb->sb_DBufInfo ) );
    ChangeVPBitMap( &screen->ViewPort, sb->sb_BitMap, sb->sb_DBufInfo );
    DDB( printf( "Back from CVPBitMap()\n"));
    /* ChangeVPBitMap() has changed the ViewPort's RasInfo BitMap,
     * but I also have a few things of my own to change.
     * First, update the embedded copy of the screen's BitMap.
     * Second, update the screen's RastPort's BitMap, which
     * is the one everyone should use.
     */
    screen->sc_BitMap = *sb->sb_BitMap;
    screen->RastPort.BitMap = sb->sb_BitMap;

    /* RealBitMap is non-NULL for non-CUSTOMBITMAP screens.  Thus,
     * it's pointing to a BitMap that Intuition got from AllocBitMap(),
     * initially during OpenScreen().  If non-NULL, we may replace it
     * here with the newly-installed bitmap.  We KNOW we allocated
     * that one, since AllocScreenBuffer() doesn't permit user-allocated
     * BitMaps for non-CUSTOMBITMAP screens.
     */
    if ( XSC(screen)->RealBitMap )
    {
	XSC(screen)->RealBitMap = sb->sb_BitMap;
    }

    /* Mike assured me that since these are my layers, it's
     * safe to change their bitmaps.  Ok, Mike...
     */
    XSC(screen)->ClipLayer->rp->BitMap = sb->sb_BitMap;
    screen->BarLayer->rp->BitMap = sb->sb_BitMap;

    DDB( printf("CSB: out\n\n") );
}

/* Calculate the amount the parent is pulled down from its DClip
 * (TopEdge - DClip.MinY) in the resolution of the child screen,
 * and wrt. its DClip.  Think of this as the "origin" of the
 * parent's position, in child resolution coordinates.
 */
LONG
parentOriginY( child, parent )
struct Screen *child;
struct Screen *parent;
{
#if 1
    LONG result;
    result = parent->TopEdge - XSC(parent)->DClip.MinY;

    /* A negative result indicates that the parent is taller than
     * its DClip and pulled up above the DClip top.  We want draggable
     * child screen to stop following up when the parent is dragged
     * off the top.
     */
    if ( TESTFLAG( XSC(child)->PrivateFlags, PSF_DRAGGABLE ) &&
	( result < 0 ) )
    {
	result = 0;
    }

    return( ( result *
	XSC(parent)->ScaleFactor.Y ) / XSC(child)->ScaleFactor.Y +
	XSC(child)->DClip.MinY );

#else
    return( ( ( parent->TopEdge - XSC(parent)->DClip.MinY ) *
	XSC(parent)->ScaleFactor.Y ) / XSC(child)->ScaleFactor.Y +
	XSC(child)->DClip.MinY );
#endif
}

/* Calculate the amount the parent is shifted right from its DClip
 * (LeftEdge - DClip.MinX) in the resolution of the child screen,
 * and wrt. its DClip.  Think of this as the "origin" of the
 * parent's position, in child resolution coordinates.
 */
LONG
parentOriginX( child, parent )
struct Screen *child;
struct Screen *parent;
{
    return( ( ( parent->LeftEdge - XSC(parent)->DClip.MinX ) *
	XSC(parent)->ScaleFactor.X ) / XSC(child)->ScaleFactor.X +
	XSC(child)->DClip.MinX );
}

/* Returns a screen that uniquely identifies this screen's family,
 * namely the parent screen if there is one, else the screen itself.
 */
struct Screen *
screenFamily( s )
struct Screen *s;
{
    if ( XSC(s)->ParentScreen )
    {
	s = XSC(s)->ParentScreen;
    }
    return( s );
}

/* Attach or detach a child screen from a parent.
 * child must be a valid pointer to a screen.
 * If parent is non-NULL, attach this screen to that parent. 
 * (Neither parent nor child may have a parent at the time this
 * function is called).
 *
 * This function does not ensure that the newly attached
 * screens are adjacent depth-wise nor does it ensure that
 * the child's top edge doesn't exceed the parent.  That's
 * handled elsewhere.
 *
 * If parent is NULL, detach. (It's safe to call this with
 * parent=NULL even when the child screen is not attached
 * to any parent.)
 *
 * Please hold the ISTATELOCK when calling...
 *
 * Returns zero for success, OSERR_ATTACHFAIL for failure.
 */
LONG
attachScreen( child, parent )
struct Screen *child;
struct Screen *parent;
{
    LONG error = 0;

    DAT( printf( "attachScreen( child %lx to parent %lx)\n", child, parent ) );
    assertLock( "attachScreen", ISTATELOCK );

    /* parent != NULL implies we're to attempt to attach a screen */
    if ( parent )
    {
	struct MinNode *node, *succ;

	/* Let's check for illegal attachments.  A bit later,
	 * we'll check if the parent-candidate already has a parent
	 * or if the child-candidate already has a parent.
	 * Here, we test to see if the child-candidate already
	 * has children.
	 */
	for ( node = XSC(child)->Family.mlh_Head;
	    succ = node->mln_Succ;
	    node = succ )
	{
	    /* One of the screens on the Family list is the
	     * screen itself, and we don't want to panic
	     * if we see that
	     */
	    if ( SCREENFROMNODE( node ) != child )
	    {
		DAT( printf("aS: Failing because child already has children\n"));
		error = OSERR_ATTACHFAIL;
		break;
	    }
	}

	DAT( printf("aS: c:%lx->ParentScreen = %lx\n", child, XSC(child)->ParentScreen ) );
	DAT( printf("aS: p:%lx->ParentScreen = %lx\n", parent, XSC(parent)->ParentScreen ) );
	if ( ( XSC(parent)->ParentScreen ) ||
	    ( XSC(child)->ParentScreen ) ||
	    TESTFLAG( XSC(parent)->PrivateFlags, PSF_EXCLUSIVE ) !=
	    TESTFLAG( XSC(child)->PrivateFlags, PSF_EXCLUSIVE ) )
	{
	    /* It is illegal to attempt to attach a child which is already
	     * attached to some parent, and it's illegal to attempt
	     * to attach a child to a parent which is itself a child
	     * screen.  Also, if one of the two screens is exclusive,
	     * then fail.  If they're both exclusive, then it's an
	     * exclusive family.
	     */
	    DAT( printf( "aS: Failing because parent or child has parent, or exclusive\n") );
	    error = OSERR_ATTACHFAIL;
	}

	if ( !error )
	{
	    /* Let's set up the family linkages, including indicating
	     * the parent and adding the child to the end of its
	     * parent's list.
	     */
	    XSC(child)->ParentScreen = parent;
	    Remove( &XSC(child)->ChildNode );
	    AddTail( &XSC(parent)->Family, &XSC(child)->ChildNode );

	    /* Let's establish the ParentYOffset */
	    XSC(child)->ParentXOffset = child->LeftEdge -
		parentOriginX( child, parent );
	    XSC(child)->ParentYOffset = child->TopEdge -
		parentOriginY( child, parent );
	    DAT( printf( "aS: attaching.  c:%lx->ParentScreen now %lx\n",
		child,XSC(child)->ParentScreen));
	}
    }
    else
    {
	/* parent == NULL means detach screen if attached */
	if ( XSC(child)->ParentScreen )
	{
	    /* Take the ChildNode off the parent's Family list,
	     * and put it back at the head of its own Family list.
	     */
	    Remove( &XSC(child)->ChildNode );
	    AddHead( &XSC(child)->Family, &XSC(child)->ChildNode );
	    XSC(child)->ParentScreen = NULL;
	    DAT( printf( "aS: detaching\n"));
	}
	/* else was not attached; do nothing */
    }

    return( error );
}

/* Routine to put a screen in the right place in the screen-list.  Here
 * are the rules:
 *
 * For regular screens (neither child nor parent), SDEPTH_TOFRONT puts
 * that screen at the very head of the screen-list, and SDEPTH_TOBACK
 * puts that screen at the very end.
 *
 * Normal depth-arrangement of a child or parent screen sends that
 * screen's whole family to the front or the back of the screen list,
 * without affecting the ordering within the family.  This type
 * of depth-arrangement includes Amiga-M/N, the depth-gadgets, and
 * the ScreenToFront()/ScreenToBack() calls.
 *
 * Special SDEPTH_INFAMILY depth-arrangement moves a family member
 * to the front or rear of their family.  This feature is
 * used at OpenScreen() time to establish the original position.
 * It will also be accessible through new screen-depth functions.
 *
 * NOTE WELL:  This function assumes that screens on the list
 * are well-ordered, i.e. no family is split up.
 */
relinkScreen( screen, flags )
struct Screen *screen;
int flags;
{
    struct IntuitionBase *IBase = fetchIBase();
    struct Screen *parent = XSC(screen)->ParentScreen;
    struct Screen *frontmember;
    struct Screen *backmember;

    /* Is this screen a parent screen?  If so, we want to set
     * the parent-pointer.
     *
     * If this is the initial linking of the parent screen, then
     * we want to link it alone.  By not setting parent, we ensure
     * we don't do something to the whole family.  So we explicitly
     * fail this test in that case.
     *
     * Now the way we tell is unusual, because I can't think of
     * a more straightforward way right now (everywhere else where
     * we care to know about parent screens, we're running a loop
     * of "do something for each child".  Now a screen is either a
     * parent, a child, or unattached:
     *
     * - child screens have a non-NULL XSC(sc)->ParentScreen.
     * - Non-attached screens have only a single node on the Family
     *   list (their own node).  A single node can be detected by
     *   looking for lh_Head == lh_TailPred ( == the single node)
     * - Parent screens always have more than one node (their own plus
     *   at least one child's).
     */
    if ( !TESTFLAG( flags, SDEPTH_INITIAL ) && ( !XSC(screen)->ParentScreen ) && 
	( XSC(screen)->Family.mlh_Head ) != ( XSC(screen)->Family.mlh_TailPred ) )
    {
	parent = screen;
    }

    if ( parent )
    {
	/* Let's save off pointers to the first and last screens
	 * in this screen's family.  We need those to handle
	 * all the de/re-linking issues.
	 */
	frontmember = SCREENFROMNODE( XSC(parent)->Family.mlh_Head );
	backmember = SCREENFROMNODE( XSC(parent)->Family.mlh_TailPred );
    }

    /* We want to move the parent's whole family as a unit under
     * the following conditions:
     *
     * - We are dealing with a real screen family (parent != NULL)
     * - and the caller didn't ask to just move within the family
     *
     * To move the family as a unit, we delink from frontmember to
     * backmember, then relink the whole gang up front or down back.
     */
    if ( ( parent ) && ( !TESTFLAG( flags, SDEPTH_INFAMILY ) ) )
    {
	/* Delink family: */
	((struct Screen *)previousThing( frontmember, 
	    &IBase->FirstScreen, 0 ))->NextScreen = backmember->NextScreen;

	if ( ( flags & SDEPTH_DIRECTIONMASK ) == SDEPTH_TOFRONT )
	{
	    /* Link family at the head */
	    backmember->NextScreen = IBase->FirstScreen;
	    IBase->FirstScreen = frontmember;
	}
	else /* ( ( flags & SDEPTH_DIRECTIONMASK ) == SDEPTH_TOBACK ) */
	{
	    /* Link family to the end */
	    ((struct Screen *)lastThing( &IBase->FirstScreen ))->NextScreen =
		frontmember;
	    backmember->NextScreen = NULL;
	}
    }
    else /* Screen has no parent or children, or screen is a family
	  * member to be moved on its own:
	  */
    {
	/* By default, assume we'll insert at the head of the list */
	struct Screen **scptr = &IBase->FirstScreen;

	/* Let's delink the screen from the screen list, and, if it's
	 * a child screen, remove its ChildNode from the Family list it's on.
	 * Now, if this is the initial linking (SDEPTH_INITIAL), then the
	 * screen is not on the screen list.  However, its ChildNode IS
	 * ALWAYS on some list.
	 */
	if ( !TESTFLAG( flags, SDEPTH_INITIAL ) )
	{
	    delinkScreen( screen );
	}
	if ( parent )
	{
	    Remove( &XSC(screen)->ChildNode );
	}

	if ( ( flags & SDEPTH_DIRECTIONMASK ) == SDEPTH_TOFRONT )
	{
	    if ( parent )
	    {
		/* This is a child screen, so insert it ahead of
		 * the parent's first child, and make this screen
		 * the first child
		 */
		scptr = (struct Screen **)previousThing( 
		    SCREENFROMNODE( XSC(parent)->Family.mlh_Head ), scptr, 0 );
		AddHead( &XSC(parent)->Family, &XSC(screen)->ChildNode );
	    }
	    screen->NextScreen = *scptr;
	    *scptr = screen;
	}
	else /* SDEPTH_TOBACK */
	{
	    struct Screen *tailsc = lastThing( scptr );

	    if ( parent )
	    {
		/* This is a child screen, so insert it after
		 * the parent's last child, and make this screen
		 * the last child
		 */
		tailsc = SCREENFROMNODE( XSC(parent)->Family.mlh_TailPred );
		AddTail( &XSC(parent)->Family, &XSC(screen)->ChildNode );
	    }
	    screen->NextScreen = tailsc->NextScreen;
	    tailsc->NextScreen = screen;
	}
    }
}


/* Remove this screen from the screen list. */
delinkScreen(OScreen)
struct Screen *OScreen;
{
    delinkThing(OScreen, &(fetchIBase())->FirstScreen);
}

/* Returns TRUE if a screen can slide.
 *
 * A screen cannot slide if it does not have the DIPF_IS_DRAGGABLE
 * graphics database property.
 *
 * A screen cannot slide if is made non-draggable through the use
 * of the {SA_Draggable,FALSE} attribute.  This particular decision
 * can be overridden with the override parameter.
 *
 * This override is set when a programmer calls ScreenPosition() with
 * the SPOS_FORCEDRAG option.  The override is also set when Intuition
 * moves a child screen due to the parent moving.
 */
LONG canSlide( s, override )
struct Screen *s;
{
    return( TESTFLAG( XSC(s)->DProperties, DIPF_IS_DRAGGABLE ) &&
	( TESTFLAG( XSC(s)->PrivateFlags, PSF_DRAGGABLE ) || ( override ) ) );
}

BOOL IsHires(s)
struct Screen *s;
{
    return (s->Flags & SCREENHIRES);
}

@


38.31
log
@Added WaitBlit() in FreeScreenBuffer().
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.30 92/12/09 18:15:19 peter Exp Locker: peter $
d715 1
a715 1
	    FreeScreenBuffer( sb );
@


38.30
log
@Finally handles horizontal relationship between non-draggable child
and its parent.  Now support families of exclusive screens.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.29 92/12/04 11:57:53 peter Exp Locker: peter $
d768 1
@


38.29
log
@IsHires() and canSlide() moved here from view.c.  SPOS_MAKEVISIBLE
now uses the coerced DisplayClip, which produces better results.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.28 92/11/25 15:41:37 peter Exp Locker: peter $
d355 2
a356 1
	    XSC(screen)->ParentYOffset = position.Y - pullDown( screen, parent );
d370 8
a377 8
		/* By default, the new X-position is the same as the
		 * old.  screenLegalPosition() knows that non-draggable
		 * children must keep the same left-edge as the parent,
		 * so that's how they'll move from side to side.
		 * Initial guess at the Y-position is independent of
		 * whether the child screen is draggable.
		 * screenLegalPosition() will take care of trimming the
		 * legal position when necessary.
d380 5
a384 1
		position.Y = XSC(child)->ParentYOffset + pullDown( child, screen );
d824 4
a827 2
/* Calculate the amount the parent is pulled down (TopEdge - DClip.MinY)
 * in the resolution of the child screen, and wrt. its DClip.
d830 1
a830 1
pullDown( child, parent )
d838 5
d860 15
d949 1
a949 1
	    TESTFLAG( XSC(parent)->PrivateFlags, PSF_EXCLUSIVE ) ||
d955 3
a957 1
	     * screen.
d974 2
d977 1
a977 1
		pullDown( child, parent );
@


38.28
log
@screenGadgets() now figures out for itself that it's a SCREENQUIET screen.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.27 92/11/20 18:32:31 peter Exp Locker: peter $
d195 1
d197 3
d1129 27
@


38.27
log
@IMoveScreen() now handles SPOS_FORCEDRAG by passing this flag to
canSlide() and screenLegalPosition(), as appropriate.  This replaces
a cruddy method that set a flag temporarily in the screen structure.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.26 92/08/02 12:44:50 peter Exp Locker: peter $
d104 1
a104 1
screenGadgets( s, silent )
d111 1
a111 1
    DSG( printf("screenGadgets s: %lx, silent %lx\n", s, silent ) );
d120 1
a120 1
    if ( silent ) 
@


38.26
log
@Playing with MAKEVISIBLE animation.  (New code is all conditionally
compiled out).
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.25 92/07/17 17:30:23 peter Exp Locker: peter $
d155 1
a155 3
    /* We inform interested parties that this screen movement
     * was initiated directly by a function call into Intuition.
     * As well, we only allow the caller to set those flags
d158 1
a158 2
    doISM( itMOVESCREEN, screen, &rect,
	( flags & SPOS_USERMASK ) | SPOS_FUNCTIONCALL );
d296 1
a296 15
    /* The SPOS_FORCEDRAG flag tells IMoveScreen() to allow
     * {SA_Draggable,FALSE} screens to be dragged.  Here, we
     * temporarily set PSF_DRAGOVERRIDE, which in turn makes
     * CanSlide() (thus screenLegalPosition()) behave as though
     * SA_Draggable was TRUE.  We clear this flag before exiting.
     */
    if ( TESTFLAG( flags, SPOS_FORCEDRAG ) )
    {
	/* Temporarily override {SA_Draggable,FALSE} */
	SETFLAG( XSC(screen)->PrivateFlags, PSF_DRAGOVERRIDE );
    }

    /* Now we need to know if this screen can slide, which
     * will take into account PSF_DRAGOVERRIDE if set above.
     * If we can't slide the screen, then we have no further
d298 2
a299 15
     *
     * Now, if CanSlide() returns TRUE, we know that the screen
     * can slide.  However, there is one case where a screen that
     * can slide must not be allowed to be moved.  That is the case
     * of MoveScreen() or plain ScreenPosition() being called for a
     * non-draggable child screen (recall that child screens are
     * considered sliding even if SA_Draggable is FALSE, since they
     * DO move, but just with their parent).  So, if we're coming from
     * a function call (SPOS_FUNCTIONCALL), and SPOS_FORCEDRAG is
     * not set, then we want to refuse to act here.
     */

    if ( ( !CanSlide( screen ) ) ||
	( ( !TESTFLAG( XSC(screen)->PrivateFlags, PSF_DRAGGABLE ) ) &&
	( flags & ( SPOS_FORCEDRAG|SPOS_FUNCTIONCALL ) ) == SPOS_FUNCTIONCALL ) )
d301 1
a301 4
	DMS( printf("MoveScreen: non-draggable screen!\n") );
	DMS( printf("MoveScreen: non-draggable child, movement refused!\n") );
	/* Need to clear PSF_DRAGOVERRIDE flag */
	CLEARFLAG( XSC(screen)->PrivateFlags, PSF_DRAGOVERRIDE );
d330 1
a330 1
    limitPoint( &position, &legal_positions);
a337 1

d379 1
a379 1
		 * Peter 26-Apr-91: For compatibility, programmatic screen motion
d381 4
a384 2
		 * dragging is bounded in startScreenDrag() by the
		 * establishment of mouse limits)
d387 1
a387 1
		    flags|SPOS_UNBOUNDEDBOTTOM );
a402 2

    CLEARFLAG( XSC(screen)->PrivateFlags, PSF_DRAGOVERRIDE );
@


38.25
log
@SDEPTH_INFAMILY replaces SDEPTH_CHILDONLY and allows "in-family"
arrangement of the parent screen too.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.24 92/07/08 15:26:42 peter Exp Locker: peter $
d30 9
d181 3
d221 34
d256 6
d264 1
@


38.24
log
@Inverted return code of attachScreen().  Added some debugging.  Fixed
bug where I failed to check if a child-candidate already had children.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.23 92/06/23 17:22:01 peter Exp Locker: peter $
a495 2
#if 1

a507 1
#endif
d530 1
a530 1
screenbar(s)
a558 3
    /*  This stuff is disabled since is isn't all done.
	The mono look isn't quite right, and we'll want to tweak the
	screen depth gadget a bit. */
a560 1
#if 1
a561 6
#else
    drawBlock( rp, 0, 0, s->Width - 1, s->BarHeight - 1,
	dri->dri_Pens[ BARBLOCKPEN ]);
    drawBlock( rp, 0, s->BarHeight, s->Width - 1, s->BarHeight,
	dri->dri_Pens[ BARTRIMPEN ]);
#endif
d606 1
a606 1
	    screenbar(screen);
d719 1
d766 2
a767 2
    /* ChangeVPBitMap() changed the ViewPort's RasInfo BitMap,
     * and now I have a few things of my own to change.
d792 1
d890 1
a890 1
		error = 1;
d908 1
a908 1
	    error = 1;
d960 2
a961 2
 * Special SDEPTH_CHILDONLY depth-arrangement of children moves the
 * children to the front or rear of their family.  This feature is
d977 2
a978 3
    /* Is this screen a parent screen?  If so, we want to move the
     * whole family, so set the parent-pointer and clear the 
     * SDEPTH_CHILDONLY flag.
d981 3
a983 2
     * we want to link it alone.  So we deliberately fail this
     * test in that case.
d990 1
a1001 1
	flags &= ~SDEPTH_CHILDONLY;
d1016 1
d1018 4
a1021 3
     * - and the caller didn't ask to just move the child
     * To move the family, we delink from frontmember to backmember,
     * then relink the whole gang up front or down back.
d1023 1
a1023 1
    if ( ( parent ) && ( !TESTFLAG( flags, SDEPTH_CHILDONLY ) ) )
d1043 3
a1045 1
    else /* Screen has no parent or children, or screen is child to move on its own */
@


38.23
log
@Downcoded MoveScreen().
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.22 92/06/03 17:36:39 peter Exp Locker: peter $
d29 1
a29 1

d866 2
d874 1
a874 1
    LONG success = TRUE;
d876 1
d879 1
d882 30
a911 2
	/* parent != NULL implies we're to attempt to attach a screen */
	if ( ( XSC(parent)->ParentScreen ) || ( XSC(child)->ParentScreen ) )
d918 2
a919 1
	    success = FALSE;
d921 2
a922 1
	else
d935 2
d950 1
d955 1
a955 1
    return( success );
@


38.22
log
@Now lock VIEWCPR lock.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.21 92/05/21 17:45:21 peter Exp Locker: peter $
d130 1
a131 6
MoveScreen(screen, dx, dy)
struct Screen *screen;
int dx, dy;
{
    ScreenPosition( screen, 0, dx, dy, 0, 0 );
}
a214 1

a219 1
    BOOL moved = FALSE;
a311 2
    moved =  (position.Y - screen->TopEdge) || (position.X - screen->LeftEdge);

a312 1
    DMS( if (!moved) printf("don't MOVE!\n") );
d314 1
a314 1
    if (moved)
d381 1
a383 2
    /* return test value -- did we hit limits...? if so : moved == FALSE */
    return(moved);
@


38.21
log
@Now passes DRAWGADGETS_ALL to drawGadgets().  ScreenToFront() and
ScreenToBack() now reach ScreenDepth() from their stub.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.20 92/05/01 13:54:44 peter Exp Locker: peter $
d329 1
a329 1
	/* Need the VIEWLOCK (really the GfxBase->ActiViewCprSemaphore)
d336 1
d387 1
@


38.20
log
@Fixed oversize canvas autoscroll screens.
Took out 2nd BorderPatrol() parameter.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.19 92/04/01 15:08:22 peter Exp Locker: peter $
d328 9
d386 2
d413 7
a419 4
ScreenToFront(screen)
{
    ScreenDepth( screen, SDEPTH_TOFRONT, NULL );
}
a467 7
/*** intuition.library/ScreenToBack ***/

ScreenToBack(screen)
{
    ScreenDepth( screen, SDEPTH_TOBACK, NULL );
}

d599 1
a599 1
    drawGadgets(s, s->FirstGadget, -1);
@


38.19
log
@Evicted autodocs.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.18 92/03/26 18:42:26 peter Exp Locker: peter $
d410 1
a410 1
ScreenDepth( screen, flags, reserved )
d516 14
d629 1
a629 1
	BorderPatrol( screen, NULL );		/* syncronous */
d817 15
d835 1
@


38.18
log
@Added IPreMoveScreen() to handle SPOS_MAKEVISIBLE.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.17 92/03/26 16:40:12 peter Exp Locker: peter $
d129 1
a130 45
/****** intuition.library/MoveScreen **************************************
*
*    NAME
*	MoveScreen -- Attempt to move the screen by the increments provided.
*
*    SYNOPSIS
*	MoveScreen( Screen, DeltaX, DeltaY )
*		    A0      D0      D1
*
*	VOID MoveScreen( struct Screen *, WORD, WORD );
*
*    FUNCTION
*	Moves the screen the specified increment, specified in screen
*	pixel resolution coordinates.
*
*	New for V36: Screen movement limits have been greatly relaxed,
*	to support screen scrolling.  In particular, negative values
*	for screen LeftEdge and TopEdge may now be valid.
*
*       If the DeltaX and DeltaY variables you specify would move the screen
*       in a way that violates any restrictions, the screen will be moved
*       as far as possible.  You may examine the LeftEdge and TopEdge fields
*	of the Screen structure after this function returns to see where
*	the screen really ended up.
*
*	In operation, this function determines what the resulting position
*	values that are actually to be used, sets these up, and calls 
*	MakeScreen() and RethinkDisplay().
*
*    INPUTS
*	Screen = pointer to a Screen structure
*	DeltaX = amount to move the screen on the x-axis
*		Note that DeltaX no longer (V36) need be set to zero
*	DeltaY = amount to move the screen on the y-axis
*		Note that these coordinates are in the same resolution
*		as the screen (such as HIRES or INTERLACE)
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	ScreenPosition(), RethinkDisplay()
*****************************************************************************/
d137 1
a138 77
/****** intuition.library/ScreenPosition **********************************
*
*    NAME
*	ScreenPosition -- Move screens with greater control. (V39)
*
*    SYNOPSIS
*	ScreenPosition( Screen, flags, x1, y1, x2, y2 )
*	                A0      D0     D1  D2  D3  D4
*
*	VOID ScreenPosition( struct Screen *, ULONG, LONG, LONG, LONG, LONG );
*
*    FUNCTION
*	Moves the screen to the specified position or by the specified
*	increment, in screen pixel resolution coordinates.
*
*	New for V36: Screen movement limits have been greatly relaxed,
*	to support screen scrolling.  In particular, negative values
*	for screen LeftEdge and TopEdge may now be valid.
*
*	If the x1 and y1 variables you specify would move the screen in
*	a way that violates any restrictions, the screen will be moved
*	as far as possible.  You may examine the LeftEdge and TopEdge
*	fields of the Screen structure after this function returns to
*	see where the screen really ended up.
*
*	In operation, this function determines what the resulting position
*	values that are actually to be used, sets these up, and calls 
*	MakeScreen() and RethinkDisplay().
*
*    INPUTS
*	Screen = pointer to a Screen structure
*	flags = Set to one of zero, SPOS_ABSOLUTE, or SPOS_MAKEVISIBLE.
*		You may additionally set SPOS_FORCEDRAG if you need.
*		Leave zero for normal use (move screen a relative amount
*		expressed by x1,y1).  Set the SPOS_ABSOLUTE flag if you
*		wish x1 and y1 to be absolute coordinates to move the
*		screen to.  Set SPOS_MAKEVISIBLE to position an oversized
*		scrolling screen so that the rectangle described by
*		(x1,y1)-(x2,y2) is on the visible part of the display.
*		(a word-processor may wish to support autoscrolling
*		as the user types.  In that case, it could call
*		ScreenPosition() with the SPOS_MAKEVISIBLE flag and
*		a rectangle that encompasses the cursor with some space
*		around it.
*		In addition to any one of the above choices, you can
*		additionally set SPOS_FORCEDRAG if you wish to reposition
*		a screen that was opened with the {SA_Draggable,FALSE}
*		attribute.
*
*	x1,y1 = Absolute position or change in position you wish to apply
*		to the screen, when using SPOS_ABSOLUTE or SPOS_RELATIVE.
*		When using SPOS_MAKEVISIBLE, these variables describe
*		the upper-left corner of the rectangle you would like to
*		ensure is on the visible part of a scrolling screen.
*	x2,y2 = Ignored when using SPOS_ABSOLUTE or SPOS_RELATIVE.
*		When using SPOS_MAKEVISIBLE, these variables describe
*		the lower-right corner of the rectangle you would like to
*		ensure is on the visible part of a scrolling screen.
*
*		Note that these coordinates are in the same resolution
*		as the screen (such as HIRES or INTERLACE)
*
*    RESULT
*	None
*
*    NOTES
*	ONLY the owner of the screen should use SPOS_FORCEDRAG.
*	It is incorrect style (and against the intentions of the
*	screen opener) for programs such as commodities or
*	mouse-helpers to move non-draggable screens.
*
*
*    BUGS
*
*    SEE ALSO
*	MoveScreen(), RethinkDisplay()
*****************************************************************************/
d400 1
a401 25
/****** intuition.library/ScreenToFront *************************************
*
*    NAME
*	ScreenToFront -- Make the specified screen the frontmost.
*
*    SYNOPSIS
*	ScreenToFront( Screen )
*		       A0
*
*	VOID ScreenToFront( struct Screen * );
*
*    FUNCTION
*	Brings the specified Screen to the front of the display.
*
*    INPUTS
*	Screen = a pointer to a Screen structure
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	ScreenDepth(), ScreenToBack()
*****************************************************************************/
d407 1
a408 42
/****** intuition.library/ScreenDepth ***************************************
*
*    NAME
*	ScreenDepth -- Depth arrange a screen with extra control. (V39)
*
*    SYNOPSIS
*	ScreenDepth( screen, flags, reserved )
*	             A0      D0     A1
*
*	VOID ScreenDepth( struct Screen *, ULONG, APTR );
*
*    FUNCTION
*	Brings the specified screen to the front or back, based on
*	the supplied flags.  Also allows control of screen
*	depth-arranging within screen families.
*
*    INPUTS
*	screen = a pointer to the screen to move
*	flags = one of SDEPTH_TOFRONT or SDEPTH_TOBACK (bringing the
*	    screen to front or back respectively).  If the screen
*	    is a child screen, then also specify SDEPTH_CHILDONLY
*	    to move the child within the screen group.  If the
*	    screen is a child screen and SDEPTH_CHILDONLY is not
*	    specified, then the whole family will move, which is
*	    also the behavior from the user-interface.
*
*    RESULT
*	None
*
*    NOTES
*	ONLY the owner of the screen should use SDEPTH_CHILDONLY.
*	It is incorrect style (and against the intentions of the
*	screen opener) for programs such as commodities or
*	mouse-helpers to move child screens around in their family.
*
*    BUGS
*
*    SEE ALSO
*	ScreenToFront(), ScreenToBack(),
*	SA_Parent, SA_FrontChild, SA_BackChild
*
*****************************************************************************/
d454 1
a455 25
/****** intuition.library/ScreenToBack ************************************
*
*    NAME
*	ScreenToBack -- Send the specified screen to the back of the display.
*
*    SYNOPSIS
*	ScreenToBack( Screen )
*		      A0
*
*	VOID ScreenToBack( struct Screen * );
*
*    FUNCTION
*	Sends the specified screen to the back of the display.
*
*    INPUTS
*	Screen = pointer to a Screen structure
*
*    RESULT
*	None
*
*    BUGS
*
*    SEE ALSO
*	ScreenDepth(), ScreenToFront()
*****************************************************************************/
d461 1
a462 57
/****** intuition.library/GetScreenDrawInfo ********************************
*
*   NAME	
*	GetScreenDrawInfo -- Get pointer to rendering information. (V36)
*
*   SYNOPSIS
*	DrInfo = GetScreenDrawInfo( Screen )
*	D0	  		    A0
*	
*	struct DrawInfo *GetScreenDrawInfo( struct Screen * );
*
*   FUNCTION
*	Returns a pointer to a DrawInfo structure derived from the
*	screen passed.  This data structure is READ ONLY.  The field
*	dri_Version identifies which version of struct DrawInfo you
*	are given a pointer to.
*
*   INPUTS
* 	Screen        - pointer to a valid, open screen.
*
*   RESULT
* 	DrInfo - pointer to a system-allocated DrawInfo structure,
*	as defined in intuition/screens.h.
*
*   NOTES
*	Some information in the DrawInfo structure may in the future
*	be calculated the first time this function is called for a
*	particular screen.
*
*	You must call FreeScreenDrawInfo() when you are done using the
*	returned pointer.
*
*	This function does not prevent a screen from closing.  Apply it
*	only to the screens you opened yourself, or apply a protocol
*	such as LockPubScreen().
*
*	WARNING: Until further notice, the pointer returned does not
*	remain valid after the screen is closed.
*
*	This function and FreeScreenDrawInfo() don't really do much now,
*	but they provide an upward compatibility path.  That means that
*	if you misuse them today, they probably won't cause a problem,
*	although they may someday later.  So, please be very careful
*	only to use the DrawInfo structure between calls to
*	GetScreenDrawInfo() and FreeScreenDrawInfo(), and be sure
*	that you don't forget FreeScreenDrawInfo().
*
*   BUGS
*	Does not reflect to changes in screen modes, depth, or pens.
*
*   SEE ALSO
*	FreeScreenDrawInfo(), LockPubScreen(), intuition/screens.h
*
******************************************************************************
*
*/

d470 2
a471 39
/****** intuition.library/FreeScreenDrawInfo ***************************
*
*   NAME	
* 	FreeScreenDrawInfo -- Finish using a DrawInfo structure. (V36)
*
*   SYNOPSIS
*	FreeScreenDrawInfo( Screen, DrInfo )
*			    A0      A1
*	
*	VOID FreeScreenDrawInfo( struct Screen *, struct DrawInfo * );
*
*   FUNCTION
*	Declares that you are finished with the DrawInfo structure
*	returned by GetScreenDrawInfo().
*
*   INPUTS
* 	Screen	      - pointer to screen passed to GetScreenDrawInfo()
*	DrInfo      - pointer to DrawInfo returned by GetScreenDrawInfo()
*
*   RESULT
* 	None
*
*   NOTES
*	This function, and GetScreenDrawInfo(), don't really do much, but
*	they provide an upward compatibility path.  That means that
*	if you misuse them today, they probably won't cause a problem,
*	although they may someday later.  So, please be very careful
*	only to use the DrawInfo structure between calls to
*	GetScreenDrawInfo() and FreeScreenDrawInfo(), and be sure
*	that you don't forget FreeScreenDrawInfo().
*
*   BUGS
*
*   SEE ALSO
*	GetScreenDrawInfo()
*
******************************************************************************
*
*/
d583 1
a584 42
/****** intuition.library/ShowTitle *****************************************
*
*    NAME
*	ShowTitle -- Set the screen title bar display mode.
*
*    SYNOPSIS
*	ShowTitle( Screen, ShowIt )
*		   A0      D0
*
*	VOID ShowTitle( struct Screen *, BOOL );
*
*    FUNCTION
*	This routine sets the SHOWTITLE flag of the specified screen, and
*	then coordinates the redisplay of the screen and its windows.
*	
*	The screen title bar can appear either in front of or behind
*	WFLG_BACKDROP windows.  This is contrasted with the fact that
*	non-WFLG_BACKDROP windows always appear in front of the screen title
*	bar.  You specify whether you want the screen title bar to be in front
*	of or behind the screen's WFLG_BACKDROP windows by calling this
*	routine.
*
*	The ShowIt argument should be set to either TRUE or FALSE.  If TRUE,
*       the screen's title bar will be shown in front of WFLG_BACKDROP windows.
*       If FALSE, the title bar will be rendered behind all windows.
*
*       When a screen is first opened, the default setting of the SHOWTITLE
*       flag is TRUE.
*
*    INPUTS
*       Screen = pointer to a Screen structure
*       ShowIt = Boolean TRUE or FALSE describing whether to show or hide the
*           screen title bar
*
*    RESULT
*       None
*
*    BUGS
*
*    SEE ALSO
*
*****************************************************************************/
d621 1
a622 60
/****** intuition.library/AllocScreenBuffer *********************************
*
*    NAME
*	AllocScreenBuffer -- Get a ScreenBuffer for double-buffering. (V39)
*
*    SYNOPSIS
*	sbuffer = AllocScreenBuffer( Screen, BitMap, flags )
*	D0                           A0      A1      D0
*
*	struct ScreenBuffer *AllocScreenBuffer( struct Screen *,
*	    struct BitMap *, ULONG );
*
*    FUNCTION
*	Allocates a ScreenBuffer structure and usually a BitMap.  This
*	structure can be used for double (or multiple) buffering in
*	Intuition screens.  You may use this call to obtain a ScreenBuffer
*	structure for the screen's initial BitMap, or for other BitMaps
*	you intend to swap in.
*
*	The ScreenBuffer structure contains a pointer to a graphics.library
*	DBufInfo structure this call allocates for you.  The DBufInfo
*	structure is free for your use.  See graphics.library/AllocDBufInfo()
*	for full details.
*
*    INPUTS
*	Screen = pointer to the screen to double-buffer
*	BitMap = For CUSTOMBITMAP screens, you may pre-allocate
*		a bitmap matching the screen's BitMap's properties, and
*		pass that in, to get a ScreenBuffer referring to that
*		BitMap.  Set this parameter to NULL if you'd prefer
*		that Intuition allocate the alternate buffer.  This parameter
*		must be NULL for non-CUSTOMBITMAP screens.
*	Flags = Set a combination of these flags:
*	    For non-CUSTOMBITMAP screens, set SB_SCREEN_BITMAP in order to
*		get a ScreenBuffer referring to the screen's initial BitMap.
*		(For CUSTOMBITMAP screens, just set the BitMap parameter
*		to the BitMap you passed to OpenScreen()).
*	    Set SB_COPY_BITMAP if you would like the screen's BitMap
*		copied into this ScreenBuffer's BitMap.  This is required
*		to get any menu-bar or gadget imagery into each
*		ScreenBuffer's BitMap.  If the screen has no Intuition
*		rendering, you may omit this flag.  Also, when allocating
*		a ScreenBuffer for the screen's initial BitMap, this flag
*		should not be set.
*
*    RESULT
*	Pointer to a valid ScreenBuffer structure, or NULL if failure.
*	You may render into the resulting BitMap as appropriate.
*	You may use the sb_DBufInfo field to access graphics.library
*	ViewPort-buffering features such as learning when it is safe
*	to reuse the previous bitmap.  If not, you risk writing into
*	the on-screen BitMap, which can damage menu or gadget rendering!
*
*    BUGS
*
*    SEE ALSO
*	FreeScreenBuffer(), ChangeScreenBuffer(),
*	graphics.library/AllocDBufInfo(), graphics.library/ChangeVPBitMap()
*
*****************************************************************************/
d720 1
a721 32
/****** intuition.library/FreeScreenBuffer **********************************
*
*    NAME
*	FreeScreenBuffer -- Free a ScreenBuffer structure. (V39)
*
*    SYNOPSIS
*	FreeScreenBuffer( Screen, ScreenBuffer )
*	                  A0      A1
*
*	VOID FreeScreenBuffer( struct Screen *, struct ScreenBuffer * );
*
*    FUNCTION
*	Frees a ScreenBuffer structure you got from AllocScreenBuffer(),
*	and releases associated resources.  You must call FreeScreenBuffer()
*	before you close your screen.
*
*    INPUTS
*	Screen: pointer to the screen this ScreenBuffer is associated with.
*	ScreenBuffer: pointer to a ScreenBuffer structure obtained from
*	    AllocScreenBuffer().  It is safe to call this function with
*	    a NULL argument.  It will have no effect.
*
*    RESULT
*	None.
*
*    BUGS
*
*    SEE ALSO
*	AllocScreenBuffer(), ChangeScreenBuffer(),
*	graphics.library/ChangeVPBitMap()
*
*****************************************************************************/
d746 1
a747 45
/****** intuition.library/ChangeScreenBuffer *********************************
*
*    NAME
*	ChangeScreenBuffer -- Swap the screen's BitMap. (V39)
*
*    SYNOPSIS
*	success = ChangeScreenBuffer( Screen, ScreenBuffer )
*	D0                            A0      A1
*
*	ULONG ChangeScreenBuffer( struct Screen *, struct ScreenBuffer * );
*
*    FUNCTION
*	Performs double (or multiple) buffering on an Intuition screen
*	in an Intuition-cooperative manner.  The BitMap associated
*	with the supplied ScreenBuffer will be installed in the
*	specified screen, if possible.  The previously-installed BitMap
*	is available for re-use upon receiving a signal from
*	graphics.library.  See the graphics.library autodocs for
*	graphics.library/AllocDBufInfo() and graphics.library/ChangeVPBitMap()
*	for details.
*
*    INPUTS
*	Screen: pointer to the screen whose bitmap is to be swapped.
*	ScreenBuffer: pointer to a ScreenBuffer structure obtained from
*	    AllocScreenBuffer().
*
*    RESULT
*	Returns non-zero if the operation succeeded.  Returns zero
*	if the operation cannot be performed.  This function will
*	fail if Intuition's state cannot permit it, for example the
*	user is playing with menus or gadgets.
*
*    NOTES
*	It is not required to restore the original ScreenBuffer
*	before closing the screen. Simply FreeScreenBuffer() each
*	buffer (including the original and the currently-installed one)
*	then close the screen.	
*
*    BUGS
*
*    SEE ALSO
*	AllocScreenBuffer(), FreeScreenBuffer(),
*	graphics.library/ChangeVPBitMap()
*
*****************************************************************************/
@


38.17
log
@Added two new SPOS_ flags.  Changed ScreenPosition() arguments.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.16 92/03/24 11:57:29 peter Exp Locker: peter $
d28 1
d264 1
a264 1
    struct Point	delta;
d266 5
a270 2
    delta.X = x1;
    delta.Y = y1;
d276 1
a276 1
    doISM( itMOVESCREEN, screen, &delta,
d279 3
a281 1
    /* synchronous, so this is OK.  Wouldn't work for sendISM() */
d285 55
d341 1
a341 1
IMoveScreen(screen, delta, flags )
d368 1
a368 2
    if ( ! ( ( knownScreen( screen ) ) &&
	( dx || dy || (TESTFLAG( flags, SPOS_ABSOLUTE|SPOS_REVALIDATE ) ) ) ) )
@


38.16
log
@Now pass NULL for new second parameter to BorderPatrol().
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.15 92/03/23 11:54:49 peter Exp Locker: peter $
d178 1
a178 1
    ScreenPosition( screen, dx, dy, 0 );
d187 2
a188 2
*	ScreenPosition( Screen, ScreenX, ScreenY, flags )
*	                A0      D0       D1       D2
d190 1
a190 1
*	VOID ScreenPosition( struct Screen *, WORD, WORD, ULONG );
d200 5
a204 5
*	If the ScreenX and ScreenY variables you specify would move the
*	screen in a way that violates any restrictions, the screen will
*	be moved as far as possible.  You may examine the LeftEdge and
*	TopEdge fields of the Screen structure after this function returns
*	to see where the screen really ended up.
d212 28
a239 4
*	ScreenX = position or change in position along the x-axis
*		you wish to apply to the screen
*	ScreenY = position or change in position along the y-axis
*		you wish to apply to the screen
a241 6
*	flags = Set to zero for normal use.  Set the SPOS_ABSOLUTE
*		flag if you wish ScreenX and ScreenY to be absolute
*		coordinates instead of an offset from the current
*		screen position.  Set SPOS_FORCEDRAG if you wish
*		to reposition a screen that was opened with the
*		{SA_Draggable,FALSE} attribute.
d258 1
a258 1
ScreenPosition(screen, dx, dy, flags)
d260 2
a261 1
int dx, dy;
d265 2
a266 2
    delta.X = dx;
    delta.Y = dy;
@


38.15
log
@Put in logic allow dragging a non-draggable screen, and to allow/disallow
dragging of non-draggable children.  Renamed IsDraggable() to CanSlide().
Added ScreenPosition() call.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.14 92/03/21 14:53:24 peter Exp Locker: peter $
d879 1
a879 1
	BorderPatrol( screen );		/* syncronous */
@


38.14
log
@Major simplification/change in attached screens.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.13 92/03/19 15:53:55 peter Exp Locker: peter $
d172 1
a172 1
*	RethinkDisplay()
d178 66
d248 8
a255 1
    doISM( itMOVESCREEN, screen, &delta );
d259 2
d263 1
a263 1
struct Point	*delta;
d277 1
d281 7
a287 1
    /* let's not waste each other's time	*/
d289 1
a289 1
	( dx || dy || (TESTFLAG( flags, SMOVE_REVALIDATE ) ) ) ) )
d294 31
a324 2
    /* Some screens are non-draggable by request or by database */
    if ( ! IsDraggable( screen ) )
d327 3
d340 1
a340 1
    screenLegalPosition( screen, &legal_positions, flags|SMOVE_UNBOUNDEDBOTTOM );
d342 3
a344 1
    /* get (proposed) new position in screen coordinates	*/
d347 7
d387 6
a392 2
		/* Initial guess at the Y-position is independent of
		 * whether the child screen can be independently dragged.
d396 2
a397 14
		position.Y = XSC(child)->ParentYOffset +
		    pullDown( child, screen );
		if ( !TESTFLAG( XSC(child)->PrivateFlags, PSF_DRAGGABLE ) )
		{
		    /* This screen doesn't drag independently */
		    position.X = 
			( ( screen->LeftEdge - XSC(screen)->DClip.MinX ) *
			XSC(screen)->ScaleFactor.X ) / XSC(child)->ScaleFactor.X +
			XSC(child)->DClip.MinX;
		}
		else
		{
		    position.X = child->LeftEdge;
		}
d407 1
a407 1
		    flags|SMOVE_UNBOUNDEDBOTTOM );
d413 5
a417 2
	/* And display the result */
	RethinkDisplay();
d420 1
d465 1
a465 1
*	ScreenToBack()
d584 1
a584 1
*	ScreenToFront()
d1268 1
a1268 1
	    /* Let's update the ParentYOffset */
a1416 1
#if 111
a1418 1
#endif
a1432 1
#if 111
a1434 3
#else
	    scptr = &tailsc->NextScreen;
#endif
a1435 4
#if 000
	screen->NextScreen = *scptr;
	*scptr = screen;
#endif
@


38.13
log
@attachScreen() now doISM()'s the new itATTACHSCREEN token.  All
the magic happens inside the IAttachScreen() function.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.12 92/03/18 11:51:04 peter Exp Locker: peter $
d195 2
a248 4
	    LONG pulldown = pullDown( screen, parent );
	    /* Don't let the screen move higher than its parent */
	    position.Y = imax( position.Y, pulldown );

d250 1
a250 1
	    XSC(screen)->ParentYOffset = position.Y - pulldown;
a251 1

d254 4
d259 4
a262 6
	    /* Let's move all the screen's children */
	    struct MinNode *node, *succ;
	    struct Screen *child;

	    for ( node = XSC(screen)->Children.mlh_Head; succ = node->mln_Succ;
		node = succ )
d264 2
a265 3
		child = SCREENFROMNODE( node );
		/* Initial guess at the Y-position is independent of whether
		 * the child screen can be independently dragged.
d270 1
a270 1
		    pullDown( child, screen ); 
d273 1
a273 1
		    /* This screen doesn't drag independently */	
a305 1

d350 56
a405 1
    doISM( itDEPTHSCREEN, screen, NULL, SDEPTH_TOFRONT );
a441 252
/* Calculate the amount the parent is pulled down (TopEdge - DClip.MinY)
 * in the resolution of the child screen, and wrt. its DClip.
 */
LONG
pullDown( child, parent )
struct Screen *child;
struct Screen *parent;
{
    return( ( ( parent->TopEdge - XSC(parent)->DClip.MinY ) *
	XSC(parent)->ScaleFactor.Y ) / XSC(child)->ScaleFactor.Y +
	XSC(child)->DClip.MinY );
}

/* Returns a screen that uniquely identifies this screen's family,
 * namely the parent screen if there is one, else the screen itself.
 */
struct Screen *
screenFamily( s )
struct Screen *s;
{
    if ( XSC(s)->ParentScreen )
    {
	s = XSC(s)->ParentScreen;
    }
    return( s );
}

/* Attach or detach a child screen from a parent.  If parent is non-NULL,
 * attach this screen to that parent.  If parent is NULL, detach.
 * It's safe to call this with parent=NULL when the screen is not
 * attached to any parent.
 */
attachScreen( child, parent, dolink )
struct Screen *child;
struct Screen *parent;
BOOL dolink;
{
    doISM( itATTACHSCREEN, child, parent, dolink );
}

/* Attach or detach a child screen from a parent.  If parent is non-NULL,
 * attach this screen to that parent.  If parent is NULL, detach.
 * It's safe to call this with parent=NULL when the screen is not
 * attached to any parent.
 * Note that IAttachScreen() may need to move the child.
 * The token-behavior of itATTACHSCREEN therefore must
 * correspond to the behavior of itMOVESCREEN.  In particular,
 * in states where itMOVESCREEN is deferred or discarded,
 * itATTACHSCREEN must be deferred.
 */
IAttachScreen( child, parent, dolink )
struct Screen *child;
struct Screen *parent;
BOOL dolink;
{
#if 0
    LONG success = TRUE;
#endif
    LONG need_rethink = FALSE;

    LOCKIBASE();

    if ( parent )
    {
	/* Attach screen if not already attached */
	if ( XSC(child)->ParentScreen )
	{
	    /* Whoops!  This screen is already attached! */
#if 0
	    success = FALSE;
#endif
	}
	else
	{
	    if ( dolink )
	    {
		/* relinkScreen() assumes that families are well-formed,
		 * but that need not be true when an already-open child
		 * screen is attached to a parent.  Thus, we'll de-link
		 * and do an "initial"-style relink.
		 */
		delinkScreen( child, TRUE );
	    }

	    /* Now that the child screen is out of the list, we can
	     * add it to the parent's list.
	     */
	    XSC(child)->ParentScreen = parent;
	    /* Attach this child to its parent */
	    AddTail( &XSC(parent)->Children, &XSC(child)->ChildNode );

	    if ( dolink )
	    {
		/* Let's reconnect the child in a comparable place to where
		 * it was.  ZZZ: We're too lazy, so we'll just stick it in
		 * front for now, and get smarter later.
		 */
		relinkScreen( child,
		    SDEPTH_TOFRONT | SDEPTH_INITIAL | SDEPTH_CHILDONLY );
		need_rethink = TRUE;
	    }
	    /* Let's update the ParentYOffset */
	    XSC(child)->ParentYOffset = child->TopEdge -
		pullDown( child, parent );
	}
    }
    else
    {
	/* Detach screen, if attached */
	if ( XSC(child)->ParentScreen )
	{
	    delinkScreen( child, FALSE );
	    Remove( &XSC(child)->ChildNode );
	    XSC(child)->ParentScreen = NULL;
	}
	/* else was not attached; do nothing */
    }
    /* ZZZ: Need to rethink FrontMember, BackMember, PullDown */

    /* If we just attached this screen, we may need to move it wrt
     * the parent.  If there are interposing screens, we should
     * become the frontmost if we're in front, else the backmost.
     * If there are no interposing screens, then we should stay
     * where we happened to be.
     * Once the depth is figured, FrontMember and BackMember
     * can follow.
     */

    /* If we just attached this screen, then we may have to move
     * it to a suitable position, which is to say screen->Top
     * plus pullDown(parent,screen,??)
     */
    UNLOCKIBASE();

    if ( need_rethink )
    {
	RethinkDisplay();
    }

#if 0
    return( success );
#endif
}

/* Routine to put a screen in the right place in the screen-list.  Here
 * are the rules:
 *
 * For regular screens (neither child nor parent), SDEPTH_TOFRONT puts
 * that screen at the very head of the screen-list, and SDEPTH_TOBACK
 * puts that screen at the very end.
 *
 * Normal depth-arrangement of a child or parent screen sends that
 * screen's whole family to the front or the back of the screen list,
 * without affecting the ordering within the family.  This type
 * of depth-arrangement includes Amiga-M/N, the depth-gadgets, and
 * the ScreenToFront()/ScreenToBack() calls.
 *
 * Special SDEPTH_CHILDONLY depth-arrangement of children moves the
 * children to the front or rear of their family.  This feature is
 * used at OpenScreen() time to establish the original position.
 * It will also be accessible through new screen-depth functions.
 *
 * NOTE WELL:  This function assumes that screens on the list
 * are well-ordered, i.e. no family is split up.
 */
relinkScreen( screen, whichway )
struct Screen *screen;
int whichway;
{
    struct IntuitionBase *IBase = fetchIBase();
    struct Screen *parent = XSC(screen)->ParentScreen;

    /* Is this screen a parent screen?  (We can tell by checking
     * if it has any children).  If so, we want to move the
     * whole family, so set the parent-pointer and clear
     * the SDEPTH_CHILDONLY flag.
     */
    if ( XSC(screen)->Children.mlh_Head->mln_Succ )
    {
	parent = screen;
	whichway &= ~SDEPTH_CHILDONLY;
    }

    /* Now, 'parent' is non-NULL if 'screen' was a child or parent.
     * Unless SDEPTH_CHILDONLY is set, we want to move the family.
     */
    if ( ( parent ) && ( !TESTFLAG( whichway, SDEPTH_CHILDONLY ) ) )
    {
	/* Delink family: */
	((struct Screen *)previousThing( XSC(parent)->FrontMember,
	    &IBase->FirstScreen, 0 ))->NextScreen = XSC(parent)->BackMember->NextScreen;

	if ( ( whichway & SDEPTH_DIRECTIONMASK ) == SDEPTH_TOFRONT )
	{
	    /* Link family at the head */
	    XSC(parent)->BackMember->NextScreen = IBase->FirstScreen;
	    IBase->FirstScreen = XSC(parent)->FrontMember;
	}
	else /* ( ( whichway & SDEPTH_DIRECIONMASK ) == SDEPTH_TOBACK ) */
	{
	    /* Link family to the end */
	    ((struct Screen *)lastThing( &IBase->FirstScreen ))->NextScreen =
		XSC(parent)->FrontMember;
	    XSC(parent)->BackMember->NextScreen = NULL;
	}
    }
    else /* Screen has no parent or children, or screen is child to move on its own */
    {
	/* By default, assume we'll insert at the head of the list */
	struct Screen **scptr = &IBase->FirstScreen;

	/* Don't delink the screen if this is the initial linking
	 * of the screen (i.e. from OpenScreen())
	 */
	if ( !TESTFLAG( whichway, SDEPTH_INITIAL ) )
	{
	    delinkScreen( screen, TRUE );
	}

	if ( ( whichway & SDEPTH_DIRECTIONMASK ) == SDEPTH_TOFRONT )
	{
	    if ( parent )
	    {
		/* This is a child screen, so insert it ahead of
		 * the parent's first child, and make this screen
		 * the first child
		 */
		scptr = (struct Screen **)previousThing( XSC(parent)->FrontMember, scptr, 0 );
		XSC(parent)->FrontMember = screen;
	    }
	    screen->NextScreen = *scptr;
	    *scptr = screen;
	}
	else /* SDEPTH_TOBACK */
	{
	    struct Screen *tailsc = lastThing( scptr );

	    if ( parent )
	    {
		/* This is a child screen, so insert it after
		 * the parent's last child, and make this screen
		 * the last child
		 */
		tailsc = XSC(parent)->BackMember;
		XSC(parent)->BackMember = screen;
	    }
	    screen->NextScreen = tailsc->NextScreen;
	    tailsc->NextScreen = screen;
	}
    }
}

d469 1
a469 1
    doISM( itDEPTHSCREEN, screen, NULL, SDEPTH_TOBACK );
d1072 264
@


38.12
log
@SA_ChildDrag,FALSE screens now drag horiz/vert in lockstep.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.11 92/03/03 16:35:25 peter Exp Locker: peter $
a421 1
LONG
d427 19
d447 1
d458 1
d460 1
d529 1
d531 1
d582 1
a582 1
	if ( whichway == SDEPTH_TOFRONT )
d588 1
a588 1
	else /* ( whichway == SDEPTH_TOBACK ) */
@


38.11
log
@TopOffset renamed PullDown.  Uses new faster form of newMakeScreen().
Renamed the screen movement flags.  Now lets screenLegalPosition() handle
the unbounding at the bottom.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.10 92/02/21 17:04:29 peter Exp Locker: peter $
d244 1
a244 1
	/* We now allow attached screens.  Is this screen a child? */
d247 1
a247 1
	    ULONG pulldown = pullDown( screen, parent );
d251 2
a252 2
	    /* Update its PullDownOffset wrt. the parent screen */
	    XSC(screen)->PullDownOffset = position.Y - pulldown;
d266 31
a296 2
		position.X = child->LeftEdge;
		position.Y = XSC(child)->PullDownOffset + pullDown( child, screen );
d393 1
a393 1
int
d398 1
a398 1
    return( ( imax( 0, ( parent->TopEdge - XSC(parent)->DClip.MinY ) ) *
d417 94
d528 3
d583 1
a583 1
	    delinkScreen( screen );
@


38.10
log
@Now actually calls AllocDBufInfo() and FreeDBufInfo().  Renamed
IScreenDepth() controls.  ScreenToFront() and ScreenToBack()
now move the whole family.  Added screenFamily() function.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.9 92/02/20 12:16:46 peter Exp Locker: peter $
d186 1
a186 1
IMoveScreen(screen, delta, allowmagic )
d189 1
a189 1
WORD allowmagic;	/* magic menu can move us farther right than nml */
d205 1
a205 1
	( dx || dy || (allowmagic & MAGIC_VALIDATE ) ) ) )
d210 1
a210 1
    /* you cannot move a hedley screen */
d213 1
a213 1
	DMS( printf("MoveScreen: don't move Hedley screens\n") );
d219 1
a219 5
     */
    screenLegalPosition( screen, &legal_positions, allowmagic );


    /* Peter 26-Apr-91: For compatibility, programmatic screen motion
a222 4
     * Peter 28-Jan-92: For screens which are MCOMPAT_NOBODY, there's
     * no point letting the user drag them down below the DClip.
     * This is important, since the new scrolling Hedley display
     * doesn't allow that.
d224 1
a224 5
    if ( !TESTFLAG( XSC(screen)->PrivateFlags, PRIVSCF_MCOMPAT_NOBODY ) )
    {
#define VBIG	(7000)
	legal_positions.MaxY = VBIG;
    }
d247 1
a247 1
	    ULONG parenttop = parentTop( screen, parent );
d249 1
a249 1
	    position.Y = imax( position.Y, parenttop );
d251 2
a252 2
	    /* Update its TopOffset wrt. the parent screen */
	    XSC(screen)->TopOffset = position.Y - parenttop;
d267 1
a267 1
		position.Y = XSC(child)->TopOffset + parentTop( child, screen );
d293 1
a293 1
    MakeScreen( screen );
d361 2
a362 2
/* Calculate the parent's TopEdge wrt. its DClip, in the resolution of
 * the child screen, and wrt. its DClip.
d365 1
a365 1
parentTop( child, parent )
a893 1

@


38.9
log
@Inverted return code of ChangeScreenBuffer() to match docs.  Now
optionally copies the screen's bitmap into each subsequent bitmap, in a
state-synchronous way.  Added flags parameter to AllocScreenBuffer().
Added screen parameter to FreeScreenBuffer().  Removed requirement
to restore original ScreenBuffer.  Now require ScreenBuffers to be
freed before CloseScreen().
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.8 92/02/17 17:16:47 peter Exp Locker: peter $
a185 13
/* Calculate the parent's TopEdge wrt. its DClip, in the resolution of
 * the child screen, and wrt. its DClip.
 */
int parentTop( child, parent )
struct Screen *child;
struct Screen *parent;
{
    return( ( imax( 0, ( parent->TopEdge - XSC(parent)->DClip.MinY ) ) *
	XSC(parent)->ScaleFactor.Y ) / XSC(child)->ScaleFactor.Y +
	XSC(child)->DClip.MinY );
}


d257 1
a257 1
	if ( parent = XSC(screen)->Parent )
d336 1
a336 1
    doISM( itDEPTHSCREEN, screen, NULL, S_TOFRONT );
d373 27
d402 15
a416 9
 * 1.  For regular screens, S_TOFRONT puts that screen at the very head
 *     of the screen-list, and S_TOBACK puts that screen at the very end.
 * 2.  For parent screens, S_TOFRONT puts that screen's whole family to
 *     the head of the screen-list, and S_TOBACK puts the whole family
 *     to the back (the ordering inside the family is unchanged).
 * 3.  Interactive depth-arrangement of children (Amiga-M/N and screen
 *     depth gadgets) operate as though the parent was depth-arranged.
 * 4.  Programmatic depth-arrangement of children (ScreenToFront/Back())
 *     moves the children to the front or rear of the family only.
d423 1
a423 1
    struct Screen *parent = XSC(screen)->Parent;
d425 4
a428 2
    /* If this screen's children list is not empty, then this screen
     * is a parent:
d433 1
a433 1
	whichway |= S_DEPTHFAMILY;
d436 2
a437 3
    /* Interactive depth-arrangement of a child is equivalent to
     * depth-arranging the whole family.  When the parent moves, all
     * children move with it.
d439 1
a439 1
    if ( ( parent ) && ( whichway & S_DEPTHFAMILY ) )
d445 1
a445 1
	if ( whichway == ( S_TOFRONT | S_DEPTHFAMILY ) )
d451 1
a451 1
	else /* whichway == ( S_TOBACK | S_DEPTHFAMILY ) */
d459 1
a459 1
    else /* Screen has no parent, or screen is child to move on its own */
d461 1
a461 1
	/* By default, we insert at the head of the list */
d464 2
a465 2
	/* Don't delink the screen if told (happens when a screen is first
	 * opened, and thus not yet linked in)
d467 1
a467 1
	if ( !TESTFLAG( whichway, S_NO_DELINK ) )
d472 1
a472 1
	if ( ( whichway & S_DEPTHMASK ) == S_TOFRONT )
d476 3
a478 2
		/* Since this screen has a parent, we insert ahead of the
		 * parent's first child, and make this screen the first child
d486 1
a486 1
	else /* S_TOBACK */
d492 4
d532 1
a532 1
    doISM( itDEPTHSCREEN, screen, NULL, S_TOBACK );
a913 3
#if AA_KLUDGES
	/* AllocDBufInfo() not yet public, but NULL is OK says ChrisG */
#else
a914 1
#endif
a1028 3
#if AA_KLUDGES
	/* FreeDBufInfo is not yet public */
#else
a1029 1
#endif
@


38.8
log
@Removed references to unused itBORDERPATROL.  Added the ScreenBuffer
functions.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.7 92/01/28 12:40:56 peter Exp Locker: peter $
d79 1
d810 2
a811 2
*	sbuffer = AllocScreenBuffer( Screen, BitMap )
*	D0                           A0      A1
d814 1
a814 1
*	    struct BitMap * );
d819 3
a821 1
*	Intuition screens.
d823 25
a847 13
*    INPUTS
*	Screen: pointer to the screen to double-buffer
*	BitMap:  If you supplied a custom bitmap when you opened this
*	    screen, then for each buffer, you should allocate a
*	    matching bitmap and pass it to AllocScreenBuffer().
*
*	    If you let Intuition provide your screen's BitMap, then
*	    you should pass NULL for this parameter, and Intuition
*	    will allocate a BitMap for each ScreenBuffer you allocate.
*
*	    You may also pass the special SB_SCREEN_BITMAP value, in
*	    order to get a ScreenBuffer which refers to the bitmap the
*	    screen was opened with.
d853 3
a855 1
*	ViewPort-buffering features such as signalling.
d864 7
d872 1
a872 1
struct ScreenBuffer *AllocScreenBuffer( sc, bm )
d881 2
a882 1
    DDB( printf("AllocScreenBuffer(screen %lx, bitmap %lx)\n", sc, bm ) );
a886 1
	DDB( printf("Got XScreenBuffer at %lx\n", sb ) );
d888 3
a890 1
#if 0
a891 2
#else
	/* AllocDBufInfo() not yet public, but NULL is OK says ChrisG */
d894 1
a894 1
	    if ( bm == SB_SCREEN_BITMAP )
d898 4
a901 6
		DDB( printf("SB_SCREEN_BITMAP, sb_BitMap = %lx\n", sb->sb_BitMap) );
	    }
	    else if ( bm )
	    {
		/* Caller supplied his own bitmap, since the
		 * screen was a CUSTOMBITMAP one.
d903 3
a905 2
		sb->sb_BitMap = bm;
		DDB( printf("Custom bitmap, sb_BitMap = %lx\n", sb->sb_BitMap) );
d907 1
a907 1
	    else
d910 1
a910 1
		 * This screen shouldn't be a CUSTOMBITMAP one.
d916 9
a924 1
		DDB( printf("Allocated bitmap, sb_BitMap = %lx\n", sb->sb_BitMap) );
d926 1
d928 1
a933 1
	    DDB( printf("Failed to AllocScreenBuffer()\n") );
d937 9
d947 2
a948 1
    DDB( printf("Exiting with sb = %lx\n", sb ) );
d953 14
d973 2
a974 2
*	FreeScreenBuffer( ScreenBuffer )
*	                  A0
d976 1
a976 1
*	VOID FreeScreenBuffer( struct ScreenBuffer * );
d980 2
a981 1
*	and releases associated resources.
d984 1
d1000 2
a1001 1
void FreeScreenBuffer( sb )
d1004 1
d1007 4
a1010 4
	if ( sb->sb_DBufInfo )
	{
#if 0	/* NOT YET PUBLIC */
	    FreeDBufInfo( sb->sb_DBufInfo );
d1012 7
a1018 2
	}
	if ( TESTFLAG( XSB(sb)->sb_Flags, SB_FREEBITMAP ) )
d1020 1
d1025 1
d1043 5
a1047 4
*	specified screen.  The previously-installed BitMap is available
*	for re-use upon receiving a signal from graphics.library.
*	That signal may be found in the DBufInfo structure pointed at
*	by the ScreenBuffer structure. 
d1061 4
a1064 2
*	You MUST restore the original screen's buffer before closing
*	the screen down!
d1074 1
a1074 1
BOOL ChangeScreenBuffer( sc, sb )
d1078 2
a1079 2
    DDB( printf("Calling ChangeScreenBuffer(sc=%lx,sb=%lx\n", sc, sb ) );
    return( doISM( itCHANGESCBUF, sc, sb ) );
d1082 37
@


38.7
log
@MCOMPAT_NOBODY screens no longer can be dragged down below their
DClip top.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.6 92/01/22 16:44:29 peter Exp Locker: peter $
d14 4
d27 1
a795 1
	/* * sendISM( itBORDERPATROL, screen ); * */
d800 210
@


38.6
log
@Removed some dead code.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.5 91/11/15 18:53:54 peter Exp Locker: peter $
d229 1
d234 4
d239 2
d242 2
a243 1
    legal_positions.MaxY = VBIG;
@


38.5
log
@No longer refreshes IBitMap and SBitMap upon setScreen().
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.4 91/07/25 15:04:28 peter Exp Locker: peter $
a622 4
#if 0
    IBase->IBitMap	= s->sc_BitMap;
    IBase->SBitMap	= s->sc_BitMap;
#endif
@


38.4
log
@Screen movement now handles attached screens.
Screen depth arrangement now handles attached screens.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.3 91/07/10 18:01:49 peter Exp Locker: peter $
d623 1
d626 1
@


38.3
log
@Deleted references to unused SDrawCount.  Removed some unused vbles
from IMoveScreen().
Last row of titlebar is now rendered in BARTRIMPEN.  Now uses
common drawScreenBar().
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.2 91/06/19 18:07:13 peter Exp Locker: peter $
d180 13
d253 12
a264 5
	/* rethinkVP will set vp dx/dyoffsets	*/
	XSC(screen)->VPOffsetStash.X = 
	    screen->ViewPort.DxOffset = screen->LeftEdge = position.X;
	XSC(screen)->VPOffsetStash.Y = 
	    screen->ViewPort.DyOffset = screen->TopEdge = position.Y;
d266 17
a282 1
	MakeScreen( screen );
a283 1
	screenMouse( screen );
d290 18
d335 1
a335 1
    doISM( itDEPTHSCREEN, screen, NULL, IUPFRONT );
d362 66
d429 5
d435 1
d437 3
a439 2
	    /* relink it at back or in front */
	    if ( whichway == IUPFRONT )
d441 5
a445 2
		screen->NextScreen = IBase->FirstScreen;
		IBase->FirstScreen = screen;
d447 8
a454 1
	    else	/* to back	*/
d456 2
a457 5
		/* link screen onto last screen */
		((struct Screen *)lastThing(&IBase->FirstScreen))->NextScreen
		    = screen;

		screen->NextScreen = NULL;
d459 2
a462 4

    UNLOCKIBASE();

    RethinkDisplay();
a464 1

d492 1
a492 1
    doISM( itDEPTHSCREEN, screen, NULL, IBEHIND );
@


38.2
log
@Removed obsolete code.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 38.1 91/06/12 15:13:15 peter Exp Locker: peter $
a184 5
    UWORD roff=16;
    SHORT top_limit;
    SHORT left_limit;
    SHORT right_limit;
    struct Rectangle *dclip;
a426 9
    if ( XSC(s)->SDrawCount < 0 )
    {
	/** ZZZ: "First Use" initialization goes here **/
	XSC(s)->SDrawCount = 1;
    }
    else
    {
	XSC(s)->SDrawCount++;
    }
a472 1
    XSC(s)->SDrawCount--;
d497 16
d552 1
d554 3
a556 4
    /*  Can we do this to non-newlook screens?  Maybe I should use BARBLOCKPEN
     *  here too
     */
    drawBlock( rp, 0, s->BarHeight, s->Width - 1, s->BarHeight, dri->dri_Pens[ BARDETAILPEN ]);
d559 3
@


38.1
log
@Enabled NewLook titlebar.  Adjusted its appearance.  Eliminated some
compiled-out code.
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 1.31 91/04/26 18:58:35 peter Exp Locker: peter $
a23 3
#define SCREEN_VP_SYNC	(0)	/* rethinkVP will set vp dx/dyoffsets	*/


a76 2
#if 1	/* just one depth gadget */

a83 13
#else

#define SGTYPECOUNT 3
USHORT SGadgetTypes[SGTYPECOUNT] =
    {
    SUPFRONTGADGET, 
    SDOWNBACKGADGET, 
    SDRAGGADGET, 		/* COUNTING on this to be last	*/
    };

#endif


d245 1
a245 5
#if SCREEN_VP_SYNC
	/* DxDyOffset set up by RemakeDisplay */
	screen->LeftEdge = position.X;
	screen->TopEdge = position.Y;
#else
a249 1
#endif
a364 1
#if 1
a368 34
#else
ScreenToBack(screen)
{
    realScreenToBack( screen, TRUE );
}


realScreenToBack(screen, lockstate)
struct Screen *screen;
{
    struct Screen *workscreen;
    struct IntuitionBase *IBase = fetchIBase();

    if ( ! screen ) return;

    CLEARFLAG( IBase->Flags, POPPEDSCREEN );

    if ( lockstate ) LOCKIBASE();

    delinkScreen(screen);

    /* link screen onto last screen */
    ((struct Screen *)lastThing(&IBase->FirstScreen))->NextScreen = screen;

    screen->NextScreen = NULL;

    if ( lockstate ) UNLOCKIBASE();

    RethinkDisplay();
#if DO_FREEMOUSE_AGAIN
    freeMouse();	/* jimm: PAL: */
#endif
}
#endif
a502 3
#ifdef IOWNTMPRAS
    IBase->MenuRPort.TmpRas	= &IBase->MenuTmpRas;
#else
a503 1
#endif
a511 6

#define TRICKSCREENBAR	(0)

#if TRICKSCREENBAR
#define SCREEN_TEXT_LEFT	(5)
#else
a512 1
#endif
@


38.0
log
@Initial V38 check-in (matches V37 release).
@
text
@d5 1
a5 1
 *  $Id: scsupp.c,v 1.31 91/04/26 18:58:35 peter Exp $
a594 1
#ifdef NEWLOOK_TITLEBAR
a595 1
#endif
a616 1
#ifdef NEWLOOK_TITLEBAR
d621 1
a621 1
    /*  Can we do this to non-newlook screens?  Maybe I should use sbarfillpen
d624 1
a624 1
    drawBlock( rp, 2, s->BarHeight, s->Width - 1, s->BarHeight, dri->dri_Pens[ shadowPen ]);
d626 1
a626 18
	dri->dri_Pens[ sbarfillPen ]);

    if (s->Title)
    {
	DSB( printf("new screen title %s\n", s->Title ) );
	itext.FrontPen = dri->dri_Pens[ sbartextPen ];
	itext.BackPen = dri->dri_Pens[ sbarfillPen ];
	itext.DrawMode = JAM2;
	itext.TopEdge = s->BarVBorder;
	itext.LeftEdge = s->BarHBorder;
	itext.ITextFont = NULL;
	itext.IText = s->Title;
	itext.NextText = NULL;
	PrintIText(s->BarLayer->rp, &itext, SCREEN_TEXT_LEFT, 0);
    }

#else
    drawBlock( rp, 0, 0, s->Width - 1, s->BarHeight, s->BlockPen);
d631 2
a632 2
	itext.FrontPen = s->DetailPen;
	itext.BackPen = s->BlockPen;
a640 1
#endif
a642 26

#if TRICKSCREENBAR
    /* round off the upper corners	*/
    {
	int segwidth;
	int row;

	segwidth = s->BarHeight / 3;
	row = 0;

	SetAPen( rp, 0 );

	while ( segwidth >= 0 )
	{
	    Move( rp, 0, row );
	    Draw( rp, segwidth, row );

	    Move( rp, s->Width - (1 + segwidth), row );
	    Draw( rp, s->Width - 1, row );

	    row++;
	    segwidth--;	/* crank it by more depending on rez */
	}
    }
#endif

@
