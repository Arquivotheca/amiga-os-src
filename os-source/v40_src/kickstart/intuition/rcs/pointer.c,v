head     39.31;
branch   ;
access   ;
symbols  V40_85:39.31 V40_71:39.30 V40_68:39.29 V40_65:39.28 V40_47:39.28 V40_45:39.28 V40_37:39.28 V40_34:39.28 V40_29:39.28 V39_2415:39.28 V39_2369:39.27 V39_2339:39.26 V39_2332:39.26 V39_2275:39.26 V39_2256:39.26 V39_2210:39.26 V39_2192:39.26 V39_2084:39.25 V39_2082:39.25 V39_2076:39.25 V39_2073:39.24 V39_2058:39.24 V39_2051:39.23 V39_2031:39.22 V39_2017:39.22 V39_2012:39.21 V39_1985:39.21 V39_1933:39.20 V39_1819:39.18 V39_1805:39.17 V39_1783:39.17 V39_1695:39.16 V39_1621:39.16 V39_1620:39.16 V39_1508:39.14 V39_1485:39.13 V39_1461:39.12 V39_1458:39.12 V39_1456:39.11 V39_1405:39.10 V39_1368:39.9 V39_1360:39.9 V39_1324:39.9 V39_1147:39.7 V39_1143:39.7 V39_1141:39.7 V39_1120:39.6 V39_1116:39.6 V39_1104:39.5 V39_1100:39.5 V39_1078:39.4 V39_1073:39.3;
locks    ; strict;
comment  @ * @;


39.31
date     93.05.05.11.55.42;  author peter;  state Exp;
branches ;
next     39.30;

39.30
date     93.04.15.16.07.38;  author peter;  state Exp;
branches ;
next     39.29;

39.29
date     93.04.15.00.57.55;  author peter;  state Exp;
branches ;
next     39.28;

39.28
date     93.01.12.16.19.35;  author peter;  state Exp;
branches ;
next     39.27;

39.27
date     93.01.08.14.47.55;  author peter;  state Exp;
branches ;
next     39.26;

39.26
date     92.11.10.17.08.43;  author peter;  state Exp;
branches ;
next     39.25;

39.25
date     92.08.28.13.05.24;  author peter;  state Exp;
branches ;
next     39.24;

39.24
date     92.08.18.13.46.24;  author peter;  state Exp;
branches ;
next     39.23;

39.23
date     92.08.18.10.13.08;  author peter;  state Exp;
branches ;
next     39.22;

39.22
date     92.08.06.17.00.59;  author peter;  state Exp;
branches ;
next     39.21;

39.21
date     92.08.04.09.59.18;  author peter;  state Exp;
branches ;
next     39.20;

39.20
date     92.08.03.15.55.04;  author peter;  state Exp;
branches ;
next     39.19;

39.19
date     92.08.02.12.43.14;  author peter;  state Exp;
branches ;
next     39.18;

39.18
date     92.07.28.15.14.00;  author peter;  state Exp;
branches ;
next     39.17;

39.17
date     92.07.17.17.28.38;  author peter;  state Exp;
branches ;
next     39.16;

39.16
date     92.06.29.10.56.16;  author peter;  state Exp;
branches ;
next     39.15;

39.15
date     92.06.23.17.20.54;  author peter;  state Exp;
branches ;
next     39.14;

39.14
date     92.06.22.13.02.09;  author peter;  state Exp;
branches ;
next     39.13;

39.13
date     92.06.18.18.09.35;  author peter;  state Exp;
branches ;
next     39.12;

39.12
date     92.06.04.16.17.38;  author peter;  state Exp;
branches ;
next     39.11;

39.11
date     92.06.02.14.54.46;  author peter;  state Exp;
branches ;
next     39.10;

39.10
date     92.05.29.18.28.20;  author peter;  state Exp;
branches ;
next     39.9;

39.9
date     92.05.21.17.43.05;  author peter;  state Exp;
branches ;
next     39.8;

39.8
date     92.05.15.14.08.16;  author peter;  state Exp;
branches ;
next     39.7;

39.7
date     92.05.01.13.54.05;  author peter;  state Exp;
branches ;
next     39.6;

39.6
date     92.04.14.15.45.13;  author peter;  state Exp;
branches ;
next     39.5;

39.5
date     92.04.13.16.23.33;  author peter;  state Exp;
branches ;
next     39.4;

39.4
date     92.04.10.15.05.19;  author peter;  state Exp;
branches ;
next     39.3;

39.3
date     92.04.09.16.23.57;  author peter;  state Exp;
branches ;
next     39.2;

39.2
date     92.04.07.17.55.18;  author peter;  state Exp;
branches ;
next     39.1;

39.1
date     92.04.02.12.06.22;  author peter;  state Exp;
branches ;
next     39.0;

39.0
date     92.03.30.14.07.53;  author peter;  state Exp;
branches ;
next     ;


desc
@New pointer routines for V39.
@


39.31
log
@Changed a TAG_DONE to a NULL.
@
text
@/*** pointer.c *****************************************************************
 *
 * pointer.c -- New Intuition pointer routines
 *
 *  $Id: pointer.c,v 39.30 93/04/15 16:07:38 peter Exp Locker: peter $
 *
 *  Confidential Information: Commodore-Amiga, Inc.
 *  Copyright (C) 1992, Commodore-Amiga, Inc.
 *  All Rights Reserved
 *
 ****************************************************************************/

/* This optimization depends on GfxBase maintaining a VBlank counter.
 * the idea is that in place of WaitTOF()/FreeXXX(), we send ourselves
 * a token (reminder) to FreeXXX after the VBlank counter has had
 * a chance to change, thus taking a WaitTOF() clean out of setMousePointer().
 */
#define WAITTOF_OPTIMIZE	0

#ifndef EXEC_MEMORY_H
#include <exec/memory.h>
#endif

#ifndef GRAPHICS_DISPLAYINFO_H
#include <graphics/displayinfo.h>
#endif

#ifndef GRAPHICS_SPRITE_H
#include <graphics/sprite.h>
#endif

#ifndef UTILITY_PACK_H
#include <utility/pack.h>
#endif

#include "intuall.h"
#include "intuition.h"
#include "pointerclass.h"
#include "classusr.h"
#include "classes.h"
#include "iprefs.h"

#define D(x)		;	/* misc debugging */
#define DSDM(x)		;	/* setDefaultMousePointer */
#define DSBP(x)		;	/* set busy pointer */
#define DSMP(x)		;	/* setMousePointer */
#define DAS(x)		;	/* MakeSpriteData() */
#define DSW(x)		;	/* Sprite word-width */

#define DPC(x)		;	/* pointerclass */
#define DSS(x)		;	/* setSpriteSpeed */
#define DSH(x)		;	/* setSpriteHeight */
#define DSP(x)		;	/* SetPointer/ClearPointer */


#define DUPM(x)		;	/* updateMousePointer */
#define DUPM2(x)	;	/* updateMousePointer */
#define DUPMC(x)	;	/* updateMousePointer change sprite */

#define DDF(x)		;	/* run time debug flag testing	*/
#define DP(x)		;	/* old setDefaultPointer */
#define DKILL(x)	;	/* pointer kill */

#if 0
#define ICOLOR(c)	 (*((SHORT *)0xdff180) = (c))
#define CKCOLOR0 (0xf00)
#define CKCOLOR1 (0x000)
#define CKCOLOR2 (0x0f0)
#define CKCOLOR3 (0x000)
#define CKCOLOR4 (0x00f)
#define CKCOLOR5 (0x000)
#define CKCOLOR6 (0xfff)
#define CKCOLOR7 (0x000)
#define CKCOLOR8 (0xff0)
#define CKCOLOR9 (0x000)
#define CKCOLOR10 (0x0ff)

#define DONECOLOR (0xfff)

#else
#define ICOLOR(c)	;
#endif


/*
 * initMousePointer()
 *	- One-time init.
 *
 * setDefaultMousePointer()
 *	- Change pref pointer.
 *
 * ISetWindowPointer()
 *	- Change the window's custom pointer.
 *
 * setMousePointer()
 *	- Establish the sprite based on the correct active pointer.
 *
 * calcSpriteWidth()
 *	- Figure out whether to use 16/32/64 bits for the sprite.
 *
 * reinstatePointer()
 *	- rebound from gfx killing our pointer
 *
 * MakeSpriteData()
 *
 */

struct ExtSprite *MakeSpriteData();

struct BitMap *setDefaultMousePointer();

extern UBYTE *PointerClassName;

/* the Intuition pointer, though defined as ROMPOINTER_HEIGHT tall,
 * has memory allocated for 16 tall, in case User wants to change it.
 * (the definition is in intuinternal.h)
 * ZZZ: This has something to do with GetPrefs() and friends.  Depending
 * what we do there, we may be able to shave the pointer image down.
 */

/* Here are the bitmap planes for the Intuition default pointer
 * and default busy pointer (note that AllocSpriteData() does not
 * require that they be in chip RAM):
 */

UWORD RomPointer0[] =
{
    0xC000,
    0x7000,
    0x3C00,
    0x3F00,

    0x1FC0,
    0x1FC0,
    0x0F00,
    0x0D80,

    0x04C0,
    0x0460,
    0x0020,
    0x0000,

    0x0000,
    0x0000,
    0x0000,
    0x0000,

};

UWORD RomPointer1[] =
{
    0x4000,
    0xB000,
    0x4C00,
    0x4300,

    0x20C0,
    0x2000,
    0x1100,
    0x1280,

    0x0940,
    0x08A0,
    0x0040,
    0x0000,

    0x0000,
    0x0000,
    0x0000,
    0x0000,
};

UWORD RomBusyPointer0[] =
{
    0x0400,
    0x0000,
    0x0100,
    0x0000,

    0x07C0,
    0x1FF0,
    0x3FF8,
    0x3FF8,

    0x7FFC,
    0x7EFC,
    0x7FFC,
    0x3FF8,

    0x3FF8,
    0x1FF0,
    0x07C0,
    0x0000,
};

UWORD RomBusyPointer1[] =
{
    0x07C0,
    0x07C0,
    0x0380,
    0x07E0,

    0x1FF8,
    0x3FEC,
    0x7FDE,
    0x7FBE,

    0xFF7F,
    0xFFFF,
    0xFFFF,
    0x7FFE,

    0x7FFE,
    0x3FFC,
    0x1FF8,
    0x07E0,
};


/* We want to look at GfxBase->MemType or GfxBase->BoardMemType to determine
 * the number of pointer sizes to deal with.  (Board)MemType is defined in a
 * manner convenient for Graphics,but not super-suitable for us:
 *
 * MemType   System Type     Number of Pointers
 *    0   -> 1X system       1
 *    1,2 -> 2X system       2
 *    3   -> 4X system       3
 *
 * This little bit of amazing math gives the right result, but would need to
 * be changed if we ever had different values of (Board)MemType.
 * Pay no attention to the man behind the curtain!
 */

#define NUMPOINTERS( memtype )	( ( (memtype) + 3 ) / 2 )

/*** initMousePointer() ***
 *
 * This routine manages the initialization of much of the pointer stuff.
 * It figures out how many pointer sizes Intuition will need to make.
 * It sets up the pointer-kill callback stuff.  It init's the standard
 * default and busy pointers.
 *
 * STATUS:  Consider putting in-line in init.c
 *
 */

initMousePointer()
{
    struct IntuitionBase *IBase = fetchIBase();
    struct BitMap pointer_bm;
    struct BitMap *busy_bm;

    void pointerKill();

    /* Set up the vector and data that gfx uses when it kills our
     * sprite-pointer for compatibility reasons.
     */
    IBase->GfxBase->IData = (APTR) IBase;
    IBase->GfxBase->IVector = (APTR) pointerKill;

    /* Let's set up the pointer bitmap.  Note that AllocSpriteData()
     * does not require that the plane data be in chip.
     */
    InitBitMap( &pointer_bm, 2, ROMPOINTER_WIDTH, ROMPOINTER_HEIGHT );
    pointer_bm.Planes[0] = RomPointer0;
    pointer_bm.Planes[1] = RomPointer1;
    DP( printf("initial sDIP ...\n"));
    setDefaultMousePointer( &pointer_bm,
	ROMPOINTER_HOTX, ROMPOINTER_HOTY,
	ROMPOINTER_XRESN, ROMPOINTER_YRESN,
	ROMPOINTER_WORDWIDTH, NPT_DEFAULT );
    DP( printf(" returned\n"));

    /* Failure here doesn't matter, since a NULL value causes
     * us to fall back to the default pointer.
     */
    DSBP( printf("About to alloc busy pointer\n"));
    /* For the default pointer, we don't need to keep the bitmap around,
     * since setDefaultMousePointer() allocates sprites in each width,
     * and then we're done with the bitmap.
     * However, the busy-pointer is handled like any custom pointer,
     * which is to say, sprite-data are generated on-demand only.  So
     * the bitmap needs to persist.
     */
    if ( busy_bm = IBase->BusyPointerBitMap =
	(struct BitMap *)AllocVec( sizeof(struct BitMap), MEMF_CLEAR ) )
    {
	InitBitMap( busy_bm, 2, ROMBUSYPOINTER_WIDTH, ROMBUSYPOINTER_HEIGHT );
	busy_bm->Planes[0] = RomBusyPointer0;
	busy_bm->Planes[1] = RomBusyPointer1;
	setDefaultMousePointer( busy_bm,
	    ROMBUSYPOINTER_HOTX, ROMBUSYPOINTER_HOTY,
	    ROMBUSYPOINTER_XRESN, ROMBUSYPOINTER_YRESN,
	    ROMBUSYPOINTER_WORDWIDTH, NPT_BUSY );
    }
    DSBP( printf("Done allocing busy pointer\n"));

    /* setMousePointer() done inside setDefaultMousePointer() */
}

/*** setDefaultMousePointer() ***
 *
 * Installs into Intuition a new default imagery for the standard
 * or busy pointer.  Caller supplies a BitMap, hot-spot offset
 * resolution and width information.
 *
 * For the default pointer, Intuition will make MousePointer structure
 * for it, then allocate an ExtSprite for each available sprite-size, and
 * make IBase->DefaultExtSprite point at it.  The previous default
 * pointer's ExtSprites are freed.  Note that Intuition doesn't currently
 * need to keep the BitMap of the default pointer, since all possible
 * pointers (3 sizes) are already created.  If the call fails, the partial
 * result is freed, and NULL is returned.  If it succeeds, the pointer
 * to the input BitMap is returned (so it can be freed by IPrefs).
 *
 * For the busy pointer Intuition just allocates a MousePointer structure
 * for it.  Returns 0 for failure, ~0 for success, or a pointer to the
 * previously installed busy pointer BitMap, for IPrefs to free.
 *
 * The caller must do the following, based on the return code:
 *
 *	~0 - everything is fine, do nothing.
 *	 0 - something failed, please free the BitMap you called with.
 *   other - This is a pointer to a BitMap to be freed (it could be the
 *	     one you just passed in, or it could be the one passed in
 *	     the previous time).
 *
 */

#define SUCCESS ((struct BitMap *)~0)

struct BitMap *
setDefaultMousePointer( bm, xoffset, yoffset, xresn, yresn, wordwidth, type )
struct BitMap *bm;
LONG xoffset;
LONG yoffset;
LONG xresn;
LONG yresn;
LONG wordwidth;
LONG type;
{
    struct BitMap *free_result = NULL;
    LONG size;
    struct MousePointer *newmpointer;
    LONG designsize;
    LONG numpointers;
    struct IntuitionBase *IBase = fetchIBase();

    extern UBYTE *PointerClassName;

    /* Figure out how many different pointers this system
     * potentially supports.  We need to allocate based on BoardMemType,
     * which reflects what GB->MemType would be after enlighten.
     * That is, we allocate sprites for the _potential_ of the machine,
     * but in calcSpriteWidth() we only choose from those currently
     * allowed by software conditions (eg. pre-enlighten, BootMenu display
     * options.
     */
    numpointers = NUMPOINTERS( IBase->GfxBase->BoardMemType );

    /* ZZZ: would have some trouble if we added new standard types */
    DSDM( printf( "\nsDMP: bm %lx, hotspot: %ld,%ld, xresn %ld, yresn %ld, ww %ld\n",
	bm, xoffset, yoffset, xresn, yresn, wordwidth ) );
    /* Create a new MousePointer structure... */
    if ( newmpointer = (struct MousePointer *)	NewObject( NULL, PointerClassName,
	POINTERA_BitMap, bm,
	POINTERA_XOffset, xoffset,
	POINTERA_YOffset, yoffset,
	POINTERA_WordWidth, wordwidth,
	POINTERA_XResolution, xresn,
	POINTERA_YResolution, yresn,
	TAG_DONE ) )
    {
	/* pointerclass can change wordwidth if it was -1
	 * (meaning an old-style pointer from SetPrefs)
	 */
	wordwidth = newmpointer->xmpt_WordWidth;

	DSDM( printf( "Obtained MousePointer %lx\n", newmpointer ) );
	/* use this lock to keep setMousePointer() from pointing
	 * at free memory
	 */
	LOCKIBASE();
	LOCKVIEW();

	/* If this is the default pointer, then IPrefs can free the
	 * BitMap it just passed to us (we don't keep the actual
	 * BitMap for the default pointer)
	 */
	free_result = bm;

	if ( type == NPT_BUSY )
	{
	    struct MousePointer *oldbusy;

	    DSBP( printf("Got new busy pointer %lx from bitmap %lx\n",
		newmpointer, bm ) );
	    DSBP( printf("Old one at %lx\n", IBase->DefaultBusyPointer ) );
	    /* Remember the old busy pointer for a check below */
	    oldbusy = IBase->DefaultBusyPointer;

	    /* Install the new busy pointer */
	    IBase->DefaultBusyPointer = newmpointer;

	    /* Nothing to do if this is the first time through... */
	    if ( oldbusy )
	    {
		/* Was the default busy pointer up? */
		if ( IBase->CustomMousePointer == oldbusy )
		{
		    DSBP( printf( "Calling sMP because default busy pointer in effect\n") );
		    setMousePointer();
		    /* We need to WaitTOF() if the default busy pointer was
		     * in use.
		     */
		    WaitTOF();
		}

		/* Normally, IPrefs would be freeing the BitMap of the
		 * previously installed busy pointer...
		 */
		free_result = oldbusy->mpt_BitMap;
		if ( free_result == IBase->BusyPointerBitMap )
		{
		    /* However,this was the original busy pointer that
		     * came from the ROM.  That one is our responsibility,
		     * to free, so let's do that, and tell IPrefs we
		     * succeeded but not to free anything.
		     */
		    DSBP( printf("Freeing busy-pointer bitmap\n"));
		    FreeVec( free_result );
		    IBase->BusyPointerBitMap = NULL;
		    /* Tell IPrefs we succeeded but not to free anything */
		    free_result = SUCCESS;
		}
		/* In any case, we have to free the MousePointer structure: */
		DisposeObject( oldbusy );
	    }
	    DSBP( printf("Returning bitmap %lx to be freed by IPrefs\n", free_result ) );
	}
	else /* type == NPT_DEFAULT */
	{
	    struct ExtSprite *oldExtSprite[POINTER_SIZES];
	    struct ExtSprite *newExtSprite[POINTER_SIZES];
	    /* Assume failure, which means we'll have to free
	     * the newExtSprite:
	     */
	    struct ExtSprite **freeExtSprite = newExtSprite;

	    /* Let's figure out the designed width in words (1,2,4),
	     * and also the designed size (0,1,2).
	     */
	    if ( (designsize = wordwidth - 1 ) == 3 )
	    {
		designsize = 2;
	    }
	    /* Attempt to allocate ExtSprite for the new preferences
	     * pointer imagery, for each size.  The way we designed it,
	     * each newExtSprite[] pointer points to something real
	     * or to NULL.
	     */
	    for ( size = 0; size < numpointers; size++ )
	    {
		if ( ! ( newExtSprite[ size ] = MakeSpriteData( newmpointer, 1<<size,
		    size-designsize ) ) )
		{
		    /* We failed */
		    free_result = NULL;
		}
		DSDM( printf( "newExtSprite[%ld] at %lx\n", size, newExtSprite[size] ) );
	    }

	    if ( free_result )
	    {
		/* Install the new pointer imagery as preferences,
		 * change the displayed pointer if necessary,
		 * and free the old ones.
		 */

		for ( size = 0; size < numpointers; size++ )
		{
		    oldExtSprite[size] = IBase->DefaultExtSprite[size];
		}

		/* This is safe inside LOCKIBASE(), since we only reference
		 * it inside LOCKIBASE().  Thus, no need to first copy away...
		 */
		DisposeObject( IBase->DefaultMousePointer );

		IBase->DefaultMousePointer = newmpointer;

		for ( size = 0; size < numpointers; size++ )
		{
		    IBase->DefaultExtSprite[size] = newExtSprite[size];
		}

		DSDM( printf( "DefaultExtSprites at %lx, %lx, %lx.  DefaultMP %lx\n",
		    IBase->DefaultExtSprite[0], IBase->DefaultExtSprite[1],
		    IBase->DefaultExtSprite[2], IBase->DefaultMousePointer ) );

		/* We update the display if the CustomMousePointer is
		 * NULL (meaning default is used)
		 */
		if ( !IBase->CustomMousePointer )
		{
		    DSDM( printf( "Calling sMP because default pointer in effect\n") );
		    setMousePointer();
		    /* We need to WaitTOF() if the default pointer was
		     * in use.
		     */
		    WaitTOF();
		}

		/* Since everything worked, we want to free the old ExtSprite
		 * instead:
		 */
		freeExtSprite = oldExtSprite;

	    }
	    else
	    {
		DisposeObject( newmpointer );
	    }
	    /* else we failed to allocate some of the new sprite data.
	     * Clean up any we did allocate, and return failure.
	     * ( freeExtSprite already points to newExtSprite ).
	     */

	    /* Free either the old or the new sprite data, depending
	     * on whether we succeeded or not.
	     */
	    for ( size = 0; size < numpointers; size++ )
	    {
		FreeSpriteData( freeExtSprite[ size ] );
	    }
	}
	UNLOCKVIEW();
	UNLOCKIBASE();
    }
    DSDM( printf( "sDMP returning bitmap to free %lx\n",free_result ) );
    return( free_result );
}


/*** ISetWindowPointer() ***
 *
 * This function is invoked when the application calls
 * SetPointer(), clearPointer or SetWindowPointer(), or
 * uses the WA_Pointer tag.
 *
 * A newMousePointer of NULL requests the default pointer.
 * newMousePointer equal to BUSYPOINTER is the standard
 * busy pointer.  (Note that this magic constant is not
 * public; applications get it through an explicit tag).
 * Other values are custom pointers obtained via
 * NewObject("pointerclass").
 *
 * If we got here during OpenWindow() through WA_Pointer,
 * then we come out OK since IBase->ActiveWindow doesn't
 * yet match win.
 *
 * There is no old stuff to free, since the system default pointer
 * is not changed by this, and custom pointers belong to the
 * application.
 */

ISetWindowPointer( win, newMousePointer )
struct Window *win;
struct MousePointer *newMousePointer;
{
    /* Optimistically assume we'll succeed: */
    LONG success = TRUE;
    struct IntuitionBase *IBase = fetchIBase();

    LOCKIBASE();
    LOCKVIEW();

    /* Stop any deferred pointer action, since a new pointer is
     * coming through.  Also, this is not a new-style pointer until
     * proven otherwise.
     */
    CLEARFLAG( win->MoreFlags, WMF_DEFERREDPOINTER );

    /* Go with custom pointer, or BUSYPOINTER, meaning the default busy
     * pointer, or NULL, meaning default pointer
     */
    XWINDOW(win)->MousePointer = newMousePointer;

    /* If the new pointer is an old-style one, then we must update
     * the pre-V39 window pointer fields.  This must be done under
     * lock, because Intuition accesses the MousePointer (which points
     * into the embedded pointer fields) under other tasks under lock.
     * We then set the MousePointer field of the XWINDOW() to point at
     * the embedded copy.
     *
     * (SetPointer() calls us with newMousePointer pointing
     * at an AllocVec()'d OldMousePointer.  We are expected to free
     * it here (see SetPointer() for relevant comments as to why).
     */
    if ( newMousePointer )
    {
	if ( ( newMousePointer != BUSYPOINTER ) &&
	( newMousePointer->mpt_Width != MPT_CUSTOMWIDTH ) )
	{
	    *(( struct OldMousePointer *)&win->Pointer ) =
		*(( struct OldMousePointer *)newMousePointer );

	    XWINDOW(win)->MousePointer = (struct MousePointer *)&win->Pointer;
	    FreeVec( newMousePointer );
	}
    }
    else
    {
	/* We were ClearPointer()d, so clear the fields */
	win->Pointer = NULL;
	win->PtrHeight = 0;
	win->PtrWidth = 0;
	win->XOffset = 0;
	win->YOffset = 0;
    }
    if ( win == IBase->ActiveWindow )
    {
	success = setMousePointer();
	if ( !success )
	{
	    /* Since we failed to give him the pointer
	     * he wanted, we mark the failure
	     * ZZZ: is this right?  Or should we try to keep
	     * the old pointer for a future attempt that
	     * might succeed.
	     */
	    XWINDOW(win)->MousePointer = NULL;
	}
    }

    /* The old window pointer is now released to the
     * application, so it may free it.
     * ZZZ: Should we do a WaitTOF(), or tell apps to
     * do that before freeing their guy?
     */

    UNLOCKVIEW();
    UNLOCKIBASE();

    return( success );
}


/*** setMousePointer() ***
 *
 * Establish the sprite display based on the active pointer.
 * Will call MakeSpriteData() if needed.
 *
 * This function might be called if:
 * - the user changed the preferences default pointer
 * - if the window's custom pointer changed
 * - if a new window became active
 * - if we have to re-instate the pointer because gfx had to kill it
 *
 */

LONG
setMousePointer()
{
    /* Let's assume success */
    LONG success = TRUE;
    struct ExtSprite *newCustomExtSprite = NULL;
    struct ExtSprite *newSprite = NULL;
    struct MousePointer *custompointer;

    struct IntuitionBase *IBase = fetchIBase();

    DSMP( printf( "\nsetMousePointer: enter\n" ) );
    LOCKIBASE();
    LOCKVIEW();

    /* Note the new active MousePointer (could be unchanged, but we
     * don't care yet).
     * ZZZ: Might be a good optimization, if we had a "force"
     * parameter to allow certain cases through anyways
     */
    IBase->CustomMousePointer = NULL;
    if ( IBase->ActiveWindow )
    {
	/* The busy-pointer is recognized by a special constant, which
	 * is only to be evaluated under IBase lock, since it's subject
	 * to change.
	 */
	if ( ( IBase->CustomMousePointer = XWINDOW(IBase->ActiveWindow)->MousePointer ) ==
	    BUSYPOINTER )
	{
	    IBase->CustomMousePointer = IBase->DefaultBusyPointer;
	}
    }
    DSMP( printf( "ActiveWindow %lx, IB->CustomMousePointer %lx\n",
	IBase->ActiveWindow, IBase->CustomMousePointer ) );

    /* Is active pointer a custom pointer of some kind?
     * Remember that CustomMousePointer is NULL when the default
     * pointer is up.
     */
    if ( custompointer = IBase->CustomMousePointer )
    {
	/* Assuming an old-style pointer, which has a width of 1 word,
	 * and a resolution of LORES in X and DEFAULT in Y.
	 * Also, if this is an old-style pointer from SetPrefs(), the
	 * caller pre-compensated for the old MoveSprite() off-by-one
	 * bug.  But since Intuition is using bug-free ExtSprites,
	 * we have to unshift to account for the x-error.
	 */
	LONG width = 1;
	LONG xres = POINTERXRESN_LORES;
	LONG yres = POINTERYRESN_DEFAULT;
	LONG xerror = -SPRITEERROR;
	/* Only new-style pointers have width/resolution information */
	if ( custompointer->mpt_Width == MPT_CUSTOMWIDTH )
	{
	    width = custompointer->xmpt_WordWidth;
	    xres = custompointer->xmpt_PointerXRes;
	    yres = custompointer->xmpt_PointerYRes;
	    xerror = 0;
	    DSW( printf("sMP: word-width of custom new-style pointer %ld\n",
		width ) );
	}
	/* Allocate a suitable ExtSprite representation of the pointer,
	 * based on what we figure to be the correct-sized pointer (16/32/64)
	 * we need to put up.
	 */
	DSW( printf("sMP: from calcSpriteWidth(%ld) = %ld\n", width, calcSpriteWidth(width) ) );
	if ( newCustomExtSprite = MakeSpriteData( custompointer,
	    calcSpriteWidth( width ), 0 ) )
	{
	    DSMP( printf( "got ExtSprite at %lx for CustomMousePointer\n",
		newCustomExtSprite ) );
	    /* Let's install the chosen sprite */
	    newSprite = newCustomExtSprite;
	    IBase->PointerXRes = xres;
	    IBase->PointerYRes = yres;
	    IBase->AXOffset = custompointer->mpt_XOffset + xerror;
	    IBase->AYOffset = custompointer->mpt_YOffset;
	}
	else
	{
	    /* We failed to give the guy what he wanted because MakeSpriteData()
	     * failed.  Let's note the failure, but proceed by giving him the
	     * system default arrow instead.
	     */
	    DSMP( printf( "Failed to get ExtSprite for CustomMousePointer\n") );
	    success = FALSE;
	    IBase->CustomMousePointer = NULL;
	}
    }

    if ( !newCustomExtSprite )
    {
	LONG width;

	/* Figure the sprite width, hoping to use our default word-width. */
	DSW( printf("sMP: Default sprite, calcSpriteWidth(%ld) = %ld\n",
	    IBase->DefaultMousePointer->xmpt_WordWidth,
	    calcSpriteWidth( IBase->DefaultMousePointer->xmpt_WordWidth ) ) );
	width = calcSpriteWidth( IBase->DefaultMousePointer->xmpt_WordWidth );
	/* GfxBase SpriteWidth is 1,2,4 words.  We want to convert
	 * that to 0,1,2 respectively.  This is the cheapest way
	 */
	if ( --width == 3 )
	{
	    width = 2;
	}
	/* If we get here, it's either because we failed to allocate
	 * a suitable size of the custom pointer, or else the active
	 * pointer is supposed to be the default one.
	 */

	/* We always keep an ExtSprite representation of the default pointer
	 * in each possible size, so we can't fail.  Let's determine what
	 * size to use, and use it.
	 *
	 * Note that old Pointers coming through Preferences have the
	 * exact correct hotspot position, so no decompensation is
	 * required.
	 */
	DSMP( printf( "Using DefaultExtSprite[%ld] at %lx\n",
	    width, IBase->DefaultExtSprite[width] ) );
	newSprite = IBase->DefaultExtSprite[ width ];
	IBase->PointerXRes = IBase->DefaultMousePointer->xmpt_PointerXRes;
	IBase->PointerYRes = IBase->DefaultMousePointer->xmpt_PointerYRes;
	IBase->AXOffset = IBase->DefaultMousePointer->mpt_XOffset;
	IBase->AYOffset = IBase->DefaultMousePointer->mpt_YOffset;
    }

    UNLOCKVIEW();

    /* Change and move the sprite to the right place */
    updateMousePointer( newSprite );

    if ( IBase->CustomExtSprite )
    {
#if WAITTOF_OPTIMIZE
    /* Up until 3.00, we used to do a WaitTOF() here, then call
     * FreeSpriteData() on IBase->CustomExtSprite.  However, we take
     * an optimization that depends on GfxBase maintaining a VBlank
     * counter.  the idea is that in place of WaitTOF()/FreeXXX(), we send
     * ourselves a token (reminder) to FreeXXX after the VBlank counter has
     * had a chance to change, thus taking a WaitTOF() clean out of
     * setMousePointer().
     */
    sendISMNoQuick( itFREESPRITEDATA, IBase->CustomExtSprite, 0,
	IBase->GfxBase->VBCounter );
#else
	/* If there was a custom ExtSprite in use, free it after
	 * waiting for it to no longer be in use:
	 */
	WaitTOF();
	FreeSpriteData( IBase->CustomExtSprite );
#endif
    }
    /* Remember the CustomExtSprite (if any) we're currently using: */
    IBase->CustomExtSprite = newCustomExtSprite;
    UNLOCKIBASE();

    return( success );
}



/*** updateMousePointer() ***
 *
 * Figure out where to move the sprite, and in whose ViewPort. 
 * Then actually call MoveSprite().  If the newSprite parameter is
 * non-NULL, then we also do ChangeExtSprite() to the newSprite.
 *
 * NOTE on the interaction between updateMousePointer() and RethinkDisplay():
 *
 * updateMousePointer() may discover that to change the sprite pixel-speed
 * requires calling RethinkDisplay().  This will rebuild the affected
 * viewports and then the copper lists.  Conversely, certain changes
 * (eg. promotion on/off) may require that ChangeExtSprite() be called
 * (in particular, to change the setting of sprite-scan-doubling).
 * Thus, routines in view.c call updateMousePointer( IBase->SimpleSprite ).
 * We pass IBase->SimpleSprite back to uMP() so that it rethinks the
 * sprite.  Note that VideoControl() (hence setSpriteSpeed()) will never
 * return rethink=TRUE if the sprite resolution is unchanged.
 *
 * ZZZ: Before I rewrote all this, the matching routine used to
 * live in mouse.c.  Jimm had a weird locking order where he did:
 *
 *	LOCKIBASE()
 *	LOCKVIEW()
 *	UNLOCKIBASE()	<-- Note VIEWLOCK still held!
 *	ChangeSprite()
 *	MoveSprite()
 *	UNLOCKVIEW()
 *
 * Things have gotten harder, so I now have to hold the IBase lock
 * across the calls to ChangeSprite() and MoveSprite().
 *
 */

updateMousePointer( newSprite )
struct ExtSprite *newSprite;
{
    struct Screen *s;
    struct Screen *mouse_screen = NULL;
    struct Window *w;
    struct Screen *prevscreen = NULL;

    struct IntuitionBase *IBase = fetchIBase();

    DUPM( printf( "rm: in %ld,%ld\n", IBase->LongMouse.LX,
	IBase->LongMouse.LY ) );
    limitLongPoint( &IBase->LongMouse, &IBase->MouseLimits );
    DUPM( printf( "rm: after limit %ld,%ld\n", IBase->LongMouse.LX,
	IBase->LongMouse.LY ) );

    LOCKIBASE();

    /* maintain the old MouseX/Y	*/
    /* too bad, eh?	*/
    IBase->MouseY = IBase->LongMouse.LY / IBase->MouseScaleY;
    IBase->MouseX = IBase->LongMouse.LX / IBase->MouseScaleX;

    ICOLOR( CKCOLOR8 );

    for ( s = IBase->FirstScreen; s; s = s->NextScreen )
    {
	screenMouse( s );

	/* keep track of first visible screen higher than mouse pos */

	/* Only consider visible screens */
	if ( !TESTFLAG(s->ViewPort.Modes, VP_HIDE ) )
	{
	    if ( !prevscreen )
	    {
		/* In the event that the mouse is below the first visible
		 * screen, that's the screen that the mouse must be in
		 */
		prevscreen = s;
	    }

	    if ( s->MouseY >= 0 )
	    {
		/* Peter 4-Dec-90:  The mouse_screen will be the screen that
		 * contains the mouse hotspot.  In the event that the hotspot
		 * is located in the interscreen gap, we use the previous
		 * screen.
		 */
		if ( !mouse_screen )
		{
		    DUPM2( printf("s->MouseY: %ld, s->ViewPort.DHeight %ld\n",
			s->MouseY, s->ViewPort.DHeight) );
		    DUPM2( printf("IBase->AYOffset * XSC(s)->SpriteFactor.Y / SPRITEMULT_Y %ld\n",
			( IBase->AYOffset * XSC(s)->SpriteFactor.Y ) / SPRITEMULT_Y ) );
		    if ( ( s->MouseY - s->ViewPort.DHeight ) >
			    -( ( IBase->AYOffset * XSC(s)->SpriteFactor.Y ) / SPRITEMULT_Y ) )
		    {
			/* Hot spot is below this screen and so is the pointer's
			 * top line, so we must use the previous visible screen
			 */
			DUPM2( printf("Mouse in previous screen %lx\n", prevscreen) );
			mouse_screen = prevscreen;
		    }
		    else
		    {
			/* Hot spot is in this screen, or if it's below, then
			 * at least the top line of pointer-data is in.
			 */
			DUPM2( printf("Mouse in this screen %lx\n", s) );
			mouse_screen = s;
		    }
		}
	    }
	    prevscreen = s;
	}

	for ( w = s->FirstWindow; w; w = w->NextWindow ) windowMouse( w );
    }

    if ( !mouse_screen )
    {
	/* When dragging a rear screen behind a front screen, the rear
	 * screen's ViewPort can end up hidden even when the mouse's
	 * y is above the front screen.  In that case, we really want
	 * the mouse's screen to be the topmost one we saw.
	 */
	mouse_screen = prevscreen;
    }
    ICOLOR( CKCOLOR9 );

    /* figure out where to put the pointer sprite	*/

    LOCKVIEW();	
    /* jimm: ZZZ: trying to synchronize changes to
     * view mode in MakeScreen with copper list changes 
     */

    DUPM( printf("mouse_screen: %lx, newSprite: %lx\n", mouse_screen, newSprite ) );
    ICOLOR( CKCOLOR10 );

    /* If mouse_screen is NULL, we must still be sure to call ChangeExtSprite()
     * on the NULL ViewPort, or else the initial sprite isn't set up right
     * in the case of a pre-DOS game which opens a screen but no window.
     */
    {
	struct Point  spritepos;
	struct ViewPort *mousevp = NULL;
	ULONG specialspritekill = IBase->SpecialSpriteKill;

	if ( mouse_screen )
	{
	    mousevp = &mouse_screen->ViewPort;
	}

	if ( newSprite )
	{
	    struct Screen *sc;

	    DUPMC( printf( "About to setSpriteHeight\n") );

	    setSpriteHeight();

	    /* Some callers call us with newSprite == IBase->SimpleSprite,
	     * which is just to force us to rethink things.  If newSprite
	     * is some other value, then blank the sucker around size/shape
	     * changes.
	     */
	    if ( newSprite != IBase->SimpleSprite )
	    {
		if ( !specialspritekill )
		{
		    ChangeExtSpriteA( mousevp, IBase->SimpleSprite, IBase->BlankSprite,
			NULL );
		}
		IBase->SimpleSprite = IBase->BlankSprite;
	    }
	    /* Sprite speed needs to be set for each ViewPort. */
	    for ( sc = IBase->FirstScreen; sc; sc = sc->NextScreen )
	    {
		setSpriteSpeed( sc );
	    }
	}

	/* We need to figure out the sprite's new position, regardless
	 * of whether we have a newSprite or not.  However, the SpriteFactors
	 * depend on the results of setSpriteSpeed(), so we have to evaluate
	 * the spritepos after setSpriteSpeed().  We need the sprite position
	 * before we change to the new sprite.  Thus, we have to leave the
	 * conditional temporarily.
	 *
	 * SpriteFactor.X is four times bigger than reality, since
	 * V39 needs to be able to scale up and down, too.
	 *
	 * SpriteFactor.Y is two times bigger than reality, for the
	 * same reason.
	 */
	spritepos.X = spritepos.Y = 0;
	if ( mouse_screen )
	{
	    spritepos.X = ( ( IBase->AXOffset * XSC(mouse_screen)->SpriteFactor.X ) /
		SPRITEMULT_X ) + mouse_screen->MouseX;
	    spritepos.Y = ( ( IBase->AYOffset * XSC(mouse_screen)->SpriteFactor.Y ) /
		SPRITEMULT_Y ) + mouse_screen->MouseY;
	}

	if ( newSprite )
	{
	    newSprite->es_SimpleSprite.x = spritepos.X;
	    newSprite->es_SimpleSprite.y = spritepos.Y;

	    DUPMC( printf( "ChangeExtSpriteA( from old %lx[%lx] to new %lx )\n",
		IBase->SimpleSprite, IBase->SimpleSprite->num, newSprite ) );
	    DUPMC( printf( "  posctldata %lx, height %lx, x/y %lx/%lx, num %lx, ww %lx ydouble %lx\n",
		newSprite->es_SimpleSprite.posctldata,
		newSprite->es_SimpleSprite.height,
		newSprite->es_SimpleSprite.x,
		newSprite->es_SimpleSprite.y,
		newSprite->es_SimpleSprite.num,
		newSprite->es_wordwidth,
		TESTFLAG( IBase->Flags, POINTER_YDOUBLE ) ) );
	    /* ZZZ: We could "legitimately" fail here if some nasty app
	     * did a FreeSprite(0), because that would clear the SoftSprite
	     * bit.  So we should try to handle failure by ? staying out
	     * of the sprite game?
	     */
	    if ( !specialspritekill )
	    {
		ChangeExtSprite( mousevp, IBase->SimpleSprite, newSprite,
		    GSTAG_SCANDOUBLED, TESTFLAG( IBase->Flags, POINTER_YDOUBLE ),
		    TAG_DONE );
	    }

	    DUPMC( printf( "Done ChangeExtSpriteA\n") );
	    IBase->TetrisSprite = IBase->SimpleSprite = newSprite;
	}

	if ( mouse_screen )
	{
	    DDF( if ( IBase->DebugFlag & IDF_SPRITE ) {
		printf("movesprite to: %ld, %ld\n", spritepos.X,spritepos.Y );
		printf("mouse screen: %lx\n", mouse_screen ); });
	    DUPM( printf("rM: spritepos.X = %ld, IBase->LongMouse.X: %ld\n",
		spritepos.X, IBase->LongMouse.LX ) );

	    D( printf( "MoveSprite of IBase->SS %lx\n", IBase->SimpleSprite ) );
	    if ( !specialspritekill )
	    {
		/* Because of specialspritekill, we run the risk that
		 * we get to MoveSprite() a sprite that was never installed
		 * with ChangeExtSprite().  Forcing its ss_num to zero
		 * cures any resulting issues.
		 */
		IBase->SimpleSprite->num = 0;
		MoveSprite( mousevp, IBase->SimpleSprite, spritepos.X, spritepos.Y );
	    }
	}
    }

    UNLOCKVIEW();
    UNLOCKIBASE();
}


/*** calcSpriteWidth() ***
 *
 * Based on the desired sprite width, and the state of GfxBase,
 * figure out what the sprite width should be.
 *
 * Returns 1, 2, or 4.
 */

calcSpriteWidth( width )
LONG width;
{
    /* Forbid() to get an atomic peek at GfxBase.  Now, if the sprites
     * in use (SpriteReserved) are not just the soft-sprites (i.e. ours),
     * then we have to use the width currently in effect.
     * If not, we can use the correct one.
     */
    struct GfxBase *GfxBase = fetchIBase()->GfxBase;

    /* Don't let the sprite width exceed what is currently allowed,
     * based on hardware restrictions and software restrictions
     * (eg. pre-enlighten or BootMenu display options).
     */
    width = imin( width, 1 << ( NUMPOINTERS( GfxBase->MemType ) - 1 ) );
    Forbid();
    if ( GfxBase->SoftSprites != GfxBase->SpriteReserved )
    {
	/* This will be 1, 2, or 4 */
	width = GfxBase->SpriteWidth;
    }
    Permit();
    return( width );
}


/*** notePointerKill() ***
 *
 * When graphics kills our pointer, it calls us with our data-pointer
 * (IntuitionBase) in A1.  We have a little assembler stub that
 * calls this routine.  The routine is in C since IBase is only
 * defined in the C-header, not the asm-header.
 *
 * We're called inside Forbid().
 *
 */

notePointerKill( passedIBase )
struct IntuitionBase *passedIBase;
{
    DKILL( printf("Pointer killed\n") );
    passedIBase->PointerKilled = 1;
}

/*** reinstatePointer() ***
 *
 * If our pointer becomes incompatible with other sprites on the
 * screen, graphics.library will blank our pointer and call us.
 * The notePointerKill() function is a very simple one that
 * notes the fact down.  Later, when we wake up, we get the
 * chance to come in and restore things via this function.
 *
 */

reinstatePointer()
{
    struct IntuitionBase *IBase = fetchIBase();

    if ( IBase->PointerKilled )
    {
	DKILL( printf("Reinstating pointer\n") );
	IBase->PointerKilled = 0;
	setMousePointer();
    }
}

/*** setSpriteSpeed ***
 *
 * For a given screen, and a desired resolution (one of the POINTERXRESN_
 * flags from intuition.h), calculate and set the sprite resolution.
 *
 * The result depends on:
 * - Pointer POINTERXRESN_ flags
 * - Ability to change sprite res on this screen
 * - Scan rate of this screen
 * - IBase->Flags POINTER_XDOUBLE (set/cleared by setSpriteHeight()
 *   in order to preserve aspect)
 *
 * Also sets up the screen's SpriteFactor.X and SpriteFactor.Y values!
 *
 * This routine should be called for each screen inside rethinkVPorts(),
 * and inside setMousePointer().
 *
 * Officially, we're supposed to MakeScreen/RethinkDisplay if rethink
 * comes back non-zero from VideoControl().  However, we risk infinite
 * recursion if we do, since RethinkDisplay() can call updateMousePointer().
 * Chris Green assures me that there should be no problem, and in all
 * normal cases, rethink will come back zero.  Guess who's the abnormal
 * case?  DPaint 4.1.  They steal their screen's ColorMap and stick it
 * into their own custom view during animation.  So it's a good idea
 * to ignore rethink.
 */

#define PIXEL_XRESOLUTION_LORES	44	/* 44 ticks per lores pixel */
#define PIXEL_XRESOLUTION_HIRES	22	/* 22 ticks per hires pixel */

UWORD SpriteFactorTable[] =
{
    140 * SPRITEMULT_X,	/* res = 1 is 140 ns */
     70 * SPRITEMULT_X,	/* res = 2 is 70 ns */
     35 * SPRITEMULT_X,	/* res = 3 is 35 ns */
};

setSpriteSpeed( sc )
struct Screen *sc;
{
    struct IntuitionBase *IBase = fetchIBase();
    LONG desired_res = IBase->PointerXRes;
    LONG res = desired_res;
    LONG rethink = 0;
    LONG changable;

    /* The ViewPort might not support changable sprite resolutions */
    changable = TESTFLAG( XSC(sc)->DProperties, DIPF_IS_SPRITES_CHNG_RES );

    /* If any old-style sprites (non-ExtSprites) are in use, we must not
     * change the VTAG_DEFSPRITERESN.  Users of ExtSprites can rely on
     * Intuition's choice, or use VTAG_SPRITERESN to control the sprite
     * resolution (this VTAG overrides the VTAG_DEFSPRITERESN we set).
     */
    Forbid();
    if ( IBase->GfxBase->ExtSprites != IBase->GfxBase->SpriteReserved )
    {
	changable = 0;
    }
    Permit();

    if ( !changable )
    {
	/* No can change sprite resolution! */
	res = SPRITERESN_ECS;
    }
    /* We've chosen POINTERXRESN_DEFAULT, POINTERXRESN_140NS, POINTERXRESN_70NS,
     * and POINTERXRESN_35NS to match numerically the gfx SPRITERESN_ defines,
     * so we have no work for those choices.
     */
    else if ( desired_res >= POINTERXRESN_SCREENRES )
    {
	LONG pointer_resolution;

	DSS( printf( "sSS: Screen %lx, pixel speed %ld, resolution.x %ld\n",
	    sc, XSC(sc)->PixelSpeed, XSC(sc)->ScaleFactor.X ) );
	/* Default here is for POINTERXRESN_SCREENRES, we want the
	 * pointer's resolution to match the mode's:
	 */
	pointer_resolution = XSC(sc)->ScaleFactor.X;
	if ( desired_res == POINTERXRESN_LORES )
	{
	    /* Want the pointer_resolution to match a regular
	     * lores pixel
	     */
	    pointer_resolution = PIXEL_XRESOLUTION_LORES;
	}
	else if ( desired_res == POINTERXRESN_HIRES )
	{
	    /* Want the pointer_resolution to match a regular
	     * hires pixel
	     */
	    pointer_resolution = PIXEL_XRESOLUTION_HIRES;
	}
	DSS( printf( "sSS: desired_res %ld, pointer_resolution %ld\n",
	    desired_res, pointer_resolution ) );

	{
	    /* Calculate what the target_pixelspeed should be.  The
	     * valid values are 35, 70, and 140 ns.  But target_pixelspeed
	     * may not be exactly one of these values, so find the nearest.
	     */
	    LONG target_pixelspeed;
	    LONG delta;
	    LONG delta2;

	    target_pixelspeed = ( XSC(sc)->PixelSpeed * pointer_resolution ) /
		XSC(sc)->ScaleFactor.X;
	    /* Because of scaling restrictions in the y-direction,
	     * we may have been forced to double the scaling in
	     * the x-direction to preserve aspect...
	     */
	    if ( TESTFLAG( IBase->Flags, POINTER_XDOUBLE ) )
	    {
		DSS( printf( "sSS: pointer is to be xdoubled\n"));
		target_pixelspeed *= 2;
	    }

	    DSS( printf( "sSS: Target target_pixelspeed %ld\n",
		target_pixelspeed ) );

	    res = SPRITERESN_35NS;
	    delta = iabs( target_pixelspeed - 35 );
	    delta2 = iabs( target_pixelspeed - 70 );
	    if ( delta2 < delta )
	    {
		delta = delta2;
		res = SPRITERESN_70NS;
	    }
	    delta2 = iabs( target_pixelspeed - 140 );
	    if ( delta2 < delta )
	    {
		res = SPRITERESN_140NS;
	    }
	}
    }
    DSS( printf( "sSS: Setting screen %lx sprite resn to %ld\n", sc, res ) );
    /* We set the default sprite resolution for the ViewPort,
     * which allows applications to override:
     */
    VideoControlTags( XSC(sc)->ColorMap,
	VTAG_DEFSPRITERESN_SET, res,
	VTAG_IMMEDIATE, &rethink,
	TAG_DONE );

    /* ZZZ: This code is correct for the default sprite resolution only.
     * If someone overrides, then this is not right.  I need to enquire
     * what the real resolution is.
     */
    if ( res == SPRITERESN_ECS )
    {
	XSC(sc)->SpriteFactor.X = ( XSC(sc)->SpriteRes.X * SPRITEMULT_X ) /
	    XSC(sc)->ScaleFactor.X;
    }
    else
    {
	XSC(sc)->SpriteFactor.X = SpriteFactorTable[ res-1 ] / XSC(sc)->PixelSpeed;
    }
    XSC(sc)->SpriteFactor.Y = ( XSC(sc)->SpriteRes.Y * SPRITEMULT_Y ) /
	XSC(sc)->ScaleFactor.Y;
    if ( TESTFLAG( IBase->Flags, POINTER_YDOUBLE ) )
    {
	XSC(sc)->SpriteFactor.Y <<= 1;
    }
}

/* Routine to figure out whether sprite scan-doubling should be
 * turned on for this sprite.
 *
 * Depends on:
 * - Pointer POINTERYRESN_ flags
 * - Ability to scan-double on this display
 * - Vertical resolution of screen and pointer
 *
 * Sets POINTER_YDOUBLE flag if it would be desirable and possible
 * to scan-double the pointer.
 * Sets POINTER_XDOUBLE flag if it would be desirable to preserve aspect
 * by horizontal doubling on the pointer.
 */

/* These are the ticks-per-pixel of a pointer designed to be about
 * 200 lines-per-screen and 400 lines-per-screen.  I use the
 * PAL ticks because the comparison for doubling in X assumes that
 * actualres >= targetres, which wouldn't be true on PAL systems
 * if we used the NTSC numbers.  So we use the smaller numbers
 * here.
 */
#define PIXEL_YRESOLUTION_200	44
#define PIXEL_YRESOLUTION_400	22

/* All aspect-preserving choices are odd-numbered: */
#define POINTERYRESNFLAG_ASPECT	1

setSpriteHeight()
{
    LONG actualres, targetres;
    LONG aspect;
    LONG delta;

    struct IntuitionBase *IBase = fetchIBase();
    struct Screen *ascreen = IBase->ActiveScreen;

    assertLock( "setSpriteHeight", IBASELOCK );

    actualres = PIXEL_YRESOLUTION_200;
    if ( ascreen )
    {
	actualres = XSC(ascreen)->SpriteRes.Y;
    }

    CLEARFLAG( IBase->Flags, POINTER_XDOUBLE|POINTER_YDOUBLE );

    DSH( printf("sSH: PointerYRes is %ld\n", IBase->PointerYRes ));
    switch ( IBase->PointerYRes )
    {
    case POINTERYRESN_DEFAULT:
	targetres = PIXEL_YRESOLUTION_200;
	break;

    case POINTERYRESN_HIGH:
    case POINTERYRESN_HIGHASPECT:
	targetres = PIXEL_YRESOLUTION_400;
	break;

    case POINTERYRESN_SCREENRES:
    case POINTERYRESN_SCREENRESASPECT:
	targetres = PIXEL_YRESOLUTION_200;
	if ( ascreen )
	{
	    targetres = XSC(ascreen)->ScaleFactor.Y;
	}
	break;
    }

    aspect = TESTFLAG( IBase->PointerYRes, POINTERYRESNFLAG_ASPECT );

    DSH( printf("sSH: actualres %ld, targetres %ld, aspect %ld\n", actualres,
	targetres, aspect ) );
    delta = iabs( targetres - actualres );

    if ( ( IBase->ActiveMonitorSpec ) && 
	TESTFLAG( IBase->ActiveMonitorSpec->ms_Flags, MSF_DOUBLE_SPRITES ) &&
	( delta > iabs( targetres - 2*actualres ) ) )
    {
	SETFLAG( IBase->Flags, POINTER_YDOUBLE );
	actualres *= 2;
	DSH( printf("sSH: vertical doubling on\n"));
    }

    /* If we can improve the pointer aspect ratio by doubling
     * it in the x-direction (via hardware), then do it,
     * and note the fact:
     */
    if ( ( actualres >= 2*targetres ) && ( aspect ) )
    {
	SETFLAG( IBase->Flags, POINTER_XDOUBLE );
	DSH( printf(" sSH: To preserve aspect, horizontal doubling on\n"));
    }
}

/*** MakeSpriteData() ***
 *
 * Take a MousePointer structure, a word-width, and a scaling factor,
 * and return a pointer to an ExtSprite allocated from that.
 * To free, just call plain graphics FreeSpriteData().
 */

struct ExtSprite *
MakeSpriteData( mpointer, word_width, scale )
struct MousePointer *mpointer;
ULONG word_width;
LONG scale;
{
    ULONG olddata_tag = TAG_IGNORE;
    ULONG height_tag = TAG_IGNORE;

    struct ExtSprite *AllocSpriteData();

    DAS( printf("MakeSpriteData: mpointer at %lx\n", mpointer ) );

    /* We never scale a sprite bigger, since we'd rather just leave
     * blank pixels.
     */
    if ( scale >= 0 )
    {
	scale = 0;
    }

    DAS( printf("Assuming New Sprite, bitmap at %lx\n", mpointer->mpt_BitMap ) );

    /* If mpt_Width is not MPT_CUSTOMWIDTH, then we have old-style
     * sprite data.
     */
    if ( mpointer->mpt_Width != MPT_CUSTOMWIDTH )
    {
	DAS( printf("Old SpriteData at %lx, height %ld\n",
	    mpointer->mpt_BitMap, mpointer->mpt_Height ) );
	olddata_tag = SPRITEA_OldDataFormat;
	height_tag = SPRITEA_OutputHeight;
    }
    return( AllocSpriteData( mpointer->mpt_BitMap,
	SPRITEA_Width, 16*word_width,
	SPRITEA_XReplication, scale,
	height_tag, mpointer->mpt_Height,
	olddata_tag, TRUE,
	TAG_DONE ) );
}

/*** intuition.library/SetWindowPointerA ***/

/* New version of SetPointer().  Recognizes the following tags:
 * WA_Pointer - custom pointer from pointerclass
 * WA_BusyPointer,TRUE - standard busy pointer
 * WA_PointerDelay,TRUE - delay a bit before posting (busy) pointer
 */
LIB_SetWindowPointerA( win, taglist )
struct Window *win;
struct TagItem *taglist;
{
    struct MousePointer *mpointer;

    /* To protect the DeferredPointer fields */
    LOCKIBASE();

    /* NULL means the default pointer, but override with his
     * selection
     */
    mpointer = (struct MousePointer *)GetUserTagData0( WA_Pointer, taglist );
    /* If caller asked for the busy pointer, we pull that out
     * of IBase:
     */
    if ( GetUserTagData0( WA_BusyPointer, taglist ) )
    {
	/* We use a special numeric value to denote the
	 * busy-pointer, because we want to grab IBase->BusyPointer
	 * in a state-synchronous way (inside ISetWindowPointer).
	 */
	mpointer = BUSYPOINTER;
    }

    /* We support pointer-delay, which is really only useful for
     * the busy pointer.  The idea here is that you can do a deferred
     * NewSetPointer() call, which will take effect in a few timer ticks
     * if you haven't restored some other pointer first.  This allows
     * you to fearlessly set the busy pointer even if there's a chance
     * you'll only be busy for an instant.
     */

    if ( GetUserTagData0( WA_PointerDelay, taglist ) )
    {
	XWINDOW(win)->DeferredPointer = mpointer;
	XWINDOW(win)->DeferredCounter = DEFERREDPOINTERCOUNT;
	SETFLAG( win->MoreFlags, WMF_DEFERREDPOINTER );
	UNLOCKIBASE();
    }
    else
    {
	UNLOCKIBASE();
	/* Change the pointer. */
	doISM( itSETPOINTER, win, mpointer );
    }
}


/*** intuition.library/SetPointer ***/
/*** intuition.library/ClearPointer ***/

/* In intuitionface.asm, ClearPointer(win) just calls
 * SetPointer( win, NULL, 0, 0, 0, 0 )
 */
SetPointer(win, pointer, height, width, xoffset, yoffset)
struct Window *win;
USHORT *pointer;
int height, width, xoffset, yoffset;
{
    struct OldMousePointer *mpointer = NULL;

    DSP( printf("SetPointer window %lx, pointer %lx, height %ld\n", win, pointer, height));

    /* SetPointer() used to have very simple locking.  Some versions
     * of ProWrite (eg. 3.2.3) and other New Horizons software end up
     * calling SetPointer() inside Begin/EndUpdate().  With the new
     * locking we added around SetPointer(), there is now a real chance
     * of deadlock.  To avoid this, we short-circuit SetPointer()
     * if the LAYERUPDATING flag is set.  Note that ProWrite uses
     * Begin/EndUpdate() directly, so we can't check the WINDOWREFRESH
     * flag.
     */
    if ( !TESTFLAG( win->WLayer->Flags, LAYERUPDATING ) )
    {
	/* We want to pass pointer=NULL for itSETPOINTER if the pointer
	 * parameter is NULL, such as it would be from ClearPointer().
	 * Otherwise, we pass an allocated OldMousePointer.  ISetWindowPointer()
	 * knows to copy old-style pointers into the window field and
	 * free the OldMousePointer.
	 *
	 * The reason we don't make mpointer a local variable is because some
	 * mouse-blankers (eg. CygnusEd, DMouse?) call SetPointer() from an
	 * input handler.  To fix them, we made doISM() convert to sendISM(),
	 * so the local variable wouldn't persist long enough.
	 */

	if ( pointer )
	{
	    /* If the allocation fails, we'd better do an effective
	     * ClearPointer(), which will result anyways since mpointer is NULL.
	     */
	    mpointer = (struct OldMousePointer *)
		AllocVec( sizeof( struct OldMousePointer ), MEMF_PUBLIC );
	}

	/* Make an old MousePointer structure out of the passed-in data.
	 * ISetWindowPointer() will copy that into 
	 */
	if ( mpointer )
	{
	    mpointer->mpt_BitMap = (struct BitMap *)pointer;
	    mpointer->mpt_Height = height;
	    mpointer->mpt_Width = width;
	    mpointer->mpt_XOffset = xoffset;
	    mpointer->mpt_YOffset = yoffset;
	}

	/* Change the pointer */
	doISM( itSETPOINTER, win, mpointer );

	DSP( printf("done.\n"));
    }
}


/**********************************************
 *                                            *
 * "pointerclass" - boopsi sprite image class *
 *                                            *
 **********************************************/

ULONG pointerPackTable[] =
{
    PACK_STARTTABLE( POINTERA_Dummy ),
    PACK_ENTRY( POINTERA_Dummy, POINTERA_BitMap, MousePointer, mpt_BitMap, PKCTRL_ULONG ),
    PACK_ENTRY( POINTERA_Dummy, POINTERA_XOffset, MousePointer, mpt_XOffset, PKCTRL_BYTE ),
    PACK_ENTRY( POINTERA_Dummy, POINTERA_YOffset, MousePointer, mpt_YOffset, PKCTRL_BYTE ),
    PACK_ENTRY( POINTERA_Dummy, POINTERA_WordWidth, MousePointer, xmpt_WordWidth, PKCTRL_WORD ),
    PACK_ENTRY( POINTERA_Dummy, POINTERA_XResolution, MousePointer, xmpt_PointerXRes, PKCTRL_WORD ),
    PACK_ENTRY( POINTERA_Dummy, POINTERA_YResolution, MousePointer, xmpt_PointerYRes, PKCTRL_WORD ),
    PACK_ENDTABLE,    
};

/* Since setPointerClassAttrs() is nothing more than a call to PackStructureTags(),
 * it's smaller to take it in-line.  It's clearer to leave it as a macro.
 */
#define setPointerClassAttrs( cl, o, msg ) \
	PackStructureTags( INST_DATA( cl, o ), pointerPackTable, \
	((struct opSet *)msg)->ops_AttrList )


/*** dispatchPointerClass ***
 *
 * Boopsi dispatcher for pointerclass.  All MousePointers that go
 * through pointerclass are full-sized, hence it's legal to access
 * the xmpt_ fields.
 *
 */

#define MPT(o) ((struct MousePointer *)(o))

ULONG
dispatchPointerClass( cl, o, msg )
Class *cl;
Object *o;
Msg msg;
{
    Object *newobj;

    DPC( printf( "dispatchPointerClass: class %lx, object %lx, msg %lx\n", cl,o,msg ) );

    switch ( msg->MethodID )
    {
    case OM_NEW:
	if ( newobj = (Object *) SSM( cl, o, msg ) )
	{
	    /* Reasonable defaults:
	     * Height of 16 is required for SetPrefs() of the old
	     *   pointer to work.
	     * Width of MPT_CUSTOMWIDTH indicates a full boopsi pointer
	     * WordWidth of 1 is a reasonable default.
	     */
	    MPT(newobj)->mpt_Height = 16;
	    MPT(newobj)->mpt_Width = MPT_CUSTOMWIDTH;
	    MPT(newobj)->xmpt_WordWidth = 1;

	    setPointerClassAttrs( cl, newobj, msg );
	    /* WordWidth of -1 means pretend we're an old-style pointer.
	     * This is used to support the initial SetPrefs().  Note
	     * that the pointer data needs to be put into chip RAM!
	     */
	    if ( MPT(newobj)->xmpt_WordWidth == -1 )
	    {
		APTR pointercopy;

		if ( pointercopy = (APTR) AllocVec( (16+2)*4, MEMF_CHIP|MEMF_PUBLIC ) )
		{
		    CopyMem( MPT(newobj)->mpt_BitMap, pointercopy, (16+2)*4 );
		    MPT(newobj)->mpt_BitMap = pointercopy;
		    MPT(newobj)->mpt_Width = 16;
		    MPT(newobj)->xmpt_WordWidth = 1;
		}
		else
		{
		    DisposeObject( newobj );
		    newobj = NULL;
		}
	    }		
	}
	return ( (ULONG) newobj );

    case OM_SET:
	SSM( cl, o, msg );
	setPointerClassAttrs( cl, o, msg );
	return( 1 );

    case OM_DISPOSE:
	/* If this pointer has a width of 16, that denotes an old-style
	 * pointer that came from SetPrefs().  We have to free the
	 * chip RAM copy.
	 */
	if ( MPT(o)->mpt_Width == 16 )
	{
	    FreeVec( MPT(o)->mpt_BitMap );
	}
	/* FALL THROUGH! */
    default:
	return( SSM( cl, o, msg ) );
    }
}

/*** initPointerClass() ***
 *
 * Set up pointerclass.
 *
 */

Class	*
initPointerClass()
{
    ULONG dispatchPointerClass();
    Class	*makePublicClass();
    extern UBYTE	*PointerClassName;
    extern UBYTE	*RootClassName;

    DPC( printf("initPointerClass\n") );
    return ( makePublicClass( PointerClassName, RootClassName,
		sizeof( struct MousePointer ), dispatchPointerClass ) );
}
@


39.30
log
@Now clears ss_num before MoveSprite().
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.29 93/04/15 00:57:55 peter Exp Locker: peter $
d993 1
a993 1
			TAG_DONE );
@


39.29
log
@If private SpecialSpriteKill field is set, Intuition won't move or
change the sprite.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.28 93/01/12 16:19:35 peter Exp Locker: peter $
d1068 6
@


39.28
log
@IBase->MouseScaleX replaces MOUSESCALEX.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.27 93/01/08 14:47:55 peter Exp Locker: peter $
d968 1
d990 5
a994 2
		ChangeExtSpriteA( mousevp, IBase->SimpleSprite, IBase->BlankSprite,
		    TAG_DONE );
d1046 6
a1051 3
	    ChangeExtSprite( mousevp, IBase->SimpleSprite, newSprite,
		GSTAG_SCANDOUBLED, TESTFLAG( IBase->Flags, POINTER_YDOUBLE ),
		TAG_DONE );
d1066 4
a1069 1
	    MoveSprite( mousevp, IBase->SimpleSprite, spritepos.X, spritepos.Y );
@


39.27
log
@Now have sprite resolution compatibility fallback.  Minor optimization
by caching IBase->GfxBase.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.26 92/11/10 17:08:43 peter Exp Locker: peter $
d881 1
a881 1
    IBase->MouseX = IBase->LongMouse.LX / MOUSESCALEX;
@


39.26
log
@If a pre-DOS app opens a screen but no window, it once again has a
pointer image.  Added (compiled-out) code to implement VBlank
optimization.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.25 92/08/28 13:05:24 peter Exp Locker: peter $
d1084 1
a1084 1
    struct IntuitionBase *IBase = fetchIBase();
d1090 1
a1090 1
    width = imin( width, 1 << ( NUMPOINTERS( IBase->GfxBase->MemType ) - 1 ) );
d1092 1
a1092 1
    if ( IBase->GfxBase->SoftSprites != IBase->GfxBase->SpriteReserved )
d1095 1
a1095 1
	width = IBase->GfxBase->SpriteWidth;
d1186 16
d1203 1
a1203 1
    if ( !TESTFLAG( XSC(sc)->DProperties, DIPF_IS_SPRITES_CHNG_RES ) )
@


39.25
log
@Added kludge so that SetPointer() inside BeginUpdate() is harmless.
This fixes ProWrite.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.24 92/08/18 13:46:24 peter Exp Locker: peter $
d13 7
d799 12
d816 1
a864 1
    struct ViewPort	*mousevp = NULL;
d961 4
a964 1
    if ( mouse_screen )
d967 6
a972 2
	LONG ydouble;
	mousevp = &mouse_screen->ViewPort;
d980 1
a980 1
	    ydouble = setSpriteHeight();
d1013 8
a1020 4
	spritepos.X = ( ( IBase->AXOffset * XSC(mouse_screen)->SpriteFactor.X ) /
	    SPRITEMULT_X ) + mouse_screen->MouseX;
	spritepos.Y = ( ( IBase->AYOffset * XSC(mouse_screen)->SpriteFactor.Y ) /
	    SPRITEMULT_Y ) + mouse_screen->MouseY;
d1036 1
a1036 1
		ydouble ) );
d1043 1
a1043 1
		GSTAG_SCANDOUBLED, ydouble,
d1050 11
a1060 8
	DDF( if ( IBase->DebugFlag & IDF_SPRITE ) {
	    printf("movesprite to: %ld, %ld\n", spritepos.X,spritepos.Y );
	    printf("mouse screen: %lx\n", mouse_screen ); });
	DUPM( printf("rM: spritepos.X = %ld, IBase->LongMouse.X: %ld\n",
	    spritepos.X, IBase->LongMouse.LX ) );

	D( printf( "MoveSprite of IBase->SS %lx\n", IBase->SimpleSprite ) );
	MoveSprite( mousevp, IBase->SimpleSprite, spritepos.X, spritepos.Y );
a1061 1
    DUPM( else printf("no mouse_screen\n") );
d1300 2
a1318 1
LONG
a1320 1
    LONG ydouble = FALSE;
a1369 1
	ydouble = TRUE;
a1383 1
    return( ydouble );
@


39.24
log
@updateMousePointer no longer can call RethinkDisplay().  This is to avoid
deadly recursion.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.23 92/08/18 10:13:08 peter Exp Locker: peter $
d1475 43
a1517 32
    /* We want to pass pointer=NULL for itSETPOINTER if the pointer
     * parameter is NULL, such as it would be from ClearPointer().
     * Otherwise, we pass an allocated OldMousePointer.  ISetWindowPointer()
     * knows to copy old-style pointers into the window field and
     * free the OldMousePointer.
     *
     * The reason we don't make mpointer a local variable is because some
     * mouse-blankers (eg. CygnusEd, DMouse?) call SetPointer() from an
     * input handler.  To fix them, we made doISM() convert to sendISM(),
     * so the local variable wouldn't persist long enough.
     */

    if ( pointer )
    {
	/* If the allocation fails, we'd better do an effective
	 * ClearPointer(), which will result anyways since mpointer is NULL.
	 */
	mpointer = (struct OldMousePointer *)
	    AllocVec( sizeof( struct OldMousePointer ), MEMF_PUBLIC );
    }

    /* Make an old MousePointer structure out of the passed-in data.
     * ISetWindowPointer() will copy that into 
     */
    if ( mpointer )
    {
	mpointer->mpt_BitMap = (struct BitMap *)pointer;
	mpointer->mpt_Height = height;
	mpointer->mpt_Width = width;
	mpointer->mpt_XOffset = xoffset;
	mpointer->mpt_YOffset = yoffset;
    }
d1519 2
a1520 2
    /* Change the pointer */
    doISM( itSETPOINTER, win, mpointer );
d1522 2
a1523 1
    DSP( printf("done.\n"));
@


39.23
log
@Fixed sprite hotspot error for old SetPointer().  Fixed pointer jumping
during screen drag (ChangeExtSprite() could receive a new vp but the
sprite had coordinates scaled to the old VP).
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.22 92/08/06 17:00:59 peter Exp Locker: peter $
a950 1
	    LONG rethink = 0;
d952 1
a952 1
	    DUPMC( printf( "About to setSpriteSpeed\n") );
a953 6
	    /* Need to hold the VIEWCPRLOCK (which also gets the GfxBase
	     * ActiViewCprSemaphore).  I need the AVCS to protect me
	     * across MakeScreen()/RethinkDisplay().
	     */
	    LOCKVIEWCPR();

d970 1
a970 11
		/* We'll need to conditionally RethinkDisplay()
		 * if VTAG_IMMEDIATE failed.
		 */
		rethink |= setSpriteSpeed( sc );
	    }
	    /* Need to rethink if setSpriteSpeed() can't change the
	     * sprite speeds immediately.
	     */
	    if ( rethink )
	    {
		RethinkDisplay();
a971 1
	    UNLOCKVIEWCPR();
d1124 11
a1134 2
 * This routine should be called for each screen inside
 * rethinkVPorts(), and inside setMousePointer().
a1257 7
    if ( rethink )
    {
	/* do a light-weight MakeScreen() */
	newMakeScreen( sc, FALSE );
    }

    return( rethink );
@


39.22
log
@Uses GetUserTagData() and GetUserTagData0().
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.21 92/08/04 09:59:18 peter Exp Locker: peter $
d697 7
d707 1
d714 1
d732 1
a732 1
	    IBase->AXOffset = custompointer->mpt_XOffset;
d771 4
d945 1
a951 1
	    LONG ydouble;
d990 19
d1010 5
a1037 11
	/* SpriteFactor.X is four times bigger than reality, since
	 * V39 needs to be able to scale up and down, too.
	 *
	 * SpriteFactor.Y is two times bigger than reality, for the
	 * same reason.
	 */
	spritepos.X = ( ( IBase->AXOffset * XSC(mouse_screen)->SpriteFactor.X ) /
	    SPRITEMULT_X ) + mouse_screen->MouseX;
	spritepos.Y = ( ( IBase->AYOffset * XSC(mouse_screen)->SpriteFactor.Y ) /
	    SPRITEMULT_Y ) + mouse_screen->MouseY;

d1059 1
@


39.21
log
@ClearPointer() now clears the window's pointer fields.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.20 92/08/03 15:55:04 peter Exp Locker: peter $
d1412 1
a1412 1
    mpointer = (struct MousePointer *)GetUserTagData( WA_Pointer, NULL, taglist );
d1416 1
a1416 1
    if ( GetUserTagData( WA_BusyPointer, FALSE, taglist ) )
d1433 1
a1433 1
    if ( GetUserTagData( WA_PointerDelay, FALSE, taglist ) )
@


39.20
log
@Fixed vertical hotspot rounding error when sprite is higher res than screen.
Changes to support syncing of pointer from SetPrefs().
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.19 92/08/02 12:43:14 peter Exp Locker: peter $
a495 2
		 * ZZZ: Is this OK inside LOCKVIEW()?  Only because we also
		 * LOCKIBASE().  Would be better off outside completely? (as before)
d593 3
a595 1
    if ( ( newMousePointer ) && ( newMousePointer != BUSYPOINTER ) &&
d597 9
d607 6
a612 5
	*(( struct OldMousePointer *)&win->Pointer ) =
	    *(( struct OldMousePointer *)newMousePointer );

	XWINDOW(win)->MousePointer = (struct MousePointer *)&win->Pointer;
	FreeVec( newMousePointer );
a613 1

@


39.19
log
@Fixed sprite hotspot scaling error.  Old-style pointers are now
POINTERXRESN_LORES instead of _DEFAULT.  Fixed timing hole in
SetPointer/ClearPointer().
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.18 92/07/28 15:14:00 peter Exp Locker: peter $
d291 1
a291 5
    setMousePointer();	/* IBase->ActiveWindow = NULL means use default pointer */

    DP( printf("Done setMousePointer\n"));


d367 4
a370 6
	/* ZZZ: This is ugly.   Old prefs come in as wordwidth = 0 */
	if ( !wordwidth )
	{
	    newmpointer->mpt_Width = 16;
	    wordwidth = 1;
	}
d429 2
d515 4
d872 2
a873 2
		    DUPM2( printf("IBase->AYOffset * XSC(s)->SpriteFactor.Y >> SPRITEFACTOR_Y %ld\n",
			( IBase->AYOffset * XSC(s)->SpriteFactor.Y ) >> SPRITEFACTOR_Y ) );
d875 1
a875 1
			    -( ( IBase->AYOffset * XSC(s)->SpriteFactor.Y ) >> SPRITEFACTOR_Y ) )
a945 6
#if AA_KLUDGES
	    /* Can't do anything because of Gfx bug where gfx blanks the
	     * sprite even when it's Intuition who's changing the sprite
	     * width.
	     */
#else
a951 1
#endif
d998 4
a1001 4
	spritepos.X = ( ( IBase->AXOffset * XSC(mouse_screen)->SpriteFactor.X ) >>
	    SPRITEFACTOR_X ) + mouse_screen->MouseX;
	spritepos.Y = ( ( IBase->AYOffset * XSC(mouse_screen)->SpriteFactor.Y ) >>
	    SPRITEFACTOR_Y ) + mouse_screen->MouseY;
d1115 3
a1117 3
    140 << SPRITEFACTOR_X,	/* res = 1 is 140 ns */
     70 << SPRITEFACTOR_X,	/* res = 2 is 70 ns */
     35 << SPRITEFACTOR_X,	/* res = 3 is 35 ns */
d1218 1
a1218 1
	XSC(sc)->SpriteFactor.X = ( XSC(sc)->SpriteRes.X << SPRITEFACTOR_X ) /
d1225 1
a1225 1
    XSC(sc)->SpriteFactor.Y = ( XSC(sc)->SpriteRes.Y << SPRITEFACTOR_Y ) /
d1354 1
a1354 1
    DAS( printf("MakeSpriteData: Welcome\n" ) );
d1529 2
d1546 9
a1554 2
	    ((struct MousePointer *)newobj)->xmpt_WordWidth = 1;
	    ((struct MousePointer *)newobj)->mpt_Width = MPT_CUSTOMWIDTH;
d1557 21
a1585 1
#if 0
d1587 9
a1595 1
#endif
@


39.18
log
@Fixed use of ACTIVIEWCPR lock.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.17 92/07/17 17:28:38 peter Exp Locker: peter $
a380 2
	 * ZZZ: May be better removing LOCKIBASE, and moving setMousePointer()
	 * out of LOCKVIEW() (that's how it used to be)
d421 1
a421 1
		free_result = oldbusy->xmpt_BitMap;
d570 3
d584 21
d626 3
d689 2
a690 1
	LONG xres = 0, yres = 0;
d764 1
a764 1
    UNLOCKIBASE();
a767 1
    LOCKIBASE();
a1094 2
	LOCKIBASE();
	LOCKVIEW();
a1095 2
	UNLOCKVIEW();
	UNLOCKIBASE();
d1120 7
d1230 1
a1230 5
#if AA_KLUDGES	/* So grep will find me */
#endif
	/* ZZZ: This is one hell of an ugly way to convert res values */
	XSC(sc)->SpriteFactor.X = ( ( 4-res )*( 35<<SPRITEFACTOR_X ) ) /
	    XSC(sc)->PixelSpeed;
d1332 1
a1332 1
     * it in the y-direction (via hardware), then do it,
d1371 1
a1371 1
    DAS( printf("Assuming New Sprite, bitmap at %lx\n", mpointer->xmpt_BitMap ) );
d1379 1
a1379 1
	    mpointer->xmpt_BitMap, mpointer->mpt_Height ) );
d1383 1
a1383 1
    return( AllocSpriteData( mpointer->xmpt_BitMap,
d1441 1
a1441 3
	/* Change the pointer.  TRUE indicates that we have
	 * a full struct MousePointer here.
	 */
d1450 3
d1458 2
a1459 1
    struct MousePointer *mpointer = NULL;
d1461 1
a1461 3
    DSP( printf("self-task %lx Intuition task %lx\n",
	FindTask(NULL), fetchIBase()->InputDeviceTask ) );
    /* Let's fill up the compatible struct MousePointer */
d1463 31
a1493 10
     * parameter is NULL, such as it would be from ClearPointer()
     */
    if ( win->Pointer = pointer )
    {
	mpointer = (struct MousePointer *)&win->Pointer;
    }
    win->PtrHeight = height;
    win->PtrWidth = width;
    win->XOffset = xoffset;
    win->YOffset = yoffset;
d1495 1
a1495 4
    /* Change the pointer.  FALSE indicates that we do not have
     * a full struct MousePointer, but rather just the part
     * embedded in the window.
     */
d1511 1
a1511 1
    PACK_ENTRY( POINTERA_Dummy, POINTERA_BitMap, MousePointer, xmpt_BitMap, PKCTRL_ULONG ),
a1542 3
#if 0
    LONG setPointerClassAttrs();
#endif
a1569 52
#if 0
/*** setPointerClassAttrs ***
 *
 * Manage the attributes of PointerClass.  Just stuffs the
 * structure.
 *
 */

setPointerClassAttrs( cl, o, msg )
Class *cl;
Object *o;
struct opSet *msg;
{
    struct TagItem	*tagitem;
    ULONG		tidata;
    struct MousePointer *mpointer = INST_DATA( cl, o );

    struct TagItem	*NextTagItem();

    while ( tagitem = NextTagItem( &msg->ops_AttrList ) )
    {
	tidata = tagitem->ti_Data;

	switch ( tagitem->ti_Tag )
	{
	case POINTERA_BitMap:
	    mpointer->xmpt_BitMap = (struct BitMap *)tidata;
	    break;

	case POINTERA_XOffset:
	    mpointer->mpt_XOffset = tidata;
	    break;

	case POINTERA_YOffset:
	    mpointer->mpt_YOffset = tidata;
	    break;

	case POINTERA_WordWidth:
	    mpointer->xmpt_WordWidth = tidata;
	    break;

	case POINTERA_XResolution:
	    mpointer->xmpt_PointerXRes = tidata;
	    break;

	case POINTERA_YResolution:
	    mpointer->xmpt_PointerYRes = tidata;
	    break;
	}
    }
}
#endif
@


39.17
log
@Fixed bug where it was confused about legal pointer sizes when running
AA hardware non-enlightened or downgraded via BootMenu display options.
mpt_SpriteData collapsed into xmpt_BitMap.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.16 92/06/29 10:56:16 peter Exp Locker: peter $
d912 1
a912 1
	    assertLock( "updateMousePointer", VIEWCPRLOCK );
d949 1
@


39.16
log
@Now uses LongMouse.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.15 92/06/23 17:20:54 peter Exp Locker: peter $
d212 17
a247 15
    /* We want to look at GfxBase->BoardMemType to determine the number
     * of pointer sizes to deal with:  BoardMemType is defined in a manner
     * convenient for Graphics,but not super-suitable for us:
     *
     * 0   -> 1X system, NumPointerSizes should be 1
     * 1,2 -> 2X system, NumPointerSizes should be 2
     * 3   -> 4X system, NumPointerSizes should be 3
     *
     * Pay no attention to the man behind the curtain!  This
     * little bit of amazing math gives the right result,
     * but would need to be changed if we ever had different
     * values of BoardMemType.
     */
    IBase->NumPointerSizes = ( IBase->GfxBase->BoardMemType + 3 ) / 2;

d343 1
d348 10
d371 7
d461 1
a461 1
	    for ( size = 0; size < IBase->NumPointerSizes; size++ )
d479 1
a479 1
		for ( size = 0; size < IBase->NumPointerSizes; size++ )
d491 1
a491 1
		for ( size = 0; size < IBase->NumPointerSizes; size++ )
d529 1
a529 1
	    for ( size = 0; size < IBase->NumPointerSizes; size++ )
d664 1
a664 1
	LONG res = 0;
d669 2
a670 1
	    res = custompointer->xmpt_PointerXRes;
d686 2
a687 2
	    IBase->PointerXRes = res;
	    IBase->PointerYRes = custompointer->xmpt_PointerYRes;
d916 18
a959 1

d1017 5
a1021 2
    /* Don't let the width exceed what the HW is capable of */
    width = imin( width, 1 << (IBase->NumPointerSizes-1) );
a1330 1
    struct BitMap *sprite_bm;
d1346 3
a1348 1
    /* If mpt_SpriteData is non-NULL, then we have old-style
d1351 1
a1351 1
    if ( mpointer->mpt_SpriteData )
d1354 1
a1354 2
	    mpointer->mpt_SpriteData, mpointer->mpt_Height ) );
	sprite_bm = ( struct BitMap * ) mpointer->mpt_SpriteData;
d1358 1
a1358 9
    else
    {
	DAS( printf("New Sprite, bitmap at %lx\n", mpointer->xmpt_BitMap ) );
	sprite_bm = mpointer->xmpt_BitMap;
    }
    /* SpriteData is NULL and thus ignored for a new-style pointer.
     * sprite_bm is NULL for an old-style one.
     */
    return( AllocSpriteData( sprite_bm,
@


39.15
log
@setDefaultMousePointer() of the default pointer now returns the
bitmap to be freed.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.14 92/06/22 13:02:09 peter Exp Locker: peter $
a778 1
    struct Point  spritepos;
d783 5
a787 3
    DUPM( dumpPt( "rm: in", IBase->Mouse ) );
    limitPoint( &IBase->Mouse, &IBase->MouseLimits);
    DUPM( dumpPt( "rm: after limit", IBase->Mouse ) );
a788 2
    spritepos = IBase->Mouse;

d793 2
a794 2
    IBase->MouseY = IBase->Mouse.Y / IBase->MouseScaleY;
    IBase->MouseX = IBase->Mouse.X / MOUSESCALEX;
d876 1
d949 2
a950 2
	DUPM( printf("rM: spritepos.X = %ld, IBase->X: %ld\n",
	    spritepos.X, IBase->Mouse.X ) );
@


39.14
log
@Enabled sprite-scan doubling.  Now calculates sprite position after
changing sprite.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.13 92/06/18 18:09:35 peter Exp Locker: peter $
d305 5
a309 2
 * pointer's ExtSprites are freed.  Returns TRUE if successful.  If it
 * fails, the partial result is freed, and FALSE is returned.
d312 11
a322 2
 * for it.  Returns 0 for failure, -1 for success, or a pointer to the
 * previously installed busy pointer, for IPrefs to free.
d337 1
a337 2
    struct ExtSprite *newExtSprite[POINTER_SIZES];
    struct BitMap *oldbm = NULL;
d367 5
a371 1
	oldbm = SUCCESS;
d400 5
a404 3
		/* Normally, IPrefs would be freeing the old busy pointer... */
		oldbm = oldbusy->xmpt_BitMap;
		if ( oldbm == IBase->BusyPointerBitMap )
d406 4
a409 2
		    /* This was the original busy pointer.  That one
		     * is our responsibility to free.
d412 1
a412 1
		    FreeVec( oldbm );
d414 2
a415 1
		    oldbm = SUCCESS;
d418 1
a418 1
	    DSBP( printf("Returning bitmap %lx to be freed by IPrefs\n",oldbm ) );
d422 7
d446 2
a447 1
		    oldbm = FALSE;
d452 1
a452 1
	    if ( oldbm )
a453 2
		struct ExtSprite *oldExtSprite[POINTER_SIZES];

d495 15
a509 6
		for ( size = 0; size < IBase->NumPointerSizes; size++ )
		{
		    FreeSpriteData( oldExtSprite[ size ] );
		}
	    }
	    else
d511 1
a511 9
		/* We failed to allocate some of the new sprite data.
		 * Clean up any we did allocate, and return failure.
		 * ZZZ: Could consolidate with FreeSpriteData() calls
		 * above...
		 */
		for ( size = 0; size < IBase->NumPointerSizes; size++ )
		{
		    FreeSpriteData( newExtSprite[ size ] );
		}
d517 2
a518 2
    DSDM( printf("sDMP success %ld\n",oldbm) );
    return( oldbm );
d1244 1
a1244 1
	    targetres = XSC(IBase->ActiveScreen)->ScaleFactor.Y;
@


39.13
log
@Uses correct test and tag for scan-doubling.  Still disabled due to
Gfx problems.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.12 92/06/04 16:17:38 peter Exp Locker: peter $
d718 12
d800 2
a801 2
		    DUPM2( printf("IBase->AYOffset * XSC(s)->SpriteFactor.Y %ld\n",
			IBase->AYOffset * XSC(s)->SpriteFactor.Y) );
d803 1
a803 1
			    -( IBase->AYOffset * XSC(s)->SpriteFactor.Y ) )
d845 3
a849 10
	/* SpriteFactor.X is four times bigger than reality, since
	 * V39 needs to be able to scale up and down, too.
	 *
	 * SpriteFactor.Y is OK as is.
	 */
	spritepos.X = ( ( IBase->AXOffset * XSC(mouse_screen)->SpriteFactor.X ) >>
	    SPRITEFACTOR_X ) + mouse_screen->MouseX;
	spritepos.Y = IBase->AYOffset * XSC(mouse_screen)->SpriteFactor.Y +
	    mouse_screen->MouseY;

a850 10
    }

    DUPM( printf("rM: spritepos.X = %ld, IBase->X: %ld\n",
	spritepos.X, IBase->Mouse.X ) );

    ICOLOR( CKCOLOR10 );

    DDF( if ( IBase->DebugFlag & IDF_SPRITE ) {
	printf("movesprite to: %ld, %ld\n", spritepos.X,spritepos.Y );
	printf("mouse screen: %lx\n", mouse_screen ); });
a851 3
    DUPM( printf("mouse_screen: %lx, newSprite: %lx\n", mouse_screen, newSprite ) );
    if ( mouse_screen )
    {
d860 1
a860 1
	    /* Need to hold the VIEWLOCK (which also gets the GfxBase
d864 1
a864 1
	    assertLock( "updateMousePointer", VIEWLOCK );
d868 1
d872 1
a872 1
		 * if VTAG_IMMEDIATE failed
d903 1
d908 17
d1013 10
a1024 1
 *
d1091 1
d1136 2
a1137 1
	XSC(sc)->SpriteFactor.X = (( 4-res )*(35<<SPRITEFACTOR_X)) / XSC(sc)->PixelSpeed;
d1139 2
a1140 1
    XSC(sc)->SpriteFactor.Y = XSC(sc)->SpriteRes.Y / XSC(sc)->ScaleFactor.Y;
d1155 9
a1163 1
 * in effect.
a1227 4
/* Temporarily disabled this because gfx is confused- GSTAG_SCANDOUBLED
 * doesn't yet work right thru ChangeExtSpriteA().
 */
#if AAA_KLUDGES
a1236 1
#endif
@


39.12
log
@Temporarily disabled vertical doubling stuff.
@
text
@a0 3
/* Dummy tag to be replaced when Chris adds a real one... */
#define CSTAG_DoubleScan	0x82009999

d5 1
a5 1
 *  $Id: pointer.c,v 39.11 92/06/02 14:54:46 peter Exp Locker: peter $
a51 1
#define DUPMC2(x)	;	/* updateMousePointer change sprite */
d893 1
a893 1
	    DUPMC( printf( "  posctldata %lx, height %lx, x/y %lx/%lx, num %lx, ww %lx\n",
d899 2
a900 1
		newSprite->es_wordwidth ) );
d908 1
a908 1
		CSTAG_DoubleScan, ydouble,
d1197 2
a1198 2
/* Temporarily disabled this since pointer scan-doubling not yet
 * available through graphics.
d1201 2
a1202 2
    /* ZZZ: Need a better test for ability to double-scan */
    if ( TESTFLAG( IBase->GfxBase->ChipRevBits0, GFXF_AA_LISA ) &&
@


39.11
log
@New names for pointer flags.  Now use DIPF_SPRITE_CHNG_RES.  Now
handles y-scaling too.
@
text
@d8 1
a8 1
 *  $Id: pointer.c,v 39.10 92/05/29 18:28:20 peter Exp Locker: peter $
d1200 4
d1213 1
@


39.10
log
@Horizontal scaling of pointer hot-spot now handled.
@
text
@d1 3
d8 1
a8 1
 *  $Id: pointer.c,v 39.9 92/05/21 17:43:05 peter Exp Locker: peter $
d48 1
d263 4
a266 2
    setDefaultMousePointer( &pointer_bm, ROMPOINTER_HOTX, ROMPOINTER_HOTY,
	ROMPOINTER_RESN, ROMPOINTER_WORDWIDTH, NPT_DEFAULT );
d286 4
a289 2
	setDefaultMousePointer( busy_bm, ROMBUSYPOINTER_HOTX, ROMBUSYPOINTER_HOTY,
	    ROMBUSYPOINTER_RESN, ROMBUSYPOINTER_WORDWIDTH, NPT_BUSY );
d320 1
a320 1
setDefaultMousePointer( bm, xoffset, yoffset, resn, wordwidth, type )
d324 2
a325 1
LONG resn;
d339 2
a340 2
    DSDM( printf( "\nsDMP: bm %lx, hotspot: %ld,%ld, resn %ld, ww %ld\n",
	bm, xoffset, yoffset, resn, wordwidth ) );
d347 2
a348 1
	POINTERA_Resolution, resn,
d626 1
a626 1
	    res = custompointer->xmpt_PointerRes;
d642 2
a643 1
	    IBase->PointerRes = res;
d687 2
a688 1
	IBase->PointerRes = IBase->DefaultMousePointer->xmpt_PointerRes;
a721 4
 * ZZZ: Some work needs to be done on scaling the hot-spot.
 * Also, switching to/from Hedley mode in remakeCopList()
 * requires ChangeSprite() get called.  That's not tested.
 *
d841 2
d845 1
a845 2
	    SPRITEFACTOR_X ) +
	    mouse_screen->MouseX;
d868 1
d878 2
d910 3
a912 1
	    ChangeExtSpriteA( mousevp, IBase->SimpleSprite, newSprite, NULL );
d1003 1
a1003 1
 * For a given screen, and a desired resolution (one of the POINTERRESN_
d1010 2
a1011 3
#define PIXELRESOLUTION_LORES	44	/* 44 ticks per lores pixel */
#define PIXELRESOLUTION_HIRES	22	/* 22 ticks per hires pixel */
#define PIXELRESOLUTION_SHIRES	11	/* 11 ticks per hires pixel */
d1017 1
a1017 1
    LONG desired_res = IBase->PointerRes;
d1021 1
a1021 1
    if ( !TESTFLAG( IBase->GfxBase->ChipRevBits0, GFXF_AA_LISA ) )
d1023 1
a1023 1
	/* No AA, no sprite resolution! */
d1026 2
a1027 2
    /* We've chosen POINTERRESN_DEFAULT, POINTERRESN_140NS, POINTERRESN_70NS,
     * and POINTERRESN_35NS to match numerically the gfx SPRITERESN_ defines,
d1030 1
a1030 1
    else if ( desired_res >= POINTERRESN_SCREENRES )
d1036 1
a1036 1
	/* Default here is for POINTERRESN_SCREENRES, we want the
d1040 1
a1040 1
	if ( desired_res == POINTERRESN_LORES )
d1045 1
a1045 1
	    pointer_resolution = PIXELRESOLUTION_LORES;
d1047 1
a1047 1
	else if ( desired_res == POINTERRESN_HIRES )
d1052 1
a1052 1
	    pointer_resolution = PIXELRESOLUTION_HIRES;
d1058 2
a1059 2
	    /* Calculate what the pointer_pixelspeed should be.  The
	     * valid values are 35, 70, and 140 ns.  But pointer_pixelspeed
d1062 1
a1062 1
	    LONG pointer_pixelspeed;
d1066 1
a1066 1
	    pointer_pixelspeed = ( XSC(sc)->PixelSpeed * pointer_resolution ) /
d1068 11
a1078 2
	    DSS( printf( "sSS: Target pointer_pixelspeed %ld\n",
		pointer_pixelspeed ) );
d1081 2
a1082 2
	    delta = iabs( pointer_pixelspeed - 35 );
	    delta2 = iabs( pointer_pixelspeed - 70 );
d1088 1
a1088 1
	    delta2 = iabs( pointer_pixelspeed - 140 );
d1110 1
a1110 1
	XSC(sc)->SpriteFactor.X = ( XSC(sc)->SpriteResX << SPRITEFACTOR_X ) /
d1115 3
d1120 5
a1124 1

d1134 88
d1384 2
a1385 1
    PACK_ENTRY( POINTERA_Dummy, POINTERA_Resolution, MousePointer, xmpt_PointerRes, PKCTRL_WORD ),
d1483 6
a1488 2
	case POINTERA_Resolution:
	    mpointer->xmpt_PointerRes = tidata;
@


39.9
log
@No longer poke GfxBase->SoftSprites.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.8 92/05/15 14:08:16 peter Exp Locker: peter $
d831 5
a835 2
	/* GZZZ: Hotspot scaling to go into graphics? */
	spritepos.X = IBase->AXOffset * XSC(mouse_screen)->SpriteFactor.X +
d998 1
d1008 5
d1014 2
a1015 1
     * and POINTERRESN_35NS to match numerically the gfx SPRITERESN_ defines.
d1017 1
a1017 1
    if ( desired_res >= POINTERRESN_SCREENRES )
a1020 3
	/* A reasonable setting if we fail */
	res = SPRITERESN_ECS;

d1043 1
d1081 15
@


39.8
log
@Simplified and fixed bad locking order in updateMousePointer().
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.7 92/05/01 13:54:05 peter Exp Locker: peter $
a230 4
#if AA_KLUDGES
    IBase->GfxBase->SoftSprites = 1;
#endif

d832 4
a835 2
	spritepos.X = IBase->AXOffset * XSC(mouse_screen)->SpriteFactor.X;
	spritepos.Y = IBase->AYOffset * XSC(mouse_screen)->SpriteFactor.Y;
a836 2
	spritepos.X += mouse_screen->MouseX;
	spritepos.Y += mouse_screen->MouseY;
d858 6
@


39.7
log
@SetWindowPointerA() now called realSetWindowPointerA().
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.6 92/04/14 15:45:13 peter Exp Locker: peter $
d717 14
a750 2
    assertLock("updateMousePointer", IBASELOCK ); /* maybe I don't need to lock */

a843 10
    /* ZZZ: Don't fully understand Jimm's locking trick of
     * LOCKIBASE()/LOCKVIEW()/UNLOCKIBASE()/UNLOCKVIEW().  In any case,
     * right now we need to keep the IBase lock just a little longer,
     * so we can do setSpriteSpeed() safely.  So let's not UNLOCKIBASE()
     * just yet...
     *
     * UNLOCKIBASE();
     *
     */

a869 4
	    /* ZZZ: Nasty locking problem.  Have to have several
	     * separate unlocks:
	     */
	    UNLOCKIBASE();
a896 7
	else
	{
	    /* ZZZ: Nasty locking problem.  Have to have several
	     * separate unlocks:
	     */
	    UNLOCKIBASE();
	}
a900 7
    else
    {
	/* ZZZ: Nasty locking problem.  Have to have several
	 * separate unlocks:
	 */
	UNLOCKIBASE();
    }
d902 1
d904 1
@


39.6
log
@Includes pointerclass.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.5 92/04/13 16:23:33 peter Exp Locker: peter $
d1150 1
a1150 1
/*** intuition.library/NewSetPointer ***/
d1157 1
a1157 1
SetWindowPointerA( win, taglist )
@


39.5
log
@Removed some compiled-out kludges and one included kludge.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.4 92/04/10 15:05:19 peter Exp Locker: peter $
d31 1
@


39.4
log
@Now uses PackStructureTags().
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.3 92/04/09 16:23:57 peter Exp Locker: peter $
d30 1
a230 8
    /* So we can survive reboot with enforcer on when in $f00000 board */
    if ( IBase->GfxBase->LibNode.lib_Version < 39 )
    {
	return;
    }
#endif

#if AA_KLUDGES
a894 16
#if AAA_KLUDGES
	    /* ChangeExtSprite() is currently failing sometimes,but it's
	     * never going to fail for us in the future.  So we temporarily
	     * update the num.
	     */
	    newSprite->es_SimpleSprite.num = IBase->SimpleSprite->num;
	    newSprite->es_SimpleSprite.x = IBase->SimpleSprite->x;
	    newSprite->es_SimpleSprite.y = IBase->SimpleSprite->y;
	    /* Currently, chrisg always sets SprMoveDisable, so clear it
	     * if we have a match
	     */
	    if ( IBase->GfxBase->SpriteWidth == newSprite->es_wordwidth )
	    {
		IBase->GfxBase->SprMoveDisable = 0;
	    }
#endif
d998 1
a998 1
 * flags from pointer.h), calculate and set the sprite resolution.
a1115 2
     * We do scale down, but chris has a bug where -2 and -1 scaling
     * are inverted, so we kludge around that.
@


39.3
log
@Added kludge to handle ChangeExtSprite() failure.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.2 92/04/07 17:55:18 peter Exp Locker: peter $
d25 4
d1273 19
d1307 1
d1309 1
d1337 1
a1337 1

d1384 1
@


39.2
log
@Now manages freeing of pointer bitmap properly.  Added NewSetPointerA().
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.1 92/04/02 12:06:22 peter Exp Locker: peter $
a47 1
#define DSETM(x)	;	/* old setMousePointer */
a249 6
#if AA_KLUDGES
    /* Gfx currently "lies" about MemType until enlighten.  They'll
     * be fixing this.
     */
    IBase->NumPointerSizes = 3;
#else
a250 1
#endif
d882 1
a882 1
	    DUPMC2( printf( "ChangeExtSpriteA( from old %lx[%lx] to new %lx )\n",
d891 6
a896 6
/* ZZZ: we need the delay this print statement causes in order not to
 * crash :-(
 */
#if 0
printf("Please don't crash\n");
#endif
d898 8
a905 1
#if AA_KLUDGES
a1124 57
#if AA_KLUDGES
/* This will be disabled because it's not the way to go.  However, we
 * still need Chris to implement SPRITEA_SpriteData.
 */
    struct BitMap temp_bm;
    struct BitMap *sprite_bm = &temp_bm;
    struct ExtSprite *AllocSpriteData();

    DAS( printf("MakeSpriteData: Welcome\n" ) );

    /* We never scale a sprite bigger, since we'd rather just leave
     * transparent pixels pixels.
     * We do scale down, but chris has a bug where -2 and -1 scaling
     * are inverted, so we kludge around that.
     */
    if ( scale >= 0 )
    {
	scale = 0;
    }
    /* ZZZ kludge to fix -2/-1 interaction */
    else
    {
	scale = -3 - scale;
    }

    /* Chris will make AllocSpriteData() capable of taking old-style
     * sprite-data.  Until then, we have to do this:
     */
    /* If mpt_SpriteData is non-NULL, then we have old-style
     * sprite data.
     */
    if ( mpointer->mpt_SpriteData )
    {
	/* This little trick makes old-style sprite data look like
	 * an interleaved struct BitMap.  The first plane starts
	 * two words into the sprite-data (skip the two words of
	 * control).  The second plane starts a word later.
	 */
	InitBitMap( sprite_bm, 2, 16, mpointer->mpt_Height );
	sprite_bm->Planes[0] = (PLANEPTR)(mpointer->mpt_SpriteData + 2);
	sprite_bm->Planes[1] = (PLANEPTR)(mpointer->mpt_SpriteData + 3);
	sprite_bm->pad = 0x805C;
	sprite_bm->BytesPerRow = 4;
	DAS( printf("Old SpriteData at %lx, height %ld\n",
	    mpointer->mpt_SpriteData, mpointer->mpt_Height ) );
    }
    else
    {
	DAS( printf("New Sprite, bitmap at %lx\n", mpointer->xmpt_BitMap ) );
	sprite_bm = mpointer->xmpt_BitMap;
    }

    return ( AllocSpriteData( sprite_bm,
	SPRITEA_Width, 16*word_width,
	SPRITEA_XReplication, scale,
	TAG_DONE ) );
#else
d1126 2
a1127 1
    ULONG tag = TAG_IGNORE;
a1141 7
#if AA_KLUDGES
    /* ZZZ kludge to fix -2/-1 interaction */
    else
    {
	scale = -3 - scale;
    }
#endif
d1151 2
a1152 5
#if AA_KLUDGES
	tag = TAG_IGNORE;
#else
	tag = SPRITEA_SpriteData;
#endif
d1162 1
a1162 1
    return ( AllocSpriteData( sprite_bm,
a1163 5
#if AA_KLUDGES
	TAG_IGNORE, mpointer->mpt_Height,
#else
	SPRITEA_Height, mpointer->mpt_Height,
#endif
d1165 2
a1166 1
	tag, TRUE,
a1167 1
#endif
d1237 3
a1239 2
    DSP( printf("SetPointer %lx for window %lx ", pointer, win));

@


39.1
log
@First cut at code needed to support new-style sprites.  Evicted
autodocs.
@
text
@d5 1
a5 1
 *  $Id: pointer.c,v 39.0 92/03/30 14:07:53 peter Exp Locker: peter $
a12 13
/*
 * BUGS:
 *
 * Functions and class take spritedata instead of BitMap
 *
 * Hedley sprites probably broken since ChangeSprite not being called
 *
 * Attached sprite support quite broken
 *
 * SetPointer()/ClearPointer() temporarily work
 *
 */

d21 4
d28 1
d32 1
d34 3
d41 1
d44 2
d50 1
d72 1
d75 1
a75 1
 *	- One-time init, call from initIntuition() or make in-line
d78 1
a78 1
 *	- Change pref pointer.  Done.  Callers need to cooperate.
d80 1
a80 1
 * setWindowPointer()
d84 1
a84 1
 *	- Establish the sprite based on the active poitner.
d87 1
a87 1
 *	- Figure out whether to use 16/32/64 for the sprite.
a88 3
 * useXSprite()
 *	- Install chosen XSprite.
 *
d92 1
a92 1
 * myAllocXSprite()
a93 1
 * myFreeXSprite()
d96 5
a100 7
struct SimpleSprite *myAllocXSprite();
void myFreeXSprite();

/* storage for a 'pheight' tall sprite, two uwords (4 bytes) per row,
 * plus two rows for top and bottom
 */
#define SPR_STORAGE( pheight ) 	(( (pheight) + 2 ) << 2)
d105 2
d109 30
a138 1
UWORD RomPointer[] =
d140 14
a153 1
    0x0000, 0x0000,	/* one word each for position and control */
d155 22
a176 19
    0xC000, 0x4000,
    0x7000, 0xB000,
    0x3C00, 0x4C00,
    0x3F00, 0x4300,

    0x1FC0, 0x20C0,
    0x1FC0, 0x2000,
    0x0F00, 0x1100,
    0x0D80, 0x1280,

    0x04C0, 0x0940,
    0x0460, 0x08A0,
    0x0020, 0x0040,
    0x0000, 0x0000

    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
    0x0000, 0x0000,
d178 4
a181 2
    0x0000, 0x0000,
    0x0000, 0x0000,
d184 22
d209 4
a212 2
 * When Intuition is being initialized, we'll use the ROM copy of
 * the pointer imagery to establish the original default MousePointer.
d214 1
a214 1
 * FUNCTIONS AFFECTED:  initIntuition()
a215 2
 * STATUS:  Need to put in-line.
 *
a217 1
#if 000
d220 34
a253 5
    /* ZZZ: Should pass a BitMap one day */
    setDefaultMousePointer( RomPointer, ROMPOINTER_HEIGHT,
	ROMPOINTER_HOTX, ROMPOINTER_HOTY, 0 );
    /* ZZZ if mousepointer failed to allocate, or sDMP() fails, we're
     * severely screwed at this point...
d255 49
a304 1
#endif
d308 3
a310 11
 * Given a BitMap, hot-spot offset, and flags, make an XSprite in each
 * size from the new preferences pointer, make IBase->DefaultXSprite
 * point at it, and free the old DefaultXSprite.  If successful,
 * returns TRUE.  Else, frees any partial result, and returns FALSE
 * (previous pointer still in effect).
 *
 * FUNCTIONS AFFECTED: setIPrefs(), initIntuition()
 *
 * STATUS: Appears to be mostly done, callers need to cooperate.
 *	bm is currently actually SpriteData.  height may not be
 *	necessary in the future.
d312 12
a323 1
 */
d325 2
a326 2
LONG
setDefaultMousePointer( bm, height, xoffset, yoffset, flags )
a327 1
LONG height;
d330 3
a332 1
LONG flags;
d334 2
a335 2
    struct SimpleSprite *newXSprite[POINTER_SIZES];
    LONG success = FALSE;
d338 1
a340 1
    struct SimpleSprite *myAllocXSprite();
d343 3
a345 3
    DSDM( printf( "\nsDMP: bm %lx, height %ld, hotspot: %ld,%ld, flags %ld\n",
	bm, height, xoffset, yoffset, flags ) );
    DSDM({ if ( IBase->DefaultXSprite[0] ) { printf( "returning early\n" ); return(TRUE);} });
d348 1
a348 2
	/* ZZZ: Make a real bitmap? */
	POINTERA_SpriteData, bm,
d351 2
a352 2
	/* ZZZ: wordwidth, resolution */
	POINTERA_Height, height,
d364 1
a364 1
	success = TRUE;
d366 15
a380 59
	/* Attempt to allocate XSprite for the new preferences
	 * pointer imagery, for each size.  The way we designed it,
	 * each newXSprite[] pointer points to something real
	 * or to NULL.
	 */
	for ( size = 0; size < POINTER_SIZES; size++ )
	{
	    if ( ! ( newXSprite[ size ] =
		myAllocXSprite( newmpointer->mpt_PointerData, size,
		    newmpointer->mpt_Height ) ) )
	    {
		success = FALSE;
	    }
	    DSDM( printf( "newXSprite[%ld] at %lx\n", size, newXSprite[size] ) );
	}

	if ( success )
	{
	    /* Install the new pointer imagery as preferences,
	     * change the displayed pointer if necessary,
	     * and free the old ones.
	     */
	    struct SimpleSprite *oldXSprite[POINTER_SIZES];

	    for ( size = 0; size < POINTER_SIZES; size++ )
	    {
		oldXSprite[size] = IBase->DefaultXSprite[size];
	    }

	    /* ZZZ: I believe this is safe without first copying away... */
	    DisposeObject( IBase->DefaultMousePointer );

	    IBase->DefaultMousePointer = newmpointer;

	    for ( size = 0; size < POINTER_SIZES; size++ )
	    {
		IBase->DefaultXSprite[size] = newXSprite[size];
	    }

	    DSDM( printf( "DefaultXSprites at %lx, %lx, %lx.  DefaultMP %lx\n",
		IBase->DefaultXSprite[0], IBase->DefaultXSprite[1],
		IBase->DefaultXSprite[2], IBase->DefaultMousePointer ) );

	    /* We update the display if the CustomMousePointer is
	     * NULL (meaning default is used)
	     * ZZZ: Is this OK inside LOCKVIEW()?  Only because we also
	     * LOCKIBASE().  Would be better off outside completely? (as before)
	     */
	    if ( !IBase->CustomMousePointer )
	    {
		DSDM( printf( "Calling sMP because default pointer in effect\n") );
		setMousePointer();
		/* We need to WaitTOF() if the default pointer was
		 * in use.
		 */
		WaitTOF();
	    }

	    for ( size = 0; size < POINTER_SIZES; size++ )
d382 23
a404 1
		myFreeXSprite( oldXSprite[ size ] );
d406 1
d408 1
a408 1
	else
d410 11
a420 4
	    /* We failed to allocate some of the new sprite data.
	     * Clean up any we did allocate, and return failure.
	     * ZZZ: Could consolidate with myFreeXSprite() calls
	     * above...
d422 61
a482 1
	    for ( size = 0; size < POINTER_SIZES; size++ )
d484 9
a492 1
		myFreeXSprite( newXSprite[ size ] );
d498 2
a499 2
    DSDM( printf( "sDMP returning %ld\n", success ) );
    return( success );
d503 1
a503 1
/*** setWindowPointer() ***
d506 2
a507 2
 * SetPointer() or NewSetPointer(), or uses the WA_Pointer
 * tag.
d509 6
a514 4
 * a newMousePointer of NULL requests the default pointer.
 * Standard default types (for now, only the busy-pointer)
 * are obtained separately through NewObject() and look
 * like any custom pointer.
d517 2
a518 2
 * then we probably come out OK since IBase->ActiveWindow
 * doesn't yet match win.
d520 2
a521 2
 * There is no old stuff to free, since the default pointer is
 * not changed by this, and custom pointers belong to the
a522 6
 *
 * FUNCTIONS AFFECTED: misc.c/SetPointer() misc.c/ClearPointer(),
 * 	OpenWindowTagList().
 *
 * STATUS: Needs integration.  Doesn't handle old-style pointers.
 *
d525 1
a525 1
setWindowPointer( win, newMousePointer, newstyle )
a527 1
LONG newstyle;
d533 5
a537 7
    LOCKIBASE();
    CLEARFLAG( win->MoreFlags, WMF_NEWPOINTER );
    if ( newstyle )
    {
	/* Note that it's a new pointer */
	SETFLAG( win->MoreFlags, WMF_NEWPOINTER );
    }
d539 3
a541 1
    /* Go with custom pointer (or NULL, meaning default pointer) */
d552 2
a553 1
	     * the old pointer for the future?
a564 2
    UNLOCKIBASE();

d572 1
a572 1
 * Will call myAllocXSprite() if needed.
a579 4
 * FUNCTIONS AFFECTED: replaces old setMousePointer()
 *
 * STATUS: Appears to be done.
 *
d587 4
a590 1
    struct SimpleSprite *newCustomXSprite = NULL;
a601 1
    CLEARFLAG( IBase->Flags, NEWPOINTER );
d605 6
a610 2
	IBase->CustomMousePointer = XWINDOW(IBase->ActiveWindow)->MousePointer;
	if ( TESTFLAG( IBase->ActiveWindow->MoreFlags, WMF_NEWPOINTER ) )
d612 1
a612 1
	    SETFLAG( IBase->Flags, NEWPOINTER );
d622 1
a622 1
    if ( IBase->CustomMousePointer )
d626 2
a627 1
	if ( TESTFLAG( IBase->Flags, NEWPOINTER ) )
d629 4
a632 2
	    width = IBase->CustomMousePointer->xmpt_WordWidth;
	    res = IBase->CustomMousePointer->xmpt_PointerRes;
d634 1
a634 1
	/* Allocate a suitable XSprite representation of the pointer,
d638 3
a640 4
	if ( newCustomXSprite = myAllocXSprite(
	    IBase->CustomMousePointer->mpt_PointerData,
	    calcSpriteWidth( width ),
	    IBase->CustomMousePointer->mpt_Height ) )
d642 4
a645 4
	    DSMP( printf( "got XSprite at %lx for CustomMousePointer\n",
		newCustomXSprite ) );
	    /* Let's actually bring it onto the display! */
	    useXSprite( newCustomXSprite );
d647 2
d652 1
a652 1
	    /* We failed to give the guy what he wanted because myAllocXSprite()
d656 1
a656 1
	    DSMP( printf( "Failed to get XSprite for CustomMousePointer\n") );
d662 1
a662 1
    if ( !newCustomXSprite )
d664 14
d683 1
a683 1
	/* We always keep an XSprite representation of the default pointer
d687 12
a698 7
	DSMP( printf( "Using DefaultXSprite[0] at %lx\n",
	    IBase->DefaultXSprite[0] ) );
	IBase->GfxBase;
	IBase->GfxBase->SpriteWidth;
	useXSprite( IBase->DefaultXSprite[ IBase->GfxBase->SpriteWidth ] );
	/* ZZZ: Need to set IBase->PointerRes to something */
    }
d700 2
a701 1
    if ( IBase->CustomXSprite )
d703 1
a703 1
	/* If there was a custom XSprite in use, free it after
d707 1
a707 1
	myFreeXSprite( IBase->CustomXSprite );
d709 2
a710 13
    /* Remember the CustomXSprite (if any) we're currently using: */
    IBase->CustomXSprite = newCustomXSprite;

    {
	struct Screen *sc;

	for ( sc = IBase->FirstScreen; sc; sc = sc->NextScreen )
	{
	    setSpriteSpeed( sc );
	}
    }

    UNLOCKVIEW();
a711 2
    /* Move the sprite to the right place */
    updateMousePointer();
d721 2
a722 7
 * Then do it.
 *
 * STATUS:  Seems pretty good.  Some work needs to be done on scaling
 *	the hot-spot.  Also, switching to/from Hedley mode in remakeCopList()
 *	requires ChangeSprite() get called.  We no longer have a provision
 *	for this because uMP() lost its parameter.  Also, may need to call
 *	NewMoveSprite(), if such appears.
d724 3
d729 2
a730 1
updateMousePointer()
d842 9
a850 1
    UNLOCKIBASE();
d861 1
d864 62
a925 1
	/* GZZZ: NewMoveSprite()? */
d929 7
d943 2
a944 4
 * Based on the supplied MousePointer flags, figure out what
 * the sprite width should be.
 *
 * STATUS: Short-circuited for now
d958 2
d963 1
d971 1
a971 1
/*** useXSprite() ***
d973 14
a986 72
 * Given a pointer to an XSprite, let's use it for the Intuition
 * sprite.  This means we have to associate sprite zero (and possibly
 * one, too) with this XSprite.
 *
 * STATUS: Kludged to FreeSprite/GetSprite.  Waiting for ObtainSpriteEngine().
 *
 */

useXSprite( xsprite )
struct SimpleSprite *xsprite;
{
    struct IntuitionBase *IBase = fetchIBase();

    assertLock( "useXSprite", IBASELOCK );
    assertLock( "useXSprite", VIEWLOCK );
#if 000 /* This works using the old sprite */
    IBase->SimpleSprite->height = xsprite->height;
    ChangeSprite( NULL, IBase->SimpleSprite, xsprite->posctldata );
#endif

#if 111
    /* This works without using the old sprite */
    FreeSprite(0);
    GetSprite( xsprite, 0 );
    IBase->TetrisSprite = IBase->SimpleSprite = xsprite;
    D( printf( "useXSprite() using %lx\n", xsprite ) );
#endif

#if 000
    /* This gfx library call will associate the supplied xsprite
     * with a suitable sprite engine.
     */
    ObtainSpriteEngine( xsprite,
	/* I use sprite zero, but I already own it: */
	SPRITEA_Number, 0,
	SPRITEA_Width, width,
	SPRITEA_Soft, TRUE,
	SPRITEA_AlreadyOwn, 0,

#if WORRY_ATTACHED
	/* Maybe need sprite 1, too, but maybe I don't own it */
	if (attached)
	    SPRITEA_Attached, TRUE,
	if (attached&gotsprite1)
	    SPRITEA_AlreadyOwn, 1,
#endif

	TAG_DONE );
#endif


#if 000
    GfxBase->GlobalSpriteResolution = whatever-sprite-resolution;
#endif

#if 000
    /* For reference, here's a bit of the old updateMousePointer() */
    {
	struct SimpleSprite *spr = IBase->SimpleSprite;
	ChangeSprite( mousevp, spr, IBase->APointer );

	if ( IBase->GotSprite1 )
	{
	    /* We must do the initial MoveSprite() on the attached guy.
	     * Thereafter, it moves in step.
	     */
	    DUPM( printf("move attached guy\n") );
	    MoveSprite( mousevp , IBase->AttachedSSprite,
		spr->x, spr->y);
	}
    }
#endif
a988 1

d993 3
a995 5
 * The call invoked should do something like sendISMNoQuick()
 * or maybe even a PutMsg() to some port.  Based on that, we
 * should invoke this function:
 *
 * STATUS: Needs to be connected via msg, token, etc.
d1001 12
a1012 6
    /* This has to get more fancy, I guess... */
    LOCKIBASE();
    LOCKVIEW();
    setMousePointer();
    UNLOCKVIEW();
    UNLOCKIBASE();
d1033 1
d1036 1
a1036 1
     * and POINTERRESN_35NS to match the gfx SPRITERESN_ values.
a1095 1
    /* ZZZ: Should be VTAG_DEFAULTSPRITERESN */
d1097 3
d1101 2
a1102 1
	VTAG_SPRITERESN_SET, res,
d1104 83
a1186 1
}
d1188 11
d1200 6
d1207 41
a1247 6
/*** myAllocXSprite() ***
 *
 * Pretend to take a BitMap and a sprite-width and return a pointer
 * to a struct SimpleSprite derived therefrom. Currently, it takes
 * a pointer to SpriteData instead of a BitMap.
 *
d1249 5
d1255 41
a1295 26
struct SimpleSprite *
myAllocXSprite( bm, sprite_width, sprite_height )
struct BitMap *bm;
ULONG sprite_width;
ULONG sprite_height;
{
    UWORD *data;
    struct SimpleSprite *ss;
    struct IntuitionBase *IBase = fetchIBase();

    if ( ss = (struct SimpleSprite *)AllocVec( sizeof( struct SimpleSprite ),
	MEMF_PUBLIC|MEMF_CLEAR ) )
    {
	ss->height = sprite_height;

	if ( data = (UWORD *)AllocVec( SPR_STORAGE( sprite_height ),
	    MEMF_PUBLIC|MEMF_CHIP ) )
	{
	    CopyMem( bm, data, SPR_STORAGE( sprite_height ) );
	    ss->posctldata = data;
	}
	else
	{
	    FreeVec( ss );
	    ss = NULL;
	}
a1296 23
    D( printf( "myAllocXSprite(bm=%lx), returning SimpleSprite %lx\n",
	bm, ss ) );
    return( ss );
}


/*** myFreeXSprite() *** 
 *
 * Free data allocated through myAllocXSprite().  myFreeXSprite(NULL)
 * is safe (does nothing).
 *
 */

void
myFreeXSprite( ss )
struct SimpleSprite *ss;
{
    D( printf( "myFreeXSprite(%lx)\n", ss ) );
    if ( ss )
    {
	FreeVec( ss->posctldata );
	FreeVec( ss );
    }
a1299 2
#endif AA_KLUDGES

d1301 1
d1303 2
a1304 2
SetPointer(window, pointer, height, width, xoffset, yoffset)
struct Window *window;
d1308 2
a1309 1
    DSP( printf("SetPointer %lx for window %lx ", pointer, window));
d1312 17
a1328 5
    window->Pointer = pointer;
    window->PtrHeight = height;
    window->PtrWidth = width;
    window->XOffset = xoffset;
    window->YOffset = yoffset;
a1329 2
    setWindowPointer( window, (struct MousePointer *)&window->Pointer, FALSE );

a1332 15
/*** intuition.library/ClearPointer ***/

ClearPointer(window)
struct Window *window;
{
    DSP( printf("ClearPointer window %lx\n", window));

    window->Pointer = NULL;
    window->PtrHeight = 0;
    window->PtrWidth = 0;

    setWindowPointer( window, NULL, FALSE );
    DSP( printf("end ClearPointer\n"));
}

d1334 5
a1354 1
    ULONG retval = 0;
d1364 4
a1367 6
	    if ( !setPointerClassAttrs( cl, newobj, msg ) )
	    {
		/* Fail and die */
		CoerceMessage( cl, newobj, OM_DISPOSE );
		return( NULL );
	    }		
d1373 2
a1374 2
	/* ZZZ: Doesn't free previous bitmap!!! */
	return( setPointerClassAttrs( cl, o, msg ) );
d1376 1
d1378 1
a1378 7
	if ( ((struct MousePointer *)o)->xmpt_AllocBM )
	{
	    FreeBitMap( ((struct MousePointer *)o)->xmpt_BitMap );
	}
	SSM( cl, o, msg );
	return( 1 );

d1380 1
a1380 2
	SSM( cl, o, msg );
	return( 1 );
a1390 1
LONG
a1397 1
    LONG		success = TRUE;
a1400 1
    struct BitMap	*AllocBitMap();
d1405 1
d1408 1
a1408 7
	case POINTERA_SpriteData:
	    mpointer->xmpt_BitMap = NULL;
	    mpointer->mpt_PointerData = (UWORD *)tidata;
	    mpointer->xmpt_AllocBM = FALSE;
	    break;

	case POINTERA_UseBitMap:
a1409 29
	    mpointer->mpt_PointerData = NULL;
	    mpointer->xmpt_AllocBM = FALSE;
	    break;

	case POINTERA_CopyBitMap:
	    {
		LONG sizex, sizey;

		/* ZZZ: Should I use GetBitMapAttr() to get BMA_HEIGHT
		 * and BMA_DEPTH?
		 */
		sizex = GetBitMapAttr( ((struct BitMap *)tidata), BMA_WIDTH );
		sizey = ((struct BitMap *)tidata)->Rows;
		if ( mpointer->xmpt_BitMap = AllocBitMap( sizex, sizey,
		    ((struct BitMap *)tidata)->Depth,
		    BMF_MINPLANES,
		    ((struct BitMap *)tidata) ) )
		{
		    BltBitMap( ((struct BitMap *)tidata), 0, 0,
			mpointer->xmpt_BitMap, 0, 0,
			sizex, sizey, 0xC0, ~0, 0 );
		    mpointer->xmpt_AllocBM = TRUE;
		}
		else
		{
		    success = FALSE;
		}
		mpointer->mpt_PointerData = NULL;
	    }
a1426 10

	/* ZZZ: Width/Height only needed temporarily */
	case POINTERA_Width:
	    mpointer->mpt_Width = tidata;
	    break;

	/* ZZZ: Width/Height only needed temporarily */
	case POINTERA_Height:
	    mpointer->mpt_Height = tidata;
	    break;
a1428 1
    return( success );;
a1448 434
















#if 000
/* storage for a 'pheight' tall sprite, two uwords (4 bytes) per row,
 * plus two rows for top and bottom
 */
#define SPR_STORAGE( pheight ) 	(( (pheight) + 2 ) << 2)

/*
 * will reuse data buffer IBase->DefPointer if it's large
 * enough.  Will realloc() if not.  ZZZ: Might want to
 * free a huge pointer buffer if new pointer is half its
 * height or something.
 *
 * Note that initial allocation works if both DefPointer and DefPtrBufSize
 * are zero.
 */
OLDsetDefaultPointer( pdata, pheight, hotx, hoty, attached )
UWORD	*pdata;		/* pointer data		*/
int	pheight;	/* pointer height	*/
WORD	hotx;
WORD	hoty;
UWORD	*attached;	/* attached pointer data		*/
{
    struct IntuitionBase	*IBase = fetchIBase();
    UWORD			sprstorage;	/* storage for *one* sprite */
    UWORD			newbuffsize;
    UWORD			*newbuff = NULL;
    UWORD			*oldbuff = NULL;
    UWORD			oldbuffsize;

    DP( printf("pdata %lx, pheight 0x%lx, hotx/y %ld/%ld, attach %lx\n",
	pdata, pheight, hotx, hoty, attached ) );

    /* use this lock to keep setMousePointer from pointing
     * at free memory
     */
    LOCKVIEW();

    /* allocate enough data for attached sprite and normal
     * one, contiguously.  Note that I calculate and store
     * "larger"
     */
    newbuffsize = (sprstorage = SPR_STORAGE(pheight)) * ( attached? 2:  1 );
    DP( printf("sDIP: pheight %ld, newbuffsize %ld\n", pheight, newbuffsize ));

    /* see if the new pointer will fit in the existing
     * chipmem buffer
     */
    if ( newbuffsize > IBase->DefPtrBufSize )
    {
	DP(printf("sDIP old ht %ld, newht %ld\n", IBase->DefPtrBufSize,pheight));

	if (!(newbuff=(UWORD *)AllocMem( newbuffsize, MEMF_PUBLIC+MEMF_CHIP)))
	{
	    DP( printf("failure to get pointer buff ht: %ld\n", pheight ) );
	    goto OUT;	/* failure: stick with old pointer	*/
	}

	/* WARNING: don't free the sprite that's being used
	 * until we've switched over, so remember ...
	 */
	oldbuff =  IBase->DefPointer;
	oldbuffsize = IBase->DefPtrBufSize;
	DP(printf("old buff %lx, oldbuffsize %ld\n",oldbuff,oldbuffsize));

	IBase->DefPointer = newbuff;
	IBase->DefPtrBufSize = newbuffsize;
    }

    /* now I know that there is enough storage for a copy
     * of the new pointer
     */
    CopyMem( pdata, IBase->DefPointer, sprstorage );
    IBase->DefPtrHeight = pheight;
    IBase->DefPtrXOffset = hotx;
    IBase->DefPtrYOffset = hoty;

    if ( attached )
    {
	DP( printf("set up attached sprite.\n") );

	IBase->AttachedSSBuff.posctldata = (UWORD *)
		(((UBYTE *)IBase->DefPointer)+sprstorage);
	CopyMem( attached, IBase->AttachedSSBuff.posctldata, sprstorage);

	DP( printf("attached sprite at %lx, data at %lx\n",
		&IBase->AttachedSSBuff,
		IBase->AttachedSSBuff.posctldata ));

	IBase->AttachedSSBuff.posctldata[1] |= SPRITE_ATTACHED;
	IBase->AttachedSSBuff.height = pheight;
	IBase->AttachedSSBuff.x = 0;
	IBase->AttachedSSBuff.y = 0;
	IBase->AttachedSSprite = &IBase->AttachedSSBuff;
    }
    else
    {
	if ( IBase->AttachedSSBuff.posctldata )
	{
	    IBase->AttachedSSBuff.posctldata[1] &= ~SPRITE_ATTACHED;
	}
	IBase->AttachedSSprite = NULL;
    }

OUT:
    DP( printf("sDIP out\n"));
    UNLOCKVIEW();

    DP( printf("1 ") );

    /* use the new pointer, if applicable */
    setMousePointer();

    DP( printf("2 ") );
    if ( oldbuff )
    {
	DP( printf("3 ") );
	WaitTOF();	/* make damn sure sprite not being used */
	DP( printf("4 ") );
	FreeMem( oldbuff, oldbuffsize );
    }
    DP( printf("sDIP done\n"));
}


/* Select the mouse-pointer to use based on the IBase->ActiveWindow.
 * Mouse-pointer is set to default if window is NULL, or if
 * window->Pointer is NULL.
 */

OLDsetMousePointer()
{
    USHORT *IP;
    SHORT IPH, xoff, yoff;
    struct IntuitionBase *IBase = fetchIBase();
    struct Window *w = IBase->ActiveWindow;

    /* protect against using freed data changed by setDefaultPointer */
    /* need LockIBase since we call updateMousePointer() which needs IBase lock */
    LOCKIBASE();
    LOCKVIEW();

    /** fix for mouse jumping
     * works "most of the time".
     * use the viewport of the window being activated
     * to pass to ChangeSprite.
     * Might see jump if a window is activated programmatically
     * while the sprite is not within the window's screen viewport.
     * But it should fix all cases where you click-activate a window.
     */

    if ( (w != NULL) && (w->Pointer != NULL))
    {
	IP = w->Pointer;
	IPH = w->PtrHeight;
	xoff = w->XOffset;
	yoff = w->YOffset;
    }
    else
    {
	IP = IBase->DefPointer;
	IPH = IBase->DefPtrHeight;
	xoff = IBase->DefPtrXOffset;
	yoff = IBase->DefPtrYOffset;
    }

    IBase->SimpleSprite->height = IPH;


    /* attach new pointer? */
    /* we only attach intuition pointer */

    if ((IBase->DefPointer == IP) 	/* new pointer is ours */
	&& (IBase->AttachedSSprite != NULL)	/* want attached */
	&& !IBase->GotSprite1)		/* haven't already got */
    {
	IBase->GotSprite1 = ( GetSprite(IBase->AttachedSSprite, 1) != -1 );
    }

    /* we only unattach intuition pointer */
    /* Free if we have the sprite and the new pointer isn't our own */
    if (IBase->GotSprite1 &&
	((IP != IBase->DefPointer)||(IBase->AttachedSSprite == NULL)))
    {
	FreeSprite(1);
	IBase->GotSprite1 = FALSE;
    }
	    
    IBase->APointer = IP;
    IBase->AXOffset = xoff;
    IBase->AYOffset = yoff;

    DSETM( kpause("calling updateMousePointer()") );

    updateMousePointer(TRUE);	/* perhaps wrong for initIntuition() */
    UNLOCKVIEW();
    UNLOCKIBASE();
}


/* jimm: 6/25/86: made screenMouse() and windowMouse() procedures,
 * so that I can call them for new screens and windows
 */

OLDupdateMousePointer( change )
BOOL change;
{
    struct Screen *s;
    struct Screen *mouse_screen = NULL;
    struct ViewPort	*mousevp = NULL;
    struct Window *w;
    struct Point  spritepos;
    struct Screen *prevscreen = NULL;

    struct IntuitionBase *IBase = fetchIBase();

    DUPM( dumpPt( "rm: in", IBase->Mouse ) );
    limitPoint( &IBase->Mouse, &IBase->MouseLimits);
    DUPM( dumpPt( "rm: after limit", IBase->Mouse ) );

    spritepos = IBase->Mouse;

    assertLock("updateMousePointer", IBASELOCK ); /* maybe I don't need to lock */

    LOCKIBASE();

    /* maintain the old MouseX/Y	*/
    /* too bad, eh?	*/
    IBase->MouseY = IBase->Mouse.Y / IBase->MouseScaleY;
    IBase->MouseX = IBase->Mouse.X / MOUSESCALEX;

    ICOLOR( CKCOLOR8 );

    for ( s = IBase->FirstScreen; s; s = s->NextScreen )
    {
	screenMouse( s );

	/* keep track of first visible screen higher than mouse pos */

	/* Only consider visible screens */
	if ( !TESTFLAG(s->ViewPort.Modes, VP_HIDE ) )
	{
	    if ( !prevscreen )
	    {
		/* In the event that the mouse is below the first visible
		 * screen, that's the screen that the mouse must be in
		 */
		prevscreen = s;
	    }

	    if ( s->MouseY >= 0 )
	    {
		/* Peter 4-Dec-90:  The mouse_screen will be the screen that
		 * contains the mouse hotspot.  In the event that the hotspot
		 * is located in the interscreen gap, we use the previous
		 * screen.
		 */
		if ( !mouse_screen )
		{
		    DUPM2( printf("s->MouseY: %ld, s->ViewPort.DHeight %ld\n",
			s->MouseY, s->ViewPort.DHeight) );
		    DUPM2( printf("IBase->AYOffset * XSC(s)->SpriteFactor.Y %ld\n",
			IBase->AYOffset * XSC(s)->SpriteFactor.Y) );
		    if ( ( s->MouseY - s->ViewPort.DHeight ) >
			    -( IBase->AYOffset * XSC(s)->SpriteFactor.Y ) )
		    {
			/* Hot spot is below this screen and so is the pointer's
			 * top line, so we must use the previous visible screen
			 */
			DUPM2( printf("Mouse in previous screen %lx\n", prevscreen) );
			mouse_screen = prevscreen;
		    }
		    else
		    {
			/* Hot spot is in this screen, or if it's below, then
			 * at least the top line of pointer-data is in.
			 */
			DUPM2( printf("Mouse in this screen %lx\n", s) );
			mouse_screen = s;
		    }
		}
	    }
	    prevscreen = s;
	}

	for ( w = s->FirstWindow; w; w = w->NextWindow ) windowMouse( w );
    }

    if ( !mouse_screen )
    {
	/* When dragging a rear screen behind a front screen, the rear
	 * screen's ViewPort can end up hidden even when the mouse's
	 * y is above the front screen.  In that case, we really want
	 * the mouse's screen to be the topmost one we saw.
	 */
	mouse_screen = prevscreen;
    }
    ICOLOR( CKCOLOR9 );

    /* figure out where to put the pointer sprite	*/

    LOCKVIEW();	
    /* jimm: ZZZ: trying to synchronize changes to
     * view mode in MakeScreen with copper list changes 
     */

    if ( mouse_screen )
    {
	spritepos.X = IBase->AXOffset * XSC(mouse_screen)->SpriteFactor.X;
	spritepos.Y = IBase->AYOffset * XSC(mouse_screen)->SpriteFactor.Y;

	spritepos.X += mouse_screen->MouseX;
	spritepos.Y += mouse_screen->MouseY;
	mousevp = &mouse_screen->ViewPort;
    }

    UNLOCKIBASE();

    DUPM( printf("rM: spritepos.X = %ld, IBase->X: %ld\n",
	spritepos.X, IBase->Mouse.X ) );

    ICOLOR( CKCOLOR10 );

    DDF( if ( IBase->DebugFlag & IDF_SPRITE ) {
	printf("movesprite to: %ld, %ld\n", spritepos.X,spritepos.Y );
	printf("mouse screen: %lx\n", mouse_screen ); });

    if ( change )
    {
	struct SimpleSprite *spr = IBase->SimpleSprite;
	ChangeSprite( mousevp, spr, IBase->APointer );

	if ( IBase->GotSprite1 )
	{
	    /* We must do the initial MoveSprite() on the attached guy.
	     * Thereafter, it moves in step.
	     */
	    DUPM( printf("move attached guy\n") );
	    MoveSprite( mousevp , IBase->AttachedSSprite,
		spr->x, spr->y);
	}
    }

    if ( mouse_screen )
    {
	MoveSprite( mousevp, IBase->SimpleSprite, spritepos.X, spritepos.Y );
    }
    DUPM( else printf("no mouse_screen\n") );
    UNLOCKVIEW();
}


OLDSetPointer(window, pointer, height, width, xoffset, yoffset)
struct Window *window;
USHORT *pointer;
int height, width, xoffset, yoffset;
{
    struct IntuitionBase *IBase;

    DSP( printf("SetPointer %lx for window %lx ", pointer, window));

    IBase = (struct IntuitionBase *)fetchIBase();

    window->Pointer = pointer;
    window->PtrHeight = height;
    window->PtrWidth = width;
    window->XOffset = xoffset;
    window->YOffset = yoffset;

    /* ZZZ: May not be good enough */
    XWINDOW(window)->MousePointer = ((struct MousePointer *)&window->Pointer);

    /*** lockIBase(ISTATELOCK); ***/	/* protect ActiveWindow */
    Forbid();
    if (IBase->ActiveWindow == window)
	{
	setMousePointer();
	}
    Permit();
    /*** unlockIBase(ISTATELOCK); ***/

    DSP( printf("done.\n"));
}


OLDClearPointer(window)
struct Window *window;
{
    struct IntuitionBase *IBase;
    IBase = (struct IntuitionBase *)fetchIBase();

    DSP( printf("ClearPointer window %lx\n", window));

    window->Pointer = NULL;
    window->PtrHeight = 0;
    window->PtrWidth = 0;


    /* ZZZ: May not be good enough */
    XWINDOW(window)->MousePointer = NULL;

    /*** lockIBase(ISTATELOCK);	 ***/ /* protect ActiveWindow */
    Forbid();
    if (IBase->ActiveWindow == window)
	{
	setMousePointer();
	}
    Permit();
    /*** unlockIBase(ISTATELOCK); ***/
    DSP( printf("end ClearPointer\n"));
}

#endif






@


39.0
log
@Initial RCS check-in.
@
text
@d5 1
a5 1
 *  $Id: $
d12 1565
@
