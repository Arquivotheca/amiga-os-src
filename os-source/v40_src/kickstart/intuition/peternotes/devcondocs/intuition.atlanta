	Intuition V2.0 Documentation Update
	    Jim Mackraz, June 1990

This document provides an overview of Intuition V2.0, that is,
intuition.library version 36.

It supercedes information provided at earlier Developer's Conferences
and with alpha and beta releases.

We only provide an quick overview of the various topics here.  Detailed
specifications for new features are provided by the accompanying "autodocs"
for intuition.library, and by the Intuition include files.

The major sections of this document are:
	    General Information
	    Changes to Windows
	    Changes to Screens
	    Gadgets
	    Requesters and System Requesters
	    IDCMP and Event communication
	    Images
	    Public Screens
	    Intuition Classes, "boopsi"
	    Intuition States
	    The New Look
	    Menus
	    Miscellaneous Items
	    New User Controls
	    About the Demos and Examples


General Information

###
TagItem Structures and Tag Lists

Throughout the operating system, a new parameter and storage mechanism
has been introduced.  Defined in the include file utility/tagitem.h,
and supported by routines in utility.library, arrays of tagged data items
are used in several places in Intuition to specify attribute/value pairs
to functions such as OpenWindow(), OpenScreen(), and new functions such
as SetGadgetAttrs().

In C, a tagged data item is a TagItem structure, defined below.
The field ti_Data often contains 32 bit data which is cast to a ULONG.

    struct TagItem
    {
	ULONG	ti_Tag;		/* identifies the type of this item	*/
	ULONG	ti_Data;	/* type-specific data, can be a pointer	*/
    };

A "tag list" is an array or chain of arrays of TagItem structures,
specifying a set of attribute/value pairs.

Unless documentation for a particular use of tag lists states otherwise,
you should avoid duplicate ti_Tag entries in a tag list and not make
any assumptions about the order in which tag items in a list are processed.

Within this array, different data items are identified by the value
in ti_Tag.  Items specific to an application have a ti_Tag value
which has the TAG_USER bit set.  System data items which can be used
by any application have a ti_Tag value with TAG_USER bit clear. 
These include:

  TAG_IGNORE - a no-op.  The data item is ignored.
  TAG_MORE   - the ti_Data points to another array of tag items, to
	       support "chaining" of TagItem arrays.
  TAG_DONE   - terminates the tag item array (or chain).
  TAG_SKIP   - ignore the current tag item, and skip succeeding
	       array elements, ti_Data in number.
	     
Note that user tags need only be unique within the particular context 
of their use.  For example, the attribute tags defined for OpenWindow()
overlap numerically with some tag values used by OpenScreen(), but the
same numeric value has different meaning in the different contexts.

You can use tag lists for your own functions.  There are numerous
support functions in utility.library, including FindTagItem(), GetTagData(),
and NextTagItem().  The last is for iterating all the items in a tag
list, and is at the root of almost all the others.

There is also a particularly handy function PackBoolTags() which
collapses the Boolean attributes in a tag list into corresponding bits
in a flag word.  See the autodocs for utility.library for the details.
TagItems are no longer part of Intuition.

###
Passing Tag Lists to System Functions--varargs

You can provide TagItems to functions in several ways.  Functions OpenWindow()
and OpenScreen() support an extension to the structures NewWindow and
NewScreen, respectively, which is a pointer to a tag list of window
or screen attribute specifications.

There are also two new functions OpenWindowTagList() and OpenScreenTagList()
to which you pass a NewWindow and a tag list or a NewScreen and a tag list.

There are also "varargs" versions of these routines implemented in
amiga.lib, OpenWindowTags() and OpenScreenTags().  "Varargs" is a C
term used to indicate a function which takes a variable number of arguments,
such as 'printf'.

As an example, here is a complete code fragment to open a screen
of "text overscan" dimensions ("MoreRows" dimensions):

    screen = OpenScreen( NULL,		/* don't bother with a NewScreen */
		SA_Overscan, OSCAN_TEXT,
		SA_Title, "My Screen",
		TAG_DONE );

This example illustrates the convenience of a varargs interface to
OpenScreen(), and also that Intuition supports a lot of default values
for screen parameters.

Other parameters besides tag lists can be provided to Intuition with
a varargs interface.  The function EasyRequest() takes printf-style
arguments to fill in the "blanks" in printf-style format strings.
There is always a corresponding non-varargs interface underlying
all varargs system calls, in this case EasyRequestArgs().

The name variations distinguishing two similar functions differing
only by a varargs interface are not consistently applied, unfortunately.

###
Function Callback Hooks

Another standard piece of technology used in various places by Intuition
is the standard application-callback interface implemented by the Hook
data structure.  These are defined in utility/hooks.h, and specify
a register-based parameter convention.  Examples of calling through
a hook and being called via a hook are provided in the Intuition
examples.

There were already mechanisms such as interrupts and input handlers
where the system calls user code but the interface to high-level languages
(HLL's) is rarely standardized.  The goals of Hooks include:

o Standard calling conventions are respected by using a register parameter
  convention.  Any language which can implement an interrupt handler
  should be able to support Hooks.

o A single assembly language interface routine can be used to interface
  to several HLL hook routines.

o A standard method of specifying HLL entry points is used so that
  portability of HLL implementations between compilers is possible.

o Future enhancement of the technique is possible.

###
IntuitionBase and Private Data

As promised, the non-public portion of the IntuitionBase data structure
was completely revised for this version of Intuition.  There is no
public information on what it has turned into, nor how it is used.

Likewise, new additional data for Screen and Window structures has been
added without publication in public include files.  If there is some
chore your application cannot accomplish without accessing private
data, you are invited to request proper programmatic access to it in
the next release.

###
The New Look, DrawInfo, and Pen Specifications

As will be discussed below in a little more detail, the new look
of Intuition displays is centered around a per-screen data structure
called a DrawInfo.  This structure encapsulates all information that
Intuition uses for rendering the new look, including specification of
which pen numbers are used for "shadow", "shine", and "text".  Screen
resolution values are also contained as is other useful information.

See the definition of struct DrawInfo in intuition/screens.h.

###
Stack Swapping

With the introduction of "New Look" system requesters, the function
AutoRequest() started using considerably more processor stack than
it had in previous versions of Intuition.  This caused some severe
and frequent problems, so code was installed to switch stacks
(unconditionally) when AutoRequest() and EasyRequest() (and their ilk)
are called.

It turned out that both DOS and the File System had identical code to
guarantee safe stacks before calling these routines, so the system enjoyed
a net shrinkage in ROM space by centralizing this code in Intuition.


###
Changes to Windows

The most important new change is the addition of a tag list specification
to OpenWindow(), via either the structure ExtNewWindow or the new
functions OpenWindowTagList() and OpenWindowTags().

See intuition/intuition.h for a complete list of window attribute tags, and
the autodocs for detailed explanation of their uses.

Windows borders are rendered quite differently in V2.0, as you've undoubtedly
noticed.  The entire border region (define by BorderLeft, BorderTop, etc.
fields in the Window structure) is redrawn every time a window becomes
active or inactive.

The colors used are different than the DetailPen and BlockPen which specified
the colors under V1.3 and previous.  We'll describe more about this later.

Windows can now open on "Public Screens", about which more later.  Such
windows are called "Visitor Windows."  There are several ways to open
a visitor window on a public screen, including all windows which open
on the Workbench screen, which are now deemed to be visitors.

Windows support a "Zoom" capability, via a "window zoom gadget" which
replaces one of the old depth gadgets and an Intuition function named
ZipWindow() (the author has never been really happy with the term
"zoom", or "zip" for that matter).

Intuition's "zooming" consists of storing the current position and dimensions
of the window, and changing them to the alternate values previously
saved for the last "zoom".  So it's really a swap between "current" and
"other" dimensions and position.

You can specify your choice for the initial "other" dimensions and position
when you open your window.

Besides ZipWindow(), other new functions which operate on windows are:

  ChangeWindowBox() - specify simultaneous position and dimension
	change for a window, in absolute (not "delta") coordinates.

  MoveWindowInFrontOf() - brings the function of the equivalent
	layers.library routine out to the Intuition user.

###
Window Refreshing Procedures

We've certainly learned a lot about refreshing window damage over the
last couple of years, mostly that there are some subtle problems.

In particular, the BeginRefresh/EndRefresh transaction has some
serious windows of vulnerability, with failures manifesting themselves
as partially refreshed window visuals.  The standard simple usage
of these functions doesn't cause problems, but using more than one
refresh "session" (passing FALSE to EndRefresh()), refreshing
through mutiple user clip-regions, and needing to hold a layer lock
around the refreshing session all require that you do things just right.

All Intuition programmers, experts included, should reread the
autodocs for BeginRefresh() and EndRefresh() to become advised of
our current understanding of their best use in tricky situations.

###
Window Layer Backfill

Intuition provides access to the new "backfill hook" supported
by layers.  That means that you can specify a routine which will
be called when damage to your window is to be filled in, rather than
the default "blast to color 0".

You can provide your replacement hook to OpenWindow(), so that your
window will initially be filled in by your own backfill processing.

This supports pattern backfill in windows, and even "null" backfill,
which yields windows which can be opened on a custom bitmap screen without
corrupting the picture already contained in the bitmap, for example.

###
More Window Features

As the autodocs for OpenWindow() explain, you can specify the
dimensions of the interior of your window--that is, within the border--and
let Intuition add on whatever it will for the borders to arrive at
the total window dimensions.  

This is best coupled with the new AutoAdjust option for OpenWindow(), which
grants Intuition permission to slide or shrink your window dimensions
to insure a legal initial position and dimension.

We used up all the Window.Flags bits, and there's a new field Window.MoreFlags
that will have to last us for a while.  The only flag yet defined for
that field is not yet documented, tested, or completely supported at
this time, but it has something to do with the "Help" key and menus.


Changes to Screens

OpenScreenTagList() is the preferred method for passing tag lists
when creating a new custom screen.  The tag list method is more
frequently useful for screens than windows, since so many screen
attributes have reasonable default values.

See the autodocs for OpenScreen() and the include file intuition/screens.h
for all the details.

###
New Screen Display Modes

We support many new screen modes in V36, and the major change is that
the display mode specifier is now an abstract 32-bit "ID Key" defined
in graphics/displayinfo.h and which serves as an index into the
new Graphics library display database.  See the accompanying documentation
of this database and new graphics display capabilities.

Programs which perform direct and on-the-fly manipulations of screen
viewports are supported as best we could.  Flying mode changes, poking
of viewport and view offsets, and every other trick we could detect
on our development and test equipment are snooped out and accommodated.

Our goal was that most tricks that worked on the original Amiga display
modes would continue to work on those old modes, but new, updated
processing would be required to manipulate the new modes.

In particular, the high-order bits of the CAMG ILBM chunk are now
relevant, but we try to support old programs using new modes
by arranging that a reasonable substitute for a new mode be used
if an old ILBM display program tries to display a picture saved
in one of the new modes.

It is also possible for a machine configured for NTSC to open a
PAL screen, including a PAL Workbench screen, and vice-versa.

But it is important to remember that the Workbench being in
PAL mode does not imply that the default display modes are all
going to be PAL.

In fact, there is not currently support for "tricking" a program
that assumes that default operations are PAL into opening a PAL
screen on an NTSC machine, and vice-versa.

###
Screen Coexistence and Coercion

The original Amiga display modes can all be displayed simultaneously
in separate screens (with some global considerations for interlace).

Some of the new modes necessarily exclude the possibility of showing
other screens in their intended mode.  For example, the A2024 special
modes cannot be displayed simultaneously with anything else, including
each other.

New "31KHz scan rate" screens require that the monitor run at a different
sync rate (and beam speed) than the old modes, and you cannot drastically 
change the monitor scan rate mid-frame.

Intuition manages these problems first by decreeing that the frontmost
screen will be displayed in its intended mode.  Other screens behind
it will be excluded, i.e. not visible, if necessary, as is the
case with A2024 special modes and everything else.  (There might
be an interesting bug in current software with this.)

Sometimes, Intuition will provide an alternate, or coerced, display mode
for a screen behind so that it can coexist with the frontmost screen.
In doing this, severe aspect ratio distortion can occur for the screens
behind.  Intuition can sometimes compensate for this by switching to
a higher resolution pixel rate at the sacrifice of some colors, or
by introducing interlace to shorten the vertical size of pixels.

These two operations can be independently disabled via the new IControl
preferences tool.

###
Scrolling, Display Clip, and Auto-Scroll

Direct support for hardware screen scrolling has been added by taking
advantage of the flexible display capabilities of the Amiga.  You may
now define a raster larger than can be displayed and scroll that raster 
through an on-screen viewable region.

In this setup, the screen dimensions reflect the raster dimensions and 
the on-screen region is defined by a new construct named DisplayClip.
The specification of DisplayClip may be made via OpenScreen(), but this
is typically only necessary in an overscan situation.

Note that when you specify an alternate DisplayClip region--whether it is
a standard one using SA_Overscan or a specific value such using SA_DClip,
--the values STDSCREENWIDTH and STDSCREENHEIGHT both are relative to the 
DisplayClip.  That is, they evaluate to its width and height, respectively.

This makes it simpler to do overscan.  By specifying OSCAN_STANDARD as the 
data item in the SA_Overscan tag and setting an appropriate width and 
height to STDSCREENWIDTH and STDSCREENHEIGHT you can automatically
create overscan displays.  In fact, you are even relieved of the
burden of specifying proper LeftEdge and TopEdge values in some
cases.  See the autodoc for OpenScreen().

Two other important scrolling features have been added.  Screen and 
DisplayClip positions may take negative values to effect scrolling up and 
left from the default position.  Also, automatic scrolling to follow the mouse 
is now supported.  There are two ways to do this: by using the MoveScreen() 
function in your application or by using direct Intuition support by setting 
the AUTOSCROLL flag in your NewScreen structure.

###
GetScreenData()

This function has served two useful roles:

o Provide information about the Workbench screen for programs
  about to open a window on that screen

o Provide information about the Workbench screen for programs
  which wish to open a similarly configured custom screen.

If the Workbench screen is in one of the new display modes, this latter
purpose is not going to be well-served, especially since the screen's
viewport has only sixteen bits of Mode information and the new modes
must specify 32 bits.

To the extent that we don't jeopardize the first purpose, there have
been some intense tricks applied to this function in support of the
second.  Also, large scrolling Workbench screens have "tricked" programs
which use GetScreenData() into opening excessive 2400x1200 pixel windows.

You'll want to read the autodocs for GetScreenData() carefully, then
use LockPubScreen() as its replacement in V36 and later.

###
Screen Colors

You can now specify, using the screen attribute tag SA_Colors, a set
of color palette entries to be applied at by OpenScreen().  This
relieves you from the burden of having to call LoadRGB4() for your
screen, and eliminates unsightly color flashing when you do.

The initial palette for new screens is determined largely by
the graphics function GetColorMap(), but Intuition has always overridden
colors 0-3 (playfield colors) and 17-19 (sprites, and sometimes playfield)
with values from preferences.

Intuition now maintains 32 screen color preferences values which it
will use for deeper Workbench screens and (our little secret) 15
color pointer sprites.

To apply these colors to all new screens would be incompatible, so you
must specify the Boolean screen attribute SA_FullPalette if you want
your screen color map to be initialized to all the colors that Intuition
ever maintains.

###
Public Screens

There's a section below that describes the details of the new public
screens protocols.  For now, be advised that the details are contained
in the autodoc for OpenScreen().

###
DrawInfo, Pen Specifications, and the New Look

We'll talk more about the new look below, but the big news is that
it could not be safely applied to all custom screens.  In particular,
ignoring the DetailPen and BlockPen designations for window border
colors was not sound.

As a result, V36 does not apply the full "3D new look" effect on
custom screens unless they so specify (as described below).  Instead,
it uses a version of it's "monochrome scheme" applied in the screen's
DetailPen and BlockPen.

Rendering for the new look uses information encapsulated in the
DrawInfo structure of each screen.  You may acquire a pointer to
this data by calling GetScreenDrawInfo().  In that data, there is
an array of pen numbers used for different drawing purposes, including
3D shine and shadow, highlighted window borders, text, text in highlighted
borders and so on.

You may specify replacement values for those pen specifications (sometimes
called "pen specs" in the documentation) using the screen attribute
SA_Pens.  You may specify many, a few, or zero pens using this tag.

Intuition will take the presence of this tag to mean that you are a
new custom screen, aware of the new look, and will set the DRIF_NEWLOOK
flag in your screen's DrawInfo structure, and give windows in your
screen the complete full-blown 3D new look treatment.

###
Miscellaneous Screen Changes

Here are a few small items:

o You can pass the pointer to a longword using the SA_ErrorCode tag,
  and Intuition will provide in that longword a detailed error code
  to supplement the NULL screen pointer it returns in the event of
  failure.  The defined error codes today are:

  OSERR_NOMONITOR	named monitor spec not available
  OSERR_NOCHIPS		you need newer custom chips
  OSERR_NOMEM		couldn't get normal memory
  OSERR_NOCHIPMEM	couldn't get chipmem
  OSERR_PUBNOTUNIQUE	public screen name already used
  OSERR_UNKNOWNMODE	don't recognize mode asked for

  You should also assume that there will be more error codes defined
  in the future, and allow for codes your program doesn't understand.

o SCREENQUIET is really quiet.
  The menu bar layer no longer blasts out a clear region in the
  custom bitmap of a SCREENQUIET screen.  It is created with a "null"
  layer backfill hook.  SCREENQUIET screens are finally completely "quiet".

o Multiple System Font Selections
  When opening a screen, you can specify a font as a pointer to a
  TextAttr structure.  If you provide none, your screen's default font
  will be the current graphics default font (GfxBase.DefaultFont),
  which is maintained by old and new preferences to be some safe,
  non-proportional conservative font that all programs should be
  able to handle even if it is no longer only topaz.font size 8 or 9.

  We also maintain via preferences a new font selection by the user,
  the "default (fancy) screen font", which is often proportional-space
  and taller than normal.  You can select this font to be
  your screen font (as does the Workbench screen) by using the
  SA_SysFont attribute tag and providing the ti_Data value of 1.

  When a proportional font is used as a screen font, though, we run
  into problems when the windows opening on that screen, esp. the
  Workbench screen, inherit the screen font in their rastport.

  We've found only a few text-oriented programs that work when
  they are surprised with a proportional font.

  So, we modify an old rule to have an exception:

  "The windows opening on a screen will have as their default font
   the font of the screen, unless when the screen opened its font
   was specified as this new preferred screen font.  In that
   case, newly opened windows will have their RastPort initializedd
   with the system (monospace) default font.
  

Gadgets

There is change in the behavior of NewModifyProp() to minimize
redraw flashing when a gadget is updated.

There is also a separate document about custom gadgets and
object-oriented (boopsi) gadget classes, group gadgets, and so on.

There's a list of the pre-defined gadget classes in the "boopsi"
section below.

The rest of this section is about string gadgets.

###
String Gadgets

String gadgets have numerous enhancements, most specified by additional
data defined in the StringExtend structure, defined in the include
file intuition/sghooks.h.  The most significant work was done in
the support of proportional fonts.

The new specifications include the font, the pens, optionally
different pens for use when the gadget is active, new editing modes
including REPLACE mode and FIXEDFIELD mode.

You may also provide a hook which can be used to intercept Intuition's
default input processing for the gadget, allowing custom editing.

See the example StrDemo on the DevCon disks, and the contents
of intuition/sghooks.h for details.

Note that late in the development of V36, two new features were added
to this custom editing hook:

o Your hook is now called to process mouse click input, not just typing.

o Your hook is passed an "edit operation code" so you don't have to
  guess whether Intuition's intentions were to delete or insert a
  character, delete to beginning, or whatever.

There is a function which can be used to replace the global editing
processing that Intuition does by default for all string gadgets.  This
function is SetEditHook(), but this feature has never been exercised
to the knowledge of the author.  This function should therefore
not be used in a commercial product until further notice.

If anybody ever gets it working to provide 'vi-style' editing for
string gadgets, though, the author would greatly appreciate a copy.

For string gadgets which inherit a font larger than they were prepared
to contain, Intuition will "fall back" to Topaz 8.

String Gadgets also have the ability to "filter" control characters
(which are even invisible in some fonts) from being entered into
the text.  This is globally established as a preferences item in 
the IControl preferences tool.

When the filter mode is on, certain control characters are used
as editing commands, consistent where possible with the same keystrokes
used to edit input for the console.

When filter mode is on, the user can still enter the occasional
control character into the text of a string gadget by holding
down BOTH the control and left-Amiga keys when typing a letter.


Requesters and System Requesters

There are some minor enhancements to application requesters (brought up
by the Request() function or as a DMRequest), but the major work
involves system requester which are gotten using the old functions
AutoRequest() and BuildSysRequest() and the new functions EasyRequest()
and BuildEasyRequest().

The new EasyRequest functions provide a 'printf-style' automatic
formatting of system requester text and gadget labels, supports
more than two requester gadgets, and performs automatic font-sensitive
layout of text and gadgets.

Both types of system requesters are now implemented in a fancy "new look"
design, and in the case of old-style AutoRequesters, that happens by
Intuition ignoring a large amount of the layout specifications you provide.

See the autodocs and the Intuition DevCon example EasyReq for several
ways you can use EasyRequesters.

The functions AutoRequest() and EasyRequest() are synchronous, that
is to say, these functions don't return until the requester has
been "satisfied", either by user input or other IDCMP traffic (e.g.,
DISKINSERTED).

For each, there are corresponding functions BuildSysRequest() and
BuildEasyRequest() that return to you a pointer to a window which
contains the system requester.  You may process the input to that
window yourself to gain more control over the request.  An example
might be timing out the request, or like the IPrefs daemon, watching
for circumstances which warrant an automatic "Retry".

The input processing for these windows is not completely trivial, but
it is made very easy by a new function SysReqHandler().  See the
autodocs for some examples of fancy processing made easy.

System requesters have, since V33, popped the screen they appear on
to the front if it was not already frontmost.  This is to alert the
user.  With V36, we will subsequently pop that screen to the back
(NOTE: not "back to where it was") when the requester is satisfied,
providing that the user did not perform manual screen depth arrangement
or open or close other screens in the interim.

###
General Requester Changes

Here are some changes made to general requesters.  Some of these
were introduced to support the new look of system requesters.

o POINTREL now works with Request(), providing a simple method 
  for requesters to appear centered in an application window.

o The new flag SIMPLEREQ specifies that you want your requester
  to be in a simple refresh layer.  Recommended for saving chip
  memory, and avoiding a large transient requirement for chip memory
  when the requester opens.

o A new flag USEREQIMAGE indicates that your requester has a valid
  pointer to a linked list of Intuition Images in the new ReqImage field.
  This list of images will be automatically drawn by Intuition when the
  requester comes up or needs to be redrawn.

  Using boopsi image classes such as fillrectclass, frameiclass, and
  itexticlass is how the sytstem requesters fancy new look is maintained
  without special refresh code.  You can do almost anything with a 
  boopsi image, and hence can have some very fancy requesters which
  are automatically maintained.

o The new flag NOREQBACKFILL specifies that your requester layer
  should have a "null" backfill hook, so that it is not cleared
  before your fancy images described above are drawn.  This is why
  system requesters don't flash before the stipple pattern is drawn.

o There is a limit to the number of requesters that Intuition will
  support for a window, if that window is capable of being moved
  or changed in size.  For V36, that limit is 8.


IDCMP and Event Communication

###
New IDCMP Classes

o CHANGEWINDOW is sent (via IDCMP or through the console) when
  your window position or dimension changes, including changes
  by new functions ChangeWindowBox() and ZipWindow().  It generalizes
  both SIZEWINDOW and the proposed MOVEWINDOW messages.

o IDCMPUPDATE is sent by boopsi gadgets as a more direct connection
  to the internal state changes of custom boopsi gadgets.  See the
  Intuition boopsi examples for comparisons to using this and
  using GADGETUP and FOLLOWMOUSE messages.  In this message, the
  qualifier IEQUALIFIER_REPEAT indicates an "interim" reports, such
  as a button repeating while held down or a slider being dragged
  vs. their being released.  All other qualifiers are meaningless.

o MENUHELP is sent in place of MENUPICK if the user presses the
  Help key while operating a menu.  This is not yet officially supported,
  and requires that an undocumented flag be set.

###
Other Changes

There are now automatic limits to the number of MOUSEMOVE or repeat-key
IDCMP messages that Intuition will send to your window before seeing
some replied.  These limits can be independently set when you open
your window.  The mouse queue limit can be changed using the function
SetMouseQueue().  There is as yet no interface for changing the repeat
queue limit on the fly.

You can set these limit values to -1 to get effectively unlimited
queue or backlog of these messages.

The middle mouse button is now supported, and is transmitted as
new values of the IntuiMessage.Code field for class MOUSEBUTTONS.

If you specify the VANILLAKEY IDCMP Flag, you will receive as always
VANILLAKEY messages for all keyboard downstrokes that translate into
a single byte character code.  But now, if you also specify the
RAWKEY flag, you will receive RAWKEY reports for those downstrokes
which do not map to a single byte.  This makes it easy to process
function keys, the cursor keys, or the Help key, without sacrificing
the convenience of VANILLAKEY messages.

####
Verify Functions Abort

The most common cause of system deadlocks were caused by deadly embrace
around the MENUVERFIFY, SIZEVERIFY, and REQVERIFY messages.  Intuition
used to wait dead for your application's reply to these messages, and
if your program was for some reason waiting for Intuition input before
it would get around to making such a reply, the system would deadlock.

Now, Intuition will time-out these verification transactions after
a user-specified interval, and abort them when the user releases the
relevant mouse button, where that makes sense.

Your program may respond affirmatively to a message like MENUVERIFY
at some time after Intuition has decided to abort.  Your program
will receive whatever termination message it expects subsequently,
even though that might mean sending both a MENUPICK message (which
your program expects after an affirmative response) and a MOUSEBUTTONS/MENUUP
message (expected when you cancel a MENUVERIFY request).

There might be some quirks that can result--in fact there are known
problems (and tested fixes waiting) with the speed of these transactions
and "hanging menu strips"--but we'll have no more deadlocks caused
by this frequent culprit.


Images

We've introduced a few new functions for images, but most of them
aren't too useful for normal old Intuition images.  All the excitement
is about new custom images created from boopsi classes.  There are
examples in the boopsi subdirectory of the Intuition DevCon demo directory.

o DrawImageState() is an enhanced DrawImage() that delegates to the
  image the type of rendering that should be done to represent
  a selected, disabled, or inactive state.  This is useful for
  fancy images attached to fancy gadgets.

o EraseImage() clears out (using the new EraseRect() graphics call)
  the region occupied by an image.

o PointInImage() asks an image whether a particular X/Y point coordinate
  is contained in the image region.  This encapsulates the intelligence of
  things like the BOOLMASK feature of V33 gadgets.

There are some very useful boopsi image classes which you can use to
create new images for your use in gadgets, menus, requesters, or just
to pass to DrawImage() or DrawImageState().  See the boopsi section
for a list.


Public Screens

Many developers and power users have requested support for "shared custom 
screens."  They wish to bring up utilities such as a text editor on an 
application custom screen such as a terminal emulator.  A similar request 
has been made for "multiple Workbench screens" so that Workbench application 
windows can be grouped in separate workspaces and display modes best suited 
for the different Workbench applications that may co-exist.

It turns out that both of these requests can be satisfied by new support in 
Intuition for what we call "public screens."  The complete solution will have
three parts - support within Intuition, a screen manager utility and of course
applications which open the new public screens and their "visitor" windows.

Under the new system, when opening a screen, you may declare your screen a 
public screen by specifying a public name string for it.  You may also 
register your task ID and a signal if you want to be notified when the last 
visitor window on your screen closes.  A new data structure, PubScreenNode, 
will be installed on a system list with links to your public screen.

A public screen has a single mode bit named PSNF_PRIVATE which indicates 
whether the screen is available for public use.   A public screen is 
initialized as private so you can open your personal application windows 
(like a backdrop window) before you make the screen officially public.

Once you have a public screen, visitor windows can be opened on it in 
several ways.  If no screen name is provided, the visitor window will open 
on the default public screen.  If a name is provided, the visitor window 
will open on the named screen if available.  Otherwise a default is used.  
A visitor window can also be opened by using a pointer to the public screen 
obtained with LockPubScreen().  

There are two global mode bits which also come into play when a visitor
window is opened on a public screen.  If the global mode SHANGHAI is set 
Workbench application windows will be opened on the default public screen.
A second global mode bit is POPPUBSCREEN which indicates that a public screen 
is to be moved to the front when a visitor window opens on it.  Both the 
SHANGHAI and POPPUBSCREEN mode bits are intended to be readily controllable 
by the human user, likewise the DefaultPubScreen.

One example of an application using visitor windows will be the public 
screen manager utility.  Its role will be to display the current public 
screens, allow selection of the default and setting of the global modes 
SHANGHAI and POPUBSCREEN.  An important elaboration will be this program's 
ability to open named public screens listed in a configuration file at the 
user's command.

Other special applications of public screens are possible.  One operation
now supported by an Intuition function is "jumping between public screens." 
In this way an application can move between screens in response to a gadget 
or menu item, or in response to a hotkey.

An example program, PubSC, is included on the DevCon disks.  This program
demonstrates the primitive operations now supported by Intuition.  It has 
been greatly improved since early alphas, and is actually a first cut at the 
screen manager utility.  Further information for this topic can be found 
in intuition/screens.h and in the autodoc sections for OpenWindow(), 
OpenScreen() and the new support functions. 

Here's a brief list of the functions:

PubScreenStatus() -- Converts a public screen to private or non-private
		     status.  Fails if you can't make a screen private 
		     because it currently has visitors.  You do this before 
		     you close a public screen.

SetDefaultPubScreen() -- Establishes a given public screen as the default.

GetDefaultPubScreen() -- Returns the name of the default screen for use
			 by the screen manager utility (the name is not
			 needed by normal applications).

SetPubScreenModes() --  Sets new values for the public screen global modes.

NextPubScreen() --  Helps an application cycle its window between the
		    currently available public screens.  Note that the 
		    Workbench screen is a public screen, and will be 
		    included in the rotation.

Lock/UnlockPubScreen() -- Allows to you to determine that a public screen 
			  exists, and to insure its existence while you open 
			  a visitor window on it.  This function also serves 
			  as an improvement over GetScreenData(), as a 
			  fortunate side-effect.

Lock/UnlockPubScreenList() -- Affords protection while you COPY the Intuition 
			      public screen list quickly.  This is intended for
			      use by the public screen manager utility only.


Intuition Classes, "boopsi"

The term "boopsi" is a lower-case acronym for the "Basic Object-Oriented
Programming System for Intuition."  The key word here is "Basic".

Boopsi supports custom gadgets, custom images, grouping of gadgets, and
interconnections between them.  It is also very open-ended, and can
be extended in many directions for general-purpose use.

You can invent boopsi classes which implement the behavior for the
objects they define and create.  Classes can be private, which means
the code for them is linked into your program and you don't have
to worry about names and attribute ID's colliding with other defined
classes.  Classes can also be public, accessed only by their unique
names.  In that case, their attribute ID's must be picked carefully
not to conflict with any others.  This will require a registration
procedure to be implemented by Commodore Applications and Technical
Support.

There is a separate document on boopsi, to which we refer the reader
for all details.  We list here only a summary of the pre-defined
public classes implemented in Intuition, grouped by their "baseclass",
that is, their inherited ancestor closest to the root.

o rootclass
    Ancestor to all boopsi classes, the only class without a superclass.
    Implements basic object memory allocation and nodes.

o gadgetclass
    Ancestor to all boopsi gadget classes, understands most gadget
    attributes.

o propgclass
    A very friendly way to use one-dimensional proportional gadgets,
    including a better way to look at Body and Pot values, and interconnection
    capability.

o buttongclass
    A (repeating) boolean command button.

o frbuttonclass
    A high-powered button for the "new look" which knows how to frame
    its general contents (label) with an embossed box.

o strgclass
    An easy interface to the new extended string gadgets, with
    many attributes easily defined.  Supports interconnection.

o ggclass
    Group-gadget class, this implements a "composite" gadget which
    has other gadgets as its members.  The DevCon demos illustrate
    how you can collect several related gadgets in one of these
    group gadgets and have them all interconnected, sending your
    application an IDCMPUPDATE message only when something of interest
    has changed.

o imageclass
    The common ancestor of boopsi image classes.  Implements most
    image attributes but draws nothing.

o frameiclass
    An embossed or recessed rectangular frame, rendered in the proper
    DrawInfo pens, and with enough intelligence to bound or center
    its contents.

o itexticlass
    A specialized image class implementing something similar to IntuiText.
    This is used by Intuition for forcing the new look on AutoRequesters,
    and for supporting System Requester button gadgets which don't need
    a full IntuiText allocated for them.

o sysiclass
    A class of premade "system images" including all the images
    for the system gadgets, and the gadtools checkmark and button
    glyphs.  These images can be created to specified size, scale,
    and will support all the new look voodoo.

o icclass
    A very simple interconnection node.  Maps one set of attributes
    (understood by something notifying other objects of changes) to
    another set of attribute tags (as understood by the object being
    notified).  The heart of boopsi interconnection, often found
    hanging in a broadcast list.

o modelclass
    A specialization (subclass) of icclass, which adds the notion
    of a broadcast list.  You notify these things of a change, and
    they broadcast that to their whole list, with attribute ID's
    being mapped independently by the ic's hanging on the list
    to what the other interested objects need to hear.
     

The New Look

The new 3D "embossed" look of Intuition window borders and gadgets
is the most obvious major change to Intuition.  It represents a compromise
between our compatibility goals and "giving a little to get a lot" in
the way of major aesthetic rework.

There are actually a couple of different "looks" Intuition will apply
to a given screen and all the windows within that screen.

o The full-blown embossed new look, as found on the Workbench screen.
  This requires that we make certain assumptions about which pens
  to use for different things.  We don't default to this look (anymore)
  for custom screens.  Only applications that run on the Workbench
  will be confronted with these changes at first.

o The monochrome new look.  In a single bitplane (two color) screen, there
  isn't a whole lot of 3D embossing you can get.  We fall back to a simpler
  two-color scheme, with specially designed system gadget images suitable
  for a monochrome presentation.

o "Compatible" custom screen new look.  Normal custom screens are rendered
  in a two-color version of the monochrome new look.  The pens used for
  this rendering are the initial screen DetailPen and BlockPen.  All windows
  are rendered in these same colors.

If you want your custom screen to be given the full-blown new look, you
pass the SA_Pens screen attribute tag to OpenScreen().

###
DrawInfo Structure

All the information needed to render the new look is packaged in a data
structure called DrawInfo associated with each screen.  You manage a
pointer to it by calling GetScreenDrawInfo() and FreeScreenDrawInfo().

We'll discuss the fields in DrawInfo now.  See also the structure and
flag definitions in intuition/screens.h.

o dri_Version - this field is initialized by Intuition to the value
    of the constant DRI_VERSION defined in the version of screens.h
    that Intuition was compiled with.  That means that if you see
    that dri_Version is greater than or equal to the value of DRI_VERSION
    that your program was compiled with, you can be assured that
    any new fields in DrawInfo that are defined are being supported
    by Intuition.

o dri_Font - this is a pointer to the screen's (open and ready to use) font.
    Do not assume that this font will remain open after you call
    FreeScreenDrawInfo().

o dri_Depth - the depth of the screen's bitmap, as provided to OpenScreen.

o dri_Resolution - a pair of numbers gotten from the display info database
    for the (intial) display mode of the screen.  These support simple
    resolution-independent constructs, such as drawing square boxes.
    The values for NTSC HIRES+LACE pixels are X = 22 and Y = 26.

o dri_Flags - there is only one flag now defined, DRIF_NEWLOOK.  If this
   flag is set, the attribute SA_Pens was provided to OpenScreen(), and
   the screen is to get the full-blown 3D new look treatment.

o dri_NumPens - this is the number of pens defined in dri_Pens.

o dri_Pens - this is an array of drawing pens used for different purposes.
	The number of entries is specified above, and the array is terminated
	by 0xffff (~0).

The pens defined are:
    detailPen		- initial value of Screen.DetailPen
    blockPen		- initial value of Screen.BlockPen
    textPen		- text on normal backgroundPen
    shinePen		- bright edge on bas-relief
    shadowPen		- dark edge
    hifillPen		- active window fill
    hifilltextPen	- text over hifillPen
    backgroundPen	- always 0 for now
    hilighttextPen	- highlighted text, against backgroundPen

###
Elements of the New Look

Here is a discussion of the things which make up the new look for V36.

Default pens are defined for multi-color screens and monochrome
(single-bitplane) screens.  The defaults are:

Multi-color screens (using four colors for new look)
    detailPen		=	0
    blockPen		=	1
    textPen		=	1
    shinePen		=	2
    shadowPen		=	1
    hifillPen		=	3
    hifilltextPen	=	1
    backgroundPen	=	0
    hilighttextPen	=	3

Monochrome screens (using four colors for new look)
    detailPen		=	0
    blockPen		=	1
    textPen		=	1
    shinePen		=	1
    shadowPen		=	1
    hifillPen		=	1
    hifilltextPen	=	0
    backgroundPen	=	0
    hilighttextPen	=	1

Old-style custom screens will get defaults the same as monochrome
screens, with "1" and "0" replaced with the initial value of the
screen's BlockPen and DetailPen, respectively.

Window Borders are filled in completely, to the (compatible) dimensions
defined by Window.BorderLeft, Window.BorderTop, Window.BorderBottom,
and Window.BorderRight.  The outer and inner edges of the borders are
drawn in a combination of shinePen and shadowPen, and the rest of
the border is filled with backgroundPen or hifillPen, depending on whether
the window is inactive or active.

Window title text is rendered in textPen and hifilltextPen, again depending
on whether the window is inactive or active, respectively.

After refreshing the borders, Intuition refreshes all border gadgets,
then draws the outline edges of the border again, to win all "border wars."

A gadget is determined to be a "border gadget" first by the presence
of one of the gadget Activation flags RIGHTBORDER, LEFTBORDER, TOPBORDER,
and BOTTOMBORDER.  Applications were not rigorous in setting these flags,
so now Intuition "sniffs out" gadgets which intersect with the border,
and sets a private flag bit so it will know to refresh these gadgets, too.

Gadgets in the border consist of both system gadgets and application
gadgets.  The system gadgets were replaced by new boopsi buttongclass
gadgets, using images from sysiclass.  These gadgets and images know
how to draw themselves in a 3D look or in monchrome, and are sensitive
to whether the window is active or not.

Application gadgets in the border are not generally that advanced, and
they are not drawn differently, except for proportional gadgets.

Proportional gadgets, especially those with AUTOKNOBs, are given a
completely new treatment for the new look, but unchanged (we hope) for
other uses.  A proportional gadget gets the new look if either:

o the proportinal gadget intersects the window the border.
o the new flag PROPNEWLOOK is set in PropInfo.Flags.

The images used for system gadgets respect several of the new image
draw states defined in intuition/imageclass.h, specifically:

o IDS_NORMAL		- what old DrawImage() will yield
o IDS_SELECTED 		- for selected gadgets
o IDS_DISABLED 		- for disabled gadgets
o IDS_BUSY 		- for future functionality
o IDS_INDETERMINATE 	- for future functionality
o IDS_INACTIVENORMAL 	- normal, in inactive window border
o IDS_INACTIVESELECTED 	- selected, in inactive border
o IDS_INACTIVEDISABLED	- disabled, in inactive border

The screen title bar is only partially converted to the new look for
V36: it has a new depth gadget.  The final design will be implemented
later.

###
System Requesters

Requesters created by AutoRequest() and EasyRequest() also get a new treatment.
They are built out of boopsi gadget and image classes, including these:

o gadgets are from frbuttonclass, which uses the image class frameiclass
  shared between all gadgets but stretched suitably for each when
  rendered.

o requester body text is managed by an itexticlass boopsi image.

o the background of the requesters is a fillrectclass object.

o the "sunken" bevelled region for the text is another frameiclass image.


Menus

There was very little enhancement to menus for V36.  No pop-up,
tear-off, or pie-shaped menus.  Sorry.  There were a few things, though:

o ResetMenuStrip() is a new function that serves as a quicker version
  of SetMenuStrip() that can be used only under certain circumstances.
  See the autodoc.

o Menu command-key equivalents are processed through the default keymap
  and use a correct algorithm for caseless comparison that doesn't 
  break down on "international" characters.

o The NextSelect cycles that could prune multiple selections from your
  MENUPICK list have been eliminated.  There is still no solution
  provided to the fact that the NextSelect chain can be severed if
  the user operates the menus before you're done walking the chain.

Miscellaneous Items

Here's a grab-bag of items that can be briefly mentioned.

o Alerts are now green if recoverable, use their own View structure,
  and are always in the topaz 8 font.  They don't clobber each other
  if DisplayAlert() is called more than once, and they never
  smear the sprite any more.

o The intended function for taking over the system, StealI(), was
  not implemented.  I'm really sorry about this one.  Maybe next time.

o Intuition supports taller and deeper system sprites through the
  new Preferences methods.  Our "official" support doesn't extend
  to attached or very tall sprites, but you can use them if you
  know how ...

o RastPort protection.  Intuition is now much better about leaving
  the various RastPorts it uses undisturbed, except for side-effects of
  its use that should be felt.  As an example, PrintIText() will not
  leave any changes to font, pens, or draw mode in the rastport it is
  passed, but it will update the current text position fields, cp_x and cp_y.

o The rectangles drawn for interactive dragging or sizing of windows 
  are now not so terribly clobbered by collisions with the video beam.

o Intuition's uses of DisplayBeep() go through the library vector, so
  if you SetFunction() it to be an audible noise, you'll pick up
  Intuition's uses in string gadget editing, too.

o Mouse emulation is done by adding input events through the input.device
  (and the command IND_WRITEEVENT).  The old method was to provide
  an event of class IECLASS_POINTERPOS, and to specify within that
  event absolute or relative coordinates in some view-relative
  "hires-lace coordinates."

  That wasn't sufficient for new super hires modes, and isn't convenient
  for tablet-driver authors, so we added a new input class (you guessed it)
  IECLASS_NEWPOINTERPOS.  This supports several methods of specifying
  mouse movement commands, including "tablet oriented" range/value
  coordinates within the overall mouse movement boundaries, and
  "screen pixel" coordinates, which makes it trivial to position the
  mouse over some point in your window or screen.

New User Controls

There are some new user interface features that will affect the end user.
Some of them, such as string gadget editing control chars, we discussed
above.  Here are some more:

o The Screen Menu Snap feature brings the upper left corner of a scrolling
  screen into view when operating menus.  If you hold the left-Amiga
  key down when you press the menu button, the screen will stay at
  the snapped position when you release the button.

o Command keys for depth arranging screens (left-Amiga M and N), for
  satisfying system requesters (left-Amiga B and V), and the qualifier
  for dragging screens when the mouse is not over the screen drag bar
  (left-Amiga default) can be set to different values in the IControl
  preferences tool.

o The screen depth keys used to mean "Workbench to front" and "Workbench
  to back".  Now they mean "Workbench to front" and "Frontmost to back"
  which lets you cycle through the screens from the keyboard.

o Keyboard methods to move the mouse (amiga-Arrows) are now much better,
  including moving exactly one pixel per keypress (non-repeating, and in
  the pixels of the active window's screen), and have a slow, predictable
  ramp-up as you hold down the key and it repeats.  While the cursor
  keys are repeating, you can tap the shift key for a burst of acceleration.
  Try it.

o Interactive window dragging and sizing can be aborted by pressing
  the menu key during the operation.

o There is an optional mouse accelerator built into Intuition.  It is
  considerably leaner than the one implemented in earlier alpha and
  beta releases.

o The window and screen depth gadget pairs have been consolidated into
  single gadgets.  When the screen or window is frontmost, selecting
  the gadget sends it to back.  Otherwise, it is brought to the front.

o The window zoom gadget replaces one of the old depth gadgets.

About the Demos and Examples

Many of these demos are familiar from previous devcons, but there
are some pretty good new ones, too.  See the README file for
the standard logical volume "Assigns" that are used to compile
and link these examples.  Some have a makefile, others have
compilation instructions in the source file or the README.

###
PubSC -- Public Screen Demo Program

This program has been completely rewritten since the early alphas.  It is
now an Intuition-based program with command and state gadgets. It includes 
some obsolete but nice gadget and image-building techniques and also adapts 
itself to fonts of various sizes.   It is itself a "visitor" window, and 
will open on the default public screen.

The command gadgets included are Close Screen, Make Default, Open New 
and Jump.  Each command may also be invoked by typing the initial 
character of the gadget label. 

The Close Screen gadget attempts to close the current screen - that is
the public screen that the PubSC window opens on.  It will not attempt
to close the Workbench screen.  The gadget reports failure if it cannot 
close the current public screen because other windows are open on it.

The Make Default gadget requests that the current screen be made the 
default public screen.  This may be selected for the Workbench screen.

The Open New gadget will open a new public screen, named "Phred" .
It will report if screen "Phred" is already open.  If you want to
change the mode or name used you will have to modify the source.
 
The Jump gadget will cause the PubSC window to "jump" from one public
screen to the next.  This is useful if you have a lot of public screens.

The state gadgets establish global Intuition public screen modes.
They are named "Auto Pop-to-front" and "Hijack Workbench."  The former
determines whether a public screen will be moved to the front when
a window opens on it.  The latter determines if application windows
which are intended for the Workbench screen are diverted to the
default public screen.  This allows you to work in multiple Workbench
environments, partitioning your projects and minimizing clutter.
In addition to the state gadgets, PubSC has text displays showing the 
names of the default and current public screens.

The source to PubSC is extremely important for understanding public
screens.  Especially important are the procedures for locking a public 
screen such as the Workbench, adapting a window layout to the screen's
parameters and font, and opening a visitor window.

The PubSC example is font-independent but not yet resolution-independent
although the source shows what needs to be done.  PubSC runs from CLI.

###
ScDemo (formerly SC, also ScreenDemo)  -- Screen Test Program and Demo

This program has been substantially rewritten to take advantage of the
simpler new methods for opening screens in new modes.  The new version
also establishes overscanned screen dimensions.  The program is run from 
the CLI.  Typing '?' will give you the available options.  

Open a few screens.  Typing 'w' opens a wide screen which you can scroll
by dragging the scroll bar or (by pressing left-Amiga-select).  Try
a productivity screen.  With several screens open, try the new cycling 
command left-Amiga-M.

You can close all the screens by typing 'q' for quit or by typing 'f' for 
free screens.  Read the source file sc.c to see the methods for opening the 
various screen modes and dimensions.

###
StrDemo -- Demonstration Of New String Gadgets

This program is run from the CLI.  It opens a new screen, a window,
and several enhanced string gadgets.  This program is most impressive
if you have ruby 12 and 8 in your fonts: directory.

Besides being a test for proportional fonts and a demo for some of the
new capabilities, this program also demonstrates a custom editing hook.
Note that 'TAB' and 'Shift-TAB' will activate gadgets in succession.
The second gadget from the top also has an editing hook.  Pressing
up and down arrow keys cycle through a list of pre-set choices.
Selecting the close gadget in the window terminates the program.

###
CustGad -- Custom Gadget Demo

This program provides a custom gadget example named "Dial Gadget".
It also uses some floating point calculations.  If we had used the 
IEEE math libraries, there would be a problem, since the only 
task that can use the IEEE libraries is the same task that opened them.
This illustrates an important point.

Remember that with custom gadgets the code you provide will be run as 
different tasks, including the input.device.  It is important to limit 
the activity that takes place in the gadget itself, and make more complex
operations occur in response to a GADGETUP or GADGETDOWN message.

###
EasyReq -- Example of Using EasyRequest()

Type "EasyReq" from the CLI and the resulting requester will tell you
how you can experiment with fancy formatting strings and arguments.

When using this demo, all arguments passed to EasyRequest() are
strings (*argv[]), so the only "printf" formatting commands that
makes good sense for the demo is "%s".

###
The boopsi Demos Subdirectory

There is a suite of boopsi examples.  One sequence of demos (demo1, demo2,
demo3, ...) solves the same problem with increasingly sophisticated use
of boopsi gadgets and classes, but with decreasing work required
by the application "main" programming.

There are examples of public and private boopsi class implementations for
gadgets and images, and examples using frame images which bound and
center their contents.

See the README file in that directory.  You will want to have a 9600
baud terminal attached to your Amiga for kprintf output since gadget
and image class code is generally not run as your application's task.
You'll certainly need kprintf output to develop such classes anyway.



