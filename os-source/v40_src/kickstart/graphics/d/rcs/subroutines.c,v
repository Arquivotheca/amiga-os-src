head     39.10;
branch   ;
access   ;
symbols  rel39_24:39.10 rel39_18:39.10 rel39_97:39.8 rel39_90:39.8 rel39_89:39.8 rel39_82:39.8 rel39_76:39.8 rel39_71:39.7 rel39_65:39.7 rel39_64:39.7 rel39_61:39.7 rel39_60:39.7 rel39_55:39.7 rel39_47:39.5 rel39_39:39.4 rel39_38:39.4 rel39_37:39.4 rel39_35:39.4 rel39_34:39.4 V37_30:37.1 V37_29:37.1 V37_28:37.1 V37_25:37.1 V37_22:37.0 V37_21:37.0 V37_20:37.0 V37_19:37.0 V37_17:37.0 V37_15:37.0 V37_14:37.0 V37_13:37.0 V37_12:37.0 V37_11:37.0 V37_10:37.0 V37_9:37.0 V37_8:37.0 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.37 V36_208:36.37 V36_207:36.37 V36_205:36.37 V36_203:36.37 V36_202:36.37 V36_201:36.37 V36_200:36.37 V36_199:36.37 V36_198:36.37 V36_196:36.37 V36_195:36.37 V36_194:36.37 V36_193:36.37 V36_192:36.37 V36_191:36.37 V36_190:36.37 V36_189:36.37 V36_188:36.37 V36_187:36.37 V36_186:36.37 V36_185:36.37 V36_184:36.37 V36_183:36.37 V36_182:36.37 V36_181:36.37 V36_67:36.37;
locks    ; strict;
comment  @*   @;


39.10
date     93.02.15.11.17.09;  author spence;  state Exp;
branches ;
next     39.9;

39.9
date     92.11.13.14.10.27;  author chrisg;  state Exp;
branches ;
next     39.8;

39.8
date     92.07.24.12.08.22;  author spence;  state Exp;
branches ;
next     39.7;

39.7
date     92.04.27.12.00.53;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     92.04.15.15.49.42;  author spence;  state Exp;
branches ;
next     39.5;

39.5
date     92.03.13.15.48.21;  author spence;  state Exp;
branches ;
next     39.4;

39.4
date     92.01.21.13.35.02;  author chrisg;  state Exp;
branches ;
next     39.3;

39.3
date     92.01.17.12.09.42;  author spence;  state Exp;
branches ;
next     39.2;

39.2
date     92.01.07.13.48.23;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     91.10.18.16.26.46;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.31.31;  author chrisg;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.11.14.13.29;  author spence;  state Exp;
branches ;
next     37.3;

37.3
date     91.05.15.12.58.57;  author spence;  state Exp;
branches ;
next     37.2;

37.2
date     91.05.09.14.27.53;  author spence;  state Exp;
branches ;
next     37.1;

37.1
date     91.04.15.14.08.57;  author spence;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.21.45;  author spence;  state Exp;
branches ;
next     36.37;

36.37
date     90.07.27.16.38.59;  author bart;  state Exp;
branches ;
next     36.36;

36.36
date     90.04.11.18.42.28;  author bart;  state Exp;
branches ;
next     36.35;

36.35
date     90.04.11.16.39.20;  author bart;  state Exp;
branches ;
next     36.34;

36.34
date     90.04.06.18.13.54;  author bart;  state Exp;
branches ;
next     36.33;

36.33
date     90.03.28.09.31.42;  author bart;  state Exp;
branches ;
next     36.32;

36.32
date     89.03.15.14.25.33;  author bart;  state Exp;
branches ;
next     36.31;

36.31
date     89.03.14.10.25.35;  author bart;  state Exp;
branches ;
next     36.30;

36.30
date     89.03.06.19.45.16;  author bart;  state Exp;
branches ;
next     36.29;

36.29
date     89.02.23.13.21.00;  author bart;  state Exp;
branches ;
next     36.28;

36.28
date     89.02.23.13.00.47;  author bart;  state Exp;
branches ;
next     36.27;

36.27
date     89.02.17.22.00.30;  author bart;  state Exp;
branches ;
next     36.26;

36.26
date     89.02.17.20.20.56;  author bart;  state Exp;
branches ;
next     36.25;

36.25
date     89.02.17.20.09.17;  author bart;  state Exp;
branches ;
next     36.24;

36.24
date     89.02.17.20.08.36;  author bart;  state Exp;
branches ;
next     36.23;

36.23
date     89.02.17.20.06.11;  author bart;  state Exp;
branches ;
next     36.22;

36.22
date     89.02.17.20.02.37;  author bart;  state Exp;
branches ;
next     36.21;

36.21
date     89.02.17.19.59.19;  author bart;  state Exp;
branches ;
next     36.20;

36.20
date     89.02.17.19.55.00;  author bart;  state Exp;
branches ;
next     36.19;

36.19
date     89.02.17.19.46.39;  author bart;  state Exp;
branches ;
next     36.18;

36.18
date     89.02.17.19.30.29;  author bart;  state Exp;
branches ;
next     36.17;

36.17
date     89.02.17.18.47.47;  author bart;  state Exp;
branches ;
next     36.16;

36.16
date     89.02.17.18.32.13;  author bart;  state Exp;
branches ;
next     36.15;

36.15
date     89.02.17.18.30.48;  author bart;  state Exp;
branches ;
next     36.14;

36.14
date     89.02.17.17.47.24;  author bart;  state Exp;
branches ;
next     36.13;

36.13
date     89.02.17.17.30.15;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     89.02.17.17.27.59;  author bart;  state Exp;
branches ;
next     36.11;

36.11
date     89.02.17.17.25.52;  author bart;  state Exp;
branches ;
next     36.10;

36.10
date     89.02.17.17.06.48;  author bart;  state Exp;
branches ;
next     36.9;

36.9
date     89.02.17.16.46.37;  author bart;  state Exp;
branches ;
next     36.8;

36.8
date     89.02.17.16.44.09;  author bart;  state Exp;
branches ;
next     36.7;

36.7
date     89.02.17.16.34.43;  author bart;  state Exp;
branches ;
next     36.6;

36.6
date     89.02.17.16.29.54;  author bart;  state Exp;
branches ;
next     36.5;

36.5
date     89.02.17.16.11.00;  author bart;  state Exp;
branches ;
next     36.4;

36.4
date     89.02.17.16.07.50;  author bart;  state Exp;
branches ;
next     36.3;

36.3
date     89.02.17.15.58.25;  author bart;  state Exp;
branches ;
next     36.2;

36.2
date     89.02.17.15.56.09;  author bart;  state Exp;
branches ;
next     36.1;

36.1
date     89.02.17.15.49.14;  author bart;  state Exp;
branches ;
next     36.0;

36.0
date     89.02.17.15.20.23;  author bart;  state Exp;
branches ;
next     ;


desc
@@


39.10
log
@set_dims() now calls uncook_oscan(TRUE,,,) for Video and MaxOScan, so that
SetChipRev() can change the SuperHires values. Only overscan.prefs should
be using SetDisplayInfoData() for DTAG_DIMS, and Martin assures me that
the data for MaxOScan and VideoOScan at that time is correct.
@
text
@/******************************************************************************
*
*   $Id: subroutines.c,v 39.9 92/11/13 14:10:27 chrisg Exp Locker: spence $
*
*   $Locker: spence $
*
******************************************************************************/

/* subroutines.c -- recipies for cooking and uncooking chunkdata */

#include    "/displayinfo_internal.h"
#include "/macros.h"
#include <pragmas/utility_pragmas.h>
#include	"d.protos"

/*#define DEBUG*/
/*#define GBDEBUG*/

#ifdef GBDEBUG
#define GBUG if (GBASE->Debug)
#else
#define GBUG
#endif

#ifdef DEBUG
#define D(x) {GBUG {x};}
#else
#define D(x)
#endif

#define CLIPOSCAN

ULONG __regargs cook_oscan( flag, dinfo, cook, size, raw, bytes, src, dst )
struct DisplayInfo *dinfo;
ULONG  cook, *size, raw, *bytes;
struct Rect32 **src;
struct Rectangle **dst;
int    flag;
{
    ULONG result = 0;

    if((cook <= (*size)) && (raw <= (*bytes))) 
    {
	if( flag )
	{
	    (*dst)->MinX = 
	    (*src)->MinX / dinfo->Resolution.x;

	    (*dst)->MaxX = 
	    (*src)->MaxX / dinfo->Resolution.x;

	    (*dst)->MinY = 
	    (*src)->MinY / dinfo->Resolution.y;

	    (*dst)->MaxY = 
	    (*src)->MaxY / dinfo->Resolution.y;
	}

	(*size) -= cook;
	(*bytes) -= raw;

	*dst = (struct Rectangle *)((*(UBYTE **)dst)+cook);
	*src = (struct Rect32 *)((*(UBYTE **)src)+raw);

	result = cook;
    }

    return(result);
}

ULONG __regargs uncook_oscan( flag, dinfo, cook, size, raw, bytes, src, dst )
struct DisplayInfo *dinfo;
ULONG  cook, *size, raw, *bytes;
struct Rectangle **src;
struct Rect32 **dst;
int    flag;
{
    ULONG result = 0;

    if((cook <= (*size)) && (raw <= (*bytes))) 
    {
	if( flag )
	{
	      (*dst)->MinX = 
	    (((*src)->MinX)  ) * dinfo->Resolution.x;

	      (*dst)->MaxX = 
	    (((*src)->MaxX)+1) * dinfo->Resolution.x - 1;

	      (*dst)->MinY = 
	    (((*src)->MinY)  ) * dinfo->Resolution.y;

	      (*dst)->MaxY = 
	    (((*src)->MaxY)+1) * dinfo->Resolution.y - 1;
	}

	(*size) -= cook;
	(*bytes) -= raw;

	*dst = (struct Rect32 *)((*(UBYTE **)dst)+raw);
	*src = (struct Rectangle *)((*(UBYTE **)src)+cook);

	result = cook;
    }

    return(result);
}

ULONG __regargs get_dims(record,src,size,tagID,ID,dst,bytes)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
{
    ULONG result;
    ULONG raw;
    ULONG cook;
    struct RawDisplayInfo *dinfo;
    struct DimensionInfo *dims = (struct DimensionInfo *)*dst;

    D(kprintf("get_dims ID = 0x%lx\n", *ID);)
    result = copy_dbstuff(src, size, dst, bytes, ((ULONG)&((struct RawDimensionInfo *)(0))->Nominal));

    if(dinfo = (struct RawDisplayInfo *)FindTagItem(DTAG_DISP,&((*record)->rec_Tag)))
    {
	if(dinfo->Resolution.x && dinfo->Resolution.y)
	{
	    struct DisplayInfoRecord *mntr= (struct DisplayInfoRecord *)((*record)->rec_Node.rcn_Parent);
	    struct RawMonitorInfo *minfo;
	    ULONG add;

	    raw = ((ULONG)&((struct RawDimensionInfo *)(0))->MaxOScan)-
		       ((ULONG)&((struct RawDimensionInfo *)(0))->Nominal);
	    cook = ((ULONG)&((struct DimensionInfo *)(0))->MaxOScan)-
			((ULONG)&((struct DimensionInfo *)(0))->Nominal);

	    if(add = cook_oscan(TRUE,(struct DisplayInfo *)dinfo,cook,size,raw,bytes,(struct Rect32 **)src, (struct Rectangle **)dst))
	    { result += add; } else { return(result); }

	    raw = ((ULONG)&((struct RawDimensionInfo *)(0))->VideoOScan)-
		  ((ULONG)&((struct RawDimensionInfo *)(0))->MaxOScan);
	    cook = ((ULONG)&((struct DimensionInfo *)(0))->VideoOScan)-
		   ((ULONG)&((struct DimensionInfo *)(0))->MaxOScan);

	    if(add = cook_oscan(TRUE,(struct DisplayInfo *)dinfo,cook,size,raw,bytes,(struct Rect32 **)src, (struct Rectangle **)dst))
	    { result += add; } else { return(result); }

	    raw = ((ULONG) ((struct RawDimensionInfo *)(0))->pad)-
	    	  ((ULONG)&((struct RawDimensionInfo *)(0))->VideoOScan);
	    cook = ((ULONG)&((struct DimensionInfo *)(0))->TxtOScan)-
		   ((ULONG)&((struct DimensionInfo *)(0))->VideoOScan);

	    if(add = cook_oscan(TRUE,(struct DisplayInfo *)dinfo,cook,size,raw,bytes,(struct Rect32 **)src, (struct Rectangle **)dst))
	    { result += add; } else { return(result); }

	    if((mntr) && (minfo = (struct RawMonitorInfo *)(FindTagItem(DTAG_MNTR,&mntr->rec_Tag))))
	    {
		*src = (UBYTE *)(&minfo->TxtOScan);

		raw = ((ULONG)&((struct RawMonitorInfo *)(0))->StdOScan)-
		      ((ULONG)&((struct RawMonitorInfo *)(0))->TxtOScan);
		cook = ((ULONG)&((struct DimensionInfo *)(0))->StdOScan)-
		       ((ULONG)&((struct DimensionInfo *)(0))->TxtOScan);

		if(add = cook_oscan(TRUE,(struct DisplayInfo *)dinfo,cook,size,raw,&raw,(struct Rect32 **)src, (struct Rectangle **)dst))
		{ result += add; } else { return(result); }

		*src = (UBYTE *)(&minfo->StdOScan);

		raw = ((ULONG)&((struct RawMonitorInfo *)(0))->DefaultViewPosition.x)-
		      ((ULONG)&((struct RawMonitorInfo *)(0))->StdOScan);
		cook = ((ULONG) ((struct DimensionInfo *)(0))->pad)-
		       ((ULONG)&((struct DimensionInfo *)(0))->StdOScan);

		if (add = cook_oscan(TRUE,(struct DisplayInfo *)dinfo,cook,size,raw,&raw,(struct Rect32 **)src, (struct Rectangle **)dst))
		{
			result += add;
		}
		/* For SuperHires modes under ECS, the MaxOScan is 8 pixels less than
		 * twice the Hires MaxOScan, and this is reflected in the database.
		 * However, we have to ensure here that we cannot be setting the
		 * TxtOScan and StdOScan values greater than the MaxOScan values.
		 */
		{
			D(kprintf("Range check. dims = 0x%lx\n", dims);)
			D(kprintf("TxtMaxX = 0x%lx, StdMaxX = 0x%lx, MaxMaxX = 0x%lx\n", dims->TxtOScan.MaxX, dims->StdOScan.MaxX, dims->MaxOScan.MaxX);)
			dims->TxtOScan.MaxX = MIN(dims->TxtOScan.MaxX, dims->MaxOScan.MaxX);
			dims->StdOScan.MaxX = MIN(dims->StdOScan.MaxX, dims->MaxOScan.MaxX);
		}
	    }
	}
    }

    return( result );
}


ULONG __regargs set_dims(record,src,size,tagID,ID,dst,bytes)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
{
    ULONG result;
    ULONG raw;
    struct RawDisplayInfo *dinfo;
    ULONG cook;

    result = copy_dbstuff(src, size, dst, bytes, ((ULONG)&((struct RawDimensionInfo *)(0))->Nominal));

    if(dinfo = (struct RawDisplayInfo *)(FindTagItem(DTAG_DISP,&((*record)->rec_Tag))))
    {
	if(dinfo->Resolution.x && dinfo->Resolution.y)
	{
	    struct DisplayInfoRecord *mntr= (struct DisplayInfoRecord *)((*record)->rec_Node.rcn_Parent);
	    struct RawMonitorInfo *minfo;
	    ULONG add;

	    raw = ((ULONG)&((struct RawDimensionInfo *)(0))->MaxOScan)-
		       ((ULONG)&((struct RawDimensionInfo *)(0))->Nominal);
	    cook = ((ULONG)&((struct DimensionInfo *)(0))->MaxOScan)-
			((ULONG)&((struct DimensionInfo *)(0))->Nominal);

	    if(add = uncook_oscan(TRUE,(struct DisplayInfo *)dinfo,cook,size,raw,bytes,(struct Rectangle **)src, (struct Rect32 **)dst))
	    { result += add; } else { return(result); }

	    raw = ((ULONG)&((struct RawDimensionInfo *)(0))->VideoOScan)-
		  ((ULONG)&((struct RawDimensionInfo *)(0))->MaxOScan);
	    cook = ((ULONG)&((struct DimensionInfo *)(0))->VideoOScan)-
		   ((ULONG)&((struct DimensionInfo *)(0))->MaxOScan);

	    if(add = uncook_oscan(TRUE,(struct DisplayInfo *)dinfo,cook,size,raw,bytes,(struct Rectangle **)src, (struct Rect32 **)dst))
	    { result += add; } else { return(result); }

	    raw = ((ULONG) ((struct RawDimensionInfo *)(0))->pad)-
	    	  ((ULONG)&((struct RawDimensionInfo *)(0))->VideoOScan);
	    cook = ((ULONG)&((struct DimensionInfo *)(0))->TxtOScan)-
		   ((ULONG)&((struct DimensionInfo *)(0))->VideoOScan);

	    if(add = uncook_oscan(TRUE,(struct DisplayInfo *)dinfo,cook,size,raw,bytes,(struct Rectangle **)src, (struct Rect32 **)dst))
	    { result += add; } else { return(result); }

	    if((mntr) && (minfo = (struct RawMonitorInfo *)(FindTagItem(DTAG_MNTR,&mntr->rec_Tag))))
	    {
		*dst = (UBYTE *)(&minfo->TxtOScan);

		raw = ((ULONG)&((struct RawMonitorInfo *)(0))->StdOScan)-
		      ((ULONG)&((struct RawMonitorInfo *)(0))->TxtOScan);
		cook = ((ULONG)&((struct DimensionInfo *)(0))->StdOScan)-
		       ((ULONG)&((struct DimensionInfo *)(0))->TxtOScan);

		if(add = uncook_oscan(TRUE,(struct DisplayInfo *)dinfo,cook,size,raw,&raw,(struct Rectangle **)src, (struct Rect32 **)dst))
		{ result += add; } else { return(result); }

		*dst = (UBYTE *)(&minfo->StdOScan);

		raw = ((ULONG)&((struct RawMonitorInfo *)(0))->DefaultViewPosition.x)-
		      ((ULONG)&((struct RawMonitorInfo *)(0))->StdOScan);
		cook = ((ULONG) ((struct DimensionInfo *)(0))->pad)-
		       ((ULONG)&((struct DimensionInfo *)(0))->StdOScan);

		if(add = uncook_oscan(TRUE,(struct Displayinfo *)dinfo,cook,size,raw,&raw,(struct Rectangel **)src, (struct Rect32 **)dst))
		{ result += add; } else { return(result); }
	    }
	}
    }

    return( result );
}

ULONG __regargs set_mntr(record,src,size,tagID,ID,dst,bytes)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
{
    ULONG result;
    ULONG raw = ((ULONG)&((struct RawMonitorInfo *)(0))->ViewPosition);
    Point *op = (Point *)((*dst)+raw);
    Point *np = (Point *)((*src)+raw);

    D(kprintf("set_mntr: enter...\n"););

    /* copy up to viewposition */

    D(kprintf("set_mntr: copy up to viewposition...\n"););
    result = copy_dbstuff(src, size, dst, bytes, raw);

    raw = ( ((ULONG)&((struct RawMonitorInfo *)(0))->reserved)
	  - ((ULONG)&((struct RawMonitorInfo *)(0))->ViewPosition)   );

    D(kprintf("set_mntr: new raw == %08lx\n",raw););

    D(kprintf("set_mntr: op %08lx ",op););
    D(kprintf("set_mntr: old viewposition %08lx \n",*((ULONG *)op)););
    D(kprintf("set_mntr: np %08lx ",np););
    D(kprintf("set_mntr: new viewposition %08lx \n",*((ULONG *)np)););

    /* check viewposition changed */

    if( *(ULONG *)np != *((ULONG *)op ) )
    {
	struct DisplayInfoRecord **mntr = (struct DisplayInfoRecord **)(&((*record)->rec_Node.rcn_Parent));
	struct DisplayInfoRecord **mode = (struct DisplayInfoRecord **)(&((*mntr)->rec_Node.rcn_Child));
	LONG   DX = (op->x - np->x) * (op+1)->x; 	/* ticks DX */
	LONG   DY = (op->y - np->y) * (op+1)->y; 	/* ticks DY */

	Forbid();

	D(kprintf("set_mntr: viewposition changed...\n"););
	D(kprintf("set_mntr: ticks DX == %ld \n",DX););
	D(kprintf("set_mntr: ticks DY == %ld \n",DY););
	D(kprintf("set_mntr: mntr == %08lx id == %08lx\n", \
		*mntr,*(ULONG *)&((*mntr)->rec_MajorKey)););

	if(!mode) D(kprintf("set_mntr: no children...\n"););

	while(*mode)
	{
	    struct RawDimensionInfo *dims = 
				     (struct RawDimensionInfo *)(FindTagItem(DTAG_DIMS,&((*mode)->rec_Tag)));
#ifdef	    CLIPOSCAN
	    struct RawDisplayInfo *dinfo; 
#endif

	    D(kprintf("set_mntr: mode== %08lx id == %08lx\n", \
		    *mode,*(ULONG *)&((*mode)->rec_MajorKey)););

	    if( dims )
	    {
		D(kprintf("set_mntr: dims == %08lx\n",dims););

		dims->MaxOScan.MinX += DX;
		dims->MaxOScan.MinY += DY;
		dims->MaxOScan.MaxX += DX;
		dims->MaxOScan.MaxY += DY;
		dims->VideoOScan.MinX += DX;
		dims->VideoOScan.MinY += DY;
		dims->VideoOScan.MaxX += DX;
		dims->VideoOScan.MaxY += DY;

		D(kprintf("set: max.miny = %08lx\n",dims->MaxOScan.MinY););
		D(kprintf("set: max.maxx = %08lx\n",dims->MaxOScan.MaxX););
		D(kprintf("set: max.maxy = %08lx\n",dims->MaxOScan.MaxY););
		D(kprintf("set: vid.minx = %08lx\n",dims->VideoOScan.MinX););
		D(kprintf("set: vid.miny = %08lx\n",dims->VideoOScan.MinY););
		D(kprintf("set: vid.maxx = %08lx\n",dims->VideoOScan.MaxX););
		D(kprintf("set: vid.maxy = %08lx\n",dims->VideoOScan.MaxY););
	    }

#ifdef	    CLIPOSCAN
	    if(dinfo = (struct RawDisplayInfo *)(FindTagItem(DTAG_DISP,&((*mode)->rec_Tag))))
	    {
		WORD dx = DX/dinfo->Resolution.x;
		WORD dy = DY/dinfo->Resolution.y;

		(*mode)->rec_ClipOScan.MinX += dx;
		(*mode)->rec_ClipOScan.MinY += dy;
		(*mode)->rec_ClipOScan.MaxX += dx;
		(*mode)->rec_ClipOScan.MaxY += dy;
	    }
#endif
	    D(kprintf("set: max.minx = %08lx\n",dims->MaxOScan.MinX););

	    mode = (struct DisplayInfoRecord **)(&((*mode)->rec_Node.rcn_Succ));
	}

	Permit();
    }

    /* copy from viewposition to termination */

    D(kprintf("set_mntr: copy copy from viewposition to termination...\n"););
    result = copy_dbstuff(src, size, dst, bytes, raw);

    D(kprintf("set_mntr: raw = %08lx\n",raw););
    D(kprintf("set_mntr: result = %08lx\n",result););

    return( result );
}
@


39.9
log
@removed ridiculous bottleneck routine copy_dbstuff.
@
text
@d3 1
a3 1
*   $Id: subroutines.c,v 39.8 92/07/24 12:08:22 spence Exp Locker: chrisg $
d5 1
a5 1
*   $Locker: chrisg $
d132 1
a132 1
	    struct RawMonitorInfo *minfo = NULL;
d222 1
a222 1
	    struct RawMonitorInfo *minfo = NULL;
d238 1
a238 1
	    if(add = uncook_oscan(FALSE,(struct DisplayInfo *)dinfo,cook,size,raw,bytes,(struct Rectangle **)src, (struct Rect32 **)dst))
d246 1
a246 1
	    if(add = uncook_oscan(FALSE,(struct DisplayInfo *)dinfo,cook,size,raw,bytes,(struct Rectangle **)src, (struct Rect32 **)dst))
d286 1
a286 1
    ULONG result = 0;
@


39.8
log
@Could set NTSC/PAL SuperHires Std/TxtOScan > MaxOScan (beacuse there are
8 less pixels in SuperHires than twice the Max of Hires).
So, range check in get_dims().
@
text
@d3 1
a3 1
*   $Id: subroutines.c,v 39.7 92/04/27 12:00:53 spence Exp Locker: spence $
d5 1
a5 1
*   $Locker: spence $
a31 17

ULONG __regargs copy_dbstuff(src, size, dst, bytes, raw)
UBYTE **src;
ULONG *size;
UBYTE **dst;
ULONG *bytes;
ULONG raw;
{
    ULONG result = 0;

    while((raw--) && ((*size)--) && ((*bytes)--) && (++result))
    {
	*(*dst)++ = *(*src)++;
    }

    return( result );
}
@


39.7
log
@set_mntr() was not writing to the monitor structure properly after the
last set of optimisations. Was not using the result of copy_dbstuff(), and
was corrupting the value of raw.
@
text
@d3 1
a3 1
*   $Id: subroutines.c,v 39.6 92/04/15 15:49:42 spence Exp Locker: spence $
d16 9
d26 1
a26 1
#define D(x) x
d28 1
a28 1
#define D(x) ;
d139 1
d141 1
d195 15
a209 2
		if(add = cook_oscan(TRUE,(struct DisplayInfo *)dinfo,cook,size,raw,&raw,(struct Rect32 **)src, (struct Rectangle **)dst))
		{ result += add; } else { return(result); }
@


39.6
log
@copy_dbstuff() now only takes the parameters it needs.
set_mntr() uses copy_dbstuff()
@
text
@d3 1
a3 1
*   $Id: subroutines.c,v 39.5 92/03/13 15:48:21 spence Exp Locker: spence $
d289 1
a289 1
    copy_dbstuff(src, size, dst, bytes, raw);
d291 2
a292 10
    /* sanity check */
    if( ~raw ) 
    {
	return( result );
    }
    else
    {
	raw = ( ((ULONG)&((struct RawMonitorInfo *)(0))->reserved)
	      - ((ULONG)&((struct RawMonitorInfo *)(0))->ViewPosition)   );
    }
d376 1
a376 1
    copy_dbstuff(src, size, dst, bytes, raw);
@


39.5
log
@calculation of raw in set_mntr() was backwards
@
text
@d3 1
a3 1
*   $Id: subroutines.c,v 39.4 92/01/21 13:35:02 chrisg Exp Locker: spence $
d24 1
a24 2
ULONG __regargs copy_dbstuff(record,src,size,tagID,ID,dst,bytes,raw)
struct DisplayInfoRecord **record;
a26 2
ULONG *tagID;
ULONG *ID;
d131 1
a131 1
    result = copy_dbstuff(record,src,size,tagID,ID,dst,bytes, ((ULONG)&((struct RawDimensionInfo *)(0))->Nominal));
d208 1
a208 1
    result = copy_dbstuff(record,src,size,tagID,ID,dst,bytes, ((ULONG)&((struct RawDimensionInfo *)(0))->Nominal));
d289 1
a289 5

    while((raw--) && ((*size)--) && ((*bytes)--) && (++result))
    {
	*(*dst)++ = *(*src)++;
    }
a291 1

d384 1
a384 5

    while((raw--) && ((*size)--) && ((*bytes)--) && (++result))
    {
	*(*dst)++ = *(*src)++;
    }
@


39.4
log
@ Now use utility.library's tag functions
@
text
@d3 1
a3 1
*   $Id: subroutines.c,v 39.3 92/01/17 12:09:42 spence Exp Locker: chrisg $
d5 1
a5 1
*   $Locker: chrisg $
d306 2
a307 2
	raw = ( ((ULONG)&((struct RawMonitorInfo *)(0))->ViewPosition)
	      - ((ULONG) ((struct RawMonitorInfo *)(0))->reserved)   );
@


39.3
log
@get/set_dbstuff() merged to copy_dbstuff()
@
text
@d3 1
a3 1
*   $Id: subroutines.c,v 39.2 92/01/07 13:48:23 spence Exp Locker: spence $
d5 1
a5 1
*   $Locker: spence $
d12 2
d136 1
a136 1
    if(dinfo = (struct RawDisplayInfo *)find_tag(&((*record)->rec_Tag),DTAG_DISP))
d168 1
a168 1
	    if((mntr) && (minfo = (struct RawMonitorInfo *)(find_tag(&mntr->rec_Tag,DTAG_MNTR))))
d213 1
a213 1
    if(dinfo = (struct RawDisplayInfo *)(find_tag(&((*record)->rec_Tag),DTAG_DISP)))
d245 1
a245 1
	    if((mntr) && (minfo = (struct RawMonitorInfo *)(find_tag(&mntr->rec_Tag,DTAG_MNTR))))
d339 1
a339 1
				     (struct RawDimensionInfo *)(find_tag(&((*mode)->rec_Tag),DTAG_DIMS));
d370 1
a370 1
	    if(dinfo = (struct RawDisplayInfo *)(find_tag(&((*mode)->rec_Tag),DTAG_DISP)))
@


39.2
log
@space savings - get/set_... functions coalesced into a single
get/set_dbstuff() call. The calls only differed in the number of bytes
to move, which is now passed as a parameter to get/set_dbstuff().
@
text
@d3 1
a3 1
*   $Id: subroutines.c,v 39.1 91/10/18 16:26:46 spence Exp Locker: spence $
d22 1
a22 1
ULONG __regargs get_dbstuff(record,src,size,tagID,ID,dst,bytes,raw)
a41 21
ULONG __regargs set_dbstuff(record,src,size,tagID,ID,dst,bytes,raw)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
ULONG raw;
{
    ULONG result = 0;

    while((raw--) && ((*size)--) && ((*bytes)--) && (++result))
    {
	*(*dst)++ = *(*src)++;
    }

    return( result );
}


d132 1
a132 1
    result = get_dbstuff(record,src,size,tagID,ID,dst,bytes, ((ULONG)&((struct RawDimensionInfo *)(0))->Nominal));
d209 1
a209 1
    result = set_dbstuff(record,src,size,tagID,ID,dst,bytes, ((ULONG)&((struct RawDimensionInfo *)(0))->Nominal));
@


39.1
log
@get/set_prog -> get/set_vec.

@
text
@d3 1
a3 1
*   $Id: subroutines.c,v 39.0 91/08/21 17:31:31 chrisg Exp Locker: spence $
d22 1
a22 1
ULONG __regargs get_disp(record,src,size,tagID,ID,dst,bytes)
d30 1
a32 1
    ULONG raw = ((struct RawDisplayInfo *)(0))->reserved[0];
d42 21
d148 2
a149 2
    ULONG result = 0;
    ULONG raw = ((ULONG)&((struct RawDimensionInfo *)(0))->Nominal);
d153 1
a153 4
    while((raw--) && ((*size)--) && ((*bytes)--) && (++result))
    {
	*(*dst)++ = *(*src)++;
    }
a214 80
ULONG __regargs get_mntr(record,src,size,tagID,ID,dst,bytes)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
{
    ULONG result = 0;
    ULONG raw = ((struct RawMonitorInfo *)(0))->reserved[0];

    while((raw--) && ((*size)--) && ((*bytes)--) && (++result))
    {
	*(*dst)++ = *(*src)++;
    }

    return( result );
}

ULONG __regargs get_name(record,src,size,tagID,ID,dst,bytes)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
{
    ULONG result = 0;
    ULONG raw = ((struct RawNameInfo *)(0))->reserved[0];

    while((raw--) && ((*size)--) && ((*bytes)--) && (++result))
    {
	*(*dst)++ = *(*src)++;
    }

    return( result );
}

ULONG __regargs get_vec(record,src,size,tagID,ID,dst,bytes)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
{
    ULONG result = 0;
    ULONG raw = ((struct RawVecInfo *)(0))->reserved[0];

    while((raw--) && ((*size)--) && ((*bytes)--) && (++result))
    {
	*(*dst)++ = *(*src)++;
    }

    return( result );
}


ULONG __regargs set_disp(record,src,size,tagID,ID,dst,bytes)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
{
    ULONG result = 0;
    ULONG raw = ((struct RawDisplayInfo *)(0))->reserved[0];

    while((raw--) && ((*size)--) && ((*bytes)--) && (++result))
    {
	*(*dst)++ = *(*src)++;
    }

    return( result );
}
d225 2
a226 2
    ULONG result = 0;
    ULONG raw = ((ULONG)&((struct RawDimensionInfo *)(0))->Nominal);
d230 1
a230 4
    while((raw--) && ((*size)--) && ((*bytes)--) && (++result))
    {
	*(*dst)++ = *(*src)++;
    }
a421 41

ULONG __regargs set_name(record,src,size,tagID,ID,dst,bytes)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
{
    ULONG result = 0;
    ULONG raw = ((struct RawNameInfo *)(0))->reserved[0];

    while((raw--) && ((*size)--) && ((*bytes)--) && (++result))
    {
	*(*dst)++ = *(*src)++;
    }

    return( result );
}

ULONG __regargs set_vec(record,src,size,tagID,ID,dst,bytes)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
{
    ULONG result = 0;
    ULONG raw = ((struct RawVecInfo *)(0))->reserved[0];

    while((raw--) && ((*size)--) && ((*bytes)--) && (++result))
    {
	*(*dst)++ = *(*src)++;
    }

    return( result );
}

@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*   $Id: subroutines.c,v 38.0 91/06/11 14:13:29 spence Exp Locker: chrisg $
d5 1
a5 1
*   $Locker: chrisg $
d237 1
a237 1
ULONG __regargs get_prog(record,src,size,tagID,ID,dst,bytes)
d247 1
a247 1
    ULONG raw = ((struct RawProgInfo *)(0))->reserved[0];
d508 1
a508 1
ULONG __regargs set_prog(record,src,size,tagID,ID,dst,bytes)
d518 1
a518 1
    ULONG raw = ((struct RawProgInfo *)(0))->reserved[0];
@


38.0
log
@set/get_prog(), and support for DTAG_PROG. Could probably use
set/get_copy() routines instead.
@
text
@d3 1
a3 1
*   $Id: subroutines.c,v 37.3 91/05/15 12:58:57 spence Exp Locker: spence $
d5 1
a5 1
*   $Locker: spence $
@


37.3
log
@Use protos. Registerized parameters. Removed compiler warnings
@
text
@d3 1
a3 1
*   $Id: subroutines.c,v 37.2 91/05/09 14:27:53 spence Exp Locker: spence $
d237 21
d499 20
@


37.2
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Id: subroutines.c,v 37.1 91/04/15 14:08:57 spence Exp Locker: spence $
d12 1
d22 1
a22 1
ULONG get_disp(record,src,size,tagID,ID,dst,bytes)
d32 1
a32 1
    ULONG raw = ((struct RawDisplayInfo *)(0))->reserved;
d42 1
a42 1
ULONG  cook_oscan( flag, dinfo, cook, size, raw, bytes, src, dst )
d71 2
a72 2
	*dst = (*(UBYTE **)dst)+cook;
	*src = (*(UBYTE **)src)+raw;
d80 1
a80 1
ULONG  uncook_oscan( flag, dinfo, cook, size, raw, bytes, src, dst )
d109 2
a110 2
	*dst = (*(UBYTE **)dst)+raw;
	*src = (*(UBYTE **)src)+cook;
d118 1
a118 1
ULONG get_dims(record,src,size,tagID,ID,dst,bytes)
d137 1
a137 1
    if(dinfo = find_tag(&((*record)->rec_Tag),DTAG_DISP))
d141 1
a141 1
	    struct DisplayInfoRecord *mntr= (*record)->rec_Node.rcn_Parent;
d150 1
a150 1
	    if(add = cook_oscan(TRUE,dinfo,cook,size,raw,bytes,src,dst))
d158 1
a158 1
	    if(add = cook_oscan(TRUE,dinfo,cook,size,raw,bytes,src,dst))
d166 1
a166 1
	    if(add = cook_oscan(TRUE,dinfo,cook,size,raw,bytes,src,dst))
d169 1
a169 1
	    if((mntr) && (minfo = find_tag(&mntr->rec_Tag,DTAG_MNTR)))
d171 1
a171 1
		*src = &minfo->TxtOScan;
d178 1
a178 1
		if(add = cook_oscan(TRUE,dinfo,cook,size,raw,&raw,src,dst))
d181 1
a181 1
		*src = &minfo->StdOScan;
d188 1
a188 1
		if(add = cook_oscan(TRUE,dinfo,cook,size,raw,&raw,src,dst))
d197 1
a197 1
ULONG get_mntr(record,src,size,tagID,ID,dst,bytes)
d207 1
a207 1
    ULONG raw = ((struct RawMonitorInfo *)(0))->reserved;
d217 1
a217 1
ULONG get_name(record,src,size,tagID,ID,dst,bytes)
d227 1
a227 1
    ULONG raw = ((struct RawNameInfo *)(0))->reserved;
d237 1
a237 1
ULONG set_disp(record,src,size,tagID,ID,dst,bytes)
d247 1
a247 1
    ULONG raw = ((struct RawDisplayInfo *)(0))->reserved;
d257 1
a257 1
ULONG set_dims(record,src,size,tagID,ID,dst,bytes)
d276 1
a276 1
    if(dinfo = find_tag(&((*record)->rec_Tag),DTAG_DISP))
d280 1
a280 1
	    struct DisplayInfoRecord *mntr= (*record)->rec_Node.rcn_Parent;
d289 1
a289 1
	    if(add = uncook_oscan(TRUE,dinfo,cook,size,raw,bytes,src,dst ))
d297 1
a297 1
	    if(add = uncook_oscan(FALSE,dinfo,cook,size,raw,bytes,src,dst))
d305 1
a305 1
	    if(add = uncook_oscan(FALSE,dinfo,cook,size,raw,bytes,src,dst))
d308 1
a308 1
	    if((mntr) && (minfo = find_tag(&mntr->rec_Tag,DTAG_MNTR)))
d310 1
a310 1
		*dst = &minfo->TxtOScan;
d317 1
a317 1
		if(add = uncook_oscan(TRUE,dinfo,cook,size,raw,&raw,src,dst))
d320 1
a320 1
		*dst = &minfo->StdOScan;
d327 1
a327 1
		if(add = uncook_oscan(TRUE,dinfo,cook,size,raw,&raw,src,dst))
d336 1
a336 1
ULONG set_mntr(record,src,size,tagID,ID,dst,bytes)
d347 2
a348 2
    Point *op = (*dst)+raw;
    Point *np = (*src)+raw;
d384 2
a385 2
	struct DisplayInfoRecord **mntr = &((*record)->rec_Node.rcn_Parent);
	struct DisplayInfoRecord **mode = &((*mntr)->rec_Node.rcn_Child);
d402 1
a402 1
				     find_tag(&((*mode)->rec_Tag),DTAG_DIMS);
d433 1
a433 1
	    if(dinfo = find_tag(&((*mode)->rec_Tag),DTAG_DISP))
d446 1
a446 1
	    mode = &((*mode)->rec_Node.rcn_Succ);
d467 1
a467 1
ULONG set_name(record,src,size,tagID,ID,dst,bytes)
d477 1
a477 1
    ULONG raw = ((struct RawNameInfo *)(0))->reserved;
@


37.1
log
@Knows about new MonitorInfo parameters
@
text
@d3 1
a3 1
*   $Id: subroutines.c,v 37.0 91/01/07 15:21:45 spence Exp Locker: spence $
d11 1
a11 1
#include    "../displayinfo_internal.h"
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*   $Id: subroutines.c,v 36.37 90/07/27 16:38:59 bart Exp Locker: spence $
d182 1
a182 1
		raw = ((ULONG) ((struct RawMonitorInfo *)(0))->pad)-
d321 1
a321 1
		raw = ((ULONG) ((struct RawMonitorInfo *)(0))->pad)-
@


36.37
log
@id
@
text
@d3 1
a3 1
*   $Id: $
d5 1
a5 1
*   $Locker: bart $
@


36.36
log
@graphics36.139 -- cliposcan back in
@
text
@d3 1
a3 1
*   $Header: /usr2/bart/v1.4/src/kickstart/working/graphics/d/RCS/subroutines.c,v 36.35 90/04/11 16:39:20 bart Exp Locker: bart $
@


36.35
log
@removed cliposcan, broken bart
@
text
@d3 1
a3 1
*   $Header: /usr2/bart/v1.4/src/kickstart/working/graphics/d/RCS/subroutines.c,v 36.34 90/04/06 18:13:54 bart Exp Locker: bart $
d19 1
a19 1
/* #define CLIPOSCAN -- broken, bart */
a280 3
#ifdef	    CLIPOSCAN
	    struct Rectangle cliposcan;
#endif
a290 4
#ifdef	    CLIPOSCAN
	    cliposcan = *((struct Rectangle *)(*src));
#endif

a298 4
#ifdef	    CLIPOSCAN
	    (*record)->rec_ClipOScan = cliposcan; /* clip to video */
#endif

d385 2
a386 4
	LONG   dx = (op->x - np->x); 	/* pixel dx */
	LONG   dy = (op->y - np->y);	/* pixel dy */
	LONG   DX = dx * (op+1)->x; 	/* ticks DX */
	LONG   DY = dy * (op+1)->y; 	/* ticks DY */
a397 7
#ifdef	    CLIPOSCAN
	(*record)->rec_ClipOScan.MinX += dx;
	(*record)->rec_ClipOScan.MinY += dy;
	(*record)->rec_ClipOScan.MaxX += dx;
	(*record)->rec_ClipOScan.MaxY += dy;
#endif

d402 3
a421 1
		D(kprintf("set: max.minx = %08lx\n",dims->MaxOScan.MinX););
d430 14
@


36.34
log
@cliposcan
@
text
@d3 1
a3 1
*   $Header: /usr2/bart/v1.4/src/kickstart/working/graphics/d/RCS/subroutines.c,v 36.33 90/03/28 09:31:42 bart Exp Locker: bart $
d19 1
a19 1
#define CLIPOSCAN
d411 7
a438 6
#ifdef	    CLIPOSCAN
		(*record)->rec_ClipOScan.MinX += dx;
		(*record)->rec_ClipOScan.MinY += dy;
		(*record)->rec_ClipOScan.MaxX += dx;
		(*record)->rec_ClipOScan.MaxY += dy;
#endif
@


36.33
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: /usr/commodore/amiga/V36/src/kickstart/graphics/d/RCS/subroutines.c,v 36.32 89/03/15 14:25:33 bart Exp Locker: bart $
d19 2
d281 3
d294 3
d306 4
d396 4
a399 2
	LONG   dx = (op->x - np->x) * (op+1)->x; /* ticks dx */
	LONG   dy = (op->y - np->y) * (op+1)->y; /* ticks dy */
d404 2
a405 2
	D(kprintf("set_mntr: ticks dx == %ld \n",dx););
	D(kprintf("set_mntr: ticks dy == %ld \n",dy););
d423 8
a430 8
		dims->MaxOScan.MinX += dx;
		dims->MaxOScan.MinY += dy;
		dims->MaxOScan.MaxX += dx;
		dims->MaxOScan.MaxY += dy;
		dims->VideoOScan.MinX += dx;
		dims->VideoOScan.MinY += dy;
		dims->VideoOScan.MaxX += dx;
		dims->VideoOScan.MaxY += dy;
d432 6
@


36.32
log
@adjust maxoscan and vidoscan when setting monitor viewposition to changed.
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.31 89/03/14 10:25:35 bart Exp $
@


36.31
log
@uncook_oscan rounding
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.30 89/03/06 19:45:16 bart Exp $
d13 6
d39 1
a39 1
ULONG  cook_oscan( dinfo, cook, size, raw, bytes, src, dst )
d44 1
d50 4
a53 2
	(*dst)->MinX = 
	(*src)->MinX / dinfo->Resolution.x;
d55 2
a56 2
	(*dst)->MaxX = 
	(*src)->MaxX / dinfo->Resolution.x;
d58 2
a59 2
	(*dst)->MinY = 
	(*src)->MinY / dinfo->Resolution.y;
d61 3
a63 2
	(*dst)->MaxY = 
	(*src)->MaxY / dinfo->Resolution.y;
d77 1
a77 1
ULONG  uncook_oscan( dinfo, cook, size, raw, bytes, src, dst )
d82 1
d88 4
a91 2
	  (*dst)->MinX = 
	(((*src)->MinX)  ) * dinfo->Resolution.x;
d93 2
a94 2
	  (*dst)->MaxX = 
	(((*src)->MaxX)+1) * dinfo->Resolution.x - 1;
d96 2
a97 2
	  (*dst)->MinY = 
	(((*src)->MinY)  ) * dinfo->Resolution.y;
d99 3
a101 2
	  (*dst)->MaxY = 
	(((*src)->MaxY)+1) * dinfo->Resolution.y - 1;
d138 1
a138 1
	    struct DisplayInfoRecord *monitor= (*record)->rec_Node.rcn_Parent;
d147 1
a147 1
	    if(add = cook_oscan( dinfo, cook, size, raw, bytes, src, dst ))
d155 1
a155 1
	    if(add = cook_oscan( dinfo, cook, size, raw, bytes, src, dst ))
d163 1
a163 1
	    if(add = cook_oscan( dinfo, cook, size, raw, bytes, src, dst ))
d166 1
a166 1
	    if((monitor) && (minfo = find_tag(&monitor->rec_Tag,DTAG_MNTR)))
d175 1
a175 1
		if(add = cook_oscan( dinfo, cook, size, raw, &raw, src, dst))
d185 1
a185 1
		if(add = cook_oscan( dinfo, cook, size, raw, &raw, src, dst))
d277 1
a277 1
	    struct DisplayInfoRecord *monitor= (*record)->rec_Node.rcn_Parent;
d286 1
a286 1
	    if(add = uncook_oscan( dinfo, cook, size, raw, bytes, src, dst ))
d289 1
d295 1
a295 1
	    if(add = uncook_oscan( dinfo, cook, size, raw, bytes, src, dst ))
d303 1
a303 1
	    if(add = uncook_oscan( dinfo, cook, size, raw, bytes, src, dst ))
d306 1
a306 1
	    if((monitor) && (minfo = find_tag(&monitor->rec_Tag,DTAG_MNTR)))
d315 1
a315 1
		if(add = uncook_oscan(dinfo, cook, size, raw, &raw, src, dst))
d325 1
a325 1
		if(add = uncook_oscan(dinfo, cook, size, raw, &raw, src, dst))
d344 3
a346 1
    ULONG raw = ((struct RawMonitorInfo *)(0))->reserved;
d348 6
d358 87
@


36.30
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.29 89/02/23 13:21:00 bart Exp $
d77 2
a78 2
	(*dst)->MinX = 
	(*src)->MinX * dinfo->Resolution.x - 1;
d80 2
a81 2
	(*dst)->MaxX = 
	(*src)->MaxX * dinfo->Resolution.x - 1;
d83 2
a84 2
	(*dst)->MinY = 
	(*src)->MinY * dinfo->Resolution.y - 1;
d86 2
a87 2
	(*dst)->MaxY = 
	(*src)->MaxY * dinfo->Resolution.y - 1;
@


36.29
log
@DTAG_
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.28 89/02/23 13:00:47 bart Exp $
d166 1
a166 1
		raw = ((ULONG) ((struct RawMonitorInfo *)(0))->reserved)-
d305 1
a305 1
		raw = ((ULONG) ((struct RawMonitorInfo *)(0))->reserved)-
@


36.28
log
@default dimensions now round down
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.27 89/02/17 22:00:30 bart Exp $
d120 1
a120 1
    if(dinfo = find_tag(&((*record)->rec_Tag),TAG_DISP))
d152 1
a152 1
	    if((monitor) && (minfo = find_tag(&monitor->rec_Tag,TAG_MNTR)))
d259 1
a259 1
    if(dinfo = find_tag(&((*record)->rec_Tag),TAG_DISP))
d291 1
a291 1
	    if((monitor) && (minfo = find_tag(&monitor->rec_Tag,TAG_MNTR)))
@


36.27
log
@checkpoint
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.26 89/02/17 20:20:56 bart Exp $
d78 1
a78 1
	(*src)->MinX * dinfo->Resolution.x;
d81 1
a81 1
	(*src)->MaxX * dinfo->Resolution.x;
d84 1
a84 1
	(*src)->MinY * dinfo->Resolution.y;
d87 1
a87 1
	(*src)->MaxY * dinfo->Resolution.y;
@


36.26
log
@removed kprintfs
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.25 89/02/17 20:09:17 bart Exp $
@


36.25
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.24 89/02/17 20:08:36 bart Exp $
d41 1
a41 1
    if((cook > (*size)) || (raw> (*bytes))) 
a42 4
	kprintf("cook_oscan: no space...\n");
    }
    else
    {
d75 1
a75 1
    if((cook > (*size)) || (raw > (*bytes))) 
a76 4
	kprintf("uncook_oscan: no space...\n");
    }
    else
    {
a132 2
	    kprintf("get_dims: nominal...\n");

a140 2
	    kprintf("get_dims: maxoscan...\n");

a148 2
	    kprintf("get_dims: videoscan...\n");

a160 2
		kprintf("get_dims: txtoscan...\n");

a170 2
		kprintf("get_dims: stdoscan...\n");

a172 2

		kprintf("get_dims: done...\n");
a173 4
	    else
	    {
		kprintf("get_dims: no monitor...\n");
	    }
a174 4
	else
	{
	    kprintf("get_dims: no resolution...\n");
	}
a175 4
    else
    {
	kprintf("get_dims: dinfo not found...\n");
    }
a271 2
	    kprintf("set_dims: nominal...\n");

a279 2
	    kprintf("set_dims: maxoscan...\n");

a287 2
	    kprintf("set_dims: videoscan...\n");

a299 2
		kprintf("set_dims: txtoscan...\n");

a309 2
		kprintf("set_dims: stdoscan...\n");

a311 2

		kprintf("set_dims: done...\n");
a312 4
	    else
	    {
		kprintf("set_dims: no monitor...\n");
	    }
a313 8
	else
	{
	    kprintf("set_dims: no resolution...\n");
	}
    }
    else
    {
	kprintf("set_dims: dinfo not found...\n");
@


36.24
log
@make
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.23 89/02/17 20:06:11 bart Exp $
d170 1
a170 1
		raw = ((ULONG)&((struct RawMonitornfo *)(0))->StdOScan)-
@


36.23
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.22 89/02/17 20:02:37 bart Exp $
d170 2
a171 2
		raw = ((ULONG)&((struct RawDimensionInfo *)(0))->StdOScan)-
		      ((ULONG)&((struct RawDimensionInfo *)(0))->TxtOScan);
d182 2
a183 2
		raw = ((ULONG) ((struct RawDimensionInfo *)(0))->reserved)-
		      ((ULONG)&((struct RawDimensionInfo *)(0))->StdOScan);
d333 2
a334 2
		raw = ((ULONG)&((struct RawDimensionInfo *)(0))->StdOScan)-
		      ((ULONG)&((struct RawDimensionInfo *)(0))->TxtOScan);
d345 2
a346 2
		raw = ((ULONG) ((struct RawDimensionInfo *)(0))->reserved)-
		      ((ULONG)&((struct RawDimensionInfo *)(0))->StdOScan);
@


36.22
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.21 89/02/17 19:59:19 bart Exp $
d177 1
a177 1
		if(add = cook_oscan( dinfo, cook, &cook, raw, bytes, src, dst))
d189 1
a189 1
		if(add = cook_oscan( dinfo, cook, &cook, raw, bytes, src, dst))
d331 1
a331 1
		*src = &minfo->TxtOScan;
d340 1
a340 1
		if(add = uncook_oscan(dinfo, cook, &cook, raw, bytes, src, dst))
d343 1
a343 1
		*src = &minfo->StdOScan;
d352 1
a352 1
		if(add = uncook_oscan(dinfo, cook, &cook, raw, bytes, src, dst))
@


36.21
log
@make
cd ..
make
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.20 89/02/17 19:55:00 bart Exp $
d168 1
a168 1
		*src = &minfo->TxtOScan.MinX;
d180 1
a180 1
		*src = &minfo->StdOScan.MinX;
d331 1
a331 1
		*src = &minfo->TxtOScan.MinX;
d343 1
a343 1
		*src = &minfo->StdOScan.MinX;
@


36.20
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.19 89/02/17 19:46:39 bart Exp $
d141 1
a141 1
	    kprintf("get_dims: add nominal...\n");
d143 1
a143 1
	    if(add = cook_oscan( dinfo, cook, &cook, raw, &raw, src, dst ))
d151 1
a151 1
	    kprintf("get_dims: add maxoscan...\n");
d153 1
a153 1
	    if(add = cook_oscan( dinfo, cook, &cook, raw, &raw, src, dst ))
d161 1
a161 1
	    kprintf("get_dims: add videoscan...\n");
d177 1
a177 1
		if(add = cook_oscan( dinfo, cook, size, raw, bytes, src, dst))
d189 1
a189 1
		if(add = cook_oscan( dinfo, cook, size, raw, bytes, src, dst))
d340 1
a340 1
		if(add = uncook_oscan( dinfo, cook, &cook, raw, &raw, src, dst))
d352 1
a352 1
		if(add = uncook_oscan( dinfo, cook, &cook, raw, &raw, src, dst))
@


36.19
log
@make 
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.18 89/02/17 19:30:29 bart Exp $
d143 1
a143 1
	    if(add = cook_oscan( dinfo, cook, size, raw, bytes, src, dst ))
d153 1
a153 1
	    if(add = cook_oscan( dinfo, cook, size, raw, bytes, src, dst ))
a165 1

d168 1
a168 1
		*src = &minfo->TxtOScan;
d180 2
d331 1
a331 1
		*src = &minfo->TxtOScan;
d340 1
a340 1
		if(add = uncook_oscan( dinfo, cook, size, raw, bytes, src, dst))
d343 2
d352 1
a352 1
		if(add = uncook_oscan( dinfo, cook, size, raw, bytes, src, dst))
@


36.18
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.17 89/02/17 18:47:47 bart Exp $
d166 2
a167 1
	    if((monitor) && (minfo = find_tag(&monitor->rec_Tag,TAG_DISP)))
d169 23
a191 2
		kprintf("get_dims: add txtoscan...\n");
		kprintf("get_dims: add stdoscan...\n");
d303 1
a303 1
	    kprintf("set_dims: add nominal...\n");
d313 1
a313 1
	    kprintf("set_dims: add maxoscan...\n");
d323 1
a323 1
	    kprintf("set_dims: add videoscan...\n");
d328 1
a328 1
	    if((monitor) && (minfo = find_tag(&monitor->rec_Tag,TAG_DISP)))
d330 23
a352 2
		kprintf("set_dims: add txtoscan...\n");
		kprintf("set_dims: add stdoscan...\n");
@


36.17
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.16 89/02/17 18:32:13 bart Exp $
d62 2
a63 2
	(*dst) += cook;
	(*src) += raw;
d79 1
a79 1
    if((cook > (*size)) || (raw> (*bytes))) 
d100 2
a101 2
	(*dst) += raw;
	(*src) += cook;
d141 1
a141 9
	    if((cook > (*size)) || (raw> (*bytes))) 
	    {
		kprintf("get_dims: no space...\n");
		return( result );
	    }
	    else
	    {
		((struct Rectangle *)(*dst))->MinX = 
		((struct Rect32 *)(*src))->MinX / dinfo->Resolution.x;
d143 2
a144 2
		((struct Rectangle *)(*dst))->MaxX = 
		((struct Rect32 *)(*src))->MaxX / dinfo->Resolution.x;
a145 15
		((struct Rectangle *)(*dst))->MinY = 
		((struct Rect32 *)(*src))->MinY / dinfo->Resolution.y;

		((struct Rectangle *)(*dst))->MaxY = 
		((struct Rect32 *)(*src))->MaxY / dinfo->Resolution.y;

		(*size) -= cook;
		(*bytes) -= raw;

		(*dst) += cook;
		(*src) += raw;

		result += cook;
	    }

d151 2
d156 10
d168 2
a169 1

d281 1
a281 7
	    if((cook > (*size)) || (raw> (*bytes))) 
	    {
		kprintf("set_dims: no space...\n");
		return( result );
	    }
	    else
	    {
d283 2
a284 1
		struct Rect32 *oscan = (struct Rect32 *)(*src);
a285 28
		((struct Rect32 *)(*dst))->MinX = 
		((struct Rectangle *)(*src))->MinX * dinfo->Resolution.x;

		((struct Rect32 *)(*dst))->MaxX = 
		((struct Rectangle *)(*src))->MaxX * dinfo->Resolution.x;

		((struct Rect32 *)(*dst))->MinY = 
		((struct Rectangle *)(*src))->MinY * dinfo->Resolution.y;

		((struct Rect32 *)(*dst))->MaxY = 
		((struct Rectangle *)(*src))->MaxY * dinfo->Resolution.y;

		(*size) -= cook;
		(*bytes) -= raw;

		(*dst) += raw;
		(*src) += cook;

		result += cook;

		kprintf("set nominal ");
		kprintf("%8ld ",oscan->MinX);
		kprintf("%8ld ",oscan->MinY);
		kprintf("%8ld ",oscan->MaxX);
		kprintf("%8ld ",oscan->MaxY);
		kprintf("\n");
	    }

d291 2
d296 10
d308 2
a309 1

@


36.16
log
@/
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.15 89/02/17 18:30:48 bart Exp $
d23 1
a23 1
    ULONG copy_raw = ((struct RawDisplayInfo *)(0))->reserved;
d25 1
a25 1
    while((copy_raw--) && ((*size)--) && ((*bytes)--) && (++result))
d119 2
a120 2
    ULONG copy_raw = ((ULONG)&((struct RawDimensionInfo *)(0))->Nominal);
    ULONG copy_cook;
d123 1
a123 1
    while((copy_raw--) && ((*size)--) && ((*bytes)--) && (++result))
d134 1
d136 1
a136 1
	    copy_raw = ((ULONG)&((struct RawDimensionInfo *)(0))->MaxOScan)-
d138 1
a138 1
	    copy_cook = ((ULONG)&((struct DimensionInfo *)(0))->MaxOScan)-
d141 1
a141 1
	    if((copy_cook > (*size)) || (copy_raw> (*bytes))) 
d160 2
a161 2
		(*size) -= copy_cook;
		(*bytes) -= copy_raw;
d163 2
a164 2
		(*dst) += copy_cook;
		(*src) += copy_raw;
d166 1
a166 1
		result += copy_cook;
d169 4
a172 4
	    copy_raw = ((ULONG)&((struct RawDimensionInfo *)(0))->VideoOScan)-
		       ((ULONG)&((struct RawDimensionInfo *)(0))->MaxOscan);
	    copy_cook = ((ULONG)&((struct DimensionInfo *)(0))->VideoOScan)-
		        ((ULONG)&((struct DimensionInfo *)(0))->MaxOscan);
d174 3
d209 1
a209 1
    ULONG copy_raw = ((struct RawMonitorInfo *)(0))->reserved;
d211 1
a211 1
    while((copy_raw--) && ((*size)--) && ((*bytes)--) && (++result))
d229 1
a229 1
    ULONG copy_raw = ((struct RawNameInfo *)(0))->reserved;
d231 1
a231 1
    while((copy_raw--) && ((*size)--) && ((*bytes)--) && (++result))
d249 1
a249 1
    ULONG copy_raw = ((struct RawDisplayInfo *)(0))->reserved;
d251 1
a251 1
    while((copy_raw--) && ((*size)--) && ((*bytes)--) && (++result))
d269 1
a269 1
    ULONG copy_raw = ((ULONG)&((struct RawDimensionInfo *)(0))->Nominal);
d271 1
a271 1
    ULONG copy_cook;
d273 1
a273 1
    while((copy_raw--) && ((*size)--) && ((*bytes)--) && (++result))
d280 1
a280 6
    	copy_raw = ((ULONG)&((struct RawDimensionInfo *)(0))->MaxOScan)-
    		   ((ULONG)&((struct RawDimensionInfo *)(0))->Nominal);
    	copy_cook = ((ULONG)&((struct DimensionInfo *)(0))->MaxOScan)-
    		    ((ULONG)&((struct DimensionInfo *)(0))->Nominal);

	if((copy_cook > (*size)) || (copy_raw> (*bytes))) 
a281 5
	    kprintf("set_dims: no space...\n");
	    return( result );
	}
	else
	{
d284 1
d286 6
a291 1
	    if(dinfo->Resolution.x && dinfo->Resolution.y)
d293 6
d313 2
a314 2
		(*size) -= copy_cook;
		(*bytes) -= copy_raw;
d316 2
a317 2
		(*dst) += copy_raw;
		(*src) += copy_cook;
d319 1
a319 1
		result += copy_cook;
a327 4
	    else
	    {
		kprintf("set_dims: no resolution...\n");
	    }
d329 8
d346 4
d369 1
a369 1
    ULONG copy_raw = ((struct RawMonitorInfo *)(0))->reserved;
d371 1
a371 1
    while((copy_raw--) && ((*size)--) && ((*bytes)--) && (++result))
d389 1
a389 1
    ULONG copy_raw = ((struct RawNameInfo *)(0))->reserved;
d391 1
a391 1
    while((copy_raw--) && ((*size)--) && ((*bytes)--) && (++result))
@


36.15
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.14 89/02/17 17:47:24 bart Exp $
d33 2
a34 1
ULONG  cook_oscan( cook, size, raw, bytes, src, dst )
d71 2
a72 1
ULONG  uncook_oscan( cook, size, raw, bytes, src, dst )
@


36.14
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.13 89/02/17 17:30:15 bart Exp $
d33 74
d128 1
a128 6
    	copy_raw = ((ULONG)&((struct RawDimensionInfo *)(0))->MaxOScan)-
    		   ((ULONG)&((struct RawDimensionInfo *)(0))->Nominal);
    	copy_cook = ((ULONG)&((struct DimensionInfo *)(0))->MaxOScan)-
    		    ((ULONG)&((struct DimensionInfo *)(0))->Nominal);

	if((copy_cook > (*size)) || (copy_raw> (*bytes))) 
d130 2
a131 8
	    kprintf("get_dims: no space...\n");
	    return( result );
	}
	else
	{
	    if(dinfo->Resolution.x && dinfo->Resolution.y)
	    {
		struct Rect32 *oscan = (struct Rect32 *)(*src);
d133 4
a136 6
		kprintf("get nominal ");
		kprintf("%8ld ",oscan->MinX);
		kprintf("%8ld ",oscan->MinY);
		kprintf("%8ld ",oscan->MaxX);
		kprintf("%8ld ",oscan->MaxY);
		kprintf("\n");
d138 7
d157 2
a158 2
		size -= copy_cook;
		bytes -= copy_raw;
d165 10
d177 1
a177 1
		kprintf("get_dims: no resolution...\n");
d180 4
d286 3
d305 2
a306 2
		size -= copy_cook;
		bytes -= copy_raw;
d323 9
@


36.13
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.12 89/02/17 17:27:59 bart Exp $
a42 20
    ULONG copy_raw = ((struct RawDimensionInfo *)(0))->reserved;

    while((copy_raw--) && ((*size)--) && ((*bytes)--) && (++result))
    {
	*(*dst)++ = *(*src)++;
    }

    return( result );
}

ULONG get_mntr(record,src,size,tagID,ID,dst,bytes)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
{
    ULONG result = 0;
d44 1
a44 1
    ULONG copy_cook = ((struct MonitorInfo *)(0))->reserved;
d61 1
a61 1
	    kprintf("get_mntr: no space...\n");
d99 1
a99 1
		kprintf("get_mntr: no resolution...\n");
d105 1
a105 1
	kprintf("get_mntr: dinfo not found...\n");
d111 1
a111 1
ULONG get_name(record,src,size,tagID,ID,dst,bytes)
d121 1
a121 1
    ULONG copy_raw = ((struct RawNameInfo *)(0))->reserved;
d131 1
a131 1
ULONG set_disp(record,src,size,tagID,ID,dst,bytes)
d141 1
a141 1
    ULONG copy_raw = ((struct RawDisplayInfo *)(0))->reserved;
d151 1
a151 1
ULONG set_dims(record,src,size,tagID,ID,dst,bytes)
d161 1
a161 1
    ULONG copy_raw = ((struct RawDimensionInfo *)(0))->reserved;
d171 1
a171 1
ULONG set_mntr(record,src,size,tagID,ID,dst,bytes)
a181 1
    ULONG copy_cook = ((struct MonitorInfo *)(0))->reserved;
d183 1
d199 1
a199 1
	    kprintf("set_mntr: no space...\n");
d237 1
a237 1
		kprintf("set_mntr: no resolution...\n");
d243 21
a263 1
	kprintf("set_mntr: dinfo not found...\n");
@


36.12
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.11 89/02/17 17:25:52 bart Exp $
d88 1
a88 1
		struct Rect32 oscan = ((struct Rect32 *)(*src));
d226 1
a226 1
		struct Rect32 oscan = ((struct Rect32 *)(*dsst));
@


36.11
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.10 89/02/17 17:06:48 bart Exp $
d89 2
a90 1
		kprintf("nominal rectangle ");
d226 2
d247 7
@


36.10
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.9 89/02/17 16:46:37 bart Exp $
d88 8
@


36.9
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.8 89/02/17 16:44:09 bart Exp $
d81 1
d108 4
d114 4
d210 1
d237 4
d242 4
@


36.8
log
@cook/uncook nominal
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.7 89/02/17 16:34:43 bart Exp $
d63 1
a63 1
    ULONG copy_raw = ((struct RawMonitorInfo *)(0))->reserved;
d183 1
a183 1
    ULONG copy_raw = ((struct RawMonitorInfo *)(0))->reserved;
@


36.7
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.6 89/02/17 16:29:54 bart Exp $
d64 1
d76 2
d79 1
a79 1
	if( copy_raw > (*size))  /* no space for Nominal rectangle */
d99 4
d104 2
a105 2
		(*dst) += copy_raw;
		result += copy_raw;
d184 1
d196 2
d199 1
a199 1
	if( copy_raw > (*size))  /* no space for Nominal rectangle */
d207 2
a208 2
		((struct Rectangle *)(*dst))->MinX = 
		((struct Rect32 *)(*src))->MinX / dinfo->Resolution.x;
d210 2
a211 2
		((struct Rectangle *)(*dst))->MaxX = 
		((struct Rect32 *)(*src))->MaxX / dinfo->Resolution.x;
d213 2
a214 2
		((struct Rectangle *)(*dst))->MinY = 
		((struct Rect32 *)(*src))->MinY / dinfo->Resolution.y;
d216 2
a217 2
		((struct Rectangle *)(*dst))->MaxY = 
		((struct Rect32 *)(*src))->MaxY / dinfo->Resolution.y;
d219 3
a221 1
		(*src) += copy_raw;
d223 3
a225 1
		result += copy_raw;
@


36.6
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.5 89/02/17 16:11:00 bart Exp $
d23 1
a23 1
    ULONG copy_raw = (struct RawDisplayInfo *)(0)->reserved;
d43 1
a43 1
    ULONG copy_raw = (struct RawDimensionInfo *)(0)->reserved;
d63 2
a64 1
    ULONG copy_raw = (struct RawMonitorInfo *)(0)->reserved;
d71 32
d116 1
a116 1
    ULONG copy_raw = (struct RawNameInfo *)(0)->reserved;
d136 1
a136 1
    ULONG copy_raw = (struct RawDisplayInfo *)(0)->reserved;
d156 1
a156 1
    ULONG copy_raw = (struct RawDimensionInfo *)(0)->reserved;
d176 2
a177 1
    ULONG copy_raw = (struct RawMonitorInfo *)(0)->reserved;
d184 32
d229 1
a229 1
    ULONG copy_raw = (struct RawNameInfo *)(0)->reserved;
@


36.5
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.4 89/02/17 16:07:50 bart Exp $
d23 1
a23 1
    ULONG copy_raw = *size;
d43 1
a43 1
    ULONG copy_raw = *size;
d63 1
a63 1
    ULONG copy_raw = *size;
d83 1
a83 1
    ULONG copy_raw = *size;
d103 1
a103 1
    ULONG copy_raw = *size;
d123 1
a123 1
    ULONG copy_raw = *size;
d143 1
a143 1
    ULONG copy_raw = *size;
d163 1
a163 1
    ULONG copy_raw = *size;
d172 1
@


36.4
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.3 89/02/17 15:58:25 bart Exp $
d23 1
a23 1
    ULONG copy_raw = ((struct RawDisplayInfo *)(0))->reserved;
d43 1
a43 3
    ULONG copy_raw = ((struct RawDimensionInfo *)(0))->reserved;
    struct RawDisplayInfo *dinfo;
    struct RawMonitorInfo *minfo;
d63 1
a63 1
    ULONG copy_raw = *(*size);
d83 1
a83 1
    ULONG copy_raw = *(*size);
d103 1
a103 1
    ULONG copy_raw = *(*size);
d123 1
a123 1
    ULONG copy_raw = *(*size);
d143 1
a143 1
    ULONG copy_raw = *(*size);
d163 1
a163 1
    ULONG copy_raw = *(*size);
@


36.3
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.2 89/02/17 15:56:09 bart Exp $
d65 1
a65 1
    ULONG copy_raw = ((struct RawDisplayInfo *)(0))->reserved;
d85 1
a85 1
    ULONG copy_raw = ((struct RawDisplayInfo *)(0))->reserved;
d105 1
a105 1
    ULONG copy_raw = ((struct RawDisplayInfo *)(0))->reserved;
d125 1
a125 3
    ULONG copy_raw = ((struct RawDimensionInfo *)(0))->reserved;
    struct RawDisplayInfo *dinfo;
    struct RawMonitorInfo *minfo;
d145 1
a145 1
    ULONG copy_raw = ((struct RawDisplayInfo *)(0))->reserved;
d165 1
a165 1
    ULONG copy_raw = ((struct RawDisplayInfo *)(0))->reserved;
@


36.2
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.1 89/02/17 15:49:14 bart Exp $
d23 1
a23 1
    ULONG copy_raw = &((struct RawDisplayInfo *)(0))->reserved;
d43 1
a43 1
    ULONG copy_raw = &((struct RawDimensionInfo *)(0))->reserved;
d65 1
a65 1
    ULONG copy_raw = &((struct RawDisplayInfo *)(0))->reserved;
d85 1
a85 1
    ULONG copy_raw = &((struct RawDisplayInfo *)(0))->reserved;
d105 1
a105 1
    ULONG copy_raw = &((struct RawDisplayInfo *)(0))->reserved;
d125 1
a125 1
    ULONG copy_raw = &((struct RawDimensionInfo *)(0))->reserved;
d147 1
a147 1
    ULONG copy_raw = &((struct RawDisplayInfo *)(0))->reserved;
d167 1
a167 1
    ULONG copy_raw = &((struct RawDisplayInfo *)(0))->reserved;
@


36.1
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: subroutines.c,v 36.0 89/02/17 15:20:23 bart Exp $
d43 1
a43 1
    ULONG copy_raw = &((struct RawDimensionInfo *)(0))->Nominal;
a51 32
    if(dinfo = find_tag(&((*record)->rec_Tag),TAG_DISP))
    {
    	copy_raw = ((ULONG)&((struct RawDimensionInfo *)(0))->MaxOScan)-
    		   ((ULONG)&((struct RawDimensionInfo *)(0))->Nominal);

	if( copy_raw > (*size))  /* no space for Nominal rectangle */
	{
	    return( result );
	}
	else
	{
	    if(dinfo->Resolution.x && dinfo->Resolution.y)
	    {
		((struct Rectangle *)(*dst))->MinX = 
		((struct Rect32 *)(*src))->MinX / dinfo->Resolution.x;

		((struct Rectangle *)(*dst))->MaxX = 
		((struct Rect32 *)(*src))->MaxX / dinfo->Resolution.x;

		((struct Rectangle *)(*dst))->MinY = 
		((struct Rect32 *)(*src))->MinY / dinfo->Resolution.y;

		((struct Rectangle *)(*dst))->MaxY = 
		((struct Rect32 *)(*src))->MaxY / dinfo->Resolution.y;

		(*src) += copy_raw;
		(*dst) += copy_raw;
		result += copy_raw;
	    }
	}
    }

d105 1
d107 4
a110 1
    /* stub */
d125 3
d129 4
a132 1
    /* stub */
d147 1
d149 4
a152 1
    /* stub */
d167 1
d169 4
a172 1
    /* stub */
@


36.0
log
@added to rcs for updating
@
text
@d3 1
a3 1
*   $Header: $
d5 1
a5 1
*   $Locker: $
d23 1
d25 4
a28 1
    /* stub */
d43 3
d47 4
a50 1
    /* stub */
d52 32
d97 1
d99 4
a102 1
    /* stub */
d117 1
d119 4
a122 1
    /* stub */
@
