head     39.9;
branch   ;
access   ;
symbols  rel39_24:39.9 rel39_18:39.9 rel39_97:39.8 rel39_90:39.8 rel39_89:39.8 rel39_82:39.8 rel39_76:39.8 rel39_71:39.8 rel39_65:39.8 rel39_64:39.8 rel39_61:39.7 rel39_60:39.7 rel39_55:39.6 rel39_47:39.5 rel39_39:39.5 rel39_38:39.5 rel39_37:39.5 rel39_35:39.5 rel39_34:39.5 V37_30:37.1 V37_29:37.1 V37_28:37.1 V37_25:37.1 V37_22:37.1 V37_21:37.1 V37_20:37.1 V37_19:37.1 V37_17:37.0 V37_15:37.0 V37_14:37.0 V37_13:37.0 V37_12:37.0 V37_11:37.0 V37_10:37.0 V37_9:37.0 V37_8:37.0 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.35 V36_208:36.35 V36_207:36.35 V36_205:36.35 V36_203:36.35 V36_202:36.35 V36_201:36.35 V36_200:36.35 V36_199:36.35 V36_198:36.35 V36_196:36.35 V36_195:36.35 V36_194:36.35 V36_193:36.35 V36_192:36.35 V36_191:36.35 V36_190:36.35 V36_189:36.35 V36_188:36.35 V36_187:36.35 V36_186:36.35 V36_185:36.35 V36_184:36.35 V36_183:36.35 V36_182:36.35 V36_181:36.35 V36_67:36.35 V36_68:36.9 V36_66:36.9 V36_62:36.9 V36_56:36.6 V36_50:36.5 V36_45:36.4 V36_41:36.4 V36_38:36.3 V36_37:36.3;
locks    ; strict;
comment  @*   @;


39.9
date     93.02.10.19.44.17;  author spence;  state Exp;
branches ;
next     39.8;

39.8
date     92.06.03.18.10.14;  author spence;  state Exp;
branches ;
next     39.7;

39.7
date     92.05.13.11.34.41;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     92.04.15.15.45.43;  author spence;  state Exp;
branches ;
next     39.5;

39.5
date     92.01.21.13.33.52;  author chrisg;  state Exp;
branches ;
next     39.4;

39.4
date     92.01.17.12.06.35;  author spence;  state Exp;
branches ;
next     39.3;

39.3
date     92.01.07.15.56.25;  author spence;  state Exp;
branches ;
next     39.2;

39.2
date     92.01.07.13.46.27;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     91.10.18.16.25.50;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.30.29;  author chrisg;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.14.11.21.41;  author spence;  state Exp;
branches ;
next     37.3;

37.3
date     91.05.15.12.57.28;  author spence;  state Exp;
branches ;
next     37.2;

37.2
date     91.05.09.14.25.49;  author spence;  state Exp;
branches ;
next     37.1;

37.1
date     91.03.08.17.04.33;  author spence;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.21.26;  author spence;  state Exp;
branches ;
next     36.35;

36.35
date     90.07.27.16.37.18;  author bart;  state Exp;
branches ;
next     36.34;

36.34
date     90.05.11.14.19.26;  author bart;  state Exp;
branches ;
next     36.33;

36.33
date     90.03.28.09.30.42;  author bart;  state Exp;
branches ;
next     36.32;

36.32
date     89.08.17.13.13.11;  author bart;  state Exp;
branches ;
next     36.31;

36.31
date     89.07.24.13.31.30;  author bart;  state Exp;
branches ;
next     36.30;

36.30
date     89.02.23.13.20.53;  author bart;  state Exp;
branches ;
next     36.29;

36.29
date     89.02.17.21.59.14;  author bart;  state Exp;
branches ;
next     36.28;

36.28
date     89.02.17.20.18.28;  author bart;  state Exp;
branches ;
next     36.27;

36.27
date     89.02.17.16.25.03;  author bart;  state Exp;
branches ;
next     36.26;

36.26
date     89.02.17.16.23.24;  author bart;  state Exp;
branches ;
next     36.25;

36.25
date     89.02.17.16.07.44;  author bart;  state Exp;
branches ;
next     36.24;

36.24
date     89.02.17.15.22.45;  author bart;  state Exp;
branches ;
next     36.23;

36.23
date     89.02.17.15.17.09;  author bart;  state Exp;
branches ;
next     36.22;

36.22
date     89.02.17.15.13.38;  author bart;  state Exp;
branches ;
next     36.21;

36.21
date     89.02.17.15.11.31;  author bart;  state Exp;
branches ;
next     36.20;

36.20
date     89.02.17.15.08.06;  author bart;  state Exp;
branches ;
next     36.19;

36.19
date     89.02.17.14.50.10;  author bart;  state Exp;
branches ;
next     36.18;

36.18
date     89.02.17.14.36.12;  author bart;  state Exp;
branches ;
next     36.17;

36.17
date     89.02.17.13.40.00;  author bart;  state Exp;
branches ;
next     36.16;

36.16
date     89.02.17.13.18.14;  author bart;  state Exp;
branches ;
next     36.15;

36.15
date     89.02.16.15.07.44;  author bart;  state Exp;
branches ;
next     36.14;

36.14
date     89.02.16.11.46.17;  author bart;  state Exp;
branches ;
next     36.13;

36.13
date     89.02.16.11.29.11;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     89.02.16.11.23.54;  author bart;  state Exp;
branches ;
next     36.11;

36.11
date     89.02.15.16.36.05;  author bart;  state Exp;
branches ;
next     36.10;

36.10
date     89.02.15.13.05.32;  author bart;  state Exp;
branches ;
next     36.9;

36.9
date     89.02.13.16.53.52;  author bart;  state Exp;
branches ;
next     36.8;

36.8
date     89.02.13.15.56.38;  author bart;  state Exp;
branches ;
next     36.7;

36.7
date     89.02.13.14.46.06;  author bart;  state Exp;
branches ;
next     36.6;

36.6
date     89.02.13.13.18.52;  author bart;  state Exp;
branches ;
next     36.5;

36.5
date     89.02.13.11.52.29;  author bart;  state Exp;
branches ;
next     36.4;

36.4
date     89.02.06.13.23.14;  author bart;  state Exp;
branches ;
next     36.3;

36.3
date     89.01.27.13.13.10;  author bart;  state Exp;
branches ;
next     36.2;

36.2
date     89.01.12.12.18.49;  author bart;  state Exp;
branches ;
next     36.1;

36.1
date     89.01.10.13.49.17;  author bart;  state Exp;
branches ;
next     36.0;

36.0
date     89.01.10.13.42.53;  author bart;  state Exp;
branches ;
next     ;


desc
@@


39.9
log
@Uses MonitorListSemaphore for safe default_monitor checking.
TrueModeID() filters out NTSC/PAL ScanDbl modes when promoting.
@
text
@/******************************************************************************
*
*   $Id: find_key.c,v 39.8 92/06/03 18:10:14 spence Exp Locker: spence $
*
*   $Locker: spence $
*
******************************************************************************/

/* find_key.c -- search a record and its siblings for a specific key */

#include    <exec/types.h>
#include    <exec/memory.h>
#include    "/view.h"
#include    "/gfxbase.h"
#include    "/displayinfo_internal.h"
#include    "d.protos"
#include    "/macros.h"
#include    "/gfxpragmas.h"
#include    <pragmas/utility_pragmas.h>

#include    "/displayinfo.h"
#include    "/displayinfo_internal.h"

/***** display.library/FindKey ***********************************************
*
*   NAME
*       FindKey -- search for a record identified by a specific key
*
*   SYNOPSIS
*       match = FindKey( record, key, mask )
*       d0                a1   d1:16 d0:16
*
*   FUNCTION
*
*   INPUTS
*       record - pointer to a Record
*       key  - unsigned word identifier
*       mask - unsigned word template for which bits to respect in key
*
*   RESULT
*       match - pointer to a display Record with that key or NULL if no match.
*
*   BUGS
*
*   SEE ALSO
*
*******************************************************************************/

struct DisplayInfoRecord __regargs *find_key( match, key, mask )
struct DisplayInfoRecord *match;
UWORD           key;
UWORD           mask;
{
    UWORD       match_key = ( key & mask );

    Forbid();

    for( ; match; match = (struct DisplayInfoRecord *)match->rec_Node.rcn_Succ )
    {
	if( match_key  == (match->rec_MinorKey & mask) ) break;
    }

    Permit();

    return( match );
}

ULONG __regargs MakeTrueID(struct DisplayInfoRecord *root, ULONG ID)
{
    ULONG t = ID;
    UWORD m;

    /* This will attempt to return the true value of DEFAULT monitors.
     * DEFAULT monitors are either NTSC, PAL, DBLNTSC or DBLPAL, depending
     * on the value in GBASE->monitor_id, set in SetDefaultMonitor().
     */

    if (root == GBASE->DisplayInfoDataBase)
    {
	UWORD tID = (ID >> 16);

	ObtainSemaphore(GBASE->MonitorListSemaphore);
	
#ifdef USE_BESTMODE
	/* Should really use this, but is too slow */
	/* How about the default? */
	if ((tID == (DEFAULT_MONITOR_ID >> 16)) && (m = GBASE->monitor_id))
	{
		ULONG best;
		t |= ((m << 16) | 0x1000);
		if ((m == (DBLNTSC_MONITOR_ID >> 16)) || (m == (DBLPAL_MONITOR_ID >> 16)))
		{
			tags[0].ti_Data = ((m << 16) | 0x1000);
			tags[1].ti_Data = (ID | ((m == (DBLNTSC_MONITOR_ID >> 16)) ? NTSC_MONITOR_ID : PAL_MONITOR_ID));
			if ((best = BestModeIDA(tags)) != INVALID_ID)
			{
				t = best
			}
			else
			{
				t = tags[1].ti_Data;	/* use plain old NTSC/PAL */
			}
		}
	}
#else
	/* How about the default? */
	if ((tID == (DEFAULT_MONITOR_ID >> 16)) && (m = GBASE->monitor_id))
	{
		t |= ((m << 16) | 0x1000);
	}
#endif
	tID = (t >> 16);
	/* Any extra fudging we need? */
	if ((tID == (DBLNTSC_MONITOR_ID >> 16)) || (tID == (DBLPAL_MONITOR_ID >> 16)))
	{
		/* Dbl... modes don't support SuperHires, nor can
		 * we promote the ScanDbl modes.
		 */
		t &= ~(SUPERHIRES | DOUBLESCAN);
	}

	ReleaseSemaphore(GBASE->MonitorListSemaphore);
    }

    return(t);
}

/***** display.library/FindID ***********************************************
*
*   NAME
*       FindID -- find a record given its display identifier
*
*   SYNOPSIS
*       record = FindID( root, ID)
*       d0               a1        d0     
*
*   FUNCTION
*
*   INPUTS
*       root - pointer to a Display DataBase RecordNode ("effective root")
*       ID       - unsigned long display ID
*
*   RESULT
*       record   - pointer to a record associate with this ID or NULL
*
*   BUGS
*
*   SEE ALSO
*       NextID(), display/record.h
*
*******************************************************************************/

struct DisplayInfoRecord __regargs *find_id( root, ID )
struct DisplayInfoRecord *root;
ULONG   ID;
{
    struct DisplayInfoRecord *type = NULL;
    struct DisplayInfoRecord *dinfo = NULL;
    UWORD major;
    UWORD minor;

    major  = ID >> 16;
    minor  = ID & 0xFFFF;

    if(ID != INVALID_ID)
    {
	if(root && (type = find_key( (struct DisplayInfoRecord *)(SubRecord(root)), major, (UWORD)~0 )) )
	{
	    dinfo = find_key( (struct DisplayInfoRecord *)(SubRecord(type)), minor, (UWORD)~0 );
	    return( dinfo );
	}
    }

    return( NULL );
}

ULONG no_copy() 
{
    return(0);
}

ULONG get_copy(record,src,size,tagID,ID,dst,bytes)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
{
    ULONG result = 0;
    ULONG raw = 0;

    switch(*tagID)
    {
	case( DTAG_DISP ):
	{
	    raw = (ULONG)(((struct RawDisplayInfo *)(0))->reserved[0]);
	}   break;
	case( DTAG_DIMS ):
	{
	    result = get_dims(record,src,size,tagID,ID,dst,bytes);
	}   break;
	case( DTAG_MNTR ):
	{
	    raw = (ULONG)(((struct RawMonitorInfo *)(0))->reserved[0]);
	}   break;
	case( DTAG_NAME ):
	{
	    raw = (ULONG)(((struct RawNameInfo *)(0))->reserved[0]);
	}   break;
	case( DTAG_VEC ):
	{
	    raw = (ULONG)(((struct RawVecInfo *)(0))->reserved[0]);
	}   break;
	default:
	{
	}   break;
    }

    if (raw)
    {
	result = copy_dbstuff(src, size, dst, bytes, raw);
    }

    return( result );
}

ULONG set_copy(record,src,size,tagID,ID,dst,bytes)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
{
    ULONG result = 0;
    ULONG raw = 0;

    switch(*tagID)
    {
	case( DTAG_DISP ):
	{
	    raw = (ULONG)(((struct RawDisplayInfo *)(0))->reserved[0]);
	}   break;
	case( DTAG_DIMS ):
	{
	    result = set_dims(record,src,size,tagID,ID,dst,bytes);
	}   break;
	case( DTAG_MNTR ):
	{
	    result = set_mntr(record,src,size,tagID,ID,dst,bytes);
	}   break;
	case( DTAG_NAME ):
	{
	    raw = (ULONG)(((struct RawNameInfo *)(0))->reserved[0]);
	}   break;
	case( DTAG_VEC ):
	{
	    raw = (ULONG)(((struct RawVecInfo *)(0))->reserved[0]);
	}   break;
	default:
	{
	}   break;
    }

    if (raw)
    {
	result = copy_dbstuff(src, size, dst, bytes, raw);
    }

    return( result );
}

ULONG raw_copy(record,src,size,tagID,ID,dst,bytes)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
{
    return(copy_dbstuff(src, size, dst, bytes, *size));
}

ULONG __regargs cook( root, handle, buf, size, tagID, ID, mode )
struct DisplayInfoRecord *root;
struct DisplayInfoRecord *handle;
UBYTE buf[];
ULONG size;
ULONG tagID;
ULONG ID;
ULONG mode;
{
    ULONG result = 0;
    ULONG (*sfunc)() = no_copy; /* system function */
    ULONG (*ufunc)() = NULL; 	/* no usr function */
    struct DisplayInfoRecord *dinfo = handle;

    if(buf)
    {
	if((dinfo) || (dinfo = (struct DisplayInfoRecord *)gfx_FindDisplayInfo(ID)))
	{
	    struct DisplayInfoRecord *record = dinfo;
	    struct QueryHeader *query = NULL; 

	    switch( tagID )
	    {
		case( DTAG_MNTR ):
		{
		    /* monitor is global to a family of modes */
		    record = (struct DisplayInfoRecord *)(dinfo->rec_Node.rcn_Parent);
		}   break;
	    }

	    switch( mode )
	    {
		case( GET_DISPLAYINFODATA ):
		{
		    sfunc = get_copy;
		    ufunc = record->rec_get_data;
		}   break;
		case( SET_DISPLAYINFODATA ):
		{
		    sfunc = set_copy;
		    ufunc = record->rec_set_data;
		}   break;
		case( NEW_DISPLAYINFODATA ):
		{
		    sfunc = raw_copy;
		}   break;
	    }

	    if(record) /* effective destination */
	    {
		UBYTE *src;
		UBYTE *dst;
		ULONG  bytes = ( sizeof( struct TagItem ) );

		query = (struct QueryHeader *)FindTagItem(tagID,&record->rec_Tag);

		switch( mode )
		{
		    case( GET_DISPLAYINFODATA ):
		    {
			src = (UBYTE *)query;
			dst = (UBYTE *)buf;
		    }   break;
		    case( SET_DISPLAYINFODATA ):
		    {
			src = (UBYTE *)buf;
			dst = (UBYTE *)query;
		    }   break;
		    case( NEW_DISPLAYINFODATA ):
		    {
			src = (UBYTE *)buf;
			if(!(dst = (UBYTE *)query))
			{	
			    dst = (UBYTE *)AllocMem(size, MEMF_PUBLIC|MEMF_CLEAR);
			    query = (struct QueryHeader *)dst;
			}
		    }   break;
		}

		if(src && dst)
		{
		    int chunk = FALSE;

		    if(((struct QueryHeader*)src)->SkipID == TAG_SKIP)
		    {
			chunk  = TRUE;
			bytes += (sizeof(*query)
			      +(((struct QueryHeader*)src)->Length<<3));
		    }

		    /* call the system function first */
		    {
			UBYTE *a = src;
			ULONG  b = size;
			UBYTE *c = dst;
			ULONG  d = bytes;
			
			result = 
			(*sfunc)(&dinfo,&src,&size,&tagID,&ID,&dst,&bytes);

			/* now call the user function, if any */

			if(ufunc)
			{
			    (*ufunc)(&dinfo,&a,&b,&tagID,&ID,&c,&d,&result);
			}
		    }

		    switch( mode )
		    {
			case( NEW_DISPLAYINFODATA ):
			{
			    if (chunk)
			    {
				query->DisplayID =  /* set dstID */
				*((ULONG *)(&dinfo->rec_MajorKey));
			    }
			    add_tag( &record->rec_Tag, query );
			}   break;
		    }
		}
	    }
	}
    }

    return( result );
}


@


39.8
log
@removed HardPromotion code.
FindID() no longer calls TrueModeID() (already done by find_info())
@
text
@d3 1
a3 1
*   $Id: find_key.c,v 39.7 92/05/13 11:34:41 spence Exp Locker: spence $
a75 8
     *
     * Also, specific NTSC and PAL modes can be forced to a new monitor
     * type by looking at their mapping values in GBASE->control_delta_pal and
     * GBASE->control_delta_ntsc. These are also set by SetDefaultMonitor().
     *
     * NB - GBASE->control_delta_pal/ntsc was used by V37 MakeVPort() for the
     * hedley code, but is now recycled for V39. These hold either 0 or DBLNTSC and
     * DBLPAL values respectively.
d81 2
d116 4
a119 8
		/* Dbl... modes don't support SuperHires */
		t &= ~(SUPERHIRES);
//		if (t & SUPERHIRES)
//		{
//			/* Put back to NTSC or PAL */
//			t &= ~(MONITOR_ID_MASK);
//			t |= ((tID == (DBLNTSC_MONITOR_ID >> 16)) ? NTSC_MONITOR_ID : PAL_MONITOR_ID);
//		}
d121 2
@


39.7
log
@Added MakeTrueID() to replace DEFAULT modes with GBASE->monitor_id.
Also replaced NTSC and PAL modes with GBASE->control_delta_ntsc/pal
as experimental hard-promotion
@
text
@d3 1
a3 1
*   $Id: find_key.c,v 39.6 92/04/15 15:45:43 spence Exp Locker: spence $
d89 5
a93 3

	/* Maybe promote NTSC or PAL? */
	if ((tID == (NTSC_MONITOR_ID >> 16)) && (m = GBASE->control_delta_ntsc))
d95 15
a109 1
		t = ((t & 0xffff) | (m << 16));
d111 1
a111 5
	if ((tID == (PAL_MONITOR_ID >> 16)) && (m = GBASE->control_delta_pal))
	{
		t = ((t & 0xffff) | (m << 16));
	}
	
d117 1
a117 1

d124 6
a168 2

    ID = MakeTrueID(root, ID);
@


39.6
log
@Uses GBASE instead of GB=FETCGHGBASE
removed (un)cook_id() and add_id() (callers now go directly to cook()).
get_copy() and set_copy() optimised for only one call to copy_dbstuff().
@
text
@d3 1
a3 1
*   $Id: find_key.c,v 39.5 92/01/21 13:33:52 chrisg Exp Locker: spence $
d13 1
d19 1
a19 1
#include <pragmas/utility_pragmas.h>
d68 50
d152 1
a152 7
    if(GBASE->monitor_id) /* normally NULL, if not will override default */
    {
	ID |= ((root != GBASE->DisplayInfoDataBase) 
		|| (ID & MONITOR_ID_MASK)) ? 
		NULL : 
		((GBASE->monitor_id << 16) | 0x1000);
    }
@


39.5
log
@ Now use utility.library's tag functions
@
text
@d3 1
a3 1
*   $Id: find_key.c,v 39.4 92/01/17 12:06:35 spence Exp Locker: chrisg $
d5 1
a5 1
*   $Locker: chrisg $
d12 1
d14 1
d17 1
a97 1
    struct GfxBase *GB;
d101 1
a101 3
    GB = FETCHGBASE;

    if( GB->monitor_id ) /* normally NULL, if not will override default */
d103 2
a104 2
	ID |= ( (root != GB->DisplayInfoDataBase) 
		|| (ID & MONITOR_ID_MASK) ) ? 
d106 1
a106 1
		((GB->monitor_id << 16) | 0x1000);
d112 1
a112 1
    if( ID != INVALID_ID)
d114 1
a114 1
	if( root && (type = find_key( (struct DisplayInfoRecord *)(SubRecord(root)), major, (UWORD)~0 )) )
a123 6
#include <exec/memory.h>

#define GET_DISPLAYINFODATA 0
#define SET_DISPLAYINFODATA 1
#define NEW_DISPLAYINFODATA 2

d139 1
d145 1
a145 1
	    result = copy_dbstuff(record,src,size,tagID,ID,dst,bytes, (ULONG)(((struct RawDisplayInfo *)(0))->reserved[0]));
d153 1
a153 1
	    result = copy_dbstuff(record,src,size,tagID,ID,dst,bytes, (ULONG)(((struct RawMonitorInfo *)(0))->reserved[0]));
d157 1
a157 1
	    result = copy_dbstuff(record,src,size,tagID,ID,dst,bytes, (ULONG)(((struct RawNameInfo *)(0))->reserved[0]));
d161 1
a161 1
	    result = copy_dbstuff(record,src,size,tagID,ID,dst,bytes, (ULONG)(((struct RawVecInfo *)(0))->reserved[0]));
d168 5
d186 1
d192 1
a192 1
	    result = copy_dbstuff(record,src,size,tagID,ID,dst,bytes,(ULONG)(((struct RawDisplayInfo *)(0))->reserved[0]));
d204 1
a204 1
	    result = copy_dbstuff(record,src,size,tagID,ID,dst,bytes, (ULONG)(((struct RawNameInfo *)(0))->reserved[0]));
d208 1
a208 1
	    result = copy_dbstuff(record,src,size,tagID,ID,dst,bytes, (ULONG)(((struct RawVecInfo *)(0))->reserved[0]));
d215 5
d232 1
a232 6
    ULONG result = 0;
    while(((*size)--) && ((*bytes)--) && (++result))
    {
	*(*dst)++ = *(*src)++;
    }
    return( result );
d249 1
a249 1
    if( buf )
d251 1
a251 1
	if( ( dinfo ) || ( dinfo = FindDisplayInfo( ID ) ) )
a362 129
/***** display.library/QueryID ***********************************************
*
*   NAME
*       QueryID -- query Record parameters
*
*   SYNOPSIS
*       result = QueryID( root, ID, buf, size, tagID )
*       d0                a1    d0  a0   d1    d2
*
*       struct Record *root
*	ULONG  ID;
*	UBYTE  buf[];
*	ULONG  size;
*	ULONG  tagID;
*	
*	ULONG  result;
*
*   FUNCTION
*
*   INPUTS
*       root  - pointer to a Display DataBase RecordNode ("effective root")
*       ID    - displayinfo identifier
*	buf   - pointer to destination buffer
*	size  - buffer size in bytes
*	tagID - query tag type
*
*   RESULT
*       result - if positive, number of bytes actually copied
*		 if zero, no information for ID was available
*   BUGS
*
*   SEE ALSO
*       FindID(), NextID(), ModifyID(), display/record.h
*
*******************************************************************************/

ULONG __regargs cook_id( root, handle, buf, size, tagID, ID )
struct DisplayInfoRecord *root;
struct DisplayInfoRecord *handle;
UBYTE buf[];
ULONG size;
ULONG tagID;
ULONG ID;
{
    return( cook( root, handle, buf, size, tagID, ID , GET_DISPLAYINFODATA ) );
}

/***** display.library/AddID ***********************************************
*
*   NAME
*       AddID -- new Record parameters
*
*   SYNOPSIS
*       result = AddID( root, ID, buf, size, tagID )
*       d0              a1    d0  a0   d1    d2
*
*       struct Record *root
*	ULONG  ID;
*	UBYTE  buf[];
*	ULONG  size;
*	ULONG  tagID;
*	
*	ULONG  result;
*
*   FUNCTION
*
*   INPUTS
*       root  - pointer to a Display DataBase RecordNode ("effective root")
*       ID    - displayinfo identifier
*	buf   - pointer to source buffer
*	size  - buffer size in bytes
*	tagID - query tag type
*
*   RESULT
*       result - if positive, number of bytes actually added
*		 if zero, new information could not be added 
*   BUGS
*
*   SEE ALSO
*       FindID(), NextID(), QueryID(), display/record.h
*
*******************************************************************************/

ULONG __regargs add_id( root, handle, buf, size, tagID, ID )
struct DisplayInfoRecord *root;
struct DisplayInfoRecord *handle;
UBYTE buf[];
ULONG size;
ULONG tagID;
ULONG ID;
{
    return( cook( root, handle, buf, size, tagID, ID ,NEW_DISPLAYINFODATA ) );
}

/***** display.library/ModifyID ***********************************************
*
*   NAME
*       ModifyID -- change Record parameters
*
*   SYNOPSIS
*       result = ModifyID( root, ID, buf, size, tagID )
*       d0                 a1    d0  a0   d1    d2
*
*       struct Record *root
*	ULONG  ID;
*	UBYTE  buf[];
*	ULONG  size;
*	ULONG  tagID;
*	
*	ULONG  result;
*
*   FUNCTION
*
*   INPUTS
*       root  - pointer to a Display DataBase RecordNode ("effective root")
*       ID    - displayinfo identifier
*	buf   - pointer to source buffer
*	size  - buffer size in bytes
*	tagID - query tag type
*
*   RESULT
*       result - if positive, number of bytes actually copied
*		 if zero, no information for ID was available
*   BUGS
*
*   SEE ALSO
*       FindID(), NextID(), QueryID(), display/record.h
*
*******************************************************************************/
a363 10
ULONG __regargs uncook_id( root, handle, buf, size, tagID, ID )
struct DisplayInfoRecord *root;
struct DisplayInfoRecord *handle;
UBYTE buf[];
ULONG size;
ULONG tagID;
ULONG ID;
{
    return( cook( root, handle, buf, size, tagID, ID ,SET_DISPLAYINFODATA ) );
}
@


39.4
log
@get/set_dbstuff() changed to copy_dbstuff()
@
text
@d3 1
a3 1
*   $Id: find_key.c,v 39.3 92/01/07 15:56:25 spence Exp Locker: spence $
d5 1
a5 1
*   $Locker: spence $
d12 1
a12 1
#include    <graphics/gfxbase.h>
d15 2
d288 1
a288 1
		query = (struct QueryHeader *)find_tag(&record->rec_Tag,tagID);
@


39.3
log
@find_info -> FindDisplayInfo etc.
@
text
@d3 1
a3 1
*   $Id: find_key.c,v 39.2 92/01/07 13:46:27 spence Exp Locker: spence $
d148 1
a148 1
	    result = get_dbstuff(record,src,size,tagID,ID,dst,bytes, (ULONG)(((struct RawDisplayInfo *)(0))->reserved[0]));
d156 1
a156 1
	    result = get_dbstuff(record,src,size,tagID,ID,dst,bytes, (ULONG)(((struct RawMonitorInfo *)(0))->reserved[0]));
d160 1
a160 1
	    result = get_dbstuff(record,src,size,tagID,ID,dst,bytes, (ULONG)(((struct RawNameInfo *)(0))->reserved[0]));
d164 1
a164 1
	    result = get_dbstuff(record,src,size,tagID,ID,dst,bytes, (ULONG)(((struct RawVecInfo *)(0))->reserved[0]));
d189 1
a189 1
	    result = set_dbstuff(record,src,size,tagID,ID,dst,bytes,(ULONG)(((struct RawDisplayInfo *)(0))->reserved[0]));
d201 1
a201 1
	    result = set_dbstuff(record,src,size,tagID,ID,dst,bytes, (ULONG)(((struct RawNameInfo *)(0))->reserved[0]));
d205 1
a205 1
	    result = set_dbstuff(record,src,size,tagID,ID,dst,bytes, (ULONG)(((struct RawVecInfo *)(0))->reserved[0]));
@


39.2
log
@space savings - get/set_... functions coalesced into a single
get/set_dbstuff() call. The calls only differed in the number of bytes
to move, which is now passed as a parameter to get/set_dbstuff().
@
text
@d3 1
a3 1
*   $Id: find_key.c,v 39.1 91/10/18 16:25:50 spence Exp Locker: spence $
d248 1
a248 1
	if( ( dinfo ) || ( dinfo = find_info( ID ) ) )
@


39.1
log
@ProgInfo -> VecInfo changes.

@
text
@d3 1
a3 1
*   $Id: find_key.c,v 39.0 91/08/21 17:30:29 chrisg Exp Locker: spence $
d148 1
a148 1
	    result = get_disp(record,src,size,tagID,ID,dst,bytes);
d156 1
a156 1
	    result = get_mntr(record,src,size,tagID,ID,dst,bytes);
d160 1
a160 1
	    result = get_name(record,src,size,tagID,ID,dst,bytes);
d164 1
a164 1
	    result = get_vec(record,src,size,tagID,ID,dst,bytes);
d189 1
a189 1
	    result = set_disp(record,src,size,tagID,ID,dst,bytes);
d201 1
a201 1
	    result = set_name(record,src,size,tagID,ID,dst,bytes);
d205 1
a205 1
	    result = set_vec(record,src,size,tagID,ID,dst,bytes);
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*   $Id: find_key.c,v 38.0 91/06/14 11:21:41 spence Exp Locker: chrisg $
d5 1
a5 1
*   $Locker: chrisg $
d162 1
a162 1
	case( DTAG_PROG ):
d164 1
a164 1
	    result = get_prog(record,src,size,tagID,ID,dst,bytes);
d203 1
a203 1
	case( DTAG_PROG ):
d205 1
a205 1
	    result = set_prog(record,src,size,tagID,ID,dst,bytes);
@


38.0
log
@support for DTAG_PROG
.,
@
text
@d3 1
a3 1
*   $Id: find_key.c,v 37.3 91/05/15 12:57:28 spence Exp Locker: spence $
d5 1
a5 1
*   $Locker: spence $
@


37.3
log
@Use protos. Registerized parameters. Removed compiler warnings
@
text
@d3 1
a3 1
*   $Id: find_key.c,v 37.2 91/05/09 14:25:49 spence Exp Locker: spence $
d13 1
a13 1
#include	"d.protos"
d15 1
d162 4
d202 4
@


37.2
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Id: find_key.c,v 37.1 91/03/08 17:04:33 spence Exp Locker: spence $
d13 1
d42 1
a42 1
struct DisplayInfoRecord *find_key( match, key, mask )
d51 1
a51 1
    for( ; match; match = match->rec_Node.rcn_Succ )
d86 1
a86 1
struct DisplayInfoRecord *find_id( root, ID )
d111 1
a111 1
	if( root && (type = find_key( SubRecord(root), major, ~0 )) )
d113 1
a113 1
	    dinfo = find_key( SubRecord(type), minor, ~0 );
d223 1
a223 1
ULONG  cook( root, handle, buf, size, tagID, ID, mode )
a231 1
    int error = FALSE;
d249 1
a249 1
		    record = dinfo->rec_Node.rcn_Parent;
d296 2
a297 2
			    dst = AllocMem(size,MEMF_PUBLIC|MEMF_CLEAR);
			    query = dst;
d387 1
a387 1
ULONG  cook_id( root, handle, buf, size, tagID, ID )
d434 1
a434 1
ULONG  add_id( root, handle, buf, size, tagID, ID )
d481 1
a481 1
ULONG  uncook_id( root, handle, buf, size, tagID, ID )
@


37.1
log
@cook() now calls find_info() if passed a NULL handle and an ID, instead
of calling find_id(). fiind_info() calls find_id() anyway, and also unpacks
from ROM to RAM if needed.
@
text
@d3 1
a3 1
*   $Id: find_key.c,v 37.0 91/01/07 15:21:26 spence Exp Locker: spence $
d13 2
a14 2
#include    "../macros.h"
#include    "../displayinfo_internal.h"
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*   $Id: find_key.c,v 36.35 90/07/27 16:37:18 bart Exp Locker: spence $
d239 1
a239 1
	if( ( dinfo ) || ( dinfo = find_id( root, ID ) ) )
@


36.35
log
@id
@
text
@d3 1
a3 1
*   $Id: $
d5 1
a5 1
*   $Locker: bart $
@


36.34
log
@GB->monitor_id normally NULL, if not will override default
@
text
@d3 1
a3 1
*   $Header: /usr2/bart/v1.4/src/kickstart/working/graphics/d/RCS/find_key.c,v 36.33 90/03/28 09:30:42 bart Exp Locker: bart $
@


36.33
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: /usr/commodore/amiga/V36/src/kickstart/graphics/d/RCS/find_key.c,v 36.32 89/08/17 13:13:11 bart Exp Locker: bart $
d11 3
a88 2
    UWORD major  = ID >> 16;
    UWORD minor  = ID & 0xFFFF;
d91 16
@


36.32
log
@TAG_SKIP
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.31 89/07/24 13:31:30 bart Exp $
@


36.31
log
@rec_get_data, rec_set_data
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.30 89/02/23 13:20:53 bart Exp $
d289 1
a289 1
		    if(((struct QueryHeader*)src)->StructIgnore == TAG_IGNORE)
@


36.30
log
@DTAG_
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.29 89/02/17 21:59:14 bart Exp $
d216 2
a217 1
    ULONG (*doit)() = no_copy;
a219 16
    switch( mode )
    {
	case( GET_DISPLAYINFODATA ):
	{
	    doit = get_copy;
	}   break;
	case( SET_DISPLAYINFODATA ):
	{
	    doit = set_copy;
	}   break;
	case( NEW_DISPLAYINFODATA ):
	{
	    doit = raw_copy;
	}   break;
    }

d236 18
d296 9
a304 3
		    /* here there be dragons... -- bart */
		    result = 
		    (*doit)(&dinfo,&src,&size,&tagID,&ID,&dst,&bytes);
d306 6
a311 4
		    /*
		    while((size--) && (bytes--) && (++result))
		    {
			*dst++ = *src++;
a312 1
		    */
@


36.29
log
@checkpoint
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.28 89/02/17 20:18:28 bart Exp $
d127 1
a127 1
	case( TAG_DISP ):
d131 1
a131 1
	case( TAG_DIMS ):
d135 1
a135 1
	case( TAG_MNTR ):
d139 1
a139 1
	case( TAG_NAME ):
d164 1
a164 1
	case( TAG_DISP ):
d168 1
a168 1
	case( TAG_DIMS ):
d172 1
a172 1
	case( TAG_MNTR ):
d176 1
a176 1
	case( TAG_NAME ):
d244 1
a244 1
		case( TAG_MNTR ):
@


36.28
log
@removed kprintfs
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.27 89/02/17 16:25:03 bart Exp $
@


36.27
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.26 89/02/17 16:23:24 bart Exp $
a128 1
	    kprintf("get_copy: tagID = TAG_DISP\n");
a132 1
	    kprintf("get_copy: tagID = TAG_DIMS\n");
a136 1
	    kprintf("get_copy: tagID = TAG_MNTR\n");
a140 1
	    kprintf("get_copy: tagID = TAG_NAME\n");
a144 1
	    kprintf("get_copy: unknown tagID = %08lx\n",tagID);
a147 1
    kprintf("get_copy: result = %ld\n",result);
a165 1
	    kprintf("set_copy: tagID = TAG_DISP\n");
a169 1
	    kprintf("set_copy: tagID = TAG_DIMS\n");
a173 1
	    kprintf("set_copy: tagID = TAG_MNTR\n");
a177 1
	    kprintf("set_copy: tagID = TAG_NAME\n");
a181 1
	    kprintf("set_copy: unknown tagID = %08lx\n",tagID);
a184 1
    kprintf("set_copy: result = %ld\n",result);
@


36.26
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.25 89/02/17 16:07:44 bart Exp $
d153 1
a153 1
    kprintf("set_copy: result = %ld\n",result);
@


36.25
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.24 89/02/17 15:22:45 bart Exp $
d125 1
a125 1
    switch(tagID)
d168 1
a168 1
    switch(tagID)
@


36.24
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.23 89/02/17 15:17:09 bart Exp $
d129 1
d134 1
d139 1
d144 1
d147 4
d153 1
d172 1
d177 1
d182 1
d187 1
d190 4
d196 1
@


36.23
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.22 89/02/17 15:13:38 bart Exp $
d129 1
a129 1
	    result = get_disp(record,src,size,tagID,ID,dst,bytes)
d133 1
a133 1
	    result = get_dims(record,src,size,tagID,ID,dst,bytes)
d137 1
a137 1
	    result = get_mntr(record,src,size,tagID,ID,dst,bytes)
d141 1
a141 1
	    result = get_name(record,src,size,tagID,ID,dst,bytes)
d163 1
a163 1
	    result = set_disp(record,src,size,tagID,ID,dst,bytes)
d167 1
a167 1
	    result = set_dims(record,src,size,tagID,ID,dst,bytes)
d171 1
a171 1
	    result = set_mntr(record,src,size,tagID,ID,dst,bytes)
d175 1
a175 1
	    result = set_name(record,src,size,tagID,ID,dst,bytes)
@


36.22
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.21 89/02/17 15:11:31 bart Exp $
d124 2
a125 1
    while(((*size)--) && ((*bytes)--) && (++result))
d127 16
a142 1
	*(*dst)++ = *(*src)++;
d144 1
d148 8
a155 1
ULONG set_copy() 
d157 23
a179 1
    return(0);
@


36.21
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.20 89/02/17 15:08:06 bart Exp $
d131 1
a131 8
ULONG set_copy(record,src,size,tagID,ID,dst,bytes)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
d133 1
a133 6
    ULONG result = 0;
    while(((*size)--) && ((*bytes)--) && (++result))
    {
	*(*dst)++ = *(*src)++;
    }
    return( result );
@


36.20
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.19 89/02/17 14:50:10 bart Exp $
d114 34
d183 1
a183 1
	    doit = raw_copy;
d187 1
a187 1
	    doit = raw_copy;
@


36.19
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.18 89/02/17 14:36:12 bart Exp $
d124 1
a124 1
    while((*size--) && (*bytes--) && (++result))
d126 1
a126 1
	**dst++ = **src++;
a130 34
ULONG get_copy(record,src,size,tagID,ID,dst,bytes)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
{
    ULONG result = 0;
    while((*size--) && (*bytes--) && (++result))
    {
	**dst++ = **src++;
    }
    return( result );
}

ULONG set_copy(record,src,size,tagID,ID,dst,bytes)
struct DisplayInfoRecord **record;
UBYTE **src;
ULONG *size;
ULONG *tagID;
ULONG *ID;
UBYTE **dst;
ULONG *bytes;
{
    ULONG result = 0;
    while((*size--) && (*bytes--) && (++result))
    {
	**dst++ = **src++;
    }
    return( result );
}

d149 1
a149 1
	    doit = get_copy;
d153 1
a153 1
	    doit = set_copy;
d220 9
a228 1
		    result = (*doit)(&dinfo,&src,&size,&tagID,&ID,&dst,&bytes);
@


36.18
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.17 89/02/17 13:40:00 bart Exp $
d126 1
a126 1
	*dst++ = *src++;
d143 1
a143 1
	*dst++ = *src++;
d160 1
a160 1
	*dst++ = *src++;
@


36.17
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.16 89/02/17 13:18:14 bart Exp $
d89 1
a89 1
    struct DisplayInfoRecord *object = NULL;
d95 2
a96 2
	    object = find_key( SubRecord(type), minor, ~0 );
	    return( object );
d106 2
a107 2
#define NEW_DISPLAYINFODATA 1
#define SET_DISPLAYINFODATA 2
d109 56
d176 2
a177 1
    struct DisplayInfoRecord *object = handle;
d179 16
d197 1
a197 1
	if( ( object ) || ( object = find_id( root, ID ) ) )
d199 1
a199 1
	    struct DisplayInfoRecord *record = object;
d207 1
a207 1
		    record = object->rec_Node.rcn_Parent;
a208 4
		default:
		{
		    /* nothing to be done */
		}   break;
d213 2
a214 2
		register UBYTE *src;
		register UBYTE *dst;
d226 5
a239 9
		    case( SET_DISPLAYINFODATA ):
		    {
			src = (UBYTE *)buf;
			dst = (UBYTE *)query;
		    }   break;
		    default:
		    {
			dst = NULL;
		    }   break;
d253 2
a254 1
		    /* here thar be dragons... -- bart */
a257 7
			case( GET_DISPLAYINFODATA ):
			{
			    while((size--) && (bytes--) && (++result))
			    {
				*dst++ = *src++;
			    }
			}   break;
d260 1
a260 1
			    while((size--) && (bytes--) && (++result))
d262 2
a263 1
				*dst++ = *src++;
d265 1
a266 31
			case( SET_DISPLAYINFODATA ):
			{
			    while((size--) && (bytes--) && (++result))
			    {
				*dst++ = *src++;
			    }
			}   break;
			default:
			{
			    error = TRUE;
			}   break;
		    }

		    if(!error) 
		    {
			switch( mode )
			{
			    case( NEW_DISPLAYINFODATA ):
			    {
				if (chunk)
				{
				    query->DisplayID =  /* set dstID */
				    *((ULONG *)(&object->rec_MajorKey));
				}
				add_tag( &record->rec_Tag, query );
			    }   break;
			    default: 
			    {
				/* nothing to be done */
			    }   break;
			}
@


36.16
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.15 89/02/16 15:07:44 bart Exp $
d118 1
a188 4
		    while((size--) && (bytes--) && (++result))
		    {
			*dst++ = *src++;
		    }
d192 7
d201 1
a201 1
			    if (chunk)
d203 1
a203 2
				query->DisplayID =  /* set destination ID */
					*((ULONG *)(&object->rec_MajorKey));
a204 1
			    add_tag( &record->rec_Tag, query );
d206 1
a206 1
			default: 
d208 4
a211 1
			    /* nothing to be done */
d213 24
@


36.15
log
@monitorinfo shared among modes
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.14 89/02/16 11:46:17 bart Exp $
d143 4
d149 1
a149 1
		/* here thar be dragons... -- bart */
d151 24
a174 3
		    register UBYTE *src;
		    register UBYTE *dst;
		    ULONG  bytes = ( sizeof( struct TagItem ) );
d176 17
a194 5
			case( GET_DISPLAYINFODATA ):
			{
			    src = (UBYTE *)query;
			    dst = (UBYTE *)buf;
			}   break;
d197 4
a200 5
			    src = (UBYTE *)buf;
			    if(!(dst = (UBYTE *)query))
			    {	
				dst = AllocMem(size,MEMF_PUBLIC|MEMF_CLEAR);
				query = dst;
d202 1
d204 1
a204 1
			case( SET_DISPLAYINFODATA ):
d206 1
a206 2
			    src = (UBYTE *)buf;
			    dst = (UBYTE *)query;
a207 38
			default:
			{
			    dst = NULL;
			}   break;
		    }

		    if(src && dst)
		    {
			int chunk = FALSE;

			if(((struct QueryHeader*)src)->StructIgnore == TAG_IGNORE)
			{
			    chunk  = TRUE;
			    bytes += (sizeof(*query)
				  +(((struct QueryHeader*)src)->Length<<3));
			}

			while((size--) && (bytes--) && (++result))
			{
			    *dst++ = *src++;
			}

			switch( mode )
			{
			    case( NEW_DISPLAYINFODATA ):
			    {
				if (chunk)
				{
				    query->DisplayID =  /* set destination ID */
					    *((ULONG *)(&object->rec_MajorKey));
				}
				add_tag( &record->rec_Tag, query );
			    }   break;
			    default: 
			    {
				/* nothing to be done */
			    }   break;
			}
@


36.14
log
@displayid in queryheader
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.13 89/02/16 11:29:11 bart Exp $
a97 4
	else
	{
	    return( NULL );
	}
d99 2
d125 2
a126 2
	    struct QueryHeader *query = ( struct QueryHeader * )
				find_tag( &object->rec_Tag, tagID );
d128 1
a128 1
	    /* here thar be dragons... -- bart */
d130 1
a130 5
		register UBYTE *src;
		register UBYTE *dst;
		ULONG  bytes = ( sizeof( struct TagItem ) );

		switch( mode )
d132 4
a135 26
		    case( GET_DISPLAYINFODATA ):
		    {
			src = (UBYTE *)query;
			dst = (UBYTE *)buf;
		    }   break;
		    case( NEW_DISPLAYINFODATA ):
		    {
			src = (UBYTE *)buf;
			if(!(dst = (UBYTE *)query))
			{	
			    dst = AllocMem(size,MEMF_PUBLIC|MEMF_CLEAR);
			    query = dst;
			}
		    }   break;
		    case( SET_DISPLAYINFODATA ):
		    {
			src = (UBYTE *)buf;
			dst = (UBYTE *)query;
		    }   break;
		    default:
		    {
			dst = NULL;
		    }   break;
		}

		if(src && dst)
d137 3
a139 1
		    int chunk = FALSE;
d141 3
a143 6
		    if(((struct QueryHeader*)src)->StructIgnore == TAG_IGNORE)
		    {
			chunk  = TRUE;
			bytes += (sizeof(*query)
			      +(((struct QueryHeader*)src)->Length<<3));
		    }
d145 5
a149 4
		    while((size--) && (bytes--) && (++result))
		    {
			*dst++ = *src++;
		    }
d153 5
d160 5
a164 4
			    if (chunk)
			    {
				query->DisplayID =  /* set destination ID */
					*((ULONG *)(&object->rec_MajorKey));
a165 1
			    add_tag( &object->rec_Tag, query );
d167 1
a167 1
			default: 
d169 2
d172 38
@


36.13
log
@set chunk DisplayID if adding chunk
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.12 89/02/16 11:23:54 bart Exp $
d185 2
a186 1
				/* set chunk DisplayID */
@


36.12
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.11 89/02/15 16:36:05 bart Exp $
d165 2
d169 1
d183 4
@


36.11
log
@DisplayInfoRecord
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.10 89/02/15 13:05:32 bart Exp $
d49 1
a49 1
	if( match_key  == (match->rec_Key & mask) ) break;
@


36.10
log
@merge DisplayInfoDataBase with graphics
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.9 89/02/13 16:53:52 bart Exp $
d11 1
a11 2
#include    "record.h"
#include    "defines.h"
d13 1
a13 1
/****** display.library/FindKey ***********************************************
d38 2
a39 2
struct Record  *find_key( match, key, mask )
struct Record  *match;
d57 1
a57 1
/****** display.library/FindID ***********************************************
d82 2
a83 2
struct Record *find_id( root, ID )
struct Record *root;
d88 2
a89 2
    struct Record *type = NULL;
    struct Record *object = NULL;
d112 2
a113 2
struct Record  *root;
struct Record  *handle;
d121 1
a121 1
    struct Record *object = handle;
d194 1
a194 1
/****** display.library/QueryID ***********************************************
d231 2
a232 2
struct Record  *root;
struct Record  *handle;
d241 1
a241 1
/****** display.library/AddID ***********************************************
d278 2
a279 2
struct Record  *root;
struct Record  *handle;
d288 1
a288 1
/****** display.library/ModifyID ***********************************************
d325 2
a326 2
struct Record  *root;
struct Record  *handle;
@


36.9
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.8 89/02/13 15:56:38 bart Exp $
@


36.8
log
@add chunk works
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.7 89/02/13 14:46:06 bart Exp $
d126 1
a126 3
	if(!object ) object = find_id( root, ID ); /* no handle */

	if( object )
d131 1
a131 1
	    /* be all things to all people */
@


36.7
log
@add displayinfodata
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.6 89/02/13 13:18:52 bart Exp $
d152 1
d168 1
a168 1
		    if(src->StructIgnore == TAG_IGNORE) /* local data */
d170 2
a171 1
			bytes += ((sizeof(*query))+(query->Length << 3));
d177 11
@


36.6
log
@cook
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.5 89/02/13 11:52:29 bart Exp $
d106 2
d109 2
a110 1
#define SET_DISPLAYINFODATA 1
d122 1
d126 1
a126 1
	struct Record *object = find_id( root, ID );
d132 2
a133 1
	    if( query )
a138 5
		if(query->StructIgnore == TAG_IGNORE) /* local data */
		{
		    bytes += ((sizeof(*query))+(query->Length << 3));
		}

d146 8
d161 1
a161 1
			bytes = 0; /* error */
d165 1
a165 1
		while((size--) && (bytes--) && (++result))
d167 9
a175 1
		    *dst++ = *src++;
d231 47
d300 1
a300 1
*	buf   - pointer to destination buffer
@


36.5
log
@get/set/add displayinfodata
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.4 89/02/06 13:23:14 bart Exp $
d106 62
d200 1
a200 1
*       FindID(), NextID(), display/record.h
d212 2
a213 1
    ULONG result = 0;
d215 35
a249 3
    if( buf )
    {
	struct Record *object = find_id( root, ID );
d251 9
a259 23
	if( object )
	{
	    struct QueryHeader *query = ( struct QueryHeader * )
				find_tag( &object->rec_Tag, tagID );
	    if( query )
	    {
		register UBYTE *src = (UBYTE *)query;
		ULONG  bytes = ( sizeof( struct TagItem ) );

		if(query->StructIgnore == TAG_IGNORE) /* local data */
		{
		    bytes += ((sizeof(*query))+(query->Length << 3));
		}

		while((size--) && (bytes--) && (++result))
		{
		    *buf++ = *src++;
		}
	    }
	}
    }

    return( result );
@


36.4
log
@INVALID_ID
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.3 89/01/27 13:13:10 bart Exp $
d142 1
a142 1
ULONG  cook_id( root, ID, buf, size, tagID )
d144 1
a144 1
ULONG ID;
d147 2
@


36.3
log
@query routines
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.2 89/01/12 12:18:49 bart Exp $
d12 1
d87 4
a90 4
	UWORD major  = ID >> 16;
	UWORD minor  = ID & 0xFFFF;
	struct Record *type = NULL;
	struct Record *object = NULL;
d92 2
d103 1
d148 1
a148 1
	ULONG result = 0;
d150 5
a154 1
	if( buf )
d156 6
a161 1
	    struct Record *object = find_id( root, ID );
d163 1
a163 5
	    if( object )
	    {
		struct QueryHeader *query = ( struct QueryHeader * )
				    find_tag( &object->rec_Tag, tagID );
		if( query )
d165 2
a166 2
		    register UBYTE *src = (UBYTE *)query;
		    ULONG  bytes = ( sizeof( struct TagItem ) );
d168 3
a170 9
		    if(query->StructIgnore == TAG_IGNORE) /* local data */
		    {
			bytes += ((sizeof(*query))+(query->Length << 3));
		    }

		    while((size--) && (bytes--) && (++result))
		    {
			*buf++ = *src++;
		    }
d174 1
d176 1
a176 1
	return( result );
@


36.2
log
@checkpoint
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.1 89/01/10 13:49:17 bart Exp $
d102 72
@


36.1
log
@checkpoint
@
text
@d3 1
a3 1
*   $Header: find_key.c,v 36.0 89/01/10 13:42:53 bart Exp $
@


36.0
log
@added to rcs for updating
@
text
@d3 1
a3 1
*   $Header: $
d5 1
a5 1
*   $Locker:  $
@
