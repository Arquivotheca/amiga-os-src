head     39.17;
branch   ;
access   ;
symbols  rel39_24:39.17 rel39_18:39.17 rel39_97:39.14 rel39_90:39.14 rel39_89:39.14 rel39_82:39.14 rel39_76:39.13 rel39_71:39.11 rel39_65:39.11 rel39_64:39.11 rel39_61:39.11 rel39_60:39.11 rel39_55:39.11 rel39_47:39.10 rel39_39:39.9 rel39_38:39.9 rel39_37:39.8 rel39_35:39.8 rel39_34:39.8 V37_30:37.3 V37_29:37.2 V37_28:37.2 V37_25:37.2 V37_22:37.2 V37_21:37.2 V37_20:37.1 V37_19:37.1 V37_17:37.1 V37_15:37.0 V37_14:37.0 V37_13:37.0 V37_12:37.0 V37_11:37.0 V37_10:37.0 V37_9:37.0 V37_8:37.0 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.17 V36_208:36.17 V36_207:36.17 V36_205:36.17 V36_203:36.17 V36_202:36.17 V36_201:36.17 V36_200:36.17 V36_199:36.17 V36_198:36.17 V36_196:36.17 V36_195:36.17 V36_194:36.17 V36_193:36.17 V36_192:36.17 V36_191:36.17 V36_190:36.17 V36_189:36.17 V36_188:36.17 V36_187:36.17 V36_186:36.17 V36_185:36.17 V36_184:36.17 V36_183:36.17 V36_182:36.17 V36_181:36.17 V36_67:36.17;
locks    ; strict;
comment  @*   @;


39.17
date     93.04.15.14.28.43;  author spence;  state Exp;
branches ;
next     39.16;

39.16
date     93.02.15.11.14.47;  author spence;  state Exp;
branches ;
next     39.15;

39.15
date     93.02.10.19.46.43;  author spence;  state Exp;
branches ;
next     39.14;

39.14
date     92.08.11.14.06.50;  author spence;  state Exp;
branches ;
next     39.13;

39.13
date     92.07.24.12.25.28;  author spence;  state Exp;
branches ;
next     39.12;

39.12
date     92.07.24.12.05.47;  author spence;  state Exp;
branches ;
next     39.11;

39.11
date     92.04.15.15.48.01;  author spence;  state Exp;
branches ;
next     39.10;

39.10
date     92.03.18.16.03.48;  author spence;  state Exp;
branches ;
next     39.9;

39.9
date     92.03.03.10.37.51;  author spence;  state Exp;
branches ;
next     39.8;

39.8
date     92.01.17.12.08.56;  author spence;  state Exp;
branches ;
next     39.7;

39.7
date     92.01.07.15.56.59;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     91.12.31.14.32.18;  author spence;  state Exp;
branches ;
next     39.5;

39.5
date     91.10.18.17.03.34;  author spence;  state Exp;
branches ;
next     39.4;

39.4
date     91.10.17.10.57.44;  author spence;  state Exp;
branches ;
next     39.3;

39.3
date     91.10.09.11.23.23;  author spence;  state Exp;
branches ;
next     39.2;

39.2
date     91.10.08.19.42.06;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     91.10.08.11.54.34;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.31.20;  author chrisg;  state Exp;
branches ;
next     38.2;

38.2
date     91.07.22.15.00.30;  author spence;  state Exp;
branches ;
next     38.1;

38.1
date     91.06.14.11.14.04;  author spence;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.11.14.15.05;  author spence;  state Exp;
branches ;
next     37.5;

37.5
date     91.05.15.12.59.28;  author spence;  state Exp;
branches ;
next     37.4;

37.4
date     91.05.09.14.24.15;  author spence;  state Exp;
branches ;
next     37.3;

37.3
date     91.04.26.16.26.32;  author spence;  state Exp;
branches ;
next     37.2;

37.2
date     91.03.28.20.15.36;  author spence;  state Exp;
branches ;
next     37.1;

37.1
date     91.02.28.14.06.35;  author spence;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.21.42;  author spence;  state Exp;
branches ;
next     36.17;

36.17
date     90.07.27.16.38.48;  author bart;  state Exp;
branches ;
next     36.16;

36.16
date     90.03.28.09.30.24;  author bart;  state Exp;
branches ;
next     36.15;

36.15
date     90.01.31.15.32.24;  author bart;  state Exp;
branches ;
next     36.14;

36.14
date     90.01.04.10.05.46;  author bart;  state Exp;
branches ;
next     36.13;

36.13
date     89.10.31.13.02.28;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     89.08.17.13.13.40;  author bart;  state Exp;
branches ;
next     36.11;

36.11
date     89.04.28.19.48.38;  author bart;  state Exp;
branches ;
next     36.10;

36.10
date     89.04.12.13.09.50;  author bart;  state Exp;
branches ;
next     36.9;

36.9
date     89.02.24.09.25.59;  author bart;  state Exp;
branches ;
next     36.8;

36.8
date     89.02.21.17.31.37;  author bart;  state Exp;
branches ;
next     36.7;

36.7
date     89.02.20.16.15.30;  author bart;  state Exp;
branches ;
next     36.6;

36.6
date     89.02.20.16.06.27;  author bart;  state Exp;
branches ;
next     36.5;

36.5
date     89.02.20.15.44.57;  author bart;  state Exp;
branches ;
next     36.4;

36.4
date     89.02.17.22.00.26;  author bart;  state Exp;
branches ;
next     36.3;

36.3
date     89.02.16.11.24.18;  author bart;  state Exp;
branches ;
next     36.2;

36.2
date     89.02.15.16.36.36;  author bart;  state Exp;
branches ;
next     36.1;

36.1
date     89.02.15.13.06.04;  author bart;  state Exp;
branches ;
next     36.0;

36.0
date     89.02.15.12.53.29;  author bart;  state Exp;
branches ;
next     ;


desc
@@


39.17
log
@make_sdbl() now also sets the DIPF_IS_AA flag, so the scan-dbl modes
are not available under 'A' emulatiom
@
text
@/******************************************************************************
*
*   $Id: startup.c,v 39.16 93/02/15 11:14:47 spence Exp Locker: spence $
*
*   $Locker: spence $
*
******************************************************************************/

/* display library initialization */

#include "/modeid.h"
#include "/displayinfo.h"	/* remove this */
#include <exec/types.h>
#include <exec/nodes.h>
#include <exec/lists.h>
#include <exec/memory.h>
/*#include <graphics/gfxbase.h>*/
#include "/gfxbase.h"		/* remove this */
#include "/gfxpragmas.h"

#include "d.protos"
#include "/displayinfo_internal.h"
#include "/macros.h"
#include "init.h"
#include "proginfo.h"

void *getmustmem();

/*#define DEBUG*/

#ifdef DEBUG
#define D(x) {x};
#else
#define D(x)
#endif

int __regargs tag_copy(tag,buf)
struct TagItem *tag;
struct TagItem *buf;
{
	int count = 0;

	while( (++count) && (tag->ti_Tag != TAG_DONE) )
	{
	    /* stupid compiler ! substiture for brain dead switch -- bart */

	    if( tag->ti_Tag == TAG_SKIP )
	    {
		ULONG skip = tag->ti_Data + 1;

		--count; 
		do 
		{
		    count++;
		    if( buf ) *buf++ = *tag; 
		    tag++;
		}   while( --skip );
		continue;
	    } 

	    if( tag->ti_Tag == TAG_MORE )
	    {
		--count; tag = (struct TagItem *)tag->ti_Data;
		continue;
	    } 	

	    /* default case */
	    {
		if( buf ) *buf++ = *tag; tag++;
		continue;
	    }
	}  

	if( buf ) *buf++ = *tag++; /* terminator */

	return( count );
}

void bind_record( argc, argv, record, tags, cn, RawStuff)
int argc;
char *argv[];
struct DisplayInfoRecord *record;
UBYTE tags[];
struct RomCompressedNode *cn;
ULONG RawStuff;
{
    struct TagItem *copytags;
    struct TagItem dummytag;
    struct RawMonitorInfo rawdata;	/* RawMonitor is the largest of the squeezed Raw... structs */
    APTR sqz;			/* squeezed data */
    ULONG data;
    int size;
    UBYTE entry = tags[cn->tag];

    if (cn->tag)
    {
	dummytag.ti_Tag = TAG_MORE;
        switch (RawStuff)
        {
        	case DTAG_DISP: 
		{	/* unsqueeze it */
			struct RawDisplayInfo *rd = (struct RawDisplayInfo *)&rawdata;

			sqz = (APTR)(DispData + entry);
			rd->Header.Length = RAWDISP_SKIP;
			rd->NotAvailable = DI_AVAIL_NOMONITOR;
			if (((struct SqueezedDisplayInfo *)sqz)->PropertyFlags & (DIPF_IS_ECS | DIPF_IS_AA))
			{
				rd->NotAvailable |= DI_AVAIL_NOCHIPS;
			}
			rd->PropertyFlags = ((struct SqueezedDisplayInfo *)sqz)->PropertyFlags;
			rd->Resolution.x = (WORD)(((struct SqueezedDisplayInfo *)sqz)->Resolution.x);
			rd->Resolution.y = (WORD)(((struct SqueezedDisplayInfo *)sqz)->Resolution.y);
			rd->PixelSpeed = (UWORD)(((struct SqueezedDisplayInfo *)sqz)->PixelSpeed);
			if (rd->PropertyFlags & DIPF_IS_PANELLED)
			{
				rd->NumStdSprites = 1;
				rd->RedBits = 2; rd->GreenBits = 3; rd->BlueBits = 1;
			}
			else
			{
				rd->NumStdSprites = 8;
				rd->RedBits = rd->GreenBits = rd->BlueBits = 
				((rd->PixelSpeed == 35) ? 2 : 4);
			}
			rd->PaletteRange = ((struct SqueezedDisplayInfo *)sqz)->PaletteRange;
			rd->SpriteResolution.x = (WORD)(((struct SqueezedDisplayInfo *)sqz)->SpriteResolution.x);
			rd->SpriteResolution.y = (WORD)(((struct SqueezedDisplayInfo *)sqz)->SpriteResolution.y);
			rd->ModeID = ((struct SqueezedDisplayInfo *)sqz)->ModeID;
			rd->pad2[0] = rd->pad2[1] = rd->pad2[2] = rd->pad2[3] = rd->pad2[4] = 0;
			rd->reserved[0] = rd->reserved[1] = 0;
			rawdata.Header.StructID = DTAG_DISP;
			data = (ULONG)rd;
			break;
		}
        	case DTAG_DIMS: 
		{
			struct SqueezedDimensionInfo *sdi;
			struct RawDimensionInfo *rd = (struct RawDimensionInfo *)&rawdata;
			UBYTE DimsRange;

			sqz = (APTR)(DimsData + entry);
			sdi = (struct SqueezedDimensionInfo *)sqz;
			DimsRange = sdi->DimsRange;
			/* Unsqueeze it to Raw data */
			rd->Header.Length = RAWDIMS_SKIP;
			rd->MinRasterHeight = 1;
			rd->MaxRasterWidth = 16368;
			rd->MaxRasterHeight = 16384;
			switch (DimsRange & 7)	/* DIMS_RANGE values = 0-4 */
			{
				case DIMS_RANGE_LORES : rd->MinRasterWidth = 16; break;
				case DIMS_RANGE_HIRES : rd->MinRasterWidth = 32; break;
				case DIMS_RANGE_SHIRES : rd->MinRasterWidth = 64; break;
				case DIMS_RANGE_A2024NTSC : 
				{
					rd->MinRasterWidth = rd->MaxRasterWidth = 1008;
					rd->MinRasterHeight = rd->MaxRasterHeight = 800;
				}
				break;
				case DIMS_RANGE_A2024PAL : 
				{
					rd->MinRasterWidth = rd->MaxRasterWidth = 1008;
					rd->MinRasterHeight = rd->MaxRasterHeight = 1024;
				}
				break;
			}
			rd->MaxDepth = (UWORD)(((struct SqueezedDimensionInfo *)sqz)->MaxDepth);
			rd->HWMaxDepth = ((DimsRange & DIMS_DEPTH_HW6) ? 6 : 8);

			rd->Nominal.MinX = (LONG)sdi->Nominal.MinX;
			rd->Nominal.MinY = (LONG)sdi->Nominal.MinY;
			rd->Nominal.MaxX = (LONG)sdi->Nominal.MaxX;
			rd->Nominal.MaxY = (LONG)sdi->Nominal.MaxY;

			rd->MaxOScan.MinX = (LONG)sdi->MaxOScan.MinX;
			rd->MaxOScan.MinY = (LONG)sdi->MaxOScan.MinY;
			rd->MaxOScan.MaxX = (LONG)sdi->MaxOScan.MaxX;
			rd->MaxOScan.MaxY = (LONG)sdi->MaxOScan.MaxY;

			rd->VideoOScan.MinX = (LONG)sdi->VideoOScan.MinX;
			rd->VideoOScan.MinY = (LONG)sdi->VideoOScan.MinY;
			rd->VideoOScan.MaxX = (LONG)sdi->VideoOScan.MaxX;
			rd->VideoOScan.MaxY = (LONG)sdi->VideoOScan.MaxY;

			rd->pad[0] = rd->pad[1] = rd->pad[2] = rd->pad[3] = rd->pad[4] = 0;
			rd->reserved[0] = rd->reserved[1] = 0;
			rawdata.Header.StructID = DTAG_DIMS;
			data = (ULONG)&rawdata;
       			break;
       		}
        	case DTAG_MNTR: data = (ULONG)(MntrData + entry); break;
        	case DTAG_VEC:
		{	/* unsqueeze it */
			struct RawVecInfo *rd = (struct RawVecInfo *)&rawdata;

			rd->Header.Length = RAWVEC_SKIP;
			rd->Vec = rd->Data = NULL;
			rd->Type = entry;
			rd->pad[0] = rd->pad[1] = rd->pad[2] = 0;
			rd->reserved[0] = rd->reserved[1] = 0;
			rawdata.Header.StructID = DTAG_VEC;
			data = (ULONG)&rawdata;
			break;
		}
	};
	rawdata.Header.DisplayID = INVALID_ID;
	rawdata.Header.SkipID = TAG_SKIP;
	dummytag.ti_Data = data;
    }
    else
    {
	dummytag = NullData[0];
    }

    D(kprintf("bind_record(). ti_Tag = 0x%lx, ti_Data - 0x%lx\n", dummytag.ti_Tag, dummytag.ti_Data);)

    size = ( tag_copy( &dummytag, NULL ) * sizeof( struct TagItem ) );
    copytags = getmustmem( size, MEMF_PUBLIC );

    if( copytags )
    {
	int (*doit)() = NULL;

	tag_copy( &dummytag, copytags ); /* decompress data */

	if(argc && (size > sizeof(struct TagItem)))
	{
	    for( ;(doit = (int (*)())(*argv)) && (argc--); argv++) 
	    {
		(*doit)(copytags); /* massage chunkdata */
	    }
	}

	gfx_AddDisplayInfoData(record, (UBYTE *)copytags,size,copytags->ti_Tag,INVALID_ID);

	freemustmem( copytags, size );    /* delete temporary copy */
    }
}

struct DisplayInfoRecord __regargs *new_record(cn)
struct RomCompressedNode *cn;
{
    struct DisplayInfoRecord *record = (struct DisplayInfoRecord *)
    AllocMem(sizeof(struct DisplayInfoRecord),MEMF_PUBLIC|MEMF_CLEAR);

    if( record ) 
    {
	record->rec_MinorKey = cn->cid;
    }

    return( record );
}

int __regargs decompress(argc,argv,parent, tags, cn, RawStuff)
int argc;
char *argv[];
struct DisplayInfoRecord *parent;
UBYTE tags[];
struct RomCompressedNode *cn;
ULONG RawStuff;
{
	int count = 0;
	BYTE num = cn->cno;

	if(parent)
	{
		while(!(num-- < 0 ))
		{
			struct DisplayInfoRecord *child = find_key( (struct DisplayInfoRecord *)(SubRecord(parent)), cn->cid, (UWORD)~0 );

			if((child) || (child = add_record( parent, new_record(cn) )))
			{
				count++;

				bind_record( argc, argv, child, tags, cn, RawStuff );

				while(!(num-- < 0 ))
				{
					count += decompress( argc, argv, child, tags, cn+count, RawStuff );
				}
			}
		}
	}
	return( count );
}

int __regargs new_display(argc, argv, data, tags, root, RawStuff)
int argc;
char *argv[];
struct RomCompressedNode data[];
UBYTE tags[];
struct DisplayInfoRecord *root;
ULONG RawStuff;
{
	int total = 0;

	total += decompress(argc,argv,root,tags,data, RawStuff);
	return(total); 
}

void make_aa(dinfo)
struct RawDisplayInfo *dinfo;
{
    if ((GBASE->ChipRevBits0 & GFXF_AA_LISA) &&
        (!(dinfo->PropertyFlags & DIPF_IS_PANELLED)))	/* don't do for non-AA and A2024 */
    {
	/* New for AA - Attached sprites now work on all modes (not true of ECS).
	 * Sprite resolution can be 140, 70 or 35ns.
	 */

	if (dinfo->PropertyFlags & DIPF_IS_SPRITES)
	{
		dinfo->PropertyFlags |= (DIPF_IS_SPRITES_ATT | DIPF_IS_SPRITES_CHNG_RES |
		DIPF_IS_SPRITES_BORDER | DIPF_IS_SPRITES_CHNG_BASE | DIPF_IS_SPRITES_CHNG_PRI);
	}

	/* Palette Range is no longer representative. The best we can make it
	 * is 0xFFFF.
	 * NB - need to avoid EHB special case
	 */
	dinfo->PaletteRange = 0xffff;

	dinfo->RedBits = dinfo->GreenBits = dinfo->BlueBits = 8;
    }
}

void make_pf2pri(dinfo)
struct RawDisplayInfo *dinfo;
{
    dinfo->PropertyFlags |= DIPF_IS_PF2PRI;
    dinfo->ModeID |= PFBA;
    make_aa(dinfo);
}

void make_dualpf(dinfo)
struct RawDisplayInfo *dinfo;
{
    dinfo->PropertyFlags |= DIPF_IS_DUALPF;
    dinfo->PropertyFlags &= ~DIPF_IS_WB;
    dinfo->ModeID |= DUALPF;
    make_aa(dinfo);
}

void make_lace(dinfo)
struct RawDisplayInfo *dinfo;
{
    dinfo->PropertyFlags |= DIPF_IS_LACE;
    dinfo->ModeID |= LACE;
    dinfo->Resolution.y >>= 1;
    make_aa(dinfo);
}

void make_sdbl(dinfo)
struct RawDisplayInfo *dinfo;
{
    dinfo->PropertyFlags |= (DIPF_IS_SCANDBL | DIPF_IS_AA);
    dinfo->PropertyFlags &= ~DIPF_IS_WB;
    dinfo->ModeID |= DOUBLESCAN;
    dinfo->Resolution.y <<= 1;
    make_aa(dinfo);
}

void (*massage_dinfo[])() =
{
    make_pf2pri,
    make_dualpf,
    make_lace,
    make_aa,
    make_sdbl,
};

void limit_blit(dims)
struct RawDimensionInfo *dims;
{
    if(!(GBASE->ChipRevBits0 & GFXF_BIG_BLITS))
    {
	dims->MaxRasterWidth  = 1008;
	dims->MaxRasterHeight = 1024;
    }
}

void increase_depth(dims)
struct RawDimensionInfo *dims;
{
    UWORD depth;

    /* MaxDepth of this mode is dims->MaxDepth * BandWidth available in
     * GB->MemType
     * ie if MemType = 0, *1
     *                 1, *2
     *                 2, *2
     *                 3, *4
    */

    depth = dims->MaxDepth << GBASE->bwshifts[GBASE->MemType];
    dims->MaxDepth = MIN(depth, (dims->HWMaxDepth ? dims->HWMaxDepth : 8));
}

void (*massage_dims[])() =
{
    limit_blit,
    increase_depth,
};

void correct_driver(vinfo)
struct RawVecInfo *vinfo;
{
    struct ProgInfo *pinfo;
    UBYTE crb = GBASE->ChipRevBits0;

    pinfo = vinfo->Data = (APTR)&ProgData[vinfo->Type];

    if (crb & GFXF_AA_LISA)
    {
	/* Use AA Vectors */
	vinfo->Vec = (APTR)(VecLists[pinfo->MakeItType]);
    }
    else
    {
	if (crb & GFXF_HR_DENISE)
	{
		/* Use ECS Vectors */
		vinfo->Vec = (APTR)(VecLists[pinfo->MakeItType + AAVECS]);
	}
	else
	{
		/* Use A Vectors */
		vinfo->Vec = (APTR)(VecLists[pinfo->MakeItType + AAVECS + ECSVECS]);
	}
    }
}


void (*massage_pinfo[])() =
{
    correct_driver,
};

void __regargs do_db_startup(root, tags, entry)
struct DisplayInfoRecord *root;
UBYTE tags[];
int entry;
{
    struct RomCompressedNode *data;
    BOOL isaa = (GBASE->ChipRevBits0 & GFXF_AA_MLISA);

    if (entry > ROM_MONITOR_ENTRIES)
	return;		/* protect against adding monitor from disk - spence Mar 28 1991 */

    D(kprintf("do_db_startup(). entry = 0x%lx tags = 0x%lx\n", entry, tags);)

    data = DataBaseStuff[entry];

    Forbid();

    /* mntr and a2024 */
    data += new_display( 0, NULL, data,
		 tags,
	         root, DTAG_MNTR );

    /* dims */ 
    data += new_display(2, (char **)(&massage_dims[0]), data,
		 tags,
	         root, DTAG_DIMS );
    if (isaa)
    {
	data += new_display(2, (char **)(&massage_dims[0]), data,
			 tags,
	        	 root, DTAG_DIMS );
    }
    else
    {
	data += (data->cno + 1);
    }

    /* normal */
    data += new_display( 1, (char **)(&massage_dinfo[3]), data,
		 tags,
	         root, DTAG_DISP );

    /* lace */
    data += new_display( 1, (char **)(&massage_dinfo[2]), data,
		 tags,
	         root, DTAG_DISP );

    /* dualpf */
    data += new_display( 1, (char **)(&massage_dinfo[1]), data,
		 tags,
	         root, DTAG_DISP );

    /* lace.dualpf */
    data += new_display( 2, (char **)(&massage_dinfo[1]), data,
		 tags,
	         root, DTAG_DISP );

    /* dualpf.pf2pri */
    data += new_display( 2, (char **)(&massage_dinfo[0]), data,
		 tags,
	         root, DTAG_DISP );

    /* lace.dualpf.pf2pri */
    data += new_display( 3, (char **)(&massage_dinfo[0]), data,
		 tags,
	         root, DTAG_DISP );

    /* ham */
    data += new_display( 1, (char **)(&massage_dinfo[3]), data,
		 tags,
	         root, DTAG_DISP );

    /* ham.lace  */
    data += new_display( 1, (char **)(&massage_dinfo[2]), data,
		 tags,
	         root, DTAG_DISP );

    /* extrahalfbrite */
    data += new_display( 1, (char **)(&massage_dinfo[3]), data,
		 tags,
	         root, DTAG_DISP );

    /* extrahalfbrite .lace  */
    data += new_display( 1, (char **)(&massage_dinfo[2]), data,
		 tags,
	         root, DTAG_DISP );

    /* ProgInfo */
    data += new_display( 1, (char **)(&massage_pinfo[0]), data,
                 tags,
                 root, DTAG_VEC );

    if (isaa)
    {
	/* aa.sdbl */
	data += new_display( 1, (char **)(&massage_dinfo[4]), data,
			 tags,
			 root, DTAG_DISP );

	/* aa.ham */
	data += new_display( 1, (char **)(&massage_dinfo[3]), data,
			 tags,
	        	 root, DTAG_DISP );

	/* aa.ham.lace  */
	data += new_display( 1, (char **)(&massage_dinfo[2]), data,
			 tags,
	        	 root, DTAG_DISP );

	/* aa.ham.sdbl  */
	data += new_display( 1, (char **)(&massage_dinfo[4]), data,
			 tags,
	        	 root, DTAG_DISP );

	/* aa.extrahalfbrite */
	data += new_display( 1, (char **)(&massage_dinfo[3]), data,
		 tags,
	         root, DTAG_DISP );

	/* aa.extrahalfbrite .lace  */
	data += new_display( 1, (char **)(&massage_dinfo[2]), data,
		 tags,
	         root, DTAG_DISP );
	/* aa.extrahalfbrite .sdbl  */
	data += new_display( 1, (char **)(&massage_dinfo[4]), data,
		 tags,
	         root, DTAG_DISP );

	/* aa.ProgInfo */
	data += new_display( 1, (char **)(&massage_pinfo[0]), data,
        	     tags,
	             root, DTAG_VEC );
    }

    Permit();

    return;
}


struct DisplayInfoRecord *db_startup()
{
    UBYTE *tags = PalDisplayTags;
    struct DisplayInfoRecord *root = (struct DisplayInfoRecord *)
    AllocMem(sizeof(struct DisplayInfoRecord),MEMF_PUBLIC|MEMF_CLEAR);
	int entry = PAL_ENTRY;

    D(kprintf("db_startup(). MntrData = 0x%lx, DimsData - 0x%lx, NullData = 0x%lx\n", MntrData, DimsData, NullData);)

    /*	 check pal once */
    if (!(GBASE->DisplayFlags & PAL))
	{
		tags = NtscDisplayTags;
		entry = NTSC_ENTRY;
	};

	do_db_startup(root, tags, DEFAULT_ENTRY);
	do_db_startup(root, tags, entry);

    D(kprintf("Goodbye, db_startup().\n");)

    return( root );
}

@


39.16
log
@Removed the code that bumped the MaxX of Max/VideoOScan for AA SHire
modes. This is now handled by SetChipRev().
NTSC/PAL ScanDbl modes are no longer DIPF_IS_WB.
@
text
@d3 1
a3 1
*   $Id: startup.c,v 39.15 93/02/10 19:46:43 spence Exp Locker: spence $
d357 1
a357 1
    dinfo->PropertyFlags |= DIPF_IS_SCANDBL;
@


39.15
log
@Support for NTSC/PAL ScanDbl modes (Lores, HAM, EHB and HiresHAM).
@
text
@d3 1
a3 1
*   $Id: startup.c,v 39.14 92/08/11 14:06:50 spence Exp Locker: spence $
a185 19
			if ((DimsRange & 0x7) == DIMS_RANGE_SHIRES)
			{
				/* In a 2 cycle mode, there are 8 less pixels per line
				 * than twice the number in a 4 cycle hires mode.
				 * This is reflected in the Squeezed data.
				 * However, on a AA machine, SuperHires will execute
				 * in at least a 4 cycle mode (for 2x), so increment
				 * the range accordingly.
				 */
				if (GBASE->BoardMemType)
				{
					rd->MaxOScan.MaxX = (LONG)0x3807;
					rd->VideoOScan.MaxX = (LONG)0x390f;
				}
			}

//			rd->Nominal = ((struct SqueezedDimensionInfo *)sqz)->Nominal;
//			rd->MaxOScan = ((struct SqueezedDimensionInfo *)sqz)->MaxOScan;
//			rd->VideoOScan = ((struct SqueezedDimensionInfo *)sqz)->VideoOScan;
d358 1
@


39.14
log
@Only add AA modes to the database on AA machines.
@
text
@d3 1
a3 1
*   $Id: startup.c,v 39.13 92/07/24 12:25:28 spence Exp Locker: spence $
d11 1
d373 9
d388 1
a549 5
    /* ProgInfoLace */
    data += new_display( 1, (char **)(&massage_pinfo[0]), data,
                 tags,
                 root, DTAG_VEC );

d552 5
d567 5
d581 4
a586 5
	data += new_display( 1, (char **)(&massage_pinfo[0]), data,
        	     tags,
	             root, DTAG_VEC );

	/* aa.ProgInfoLace */
@


39.13
log
@check for SHires against GBASE->BoardMemType, not GBASE->MemType.
NB - problem here is that if you boot an AA machine into ECS mode,
the database will show 1448 pixels, but you can only see 1440.
@
text
@d3 1
a3 1
*   $Id: startup.c,v 39.12 92/07/24 12:05:47 spence Exp Locker: spence $
d336 6
a341 8
	if (!(dinfo->PropertyFlags & DIPF_IS_EXTRAHALFBRITE))
	{
		/* Palette Range is no longer representative. The best we can make it
		 * is 0xFFFF.
		 * NB - need to avoid EHB special case
		 */
		dinfo->PaletteRange = 0xffff;
	}
d453 1
d462 1
a462 1
    Forbid();		/* prevent memory fragging by another task */
d469 2
a470 2
    /* dims (only massage if not A2024) */
    data += new_display((entry == (A2024_MONITOR_ID >> 16) ? 0 : 2), (char **)(&massage_dims[0]), data,
d473 10
d543 33
@


39.12
log
@When building the RawDimensionInfo, if the machine is at least 2x, set the
SuperHires MaxX to 1447, and not the 1440 we have for ECS.
@
text
@d3 1
a3 1
*   $Id: startup.c,v 39.11 92/04/15 15:48:01 spence Exp Locker: spence $
d194 1
a194 1
				if (GBASE->MemType)
@


39.11
log
@uses GBASE instead of GB=FETCHGBASE
uses GBASE->bwshifts instead of referencing the table directly.
@
text
@d3 1
a3 1
*   $Id: startup.c,v 39.10 92/03/18 16:03:48 spence Exp Locker: spence $
d137 1
d142 2
a143 1
			DimsRange = ((struct SqueezedDimensionInfo *)sqz)->DimsRange;
a157 1
					break;
d159 1
a163 1
					break;
d165 1
d169 5
a173 2
			{
				struct SqueezedDimensionInfo *sdi = (struct SqueezedDimensionInfo *)sqz;
d175 9
a183 9
				rd->Nominal.MinX = (LONG)sdi->Nominal.MinX;
				rd->Nominal.MinY = (LONG)sdi->Nominal.MinY;
				rd->Nominal.MaxX = (LONG)sdi->Nominal.MaxX;
				rd->Nominal.MaxY = (LONG)sdi->Nominal.MaxY;

				rd->MaxOScan.MinX = (LONG)sdi->MaxOScan.MinX;
				rd->MaxOScan.MinY = (LONG)sdi->MaxOScan.MinY;
				rd->MaxOScan.MaxX = (LONG)sdi->MaxOScan.MaxX;
				rd->MaxOScan.MaxY = (LONG)sdi->MaxOScan.MaxY;
d185 14
a198 4
				rd->VideoOScan.MinX = (LONG)sdi->VideoOScan.MinX;
				rd->VideoOScan.MinY = (LONG)sdi->VideoOScan.MinY;
				rd->VideoOScan.MaxX = (LONG)sdi->VideoOScan.MaxX;
				rd->VideoOScan.MaxY = (LONG)sdi->VideoOScan.MaxY;
d200 1
@


39.10
log
@RawDisplayInfo->Red/Green/BlueBits set to 2 for 35ns modes.
@
text
@d3 1
a3 1
*   $Id: startup.c,v 39.9 92/03/03 10:37:51 spence Exp Locker: spence $
d18 1
d237 1
a237 1
	AddDisplayInfoData(record, (UBYTE *)copytags,size,copytags->ti_Tag,INVALID_ID);
d307 1
a307 4
    struct GfxBase *GB;
    GB = FETCHGBASE; 

    if ((GB->ChipRevBits0 & GFXF_AA_LISA) &&
d369 1
a369 4
    struct GfxBase *GB;
    GB = FETCHGBASE; 

    if(!(GB->ChipRevBits0 & GFXF_BIG_BLITS))
a379 1
    extern UBYTE bwshifts[];
d389 1
a389 1
    depth = dims->MaxDepth << bwshifts[GBASE->MemType];
a437 1
    struct GfxBase *GB;
a439 1
    GB = FETCHGBASE; 
a526 1
    struct GfxBase *GB;
a531 2
    GB = FETCHGBASE; 

d535 1
a535 1
    if (!(GB->DisplayFlags & PAL))
@


39.9
log
@make_aa() ORs the new DIPF_IS_SPRITES flags
@
text
@d3 1
a3 1
*   $Id: startup.c,v 39.8 92/01/17 12:08:56 spence Exp Locker: spence $
d121 2
a122 1
				rd->RedBits = rd->GreenBits = rd->BlueBits = 4;
@


39.8
log
@EHB MaxDepth can only be 6 bitplanes
@
text
@d3 1
a3 1
*   $Id: startup.c,v 39.7 92/01/07 15:56:59 spence Exp Locker: spence $
d317 2
a318 2
		dinfo->PropertyFlags |= (DIPF_IS_SPRITES_ATT | 
		DIPF_IS_SPRITES_CHNG_RES | DIPF_IS_SPRITES_BORDER);
@


39.7
log
@find_info -> FindDisplayInfo etc.
@
text
@d3 1
a3 1
*   $Id: startup.c,v 39.6 91/12/31 14:32:18 spence Exp Locker: spence $
d145 1
a145 1
			switch (DimsRange)
d164 1
d186 1
a186 1
			rd->pad[0] = rd->pad[1] = rd->pad[2] = rd->pad[3] = rd->pad[4] = rd->pad[5] = 0;
d316 1
d319 1
d321 8
a328 5
	/* Palette Range is no longer representative. The best we can make it
	 * is 0xFFFF.
	 * NB - need to consider A2024 special case
	 */
	dinfo->PaletteRange = 0xffff;
d394 2
a395 2
    depth = dims->MaxDepth << bwshifts[(GBASE->MemType & 0x03)];
    dims->MaxDepth = MIN(depth, 8);
@


39.6
log
@Sets up single-A vectors.
@
text
@d3 1
a3 1
*   $Id: startup.c,v 39.5 91/10/18 17:03:34 spence Exp Locker: spence $
d234 1
a234 1
	add_chunk(record, (UBYTE *)copytags,size,copytags->ti_Tag,INVALID_ID);
@


39.5
log
@Handle ProgInfo -> VecInfo change
Further squeezing of DimensionInfo
@
text
@d3 1
a3 1
*   $Id: startup.c,v 39.4 91/10/17 10:57:44 spence Exp Locker: spence $
d402 1
d406 1
a406 1
    if (GBASE->ChipRevBits0 & GFXF_AA_LISA)
d408 1
d413 10
a422 1
	vinfo->Vec = (APTR)(VecLists[pinfo->MakeItType + AAVECS]);
@


39.4
log
@Initialises Move/ChangeSprite() ProgInfo entries.
@
text
@d3 1
a3 1
*   $Id: startup.c,v 39.3 91/10/09 11:23:23 spence Exp Locker: spence $
d19 1
a19 1
#include	"d.protos"
d23 1
d164 21
a184 3
			rd->Nominal = ((struct SqueezedDimensionInfo *)sqz)->Nominal;
			rd->MaxOScan = ((struct SqueezedDimensionInfo *)sqz)->MaxOScan;
			rd->VideoOScan = ((struct SqueezedDimensionInfo *)sqz)->VideoOScan;
d192 1
a192 1
        	case DTAG_PROG:
d194 1
a194 1
			struct RawProgInfo *rd = (struct RawProgInfo *)&rawdata;
d196 4
a199 15
			sqz = (APTR)(ProgData + entry);
			rd->Header.Length = RAWPROG_SKIP;
			rd->MakeIt = rd->MoveSprite = rd->ChangeSprite = NULL;
			rd->bplcon0 = ((struct SqueezedProgInfo *)sqz)->bplcon0;
			rd->bplcon2 = ((struct SqueezedProgInfo *)sqz)->bplcon2;
			rd->ToViewX = ((struct SqueezedProgInfo *)sqz)->ToViewX;
			rd->ToViewY = ((struct SqueezedProgInfo *)sqz)->ToViewY;
			rd->Flags = ((struct SqueezedProgInfo *)sqz)->Flags;
			rd->MakeItType = (UWORD)(((struct SqueezedProgInfo *)sqz)->MakeItType);
			rd->ScrollVPCount = (UWORD)(((struct SqueezedProgInfo *)sqz)->ScrollVPCount);
			rd->DDFSTRTMask = ((struct SqueezedProgInfo *)sqz)->DDFSTRTMask;
			rd->DDFSTOPMask = ((struct SqueezedProgInfo *)sqz)->DDFSTOPMask;
			rd->DspInsCount = DSPINS_COUNTAA;
			rd->ToDIWResn = ((struct SqueezedProgInfo *)sqz)->ToDIWResn;
			rd->Offset = ((struct SqueezedProgInfo *)sqz)->Offset;
d201 1
a201 1
			rawdata.Header.StructID = DTAG_PROG;
d398 2
a399 2
void correct_driver(pinfo)
struct RawProgInfo *pinfo;
d401 4
d407 1
a407 2
	pinfo->MakeIt = MakeItLists[(ULONG)pinfo->MakeItType];
	pinfo->DspInsCount = DSPINS_COUNTAA;
d411 1
a411 2
	pinfo->MakeIt = MakeItLists[(ULONG)pinfo->MakeItType + AAMAKEITS];
	pinfo->DspInsCount = DSPINS_COUNTA;
a412 10
    pinfo->MoveSprite = MOVESPRITE;
    pinfo->ChangeSprite = CHANGESPRITE;
}

void correct_driver_lace(pinfo)
struct RawProgInfo *pinfo;
{
    pinfo->ToViewY = 1;
    pinfo->Flags |= PROGINFO_MODELACE;
    pinfo->bplcon0 |= LACE;
a418 1
    correct_driver_lace,
d502 1
a502 1
                 root, DTAG_PROG );
d505 1
a505 1
    data += new_display( 2, (char **)(&massage_pinfo[0]), data,
d507 1
a507 1
                 root, DTAG_PROG );
@


39.3
log
@Squeezed RawProgInfo.
Cleared pu problem with squeezed A2024 data (no need to fix blitter dims,
or depth).
@
text
@d3 1
a3 1
*   $Id: startup.c,v 39.2 91/10/08 19:42:06 spence Exp Locker: spence $
d179 1
a179 1
			rd->MakeIt = NULL;
d403 2
@


39.2
log
@Unsqueezes Display and DimensionInfo.
@
text
@d3 1
a3 1
*   $Id: startup.c,v 39.1 91/10/08 11:54:34 spence Exp Locker: spence $
d86 1
a86 1
    struct RawDimensionInfo rawdata;	/* RawDimension is the largest of the squeezed Raw... structs */
d115 1
a115 1
				rd->RedBits = 3; rd->GreenBits = 2; rd->BlueBits = 1;
d134 1
d140 4
a143 4
			rawdata.Header.Length = RAWDIMS_SKIP;
			rawdata.MinRasterHeight = 1;
			rawdata.MaxRasterWidth = 16368;
			rawdata.MaxRasterHeight = 16384;
d146 3
a148 3
				case DIMS_RANGE_LORES : rawdata.MinRasterWidth = 16; break;
				case DIMS_RANGE_HIRES : rawdata.MinRasterWidth = 32; break;
				case DIMS_RANGE_SHIRES : rawdata.MinRasterWidth = 64; break;
d151 2
a152 2
					rawdata.MinRasterWidth = rawdata.MaxRasterWidth = 1008;
					rawdata.MinRasterHeight = rawdata.MaxRasterHeight = 800;
d157 2
a158 2
					rawdata.MinRasterWidth = rawdata.MaxRasterWidth = 1008;
					rawdata.MinRasterHeight = rawdata.MaxRasterHeight = 1024;
d162 6
a167 6
			rawdata.MaxDepth = (UWORD)(((struct SqueezedDimensionInfo *)sqz)->MaxDepth);
			rawdata.Nominal = ((struct SqueezedDimensionInfo *)sqz)->Nominal;
			rawdata.MaxOScan = ((struct SqueezedDimensionInfo *)sqz)->MaxOScan;
			rawdata.VideoOScan = ((struct SqueezedDimensionInfo *)sqz)->VideoOScan;
			rawdata.pad[0] = rawdata.pad[1] = rawdata.pad[2] = rawdata.pad[3] = rawdata.pad[4] = rawdata.pad[5] = 0;
			rawdata.reserved[0] = rawdata.reserved[1] = 0;
d172 25
a196 4
        	case DTAG_MNTR: data = (ULONG)(MntrData + entry);
        			break;
        	case DTAG_PROG: data = (ULONG)(ProgData + entry);
        			break;
d299 2
a300 1
    if (GB->ChipRevBits0 & GFXF_AA_LISA)
d396 1
d443 2
a444 2
    /* dims */
    data += new_display( 2, (char **)(&massage_dims[0]), data,
@


39.1
log
@Understands new behavior of database - no {-1, 0, -1} terminators in
init.h, and Pal/NtscDisplayTags is now an array of UBYTES instead of
an array of TagItems. SAves approx 1400 bytes.
@
text
@d3 1
a3 1
*   $Id: startup.c,v 39.0 91/08/21 17:31:20 chrisg Exp Locker: spence $
d85 3
a88 1
    struct TagItem dummytag;
d97 76
a174 6
        	case DTAG_DIMS: data = (ULONG)(DimsData + entry);
        			break;
        	case DTAG_DISP: data = (ULONG)(DispData + entry);
        			break;
        	case DTAG_MNTR: data = (ULONG)(MntrData + entry);
        			break;
d176 2
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*   $Id: startup.c,v 38.2 91/07/22 15:00:30 spence Exp Locker: chrisg $
d5 1
a5 1
*   $Locker: chrisg $
d26 8
d76 1
a76 1
void bind_record( argc, argv, record, tags, cn )
d80 1
a80 1
struct TagItem *tags;
d82 1
d84 28
a111 2
    int size = ( tag_copy( tags+cn->tag, NULL ) * sizeof( struct TagItem ) );
    struct TagItem *copytags = getmustmem( size, MEMF_PUBLIC );
d113 3
d120 1
a120 1
	tag_copy( tags+cn->tag, copytags ); /* decompress data */
d136 1
a136 1
struct DisplayInfoRecord __regargs *new_record(cn, tags)
a137 1
struct TagItem *tags;
d150 1
a150 1
int __regargs decompress(argc,argv,parent, tags, cn)
d154 1
a154 1
struct TagItem tags[];
d156 1
d167 1
a167 1
			if((child) || (child = add_record( parent, new_record(cn, tags) )))
d171 1
a171 1
				bind_record( argc, argv, child, tags, cn );
d175 1
a175 1
					count += decompress( argc, argv, child, tags, cn+count );
a179 1

d183 1
a183 1
int __regargs new_display(argc, argv, data, tags, root)
d187 1
a187 1
struct TagItem tags[];
d189 1
d191 1
a191 1
	int subtotal, total = 0;
d193 2
a194 5
	while(subtotal = decompress(argc,argv,root,tags,data+total)) 
	{
		total += subtotal;
	}
	return( total + 1 );	/* +1 for the terminator */
d215 1
a215 2
	 * NB - no need to worry about A2024 special case, as it never reaches
	 * here.
d324 1
a324 1
struct TagItem *tags;
d334 2
d343 1
a343 1
	         root );
d348 1
a348 1
	         root );
d353 1
a353 1
	         root );
d358 1
a358 1
	         root );
d363 1
a363 1
	         root );
d368 1
a368 1
	         root );
d373 1
a373 1
	         root );
d378 1
a378 1
	         root );
d383 1
a383 1
	         root );
d388 1
a388 1
	         root );
d393 1
a393 1
	         root );
d398 1
a398 1
	         root );
d403 1
a403 1
                 root );
d408 1
a408 1
                 root );
d419 1
a419 1
    struct TagItem *tags = PalDisplayTags;
d426 2
d437 2
@


38.2
log
@Uses new RawProgInfo->MakeItType instead of MakeIt pointer.
@
text
@d3 1
a3 1
*   $Id: startup.c,v 38.1 91/06/14 11:14:04 spence Exp Locker: spence $
d5 1
a5 1
*   $Locker: spence $
@


38.1
log
@corrected UWORD bwshifts to UBYTE bwshifts
@
text
@d3 1
a3 1
*   $Id: startup.c,v 38.0 91/06/11 14:15:05 spence Exp Locker: spence $
d264 1
a264 1
	pinfo->MakeIt = MakeItLists[(ULONG)pinfo->MakeIt];
d268 1
a268 2
	pinfo->MakeIt = MakeItLists[(ULONG)pinfo->MakeIt + AAMAKEITS];
	pinfo->DataSize = sizeof(struct BDNml);
@


38.0
log
@First pass for ProgInfo entries.
@
text
@d3 1
a3 1
*   $Id: startup.c,v 37.5 91/05/15 12:59:28 spence Exp Locker: spence $
a237 1
    struct GfxBase *GB;
d239 1
a239 3
    extern UWORD bwshifts[];

    GB = FETCHGBASE; 
d249 1
a249 1
    depth = dims->MaxDepth << bwshifts[(GB->MemType & 0x03)];
@


37.5
log
@Use protos. Registerized parameters. Removed compiler warnings
@
text
@d3 1
a3 1
*   $Id: startup.c,v 37.4 91/05/09 14:24:15 spence Exp Locker: spence $
d11 1
d16 2
a17 1
#include <graphics/gfxbase.h>
d52 1
a52 1
		--count; tag = (struct TagIemt *)tag->ti_Data;
d162 26
d193 1
d202 1
d211 1
d219 1
d235 21
d259 31
d298 1
a298 1
	struct RomCompressedNode *data;
d301 2
a302 2
	if (entry > ROM_MONITOR_ENTRIES)
		return;		/* protect against adding monitor from disk - spence Mar 28 1991 */
d304 1
a304 1
	data = DataBaseStuff[entry];
d306 1
a306 1
	Forbid();		/* prevent memory fragging by another task */
d314 1
a314 1
    data += new_display( 1, (char **)(&massage_dims[0]), data,
d319 1
a319 1
    data += new_display( 0, NULL, data,
d349 1
a349 1
    data += new_display( 0, NULL, data,
d359 1
a359 1
    data += new_display( 0, NULL, data,
d368 11
a378 1
	Permit();
@


37.4
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Id: startup.c,v 37.3 91/04/26 16:26:32 spence Exp Locker: spence $
d17 1
d24 1
a24 1
tag_copy(tag,buf)
d90 1
a90 1
	add_chunk(record,copytags,size,copytags->ti_Tag,INVALID_ID);
d96 1
a96 1
struct DisplayInfoRecord *new_record(cn, tags)
d111 1
a111 1
decompress(argc,argv,parent, tags, cn)
d125 1
a125 1
			struct DisplayInfoRecord *child = find_key( SubRecord(parent), cn->cid, ~0 );
d144 1
a144 1
int new_display(argc, argv, data, tags, root)
d160 1
a160 1
make_pf2pri(dinfo)
d167 1
a167 1
make_dualpf(dinfo)
d175 1
a175 1
make_lace(dinfo)
d183 1
a183 1
int (*massage_dinfo[])() =
d190 1
a190 1
limit_blit(dims)
d203 1
a203 1
int (*massage_dims[])() =
d208 1
a208 1
void do_db_startup(root, tags, entry)
d230 1
a230 1
    data += new_display( 1, &massage_dims[0], data,
d240 1
a240 1
    data += new_display( 1, &massage_dinfo[2], data,
d245 1
a245 1
    data += new_display( 1, &massage_dinfo[1], data,
d250 1
a250 1
    data += new_display( 2, &massage_dinfo[1], data,
d255 1
a255 1
    data += new_display( 2, &massage_dinfo[0], data,
d260 1
a260 1
    data += new_display( 3, &massage_dinfo[0], data,
d270 1
a270 1
    data += new_display( 1, &massage_dinfo[2], data,
d280 1
a280 1
    data += new_display( 1, &massage_dinfo[2], data,
@


37.3
log
@Forbid()/Permit() in do_db_startup() to prevent memory fragging.
@
text
@d3 1
a3 1
*   $Id: startup.c,v 37.2 91/03/28 20:15:36 spence Exp Locker: spence $
d17 2
a18 2
#include "../displayinfo_internal.h"
#include "../macros.h"
d21 2
d63 1
a63 1
};
d65 1
a65 1
struct DisplayInfoRecord *bind_record( argc, argv, record, tags, cn )
d93 1
a93 1
};
d108 1
a108 1
};
d117 2
a118 2
    int count = 0;
    BYTE num = cn->cno;
d120 1
a120 3
    if(parent)
    {
	while(!(num-- < 0 ))
a121 8
	    struct DisplayInfoRecord *child = find_key( SubRecord(parent), cn->cid, ~0 );

	    if((child) || (child = add_record( parent, new_record(cn, tags) )))
	    {
		count++;

		bind_record( argc, argv, child, tags, cn );

d124 13
a136 1
		    count += decompress( argc, argv, child, tags, cn+count );
a137 1
	    }
a138 1
    }
d140 2
a141 2
    return( count );
};
d143 1
a143 1
new_display(argc, argv, data, tags, root)
d150 1
a150 1
    int subtotal, total = 0;
d153 1
a153 1
    {
d155 3
a157 3
    }
    return( total + 1 );	/* +1 for the terminator */
};
d164 1
a164 1
};
d172 1
a172 1
};
d180 1
a180 1
};
d200 1
a200 1
};
d286 1
a286 1
};
@


37.2
log
@do_db_startup() checks if the monitor number <= ROM_MONITOR_ENTRIES.
prevents unpacking random data if a monitor is initialised from disk.
@
text
@d3 1
a3 1
*   $Id: startup.c,v 37.1 91/02/28 14:06:35 spence Exp Locker: spence $
d219 2
d280 2
@


37.1
log
@db_startup() now only unloads DEFAULT monitor and PAL or NTSC monitors
from ROM to RAM at bootup time. This saves initial RAM. The rest are unloaded
either when a monitor is 'AddMonitored' from WB/CLI, or an application
tries to FindDisplayInfo() a monitor not unloaded.
@
text
@d3 1
a3 1
*   $Id: startup.c,v 37.0 91/01/07 15:21:42 spence Exp Locker: spence $
d214 3
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*   $Id: startup.c,v 36.17 90/07/27 16:38:48 bart Exp Locker: spence $
d61 1
a61 1
}
d91 1
a91 1
}
d106 1
a106 1
}
d139 1
a139 1
}
d150 1
a150 1
    while(subtotal = decompress(argc,argv,root,tags,data+total)) 
d152 1
a152 1
	total += subtotal;
d154 2
a156 3
    return( total );
}

d162 1
a162 1
}
d170 1
a170 1
}
d178 1
a178 1
}
d198 1
a198 1
}
d205 4
a208 1
struct DisplayInfoRecord *db_startup()
d211 1
a211 3
    struct TagItem *tags= NtscDisplayTags;
    struct DisplayInfoRecord *root = (struct DisplayInfoRecord *)
    AllocMem(sizeof(struct DisplayInfoRecord),MEMF_PUBLIC|MEMF_CLEAR);
d214 1
a215 3
    /*	 check pal once */
    if (GB->DisplayFlags & PAL) tags = PalDisplayTags;

d217 1
a217 1
    new_display( 0, NULL, MntrBind,
d222 1
a222 1
    new_display( 1, &massage_dims[0], DimsBind,
d227 1
a227 1
    new_display( 0, NULL, DispBindNorm,
d230 1
d232 1
a232 1
    new_display( 1, &massage_dinfo[2], DispBindLace,
d237 1
a237 1
    new_display( 1, &massage_dinfo[1], DispBindDual,
d242 1
a242 1
    new_display( 2, &massage_dinfo[1], DispBindLaceDual,
d247 1
a247 1
    new_display( 2, &massage_dinfo[0], DispBindDual2,
d252 1
a252 1
    new_display( 3, &massage_dinfo[0], DispBindLaceDual2,
d257 1
a257 1
    new_display( 0, NULL, DispBindHam,
d262 1
a262 1
    new_display( 1, &massage_dinfo[2], DispBindHamLace,
d267 1
a267 1
    new_display( 0, NULL, DispBindEHB,
d272 1
a272 1
    new_display( 1, &massage_dinfo[2], DispBindEHBLace,
d276 24
d302 1
@


36.17
log
@id
@
text
@d3 1
a3 1
*   $Id: $
d5 1
a5 1
*   $Locker: bart $
@


36.16
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: /usr/commodore/amiga/V36/src/kickstart/graphics/d/RCS/startup.c,v 36.15 90/01/31 15:32:24 bart Exp Locker: bart $
@


36.15
log
@extrahalfbrite
@
text
@d3 1
a3 1
*   $Header: startup.c,v 36.14 90/01/04 10:05:46 bart Exp $
@


36.14
log
@ham and dualpf not wb'able
@
text
@d3 1
a3 1
*   $Header: startup.c,v 36.13 89/10/31 13:02:28 bart Exp $
d264 10
@


36.13
log
@gfxmustmem to prevent mem fragmenation at boot
@
text
@d3 1
a3 1
*   $Header: startup.c,v 36.12 89/08/17 13:13:40 bart Exp $
d169 1
@


36.12
log
@TAG_SKIP
@
text
@d3 1
a3 1
*   $Header: startup.c,v 36.11 89/04/28 19:48:38 bart Exp $
d71 1
a71 1
    struct TagItem *copytags = AllocMem( size, MEMF_PUBLIC | MEMF_CLEAR );
d89 1
a89 1
	FreeMem( copytags, size );    /* delete temporary copy */
@


36.11
log
@include file hygiene... removed execname.h reference for bryce
@
text
@d3 1
a3 1
*   $Header: startup.c,v 36.10 89/04/12 13:09:50 bart Exp $
d31 1
a31 1
	    if( tag->ti_Tag == TAG_IGNORE )
d33 1
a33 1
		ULONG ignore = tag->ti_Data + 1;
d41 1
a41 1
		}   while( --ignore );
@


36.10
log
@check pal once 
@
text
@d3 1
a3 1
*   $Header: startup.c,v 36.9 89/02/24 09:25:59 bart Exp $
a13 3
#include <exec/libraries.h>
#include <exec/execbase.h>
#include <exec/execname.h>
@


36.9
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: startup.c,v 36.9 89/02/22 11:10:42 bart Exp $
d5 1
a5 1
*   $Locker:  $
d211 1
d217 3
d222 1
a222 1
	       ((GB->DisplayFlags & PAL) ? PalDisplayTags: NtscDisplayTags), 
d227 1
a227 1
	       ((GB->DisplayFlags & PAL) ? PalDisplayTags: NtscDisplayTags), 
d232 1
a232 1
	       ((GB->DisplayFlags & PAL) ? PalDisplayTags: NtscDisplayTags), 
d236 1
a236 1
	       ((GB->DisplayFlags & PAL) ? PalDisplayTags: NtscDisplayTags), 
d241 1
a241 1
	       ((GB->DisplayFlags & PAL) ? PalDisplayTags: NtscDisplayTags), 
d246 1
a246 1
	       ((GB->DisplayFlags & PAL) ? PalDisplayTags: NtscDisplayTags), 
d251 1
a251 1
	       ((GB->DisplayFlags & PAL) ? PalDisplayTags: NtscDisplayTags), 
d256 1
a256 1
	       ((GB->DisplayFlags & PAL) ? PalDisplayTags: NtscDisplayTags), 
d261 1
a261 1
	       ((GB->DisplayFlags & PAL) ? PalDisplayTags: NtscDisplayTags), 
d266 1
a266 1
	       ((GB->DisplayFlags & PAL) ? PalDisplayTags: NtscDisplayTags), 
@


36.8
log
@compress lace,dualpf,pf2pri,ham database
@
text
@d3 1
a3 1
*   $Header: startup.c,v 36.7 89/02/20 16:15:30 bart Exp $
d5 1
a5 1
*   $Locker: bart $
d190 18
d216 7
a222 2
    /* a2024 */
    new_display( 0, NULL, DimsBind,
@


36.7
log
@checkpoint
@
text
@d3 1
a3 1
*   $Header: startup.c,v 36.6 89/02/20 16:06:27 bart Exp $
d66 3
a68 1
struct DisplayInfoRecord *bind_record( record, tags, cn )
d78 2
d82 8
d111 3
a113 1
decompress(parent, tags, cn)
d131 1
a131 1
		bind_record( child, tags, cn );
d135 1
a135 1
		    count += decompress(child, tags, cn+count );
d144 3
a146 1
new_display(data, tags, root)
d152 6
a157 1
    while(subtotal = decompress(root,tags,data+total)) total += subtotal;
d161 29
d198 41
a238 1
    new_display( Bindings,
@


36.6
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: startup.c,v 36.5 89/02/20 15:44:57 bart Exp $
@


36.5
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: startup.c,v 36.4 89/02/17 22:00:26 bart Exp $
d150 1
a150 1
	         root);
@


36.4
log
@checkpoint
@
text
@d3 1
a3 1
*   $Header: startup.c,v 36.3 89/02/16 11:24:18 bart Exp $
d21 1
d142 1
d146 5
a150 1
    new_display( table, tags, root ); /* initialize display from table */
@


36.3
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: startup.c,v 36.2 89/02/15 16:36:36 bart Exp $
@


36.2
log
@DisplayInfoRecord
@
text
@d3 1
a3 1
*   $Header: startup.c,v 36.1 89/02/15 13:06:04 bart Exp $
d92 1
a92 1
	record->rec_Key = cn->cid;
@


36.1
log
@merge DisplayInfoDataBase with graphics
@
text
@d3 1
a3 1
*   $Header: startup.c,v 36.0 89/02/15 12:53:29 bart Exp $
d20 1
a20 2
#include "record.h"
#include "defines.h"
d65 2
a66 2
struct Record *bind_record( record, tags, cn )
struct Record *record;
d83 1
a83 1
struct Record *new_record(cn, tags)
d87 2
a88 2
    struct Record *record = (struct Record *)
    AllocMem(sizeof(struct Record),MEMF_PUBLIC|MEMF_CLEAR);
d99 1
a99 1
struct Record *parent;
d110 1
a110 1
	    struct Record *child = find_key( SubRecord(parent), cn->cid, ~0 );
d132 1
a132 1
struct Record *root;
d139 1
a139 1
struct Record *db_startup()
d141 2
a142 2
    struct Record *root = (struct Record *)
	   AllocMem(sizeof(struct Record),MEMF_PUBLIC|MEMF_CLEAR);
@


36.0
log
@added to rcs for updating
@
text
@d3 1
a3 1
*   $Header: startup.c,v 36.11 89/02/15 10:45:32 bart Exp $
a19 1
#include "display_base.h"
@
