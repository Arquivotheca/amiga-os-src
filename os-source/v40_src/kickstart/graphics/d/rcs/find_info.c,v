head     39.8;
branch   ;
access   ;
symbols  rel39_24:39.8 rel39_18:39.8 rel39_97:39.8 rel39_90:39.8 rel39_89:39.8 rel39_82:39.8 rel39_76:39.8 rel39_71:39.8 rel39_65:39.8 rel39_64:39.8 rel39_61:39.8 rel39_60:39.8 rel39_55:39.7 rel39_47:39.6 rel39_39:39.6 rel39_38:39.6 rel39_37:39.6 rel39_35:39.6 rel39_34:39.6 V37_33:37.6 V37_32:37.6 V37_31:37.6 V37_30:37.6 V37_29:37.4 V37_28:37.4 V37_25:37.4 V37_22:37.4 V37_21:37.4 V37_20:37.4 V37_19:37.4 V37_17:37.4 V37_15:37.3 V37_14:37.3 V37_13:37.2 V37_12:37.2 V37_11:37.2 V37_10:37.0 V37_9:37.0 V37_8:37.0 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.17 V36_208:36.17 V36_207:36.17 V36_205:36.17 V36_203:36.17 V36_202:36.17 V36_201:36.17 V36_200:36.17 V36_199:36.17 V36_198:36.17 V36_196:36.17 V36_195:36.17 V36_194:36.17 V36_193:36.17 V36_192:36.17 V36_191:36.17 V36_190:36.17 V36_189:36.17 V36_188:36.17 V36_187:36.17 V36_186:36.16 V36_185:36.16 V36_184:36.16 V36_183:36.16 V36_182:36.16 V36_181:36.16 V36_67:36.16 V36_68:36.8 V36_66:36.7 V36_62:36.7 V36_56:36.6 V36_50:36.5 V36_45:36.4 V36_41:36.4 V36_38:36.4 V36_37:36.4;
locks    ; strict;
comment  @*   @;


39.8
date     92.05.13.11.33.14;  author spence;  state Exp;
branches ;
next     39.7;

39.7
date     92.04.15.15.44.00;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     92.02.05.11.54.51;  author spence;  state Exp;
branches ;
next     39.5;

39.5
date     92.01.21.13.33.36;  author chrisg;  state Exp;
branches ;
next     39.4;

39.4
date     91.10.28.17.19.09;  author spence;  state Exp;
branches ;
next     39.3;

39.3
date     91.10.15.16.30.48;  author spence;  state Exp;
branches ;
next     39.2;

39.2
date     91.10.15.16.02.27;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     91.10.08.11.58.23;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.30.18;  author chrisg;  state Exp;
branches ;
next     37.8;

37.8
date     91.05.15.12.57.02;  author spence;  state Exp;
branches ;
next     37.7;

37.7
date     91.05.09.14.25.01;  author spence;  state Exp;
branches ;
next     37.6;

37.6
date     91.04.27.17.36.34;  author spence;  state Exp;
branches ;
next     37.5;

37.5
date     91.04.26.16.27.29;  author spence;  state Exp;
branches ;
next     37.4;

37.4
date     91.02.28.14.09.41;  author spence;  state Exp;
branches 37.4.1.1;
next     37.3;

37.3
date     91.02.12.15.47.43;  author spence;  state Exp;
branches ;
next     37.2;

37.2
date     91.02.06.11.10.10;  author spence;  state Exp;
branches ;
next     37.1;

37.1
date     91.02.04.19.52.09;  author spence;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.21.21;  author spence;  state Exp;
branches ;
next     36.17;

36.17
date     90.10.03.14.35.02;  author bart;  state Exp;
branches ;
next     36.16;

36.16
date     90.07.27.16.37.04;  author bart;  state Exp;
branches ;
next     36.15;

36.15
date     90.03.28.09.31.33;  author bart;  state Exp;
branches ;
next     36.14;

36.14
date     89.10.31.13.03.02;  author bart;  state Exp;
branches ;
next     36.13;

36.13
date     89.02.27.13.43.25;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     89.02.27.13.38.50;  author bart;  state Exp;
branches ;
next     36.11;

36.11
date     89.02.17.21.59.09;  author bart;  state Exp;
branches ;
next     36.10;

36.10
date     89.02.15.16.35.59;  author bart;  state Exp;
branches ;
next     36.9;

36.9
date     89.02.15.13.05.27;  author bart;  state Exp;
branches ;
next     36.8;

36.8
date     89.02.15.09.46.54;  author bart;  state Exp;
branches ;
next     36.7;

36.7
date     89.02.13.14.46.25;  author bart;  state Exp;
branches ;
next     36.6;

36.6
date     89.02.13.13.19.10;  author bart;  state Exp;
branches ;
next     36.5;

36.5
date     89.02.13.11.52.24;  author bart;  state Exp;
branches ;
next     36.4;

36.4
date     89.01.27.13.12.34;  author bart;  state Exp;
branches ;
next     36.3;

36.3
date     89.01.25.12.14.46;  author bart;  state Exp;
branches ;
next     36.2;

36.2
date     89.01.25.11.12.57;  author bart;  state Exp;
branches ;
next     36.1;

36.1
date     89.01.16.12.05.47;  author bart;  state Exp;
branches ;
next     36.0;

36.0
date     89.01.16.10.14.58;  author bart;  state Exp;
branches ;
next     ;

37.4.1.1
date     91.04.27.17.31.51;  author spence;  state Exp;
branches ;
next     ;


desc
@@


39.8
log
@Work:src/gfx
coercion.
@
text
@/******************************************************************************
*
*   $Id: find_info.c,v 39.7 92/04/15 15:44:00 spence Exp Locker: spence $
*
*   $Locker: spence $
*
******************************************************************************/

/* find_info.c -- search database for displayinfo record by ID */

#include	<exec/types.h>
#include	"/gfxbase.h"
#include	<graphics/view.h>
#include	"/macros.h"
#include	"/displayinfo_internal.h"
#include	"d.protos"
#include 	<pragmas/utility_pragmas.h>

/*#define DEBUG*/
/*#define USEGBDEBUG*/

#ifdef USEGBDEBUG
#define GBDEBUG if (GBASE->Debug)
#else
#define GBDEBUG
#endif

#ifdef DEBUG
#define D(x) {GBDEBUG {x};}
#else
#define D(x)
#endif

/****** graphics.library/FindDisplayInfo ****************************************
*
*   NAME
*	FindDisplayInfo -- search for a record identified by a specific key (V36)
*
*   SYNOPSIS
*	handle = FindDisplayInfo(ID)
*	D0                       D0
*
*	DisplayInfoHandle FindDisplayInfo(ULONG);
*
*   FUNCTION
*	Given a 32-bit Mode Key, return a handle to a valid DisplayInfoRecord
*	found in the graphics database.  Using this handle, you can obtain
*	information about this Mode, including its default dimensions,
*	properties, and whether it is currently available for use.
*
*   INPUTS
*	ID     - unsigned long identifier
*
*   RESULT
*	handle - handle to a displayinfo Record with that key
*	         or NULL if no match.
*
*   BUGS
*
*   SEE ALSO
*	graphics/displayinfo.h
*
*******************************************************************************/

void all_db_avail(void);

struct DisplayInfoRecord * __asm FindDisplayInfo( register __d0 ULONG ID)
{
    extern UBYTE PalDisplayTags[];
    extern UBYTE NtscDisplayTags[];
    struct DisplayInfoRecord *dinfo, *head, *head2 = NULL;
    struct RawDisplayInfo *rdi;
    UBYTE *tags = PalDisplayTags;
    struct DisplayInfoRecord *dib;

	dib = (struct DisplayInfoRecord *)GBASE->DisplayInfoDataBase;
	ID = MakeTrueID(dib, ID);
	if (head = find_key((struct DisplayInfoRecord *)(SubRecord(dib)), (ID >> 16), (UWORD)~0))
	{
		head2 = find_key((SubRecord(head)), (ID & 0xffff), ~0);
	}

	D(kprintf("finddisplayinfo(). ID = 0x%lx, dib = 0x%lx, head = 0x%lx, head2 = 0x%lx\n", ID, dib, head, head2);)

	if ((dinfo = find_id(dib, ID)) == NULL)
	{
		/* could not find this ID. Was it legal? */
		D(kprintf("Could not find ID\n");)
		if (((ID != INVALID_ID) && ((ID & EXTENDED_MODE) && (ID & 0xFFFF0000))) ||
		    ((ID & MONITOR_ID_MASK) == DEFAULT_MONITOR_ID))
		{
		/* OK - it was legal. Now, could we not find it because
		 * the mode was not legal for this monitor, or because
		 * the monitor has not been unpacked?
		*/
			D(kprintf("mode was legal\n");)
			if (head)
			{
			/* Have the head of the monitor. Is this an invalid ID
			 * for a disk-based monitor that has not been made available
			 * yet?
			*/
				D(kprintf("have head\n");)
				/* look for the RawDisplayInfo */
				if (head2 && ((!(rdi = (struct RawDisplayInfo *)FindTagItem(DTAG_DISP, &head2->rec_Tag))) ||
				    (rdi->NotAvailable & DI_AVAIL_NOMONITOR)))
				{
				/* make it available */
					D(kprintf("db_a() 1\n");)
					db_avail(head2);
				}
				/* Either way, this is an invalid mode id. */
				return(NULL);
			}
			else
			{
			/* No head. Unpack from ROM to RAM and try again */
				D(kprintf("no head - unpacking\n");)
				if (!(GBASE->DisplayFlags & PAL))
				{
					tags = NtscDisplayTags;
				}
				do_db_startup(dib, tags, ((ID & MONITOR_ID_MASK) >> 16));
				D(kprintf("db_a() 2, ");)
				head = find_key((struct DisplayInfoRecord *)(SubRecord(dib)), (ID >> 16), (UWORD)~0);
				D(kprintf("head = 0x%lx\n", head);)
				all_db_avail();
				return( find_id(dib, ID ) );
			}
		}
		else
		{
		/* Not a legal mode id. */
			D(kprintf("illegal modeid\n");)
			return(NULL);		
		}
	}
	else
	{
	/* Found the ID. If the monitor has been added from disk, then we need
	 * to make the monitor available if it has not already been done.
	*/
		D(kprintf("found the ID\n");)
		if (head)
		{
		/* look for the RawDisplayInfo */
			D(kprintf("have the head\n");)
			if (head2 && ((rdi = (struct RawDisplayInfo *)FindTagItem(DTAG_DISP,&head2->rec_Tag)) &&
			    (rdi->NotAvailable & DI_AVAIL_NOMONITOR)))
			{
			/* make it available */
				D(kprintf("making it available\n");)
				D(kprintf("db_a() 3\n");)
				db_avail(head2);
			}
		}
		else
		{
			D(kprintf("should never reach here!\n");)
		}			 
		D(kprintf("returning dinfo = 0x%lx\n", dinfo);)
		return(dinfo);
	}
}

/****** graphics.library/NextDisplayInfo ***************************************
*
*   NAME
*	NextDisplayInfo -- iterate current displayinfo identifiers (V36)
*
*   SYNOPSIS
*	next_ID = NextDisplayInfo(last_ID)
*	D0                        D0
*
*	ULONG NextDisplayInfo(ULONG);
*
*   FUNCTION
*	The basic iteration function with which to find all records in the
*	graphics database.  Using each ID in succession, you can then call
*	FindDisplayInfo() to obtain the handle associated with each ID.
*	Each ID is a 32-bit Key which uniquely identifies one record.
*	The INVALID_ID is special, and indicates the end-of-list.
*
*   INPUTS
*	last_ID - previous displayinfo identifier
*	          or INVALID_ID if beginning iteration.
*
*   RESULT
*	next_ID - subsequent displayinfo identifier
*	          or INVALID_ID if no more records.
*
*   BUGS
*
*   SEE ALSO
*	FindDisplayInfo(), GetDisplayInfoData()
*	graphics/displayinfo.h
*
*******************************************************************************/

ULONG __asm NextDisplayInfo( register __d0 ULONG ID)
{
	ULONG next = ID;
	ULONG skip = INVALID_ID;

#ifdef SKIP_ID
	if( GBASE->DisplayFlags & NTSC ) skip = NTSC_MONITOR_ID;
	if( GBASE->DisplayFlags & PAL  ) skip =  PAL_MONITOR_ID;
#endif

	while(( next = next_id( GBASE->DisplayInfoDataBase, next )) != INVALID_ID )
	{
	    if( (next & skip ) != skip )
	    {
		break;
	    }
	}

	return( next );
}

/****i* graphics.library/AddDisplayInfo ****************************************
*
*   NAME
*       AddDisplayInfo -- add a Record to a Display DataBase (V36)
*
*   SYNOPSIS
*       handle = AddDisplayInfo( record )
*       d0                       a0
*
*   FUNCTION
*
*   INPUTS
*       record  - pointer to a DisplayInfoRecord to link to the Display DataBase
*
*   RESULT
*       handle -   handle to this Record after linking or NULL if link failed.
*
*   BUGS
*       does not check to see if there is already a child with identical key.
*
*   SEE ALSO
*       graphics/displayinfo.h
*
*******************************************************************************/

struct DisplayInfoRecord * __asm AddDisplayInfo( register __a0 struct DisplayInfoRecord  *record)
{
	return( add_record( GBASE->DisplayInfoDataBase, (struct RecordNode *)record ) );
}

/****** graphics.library/GetDisplayInfoData **************************************
*
*   NAME
*	GetDisplayInfoData -- query DisplayInfo Record parameters (V36)
*
*   SYNOPSIS
*	result = GetDisplayInfoData(handle, buf, size, tagID, [ID])
*	D0                          A0      A1   D0    D1     [D2]
*
*	ULONG GetDisplayInfoData(DisplayInfoHandle, UBYTE *, ULONG, ULONG, ULONG);
*
*   FUNCTION
*	GetDisplayInfoData() fills a buffer with data meaningful to the
*	DisplayInfoRecord pointed at by your valid handle. The data type
*	that you are interested in is indicated by a tagID for that chunk.
*	The types of tagged information that may be available include:
*
*	DTAG_DISP: (DisplayInfo)   - properties and availability information.
*	DTAG_DIMS: (DimensionInfo) - default dimensions and overscan info.
*	DTAG_MNTR: (MonitorInfo)   - type, position, scanrate, and compatibility
*	DTAG_NAME: (NameInfo)      - a user friendly way to refer to this mode.
*
*   INPUTS
*	handle - displayinfo handle
*	buf    - pointer to destination buffer
*	size   - buffer size in bytes
*	tagID  - data chunk type
*	ID     - displayinfo identifier, optionally used if handle is NULL
*
*   RESULT
*	result - if positive, number of bytes actually transferred
*	         if zero, no information for ID was available
*
*   BUGS
*
*   SEE ALSO
*	FindDisplayInfo(), NextDisplayInfo()
*	graphics/displayinfo.h
*
*******************************************************************************/

struct DisplayInfoRecord * __asm GetDisplayInfoData( register __a0 struct DisplayInfoRecord *handle,
				register __a1 UBYTE *buf,
				register __d0 ULONG size,
				register __d1 ULONG tagID,
				register __d2 ULONG ID)
{
	return((struct DisplayInfoRecord *)cook(GBASE->DisplayInfoDataBase, handle, buf, size, tagID, ID, GET_DISPLAYINFODATA)); 
}

/***** graphics.library/AddDisplayInfoData ************************************
*
*   NAME
*       AddDisplayInfoData -- add data chunk to DisplayInfo Record
*
*   SYNOPSIS
*       result = AddDisplayInfoData( handle, buf, size, tagID, [ID] )
*       d0                	     a0      a1   d0    d1	d2 
*	
*	DisplayInfoHandle handle;
*	UBYTE   buf[];
*	ULONG   size;
*	ULONG   tagID;
*	ULONG   ID;
*	
*	ULONG  result;
*
*   FUNCTION
*
*   INPUTS
*	handle - displayinfo handle
*	buf    - pointer to destination buffer
*	size   - buffer size in bytes
*	tagID  - data chunk type
*       ID     - displayinfo identifier, optionally used if handle is NULL
*
*   RESULT
*       result - if positive, number of bytes actually added
*		 if zero, no data was actually transferred 
*
*   BUGS
*
*   SEE ALSO
*	GetDisplayInfoData(), SetDisplayInfoData()
*	graphics/displayinfo.h
*
*******************************************************************************/

struct DisplayInfoRecord * __asm AddDisplayInfoData(register __a0 struct DisplayInfoRecord *handle,
				register __a1 UBYTE *buf,
				register __d0 ULONG size,
				register __d1 ULONG tagID,
				register __d2 ULONG ID)
{
	return((struct DisplayInfoRecord *)cook(GBASE->DisplayInfoDataBase, handle, buf, size, tagID, ID, NEW_DISPLAYINFODATA)); 
}

/***** graphics.library/SetDisplayInfoData ************************************
*
*   NAME
*       SetDisplayInfoData -- change DisplayInfo Record parameters 
*
*   SYNOPSIS
*       result = SetDisplayInfoData( handle, buf, size, tagID, [ID] )
*       d0                	     a0      a1   d0    d1	d2 
*	
*	DisplayInfoHandle handle;
*	UBYTE   buf[];
*	ULONG   size;
*	ULONG   tagID;
*	ULONG   ID;
*	
*	ULONG  result;
*
*   FUNCTION
*
*   INPUTS
*	handle - displayinfo handle
*	buf    - pointer to destination buffer
*	size   - buffer size in bytes
*	tagID  - data chunk type
*       ID     - displayinfo identifier, optionally used if handle is NULL
*
*   RESULT
*       result - if positive, number of bytes actually transferred
*		 if zero, no data was actually transferred 
*
*   BUGS
*
*   SEE ALSO
*	FindDisplayInfo(), NextDisplayInfo(), GetDisplayInfoData()
*	graphics/displayinfo.h
*
*******************************************************************************/

struct DisplayInfoRecord * __asm SetDisplayInfoData(register __a0 struct DisplayInfoRecord *handle,
				register __a1 UBYTE *buf,
				register __d0 ULONG size,
				register __d1 ULONG tagID,
				register __d2 ULONG ID)
{
	D(kprintf("SetDisplayInfoData(). Record = 0x%lx, ID = 0x%lx\n", handle, ID));
	return((struct DisplayInfoRecord *)cook(GBASE->DisplayInfoDataBase, handle, buf, size, tagID, ID, SET_DISPLAYINFODATA));
}
@


39.7
log
@calls cook() directly, rather than go through (un)cook_id()
Uses GBASE instead of GB=FETCGHGBASE
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 39.6 92/02/05 11:54:51 spence Exp Locker: spence $
d77 1
a77 7
	if ((GBASE->monitor_id) &&
	    ((ID & MONITOR_ID_MASK) == DEFAULT_MONITOR_ID))
	{
		ID |= ((GBASE->monitor_id << 16) | 0x1000);
		D(kprintf("Use gb->monitorid. ID = 0x%lx\n", ID);)
	}
	    
@


39.6
log
@Uses GB->MonitorID if passing a default monitor ID
Fixed enforcer hit at bootup time in PAL mode by not looking for head2
if there is no head.
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 39.5 92/01/21 13:33:36 chrisg Exp Locker: spence $
a70 1
    struct GfxBase *GB;
d76 1
a76 2
	GB = FETCHGBASE; 
	dib = (struct DisplayInfoRecord *)GB->DisplayInfoDataBase;
d125 1
a125 1
				if (!(GB->DisplayFlags & PAL))
a207 1
	struct GfxBase *GB;
a210 2
	GB = FETCHGBASE; 

d212 2
a213 2
	if( GB->DisplayFlags & NTSC ) skip = NTSC_MONITOR_ID;
	if( GB->DisplayFlags & PAL  ) skip =  PAL_MONITOR_ID;
d216 1
a216 1
	while(( next = next_id( GB->DisplayInfoDataBase, next )) != INVALID_ID )
d254 1
a254 5
	struct GfxBase *GB;

	GB = FETCHGBASE; 

	return( add_record( GB->DisplayInfoDataBase, (struct RecordNode *)record ) );
d304 1
a304 5
	struct GfxBase *GB;

	GB = FETCHGBASE; 

	return((struct DisplayInfoRecord *)cook_id( GB->DisplayInfoDataBase, handle, buf, size, tagID, ID ) ); 
d351 1
a351 5
	struct GfxBase *GB;

	GB = FETCHGBASE; 

	return((struct DisplayInfoRecord *)add_id( GB->DisplayInfoDataBase, handle, buf, size, tagID, ID ) ); 
a397 4
	struct GfxBase *GB;

	GB = FETCHGBASE; 

d399 1
a399 1
	return((struct DisplayInfoRecord *)uncook_id( GB->DisplayInfoDataBase,handle,buf,size,tagID,ID ) ); 
@


39.5
log
@ Now use utility.library's tag functions
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 39.4 91/10/28 17:19:09 spence Exp Locker: chrisg $
d5 1
a5 1
*   $Locker: chrisg $
d20 8
d29 1
a29 1
#define D(x) {x};
d79 7
d91 1
a91 2
	D(kprintf("FDI(0x%lx)\n", ID);)
	D(kprintf("head = 0x%lx, head2 = 0x%lx\n", head, head2);)
a92 1
	D(kprintf("finddisplayinfo(). ID = 0x%lx, head = 0x%lx\n", ID, head);)
d96 1
a96 1
		D(kprintf("Could not find ID");)
d134 1
a134 2
				head2 = (struct DisplayInfoRecord *)(SubRecord(head));
				D(kprintf("head = 0x%lx, head2 = 0x%lx\n", head, head2);)
d165 1
a165 1
		/* else
d167 2
a168 2
		should never reach here!
		}*/			 
@


39.4
log
@Fixed bug B14669 - SetDisplayInfoData(). The wrong node was being used,
which could cause an infinite loop between FindDisplayInfo() and
db_avail().
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 39.3 91/10/15 16:30:48 spence Exp Locker: spence $
d5 1
a5 1
*   $Locker: spence $
d12 1
a12 1
#include	<graphics/gfxbase.h>
d17 1
d100 1
a100 1
				if (head2 && ((!(rdi = (struct RawDisplayInfo *)find_tag(&head2->rec_Tag, DTAG_DISP))) ||
d144 1
a144 1
			if (head2 && ((rdi = (struct RawDisplayInfo *)find_tag(&head2->rec_Tag, DTAG_DISP)) &&
@


39.3
log
@*%^#ing bloody DEBUG statements enabled!!
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 39.2 91/10/15 16:02:27 spence Exp Locker: spence $
d56 2
d63 1
a63 1
    struct DisplayInfoRecord *dinfo, *head;
d70 7
a76 1
	head = find_key((struct DisplayInfoRecord *)(SubRecord(dib)), (ID >> 16), (UWORD)~0);
d83 2
a84 1
		if ((ID & EXTENDED_MODE) && (ID & 0xFFFF0000))
d99 2
a100 2
				if ((!(rdi = (struct RawDisplayInfo *)find_tag(&head->rec_Tag, DTAG_DISP))) ||
				    (rdi->NotAvailable & DI_AVAIL_NOMONITOR))
d103 2
a104 1
					db_avail(GB);
d118 5
a122 1
				db_avail(GB);
d143 2
a144 2
			if ((rdi = (struct RawDisplayInfo *)find_tag(&head->rec_Tag, DTAG_DISP)) &&
			    (rdi->NotAvailable & DI_AVAIL_NOMONITOR))
d147 3
a149 2
				D(kprintf("makeing it available\n");)
				db_avail(GB);
@


39.2
log
@added Debug statements - no code change.
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 39.1 91/10/08 11:58:23 spence Exp Locker: spence $
d18 1
a18 1
#define DEBUG
@


39.1
log
@FindDisplayInfo() altered for the new Pal/NtscDisplayTags format.
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 39.0 91/08/21 17:30:18 chrisg Exp Locker: spence $
d18 7
d70 1
d74 1
d81 1
d88 1
d102 1
d115 1
d124 1
d128 1
d133 1
d141 1
d391 1
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 37.8 91/05/15 12:57:02 spence Exp Locker: chrisg $
d5 1
a5 1
*   $Locker: chrisg $
d51 3
a53 3
	extern struct TagItem PalDisplayTags[];
	extern struct TagItem NtscDisplayTags[];
	struct GfxBase *GB;
d55 3
a57 3
	struct RawDisplayInfo *rdi;
    struct TagItem *tags = PalDisplayTags;
	struct DisplayInfoRecord *dib;
a167 2
	extern struct TagItem PalDisplayTags[];
	extern struct TagItem NtscDisplayTags[];
@


37.8
log
@Use protos. Registerized parameters. Removed compiler warnings
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 37.7 91/05/09 14:25:01 spence Exp Locker: spence $
d5 1
a5 1
*   $Locker: spence $
@


37.7
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 37.6 91/04/27 17:36:34 spence Exp Locker: spence $
d11 2
a12 2
#include    <exec/types.h>
#include    <graphics/gfxbase.h>
d14 3
a16 2
#include    "/macros.h"
#include    "/displayinfo_internal.h"
d49 1
a49 2
struct DisplayInfoRecord *find_info( ID )
ULONG ID;
d61 1
a61 1
	head = find_key(SubRecord(dib), (ID >> 16), ~0);
d79 1
a79 1
				if ((!(rdi = find_tag(&head->rec_Tag, DTAG_DISP))) ||
d114 1
a114 1
			if ((rdi = find_tag(&head->rec_Tag, DTAG_DISP)) &&
d163 1
a163 2
ULONG next_info( ID )
ULONG ID;
a169 1
    struct TagItem *tags= NtscDisplayTags;
d214 1
a214 2
struct DisplayInfoRecord  *add_info( record )
struct DisplayInfoRecord  *record;
d220 1
a220 1
	return( add_record( GB->DisplayInfoDataBase, record ) );
d264 6
a269 7
struct DisplayInfoRecord *cook_chunk( handle, buf, size, tagID, ID )
struct DisplayInfoRecord *handle;
UBYTE buf[];
ULONG size;
ULONG tagID;
ULONG ID;
{
d274 1
a274 1
	return( cook_id( GB->DisplayInfoDataBase, handle, buf, size, tagID, ID ) ); 
d315 6
a320 7
struct DisplayInfoRecord *add_chunk( handle, buf, size, tagID, ID )
struct DisplayInfoRecord *handle;
UBYTE buf[];
ULONG size;
ULONG tagID;
ULONG ID;
{
d325 1
a325 1
	return( add_id( GB->DisplayInfoDataBase, handle, buf, size, tagID, ID ) ); 
d366 6
a371 7
struct DisplayInfoRecord *uncook_chunk( handle, buf, size, tagID, ID )
struct DisplayInfoRecord *handle;
UBYTE buf[];
ULONG size;
ULONG tagID;
ULONG ID;
{
d376 1
a376 1
	return( uncook_id( GB->DisplayInfoDataBase,handle,buf,size,tagID,ID ) ); 
@


37.6
log
@Better protection for monitor unpacking
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 37.4.1.1 91/04/27 17:31:51 spence Exp $
d5 1
a5 1
*   $Locker:  $
d14 2
a15 2
#include    "../macros.h"
#include    "../displayinfo_internal.h"
d57 1
a57 1
	APTR dib;
d60 1
a60 1
	dib = GB->DisplayInfoDataBase;
@


37.5
log
@find_info() would unpack a monitor from ROM if passed an invalid ID. Needs
to check also if Monitor had already been unpacked.
*** RELIES ON EACH MONITOR HAVING A MODE OF XXXX0000 AAT LEAST ***
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 37.4 91/02/28 14:09:41 spence Exp Locker: spence $
d5 1
a5 1
*   $Locker: spence $
d13 1
a13 1
#include    <graphics/displayinfo.h>
d54 2
a55 1
    struct DisplayInfoRecord *dinfo;
d61 1
d63 1
a63 3
	/* if ID is not in database, and monitor has not been unpacked, unpack it */

	if (((dinfo = find_id(dib, ID)) == NULL) && (!(find_id(dib, (ID  & MONITOR_ID_MASK)))))
d65 2
a66 2
		/* not in the db in RAM. Should we unload it from ROM? */
		if (!(GB->DisplayFlags & PAL))
d68 31
a98 1
			tags = NtscDisplayTags;
d100 5
a104 3
		do_db_startup(dib, tags, ((ID & MONITOR_ID_MASK) >> 16));
		db_avail(GB);
		return( find_id(dib, ID ) );
d106 1
a106 1
	else	/* ID is in database, or ID is not in databse and record has been unpacked */
d108 17
@


37.4
log
@if find_info() cannot find the info for the given ID, it tries to unload it
from ROM to RAM.
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 37.3 91/02/12 15:47:43 spence Exp Locker: spence $
d13 1
d60 4
a63 1
	if ((dinfo = find_id(dib, ID)) == NULL)
d74 2
a75 1
	else
d77 1
@


37.4.1.1
log
@Better protection for unpacking monitors twice
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 37.4 91/02/28 14:09:41 spence Exp Locker: spence $
a12 1
#include	<graphics/view.h>
d53 1
a53 2
    struct DisplayInfoRecord *dinfo, *head;
	struct RawDisplayInfo *rdi;
a58 2
	head = find_key(SubRecord(dib), (ID >> 16), ~0);

d61 2
a62 2
		/* could not find this ID. Was it legal? */
		if ((ID & EXTENDED_MODE) && (ID & 0xFFFF0000))
d64 1
a64 31
		/* OK - it was legal. Now, could we not find it because
		 * the mode was not legal for this monitor, or because
		 * the monitor has not been unpacked?
		*/
			if (head)
			{
			/* Have the head of the monitor. Is this an invalid ID
			 * for a disk-based monitor that has not been made available
			 * yet?
			*/
				/* look for the RawDisplayInfo */
				if ((!(rdi = find_tag(&head->rec_Tag, DTAG_DISP))) ||
				    (rdi->NotAvailable & DI_AVAIL_NOMONITOR))
				{
				/* make it available */
					db_avail(GB);
				}
				/* Either way, this is an invalid mode id. */
				return(NULL);
			}
			else
			{
			/* No head. Unpack from ROM to RAM and try again */
				if (!(GB->DisplayFlags & PAL))
				{
					tags = NtscDisplayTags;
				}
				do_db_startup(dib, tags, ((ID & MONITOR_ID_MASK) >> 16));
				db_avail(GB);
				return( find_id(dib, ID ) );
			}
d66 3
a68 5
		else
		{
		/* Not a legal mode id. */
			return(NULL);		
		}
a70 18
	{
	/* Found the ID. If the monitor has been added from disk, then we need
	 * to make the monitor available if it has not already been done.
	*/
		if (head)
		{
		/* look for the RawDisplayInfo */
			if ((rdi = find_tag(&head->rec_Tag, DTAG_DISP)) &&
			    (rdi->NotAvailable & DI_AVAIL_NOMONITOR))
			{
			/* make it available */
				db_avail(GB);
			}
		}
		/* else
		{
		should never reach here!
		}*/			 
a71 1
	}
@


37.3
log
@autodocs
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 37.2 91/02/06 11:10:10 spence Exp Locker: spence $
d50 2
d53 3
d58 14
a71 2

	return( find_id( GB->DisplayInfoDataBase, ID ) );
d114 3
@


37.2
log
@More autodoc corrections.
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 37.1 91/02/04 19:52:09 spence Exp Locker: spence $
d16 1
a16 1
/****** graphics.library/FindDisplayInfo ***************************************
d19 1
a19 2
*       FindDisplayInfo -- search for a record identified by a specific key
*                          (V36)
d22 2
a23 2
*       handle = FindDisplayInfo( ID )
*       d0               	  d0
d25 1
a25 1
*	ULONG   ID;
a26 2
*	DisplayInfoHandle handle;
*
d29 1
a29 1
*	found in the graphics database.  Using this handle, you can obtain 
d34 1
a34 1
*       ID     - unsigned long identifier
d37 2
a38 2
*       handle - handle to a displayinfo Record with that key 
*	 	 or NULL if no match.
d60 1
a60 1
*       NextDisplayInfo -- iterate current displayinfo identifiers (V36)
d63 2
a64 5
*       next_ID = NextDisplayInfo( last_ID )
*       d0                	   d0
*	
*	ULONG last_ID;
*	ULONG next_ID;
d66 2
d69 2
a70 2
*	The basic iteration function with which to find all records in the 
*	graphics database.  Using each ID in succession, you can then call 
d76 2
a77 2
*       last_ID - previous displayinfo identifier
*		  or INVALID_ID if beginning iteration.
d80 2
a81 2
*       next_ID - subsequent displayinfo identifier
*		  or INVALID_ID if no more records.
d116 1
a116 1
/***** graphics.library/AddDisplayInfo ****************************************
d119 1
a119 1
*       AddDisplayInfo -- add a Record to a Display DataBase
d151 1
a151 1
/****** graphics.library/GetDisplayInfoData ************************************
d154 1
a154 1
*       GetDisplayInfoData -- query DisplayInfo Record parameters (V36)
d157 2
a158 10
*       result = GetDisplayInfoData( handle, buf, size, tagID, [ID] )
*       d0                	     a0      a1   d0    d1	d2 
*	
*	DisplayInfoHandle handle;
*	UBYTE   buf[];
*	ULONG   size;
*	ULONG   tagID;
*	ULONG   ID;
*	
*	ULONG  result;
d160 2
d163 1
a163 1
*	GetDisplayInfoData() fills a buffer with data meaningful to the 
d174 1
a174 1
*       handle - displayinfo handle 
d178 1
a178 1
*       ID     - displayinfo identifier, optionally used if handle is NULL 
d181 2
a182 2
*       result - if positive, number of bytes actually transferred
*		 if zero, no information for ID was available
@


37.1
log
@AutoDocs
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 37.0 91/01/07 15:21:21 spence Exp Locker: spence $
d19 2
a20 1
*       FindDisplayInfo -- search for a record identified by a specific key (V36)
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 36.17 90/10/03 14:35:02 bart Exp Locker: spence $
d19 1
a19 1
*       FindDisplayInfo -- search for a record identified by a specific key
d62 1
a62 1
*       NextDisplayInfo -- iterate current displayinfo identifiers
d157 1
a157 1
*       GetDisplayInfoData -- query DisplayInfo Record parameters 
@


36.17
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Id: find_info.c,v 36.16 90/07/27 16:37:04 bart Exp Locker: bart $
d5 1
a5 1
*   $Locker: bart $
@


36.16
log
@id
@
text
@d3 1
a3 1
*   $Id: $
d177 4
a180 4
*	TAG_DISP: (DisplayInfo)   - properties and availability information.
*	TAG_DIMS: (DimensionInfo) - default dimensions and overscan info.
*	TAG_MNTR: (MonitorInfo)   - type, position, scanrate, and compatibility.
*	TAG_NAME: (NameInfo)      - a user friendly way to refer to this mode.
@


36.15
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: /usr/commodore/amiga/V36/src/kickstart/graphics/d/RCS/find_info.c,v 36.14 89/10/31 13:03:02 bart Exp Locker: bart $
@


36.14
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_info.c,v 36.13 89/02/27 13:43:25 bart Exp $
@


36.13
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_info.c,v 36.12 89/02/27 13:38:50 bart Exp $
d98 2
d103 14
a116 1
	return( next_id( GB->DisplayInfoDataBase, ID ) );
@


36.12
log
@documentation of FUNCTION fields
@
text
@d3 1
a3 1
*   $Header: find_info.c,v 36.11 89/02/17 21:59:09 bart Exp $
d83 1
a83 1
*       last_ID - subsequent displayinfo identifier
@


36.11
log
@checkpoint
@
text
@d3 1
a3 1
*   $Header: find_info.c,v 36.10 89/02/15 16:35:59 bart Exp $
d30 4
d72 5
d157 9
@


36.10
log
@DisplayInfoRecord
@
text
@d3 1
a3 1
*   $Header: find_info.c,v 36.9 89/02/15 13:05:27 bart Exp $
@


36.9
log
@merge DisplayInfoDataBase with graphics
@
text
@d3 1
a3 1
*   $Header: find_info.c,v 36.8 89/02/15 09:46:54 bart Exp $
d11 1
a11 2
#include    "record.h"
#include    "defines.h"
d14 1
d27 1
a27 1
*	Record *handle
d35 1
a35 1
*       handle - pointer to a displayinfo Record with that key 
d45 1
a45 1
struct Record  *find_info( ID )
d95 1
a95 1
/****** graphics.library/AddDisplayInfo ****************************************
d107 1
a107 1
*       record   - pointer to a RecordNode to link to the Display DataBase.
d110 1
a110 1
*       handle -   pointer to this Record after linking or NULL if link failed.
d120 2
a121 2
struct Record  *add_info( record )
struct Record  *record;
d139 1
a139 1
*	Record *handle
d150 1
a150 1
*       ID     - displayinfo identifier
d154 1
d163 1
a163 1
*	FindDisplayInfo(), NextDisplayInfo(), SetDisplayInfoData()
d168 2
a169 2
struct Record *cook_chunk( handle, buf, size, tagID, ID )
struct Record *handle;
d182 1
a182 1
/****** graphics.library/AddDisplayInfoData ************************************
d191 1
a191 1
*	Record *handle
d202 1
a202 1
*       ID     - displayinfo identifier
d206 1
d220 2
a221 2
struct Record *add_chunk( handle, buf, size, tagID, ID )
struct Record *handle;
d234 1
a234 1
/****** graphics.library/SetDisplayInfoData ************************************
d243 1
a243 1
*	Record *handle
d254 1
a254 1
*       ID     - displayinfo identifier
d258 1
d272 2
a273 2
struct Record *uncook_chunk( handle, buf, size, tagID, ID )
struct Record *handle;
@


36.8
log
@single subject database
@
text
@d3 1
a3 1
*   $Header: find_info.c,v 36.7 89/02/13 14:46:25 bart Exp $
a10 1
#include    "display_base.h"
d13 2
d48 1
a48 2
	struct DisplayBase *base = getDisplayBase();
	struct Record *subject = base->Root; 
d50 3
a52 1
	return( find_id( subject, ID ) );
d88 1
a88 2
	struct DisplayBase *base = getDisplayBase();
	struct Record *subject = base->Root;
d90 3
a92 1
	return( next_id( subject, ID ) );
d123 1
a123 2
	struct DisplayBase *base = getDisplayBase();
	struct Record *subject = base->Root;
d125 3
a127 1
	return( add_record( subject, record ) );
d174 1
a174 2
	struct DisplayBase *base = getDisplayBase();
	struct Record *subject = base->Root;
d176 3
a178 1
	return( cook_id( subject, handle, buf, size, tagID, ID ) ); 
d225 1
a225 2
	struct DisplayBase *base = getDisplayBase();
	struct Record *subject = base->Root;
d227 3
a229 1
	return( add_id( subject, handle, buf, size, tagID, ID ) ); 
d276 1
a276 2
	struct DisplayBase *base = getDisplayBase();
	struct Record *subject = base->Root;
d278 3
a280 1
	return( uncook_id( subject, handle, buf, size, tagID, ID ) ); 
@


36.7
log
@add displayinfodata
@
text
@d3 1
a3 1
*   $Header: find_info.c,v 36.6 89/02/13 13:19:10 bart Exp $
d48 1
a48 2
	struct Record *subject = 
	find_key( SubRecord(base->Root), GRAPHICS_MONITORS_ID, ~0 );
d87 1
a87 2
	struct Record *subject = 
	find_key( SubRecord(base->Root), GRAPHICS_MONITORS_ID, ~0 );
d121 1
a121 2
	struct Record *subject = 
	find_key( SubRecord(base->Root), GRAPHICS_MONITORS_ID, ~0 );
d171 1
a171 2
	struct Record *subject = 
	find_key( SubRecord(base->Root), GRAPHICS_MONITORS_ID, ~0 );
d221 1
a221 2
	struct Record *subject = 
	find_key( SubRecord(base->Root), GRAPHICS_MONITORS_ID, ~0 );
d271 1
a271 2
	struct Record *subject = 
	find_key( SubRecord(base->Root), GRAPHICS_MONITORS_ID, ~0 );
@


36.6
log
@cook
@
text
@d3 1
a3 1
*   $Header: find_info.c,v 36.5 89/02/13 11:52:24 bart Exp $
d166 1
a166 1
struct Record *cook_info( handle, buf, size, tagID, ID )
d217 10
a226 1
/* stub */
d228 3
d268 1
a268 1
struct Record *uncook_info( handle, buf, size, tagID, ID )
@


36.5
log
@get/set/add displayinfodata
@
text
@d3 1
a3 1
*   $Header: find_info.c,v 36.4 89/01/27 13:12:34 bart Exp $
d94 35
d256 6
a261 29
/* stub */

/****** graphics.library/AddDisplayInfo ****************************************
*
*   NAME
*       AddDisplayInfo -- add a Record to a Display DataBase
*
*   SYNOPSIS
*       handle = AddDisplayInfo( record )
*       d0                       a0
*
*   FUNCTION
*
*   INPUTS
*       record   - pointer to a RecordNode to link to the Display DataBase.
*
*   RESULT
*       handle -   pointer to this Record after linking or NULL if link failed.
*
*   BUGS
*       does not check to see if there is already a child with identical key.
*
*   SEE ALSO
*       graphics/displayinfo.h
*
*******************************************************************************/

struct Record  *add_info( record )
struct Record  *record;
d267 1
a267 1
	return( add_record( subject, record ) );
@


36.4
log
@query routines
@
text
@d3 1
a3 1
*   $Header: find_info.c,v 36.3 89/01/25 12:14:46 bart Exp $
d5 1
a5 1
*   $Locker:  $
d15 1
a15 1
/****** display.library/FindDisplayInfo ***************************************
d21 2
a22 5
*       record = FindDisplayInfo( ID )
*       d0                	  d0
*	
*	ULONG ID;
*	struct Record *record;
d24 4
d31 1
a31 1
*       ID - displayinfo identifier
d34 3
a36 2
*       record - pointer to a displayinfo Record with that key 
*		 or NULL if no match.
d40 1
a40 1
*	NextDisplayInfo(), QueryDisplayInfo(), display/record.h
d54 1
a54 1
/****** display.library/NextDisplayInfo ***************************************
d70 1
d74 1
d79 2
a80 1
*	FindDisplayInfo(), QueryDisplayInfo(), display/record.h
d94 1
a94 1
/****** display.library/QueryDisplayInfo ***************************************
d97 1
a97 1
*       QueryDisplayInfo -- query DisplayInfo Record parameters 
d100 2
a101 2
*       result = QueryDisplayInfo( ID, buf, size, tagID )
*       d0                	   d0  a0   d1	  d2
d103 5
a107 4
*	ULONG  ID;
*	UBYTE  buf[];
*	ULONG  size;
*	ULONG  tagID;
d114 4
a117 4
*       ID    - displayinfo identifier
*	buf   - pointer to destination buffer
*	size  - buffer size in bytes
*	tagID - query tag type
d120 1
a120 1
*       result - if positive, number of bytes actually copied
d126 2
a127 1
*	FindDisplayInfo(), NextDisplayInfo(), display/record.h
d131 2
a132 2
struct Record  *cook_info( ID, buf, size, tagID )
ULONG ID;
d136 1
d142 114
a255 1
	return( cook_id( subject, ID, buf, size, tagID ) ); 
@


36.3
log
@find_tag
@
text
@d3 1
a3 1
*   $Header: find_info.c,v 36.2 89/01/25 11:12:57 bart Exp $
d5 1
a5 1
*   $Locker: bart $
d38 1
a38 1
*	NextDisplayInfo(), CookDisplayInfo(), display/record.h
d75 1
a75 1
*	FindDisplayInfo(), CookDisplayInfo(), display/record.h
d89 1
a89 1
/****** display.library/CookDisplayInfo ***************************************
d92 1
a92 1
*       CookDisplayInfo -- query DisplayInfo Record parameters 
d95 2
a96 2
*       result = CookDisplayInfo( ID, buf, size )
*       d0                	  d0  a0   d1	
d101 1
d111 1
d124 1
a124 1
struct Record  *cook_info( ID, buf, size )
d128 1
d130 3
a132 1
	ULONG result = 0;
d134 1
a134 24
	if( buf )
	{
	    struct Record *object = find_info( ID );

	    if( object )
	    {
		struct QueryHeader *query = (struct QueryHeader *)
				    find_tag( &object->rec_Tag, TAG_DISP );
		if( query )
		{
		    register UBYTE *src = (UBYTE *)query;
		    ULONG bytes = ( sizeof(*query)) +
				  ( query->Length << 3 ) +
				  ( sizeof(ULONG) << 1 );

		    while((size--) && (bytes--) && (++result))
		    {
			*buf++ = *src++;
		    }
		}
	    }
	}

	return( result );
@


36.2
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_info.c,v 36.1 89/01/16 12:05:47 bart Exp $
d131 1
a131 4
	    struct DisplayBase *base = getDisplayBase();
	    struct Record *subject = 
	    find_key( SubRecord(base->Root), GRAPHICS_MONITORS_ID, ~0 );
	    struct Record *object = find_id( subject, ID );
d136 1
a136 1
				    FindTag( &object->rec_Tag, TAG_DISP );
@


36.1
log
@*** empty log message ***
@
text
@d3 1
a3 1
*   $Header: find_info.c,v 36.0 89/01/16 10:14:58 bart Exp $
d38 1
a38 1
*	NextDisplayInfo(), display/record.h
d75 1
a75 1
*	FindDisplayInfo(), display/record.h
d89 68
@


36.0
log
@added to rcs for updating
@
text
@d3 1
a3 1
*   $Header: $
d5 1
a5 1
*   $Locker:  $
d13 1
d18 1
a18 1
*       Find-- search for a record identified by a specific key
d21 2
a22 2
*       record = FindKey( ID )
*       d0                d0
d38 1
a38 1
*	display/record.h
d45 3
a47 2
	struct DisplayBase *base = getDisplayBase;
	struct Record *type = find_key( base->Root, GRAPHICS_MONITORS_ID, ~0 );
d49 38
a86 1
	return( find_id( type, ID ) );
@
