head     39.21;
branch   ;
access   ;
symbols  rel39_24:39.21 rel39_18:39.21 rel39_97:39.16 rel39_90:39.16 rel39_89:39.16 rel39_82:39.13 rel39_76:39.13 rel39_71:39.10 rel39_65:39.10 rel39_64:39.10 rel39_61:39.10 rel39_60:39.10 rel39_55:39.9 rel39_47:39.8 rel39_39:39.6 rel39_38:39.6 rel39_37:39.5 rel39_35:39.4 rel39_34:39.4 V37_30:37.0 V37_29:37.0 V37_28:37.0 V37_25:37.0 V37_22:37.0 V37_21:37.0 V37_20:37.0 V37_19:37.0 V37_17:37.0 V37_15:37.0 V37_14:37.0 V37_13:37.0 V37_12:37.0 V37_11:37.0 V37_10:37.0 V37_9:37.0 V37_8:37.0 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:1.26 V36_208:1.26 V36_207:1.26 V36_205:1.26 V36_203:1.26 V36_202:1.26 V36_201:1.26 V36_200:1.26 V36_199:1.26 V36_198:1.26 V36_196:1.26 V36_195:1.26 V36_194:1.26 V36_193:1.26 V36_192:1.26 V36_191:1.26 V36_190:1.26 V36_189:1.26 V36_188:1.26 V36_187:1.26 V36_186:1.26 V36_185:1.26 V36_184:1.26 V36_183:1.26 V36_182:1.26 V36_181:1.25 V36_67:1.25;
locks    ; strict;
comment  @ * @;


39.21
date     93.03.12.13.58.59;  author chrisg;  state Exp;
branches ;
next     39.20;

39.20
date     93.02.15.17.42.19;  author spence;  state Exp;
branches ;
next     39.19;

39.19
date     93.01.20.17.33.52;  author chrisg;  state Exp;
branches ;
next     39.18;

39.18
date     93.01.20.13.34.49;  author chrisg;  state Exp;
branches ;
next     39.17;

39.17
date     92.12.02.09.55.54;  author chrisg;  state Exp;
branches ;
next     39.16;

39.16
date     92.08.27.14.49.28;  author chrisg;  state Exp;
branches ;
next     39.15;

39.15
date     92.08.20.15.08.26;  author chrisg;  state Exp;
branches ;
next     39.14;

39.14
date     92.08.18.13.49.40;  author spence;  state Exp;
branches ;
next     39.13;

39.13
date     92.07.29.16.51.19;  author chrisg;  state Exp;
branches ;
next     39.12;

39.12
date     92.07.21.14.47.38;  author spence;  state Exp;
branches ;
next     39.11;

39.11
date     92.07.09.10.13.09;  author chrisg;  state Exp;
branches ;
next     39.10;

39.10
date     92.05.05.12.18.45;  author chrisg;  state Exp;
branches ;
next     39.9;

39.9
date     92.04.06.12.27.20;  author chrisg;  state Exp;
branches ;
next     39.8;

39.8
date     92.04.04.14.35.50;  author chrisg;  state Exp;
branches ;
next     39.7;

39.7
date     92.03.20.10.03.18;  author chrisg;  state Exp;
branches ;
next     39.6;

39.6
date     92.02.28.13.41.55;  author spence;  state Exp;
branches ;
next     39.5;

39.5
date     92.02.25.14.29.36;  author spence;  state Exp;
branches ;
next     39.4;

39.4
date     92.01.21.13.35.22;  author chrisg;  state Exp;
branches ;
next     39.3;

39.3
date     92.01.17.12.10.41;  author spence;  state Exp;
branches ;
next     39.2;

39.2
date     91.11.11.11.49.24;  author chrisg;  state Exp;
branches ;
next     39.1;

39.1
date     91.10.18.16.27.32;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.31.43;  author chrisg;  state Exp;
branches ;
next     38.0;

38.0
date     91.07.27.17.05.57;  author spence;  state Exp;
branches ;
next     37.3;

37.3
date     91.06.14.11.10.14;  author chrisg;  state Exp;
branches ;
next     37.2;

37.2
date     91.05.15.13.00.06;  author spence;  state Exp;
branches ;
next     37.1;

37.1
date     91.05.09.14.29.29;  author spence;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.21.51;  author spence;  state Exp;
branches ;
next     1.26;

1.26
date     90.09.12.15.29.10;  author bart;  state Exp;
branches ;
next     1.25;

1.25
date     90.07.27.16.39.20;  author bart;  state Exp;
branches ;
next     1.24;

1.24
date     90.05.27.13.16.28;  author bart;  state Exp;
branches ;
next     1.23;

1.23
date     90.03.28.09.13.33;  author bart;  state Exp;
branches ;
next     1.22;

1.22
date     89.11.21.10.56.46;  author bart;  state Exp;
branches ;
next     1.21;

1.21
date     89.04.29.15.43.07;  author bart;  state Exp;
branches ;
next     1.20;

1.20
date     89.03.03.17.21.45;  author bart;  state Exp;
branches ;
next     1.19;

1.19
date     89.03.03.11.02.02;  author bart;  state Exp;
branches ;
next     1.18;

1.18
date     89.03.02.18.30.44;  author bart;  state Exp;
branches ;
next     1.17;

1.17
date     89.03.01.13.45.27;  author bart;  state Exp;
branches ;
next     1.16;

1.16
date     89.03.01.13.31.10;  author bart;  state Exp;
branches ;
next     1.15;

1.15
date     89.03.01.13.12.31;  author bart;  state Exp;
branches ;
next     1.14;

1.14
date     89.03.01.12.53.10;  author bart;  state Exp;
branches ;
next     1.13;

1.13
date     89.02.14.10.13.22;  author bart;  state Exp;
branches ;
next     1.12;

1.12
date     89.02.01.17.53.04;  author bart;  state Exp;
branches ;
next     1.11;

1.11
date     89.01.31.15.39.17;  author bart;  state Exp;
branches ;
next     1.10;

1.10
date     89.01.26.10.45.51;  author bart;  state Exp;
branches ;
next     1.9;

1.9
date     89.01.24.15.38.33;  author bart;  state Exp;
branches ;
next     1.8;

1.8
date     89.01.23.16.12.23;  author bart;  state Exp;
branches ;
next     1.7;

1.7
date     89.01.23.16.00.34;  author bart;  state Exp;
branches ;
next     1.6;

1.6
date     89.01.23.15.58.49;  author bart;  state Exp;
branches ;
next     1.5;

1.5
date     89.01.19.17.28.41;  author bart;  state Exp;
branches ;
next     1.4;

1.4
date     89.01.18.13.54.54;  author bart;  state Exp;
branches ;
next     1.3;

1.3
date     89.01.17.14.29.16;  author bart;  state Exp;
branches ;
next     1.2;

1.2
date     89.01.17.11.38.47;  author bart;  state Exp;
branches ;
next     1.1;

1.1
date     88.09.19.20.43.02;  author dale;  state Exp;
branches ;
next     ;


desc
@New VideoControl procedure for genlock and more.
@


39.21
log
@ew tags.
@
text
@/******************************************************************************
*
*   $Id: videocontrol.c,v 39.20 93/02/15 17:42:19 spence Exp Locker: chrisg $
*
*   $Locker: chrisg $
*
******************************************************************************/

#include <exec/types.h>
#include <utility/tagitem.h>
#include "/gfxbase.h"
#include "/view.h"
#include "/videocontrol.h"
#include "/displayinfo.h"
#include "d.protos"
#include "/macros.h"
#include "/displayinfo_internal.h"
#include "/c/c.protos"
#include <hardware/custom.h>
#include <clib/utility_protos.h>
#include <pragmas/utility_pragmas.h>

extern struct Custom custom;

/* need to consider GlobalVideoControl issues at length -- bart */

/* need to consider GlobalVideoControl issues at length -- bart */

/* returns the number of pens currently set up for chroma_key */

int __regargs num_chroma_pens(cm) 
struct ColorMap *cm;
{
    int i, num = 0;
    WORD *p = cm->ColorTable;

    Forbid();	/* like this really protects us! */

    for(i=0; i<cm->Count; i++)
	if ((*p++)<0) num++;		/* check high bit of color table */

    Permit();

    return(num); 
}

/* This function may then be renamed to LocalVideoControl */

#define AA_CHIPS (GBASE->ChipRevBits0 & GFXF_AA_LISA)

long	videocontrol(cm,v)
register struct ColorMap *cm;
register struct TagItem *v;
{
	struct TagItem *tstate;
	int error = FALSE;
	int must_remake = 0;			/* must a remake happen if vtag_immed was set? */
	int *remake_variable=0;			/* where the user wants the remake flag set or null */
	int must_do_bplcon2=0;			/* must we repoke bplcon2? */
	int must_do_bplcon3=0;			/* must we repoke bplcon3? */
	int must_do_bplcon4=0;			/* must we repoke bplcon4? */
	int must_do_colors=0;			/* must we call pokecolors? */
	int must_do_ecsena=0;			/* ecs enable changes */
	if(!cm || (!(cm->Type))) error = -1; /* error, bad colormap */

	tstate=v;
	while((!error) && (v=NextTagItem(&tstate)))
	{
		int TagData=(int) v->ti_Data;
		switch(v->ti_Tag)
		{
			/* handle videocontrol tags */
			case	VTAG_CHROMAKEY_CLR:
				must_do_colors++;
				must_do_bplcon2++;
				cm->Flags &= ~COLORMAP_TRANSPARENCY;
				break;
			case	VTAG_CHROMAKEY_SET:
				must_do_colors++;
				must_do_bplcon2++;
				cm->Flags |=  COLORMAP_TRANSPARENCY;
				break;
			case	VTAG_BITPLANEKEY_CLR:
				must_do_bplcon2++;
				cm->Flags &= ~COLORPLANE_TRANSPARENCY;
				break;
			case	VTAG_BITPLANEKEY_SET:
				must_do_bplcon2++;
				cm->Flags |=  COLORPLANE_TRANSPARENCY;
				break;
			case	VTAG_BORDERBLANK_CLR:
				must_do_bplcon3++;
				must_do_ecsena++;
				cm->Flags &= ~BORDER_BLANKING;
				break;
			case	VTAG_BORDERBLANK_SET:
				must_do_bplcon3++;
				must_do_ecsena++;
				cm->Flags |=  BORDER_BLANKING;
				break;
			case	VTAG_BORDERNOTRANS_CLR:
				must_do_ecsena++;
				must_do_bplcon3++;
				cm->Flags &= ~BORDER_NOTRANSPARENCY;
				break;
			case	VTAG_BORDERNOTRANS_SET:
				must_do_ecsena++;
				must_do_bplcon3++;
				cm->Flags |=  BORDER_NOTRANSPARENCY;
				break;
			case	VTAG_CHROMA_PEN_CLR:
				if (TagData <cm->Count)
				{
				     must_do_colors++;
				     ((UWORD *)(cm->ColorTable))[TagData] &= 0x7fff;
				}
				break;
			case	VTAG_CHROMA_PEN_SET:
				if (TagData <cm->Count)
				{
				    ((UWORD *)(cm->ColorTable))[TagData] |= 0x8000;
				    must_do_colors++;
				}
				break;
			case	VTAG_CHROMA_PLANE_SET:
				if (TagData < 8) {
					must_do_bplcon2++;
					cm->TransparencyPlane = TagData;
				}
				break;
			case	VTAG_ATTACH_CM_SET:
				Forbid();
				{
				    struct ViewPort *vp = 
				    (struct ViewPort *) TagData;
				    must_remake++;
				    if (vp)
				    {
					/* remove old reference */
					struct ColorMap *oldcm = vp->ColorMap;
					if (oldcm) oldcm->cm_vp = 0;
					vp->ColorMap = cm;
					cm->cm_vp = vp;
				    }
				}
				Permit();
				break;
			case	VTAG_NEXTBUF_CM:
				tstate = (struct TagItem *)TagData;
				break;
			case	VTAG_BATCH_CM_CLR:
				cm->Flags &= ~VIDEOCONTROL_BATCH;
				break;
			case	VTAG_BATCH_CM_SET:
				cm->Flags |=  VIDEOCONTROL_BATCH;
				break;
			case	VTAG_NORMAL_DISP_GET:
				v->ti_Tag  = VTAG_NORMAL_DISP_SET;
				v->ti_Data = (ULONG)cm->NormalDisplayInfo;
				break;
			case	VTAG_NORMAL_DISP_SET:
				must_remake++;
				cm->NormalDisplayInfo = (APTR)TagData;
				break;
			case	VTAG_COERCE_DISP_GET:
				v->ti_Tag  = VTAG_COERCE_DISP_SET;
				v->ti_Data = (ULONG)cm->CoerceDisplayInfo;
				break;
			case	VTAG_COERCE_DISP_SET:
				must_remake++;
				cm->CoerceDisplayInfo = (APTR)TagData;
				break;
			case	VTAG_VIEWPORTEXTRA_GET:
				v->ti_Tag  = VTAG_VIEWPORTEXTRA_SET;
				v->ti_Data = (ULONG)cm->cm_vpe;
				break;
			case	VTAG_VIEWPORTEXTRA_SET:
				{
					must_remake++;
					cm->cm_vpe = (struct ViewPortExtra *)TagData;
				}
			case	VTAG_CHROMAKEY_GET:
				v->ti_Tag = VTAG_CHROMAKEY_CLR;
				if(cm->Flags & COLORMAP_TRANSPARENCY)
				{
				    v->ti_Tag = VTAG_CHROMAKEY_SET;
				}
				v->ti_Data = num_chroma_pens(cm);
				break;
			case	VTAG_BITPLANEKEY_GET:
				v->ti_Tag = VTAG_BITPLANEKEY_CLR;
				if(cm->Flags & COLORPLANE_TRANSPARENCY)
				{
				    v->ti_Tag = VTAG_BITPLANEKEY_SET;
				}
				break;
			case	VTAG_BORDERBLANK_GET:
			    v->ti_Tag = VTAG_BORDERBLANK_CLR;
				if (cm->Flags & BORDER_BLANKING)
				{
				    v->ti_Tag = VTAG_BORDERBLANK_SET;
				}
				break;
			case	VTAG_BORDERNOTRANS_GET:
				v->ti_Tag = VTAG_BORDERNOTRANS_CLR;
				if(cm->Flags & BORDER_NOTRANSPARENCY)
				{
				    v->ti_Tag = VTAG_BORDERNOTRANS_SET;
				}
				break;
			case	VTAG_CHROMA_PEN_GET:
				v->ti_Tag=(((WORD *)cm->ColorTable)[TagData] < 0)?VTAG_CHROMA_PEN_SET:VTAG_CHROMA_PEN_CLR;
				break;
			case	VTAG_CHROMA_PLANE_GET:
				v->ti_Tag  = VTAG_CHROMA_PLANE_SET;
				v->ti_Data = (ULONG)cm->TransparencyPlane;
				break;
			case	VTAG_ATTACH_CM_GET:
				v->ti_Tag  = VTAG_ATTACH_CM_SET;
				v->ti_Data = (ULONG)cm->cm_vp;
				break;
			case	VTAG_BATCH_CM_GET:
			    v->ti_Tag  = VTAG_BATCH_CM_CLR;
				if(cm->Flags & VIDEOCONTROL_BATCH)
				{
				    v->ti_Tag  = VTAG_BATCH_CM_SET;
				}
				break;
			case	VTAG_BATCH_ITEMS_GET:
				v->ti_Tag  = VTAG_BATCH_ITEMS_SET;
				v->ti_Data = (ULONG)cm->cm_batch_items;
				break;
			case	VTAG_BATCH_ITEMS_SET:
				cm->cm_batch_items = (struct TagItem *)	TagData;
				break;
			case	VTAG_BATCH_ITEMS_ADD:
				Forbid(); 
				{
				    struct TagItem *oi = cm->cm_batch_items;
				    struct TagItem *ti = (struct TagItem *)
				    TagData;

				    while(ti && (ti->ti_Tag != VTAG_END_CM))
				    {
					if(ti->ti_Tag == VTAG_NEXTBUF_CM)
					{
					    ti = (struct TagItem *)ti->ti_Data;
					}
					else 
					{
					    ti++;
					}
				    }
				    if(ti != (struct TagItem *)TagData) 
				    {
					ti->ti_Tag  = VTAG_NEXTBUF_CM;
					ti->ti_Data = (ULONG)oi;
					ti = (struct TagItem *)TagData;
				    }
				    else
				    {
					ti = oi;
				    }
				    cm->cm_batch_items = ti;
				}
				Permit();
				break;
			case	VTAG_VPMODEID_GET:
				    v->ti_Tag  = VTAG_VPMODEID_SET;
					v->ti_Data = (ULONG)cm->VPModeID;
				break;
			case	VTAG_VPMODEID_SET:
				{
					struct ViewPort *vp = cm->cm_vp;
					ULONG ID = (ULONG)TagData;

					must_remake++;
					ObtainSemaphore(GBASE->ActiViewCprSemaphore);
					cm->VPModeID = ID;
					if ((vp) && (ID != INVALID_ID))
					{
						AttachVecTable(cm->cm_vpe, NULL, ID);
					}
					ReleaseSemaphore(GBASE->ActiViewCprSemaphore);
				}
				break;
			case	VTAG_VPMODEID_CLR:
				{
					must_remake++;
					ObtainSemaphore(GBASE->ActiViewCprSemaphore);
					cm->VPModeID = (ULONG)INVALID_ID;
					if (cm->cm_vpe)
					{
						cm->cm_vpe->VecTable = NULL;
					}
					ReleaseSemaphore(GBASE->ActiViewCprSemaphore);
				}
				break;
			case	VTAG_USERCLIP_GET:
			    	v->ti_Tag = VTAG_USERCLIP_CLR;
				if(cm->Flags & USER_COPPER_CLIP)
				{
				    v->ti_Tag = VTAG_USERCLIP_SET;
				}
				break;
			case	VTAG_USERCLIP_SET:
				must_remake++;
				cm->Flags |=   USER_COPPER_CLIP;
				break;
			case	VTAG_USERCLIP_CLR:
				must_remake++;
				cm->Flags &=  ~USER_COPPER_CLIP;
				break;

			case VTAG_PF2_BASE_SET:
				if (AA_CHIPS) {
					cm->Bp_0_base=(UWORD) TagData; must_do_bplcon4++;
				}
				break;
			case VTAG_PF1_BASE_SET:
				if (AA_CHIPS) { cm->Bp_1_base=(UWORD) TagData; must_do_bplcon4++; }
				break;

			case VTAG_SPEVEN_BASE_SET:
				if (AA_CHIPS) { cm->SpriteBase_Even=(UWORD) TagData; must_do_bplcon4++; }
				break;

			case VTAG_SPODD_BASE_SET:
				if (AA_CHIPS) { cm->SpriteBase_Odd=(UWORD) TagData; must_do_bplcon4++; }
				break;

			case VTAG_PF2_BASE_GET:
				v->ti_Tag = VTAG_PF2_BASE_SET;
				v->ti_Data=cm->Bp_0_base;
				break;

			case VTAG_PF1_BASE_GET:
				v->ti_Tag = VTAG_PF1_BASE_SET;
				v->ti_Data=cm->Bp_1_base;
				break;

			case VTAG_SPEVEN_BASE_GET:
				v->ti_Tag=VTAG_SPEVEN_BASE_SET;
				v->ti_Data=cm->SpriteBase_Even;
				break;

			case VTAG_SPODD_BASE_GET:
				v->ti_Tag=VTAG_SPODD_BASE_SET;
				v->ti_Data=cm->SpriteBase_Odd;
				break;


			case	VTAG_BORDERSPRITE_GET:
			        v->ti_Tag = VTAG_BORDERSPRITE_CLR;
				if(cm->Flags & BORDERSPRITES)
				{
				    v->ti_Tag = VTAG_BORDERSPRITE_SET;
				}
				break;
			case	VTAG_BORDERSPRITE_SET:
				if (AA_CHIPS) { cm->Flags |= BORDERSPRITES; must_do_bplcon3++; }
				break;
			case	VTAG_BORDERSPRITE_CLR:
				if (AA_CHIPS) { cm->Flags &=  ~BORDERSPRITES; must_do_bplcon3++; }
				break;
			case	VTAG_SPRITERESN_SET:
				if ((AA_CHIPS) && (cm->SpriteResolution != TagData))
				{
				 	cm->SpriteResolution = TagData;
					must_do_bplcon3++;
				}
				break;
			case	VTAG_SPRITERESN_GET:
				v->ti_Tag = VTAG_SPRITERESN_SET;
				v->ti_Data = cm->SpriteResolution;
				break;
			case	VTAG_PF1_TO_SPRITEPRI_SET:
				if (cm->cm_vp)
				{
					UBYTE pri = (cm->cm_vp->SpritePriorities & 0x38);	/* preserve pf2 */
					cm->cm_vp->SpritePriorities = (pri | MIN(TagData, 7));
					must_do_bplcon2++;
				}
				break;
			case	VTAG_PF1_TO_SPRITEPRI_GET:
				v->ti_Tag = VTAG_PF1_TO_SPRITEPRI_SET;
				v->ti_Data = 0x4;	/* default */
				if (cm->cm_vp)
				{
					v->ti_Data = (cm->cm_vp->SpritePriorities & 0x7);
				}
				break;
			case	VTAG_PF2_TO_SPRITEPRI_SET:
				if (cm->cm_vp)
				{
					UBYTE pri = (cm->cm_vp->SpritePriorities & 0x7);	/* preserve pf1 */
					must_do_bplcon2++;
					cm->cm_vp->SpritePriorities = (pri | (MIN(TagData, 7) << 3));
				}
				break;
			case	VTAG_PF2_TO_SPRITEPRI_GET:
				v->ti_Tag = VTAG_PF2_TO_SPRITEPRI_SET;
				v->ti_Data = 0x4;	/* default */
				if (cm->cm_vp)
				{
					v->ti_Data = ((cm->cm_vp->SpritePriorities & 0x38) >> 3);
				}
				break;
			case VTAG_IMMEDIATE:
				remake_variable=(int *) (TagData);
				break;

			case VTAG_FULLPALETTE_SET:
				cm->AuxFlags |= CMAF_FULLPALETTE;
				must_remake++;
				break;

			case VTAG_FULLPALETTE_GET:
				v->ti_Tag=VTAG_FULLPALETTE_SET;
				v->ti_Data=(cm->AuxFlags & CMAF_FULLPALETTE)?-1:0;
				break;

			case VTAG_FULLPALETTE_CLR:
				cm->AuxFlags &= ~CMAF_FULLPALETTE;
				break;

			case VTAG_DEFSPRITERESN_SET:
				if ((AA_CHIPS) && (cm->SpriteResDefault != TagData))
				{
					cm->SpriteResDefault=TagData;
					must_do_bplcon3++;
				}
				break;

			case VTAG_DEFSPRITERESN_GET:
				v->ti_Tag=VTAG_DEFSPRITERESN_SET;
				v->ti_Data=cm->SpriteResDefault;
				break;

			default:
/* start of new tag handling tags! separating these makes code smaller */
				switch(v->ti_Tag)
				{
					case VC_IntermediateCLUpdate:
						if (TagData)
							cm->AuxFlags &= ~CMAF_NO_INTERMED_UPDATE;
						else
							cm->AuxFlags |= CMAF_NO_INTERMED_UPDATE;
						break;

					case VC_IntermediateCLUpdate_Query:
						*((ULONG *) TagData)=(cm->AuxFlags & CMAF_NO_INTERMED_UPDATE)?0:-1;
						break;
					case VC_NoColorPaletteLoad:
						must_remake++;
						if (TagData)
						{
							cm->AuxFlags |= CMAF_NO_COLOR_LOAD;
						}
						else
						{
							cm->AuxFlags &= ~CMAF_NO_COLOR_LOAD;
						}
						break;
					case VC_NoColorPaletteLoad_Query:
						*((ULONG *) TagData)=(cm->AuxFlags & CMAF_NO_COLOR_LOAD)?-1:0;
						break;

					case VC_DUALPF_Disable:
						must_remake++;
						if (TagData)
						{
							cm->AuxFlags |= CMAF_DUALPF_DISABLE;
						}
						else
						{
							cm->AuxFlags &= ~CMAF_DUALPF_DISABLE;
						}
						break;
					case VC_DUALPF_Disable_Query:
						*((ULONG *) TagData)=(cm->AuxFlags & CMAF_DUALPF_DISABLE)? -1:0;
						break;
				}
		}
	}



//	kprintf("make=%d con2=%d con4=%d cm->cm_vp=%08lx\n",must_remake,must_do_bplcon2,must_do_bplcon4,cm->cm_vp);

	must_remake = (must_remake || must_do_bplcon2 || must_do_bplcon4 || !cm || !(cm->cm_vp));

	if (remake_variable)
	{
	    *remake_variable=must_remake;
	    if (! must_remake)
	    {
		if (must_do_colors || must_do_bplcon3)
		{
		    ObtainSemaphore(GBASE->ActiViewCprSemaphore);
		    if (must_do_colors) pokecolors(cm->cm_vp);
		    if (must_do_bplcon3) pokevp(cm->cm_vp,REGNUM(bplcon3),get_bplcon3(cm),0x1cfe);
		    if (must_do_ecsena)	pokevp(cm->cm_vp,REGNUM(bplcon0),1,1);
		    update_top_color(GBASE->current_monitor);
		    ReleaseSemaphore(GBASE->ActiViewCprSemaphore);
		}
	    }
	}	


	return (error);	/* ok?, or not... */
}
@


39.20
log
@VC_NoColorPaletteLoad support.
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.19 93/01/20 17:33:52 chrisg Exp Locker: spence $
d5 1
a5 1
*   $Locker: spence $
d455 1
d466 16
a481 1
						*((ULONG *) TagData)=(cm->AuxFlags & CMAF_NO_COLOR_LOAD)? 0 : -1;
@


39.19
log
@optimized.

@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.18 93/01/20 13:34:49 chrisg Exp Locker: chrisg $
d5 1
a5 1
*   $Locker: chrisg $
d454 14
a467 1
				}		
@


39.18
log
@optimization
intermiedate clupdate.
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.17 92/12/02 09:55:54 chrisg Exp Locker: chrisg $
d440 10
a449 7
/* start of new tag handling tags! */
			case VC_IntermediateCLUpdate:
				if (TagData)
					cm->AuxFlags &= ~CMAF_NO_INTERMED_UPDATE;
				else
					cm->AuxFlags |= CMAF_NO_INTERMED_UPDATE;
				break;
d451 4
a454 4
			case VC_IntermediateCLUpdate_Query:
				*((ULONG *) TagData)=(cm->AuxFlags & CMAF_NO_INTERMED_UPDATE)?0:-1;
				break;
				
@


39.17
log
@made not abort on bad tags.
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.16 92/08/27 14:49:28 chrisg Exp Locker: chrisg $
d69 1
d112 1
a112 1
				if (v->ti_Data <cm->Count)
d115 1
a115 1
				     ((UWORD *)(cm->ColorTable))[v->ti_Data] &= 0x7fff;
d119 1
a119 1
				if (v->ti_Data <cm->Count)
d121 1
a121 1
				    ((UWORD *)(cm->ColorTable))[v->ti_Data] |= 0x8000;
d126 1
a126 1
				if (v->ti_Data < 8) {
d128 1
a128 1
					cm->TransparencyPlane = v->ti_Data;
d135 1
a135 1
				    (struct ViewPort *) v->ti_Data;
d149 1
a149 1
				tstate = (struct TagItem *)v->ti_Data;
d163 1
a163 1
				cm->NormalDisplayInfo = (APTR)v->ti_Data;
d171 1
a171 1
				cm->CoerceDisplayInfo = (APTR)v->ti_Data;
d180 1
a180 1
					cm->cm_vpe = (struct ViewPortExtra *)v->ti_Data;
d212 1
a212 1
				v->ti_Tag=(((WORD *)cm->ColorTable)[v->ti_Data] < 0)?VTAG_CHROMA_PEN_SET:VTAG_CHROMA_PEN_CLR;
d234 1
a234 1
				cm->cm_batch_items = (struct TagItem *)	v->ti_Data;
d241 1
a241 1
				    v->ti_Data;
d254 1
a254 1
				    if(ti != (struct TagItem *)v->ti_Data) 
d258 1
a258 1
					ti = (struct TagItem *)v->ti_Data;
d275 1
a275 1
					ULONG ID = (ULONG)v->ti_Data;
d317 1
a317 1
					cm->Bp_0_base=(UWORD) v->ti_Data; must_do_bplcon4++;
d321 1
a321 1
				if (AA_CHIPS) { cm->Bp_1_base=(UWORD) v->ti_Data; must_do_bplcon4++; }
d325 1
a325 1
				if (AA_CHIPS) { cm->SpriteBase_Even=(UWORD) v->ti_Data; must_do_bplcon4++; }
d329 1
a329 1
				if (AA_CHIPS) { cm->SpriteBase_Odd=(UWORD) v->ti_Data; must_do_bplcon4++; }
d367 1
a367 1
				if ((AA_CHIPS) && (cm->SpriteResolution != v->ti_Data))
d369 1
a369 1
				 	cm->SpriteResolution = v->ti_Data;
d381 1
a381 1
					cm->cm_vp->SpritePriorities = (pri | MIN(v->ti_Data, 7));
d398 1
a398 1
					cm->cm_vp->SpritePriorities = (pri | (MIN(v->ti_Data, 7) << 3));
d410 1
a410 1
				remake_variable=(int *) (v->ti_Data);
d428 1
a428 1
				if ((AA_CHIPS) && (cm->SpriteResDefault != v->ti_Data))
d430 1
a430 1
					cm->SpriteResDefault=v->ti_Data;
d440 12
@


39.16
log
@handle ecsena for some chnages.
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.15 92/08/20 15:08:26 chrisg Exp Locker: chrisg $
a64 1
	if(!v ) error = -2; 		     /* error, bad tagitems */
a438 3
			default:
				error = -3; /* error, bad command */
				break; 
@


39.15
log
@range check chroma pen
ignore >7 values for chroma plane.
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.14 92/08/18 13:49:40 spence Exp Locker: chrisg $
d63 1
a63 1

d93 1
d98 1
d102 1
d107 1
d462 2
a463 1
			update_top_color(GBASE->current_monitor);
@


39.14
log
@if attaching an attached ColorMap to another ViewPort, then reattaching
the ColorMap back afterwards would cause the ColorMap's backpointer to
be NULL. Fixed by reordering the instructions. This was causing DPaint4.1 
to hang when finishing an Anim
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.13 92/07/29 16:51:19 chrisg Exp Locker: spence $
d5 1
a5 1
*   $Locker: spence $
d108 5
a112 2
				must_do_colors++;
				((UWORD *)(cm->ColorTable))[v->ti_Data] &= 0x7fff;
d115 5
a119 2
				must_do_colors++;
				((UWORD *)(cm->ColorTable))[v->ti_Data] |= 0x8000;
d122 4
a125 2
				must_do_bplcon2++;
				cm->TransparencyPlane = v->ti_Data;
@


39.13
log
@made VTAG_IMMEDIATE call update_top_color.
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.12 92/07/21 14:47:38 spence Exp Locker: chrisg $
d5 1
a5 1
*   $Locker: chrisg $
d125 1
a125 1
				    if(cm->cm_vp = vp)
d131 1
@


39.12
log
@check if ColorMap is NULL when checking for must_remake
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.11 92/07/09 10:13:09 chrisg Exp Locker: spence $
d5 1
a5 1
*   $Locker: spence $
d449 1
@


39.11
log
@bplcon3 changes are immediate!
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.10 92/05/05 12:18:45 chrisg Exp Locker: chrisg $
d5 1
a5 1
*   $Locker: chrisg $
d437 1
a437 2
	must_remake=must_remake || must_do_bplcon2 || must_do_bplcon4 || (! cm->cm_vp);

@


39.10
log
@optimizations.
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.9 92/04/06 12:27:20 chrisg Exp Locker: chrisg $
d437 1
a437 1
	must_remake=must_remake || must_do_bplcon2 || must_do_bplcon3 || must_do_bplcon4 || (! cm->cm_vp);
d443 3
a445 3
	    if ((! must_remake) && (must_do_colors)) pokecolors(cm->cm_vp);
#if 0
		if ((! must_remake) && must_do_bplcon3)
d447 4
a450 7
			UWORD w=get_bplcon3(cm);
			kprintf("doing con3\n");
			ObtainSemaphore(GBASE->ActiViewCprSemaphore);
			pokeCprList(cm->cm_vp->DspIns->CopLStart,&custom.bplcon3,w);
			pokeCprList(cm->cm_vp->DspIns->CopSStart,&custom.bplcon3,w);
			pokeCopIns(cm->cm_vp->DspIns->CopIns,0,&custom.bplcon3,w);
			ReleaseSemaphore(GBASE->ActiViewCprSemaphore);
d452 3
a454 2
#endif
	}
@


39.9
log
@ removed debug.
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.8 92/04/04 14:35:50 chrisg Exp Locker: chrisg $
d18 1
a18 1
#include "/a/a.protos"
d170 1
a174 4
				else
				{
				    v->ti_Tag = VTAG_CHROMAKEY_CLR;
				}
d178 1
a182 4
				else
				{
				    v->ti_Tag = VTAG_BITPLANEKEY_CLR;
				}
d185 2
a186 1
				if(cm->Flags & BORDER_BLANKING)
a189 4
				else
				{
				    v->ti_Tag = VTAG_BORDERBLANK_CLR;
				}
d192 1
a196 4
				else
				{
				    v->ti_Tag = VTAG_BORDERNOTRANS_CLR;
				}
d210 1
a214 4
				else
				{
				    v->ti_Tag  = VTAG_BATCH_CM_CLR;
				}
d287 1
a291 4
				else
				{
				    v->ti_Tag = VTAG_USERCLIP_CLR;
				}
d341 1
a345 4
				else
				{
				    v->ti_Tag = VTAG_BORDERSPRITE_CLR;
				}
d374 1
a378 4
				else
				{
					v->ti_Data = 0x4;	/* default */
				}
d390 1
a393 4
				}
				else
				{
					v->ti_Data = 0x4;	/* default */
@


39.8
log
@ attemted to make bplcon3 updates VTAG_IMMEDIATE.
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.7 92/03/20 10:03:18 chrisg Exp Locker: chrisg $
d462 1
a462 1
	kprintf("make=%d con2=%d con4=%d cm->cm_vp=%08lx\n",must_remake,must_do_bplcon2,must_do_bplcon4,cm->cm_vp);
@


39.7
log
@added fullpalette and vtag_immediate
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.6 92/02/28 13:41:55 spence Exp Locker: chrisg $
d18 2
d23 2
a49 1
#define SPRITERESN_MASK	3
d236 1
a236 2
				cm->cm_batch_items = (struct TagItem *)
				v->ti_Data;
d375 5
a379 2
				if (AA_CHIPS)
				{ cm->SpriteResolution = (v->ti_Data & SPRITERESN_MASK); must_do_bplcon3++; }
d429 1
d441 13
d462 4
a465 1
	must_remake=must_remake || must_do_bplcon3 || must_do_bplcon2 || must_do_bplcon4 || (! cm->cm_vp);	/* can't do smart bplcon updates for now */
d471 12
@


39.6
log
@VTAG_PFx_TO_SPRITEPRI tags
Also, reversed swapped VTAG_PF1_BASE and VTAG_PF2_BASE because when in
single playfield mode, playfield 2 is displayed, not playfield 1.
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.5 92/02/25 14:29:36 spence Exp Locker: spence $
d5 1
a5 1
*   $Locker: spence $
d54 6
d71 2
d76 2
d81 1
d85 1
d89 1
d93 1
d97 1
d101 1
d105 1
d109 1
d113 1
d121 1
d146 1
d154 1
d163 1
d277 1
d289 1
d310 1
d314 1
d319 3
a321 1
				if (AA_CHIPS) cm->Bp_0_base=(UWORD) v->ti_Data;
d324 1
a324 1
				if (AA_CHIPS) cm->Bp_1_base=(UWORD) v->ti_Data;
d328 1
a328 1
				if (AA_CHIPS) cm->SpriteBase_Even=(UWORD) v->ti_Data;
d332 1
a332 1
				if (AA_CHIPS) cm->SpriteBase_Odd=(UWORD) v->ti_Data;
d339 1
d367 1
a367 1
				if (AA_CHIPS) cm->Flags |= BORDERSPRITES;
d370 1
a370 1
				cm->Flags &=  ~BORDERSPRITES;
d374 1
a374 1
					cm->SpriteResolution = (v->ti_Data & SPRITERESN_MASK);
d385 1
d403 1
d418 17
d441 5
a445 3
#ifdef  IMMEDIATE_MODE
	/* color map needs to be attached to make immediate changes */
	if (cm->cm_vp && (!(cm->Flags & VIDEOCONTROL_BATCH))) 
d447 2
a448 7
		struct GfxBase *GB;
		FETCHGBASE;
		/* chock full of race conditions */
		makevport(GB->ActiView,cm->cm_vp);
		mrgcop(GB->ActiView);
		waittof();
		loadview(GB->ActiView);
a449 1
#endif
@


39.5
log
@VTAG_SPRITERESN_[SET/GET]
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.4 92/01/21 13:35:22 chrisg Exp Locker: spence $
d291 1
a291 1
			case VTAG_PF1_BASE_SET:
d294 1
a294 1
			case VTAG_PF2_BASE_SET:
d306 4
a311 4
				v->ti_Data=cm->Bp_0_base;
				break;
			case VTAG_PF2_BASE_GET:
				v->ti_Tag = VTAG_PF2_BASE_SET;
d350 36
a385 1

@


39.4
log
@ Now use utility.library's tag functions
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.3 92/01/17 12:10:41 spence Exp Locker: chrisg $
d5 1
a5 1
*   $Locker: chrisg $
d46 1
a47 9
void reset_fmode(struct ColorMap *cm)
{
	struct ViewPortExtra *vpe = cm->cm_vpe;

	if (vpe)
		vpe->Flags &= ~VPXF_HAVE_FMODE;
}


a126 1
				reset_fmode(cm);
a133 1
				reset_fmode(cm);
d342 8
a349 1

@


39.3
log
@VecTable is attached to the cm->vpe by VTAG_VPMODEID_SET (was with
VTAG_VIEWPORTEXTRA_SET).
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.2 91/11/11 11:49:24 chrisg Exp Locker: spence $
d5 1
a5 1
*   $Locker: spence $
d18 2
d57 2
a58 2
struct ColorMap *cm;
struct TagItem *v;
d60 1
d66 2
a67 1
	while((!error) && v->ti_Tag)
a70 10
			/* handle system tags */
			case	TAG_IGNORE:
				break;
			case	TAG_MORE:
				v = (struct TagItem *)v->ti_Data;
				continue;
			case	TAG_SKIP:
				v += v->ti_Data;
				break;

d121 1
a121 3
				v = (struct TagItem *)v->ti_Data;
				v--;	/* back up here so we can just */
					/* keep incrementing at bottom */
a357 1
		v++;	/* to next video command */
@


39.2
log
@  updated and fixed chromapen support for new method.
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.1 91/10/18 16:27:32 spence Exp Locker: chrisg $
d5 1
a5 1
*   $Locker: chrisg $
a158 3
					struct ViewPort *vp = cm->cm_vp;
					ULONG ID;

a159 5
					if ((vp) && ((ID = GetVPModeID(vp)) != INVALID_ID))
					{
						AttachVecTable(cm->cm_vpe, NULL, ID);
					}
					break;
d268 12
a279 1
					cm->VPModeID = (ULONG)v->ti_Data;
d282 2
d285 6
@


39.1
log
@SET_VPEXTRA sets the ViewPortExtra->VecTable from the database
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 39.0 91/08/21 17:31:43 chrisg Exp Locker: spence $
d5 1
a5 1
*   $Locker: spence $
d21 2
d29 1
a29 1
    UWORD *p = cm->TransparencyBits;
d31 1
a31 1
    Forbid();
d34 1
a34 6
    {
	int bit_no = i & 15;
	UWORD mask = 0x8000;
	mask >>= bit_no;
	if(*(p+(i>>4)) & mask) num ++;
    }
d103 1
a103 9
				{
				    int pen_no = v->ti_Data;
				    int bit_no = pen_no & 15;
				    UWORD mask = 0x8000;
				    UWORD *p = cm->TransparencyBits;
				    mask >>= bit_no;
				    p += pen_no >> 4; /* bump to correct word */
				    *p &= ~mask;
				}
d106 1
a106 9
				{
				    int pen_no = v->ti_Data;
				    int bit_no = pen_no & 15;
				    UWORD mask = 0x8000;
				    UWORD *p = cm->TransparencyBits;
				    mask >>= bit_no;
				    p += pen_no >> 4; /* bump to correct word */
				    *p |= mask;
				}
d109 1
a109 4
				if( v->ti_Data < 6 ) /* 6,7 reserved for now */
				{
				    cm->TransparencyPlane = v->ti_Data;
				}
a159 1
					struct VecInfo vinfo;
d211 1
a211 16
				{
				    int pen_no = v->ti_Data;
				    int bit_no = pen_no & 15;
				    UWORD mask = 0x8000;
				    UWORD *p = cm->TransparencyBits;
				    mask >>= bit_no;
				    p += pen_no >> 4; /* bump to correct word */
				    if(*p & mask)
				    {
					v->ti_Tag = VTAG_CHROMA_PEN_SET;
				    }
				    else
				    {
					v->ti_Tag = VTAG_CHROMA_PEN_CLR;
				    }
				}
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*   $Id: videocontrol.c,v 38.0 91/07/27 17:05:57 spence Exp Locker: chrisg $
d5 1
a5 1
*   $Locker: chrisg $
d17 1
d180 12
a191 2
				cm->cm_vpe = (struct ViewPortExtra *)v->ti_Data;
				break;
@


38.0
log
@setting normal or coerced displayclip forces FMode to be recalculated
next time.
@
text
@d3 1
a3 1
*   $Id:  Exp $
d5 1
a5 1
*   $Locker:  $
@


37.3
log
@ added tags for new color base stuff.
@
text
@d1 8
d47 7
d164 1
d172 1
@


37.2
log
@Use protos. Registerized parameters. Removed compiler warnings
@
text
@d3 5
a7 5
#include <graphics/gfxbase.h>
#include <graphics/view.h>
#include <graphics/videocontrol.h>
#include <graphics/displayinfo.h>
#include	"d.protos"
d37 4
d307 54
@


37.1
log
@*** empty log message ***
@
text
@d7 1
d14 1
a14 1
num_chroma_pens(cm) 
@


37.0
log
@initial switchover from V36
@
text
@d7 1
a7 1
#include "../macros.h"
@


1.26
log
@user copper list clipping
@
text
@@


1.25
log
@id
@
text
@d286 16
@


1.24
log
@tags for vpmodeid control and system tags
@
text
@@


1.23
log
@*** empty log message ***
@
text
@d2 1
d6 1
d49 11
d276 10
d287 2
a288 1
				error = -3; /* error, unknown command */
@


1.22
log
@utility/tagitem
@
text
@@


1.21
log
@cm->Type checking
@
text
@@


1.20
log
@attach null cm->vp properly
@
text
@d40 2
a41 2
	if(!cm) error = -1; /* error, no colormap */
	if(!v ) error = -2; /* error, no tagitems */
@


1.19
log
@dont perform changes immediately
@
text
@d102 5
a106 2
					struct ViewPort *vp = 
					(struct ViewPort *)v->ti_Data;
a107 1
					/* remove old reference */
a108 1
					cm->cm_vp = vp;
d110 1
@


1.18
log
@genlock
@
text
@d267 1
a267 2
#define BATCH_MODE
#ifdef  BATCH_MODE
@


1.17
log
@*** empty log message ***
@
text
@d5 1
d38 1
a38 1
	if(!cm) return(-1); /* error */
d40 4
a43 1
	while (v->ti_Tag)
d59 1
a59 1
			case	VTAG_BRDRBLNK_CLR:
d62 1
a62 1
			case	VTAG_BRDRBLNK_SET:
d65 2
a66 2
			case	VTAG_BRDRTRANS_CLR:
				cm->Flags &= ~BORDER_TRANSPARENCY;
d68 2
a69 2
			case	VTAG_BRDRTRANS_SET:
				cm->Flags |=  BORDER_TRANSPARENCY;
d100 1
d110 1
d165 1
a165 1
			case	VTAG_BRDRBLNK_GET:
d168 1
a168 1
				    v->ti_Tag = VTAG_BRDRBLNK_SET;
d172 1
a172 1
				    v->ti_Tag = VTAG_BRDRBLNK_CLR;
d175 2
a176 2
			case	VTAG_BRDRTRANS_GET:
				if(cm->Flags & BORDER_TRANSPARENCY)
d178 1
a178 1
				    v->ti_Tag = VTAG_BRDRTRANS_SET;
d182 1
a182 1
				    v->ti_Tag = VTAG_BRDRTRANS_CLR;
d262 1
a262 1
				return (1);	/* error, no such command */
d266 3
d270 10
a279 2
#ifdef IMMEDIATE_CHANGES
	if (cm->cm_vp && (cm->Flags & VIDEOCONTROL_IMMEDIATE)) RemakeDisplay();
d281 2
a282 1
	return (0);	/* ok */
@


1.16
log
@*** empty log message ***
@
text
@d217 1
a217 1
				v->ti_Data = (ULONG)cm->cm_batch_items
d227 2
a228 1
				    struct TagItem *ti = vi->ti_Data;
d234 1
a234 1
					    ti = (struct TagItem *)ti->Data;
d238 1
a238 1
					    ti++
d241 1
a241 1
				    if(ti != vi->ti_Data) 
d244 2
a245 2
					ti->ti_Data = oi;
					ti = vi->ti_Data;
@


1.15
log
@*** empty log message ***
@
text
@d172 1
a172 1
				    v->ti_Tag = VTAG_BRDRTRANSSET;
d176 1
a176 1
				    v->ti_Tag = VTAG_BRDRTRANSCLR;
@


1.14
log
@videocontrol issues
@
text
@d13 16
a28 1
    return(0); 
a111 1
				Forbid();
d118 1
d125 1
d132 1
a215 1
				Forbid(); 
a217 1
				Permit();
a219 1
				Forbid(); 
a221 1
				Permit();
@


1.13
log
@checkpoint 02.14.89
@
text
@d6 1
a6 3
/* some of the commands maybe moved to a function called */
/* GlobalVideoControl since some of them have nothing to */
/* do with a particular ColorMap */
d8 8
d29 1
a29 1
				cm->Flags &= ~1;
d32 1
a32 1
				cm->Flags |= 1;
d35 1
a35 1
				cm->Flags &= ~2;
d38 1
a38 1
				cm->Flags |= 2;
d41 1
a41 6
				{
				    struct ViewExtra *ve = (struct ViewExtra *)
						      gfxlookup(v->ti_Data);
				    if (!ve)	return (2);
				    ve->ve_VideoFlags &= ~ve_BRDRBLNK;
				}
d44 1
a44 6
				{
				    struct ViewExtra *ve = (struct ViewExtra *)
						      gfxlookup(v->ti_Data);
				    if (!ve)	return (2);
				    ve->ve_VideoFlags |= ve_BRDRBLNK;
				}
d47 1
a47 6
				{
				    struct ViewExtra *ve = (struct ViewExtra *)
						      gfxlookup(v->ti_Data);
				    if (!ve)	return (2);
				    ve->ve_VideoFlags &= ~ve_BRDRNTRN;
				}
d50 1
a50 6
				{
				    struct ViewExtra *ve = (struct ViewExtra *)
						      gfxlookup(v->ti_Data);
				    if (!ve)	return (2);
				    ve->ve_VideoFlags |= ve_BRDRNTRN;
				}
d74 5
a78 1
			case	VTAG_CHROMA_PLANE:
d80 1
a80 1
			case	VTAG_ATTACH_CM:
d92 1
a92 1
				v = (struct VideoCommand *)v->ti_Data;
d97 2
a98 1
				cm->Flags &= ~4;
d101 1
a101 1
				cm->Flags |= 4;
d103 3
d109 2
a110 2
			case	VTAG_NORMAL_DISP_GET:
				v->ti_Data = (ULONG)cm->NormalDisplayInfo;
d115 2
a116 2
			case	VTAG_COERCE_DISP_GET:
				v->ti_Data = (ULONG)cm->CoerceDisplayInfo;
d121 10
a130 2
			case	VTAG_VIEWPORTEXTRA_GET:
				v->ti_Data = (ULONG)cm->cm_vpe;
d132 109
d247 2
a248 2
#ifdef QWE
	if ( cm->cm_vp && ((cm->Flags & 4)==0) )	RemakeDisplay();
@


1.12
log
@checkpoint -- a2024 10hz and 15hz scan works from 32 bit id
@
text
@@


1.11
log
@checkpoint 2024
@
text
@@


1.10
log
@viewportextra set/get
@
text
@@


1.9
log
@checkpoint 01.24.89
@
text
@a3 4

#define PROTOTYPE_DISPLAY
#ifdef  PROTOTYPE_DISPLAY

d124 2
a125 56
			default:
				return (1);	/* error, no such command */
		}
		v++;	/* to next video command */
	}
	/* color map needs to be attached to make immediate changes */
#ifdef QWE
	if ( cm->cm_vp && ((cm->Flags & 4)==0) )	RemakeDisplay();
#endif
	return (0);	/* ok */
}


#else

/* program to print colormap details */

#define END_CM		0	/* terminator for command list */
#define	CHROMAKEY	1	/* control colormap genlock enable */
#define	BITPLANEKEY	2	/* control bitplane genlock enable */
#define	BRDRBLNK	3
#define	BRDRTRANS	4
#define	CHROMA_PEN	5	/* control genlock for a pen # */
#define	CHROMA_PLANE	6	/* pick the genlock plane */
#define ATTACH_CM	7	/* attach colormap to viewport */
#define NEXTBUF_CM	8	/* jump to another buffer of commands */
#define BATCH_CM	9	/* delay system changes */
#define NORMAL_DISP	10	/* attach default displayinfo to viewport */
#define COERCE_DISP	11	/* attach coerced displayinfo to viewport */

struct VideoCommand
{
	UWORD 	command;
	UWORD 	sarg;
	ULONG	larg;
};

/* some of the commands maybe moved to a function called */
/* GlobalVideoControl since some of them have nothing to */
/* do with a particular ColorMap */

/* This function may then be renamed to LocalVideoControl */

long	videocontrol(cm,v)
struct ColorMap *cm;
struct VideoCommand *v;
{
	if(!cm) return(-1); /* error */

	while (v->command)
	{
		switch(v->command)
		{
			case	CHROMAKEY:
				if (v->sarg)	cm->Flags |= 1;
				else		cm->Flags &= ~1;
d127 2
a128 3
			case	BITPLANEKEY:
				if (v->sarg)	cm->Flags |= 2;
				else		cm->Flags &= ~2;
a129 74
			case	BRDRBLNK:
				{
					struct ViewExtra *ve = (struct ViewExtra *)
								gfxlookup(v->larg);
					if (!ve)	return (2);
					if (v->sarg) ve->ve_VideoFlags |= ve_BRDRBLNK;
					else	ve->ve_VideoFlags &= ~ve_BRDRBLNK;
				}
				break;
			case	BRDRTRANS:
				{
					struct ViewExtra *ve = (struct ViewExtra *)
								gfxlookup(v->larg);
					if (!ve)	return (2);
					if (v->sarg) ve->ve_VideoFlags |= ve_BRDRNTRN;
					else	ve->ve_VideoFlags &= ~ve_BRDRNTRN;
				}
				break;
			case	CHROMA_PEN:
				{
					int pen_no = v->larg;
					int bit_no = pen_no & 15;
					UWORD mask = 0x8000;
					UWORD *p = cm->TransparencyBits;
					mask >>= bit_no;
					p += pen_no >> 4;	/* bump to correct word */
					if (v->sarg)	*p |= mask;
					else		*p &= ~mask;
				}
				break;
			case	CHROMA_PLANE:
				break;
			case	ATTACH_CM:
				{
					struct ViewPort *vp = 
					(struct ViewPort *)v->larg;
					struct ColorMap *oldcm = vp->ColorMap;
					/* remove old reference */
					if (oldcm) oldcm->cm_vp = 0;
					cm->cm_vp = vp;
					vp->ColorMap = cm;
				}
				break;
			case	NEXTBUF_CM:
				v = (struct VideoCommand *)v->larg;
				v--;	/* back up here so we can just */
					/* keep incrementing at bottom */
				break;
			case	BATCH_CM:
				if (v->sarg)	cm->Flags |= 4;
				else		cm->Flags &= ~4;
				break;
			case	NORMAL_DISP:
				{
				    if (v->sarg)
				    {
					v->larg = (ULONG)cm->NormalDisplayInfo;
				    }
				    else
				    {
					cm->NormalDisplayInfo = (APTR)v->larg;
				    }
				} break;
			case	COERCE_DISP:
				{
				    if (v->sarg)
				    {
					v->larg = (ULONG)cm->CoerceDisplayInfo;
				    }
				    else
				    {
					cm->CoerceDisplayInfo = (APTR)v->larg;
				    }
				} break;
a140 2

#endif
@


1.8
log
@include <graphics/videocontrol.h>
@
text
@@


1.7
log
@*** empty log message ***
@
text
@d8 1
a8 24
#include <intuition/tagitem.h>

/* program to print colormap details */

#define	VTAG_END_CM		0x00000000	
#define	VTAG_CHROMAKEY_CLR	0x00010000	
#define	VTAG_CHROMAKEY_SET	0x00010001	
#define	VTAG_BITPLANEKEY_CLR	0x00020000	
#define	VTAG_BITPLANEKEY_SET	0x00020001	
#define	VTAG_BRDRBLNK_CLR	0x00030000
#define	VTAG_BRDRBLNK_SET	0x00030001
#define	VTAG_BRDRTRANS_CLR	0x00040000
#define	VTAG_BRDRTRANS_SET	0x00040001
#define	VTAG_CHROMA_PEN_CLR	0x00050000	
#define	VTAG_CHROMA_PEN_SET	0x00050001	
#define	VTAG_CHROMA_PLANE	0x00060000	
#define	VTAG_ATTACH_CM		0x00070000	
#define	VTAG_NEXTBUF_CM		0x00080000	
#define	VTAG_BATCH_CM_CLR	0x00090000	
#define	VTAG_BATCH_CM_SET	0x00090001	
#define	VTAG_NORMAL_DISP_SET	0x000A0000
#define	VTAG_NORMAL_DISP_GET	0x000A0001
#define	VTAG_COERCE_DISP_SET	0x000B0000
#define	VTAG_COERCE_DISP_GET	0x000B0001
@


1.6
log
@tag substitution for videocommand
@
text
@d8 2
@


1.5
log
@checkpoint 01.19.89 coercion down to default
@
text
@d5 3
d10 156
d295 2
@


1.4
log
@checkpoint 01.18.89
@
text
@@


1.3
log
@if(!cm) return(-1);
@
text
@@


1.2
log
@*** empty log message ***
@
text
@d37 2
@


1.1
log
@Initial revision
@
text
@d17 2
d22 3
a24 3
	unsigned short	command;
	unsigned short	sarg;
	unsigned long	larg;
d71 2
a72 2
					unsigned short mask = 0x8000;
					unsigned short *p = cm->TransparencyBits;
d83 2
a84 1
					struct ViewPort *vp = (struct ViewPort *)v->larg;
d87 1
a87 2
					if (oldcm)	oldcm->cm_vp = 0;
					vp->ColorMap = vp;
d101 22
@
