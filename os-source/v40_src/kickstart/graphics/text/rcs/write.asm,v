head     39.5;
branch   ;
access   ;
symbols  rel39_24:39.5 rel39_18:39.5 rel39_97:39.5 rel39_90:39.5 rel39_89:39.5 rel39_82:39.5 rel39_76:39.5 rel39_71:39.5 rel39_65:39.5 rel39_64:39.5 rel39_61:39.5 rel39_60:39.5 rel39_55:39.5 rel39_47:39.3 rel39_39:39.2 rel39_38:39.2 rel39_37:39.2 rel39_35:39.2 rel39_34:39.2 V37_30:37.3 V37_29:37.3 V37_28:37.3 V37_25:37.3 V37_22:37.3 V37_21:37.3 V37_20:37.3 V37_19:37.3 V37_17:37.3 V37_15:37.3 V37_14:37.3 V37_13:37.2 V37_12:37.2 V37_11:37.2 V37_10:37.2 V37_9:37.2 V37_7:37.2 V37_6:37.2 V37_5:37.1 V37_4:37.1 V37_3:37.1 V37_2:37.0 V37_1:37.0 V36_209:36.21 V36_208:36.21 V36_207:36.21 V36_205:36.21 V36_203:36.21 V36_202:36.21 V36_201:36.21 V36_200:36.21 V36_199:36.21 V36_198:36.21 V36_196:36.21 V36_195:36.21 V36_194:36.21 V36_193:36.21 V36_192:36.21 V36_191:36.21 V36_190:36.21 V36_189:36.21 V36_188:36.21 V36_187:36.21 V36_186:36.21 V36_185:36.21 V36_184:36.20 V36_183:36.20 V36_182:36.20 V36_181:36.20;
locks    ; strict;
comment  @*   @;


39.5
date     92.04.09.10.06.27;  author chrisg;  state Exp;
branches ;
next     39.4;

39.4
date     92.04.08.11.32.09;  author spence;  state Exp;
branches ;
next     39.3;

39.3
date     92.03.19.16.32.48;  author chrisg;  state Exp;
branches ;
next     39.2;

39.2
date     92.02.10.14.43.07;  author chrisg;  state Exp;
branches ;
next     39.1;

39.1
date     92.01.30.15.34.48;  author chrisg;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.37.08;  author chrisg;  state Exp;
branches ;
next     37.3;

37.3
date     91.02.12.15.52.48;  author spence;  state Exp;
branches ;
next     37.2;

37.2
date     91.01.25.17.25.33;  author spence;  state Exp;
branches ;
next     37.1;

37.1
date     91.01.18.17.19.51;  author spence;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.29.16;  author spence;  state Exp;
branches ;
next     36.21;

36.21
date     90.09.27.11.30.43;  author bart;  state Exp;
branches ;
next     36.20;

36.20
date     90.06.11.15.51.40;  author kodiak;  state Exp;
branches ;
next     36.19;

36.19
date     90.05.21.21.37.14;  author kodiak;  state Exp;
branches ;
next     36.18;

36.18
date     90.05.10.15.36.49;  author kodiak;  state Exp;
branches ;
next     36.17;

36.17
date     90.04.24.10.47.09;  author kodiak;  state Exp;
branches ;
next     36.16;

36.16
date     90.04.13.11.52.36;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     90.04.02.13.00.54;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     90.02.18.21.07.35;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     90.01.29.11.39.16;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     90.01.23.16.56.47;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     90.01.09.17.54.20;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     89.11.22.16.53.58;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     89.11.02.18.37.56;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     89.06.29.11.44.14;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     89.06.08.14.22.11;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     89.06.05.14.16.04;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.05.05.11.24.58;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     88.07.14.14.57.51;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     88.04.13.14.46.09;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     88.04.13.13.28.34;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     88.03.11.09.56.19;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     88.03.06.11.02.12;  author kodiak;  state Exp;
branches ;
next     35.5;

35.5
date     87.12.03.12.59.29;  author kodiak;  state Exp;
branches ;
next     35.4;

35.4
date     87.11.24.17.57.03;  author kodiak;  state Exp;
branches ;
next     35.3;

35.3
date     87.11.17.14.49.24;  author kodiak;  state Exp;
branches ;
next     35.2;

35.2
date     87.11.11.14.42.24;  author kodiak;  state Exp;
branches ;
next     35.1;

35.1
date     87.10.19.16.28.00;  author kodiak;  state Exp;
branches ;
next     35.0;

35.0
date     87.10.19.16.20.23;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


39.5
log
@ ifdef'd out 020 text code. :-(.
@
text
@**
**	$Id: write.asm,v 39.4 92/04/08 11:32:09 spence Exp Locker: chrisg $
**
**      text write primitive
**
**      (C) Copyright 1985,1987,1989 Commodore-Amiga, Inc.
**          All Rights Reserved
**

	SECTION		graphics

*------ Included Files -----------------------------------------------

	INCLUDE		"exec/types.i"
	INCLUDE		"exec/nodes.i"
	INCLUDE		"exec/lists.i"
	INCLUDE		"exec/ports.i"
	INCLUDE		"exec/libraries.i"
	INCLUDE		"exec/memory.i"
	INCLUDE		"exec/alerts.i"
	include		"exec/execbase.i"

	INCLUDE		"text.i"

	INCLUDE		"graphics/gfx.i"
	INCLUDE		"graphics/clip.i"
	INCLUDE		"graphics/rastport.i"
	INCLUDE		"graphics/gfxbase.i"

	INCLUDE		"hardware/blit.i"

	INCLUDE		"txtdata.i"
	INCLUDE		"macros.i"
	include	"/macros.i"

	IFNE		rp_Layer
	FAIL		"recode rp_Layer instructions"
	ENDC

*------ Imported Names -----------------------------------------------

	XREF		FreeMustMem
	XREF		GetMustMem
	XREF		textLength
	XREF		waitblitdone

	XREF		_lwmaskTable

	XLVO	AllocMem		; Exec
	XLVO	FreeMem			;

	XLVO	BltBitMap		; Graphics
	XLVO	BltBitMapRastPort	;
	XLVO	BltMaskBitMapRastPort	;
	XLVO	BltClear		;
	XLVO	BltTemplate		;
	XLVO	LockLayerRom		;
	XLVO	UnlockLayerRom		;


*------ Exported Names -----------------------------------------------

*------ Functions ----------------------------------------------------

	XDEF		_Text


******* graphics.library/Text ****************************************
*
*   NAME
*	Text -- Write text characters (no formatting).
*
*   SYNOPSIS
*	Text(rp, string, length)
*	     A1  A0      D0-0:16
*
*	void Text(struct RastPort *, STRPTR, WORD);
*
*   FUNCTION
*	This graphics function writes printable text characters to the
*	specified RastPort at the current position.  No control meaning
*	is applied to any of the characters, thus only text on the
*	current line is output.
*
*	The current position in the RastPort is updated to the next
*	character position.
*	If the characters displayed run past the RastPort boundary,
*	the current position is truncated to the boundary, and
*	thus does not equal the old position plus the text length.
*
*   INPUTS
*	rp     - a pointer to the RastPort which describes where the
*	         text is to be output
*	string - the address of string to output
*	length - the number of characters in the string.
*	         If zero, there are no characters to be output.
*
*   NOTES
*	o   This function may use the blitter.
*	o   Changing the text direction with RastPort->TxSpacing is
*	    not supported.
*
*   BUGS
*	For V34 and earlier:
*	o   The maximum string length (in pixels) is limited to
*	    (1024 - 16 = 1008) pixels wide.
*	o   A text string whose last character(s) have a
*	    tf_CharLoc size component that extends to the right of
*	    the rightmost of the initial and final CP positions
*	    will be (inappropriately) clipped.
*
*   SEE ALSO
*	Move()  TextLength()  graphics/text.h  graphics/rastport.h
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*	Text is drawn by taking the byte data in a string and using
*	it as an index into font data.	The byte data may range from
*	0-255.
*
*	A font will have the following characteristics:
*	  - fast and efficient access to the data to draw a character
*	  - support for proportional spacing and kerning
*	  - compact data representation of characters
*	  - easy to manipulate to create new "constructed" fonts
*	  - able to represent characters that are 1K by 1K
*	  - special "fast" support structure for byte-wide fonts
*
*	Text that is drawn will have the standard graphics attributes,
*	i.e. color, drawing mode, write mask, bounds and clipping, as
*	well as the text specific attributes, i.e. reverse video,
*	underline, font, and optionally blinking.  Other attributes
*	often associated with text, such as bold and italic, will be
*	implemented via alternate fonts, which may be either designed
*	as a specific family, or constructed algorithmically from a
*	base font.
*
*	Text can be drawn in any drawing mode, but one color mode is
*	suggested:  Text fonts can have non-spacing characters or
*	characters that kern, which, when the text is output a
*	character at a time in either two color or xor mode, can cause
*	incorrect results at the overlap.  This does not happen,
*	however, when such characters are all output in the same
*	string: the characters are then formed in a temporary buffer
*	using one color mode, then the entire string is written to
*	the RastPort, so overlap among those characters is as if the
*	string were written in one color mode, regardless.
*
*	The temporary buffer is equal in size to (the height of the
*	font + 1) * (width of the RastPort + (height/2) + boldSmear)
*	so the characters can grow either to the left or right of the
*	CP and have algorithmic enhancements performed en masse.
*
*---------------------------------------------------------------------
 STRUCTURE  TW,0
	WORD	TW_LENGTH
	APTR	TW_STRING
	WORD	TW_CP
	WORD	TW_MAX
	WORD	TW_MIN
	WORD	TW_FONTDEPTH		; only used for colorFont
	WORD	TW_OFFSETX0		;
	WORD	TW_OFFSETBM		;
	WORD	TW_OFFSETCHAR		;
	LONG	TW_TEMPLATESIZE		; for each plane
	STRUCT	TW_BITMAP,bm_SIZEOF
	STRUCT	TW_EXTRABITMAP,bm_SIZEOF
	LABEL	TW_SIZE

;
;   d7	length parameter
;
;   a2	TextFont of RastPort
;   a3	string parameter
;   a4	RastPort parameter
;   a5	local variables (TW structure)
;   a6	GfxBase
;   a7	stack pointer
;
_Text:
		movem.l d2-d7/a2-a5,-(a7)

	    ;-- save the text parameters
		tst.w	d0			; check length
		beq	endText			; if no data, return

	    ;-- check if need to lock layer
		move.l	(a1),d1			; rp_Layer
		beq.s	getLength
		move.l	d1,a5
		CALLLVO LockLayerRom		; preserves d0/d1/a0/a1

getLength:
	    ;-- get length of this string
		movem.l	d0/a0/a1,-(a7)
		bsr	textLength		; may destroy d0-d7/a0-a5
						; length in d0
						; max in d1
						; min in d2

		movem.l	(a7)+,d7/a3/a4		; from d0/a0/a1

	    ;-- reserve space for local variables
		suba.w	#TW_SIZE,a7
		move.l	a7,a5

		move.b	#1,TW_BITMAP+bm_BytesPerRow(a5)

	    ;-- initialize variables
		movem.w	d0/d1/d2,TW_CP(a5)	; MAX, and MIN


		move.l	rp_Font(a4),a2		; get the current font

		;-- preclip
		move.l	(a4),d3			; rp_Layer
		beq.s	noPreclip

		move.l	d3,a0

		;--	if super bit map exists, then assume no preclip
		tst.l	lr_SuperClipRect(a0)
		bne.s	noPreclip

		;--	calculate text box in d4,d5 d6,a1
		move.w	rp_cp_x(a4),d4
		add.w	lr_MinX(a0),d4
		sub.w	lr_Scroll_X(a0),d4
		move.w	rp_cp_y(a4),d5
		add.w	lr_MinY(a0),d5
		sub.w	lr_Scroll_Y(a0),d5
		move.w	d4,d6
		add.w	d2,d4
		add.w	d1,d6
		sub.w	tf_Baseline(a2),d5
		move.w	d5,a1
		add.w	tf_YSize(a2),a1
		lea	lr_ClipRect(a0),a0

		;--	cycle for all ClipRects
preclipClipRect:
		move.l	(a0),d3			; cr_Next
		beq	freeLocal
		move.l	d3,a0

		cmp.w	cr_MaxX(a0),d4
		bgt.s	preclipClipRect
		cmp.w	cr_MinX(a0),d6
		blt.s	preclipClipRect

		cmp.w	cr_MaxY(a0),d5
		bgt.s	preclipClipRect
		cmp.w	cr_MinY(a0),a1
		blt.s	preclipClipRect
		tst.l	cr_lobs(a0)
		beq.s	noPreclip
		tst.l	cr_BitMap(a0)
		beq.s	preclipClipRect

noPreclip:

;
;  d2	MIN
;  d3	TW_BITMAP+bm_BytesPerRow
;  d5.b	byteCase if non-zero
;  d6	YSize
;  a1	TEMPLATE
;
		move.w	tf_YSize(a2),d6		; cache YSize
		beq	freeLocal		; no height => no rendering

	;-- get template

		;-- bm_BytesPerRow is based on rendering length
		move.w	d1,d3			; MAX
		sub.w	d2,d3			;     - MIN
		beq	freeLocal		; no width => no rendering
		moveq	#0,d5

		;-- check quickly if this font has been compiled yet
		move.l	tf_Extension(a2),d1
		beq		notByteModulo
		move.l	d1,a0
		cmp.w   #TE_MATCHWORD,(a0)      ; tfe_MatchWord(a0)
		bne		notByteModulo
		cmp.l   tfe_BackPtr(a0),a2
		bne.s	notByteModulo

		;-- check for byte font special case
		btst	#TE0B_BYTECELL,tfe_Flags0(a0)
		beq.s	notByteModulo
		tst.w	rp_TxSpacing(a4)
		bne.s	notByteModulo
		move.b	rp_AlgoStyle(a4),d5
		andi.b	#FSF_ITALIC+FSF_BOLD+FSF_UNDERLINED,d5
		bne.s	notByteModulo

	    ;-- byte font special case
		addq.w	#8,d3			; round up to even bytes
		bsr.s	getTemplate
		tst.l	d1
		beq.s	LowMemText
		move.l	a1,TW_EXTRABITMAP+bm_Planes(a5)
		bsr	waitblitdone
		bra	bInitialization

* LowMemText - GetMustMem() no longer GURUs, but returns NULL in no-mem
* situations. As an alternative to the GURU, Text() should now try to
* write each character one at a time. This may produce a differently
* rendered text ('cos of kerning), but WTF, we've no memory!!
*
* Call Text() (recursively) one character at a time. The only way
* Text() can now fail is if a single character is larger than
* MAXBYTESPERROW (= 4096 bytes). That's a pretty big font to fail,
* eg 256 * 128 pixels
*
* - spence Jan 16 1991

LowMemText:
*	d7:16 = length
*	a4	-> rp
*	a3	-> string 
		subq.w	#1,d7
		beq		_Text.			; one character is too big! exit quietly.
LowMemTextloop:
		subq.l	#2,sp			; keep it aligned for normal stack usage
		move.b	(a3)+,(sp)		; use stack as string pointer, for 1 char at a time
		move.l	sp,a0
		move.l	a4,a1			; rastport
		moveq	#1,d0			; string length
		bsr		_Text			; recurse
		addq.l	#2,sp
LowMemTextdbra:
		dbra	d7,LowMemTextloop
		bra		_Text.
	
	    ;-- shared code to get template
getTemplate:
		lsr.w	#4,d3			; converted to words
		add.w	d3,d3			; converted to bytes
		move.w	d3,TW_BITMAP+bm_BytesPerRow(a5)

		;-- get template size
		move.w	d6,d0			; get height
		mulu	d3,d0			; get the total needed size
		move.l	d0,TW_TEMPLATESIZE(a5)

		;-- get the template
		move.l	rp_TmpRas(a4),d1
		beq.s	needTemplate
		move.l	d1,a0
		move.l	tr_RasPtr(a0),d1
		beq.s	needTemplate
		cmp.l	tr_Size(a0),d0
		ble.s	cacheTAddr

		;-- no template or not big enough
needTemplate:
		moveq	#MEMF_CHIP,d1
		bsr	GetMustMem		; returns OK or alerts
		move.l	d0,d1

cacheTAddr:
		move.l	d1,a1
		move.l	a1,TW_BITMAP+bm_Planes(a5)
		rts


	    ;-- non-byte case, or byte case w/ spacing or algorithmic
notByteModulo:
		add.w	#79,d3			; round up to word + 4 word pad
		add.w	tf_Baseline(a2),d3
		btst.b	#FSB_COLORFONT,tf_Style(a2)
		bne	colorFont
notColorFont:
		bsr.s	getTemplate
		tst.l	d1
		beq.s	LowMemText

		;-- get TW_EXTRABITMAP+bm_Planes address based on MIN
		sub.w	tf_Baseline(a2),d2
		move.w	d2,d0			; MIN
		asr.w	#4,d0			; get offset word
		add.w	d0,d0			;   in bytes
		neg.w	d0			;
		lea	4(a1,d0.w),a0		; pad with 2 words
		move.l	a0,TW_EXTRABITMAP+bm_Planes(a5)	; thus X=0 is here

		tst.b	d5
		beq	notByteCode

	;-- special case byte fonts
;   d1	tf_LoChar
;   d2	tf_YSize-1 (dbf copy count)
;   d3	TW_BITMAP+bm_BytesPerRow
;   d4	font modulo
;   d5	character index
;   d6	tf_HiChar
;   d7	chars to output
;
;   a2	tf_CharData
;   a4	tf_CharLoc
;   a5	CP (byte address in template)
;   a6  initial loop entry
;

bClearTemplate:
	    ;-- clear the template plane for use
		move.w	d6,d0			; get height
		swap	d0			;   (in high word)
		move.w	d3,d0			; and width
		moveq	#3,d1			; synchronous clear,
						; row/word count
		CALLLVO BltClear

bnoclear:
		move.l	TW_EXTRABITMAP+bm_Planes(a5),a1	; CP (byte address)

bInitialization:
		movem.l	a2/a4/a5/a6,-(a7)
		;-- calculate bLoop entry offset
		move.w	d6,d2
		subq.w	#1,d2
		move.w	d2,d0
		and.w	#7,d0			; note high byte is cleared
		move.b	bLoopOffsets(pc,d0.w),d0
		lea	bHunkStart(pc,d0.w),a6
		;-- get DBF counter
		lsr.w	#3,d2
		;-- initialize other registers
		subq.w	#1,d7			; adjust length for dbf
		move.b	tf_HiChar(a2),d6
		move.w	tf_Modulo(a2),d4
		move.b	tf_LoChar(a2),d1
		move.l	tf_CharLoc(a2),a4
		move.l	tf_CharData(a2),a2
		move.l	a1,a5			; CP (byte address)

bCharLoop:
		moveq	#0,d5
		move.b	(a3)+,d5		; get next character in string
		cmp.b	d6,d5			; check character range
		bhi.s	bUnKnownRC
		sub.b	d1,d5
		bcc.s	bKnownRC

	    ;-- the character code is not in the font, use last char + 1
bUnKnownRC:
		move.b	d6,d5  			 ;get last character
		sub.b	d1,d5
		addq.w	#1,d5

bKnownRC:
	    ;-- find character data start and size
		add.w	d5,d5
		add.w	d5,d5
		move.w	0(a4,d5.w),d0
		lsr.w	#3,d0			; get start byte offset
		lea	0(a2,d0.w),a1		; character data start byte

		move.l	a5,a0			; template starting address
		move.w	d2,d0			; line dbf count
		jmp	(a6)

bLoopOffsets:
		dc.b	42,36,30,24,18,12,6,0
		ds.w	0


bLoop:
		adda.w	d4,a1
		adda.w	d3,a0
bHunkStart:
		move.b	(a1),(a0)		; remainder 0
		adda.w	d4,a1			; bump char data by it's modulo
		adda.w	d3,a0			; bump template by it's modulo
bHunkMark:
		move.b	(a1),(a0)		; remainder 7
		adda.w	d4,a1
		adda.w	d3,a0
		move.b	(a1),(a0)		; remainder 6
		adda.w	d4,a1
		adda.w	d3,a0
		move.b	(a1),(a0)		; remainder 5
		adda.w	d4,a1
		adda.w	d3,a0
		move.b	(a1),(a0)		; remainder 4
		adda.w	d4,a1
		adda.w	d3,a0
		move.b	(a1),(a0)		; remainder 3
		adda.w	d4,a1
		adda.w	d3,a0
		move.b	(a1),(a0)		; remainder 2
		adda.w	d4,a1
		adda.w	d3,a0
		move.b	(a1),(a0)		; remainder 1
		dbf	d0,bLoop

	    ;-- get next character
		addq.w	#1,a5			; update CP byte address
		dbf	d7,bCharLoop

		movem.l	(a7)+,a2/a4/a5/a6
		bra	chkBold

	IFNE	bHunkMark-bHunkStart-6
	FAIL	"bHunk not 6 bytes long, recode bLoopOffsets"
	ENDC

;
;   d5	character index
;

notByteCode:

; now, call special 020 code
;		move.l	gb_ExecBase(a6),a0
;		btst	#AFB_68020,AttnFlags+1(a0)	; 68020 or above for bitfield instructions?
;		bne	special_020_text

	    ;-- clear the template plane for use
non_68020:
		move.w	d6,d0			; get height
		swap	d0			;   (in high word)
		move.w	d3,d0			; and width
		moveq	#3,d1			; synchronous clear,
						; row/word count
		CALLLVO BltClear

;-- save registers used for other things here
		move.w	d7,TW_LENGTH(a5)
		move.l	a3,TW_STRING(a5)
		clr.w	TW_CP(a5)

nbCharLoop:
		moveq	#0,d5
		move.l	TW_STRING(a5),a0
		move.b	(a0)+,d5    ;get next character in string
		move.l	a0,TW_STRING(a5)
		cmp.b	tf_HiChar(a2),d5   ;check character range
		bhi.s	nbUnKnownRC
		sub.b	tf_LoChar(a2),d5
		bcc.s	nbKnownRC

	    ;-- the character code is not in the font, use last char + 1
nbUnKnownRC:
		move.b	tf_HiChar(a2),d5   ;get last character
		sub.b	tf_LoChar(a2),d5
		addq.w	#1,d5

	    ;-- get start position of character
nbKnownRC:
		add.w	d5,d5
		move.w	TW_CP(a5),d3
		move.l	tf_CharKern(a2),d0
		beq.s	nbGotNear
		move.l	d0,a0
		add.w	0(a0,d5.w),d3
nbGotNear:
		move.w	d3,d7			; save CP of char start
		move.l	tf_CharSpace(a2),d0
		bne.s	nbGotFar
		add.w	tf_XSize(a2),d3
		bra.s	nbSpacing
nbGotFar:
		move.l	d0,a0
		add.w	0(a0,d5.w),d3
nbSpacing:
		add.w	rp_TxSpacing(a4),d3

	    ;-- save CP
		move.w	d3,TW_CP(a5)

	    ;-- find character data start and size
		add.w	d5,d5
		move.l	tf_CharLoc(a2),a0
		move.l	0(a0,d5.w),d0
		move.w	d0,d5	    ;character data bit length
		beq	checkDoneRendering
		swap	d0
		move.w	d0,d3
		and.w	#$0F,d3			; character data start bit
		lsr.w	#4,d0			; (always positive)
		add.w	d0,d0			;   even word address
		move.l	tf_CharData(a2),a1
		add.w	d0,a1			; character data start word
		move.w	tf_Modulo(a2),a3

	    ;-- get number of lines to copy
		move.w	tf_YSize(a2),d6

	    ;--	calculate the 32 bit mask
		move.w	d5,d0
		subq.w	#1,d0			; make 16 fast?
		and.w	#15,d0			; get number of bits to save
		add.w	d0,d0			; word index
		lea	_lwmaskTable,a0
		move.w	0(a0,d0.w),d4		; 1 = first entry
		swap	d4
		clr.w	d4
		lsr.l	d3,d4			; shift into position

	    ;-- calculate start line position
		move.w	d7,d0
		andi.w	#$0F,d7	    ;get line buffer starting bit position
		asr.w	#4,d0	    ;get line buffer starting byte offset
		add.w	d0,d0	    ;  then word offset
		move.l	TW_EXTRABITMAP+bm_Planes(a5),a0  ;get word address
		add.w	d0,a0	    ;line buffer starting word address
		move.w	TW_BITMAP+bm_BytesPerRow(a5),a2

	    ;-- check for characters no wider than 16 bits
		cmp.w	#16,d5
		bls.s	thinCopy

	    ;-- calculate additional variables for wide characters
		move.l	#$ffff0000,d2		; intermediate mask
		lsr.l	d3,d2
		sub.w	#17,d5			; fix up width dbf counter
		lsr.w	#4,d5
		move.w	d5,d0			; fix up modulos
		add.w	d0,d0
		addq.w	#2,d0
		sub.w	d0,a2
		sub.w	d0,a3
;
;  d0	 **
;  d1	  *
;  d2	>  mask associated with char data (longword)
;  d3	  *start bit associated with char data (0-15)
;  d4	   mask associated with last word of char data (longword)
;  d5	>  dbf counter for intermediate char words
;  d6	  *counter for height (tf_YSize)
;  d7	   start bit associated with CP (0-15)
;  a0	 **template initial longword address
;  a1	 **character data initial longword address
;  a2	   template adjusted modulo
;  a3	   font adjusted modulo
;	>  =only in wideCopy
;	 **=destroyed
;
wideCopy:
		sub.w	d7,d3
		bge.s	wideLeft
		neg.w	d3
		bra.s	wideRight
wideRightLoop:
		move.l	(a1),d0
		and.l	d2,d0
		lsr.l	d3,d0
		or.l	d0,(a0)
		addq.l	#2,a1
		addq.l	#2,a0
		dbf	d1,wideRightLoop

		move.l	(a1),d0
		and.l	d4,d0
		lsr.l	d3,d0
		or.l	d0,(a0)

		adda.w	a3,a1		; bump char data by it's modulo
		adda.w	a2,a0		; bump template by it's modulo
wideRight:
		move.w	d5,d1		; initialize x counter
		dbf	d6,wideRightLoop
		bra.s	checkDoneRendering

wideLeftLoop:
		move.l	(a1),d0
		and.l	d2,d0
		lsl.l	d3,d0
		or.l	d0,(a0)
		addq.l	#2,a1
		addq.l	#2,a0
		dbf	d1,wideLeftLoop

		move.l	(a1),d0
		and.l	d4,d0
		lsl.l	d3,d0
		or.l	d0,(a0)

		adda.w	a3,a1		; bump char data by it's modulo
		adda.w	a2,a0		; bump template by it's modulo
wideLeft:
		move.w	d5,d1		; initialize x counter
		dbf	d6,wideLeftLoop
		bra.s	checkDoneRendering


thinCopy:
		sub.w	d7,d3
		bge.s	thinLeft
		neg.w	d3
		bra.s	thinRight
thinRightLoop:
		move.l	(a1),d0
		and.l	d4,d0
		lsr.l	d3,d0
		or.l	d0,(a0)

		adda.w	a3,a1		; bump char data by it's modulo
		adda.w	a2,a0		; bump template by it's modulo
thinRight:
		dbf	d6,thinRightLoop
		bra.s	checkDoneRendering

thinLeftLoop:
		move.l	(a1),d0
		and.l	d4,d0
		lsl.l	d3,d0
		or.l	d0,(a0)

		adda.w	a3,a1		; bump char data by it's modulo
		adda.w	a2,a0		; bump template by it's modulo
thinLeft:
		dbf	d6,thinLeftLoop

checkDoneRendering:
		move.l	rp_Font(a4),a2
		subq.w	#1,TW_LENGTH(a5)
		bne	nbCharLoop
;		bra.s	chkBold


    ;-- character loop is done

chkBold:
	;-- check bold enhancement
		btst	#FSB_BOLD,rp_AlgoStyle(a4) ;bold text?
		beq.s	chkItalic
	;-- embolden the data in the buffer
		move.w	tf_BoldSmear(a2),d1
		cmp	#16,d1
		bgt.s	must_make_really_bold
		move.l	TW_BITMAP+bm_Planes(a5),a0
		move.l	TW_TEMPLATESIZE(a5),d0
		lsr.l	#1,d0		; fix size for word count,
		subq.l	#2,d0		;   DBF, & not last word
		moveq	#0,d3
		move.w	(a0)+,d3

emboldenLoop:
		swap	d3
		move.l	d3,d2
		lsr.l	d1,d2
		moveq	#0,d3
		move.w	(a0)+,d3
		or.l	d2,-4(a0)
		dbf	d0,emboldenLoop
		bra.s	chkItalic
must_make_really_bold:
		movem.l	a2/d2-d7,-(a7)
		lea	TW_BITMAP(a5),a0	; srcbm
		move.l	a0,a1			; destbm
		moveq	#0,d0			; srcx
		move.w	d1,d2			; destx
		moveq	#0,d1			; srcy
		moveq	#0,d3			; desty
		move.w	bm_BytesPerRow(a0),d4
		lsl.w	#3,d4
		sub.w	d2,d4			; width
		move.w	tf_YSize(a2),d5		; sizey
		move.w	#$e5,d6			; minterm
		moveq	#1,d7
		sub.l	a2,a2
		jsr	_LVOBltBitMap(a6)
		movem.l	(a7)+,a2/d2-d7
chkItalic:
	;-- check italic enhancement
		btst	#FSB_ITALIC,rp_AlgoStyle(a4) ;italic text?
		beq.s	chkUnderline

	;-- italicize the data in the buffer
	    ;-- initialize variables to point to baseline
		move.l	TW_BITMAP+bm_Planes(a5),a0
		move.w	tf_Baseline(a2),d0
		move.w	d0,d6		; save baseline for later
		addq.w	#1,d0		; at the end of the line
		mulu	TW_BITMAP+bm_BytesPerRow(a5),d0
		add.l	d0,a0
		move.l	a0,a1		; generate start for right shift
		addq.w	#1,d6		; BaseLine + 1
		move.w	tf_YSize(a2),d5 ; generate number of left shift
		sub.w	d6,d5		;   lines
		blt.s	chkUnderline	; bad BaseLine!

		moveq	#1,d1		; starts shifted below baseline
		move.w	TW_BITMAP+bm_BytesPerRow(a5),d7
		lsr.w	#1,d7
		subq.w	#1,d7
		move.w	d7,-(sp)
		bra.s	startLShift
shiftLeft:
		move.w	(sp),d7		; recover the count
		addq.w	#1,d1		; increment count away from baseline
		;-- first, DBF, and last word not counted
		move.w	d1,d2		; move count into halvsies register
		lsr.w	#1,d2		; get half of baseline distance
		move.w	d2,d3		; clone distance
		andi.w	#$0F,d2		;   extract bit part
		lsr.w	#4,d3		;   extract word offset
		add.w	d3,d3		;     (which is really a byte offset)
shiftLLine:
		move.l	0(a0,d3.w),d0	; get longword to shift
		lsl.l	d2,d0		; shift longword
		swap	d0		; get the complete word portion
		move.w	d0,(a0)+	;   update word in shifted position
		dbf	d7,shiftLLine	;

startLShift:
		dbf	d5,shiftLeft	


		moveq	#-1,d1		; starts at baseline
		bra.s	startRShift
shiftRight:
		move.w	(sp),d7
		addq.w	#1,d1		; increment count away from baseline
		;-- first, DBF, and last word not counted
		;-- get shift and offset
		move.w	d1,d2		; move count into halvsies register
		lsr.w	#1,d2		; get half of baseline distance
		move.w	d2,d3		; clone distance
		andi.w	#$0F,d2		;   extract bit part
		lsr.w	#4,d3		;   extract word offset
		add.w	d3,d3		;     (which is really a byte offset)
		neg.w	d3		;     to the right is lower addresses
shiftRLine:
		move.l	-4(a1,d3),d0	; get longword to shift
		lsr.l	d2,d0		; shift longword
		move.w	d0,-(a1)	;   update word in shifted position
		dbf	d7,shiftRLine	;

startRShift:
		dbf	d6,shiftRight	
		addq.l	#2,sp

chkUnderline:
	;-- check underline enhancement
		btst	#FSB_UNDERLINED,rp_AlgoStyle(a4) ;underlined text?
		beq.s	templateOut
	;-- underline the data in the buffer
	    ;-- initialize variables to point to baseline
		move.l	TW_BITMAP+bm_Planes(a5),a0
		;------ underline under the baseline
		move.w	tf_Baseline(a2),d0
		addq.w	#1,d0		;the template starts one line down
		cmp.w	tf_YSize(a2),d0
		bge.s	templateOut

		mulu	TW_BITMAP+bm_BytesPerRow(a5),d0
		add.l	d0,a0
		move.l	a0,a1
		bsr.s	underlineA0

	;-- output the buffer data to the raster
;	BltTemplate(source, srcX, srcMod, destRastPort,
;		    a0	    d0	  d1	  a1
;		    destX,  destY, sizeX, sizeY),  graphicsLib
;		    d2	    d3	   d4	  d5	   a6
;
templateOut:

		move.l	TW_EXTRABITMAP+bm_Planes(a5),a0	; srcTemplate

		move.l	a4,a1			; destRastPort

		move.w	TW_MIN(a5),d0		; srcX

		move.w	TW_BITMAP+bm_BytesPerRow(a5),d1	; srcMod

		move.w	rp_cp_x(a4),d2		; get destX
		add.w	d0,d2			; adjusted for srcX

		move.w	rp_cp_y(a4),d3		; get destY
		sub.w	tf_Baseline(a2),d3	;   adjusted for even baselines

		move.w	TW_MAX(a5),d4		; get sizeX
		sub.w	d0,d4

		move.w	tf_YSize(a2),d5		; get sizeY

		CALLLVO BltTemplate

	;-- free the template if required
		move.l	TW_TEMPLATESIZE(a5),d0
	    ;-- check if this is the RastPort TmpRas
		move.l	rp_TmpRas(a4),d1
		beq.s	freeTemplate
		move.l	d1,a0
		move.l	tr_RasPtr(a0),d1
		beq.s	freeTemplate
		cmp.l	tr_Size(a0),d0
		ble.s	freeLocal

	    ;-- free the template
freeTemplate:
		bsr	waitblitdone
		move.l	TW_BITMAP+bm_Planes(a5),a1
		bsr	FreeMustMem

	    ;-- free the local variables
freeLocal:
		move.w	TW_CP(a5),d0		; update current position
		add.w	d0,rp_cp_x(a4)		;

_Text.:
		adda.w	#TW_SIZE,a7		; dump local variables

	    ;-- unlock the layer if required
		move.l	(a4),d0			; rp_Layer
		beq.s	endText
		move.l	d0,a5
		CALLLVO UnlockLayerRom

	    ;-- restore the caller's registers
endText:
		movem.l (a7)+,d2-d7/a2-a5
		rts



;---------------------------------------------------------------------
underlineA0:
	    ;-- get length, sans first and DBF word
		move.w	TW_BITMAP+bm_BytesPerRow(a5),d4
		lsr.w	#1,d4
		subq.w	#1,d4
	    ;-- first word (don't shift bit in from left)
		move.l	(a0),d0
		move.l	d0,d1
		swap	d1
		lsr.w	#1,d1
		bra.s	uFirstContd
	    ;-- middle words
uMidLoop:
		or.w	d3,(a1)+
		move.l	d0,d1
		addq.l	#2,a0
		move.l	(a0),d0
		lsr.l	#1,d1
uFirstContd:
		move.l	d0,d2
		add.l	d2,d2
		swap	d2
		move.l	d0,d3
		swap	d3
		or.w	d2,d3
		or.w	d1,d3
		not.w	d3
		dbf	d4,uMidLoop
	    ;-- last word (ensure bit wasn't masked from right)
		btst	#16,d0		; is it not set from char in last word?
		bne.s	uLastWord
		bset	#0,d3		; ensure right bit set
uLastWord:
		or.w	d3,(a1)+
		rts


	ifne	0
do_line	macro
	bfextu	(a2){d4:d3},d6
	add.w	d0,a2
	bfins	d6,(a6){d1:d5}
	add.w	d2,a6
	endm


	OPT	P=68020

jptbl:	dc.l	high1
	dc.l	high2
	dc.l	high3
	dc.l	high4
	dc.l	high5
	dc.l	high6
	dc.l	high7
	dc.l	high8
	dc.l	high9
	dc.l	high10
	dc.l	high11
	dc.l	high12
	dc.l	high13
	dc.l	high14
	dc.l	high15

special_020_text:
; special routines which use the 020's bitfiled instructions to render text.
; entr d7=len a3=source chars d6=height a2=font TW_EXTRA_BITMAP=allocated
; a1=tmprast
		tst.l	tf_CharSpace(a2)	; no proportional for now
		bne	non_68020
		tst.l	tf_CharKern(a2)
		bne	non_68020
		cmp.w	#15,tf_YSize(a2)
		bgt	non_68020

		tst.b	rp_AlgoStyle(a4)
		beq.s	noclear_020
	    ;-- clear the template plane for use
		move.w	d6,d0			; get height
		swap	d0			;   (in high word)
		move.w	d3,d0			; and width
		moveq	#3,d1			; synchronous clear,
						; row/word count
		CALLLVO BltClear
noclear_020:
		move.l	TW_BITMAP+bm_Planes(a5),a1

		movem.l	a2/a4/a5/a6,-(a7)
		moveq	#0,d1
		move.w	TW_MIN(a5),d1
		move.l	tf_CharLoc(a2),a0
		move.w	tf_Modulo(a2),d0
		swap	d7
		clr.w	d7
		move.b	tf_LoChar(a2),d7
		swap	d7
		move.w	TW_BITMAP+bm_BytesPerRow(a5),d2
		swap	d2
		move.b	tf_HiChar(a2),d2
		move.w	tf_XSize(a2),d5
		move.w	tf_YSize(a2),d4
		subq	#1,d4
		add.w	d4,d4
		add.w	d4,d4
		lea	jptbl(pc),a5
		move.l	0(a5,d4.w),a5
		move.l	tf_CharData(a2),-(a7)
		subq	#1,d7
		moveq	#0,d4
char_loop:	swap	d7
		moveq	#0,d3
		move.b	(a3)+,d3
		cmp.b	d2,d3
		bhi.s	spec_badchar
		sub.w	d7,d3			; subtract lochar
		bpl.s	spec_goodchar
spec_badchar:	moveq	#0,d3
		move.b	d2,d3
		sub.w	d7,d3
spec_goodchar:
		add.w	d3,d3
		add.w	d3,d3
		move.w	0(a0,d3.w),d4		; field start
		move.w	2(a0,d3.w),d3		; field width
		move.l	(a7),a2
		move.l	a1,a6
		swap	d2
		jmp	(a5)
high15:		do_line
high14:		do_line
high13:		do_line
high12:		do_line
high11:		do_line
high10:		do_line
high9:		do_line
high8:		do_line
high7:		do_line
high6:		do_line
high5:		do_line
high4:		do_line
high3:		do_line
high2:		do_line
high1:		do_line
		add.w	d5,d1
		add.w	rp_TxSpacing(a4),d1
		swap	d2
		swap	d7
end_lp1:	dbra	d7,char_loop
		lea	4(a7),a7
		movem.l	(a7)+,a2/a4/a5/a6
		move.w	d1,TW_CP(a5)
		move.l	TW_BITMAP+bm_Planes(a5),a1
		move.l	#$f0f0f0f0,(a1)
		bra	chkBold
	endc


;---------------------------------------------------------------------
;
;	font		planePick		minterm
;		ctf_FgColor	planeOnOff		rastport bitMap
;
;	+-+	+-+	+-+	+-+		+-+	+-+
;	|a|	|=|--->	|1|--->	|X|- font a -o>	| |	| |
;	+-+	+-+	+-+	+-+	     |	+-+	+-+
;	|b|	|=|\	|0|	|0|- zeros --o>	| |	| |
;	+-+	+-+ \	+-+	+-+	     |	+-+	+-+
;		     ~>	|1|--->	|X|- font b -o>	| |	| |
;		+-+	+-+	+-+	     |	+-+	+-+
;		|c|\	|0|	|1|- ones ---o>	| |	| |
;		+-+ \	+-+	+-+	    /	+-+	+-+
;		     \			   /
;		      `-mask & FgPen------'
;
;	ctf_Depth (<=8)	8			8
;		1 (mask plane)	8			rp_BitMap->depth (<=8)
;

;
;   d2	MIN
;   d3	width in pixels
;   d5	(must be zero when returning to notColorFont)
;   d6	YSize
;   d7	chars to output
;   a1	TEMPLATE
;
colorFont:
	    ;-- calculate bitmap and font depths
		;-- get rp_BitMap bm_Depth
		moveq	#0,d4
		move.l	rp_BitMap(a4),a0
		move.b	bm_Depth(a0),d4
		;-- get ctf_Depth
		moveq	#0,d1
		move.b	ctf_Depth(a2),d1
		;-- check if color remapping of FgColor to FgPen is requested
		btst	#CTB_MAPCOLOR&$7,(1-(CTB_MAPCOLOR/8))+ctf_Flags(a2)
		beq.s	cfMinFontDepth
		move.b	ctf_FgColor(a2),d0
		cmp.b	ctf_High(a2),d0
		bhi.s	cfMinFontDepth	; bgt unsigned
		cmp.b	ctf_Low(a2),d0
		bcc.s	cfHaveFontDepth	; bge unsigned
		;--	check if rp_BitMap bm_Depth is smaller
cfMinFontDepth:
		cmp.b	d1,d4
		bge.s	cfHaveFontDepth
		move.b	d4,d1
cfHaveFontDepth:
		move.w	d1,TW_FONTDEPTH(a5)
		;--	check if rp_BitMap bm_Depth is greater
		cmp.b	d1,d4
		bge.s	cfHaveDepth
		move.b	d1,d4
cfHaveDepth:
	    ;-- size template planes
		;-- get template modulo
		move.w	d3,d0
		lsr.w	#4,d0			; converted to words
		add.w	d0,d0			; converted to bytes
		move.w	d0,TW_BITMAP+bm_BytesPerRow(a5)
		move.w	d0,TW_EXTRABITMAP+bm_BytesPerRow(a5)

		;-- get template size
		mulu	d6,d0			; get the total needed size
		move.l	d0,TW_TEMPLATESIZE(a5)

	    ;-- get BitMap
		;-- initialize BitMap header
		move.w	d4,TW_BITMAP+bm_Flags(a5)	; + bm_Depth
		beq	notColorFont
		move.w	d4,TW_EXTRABITMAP+bm_Flags(a5)	; + bm_Depth
		clr.w	TW_BITMAP+bm_Pad(a5)
		clr.w	TW_EXTRABITMAP+bm_Pad(a5)
		move.w	d6,TW_BITMAP+bm_Rows(a5)
		move.w	d6,TW_EXTRABITMAP+bm_Rows(a5)
		moveq	#7,d5
		lea	TW_BITMAP+bm_Planes(a5),a0
cfClearPlanes:
		clr.l	(a0)+
		dbf	d5,cfClearPlanes

		;-- allocate all the planes required
		move.w	d4,d5
		subq	#1,d5
cfAllocPlanes:
		move.l	TW_TEMPLATESIZE(a5),d0
		moveq	#MEMF_CHIP,d1
		LINKEXE	AllocMem
		move.w	d5,d1		; get a slot for this plane
		lsl.w	#2,d1
		move.l	d0,TW_BITMAP+bm_Planes(a5,d1.w)
		beq.s	cfFailPlaneAlloc
		;-- clear the template plane for use
		move.l	d0,a1
		move.l	TW_TEMPLATESIZE(a5),d0
		moveq	#0,d1
		CALLLVO BltClear
		dbf	d5,cfAllocPlanes

		;-- use the TmpRas for the EXTRAPLANE if available
		move.l	TW_TEMPLATESIZE(a5),d0
		move.l	rp_TmpRas(a4),d1
		beq.s	cfNeedExtra
		move.l	d1,a0
		move.l	tr_RasPtr(a0),d1
		beq.s	cfNeedExtra
		cmp.l	tr_Size(a0),d0
		ble.s	cfCacheExtra
cfNeedExtra:
		moveq	#MEMF_CHIP,d1
		LINKEXE	AllocMem
		move.l	d0,d1
cfCacheExtra:
		moveq	#7,d0
		lea	TW_EXTRABITMAP+bm_Planes(a5),a0
cfCachePlanes:
		move.l	d1,(a0)+
		dbeq	d0,cfCachePlanes
		bne.s	cfGotBitmap

		;-- free any allocated planes and go render as normal text
cfFailPlaneAlloc:
		bsr	waitblitdone
		moveq	#7,d5
cfFFreePlanes:
		move.w	d5,d1
		lsl.w	#2,d1
		move.l	TW_BITMAP+bm_Planes(a5,d1.w),d0
		beq.s	cfFNextFreePlane
		move.l	d0,a1
		move.l	TW_TEMPLATESIZE(a5),d0
		LINKEXE	FreeMem
cfFNextFreePlane:
		dbf	d5,cfFFreePlanes
		moveq	#0,d5
		bra	notColorFont

cfGotBitmap:
		;-- get TW_OFFSETX0 based on MIN
		move.w	d2,d0			; MIN
		neg.w	d0			; -MIN
		asr.w	#4,d0			; get offset word
		add.w	d0,d0			;   in bytes
		addq.w	#2,d0
		move.w	d0,TW_OFFSETX0(a5)	; thus X=0 is here

		;-- save registers used for other things here
		move.w	d7,TW_LENGTH(a5)
		move.l	a3,TW_STRING(a5)
		clr.w	TW_CP(a5)

		;-- wait for last plane to clear
		bsr	waitblitdone

	;-- render characters into template
cfCharLoop:
		moveq	#0,d2
		move.l	TW_STRING(a5),a0
		move.b	(a0)+,d2		; get next character in string
		move.l	a0,TW_STRING(a5)
		cmp.b	tf_HiChar(a2),d2	; check character range
		bhi.s	cfUnKnownRC
		sub.b	tf_LoChar(a2),d2
		bcc.s	cfKnownRC

		;-- the character code is not in the font, use last char + 1
cfUnKnownRC:
		move.b	tf_HiChar(a2),d2   ;get last character
		sub.b	tf_LoChar(a2),d2
		addq.w	#1,d2

	    ;-- get start position of character
cfKnownRC:
		add.w	d2,d2
		move.w	TW_CP(a5),d1
		move.l	tf_CharKern(a2),d0
		beq.s	cfGotNear
		move.l	d0,a0
		add.w	0(a0,d2.w),d1
cfGotNear:
		move.w	d1,d3			; save CP of char start
		move.l	tf_CharSpace(a2),d0
		bne.s	cfGotFar
		add.w	tf_XSize(a2),d3
		bra.s	cfSpaced
cfGotFar:
		move.l	d0,a0
		add.w	0(a0,d2.w),d3
cfSpaced:
		add.w	rp_TxSpacing(a4),d3
		move.w	d3,TW_CP(a5)		; save CP

	    ;-- calculate bitmap bit and offset
		move.w	d1,d0
		andi.w	#$0F,d1		; get line buffer starting bit position
		asr.w	#4,d0		; get line buffer starting word offset
		add.w	d0,d0		;   then byte offset
		add.w	TW_OFFSETX0(a5),d0
		move.w	d0,TW_OFFSETBM(a5)

	    ;-- find character data bit, offset, and size
		add.w	d2,d2
		move.l	tf_CharLoc(a2),a0
		move.l	0(a0,d2.w),d0
		move.w	d0,d7			; character data bit length
		beq	cfCheckDone
		swap	d0
		move.w	d0,d6
		and.w	#$0F,d6			; character data start bit

		;-- calculate TW_OFFSETCHAR
		lsr.w	#4,d0			; (always positive)
		add.w	d0,d0			;   even word address
		move.w	d0,TW_OFFSETCHAR(a5)	;

		;-- calculate X counter initial value
		move.w	d7,d0
		sub.w	#1,d7
		lsr.w	#4,d7
		;-- look up last word mask
		subq.w	#1,d0			; make 16 fast?
		and.w	#15,d0			; get number of bits to save
		add.w	d0,d0			; word index
		lea	_lwmaskTable,a0
		move.w	0(a0,d0.w),d5		; 1 = first entry
		swap	d5
		clr.w	d5
		lsr.l	d6,d5			; shift into position

		;-- create intermediate mask
		move.l	#$ffff0000,d4
		lsr.l	d6,d4

		;-- get font bit map depth
		move.w	TW_FONTDEPTH(a5),d3

		;-- initialize plane array pointers
		move.l	a4,-(a7)		; save rastPort
		lea	TW_BITMAP+bm_Planes(a5),a3
		lea	ctf_CharData(a2),a4

		;-- determine copy direction and branch
		sub.w	d1,d6
		bge	cfLeft
		neg.w	d6
		bra.s	cfRight
;
;   d0	temporary for character bits
;   d1	temporary for X counter
;   d2	temporary for Y counter
;   d3  Z counter
;   d4	longword mask associated with intermediate words of char data
;   d5	longword mask associated with last word of char data
;   d6	shift associated with char data (0-15)
;   d7	initial value for x counter
;   a0	current font source
;   a1	current template destination
;   a2	tf_ current textFont
;   a3	template bm_Planes array
;   a4	font ctf_Planes array
;   a5	TW variables
;   a6	gfxBase (unused, preserved)
;   a7	stack
;
cfRightZLoop:
		move.l	(a4)+,a0
		add.w	TW_OFFSETCHAR(a5),a0
		move.l	(a3)+,a1
		add.w	TW_OFFSETBM(a5),a1
cfRightYLoop:
		move.w	d7,d1		; initialize x counter
		movem.l	a0/a1,-(a7)
		bra.s	cfRightXDBF
cfRightXLoop:
		move.l	(a0),d0
		and.l	d4,d0
		lsr.l	d6,d0
		or.l	d0,(a1)
		addq.l	#2,a1
		addq.l	#2,a0
cfRightXDBF:
		dbf	d1,cfRightXLoop

		move.l	(a0),d0
		and.l	d5,d0
		lsr.l	d6,d0
		or.l	d0,(a1)

		movem.l	(a7)+,a0/a1
		add.w	tf_Modulo(a2),a0
		add.w	TW_BITMAP+bm_BytesPerRow(a5),a1
		dbf	d2,cfRightYLoop

cfRight:
		move.w	tf_YSize(a2),d2	; initialize y counter
		subq	#1,d2
		dbf	d3,cfRightZLoop
		bra.s	cfLeftEnd

cfLeftZLoop:
		move.l	(a4)+,a0
		add.w	TW_OFFSETCHAR(a5),a0
		move.l	(a3)+,a1
		add.w	TW_OFFSETBM(a5),a1
cfLeftYLoop:
		move.w	d7,d1		; initialize x counter
		movem.l	a0/a1,-(a7)
		bra.s	cfLeftXDBF
cfLeftXLoop:
		move.l	(a0),d0
		and.l	d4,d0
		lsl.l	d6,d0
		or.l	d0,(a1)
		addq.l	#2,a1
		addq.l	#2,a0
cfLeftXDBF:
		dbf	d1,cfLeftXLoop

		move.l	(a0),d0
		and.l	d5,d0
		lsl.l	d6,d0
		or.l	d0,(a1)

		movem.l	(a7)+,a0/a1
		add.w	tf_Modulo(a2),a0
		add.w	TW_BITMAP+bm_BytesPerRow(a5),a1
		dbf	d2,cfLeftYLoop

cfLeft:
		move.w	tf_YSize(a2),d2	; initialize y counter
		subq	#1,d2
		dbf	d3,cfLeftZLoop


cfLeftEnd:
		move.l	(a7)+,a4
cfCheckDone:
		subq.w	#1,TW_LENGTH(a5)
		bne	cfCharLoop
	    
	    ;-- check bold enhancement
		btst	#FSB_BOLD,rp_AlgoStyle(a4)
		beq.s	cfChkItalic
		;-- set up parameters to OR BitMap into itself BoldSmear later
		lea	TW_BITMAP(a5),a0		; SrcBitMap
		moveq	#0,d0				; SrcX
		moveq	#0,d1				; SrcY
		move.l	a0,a1				; DstBitMap
		move.w	tf_BoldSmear(a2),d2		; DstX
		moveq	#0,d3				; DstY
		move.w	TW_BITMAP+bm_BytesPerRow(a5),d4	; SizeX
		lsl.w	#3,d4				;
		sub.w	d2,d4				;
		move.w	tf_YSize(a2),d5			; SizeY
		moveq	#$ffffffea,d6			; Minterm
		moveq	#-1,d7				; Mask
		move.l	d0,a2				; TempA
		CALLLVO	BltBitMap
		move.l	rp_Font(a4),a2

	    ;-- check italic enhancement
cfChkItalic:
		btst	#FSB_ITALIC,rp_AlgoStyle(a4)
		beq	cfChkPen
		;-- get font variables
		move.w	tf_YSize(a2),d3
		move.w	tf_Baseline(a2),d5
		sub.w	d3,d5				; Baseline - YSize
		bge	cfChkPen			; bad Baseline!
		;-- get the TempA now once
		moveq	#0,d0
		move.w	TW_BITMAP+bm_BytesPerRow(a5),d0
		addq.w	#2,d0
		move.l	d0,-(a7)
		moveq	#MEMF_CHIP,d1
		bsr	GetMustMem
		move.l	d0,a2				; TempA
		;-- setup for loop
		move.w	d5,d0				; SrcX =
		neg.w	d0				;   (YSize - Baseline)
		lsr.w	#1,d0				;   /2
		bcc.s	cfiOddSizeY			; check if odd start
		moveq	#2,d5				; (YSize-Baseline odd)
		bra.s	cfiSetDstX
cfiOddSizeY:
		moveq	#1,d5				; (YSize-Baseline even)
cfiSetDstX:
		moveq	#0,d2				; DstX

		move.w	TW_BITMAP+bm_BytesPerRow(a5),d4	; SizeX
		lsl.w	#3,d4				;
		sub.w	d0,d4

		moveq	#-1,d7				; Mask
		;-- loop thru Bitmap and shift pairs of rows
cfiShift:
		sub.w	d5,d3				; next Y
		bpl.s	cfisYOK
		addq.w	#1,d3				; last single line?
		bmi.s	cfisDone
		moveq	#1,d5				; last single SizeY
cfisYOK:
		cmp.w	d0,d2				; check for baseline
		beq.s	cfisNext
		move.w	d3,d1				; SrcY (from DstY)

		movem.w	d0/d2/d4,-(a7)			; save SrcX,DestX,SizeX
		;--	shift row
		moveq	#$ffffffc0,d6			; Minterm: copy
		lea	TW_BITMAP(a5),a0		; SrcBitMap
		move.l	a0,a1				; DstBitMap
		CALLLVO	BltBitMap

		cmp.w	(a7),d2				; SrcX ? DestX
		blt.s	cfisCleared			; below baseline, no clr
		move.w	d2,d4				; Size is DestX
		beq.s	cfisCleared			; first line, no clr

		;--	clear upper left
		moveq	#0,d0				; Src doesn't matter
		moveq	#0,d1				;
		moveq	#0,d2				; DestX is 0
		moveq	#$00000000,d6			; Minterm: clear
		lea	TW_BITMAP(a5),a0		; SrcBitMap
		move.l	a0,a1
		CALLLVO	BltBitMap

cfisCleared:
		movem.w	(a7)+,d0/d2/d4			; get SrcX,DestX,SizeX

cfisNext:
		addq.w	#1,d2				; DstX
		subq.w	#1,d4				; SizeX
		moveq	#2,d5				; intermediate SizeY
		bra.s	cfiShift
cfisDone:
		;-- release the TempA
		bsr	waitblitdone
		move.l	(a7)+,d0
		move.l	a2,a1
		bsr	FreeMustMem
		move.l	rp_Font(a4),a2

	    ;-- check for color remapping of FgColor to FgPen
cfChkPen:
		btst	#CTB_MAPCOLOR&$7,(1-(CTB_MAPCOLOR/8))+ctf_Flags(a2)
		beq	cfChkUnderline
		move.b	ctf_FgColor(a2),d7
		cmp.b	ctf_High(a2),d7
		bhi	cfChkUnderline	; bgt unsigned
		cmp.b	ctf_Low(a2),d7
		bcs	cfChkUnderline	; blt unsigned
		;-- generate mask for rp_FgPen based on rp BitMap Depth
		;   and check if need to change color
		moveq	#-1,d0			; move.l #$ffff0000,d0
		clr.w	d0			;
		move.l	rp_BitMap(a4),a0	; get rp BitMap
		move.b	bm_Depth(a0),d1		;   Depth
		rol.l	d1,d0			; get mask in low word
		and.b	rp_FgPen(a4),d0		; get masked rp_FgPen
		cmp.b	d0,d7			; check if need to change color
		beq.s	cfChkUnderline
		;-- construct a mask of the inverse of the FgColor
		;------ clear the mask
		move.l	TW_EXTRABITMAP+bm_Planes(a5),a1
		move.l	TW_TEMPLATESIZE(a5),d0
		moveq	#0,d1
		CALLLVO	BltClear
		;------ OR in data from planes clear where FgColor is set
		lea	TW_BITMAP(a5),a0
		moveq	#0,d0
		moveq	#0,d1
		lea	TW_EXTRABITMAP(a5),a1
		moveq	#0,d2
		moveq	#0,d3
		moveq	#0,d4
		move.w	TW_BITMAP+bm_BytesPerRow(a5),d4
		lsl.l	#3,d4
		moveq	#0,d5
		move.w	TW_BITMAP+bm_Rows(a5),d5
		moveq	#$ffffffba,d6		; ABC ANBC ANBNC NABC NANBC
		move.b	ctf_FgColor(a2),d7
		CALLLVO	BltBitMap
		;------ OR in data from planes set where FgColor is clear
		lea	TW_BITMAP(a5),a0
		moveq	#0,d0
		moveq	#0,d1
		lea	TW_EXTRABITMAP(a5),a1
		moveq	#$ffffffea,d6		; ABC ABNC ANBC NABC NANBC
		not.b	d7			; ~ctf_FgColor
		CALLLVO	BltBitMap
		;------ OR in the data to planes were FgPen is set
		lea	TW_EXTRABITMAP(a5),a0
		moveq	#0,d0
		moveq	#0,d1
		lea	TW_BITMAP(a5),a1
		moveq	#$ffffffba,d6		; ABC ANBC ANBNC NABC NANBC
		move.b	rp_FgPen(a4),d7
		CALLLVO	BltBitMap
		;------ AND in the data to planes were FgPen is clear
		lea	TW_EXTRABITMAP(a5),a0
		moveq	#0,d0
		moveq	#0,d1
		lea	TW_BITMAP(a5),a1
		moveq	#$ffffff8a,d6		; ABC NABC NANBC
		not.b	d7			; ~rp_FgPen
		CALLLVO	BltBitMap


	    ;-- check underline enhancement
cfChkUnderline:
		btst	#FSB_UNDERLINED,rp_AlgoStyle(a4)
		beq	cfChkInverse
		;-- get the text mask
		bsr	cfTextMask
		;-- get the underline template
		;--	get the memory
		moveq	#0,d0
		move.w	TW_BITMAP+bm_BytesPerRow(a5),d0
		move.l	d0,d7
		moveq	#MEMF_CHIP,d1
		bsr	GetMustMem
		move.l	d0,a3
		;--	clear the memory
		move.l	d7,d0
		moveq	#1,d1			; synchronous clear
		move.l	a3,a1
		CALLLVO	BltClear
		;-- render underline template
		move.l	TW_EXTRABITMAP+bm_Planes(a5),a0
		move.w	tf_Baseline(a2),d6
		addq.w	#1,d6
		cmp.w	tf_YSize(a2),d6
		bge.s	cfuFreeMustMem
		mulu	TW_BITMAP+bm_BytesPerRow(a5),d6
		add.l	d6,a0
		move.l	a3,a1
		bsr	underlineA0
		;-- render underline from template
		lea	TW_BITMAP+bm_Planes(a5),a2
		moveq	#0,d5
		move.b	TW_BITMAP+bm_Depth(a5),d5
		moveq	#0,d4
		move.b	rp_FgPen(a4),d4
		bra.s	cfuZDBF
cfuZLoop:
		move.l	a3,a0
		move.l	(a2)+,a1
		add.l	d6,a1
		move.w	TW_BITMAP+bm_BytesPerRow(a5),d3
		lsr.w	#1,d3
		lsr.w	#1,d4
		bcc.s	cfuX0DBF
		bra.s	cfuX1DBF
cfuX0Loop:
		move.w	(a0)+,d0
		not.w	d0
		and.w	d0,(a1)+
cfuX0DBF:
		dbf	d3,cfuX0Loop
		bra.s	cfuZDBF
cfuX1Loop:
		move.w	(a0)+,d0
		or.w	d0,(a1)+
cfuX1DBF:
		dbf	d3,cfuX1Loop
cfuZDBF:
		dbf	d5,cfuZLoop

		;-- free the underline template
cfuFreeMustMem:
		move.l	d7,d0
		move.l	a3,a1
		bsr	FreeMustMem
		;-- restore font pointer
		move.l	rp_Font(a4),a2

cfChkInverse:
		btst	#2,rp_DrawMode(a4)	; check INVERSE bit
		beq.s	cfChkJam1
	    ;-- invert the character data
		lea	TW_BITMAP(a5),a0
		move.l	a0,a1
		moveq	#0,d0
		moveq	#0,d1
		moveq	#0,d2
		moveq	#0,d3
		move.w	TW_BITMAP+bm_BytesPerRow(a5),d4
		lsl.l	#3,d4
		move.w	TW_BITMAP+bm_Rows(a5),d5
		moveq	#$3a,d6			; ANBNC ANBC NABC NANBC
		moveq	#-1,d7
		CALLLVO	BltBitMap

cfChkJam1:
	    ;-- check for JAM1 write
		move.b	rp_DrawMode(a4),d0
		and.b	#RP_COMPLEMENT+RP_JAM2,d0 ; check for other than JAM1
		bne.s	cfNotMaskedBlt		; no need to make text mask

		;-- get the text mask
		bsr.s	cfTextMask
		;-- clear under the mask
		bsr	cfGetBltParms
		lea	TW_EXTRABITMAP(a5),a0	; srcBitMap
		moveq	#$2a,d6			; ANBC NABC NANBC
		CALLLVO BltBitMapRastPort

cfNotMaskedBlt:
	    ;-- copy the text to the rastPort
		bsr	cfGetBltParms
		lea	TW_BITMAP(a5),a0	; srcBitMap
		moveq	#0,d6			; minterm
		move.b	rp_DrawMode(a4),d6
		and.b	#3,d6
		move.b	cfMinterms(pc,d6.w),d6
		CALLLVO BltBitMapRastPort

	    ;-- free the EXTRAPLANE
		bsr	waitblitdone
		;-- check if this is the RastPort TmpRas
		move.l	TW_TEMPLATESIZE(a5),d0
		move.l	rp_TmpRas(a4),d1
		beq.s	cfFreeExtra
		move.l	d1,a0
		move.l	tr_RasPtr(a0),d1
		beq.s	cfFreeExtra
		cmp.l	tr_Size(a0),d0
		ble.s	cfFreeBitmap

		;-- free the TmpRas
cfFreeExtra:
		move.l	TW_EXTRABITMAP+bm_Planes(a5),a1
		LINKEXE	FreeMem

	    ;-- free the BitMap planes
cfFreeBitmap:
		moveq	#7,d5
cfFreePlanes:
		move.w	d5,d1
		lsl.w	#2,d1
		move.l	TW_BITMAP+bm_Planes(a5,d1.w),d0
		beq.s	cfNextFreePlane
		move.l	d0,a1
		move.l	TW_TEMPLATESIZE(a5),d0
		LINKEXE	FreeMem
cfNextFreePlane:
		dbf	d5,cfFreePlanes
		bra	freeLocal
		
cfMinterms:
		;--				      _  _   __ _   _ _ __  ___
		;				ABC ABC ABC ABC ABC ABC ABC ABC
		; JAM1: copy under mask
		dc.b	$ea
		; JAM2: copy block
		dc.b	$ca
		; COMPLEMENT: complement under mask
		dc.b	$6a
		; JAM2 COMPLEMENT: complement block
		dc.b	$5a

cfTextMask:
	    ;-- construct the text mask
		;-- clear the mask
		move.l	TW_EXTRABITMAP+bm_Planes(a5),a1
		move.l	TW_TEMPLATESIZE(a5),d0
		moveq	#0,d1
		CALLLVO	BltClear
		;-- OR in all the text planes
		lea	TW_BITMAP(a5),a0
		moveq	#0,d0
		moveq	#0,d1
		lea	TW_EXTRABITMAP(a5),a1
		moveq	#0,d2
		moveq	#0,d3
		moveq	#0,d4
		move.w	TW_BITMAP+bm_BytesPerRow(a5),d4
		lsl.l	#3,d4
		moveq	#0,d5
		move.w	TW_BITMAP+bm_Rows(a5),d5
		moveq	#$ffffffea,d6		; ABC ABNC ANBC NABC NANBC
		moveq	#-1,d7
		CALLLVO	BltBitMap
		rts


cfGetBltParms:
		move.l	a4,a1			; destRastPort
		move.w	TW_OFFSETX0(a5),d0	; srcX
		lsl.w	#3,d0
		move.w	TW_MIN(a5),d6
		add.w	d6,d0
		ext.l	d0
		moveq	#0,d1
		move.w	rp_cp_x(a4),d2		; get destX
		add.w	d6,d2			; adjusted for MIN
		ext.l	d2
		move.w	rp_cp_y(a4),d3		; get destY
		sub.w	tf_Baseline(a2),d3	;   adjusted for even baselines
		ext.l	d3
		move.w	TW_MAX(a5),d4		; get sizeX
		sub.w	d6,d4
		ext.l	d4
		move.w	tf_YSize(a2),d5		; get sizeY
		ext.l	d5
		rts

	END
@


39.4
log
@Fixed italicising of large fonts. Also, slightly optimised the italic
code.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 39.3 92/03/19 16:32:48 chrisg Exp Locker: spence $
d962 1
d1079 1
@


39.3
log
@fixed cliprect optimization. 020 text not all there yet.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 39.2 92/02/10 14:43:07 chrisg Exp Locker: chrisg $
d372 2
a373 1
		add.w	#47,d3			; round up to word + 2 word pad
d382 1
d387 1
a387 1
		lea	2(a1,d0.w),a0		; pad with 1 word
d789 4
d795 1
a797 3
		move.w	TW_BITMAP+bm_BytesPerRow(a5),d7
		lsr.w	#1,d7
		subq.w	#1,d7
d805 1
a805 1
		move.l	(a0),d0		; get longword to shift
d808 1
a808 2
		move.w	d0,0(a0,d3)	;   update word in shifted position
		addq.l	#2,a0		; go on to next word
d818 1
a820 3
		move.w	TW_BITMAP+bm_BytesPerRow(a5),d7
		lsr.w	#1,d7
		subq.w	#1,d7
d837 1
@


39.2
log
@ removed stupid print
@
text
@d2 1
a2 1
**	$Id: write.asm,v 39.1 92/01/30 15:34:48 chrisg Exp Locker: chrisg $
d21 1
d256 4
d415 1
d454 2
a455 1
		lsl.w	#2,d5
d514 6
d521 1
d529 1
a529 1
	    ;-- save registers used for other things here
d721 1
a721 1
		bra	chkBold
d770 1
a770 1
		beq	chkUnderline
d853 1
a853 1
		bsr	underlineA0
d960 118
d1683 1
a1683 1
		bsr	cfTextMask
@


39.1
log
@  Fixed bug (also present in 2.04!) Didn't en-bolden properly when
tf_BoldSmear > 16
@
text
@d2 1
a2 1
**	$Id: write.asm,v 39.0 91/08/21 17:37:08 chrisg Exp Locker: chrisg $
a736 1
		print	'mmrb'
@


39.0
log
@Bumped
@
text
@d2 1
a2 1
**	$Id: write.asm,v 37.3 91/02/12 15:52:48 spence Exp Locker: chrisg $
d33 1
d207 2
d717 3
a723 1
		move.w	tf_BoldSmear(a2),d1
d735 19
a753 2


@


37.3
log
@autodoc
@
text
@d2 1
a2 1
**	$Id: write.asm,v 37.2 91/01/25 17:25:33 spence Exp Locker: spence $
@


37.2
log
@Handles *humungously* large text in low-mem conditions.
@
text
@d2 1
a2 1
**	$Id: write.asm,v 37.1 91/01/18 17:19:51 spence Exp Locker: spence $
d73 1
a73 1
*            a1  a0      d0-0:16
d75 1
a75 1
*	void Text( struct RastPort *, STRPTR, WORD );
d90 2
a91 2
*	rp - a pointer to the RastPort which describes where the
*	    text is to be output
d93 2
a94 2
*	length - the string length.  If zero, there are no characters
*	    to be output. 
d98 1
a98 1
*       o   Changing the text direction with RastPort->TxSpacing is
d111 1
a111 1
*	Move, TextLength, graphics/text.h, graphics/rastport.h
@


37.1
log
@Handles large text in low-mem conditions without guruing
@
text
@d2 1
a2 1
**	$Id: write.asm,v 37.0 91/01/07 15:29:16 spence Exp Locker: spence $
d278 1
a278 1
		bne.s	notByteModulo
d295 1
a295 1
		beq.s	LowMemTextdbra
d316 2
a317 1
*		bra.s	LowMemTextdbra
d370 1
a370 1
		beq.s	LowMemTextdbra
@


37.0
log
@initial switchover from V36
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.21 90/09/27 11:30:43 bart Exp Locker: spence $
d275 1
a275 1
		beq.s	notByteModulo
d294 2
d300 11
d312 17
d368 2
d870 1
@


36.21
log
@removed textfont reliance on tf_Styles TAGGED bit
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.20 90/06/11 15:51:40 kodiak Exp Locker: bart $
@


36.20
log
@fixes depth of ColorFont rendering to affect all planes in RastPort
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.19 90/05/21 21:37:14 kodiak Exp Locker: kodiak $
d266 1
d272 10
a282 4
		move.b	tf_Style(a2),d1
		btst	#FSB_TAGGED,d1
		beq.s	notByteModulo
		move.l	tf_Extension(a2),a0
d334 1
a334 1
		btst	#FSB_COLORFONT,d1
@


36.19
log
@fix fg color remapping for color fonts
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.18 90/05/10 15:36:49 kodiak Exp Locker: kodiak $
d160 2
a161 1
	WORD	TW_OFFSETX0		; only used for colorFont
d914 2
a915 2
	    ;-- calculate rendering depth plus mask plane
		;-- get font depth
d917 5
a921 1
		move.b	ctf_Depth(a2),d4
d924 1
a924 1
		beq.s	cfMinDepth
d927 1
a927 1
		bhi.s	cfMinDepth
d929 12
a940 7
		bcc.s	cfHaveDepth
		;-- check if rp_BitMap bm_Depth is less
cfMinDepth:
		move.l	rp_BitMap(a4),a0
		cmp.b	bm_Depth(a0),d4
		ble.s	cfHaveDepth
		move.b	bm_Depth(a0),d4
d1121 2
a1122 3
		;-- get bit map depth
		moveq	#0,d3
		move.b	TW_BITMAP+bm_Depth(a5),d3
d1337 1
a1337 1
		bhi	cfChkUnderline
d1339 1
a1339 1
		bcs	cfChkUnderline
d1341 1
@


36.18
log
@check for invalid baseline before using for algorithmic italic
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.17 90/04/24 10:47:09 kodiak Exp Locker: kodiak $
d1346 1
a1346 1
		;------ OR in data from planes where FgColor is set
d1358 1
a1358 1
		moveq	#$ffffffea,d6		; ABC ABNC ANBC NABC NANBC
d1361 1
a1361 1
		;------ OR in data from planes where FgColor is clear
d1366 1
a1366 1
		moveq	#$ffffffba,d6		; ABC ANBC ANBNC NABC NANBC
d1374 1
a1374 1
						; ABC ANBC ANBNC NABC NANBC
@


36.17
log
@document blitter usage
@
text
@d2 1
a2 1
**	$Id: write.asm,v 36.16 90/04/13 11:52:36 kodiak Exp Locker: kodiak $
d708 1
d1246 2
a1256 1
		sub.w	d3,d5				; Baseline - YSize
@


36.16
log
@use Id instead of Header for 4.x rcs
@
text
@d2 1
a2 1
**	$Id$
d96 5
d103 6
a108 10
*	    -   The maximum string length (in pixels) is limited to
*		(1024 - 16 = 1008) pixels wide.
*	    -   A text string whose last character(s) have a
*		tf_CharLoc size component that extends to the right of
*		the rightmost of the initial and final CP positions
*		will be (inappropriately) clipped.
*
*   NOTES
*       Changing the text direction with RastPort->TxSpacing is not
*	supported.
@


36.15
log
@for rcs 4.x header change
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/graphics/text/RCS/write.asm,v 36.14 90/02/18 21:07:35 kodiak Exp Locker: kodiak $
@


36.14
log
@fix italic color fonts
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.13 90/01/29 11:39:16 kodiak Exp $
@


36.13
log
@rename and move TTEXTATTR in flags to TAGGED in style
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.12 90/01/23 16:56:47 kodiak Exp $
d1016 1
d1240 1
a1240 1
		beq.s	cfChkPen
d1258 1
a1258 1
		moveq	#2,d5				; SizeY
d1261 1
a1261 1
		moveq	#1,d5
a1268 1
		moveq	#$ffffffca,d6			; Minterm
a1271 1
		lea	TW_BITMAP(a5),a0		; SrcBitMap
d1281 5
a1286 1
		move.w	d0,-(a7)			; save SrcX
d1288 18
a1305 1
		move.w	(a7)+,d0			; recover SrcX
@


36.12
log
@first cut at TextFont tag extension (tf_Extension)
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.11 90/01/09 17:54:20 kodiak Exp $
d271 1
a271 1
		btst	#FSB_COMPILED,d1
@


36.11
log
@adjust cp_x even if text is clipped.
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.10 89/11/22 16:53:58 kodiak Exp $
d273 2
a274 1
		btst	#FCBB_BYTECELL,MN_LENGTH+FCBO_BYTECELL(a2)
@


36.10
log
@update documentation
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.9 89/11/02 18:37:56 kodiak Exp $
d199 9
d238 1
a238 1
		beq	unLockLayer
a250 1
	    ;-- reserve space for local variables
a251 2
		suba.w	#TW_SIZE,a7
		move.l	a7,a5
a262 3
	    ;-- initialize variables
		movem.w	d0/d1/d2,TW_CP(a5)	; MAX, and MIN

a804 4
allClipped:
		move.w	TW_CP(a5),d0		; update current position
		add.w	d0,rp_cp_x(a4)		;

d824 3
a828 1
unLockLayer:
a1470 4

cfUpdateCP:
		move.w	TW_CP(a5),d0		; update current position
		add.w	d0,rp_cp_x(a4)		;
@


36.9
log
@recode to use gb_ExecBase
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.8 89/06/29 11:44:14 kodiak Exp $
d82 3
d97 7
d105 3
a107 2
*	The maximum string length (in pixels) is limited to (1024 - 16 = 1008)
*	    pixels wide.
d193 1
a193 1
		bsr	textLength		; destroys d0-d6/a0-a6
@


36.8
log
@remove debug code writing to $0
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.7 89/06/08 14:22:11 kodiak Exp $
d27 1
d47 2
a48 3
	XREF		_AbsExecBase
	XREF_EXE	AllocMem
	XREF_EXE	FreeMem
d50 7
a56 1
*------ Graphics Library Functions -----------------------------------
a57 7
	XREF_GFX	BltBitMap
	XREF_GFX	BltBitMapRastPort
	XREF_GFX	BltMaskBitMapRastPort
	XREF_GFX	BltClear
	XREF_GFX	BltTemplate
	XREF_GFX	LockLayerRom
	XREF_GFX	UnlockLayerRom
a58 1

d177 1
a177 1
		CALLGFX LockLayerRom		; preserves d0/d1/a0/a1
d348 1
a348 1
		CALLGFX BltClear
d453 1
a453 1
		CALLGFX BltClear
d789 1
a789 1
		CALLGFX BltTemplate
d821 1
a821 1
		CALLGFX UnlockLayerRom
d959 1
a959 1
		CALLGFX BltClear
d1220 1
a1220 1
		CALLGFX	BltBitMap
d1271 1
a1271 1
		CALLGFX	BltBitMap
d1309 1
a1309 1
		CALLGFX	BltClear
d1324 1
a1324 1
		CALLGFX	BltBitMap
d1332 1
a1332 1
		CALLGFX	BltBitMap
d1340 1
a1340 1
		CALLGFX	BltBitMap
d1348 1
a1348 1
		CALLGFX	BltBitMap
d1369 1
a1369 1
		CALLGFX	BltClear
d1434 1
a1434 1
		CALLGFX	BltBitMap
d1448 1
a1448 1
		CALLGFX BltBitMapRastPort
d1458 1
a1458 1
		CALLGFX BltBitMapRastPort
d1514 1
a1514 1
		CALLGFX	BltClear
d1529 1
a1529 1
		CALLGFX	BltBitMap
@


36.7
log
@add preclipping (after box calculation, before rendering)
@
text
@d2 1
a2 1
**	$Header: write.asm,v 36.6 89/06/05 14:16:04 kodiak Exp $
a219 4
	bne.s	qwe
	addq	#1,0
	bra	unLockLayer
qwe:
@


36.6
log
@autodoc changes
@
text
@d2 1
a2 1
**	$Header$
d190 1
d192 45
d238 1
a248 1
		move.l	rp_Font(a4),a2		; get the current font
d775 1
d822 1
@


36.5
log
@rework mechanism for storing speedup bits
@
text
@d1 8
a8 35
	TTL    '$Header: write.asm,v 36.4 88/07/14 14:57:51 kodiak Exp $'
**********************************************************************
*
*		-------------
*		GRAPHICS TEXT	text write primitive
*		-------------
*
*   Copyright 1985, 1987 Commodore-Amiga Inc.
*
*   Source Control: $Locker: kodiak $
*
*   $Log:	write.asm,v $
*   Revision 36.4  88/07/14  14:57:51  kodiak
*   fix TW_EXTRABITMAP, so REVPATH fonts work
*   
*   Revision 36.3  88/04/13  14:46:09  kodiak
*   (oops: sense of colorfont branch)
*   
*   Revision 36.2  88/04/13  13:28:34  kodiak
*   first cut at color pen remapping
*   
*   Revision 36.1  88/03/11  09:56:19  kodiak
*   max from textLength needs no correction
*   
*   Revision 36.0  88/03/06  11:02:12  kodiak
*   changed register usage due to textLength register changes
*   
*   Revision 35.5  87/12/03  12:59:29  kodiak
*   support color text
*   
*   Revision 35.3  87/11/17  14:49:24  kodiak
*   fix italics & underline
*   
*
**********************************************************************
d77 1
a77 3
*	struct	RastPort *rp;
*	STRPTR	string;
*	SHORT	length;
@


36.4
log
@fix TW_EXTRABITMAP, so REVPATH fonts work
@
text
@d1 1
a1 1
	TTL    '$Header: write.asm,v 36.3 88/04/13 14:46:09 kodiak Exp $'
d13 3
d57 1
d246 1
a246 1
		btst	#FSB_BYTEFONT,d1
d248 2
a249 2
		btst	#FSB_COLORFONT,d1
		bne.s	notByteModulo
@


36.3
log
@(oops: sense of colorfont branch)
@
text
@d1 1
a1 1
	TTL    '$Header: write.asm,v 36.2 88/04/13 13:28:34 kodiak Exp $'
d13 3
d304 1
@


36.2
log
@first cut at color pen remapping
@
text
@d1 1
a1 1
	TTL    '$Header: write.asm,v 36.1 88/03/11 09:56:19 kodiak Exp $'
d13 3
d293 1
a293 1
		beq	colorFont
@


36.1
log
@max from textLength needs no correction
@
text
@d1 1
a1 1
	TTL    '$Header: write.asm,v 36.0 88/03/06 11:02:12 kodiak Exp $'
d13 3
a289 2
		beq.s	notColorFont
		btst	#CTB_NORMALFONT&$7,(1-(CTB_NORMALFONT/8))+ctf_Flags(a2)
d1265 1
a1265 1
		beq.s	cfChkUnderline
d1268 1
a1268 1
		bhi.s	cfChkUnderline
d1270 1
a1270 1
		bcs.s	cfChkUnderline
d1280 46
a1325 2
		;-- construct a mask of the FgColor
		nop	;!!!
@


36.0
log
@changed register usage due to textLength register changes
@
text
@d1 1
a1 1
	TTL    '$Header: write.asm,v 35.5 87/12/03 12:59:29 kodiak Exp $'
d13 3
a203 1
		addq.w	#1,d1
@


35.5
log
@support color text
@
text
@d1 1
a1 1
	TTL    '$Header: write.asm,v 35.3 87/11/17 14:49:24 kodiak Exp $'
d13 3
d185 1
a185 1
		move.w	d0,d7			; save length
a186 2
		move.l	a1,a4			; save rp
		move.l	a0,a3			; save string
d189 2
a190 2
		move.l	(a4),d1			; rp_Layer
		beq.s	getLocals
d194 11
a204 1
getLocals:
a208 5
	    ;-- get length of this string
		bsr	textLength		; destroys d0-d4/a0-a2
						; length in d0
						; max in d1
						; min in d2
a282 5
		;-- adjust bm_BytesPerRow for algorithmic enhancements
		add.w	tf_BoldSmear(a2),d3	; pad for bold smear
		move.w	d6,d0			; pad for italicizing w/
		lsr.w	#1,d0			;   YSize/2
		add.w	d0,d3			;
d291 2
a292 5
		;-- get TW_EXTRABITMAP+bm_Planes address based on MIN & italics
		move.w	d6,d0			; YSize
		sub.w	tf_Baseline(a2),d0	;   - Baseline
		lsr.w	#1,d0			;   ()/2
		sub.w	d2,d0			; () - MIN
a636 1
		add.w	d1,TW_MAX(a5)	; update size
a691 2
		lsr.w	#1,d1		; get half of baseline distance
		sub.w	d1,TW_MIN(a5)	; update left edge
a717 3
		asr.w	#1,d1		; get half of baseline distance
		bmi.s	chkUnderline	; never looped through
		add.w	d1,TW_MAX(a5)	; update right edge
d758 1
a758 1
		move.w	TW_MAX(a5),d4		; get sizeX + 1
d974 2
a975 5
		;-- get TW_OFFSETX0 based on MIN & italics
		move.w	d6,d0			; YSize
		sub.w	tf_Baseline(a2),d0	;   - Baseline
		lsr.w	#1,d0			;   ()/2
		sub.w	d2,d0			; () - MIN
a1193 1
		add.w	d2,TW_MAX(a5)			; update size
a1202 5
		;-- adjust MAX
		move.w	d5,d0
		subq.w	#1,d0
		lsr.w	#1,d0
		add.w	d0,TW_MAX(a5)
d1218 1
a1218 1
		bra.s	cfiAdjMin
d1221 1
a1221 2
cfiAdjMin:
		sub.w	d0,TW_MIN(a5)
d1476 1
a1476 1
		move.w	TW_MAX(a5),d4		; get sizeX + 1
@


35.4
log
@(note: will break for ColorFonts)
@
text
@d31 2
a35 1
	INCLUDE		"graphics/gfxbase.i"
a38 2
	INCLUDE		"text.i"

d54 3
d60 3
d160 4
a163 2
	WORD	TW_OFFSETX		; only used for ColorText
	LONG	TW_TEMPLATESIZE		; total of all planes
d165 1
a168 8
;   normal text doesn't need the BitMap, and uses the following names in
;   the temporary write variable space instead
;
TW_TEMPLATE	EQU	TW_BITMAP+bm_Planes
TW_TEMPLATE0	EQU	TW_BITMAP+bm_Planes+4
TW_TEMPLATEMOD	EQU	TW_BITMAP+bm_BytesPerRow

;
d205 1
a205 1
;  d3	TW_TEMPLATEMOD
d218 1
a218 1
		;-- TEMPLATEMOD is based on rendering length
d232 1
a232 1
		andi.b	#FSF_ITALIC+FSF_BOLD,d5
d238 1
a238 1
		move.l	a1,TW_TEMPLATE0(a5)
d247 1
a247 1
		move.w	d3,TW_TEMPLATEMOD(a5)
d271 1
a271 1
		move.l	a1,TW_TEMPLATE(a5)
d277 1
a277 1
		;-- adjust TEMPLATEMOD for algorithmic enhancements
d284 4
a287 1
		bne	colorFont
d290 1
a290 1
		;-- get TW_TEMPLATE0 address based on MIN & italics
d298 1
a298 1
		move.l	a0,TW_TEMPLATE0(a5)	; thus X=0 is here
d306 1
a306 1
;   d3	TW_TEMPLATEMOD
d327 1
a327 1
		move.l	TW_TEMPLATE(a5),a1	; CP (byte address)
d458 1
a458 1
		beq.s	nbFarBound
d461 1
a461 1
nbFarBound:
d464 1
a464 1
		bne.s	nbPropBound
d467 1
a467 1
nbPropBound:
d510 1
a510 1
		move.l	TW_TEMPLATE0(a5),a0  ;get word address
d512 1
a512 1
		move.w	TW_TEMPLATEMOD(a5),a2
d634 1
a634 1
		move.l	TW_TEMPLATE(a5),a0
d660 1
a660 1
		move.l	TW_TEMPLATE(a5),a0
d662 1
a662 1
		move.w	d0,d6			; save baseline for later
d664 1
a664 1
		mulu	TW_TEMPLATEMOD(a5),d0
d667 1
a667 1
		addq.w	#1,d6			; BaseLine + 1
d676 1
a676 1
		move.w	TW_TEMPLATEMOD(a5),d7
d704 1
a704 1
		move.w	TW_TEMPLATEMOD(a5),d7
a726 1

a730 1

d733 1
a733 1
		move.l	TW_TEMPLATE(a5),a0
d736 1
a736 1
		addq.w	#2,d0		;the template starts one line down
d738 1
a738 1
		bgt.s	templateOut
d740 1
a740 1
		mulu	TW_TEMPLATEMOD(a5),d0
d742 2
a744 35
	    ;-- get length, sans first and DBF word
		move.w	TW_TEMPLATEMOD(a5),d4
		lsr.w	#1,d4
		subq.w	#1,d4
	    ;-- first word (don't shift bit in from left)
		move.l	(a0),d0
		move.l	d0,d1
		swap	d1
		lsr.w	#1,d1
		bra.s	uFirstContd
	    ;-- middle words
uMidLoop:
		eor.w	d3,(a0)+
		move.l	d0,d1
		move.l	(a0),d0
		lsr.l	#1,d1
uFirstContd:
		move.l	d0,d2
		add.l	d2,d2
		swap	d2
		move.l	d0,d3
		swap	d3
		or.w	d2,d3
		or.w	d1,d3
		not.w	d3
		dbf	d4,uMidLoop
	    ;-- last word (ensure bit wasn't masked from right)
		btst	#16,d0		; is it not set from char in last word?
		bne.s	uLastWord
		bset	#0,d3		; ensure right bit set
uLastWord:
		eor.w	d3,(a0)+
	    ;-- end of underline code


d752 1
a752 1
		move.l	TW_TEMPLATE0(a5),a0	; srcTemplate
d758 1
a758 1
		move.w	TW_TEMPLATEMOD(a5),d1	; srcMod
d791 1
a791 1
		move.l	TW_TEMPLATE(a5),a1
d810 68
d879 14
d894 21
a914 8
		moveq	#0,d0
		move.b	bm_Depth(a0),d0
		cmp.b	ctf_Depth(a2),d0
		ble.s	haveDepth
		move.b	ctf_Depth(a2),d0
haveDepth:
		move.w	d0,TW_BITMAP+bm_Flags(a5)	; + bm_Depth
		beq	freeLocal
d916 1
d918 65
a982 5
		addq.w	#1,d0			; one plane for pen remapping
		mulu	d0,d6			; fake height to get planes
		bsr	getTemplate
		move.w	TW_BITMAP+bm_Rows(a5),d6
		;-- get TW_OFFSETX based on MIN & italics
d990 1
a990 15
		move.w	d0,TW_OFFSETX(a5)	; thus X=0 is here
		;-- flesh out bm_Planes for BltBitMapRastPort
		moveq	#0,d0
		move.b	TW_BITMAP+bm_Depth(a5),d0
		subq.w	#1,d0
		lea	TW_BITMAP+bm_Planes(a5),a0	; == TW_TEMPLATE
		move.w	TW_TEMPLATEMOD(a5),d1
		mulu	d6,d1
		move.l	(a0)+,a1
		bra.s	gapPlanesDBF
gapPlanesLoop:
		add.w	d1,a1
		move.l	a1,(a0)+
gapPlanesDBF:
		dbf	d0,gapPlanesLoop
d992 1
a992 7
	    ;-- clear the template plane for use
		move.l	TW_TEMPLATESIZE(a5),d0
		moveq	#1,d1			; synchronous clear
		move.l	TW_TEMPLATE(a5),a1
		CALLGFX BltClear

	    ;-- save registers used for other things here
d997 4
d1002 1
a1002 1
		moveq	#0,d5
d1004 1
a1004 1
		move.b	(a0)+,d5    ;get next character in string
d1006 1
a1006 1
		cmp.b	tf_HiChar(a2),d5   ;check character range
d1008 1
a1008 1
		sub.b	tf_LoChar(a2),d5
d1011 1
a1011 1
	    ;-- the character code is not in the font, use last char + 1
d1013 3
a1015 3
		move.b	tf_HiChar(a2),d5   ;get last character
		sub.b	tf_LoChar(a2),d5
		addq.w	#1,d5
d1019 2
a1020 2
		add.w	d5,d5
		move.w	TW_CP(a5),d3
d1022 1
a1022 1
		beq.s	cfFarBound
d1024 3
a1026 3
		add.w	0(a0,d5.w),d3
cfFarBound:
		move.w	d3,d7			; save CP of char start
d1028 1
a1028 1
		bne.s	cfPropBound
d1030 2
a1031 2
		bra.s	cfSpacing
cfPropBound:
d1033 2
a1034 2
		add.w	0(a0,d5.w),d3
cfSpacing:
d1036 1
d1038 7
a1044 2
	    ;-- save CP
		move.w	d3,TW_CP(a5)
d1046 2
a1047 2
	    ;-- find character data start and size
		add.w	d5,d5
d1049 2
a1050 2
		move.l	0(a0,d5.w),d0
		move.w	d0,d5	    ;character data bit length
d1053 4
a1056 2
		move.w	d0,d3
		and.w	#$0F,d3			; character data start bit
d1059 1
d1061 5
a1065 10
		move.l	tf_CharData(a2),a1
		add.w	d0,a1			; character data start word

		move.w	tf_Modulo(a2),a3

	    ;-- get number of lines to copy
		move.w	tf_YSize(a2),d6

	    ;--	calculate the 32 bit mask
		move.w	d5,d0
d1070 4
a1073 4
		move.w	0(a0,d0.w),d4		; 1 = first entry
		swap	d4
		clr.w	d4
		lsr.l	d3,d4			; shift into position
d1075 3
a1077 8
	    ;-- calculate start line position
		move.w	d7,d0
		andi.w	#$0F,d7	    ;get line buffer starting bit position
		asr.w	#4,d0	    ;get line buffer starting byte offset
		add.w	d0,d0	    ;  then word offset
		move.l	TW_TEMPLATE0(a5),a0  ;get word address
		add.w	d0,a0	    ;line buffer starting word address
		move.w	TW_TEMPLATEMOD(a5),a2
d1079 14
a1092 10
	    ;-- calculate variables for wide characters
		move.l	#$ffff0000,d2		; intermediate mask
		lsr.l	d3,d2
		sub.w	#17,d5			; fix up width dbf counter
		lsr.w	#4,d5
		move.w	d5,d0			; fix up modulos
		add.w	d0,d0
		addq.w	#2,d0
		sub.w	d0,a2
		sub.w	d0,a3
d1094 16
a1109 13
;  d0	 **
;  d1	  *
;  d2	   mask associated with char data (longword)
;  d3	  *start bit associated with char data (0-15)
;  d4	   mask associated with last word of char data (longword)
;  d5	   dbf counter for intermediate char words
;  d6	  *counter for height (tf_YSize)
;  d7	   start bit associated with CP (0-15)
;  a0	 **template initial longword address
;  a1	 **character data initial longword address
;  a4	   template adjusted modulo
;  a5	   font adjusted modulo
;	 **=destroyed
d1111 14
a1124 10
cfCopy:
		sub.w	d7,d3
		bge.s	cfLeft
		neg.w	d3
		bra.s	cfRight
cfRightLoop:
		move.l	(a1),d0
		and.l	d2,d0
		lsr.l	d3,d0
		or.l	d0,(a0)
d1127 2
a1128 1
		dbf	d1,cfRightLoop
d1130 4
a1133 4
		move.l	(a1),d0
		and.l	d4,d0
		lsr.l	d3,d0
		or.l	d0,(a0)
d1135 5
a1139 2
		adda.w	a5,a1		; bump char data by it's modulo
		adda.w	a4,a0		; bump template by it's modulo
d1141 4
a1144 2
		move.w	d5,d1		; initialize x counter
		dbf	d6,cfRightLoop
d1146 37
a1183 1
		move.l	rp_Font(a4),a2
d1186 21
a1206 1
		bra	chkBold
d1208 33
a1240 8
cfLeftLoop:
		move.l	(a1),d0
		and.l	d2,d0
		lsl.l	d3,d0
		or.l	d0,(a0)
		addq.l	#2,a1
		addq.l	#2,a0
		dbf	d1,cfLeftLoop
d1242 3
a1244 4
		move.l	(a1),d0
		and.l	d4,d0
		lsl.l	d3,d0
		or.l	d0,(a0)
d1246 255
a1500 6
		adda.w	a5,a1		; bump char data by it's modulo
		adda.w	a4,a0		; bump template by it's modulo
cfLeft:
		move.w	d5,d1		; initialize x counter
		dbf	d6,cfLeftLoop
		bra.s	cfCheckDone
@


35.3
log
@fix italics & underline
@
text
@d1 1
a1 1
	TTL    '$Header: write.asm,v 33.1 86/06/11 11:28:55 bart Exp $'
d10 1
a10 1
*   Source Control: $Locker: bart $
d12 4
a15 1
*   $Log: write.asm,v $
d155 3
a157 4
	APTR	TW_TEMPLATE
	APTR	TW_TEMPLATE0
	WORD	TW_TEMPLATEMOD
	WORD	TW_TEMPLATESIZE
d159 1
d161 8
d224 5
a230 2
		btst	#FSB_BYTEFONT,tf_Style(a2)
		beq.s	notByteModulo
d252 1
a252 1
		move.w	d0,TW_TEMPLATESIZE(a5)
d283 2
a616 1

d621 1
d632 3
a634 3
		move.w	TW_TEMPLATESIZE(a5),d0
		lsr	#1,d0		; fix size for word count,
		subq	#2,d0		;   DBF, & not last word
d810 1
a810 2
		moveq	#0,d0
		move.w	TW_TEMPLATESIZE(a5),d0
d841 207
@


35.2
log
@support for BIG_BLIT
@
text
@a647 1
		subq.w	#4,a1		;   right edge
d688 1
d697 1
a697 1
		move.l	(a1),d0		; get longword to shift
d699 1
a699 2
		move.w	d0,2(a1,d3)	;   update word in shifted position
		subq.l	#2,a1		; go on to next word
d726 1
a726 1
		;-- first, DBF, and last word not counted
d730 1
a730 1
	    ;-- first word
a732 1
		move.l	d0,d2
a733 1
		move.w	d1,d3
a734 1
		add.l	d2,d2
d738 2
d741 2
d744 2
a746 2
		lsr.w	#1,d1
		add.l	d2,d2
d748 3
a750 7
uFirstContd:
		swap	d2
		or.w	d3,d2
		or.w	d2,d1
		not.w	d1
		eor.w	d1,(a0)+
		move.w	d0,d1
d752 6
a757 9
	    ;-- last word
		move.w	(a0),d0
		move.w	d0,d2
		lsr.w	#1,d1
		add.l	d2,d2
		or.w	d2,d1
		or.w	d1,d0
		not.w	d0
		eor.w	d0,(a0)
@


35.1
log
@text speed enhancements
@
text
@a2 11
*								     *
*   Copyright 1985, Commodore-Amiga Inc.   All rights reserved.	     *
*   No part of this program may be reproduced, transmitted,	     *
*   transcribed, stored in retrieval system, or translated into	     *
*   any language or computer language, in any form or by any	     *
*   means, electronic, mechanical, magnetic, optical, chemical,	     *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030				     *
*								     *
**********************************************************************
d4 3
a6 1
*	text write primitive
d8 1
a8 3
*   Source Control
*   --------------
*   $Header: write.asm,v 33.1 86/06/11 11:28:55 bart Exp $
d10 1
a10 1
*   $Locker: kodiak $
d12 1
a12 1
*   $Log:	write.asm,v $
d31 1
d33 2
d47 1
a145 2
MAX_TEMPLATEMOD	EQU	126

d149 2
a151 3
	WORD	TW_MAX
	WORD	TW_CP
	WORD	TW_MINMAXBOUND
d153 1
d170 1
a170 1
	;-- save the text parameters
d176 1
a176 1
	;-- check if need to lock layer
d178 1
a178 1
		beq.s	getLocal
d180 1
a180 1
		CALLGFX LockLayerRom
d182 2
a183 2
	;-- reserve space for local variables
getLocal:
d187 12
a198 4
	;-- initialize variables
		clr.w	TW_MIN(a5)

	    ;-- find the current font
d200 2
d203 10
a212 1
	;-- check for byte font special case
d214 1
a214 1
		bne.s	notByteCase
d216 4
a219 1
		beq.s	notByteCase
d221 6
a227 9
	;-- get template
;
;   d3	TW_TEMPLATEMOD
;   d4	TW_MINMAXBOUND
;   d5	byteCase if non-zero; no BOLD/ITALIC & MAX_TEMPLATEMOD if negative 
;   d6	BltClear size
;
	    ;-- calculate working template width
		;-- byte case:
d229 2
a230 39
		;-- check if width-altering algorithmic enhancements are used:
		;   if not, then use a fixed width template that's not cleared
		move.b	rp_AlgoStyle(a4),d0
		andi.b	#FSF_ITALIC+FSF_BOLD,d0
		bne.s	varyingTemplateByteCase
		move.w	tf_YSize(a2),d0		; cache YSize
		beq	unlock			; no height => no rendering
		addq	#1,d0			; to start in the middle
		moveq	#MAX_TEMPLATEMOD,d3
		move.w	#(MAX_TEMPLATEMOD*8),d4
		moveq	#-1,d5
		move.w	d4,d6
		bra.s	cacheTAttrs

varyingTemplateByteCase:
		moveq	#1,d5
		bra.s	varyingTemplate
notByteCase:
		moveq	#0,d5
varyingTemplate:
		move.w	tf_YSize(a2),d0		; cache YSize
		beq	unlock			; no height => no rendering
		move.w	d0,d1			; cache YSize
		lsr.w	#1,d1			;            /2
		btst	#FPB_PROPORTIONAL,tf_Flags(a2)
		bne.s	largestTemplate		; cannot know size, use largest
		move.w	tf_XSize(a2),d4		; get width of character cell
		add.w	rp_TxSpacing(a4),d4	; including spacing
		mulu	d7,d4			; get string width
		add.w	tf_BoldSmear(a2),d4	; pad for bold smear
		add.w	d1,d4			; pad for italicizing
		add.w	#23,d4			; pad for padding
		cmp.w	#(MAX_TEMPLATEMOD*8),d4
		ble.s	gotTemplateWidth
largestTemplate:
		move.w	#(MAX_TEMPLATEMOD*8),d4
gotTemplateWidth:
		;-- calculate template modulo
		move.w	d4,d3			; from working width
d233 4
a236 9
		;-- calculate MINMAXBOUND
		sub.w	tf_BoldSmear(a2),d4
		sub.w	d1,d4
	    ;-- get template size
		addq.w	#1,d0			; to "start in the middle"
		move.w	d0,d6			; cache height
		swap	d6			;   for later BltClear
		move.w	d3,d6			; width
cacheTAttrs:
a238 1
		move.w	d3,TW_TEMPLATEMOD(a5)
d240 1
a240 1
	    ;-- get the template
d249 1
a249 1
	    ;-- no template or not big enough
d256 26
a281 4
		move.l	d1,TW_TEMPLATE(a5)
		tst.w	d5
		bmi.s	fixedByteCode
		move.l	d1,a1			; save template for BltClear
d284 1
a284 2
	    ;-- special case byte fonts
;
d298 2
d301 3
a303 1
		move.l	d6,d0			; get height & width
d308 1
a308 9
		movem.l	a2/a4/a5/a6,-(a7)
		lea	bVarHunkStart(pc),a6
		;-- calculate bLoop entry offset
		move.w	tf_YSize(a2),d2
		subq.w	#1,d2
		move.w	d2,d0
		and.w	#7,d0
		subq.w	#7,d0
		bra.s	sharedByteInitialization
d310 1
a310 1
fixedByteCode:
a311 1
		lea	bMaxHunkStart(pc),a6
d313 1
a313 1
		move.w	tf_YSize(a2),d2
d316 4
a319 19
		and.w	#7,d0
		subq.w	#7,d0
		move.w	d0,d3
		addq.w	#1,d3
		    ;-- offset template for middle of char copy loop
		mulu	#MAX_TEMPLATEMOD,d3
		;-- ensure the template is ready for use
		bsr	waitblitdone

sharedByteInitialization:
		;-- finish bLoop entry point and loop counter calculations
		neg.w	d0
		    ;-- get initial entry into bLoop
		add.w	d0,d0			; calculate d0 * 6
		move.w	d0,d5
		add.w	d0,d0
		add.w	d5,d0
		add.w	d0,a6
		    ;-- get DBF counter
a321 9
		lsr.w	#3,d4			; / 8: chars that fit here
		cmp.w	d7,d4			; vs. desired
		bcc.s	bGotLength
		move.w	d4,d7			; truncate length to fit
bGotLength:
		move.w	d7,d0
		lsl.w	#3,d0			; * 8: pixels
		move.w	d0,TW_CP(a5)
		move.w	d0,TW_MAX(a5)
d328 1
a328 2
		move.l	TW_TEMPLATE(a5),a5	; CP (byte address)
		add.w	d3,a5			; start in "middle"
d355 6
a360 1
bVarLoop:
d363 1
a363 1
bVarHunkStart:
d367 1
a367 1
bVarHunkMark:
d387 1
a387 1
		dbf	d0,bVarLoop
d396 2
a397 31
bMaxLoop:
		adda.w	d4,a1
		adda.w	#(MAX_TEMPLATEMOD*8),a0
bMaxHunkStart:
		move.b	(a1),0(a0)
		adda.w	d4,a1			; bump char data by it's modulo
bMaxHunkMark:
		move.b	(a1),(MAX_TEMPLATEMOD)(a0)
		adda.w	d4,a1
		move.b	(a1),(MAX_TEMPLATEMOD*2)(a0)
		adda.w	d4,a1
		move.b	(a1),(MAX_TEMPLATEMOD*3)(a0)
		adda.w	d4,a1
		move.b	(a1),(MAX_TEMPLATEMOD*4)(a0)
		adda.w	d4,a1
		move.b	(a1),(MAX_TEMPLATEMOD*5)(a0)
		adda.w	d4,a1
		move.b	(a1),(MAX_TEMPLATEMOD*6)(a0)
		adda.w	d4,a1
		move.b	(a1),(MAX_TEMPLATEMOD*7)(a0)
		dbf	d0,bMaxLoop

	    ;-- get next character
		addq.w	#1,a5			; update CP byte address
		dbf	d7,bCharLoop

		movem.l	(a7)+,a2/a4/a5/a6
		bra	chkUnderline

	IFNE	bVarHunkMark-bVarHunkStart-6
	FAIL	"bHunk not 6 bytes long, recode initial entry calculation * 6"
a399 4
	IFNE	(bVarHunkMark-bVarHunkStart)-(bMaxHunkMark-bMaxHunkStart)
	FAIL	"bHunks not equal sized, recode"
	ENDC

d406 3
a408 1
		move.l	d6,d0			; get height & width
a415 1
		move.w	#-1,TW_MAX(a5)
a416 1
		move.w	d4,TW_MINMAXBOUND(a5)
d437 1
a437 1
		movem.w TW_MIN(a5),d1/d2/d3/d4	; MAX, CP, & MMBOUND
a441 9
		;-- check kern vs. character min/max
		cmp.w	d1,d3			;TW_MIN
		bgt.s	nbKernMaxChk
		move.w	d3,d1
nbKernMaxChk:
		cmp.w	d2,d3			;TW_MAX
		blt.s	nbFarBound
		move.w	d3,d2
	    ;-- ensure character will fit
a452 14
		;-- check bound vs. character min/max
		cmp.w	d1,d3			;TW_MIN
		bgt.s	nbBoundMaxChk
		move.w	d3,d1
nbBoundMaxChk:
		cmp.w	d2,d3			;TW_MAX
		blt.s	nbLineSizeChk
		move.w	d3,d2
	    ;-- ensure min/max is not too big
nbLineSizeChk:
		move.w	d2,d0			; MAX
		sub.w	d1,d0			;   - MIN
		cmp.w	d4,d0			; vs. MMBOUND
		bge	chkBold
d454 2
a455 2
	    ;-- save line extremes
		movem.w d1/d2/d3,TW_MIN(a5)	; MAX, and CP
d491 1
a491 1
		move.l	TW_TEMPLATE(a5),a0  ;get word address
a493 1
		add.w	a2,a0	    ;
d643 2
a644 2
		addq.w	#2,d0		;1: the template starts one line down
					;  and 2: at the end of the line
a646 4
		move.w	TW_MIN(a5),d0
		asr.w	#4,d0
		add.w	d0,d0		; get bytes
		add.w	d0,a0		; adjust start for min
d649 1
a649 2
		move.w	tf_Baseline(a2),d6
		addq.w	#1,d6
d653 1
a653 1
		moveq	#2,d1		; starts shifted below baseline
d656 1
a674 1
		addq.w	#1,d1		; increment count away from baseline
d677 2
a678 1
		sub.w	d2,TW_MIN(a5)	; update left edge
d681 1
a681 1
		moveq	#0,d1		; starts at baseline
d684 1
a702 1
		addq.w	#1,d1		; increment count away from baseline
d705 3
a707 1
		add.w	d2,TW_MAX(a5)	; update right edge
a725 4
		move.w	TW_MIN(a5),d0
		asr.w	#4,d0
		add.w	d0,d0		; get bytes
		add.w	d0,a0		; adjust start for min
d775 1
a775 1
		move.l	TW_TEMPLATE(a5),a0
d777 1
a777 6
	    ;--	adjust source for min
		move.w	TW_MIN(a5),d0
		move.w	d0,d1
		asr.w	#4,d1			; get offset word
		add.w	d1,d1			;   in bytes
		add.w	d1,a0
d779 1
a779 2
		move.w	TW_TEMPLATEMOD(a5),d1
		add.w	d1,a0
d781 1
a781 1
		move.l	a4,a1			; destRastPort
a784 1
		ext.l	d2
a787 1
		ext.l	d3
a790 2
		ext.l	d4
		and.l	#$0F,d0			; mask srcX
a792 1
		ext.l	d5
d810 1
a810 1
		ble.s	unlock
d814 1
d818 5
a822 2
	;-- unlock the layer if required
unlock:
d824 1
a824 1
		beq.s	freeLocal
a826 2
freeLocal:
		adda.w	#TW_SIZE,a7		; dump local variables
d828 1
a828 1
	;-- free the local variables and restore the caller's registers
@


35.0
log
@initial from V34
@
text
@d1 1
a1 1
	TTL    '$Header: write.asm,v 1.1 87/10/19 15:14:30 kodiak Exp $'
d19 1
a19 1
*   $Header: write.asm,v 1.1 87/10/19 15:14:30 kodiak Exp $
d47 4
d53 3
a55 1
	XREF		_AbsExecBase
d57 1
a57 2
	XREF	FreeMustMem
	XREF	GetMustMem
a58 1
	XREF_EXE	Alert
a59 3
	xref	_lwmaskTable


d81 2
a82 2
*	Text(rp, string, count)
*	     a1	  a0    d0-0:16
d86 1
a86 1
*	SHORT	count;
d91 1
a91 1
*	is applied to any of the characters, and only text on the
d95 1
a95 1
*	thus does not represent the true position.
d100 2
a101 1
*	count - the string length.  If zero, there are no characters
a102 1
*	string - the address of string to output
d110 1
a110 1
*	Move TextLength graphics/text.h graphics/rastport.h
a114 2
*	only horizontal text is currently supported
*
d153 2
a157 1
	APTR	TW_WINDOW
d161 4
a164 3
	WORD	TW_MODULO
	APTR	TW_STENCIL
	WORD	TW_STENCILSIZE
d166 10
a175 1

d177 1
a177 2
		MOVEM.L D2-D7/A2-A5,-(A7)
		MOVE.L	A1,A2
d179 5
a183 5
*	    ;-- check if need to lock layer
		MOVE.L	rp_Layer(A2),D1
		BEQ.S	linkLocal
		MOVE.L	D1,A5
		CALLGFX	LockLayerRom		; assumes A0 not hit!
d185 5
a189 2
linkLocal
		LINK	A6,#-TW_SIZE
d191 4
a194 4
*	;-- get string length
		MOVE.W	D0,TW_LENGTH-TW_SIZE(A6)
*	    ;-- check for null string
		BEQ	unlock
d196 2
a197 2
*	    ;-- save string pointer
		MOVE.L	A0,TW_STRING-TW_SIZE(A6)
d199 2
a200 15
		CLR.W	TW_STENCILSIZE-TW_SIZE(A6)
*	;-- get template
getTemplate:
		MOVE.L	rp_Font(A2),A4
*	    ;-- calculate horizontal template size
		MOVE.W	rp_TxHeight(A2),D0
		ADDQ.W	#1,D0		    ;to "start in the middle"
		MOVE.W	D0,D1
		MOVE.W	D0,D4
		SWAP	D4
		MOVE.L	rp_BitMap(A2),A0
		ifne	bm_BytesPerRow
			fail
		endc
		MOVE.W	(A0),D4		* was bm_BytesPerRow(a0) ,see fail above
d202 5
a206 1
*		bart - 06.11.86 	* check for superbitmap layer...
a207 3
		MOVEA.L	rp_Layer(A2),A0
		CMPA.L	#0,A0
		BEQ.S	no_layer
d209 9
a217 3
		MOVEA.L  lr_SuperBitMap(A0),A0
		CMPA.L	#0,A0
		BEQ.S	no_superbitmap
d219 13
a231 1
		MOVE.W	(A0),D4		* was bm_BytesPerRow(a0) ,see fail above
d233 39
a271 2
no_superbitmap:
no_layer:
d273 8
a280 1
*		endbart - 06.11.86 	* check for superbitmap layer...
d282 1
a282 21
		LSR.W	#1,D1
		ADD.W	tf_BoldSmear(A4),D1
		LSR.W	#1,D1
		LSR.W	#4,D1
		ADD.W	D1,D1
		ADDQ.W	#4,D1		; fudge factor
		ADD.W	D1,D4
its_ok:
		MOVE.W	D4,TW_MODULO-TW_SIZE(A6)    ;save template modulo
		MULU	D4,D0		    ;get template size
		MOVE.W	D0,TW_STENCILSIZE-TW_SIZE(A6)

*	    ;-- get the template
		MOVE.L	rp_TmpRas(A2),D2
		BEQ.S	needTemplate
		MOVE.L	D2,A0
		MOVE.L	tr_RasPtr(A0),D2
		BEQ.S	needTemplate
		CMP.L	tr_Size(A0),D0
		BLE.S	clrTemplate
*	;------ horrors! no template or not big enough
d284 3
d288 6
a293 18
		MOVEQ	#MEMF_CHIP,D1
		MOVE.L	A6,-(A7)
		MOVE.L	(A6),A6
		BSR	GetMustMem
		MOVE.L	(A7)+,A6
		MOVE.L	D0,D2
**********************
*		GetMustMem is guarenteed to return NON NULL
*		BNE.S	clrTemplate
*
*		MOVE.L	A5,-(A7)
*		MOVE.L	#AN_TextTmpRas,D7
*		MOVE.L	A2,A5
*		LINKEXE	Alert
*		MOVE.L	(A7)+,A5
*
*		BRA	unlock
**********************
d295 20
a314 6
clrTemplate:
*	    ;-- clear the template plane for use
		MOVE.L	D2,TW_STENCIL-TW_SIZE(A6)
		MOVE.L	D2,A1
		MOVE.L	D4,D0
		MOVEQ	#3,D1	    ; synchronous clear of row/word count
d316 163
a478 2
		MOVE.L	A6,-(A7)
		MOVE.L	(A6),A6
a479 1
		MOVE.L	(A7)+,A6
d481 6
a486 4
*	;-- initialize common variables
		CLR.W	TW_MIN-TW_SIZE(A6)
		CLR.W	TW_CP-TW_SIZE(A6)
		MOVE.W	#-1,TW_MAX-TW_SIZE(A6)
d488 9
a496 16
*------ do robust characters ------
*   D0	character value
*   D1	character data offset (bits)
*   D2	character current data length (bits)
*   D3	line buffer data offset (bits)
*   D4	line buffer modulo
*   D5	font modulo
*   D6	number of lines to copy (decremented)
*   D7	character offset
*
*   A0	character current (word) address
*   A1	line buffer current (word) address
*   A2	character current line (word) address
*   A3	line buffer current line (word) address
*   A4	font pointer, imported
*   A6	local variables
d498 5
a502 11
		MOVE.L	A2,TW_WINDOW-TW_SIZE(A6)
		MOVE.W	tf_Modulo(A4),D5
robString:
		MOVEQ	#0,D7
		MOVE.L	TW_STRING-TW_SIZE(A6),A0
		MOVE.B	(A0)+,D7    ;get next character in string
		MOVE.L	A0,TW_STRING-TW_SIZE(A6)
		CMP.B	tf_HiChar(A4),D7   ;check character range
		BHI.S	unKnownRC
		SUB.B	tf_LoChar(A4),D7
		BCC.S	knownRC
d504 42
a545 5
*	    ;-- the character code is not in the font, use last char + 1
unKnownRC:
		MOVE.B	tf_HiChar(A4),D7   ;get last character
		SUB.B	tf_LoChar(A4),D7
		ADDQ	#1,D7
d547 2
a548 48
*	    ;-- get start position of character
knownRC:
		ADD.W	D7,D7
*		tweaked by Dale	  tentative
		movem.w	TW_MIN-TW_SIZE(a6),d1/d2
*		MOVE.W	TW_MIN-TW_SIZE(A6),D1
*		MOVE.W	TW_MAX-TW_SIZE(A6),D2
		MOVE.W	TW_CP-TW_SIZE(A6),D3
		MOVE.L	tf_CharKern(A4),D0
		BEQ.S	farBound
		MOVE.L	D0,A0
		ADD.W	0(A0,D7.W),D3
		MOVE.W	D3,TW_CP-TW_SIZE(A6)
*		;-- check kern vs. character min/max
		CMP.W	D1,D3		    ;TW_MIN
		BGT.S	kernMaxChk
		MOVE.W	D3,D1
kernMaxChk:
		CMP.W   D2,D3		;TW_MAX
		BLT.S	farBound
		MOVE.W	D3,D2
*	    ;-- ensure character will fit
farBound:
		MOVE.L	tf_CharSpace(A4),D0
		BNE.S	propBound
		ADD.W	tf_XSize(A4),D3
		BRA.S	spacing
propBound:
		MOVE.L  D0,A0
		ADD.W	0(A0,D7.W),D3
spacing:
		MOVE.L	TW_WINDOW-TW_SIZE(A6),A2
		ADD.W	rp_TxSpacing(A2),D3
*		;-- check bound vs. character min/max
		CMP.W   D1,D3		;TW_MIN
		BGT.S	boundMaxChk
		MOVE.W	D3,D1
boundMaxChk:
		CMP.W   D2,D3		;TW_MAX
		BLT.S	lineSizeChk
		MOVE.W	D3,D2
*	    ;-- ensure min/max is not too big
lineSizeChk:
		MOVE.W	D2,D0	    ;max
		SUB.W	D1,D0	    ;max-min
		LSR.W	#3,D0	    ;(max-min) bytes
		CMP.W	D4,D0	    ;TX_MODULO,D0
		BGE	robOverflow
d550 14
a563 15
*	    ;-- save line extremes and calculate start line position
*	tweaked by dale   tentative
		movem.w	d1/d2,TW_MIN-TW_SIZE(a6)
*		MOVE.W	D1,TW_MIN-TW_SIZE(A6)  ;save min/max after this char
*		MOVE.W	D2,TW_MAX-TW_SIZE(A6)
		MOVE.W	TW_CP-TW_SIZE(A6),D0   ;get start position of char
		MOVE.W	D3,TW_CP-TW_SIZE(A6)   ;save start position after char
		MOVE.W	D0,D3
		ANDI.W	#$0F,D3	    ;get line buffer starting bit position
		ASR.W	#4,D0	    ;get line buffer starting byte offset
		ADD.W	D0,D0	    ;  then word offset
		EXT.L	D0	    ;
		ADD.L	TW_STENCIL-TW_SIZE(A6),D0  ;get word address
		MOVE.L	D0,A3	    ;line buffer starting word address
		ADD.W	D4,A3	    ;
d565 2
a566 13
*	    ;-- find character data start and size
		ADD.W	D7,D7
		MOVE.L	tf_CharLoc(A4),A0
		MOVE.L	0(A0,D7.W),D0
		MOVE.W	D0,D2	    ;character data bit length
		SWAP	D0
		MOVE.W	D0,D1
		AND.W	#$0F,D1	    ;character data start bit
		LSR.W	#3,D0	    ;(always positive)
		BCLR	#0,D0	    ;  even word address
		EXT.L	D0
		ADD.L	tf_CharData(A4),D0
		MOVE.L	D0,A2	    ;character data start word
d568 5
a572 10
*	    ;-- get number of lines to copy
		MOVE.W	tf_YSize(A4),D6
		move.l	a5,-(sp)		* save here
		move.w	d5,a5			* free up d5
*		calculate the 32 bit mask and save in 
		move.w	d2,d5
		beq.s	keep_it_zero
		subq.w	#1,d5			* make 16 fast?
		and.w	#15,d5			* get number of bits to save
		add.w	d5,d5			* word index
d574 4
a577 10
		move.w	0(a0,d5.w),d5	* 1 = first entry
keep_it_zero:
		swap	d5
		clr.w	d5
		cmp.w	#16,d2			* optimize for small characters
		bcs.s	smallrobSetup1
		move.l	a4,-(sp)
		move.w	d2,a4
		moveq	#16,d2			* set up const 16 used in loop
		BRA.S	robSetupLine
d579 9
a587 16
smallrobSetup1:
	lsr.l	d3,d5
	sub.w	d1,d3			* new kill
	blt.s	smallrobSetup1left	* new kill
	bra.s	smallrobSetupright
smallrobLineLoopright:
	move.l	(a2),d0
*	lsl.l	d1,d0				* new kill
	lsr.l	d3,d0
	and.l	d5,d0			* dales new stuff
	or.l	d0,(a3)
	adda.w	a5,a2
	adda.w	d4,a3
smallrobSetupright:
	dbf	d6,smallrobLineLoopright
	bra.s	smallrobreturn
d589 3
a591 14
smallrobSetup1left:
	neg.w	d3
	bra.s	smallrobSetupleft
smallrobLineLoopleft:
	move.l	(a2),d0
*	lsl.l	d1,d0		* new kill
	lsl.l	d3,d0		* new kill
	and.l	d5,d0			* dales new stuff
	or.l	d0,(a3)
	adda.w	a5,a2
	adda.w	d4,a3
smallrobSetupleft:
	dbf	d6,smallrobLineLoopleft
	bra.s	smallrobreturn
d593 39
a631 6
robLineLoop:
		MOVE.L  (A0),D0
		LSL.L	D1,D0
		CLR.W	D0
		CMP.W	d2,D7			* d2 is really const 16
		BCC.S	robWordDump
d633 4
a636 3
*       bart - 04.09.86 carry set, always do next line
		NEG.W   D7
		ADDI.W  #16,D7
d638 6
a643 3
		LSR.L   D7,D0
		CLR.W   D0
		LSL.L   D7,D0
d645 8
a652 3
		LSR.L   D3,D0
		OR.L    D0,(A1)
		BRA.S   robNextLine
d654 4
a657 3
*       bart -  bugfix #2479  don't use mask here
*		and.l	d5,d0			* dales new stuff
*		end bart - 04.09.86
d659 6
a664 14
*		ROL.L	D7,D0		* kodiak's old stuff
*		ext.l	d0
*		SWAP	D0		* kodiak's old stuff
*		CLR.W	D0		* kodiak's old stuff
*		SWAP	D0		* kodiak's old stuff
*		ROR.L	D7,D0		* kodiak's old stuff
robWordDump:
		LSR.L   D3,D0
		OR.L	D0,(A1)
		SUB.W	d2,D7			* d2 is really const 16
		BCS.S	robNextLine
		ADDQ.L	#2,A0
		ADDQ.L	#2,A1
		BRA.S	robLineLoop
a665 4
* entry into this loop
robNextLine:
		ADDA.W	a5,A2
		ADDA.W	D4,A3
d667 10
a676 4
robSetupLine:
		MOVE.L	A2,A0
		MOVE.L	A3,A1
		MOVE.W	a4,D7
d678 5
a682 1
		DBF	D6,robLineLoop
d684 5
a688 4
		move.l	(sp)+,a4
smallrobreturn:
		move.w	a5,d5			* restore d5
		move.l	(sp)+,a5		* restore a4
d690 4
a693 7
*	;-- test and loop for any more characters
nextRob:
		SUBQ	#1,TW_LENGTH-TW_SIZE(A6)
		BNE	robString
exitRob:
		MOVE.L	TW_WINDOW-TW_SIZE(A6),A2
		BRA.S	chkBold
a694 4
robOverflow:
*	;-- readjust string pointer
		ADDQ.L	#1,TW_STRING-TW_SIZE(A6)
		BRA.S	exitRob
d696 4
a699 1
*   ;-- character loop is done
d701 3
d705 12
a716 12
*	;-- check bold enhancement
		BTST	#FSB_BOLD,rp_AlgoStyle(A2) ;bold text?
		BEQ.S	chkItalic
*	;-- embolden the data in the buffer
		MOVE.L	TW_STENCIL-TW_SIZE(A6),A0
		MOVE.W	TW_STENCILSIZE-TW_SIZE(A6),D0
		LSR	#1,D0		; fix size for word count,
		SUBQ	#2,D0		;   DBF, & not last word
		MOVE.W	tf_BoldSmear(A4),D1
		ADD.W	D1,TW_MAX-TW_SIZE(A6)	; update size
		MOVEQ	#0,D3
		MOVE.W	(A0)+,D3
d719 7
a725 7
		SWAP	D3
		MOVE.L	D3,D2
		LSR.L	D1,D2
		MOVEQ	#0,D3
		MOVE.W	(A0)+,D3
		OR.L	D2,-4(A0)
		DBF	D0,emboldenLoop
d729 3
a731 3
*	;-- check italic enhancement
		BTST	#FSB_ITALIC,rp_AlgoStyle(A2) ;italic text?
		BEQ	chkUnderline
d733 5
a737 6
*	;-- italicize the data in the buffer
*	    ;-- initialize variables to point to baseline
		MOVE.L	TW_STENCIL-TW_SIZE(A6),A0
		MOVE.W	TW_MODULO-TW_SIZE(A6),D4
		MOVE.W	tf_Baseline(A4),D0
		ADDQ	#2,D0		;1: the template starts one line down
d739 12
a750 14
		MULU	D4,D0
		ADD.L	D0,A0
		MOVE.W	TW_MIN-TW_SIZE(A6),D0
		ASR.W	#4,D0
		ADD.W	D0,D0		; get bytes
		ADD.W	D0,A0		; adjust start for min
		MOVE.L	A0,A1		; generate start for right shift
		SUBQ.W	#4,A1		;   right edge
		MOVE.W	tf_Baseline(A4),D6
		ADDQ	#1,D6
		MOVE.W	tf_YSize(A4),D5	; generate number of left shift
		SUB.W	D6,D5		;   lines
		LSR	#1,D4		; shift words in a line
		SUBQ	#1,D4		; DBF is count - 1
d752 2
a753 2
		MOVEQ	#2,D1		; starts shifted below baseline
		BRA.S	startLShift
d755 10
a764 7
		MOVE.W	D4,D7
		MOVE.W	D1,D2		; move count into halvsies register
		LSR.W	#1,D2		; get half of baseline distance
		MOVE.W	D2,D3		; clone distance
		ANDI.W	#$0F,D2		;   extract bit part
		LSR.W	#4,D3		;   extract word offset
		ADD.W	D3,D3		;     (which is really a byte offset)
d766 6
a771 6
		MOVE.L	(A0),D0		; get longword to shift
		LSL.L	D2,D0		; shift longword
		SWAP	D0		; get the complete word portion
		MOVE.W	D0,0(A0,D3)	;   update word in shifted position
		ADDQ.L	#2,A0		; go on to next word
		DBF	D7,shiftLLine	;
d773 1
a773 1
		ADDQ.W	#1,D1		; increment count away from baseline
d775 2
a776 2
		DBF	D5,shiftLeft	
		SUB.W	D2,TW_MIN-TW_SIZE(A6)	; update left edge
d779 2
a780 2
		MOVEQ	#0,D1		; starts at baseline
		BRA.S	startRShift
d782 11
a792 8
		MOVE.W	D4,D7
		MOVE.W	D1,D2		; move count into halvsies register
		LSR.W	#1,D2		; get half of baseline distance
		MOVE.W	D2,D3		; clone distance
		ANDI.W	#$0F,D2		;   extract bit part
		LSR.W	#4,D3		;   extract word offset
		ADD.W	D3,D3		;     (which is really a byte offset)
		NEG.W	D3		;     to the right is lower addresses
d794 5
a798 5
		MOVE.L	(A1),D0		; get longword to shift
		LSR.L	D2,D0		; shift longword
		MOVE.W	D0,2(A1,D3)	;   update word in shifted position
		SUBQ.L	#2,A1		; go on to next word
		DBF	D7,shiftRLine	;
d800 1
a800 1
		ADDQ.W	#1,D1		; increment count away from baseline
d802 2
a803 2
		DBF	D6,shiftRight	
		ADD.W	D2,TW_MAX-TW_SIZE(A6)	; update right edge
d807 3
a809 4
		MOVE.L	rp_Font(A2),A4
*	;-- check underline enhancement
		BTST	#FSB_UNDERLINED,rp_AlgoStyle(A2) ;underlined text?
		BEQ.S	templateOut
d811 3
a813 3
*	;-- underline the data in the buffer
*	    ;-- initialize variables to point to baseline
		MOVE.L	TW_STENCIL-TW_SIZE(A6),A0
d815 4
a818 4
		MOVE.W	tf_Baseline(A4),D0
		ADDQ	#2,D0		;the template starts one line down
		CMP.W	tf_YSize(A4),D0
		BGT.S	templateOut
d820 6
a825 7
		MOVE.W	TW_MODULO-TW_SIZE(A6),D4
		MULU	D4,D0
		ADD.L	D0,A0
		MOVE.W	TW_MIN-TW_SIZE(A6),D0
		ASR.W	#4,D0
		ADD.W	D0,D0		; get bytes
		ADD.W	D0,A0		; adjust start for min
d827 14
a840 17
		LSR	#1,D4		; word count from byte count
		SUBQ	#3,D4		; first, DBF, and last word not counted
*	    ;-- first word
		MOVE.L	(A0),D0
		MOVE.L	D0,D1
		MOVE.L	D0,D2
		SWAP	D1
		MOVE.W	D1,D3
		LSR.W	#1,D1
		ADD.L	D2,D2
		SWAP	D2
		OR.W	D3,D2
		OR.W	D2,D1
		NOT.W	D1
		EOR.W	D1,(A0)+
		MOVE.W	D0,D1
*	    ;-- middle words
d842 24
a865 23
		MOVE.L  (A0),D0
		MOVE.L	D0,D2
		MOVE.L	D0,D3
		LSR.W	#1,D1
		ADD.L	D2,D2
		SWAP	D2
		SWAP	D3
		OR.W	D3,D2
		OR.W	D2,D1
		NOT.W	D1
		EOR.W	D1,(A0)+
		MOVE.W	D0,D1
		DBF	D4,uMidLoop
*	    ;-- last word
		MOVE.W	(A0),D0
		MOVE.W	D0,D2
		LSR.W	#1,D1
		ADD.L	D2,D2
		OR.W	D2,D1
		OR.W	D1,D0
		NOT.W	D0
		EOR.W	D0,(A0)
*	    ;-- end of underline code
d868 6
a873 6
*	;-- output the buffer data to the raster
*	BltTemplate(source, srcX, srcMod, destRastPort,
*		    A0	    D0	  D1	  A1
*		    destX,  destY, sizeX, sizeY),  graphicsLib
*		    D2	    D3	   D4     D5	   A6
*
d875 1
a875 1
		MOVE.L	TW_STENCIL-TW_SIZE(A6),A0
d877 6
a882 5
		MOVE.W	TW_MIN-TW_SIZE(A6),D0
		MOVE.W	D0,D1
		ASR.W	#4,D1
		ADD.W	D1,D1		; get bytes
		ADD.W	D1,A0		    ;adjust source for min
d884 2
a885 3
		MOVE.W	TW_MODULO-TW_SIZE(A6),D1
		ADD.W	D1,A0
		EXT.L	D1
d887 1
a887 1
		MOVE.L	A2,A1		    ;  destRastPort
d889 3
a891 3
		MOVE.W	rp_cp_x(A2),D2	    ; get destX
		ADD.W	D0,D2		    ; adjusted for srcX
		EXT.L	D2
d893 3
a895 3
		MOVE.W	rp_cp_y(A2),D3	    ;get destY
		SUB.W	tf_Baseline(A4),D3  ;  adjusted for even baselines
		EXT.L	D3
d897 4
a900 4
		MOVE.W	TW_MAX-TW_SIZE(A6),D4	;get sizeX + 1
		SUB.W	D0,D4
		EXT.L	D4
		AND.L	#$0F,D0		    ; mask srcX
d902 2
a903 2
		MOVE.W	tf_YSize(A4),D5	    ;get sizeY
		EXT.L	D5
a904 2
		MOVE.L	A6,-(A7)
		MOVE.L	(A6),A6
a905 1
		MOVE.L	(A7)+,A6
d908 2
a909 3
		MOVE.W	rp_cp_x(A2),D0		;update current position
		ADD.W	TW_CP-TW_SIZE(A6),D0	;
		MOVE.W	D0,rp_cp_x(A2)		;
d911 11
a921 9
		MOVEQ	#0,D0
		MOVE.W	TW_STENCILSIZE-TW_SIZE(A6),D0
		MOVE.L	rp_TmpRas(A2),D2
		BEQ.S	freeTemplate
		MOVE.L	D2,A0
		MOVE.L	tr_RasPtr(A0),D2
		BEQ.S	freeTemplate
		CMP.L	tr_Size(A0),D0
		BLE.S	unlock
d923 1
d925 2
a926 5
		MOVE.L	TW_STENCIL-TW_SIZE(A6),A1
		MOVE.L	A6,-(A7)
		MOVE.L	(A6),A6
		BSR	FreeMustMem
		MOVE.L	(A7)+,A6
d928 1
d930 6
a935 6
		MOVE.L	rp_Layer(A2),D0
		BEQ.S	noUnlock
		MOVE.L	D0,A5
		UNLK	A6
		CALLGFX	UnlockLayerRom
		BRA.S	labelrts
d937 4
a940 5
noUnlock:
		UNLK	A6
labelrts:
		MOVEM.L (A7)+,D2-D7/A2-A5
		RTS
d942 1
a942 1
		END
@
