head     39.7;
branch   ;
access   ;
symbols  rel39_24:39.6 rel39_18:39.6 rel39_97:39.6 rel39_90:39.6 rel39_89:39.5 rel39_82:39.4 rel39_76:39.4 rel39_71:39.2 rel39_65:39.2 rel39_64:39.2 rel39_61:39.2 rel39_60:39.2 rel39_55:39.2 rel39_47:39.1 rel39_39:39.1 rel39_38:39.1 rel39_37:39.1 rel39_35:39.0 rel39_34:39.0 V37_30:37.6 V37_29:37.6 V37_28:37.6 V37_25:37.6 V37_22:37.5 V37_21:37.5 V37_20:37.5 V37_19:37.5 V37_17:37.5 V37_15:37.5 V37_14:37.5 V37_13:37.3 V37_12:37.3 V37_11:37.3 V37_10:37.1 V37_9:37.1 V37_7:37.1 V37_6:37.1 V37_5:37.1 V37_4:37.1 V37_3:37.1 V37_2:37.0 V37_1:37.0 V36_209:36.42 V36_208:36.42 V36_207:36.42 V36_205:36.42 V36_203:36.42 V36_202:36.42 V36_201:36.42 V36_200:36.42 V36_199:36.42 V36_198:36.42 V36_196:36.41 V36_195:36.41 V36_194:36.41 V36_193:36.41 V36_192:36.41 V36_191:36.41 V36_190:36.41 V36_189:36.41 V36_188:36.41 V36_187:36.41 V36_186:36.41 V36_185:36.41 V36_184:36.40 V36_183:36.40 V36_182:36.40 V36_181:36.40;
locks    ; strict;
comment  @*   @;


39.7
date     93.05.27.16.27.30;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     92.09.17.15.12.40;  author spence;  state Exp;
branches ;
next     39.5;

39.5
date     92.09.08.14.53.12;  author chrisg;  state Exp;
branches ;
next     39.4;

39.4
date     92.07.09.12.12.19;  author spence;  state Exp;
branches ;
next     39.3;

39.3
date     92.07.08.11.04.59;  author darren;  state Exp;
branches ;
next     39.2;

39.2
date     92.04.07.18.25.40;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     92.02.21.14.14.40;  author chrisg;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.35.58;  author chrisg;  state Exp;
branches ;
next     37.6;

37.6
date     91.04.15.15.58.48;  author spence;  state Exp;
branches ;
next     37.5;

37.5
date     91.02.12.16.10.09;  author spence;  state Exp;
branches ;
next     37.4;

37.4
date     91.02.12.15.51.58;  author spence;  state Exp;
branches ;
next     37.3;

37.3
date     91.02.06.16.45.25;  author spence;  state Exp;
branches ;
next     37.2;

37.2
date     91.02.04.19.36.34;  author spence;  state Exp;
branches ;
next     37.1;

37.1
date     91.01.18.17.21.20;  author spence;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.28.58;  author spence;  state Exp;
branches ;
next     36.43;

36.43
date     91.01.07.14.30.38;  author spence;  state Exp;
branches ;
next     36.42;

36.42
date     90.11.09.17.44.45;  author spence;  state Exp;
branches ;
next     36.41;

36.41
date     90.09.27.11.29.50;  author bart;  state Exp;
branches ;
next     36.40;

36.40
date     90.07.18.11.05.44;  author bart;  state Exp;
branches ;
next     36.39;

36.39
date     90.06.13.17.27.37;  author kodiak;  state Exp;
branches ;
next     36.38;

36.38
date     90.06.12.18.45.07;  author kodiak;  state Exp;
branches ;
next     36.37;

36.37
date     90.06.12.18.23.02;  author kodiak;  state Exp;
branches ;
next     36.36;

36.36
date     90.06.04.17.41.12;  author kodiak;  state Exp;
branches ;
next     36.35;

36.35
date     90.05.31.18.50.32;  author kodiak;  state Exp;
branches ;
next     36.34;

36.34
date     90.05.27.12.27.34;  author kodiak;  state Exp;
branches ;
next     36.33;

36.33
date     90.05.21.20.28.28;  author kodiak;  state Exp;
branches ;
next     36.32;

36.32
date     90.05.10.14.10.19;  author kodiak;  state Exp;
branches ;
next     36.31;

36.31
date     90.05.10.09.55.02;  author kodiak;  state Exp;
branches ;
next     36.30;

36.30
date     90.05.05.16.46.30;  author kodiak;  state Exp;
branches ;
next     36.29;

36.29
date     90.05.04.14.30.11;  author kodiak;  state Exp;
branches ;
next     36.28;

36.28
date     90.04.13.11.52.26;  author kodiak;  state Exp;
branches ;
next     36.27;

36.27
date     90.04.05.10.30.33;  author kodiak;  state Exp;
branches ;
next     36.26;

36.26
date     90.04.02.12.59.24;  author kodiak;  state Exp;
branches ;
next     36.25;

36.25
date     90.03.08.15.01.55;  author kodiak;  state Exp;
branches ;
next     36.24;

36.24
date     90.02.28.14.46.54;  author kodiak;  state Exp;
branches ;
next     36.23;

36.23
date     90.02.18.18.02.18;  author kodiak;  state Exp;
branches ;
next     36.22;

36.22
date     90.01.29.12.31.28;  author kodiak;  state Exp;
branches ;
next     36.21;

36.21
date     90.01.29.11.22.14;  author kodiak;  state Exp;
branches ;
next     36.20;

36.20
date     90.01.23.19.47.32;  author kodiak;  state Exp;
branches ;
next     36.19;

36.19
date     90.01.23.19.28.13;  author kodiak;  state Exp;
branches ;
next     36.18;

36.18
date     90.01.23.16.55.51;  author kodiak;  state Exp;
branches ;
next     36.17;

36.17
date     90.01.10.16.13.57;  author kodiak;  state Exp;
branches ;
next     36.16;

36.16
date     89.12.12.16.51.32;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     89.11.22.17.03.48;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     89.11.02.18.37.49;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     89.09.19.14.42.56;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     89.09.06.11.20.56;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     89.09.05.10.42.00;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     89.09.04.17.20.42;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     89.09.04.16.28.07;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     89.08.09.15.10.48;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     89.07.25.16.51.10;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     89.06.05.14.15.48;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.05.05.11.23.21;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     88.09.15.16.42.47;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     88.07.15.16.23.20;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     88.03.06.11.00.24;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     88.03.04.11.38.34;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     88.03.04.10.50.49;  author kodiak;  state Exp;
branches ;
next     35.1;

35.1
date     87.10.19.16.27.49;  author kodiak;  state Exp;
branches ;
next     35.0;

35.0
date     87.10.19.16.19.47;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


39.7
log
@Autodoc for AddFont() shows that the tf_Accessors in 0.
@
text
@**
**	$Id: font.asm,v 39.6 92/09/17 15:12:40 spence Exp Locker: spence $
**
**      font and text attribute specification
**
**      (C) Copyright 1985-1989 Commodore-Amiga, Inc.
**          All Rights Reserved
**

	SECTION		graphics

**	Includes

	INCLUDE		"exec/types.i"
	INCLUDE		"exec/nodes.i"
	INCLUDE		"exec/lists.i"
	INCLUDE		"exec/ports.i"
	INCLUDE		"exec/interrupts.i"
	INCLUDE		"exec/libraries.i"
	INCLUDE		"exec/memory.i"
	INCLUDE		"exec/ables.i"
	INCLUDE		"exec/alerts.i"
	INCLUDE		"exec/macros.i"

	INCLUDE		"/gfxbase.i"
	INCLUDE		"/rastport.i"

	INCLUDE		"utility/tagitem.i"
	INCLUDE		"diskfont/diskfonttag.i"

	INCLUDE		"text.i"

	INCLUDE		"txtdata.i"
	INCLUDE		"macros.i"


**	Exports

	XDEF		_OpenFont
	XDEF		_CloseFont
	XDEF		_AddFont
	XDEF		_RemFont
	XDEF		_AskFont
	XDEF		_SetFont
	XDEF		_AskSoftStyle
	XDEF		_SetSoftStyle
	XDEF		_FontExtent
	XDEF		_ExtendFont
	XDEF		_StripFont
	XDEF		_WeighTAMatch


**	Imports

	XLVO	Alert			; Exec
	XLVO	AllocMem		;
	XLVO	AllocVec		;
	XLVO	Enqueue			;
	XLVO	FindName		;
	XLVO	FreeMem			;
	XLVO	FreeVec			;
	XLVO	Permit			;
	XLVO	ReplyMsg		;

	XLVO	AskSoftStyle		; Graphics
	XLVO	ExtendFont		;
	XLVO	StripFont		;
	XLVO	WeighTAMatch		;

	XLVO	GetTagData		; Utility
	XLVO	UDivMod32		;
	XLVO	UMult32			;


**	Assumptions
	IFNE	tfe_MatchWord
	FAIL	"tfe_MatchWord not zero, recode"
	ENDC


******* graphics.library/OpenFont ************************************
*
*   NAME
*	OpenFont -- Get a pointer to a system font.
*
*   SYNOPSIS
*	font = OpenFont(textAttr)
*	D0              A0
*
*	struct TextFont *OpenFont(struct TextAttr *);
*
*   FUNCTION
*	This function searches the system font space for the graphics
*	text font that best matches the attributes specified.  The
*	pointer to the font returned can be used in subsequent
*	SetFont and CloseFont calls.  It is important to match this
*	call with a corresponding CloseFont call for effective
*	management of ram fonts.
*
*   INPUTS
*	textAttr - a TextAttr or TTextAttr structure that describes the
*	           text font attributes desired.
*
*   RESULT
*	font is zero if the desired font cannot be found.  If the named
*	font is found, but the size and style specified are not
*	available, a font with the nearest attributes is returned.
*
*   BUGS
*	Prior to V39 this function would return a TextFont pointer
*	for any font which matched exactly in Y size, regardless of
*	differences in DPI, or DotSize.
*
*	As part of fixing this bug it is REQUIRED that you use pass the
*	same TextAttr (or TTextAttr) to this function that was used when
*	OpenDiskFont() was called.
*
*	OpenFont(), and OpenDiskFont() use WeighTAMatch() to measure
*	how well two fonts match.  WeightTAMatch() was a public function
*	in graphics.library V36-V37; it is now a system PRIVATE function
*	as of V39.
*
*   SEE ALSO
*	CloseFont()  SetFont()
*	diskfont.library/OpenDiskFont  graphics/text.h
*	intuition/intuition.h
*
**********************************************************************
*
*   REGISTERS
*	d0
*	d1	font style and flags
*	d2	font and text attribute style and flags xored
*	d3	working weight
*	d4	best weight so far
*	d5	bit mask
*	d6	longword index

*	a0
*	a1
*	a2	
*	a3	font under consideration (name matches)
*	a4	font with best weight so far
*	a5	textAttr parameter

_OpenFont:
		movem.l d2-d6/a2-a5,-(a7)
		move.l	a0,a5

		move.l	gb_ExecBase(a6),a0
		FORBID	a0,NOFETCH

		move.l	(a5),a1		; ta_Name(a5) get name

		lea	gb_TextFonts(a6),a0
		LINKEXE	FindName

*	    ;------ check if name exists

		tst.l	d0
		beq.s	openRts
		moveq	#0,d4		; no previous best match

testMatch:
		move.l	d0,a3

		move.l	d0,a0
		suba.l	a1,a1
		JSRLIB	ExtendFont
		tst.l	d0
		beq.s	noBetter

		move.l	a5,a0
		lea	tf_YSize-ta_YSize(a3),a1
		move.l	tf_Extension(a3),a2
		move.l	tfe_Tags(a2),a2
		JSRLIB	WeighTAMatch

	    ;-- Check private return to see if caller asked for
	    ;-- DPI or DotSize (means they are Tag Aware)

		;--	check for request aspect
		tst.w	d1
		bne.s	opf_DPISpecified

	    ;------ otherwise only accept match of a font which has
	    ;------ not been marked a duplicate.

		move.l	tf_Extension(a3),a0
		btst	#TE0B_DUPLICATE,tfe_Flags0(a0)
		beq.s	opf_DPISpecified	; acceptable

		moveq	#00,d0			; not acceptable


opf_DPISpecified:

		cmp.w	#MAXFONTMATCHWEIGHT,d0
		bne.s	notPerfect

		move.l	a3,a4
		bra.s	gotBest

notPerfect:
		cmp.w	d0,d4		; compare with best weight
		bge.s	noBetter	;   not bigger, already have best
		move.w	d0,d4
		move.l	a3,a4

noBetter:
	    ;------ check for any more of this name
		move.l	a3,a0		; start with this font
		move.l	(a5),a1		; ta_Name(a5) get name
		LINKEXE FindName

		tst.l	d0
		bne.s	testMatch

		move.l	d4,d0		; check if acceptable font
		beq.s	openRts

gotBest:
		addq.w	#1,tf_Accessors(a4)
		move.l	a4,d0


openRts:
		move.l	gb_ExecBase(a6),a0
		PERMIT	a0,NOFETCH

		movem.l (a7)+,d2-d6/a2-a5
		rts


******* graphics.library/CloseFont ***************************************
*
*   NAME
*	CloseFont -- Release a pointer to a system font.
*
*   SYNOPSIS
*	CloseFont(font)
*	          A1
*
*	void CloseFont(struct TextFont *);
*
*   FUNCTION
*	This function indicates that the font specified is no longer
*	in use.  It is used to close a font opened by OpenFont, so
*	that fonts that are no longer in use do not consume system
*	resources.
*	
*   INPUTS
*	font -	a font pointer as returned by OpenFont() or OpenDiskFont()
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	OpenFont()  diskfont.library/OpenDiskFont  graphics/text.h
*
**************************************************************************
_CloseFont:
		subq.w	#1,tf_Accessors(a1)
		bgt.s	cfRts
		btst	#FPB_REMOVED,tf_Flags(a1)
		bne.s	rfClosedRemove

cfRts:
		rts


******* graphics.library/AddFont *************************************
*
*   NAME
*	AddFont -- add a font to the system list
*
*   SYNOPSIS
*	AddFont(textFont)
*	        A1
*
*	void AddFont(struct TextFont *);
*
*   FUNCTION
*	This function adds the text font to the system, making it
*	available for use by any application.  The font added must be
*	in public memory, and remain until successfully removed.
*
*   INPUTS
*	textFont - a TextFont structure in public ram.
*
*   RESULT
*
*   NOTES
*	This function will set the tf_Accessors to 0.
*
*   BUGS
*
*   SEE ALSO
*	SetFont()  RemFont()  graphics/text.h
*
**********************************************************************
_AddFont:
		bclr.b	#FPB_REMOVED,tf_Flags(a1)
		clr.w	tf_Accessors(a1)
		move.b	#NT_FONT,LN_TYPE(a1)
		lea	gb_TextFonts(a6),a0
		move.l	a6,-(a7)
		move.l	gb_ExecBase(a6),a6
		FORBID
		CALLLVO	Enqueue
		CALLLVO	Permit
		move.l	(a7)+,a6
		rts


******* graphics.library/RemFont *************************************
*
*   NAME
*	RemFont -- Remove a font from the system list.
*
*   SYNOPSIS
*	RemFont(textFont)
*	        A1
*
*	void RemFont(struct TextFont *);
*
*   FUNCTION
*	This function removes a font from the system, ensuring that
*	access to it is restricted to those applications that
*	currently have an active pointer to it: i.e. no new SetFont
*	requests to this font are satisfied.
*
*   INPUTS
*	textFont - the TextFont structure to remove.
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	SetFont()  AddFont()  graphics/text.h
*
**********************************************************************
_RemFont:
		;-- check quickly if this font has been compiled yet
		move.l	tf_Extension(a1),d1
		beq.s	rfRemoveOK
		move.l	d1,a0
		cmp.w	#TE_MATCHWORD,(a0)	; tfe_MatchWord(a0)
		bne.s	rfRemoveOK
		cmp.l	tfe_BackPtr(a0),a1
		bne.s	rfRemoveOK
		btst	#TE0B_NOREMFONT,tfe_Flags0(a0)
		bne.s	rfRts

rfRemoveOK:
		bset	#FPB_REMOVED,tf_Flags(a1)
		bne.s	rfRedundant

		move.b	#NT_MESSAGE,LN_TYPE(a1)

		move.l	gb_ExecBase(a6),a0
		FORBID	a0,NOFETCH

		;--	REMOVE w/o destroying a1
		move.l	(a1),d0
		move.l	LN_PRED(a1),a0
		move.l	d0,(a0)
		exg	d0,a0
		move.l	d0,LN_PRED(a0)

		move.l	gb_ExecBase(a6),a0
		PERMIT	a0,NOFETCH

rfRedundant:
		tst.w	tf_Accessors(a1)
		bgt.s	rfRts

rfClosedRemove:
		move.l	a1,-(a7)
		move.l	a1,a0
		CALLLVO	StripFont
		move.l	(a7)+,a1

		LINKEXE	ReplyMsg	; reply font

rfRts:
		rts


******* graphics.library/AskFont *************************************
*
*   NAME
*	AskFont -- get the text attributes of the current font
*
*   SYNOPSIS
*	AskFont(rp, textAttr)
*	        A1  A0
*
*	void AskFont(struct RastPort *, struct TextAttr *);
*
*   FUNCTION
*	This function fills the text attributes structure with the
*	attributes of the current font in the RastPort.
*
*   INPUTS
*	rp       - the RastPort from which the text attributes are
*	           extracted
*	textAttr - the TextAttr structure to be filled.  Note that
*	           there is no support for a TTextAttr.
*
*   RESULT
*	The textAttr structure is filled with the RastPort's text
*	attributes.
*
*   BUGS
*
*   SEE ALSO
*	graphics/text.h
*
**********************************************************************
_AskFont:
		move.l	rp_Font(a1),a1
		move.l	LN_NAME(a1),ta_Name(a0)
		;------ copy over longword attributes
		move.l	tf_YSize(a1),ta_YSize(a0)
		rts


******* graphics.library/SetFont ******************************************
*
*   NAME
*	SetFont -- Set the text font and attributes in a RastPort.
*
*   SYNOPSIS
*	SetFont(rp, font)
*	        A1   A0
*
*	void SetFont(struct RastPort *, struct TextFont *);
*
*   FUNCTION
*	This function sets the font in the RastPort to that described
*	by font, and updates the text attributes to reflect that
*	change.  This function clears the effect of any previous
*	soft styles.
*
*   INPUTS
*	rp   - the RastPort in which the text attributes are to be changed
*	font - pointer to a TextFont structure returned from OpenFont()
*	       or OpenDiskFont()
*
*   RESULT
*
*   NOTES
*	This function had previously been documented that it would
*	accept a null font.  This practice is discouraged.
*	o   Use of a RastPort with a null font with text routines has
*	    always been incorrect and risked the guru.
*	o   Keeping an obsolete font pointer in the RastPort is no more
*	    dangerous than keeping a zero one there.
*	o   SetFont(rp, 0) causes spurious low memory accesses under
*	    some system software releases.
*
*	As of V36, the following Amiga font variants are no longer
*	directly supported:
*	    fonts with NULL tf_CharSpace and non-NULL tf_CharKern.
*	    fonts with non-NULL tf_CharSpace and NULL tf_CharKern.
*	    fonts with NULL tf_CharSpace and NULL tf_CharKern with
*		a tf_CharLoc size component greater than tf_XSize.
*	Attempts to SetFont these one of these font variants will
*	cause the system to modify your font to make it acceptable.
*
*   BUGS
*	Calling SetFont() on in-code TextFonts (ie fonts not
*	OpenFont()ed) will result in a loss of 24 bytes from
*	the system as of V36.
*	This can be resolved by calling StripFont().
*
*   SEE ALSO
*	OpenFont()  StripFont()
*	diskfont.library/OpenDiskFont()  graphics/text.h
*
**********************************************************************
_SetFont:
		move.l	a1,d0
		beq.s	_SetFont.	; spence - Jan 18 1991

		movem.l	a2-a3,-(a7)
		move.l	a0,a2		; save font
		move.l	a1,a3		; save rp

		move.l	a0,d0		; tst.l	a0
		beq.s	sfNullFont


		suba.l	a1,a1
		CALLLVO	ExtendFont
		tst.l	d0
		beq.s	sfDone

		move.w	tf_YSize(a2),rp_TxHeight(a3)
		move.l	tf_XSize(a2),rp_TxWidth(a3)	; and Baseline

sfNullEntry:
		clr.b	rp_AlgoStyle(a3)
		move.l	a2,rp_Font(a3)

sfDone:
		movem.l	(a7)+,a2-a3
_SetFont.
		rts

sfNullFont:
		clr.w	rp_TxHeight(a3)
		clr.l	rp_TxWidth(a3)			; and Baseline
		bra.s	sfNullEntry


******* graphics.library/AskSoftStyle ********************************
*
*   NAME
*	AskSoftStyle -- Get the soft style bits of the current font.
*
*   SYNOPSIS
*	enable = AskSoftStyle(rp)
*	D0                    A1
*
*	ULONG AskSoftStyle(struct RastPort *);
*
*   FUNCTION
*	This function returns those style bits of the current font
*	that are not intrinsic in the font itself, but
*	algorithmically generated.  These are the bits that are
*	valid to set in the enable mask for SetSoftStyle().
*
*   INPUTS
*	rp - the RastPort from which the font and style	are extracted.
*
*   RESULTS
*	enable - those bits in the style algorithmically generated.
*	         Style bits that are not defined are also set.
*
*   BUGS
*
*   SEE ALSO
*	SetSoftStyle()  graphics/text.h
*
**********************************************************************
_AskSoftStyle:
		move.l	rp_Font(a1),d0
		beq.s	assRts1			* no Font - just assume nothing is algorithmic - spence Jan  2 1991
		move.l	d0,a0
		moveq	#0,d0
		move.b	tf_Style(a0),d0
		btst	#FSB_UNDERLINED,d0
		bne.s	assRts
		move.b	tf_Baseline(a0),d1
		addq	#2,d1
		cmp.w	tf_YSize(a0),d1
		ble.s	assRts
		bset	#FSB_UNDERLINED,d0
assRts:
		not.l	d0
assRts1:
		rts


******* graphics.library/SetSoftStyle ********************************
*
*   NAME
*	SetSoftStyle -- Set the soft style of the current font.
*
*   SYNOPSIS
*	newStyle = SetSoftStyle(rp, style, enable)
*	D0                      A1  D0     D1
*
*	ULONG SetSoftStyle(struct RastPort *, ULONG, ULONG);
*
*   FUNCTION
*	This function alters the soft style of the current font.  Only
*	those bits that are also set in enable are affected.  The
*	resulting style is returned, since some style request changes
*	will not be honored when the implicit style of the font
*	precludes changing them.
*
*   INPUTS
*	rp     - the RastPort from which the font and style
*	         are extracted.
*	style  - the new font style to set, subject to enable.
*	enable - those bits in style to be changed.  Any set bits here
*	         that would not be set as a result of AskSoftStyle will
*	         be ignored, and the newStyle result will not be as
*	         expected. 
*
*   RESULTS
*	newStyle - the resulting style, both as a result of previous
*	           soft style selection, the effect of this function,
*	           and the style inherent in the set font.
*
*   BUGS
*
*   SEE ALSO
*	AskSoftStyle()  graphics/text.h
*
**********************************************************************
_SetSoftStyle:
		move.l	d2,-(a7)
		move.l	rp_Font(a1),d2
		beq.s	nofont			* force resulting style to 0 - spence Jan  2 1991
		moveq	#0,d2
		movem.l	d0-d1/a1,-(a7)
		CALLLVO	AskSoftStyle
		move.b	d0,d2
		movem.l	(a7)+,d0-d1/a1
		move.l	rp_Font(a1),a0
		and.b	d2,d1
		move.b	rp_AlgoStyle(a1),d2
		and.b	d1,d0
		not.b	d1
		and.b	d1,d2
		or.b	d0,d2
		move.b	d2,rp_AlgoStyle(a1)
		or.b	tf_Style(a0),d2
nofont:
		move.l	d2,d0

		move.l	(a7)+,d2
		rts


******* graphics.library/FontExtent **********************************
*
*   NAME
*	FontExtent -- get the font attributes of the current font (V36)
*
*   SYNOPSIS
*	FontExtent(font, fontExtent)
*	           A0    A1
*
*	void FontExtent(struct TextFont *, struct TextExtent *);
*
*   FUNCTION
*	This function fills the text extent structure with a bounding
*	(i.e. maximum) extent for the characters in the specified font.
*
*   INPUTS
*	font       - the TextFont from which the font metrics are extracted.
*	fontExtent - the TextExtent structure to be filled.
*
*   RESULT
*	fontExtent is filled.
*
*   NOTES
*	The TextFont, not the RastPort, is specified -- unlike
*	TextExtent(), effect of algorithmic enhancements is not
*	included, nor does te_Width include any effect of
*	rp_TxSpacing.  The returned te_Width will be negative only
*	when FPF_REVPATH is set in the tf_Flags of the font -- the
*	effect of left-moving characters is ignored for the width of
*	a normal font, and the effect of right-moving characters is
*	ignored if a REVPATH font.  These characters will, however,
*	be reflected in the bounding extent.
*
*   SEE ALSO
*	TextExtent()  graphics/text.h
*
**********************************************************************
_FontExtent:
		movem.l	d2-d5/a2-a4,-(a7)

		move.l	tf_CharLoc(a0),a2
		move.l	tf_CharSpace(a0),a3
		move.l	tf_CharKern(a0),a4
		addq.l	#2,a2
		moveq	#0,d3		; CP bound
		move.l	a4,d4		; bit min
		beq.s	feInitBitMax	; is zero if no kern
		move.w	#32767,d4	; bit min
feInitBitMax:
		move.w	#-32768,d5	; bit max

		;-- get character loop counter
		clr.w	d0
		move.b	tf_HiChar(a0),d0
		sub.b	tf_LoChar(a0),d0

		;-- bounding loop
feLoop:
		move.l	a4,d1		; tst.l a4 & clr.l d1 if zero
		beq.s	feAddBitSize
		move.w	(a4)+,d1	; Kern
		cmp.w	d1,d4		; min
		ble.s	feAddBitSize
		move.w	d1,d4
feAddBitSize:
		move.w	d1,d2		; save kern for CP bound later
		add.w	(a2),d1		; Loc bit size
		addq.l	#4,a2
		cmp.w	d1,d5		; max
		bge.s	feBoundCP
		move.w	d1,d5
feBoundCP:
		move.l	a3,d1
		beq.s	feConstantSpace
		add.w	(a3)+,d2	; Space
		bra.s	feDirection
feConstantSpace:
		add.w	tf_XSize(a0),d2
feDirection:
		btst	#FPB_REVPATH,tf_Flags(a0)
		bne.s	feRevPath
		cmp.w	d2,d3
		bge.s	feNextChar
		move.w	d2,d3
		bra.s	feNextChar
feRevPath:
		cmp.w	d2,d3
		ble.s	feNextChar
		move.w	d2,d3
feNextChar:
		dbf	d0,feLoop

		move.w	d3,te_Width(a1)
		move.w	d4,te_Extent+ra_MinX(a1)
		subq.w	#1,d5
		move.w	d5,te_Extent+ra_MaxX(a1)
		move.w	tf_YSize(a0),d0
		move.w	d0,te_Height(a1)
		move.w	tf_Baseline(a0),d1
		neg.w	d1
		move.w	d1,te_Extent+ra_MinY(a1)
		add.w	d0,d1
		subq.w	#1,d1
		move.w	d1,te_Extent+ra_MaxY(a1)

		movem.l	(a7)+,d2-d5/a2-a4
		rts


******* graphics.library/ExtendFont *******************************************
*
*   NAME
*	ExtendFont -- ensure tf_Extension has been built for a font (V36)
*
*   SYNOPSIS
*	success = ExtendFont(font, fontTags)
*	D0                   A0    A1
*
*	ULONG ExtendFont(struct TextFont *, struct TagItem *);
*
*	success = ExtendFontTags(font, Tag1, ...)  (V39)
*
*	ULONG ExtendFontTags(struct TextFont *, ULONG, ...);
*
*   FUNCTION
*	To extend a TextFont structure.
*
*   INPUTS
*	font - The font to extend.
*	fontTags - An optional taglist.  If NULL, then a default is used.
*	           Currently, the only tag defined is TA_DeviceDPI.
*
*   RESULT
*	success - 1 if the TextFont was properly extended, else 0.
*
*   NOTES
*	The varargs stub was missing from amiga.lib until V39.
*
*   SEE ALSO
*	graphics/text.h
*
*******************************************************************************
_ExtendFont:
		;-- check quickly if this font has been compiled yet
		move.l	a1,d0
		move.l	tf_Extension(a0),d1
		beq.s	efUncompiled
		move.l	d1,a1
		cmp.w	#TE_MATCHWORD,(a1)	; tfe_MatchWord(a1)
		bne.s	efUncompiled
		cmp.l	tfe_BackPtr(a1),a0
		bne.s	efUncompiled
		moveq	#1,d0
		rts


efDefaultTags:
		dc.l	0
		dc.l	efTallDotTags
		dc.l	efWideDotTags
		dc.l	0

efTallDotTags:
		dc.l	TA_DeviceDPI,(100<<16)!50
		dc.l	TAG_DONE

efWideDotTags:
		dc.l	TA_DeviceDPI,(50<<16)!100
		dc.l	TAG_DONE


;
;   d0	temporary, e.g. origin
;   d1	temporary, e.g. size
;   d2	temporary, e.g. fontTags, #8, space
;   d3	kern
;   d4	decrementing character count
;   d5	tf_XSize
;   d6	tf_Modulo*8
;
;   a0	
;   a1	
;   a2	
;   a3	TextFont
;   a4	TextFontExtension
;
efUncompiled:
		movem.l	d2-d6/a2-a4,-(a7)
		move.l	a0,a3		; save font
		move.l	d0,d2		; and fontTags

		addq.w	#1,tf_Accessors(a3)	; ensure not expunged

		;-- get memory for TextFontExtension
		moveq	#tfe_SIZEOF,d0
		move.l	#MEMF_PUBLIC!MEMF_CLEAR,d1
		LINKEXE	AllocMem

		tst.l	d0
		beq	efDone

		;-- initialize TextFontExtension
		move.l	d0,a4
		move.w	#TE_MATCHWORD,(a4)	; tfe_MatchWord(a4)
		move.l	a3,tfe_BackPtr(a4)
		move.l	tf_Extension(a3),tfe_OrigReplyPort(a4)
		move.l	d2,tfe_Tags(a4)
		bne.s	efCompileFlags0

		;-- use default tags if TALLDOT or WIDEDOT
		move.b	tf_Flags(a3),d0
		and.w	#FPF_TALLDOT!FPF_WIDEDOT,d0
		lsr.w	#FPB_TALLDOT-2,d0
		move.l	efDefaultTags(pc,d0.w),tfe_Tags(a4)

efCompileFlags0:
		moveq	#8,d2
		move.w	tf_XSize(a3),d5
		move.w	tf_Modulo(a3),d6
		lsl.w	#3,d6			; pixel width: origin bound
		;-- look to see if it's a byte font
		btst	#FPB_PROPORTIONAL,tf_Flags(a3)
		bne.s	efChkKernless
		btst	#FSB_COLORFONT,tf_Style(a3)
		bne.s	efChkKernless
		cmp.w	d2,d5
		bne.s	efChkKernless
		;--	check for byte fonts
		tst.l	tf_CharKern(a3)
		bne.s	efChkKernless
		tst.l	tf_CharSpace(a3)
		bne.s	efChkKernless

		;-- perform the longest bytefont test
		moveq	#0,d4
		move.b	tf_HiChar(a3),d4
		sub.b	tf_LoChar(a3),d4
		move.l	tf_CharLoc(a3),a0
efChkSize8:
		move.w	(a0)+,d0		; check for start location
		cmp.w	d6,d0			;   within strike font
		bge.s	efChkKernless
		andi.w	#7,d0			;   and byte offset
		bne.s	efChkKernless
		cmp.w	(a0)+,d2		; check for byte size
		dbne	d4,efChkSize8
		bne.s	efChkKernless

		;-- this is a bytefont (which is also kernless)
		move.b	#TE0F_KERNLESS!TE0F_BYTECELL,tfe_Flags0(a4)
		bra.s	efCompiled

	    ;-- look harder to see if it's a kernless font
efChkKernless:
		moveq	#0,d4
		move.b	tf_HiChar(a3),d4
		sub.b	tf_LoChar(a3),d4
		move.l	tf_CharLoc(a3),a0
		move.l	tf_CharKern(a3),d0
		beq.s	efNoKern
		move.l	tf_CharSpace(a3),d1
		beq	efOSpace

		;-- both
		move.l	d0,a1
		move.l	d1,a2
efBothLoop:
		move.w	(a0)+,d0	; origin
		move.w	(a0)+,d1	; size
		move.w	(a2)+,d2	; space
		move.w	(a1)+,d3	; kern
		bmi.s	efNotKernless	; negative kern
		add.w	d2,d3
		cmp.w	d3,d5
		bne.s	efNotKernless	; width != tf_XSize
		cmp.w	d1,d2
		blt.s	efNotKernless	; space < bit width
		tst.w	d1
		beq.s	efBothDBF	; no width, so don't care where
		add.w	d1,d0
		cmp.w	d6,d0
efBothDBF:
		dbgt	d4,efBothLoop
		ble.s	efKernless

		;--	bad offset but kernless so far
efBadKernlessOffset:
		tst.w	d4		; for undefined character?
;13Jun90    for EA's ShangHai's gene.font -- don't obsolete it.
;13Jun90	bne	efObsoleteFont
		bne.s	efKernless
		;--	patch bad undefined character by making it the same
		;	as the HiChar itself
		subq.b	#1,tf_HiChar(a3)
		bra.s	efKernless


		;-- no kern & ?
efNoKern:
		tst.l	tf_CharSpace(a3)
		bne.s	efOKern

		;-- neither
efNeitherLoop:
		move.w	(a0)+,d0	; origin
		move.w	(a0)+,d1	; size
		beq.s	efNeitherDBF	; no width, so don't care where
		cmp.w	d1,d5
		blt.s	efOKernSpace	; space < bit width
		add.w	d1,d0
		cmp.w	d6,d0
efNeitherDBF:
		dbgt	d4,efNeitherLoop
		bgt.s	efBadKernlessOffset

efKernless:
		move.b	#TE0F_KERNLESS,tfe_Flags0(a4)

efCompiled:
		move.l	a4,tf_Extension(a3)
**************  removed for 2.03 -- bart ****************************
*	
* the problem was that old programs are initializing textattr structs
* with the first n bytes of a textfont, to force it to remain open.
* however they were getting the tagged bit set in the style so that
* an improper parsing of non-existant tags was taking place.
*	
*		bset	#FSB_TAGGED,tf_Style(a3)
*	
**************  removed for 2.03 -- bart ****************************
		moveq	#1,d0

efDone:
		subq.w	#1,tf_Accessors(a3)

		movem.l	(a7)+,d2-d6/a2-a4
		rts


efnkLoop:
		move.w	(a0)+,d0
		move.w	(a0)+,d1
efNotKernless:
		tst.w	d1
		beq.s	efnkDBF		; no width, so don't care where
		add.w	d1,d0
		cmp.w	d6,d0
efnkDBF:
		dbgt	d4,efnkLoop
		ble.s	efCompiled

		tst.w	d4		; for undefined character?
;13Jun90    for EA's ShangHai's gene.font -- don't obsolete it.
;13Jun90	bne.s	efObsoleteFont
		bne.s	efCompiled
		;--	patch bad undefined character by making it the same
		;	as the HiChar itself
		subq.b	#1,tf_HiChar(a3)
		bra.s	efCompiled


efOKernSpace:
		bsr.s	efOAllocVec
		move.l	a0,tfe_OFontPatchK(a4)
		move.l	a0,tf_CharKern(a3)
		;--	default kern is zero so no initialization needed

efOSpace:
		bsr.s	efOAllocVec
		move.l	a0,tfe_OFontPatchS(a4)
		move.l	a0,tf_CharSpace(a3)
		move.w	d4,d1
efOBuildSpace:
		move.w	d5,(a0)+
		dbf	d1,efOBuildSpace
		bra.s	efOPatched

efOKern:
		bsr.s	efOAllocVec
		move.l	a0,tfe_OFontPatchK(a4)
		move.l	a0,tf_CharKern(a3)
		;--	default kern is zero so no initialization needed

efOPatched:
		move.l	tf_CharLoc(a3),a0
		move.l	tf_CharKern(a3),a1
		move.l	tf_CharSpace(a3),a2
		bra	efBothLoop

efOAllocVec:
		moveq	#0,d4
		move.b	tf_HiChar(a3),d4
		sub.b	tf_LoChar(a3),d4
		move.l	d4,d0
		addq.l	#1,d0
		add.l	d0,d0
		move.l	#MEMF_CLEAR,d1
		LINKEXE	AllocVec
		move.l	d0,a0
		move.l	(a7)+,a1
		tst.l	d0
		beq.s	efObsoleteFont
		jmp	(a1)

		;-- font is obsolete and unpatchable
efObsoleteFont:
		movem.l	d7/a6,-(a7)
		move.l	#AN_ObsoleteFont,d7
		move.l	gb_ExecBase(a6),a6
		CALLLVO	Alert
		move.l	tfe_OFontPatchS(a4),a1
		CALLLVO	FreeVec
		move.l	tfe_OFontPatchK(a4),a1
		CALLLVO	FreeVec
		move.l	a4,a1
		moveq	#tfe_SIZEOF,d0
		CALLLVO	FreeMem
		movem.l	(a7)+,d7/a6
		moveq	#0,d0
		bra	efDone


******* graphics.library/StripFont ***********************************
*
*   NAME
*	StripFont -- remove the tf_Extension from a font (V36)
*
*   SYNOPSIS
*	StripFont(font)
*	          A0
*
*	VOID StripFont(struct TextFont *);
*
**********************************************************************
_StripFont:
		;-- check if this font has been compiled
		move.l	tf_Extension(a0),d1
		beq.s	sfRts
		move.l	d1,a1
		cmp.w	#TE_MATCHWORD,(a1)	; tfe_MatchWord(a1)
		bne.s	sfRts
		cmp.l	tfe_BackPtr(a1),a0
		bne.s	sfRts

		movem.l	a2/a3/a6,-(a7)
		move.l	a0,a2
		move.l	a1,a3
		move.l	gb_ExecBase(a6),a6
		;--	put original reply port back in font message
		move.l	tfe_OrigReplyPort(a3),tf_Extension(a2)
		move.l	tfe_OFontPatchS(a3),d0
		beq.s	sfUnPatchK
		clr.l	tf_CharSpace(a2)
		move.l	d0,a1
		CALLLVO	FreeVec
sfUnPatchK:
		move.l	tfe_OFontPatchK(a3),d0
		beq.s	sfFreeTFE
		clr.l	tf_CharKern(a2)
		move.l	d0,a1
		CALLLVO	FreeVec
sfFreeTFE:
		move.l	a3,a1
		moveq	#tfe_SIZEOF,d0
		CALLLVO	FreeMem
		movem.l	(a7)+,a2/a3/a6

sfRts:
		rts


*****i* graphics.library/WeighTAMatch ********************************
*
*   NAME
*	WeighTAMatch -- Get a measure of how well two fonts match. (V36)
*
*   SYNOPSIS
*	weight = WeighTAMatch(reqTextAttr, targetTextAttr, targetTags)
*	D0                    A0           A1              A2
*	D1
*
*	WORD WeighTAMatch(struct TTextAttr *, struct TextAttr *,
*	     struct TagItem *);
*
*	weight = WeighTAMatchTags(reqTextAttr, targetTextAttr, Tag1, ...) (V39)
*
*	WORD WeighTAMatchTags(struct TTextAttr *,struct TextAttr *, ULONG, ...)
*
*   FUNCTION
*	This function provides a metric to describe how well two fonts
*	match.  This metric ranges from MAXFONTMATCHWEIGHT (perfect match)
*	through lower positive numbers to zero (unsuitable match).
*
*   INPUTS
*	reqTextAttr    - the text attributes requested.
*	targetTextAttr - the text attributes of a potential match.
*	targetTags     - tags describing the extended target attributes, or
*	                 zero if not available.
*
*	The [t]ta_Name fields of the [T]TextAttr structures are not used.
*
*	The tags affect the weight only when both a) the reqTextAttr
*	has the FSF_TAGGED bit set in ta_Style, and b) targetTags is
*	not zero.  To fairly compare two different weights, the inclusion
*	or exclusion of tags in the weighing must be the same for both.
*
*   RESULTS
*	weight -- a positive weight describes suitable matches, in
*	      increasing desirability.  MAXFONTMATCHWEIGHT is a perfect
*	      match.  A zero weight is an unsuitable match.
*
*	D1 -- 1-DPI specified in request.  2-DotSize specified in request.
*	      3-DPI and DotSize specified in request.  0-Neither
*	      specified in request.  To be used as a TRUE/FALSE value
*	      for OpenFont() to decide if caller is TAG aware.
*
*   BUGS
*	Prior to V39, this function did not factor differences in
*	font DPI if the Y size of the reqTextAttr, and targetTextAttr
*	matched.  This function also failed to compared DPI if the
*	target did not have a TA_DeviceDPI tag.  As of V39, this function
*	assumes the target has a 1:1 DPI if the TA_DeviceDPI tag is
*	absent.   As of V39, this function will return an imperfect
*	match if the OT_DotSize tag of the source font does not exactly
*	match the request.
*
*	This function is now private; it is meant to be used by diskfont
*	and OpenFont() only.
*
*   SEE ALSO
*	OpenFont()
*
**********************************************************************
*
*   REGISTERS
*	d2	temp
*	d3	temp
*	d4	flag (00-no tags; 01-DPI specified; 02-DOT specified; 03-BOTH)
*	d5	DPI error

*	a0	passed in
*	a1	passed in
*	a2	passed in


WEIGHTSHIFT	EQU	5		; * 32
WEIGHTXMAX	EQU	(1<<WEIGHTSHIFT)

wfmGetDPI:
		beq.s	wfmDefaultTag	; test D1
		move.l	#TA_DeviceDPI,d3
wfmGetTag:

		movem.l	a0-a1/a6,-(a7)
		move.l	d1,a0
		move.l	d0,d1		; set default
		move.l	d3,d0		; tag to search for
		move.l	gb_UtilBase(a6),a6
		JSRLIB	GetTagData
		movem.l	(a7)+,a0-a1/a6
wfmDefaultTag:
		rts

wfmGetDOT:
		moveq	#00,d0		; set default
		tst.l	d1		; test D1
		beq.s	wfmDefaultTag
		move.l	#OT_DotSize,d3
		bra.s	wfmGetTag

_WeighTAMatch:
		movem.l	d2-d5,-(a7)

		;-- check for aspect effect

		moveq	#00,d5		; Set Default DPI error (no-error)

		moveq	#00,d4		; assume DPI/DOT tags not requested

		;--	check for target aspect
		move.l	#$00200020,d0	; default is 1:1
		move.l	a2,d1
		bsr.s	wfmGetDPI
		move.l	d0,d2

		;--	check for request aspect
		btst	#FSB_TAGGED,tta_Style(a0)
		beq.s	wfmGetYComponent
		moveq	#00,d0		; default is DPI tag not specified
		move.l	tta_Tags(a0),d1
		bmi.s	wfmGetYComponent	; kludge for LSE

		bsr.s	wfmGetDPI

		;--	calculate aspect correction

		move.l	d0,d1
		beq.s	wfmNoAspect	; No DPI specified?

		moveq	#01,d4		; DPI specified flag

		swap	d0
		mulu	d2,d0		; Req XDPI * Target YDPI
		beq.s	wfmNoAspect
		swap	d2
		mulu	d2,d1		; Req YDPI * Target XDPI
		beq.s	wfmNoAspect
		cmp.l	d0,d1

		;--	ratio MUST be <= 1:1
		;--	Divisor must be >= Dividend (BCC is unsigned BGE)

		bcc.s	wfmCalcAspectCorrection
		exg	d0,d1

wfmCalcAspectCorrection:

		;--     Calculate a DPI error value of <= a minimum
		;--	Y error.  A DPI error of 0 means no error, or
		;--	perfect match.  A DPI error of 1 means the
		;--	DPI of the TARGET and REQUEST are very close,
		;--	but not perfect.  A DPI error of WEIGHTMAX is
		;--     possible, but unlikely.  It requires comparing
		;--	a 1:1 DPI font with a 1:33, or 33:1 DPI font.
		;--	In actual use such distorted fonts are rare, and
		;--	we can assume that somewhere on the font list
		;--	a perfect match exists, so the calculated weight
		;--	for this comparison is essentially ignored.
		;
		;--     ratio of <= 1:1 * WEIGHTXMAX:1 MUST be <= WEIGHTXMAX
		;--

		lsl.l	#WEIGHTSHIFT,d0
		movem.l	a0-a1/a6,-(a7)
		move.l	gb_UtilBase(a6),a6
		JSRLIB	UDivMod32
		movem.l	(a7)+,a0-a1/a6

		;--	transform WEIGHTXMAX-0 into 0-WEIGHTXMAX; this value
		;--	is then subtracted from MAXFONTMATCHWEIGHT along with
		;--	some integer multiple of WEIGHTXMAX if there is any
		;--	difference in Y size.
		
		moveq	#WEIGHTXMAX,d5
		sub.l	d0,d5

wfmNoAspect:

		;--	Check OT_DotSize tag for diffs (FSF_TAGGED already
		;--	known to be TRUE)

		move.l	tta_Tags(a0),d1
		bsr.s	wfmGetDOT
		move.l	d0,d2
		beq.s	wfmGetYComponent

		addq.w	#02,d4		; OT_DotSize tag specified in request

		;--	OT_DotSize requested, see if the font has one, and
		;--	compare for exact match

		move.l	a2,d1
		bsr.s	wfmGetDOT
		
                cmp.l	d0,d2		; dotsize must match exactly
		beq.s	wfmGetYComponent

		addq.l	#1,d5		; increment error by fudge factor
					; to indicate imperfect match		
wfmGetYComponent:
		;-- get Y effect
		moveq	#0,d1
		move.w	ta_YSize(a0),d1
		ble.s	wfmFail		; if YSize <= 0 bail out here
		move.w	ta_YSize(a1),d2
		ble.s	wfmFail		; if YSize <= 0 bail out here

		sub.w	d2,d1		; req - target
		bpl.s	wfmApplyAspectCorrection ; target <= req?

		;	target is larger than req
		neg.w	d1
		lsl.l	#2,d1		; (e.g., -128, not -32, for every pixel larger)

wfmApplyAspectCorrection:

		lsl.l	#WEIGHTSHIFT,d1	; (Y diff * MAX) + 0-MAX for X diff
		add.l	d5,d1		

	; start with largest

		move.l	#MAXFONTMATCHWEIGHT,d0
		sub.l	d1,d0

		;-- involve weights for style & flags
		move.w	ta_Style(a0),d2	; and ta_Flags(a0)
		move.w	ta_Style(a1),d3	; and ta_Flags(a1)
		lea	wfmR1T0Weights(pc),a0
		lea	wfmR0T1Weights(pc),a1

		;--	ensure "designed" is set appropriately for target
		move.w	d3,d1
		and.w	#FPF_ROMFONT!FPF_DISKFONT,d1
		beq.s	wfmBitWeights

		or.w	#FPF_DESIGNED,d3

wfmBitWeights:
		moveq	#0,d1
		eor.w	d2,d3

		;--	loop while some bits differ
wfmBitLoop:
		beq.s	wfmDone
		bpl.s	wfmbNext
		tst.w	d2		; check current (MSB) of req
		bpl.s	wfmbR0T1

		;--	    set in request, clear in target
		move.w	(a0),d1
		bra.s	wfmbDiff

		;--	    clear in request, set in target
wfmbR0T1:
		move.w	(a1),d1
wfmbDiff:
		sub.l	d1,d0

wfmbNext:
		addq.l	#2,a0
		addq.l	#2,a1
		add.w	d2,d2
		add.w	d3,d3
		bra.s	wfmBitLoop

wfmDone:
		tst.l	d0
		bge.s	wfmRts

wfmFail:
		moveq	#0,d0		; collapse all unsuitable to 0

wfmRts:
		move.w	d4,d1		; return PRIVATE

		movem.l	(a7)+,d2-d5
		rts



;	range of numbers for size difference:
;	    y differences: 32..<8K would be nice>?
;
;			,color,,extended,italic,bold,underlined
;			,designed,propor,wide,tall,revpath,diskfont,romfont
wfmR1T0Weights:
		dc.w	0,0,0,0,0,16,8,4
		dc.w	0,MAXFONTMATCHWEIGHT,0,0,0,MAXFONTMATCHWEIGHT,0,0

wfmR0T1Weights:
		dc.w	0,0,0,0,0,1024,512,2048
		dc.w	0,0,0,0,0,MAXFONTMATCHWEIGHT,0,0


	END
@


39.6
log
@Clean up the autodocs
@
text
@d2 1
a2 1
**	$Id: font.asm,v 39.5 92/09/08 14:53:12 chrisg Exp Locker: spence $
d293 3
@


39.5
log
@kludge for LSE.
@
text
@d2 1
a2 1
**	$Id: font.asm,v 39.4 92/07/09 12:12:19 spence Exp Locker: chrisg $
d738 1
a738 1
******* graphics.library/ExtendFont **********************************
d764 3
d770 1
a770 1
**********************************************************************
@


39.4
log
@macro name changes to assemble properly.
@
text
@d2 1
a2 1
**	$Id: font.asm,v 39.3 92/07/08 11:04:59 darren Exp Locker: spence $
d1216 2
@


39.3
log
@Replace WeighTAMatch() with code which compares for differences
in DPI, and/or DotSize ratio.  WeightTAMatch() is now documented as
system private.  Now returns a PRIVATE return in D1 which OpenFont()
uses to determine if caller is tag aware.  If not, then OpenFont()
will ignore fonts marked as DUPLICATES.  Non-Tag aware callers therefore
always get the same TextFont back, even if there is a better match
added to the font list by some other application.
@
text
@d2 1
a2 1
**	$Id: font.asm,v 39.2 92/04/07 18:25:40 spence Exp Locker: darren $
d23 1
d156 1
a156 1
		LINKEXEGFX	FindName
d214 1
a214 1
		LINKEXEGFX FindName
@


39.2
log
@Updated Autodocs for WeighTAMatch and ExtendFont, to show VarArgs
versions.
@
text
@d2 1
a2 1
**	$Id: font.asm,v 39.1 92/02/21 14:14:40 chrisg Exp Locker: spence $
d27 3
d108 14
d125 1
d155 1
a155 1
		LINKEXE FindName
d158 1
d168 1
a168 1
		CALLLVO	ExtendFont
d176 18
a193 1
		CALLLVO	WeighTAMatch
d195 2
d213 2
a214 1
		LINKEXE FindName
d225 1
d1096 1
a1096 1
******* graphics.library/WeighTAMatch ********************************
d1104 1
d1136 18
d1158 37
d1196 2
a1197 1
		movem.l	d2-d3,-(a7)
d1200 4
d1205 2
a1206 2
		move.l	a2,d0
		beq.s	wfmNoAspect
a1208 1
		beq.s	wfmNoAspect
d1212 3
a1214 2
		beq.s	wfmNoAspect
		move.l	tta_Tags(a0),d0
d1218 1
d1220 4
d1231 5
a1235 1
		ble.s	wfmCalcAspectCorrection
d1237 1
d1239 17
a1255 1
		lsl.l	#5,d0		; (want 5 bits of fraction)
d1258 1
a1258 1
		CALLLVO	UDivMod32
a1259 1
		bra.s	wfmGetYComponent
d1261 7
a1267 9
wfmGetDPI:
		movem.l	a0-a1/a6,-(a7)
		move.l	d0,a0
		move.l	#TA_DeviceDPI,d0
		moveq	#0,d1
		move.l	gb_UtilBase(a6),a6
		CALLLVO	GetTagData
		movem.l	(a7)+,a0-a1/a6
		rts
d1270 10
a1279 1
		moveq	#32,d0		; no aspect correction (1.00000 binary)
d1281 11
d1301 1
a1301 1
		bpl.s	wfmApplyAspectCorrection ; target smaller than req
d1305 1
a1305 1
		lsl.l	#2,d1		; -128, not -32, for every pixel larger
d1308 5
a1312 4
		movem.l	a0-a1/a6,-(a7)
		move.l	gb_UtilBase(a6),a6
		CALLLVO	UMult32
		movem.l	(a7)+,a0-a1/a6
d1314 1
a1314 2
		move.l	d0,d1
		move.l	#MAXFONTMATCHWEIGHT,d0	; start w/ the largest weight
d1366 3
a1368 1
		movem.l	(a7)+,d2-d3
@


39.1
log
@ made use utilbase and changed to use local include file.
@
text
@d2 1
a2 1
**	$Id: font.asm,v 39.0 91/08/21 17:35:58 chrisg Exp Locker: chrisg $
d708 15
d1067 4
@


39.0
log
@Bumped
@
text
@d2 1
a2 1
**	$Id: font.asm,v 37.6 91/04/15 15:58:48 spence Exp Locker: chrisg $
d24 2
a25 2
	INCLUDE		"graphics/gfxbase.i"
	INCLUDE		"graphics/rastport.i"
d1111 1
a1111 1
		move.l	gb_UtilityBase(a6),a6
d1121 1
a1121 1
		move.l	gb_UtilityBase(a6),a6
d1146 1
a1146 1
		move.l	gb_UtilityBase(a6),a6
@


37.6
log
@Autodoc change - OpenFont() XTextAttr to TTextAttr
@
text
@d2 1
a2 1
**	$Id: font.asm,v 37.5 91/02/12 16:10:09 spence Exp Locker: spence $
@


37.5
log
@autodocs.
@
text
@d2 1
a2 1
**	$Id: font.asm,v 37.4 91/02/12 15:51:58 spence Exp Locker: spence $
d97 1
a97 1
*	textAttr - a TextAttr or XTextAttr structure that describes the
@


37.4
log
@autodoc
@
text
@d2 1
a2 1
**	$Id: font.asm,v 37.3 91/02/06 16:45:25 spence Exp Locker: spence $
d707 3
@


37.3
log
@AutoDoc changes to SetFont()
@
text
@d2 1
a2 1
**	$Id: font.asm,v 37.2 91/02/04 19:36:34 spence Exp Locker: spence $
d84 1
a84 1
*	d0		  a0
d86 1
a86 1
*	struct TextFont *OpenFont( struct TextAttr * );
d98 1
a98 1
*	    text font attributes desired.
d100 1
a100 1
*   RESULTS
d106 2
a107 1
*	CloseFont SetFont diskfont.library/OpenDiskFont graphics/text.h
d194 1
a194 1
******* graphics.library/CloseFont ***********************************
d201 1
a201 1
*		   a1
d203 1
a203 1
*	void CloseFont( struct TextFont * );
d206 2
a207 2
*	This function indicates that the font specified is no longer 
*	in use.  It is used to close a font opened by OpenFont, so 
d212 1
a212 1
*	font -	a font pointer as returned by OpenFont or OpenDiskFont
d214 2
d219 1
a219 1
*	OpenFont diskfont.library/OpenDiskFont graphics/text.h
d221 1
a221 1
**********************************************************************
d239 1
a239 1
*		a1
d241 1
a241 1
*	void AddFont( struct TextFont * );
d251 2
d256 1
a256 1
*	SetFont RemFont graphics/text.h
d280 1
a280 1
*	        a1
d282 1
a282 1
*	void RemFont( struct TextFont * );
d293 2
d298 1
a298 1
*	SetFont AddFont graphics/text.h
d355 1
a355 1
*		a1	  a0
d357 1
a357 1
*	void AskFont( struct RastPort *, struct TextAttr * );
d364 2
a365 1
*	rp - the RastPort from which the text attributes are extracted
d367 1
a367 1
*		as there is no support for a TTextAttr.
d369 4
d387 1
a387 1
******* graphics.library/SetFont *************************************
d394 1
a394 1
*		a1   a0
d396 1
a396 1
*	void SetFont( struct RastPort *, struct TextFont * );
d405 3
a407 3
*	rp - the RastPort in which the text attributes are to be changed
*	font - pointer to a TextFont structure returned from OpenFont
*	    or OpenDiskFont
d409 2
d427 1
a427 1
*	Attempts to SetFont these one of these font variants will 
d431 4
a434 4
*   Calling SetFont() on in-code TextFonts (ie fonts not 
*   OpenFont()ed) will result in a loss of 24 bytes from
*   the system as of V36.
*   This can be resolved by calling StripFont().
d437 2
a438 2
*	OpenFont() diskfont.library/OpenDiskFont() graphics/text.h
*   StripFont()
d483 1
a483 1
*	d0                    a1
d485 1
a485 1
*	ULONG AskSoftStyle( struct RastPort * );
d490 2
a491 2
*	algorithmically generated.  These are the bits that are 
*	valid to set in the enable mask for SetSoftStyle
d497 2
a498 2
*	enable - those bits in the style algorithmically generated
*	    Style bits that are not defined are also set.
d503 1
a503 1
*	SetSoftStyle	graphics/text.h
d532 1
a532 1
*	d0                      a1  d0     d1
d534 1
a534 1
*	ULONG SetSoftStyle( struct RastPort *, ULONG, ULONG );
d544 3
a546 2
*	rp - the RastPort from which the font and style	are extracted.
*	style - the new font style to set, subject to enable.
d548 3
a550 3
*	    that would not be set as a result of AskSoftStyle will
*	    be ignored, and the newStyle result will not be as
*	    expected. 
d554 2
a555 2
*	    soft style selection, the effect of this function, and
*	    the style inherent in the set font.
d560 1
a560 1
*	AskSoftStyle graphics/text.h
d595 1
a595 1
*	           a0    a1
d597 1
a597 1
*	void FontExtent( struct TextFont *, struct TextExtent * );
d604 1
a604 1
*	font - the TextFont from which the font metrics are extracted.
d607 3
d622 1
a622 1
*	graphics/text.h
d706 1
a706 1
*	ULONG ExtendFont( struct TextFont *, struct TagItem * );
d998 1
a998 1
*	VOID StripFont( struct TextFont * );
d1045 1
a1045 1
*	d0                      a0           a1              a2
d1047 2
a1048 2
*	WORD WeighTAMatch( struct TTextAttr *, struct TextAttr *,
*		struct TagItem * );
d1056 1
a1056 1
*	reqTextAttr - the text attributes requested.
d1058 2
a1059 2
*	targetTags - tags describing the extended target attributes, or
*	    zero if not available.
d1070 2
a1071 2
*	    increasing desirability.  MAXFONTMATCHWEIGHT is a perfect
*	    match.  A zero weight is an unsuitable match.
d1074 1
a1074 1
*	OpenFont
@


37.2
log
@AutoDocs
@
text
@d2 1
a2 1
**	$Id: font.asm,v 37.1 91/01/18 17:21:20 spence Exp Locker: spence $
d416 6
d423 2
a424 1
*	OpenFont diskfont.library/OpenDiskFont graphics/text.h
@


37.1
log
@SetFont() now checks for NULL rastport pointer
@
text
@d2 1
a2 1
**	$Id: font.asm,v 37.0 91/01/07 15:28:58 spence Exp Locker: spence $
d569 1
a569 1
*	FontExtent -- get the font attributes of the current font
d675 1
a675 1
*	ExtendFont -- ensure the tf_Extension has been built for a font
d967 1
a967 1
*	StripFont -- remove the tf_Extension from a font
@


37.0
log
@initial switchover from V36
@
text
@d2 1
a2 1
**	$Id: font.asm,v 36.43 91/01/07 14:30:38 spence Exp Locker: spence $
d421 3
d446 1
@


36.43
log
@Remove enforcer hit if Ask/SetSoftStyle() called with rp_Font -> NULL.
@
text
@d2 1
a2 1
**	$Id: font.asm,v 36.42 90/11/09 17:44:45 spence Exp Locker: spence $
@


36.42
log
@fixed problem with AddFont() - it now clears FPF_REMOVED flag.
@
text
@d2 1
a2 1
**	$Id: font.asm,v 36.41 90/09/27 11:29:50 bart Exp Locker: spence $
d482 3
a485 1
		move.l	rp_Font(a1),a0
d496 1
d539 2
d555 1
@


36.41
log
@removed textfont reliance on tf_Styles TAGGED bit
@
text
@d2 1
a2 1
**	$Id: font.asm,v 36.40 90/07/18 11:05:44 bart Exp Locker: bart $
d255 1
@


36.40
log
@fix setsoftstyle not to use a2 erroneously
@
text
@d2 1
a2 1
**	$Id: font.asm,v 36.39 90/06/13 17:27:37 kodiak Exp Locker: bart $
d851 10
a860 1
		bset	#FSB_TAGGED,tf_Style(a3)
@


36.39
log
@no longer declares fonts with trash character data as obsolete
@
text
@d2 1
a2 1
**	$Id: font.asm,v 36.38 90/06/12 18:45:07 kodiak Exp Locker: kodiak $
d548 1
a548 1
		or.b	tf_Style(a2),d2
@


36.38
log
@optimize a branch
@
text
@d2 1
a2 1
**	$Id: font.asm,v 36.37 90/06/12 18:23:02 kodiak Exp Locker: kodiak $
d819 3
a821 1
		bne	efObsoleteFont
d874 3
a876 1
		bne.s	efObsoleteFont
@


36.37
log
@add and implement TF0._NOREMFONT
@
text
@d2 1
a2 1
**	$Id: font.asm,v 36.36 90/06/04 17:41:12 kodiak Exp Locker: kodiak $
d140 1
a140 1
		beq	openRts
@


36.36
log
@fix ExtendFont again -- check that kern+space == size for KERNLESS
@
text
@d2 1
a2 1
**	$Id: font.asm,v 36.35 90/05/31 18:50:32 kodiak Exp Locker: kodiak $
d294 12
@


36.35
log
@fix determination of obsolete fonts
@
text
@d2 1
a2 1
**	$Id: font.asm,v 36.34 90/05/27 12:27:34 kodiak Exp Locker: kodiak $
d690 15
d706 1
a706 1
		movem.l	d2-d4/a2-a4,-(a7)
d708 1
a708 1
		move.l	d0,d3		; and fontTags
d725 1
a725 1
		move.l	d3,tfe_Tags(a4)
d735 4
a738 2
		move.w	tf_Modulo(a3),d4
		lsl.w	#3,d4			; pixel width: origin bound
d744 1
a744 1
		cmpi.w	#8,tf_XSize(a3)
d753 3
a755 4
		moveq	#8,d2
		moveq	#0,d3
		move.b	tf_HiChar(a3),d3
		sub.b	tf_LoChar(a3),d3
d759 1
a759 1
		cmp.w	d4,d0			;   within strike font
d764 1
a764 1
		dbne	d3,efChkSize8
d773 3
a775 3
		moveq	#0,d3
		move.b	tf_HiChar(a3),d3
		sub.b	tf_LoChar(a3),d3
d788 2
a789 2
		move.w	(a2)+,d2 
		tst.w	(a1)+
d791 3
d797 1
a797 1
		beq.s	efBothLoop	; no width, so don't care where
d799 3
a801 2
		cmp.w	d4,d0
		dbgt	d3,efBothLoop
d806 1
a806 1
		tst.w	d3		; for undefined character?
a819 1
		move.w	tf_XSize(a3),d2
d821 4
a824 3
		move.w	(a0)+,d0
		move.w	(a0)+,d1
		cmp.w	d1,d2
a825 2
		tst.w	d1
		beq.s	efNeitherLoop	; no width, so don't care where
d827 3
a829 2
		cmp.w	d4,d0
		dbgt	d3,efNeitherLoop
d843 1
a843 1
		movem.l	(a7)+,d2-d4/a2-a4
d852 1
a852 1
		beq.s	efnkLoop	; no width, so don't care where
d854 3
a856 2
		cmp.w	d4,d0
		dbgt	d3,efnkLoop
d859 1
a859 1
		tst.w	d3		; for undefined character?
d877 1
a877 2
		move.w	tf_XSize(a3),d0
		move.w	d3,d1
d879 1
a879 1
		move.w	d0,(a0)+
d896 4
a899 4
		moveq	#0,d3
		move.b	tf_HiChar(a3),d3
		sub.b	tf_LoChar(a3),d3
		move.l	d3,d0
@


36.34
log
@fixes mislabelling valid fonts as obsolete
@
text
@d2 1
a2 1
**	$Id: font.asm,v 36.33 90/05/21 20:28:28 kodiak Exp Locker: kodiak $
d778 1
a778 1
		dbne	d3,efBothLoop
d807 1
a807 1
		dbne	d3,efNeitherLoop
d833 1
a833 1
		dbne	d3,efnkLoop
@


36.33
log
@protects ExtendFont by ensuring font access count is non-zero during its
AllocMem
@
text
@d2 1
a2 1
**	$Id: font.asm,v 36.32 90/05/10 14:10:19 kodiak Exp Locker: kodiak $
d781 2
a782 2
		dbge	d3,efBothLoop
		blt.s	efKernless
d810 2
a811 2
		dbge	d3,efNeitherLoop
		bge.s	efBadKernlessOffset
d836 2
a837 2
		dbge	d3,efnkLoop
		blt.s	efCompiled
@


36.32
log
@fix check for charloc in bounds to ignore loc of zero width data
@
text
@d2 1
a2 1
**	$Id: font.asm,v 36.31 90/05/10 09:55:02 kodiak Exp Locker: kodiak $
d695 2
d822 2
a824 1
efORts:
@


36.31
log
@Fixes bad kernless test in ExtendFont
Finds and fix fonts w/ bad undefined characters at ExtendFont time.
@
text
@d2 1
a2 1
**	$Id: font.asm,v 36.30 90/05/05 16:46:30 kodiak Exp Locker: kodiak $
d768 3
a770 3
		move.w	(a0)+,d0
		move.w	(a0)+,d1
		move.w	(a2)+,d2
d775 1
a775 1
		tst.w	d0
d804 1
a804 1
		tst.w	d0
d829 1
a829 1
		tst.w	d0
@


36.30
log
@non $4 based Forbid/Permit pairs
fix RemFont call of StripFont
@
text
@d2 1
a2 1
**	$Id: font.asm,v 36.29 90/05/04 14:30:11 kodiak Exp Locker: kodiak $
d691 1
a691 1
		movem.l	d2/a2-a4,-(a7)
d693 1
a693 1
		move.l	d0,d2		; and fontTags
d708 1
a708 1
		move.l	d2,tfe_Tags(a4)
d718 2
d734 4
a737 4
		moveq	#8,d0
		moveq	#0,d2
		move.b	tf_HiChar(a3),d2
		sub.b	tf_LoChar(a3),d2
d740 4
a743 2
		move.w	(a0)+,d1		; check for byte start location
		andi.w	#7,d1
d745 2
a746 2
		cmp.w	(a0)+,d0		; check for byte size
		dbne	d2,efChkSize8
d751 1
a751 1
		bra	efCompiled
d755 3
a757 3
		moveq	#0,d2
		move.b	tf_HiChar(a3),d2
		sub.b	tf_LoChar(a3),d2
a758 1
		addq.l	#2,a0
d760 1
a760 1
		beq	efNoKern
d762 1
a762 1
		beq.s	efOSpace
d768 3
d772 9
a780 7
		bmi	efCompiled
		move.w	(a2)+,d0
		cmp.w	(a0),d0
		addq.l	#4,a1
		dblt	d2,efBothLoop
		blt	efCompiled
		bra	efKernless
d782 62
d855 1
a855 1
		move.w	d2,d1
a868 1
		addq.l	#2,a0
d871 1
a871 1
		bra.s	efBothLoop
d874 4
a877 4
		moveq	#0,d2
		move.b	tf_HiChar(a3),d2
		sub.b	tf_LoChar(a3),d2
		move.l	d2,d0
d883 1
d885 2
a886 3
		bne.s	efORts
		;-- pop call and drop thru to obsolete alert
		addq.l	#4,a7
d889 1
d903 1
a903 27
		bra.s	efDone

		;-- no kern & ?
efNoKern:
		tst.l	tf_CharSpace(a3)
		bne.s	efOKern

		;-- neither
		move.w	tf_XSize(a3),d0
efNeitherLoop:
		cmp.w	(a0),d0
		addq.l	#4,a0
		dblt	d2,efNeitherLoop
		blt	efOKernSpace

efKernless:
		move.b	#TE0F_KERNLESS,tfe_Flags0(a4)

efCompiled:
		move.l	a4,tf_Extension(a3)
		bset	#FSB_TAGGED,tf_Style(a3)
		moveq	#1,d0

efDone:
		movem.l	(a7)+,d2/a2-a4
efORts:
		rts
@


36.29
log
@SetSoftStyle was preserving a0 around the AskSoftStyle call unnecessarily
@
text
@d2 1
a2 1
**	$Id: font.asm,v 36.28 90/04/13 11:52:26 kodiak Exp Locker: kodiak $
d130 2
a131 1
		FORBID	a0
d186 2
a187 1
		PERMIT	saveFlag
d299 3
a301 1
		FORBID	a0
d309 2
a310 1
		PERMIT	saveFlag
d318 1
@


36.28
log
@use Id instead of Header for 4.x rcs
@
text
@d2 1
a2 1
**	$Id$
d518 1
a518 1
		movem.l	d0-d1/a0-a1,-(a7)
d521 1
a521 1
		movem.l	(a7)+,d0-d1/a0-a1
@


36.27
log
@fix SetFont for null fonts.
change SetFont doc to discourgage null fonts
    and redescribe actions taken for obsolete fonts
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/graphics/text/RCS/font.asm,v 36.26 90/04/02 12:59:24 kodiak Exp Locker: kodiak $
@


36.26
log
@for rcs 4.x header change
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/graphics/text/RCS/font.asm,v 36.25 90/03/08 15:01:55 kodiak Exp Locker: kodiak $
d371 1
a371 2
*	soft styles.  If font is zero, this call leaves the RastPort
*	with no font.
d379 9
d389 1
a389 1
*	supported:
d394 2
a395 2
*	Attempts to SetFont these will present the recoverable alert
*	AN_ObsoleteFont and not set the font in the RastPort.
a402 3
		move.l	a0,d0
		beq	sfNullFont

d406 4
a813 1
efObsolete:
@


36.25
log
@fix code getting length of undefined character
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.24 90/02/28 14:46:54 kodiak Exp $
@


36.24
log
@convert obsolete fonts into valid fonts automatically
fix bug in stripfont's use of a6
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.23 90/02/18 18:02:18 kodiak Exp $
d12 1
a12 1
*------ Included Files -----------------------------------------------
d33 1
a33 1
*------ System Library Functions -------------------------------------
d35 16
d71 4
a74 1
*------ Exported -----------------------------------------------------
a75 1
*------ Functions ----------------------------------------------------
a76 14
	XDEF		_OpenFont
	XDEF		_CloseFont
	XDEF		_AddFont
	XDEF		_RemFont
	XDEF		_AskFont
	XDEF		_SetFont
	XDEF		_AskSoftStyle
	XDEF		_SetSoftStyle
	XDEF		_FontExtent
	XDEF		_ExtendFont
	XDEF		_StripFont
	XDEF		_WeighTAMatch


d652 1
a652 1
		cmp.w	#TE_MATCHWORD,tfe_MatchWord(a1)
d690 1
a690 1
		move.w	#TE_MATCHWORD,tfe_MatchWord(a4)
d865 1
a865 1
		cmp.w	#TE_MATCHWORD,tfe_MatchWord(a1)
@


36.23
log
@ensure COLORFONT is not tagged as BYTECELL
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.22 90/01/29 12:31:28 kodiak Exp $
d37 1
d41 1
d728 1
a728 1
		bra.s	efCompiled
d738 1
a738 1
		beq.s	efNoKern
d740 1
a740 1
		beq.s	efObsolete
d747 1
a747 1
		bmi.s	efCompiled
d752 2
a753 2
		blt.s	efCompiled
		bra.s	efKernless
d755 46
a800 1
		;-- ((kern==0) != (space==0)) or kerning in fixed width font
d806 4
d820 1
a820 1
		bne.s	efObsolete
d828 1
a828 1
		blt.s	efObsolete	; no kerning allowed for fixed width
d840 1
d866 4
d871 14
a884 1
		move.l	tfe_OrigReplyPort(a1),tf_Extension(a0)
d887 1
@


36.22
log
@interpret TALLDOT and WIDEDOT at ExtendFont time, not at WeighTAFont time
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.21 90/01/29 11:22:14 kodiak Exp $
d699 2
@


36.21
log
@rename and move TTEXTATTR in flags to TAGGED in style
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.20 90/01/23 19:47:32 kodiak Exp $
d635 1
a635 1
*	D0                    A0    A1
d653 16
d688 1
d690 7
d994 2
a995 2
		dc.w	0,0,0,0,0,4,2,1
		dc.w	0,MAXFONTMATCHWEIGHT,256,32,32,MAXFONTMATCHWEIGHT,0,0
d999 1
a999 1
		dc.w	0,0,256,16,16,MAXFONTMATCHWEIGHT,0,0
@


36.20
log
@keep 5 bits of fraction around in aspect ratio correction
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.19 90/01/23 19:28:13 kodiak Exp $
d758 1
d823 1
a823 1
*	has the FPF_TTEXTATTR bit set in ta_Flags, and b) targetTags is
d848 1
a848 1
		btst	#FPB_TTEXTATTR,tta_Flags(a0)
@


36.19
log
@CompileFont -> ExtendFont & StripFont
weights redone so asking for tall/wide font & not getting it are worse
    than not asking for it and getting it (instead of v.v.)  this is
    so requests for topaz 9 work when asking w/ 0
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.18 90/01/23 16:55:51 kodiak Exp $
d864 1
d882 1
a882 1
		moveq	#1,d0		; no aspect correction
d893 1
a893 1
		bmi.s	wfmsLarger	; target bigger than req
d895 1
a895 5
		;	target is smaller than req
		lsl.l	#5,d1		; -32 for every pixel font is smaller
		bra.s	wfmApplyAspectCorrection

wfmsLarger:
d897 1
a897 1
		lsl.l	#7,d1		; -128 for every pixel font is larger
@


36.18
log
@first cut at TextFont tag extension (tf_Extension)
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.17 90/01/10 16:13:57 kodiak Exp $
d44 2
a45 1
	XLVO	CompileFont		;
d66 2
a67 1
	XDEF		_CompileFont
d140 2
a141 2
		lea	defaultFontTags(pc),a1
		CALLLVO	CompileFont
d143 1
a143 1
		beq.s	gotBest
d151 3
a153 4
gotWeight:
		cmp.l	d0,d4		; compare with best weight
		bge.s	gotBest		;   not bigger, already have best
		move.l	d0,d4
d155 1
d157 7
a163 1
gotBest:
d169 1
a169 1
		bne	testMatch
d174 1
d213 1
a213 1
		bgt.s	closeRts
d215 1
a215 1
		beq.s	closeRts
d217 1
a217 19
		move.l	a6,-(a7)
		move.l	gb_ExecBase(a6),a6

remFontEntry:
		move.l	tf_Extension(a1),a0

		;--	put original reply port back in font message
		move.l	tfe_OrigReplyPort(a0),tf_Extension(a1)
		move.l	a1,-(a7)	; save font
		move.l	a0,a1
		moveq	#tfe_SIZEOF,d0
		CALLLVO	FreeMem

		move.l	(a7)+,a1
		CALLLVO	ReplyMsg	; reply font

		move.l	(a7)+,a6

closeRts:
d286 2
a287 3
		move.l	a6,-(a7)
		move.l	gb_ExecBase(a6),a6
		FORBID
d289 4
a292 1
		;--	REMOVE w/o destroying A1
d299 1
a299 1
		CALLLVO	Permit
d301 1
a301 3
		move.b	#NT_MESSAGE,LN_TYPE(a1)
		bset	#FPB_REMOVED,tf_Flags(a1)

d303 1
a303 1
		bgt.s	remRts
d305 4
a308 6
		;--	did this ever compile?
		move.l	tf_Extension(a1),a0
		cmp.w	#TE_MATCHWORD,tfe_MatchWord(a0)
		bne.s	remUncompiled
		cmp.l	tfe_BackPtr(a0),a1
		beq	remFontEntry
d310 1
a310 2
remUncompiled:
		CALLLVO	ReplyMsg	; reply font
d312 1
a312 2
remRts:
		move.l	(a7)+,a6
d395 2
a396 2
		lea	defaultFontTags(pc),a1
		CALLLVO	CompileFont
d628 1
a628 1
******* graphics.library/CompileFont *********************************
d631 1
a631 1
*	CompileFont -- Set the text font and attributes in a RastPort.
d634 1
a634 1
*	success = CompileFont(font, fontTags)
d637 1
a637 1
*	ULONG CompileFont( struct TextFont *, struct TagItem * );
d640 1
a640 1
_CompileFont:
d644 1
a644 1
		beq.s	cfUncompiled
d647 1
a647 1
		bne.s	cfUncompiled
d649 1
a649 1
		bne.s	cfUncompiled
d653 1
a653 1
cfUncompiled:
d664 1
a664 1
		beq	cfDone
d675 1
a675 1
		bne.s	cfChkKernless
d677 1
a677 1
		bne.s	cfChkKernless
d680 1
a680 1
		bne.s	cfChkKernless
d682 1
a682 1
		bne.s	cfChkKernless
d690 1
a690 1
cfChkSize8:
d693 1
a693 1
		bne.s	cfChkKernless
d695 2
a696 2
		dbne	d2,cfChkSize8
		bne.s	cfChkKernless
d700 1
a700 1
		bra.s	cfCompiled
d703 1
a703 1
cfChkKernless:
d710 1
a710 1
		beq.s	cfNoKern
d712 1
a712 1
		beq.s	cfObsolete
d717 1
a717 1
cfBothLoop:
d719 1
a719 1
		bmi.s	cfCompiled
d723 3
a725 3
		dblt	d2,cfBothLoop
		blt.s	cfCompiled
		bra.s	cfKernless
d728 1
a728 1
cfObsolete:
d738 1
a738 1
		bra.s	cfDone
d741 1
a741 1
cfNoKern:
d743 1
a743 1
		bne.s	cfObsolete
d747 1
a747 1
cfNeitherLoop:
d750 2
a751 2
		dblt	d2,cfNeitherLoop
		blt.s	cfObsolete	; no kerning allowed for fixed width
d753 1
a753 1
cfKernless:
d756 1
a756 1
cfCompiled:
d760 1
a760 1
cfDone:
d765 21
a785 2
defaultFontTags:
		dc.l	TAG_DONE
d787 4
d792 4
d844 1
d899 2
a900 2
		neg.l	d1
		lsl.w	#7,d1		; -128 for every pixel font is larger
d966 1
a966 2
;	range of numbers for size differences:
;	    x differences: 8..<8K would be nice>?
d968 2
a969 1
;			compiled,color,,extended,italic,bold,underlined
d973 1
a973 1
		dc.w	0,MAXFONTMATCHWEIGHT,1,16,16,MAXFONTMATCHWEIGHT,0,0
d977 1
a977 1
		dc.w	0,0,256,32,32,MAXFONTMATCHWEIGHT,0,0
@


36.17
log
@include exec/alerts.i to get AN_ObsoleteFont
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.16 89/12/12 16:51:32 kodiak Exp $
d20 1
d36 1
d39 1
a39 1
	XLVO	Forbid			;
d44 2
a45 1
	XLVO	WeighFontMatch		;
d47 3
d51 1
d65 2
a66 1
	XDEF		_WeighFontMatch
d89 2
a90 2
*	textAttr - a TextAttr structure that describes the text font
*	    attributes desired
d113 1
a113 1
*	a2	textAttr parameter
d116 1
d119 2
a120 2
		movem.l d2-d6/a2-a4,-(a7)
		move.l	a0,a2
d124 1
a124 1
		move.l	(a2),a1		    ; ta_Name(a2) get name
d131 1
a131 1
		beq	failOpen
d137 7
a143 1
		move.l	a2,a0
d145 3
a147 2
		move.w	tf_XSize(a3),d1
		CALLLVO	WeighFontMatch
d158 1
a158 1
		move.l	(a2),a1		; ta_Name(a2) get name
d163 2
a164 2
		tst.l	d4		; check if acceptable font
		ble.s	failOpen
d170 1
a170 1
		PERMIT	qwe
d172 1
a172 1
		movem.l (a7)+,d2-d6/a2-a4
a174 3
failOpen:
		moveq	#0,d0
		bra.s	openRts
a175 1

d208 2
a209 1
		LINKEXE	ReplyMsg
d211 15
d261 1
a261 1
		CALLLVO	Forbid
d297 1
a297 1
		CALLLVO	Forbid
d314 6
a319 1
		CALLLVO	ReplyMsg
d321 3
d347 1
a347 3
*		as there is no support for an XTextAttr: you must
*		inspect the rp->TxWidth or rp->Font->tf_XSize for
*		that.
d377 3
a379 3
*	change.  If font is zero, this call leaves the RastPort
*	with no font.  This function clears the effect of any previous
*	soft styles.
a386 4
*	For V36, fonts that are programmatically cloned from another
*	font must have the tf_Style bit FSB_COMPILED clear before use.
*	That bit is set by the system -- currently by this SetFont call.
*
d401 1
a401 1
		movem.l	d2/a2-a4,-(a7)
d405 2
a406 1
		move.l	a1,a4		; save rp
d408 4
a411 5
	    ;-- check if this font has been compiled yet
		bset.b	#FSB_COMPILED,tf_Style(a0)
		beq.s	sfCompile
		btst.b	#FCBB_COMPILED,MN_LENGTH+FCBO_COMPILED(a0)
		bne	sfSetFont
d413 2
a414 2
sfCompile:
		move.w	#FCF_COMPILED,MN_LENGTH(a0)
d416 3
a418 10
	    ;-- look to see if it's a byte font
		btst	#FPB_PROPORTIONAL,tf_Flags(a0)
		bne.s	sfChkKernless
		cmpi.w	#8,tf_XSize(a0)
		bne.s	sfChkKernless
		;-- check for byte fonts
		tst.l	tf_CharKern(a0)
		bne.s	sfChkKernless
		tst.l	tf_CharSpace(a0)
		bne.s	sfChkKernless
d420 3
a422 13
		;-- perform the longest bytefont test
		moveq	#8,d0
		moveq	#0,d2
		move.b	tf_HiChar(a0),d2
		sub.b	tf_LoChar(a0),d2
		move.l	tf_CharLoc(a0),a1
sfChkSize8:
		move.w	(a1)+,d1		; check for byte start location
		andi.w	#7,d1
		bne.s	sfChkKernless
		cmp.w	(a1)+,d0		; check for byte size
		dbne	d2,sfChkSize8
		bne.s	sfChkKernless
a423 60
		;-- this is a bytefont (which is also kernless)
		move.w	#FCF_KERNLESS!FCF_BYTECELL!FCF_COMPILED,MN_LENGTH(a0)
		bra.s	sfSetFont

	    ;-- look harder to see if it's a kernless font
sfChkKernless:
		moveq	#0,d2
		move.b	tf_HiChar(a0),d2
		sub.b	tf_LoChar(a0),d2
		move.l	tf_CharLoc(a0),a1
		addq.l	#2,a1
		move.l	tf_CharKern(a0),d0
		beq.s	sfNoKern
		move.l	tf_CharSpace(a0),d1
		beq.s	sfObsolete

		;-- both
		move.l	d0,a2
		move.l	d1,a3
sfBothLoop:
		tst.w	(a2)+
		bmi.s	sfSetFont
		move.w	(a3)+,d0
		cmp.w	(a1),d0
		addq.l	#4,a1
		dblt	d2,sfBothLoop
		blt.s	sfSetFont
		bra.s	sfKernless

		;-- ((kern==0) != (space==0)) or kerning in fixed width font
sfObsolete:
		movem.l	d7/a6,-(a7)
		move.l	#AN_ObsoleteFont,d7
		move.l	gb_ExecBase(a6),a6
		jsr	_LVOAlert(a6)
		movem.l	(a7)+,d7/a6
		bra.s	sfDone

		;-- no kern & ?
sfNoKern:
		move.l	tf_CharSpace(a0),d1
		bne.s	sfObsolete

		;-- neither
		move.w	tf_XSize(a0),d0
sfNeitherLoop:
		cmp.w	(a1),d0
		addq.l	#4,a1
		dblt	d2,sfNeitherLoop
		blt.s	sfObsolete	; no kerning allowed for fixed width

sfKernless:
		move.w	#FCF_KERNLESS!FCF_COMPILED,MN_LENGTH(a0)

	    ;-- set the font in the rastport
sfSetFont:
		move.w	tf_YSize(a0),rp_TxHeight(a4)
		move.w	tf_XSize(a0),rp_TxWidth(a4)
		move.w	tf_Baseline(a0),rp_TxBaseline(a4)

d425 3
a427 2
		clr.b	rp_AlgoStyle(a4)
		move.l	a0,rp_Font(a4)
a428 3
sfDone:
		movem.l	(a7)+,d2/a2-a4
		rts
a429 1

d641 1
a641 1
******* graphics.library/WeighFontMatch ******************************
d644 1
a644 1
*	WeighFontMatch -- Get a measure of how well two fonts match. (V36)
d647 2
a648 2
*	weight = WeighFontMatch(reqTextAttr, targetTextAttr, targetX)
*	d0                      a0           a1              d1
d650 1
a650 1
*	WORD WeighFontMatch( struct XTextAttr *, struct TextAttr *, UWORD );
d652 142
d802 2
a803 2
*	targetX - the X size of a potential match, or zero if not
*	    available.
d805 1
a805 1
*	The [x]ta_Name fields of the [X]TextAttr structures are not used.
d807 4
a810 4
*	The X size affects the weight only when both a) the reqTextAttr
*	has the FPF_XTEXTATTR bit set in xta_Flags, and b) targetX is not
*	zero.  To fairly compare two different weights, the inclusion
*	of the X size must be the same for both.
d821 1
a821 1
_WeighFontMatch:
d823 1
a823 4
		move.l	#MAXFONTMATCHWEIGHT,d0	; start w/ the largest weight
		;-- check for X effect
		move.w	d1,d3
		beq.s	wfmYComponent
d825 5
a829 2
		btst	#FPB_XTEXTATTR,xta_Flags(a0)
		beq.s	wfmYComponent
d831 5
a835 5
		;--	get X effect
		move.w	xta_XSize(a0),d2
		bsr.s	wfmSize
		lsr.w	#2,d1		; X effect 1/4 of Y effect
		sub.l	d1,d0
d837 32
a868 1
wfmYComponent:
d870 2
a871 2
		move.w	xta_YSize(a0),d2
		move.w	xta_YSize(a1),d3
d873 22
a894 1
		bsr.s	wfmSize
d898 2
a899 2
		move.w	xta_Style(a0),d2	; and xta_Flags(a0)
		move.w	xta_Style(a1),d3	; and xta_Flags(a1)
a948 15

wfmSize:
		moveq	#0,d1		; req - target
		move.w	d2,d1		;
		sub.w	d3,d1		;
		bmi.s	wfmsLarger	; target bigger than req

		;	target is smaller than req
		lsl.l	#5,d1		; -32 for every pixel font is smaller
		rts

wfmsLarger:
		neg.w	d1
		lsl.l	#7,d1		; -128 for every pixel font is larger
		rts
@


36.16
log
@allow null font in SetFont
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.15 89/11/22 17:03:48 kodiak Exp $
d21 1
@


36.15
log
@formalize font obsolescence in SetFont
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.14 89/11/02 18:37:49 kodiak Exp $
d371 3
a440 1
;	move.l	a5,$c0	; catch Alert trashing a5
a445 1
;	move.l	a5,$c0	; catch Alert trashing a5
d469 2
@


36.14
log
@recode to use gb_ExecBase
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.13 89/09/19 14:42:56 kodiak Exp $
d33 2
a34 1
	XLVO	Enqueue			; Exec
d309 4
a312 1
*	textAttr - the TextAttr structure to be filled
d351 4
a354 1
*   BUGS
d356 9
d370 2
a371 5
		move.w	tf_YSize(a0),rp_TxHeight(a1)
		move.w	tf_XSize(a0),rp_TxWidth(a1)
		move.w	tf_Baseline(a0),rp_TxBaseline(a1)
		clr.b	rp_AlgoStyle(a1)
		move.l	a0,rp_Font(a1)
d373 1
a373 1
	;-- check if this font has been compiled yet
d375 3
a377 1
		bne	sfDone
d382 1
a382 1
	    ;-- look harder to see if it's a byte font
d394 4
a397 3
		moveq	#0,d0
		move.b	tf_HiChar(a0),d0
		sub.b	tf_LoChar(a0),d0
d403 2
a404 2
		cmpi.w	#8,(a1)+		; check for byte size
		dbne	d0,sfChkSize8
d409 1
a409 1
		bra.s	sfDone
a412 1
		movem.l	d2/a2/a3,-(a7)
d421 1
a421 1
		beq.s	sfKern
d428 1
a428 1
		bmi.s	sfKerned
d433 1
a433 1
		blt.s	sfKerned
d436 10
a445 12
		;-- kern and no space
sfKern:
		move.l	d0,a2
		move.w	tf_XSize(a0),d0
sfKernLoop:
		tst.w	(a2)+
		bmi.s	sfKerned
		cmp.w	(a1),d0
		addq.l	#4,a1
		dblt	d2,sfKernLoop
		blt.s	sfKerned
		bra.s	sfKernless
d450 1
a450 1
		beq.s	sfNeither
d452 1
a452 11
		;-- no kern and space
		move.l	d1,a3
sfSpaceLoop:
		move.w	(a3)+,d0
		cmp.w	(a1),d0
		addq.l	#4,a1
		dblt	d2,sfSpaceLoop
		blt.s	sfKerned
		bra.s	sfKernless

sfNeither:
d458 1
a458 1
		blt.s	sfKerned
a461 2
sfKerned:
		movem.l	(a7)+,d2/a2/a3
d463 8
d472 1
a472 44
	IFD	SETFONT_ALERTS
;
;   check for cases I want to get rid of
;
		btst.b	#FCBB_COMPILED,MN_LENGTH+FCBO_COMPILED(a0)
		bne.s	sfaChkKernSpace
		move.l	#$0200b0b1,d0
		bsr.s	sfaAlert
		bra	sfCompile

sfaChkKernSpace:
		tst.l	tf_CharKern(a0)
		beq.s	sfaNoKern
		tst.l	tf_CharSpace(a0)
		bne.s	sfaContinue
		move.l	#$0200b0b2,d0
		bsr.s	sfaAlert
		bra.s	sfaContinue

sfaNoKern:
		tst.l	tf_CharSpace(a0)
		beq.s	sfaNoSpace
		move.l	#$0200b0b3,d0
		bsr.s	sfaAlert
		bra.s	sfaContinue

sfaNoSpace:
		btst	#FCBB_KERNLESS,MN_LENGTH+FCBO_KERNLESS(a0)
		bne.s	sfaContinue
		move.l	#$0200b0b4,d0
		bsr.s	sfaAlert

sfaContinue:
		rts

sfaAlert:
		movem.l	d7/a0/a6,-(a7)
		move.l	d0,d7
		move.l	gb_ExecBase(a6),a6
	XLVO	Alert
		jsr	_LVOAlert(a6)
		movem.l	(a7)+,d7/a0/a6

	ENDC
@


36.13
log
@protect font list during OpenFont w/ Forbid/Permit
swizzle match criteria in WeighFontMatch
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.12 89/09/06 11:20:56 kodiak Exp $
a29 1
*------ Imported -----------------------------------------------------
a30 3
	XREF		_AbsExecBase


d33 5
a37 5
	XREF_EXE	Enqueue
	XREF_EXE	FindName
	XREF_EXE	Forbid
	XREF_EXE	Permit
	XREF_EXE	ReplyMsg
d39 2
a40 2
	XREF_GFX	AskSoftStyle
	XREF_GFX	WeighFontMatch
d129 1
a129 1
		CALLGFX	WeighFontMatch
d229 6
a234 3
		LINKEXE	Forbid
		LINKEXE	Enqueue
		LINKEXE	Permit
d265 3
a267 5
		LINKEXE	Forbid
		move.l	a1,-(a7)
		REMOVE	
		move.l	(a7)+,a1
		LINKEXE	Permit
d269 9
d284 1
a284 1
		LINKEXE	ReplyMsg
d287 1
d501 2
a502 2
		move.l	ABSEXECBASE,a6
	XREF_EXE Alert
d597 1
a597 1
		CALLGFX	AskSoftStyle
@


36.12
log
@MAXFONTMATCHWEIGHT defined in text.[hi]
minfontmatchweight changed to 0, not -1
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.11 89/09/05 10:42:00 kodiak Exp $
d20 1
d114 3
d156 2
d765 1
a765 1
		asr.w	#2,d1		; X effect 1/4 of Y effect
d836 1
a836 1
		lsl.l	#6,d1		; -64 for every pixel font is smaller
d841 1
a841 1
		lsl.l	#8,d1		; -256 for every pixel font is larger
d845 3
d851 2
a852 2
		dc.w	0,0,0,0,0,16,8,4
		dc.w	0,MAXFONTMATCHWEIGHT,32,32,32,MAXFONTMATCHWEIGHT,0,0
d855 2
a856 2
		dc.w	0,0,0,0,0,128,128,256
		dc.w	0,0,128,32,32,MAXFONTMATCHWEIGHT,0,0
@


36.11
log
@(fix WeighFontMatch style & flag contributions)
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.10 89/09/04 17:20:42 kodiak Exp $
d721 2
a722 2
*	match.  This metric ranges from 32767 (perfect match) through
*	lower positive numbers to negative (unsuitable match).
d739 2
a740 2
*	    increasing desirability.  32767 is a perfect match.  A
*	    negative weight is an unsuitable match.
d748 1
a748 1
		move.l	#32767,d0	; start w/ the largest weight
d813 1
a813 1
		bpl.s	wfmRts
d816 1
a816 1
		moveq	#-1,d0		; collapse all unsuitable to -1
d843 1
a843 1
		dc.w	0,32768,32,32,32,32768,0,0
d847 1
a847 1
		dc.w	0,0,128,32,32,32768,0,0
@


36.10
log
@export _WeighFontMatch for cpwrup.c
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.9 89/09/04 16:28:07 kodiak Exp $
d839 2
a840 2
;			underlined,bold,italic,extended,,color,compiled
;			romfont,diskfont,revpath,talldot,widedot,propor,design,
d842 2
a843 2
		dc.w	4,8,16,0,0,0,0,0
		dc.w	0,0,32768,32,32,32,32768,0
d846 3
a848 2
		dc.w	128,128,128,0,0,0,0,0
		dc.w	0,0,32768,32,32,128,0,0
@


36.9
log
@add WeighFontMatch, use it from OpenFont
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.8 89/08/09 15:10:48 kodiak Exp $
d59 1
@


36.8
log
@change parameters to FontExtent
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.7 89/07/25 16:51:10 kodiak Exp $
d43 1
d95 7
a101 7
*	D0
*	D1	font style and flags
*	D2	font and text attribute style and flags xored
*	D3	working weight
*	D4	best weight so far
*	D5	bit mask
*	D6	longword index
d103 5
a107 5
*	A0
*	A1
*	A2	textAttr parameter
*	A3	font under consideration (name matches)
*	A4	font with best weight so far
d110 3
a112 3
		MOVEM.L D2-D6/A2-A4,-(A7)
		MOVE.L	A0,A2
		MOVE.L	(A2),A1		    ; ta_Name(A2) get name
d114 1
a114 1
		LEA	gb_TextFonts(A6),A0
d118 3
a120 3
		TST.L	D0
		BEQ	failOpen
		MOVEQ	#0,D4		; no previous best match
d123 1
a123 12
		MOVE.L	D0,A3
		MOVE.W	tf_YSize(A3),D0	; get font height
		BEQ	gotBest
		MOVE.L	#32767,D3
		SUB.W	ta_YSize(A2),D0	; compare vs. desired height
		BGE.S	fontIsLarger
		MULS	#64,D0
		ADD.L	D0,D3		; -64 for every pixel font is smaller
		BRA.S	styleAndFlags
fontIsLarger:
		MULS	#256,D0
		SUB.L	D0,D3		; -256 for every pixel font is bigger
d125 4
a128 23
styleAndFlags:
		MOVE.W	tf_Style(A3),D1	; find differing bits in font
		MOVE.W	ta_Style(A2),D2	;   and text attribute Style and Flags
		EOR.W	D1,D2		;
		MOVEQ	#0,D5		; bit
		MOVEQ	#0,D6		; longword index
loopSF:
		BTST	D5,D2		; check if difference
		BEQ.S	nextSF		;   no, go get the next bit
		BTST	D5,D1		; check if set in font
		BEQ.S	setInTA		;   no, go get weight from tWeight
		MOVE.L	fWeight(PC,D6.W),D0
		BRA.S	subWeight
setInTA:
		MOVE.L	tWeight(PC,D6.W),D0
subWeight:
		SUB.L	D0,D3
nextSF:
		ADDQ.W	#1,D5
		CMPI.W	#16,D5
		BGE	gotWeight
		ADDQ.W	#4,D6
		BRA.S	loopSF
a129 11
tWeight:
;                       romfont,diskfont,revpath,talldot,widedot,propor,design,
		DC.L	1,1,32768,32,32,32,2,0
;                       underlined,bold,italic,extended,,color,byte
		DC.L	4,8,16,0,0,0,0,0
fWeight:
;                       romfont,diskfont,revpath,talldot,widedot,propor,design,
		DC.L	1,1,32768,32,32,128,2,0
;                       underlined,bold,italic,extended,,color,byte
		DC.L	128,128,128,0,0,0,0,0

d131 4
a134 4
		CMP.L	D3,D4		; compare with best weight
		BGE.S	gotBest		;   not bigger, already have best
		MOVE.L	D3,D4
		MOVE.L	A3,A4
d138 2
a139 2
		MOVE.L	A3,A0		; start with this font
		MOVE.L	(A2),A1		; ta_Name(A2) get name
d141 2
a142 2
		TST.L	D0
		BNE	testMatch
d144 2
a145 2
		TST.L	D4		; check if acceptable font
		BLE.S	failOpen
d147 2
a148 2
		ADDQ.W	#1,tf_Accessors(A4)
		MOVE.L	A4,D0
d151 2
a152 2
		MOVEM.L (A7)+,D2-D6/A2-A4
		RTS
d155 2
a156 2
		MOVEQ	#0,D0
		BRA.S	openRts
d186 4
a189 4
		SUBQ.W	#1,tf_Accessors(A1)
		BGT.S	closeRts
		BTST	#FPB_REMOVED,tf_Flags(A1)
		BEQ.S	closeRts
d194 1
a194 1
		RTS
d223 3
a225 3
		CLR.W	tf_Accessors(A1)
		MOVE.B	#NT_FONT,LN_TYPE(A1)
		LEA	gb_TextFonts(A6),A0
d229 1
a229 1
		RTS
d260 1
a260 1
		MOVE.L	A1,-(A7)
d262 1
a262 1
		MOVE.L	(A7)+,A1
d265 2
a266 2
		MOVE.B	#NT_MESSAGE,LN_TYPE(A1)
		BSET	#FPB_REMOVED,tf_Flags(A1)
d268 2
a269 2
		TST.W	tf_Accessors(A1)
		BGT.S	remRts
d274 1
a274 1
		RTS
d303 2
a304 2
		MOVE.L	rp_Font(A1),A1
		MOVE.L	LN_NAME(A1),ta_Name(A0)
d306 2
a307 2
		MOVE.L	tf_YSize(A1),ta_YSize(A0)
		RTS
d340 5
a344 5
		MOVE.W	tf_YSize(A0),rp_TxHeight(A1)
		MOVE.W	tf_XSize(A0),rp_TxWidth(A1)
		MOVE.W	tf_Baseline(A0),rp_TxBaseline(A1)
		CLR.B	rp_AlgoStyle(A1)
		MOVE.L	A0,rp_Font(A1)
d527 10
a536 10
		MOVEQ	#0,D0
		MOVE.L	rp_Font(A1),A0
		MOVE.B	tf_Style(A0),D0
		BTST	#FSB_UNDERLINED,D0
		BNE.S	assRts
		MOVE.B	tf_Baseline(A0),D1
		ADDQ	#2,D1
		CMP.W	tf_YSize(A0),D1
		BLE.S	assRts
		BSET	#FSB_UNDERLINED,D0
d538 2
a539 2
		NOT.L	D0
		RTS
d580 3
a582 3
		MOVE.L	D2,-(A7)
		MOVEQ	#0,D2
		MOVEM.L	D0-D1/A0-A1,-(A7)
d584 12
a595 12
		MOVE.B	D0,D2
		MOVEM.L	(A7)+,D0-D1/A0-A1
		MOVE.L	rp_Font(A1),A0
		AND.B	D2,D1
		MOVE.B	rp_AlgoStyle(A1),D2
		AND.B	D1,D0
		NOT.B	D1
		AND.B	D1,D2
		OR.B	D0,D2
		MOVE.B	D2,rp_AlgoStyle(A1)
		OR.B	tf_Style(A2),D2
		MOVE.L	D2,D0
d597 2
a598 2
		MOVE.L	(A7)+,D2
		RTS
d705 142
@


36.7
log
@FontExtent Y Min/Max was wrong
@
text
@d2 1
a2 1
**	$Header: font.asm,v 36.6 89/06/05 14:15:48 kodiak Exp $
d647 2
a648 2
*	FontExtent(rp, fontExtent)
*	           a1  a0
d650 1
a650 1
*	void FontExtent( struct RastPort *, struct TextExtent * );
d654 1
a654 5
*	(i.e. maximum) extent for the characters in the current font
*	in the RastPort.  The te_Width does not include any effect of
*	rp_TxSpacing, as it would from a TextExtent() call.  It will
*	be negative only when FPF_REVPATH is set in the tf_Flags of
*	the font.
d657 2
a658 2
*	rp - the RastPort from which the font attributes are extracted
*	fontExtent - the TextExtent structure to be filled
d661 9
a669 5
*	The effect of algorithmic enhancements is not included.
*	The effect of left-moving characters is ignored for the
*	width of a normal font.  The effect of right-moving
*	characters is ignored if a REVPATH font.  These characters
*	will, however, be reflected in the bounding extent.
d678 3
a680 4
		move.l	rp_Font(a1),a1
		move.l	tf_CharLoc(a1),a2
		move.l	tf_CharSpace(a1),a3
		move.l	tf_CharKern(a1),a4
d691 2
a692 2
		move.b	tf_HiChar(a1),d0
		sub.b	tf_LoChar(a1),d0
d715 1
a715 1
		add.w	tf_XSize(a1),d2
d717 1
a717 1
		btst	#FPB_REVPATH,tf_Flags(a1)
d730 2
a731 2
		move.w	d3,te_Width(a0)
		move.w	d4,te_Extent+ra_MinX(a0)
d733 4
a736 4
		move.w	d5,te_Extent+ra_MaxX(a0)
		move.w	tf_YSize(a1),d0
		move.w	d0,te_Height(a0)
		move.w	tf_Baseline(a1),d1
d738 1
a738 1
		move.w	d1,te_Extent+ra_MinY(a0)
d741 1
a741 1
		move.w	d1,te_Extent+ra_MaxY(a0)
@


36.6
log
@autodoc changes
@
text
@d2 1
a2 1
**	$Header$
d738 4
a742 3
		sub.w	d0,d1
		addq.w	#1,d1
		move.w	d1,te_Extent+ra_MinY(a0)
@


36.5
log
@rework mechanism for storing speedup bits
@
text
@d1 8
a8 45
	TTL    '$Header: font.asm,v 36.4 88/09/15 16:42:47 kodiak Exp $'
**********************************************************************
*								     *
*   Copyright 1985, Commodore-Amiga Inc.   All rights reserved.	     *
*   No part of this program may be reproduced, transmitted,	     *
*   transcribed, stored in retrieval system, or translated into	     *
*   any language or computer language, in any form or by any	     *
*   means, electronic, mechanical, magnetic, optical, chemical,	     *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030				     *
*								     *
**********************************************************************
*
*	font and text attribute specification
*
*
*   Source Control
*   --------------
*   $Header: font.asm,v 36.4 88/09/15 16:42:47 kodiak Exp $
*
*   $Locker: kodiak $
*
*   $Log:	font.asm,v $
*   Revision 36.4  88/09/15  16:42:47  kodiak
*   SetFont alerts when (Kern==0) != (Space==0) or when (Kern==0) and (Space==0)
*   but not KERNLESS.
*   
*   Revision 36.3  88/07/15  16:23:20  kodiak
*   add KERNLESS support
*   
*   Revision 36.2  88/03/06  11:00:24  kodiak
*   fixed Bxx directions
*   
*   Revision 36.1  88/03/04  11:38:34  kodiak
*   changed FontExtent NOTES
*   
*   Revision 36.0  88/03/04  10:50:49  kodiak
*   add FontExtent function
*   
*   Revision 35.1  87/10/19  16:27:49  kodiak
*   text speed enhancements
*   
*
**********************************************************************
d69 1
a69 2
*	struct TextFont *font;
*	struct TextAttr *textAttr;
a87 2
*   BUGS
*
d208 1
a208 1
*	struct TextFont *font;
d246 1
a246 1
*	struct TextFont *textFont;
d279 1
a279 1
*	          a1
d281 1
a281 1
*	struct TextFont *textFont;
d326 1
a326 2
*	struct RastPort *rp;
*	struct TextAttr *textAttr;
d359 1
a359 2
*	struct RastPort *rp;
*	struct TextFont *font;
d543 1
a543 1
*	  d0		      a1
d545 1
a545 2
*	ULONG enable;
*	struct RastPort *rp;
d589 1
a589 1
*	  d0			a1  d0	    d1
d591 1
a591 4
*	ULONG	newStyle;
*	struct RastPort *rp;
*	ULONG	style;
*	ULONG	enable;
d650 1
a650 2
*	struct RastPort *rp;
*	struct TextExtent *fontExtent;
@


36.4
log
@SetFont alerts when (Kern==0) != (Space==0) or when (Kern==0) and (Space==0)
but not KERNLESS.
@
text
@d1 1
a1 1
	TTL    '$Header: font.asm,v 36.3 88/07/15 16:23:20 kodiak Exp $'
d20 1
a20 1
*   $Header: font.asm,v 36.3 88/07/15 16:23:20 kodiak Exp $
d25 4
d63 1
d428 2
a429 4
	;-- check if this is an old font that needs to be hand flagged
	;   as kernless or byte font
		move.b	tf_Style(a0),d0
		and.b	#FSF_KERNLESS!FSF_BYTEFONT,d0
d432 3
d460 1
a460 1
		ori.b	#FSF_KERNLESS!FSF_BYTEFONT,tf_Style(a0)
d526 1
a526 1
		bset	#FSB_KERNLESS,tf_Style(a0)
d531 1
d533 1
a533 1
;  !!! check for cases I want to get rid of
d535 15
a549 11
	XREF_EXE Alert
	tst.l	tf_CharKern(a0)
	beq.s	sfaNoKern
	tst.l	tf_CharSpace(a0)
	bne.s	sfaContinue
	movem.l	d0-d1/d7/a5,-(a7)
	move.l	#$0201b0b0,d7
	move.l	a0,a5
	LINKEXE	Alert
	movem.l	(a7)+,d0-d1/d7/a5
	bra.s	sfaContinue
d551 6
a556 8
	tst.l	tf_CharSpace(a0)
	beq.s	sfaNoSpace
	movem.l	d0-d1/d7/a5,-(a7)
	move.l	#$0201b0b1,d7
	move.l	a0,a5
	LINKEXE	Alert
	movem.l	(a7)+,d0-d1/d7/a5
	bra.s	sfaContinue
d558 5
a562 7
	btst	#FSB_KERNLESS,tf_Style(a0)
	bne.s	sfaContinue
	movem.l	d0-d1/d7/a5,-(a7)
	move.l	#$0201b0b2,d7
	move.l	a0,a5
	LINKEXE	Alert
	movem.l	(a7)+,d0-d1/d7/a5
d564 12
a575 1
		RTS
@


36.3
log
@add KERNLESS support
@
text
@d1 1
a1 1
	TTL    '$Header: font.asm,v 36.2 88/03/06 11:00:24 kodiak Exp $'
d20 1
a20 1
*   $Header: font.asm,v 36.2 88/03/06 11:00:24 kodiak Exp $
d25 3
d525 32
@


36.2
log
@fixed Bxx directions
@
text
@d1 1
a1 1
	TTL    '$Header: font.asm,v 36.1 88/03/04 11:38:34 kodiak Exp $'
d20 1
a20 1
*   $Header: font.asm,v 36.1 88/03/04 11:38:34 kodiak Exp $
d25 3
d421 4
a424 3
	;   as a byte font
		btst	#FSB_BYTEFONT,tf_Style(a0)
		bne.s	sfDone
d428 1
a428 1
		bne.s	sfDone
d430 1
a430 1
		bne.s	sfDone
d433 1
a433 1
		bne.s	sfDone
d435 1
a435 1
		bne.s	sfDone
d437 1
a437 1
		;-- perform the longest test
d442 1
a442 1
chkSize8:
d445 1
a445 1
		bne.s	sfDone
d447 2
a448 2
		dbne	d0,chkSize8
		bne.s	sfDone
d450 70
a519 2
		;-- this is really a BYTEFONT, make it so
		bset	#FSB_BYTEFONT,tf_Style(a0)
@


36.1
log
@changed FontExtent NOTES
@
text
@d1 1
a1 1
	TTL    '$Header: font.asm,v 36.0 88/03/04 10:50:49 kodiak Exp $'
d20 1
a20 1
*   $Header: font.asm,v 36.0 88/03/04 10:50:49 kodiak Exp $
d25 3
d623 1
a623 1
		bge.s	feAddBitSize
d630 1
a630 1
		ble.s	feBoundCP
d643 1
a643 1
		ble.s	feNextChar
d648 1
a648 1
		bge.s	feNextChar
@


36.0
log
@add FontExtent function
@
text
@d1 1
a1 1
	TTL    '$Header: font.asm,v 35.1 87/10/19 16:27:49 kodiak Exp $'
d20 1
a20 1
*   $Header: font.asm,v 35.1 87/10/19 16:27:49 kodiak Exp $
d25 3
d583 2
a584 1
*   BUGS
@


35.1
log
@text speed enhancements
@
text
@d1 1
a1 1
	TTL    '$Header: font.asm,v 33.0 86/05/17 15:29:29 bart Exp $'
d20 1
a20 1
*   $Header: font.asm,v 33.0 86/05/17 15:29:29 bart Exp $
d22 1
a22 1
*   $Locker: bart $
d25 3
d77 1
d555 107
a661 1
		END
@


35.0
log
@initial from V34
@
text
@d1 1
a1 1
	TTL    '$Header: font.asm,v 1.1 87/10/19 15:14:23 kodiak Exp $'
d20 1
a20 1
*   $Header: font.asm,v 1.1 87/10/19 15:14:23 kodiak Exp $
d22 1
a22 1
*   $Locker: kodiak $
d181 1
a181 1
;                       underlined,bold,italic,,,,,
d186 1
a186 1
;                       underlined,bold,italic,,,,,
d407 33
@
