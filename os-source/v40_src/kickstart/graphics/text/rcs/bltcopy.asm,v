head     39.8;
branch   ;
access   ;
symbols  rel39_24:39.8 rel39_18:39.8 rel39_97:39.8 rel39_90:39.7 rel39_89:39.7 rel39_82:39.6 rel39_76:39.6 rel39_71:39.6 rel39_65:39.6 rel39_64:39.6 rel39_61:39.6 rel39_60:39.6 rel39_55:39.6 rel39_47:39.6 rel39_39:39.5 rel39_38:39.5 rel39_37:39.5 rel39_35:39.4 rel39_34:39.4 V37_30:37.2 V37_29:37.2 V37_28:37.2 V37_25:37.2 V37_22:37.2 V37_21:37.2 V37_20:37.2 V37_19:37.2 V37_17:37.2 V37_15:37.2 V37_14:37.2 V37_13:37.1 V37_12:37.1 V37_11:37.1 V37_10:37.1 V37_9:37.1 V37_7:37.1 V37_6:37.1 V37_5:37.1 V37_4:37.1 V37_3:37.1 V37_2:37.0 V37_1:37.0 V36_209:36.10 V36_208:36.10 V36_207:36.10 V36_205:36.10 V36_203:36.10 V36_202:36.10 V36_201:36.10 V36_200:36.10 V36_199:36.10 V36_198:36.10 V36_196:36.10 V36_195:36.10 V36_194:36.10 V36_193:36.10 V36_192:36.10 V36_191:36.10 V36_190:36.10 V36_189:36.10 V36_188:36.10 V36_187:36.10 V36_186:36.10 V36_185:36.10 V36_184:36.10 V36_183:36.10 V36_182:36.10 V36_181:36.10;
locks    ; strict;
comment  @*   @;


39.8
date     92.10.20.08.56.08;  author chrisg;  state Exp;
branches ;
next     39.7;

39.7
date     92.09.03.15.38.40;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     92.03.19.16.28.27;  author chrisg;  state Exp;
branches ;
next     39.5;

39.5
date     92.02.26.11.34.48;  author chrisg;  state Exp;
branches ;
next     39.4;

39.4
date     91.11.22.15.05.29;  author chrisg;  state Exp;
branches ;
next     39.3;

39.3
date     91.11.21.10.39.44;  author chrisg;  state Exp;
branches ;
next     39.2;

39.2
date     91.11.19.10.34.50;  author chrisg;  state Exp;
branches ;
next     39.1;

39.1
date     91.11.15.11.04.29;  author chrisg;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.35.29;  author chrisg;  state Exp;
branches ;
next     37.3;

37.3
date     91.05.09.14.47.43;  author spence;  state Exp;
branches ;
next     37.2;

37.2
date     91.02.12.15.51.11;  author spence;  state Exp;
branches ;
next     37.1;

37.1
date     91.01.18.17.21.59;  author spence;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.28.41;  author spence;  state Exp;
branches ;
next     36.10;

36.10
date     90.05.10.10.11.27;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     90.04.24.10.46.38;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     90.04.13.11.52.12;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     90.04.02.12.58.56;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     90.03.05.16.23.45;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.11.02.18.37.36;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     89.08.16.12.58.24;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     89.07.18.15.50.04;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     89.07.17.15.03.55;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     89.06.08.14.22.42;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     89.06.05.14.15.14;  author kodiak;  state Exp;
branches ;
next     35.4;

35.4
date     87.12.03.12.59.03;  author kodiak;  state Exp;
branches ;
next     35.3;

35.3
date     87.11.24.17.57.46;  author kodiak;  state Exp;
branches ;
next     35.2;

35.2
date     87.11.11.14.43.18;  author kodiak;  state Exp;
branches ;
next     35.1;

35.1
date     87.10.19.16.27.28;  author kodiak;  state Exp;
branches ;
next     35.0;

35.0
date     87.10.19.16.18.56;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


39.8
log
@preserve d7.
@
text
@	TTL    '$Id: bltcopy.asm,v 39.7 92/09/03 15:38:40 spence Exp Locker: chrisg $'
**********************************************************************
*
*		-------------
*		GRAPHICS TEXT	rectangular blit guts
*		-------------
*
*   Copyright 1985, 1987 Commodore-Amiga Inc.
*
*   Source Control: $Locker: chrisg $
*
*   $Log:	bltcopy.asm,v $
*   Revision 39.7  92/09/03  15:38:40  spence
*   Autodoc spelling corrections
*   
*   Revision 39.6  92/03/19  16:28:27  chrisg
*   short branches.
*   
*   Revision 39.5  92/02/26  11:34:48  chrisg
*    fxied for new interleave scheme.
*   
*   Revision 39.4  91/11/22  15:05:29  chrisg
*    put depth check back in.
*   
*   Revision 39.3  91/11/21  10:39:44  chrisg
*    improved to handle bltbitmap with minterm of 0 ( no source)
*   
*   Revision 39.2  91/11/19  10:34:50  chrisg
*     updated because of new magic cookie for interleaved bitmaps.
*   
*   Revision 39.1  91/11/15  11:04:29  chrisg
*    added support for interleaved bitmaps!
*   
*   Revision 39.0  91/08/21  17:35:29  chrisg
*   Bumped
*   
*   Revision 37.3  91/05/09  14:47:43  spence
*   *** empty log message ***
*   
*   Revision 37.2  91/02/12  15:51:11  spence
*   autodoc
*   
*   Revision 37.1  91/01/18  17:21:59  spence
*   Checks for NULL from getmustmem(), which no longer gurus.
*   Makes a quick exit if NULL found. This may cause guru further up the
*   calling chain - I hope not.
*   
*   Revision 37.0  91/01/07  15:28:41  spence
*   initial switchover from V36
*   
*   Revision 36.10  90/05/10  10:11:27  kodiak
*   optimize lea bm_Planes(an),an to addq.l #bm_Planes,an
*   
*   Revision 36.9  90/04/24  10:46:38  kodiak
*   document blitter usage
*   
*   Revision 36.8  90/04/13  11:52:12  kodiak
*   use Id instead of Header for 4.x rcs
*   
*   Revision 36.7  90/04/02  12:58:56  kodiak
*   for rcs 4.x header change
*   
*   Revision 36.6  90/03/05  16:23:45  kodiak
*   fix superbitmap BltTemplate (and thus Text)
*   
*   Revision 36.5  89/11/02  18:37:36  kodiak
*   recode to use gb_ExecBase
*   
*   Revision 36.4  89/08/16  12:58:24  kodiak
*   document 0/-1 plane pointer hack
*   
*   Revision 36.3  89/07/18  15:50:04  kodiak
*   special case for zero & $ffffffff plane pointers
*   
*   Revision 36.2  89/07/17  15:03:55  kodiak
*   waitblitdone after OwnBlitter for BltTemplate left or right cases
*   
*   Revision 36.1  89/06/08  14:22:42  kodiak
*   define out big blit emulation
*   define EMULATE to put it back in
*   
*   Revision 36.0  89/06/05  14:15:14  kodiak
*   autodoc changes
*   
*   Revision 35.4  87/12/03  12:59:03  kodiak
*   emulate big blits on small blitters
*   
*
**********************************************************************

	SECTION		graphics

	OPTIMON

*------ Included Files -----------------------------------------------

	INCLUDE		"exec/types.i"
	INCLUDE		"exec/nodes.i"
	INCLUDE		"exec/lists.i"
	INCLUDE		"exec/ports.i"
	INCLUDE		"exec/memory.i"
	INCLUDE		"exec/libraries.i"
	INCLUDE		"exec/alerts.i"

	INCLUDE		"graphics/gfx.i"
	INCLUDE		"graphics/clip.i"
	INCLUDE		"graphics/rastport.i"
	INCLUDE		"graphics/gfxbase.i"

	INCLUDE		"hardware/blit.i"
	INCLUDE		"hardware/custom.i"

	INCLUDE		"macros.i"

	IFNE		rp_Layer
	FAIL		"recode rp_Layer instructions"
	ENDC

*------ Imported Names -----------------------------------------------

	XREF		_custom

	XREF		GetMustMem
	XREF		FreeMustMem

	XREF		waitblitdone

	XLVO	UnlockLayerRom		; Graphics
	XLVO	LockLayerRom		;
	XLVO	OwnBlitter		;
	XLVO	DisownBlitter		;


*------ Exported Names -----------------------------------------------

*------ Tables -------------------------------------------------------

	XDEF		_fwmaskTable
	XDEF		_lwmaskTable

*------ Functions ----------------------------------------------------

	XDEF		_BltBitMap
	XDEF		_BltTemplate

	IFNE	BC1F_DESC-2
	FAIL	"recode BC1B_DESC bit tests"
	ENDC

BC1B_DESC	EQU	2

 STRUCTURE	SHADOW,0
    UWORD	SHADOW_CON0
    UWORD	SHADOW_CON1
    UWORD	SHADOW_AFWM
    UWORD	SHADOW_ALWM
    UWORD	SHADOW_AMOD
    UWORD	SHADOW_BMOD
    UWORD	SHADOW_CDMOD
    APTR	SHADOW_APT
    LABEL	SHADOW_SIZEOF
	
	IFNE	SHADOW_CON0
	FAIL	"SHADOW_CON0 not zero: recode"
	ENDC

	IFNE	SHADOW_CON1-2
	FAIL	"SHADOW_CON1 not immediately after SHADOW_CON0: recode"
	ENDC

	IFD	EMULATE

 STRUCTURE	EMUL,0
    APTR	EMUL_POINTER	; varies: A data, or source (from a0)
    LONG	EMUL_SOFFSET	; original source offset (from d1)
    LONG	EMUL_DOFFSET	; original destination offset (from d3)
    UWORD	EMUL_AMOD1	; A modulo for all but last X size
    UWORD	EMUL_AMOD2	; A modulo for last X size
    UWORD	EMUL_BMOD1	; source modulo for all but last X size
    UWORD	EMUL_BMOD2	; source modulo for last X size
    UWORD	EMUL_CDMOD1	; dest modulo for all but last X size
    UWORD	EMUL_CDMOD2	; dest modulo for last X size
				; intermediate X intermediate Y size is 0
				; last X intermediate Y size is last & $003f
				; intermediate X last Y size is last & $ffc0
    UWORD	EMUL_SIZE22	; last X         last Y         size
    UWORD	EMUL_COUNTX1	; intermediate X counter
    UWORD	EMUL_COUNTY1	; intermediate Y counter
    LABEL	EMUL_SIZEOF
	
	ENDC	; EMULATE

_lwmaskTable:
		dc.w    $08000
		dc.w	$0C000
		dc.w	$0E000
		dc.w	$0F000
		dc.w	$0F800
		dc.w	$0FC00
		dc.w	$0FE00
		dc.w	$0FF00
		dc.w	$0FF80
		dc.w	$0FFC0
		dc.w	$0FFE0
		dc.w	$0FFF0
		dc.w	$0FFF8
		dc.w	$0FFFC
		dc.w	$0FFFE
_fwmaskTable:
		dc.w    $0FFFF
		dc.w	$07FFF
		dc.w	$03FFF
		dc.w	$01FFF
		dc.w	$00FFF
		dc.w	$007FF
		dc.w	$003FF
		dc.w	$001FF
		dc.w	$000FF
		dc.w	$0007F
		dc.w	$0003F
		dc.w	$0001F
		dc.w	$0000F
		dc.w	$00007
		dc.w	$00003
		dc.w	$00001


******* graphics.library/BltBitMap ***********************************
*
*   NAME
*	BltBitMap -- Move a rectangular region of bits in a BitMap.
*
*   SYNOPSIS
*	planecnt = BltBitMap(SrcBitMap, SrcX, SrcY, DstBitMap,
*	D0                   A0         D0:16 D1:16 A1
*	    DstX, DstY, SizeX, SizeY, Minterm, Mask [, TempA])
*	    D2:16 D3:16 D4:16  D5:16  D6:8     D7:8   [A2]
*
*	ULONG BltBitMap(struct BitMap *, WORD, WORD, struct BitMap *,
*	    WORD, WORD, WORD, WORD, UBYTE, UBYTE, UWORD *);
*
*   FUNCTION
*	Perform non-destructive blits to move a rectangle from one
*	area in a BitMap to another area, which can be on a different
*	BitMap.
*	This blit is assumed to be friendly: no error conditions (e.g.
*	a rectangle outside the BitMap bounds) are tested or reported.
*
*   INPUTS
*	SrcBitMap, DstBitMap - the BitMap(s) containing the
*	      rectangles
*	    - the planes copied from the source to the destination are
*	      only those whose plane numbers are identical and less
*	      than the minimum Depth of either BitMap and whose Mask
*	      bit for that plane is non-zero.
*	    - as a special case, if a plane pointer in the SrcBitMap
*	      is zero, it acts as a pointer to a plane of all zeros, and
*	      if the plane pointer is 0xffffffff, it acts as a pointer
*	      to a plane of all ones.  (Note: new for V36)
*	    - SrcBitMap and DstBitMap can be identical if they point
*	      to actual planes.
*	SrcX, SrcY - the x and y coordinates of the upper left corner
*	    of the source rectangle.  Valid range is positive
*	    signed integer such that the raster word's offset
*	    0..(32767-Size)
*	DstX, DstY - the x and y coordinates of the upper left
*	    corner of the destination for the rectangle.  Valid
*	    range is as for Src.
*	SizeX, SizeY - the size of the rectangle to be moved.  Valid
*	    range is (X: 1..976; Y: 1..1023 such that final raster
*	    word's offset is 0..32767)
*	Minterm - the logic function to apply to the rectangle when
*	    A is non-zero (i.e. within the rectangle).  B is the
*	    source rectangle and C, D is the destination for the
*	    rectangle.
*	    - $0C0 is a vanilla copy
*	    - $030 inverts the source before the copy
*	    - $050 ignores the source and inverts the destination
*	    - see the hardware reference manual for other combinations
*	Mask - the write mask to apply to this operation.  Bits set 
*	    indicate the corresponding planes (if not greater than
*	    the minimum plane count) are to participate in the
*	    operation.  Typically this is set to 0xff.
*	TempA - If the copy overlaps exactly to the left or right
*	    (i.e. the scan line addresses overlap), and TempA is
*	    non-zero, it points to enough chip accessible memory
*	    to hold a line of A source for the blit (ie CHIP RAM).
*	    BltBitMap will allocate (and free) the needed TempA if
*	    none is provided and one is needed.  Blit overlap is
*	    determined from the relation of the first non-masked
*	    planes in the source and destination bit maps.
*
*   RESULTS
*	planecnt - the number of planes actually involved in the blit.
*
*   NOTES
*	o   This function may use the blitter.
*
*   SEE ALSO
*	ClipBlit()  graphics/gfx.h  hardware/blit.h
*
**********************************************************************
	include	'/macros.i'
_BltBitMap:
	cmp.w	#UNLIKELY_WORD,bm_Pad(a1)
	bne	old_entry
	cmp.b	#-1,d7
	bne	old_entry
	move.b	bm_Depth(a1),d7
	tst.b	d6	; minterm=0?
	beq.s	no_ck_2nd

	cmp.w	#UNLIKELY_WORD,bm_Pad(a0)
	bne.s	old_entry_1
	cmp.b	bm_Depth(a0),d7
	bne.s	old_entry_1
no_ck_2nd:
	movem.l	d1/d3/d5/d7/a2,-(a7)
	lea	-bm_SIZEOF*2(a7),a7
	tst.b	d6
	beq.s	no_ck_2nd_1
	move.l	bm_Planes+4(a0),a2
	sub.l	bm_Planes(a0),a2
	cmp.w	#0,a2
	beq.s	old_1
	cmp.w	bm_BytesPerRow(a0),a2
	bhi.s	old_1
no_ck_2nd_1:
	move.l	bm_Planes+4(a1),a2
	sub.l	bm_Planes(a1),a2
	cmp.w	bm_BytesPerRow(a1),a2
	bhi.s	old_1

	ext.w	d7
	mulu	d7,d3	; dsty*=depth
	mulu	d7,d5	; high*=depth
	mulu	d7,d1	; srcy*=depth
	move.b	#1,bm_Depth(a7)
	move.b	#1,bm_SIZEOF+bm_Depth(a7)
	move.l	bm_Planes+4(a0),a2
	sub.l	bm_Planes(a0),a2
	move.w	a2,bm_BytesPerRow(a7)
	move.l	bm_Planes+4(a1),a2
	sub.l	bm_Planes(a1),a2
	move.w	a2,bm_SIZEOF+bm_BytesPerRow(a7)
	move.l	bm_Planes(a0),bm_Planes(a7)
	move.l	bm_Planes(a1),bm_SIZEOF+bm_Planes(a7)
	move.l	a7,a0
	lea	bm_SIZEOF(a7),a1
old_1:	st	d7
	sub.l	a2,a2									; don't use temp
	bsr.s	old_entry
	lea	bm_SIZEOF*2(a7),a7
	movem.l	(a7)+,d1/d3/d5/d7/a2
	st	d7
	rts

old_entry_1:
	st	d7
old_entry:
	movem.l d2-d7/a0-a5,-(a7)
		sub.w	#SHADOW_SIZEOF,a7
		move.l	a7,a5
PARM_MINTERM	EQU	SHADOW_SIZEOF+16	; then MASK, SRCBMAP, DESTBMAP

	    ;-- get lowest plane count
		moveq	#0,d6
		move.b	bm_Depth(a0),d6
		beq.s	noPlanes
		cmp.b	bm_Depth(a1),d6
		ble.s	countHarmony
		move.b	bm_Depth(a1),d6
		beq.s	noPlanes
countHarmony:
		move.w	d6,-(a7)
	    ;-- set up blitter
						; d0-d5 from BltBitMap args
		move.l	a2,SHADOW_APT(a5)	; TmpRas
		move.w	bm_BytesPerRow(a0),a2	; srcModulo
		move.w	bm_BytesPerRow(a1),a3	; destModulo
		;-- get unmasked srcPlane, destPlane
findUnMaskedPlane:
		subq	#1,d6
		bmi.s	noPlanes2		; no unmasked planes
		btst	d6,d7			; check this plane's mask
		beq.s	findUnMaskedPlane
		lsl.w	#2,d6			; get plane index
		move.l	bm_Planes(a0,d6.w),a0
		move.l	bm_Planes(a1,d6.w),a1
						; a6 from BltBitMap args

		bsr	bltSetup

	    ;-- recover BltBitMap arguments
		movem.l	PARM_MINTERM(a5),d2/d7/a0-a1
		addq.l	#bm_Planes,a0		; srcPlane
		addq.l	#bm_Planes,a1		; destPlane
		;-- adjust CON0
		andi.w	#$F0,d2			; mask minterm to 4:4
		or.w	d2,(a5)			; SHADOW_CON0

	    ;-- set up for plane loops
		moveq	#0,d5			; actual plane count
		move.w	(a7)+,d6		; recover plane count

		btst	#GFXB_BIG_BLITS,gb_ChipRevBits0(a6)
		bne.s	bigBBM
	
	IFD	EMULATE
		;-- check if blit will fit wholly in old chip bltsize
		move.l	d0,d2
		and.l	#$ffc0fc00,d2		; check for less than 1Kx1K
		beq.s	smallBBM
		cmp.w	#$0400,d0		; check Y vs. 1K
		bgt.s	bbmEmulate
		move.l	d0,d2
		swap	d2
		cmp.w	#$0040,d2		; check X vs. 1K
		bgt.s	bbmEmulate
	ENDC	; EMULATE

smallBBM:

		;-- do a blit with just the bltsize register
		move.w	d0,d2			; cache Y
		lsl.w	#6,d2			; shift up Y
		swap	d0			; get X
		and.w	#$003f,d0		; fix 1K to zero
		or.w	d2,d0			; form bltsize register
		bra.s	planesDBF

bigBBM:
		move.w	d0,bltsizv(a4)
		swap	d0
		bra	planebDBF

	    ;-- return quickly when there is no work to do
noPlanes2:
		addq	#2,a7			; pop.w d6
noPlanes:
		moveq	#0,d0			; no planes actually blitted
		bra	bbmRts

	IFD	EMULATE
bbmEmulate:
		sub.w	#EMUL_SIZEOF,a7
		move.l	d1,EMUL_SOFFSET(a7)
		move.l	d3,EMUL_DOFFSET(a7)
	    ;-- calculate counters
		;-- COUNTY1
		move.w	d0,d1
		moveq	#10,d2
		lsr.w	d2,d1
		move.w	d0,d2
		and.w	#$3ff,d2
		bne.s	bbmeYCount
		subq	#1,d1
bbmeYCount:
		move.w	d1,EMUL_COUNTY1(a7)
		;-- COUNTX1
		swap	d0
		move.w	d0,d1
		lsr.w	#6,d1
		move.w	d0,d2
		and.w	#$3f,d2
		bne.s	bbmeXCount
		subq	#1,d1
		move.w	#$40,d2
bbmeXCount:
		move.w	d1,EMUL_COUNTX1(a7)
		move.w	d1,d4		; save for mod fixup
		;-- SIZE22
		move.w	d0,d1
		move.w	d1,d3		; save for mod fixup
		and.w	#$3f,d1
		swap	d0
		move.w	d0,d2
		lsl.w	#6,d2
		or.w	d2,d1
		move.w	d1,EMUL_SIZE22(a7)
	    ;-- calculate new modulos
		sub.w	#$40,d3		; size sans intermediate
		add.w	d3,d3
		lsl.w	#7,d4		; size sans last
		;-- A modulo
		move.w	SHADOW_AMOD(a5),d0
		move.w	d0,d1
		btst	#BC1B_DESC,SHADOW_CON1+1(a5)
		bne.s	bbmeXAModDesc
		add.w	d3,d0
		add.w	d4,d1
		bra.s	bbmeXAMod
bbmeXAModDesc:
		sub.w	d3,d0
		sub.w	d4,d1
bbmeXAMod:
		move.w	d0,EMUL_AMOD1(a7)
		move.w	d1,EMUL_AMOD2(a7)
		;-- B modulo
		move.w	SHADOW_BMOD(a5),d0
		move.w	d0,d1
		btst	#BC1B_DESC,SHADOW_CON1+1(a5)
		bne.s	bbmeXBModDesc
		add.w	d3,d0
		add.w	d4,d1
		bra.s	bbmeXBMod
bbmeXBModDesc:
		sub.w	d3,d0
		sub.w	d4,d1
bbmeXBMod:
		move.w	d0,EMUL_BMOD1(a7)
		move.w	d1,EMUL_BMOD2(a7)
		;-- C & D modulos
		move.w	SHADOW_CDMOD(a5),d0
		move.w	d0,d1
		btst	#BC1B_DESC,SHADOW_CON1+1(a5)
		bne.s	bbmeXCDModDesc
		add.w	d3,d0
		add.w	d4,d1
		bra.s	bbmeXCDMod
bbmeXCDModDesc:
		sub.w	d3,d0
		sub.w	d4,d1
bbmeXCDMod:
		move.w	d0,EMUL_CDMOD1(a7)
		move.w	d1,EMUL_CDMOD2(a7)
		bra	bbmeDBF
	    ;--	cycle through planes and patch together small blits
bbmeLoop:
		move.l	(a0)+,a2
		move.l	(a1)+,a3
		;-- check for masked plane
		lsr.b	#1,d7
		bcc	bbmeBumpPlane
		;-- adjust planes by offsets
		add.l	EMUL_SOFFSET(a7),a2
		add.l	EMUL_DOFFSET(a7),a3
		move.l	SHADOW_APT(a5),d0
		move.l	d0,EMUL_POINTER(a7)
		bsr	waitblitdone
		move.l	d0,bltapt(a4)
		move.l	a2,bltbpt(a4)
		move.l	a3,bltcpt(a4)
		move.l	a3,bltdpt(a4)
		move.w	EMUL_COUNTX1(a7),d3
		move.w	EMUL_AMOD1(a7),bltamod(a4)
		move.w	EMUL_BMOD1(a7),bltbmod(a4)
		move.w	EMUL_CDMOD1(a7),bltcmod(a4)
		move.w	EMUL_CDMOD1(a7),bltdmod(a4)
		moveq	#-1,d1
		btst	#BC1B_DESC,SHADOW_CON1+1(a5)
		bne.s	bbmeXHeadMaskDesc
		move.w	d1,bltalwm(a4)
		bra.s	bbmeXDBF
bbmeXHeadMaskDesc:
		move.w	d1,bltafwm(a4)
		bra.s	bbmeXDBF
	    ;-- loop through intermediate x
bbmeXLoop:
		move.w	EMUL_COUNTY1(a7),d2
		bra.s	bbmeY1DBF
	    ;-- loop through intermediate x intermediate y
bbmeY1Loop:
		bsr	waitblitdone
		move.w	#0,bltsize(a4)
bbmeY1DBF:
		dbf	d2,bbmeY1Loop
	    ;-- intermediate x last y
		move.w	EMUL_SIZE22(a7),d0
		and.w	#$ffc0,d0
		bsr	waitblitdone
		move.w	d0,bltsize(a4)
		;-- ensure fwm/lwm are both $ffff for middle
		bsr	waitblitdone
		moveq	#-1,d1
		move.l	d1,bltafwm(a4)		; and bltalwm
		;-- advance pointers along in x
		move.l	EMUL_POINTER(a7),d0
		move.l	#$80,d1
		btst	#BC1B_DESC,SHADOW_CON1+1(a5)
		bne.s	bbmeXAdvanceDesc
		add.l	d1,d0
		add.w	d1,a2
		add.w	d1,a3
		bra.s	bbmeXAdvance
bbmeXAdvanceDesc:
		sub.l	d1,d0
		sub.w	d1,a2
		sub.w	d1,a3
bbmeXAdvance:
		move.l	d0,EMUL_POINTER(a7)
		move.l	d0,bltapt(a4)
		move.l	a2,bltbpt(a4)
		move.l	a3,bltcpt(a4)
		move.l	a3,bltdpt(a4)
bbmeXDBF:
		dbf	d3,bbmeXLoop
	    ;-- last x
		move.w	EMUL_COUNTY1(a7),d2
		move.w	EMUL_AMOD2(a7),bltamod(a4)
		move.w	EMUL_BMOD2(a7),bltbmod(a4)
		move.w	EMUL_CDMOD2(a7),bltcmod(a4)
		move.w	EMUL_CDMOD2(a7),bltdmod(a4)
		btst	#BC1B_DESC,SHADOW_CON1+1(a5)
		bne.s	bbmeXTailDesc
		move.w	SHADOW_ALWM(a5),bltalwm(a4)
		bra.s	bbmeY2DBF
bbmeXTailDesc:
		move.w	SHADOW_AFWM(a5),bltafwm(a4)
		bra.s	bbmeY2DBF
	    ;-- loop through last x intermediate y
bbmeY2Loop:
		move.w	EMUL_SIZE22(a7),d0
		and.w	#$003f,d0
		bsr	waitblitdone
		move.w	d0,bltsize(a4)
bbmeY2DBF:
		dbf	d2,bbmeY2Loop
	    ;-- last x last y
		bsr	waitblitdone
		move.w	EMUL_SIZE22(a7),bltsize(a4)

bbmeBumpPlane:
		addq.w	#1,d5
bbmeDBF:
		dbf	d6,bbmeLoop
		add.w	#EMUL_SIZEOF,a7
		bra.s	releaseBlitter

	ENDC	; EMULATE


	    ;--	cycle through small planes
planesLoop:
		move.l	(a0)+,a2
		move.l	(a1)+,a3
		;-- check for masked plane
		lsr.l	#1,d7
		bcc.s	planesDBF
		bsr	waitblitdone
		;-- check for special source
		move.l	a2,d2
		beq.s	planesSolid
		addq.l	#1,d2		; cmp.l	#-1,d2
		beq.s	planesSolid
		move.l	(a5),bltcon0(a4)	; SHADOW_CON0, SHADOW_CON1
		;-- adjust planes by offsets
		add.l	d1,a2
		move.l	a2,bltbpt(a4)
planesBlit:
		add.l	d3,a3
		move.l	a3,bltcpt(a4)
		move.l	a3,bltdpt(a4)
		move.w	d0,bltsize(a4)
		addq.w	#1,d5

planesDBF:
		dbf	d6,planesLoop
		bra.s	releaseBlitter


planesSolid:
		move.l	(a5),d2			; SHADOW_CON0, SHADOW_CON1
		and.l	#((~SRCB)<<16)!$0fff,d2
		move.l	d2,bltcon0(a4)		; , bltcon1
		move.w	a2,bltbdat(a4)
		bra.s	planesBlit

planebSolid:
		move.l	(a5),d2			; SHADOW_CON0, SHADOW_CON1
		and.l	#((~SRCB)<<16)!$0fff,d2
		move.l	d2,bltcon0(a4)		; , bltcon1
		move.w	a2,bltbdat(a4)
		bra.s	planebBlit


	    ;--	cycle through big planes
planebLoop:
		move.l	(a0)+,a2
		move.l	(a1)+,a3
		;-- check for masked plane
		lsr.l	#1,d7
		bcc.s	planebDBF
		bsr	waitblitdone
		;-- check for special source
		move.l	a2,d2
		beq.s	planebSolid
		addq.l	#1,d2		; cmp.l	#-1,d2
		beq.s	planebSolid
		move.l	(a5),bltcon0(a4)	; SHADOW_CON0, SHADOW_CON1
		;-- adjust planes by offsets
		add.l	d1,a2
		move.l	a2,bltbpt(a4)
planebBlit:
		add.l	d3,a3
		move.l	a3,bltcpt(a4)
		move.l	a3,bltdpt(a4)
		move.w	d0,bltsizh(a4)
		addq.w	#1,d5

planebDBF:
		dbf	d6,planebLoop

releaseBlitter:
	    ;-- release the blitter
		CALLLVO DisownBlitter
	    ;-- release allocated A data, if necessary
		;-- check if A data used
		move.l	d4,d0
		beq.s	donePlanes
		;-- free allocated A data
		bsr	waitblitdone
		move.l	SHADOW_APT(a5),a1
		bsr	FreeMustMem

donePlanes:
	    ;-- return actual plane count
		move.l	d5,d0
bbmRts:
		add.w	#SHADOW_SIZEOF,a7
		movem.l (a7)+,d2-d7/a0-a5
		rts


;------ bltSetup -----------------------------------------------------
;
;   NAME
;	bltSetup
;
;   INPUTS
;	d0.w	srcX
;	d1.w	srcY		then .l srcWordOffset
;	d2.w	destX
;	d3.w	destY		then .l destWordOffset
;	d4.w	sizeX
;	d5.w	sizeY
;
;	a0.l	srcPlane
;	a1.l	destPlane
;	a2.w	srcModulo
;	a3.w	destModulo
;	a5.l	SHADOW
;	a6.l	GfxBase
;	a7.l	4 bytes return address,
;		then 6 bytes for bltafwm, bltalwm, and decending flag
;
;   OUTPUTS
;	d0	.w bltsize or .l bltsizh/bltsizv (horizontal in high word)
;	d1.l	srcWordOffset
;	d2.w	bltcon0 w/o minterm
;	d3.l	destWordOffset
;	d4	A data size allocated here
;	d5	destroyed
;	d6	destroyed
;	d7	destroyed
;
;	a0	destroyed
;	a1	destroyed
;	a2	destroyed
;	a3	destroyed
;	a4.l	_custom
;	a5	SHADOW
;		    SHADOW_CON0
;		    SHADOW_CON1
;		    SHADOW_AFWM
;		    SHADOW_ALWM
;		    SHADOW_AMOD
;		    SHADOW_BMOD
;		    SHADOW_CDMOD
;		    SHADOW_APT
;	a6	preserved
;
bltSetup:
	;-- find initial plane offsets
	    ;-- word offsets
		move.w	a2,d7		; for source
		muls	d7,d1
		move.w	d0,d7
		asr.w	#4,d7
		add.w	d7,d7
		ext.l	d7
		add.l	d7,d1
		move.w	a3,d7		; for destination
		muls	d7,d3
		move.w	d2,d7
		asr.w	#4,d7
		add.w	d7,d7
		ext.l	d7
		add.l	d7,d3

	    ;-- bit offsets
		and.w	#$0f,d0		; for source
		and.w	#$0f,d2		; for destination

	;-- determine the blit direction & modulo
	    ;-- apply equal modulo criterion for overlapping blits
		cmpa.w	a2,a3
		beq.s	mightOverlap

	    ;-- simply look at shift direction: modulo cannot be "-2"
		cmp.w	d0,d2
		blt	increasingReverse
		bra	decreasingForward

mightOverlap:
	    ;-- comparing addresses
		;-- word addresses
		adda.l	d1,a0
		adda.l	d3,a1
		cmp.l	a0,a1
		bge	decreasing
		;-- bit offsets
		cmp.w	d0,d2
		blt.s	increasingScanTest

	    ;------ forward blit, positive modulo
		bsr	forwardCore

	    ;-- construct modulos
		add.w	d6,d6		; get blit bytes (blit words << 1)
		sub.w	d6,a2		; adjust srcModulo
		move.w	a2,SHADOW_BMOD(a5)
		move.w	a2,bltbmod(a4)
		sub.w	d6,a3		; adjust destModulo
		move.w	a3,SHADOW_CDMOD(a5)
		move.w	a3,bltcmod(a4)
		move.w	a3,bltdmod(a4)
		rts
	    ;==========


	    ;-- test if in the same scan line
increasingScanTest:
		move.w	d2,d7		; get destX bit offset
		add.w	d4,d7		; add sizeX
		subq.w	#1,d7		; produce final x on dest line
		lsr.w	#4,d7		; make word offset
		add.w	d7,d7		; make byte offset
		ext.l	d7
		add.l	a1,d7		; make dest final x line address
		cmp.l	a0,d7		; compare with source address
		blt	increasingReverse

	    ;------ forward blit, positive modulo, with A source

	    ;-- calculate blit size
		move.w	d2,d6		; destX bit offset
		add.w	d4,d6		;   + sizeX
		subq.w	#1,d6		;   - 1
		move.w	d6,-(a7)	; save dest + size - 1
		lsr.w	#4,d6		; number of words to blit - 2
	    ;-- get A data
		moveq	#0,d4
		move.l	SHADOW_APT(a5),d7	; check for TempA
		bne.s	gotForwardA
		move.w	d6,d4		; number of words to blit - 2
		add.w	d4,d4		; number of bytes to blit - 4
		addq	#4,d4		; number of bytes to blit
		movem.l	d0-d1,-(a7)
		move.l	d4,d0
		moveq	#MEMF_CHIP,d1
		bsr	GetMustMem
		move.l	d0,SHADOW_APT(a5)
		move.l	d0,d7
		movem.l	(a7)+,d0-d1
		beq		increasingScanTest.	; spence - Jan 18 1991

gotForwardA:
	    ;-- build A data
		;-- grab the blitter
		CALLLVO	OwnBlitter	; (before the waitblitdone)

		move.l	d7,a1		; recover A data memory
		;-- ensure A data not in use
		bsr	waitblitdone
		;-- first two words in A data
		clr.w	(a1)+			; clear first word
		move.w	d2,d7			; using dest x bit...
		add.w	d7,d7			; 
		lea	_fwmaskTable(pc),a0	; get
		move.w	0(a0,d7.W),(a1)+	;   second word like a fwmask
		;-- set intermediate words in A data
		moveq	#-1,d7
		bra.s	midForwardA
initForwardA:
		move.w	d7,(a1)+
midForwardA:
		dbf	d6,initForwardA

		lea	_custom,a4
		;-- set adata
		move.l	SHADOW_APT(a5),bltapt(a4)
		;-- set hardware fwmask and lwmask
		move.l	d7,SHADOW_AFWM(a5)
		move.l	d7,bltafwm(a4)
		;-- set last word in A data
		move.w	(a7)+,d6	; recover dest + size - 1
		move.w	d6,d7
		and.w	#$0F,d7
		add.w	d7,d7
		lea	_lwmaskTable(pc),a0
		move.w	0(a0,d7.w),d7	; last word like lwmask
		and.w	d7,-2(a1)	;   which can overlap fwmask
	    ;-- get B shift into con1
		move.w	d2,d7		; get dest x bit
		sub.w	d0,d7		; subtract src x bit
		and.w	#$0F,d7		; "add 16" to the negative result
		ror.w	#4,d7
		move.w	d7,SHADOW_CON1(a5)
		move.w	d7,bltcon1(a4)
	    ;-- partial con0 (minterm and A shift)
		move.w	#NABC+NANBC+SRCA+SRCB+SRCC+DEST,(a5)	; SHADOW_CON0
	    ;-- blit size into d0
		lsr.w	#4,d6		; number of words to blit - 2
		addq.w	#2,d6		; blit word width (1 extra word)
		move.w	d6,d0
		swap	d0
		move.w	d5,d0

	    ;-- adjust start address offsets
		subq.l	#2,d3

	    ;-- construct modulos
		add.w	d6,d6		; get blit bytes (blit words << 1)
		sub.w	d6,a2		; adjust srcModulo
		move.w	a2,SHADOW_BMOD(a5)
		move.w	a2,bltbmod(a4)
		sub.w	d6,a3		; adjust destModulo
		move.w	a3,SHADOW_CDMOD(a5)
		move.w	a3,bltcmod(a4)
		move.w	a3,bltdmod(a4)
		neg.w	d6
		move.w	d6,SHADOW_AMOD(a5)
		move.w	d6,bltamod(a4)
increasingScanTest.:
		rts
	    ;==========


	;------ reverse blit, negative modulo
increasingReverse:
		bsr	reverseCore

	    ;-- construct modulos
		add.w	d6,d6		; get blit bytes (blit words << 1)
		move.w	d6,d7
		add.w	a2,d6		; adjust srcModulo
		neg.w	d6
		move.w	d6,SHADOW_BMOD(a5)
		move.w	d6,bltbmod(a4)
		add.w	a3,d7		; adjust destModulo
		neg.w	d7
		move.w	d7,SHADOW_CDMOD(a5)
		move.w	d7,bltcmod(a4)
		move.w	d7,bltdmod(a4)
		rts
	    ;==========


	    ;-- decreasing blit
decreasing:
		cmp.w	d0,d2		; compare src to dest bit
		ble	decreasingReverse

	    ;-- test if in the same scan line
		move.w	d0,d7		; get srcX bit offset
		add.w	d4,d7		; add sizeX
		subq.w	#1,d7		; produce final x on src line
		lsr.w	#4,d7		; make word offset
		add.w	d7,d7		; make byte offset
		ext.l	d7
		add.l	a0,d7		; make src final x line address
		cmp.l	d7,a1		; compare with destination address
		bgt	decreasingForward

	;------ reverse blit, negative modulo, with A source
	    ;-- calculate blit size
		move.w	d2,d6		; destX bit offset
		add.w	d4,d6		;   + sizeX
		subq.w	#1,d6		;   - 1
		move.w	d6,-(a7)	; save dest + size - 1
		lsr.w	#4,d6		; number of words to blit - 2
	    ;-- get A data
		moveq	#0,d4
		move.l	SHADOW_APT(a5),d7	; check for TempA
		bne.s	gotReverseA
		move.w	d6,d4		; number of words to blit - 2
		add.w	d4,d4		; number of bytes to blit - 4
		addq	#4,d4		; number of bytes to blit
		movem.l	d0-d1,-(a7)
		move.l	d4,d0
		moveq	#MEMF_CHIP,d1
		bsr	GetMustMem
		move.l	d0,SHADOW_APT(a5)
		move.l	d0,d7
		movem.l	(a7)+,d0-d1
		beq		increasingScanTest.	; spence - Jan 18 1991

gotReverseA:
	    ;-- build A data
		;-- grab the blitter
		CALLLVO	OwnBlitter	; (before the waitblitdone)

		move.l	d7,a1
		;-- first word in A data
		move.w	d2,d7			; using dest x bit...
		add.w	d7,d7			; 
		lea	_fwmaskTable(pc),a0	; get
		;-- ensure A data not in use
		bsr	waitblitdone
		move.w	0(a0,d7.W),(a1)+	;   second word like a fwmask
		;-- set intermediate words in A data
		moveq	#-1,d7
		bra.s	midReverseA
initReverseA:
		move.w	d7,(a1)+
midReverseA:
		dbf	d6,initReverseA

		lea	_custom,a4
		;-- set hardware fwmask and lwmask
		move.l	d7,SHADOW_AFWM(a5)
		move.l	d7,bltafwm(a4)
		;-- set penultimate word in A data
		move.w	(a7)+,d6	; recover dest + size - 1
		move.w	d6,d7
		and.w	#$0F,d7
		add.w	d7,d7
		lea	_lwmaskTable(pc),a0
		move.w	0(a0,d7.w),d7	; last word like lwmask
		and.w	d7,-2(a1)	;   which can overlap fwmask
		;-- clear last word in A data
		clr.w	(a1)			; clear last word
		;-- set adata (at end of line)
		move.l	a1,bltapt(a4)
	    ;-- get B shift into con1
		move.w	d0,d7		; get src x bit
		sub.w	d2,d7		; subtract dest x bit
		and.w	#$0F,d7		; "add 16" to the negative result
		ror.w	#4,d7
		or.w	#BC1F_DESC,d7
		move.w	d7,SHADOW_CON1(a5)
		move.w	d7,bltcon1(a4)
	    ;-- blit line length for address adjustments
		lsr.w	#4,d6		; number of words to blit - 2
		;-- adjust start address offsets
		move.w	d6,d7
		add.w	d7,d7		; get line bytes (sans 2 words)
		ext.l	d7
		add.l	d7,d1		; start at last line word in src
		addq.l	#2,d7		; bump to just sans 1 word
		add.l	d7,d3		; start at last line word in dest
	    ;-- partial con0 (minterm and A shift) into SHADOW_CON0
		move.w	#NABC+NANBC+SRCA+SRCB+SRCC+DEST,(a5)	; SHADOW_CON0
	    ;-- blit size into d0
		addq.w	#2,d6		; blit word width (1 extra word)
		move.w	d6,d0
		swap	d0
		move.w	d5,d0
	    ;-- construct modulos
		add.w	d6,d6		; get blit bytes (blit words << 1)
		move.w	d6,d7
		add.w	a2,d7		; adjust srcModulo
		neg.w	d7
		move.w	d7,SHADOW_BMOD(a5)
		move.w	d7,bltbmod(a4)
		move.w	d6,d7
		add.w	a3,d7		; adjust destModulo
		neg.w	d7
		move.w	d7,SHADOW_CDMOD(a5)
		move.w	d7,bltcmod(a4)
		move.w	d7,bltdmod(a4)
		neg.w	d6
		move.w	d6,SHADOW_AMOD(a5)
		move.w	d6,bltamod(a4)
		rts
	    ;==========


	;------ forward blit, negative modulo
decreasingForward:
		bsr.s	forwardCore

	    ;-- fix up blit start addresses to last line of rectangle
		subq.w	#1,d5
		move.w	a2,d7		; adjust srcWordOffset
		mulu	d5,d7
		add.l	d7,d1
		move.w	a3,d7		; adjust destWordOffset
		mulu	d5,d7
		add.l	d7,d3

	    ;-- construct modulos
		add.w	d6,d6		; get blit bytes (blit words << 1)
		move.w	d6,d7
		add.w	a2,d6		; adjust srcModulo
		neg.w	d6
		move.w	d6,SHADOW_BMOD(a5)
		move.w	d6,bltbmod(a4)
		add.w	a3,d7		; adjust destModulo
		neg.w	d7
		move.w	d7,SHADOW_CDMOD(a5)
		move.w	d7,bltcmod(a4)
		move.w	d7,bltdmod(a4)
		rts

	;------ reverse blit, positive modulo
decreasingReverse:
		bsr	reverseCore

	    ;-- fix up blit start addresses to last line of rectangle
		subq.w	#1,d5
		move.w	a2,d7		; adjust srcWordOffset
		mulu	d5,d7
		add.l	d7,d1
		move.w	a3,d7		; adjust destWordOffset
		mulu	d5,d7
		add.l	d7,d3

	    ;-- construct modulos
		add.w	d6,d6		; get blit bytes (blit words << 1)
		sub.w	d6,a2		; adjust srcModulo
		move.w	a2,SHADOW_BMOD(a5)
		move.w	a2,bltbmod(a4)
		sub.w	d6,a3		; adjust destModulo
		move.w	a3,SHADOW_CDMOD(a5)
		move.w	a3,bltcmod(a4)
		move.w	a3,bltdmod(a4)
		rts


;------ forwardCore --------------------------------------------------
forwardCore:
	    ;-- grab the blitter
		CALLLVO	OwnBlitter
		lea	_custom,a4
	    ;-- fwmask for dest
		move.w	d2,d7
		add.w	d7,d7
		lea	_fwmaskTable(pc),a0
		bsr	waitblitdone
		move.w	0(a0,d7.W),d7
		move.w	d7,SHADOW_AFWM(a5)
		move.w	d7,bltafwm(a4)
	    ;-- get B shift into con1
		move.w	d2,d7		; get dest x bit
		sub.w	d0,d7		; subtract src x bit
		ror.w	#4,d7
		move.w	d7,SHADOW_CON1(a5)
		move.w	d7,bltcon1(a4)
	    ;-- lwmask for dest + size - 1
		move.w	d2,d7		; destX bit offset
		add.w	d4,d7		;   + sizeX
		subq.w	#1,d7		;   - 1
		move.w	d7,d6		; save dest + size - 1
		and.w	#$0F,d7		; get associated bit
		add.w	d7,d7
		lea	_lwmaskTable(pc),a0
		move.w	0(a0,d7.W),d7
		move.w	d7,SHADOW_ALWM(a5)
		move.w	d7,bltalwm(a4)
	    ;-- blit size into d0
		lsr.w	#4,d6		; number of words to blit - 1
		addq.w	#1,d6		; blit word width
		move.w	d6,d0
		swap	d0
		move.w	d5,d0
	    ;-- partial con0 (minterm and A shift) into SHADOW_CON0
		move.w	#NABC+NANBC+SRCB+SRCC+DEST,(a5)		; SHADOW_CON0
	    ;-- constant A data
		moveq	#0,d4
		move.w	#$ffff,bltadat(a4)
		rts

;------ reverseCore --------------------------------------------------
reverseCore:
	    ;-- grab the blitter
		CALLLVO	OwnBlitter
		lea	_custom,a4
	    ;-- lwmask for src
		move.w	d0,d7
		add.w	d7,d7
		lea	_fwmaskTable(pc),a0
		bsr	waitblitdone
		move.w	0(a0,d7.W),d7
		move.w	d7,SHADOW_ALWM(a5)
		move.w	d7,bltalwm(a4)
	    ;-- fwmask for src + size - 1
		move.w	d0,d7		; srcX bit offset
		add.w	d4,d7		;   + sizeX
		subq.w	#1,d7		;   - 1
		move.w	d7,d6		; save src + size - 1
		and.w	#$0F,d7
		add.w	d7,d7
		lea	_lwmaskTable(pc),a0
		move.w	0(a0,d7.W),d7
		move.w	d7,SHADOW_AFWM(a5)
		move.w	d7,bltafwm(a4)
	    ;-- blit line length for address adjustments
		lsr.w	#4,d6		; number of words to blit - 1
		;-- adjust start address offsets
		move.w	d6,d7
		add.w	d7,d7		; get line bytes
		ext.l	d7
		add.l	d7,d1		; start at last line word in src
		add.l	d7,d3		; start at last line word in dest
	    ;-- get B shift into con1
		move.w	d0,d7		; get src x bit
		sub.w	d2,d7		; subtract dest x bit
		ror.w	#4,d7
		move.w	d7,d2		; save for con0
		or.w	#BC1F_DESC,d7
		move.w	d7,SHADOW_CON1(a5)
		move.w	d7,bltcon1(a4)
	    ;-- blit size into d0
		addq.w	#1,d6		; blit word width
		move.w	d6,d0
		swap	d0
		move.w	d5,d0
	    ;-- partial con0 (minterm and A shift) into SHADOW_CON0
		or.w	#NABC+NANBC+SRCB+SRCC+DEST,d2
		move.w	d2,(a5)		; SHADOW_CON0
	    ;-- constant A data
		moveq	#0,d4
		move.w	#$ffff,bltadat(a4)
		rts


******* graphics.library/BltTemplate ******************************************
*
*   NAME
*	BltTemplate -- Cookie cut a shape in a rectangle to the RastPort.
*
*   SYNOPSIS
*	BltTemplate(SrcTemplate, SrcX, SrcMod, rp,
*	            A0           D0:16  D1:16  A1
*	    DstX,  DstY, SizeX, SizeY)
*	    D2:16  D3:16 D4:16  D5:16
*
*	void BltTemplate(UWORD *, WORD, WORD, struct RastPort *,
*	     WORD, WORD, WORD, WORD);
*
*   FUNCTION
*	This function draws the image in the template into the
*	RastPort in the current color and drawing mode at the
*	specified position.  The template is assumed not to overlap
*	the destination.
*	If the template falls outside the RastPort boundary, it is
*	truncated to that boundary.
*
*	Note: the SrcTemplate pointer should point to the "nearest" word
*	   (rounded down) of the template mask. Fine alignment of the mask
*	   is achieved by setting the SrcX bit offseet within the range
*	   of 0 to 15 decimal.
*
*   INPUTS
*	SrcTemplate  - pointer to the first (nearest) word of the template mask.
*	SrcX         - x bit offset into the template mask (range 0..15).
*	SrcMod       - number of bytes per row in template mask.
*	rp           - pointer to destination RastPort.
*	DstX, DstY   - x and y coordinates of the upper left
*	               corner of the destination for the blit.
*	SizeX, SizeY - size of the rectangle to be used as the
*	               template.
*
*   NOTES
*	o   This function may use the blitter.
*
*   SEE ALSO
*	BltBitMap()  graphics/rastport.h
*
*******************************************************************************
 STRUCTURE  TEMP,SHADOW_SIZEOF
	LONG	TEMP_CLIPRECT
	WORD	TEMP_SRC		; d0
	LONG	TEMP_DEST		; d2/d3
	LONG	TEMP_SIZE		; d4/d5
	LABEL	TEMP_SIZEOF

 STRUCTURE  PARM,TEMP_SIZEOF
	LONG	PARM_SRCMOD		; d1
	LONG	PARM_DESTX		; d2
	LONG	PARM_DESTY		; d3
	LONG	PARM_SIZEX		; d4
	LONG	PARM_SIZEY		; d5
	LONG	PARM_UNUSEDD6		; d6
	LONG	PARM_UNUSEDD7		; d7
	LONG	PARM_SRCPLANE		; a0
	LONG	PARM_RASTPORT		; a1

_BltTemplate:
		movem.l d1-d7/a0-a5,-(a7)
		sub.w	#TEMP_SIZEOF,a7
		move.l	a7,a5

	;-- check for simple RastPort
		move.l	(a1),d7			; rp_Layer
		bne.s	clipRects
		move.w	d1,a2
		moveq	#0,d1
		move.l	rp_BitMap(a1),a4
		bsr	tDoBlit
		bra	btRts

clipRects:
	;-- lock clip windows
		move.l	a5,a4
		move.l	d7,a5
		CALLLVO	LockLayerRom		; does NOT hit d0/d1/a0/a1
		move.l	a4,a5

	    ;-- adjust destination for clip rectangles
		move.l	d7,a3
		add.w	lr_MinX(a3),d2
		sub.w	lr_Scroll_X(a3),d2
		add.w	lr_MinY(a3),d3
		sub.w	lr_Scroll_Y(a3),d3
		movem.w	d0/d2-d5,TEMP_SRC(a5)	; & DEST & SIZE

		lea.l	lr_ClipRect(a3),a3	; get first ClipRect
		bra.s	nextClipRect

clipRectLoop:
		bsr	tClipCode
		bne.s	recoverCoords

	    ;-- find bitmap
		tst.l	cr_lobs(a3)		; using RastPort BitMap?
		bne.s	crBitMap
		move.l	rp_BitMap(a1),a4
		bra.s	doCBlit
crBitMap:
		move.l	cr_BitMap(a3),d7
		beq.s	recoverCoords
		move.l	d7,a4
		move.w	cr_MinX(a3),d7		; adjust x for offscreen memory
		and.w	#$0FFF0,d7		;	with origin @@ MinX
		sub.w	d7,d2			;
		sub.w	cr_MinY(a3),d3		; adjust y for offscreen memory
						;	with origin @@ MinY

doCBlit:
		move.l	PARM_SRCPLANE(a5),a0	; recover srcPlane
		move.w	PARM_SRCMOD+2(a5),a2	; recover srcModulo
		move.l	a3,TEMP_CLIPRECT(a5)
		bsr	tDoBlit
		move.l	TEMP_CLIPRECT(a5),a3
recoverCoords:
		movem.w	TEMP_SRC(a5),d0/d2-d5	; recover srcX, destXY, sizeXY
nextClipRect:
		move.l	(a3),d7			; check for more clip regions
		move.l	d7,a3
		bne.s	clipRectLoop

	;-- check for super bit map
		move.l	(a1),a3			; rp_Layer
		move.l	lr_SuperClipRect(a3),d7
		beq.s	btCEnd
		move.l	lr_SuperBitMap(a3),a4
	    ;-- get original dest without layer Min & Scroll effects
		move.w	PARM_DESTX+2(a5),d2
		move.w	PARM_DESTY+2(a5),d3
		movem.w	d2/d3,TEMP_DEST(a5)

		move.l	d7,a3			; ClipRect

vClipRectLoop:
		bsr.s	tClipCode
		bne.s	recoverSuperCoords

		move.l	PARM_SRCPLANE(a5),a0	; recover srcPlane
		move.w	PARM_SRCMOD+2(a5),a2	; recover srcModulo
		move.l	a3,TEMP_CLIPRECT(a5)
		bsr.s	tDoBlit
		move.l	TEMP_CLIPRECT(a5),a3
recoverSuperCoords:
		movem.w	TEMP_SRC(a5),d0/d2-d5	; recover srcX, destXY, sizeXY
		move.l	(a3),d7		    ;check for more clip regions
		move.l	d7,a3
		bne.s	vClipRectLoop

btCEnd:
	    ;-- unlock clip windows
		move.l	(a1),a5			; rp_Layer
		CALLLVO	UnlockLayerRom		; does NOT hit d0/d1/a0/a1


btRts:
		add.w	#TEMP_SIZEOF,a7
		movem.l (a7)+,d1-d7/a0-a5
		rts


;------ tClipCode ----------------------------------------------------
;
;   NAME
;	tClipCode 
;
;   INPUTS
;	d0.w	srcX
;	d1.w
;	d2.w	destX
;	d3.w	destY
;	d4.w	sizeX
;	d5.w	sizeY
;
;	a3.l	clipRect
;
;   OUTPUTS
;	d0.w	srcX
;	d1.w	srcY
;	d2.w	destX
;	d3.w	destY
;	d4.w	sizeX
;	d5.w	sizeY
;	d6	preserved
;	d7	non-zero indicates all clipped (also in condition code)
;
;	aN	preserved
;
;---------------------------------------------------------------------
tClipCode:
		cmp.w	cr_MinX(a3),d2
		bge.s	xMinOK
	    ;-- clip X to low edge
		sub.w	d2,d0		; start fixup for srcX
		add.w	d2,d4		;   and sizeX
		move.w	cr_MinX(a3),d2
		add.w	d2,d0		; complete fixup for srcX
		sub.w	d2,d4		;   and sizeX
xMinOK:
		move.w	d4,d7
		add.w	d2,d7
		subq.w	#1,d7
		cmp.w	cr_MaxX(a3),d7
		ble.s	xMaxOK
	    ;-- clip X to max edge
		sub.w	d7,d4
		add.w	cr_MaxX(a3),d4
xMaxOK:
		tst.w	d4		; check for non-zero positive size
		ble.s	tccAllClipped

		moveq	#0,d1		; srcY starts at zero
		cmp.w	cr_MinY(a3),d3
		bge.s	yMinOK
	    ;-- clip Y to low edge
		sub.w	d3,d1		; start fixup for srcY
		add.w	d3,d5		;   and sizeY
		move.w	cr_MinY(a3),d3
		add.w	d3,d1		; complete fixup for srcY
		sub.w	d3,d5		;   and sizeY
yMinOK:
		move.w	d5,d7
		add.w	d3,d7
		subq.w	#1,d7
		cmp.w	cr_MaxY(a3),d7
		ble.s	yMaxOK
	    ;-- clip Y to max edge
		sub.w	d7,d5
		add.w	cr_MaxY(a3),d5
yMaxOK:
		tst.w	d5		; check for non-zero positive size
		ble.s	tccAllClipped
		moveq	#0,d7
		rts

tccAllClipped:
		moveq	#-1,d7
		rts


;------ tDoBlit ------------------------------------------------------
;
;   NAME
;	tDoBlit
;
;   INPUTS
;	d0.w	srcX
;	d1.w	srcY
;	d2.w	destX
;	d3.w	destY
;	d4.w	sizeX
;	d5.w	sizeY
;
;	a0.l	srcPlane
;	a1.l	rastPort
;	a2.w	srcModulo
;	a4.l	bitMap
;	a6.l	GfxBase
;
;   OUTPUTS
;	d0	destroyed
;	d1	destroyed
;	d2	destroyed
;	d3	destroyed
;	d4	destroyed
;	d5	destroyed
;	d6	destroyed
;	d7	destroyed
;
;	a0	destroyed
;	a1	preserved
;	a2	destroyed
;	a3	destroyed
;	a4	preserved
;	a5	destroyed
;
;---------------------------------------------------------------------
tDoBlit:
		move.l	a4,-(a7)		; save bitMap
		tst.b	bm_Depth(a4)
		beq.s	tdbRts
	    ;-- set up the blit
		movem.l	a0-a1,-(a7)
		move.w	bm_BytesPerRow(a4),a3
		move.l	bm_Planes(a4),a1
		bsr	bltSetup
		movem.l	(a7)+,a0-a1
		;-- get write mask and partial minterms
		move.b	rp_Mask(a1),d5
		move.w	(a5),d2			; SHADOW_CON0
		;-- adjust source
		add.l	d1,a0
		;-- get plane loop counters
		moveq	#0,d7			; count up
		moveq	#0,d6			; count down
		move.l	(a7),a2			; get bitMap
		move.b	bm_Depth(a2),d6
		;-- get destPlane array
		addq.l	#bm_Planes,a2
		btst	#GFXB_BIG_BLITS,gb_ChipRevBits0(a6)
		bne.s	bigBT
	
	IFD	EMULATE
		;-- check if blit will fit wholly in old chip bltsize
		move.l	d0,d1
		and.l	#$ffc0fc00,d1		; check for less than 1Kx1K
		beq	smallBT
		cmp.w	#$0400,d0		; check Y vs. 1K
		bgt	tdbEmulate
		move.l	d0,d1
		swap	d1
		cmp.w	#$0040,d1		; check X vs. 1K
		ble	smallBT


tdbEmulate:
		sub.w	#EMUL_SIZEOF,a7
		move.l	a0,EMUL_POINTER(a7)
		move.l	d3,EMUL_DOFFSET(a7)
	    ;-- calculate counters
		;-- COUNTY1
		move.w	d0,d1
		moveq	#10,d2
		lsr.w	d2,d1
		move.w	d0,d2
		and.w	#$3ff,d2
		bne.s	tdbeYCount
		subq	#1,d1
tdbeYCount:
		move.w	d1,EMUL_COUNTY1(a7)
		;-- COUNTX1
		swap	d0
		move.w	d0,d1
		lsr.w	#6,d1
		move.w	d0,d2
		and.w	#$3f,d2
		bne.s	tdbeXCount
		subq	#1,d1
		move.w	#$40,d2
tdbeXCount:
		move.w	d1,EMUL_COUNTX1(a7)
		move.w	d1,d4		; save for mod fixup
		;-- SIZE22
		move.w	d0,d1
		move.w	d1,d3		; save for mod fixup
		and.w	#$3f,d1
		swap	d0
		move.w	d0,d2
		lsl.w	#6,d2
		or.w	d2,d1
		move.w	d1,EMUL_SIZE22(a7)
	    ;-- calculate new modulos
		sub.w	#$40,d3		; size sans intermediate
		add.w	d3,d3
		lsl.w	#7,d4		; size sans last
		;-- B modulo
		move.w	SHADOW_BMOD(a5),d0
		move.w	d0,d1
		btst	#BC1B_DESC,SHADOW_CON1+1(a5)
		bne.s	tdbeXBModDesc
		add.w	d3,d0
		add.w	d4,d1
		bra.s	tdbeXBMod
tdbeXBModDesc:
		sub.w	d3,d0
		sub.w	d4,d1
tdbeXBMod:
		move.w	d0,EMUL_BMOD1(a7)
		move.w	d1,EMUL_BMOD2(a7)
		;-- C & D modulos
		move.w	SHADOW_CDMOD(a5),d0
		move.w	d0,d1
		btst	#BC1B_DESC,SHADOW_CON1+1(a5)
		bne.s	tdbeXCDModDesc
		add.w	d3,d0
		add.w	d4,d1
		bra.s	tdbeXCDMod
tdbeXCDModDesc:
		sub.w	d3,d0
		sub.w	d4,d1
tdbeXCDMod:
		move.w	d0,EMUL_CDMOD1(a7)
		move.w	d1,EMUL_CDMOD2(a7)
		bra	tdbeDBF
	    ;--	cycle through planes and patch together small blits
tdbeLoop:
		move.l	(a2)+,a3
		;-- check for masked plane
		lsr.b	#1,d5
		bcc	tdbeBumpPlane
		;-- set CON0
		moveq	#0,d1
		move.b	rp_minterms(a1,d7.w),d1
		or.w	(a7),d1		; SHADOW_CON0
		bsr	waitblitdone
		move.w	d1,bltcon0(a4)
		;-- adjust planes by offsets
		move.l	EMUL_POINTER(a7),a0
		move.l	a0,bltbpt(a4)
		add.l	EMUL_DOFFSET(a7),a3
		move.l	a3,bltcpt(a4)
		move.l	a3,bltdpt(a4)
		move.w	EMUL_COUNTX1(a7),d3
		move.w	EMUL_BMOD1(a7),bltbmod(a4)
		move.w	EMUL_CDMOD1(a7),bltcmod(a4)
		move.w	EMUL_CDMOD1(a7),bltdmod(a4)
		moveq	#-1,d1
		btst	#BC1B_DESC,SHADOW_CON1+1(a5)
		bne.s	tdbeXHeadMaskDesc
		move.w	d1,bltalwm(a4)
		bra.s	tdbeXDBF
tdbeXHeadMaskDesc:
		move.w	d1,bltafwm(a4)
		bra.s	tdbeXDBF
	    ;-- loop through intermediate x
tdbeXLoop:
		move.w	EMUL_COUNTY1(a7),d2
		bra.s	tdbeY1DBF
	    ;-- loop through intermediate x intermediate y
tdbeY1Loop:
		bsr	waitblitdone
		move.w	#0,bltsize(a4)
tdbeY1DBF:
		dbf	d2,tdbeY1Loop
	    ;-- intermediate x last y
		move.w	EMUL_SIZE22(a7),d0
		and.w	#$ffc0,d0
		bsr	waitblitdone
		move.w	d0,bltsize(a4)
		;-- ensure fwm/lwm are both $ffff for middle
		bsr	waitblitdone
		moveq	#-1,d1
		move.l	d1,bltafwm(a4)		; and bltalwm
		;-- advance pointers along in x
		btst	#BC1B_DESC,SHADOW_CON1+1(a5)
		bne.s	tdbeXAdvanceDesc
		add.w	#$80,a0
		add.w	#$80,a3
		bra.s	tdbeXAdvance
tdbeXAdvanceDesc:
		sub.w	#$80,a0
		sub.w	#$80,a3
tdbeXAdvance:
		move.l	a0,bltbpt(a4)
		move.l	a3,bltcpt(a4)
		move.l	a3,bltdpt(a4)
tdbeXDBF:
		dbf	d3,tdbeXLoop
	    ;-- last x
		move.w	EMUL_COUNTY1(a7),d2
		move.w	EMUL_BMOD2(a7),bltbmod(a4)
		move.w	EMUL_CDMOD2(a7),bltcmod(a4)
		move.w	EMUL_CDMOD2(a7),bltdmod(a4)
		btst	#BC1B_DESC,SHADOW_CON1+1(a5)
		bne.s	tdbeXTailDesc
		move.w	SHADOW_ALWM(a5),bltalwm(a4)
		bra.s	tdbeY2DBF
tdbeXTailDesc:
		move.w	SHADOW_AFWM(a5),bltafwm(a4)
		bra.s	tdbeY2DBF
	    ;-- loop through last x intermediate y
tdbeY2Loop:
		move.w	EMUL_SIZE22(a7),d0
		and.w	#$003f,d0
		bsr	waitblitdone
		move.w	d0,bltsize(a4)
tdbeY2DBF:
		dbf	d2,tdbeY2Loop
	    ;-- last x last y
		bsr	waitblitdone
		move.w	EMUL_SIZE22(a7),bltsize(a4)

tdbeBumpPlane:
		addq.w	#1,d7
tdbeDBF:
		dbf	d6,tdbeLoop
		add.w	#EMUL_SIZEOF,a7
		bra.s	tdbDisown
	
	ENDC	; EMULATE

smallBT:
		;-- do a blit with just the bltsize register
		move.w	d0,d1			; cache Y
		lsl.w	#6,d1			; shift up Y
		swap	d0			; get X
		and.w	#$003f,d0		; fix 1K to zero
		or.w	d1,d0			; form bltsize register
		bra.s	tdbsDBF

bigBT:
		move.w	d2,bltcon0(a4)
		move.w	d0,bltsizv(a4)
		swap	d0
		bra.s	tdbbDBF

	    ;--	cycle through small planes
tdbsLoop:
		move.l	(a2)+,a3
		;-- check for masked plane
		lsr.b	#1,d5
		bcc.s	tdbsBumpPlane
		;-- set CON0
		moveq	#0,d1
		move.b	rp_minterms(a1,d7.w),d1
		or.w	d2,d1
		bsr	waitblitdone
		move.w	d1,bltcon0(a4)
		;-- adjust planes by offsets
		add.l	d3,a3
		move.l	a0,bltbpt(a4)
		move.l	a3,bltcpt(a4)
		move.l	a3,bltdpt(a4)
		move.w	d0,bltsize(a4)
tdbsBumpPlane:
		addq.w	#1,d7
tdbsDBF:
		dbf	d6,tdbsLoop

	    ;-- release the blitter
tdbDisown:
		CALLLVO DisownBlitter

tdbRts:
		move.l	(a7)+,a4
		rts

	    ;--	cycle through big planes
tdbbLoop:
		move.l	(a2)+,a3
		;-- check for masked plane
		lsr.b	#1,d5
		bcc.s	tdbbBumpPlane
		;-- set CON0
		moveq	#0,d1
		bsr	waitblitdone
		move.b	rp_minterms(a1,d7.w),bltcon0l(a4)
		;-- adjust planes by offsets
		add.l	d3,a3
		move.l	a0,bltbpt(a4)
		move.l	a3,bltcpt(a4)
		move.l	a3,bltdpt(a4)
		move.w	d0,bltsizh(a4)
tdbbBumpPlane:
		addq.w	#1,d7
tdbbDBF:
		dbf	d6,tdbbLoop
		bra.s	tdbDisown

	END
@


39.7
log
@Autodoc spelling corrections
@
text
@d1 1
a1 1
	TTL    '$Id: bltcopy.asm,v 39.6 92/03/19 16:28:27 chrisg Exp Locker: spence $'
d10 1
a10 1
*   Source Control: $Locker: spence $
d13 3
d355 1
@


39.6
log
@short branches.
@
text
@d1 1
a1 1
	TTL    '$Id: bltcopy.asm,v 39.5 92/02/26 11:34:48 chrisg Exp Locker: chrisg $'
d10 1
a10 1
*   Source Control: $Locker: chrisg $
d13 3
d283 1
a283 1
*	    non-zero, it points to enough chip accessable memory
d285 1
a285 1
*	    BitBitMap will allocate (and free) the needed TempA if
d1249 1
a1249 1
*	   is acheived by setting the SrcX bit offseet within the range
@


39.5
log
@ fxied for new interleave scheme.
@
text
@d1 1
a1 1
	TTL    '$Id: bltcopy.asm,v 39.4 91/11/22 15:05:29 chrisg Exp Locker: chrisg $'
d13 3
d87 2
d308 1
a308 1
	bne	old_entry_1
d318 2
d346 1
a346 1
	bsr	old_entry
d362 1
a362 1
		beq	noPlanes
d423 1
a423 1
		bra	planesDBF
d1506 1
a1506 1
		beq	tdbRts
@


39.4
log
@ put depth check back in.
@
text
@d1 1
a1 1
	TTL    '$Id: bltcopy.asm,v 39.3 91/11/21 10:39:44 chrisg Exp Locker: chrisg $'
d13 3
d294 1
a294 1
	cmp.b	#UNLIKELY_BYTE,bm_Flags(a1)
d298 1
d301 5
a305 2
	cmp.b	#UNLIKELY_BYTE,bm_Flags(a0)
	bne	old_entry
a308 4
	move.w	a1,d7
	cmp.w	bm_Pad(a1),d7
	bne.s	old_1

d311 4
a314 3
	move.w	a0,d7
	cmp.w	bm_Pad(a0),d7
	bne.s	old_1
d316 4
a319 3
	move.b	bm_Depth(a1),d7
	cmp.b	bm_Depth(a0),d7
	bne.s	old_1
a334 1
	sub.l	a2,a2									; don't use temp
d338 1
d344 2
d347 1
a347 1
		movem.l d2-d7/a0-a5,-(a7)
@


39.3
log
@ improved to handle bltbitmap with minterm of 0 ( no source)
@
text
@d1 1
a1 1
	TTL    '$Id: bltcopy.asm,v 39.2 91/11/19 10:34:50 chrisg Exp Locker: chrisg $'
d13 3
d314 1
a314 1
	bgt		old_1
@


39.2
log
@  updated because of new magic cookie for interleaved bitmaps.
@
text
@d1 1
a1 1
	TTL    '$Id: bltcopy.asm,v 39.1 91/11/15 11:04:29 chrisg Exp Locker: chrisg $'
d13 3
a287 2
	cmp.b	#UNLIKELY_BYTE,bm_Flags(a0)
	bne	old_entry
d292 5
d299 6
d308 5
a312 6
	move.w	a1,d7
	cmp.w	bm_Pad(a1),d7
	bne.s	old_1
	move.b	bm_Depth(a0),d7
	cmp.b	bm_Depth(a1),d7
	bne	old_1
a313 1
	mulu	d7,d1	; srcy*=depth
d316 1
@


39.1
log
@ added support for interleaved bitmaps!
@
text
@d1 1
a1 1
	TTL    '$Id: bltcopy.asm,v 39.0 91/08/21 17:35:29 chrisg Exp Locker: chrisg $'
d13 3
a286 2
	cmp.w	#UNLIKELY_WORD,bm_Pad(a0)
	bne	old_entry
a288 2
	cmp.w	#UNLIKELY_WORD,bm_Pad(a1)
	bne	old_entry
d291 8
a301 2
	movem.l	d1/d3/d5/d7/a2,-(a7)
	lea	-bm_SIZEOF*2(a7),a7
a313 2
	move.w	bm_Rows(a0),bm_Rows(a7)		; shouldn't matter
	move.w	bm_Rows(a1),bm_SIZEOF+bm_Rows(a7)		; shouldn't matter
d319 2
a320 1
	bsr	old_1
a324 1
old_1:	st	d7
@


39.0
log
@Bumped
@
text
@d1 1
a1 1
	TTL    '$Id: bltcopy.asm,v 37.3 91/05/09 14:47:43 spence Exp Locker: chrisg $'
d13 3
d280 1
d282 41
@


37.3
log
@*** empty log message ***
@
text
@d1 1
a1 1
	TTL    '$Id: bltcopy.asm,v 37.2 91/02/12 15:51:11 spence Exp Locker: spence $'
d10 1
a10 1
*   Source Control: $Locker: spence $
d13 3
@


37.2
log
@autodoc
@
text
@d1 1
a1 1
	TTL    '$Id: bltcopy.asm,v 37.1 91/01/18 17:21:59 spence Exp Locker: spence $
d13 3
@


37.1
log
@Checks for NULL from getmustmem(), which no longer gurus.
Makes a quick exit if NULL found. This may cause guru further up the
calling chain - I hope not.
@
text
@d1 1
a1 1
	TTL    '$Id: bltcopy.asm,v 37.0 91/01/07 15:28:41 spence Exp Locker: spence $
d13 5
d204 1
a204 1
*	    DstX, DstY, SizeX, SizeY, Minterm, Mask [, TempA] )
d207 2
a208 2
*	ULONG BltBitMap( struct BitMap *, WORD, WORD, struct BitMap *,
*	    WORD, WORD, WORD, WORD, UBYTE, UBYTE, UWORD * );
d219 1
a219 1
*		rectangles
d255 5
a259 5
*	    to hold a line of A source for the blit. BitBitMap will
*	    allocate the needed TempA if none is provided and one
*	    is needed.  Blit overlap is determined from the relation
*	    of the first non-masked planes in the source and
*	    destination bit maps.
d268 1
a268 1
*	ClipBlit graphics/gfx.h hardware/blit.h
d1140 1
a1140 1
******* graphics.library/BltTemplate *********************************
d1147 1
a1147 1
*		    A0	         D0:16  D1:16  A1
d1151 2
a1152 2
*	void BltTemplate( UWORD *, WORD, WORD, struct RastPort *,
*	    WORD, WORD, WORD, WORD );
d1168 6
a1173 6
*	SrcTemplate - pointer to the first (nearest) word of the template mask.
*	SrcX - x bit offset into the template mask (range 0..15).
*	SrcMod - number of bytes per row in template mask.
*	rp - pointer to destination RastPort.
*	DstX, DstY - x and y coordinates of the upper left
*	    corner of the destination for the blit.
d1175 1
a1175 1
*	    template.
d1181 1
a1181 1
*	BltBitMap	graphics/rastport.h
d1183 1
a1183 1
**********************************************************************
@


37.0
log
@initial switchover from V36
@
text
@d1 1
a1 1
	TTL    '$Id: bltcopy.asm,v 36.10 90/05/10 10:11:27 kodiak Exp Locker: spence $
d13 3
d772 2
d841 1
d903 2
@


36.10
log
@optimize lea bm_Planes(an),an to addq.l #bm_Planes,an
@
text
@d1 1
a1 1
	TTL    '$Id: bltcopy.asm,v 36.9 90/04/24 10:46:38 kodiak Exp Locker: kodiak $
d10 1
a10 1
*   Source Control: $Locker: kodiak $
d13 3
@


36.9
log
@document blitter usage
@
text
@d1 1
a1 1
	TTL    '$Id: bltcopy.asm,v 36.8 90/04/13 11:52:12 kodiak Exp Locker: kodiak $
d13 3
d296 2
a297 2
		lea	bm_Planes(a0),a0	; srcPlane
		lea	bm_Planes(a1),a1	; destPlane
d1426 1
a1426 1
		lea	bm_Planes(a2),a2
@


36.8
log
@use Id instead of Header for 4.x rcs
@
text
@d1 1
a1 1
	TTL    '$Id$
d13 3
d250 2
a251 1
*   BUGS
d1158 2
a1159 1
*   BUGS
@


36.7
log
@for rcs 4.x header change
@
text
@d1 1
a1 1
	TTL    '$Header: /usr2/kodiak/src/KS/graphics/text/RCS/bltcopy.asm,v 36.6 90/03/05 16:23:45 kodiak Exp Locker: kodiak $'
d13 3
@


36.6
log
@fix superbitmap BltTemplate (and thus Text)
@
text
@d1 1
a1 1
	TTL    '$Header: bltcopy.asm,v 36.5 89/11/02 18:37:36 kodiak Exp $'
d13 3
@


36.5
log
@recode to use gb_ExecBase
@
text
@d1 1
a1 1
	TTL    '$Header: bltcopy.asm,v 36.4 89/08/16 12:58:24 kodiak Exp $'
d13 3
d1246 1
a1246 1
		move.l	d7,a3
d1253 1
a1253 1
		move.w	PARM_SRCMOD(a5),a2	; recover srcModulo
@


36.4
log
@document 0/-1 plane pointer hack
@
text
@d1 1
a1 1
	TTL    '$Header: bltcopy.asm,v 36.3 89/07/18 15:50:04 kodiak Exp $'
d13 3
a67 7
	XREF_EXE	Alert
	XREF		_AbsExecBase

	XREF_GFX	UnlockLayerRom
	XREF_GFX	LockLayerRom
	XREF_GFX	OwnBlitter
	XREF_GFX	DisownBlitter
d70 4
d75 1
d590 1
a590 1
		CALLGFX DisownBlitter
d753 1
a753 1
		CALLGFX	OwnBlitter	; (before the waitblitdone)
d881 1
a881 1
		CALLGFX	OwnBlitter	; (before the waitblitdone)
d1014 1
a1014 1
		CALLGFX	OwnBlitter
d1057 1
a1057 1
		CALLGFX	OwnBlitter
d1187 1
a1187 1
		CALLGFX	LockLayerRom		; does NOT hit d0/d1/a0/a1
d1263 1
a1263 1
		CALLGFX	UnlockLayerRom		; does NOT hit d0/d1/a0/a1
d1632 1
a1632 1
		CALLGFX DisownBlitter
@


36.3
log
@special case for zero & $ffffffff plane pointers
@
text
@d1 1
a1 1
	TTL    '$Header: bltcopy.asm,v 36.2 89/07/17 15:03:55 kodiak Exp $'
d10 1
a10 1
*   Source Control: $Locker:  $
d13 3
d197 6
a202 1
*	    - SrcBitMap and DstBitMap can be identical
@


36.2
log
@waitblitdone after OwnBlitter for BltTemplate left or right cases
@
text
@d1 1
a1 1
	TTL    '$Header: bltcopy.asm,v 36.1 89/06/08 14:22:42 kodiak Exp $'
d10 1
a10 1
*   Source Control: $Locker: kodiak $
d13 3
d91 1
d100 4
d105 4
a112 1
    UWORD	EMUL_CON0	; original con0 (from d2)
d270 1
a270 1
		movem.l	PARM_MINTERM(a5),d6/d7/a0-a1
d273 3
a275 4
		;-- set constant CON0
		andi.w	#$F0,d6			; mask minterm to 4:4
		or.w	d6,d2
		move.w	d2,bltcon0(a4)
d278 1
a279 1
		moveq	#0,d5			; actual plane count
d515 7
d524 2
a526 2
		bsr	waitblitdone
		move.l	a2,bltbpt(a4)
d536 16
d559 7
d568 2
a570 2
		bsr	waitblitdone
		move.l	a2,bltbpt(a4)
d637 9
a645 1
;	a5	preserved
d784 2
a785 2
	    ;-- partial con0 (minterm and A shift) into d2
		move.w	#NABC+NANBC+SRCA+SRCB+SRCC+DEST,d2
d923 2
a924 2
	    ;-- partial con0 (minterm and A shift) into d2
		move.w	#NABC+NANBC+SRCA+SRCB+SRCC+DEST,d2
d1038 2
a1039 2
	    ;-- partial con0 (minterm and A shift) into d2
		move.w	#NABC+NANBC+SRCB+SRCC+DEST,d2
d1090 1
a1090 1
	    ;-- partial con0 (minterm and A shift) into d2
d1092 1
d1389 1
a1389 1
		;-- get write mask
d1391 1
a1419 1
		move.w	d2,EMUL_CON0(a7)
d1495 1
a1495 1
		or.w	EMUL_CON0(a7),d1
@


36.1
log
@define out big blit emulation
define EMULATE to put it back in
@
text
@d1 1
a1 1
	TTL    '$Header: bltcopy.asm,v 36.0 89/06/05 14:15:14 kodiak Exp $'
d13 4
d695 3
d714 1
a714 2
		;-- grab the blitter
		CALLGFX	OwnBlitter
d823 3
d841 1
a841 2
		;-- grab the blitter
		CALLGFX	OwnBlitter
@


36.0
log
@autodoc changes
@
text
@d1 1
a1 1
	TTL    '$Header: bltcopy.asm,v 35.4 87/12/03 12:59:03 kodiak Exp $'
d13 3
d93 2
d113 2
d269 2
d281 1
d284 1
d292 1
d305 1
d491 3
d1344 3
a1346 1
		bne	bigBT
d1522 3
a1525 7
	    ;-- release the blitter
tdbDisown:
		CALLGFX DisownBlitter

tdbRts:
		move.l	(a7)+,a4
		rts
d1534 1
d1540 1
a1562 1
		bra	tdbDisown
d1564 8
d1592 1
a1592 1
		bra	tdbDisown
@


35.4
log
@emulate big blits on small blitters
@
text
@d1 1
a1 1
	TTL    '$Header: bltcopy.asm,v 33.0 86/05/17 15:29:04 bart Exp $'
d10 1
a10 1
*   Source Control: $Locker: bart $
d12 4
a15 1
*   $Log: bltcopy.asm,v $
d151 3
a153 3
*	d0		      a0      d0:16 d1:16   a1
*		  DstX, DstY, SizeX, SizeY, Minterm, Mask [, TempA])
*		  d2:16	d3:16 d4:16  d5:16   d6:8    d7:8    [a2]
d155 2
a156 7
*	ULONG planecnt;
*	struct BitMap *SrcBitMap,*DstBitMap;
*	SHORT SrcX,SrcY;
*	SHORT DstX,DstY;
*	SHORT SizeX,SizeY;
*	UBYTE MinTerm,Mask;
*	CPTR  TempA;	/*optional */
d1033 3
a1035 3
*		    a0	         d0:16  d1:16  a1
*		    DstX,  DstY, SizeX, SizeY)
*		    d2:16  d3:16 d4:16  d5:16
d1037 2
a1038 7
*	CPTR	SrcTemplate;
*	SHORT	SrcX;
*	SHORT	SrcMod;
*	struct  RastPort *rp;
*	SHORT	DstX,DstY;
*	SHORT	SizeX,SizeY;
*	
@


35.3
log
@emulate BIG_BLITS in BltTemplate if needed
@
text
@d71 3
d75 31
d217 3
a219 1
PARM_MINTERM	EQU	16		; then MASK, SRCBMAP, DESTBMAP
d224 1
a224 1
		beq.s	noPlanes
d233 1
a233 1
		move.l	a2,a4			; TmpRas
a246 1
		subq.l	#6,a7
a247 1
		addq.l	#6,a7
d250 1
a250 1
		movem.l	PARM_MINTERM+2(a7),d6/d7/a0-a1
d256 1
a256 1
		move.w	d2,bltcon0(a5)
d264 13
d282 1
a282 1
		bra.s	planesDBF
d284 1
a284 1
		move.w	d0,bltsizv(a5)
d286 1
a286 1
		bra.s	planebDBF
d293 1
a293 1
		bra.s	bbmRts
d295 185
d491 4
a494 4
		move.l	a2,bltbpt(a5)
		move.l	a3,bltcpt(a5)
		move.l	a3,bltdpt(a5)
		move.w	d0,bltsize(a5)
d512 4
a515 4
		move.l	a2,bltbpt(a5)
		move.l	a3,bltcpt(a5)
		move.l	a3,bltdpt(a5)
		move.w	d0,bltsizh(a5)
d530 1
a530 1
		move.l	a4,a1
d537 1
d559 1
a559 1
;	a4.l	TmpRas (or NULL)
d578 2
a579 2
;	a4.l	A data used (or NULL if constant A data)
;	a5.l	_custom
a581 3
BSSTK_STARTMASK	EQU	4
BSSTK_ENDMASK	EQU	6
BSSTK_DESCFLAG	EQU	8
d631 2
a632 1
		move.w	a2,bltbmod(a5)
d634 3
a636 2
		move.w	a3,bltcmod(a5)
		move.w	a3,bltdmod(a5)
d663 1
a663 1
		move.l	a4,d7		; tst.l a4 ; check for TempA
d672 2
a673 1
		move.l	d0,a4
d677 1
a677 1
		move.l	a4,a1		; recover A data memory
d695 1
a695 1
		lea	_custom,a5
d697 1
a697 1
		move.l	a4,bltapt(a5)
d699 2
a700 2
		move.l	d7,BSSTK_STARTMASK+2(a7)
		move.l	d7,bltafwm(a5)
d714 2
a715 2
		move.w	#$0000,BSSTK_DESCFLAG(a7)
		move.w	d7,bltcon1(a5)
d731 2
a732 1
		move.w	a2,bltbmod(a5)
d734 3
a736 2
		move.w	a3,bltcmod(a5)
		move.w	a3,bltdmod(a5)
d738 2
a739 1
		move.w	d6,bltamod(a5)
d753 2
a754 1
		move.w	d6,bltbmod(a5)
d757 3
a759 2
		move.w	d7,bltcmod(a5)
		move.w	d7,bltdmod(a5)
d789 1
a789 1
		move.l	a4,d7		; tst.l a4 ; check for TempA
d798 2
a799 1
		move.l	d0,a4
d803 1
a803 1
		move.l	a4,a1
d820 1
a820 1
		lea	_custom,a5
d822 2
a823 2
		move.l	d7,BSSTK_STARTMASK+2(a7)
		move.l	d7,bltafwm(a5)
d835 1
a835 1
		move.l	a1,bltapt(a5)
d842 2
a843 2
		move.w	#$8000,BSSTK_DESCFLAG(a7)
		move.w	d7,bltcon1(a5)
d865 2
a866 1
		move.w	d7,bltbmod(a5)
d870 3
a872 2
		move.w	d7,bltcmod(a5)
		move.w	d7,bltdmod(a5)
d874 2
a875 1
		move.w	d6,bltamod(a5)
d898 2
a899 1
		move.w	d6,bltbmod(a5)
d902 3
a904 2
		move.w	d7,bltcmod(a5)
		move.w	d7,bltdmod(a5)
d923 2
a924 1
		move.w	a2,bltbmod(a5)
d926 3
a928 2
		move.w	a3,bltcmod(a5)
		move.w	a3,bltdmod(a5)
d936 1
a936 1
		lea	_custom,a5
d943 2
a944 2
		move.w	d7,BSSTK_STARTMASK+4(a7)
		move.w	d7,bltafwm(a5)
d949 2
a950 2
		move.w	#$0000,BSSTK_DESCFLAG+4(a7)
		move.w	d7,bltcon1(a5)
d960 2
a961 2
		move.w	d7,BSSTK_ENDMASK+4(a7)
		move.w	d7,bltalwm(a5)
d972 1
a972 1
		move.w	#$ffff,bltadat(a5)
d979 1
a979 1
		lea	_custom,a5
d986 2
a987 2
		move.w	d7,BSSTK_STARTMASK+4(a7)
		move.w	d7,bltalwm(a5)
d997 2
a998 2
		move.w	d7,BSSTK_ENDMASK+4(a7)
		move.w	d7,bltafwm(a5)
d1013 2
a1014 2
		move.w	#$8000,BSSTK_DESCFLAG+4(a7)
		move.w	d7,bltcon1(a5)
d1024 1
a1024 1
		move.w	#$ffff,bltadat(a5)
d1076 2
a1077 2
 STRUCTURE  TEMP,0
	LONG	TEMP_CLIPRECT		; temp longword at (a7)
a1083 1
	LONG	PARM_SRCX		; d0
d1095 3
a1097 1
		movem.l d0-d7/a0-a5,-(a7)
a1108 2
		sub.w	#TEMP_SIZEOF,a7		; space for locals

d1110 1
d1113 1
d1121 1
a1121 1
		movem.w	d0/d2-d5,TEMP_SRC(a7)	; & DEST & SIZE
d1146 3
a1148 3
		move.l	PARM_SRCPLANE(a7),a0	; recover srcPlane
		move.w	PARM_SRCMOD+2(a7),a2	; recover srcModulo
		move.l	a3,(a7)			; TEMP_CLIPRECT(a7)
d1150 1
a1150 1
		move.l	(a7),a3			; TEMP_CLIPRECT(a7)
d1152 1
a1152 1
		movem.w	TEMP_SRC(a7),d0/d2-d5	; recover srcX, destXY, sizeXY
d1164 3
a1166 3
		move.w	PARM_DESTX+2(a7),d2
		move.w	PARM_DESTY+2(a7),d3
		movem.w	d2/d3,TEMP_DEST(a7)
d1174 3
a1176 3
		move.l	PARM_SRCPLANE(a7),a0	; recover srcPlane
		move.w	PARM_SRCMOD(a7),a2	; recover srcModulo
		move.l	a3,(a7)			; TEMP_CLIPRECT(a7)
d1178 1
a1178 1
		move.l	(a7),a3			; TEMP_CLIPRECT(a7)
d1180 1
a1180 1
		movem.w	TEMP_SRC(a7),d0/d2-d5	; recover srcX, destXY, sizeXY
a1189 1
		add.w	#TEMP_SIZEOF,a7		; space for locals
d1192 2
a1193 1
		movem.l (a7)+,d0-d7/a0-a5
d1314 1
d1316 1
a1316 1
		beq	tdeRts
d1318 1
a1318 1
		movem.l	a0-a1/a4,-(a7)
a1320 1
		subq.l	#6,a7
d1322 1
a1322 3
		move.l	(a7)+,d4		; recover START and END MASK
		move.w	(a7)+,d5		; recover decending flag
		movem.l	(a7)+,a0-a1/a4
d1330 2
a1331 1
		move.b	bm_Depth(a4),d6
d1333 1
a1333 1
		lea	bm_Planes(a4),a2
d1341 1
a1341 1
		bgt	tdbeDBF
d1345 1
a1345 1
		bgt	tdbeDBF
d1347 71
d1427 1
a1427 1
		or.w	d2,d1
d1429 1
a1429 1
		move.w	d1,bltcon0(a5)
d1431 9
a1439 8
		add.l	d3,a3
		move.l	a0,bltbpt(a5)
		move.l	a3,bltcpt(a5)
		move.l	a3,bltdpt(a5)
		;-- loop through x
		movem.l	d0/d2/d3/a0,-(a7)
		move.w	d0,d3			; set up Y
		swap	d0			; get X
d1441 8
a1448 11
		swap	d4
		tst	d5
		bmi.s	tdbeXDInit
		move.w	d1,bltalwm(a5)
		move.w	d4,bltafwm(a5)
		swap	d4
		bra.s	tdbeXLoop
tdbeXDInit:
		move.w	d1,bltafwm(a5)
		move.w	d4,bltalwm(a5)
		swap	d4
d1450 15
a1464 31
		sub.w	#$40,d0			; subtract 1K from X size
		bhi.s	tdbeX1K
		add.w	#$40,d0			; X <= 1K: last one
		beq.s	tdbeXEnd		; X = 0: the last was last
		move.w	d0,d2
		and.w	#$3f,d2
		tst	d5
		bmi.s	tdbeXDLast
		move.w	d4,bltalwm(a5)
		bra.s	tdbeYStart
tdbeXDLast:
		move.w	d4,bltafwm(a5)
		bra.s	tdbeYStart
tdbeX1K:
		clr.w	d2
tdbeYStart:
		swap	d0
		;-- loop through y
tdbeYLoop:
		sub.w	#$400,d3		; subtract 1K from Y size
		bhi.s	tdbeY1K
		add.w	#$400,d3		; Y <= 1K: last one
		lsl.w	#6,d3			; shift up Y
		or.w	d2,d3			; form bltsize register
		move.w	d3,bltsize(a5)
		;-- end of Y loop
		move.w	d0,d3			; set up next Y
		swap	d0			; get X
		tst.w	d0
		beq.s	tdbeXEnd
		;-- patch pointers for X
d1466 40
a1505 22
		move.l	d1,bltafwm(a5)		; and bltalwm
		moveq	#$40,d1
		tst.w	d5
		bmi.s	tdbeXDBump
		;--	ascending
		add.l	d1,a0
		add.l	d1,a3
		bra.s	tdbeXBumpPt
		;--	decending
tdbeXDBump:
		sub.l	d1,a0
		sub.l	d1,a3
tdbeXBumpPt:
		move.l	a0,bltbpt(a5)
		move.l	a3,bltcpt(a5)
		move.l	a3,bltdpt(a5)
		bra.s	tdbeXLoop
tdbeY1K:
		move.w	d2,bltsize(a5)		; ("Y" is clear -> 1K)
		bra.s	tdbeYLoop
tdbeXEnd:
		movem.l	(a7)+,d0/d2/d3/a0
d1510 1
d1513 1
d1516 2
a1517 1
tdeRts:
d1528 2
a1529 2
		move.w	d2,bltcon0(a5)
		move.w	d0,bltsizv(a5)
d1543 1
a1543 1
		move.w	d1,bltcon0(a5)
d1546 4
a1549 4
		move.l	a0,bltbpt(a5)
		move.l	a3,bltcpt(a5)
		move.l	a3,bltdpt(a5)
		move.w	d0,bltsize(a5)
d1554 1
a1555 5
	    ;-- release the blitter
		CALLGFX DisownBlitter

		rts

d1565 1
a1565 1
		move.b	rp_minterms(a1,d7.w),bltcon0l(a5)
d1568 4
a1571 4
		move.l	a0,bltbpt(a5)
		move.l	a3,bltcpt(a5)
		move.l	a3,bltdpt(a5)
		move.w	d0,bltsizh(a5)
d1576 1
a1577 3
	    ;-- release the blitter
		CALLGFX DisownBlitter
		rts
@


35.2
log
@support for BIG_BLIT
@
text
@d211 1
d213 1
d229 8
a236 1
		beq.s	planesDBF
d328 2
d349 3
d466 1
d481 1
d488 3
a490 5
		btst	#GFXB_BIG_BLITS,gb_ChipRevBits0(a6)
		bne.s	bbForwardA
		move.w	d5,d0		; get sizeY
		lsl.w	#6,d0		; shift sizeY up
		or.w	d6,d0
a491 1
modForwardA:
a504 7

	    ;-- blit size for big blits
bbForwardA:
		move.w	d6,d0
		swap	d0
		move.w	d5,d0
		bra.s	modForwardA
d583 1
d603 1
d618 3
a620 5
		btst	#GFXB_BIG_BLITS,gb_ChipRevBits0(a6)
		bne.s	bbReverseA
		move.w	d5,d0		; get sizeY
		lsl.w	#6,d0		; shift sizeY up
		or.w	d6,d0
a621 1
modReverseA:
a634 7

	    ;-- blit size for big blits
bbReverseA:
		move.w	d6,d0
		swap	d0
		move.w	d5,d0
		bra.s	modReverseA
d696 3
a698 1
		move.w	0(a0,d7.W),bltafwm(a5)
d703 1
d713 3
a715 1
		move.w	0(a0,d7.W),bltalwm(a5)
d719 3
a721 6
		btst	#GFXB_BIG_BLITS,gb_ChipRevBits0(a6)
		bne.s	bbForward
		move.w	d5,d0		; get sizeY
		lsl.w	#6,d0		; shift sizeY up
		or.w	d6,d0
con0Forward:
a728 7
	    ;-- blit size for big blits
bbForward:
		move.w	d6,d0
		swap	d0
		move.w	d5,d0
		bra.s	con0Forward

d739 3
a741 1
		move.w	0(a0,d7.W),bltalwm(a5)
d750 3
a752 1
		move.w	0(a0,d7.W),bltafwm(a5)
d767 1
d771 3
a773 6
		btst	#GFXB_BIG_BLITS,gb_ChipRevBits0(a6)
		bne.s	bbReverse
		move.w	d5,d0		; get sizeY
		lsl.w	#6,d0		; shift sizeY up
		or.w	d6,d0
con0Reverse:
a780 6
	    ;-- blit size for big blits
bbReverse:
		move.w	d6,d0
		swap	d0
		move.w	d5,d0
		bra.s	con0Reverse
d1068 1
a1068 1
		beq.s	tdbRts
d1073 1
d1075 2
d1089 119
a1207 1
		beq.s	tdbsDBF
d1216 1
a1216 1
		lsr.l	#1,d5
a1237 1
tdbRts:
d1244 1
a1244 1
		lsr.l	#1,d5
@


35.1
log
@text speed enhancements
@
text
@a2 11
*								     *
*   Copyright 1985, Commodore-Amiga Inc.   All rights reserved.	     *
*   No part of this program may be reproduced, transmitted,	     *
*   transcribed, stored in retrieval system, or translated into	     *
*   any language or computer language, in any form or by any	     *
*   means, electronic, mechanical, magnetic, optical, chemical,	     *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030				     *
*								     *
**********************************************************************
d4 3
a6 1
*	Control the gut level blts of rectangles
d8 1
a8 3
*   Source Control
*   --------------
*   $Header: bltcopy.asm,v 33.0 86/05/17 15:29:04 bart Exp $
d10 1
a10 1
*   $Locker: kodiak $
d12 1
a12 1
*   $Log:	bltcopy.asm,v $
d31 1
d166 5
a170 4
*	    (MAXBYTESPERROW) to hold a line of A source for the blit.
*	    BitBitMap will allocate the needed TempA if none is
*	    provided and one is needed. If the blit does not overlap;
*	    SrcBitMap != DstBitMap then TempA need not be supplied.
a183 1
PARM_TEMPA	EQU	32
d203 1
a203 1
		bmi.s	noPlanes		; no unmasked planes
d211 1
a211 1
		bsr.s	bltSetup
a212 3
		move.w	(a7)+,d6
		moveq	#0,d7

d214 1
a214 1
		movem.l	PARM_MINTERM(a7),d4-d5/a0-a1
d218 2
a219 2
		andi.w	#$F0,d4			; mask minterm to 4:4
		or.w	d4,d2
a220 1
		bra.s	planeDBF
d222 10
d233 2
d239 2
a240 2
	    ;--	cycle through the planes
planeLoop:
d244 2
a245 2
		lsr.l	#1,d5
		bcc.s	planeDBF
d254 1
a254 1
		addq.w	#1,d7
d256 3
a258 2
planeDBF:
		dbf	d6,planeLoop
d260 21
d285 1
a285 1
		move.l	a4,d7			; tst.l a4
a286 3
		;-- check if A data used was that provided in parms
		cmp.l	PARM_TEMPA(a7),d7
		beq.s	donePlanes
a289 1
		move.l	#MAXBYTESPERROW,d0
d294 1
a294 1
		move.l	d7,d0
d317 1
a317 1
;	a4.l	TmpRas of at least MAXBYTESPERROW bytes (or NULL)
d321 1
a321 1
;	d0.w	bltsize
d325 1
a325 1
;	d4	preserved
d409 6
d416 1
d419 3
d423 1
a423 1
		move.l	#MAXBYTESPERROW,d0
a428 4
	    ;-- calculate blit size
		move.w	d2,d6		; destX bit offset
		add.w	d4,d6		;   + sizeX
		subq.w	#1,d6		;   - 1
a429 1
		move.w	d6,-(a7)	; save dest + size - 1
a439 1
		lsr.w	#4,d6		; number of words to blit - 1
d470 1
a470 1
		lsr.w	#4,d6		; number of words to blit - 1
d472 2
d478 1
d492 7
d537 6
d544 1
d547 3
d551 1
a551 1
		move.l	#MAXBYTESPERROW,d0
a556 4
	    ;-- calculate blit size
		move.w	d2,d6		; destX bit offset
		add.w	d4,d6		;   + sizeX
		subq.w	#1,d6		;   - 1
d558 1
a558 2
		move.w	d6,-(a7)	; save dest + size - 1
		move.l	a4,a1		; recover A data memory
a566 1
		lsr.w	#4,d6		; number of words to blit - 1
d598 1
a598 1
		lsr.w	#4,d6		; number of words to blit - 1
d610 2
d616 1
d630 7
d667 1
a667 1
		bsr.s	reverseCore
a691 1
		move.w	#0,a4		; no A data
d716 2
d721 1
d725 1
d729 7
a739 1
		move.w	#0,a4		; no A data
d773 2
d778 1
d782 1
d786 7
d838 1
a838 1
*	BltPattern	graphics/rastport.h
d1064 1
a1064 1
;	d4	preserved
a1083 1
		moveq	#0,d1
d1096 8
a1103 3
		bra.s	tdbDBF
	    ;--	cycle through the planes
tdbLoop:
d1107 1
a1107 1
		bcc.s	tdbBumpPlane
d1120 1
a1120 1
tdbBumpPlane:
d1122 2
a1123 2
tdbDBF:
		dbf	d6,tdbLoop
d1131 24
@


35.0
log
@initial from V34
@
text
@d1 1
a1 1
	TTL    '$Header: bltcopy.asm,v 1.1 87/10/19 15:14:17 kodiak Exp $'
d15 2
a16 1
*	   **		Copy data into RastPort		 **
d19 1
a19 1
*   $Header: bltcopy.asm,v 1.1 87/10/19 15:14:17 kodiak Exp $
d48 3
d56 2
a57 2
	XREF	GetMustMem
	XREF	FreeMustMem
d73 2
a74 2
	XDEF	    _fwmaskTable
	XDEF	    _lwmaskTable
d78 2
a79 2
	XDEF	    _BltBitMap
	XDEF	    _BltTemplate
a80 1
*------ Local Structures ---------------------------------------------
a81 62
 STRUCTURE  BP,0
	UWORD	BP_CON0
	UWORD	BP_CON1
	UWORD	BP_FWMASK
	UWORD	BP_LWMASK
	APTR	BP_APTR
	WORD	BP_AMOD
	APTR	BP_SOURCE
	WORD	BP_SMOD
	APTR	BP_DEST
	WORD	BP_DMOD
	UWORD	BP_BSIZE
	LABEL	BP_SIZE


 STRUCTURE  BR,0
	BYTE	BR_FLAGS
	BYTE	BR_COUNT
	ULONG	BR_SRCWORD
	ULONG	BR_DESTWORD
	APTR	BR_NEXTBLIT
	STRUCT	BR_PLANE0,BP_SIZE
	STRUCT	BR_PLANE1,BP_SIZE
	STRUCT	BR_PLANE2,BP_SIZE
	STRUCT	BR_PLANE3,BP_SIZE
	STRUCT	BR_PLANE4,BP_SIZE
	STRUCT	BR_PLANE5,BP_SIZE
	STRUCT	BR_PLANE6,BP_SIZE
	STRUCT	BR_PLANE7,BP_SIZE
*			    ;-- These must be at the end, near BR_SIZE
	APTR	BR_TEMPA
	UWORD	BR_SXBytes	    ;temporary: used during blit setup,
	UWORD	BR_DXBytes	    ;  not during the blit itself
	LABEL	BR_SIZE


 STRUCTURE  BT,0
	BYTE	BT_FLAGS
	BYTE	BT_COUNT		; count down the planes
	WORD	BT_PLANE		; the current plane number
	APTR	BT_RP			; the raster port
	APTR	BT_CW			; the clip window
	APTR	BT_PLANES
	WORD	BT_WRITEMASK
	STRUCT	BT_BP,BP_SIZE

	WORD	BT_srcX		    ; cookie specification, saved for each
	LONG	BT_dest		    ;	iteration of a clip region
	LONG	BT_size		    ;
	LONG	BT_source	    ;

*			    ;-- These must be at the end, near BT_SIZE
	UWORD	BT_SXBytes	    ;temporary: used during blit setup,
	UWORD	BT_DXBytes	    ;  not during the blit itself
	LABEL	BT_SIZE

	IFNE	BT_SXBytes-BT_SIZE-BR_SXBytes+BR_SIZE
	FAIL	"XBytes fields not in the same place in local variables"
	ENDC

	BITDEF	BF,INITIALIZE,7

d83 15
a97 15
		DC.W    $08000
		DC.W	$0C000
		DC.W	$0E000
		DC.W	$0F000
		DC.W	$0F800
		DC.W	$0FC00
		DC.W	$0FE00
		DC.W	$0FF00
		DC.W	$0FF80
		DC.W	$0FFC0
		DC.W	$0FFE0
		DC.W	$0FFF0
		DC.W	$0FFF8
		DC.W	$0FFFC
		DC.W	$0FFFE
d99 16
a114 16
		DC.W    $0FFFF
		DC.W	$07FFF
		DC.W	$03FFF
		DC.W	$01FFF
		DC.W	$00FFF
		DC.W	$007FF
		DC.W	$003FF
		DC.W	$001FF
		DC.W	$000FF
		DC.W	$0007F
		DC.W	$0003F
		DC.W	$0001F
		DC.W	$0000F
		DC.W	$00007
		DC.W	$00003
		DC.W	$00001
d124 1
a124 1
*	D0		      A0      D0:16 D1:16   A1
d126 1
a126 1
*		  D2:16	D3:16 D4:16  D5:16   D6:8    D7:8    [A2]
a184 4
*       This routine uses over 300 bytes of stack when it really does
*	not need to. It calculates all blits ahead of time and then
*	sits in a loop doing the blits when it should overlap blits
*	with calculations.
a189 21
*
*   IMPLEMENTATION NOTES
*	D0  srxY	srcX
*	D1  destY	destX
*	D2  sizeY	sizeX
*	D3  minterm	BR_PLANEn offset in A6
*	D4  temporary		(was destWord, srcWord offsets)
*	D5  plane count plane mask
*	    plane countdown
*	D6  temporary
*	D7  temporary
*
*	A0  source BitMap
*	A1  destination BitMap
*	A2  temporary memory
*	A3  - unused -
*	A4  source
*	A5  destination
*	A6  blitter structure
*
*---------------------------------------------------------------------
d191 3
a193 13
		MOVEM.L D2-D7/A2-A5,-(A7)
		SWAP	D0
		MOVE.W	D1,D0
		SWAP	D0
		MOVE.W	D2,D1
		SWAP	D1
		MOVE.W	D3,D1
		SWAP	D1
		MOVE.W	D4,D2
		SWAP	D2
		MOVE.W	D5,D2
		SWAP	D2
		MOVE.W	D6,D3
d195 8
a202 11
		LINK	A6,#-BR_SIZE
		CLR.L	BR_TEMPA-BR_SIZE(A6)

*	;-- get constant info
*	    ;-- get lowest plane count
		MOVE.B	bm_Depth(A0),D5
		BEQ	noPlanes
		CMP.B	bm_Depth(A1),D5
		BLE.S	countHarmony
		MOVE.B	bm_Depth(A1),D5
		BEQ	noPlanes
d204 16
a219 22
		MOVE.B	D5,D4		;replicate plane count
		ROR.W	#8,D5		;  into
		MOVE.B	D4,D5		;  plane countdown
		SWAP	D5		;move both to high word
*	    ;-- get write mask
		MOVE.B	D7,D5
		BEQ	noPlanes
*	    ;-- get word offsets into planes
		SWAP	D2		;get y size ready
		MOVE.W	D1,D4		;get x
		LSR.W	#4,D4		;get x word offset
		ADD.W	D4,D4		;  (byte offset)
		EXT.L	D4
		SWAP	D1		;get y
		MOVE.W	D1,D6		;  save y
		MOVE.W	bm_BytesPerRow(A1),D7 ;get bytes per y
		MULS	D7,D6		;get y byte offset
setDOffset:
		MOVE.W	D7,BR_DXBytes-BR_SIZE(A6)
		ADD.L	D6,D4		;-- destination offset
		SWAP	D1		;restore dest
		MOVE.L	D4,BR_DESTWORD-BR_SIZE(A6)
d221 1
a221 21
		MOVE.W	D0,D4		;get x
		LSR.W	#4,D4		;get x word offset
		ADD.W	D4,D4		;  (byte offset)
		EXT.L	D4
		SWAP	D0		;get y
		MOVE.W	D0,D6		;  save y
		MOVE.W	bm_BytesPerRow(A0),D7 ;get bytes per y
		MULS	D7,D6		;get y byte offset
setSOffset:
		MOVE.W	D7,BR_SXBytes-BR_SIZE(A6)
		ADD.L	D6,D4		;-- source offset
		MOVE.L	D4,BR_SRCWORD-BR_SIZE(A6)
		SWAP	D0		;restore src
		SWAP	D2		;restore x size
*	    ;-- get plane pointers
		LEA	bm_Planes(A0),A0
		LEA	bm_Planes(A1),A1
*	    ;-- setup to store first blit
		ANDI.W	#$00F0,D3	;mask minterm to 4:4
		SWAP	D3
		MOVE.W	#BR_PLANE0-BR_SIZE,D3
d223 2
a224 15
*-- find planes and store their blit data
loopPlane:
		MOVE.L	(A0)+,A4
		MOVE.L	(A1)+,A5
		LSR.B	#1,D5
		BCC	maskedPlane
	    ;------ adjust planes by offsets
		ADD.L	BR_SRCWORD-BR_SIZE(A6),A4
		ADD.L	BR_DESTWORD-BR_SIZE(A6),A5
		MOVE.L	D0,-(A7)
		BSR	bltPlane
		TST.L	D0
		BNE.S	errorPlane
		MOVE.L	(A7)+,D0
		ADD.W	#BP_SIZE,D3
d226 9
a234 6
nextPlane:
		SWAP	D5
		SUBQ.B	#1,D5
		BEQ.S	planesDone
		SWAP	D5
		BRA	loopPlane
d236 4
a239 5
errorPlane:
		MOVE.L	(A7)+,D0
maskedPlane:
		SUB.L	#$01000000,D5	;adjust plane count
		BRA.S	nextPlane
d241 21
a261 22
planesDone:
		LSR.W	#8,D5
		MOVE.B	D5,BR_COUNT-BR_SIZE(A6)
		BEQ.S	donePlanes
		LEA	BR_PLANE0-BR_SIZE(A6),A0
		MOVE.L	A0,BR_NEXTBLIT-BR_SIZE(A6)
	;------ grab the blitter
		MOVE.L	A6,-(A7)
		MOVE.L	(A6),A6
		CALLGFX	OwnBlitter
	;------ perform the blit
brLoop:
		BSR	waitblitdone
		MOVE.L	(A7)+,A6
		MOVE.L	#_custom,A0
		LEA	-BR_SIZE(A6),A1
		BSR.S	rBlitCode
		MOVE.L	A6,-(A7)
		TST.B	BR_COUNT-BR_SIZE(A6)
		MOVE.L	(A6),A6
		BNE.S	brLoop
	;------ disown the blitter
d263 12
a274 1
		MOVE.L	(A7)+,A6
d277 5
a281 9
		MOVE.L	BR_TEMPA-BR_SIZE(A6),D0
		BEQ.S	noPlanes
		BSR	waitblitdone
		MOVE.L	D0,A1
		MOVE.L	#MAXBYTESPERROW,D0
		move.l	a6,-(sp)
		move.l	(a6),a6
		BSR		FreeMustMem
		move.l	(sp)+,a6
a282 6
noPlanes:
		UNLK	A6
		MOVEQ	#0,D0
		MOVE.B	D5,D0
		MOVEM.L (A7)+,D2-D7/A2-A5
		RTS
d284 55
d340 3
d344 4
a347 32
*------ rBlitCode ----------------------------------------------------
*
*	completion = rBlitCode(chips, node);
*	zero-condition-code    A0     A1
*
*---------------------------------------------------------------------
rBlitCode:
		MOVE.L	A2,-(A7)
*	    ;-- perform the next blit sequence
		MOVE.L	BR_NEXTBLIT(A1),A2
		MOVE.l	BP_CON0(A2),bltcon0(A0)
*		MOVE.W	BP_CON1(A2),bltcon1(A0)		* dale fix up
		MOVE.l	BP_FWMASK(A2),bltafwm(A0)
*		MOVE.W	BP_LWMASK(A2),bltalwm(A0)	* dale fix up
		MOVE.L	BP_APTR(A2),D0
		BEQ.S	adata
		MOVE.L	D0,bltapt(A0)
		MOVE.W	BP_AMOD(A2),bltamod(A0)
		BRA.S	source
adata:
		MOVE.W	#$0FFFF,bltadat(A0)
source:
		MOVE.L	BP_SOURCE(A2),bltbpt(A0)
		MOVE.W	BP_SMOD(A2),bltbmod(A0)
		MOVE.L	BP_DEST(A2),D0
		MOVE.L	D0,bltcpt(A0)
		MOVE.L	D0,bltdpt(A0)
		MOVE.W	BP_DMOD(A2),D0
		MOVE.W	D0,bltcmod(A0)
		MOVE.W	D0,bltdmod(A0)
*	    ;-- fire up the blit
		MOVE.W	BP_BSIZE(A2),bltsize(A0)
d349 4
a352 5
*	    ;-- decrement and set CC to non-zero if blit still pending
		ADD.L	#BP_SIZE,BR_NEXTBLIT(A1)
		SUBQ.B	#1,BR_COUNT(A1)
		MOVE.L	(A7)+,A2
		RTS
a353 40

*---------------------------------------------------------------------
*
*   NAME
*	bltPlane
*
*   INPUTS
*
*	D0  srxY	srcX			destroy - success flag
*	D1  destY	destX			preserve
*	D2  sizeY	sizeX			preserve
*	D3  minterm	BR_PLANEn offset in A6	preserve except SRCA
*	    ^if SRCA set then stencil already set up for ADATA
*	D4					preserve
*	D5					preserve
*	D6					destroy
*	D7					destroy
*
*	A0					preserve
*	A1					preserve
*	A2  temporary memory for ADATA stencil  preserve
*	A3					preserve
*	A4  source word for srcX		destroy
*	A5  destination word for destX		destroy
*	A6  blitter structure			preserve
*
bltPlane:
		MOVEM.L D4-D5/A0-A1,-(A7)
*   ;-- determine the blit direction & modulo
		MOVE.W	D0,D4		;get source and destination bits
		AND.W	#$0F,D4
		MOVE.W	D1,D5
		AND.W	#$0F,D5
		MOVE.W	BR_SXBytes-BR_SIZE(A6),D7
		CMP.W	BR_DXBytes-BR_SIZE(A6),D7
		BEQ.S	mightOverlap
*	;-- use blit modulos that cannot be "-2"
		CMP.W	D4,D5		;compare src to dest bit
		BLT	increasingReverse
		BRA	decreasingForward
d355 9
a363 4
		CMP.L	A4,A5		;compare src to dest address
		BGE	decreasing
		CMP.W	D4,D5		;compare src to dest bit
		BLT.S	increasingScanTest
d365 2
a366 2
*	;------ forward blit, positive modulo
		BSR	forwardCore
d368 9
a376 11
*	    ;-- construct modulos
		ADD.W	D7,D7		;get blit bytes (blit words << 1)
		NEG.W	D7
		MOVE.W	D7,D6
		ADD.W	BR_SXBytes-BR_SIZE(A6),D6
		MOVE.W	D6,BP_SMOD(A6,D3.W)
		ADD.W	BR_DXBytes-BR_SIZE(A6),D7
		MOVE.W	D7,BP_DMOD(A6,D3.W)
		MOVEM.L (A7)+,D4-D5/A0-A1
		MOVEQ	#0,D0
		RTS
d378 2
a379 1
*	    ;-- test if in the same scan line
d381 9
a389 16
		MOVE.W	D1,D6		;get dest x
		LSR.W	#4,D6		;get x word offset
		ADD.W	D6,D6		;  (byte offset)
		NEG.W	D6		;negate for subtraction
		EXT.L	D6		;
		ADD.L	A5,D6		;remove the x0 term from dest addr
		MOVE.W	D1,D7		;get dest x
		ADD.W	D2,D7		;  add size x
		SUBQ.W	#1,D7		;  and produce dest xf (final x)
		LSR.W	#4,D7		;get x word offset
		ADD.W	D7,D7		;  (byte offset)
		EXT.L	D7		;
		ADD.L	D6,D7		;get xf dest address
		CMP.L	A4,D7		;compare with source address
		BLT	increasingReverse
*	;------ forward blit, positive modulo, with A source
d391 1
a391 39
*	    ;-- get B shift into con1
		MOVE.W	D5,D7	;get dest x bit
		SUB.W	D4,D7	;  subtract src x bit
		AND.W	#$0F,D7 ;  "add 16" to the negative result
		ROR.W	#4,D7
		MOVE.W	D7,BP_CON1(A6,D3.W)
*	    ;-- get number of words in blit
		MOVE.W	D1,D6		    ;dest x
		ADD.W	D2,D6		    ;	    + size x
		SUBQ.W	#1,D6		    ;		     - 1
		MOVE.W	D6,D4		    ;save for A source init data
		MOVE.W	D1,D7
		LSR.W	#4,D7		    ;first word
		LSR.W	#4,D6		    ;last word
		SUB.W	D7,D6		    ;difference
*	    ;-- move minterm into con0
		MOVE.W	#NABC+NANBC+SRCB+SRCC+DEST,D7
		SWAP	D3
		BSET	#BC0B_SRCA,D3
		BNE	foreASourceGot
		OR.W	D3,D7
		SWAP	D3
		MOVE.W	D7,BP_CON0(A6,D3.W)
*	;-- set A source
		MOVE.L	A2,D7		; check for TempA
		BNE.S	gotForwardA
		MOVEM.L	D0-D1,-(A7)
		MOVE.L	BR_TEMPA-BR_SIZE(A6),D0
		BNE.S	gotForwardTempA
		MOVE.L	#MAXBYTESPERROW,D0
		MOVEQ	#MEMF_CHIP,D1
		move.l	a6,-(sp)
		move.l	(a6),a6
		BSR		GetMustMem
		move.l	(sp)+,a6
gotForwardTempA:
		MOVE.L	D0,A2
		MOVEM.L	(A7)+,D0-D1
		BRA.S	allocedForwardA
d393 9
d403 19
a421 11
		BSR	waitblitdone	    ;wait for blitter using this memory
allocedForwardA:
		MOVE.L	A2,A1		    ;use for A source memory
		CLR.W	(A1)+		    ;clear first word
		MOVE.W	D5,D7		    ;using dest x bit...
		ADD.W	D7,D7		    ;
		LEA	_fwmaskTable(PC),A0	    ;  get
		MOVE.W	0(A0,D7.W),(A1)+    ;  second word like a fwmask
		MOVE.W	D6,D7		    ;get words in data line
		BRA.S	midForwardA
*	    ;-- initialize A source
d423 1
a423 1
		MOVE.W	#$0FFFF,(A1)+
d425 30
a454 7
		DBF	D7,initForwardA
		AND.W	#$0F,D4
		ADD.W	D4,D4
		LEA	_lwmaskTable(PC),A0
		MOVE.W	0(A0,D4.W),D4	    ;last word like lwmask
		AND.W	D4,-2(A1)	    ;  which can overlap fwmask
		BRA.S	foreWMasks
d456 2
a457 5
*	;-- join back in if A source already initialized
foreASourceGot:
		OR.W	D3,D7
		SWAP	D3
		MOVE.W	D7,BP_CON0(A6,D3.W)
d459 11
a469 7
*	;-- set fwmask and lwmask
foreWMasks:
		MOVE.W	#$0FFFF,BP_FWMASK(A6,D3.W)
		MOVE.W	#$0FFFF,BP_LWMASK(A6,D3.W)
*	;-- get blit length
		ADDQ.W	#2,D6		;blit length: words
		MOVE.W	D6,D5		;save for blit size calc
a470 5
*	;-- save start addresses
		MOVE.L	A2,BP_APTR(A6,D3.W)
		MOVE.L	A4,BP_SOURCE(A6,D3.W)
		SUBQ.L	#2,A5
		MOVE.L	A5,BP_DEST(A6,D3.W)
d472 1
a472 37
*	;-- construct modulos
		ADD.W	D6,D6		;get blit bytes (blit words << 1)
		NEG.W	D6
		MOVE.W	D6,BP_AMOD(A6,D3.W)
		MOVE.W	D6,D7
		ADD.W	BR_SXBytes-BR_SIZE(A6),D6
		MOVE.W	D6,BP_SMOD(A6,D3.W)
		ADD.W	BR_DXBytes-BR_SIZE(A6),D7
		MOVE.W	D7,BP_DMOD(A6,D3.W)

*	;-- construct blit size
		SWAP	D2
		MOVE.W	D2,D7
		SWAP	D2
		LSL.W	#6,D7
		OR.W	D5,D7
		MOVE.W	D7,BP_BSIZE(A6,D3.W)
		MOVEM.L (A7)+,D4-D5/A0-A1
		MOVEQ	#0,D0
		RTS

* not needed anymore
*noTempA:
*		MOVEM.L	(A7)+,D0-D1
*
*		;------ ALERT, need not be dead end
*		MOVEM.L	D7/A5,-(A7)
*		MOVE.L	#AN_BltBitMap,D7
*		LEA	-BR_SIZE(A6),A5
*		LINKEXE	Alert
*		MOVEM.L	(A7)+,D7/A5
*
*		MOVEM.L (A7)+,D4-D5/A0-A1
*		MOVEQ	#1,D0
*		RTS

*	;------ reverse blit, negative modulo
d474 1
a474 1
		BSR	reverseCore
d476 12
a487 12
*	    ;-- construct modulos
		ADDQ.W	#2,D7		;blit length
		MOVE.W	D7,D6
		ADD.W	BR_SXBytes-BR_SIZE(A6),D6
		NEG.W	D6
		MOVE.W	D6,BP_SMOD(A6,D3.W)
		ADD.W	BR_DXBytes-BR_SIZE(A6),D7
		NEG.W	D7
		MOVE.W	D7,BP_DMOD(A6,D3.W)
		MOVEM.L (A7)+,D4-D5/A0-A1
		MOVEQ	#0,D0
		RTS
d490 1
a490 1
*	    ;-- decreasing blit
d492 2
a493 19
		CMP.W	D4,D5		;compare src to dest bit
		BLE	decreasingReverse
*	    ;-- test if in the same scan line
		MOVE.W	D0,D7		;get src x
		LSR.W	#4,D7		;get x word offset
		ADD.W	D7,D7		;  (byte offset)
		NEG.W	D7		;negate for subtraction
		EXT.L	D7		;
		ADD.L	A4,D7		;remove the x0 term from src addr
		MOVE.W	D0,D6		;get src x
		ADD.W	D2,D6		;  add size x
		SUBQ.W	#1,D6		;  and produce src xf (final x)
		LSR.W	#4,D6		;get x word offset
		ADD.W	D6,D6		;  (byte offset)
		EXT.L	D6		;
		ADD.L	D7,D6		;get xf src address
		CMP.L	D6,A5		;compare with destination address
		BGT	decreasingForward
*	;------ reverse blit, negative modulo, with A source
d495 10
a504 40
*	    ;-- get B shift into con1
		MOVE.W	D4,D7	;get src x bit
		SUB.W	D5,D7	;  subtract dest x bit
		AND.W	#$0F,D7 ;  "add 16" to the negative result
		ROR.W	#4,D7
		OR.W	#BC1F_DESC,D7
		MOVE.W	D7,BP_CON1(A6,D3.W)
*	    ;-- get number of words in blit
		MOVE.W	D1,D6		    ;dest x
		ADD.W	D2,D6		    ;	    + size x
		SUBQ.W	#1,D6		    ;		     - 1
		MOVE.W	D6,D4		    ;save for A source init data
		MOVE.W	D1,D7
		LSR.W	#4,D7		    ;first word
		LSR.W	#4,D6		    ;last word
		SUB.W	D7,D6		    ;difference
*	    ;-- move minterm into con0
		MOVE.W	#NABC+NANBC+SRCB+SRCC+DEST,D7
		SWAP	D3
		BSET	#BC0B_SRCA,D3
		BNE	reveASourceGot
		OR.W	D3,D7
		SWAP	D3
		MOVE.W	D7,BP_CON0(A6,D3.W)
*	;-- set A source
		MOVE.L	A2,D7		; check for TempA
		BNE.S	gotReverseA
		MOVEM.L	D0-D1,-(A7)
		MOVE.L	BR_TEMPA-BR_SIZE(A6),D0
		BNE.S	gotReverseTempA
		MOVE.L	#MAXBYTESPERROW,D0
		MOVEQ	#MEMF_CHIP,D1
		move.l	a6,-(sp)
		move.l	(a6),a6
		BSR		GetMustMem
		move.l	(sp)+,a6
gotReverseTempA:
		MOVE.L	D0,A2
		MOVEM.L	(A7)+,D0-D1
		BRA.S	allocedReverseA
d506 10
d517 18
a534 10
		BSR	waitblitdone	    ;wait for blitter using this memory
allocedReverseA:
		MOVE.L	A2,A1		    ;use for A source memory
		MOVE.W	D5,D7		    ;using dest x bit...
		ADD.W	D7,D7		    ;
		LEA	_fwmaskTable(PC),A0	    ;  get
		MOVE.W	0(A0,D7.W),(A1)+    ;  first word like a fwmask
		MOVE.W	D6,D7		    ;get words in data line
		BRA.S	midReverseA
*	    ;-- initialize A source
d536 1
a536 1
		MOVE.W	#$0FFFF,(A1)+
d538 56
a593 8
		DBF	D7,initReverseA
		AND.W	#$0F,D4
		ADD.W	D4,D4
		LEA	_lwmaskTable(PC),A0
		MOVE.W	0(A0,D4.W),D4	    ;last word-1 like lwmask
		AND.W	D4,-2(A1)	    ;  which can overlap fwmask
		CLR.W	(A1)		    ;clear last word
		BRA.S	reveWMasks
a594 5
*	;-- join back in if A source already initialized
reveASourceGot:
		OR.W	D3,D7
		SWAP	D3
		MOVE.W	D7,BP_CON0(A6,D3.W)
d596 1
a596 43
*	;-- set fwmask and lwmask
reveWMasks:
		MOVE.W	#$0FFFF,BP_FWMASK(A6,D3.W)
		MOVE.W	#$0FFFF,BP_LWMASK(A6,D3.W)
*	;-- adjust start addresses
		MOVE.W	D6,D7
		ADD.W	D7,D7		    ;scan bytes - 4
*	    ;-- adjust source and destination to end of rectangle
		ADD.W	D7,A4
		MOVE.L	A4,BP_SOURCE(A6,D3.W)
		ADDQ	#2,D7		    ;scan bytes - 2
		MOVE.L	A2,A1
		ADD.W	D7,A1
		MOVE.L	A1,BP_APTR(A6,D3.W) ;end of ADATA
		ADD.W	D7,A5
		MOVE.L	A5,BP_DEST(A6,D3.W)

*	;-- construct modulos
		ADDQ.W	#2,D7		    ;scan bytes
		NEG.W	D7
		MOVE.W	D7,BP_AMOD(A6,D3.W)
		NEG.W	D7
		MOVE.W	D7,D5
		ADD.W	BR_SXBytes-BR_SIZE(A6),D5
		NEG.W	D5
		MOVE.W	D5,BP_SMOD(A6,D3.W)
		ADD.W	BR_DXBytes-BR_SIZE(A6),D7
		NEG.W	D7
		MOVE.W	D7,BP_DMOD(A6,D3.W)

*	;-- construct blit size
		SWAP	D2
		MOVE.W	D2,D7
		SWAP	D2
		LSL.W	#6,D7
		ADDQ.W	#2,D6		    ;scan words
		OR.W	D6,D7
		MOVE.W	D7,BP_BSIZE(A6,D3.W)
		MOVEM.L (A7)+,D4-D5/A0-A1
		MOVEQ	#0,D0
		RTS

*	;------ forward blit, negative modulo
d598 1
a598 1
		BSR.S	forwardCore
d600 8
a607 9
*	    ;-- construct modulos
		ADD.W	D7,D7		;get blit bytes (blit words << 1)
		MOVE.W	D7,D6
		ADD.W	BR_SXBytes-BR_SIZE(A6),D6
		NEG.W	D6
		MOVE.W	D6,BP_SMOD(A6,D3.W)
		ADD.W	BR_DXBytes-BR_SIZE(A6),D7
		NEG.W	D7
		MOVE.W	D7,BP_DMOD(A6,D3.W)
d609 11
a619 2
*	    ;-- fix up blit start addresses to last line of rectangle
		BRA.S	lastLine
d621 1
a621 1
*	;------ reverse blit, positive modulo
d623 1
a623 1
		BSR	reverseCore
d625 8
a632 8
*	    ;-- construct modulos
		ADDQ.W	#2,D7		;blit length
		NEG.W	D7
		MOVE.W	D7,D6
		ADD.W	BR_SXBytes-BR_SIZE(A6),D6
		MOVE.W	D6,BP_SMOD(A6,D3.W)
		ADD.W	BR_DXBytes-BR_SIZE(A6),D7
		MOVE.W	D7,BP_DMOD(A6,D3.W)
d634 8
a641 14
*	    ;-- fix up blit start addresses to last line of rectangle
lastLine:
		SWAP	D2
		MOVE.W	D2,D6
		SUBQ.W	#1,D6
		MOVE.W	D6,D7
		SWAP	D2
		MULU	BR_SXBytes-BR_SIZE(A6),D6
		ADD.L	D6,BP_SOURCE(A6,D3.W)
		MULU	BR_DXBytes-BR_SIZE(A6),D7
		ADD.L	D7,BP_DEST(A6,D3.W)
		MOVEM.L (A7)+,D4-D5/A0-A1
		MOVEQ	#0,D0
		RTS
d643 2
a644 1
*------ forwardCore --------------------------------------------------
d646 35
a680 36
*	;-- get fwmask and lwmask
*	    ;-- fwmask for dest
		MOVE.W	D5,D7
		ADD.W	D7,D7
		LEA	_fwmaskTable(PC),A0
		MOVE.W	0(A0,D7.W),BP_FWMASK(A6,D3.W)
*	    ;-- get B shift into con1
		MOVE.W	D5,D7	;get dest x bit
		SUB.W	D4,D7	;  subtract src x bit
		ROR.W	#4,D7
		MOVE.W	D7,BP_CON1(A6,D3.W)
*	    ;-- move minterm into con0
		MOVE.W	#NABC+NANBC+SRCB+SRCC+DEST,D7
		SWAP	D3
		BCLR	#BC0B_SRCA,D3
		OR.W	D3,D7
		SWAP	D3
		MOVE.W	D7,BP_CON0(A6,D3.W)
*	    ;-- lwmask for dest + size - 1
		MOVE.W	D1,D7
		ADD.W	D2,D7
		SUBQ.W	#1,D7
		MOVE.W	D7,D5		;save dest + size - 1
		AND.W	#$0F,D7
		ADD.W	D7,D7
		LEA	_lwmaskTable(PC),A0
		MOVE.W	0(A0,D7.W),BP_LWMASK(A6,D3.W)
*	    ;-- show constant adata
		CLR.L	BP_APTR(A6,D3.W)
*	;-- get blit length
		MOVE.W	D1,D7
		LSR.W	#4,D7		;first word
		LSR.W	#4,D5		;last word
		SUB.W	D7,D5
		ADDQ.W	#1,D5		;blit length: words
		MOVE.W	D5,D7		;save for blit size calc
d682 1
a682 14
*	;-- save start addresses
		MOVE.L	A4,BP_SOURCE(A6,D3.W)
		MOVE.L	A5,BP_DEST(A6,D3.W)

*	;-- construct blit size
		SWAP	D2
		MOVE.W	D2,D6
		SWAP	D2
		LSL.W	#6,D6
		OR.W	D5,D6
		MOVE.W	D6,BP_BSIZE(A6,D3.W)
		RTS

*------ reverseCore --------------------------------------------------
d684 44
a727 37
*	;-- get fwmask and lwmask
*	    ;-- lwmask for src
		MOVE.W	D4,D7
		ADD.W	D7,D7
		LEA	_fwmaskTable(PC),A0
		MOVE.W	0(A0,D7.W),BP_LWMASK(A6,D3.W)
*	    ;-- get B shift into con1
		MOVE.W	D4,D7	;get src x bit
		SUB.W	D5,D7	;  subtract dest x bit
		ROR.W	#4,D7
		MOVE.W	D7,D6	;save for con0
		OR.W	#BC1F_DESC,D7
		MOVE.W	D7,BP_CON1(A6,D3.W)
*	    ;-- get A shift & minterm into con0
		OR.W	#NABC+NANBC+SRCB+SRCC+DEST,D6
		SWAP	D3
		BCLR	#BC0B_SRCA,D3
		OR.W	D3,D6
		SWAP	D3
		MOVE.W	D6,BP_CON0(A6,D3.W)
*	    ;-- fwmask for src + size - 1
		MOVE.W	D0,D7
		ADD.W	D2,D7
		SUBQ.W	#1,D7
		MOVE.W	D7,D5		;save src + size - 1
		AND.W	#$0F,D7
		ADD.W	D7,D7
		LEA	_lwmaskTable(PC),A0
		MOVE.W	0(A0,D7.W),BP_FWMASK(A6,D3.W)
*	    ;-- show constant adata
		CLR.L	BP_APTR(A6,D3.W)
*	;-- get line length
		MOVE.W	D0,D7
		LSR.W	#4,D7		;first word
		LSR.W	#4,D5		;last word
		SUB.W	D7,D5
		MOVE.W	D5,D7		;save for blit size calc
a728 18
*	;-- save start addresses
		ADD.W	D7,D7		;get line bytes
		ADD.W	D7,A4
		MOVE.L	A4,BP_SOURCE(A6,D3.W)
		ADD.W	D7,A5
		MOVE.L	A5,BP_DEST(A6,D3.W)

*	;-- construct blit size
		SWAP	D2
		MOVE.W	D2,D6
		SWAP	D2
		LSL.W	#6,D6
		OR.W	D5,D6
		ADDQ.W	#1,D6		;adjust line size to blit length
		MOVE.W	D6,BP_BSIZE(A6,D3.W)
		RTS


d777 19
a795 14
*
*   IMPLEMENTATION NOTES
*	D0		srcX
*	D1  destY	destX
*	D2  sizeY	sizeX
*	D3  srcMod
*	D4  temporary
*	D5  clip code
*	A0  srcTemplate
*	A1  destRastPort
*	A2  destBitMap
*	A3  destination ClipRect
*
*---------------------------------------------------------------------
d797 1
a797 9
		MOVEM.L D2-D7/A2-A5,-(A7)
		EXG	D1,D3
		SWAP	D1
		MOVE.W	D2,D1
		MOVE.W	D4,D2
		SWAP	D2
		MOVE.W	D5,D2
		SWAP	D2
		LINK	A6,#-BT_SIZE
a798 2
		MOVE.W	D3,BT_SXBytes-BT_SIZE(A6)	; stash modulo

d800 7
a806 7
		MOVE.L	A1,BT_RP-BT_SIZE(A6)
		MOVE.L	A0,A4
		MOVE.L	rp_Layer(A1),D4
		BNE	clipRects
		MOVE.L	rp_BitMap(A1),A2
		BSR	tDoBlit
		BRA	btUnlk
d809 1
a809 6
	    ;-- lock clip windows
		MOVEM.L D0-D1/A0-A1/A6,-(A7)
		MOVE.L	D4,A5
		MOVE.L	(A6),A6
		CALLGFX	LockLayerRom
		MOVEM.L (A7)+,D0-D1/A0-A1/A6
d811 3
a813 13
	;------ save parms to perform operation for every clip rectangle
		MOVE.L	D4,BT_CW-BT_SIZE(A6)
		MOVE.L	A0,BT_source-BT_SIZE(A6)
		MOVE.W	D0,BT_srcX-BT_SIZE(A6)
		MOVE.L	D4,A3
	    ;------ adjust destination for clip rectangles
		ADD.W	lr_MinX(A3),D1
		SUB.W	lr_Scroll_X(A3),D1
		SWAP	D1
		ADD.W	lr_MinY(A3),D1
		SUB.W	lr_Scroll_Y(A3),D1
		SWAP	D1
		MOVE.L	D1,BT_dest-BT_SIZE(A6)
d815 7
a821 1
		MOVE.L	D2,BT_size-BT_SIZE(A6)
d823 2
a824 2
		LEA.L	lr_ClipRect(A3),A3	; get first ClipRect
		BRA.S	nextClipRect
a825 1

d827 2
a828 7
		MOVE.L	BT_source-BT_SIZE(A6),A4
		MOVE.W	BT_srcX-BT_SIZE(A6),D0
		MOVE.L	BT_dest-BT_SIZE(A6),D1
		MOVE.L	BT_size-BT_SIZE(A6),D2
		BSR	tClipCode
		TST	D7
		BNE.S	nextClipRect
d831 4
a834 5
		TST.L	cr_lobs(A3)	    ; check if using RastPort BitMap
		BNE.S	crBitMap	    ;	yes
		MOVE.L	BT_RP-BT_SIZE(A6),A1
		MOVE.L	rp_BitMap(A1),A2
		BRA.S	doCBlit
d836 8
a843 9
		MOVE.L	cr_BitMap(A3),D4
		BEQ	nextClipRect
		MOVE.L	D4,A2
		MOVE.W	cr_MinX(A3),D4	    ; adjust x for offscreen memory
		AND.W	#$0FFF0,D4	    ;	with origin @@ MinX
		SUB.W	D4,D1		    ;
		SWAP	D1
		SUB.W	cr_MinY(A3),D1	    ; adjust y for offscreen memory
		SWAP	D1		    ;	with origin @@ MinY
d846 7
a852 2
		BSR.S	tDoBlit

d854 3
a856 3
		MOVE.L	(A3),D4		    ;check for more clip regions
		MOVE.L	D4,A3
		BNE.S	clipRectLoop
d858 9
a866 14
	;------ check for super bit map
		MOVE.L	BT_CW-BT_SIZE(A6),A3
		MOVE.L	lr_SuperClipRect(A3),D4
		BEQ.S	btCEnd
		MOVE.L	lr_SuperBitMap(A3),A2
	    ;------ adjust destination for super clip rectangles
		MOVE.L	BT_dest-BT_SIZE(A6),D1
		SUB.W	lr_MinX(A3),D1
		ADD.W	lr_Scroll_X(A3),D1
		SWAP	D1
		SUB.W	lr_MinY(A3),D1
		ADD.W	lr_Scroll_Y(A3),D1
		SWAP	D1
		MOVE.L	D1,BT_dest-BT_SIZE(A6)
d868 1
a868 1
		MOVE.L	D4,A3
d871 2
a872 7
		MOVE.L	BT_source-BT_SIZE(A6),A4
		MOVE.W	BT_srcX-BT_SIZE(A6),D0
		MOVE.L	BT_dest-BT_SIZE(A6),D1
		MOVE.L	BT_size-BT_SIZE(A6),D2
		BSR	tClipCode
		TST	D7
		BNE.S	nextSuperClipRect
d874 10
a883 1
		BSR.S	tDoBlit
a884 5
nextSuperClipRect:
		MOVE.L	(A3),D4		    ;check for more clip regions
		MOVE.L	D4,A3
		BNE.S	vClipRectLoop

d887 2
a888 5
		MOVE.L	BT_RP-BT_SIZE(A6),A1
		MOVE.L	rp_Layer(A1),A5
		UNLK	A6
		CALLGFX	UnlockLayerRom
		BRA.S	btRts
d890 2
a891 2
btUnlk:
		UNLK	A6
d893 2
a894 2
		MOVEM.L (A7)+,D2-D7/A2-A5
		RTS
d897 28
a924 73
*------ tDoBlit ------------------------------------------------------
*
*	tDoBlit(srcX, destYX, sizeYX, rastPort, bitMap, source, BT_Vars);
*		D0    D1      D2      A1	A2	A4	A6
*
*---------------------------------------------------------------------
tDoBlit:
		MOVE.B	bm_Depth(A2),BT_COUNT-BT_SIZE(A6)
		MOVE.W	bm_BytesPerRow(A2),D7 ;get bytes per y
		LEA	bm_Planes(A2),A0
		MOVE.L	A0,BT_PLANES-BT_SIZE(A6)
		MOVEQ	#0,D3
		MOVE.W	D3,BT_PLANE-BT_SIZE(A6)
		MOVE.L	BT_RP-BT_SIZE(A6),A1
		MOVE.B	rp_Mask(A1),D3
		MOVE.W	D3,BT_WRITEMASK-BT_SIZE(A6)

		MOVE.B	#BFF_INITIALIZE,BT_FLAGS-BT_SIZE(A6)

*	;-- get word offsets into planes for bltPlane
		MOVE.W	D1,D4		;get x
		LSR.W	#4,D4		;get x word offset
		ADD.W	D4,D4		;  (byte offset)
		EXT.L	D4
		SWAP	D1		;get y
		MOVE.W	D1,D6		;save y
		SWAP	D1		;destination y, x in D1
		MULS	D7,D6		;get y byte offset
		MOVE.W	D7,BT_DXBytes-BT_SIZE(A6)
		ADD.L	D6,D4		;-- destination offset
		MOVE.L	D4,A5		;save as destination address

*	;-- finish bltPlane setup
		MOVEQ	#0,D3		    ; clear minterm
		MOVE.W	#BT_BP-BT_SIZE,D3   ; get offset of BP

		MOVE.L	D0,-(A7)
		BSR	bltPlane	; A2 not used bu BltTemplate!
		MOVE.L	(A7)+,D0

	;------ grab the blitter
		MOVE.L	A6,-(A7)
		MOVE.L	(A6),A6
		CALLGFX	OwnBlitter
	;------ perform the blit
btLoop:
		BSR	waitblitdone
		MOVE.L	(A7)+,A6
		MOVE.L	#_custom,A0
		LEA	-BT_SIZE(A6),A1
		BSR	tBlitCode
		MOVE.L	A6,-(A7)
		TST.B	BT_COUNT-BT_SIZE(A6)
		MOVE.L	(A6),A6
		BNE.S	btLoop
	;------ disown the blitter
		CALLGFX DisownBlitter
		MOVE.L	(A7)+,A6
		RTS


*------ tClipCode ----------------------------------------------------
*
*	tClipCode(srcX, destYX, sizeYX, clipRect, source, BT_Vars);
*		  D0	D1	D2	A3	  A4	  A6
*   RETURNS
*	D0	srcX
*	D1	destXY
*	D2	sizeXY
*	D7	non-zero if all clipped
*	A4	adjusted source
*
*---------------------------------------------------------------------
d926 8
a933 10
		MOVEQ	#0,D7		; guess it will be drawn 

		CMP.W	cr_MinX(A3),D1
		BGE.S	xMinOK
*	    ;-- clip X to low edge
		SUB.W	D1,D0		;start fixup for srcX
		ADD.W	D1,D2		;  and sizeX
		MOVE.W	cr_MinX(A3),D1
		ADD.W	D1,D0		;complete fixup for srcX
		SUB.W	D1,D2		;  and sizeX
d935 8
a942 8
		MOVE.W	D2,D4
		ADD.W	D1,D4
		SUBQ.W	#1,D4
		CMP.W	cr_MaxX(A3),D4
		BLE.S	xMaxOK
*	    ;-- clip X to max edge
		SUB.W	D4,D2
		ADD.W	cr_MaxX(A3),D2
d944 2
a945 9
		TST.W	D2		;check for non-zero positive size
		BGT.S	yCheck
		MOVEQ	#-1,D7		;  show no width
		BRA.S	tccRts
yCheck:
		SWAP	D0
		CLR.W	D0	;start out with zero srcY
		SWAP	D1
		SWAP	D2
d947 9
a955 11
		CMP.W	cr_MinY(A3),D1
		BGE.S	yMinOK
*	    ;-- clip Y to low edge
		SUB.W	D1,D0		;start fixup for srcY
		ADD.W	D1,D2		;  and sizeY
		MOVE.W	cr_MinY(A3),D1
		ADD.W	D1,D0		;complete fixup for srcY
		SUB.W	D1,D2		;  and sizeY
		BPL.S	yMinOK
		MOVEQ	#-1,D7		;  show no width
		BRA.S	tccRts
d957 8
a964 8
		MOVE.W	D2,D4
		ADD.W	D1,D4
		SUBQ.W	#1,D4
		CMP.W	cr_MaxY(A3),D4
		BLT.S	yMaxOK
*	    ;-- clip Y to max edge
		SUB.W	D4,D2
		ADD.W	cr_MaxY(A3),D2
d966 4
a969 22
		TST.W	D2		;check for non-zero positive size
		BGT.S	yMover
		MOVEQ	#-1,D7		;  show no width
		BRA.S	tccRts
yMover:
*	;-- take care of non-zero y correction
		MOVE.W	D0,D4
		BEQ.S	xySwap
		MULS	BT_SXBytes-BT_SIZE(A6),D4
		ADD.L	D4,A4	    ;get new source word
		CLR.W	D0
xySwap:
		SWAP	D0
		SWAP	D1
		SWAP	D2
*	;-- take care of non-zero x correction
		MOVE.W	D0,D4
		ASR.W	#4,D4
		ADD.W	D4,D4	    ;address of delta x word
		BEQ.S	tccRts
		ADD.W	D4,A4	    ;get new source word
		AND.W	#$0F,D0	    ;get new srcX
d971 3
a973 2
tccRts:
		RTS
d976 80
a1055 43
*------ tBlitCode ----------------------------------------------------
*
*	completion = tBlitCode(chips, node);
*	zero-condition-code    A0     A1
*
*---------------------------------------------------------------------
tBlitCode:
		MOVE.L	A2,-(A7)
		BCLR	#BFB_INITIALIZE,BT_FLAGS(A1)
		BEQ.S	bCContinued
*	    ;-- initialize this blit sequence invariant registers
		MOVE.W	#$0FFFF,bltadat(A0)
*		changed by dale
		MOVE.l	BT_BP+BP_FWMASK(A1),bltafwm(A0)
*		MOVE.W	BT_BP+BP_LWMASK(A1),bltalwm(A0)	   * unneeded
		MOVE.W	BT_BP+BP_CON1(A1),bltcon1(A0)
		MOVE.W	BT_BP+BP_SMOD(A1),bltbmod(A0)
		MOVE.W	BT_BP+BP_DMOD(A1),D0
		MOVE.W	D0,bltcmod(A0)
		MOVE.W	D0,bltdmod(A0)
bCContinued:
*	    ;-- get the minterm
		MOVE.L	BT_RP(A1),A2		 ; get the raster port
		MOVE.W	BT_PLANE(A1),D0
		MOVE.B	rp_minterms(A2,D0.W),D0
		OR.W	#SRCB+SRCC+DEST,D0
*	    ;-- get the plane pointer
		MOVE.L	BT_PLANES(A1),A2
		MOVE.L	(A2),A2
		ADDQ.L	#4,BT_PLANES(A1)
*	    ;-- check the write mask for this plane
		LSR.W	BT_WRITEMASK(A1)
		BCC.S	bCNext
*	    ;-- set the minterm
		OR.W	BT_BP+BP_CON0(A1),D0
		MOVE.W	D0,bltcon0(A0)
*	    ;-- set up the data pointers
		MOVE.L	BT_BP+BP_SOURCE(A1),bltbpt(A0)
		ADD.L	BT_BP+BP_DEST(A1),A2
		MOVE.L	A2,bltcpt(A0)
		MOVE.L	A2,bltdpt(A0)
*	    ;-- fire up the blit
		MOVE.W	BT_BP+BP_BSIZE(A1),bltsize(A0)
d1057 2
a1058 5
*	    ;-- decrement and set CC to non-zero if blit still pending
		ADDQ.W	#1,BT_PLANE(A1)
		SUBQ.B	#1,BT_COUNT(A1)
		MOVE.L	(A7)+,A2
		RTS
d1060 2
a1061 7
bCNext:
*	    ;-- decrement and set CC to non-zero if blit still pending
		ADDQ.W	#1,BT_PLANE(A1)
		SUBQ.B	#1,BT_COUNT(A1)
		BNE.S	bCContinued
		MOVE.L	(A7)+,A2
		RTS
d1063 1
a1063 1
		END
@
