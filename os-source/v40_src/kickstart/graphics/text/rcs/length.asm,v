head     39.4;
branch   ;
access   ;
symbols  rel39_24:39.4 rel39_18:39.4 rel39_97:39.3 rel39_90:39.3 rel39_89:39.3 rel39_82:39.2 rel39_76:39.2 rel39_71:39.2 rel39_65:39.2 rel39_64:39.2 rel39_61:39.2 rel39_60:39.2 rel39_55:39.2 rel39_47:39.1 rel39_39:39.0 rel39_38:39.0 rel39_37:39.0 rel39_35:39.0 rel39_34:39.0 V37_30:37.2 V37_29:37.2 V37_28:37.2 V37_25:37.2 V37_22:37.2 V37_21:37.2 V37_20:37.2 V37_19:37.2 V37_17:37.2 V37_15:37.2 V37_14:37.2 V37_13:37.1 V37_12:37.1 V37_11:37.1 V37_10:37.0 V37_9:37.0 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.24 V36_208:36.24 V36_207:36.24 V36_205:36.23 V36_203:36.21 V36_202:36.21 V36_201:36.21 V36_200:36.21 V36_199:36.21 V36_198:36.21 V36_196:36.21 V36_195:36.21 V36_194:36.21 V36_193:36.21 V36_192:36.21 V36_191:36.20 V36_190:36.20 V36_189:36.19 V36_188:36.19 V36_187:36.19 V36_186:36.19 V36_185:36.19 V36_184:36.19 V36_183:36.19 V36_182:36.19 V36_181:36.19;
locks    chrisg:39.4; strict;
comment  @*   @;


39.4
date     92.12.11.10.25.42;  author chrisg;  state Exp;
branches ;
next     39.3;

39.3
date     92.09.03.15.39.06;  author spence;  state Exp;
branches ;
next     39.2;

39.2
date     92.04.08.11.16.37;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     92.04.03.16.19.09;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.36.16;  author chrisg;  state Exp;
branches ;
next     37.2;

37.2
date     91.02.12.15.52.25;  author spence;  state Exp;
branches ;
next     37.1;

37.1
date     91.02.04.19.37.11;  author spence;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.29.07;  author spence;  state Exp;
branches ;
next     36.24;

36.24
date     90.12.13.19.45.29;  author spence;  state Exp;
branches ;
next     36.23;

36.23
date     90.12.12.11.47.42;  author bart;  state Exp;
branches ;
next     36.22;

36.22
date     90.12.11.17.27.08;  author bart;  state Exp;
branches ;
next     36.21;

36.21
date     90.10.12.15.08.55;  author spence;  state Exp;
branches ;
next     36.20;

36.20
date     90.10.10.16.16.17;  author spence;  state Exp;
branches ;
next     36.19;

36.19
date     90.05.17.09.16.42;  author kodiak;  state Exp;
branches ;
next     36.18;

36.18
date     90.05.05.16.45.14;  author kodiak;  state Exp;
branches ;
next     36.17;

36.17
date     90.04.13.11.52.31;  author kodiak;  state Exp;
branches ;
next     36.16;

36.16
date     90.04.02.12.59.40;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     90.03.08.15.02.25;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     90.01.23.16.56.29;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     89.11.22.18.04.10;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     89.11.14.12.35.35;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     89.06.05.14.15.58;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     89.05.05.11.24.44;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     88.09.01.15.12.25;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     88.07.15.17.23.06;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     88.07.15.16.23.59;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     88.06.16.13.18.22;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     88.06.13.15.29.37;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     88.04.15.12.27.40;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     88.04.15.11.49.31;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     88.04.13.13.27.25;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     88.04.08.17.38.03;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     88.03.06.11.01.11;  author kodiak;  state Exp;
branches ;
next     35.4;

35.4
date     88.01.08.14.40.19;  author kodiak;  state Exp;
branches ;
next     35.3;

35.3
date     88.01.08.13.45.53;  author kodiak;  state Exp;
branches ;
next     35.2;

35.2
date     88.01.08.13.38.31;  author kodiak;  state Exp;
branches ;
next     35.1;

35.1
date     87.11.11.14.42.52;  author kodiak;  state Exp;
branches ;
next     35.0;

35.0
date     87.10.19.16.20.03;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


39.4
log
@fixe dy clip bug.
@
text
@**
**	$Id: length.asm,v 39.3 92/09/03 15:39:06 spence Exp Locker: chrisg $
**
**      output length of text string
**
**      (C) Copyright 1989 Commodore-Amiga, Inc.
**          All Rights Reserved
**

	SECTION		graphics

*------ Included Files -----------------------------------------------

	INCLUDE		"exec/types.i"
	INCLUDE		"exec/nodes.i"
	INCLUDE		"exec/lists.i"
	INCLUDE		"exec/ports.i"

	INCLUDE		"graphics/rastport.i"

	INCLUDE		"text.i"

	INCLUDE		"txtdata.i"


*------ Exported Names -----------------------------------------------

*------ Functions ----------------------------------------------------

	XDEF		_TextFit
	XDEF		_TextLength
	XDEF		_TextExtent

	XDEF		textLength


******* graphics.library/TextLength **********************************
*
*   NAME
*	TextLength -- Determine raster length of text data.
*
*   SYNOPSIS
*	length = TextLength(rp, string, count)
*	D0                  A1  A0      D0:16
*
*	WORD TextLength(struct RastPort *, STRPTR, WORD);
*
*   FUNCTION
*	This graphics function determines the length that text data
*	would occupy if output to the specified RastPort with the
*	current attributes.  The length is specified as the number of
*	raster dots: to determine what the current position would be
*	after a Write() using this string, add the length to cp_x
*	(cp_y is unchanged by Write()).  Use the newer TextExtent() to
*	get more information.
*
*   INPUTS
*	rp     - a pointer to the RastPort which describes where the
*	         text attributes reside.
*	string - the address of string to determine the length of
*	count  - the string length.  If zero, there are no characters
*	         in the string.
*
*   RESULTS
*	length - the number of pixels in x this text would occupy, not
*	         including any negative kerning that may take place at
*	         the beginning of the text string, nor taking into
*	         account the effects of any clipping that may take
*	         place.
*
*   NOTES
*	Prior to V36, the result length occupied only the low word of
*	d0 and was not sign extended into the high word.
*
*   BUGS
*	A length that would overflow single word arithmetic is not
*	calculated correctly.
*
*   SEE ALSO
*	TextExtent()  Text()  TextFit()
*	graphics/text.h  graphics/rastport.h
*
**********************************************************************
******* graphics.library/TextExtent **********************************
*
*   NAME
*	TextExtent -- Determine raster extent of text data. (V36)
*
*   SYNOPSIS
*	TextExtent(rp, string, count, textExtent)
*	           A1  A0      D0:16  A2
*
*	void textExtent(struct RastPort *, STRPTR, WORD,
*	     struct TextExtent *);
*
*   FUNCTION
*	This function determines a more complete metric of the space
*	that a text string would render into than the TextLength()
*	function.
*
*   INPUTS
*	rp     - a pointer to the RastPort which describes where the
*	         text attributes reside.
*	string - the address of the string to determine the length of.
*	count  - the number of characters in the string.
*                If zero, there are no characters in the string.
*	textExtent - a structure to hold the result.
*
*   RESULTS
*	textExtent is filled in as follows:
*	    te_Width  - same as TextLength() result: the rp_cp_x
*	                advance that rendering this text would cause.
*	    te_Height - same as tf_YSize.  The height of the
*	                font.
*	    te_Extent.MinX - the offset to the left side of the
*	                rectangle this would render into.  Often zero.
*	    te_Extent.MinY - same as -tf_Baseline.  The offset
*	                from the baseline to the top of the rectangle
*	                this would render into.
*	    te_Extent.MaxX - the offset of the left side of the
*	                rectangle this would render into.  Often the
*	                same as te_Width-1.
*	    te_Extent.MaxY - same as tf_YSize-tf_Baseline-1.
*	                The offset from the baseline to the bottom of
*	                the rectangle this would render into.
*
*   SEE ALSO
*	TextLength()  Text()  TextFit()
*	graphics/text.h  graphics/rastport.h
*
**********************************************************************
;   supported characters
;
;   Full Forward, any spacing
;
;		0---------L
;	      K?K?K-----B?B?B
;	    F?F?F?F?F?F?F?F?F?F
;
;   Full Reverse, any spacing
;
;		L---------0
;	      K?K?K-----B?B?B
;	    F?F?F?F?F?F?F?F?F?F
;
;   Kernless Forward, no reversing spacing
;		0---------L
;		+-------B?B
;		F?F?F?F?F?F?F
;   
_TextLength:
		ext.l	d0
		beq.s	tlEmpty
		movem.l d2-d6/a2-a5,-(a7)
		bsr.s	textLength
		movem.l	(a7)+,d2-d6/a2-a5
		ext.l	d0
tlEmpty:
		rts
	    
_TextExtent:
		tst.w	d0
		beq.s	zeroExtent
		movem.l d2-d6/a2-a5,-(a7)
		bsr.s	textLength
		move.w	d0,te_Width(a2)
		subq.w	#1,d1
		move.w	d1,te_Extent+ra_MaxX(a2)
		move.w	d2,te_Extent+ra_MinX(a2)
		bsr.s	yExtent
		movem.l	(a7)+,d2-d6/a2-a5
		rts

yExtent:
		move.w	tf_YSize(a1),d0
		move.w	d0,te_Height(a2)
		move.w	tf_Baseline(a1),d1
		neg.w	d1
		move.w	d1,te_Extent+ra_MinY(a2)
		add.w	d0,d1
		subq.w	#1,d1
		move.w	d1,te_Extent+ra_MaxY(a2)
		rts

zeroExtent:
		moveq	#-1,d0
		move.l	d0,te_Extent+ra_MaxX(a2)
		moveq	#0,d0
		move.l	d0,te_Width(a2)
		move.l	d0,te_Extent+ra_MinX(a2)
		rts			; must return d0 = 0 for TextFit call


;------ textLength ---------------------------------------------------
;	length, max, min = textLength(strLen, string, rastPort)
;	d0      d1   d2               d0      a0      a1
;
;	write.asm reference allows to destroy d0-d7/a0-a5
;
;	d3	decrementing strLen
;	d4	rp_AlgoStyle, rp_TxSpacing
;	d5	char index
;	d6	temp
;	a1	rastPort, then textFont
;	a3	textFontExtension, then tf_CharSpace
;	a4	tf_CharKern
;	a5	tf_CharLoc
;
;---------------------------------------------------------------------
;
;	spacing that reverses text is only completely supported for
;	kernless characters -- other cases will risk unrendered
;	background seams in JAM2 mode.
;
textLength:
	    ;-- up front initialization
		move.b	rp_AlgoStyle(a1),d4
		swap	d4
		move.w	rp_TxSpacing(a1),d4
		move.l	rp_Font(a1),a1
		move.l	tf_Extension(a1),a3
		bne.s	tlSpacingExists	; rp_TxSpacing

		btst	#TE0B_BYTECELL,tfe_Flags0(a3)
		bne.s	tlByteCase

tlSpacingExists:
		btst	#TE0B_KERNLESS,tfe_Flags0(a3)
		bne.s	tlFixedCase

	    ;-- full kern/space case
		;-- initialize max/min
		move.w	d0,d3		; strLen for decrementing
		moveq	#0,d0		; zero length
		moveq	#0,d1		; always include CP in bits
		moveq	#0,d2		;

		move.l	tf_CharSpace(a1),a3
		move.l	tf_CharKern(a1),a4
		move.l	tf_CharLoc(a1),a5
		bra.s	tlBothDBF


		;-- kern & space loop
tlBothLoop:
		clr.w	d5
		move.b	(a0)+,d5
		;--	get character bounder
		cmp.w	#$20ff,tf_LoChar(a1)
		beq.s	tlbStdBound

		cmp.b	tf_HiChar(a1),d5
		bhi.s	tlbBadChar
		sub.b	tf_LoChar(a1),d5
		bcc.s	tlbGotChar

tlbBadChar:
		move.b	tf_HiChar(a1),d5
		sub.b	tf_LoChar(a1),d5
		addq.w	#1,d5
		bra.s	tlbGotChar

tlbStdBound
		sub.b	#$20,d5
		bcs.s	tlbBadChar

tlbGotChar:
		add.w	d5,d5
		add.w	0(a4,d5.w),d0	; CP + Kern
		cmp.w	d0,d2		; min
		ble.s	tlbAddSpace
		move.w	d0,d2
tlbAddSpace:
		move.w	d0,d6		; save kern for bit size later
		add.w	0(a3,d5.w),d0	; CP + Space
		add.w	d4,d0		; CP + Spacing

		add.w	d5,d5
		add.w	2(a5,d5.w),d6	; Loc bit size
		cmp.w	d6,d1		; max
		bge.s	tlbCPBound
		move.w	d6,d1

		;-- bound to CP
tlbCPBound:
		cmp.w	d0,d1		; max
		bge.s	tlbCPBMin
		move.w	d0,d1
		bra.s	tlBothDBF
tlbCPBMin
		cmp.w	d0,d2		; min
		ble.s	tlBothDBF
		move.w	d0,d2

tlBothDBF:
		dbf	d3,tlBothLoop
		bra.s	tlAlgoStyleAdj


	    ;-- byte case
tlByteCase:
		lsl.w	#3,d0
		move.w	d0,d1
		moveq	#0,d2
		bra.s	tlAlgoStyleAdj


	    ;-- fixed width case
tlFixedCase:
		moveq	#0,d2			; min is zero
		move.w	tf_XSize(a1),d3
		add.w	d4,d3
		bmi.s	tlIllegalReverse
		mulu	d3,d0			; get CP advance
		move.w	d0,d1			; clone in max
		tst.w	d4			; check for CP < max
		bpl.s	tlAlgoStyleAdj
		sub.w	d4,d1			; max is more than CP advance

tlAlgoStyleAdj:
		btst	#FSB_BOLD+16,d4
		beq.s	tlaChkItalic
		add.w	tf_BoldSmear(a1),d1
tlaChkItalic:
		btst	#FSB_ITALIC+16,d4
		beq.s	tlDone
		move.w	tf_Baseline(a1),d5
		move.w	tf_YSize(a1),d6
		sub.w	d5,d6
		addq.w	#1,d6
		lsr.w	#1,d5
		lsr.w	#1,d6
		add.w	d5,d1
		sub.w	d6,d2
tlDone:
		rts


tlIllegalReverse:
		moveq	#0,d0
		moveq	#0,d1
		bra.s	tlDone


******* graphics.library/TextFit *************************************
*
*   NAME
*	TextFit - count characters that will fit in a given extent (V36)
*
*   SYNOPSIS
*	chars = TextFit(rastport, string, strLen, textExtent,
*	D0              A1        A0      D0      A2
*	        constrainingExtent, strDirection,
*	        A3                  D1
*	        constrainingBitWidth, constrainingBitHeight)
*	        D2                    D3
*
*	ULONG TextFit(struct RastPort *, STRPTR, UWORD,
*	    struct TextExtent *, struct TextExtent *, WORD, UWORD, UWORD);
*
*   FUNCTION
*	This function determines how many of the characters of the
*	provided string will fit into the space described by the
*	constraining parameters.  It also returns the extent of
*	that number of characters.
*
*   INPUTS
*	rp     - a pointer to the RastPort which describes where the
*	         text attributes reside.
*	string - the address of string to determine the constraint of
*	strLen - The number of characters in the string.
*	         If zero, there are no characters in the string.
*	textExtent - a structure to hold the extent result.
*	constrainingExtent - the extent that the text must fit in.
*	    This can be NULL, indicating only the constrainingBit
*	    dimensions will describe the constraint.
*	strDirection - the offset to add to the string pointer to
*	    get to the next character in the string.  Usually 1.
*	    Set to -1 and the string to the end of the string to
*	    perform a TextFit() anchored at the end.  No other value
*	    is valid.
*	constrainingBitWidth - an alternative way to specify the
*	    rendering box constraint width that is independent of
*	    the rendering origin.  Range 0..32767.
*	constrainingBitHeight - an alternative way to specify the
*	    rendering box constraint height that is independent of
*	    the rendering origin.  Range 0..32767.
*
*   RESULTS
*	chars - the number of characters from the origin of the
*	        given string that will fit in both the constraining
*	        extent (which specifies a CP bound and a rendering
*	        box relative to the origin) and in the rendering width
*	        and height specified.
*
*   NOTES
*	The result is zero chars and an empty textExtent when the fit
*	cannot be performed.  This occurs not only when no text will
*	fit in the provided constraints, but also when:
*	-   the RastPort rp's rp_TxSpacing sign and magnitude is so
*	    great it reverses the path of the text. 
*	-   the constrainingExtent does not include x = 0.
*
*
*   BUGS
*	Under V37, TextFit() would return one too few characters if the
*	font was proportional. This can be worked around by passing
*	(constrainingBitWidth + 1) for proportional fonts. This is fixed
*	for V39.
*
*   SEE ALSO
*	TextExtent()  TextLength()  Text()
*	graphics/text.h  graphics/rastport.h
*
**********************************************************************
tfZeroExtent:
		add.w	#te_SIZEOF+8,a7
		movem.l	(a7)+,d2-d7/a3-a6
		bsr	zeroExtent		; sets d0 = 0
		rts

_TextFit:
	    ;-- save registers
		movem.l d2-d7/a3-a6,-(a7)

		clr.l	-(a7)			; store for bounding width &
		clr.l	-(a7)			;   last chars CP/max/min

		;-- build default constraining extent
		move.l	#$7fff7fff,-(a7)	; te_Extent.Max
		move.l	#$80008000,-(a7)	; te_Extent.Min
		move.l	#$7fff7fff,-(a7)	; te_Width & te_Height
		btst.b	#FPB_REVPATH,rp_TxFlags(a1)
		beq.s	tfPWidth
		not.w	2(a7)			; te_Width -> $8000
tfPWidth:
		move.l	a7,a6
	    
		;-- check zero string length
		tst.w	d0
		beq.s	tfZeroExtent

		;-- check early reason to allow no characters
		;--	check constrainingBitHeight
		move.w	rp_TxHeight(a1),d7
		cmp.w	d7,d3
		blt.s	tfZeroExtent

	    ;-- get constraining extent
		move.l	a3,d6
		beq.s	tfCheckX

		;-- copy specified constraining extent
		move.l	(a3)+,(a6)
		move.l	(a3)+,4(a6)
		move.l	(a3)+,8(a6)

		;-- check more early reasons to allow no characters
		;--	check constrainingExtent MaxY
		move.w	rp_TxBaseline(a1),d6
		neg.w	d6			; d6=-baseline
		cmp.w	te_Extent+ra_MinY(a6),d6
		blt.s	tfZeroExtent		; is -baseline < miny?
		;--	check constrainingExtent MinY
		add.w	d7,d6			; d6=height-base
		subq.w	#1,d6			; height-base-1
		cmp.w	te_Extent+ra_MaxY(a6),d6
		bgt.s	tfZeroExtent		; abort if h-base-1 > maxy

;
;	d0	strLen
;	d1	string direction
;	d2	bounding bit size
;	d4	rp_AlgoStyle / rp_TxSpacing
;	d7	temp
;	a0	string
;	a1	rastPort, then textFont
;	a6	constraining te_Extent adjusted for algorithmic style
;
tfCheckX:
	    ;-- up front initialization
		move.b	rp_AlgoStyle(a1),d4
		swap	d4
		move.w	rp_TxSpacing(a1),d4

		move.l	rp_Font(a1),a1

		;-- trim constraints for algorithmic elbow room
		btst	#FSB_BOLD+16,d4
		beq.s	tfConstrainItalic

		move.w	tf_BoldSmear(a1),d7
		sub.w	d7,d2
		sub.w	d7,te_Extent+ra_MaxX(a6)

tfConstrainItalic:
		btst	#FSB_ITALIC+16,d4
		beq.s	tfEnsureX00

		move.w	tf_Baseline(a1),d5
		move.w	tf_YSize(a1),d6
		sub.w	d5,d6
		addq.w	#1,d6
		lsr.w	#1,d5
		lsr.w	#1,d6
		sub.w	d5,te_Extent+ra_MaxX(a6)
		sub.w	d5,d2
		add.w	d6,te_Extent+ra_MinX(a6)
		sub.w	d6,d2

tfEnsureX00:
		;--	check constrainingExtent MaxX
		tst.w	te_Extent+ra_MaxX(a6)
		blt	tfZeroExtent
		;--	check constrainingExtent MinX
		tst.w	te_Extent+ra_MinX(a6)
		bgt	tfZeroExtent

		move.l	tf_Extension(a1),a4
		btst	#TE0B_KERNLESS,tfe_Flags0(a4)
		bne	tfFixedCase

;
;	d0	cumulative length
;	d1	sign of string direction / working max
;	d2	working min
;	d3	decrementing strLen
;	d4	rp_AlgoStyle / rp_TxSpacing
;	d5	char index
;	d6	temp
;	d7	original strLen / temp
;	a0	string
;	a1	rastPort, then textFont
;	a3	tf_CharSpace
;	a4	tf_CharKern
;	a5	tf_CharLoc
;	a6	constraining te_Extent adjusted for algorithmic style,
;		store for last character's CP/max/min
;
		move.w	d0,d7		; original strLen
		swap	d7		;   in high word
		move.l	tf_CharSpace(a1),a3
		move.l	tf_CharKern(a1),a4
		move.l	tf_CharLoc(a1),a5
		move.w	d0,d3
		ext.l	d1		; move direction into sign bit
		move.w	d2,te_SIZEOF(a6) ; bounding bit width
		moveq	#0,d0		; working CP = 0;
		clr.w	d1		; working max = 0
		moveq	#0,d2		; working min = 0
		moveq	#-1,d5		; initialize to illegal value

		bra	tfBothDBF

		;-- kern & space loop
tfBothLoop:
		clr.w	d5
		move.b	(a0),d5
		cmp.w	#$20ff,tf_LoChar(a1)
		beq.s	tfbStdBound

		cmp.b	tf_HiChar(a1),d5
		bhi.s	tfbBadChar
		sub.b	tf_LoChar(a1),d5
		bcc.s	tfbGotChar

tfbBadChar:
		move.b	tf_HiChar(a1),d5
		sub.b	tf_LoChar(a1),d5
		addq.w	#1,d5
		bra.s	tfbGotChar

tfbStdBound:
		sub.b	#$20,d5
		bcs.s	tfbBadChar

tfbGotChar:
		add.w	d5,d5
		;-- get new CP
		move.w	0(a4,d5.w),d7	; Kern
		add.w	0(a3,d5.w),d7	; + Space
		add.w	d4,d7		; + Spacing
		add.w	d0,d7
		move.w	te_Width(a6),d6	; check new width
		bpl.s	tfbPosWidth

		;--	check negative width constraint
		tst.w	d7
		bpl.s	tfbCheckDirection
		cmp.w	d6,d7
		bge.s	tfbCheckDirection
		bra.s	tfExhausted

tfbPosWidth:
		;--	check positive width constraint
		tst.w	d7
		bmi.s	tfbCheckDirection
		cmp.w	d6,d7
		bgt.s	tfExhausted

		;-- check string direction
tfbCheckDirection:
		tst.l	d1
		bmi	tfbRightFit

		;-- left fit
		addq.w	#1,a0
		add.w	0(a4,d5.w),d0	; CP + Kern

tfCheckBitMin:
		cmp.w	d0,d2		; min
		ble.s	tfbCheckBitMax
		cmp.w	te_Extent+ra_MinX(a6),d0 ; out of bounds?
		blt.s	tfExhausted
		move.w	d0,d2
tfbCheckBitMax:
		add.w	d5,d5		; double d5 temporarily
		add.w	2(a5,d5.w),d0	; Loc bit size
		lsr.w	#1,d5		; restore d5

		cmp.w	d0,d1		; max
		bge.s	tfbSetCP
		cmp.w	te_Extent+ra_MaxX(a6),d0 ; out of bounds?
		bgt.s	tfExhausted
		move.w	d0,d1

tfbSetCP:
		move.w	d7,d0

		;-- include CP in bound
tfbCheckCP:
		cmp.w	d0,d2		; min
		ble.s	tfbChkWMax
		cmp.w	te_Extent+ra_MinX(a6),d0 ; out of bounds?
		blt.s	tfExhausted
		move.w	d0,d2
tfbChkWMax:
		cmp.w	d0,d1		; max
		bge.s	tfbChkBWidth
		cmp.w	te_Extent+ra_MaxX(a6),d0 ; out of bounds?
		bgt.s	tfExhausted
		move.w	d0,d1

		;--	check constrainingBitWidth
tfbChkBWidth:
		move.w	d1,d7		; working max
		sub.w	d2,d7		; max - min
		cmp.w	te_SIZEOF(a6),d7 ;   out of bounds?
*		bge.s	tfExhausted	; make inclusive
		bgt.s	tfExhausted

tfbCacheLast:
		movem.w	d0/d1/d2,te_SIZEOF+2(a6) ; save working to last char's
tfBothDBF:
		swap	d5
		dbf	d3,tfBothLoop


	    ;-- proportional wrapup
tfExhausted:
		swap	d7		; recover original strLen
		sub.w	d3,d7		; find what was used up
		subq.w	#1,d7		; this is the chars result
		tst.l	d1
		bmi.s	1$
		movem.w	te_SIZEOF+2(a6),d0/d1/d2 ; get CP, max, and min
2$		bsr	tlAlgoStyleAdj
		bra	tfResult

* direction is right to left. Handle special cases:

1$		movem.w	te_SIZEOF+2(a6),d0/d1/d2 ; get CP, max, and min
		tst.l	d5
		bmi.s	2$		; no previous character
		swap	d5		; get the previous character (which will have fit)
		move.w	0(a4,d5.w),d3	; final Kern
*		bmi.s	2$		; check for positive sign
		bmi.s	3$
		sub.w	d3,d2		; min - final Kern if positive
*		bra.s	2$

* have to check for -ve space in the font definition. 
* - spence Dec 12 1990

3$		move.w	0(a3,d5.w),d3	; previous space
		bpl.s	2$
*		add.w	d3,d2
		clr.w	d2		; BLEUCHHH! (but it makes Peter happy)
		bra.s	2$

		;-- right fit
tfbRightFit:
		subq.w	#1,a0
		sub.w	d0,d7		; recover CP increment
		add.w	d7,d1		; adjust max/min
		add.w	d7,d2

		;--	check adjusted max against constraining bit size

		cmp.w	te_SIZEOF(a6),d1 ;   out of bounds?
		bge.s	tfExhausted	; make inclusive

		;--	check adjusted max/min
		cmp.w	te_Extent+ra_MaxX(a6),d1
		bgt.s	tfExhausted
		cmp.w	te_Extent+ra_MinX(a6),d2
		blt.s	tfExhausted

		add.w	d0,d7		; recover next CP
		move.w	0(a4,d5.w),d0	; Kern
		bra	tfCheckBitMin


;
;	d0	strLen, then length
;	d1	, then max
;	d2	bounding bit size, then min
;	d4	rp_AlgoStyle / rp_TxSpacing
;	d5	fit count
;	d6	tf_XSize
;	d7	temp, then fitLen
;	a1	textFont
;	a2	result te_Extent
;	a6	constraining te_Extent adjusted for algorithmic style
;
	    ;-- fixed width case
tfFixedCase:
		moveq	#0,d5
		move.w	tf_XSize(a1),d7
		add.w	d4,d7		; add rp_TxSpacing
		blt	tfZeroExtent
		beq.s	tffHaveD5

		;--	get CP advance contribution
		move.w	te_Width(a6),d5
		bmi.s	tffHaveD5
		divu	d7,d5
		beq	tfZeroExtent

		;--	get bit contribution
tffHaveD5:
		moveq	#0,d1
		move.w	te_Extent+ra_MaxX(a6),d1
		cmp.w	d2,d1
		ble.s	tffBitSrc
		move.w	d2,d1
tffBitSrc:
		tst.w	d7
		beq.s	tffZeroAdvance
		tst.w	d4
		bpl.s	tffBitDest
		add.w	d4,d1		; without contribution of last spacing
tffBitDest:

		divu	d7,d1

		tst.w	d5
		beq.s	tffMinD0D1
		cmp.w	d1,d5
		bgt.s	tffMinD0D1
		move.w	d5,d1
tffMinD0D1:
		cmp.w	d0,d1
		bgt.s	tffD0
		move.w	d1,d0

tffD0:
		move.w	d0,d7
		bsr	tlFixedCase

tfResult:
		move.w	d0,te_Width(a2)
		subq.w	#1,d1
		move.w	d1,te_Extent+ra_MaxX(a2)
		move.w	d2,te_Extent+ra_MinX(a2)
		bsr	yExtent
		moveq	#0,d0
		move.w	d7,d0
		add.w	#te_SIZEOF+8,a7
		movem.l	(a7)+,d2-d7/a3-a6
		rts


tffZeroAdvance:
		add.w	d4,d1		; see if room for bits
		bge.s	tffD0		; yes: enough room for all characters
		bra	tfZeroExtent


	END
@


39.3
log
@Autodoc spelling corrections
@
text
@d2 1
a2 1
**	$Id: length.asm,v 39.2 92/04/08 11:16:37 spence Exp Locker: spence $
d461 6
d468 1
a468 7
		bgt.s	tfZeroExtent
		;--	check constrainingExtent MinY
		sub.w	d7,d6
		addq.w	#1,d6
		cmp.w	te_Extent+ra_MinY(a6),d6
		blt.s	tfZeroExtent

@


39.2
log
@Documented the V37 TextFit() bug in the autodocs
@
text
@d2 1
a2 1
**	$Id: length.asm,v 39.1 92/04/03 16:19:09 spence Exp Locker: spence $
d76 1
a76 1
*	A length that would overflow single word arithmatic is not
d125 1
a125 1
*	                the rectanangle this would render into.
@


39.1
log
@In TextFit(), changed bge.s -> bgt.s when checking width
for bug B14223
@
text
@d2 1
a2 1
**	$Id: length.asm,v 39.0 91/08/21 17:36:16 chrisg Exp Locker: spence $
d403 7
@


39.0
log
@Bumped
@
text
@d2 1
a2 1
**	$Id: length.asm,v 37.2 91/02/12 15:52:25 spence Exp Locker: chrisg $
d642 2
a643 2
		bge.s	tfExhausted	; make inclusive
*		bgt.s	tfExhausted
a675 2
* Q. Why a -ve space? 
* A. DFYPs!
d681 1
a681 1
		clr.w	d2				; BLEUCHHH! (but it makes Peter happy)
@


37.2
log
@autodoc
@
text
@d2 1
a2 1
**	$Id: length.asm,v 37.1 91/02/04 19:37:11 spence Exp Locker: spence $
@


37.1
log
@AutoDocs
@
text
@d2 1
a2 1
**	$Id: length.asm,v 37.0 91/01/07 15:29:07 spence Exp Locker: spence $
d44 1
a44 1
*	d0                  a1  a0      d0:16
d46 1
a46 1
*	WORD TextLength( struct RastPort *, STRPTR, WORD );
d49 2
a50 2
*	This graphics function determines the length that text data 
*	would occupy if output to the specified RastPort with the 
d53 2
a54 2
*	after a Write using this string, add the length to cp_x
*	(cp_y is unchanged by Write).  Use the newer TextExtent to
d58 2
a59 2
*	rp - a pointer to the RastPort which describes where the
*	    text attributes reside.
d61 2
a62 2
*	count - the string length.  If zero, there are no characters
*	    in the string.
d65 5
a69 5
*	length - the number of pixels in x this text would occupy, not 
*	    including any negative kerning that may take place at
*	    the beginning of the text string, nor taking into
*	    account the effects of any clipping that may take
*	    place.
d76 1
a76 1
*	A length that would overflow single word arithmatic is not 
d80 2
a81 1
*	TextExtent Text TextFit graphics/text.h graphics/rastport.h
d91 1
a91 1
*	           a1  a0      d0:16  a2
d93 2
a94 2
*	VOID TextExtent( struct RastPort *, STRPTR, WORD,
*	    struct TextExtent * );
d98 1
a98 1
*	that a text string would render into than the TextLength
d102 5
a106 5
*	rp - a pointer to the RastPort which describes where the
*	    text attributes reside.
*	string - the address of string to determine the length of
*	count - the string length.  If zero, there are no characters
*	    in the string.
d111 2
a112 2
*	    te_Width - same as TextLength result: the rp_cp_x
*		advance that rendering this text would cause.
d114 1
a114 1
*		font.
d116 1
a116 1
*		rectangle this would render into.  Often zero.
d118 2
a119 2
*		from the baseline to the top of the rectangle
*		this would render into.
d121 2
a122 2
*		rectangle this would render into.  Often the
*		same as te_Width-1.
d124 2
a125 2
*		The offset from the baseline to the bottom of
*		the rectanangle this would render into.
d128 2
a129 1
*	TextLength Text TextFit graphics/text.h graphics/rastport.h
d352 5
a356 5
*	d0              a1        a0      d0      a2
*		constrainingExtent, strDirection,
*	        a3                  d1
*		constrainingBitWidth, constrainingBitHeight)
*		d2                    d3
d358 2
a359 2
*	ULONG TextFit( struct RastPort *, STRPTR, UWORD,
*	    struct TextExtent *, struct TextExtent *, WORD, UWORD, UWORD );
d368 2
a369 2
*	rp - a pointer to the RastPort which describes where the
*	    text attributes reside.
d371 2
a372 2
*	strLen - the string length.  If zero, there are no characters
*	    in the string.
d375 1
a375 1
*	    This can be null, indicating only the constrainingBit
d380 1
a380 1
*	    perform a TextFit anchored at the end.  No other value
d391 4
a394 4
*	    given string that will fit in both the constraining
*	    extent (which specifies a CP bound and a rendering
*	    box relative to the origin) and in the rendering width
*	    and height specified.
d405 2
a406 1
*	TextExtent TextLength Text graphics/text.h graphics/rastport.h
@


37.0
log
@initial switchover from V36
@
text
@d2 1
a2 1
**	$Id: length.asm,v 36.24 90/12/13 19:45:29 spence Exp Locker: spence $
d86 1
a86 1
*	TextExtent -- Determine raster extent of text data.
d346 1
a346 1
*	TextFit - count characters that will fit in a given extent
@


36.24
log
@Fixed TextFit() bug. Wrong result returned if fitting right to left,
and the last character to fit had a -ve kern and/or space.
@
text
@d2 1
a2 1
**	$Id: length.asm,v 36.23 90/12/12 11:47:42 bart Exp Locker: spence $
@


36.23
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: length.asm,v 36.22 90/12/11 17:27:08 bart Exp Locker: bart $
d640 1
d659 3
d664 17
a680 5
		bmi.s	2$
		swap	d5
		move.w	0(a4,d5.w),d5	; final Kern
		bmi.s	2$		; check for positive sign
		sub.w	d5,d2		; min - final Kern if positive
a682 1

d689 5
@


36.22
log
@fix fowward/backward kern textfit problems 
@
text
@d2 1
a2 1
**	$Id: length.asm,v 36.21 90/10/12 15:08:55 spence Exp $
@


36.21
log
@same as 36.19
@
text
@d2 1
a2 1
**	$Id: length.asm,v 36.19 90/05/17 09:16:42 kodiak Exp $
d541 1
d594 1
a594 1
		bmi.s	tfbRightFit
d607 1
a607 1
		add.w	d5,d5
d609 1
d639 1
a639 1
		bgt.s	tfExhausted
d644 1
d653 2
d656 1
a656 1
		bsr	tlAlgoStyleAdj
d658 8
d683 1
a683 1
		bra.s	tfCheckBitMin
@


36.20
log
@Fixes TextLength() bug for proportional characters whose Width > its Space,
and for italicised text.
@
text
@d152 1
a152 1
		movem.l d2-d7/a2-a5,-(a7)
d154 1
a154 1
		movem.l	(a7)+,d2-d7/a2-a5
d162 1
a162 1
		movem.l d2-d7/a2-a5,-(a7)
d169 1
a169 1
		movem.l	(a7)+,d2-d7/a2-a5
a201 1
;	d7	stores (kern + CharSpace) value - spence Oct  9 1990
d223 1
a223 1
		bne		tlByteCase
d227 1
a227 1
		bne		tlFixedCase
d267 1
a267 3
		move.w	0(a4,d5.w),d7	; kern
*		add.w	0(a4,d5.w),d0	; CP + Kern
		add.w	d7,d0			; CP + Kern
a272 1
		add.w	0(a3,d5.w),d7	; kern + space
a294 18

* fix problem of character width > space. spence Oct  9 1990 ---v

		sub.w	2(a5,d5.w),d7
*		bge.s	tlAlgoStyleAdj
		bge.s	1$
		sub.w	d7,d0			; add the difference 
		move.w	2(a5,d5.w),d7	; next time through will be OK...
		moveq	#0,d3
		bra.s	tlbCPBound		; ...when we recheck the bounds
1$:
		btst	#FSB_ITALIC+16,d4
		beq.s	tlAlgoStyleAdj
		lsr.w	#1,d5
		move.w	0(a3,d5.w),d6	; CharSpace
		add.w	d5,d5
		move.w	2(a5,d5.w),d5	; charBitWidth
		sub.w	d5,d6			; excess space for italicising into
a295 1
*                                                           ----^
a299 2
		moveq	#8,d5			; to calc italics - spence Oct 10 1990
		moveq	#0,d6
a310 2
		move.w	d3,d5			; to calc italics - spence Oct 10 1990
		move.w	d4,d6			; excess space to italicise into
d321 1
a321 4
		move.w	tf_BoldSmear(a1),d7	; spence Oct 10 1990 ----v
*		add.w	tf_BoldSmear(a1),d1
		add.w	d7,d1
		add.w	d7,d0
a322 2
* d5.w = charBitWidth of last character
* d6.w = excess space after last character to italicise into
d325 8
a332 15
		move.w	tf_Baseline(a1),d7
		move.w	tf_YSize(a1),d4
		sub.w	d7,d4
		addq.w	#1,d4
		lsr.w	#1,d7
		lsr.w	#1,d4
		add.w	d7,d1
		sub.w	d4,d2
		sub.w	d5,d7
		sub.w	d7,d6
		bgt.s	tlDone	; italicising is within the space at the end of the last char
		sub.w	d6,d0	; add the difference to the length
		add.w	d4,d0
*		add.w	d7,d0	; add to the length too. - spence Oct  9 1990
*		sub.w	d5,d0	; - end spence Oct 10 1990      ----^
@


36.19
log
@extend result of TextLength into longword and document historical anomoly
return zero chars when rp_TxSpacing reverses text: consistant w/ empty
    extent returned.
@
text
@d2 1
a2 1
**	$Id: length.asm,v 36.18 90/05/05 16:45:14 kodiak Exp Locker: kodiak $
d152 1
a152 1
		movem.l d2-d6/a2-a5,-(a7)
d154 1
a154 1
		movem.l	(a7)+,d2-d6/a2-a5
d162 1
a162 1
		movem.l d2-d6/a2-a5,-(a7)
d169 1
a169 1
		movem.l	(a7)+,d2-d6/a2-a5
d202 1
d224 1
a224 1
		bne.s	tlByteCase
d228 1
a228 1
		bne.s	tlFixedCase
d268 3
a270 1
		add.w	0(a4,d5.w),d0	; CP + Kern
d276 1
d299 18
d318 1
d323 2
d336 2
d348 4
a351 1
		add.w	tf_BoldSmear(a1),d1
d353 2
d357 15
a371 8
		move.w	tf_Baseline(a1),d5
		move.w	tf_YSize(a1),d6
		sub.w	d5,d6
		addq.w	#1,d6
		lsr.w	#1,d5
		lsr.w	#1,d6
		add.w	d5,d1
		sub.w	d6,d2
@


36.18
log
@doc TextExtent result
@
text
@d2 1
a2 1
**	$Id: length.asm,v 36.17 90/04/13 11:52:31 kodiak Exp Locker: kodiak $
d44 1
a44 1
*	d0:16               a1  a0      d0:16
d71 4
d92 1
a92 1
*	WORD TextExtent( struct RastPort *, STRPTR, WORD,
d155 1
d189 1
a189 1
		rts
d191 1
d394 8
a406 2
		moveq	#0,d0
tfIllegalReverse:
d409 1
a409 3
		move.l	d0,-(a7)
		bsr	zeroExtent
		move.l	(a7)+,d0
d690 1
a690 1
		blt	tfIllegalReverse
a737 1
tfDone:
@


36.17
log
@use Id instead of Header for 4.x rcs
@
text
@d2 1
a2 1
**	$Id$
d105 16
@


36.16
log
@for rcs 4.x header change
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/graphics/text/RCS/length.asm,v 36.15 90/03/08 15:02:25 kodiak Exp Locker: kodiak $
@


36.15
log
@optimize 0(ax) to (ax)
@
text
@d2 1
a2 1
**	$Header: length.asm,v 36.14 90/01/23 16:56:29 kodiak Exp $
@


36.14
log
@first cut at TextFont tag extension (tf_Extension)
@
text
@d2 1
a2 1
**	$Header: length.asm,v 36.13 89/11/22 18:04:10 kodiak Exp $
d240 1
a240 1
		sub.w	#$20,d5
d537 1
a537 1
		sub.w	#$20,d5
@


36.13
log
@working TextFit w/ -1 advance
@
text
@d2 1
a2 1
**	$Header: length.asm,v 36.11 89/06/05 14:15:58 kodiak Exp $
d181 1
a181 1
;	a3	tf_CharSpace
d197 1
d200 1
a200 1
		btst	#FCBB_BYTECELL,MN_LENGTH+FCBO_BYTECELL(a1)
d204 1
a204 1
		btst	#FCBB_KERNLESS,MN_LENGTH+FCBO_KERNLESS(a1)
d483 2
a484 1
		btst	#FCBB_KERNLESS,MN_LENGTH+FCBO_KERNLESS(a1)
@


36.12
log
@after major length changes, before major -1 fit changes
@
text
@d110 19
a128 4
emptyLength:
		moveq	#0,d0
		rts

d130 3
a132 3
		tst.w	d0
		beq.s	emptyLength
		movem.l d2-d6/a2-a4,-(a7)
d134 2
a135 1
		movem.l	(a7)+,d2-d6/a2-a4
d141 1
a141 2
		move.l	d2,-(a7)
		movem.l d3-d6/a2-a4,-(a7)
a142 1
		movem.l	(a7)+,d3-d6/a2-a4
d148 1
a148 1
		move.l	(a7)+,d2
d164 1
a164 1
		move.l	d0,te_Extent+ra_MinY(a2)
d174 3
a176 1
;	d3	cumulative length
d181 4
a184 3
;	a2	tf_CharSpace
;	a3	tf_CharKern
;	a4	tf_CharLoc
d186 5
d208 3
a210 1
		moveq	#0,d1		; always include CP in length
a211 1
		moveq	#0,d3
d213 3
a215 3
		move.l	tf_CharSpace(a1),a2
		move.l	tf_CharKern(a1),a3
		move.l	tf_CharLoc(a1),a4
d244 2
a245 2
		add.w	0(a3,d5.w),d3	; CP + Kern
		cmp.w	d3,d2		; min
d247 1
a247 1
		move.w	d3,d2
d249 3
a251 3
		move.w	d3,d6		; save kern for bit size later
		add.w	0(a2,d5.w),d3	; CP + Space
		add.w	d4,d3		; CP + Spacing
d254 1
a254 1
		add.w	2(a4,d5.w),d6	; Loc bit size
d261 1
a261 1
		cmp.w	d3,d1		; max
d263 1
a263 1
		move.w	d3,d1
d266 1
a266 1
		cmp.w	d3,d2		; min
d268 1
a268 1
		move.w	d3,d2
d271 2
a272 3
		dbf	d0,tlBothLoop
		move.w	d3,d0
		bra.s	tlaChkBold
d280 1
a280 1
		bra.s	tlaChkBold
d285 1
d288 6
a293 3
		muls	d3,d0
		move.w	d0,d1
		moveq	#0,d2
d295 1
a295 16
		;-- fix up for negative path
		tst.w	d3
		bpl.s	tlfForwardTotal

		;--	reverse total
		sub.w	d3,d1			; back off rendering last space
		move.w	d1,d2			; min = old_max + 1
		addq.w	#1,d2
		move.w	tf_XSize(a1),d1		; there is a positive max part
		bra.s	tlaChkBold

		;--	forward total
tlfForwardTotal:
		sub.w	d4,d1			; back off rendering last space

tlaChkBold:
d298 1
a298 1
		add.w	tf_BoldSmear(a1),d2
d308 2
a309 2
		sub.w	d5,d2
		add.w	d6,d1
d314 4
d319 1
d350 2
d355 2
a356 1
*	    perform a TextFit anchored at the end.
a373 3
*   BUGS
*	strDirections that are not one do not yet work.
*
d375 4
a378 1
tfEarlyZeroExtent:
d380 4
a383 1
		bra	zeroExtent
d389 13
a401 1
	    ;-- check early reasons to allow no characters
d404 4
a407 2
		beq.s	tfEarlyZeroExtent
		;-- check constrainingBitHeight
d410 13
a422 2
		blt.s	tfEarlyZeroExtent
		;-- check constrainingExtent MaxY
d424 3
a426 3
		cmp.w	te_Extent+ra_MaxY(a3),d6
		bgt.s	tfEarlyZeroExtent
		;-- check constrainingExtent MinY
d429 2
a430 2
		cmp.w	te_Extent+ra_MinY(a3),d6
		blt.s	tfEarlyZeroExtent
d432 1
d434 4
a437 7
;	d0	strLen / char index
;	d1	working max / working min
;	d2	bounding bit size / bounding width
;	d3	original strLen / cumulative length
;	d4	rp_AlgoStyle, rp_TxSpacing
;	d5	last character's max / last character's min
;	d6	bounding max (-1) / bounding min
d441 1
a441 4
;	a2	tf_CharSpace
;	a3	tf_CharKern
;	a4	tf_CharLoc
;	a6	string direction
a444 8
		move.l	a2,-(a7)
		move.l	d1,a6		; save string direction
		moveq	#$00000000,d1	; working max = 0, min = 0
		swap	d2		; bounding bit width in high word
		move.w	te_Width(a3),d2	; bounding CP width in low word
		move.w	d0,d3		; original strLen
		swap	d3		;   in high word
		clr.w	d3		; CP = 0
a447 4
		moveq	#0,d5		; last character's max = 0, min = 0
		move.w	te_Extent+ra_MaxX(a3),d6
		swap	d6
		move.w	te_Extent+ra_MinX(a3),d6
d454 5
a458 6
		swap	d6
		sub.w	tf_BoldSmear(a1),d6
		swap	d6
		swap	d2
		sub.w	tf_BoldSmear(a1),d2
		swap	d2
d461 1
a461 15
		beq.s	tfFontCase
		swap	d2
		move.w	tf_Baseline(a1),d7
		lsr.w	#1,d7
		sub.w	d7,d2
		swap	d6
		sub.w	d7,d6
		swap	d6
		move.w	tf_YSize(a1),d7
		sub.w	tf_Baseline(a1),d7
		addq.w	#1,d7
		lsr.w	#1,d7
		sub.w	d7,d2
		add.w	d7,d6
		swap	d2
d463 19
a481 1
tfFontCase:
d485 29
a513 3
		move.l	tf_CharSpace(a1),a2
		move.l	tf_CharKern(a1),a3
		move.l	tf_CharLoc(a1),a4
d518 2
a519 4
		swap	d0
		clr.w	d0
		move.b	(a0),d0
		add.l	a6,a0
d523 1
a523 1
		cmp.b	tf_HiChar(a1),d0
d525 1
a525 1
		sub.b	tf_LoChar(a1),d0
d529 3
a531 3
		move.b	tf_HiChar(a1),d0
		sub.b	tf_LoChar(a1),d0
		addq.w	#1,d0
d535 1
a535 1
		sub.w	#$20,d0
d539 8
a546 13
		add.w	d0,d0
		add.w	0(a3,d0.w),d3	; CP + Kern
		cmp.w	d3,d1		; min
		ble.s	tfbAddSpace
		cmp.w	d3,d6		;   out of bounds?
		bgt.s	tfUnKern
		move.w	d3,d1
tfbAddSpace:
		move.w	d3,d7		; save kern for bit size later
		add.w	0(a2,d0.w),d3	; CP + Space
		add.w	d4,d3		; CP + Spacing
		cmp.w	d3,d2		;   out of bounds?
		blt.s	tfUnD4SpaceKern
d548 6
a553 5
		cmp.w	d3,d1		; min
		ble.s	tfbGetMax
		cmp.w	d3,d6		;   out of bounds?
		bgt.s	tfUnD4SpaceKern
		move.w	d3,d1
d555 51
a605 17
tfbGetMax:
		add.w	d0,d0
		add.w	2(a4,d0.w),d7	; Loc bit size
		cmp.w	d3,d7
		bge.s	tfbChkMax
		move.w	d3,d7
tfbChkMax:
		swap	d1
		cmp.w	d7,d1		; max
		bge.s	tfbChkSize
		swap	d6
		cmp.w	d7,d6		;   out of bounds?
		ble.s	tfUnD4SpaceKern
		swap	d6
		move.w	d7,d1
		;-- check bounding bit size
tfbChkSize:
d607 3
a609 6
		swap	d1
		sub.w	d1,d7		; max - min
		swap	d2
		cmp.w	d7,d2		;   out of bounds?
		blt.s	tfUnD4SpaceKern
		swap	d2
d611 2
a612 2
		move.l	d1,d5		; move working to last character's
		swap	d0		; recover strLen
d614 1
a614 2
		dbf	d0,tfBothLoop
		bra.s	tfNoMoreChars
d618 7
a624 44
tfUnD4SpaceKern:
		sub.w	0(a3,d0.w),d3	; recover CP before + Kern
		sub.w	0(a2,d0.w),d3	; recover CP before + Space
tfUnD4:
		sub.w	d4,d3		; recover CP before + constant space
		bra.s	tfBounded
tfUnKern:
		sub.w	0(a3,d0.w),d3	; recover CP before + Kern
tfBounded:
		swap	d0		; recover strLen
tfNoMoreChars:
		btst	#FSB_BOLD+16,d4
		beq.s	tfbChkItalic
		swap	d5
		add.w	tf_BoldSmear(a1),d5
		swap	d5
tfbChkItalic:
		btst	#FSB_ITALIC+16,d4
		beq.s	tfbDone
		move.w	tf_Baseline(a1),d6
		move.w	tf_YSize(a1),d7
		sub.w	d6,d7
		addq.w	#1,d7
		lsr.w	#1,d6
		lsr.w	#1,d7
		sub.w	d6,d5
		swap	d5
		add.w	d7,d5
		swap	d5
tfbDone:
		move.l	(a7)+,a2
		move.w	d3,te_Width(a2)
		move.w	d5,te_Extent+ra_MinX(a2)
		swap	d5
		subq.w	#1,d5
		move.w	d5,te_Extent+ra_MaxX(a2)
		swap	d3		; recover original strLen
		sub.w	d0,d3		; find what was used up
		subq.w	#1,d3		; this is the chars result
		bsr	yExtent
		moveq	#0,d0
		move.w	d3,d0
		movem.l	(a7)+,d2-d7/a3-a6
		rts
d626 31
d659 5
a663 9
		swap	d0
		move.w	tf_XSize(a1),d0
		add.w	d0,d4
		swap	d0
		bra	tfFixedDBF
tfFixedLoop:
		swap	d0		; cache strLen
		move.w	d3,d7		; save CP in case of failure
		add.w	d0,d7		; CP + XSize
d665 5
a669 9
		swap	d1
		cmp.w	d7,d1		; max
		bge.s	tffAddSpacing
		swap	d6
		cmp.w	d7,d6		;   out of bounds?
		ble	tfBounded
		swap	d6
		move.w	d7,d1
		swap	d1
d671 14
a684 3
tffAddSpacing:
		cmp.w	d0,d4
		beq	tffNoExtraSpacing
d686 1
a686 1
		add.w	d4,d3
d688 9
a696 2
		tst.w	d4		; positive or negative spacing?
		bmi.s	tffNegSpacing
d698 3
a700 10
		swap	d1
		cmp.w	d3,d1		; max
		bge.s	tffChkSize
		swap	d6
		cmp.w	d3,d6		;   out of bounds?
		ble	tfUnD4
		swap	d6
		move.w	d3,d1
		swap	d1
		bra.s	tffChkSize
d702 12
a713 7
tffNegSpacing:
		cmp.w	d3,d1		; min
		ble.s	tffAddSpacing
		cmp.w	d3,d6		;   out of bounds?
		bgt	tfUnD4
		move.w	d3,d1
		bra.s	tffChkSize
a714 12
tffNoExtraSpacing:
		move.w	d7,d3
		;-- check bounding bit size
tffChkSize:
		swap	d1
		move.w	d1,d7		; working max
		swap	d1
		sub.w	d1,d7		; max - min
		swap	d2
		cmp.w	d7,d2		;   out of bounds?
		blt	tfUnD4
		swap	d2
d716 4
a719 6
		move.l	d1,d5		; move working to last character's
		swap	d0		; recover strLen
tfFixedDBF:
		dbf	d0,tfFixedLoop
		bra	tfNoMoreChars

@


36.11
log
@autodoc changes
@
text
@d2 1
a2 1
**	$Header$
d117 1
a117 1
		movem.l d2-d6/a2-a5,-(a7)
d119 1
a119 1
		movem.l	(a7)+,d2-d6/a2-a5
d126 1
a126 1
		movem.l d3-d6/a2-a5,-(a7)
d128 1
a128 1
		movem.l	(a7)+,d3-d6/a2-a5
a167 1
;	a5	character bounder
d175 1
a175 2
		btst	#FSB_COMPILED,tf_Style(a1)
		beq.s	tlProportional
a176 3
		tst.w	d4		; rp_TxSpacing
		bne.s	tlSpacingExists

d178 1
a178 1
		bne	tlByteCase
a180 3
		btst	#FPB_PROPORTIONAL,tf_Flags(a1)
		bne.s	tlProportional

d182 1
a182 1
		bne	tlFixedCase
d184 2
a185 4
tlProportional:
		move.l	tf_CharLoc(a1),a4

	    ;-- initialize max/min
d190 4
a193 7
	    ;-- get character bounder
		cmp.w	#$20ff,tf_LoChar(a1)
		bne.s	tlFullBounder
		lea	tlStdBoundSub(pc),a5
		bra.s	tlFindKSCase
tlFullBounder:
		lea	tlFullBoundSub(pc),a5
a194 9
	    ;-- find kern/space case
tlFindKSCase:
		move.l	tf_CharKern(a1),d6
		beq.s	tlNoKern
		move.l	d6,a3
		move.l	tf_CharSpace(a1),d6
		beq.s	tlKern
		move.l	d6,a2
		bra	tlBothDBF
d196 7
a202 4
	    ;-- kern & no space loop
tlKern:
		add.w	tf_XSize(a1),d4
		bra.s	tlKernDBF
d204 4
a207 2
tlKernLoop:
		jsr	(a5)
d209 5
a213 7
		add.w	0(a3,d5.w),d3	; CP + Kern
		cmp.w	d3,d2		; min
		ble.s	tlkAddSpace
		move.w	d3,d2
tlkAddSpace:
		move.w	d3,d6		; save kern for bit size later
		add.w	d4,d3		; CP + XSize + Spacing
d215 3
a217 5
		add.w	d5,d5
		add.w	2(a4,d5.w),d6	; Loc bit size
		cmp.w	d6,d1		; max
		bge.s	tlkCPBound
		move.w	d6,d1
d219 1
a219 35
		;-- bound to CP
tlkCPBound:
		cmp.w	d3,d1		; max
		bge.s	tlkCPBMin
		move.w	d3,d1
		bra.s	tlKernDBF
tlkCPBMin
		cmp.w	d3,d2		; min
		ble.s	tlKernDBF
		move.w	d3,d2

tlKernDBF:
		dbf	d0,tlKernLoop
		bra	tlAlgoContribution


	    ;-- no kern & ?
tlNoKern:
		move.l	tf_CharSpace(a1),d6
		beq.s	tlNeither
		move.l	d6,a2
		bra.s	tlSpaceDBF

	    ;-- no kern & space loop
tlSpaceLoop:
		jsr	(a5)

		move.w	d3,d6		; save kern for bit size later
		add.w	0(a2,d5.w),d3	; CP + Space
		add.w	d4,d3		; CP + Spacing

		cmp.w	d6,d2		; min
		ble.s	tlsAddSize
		move.w	d6,d2
tlsAddSize:
a220 25
		add.w	2(a4,d5.w),d6	; Loc bit size
		cmp.w	d6,d1		; max
		bge.s	tlsCPBound
		move.w	d6,d1

		;-- bound to CP
tlsCPBound:
		cmp.w	d3,d1		; max
		bge.s	tlsCPBMin
		move.w	d3,d1
		bra.s	tlSpaceDBF
tlsCPBMin
		cmp.w	d3,d2		; min
		ble.s	tlSpaceDBF
		move.w	d3,d2

tlSpaceDBF:
		dbf	d0,tlSpaceLoop
		bra	tlAlgoContribution


	    ;-- kern & space loop
tlBothLoop:
		jsr	(a5)

d249 2
a250 1
		bra.s	tlAlgoContribution
a251 4
	    ;-- no kern & no space loop
tlNeither:
		btst	#FCBB_KERNLESS,MN_LENGTH+FCBO_KERNLESS(a1)
		bne.s	tlFixedCase
a252 31
		add.w	tf_XSize(a1),d4
		bra.s	tlNeitherDBF

tlNeitherLoop:
		jsr	(a5)

		move.w	d3,d6		; save kern for bit size later
		add.w	d4,d3		; CP + XSize + Spacing

		add.w	d5,d5
		add.w	2(a4,d5.w),d6	; Loc bit size
		cmp.w	d6,d1		; max
		bge.s	tlnCPBound
		move.w	d6,d1

		;-- bound to CP
tlnCPBound:
		cmp.w	d3,d1		; max
		bge.s	tlnCPBMin
		move.w	d3,d1
		bra.s	tlNeitherDBF
tlnCPBMin
		cmp.w	d3,d2		; min
		ble.s	tlNeitherDBF
		move.w	d3,d2

tlNeitherDBF:
		dbf	d0,tlNeitherLoop
		bra.s	tlAlgoContribution


d260 1
d269 1
a269 1
		;-- fix up for negative path or spacing
d271 3
a273 8
		blt.s	tlfReverseTotal
		cmp.w	d4,d3
		blt.s	tlfReversePathForwardTotal
		;--	forward path, forward total
		sub.w	d4,d1			; back off rendering last space
		bra.s	tlaChkBold
tlfReversePathForwardTotal:
		;--	reverse path, forward total
a274 7
		move.w	tf_XSize(a1),d2		; there is a negative min part
		bra.s	tlaChkBold
tlfReverseTotal:
		cmp.w	d4,d3
		bgt.s	tlfForwardPathReverseTotal
		;--	reverse path, reverse total
		sub.w	d4,d1			; back off rendering last space
a275 7
		addq.w	#1,d2			;
		moveq	#1,d1			; new max
		bra.s	tlaChkBold
tlfForwardPathReverseTotal:
		;--	forward path, reverse total
		sub.w	d3,d1			; back off rendering last space
		move.w	d1,d2			; min = old_max + 1
d280 3
a283 2
tlAlgoContribution:
		move.w	d3,d0
a301 11
;------ tlStdBoundSub ------------------------------------------------
tlStdBoundSub:
		clr.w	d5
		move.b	(a0)+,d5
		sub.w	#$20,d5
		bcs.s	tlsbBad
		add.w	d5,d5
		rts
tlsbBad:
		move.w	#$1c0,d5		; undefined char is $100-$20
		rts
a302 16
;------ tlFullBountSub -----------------------------------------------
tlFullBoundSub:
		clr.w	d5
		move.b	(a0)+,d5
		cmp.b	tf_HiChar(a1),d5
		bhi.s	tlfbBad
		sub.b	tf_LoChar(a1),d5
		bcs.s	tlfbBad
		add.w	d5,d5
		rts
tlfbBad:
		move.b	tf_HiChar(a1),d5
		sub.b	tf_LoChar(a1),d5
		addq.w	#1,d5
		add.w	d5,d5
		rts
a303 1

d359 4
d366 1
d383 1
a383 2
		bge.s	tfCheckX
		bra.s	tfEarlyZeroExtent
a384 6
tfZeroExtent:
		move.l	(a7)+,a2
tfEarlyZeroExtent:
		movem.l	(a7)+,d2-d7/a3-a6
		bra	zeroExtent

a398 1
;	a5	character bounder
d432 1
a432 1
		beq.s	tfGetSpacing
d448 1
a448 15
tfGetSpacing:
		move.l	tf_CharLoc(a1),a4

	    ;-- get character bounder
		cmp.w	#$20ff,tf_LoChar(a1)
		bne.s	tfFullBounder
		lea	tfStdBoundSub(pc),a5
		bra.s	tfFindKSCase
tfFullBounder:
		lea	tfFullBoundSub(pc),a5

	    ;-- find kern/space case
tfFindKSCase:
		btst	#FPB_PROPORTIONAL,tf_Flags(a1)
		bne.s	tfProportional
d452 3
a454 8
tfProportional:

		move.l	tf_CharKern(a1),d7
		beq.s	tfNoKern
		move.l	d7,a3
		move.l	tf_CharSpace(a1),d7
		beq.s	tfKern
		move.l	d7,a2
d457 8
a464 4
	    ;-- kern & no space loop
tfKern:
		add.w	tf_XSize(a1),d4
		bra.s	tfKernDBF
d466 4
a469 2
tfKernLoop:
		jsr	(a5)
d471 9
a479 11
		add.w	0(a3,d0.w),d3	; CP + Kern
		cmp.w	d3,d1		; min
		ble.s	tfkAddSpace
		cmp.w	d3,d6		;   out of bounds?
		bgt	tfUnKern
		move.w	d3,d1
tfkAddSpace:
		move.w	d3,d7		; save kern for bit size later
		add.w	d4,d3		; CP + XSize + Spacing
		cmp.w	d3,d2		;   out of bounds?
		blt	tfUnD4Kern
d481 1
a481 7
		cmp.w	d3,d1		; min
		ble.s	tfkGetMax
		cmp.w	d3,d6		;   out of bounds?
		bgt	tfUnD4Kern
		move.w	d3,d1

tfkGetMax:
a482 145
		add.w	2(a4,d0.w),d7	; Loc bit size
		cmp.w	d3,d7
		bge.s	tfkChkMax
		move.w	d3,d7
tfkChkMax:
		swap	d1
		cmp.w	d7,d1		; max
		bge.s	tfkChkSize
		swap	d6
		cmp.w	d7,d6		;   out of bounds?
		ble	tfUnD4Kern
		swap	d6
		move.w	d7,d1
		;-- check bounding bit size
tfkChkSize:
		move.w	d1,d7		; working max
		swap	d1
		sub.w	d1,d7		; max - min
		swap	d2
		cmp.w	d7,d2		;   out of bounds?
		blt	tfUnD4Kern
		swap	d2

		move.l	d1,d5		; move working to last character's
		swap	d0		; recover strLen
tfKernDBF:
		dbf	d0,tfKernLoop
		bra	tfNoMoreChars


	    ;-- no kern & ?
tfNoKern:
		move.l	tf_CharSpace(a1),d7
		bne	tfSpace

		btst	#FCBB_KERNLESS,MN_LENGTH+FCBO_KERNLESS(a1)
		bne	tfFixedCase

		add.w	tf_XSize(a1),d4
		bra.s	tfNeitherDBF

tfNeitherLoop:
		jsr	(a5)

		move.w	d3,d7		; save kern for bit size later
		add.w	d4,d3		; CP + Space + Spacing
		cmp.w	d3,d2		;   out of bounds?
		blt	tfUnD4

		cmp.w	d3,d1		; min
		ble.s	tfnGetMax
		cmp.w	d3,d6		;   out of bounds?
		bgt	tfUnD4
		move.w	d3,d1

tfnGetMax:
		add.w	d0,d0
		add.w	2(a4,d0.w),d7	; Loc bit size

		cmp.w	d3,d7
		bge.s	tfnChkMax
		move.w	d3,d7
tfnChkMax:
		swap	d1
		cmp.w	d7,d1		; max
		bge.s	tfnChkSize
		swap	d6
		cmp.w	d7,d6		;   out of bounds?
		ble	tfUnD4
		swap	d6
		move.w	d7,d1
		;-- check bounding bit size
tfnChkSize:
		move.w	d1,d7		; working max
		swap	d1
		sub.w	d1,d7		; max - min
		swap	d2
		cmp.w	d7,d2		;   out of bounds?
		blt	tfUnD4
		swap	d2

		move.l	d1,d5		; move working to last character's
		swap	d0		; recover strLen
tfNeitherDBF:
		dbf	d0,tfNeitherLoop
		bra	tfNoMoreChars


tfSpace:
		move.l	d7,a2
		bra.s	tfSpaceDBF

	    ;-- no kern & space loop
tfSpaceLoop:
		jsr	(a5)

		move.w	d3,d7		; save kern for bit size later
		add.w	0(a2,d0.w),d3	; CP + Space
		add.w	d4,d3		; CP + Spacing
		cmp.w	d3,d2		;   out of bounds?
		blt	tfUnD4Space

		cmp.w	d3,d1		; min
		ble.s	tfsGetMax
		cmp.w	d3,d6		;   out of bounds?
		bgt	tfUnD4Space
		move.w	d3,d1

tfsGetMax:
		add.w	d0,d0
		add.w	2(a4,d0.w),d7	; Loc bit size

		cmp.w	d3,d7
		bge.s	tfsChkMax
		move.w	d3,d7
tfsChkMax:
		swap	d1
		cmp.w	d7,d1		; max
		bge.s	tfsChkSize
		swap	d6
		cmp.w	d7,d6		;   out of bounds?
		ble.s	tfUnD4Space
		swap	d6
		move.w	d7,d1
		;-- check bounding bit size
tfsChkSize:
		move.w	d1,d7		; working max
		swap	d1
		sub.w	d1,d7		; max - min
		swap	d2
		cmp.w	d7,d2		;   out of bounds?
		blt.s	tfUnD4Space
		swap	d2

		move.l	d1,d5		; move working to last character's
		swap	d0		; recover strLen
tfSpaceDBF:
		dbf	d0,tfSpaceLoop
		bra.s	tfNoMoreChars


	    ;-- kern & space loop
tfBothLoop:
		jsr	(a5)

d533 1
a536 1
tfUnD4Space:
a540 2
tfUnD4Kern:
		sub.w	d4,d3		; recover CP before + constant space
a591 3
		tst.w	d0		; positive or negative size?
		bmi.s	tffNegXSize

a600 1
		bra.s	tffAddSpacing
a601 7
tffNegXSize:
		cmp.w	d7,d1		; min
		ble.s	tffAddSpacing
		cmp.w	d7,d6		;   out of bounds?
		bgt	tfBounded
		move.w	d7,d1

a649 32
;------ tfStdBoundSub ------------------------------------------------
tfStdBoundSub:
		swap	d0
		clr.w	d0
		move.b	(a0),d0
		add.l	a6,a0
		sub.w	#$20,d0
		bcs.s	tfsbBad
		add.w	d0,d0
		rts
tfsbBad:
		move.w	#$1c0,d0		; undefined char is $100-$20
		rts

;------ tfFullBoundSub -----------------------------------------------
tfFullBoundSub:
		swap	d0
		clr.w	d0
		move.b	(a0),d0
		add.l	a6,a0
		cmp.b	tf_HiChar(a1),d0
		bhi.s	tffbBad
		sub.b	tf_LoChar(a1),d0
		bcs.s	tffbBad
		add.w	d0,d0
		rts
tffbBad:
		move.b	tf_HiChar(a1),d0
		sub.b	tf_LoChar(a1),d0
		addq.w	#1,d0
		add.w	d0,d0
		rts
@


36.10
log
@rework mechanism for storing speedup bits
@
text
@d1 8
a8 58
	TTL    '$Header: length.asm,v 36.9 88/09/01 15:12:25 kodiak Exp $'
**********************************************************************
*
*		-------------
*		GRAPHICS TEXT	output length of text string
*		-------------
*
*   Copyright 1985, 1987 Commodore-Amiga Inc.
*
*   Source Control: $Locker: kodiak $
*
*   $Log:	length.asm,v $
*   Revision 36.9  88/09/01  15:12:25  kodiak
*   fix length returned from TextFit
*   fix fixed case TextFit
*   
*   Revision 36.8  88/07/15  17:23:06  kodiak
*   teach TextFit about KERNLESS support & length encompasing CP
*   
*   Revision 36.7  88/07/15  16:23:59  kodiak
*   add KERNLESS support while ensuring length encompasses CP
*   
*   Revision 36.6  88/06/16  13:18:22  kodiak
*   don't corrupt d0 for fixed font TextFit case
*   
*   Revision 36.5  88/06/13  15:29:37  kodiak
*   fix TextFit bug re: A1 needs to be rp_Font while doing algo init adjustment
*   
*   Revision 36.4  88/04/15  12:27:40  kodiak
*   bounded strlen fix
*   
*   Revision 36.3  88/04/15  11:49:31  kodiak
*   fix ConstrainingWidth
*   
*   Revision 36.2  88/04/13  13:27:25  kodiak
*   fix Y extent min/max
*   
*   Revision 36.1  88/04/08  17:38:03  kodiak
*   (fix swap of original strlen)
*   
*   Revision 36.0  88/03/06  11:01:11  kodiak
*   changed TextLength, TextFit
*   
*   Revision 35.4  88/01/08  14:40:19  kodiak
*   fix some TextFit bugs
*   
*   Revision 35.3  88/01/08  13:45:53  kodiak
*   first cut at TextFit instead of CharFit
*   
*   Revision 35.2  88/01/08  13:38:31  kodiak
*   new TextExtent
*   new CharFit
*   
*   Revision 35.1  87/11/11  14:42:52  kodiak
*   textLength called by write.asm
*   
*
**********************************************************************
d44 1
a44 1
*	d0:16		    a1	  a0    d0:16
d46 1
a46 4
*	SHORT length;
*	struct RastPort *pr;
*	STRPTR string;
*	SHORT count;
d88 3
d475 4
@


36.9
log
@fix length returned from TextFit
fix fixed case TextFit
@
text
@d1 1
a1 1
	TTL    '$Header: length.asm,v 36.8 88/07/15 17:23:06 kodiak Exp $'
d13 4
d73 1
d75 1
d96 5
d226 2
a227 1
		bne.s	tlSpacingExists		; result of rp_TxSpacing
d229 4
a232 1
		btst	#FSB_BYTEFONT,tf_Style(a1)
d234 1
d238 2
a239 1
		btst	#FSB_KERNLESS,tf_Style(a1)
d383 1
a383 1
		btst	#FSB_KERNLESS,tf_Style(a1)
d516 1
a516 1
*	TextFit - count characters that will fit in a given width
d560 3
d671 1
a671 1
		btst	#FSB_KERNLESS,tf_Style(a1)
d747 1
a747 1
		btst	#FSB_KERNLESS,tf_Style(a1)
@


36.8
log
@teach TextFit about KERNLESS support & length encompasing CP
@
text
@d1 1
a1 1
	TTL    '$Header: length.asm,v 36.7 88/07/15 16:23:59 kodiak Exp $'
d13 3
d676 1
a676 1
		bgt	tfBounded
d682 1
a682 1
		blt	tfBounded
d687 1
a687 1
		bgt	tfBounded
d702 1
a702 1
		ble	tfBounded
d712 1
a712 1
		blt	tfBounded
d739 1
a739 1
		blt	tfBounded
d744 1
a744 1
		bgt	tfBounded
d760 1
a760 1
		ble	tfBounded
d770 1
a770 1
		blt	tfBounded
d792 1
a792 1
		blt	tfBounded
d797 1
a797 1
		bgt	tfBounded
d813 1
a813 1
		ble.s	tfBounded
d823 1
a823 1
		blt.s	tfBounded
d841 1
a841 1
		bgt.s	tfBounded
d848 1
a848 1
		blt.s	tfBounded
d853 1
a853 1
		bgt.s	tfBounded
d868 1
a868 1
		ble.s	tfBounded
d878 1
a878 1
		blt.s	tfBounded
d888 11
d938 5
a942 2
		add.w	tf_XSize(a1),d4
		bra.s	tfFixedDBF
d945 2
a946 4
		move.w	d3,d7		; save kern for bit size later
		add.w	d4,d3		; CP + XSize + Spacing
		cmp.w	d3,d2		;   out of bounds?
		blt.s	tfBounded
d948 15
d964 1
a964 1
		ble.s	tffAddSize
d966 1
a966 1
		bgt.s	tfBounded
d968 10
a977 3
tffAddSize:
		add.w	d0,d0
		add.w	d0,d7		; Loc bit size
d979 1
a979 1
		cmp.w	d7,d1		; max
d982 2
a983 2
		cmp.w	d7,d6		;   out of bounds?
		ble.s	tfBounded
d985 14
a998 1
		move.w	d7,d1
d1001 1
d1007 1
a1007 1
		blt	tfBounded
@


36.7
log
@add KERNLESS support while ensuring length encompasses CP
@
text
@d1 1
a1 1
	TTL    '$Header: length.asm,v 36.6 88/06/16 13:18:22 kodiak Exp $'
d13 3
d590 1
a590 1
		move.l	#$80007fff,d1	; working max = -32768, min = 32767
d647 3
a649 1
		beq	tfFixedCase
d651 2
d681 7
d690 4
d722 56
a777 1
		beq	tfFixedCase
d791 7
a797 6
		cmp.w	d7,d1		; min
		ble.s	tfsAddSize
		cmp.w	d7,d6		;   out of bounds?
		bgt.s	tfBounded
		move.w	d7,d1
tfsAddSize:
d800 5
d847 7
d856 4
d980 1
a980 1
;------ tfFullBountSub -----------------------------------------------
@


36.6
log
@don't corrupt d0 for fixed font TextFit case
@
text
@d1 1
a1 1
	TTL    '$Header: length.asm,v 36.5 88/06/13 15:29:37 kodiak Exp $'
d13 3
d215 3
a217 1
		beq	tlFixedCase
d219 1
d223 2
a224 2
		move.w	#-32768,d1	; large negative word
		move.w	#32767,d2	; large word
d243 1
a243 1
		bra.s	tlBothDBF
d264 1
a264 1
		bge.s	tlKernDBF
d266 12
d286 1
a286 1
		beq.s	tlFixedCase
d305 1
a305 1
		bge.s	tlSpaceDBF
d307 12
d321 1
a321 1
		bra.s	tlAlgoContribution
d340 1
a340 1
		bge.s	tlBothDBF
d342 12
d357 36
@


36.5
log
@fix TextFit bug re: A1 needs to be rp_Font while doing algo init adjustment
@
text
@d1 1
a1 1
	TTL    '$Header: length.asm,v 36.4 88/04/15 12:27:40 kodiak Exp $'
d10 1
a10 1
*   Source Control: $Locker:  $
d13 3
d756 1
a756 2
		move.w	tf_XSize(a1),d0
		add.w	d0,d4
d759 1
@


36.4
log
@bounded strlen fix
@
text
@d1 1
a1 1
	TTL    '$Header: length.asm,v 36.3 88/04/15 11:49:31 kodiak Exp $'
d13 3
d514 1
d520 2
a549 3
		move.w	rp_TxSpacing(a1),d4
		move.l	rp_Font(a1),a1

@


36.3
log
@fix ConstrainingWidth
@
text
@d1 1
a1 1
	TTL    '$Header: length.asm,v 36.2 88/04/13 13:27:25 kodiak Exp $'
d10 1
a10 1
*   Source Control: $Locker: kodiak $
d13 3
d614 1
a614 1
		bra	tfBounded
d664 1
a664 1
		bra.s	tfBounded
d708 1
d712 2
d789 1
a789 1
		bra	tfBounded
@


36.2
log
@fix Y extent min/max
@
text
@d1 1
a1 1
	TTL    '$Header: length.asm,v 36.1 88/04/08 17:38:03 kodiak Exp $'
d13 3
a500 1
		neg.w	d2		; easier to work with min-max
d599 1
a599 1
		move.w	d1,d7		; working min
d601 1
a601 1
		sub.w	d1,d7		; min - max
d604 1
a604 1
		bgt	tfBounded
d649 1
a649 1
		move.w	d1,d7		; working min
d651 1
a651 1
		sub.w	d1,d7		; min - max
d654 1
a654 1
		bgt.s	tfBounded
d693 1
a693 1
		move.w	d1,d7		; working min
d695 1
a695 1
		sub.w	d1,d7		; min - max
d698 1
a698 1
		bgt.s	tfBounded
d771 1
a771 1
		move.w	d1,d7		; working min
d773 1
a773 1
		sub.w	d1,d7		; min - max
d776 1
a776 1
		bgt	tfBounded
@


36.1
log
@(fix swap of original strlen)
@
text
@d1 1
a1 1
	TTL    '$Header: length.asm,v 36.0 88/03/06 11:01:11 kodiak Exp $'
d13 3
d159 4
a163 3
		sub.w	d0,d1
		addq.w	#1,d1
		move.w	d1,te_Extent+ra_MinY(a2)
@


36.0
log
@changed TextLength, TextFit
@
text
@d1 1
a1 1
	TTL    '$Header: length.asm,v 35.4 88/01/08 14:40:19 kodiak Exp $'
d13 3
d498 1
a498 1
		swap	d0		;   in high word
@


35.4
log
@fix some TextFit bugs
@
text
@d1 1
a1 1
	TTL    '$Header: length.asm,v 35.3 88/01/08 13:45:53 kodiak Exp $'
d13 3
d129 1
a129 1
		movem.l d2-d6/a2,-(a7)
d131 1
a131 1
		movem.l	(a7)+,d2-d6/a2
d137 2
a138 1
		movem.l d2-d6/a2,-(a7)
d140 1
d145 5
a156 1
		movem.l	(a7)+,d2-d6/a2
d158 1
d160 5
a164 4
		move.l	a2,a1
		clr.l	(a1)+
		clr.l	(a1)+
		clr.l	(a1)+
d172 8
a179 5
;	d4	hiChar
;	d5	loChar
;	d6	temp for address testing, then char index
;	a1	rastPort, then textFont, then tf_CharSpace
;	a2	tf_CharKern
a180 1

d182 4
a185 8
	    ;-- get effect of spacing
		moveq	#0,d3
		move.w	rp_TxSpacing(a1),d3
		beq.s	getFontData
		muls	d0,d3

	    ;-- get register variables font
getFontData:
d187 1
d190 2
a191 1
		bne.s	byteLength
d193 1
a193 1
		beq.s	fixedLength
d195 2
d200 10
a209 3
	    ;-- initialize loop invariants
		move.b	tf_HiChar(a1),d4
		move.b	tf_LoChar(a1),d5
d211 1
d213 4
a216 1
		beq.s	noKern
d218 1
a218 4
		move.l	tf_CharSpace(a1),d6
		beq.s	kern
		move.l	d6,a1
		bra.s	bothDBF
d220 4
a223 6
	    ;-- kern & no space
kern:
		move.w	d0,d6
		mulu	tf_XSize(a1),d6
		add.w	d6,d3
		bra.s	oneDBF
d225 21
d247 1
a247 1
noKern:
d249 1
a249 1
		beq.s	fixedLength
d251 1
a251 1
		bra.s	oneDBF
d253 3
a255 4
	    ;-- endgame, here so it's a short branch for all
byteLength:
		lsl.w	#3,d0
		bra.s	addSpacing
d257 3
a259 2
fixedLength:
		muls	tf_XSize(a1),d0
d261 12
a272 5
addSpacing:
		add.w	d3,d0
		move.w	d0,d1
		moveq	#0,d2
		rts
d274 1
d276 6
a281 12
bothLoop:
		moveq	#0,d6
		move.b	(a0)+,d6
		cmp.b	d4,d6
		bhi.s	bothUnknownChar
		sub.b	d5,d6
		bcs.s	bothUnknownChar
bothHaveChar:
		add.w	d6,d6
		add.w	0(a2,d6.w),d3
		cmp.w	d2,d3			; min
		bgt.s	1$
d283 4
a286 18
1$:
		cmp.w	d1,d3			; max
		blt.s	2$
		move.w	d3,d1
2$:
		add.w	0(a1,d6.w),d3
		cmp.w	d2,d3			; min
		bgt.s	3$
		move.w	d3,d2
3$:
		cmp.w	d1,d3			; max
		blt.s	4$
		move.w	d3,d1
4$:
bothDBF:
		dbf	d0,bothLoop
		move.w	d3,d0
		rts
d288 8
a295 5
bothUnknownChar:
		move.b	d4,d6
		sub.b	d5,d6
		addq	#1,d6
		bra.s	bothHaveChar
d297 47
a343 21
	    ;-- kern or space loop
oneLoop:
		moveq	#0,d6
		move.b	(a0)+,d6
		cmp.b	d4,d6
		bhi.s	oneUnknownChar
		sub.b	d5,d6
		bcs.s	oneUnknownChar
oneHaveChar:
		add.w	d6,d6
		add.w	0(a2,d6.w),d3
		cmp.w	d2,d3			; min
		bgt.s	1$
		move.w	d3,d2
1$:
		cmp.w	d1,d3			; max
		blt.s	2$
		move.w	d3,d1
2$:
oneDBF:
		dbf	d0,oneLoop
d345 16
d363 11
a373 5
oneUnknownChar:
		move.b	d4,d6
		sub.b	d5,d6
		addq	#1,d6
		bra.s	oneHaveChar
d375 16
d399 11
a409 2
*	chars = TextFit(rastport, string, strLen, textExtent, width)
*	d0              a1        a0      d0      a2          d1
d411 29
d441 21
a461 11
clByteLength:
		tst.w	d4
		bne.s	clFixedLength
		lsr.l	#3,d1
clReturnD1:
		cmp.l	d1,d0
		ble.s	clPlentySpace
		move.l	d1,d0
clPlentySpace:
		move.l	(a7)+,d4
		rts
d463 5
a467 7
clFixedLengthAfterAll:
		movem.l	(a7)+,d2-d3/d5-d7/a2
clFixedLength:
		add	tf_XSize(a1),d4
		divu	d4,d1
		ext.l	d1
		bra.s	clReturnD1
d469 63
a531 3
_TextFit:
		move.l	d4,-(a7)
	    ;-- cache spacing and font
d535 12
a546 3
	    ;-- look for special cases
		btst	#FSB_BYTEFONT,tf_Style(a1)
		bne.s	clByteLength
d548 1
a548 1
		beq.s	clFixedLength
a549 21
		movem.l	d2-d3/d5-d7/a2,-(a7)
;
;   d0	decrementing string length
;   d1	width limit
;   d2	incrementing charLength
;   d3	width of charLength
;   d4	rp_TxSpacing + constant tf_CharKern (0) or tf_CharSpace (tf_XSize)
;   d5	tf_HiChar
;   d6	tf_LoChar
;   d7	char index
;   a0	string
;   a1	tf_CharSpace
;   a2	tf_CharKern or tf_CharSpace
;
	    ;-- initialize charLength and currWidth
		moveq	#0,d2
		moveq	#0,d3
	    ;-- initialize loop invariants
		move.b	tf_HiChar(a1),d5
		move.b	tf_LoChar(a1),d6
	    ;-- find kern/space case
d551 4
a554 1
		beq.s	clNoKern
d556 1
a556 4
		move.l	tf_CharSpace(a1),d7
		beq.s	clKern
		move.l	d7,a1
		bra.s	clBothDBF
d558 2
a559 2
	    ;-- kern & no space
clKern:
d561 1
a561 1
		bra.s	clOneDBF
d563 42
d606 1
a606 1
clNoKern:
d608 1
a608 1
		beq.s	clFixedLengthAfterAll
d610 1
a610 1
		bra.s	clOneDBF
d612 43
d656 2
a657 21
clBothLoop:
		add.w	d4,d3
		cmp.w	d1,d3			; max
		bgt.s	clReturnD2
		moveq	#0,d7
		move.b	(a0)+,d7
		cmp.b	d5,d7
		bhi.s	clBothUnknownChar
		sub.b	d6,d7
		bcs.s	clBothUnknownChar
clBothHaveChar:
		add.w	d7,d7
		add.w	0(a2,d7.w),d3
		cmp.w	d1,d3			; max
		bgt.s	clReturnD2
		add.w	0(a1,d7.w),d3
		cmp.w	d1,d3			; max
		bgt.s	clReturnD2
		addq.l	#1,d2
clBothDBF:
		dbf	d0,clBothLoop
d659 72
a730 3
clReturnD2:
		move.l	d2,d0
		movem.l	(a7)+,d2-d3/d5-d7/a2
d733 10
a742 5
clBothUnknownChar:
		move.b	d5,d7
		sub.b	d6,d7
		addq	#1,d7
		bra.s	clBothHaveChar
d744 25
a768 20
	    ;-- kern or space loop
clOneLoop:
		add.w	d4,d3
		cmp.w	d1,d3			; max
		bgt.s	clReturnD2
		moveq	#0,d7
		move.b	(a0)+,d7
		cmp.b	d5,d7
		bhi.s	clOneUnknownChar
		sub.b	d6,d7
		bcs.s	clOneUnknownChar
clOneHaveChar:
		add.w	d7,d7
		add.w	0(a2,d7.w),d3
		cmp.w	d1,d3			; max
		bgt.s	clReturnD2
		addq.l	#1,d2
clOneDBF:
		dbf	d0,clOneLoop
		bra.s	clReturnD2
d770 39
a808 5
clOneUnknownChar:
		move.b	d5,d7
		sub.b	d6,d7
		addq	#1,d7
		bra.s	clOneHaveChar
@


35.3
log
@first cut at TextFit instead of CharFit
@
text
@d1 1
a1 1
	TTL    '$Header: length.asm,v 35.2 88/01/08 13:38:31 kodiak Exp $'
d13 3
d313 1
a313 1
		cmp.w	d1,d0
d325 1
@


35.2
log
@new TextExtent
new CharFit
@
text
@d1 1
a1 1
	TTL    '$Header: length.asm,v 35.1 87/11/11 14:42:52 kodiak Exp $'
d13 4
d41 1
a41 1
	XDEF		_CharFit
d85 1
a85 1
*	TextExtent Text CharFit graphics/text.h graphics/rastport.h
d113 1
a113 1
*	TextLength Text CharFit graphics/text.h graphics/rastport.h
d295 1
a295 1
******* graphics.library/CharFit *************************************
d298 1
a298 1
*	CharFit - count characters that will fit in a given width
d301 2
a302 2
*	chars = CharFit(rastport, string, strLen, width)
*	d0              a1        a0      d0      d1
d324 1
a324 1
_CharFit:
@


35.1
log
@textLength called by write.asm
@
text
@d1 1
a1 1
	TTL    '$Header: length.asm,v 33.0 86/05/17 15:29:39 bart Exp $'
d10 1
a10 1
*   Source Control: $Locker: bart $
d12 4
a15 1
*   $Log: length.asm,v $
d37 1
d39 2
a52 5
*	SHORT length;
*	struct RastPort *rp;
*	stRPTR string;
*	SHORT count;
*
d59 2
a60 1
*	(cp_y is unchanged by Write).
d81 1
a81 1
*	Text graphics/text.h graphics/rastport.h
d84 28
d124 25
d288 145
@


35.0
log
@initial from V34
@
text
@d1 1
a1 1
	TTL    '$Header: length.asm,v 1.1 87/10/19 15:14:27 kodiak Exp $'
a2 11
*								     *
*   Copyright 1985, Commodore-Amiga Inc.   All rights reserved.	     *
*   No part of this program may be reproduced, transmitted,	     *
*   transcribed, stored in retrieval system, or translated into	     *
*   any language or computer language, in any form or by any	     *
*   means, electronic, mechanical, magnetic, optical, chemical,	     *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030				     *
*								     *
**********************************************************************
d4 3
a6 1
*	output length of text string
d8 1
a8 3
*   Source Control
*   --------------
*   $Header: length.asm,v 1.1 87/10/19 15:14:27 kodiak Exp $
d10 1
a10 1
*   $Locker:  $
d12 1
a12 1
*   $Log:	length.asm,v $
d35 1
d49 1
a49 1
*	STRPTR string;
d82 4
a85 9
*	D0	running length
*	D1	decrementing string byte length
*	D2	current character index
*	D3	scratch
*	D4	original length * spacing
*	A0	incrementing string address
*	A1	RastPort
*	A2	Font
*	A3	scratch
d87 18
a104 4
		MOVEM.L D2-D4/A2-A3,-(A7)
*	    ;-- check for null string
		AND.L	#$FFFF,D0
		BEQ.S	labelend
d106 6
a111 2
		MOVE.W	D0,D4
		MULS	rp_TxSpacing(A1),D4
d113 3
a115 2
*	;-- get font
		MOVE.L	rp_Font(A1),A2
d117 4
a120 9
		MOVE.W	D0,D1
		MOVEQ	#0,D0
robString:
		MOVEQ	#0,D2
		MOVE.B	(A0)+,D2    ;get next character in string
		CMP.B	tf_HiChar(A2),D2   ;check character range
		BHI.S	unKnownRC
		SUB.B	tf_LoChar(A2),D2
		BCC.S	knownRC
d122 14
a135 5
*	    ;-- the character code is not in the font, use last char + 1
unKnownRC:
		MOVE.B	tf_HiChar(A2),D2   ;get last character
		SUB.B	tf_LoChar(A2),D2
		ADDQ	#1,D2
d137 8
a144 7
*	    ;-- get start position of character
knownRC:
		ADD.W	D2,D2
		MOVE.L	tf_CharKern(A2),D3
		BEQ.S	noKern
		MOVE.L	D3,A3
		ADD.W	0(A3,D2.W),D0
d146 4
a149 7
		MOVE.L	tf_CharSpace(A2),D3
		BNE.S	propBound
		ADD.W	tf_XSize(A2),D0
		BRA.S	nextRob
propBound:
		MOVE.L	D3,A3
		ADD.W	0(A3,D2.W),D0
d151 4
a154 4
*	;-- test and loop for any more characters
nextRob:
		SUBQ	#1,D1
		BNE.S	robString
d156 2
a157 4
		ADD.W	D4,D0
labelend:
		MOVEM.L (A7)+,D2-D4/A2-A3
		RTS
d159 76
a234 1
		END
@
