head     39.41;
branch   ;
access   ;
symbols  rel39_24:39.38 rel39_18:39.38 rel39_97:39.35 rel39_90:39.33 rel39_89:39.32 rel39_82:39.31 rel39_76:39.28 rel39_71:39.26 rel39_65:39.22 rel39_64:39.21 rel39_61:39.21 rel39_60:39.21 rel39_55:39.19 rel39_52:39.18 rel39_47:39.14 rel39_39:39.12 rel39_38:39.12 rel39_37:39.12 rel39_35:39.11 rel39_34:39.11 V37_30:37.11 V37_29:37.11 V37_28:37.11 V37_27:37.11 V37_25:37.10 V37_24:37.10 V37_23:37.10 V37_22:37.10 V37_21:37.10 V37_20:37.10 V37_19:37.10 V37_18:37.10 V37_17:37.9 V37_15:37.9 V37_14:37.9 V37_13:37.7 V37_12:37.6 V37_11:37.5 V37_10:37.4 V37_9:37.3 V37_8:37.1 V37_7:37.1 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:1.15 V36_208:1.15 V36_207:1.15 V36_205:1.15 V36_203:1.15 V36_202:1.15 V36_201:1.15 V36_200:1.15 V36_199:1.15 V36_198:1.15 V36_196:1.15 V36_195:1.15 V36_194:1.15 V36_193:1.15 V36_192:1.15 V36_191:1.15 V36_190:1.15 V36_189:1.15 V36_188:1.15 V36_187:1.15 V36_186:1.15 V36_185:1.15 V36_184:1.15 V36_183:1.15 V36_182:1.15 V36_181:1.15 V36_180:1.15;
locks    ; strict;
comment  @@;


39.41
date     93.08.11.15.28.20;  author spence;  state Exp;
branches ;
next     39.40;

39.40
date     93.06.16.07.55.00;  author chrisg;  state Exp;
branches ;
next     39.39;

39.39
date     93.05.31.14.37.30;  author chrisg;  state Exp;
branches ;
next     39.38;

39.38
date     93.03.23.11.03.10;  author chrisg;  state Exp;
branches ;
next     39.37;

39.37
date     93.03.12.12.34.52;  author chrisg;  state Exp;
branches ;
next     39.36;

39.36
date     93.03.08.11.15.32;  author chrisg;  state Exp;
branches ;
next     39.35;

39.35
date     92.11.09.16.06.15;  author chrisg;  state Exp;
branches ;
next     39.34;

39.34
date     92.11.09.14.38.09;  author chrisg;  state Exp;
branches ;
next     39.33;

39.33
date     92.09.24.13.35.42;  author chrisg;  state Exp;
branches ;
next     39.32;

39.32
date     92.08.24.12.12.39;  author chrisg;  state Exp;
branches ;
next     39.31;

39.31
date     92.08.11.14.27.38;  author chrisg;  state Exp;
branches ;
next     39.30;

39.30
date     92.08.08.11.11.13;  author chrisg;  state Exp;
branches ;
next     39.29;

39.29
date     92.08.03.11.39.26;  author chrisg;  state Exp;
branches ;
next     39.28;

39.28
date     92.07.21.14.04.29;  author chrisg;  state Exp;
branches ;
next     39.27;

39.27
date     92.07.09.10.06.43;  author chrisg;  state Exp;
branches ;
next     39.26;

39.26
date     92.06.26.10.42.28;  author chrisg;  state Exp;
branches ;
next     39.25;

39.25
date     92.06.19.13.54.19;  author chrisg;  state Exp;
branches ;
next     39.24;

39.24
date     92.06.16.13.20.51;  author chrisg;  state Exp;
branches ;
next     39.23;

39.23
date     92.06.11.14.29.30;  author chrisg;  state Exp;
branches ;
next     39.22;

39.22
date     92.06.09.10.47.07;  author chrisg;  state Exp;
branches ;
next     39.21;

39.21
date     92.05.15.07.51.30;  author chrisg;  state Exp;
branches ;
next     39.20;

39.20
date     92.05.13.11.12.39;  author spence;  state Exp;
branches ;
next     39.19;

39.19
date     92.04.27.14.30.33;  author chrisg;  state Exp;
branches ;
next     39.18;

39.18
date     92.04.10.13.09.59;  author chrisg;  state Exp;
branches ;
next     39.17;

39.17
date     92.04.09.10.05.13;  author chrisg;  state Exp;
branches ;
next     39.16;

39.16
date     92.04.08.16.14.05;  author chrisg;  state Exp;
branches ;
next     39.15;

39.15
date     92.04.06.12.41.06;  author chrisg;  state Exp;
branches ;
next     39.14;

39.14
date     92.04.04.14.34.28;  author chrisg;  state Exp;
branches ;
next     39.13;

39.13
date     92.04.03.16.56.42;  author chrisg;  state Exp;
branches ;
next     39.12;

39.12
date     92.02.26.11.34.11;  author chrisg;  state Exp;
branches ;
next     39.11;

39.11
date     92.02.11.10.26.52;  author spence;  state Exp;
branches ;
next     39.10;

39.10
date     92.01.29.17.02.08;  author chrisg;  state Exp;
branches ;
next     39.9;

39.9
date     91.12.20.15.41.27;  author chrisg;  state Exp;
branches ;
next     39.8;

39.8
date     91.11.26.16.09.45;  author chrisg;  state Exp;
branches ;
next     39.7;

39.7
date     91.11.26.16.02.41;  author chrisg;  state Exp;
branches ;
next     39.6;

39.6
date     91.11.15.11.02.22;  author chrisg;  state Exp;
branches ;
next     39.5;

39.5
date     91.10.30.19.13.32;  author spence;  state Exp;
branches ;
next     39.4;

39.4
date     91.10.30.15.49.43;  author chrisg;  state Exp;
branches ;
next     39.3;

39.3
date     91.10.28.11.48.44;  author chrisg;  state Exp;
branches ;
next     39.2;

39.2
date     91.10.15.15.49.39;  author chrisg;  state Exp;
branches ;
next     39.1;

39.1
date     91.10.10.09.46.17;  author chrisg;  state Exp;
branches ;
next     39.0;

39.0
date     91.09.25.15.16.51;  author chrisg;  state Exp;
branches ;
next     38.0;

38.0
date     91.07.12.16.29.13;  author chrisg;  state Exp;
branches ;
next     37.13;

37.13
date     91.05.02.10.43.37;  author chrisg;  state Exp;
branches ;
next     37.12;

37.12
date     91.05.01.14.41.17;  author chrisg;  state Exp;
branches ;
next     37.11;

37.11
date     91.04.17.14.19.53;  author chrisg;  state Exp;
branches ;
next     37.10;

37.10
date     91.03.01.08.57.22;  author chrisg;  state Exp;
branches ;
next     37.9;

37.9
date     91.02.12.17.48.15;  author spence;  state Exp;
branches ;
next     37.8;

37.8
date     91.02.12.16.27.10;  author chrisg;  state Exp;
branches ;
next     37.7;

37.7
date     91.02.08.15.52.00;  author spence;  state Exp;
branches ;
next     37.6;

37.6
date     91.02.07.16.23.20;  author spence;  state Exp;
branches ;
next     37.5;

37.5
date     91.02.01.08.48.54;  author bart;  state Exp;
branches ;
next     37.4;

37.4
date     91.01.31.17.32.57;  author spence;  state Exp;
branches ;
next     37.3;

37.3
date     91.01.31.12.32.30;  author bart;  state Exp;
branches ;
next     37.2;

37.2
date     91.01.31.09.49.40;  author bart;  state Exp;
branches ;
next     37.1;

37.1
date     91.01.30.13.09.28;  author spence;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.26.27;  author spence;  state Exp;
branches ;
next     1.15;

1.15
date     90.08.24.11.28.45;  author bart;  state Exp;
branches ;
next     1.14;

1.14
date     90.03.27.16.27.51;  author bart;  state Exp;
branches ;
next     1.13;

1.13
date     90.03.02.09.48.14;  author bart;  state Exp;
branches ;
next     1.12;

1.12
date     89.04.14.16.03.20;  author bart;  state Exp;
branches ;
next     1.11;

1.11
date     89.03.10.15.50.46;  author bart;  state Exp;
branches ;
next     1.10;

1.10
date     89.03.10.14.47.33;  author bart;  state Exp;
branches ;
next     1.9;

1.9
date     89.03.09.15.59.06;  author bart;  state Exp;
branches ;
next     1.8;

1.8
date     89.02.23.11.09.09;  author bart;  state Exp;
branches ;
next     1.7;

1.7
date     89.02.14.18.24.03;  author bart;  state Exp;
branches ;
next     1.6;

1.6
date     89.02.14.10.08.59;  author bart;  state Exp;
branches ;
next     1.5;

1.5
date     89.02.01.17.53.52;  author bart;  state Exp;
branches ;
next     1.4;

1.4
date     89.01.13.12.39.48;  author bart;  state Exp;
branches ;
next     1.3;

1.3
date     88.10.31.10.17.20;  author bart;  state Exp;
branches ;
next     1.2;

1.2
date     88.05.03.15.29.19;  author dale;  state Exp;
branches ;
next     1.1;

1.1
date     88.05.01.15.38.06;  author dale;  state Exp;
branches ;
next     ;


desc
@@


39.41
log
@es_SIZEOF -> ExtSprite_SIZEOF
@
text
@*******************************************************************************
*
*	$Id: simplesprites.asm,v 39.40 93/06/16 07:55:00 chrisg Exp Locker: spence $
*
*******************************************************************************

	include	'exec/types.i'
	include	'exec/ables.i'
	include	'/gfxbase.i'
	include	'/view.i'
	include	'/sprite.i'
	include	'/monitor.i'
	include	'/macros.i'
	include	'/copper.i'
	include	'/gels/gelsinternal.i'
	include	'/vp_internal.i'
	include 'hardware/intbits.i'
	include 'hardware/dmabits.i'
	include	'exec/memory.i'

	xref	_LVOPermit,_LVOObtainSemaphore,_LVOReleaseSemaphore,_LVOGetTagData
	xref	_LVOAllocMem,_LVOAllocVec,_LVOFreeMem,_LVOFreeVec
	xref	_LVONextTagItem,_LVOMoveSprite

	xref	_pokevp

get_sprite_fmode:
; ret d0=fmodebits(spritewidth)
; based on the AA machine's memory architecture, get the fmode bits to display
; a sprite of a given width.
	subq	#1,d0
	beq.s	got_bits	; 1->0
	subq	#1,d0		; 2x?
	bne.s	is_4x
; must be 2x
	moveq	#0,d0
	move.b	gb_MemType(a6),d0
	cmp.b	#BANDWIDTH_4X,d0
	bne.s	got_bits
	moveq	#(BANDWIDTH_2XNML<<2),d0
	rts
is_4x:	moveq	#(BANDWIDTH_4X<<2),d0		; 4x!
got_bits:
	rts

do_nothing:
	tst.w	d0
	rts

change_sprite_width:
; for non-aa systems this should not be called with a width other than 1.
; entr d0=width exit d0=width or 0 for failure. flags reflect d0.
; trashes d0/d1/a0/a1
; d1=sprite number.
; it's ok to change the sprite width iff:
; bitclear(gb_SpriteReserved-gb_SoftSprites,snum)==0
; if (width != gb_SpriteWidth) then
;  gb_SpriteWidth=width;
;  blank soft sprites
;  poke all fmodes in the copper list to the new width
;  call GfxBase->WidthChangedVector
; endif
	cmp.w	gb_SpriteWidth(a6),d0
	beq.s	do_nothing
	move.l	d2,-(a7)
	move.b	gb_SpriteReserved(a6),d2
	sub.b	gb_SoftSprites(a6),d2
	tst.w	d1
	bmi.s	no_clr
	bclr.b	d1,d2
no_clr:
	tst.b	d2
	beq.s	ok_to_change
	moveq	#0,d0
	move.l	(a7)+,d2
	rts
ok_to_change:
; now, blank soft sprites in copinit
	move.l	(a7)+,d2
	move.w	d0,gb_SpriteWidth(a6)
	move.l	a6,-(a7)
	move.l	gb_ActiViewCprSemaphore(a6),a0
	move.l	gb_ExecBase(a6),a6
	jsr	_LVOObtainSemaphore(a6)
	move.l	(a7)+,a6
	move.l	gb_copinit(a6),a0
	lea	copinit_sprstop(a0),a1
	lea	copinit_sprstrtup+2(a0),a0
	move.l	d1,-(a7)	; save sprite nunber
	moveq	#0,d1
ss_lp	btst.b	d1,gb_SoftSprites(a6)
	beq.s	noblank
	bset.b	d1,gb_SprMoveDisable(a6)
	move.w	(a1),(a0)
	move.w	2(a1),4(a0)
noblank:
	lea	8(a0),a0
	addq	#1,d1
	cmp	#8,d1
	bne.s	ss_lp
	bsr	get_sprite_fmode	; width -> fmode bits
	move.w	d0,gb_SpriteFMode(a6)
; poke fmode in copinit:
	move.l	gb_copinit(a6),a0
	move.w	copinit_fm0+2(a0),d1
	and.w	#$fff3,d1
	or.w	d0,d1
	move.w	d1,copinit_fm0+2(a0)

; now, do the horrible part.
; v=active view
; for ( each viewport in v)
;  poke the intermediate copper instruction's fmode
; poke the view's copper list fmode bits.
; it might be a good idea to poke the posctl words to be invisible
; when blanking soft sprites ?!?

	move.l	gb_ActiView(a6),d1
	beq.s	done_viewport_copins
	move.l	d1,a0
	move.l	v_ViewPort(a0),a0
vp_loop	cmp	#0,a0
	beq.s	done_viewport_copins
	movem.l	d0/d2/a0,-(a7)
	move.w	d0,d1				; new fmode
	move.w	#fmode,d0
	moveq	#$c,d2				; mask
	bsr	_pokevp
	movem.l	(a7)+,d0/d2/a0
end_vp_loop:
	move.l	vp_Next(a0),a0
	bra.s	vp_loop

done_viewport_copins:
	move.l	(a7)+,d1	; restore sprite number
	move.l	a6,-(a7)
	move.l	gb_ActiViewCprSemaphore(a6),a0
	move.l	gb_ExecBase(a6),a6
	jsr	_LVOReleaseSemaphore(a6)
	move.l	(a7)+,a6
	moveq	#-1,d0

tweak_intuition:
; trashes a0,a1
; preserves d0
	tst.b	d1
	bmi.s	yes_tweak
	btst.b	d1,gb_SoftSprites(a6)	; was a softsprite changed?
	bne.s	notweak
yes_tweak:
	move.l	d0,-(a7)
	move.l	gb_IVector(a6),d0
	beq.s	1$
	move.l	d0,a0
	move.l	gb_IData(a6),a1
	jsr	(a0)
1$:	move.l	(a7)+,d0
notweak:
	rts


******* graphics.library/GetExtSpriteA *************************************
*
*   NAME
*	GetExtSpriteA -- Attempt to get a sprite for the extended sprite
*					 manager. (V39)
*	GetExtSprite -- varargs stub for GetExtSpriteA. (V39)
*
*   SYNOPSIS
*	Sprite_Number = GetExtSpriteA( sprite, tags )
*	    d0			        a2      a1
*
*	LONG GetExtSpriteA( struct ExtSprite *, struct TagItem * );
*
*	spritenum=GetExtSprite(sprite,tags,...);
*
*   FUNCTION
*	Attempt to allocate one of the eight sprites for private use
*	with the extended sprite manager. 
*
*   INPUTS
*	sprite - ptr to programmer's ExtSprite (from AllocSpriteData()).
*	tags - a standard tag list:
*
*		GSTAG_SPRITE_NUM	specifies a specific sprite to get by number.
*		
*		GSTAG_ATTACHED specifies that you wish to get a sprite pair.
*			the tag data field points to a ExtSprite structure
*			for the second sprite. You must free both sprites.
*
*
*   RESULTS
*	Sprite_number = a sprite number or -1 for an error.
*		This call will fail if no sprites could be allocated, or
*		if you try to allocate a sprite which would require
*		a mode change when there are other sprites of incompatible
*		modes in use.
*
*   BUGS
*
*	GSTAG_ATTACHED does not work in version 39. When running under V39,
*	you should attach the second sprite with a separate GetExtSprite call.
*
*   SEE ALSO
*	FreeSprite() ChangeSprite() MoveSprite() GetSprite() graphics/sprite.h
*
*********************************************************************

TEMP_SIZE	set	0
	LONGVAR	spriteatt	; pointer to attached data or 0
	LONGVAR	tstate		; for NextTagItem
	WORDVAR	spritenum	; number or -1
	WORDVAR	spriteflags	; flags bit 0=softsprite
	
_GetExtSpriteA::
	movem.l	a2-a5,-(a7)
	ALLOCLOCALS
	clr.l	spriteatt_l(a7)
	move.w	#-1,spritenum_w(a7)
	clr.w	spriteflags_w(a7)
	move.l	a1,tstate_l(a7)
	move.l	a6,a5
	move.l	gb_UtilBase(a6),a6
gst_tag_loop:
	lea	tstate_l(a7),a0
	jsr	_LVONextTagItem(a6)		; d0=next tag item, tstate updated
	tst.l	d0
	beq.s	gst_donetags
	move.l	d0,a0
	move.l	4(a0),d1
	move.l	(a0),d0
	sub.l	#GSTAG_SPRITE_NUM,d0
	bne.s	gst_not_snum
	move.w	d1,spritenum_w(a7)
gst_not_snum:
	subq.l	#2,d0
	bne.s	gst_not_att
	move.l	d1,spriteatt_l(a7)
gst_not_att:
	subq.l	#2,d0
	bne.s	not_softsprite
	tst.l	d1
	beq.s	not_softsprite
	bset.b	#0,spriteflags_w+1(a7)
not_softsprite:
	sub.l	#GSTAG_SCANDOUBLED-GSTAG_SOFTSPRITE,d0
	bne.s	not_sdbl
	tst.l	d1
	beq.s	not_sdbl
	bset	#1,spriteflags_w+1(a7)
not_sdbl:
	bra.s	gst_tag_loop
gst_donetags:
; now, all tags are parsed
; now, check stuff!
; is width available on this system?
	move.l	gb_ExecBase(a5),a6
	FORBID	a6,NOFETCH
	move.w	es_wordwidth(a2),d0
	subq.w	#1,d0				; width=1?
	beq.s	width_ok
	subq.w	#1,d0
	bne.s	is4x
	tst.b	gb_MemType(a5)
	beq	gs_fail
	bra.s	width_ok
is4x:	cmp.w	#2,d0
	bne	gs_fail				; no >4x sprites
	cmp.b	#3,gb_MemType(a5)
	bne	gs_fail
width_ok:
; width is ok, let's see if possible to get a sprite of this width
	move.w	es_wordwidth(a2),d0		; get width
	cmp.w	gb_SpriteWidth(a5),d0		; width=cur width?
	beq.s	can_get_width
	move.b	gb_SpriteReserved(a5),d0
	cmp.b	gb_SoftSprites(a5),d0		; any non-intuition sprites allocated?
	bne.s	gs_fail
can_get_width:
	tst.l	spriteatt_l(a7)			; attached sprite
	bne.s	gs_fail				; must add code
	move.w	spritenum_w(a7),d0
	bpl.s	get_specific_sprite1
; user wants next available sprite
	move.b	gb_SpriteReserved(a5),d0
	moveq	#7,d1
1$:	lsr.b	#1,d0
	dbcc	d1,1$
	bcs.s	gs_fail
	moveq	#7,d0
	sub	d1,d0
; now, d0=sprite # to get
get_specific_sprite1:
	and	#7,d0
	btst.b	d0,gb_SpriteReserved(a5)
	bne.s	gs_fail
	move.w	d0,ss_num(a2)
	bset.b	d0,gb_SpriteReserved(a5)
	bset.b	d0,gb_ExtSprites(a5)
	btst	#0,spriteflags_w+1(a7)
	beq.s	no_soft
	bset.b	d0,gb_SoftSprites(a5)
no_soft:
	btst	#1,spriteflags_w+1(a7)
	beq.s	no_dbl1
	bset.b	d0,gb_ScanDoubledSprites(a5)
no_dbl1:
	move.w	es_wordwidth(a2),d0
	move.w	ss_num(a2),d1
	move.l	a5,a6
	bsr	change_sprite_width
	move.l	gb_ExecBase(a6),a3
	PERMIT	a3,NOFETCH
	moveq	#0,d0
	move.w	ss_num(a2),d0
exit1:
	add.l	#TEMP_SIZE,a7
	movem.l	(a7)+,a2-a5
	rts
gs_fail:
	PERMIT
	move.l	a5,a6
	moveq	#-1,d0
	bra.s	exit1

******* graphics.library/FreeSpriteData **************************************
*
*   NAME
*	FreeSpriteData -- free sprite data allocated by AllocSpriteData() (V39)
*
*   SYNOPSIS
*	FreeSpriteData(extsp)
*			a2
*
*	void FreeSpriteData(struct ExtSprite *);
*
*
*   FUNCTION
*
*   INPUTS
*	extsp - The extended sprite structure to be freed. Passing NULL is a
*	NO-OP.
*
*   SEE ALSO
*	FreeSpriteData() FreeSprite() ChangeSprite() MoveSprite() GetExtSprite()
*	AllocBitMap() graphics/sprite.h
*
******************************************************************************
_FreeSpriteData::
	cmp.w	#0,a2
	beq.s	fspd_null
	move.l	a6,-(a7)
	move.l	gb_ExecBase(a6),a6
	tst.w	es_flags(a2)
	bne.s	no_free_spdata
	move.l	ss_posctldata(a2),a1
	sub.l	#4,a1
	jsr	_LVOFreeVec(a6)
no_free_spdata
	move.l	a2,a1
	move.l	#ExtSprite_SIZEOF,d0
	jsr	_LVOFreeMem(a6)
	move.l	(a7)+,a6
fspd_null:
	rts



******* graphics.library/AllocSpriteDataA **************************************
*
*   NAME
*	AllocSpriteDataA -- allocate sprite data and convert from a bitmap. (V39)
*	AllocSpriteData -- varargs stub for AllocSpriteData(). (V39)
*
*   SYNOPSIS
*	SpritePtr | 0 = AllocSpriteDataA(bitmap,taglist)
*	 d0	 	                 a2      a1
*
*	struct ExtSprite *AllocSpriteDataA( struct BitMap *, struct TagItem * );
*
*	extsprite=AllocSpriteData(bitmap,tags,...TAG_END)
*
*    FUNCTION
*	Allocate memory to hold a sprite image, and convert the passed-in
*	bitmap data to the appropriate format. The tags allow specification
*	of width, scaling, and other options.
*
*   INPUTS
*	bitmap - ptr to a bitmap. This bitmap provides the source data for the
*		sprite image.
*
*	tags -
*		SPRITEA_Width specifies how many pixels wide you desire
*		the sprite to be. Specifying a width wider than the hardware
*		can handle will cause the function to return failure. If the
*		bitmap passed in is narrower than the width asked for, then
*		it will be padded on the right with transparent pixels.
*		Defaults to 16.
*
*		SPRITEA_XReplication controls the horizontal pixel replication factor
*		used when converting the bitmap data. Valid values are:
*			0 - perform a 1 to 1 conversion
*			1 - each pixel from the source is replicated twice
*			    in the output.
*			2 - each pixel is replicated 4 times.
*		       -1 - skip every other pixel in the source bitmap
*		       -2 - only include every fourth pixel from the source.
*
*			This tag is useful for converting data from one resolution
*		to another. For instance, hi-res bitmap data can be correctly
*		converted for a lo-res sprite by using an x replication factor
*		of -1. Defaults to 0.
*
*		SPRITEA_YReplication controls the vertical pixel replication factor
*		in the same manner as SPRITEA_XReplication controls the horizontal.
*
*		SPRITEA_OutputHeight specifies how tall the resulting sprite
*		should be. Defaults to the bitmap height. The bitmap MUST be at
*		least as tall as the output height.
*
*		SPRITEA_Attached tells the function that you wish to convert
*		the data for the second sprite in an attached sprite pair.
*		This will cause AllocSpriteData() to take its data from the
*		3rd and 4th bitplanes of the passed in bitmap.
*
*
*	Bitplane data is not required to be in chip ram for this function.
*
*
*   RESULTS
*	SpritePtr = a pointer to a ExtSprite structure, or 0 if there is
*	a failure. You should pass this pointer to FreeSpriteData() when finished
*	with the sprite.
*
*   BUGS
*		Under V39, the appropriate attach bits would not be set in the sprite 
*	data.
*		The work-around is to set the bits manually. Bit 7 of the second
*	word should be set. On a 32 bit sprite, bit 7 of the 3rd word should 
*	also be set. For a 64 bit sprite, bit 7 of the 5th word should also be
*	set. This should NOT be done under V40, as the bug is fixed.
*
*   SEE ALSO
*	FreeSpriteData() FreeSprite() ChangeSprite() MoveSprite() GetExtSpriteA()
*	AllocBitMap() graphics/sprite.h
*
*********************************************************************

; sprite data layout is as follows:
;	1x: pos ctl a b a b pos ctl		high*2+4 words
;	2x: pos x ctl x a a b b pos x ctl x	high*4+8 words
;	4x: pos x x x ctl x x x  a a a a b b b b pos x x x ctl x x x  high*8+16 words
;	so allocsize=high*2*wordwidth+(2<<wordwidth) words


TEMP_SIZE	set	0	; init locals
	LONGVAR	tstate				; tag state for nexttagitem
	WORDVAR	height				; output height
	WORDVAR	wordwidth			; output width
	WORDVAR	hrep				; horizontal repetition factor.
	WORDVAR	vrep				; vertcial repetition factor.
	LONGVAR	vskip				; amount to add to bitplane ptr
						; for each line
	ARRAYVAR tempwords,32			; 16 temp words for scaling.

	WORDVAR	srcwords			; number of words to copy from each line.
	WORDVAR	pstart				; bitplane ptr offset
	LONGVAR	sp_ptr				; pointer to extsprite structure.
	WORDVAR	old_data_flag
	BVAR	attached_flag

_AllocSpriteDataA::
	movem.l	d2-d7/a2-a5,-(a7)
	ALLOCLOCALS
	clr.w	old_data_flag_w(a7)
	move.w	#bm_Planes,pstart_w(a7)
	move.l	a1,tstate_l(a7)
	move.w	bm_Rows(a2),height_w(a7)
	move.w	#1,wordwidth_w(a7)
	clr.w	vrep_w(a7)
	clr.w	hrep_w(a7)
	clr.b	attached_flag_b(a7)
	moveq	#0,d0
	move.w	bm_BytesPerRow(a2),d0
	cmp.w	#UNLIKELY_WORD,bm_Pad(a2)
	bne.s	1$
; it's interleaved
	move.l	bm_Planes+4(a2),d0
	sub.l	bm_Planes(a2),d0
1$:	lsr.l	#1,d0
	move.w	d0,srcwords_w(a7)		; d0= the number of words wide the source is.
	move.l	a6,a5				; save gfxbase
	move.l	gb_UtilBase(a6),a6		; get utiity base
tag_loop:
	lea	tstate_l(a7),a0
	jsr	_LVONextTagItem(a6)		; d0=next tag item, tstate updated
	tst.l	d0
	beq.s	donetags
	move.l	d0,a0
	move.l	4(a0),d1
	move.l	(a0),d0
	sub.l	#SPRITEA_Width,d0
	bne.s	not_spa_width
; it's the width, so round to words and store.
	tst.b	d1
	bne.s	2$
	moveq	#16,d1
2$:
	add.w	#15,d1
	lsr.w	#4,d1
	cmp.w	#3,d1
	bne.s	1$
	moveq	#4,d1
1$:	move.w	d1,wordwidth_w(a7)
not_spa_width:
	subq.l	#2,d0
	bne.s	not_spa_xrep
	move.w	d1,hrep_w(a7)
not_spa_xrep:
	subq.l	#2,d0
	bne.s	not_spa_yrep
	move.w	d1,vrep_w(a7)
not_spa_yrep:
	subq.l	#2,d0
	bne.s	not_spa_oheight
	move.w	d1,height_w(a7)
not_spa_oheight:
	subq.l	#2,d0
	bne.s	not_spa_att
	tst.l	d1
	beq.s	not_spa_att
	move.w	#bm_Planes+8,pstart_w(a7)
	st	attached_flag_b(a7)
not_spa_att:
	subq.l	#2,d0
	bne.s	not_old_fmt
	move.w	d1,old_data_flag_w(a7)
not_old_fmt:
	bra	tag_loop			; ignore bad tags
donetags:
; all tags are done, so let's initialize
; vskip=bytesperrow<<max(0,-vrep)
; vrep=1<<max(0,vrep)
; srcwords=min(srcwords,wordwidth)
	move.w	vrep_w(a7),d0
	neg.w	d0
	bpl.s	1$
	moveq	#0,d0
1$:	moveq	#0,d1
	move.w	bm_BytesPerRow(a2),d1
	tst.w	old_data_flag_w(a7)
	beq.s	not_old1
	moveq	#4,d1
	move.w	#1,srcwords_w(a7)
not_old1:
	lsl.l	d0,d1
	move.l	d1,vskip_l(a7)
	move.w	wordwidth_w(a7),d0
	move.w	hrep_w(a7),d1
	bpl.s	3$
	neg.w	d1
	lsl.w	d1,d0
	bra.s	4$
3$:	lsr.w	d1,d0
	bne.s	4$
	moveq	#1,d0
4$:	cmp.w	srcwords_w(a7),d0
	bhs.s	2$
	move.w	d0,srcwords_w(a7)
2$:
; now, lets do some allocations!
	move.l	gb_ExecBase(a5),a6
	moveq	#0,d1
	move.l	#ExtSprite_SIZEOF,d0
	jsr	_LVOAllocMem(a6)
	move.l	d0,sp_ptr_l(a7)
	beq	failure
	move.l	d0,a3
	move.w	old_data_flag_w(a7),d0
	beq.s	not_old
;	BRA.s	not_old
	tst.w	hrep_w(a7)
	bne.s	not_old
	tst.w	vrep_w(a7)
	bne.s	not_old
	cmp.w	#1,wordwidth_w(a7)
	bne.s	not_old
	move.w	#1,es_wordwidth(a3)
	move.l	a2,ss_posctldata(a3)
	move.w	height_w(a7),ss_height(a3)
	st	es_flags(a3)
	bra	done_term
	
not_old:
; now, lets allocvec the sprite data!
;	so allocsize=high*2*wordwidth+(2<<wordwidth) words+ 1 lword to align
	clr.w	es_flags(a3)
	move.w	wordwidth_w(a7),es_wordwidth(a3)
	move.w	height_w(a7),d0
	move.w	d0,ss_height(a3)
	mulu	wordwidth_w(a7),d0
	add.l	d0,d0				; 2 planes
	moveq	#2,d1
	move.w	wordwidth_w(a7),d2
	lsl.l	d2,d1
	add.l	d1,d0
	add.l	d0,d0				; words->bytes
	add.l	#4,d0
	move.l	#MEMF_CHIP,d1
	jsr	_LVOAllocVec(a6)
	tst.l	d0
	beq	failure
	add.l	#4,d0
	move.l	d0,ss_posctldata(a3)
; now, let's convert it!
; d7=free
	moveq	#0,d7
	tst.b	attached_flag_b(a7)
	beq.s	1$
	bset	#7,d7
1$:
	move.l	d0,a4
	move.l	d7,(a4)+				; clear posctl but may set attached flag
	cmp.w	#2,wordwidth_w(a7)
	blt.s	gotw
	move.w	d7,(a4)+				; maybe another attach bit and clear	
	move.w	d7,(a4)+
	cmp.w	#4,wordwidth_w(a7)
	blt.s	gotw
	move.w	d7,(a4)+
	clr.w	(a4)+
	clr.l	(a4)+
gotw:
; now, a4 is pointing past the position/control data
; point a1=plane 0 data
; 	a2=plane 1 data
	tst.w	old_data_flag_w(a7)
	beq.s	is_bm
	lea	6(a2),a2
	lea	-2(a2),a1
	bra.s	got_ptrs
is_bm:
	add.w	pstart_w(a7),a2
	move.l	(a2)+,a1			; first plane
	move.l	(a2),a2				; second plane

got_ptrs:
	move.w	height_w(a7),d7		; d7=height counter
	add.l	d7,d7				; double becuase of two planes
	bra.s	end_hloop
hloop:						; clear 32 bytes=8 lwords
	lea	tempwords(a7),a0
	clr.l	(a0)+
	clr.l	(a0)+
	clr.l	(a0)+
	clr.l	(a0)+
	clr.l	(a0)+
	clr.l	(a0)+
	clr.l	(a0)+
	clr.l	(a0)+
; now, move source data!
	move.w	srcwords_w(a7),d0
	subq.w	#1,d0
	move.l	a2,d1
	lea	tempwords(a7),a0
1$:	move.w	(a2)+,(a0)+
	dbra	d0,1$
	move.l	d1,a2
; now, one plane of data is in tempwords!
	tst.w	hrep_w(a7)			; scale up or down?
	bpl.s	scale_up_maybe
	bsr	scale_down			; 1/2
	btst	#0,hrep_w+1(a7)			; >-1?
	bne.s	done_scale
	bsr	scale_down
done_scale:
	move.w	wordwidth_w(a7),d0
	subq	#1,d0
	lea	tempwords(a7),a0
mover:
	move.w	(a0)+,(a4)+			; output one word
	dbra	d0,mover
	add.l	vskip_l(a7),a2
end_hloop:
	exg.l	a1,a2				; swap plane ptrs
	dbra	d7,hloop
	clr.l	(a4)+				; clear posctl
	cmp.w	#2,wordwidth_w(a7)
	blt.s	done_term
	clr.l	(a4)+
	cmp.w	#4,wordwidth_w(a7)
	blt.s	done_term
	clr.l	(a4)+
	clr.l	(a4)+
done_term
	move.l	a3,d0
ex1:
	move.l	a5,a6
	lea	TEMP_SIZE(a7),a7
	movem.l	(a7)+,d2-d7/a2-a5
	rts
failure:
	move.l	sp_ptr_l(a7),d0
	beq.s	ex1				; no cleanup, ret val=0
	move.l	d0,a1
	move.l	#ExtSprite_SIZEOF,d0
	jsr	_LVOFreeMem(a6)
	moveq	#0,d0
	bra.s	ex1


scale_up_maybe:
	beq	done_scale
	bsr.s	scale_up
	btst	#1,hrep_w+1(a7)		; could it be 2?
	beq	done_scale
	pea	done_scale(pc)
; fall scale_up	
scale_up:
; pixel magnify the 32 byte array at tempwords+4(a7)
	move.l	a1,d3
	lea	tempwords+4(a7),a0
	lea	-32(a7),a7
	move.l	a7,a1
	move.l	(a0)+,(a1)+
	move.l	(a0)+,(a1)+
	move.l	(a0)+,(a1)+
	move.l	(a0)+,(a1)+
	move.l	(a0)+,(a1)+
	move.l	(a0)+,(a1)+
	move.l	(a0)+,(a1)+
	move.l	(a0)+,(a1)+
	move.l	a7,a1
	lea	-32(a0),a0
	moveq	#15,d0
	moveq	#0,d1
1$:	move.b	(a1),d1
	lsr.b	#4,d1
	move.b	magtbl(pc,d1.w),(a0)+
	move.b	(a1)+,d1
	and.b	#$0f,d1
	move.b	magtbl(pc,d1.w),(a0)+
	dbra	d0,1$
	lea	32(a7),a7
	move.l	d3,a1
	rts

magtbl:
	dc.b	%00000000
	dc.b	%00000011
	dc.b	%00001100
	dc.b	%00001111
	dc.b	%00110000
	dc.b	%00110011
	dc.b	%00111100
	dc.b	%00111111
	dc.b	%11000000
	dc.b	%11000011
	dc.b	%11001100
	dc.b	%11001111
	dc.b	%11110000
	dc.b	%11110011
	dc.b	%11111100
	dc.b	%11111111

scale_down:
; pixel shrink the 32 byte array at tempwords+4(a7)
	moveq	#15,d0
	lea	tempwords+4(a7),a0	; input
	move.l	a1,d3
	move.l	a0,a1			; output
1$:	moveq	#0,d1
	move.w	(a0)+,d2
	add.w	d2,d2
	addx.w	d1,d1
	add.w	d2,d2
	add.w	d2,d2
	addx.w	d1,d1
	add.w	d2,d2
	add.w	d2,d2
	addx.w	d1,d1
	add.w	d2,d2
	add.w	d2,d2
	addx.w	d1,d1
	add.w	d2,d2
	add.w	d2,d2
	addx.w	d1,d1
	add.w	d2,d2
	add.w	d2,d2
	addx.w	d1,d1
	add.w	d2,d2
	add.w	d2,d2
	addx.w	d1,d1
	add.w	d2,d2
	add.w	d2,d2
	addx.w	d1,d1
	add.w	d2,d2
	move.b	d1,(a1)+
	dbra	d0,1$
	clr.l	(a1)+
	clr.l	(a1)+
	clr.l	(a1)+
	clr.l	(a1)+
	move.l	d3,a1
	rts


	xdef    _GetSprite
	xref    _getsprite
******* graphics.library/GetSprite ******************************************
*
*   NAME
*	GetSprite -- Attempt to get a sprite for the simple sprite manager.
*
*   SYNOPSIS
*	Sprite_Number = GetSprite( sprite, pick )
*	    d0			    a0      d0
*
*	WORD GetSprite( struct SimpleSprite *, WORD );
*
*   FUNCTION
*	Attempt to allocate one of the eight sprites for private use
*	with the simple sprite manager. This must be done before using
*	further calls to the simple sprite machine. If the programmer
*	wants to use 15 color sprites, they must allocate both sprites
*	and set the 'SPRITE_ATTACHED' bit in the odd sprite's posctldata
*	array. 
*
*   INPUTS
*	sprite - ptr to programmers SimpleSprite structure.
*	pick - number in the range of 0-7 or
*	  -1 if programmer just wants the next one.
*
*   RESULTS
*	If pick is 0-7 attempt to allocate the sprite. If the sprite
*	is already allocated then return -1.
*	If pick -1 allocate the next sprite starting search at 0.
*	If no sprites are available return -1 and fill -1 in num entry
*	of SimpleSprite structure.
*	If the sprite is available for allocation, mark it allocated
*	and fill in the 'num' entry of the SimpleSprite structure.
*	If successful return the sprite number.
*
*   BUGS
*
*   SEE ALSO
*	FreeSprite() ChangeSprite() MoveSprite() GetSprite() graphics/sprite.h
*
*********************************************************************
_GetSprite:
	move.l	gb_ExecBase(a6),a1
	FORBID	a1,NOFETCH
	movem.l	d0/a0,-(a7)
	moveq	#1,d0
	moveq	#-1,d1
	bsr	change_sprite_width
	tst.w	d0
	movem.l	(a7)+,d0/a0
	beq.s	no_sprite_to_get
	tst.w	d0
	bpl.s	get_specific_sprite
; user wants next available sprite
	move.b	gb_SpriteReserved(a6),d0
	moveq	#7,d1
1$:	lsr.b	#1,d0
	dbcc	d1,1$
	bcs.s	no_sprite_to_get
	moveq	#7,d0
	sub	d1,d0
; now, d0=sprite # to get
get_specific_sprite:
	and	#7,d0
	btst.b	d0,gb_SpriteReserved(a6)
	bne.s	no_sprite_to_get
	bset.b	d0,gb_ScanDoubledSprites(a6)	; those who come in through the old interface
	bset.b	d0,gb_SpriteReserved(a6)		; always get scan-doubled sprites.
	bclr.b	d0,gb_ExtSprites(a6)			; not an extsprite!
got_sp	move.l	gb_ExecBase(a6),a1
	PERMIT	a1,NOFETCH
	move.w	d0,ss_num(a0)
	rts
no_sprite_to_get:
	moveq	#-1,d0
	bra.s	got_sp


	xdef    _FreeSprite

******* graphics.library/FreeSprite ***********************************
*
*   NAME
*       FreeSprite -- Return sprite for use by others and virtual
*					  sprite machine.
*
*   SYNOPSIS
*       FreeSprite( pick )
*                    d0
*
*	void FreeSprite( WORD );
*
*   FUNCTION
*	Mark sprite as available for others to use.
*       These sprite routines are provided to ease sharing of sprite
*	hardware and to handle simple cases of sprite usage and
*	movement.  It is assumed the programs that use these routines
*	do want to be good citizens in their hearts. ie: they will
*	not FreeSprite unless they actually own the sprite.
*	The Virtual Sprite machine may ignore the simple sprite machine.
*
*   INPUTS
*       pick - number in range of 0-7
*
*   RESULTS
*	sprite made available for subsequent callers of GetSprite
*	as well as use by Virtual Sprite Machine.
*
*   BUGS
*
*   SEE ALSO
*       GetSprite() ChangeSprite() MoveSprite() graphics/sprite.h
*
*********************************************************************
_FreeSprite:
	move.l	gb_ExecBase(a6),a1
	FORBID	a1,NOFETCH
	bclr.b	d0,gb_SpriteReserved(a6)
	bclr.b	d0,gb_ExtSprites(a6)
	bclr.b	d0,gb_SoftSprites(a6)
	move.w	d0,d1
	add.w	d1,d1
	add.w	d1,d1
	move.l	gb_SimpleSprites(a6),a0
	add.w	d1,a0
	move.l	(a0),d1
	clr.l	(a0)

; set the sprite to the blank sprite by poking copinit
	move.l	gb_copinit(a6),a0
	lsl.w	#3,d0
	lea	copinit_sprstrtup(a0,d0.w),a1
	move.l	#copinit_sprstop,d0
	add.l	a0,d0
	move.w	d0,6(a1)
	swap	d0
	move.w	d0,2(a1)
; now, see if it is time to switch back to the desired intuition mode
	moveq	#-1,d1
	move.w	gb_DefaultSpriteWidth(a6),d0
	bsr	change_sprite_width		; attempt to change width
	move.l	gb_ExecBase(a6),a1
	PERMIT	a1,NOFETCH	
	rts

******* graphics.library/ChangeExtSpriteA *****************************************
*
*   NAME
*       ChangeExtSpriteA -- Change the sprite image pointer. (V39)
*	ChangeExtSprite  -- varargs stub for ChangeExtSpriteA(). (V39)
*
*   SYNOPSIS
*       ChangeExtSpriteA( vp, oldsprite, newsprite, tags)
*                     	  a0  a1   	 a2	    a3
*
*	success=ChangeExtSpriteA(struct ViewPort *, struct ExtSprite *,
*			struct ExtSprite *, struct TagList *);
* 
*	success=ChangeExtSprite(vp,old_sp,new_sp,tag,....);
*
*   FUNCTION 
*	Attempt to change which sprite is displayed for a given
*	sprite engine.
*
*   INPUTS
*       vp - pointer to ViewPort structure that this sprite is
*		  relative to,  or 0 if relative only top of View
*	oldsprite - pointer the old ExtSprite structure
*	newsprite - pointer to the new ExtSprite structure. 
*
*   RESULTS 
* 	success - 0 if there was an error.
*   BUGS 
* 
*   SEE ALSO
*	FreeSprite() ChangeSprite() MoveSprite() AllocSpriteDataA()
*	graphics/sprite.h
* 
*********************************************************************
TEMP_SIZE	set	0
	LONGVAR	tstate

_ChangeExtSpriteA::
	movem.l	d7/a0-a2/a5-a6,-(a7)
	ALLOCLOCALS
	move.l	a3,tstate_l(a7)
	moveq	#0,d7			; dbl flag
	movem.l	a0/a1/a6,-(a7)
	move.l	gb_UtilBase(a6),a6
cst_tag_loop:
	lea	tstate_l+4*3(a7),a0
	jsr	_LVONextTagItem(a6)
	tst.l	d0
	beq.s	cst_donetags
	move.l	d0,a0
	move.l	4(a0),d1
	move.l	(a0),d0
	sub.l	#GSTAG_SCANDOUBLED,d0
	bne.s	cst_nodbl
	move.l	d1,d7
cst_nodbl:
	bra.s	cst_tag_loop
cst_donetags:
	movem.l	(a7)+,a0/a1/a6

	move.l	gb_ExecBase(a6),a5
	FORBID	a5,NOFETCH
	move.w	es_wordwidth(a2),d0
	move.w	ss_num(a1),d1
	move.l	a1,-(a7)
	bsr	change_sprite_width
	move.l	(a7)+,a1
	tst.l	d0
	bne.s	its_cool
	move.w	ss_num(a1),ss_num(a2)	; should I be dooing this?
 	move.l	a5,a6
	jsr	_LVOPermit(a6)
	lea	TEMP_SIZE(a7),a7
	movem.l	(a7)+,d7/a0-a2/a5-a6
	moveq	#0,d0
	rts
its_cool:
	move.w	ss_num(a1),d0
	bclr.b	d0,gb_SprMoveDisable(a6)
	bclr.b	d0,gb_ScanDoubledSprites(a6)
	tst.l	d7
	beq.s	no_ctsdbl1
	bset.b	d0,gb_ScanDoubledSprites(a6)
no_ctsdbl1:
	move.w	d0,ss_num(a2)
	move.l	a5,a6
	jsr	_LVOPermit(a6)
	lea	TEMP_SIZE(a7),a7
	movem.l	(a7)+,d7/a0-a2/a5-a6
	movem	ss_x(a1),d0/d1
	move.l	a2,a1
	jsr	_LVOMoveSprite(a6)
	moveq	#-1,d0
	rts

	xdef    _ChangeSprite
	xref    _changesprite
******* graphics.library/ChangeSprite ******************************************
*
*   NAME
*       ChangeSprite -- Change the sprite image pointer.
*
*   SYNOPSIS
*       ChangeSprite( vp, s, newdata)
*                     a0  a1   a2
*
*	void ChangeSprite(struct ViewPort *, struct SimpleSprite *, void * )
* 
*   FUNCTION 
*	The sprite image is changed to use the data starting at newdata
*
*   INPUTS
*       vp - pointer to ViewPort structure that this sprite is
*		  relative to,  or 0 if relative only top of View
*	s - pointer to SimpleSprite structure
*	newdata	- pointer to data structure of the following form.
*		struct spriteimage
*		{
*		    UWORD    posctl[2];	/* used by simple sprite machine*/
*		    UWORD    data[height][2];   /* actual sprite image */
*		    UWORD    reserved[2];	/* initialized to */
*			                             /*  0x0,0x0 */
*		};
*	The programmer must initialize reserved[2].  Spriteimage must be
*	in CHIP memory. The height subfield of the SimpleSprite structure
*	must be set to reflect the height of the new spriteimage BEFORE
*	calling ChangeSprite(). The programmer may allocate two sprites to
*	handle a single attached sprite.  After GetSprite(), ChangeSprite(),
*	the programmer can set the SPRITE_ATTACHED bit in posctl[1] of the
*	odd numbered sprite.
*	If you need more than 8 sprites, look up VSprites in the
*	graphics documentation.
*
*   RESULTS 
* 
*   BUGS 
* 
*   SEE ALSO
*	FreeSprite() ChangeSprite() MoveSprite() AddVSprite() graphics/sprite.h
* 
*********************************************************************
_ChangeSprite:
	move.l  a2,ss_posctldata(a1)
	movem.w	ss_x(a1),d0/d1
;	fall MoveSprite

******* graphics.library/MoveSprite ******************************************
*
*   NAME
*	MoveSprite -- Move sprite to a point relative to top of viewport.
*
*   SYNOPSIS
*	MoveSprite(vp, sprite, x, y)
*	           A0  A1      D0 D1
*
*	void MoveSprite(struct ViewPort *,struct SimpleSprite *, WORD, WORD);
*
*   FUNCTION
*	Move sprite image to new place on display.
*
*   INPUTS
*	vp - pointer to ViewPort structure
*	     if vp = 0, sprite is positioned relative to View.
*	sprite - pointer to SimpleSprite structure
*	(x,y)  - new position relative to top of viewport or view.
*
*   RESULTS
*	Calculate the hardware information for the sprite and
*	place it in the posctldata array. During next video display
*	the sprite will appear in new position.
*
*   BUGS
*	Sprites really appear one pixel to the left of the position you specify.
*	This bug affects the apparent display position of the sprite on the
*	screen,	but does not affect the numeric position relative to the
*	viewport or view. This behaviour only applies to SimpleSprites,
*	not to ExtSprites.
*
*
*   SEE ALSO
*	FreeSprite()  ChangeSprite()  GetSprite()  graphics/sprite.h
*
*********************************************************************

	xdef	_MoveSprite

_MoveSprite:
; do necessary pokes and call the movesprite ptr in the vector table
	move.l	a2,-(a7)
	cmp	#0,a0
	beq.s	view_relative_spmove
	move.l	a0,a2
got_vp:	vp_to_vector	a2,vt_MoveSprite,_DefaultMoveSprite(pc)
got_a2:	jsr	(a2)
	move.l	(a7)+,a2
	rts
view_relative_spmove:
	move.l	gb_ActiView(a6),a0
	cmp	#0,a0
	beq.s	goat
	move.l	v_ViewPort(a0),a2
	sub.l	a0,a0
	cmp	#0,a2
	bne.s	got_vp
goat:	lea	_DefaultMoveSprite(pc),a2
	bra.s	got_a2

	xref	_intena
	xdef    _DefaultMoveSprite

_DefaultMoveSprite:

ms_amovesprite:


	move.w	d0,ss_x(a1)
	move.w	d1,ss_y(a1)
	movem.l	d2-d7/a2-a4,-(sp)	; preserve registers
	move.w	ss_num(a1),d6
	btst.b	d6,gb_SprMoveDisable(a6)
	bne	moves_exit
	move.w	gb_SpriteWidth(a6),d6		; d6=sprite width in words

got_spritesize:
	move.l	a0,a2		  	; viewport pointer
	move.l	a1,a3		  	; simplesprite pointer
	move.l	ss_x(a3),d2	  	; x in d2 high, y in d2 low

;   safe to call self after this point

ms_safe: 
	move.l	gb_ActiView(a6),d3
	beq	ms_arts
	move.l	d3,a0

ms_view:
 
	move.l	v_DyOffset(a0),d3 
	add.w	d3,d3
	add.w	d3,d3			; convert to superhires
	swap	d3 		  	; startx in d3 high, starty in d3 low

ms_check_attached:

	move.l	gb_SimpleSprites(a6),a4 ; ns
	move.w	ss_num(a3),d4
	add.w	d4,d4			; convert sprite num
	move.w	d4,d5			; needed later
	add.w	d4,d4			; to longword offset
	move.l	a3,0(a4,d4.w)	 	; ns[num] = s;

; check for sprite attached
	btst	#1,d5			; odd sp?
	bne.s	ms_not_attached
	move.l	4(a4,d4.w),d0
	beq.s	ms_not_attached		; not attached if ss[n+1]==0
	move.l	d0,a0
	move.l	ss_posctldata(a0),a0
	btst	#7,3(a0)		; attach bit set?
	beq.s	ms_not_attached

	move.l	a2,a0		 	; viewport
	move.l	d0,a1	      		; attached simplesprite!
	move.w	ss_x(a3),d0
	move.w	ss_y(a3),d1
	ext.l	d0
	ext.l	d1
	bsr	ms_amovesprite		; assembly direct
ms_not_attached:

	move.l	ss_posctldata(a3),a1	; k = s->posctldata
	move.l	a1,d0			
	beq	ms_arts

	moveq.l	#0,d4			; 140 ns scrolling

	move.l	a2,-(sp)		; viewport?
	bne.s	ms_yesvp
	swap	d2
	add.w	d2,d2
	add.w	d2,d2
	swap	d2
	bra.s	ms_novp	; was short

ms_yesvp:
;   move.w	vp_Modes(a2),d0 ; don't use vp->Modes directly for 1.4

	xref	_new_mode
	jsr	_new_mode
;	move.l	d0,(sp)			; remember to pop from stack after clipping sprite

	move.l	ss_posctldata(a3),a1	; reload k after "C" call
	move.l	vp_DxOffset(a2),d1	; dxoffset in d1 high, dyoffset in d1 low

	add.w	d1,d2			; y += vp->DyOffset -- greater accuracy
	btst	#3,d0
	beq.s	no_double
	add.w	d2,d2
no_double:

	btst.l	#5,d0
	beq.s	ms_nosuper
	bclr.l	#15,d0

ms_nosuper:
	btst.l	#2,d0
	beq.s	ms_nolace
	asr.w	#1,d2			; y >>= 1

ms_nolace: 
	swap	d1			; vp->dxoffset now in d1 low
	swap	d2 			; will have to swap this back later	
	swap	d3 			; will have to swap this back later	

	add.w	d1,d2			; x += vp->DxOffset -- greater accuracy

	btst	#5,d0
	bne.s	shifted_x
	add.w	d2,d2
	btst	#15,d0
	bne.s	shifted_x
	add.w	d2,d2
shifted_x:
; now have scroll value in superhires pixels
; now, if ECS, then we must clear the 35ns bit and 70ns unless we are shires
	btst	#GFXB_AA_LISA,gb_ChipRevBits0(a6)
	bne.s	ms_swapback
	bclr	#0,d2		; clear 35ns bit
	btst	#5,d0		; shres
	bne.s	ms_swapback
	bclr	#1,d2		; clear 70ns bit
	

ms_swapback:
	move.w	ss_num(a3),d1
	btst	d1,gb_ExtSprites(a6)	; is it an ExtSprite?
	beq.s	no_fixbug
	subq.w	#4,d2					; if so, no off-by-1 bug!

no_fixbug:	swap	d2 			; swap this back now
	swap	d3		 	; swap this back now

ms_novp: 
	add	#4,sp
	add.w	d2,d3			; starty += y;
	move.w	d3,d2

	move.w	#21,d1			; outdated - presupposes NTSC - bart 

	move.l	gb_current_monitor(a6),d0 ; fetch correct min_row instead - bart
	beq.s	ms_nomspc
	move.l	d0,a0
	move.w	ms_min_row(a0),d1
	btst	#GFXB_AA_MLISA,gb_ChipRevBits0(a6)
	bne.s	ms_nomspc
	btst	#MSB_REQUEST_SPECIAL,ms_Flags+1(a0)
	beq.s	ms_nomspc
	addq.w	#1,d1

ms_nomspc:
	sub.w	d1,d2 
	bge.s	ms_noclip
	sub.w	d2,d3			; starty = MAX(21,starty);
ms_noclip:
	move.w	d3,d1		        ; starty for jam
	swap	d2
	swap	d3
	add.w	d2,d3			; startx += x;
	add.w	ss_height(a3),d1	; stopy for jam

ms_check_wrap:
	cmp.w	#2048,d0
	blo.s	no_satur
	move.w	#2047,d0
no_satur:

	moveq.l	#0,d0			; build jam in d0

ms_jamhigh: 
	lsr.w	#1,d3			; (startx>>1)
	bcc.s	no_35ns
	bset	#3,d0
no_35ns:
	lsr.w	#1,d3
	bcc.s	no_70ns
	bset	#4,d0
no_70ns:
	lsr.w	#1,d3
	bcc.s	no_140ns
	addq.w	#1,d0
no_140ns:
	move.b	d3,d2 			; ((startx>>1)&0xff)
	swap	d0			; (startx & 1) in upper word, zero in lower word
	swap	d3			; starty now in lower word
	move.w	d3,d0
	lsl.w	#8,d0			; (starty<<8)
	move.b	d2,d0   		; (starty<<8)|((startx>>1)&0xff) in lower word
	btst	#MSB_DOUBLE_SPRITES,gb_MonitorFlags+1(a6)	; not set in ECS.
	beq.s	no_sdbl
	move.b	ss_num+1(a3),d2
	btst	d2,gb_ScanDoubledSprites(a6)
	beq.s	no_sdbl
	add.w	ss_height(a3),d1	; double height
	bset	#7,d0

no_sdbl:	
	swap	d0			; upper word of jam is now finished
ms_jamlow: 

	move.b	3(a1),d2
	and.b	#$80,d2			; sprite attached?
	or.b	d2,d0
	btst.l	#8,d3
	beq.s	no_sv8
	bset	#2,d0

no_sv8:
	btst.l	#9,d3
	beq.s	no_sv9
	bset	#6,d0

no_sv9:
	move.b	d1,d2			; stopy low byte
	lsl.w	#8,d2
	or.w	d2,d0			; ((stopy&0xff)<<8)
	btst.l	#8,d1
	beq.s	no_ev8
	bset	#1,d0

no_ev8:
	btst.l	#9,d1
	beq.s	no_ev9
	bset	#5,d0

no_ev9:

	move.w	#3,d1
	move.w	#2,d2
	sub.w	d4,d2
	lsr.w	d2,d1
	beq.s	ms_jammit
	and.w	ss_x(a3),d1
	add.w	#3,d2
	lsl.w	d2,d1
	or.w	d1,d0

ms_jammit:

	include 'hardware/custom.i'

	xref	_custom
	xref	_LVODisable
	xref	_LVOEnable

FIRST_SPRITE_DMA	equ	$18	; end of first sprite dma slot
LAST_SPRITE_DMA	equ	$34		; end of last sprite dma slot

	btst	#GFXB_AA_LISA,gb_ChipRevBits0(a6)
	bne.s	no_zero_ecs_bits
	and.w	#$ffff-$18,d0	; zero low order hpos bits
no_zero_ecs_bits:
	moveq	#LAST_SPRITE_DMA,d2
	move.l	a5,-(sp)
	move.l	d0,d4
	move.l	a1,a5
	lea	_custom+vhposr,a4	; for beam pos check code below
	move.l	gb_ExecBase(a6),a0
	DISABLE	a0,NOFETCH
	move.w	(a4),d1			; horizontal pos in d1:8
	cmp.b	d2,d1
	bhi.s	do_jammit		; after sprite dma slots
	moveq	#FIRST_SPRITE_DMA,d2
	add.b	d5,d2			; 4 slots per sprite (from above)
1$:
	move.w	(a4),d1			; horizontal pos in d1:8
	cmp.b	d2,d1
	bls.s	1$			; busy wait until after this sprite's slot (Yeuchh!)
do_jammit:
; d6=sprite size
	move.l	d4,(a5)			; jam that sucker!	
	btst	#0,d6
	bne.s	done_jammit
	btst	#2,d6
	beq.s	sprite_2x
	addq	#4,a5
sprite_2x:
	move.w	d4,4(a5)
done_jammit:
	ENABLE	a0,NOFETCH
	move.l	(sp)+,a5
	
; now, 
; if viewport relative then
;   if  (vp->Modes & VP_HIDE)
;    or (vp->DHeight < spritey)
;    or (y>>lace) + shheight <0
;	then make it disappear
;  else
;	make it appear
;

; a2=viewport (if any)
; a3=simplesprite

ms_arts:
	move.l	gb_copinit(a6),a0
	lea	copinit_sprstrtup(a0),a0
	move.w	ss_num(a3),d0
	add.w	d0,d0
	add.w	d0,d0			; do=sprite#*4
	move	d0,d2
	add.w	d2,d2			; now (a0,d2) points at copins

	cmp	#0,a2
	beq.s	make_them_appear
	btst.b	#5,vp_Modes(a2)		; VP_HIDE?
	bne.s	make_them_disappear
	move.w	ss_y(a3),d1		; spritey
	cmp.w	vp_DHeight(a2),d1	; y>high
	bgt.s	make_them_disappear
	btst	#2,vp_Modes+1(a2)	; lace?
	beq.s	nolace
	asr.w	#1,d1
nolace	add.w	ss_height(a3),d1	; high+y
	bpl.s	make_them_appear

make_them_disappear:
; now, poke copinit
	lea	copinit_sprstop-copinit_sprstrtup(a0),a1
	move.w	copinit_sprstop-copinit_sprstrtup+2(a0),d7
	move.l	a1,d6
	move.w	d6,d7
	swap	d6


	move.w	d6,2(a0,d2.w)
	move.w	d7,6(a0,d2.w)

	btst	#2,d0			; odd sprite? can't be attached
	bne.s	moves_exit
	move.l	gb_SimpleSprites(a6),a1
	move.l	4(a1,d0.w),d1
	beq.s	moves_exit		; not attached if ss ptr=nil
	move.l	d1,a1
	move.l	ss_posctldata(a1),a1
	btst	#7,3(a1)		; attach bit set?
	beq.s	moves_exit
	move.w	d6,10(a0,d2.w)
	move.w	d7,14(a0,d2.w)
moves_exit:
	movem.l	(sp)+,d2-d7/a2-a4	; restore registers
	rts

make_them_appear:
; now, poke copinit
	move.l	ss_posctldata(a3),d7
	move.w	d7,6(a0,d2.w)
	swap	d7
	move.w	d7,2(a0,d2.w)

	btst	#2,d0			; odd sprite? can't be attached
	bne.s	moves_exit
	move.l	gb_SimpleSprites(a6),a1
	move.l	4(a1,d0.w),d1
	beq.s	moves_exit		; not attached if ss ptr=nil
	move.l	d1,a1
	move.l	ss_posctldata(a1),a1
	btst	#7,3(a1)		; attach bit set?
	beq.s	moves_exit
	move.l	a1,d6
	move.w	d6,14(a0,d2.w)
	swap	d6
	move.w	d6,10(a0,d2.w)
	movem.l	(sp)+,d2-d7/a2-a4	; restore registers
	rts

	end
@


39.40
log
@autodoc.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.39 93/05/31 14:37:30 chrisg Exp Locker: chrisg $
d361 1
a361 1
	move.l	#es_SIZEOF,d0
d574 1
a574 1
	move.l	#es_SIZEOF,d0
d706 1
a706 1
	move.l	#es_SIZEOF,d0
@


39.39
log
@massive fixes to includes & autodocs.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.38 93/03/23 11:03:10 chrisg Exp Locker: chrisg $
d170 1
a170 1
*	Sprite_Number = GetExtSpriteA( sprite, tags )  (V39)
d958 1
@


39.38
log
@autodoc.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.37 93/03/12 12:34:52 chrisg Exp Locker: chrisg $
d182 1
a182 1
*	sprite - ptr to programmers SimpleSprite structure.
@


39.37
log
@fixed setting attach bit.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.36 93/03/08 11:15:32 chrisg Exp Locker: chrisg $
d185 1
a185 1
*		STAG_SPRITE_NUM	specifies a specific sprite to get by number.
d187 1
a187 1
*		STAG_ATTACHED specifies that you wish to get a sprite pair.
d201 1
a201 1
*	STAG_ATTACHED does not work in version 39. When running under V39,
@


39.36
log
@autodoc
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.35 92/11/09 16:06:15 chrisg Exp Locker: chrisg $
d202 1
a202 2
*	you should attach the second sprite with a separate GetExtSprite call,
*	and set the attached bit in the sprite position-control data.
d436 6
d470 1
d482 1
d533 1
d616 6
d623 1
a623 1
	clr.l	(a4)+				; clear posctl
d626 2
a627 1
	clr.l	(a4)+		
d630 2
a631 1
	clr.l	(a4)+
@


39.35
log
@fixed trash of d0 in previous fix :-(.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.34 92/11/09 14:38:09 chrisg Exp Locker: chrisg $
d960 1
a960 4
*	newsprite - pointer to the new ExtSprite structure. If successful,
*			you should pass this pointer to FreeSprite when done
*			with the sprite engine.
*	
@


39.34
log
@fixed enforcer hit when actiview=0
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.33 92/09/24 13:35:42 chrisg Exp Locker: chrisg $
d118 1
a118 1
	move.l	gb_ActiView(a6),d0
d120 1
a120 1
	move.l	d0,a0
@


39.33
log
@autodoc
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.32 92/08/24 12:12:39 chrisg Exp Locker: chrisg $
d118 3
a120 1
	move.l	gb_ActiView(a6),a0
@


39.32
log
@limit against min_row instead of min_row-1.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.31 92/08/11 14:27:38 chrisg Exp Locker: chrisg $
d160 1
a160 1
******* graphics.library/GetExtSprite **************************************
d164 2
a165 2
*					 manager.
*	GetExtSprite  -- varargs stub for GetExtSpriteA.
d199 4
d328 1
a328 1
*	FreeSpriteData  - free sprite data allocated by AllocSpriteData()
d331 1
a331 1
*	FreeSpriteData(extsp) (V39)
d345 1
a345 1
*	AllocBitMap()graphics/sprite.h
d368 1
a368 1
******* graphics.library/AllocSpriteData **************************************
d371 2
a372 2
*	AllocSpriteDataA - allocate sprite data and convert it from a bitmap.
*	AllocSpriteData  - varargs stub for AllocSpriteData().
d375 1
a375 1
*	SpritePtr | 0 = AllocSpriteDataA(bitmap,taglist)  (V39)
d437 2
a438 2
*	FreeSpriteData() FreeSprite() ChangeSprite() MoveSprite() GetExtSprite() AllocBitMap()
*	graphics/sprite.h
d795 1
a795 2
*	GetSprite -- Attempt to get a sprite for the simple sprite
*					 manager.
d801 1
a801 1
*	SHORT GetSprite( struct SimpleSprite *, SHORT );
d871 1
a871 1
******* graphics.library/FreeSprite ******************************************
d936 1
a936 1
******* graphics.library/ChangeExtSprite ******************************************
d939 1
a939 1
*       ChangeExtSpriteA -- Change the sprite image pointer.
d968 1
a968 1
*	FreeSprite() ChangeSprite() MoveSprite() AllocSpriteData()
d1291 5
a1295 4
;	move.w	ms_Flags(a0),d0
;	and.w	#MSF_REQUEST_SPECIAL,d0	huh?
;	beq.s	ms_nomspc
;	addq.w	#1,d1
@


39.31
log
@removed brain-dead wrap code.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.30 92/08/08 11:11:13 chrisg Exp Locker: chrisg $
d1288 4
a1291 4
	move.w	ms_Flags(a0),d0
	and.w	#MSF_REQUEST_SPECIAL,d0
	beq.s	ms_nomspc
	addq.w	#1,d1
@


39.30
log
@ExtSprites ar eno longer off by 140ns!
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.29 92/08/03 11:39:26 chrisg Exp Locker: chrisg $
d1305 4
a1308 14
	move.w	d3,d0			; startx
	move.w	gb_MaxDisplayColumn(a6),d7
	add.w	d7,d7
	add.w	d7,d7
	sub.w	d7,d0
	ble.s	ms_no_wrap
	sub.w	#9*4,d0
	bgt.s	ms_no_wrap

ms_sprite_wrap:
	addq.w	#8,d0			; startx -= (GB->MaxDisplayColumn-1);
	move.w	d0,d3

ms_no_wrap:
@


39.29
log
@made not blank intuition sprite when intuition calls me
used right execbase after change_sprite_width call in GetSprite!
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.28 92/07/21 14:04:29 chrisg Exp Locker: chrisg $
d294 1
d856 1
d906 1
d1110 2
a1111 1
*	viewport or view.
d1113 1
d1269 6
a1274 1
	swap	d2 			; swap this back now
@


39.28
log
@fixed pointer replication bug. Wrong srcwords if src not interleaved.
handles size=0 ok
frees extsprite when it fails.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.27 92/07/09 10:06:43 chrisg Exp Locker: chrisg $
d89 1
d133 1
d144 5
d156 1
d484 1
a484 1
	beq	donetags
d855 2
a856 1
got_sp	PERMIT	a1,NOFETCH
@


39.27
log
@calls pokevp instead of poking itself when changing spritefmode.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.26 92/06/26 10:42:28 chrisg Exp Locker: chrisg $
d468 2
a469 2
	lsr.l	#1,d0
1$:	move.w	d0,srcwords_w(a7)		; d0= the number of words wide the source is.
d476 1
a476 1
	beq.s	donetags
d483 4
d542 2
d597 1
a597 1
	clr.l	(a4)+
d672 6
a677 1
	moveq	#0,d0			; need to cleanup!
@


39.26
log
@wrong stack offset in changeextsprite.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.25 92/06/19 13:54:19 chrisg Exp Locker: chrisg $
d25 1
d121 6
a126 26
	move.w	vp_Modes(a0),d1
	and.w	#V_VP_HIDE,d1		; do I really need to do this?
	bne.s	end_vp_loop
	move.l	vp_DspIns(a0),d1
	beq.s	end_vp_loop
	move.l	d1,a1
	move.l	cl_CopIns(a1),a1
cins_loop:
	cmp.w	#COPPER_MOVE,ci_OpCode(a1)
	beq.s	is_move_ins
	cmp.w	#COPPER_WAIT,ci_OpCode(a1)
	bne.s	end_vp_loop
	cmp.w	#255,ci_HWaitPos(a1)	; end of list?
	beq.s	end_vp_loop
end_ci_loop:
	lea	ci_SIZEOF(a1),a1
	bra.s	cins_loop
is_move_ins:
	move.w	ci_DestAddr(a1),d1	; is this the one?
	and.w	#$1ff,d1			; STUPID
	cmp.w	#fmode,d1
	bne.s	end_ci_loop
	move.w	ci_DestData(a1),d1
	and.w	#$fff3,d1		; clear both sprite width bits
	or.w	d0,d1
	move.w	d1,ci_DestData(a1)
d130 1
d132 1
a132 9
; now, let's do the hardware copper list
	move.l	gb_ActiView(a6),a0
	move.l	v_LOFCprList(a0),a1
	bsr.s	poke_fmode_a1
	move.l	v_SHFCprList(a0),a1
	cmp	#0,a1
	beq.s	no_shf
	bsr.s	poke_fmode_a1
no_shf:	move.l	a6,-(a7)
a148 20
	rts


poke_fmode_a1:
	tst.l	crl_start(a1)
	beq.s	done_poking_fmode
	move.l	crl_start(a1),a1
iterate:
	cmp.l	#$fffffffe,(a1)
	beq.s	done_poking_fmode
	cmp.w	#fmode,(a1)
	bne.s	do_next_ins
	move.w	2(a1),d1
	and.w	#$fff3,d1		; clear sprite size bits
	or.w	d0,d1
	move.w	d1,2(a1)
do_next_ins:
	lea	4(a1),a1
	bra.s	iterate
done_poking_fmode:
@


39.25
log
@was testing wrong byte of spriteflags_w.
wrong branch.
all sprite-scan-doubling related.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.24 92/06/16 13:20:51 chrisg Exp Locker: chrisg $
d1003 1
a1003 1
	lea	tstate_l(a7),a0
@


39.24
log
@trailing forbid in GetExtSptrite
vp_sprites->vp_hide
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.23 92/06/11 14:29:30 chrisg Exp Locker: chrisg $
d332 1
a332 1
	btst	#0,spriteflags_w(a7)
d334 1
a334 1
	bset.b	d0,gb_SpriteReserved(a5)
d336 1
a336 1
	btst	#1,spriteflags_w(a7)
d1011 1
a1011 1
	beq.s	cst_nodbl
@


39.23
log
@fixed attached tag.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.22 92/06/09 10:47:07 chrisg Exp Locker: chrisg $
d353 2
d1407 1
a1407 1
0
d1475 2
a1476 2
	btst.b	#6,vp_Modes(a2)		; VP_HIDE?
	beq.s	make_them_disappear
d1488 1
a1488 1
	move.l	copinit_sprstop-copinit_sprstrtup(a0),d6
d1490 4
@


39.22
log
@sprite scan-doubling!!!!
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.21 92/05/15 07:51:30 chrisg Exp Locker: chrisg $
d548 2
@


39.21
log
@doesn't set 35/70ns bits unless lisa.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.20 92/05/13 11:12:39 spence Exp Locker: chrisg $
a274 1
	bclr.b	#0,spriteflags_w+1(a7)
d279 6
d303 1
a303 1
	bne.s	gs_fail
d336 4
a480 1

d876 2
a877 1
	bset.b	d0,gb_SpriteReserved(a6)
d988 3
d992 22
a1013 1
	movem.l	a0-a2/a5-a6,-(a7)
d1023 1
a1023 1
	move.w	ss_num(a1),ss_num(a2)
d1026 2
a1027 1
	movem.l	(a7)+,a0-a2/a5-a6
d1033 5
d1041 2
a1042 1
	movem.l	(a7)+,a0-a2/a5-a6
d1353 9
a1362 1

@


39.20
log
@renamed copinit fm0 to copinit_fm0
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.19 92/04/27 14:30:33 chrisg Exp Locker: spence $
d1236 8
@


39.19
log
@ short branches.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.18 92/04/10 13:09:59 chrisg Exp Locker: chrisg $
d103 1
a103 1
	move.w	fm0+2(a0),d1
d106 1
a106 1
	move.w	d1,fm0+2(a0)
@


39.18
log
@ fixes.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.17 92/04/09 10:05:13 chrisg Exp Locker: chrisg $
d153 1
a153 1
	bsr	poke_fmode_a1
d157 1
a157 1
	bsr	poke_fmode_a1
d261 1
a261 1
	beq	gst_donetags
d298 1
a298 1
	bne	gs_fail
d306 1
a306 1
	bne	gs_fail
d309 1
a309 1
	bne	gs_fail				; must add code
d512 1
a512 1
	beq	donetags
d647 1
a647 1
	bra	end_hloop
d668 1
a668 1
	bpl	scale_up_maybe
d706 1
a706 1
	bsr	scale_up
d709 2
a710 4
	bsr	scale_up
	bra	done_scale

	
d1194 1
a1194 1
	bra	ms_novp	; was short
d1414 1
a1414 1
	beq	make_them_appear
@


39.17
log
@ fixed freespritedata.

@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.16 92/04/08 16:14:05 chrisg Exp Locker: chrisg $
d67 2
d70 1
d163 1
d376 1
a376 1
	beq.s	no_free_spdata
a446 8
*		SPRITEA_OldDataFormat tells the system that you wish to convert
*		old-format (non-bitmap) sprite data into an ExtSprite structure.
*		Data converted in this way will not be copied, and will not be
*		freed by FreeSpriteData. This provides a way of converting old
*		simplesprite-type data into an ExtSprite or width 1. If using
*		this tag, you MUST pass in SPRITEA_OutputHeight, and must not
*		specify scaling options.
*
d516 1
a516 1
	sub.l	#$80000000,d0
d521 4
a524 1
	move.w	d1,wordwidth_w(a7)
d558 5
d584 1
a584 1
	move.w	old_data_flag_w(a7),es_flags(a3)
d586 7
d595 2
d602 1
d634 6
d668 1
a668 1
	bpl.s	scale_up_maybe
d705 1
a705 1
	beq.s	done_scale
d708 1
a708 1
	beq.s	done_scale
d710 1
a710 1
	bra.s	done_scale
d848 7
d938 1
d986 2
d989 1
d992 1
@


39.16
log
@change spritea_oldformat
terminate sprite
clr sprmovedisable on get
get right ret code for changeextspritea.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.15 92/04/06 12:41:06 chrisg Exp Locker: chrisg $
d350 1
a350 1
*					a2
d370 1
a374 1
	move.l	gb_ExecBase(a6),a6
@


39.15
log
@ fixed changeextsprite.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.14 92/04/04 14:34:28 chrisg Exp Locker: chrisg $
d368 1
a368 1
	beq.s	1$
d370 2
d376 1
d381 2
a382 1
1$:	rts
d443 9
d489 1
d494 1
d543 4
d579 8
a588 1
	move.l	d0,a3
d624 1
d651 1
a651 1
	beq.s	done_scale
d664 9
d945 1
a945 1
* 
d954 3
a956 1
	movem.l	a0-a2,-(a7)
a958 1
	movem.l	(a7)+,a0-a2
d961 3
d967 6
a973 1
	move.w	ss_num(a1),ss_num(a2)
d975 3
a977 1
	jmp	_LVOMoveSprite(a6)
@


39.14
log
@ softsprite tag correction
 free the right size in freesp data
 handle freespdata(null);
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.13 92/04/03 16:56:42 chrisg Exp Locker: chrisg $
d52 1
d918 1
a918 1
	movem.l	a2/a1,-(a7)
d921 1
a921 1
	movem.l	(a7)+,a2/a1
@


39.13
log
@ added lots o' new code.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.12 92/02/26 11:34:11 chrisg Exp Locker: chrisg $
d322 4
d354 1
a354 1
*    FUNCTION
d357 2
d361 2
a362 2
*	FreeSpriteData() FreeSprite() ChangeSprite() MoveSprite() GetExtSprite() AllocBitMap()
*	graphics/sprite.h
d364 1
a364 1
*********************************************************************
d366 2
d374 1
a374 1
	move.l	#ss_SIZEOF,d0
d377 1
a377 1
	rts
@


39.12
log
@ fxied bug in FreeSprite which caused bootmenu to leav a garbage sprite on the screen.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.11 92/02/11 10:26:52 spence Exp Locker: chrisg $
d19 1
d22 2
d52 3
d63 5
a67 2
	move.b	gb_SpriteReserved(a6),d1
	cmp.b	gb_SoftSprites(a6),d1
d70 1
d74 1
d159 11
a169 1
	tst.w	d0
d193 1
a193 1
******* graphics.library/GetSpriteTags **************************************
d196 1
a196 1
*	GetSpriteTags -- Attempt to get a sprite for the simple sprite
d198 1
d201 4
a204 2
*	Sprite_Number = GetSpriteTags( sprite, tags )  (V39)
*	    d0			         a0      a1
d206 1
a206 1
*	SHORT GetSpriteTags( struct SimpleSprite *, struct TagItem * );
d210 1
a210 2
*	with the simple sprite manager. This must be done before using
*	further calls to the simple sprite machine.
d219 2
a220 14
*			the tag data field points to a simple sprite structure
*			for the second sprite.
*
*		STAG_SPRITE_WIDTH specifies the width in words that the sprite
*			data is formatted for.
*
*		STAG_SPRITE_BITMAP specifies a bitmap structure which contains
*			a description of the sprite data. This will cause a
*			call to BitMapToSprite to occur. If the GetSpriteTags()
*			call succeeds, then you should be sure to call
*			FreeSpriteData() with the resulting posctl data when you are
*			finished with it. If you are using this tag, then any
*			valid tags for BitMapToSprite() can also be passed.
*
d225 4
a228 2
*			on success, fields in the SimpleSrpite structure will
*			be initalized.
a235 1
	xdef	_GetSpriteTags
d237 7
a243 7
_GetSpriteTags:
gst_snum	equ	0
gst_satt	equ	gst_snum+2
gst_swidth	equ	gst_satt+4
gst_bitmap	equ	gst_swidth+4
gst_stacksize	equ	gst_bitmap+4

d245 5
a249 5
	sub.l	#gst_stacksize,a7
	move.l	a1,a4
	move.l	a0,a2
	move.l	gb_ExecBase(a6),a3
	FORBID	a3,NOFETCH
d252 26
a277 16
	moveq	#-1,d1				; default sprite width
	move.l	#STAG_SPRITE_NUM,d0
	move.l	a4,a0
	jsr	_LVOGetTagData(a6)
	move.l	d0,gst_snum(a7)
	moveq	#0,d1				; default sprite width
	move.l	#STAG_ATTACHED,d0
	move.l	a4,a0
	jsr	_LVOGetTagData(a6)
	move.l	d0,gst_satt(a7)
	moveq	#1,d1				; default sprite width
	move.l	#STAG_SPRITE_WIDTH,d0
	move.l	a4,a0
	jsr	_LVOGetTagData(a6)
	move.w	d0,gst_swidth(a7)
	move.l	a5,a6
d280 3
d287 1
a287 1
	tst.b	gb_MemType(a6)
d292 1
a292 1
	cmp.b	#3,gb_MemType(a6)
d296 2
a297 2
	move.w	gst_swidth(a7),d0		; get width
	cmp.w	gb_SpriteWidth(a6),d0		; width=cur width?
d299 2
a300 2
	move.b	gb_SpriteReserved(a6),d0
	cmp.b	gb_SoftSprites(a6),d0		; any non-intuition sprites allocated?
d303 1
a303 1
	tst.l	gst_satt(a7)			; attached sprite
d305 1
a305 1
	move.w	gst_snum(a7),d0
d308 1
a308 1
	move.b	gb_SpriteReserved(a6),d0
d318 1
a318 1
	btst.b	d0,gb_SpriteReserved(a6)
d321 4
a324 1
	move.w	gst_swidth(a7),d0
d326 2
a329 2
	bset.b	d0,gb_SpriteReserved(a6)
	PERMIT	a3,NOFETCH
d331 1
a331 1
	add.l	#gst_stacksize,a7
d338 399
d871 51
@


39.11
log
@Correct calculation of sprite bandwidth.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.10 92/01/29 17:02:08 chrisg Exp Locker: spence $
d433 5
a437 2
	move.w	copinit_sprstop(a0),2(a1)
	move.w	copinit_sprstop+2(a0),6(a1)
@


39.10
log
@ fixed to use utilbase instead of utility.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.9 91/12/20 15:41:27 chrisg Exp Locker: chrisg $
d32 5
a36 1
	moveq	#1,d0		; 2x	must check GB->MemType!!!!
d38 1
a38 1
is_4x:	moveq	#$c,d0		; 4x!
d85 1
@


39.9
log
@killed clear of ss_num. caused enforcer hit in rick strelings program.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.8 91/11/26 16:09:45 chrisg Exp Locker: chrisg $
d234 1
a234 1
	move.l	gb_UtilityBase(a6),a6
@


39.8
log
@ fixed sprite move for scan doubled modes.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.7 91/11/26 16:02:41 chrisg Exp Locker: chrisg $
a422 2
	move.l	d1,a0
	clr.w	ss_num(a0)
@


39.7
log
@ fixed attached sprites again
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.6 91/11/15 11:02:22 chrisg Exp Locker: chrisg $
a38 1
	print	'do_nothing'
a50 2
	print	'changewidth='
	dbugw	d0
a52 1
	print	'do something?'
a248 2
	print	'req wi='
	dbugw	d0
a290 2
	print	'snum='
	dbugw	d0
d636 1
d640 1
a640 1
no_double:	add.w	d1,d2			; y += vp->DyOffset -- greater accuracy
@


39.6
log
@ fixed problem with view relative sprite moves that showed up in
bootmenu.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.5 91/10/30 19:13:32 spence Exp Locker: chrisg $
a537 2
	move.w	d0,ss_x(a1)
	move.w	d1,ss_y(a1)
d565 2
d613 4
a616 4
	move.l	d2,d0			; x in d0 high
	swap	d0			; x in d0 low
	move.w	d2,d1			; y in d1 low 

@


39.5
log
@Passing MoveSprite() with vp == NULL was attempting to read View->Viewport
from same NULL pointer.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.4 91/10/30 15:49:43 chrisg Exp Locker: spence $
d553 1
a553 1
	move.l	a2,a0
@


39.4
log
@  vectors movesprite via vecinfo
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.3 91/10/28 11:48:44 chrisg Exp Locker: chrisg $
d549 3
d553 1
d556 1
a556 1
	lea	_DefaultMoveSprite(pc),a2
@


39.3
log
@first rev with sprite width mode changing stuff
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.2 91/10/15 15:49:39 chrisg Exp Locker: chrisg $
d16 1
d206 2
a207 1
*			finished with it.
d210 1
d534 21
d556 1
a556 2
	xdef    _MoveSprite
SASDEBUG	equ	0
d558 1
a558 1
_MoveSprite:
a561 2
	move.w	d0,ss_x(a1)
	move.w	d1,ss_y(a1)
@


39.2
log
@ massive re-write : all c stuff now downcoded. hedley removed.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.1 91/10/10 09:46:17 chrisg Exp Locker: chrisg $
d19 1
a19 1
	xref	_LVOPermit
d21 289
d362 2
a363 2
	dbcs	d1,1$
	bcc.s	no_sprite_to_get
d417 2
d420 1
d425 4
a428 1
	move.l	0(a0,d1.w),a0
d437 5
d543 3
a545 1

a592 1

d759 1
a759 1

d864 1
a866 2
	swap	d7
	move.w	d7,6(a0,d2.w)
a867 1
	move.w	ss_num(a3),d0
d878 2
a880 2
	swap	d6
	move.w	d6,14(a0,d2.w)
@


39.1
log
@  downcodes GetSprite, FreeSprite, make_sprite_appear,
make_sprite_disappear, and sprite_attached in asm.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 39.0 91/09/25 15:16:51 chrisg Exp Locker: chrisg $
d91 1
a91 1
	xdef    _FreeSprite,_make_sprite_disappear
d136 1
a136 3
; void __asm make_sprite_disappear(register __d0 num);
; set the given sprite to the blank sprite by poking copinit
_make_sprite_disappear:
a143 36
; void __asm make_sprite_appear(register __a1 struct SimpleSprite * ss);
	xdef	_make_sprite_appear

_make_sprite_appear:
	move.l	gb_copinit(a6),a0
	move.w	ss_num(a1),d0
	lsl.w	#3,d0
	lea	copinit_sprstrtup+2(a0,d0.w),a0
	move.l	ss_posctldata(a1),d1
	swap	d1
	move.w	d1,(a0)
	swap	d1
	move.w	d1,4(a0)
	rts

; int __asm sprite_attached(register __a0 struct SimpleSprite * s);
	xdef	_sprite_attached
_sprite_attached:
	move.w	ss_num(a0),d0
	btst	#0,d0
	bne.s	not_attached
	add.w	d0,d0
	add.w	d0,d0
	move.l	gb_SimpleSprites(a6),a0
	move.l	4(a0,d0.w),d0
	beq.s	not_attached
	move.l	d0,a0
	move.l	ss_posctldata(a0),a0
	btst	#7,3(a0)
	beq.s	not_attached
	moveq	#-1,d0
	rts
not_attached:
	moveq	#0,d0
	rts

d191 3
a193 11
	move.l  a2,-(sp)
	move.l  a1,-(sp)
	move.l  a0,-(sp)
	jsr _changesprite
	lea 12(sp),sp
	rts


	xref	_intena

	xdef _movesprite_internal
a194 11
_movesprite_internal:

	move.l  4(sp),a0
	move.l  8(sp),a1
	move.w  14(sp),d0
	move.w  18(sp),d1
	tst.l   20(sp)
	bne.s   ms_amovesprite

	xdef    _MoveSprite
	xref    _movesprite
d231 2
a236 5
	btst.b	#0,gb_hedley_flags+1(a6)
	bne	ms_cmovesprite
	btst.b	#2,gb_hedley_flags+1(a6)
	bne	ms_cmovesprite

d244 1
a244 20
	moveq	#1,d6			; d6=sprite width in words
	cmp.w	#0,a0		  	; viewport specified?
	beq.s	view_relative
got_vport:
	move.l	vp_ColorMap(a0),a2
	cmp	#0,a2
	beq.s	got_spritesize
	tst.w	cm_Type(a2)
	beq.s	got_spritesize
	move.w	cm_SpriteWidth(a2),d6
	bra.s	got_spritesize
view_relative:
	move.l	gb_ActiView(a6),d3
	beq.s	got_spritesize
	move.l	d3,a2
	move.l	v_ViewPort(a2),a2
	cmp	#0,a2
	bne.s	got_vport

	
a264 12
ms_check_15hz:
	btst.b	#0,gb_hedley_flags+1(a6)
	beq.s	ms_check_10hz
	move.l	#$0081002C,d3
	bra.s	ms_not_attached

ms_check_10hz:
	btst.b	#2,gb_hedley_flags+1(a6)
	beq.s	ms_check_attached
	move.l	#$0071002C,d3
	bra.s	ms_not_attached

d290 1
a290 1
	jsr	ms_amovesprite		; assembly direct
d313 1
a313 1
	move.l	d0,(sp)			; remember to pop from stack after clipping sprite
d353 1
a457 3
	move.b	gb_hedley_flags+1(a6),d4
	and.b	#5,d4
	bne.s	ms_hedley
d502 9
a510 1
ms_check_clipped:
d512 2
a513 6
	xref	_sprite_clipped
;   move.l      xx,-(sp)		; phantom push -- see jsr above
	move.l	a3,-(sp)		; s
	move.l	a2,-(sp)		; vp
	jsr	_sprite_clipped		; call c routine
	addq.l	#8,sp
d515 8
a522 2
ms_pop:
	addq.l	#4,sp			; phantom pop
d524 33
a556 1
ms_arts:
d560 23
a582 13
ms_hedley:
	move.l	d0,(a1)
	bra.s	ms_pop

ms_cmovesprite:

	clr.l	-(sp)			; put parameter 0 on stack
	move.l  d1,-(sp)
	move.l  d0,-(sp)
	move.l  a1,-(sp)
	move.l  a0,-(sp)
	jsr _movesprite
	lea 20(sp),sp
@


39.0
log
@made sprites move properly on scan doubled screens.
@
text
@d3 1
a3 1
*	$Id: simplesprites.asm,v 38.0 91/07/12 16:29:13 chrisg Exp Locker: chrisg $
d7 14
d65 20
a84 5
*               current routine calls a C subroutine to do the work
	move.l  d0,-(sp)    * push num
	move.l  a0,-(sp)    * push struct *SimpleSprite
	jsr _getsprite      * call C routine
	addq.l #8,sp       * remove args from stack
d86 4
d91 2
a92 2
	xdef    _FreeSprite
	xref    _freesprite
d128 31
a158 3
	move.l  d0,-(sp)
	jsr _freesprite
	addq 	#4,sp
d161 21
a235 10
	include	'exec/types.i'
	include	'exec/ables.i'
	include	'/gfxbase.i'
	include	'/view.i'
	include	'/sprite.i'
	include	'/monitor.i'
	include	'/macros.i'
	include	'/gels/gelsinternal.i'
	include 'hardware/intbits.i'
	include 'hardware/dmabits.i'
d365 8
a372 5
	xref	_sprite_attached
	move.l	a3,-(sp) 	 	; check this sprite
	jsr	_sprite_attached	; call c routine
	add.l	#4,sp
	tst.l	d0
d376 1
a376 3
	move.l	4(a4,d4.w),d4		; attached simplesprite?
	beq.s	ms_not_attached
	move.l	d4,a1	      		; attached simplesprite!
d561 4
@


38.0
log
@added handling for wide sprites
@
text
@d3 1
a3 1
*	$Id: SimpleSprites.asm,v 37.13 91/05/02 10:43:37 chrisg Exp Locker: chrisg $
d160 1
d324 1
a324 1
	bra.s	ms_novp
d336 4
a339 1
	add.w	d1,d2			; y += vp->DyOffset -- greater accuracy
@


37.13
log
@ changed BSET.B to BSET
@
text
@d3 1
a3 1
*	$Id: SimpleSprites.asm,v 37.12 91/05/01 14:41:17 chrisg Exp Locker: chrisg $
d7 2
a8 2
    xdef    _GetSprite
    xref    _getsprite
d52 5
a56 5
    move.l  d0,-(sp)    * push num
    move.l  a0,-(sp)    * push struct *SimpleSprite
    jsr _getsprite      * call C routine
    addq.l #8,sp       * remove args from stack
    rts
d58 2
a59 2
    xdef    _FreeSprite
    xref    _freesprite
d95 4
a98 4
    move.l  d0,-(sp)
    jsr _freesprite
    addq 	#4,sp
    rts
d100 2
a101 2
    xdef    _ChangeSprite
    xref    _changesprite
d147 16
a162 16
    move.l  a2,-(sp)
    move.l  a1,-(sp)
    move.l  a0,-(sp)
    jsr _changesprite
    lea 12(sp),sp
    rts

    include	'exec/types.i'
    include	'exec/ables.i'
    include	'graphics/gfxbase.i'
    include	'graphics/view.i'
    include	'graphics/sprite.i'
    include	'graphics/monitor.i'
    include	'/gels/gelsinternal.i'
    include 'hardware/intbits.i'
    include 'hardware/dmabits.i'
d166 1
a166 1
    xdef _movesprite_internal
d170 6
a175 6
    move.l  4(sp),a0
    move.l  8(sp),a1
    move.w  14(sp),d0
    move.w  18(sp),d1
    tst.l   20(sp)
    bne.s   ms_amovesprite
d177 2
a178 2
    xdef    _MoveSprite
    xref    _movesprite
d219 4
a222 4
    btst.b	#0,gb_hedley_flags+1(a6)
    bne		ms_cmovesprite
    btst.b	#2,gb_hedley_flags+1(a6)
    bne		ms_cmovesprite
d226 2
a227 2
    move.w	d0,ss_x(a1)
    move.w	d1,ss_y(a1)
d229 1
a229 1
    movem.l	d2-d5/a2-a4,-(sp) * preserve registers
d231 25
a255 3
    move.l	a0,a2		  * viewport pointer
    move.l	a1,a3		  * simplesprite pointer
    move.l	ss_x(a3),d2	  * x in d2 high, y in d2 low
d257 1
a257 1
*   safe to call self after this point
d260 3
a262 3
    move.l	gb_ActiView(a6),d3
    beq		ms_arts
    move.l	d3,a0
d266 4
a269 2
    move.l	v_DyOffset(a0),d3 
    swap	d3 		  * startx in d3 high, starty in d3 low
d272 4
a275 4
    btst.b	#0,gb_hedley_flags+1(a6)
    beq.s	ms_check_10hz
    move.l	#$0081002C,d3
    bra.s	ms_not_attached
d278 4
a281 4
    btst.b	#2,gb_hedley_flags+1(a6)
    beq.s	ms_check_attached
    move.l	#$0071002C,d3
    bra.s	ms_not_attached
d285 21
a305 21
    move.l	gb_SimpleSprites(a6),a4  * ns
    move.w	ss_num(a3),d4
    add.w	d4,d4			 * convert sprite num
	move.w	d4,d5			 * needed later
    add.w	d4,d4			 * to longword offset
    move.l	a3,0(a4,d4.w) 	* ns[num] = s;

    xref	_sprite_attached
    move.l	a3,-(sp) 	 * check this sprite
    jsr		_sprite_attached * call c routine
    add.l	#4,sp
    tst.l	d0
    beq.s	ms_not_attached

    move.l	a2,a0 	* viewport
    move.l	4(a4,d4.w),d4 * attached simplesprite?
    beq.s	ms_not_attached
    move.l	d4,a1	      * attached simplesprite!
    move.l	d2,d0	* x in d0 high
    swap	d0	* x in d0 low
    move.w	d2,d1	* y in d1 low 
d307 1
a307 1
    jsr		ms_amovesprite * assembly direct
d311 3
a313 3
    move.l	ss_posctldata(a3),a1	* k = s->posctldata
    move.l	a1,d0			
    beq		ms_arts
d315 21
a335 15
    moveq.l	#0,d4   * 140 ns scrolling

    move.l	a2,-(sp) * viewport?
    beq.s	ms_novp

*   move.w	vp_Modes(a2),d0 * don't use vp->Modes directly for 1.4

    xref	_new_mode
    jsr		_new_mode
    move.l	d0,(sp)	* remember to pop from stack after clipping sprite

    move.l	ss_posctldata(a3),a1	* reload k after "C" call
    move.l	vp_DxOffset(a2),d1 * dxoffset in d1 high, dyoffset in d1 low

    add.w	d1,d2   * y += vp->DyOffset -- greater accuracy
d337 3
a339 3
    btst.l	#5,d0
    beq.s	ms_nosuper
    bclr.l	#15,d0
d342 3
a344 3
    btst.l	#2,d0
    beq.s	ms_nolace
    asr.w	#1,d2	* y >>= 1
d347 3
a349 3
    swap	d1	* vp->dxoffset now in d1 low
    swap	d2 	* will have to swap this back later	
    swap	d3 	* will have to swap this back later	
d351 10
a360 12
    add.w	d1,d2   * x += vp->DxOffset -- greater accuracy

    btst.l	#15,d0
    beq.s	ms_nohires
    asr.w	#1,d2	* x >>= 1
    bra.s	ms_swapback

ms_nohires: 
    btst.l	#5,d0
    beq.s	ms_swapback
    asr.w	#2,d2	* x >>= 2
    moveq.l	#2,d4   * 70 ns scrolling
d363 2
a364 2
    swap	d2 	* swap this back now
    swap	d3 	* swap this back now
d367 2
a368 2
    add.w	d2,d3	* starty += y;
    move.w	d3,d2
d370 1
a370 1
    move.w	#21,d1 * outdated - presupposes NTSC - bart 
d372 8
a379 8
    move.l	gb_current_monitor(a6),d0 * fetch correct min_row instead - bart
    beq.s	ms_nomspc
    move.l	d0,a0
    move.w	ms_min_row(a0),d1
    move.w	ms_Flags(a0),d0
    and.w	#MSF_REQUEST_SPECIAL,d0
    beq.s	ms_nomspc
    addq.w	#1,d1
d382 3
a384 3
    sub.w	d1,d2 
    bge.s	ms_noclip
    sub.w	d2,d3	* starty = MAX(21,starty);
d386 5
a390 5
    move.w	d3,d1   * starty for jam
    swap	d2
    swap	d3
    add.w	d2,d3	* startx += x;
    add.w	ss_height(a3),d1 * stopy for jam
d393 8
a400 5
    move.w	d3,d0	* startx
    sub.w	gb_MaxDisplayColumn(a6),d0
    ble.s	ms_no_wrap
    sub.w	#9,d0
    bgt.s	ms_no_wrap
d403 2
a404 2
    addq.w	#8,d0	* startx -= (GB->MaxDisplayColumn-1);
    move.w	d0,d3
d408 1
a408 1
    moveq.l	#0,d0	* build jam in d0
d411 19
a429 9
    lsr.w	#1,d3	* (startx>>1)
    addx.b	d0,d0	* (startx & 1)
    move.b	d3,d2 	* ((startx>>1)&0xff)
    swap	d0	* (startx & 1) in upper word, zero in lower word
    swap	d3	* starty now in lower word
    move.w	d3,d0
    lsl.w	#8,d0	* (starty<<8)
    move.b	d2,d0   * (starty<<8)|((startx>>1)&0xff) in lower word
    swap	d0	* upper word of jam is now finished
d433 6
a438 6
    move.b	3(a1),d2
    and.b	#$80,d2	* sprite attached?
    or.b	d2,d0
    btst.l	#8,d3
    beq.s	no_sv8
    bset	#2,d0
d441 3
a443 3
    btst.l	#9,d3
    beq.s	no_sv9
    bset	#6,d0
d446 6
a451 6
    move.b	d1,d2	* stopy low byte
    lsl.w	#8,d2
    or.w	d2,d0	* ((stopy&0xff)<<8)
    btst.l	#8,d1
    beq.s	no_ev8
    bset	#1,d0
d454 3
a456 3
    btst.l	#9,d1
    beq.s	no_ev9
    bset	#5,d0
d460 9
a468 9
    move.w	#3,d1
    move.w	#2,d2
    sub.w	d4,d2
    lsr.w	d2,d1
    beq.s	ms_jammit
    and.w	ss_x(a3),d1
    add.w	#3,d2
    lsl.w	d2,d1
    or.w	d1,d0
d481 2
a482 2
FIRST_SPRITE_DMA	equ	$18		* end of first sprite dma slot
LAST_SPRITE_DMA	equ	$34		* end of last sprite dma slot
d488 1
a488 1
	lea	_custom+vhposr,a4	* for beam pos check code below
d491 1
a491 1
	move.w	(a4),d1			* horizontal pos in d1:8
d493 1
a493 1
	bhi.s	do_jammit		* after sprite dma slots
d495 1
a495 1
	add.b	d5,d2			* 4 slots per sprite (from above)
d497 1
a497 1
	move.w	(a4),d1			* horizontal pos in d1:8
d499 1
a499 1
	bls.s	1$			* busy wait until after this sprite's slot (Yeuchh!)
d501 10
a510 1
	move.l	d4,(a5)			* jam that sucker!	
d513 1
a513 1

d516 6
a521 6
    xref	_sprite_clipped
*   move.l      xx,-(sp)	* phantom push -- see jsr above
    move.l	a3,-(sp)	* s
    move.l	a2,-(sp)	* vp
    jsr		_sprite_clipped * call c routine
    addq.l	#8,sp
d524 1
a524 1
    addq.l	#4,sp		* phantom pop
d527 2
a528 2
    movem.l	(sp)+,d2-d5/a2-a4 * restore registers
    rts
d536 8
a543 8
    clr.l	-(sp)	; put parameter 0 on stack
    move.l  d1,-(sp)
    move.l  d0,-(sp)
    move.l  a1,-(sp)
    move.l  a0,-(sp)
    jsr _movesprite
    lea 20(sp),sp
    rts
d545 1
a545 1
    end
@


37.12
log
@killed ".." for cape
@
text
@d3 1
a3 1
*	$Id: SimpleSprites.asm,v 37.11 91/04/17 14:19:53 chrisg Exp Locker: chrisg $
d397 1
a397 1
    bset.b	#2,d0
d402 1
a402 1
    bset.b	#6,d0
d410 1
a410 1
    bset.b	#1,d0
d415 1
a415 1
    bset.b	#5,d0
@


37.11
log
@  Optimized to reduce Disable time.
@
text
@d3 1
a3 1
*	$Id: SimpleSprites.asm,v 37.10 91/03/01 08:57:22 chrisg Exp Locker: chrisg $
d160 1
a160 1
    include	'../gels/gelsinternal.i'
@


37.10
log
@ Took out >>1 for FIRST_SPRITE_DMA and LAST_SPRITE_DMA. Acording to spence,
these are the correct values, and his previous reading of the hardware
manual was wrong. If so, this should fix bryce's sprite problem.
@
text
@d3 1
a3 1
*	$Id: SimpleSprites.asm,v 37.9 91/02/12 17:48:15 spence Exp Locker: chrisg $
d155 1
d161 2
d164 2
d447 4
a450 6
	lea		_custom,a4
	move.l	a6,d3
	move.l	gb_ExecBase(a6),a6
	jsr		_LVODisable(a6)
	move.w	vhposr(a4),d1	* horizontal pos in d1:8
*	asl.b	#1,d1			* H1-H8 -> H0-H7
d456 1
a456 2
	move.w	vhposr(a4),d1	* horizontal pos in d1:8
*	asl.b	#1,d1			* H1-H8 -> H0-H7
d458 1
a458 1
	bls.s	1$				* busy wait until after this sprite's slot (Yeuchh!)
d460 2
a461 3
    move.l	d4,(a5)		* jam that sucker!	
	jsr		_LVOEnable(a6)
	move.l	d3,a6
@


37.9
log
@autodocs
@
text
@d3 1
a3 1
*	$Id: SimpleSprites.asm,v 37.8 91/02/12 16:27:10 chrisg Exp Locker: spence $
d438 1
a438 1
	moveq	#(LAST_SPRITE_DMA>>1),d2
d450 1
a450 1
	moveq	#(FIRST_SPRITE_DMA>>1),d2
@


37.8
log
@edited autodoc
@
text
@d3 1
a3 1
*	$Id: SimpleSprites.asm,v 37.7 91/02/08 15:52:00 spence Exp Locker: chrisg $
d177 1
a177 1
*       MoveSprite -- Move sprite to a point relative to top of viewport.
d180 2
a181 2
*       MoveSprite( vp, sprite, x, y )
*		    a0   a1    d0 d1
d183 1
a183 1
*	void MoveSprite( struct ViewPort *,struct SimpleSprite *, WORD, WORD );
d192 1
a192 1
*	(x,y) - new position relative to top of viewport or view.
d201 3
a203 2
*	This bug affects the apparent display position of the sprite on the screen,
*       but does not affect the numeric position relative to the viewport or view.
d206 1
a206 1
*       FreeSprite() ChangeSprite() GetSprite() graphics/sprite.h
@


37.7
log
@Sprite fix use bhi.s and bls.s instead of bgt.s and ble.s
@
text
@d3 1
a3 1
*	$Id: SimpleSprites.asm,v 37.6 91/02/07 16:23:20 spence Exp Locker: spence $
d19 1
a19 3
*	SHORT Sprite_Number;
*	struct SimpleSprite *sprite;
*	SHORT pick;
d24 2
a25 2
*	further calls to simple sprite machine. If the programmer
*	wants to use 15 color sprites you must allocate both sprites
d47 1
a47 1
*	FreeSprite ChangeSprite MoveSprite GetSprite graphics/sprite.h
d70 1
a70 1
*	SHORT pick;
d79 1
a79 1
*	Virtual Sprite machine may ignore simple sprite machine.
d86 1
a86 1
*	as well as use by Virtual Sprite Machine
d91 1
a91 1
*       GetSprite ChangeSprite MoveSprite graphics/sprite.h
d111 1
a111 3
*	struct ViewPort *vp;
*	struct SimpleSprite *s;
*	APTR	newdata;	/* chip memory */
d118 1
a118 2
*		  relative to.
*		  or 0 if relative only top of View
d128 1
a128 1
*	Programmer must initialize reserved[2].  Spriteimage must be
d131 2
a132 2
*	calling ChangeSprite. The programmer may allocate two sprites to
*	handle a single attached sprite.  After GetSprite, ChangeSprite,
d135 1
a135 1
*	If you need more than 8 sprites look up VSprites in the
d143 1
a143 1
*	FreeSprite ChangeSprite MoveSprite AddVSprite graphics/sprite.h
d176 1
a176 1
*NAME
d179 1
a179 1
*SYNOPSIS
d183 1
a183 3
*	struct ViewPort *vp;
*	struct SimpleSprite *sprite;
*	SHORT	x,y;
d185 1
a185 1
*FUNCTION
d188 1
a188 1
*INPUTS
d194 1
a194 1
*RESULTS
d199 1
a199 1
*BUGS
d202 1
a202 1
*   but does not affect the numeric position relative to the viewport or view.
d204 2
a205 2
*SEE ALSO
*       FreeSprite ChangeSprite GetSprite graphics/sprite.h
@


37.6
log
@New fix to MoveSprite() - check if we are going to jam during the
sprite DMA slots.
@
text
@d3 1
a3 1
*	$Id: SimpleSprites.asm,v 37.5 91/02/01 08:48:54 bart Exp Locker: spence $
d455 1
a455 1
	bgt.s	do_jammit		* after sprite dma slots
d462 1
a462 1
	ble.s	1$				* busy wait until after this sprite's slot (Yeuchh!)
@


37.5
log
@must Disable/Enable because every other method has race conditions
@
text
@d3 1
a3 1
*	$Id: SimpleSprites.asm,v 37.4 91/01/31 17:32:57 spence Exp Locker: bart $
d265 1
a266 1
	move.w	d4,d5			 * needed later
d431 3
a433 2
* don't jam yet! 
* That gets done in vblank ('cos may cause contention) - spence Jan 29 1991
a434 1
	include 'hardware/intbits.i'
d437 1
d441 2
a442 3
	move.b	gb_hedley_flags+1(a6),d2
	and.b	#5,d2
	bne.s	do_jammit		* OK - we do jam in Hedley mode
d444 24
d469 1
a469 3
	move.l	gb_SpriteCtlData(a6),a4	
	add.w	d5,d5
	add.w	d5,a4
a470 30
	move.l	a6,d5				* must Disable/Enable because every
	move.l	gb_ExecBase(a6),a6		* other method has race conditions
	jsr	_LVODisable(a6)			* protecting for vblank interrupt
	move.l	a1,(a4)+			* move.l a1,pcd_Address(a4,d5.w)
	move.l	d0,(a4)				* move.l d0,pcd_Data(a4,d5.w)
	jsr	_LVOEnable(a6)			* vblank interrupt ok now
	move.l	d5,a6

	ifne	SASDEBUG	* increment address 0 
*				* if MoveSprite()_y and beampos_y same
	xref	_vposr
	xref	_vhposr
	move.w	_vhposr,d4
	move.w	_vposr,d5
	lsr.w	#8,d4
	and.w	#1,d5
	asl.w	#8,d5
	or.w	d5,d4
	move.l	d0,d1
	swap	d0
	lsr.w	#8,d0
	and.w	#4,d1
	asl.w	#6,d1
	or.w	d1,d0
	cmp.w	d4,d0
	bne.s	ms_check_clipped
	add.w	#1,0	
	endc

ms_check_clipped:
d476 1
a476 1
	    addq.l	#8,sp
d485 2
a486 2
do_jammit:
   	move.l	d0,(a1)		* jam that sucker!	
a487 5

*    btst.b	#0,gb_hedley_flags+1(a6)
*    bne.s	ms_pop
*    btst.b	#2,gb_hedley_flags+1(a6)
*    bne.s	ms_pop
@


37.4
log
@disables master interrupt around MoveSprite() kludge, and restores
interrupts to original state.
@
text
@d3 1
a3 1
*	$Id: SimpleSprites.asm,v 37.3 91/01/31 12:32:30 bart Exp Locker: spence $
d437 2
a438 4
	xref	_intena
	xref	_intenar
	xref	_vposr
	xref	_vhposr
d444 1
d448 4
a451 2
	move.w	_intenar,d2
	move.w  #INTF_INTEN,_intena		* protect from vblank interrupt ...
d454 2
a455 3
	and.w	#INTF_INTEN,d2
	or.w	#BITSET,d2
	move.w  d2,_intena 	* ok for vblank interrupt now (keeping original VBLANK interrupt state)
d459 2
@


37.3
log
@oops meant VERTB in ms_jammit
@
text
@d3 1
a3 1
*	$Id: SimpleSprites.asm,v 37.2 91/01/31 09:49:40 bart Exp Locker: bart $
d438 1
a438 1
	xref	_intena
d442 4
d449 2
a450 1
	move.w  #INTF_VERTB,_intena		* protect from vblank interrupt ...
d453 3
a455 1
	move.w  #BITSET+INTF_VERTB,_intena 	* ok for vblank interrupt now
a456 2
*    	move.l	d0,(a1)		* jam that sucker!	

a476 6

    btst.b	#0,gb_hedley_flags+1(a6)
    bne.s	ms_pop
    btst.b	#2,gb_hedley_flags+1(a6)
    bne.s	ms_pop

d482 1
a482 1
    addq.l	#8,sp
d490 9
@


37.2
log
@protect jammit from vlank interrupt
bart
@
text
@d3 1
a3 1
*	$Id: SimpleSprites.asm,v 37.1 91/01/30 13:09:28 spence Exp Locker: bart $
d445 1
a445 1
	move.w  #INTF_BLIT,_intena		* protect from vblank interrupt ...
d448 1
a448 1
	move.w  #BITSET+INTF_BLIT,_intena 	* ok for vblank interrupt now
@


37.1
log
@MoveSprite() now buffers the new sprite positions, which are updated
in vblank time. Hopefully, this will cure the random 'ghost' sprite
problem.
@
text
@d3 1
a3 1
*	$Id: SimpleSprites.asm,v 37.0 91/01/07 15:26:27 spence Exp Locker: spence $
d431 11
a441 1
* don't jam yet! That gets done in vblank ('cos may cause contention) - spence Jan 29 1991
d445 4
a448 3
	move.l	a1,(a4)+	*	move.l	a1,pcd_Address(a4,d5.w)
	move.l	d0,(a4)		*	move.l	d0,pcd_Data(a4,d5.w)
*    move.l	d0,(a1)		* jam that sucker!	
d450 6
a455 3
	ifne	SASDEBUG	* increment address 0 if MoveSprite()_y and beampos_y same
	move.w	$dff006,d4
	move.w	$dff004,d5
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*	$Id: SimpleSprites.asm,v 1.15 90/08/24 11:28:45 bart Exp Locker: spence $
d164 1
d216 2
d230 1
a230 1
    movem.l	d2-d4/a2-a4,-(sp) * preserve registers
d266 1
d431 7
a437 1
    move.l	d0,(a1)		* jam that sucker!	
d439 18
d475 1
a475 1
    movem.l	(sp)+,d2-d4/a2-a4 * restore registers
@


1.15
log
@id
@
text
@d3 1
a3 1
*	$Id: $
@


1.14
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: SimpleSprites.asm,v 1.13 90/03/02 09:48:14 bart Exp $
@


1.13
log
@update min_row for 1.4 compatibility
clip sprite position to min_row rather than hard coded #21 (outdated)
@
text
@d3 1
a3 1
*	$Header: SimpleSprites.asm,v 1.12 89/04/14 16:03:20 bart Exp $
@


1.12
log
@move.l      gb_ActiView(a6),d3 
@
text
@d3 1
a3 1
*	$Header: SimpleSprites.asm,v 1.11 89/03/10 15:50:46 bart Exp $
d163 1
d338 14
a351 1
    sub.w	#21,d2 * outdated - presupposes NTSC - bart 
@


1.11
log
@ms_pop for hedley mode
@
text
@d3 1
a3 1
*	$Header: SimpleSprites.asm,v 1.10 89/03/10 14:47:33 bart Exp $
d235 1
a235 1
    move.l	gb_ActiView(a6),a0
d237 1
@


1.10
log
@added mode flags to sprite clipped and removed y rounding
@
text
@d3 1
a3 1
*	$Header: SimpleSprites.asm,v 1.9 89/03/09 15:59:06 bart Exp $
d417 1
a417 1
    bne.s	ms_arts
d419 1
a419 1
    bne.s	ms_arts
d422 1
a422 1
*   move.l      _new_mode,-(sp)	* phantom push -- see jsr above
d426 4
a429 1
    lea.l	12(sp),sp	* phantom pop
@


1.9
log
@x += vp->DxOffset -- greater accuracy
y += vp->DyOffset -- greater accuracy and saves bytes
@
text
@d3 1
a3 1
*	$Header: SimpleSprites.asm,v 1.8 89/02/23 11:09:09 bart Exp $
d288 1
a288 1
    move.l	a2,d1	* viewport?
a293 1
    move.l	a2,-(sp)
d295 1
a295 1
    addq.l	#4,sp
a308 1
    add.w	#1,d2	* round y
d422 1
d426 1
a426 1
    addq.l	#8,sp
@


1.8
log
@call new_mode
@
text
@d3 1
a3 1
*	$Header: SimpleSprites.asm,v 1.7 89/02/14 18:24:03 bart Exp $
d301 2
d310 1
d312 1
a312 1
    asr.w	#1,d1	* dyoffset >>= 1
d314 3
a316 1
    add.w	d1,d3	* starty += vp->DyOffset>>(vp->Modes &LACE?1:0);
d318 1
a318 3
ms_swapit:
    swap	d2 	* will have to swap these back later	
    swap	d3
a325 1

d332 2
a333 3

    swap	d2 	* swap these back now
    swap	d3
@


1.7
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: SimpleSprites.asm,v 1.6 89/02/14 10:08:59 bart Exp $
d287 1
d291 8
d300 1
a300 1
    move.w	vp_Modes(a2),d0
@


1.6
log
@checkpoint 02.14.89
@
text
@d3 1
a3 1
*	$Header: SimpleSprites.asm,v 1.5 89/02/01 17:53:52 bart Exp $
d292 1
a292 1
    btst.l	#6,d0
d315 1
a315 1
    btst.l	#6,d0
@


1.5
log
@checkpoint - a2024 10hz and 15hz works from 32 bit id
@
text
@d3 1
a3 1
*	$Header: SimpleSprites.asm,v 1.4 89/01/13 12:39:48 bart Exp $
@


1.4
log
@fix superhires bit #6 and simultaneous hires/super bits set
@
text
@d3 1
a3 1
*	$Header: SimpleSprites.asm,v 1.3 88/10/31 10:17:20 bart Exp $
@


1.3
log
@downcode portions of movesprite to assembly language
@
text
@d3 1
a3 1
*	$Header: SimpleSprites.asm,v 1.2 88/05/03 15:29:19 dale Exp $
d292 3
d296 1
d315 1
a315 1
    btst.l	#5,d0
@


1.2
log
@New code to make hedley sprite code reentrant.
@
text
@d3 1
a3 1
*	$Header: SimpleSprites.asm,v 1.1 88/05/01 15:38:06 dale Exp $
d159 16
d213 1
d215 207
a421 1
	clr.l	-(sp)	; put parameter 0 on stack
d430 1
a430 1
	end
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
*	$Header: SimpleSprites.asm,v 33.1 86/08/12 11:36:41 bart Exp $
d198 1
d204 1
a204 1
    lea 16(sp),sp
@
