head     39.54;
branch   ;
access   ;
symbols  rel39_24:39.54 rel39_18:39.54 rel39_97:39.47 rel39_90:39.47 rel39_89:39.45 rel39_82:39.42 rel39_76:39.38 rel39_71:39.36 rel39_65:39.34 rel39_64:39.34 rel39_61:39.34 rel39_60:39.33 rel39_55:39.31 rel39_52:39.31 rel39_47:39.29 rel39_39:39.25 rel39_38:39.25 rel39_37:39.21 rel39_35:39.19 rel39_34:39.18;
locks    ; strict;
comment  @* @;


39.54
date     93.04.08.13.32.42;  author spence;  state Exp;
branches ;
next     39.53;

39.53
date     93.03.12.12.39.04;  author chrisg;  state Exp;
branches ;
next     39.52;

39.52
date     93.03.09.10.28.47;  author chrisg;  state Exp;
branches ;
next     39.51;

39.51
date     93.03.08.13.12.46;  author chrisg;  state Exp;
branches ;
next     39.50;

39.50
date     93.02.15.17.31.08;  author spence;  state Exp;
branches ;
next     39.49;

39.49
date     93.02.11.08.21.24;  author chrisg;  state Exp;
branches ;
next     39.48;

39.48
date     93.02.09.15.51.04;  author chrisg;  state Exp;
branches ;
next     39.47;

39.47
date     92.09.24.13.35.03;  author chrisg;  state Exp;
branches ;
next     39.46;

39.46
date     92.09.17.11.42.02;  author spence;  state Exp;
branches ;
next     39.45;

39.45
date     92.09.08.14.51.57;  author chrisg;  state Exp;
branches ;
next     39.44;

39.44
date     92.08.24.12.18.09;  author chrisg;  state Exp;
branches ;
next     39.43;

39.43
date     92.08.20.14.52.04;  author chrisg;  state Exp;
branches ;
next     39.42;

39.42
date     92.08.17.13.36.19;  author chrisg;  state Exp;
branches ;
next     39.41;

39.41
date     92.08.10.10.26.22;  author chrisg;  state Exp;
branches ;
next     39.40;

39.40
date     92.08.06.11.25.08;  author chrisg;  state Exp;
branches ;
next     39.39;

39.39
date     92.08.03.09.09.31;  author chrisg;  state Exp;
branches ;
next     39.38;

39.38
date     92.07.29.16.48.00;  author chrisg;  state Exp;
branches ;
next     39.37;

39.37
date     92.07.21.14.43.52;  author chrisg;  state Exp;
branches ;
next     39.36;

39.36
date     92.06.16.13.15.28;  author chrisg;  state Exp;
branches ;
next     39.35;

39.35
date     92.06.11.14.26.30;  author chrisg;  state Exp;
branches ;
next     39.34;

39.34
date     92.06.03.16.32.01;  author chrisg;  state Exp;
branches ;
next     39.33;

39.33
date     92.05.19.13.15.03;  author chrisg;  state Exp;
branches ;
next     39.32;

39.32
date     92.05.13.11.11.36;  author spence;  state Exp;
branches ;
next     39.31;

39.31
date     92.04.10.12.10.39;  author chrisg;  state Exp;
branches ;
next     39.30;

39.30
date     92.04.08.17.03.59;  author chrisg;  state Exp;
branches ;
next     39.29;

39.29
date     92.04.04.14.33.38;  author chrisg;  state Exp;
branches ;
next     39.28;

39.28
date     92.03.26.11.59.18;  author chrisg;  state Exp;
branches ;
next     39.27;

39.27
date     92.03.19.16.07.55;  author chrisg;  state Exp;
branches ;
next     39.26;

39.26
date     92.03.11.11.19.03;  author spence;  state Exp;
branches ;
next     39.25;

39.25
date     92.03.03.10.24.36;  author spence;  state Exp;
branches ;
next     39.24;

39.24
date     92.02.28.12.34.32;  author spence;  state Exp;
branches ;
next     39.23;

39.23
date     92.02.27.16.09.41;  author chrisg;  state Exp;
branches ;
next     39.22;

39.22
date     92.02.27.14.25.21;  author spence;  state Exp;
branches ;
next     39.21;

39.21
date     92.02.25.12.59.30;  author spence;  state Exp;
branches ;
next     39.20;

39.20
date     92.02.24.14.07.40;  author chrisg;  state Exp;
branches ;
next     39.19;

39.19
date     92.02.20.13.43.30;  author chrisg;  state Exp;
branches ;
next     39.18;

39.18
date     92.02.14.15.57.52;  author chrisg;  state Exp;
branches ;
next     39.17;

39.17
date     92.01.29.16.33.08;  author spence;  state Exp;
branches ;
next     39.16;

39.16
date     92.01.29.14.30.38;  author chrisg;  state Exp;
branches ;
next     39.15;

39.15
date     91.12.20.15.39.17;  author chrisg;  state Exp;
branches ;
next     39.14;

39.14
date     91.11.25.16.05.53;  author chrisg;  state Exp;
branches ;
next     39.13;

39.13
date     91.11.21.10.38.16;  author chrisg;  state Exp;
branches ;
next     39.12;

39.12
date     91.11.18.17.46.31;  author spence;  state Exp;
branches ;
next     39.11;

39.11
date     91.11.18.16.38.57;  author spence;  state Exp;
branches ;
next     39.10;

39.10
date     91.11.18.11.42.18;  author chrisg;  state Exp;
branches ;
next     39.9;

39.9
date     91.11.11.16.10.11;  author chrisg;  state Exp;
branches ;
next     39.8;

39.8
date     91.11.11.11.45.14;  author chrisg;  state Exp;
branches ;
next     39.7;

39.7
date     91.11.08.11.29.09;  author chrisg;  state Exp;
branches ;
next     39.6;

39.6
date     91.10.30.15.48.36;  author chrisg;  state Exp;
branches ;
next     39.5;

39.5
date     91.10.30.15.17.06;  author spence;  state Exp;
branches ;
next     39.4;

39.4
date     91.10.29.10.45.21;  author chrisg;  state Exp;
branches ;
next     39.3;

39.3
date     91.10.04.12.19.12;  author chrisg;  state Exp;
branches ;
next     39.2;

39.2
date     91.08.28.11.20.25;  author chrisg;  state Exp;
branches ;
next     39.1;

39.1
date     91.08.27.16.25.25;  author chrisg;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.29.14;  author chrisg;  state Exp;
branches ;
next     38.11;

38.11
date     91.08.20.16.04.43;  author chrisg;  state Exp;
branches ;
next     38.10;

38.10
date     91.08.07.13.44.12;  author chrisg;  state Exp;
branches ;
next     38.9;

38.9
date     91.08.02.15.22.15;  author chrisg;  state Exp;
branches ;
next     38.8;

38.8
date     91.07.12.16.30.26;  author chrisg;  state Exp;
branches ;
next     38.7;

38.7
date     91.07.03.14.32.09;  author chrisg;  state Exp;
branches ;
next     38.6;

38.6
date     91.07.03.10.48.17;  author chrisg;  state Exp;
branches ;
next     38.5;

38.5
date     91.06.19.12.54.30;  author spence;  state Exp;
branches ;
next     38.4;

38.4
date     91.06.18.11.08.06;  author chrisg;  state Exp;
branches ;
next     38.3;

38.3
date     91.06.14.11.07.53;  author chrisg;  state Exp;
branches ;
next     38.2;

38.2
date     91.06.06.14.14.03;  author chrisg;  state Exp;
branches ;
next     38.1;

38.1
date     91.06.03.16.48.07;  author chrisg;  state Exp;
branches ;
next     38.0;

38.0
date     91.05.29.16.37.57;  author chrisg;  state Exp;
branches ;
next     ;


desc
@   Contains new palette functions, including palette allocation management.
@


39.54
log
@create_color_bits() always subtracted 2 from the depth for HAM screens,
but the Blanker commodity would open a 1 bitplane screen of the same type
as the frobtmost screen, so if the front was ham, ccb() would set depth
to -1.
Fixed so that ccb() sets depth to 4 for 5 or 6 bitplane HAM screens, and
to 6 for 7 or 8 bitplane screens. Depths of 4 or less act as non-ham in
the hardware.
@
text
@*******************************************************************************
*
*	$Id: newcolorstuff.asm,v 39.53 93/03/12 12:39:04 chrisg Exp Locker: spence $
*
*******************************************************************************


	SECTION	graphics

	ifd	AA_ONLY
	OPT	P=68020
	endc

	include	'/view.i'
	include	'/gfx.i'

	include	'exec/memory.i'
	include	'exec/ables.i'
	include	'/gfxbase.i'
	include	'/displayinfo.i'
	include	'/vp_internal.i'
	include	'/macros.i'

	include	'hardware/custom.i'

	xref	_LVOAllocMem,_LVOInitSemaphore,_LVOObtainSemaphore,_LVOReleaseSemaphore
	xref	_LVOSetRGB4,_LVOPermit,_LVONextTagItem
	xref	_LVOSetRGB32,_LVOLoadRGB32

	xref	_new_mode,_hedley_load,_update_top_color

	xdef	_AttachPalExtra,_ReleasePen,_SetRGB32,_LoadRGB32
	xdef	_ObtainPen
	
_AttachPalExtra:
******* graphics.library/AttachPalExtra *****************************************
*
*   NAME
*       AttachPalExtra -- Allocate and attach a palette sharing structure to a 
*	                  colormap. (V39)
*
*
*   SYNOPSIS
*       status=AttachPalExtra( cm, vp)
*	                       a0  a1
*
*	LONG AttachPalExtra( Struct ColorMap *, struct ViewPort *);
*
*   FUNCTION
*	Allocates and attaches a PalExtra structure to a ColorMap.
*	This is necessary for color palette sharing to work. The
*	PalExtra structure will be freed by FreeColorMap().
*	The set of available colors will be determined by the mode
*	and depth of the viewport.
*
*   INPUTS
*	cm  =  A pointer to a color map created by GetColorMap().
*
*	vp   = A pointer to the viewport structure associated with
*	       the ColorMap.
*
*   RESULTS
*	status - 0 if sucessful, else an error number. The only currently
*	         defined error number is out of memory (1).
*
*   BUGS
*
*   NOTES
*	This function is for use with custom ViewPorts and custom ColorMaps,
*	as Intuition attaches a PalExtra to all of its Screens.
*	If there is already a PalExtra associated with the ColorMap, then
*	this function will do nothing.
*
*   SEE ALSO
*	GetColorMap() FreeColorMap() ObtainPen() ObtainBestPenA()
*
*********************************************************************************
;
;  The alloc size for a Palette Extra is pe_SIZEOF+2*cm_Count
;
;  For now, the formula for the maximum number of shared colors to make available
;  is 1<<NBITPLANES.
;
;  Needs to make sprite colors unavailable when sprite banking support is complete.
;			(or intuition could do this)
;  For dual playfields, really won't work. there would have to be 2 structures.
;  for 6 bitplane HAM, should make 0..15 available.
;  for 8 bitplane HAM, should make 0,4,8,12... available.
;
;  colors will be allocated from high to low.
;

1$:	movem.l	a0/a2/a3/a4/a5/a6,-(sp)
	move.l	gb_ExecBase(a6),a6		; get execbase

	FORBID							; onl let one process attach it.
	tst.l	cm_PalExtra(a0)
	bne	end_att
	move.l	a1,a5				; save view pointer for later.
	move.l	a0,a2				; save color map pointer in a2 so it doesn't get trashed.
	move	cm_Count(a2),d0
	ext.l	d0
	move.l	d0,d1
	add.l	d0,d0				;*2
	add.l	d1,d0				;*3, 3 because refcnts are words but alloclist is a byte
	add.l	#pe_SIZEOF,d0
	move.l	#MEMF_PUBLIC+MEMF_CLEAR,d1
	jsr	_LVOAllocMem(a6)
	move.l	d0,cm_PalExtra(a2)
	beq.s	end_att				; no memory - don't attach it.
	move.l	d0,a0
	move.l	a0,a3

	ifne	pe_Semaphore
	fail	"change me!!"
	endc

	jsr	_LVOInitSemaphore(a6)		; inits its semaphore
	move.l	a5,pe_ViewPort(a3)
	move	cm_Count(a2),d0
	move.w	#-1,pe_FirstShared(a3)
	lea	pe_SIZEOF(a3),a4
	move.l	a4,pe_RefCnt(a3)
	lea	0(a4,d0.w),a4			; point a4 at alloc list
	add.w	d0,a4				; double it because refcnt is a word
	move.l	a4,pe_AllocList(a3)
; now, we initialize the alloc list to -1,0,1,2,3,4,...
	subq	#1,d0				; adjust for dbra
	moveq	#-1,d1
2$:	move.b	d1,(a4)+
	addq	#1,d1
	dbra	d0,2$
; now, init NFREE to the appropriate number for the viewport
	move.l	vp_RasInfo(a5),d0
	beq.s	end_att
	move.l	d0,a1
	move.l	ri_BitMap(a1),d0
	beq.s	end_att
	move.l	d0,a1
	moveq	#0,d0
	move.b	bm_Depth(a1),d0
	btst	#3,vp_Modes(a5)	; HAM?
	beq.s	no_ham1
	subq	#2,d0
no_ham1:
	tst.b	vp_Modes+1(a5)	; EHB
	bpl.s	no_ehb1
	subq	#1,d0
no_ehb1:
	moveq	#1,d1
	lsl.l	d0,d1
	move.w	d1,pe_NFree(a3)
	subq	#1,d1
	move.w	d1,pe_FirstFree(a3)
	move.w	d1,pe_SharableColors(a3)	
end_att
	jsr	_LVOPermit(a6)
	movem.l	(sp)+,a0/a2/a3/a4/a5/a6
	move.l	cm_PalExtra(a0),d0
	beq.s	retfail
	moveq	#0,d0
	rts
retfail:
	moveq	#1,d0
	rts

none_free:
	moveq	#-1,d0
	rts

	

_ReleasePen:
******* graphics.library/ReleasePen ********************************************
*
*   NAME
*	ReleasePen -- Release an allocated palette entry to the free pool. (V39)
*
*
*   SYNOPSIS
*	ReleasePen( cm, n)
*	            a0 d0
*
*	void ReleasePen( Struct ColorMap *, ULONG);
*
*   FUNCTION
*	Return the palette entry for use by other applications.
*	If the reference count for this palette entry goes to zero,
*	then it may be reset to another RGB value.
*
*   INPUTS
*       cm  =  A pointer to a color map created by GetColorMap().
*
*	n   =  A palette index obtained via any of the palette allocation
*	       functions. Passing a -1 will result in this call doing
*	       nothing.
*
*   BUGS
*
*   NOTES
*	This function works for both shared and exclusive palette entries.
*
*   SEE ALSO
*	GetColorMap() ObtainPen() ObtainBestPenA()
*
*********************************************************************************
	tst.l	d0
	bmi.s	rts_rel_pen
	movem.l	d2/a2/a6,-(sp)
	move.l	cm_PalExtra(a0),a2
	lea	pe_Semaphore(a2),a0
	move.l	gb_ExecBase(a6),a6
	jsr	_LVOObtainSemaphore(a6)		; lock the palette extra info.
	move.l	pe_RefCnt(a2),a0		; get pointer to ref cnt table
	add.w	d0,a0					; double offset for words
	subq.w	#1,0(a0,d0.w)			; ref[i]--
	bne.s	still_some_refs
	addq.w	#1,pe_NFree(a2)			; nfree++
	move.l	pe_AllocList(a2),a0

; now, see if on shared list, and if so, remove it.
	move.w	pe_NShared(a2),d1		; ctr
	beq.s	freed_it			; none shared, so this one can't be.
	move.w	pe_FirstShared(a2),d2		; j=first
	cmp.w	d2,d0				; if (i=first)
	bne.s	list_loop
	move.b	0(a0,d0.l),pe_FirstShared+1(a2)	;  then first=i->next
	bra.s	freed_shared
list_loop:
	subq	#1,d1
	beq.s	freed_it			; not on shared list.
	cmp.b	0(a0,d2.w),d0			; if (j->next=i)
	beq.s	found_shared
	move.b	0(a0,d2.w),d2
	bra.s	list_loop
found_shared:
	move.b	0(a0,d0.w),0(a0,d2.w)		;   then j->next=i->next
freed_shared:
	subq.w	#1,pe_NShared(a2)
freed_it:
	move.b	pe_FirstFree+1(a2),0(a0,d0.w)	; n->next=first
	move.w	d0,pe_FirstFree(a2)		; first=n

still_some_refs:
	lea	pe_Semaphore(a2),a0
	jsr	_LVOReleaseSemaphore(a6)
	movem.l	(sp)+,d2/a2/a6
rts_rel_pen:
	rts

_ObtainPen:
******* graphics.library/ObtainPen **********************************************
*
*   NAME
*	ObtainPen -- Obtain a free palette entry for use by your program. (V39)
*
*
*   SYNOPSIS
*	n = ObtainPen( cm, n, r, g, b, flags)
*	d0	       a0 d0  d1 d2 d3  d4
*
*	LONG ObtainPen(struct ColorMap *,ULONG,ULONG,ULONG,ULONG,ULONG);
*
*   FUNCTION
*	Attempt to allocate an entry in the colormap for use by the application.
*	If successful, you should ReleasePen() this entry after you have finished
*	with it.
*	
*	Applications needing exclusive use of a color register (say for color
*	cycling) will typically call this function with n=-1. Applications needing
*	only the shared use of a color will typically use ObtainBestPenA() instead.
*	Other uses of this function are rare.
*
*   INPUTS
*	cm  =  A pointer to a color map created by GetColorMap().
*	n   =  The index of the desired entry, or -1 if any one is acceptable
*	rgb =  The RGB values (32 bit left justified fractions) to set the new
*	       palette entry to.
*	flags= PEN_EXCLUSIVE - tells the system that you want exclusive
*	       (non-shared) use of this pen value. Default is shared access.
*
*	       PEN_NO_SETCOLOR - tells the system to not change the rgb values
*	       for the selected pen. Really only makes sense for exclusive pens.
*
*
*   RESULTS
*
*	n   =  The allocated pen. -1 will be returned if there is no pen available
*	       for you.
*
*   BUGS
*
*   NOTES
*	When you allocate a palette entry in non-exclusive mode, you
*	should not change it (via SetRGB32), because other programs on the
*	same screen may be using it. With PEN_EXCLUSIVE mode, you can
*	change the returned entry at will.
*
*	To avoid visual artifacts, you should not free up a palette
*	entry until you are sure that your application is not displaying
*	any pixels in that color at the time you free it. Otherwise, another
*	task could allocate and set that color index, thus changing the colors
*	of your pixels.
*
*	Generally, for shared access, you should use ObtainBestPenA()
*	instead, since it will not allocate a new color if there is one
*	"close enough" to the one you want already.
*	If there is no Palextra attached to the colormap, then this
*	routine will always fail. 
*
*   SEE ALSO
*	GetColorMap() ReleasePen() AttachPalExtra() ObtainBestPenA()
*
*********************************************************************************


	movem.l	a2/d6/d7,-(a7)
	movem.l	a6/d1/d2/d3,-(a7)
	moveq	#-1,d7				; return value
	cmp.w	cm_Count(a0),d0
	bgt	return2				; handles negative or > count.
	tst.l	cm_PalExtra(a0)			; colorinfo fattened?
	beq	return2
	move.l	cm_PalExtra(a0),a2		; a2=pal extra

	lea	pe_Semaphore(a2),a0
	move.l	gb_ExecBase(a6),a6
	jsr	_LVOObtainSemaphore(a6)

	tst.w	pe_NFree(a2)			; any available?
	beq	no_set_rgb32
	
	move.l	pe_RefCnt(a2),a0
	tst.l	d0				; a specific one, or the next one?
	bmi.s	want_any_one			; any ol' one will do

	cmp.w	pe_SharableColors(a2),d0	; if not allocable, fail
	bhi.s	return1

	IFND	AA_ONLY
	add.l	d0,d0
	tst.w	0(a0,d0.l)			; ref cnt==0?
	bne.s	return1
	addq.w	#1,0(a0,d0.l)			; bump ref cnt
	lsr.l	#1,d0
	else
	tst.w	(a0,d0.l*2)
	bne.s	return1
	addq.w	#1,(a0,d0.l*2)
	endc


	move.l	d0,d7				; return success
	move.l	pe_AllocList(a2),a0
	subq.w	#1,pe_NFree(a2)			; nfree--
	beq.s	check_exclusive
	move.w	pe_FirstFree(a2),d6
	cmp.w	d6,d0				; first=got?
	bne.s	must_traverse_list
	move.b	0(a0,d0.l),d6
	move.w	d6,pe_FirstFree(a2)		; first=first->next
	bra.s	check_exclusive
must_traverse_list:
	cmp.b	0(a0,d6.w),d0			; i->next=n?
	bne.s	iter_again
	move.b	0(a0,d0.w),0(a0,d6.w)		; i->next=n->next
	bra.s	check_exclusive
iter_again:
	move.b	0(a0,d6.w),d6			; i = i->next
	bra.s	must_traverse_list


want_any_one:
	moveq	#0,d7				; zero upper bits
	subq.w	#1,pe_NFree(a2)			; dec avail count
	move.w	pe_FirstFree(a2),d7		; get next avail
	IFND	AA_ONLY
	add.w	d7,d7
	addq.w	#1,0(a0,d7.w)			; refcnt[alloc]++
	lsr.w	#1,d7
	else
	addq.w	#1,(a0,d7.w*2)
	endc

	move.l	pe_AllocList(a2),a0
	move.b	0(a0,d7.w),pe_FirstFree+1(a2)	; firstfree=alloc->next

check_exclusive:
; now, a0=alloc list a2=palextra, d7=color #
	btst	#0,d4				; PALETTE_EXCLUSIVE?
	bne.s	return1
; not exclusive, so add it to shared list.
	addq.w	#1,pe_NShared(a2)
	move.b	pe_FirstShared+1(a2),0(a0,d7.w)
	move.w	d7,pe_FirstShared(a2)
	
return1:
; now, set the color
	move.l	d7,d0
	bmi.s	no_set_rgb32
	btst	#1,d4
	bne.s	no_set_rgb32
	movem.l	(sp),a6/d1/d2/d3
	move.l	pe_ViewPort(a2),a0
	jsr	_LVOSetRGB32(a6)
	move.l	gb_ExecBase(a6),a6
no_set_rgb32:
	lea	pe_Semaphore(a2),a0
	jsr	_LVOReleaseSemaphore(a6)
return2:
	move.l	d7,d0
	movem.l	(sp)+,a6/d1/d2/d3
	movem.l	(a7)+,a2/d6/d7
	rts

replicate	macro	reg
; replicate 8 bits to all 32
; ab000000 -> abababab
	move.l	\1,d0	; d0=ab000000
	lsr.l	#8,d0	; d0=00ab0000
	or.l	\1,d0	; d0=abab0000
	move.l	d0,\1	; \1=abab0000
	swap	d0	; d0=0000abab
	or.l	d0,\1	; \1=abababab
	endm

******* graphics.library/GetRGB32 ********************************************
*
*   NAME
*	GetRGB32 -- Set a series of color registers for this Viewport. (V39)
*
*   SYNOPSIS
*	GetRGB32(  cm,  firstcolor, ncolors, table )
*	           a0   d0   		d1    a1
*
*       void GetRGB32( struct ColorMap *, ULONG, ULONG, ULONG *);
*
*   INPUTS
*	cm = colormap
*	firstcolor = the first color register to get
*	ncolors = the number of color registers to set.
*	table=a pointer to a series of 32-bit RGB triplets.
*
*   RESULT
*	The ULONG data pointed to by 'table' will be filled with the 32 bit
*	fractional RGB values from the colormap.
*   BUGS
*
*   NOTES
*	'Table' should point to at least ncolors*3 longwords.
*
*   SEE ALSO
*	LoadRGB4() GetColorMap() LoadRGB32() SetRGB32CM() graphics/view.h
******************************************************************************
	xdef	_GetRGB32
_GetRGB32:
	movem.l	a2/a3/d2-d7,-(a7)
	move.l	cm_ColorTable(a0),a2
	move.l	a2,a3
	btst.b	#GFXB_AA_LISA,gb_ChipRevBits0(a6)
	beq.s	no_lowbits1
	tst.b	cm_Type(a0)
	beq.s	no_lowbits1
	tst.l	cm_LowColorBits(a0)
	beq.s	no_lowbits1
	move.l	cm_LowColorBits(a0),a3
no_lowbits1:
	add.l	d0,d0
	add.l	d0,a2
	add.l	d0,a3
	subq.l	#1,d1			; adjust for DBRA
	move.l	#$f0000000,d5
	move.l	#$0f000000,d6
getrgb32_lp:
	move.w	(a2)+,d0		; 0RGB
	lsl.w	#4,d0			; RGB0
	swap	d0
	move.l	d0,d2
	and.l	d5,d2			; R000000
	lsl.l	#4,d0
	move.l	d0,d3
	and.l	d5,d3			; G000000
	lsl.l	#4,d0
	move.l	d0,d4
	and.l	d5,d4
	move.w	(a3)+,d0		; 0RGB
	swap	d0
	clr.w	d0
	move.l	d0,d7
	and.l	d6,d7			; 0R000000
	or.l	d7,d2
	lsl.l	#4,d0
	move.l	d0,d7
	and.l	d6,d7
	or.l	d7,d3
	lsl.l	#4,d0
	and.l	d6,d0
	or.l	d0,d4
	replicate	d2
	replicate	d3
	replicate	d4
	movem.l	d2/d3/d4,(a1)
	lea	4*3(a1),a1	
	dbra	d1,getrgb32_lp
	movem.l	(a7)+,d2-d7/a2-a3
	rts


******* graphics.library/LoadRGB32 ********************************************
*
*   NAME
*	LoadRGB32 -- Set a series of color registers for this Viewport. (V39)
*
*   SYNOPSIS
*	LoadRGB32(  vp,  table )
*	            a0   a1
*
*	void LoadRGB32( struct ViewPort *, ULONG *);
*
*   INPUTS
*	vp = viewport
*	table = a pointer to a series of records which describe which colors to
*	        modify.
*   RESULT
*	The selected color registers are changed to match your specs.
*   BUGS
*
*   NOTES
*
*	Passing a NULL "table" is ignored.
*	The format of the table passed to this function is a series of records,
*	each with the following format:
*
*	        1 Word with the number of colors to load
*	        1 Word with the first color to be loaded.
*	        3 longwords representing a left justified 32 bit rgb triplet.
*	        The list is terminated by a count value of 0.
*
*	   examples:
*	        ULONG table[]={1l<<16+0,0xffffffff,0,0,0} loads color register
*	                0 with 100% red.
*	        ULONG table[]={256l<<16+0,r1,g1,b1,r2,g2,b2,.....0} can be used
*	                to load an entire 256 color palette.
*
*	Lower order bits of the palette specification will be discarded,
*	depending on the color palette resolution of the target graphics
*	device. Use 0xffffffff for the full value, 0x7fffffff for 50%,
*	etc. You can find out the palette range for your screen by
*	querying the graphics data base.
*
*	LoadRGB32 is faster than SetRGB32, even for one color.
*
*   SEE ALSO
*	LoadRGB4() GetColorMap() GetRGB32() SetRGB32CM() graphics/view.h
******************************************************************************
_LoadRGB32:
	move.l	a1,d0
	beq	loadrgb_exit
	movem.l	d2-d7/a2-a5,-(a7)
	move.l	a6,-(a7)
	move.l	a0,a2
	move.l	vp_ColorMap(a2),a0
	move.l	cm_ColorTable(a0),a3
	move.l	a3,a4
	tst.b	cm_Type(a0)
	beq.s	old_cmap
	move.l	cm_LowColorBits(a0),a4
old_cmap:
	move.w	#$0f00,d5
	move.w	#$f000,d6
loadrgb_lp:
	move.w	(a1)+,d1	; count
	beq.s	done_loadlp
	move.w	(a1)+,d0	; start color
; a=firstc+count-cm_ncolors
; if a>0, { count -=a; modulo=12*a }
; else modulo=0;
	move	d1,d7
	add.w	d0,d7
	sub.w	cm_Count(a0),d7
	ext.l	d7
	bgt.s	non_zero_modulo
	moveq	#0,d7
non_zero_modulo:
	sub	d7,d1
	add.l	d7,d7		;*2
	add.l	d7,d7		;*4
	move.l	d7,a5
	add.l	d7,d7		;*8
	add.l	a5,d7		;*8+*4=*12

	IFND	AA_ONLY
	add.w	d0,d0
	lea	0(a3,d0.w),a5
	lea	0(a4,d0.w),a6
	else
	lea	(a3,d0.w*2),a5
	lea	(a4,d0.w*2),a6
	endc
	bra.s	lrgb_end_lp1		; d1 could be zero
lrgbinner:
	movem.l	(a1),d2/d3/d4			; rgb
	swap	d2
	and.w	d5,d2
	swap	d3
	and.w	d5,d3
	lsr.w	#4,d3
	or.w	d3,d2
	swap	d4
	and.w	d5,d4
	lsr.w	#8,d4
	or.w	d4,d2
	move.w	d2,(a6)+
	movem.l	(a1)+,d2/d3/d4
	swap	d2
	and.w	d6,d2
	swap	d3
	and.w	d6,d3
	lsr.w	#4,d3
	or.w	d3,d2
	swap	d4
	and.w	d6,d4
	lsr.w	#8,d4
	or.w	d4,d2
	lsr.w	#4,d2
	move.w	(a5),d3
	and.w	#$8000,d3
	or.w	d3,d2
	move.w	d2,(a5)+
lrgb_end_lp1:
	dbra	d1,lrgbinner
	add.l	d7,a1
	bra	loadrgb_lp
done_loadlp:
	move.l	(a7)+,a6
	bsr.s	_pokecolors			; vp in a2
	movem.l	(a7)+,d2-d7/a2-a5
loadrgb_exit:
	rts


******* graphics.library/SetRGB32 ********************************************
*
*   NAME
*	SetRGB32 -- Set one color register for this Viewport. (V39)
*
*   SYNOPSIS
*	SetRGB32(  vp,  n,   r,    g,    b)
*	           a0  d0   d1    d2    d3
*
*	void SetRGB32( struct ViewPort *, ULONG, ULONG, ULONG, ULONG );
*
*   INPUTS
*	vp = viewport
*	n = the number of the color register to set.
*	r = red level   (32 bit left justified fraction)
*	g = green level (32 bit left justified fraction)
*	b = blue level  (32 bit left justified fraction)
*
*   RESULT
*	If there is a ColorMap for this viewport, then the value will
*	be stored in the ColorMap.
*	The selected color register is changed to match your specs.
*	If the color value is unused then nothing will happen.
*
*   BUGS
*
*   NOTES
*	Lower order bits of the palette specification will be discarded,
*	depending on the color palette resolution of the target graphics
*	device. Use 0xffffffff for the full value, 0x7fffffff for 50%,
*	etc. You can find out the palette range for your screen by
*	querying the graphics data base.
*
*   SEE ALSO
*	GetColorMap() GetRGB32() SetRGB32CM() LoadRGB32() graphics/view.h
******************************************************************************

_SetRGB32:
	clr.l	-(a7)
	move.l	d3,-(a7)
	move.l	d2,-(a7)
	move.l	d1,-(a7)
	or.l	#$10000,d0
	move.l	d0,-(a7)
	move.l	a7,a1
	jsr	_LVOLoadRGB32(a6)
	lea	20(a7),a7
an_rts:
	rts

	xdef	_pokecolors
_pokecolors:
; pokecolors - repoke the hardware copper lists and the CopIns for the colors of
; a viewport.
;
;	void _pokecolors(register __a2 struct ViewPort *vp)
;
;   algorithm:
;
;	obtain cpr list semaphore
;	for each long word in mask
;		set ptr=the next write to bplcon3.
;		if the longword is not zero
;			skip bplcon3
;			for i=0 to 32
;				if (this color used)
;					if (*ptr) != 180+i	abort
;					poke high word
;				else skip
;			skip bplcon3
;			for i=0 to 32
;				if (this color used)
;					if (*ptr) != 180+i	abort
;					poke low word
;				else skip


_pokecolors:
	tst.l	vp_ColorMap(a2)
	beq.s	an_rts
	move.l	a2,a0
	vp_to_vector	a0,vt_PokeColors,_DefaultPokeColors(pc)
	jmp	(a0)

	xdef	_DefaultPokeColors

_DefaultPokeColors:
	movem.l	d2-d7/a0-a6,-(a7)
	move.l	a2,-(a7)
	jsr	_new_mode
	addq.l	#4,a7
	move.l	d0,d5					; d5=modes(vp)
	lea	-64(a7),a7				; 256 bits+32 words (a7)=bits 32(a7)=color scramble data

	move.w	#$7fff,d6					; d6=color AND word
	move.l	vp_ColorMap(a2),a1
	btst	#0,cm_Flags(a1)			; colormap_transparency?
	beq.s	no_chroma_pen
	moveq	#-1,d6
no_chroma_pen:
; now for the fun part!
	move.l	a6,-(a7)
	move.b	gb_ChipRevBits0(a6),d4
	moveq	#0,d7
	move.l	gb_ActiViewCprSemaphore(a6),a0
	move.l	gb_ExecBase(a6),a6
	cmp.l	SysStkUpper(a6),a7			; might we be in an interrupt?
	bhi.s	no_interrupt1
	cmp.l	SysStkLower(a6),a7
	blo.s	no_interrupt1
	cmp.w	#-1,SS_QUEUECOUNT(a0)
	bne.s	yes_interrupt1
no_interrupt1:
	move.l	a0,d7
	jsr	_LVOObtainSemaphore(a6)
yes_interrupt1:
	move.l	vp_DspIns(a2),d0
	beq	no_dspins
	move.l	d0,a4					; a4=DspIns=CopList ptr
	move.w	vp_Modes(a2),d0
	and.w	#V_VP_HIDE,d0
	bne	no_dspins
	move.l	cl_CopLStart(a4),a5			; a5=long frame ptr
	move.l	cl_CopSStart(a4),a4			; a4=short frame pointer
	move.l	cm_ColorTable(a1),a6
	move.l	cm_LowColorBits(a1),a0
	tst.b	cm_Type(a1)
	bne.s	new_colormap1
	move.l	a6,a0					; set low words=high words
new_colormap1:
; now:
; a0=low color words
; a1=color map
; a2=vp
; a3=
; a4=short frame hw copper list
; a5=long frame hw copper list
; a6=colortable
; d4=chip rev bits
; d5=viewport modes
; d6=AND value for color words.
	btst	#5,d5					; shres?
	beq.s	no_scramble1
	btst.b	#GFXB_AA_MLISA,d4
	bne.s	no_scramble1
;  now, repoint a0 and a6 at the scrambled workspace
	move.l	a1,-(a7)
	lea	8(a7),a1				; a6 and a1 are on stack right now
	move.l	a6,a0
	bsr	_scramble_colors			; *(a1++)=scrambled data
	lea	32(a6),a0				; scramble colors 16-19
	bsr	_scramble_colors
	move.l	(a7)+,a1
	lea	4(a7),a6				; a6 still on stack
	move.l	a6,a0
no_scramble1:
	move.w	#color,d0
	move.w	#bplcon3-color,d2
	move.w	#32*2,d3
	move.w	#%1110000000000000,d4
; now:
; a0=low color words
; a1=color map
; a2=vp
; a3=
; a4=short frame hw copper list
; a5=long frame hw copper list
; a6=colortable
; d0=#color
; d1=scratch
; d2=#bplcon3-color0
; d3=64 (color limit)
; d4=%1110000000000000 (bplcon3 bank mask)
; d5=scratch
; d6=AND value for color words.
; d7=interrupt flag

	move.l	a5,d5
	move.l	a4,d1
	beq.s	skip_shf
	lea	skip_shf(pc),a3
do_hw_clist:
; poke a hardware copper list for colors
; entr a4=&cl 
; a0=low colors a6=high colors
; usage:
; a5=cur list + offset
; a3=where to return to
	move.l	a6,a5
1$:	cmp.w	(a4),d0
	lea	4(a4),a4
	bne.s	1$
	move.w	(a5),d1
	and.w	d6,d1
	move.w	d1,-2(a4)
; now, we have handled color 0. We must now enter the following loop:
; switch (*c++)
;  case COLORnn
;   *c++=*(a5+nn) & d6
;  case BPLCON3:
;   if (*c & 512) a5=a0 else a5=a6
;   a5 += (*c & %1110000000000000) >> 8
;  else
;    done
next_hwins
	move.w	(a4)+,d1
	sub.w	d0,d1
	blo.s	not_color_load
	cmp.w	d3,d1
	bhs.s	done_hwlist
	move.w	0(a5,d1.w),d1
	and.w	d6,d1
	move.w	d1,(a4)+
	move.w	(a4)+,d1
	sub.w	d0,d1
	blo.s	not_color_load
	cmp.w	d3,d1
	bhs.s	done_hwlist
	move.w	0(a5,d1.w),d1
	and.w	d6,d1
	move.w	d1,(a4)+
	bra.s	next_hwins
not_color_load:
	cmp.w	d2,d1
	bne.s	done_hwlist
; it's bplcon3!
	move.w	(a4)+,d1
	move.l	a0,a5
	btst	#9,d1
	bne.s	1$
	move.l	a6,a5
1$:	and.w	d4,d1
	lsr.w	#7,d1
	add.w	d1,a5
	bra.s	next_hwins
done_hwlist:
	jmp	(a3)
skip_shf:
	tst.l	d5
	beq.s	skip_lof
	lea	skip_lof(pc),a3
	move.l	d5,a4
	bra.s	do_hw_clist

skip_lof:
	btst	#CMAB_NO_INTERMED_UPDATE,cm_AuxFlags(a1)
	bne.s	dont_do_intermed
	move.l	a6,a5
	move.l	vp_DspIns(a2),a2
	move.l	cl_CopIns(a2),a2
	cmp.w	#0,a2
	bne.s	find_color0_noinc
dont_do_intermed:
no_dspins:
	move.l	(a7)+,a6					; get back gfxbase
	move.l	gb_current_monitor(a6),-(a7)
	bsr	_update_top_color
	addq.l	#4,a7
	tst.l	d7
	beq.s	i_was_in_an_interrupt
	move.l	d7,a0
	move.l	gb_ExecBase(a6),a6
	jsr	_LVOReleaseSemaphore(a6)
i_was_in_an_interrupt:
	lea	64(a7),a7
	movem.l	(a7)+,d2-d7/a0-a6
	rts

find_color0_intermed:
	lea	ci_SIZEOF(a2),a2
find_color0_noinc:
	move.w	ci_OpCode(a2),d1
	and.w	#3,d1
	bne.s	find_color0_intermed
	move.w	ci_DestAddr(a2),d1
	cmp.w	d0,d1					; color?
	bne.s	find_color0_intermed
; now, we are pointing at color0!
	move.w	(a5),d1
	and.w	d6,d1
	move.w	d1,ci_DestData(a2)
	lea	ci_SIZEOF(a2),a2
; now, we must execute the same basic algorithm as in do_hwclist, except that it is more
; annoying.
next_intermed_opcode:
	move.w	(a2)+,d1	; opcode
	and.w	#3,d1
	bne.s	dont_do_intermed
	move.w	(a2)+,d1
	sub.w	d0,d1
	blo.s	not_color_load_i
	cmp.w	d3,d1
	bhs.s	dont_do_intermed
	move.w	0(a5,d1.w),d1
	and.w	d6,d1
	move.w	d1,(a2)+
	move.w	(a2)+,d1	; opcode
	and.w	#3,d1
	bne.s	dont_do_intermed
	move.w	(a2)+,d1
	sub.w	d0,d1
	blo.s	not_color_load_i
	cmp.w	d3,d1
	bhs.s	dont_do_intermed
	move.w	0(a5,d1.w),d1
	and.w	d6,d1
	move.w	d1,(a2)+
	bra.s	next_intermed_opcode

not_color_load_i:
	cmp.w	d2,d1
	bne.s	dont_do_intermed
	move.w	(a2)+,d1
	move.l	a0,a5
	btst	#9,d1
	bne.s	1$
	move.l	a6,a5
1$:	and.w	d4,d1
	lsr.w	#7,d1
	add.w	d1,a5
	bra.s	next_intermed_opcode




get_32bit_color:
; a3=cm
; d0=index
; exit d5/d6/d7=rgbcolors
; trashes d2,d0,a0
	add.w	d0,d0
	move.l	cm_ColorTable(a3),a0
	moveq	#0,d5
	move.w	0(a0,d0.w),d5
	move.l	d5,d6
	move.l	d5,d7
	and.w	#$0f00,d5
	and.w	#$00f0,d6
	and.w	#$000f,d7
	lsl.l	#4,d5
	swap	d5				; d5=red
	lsl.l	#8,d6
	swap	d6				; d6=green
	ror.l	#4,d7				; d7=red
	move.l	cm_LowColorBits(a3),a0
	move.w	0(a0,d0.w),d2
	and.l	#$0f00,d2
	swap	d2
	or.l	d2,d5
	move.w	0(a0,d0.w),d2
	and.l	#$00f0,d2
	lsl.l	#4,d2
	swap	d2
	or.l	d2,d6
	move.w	0(a0,d0.w),d2
	and.l	#$000f,d2
	lsl.l	#8,d2
	swap	d2
	or.l	d2,d7				; yuck! now, we finally have the RGB
						; values from the colormap in fractional
						; format in d5/d6/d7

	rts

_SearchColorMap:
*       Search for a close color match, using a user-supplied procedure. (V39)
*
*   SYNOPSIS
*       color | -1 =SearchColorMap(  cm,  proc, R, G, B, MaxError, MaxColor, RealMax)
*                                    a0     a1 d1  d2 d3     d4	   d5		d6
*
*       ULONG SearchColorMap( struct ColorMap *, (*int)(), ULONG, ULONG, ULONG,
*				ULONG, ULONG );
*
*   INPUTS
*	cm = colormap
*       proc = the procedure to call for each color candidate.
*       R = red level   (32 bit left justified fraction)
*       G = green level (32 bit left justified fraction)
*       B = blue level  (32 bit left justified fraction)
*       MaxError = the maximum permissible error value for a match.
*	MaxColor = the maximum color index that you want. -1 for any valid one.
*   RESULT
*	Your procedure will be called for each shared entry in the colormap.
*	Your procedure will be passed the RGB values supplied to the call
*	in d1/d2/d3, and the RGB values from the color map in d5/d6/d7.
*	Your function should return the error value in d0. Your function will
*	be called until it returns a zero, or until there are no more colors
*	to examine.
*	If no match was found with a return of less then the value passed in
*	the MaxError parameter, then a new one will be allocated if available,
*	and its RGB values set to the ones passed. This color will be returned.
*	If no palette entry was found within the error tolerance, and there are none
*	available for allocation, then the closest one found will be returned.
*	If one was found within the tolerance passed by the application, then
*	it will be returned, and its reference count will be bumped.
*	If there are no sharable palette entries available, then -1 will be returned.
*
*   BUGS
*
*   NOTES
*	If this call succceeds, then you must call ReleasePen() when you are done
*	with the color.
*	Lower order bits of the palette specification will be discarded,
*	depending on the color palette resolution of the target graphics
*	device. Use 0xffffffff for the full value, 0x7fffffff for 50%,
*	etc. You can find out the palette range for your screen by
*	querying the graphics data base.
*	For most applications, you should call ObtainBestPenA(), and not this
*	function. This is provided for an application which might want to
*	optimize its palette error metrics differently. ObatinBestPen() also
*	works better in shared screens, because it changes its tolerances based
*	on the amount of space free in the palette.
*
*   SEE ALSO
*	GetColorMap() ObtainBestPenA() ReleasePen() ObtainPen()
******************************************************************************
ofs_closest_error	equ	0
ofs_closest_color	equ	ofs_closest_error+4
ofs_match_rgb		equ	ofs_closest_color+4
ofs_maxerr		equ	ofs_match_rgb+12
ofs_jmpvector		equ	ofs_maxerr+4
ofs_counter		equ	ofs_jmpvector+4
ofs_gbase		equ	ofs_counter+4
ofs_flags		equ	ofs_gbase+4
ofs_colormask	equ	ofs_flags+4
ofs_realmax	equ	ofs_colormask+4
ofs_stacksize		equ	ofs_realmax+4


	move.l	cm_PalExtra(a0),d0
	movem.l	d2-d7/a2-a6,-(a7)
	sub.l	#ofs_stacksize,a7
	move.l	d6,ofs_realmax(a7)
	move.l	d5,ofs_flags(a7)
	move.l	a6,ofs_gbase(a7)
	move.l	#-1,ofs_closest_error(a7)
	move.l	#-1,ofs_closest_color(a7)
	move.l	gb_ColorMask(a6),d7
	move.l	d7,ofs_colormask(a7)
	and.l	d7,d1
	and.l	d7,d2
	and.l	d7,d3
	movem.l	d1/d2/d3,ofs_match_rgb(a7)
	move.l	d4,ofs_maxerr(a7)
	move.l	a1,ofs_jmpvector(a7)

	move.l	d0,a2				; a2=palextra
	move.l	a0,a3				; a3=color map
	move.l	gb_ExecBase(a6),a6		; a6=execbase
	lea	pe_Semaphore(a2),a0		
	jsr	_LVOObtainSemaphore(a6)
	move.l	pe_AllocList(a2),a4		; a4=alloc list

	moveq	#0,d0
	move.w	pe_NShared(a2),d0		; load and sign extend
	beq.s	no_match_try_new_one
	move.l	d0,ofs_counter(a7)		; number of shared entries to examine
	move.w	pe_FirstShared(a2),a5		; a5=color index being checked
check_next_color:
; now, a5=color index to try. Unpack it to d5/d6/d7
	move	a5,d0
	bsr	get_32bit_color

	move.l	ofs_colormask(a7),d1
	and.l	d1,d5
	and.l	d1,d6
	and.l	d1,d7
	movem.l	ofs_match_rgb(a7),d1/d2/d3
	move.l	ofs_jmpvector(a7),a1
	jsr	(a1)
	tst.l	d0				; exact match?
	beq.s	exact_match
	cmp.l	ofs_closest_error(a7),d0
	bhs.s	no_closer
	move.l	d0,ofs_closest_error(a7)
	move.l	a5,ofs_closest_color(a7)
no_closer:
	subq.l	#1,ofs_counter(a7)
	beq.s	got_last
	moveq	#0,d0
	move.b	0(a4,a5),d0			; i=i->next
	move.l	d0,a5
	bra	check_next_color
exact_match:
	move.l	a5,ofs_closest_color(a7)
	bra.s	can_use_old
got_last:
	move.l	ofs_maxerr(a7),d1
	cmp.l	ofs_closest_error(a7),d1
	blo.s	no_match_try_new_one
	move.l	ofs_realmax(a7),d1
	cmp.l	ofs_closest_error(a7),d1
	bhs.s	can_use_old
	bra.s	cant_get
no_match_try_new_one:
	tst.w	pe_NFree(a2)			; any free?
	bne.s	can_do_new
	tst.l	ofs_flags(a7)
	beq.s	can_use_old			; none free, so use whatever was closest
cant_get:
	move.l	#-1,ofs_closest_color(a7)
	bra.s	can_use_old
can_do_new:
; must allocate a new one.
	subq.w	#1,pe_NFree(a2)
	addq.w	#1,pe_NShared(a2)
	moveq	#0,d0
	move.w	pe_FirstFree(a2),d0
	move.l	d0,ofs_closest_color(a7)
	moveq	#0,d1
	move.b	0(a4,d0.w),d1
	move.w	d1,pe_FirstFree(a2)
	move.w	pe_FirstShared(a2),d1
	move.b	d1,0(a4,d0.w)
	move.w	d0,pe_FirstShared(a2)
	move.l	ofs_gbase(a7),a6
	move.l	pe_ViewPort(a2),a0
	move.l	ofs_closest_color(a7),d0
	movem.l	ofs_match_rgb(a7),d1/d2/d3
	jsr	_LVOSetRGB32(a6)			; should call thru vector!!!
	move.l	gb_ExecBase(a6),a6

can_use_old:
	move.l	ofs_closest_color(a7),d0	; return value
	bmi.s	dont_bump_refcnt		; valid color or failure?
	move.l	pe_RefCnt(a2),a0
	IFND	AA_ONLY
	add.l	d0,d0
	addq.w	#1,0(a0,d0.l)
	lsr.l	#1,d0
	else
	addq.w	#1,(a0,d0.l*2)
	endc
dont_bump_refcnt:
	lea	pe_Semaphore(a2),a0
	jsr	_LVOReleaseSemaphore(a6)
	move.l	ofs_closest_color(a7),d0
	add.l	#ofs_stacksize,a7
	movem.l	(a7)+,d2-d7/a2-a6
	rts

				
default_color_matcher:
; passed rgb in d1/d2/d3 and d5/d6/d7
	swap	d1
	swap	d2
	swap	d3
	swap	d5
	swap	d6
	swap	d7
	lsr.w	#4,d1
	lsr.w	#4,d2
	lsr.w	#4,d3
	lsr.w	#4,d5
	lsr.w	#4,d6
	lsr.w	#4,d7

	sub.w	d1,d5
	bpl.s	1$
	neg.w	d5
1$:	sub.w	d2,d6
	bpl.s	2$
	neg.w	d6
2$:	sub.w	d3,d7
	bpl.s	3$
	neg.w	d7
3$:
	cmp.w	d6,d5
	bgt.s	not_d6
	exg		d5,d6
not_d6:
	cmp.w	d7,d5
	bgt.s	not_d7
	exg		d7,d5
not_d7:
	cmp.w	d7,d6
	bgt.s	no_d6_lowest
	exg		d7,d6
no_d6_lowest:
; now, d5-d6-d7 are ordered
	lsr.w	#1,d6
	lsr.w	#2,d7
	moveq	#0,d0
	move.w	d5,d0
	add.w	d6,d0
	add.w	d7,d0
	rts


******* graphics.library/FindColor *****************************************
*
*   NAME
*	FindColor -- Find the closest matching color in a colormap. (V39)
*
*   SYNOPSIS
*	color = FindColor(  cm,  R,   G,    B , maxpen)
*	                   a3   d1   d2    d3   d4
*
*	ULONG FindColor( struct ColorMap *, ULONG, ULONG, ULONG,LONG);
*
*   INPUTS
*	cm = colormap
*	R = red level   (32 bit left justified fraction)
*	G = green level (32 bit left justified fraction)
*	B = blue level  (32 bit left justified fraction)
*	MaxPen = the maximum entry in the color table to search. A value of
*	        -1 will limt the search to only those pens which could be
*	        rendered in (for instance, it will not examine the sprite
*	        colors on a 4 color screen).
*
*
*   RESULT
*	The system will attempt to find the color in the passed colormap
*	which most closely matches the RGB values passed. No new pens will
*	be allocated, and you should not ReleasePen() the returned pen.
*	This function is not sensitive to palette sharing issues. Its
*	intended use is for:
*
*	        (a) programs which pop up on public screens when those
*	            screens are not using palette sharing. You might
*	            use this function as a fallback when ObtainBestPenA()
*	            says that there are no sharable pens.
*
*	        (b) Internal color matching by an application which is
*	            either running on a non-public screen, or which
*	            wants to match colors to an internal color table
*	            which may not be associated with any displayed screen.
*
*   BUGS
*
*   NOTES
*	In order to use the MaxPen=-1 feature, you must have initialized
*	palette sharing via AttachPalExtra() (all intuition screens do this).
*	Otherwise, MaxPen=-1 will search all colors in the colormap.
*
*
*   SEE ALSO
*	ObtainBestPenA() GetColorMap() ObtainPen() ReleasePen()
******************************************************************************
_FindColor::
	movem.l	d2-d7/a4,-(a7)
	tst.l	d4
	bpl.s	no_def_maxpen
	moveq	#0,d4
	move.w	cm_Count(a3),d4
	move.l	cm_PalExtra(a3),d0
	beq.s	no_def_maxpen
	move.l	d0,a0
	move.w	pe_SharableColors(a0),d4
no_def_maxpen:
	moveq	#-1,d0
	move.l	d0,a1			; a1-retval
	move.l	d0,a4			; a4=best match so far
	movem.l	d1/d2/d3,-(a7)
search_lp:
	move.l	d4,d0
	bsr	get_32bit_color		; d5/d6/d7=cm[d0]
	movem.l	(a7),d1/d2/d3		; get back user's colors
	bsr	default_color_matcher	; d0=err value
	cmpa.l	d0,a4
	bls.s	end_lp1
	move.l	d0,a4
	move.l	d4,a1
end_lp1:
	dbra	d4,search_lp
	lea	3*4(a7),a7
	move.l	a1,d0
	movem.l	(a7)+,d2-d7/a4
	rts

_ObtainBestPenA::
******* graphics.library/ObtainBestPenA ****************************************
*
*   NAME
*	ObtainBestPenA --- Search for the closest color match, or allocate a
*	                   new one. (V39)
*	ObtainBestPen  --- varargs stub for ObtainBestPenA
*
*   SYNOPSIS
*	color | -1 =ObtainBestPenA(  cm,  R,   G,    B,    taglist)
*	                             a0   d1   d2    d3       a1
*
*	LONG ObtainBestPenA( struct ColorMap *, ULONG, ULONG, 
*			ULONG, struct TagItem *);
*
*	color = ObtainBestPen(cm,r,g,b,tags....);
*
*   INPUTS
*	cm = colormap
*	R = red level   (32 bit left justified fraction)
*	G = green level (32 bit left justified fraction)
*	B = blue level  (32 bit left justified fraction)
*	taglist = a pointer to a standard tag list specifying the color
*	          matching settings desired:
*
*	        OBP_Precision - specifies the desired precision for the
*	                match. Should be PRECISION_GUI, PRECISION_ICON, or
*	                PRECISION_IMAGE or PRECISION_EXACT.
*	                Defaults to PRECISION_IMAGE.
*
*	        OBP_FailIfBad - specifies that you want ObtainBestPen to return
*	                a failure value if there is not a color within the
*	                given tolerance, instead of returning the closest color.
*	                With OBP_FailIfBad==FALSE, ObtainBestPen will only fail
*	                if the ViewPort contains no sharable colors.
*	                Defaults to FALSE.
*
*
*   FUNCTION
*	This function can be used by applications to figure out
*	what pen to use to represent a given color.
*
*	The system will attempt to find the color in your viewport closest
*	to the specified color. If there is no color within your tolerance,
*	then a new one will be allocated, if available. If none is available,
*	then the closest one found will be returned. 
*	
*   RESULT
*	The correct pen value, or -1 if no sharable palette entries are available.
*
*
*   BUGS
*
*   NOTES
*	If this call succceeds, then you must call ReleasePen() when you are
*	done with the color.
*
*	The error metric used for ObtainBestPen() is based on the magnitude
*	squared between the two RGB values, scaled by the percentage of free
*	entries.
*
*   SEE ALSO
*	GetColorMap() ObtainPen() ReleasePen() 
******************************************************************************
; the formula for what error value to pass is:
;
;	(TotalColors+Precision)*8
;	-------------------------   all squared.
;		#FreeColors



TEMP_SIZE	set	0
	LONGVAR	precision
	LONGVAR	tstate
	LONGVAR	colormap
	LONGVAR	save_d1
	LONGVAR	flags

	movem.l	d4/d5/d6/a5,-(a7)
	ALLOCLOCALS
	clr.l	flags_l(a7)
	move.l	d1,save_d1_l(a7)
	move.l	a1,tstate_l(a7)
	move.l	a0,colormap_l(a7)
	clr.l	precision_l(a7)
	move.l	a6,a5
	move.l	gb_UtilBase(a6),a6
tagparse:
	lea	tstate_l(a7),a0
	jsr	_LVONextTagItem(a6)
	tst.l	d0
	beq.s	donetags
	move.l	d0,a0
	move.l	(a0)+,d0
	move.l	(a0)+,d1
	sub.l	#OBP_Precision,d0
	bne.s	not_precision
	move.l	d1,precision_l(a7)
not_precision:
	subq.l	#1,d0
	bne.s	not_failifbad
	move.l	d1,flags_l(a7)
not_failifbad:
	bra.s	tagparse
donetags:
	move.l	a5,a6
	move.l	colormap_l(a7),a0
	move.l	precision_l(a7),d4
	bmi.s	try_exact
	move.l	cm_PalExtra(a0),a1
	add.w	pe_SharableColors(a1),d4
	ext.l	d4
	lsl.l	#3,d4
	move.w	pe_NFree(a1),d0
	beq.s	all_out_of_colors
	divu	d0,d4
	mulu	d4,d4
doit:	lea	default_color_matcher(pc),a1
	moveq	#-1,d6			; realmax
	move.l	flags_l(a7),d5
	beq.s	no_fifbad
	move.l	precision_l(a7),d6
	bmi.s	do_exact
	addq.w	#1,d6
	lsl.l	#5,d6
	mulu	d6,d6
	bra.s	no_fifbad
do_exact:
	moveq	#0,d6
no_fifbad:
	move.l	save_d1_l(a7),d1
	bsr	_SearchColorMap
	lea	TEMP_SIZE(a7),a7
	movem.l	(a7)+,d4/d5/d6/a5
	rts

all_out_of_colors:
	moveq	#-1,d4
	bra.s	doit

try_exact:
	moveq	#0,d4
	bra.s	doit


	xdef	_create_color_bits

	xref	_fwmaskTable
	xref	_lwmaskTable

_create_color_bits:
; void __asm create_color_bits(register __a0 struct ViewPort * vp, register __a1 void * bit_mask);
; given a viewport, and a bit vector (256 bits=32 bytes=8 longs), set
; a bit for each color used.
	movem.l	d2/d7/a2/a3/a4/a5,-(a7)
	moveq	#0,d0
	move.l	d0,(a1)+			; init all bits to 0
	move.l	d0,(a1)+
	move.l	d0,(a1)+
	move.l	d0,(a1)+
	move.l	d0,(a1)+
	move.l	d0,(a1)+
	move.l	d0,(a1)+
	move.l	d0,(a1)+
	lea	-32(a1),a1
	movem.l	a0/a1,-(a7)
	move.l	a0,-(a7)
	jsr	_new_mode
	lea	4(a7),a7
	move.l	d0,d7				; d7=modes
	movem.l	(a7)+,a0/a1
; depth=bm_depth
; if HAM then bm_depth-=2
; if EHB then depth = MIN(bm_depth, 5)
; if (the viewport has a 3.0 style color map)
;	fillbits(bp0_base,1<<depth)
;	if dualpf then fillbits(bp1_base,1<<bp1_depth)
;	uwordmask[spofs0*2] |= $7fff		set sprite bits. sprites use 1,2,3,5,..
;	uwordmask[spofs1*2] |= $7fff		or 1-15 if attached!
; else
;	fillbits(0,1<<depth)
;	if dualpf then fillbits(8,1<<bp1_depth)
;	if sprites then uwordmask[1] |= $ffff	(yep, even colour 16)
	btst	#5,d7				; super-hires?
	beq.s	no_scramble
	btst	#GFXB_AA_MLISA,gb_ChipRevBits0(a6)		; lisa? if so, no scrambling
	bne.s	no_scramble
	move.l	#-1,(a1)			; if shires, then must load all 32 colors
no_scramble:
	move.l	vp_ColorMap(a0),a3
	cmp	#0,a3
	beq	no_colormap
	moveq	#0,d2
	tst.b	cm_Type(a3)			; 3.0 type?
	beq.s	old_type
	move.b	cm_AuxFlags(a3),d2
	btst	#CMAB_FULLPALETTE,d2
	bne	load_full
	btst	#CMAB_NO_COLOR_LOAD,d2
	bne	load_none

old_type:
	move.l	vp_RasInfo(a0),d0
	beq	no_bitplanes
	move.l	d0,a2
	move.l	ri_BitMap(a2),d1
	beq.s	no_bitplanes
	move.l	d1,a4
	moveq	#0,d1
	move.b	bm_Depth(a4),d1
	btst	#10,d7				; dualpf???
	beq.s	no_dpf1
	btst	#CMAB_DUALPF_DISABLE,d2
	beq.s	no_dpf1
	move.l	ri_Next(a2),d2
	beq.s	no_dpf1
	move.l	d2,a5
	move.l	ri_BitMap(a5),d2
	beq.s	no_dpf1
	move.l	d2,a5
	add.b	bm_Depth(a5),d1
	bclr	#10,d7				; kill dpf!!!

no_dpf1:
	btst	#11,d7				; HAM?
	beq.s	no_ham
	; if ham, if depth is 5 or 6, then depth = 4
	;         if depth is 7 or 8, then depth = 6
	cmp.w	#4,d1
	ble.s	no_ham
	cmp.w	#7,d1
	blt.s	ham6fudge
	moveq	#6,d1
	bra.s	no_ham
ham6fudge:
	moveq	#4,d1
no_ham:
	btst.b	#7,d7				; EHB?
	beq.s	no_ehb
	cmp.b	#5,d1
	ble.s	no_ehb
	moveq	#5,d1
no_ehb:
; now, have d1=playfield 0 depth!!!
	moveq	#1,d0
	lsl.w	d1,d0
	moveq	#0,d1				; d1=playfield 0 base
	bsr.s	setbits
; now, do playfield 1
	btst	#10,d7				; DUALPF?
	beq.s	no_bitplanes
	move.l	ri_Next(a2),d0
	beq.s	no_bitplanes
	move.l	d0,a2
	move.l	ri_BitMap(a2),d0
	beq.s	no_bitplanes
	move.l	d0,a2
	moveq	#1,d0
	moveq	#0,d1
	move.b	bm_Depth(a2),d1
	lsl.w	d1,d0				; d0=ncolors
	moveq	#8,d1				; d1=color base
	bsr.s	setbits
no_bitplanes:
	btst	#6,vp_Modes(a0)			; SPRITES?
	beq.s	bye_ccb
	or.w	#$ffff,2(a1)			; set sprite colors!
bye_ccb:
	movem.l	(a7)+,d2/d7/a2/a3/a4/a5
	rts
load_full:					; if the cm->AuxFlags has FULLPALETTE,
	moveq	#-1,d0				; than load all 256 colors.
	move.l	d0,(a1)+
	move.l	d0,(a1)+
	move.l	d0,(a1)+
	move.l	d0,(a1)+
	move.l	d0,(a1)+
	move.l	d0,(a1)+
	move.l	d0,(a1)+
	move.l	d0,(a1)+
	lea	-32(a1),a1
	bra.s	bye_ccb
; if CMAF_NO_COLOR_LOAD is set, then just set colour 0.
load_none:
	bset.b	#7,(a1)
	bra.s	bye_ccb

no_colormap:
 	move.l	#-1,(a1)			; use 32 colours as default.
	bra.s	bye_ccb

setbits:
; d1=bit base, d0=#bits to set, a1=dest
; trashes d1 d2 d0 a4
	ifd	AA_ONLY
1$:	moveq	#32,d2
	cmp.w	d2,d0
	bge.s	2$
	move	d0,d2
2$:	bfset	(a1){d1:d2}
	add	d2,d1
	sub	d2,d0
	bgt.s	1$
	rts

	else

	move.l	a1,a4				; a4=byte base
	move.w	d1,d2
	lsr.w	#3,d2				; d2=byte offset
	add	d2,a4
	and.w	#$7,d1				; d1=bit offset
	beq.s	bitofs_already_0
set_next_unaligned:
	moveq	#7,d2
	sub	d1,d2
	bset	d2,(a4)
	subq.w	#1,d0
	beq.s	done_setbits
	subq.w	#1,d1
	bne.s	set_next_unaligned
	addq.l	#1,a4
; now, bit offset=0, d0=#bits
bitofs_already_0:
	move	d0,d2
	lsr.w	#3,d2
	bra.s	sb_eloop
setbits_lp:
	st	(a4)+
sb_eloop:
	dbra	d2,setbits_lp
no_full_byte:
	and.w	#7,d0
	beq.s	done_setbits
	subq	#1,d0
	add.w	d0,d0
	move.l	a1,d1
	move.l	#_lwmaskTable,a1
	move.b	0(a1,d0.w),d0
	or.b	d0,(a4)
	move.l	d1,a1
done_setbits:
	rts
	endc


	xdef	_numbits
_numbits:
; int __asm numbits(register __d1 ULONG lword1);
; return d0=number of bits set in d1
; trashes a0 d0 d1
	move.l	d2,a0
	moveq	#0,d0
	moveq	#0,d2
1$	add.l	d1,d1
	addx	d2,d0
	tst.l	d1
	bne.s	1$
	move.l	a0,d2
	rts


	xdef	_color_ofs_bits
_color_ofs_bits:
; int __asm color_ofs_bits(register __d1 number);
; return d0=the 3 bit value for color offset NN
;	128->7 64->6 32->5 16->4 8->3 4->2 2->1 0->0
; trashes d1,d0
	tst.b	d1
	beq.s	2$
	moveq	#8,d0
1$:	subq	#1,d0
	add.b	d1,d1
	bcc.s	1$
	rts
2$:	moveq	#0,d0
	rts


* get_bplcon4() - BPLAMx, ESPRMx, OSPRMx
	xdef	_get_bplcon4
_get_bplcon4:
; int __asm get_bplcon4(register __a0 struct ColorMap * cm );
; trashes d0,d1
	move.l	a0,d0
	beq.s	def_bplcon4
	tst.b	cm_Type(a0)
	beq.s	def_bplcon4
	moveq	#0,d0
	move.w	cm_Bp_0_base(a0),d0
	lsl.w	#8,d0
	move.w	cm_SpriteBase_Even(a0),d1
	and.w	#$f0,d1
	or.w	d1,d0
	move.w	cm_SpriteBase_Odd(a0),d1
	lsr.w	#4,d1
	or.w	d1,d0
	rts
def_bplcon4:
	moveq	#$11,d0
	rts
		
* get_bplcon3() - PF2OFx, SPRESx, BRDRBLNKM, BRDRNTRAN, BRDRSPRT
	xdef	_get_bplcon3
_get_bplcon3:
; int __asm get_bplcon3(register __a0 struct ColorMap * cm );
; trashes d0,d1
	move.l	#$c00,d0	; default value
	move.l	a0,d1
	beq.s	got_bplcon3
	tst.b	cm_Type(a0)
	beq.s	got_ofs
	move.w	cm_Bp_1_base(a0),d1
	sub.w	cm_Bp_0_base(a0),d1
	bsr	_color_ofs_bits
got_ofs:
	lsl.w	#8,d0
	add	d0,d0
	add	d0,d0
	move.b	cm_Flags(a0),d1
	btst	#CMB_BRDRBLNK,d1
	beq.s	1$
	bset	#5,d0
1$:	btst	#CMB_BRDNTRAN,d1
	beq.s	2$
	bset	#4,d0
2$:	btst	#CMB_BRDRSPRT,d1
	beq.s	3$
	addq	#2,d0
3$:	move.b	cm_SpriteResolution(a0),d1
	bpl.s	4$
	move.b	cm_SpriteResDefault(a0),d1
4$:	ror.b	#2,d1
	or.b	d1,d0
got_bplcon3:
	or.b	gb_BP3Bits(a6),d0
	rts

* get_bplcon2() - ZDBPSELx, ZDBPEN, ZDCTEN, PF1Px, PF2Px
	xdef	_get_bplcon2
_get_bplcon2:
; int __asm get_bplcon2(register __a0 struct ColorMap * cm );
; trashes d0,d1
	movem.l	a0-a2/d2/d3,-(a7)
	moveq	#$24,d0		; default value
	move.l	a0,d1
	beq	got_bplcon2
	tst.b	cm_Type(a0)
	beq	got_bplcon2
	moveq	#0,d0		; modes
	move.l	cm_vp(a0),a2
	move.l	a0,-(a7)
	move.l	a2,-(a7)
	beq.s	bad_cm_vp
	jsr	_new_mode
bad_cm_vp:
	lea	4(a7),a7
	move.l	(a7)+,a0
	move.l	d0,d2
; now, a0=cm, a2=vp|NULL, d2=modes
	move.b	cm_Flags(a0),d1
	moveq	#0,d0
	btst.b	#CMB_CMTRANS,d1
	beq.s	1$
	or.w	#$400,d0	; ZDCTEN
1$:	btst.b	#CMB_CPTRANS,d1
	beq.s	no_cptrans
	or.w	#$800,d0	; ZDBPEN
	moveq	#0,d1
; if chroma_plane, then scrozzle the bits if 8 bitplane ham
	move.b	cm_TransparencyPlane(a0),d1
	btst	#11,d2		; HAM?
	beq.s	no_scrozzle
	cmp.w	#0,a2		; vp null?
	beq.s	no_scrozzle
	move.l	vp_RasInfo(a2),a1
	cmp.w	#0,a1
	beq.s	no_scrozzle
	move.l	ri_BitMap(a1),a1
	cmp.w	#0,a1
	beq.s	no_scrozzle
	cmp.b	#8,bm_Depth(a1)
	bne.s	no_scrozzle
	addq.b	#2,d1
	and.b	#7,d1
no_scrozzle:
	ror.w	#4,d1		; into bits 12-14
	or.w	d1,d0		; ZDBPSELx
no_cptrans:
	cmp.w	#0,a2
	beq.s	no_vp_2
	move.b	vp_SpritePriorities(a2),d1
; now, check if the viewport is superhires on ecs-denise
	btst	#GFXB_AA_MLISA,gb_ChipRevBits0(a6)	; lisa doesn't need this
	bne.s	bp2_sprite
	btst	#5,d2			; superhires?
	beq.s	bp2_sprite
	lsr.b	#1,d1			; shift priorities because of color scramble.
	bclr.b	#2,d1

bp2_sprite:
	or.b	d1,d0
got_bplcon2:
	movem.l	(a7)+,a0-a2/d2/d3
	rts
no_vp_2:
	moveq	#$24,d1		; default value
	bra.s	bp2_sprite

; see page 302 of HW manual

sc_A	equ	0*8+3
sc_B	equ	0*8+2
sc_C	equ	1*8+7
sc_D	equ	1*8+6
sc_E	equ	1*8+3
sc_F	equ	1*8+2
sc_G	equ	2*8+3
sc_H	equ	2*8+2
sc_I	equ	3*8+7
sc_J	equ	3*8+6
sc_K	equ	3*8+3
sc_L	equ	3*8+2
sc_M	equ	4*8+3
sc_N	equ	4*8+2
sc_O	equ	5*8+7
sc_P	equ	5*8+6
sc_Q	equ	5*8+3
sc_R	equ	5*8+2
sc_S	equ	6*8+3
sc_T	equ	6*8+2
sc_U	equ	7*8+7
sc_V	equ	7*8+6
sc_W	equ	7*8+3
sc_X	equ	7*8+2

; the NO_SCRAMBLE symbols disables ecs shires color-scrambling. This is
; to save space in AA machines.

	IFND	AA_ONLY
scramble_table:
; for each output bit (12x16), select input bit.
; format is bofs*8+bit#
	dc.b	sc_A,sc_B,sc_A,sc_B,sc_C,sc_D,sc_C,sc_D,sc_E,sc_F,sc_E,sc_F
	dc.b	sc_G,sc_H,sc_A,sc_B,sc_I,sc_J,sc_C,sc_D,sc_K,sc_L,sc_E,sc_F
	dc.b	sc_M,sc_N,sc_A,sc_B,sc_O,sc_P,sc_C,sc_D,sc_Q,sc_R,sc_E,sc_F
	dc.b	sc_S,sc_T,sc_A,sc_B,sc_U,sc_V,sc_C,sc_D,sc_W,sc_X,sc_E,sc_F
	dc.b	sc_A,sc_B,sc_G,sc_H,sc_C,sc_D,sc_I,sc_J,sc_E,sc_F,sc_K,sc_L
	dc.b	sc_G,sc_H,sc_G,sc_H,sc_I,sc_J,sc_I,sc_J,sc_K,sc_L,sc_K,sc_L
	dc.b	sc_M,sc_N,sc_G,sc_H,sc_O,sc_P,sc_I,sc_J,sc_Q,sc_R,sc_K,sc_L
	dc.b	sc_S,sc_T,sc_G,sc_H,sc_U,sc_V,sc_I,sc_J,sc_W,sc_X,sc_K,sc_L
	dc.b	sc_A,sc_B,sc_M,sc_N,sc_C,sc_D,sc_O,sc_P,sc_E,sc_F,sc_Q,sc_R
	dc.b	sc_G,sc_H,sc_M,sc_N,sc_I,sc_J,sc_O,sc_P,sc_K,sc_L,sc_Q,sc_R
	dc.b	sc_M,sc_N,sc_M,sc_N,sc_O,sc_P,sc_O,sc_P,sc_Q,sc_R,sc_Q,sc_R
	dc.b	sc_S,sc_T,sc_M,sc_N,sc_U,sc_V,sc_O,sc_P,sc_W,sc_X,sc_Q,sc_R
	dc.b	sc_A,sc_B,sc_S,sc_T,sc_C,sc_D,sc_U,sc_V,sc_E,sc_F,sc_W,sc_X
	dc.b	sc_G,sc_H,sc_S,sc_T,sc_I,sc_J,sc_U,sc_V,sc_K,sc_L,sc_W,sc_X
	dc.b	sc_M,sc_N,sc_S,sc_T,sc_O,sc_P,sc_U,sc_V,sc_Q,sc_R,sc_W,sc_X
	dc.b	sc_S,sc_T,sc_S,sc_T,sc_U,sc_V,sc_U,sc_V,sc_W,sc_X,sc_W,sc_X

; void __asm scramble_colors(register __a0 UWORD *srcdata, register __a1 UWORD *dest);
; generates 16 uwords from 
	endc
	xdef	_scramble_colors

_scramble_colors:
	IFND	AA_ONLY
	movem.l	a2/d2/d3/d4,-(a7)
	lea	scramble_table(pc),a2
	moveq	#15,d0					; output ctr
	moveq	#0,d3
1$:	moveq	#0,d1					; output word
	moveq	#11,d2					; bit ctr
2$:	move.b	(a2)+,d3				; d3=table entry
	move	d3,d4
	lsr.w	#3,d4
	add.w	d1,d1
	btst	d3,0(a0,d4.w)
	beq.s	3$
	addq	#1,d1
3$:	dbra	d2,2$
	move.w	d1,(a1)+
	dbra	d0,1$
	movem.l	(a7)+,a2/d2/d3/d4
	ENDC
	rts

	end
@


39.53
log
@added support for non-dual dualpf.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.52 93/03/09 10:28:47 chrisg Exp Locker: chrisg $
d1517 1
a1517 1
	beq.s	no_bitplanes
d1540 10
a1549 1
	subq	#2,d1				; if (ham) depth-=2
@


39.52
log
@added some 020 optimizations in aa_only build.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.51 93/03/08 13:12:46 chrisg Exp Locker: chrisg $
d1468 1
a1468 1
	movem.l	d2/d7/a2/a3/a4,-(a7)
d1506 1
d1509 4
a1512 3
	btst	#CMAB_FULLPALETTE,cm_AuxFlags(a3)
	bne.s	load_full
	btst	#CMAB_NO_COLOR_LOAD,cm_AuxFlags(a3)
d1519 1
a1519 1
	tst.l	ri_BitMap(a2)
d1521 1
a1521 1
	move.l	ri_BitMap(a2),a4
d1524 14
a1570 2
	tst.b	cm_Type(a3)			; color map type?
	bne.s	new_colormap
d1573 1
a1573 1
	movem.l	(a7)+,d2/d7/a2/a3/a4
a1589 6
	bra.s	bye_ccb
	

new_colormap:
	moveq	#-1,d1				; mask value.
	or.w	d1,2(a1)
@


39.51
log
@added AA_ONLY define to save space.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.50 93/02/15 17:31:08 spence Exp Locker: chrisg $
d339 2
d346 7
d377 1
d381 4
d592 1
d596 4
d1168 2
a1170 1
	move.l	pe_RefCnt(a2),a0
d1173 3
d1591 13
d1640 1
@


39.50
log
@if CMAF_NO_COLOR_LOAD is set, the create_color_bits only sets the bit
for colour 0.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.49 93/02/11 08:21:24 chrisg Exp Locker: spence $
d10 4
d1796 4
d1822 1
d1826 1
d1844 1
@


39.49
log
@no longer need testbit.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.48 93/02/09 15:51:04 chrisg Exp Locker: chrisg $
d1483 2
d1546 5
@


39.48
log
@re-wrote color poker.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.47 92/09/24 13:35:03 chrisg Exp Locker: chrisg $
a1593 17

	xdef	_testbit
_testbit:
; int __asm testbit(register __a0 void * base, register __d0 bitnum);
; return d0=true if bit set
; trashes d1,d0,a0
	move	d0,d1
	lsr.w	#3,d1
	add	d1,a0
	moveq	#7,d1
	and	d1,d0
	sub	d0,d1
	btst	d1,(a0)
	sne	d0
	ext.w	d0
	ext.l	d0
	rts
@


39.47
log
@autodoc
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.46 92/09/17 11:42:02 spence Exp Locker: chrisg $
a505 1
*
d711 1
a711 5
	lea	-(32+64)(a7),a7				; 256 bits+32 words (a7)=bits 32(a7)=color scramble data
	move.l	a7,a3					; a3=color bits
	move.l	a3,a1
	move.l	a2,a0
	bsr	_create_color_bits
d753 1
a753 1
; a3=cbits
d766 1
a766 1
	lea	32+8(a7),a1				; a6 and a1 are on stack right now
d772 1
a772 1
	lea	32+4(a7),a6				; a6 still on stack
d775 20
d796 71
a866 1
	move.l	a2,-(a7)
d869 3
a871 124

	cmp	#0,a4
	bne.s	poke_both
	move.l	a5,a4
poke_both:
	cmp	#0,a4
	beq	no_hwlists
	moveq	#7,d0						; d0=bank counter
bank_lp:
	move.l	(a3),d1						; d1=color bits
	beq	unused_bank
	btst	#GFXB_AA_LISA,d4
	bne.s	sync_newchips
sync_old:
	cmp.w	#color,(a4)
	beq.s	sync_old_lof
	addq.l	#4,a4
	bra.s	sync_old
sync_old_lof:
	cmp.w	#color,(a5)
	beq.s	sync_copins_old
	addq.l	#4,a5
	bra.s	sync_old_lof
sync_copins_old:
	move.w	ci_OpCode(a2),d2
	and.w	#3,d2
	ifne	COPPER_MOVE
	fail
	endc
	bne.s	is_wait_ins_old
	move.w	ci_DestAddr(a2),d2
	and.w	#$0fff,d2
	cmp.w	#color,d2
	beq.s	synced_lists
is_wait_ins_old:
	lea	ci_SIZEOF(a2),a2
	bra.s	sync_copins_old
sync_newchips:
sync_shf:
	cmp.w	#bplcon3,(a4)
	beq.s	sync_lof
	addq.l	#4,a4
	bra.s	sync_shf
sync_lof:
	cmp.w	#bplcon3,(a5)
	beq.s	synced_lof
	addq.l	#4,a5
	bra.s	sync_lof
synced_lof:
; now, (a4), (a5) point at bplcon3 load instructions, and d1=colorbits
	addq.l	#4,a4
	addq.l	#4,a5
sync_copins_new:
	move.w	ci_OpCode(a2),d2
	and.w	#3,d2
	ifne	COPPER_MOVE
	fail
	endc
	bne.s	is_wait_ins_new
	move.w	ci_DestAddr(a2),d2
	and.w	#$0fff,d2
	cmp.w	#bplcon3,d2
	beq.s	synced_new
is_wait_ins_new:
	lea	ci_SIZEOF(a2),a2
	bra.s	sync_copins_new
synced_new:
	lea	ci_SIZEOF(a2),a2

synced_lists:
	moveq	#31,d2						; d2=color counter
	move.l	a6,a1						; do high words first
clp:	move.w	(a1)+,d3					; fetch color word
	and.w	d6,d3
	add.l	d1,d1						; color bit on?
	bcc.s	unused_color					; nope, it's not
; at this point, d2=(31-color_reg_num),
; so we should verify this in case someone has changed
; something and then called LoadRGB4.
; *(a[54]) should equal color+2*31-2*d2)
	swap	d3
	move.w	#color+2*31,d3
	sub.w	d2,d3
	sub.w	d2,d3
	cmp.w	(a5),d3
	bne.s	unused_color
	swap	d3

	move.w	d3,2(a5)					; set LOF
	move.w	d3,2(a4)					; set SHF
	move.w	d3,ci_DestData(a2)
	addq.l	#4,a4
	addq.l	#4,a5
	lea	ci_SIZEOF(a2),a2
unused_color:
	dbra	d2,clp
; now, do low words
	btst	#GFXB_AA_LISA,d4
	beq.s	unused_bank
	addq.l	#4,a4						; skip store to bplcon3
	addq.l	#4,a5
	lea	ci_SIZEOF(a2),a2
	move.l	(a3),d1						; d1=color bits
	moveq	#31,d2						; d2=color counter
	move.l	a0,a1						; do low color words now
clp2:	move.w	(a1)+,d3					; fetch color word
	add.l	d1,d1						; color bit on?
	bcc.s	unused_color2					; nope, it's not
	move.w	d3,2(a5)					; set LOF
	move.w	d3,2(a4)					; set SHF
	move.w	d3,ci_DestData(a2)
	addq.l	#4,a4
	addq.l	#4,a5
	lea	ci_SIZEOF(a2),a2
unused_color2:
	dbra	d2,clp2

unused_bank:
	lea	32*2(a6),a6					; bump color table ptr
	lea	32*2(a0),a0					; bump low color tb ptr
	addq.l	#4,a3						; skip to next cbit lword
	dbra	d0,bank_lp
no_hwlists:
	move.l	(a7)+,a2
d883 1
a883 1
	lea	32+64(a7),a7
d886 56
@


39.46
log
@some autodocs clean  up
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.45 92/09/08 14:51:57 chrisg Exp Locker: spence $
a68 1
*	This function is incompatible with 1.3 format ColorMaps.
d71 1
a71 1
*	GetColorMap() FreeColorMap() ObtainPen()
d200 1
a200 1
*	GetColorMap() ObtainPen()
d262 7
a268 1
*	If successful, you should free this entry after you have finished with it.
d294 1
d300 2
a301 1
*	Generally, for shared access, you should use ObtainBestColor()
d305 1
a305 2
*	routine will always fail. This routine does not work if called
*	on 1.3 format ColorMap structures.
d308 1
a308 1
*	GetColorMap() ReleasePen() AttachPalExtra()
a508 1
*	Channels other than RGB will not be modified.
a532 2
*	Do not set colors which are not present in the colormap!
*	The viewport MUST have a colormap attached for this function!
d534 1
d654 1
a654 1
*	GetColorMap() GetRGB32() SetRGB32CM() graphics/view.h
d1014 1
a1014 2
*	GetColorMap() ObtainBestPenA() ReleasePen()
*	ObtainPen()
d1185 1
a1185 1
******* graphics.library/FindColor ****************************************
d1188 1
a1188 1
*	Find the closest matching color in a colormap. (V39)
d1191 1
a1191 1
*	color =FindColor(  cm,  R,   G,    B , maxpen)
d1278 2
a1279 1
*	LONG ObtainBestPenA( struct ColorMap *, ULONG, ULONG, ULONG, struct TagItem *);
d1304 4
a1307 1
*   RESULT
d1311 4
a1314 2
*	then the closest one found will be returned. A -1 will be returned if
*	no sharable palette entries are available.
d1320 1
a1320 1
*	If this call succceeds, then you must call RelasePen() when you are
d1322 1
a1322 2
*	The precision value should be either PRECISION_IMAGE (for colorful images),
*	PRECISION_ICON (for somewhat less precise images), and ..(I DON'T KNOW)!!!
@


39.45
log
@ was presevring chromapen bit in wrong place.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.44 92/08/24 12:18:09 chrisg Exp Locker: chrisg $
d36 1
a36 1
*			  colormap. (V39)
d41 1
a41 1
*		               a0  a1
d53 1
a53 1
*       cm  =  A pointer to a color map created by GetColorMap().
d60 1
a60 1
*		defined error number is out of memory (1).
d65 3
a67 1
*       If there is already a PalExtra associated with the ColorMap, then
d174 1
a174 1
*       ReleasePen -- Release an allocated palette entry to the free pool. (V39)
d178 1
a178 1
*       ReleasePen( cm, n)
d198 1
a198 1
*       This function works for both shared and exclusive palette entries.
d252 1
a252 1
*       ObtainPen -- Obtain a free palette entry for use by your program. (V39)
d256 1
a256 1
*       n = ObtainPen( cm, n, r, g, b, flags)
d266 1
a266 1
*       cm  =  A pointer to a color map created by GetColorMap().
d271 1
a271 1
*		(non-shared) use of this pen value. Default is shared access.
d274 1
a274 1
*		for the	selected pen. Really only makes sense for exclusive pens.
d285 1
a285 1
*		When you allocate a palette entry in non-exclusive mode, you
d289 1
a289 1
*		To avoid visual artifacts, you should not free up a palette
d294 1
a294 1
*		Generally, for shared access, you should use ObtainBestColor()
d297 1
a297 1
*		If there is no Palextra attached to the colormap, then this
d299 1
a299 1
*	on 1.3 format ColorMap structures.       
d406 1
a406 1
*       GetRGB32 -- Set a series of color registers for this Viewport. (V39)
d409 2
a410 2
*       GetRGB32(  cm,  firstcolor, ncolors, table )
*                  a0   d0   		d1    a1
d417 2
a418 2
*       ncolors = the number of color registers to set.
*       table=a pointer to a series of 32-bit RGB triplets.
d421 1
a421 1
*       The ULONG data pointed to by 'table' will be filled with the 32 bit
d429 1
a429 1
*       LoadRGB4() GetColorMap() LoadRGB32() SetRGB32CM() graphics/view.h
d488 1
a488 1
*       LoadRGB32 -- Set a series of color registers for this Viewport. (V39)
d491 2
a492 2
*       LoadRGB32(  vp,  table )
*                   a0   a1
d494 1
a494 1
*       void LoadRGB32( struct ViewPort *, ULONG *);
d498 2
a499 2
*       table=a pointer to a series of records which describe which colors to
*		modify.
d502 1
a502 1
*       The selected color registers are changed to match your specs.
d512 4
a515 4
*		1 Word with the number of colors to load
*		1 Word with the first color to be loaded.
*		3 longwords representing a left justified 32 bit rgb triplet.
*		The list is terminated by a count value of 0.
d518 4
a521 4
*		ULONG table[]={1l<<16+0,0xffffffff,0,0,0} loads color register
*			0 with 100% red.
*		ULONG table[]={256l<<16+0,r1,g1,b1,r2,g2,b2,.....0} can be used
*			to load an entire 256 color palette.
d533 1
a533 1
*       LoadRGB4() GetColorMap() GetRGB32() SetRGB32CM() graphics/view.h
d619 1
a619 1
*       SetRGB32 -- Set one color register for this Viewport. (V39)
d622 2
a623 2
*       SetRGB32(  vp,  n,   r,    g,    b)
*                  a0  d0   d1    d2    d3
d625 1
a625 1
*       void SetRGB32( struct ViewPort *, ULONG, ULONG, ULONG, ULONG );
d629 4
a632 4
*       n = the number of the color register to set.
*       r = red level   (32 bit left justified fraction)
*       g = green level (32 bit left justified fraction)
*       b = blue level  (32 bit left justified fraction)
d637 1
a637 1
*       The selected color register is changed to match your specs.
d650 1
a650 1
*       GetColorMap() GetRGB32() SetRGB32CM() graphics/view.h
d1185 1
a1185 1
*       Find the closest matching color in a colormap. (V39)
d1188 2
a1189 2
*       color =FindColor(  cm,  R,   G,    B , maxpen)
*                          a3   d1   d2    d3   d4
d1191 1
a1191 1
*       ULONG FindColor( struct ColorMap *, ULONG, ULONG, ULONG,LONG);
d1195 3
a1197 3
*       R = red level   (32 bit left justified fraction)
*       G = green level (32 bit left justified fraction)
*       B = blue level  (32 bit left justified fraction)
d1199 3
a1201 3
*		-1 will limt the search to only those pens which could be
*		rendered in (for instance, it will not examine the sprite
*		colors on a 4 color screen).
d1211 4
a1214 4
*		(a) programs which pop up on public screens when those
*		    screens are not using palette sharing. You might
*		    use this function as a fallback when ObtainBestPenA()
*		    says that there are no sharable pens.
d1216 4
a1219 4
*		(b) Internal color matching by an application which is
*		    either running on a non-public screen, or which
*		    wants to match colors to an internal color table
*		    which may not be associated with any displayed screen.
d1267 2
a1268 2
*       ObtainBestPenA --- Search for the closest color match, or allocate a
*			   new one. (V39)
d1272 2
a1273 2
*       color | -1 =ObtainBestPenA(  cm,  R,   G,    B,    taglist)
*                                   a0   d1   d2    d3       a1
d1275 1
a1275 1
*       LONG ObtainBestPenA( struct ColorMap *, ULONG, ULONG, ULONG, struct TagItem *);
d1281 17
a1297 17
*       R = red level   (32 bit left justified fraction)
*       G = green level (32 bit left justified fraction)
*       B = blue level  (32 bit left justified fraction)
*       taglist = a pointer to a standard tag list specifying the color
*		matching settings desired:
*
*		OBP_Precision - specifies the desired precision for the
*			match. Should be PRECISION_GUI, PRECISION_ICON, or
*			PRECISION_IMAGE or PRECISION_EXACT.
*			Defaults to PRECISION_IMAGE.
*
*		OBP_FailIfBad - specifies that you want ObtainBestPen to return
*			a failure value if there is not a color within the
*			given tolerance, instead of returning the closest color.
*			With OBP_FailIfBad==FALSE, ObtainBestPen will only fail
*			if the ViewPort contains no sharable colors.
*			Defaults to FALSE.
@


39.44
log
@preserve a0 in get_bplcon2.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.43 92/08/20 14:52:04 chrisg Exp Locker: chrisg $
a584 3
	move.w	(a6),d3
	and.w	#$8000,d3
	or.w	d3,d2
d598 3
@


39.43
log
@preserve chromapen in loadrgb32
swizzle bitplanes for 8 bit ham in chromaplane mode.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.42 92/08/17 13:36:19 chrisg Exp Locker: chrisg $
d1679 1
a1679 1
	movem.l	a2/d2/d3,-(a7)
d1687 1
d1693 1
d1739 1
a1739 1
	movem.l	(a7)+,a2/d2/d3
@


39.42
log
@replicate bits
fix range check in loadrgb32.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.41 92/08/10 10:26:22 chrisg Exp Locker: chrisg $
d550 1
a550 1
	beq	done_loadlp
d585 3
d1381 1
a1381 1
	lsl.l	#3,d6
d1679 1
d1682 1
a1682 1
	beq.s	got_bplcon2
d1684 10
a1693 1
	beq.s	got_bplcon2
d1700 1
a1700 1
	beq.s	2$
d1703 1
d1705 15
d1722 2
a1723 1
2$:	move.l	cm_vp(a0),d1
d1725 1
a1725 3
	move.l	a0,-(sp)
	move.l	d1,a0
	move.b	vp_SpritePriorities(a0),d1
d1728 3
a1730 8
	bne.s	donevp
	movem.l	d0/d1/a0/a1,-(a7)
	move.l	a0,-(a7)
	jsr	_new_mode
	lea	4(a7),a7
	btst	#5,d0			; superhires?
	movem.l	(a7)+,d0/d1/a0/a1	; leaves cc alone
	beq.s	donevp
a1732 2
donevp:
	move.l	(sp)+,a0
d1737 1
d1772 1
a1772 1
; format is bofs*3+bit#
@


39.41
log
@made call setrgb32/loadrgb32 through vectors.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.40 92/08/06 11:25:08 chrisg Exp Locker: chrisg $
d390 11
d434 2
d473 3
d550 1
a550 1
	beq.s	done_loadlp
d562 1
a562 1
	sub	d7,d0
@


39.40
log
@load color 16 for compatibility.
35ns ECS sprite prioirties.
check reg # in pokecolors.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.39 92/08/03 09:09:31 chrisg Exp Locker: chrisg $
d24 1
a25 1

d379 1
a379 1
	bsr	_SetRGB32			; should call via vector
d640 1
a640 1
	bsr	_LoadRGB32
d1095 1
a1095 1
	bsr	_SetRGB32			; should call thru vector!!!
@


39.39
log
@made color change calls safe from an interrupt again.
made it possible to ObtainPen the highest color.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.38 92/07/29 16:48:00 chrisg Exp Locker: chrisg $
d835 12
a1496 2
; if ECS, then set colour 16 for compatibility. ???
; if AA, then don't set colour 16, because it's useless if depth <= 4;
a1497 4
	btst.b	#GFXB_AA_LISA,gb_ChipRevBits0(a6)
	beq.s	not_aa_sprites
	move.w	#$7fff,d1
not_aa_sprites:
d1682 13
d1696 1
@


39.38
log
@obp_failifbad
ham and ehb for palette sharing.
get_bplconxx default values for no cm.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.37 92/07/21 14:43:52 chrisg Exp Locker: chrisg $
d326 1
a326 1
	bhs.s	return1
d682 1
a682 1
	movem.l	d2-d6/a0-a6,-(a7)
d702 1
d705 8
d714 1
d872 1
a872 6
	move.l	(a7)+,a1					; get back gfxbase
	move.l	gb_ExecBase(a1),a6
	move.l	gb_ActiViewCprSemaphore(a1),a0
	jsr	_LVOReleaseSemaphore(a6)
	lea	32+64(a7),a7
	movem.l	(a7)+,d2-d6/a0-a6
d876 8
@


39.37
log
@fixed so that bplcon4 would have the right color offset bits when
there was no or old-style colormap.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.36 92/06/16 13:15:28 chrisg Exp Locker: chrisg $
d91 1
a91 1
	FORBID
d137 8
d325 2
d917 2
a918 2
*       color | -1 =SearchColorMap(  cm,  proc, R, G, B, MaxError, MaxColor)
*                                    a0     a1 d1  d2 d3     d4	   d5
d976 2
a977 1
ofs_stacksize		equ	ofs_colormask+4
d983 1
d1040 3
d1044 1
d1050 1
d1291 1
a1291 1
	movem.l	d4/d5/a5,-(a7)
d1331 1
d1333 10
d1346 1
a1346 1
	movem.l	(a7)+,d4/d5/a5
d1605 2
a1606 1
	move.l	a0,d0
a1607 1
	moveq	#0,d0
d1641 2
a1642 1
	move.l	a0,d0
@


39.36
log
@fixed palette sharing bug in compare function.
added bp3bits.
range checks in loadrgb32
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.35 92/06/11 14:26:30 chrisg Exp Locker: chrisg $
d1555 1
a1555 1
	beq.s	got_bplcon4
d1557 1
a1557 1
	beq.s	got_bplcon4
d1567 3
a1569 1
got_bplcon4:
@


39.35
log
@ made releasepen(-1) a nop.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.34 92/06/03 16:32:01 chrisg Exp Locker: chrisg $
d509 3
a511 3
	beq.s	loadrgb_exit
	cmp	#0,a1
	movem.l	d2-d6/a2-a5,-(a7)
d525 18
a542 1
	move.w	(a1)+,d0
d545 2
a546 2
	lea	0(a4,d0.w),a0
	subq	#1,d1
d559 1
a559 1
	move.w	d2,(a0)+
d573 1
d575 1
d578 1
d580 1
a580 1
	movem.l	(a7)+,d2-d6/a2-a5
d893 1
a893 1
	move.l	0(a0,d0.w),d2
d1603 1
@


39.34
log
@added OBP_FailIFBad.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.33 92/05/19 13:15:03 chrisg Exp Locker: chrisg $
d182 2
a183 1
*	       functions.
d194 2
d235 1
d246 2
a247 2
*       n | -1= ObtainPen( cm, n, r, g, b, flags)
*	d0		   a0 d0  d1 d2 d3  d4
d266 5
@


39.33
log
@changed counters to be 16 bits.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.32 92/05/13 11:11:36 spence Exp Locker: chrisg $
d935 2
a936 2
ofs_maxcolor		equ	ofs_gbase+4
ofs_colormask	equ	ofs_maxcolor+4
d943 1
a943 1
	move.l	d5,ofs_maxcolor(a7)
a969 2
	cmp.l	ofs_maxcolor(a7),a5
	bhi.s	no_closer
d1002 2
d1005 3
d1200 8
d1243 1
d1247 1
d1266 4
d1285 1
a1285 1
	moveq	#-1,d5	; maxcolor
@


39.32
log
@EHB modes only load 32 colours
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.31 92/04/10 12:10:39 chrisg Exp Locker: spence $
d93 1
a93 1
	bne.s	end_att
d98 3
a100 1
	add.l	d0,d0
d120 1
d199 2
a200 1
	subq.b	#1,0(a0,d0.w)			; ref[i]--
d308 2
a309 1
	tst.b	0(a0,d0.l)			; ref cnt==0?
d311 2
a313 1
	addq.b	#1,0(a0,d0.l)			; bump ref cnt
d337 3
a339 1
	addq.b	#1,0(a0,d7.w)			; refcnt[alloc]++
d1027 1
d1029 2
a1030 1
	addq.b	#1,0(a0,d0.l)
@


39.31
log
@made attachpalextra have a return code.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.30 92/04/08 17:03:59 chrisg Exp Locker: chrisg $
d1302 1
d1339 6
@


39.30
log
@ changed pickbestcolor->obtainbestpen.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.29 92/04/04 14:33:38 chrisg Exp Locker: chrisg $
d40 2
a41 2
*       AttachPalExtra( cm, vp)
*		        a0  a1
d43 1
a43 1
*	void AttachPalExtra( Struct ColorMap *, struct ViewPort *);
d58 4
d88 1
a88 1
1$:	movem.l	a2/a3/a4/a5/a6,-(sp)
d142 7
a148 1
	movem.l	(sp)+,a2/a3/a4/a5/a6
@


39.29
log
@added spriteresdef handling.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.28 92/03/26 11:59:18 chrisg Exp Locker: chrisg $
d23 1
a23 1
	xref	_LVOSetRGB4,_LVOPermit
d25 1
d29 1
a29 1
	xdef	_PickBestColor,_SearchColorMap,_ObtainPen
a856 3
******* graphics.library/SearchColorMap ****************************************
*
*   NAME
d900 1
a900 1
*	For most applications, you should call PickBestColor(), and not this
d902 1
a902 1
*	optimize its palette error metrics differently. PickBestColor() also
d907 1
a907 1
*	GetColorMap() PickBestColor() ReleasePen()
d923 1
a923 4
	bne.s	1$
	moveq	#-1,d0
	rts
1$:	movem.l	d2-d7/a2-a6,-(a7)
d1098 1
a1098 1
*		    use this function as a fallback when PickBestColor()
d1115 1
a1115 1
*	PickBestColor() GetColorMap() ObtainPen() ReleasePen()
d1148 2
a1149 2
_PickBestColor:
******* graphics.library/PickBestColor ****************************************
d1152 9
a1160 5
*       Search for the closest color match, or allocate a new one. (V39)
*
*   SYNOPSIS
*       color | -1 =PickBestColor(  cm,  R,   G,    B,    Precision, MaxColor)
*                                   a0   d1   d2    d3     d4		d5
d1162 1
a1162 2
*       ULONG PickBestColor( struct ColorMap *, ULONG, ULONG, ULONG, ULONG,
*				ULONG );
d1169 2
a1170 2
*       Precision = the relative amount of color resolution desired.
*	MaxColor = the largest color value to examine. -1 means any valid one.
d1172 5
d1192 1
a1192 1
*	The error metric used for PickBestColor() is based on the magnitude
d1197 1
a1197 1
*	GetColorMap() ObtainPen() ReleasePen() SearchColorMap()
d1207 32
a1240 1
	bmi.s	try_exact
d1247 7
a1253 2
	lea	default_color_matcher(pc),a1
	bra	_SearchColorMap
d1257 1
a1257 2
	lea	default_color_matcher(pc),a1
	bra	_SearchColorMap			; should call thru vector
d1261 1
a1261 2
	lea	default_color_matcher(pc),a1
	bra	_SearchColorMap			; should call thru vector
d1382 1
a1382 1
	move.l	#-1,(a1)			; use 32 colours as default.
@


39.28
log
@  Added FindColor and updated autodoc.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.27 92/03/19 16:07:55 chrisg Exp Locker: chrisg $
d1488 3
a1490 1
	ror.b	#2,d1
@


39.27
log
@ added support for CMAB_FULLPALETTE flag!
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.26 92/03/11 11:19:03 spence Exp Locker: chrisg $
d816 39
d895 1
a895 1
*	If this call succceeds, then you must call FreePalette() when you are done
d909 2
a910 2
*	GetColorMap() PickBestColor() FreePalette()
*	AllocPalette()
d952 1
a952 1
	beq	no_match_try_new_one
d958 1
a958 1
	bhi	no_closer
d960 1
a960 33
	add.w	d0,d0
	move.l	cm_ColorTable(a3),a0
	moveq	#0,d5
	move.w	0(a0,d0.w),d5
	move.l	d5,d6
	move.l	d5,d7
	and.w	#$0f00,d5
	and.w	#$00f0,d6
	and.w	#$000f,d7
	lsl.l	#4,d5
	swap	d5				; d5=red
	lsl.l	#8,d6
	swap	d6				; d6=green
	ror.l	#4,d7				; d7=red
	move.l	cm_LowColorBits(a3),a0
	cmp.l	#0,a0
	beq.s	already_got_color
	move.w	0(a0,d0.w),d2
	and.l	#$0f00,d2
	swap	d2
	or.l	d2,d5
	move.w	0(a0,d0.w),d2
	and.l	#$00f0,d2
	lsl.l	#4,d2
	swap	d2
	or.l	d2,d6
	move.l	0(a0,d0.w),d2
	and.l	#$000f,d2
	lsl.l	#8,d2
	swap	d2
	or.l	d2,d7				; yuck! now, we finally have the RGB
						; values from the colormap in fractional
						; format in d5/d6/d7
a961 1
already_got_color:
d1072 81
a1153 1

d1185 1
a1185 1
*	If this call succceeds, then you must call FreePalette() when you are
d1194 1
a1194 1
*	GetColorMap() AllocPalette() FreePalette() SearchColorMap()
@


39.26
log
@create_color_bits() sets colour 16 on <AA machines for compatibility.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.25 92/03/03 10:24:36 spence Exp Locker: spence $
d88 1
a88 1
	bne	end_att
d305 1
a305 1
	bra	check_exclusive
d310 1
a310 1
	bra	check_exclusive
d531 1
a531 1
	bsr	_pokecolors			; vp in a2
d673 1
a673 1
	beq	no_scramble1
d675 1
a675 1
	bne	no_scramble1
d1187 6
d1209 1
a1209 4
	tst.b	cm_Type(a3)			; 2.0 style or 1.0 style?
	beq.s	1$
	move.w	cm_Bp_0_base(a3),d1		; base=playfield 0 base
1$:	bsr	setbits
d1224 1
a1224 4
	tst.b	cm_Type(a3)
	beq.s	2$
	move.w	cm_Bp_1_base(a3),d1
2$:	bsr	setbits
d1234 13
d1248 1
a1248 1
; if ECS, then set colour 16 for compatibility.
d1255 1
a1255 6
	move.w	cm_SpriteBase_Even(a3),d0	; always a multiple of 16.
	lsr.w	#3,d0
	or.w	d1,0(a1,d0.w)
	move.w	cm_SpriteBase_Odd(a3),d0	; always a multiple of 16.
	lsr.w	#3,d0
	or.w	d1,0(a1,d0.w)
d1259 1
a1259 1
	move.l	#-1,(a1);			; use 32 colours as default.
d1392 1
a1392 1
	btst	#CMF_BRDRBLNK,d1
d1395 1
a1395 1
1$:	btst	#CMF_BRDNTRAN,d1
d1398 1
a1398 1
2$:	btst	#CMF_BRDRSPRT,d1
d1418 1
a1418 1
	btst.b	#CMF_CMTRANS,d1
d1421 1
a1421 1
1$:	btst.b	#CMF_CPTRANS,d1
@


39.25
log
@bplcon2 was setting wrong bits.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.24 92/02/28 12:34:32 spence Exp Locker: spence $
d1177 1
a1177 1
;	if sprites then uwordmask[1] |= $7fff
d1230 1
a1230 1
	or.w	#$7fff,2(a1)			; set sprite colors!
d1235 7
d1244 1
a1244 1
	or.w	#$7fff,0(a1,d0.w)
d1247 1
a1247 1
	or.w	#$7fff,0(a1,d0.w)
@


39.24
log
@Take SpritePriorities from vp->SpritePriorities  instead of the
colormap
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.23 92/02/27 16:09:41 chrisg Exp Locker: spence $
d1405 1
a1405 1
	or.w	#$4000,d0	; ZDCTEN
d1408 1
a1408 1
	or.w	#$8000,d0	; ZDBPEN
@


39.23
log
@ made allow NULL on LOADRGB32
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.22 92/02/27 14:25:21 spence Exp Locker: chrisg $
d1413 7
a1419 1
2$:	move.b	cm_PfdSpritePri(a0),d1
d1423 3
a1425 1

@


39.22
log
@get_bplcon2()
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.21 92/02/25 12:59:30 spence Exp Locker: spence $
d452 1
d472 1
a472 1
*	Do not set more colors then are present in the colormap!
d480 3
d533 1
@


39.21
log
@get_bplcon3() respects sprite resolution bits.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.20 92/02/24 14:07:40 chrisg Exp Locker: spence $
d1333 1
d1337 1
d1340 2
d1354 1
d1386 27
@


39.20
log
@added color masking.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.19 92/02/20 13:43:30 chrisg Exp Locker: chrisg $
d1374 1
a1374 1
	beq.s	got_bplcon3
d1376 3
@


39.19
log
@o	Made ObtainPen return failure if you ask for an absolute pen whose
	index is higher than that allowed on the screen. So, asking for
	color 255 will fail on a 2 deep WB.

o	SetRGB32() now calls LoadRGB32().
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.18 92/02/14 15:57:52 chrisg Exp Locker: chrisg $
a811 1
COLORMASK	equ	$ff000000
d876 2
a877 1
ofs_stacksize		equ	ofs_maxcolor+4
d890 5
a894 3
	and.l	#COLORMASK,d1
	and.l	#COLORMASK,d2
	and.l	#COLORMASK,d3
d951 4
@


39.18
log
@  new loadrgb32 parameters!
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.17 92/01/29 16:33:08 spence Exp Locker: chrisg $
d14 1
d23 1
a23 1
	xref	_LVOSetRGB4
a24 1
	xref	_Forbid,_Permit
d84 3
a86 1
	bsr	_Forbid
a88 1
	move.l	gb_ExecBase(a6),a6		; get execbase
d136 1
a137 1
	bsr	_Permit
d276 2
a478 1
	print	'lrgb32'
d570 11
a580 44
	movem.l	a2/d2/d3/d6/d7,-(a7)
	move.l	vp_ColorMap(a0),a1
	add.l	d0,d0
	tst.b	cm_Type(a1)
	beq.s	no_lowbits
	move.l	cm_LowColorBits(a1),d7
	beq.s	no_lowbits
	move.l	d7,a1
; now, merge lower nibbles into one word.
	move.l	d1,d7
	swap	d7
	and.l	#$0f00,d7
	move.l	d2,d6
	lsr.l	#4,d6
	swap	d6
	and.w	#$00f0,d6
	or.w	d6,d7
	move.l	d3,d6
	lsr.l	#8,d6
	swap	d6
	and.w	#$000f,d6
	or.w	d6,d7
	move.w	d7,0(a1,d0.l)

no_lowbits:
	move.l	#$f0000000,d7
	and.l	d7,d1
	and.l	d7,d2
	and.l	d7,d3
	lsr.l	#4,d1
	lsr.l	#8,d2
	lsr.l	#8,d3
	lsr.l	#4,d3
	or.l	d2,d1
	or.l	d3,d1
	swap	d1
	move.l	vp_ColorMap(a0),a1
	move.l	cm_ColorTable(a1),a1
	move.w	d1,0(a1,d0.l)
	move.l	a0,a2
	bsr	_pokecolors
	movem.l	(a7)+,a2/d2/d3/d6/d7
an_rts	rts

@


39.17
log
@Check copperlist address against 0, not 4.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.16 92/01/29 14:30:38 chrisg Exp Locker: spence $
d432 2
a433 2
*       LoadRGB32(  vp,  c1,   n,  table )
*                   a0   d0   d1    a1
d435 1
a435 1
*       void LoadRGB32( struct ViewPort *, ULONG, ULONG, ULONG *);
d439 2
a440 3
*	c1 = the first color register to set
*       n = the number of color registers to set.
*       table=a pointer to a series of 32-bit RGB triplets.
d448 15
d469 1
d471 1
d476 2
a477 1
	movem.l	d2-d6/a2-a4,-(a7)
a485 4
	add.l	d0,d0
	add.l	d0,a3
	add.l	d0,a4
	subq	#1,d1				; for dbra
d489 8
d508 1
a508 1
	move.w	d2,(a4)+
d521 4
a524 2
	move.w	d2,(a3)+
	dbra	d1,loadrgb_lp
d526 1
a526 1
	movem.l	(a7)+,d2-d6/a2-a4
@


39.16
log
@  made check both coplists for null. dpaint may be doing something strange when
animating.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.15 91/12/20 15:39:17 chrisg Exp Locker: chrisg $
d699 2
a700 2
	cmp	#4,a4
	beq	no_dspins
d804 1
@


39.15
log
@slight optimization
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.14 91/11/25 16:05:53 chrisg Exp Locker: chrisg $
d699 2
@


39.14
log
@  made obatinpen look at the proper bit in flags.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.13 91/11/21 10:38:16 chrisg Exp Locker: chrisg $
d718 3
a720 1
	cmp.w	#COPPER_MOVE,d2
d747 3
a749 1
	cmp.w	#COPPER_MOVE,d2
@


39.13
log
@  added pen_no_setcolor flag
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.12 91/11/18 17:46:31 spence Exp Locker: chrisg $
d334 1
a334 1
	btst	#2,d4
@


39.12
log
@Whoops - still checks SPRITE bit in vp->Modes rather than d7.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.11 91/11/18 16:38:57 spence Exp Locker: spence $
d240 2
a241 2
*	flags= the only flag currently in use is PEN_EXCLUSIVE. All other
*		bits should be zero.
d243 4
d252 1
a252 1
*	same screen may be using it. With PALETTE_EXCLUSIVE mode, you can
d334 2
a348 1
	
@


39.11
log
@Was checking wrong bits for HAM and dualpf.
Was using RasInfo instead of BitMap for 2nd playfield.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.10 91/11/18 11:42:18 chrisg Exp Locker: spence $
d1211 1
a1211 1
	btst	#14,d7				; SPRITES?
@


39.10
log
@ fixed potential semaphore problem.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.9 91/11/11 16:10:11 chrisg Exp Locker: chrisg $
d1180 1
a1180 1
	btst	#3,d7				; HAM?
d1193 1
a1193 1
	btst	#2,d7				; DUALPF?
d1200 1
d1211 1
a1211 1
	btst	#6,vp_Modes(a0)			; SPRITES?
d1226 1
a1226 2
	movem.l	(a7)+,d2/d7/a2/a3/a4
	rts
@


39.9
log
@ fixed genlock chromapen thing
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.8 91/11/11 11:45:14 chrisg Exp Locker: chrisg $
d640 5
a650 5
	move.b	gb_ChipRevBits0(a6),d4
	move.l	gb_ActiViewCprSemaphore(a6),a0
	move.l	a6,-(a7)
	move.l	gb_ExecBase(a6),a6
	jsr	_LVOObtainSemaphore(a6)
d794 4
a797 3
	move.l	(a7)+,a0					; get back gfxbase
	move.l	gb_ExecBase(a0),a6
	move.l	gb_ActiViewCprSemaphore(a0),a0
a798 1
no_dspins:
@


39.8
log
@ fixed color scrambler.
 made pokecolors use color scrambler
 mae pokecolors call _new_mode
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.7 91/11/08 11:29:09 chrisg Exp $
d622 1
a622 1
	movem.l	d2-d5/a0-a6,-(a7)
d633 1
d635 4
a638 1

d669 1
a669 1

d756 1
d800 1
a800 1
	movem.l	(a7)+,d2-d5/a0-a6
@


39.7
log
@ a) changed some palette sharing function names
 b) fixed bug with pokecolors in ECS 35ns modes
 c) added some (untested) color scrambling code
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.6 91/10/30 15:48:36 chrisg Exp Locker: chrisg $
d622 6
a627 2
	movem.l	d2-d4/a0-a6,-(a7)
	lea	-32(a7),a7
a632 1

a634 18
	move.l	a2,-(a7)
	jsr	_new_mode				; d0=modes
	addq.l	#4,a7
	and.l	#V_SUPERHIRES,d0				; super hires?
	beq.s	no_hedley
	btst	#GFXB_AA_MLISA,gb_ChipRevBits0(a6)		; super hires not scrambled 
								; in AA chips
	bne.s	no_hedley
must_load_hedley:
	move.l	vp_ColorMap(a2),-(a7)
	beq.s	no_colormap1
	move.l	a0,-(a7)
	jsr	_hedley_load
	addq.l	#4,a7
no_colormap1:
	addq.l	#4,a7
	bra	no_dspins				; go to exit point
no_hedley:
d664 18
d794 2
a795 2
	lea	32(a7),a7
	movem.l	(a7)+,d2-d4/a0-a6
d1130 1
a1130 1
	movem.l	d2/a2/a3/a4,-(a7)
d1141 6
d1158 6
d1175 1
a1175 1
	btst	#3,vp_Modes(a0)			; HAM?
d1188 1
a1188 1
	btst	#2,vp_Modes(a0)			; DUALPF?
d1211 1
a1211 1
	movem.l	(a7)+,d2/a2/a3/a4
d1220 1
a1220 1
	movem.l	(a7)+,d2/a2/a3/a4
d1394 16
a1409 16
	dc.b	sc_A,sc_B,sc_A,sc_B,sc_A,sc_C,sc_D,sc_C,sc_D,sc_E,sc_F,sc_E,sc_F
	dc.b	sc_G,sc_H,sc_A,sc_B,sc_A,sc_I,sc_J,sc_C,sc_D,sc_K,sc_L,sc_E,sc_F
	dc.b	sc_M,sc_N,sc_A,sc_B,sc_A,sc_O,sc_P,sc_C,sc_D,sc_Q,sc_R,sc_E,sc_F
	dc.b	sc_S,sc_T,sc_A,sc_B,sc_A,sc_U,sc_V,sc_C,sc_D,sc_W,sc_X,sc_E,sc_F
	dc.b	sc_A,sc_B,sc_G,sc_H,sc_A,sc_C,sc_D,sc_I,sc_J,sc_E,sc_F,sc_K,sc_L
	dc.b	sc_G,sc_H,sc_G,sc_H,sc_A,sc_I,sc_J,sc_I,sc_J,sc_K,sc_L,sc_K,sc_L
	dc.b	sc_M,sc_N,sc_G,sc_H,sc_A,sc_O,sc_P,sc_I,sc_J,sc_Q,sc_R,sc_K,sc_L
	dc.b	sc_S,sc_T,sc_G,sc_H,sc_A,sc_U,sc_V,sc_I,sc_J,sc_W,sc_X,sc_K,sc_L
	dc.b	sc_A,sc_B,sc_M,sc_N,sc_A,sc_C,sc_D,sc_O,sc_P,sc_E,sc_F,sc_Q,sc_R
	dc.b	sc_G,sc_H,sc_M,sc_N,sc_A,sc_I,sc_J,sc_O,sc_P,sc_K,sc_L,sc_Q,sc_R
	dc.b	sc_M,sc_N,sc_M,sc_N,sc_A,sc_O,sc_P,sc_O,sc_P,sc_Q,sc_R,sc_Q,sc_R
	dc.b	sc_S,sc_T,sc_M,sc_N,sc_A,sc_U,sc_V,sc_O,sc_P,sc_W,sc_X,sc_Q,sc_R
	dc.b	sc_A,sc_B,sc_S,sc_T,sc_A,sc_C,sc_D,sc_U,sc_V,sc_E,sc_F,sc_W,sc_X
	dc.b	sc_G,sc_H,sc_S,sc_T,sc_A,sc_I,sc_J,sc_U,sc_V,sc_K,sc_L,sc_W,sc_X
	dc.b	sc_M,sc_N,sc_S,sc_T,sc_A,sc_O,sc_P,sc_U,sc_V,sc_Q,sc_R,sc_W,sc_X
	dc.b	sc_S,sc_T,sc_S,sc_T,sc_A,sc_U,sc_V,sc_U,sc_V,sc_W,sc_X,sc_W,sc_X
d1413 2
d1419 1
a1420 1
	moveq	#0,d3
@


39.6
log
@vectored _pokecolors
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.5 91/10/30 15:17:06 spence Exp Locker: chrisg $
d27 2
a28 2
	xdef	_AttachPalExtra,_FreePalette,_SetRGB32,_LoadRGB32
	xdef	_PickBestColor,_SearchColorMap,_AllocPalette
d35 1
a35 1
*			  colormap. (V38)
d65 1
a65 1
*	GetColorMap() FreeColorMap() AllocPalette()
d145 2
a146 2
_FreePalette:
******* graphics.library/FreePalette ********************************************
d149 6
a154 6
*       FreePalette -- Release an allocated palette entry to the free pool. (V38)
*
*
*   SYNOPSIS
*       FreePalette( cm, n)
*		      a0 d0
d156 1
a156 1
*	void FreePalette( Struct ColorMap *, ULONG);
d175 1
a175 1
*	GetColorMap() AllocPalette()
d218 2
a219 2
_AllocPalette:
******* graphics.library/AllocPalette *******************************************
d222 6
a227 6
*       AllocPalette -- Obtain a free palette entry for use by your program. (V38)
*
*
*   SYNOPSIS
*       n | -1= AllocPalette( cm, n, r, g, b, flags)
*	d0		      a0 d0  d1 d2 d3  d4
d229 1
a229 1
*	ULONG AllocPalette(struct ColorMap *,ULONG,ULONG,ULONG,ULONG,ULONG);
d240 2
a241 1
*	flags= the only flag currently in use is PALETTE_EXCLUSIVE
d255 1
a255 1
*		Generally, for shared access, you should use PickColorMap()
d263 1
a263 1
*	GetColorMap() FreePalette() AttachPalExtra()
d347 1
a347 1
*       GetRGB32 -- Set a series of color registers for this Viewport. (V38)
d424 1
a424 1
*       LoadRGB32 -- Set a series of color registers for this Viewport. (V38)
d505 1
a505 1
*       SetRGB32 -- Set one color register for this Viewport. (V38)
d637 1
a637 1
	btst	#GFXB_AA_LISA,gb_ChipRevBits0(a6)		; super hires not scrambled 
d648 1
a648 4
	move.l	gb_current_monitor(a6),-(a7)
	bsr	_update_top_color
	addq.l	#4,a7
	rts
d804 1
a804 1
*       Search for a close color match, using a user-supplied procedure. (V38)
d1004 7
a1010 6
	lsr.l	#8,d1
	lsr.l	#8,d2
	lsr.l	#8,d3
	lsr.l	#8,d5
	lsr.l	#8,d6
	lsr.l	#8,d7
d1012 28
a1039 8
	sub.w	d2,d6
	sub.w	d3,d7
	muls	d5,d5
	muls	d6,d6
	muls	d7,d7
	move.l	d5,d0
	add.l	d6,d0
	add.l	d7,d0
d1048 1
a1048 1
*       Search for the closest color match, or allocate a new one. (V38)
d1347 69
@


39.5
log
@All ColorMap pointers are checked for NULL.
create_color_bits() sets 1st 32 bits if ColorMap is NULL for default
palette.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.4 91/10/29 10:45:21 chrisg Exp Locker: spence $
d16 3
d610 2
d614 7
@


39.4
log
@ killed vestige of hedley stuff
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.3 91/10/04 12:19:12 chrisg Exp Locker: chrisg $
d1120 1
a1120 1
	beq.s	no_colormap
d1160 1
a1160 1
	beq.s	no_colormap
d1164 1
a1164 1
no_colormap:
d1177 3
a1180 1

d1275 2
d1286 1
d1293 2
d1313 1
a1313 1
	beq.s	3$
d1315 2
a1316 1
3$:	rts
@


39.3
log
@ fixed colors for attached sprites and fixed bordersprites.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.2 91/08/28 11:20:25 chrisg Exp Locker: chrisg $
a618 2
	btst	#VPB_A2024,vp_ExtendedModes(a2)
	bne.s	must_load_hedley
a621 4
	cmp.l	#A2024TENHERTZ_KEY,d0
	beq.s	must_load_hedley
	cmp.l	#A2024FIFTEENHERTZ_KEY,d0
	beq.s	must_load_hedley
@


39.2
log
@ fixed bug in allocpalette
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.1 91/08/27 16:25:25 chrisg Exp Locker: chrisg $
d1099 1
a1099 1
; void __asm create_color_table(register __a0 vp, register __a1 bit_mask)
d1118 2
a1119 2
;	uwordmask[spofs0*2] |= $7777		set sprite bits. sprites use 1,2,3,5,..
;	uwordmask[spofs1*2] |= $7777		
d1123 1
a1123 1
;	if sprites then uwordmask[1] |= $7777
d1169 1
a1169 1
	or.w	#$7777,2(a1)			; set sprite colors!
d1176 1
a1176 1
	or.w	#$7777,0(a1,d0.w)
d1179 1
a1179 1
	or.w	#$7777,0(a1,d0.w)
d1228 1
a1228 1
; int __asm testbit(register __a0 base, register __d0 bitnum);
d1245 1
a1245 1
; int __asm numbits(register __d1 ulong1);
d1261 1
a1261 1
; int __asm color_ofs_bits(register __d1 number)
d1278 1
a1278 1
; int __asm _get_bplcon4(register __a0 struct ColorMap * cm );
d1292 1
a1292 1
; int __asm _get_bplcon3(register __a0 struct ColorMap * cm );
d1313 1
a1313 1
	addq	#1,d0
@


39.1
log
@  fixed color poker for non-AA
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 39.0 91/08/21 17:29:14 chrisg Exp Locker: chrisg $
d286 1
a288 1
	move.l	pe_AllocList(a2),a0
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 38.11 91/08/20 16:04:43 chrisg Exp Locker: chrisg $
d691 1
a691 1
	bne.s	sync_old_lof
@


38.11
log
@  removes debug line
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 38.10 91/08/07 13:44:12 chrisg Exp Locker: chrisg $
@


38.10
log
@ fixed GetRGB32 to not set extraneous low bits.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 38.9 91/08/02 15:22:15 chrisg Exp Locker: chrisg $
a203 1
	move.w	#$f00,$dff180
d1042 1
a1042 1
*	to the specified color. If their is no color within your tolerance,
@


38.9
log
@  Added GetRGB32 function
@
text
@d3 1
a3 1
*	$Id: NewColorStuff.asm,v 38.8 91/07/12 16:30:26 chrisg Exp Locker: chrisg $
d369 2
d397 1
d409 1
@


38.8
log
@added loadrgb32 call.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 38.7 91/07/03 14:32:09 chrisg Exp Locker: chrisg $
d341 73
@


38.7
log
@ made SetRGB32 preserve A2!!!
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 38.6 91/07/03 10:48:17 chrisg Exp Locker: chrisg $
d24 1
a24 1
	xdef	_AttachPalExtra,_FreePalette,_SetRGB32
d341 81
@


38.6
log
@  Added new routine PokeColors to update copper list for a viewport for
new colors. must add genlock modes!!!!
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 38.5 91/06/19 12:54:30 spence Exp Locker: chrisg $
d379 1
a379 1
	movem.l	d2/d3/d6/d7,-(a7)
d420 1
a420 1
	movem.l	(a7)+,d2/d3/d6/d7
@


38.5
log
@get_bplcon3 was using d0 instead of d1
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 38.4 91/06/18 11:08:06 chrisg Exp Locker: spence $
d14 4
a17 2
	include	'graphics/gfxbase.i'
	
d22 1
d381 3
a400 1
	add.l	d0,d0
a401 1
	lsr.l	#1,d0
d404 1
a404 4
	moveq	#$f,d7
	rol.l	#4,d1
	rol.l	#4,d2
	rol.l	#4,d3
d408 12
a419 1
	jsr	_LVOSetRGB4(a6)
d421 214
d1045 1
a1045 1
	lea	1(a4),a4
d1137 3
d1143 1
@


38.4
log
@ optimized and made save d2/d3
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 38.3 91/06/14 11:07:53 chrisg Exp Locker: chrisg $
d911 2
a912 2
	move.w	cm_Bp_1_base(a0),d0
	sub.w	cm_Bp_0_base(a0),d0
@


38.3
log
@ Added bit vector routines, get_bplcon3 and get_bplcon4, for AA
color build.
@
text
@d3 1
a3 1
*	$Id: newcolorstuff.asm,v 38.2 91/06/06 14:14:03 chrisg Exp Locker: chrisg $
d376 1
a376 1
	movem.l	d6/d7,-(a7)
d400 1
a400 2
	move.l	d0,d7
	moveq	#$f,d0
d404 3
a406 4
	and.l	d0,d1
	and.l	d0,d2
	and.l	d0,d3
	move.l	d7,d0
d408 1
a408 1
	movem.l	(a7)+,d6/d7
@


38.2
log
@  Fixed bug with allocating a color.
  made SetRGB32 store lower color nibbles.
@
text
@d3 1
a3 1
*	$Id: NewColorStuff.asm,v 38.1 91/06/03 16:48:07 chrisg Exp Locker: chrisg $
d710 220
@


38.1
log
@  Reduced number of function entry points. changed names.
@
text
@d3 1
a3 1
*	$Id: NewColorStuff.asm,v 38.0 91/05/29 16:37:57 chrisg Exp Locker: chrisg $
d317 1
a317 1
	move.w	pe_FirstShared+1(a2),0(a0,d7.w)
d376 25
a400 1
	move.l	d0,a1
d408 4
a411 2
	move.l	a1,d0
	jmp	_LVOSetRGB4(a6)
@


38.0
log
@  First check in (V38.0)
@
text
@d3 1
a3 1
*	$Id: Exp $
d10 1
a10 1
	include	'/view.i'	* use local include file FOR NOW!!!
d21 2
a22 3
	xdef	_AttachPalExtra,_FreePalEntry,_AllocPalExclusive,_SetRGB32
	xdef	_PickBestColor,_SearchColorMap
	xdef	_AllocAbsPalShared
d29 1
a29 1
*			  colormap.
d59 1
a59 2
*	GetColorMap() FreeColorMap() AllocPalEntryShared() AllocPalExclusive()
*	AllocAbsPal() AllocAbsPalShared()
d139 2
a140 2
_FreePalEntry:
******* graphics.library/FreePalEntry ********************************************
d143 1
a143 1
*       FreePalEntry -- Release an allocated palette entry to the free pool.
d147 1
a147 1
*       FreePalEntry( cm, n)
d150 1
a150 1
*	void FreePalEntry( Struct ColorMap *, ULONG);
d169 1
a169 2
*	GetColorMap() AllocPalEntryShared() AllocPalExclusive()
*	AllocAbsPal() AllocAbsPalShared()
a172 1
	move.l	d0,d2
a176 1
	move.l	d2,d0
d213 2
a214 2
_AllocPalExclusive:
******* graphics.library/AllocPalExclusive **************************************
d217 6
a222 7
*       AllocPalExclusive -- Obtain a free palette entry for exclusive use by
*			     your program.
*
*
*   SYNOPSIS
*       n | -1=AllocPalExclusive( cm)
*	d0			  a0
d224 1
a224 1
*	ULONG AllocPalExclusive(struct ColorMap *);
d227 2
a228 3
*	Attempt to allocate an entry in the colormap for exclusive
*	use by the application. If successful, you should free
*	this entry after you have finished with it.
d232 4
d237 16
a252 4
*   BUGS
*
*   NOTES
*	If there is no Palextra attached to the colormap, then this
d257 1
a257 2
*	GetColorMap() AllocPalEntryShared() FreePalEntry()
*	AllocAbsPal() AllocAbsPalShared()
d260 4
a263 4
; trashes d0,a0
	move.l	cm_PalExtra(a0),d0		; colorinfo fattened?
	beq	none_free
	movem.l	d7/a2/a6,-(a7)
d265 4
a268 1
	move.l	d0,a2
d272 1
d274 2
a275 4
	beq	none_free2
	moveq	#0,d7				; zero upper bits
	subq.w	#1,pe_NFree(a2)			; dec avail count
	move.w	pe_FirstFree(a2),d7		; get next avail
d277 2
a278 10
	addq.b	#1,0(a0,d7.w)			; refcnt[alloc]++
	move.l	pe_AllocList(a2),a0
	move.b	0(a0,d7.w),pe_FirstFree+1(a2)	; firstfree=alloc->next
none_free2:
return1:
	lea	pe_Semaphore(a2),a0
	jsr	_LVOReleaseSemaphore(a6)
	move.l	d7,d0
	movem.l	(sp)+,d7/a2/a6
	rts
a279 47
	xdef	_AllocAbsPalExclusive

_AllocAbsPalExclusive:
******* graphics.library/AllocAbsPalExclusive ***********************************
*
*   NAME
*       AllocAbsPalExclusive -- Attempt to allocate a specific palette entry for
*			 exclusive use.
*
*   SYNOPSIS
*       success?=AllocAbsPalExclusive( cm, n)
*	d0		  	       a0  d0
*
*	BOOL AllocAbsPalExclusive(struct ColorMap *,ULONG);
*
*   FUNCTION
*	Attempt to allocate a specific entry in the colormap for exclusive
*	use by the application. If successful, you should free
*	this entry after you have finished with it.
*
*   INPUTS
*       cm  =  A pointer to a color map created by GetColorMap().
*	n   =  The specific color that you want.
*
*   BUGS
*
*   NOTES
*	If there is no Palextra attached to the colormap, then this
*	routine will always fail. This routine does not work if called
*	on 1.3 format ColorMap structures.       
*	Do not attempt to allocate a color which isn't in the color map!
*
*   SEE ALSO
*	GetColorMap() AllocPalEntryShared() FreePalEntry()
*	AllocAbsPal() AllocAbsPalShared()
*
*********************************************************************************
; trashes d0,a0
	movem.l	d7/a2/a6,-(a7)
	moveq	#0,d7				; ret value
	move.l	cm_PalExtra(a0),d1		; colorinfo fattened?
	beq.s	return1
	move.l	d1,a2
	lea	pe_Semaphore(a2),a0
	move.l	gb_ExecBase(a6),a6
	jsr	_LVOObtainSemaphore(a6)
	move.l	pe_RefCnt(a2),a0
d282 2
a283 2
	addq.b	#1,0(a0,d0.l)		; bump ref cnt
	moveq	#-1,d7				; return success
d285 1
a285 1
	beq.s	return1
d287 2
a288 2
	move.w	pe_FirstFree(a2),d1
	cmp.w	d1,d0				; first=got?
d290 3
a292 3
	move.b	0(a0,d0.l),d1
	move.w	d1,pe_FirstFree(a2)		; first=first->next
	bra	return1
d294 1
a294 1
	cmp.b	0(a0,d1.w),d0			; i->next=n?
d296 2
a297 2
	move.b	0(a0,d0.w),0(a0,d1.w)		; i->next=n->next
	bra	return1
d299 1
a299 1
	move.b	0(a0,d1.w),d1			; i = i->next
d303 7
a309 42
_AllocAbsPalShared:
******* graphics.library/AllocAbsPalShared ***********************************
*
*   NAME
*       AllocAbsPalShared -- Attempt to allocate a specific palette entry for
*			 shared use.
*
*   SYNOPSIS
*       success?=AllocAbsPalShared( cm, n, r, g, b)
*	d0		  	   a0  d0 d1 d2 d3
*
*	BOOL AllocAbsPalShared(struct ColorMap *,ULONG,ULONG,ULONG);
*
*   FUNCTION
*	Attempt to allocate a specific entry in the colormap for shared
*	use by the application. If successful, you should free
*	this entry after you have finished with it.
*
*   INPUTS
*       cm  =  A pointer to a color map created by GetColorMap().
*	n   =  The specific color that you want.
*	r   =  the red value desired for this color, in 32 bit format.
*	g   =  the green value desired for this color.
*	b   =  the blue value desired for this color register
*   BUGS
*
*   NOTES
*	If there is no Palextra attached to the colormap, then this
*	routine will always fail. This routine does not work if called
*	on 1.3 format ColorMap structures.       
*	Do not attempt to allocate a color which isn't in the color map!
*
*   SEE ALSO
*	GetColorMap() AllocPalEntryShared() FreePalEntry()
*	AllocAbsPal() AllocAbsPalShared() AllocAbsPalExclusive()
*
*********************************************************************************
; trashes d0,a0
	movem.l	a0/a6/d0/d1/d2/d3,-(a7)
	move.l	gb_ExecBase(a6),a6
	move.l	cm_PalExtra(a0),a0
	jsr	_LVOObtainSemaphore(a6)
d311 16
a326 17
	movem.l	(a7),a0/a6/d0/d1/d2/d3

	bsr	_AllocAbsPalExclusive		; should call thru vector?
	tst.l	d0
	bmi.s	failed

	movem.l	(a7),a0/a6/d0/d1/d2/d3

	move.l	cm_PalExtra(a0),a0
	addq.w	#1,pe_NShared(a0)
	move.l	pe_AllocList(a0),a1
	move.b	pe_FirstShared+1,0(a1,d0.l)
	move.w	d0,pe_FirstShared(a0)

	move.l	pe_ViewPort(a0),a0
	bsr	_SetRGB32			; should call via vector?
	movem.l	(a7),a0/a6/d0/d1/d2/d3
d328 2
a329 1
	move.l	cm_PalExtra(a0),a0
d331 4
a334 1
	movem.l	(a7)+,a0/a6/d0/d1/d2/d3
d336 1
a336 7
failed:	movem.l	(a7),a0/a6/d0/d1/d2/d3
	move.l	gb_ExecBase(a6),a6
	move.l	cm_PalExtra(a0),a0
	jsr	_LVOReleaseSemaphore(a6)
	movem.l	(a7)+,a0/a6/d0/d1/d2/d3
	moveq	#-1,d0
	rts
d341 1
a341 1
*       SetRGB32 -- Set one color register for this Viewport.
d390 1
a390 1
******* graphics.library/SearchColorMap****************************************
d393 1
a393 1
*       Search for a close color match, using a user-supplied procedure.
d395 3
a397 3
*   SYNOPSIS
*       color | -1 =SearchColorMap(  cm,  proc, R,   G,    B,    MaxError)
*                                   a0     a1 d1   d2    d3     d4
d399 2
a400 1
*       ULONG SearchColorMap( struct ColorMap *, (*int)(), ULONG, ULONG, ULONG, ULONG );
d409 1
a409 1
*
d429 1
a429 1
*	If this call succceeds, then you must call FreePalEntry() when you are done
d436 5
d443 2
a444 2
*	GetColorMap() PickBestColor() FreePalEntry()
*	AllocAbsPal() AllocAbsPalShared()
d453 2
a454 1
ofs_stacksize		equ	ofs_gbase+4
d463 1
d488 2
d613 1
a613 1
******* graphics.library/PickBestColor****************************************
d616 1
a616 1
*       Search for the closest color match, or allocate a new one.
d618 3
a620 3
*   SYNOPSIS
*       color | -1 =PickBestColor(  cm,  R,   G,    B,    Precision)
*                                   a0   d1   d2    d3     d4
d622 2
a623 1
*       ULONG PickBestColor( struct ColorMap *, ULONG, ULONG, ULONG, ULONG );
d631 1
d644 2
a645 2
*	If this call succceeds, then you must call FreePalEntry() when you are done
*	with the color.
d647 4
a650 1
*	PRECISION_
d653 1
a653 2
*	GetColorMap() AllocPalEntryShared() FreePalEntry()
*	AllocAbsPal() AllocAbsPalShared() SearchColorMap()
@
