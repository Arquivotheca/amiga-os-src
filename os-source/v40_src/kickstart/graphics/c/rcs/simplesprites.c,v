head     39.4;
branch   ;
access   ;
symbols  rel39_24:39.4 rel39_18:39.4 rel39_97:39.4 rel39_90:39.4 rel39_89:39.4 rel39_82:39.4 rel39_76:39.4 rel39_71:39.4 rel39_65:39.4 rel39_64:39.4 rel39_61:39.4 rel39_60:39.4 rel39_55:39.4 rel39_52:39.4 rel39_47:39.4 rel39_39:39.3 rel39_38:39.3 rel39_37:39.3 rel39_35:39.3 rel39_34:39.3 V37_30:37.0 V37_29:37.0 V37_28:37.0 V37_27:37.0 V37_25:37.0 V37_24:37.0 V37_23:37.0 V37_22:37.0 V37_21:37.0 V37_20:37.0 V37_19:37.0 V37_17:37.0 V37_15:37.0 V37_14:37.0 V37_13:37.0 V37_12:37.0 V37_11:37.0 V37_10:37.0 V37_9:37.0 V37_8:37.0 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.23 V36_208:36.23 V36_207:36.23 V36_205:36.23 V36_203:36.23 V36_202:36.23 V36_201:36.23 V36_200:36.23 V36_199:36.23 V36_198:36.23 V36_196:36.23 V36_195:36.23 V36_194:36.23 V36_193:36.23 V36_192:36.23 V36_191:36.23 V36_190:36.23 V36_189:36.23 V36_188:36.23 V36_186:36.23 V36_185:36.23 V36_184:36.23 V36_182:36.23 V36_181:36.23;
locks    ; strict;
comment  @ * @;


39.4
date     92.04.03.16.58.52;  author chrisg;  state Exp;
branches ;
next     39.3;

39.3
date     91.10.15.15.53.26;  author chrisg;  state Exp;
branches ;
next     39.2;

39.2
date     91.10.10.09.49.52;  author chrisg;  state Exp;
branches ;
next     39.1;

39.1
date     91.08.27.16.53.07;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.22.26;  author chrisg;  state Exp;
branches ;
next     37.2;

37.2
date     91.05.20.11.21.22;  author chrisg;  state Exp;
branches ;
next     37.1;

37.1
date     91.05.02.13.05.39;  author chrisg;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.20.59;  author spence;  state Exp;
branches ;
next     36.23;

36.23
date     90.07.27.17.00.09;  author bart;  state Exp;
branches ;
next     36.22;

36.22
date     90.03.28.09.12.06;  author bart;  state Exp;
branches ;
next     36.21;

36.21
date     90.03.08.12.21.33;  author bart;  state Exp;
branches ;
next     36.20;

36.20
date     90.03.06.15.46.47;  author bart;  state Exp;
branches ;
next     36.19;

36.19
date     89.08.22.13.08.34;  author bart;  state Exp;
branches ;
next     36.18;

36.18
date     89.08.22.09.36.29;  author bart;  state Exp;
branches ;
next     36.17;

36.17
date     89.03.13.10.33.14;  author bart;  state Exp;
branches ;
next     36.16;

36.16
date     89.03.10.14.46.45;  author bart;  state Exp;
branches ;
next     36.15;

36.15
date     89.03.09.16.03.57;  author bart;  state Exp;
branches ;
next     36.14;

36.14
date     89.02.24.19.09.26;  author bart;  state Exp;
branches ;
next     36.13;

36.13
date     89.02.23.11.10.36;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     88.10.31.10.30.01;  author bart;  state Exp;
branches ;
next     36.11;

36.11
date     88.10.18.16.54.40;  author bart;  state Exp;
branches ;
next     36.10;

36.10
date     88.09.11.14.00.31;  author bart;  state Exp;
branches ;
next     36.9;

36.9
date     88.09.01.11.57.17;  author bart;  state Exp;
branches ;
next     36.8;

36.8
date     88.09.01.09.30.02;  author bart;  state Exp;
branches ;
next     36.7;

36.7
date     88.08.18.21.19.28;  author dale;  state Exp;
branches ;
next     36.6;

36.6
date     88.07.15.16.10.12;  author dale;  state Exp;
branches ;
next     36.5;

36.5
date     88.07.15.15.18.18;  author dale;  state Exp;
branches ;
next     36.4;

36.4
date     88.06.10.11.43.57;  author dale;  state Exp;
branches ;
next     36.3;

36.3
date     88.05.03.15.32.42;  author dale;  state Exp;
branches ;
next     36.2;

36.2
date     88.05.17.22.44.41;  author dale;  state Exp;
branches ;
next     36.1;

36.1
date     88.03.10.16.12.17;  author dale;  state Exp;
branches ;
next     ;


desc
@@


39.4
log
@ killed simplesprites.c
@
text
@/******************************************************************************
*
*	$Id: simplesprites.c,v 39.3 91/10/15 15:53:26 chrisg Exp Locker: chrisg $
*
******************************************************************************/


		OBSOLETE
@


39.3
log
@  all code now in a/simplesprites.asm
@
text
@d3 1
a3 1
*	$Id: simplesprites.c,v 39.2 91/10/10 09:49:52 chrisg Exp Locker: chrisg $
a6 10
#include <exec/types.h>
#include <exec/nodes.h>
#include <exec/lists.h>
#include <exec/interrupts.h> 
#include <exec/libraries.h>
#include "/copper.h"
#include "/gfx.h"
#include "/gfxbase.h"
#include "/view.h"
#include "/sprite.h"
d8 1
a8 6
#include "/macros.h"

#include "gfxprivate.h"
#include "c.protos"

/* simplified sprite machine */
@


39.2
log
@ downcoded some sprite stuff while doing sprite work.
@
text
@d3 1
a3 1
*	$Id: simplesprites.c,v 39.1 91/08/27 16:53:07 spence Exp Locker: chrisg $
a23 744
/*#define DEBUG*/

/*#define	DEBUGMOVE*/

/*#define SimpleSprites reserved[0]*/

#define ATTACHED(s)	(sprite_attached(s))

#define MOVE_DOWN

#ifdef NOT_DEFINED
sprite_attached(s)
struct SimpleSprite *s;
{
	struct GfxBase *GB;
	short n;
	struct SimpleSprite *as;

	FETCHGBASE;

	n = s->num;
	if (n & 1)	return (FALSE);
		as = GB->SimpleSprites[n+1];
	if (!as)	return(FALSE);
	if (as->posctldata[1] & 0x80)	return (TRUE);
	return (FALSE);
}

getsprite(s,num)
short num;
struct SimpleSprite *s;
{
	struct GfxBase *GB;
	FETCHGBASE;
#ifdef DEBUG
	printf("getsprite(%lx,%lx,%ld)\n",GB,s,num);
#endif
    
	Forbid(); /* disable other tasks during search */
    if ( num == -1 ) /* user wants us to look for the first free sprite */
    {
		short i;
		for (i=0; i<8; i++)
		{
	    	if ( !(GB->SpriteReserved & (1<<i)) )
	    	{
				GB->SpriteReserved |= (1<<i);
				num = i;
				break;
	    	}
		}
    }
    else
    {
		num &= 0x7; /* keep num within the range 0..7 */

		if (!( (GB->SpriteReserved>>num) & 1))
		{
			GB->SpriteReserved |= 1<<num;
		}	else num = -1;

    }
	Permit(); /* REMEMBER TO PERMIT OTHER TASKS !!!*/
	s->num = num;	/* this is correct according to 1.2 doc */
			/* although not explicitly stated in 1.1 (-1)*/
	return(num);
}
#endif

#ifdef NOT_DEFINED
make_sprite_disappear(num)
int num;
{
	struct GfxBase *GB;
	UWORD   *k;

	FETCHGBASE;

	k = GB->copinit->sprstrtup + 4*num;
	k[1] = (long)(GB->copinit->sprstop) >> 16;
	k[3] = (short)(GB->copinit->sprstop);
}

make_sprite_appear(s)
struct SimpleSprite *s;
{
	struct GfxBase *GB;
	UWORD *pnew = s->posctldata;
	UWORD   *k;
	FETCHGBASE;

	k = GB->copinit->sprstrtup + 4*s->num;
	k[1] = (int)pnew>>16;
	k[3] = (UWORD)pnew;

}
#endif

#ifdef NOT_DEFINED
freesprite(num)
short num;
{
	struct GfxBase *GB;
    UWORD   *k;
	struct SimpleSprite **ns;

	FETCHGBASE;
#ifdef DEBUG
	printf("freesprite %ld\n",num);
#endif
    GB->SpriteReserved &= ~(1<<num);
	ns = (struct SimpleSprite *)GB->SimpleSprites;
	ns[num] = 0;
	make_sprite_disappear(num);
}
#endif

sprite_clipped(vp,s,flags)
struct ViewPort *vp;
struct SimpleSprite *s;
ULONG flags;
{
	struct SimpleSprite *as;
	struct GfxBase *GB;
	FETCHGBASE;
	/*kprintf("sprite_clipped(%lx,%lx)\n",vp,s);*/
	if (vp)
	{
	    if ( (vp->Modes & VP_HIDE) || /* completely unseen? */
	         (vp->DHeight < (WORD)(s->y)) || /* clipped bottom? */
		 (0>(((WORD)(((WORD)s->y)>>((flags&LACE)?1:0)))+((WORD)(s->height)))) ) 
		{
		    make_sprite_disappear(s->num);
		    if ATTACHED(s)	make_sprite_disappear(s->num+1);
		    return (TRUE);
		}
	}
	if ATTACHED(s)
	{
		struct SimpleSprite **ns;
		ns = GB->SimpleSprites;
		as = ns[s->num+1];
		if (as)	make_sprite_appear(as);
	}
	make_sprite_appear(s);
	return(FALSE);
}

__regargs cracksprite(UWORD *src,int cnta,int cntb,int cntd,int start)
{
	UWORD t;
	UWORD *p;
	int i_d,i;
	struct GfxBase *GB;
	FETCHGBASE;
	for (i_d = 0; i_d < cntd ; i_d++)
	{
		t = *src++;	/* get data to move */
		/* update primary sprites */
		for (i = 0; i < cnta ;i++)
		{
			p = GB->hedley_sprites[i];
			p[start+i_d] = t;
		};
		/* jam secondary sprites */
		for (i = 0; i < cntb ;i++)
		{
			p = GB->hedley_sprites1[i];
			p[start+i_d] = t;
		}
	}
}


changesprite(vp,s,pnew)
struct ViewPort *vp;
struct SimpleSprite *s;
UWORD *pnew;
{
	struct GfxBase *GB;
    struct View *view;
	FETCHGBASE;
#ifdef DEBUG
	kprintf("change sprite(%lx) to %lx\n",s,pnew);
#endif
    s->posctldata = pnew;

#ifdef NEW_HEDLEY
	if ((GB->hedley_flags & 5) && (s->num == 0))
	{
		/* crack data in half */
		/* copy data into 8 hires sprite holders */
    		UWORD *src,*d;
		int i;
		int maxheight = MIN(s->height,MAX_HEDLEYSPRITE_HEIGHT);
		src = pnew;
		GB->hedley_flags &= ~2;
		/* set up first 2 control words in all 8 sprites */
		if (GB->hedley_flags & 4)
		{	/* in 10hz */
			src[1] |= 0x80;	/* make attached */
			cracksprite(src,6,6,2,0);

			for (i = 0; i<maxheight; i++)
			{
				src += 2;	/* point to next data */
				if (i & 1)	/* odd row */
				{	/* send data to attached sprite */
					cracksprite(src,0,6,2,1+i);
				}
				else		/* even row */
				{	/* send data to primary sprites */
					cracksprite(src,6,0,2,2+i);
				}
			}
			/* now send last 2 words of control */
			cracksprite(src + 2,6,6,2,2 + maxheight);
		}
		else
		{	/* 15 hz */
			src[1] |= 0x80;	/* make attached */
			/* In this mode we use attached sprites but
				both sprite pointers actually point to
				the same sprite image */
			cracksprite(src,4,0,2+2+2*maxheight,0);
		}
	}
#endif

    /* force reserved sprite data to terminate sprite definition */
    /* *(ULONG*)((s->posctldata)+(((s->height)<<1)+2)) = 0xFFFFFFF7; */
#ifdef MOVE_DOWN
   movesprite_internal(vp,s,s->x,s->y,0);
#else
   movesprite(vp,s,s->x,s->y,0);
#endif

}

#ifdef MOVE_DOWN

movesprite(vp,s,x,y,a2024)
struct ViewPort *vp;
struct SimpleSprite *s;
short x,y;
int	a2024;
{
	struct GfxBase *GB;
	struct View *view;
	register ULONG *k;
	USHORT	hedley_flags;
	UWORD stopy, starty, startx, oldstarty;
	register ULONG	jam;
	int num = s->num;
	struct SimpleSprite **ns;
	short xprecision = 0;
	ULONG modes = vp?new_mode(vp):0;

#ifdef DEBUGMOVE
	kprintf("movesprite(%lx,%lx,(%lx,%lx),%ld)\n",
		vp,s,x,y,a2024);
#endif

	s->x = x;
	s->y = y;

	FETCHGBASE;

	if (!(view = GB->ActiView)) return;

#ifdef NEW_HEDLEY
	if(hedley_flags = (GB->hedley_flags & 5))
	{
	    starty = 0x2c;
	    startx = 0x81;

	    ns = (struct SimpleSprite **)GB->SimpleSprites;

	    if (hedley_flags & 4) startx -= 16;

	    if ( (a2024 == 0) && (num == 0) )
	    {
		int i,j;
		int height = MIN(s->height,MAX_HEDLEYSPRITE_HEIGHT);
		short xmin,ymin;
		short xmax,ymax;
		short xnew,ynew;
		short phys_rows = 400;
		short phys_cols = vp?512:256;
		struct SimpleSprite hires_ss;

		if (GB->DisplayFlags & PAL)	phys_rows = 512;

		if (hedley_flags & 1)
		{
			hires_ss.height = height;
			for(i = 0; i<4; i++)	/* 4 quadrants */
			{
				if (i&1)
				{
					ymin = phys_rows;
				}
				else
				{
					ymin = 0;
				}
				ymax = ymin + phys_rows - 1;
				if (i&2)
				{
					xmin = phys_cols;
				}
				else
				{
					xmin = 0;
				}
				xmax = xmin + phys_cols  - 1;
				xnew = x;
				ynew = phys_rows+10;	/* assume clipped out */
				if  ( (x<= xmax) && (x>=(xmin-32)) &&
				      (y<= ymax) && (y>=(short)(ymin-height-height)) )
				{
					xnew = x - xmin;
					ynew = y - ymin;
					GB->hedley_hint = 4*i;
				}
				/* otherwise only move main sprite for 15hz */
				hires_ss.posctldata = GB->hedley_sprites[i];
							hires_ss.num = num;
				movesprite_internal
				(vp,&hires_ss,xnew,ynew>>1,1);
			}
		}
		if (hedley_flags & 4)
		{
			hires_ss.height = height>>1;
			for(i = 0; i<6; i++)	/* 6 pieces */
			{
				if (i&1)
				{
					ymin = phys_rows;
				}
				else
				{
					ymin = 0;
				}
				ymax = ymin + phys_rows - 1;
#ifdef USE_SWITCH
				switch (i>>1)
				{
					case 0:
						xmin = 0;
						break;
					case 1:
						xmin = 336;
						break;
					case 2:
						xmin = 336+336;
						break;
				}
#else
				xmax = i>>1;	/* tmp reuse variable */
				xmin = 0;	/* assume left third */
				if (xmax == 1)	xmin = 336;	/* nope, middle*/
				else	if (xmax == 2)	xmin = 336+336;	/* right third */
#endif
				xmax = xmin + 351;
				xnew = x;
				ynew = phys_rows +10;	/* assume clipped out */
				if  ( (x<= xmax) && (x>=(xmin-16)) &&
				      (y<= ymax) && (y>=(short)(ymin-height)) )
				{
					/* make visable */
					xnew = x - xmin;
					ynew = y - ymin;
					GB->hedley_hint = 4*i;
				}
				ynew >>= 1;
				for (j = 0; j<2 ;j++)
				{
					{
						if (j == 0)
						{
					hires_ss.posctldata = GB->hedley_sprites[i];
							hires_ss.num = num;
						}
						else
						{
					hires_ss.posctldata = GB->hedley_sprites1[i];
							hires_ss.num = num + 1;
						}
					}
					movesprite_internal(vp,&hires_ss,xnew,ynew,1);
				}
			}
		}
		ns[num] = s;
		ns[num+1] = 0;
		return;
	    }
	}
	else
#endif
#ifdef MOVE_DOWN
	{
		/* kprintf("movesprite: should never get here???...\n"); */
	}
#else
	{
	    starty = view->DyOffset;
	    startx = view->DxOffset;

	    ns = (struct SimpleSprite **)GB->SimpleSprites;

	    if ATTACHED(s)
	    {
		    struct SimpleSprite *as;
		    if (as = ns[s->num+1])	movesprite(vp,as,x,y,a2024);
	    }
	}

	ns[num] = s;

	if (vp)
	{
	        x += vp->DxOffset;
	        y += vp->DyOffset;

		if (modes & SUPERHIRES) 
		{
		    x >>= 2;
		    xprecision = 2;
		}
		else
		{
		    if (modes & HIRES)
		    {
			x >>= 1;
			/* xprecision = 1;*/
			/* unimplemented yet */
		    }
		}
		if (modes & LACE)
		{
		    y >>= 1;
		}
	}

	/* corresponding to change in mrgcop */
	starty += y;

#define NOT_FUNNY
#ifdef NOT_FUNNY
	startx += x;
#else
	startx += x - 1;
#endif

	/* new code to correct for hardware design flaw */
	/* The sprite horizontal counters are reset prior to the */
	/* overscanned end of a line, so we must artificially wrap */
	/* the start position sooner */

	/* bart -- rewrote to work with variable MaxDiplayColumn information */
	/* the -1 correction term in startx prevents the sprite from */
	/* disappearing in the denise "cusp" case */

#define SPRITE_WRAP	9 /* the infamous four and one half colorclocks */
#define MAX_XSPRITE	(GB->MaxDisplayColumn + SPRITE_WRAP)
	if ( (startx > GB->MaxDisplayColumn) && (startx <= MAX_XSPRITE) )
	      startx -= (GB->MaxDisplayColumn-1); /* sprite can alias */

	/*kprint("startx:%lx",startx);*/

	stopy = oldstarty = starty;
	stopy += s->height;
	starty = MAX(21,starty); /* this is outdated, presupposes NTSC - bart */
	/* lets keep it visible maybe? */
	stopy += starty - oldstarty;
	if (!(k = s->posctldata)) return;	/* in case none exists yet */
	jam = (((starty<<8)|( (startx>>1) &0xff))<<16);
	jam |=  (s->posctldata[1] & 0x80) | 
	    (startx & 1) | 
	    ( (starty>>6) & 4) | 
	    ( ((s->x) & (3 >> (2 - xprecision))) << (5 - xprecision) ) |
	    ((stopy>>7)&2) | 
	    ((0xff&stopy)<<8) | 
	    ((starty>>3)&0x40) | 
	    ((stopy>>4)&0x20);
	*k = jam;

	if (!(hedley_flags))	sprite_clipped(vp,s,modes);
	/*kprintf("return from movesprite\n");*/
#endif
}

#else

movesprite(vp,s,x,y,a2024)
struct ViewPort *vp;
struct SimpleSprite *s;
short x,y;
int	a2024;
{
	struct GfxBase *GB;
	struct View *view;
	register ULONG *k;
	USHORT	hedley_flags;
	UWORD stopy, starty, startx, oldstarty;
	register ULONG	jam;
	int num = s->num;
	struct SimpleSprite **ns;
	short xprecision = 0;
	ULONG modes = vp?new_mode(vp):0;

#ifdef DEBUGMOVE
	kprintf("movesprite(%lx,%lx,(%lx,%lx),%ld)\n",
		vp,s,x,y,a2024);
#endif

	s->x = x;
	s->y = y;

	FETCHGBASE;

	if (!(view = GB->ActiView)) return;

#ifdef NEW_HEDLEY
	if(hedley_flags = (GB->hedley_flags & 5))
	{
	    starty = 0x2c;
	    startx = 0x81;

	    ns = (struct SimpleSprite **)GB->SimpleSprites;

	    if (hedley_flags & 4) startx -= 16;

	    if ( (a2024 == 0) && (num == 0) )
	    {
		int i,j;
		int height = MIN(s->height,MAX_HEDLEYSPRITE_HEIGHT);
		short xmin,ymin;
		short xmax,ymax;
		short xnew,ynew;
		short phys_rows = 400;
		struct SimpleSprite hires_ss;

		if (GB->DisplayFlags & PAL)	phys_rows = 512;

		if (hedley_flags & 1)
		{
			hires_ss.height = height;
			for(i = 0; i<4; i++)	/* 4 quadrants */
			{
				if (i&1)
				{
					ymin = phys_rows;
				}
				else
				{
					ymin = 0;
				}
				ymax = ymin + phys_rows - 1;
				if (i&2)
				{
					xmin = 256;
				}
				else
				{
					xmin = 0;
				}
				xmax = xmin + 256 - 1;
				xnew = x;
				ynew = phys_rows+10;	/* assume clipped out */
				if  ( (x<= xmax) && (x>=(xmin-16)) &&
				      (y<= ymax) && (y>=(short)(ymin-height-height)) )
				{
					xnew = x - xmin;
					ynew = y - ymin;
					GB->hedley_hint = 4*i;
				}
				/* otherwise only move main sprite for 15hz */
				hires_ss.posctldata = GB->hedley_sprites[i];
							hires_ss.num = num;
				movesprite(vp,&hires_ss,xnew,ynew>>1,1);
			}
		}
		if (hedley_flags & 4)
		{
			hires_ss.height = height>>1;
			for(i = 0; i<6; i++)	/* 6 pieces */
			{
				if (i&1)
				{
					ymin = phys_rows;
				}
				else
				{
					ymin = 0;
				}
				ymax = ymin + phys_rows - 1;
#ifdef USE_SWITCH
				switch (i>>1)
				{
					case 0:
						xmin = 0;
						break;
					case 1:
						xmin = 336;
						break;
					case 2:
						xmin = 336+336;
						break;
				}
#else
				xmax = i>>1;	/* tmp reuse variable */
				xmin = 0;	/* assume left third */
				if (xmax == 1)	xmin = 336;	/* nope, middle*/
				else	if (xmax == 2)	xmin = 336+336;	/* right third */
#endif
				xmax = xmin + 351;
				xnew = x;
				ynew = phys_rows +10;	/* assume clipped out */
				if  ( (x<= xmax) && (x>=(xmin-16)) &&
				      (y<= ymax) && (y>=(short)(ymin-height)) )
				{
					/* make visable */
					xnew = x - xmin;
					ynew = y - ymin;
					GB->hedley_hint = 4*i;
				}
				ynew >>= 1;
				for (j = 0; j<2 ;j++)
				{
					{
						if (j == 0)
						{
					hires_ss.posctldata = GB->hedley_sprites[i];
							hires_ss.num = num;
						}
						else
						{
					hires_ss.posctldata = GB->hedley_sprites1[i];
							hires_ss.num = num + 1;
						}
					}
					movesprite(vp,&hires_ss,xnew,ynew,1);
				}
			}
		}
		ns[num] = s;
		ns[num+1] = 0;
		return;
	    }
	}
	else
#endif
	{
	    starty = view->DyOffset;
	    startx = view->DxOffset;

	    ns = (struct SimpleSprite **)GB->SimpleSprites;

	    if ATTACHED(s)
	    {
		    struct SimpleSprite *as;
		    if (as = ns[s->num+1])	movesprite(vp,as,x,y,a2024);
	    }
	}

	ns[num] = s;

	if (vp)
	{
	        x += vp->DxOffset;
	        y += vp->DyOffset;

		if (modes & SUPERHIRES) 
		{
		    x >>= 2;
		    xprecision = 2;
		}
		else
		{
		    if (modes & HIRES)
		    {
			x >>= 1;
			/* xprecision = 1;*/
			/* unimplemented yet */
		    }
		}
		if (modes & LACE)
		{
		    y >>= 1;
		}
	}

	/* corresponding to change in mrgcop */
	starty += y;

#define NOT_FUNNY
#ifdef NOT_FUNNY
	startx += x;
#else
	startx += x - 1;
#endif

	/* new code to correct for hardware design flaw */
	/* The sprite horizontal counters are reset prior to the */
	/* overscanned end of a line, so we must artificially wrap */
	/* the start position sooner */

	/* bart -- rewrote to work with variable MaxDiplayColumn information */
	/* the -1 correction term in startx prevents the sprite from */
	/* disappearing in the denise "cusp" case */

#define SPRITE_WRAP	9 /* the infamous four and one half colorclocks */
#define MAX_XSPRITE	(GB->MaxDisplayColumn + SPRITE_WRAP)
	if ( (startx > GB->MaxDisplayColumn) && (startx <= MAX_XSPRITE) )
	      startx -= (GB->MaxDisplayColumn-1); /* sprite can alias */

	/*kprint("startx:%lx",startx);*/

	stopy = oldstarty = starty;
	stopy += s->height;
	starty = MAX(21,starty); /* this is outdated, presupposes NTSC - bart */
	/* lets keep it visible maybe? */
	stopy += starty - oldstarty;
	if (!(k = s->posctldata)) return;	/* in case none exists yet */
	jam = (((starty<<8)|( (startx>>1) &0xff))<<16);
	jam |=  (s->posctldata[1] & 0x80) | 
	    (startx & 1) | 
	    ( (starty>>6) & 4) | 
	    ( ((s->x) & (3 >> (2 - xprecision))) << (5 - xprecision) ) |
	    ((stopy>>7)&2) | 
	    ((0xff&stopy)<<8) | 
	    ((starty>>3)&0x40) | 
	    ((stopy>>4)&0x20);
	*k = jam;

	if (!(hedley_flags))	sprite_clipped(vp,s,modes);
	/*kprintf("return from movesprite\n");*/
}

#endif
@


39.1
log
@uses local includes
@
text
@d3 1
a3 1
*	$Id: simplesprites.c,v 39.0 91/08/21 17:22:26 chrisg Exp Locker: spence $
d34 1
d91 1
d93 1
d120 1
d122 1
d139 2
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*	$Id: simplesprites.c,v 37.2 91/05/20 11:21:22 chrisg Exp Locker: chrisg $
d12 5
a16 5
#include <graphics/gfx.h>
#include <graphics/gfxbase.h>
#include <graphics/view.h>
#include <graphics/copper.h>
#include <graphics/sprite.h>
@


37.2
log
@Added prototypes, improved warnings, and glue code. still needs work.
@
text
@d3 1
a3 1
*	$Id: simplesprites.c,v 1.1 91/05/20 10:48:15 chrisg Exp $
@


37.1
log
@ changed "../" to "/" for native build
@
text
@d3 1
a3 1
*	$Id: simplesprites.c,v 37.0 91/01/07 15:20:59 spence Exp Locker: chrisg $
d21 1
d165 1
a165 3
cracksprite(src,cnta,cntb,cntd,start)
UWORD *src;
int cnta,cntb,cntd,start;
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*	$Id: simplesprites.c,v 36.23 90/07/27 17:00:09 bart Exp Locker: spence $
d18 1
a18 1
#include "../macros.h"
@


36.23
log
@id
@
text
@d3 1
a3 1
*	$Id: $
@


36.22
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/graphics/c/RCS/simplesprites.c,v 36.21 90/03/08 12:21:33 bart Exp Locker: bart $
@


36.21
log
@fix bug B6685 (better lace simplesprite clipping)
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.20 90/03/06 15:46:47 bart Exp $
@


36.20
log
@fix bug B6871 a2024 15hz pointer subdivision
post B3
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.19 89/08/22 13:08:34 bart Exp $
d146 1
a146 1
		 (0>(((WORD)(s->y>>((flags&LACE)?1:0)))+((WORD)(s->height)))) ) 
@


36.19
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.18 89/08/22 09:36:29 bart Exp $
d336 1
a336 1
				if  ( (x<= xmax) && (x>=(xmin-16)) &&
@


36.18
log
@single thread access to ActiView hardware copper list
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.17 89/03/13 10:33:14 bart Exp $
a97 4
	/* single thread access to ActiView hardware copper list */

	ObtainSemaphore(GB->ActiViewCprSemaphore);

d101 1
a102 2
	ReleaseSemaphore(GB->ActiViewCprSemaphore);
}
a110 4
	/* single thread access to ActiView hardware copper list */

	ObtainSemaphore(GB->ActiViewCprSemaphore);

a114 1
	ReleaseSemaphore(GB->ActiViewCprSemaphore);
@


36.17
log
@increment src ptr when sending last 2 words of control to crack 10hz sprite
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.16 89/03/10 14:46:45 bart Exp $
d94 1
a94 1
    UWORD   *k;
d98 9
a106 3
    k = GB->copinit->sprstrtup + 4*num;
    k[1] = (long)(GB->copinit->sprstop) >> 16;
    k[3] = (short)(GB->copinit->sprstop);
d113 1
a113 1
    UWORD   *k;
d115 10
a124 3
    k = GB->copinit->sprstrtup + 4*s->num;
    k[1] = (int)pnew>>16;
    k[3] = (UWORD)pnew;
@


36.16
log
@sprite_clipped: added mode flags
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.15 89/03/09 16:03:57 bart Exp $
d231 1
a231 1
			cracksprite(src,6,6,2,2 + maxheight);
@


36.15
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.14 89/02/24 19:09:26 bart Exp $
d130 1
a130 1
sprite_clipped(vp,s)
d133 1
d141 3
a143 4
		if ( (vp->Modes & VP_HIDE) ||			/* completely unseen? */
			 (vp->DHeight < (WORD)(s->y)) ||  	/* clipped bottom? */
			 ( 0 > (((WORD)(s->y))+((WORD)(s->height))) ) )  /* clipped top?*/
			 /* ( vp->DyOffset > (s->y+s->height)) ) */
d145 3
a147 3
			make_sprite_disappear(s->num);
			if ATTACHED(s)	make_sprite_disappear(s->num+1);
			return (TRUE);
d271 1
a438 2
		ULONG modes = new_mode(vp);

a457 1
		    y += 1; /* round */
d505 1
a505 1
	if (!(hedley_flags))	sprite_clipped(vp,s);
d527 1
d688 2
a689 1
		ULONG modes = new_mode(vp);
a707 1
		    starty += vp->DyOffset>>1; 
a708 4
		else
		{
		    starty += vp->DyOffset; 
		}
d754 1
a754 1
	if (!(hedley_flags))	sprite_clipped(vp,s);
@


36.14
log
@a2024 15hz with vp relative sprites : phy_cols == 512
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.13 89/02/23 11:10:36 bart Exp $
d440 3
d459 1
a460 5
		    starty += vp->DyOffset>>1; 
		}
		else
		{
		    starty += vp->DyOffset; 
@


36.13
log
@rec_Control and new_mode processing
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.12 88/10/31 10:30:01 bart Exp $
d302 1
d323 1
a323 1
					xmin = 256;
d329 1
a329 1
				xmax = xmin + 256 - 1;
d342 2
a343 1
				movesprite_internal(vp,&hires_ss,xnew,ynew>>1,1);
@


36.12
log
@downcode portions of movesprite to assembly language
bart
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.11 88/10/18 16:54:40 bart Exp $
d436 3
a438 1
		if (vp->Modes & SUPERHIRES) 
d445 1
a445 1
		    if (vp->Modes & HIRES)
d452 1
a452 1
		if (vp->Modes & LACE)
d688 3
a690 1
		if (vp->Modes & SUPERHIRES) 
d697 1
a697 1
		    if (vp->Modes & HIRES)
d704 1
a704 1
		if (vp->Modes & LACE)
@


36.11
log
@if ( (startx > GB->MaxDisplayColumn) && (startx <= MAX_XSPRITE) )
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.10 88/09/11 14:00:31 bart Exp $
d31 2
d188 1
d246 3
d250 2
d254 2
d265 2
a266 2
	UWORD stopy,starty,startx,oldstarty;
	UWORD oldctl;
d277 3
d281 3
d285 1
a285 1
	if ( (a2024 == 0) && (GB->hedley_flags & 5) && (num == 0) )
d287 9
d306 1
a306 1
		if (GB->hedley_flags & 1)
d341 1
a341 1
				movesprite(vp,&hires_ss,xnew,ynew>>1,1);
d344 1
a344 1
		if (GB->hedley_flags & 4)
d403 1
a403 1
					movesprite(vp,&hires_ss,xnew,ynew,1);
a406 1
		ns = (struct SimpleSprite **)GB->SimpleSprites;
a408 2
	    	s->x = x;
	    	s->y = y;
d410 1
d412 1
d414 8
d423 9
a431 3
    view = GB->ActiView;
	if (!view)	return;
	ns = (struct SimpleSprite **)GB->SimpleSprites;
d434 3
a436 2
	if ((GB->hedley_flags & 5) == 0)
		if ATTACHED(s)
d438 2
a439 5
			struct SimpleSprite *as;
			struct SimpleSprite **ns;
			ns = GB->SimpleSprites;
			as = ns[s->num+1];
			if (as)	movesprite(vp,as,x,y,a2024);
d441 19
d461 71
d535 149
d688 2
a689 2
		    x >>= 1;				/* convert to hires */
		    xprecision++;
d691 1
a691 1
		if ((vp->Modes & HIRES)||(vp->Modes & SUPERHIRES))
d693 6
a698 7
		    x >>= 1;				/* convert to lowres */
#define BUGGY_HARDWARE
#ifdef BUGGY_HARDWARE
		    if(vp->Modes & HIRES) xprecision = 0; /* special case */
		    else
#endif
		    xprecision++; 			  /* general case */
d700 9
a708 1
		if (vp->Modes & LACE)	y >>= 1;	  /*     "      */
a710 2
	/* starty = view->DyOffset + y; */ /* bart - 12.22.87 */

d712 1
a712 3
	starty =    ((GB->hedley_flags & 5) == 0) ?
				view->DyOffset + y :
				0x2c +y ;
a713 3
	/* if (vp != 0) starty += vp->DyOffset; */ /* bart -- better below */
	if (vp != 0) starty += (vp->Modes&LACE)? vp->DyOffset>>1: vp->DyOffset;

d716 1
a716 4
    /* startx = view->DxOffset + x; */	/* now you not funny no mo.... */
	if (GB->hedley_flags & 1) startx = 0x81 + x;
	else if (GB->hedley_flags & 4) startx = 0x81 - 16 + x;
	else startx = view->DxOffset + x;
d718 1
a718 4
    /* startx = view->DxOffset + x - 1;	 */ /* now you funny too! hardware */
	startx =    ((GB->hedley_flags & 5) == 0) ?
				view->DxOffset + x - 1 :
				0x81+x ;
d737 3
a739 3
    stopy = starty + s->height;
	oldstarty = starty;
	starty = MAX(21,starty);
d742 3
a744 5
	if (!s->posctldata) return;	/* in case none exists yet */
    oldctl = (starty<<8)|( (startx>>1) &0xff);
	jam = (oldctl<<16);
	oldctl = s->posctldata[1] & 0x80;	/* and away old position */
    jam |=  oldctl | 
a751 1
	k = s->posctldata;
d754 1
a754 1
	if ((GB->hedley_flags & 5)==0)	sprite_clipped(vp,s);
d757 2
@


36.10
log
@vp->Modes & SUPERHIRES
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.9 88/09/01 11:57:17 bart Exp $
d463 1
a463 1
	if ( (startx > GB->MaxDisplayColumn) & (startx <= MAX_XSPRITE) )
@


36.9
log
@sprite wrap logic fixed for variable beam counters... bart
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.8 88/09/01 09:30:02 bart Exp $
d411 1
a411 1
		if (vp->ExtendedModes & VPF_SUPER_HIRES) 
d416 1
a416 1
		if ((vp->Modes & HIRES)||(vp->ExtendedModes & VPF_SUPER_HIRES))
@


36.8
log
@70 ns sprite positioning
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.7 88/08/18 21:19:28 dale Exp $
d456 10
a466 6
#define SPRITE_WRAP	(0x1d1 - 0x1c8)	/* value from normal display */
#define MAX_XSPRITE	(GB->MaxDisplayColumn - SPRITE_WRAP)
	if ( (startx >= MAX_XSPRITE) & (startx <= GB->MaxDisplayColumn) )
			 startx -= (MAX_XSPRITE-2);
	/*kprint(":%lx\n",startx);*/

@


36.7
log
@Fixed 15hz hedley sprite black lines. Now use attached sprite in
10hz and 15hz 
and 15hz modes.
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.6 88/07/15 16:10:12 dale Exp $
d253 3
a255 3
    struct View *view;
    register ULONG *k;
    UWORD stopy,starty,startx,oldstarty;
d260 1
d406 2
a407 2
    s->x = x;
    s->y = y;
d411 16
a426 2
		if (vp->Modes & HIRES)	x >>= 1;	/* convert to lowres */
		if (vp->Modes & LACE)	y >>= 1;	/*     "      */
d429 1
a429 1
    /* starty = view->DyOffset + y; */ /* bart - 12.22.87 */
d436 2
a437 1
    if (vp != 0)    starty += vp->DyOffset;
d473 8
a480 3
    jam |=  oldctl | (startx & 1) | ( (starty>>6) & 4) | 
		((startx & 3)<<3) |	((stopy>>7)&2) | ((0xff&stopy)<<8)
			| ((starty>>3)&0x40) | ((stopy>>4)&0x20);
d483 1
a486 1

@


36.6
log
@Fixed sprite positioning with greater than 300 line displays.
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.5 88/07/15 15:18:18 dale Exp $
d232 4
a235 2
			/* do not use attached sprite */
			src[1] &= ~0x80;	/* make unattached */
@


36.5
log
@Check in before ev9 sprite fix
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.4 88/06/10 11:43:57 dale Exp $
d445 1
d454 1
a454 1
	oldctl = s->posctldata[1] & 0xf8;	/* and away old position */
d456 2
a457 1
		((startx & 3)<<3) |	((stopy>>7)&2) | ((0xff&stopy)<<8);
@


36.4
log
@added a debug statement, ifdefed out.
Dale
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.3 88/05/03 15:32:42 dale Exp $
d20 2
d206 1
d210 4
a213 6
		if (s->height <= 32)
		{
			if (GB->hedley_flags & 4)
			{	/* in 10hz */
				src[1] |= 0x80;	/* make attached */
				cracksprite(src,6,6,2,0);
d215 6
a220 11
				for (i = 0; i<s->height; i++)
				{
					src += 2;	/* point to next data */
					if (i & 1)	/* odd row */
					{	/* send data to attached sprite */
						cracksprite(src,0,6,2,1+i);
					}
					else		/* even row */
					{	/* send data to primary sprites */
						cracksprite(src,6,0,2,2+i);
					}
d222 4
a225 2
				/* now send last 2 words of control */
				cracksprite(src,6,6,2,2 + s->height);
d227 2
a228 6
			else
			{	/* 15 hz */
				/* do not use attached sprite */
				src[1] &= ~0x80;	/* make unattached */
				cracksprite(src,4,0,2+2+2*s->height,0);
			}
d230 6
d269 1
d280 1
a280 1
			hires_ss.height = 16;
d304 1
a304 1
				      (y<= ymax) && (y>=(short)(ymin-s->height-s->height)) )
d318 1
a318 1
			hires_ss.height = 8;
d353 1
a353 1
				      (y<= ymax) && (y>=(short)(ymin-s->height)) )
@


36.3
log
@Fixes for makeing a2024MoveSprite reentrant as well as 
use the superhires sprite position bits. Which don't seem to work
at this time.
Dale
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.2 88/05/17 22:44:41 dale Exp $
d23 1
a23 1
#define DEBUGCHANGE
d258 5
@


36.2
log
@Check in, must have forgot last time mods made for hedley monitor.
@
text
@d3 1
a3 1
*	$Header: simplesprites.c,v 36.1 88/03/10 16:12:17 dale Exp $
d198 1
a198 1
	if (GB->hedley_flags & 5)
d241 1
a241 1
   movesprite(vp,s,s->x,s->y);
d244 1
a244 1
movesprite(vp,s,x,y)
d248 1
d261 1
a261 1
	if ( (GB->hedley_tmp == 0) && (GB->hedley_flags & 5) )
a271 2
		GB->hedley_tmp = 1;	/* kill recursion */

d307 1
a307 1
				movesprite(vp,&hires_ss,xnew,ynew>>1);
d369 1
a369 1
					movesprite(vp,&hires_ss,xnew,ynew);
a377 1
		GB->hedley_tmp = 0;
d394 1
a394 1
			if (as)	movesprite(vp,as,x,y);
d449 1
a449 1
			((stopy>>7)&2) | ((0xff&stopy)<<8);
@


36.1
log
@
@
text
@d3 1
a3 1
*	$Header: $
d263 4
a266 3
		int xmin,ymin;
		int xmax,ymax;
		int xnew,ynew;
a268 1
		int phys_rows = 400;
d299 1
a299 1
				      (y<= ymax) && (y>=ymin-s->height) )
d303 1
a304 1
				ynew >>= 1;
d308 1
a308 3
				if (ynew < (phys_rows>>1)+1 )
					GB->hedley_hint = 4*i;
				movesprite(vp,&hires_ss,xnew,ynew);
d325 1
d338 6
d348 1
a348 1
				      (y<= ymax) && (y>=ymin-s->height) )
d350 1
d353 1
a369 2
					if (ynew < (phys_rows>>1)+1 )
						GB->hedley_hint = 4*i;
@
