head     39.27;
branch   ;
access   ;
symbols  rel39_24:39.27 rel39_18:39.25 rel39_97:39.24 rel39_90:39.24 rel39_89:39.23 rel39_82:39.23 rel39_76:39.20 rel39_71:39.17 rel39_65:39.11 rel39_64:39.9 rel39_61:39.8 rel39_60:39.7 rel39_55:39.6 rel39_52:39.6 rel39_47:39.6 rel39_39:39.5 rel39_38:39.5 rel39_37:39.5 rel39_35:39.5 rel39_34:39.4 V37_30:37.0 V37_29:37.0 V37_28:37.0 V37_27:37.0 V37_25:37.0 V37_24:37.0 V37_23:37.0 V37_22:37.0 V37_21:37.0 V37_20:37.0 V37_19:37.0 V37_17:37.0 V37_15:37.0 V37_14:37.0 V37_13:37.0 V37_12:37.0 V37_11:37.0 V37_10:37.0 V37_9:37.0 V37_8:37.0 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.36 V36_208:36.36 V36_207:36.36 V36_205:36.36 V36_203:36.36 V36_202:36.36 V36_201:36.36 V36_200:36.36 V36_199:36.36 V36_198:36.36 V36_196:36.36 V36_195:36.36 V36_194:36.36 V36_193:36.36 V36_192:36.35 V36_191:36.35 V36_190:36.35 V36_189:36.35 V36_188:36.35 V36_186:36.35 V36_185:36.35 V36_184:36.35 V36_182:36.35 V36_181:36.35;
locks    ; strict;
comment  @ * @;


39.27
date     93.05.17.12.56.45;  author spence;  state Exp;
branches ;
next     39.26;

39.26
date     93.05.17.10.58.27;  author spence;  state Exp;
branches ;
next     39.25;

39.25
date     93.02.15.11.03.46;  author spence;  state Exp;
branches ;
next     39.24;

39.24
date     92.09.21.10.30.22;  author spence;  state Exp;
branches ;
next     39.23;

39.23
date     92.08.18.01.11.02;  author spence;  state Exp;
branches ;
next     39.22;

39.22
date     92.08.06.11.30.18;  author spence;  state Exp;
branches ;
next     39.21;

39.21
date     92.08.03.10.15.56;  author chrisg;  state Exp;
branches ;
next     39.20;

39.20
date     92.07.21.14.36.28;  author spence;  state Exp;
branches ;
next     39.19;

39.19
date     92.07.10.17.03.56;  author spence;  state Exp;
branches ;
next     39.18;

39.18
date     92.07.09.12.09.53;  author spence;  state Exp;
branches ;
next     39.17;

39.17
date     92.06.25.20.43.19;  author spence;  state Exp;
branches ;
next     39.16;

39.16
date     92.06.19.12.14.44;  author spence;  state Exp;
branches ;
next     39.15;

39.15
date     92.06.18.15.36.23;  author spence;  state Exp;
branches ;
next     39.14;

39.14
date     92.06.16.16.42.10;  author spence;  state Exp;
branches ;
next     39.13;

39.13
date     92.06.11.12.09.06;  author spence;  state Exp;
branches ;
next     39.12;

39.12
date     92.06.11.10.51.42;  author spence;  state Exp;
branches ;
next     39.11;

39.11
date     92.06.09.10.56.19;  author chrisg;  state Exp;
branches ;
next     39.10;

39.10
date     92.06.08.14.03.54;  author spence;  state Exp;
branches ;
next     39.9;

39.9
date     92.06.04.16.17.20;  author chrisg;  state Exp;
branches ;
next     39.8;

39.8
date     92.06.03.16.34.45;  author chrisg;  state Exp;
branches ;
next     39.7;

39.7
date     92.05.15.07.27.21;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     92.03.13.15.46.14;  author spence;  state Exp;
branches ;
next     39.5;

39.5
date     92.02.19.14.38.18;  author spence;  state Exp;
branches ;
next     39.4;

39.4
date     92.01.07.16.07.08;  author spence;  state Exp;
branches ;
next     39.3;

39.3
date     91.12.19.13.30.09;  author spence;  state Exp;
branches ;
next     39.2;

39.2
date     91.08.27.17.53.58;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     91.08.27.16.44.20;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.19.38;  author chrisg;  state Exp;
branches ;
next     37.3;

37.3
date     91.05.20.11.12.42;  author chrisg;  state Exp;
branches ;
next     37.2;

37.2
date     91.05.03.16.54.34;  author chrisg;  state Exp;
branches ;
next     37.1;

37.1
date     91.05.02.12.59.27;  author chrisg;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.19.50;  author spence;  state Exp;
branches ;
next     36.36;

36.36
date     90.10.25.10.35.47;  author spence;  state Exp;
branches ;
next     36.35;

36.35
date     90.07.27.16.58.10;  author bart;  state Exp;
branches ;
next     36.34;

36.34
date     90.03.28.09.11.10;  author bart;  state Exp;
branches ;
next     36.33;

36.33
date     89.08.22.09.35.59;  author bart;  state Exp;
branches ;
next     36.32;

36.32
date     89.05.05.10.35.51;  author bart;  state Exp;
branches ;
next     36.31;

36.31
date     89.04.29.15.42.06;  author bart;  state Exp;
branches ;
next     36.30;

36.30
date     89.04.13.09.52.40;  author bart;  state Exp;
branches ;
next     36.29;

36.29
date     89.03.20.16.40.33;  author bart;  state Exp;
branches ;
next     36.28;

36.28
date     89.03.20.10.08.50;  author bart;  state Exp;
branches ;
next     36.27;

36.27
date     89.03.16.16.10.02;  author bart;  state Exp;
branches ;
next     36.26;

36.26
date     89.03.16.14.05.34;  author bart;  state Exp;
branches ;
next     36.25;

36.25
date     89.03.07.16.40.39;  author bart;  state Exp;
branches ;
next     36.24;

36.24
date     89.03.07.16.33.20;  author bart;  state Exp;
branches ;
next     36.23;

36.23
date     89.03.03.11.06.05;  author bart;  state Exp;
branches ;
next     36.22;

36.22
date     89.03.03.11.01.49;  author bart;  state Exp;
branches ;
next     36.21;

36.21
date     89.03.02.18.30.06;  author bart;  state Exp;
branches ;
next     36.20;

36.20
date     89.02.14.10.12.48;  author bart;  state Exp;
branches ;
next     36.19;

36.19
date     89.02.01.17.52.29;  author bart;  state Exp;
branches ;
next     36.18;

36.18
date     89.02.01.17.41.21;  author bart;  state Exp;
branches ;
next     36.17;

36.17
date     89.01.31.15.38.50;  author bart;  state Exp;
branches ;
next     36.16;

36.16
date     88.10.17.15.08.04;  author bart;  state Exp;
branches ;
next     36.15;

36.15
date     88.09.11.14.00.18;  author bart;  state Exp;
branches ;
next     36.14;

36.14
date     88.08.12.13.18.53;  author bart;  state Exp;
branches ;
next     36.13;

36.13
date     88.09.01.10.48.16;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     88.07.25.14.23.51;  author bart;  state Exp;
branches ;
next     36.11;

36.11
date     88.07.23.17.08.45;  author bart;  state Exp;
branches ;
next     36.10;

36.10
date     88.07.15.17.35.38;  author dale;  state Exp;
branches ;
next     36.9;

36.9
date     88.07.08.14.02.45;  author bart;  state Exp;
branches ;
next     36.8;

36.8
date     88.05.02.19.02.11;  author dale;  state Exp;
branches ;
next     36.7;

36.7
date     88.05.02.14.02.03;  author dale;  state Exp;
branches ;
next     36.6;

36.6
date     88.05.18.18.31.15;  author dale;  state Exp;
branches ;
next     36.5;

36.5
date     88.05.18.17.14.49;  author dale;  state Exp;
branches ;
next     36.4;

36.4
date     88.05.17.22.49.20;  author dale;  state Exp;
branches ;
next     36.3;

36.3
date     88.03.11.17.07.12;  author dale;  state Exp;
branches ;
next     36.2;

36.2
date     88.03.10.20.41.56;  author dale;  state Exp;
branches ;
next     36.1;

36.1
date     88.03.10.16.11.52;  author dale;  state Exp;
branches ;
next     ;


desc
@@


39.27
log
@VBeamPos -> gfx_VBeamPos
@
text
@/******************************************************************************
*
*	$Id: loadview.c,v 39.26 93/05/17 10:58:27 spence Exp Locker: spence $
*
******************************************************************************/

#include <exec/types.h>
#include <exec/nodes.h>
#include <exec/lists.h>
#include <exec/interrupts.h> 
#include <exec/libraries.h>
#include "/monitor.h"
#include "/gfx.h"
#include "/gfxbase.h"
#include "/copper.h"
#include "/view.h"
#include "/display.h"
#include "/vp_internal.h"
#include "gfxprivate.h"
#include <hardware/intbits.h>
#include <hardware/custom.h>
#include <hardware/dmabits.h>
#include "c.protos"
#include "/macros.h"
#include "/gfxpragmas.h"

#define ZD_BP

/*#define DEBUG*/

#ifdef DEBUG
#define D(x) {x};
#else
#define D(x)
#endif


extern struct Custom custom;

void __asm KillOldMonitor(register __a0 struct MonitorSpec *mspc)
{
    void (* __asm killview)(register __a0 struct MonitorSpec *mspc);

    if ((mspc) && (killview = mspc->ms_KillView))
    {
	(*killview)(mspc);
    }
}

void default_monitor(mspc)
struct MonitorSpec *mspc;
{
    struct Custom *io;

    io = &custom;

    /* if we get here we must have indirected through ms_Special.do_monitor */
    {
	int hcenter;

	io->htotal = mspc->total_colorclocks;

    D(kprintf("default_monitor: io->htotal == 0x%08lx\n",mspc->total_colorclocks);)

	io->hbstrt = mspc->ms_Special->hblank.asi_Start;
	io->hbstop = mspc->ms_Special->hblank.asi_Stop;
	io->hsstrt = mspc->ms_Special->hsync.asi_Start;
	io->hsstop = mspc->ms_Special->hsync.asi_Stop;

    D(kprintf("default_monitor: io->hbstrt == 0x%08lx\n",
	     mspc->ms_Special->hblank.asi_Start);)
    D(kprintf("default_monitor: io->hsstrt == 0x%08lx\n",
	     mspc->ms_Special->hsync.asi_Start);)
    D(kprintf("default_monitor: io->hsstop == 0x%08lx\n",
	     mspc->ms_Special->hsync.asi_Stop);)
    D(kprintf("default_monitor: io->hbstop == 0x%08lx\n",
	     mspc->ms_Special->hblank.asi_Stop);)

	hcenter = ( mspc->total_colorclocks >> 1) +
		    mspc->ms_Special->hsync.asi_Start;

	io->hcenter = hcenter;

    D(kprintf("default_monitor: io->hcenter == 0x%08lx\n",hcenter);)
    D(kprintf("default_monitor: io->vtotal == 0x%08lx\n",mspc->total_rows);)

	io->vsstrt = mspc->ms_Special->vsync.asi_Start/mspc->total_colorclocks;
	io->vsstop = mspc->ms_Special->vsync.asi_Stop/mspc->total_colorclocks;

	/*
	 * Calculate vbstrt and vbstop, and store them in GfxBase.
	 */
#ifdef VBLANK_BUG
	/* VBlanks are already disabled */
	if (GBASE->Bugs & BUG_VBLANK)
	{
		GBASE->MonitorVBlank.asi_Start = mspc->total_rows;
		GBASE->MonitorVBlank.asi_Stop = (mspc->min_row - 1);
	}
	else
#endif
	{
		GBASE->MonitorVBlank.asi_Start = (mspc->ms_Special->vblank.asi_Start / mspc->total_colorclocks);
		GBASE->MonitorVBlank.asi_Stop = (mspc->ms_Special->vblank.asi_Stop / mspc->total_colorclocks);
	}

    D(kprintf("default_monitor: io->vbstrt == 0x%08lx\n",
	     mspc->ms_Special->vblank.asi_Start/mspc->total_colorclocks);)
    D(kprintf("default_monitor: io->vsstrt == 0x%08lx\n",
	     mspc->ms_Special->vsync.asi_Start/mspc->total_colorclocks);)
    D(kprintf("default_monitor: io->vsstop == 0x%08lx\n",
	     mspc->ms_Special->vsync.asi_Stop/mspc->total_colorclocks);)
    D(kprintf("default_monitor: io->vbstop == 0x%08lx\n",
	     mspc->ms_Special->vblank.asi_Stop/mspc->total_colorclocks);)

    }

    D(kprintf("default_monitor: beamcon0 == 0x%08lx\n",mspc->BeamCon0);)

    newdefras(GBASE,mspc->ratioh,mspc->ratiov);
}

void loadview(d)
struct View *d;
{
    typedef volatile struct Custom vcustom;
    vcustom *io;
    struct MonitorSpec *oldmspc = GBASE->current_monitor;
    BOOL vbstrt = FALSE;

    io = &custom;

    D(kprintf("loadview: view == 0x%08lx. oldmspc = 0x%lx\n",d, oldmspc);)

    /* single thread access to ActiView hardware copper list */

    D(kprintf("Getting the Semaphore\n");)

    ObtainSemaphore(GBASE->ActiViewCprSemaphore);

    if( (d) && ( (GBASE->Modes&INTERLACE) && (!(d->Modes&INTERLACE))) )
    {
	/* Changing from Lace to non-lace */
	vbstrt = TRUE;
    }
    GBASE->SpecialCounter++;
    io->intena = BITCLR|INTF_VERTB;

    if (GBASE->ActiView = d)
    {
	struct	ViewExtra *ve = NULL;
	struct	MonitorSpec *mspc = NULL;
	int	tot_rows = 0;
	int	tot_cclks = 0;
	UWORD	old_dma;
	UWORD	topline = TOPLINE;
	char	mode_change = FALSE;

	D(kprintf("ActiView and View are the same\n");)

	if (d->LOFCprList == 0)
	{
		D(kprintf("LOFCprList = NULL\n");)
		goto no_cpr_list;
	}

	GBASE->Modes = d->Modes;
	GBASE->LOFlist = d->LOFCprList->start;

	mspc = GBASE->natural_monitor;
	D(kprintf("natural_monitor = 0x%lx\n", mspc);)

	if (d->Modes & EXTEND_VSTRUCT)
	{
	    if((ve = (struct ViewExtra *) gfx_GfxLookUp(d)) && ve->Monitor)
	    {
		mspc = ve->Monitor;
		D(kprintf("Use ve->mspc = 0x%lx, ve = 0x%lx\n", mspc, ve);)
	    }
	    if ((GBASE->ChipRevBits0 & GFXF_AA_LISA) && ve)
	    {
		topline = ve->TopLine;
	    }
	}

	D(kprintf("topline = 0x%lx, GBASE->TopLine = 0x%lx\n", topline, GBASE->TopLine);)
	if (topline != GBASE->TopLine)
	{
		GBASE->TopLine = topline;
		GBASE->copinit->wait14[0] = (COPPER_WAIT | topline);	/* risky */
		if (GBASE->copinit->norm_hblank[0] & COPPER_WAIT)
		{
			GBASE->copinit->norm_hblank[0] = (COPPER_WAIT | topline);
		}
	}

	if (d->SHFCprList)
	{
		/* LPEN bit is set in bplcon0, swap the long frame and short
		 * frame.
		 */
		if ((GBASE->system_bplcon0 & 0x8) &&
		    (GBASE->DisplayFlags & LPEN_SWAP_FRAMES))
		{
			GBASE->SHFlist = GBASE->LOFlist;
			GBASE->LOFlist = d->SHFCprList->start;
		}
		else
		{
			GBASE->SHFlist = d->SHFCprList->start;
		}
	}

	if(!(mspc == oldmspc))
	{
	    mode_change = TRUE; /* force change */
	}

	GBASE->current_monitor = mspc; /* update current */
	update_top_color(mspc);     /* update topmost */

	D(kprintf("loadview: mspc == 0x%08lx\n",mspc);)
	D(kprintf("mspc->ms_Flags = 0x%lx\n", mspc->ms_Flags);)
	if (mspc->ms_Flags)
	{
		/* found new 1.3 stuff */
		tot_rows = mspc->total_rows;
		tot_cclks = mspc->total_colorclocks;
	}
	else	
	{
	    io->beamcon0 = beamconpal(GBASE);	/* going to old mode */
	    D(kprintf("old mode: beamcon0 == %04lx\n",beamconpal(GBASE));)
	}

	old_dma = io->dmaconr;

	/* changing modes? */

	if ( ( tot_rows != GBASE->current_tot_rows) ||
	     (tot_cclks != GBASE->current_tot_cclks)  )
	{
		LONG tmp;
		/* turn off all dma that may blow up */

		io->dmacon = DMAF_COPPER|DMAF_SPRITE;

		/* ensure DDFSTOP will never screw us.
		 * Wait for the line count to change, the write legal values
		 * into the ddfstrt/stop registers, wait for another line, so
		 * we know the datafetch completed, and then turn of raster
		 * DMA.
		 *
		 * At this point, VBLANK interrupts are disable, so we
		 * cannot get preempted out, although we could get hit by
		 * a higher priority interrupt.
		 */
		tmp = gfx_VBeamPos();
		while (gfx_VBeamPos() == tmp);
		io->ddfstrt = 0x38;
		io->ddfstop = 0x58;
		tmp = gfx_VBeamPos();
		while (gfx_VBeamPos() == tmp);
		io->dmacon = DMAF_RASTER;

		mode_change = TRUE;

//		io->beamcon0 = beamconpal(GBASE);
		D(kprintf("mode_change: beamcon0 == %04lx\n",beamconpal(GBASE));)
	}

	if(mode_change)
	{
	    D(kprintf("Mode_change\n");)
	    if ( ( tot_rows || tot_cclks ) && (d->LOFCprList) )
	    {
		if(!(mspc->ms_Flags & REQUEST_SPECIAL))
		{
		    D(kprintf("not special: beamcon0 == %04lx\n",mspc->BeamCon0);)
		    D(kprintf("@@beamcon0 == %04lx\n",&mspc->BeamCon0);)
		    io->beamcon0 = mspc->BeamCon0;
		}
		else
		{
		    /* call special monitor routine */
		    if((mspc->ms_Special) && (mspc->ms_Special->do_monitor))
		    {
			(*mspc->ms_Special->do_monitor)(mspc); /* indirect */
			vbstrt = TRUE;
		    }
		    else 
		    { 
			io->beamcon0 = 0x0000; /* stub error hardcode */ 
		    }
		}
		GBASE->MaxDisplayRow = mspc->total_rows - 1; /* for vbasm */
		GBASE->MaxDisplayColumn = mspc->DeniseMaxDisplayColumn; 
		GBASE->MinDisplayColumn = mspc->DeniseMinDisplayColumn;
	    }
	    else
	    {
		GBASE->MaxDisplayRow = ( ( GBASE->DisplayFlags & PAL ) ?
		                        STANDARD_PAL_ROWS :
		                        STANDARD_NTSC_ROWS )
		                        - 1; /* for vbasm */
		GBASE->MaxDisplayColumn = STANDARD_DENISE_MAX; /* bart */
		GBASE->MaxDisplayColumn = STANDARD_DENISE_MIN; /* bart */
	    }
	    /* Do any special kill code for the old monitor */
	    KillOldMonitor(oldmspc);
	}
	GBASE->current_tot_rows = tot_rows;
	GBASE->current_tot_cclks = tot_cclks;
	GBASE->MonitorFlags = mspc->ms_Flags;
	if (mode_change) io->dmacon = old_dma | DMAF_SETCLR;
    }
    else
    {
no_cpr_list:

	D(kprintf("no_cpr_list\n");)
	KillOldMonitor(GBASE->current_monitor);
	GBASE->MonitorFlags = NULL;
	GBASE->current_monitor = NULL; /* no view, so no monitor either */
	GBASE->hedley_flags = 0;
	GBASE->LOFlist = GBASE->copinit->wait_forever;
	GBASE->Modes = 0;
	defras(GBASE);
	if (! d)
		GBASE->copinit->fm0[1]=0;	/* turn off sprite scan doubling and anything else */
    }

    if (vbstrt)
    {
	D(kprintf("vbstrt\n");)
	GBASE->Bugs |= CHANGE;	/* vblank should change the beamcon0 */
	io->vbstrt = 0;
    }
    io->intena = BITSET|INTF_VERTB;

    ReleaseSemaphore(GBASE->ActiViewCprSemaphore);
    D(kprintf("Released the Semaphore\n");)
    D(kprintf("ByeBye loadview()\n");)

}

@


39.26
log
@When changing between PAL and NTSC views (and presumably between other
monitor types too), occasionally the machine could freeze. The cause is
unkown, but our current theory is that disabling RASTER DMA in the
middle of a fetch cycle could be dangerous. We now try to ensure that
we don't disable RASTER DMA in the middle of a fetch cycle. This is an
improvement, although tests show this to not be perfect.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.25 93/02/15 11:03:46 spence Exp Locker: spence $
d258 2
a259 2
		tmp = VBeamPos();
		while (VBeamPos() == tmp);
d262 2
a263 2
		tmp = VBeamPos();
		while (VBeamPos() == tmp);
@


39.25
log
@If the LPEN is set, then only swap the LOF and SHF if LPEN_SWAP_FRAMES in
GfxBase->DisplayFlags is set. 
This bit is set in cpwrup, and is generally what we want, however Raible
tells us that the LPEN fix was implemented in a version of Agnus, only
we have no way of knowing if the Agnus in the machine is fixed or not.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.24 92/09/21 10:30:22 spence Exp Locker: spence $
d243 1
d246 20
a265 1
		io->dmacon = DMAF_COPPER|DMAF_RASTER|DMAF_SPRITE;
d320 1
@


39.24
log
@Ensure the killView vector is called with the monitor spec in a0
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.23 92/08/18 01:11:02 spence Exp Locker: spence $
d202 2
a203 1
		if ((GBASE->system_bplcon0 & 0x8) && (!(GBASE->ChipRevBits0 & GFXF_HR_AGNUS)))
@


39.23
log
@if lpen bit is set, only swap the LOF<->SHF copperlists on 'A' machines.
vbasm handles ECS and AA properly.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.22 92/08/06 11:30:18 spence Exp Locker: spence $
d42 6
a47 4
	if ((mspc) && (mspc->ms_KillView))
	{
		(*mspc->ms_KillView)(mspc);
	}
@


39.22
log
@Replace GBASE->default_monitor with GBASE->natural_monitor
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.21 92/08/03 10:15:56 chrisg Exp Locker: spence $
d198 1
a198 1
		 * frame. This hides a chip bug.
d200 1
a200 1
		if (GBASE->system_bplcon0 & 0x8)
@


39.21
log
@made LoadView(NULL) clear fmode.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.20 92/07/21 14:36:28 spence Exp Locker: chrisg $
d25 1
d46 1
a46 1
};
d168 2
a169 2
	mspc = GBASE->default_monitor;
	D(kprintf("default_monitor = 0x%lx\n", mspc);)
d173 1
a173 1
	    if((ve = (struct ViewExtra *) GfxLookUp(d)) && ve->Monitor)
@


39.20
log
@Was using default TopLine value every other LoadView().
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.19 92/07/10 17:03:56 spence Exp Locker: spence $
d304 2
@


39.19
log
@If no ViewExtra, set GBASE->TopLine to the default.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.18 92/07/09 12:09:53 spence Exp Locker: spence $
d24 1
d30 5
a34 2
/*#define DEBUGS*/
/*#define BARTDEBUG*/
a35 1
#include "/macros.h"
d60 1
a60 3
#ifdef BARTDEBUG
    kprintf("default_monitor: io->htotal == 0x%08lx\n",mspc->total_colorclocks);
#endif
d67 8
a74 10
#ifdef BARTDEBUG
    kprintf("default_monitor: io->hbstrt == 0x%08lx\n",
	     mspc->ms_Special->hblank.asi_Start);
    kprintf("default_monitor: io->hsstrt == 0x%08lx\n",
	     mspc->ms_Special->hsync.asi_Start);
    kprintf("default_monitor: io->hsstop == 0x%08lx\n",
	     mspc->ms_Special->hsync.asi_Stop);
    kprintf("default_monitor: io->hbstop == 0x%08lx\n",
	     mspc->ms_Special->hblank.asi_Stop);
#endif
d81 2
a82 4
#ifdef BARTDEBUG
    kprintf("default_monitor: io->hcenter == 0x%08lx\n",hcenter);
    kprintf("default_monitor: io->vtotal == 0x%08lx\n",mspc->total_rows);
#endif
d104 8
a111 10
#ifdef BARTDEBUG
    kprintf("default_monitor: io->vbstrt == 0x%08lx\n",
	     mspc->ms_Special->vblank.asi_Start/mspc->total_colorclocks);
    kprintf("default_monitor: io->vsstrt == 0x%08lx\n",
	     mspc->ms_Special->vsync.asi_Start/mspc->total_colorclocks);
    kprintf("default_monitor: io->vsstop == 0x%08lx\n",
	     mspc->ms_Special->vsync.asi_Stop/mspc->total_colorclocks);
    kprintf("default_monitor: io->vbstop == 0x%08lx\n",
	     mspc->ms_Special->vblank.asi_Stop/mspc->total_colorclocks);
#endif
d115 1
a115 3
#ifdef BARTDEBUG
    kprintf("default_monitor: beamcon0 == 0x%08lx\n",mspc->BeamCon0);
#endif
a125 1
    UWORD vpos;
d130 1
a130 3
#ifdef BARTDEBUG
    kprintf("loadview: view == 0x%08lx\n",d);
#endif
d134 1
a134 3
#ifdef BARTDEBUG
    kprintf("Getting the Semaphore\n");
#endif
d156 1
a156 3
#ifdef BARTDEBUG
    kprintf("ActiView and View are the same\n");
#endif
d160 1
d168 1
d175 1
d177 1
a177 1
	    if ((GBASE->ChipRevBits0 & GFXF_AA_LISA) && ve && (ve->TopLine != GBASE->TopLine))
d183 2
a184 3
	GBASE->TopLine = topline;
	GBASE->copinit->wait14[0] = (COPPER_WAIT | topline);	/* risky */
	if (GBASE->copinit->norm_hblank[0] & COPPER_WAIT)
d186 6
a191 1
		GBASE->copinit->norm_hblank[0] = (COPPER_WAIT | topline);
d218 2
a219 4
#ifdef BARTDEBUG
    kprintf("loadview: mspc == 0x%08lx\n",mspc);
#endif

d229 1
a229 3
#ifdef BARTDEBUG
	    kprintf("old mode: beamcon0 == %04lx\n",beamconpal(GBASE));
#endif
d245 1
a245 3
#ifdef BARTDEBUG
		kprintf("mode_change: beamcon0 == %04lx\n",beamconpal(GBASE));
#endif
d250 1
d255 2
a256 4
#ifdef BARTDEBUG
		    kprintf("not special: beamcon0 == %04lx\n",mspc->BeamCon0);
		    kprintf("@@beamcon0 == %04lx\n",&mspc->BeamCon0);
#endif
d295 2
d298 1
a299 2
	GBASE->MonitorFlags = NULL;
no_cpr_list:
d308 1
d315 2
a316 7
#ifdef BARTDEBUG
    kprintf("Released the Semaphore\n");
#endif

#ifdef BARTDEBUG
    kprintf("ByeBye loadview()\n");
#endif
@


39.18
log
@Reads TopLine from the ViewExtra, and sets GfxBase->TopLine with the value.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.17 92/06/25 20:43:19 spence Exp Locker: spence $
d19 1
d165 1
a186 9
		if ((GBASE->ChipRevBits0 & GFXF_AA_LISA) && (ve->TopLine != GBASE->TopLine))
		{
			GBASE->TopLine = ve->TopLine;
			GBASE->copinit->wait14[0] = (COPPER_WAIT | GBASE->TopLine);	/* risky */
			if (GBASE->copinit->norm_hblank[0] & COPPER_WAIT)
			{
				GBASE->copinit->norm_hblank[0] = (COPPER_WAIT | GBASE->TopLine);
			}
		}
d188 11
d200 1
@


39.17
log
@vbstrt = 0 on mode change AND lace->non-laced transitions.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.16 92/06/19 12:14:44 spence Exp Locker: spence $
a156 8
    if (GBASE->Flags & TOPLINE_CHANGE)
    {
    	GBASE->Flags &= ~TOPLINE_CHANGE;
    	GBASE->copinit->wait14[0] = (COPPER_WAIT | GBASE->TopLine);	/* risky */
	if (GBASE->copinit->norm_hblank[0] & COPPER_WAIT)
		GBASE->copinit->norm_hblank[0] = (COPPER_WAIT | GBASE->TopLine);
    }

d185 9
@


39.16
log
@GBASE->Bugs |= CHANGE so vblank only needs to set BeamCon0 once.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.15 92/06/18 15:36:23 spence Exp Locker: spence $
a105 1
	io->vbstrt = 0;
d133 1
d149 5
a271 1
			GBASE->Bugs |= CHANGE;	/* vblank should change the beamcon0 */
d273 1
d313 5
@


39.15
log
@default_monitor() sets vbstrt = 0, to guarantee getting a vblank.
vbstop and vtotal not written (again!).
BeamCon0 not written when changing modes (done in vblank).
removed check for ensuring lace transitions happen in LOF. It was bogus
and could be preempted.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.14 92/06/16 16:42:10 spence Exp Locker: spence $
d267 1
@


39.14
log
@Uses (mspc->total_rows - 1) for vbstrt.
Writes vbstrt, vbstop and vtotal again.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.13 92/06/11 12:09:06 spence Exp Locker: spence $
d96 1
a96 1
		GBASE->MonitorVBlank.asi_Start = (mspc->total_rows - 1);
d106 1
a106 4
	io->vtotal = mspc->total_rows;
	io->vbstrt = GBASE->MonitorVBlank.asi_Start;
	io->vbstop = GBASE->MonitorVBlank.asi_Stop;

a117 2
	newdefras(GBASE,mspc->ratioh,mspc->ratiov);

d124 1
a124 2
    io->beamcon0 = mspc->BeamCon0;

d132 1
a140 17
    /* don't want a spurious interupt occuring before its time */
    /* only allow interlace->noninterlace transitions during short frame */

    if( (d) && ( (GBASE->Modes&INTERLACE) && (!(d->Modes&INTERLACE))) )
    {
	vpos = io->vposr;
	while (vpos & VPOSRLOF)	/* wait for shortframe */
	{
		vpos = io->vposr;	/* stupid fucking compiler */
	}
	vpos = io->vhposr;
	while (((vpos >> 8) & 0xff) < 10)  /* wait till after vblank occurs */
	{
		vpos = io->vhposr;
	}
    }

a163 1
	struct  MonitorSpec *oldmspc = GBASE->current_monitor;
d244 1
a244 1
		io->beamcon0 = beamconpal(GBASE);
d307 2
a312 1
    io->intena = BITSET|INTF_VERTB;
@


39.13
log
@default_monitor() calculates vbstrt and vbstop, and stores the results
in GfxBase->MonitorVBlank
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.12 92/06/11 10:51:42 spence Exp Locker: spence $
d88 2
a89 8
	/* vbstrt, vbstop and vtotal are now written in vblank.
	 * This helps in overcoming the AA vblank bug.
	 * spence - Jun 10 1992
	 *
	 * io->vbstrt = mspc->ms_Special->vblank.asi_Start/mspc->total_colorclocks;
	 * io->vbstop = mspc->ms_Special->vblank.asi_Stop/mspc->total_colorclocks;
	 * io->vtotal = mspc->total_rows;
	 *
a91 1

d96 1
a96 1
		GBASE->MonitorVBlank.asi_Start = mspc->total_rows;
d105 4
@


39.12
log
@removed VBLANK_BUG code.
default_monitor() no longer writes vbstrt, vbstop or vtotal. This is
done in the vblank code
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.11 92/06/09 10:56:19 chrisg Exp Locker: spence $
d95 2
d98 14
@


39.11
log
@REQ -> MSF_REQ.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.10 92/06/08 14:03:54 spence Exp Locker: chrisg $
a79 1
	io->vtotal = mspc->total_rows;
d88 8
a95 2
	io->vbstrt = mspc->ms_Special->vblank.asi_Start/mspc->total_colorclocks;
	io->vbstop = mspc->ms_Special->vblank.asi_Stop/mspc->total_colorclocks;
a201 1
#ifndef VBLANK_BUG
a205 8

#else		 * Also hide another chip bug - if programmed beamsync and
		 * interlace, then swap lof/shf.
		 */

		if ((GBASE->system_bplcon0 & 0x8) ||
		    ((GBASE->Bugs & BUG_VBLANK) && (mspc->ms_Flags & MSF_REQUEST_SPECIAL)))
#endif
@


39.10
log
@removed old update_top_color() code
Calls KillView() indirectly through the MonitorSpec->ms_KillView when
changing views.
Copies MonitorSpec->ms_Flags to GfxBase.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.9 92/06/04 16:17:20 chrisg Exp Locker: spence $
d208 1
a208 1
		    ((GBASE->Bugs & BUG_VBLANK) && (mspc->ms_Flags & REQUEST_SPECIAL)))
@


39.9
log
@incr of cache counter was in the wrong place.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.8 92/06/03 16:34:45 chrisg Exp Locker: chrisg $
d12 1
d35 1
a35 5
#define DOWN_UPDATE

#ifndef DOWN_UPDATE
update_top_color(mspc)
struct MonitorSpec *mspc;
d37 1
a37 128
    /* put correct copper color in upper half of screen */
    struct Custom *io;
    struct View *v;
    struct ViewPort *vp,*bestvp;
    struct ColorMap *cm;
    io = &custom;

    /* single thread access to ActiView hardware copper list */
    ObtainSemaphore(GBASE->ActiViewCprSemaphore);
    if (v = GBASE->ActiView)
    if (bestvp = vp = v->ViewPort)
    {
	WORD bestdy;
	WORD tempdy;
	ULONG modes;
	bestdy = 10000;
	/* find topmost vp */
	while ( vp )
	{
	    if ( (vp->Modes & VP_HIDE) == 0)
	    {
		tempdy = vp->DyOffset;
		if (new_mode(vp) & INTERLACE) tempdy >>= 1;
		if (bestdy > tempdy) { bestvp = vp; bestdy = tempdy; }
	    }
	    vp = vp->Next;
	}
	if (cm = bestvp->ColorMap)
	{
	    ULONG color = (0x1FE&(int)(&io->color[0])) << 16;
	    ULONG *p = GBASE->copinit->diagstrt;
	    UWORD *ct;
	    UWORD qwe;
	    UWORD gen;
	    ct = (UWORD *)cm->ColorTable;
	    qwe = *ct;
	    gen = check_genlock(cm,0);
	    if ((modes = new_mode(bestvp)) & SUPERHIRES)
	    {
		qwe &= 0xccc;	/* clear unused bits */
		qwe |= (qwe>>2); /* funny hardware */
		gen |= gen>>1;
	    }

	    color |= (qwe | gen);

	    *p = color; /* top color */

#ifdef ZD_BP
	    if ((mspc) && (GBASE->ChipRevBits0 & GFXF_HR_DENISE))
	    {
		ULONG *q = GBASE->copinit->genloc;
		ULONG  bplcon0 = (0x1FE&(int)(&io->bplcon0)) << 16;
		ULONG  bplcon2 = (0x1FE&(int)(&io->bplcon2)) << 16;
		ULONG  bplcon3 = (0x1FE&(int)(&io->bplcon3)) << 16;

		/* note that bitplane depth of zero is ok here */

		bplcon0 |= ( GBASE->system_bplcon0 | 
			   ( v->Modes & INTERLACE ) |
			   ( (modes & SUPERHIRES)? 0x40: 0 ) | 
			   ( (modes & (HOLDNMODIFY|DUALPF|HIRES)) ) );


		bplcon2 |= (modes & SUPERHIRES)?
			   (bestvp->SpritePriorities>>1): /* temp hack */
			   (bestvp->SpritePriorities);

		bplcon2 |= (modes & PF2PRI);

		if(cm->Type)
		{
		    if(cm->Flags & COLORMAP_TRANSPARENCY)
		    {
			bplcon2 |= BPLCON2_ZDCTEN;
		    }

		    if(cm->Flags & COLORPLANE_TRANSPARENCY)
		    {
			bplcon2 |= BPLCON2_ZDBPEN;
			bplcon2 |= cm->TransparencyPlane <<12;
		    }

		    if(cm->Flags & BORDER_BLANKING)
		    {
			bplcon0 |= USE_BPLCON3;    /* permission to listen */
			bplcon3 |= BPLCON3_BRDNBLNK;
		    }

		    if(cm->Flags & BORDER_NOTRANSPARENCY)
		    {
			bplcon0 |= USE_BPLCON3;    /* permission to listen */
			bplcon3 |= BPLCON3_BRDNTRAN;
		    }
		}

		if (mspc->BeamCon0 & CSBLANK) /* for new chips */
		{
		    bplcon0 |= USE_BPLCON3;        /* permission to listen */
		    bplcon3 |= BPLCON3_EXTBLNKEN;  /* ok to listen ?       */
		}

		*++p = bplcon0; /* unfortunate but necessary   */
		*q++ = bplcon2; /* setting up bplcon registers */
		*q++ = bplcon3; /* may be dangerous... -- bart */
	    }
#endif

	}
	else
	{
	    ULONG *p = GBASE->copinit->diagstrt;
	    ULONG kill = (0x1FE&(int)(&io->bplpt[0])) << 16;

	    *p   = kill; /* kill top color set up */
#ifdef ZD_BP
	    /* kill top bplcon set ups */
	    if(GBASE->ChipRevBits0 & GFXF_HR_DENISE)
	    {
		ULONG *q = GBASE->copinit->genloc;
		*q++ = kill; /* kill newgenloc modes */
		kill = (0x1FE&(int)(&io->bplpt[0])+2) << 16;
		*++p = kill; /* kill viewport modes */
		*q++ = kill; /* kill extended modes */
	    }
#endif
	}
	if(GBASE->ChipRevBits0 & GFXF_HR_DENISE)
d39 1
a39 13
	    /* must set up diwstart here because copper list */
	    /* may have just moved down and the old one is */
	    /* now incorrect */
	    /* all we have to do is delay it till the proper */
	    /* one is loaded */
	    ULONG val = 0;
	    ULONG *p = GBASE->copinit->diwstart;
	    val = (0x1FE&(int)(&io->diwstrt)) << 16;
	    val |= 0xffff;
	    *p++ = val;
	    val = (0x1FE&(int)(&io->diwhigh)) << 16;
	    val |= 0xff;	/* never */
	    *p++ = val;
d41 1
a41 5
    }

    ReleaseSemaphore(GBASE->ActiViewCprSemaphore);
}
#endif
d166 3
a171 2
	struct	ViewExtra *ve = 0;
	struct	MonitorSpec *mspc = 0;
a194 1

d220 1
a220 1
	if(!(mspc == GBASE->current_monitor))
a225 1

d301 2
d306 1
d311 1
d313 1
@


39.8
log
@increments specialcounter.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.7 92/05/15 07:27:21 spence Exp Locker: chrisg $
a48 1
    GBASE->SpecialCounter++;
d299 1
@


39.7
log
@VBLANK_BUG code (#ifdef ed out)
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.6 92/03/13 15:46:14 spence Exp Locker: spence $
d49 1
a49 1

@


39.6
log
@swap LOF/SHF copperlists if laced with a lightpen (for the chip bug).
/.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.5 92/02/19 14:38:18 spence Exp Locker: spence $
d17 1
d330 11
d343 1
d347 5
d353 3
a355 1
		if (GBASE->system_bplcon0 & 0x8)
a363 10
	}

	mspc = GBASE->default_monitor;

	if (d->Modes & EXTEND_VSTRUCT)
	{
	    if((ve = (struct ViewExtra *) GfxLookUp(d)) && ve->Monitor)
	    {
		mspc = ve->Monitor;
	    }
@


39.5
log
@Pokes HBSTOP with the CPU instead of copinit
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.4 92/01/07 16:07:08 spence Exp Locker: spence $
d329 16
a344 1
	if (d->SHFCprList) GBASE->SHFlist = d->SHFCprList->start;
@


39.4
log
@gfxlookup -> GfxLookUp
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.3 91/12/19 13:30:09 spence Exp Locker: spence $
d207 1
a207 2
	/* hbstop is done by copper list */

a250 12
	/* set up hbstops in copper list */
	{
		UWORD *p;
		p = (UWORD *) GBASE->copinit;
		*p++ = 0x1fe & ((int)&io->hbstop);
		*p = hcenter - 
		    (mspc->ms_Special->hsync.asi_Stop - 
		     mspc->ms_Special->hsync.asi_Start);
		p = GBASE->copinit->norm_hblank;
		*p++ = 0x1fe & ((int)&io->hbstop);
		*p = mspc->ms_Special->hblank.asi_Stop;
	}
@


39.3
log
@No longer handles A2024 cases. This is done externally (through the A2024
driver which SetPatch()es LoadView().
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.2 91/08/27 17:53:58 spence Exp Locker: spence $
d348 1
a348 1
	    if((ve = (struct ViewExtra *) gfxlookup(d)) && ve->Monitor)
@


39.2
log
@use new custom.h instead of newcustom.h
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.1 91/08/27 16:44:20 spence Exp Locker: spence $
a396 27
	}

	if (d->LOFCprList->Next)	/* a2024 special? */
	{
	    /* transfer ptrs to gb_hedley */
	    /* kill new chip beam counters */
	    GBASE->hedley[0] = (ULONG) d->LOFCprList->start;
	    GBASE->hedley[1] = (ULONG) d->SHFCprList->start;
	    GBASE->hedley[2] = (ULONG) d->LOFCprList->Next->start;
	    GBASE->hedley[3] = (ULONG) d->SHFCprList->Next->start;

	    if (d->LOFCprList->Next->Next)
	    {
		GBASE->hedley[4] = (ULONG) d->LOFCprList->Next->Next->start;
		GBASE->hedley[5] = (ULONG) d->SHFCprList->Next->Next->start;
		GBASE->hedley_flags = 4;
	    }
	    else
	    {
		/* range validate */
		GBASE->hedley_count %= 16;
		GBASE->hedley_flags = 1;
	    }
	}
	else
	{
		GBASE->hedley_flags = 0;
@


39.1
log
@checks to see if TOPLINE in copinit should be changed.
Fixed lace bug created when we went native (stupid compiler optimisation)
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 39.0 91/08/21 17:19:38 chrisg Exp Locker: spence $
d18 1
a18 1
#include <hardware/newcustom.h>
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 37.3 91/05/20 11:12:42 chrisg Exp Locker: chrisg $
d12 5
a16 5
#include <graphics/gfx.h>
#include <graphics/gfxbase.h>
#include <graphics/copper.h>
#include <graphics/view.h>
#include <graphics/display.h>
d18 1
a18 1
#include <hardware/custom.h>
d277 3
a279 1
    struct Custom *io;
d283 4
d292 10
a301 2
	while (io->vposr & VPOSRLOF);   /* wait for short frame */
	while (((io->vhposr>>8)&0xff)<10);  /* wait till after vblank occurs */
d306 4
d314 8
d332 1
a332 1
    kprintf("loadview: view == 0x%08lx\n",d);
d479 8
a487 1
    io->intena = BITSET|INTF_VERTB;
@


37.3
log
@Added prototypes, improved warnings, and glue code. still needs work.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 1.1 91/05/20 10:41:54 chrisg Exp $
@


37.2
log
@ cleaned up for lattice and made use GBASE macro.
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 37.1 91/05/02 12:59:27 chrisg Exp Locker: chrisg $
d20 1
@


37.1
log
@ changed "../" to "/" for native build
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 37.0 91/01/07 15:19:50 spence Exp Locker: chrisg $
a40 1
    struct GfxBase *GB;
a42 1
    FETCHGBASE;
d46 1
a46 1
    ObtainSemaphore(GB->ActiViewCprSemaphore);
d48 1
a48 1
    if (v = GB->ActiView)
d69 1
a69 1
	    ULONG *p = GB->copinit->diagstrt;
d88 1
a88 1
	    if ((mspc) && (GB->ChipRevBits0 & GFXF_HR_DENISE))
d90 1
a90 1
		ULONG *q = GB->copinit->genloc;
d97 1
a97 1
		bplcon0 |= ( GB->system_bplcon0 | 
d150 1
a150 1
	    ULONG *p = GB->copinit->diagstrt;
d156 1
a156 1
	    if(GB->ChipRevBits0 & GFXF_HR_DENISE)
d158 1
a158 1
		ULONG *q = GB->copinit->genloc;
d166 1
a166 1
	if(GB->ChipRevBits0 & GFXF_HR_DENISE)
d174 1
a174 1
	    ULONG *p = GB->copinit->diwstart;
d184 1
a184 1
    ReleaseSemaphore(GB->ActiViewCprSemaphore);
d188 1
a188 1
default_monitor(mspc)
a191 1
    struct GfxBase *GB;
a192 1
    FETCHGBASE;
d249 1
a249 1
	newdefras(GB,mspc->ratioh,mspc->ratiov);
d254 1
a254 1
		p = GB->copinit;
d259 1
a259 1
		p = GB->copinit->norm_hblank;
d273 1
a273 1
loadview(d)
a276 1
    struct GfxBase *GB;
a277 2
    FETCHGBASE;

d283 1
a283 1
    if( (d) && ( (GB->Modes&INTERLACE) && (!(d->Modes&INTERLACE))) )
d291 1
a291 1
    ObtainSemaphore(GB->ActiViewCprSemaphore);
d295 1
a295 1
    if (GB->ActiView = d)
d313 3
a315 3
	GB->Modes = d->Modes;
	GB->LOFlist = d->LOFCprList->start;
	if (d->SHFCprList) GB->SHFlist = d->SHFCprList->start;
d317 1
a317 1
	mspc = GB->default_monitor;
d327 1
a327 1
	if(!(mspc == GB->current_monitor))
d332 1
a332 1
	GB->current_monitor = mspc; /* update current */
d348 1
a348 1
	    io->beamcon0 = beamconpal(GB);	/* going to old mode */
d350 1
a350 1
	    kprintf("old mode: beamcon0 == %04lx\n",beamconpal(GB));
d358 2
a359 2
	if ( ( tot_rows != GB->current_tot_rows) ||
	     (tot_cclks != GB->current_tot_cclks)  )
d366 1
a366 1
		io->beamcon0 = beamconpal(GB);
d368 1
a368 1
		kprintf("mode_change: beamcon0 == %04lx\n",beamconpal(GB));
d376 4
a379 4
	    GB->hedley[0] = d->LOFCprList->start;
	    GB->hedley[1] = d->SHFCprList->start;
	    GB->hedley[2] = d->LOFCprList->Next->start;
	    GB->hedley[3] = d->SHFCprList->Next->start;
d383 3
a385 3
		GB->hedley[4] = d->LOFCprList->Next->Next->start;
		GB->hedley[5] = d->SHFCprList->Next->Next->start;
		GB->hedley_flags = 4;
d390 2
a391 2
		GB->hedley_count %= 16;
		GB->hedley_flags = 1;
d396 1
a396 1
		GB->hedley_flags = 0;
d423 3
a425 3
		GB->MaxDisplayRow = mspc->total_rows - 1; /* for vbasm */
		GB->MaxDisplayColumn = mspc->DeniseMaxDisplayColumn; 
		GB->MinDisplayColumn = mspc->DeniseMinDisplayColumn;
d429 1
a429 1
		GB->MaxDisplayRow = ( ( GB->DisplayFlags & PAL ) ?
d433 2
a434 2
		GB->MaxDisplayColumn = STANDARD_DENISE_MAX; /* bart */
		GB->MaxDisplayColumn = STANDARD_DENISE_MIN; /* bart */
d437 2
a438 2
	GB->current_tot_rows = tot_rows;
	GB->current_tot_cclks = tot_cclks;
d443 1
a443 1
	GB->current_monitor = NULL; /* no view, so no monitor either */
d445 4
a448 4
	GB->hedley_flags = 0;
	GB->LOFlist = GB->copinit->wait_forever;
	GB->Modes = 0;
	defras(GB);
d451 1
a451 1
    ReleaseSemaphore(GB->ActiViewCprSemaphore);
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 36.36 90/10/25 10:35:47 spence Exp Locker: spence $
d28 1
a28 1
#include "../macros.h"
@


36.36
log
@loadview() sets GB->hedley_flags to 0 if there is no copper list (MrgCop
returned an error instead of an ALERT).
@
text
@d3 1
a3 1
*	$Id: loadview.c,v 36.35 90/07/27 16:58:10 bart Exp $
@


36.35
log
@id
@
text
@d3 1
a3 1
*	$Id: $
d452 1
@


36.34
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/graphics/c/RCS/loadview.c,v 36.33 89/08/22 09:35:59 bart Exp Locker: bart $
@


36.33
log
@single thread access to ActiView hardware copper list
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.32 89/05/05 10:35:51 bart Exp $
@


36.32
log
@check for view in lace->nonlace switchover
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.31 89/04/29 15:42:06 bart Exp $
d46 4
d185 2
d296 4
d456 2
@


36.31
log
@cm->Type checking
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.30 89/04/13 09:52:40 bart Exp $
d282 1
a282 1
    /* only allow interlace->noninterlace transitions during short fram */
d284 1
a284 1
    if ((GB->Modes&INTERLACE)&&(0==(d->Modes&INTERLACE)))
d446 1
@


36.30
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.29 89/03/20 16:40:33 bart Exp $
d107 1
a107 1
		if(cm->Flags & COLORMAP_TRANSPARENCY)
d109 4
a112 2
		    bplcon2 |= BPLCON2_ZDCTEN;
		}
d114 17
a130 4
		if(cm->Flags & COLORPLANE_TRANSPARENCY)
		{
		    bplcon2 |= BPLCON2_ZDBPEN;
		    bplcon2 |= cm->TransparencyPlane <<12;
a138 12
		if(cm->Flags & BORDER_BLANKING)
		{
		    bplcon0 |= USE_BPLCON3;        /* permission to listen */
		    bplcon3 |= BPLCON3_BRDNBLNK;
		}

		if(cm->Flags & BORDER_NOTRANSPARENCY)
		{
		    bplcon0 |= USE_BPLCON3;        /* permission to listen */
		    bplcon3 |= BPLCON3_BRDNTRAN;
		}

d314 2
d318 1
a318 2
	    ve = (struct ViewExtra *) gfxlookup(d);
	    if(ve)
d320 1
a320 1
		mspc = ve->Monitor; 	/* use specified */
a321 5
	}

	if(!mspc)
	{
	    mspc = GB->default_monitor; /* use default */
@


36.29
log
@downcoded update_top_color()
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.28 89/03/20 10:08:50 bart Exp $
d26 1
d224 1
@


36.28
log
@update_top_color(mspc)
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.27 89/03/16 16:10:02 bart Exp $
d31 3
d178 1
@


36.27
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.26 89/03/16 14:05:34 bart Exp $
d31 2
a32 1
update_top_color()
d82 1
a82 1
	    if (GB->ChipRevBits0 & GFXF_HR_DENISE)
a83 2
		struct ViewExtra *ve;
		struct MonitorSpec *mspc = NULL;
a113 14

		if (v->Modes & EXTEND_VSTRUCT)
		{
		    if(ve = gfxlookup(v));
		    {
			mspc = ve->Monitor;
		    }
		}

		if(!mspc)
		{
		    mspc = GB->default_monitor;
		}

d147 1
a147 1
	    if (GB->ChipRevBits0 & GFXF_HR_DENISE)
d157 1
a157 1
	if (GB->ChipRevBits0 & GFXF_HR_DENISE)
a304 2
	update_top_color();

d325 2
@


36.26
log
@fixed loadview scanrate change timing interaction bug!!! studley bart
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.25 89/03/07 16:40:39 bart Exp $
d131 2
a132 2
		    bplcon0 |= USE_BPLCON3;        /* permission to listen? */
		    bplcon3 |= BPLCON3_EXTBLNKEN;  /* ok to listen ?      */
d137 1
d143 1
@


36.25
log
@ULONG color = (0x1FE&(int)(&io->color[0])) << 16;
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.24 89/03/07 16:33:20 bart Exp $
d42 1
a42 1
    if (vp = v->ViewPort)
d54 2
a55 3
		if (vp->Modes & INTERLACE) tempdy >>= 1;
		if (bestdy > tempdy)
		{ bestvp = vp;	bestdy = tempdy; }
d78 1
a78 1
	    *p++ = color; /* top color */
d86 3
a88 2
		ULONG bplcon2 = (0x1FE&(int)(&io->bplcon2)) << 16;
		ULONG bplcon3 = (0x1FE&(int)(&io->bplcon3)) << 16;
d90 8
a114 1
		*q++ = bplcon2; /* top genlock modes */
d131 2
a132 1
		    bplcon3 |= BPLCON3_EXTBLNKEN;  /* ok to listen ? */
d145 3
a147 1
		*q++ = bplcon3; /* stuff it at head of copinit -- bart */
d150 1
d154 15
a168 4
	    /* kill top color set up */
	    UWORD *p;
	    p = GB->copinit->diagstrt;
	    *p = COPPER_MOVE|(0x1FE&(int)(&io->bplpt[0]));
@


36.24
log
@color00
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.23 89/03/03 11:06:05 bart Exp $
d62 1
a62 1
	    ULONG color = (0x1FE&(int)(&io->color00[0])) << 16;
@


36.23
log
@redefine ZD_BP for now
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.22 89/03/03 11:01:49 bart Exp $
d62 1
a62 1
	    ULONG color = (0x1FE&(int)(&io->color)) << 16;
@


36.22
log
@undefine ZD_BP for now
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.21 89/03/02 18:30:06 bart Exp $
d21 1
a21 1
/* #define ZD_BP */
@


36.21
log
@genlock
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.20 89/02/14 10:12:48 bart Exp $
d21 1
a21 1
#define ZD_BP
@


36.20
log
@checkpoint 02.14.89
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.19 89/02/01 17:52:29 bart Exp $
d21 2
d46 1
d62 3
a64 1
	    UWORD *p,*ct;
a66 1
	    p = GB->copinit->diagstrt;
d70 1
a70 1
	    if (bestvp->Modes & SUPERHIRES)
d76 64
a139 2
	    *p++ = 0x1fe & ((int)io->color);
	    *p = qwe | gen;
d156 1
a156 1
	    ULONG *p = GB->copinit->vsync_hblank;
@


36.19
log
@checkpoint -- a2024 10hz and 15hz scan works from 32 bit id
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.18 89/02/01 17:41:21 bart Exp $
@


36.18
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.17 89/01/31 15:38:50 bart Exp $
@


36.17
log
@checkpoint 2024
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.16 88/10/17 15:08:04 bart Exp $
a301 1
		kprintf("loadview: GB->hedley_flags = 4\n");
a307 1
		kprintf("loadview: GB->hedley_flags = 1\n");
a312 1
		kprintf("loadview: GB->hedley_flags = 0\n");
@


36.16
log
@default monitorspec guaranteed to exist ... optimise
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.15 88/09/11 14:00:18 bart Exp $
d302 1
d309 1
d315 1
@


36.15
log
@vp->Modes & SUPERHIRES
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.14 88/08/12 13:18:53 bart Exp $
d246 1
a246 1
	if(mspc)
d248 1
a248 4
	    if(!(mspc == GB->current_monitor))
	    {
		mode_change = TRUE; /* force change */
	    }
d257 1
a257 1
	if ((mspc) && (mspc->ms_Flags))
@


36.14
log
@mspc->DeniseMinDisplayColumn
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.13 88/09/01 10:48:16 bart Exp $
d66 1
a66 1
	    if (bestvp->ExtendedModes & VPF_SUPER_HIRES)
@


36.13
log
@GB->MaxDisplayColumn = mspc->DeniseMaxDisplayColumn -- bart
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.12 88/07/25 14:23:51 bart Exp $
d344 2
a345 1
		GB->MaxDisplayColumn = mspc->DeniseMaxDisplayColumn; /* bart */
d354 1
@


36.12
log
@default_monitorspec
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.11 88/07/23 17:08:45 bart Exp $
d344 9
@


36.11
log
@monitorspec -- bart 07.23.88 merge source
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.10 88/07/15 17:35:38 dale Exp $
d237 14
a250 7
		if(mspc = ve->Monitor)
		{
		    if(!(mspc == GB->current_monitor))
		    {
			mode_change = TRUE; /* force change */
		    }
		}
@


36.10
log
@cd ..
Fix for proper displaywindow killing at top of screen
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.9 88/07/08 14:02:45 bart Exp $
d31 1
a31 1
	/* put correct copper color in upper half of screen */
d33 5
a37 5
	struct View *v;
	struct GfxBase *GB;
	struct ViewPort *vp,*bestvp;
	struct ColorMap *cm;
	FETCHGBASE;
d39 60
a98 60
	if (v = GB->ActiView)
		if (vp = v->ViewPort)
		{
			WORD bestdy;
			WORD tempdy;
			bestdy = 10000;
			/* find topmost vp */
			while ( vp )
			{
				if ( (vp->Modes & VP_HIDE) == 0)
				{
					tempdy = vp->DyOffset;
					if (vp->Modes & INTERLACE) tempdy >>= 1;
					if (bestdy > tempdy)
					{ bestvp = vp;	bestdy = tempdy; }
				}
				vp = vp->Next;
			}
			if (cm = bestvp->ColorMap)
			{
				UWORD *p,*ct;
				UWORD qwe;
				UWORD gen;
				p = GB->copinit->diagstrt;
				ct = (UWORD *)cm->ColorTable;
				qwe = *ct;
				gen = check_genlock(cm,0);
				if (bestvp->ExtendedModes & VPF_SUPER_HIRES)
				{
					qwe &= 0xccc;	/* clear unused bits */
					qwe |= (qwe>>2); /* funny hardware */
					gen |= gen>>1;
				}
				*p++ = 0x1fe & ((int)io->color);
				*p = qwe | gen;
			}
			else
			{
				/* kill top color set up */
				UWORD *p;
				p = GB->copinit->diagstrt;
				*p = COPPER_MOVE|(0x1FE&(int)(&io->bplpt[0]));
			}
			if (GB->ChipRevBits0 & GFXF_HR_DENISE)
			{
				/* must set up diwstart here because copper list */
				/* may have just moved down and the old one is */
				/* now incorrect */
				/* all we have to do is delay it till the proper */
				/* one is loaded */
				ULONG val = 0;
				ULONG *p = GB->copinit->vsync_hblank;
				val = (0x1FE&(int)(&io->diwstrt)) << 16;
				val |= 0xffff;
				*p++ = val;
				val = (0x1FE&(int)(&io->diwhigh)) << 16;
				val |= 0xff;	/* never */
				*p++ = val;
			}
		}
d101 86
d191 1
a191 2
	int special = 0;
	struct GfxBase *GB;
d193 2
a194 7
	FETCHGBASE;
#ifdef DEBUG
	kprintf("loadview(%lx)\n",d);
#ifdef DEBUGDEBUG
	Debug();
#endif
#endif
d196 1
d199 1
d202 2
a203 2
		while (io->vposr & VPOSRLOF);   /* wait for short frame */
		while (((io->vhposr>>8)&0xff)<10);  /* wait till after vblank occurs */
d205 1
d207 1
d210 6
a215 6
		int	tot_rows = 0;
		int	tot_cclks = 0;
		UWORD	old_dma;
		struct	ViewExtra *ev = 0;
		char	dma_off = FALSE;
		char	monitor_change = FALSE;
d217 21
a237 1
		if (d->LOFCprList == 0)
d239 4
a242 1
			goto no_cpr_list;
d244 2
a245 4
		GB->Modes = d->Modes;
		GB->LOFlist = d->LOFCprList->start;
		if (d->SHFCprList) GB->SHFlist = d->SHFCprList->start;
		update_top_color();
d247 4
a250 24
		if (d->Modes & EXTEND_VSTRUCT)	ev = gfxlookup(d);
		if (ev)
		{
			/* found new 1.3 stuff */
			tot_rows = ev->total_rows;
			tot_cclks = ev->total_colorclocks;
		}
		else	io->beamcon0 = beamconpal(GB);	/* going to old mode */
		if ( (tot_rows == 0x106) && (tot_cclks == 226))
		{
			/* hack, must use standard chip features */
			tot_rows = 0;
			tot_cclks = 0;
		}
		old_dma = io->dmaconr;
		if ( (tot_rows != GB->current_tot_rows) ||
			(tot_cclks != GB->current_tot_cclks) )
		{
			/* turn off all dma that may blow up */
#ifdef DEBUG
		kprintf("turning off dma for safety\n");
		kprintf("oldrows=%ld oldclks=%ld\n",GB->current_tot_rows,
				GB->current_tot_cclks);
		kprintf("newrows=%ld newclks=%ld\n",tot_rows,tot_cclks);
a251 15
			io->dmacon = DMAF_COPPER|DMAF_RASTER|DMAF_SPRITE;
			dma_off = TRUE;
#ifdef DEBUG
			kprintf("old_dma=%lx\n",old_dma);
#endif
			io->beamcon0 = beamconpal(GB);
		}
		if (d->LOFCprList->Next)	/* a2024 special? */
		{
			/* transfer ptrs to gb_hedley */
			/* kill new chip beam counters */
			GB->hedley[0] = d->LOFCprList->start;
			GB->hedley[1] = d->SHFCprList->start;
			GB->hedley[2] = d->LOFCprList->Next->start;
			GB->hedley[3] = d->SHFCprList->Next->start;
d253 11
a263 14
			if (d->LOFCprList->Next->Next)
			{
				GB->hedley[4] = d->LOFCprList->Next->Next->start;
				GB->hedley[5] = d->SHFCprList->Next->Next->start;
				GB->hedley_flags = 4;
			}
			else
			{
				/* range validate */
				GB->hedley_count %= 16;
				GB->hedley_flags = 1;
			}
#ifdef DEBUG
		kprintf("enter hedley mode\n");
d265 1
a265 5
		}
		else
		{
			GB->hedley_flags = 0;
		}
d267 1
a267 20
#define RATIOH(x)	((ratioh*x)>>4)
#define RATIOV(x)	((ratiov*x)>>4)
#define HSYNC_WIDTH	(16)	/* this value is absolute */
/*   values for 31.5khz */
/*   hsync    start    at    0x0e */
/*   hsync    stop     at    0x1e */
/*   hblank   start    at    0x07 */
/*   hblank   stop     at    0x1f */
/*   vsync    width    is    65usec */
/* defined in color clocks */
#define HSYNC_START	0x0e
#define HSYNC_STOP	(HSYNC_START+HSYNC_WIDTH)
#define HBLANK_START	0x07
#define HBLANK_STOP	0x1f
/* defined by row ctr */
#define VSYNC_WIDTH	(65*4/tot_cclks)
#define VSYNC_START	3
#define VSYNC_STOP	(VSYNC_START+VSYNC_WIDTH)
#define VBLANK_START	(VSYNC_START-(97*4/tot_cclks))
#define VBLANK_STOP	(VSYNC_STOP+(815*4/tot_cclks))
d269 1
a269 25
		if ( (tot_rows != GB->current_tot_rows) ||
			(tot_cclks != GB->current_tot_cclks) )
		if ( ( tot_rows || tot_cclks ) && (d->LOFCprList) )
		{
			/* turn on all dma that may blow up */
			UWORD	BeamControl;
			int hcenter;
			int ratioh,ratiov;
			{
				ratiov = ev->ratiov;
				ratioh = ev->ratioh;
				io->htotal = tot_cclks;
				/* fudge this value? */
				io->hbstrt = HBLANK_START;
				/* hbstop is done by copper list */
				io->hsstrt = HSYNC_START;
				io->hsstop = HSYNC_STOP;
				hcenter = (tot_cclks>>1) + HSYNC_START;
				io->hcenter = hcenter;
				io->vtotal = tot_rows;
				io->vsstrt = VSYNC_START;
				io->vsstop = VSYNC_STOP;
				io->vbstrt = VBLANK_START;
				io->vbstop = VBLANK_STOP;
				newdefras(GB,ev->ratioh,ev->ratiov);
d271 11
a281 4
#ifdef DEBUG
	kprintf("new registers all setup\n");
#ifdef DEBUGDEBUG
	Debug();
d283 1
a283 32
#endif
				/* set up hbstops in copper list */
				{
					UWORD *p;
					p = GB->copinit;
					*p++ = 0x1fe & ((int)&io->hbstop);
					*p = hcenter - HSYNC_WIDTH;
					p = GB->copinit->norm_hblank;
					*p++ = 0x1fe & ((int)&io->hbstop);
					*p = HBLANK_STOP;
				}
				/* really need to wait till vsync here */
				/* this value kills csync output */
				/* but makes hedley display work */
				/* new value puts csync on hsync, hoping */
				/* monitors that want hsync/vsync will */
				/* ignore the vsync component */
				/* only use new chip registers is other */
				/* than standard display */
				BeamControl = VARVBLANK | LOLDIS | CSCBLANKEN |
						VARVSYNC | VARBEAM | CSBLANK |
						VARHSYNC |
						VSYNCTRUE /*| HSYNCTRUE*/;
				if (tot_cclks == 226)	io->beamcon0 = beamconpal(GB);
				else			io->beamcon0 = 0x1e8b|beamconpal(GB);
				/* but I may want to force the issue */
				if (GB->Debug & 0x80) io->beamcon0 = 0x1e88|beamconpal(GB);
				/* tmp hack for diwhigh */
				/* set copper danger bit */
				/*io->copcon = 2;*/
				special = 1;
			}
d285 36
a320 4
#ifdef DEBUG
	kprintf("tada!!!!\n");
#ifdef DEBUGDEBUG
	Debug();
d322 1
a322 1
#endif
d324 18
a341 3
		GB->current_tot_rows = tot_rows;
		GB->current_tot_cclks = tot_cclks;
		if (dma_off)	io->dmacon = old_dma | DMAF_SETCLR;
d345 1
d347 3
a349 3
		GB->LOFlist = GB->copinit->wait_forever;
		GB->Modes = 0;
		defras(GB);
a351 6
#ifdef DEBUGS
	if (special)
	{
		Debug();
	}
#endif
@


36.9
log
@range validate GB->hedley_count %= 16
only if GB->hedley_flags = 1
fixes a2024 update bug when loadview called "often"
bart
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.8 88/05/02 19:02:11 dale Exp $
d92 1
a92 1
				val |= 0xff20;
d95 1
a95 1
				val |= 0x707;	/* never */
@


36.8
log
@More changes to support setrgb4,loadrgb4 for genlock control.
Also changed the interface to check_genlock to take a ColorMap
ptr instead of Flags and Bits. Makes it a little more general purpose
as well as all the callers a little more efficient.
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.7 88/05/02 14:02:03 dale Exp $
d182 1
a182 2
			GB->hedley_count = 12;
			GB->hedley_flags = 1;
d188 6
@


36.7
log
@Fixes to make top color genlock properly.
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.6 88/05/18 18:31:15 dale Exp $
d65 1
a65 2
				gen = check_genlock(cm->Flags,0,
					cm->TransparencyBits);
@


36.6
log
@Fix for topcolor in super hires mode.
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.5 88/05/18 17:14:49 dale Exp $
d61 1
d65 2
d71 1
d74 1
a74 1
				*p = qwe;
@


36.5
log
@Fix for going from superhires->ntsc
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.4 88/05/17 22:49:20 dale Exp $
d64 2
a65 2
#ifdef QWEQWE
				if (bestvp->ExtendedModes & VPF_DENISE)
d67 2
a68 1
#endif
@


36.4
log
@fixes for super hires.
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.3 88/03/11 17:07:12 dale Exp $
a279 2
			GB->current_tot_rows = tot_rows;
			GB->current_tot_cclks = tot_cclks;
d287 2
@


36.3
log
@newchip PAL changes, proper PGA syncs and bullshit.
Dale
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.2 88/03/10 20:41:56 dale Exp $
d20 1
d78 16
d107 1
d110 1
d126 2
d146 6
d161 1
a161 1
		kprintf("newrows=%lx newclks=%ld\n",tot_rows,tot_cclks);
d164 1
d170 1
a170 1
#ifdef NEW_HEDLEY
d172 9
a180 3
			struct ViewPort *vp;
			vp = d->ViewPort;
			if (d->LOFCprList->Next)
d182 4
a185 14
				/* transfer ptrs to gb_hedley */
				/* kill new chip beam counters */
				GB->hedley[0] = d->LOFCprList->start;
				GB->hedley[1] = d->SHFCprList->start;
				GB->hedley[2] = d->LOFCprList->Next->start;
				GB->hedley[3] = d->SHFCprList->Next->start;
				GB->hedley_count = 12;
				GB->hedley_flags = 1;
				if (d->LOFCprList->Next->Next)
				{
					GB->hedley[4] = d->LOFCprList->Next->Next->start;
					GB->hedley[5] = d->SHFCprList->Next->Next->start;
					GB->hedley_flags = 4;
				}
a188 8
			}
			else
			{
				GB->hedley_flags = 0;
#ifdef DEBUG
	kprintf("exit hedley mode\n");
#endif
			}
d190 4
a193 1
#endif
d216 2
d244 1
d247 1
d284 1
d287 1
d289 1
a289 1
		io->dmacon = old_dma | DMAF_SETCLR;
@


36.2
log
@hires chip changes.
@
text
@d3 1
a3 1
*	$Header: loadview.c,v 36.1 88/03/10 16:11:52 dale Exp $
d124 1
a124 1
		else	io->beamcon0 = 0;	/* going to old mode */
d140 1
a140 1
			io->beamcon0 = 0;
d179 17
a195 1
#define HSYNC_START	RATIOH(6)
d208 2
a209 1
				io->hbstrt = 4 + RATIOH(4);
d211 1
a211 2
				/* give me about 4usec */
				io->hsstop = HSYNC_START+HSYNC_WIDTH;
a213 2
				/*io->hbstop =  hcenter - HSYNC_WIDTH;*/
				/*io->hbstop = RATIOH(20);*/
d215 4
a218 5
				io->vbstrt = 0;
				io->vbstop = RATIOV(32);
				io->vsstrt = RATIOV(3);
				/* give me about 160usec */
				io->vsstop = RATIOV(3)+160*4/tot_cclks;
d233 1
a233 1
					*p = 0xe + RATIOH(0x1a);
a237 1
				/*io->beamcon0 = 0x1b98;*/
d247 2
a248 2
				if (tot_cclks == 226)	io->beamcon0 = 0;
				else			io->beamcon0 = 0x1e8b;
d250 1
a250 1
				if (GB->Debug & 0x80) io->beamcon0 = 0x1e88;
@


36.1
log
@V36 initial check in
@
text
@d3 1
a3 1
*	$Header: $
d178 2
a179 2
#define HSYNC_WIDTH	(16)
#define HSYNC_START	(12 + RATIOH(4))
d192 1
a192 1
				io->hbstrt = 8;
d220 1
a220 1
					*p = RATIOH(0x28);
d233 1
d241 1
a241 1
				io->copcon = 2;
@
