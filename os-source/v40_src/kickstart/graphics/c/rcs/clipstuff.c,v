head     39.11;
branch   ;
access   ;
symbols  rel39_24:39.11 rel39_18:39.11 rel39_97:39.11 rel39_90:39.11 rel39_89:39.11 rel39_82:39.11 rel39_76:39.10 rel39_71:39.10 rel39_65:39.10 rel39_64:39.10 rel39_61:39.10 rel39_60:39.10 rel39_55:39.10 rel39_47:39.10 rel39_39:39.10 rel39_38:39.10 rel39_37:39.10 rel39_35:39.9 rel39_34:39.9 V37_30:37.5 V37_29:37.4 V37_28:37.4 V37_27:37.4 V37_25:37.4 V37_24:37.3 V37_23:37.3 V37_22:37.3 V37_21:37.3 V37_20:37.2 V37_19:37.1 V37_17:37.1 V37_15:37.1 V37_14:37.1 V37_13:37.1 V37_12:37.1 V37_11:37.1 V37_10:37.1 V37_9:37.1 V37_8:37.1 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.57 V36_208:36.57 V36_207:36.57 V36_205:36.57 V36_203:36.57 V36_202:36.57 V36_201:36.57 V36_200:36.57 V36_199:36.56 V36_198:36.55 V36_196:36.55 V36_195:36.55 V36_194:36.55 V36_193:36.55 V36_192:36.55 V36_191:36.55 V36_190:36.55 V36_189:36.55 V36_188:36.55 V36_186:36.55 V36_185:36.55 V36_184:36.55 V36_182:36.55 V36_181:36.55;
locks    ; strict;
comment  @*   @;


39.11
date     92.08.06.11.26.51;  author spence;  state Exp;
branches ;
next     39.10;

39.10
date     92.02.25.14.24.24;  author spence;  state Exp;
branches ;
next     39.9;

39.9
date     92.01.29.16.43.45;  author spence;  state Exp;
branches ;
next     39.8;

39.8
date     91.12.20.15.45.35;  author spence;  state Exp;
branches ;
next     39.7;

39.7
date     91.11.15.18.56.18;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     91.10.30.19.16.17;  author spence;  state Exp;
branches ;
next     39.5;

39.5
date     91.10.29.11.32.42;  author spence;  state Exp;
branches ;
next     39.4;

39.4
date     91.10.28.19.31.08;  author spence;  state Exp;
branches ;
next     39.3;

39.3
date     91.10.18.18.35.35;  author spence;  state Exp;
branches ;
next     39.2;

39.2
date     91.10.17.13.59.39;  author chrisg;  state Exp;
branches ;
next     39.1;

39.1
date     91.08.27.16.31.19;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.15.30;  author chrisg;  state Exp;
branches ;
next     37.7;

37.7
date     91.05.20.10.53.47;  author chrisg;  state Exp;
branches ;
next     37.6;

37.6
date     91.05.02.12.51.15;  author chrisg;  state Exp;
branches ;
next     37.5;

37.5
date     91.04.26.16.25.26;  author spence;  state Exp;
branches ;
next     37.4;

37.4
date     91.04.15.14.03.56;  author spence;  state Exp;
branches ;
next     37.3;

37.3
date     91.03.28.20.31.34;  author spence;  state Exp;
branches ;
next     37.2;

37.2
date     91.03.14.18.46.20;  author spence;  state Exp;
branches ;
next     37.1;

37.1
date     91.01.30.17.15.31;  author bart;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.18.31;  author spence;  state Exp;
branches ;
next     36.57;

36.57
date     90.12.02.12.36.45;  author spence;  state Exp;
branches ;
next     36.56;

36.56
date     90.11.16.16.31.29;  author spence;  state Exp;
branches ;
next     36.55;

36.55
date     90.07.27.16.55.26;  author bart;  state Exp;
branches ;
next     36.54;

36.54
date     90.04.11.18.40.00;  author bart;  state Exp;
branches ;
next     36.53;

36.53
date     90.04.11.16.45.22;  author bart;  state Exp;
branches ;
next     36.52;

36.52
date     90.04.06.18.30.54;  author bart;  state Exp;
branches ;
next     36.51;

36.51
date     90.04.06.18.20.29;  author bart;  state Exp;
branches ;
next     36.50;

36.50
date     90.03.28.09.13.15;  author bart;  state Exp;
branches ;
next     36.49;

36.49
date     89.04.29.15.41.23;  author bart;  state Exp;
branches ;
next     36.48;

36.48
date     89.02.24.09.42.56;  author bart;  state Exp;
branches ;
next     36.47;

36.47
date     89.02.17.22.03.13;  author bart;  state Exp;
branches ;
next     36.46;

36.46
date     89.02.15.16.45.38;  author bart;  state Exp;
branches ;
next     36.45;

36.45
date     89.02.15.16.07.05;  author bart;  state Exp;
branches ;
next     36.44;

36.44
date     89.02.14.18.22.00;  author bart;  state Exp;
branches ;
next     36.43;

36.43
date     89.02.14.10.11.44;  author bart;  state Exp;
branches ;
next     36.42;

36.42
date     89.02.01.17.52.01;  author bart;  state Exp;
branches ;
next     36.41;

36.41
date     89.02.01.17.40.01;  author bart;  state Exp;
branches ;
next     36.40;

36.40
date     89.02.01.14.23.17;  author bart;  state Exp;
branches ;
next     36.39;

36.39
date     89.02.01.14.05.18;  author bart;  state Exp;
branches ;
next     36.38;

36.38
date     89.02.01.14.02.49;  author bart;  state Exp;
branches ;
next     36.37;

36.37
date     89.01.31.15.38.26;  author bart;  state Exp;
branches ;
next     36.36;

36.36
date     89.01.26.11.06.18;  author bart;  state Exp;
branches ;
next     36.35;

36.35
date     89.01.26.11.04.36;  author bart;  state Exp;
branches ;
next     36.34;

36.34
date     89.01.24.15.37.33;  author bart;  state Exp;
branches ;
next     36.33;

36.33
date     89.01.19.17.27.46;  author bart;  state Exp;
branches ;
next     36.32;

36.32
date     89.01.18.13.53.52;  author bart;  state Exp;
branches ;
next     36.31;

36.31
date     89.01.17.15.59.58;  author bart;  state Exp;
branches ;
next     36.30;

36.30
date     88.10.17.15.08.28;  author bart;  state Exp;
branches ;
next     36.29;

36.29
date     88.10.10.15.59.20;  author bart;  state Exp;
branches ;
next     36.28;

36.28
date     88.10.06.13.54.02;  author bart;  state Exp;
branches ;
next     36.27;

36.27
date     88.10.05.15.24.05;  author bart;  state Exp;
branches ;
next     36.26;

36.26
date     88.10.05.13.23.53;  author bart;  state Exp;
branches ;
next     36.25;

36.25
date     88.10.04.18.34.41;  author bart;  state Exp;
branches ;
next     36.24;

36.24
date     88.09.21.17.06.06;  author bart;  state Exp;
branches ;
next     36.23;

36.23
date     88.09.16.01.05.58;  author bart;  state Exp;
branches ;
next     36.22;

36.22
date     88.09.15.23.57.47;  author bart;  state Exp;
branches ;
next     36.21;

36.21
date     88.09.14.17.56.14;  author bart;  state Exp;
branches ;
next     36.20;

36.20
date     88.09.14.16.48.24;  author bart;  state Exp;
branches ;
next     36.19;

36.19
date     88.09.13.17.02.00;  author bart;  state Exp;
branches ;
next     36.18;

36.18
date     88.09.12.12.12.26;  author bart;  state Exp;
branches ;
next     36.17;

36.17
date     88.09.11.13.59.58;  author bart;  state Exp;
branches ;
next     36.16;

36.16
date     88.08.12.13.19.05;  author bart;  state Exp;
branches ;
next     36.15;

36.15
date     88.09.01.13.58.34;  author bart;  state Exp;
branches ;
next     36.14;

36.14
date     88.09.01.11.17.29;  author bart;  state Exp;
branches ;
next     36.13;

36.13
date     88.09.01.10.52.37;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     88.08.31.12.47.31;  author bart;  state Exp;
branches ;
next     36.11;

36.11
date     88.08.31.12.21.52;  author bart;  state Exp;
branches ;
next     36.10;

36.10
date     88.07.29.14.16.00;  author bart;  state Exp;
branches ;
next     36.9;

36.9
date     88.07.26.18.00.54;  author bart;  state Exp;
branches ;
next     36.8;

36.8
date     88.07.26.14.07.04;  author bart;  state Exp;
branches ;
next     36.7;

36.7
date     88.07.25.14.21.55;  author bart;  state Exp;
branches ;
next     36.6;

36.6
date     88.07.23.17.07.26;  author bart;  state Exp;
branches ;
next     36.5;

36.5
date     88.06.23.18.00.58;  author bart;  state Exp;
branches ;
next     36.4;

36.4
date     88.05.21.17.37.58;  author bart;  state Exp;
branches ;
next     36.3;

36.3
date     88.06.16.15.28.12;  author bart;  state Exp;
branches ;
next     36.2;

36.2
date     88.06.14.16.39.20;  author bart;  state Exp;
branches ;
next     36.1;

36.1
date     88.06.10.11.55.37;  author bart;  state Exp;
branches ;
next     36.0;

36.0
date     88.06.10.11.51.15;  author bart;  state Exp;
branches ;
next     ;


desc
@@


39.11
log
@call RealVPModeID() with View parameter.
@
text
@/******************************************************************************
*
*	$Id: clipstuff.c,v 39.10 92/02/25 14:24:24 spence Exp Locker: spence $
*
******************************************************************************/

#include <exec/types.h>
#include <exec/memory.h>
#include "/displayinfo.h"
#include "/gfx.h"
#include "/gfxbase.h"
#include "/display.h"
#include "/copper.h"
#include "/view.h"
#include "/monitor.h"
#include "/macros.h"
#include "/vp_internal.h"

#include "c.protos"
#include "/d/d.protos"

/*#define DEBUG*/

#ifdef DEBUG
#define D(x) {{x};}
#else
#define D(x)
#endif

ULONG getclipstuff(struct View *v, struct ViewPort *vp, struct BuildData *bd)
{
    struct ViewPortExtra *vpe = NULL;
    ULONG mode = RealVPModeID(vp, v);
    ULONG err;
    struct VecInfo vinfo;
    UWORD count;
    WORD fmode;

    D(kprintf("In getclipstuff(). mode = 0x%lx\n", mode);)
    D(kprintf("bd at 0x%lx, Flags = 0x%lx, Offset = 0x%lx\n", bd, bd->Flags, bd->Offset);)

    /* we have to call CalcFMode() as ScrollVPort() is a populatr way of
     * double-buffering, and the bitplanes may not be aligned.
     */

    if ((vp->ColorMap) && (vp->ColorMap->Type) && (vpe = vp->ColorMap->cm_vpe))
    {
	if ((fmode = CalcFMode(vp)) != (WORD)-1)
	{
		D(kprintf("Fmode = 0x%lx\n", fmode);)
	}
	else
	{
		return(BAD_CLIPSTUFF);	/* TFB - unaligned. */
	}
    }

    if (GetDisplayInfoData(NULL, (UBYTE *)&vinfo, sizeof(struct VecInfo), DTAG_VEC, mode))
    {
	struct ProgInfo *pinfo = (struct ProgInfo *)vinfo.Data;
	char **makeit;
	int (*nextone)();

	makeit = (GetVecTable(vp, &vinfo))->BuildVP;

	/* first in the list is the Initialisation code, last one
	 * is the cleanup code.
	 */
	nextone = (int (*)())(*makeit++);
	if ((err = ((*nextone)(v, vp, &vpe, pinfo, bd) & 0xFFFF)) == MVP_OK)
	{
		for (count = pinfo->ScrollVPCount; count; count--)
		{
			nextone = (int (*)())(*makeit++);
			(*nextone)(v, vp, vpe);
		}

	}
	/* look for the cleanup routine */

	while (*makeit)
		nextone = (int (*)())(*makeit++);

	(*nextone)(v, vp, vpe);
    }
    else
    {
	D(kprintf("No ProgInfo\n");)
	return(BAD_CLIPSTUFF);
    }

    return(GOOD_CLIPSTUFF);
}
@


39.10
log
@better error handling if the InitMVP() call fails.
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 39.9 92/01/29 16:43:45 spence Exp Locker: spence $
d33 1
a33 1
    ULONG mode = RealVPModeID(vp);
@


39.9
log
@Use RealVPModeID() to get modeid (knows about coercion).
No longer set vpe->fmode (done by the InitMVP() code).
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 39.8 91/12/20 15:45:35 spence Exp Locker: spence $
d70 1
a70 2
	bd->pinfo = pinfo;
	if ((err = ((*nextone)(v, vp, &vpe, pinfo) & 0xFFFF)) == MVP_OK)
a71 1
		vpe->DriverData[0] = (APTR)bd;
d78 2
a79 1
		/* look for the cleanup routine */
d81 2
a82 2
		while (*makeit)
			nextone = (int (*)())(*makeit++);
d84 1
a84 2
		(*nextone)(v, vp, vpe);
	}
@


39.8
log
@
Uses new_mode() instead of getvpmodeid()
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 39.7 91/11/15 18:56:18 spence Exp Locker: spence $
d33 1
a33 1
    ULONG mode = CleanMode(new_mode(vp));
d40 1
a40 1
    D(kprintf("bd at 0x%lx, Flags = 0x%lx, Offset = 0x%lx", bd, bd->Flags, bd->Offset);)
d50 1
a50 2
		vpe->FMode = fmode;
		vpe->Flags |= VPXF_HAVE_FMODE;
d91 1
@


39.7
log
@Recalculates FMode for the ViewPort. Can fail if double buffering
and new bitmaps fon't align
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 39.6 91/10/30 19:16:17 spence Exp Locker: spence $
d33 1
a33 1
    ULONG mode = CleanMode(getvpmodeid(vp));
@


39.6
log
@Find makeit list from GetVecTable()
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 39.5 91/10/29 11:32:42 spence Exp Locker: spence $
d30 1
a30 1
void getclipstuff(struct View *v, struct ViewPort *vp, struct BuildData *bd)
d37 1
d42 3
a44 2
    if ((vp->ColorMap) && (vp->ColorMap->Type))
	vpe = vp->ColorMap->cm_vpe;
d46 13
d93 2
@


39.5
log
@replace vpe->BuildData with vpe->DriverData[0]
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 39.4 91/10/28 19:31:08 spence Exp Locker: spence $
d50 1
a50 20
	/* take the BuildVP list from the ViewPortExtra. If vpe == NULL, then
	 * use the VecInfo. If this pointer is NULL (disk-based monitor), then
	 * do the best we can.
	 */
	if ((vpe) && (vpe->VecTable))
	{
		makeit = ((struct VecTable *)vpe->VecTable)->BuildVP;
	}
	else
	{
		if (vinfo.Vec)
		{
			makeit = ((struct VecTable *)vinfo.Vec)->BuildVP;
		}
		else
		{
			extern void *VecLists[];
			makeit = (((struct VecTable *)(VecLists[pinfo->MakeItType]))->BuildVP);
		}
	}
@


39.4
log
@Take the BuildData from the ViewPortExtra, VecInfo, and defaults in
that priority
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 39.3 91/10/18 18:35:35 spence Exp Locker: spence $
d78 1
a78 1
		vpe->BuildData = bd;
@


39.3
log
@ProgInfo -> VecInfo
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 39.2 91/10/17 13:59:39 chrisg Exp Locker: spence $
d47 1
a47 1
	char **makeit = ((struct VecTable *)(vinfo).Vec)->BuildVP;
d49 21
@


39.2
log
@killed typedef
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 39.1 91/08/27 16:31:19 spence Exp Locker: chrisg $
d35 1
a35 1
    struct ProgInfo pinfo;
d44 1
a44 1
    if (GetDisplayInfoData(NULL, (UBYTE *)&pinfo, sizeof(struct ProgInfo), DTAG_PROG, mode))
d46 2
a47 1
	char **makeit = pinfo.MakeIt;
d54 2
a55 1
	if ((err = ((*nextone)(v, vp, &vpe, &pinfo) & 0xFFFF)) == MVP_OK)
d58 1
a58 1
		for (count = pinfo.ScrollVPCount; count; count--)
@


39.1
log
@Uses new makevp() code (ie uses the database). This is a complete
rewrite of the old code to use the new code.
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 39.0 91/08/21 17:15:30 chrisg Exp Locker: spence $
d30 1
a30 1
void getclipstuff(struct View *v, struct ViewPort *vp, BuildData *bd)
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 37.7 91/05/20 10:53:47 chrisg Exp Locker: chrisg $
a6 2
#define CLIPOSCAN

d9 7
a15 7
#include "/displayinfo_internal.h"
#include <graphics/gfx.h>
#include <graphics/gfxbase.h>
#include <graphics/display.h>
#include <graphics/copper.h>
#include <graphics/view.h>
#include <graphics/monitor.h>
d17 1
a17 4

#ifdef CLIPOSCAN
#include "/displayinfo_internal.h"
#endif
d20 1
a20 54

/* #define SAS_DEBUG */
/* #define BARTDEBUG */
/* #define ALIASING */  /* agnus 8372-1 and above don't alias anymore -- bart */

#define COLORCLOCKS mspc->total_colorclocks
#define GRANULARITY 8

#define HFIX(x)	{ (x) = ((x)*mspc->ratioh) >> 4; }
#define VFIX(x)	{ (x) = ((x)*mspc->ratiov) >> 4; }

#define PROTOTYPE_DISPLAY

#ifdef  PROTOTYPE_DISPLAY

#ifdef ALIASING
#define MODE_NORMALIZE(x) \
{ if (modes     & SUPERHIRES) (x) >>= 1; }

#define MODE_SCALE(x) \
{ if (modes     & SUPERHIRES) (x) <<= 1; }
#endif

#define DENISE_OFFSET 9

#define LEFT_EDGE_ORIGIN 0x81	/* empirical value */

#ifdef ALIASING
#define MODE_OFFSET \
( (modes     & SUPERHIRES)? -4: ((modes     & HIRES)? 0: 4) )
#else
#define MODE_OFFSET \
( (modes     & SUPERHIRES)? -2: ((modes     & HIRES)? 0: 4) )
#endif

#define DENISE_TO_AGNUS(x) \
{ (x) -= DENISE_OFFSET; (x) >>= 1; (x) -= MODE_OFFSET; }

#define AGNUS_TO_DENISE(x) \
{ (x) += MODE_OFFSET; (x) <<= 1; (x) += DENISE_OFFSET; }

#define NORMALIZE_PIXELS(x) \
{ if ((modes     & HIRES)||(modes     & SUPERHIRES)) (x) >>= 1; \
  if (modes     & SUPERHIRES) (x) >>= 1; }

#define SCALE_PIXELS(x) \
{ if ((modes     & HIRES)||(modes     & SUPERHIRES)) (x) <<= 1; \
  if (modes     & SUPERHIRES) (x) <<= 1; }

#else

#ifdef ALIASING
#define MODE_NORMALIZE(x) \
{ if (vp->Modes & SUPERHIRES) (x) >>= 1; }
d22 1
a22 7
#define MODE_SCALE(x) \
{ if (vp->Modes & SUPERHIRES) (x) <<= 1; }
#endif

#define DENISE_OFFSET 9

#define LEFT_EDGE_ORIGIN 0x81	/* empirical value */
d24 2
a25 3
#ifdef ALIASING
#define MODE_OFFSET \
( (vp->Modes & SUPERHIRES)? -4: ((vp->Modes & HIRES)? 0: 4) )
d27 1
a27 18
#define MODE_OFFSET \
( (vp->Modes & SUPERHIRES)? -2: ((vp->Modes & HIRES)? 0: 4) )
#endif

#define DENISE_TO_AGNUS(x) \
{ (x) -= DENISE_OFFSET; (x) >>= 1; (x) -= MODE_OFFSET; }

#define AGNUS_TO_DENISE(x) \
{ (x) += MODE_OFFSET; (x) <<= 1; (x) += DENISE_OFFSET; }

#define NORMALIZE_PIXELS(x) \
{ if ((vp->Modes & HIRES)||(vp->Modes & SUPERHIRES)) (x) >>= 1; \
  if (vp->Modes & SUPERHIRES) (x) >>= 1; }

#define SCALE_PIXELS(x) \
{ if ((vp->Modes & HIRES)||(vp->Modes & SUPERHIRES)) (x) <<= 1; \
  if (vp->Modes & SUPERHIRES) (x) <<= 1; }

d30 1
a30 36
#define SCROLLMASK 0x000F	/* maximum granularity of display scroll */
#define FETCH_MASK 0xFFF8  	/* maximum granularity of agnus datafetch */
#define DATAFETCH_MIN 0x18 	/* minimum agnus position for hard datafetch */
#define DATAFETCH_MAX 0xD7 	/* maximum agnus position of hard datafetch */

#define MINCLIP(a,b) (vpe?(MAX((a),(b))):(a))
#define MAXCLIP(a,b) (vpe?(MIN((a),(b))):(a))

#define MINXCLIP(x) (clip?(MAX((x),(cliposcan.MinX))):(x))
#define MINYCLIP(y) (clip?(MAX((y),(MAX(0,(cliposcan.MinY-vp->DyOffset))))):(y))
#define MAXXCLIP(x) (clip?(MIN((x),(cliposcan.MaxX))):(x))
#define MAXYCLIP(y) (clip?(MIN((y),MAX(0,((cliposcan.MaxY+1)-vp->DyOffset)))):(y))

#include "gs_info.h"

#ifdef CLIPPING

struct DisplayInfoRecord *get_vprecord(vp)
struct ViewPort *vp;
{
    struct ColorMap 			*cm = vp->ColorMap;
    struct DisplayInfoRecord   	*record = NULL;

    if((cm && cm->Type)
    &&((record = cm->CoerceDisplayInfo) || (record = cm->NormalDisplayInfo)));

    return(record);
}


getclipstuff(v,vp,ri,gs,yclip)
short yclip;
struct View *v;
struct ViewPort *vp;
struct RasInfo *ri;
register struct gs_info *gs;
d32 22
a53 70
    struct GfxBase *GB;
    struct ViewExtra *ve = 0;
    struct MonitorSpec *mspc = 0;
    struct ColorMap *cm = vp->ColorMap;		/* colormap attached? */
    struct ViewPortExtra *vpe = 0;
    short clip = 0;				/* clip region valid ? */
    short vdx  = (vp->ExtendedModes & VPF_A2024)?
		 ((vp->ExtendedModes & VPF_TENHZ)? 0x81-16: 0x81) :
		 v->DxOffset; 			/* view dxoffset */
    short vpdx = vp->DxOffset;			/* viewport dxoffset */
    short vpdy = vp->DyOffset;			/* viewport dyoffset */
    short vpdw = vp->DWidth;			/* viewport width */
    short vlbd;					/* viewport lower bound */
    short ridx = ri->RxOffset;			/* rasinfo dxoffset */
    short ridy = ri->RyOffset;			/* rasinfo dyoffset */
    short rbytes = ri->BitMap->BytesPerRow;	/* bitmap bytesperrow */
    short hmin;					/* hardware minimum datafetch */
    short hmax;					/* hardware maximum datafetch */
    short xmin;					/* graphics minimum clock */
    short xmax;					/* graphics maximum clock */
    short mask;					/* scroll mask */
    short dmin;					/* displayclip MinXoffset */
    short dmax;					/* displayclip MaxXoffset */
    short dcdw;					/* displayclip width */
    short dcdx;					/* displayclip dxoffset */
    short exdx;					/* extra vpdx */
    short ecdx;					/* extra displayclip */
    short mcdx;					/* mask clip */
    short hcdx;					/* hardware clip */
    short dfdx;					/* fetch clip */
    short rcdx, orig_rcdx;		/* rasinfo clip */
    short pixx;					/* pixel position of start */
    short vscroll;				/* viewport scroll */
    short rscroll;				/* rasinfo scroll */
    long  sbytes;				/* skip bytesperrow */
    long  skip;					/* skip total */
    short dfstrt;				/* display fetch start */
    short dfstop = 0;			/* display fetch stop */
    short dwstrt;				/* display window start */
    short dwstop;				/* display window stop */
    short dwdw;					/* displaywindow width */
    short yxtra;			    /* displaywindow extra */
    ULONG modes;				/* local modes */
	struct Rectangle cliposcan; /* local displayclip */
#ifdef CLIPOSCAN
	struct DisplayInfoRecord     * record = get_vprecord(vp);
#endif

    modes = new_mode(vp);

    FETCHGBASE;

    mspc = GB->default_monitor;

    if (v->Modes & EXTEND_VSTRUCT)
    {
	if((ve = (struct ViewExtra *) gfxlookup(v)) && ve->Monitor)
	{
	    mspc = ve->Monitor;
	}
    }

#ifdef PROTOTYPE_DISPLAY


    /* new mode processing */

    if( mspc->ms_Flags & REQUEST_A2024)
    {
	switch( modes )
d55 2
a56 20
	    case( A2024TENHERTZ_KEY ):
	    {
		vdx = 0x81-16;
	    }   break;
	    case( A2024FIFTEENHERTZ_KEY ):
	    {
		vdx = 0x81;
	    } 	break;
	    default:
	    {
	    }	break;
	}
    }

#endif

    if( ((cm) && (cm->Type) && (vpe = cm->cm_vpe)) 
    /* ||  (vpe = gfxlookup(vp)) */ )   /* re-examined this algorithm */
    {
		if(((ULONG)(vpe->DisplayClip.MaxX)-(ULONG)(vpe->DisplayClip.MinX)))
d58 2
a59 19
			clip = ~0; 			/* use optional clip region */

#ifdef CLIPOSCAN
			if( record )
			{
				cliposcan.MinX = 
					SHORTMAX(record->rec_ClipOScan.MinX,vpe->DisplayClip.MinX);
				cliposcan.MinY = 
					SHORTMAX(record->rec_ClipOScan.MinY,vpe->DisplayClip.MinY);
				cliposcan.MaxX = 
					SHORTMIN(record->rec_ClipOScan.MaxX,vpe->DisplayClip.MaxX);
				cliposcan.MaxY = 
					SHORTMIN(record->rec_ClipOScan.MaxY,vpe->DisplayClip.MaxY);
			}
			else
#endif
			{
				cliposcan = vpe->DisplayClip;
			}
a60 102
    }

    xmin = mspc->DeniseMinDisplayColumn; /* first displayable */
 
    SCALE_PIXELS(xmin);			/* minimum display position */

    mask = SCROLLMASK; 			/* scroll mask on 16 bit boundaries */

    mcdx = FETCH_MASK;			/* maximum fetch granularity */
    NORMALIZE_PIXELS(mcdx);		/* ajust fetch mask for mode */

    dmin = MINXCLIP( (short)(0x80 << ((sizeof(short)-1)<<3)));
    dmax = MAXXCLIP(~(short)(0x80 << ((sizeof(short)-1)<<3)));
    dcdw = dmax - dmin + 1;

#ifdef ALIASING
    MODE_NORMALIZE(vpdx);		/* scale viewport offset to common */
    MODE_NORMALIZE(dmin);		/* scale displayclip offset to common */
    MODE_NORMALIZE(dmax);		/* scale displayclip offset to common */
#endif
    SCALE_PIXELS(vdx);			/* scale view offset to common coords */
    vlbd = vdx+vpdx;			/* initialize viewport lower bound */

    NORMALIZE_PIXELS(vpdx);
    NORMALIZE_PIXELS(dmin);

    dcdx = MINCLIP(vpdx,dmin);		/* clipped vpdx */ 
    exdx = SHORTMAX(0,(dcdx-vpdx)); 	/* extra vpdx */ 
    orig_rcdx = rcdx = ridx + exdx;		 	/* display offset into the raster */
#ifdef SAS_DEBUG
	kprintf("\nridx = %ld, exdx = %ld, rcdx = %ld\n",ridx, exdx, rcdx);
#endif
    SCALE_PIXELS(dcdx);			/* scale clipped vpoffset */
    SCALE_PIXELS(rcdx);			/* scale display offset */
#ifdef SAS_DEBUG
	kprintf("rcdx after SCALE_PIXELS = %ld\n", rcdx);
#endif

    pixx = vdx + dcdx;			/* leftmost pixel position */

    ecdx = SHORTMAX(0,(xmin - pixx)); 	/* extra clip left minimum bound */

    pixx += ecdx;			/* proposed display window start */
    rcdx += ecdx;			/* adjusted by extra clip offset */
#ifdef	SAS_DEBUG
	kprintf("ecdx = %ld, rcdx = %ld\n",ecdx,rcdx);
#endif

    yxtra = MINYCLIP(0);		/* skip lines due to displayclip */

    if(!clip) 
    {
	yxtra = (((mspc->min_row-v->DyOffset)<<((modes&LACE)?1:0))-vp->DyOffset);
	yxtra = MAX(0,yxtra); 		/* also for non-clipped 1.3 cases */
    }

    yxtra &= ((modes     & LACE) ? (~1): (~0));	 /* align extra for mode */

    sbytes = smuls(rbytes,yxtra); 		 /* skip for displayclip */

    yxtra = MAX(0,yxtra+yclip);   	    	/* bound below maximum extra */

    if(yclip)
    {
	yclip = -yclip;
	yclip += 1;				/* rounding */
	yclip >>= ((modes     & LACE) ? (~1): (~0));  /* adjust clip for lace */
	sbytes += smuls(rbytes,yclip);   /* adjust for top clip */
    }

    sbytes += smuls(rbytes,ridy); 	/* skip words due to ri->DyOffset */

    skip = rcdx & (~mask);		/* masked offset into raster */
	skip >>= 3;
	if ((modes & (HIRES|DUALPF)) == (HIRES|DUALPF))
	{
		skip >>= 1;
		rcdx = (orig_rcdx & ~1);
	}
/*	else
	{
		skip >>= 3;
	}	*/			/* spence - Dec  2 1990 */

#ifdef SAS_DEBUG
	kprintf("*\nrcdx = %lx, ~mask = %lx, skip = ((rcdx & ((~mask)<<1))>>3) = %lx\n", rcdx, (~mask), skip);
#endif

#ifdef ALIASING
    MODE_SCALE(skip);
#endif
    skip += sbytes;			/* total skip bytes */
#ifdef SAS_DEBUG
	kprintf("*\nsbytes = %lx, skip += sbytes = %lx\n", sbytes, skip);
#endif

    dwstrt = LEFT_EDGE_ORIGIN;		/* empirical value */ 
    DENISE_TO_AGNUS(dwstrt);		/* rationalize offset */
    HFIX(dwstrt);			/* rationalize offset */
    dwstrt &= mcdx;
    AGNUS_TO_DENISE (dwstrt);		/* rationalize offset */
    SCALE_PIXELS(dwstrt);		/* scale extra offset */
d62 1
a62 24
#ifdef SAS_DEBUG
	kprintf("BEFORE\ndwstrt = %ld\nrscroll = %ld\nvscroll = %ld\n",dwstrt, rscroll, vscroll);
	kprintf("pixx = %ld\nmask = %ld\nrcdx = %ld\n",pixx, mask, rcdx);
#endif

    pixx -= dwstrt;			/* translate start position to origin */

    rscroll = mask & (-rcdx);		/* rastport scroll position */

    vscroll = (mask & pixx) + rscroll;	/* viewport scroll position */

    if (vscroll > mask)      		/* sum exceeds hardware limits */
    {
	vscroll &= mask;
	pixx -= ((mask+1) - (rscroll));	 /* adjust left edge at clipstop */
	/* rscroll = 0; */
    }
    else
    {
	if (rscroll)	  		/* rastport scroll is handled here */
	{
	    pixx -= ((mask+1) - (rscroll)); /* adjust left edge at clipstop */
	}
    }
d64 2
a65 1
    dwstrt += pixx; 			/* actual display window start */
d67 1
a67 7
    dfstrt = dwstrt; 			/* calculations for fetch */

    if (pixx < 0)
    {
	if (rcdx)	  		/* displayclip extra is handled here */
	{
	    dwstrt += (mask & rcdx);
d72 1
a72 189
	if (rscroll)			/* ... as is rasinfo->dxoffset */
	{
	    dwstrt += (mask & rcdx);
	}
    }
#ifdef SAS_DEBUG
	kprintf("AFTER\ndwstrt = %ld\nrscroll = %ld\nvscroll = %ld\n",dwstrt, rscroll, vscroll);
	kprintf("pixx = %ld\nmask = %ld\nrcdx = %ld\n",pixx, mask, rcdx);
#endif

    dwdw = MAX(0,(MAXCLIP(vpdw+exdx,dcdw))); /* display clip */

#ifdef ALIASING
    MODE_NORMALIZE(dwdw);		/* adjust width for special mode */
    MODE_NORMALIZE(mask);		/* adjust mask for special mode */
#endif

    dwdw -= ((ecdx & (~mask)) & (mask | (~SCROLLMASK))); /* bounds clip */

    /* dfstop = dfstrt + dwdw;*/	/* reflect agnus limitations */

#ifdef ALIASING
    MODE_NORMALIZE(vpdw);		/* adjust viewport width for mode */
#endif

    dwstop = MIN(MIN(dwstrt+dwdw,vlbd+vpdw),(vdx+dmax+1));  /* actual stop */

    NORMALIZE_PIXELS(dwstrt);
    NORMALIZE_PIXELS(dfstrt);
    /* NORMALIZE_PIXELS(dfstop); */	/* computed directly below */
    NORMALIZE_PIXELS(dwdw);
    NORMALIZE_PIXELS(mask);

    NORMALIZE_PIXELS(rscroll);
    NORMALIZE_PIXELS(vscroll);
    
    hmin = DATAFETCH_MIN; 	
    hmin &= mcdx;			/* mask least significant bits */

    DENISE_TO_AGNUS(dfstrt);
    /* DENISE_TO_AGNUS(dfstop); */	/* computed directly below */

    dfstrt &= mcdx;			/* mask least significant bits */

    hcdx = SHORTMAX(0,(hmin - dfstrt)); /* hardware clip left minimum bound */
    dfstrt += hcdx;
    SCALE_PIXELS(hcdx);

    skip += ( (hcdx & (~(mask>>1))) >> 2 ); /* adjust skip for hcdx */
#ifdef SAS_DEBUG
	kprintf("*\nhcdx = %lx, mask = %lx, ( (hcdx & (~(mask>>1))) >> 2 ) = %lx, skip += %lx\n", hcdx, mask, ( (hcdx & (~(mask>>1))) >> 2 ), skip);
#endif
    dfdx = SHORTMAX(0,(dfstrt & ~FETCH_MASK)); 

	/* let's do the nonECS-denise fudging here */
    if (!(GB->ChipRevBits0 & GFXF_HR_DENISE))
    {
    	int oscanw;
		if (modes & HIRES)
		{
			oscanw = 713;
		}
		else
		{		/* must be LORES */
			oscanw = 327;
		/* if we are overscanned to the LHS of the screen, we'll lose 2 pixels unless... */
			if ((pixx <= -34) && (pixx > -48) && ((vscroll - 1) >= 7)) 	/* happens to be the numbers to look for (from debug printouts) */
			{
#ifdef SAS_DEBUG
	kprintf("fudging skip = %lx, dfstrt = %lx, dfstop = %lx\n", skip, dfstrt, dfstop);
#endif
				skip -= 2;
				dfstrt -= 4;
				dfstop -= 4;	/* fudge, fudge, fudge to fix Denise h/w problem */
			}
		}
		if ((vpe) && ((vpe->DisplayClip.MaxX - vpe->DisplayClip.MinX) < oscanw))
			dfdx = 0;  /* compatibility for non-oscanned screens - spence Mar 21 1991 */
	}

    dfstrt -= dfdx;
    SCALE_PIXELS(dfdx);

    skip -= ( (dfdx  & (~(mask>>1))) >> 2 ); /* try to align on best boundary */
#ifdef SAS_DEBUG
	kprintf("*\ndfdx = %lx, mask = %lx, ( (dfdx & (~(mask>>1))) >> 2 ) = %lx, skip -= %lx\n", dfdx, mask, ( (dfdx & (~(mask>>1))) >> 2 ), skip);
#endif

    /* bart -- dfstop is to be interpereted as a lower bound for the
       last sequence of fetches on this scan line.  the last of the
       fetches MUST occur before the last colorclock on this line. */

    hmax =  COLORCLOCKS - GRANULARITY;
    hmax -= (((hmax-(dfstrt+2))+1)%GRANULARITY);
    hmax &= ~1;

    NORMALIZE_PIXELS(dwstop);

    xmax = hmax + GRANULARITY;
    AGNUS_TO_DENISE(xmax);

    if (dwstop > xmax) dwstop = xmax;	/* maximum stop */

    /* bart - dfstop can be computed directly from dwstrt, dwstop and 
       dfstrt.  first, determine the number of lores pixels you to
       display and convert to the least number of color clocks which
       will display those pixels. next, add those colorclocks to the
       dfstrt position which must already have been aligned to a legal 
       position. next, make sure that granularity restrictions are
       respected. this gives an upper bound to fetches to display 
       all desired pixels. last, convert this upper bound to a lower
       bound final dfstop which reflects the value that will respect 
       such an upper bound 
    */

    dfstop = dfstrt + (MAX(((dwstop - dwstrt) + 1),0) >> 1);
    dfstop = (dfstop + (GRANULARITY - 1)) & (~(GRANULARITY - 1));
    dfstop -= ((dfstrt) & (GRANULARITY - 1)) & mcdx; 

    if (dfstop > hmax) dfstop = hmax;

    gs->dafstrt = dfstrt;		/* pass information to caller */
    gs->dafstop = dfstop;
    gs->scroll = vscroll;
    gs->rbytes = rbytes;
    gs->plnskip = skip;
    gs->dw = dwstop - dwstrt;
    gs->dwxstrt = dwstrt;
    gs->yxtra = yxtra;

#ifdef SAS_DEBUG
	GB->Debug = 0xf0;
#define	BARTDEBUG
#endif

#ifdef BARTDEBUG
    if((UBYTE)GB->Debug & (UBYTE)0x80)
    {
	kprintf("v    = %lx\n", v);
	kprintf("vp   = %lx\n", vp);
	kprintf("ri   = %lx\n", ri);
	kprintf("gs   = %lx\n", gs);
	kprintf("yclip = %lx\n", yclip);

	if((UBYTE)GB->Debug & (UBYTE)0x70)
	{
	    kprintf("-----  variables  ---------\n");
	    kprintf("vdx  = %lx\n", vdx);
	    kprintf("vpdx = %lx\n", vpdx);
	    kprintf("vpdy = %lx\n", vpdy);
	    kprintf("vpdw = %lx\n", vpdw);
	    kprintf("vlbd = %lx\n", vlbd);
	    kprintf("ridx = %lx\n", ridx);
	    kprintf("ridy = %lx\n", ridy);
	    kprintf("hmin = %lx\n", hmin);
	    kprintf("hmax = %lx\n", hmax);
	    kprintf("xmin = %lx\n", xmin);
	    kprintf("xmax = %lx\n", xmax);
	    kprintf("dmin = %lx\n", dmin);
	    kprintf("dmax = %lx\n", dmax);
	    kprintf("dcdw = %lx\n", dcdw);
	    kprintf("dcdx = %lx\n", dcdx);
	    kprintf("exdx = %lx\n", exdx);
	    kprintf("ecdx = %lx\n", ecdx);
	    kprintf("dwdw = %lx\n", dwdw);
	    kprintf("mcdx = %lx\n", mcdx);
	    kprintf("hcdx = %lx\n", hcdx);
	    kprintf("dfdx = %lx\n", dfdx);
	    kprintf("mask = %lx\n", mask);
	    kprintf("pixx = %lx\n", pixx);
	    kprintf("rcdx = %lx\n", rcdx);
	    kprintf("vscroll = %lx\n", vscroll);
	    kprintf("rscroll = %lx\n", rscroll);
	    kprintf("sbytes = %lx\n", sbytes);
	    kprintf("skip = %lx\n", skip);
	    kprintf("dfstrt = %lx\n", dfstrt);
	    kprintf("dfstop = %lx\n", dfstop);
	    kprintf("dwstrt = %lx\n", dwstrt);
	    kprintf("dwstop = %lx\n", dwstop);
	}
	kprintf("----- mygetstuff ---------\n");
	kprintf("gs->dafstrt = %lx\n", dfstrt);
	kprintf("gs->dafstop = %lx\n", dfstop);
	kprintf("gs->scroll  = %lx\n", vscroll);
	kprintf("gs->rbytes  = %lx\n", rbytes);
	kprintf("gs->plnskip = %lx\n", skip);
	kprintf("gs->dw      = %lx\n", dwstop-dwstrt);
	kprintf("gs->dwxstrt = %lx\n", dwstrt);
	kprintf("gs->yxtra = %lx\n", gs->yxtra);
a73 2
#endif

a74 2
#endif

@


37.7
log
@added #include of protos file
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 1.1 91/05/20 10:39:37 chrisg Exp $
@


37.6
log
@ changed "../" to "/" for native build
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 37.5 91/04/26 16:25:26 spence Exp Locker: chrisg $
d23 2
@


37.5
log
@enforcer on (vpe->) in old-Denise overscan stuff.
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 37.4 91/04/15 14:03:56 spence Exp Locker: spence $
d11 1
a11 1
#include "../displayinfo_internal.h"
d18 1
a18 1
#include "../macros.h"
d21 1
a21 1
#include "../displayinfo_internal.h"
@


37.4
log
@more nonECSDenise OScan fudging.
NB - in some positions (LORES, maximum oscan on LHS, bplcon1 <= 7), lose
the LHS 2 pixels again. But, previous fix was completely trashing.
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 37.3 91/03/28 20:31:34 spence Exp Locker: spence $
d476 1
a476 1
		if ((vpe->DisplayClip.MaxX - vpe->DisplayClip.MinX) < oscanw)
@


37.3
log
@old-denise overscan fudging
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 37.2 91/03/14 18:46:20 spence Exp Locker: spence $
d466 1
a466 1
			if (pixx <= -34) 	/* happens to be the number to look for (from debug printouts) */
d468 3
@


37.2
log
@Fixed rhs early clipping with old denise.
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 37.1 91/01/30 17:15:31 bart Exp Locker: spence $
d184 1
a184 1
    short dfstop;				/* display fetch stop */
d454 22
a475 3
	/* took this line out - broke overscan screens with old Denise by clipping
	   too early at the RHS of the display... - spence Mar 14 1991 */
    /*if (!(GB->ChipRevBits0 & GFXF_HR_DENISE)) dfdx = 0;*/ /* compatibility */
@


37.1
log
@coplist fixes for compatibility
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 37.0 91/01/07 15:18:31 spence Exp $
d454 3
a456 1
    if (!(GB->ChipRevBits0 & GFXF_HR_DENISE)) dfdx = 0; /* compatibility */
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 36.57 90/12/02 12:36:45 spence Exp Locker: spence $
d119 1
a119 1
#define MINYCLIP(y) (clip?(MAX((y),MAX(0,(cliposcan.MinY-vp->DyOffset)))):(y))
d306 1
d308 6
@


36.57
log
@dualpf corrections now only used on DUALPF viewports.
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 36.56 90/11/16 16:31:29 spence Exp Locker: spence $
@


36.56
log
@Fixed problem with vp scrolling hires screens (with RasInfo->RxOffset). It
was scrolling twice as many pixels as it should.
@
text
@d3 1
a3 1
*	$Id: clipstuff.c,v 36.55 90/07/27 16:55:26 bart Exp Locker: spence $
d325 10
a334 1
	skip >>= ((modes & HIRES)? 4 : 3);	/* spence - Nov 16 1990 */
a354 2
	if (modes & HIRES)
		rcdx = (orig_rcdx & ~1);	/* spence - Nov 14 1990*/
@


36.55
log
@id
@
text
@d3 1
a3 1
*	$Id: $
d24 1
d31 2
a32 2
#define HFIX(x)	{ x = ((x)*mspc->ratioh) >> 4; }
#define VFIX(x)	{ x = ((x)*mspc->ratiov) >> 4; }
d177 1
a177 1
    short rcdx;					/* rasinfo clip */
d287 4
a290 1
    rcdx = ridx + exdx;		 	/* display offset into the raster */
d293 3
d303 3
a305 1

d325 1
a325 1
    skip >>= 3; 			/* convert to byte offset */
d327 4
d335 3
d346 7
d391 4
d435 3
a437 1

d446 3
d491 5
@


36.54
log
@graphics36.139 -- cliposcan back in
@
text
@d3 1
a3 1
*	$Header: /usr2/bart/v1.4/src/kickstart/working/graphics/c/RCS/clipstuff.c,v 36.53 90/04/11 16:45:22 bart Exp Locker: bart $
@


36.53
log
@undefined CLIPOSCAN for beta 5 -- broken, bart
@
text
@d3 1
a3 1
*	$Header: /usr2/bart/v1.4/src/kickstart/working/graphics/c/RCS/clipstuff.c,v 36.52 90/04/06 18:30:54 bart Exp Locker: bart $
d7 1
a7 1
/* #define CLIPOSCAN -- broken, bart */
@


36.52
log
@removed kprintf oops
@
text
@d3 1
a3 1
*	$Header: /usr2/bart/v1.4/src/kickstart/working/graphics/c/RCS/clipstuff.c,v 36.51 90/04/06 18:20:29 bart Exp Locker: bart $
d7 1
a7 1
#define CLIPOSCAN
@


36.51
log
@cliposcan
@
text
@d3 1
a3 1
*	$Header: /usr2/bart/v1.4/src/kickstart/working/graphics/c/RCS/clipstuff.c,v 36.50 90/03/28 09:13:15 bart Exp Locker: bart $
a250 3

				kprintf("clipstuff: %08lx %08lx %08lx %08lx\n",
				cliposcan.MinX,cliposcan.MinY,cliposcan.MaxX,cliposcan.MaxY);
@


36.50
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/graphics/c/RCS/clipstuff.c,v 36.49 89/04/29 15:41:23 bart Exp Locker: bart $
d7 2
d20 4
d117 4
a120 4
#define MINXCLIP(x) (clip?(MAX((x),(vpe->DisplayClip.MinX))):(x))
#define MINYCLIP(y) (clip?(MAX((y),MAX(0,(vpe->DisplayClip.MinY-vp->DyOffset)))):(y))
#define MAXXCLIP(x) (clip?(MIN((x),(vpe->DisplayClip.MaxX))):(x))
#define MAXYCLIP(y) (clip?(MIN((y),MAX(0,((vpe->DisplayClip.MaxY+1)-vp->DyOffset)))):(y))
d125 14
d187 6
a192 2
    short yxtra;			        /* displaywindow extra */
    ULONG  modes = new_mode(vp);		/* local modes */
d194 2
d236 25
a260 4
	if(((ULONG)(vpe->DisplayClip.MaxX)-(ULONG)(vpe->DisplayClip.MinX)))
	{
	    clip = ~0; 			/* use optional clip region */
	}
@


36.49
log
@cm->Type checking
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.48 89/02/24 09:42:56 bart Exp $
@


36.48
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.48 89/02/22 13:07:22 bart Exp $
d129 1
d172 2
d176 1
a176 2
	ve = (struct ViewExtra *) gfxlookup(v);
	if(ve)
a181 5
    if(!mspc)
    {
	mspc = GB->default_monitor;
    }

d207 2
a208 3
    /* need to re-examine this algorithm later for speed considerations */

    if((vp->ColorMap && (vpe = vp->ColorMap->cm_vpe)) || (vpe = gfxlookup(vp)))
@


36.47
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.46 89/02/15 16:45:38 bart Exp $
d194 1
a194 1
	    case( A2024_10HZ_KEY ):
d198 1
a198 1
	    case( A2024_15HZ_KEY ):
@


36.46
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.45 89/02/15 16:07:05 bart Exp $
@


36.45
log
@displayinfo_internal
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.44 89/02/14 18:22:00 bart Exp $
d9 1
a186 1
#include "../displayinfo_internal.h"
@


36.44
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.43 89/02/14 10:11:44 bart Exp $
d186 1
a186 1
#include <display/defines.h>
@


36.43
log
@checkpoint 02.14.89
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.42 89/02/01 17:52:01 bart Exp $
d186 1
a186 1
#include <display/modes.h>
d194 1
a194 1
	    case( STD_MODE_14 ):
d198 1
a198 1
	    case( STD_MODE_15 ):
@


36.42
log
@checkpoint -- a2024 10hz and 15hz scan works from 32 bit id
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.41 89/02/01 17:40:01 bart Exp $
@


36.41
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.40 89/02/01 14:23:17 bart Exp $
@


36.40
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.39 89/02/01 14:05:18 bart Exp $
a191 1
	kprintf("clipstuff: mspc->ms_Flags & REQUEST_A2024\n");
a195 1
		kprintf("clipstuff: vdx == 0x81-16\n");
a199 1
		kprintf("clipstuff: vdx == 0x81\n");
@


36.39
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.38 89/02/01 14:02:49 bart Exp $
d192 1
d197 1
d199 1
a199 1
	    }
d202 1
@


36.38
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.37 89/01/31 15:38:26 bart Exp $
d184 4
d189 1
a189 1
#ifdef PROTOTYPE_DISPLAY
d207 1
@


36.37
log
@checkpoint 2024
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.36 89/01/26 11:06:18 bart Exp $
d183 21
@


36.36
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.35 89/01/26 11:04:36 bart Exp $
@


36.35
log
@vp->ColorMap->cm_vpe
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.34 89/01/24 15:37:33 bart Exp $
d190 1
a190 1
	    clip= ~0; 			/* use optional clip region */
@


36.34
log
@checkpoint 01.24.89
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.33 89/01/19 17:27:46 bart Exp $
d110 4
a113 4
#define MINXCLIP(x) (vpe?(MAX((x),(vpe->DisplayClip.MinX))):(x))
#define MINYCLIP(y) (vpe?(MAX((y),MAX(0,(vpe->DisplayClip.MinY-vp->DyOffset)))):(y))
#define MAXXCLIP(x) (vpe?(MIN((x),(vpe->DisplayClip.MaxX))):(x))
#define MAXYCLIP(y) (vpe?(MIN((y),MAX(0,((vpe->DisplayClip.MaxY+1)-vp->DyOffset)))):(y))
d129 1
d184 3
a186 1
    if (vp->Modes & EXTEND_VPSTRUCT)
d188 4
a191 1
	vpe = (struct ViewPortExtra *) gfxlookup(vp);
@


36.33
log
@checkpoint 01.19.89 coercion down to default
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.32 89/01/18 13:53:52 bart Exp $
@


36.32
log
@checkpoint 01.18.89
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.31 89/01/17 15:59:58 bart Exp $
@


36.31
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.30 88/10/17 15:08:28 bart Exp $
d26 4
d32 36
d100 2
d165 1
a165 1
    ULONG  modes = map_mode(vp->Modes);		/* local modes */
d183 1
a183 1
    if (modes     & EXTEND_VPSTRUCT)
@


36.30
log
@default monitorspec guaranteed to exist ... optimise
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.29 88/10/10 15:59:20 bart Exp $
d123 1
d141 1
a141 1
    if (vp->Modes & EXTEND_VPSTRUCT)
d185 1
a185 1
    yxtra &= ((vp->Modes & LACE) ? (~1): (~0));	 /* align extra for mode */
d195 1
a195 1
	yclip >>= ((vp->Modes & LACE) ? (~1): (~0));  /* adjust clip for lace */
@


36.29
log
@incorporate rasinfo->dxoffset into displayclip extra handling...
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.28 88/10/06 13:54:02 bart Exp $
d20 1
a20 1
#define COLORCLOCKS (mspc ? mspc->total_colorclocks : STANDARD_COLORCLOCKS)
d23 2
a24 2
#define HFIX(x)	{ if (mspc) x = ((x)*mspc->ratioh) >> 4; }
#define VFIX(x)	{ if (mspc) x = ((x)*mspc->ratiov) >> 4; }
d145 1
a145 8
    if (mspc)
    {
	xmin = mspc->DeniseMinDisplayColumn; /* first displayable */
    }
    else
    {
	xmin = STANDARD_DENISE_MIN;
    }
@


36.28
log
@long sbytes, skip to prevent overflow for new, bigger viewports
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.27 88/10/05 15:24:05 bart Exp $
d248 1
a248 1
	if (exdx)	  		/* displayclip extra is handled here */
d250 1
a250 3
	    SCALE_PIXELS(exdx);
	    dwstrt += (mask & exdx);
	    NORMALIZE_PIXELS(exdx);
d255 1
a255 1
	if (rscroll)
d257 1
a257 3
	    SCALE_PIXELS(exdx);
	    dwstrt += (mask & exdx);
	    NORMALIZE_PIXELS(exdx);
@


36.27
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.26 88/10/05 13:23:53 bart Exp $
d115 2
a116 2
    short sbytes;				/* skip bytesperrow */
    short skip;					/* skip total */
@


36.26
log
@interperet v->dxoffset if a2024 for now
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.25 88/10/04 18:34:41 bart Exp $
d89 1
a89 1
		 view->DxOffset; 		/* view dxoffset */
@


36.25
log
@adjust yclip for lace
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.24 88/09/21 17:06:06 bart Exp $
d87 3
a89 2
    short vdx  = v->DxOffset; 			/* view dxoffset */
    short vdy  = v->DyOffset;			/* view dyoffset */
a368 1
	    kprintf("vdy  = %lx\n", vdy);
@


36.24
log
@MAXYCLIP consistent with makevp.c
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.23 88/09/16 01:05:58 bart Exp $
d194 1
a194 1
    if (yclip) sbytes -= smuls(rbytes,yclip); 	  /* adjust for top clip */
d196 7
a202 1
    yxtra = MAX(0,yxtra+yclip);   	    /* bound below maximum extra */
@


36.23
log
@checkpoint for alpha 14 release
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.22 88/09/15 23:57:47 bart Exp $
d71 1
a71 1
#define MAXYCLIP(y) (vpe?(MIN((y),MIN(0,(vpe->DisplayClip.MaxY-vp->DyOffset)))):(y))
@


36.22
log
@yxtra
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.21 88/09/14 17:56:14 bart Exp $
d18 1
d26 8
d38 1
d40 3
d44 1
d121 1
a121 1
    short yxtra;                                /* displaywindow extra */
d164 5
d189 1
d192 1
a192 2
    sbytes -= smuls(rbytes, yclip-yextra); 	     /* adjust for clips */
    sbytes += smuls(rbytes, ridy);     /* skip words due to ri->DyOffset */
d194 2
d198 2
d203 3
d224 2
a225 1
	pixx -= ((mask+1) - rscroll);	 /* adjust left edge at clipstop */
d229 1
a229 1
	if (rscroll)	  		 /* rastport scroll is handled here */
d231 1
a231 1
	    pixx -= ((mask+1) - rscroll); /* adjust left edge at clipstop */
d239 1
a239 1
    if (pixx < 0)			/* displayclip extra is handled here */
d241 1
a241 1
	if (exdx)	  
d248 1
a248 1
    else 			
d250 1
a250 1
	if (rscroll && exdx)
d260 5
d267 6
d277 1
d280 2
d288 1
d403 1
a403 1
	kprintf("gs->yxtra   = %lx\n", yxtra);
@


36.21
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.20 88/09/14 16:48:24 bart Exp $
d107 1
d169 2
a170 2
    sbytes = smuls(rbytes,MINYCLIP(ridy)); /* skip words due to ri->DyOffset */
    if (yclip) sbytes -= smuls(rbytes,yclip); 	      /* adjust for top clip */
d172 5
d305 1
d361 1
@


36.20
log
@if (rscroll && exdx) displayclip extra is handled
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.19 88/09/13 17:02:00 bart Exp $
a17 1
/* #define ALIASING */  /* agnus 8372-1 and above don't alias anymore -- bart */
a24 8
#ifdef ALIASING
#define MODE_NORMALIZE(x) \
{ if (vp->Modes & SUPERHIRES) (x) >>= 1; }

#define MODE_SCALE(x) \
{ if (vp->Modes & SUPERHIRES) (x) <<= 1; }
#endif

a28 1
#ifdef ALIASING
a29 3
( (vp->Modes & SUPERHIRES)? -4: ((vp->Modes & HIRES)? 0: 4) )
#else
#define MODE_OFFSET \
a30 1
#endif
a148 5
#ifdef ALIASING
    MODE_NORMALIZE(vpdx);		/* scale viewport offset to common */
    MODE_NORMALIZE(dmin);		/* scale displayclip offset to common */
    MODE_NORMALIZE(dmax);		/* scale displayclip offset to common */
#endif
a173 3
#ifdef ALIASING
    MODE_SCALE(skip);
#endif
d192 1
a192 1
	rscroll = 0;
d194 1
a194 2

    if (rscroll)	  		/* rastport scroll is handled here */
d196 4
a199 1
	pixx -= ((mask+1) - rscroll);	/* adjust left edge at clipstop */
a226 5
#ifdef ALIASING
    MODE_NORMALIZE(dwdw);		/* adjust width for special mode */
    MODE_NORMALIZE(mask);		/* adjust mask for special mode */
#endif

a228 6
    /* dfstop = dfstrt + dwdw;*/	/* reflect agnus limitations */

#ifdef ALIASING
    MODE_NORMALIZE(vpdw);		/* adjust viewport width for mode */
#endif

a232 1
    /* NORMALIZE_PIXELS(dfstop); */	/* computed directly below */
a234 2

    NORMALIZE_PIXELS(rscroll);
a240 1
    /* DENISE_TO_AGNUS(dfstop); */	/* computed directly below */
@


36.19
log
@videoscan() processing and denise backwards compatibility
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.18 88/09/12 12:12:26 bart Exp $
d226 1
a226 1
    if (pixx < 0)
d228 10
a237 1
	if (exdx)	  		/* displayclip extra is handled here */
@


36.18
log
@dfdx
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.17 88/09/11 13:59:58 bart Exp $
a145 1
	xmax = mspc->DeniseMaxDisplayColumn; /* last  displayable */
a149 1
	xmax = STANDARD_DENISE_MAX;
a152 1
    SCALE_PIXELS(xmax);			/* maximum display position */
a252 2
    if (dwstop > xmax) dwstop = xmax;	/* maximum stop */

a253 1
    NORMALIZE_PIXELS(dwstop);
d274 1
a274 1
    skip += ( (hcdx & (~(mask>>1))) >> 2 ); 	/* adjust skip for hcdx */
d276 4
a279 1
    dfdx = SHORTMAX(0,(dfstrt & ~FETCH_MASK));	/* align on best boundary */
d283 1
a283 1
    skip -= ( (dfdx  & (~(mask>>1))) >> 2 ); 	/* adjust skip for dfdx */
a284 15
#ifdef ALIASING
    if ((~mask) & (SCROLLMASK>>1))	/* scroll can alias */
    {
	dfstrt -= mask+1;
	skip -= 2;

	if (vscroll & (~mask))		/* scroll is aliasing  */
	{
	    dfstrt += mask+1;
	    skip += 2;
	}
	vscroll &= mask;
    }
#endif

d292 7
@


36.17
log
@vp->Modes & SUPERHIRES
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.16 88/08/12 13:19:05 bart Exp $
d109 1
d280 1
a280 1
    skip += ( (hcdx & (~(mask>>1))) >> 2 ); /* adjust skip for hcdx */
d282 6
d370 1
@


36.16
log
@mspc->DeniseMinDisplayColumn
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.15 88/09/01 13:58:34 bart Exp $
a19 2
#define VP_SUPER_HIRES 0x80	/* temporary define */

d28 1
a28 1
{ if (vp->ExtendedModes & VP_SUPER_HIRES) (x) >>= 1; }
d31 1
a31 1
{ if (vp->ExtendedModes & VP_SUPER_HIRES) (x) <<= 1; }
d40 1
a40 1
( (vp->ExtendedModes & VP_SUPER_HIRES)? -4: ((vp->Modes & HIRES)? 0: 4) )
d43 1
a43 1
( (vp->ExtendedModes & VP_SUPER_HIRES)? -2: ((vp->Modes & HIRES)? 0: 4) )
d53 2
a54 2
{ if ((vp->Modes & HIRES)||(vp->ExtendedModes & VP_SUPER_HIRES)) (x) >>= 1; \
  if (vp->ExtendedModes & VP_SUPER_HIRES) (x) >>= 1; }
d57 2
a58 2
{ if ((vp->Modes & HIRES)||(vp->ExtendedModes & VP_SUPER_HIRES)) (x) <<= 1; \
  if (vp->ExtendedModes & VP_SUPER_HIRES) (x) <<= 1; }
@


36.15
log
@hmax reflects the state machine better now
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.14 88/09/01 11:17:29 bart Exp $
a65 2
#define WINDOW_MIN 0x3C 	/* minimum denise position of window start */
#define WINDOW_MAX 0x1C7	/* maximum denise position of window stop */
a143 5
    xmin = GB->MinDisplayColumn; 		
    xmin = MAX(xmin,WINDOW_MIN);

    SCALE_PIXELS(xmin);			/* minimum display position */

d146 2
a147 1
	xmax = mspc->DeniseMaxDisplayColumn; /* last displayable */
d151 1
d155 1
d158 1
a158 1
    mask = 0x000F; 			/* scroll mask on 16 bit boundaries */
d335 6
@


36.14
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.13 88/09/01 10:52:37 bart Exp $
d303 2
a304 7
       last sequence of fetches on this scan line.  the actual beginning 
       of the last sequence of fetches is related to the dfstrt position
       by the relation (((begin - dfstrt) % GRANULARITY) == 0) and the
       sequence continues for GRANULARITY colorclocks.  the last of the
       sequence of fetches MUST occur before the last colorclock on this
       scan line. 
    */
d306 3
a308 2
    hmax = ((COLORCLOCKS - GRANULARITY) & (~(GRANULARITY - 1))); 	
    hmax -= ((dfstrt) & (GRANULARITY - 1)) & mcdx; 
@


36.13
log
@xmax = mspc->DeniseMaxDisplayColumn;
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.12 88/08/31 12:47:31 bart Exp $
d153 1
a153 1
	xmax = mspc->DeniseMaxDisplayColumn;
@


36.12
log
@superhires datafetch start position is now mod 2 for 8372-1 agnus
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.11 88/08/31 12:21:52 bart Exp $
a150 2
    xmax = GB->MaxDisplayColumn; 		

d153 1
a153 1
	xmax = MIN(xmax,(mspc->total_colorclocks <<1 ) + 3);
d157 1
a157 1
	xmax = MIN(xmax,WINDOW_MAX);
@


36.11
log
@BEGIN SUPPORT OF AGNUS 8372-1 3488 2350
checkpoint before changes to superhires horizontal ddfstrt resolution
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.10 88/07/29 14:16:00 bart Exp $
d18 1
d28 1
d30 1
a30 1
{ if (vp->ExtendedModes & VP_SUPER_HIRES) { (x) >>= 1; } }
d34 1
d40 1
d43 4
d55 2
a56 1
{ if ((vp->Modes & HIRES)||(vp->ExtendedModes & VP_SUPER_HIRES)) (x) >>= 1; };
d59 2
a60 1
{ if ((vp->Modes & HIRES)||(vp->ExtendedModes & VP_SUPER_HIRES)) (x) <<= 1; };
d173 1
d177 1
d184 2
a185 2
    dcdx = MINCLIP(vpdx,dmin);		/* clipped vpdx */
    exdx = SHORTMAX(0,(dcdx-vpdx)); 	/* extra vpdx */
a186 1

d203 1
d205 1
d248 1
d251 1
d257 1
d259 1
d289 1
d302 1
@


36.10
log
@fix "off by one" bug...
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.9 88/07/26 18:00:54 bart Exp $
@


36.9
log
@undefine BARTDEBUG
@
text
@d3 1
a3 1
*	$Header: clipstuff.c,v 36.8 88/07/26 14:07:04 bart Exp $
d161 1
a161 1
    dcdw = dmax - dmin;
d244 1
a244 1
    dwstop = MIN(MIN(dwstrt+dwdw,vlbd+vpdw),(vdx+dmax));  /* actual stop */
@


36.8
log
@if (pixx < 0) 
@
text
@d3 1
a3 3
*	Source Control
*	--------------
*	$Header: clipstuff.c,v 36.7 88/07/25 14:21:55 bart Exp $
a4 28
*	$Locker: bart $
*
*	$Log:	clipstuff.c,v $
*   Revision 36.7  88/07/25  14:21:55  bart
*   default_monitorspec
*   
*   Revision 36.6  88/07/23  17:07:26  bart
*   monitorspec -- bart 07.23.88 merge source
*   
*   Revision 36.5  88/06/23  18:00:58  bart
*   adjust for top clip
*   
*   Revision 36.4  88/05/21  17:37:58  bart
*   smooth scrolling of displayclip regions in lores, hires, and superhires.
*   
*   Revision 36.3  88/06/16  15:28:12  bart
*   adjust viewport offset for mode
*   
*   Revision 36.2  88/06/14  16:39:20  bart
*   scroll in doublescan modes
*   
*   Revision 36.1  88/06/10  11:55:37  bart
*   *** empty log message ***
*   
*   Revision 36.0  88/06/10  11:51:15  bart
*   added to rcs for updating
*   
*
d17 1
a17 1
#define BARTDEBUG
@


36.7
log
@default_monitorspec
@
text
@d5 1
a5 1
*	$Header: clipstuff.c,v 36.6 88/07/23 17:07:26 bart Exp $
d10 3
d47 1
a47 1
/* #define BARTDEBUG */
d253 1
a253 1
    if (exdx)	  			/* displayclip extra is handled here */
d255 6
a260 3
	SCALE_PIXELS(exdx);
	dwstrt += (mask & exdx);
	NORMALIZE_PIXELS(exdx);
@


36.6
log
@monitorspec -- bart 07.23.88 merge source
@
text
@d5 1
a5 1
*	$Header: clipstuff.c,v 36.5 88/06/23 18:00:58 bart Exp $
d10 3
d44 1
a44 1
#define BARTDEBUG
d151 5
@


36.5
log
@adjust for top clip
@
text
@d5 1
a5 1
*	$Header: clipstuff.c,v 36.4 88/05/21 17:37:58 bart Exp $
d10 3
d38 1
d41 1
a41 1
/* #define BARTDEBUG */
d45 2
a46 2
#define HFIX(x)	{ if (ve) x = ((x)*ve->ratioh) >> 4; }
#define VFIX(x)	{ if (ve) x = ((x)*ve->ratiov) >> 4; }
d48 3
d103 1
d144 4
d162 1
a162 1
    if (ve)
d164 1
a164 1
	xmax = MIN(xmax,(ve->total_colorclocks <<1 ) + 3);
d170 1
a170 1

d206 1
a206 1
    if (yclip) sbytes -= smuls(rbytes,yclip);         /* adjust for top clip */
d256 1
a256 1
    dfstop = dfstrt + dwdw;		/* reflect agnus limitations */
d267 1
a267 1
    NORMALIZE_PIXELS(dfstop);
d278 1
a278 1
    DENISE_TO_AGNUS(dfstop);
d290 1
a290 1
	dfstrt -= mask+1; 
a291 1
    }
d293 5
a297 2
    if (vscroll & (~mask))		/* scroll is aliasing  */
    {
a298 1
	skip -= 2;
d301 8
a308 8
    hmax = DATAFETCH_MAX; 	
    hmax &= mcdx; 	
    hmax -= MODE_OFFSET;
    AGNUS_TO_DENISE(hmax);
    HFIX(hmax);
    DENISE_TO_AGNUS(hmax);
    hmax += MODE_OFFSET;
    hmax &= mcdx;			/* mask least significant bits */
d310 19
d342 1
a342 1
	if((UBYTE)GB->Debug == (UBYTE)0xFF)
@


36.4
log
@smooth scrolling of displayclip regions in lores, hires, and superhires.
@
text
@d5 1
a5 1
*	$Header: clipstuff.c,v 36.3 88/06/16 15:28:12 bart Exp $
d10 3
d194 1
a194 1
    if (yclip) sbytes -= smuls(rbytes,MINYCLIP(yclip)); /* subtract top clip */
@


36.3
log
@adjust viewport offset for mode
@
text
@d5 1
a5 1
*	$Header: clipstuff.c,v 36.2 88/06/14 16:39:20 bart Exp $
d10 3
d109 1
d164 2
a165 1
    dcdw = MAXXCLIP(~(short)(0x80 << ((sizeof(short)-1)<<3))) - dmin;
d167 3
a170 1
    MODE_NORMALIZE(vpdx);		/* adjust viewport offset for mode */
d173 1
a174 1
    NORMALIZE_PIXELS(vpdx);
d225 9
d238 1
d241 2
a243 1
    dwstop = MIN(dwstrt+dwdw,vlbd+vpdw);    /* actual display window stop */
d245 1
a245 1
    if (dwstop > xmax) dwstop = xmax;
d247 1
a247 2
    dfstrt = dwstrt; 			/* calculations for fetch */
    dfstop = dfstrt + dwdw;		/* reflect agnus limitations */
d323 1
@


36.2
log
@scroll in doublescan modes
@
text
@d5 1
a5 1
*	$Header: clipstuff.c,v 36.1 88/06/10 11:55:37 bart Exp $
d10 3
d163 1
@


36.1
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: clipstuff.c,v 36.0 88/06/10 11:51:15 bart Exp $
d10 3
d61 1
a61 1
#define FETCH_MASK 0xFFFC  	/* maximum granularity of agnus datafetch */
d153 3
d191 1
d239 1
a239 1
    hmin &= FETCH_MASK;			/* mask least significant bits */
d244 1
a244 3
    dfstrt &= FETCH_MASK;		/* mask least significant bits */
    mcdx = (mask >> 1) & FETCH_MASK; 	/* clip offset due to mode */
    dfstrt -= mcdx; 			/* adjust down to fetch boundaries */
d265 1
a265 1
    hmax &= FETCH_MASK;			/* mask least significant bits */
d271 1
a271 2
    hmax &= FETCH_MASK;			/* mask least significant bits */
    hmax -= mcdx;			/* which have no effect on fetch */
d280 1
a280 1
    gs->dw = dwstop-dwstrt;
d284 46
a329 39
    kprintf("-----  variables  ---------\n");
    kprintf("vdx  = %lx\n", vdx);
    kprintf("vdy  = %lx\n", vdy);
    kprintf("vpdx = %lx\n", vpdx);
    kprintf("vpdy = %lx\n", vpdy);
    kprintf("vpdw = %lx\n", vpdw);
    kprintf("vlbd = %lx\n", vlbd);
    kprintf("ridx = %lx\n", ridx);
    kprintf("ridy = %lx\n", ridy);
    kprintf("hmin = %lx\n", hmin);
    kprintf("hmax = %lx\n", hmax);
    kprintf("xmin = %lx\n", xmin);
    kprintf("xmax = %lx\n", xmax);
    kprintf("dmin = %lx\n", dmin);
    kprintf("dcdw = %lx\n", dcdw);
    kprintf("dcdx = %lx\n", dcdx);
    kprintf("exdx = %lx\n", exdx);
    kprintf("ecdx = %lx\n", ecdx);
    kprintf("mcdx = %lx\n", mcdx);
    kprintf("hcdx = %lx\n", hcdx);
    kprintf("mask = %lx\n", mask);
    kprintf("pixx = %lx\n", pixx);
    kprintf("rcdx = %lx\n", rcdx);
    kprintf("vscroll = %lx\n", vscroll);
    kprintf("rscroll = %lx\n", rscroll);
    kprintf("sbytes = %lx\n", sbytes);
    kprintf("skip = %lx\n", skip);
    kprintf("dfstrt = %lx\n", dfstrt);
    kprintf("dfstop = %lx\n", dfstop);
    kprintf("dwstrt = %lx\n", dwstrt);
    kprintf("dwstop = %lx\n", dwstop);
    kprintf("----- mygetstuff ---------\n");
    kprintf("gs->dafstrt = %lx\n", dfstrt);
    kprintf("gs->dafstop = %lx\n", dfstop);
    kprintf("gs->scroll  = %lx\n", vscroll);
    kprintf("gs->rbytes  = %lx\n", rbytes);
    kprintf("gs->plnskip = %lx\n", skip);
    kprintf("gs->dw      = %lx\n", dwstrt-dwstop);
    kprintf("gs->dwxstrt = %lx\n", dwstrt);
@


36.0
log
@added to rcs for updating
@
text
@d5 1
a5 1
*	$Header: $
d7 1
a7 1
*	$Locker: $
d9 4
a12 1
*	$Log: $
d74 1
d322 1
@
