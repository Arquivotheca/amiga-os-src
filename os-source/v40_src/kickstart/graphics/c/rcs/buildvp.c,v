head     39.75;
branch   ;
access   ;
symbols  rel39_24:39.75 rel39_18:39.75 rel39_97:39.65 rel39_90:39.64 rel39_89:39.63 rel39_82:39.61 rel39_76:39.58 rel39_71:39.55 rel39_65:39.48 rel39_64:39.46 rel39_61:39.46 rel39_60:39.46 rel39_55:39.41 rel39_47:39.37 rel39_39:39.33 rel39_38:39.33 rel39_37:39.32 rel39_35:39.30 rel39_34:39.30;
locks    ; strict;
comment  @ * @;


39.75
date     93.04.15.16.15.29;  author spence;  state Exp;
branches ;
next     39.74;

39.74
date     93.03.29.11.19.52;  author spence;  state Exp;
branches ;
next     39.73;

39.73
date     93.03.26.13.42.40;  author spence;  state Exp;
branches ;
next     39.72;

39.72
date     93.03.12.12.55.43;  author chrisg;  state Exp;
branches ;
next     39.71;

39.71
date     93.02.25.17.44.04;  author spence;  state Exp;
branches ;
next     39.70;

39.70
date     93.02.22.10.15.37;  author spence;  state Exp;
branches ;
next     39.69;

39.69
date     93.02.11.08.26.13;  author chrisg;  state Exp;
branches ;
next     39.68;

39.68
date     92.12.09.13.41.27;  author spence;  state Exp;
branches ;
next     39.67;

39.67
date     92.11.23.16.58.20;  author spence;  state Exp;
branches ;
next     39.66;

39.66
date     92.11.23.16.22.59;  author spence;  state Exp;
branches ;
next     39.65;

39.65
date     92.10.30.16.12.26;  author spence;  state Exp;
branches ;
next     39.64;

39.64
date     92.09.18.14.34.54;  author spence;  state Exp;
branches ;
next     39.63;

39.63
date     92.08.27.14.30.25;  author spence;  state Exp;
branches ;
next     39.62;

39.62
date     92.08.20.13.36.30;  author spence;  state Exp;
branches ;
next     39.61;

39.61
date     92.08.17.16.47.05;  author spence;  state Exp;
branches ;
next     39.60;

39.60
date     92.08.11.13.58.39;  author spence;  state Exp;
branches ;
next     39.59;

39.59
date     92.08.06.11.25.44;  author spence;  state Exp;
branches ;
next     39.58;

39.58
date     92.07.24.12.00.50;  author spence;  state Exp;
branches ;
next     39.57;

39.57
date     92.07.21.14.34.06;  author spence;  state Exp;
branches ;
next     39.56;

39.56
date     92.07.09.12.02.51;  author spence;  state Exp;
branches ;
next     39.55;

39.55
date     92.07.01.10.51.34;  author chrisg;  state Exp;
branches ;
next     39.54;

39.54
date     92.06.30.18.14.15;  author spence;  state Exp;
branches ;
next     39.53;

39.53
date     92.06.30.16.41.50;  author spence;  state Exp;
branches ;
next     39.52;

39.52
date     92.06.29.13.48.04;  author spence;  state Exp;
branches ;
next     39.51;

39.51
date     92.06.23.14.10.17;  author spence;  state Exp;
branches ;
next     39.50;

39.50
date     92.06.19.12.12.18;  author spence;  state Exp;
branches ;
next     39.49;

39.49
date     92.06.11.10.31.58;  author spence;  state Exp;
branches ;
next     39.48;

39.48
date     92.06.09.10.51.07;  author spence;  state Exp;
branches ;
next     39.47;

39.47
date     92.06.08.15.56.52;  author spence;  state Exp;
branches ;
next     39.46;

39.46
date     92.05.15.07.25.35;  author spence;  state Exp;
branches ;
next     39.45;

39.45
date     92.05.13.11.16.06;  author spence;  state Exp;
branches ;
next     39.44;

39.44
date     92.05.05.15.03.02;  author spence;  state Exp;
branches ;
next     39.43;

39.43
date     92.05.05.14.50.30;  author spence;  state Exp;
branches ;
next     39.42;

39.42
date     92.05.05.11.31.45;  author spence;  state Exp;
branches ;
next     39.41;

39.41
date     92.04.27.11.53.52;  author spence;  state Exp;
branches ;
next     39.40;

39.40
date     92.04.16.16.47.00;  author spence;  state Exp;
branches ;
next     39.39;

39.39
date     92.04.14.11.20.10;  author spence;  state Exp;
branches ;
next     39.38;

39.38
date     92.04.04.17.30.56;  author spence;  state Exp;
branches ;
next     39.37;

39.37
date     92.04.03.10.56.08;  author spence;  state Exp;
branches ;
next     39.36;

39.36
date     92.03.24.16.47.22;  author spence;  state Exp;
branches ;
next     39.35;

39.35
date     92.03.18.15.58.36;  author spence;  state Exp;
branches ;
next     39.34;

39.34
date     92.03.13.15.41.23;  author spence;  state Exp;
branches ;
next     39.33;

39.33
date     92.02.28.13.38.56;  author spence;  state Exp;
branches ;
next     39.32;

39.32
date     92.02.26.11.33.37;  author spence;  state Exp;
branches ;
next     39.31;

39.31
date     92.02.25.14.22.52;  author spence;  state Exp;
branches ;
next     39.30;

39.30
date     92.02.11.11.08.52;  author spence;  state Exp;
branches ;
next     39.29;

39.29
date     92.01.30.20.02.20;  author spence;  state Exp;
branches ;
next     39.28;

39.28
date     92.01.29.16.36.28;  author spence;  state Exp;
branches ;
next     39.27;

39.27
date     92.01.22.16.19.13;  author spence;  state Exp;
branches ;
next     39.26;

39.26
date     92.01.21.13.18.59;  author chrisg;  state Exp;
branches ;
next     39.25;

39.25
date     91.12.31.14.27.45;  author spence;  state Exp;
branches ;
next     39.24;

39.24
date     91.12.20.15.43.48;  author spence;  state Exp;
branches ;
next     39.23;

39.23
date     91.11.25.15.53.42;  author spence;  state Exp;
branches ;
next     39.22;

39.22
date     91.11.18.11.24.38;  author spence;  state Exp;
branches ;
next     39.21;

39.21
date     91.11.15.10.49.44;  author spence;  state Exp;
branches ;
next     39.20;

39.20
date     91.11.11.17.08.56;  author chrisg;  state Exp;
branches ;
next     39.19;

39.19
date     91.11.11.11.46.52;  author chrisg;  state Exp;
branches ;
next     39.18;

39.18
date     91.11.08.11.34.04;  author spence;  state Exp;
branches ;
next     39.17;

39.17
date     91.10.30.19.15.08;  author spence;  state Exp;
branches ;
next     39.16;

39.16
date     91.10.29.11.31.54;  author spence;  state Exp;
branches ;
next     39.15;

39.15
date     91.10.28.17.06.51;  author spence;  state Exp;
branches ;
next     39.14;

39.14
date     91.10.18.16.23.28;  author spence;  state Exp;
branches ;
next     39.13;

39.13
date     91.10.17.13.59.09;  author chrisg;  state Exp;
branches ;
next     39.12;

39.12
date     91.10.16.17.22.56;  author spence;  state Exp;
branches ;
next     39.11;

39.11
date     91.10.16.14.05.22;  author chrisg;  state Exp;
branches ;
next     39.10;

39.10
date     91.10.15.16.01.23;  author spence;  state Exp;
branches ;
next     39.9;

39.9
date     91.10.04.12.20.01;  author chrisg;  state Exp;
branches ;
next     39.8;

39.8
date     91.09.27.11.14.58;  author spence;  state Exp;
branches ;
next     39.7;

39.7
date     91.09.23.10.55.30;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     91.09.01.16.53.50;  author spence;  state Exp;
branches ;
next     39.5;

39.5
date     91.09.01.14.59.54;  author spence;  state Exp;
branches ;
next     39.4;

39.4
date     91.08.29.15.00.57;  author spence;  state Exp;
branches ;
next     39.3;

39.3
date     91.08.29.11.25.44;  author spence;  state Exp;
branches ;
next     39.2;

39.2
date     91.08.27.17.56.08;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     91.08.27.16.29.44;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.14.38;  author chrisg;  state Exp;
branches ;
next     38.10;

38.10
date     91.08.21.16.45.17;  author spence;  state Exp;
branches ;
next     38.9;

38.9
date     91.08.21.13.47.30;  author spence;  state Exp;
branches ;
next     38.8;

38.8
date     91.07.27.16.49.52;  author spence;  state Exp;
branches ;
next     38.7;

38.7
date     91.07.22.14.54.32;  author spence;  state Exp;
branches ;
next     38.6;

38.6
date     91.07.09.18.02.18;  author spence;  state Exp;
branches ;
next     38.5;

38.5
date     91.07.08.13.46.48;  author spence;  state Exp;
branches ;
next     38.4;

38.4
date     91.07.02.20.05.49;  author spence;  state Exp;
branches ;
next     38.3;

38.3
date     91.06.24.14.43.13;  author spence;  state Exp;
branches ;
next     38.2;

38.2
date     91.06.19.13.13.53;  author spence;  state Exp;
branches ;
next     38.1;

38.1
date     91.06.14.11.49.38;  author spence;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.05.13.19.54;  author spence;  state Exp;
branches ;
next     ;


desc
@Series of drivers to build the ViewPort intermediate copperlists.
@


39.75
log
@Improved the calculation of the number of intermediate copper instructions
allocated for AA screens.
@
text
@/******************************************************************************
*
*	$Id: buildvp.c,v 39.74 93/03/29 11:19:52 spence Exp Locker: spence $
*
******************************************************************************/

#define ECS_SPECIFIC		/* for custom.h */

	#include <hardware/custom.h>
	#include "/copper.h"
	#include "/displayinfo.h"
	#include "/displayinfo_internal.h"
	#include "/view.h"
	#include "/vp_internal.h"
	#include "/monitor.h"
	#include "/macros.h"
	#include "/gfxbase.h"
	#include "/gfx.h"
	#include "/gfxpragmas.h"
	#include "c.protos"
	#include <exec/memory.h>

extern struct Custom custom;
extern UWORD dflt_clrs[];

#define USEERR
/*#define USEFNCOUNT*/
#define USEGBDEBUG
/*#define DEBUG*/
/*#define BADFMODE*/
#define MAKEFMODE

/* Switches to enable chip bug-fixing code */
/* #define VBLANK_BUG - set in lmkfile */
/*#define H0_BUG*/
/*#define ALICE_RHS_BUG*/
#define ALICE_LHS_BUG

/* A possible fix that never got implemented ..... */
/* #define ALICE_LHS_WRAPAROUND */

#ifdef USEGBDEBUG
#define GBDEBUG if (GBASE->Debug)
#else
#define GBDEBUG
#endif

#ifdef DEBUG
#define D(x) {GBDEBUG {x};}
#define DG(x) {x}
#else
#define D(x)
#define DG(x)
#endif

#ifdef WACKDEBUG
#define WACK Debug()
#else
#define WACK
#endif

#ifdef USEFNCOUNT
#define INITERR ULONG  err = (bd->FnCount << 16);
#define INC_FNCOUNT {bd->FnCount++; D(kprintf("err = 0x%lx\n", err); WACK;)}
#else
#define INITERR ULONG err = 0;
#define INC_FNCOUNT
#endif

#ifdef USEERR
#define ERR(x) {err |= x;}
#define GOODERR {err = MVP_OK;}
#define RETERR err
#else
#define INC_FNCOUNT
#define INITERR
#define ERR(x)
#define GOODERR
#define RETERR (0)
#endif

#ifdef BADFMODE
#define FMODE io->pad3b[0]
#define FMODE2 io->fmode
#else
#define FMODE io->fmode
#endif

/* A Collection of routines needed to build the native Amiga display mode's
 * intermediate copper lists.
 *
 * All driver routines take a View, ViewPort and ViewPortExtra pointers as 
 * parameters. They all return a ULONG value. The upper word is the number of the
 * routine in the list in which the error occured, and the low word is
 * dependent on the function and the error.
 * A return of 0L is a GOOD return.
 *
 * These are defined in vp_internal.h
 */


/* InitMVP() - must be the 1st function to be called.
 * It takes a pointer to a pointer to a ViewPortExtra, because
 * if the vpe is NULL, create one, and set a flag to show it's creation. This
 * will be removed in the cleanup code.
 * This is the only function in the list that takes a pointer to the BuildData,
 * which will also be initialised. It also takes a pointer to the ProgInfo.
 */

ULONG InitMVP(struct View *v, struct ViewPort *vp, struct ViewPortExtra **vpe, struct ProgInfo *pinfo, struct BuildData *bd)
{
#ifdef BADFMODE
    struct Custom *io = &custom;
#endif
    struct ViewPortExtra *_vpe = *vpe;
    struct ColorMap *cm = vp->ColorMap;
    ULONG  err;
    UWORD  fmode;

    D(kprintf("In InitMVP()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, _vpe, pinfo);)
    D(kprintf("vpe->Flags = 0x%lx, vp->DWidth = 0x%lx, vp->DHeight = 0x%lx\n", (_vpe ? _vpe->Flags : 0), vp->DWidth, vp->DHeight);)
    D(kprintf("vp->DxOffset = 0x%lx vp->DyOffset = 0x%lx, v->DxOffset = 0x%lx, v->DyOffset = 0x%lx\n", vp->DxOffset, vp->DyOffset, v->DxOffset, v->DyOffset);)
    D(kprintf("RasInfo = 0x%lx, BitMap = 0x%lx\n", vp->RasInfo, vp->RasInfo->BitMap);)
    D(kprintf("bm->BytesPerRow = 0x%lx vp->Modes = 0x%lx\n", vp->RasInfo->BitMap->BytesPerRow, vp->Modes);)
    D(kprintf("new_mode(vp) = 0x%lx\n", new_mode(vp));)
    WACK;

    GOODERR
    if ((fmode = CalcFMode(vp)) == (UWORD) -1)
    {
    	err = MVP_NO_DISPLAY;
    }
    else
    {
	if (_vpe == NULL)
	{
		D(kprintf("_vpe == NULL\n");)
		if (_vpe = (struct ViewPortExtra *)gfx_GfxNew(VIEWPORT_EXTRA_TYPE))
		{
			D(kprintf("Allocated a new ViewPortExtra\n"); WACK;)
			_vpe->Flags = VPXF_FREE_ME;
			*vpe = _vpe;
			if ((cm) && (cm->Type))
			{
				cm->cm_vpe = _vpe;
			}
		}
		else
		{
			D(kprintf("GfxNew() failed\n");)
			err = MVP_NO_VPE;
		}		
	}
	if (err == MVP_OK)
	{
		struct ViewExtra *ve = NULL;

		/* initialise the BuildData structure */
		bd->bplcon0 = 0;
		bd->bplcon2 = get_bplcon2(cm);
		bd->bplcon3 = 0;
		bd->Flags = 0;
		bd->Offset = 0;
		bd->Offset2 = 0;
		bd->ToViewY = 0;
		bd->FMode = fmode;
		bd->Index = ((pinfo->ToViewX << GBASE->arraywidth) + fmode);
		bd->RHSFudge = bd->LHSFudge = FALSE;
		D(kprintf("fmode = 0x%lx\n", fmode);)

		if (v->Modes & EXTEND_VSTRUCT)
		{
			ve = (struct ViewExtra *)gfx_GfxLookUp(v);

		}
		if(ve && ve->Monitor)
		{
			bd->mspc = ve->Monitor;
		}
		else
		{
			bd->mspc = GBASE->natural_monitor;
		}

		if ((new_mode(vp) & (DOUBLESCAN | LACE)) == LACE)
		{
			bd->ToViewY = 1;
			bd->bplcon0 |= LACE;
			bd->Flags |= BD_IS_LACE;
		}
		/* Put the BuildData where it can be found */
		_vpe->DriverData[0] = (APTR)bd;
		bd->pinfo = pinfo;

		/* reset the origin offset (y component is currently untouched) */
		_vpe->Origin[0].x = _vpe->Origin[1].x = 0;
	}
    }

#ifdef BADFMODE
    io->copcon = 2;	/* turn on CDANG bit - what a fuck up */
#endif

    D(kprintf("Leaving InitMVP(), err = 0x%lx\n", err); WACK;);

    return(RETERR);
}

ULONG CleanUpMVP(DRIVER_PARAMS)
{
    D(kprintf("In CleanUpMVP()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\n", v, vp, vpe);)
    D(kprintf("vpe->Flags = 0x%lx\n", vpe->Flags); WACK;)

    if (vpe)
    {
	if (vpe->Flags & VPXF_FREE_ME)
	{
		/* The vpe was allocated on the fly, so free it */
		D(kprintf("Freeing Allocated VPE 0x%lx\n", vpe); WACK;)
		if ((vp->ColorMap) && (vp->ColorMap->Type))
		{
			vp->ColorMap->cm_vpe = NULL;
		}
		gfx_GfxFree((struct ExtendedNode *)vpe);
	}
    }

    D(kprintf("Leaving CleanUpMVP()\n");)
    return(MVP_OK);
}



/* All the following functions *MUST* be called with valid BuildData and ProgInfo
 * pointers, to reduce error-checking code
 */

#define VIDEOOSCAN_FUDGE 10	/* value from V37 MakeVPort(). */

ULONG CalcDispWindow(DRIVER_PARAMS)
{

    /* CalcDispWindow() calculates the DiwStrt/Stop values of this viewport.
     * It stores the values in ViewPort coordinate resolution.
     */

    struct DisplayInfoRecord *record;
    struct ColorMap *cm = vp->ColorMap;
    struct Rectangle *DClip = &vpe->DisplayClip;
    struct BuildData *bd = (struct BuildData *)vpe->DriverData[0];
    struct ProgInfo *pinfo = bd->pinfo;
    ULONG mode = gfx_GetVPModeID(vp);
    UWORD  clip;
    UWORD  ToViewX = pinfo->ToViewX;
    UWORD  ToViewY = bd->ToViewY;
    WORD   dxstrt, dxstop, dystrt, dystop, dwidth, dheight, vdx;
    INITERR

    D(kprintf("In CalcDispWindow()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx, mode = 0x%lx\n", v, vp, vpe, bd->pinfo, mode); WACK;);

    /* First, let's get the display clip area into cliposcan.
     * If there is no DisplayClip in the ViewPortExtra->DisplayClip, then we
     * don't do any clipping, else use the MAX/MIN of either Coerce or
     * Normal DClips and the vpe->DClip.
     *
     * The DisplayClips are set by the user and/or intuition with
     * VideoControl().
     */

    vdx = v->DxOffset;
    if ((mode >> 16) == 4)
    {
	if (mode == A2024TENHERTZ_KEY)
	{
		D(kprintf("10Hz mode. FMode = 0x%lx\n", bd->FMode);)
		dwidth = 352;
		vdx -= 16;
		/* alignments only allow for 1x in 10hz */
		bd->FMode = BANDWIDTH_1X;
	}
	else
	{
		dwidth = 512;
	}
	dheight = ((GBASE->DisplayFlags & PAL) ? 256 : 200);
	bd->Flags |= (BD_IS_A2024 | BD_IS_LACE);
    }
    else
    {
    	dwidth = vp->DWidth;
	dheight = vp->DHeight;
    }

    clip = ((DClip->MinX) | (DClip->MinY) |
            (DClip->MaxX) | (DClip->MaxY));	/* do we have a DClip? */

    if ((cm && cm->Type && clip) &&
	((record = cm->CoerceDisplayInfo) || (record = cm->NormalDisplayInfo)))
    {
	D(kprintf("Have a record = 0x%lx\n", record);)
	bd->cliposcan.MinX = 
		SHORTMAX(record->rec_ClipOScan.MinX,DClip->MinX);
	bd->cliposcan.MinY = 
		SHORTMAX(record->rec_ClipOScan.MinY,DClip->MinY);
	bd->cliposcan.MaxX = 
		SHORTMIN(record->rec_ClipOScan.MaxX,DClip->MaxX);
	bd->cliposcan.MaxY = 
		SHORTMIN(record->rec_ClipOScan.MaxY,DClip->MaxY);
    }
    else
    {
	/* clear the bd->cliposcan to the contents of vpe->DisplayClip, which
	 * may be all 0's.
	 */
	bd->cliposcan = vpe->DisplayClip;
    }


    /* Calculate the displaywindow values asked for */

    dxstrt = vp->DxOffset;
    dystrt = ((vp->DyOffset + ToViewY) & ~(ToViewY));
    dystop = (dystrt + dheight);

    /* Do we need to clip it?
     * Clipping is in ViewPort resolution.
     */

    if (clip)
    {
	D(kprintf("Clipping! cliposcan at 0x%lx\n", &bd->cliposcan);)
	D(kprintf("(0x%lx, 0x%lx) - (0x%lx, 0x%lx)\n", bd->cliposcan.MinX, bd->cliposcan.MinY, bd->cliposcan.MaxX, bd->cliposcan.MaxY);)
	D(kprintf("dxstrt = 0x%lx, dxstop = ????, dystrt = 0x%lx, dystop = 0x%lx\n", dxstrt, dystrt, dystop); WACK;)
	clip = 1;
	dxstrt = MAX(dxstrt, bd->cliposcan.MinX);
	dxstop = MIN((dxstrt + dwidth), (bd->cliposcan.MaxX + 1));	/* inclusive */
	dystrt = MAX(dystrt, bd->cliposcan.MinY);
    }
    else
    {
	dxstop = (dxstrt + dwidth);		/* vp->DWidth is in VP resolution */
    }
    dystop = MAX(dystrt, dystop);

    if ((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_SCANDBL)) == (PROGINFO_NATIVE | PROGINFO_SCANDBL))
    {
	bd->Flags |= BD_IS_SDBL;
	dystrt <<= 1;
	dystop <<= 1;
    }

    dxstrt += (vdx << ToViewX);
    dystrt += (v->DyOffset << ToViewY);
    dxstop += (vdx << ToViewX);
    dystop += (v->DyOffset << ToViewY);

    /* Now clip to the hardware limits. */
    {
	struct MonitorSpec *mspc = bd->mspc;
	WORD xdiff, ydiff;

	/* if we have a VideoOScan dclip, do some magical chip fudging. */
	if (dxstop > (mspc->DeniseMaxDisplayColumn << ToViewX))
	{
		bd->Flags |= BD_VIDEOOSCAN;
		bd->DiwStopX = dxstop;	/* keep this for other calculations */
		dxstop = (VIDEOOSCAN_FUDGE << ToViewX);
		if (!(GBASE->ChipRevBits0 & GFXF_HR_DENISE))
		{
			dxstop += (mspc->DeniseMaxDisplayColumn << ToViewX);
		}
	}
	else
	{
		bd->DiwStopX = dxstop;
	}
	/* There are (TOTROWS + 2) rows in every Long Frame. However, there is
	 * no sprite DMA fetches on the very last line (YACB), so we limit
	 * DiwStopY to (TOTROWS + 1).
	 */
	bd->DiwStopY = MIN(dystop, ((mspc->total_rows + 1) << ToViewY));
	bd->DiwStrtX = MAX(dxstrt, (xdiff = (mspc->DeniseMinDisplayColumn << ToViewX)));
	bd->DiwStrtY = MAX(dystrt, (ydiff = (mspc->min_row << ToViewY)));
	if (!clip)
	{
	    	/* create the clip values we need for later */
		xdiff = (dxstrt - xdiff);
		ydiff = (dystrt - ydiff);
    		bd->cliposcan.MinX = (vp->DxOffset - (MIN(0, xdiff)));
	    	bd->cliposcan.MinY = (vp->DyOffset - (MIN(0, ydiff)));
	}
#ifdef ALICE_LHS_WRAPAROUND
	if (GBASE->Bugs & BUG_ALICE_LHS)
	{
		/* mspc->ms_xoffset is the number of colour clocks I move
		 * the View to overcome the LHS scroll problem.
		 */
		UWORD xoffset = (/*bd->mspc->ms_xoffset*/8 << (ToViewX + 1));
		D(kprintf("xoffset = 0x%lx\n", xoffset);)
		bd->DiwStopX += xoffset;
	}
#endif
    }

#ifdef H0_BUG
    if ((GBASE->Bugs & BUG_H0) && (ToViewX == 2))
    {
	/* 35ns modes cannot be positioned on 35ns boundaries */
    	bd->DiwStrtX &= ~1;
    	bd->DiwStopX &= ~1;
    }
#endif

    /* Now calculate the actual DiwStopY values that get written into the
     * copper list. This also simplifies the ScrollVPort() code.
     */
    {
	UWORD diwstopl, diwstops, diff;
	if (!(vpe->Flags & VPXF_LAST))
	{
		bd->DiwStopY &= ~(ToViewY);
	}
	diff = ((bd->DiwStopY - bd->DiwStrtY) & ToViewY);
	diwstopl = diwstops = (((dxstop << pinfo->ToDIWResn) >> 2) & 0xff);
	diwstops |= ((((bd->DiwStopY >> ToViewY) + diff) & 0xff) << 8);
	diwstopl |= (((bd->DiwStopY >> ToViewY) & 0xff) << 8);
	bd->RGADiwStopYL = diwstopl;
	bd->RGADiwStopYS = diwstops;
    }

    /* one last check: make sure that the top of the ViewPort is not below
     * the last visible display line. If so, set a special error code.
     */
    if ((bd->DiwStrtY >> ToViewY) > bd->mspc->total_rows)
    {
	ERR(MVP_OFF_BOTTOM)
    }

    D(kprintf("Leaving CalcDispWindow()\n"); WACK;);
    D(kprintf("dxstrt = 0x%lx, dxstop = 0x%lx, dystrt = 0x%lx, dystop = 0x%lx\n", bd->DiwStrtX, bd->DiwStopX, bd->DiwStrtY, bd->DiwStopY); WACK;);

    INC_FNCOUNT;
    return(RETERR);
}

ULONG CalcADispWindow(DRIVER_PARAMS)
{

    /* CalcADispWindow() calculates the DiwStrt/Stop values of this viewport
     * for the single-A chip set.
     * It stores the values in ViewPort coordinate resolution.
     */

    struct BuildData *bd = (struct BuildData *)vpe->DriverData[0];
    struct MonitorSpec *mspc = bd->mspc;
    UWORD  ToViewY = bd->ToViewY;
    INITERR

    D(kprintf("In CalcADispWindow()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, bd->pinfo); WACK;);

    ERR(CalcDispWindow(v, vp, vpe));		/* Calc for ECS/AA */

    /* The differences between ECS/AA displaywindow values and A displaywindow
     * values is that A displaywindow is open for the maximum possible
     * height.
     */

    /* For 'A', bd->DiwStrtY is used to hold the line number to enable the 
     * display.
     *
     * Was: bd->DiwStrtY = (mspc->min_row << ToViewY); - Jun 30 1992
     */
    bd->DiwStopY = (mspc->total_rows << ToViewY);

    /* Now calculate the actual DiwStopY values that get written into the
     * copper list.
     */
    {
	UWORD diff;
	diff = ((bd->DiwStopY - bd->DiwStrtY) & ToViewY);
	bd->RGADiwStopYS &= 0xff;	/* clear away the Y pos */
	bd->RGADiwStopYS |= ((((bd->DiwStopY - diff) >> ToViewY) & 0xff) << 8);
	bd->RGADiwStopYL = bd->RGADiwStopYS;
    }

    D(kprintf("Leaving CalcADispWindow()\n"); WACK;);
    D(kprintf("dxstrt = 0x%lx, dxstop = 0x%lx, dystrt = 0x%lx, dystop = 0x%lx\n", bd->DiwStrtX, bd->DiwStopX, bd->DiwStrtY, bd->DiwStopY); WACK;);

    INC_FNCOUNT;
    return(RETERR);
}
    
#define FIRSTFETCH 0x18
#define DENISE_OFFSET 1		/* just 1/2 a colour-clock, but times 2 for integers */
#define DIWX_TO_CC(x) ((((x) >> ToViewX) - DENISE_OFFSET) >> 1)

/* This table is designed to be:
 * 1) correct
 * 2) compatible with older DDFSTRT values.
 */
UWORD  StrtFetchMasks[][] = 
{
    {0xfff8, 0xfff0, 0xfff0, 0xffe0},
    {0xfff8, 0xfff8, 0xfff8, 0xfff0},
    {0xfff8, 0xfff8, 0xfff8, 0xfff8}
};

UWORD  StopFetchMasks[][] = 
{
    {0xfff8, 0xfff0, 0xfff0, 0xffe0},
    {0xfff8, 0xfff8, 0xfff8, 0xfff0},
    {0xfff8, 0xfff8, 0xfff8, 0xfff8}
};

WORD Overrun[][] =	/* (-(Number of cycles in the pattern)) */
{
    {0xfff8, 0xfff0, 0xfff0, 0xffe0},
    {0xfffc, 0xfff8, 0xfff8, 0xfff0},
    {0xfffe, 0xfffc, 0xfffc, 0xfff8}
};

WORD RealStops[][] =	/* == the number of bitplane fetches per cycle */
{
    {8, 8, 8, 8},	/* Lores (2x and 4x are 16 and 32 cycles, but only 8 fetches) */
    {4, 8, 8, 8},	/* Hires (2x is really 16 cycles, but only 8 cycles) */
    {2, 4, 4, 8}	/* SHires */
};

ULONG CalcDataFetch(DRIVER_PARAMS)
{

    /* CalcDataFetch() calculates the DDFSTRT/STOP values for the defined
     * display window. At this stage, the Display Window values are in
     * ViewPort resolution coordinates.
     */

    struct BuildData *bd = (struct BuildData *)vpe->DriverData[0];
    struct ProgInfo *pinfo = bd->pinfo;
    WORD  ddfstrt, ddfstop;
    UWORD  realstop = GBASE->RealStops[bd->Index];
    UWORD  maskstrt;
    UWORD  pixels;
    UBYTE  ToViewX = pinfo->ToViewX;
    INITERR

    D(kprintf("In CalcDataFetch()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, bd->pinfo); WACK;)

    /* for ddfstrt, convert the displaywindow values to ColourClocks, and subtract 
     * the DENISE_OFFSET. ie
     *
     * ((((diwstrt >> (ToViewX + 1)) << 1) - DENISE_OFFSET) >> 1) & granularity, or
     *
     * (((diwstrt >> ToViewX) - DENISE_OFFSET) >> 1) & granularity.
     *
     * The granularity is 8 for old chips, or 4 for ECS and AA, though for
     * compatibility, keep to 8.
     * 
     */

    bd->Cycle = GBASE->StrtFetchMasks[bd->Index];
    maskstrt = (pinfo->DDFSTRTMask & bd->Cycle);
    bd->Cycle = -((WORD)bd->Cycle);
    D(kprintf("bd->Cycle = 0x%lx\n", bd->Cycle);)

    ddfstrt = ((((bd->FirstFetch = (DIWX_TO_CC(bd->DiwStrtX) - realstop)) - FIRSTFETCH) & maskstrt) + FIRSTFETCH);
    ddfstrt = MAX(FIRSTFETCH, ddfstrt);

    /* for ddfstop, calculate the number of cycles that are needed, and add it to
     * ddfstrt.
     */

    pixels = ((16 << GBASE->bwshifts[bd->FMode]) * ((realstop < 8) ? (bd->Cycle / realstop) : 1));
    ddfstop = (ddfstrt + (bd->Cycle * (((bd->DiwStopX - bd->DiwStrtX - 1) / pixels) + 1)));

    if (ddfstop >= (bd->mspc->total_colorclocks - realstop))
    {
    	D(kprintf("clipping ddfstop (= 0x%lx) to total_colorclocks (= 0x%lx)\n", ddfstop, bd->mspc->total_colorclocks); WACK;)
    	ddfstop = ((((bd->mspc->total_colorclocks - realstop - DENISE_OFFSET) - FIRSTFETCH) & maskstrt) + FIRSTFETCH);

	/* but in the case of narrow ViewPorts, it is quite possible that ddfstrt
	 * and ddfstop are now the same. This will not do! Easy solution - subtract
	 * a fetch cycle from ddfstrt.
	 * Caveat - on a 'A' machine which does not have fine display window control,
	 * this may cause the early fetch to be visible. But seeing as 'A' doesn't
	 * really work on ViewPorts narrower than 64 pixels, I don't see this as
	 * being a practical problem.
	 */
	 if (ddfstrt == ddfstop)
	 {
	 	ddfstrt -= bd->Cycle;
	 }
    }


    if ((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_VARBEAM)) == (PROGINFO_NATIVE | PROGINFO_VARBEAM))
    {
	bd->bplcon3 |= BPLCON3_EXTBLNKEN;
    }

    bd->DDFStrt = ddfstrt;
    bd->DDFStop = ddfstop;

    D(kprintf("Leaving CalcDataFetch\n"); WACK;);
    D(kprintf("ddfstrt = 0x%lx, ddfstop = 0x%lx\n", bd->DDFStrt, bd->DDFStop); WACK;);

    INC_FNCOUNT;
    return(RETERR);
}

#define SCROLLRESOLUTION (pinfo->ToViewX + (2 - GBASE->bwshifts[bd->FMode]))

ULONG CalcScroll(DRIVER_PARAMS)
{
    struct BuildData *bd = (struct BuildData *)vpe->DriverData[0];
    struct ProgInfo *pinfo = bd->pinfo;
    struct RasInfo *ri = vp->RasInfo;
    struct BitMap *bm;
    LONG   offset = 0;
    UWORD  diwstrt, datafetch;
    UWORD  resn, chunksize;
    UWORD  m;
    WORD   diff, shift;
    BOOL   needpre = FALSE;
    UBYTE  ToDIWResn = pinfo->ToDIWResn;

    INITERR

    if ((bd->Flags & BD_IS_DPF) && ri->Next)
    {
	ri = ri->Next;
    }
    bm = ri->BitMap;

    D(kprintf("In CalcScroll()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, bd->pinfo);)
    D(kprintf("DxOffset = 0x%lx, RxOffset = 0x%lx, DyOffset = 0x%lx, RyOffset = 0x%lx\n", vp->DxOffset, ri->RxOffset, vp->DyOffset, ri->RyOffset);)
    D(kprintf("bd->Flags = 0x%lx, vp->RasInfo = 0x%lx, ri = 0x%lx\n", bd->Flags, vp->RasInfo, ri); WACK;)

    if (bm)
    {
	m =(pinfo->Offset + GBASE->bwshifts[bd->FMode]);
	/* m is the cycle number:
	 * 0 = 2cycle,
	 * 1 = 4cycle, .....
	 * 4 = 32cycle.
	 */
#ifdef ALICE_RHS_BUG
	if ((GBASE->Bugs & BUG_ALICE_RHS) && (!(vpe->Flags & VPXF_LAST)))
	{
		bd->RHSFudge = TRUE;
	}
#endif
	/* convert the displaywindow coordinates to 35ns */
	diwstrt = (bd->DiwStrtX << ToDIWResn);

	/* now calculate the colourclock on which the last fetch of the
	 * first batch of fetches happens, and convert to 35ns.
	 *
	 * Note that for 16 and 32 cycles, the last fetch is the 8th cycle.
	 */
	datafetch = ((bd->DDFStrt + (2 << MIN(m, 2))) << 3);

	diff = diwstrt - datafetch - 4;	/* Remember the Denise delay */

	/* extra from vp and ri offsets, to 35ns */

	shift = (MIN(0, (vp->DxOffset - bd->cliposcan.MinX)) - ri->RxOffset) << ToDIWResn;	/* to 35ns */

	/* the scroll range, governed by the fetch cycle (32, 16, 8, 4, or 2) and
	 * the fmode.
	 */
	chunksize = SCROLLRESOLUTION;
	resn = (0x00ff >> chunksize) + 1;	/* scroll range for bplcon1 in 35ns */

	/* add it all together */
	diff += shift;
	if ((diff < 0) || (shift > 0))
	{
		needpre = TRUE;
	}
	D(kprintf("Shift = 0x%lx, resn = 0x%lx, diff = 0x%lx\n", shift, resn, diff); WACK;)

	/* shift now has the total number of 35ns pixels to scroll.
	 * How many whole bytes is this (in words)?
	 */

	offset += ((-diff / resn) << (1 + GBASE->bwshifts[bd->FMode]));
	diff += resn;
	diff &= (resn - 1);

	/* Do we need to prefetch? */
	if ((needpre) && (diff))
	{
		WORD prefetch = (pinfo->DDFSTRTMask & GBASE->StrtFetchMasks[bd->Index]);
		WORD realstop = GBASE->RealStops[bd->Index];
		D(kprintf("<<< Reducing ddfstrt for scroll from 0x%lx", bd->DDFStrt);)
		bd->DDFStrt += prefetch;
#ifdef ALICE_LHS_BUG
		/* Will need a better check than this for AA+ */
		if ((WORD)bd->DDFStrt < (WORD)FIRSTFETCH)
		{
			bd->DDFStrt = FIRSTFETCH;
			bd->LHSFudge = TRUE;
			/* Couldn't prefetch, so compensate the offset calculations */
			if (shift <= 0)
			{
				offset += (1 << (1 + GBASE->bwshifts[bd->FMode]));
			}
		}
		else
#endif
		{
			/* Is the difference between the new DDFSTRT and
			 * what it COULD be greater than a whole fetch cycle,
			 * or have we done some nasty scrolling with RxOffset?
			 */
			if ((realstop < 8) || (shift > 0))
			{
				/* Subtract (the number of words fetched per cycle *
				 * the number of whole cycles skipped).
				 */
				offset -= ((1 << (1 + GBASE->bwshifts[bd->FMode])) * 
				           (((-prefetch) >> realstop) + 1));
			}
		}
		D(kprintf(" to 0x%lx\n", bd->DDFStrt); WACK;)
	}

	/* add the vertical offset */
	offset -= (LONG)((MIN(0,(((vp->DyOffset + bd->ToViewY) & ~(bd->ToViewY)) - bd->cliposcan.MinY)) - ri->RyOffset) * bm->BytesPerRow);

	/* start on the correct boundary */
	offset &= (0xfffffffe << GBASE->bwshifts[bd->FMode]);

	bd->Offset = offset;
	bd->Scroll = diff;

    }
    else
    {
	bd->Offset = bd->Scroll = 0;
    }

    GOODERR

    D(kprintf("Leaving CalcScroll()\n"); WACK;);
    D(kprintf("scroll = 0x%lx\n", bd->Scroll); WACK;);
    D(kprintf("Offset = 0x%lx\n", bd->Offset); WACK;);

    INC_FNCOUNT;
    return(RETERR);

}


/* Fudge will detect the overscan cusp cases (h/w limitations), and alter the
 * FMode and everything else accordingly.
 */

#define HIRES4X ((pinfo->ToViewX == 1) && (fmode == BANDWIDTH_4X))
#define LORES4X ((pinfo->ToViewX == 0) && (fmode == BANDWIDTH_4X))
#define LORES2X ((pinfo->ToViewX == 0) && ((fmode == BANDWIDTH_2XNML) || (fmode == BANDWIDTH_2XDBL)))
#define VARBEAM35 ((pinfo->Flags & PROGINFO_VARBEAM) && (pinfo->ToViewX == 2) && (fmode))
#define VARBEAM70_140 ((pinfo->Flags & PROGINFO_VARBEAM) && (pinfo->ToViewX < 2))

ULONG Fudge(DRIVER_PARAMS)
{
    struct BuildData *bd = (struct BuildData *)vpe->DriverData[0];
    struct ProgInfo *pinfo = bd->pinfo;
    UWORD fmode = bd->FMode;
    UWORD cycles = bd->Cycle;
    BOOL lores4x = LORES4X;

    INITERR

    D(kprintf("In Fudge()\n"); WACK;)

    /* AA - We only need to fudge for Hires4x, Lores4x and Lores2x
     * when ddfstrt == FIRSTFETCH.
     */

#ifdef ALICE_LHS_BUG
    if ((bd->LHSFudge) && (!(pinfo->Flags & PROGINFO_VARBEAM)))
    {
	D(kprintf("LHS Fudging\n"); WACK;)

	if ((HIRES4X) && (bd->Scroll >= 0x70))
	{
		/* only in this certain range */
		D(kprintf("Hires 4x cusp case. Scroll = 0x%lx\n", bd->Scroll); WACK;)
		DG(struct Custom *io = &custom; io->color[0] = 0xf00;)
		fmode = BUS_32;	/* drop to 2x */
		cycles = 8;
	}
	if (lores4x && (bd->Scroll >= 0xf0))
	{
		D(kprintf("Lores 4x -> 1x. Scroll = 0x%lx\n", bd->Scroll); WACK;)
		DG(struct Custom *io = &custom; io->color[0] = 0x0f0;)
		fmode = BANDWIDTH_1X;
		cycles = 8;
	}
	if (lores4x && ((bd->Scroll >= 0x70) && (bd->Scroll < 0x80)))
	{
		D(kprintf("Lores 4x cusp case. Scroll = 0x%lx\n", bd->Scroll); WACK;)
		DG(struct Custom *io = &custom; io->color[0] = 0x0f0;)
		fmode = BANDWIDTH_1X;
		cycles = 8;
	}
	if (LORES2X && (bd->Scroll >= 0x70))
	{
		D(kprintf("Lores 2x cusp case. Scroll = 0x%lx\n\n", bd->Scroll); WACK;)
		DG(struct Custom *io = &custom; io->color[0] = 0x0f0;)
		fmode = BANDWIDTH_1X;
		cycles = 8;
	}
	if ((lores4x) && ((bd->Scroll >= 0x80) && (bd->Scroll < 0xf0)))
	{
		D(kprintf("Lores 4x -> 2x. Scroll = 0x%lx\n", bd->Scroll); WACK;)
		DG(struct Custom *io = &custom; io->color[0] = 0x00f;)
		fmode = BUS_32;
		cycles = 16;
	}
#ifdef COARSE_SCROLL
	/* There is another problem though in programmed beam-sync modes.
	 * They usually start fetching at colourclock 0x18, which limits their
	 * ability to scroll. This causes an ugly blank
	 * band on the LHS of the display. We cannot always drop the bandwidth,
	 * because for example 8 bitplane Productivity MUST have 4x.
	 * To overcome this, we force the display to remain static during smooth
	 * scrolling, and only move coarsly. The difference is stored in the 
	 * vpe->Origin point as an offset from vp->DxOffset. This offset can be
	 * read with VPOrigin().
	 *
	 * This problem also occurs under ECS in 70 and 140ns modes.
	 */
	if ((VARBEAM35) || (VARBEAM70_140))
	{
		UWORD max = (0xff >> SCROLLRESOLUTION);
		UWORD resn = (max >> 2);
		D(kprintf("Varbeam problem, max = 0x%lx resn = 0x%lx\n", max, resn); WACK;)
		/* Store the offset */
		vpe->Origin[0].x = (((max - bd->Scroll) + resn) >> pinfo->ToDIWResn);
		vpe->Origin[1].x = (((max - bd->Scroll2) + resn) >> pinfo->ToDIWResn);
		/* Force it to not change */
//		bd->DiwStrtX += (max - bd->Scroll);
		bd->DiwStopX = ((bd->cliposcan.MaxX << pinfo->ToDIWResn) + (v->DxOffset << pinfo->ToViewX));
		bd->Scroll = bd->Scroll2 = (resn + 1);
		bd->Offset -= (2 << GBASE->bwshifts[bd->FMode]);
		bd->Offset2 -= (2 << GBASE->bwshifts[bd->FMode]);
	}
#endif	/* COARSE_SCROLL */
    }
#endif	/* ALICE_LHS_BUG */

    /* 'A' fudging: */
    if ((bd->DiwStopX < 0x100) && (cycles == 8) && (!(GBASE->ChipRevBits0 & GFXF_HR_DENISE)))
    {
	/* The ddfstop calculations are 1 larger than is sometimes necessary, but
	 * this is cancelled out in the unneccessary situations by closing the
	 * display window at the right point. 'A' cannot do this, so only fetch
	 * what is needed. This fudge is mainly for narrow viewports.
	 */
	bd->DDFStop -= cycles;
    }

    /* We also want to maximise sprite usage. This may involve dropping the
     * bandwidth (if possible).
     *
     * The more complicated algorithm is as follows:
     * If there is more than sprite 0,
     * and ddfstrt < the ddfstrt needed to fetch the highest numbered sprite,
     * then
     *    calculate how many extra cycles we need to increment ddfstrt.
     *    calculate what we need to drop the bandwidth to for that value.
     *
     * Only bother with this test if we haven't fudged the fmode already or
     * we have only dropped the fmode to 2x, and there is more than one sprite
     * active.
     */

    if ((GBASE->SpriteReserved > 1) && ((fmode == bd->FMode) || (fmode)))
    {
	UWORD ddfwanted;
	WORD  diff;
	WORD  need;
	UBYTE sprite = FindMSBSet(GBASE->SpriteReserved);
	ddfwanted = (FIRSTFETCH + (sprite << 2));
	diff = (ddfwanted - bd->DDFStrt);
	need = (bd->FirstFetch - bd->DDFStrt);

	D(kprintf("need >1 sprite. ddfstrt = 0x%lx, max sprite number = 0x%lx\n", bd->DDFStrt, sprite);)
	D(kprintf("ddfwanted = 0x%lx, ccstrt = 0x%lx, cycles = 0x%lx\n", ddfwanted, bd->FirstFetch, cycles);)
	/* We must be a 16 or 32 cycle to be able to help, as we cannot fetch any later
	 * anyway. If we are a 16 or 32 cycle, then dropping the bandwidth means
	 * we can just add half the current cycle to ddfstrt, if the colour clock
	 * we need to start fetching by is within that range.
	 */
	if (diff && (cycles > 8))
	{
		/* can we drop the bandwidth? */
		if (need >= (cycles >>= 1))
		{
			fmode = ((fmode == BANDWIDTH_4X) ? BANDWIDTH_2XNML : BANDWIDTH_1X);
			need -= cycles;
			/* and further still? */
			if (((bd->DDFStrt + cycles) < ddfwanted) && (cycles > 8) && (need >= (cycles >>= 1)))
			{
				fmode = BANDWIDTH_1X;
			}
			D(kprintf("Dropped the bw to %lxx, ddfstrt = 0x%lx\n", fmode, bd->DDFStrt);)
		}
	}
    }

    if ((bd->FudgedFMode = fmode) != bd->FMode)	/* used later by BuildAAColors and ScrollVPort() */
    {
	bd->Index = ((pinfo->ToViewX << GBASE->arraywidth) + fmode); /* OK to change this, as we don't use it any more. */
	bd->FMode = fmode;
	CalcDataFetch(v, vp, vpe);
	err = CalcScroll(v, vp, vpe);
    }
    bd->Flags |= BD_FUDGEDFMODE;

    D(kprintf("Leaving Fudge(). Flags = 0x%lx\n", bd->Flags); WACK;)

    INC_FNCOUNT;
    return(RETERR);
}

ULONG CalcModulos(DRIVER_PARAMS)
{
    struct BuildData *bd = (struct BuildData *)vpe->DriverData[0];
    struct ProgInfo *pinfo = bd->pinfo;
    struct RasInfo *ri = vp->RasInfo;
    struct BitMap *bm = ri->BitMap;
    UBYTE shift = GBASE->bwshifts[bd->FudgedFMode];
    INITERR
    WORD  wpr, wpd;

    D(kprintf("In CalcModulos()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, bd->pinfo); WACK;);
    D(kprintf("Flags = 0x%lx\n", pinfo->Flags);)

    if (bd->Flags & BD_IS_DPF)
    {
	bm = ri->Next->BitMap;
    }

    /* The modulo is the number of words-per-row in the bitmap - number of
     * words fetched each scanline.
     *
     * The number of words fetched per scanline is the number of colourclocks
     * between ddfstop and ddfstrt, converted to pixels, /16, =
     * ((DDFSTOP - DDFSTRT) * bandwidth) + bandwidth
     *  ------------------    ~~~~~~~~~    ~~~~~~~~~
     *  Fetches per cycle     (^ 1, 2 or 4        ^)
     *
     */

    if (bm)
    {
	WORD overrun = -(GBASE->Overrun[(pinfo->ToViewX << GBASE->arraywidth) + bd->FudgedFMode]);
	wpr = (bm->BytesPerRow + 1) >> 1;	/* to words */
	wpd = (((bd->DDFStop - bd->DDFStrt) << shift) / overrun);

	/* DDFSTOP is where to START STOPPING. The number of fetch cycles after
	 * DDFSTOP (the final fetch) is always a minimum of 8. eg a 4 cycle mode
	 * will do 2 whole fetches.
	 * In the current rev of Alice (8374R3), the maximum count for the last
	 * fetch is 8 (ie a 32 cycle is truncated to 8 cycles).
	 */

	wpd += ((8 / MIN(overrun, 8)) * (1 << shift));
	D(kprintf("ddfstop = 0x%lx, wpr = 0x%lx, wpd = 0x%lx\n", bd->DDFStop, wpr, wpd); WACK;)

	bd->Modulo = ((wpr - wpd) << 1);	/* to bytes */
	bd->Modulo &= (0xfffe << shift);

	if (bd->Flags & BD_IS_LACE)
	{
		D(kprintf("Lace. Was 0x%lx\n", bd->Modulo); WACK;)
		bd->Modulo += bm->BytesPerRow;
	}

	if (bd->Flags & BD_IS_SDBL)
	{
		/* Refetch the last line (use the number of bytes actually fetched) */
		D(kprintf("Scandouble modulos\n");)
		bd->Modulo2 = bd->Modulo;
		bd->Modulo = -(wpd << 1);
		bd->Modulo &= (0xfffe << shift);
	}
	else
	{
		if (!(bd->Flags & BD_IS_DPF))
		{
			D(kprintf("Not DPF\n");)
			bd->Modulo2 = bd->Modulo;
		}
	}
    }
    else
    {
	bd->Modulo = 0;
    }
    
    GOODERR

    D(kprintf("Leaving CalcModulos()\n"); WACK;)
    D(kprintf("Modulo1 = 0x%lx Modulo2 = 0x%lx\n", bd->Modulo, bd->Modulo2); WACK;)

    INC_FNCOUNT;
    return(RETERR);
}

ULONG CalcDPFScrollMods(DRIVER_PARAMS)
{
    struct BuildData *bd = (struct BuildData *)vpe->DriverData[0];
    struct RasInfo *ri = vp->RasInfo;
    UWORD ddfstrtorig = bd->DDFStrt, ddfstrt1, ddfstrt2 = ddfstrtorig;
    LONG offset;
    BOOL isdpf = FALSE;

    INITERR

    D(kprintf("In CalcDPFScroll()\n"); WACK;)

    /* Problem with DualPlayfield - we must use the minimum ddfstrt value that
     * *both* playfields need.
     * CalcScroll() alters the ddfstrt value already calculated to minimise
     * bitplane DMA usage, so we need to keep track.
     */

    if ((ri->Next) && (ri->Next->BitMap))
    {
	isdpf = TRUE;
	bd->Flags |= BD_IS_DPF;
	CalcScroll(v, vp, vpe);		/* assume no error returned */
	ddfstrt2 = bd->DDFStrt;		/* store the (possibly altered) new ddfstrt */
	bd->DDFStrt = ddfstrtorig;	/* restore the original */
	bd->Offset2 = bd->Offset;	/* these are the values we want for plfd 2 */
	bd->Scroll2 = bd->Scroll;	
        bd->Flags &= ~BD_IS_DPF;	/* calculate scroll for plfd 1 */
    }
    CalcScroll(v, vp, vpe);

    D(kprintf("After 2 CalcScrolls, ddfstrt1 = 0x%lx, ddfstrt2 = 0x%lx\n", bd->DDFStrt, ddfstrt2); WACK;)

    /* use the minimum ddfstrt value of the two */
    if ((ddfstrt1 = bd->DDFStrt) != ddfstrt2)
    {
	/* handle the fact that the two ddfstrt values are different */
	offset = (2 << GBASE->bwshifts[bd->FMode]);
	if (ddfstrt1 < ddfstrt2)
	{
		/* we need to use this new ddfstrt value, and so alter
		 * playfield 2's offset accordingly.
		 */
		D(kprintf("Altering Offset2 by 0x%lx\n", offset); WACK;)
		bd->Offset2 -= offset;
	}
	else /* (ddfstrt2 < ddfstrt1) */
	{
		/* change the ddfstrt value, and the 1st playfield's
		 * offset.
		 */
		D(kprintf("Altering Offset1 by 0x%lx, changing ddfstrt to 0x%lx\n", offset, ddfstrt2); WACK;)
		bd->DDFStrt = ddfstrt2;
		bd->Offset -= offset;
	}
    }

    Fudge(v, vp, vpe);

    /* now calculate the modulo values */
    CalcModulos(v, vp, vpe);
    if (isdpf)
    {
	UWORD mods;
	bd->Flags |= BD_IS_DPF;
	CalcModulos(v, vp, vpe);
	mods = bd->Modulo;		/* swap the modulos over */
	bd->Modulo = bd->Modulo2;
	bd->Modulo2 = mods;
//	bd->Flags &= ~BD_IS_DPF;
    }
    
    D(kprintf("Leaving CalcDPFScroll()\n"); WACK;)

    INC_FNCOUNT;
    return(RETERR);
}

#define BPLCON3_BRDSPRT (1<<1)
#define KILLEHB 0x200
#define ECSENA_LOCKS (BPLCON3_EXTBLNKEN | BPLCON3_BRDSPRT | BPLCON3_ZDCLKEN | BPLCON3_BRDNTRAN | BPLCON3_BRDNBLNK)

ULONG MakeAABplcon(DRIVER_PARAMS)
{
#define SCROLL(x) ((((x) & 0x003c) >> 2) | (((x) & 0x0003) << 8) | (((x) & 0x00c0) << 4))

    struct BuildData *bd = (struct BuildData *)vpe->DriverData[0];
    struct ProgInfo *pinfo = bd->pinfo;
    struct RasInfo *ri = vp->RasInfo;
    struct BitMap *bm;
    INITERR
    UWORD  bpu = 0;

    D(kprintf("In MakeAABplcon()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, bd->pinfo); WACK;);

    if (bm = ri->BitMap)
    {
	bpu = bm->Depth;
    }

    if ((bd->Flags & BD_IS_DPF) && (ri = ri->Next) && (bm = ri->BitMap))
    {
	bpu += bm->Depth;
    }

    if (bd->Flags & BD_IS_A2024)
    {
	bpu <<= 1;
    }

    bd->bplcon0 |= pinfo->bplcon0 | GBASE->system_bplcon0 | (v->Modes & LACE) | 
                  (((bpu & 7) << 12) | ((bpu & 8) << 1));

    if ((vp->ColorMap) && (vp->ColorMap->Type) && 
		(vp->ColorMap->AuxFlags & CMAF_DUALPF_DISABLE))
	bd->bplcon0 &= 0xfbff;	/* clear dualpf bit */


    /* for bplcon1, remember bd->Scroll is in 35ns values */
    bd->bplcon1 = SCROLL(bd->Scroll) | (SCROLL(((bd->Flags & BD_IS_DPF) ? bd->Scroll2 : bd->Scroll)) << 4);
    bd->bplcon2 = pinfo->bplcon2 | bd->bplcon2;
    bd->bplcon3 |= get_bplcon3(vp->ColorMap);
    bd->bplcon4 = get_bplcon4(vp->ColorMap);

    /* Do we need to turn on ECSENA? */
    if (bd->bplcon3 & (ECSENA_LOCKS))
    {
	bd->bplcon0 |= USE_BPLCON3;
    }

    /* at this point, set the ScanDouble bit in the fmode. bd->FudgedFMode is
     * not used as an index anymore, and this is needed for ScrollVPort().
     */
    if (bd->Flags & BD_IS_SDBL)
    {
	bd->FudgedFMode |= FMF_BSCAN2;	/* bitplane scan double bit */
    }
    if (bd->mspc->ms_Flags & MSF_DOUBLE_SPRITES)
    {
	bd->FudgedFMode |= FMF_SSCAN2;
    }
    /* also, get the sprite fmode. */
    bd->FudgedFMode |= GBASE->SpriteFMode;

    D(kprintf("Leaving MakeAABplcon()\n"); WACK;);

    INC_FNCOUNT;
    return(RETERR);

}

ULONG MakeECSBplcon(DRIVER_PARAMS)
{
#undef SCROLL
#define SCROLL(x) (((x) & 0x003c) >> 2)

    struct BuildData *bd = (struct BuildData *)vpe->DriverData[0];
    struct ProgInfo *pinfo = bd->pinfo;
    struct RasInfo *ri = vp->RasInfo;
    struct BitMap *bm;
    INITERR
    UWORD  bpu = 0;

    D(kprintf("In MakeECSBplcon()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, bd->pinfo); WACK;);

    if (bm = ri->BitMap)
    {
	bpu = bm->Depth;
    }

    if ((bd->Flags & BD_IS_DPF) && (ri = ri->Next) && (bm = ri->BitMap))
    {
	bpu += bm->Depth;
    }

    if (bd->Flags & BD_IS_A2024)
    {
	bpu <<= 1;
    }

    bd->bplcon0 |= pinfo->bplcon0 | GBASE->system_bplcon0 | (v->Modes & LACE) | 
                  (((bpu & 7) << 12));

    if ((vp->ColorMap) && (vp->ColorMap->Type) && 
		(vp->ColorMap->AuxFlags & CMAF_DUALPF_DISABLE))
	bd->bplcon0 &= 0xfbff;	/* clear dualpf bit */

    /* for bplcon1, remember bd->Scroll is in 35ns values */
    bd->bplcon1 = SCROLL(bd->Scroll) | (SCROLL(((bd->Flags & BD_IS_DPF) ? bd->Scroll2 : bd->Scroll)) << 4);
    bd->bplcon2 = ((pinfo->bplcon2 | bd->bplcon2) & (~KILLEHB));
    bd->bplcon3 |= get_bplcon3(vp->ColorMap);

    /* Do we need to turn on ECSENA? */
    if (bd->bplcon3 & (ECSENA_LOCKS))
    {
	bd->bplcon0 |= USE_BPLCON3;
    }

    D(kprintf("Leaving MakeECSBplcon()\n"); WACK;);

    INC_FNCOUNT;
    return(RETERR);

}

/*********************************************************************************/
/*                                                                               */
/* From here on is the code that actually builds the A, ECS and AA copper lists. */
/*                                                                               */
/*********************************************************************************/

#define DPF_OFFSET_PLANE 3
#define DPF_OFFSET_COLOUR (1 << DPF_OFFSET_PLANE)
#define SPR_OFFSET_PLANE 4
#define SPR_OFFSET_COLOUR (1 << SPR_OFFSET_PLANE)

struct CopIns *setplptr(struct CopIns *c, struct CopList **cl, ULONG reg, ULONG value, UWORD diff)
{
    WORD frame = (diff ? CPR_NT_LOF : 0);

    D(kprintf("setpltr(), address = 0x%lx, value = 0x%lx\n", reg, value); WACK;)

    c->OpCode = (frame | COPPER_MOVE); c->DESTADDR = (WORD)reg; c->DESTDATA = (WORD)(value >> 16); CBUMP(cl);
    c->OpCode = (frame | COPPER_MOVE); c->DESTADDR = (WORD)(reg + 2); c->DESTDATA = (WORD)(value & 0xffff); CBUMP(cl);

    if (diff)	/* must be laced */
    {
	D(kprintf("Have a diff of 0x%lx\n", diff); WACK;)
	c->OpCode = (CPR_NT_SHT | COPPER_MOVE); c->DESTADDR = (WORD)reg; c->DESTDATA = (WORD)((value + diff) >> 16); CBUMP(cl);
	c->OpCode = (CPR_NT_SHT | COPPER_MOVE); c->DESTADDR = (WORD)(reg + 2); c->DESTDATA = (WORD)((value + diff) & 0xffff); CBUMP(cl);
	(*cl)->SLRepeat += 2;

    }

    return(c);
}

struct CopIns *DoPlPtrs(struct ViewPort *vp, struct CopIns *c, struct CopList **cl, struct BuildData *bd)
{
    struct RasInfo *ri = vp->RasInfo;
    struct BitMap *bm;
    struct BitMap *bm2 = NULL;
    struct ProgInfo *pinfo = bd->pinfo;
    UWORD diff, diff1;
    UWORD diff2 = 0;
    int depth, totdepth = 0;

    if (bm = ri->BitMap)
    {
	totdepth = bm->Depth;
    }
    if ((bd->Flags & BD_IS_DPF) && (ri->Next) && (bm2 = ri->Next->BitMap))    /* DualPF */
    {
	diff2 = ((bd->Flags & BD_IS_LACE) ? bm2->BytesPerRow : 0);
	totdepth += bm2->Depth;
    }

    if (totdepth)
    {
	/* Aha - some bitplane pointers */
	diff1 = ((bd->Flags & BD_IS_LACE) ? bm->BytesPerRow : 0);
	if (!(bd->Flags & BD_IS_A2024))
	{
		for (depth = 0; depth < totdepth; depth++)
		{
			int plane;
			ULONG addr;
			plane = ((((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_HAM)) == (PROGINFO_NATIVE | PROGINFO_HAM)) && (bm->Depth >= 7)) ?
				((depth + 6) & 0x7) : 	/* swap the bitplanes */
				depth);
			if (bm2)
			{
				if (depth & 1)
				{
					addr = (ULONG)(bm2->Planes[depth >> 1] + bd->Offset2);
					diff = diff2;
				}
				else
				{
					addr = (ULONG)(bm->Planes[depth >> 1] + bd->Offset);
					diff = diff1;
				}
			}
			else
			{
				addr = (ULONG)(bm->Planes[plane] + bd->Offset);
				diff = diff1;
			}
			c = setplptr(c, cl, REGNUM(bplpt) + (depth<<2), addr, diff);
		}
	}
	else
	{
		for (depth = 0; depth < totdepth; depth++)
		{
			ULONG addr = (ULONG)(bm->Planes[depth] + bd->Offset);

			c = setplptr(c, cl, REGNUM(bplpt) + (depth << 3), addr, 0);
			c = setplptr(c, cl, REGNUM(bplpt) + (((depth << 1) + 1)<<2), (addr + diff1), 0);
		}
	}
    }

    return(c);
}

ULONG BuildColours(DRIVER_PARAMS)
{
    struct BuildData *bd = (struct BuildData *)vpe->DriverData[0];
    struct ColorMap *cm;
    INITERR

    D(kprintf("In BuildColours()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, bd->pinfo); WACK;);

    cm = vp->ColorMap;
    {
	struct CopList *cl;
	if ((cl = vp->DspIns = copinit(vp->DspIns, DSPINS_COUNTA)) && (cl->MaxCount))
	{
		UWORD *c = (UWORD *) cl->CopIns;
		UWORD  *table;
		int    pen;
		UWORD datamask=0x7fff;

		if ((cm) && (cm->Flags & COLORMAP_TRANSPARENCY))
		    datamask=-1;

		table = (cm ? (UWORD *)cm->ColorTable : dflt_clrs);
		bd->firstwait = (struct CopIns *) c;
		D(kprintf("Have CopList at 0x%lx, CopIns at 0x%lx\n", cl, c); WACK;)
		SUPERWAIT(c, 0, 0); SUPERBUMP(&cl); 
		if (table)
		{
			ULONG colormask[8];
			UWORD scrambled_colors[32];
			create_color_bits(vp,colormask);
			if ( (new_mode(vp) & SUPERHIRES) && (! (GBASE->ChipRevBits0 & GFXF_AA_MLISA)))
			{
			    scramble_colors(table,scrambled_colors);
			    scramble_colors(table+16,scrambled_colors+16);
			    table=scrambled_colors;
			}
			for (pen = 0; pen < 32; pen++)
			{
				if (colormask[0] & (1l<<(31-pen)))
				{
					D(kprintf("color=%ld\n",pen););
					*(c++)=COPPER_MOVE; *(c++)=0x180+pen+pen; *(c++)=table[pen] & datamask; SUPERBUMP(&cl);
				}
			}
		}
		bd->c = (struct CopIns *) c;
	}
	else
	{
		ERR(MVP_NO_DSPINS);
	}
    }

    D(kprintf("Leaving BuildColours()\n"); WACK;);

    INC_FNCOUNT;
    return(RETERR);
}

ULONG BuildAAColours(DRIVER_PARAMS)
{

    struct BuildData *bd = (struct BuildData *)vpe->DriverData[0];
    struct ColorMap *cm;
    struct CopList *cl;
    ULONG colormask[8];			/* mask of colors used */
    UWORD cmcount;
    INITERR

    D(kprintf("In BuildAAColours()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, bd->pinfo); WACK;);

    if (cm = vp->ColorMap)
    {
	cmcount = cm->Count;
    }
    else
    {
	cmcount = 32;
    }
    D(kprintf("cmcount = 0x%lx\n", cmcount);)	

    {
	if ((cl = vp->DspIns = copinit(vp->DspIns, (((cmcount << 1) + (((cmcount >> 5) + 1) << 1)) + DSPINS_COUNTAA))) && (cl->MaxCount))
	{
	    UWORD *c = (UWORD *) cl->CopIns;
	    UWORD  *table, *origtableh, *origtablel;
	    int bank, loct, pen;
	    UWORD datamask=0x7fff;

	    if (cm)
	    {
		if (cm->Flags & COLORMAP_TRANSPARENCY) datamask=-1;
		origtableh = (UWORD *)cm->ColorTable;
		origtablel = (UWORD *)((cm->Type == COLORMAP_TYPE_V39) ? cm->LowColorBits : origtableh);
	    }
	    else
	    {
		origtableh = origtablel = dflt_clrs;
	    }
	    D(kprintf("cl = 0x%lx, c = 0x%lx, cl->Count = %ld, cl->MaxCount = %ld\n", cl, c, cl->Count, cl->MaxCount); WACK;)
	    D(kprintf("origtableh = 0x%lx, origtablel = 0x%lx\n", origtableh, origtablel); WACK;)

	    bd->firstwait = (struct CopIns *) c;

	    D(kprintf("bplcon3 = %lx\n",bd->bplcon3););
	    create_color_bits(vp,colormask);	// create bit array of colors used
	    #ifdef DEBUG
	    {
	    	int i;
	    	for (i=0; i<8; i++)
	    	    D(kprintf("cmask[%ld] = 0x%lx\n", i, colormask[i]));
	    }
	    #endif
	    D(kprintf("colormask[0]=%lx\n",colormask[0]););
	    D(kprintf("cl = 0x%lx, c = 0x%lx\n", cl, c);)
	    SUPERWAIT(c, 0, 0); SUPERBUMP(&cl); 
	    for (bank = 0; bank < 8; bank++)
	    {
		if (colormask[bank])
		{
		    D(kprintf("colormask[%ld] = 0x%lx\n", bank, colormask[bank]); WACK;)
		    for (loct = 0; loct < 2; loct++)	/* MSBs, then LSBs of colours */
		    {
			D(kprintf("loct = 0x%lx\n", loct);)
			table = (loct ? origtablel : origtableh);
			SUPERCMOVE(c, bplcon3, (((bank & 0x7) << 13) | (loct << 9)) | bd->bplcon3); SUPERBUMP(&cl);
			for (pen = 0; pen < 32; pen++)
			{
				if (colormask[bank] & (1l<<(31-pen)))
				{
 					*(c++)=COPPER_MOVE; *(c++)=0x180+pen+pen; *(c++)=table[pen+(bank<<5)] & datamask; SUPERBUMP(&cl);
				}
			}
		     }
		}
	    }
	    SUPERCMOVE(c,bplcon4,bd->bplcon4); SUPERBUMP(&cl);
	    bd->c = (struct CopIns *)c;
	} else
	ERR(MVP_NO_DSPINS);
    }
    D(kprintf("Leaving BuildAAColours()\n"); WACK;);
    D(kprintf("cl->Count = %ld\n", cl->Count);)

    INC_FNCOUNT;
    return(RETERR);
}

struct CopIns *BuildStdAACopList(struct CopList **cl, UWORD *c, struct BuildData *bd, struct ProgInfo *pinfo)
{
    D(kprintf("In BuildStdAACopList() - CopList at 0x%lx, CopIns at 0x%lx, bd at 0x%lx, pinfo at 0x%lx\n", *cl, c, bd, pinfo); WACK;)

    /* DIWSTRT/STOP are in ViewPort resolution. The diwstrt/stop registers now
     * work in 35ns pixel resolution with AA, so some conversion is
     * required.
     */

#ifdef ALICE_LHS_WRAPAROUND
    if (GBASE->Bugs & BUG_ALICE_LHS)
    {
	/* Must ensure that the wrap around value is at least 1, as 0 is illegal */
	bd->DiwStopX %= ((bd->mspc->DeniseMaxDisplayColumn - 1) << pinfo->ToViewX);
    }
#endif

    bd->DiwStopX <<= pinfo->ToDIWResn;
    bd->DiwStrtY >>= bd->ToViewY;

    SUPERCMOVE(c, diwstrt, (((bd->DiwStrtY & 0xff) << 8) |
                            (((bd->DiwStrtX <<= pinfo->ToDIWResn) >> 2) & 0xff))); SUPERBUMP(cl);
    SUPERCMOVE(c, bplcon0, bd->bplcon0); SUPERBUMP(cl);
    SUPERCMOVE(c, bplcon2, bd->bplcon2); SUPERBUMP(cl);
    SUPERCMOVE(c, bplcon3, bd->bplcon3); SUPERBUMP(cl);
    *(c++) = (COPPER_MOVE | CPR_NT_SHT); *(c++) = REGNUM(diwstop); *(c++) = bd->RGADiwStopYL; SUPERBUMP(cl);
    *(c++) = (COPPER_MOVE | CPR_NT_LOF); *(c++) = REGNUM(diwstop); *(c++) = bd->RGADiwStopYS; SUPERBUMP(cl);
    (*cl)->SLRepeat++;
    SUPERCMOVE(c, ddfstrt, bd->DDFStrt); SUPERBUMP(cl);
    SUPERCMOVE(c, ddfstop, bd->DDFStop); SUPERBUMP(cl);
    SUPERCMOVE(c, bplcon1, bd->bplcon1); SUPERBUMP(cl);
    SUPERCMOVE(c, bpl1mod, bd->Modulo); SUPERBUMP(cl);
    SUPERCMOVE(c, bpl2mod, bd->Modulo2); SUPERBUMP(cl);

    D(kprintf("Leaving BuildStdAACopList()\n"); WACK;)
    return((struct CopIns *) c);
}

ULONG BuildNmlAACopList(DRIVER_PARAMS)
{

    struct BuildData *bd = (struct BuildData *)vpe->DriverData[0];
    struct ProgInfo *pinfo = bd->pinfo;
    struct CopList *cl;
    UWORD fmode = bd->FudgedFMode;
    UWORD diwhighl, diwhighs;
    UWORD diwstopX;
    WORD ivg;

    INITERR

    D(kprintf("In BuildNmlAACopList()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, bd->pinfo);)
    D(kprintf("bd = 0x%lx CopIns = 0x%lx\n", bd, bd->c); WACK;)

    if (cl = vp->DspIns)    /* should have been set up in BuildAAColours() */
    {
	UWORD *c = (UWORD *) bd->c;

	c = (UWORD *) BuildStdAACopList(&cl, c, bd, pinfo);
	c = (UWORD *) DoPlPtrs(vp, c, &cl, bd);

	diwstopX = ((bd->Flags & BD_VIDEOOSCAN) ? 0 : bd->DiwStopX);

	diwhighl = ((((diwstopX & 0x400) << 3) | (((bd->DiwStrtX & 0x400) >> 5) | ((bd->DiwStrtY & 0x700) >> 8))));
	if (GBASE->ChipRevBits0 & GFXF_AA_ALICE)
	{
		/* For ROM space savings, ECS goes through here too! */

		UWORD mask = ((GBASE->Bugs & BUG_H0) ? 2 : 3);
		diwhighl |= (((bd->DiwStrtX & mask) << 3) | ((bd->DiwStopX & mask) << 11));
	}
	diwhighs = diwhighl;
	diwhighl |= (((bd->DiwStopY + bd->ToViewY) >> bd->ToViewY) & 0x700);
	diwhighs |= ((bd->DiwStopY >>= bd->ToViewY) & 0x700);
	*(c++) = (COPPER_MOVE | CPR_NT_LOF); *(c++) = REGNUM(diwhigh); *(c++)= diwhighl; SUPERBUMP(&cl);
	*(c++) = (COPPER_MOVE | CPR_NT_SHT); *(c++) = REGNUM(diwhigh); *(c++)= diwhighs; SUPERBUMP(&cl);
	cl->SLRepeat++;

	if (GBASE->ChipRevBits0 & GFXF_AA_ALICE)
	{
		/* For ROM space savings, ECS goes through here too! */
		SUPERCMOVE(c, fmode, fmode); SUPERBUMP(&cl);

#ifdef ALICE_RHS_BUG
		/* +++++++++ Fudge Fudge Fudge! ++++++++++++
		 * On the last line of the display, turn off bitplane DMA by 
		 * making BPU in bplcon0 = 0, and set fmode to 0.
		 *
		 * This is only needed for display windows with a 16 or 32 fetch cycle.
		 */

		D(kprintf("cycle = %ld\n", (pinfo->Offset + GBASE->bwshifts[fmode])); WACK;)
		if (bd->RHSFudge)
		{
			SUPERWAIT(c, (vp->DHeight - 1), 0); SUPERBUMP(&cl);
			SUPERCMOVE(c, bplcon0, (bd->bplcon0 & 0x8fef)); SUPERBUMP(&cl);
			SUPERCMOVE(c, fmode, GBASE->SpriteFMode); SUPERBUMP(&cl);
		}
#endif
	}

	SUPERCEND(c); SUPERBUMP(&cl);

        if (bd->firstwait)
        {
		ivg = gfx_CalcIVG(v, vp);
		D(kprintf("IVG = 0x%lx\n", ivg); WACK)
		bd->firstwait->VWAITPOS = -ivg;		/* leave enough space for loading the colours */
        }

	/* Does the IVG straddle line 255?
	 * DiwStrtY must be > 255, && (DiwStrtY - ivg) < 255.
	 */
	if (bd->Flags & BD_IS_SDBL)
	{
		ivg <<= 1;
	}
	else
	{
		if (bd->Flags & BD_IS_LACE)
		{
			ivg >>= 1;
		}
	}
	if (((bd->DiwStrtY & 0xff) && (bd->DiwStrtY > ivg) && ((bd->DiwStrtY & 0xff00) != ((bd->DiwStrtY - ivg) & 0xff00))) ||
	    ((cl->Flags & EXACT_LINE) && (!(bd->DiwStrtY & 0xff))))
	{
		D(kprintf("Straddles. DiwStrtY = 0x%lx, vp = 0x%lx\n", bd->DiwStrtY, vp); WACK;)
		DG(struct Custom *io = &custom; io->color[0] = 0xf00;)
		vpe->Flags |= VPXF_STRADDLES_256;
		if (bd->DiwStrtY >= 512)
		{
			vpe->Flags |= VPXF_STRADDLES_512;
			DG(struct Custom *io = &custom; io->color[0] = 0x0f0;)
		}
	}
	else
	{
		vpe->Flags &= ~(VPXF_STRADDLES_256 | VPXF_STRADDLES_512);
	}
    }
    else
    {
	ERR(MVP_NO_DSPINS);
    }

    D(kprintf("Leaving BuildNmlAACopList()\n"); WACK;);
    D(kprintf("cl->Count = %ld\n", cl->Count);)

    INC_FNCOUNT;
    return(RETERR);
}

ULONG BuildNmlACopList(DRIVER_PARAMS)
{

    struct BuildData *bd = (struct BuildData *)vpe->DriverData[0];
    struct ProgInfo *pinfo = bd->pinfo;
    struct CopList *cl;
    UWORD  ToViewY = bd->ToViewY;
    WORD ivg, enable;

    INITERR

    D(kprintf("In BuildNmlACopList()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, bd->pinfo);)
    D(kprintf("bd = 0x%lx CopIns = 0x%lx\n", bd, bd->c); WACK;)

    if (cl = vp->DspIns)    /* should have been set up in BuildColours() */
    {
	UWORD *c = (UWORD *) bd->c;

	/* DIWSTRT/STOP are in ViewPort resolution. The diwstrt/stop registers now
	 * work in 35ns pixel resolution with AA, so some conversion is
	 * required.
	 */

	bd->DiwStrtX <<= pinfo->ToDIWResn;
//	bd->DiwStopX <<= pinfo->ToDIWResn;
//	bd->DiwStopY >>= ToViewY;	/* not used any more */

	/* clip to the 'A' hardware limits. The display window is restricted to
	 * opening horizontally to the left 3/4 of the display (H8 = 0) and vertically
	 * upper 2/3 of the display (V8 = 0), and closing horizontally to the right
	 * 1/4 (H8 = 1) and vertically to the lower half.
	 */

	bd->DiwStrtX = MIN(bd->DiwStrtX, 0x3ff);

#ifdef UNDEF
	/* Furthermore, on true 'A' machines (those without ECS Denise or Lisa),
	 * for some reason, setting DDFSTRT to 0x20 in lores screens when the 
	 * screen is as far to the left as possible results in about 4 pixels being
	 * lost. This is weird - if I remove the old denise whilst the machine is
	 * running, and replace it with an ECS denise, then the display is fine.
	 * The simplest solution I have found so far is to sniff out this case,
	 * and reduce DDFSTRT by 4, and subtract 2 from the bitplane
	 * offsets and modulos.
	 * Sheesh!
	 */
	if ((bd->DDFStrt == 0x20) && (pinfo->ToViewX == 0))
	{
		/* Note: this also works on ECS and AA in 'A' emulation */
		bd->DDFStrt -= 4;
		bd->Offset -= 2;
		bd->Offset2 -= 2;
		if (bd->DiwStopX >= 0x100)
		{
			bd->DDFStop -= 4;
		}
		else
		{
			bd->Modulo -= 2;
			bd->Modulo2 -= 2;
		}
	}
#endif
	SUPERCMOVE(c, diwstrt, (((bd->mspc->min_row & 0xff) << 8) |
	                        ((bd->DiwStrtX >> 2) & 0xff))); SUPERBUMP(&cl);
	SUPERCMOVE(c, bplcon0, (bd->bplcon0 & 0x0fef)); SUPERBUMP(&cl);
	SUPERCMOVE(c, bplcon2, bd->bplcon2); SUPERBUMP(&cl);
	SUPERCMOVE(c, diwstop, bd->RGADiwStopYL); SUPERBUMP(&cl);
	SUPERCMOVE(c, ddfstrt, bd->DDFStrt); SUPERBUMP(&cl);
	SUPERCMOVE(c, ddfstop, bd->DDFStop); SUPERBUMP(&cl);
	SUPERCMOVE(c, bplcon1, bd->bplcon1); SUPERBUMP(&cl);
	SUPERCMOVE(c, bpl1mod, bd->Modulo); SUPERBUMP(&cl);
	SUPERCMOVE(c, bpl2mod, bd->Modulo2); SUPERBUMP(&cl);

	c = (UWORD *) DoPlPtrs(vp, c, &cl, bd);

	/* We now display the ViewPort by turning on BitPlaneUsage. We always
	 * want to do this at the same Y position (the View->DyOffset).
	 */
	enable = (bd->DiwStrtY - vp->DyOffset - (v->DyOffset << ToViewY));
	/* Turn on... */
	SUPERWAIT(c, enable, 0); SUPERBUMP(&cl);
	SUPERCMOVE(c, bplcon0, bd->bplcon0); SUPERBUMP(&cl);
	/* ... and turn off again, at different points for Long and Short frame */
	{
		UWORD diff;
		diff = ((vp->DHeight & (vp->DyOffset + 1)) & ToViewY);
		D(kprintf("vp->DHeight = 0x%lx, enable = 0x%lx, diff = 0x%lx\n", vp->DHeight, enable, diff);)
		*(c++) = (COPPER_WAIT | CPR_NT_SHT); *(c++) = (vp->DHeight + diff); *(c++) = 0; SUPERBUMP(&cl);
		*(c++) = (COPPER_WAIT | CPR_NT_LOF); *(c++) = (vp->DHeight & ~1); *(c++) = 0; SUPERBUMP(&cl);
		cl->SLRepeat++;
	}
	SUPERCMOVE(c, bplcon0, (bd->bplcon0 & 0x0fef)); SUPERBUMP(&cl);
	/* Calculate InterViewPort gap. */
        if (bd->firstwait)
        {
		ivg = gfx_CalcIVG(v, vp);
		D(kprintf("IVG = 0x%lx\n", ivg); WACK)
		bd->firstwait->VWAITPOS = (enable - ivg);		/* leave enough space for loading the colours */
        }
	SUPERCEND(c); SUPERBUMP(&cl);
    }

    D(kprintf("Leaving BuildNmlACopList\n");)

    INC_FNCOUNT;
    return(RETERR);
}
@


39.74
log
@Also set VPXF_STRADDLES if there are an exact number of whole lines
in the IVG (cl->Flags & EXACT_LINE), and we are on a line-256 boundary.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.73 93/03/26 13:42:40 spence Exp Locker: spence $
d1402 1
a1402 1
	if ((cl = vp->DspIns = copinit(vp->DspIns, (((cmcount << 1) + cmcount) << 1) + DSPINS_COUNTAA)) && (cl->MaxCount))
@


39.73
log
@Code that calculated the STRADDLES_256 bit was not halving the IVG
in interlaced screens.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.72 93/03/12 12:55:43 chrisg Exp Locker: spence $
d1592 2
a1593 1
	if ((bd->DiwStrtY & 0xff) && (bd->DiwStrtY > ivg) && ((bd->DiwStrtY & 0xff00) != ((bd->DiwStrtY - ivg) & 0xff00)))
@


39.72
log
@nodpf-dpf support.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.71 93/02/25 17:44:04 spence Exp Locker: chrisg $
d1581 12
a1592 1
	if ((bd->DiwStrtY & 0xff) && (bd->DiwStrtY > ivg) && ((bd->DiwStrtY & 0xff00) != ((bd->DiwStrtY - (ivg << ((bd->Flags & BD_IS_SDBL) ? 1 : 0))) & 0xff00)))
@


39.71
log
@Moved the COMPATIBILITY_KLUDGE code to CalcIVG().
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.70 93/02/22 10:15:37 spence Exp Locker: spence $
d1126 6
d1196 5
@


39.70
log
@Increment CopList->SLRepeat for evey instruction that is different in
LONG and SHORT frames. This is used by CalcIVG() to return a true value.
It was possible for CalcIVG() to return a value 1 too great in edge
condiftions.
,
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.69 93/02/11 08:26:13 chrisg Exp Locker: spence $
a32 2
#define COMPATIBILITY_KLUDGES

a1563 8
#ifdef COMPATIBILITY_KLUDGES
		/* Under V37, there was always at least 2 lines in the IVG. */
		if(!(GBASE->ChipRevBits0 & GFXF_AA_ALICE))
		{
			ivg = MAX(ivg, (2 << bd->ToViewY));
			D(kprintf("kludged IVG to 0x%lx\n", ivg);)
		}
#endif
a1695 5
#ifdef COMPATIBILITY_KLUDGES
		/* Under V37, there was always at least 2 lines in the IVG. */
		ivg = MAX(ivg, (2 << bd->ToViewY));
		D(kprintf("kludged IVG to 0x%lx\n", ivg);)
#endif
@


39.69
log
@now uses UWORD ptr for copins. Massive speedup and saves 330 bytes!
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.68 92/12/09 13:41:27 spence Exp Locker: chrisg $
d10 1
d1235 2
d1398 1
a1398 1
	     UWORD datamask=0x7fff;
d1410 1
a1410 1
	    D(kprintf("cl = 0x%lx, c = 0x%lx\n", cl, c); WACK;)
d1453 1
d1486 1
d1535 1
d1602 1
d1698 1
@


39.68
log
@Code that fudges the fmode dependent on the number of sprites asked for
was not fudging if the difference between current ddfstrt and required
ddfstrt < 8. This is not necessary. For instance, a maxoscan Hires screen
with Sprite 1 was not being dropped to 2x.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.67 92/11/23 16:58:20 spence Exp Locker: spence $
d1321 1
a1321 1
		struct CopIns *c = cl->CopIns;
d1330 1
a1330 1
		bd->firstwait = c;
d1332 1
a1332 1
		CWAIT(c, 0, 0); CBUMP(&cl); 
d1346 1
a1346 1
				if (testbit(colormask,pen))
d1349 1
a1349 3
					c->OpCode=COPPER_MOVE; c->DESTADDR=0x180+pen+pen; c->DESTDATA=table[pen] & datamask; CBUMP(&cl);

//					CMOVER(c, color[pen], table[pen] & datamask); CBUMP(&cl);
d1353 1
a1353 1
		bd->c = c;
d1392 1
a1392 1
	    struct CopIns *c = cl->CopIns;
d1410 1
a1410 1
	    bd->firstwait = c;
d1423 1
a1423 1
	    CWAIT(c, 0, 0); CBUMP(&cl); 
d1433 1
a1433 1
			CMOVER(c, bplcon3, (((bank & 0x7) << 13) | (loct << 9)) | bd->bplcon3); CBUMP(&cl);
d1436 1
a1436 1
				if (testbit(colormask,pen+(bank<<5)))
d1438 1
a1438 1
 					c->OpCode=COPPER_MOVE; c->DESTADDR=0x180+pen+pen; c->DESTDATA=table[pen+(bank<<5)] & datamask; CBUMP(&cl);
d1444 2
a1445 2
	    CMOVER(c,bplcon4,bd->bplcon4); CBUMP(&cl);
	    bd->c = c;
d1455 1
a1455 1
struct CopIns *BuildStdAACopList(struct CopList **cl, struct CopIns *c, struct BuildData *bd, struct ProgInfo *pinfo)
d1475 12
a1486 12
    CMOVER(c, diwstrt, (((bd->DiwStrtY & 0xff) << 8) |
                            (((bd->DiwStrtX <<= pinfo->ToDIWResn) >> 2) & 0xff))); CBUMP(cl);
    CMOVER(c, bplcon0, bd->bplcon0); CBUMP(cl);
    CMOVER(c, bplcon2, bd->bplcon2); CBUMP(cl);
    CMOVER(c, bplcon3, bd->bplcon3); CBUMP(cl);
    c->OpCode = (COPPER_MOVE | CPR_NT_SHT); c->DESTADDR = REGNUM(diwstop); c->DESTDATA = bd->RGADiwStopYL; CBUMP(cl);
    c->OpCode = (COPPER_MOVE | CPR_NT_LOF); c->DESTADDR = REGNUM(diwstop); c->DESTDATA = bd->RGADiwStopYS; CBUMP(cl);
    CMOVER(c, ddfstrt, bd->DDFStrt); CBUMP(cl);
    CMOVER(c, ddfstop, bd->DDFStop); CBUMP(cl);
    CMOVER(c, bplcon1, bd->bplcon1); CBUMP(cl);
    CMOVER(c, bpl1mod, bd->Modulo); CBUMP(cl);
    CMOVER(c, bpl2mod, bd->Modulo2); CBUMP(cl);
d1489 1
a1489 1
    return(c);
d1510 1
a1510 1
	struct CopIns *c = bd->c;
d1512 2
a1513 2
	c = BuildStdAACopList(&cl, c, bd, pinfo);
	c = DoPlPtrs(vp, c, &cl, bd);
d1528 2
a1529 2
	c->OpCode = (COPPER_MOVE | CPR_NT_LOF); c->DESTADDR = REGNUM(diwhigh); c->DESTDATA = diwhighl; CBUMP(&cl);
	c->OpCode = (COPPER_MOVE | CPR_NT_SHT); c->DESTADDR = REGNUM(diwhigh); c->DESTDATA = diwhighs; CBUMP(&cl);
d1534 1
a1534 1
		CMOVER(c, fmode, fmode); CBUMP(&cl);
d1547 3
a1549 3
			CWAIT(c, (vp->DHeight - 1), 0); CBUMP(&cl);
			CMOVER(c, bplcon0, (bd->bplcon0 & 0x8fef)); CBUMP(&cl);
			CMOVER(c, fmode, GBASE->SpriteFMode); CBUMP(&cl);
d1554 1
a1554 1
	CEND(c); CBUMP(&cl);
d1617 1
a1617 1
	struct CopIns *c = bd->c;
d1664 10
a1673 10
	CMOVER(c, diwstrt, (((bd->mspc->min_row & 0xff) << 8) |
	                        ((bd->DiwStrtX >> 2) & 0xff))); CBUMP(&cl);
	CMOVER(c, bplcon0, (bd->bplcon0 & 0x0fef)); CBUMP(&cl);
	CMOVER(c, bplcon2, bd->bplcon2); CBUMP(&cl);
	CMOVER(c, diwstop, bd->RGADiwStopYL); CBUMP(&cl);
	CMOVER(c, ddfstrt, bd->DDFStrt); CBUMP(&cl);
	CMOVER(c, ddfstop, bd->DDFStop); CBUMP(&cl);
	CMOVER(c, bplcon1, bd->bplcon1); CBUMP(&cl);
	CMOVER(c, bpl1mod, bd->Modulo); CBUMP(&cl);
	CMOVER(c, bpl2mod, bd->Modulo2); CBUMP(&cl);
d1675 1
a1675 1
	c = DoPlPtrs(vp, c, &cl, bd);
d1682 2
a1683 2
	CWAIT(c, enable, 0); CBUMP(&cl);
	CMOVER(c, bplcon0, bd->bplcon0); CBUMP(&cl);
d1689 2
a1690 2
		c->OpCode = (COPPER_WAIT | CPR_NT_SHT); c->VWAITPOS = (vp->DHeight + diff); c->HWAITPOS = 0; CBUMP(&cl);
		c->OpCode = (COPPER_WAIT | CPR_NT_LOF); c->VWAITPOS = (vp->DHeight & ~1); c->HWAITPOS = 0; CBUMP(&cl);
d1692 1
a1692 1
	CMOVER(c, bplcon0, (bd->bplcon0 & 0x0fef)); CBUMP(&cl);
d1705 1
a1705 1
	CEND(c); CBUMP(&cl);
@


39.67
log
@Forgot to remove an unneeded VPXF_OFF_BOTTOM flag.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.66 92/11/23 16:22:59 spence Exp Locker: spence $
d893 1
a893 4
	/* If the difference between ddfwanted and ddfstrt is < 8,
	 * then there's nothing we can do, as dropping the bandwidth
	 * won't affect ddfstrt. If it's greater than 8, we must be a
	 * 16 or 32 cycle to be able to help, as we cannot fetch any later
d898 1
a898 1
	if ((diff >= 8) && (cycles > 8))
@


39.66
log
@If the top of the ViewPort is off the bottom of the display, now
returns MVP_OFF_BOTTOM as an internal error. MakeVPort() will then
bug out of the buildvp process early, and so no copper instructions will
be generated for this invisible viewport.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.65 92/10/30 16:12:26 spence Exp Locker: spence $
a436 1
	vpe->Flags |= VPXF_OFF_BOTTOM;	/* signal for MrgCop() */
@


39.65
log
@ECS/AA now clips DiwStopY to (mspc->total_rows + 1).
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.64 92/09/18 14:34:54 spence Exp Locker: spence $
d432 9
d463 1
a463 1
    CalcDispWindow(v, vp, vpe);		/* Calc for ECS/AA */
@


39.64
log
@ddfstop now calculated by counting the number of fetches needed and
adding them to ddfstrt. This is easier than the old way, and more accurate,
especially when it comes to narrow viewports (which now work much better).
The IVG compatiblity kludge wasn't doubling the result for laced viewports.
Known problems: Database says viewports can be 16pixels wide. On 'A', can
only manage 32 pixels. And this is only for Lores - Hires are still broken.
On ECS, narrow productivity type viewports are also problematic, but work
OK in AA in ECS mode. Go figure!
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.63 92/08/27 14:30:25 spence Exp Locker: spence $
d378 5
a382 1
	bd->DiwStopY = MIN(dystop, (mspc->total_rows << ToViewY));
@


39.63
log
@Fixed laced ViewPort Y Offset problems (were mostly rounding errors).
Changed DDFSTOP mask calculation to match DDFSTRT value. Fixes problems
with Super72 ExtraLores screens.
DDFSTRT could be set to <0x18 on ECS machines because it was checking
for GBASE->Bugs ALICE_LHS_BUG, which is not set for ECS.
Removed bd->FnCount++ from macro.
Added compatiblity kludge for ECS and A - ivg should always be at
least 2 lines.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.62 92/08/20 13:36:30 spence Exp Locker: spence $
d531 1
a531 1
    UWORD  maskstop = (pinfo->DDFSTOPMask & GBASE->StopFetchMasks[bd->Index]);
d552 1
a552 1
    D(kprintf("bd->Cycle = 0x%lx", bd->Cycle);)
d557 2
a558 2
    /* for ddfstop, convert the diwstopx to ColourClocks, subtract the number of colorclocks in
     * the fetch pattern (for where to START STOPPING!), and mask.
d561 2
a562 2
    maskstop &= ((ddfstrt - FIRSTFETCH) | 0xfff0);
    ddfstop = ((((DIWX_TO_CC(bd->DiwStopX) - realstop) - FIRSTFETCH) & maskstop) + FIRSTFETCH);
d567 14
a580 1
    	ddfstop = (bd->mspc->total_colorclocks - realstop - 1) & maskstop;
d843 11
d959 2
a960 3
	 * In the current rev of Alice (8374R2), the maximum count for the last
	 * fetch is 16 (ie a 32 cycle is truncated to 16 cycles), but this is
	 * still only an 8-fetch (the last 8 cycles are empty).
d1557 1
a1557 1
			ivg = MAX(ivg, 2);
d1617 3
a1619 2
	bd->DiwStopX <<= pinfo->ToDIWResn;
	bd->DiwStopY >>= ToViewY;
d1621 36
d1658 1
a1658 1
	                        (((bd->DiwStrtX <<= pinfo->ToDIWResn) >> 2) & 0xff))); CBUMP(&cl);
d1693 1
a1693 1
		ivg = MAX(ivg, 2);
@


39.62
log
@Put GBASE->SpriteFMode in bd->FudgedFMode
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.61 92/08/17 16:47:05 spence Exp Locker: spence $
d26 1
d32 2
d63 8
a71 3
/*#define INITERR ULONG  err = (bd->FnCount << 16);*/
#define INITERR ULONG err = 0;
#define INC_FNCOUNT {bd->FnCount++; D(kprintf("err = 0x%lx\n", err); WACK;)}
d76 1
a77 1
#define INC_FNCOUNT
d323 2
a324 2
    dystrt = (vp->DyOffset & ~(ToViewY));
    dystop = (dystrt + dheight - 1);	/* vp->DHeight is in VP resolution */
a350 1
	dystop ++;
d356 1
a356 1
    dystop += ((v->DyOffset + 1) << ToViewY);
d416 5
a420 1
	diff = (((bd->DiwStopY - bd->DiwStrtY) + 1) & ToViewY);
d422 2
a423 2
	diwstopl |= ((((bd->DiwStopY >> ToViewY) - diff) & 0xff) << 8);
	diwstops |= (((bd->DiwStopY >> ToViewY) & 0xff) << 8);
d469 4
a472 3
	diff = (((bd->DiwStopY - bd->DiwStrtY) + 1) & ToViewY);
	bd->RGADiwStopYL |= ((((bd->DiwStopY >> ToViewY) - diff) & 0xff) << 8);
	bd->RGADiwStopYS = bd->RGADiwStopYL;
d499 2
a500 2
    {0xfff8, 0xfff8, 0xfff8, 0xfff8},
    {0xfff8, 0xfff8, 0xfff8, 0xfff8},
d530 1
a530 1
    UWORD  maskstrt = (pinfo->DDFSTRTMask & GBASE->StrtFetchMasks[bd->Index]);
d549 5
a553 1
    bd->Cycle = -((WORD)maskstrt);
d561 1
a561 4
    if (bd->Cycle > 8)
    {
	maskstop &= ((ddfstrt - FIRSTFETCH) | 0xfff0);
    }
d674 2
a675 1
		if (((WORD)bd->DDFStrt < (WORD)FIRSTFETCH) && (GBASE->Bugs & BUG_ALICE_LHS))
d705 1
a705 1
	offset -= (LONG)((MIN(0,(vp->DyOffset - bd->cliposcan.MinY)) - ri->RyOffset) * bm->BytesPerRow);
a1443 1
    bd->DiwStopY >>= bd->ToViewY;
d1469 1
a1469 1
    UWORD diwhigh;
d1486 2
a1487 2
	diwhigh = (((((diwstopX & 0x400) << 3) | (bd->DiwStopY & 0x700)) |
	          (((bd->DiwStrtX & 0x400) >> 5) | ((bd->DiwStrtY & 0x700) >> 8))));
d1493 1
a1493 1
		diwhigh |= (((bd->DiwStrtX & mask) << 3) | ((bd->DiwStopX & mask) << 11));
d1495 6
a1500 1
	CMOVER(c, diwhigh, diwhigh); CBUMP(&cl);
d1530 8
d1631 5
@


39.61
log
@make sure that DiwStrtY is greater than the ivg when calculating if the
IVG straddles line 256.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.60 92/08/11 13:58:39 spence Exp Locker: spence $
d1104 3
d1486 1
a1486 1
		CMOVER(c, fmode, (fmode | GBASE->SpriteFMode)); CBUMP(&cl);
@


39.60
log
@removed R2Alice bug-fixing code.
increment diwstrty by one after scaling for scan double modes. Was losing 
the last line of the display.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.59 92/08/06 11:25:44 spence Exp Locker: spence $
d1515 1
a1515 1
	if ((bd->DiwStrtY & 0xff) && ((bd->DiwStrtY & 0xff00) != ((bd->DiwStrtY - (ivg << ((bd->Flags & BD_IS_SDBL) ? 1 : 0))) & 0xff00)))
@


39.59
log
@Replace GBASE->default_monitor with GBASE->natural_monitor
VideoOScan displays now no longer clipped
Check for STRADDLES_512
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.58 92/07/24 12:00:50 spence Exp Locker: spence $
d33 2
a34 1
#define H0_BUG
a35 1
#define ALICE_RHS_BUG
d343 1
d1485 1
d1500 1
@


39.58
log
@Previous fix for narrow ViewPorts broke coercion, especially beamsynced
16 and 32 cycles. Fixed this by checking the cycle count, and altering the
maskstrt as I was doing before.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.57 92/07/21 14:34:06 spence Exp Locker: spence $
d118 1
d175 1
a175 1
			bd->mspc = GBASE->default_monitor;
d231 2
d355 15
a369 1
	bd->DiwStopX = MIN(dxstop, (mspc->DeniseMaxDisplayColumn << ToViewX));
d409 1
a409 1
	diwstopl = diwstops = (((bd->DiwStopX << pinfo->ToDIWResn) >> 2) & 0xff);
d456 1
a456 1
	UWORD diwstopl, diff;
d458 2
a459 4
	diwstopl = (((bd->DiwStopX << bd->pinfo->ToDIWResn) >> 2) & 0xff);
	diwstopl |= ((((bd->DiwStopY >> ToViewY) - diff) & 0xff) << 8);
	bd->RGADiwStopYL = diwstopl;
	bd->RGADiwStopYS = diwstopl;
d1453 1
d1468 2
a1469 1
	diwhigh = (((((bd->DiwStopX & 0x400) << 3) | (bd->DiwStopY & 0x700)) |
d1515 7
a1521 1
		vpe->Flags |= VPXF_STRADDLES_255;
d1525 1
a1525 1
		vpe->Flags &= ~(VPXF_STRADDLES_255);
@


39.57
log
@Only check RasInfo->Next if DualPlayfield
Fmode demotion for sprites
Changed DDFSTOP mask table and removed code that sets maskstop on same
boundary as maskstrt. Fixes narrow viewports on the RHS.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.56 92/07/09 12:02:51 spence Exp Locker: spence $
d529 4
@


39.56
log
@Fixed depth > 5 problems from previous version's optimisations.
Checks and sets a flag if the IVG straddles line 256
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.55 92/07/01 10:51:34 chrisg Exp Locker: spence $
d37 3
d471 1
a471 1
    {0xfff8, 0xfff0, 0xfff0, 0xffe0},
a500 1
    UBYTE  ToViewX = pinfo->ToViewX;
d504 1
d521 2
a522 1
    ddfstrt = ((((DIWX_TO_CC(bd->DiwStrtX) - realstop) - FIRSTFETCH) & maskstrt) + FIRSTFETCH);
a528 1
    maskstop &= ((ddfstrt - FIRSTFETCH) | 0xfff0);
d531 1
a531 1
    if (ddfstop >= (bd->LastFetch = (bd->mspc->total_colorclocks - realstop)))
d712 1
d734 1
d741 1
d748 1
d755 1
d762 1
d792 54
a845 1
#endif
a854 3
#else
    bd->FudgedFMode = fmode;
#endif
d1018 1
a1018 1
	bd->Flags &= ~BD_IS_DPF;
d1049 1
a1049 1
    if ((ri = ri->Next) && (bm = ri->BitMap))
a1051 1
	bd->Flags |= BD_IS_DPF;
d1110 1
a1110 1
    if ((ri = ri->Next) && (bm = ri->BitMap))
a1112 1
	bd->Flags |= BD_IS_DPF;
d1184 1
a1184 1
    if ((ri->Next) && (bm2 = ri->Next->BitMap))    /* DualPF */
@


39.55
log
@cmover
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.54 92/06/30 18:14:15 spence Exp Locker: chrisg $
d1314 1
a1314 2
					c->OpCode=COPPER_MOVE; c->DESTADDR=0x180+pen+pen; c->DESTDATA=table[pen] & datamask; CBUMP(&cl);
//				    CMOVER(c, color[pen], table[pen+(bank<<5)] & datamask); CBUMP(&cl);
d1430 13
@


39.54
log
@ECS copperlists did not have a bplcon3 in them.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.53 92/06/30 16:41:50 spence Exp Locker: spence $
a1114 1
    struct Custom *io = &custom;
d1164 1
a1164 1
			c = setplptr(c, cl, (ULONG)(io->bplpt + depth), addr, diff);
d1173 2
a1174 2
			c = setplptr(c, cl, (ULONG)(io->bplpt + (depth << 1)), addr, 0);
			c = setplptr(c, cl, (ULONG)(io->bplpt + ((depth << 1) + 1)), (addr + diff1), 0);
a1185 1
    struct Custom *io = &custom;
d1223 3
a1225 1
					CMOVE(c, io->color[pen], table[pen] & datamask); CBUMP(&cl);
a1247 1
    struct Custom *io = &custom;
d1309 1
a1309 1
			CMOVE(c, io->bplcon3, (((bank & 0x7) << 13) | (loct << 9)) | bd->bplcon3); CBUMP(&cl);
d1314 2
a1315 1
				    CMOVE(c, io->color[pen], table[pen+(bank<<5)] & datamask); CBUMP(&cl);
d1321 1
a1321 1
	    CMOVE(c,io->bplcon4,bd->bplcon4); CBUMP(&cl);
a1333 1
    struct Custom *io = &custom;
d1353 1
a1353 1
    CMOVE(c, io->diwstrt, (((bd->DiwStrtY & 0xff) << 8) |
d1355 10
a1364 10
    CMOVE(c, io->bplcon0, bd->bplcon0); CBUMP(cl);
    CMOVE(c, io->bplcon2, bd->bplcon2); CBUMP(cl);
    CMOVE(c, io->bplcon3, bd->bplcon3); CBUMP(cl);
    c->OpCode = (COPPER_MOVE | CPR_NT_SHT); c->DESTADDR = (int)(&io->diwstop); c->DESTDATA = bd->RGADiwStopYL; CBUMP(cl);
    c->OpCode = (COPPER_MOVE | CPR_NT_LOF); c->DESTADDR = (int)(&io->diwstop); c->DESTDATA = bd->RGADiwStopYS; CBUMP(cl);
    CMOVE(c, io->ddfstrt, bd->DDFStrt); CBUMP(cl);
    CMOVE(c, io->ddfstop, bd->DDFStop); CBUMP(cl);
    CMOVE(c, io->bplcon1, bd->bplcon1); CBUMP(cl);
    CMOVE(c, io->bpl1mod, bd->Modulo); CBUMP(cl);
    CMOVE(c, io->bpl2mod, bd->Modulo2); CBUMP(cl);
a1374 1
    struct Custom *io = &custom;
d1401 1
a1401 1
	CMOVE(c, io->diwhigh, diwhigh); CBUMP(&cl);
d1405 1
a1405 1
		CMOVE(c, FMODE, (fmode | GBASE->SpriteFMode)); CBUMP(&cl);
d1418 2
a1419 2
			CMOVE(c, io->bplcon0, (bd->bplcon0 & 0x8fef)); CBUMP(&cl);
			CMOVE(c, FMODE, GBASE->SpriteFMode); CBUMP(&cl);
a1447 1
    struct Custom *io = &custom;
d1469 1
a1469 1
	CMOVE(c, io->diwstrt, (((bd->mspc->min_row & 0xff) << 8) |
d1471 8
a1478 8
	CMOVE(c, io->bplcon0, (bd->bplcon0 & 0x0fef)); CBUMP(&cl);
	CMOVE(c, io->bplcon2, bd->bplcon2); CBUMP(&cl);
	CMOVE(c, io->diwstop, bd->RGADiwStopYL); CBUMP(&cl);
	CMOVE(c, io->ddfstrt, bd->DDFStrt); CBUMP(&cl);
	CMOVE(c, io->ddfstop, bd->DDFStop); CBUMP(&cl);
	CMOVE(c, io->bplcon1, bd->bplcon1); CBUMP(&cl);
	CMOVE(c, io->bpl1mod, bd->Modulo); CBUMP(&cl);
	CMOVE(c, io->bpl2mod, bd->Modulo2); CBUMP(&cl);
d1488 1
a1488 1
	CMOVE(c, io->bplcon0, bd->bplcon0); CBUMP(&cl);
d1497 1
a1497 1
	CMOVE(c, io->bplcon0, (bd->bplcon0 & 0x0fef)); CBUMP(&cl);
@


39.53
log
@'A' display window bug fixes
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.52 92/06/29 13:48:04 spence Exp Locker: spence $
a1320 1
	    CMOVE(c,io->bplcon3, bd->bplcon3); CBUMP(&cl);
d1358 1
@


39.52
log
@DiwStopY fro Long and Short frames calculated and stored in BuildDAta
for use by ScrollVPort().
Ensure that DDFSTRT and DDFSTOP values are coordinated to be whole
cycles.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.51 92/06/23 14:10:17 spence Exp Locker: spence $
d425 5
a429 1
    bd->DiwStrtY = (mspc->min_row << ToViewY);
d432 12
d661 1
a661 1
				           (((-prefetch) >> realstop) + 1))
d1359 2
a1360 2
    c->OpCode = (COPPER_MOVE | CPR_NT_SHT); c->DESTADDR=(int)(&io->diwstop); c->DESTDATA = bd->RGADiwStopYL; CBUMP(cl);
    c->OpCode = (COPPER_MOVE | CPR_NT_LOF); c->DESTADDR=(int)(&io->diwstop); c->DESTDATA = bd->RGADiwStopYS; CBUMP(cl);
d1452 2
a1453 1
    WORD ivg;
d1469 2
a1470 3
	bd->DiwStopX <= pinfo->ToDIWResn;
	bd->DiwStrtY >>= bd->ToViewY;
	bd->DiwStopY >>= bd->ToViewY;
d1472 1
a1472 1
	CMOVE(c, io->diwstrt, (((bd->DiwStrtY & 0xff) << 8) |
d1476 1
a1476 2
	c->OpCode = (COPPER_MOVE | CPR_NT_SHT); c->DESTADDR=(int)(&io->diwstop); c->DESTDATA = bd->RGADiwStopYL; CBUMP(cl);
	c->OpCode = (COPPER_MOVE | CPR_NT_LOF); c->DESTADDR=(int)(&io->diwstop); c->DESTDATA = bd->RGADiwStopYS; CBUMP(cl);
d1485 6
a1490 1
	CWAIT(c, 0, 0); CBUMP(&cl);
d1492 8
a1499 1
	CWAIT(c, (vp->DHeight + 1), 0); CBUMP(&cl);
d1501 1
d1506 1
a1506 1
		bd->firstwait->VWAITPOS = -ivg;		/* leave enough space for loading the colours */
@


39.51
log
@display window wraparound code (ifdefed out - hopefully won't be needed).
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.50 92/06/19 12:12:18 spence Exp Locker: spence $
d383 13
d509 1
d704 1
a704 1
    if (bd->LHSFudge)
a1319 1
    UWORD diwstopl, diwstops, diff;
d1335 1
a1335 4
    diff = (((bd->DiwStopY - bd->DiwStrtY) + 1) & bd->ToViewY);
    diwstopl = diwstops = (((bd->DiwStopX <<= pinfo->ToDIWResn) >> 2) & 0xff);
    diwstopl |= ((((bd->DiwStopY >> bd->ToViewY) - diff) & 0xff) << 8);
    diwstops |= (((bd->DiwStopY >>= bd->ToViewY) & 0xff) << 8);
d1337 1
d1343 2
a1344 2
    c->OpCode = (COPPER_MOVE | CPR_NT_SHT); c->DESTADDR=(int)(&io->diwstop); c->DESTDATA = diwstopl; CBUMP(cl);
    c->OpCode = (COPPER_MOVE | CPR_NT_LOF); c->DESTADDR=(int)(&io->diwstop); c->DESTDATA = diwstops; CBUMP(cl);
a1445 1
	UWORD diwstopl, diwstops, diff;
d1452 1
a1452 4
	diff = (((bd->DiwStopY - bd->DiwStrtY) + 1) & bd->ToViewY);
	diwstopl = diwstops = (((bd->DiwStopX <<= pinfo->ToDIWResn) >> 2) & 0xff);
	diwstopl |= ((((bd->DiwStopY >> bd->ToViewY) - diff) & 0xff) << 8);
	diwstops |= (((bd->DiwStopY >>= bd->ToViewY) & 0xff) << 8);
d1454 1
d1460 2
a1461 2
	c->OpCode = (COPPER_MOVE | CPR_NT_SHT); c->DESTADDR=(int)(&io->diwstop); c->DESTDATA = diwstopl; CBUMP(cl);
	c->OpCode = (COPPER_MOVE | CPR_NT_LOF); c->DESTADDR=(int)(&io->diwstop); c->DESTDATA = diwstops; CBUMP(cl);
@


39.50
log
@corrrected ALICE_LHS_FUDGE
to ALICE_LHS_BUG to enable LHS fudging again!
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.49 92/06/11 10:31:58 spence Exp Locker: spence $
d361 11
d1313 8
@


39.49
log
@removed VBLANK_BUG fix from the copperlists - it is now fixed in the
VBlank interrupt server.
Different DIWSTOP values are written for Long and Short Frames. This
removes the extra line at the bottom of odd-sized lace screens.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.48 92/06/09 10:51:07 spence Exp Locker: spence $
d678 1
a678 1
#ifdef ALICE_LHS_FUDGE
@


39.48
log
@reenabled vblank-bug code, and improved it. It now seems to work for
all the current monitors, but we do lose one more line in lace mode.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.47 92/06/08 15:56:52 spence Exp Locker: spence $
d31 6
d309 1
a309 1
    dystrt = (vp->DyOffset & ~(ToViewY));	/* put into ViewPort resolution */
d342 1
a342 1
    dystop += ((v->DyOffset + 1) << ToViewY);		/* inclusive */
d363 1
d370 1
d545 1
d550 1
a550 1

d596 1
d608 1
d678 1
d752 3
d1042 6
a1141 2


a1259 9

		if ((GBASE->Bugs & BUG_VBLANK) && (bd->pinfo->Flags & PROGINFO_VARBEAM))
		{
			c->OpCode = (COPPER_MOVE | CPR_NT_SHT); c->DESTADDR=(int)(&io->vbstrt); c->DESTDATA = bd->mspc->total_rows; CBUMP(&cl);
			c->OpCode = (COPPER_MOVE | CPR_NT_SHT); c->DESTADDR=(int)(&io->vbstop); c->DESTDATA = (bd->mspc->min_row - 1); CBUMP(&cl);
			c->OpCode = (COPPER_MOVE | CPR_NT_LOF); c->DESTADDR=(int)(&io->vbstrt); c->DESTDATA = (bd->mspc->total_rows + 1); CBUMP(&cl);
			c->OpCode = (COPPER_MOVE | CPR_NT_LOF); c->DESTADDR=(int)(&io->vbstop); c->DESTDATA = (bd->mspc->min_row - 1); CBUMP(&cl);
		}

d1295 1
d1303 4
a1307 1
    bd->DiwStopY >>= bd->ToViewY;
d1313 2
a1314 2
    CMOVE(c, io->diwstop, (((bd->DiwStopY & 0xff) << 8) |
                            (((bd->DiwStopX <<= pinfo->ToDIWResn) >> 2) & 0xff))); CBUMP(cl);
d1343 1
a1343 1
	struct CopIns *c;
d1345 1
a1345 1
	c = BuildStdAACopList(&cl, bd->c, bd, pinfo);
a1357 1

d1416 1
d1423 4
a1427 1
	bd->DiwStopY >>= bd->ToViewY;
d1433 2
a1434 2
	CMOVE(c, io->diwstop, (((bd->DiwStopY & 0xff) << 8) |
        	                (((bd->DiwStopX <<= pinfo->ToDIWResn) >> 2) & 0xff))); CBUMP(&cl);
d1445 1
a1445 1
	CWAIT(c, vp->DHeight, 0); CBUMP(&cl);
@


39.47
log
@sets the sprite scandouble bit in bd->FudgedFMode if the monitorspec has
the DOUBLE_SPRITE bit set.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.46 92/05/15 07:25:35 spence Exp Locker: spence $
d14 1
d966 1
a966 1
    if (bd->mspc->ms_Flags & DOUBLE_SPRITES)
a1241 1
#ifdef VBLANK_BUG
d1244 1
a1244 1
			c->OpCode = (COPPER_MOVE | CPR_NT_SHT); c->DESTADDR=(int)(&io->vbstrt); c->DESTDATA = (bd->mspc->total_rows - 1); CBUMP(&cl);
d1246 1
a1246 1
			c->OpCode = (COPPER_MOVE | CPR_NT_LOF); c->DESTADDR=(int)(&io->vbstrt); c->DESTDATA = bd->mspc->total_rows; CBUMP(&cl);
a1248 1
#endif
@


39.46
log
@VBLANK_BUG code (#ifdef ed out)
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.45 92/05/13 11:16:06 spence Exp Locker: spence $
d963 1
a963 1
	bd->FudgedFMode |= 0x4000;	/* bitplane scan double bit */
d965 4
a968 1

@


39.45
log
@Check GBASE->Bugs before implementing chip kludges.
Redefined Overrun[] values for Lores2x and Lores4x modes.
Fudge code now recalls CalcDataFetch() and CalcScroll().
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.44 92/05/05 15:03:02 spence Exp Locker: spence $
d1237 10
@


39.44
log
@no debug!
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.43 92/05/05 14:50:30 spence Exp Locker: spence $
d356 1
a356 2
#ifndef H0_DIWHIGH_OK
    if (ToViewX == 2)
a361 1
#endif
d419 1
a419 1
    {0xfff8, 0xfff8, 0xfff8, 0xfff8},
a452 1
//    WORD   overrun = GBASE->Overrun[bd->Index];
d536 1
a536 1
	if ((m >= CYCLE_16) && (!(vpe->Flags & VPXF_LAST)))
d586 1
a586 1
		if ((WORD)bd->DDFStrt < (WORD)FIRSTFETCH)
a654 2
    UWORD shift = pinfo->ToDIWResn;
    UWORD origscroll = bd->Scroll;
a663 2
     *
     * Apr 29 1992: For now, don't fudge VARBEAM modes.
d666 1
a666 1
    if ((bd->LHSFudge) && (!(pinfo->Flags & PROGINFO_VARBEAM)))
d670 1
a670 2
	if (((HIRES4X) && (bd->Scroll >= 0x70)) ||
	    ((lores4x) && ((bd->Scroll >= 0x80) && (bd->Scroll < 0xf0))))
d673 1
a673 1
		D(kprintf("Hires and Lores 4x cusp case. Scroll = 0x%lx\n", bd->Scroll); WACK;)
a675 5
		bd->Scroll -= (32 << shift);
		bd->Scroll2 -= (32 << shift);
		bd->Offset -= 4;
		bd->Offset2 -= 4;
// 		bd->DDFStop += (4 << shift);
a681 5
		bd->Scroll -= 192;
		bd->Scroll2 -= 192;
		bd->Offset -= 6;
		bd->Offset2 -= 6;
// 		bd->DDFStop += 24;
d683 1
a683 1
	if (lores4x && ((origscroll >= 0x70) && (origscroll < 0x80)))
a687 5
		bd->Scroll -= 192;
		bd->Scroll2 -= 192;
		bd->Offset -= 2;
		bd->Offset2 -= 2;
// 		bd->DDFStop += 24;
d694 6
a699 5
		bd->Scroll -= 64;
		bd->Scroll2 -= 64;
		bd->Offset -= 2;
		bd->Offset2 -= 2;
// 		bd->DDFStop += 8;
a700 1

d732 7
a738 1
    bd->FudgedFMode = fmode;	/* used later by BuildAAColors and ScrollVPort() */
d839 1
a839 1
    BOOL isdpf;
d1327 3
a1329 5
#ifdef H0_DIWHIGH_OK
		diwhigh |= (((bd->DiwStrtX & 0x3) << 3) | ((bd->DiwStopX & 0x3) << 11));
#else
		diwhigh |= (((bd->DiwStrtX & 0x2) << 3) | ((bd->DiwStopX & 0x2) << 11));
#endif
d1339 2
a1340 2
		 * On the last line of the display, change the fmode to 1x but
		 * turn off bitplane DMA by making BPU in bplcon0 = 0.
@


39.43
log
@use VPXF_LAST in ViewPortExtra instead of ViewPort->Modes
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.42 92/05/05 11:31:45 spence Exp Locker: spence $
d26 1
a26 1
#define DEBUG
@


39.42
log
@New RHS Fudges back in. If the ViewPort is 16 or 32 cycle mode, and
vp->Modes VP_LAST bit is not set, then reduce the height of the display
window by one line, and use that line to change bandwidth to 1x, but with
the BPU set to 0 planes. This will reset the BP_LAST chip signal, but
increase the inter-screen gap by one line.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.41 92/04/27 11:53:52 spence Exp Locker: spence $
d26 1
a26 1
/*#define DEBUG*/
d539 1
a539 1
	if ((m >= CYCLE_16) && (!(vp->Modes & VP_LAST)))
@


39.41
log
@Reworked DDFSTRT/STOP, Modulos and Scroll to be optimised. Also
made some code optimisations.
Currently disabled RHSFudging.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.40 92/04/16 16:47:00 spence Exp Locker: spence $
d107 1
a107 1
    D(kprintf("bm->BytesPerRow = 0x%lx\n", vp->RasInfo->BitMap->BytesPerRow);)
d150 1
a150 1
		bd->LHSFudge = FALSE;
d356 1
a356 1
#ifndef GOOD_ALICE
d421 2
a422 2
    {0xfff8, 0xfff0, 0xfff0, 0xfff0},	/* Lores 4x is terminated at the 16th cycle, not the 32nd */
    {0xfff8, 0xfff8, 0xfff8, 0xfff0},
d437 1
a437 1
    {2, 4, 8, 8}	/* SHires */
d455 1
a455 1
    WORD   overrun = GBASE->Overrun[bd->Index];
d479 1
a479 1
    ddfstop = ((((DIWX_TO_CC(bd->DiwStopX) + overrun) - FIRSTFETCH) & maskstop) + FIRSTFETCH);
d481 1
a481 1
    if (ddfstop >= (bd->mspc->total_colorclocks - realstop))
d533 1
d539 4
a542 1
	m =(pinfo->Offset + GBASE->bwshifts[bd->FMode]);
d669 2
d673 1
a673 1
    if (bd->LHSFudge)
d688 1
a688 1
		bd->DDFStop += (4 << shift);
d699 1
a699 1
		bd->DDFStop += 24;
d710 1
a710 1
		bd->DDFStop += 24;
d721 1
a721 1
		bd->DDFStop += 8;
a754 37
#ifdef RHSFUDGE
    /* SHIT! More stupid frigging Fudges. This is because the BPRUN signal is
     * not turned off until the 16th cycle of a 16 and 32 cycle fetch. It would
     * be Verrrry nice if it were turned off after the 8th cycle in the last fetch,
     * but it isn't, so there! So, we have to fudge the Right Hand Side.
     */

    if ((fmode)	/* a quick way to eliminate non-AA fudging */
         && ((bd->DiwStopX << shift) > 0x704))
    {
	if ((LORES4X) && (bd->DDFStop == 0xb8) && (bd->Scroll <= 0x14))
	{
		D(kprintf("Lores 4x RHS case. Scroll = 0x%lx\n\n", bd->Scroll); WACK;)
		DG(struct Custom *io = &custom; io->color[0] = 0x00f;)
		fmode = BANDWIDTH_1X;		/* drop to 1x */
		bd->DDFStop = 0xd8;
	}
	if (bd->DDFStop == 0xc8)
	{
		if ((LORES2X) && (bd->Scroll <= 0x14))
		{
			D(kprintf("Lores 2x RHS case. Scroll = 0x%lx\n\n", bd->Scroll); WACK;)
			DG(struct Custom *io = &custom; io->color[0] = 0xfff;)
			fmode = BANDWIDTH_1X;		/* drop to 1x */
			bd->DDFStop = 0xd8;
		}
		if ((HIRES4X) && (bd->Scroll <= 0x16))
		{
			D(kprintf("Hires 4x RHS case. Scroll = 0x%lx\n\n", bd->Scroll); WACK;)
			DG(struct Custom *io = &custom; io->color[0] = 0x000;)
			fmode = BUS_32;		/* drop to 2x */
			bd->DDFStop = 0xd8;
		}
	}
    }
#endif

d822 4
a825 2
		bd->Modulo2 = -(wpd << 1);
		bd->Modulo2 &= (0xfffe << shift);
d831 1
d844 1
a844 1
    D(kprintf("Modulo = 0x%lx\n", bd->Modulo); WACK;)
d1323 1
a1323 1
    UWORD fmode = (bd->FudgedFMode | GBASE->SpriteFMode);
d1344 1
a1344 1
#ifdef GOOD_ALICE
d1355 16
a1370 1
		CMOVE(c, FMODE, fmode); CBUMP(&cl);
d1372 1
@


39.40
log
@RHS fudging.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.39 92/04/14 11:20:10 spence Exp Locker: spence $
d149 2
d405 1
a405 1
#define DENISE_OFFSET 9	/* really 4.5 colour clocks, but *2 for ints */
d408 10
a417 1
UWORD  StrtFetchMasks[] = {0xfff8, 0xfff8, 0xfff8, 0xfff8};
d421 2
a422 2
    {0xfff8, 0xfff8, 0xfff8, 0xfff8},
    {0xfff8, 0xfff8, 0xfff8, 0xfff8},
d426 1
a426 1
UWORD Overrun[][] =
d428 3
a430 3
    {0, 16, 16, 32},
    {0, 0, 0, 16},
    {0, 0, 0, 0}
d433 1
a433 1
WORD RealStops[][] =
d435 3
a437 3
    {8, 16, 16, 32},
    {8, 8, 8, 16},
    {8, 8, 8, 8}
d443 1
a443 1
    /* CalcDataFetch() calcualtes the DDFSTRT/STOP values for the defined
d452 4
a455 3
    UWORD  overrun = GBASE->RealStops[(ToViewX << GBASE->arraywidth) + bd->FMode];
    UWORD  maskstrt = (pinfo->DDFSTRTMask & GBASE->StrtFetchMasks[bd->FMode]);
    UWORD  maskstop = (pinfo->DDFSTOPMask & GBASE->StopFetchMasks[(ToViewX << GBASE->arraywidth) + bd->FMode]);
d472 1
a472 1
    ddfstrt = ((((DIWX_TO_CC(bd->DiwStrtX) - overrun) - FIRSTFETCH) & maskstrt) + FIRSTFETCH);
d475 2
a476 3
    /* for ddfstop, convert the diwstopx to ColourClocks, and mask.
     * Also, remember that the fetch continues until the end of the
     * block, so in higher fmodes, we can set ddfstop early.
d479 1
a479 2
//    ddfstop = ((DIWX_TO_CC(bd->DiwStopX) - GBASE->Overrun[(ToViewX << GBASE->arraywidth) + bd->FMode]) & maskstop);
    ddfstop = ((((DIWX_TO_CC(bd->DiwStopX) - GBASE->Overrun[(ToViewX << GBASE->arraywidth) + bd->FMode]) - FIRSTFETCH) & maskstop) + FIRSTFETCH);
d481 1
a481 1
    if (ddfstop > (bd->mspc->total_colorclocks - overrun))
d484 1
a484 1
    	ddfstop = (bd->mspc->total_colorclocks - overrun) & maskstop;
d516 1
d563 5
a567 1
	shift += diff;
d574 22
a595 10
	shift -= resn;
	if ((shift == 0) && (diff == resn))
	{
		D(kprintf(">>> Optimising ddfstrt from 0x%lx", bd->DDFStrt);)
		bd->DDFStrt += GBASE->RealStops[(pinfo->ToViewX << GBASE->arraywidth) + bd->FMode];
		D(kprintf(" to 0x%lx\n", bd->DDFStrt); WACK;)
	}
	else
	{
		if (shift >= 0)
d597 12
a608 1
			offset += (2 << GBASE->bwshifts[bd->FMode]);
d610 1
a611 3
	offset += (((shift + 1) / resn) << (1 + GBASE->bwshifts[bd->FMode]));

	shift &= (resn - 1);
d614 1
a614 1
	offset += (LONG)((MIN(0,(vp->DyOffset - bd->cliposcan.MinY)) - ri->RyOffset) * bm->BytesPerRow);
d619 3
a621 2
	bd->Offset = -offset;
	bd->Scroll = shift;
d667 1
a667 1
    if ((bd->DDFStrt == FIRSTFETCH) && (bd->Offset))
d669 47
a715 50
	if (fmode)
	{
		D(kprintf("At FIRSTFETCH\n"); WACK;)

		if (((HIRES4X) && (bd->Scroll >= 0x70)) ||
		    ((lores4x) && ((bd->Scroll >= 0x80) && (bd->Scroll < 0xf0))))
		{
			/* only in this certain range */
			D(kprintf("Hires and Lores 4x cusp case. Scroll = 0x%lx\n", bd->Scroll); WACK;)
			DG(struct Custom *io = &custom; io->color[0] = 0xf00;)
			fmode = BUS_32;	/* drop to 2x */
			bd->Scroll -= (32 << shift);
			bd->Scroll2 -= (32 << shift);
			bd->Offset -= 4;
			bd->Offset2 -= 4;
			bd->DDFStop += (4 << shift);
		}
		if (lores4x && (bd->Scroll >= 0xf0))
		{
			D(kprintf("Lores 4x -> 1x. Scroll = 0x%lx\n", bd->Scroll); WACK;)
			DG(struct Custom *io = &custom; io->color[0] = 0x0f0;)
			fmode = BANDWIDTH_1X;
			bd->Scroll -= 192;
			bd->Scroll2 -= 192;
			bd->Offset -= 6;
			bd->Offset2 -= 6;
			bd->DDFStop += 24;
		}
		if (lores4x && ((origscroll >= 0x70) && (origscroll < 0x80)))
		{
			D(kprintf("Lores 4x cusp case. Scroll = 0x%lx\n", bd->Scroll); WACK;)
			DG(struct Custom *io = &custom; io->color[0] = 0x0f0;)
			fmode = BANDWIDTH_1X;
			bd->Scroll -= 192;
			bd->Scroll2 -= 192;
			bd->Offset -= 2;
			bd->Offset2 -= 2;
			bd->DDFStop += 24;
		}
		if (LORES2X && (bd->Scroll >= 0x70))
		{
			D(kprintf("Lores 2x cusp case. Scroll = 0x%lx\n\n", bd->Scroll); WACK;)
			DG(struct Custom *io = &custom; io->color[0] = 0x0f0;)
			fmode = BANDWIDTH_1X;
			bd->Scroll -= 64;
			bd->Scroll2 -= 64;
			bd->Offset -= 2;
			bd->Offset2 -= 2;
			bd->DDFStop += 8;
		}
d749 1
d784 1
d801 1
d818 3
a820 2
     * (((ddfstop + granularity) - ddfstrt) * 
     *  (LORES:2, HIRES:4, SHIRES:8) / 16)
a821 1
     * granularity = 8, 16 or 32, depending on FMode.
d826 1
d828 11
a838 1
	wpd = ((((bd->DDFStop + GBASE->RealStops[(pinfo->ToViewX << GBASE->arraywidth) + bd->FudgedFMode]) - bd->DDFStrt) << (pinfo->ToViewX + 1)) >> 4);
d840 1
d842 1
a842 1
	bd->Modulo &= (0xfffe << GBASE->bwshifts[bd->FudgedFMode]);
d854 1
a854 1
		bd->Modulo2 &= (0xfffe << GBASE->bwshifts[bd->FudgedFMode]);
@


39.39
log
@Finer DisplayWindow positioning - to 70ns resolution. Still can't go
to 35ns though because of Chip bug (H0 STOP is still tied to the
vertical comparator, so setting this bit leaves the display window on
to the bottom).
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.38 92/04/04 17:30:56 spence Exp Locker: spence $
d38 1
d41 1
d641 1
d652 1
d663 1
d674 1
d713 35
@


39.38
log
@CoarseScroll code sets the DiwStopX to be the MaxX of the DClip for
better visual feedback. Still need to do something with diwstrtx.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.37 92/04/03 10:56:08 spence Exp Locker: spence $
d312 1
a312 1
	dxstop = MIN((dxstrt + dwidth - 1), bd->cliposcan.MaxX);
d330 2
a331 2
    dxstop += ((vdx << ToViewX) + (clip << ToViewX));
    dystop += ((v->DyOffset + 1) << ToViewY);
d352 9
d1278 10
a1287 2
	          (((bd->DiwStrtX & 0x400) >> 5) | ((bd->DiwStrtY & 0x700) >> 8))) |
	          ((bd->DiwStrtX & 0x2) << 3) );
@


39.37
log
@First of the Coarse-scrolling code (#ifdef'ed out for now)
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.36 92/03/24 16:47:22 spence Exp Locker: spence $
d691 2
@


39.36
log
@checks bd->firstwait for NULL before poking it with the CalcIVG() result.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.35 92/03/18 15:58:36 spence Exp Locker: spence $
d172 3
d599 2
d619 1
a619 1
    if (fmode && ((bd->DDFStrt == FIRSTFETCH) && (bd->Offset)))
d621 73
a693 43
	D(kprintf("At FIRSTFETCH\n"); WACK;)

	if (((HIRES4X) && (bd->Scroll >= 0x70)) ||
	    ((lores4x) && ((bd->Scroll >= 0x80) && (bd->Scroll < 0xf0))))
	{
		/* only in this certain range */
		D(kprintf("Hires and Lores 4x cusp case. Scroll = 0x%lx\n", bd->Scroll); WACK;)
		fmode = BUS_32;	/* drop to 2x */
		bd->Scroll -= (32 << shift);
		bd->Scroll2 -= (32 << shift);
		bd->Offset -= 4;
		bd->Offset2 -= 4;
		bd->DDFStop += (4 << shift);
	}
	if (lores4x && (bd->Scroll >= 0xf0))
	{
		D(kprintf("Lores 4x -> 1x. Scroll = 0x%lx\n", bd->Scroll); WACK;)
		fmode = BANDWIDTH_1X;
		bd->Scroll -= 192;
		bd->Scroll2 -= 192;
		bd->Offset -= 6;
		bd->Offset2 -= 6;
		bd->DDFStop += 24;
	}
	if (lores4x && ((origscroll >= 0x70) && (origscroll < 0x80)))
	{
		D(kprintf("Lores 4x cusp case. Scroll = 0x%lx\n", bd->Scroll); WACK;)
		fmode = BANDWIDTH_1X;
		bd->Scroll -= 192;
		bd->Scroll2 -= 192;
		bd->Offset -= 2;
		bd->Offset2 -= 2;
		bd->DDFStop += 24;
	}
	if (LORES2X && (bd->Scroll >= 0x70))
	{
		D(kprintf("Lores 2x cusp case. Scroll = 0x%lx\n\n", bd->Scroll); WACK;)
		fmode = BANDWIDTH_1X;
		bd->Scroll -= 64;
		bd->Scroll2 -= 64;
		bd->Offset -= 2;
		bd->Offset2 -= 2;
		bd->DDFStop += 8;
d695 1
a1193 1
				D(kprintf("pen = 0x%lx\n", pen);)
a1195 1
				    D(kprintf("this one\n");)
@


39.35
log
@bd->cliposcan was not being initilised if the vpe->DClip was set up, but
there was no cm->Coerce/NormalDisplayInfo.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.34 92/03/13 15:41:23 spence Exp Locker: spence $
d1244 6
a1249 3
	ivg = gfx_CalcIVG(v, vp);
        D(kprintf("IVG = 0x%lx\n", ivg); WACK)
        bd->firstwait->VWAITPOS = -ivg;		/* leave enough space for loading the colours */
d1306 6
a1311 3
	ivg = gfx_CalcIVG(v, vp);
        D(kprintf("IVG = 0x%lx\n", ivg); WACK)
        bd->firstwait->VWAITPOS = -ivg;		/* leave enough space for loading the colours */
@


39.34
log
@Made bplcon2 and bplcon3 more compatible in ECS and A machines.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.33 92/02/28 13:38:56 spence Exp Locker: spence $
d147 1
d270 2
a271 1
    if (cm && cm->Type && clip)
d273 9
a281 11
	if ((record = cm->CoerceDisplayInfo) || (record = cm->NormalDisplayInfo))
	{
		bd->cliposcan.MinX = 
			SHORTMAX(record->rec_ClipOScan.MinX,DClip->MinX);
		bd->cliposcan.MinY = 
			SHORTMAX(record->rec_ClipOScan.MinY,DClip->MinY);
		bd->cliposcan.MaxX = 
			SHORTMIN(record->rec_ClipOScan.MaxX,DClip->MaxX);
		bd->cliposcan.MaxY = 
			SHORTMIN(record->rec_ClipOScan.MaxY,DClip->MaxY);
	}
d285 4
a288 1
	bd->cliposcan = vpe->DisplayClip;	/* clear the bd->cliposcan to 0s */
@


39.33
log
@call get_bplcon2().
better use of get_bplcon3() and get_bplcon4()
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.32 92/02/26 11:33:37 spence Exp Locker: spence $
d816 4
d854 1
d857 6
d912 8
a919 1
    bd->bplcon2 = pinfo->bplcon2 | bd->bplcon2;
a1109 1
	    UWORD bplcon3_or;
a1128 1
	    bplcon3_or=get_bplcon3(cm) | bd->bplcon3;
d1130 1
a1130 1
	    D(kprintf("bplcon3_or=%lx\n",bplcon3_or););
d1152 1
a1152 1
			CMOVE(c, io->bplcon3, (((bank & 0x7) << 13) | (loct << 9)) | bplcon3_or); CBUMP(&cl);
d1165 1
a1165 1
	    CMOVE(c,io->bplcon3,bplcon3_or | bd->bplcon3); CBUMP(&cl);
a1280 1
	bd->bplcon0 &= ~(USE_BPLCON3);
@


39.32
log
@All GFX calls go through LVO
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.31 92/02/25 14:22:52 spence Exp Locker: spence $
d97 1
d123 1
a123 1
			if ((vp->ColorMap) && (vp->ColorMap->Type))
d125 1
a125 1
				vp->ColorMap->cm_vpe = _vpe;
d140 1
a140 1
		bd->bplcon2 = 0;
d850 1
a850 2
    bd->bplcon3 |= 0x0c00;
    bd->bplcon4 = 0x11;
a901 1
//    bd->bplcon3 = 0x0;
d1087 2
a1088 1
	
d1108 1
d1124 1
d1134 1
d1139 1
d1142 1
d1150 1
a1150 1
	    CMOVE(c,io->bplcon4,get_bplcon4(cm)); CBUMP(&cl);
@


39.31
log
@Redid InitMVP(). Now initialises the BuildData as well.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.30 92/02/11 11:08:52 spence Exp Locker: spence $
d17 1
d117 1
a117 1
		if (_vpe = (struct ViewPortExtra *)GfxNew(VIEWPORT_EXTRA_TYPE))
d149 1
a149 1
			ve = (struct ViewExtra *)GfxLookUp(v);
d197 1
a197 1
		GfxFree((struct ExtendedNode *)vpe);
d223 1
a223 1
    ULONG mode = getvpmodeid(vp);
d1220 1
a1220 1
	ivg = CalcIVG(v, vp);
d1280 1
a1280 1
	ivg = CalcIVG(v, vp);
@


39.30
log
@OR GBASE->SpriteFMode with the FMode value.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.29 92/01/30 20:02:20 spence Exp Locker: spence $
d82 2
a83 3
/* InitMVP() - must be the 1st function to be called. This is the only function
 * that takes a ProgInfo structure, as this will be pointed to by the vpe.
 * It also takes a pointer to a pointer to a ViewPortExtra, because
d86 2
d90 1
a90 1
ULONG InitMVP(struct View *v, struct ViewPort *vp, struct ViewPortExtra **vpe, struct ProgInfo *pinfo)
d96 2
a97 1
    ULONG  err = MVP_NO_MEM;
d106 7
d132 20
a151 5
	if (_vpe)
	{		
		UWORD FMode;
		D(kprintf("Calculating FMode\n"); WACK;)
		if ((FMode = (UWORD)CalcFMode(vp)) != (UWORD)-1)
d153 1
a153 1
			_vpe->FMode = FMode;
d157 1
a157 1
			err = MVP_NO_DISPLAY;
a158 5
#ifndef MAKEFMODE
		_vpe->Blank = -1;
		_vpe->FMode = 0;
#endif
		D(kprintf("FMode = 0x%lx Flags = 0x%lx\n", _vpe->FMode, _vpe->Flags); WACK;)
d160 9
a168 1
		GOODERR
d170 1
d245 1
a245 1
		D(kprintf("10Hz mode. FMode = 0x%lx\n", vpe->FMode);)
d249 1
a249 1
		vpe->FMode = BANDWIDTH_1X;
d422 3
a424 3
    UWORD  overrun = GBASE->RealStops[(ToViewX << GBASE->arraywidth) + vpe->FMode];
    UWORD  maskstrt = (pinfo->DDFSTRTMask & GBASE->StrtFetchMasks[vpe->FMode]);
    UWORD  maskstop = (pinfo->DDFSTOPMask & GBASE->StopFetchMasks[(ToViewX << GBASE->arraywidth) + vpe->FMode]);
d449 2
a450 2
//    ddfstop = ((DIWX_TO_CC(bd->DiwStopX) - GBASE->Overrun[(ToViewX << GBASE->arraywidth) + vpe->FMode]) & maskstop);
    ddfstop = ((((DIWX_TO_CC(bd->DiwStopX) - GBASE->Overrun[(ToViewX << GBASE->arraywidth) + vpe->FMode]) - FIRSTFETCH) & maskstop) + FIRSTFETCH);
d474 1
a474 1
#define SCROLLRESOLUTION (pinfo->ToViewX + (2 - GBASE->bwshifts[vpe->FMode]))
d508 1
a508 1
	m =(pinfo->Offset + GBASE->bwshifts[vpe->FMode]);
d544 1
a544 1
		bd->DDFStrt += GBASE->RealStops[(pinfo->ToViewX << GBASE->arraywidth) + vpe->FMode];
d551 1
a551 1
			offset += (2 << GBASE->bwshifts[vpe->FMode]);
d554 1
a554 1
	offset += (((shift + 1) / resn) << (1 + GBASE->bwshifts[vpe->FMode]));
d562 1
a562 1
	offset &= (0xfffffffe << GBASE->bwshifts[vpe->FMode]);
d598 1
a598 1
    UWORD fmode = vpe->FMode;
d773 1
a773 1
	offset = (2 << GBASE->bwshifts[vpe->FMode]);
@


39.29
log
@Restricts A2024 10Hz mode to 1x bandwidth.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.28 92/01/29 16:36:28 spence Exp Locker: spence $
d1163 1
a1163 1
    UWORD fmode = bd->FudgedFMode;
@


39.28
log
@ECS uses defaultcolourtable properly.
InitMVP() always calls CalcFMode() for double-buffering compatibility
Checks for RasInfo->BitMap == NULL
Removed BuildNmlECSCopList() - goes through AA version.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.27 92/01/22 16:19:13 spence Exp Locker: spence $
d217 1
d220 2
@


39.27
log
@CalcOffset() could be out by vp->DyOffset rows if no displayclip
was attached to the ViewPort.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.26 92/01/21 13:18:59 chrisg Exp Locker: spence $
d21 1
a21 1
extern UWORD *dflt_clrs;
d100 1
d124 11
a134 19
	{
		if (((_vpe->Flags & VPXF_HAVE_FMODE) == 0) ||
		    (vp->Modes & DUALPF))	/* The 'recommended' intuition way 
						 * to make DUALPF is to manhandle
		    				 * an already built single playfield, so ensure
		    				 * the FMode is correct!
		    				 */
		{
			UWORD FMode;
			D(kprintf("Calculating FMode\n"); WACK;)
			if ((FMode = (UWORD)CalcFMode(vp)) != (UWORD)-1)
			{
				_vpe->FMode = FMode;
				_vpe->Flags |= VPXF_HAVE_FMODE;
			}
			else
			{
				err = MVP_NO_DISPLAY;
			}
d136 2
a137 2
			_vpe->Blank = -1;
			_vpe->FMode = 0;
a138 1
		}
d470 70
a539 63
    /* m is the cycle number:
     * 0 = 2cycle,
     * 1 = 4cycle, .....
     * 4 = 32cycle.
     */
    m =(pinfo->Offset + GBASE->bwshifts[vpe->FMode]);

    /* convert the displaywindow coordinates to 35ns */
    diwstrt = (bd->DiwStrtX << ToDIWResn);

    /* now calculate the colourclock on which the last fetch of the
     * first batch of fetches happens, and convert to 35ns.
     *
     * Note that for 16 and 32 cycles, the last fetch is the 8th cycle.
     */
    datafetch = ((bd->DDFStrt + (2 << MIN(m, 2))) << 3);

    diff = diwstrt - datafetch - 4;	/* Remember the Denise delay */

    /* extra from vp and ri offsets, to 35ns */

    shift = (MIN(0, (vp->DxOffset - bd->cliposcan.MinX)) - ri->RxOffset) << ToDIWResn;	/* to 35ns */

    /* the scroll range, governed by the fetch cycle (32, 16, 8, 4, or 2) and
     * the fmode.
     */
    chunksize = SCROLLRESOLUTION;
    resn = (0x00ff >> chunksize) + 1;	/* scroll range for bplcon1 in 35ns */

    /* add it all together */
    shift += diff;
    D(kprintf("Shift = 0x%lx, resn = 0x%lx, diff = 0x%lx\n", shift, resn, diff); WACK;)

    /* shift now has the total number of 35ns pixels to scroll.
     * How many whole bytes is this (in words)?
     */

    shift -= resn;
    if ((shift == 0) && (diff == resn))
    {
	D(kprintf(">>> Optimising ddfstrt from 0x%lx", bd->DDFStrt);)
	bd->DDFStrt += GBASE->RealStops[(pinfo->ToViewX << GBASE->arraywidth) + vpe->FMode];
	D(kprintf(" to 0x%lx\n", bd->DDFStrt); WACK;)
    }
    else
    {
	if (shift >= 0)
	{
		offset += (2 << GBASE->bwshifts[vpe->FMode]);
	}
    }
    offset += (((shift + 1) / resn) << (1 + GBASE->bwshifts[vpe->FMode]));

    shift &= (resn - 1);

    /* add the vertical offset */
    offset += (LONG)((MIN(0,(vp->DyOffset - bd->cliposcan.MinY)) - ri->RyOffset) * bm->BytesPerRow);

    /* start on the correct boundary */
    offset &= (0xfffffffe << GBASE->bwshifts[vpe->FMode]);

    bd->Offset = -offset;
    bd->Scroll = shift;
d663 1
a663 7
    wpr = (bm->BytesPerRow + 1) >> 1;	/* to words */
    wpd = ((((bd->DDFStop + GBASE->RealStops[(pinfo->ToViewX << GBASE->arraywidth) + bd->FudgedFMode]) - bd->DDFStrt) << (pinfo->ToViewX + 1)) >> 4);
    D(kprintf("ddfstop = 0x%lx, wpr = 0x%lx, wpd = 0x%lx\n", bd->DDFStop, wpr, wpd); WACK;)
    bd->Modulo = ((wpr - wpd) << 1);	/* to bytes */
    bd->Modulo &= (0xfffe << GBASE->bwshifts[bd->FudgedFMode]);

    if (bd->Flags & BD_IS_LACE)
d665 25
a689 2
	D(kprintf("Lace. Was 0x%lx\n", bd->Modulo); WACK;)
	bd->Modulo += bm->BytesPerRow;
d691 1
a691 2

    if (bd->Flags & BD_IS_SDBL)
d693 1
a693 3
	/* Refetch the last line (use the number of bytes actually fetched) */
	bd->Modulo2 = -(wpd << 1);
	bd->Modulo2 &= (0xfffe << GBASE->bwshifts[bd->FudgedFMode]);
d695 1
a695 8
    else
    {
	if (!(bd->Flags & BD_IS_DPF))
	{
		bd->Modulo2 = bd->Modulo;
	}
    }

d790 1
a790 1
    struct BitMap *bm = ri->BitMap;
d792 1
a792 1
    UWORD  bpu;
d796 5
a800 1
    bpu = bm->Depth;
d806 1
d843 1
a843 1
    struct BitMap *bm = ri->BitMap;
d845 1
a845 1
    UWORD  bpu;
d849 5
a853 1
    bpu = bm->Depth;
d859 1
d907 2
a908 1
    struct BitMap *bm = ri->BitMap, *bm2 = NULL;
d910 3
a912 2
    UWORD diff, diff1 = ((bd->Flags & BD_IS_LACE) ? bm->BytesPerRow : 0), diff2;
    int depth, totdepth;
d914 4
a917 1
    totdepth = bm->Depth;
d923 2
a924 1
    if (!(bd->Flags & BD_IS_A2024))
d926 12
a937 10
	for (depth = 0; depth < totdepth; depth++)
	{
		int plane;
		ULONG addr;
		plane = ((((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_HAM)) == (PROGINFO_NATIVE | PROGINFO_HAM)) && (bm->Depth >= 7)) ?
			((depth + 6) & 0x7) : 	/* swap the bitplanes */
			depth);
		if (bm2)
		{
			if (depth & 1)
d939 10
a948 2
				addr = (ULONG)(bm2->Planes[depth >> 1] + bd->Offset2);
				diff = diff2;
d952 1
a952 1
				addr = (ULONG)(bm->Planes[depth >> 1] + bd->Offset);
d955 1
a955 5
		}
		else
		{
			addr = (ULONG)(bm->Planes[plane] + bd->Offset);
			diff = diff1;
a956 1
		c = setplptr(c, cl, (ULONG)(io->bplpt + depth), addr, diff);
d958 1
a958 4
    }
    else
    {
	for (depth = 0; depth < totdepth; depth++)
d960 3
a962 1
		ULONG addr = (ULONG)(bm->Planes[depth] + bd->Offset);
d964 3
a966 2
		c = setplptr(c, cl, (ULONG)(io->bplpt + (depth << 1)), addr, 0);
		c = setplptr(c, cl, (ULONG)(io->bplpt + ((depth << 1) + 1)), (addr + diff1), 0);
d1074 1
a1074 1
		origtableh = origtablel = (UWORD *)&dflt_clrs;
d1181 5
a1185 1
	CMOVE(c, FMODE, fmode); CBUMP(&cl);
a1197 16

    INC_FNCOUNT;
    return(RETERR);
}

ULONG BuildNmlECSCopList(DRIVER_PARAMS)
{
    struct BuildData *bd = (struct BuildData *)vpe->DriverData[0];

    INITERR

    D(kprintf("In BuildNmlECSCopList()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, bd->pinfo); WACK;);

    BuildNmlAACopList(v, vp, vpe);

    D(kprintf("Leaving BuildNmlECSCopList()\n"); WACK;);
@


39.26
log
@killed fetchgbase
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.25 91/12/31 14:27:45 spence Exp Locker: chrisg $
d297 4
a300 4
    dxstrt = (vdx << ToViewX) + dxstrt;
    dystrt = ((v->DyOffset << ToViewY) + dystrt);
    dxstop = (vdx << ToViewX) + dxstop + (clip << ToViewX);
    dystop = (v->DyOffset << ToViewY) + dystop + (clip << ToViewY);
d305 1
a306 1
	bd->DiwStrtX = MAX(dxstrt, (mspc->DeniseMinDisplayColumn << ToViewX));
a307 1
	bd->DiwStrtY = MAX(dystrt, (mspc->min_row << ToViewY));
d309 10
d534 1
a534 1
    offset += (LONG)(((MIN(0,(vp->DyOffset - bd->cliposcan.MinY)) - ri->RyOffset) * bm->BytesPerRow));
@


39.25
log
@Clips display window to hardware limits in the MonitorSpec.
SingleA code.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.24 91/12/20 15:43:48 spence Exp Locker: spence $
a773 1
    struct GfxBase *GB;
a778 1
    FETCHGBASE;
d792 1
a792 1
    bd->bplcon0 |= pinfo->bplcon0 | GB->system_bplcon0 | (v->Modes & LACE) | 
a821 1
    struct GfxBase *GB;
a826 1
    FETCHGBASE;
d840 1
a840 1
    bd->bplcon0 |= pinfo->bplcon0 | GB->system_bplcon0 | (v->Modes & LACE) | 
@


39.24
log
@Small amount of code for A2024 (easier to put it here than on disk).
ScanDbl bit in bd->FudgedFMode now used in time to be of use in
ScrollVP().
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.23 91/11/25 15:53:42 spence Exp Locker: spence $
d91 1
d93 1
d297 14
a310 5
    bd->DiwStrtX = (vdx << ToViewX) + dxstrt;
    bd->DiwStrtY = (v->DyOffset << ToViewY) + dystrt;
    bd->DiwStopX = (vdx << ToViewX) + dxstop + (clip << ToViewX);
    bd->DiwStopY = (v->DyOffset << ToViewY) + dystop + (clip << ToViewY);
    bd->DiwStopY = MIN(bd->DiwStopY, (bd->mspc->total_rows << ToViewY));
d319 32
a556 1
    struct RasInfo *ri;
d882 61
a945 1
    struct ProgInfo *pinfo = bd->pinfo;
a1006 1
    struct ProgInfo *pinfo = bd->pinfo;
a1127 2
    struct RasInfo *ri = vp->RasInfo;
    struct BitMap *bm = ri->BitMap, *bm2 = NULL;
a1129 1
    UWORD diff, diff1 = ((bd->Flags & BD_IS_LACE) ? bm->BytesPerRow : 0), diff2;
a1130 1
    int depth, totdepth;
d1142 1
a1142 47

	totdepth = bm->Depth;
	if ((ri->Next) && (bm2 = ri->Next->BitMap))    /* DualPF */
	{
		diff2 = ((bd->Flags & BD_IS_LACE) ? bm2->BytesPerRow : 0);
		totdepth += bm2->Depth;
	}
	if (!(bd->Flags & BD_IS_A2024))
	{
		for (depth = 0; depth < totdepth; depth++)
		{
			int plane;
			ULONG addr;
			plane = ((((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_HAM)) == (PROGINFO_NATIVE | PROGINFO_HAM)) && (bm->Depth >= 7)) ?
				((depth + 6) & 0x7) : 	/* swap the bitplanes */
				depth);
			if (bm2)
			{
				if (depth & 1)
				{
					addr = (ULONG)(bm2->Planes[depth >> 1] + bd->Offset2);
					diff = diff2;
				}
				else
				{
					addr = (ULONG)(bm->Planes[depth >> 1] + bd->Offset);
					diff = diff1;
				}
			}
			else
			{
				addr = (ULONG)(bm->Planes[plane] + bd->Offset);
				diff = diff1;
			}
			c = setplptr(c, &cl, (ULONG)(io->bplpt + depth), addr, diff);
		}
	}
	else
	{
		for (depth = 0; depth < totdepth; depth++)
		{
			ULONG addr = (ULONG)(bm->Planes[depth] + bd->Offset);

			c = setplptr(c, &cl, (ULONG)(io->bplpt + (depth << 1)), addr, 0);
			c = setplptr(c, &cl, (ULONG)(io->bplpt + ((depth << 1) + 1)), (addr + diff1), 0);
		}
	}
d1183 56
@


39.23
log
@Double DIWSTRT/STOPY in scan doubled modes.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.22 91/11/18 11:24:38 spence Exp Locker: spence $
d204 1
a204 1
    WORD   dxstrt, dxstop, dystrt, dystop, dwidth, dheight;
d218 1
d221 16
a236 3
	dwidth = ((mode == 0x41000) ? 352 : 512);
	vp->DHeight = ((GBASE->DisplayFlags & PAL) ? 256 : 200);
	bd->Flags |= BD_IS_LACE;
d266 1
a266 1
    dystop = (dystrt + vp->DHeight - 1);	/* vp->DHeight is in VP resolution */
d279 1
a279 1
	dxstop = MIN((dxstrt + vp->DWidth - 1), bd->cliposcan.MaxX);
d284 1
a284 1
	dxstop = (dxstrt + vp->DWidth);		/* vp->DWidth is in VP resolution */
d295 1
a295 1
    bd->DiwStrtX = (v->DxOffset << ToViewX) + dxstrt;
d297 1
a297 1
    bd->DiwStopX = (v->DxOffset << ToViewX) + dxstop + (clip << ToViewX);
d312 1
a312 1
UWORD  StrtFetchMasks[] = {0xfff0, 0xfff0, 0xfff0, 0xfff0};
a365 1
//    ddfstrt = ((DIWX_TO_CC(bd->DiwStrtX) + pinfo->DDFExtra) & maskstrt);
a385 2
//	if ((vpe->Flags & VPXF_HAVE_FMODE) && (vpe->FMode == 0))
//		ddfstrt <<= 1;
a386 1
//	bd->Offset -= 2;
d618 7
d629 1
d631 1
a631 3


    if (bd->Flags & BD_IS_LACE)
d633 4
a636 2
	D(kprintf("Lace. Was 0x%lx\n", bd->Modulo); WACK;)
	bd->Modulo += bm->BytesPerRow;
d638 1
d708 1
d711 1
d714 3
a716 1
	bd->Modulo2 = bd->Modulo;
a718 1
    CalcModulos(v, vp, vpe);
d747 4
d760 8
d797 4
d1014 1
a1014 1
    CMOVE(c, io->bpl2mod, (bd->Flags & (BD_IS_DPF | BD_IS_SDBL)) ? bd->Modulo2 : bd->Modulo); CBUMP(cl);
a1039 5
    if (bd->Flags & BD_IS_SDBL)
    {
	fmode |= 0x4000;	/* bitplane scan double bit */
    }

d1052 1
a1052 1
	for (depth = 0; depth < totdepth; depth++)
d1054 8
a1061 8
		int plane;
		ULONG addr;
		plane = ((((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_HAM)) == (PROGINFO_NATIVE | PROGINFO_HAM)) && (bm->Depth >= 7)) ?
			((depth + 6) & 0x7) : 	/* swap the bitplanes */
			depth);
		if (bm2)
		{
			if (depth & 1)
d1063 10
a1072 2
				addr = (ULONG)(bm2->Planes[depth >> 1] + bd->Offset2);
				diff = diff2;
d1076 1
a1076 1
				addr = (ULONG)(bm->Planes[depth >> 1] + bd->Offset);
d1079 1
d1081 4
a1084 1
		else
d1086 4
a1089 2
			addr = (ULONG)(bm->Planes[plane] + bd->Offset);
			diff = diff1;
a1090 1
		c = setplptr(c, &cl, (ULONG)(io->bplpt + depth), addr, diff);
@


39.22
log
@No longer sets bit 3 of Diwhigh (= H0 of diwstrtX - blanks display!!)
Scandbl bit of fmode is not set in bd->FudgedFMode, but only set
when poking the copperlists.

@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.21 91/11/15 10:49:44 spence Exp Locker: spence $
d277 2
a278 1
	dystop += (vp->DHeight - 1);
@


39.21
log
@Initialise bd->ClipOScan if the vp does not have its own.
Put the FMode at the end of the copperlist
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.20 91/11/11 17:08:56 chrisg Exp Locker: spence $
d207 1
a207 1
    D(kprintf("In CalcDispWindow()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, bd->pinfo); WACK;);
d272 1
d334 1
a334 1
    UWORD  maskstop = GBASE->StopFetchMasks[(ToViewX << GBASE->arraywidth) + vpe->FMode];
a564 4
    if (bd->Flags & BD_IS_SDBL)
    {
	fmode |= 0x4000;	/* bitplane scan double bit */
    }
d1001 5
d1048 1
a1048 1
	          ((bd->DiwStrtX & 0x3) << 3) );
@


39.20
log
@ fixed chromapen
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.19 91/11/11 11:46:52 chrisg Exp Locker: chrisg $
d241 4
a244 4
	else
	{
		bd->cliposcan = vpe->DisplayClip;
	}
a873 1
    UWORD fmode = bd->FudgedFMode;
a923 4
	    CMOVE(c, FMODE, fmode); CBUMP(&cl);
#ifdef BADFMODE
	    CMOVE(c, FMODE2, fmode); CBUMP(&cl);
#endif
d993 1
d1049 1
@


39.19
log
@ made scramble colors for ECS 35ns modes.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.18 91/11/08 11:34:04 spence Exp Locker: chrisg $
d822 1
d824 3
d847 1
a847 1
					CMOVE(c, io->color[pen], table[pen]); CBUMP(&cl);
d896 1
d900 1
d942 1
a942 1
				    CMOVE(c, io->color[pen], table[pen+(bank<<5)]); CBUMP(&cl);
@


39.18
log
@Looks for monitor 4 (A2024) and fixes the dwidth if found (should be
on disk, but easier this way).
AAFudge() renamed to Fudge(), and called by ECS code too. Optimised
for ECS by checking if fmode != 0.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.17 91/10/30 19:15:08 spence Exp Locker: spence $
d830 1
a830 1
			D(kprintf("modes=%ld\n",vp->Modes);)
d832 6
@


39.17
log
@Now uses default palette if passed a ViewPort with a NULL ColorMap
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.16 91/10/29 11:31:54 spence Exp Locker: spence $
d200 1
d204 1
a204 1
    WORD   dxstrt, dxstop, dystrt, dystop;
d218 7
d490 1
a490 1
/* AAFudge will detect the overscan cusp cases (h/w limitations), and alter the
d498 1
a498 1
ULONG AAFudge(DRIVER_PARAMS)
d510 1
a510 1
    D(kprintf("In AAFudge()\n"); WACK;)
d512 1
a512 1
    /* We only need to fudge for Hires4x, Lores4x and Lores2x
d516 1
a516 1
    if ((bd->DDFStrt == FIRSTFETCH) && (bd->Offset))
d571 1
a571 1
    D(kprintf("Leaving AAFudge(). Flags = 0x%lx\n", bd->Flags); WACK;)
d607 1
d688 1
a688 1
    AAFudge(v, vp, vpe);
@


39.16
log
@replace vpe->BuildData with vpe->DriverData[0]
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.15 91/10/28 17:06:51 spence Exp Locker: spence $
d21 1
d95 2
a96 2
    D(kprintf("In InitMVP()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, *vpe, pinfo);)
    D(kprintf("vpe->Flags = 0x%lx, vp->DWidth = 0x%lx, vp->DHeight = 0x%lx\n", _vpe->Flags, vp->DWidth, vp->DHeight);)
d103 1
d116 1
a794 1

d805 1
a805 1
    if (cm = vp->ColorMap)
d811 1
a811 1
		UWORD  *table = (UWORD *)cm->ColorTable;
d814 1
a838 4
    else
    {
	ERR(MVP_NO_CM);
    }
d856 1
d861 5
a865 1
    if (cm=vp->ColorMap)
d867 5
a871 1
	if ((cl = vp->DspIns = copinit(vp->DspIns, (((cm->Count << 1) + cm->Count) << 1) + DSPINS_COUNTAA)) && (cl->MaxCount))
d875 1
a875 1
	    UWORD  *table = (UWORD *)cm->ColorTable;
d878 11
d915 3
a917 1
			if (table)
a918 3
			    CMOVE(c, io->bplcon3, (((bank & 0x7) << 13) | (loct << 9)) | bplcon3_or); CBUMP(&cl);
			    for (pen = 0; pen < 32; pen++)
			    {
a922 2
			    }
			    table = (loct ? (UWORD *)cm->ColorTable : (UWORD *)cm->LowColorBits);
@


39.15
log
@Moved AAFudge() code. Now called by the CalcDPF() code.
CalcDPF() also checks for 2nd RasInfo, to ensure true DPF.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.14 91/10/18 16:23:28 spence Exp Locker: spence $
d195 1
a195 1
    struct BuildData *bd = vpe->BuildData;
d316 1
a316 1
    struct BuildData *bd = vpe->BuildData;
d380 1
a380 1
    struct BuildData *bd = vpe->BuildData;
d489 1
a489 1
    struct BuildData *bd = vpe->BuildData;
d568 1
a568 1
    struct BuildData *bd = vpe->BuildData;
d621 1
a621 1
    struct BuildData *bd = vpe->BuildData;
d698 1
a698 1
    struct BuildData *bd = vpe->BuildData;
d736 1
a736 1
    struct BuildData *bd = vpe->BuildData;
d795 1
a795 1
    struct BuildData *bd = vpe->BuildData;
d850 1
a850 1
    struct BuildData *bd = vpe->BuildData;
d955 1
a955 1
    struct BuildData *bd = vpe->BuildData;
d1035 1
a1035 1
    struct BuildData *bd = vpe->BuildData;
@


39.14
log
@Reworked to handle the ProgInfo -> VecInfo changed
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.13 91/10/17 13:59:09 chrisg Exp Locker: spence $
d478 88
d595 1
a595 1
    wpd = ((((bd->DDFStop + GBASE->RealStops[(pinfo->ToViewX << GBASE->arraywidth) + vpe->FMode]) - bd->DDFStrt) << (pinfo->ToViewX + 1)) >> 4);
d597 1
a597 1
    bd->Modulo &= (0xfffe << GBASE->bwshifts[vpe->FMode]);
d623 1
a623 1
    UWORD ddfstrtorig = bd->DDFStrt, ddfstrt1, ddfstrt2;
d625 1
d639 1
d641 2
a642 2
	CalcScroll(v, vp, vpe);	/* assume no error returned */
	ddfstrt2 = bd->DDFStrt;	/* store the (possibly altered) new ddfstrt */
d646 3
a648 2
	bd->Flags &= ~BD_IS_DPF;	/* calculate scroll for plfd 1 */
	CalcScroll(v, vp, vpe);
d650 27
a676 1
	D(kprintf("After 2 CalcScrolls, ddfstrt1 = 0x%lx, ddfstrt2 = 0x%lx\n", bd->DDFStrt, ddfstrt2); WACK;)
d678 3
a680 25
	/* use the minimum ddfstrt value of the two */
	if ((ddfstrt1 = bd->DDFStrt) != ddfstrt2)
	{
		/* handle the fact that we the two ddfstrt values are different */
		offset = (2 << GBASE->bwshifts[vpe->FMode]);
		if (ddfstrt1 < ddfstrt2)
		{
			/* we need to use this new ddfstrt value, and so alter
			 * playfield 2's offset accordingly.
			 */
			D(kprintf("Altering Offset2 by 0x%lx\n", offset); WACK;)
			bd->Offset2 -= offset;
		}
		else /* (ddfstrt2 < ddfstrt1) */
		{
			/* change the ddfstrt value, and the 1st playfield's
			 * offset.
			 */
			D(kprintf("Altering Offset1 by 0x%lx, changing ddfstrt to 0x%lx\n", offset, ddfstrt2); WACK;)
			bd->DDFStrt = ddfstrt2;
			bd->Offset -= offset;
		}
	}

	/* now calculate the modulo values */
a684 1
	CalcModulos(v, vp, vpe);
d686 1
a1048 87

/* AAFudge will detect the overscan cusp cases (h/w limitations), and alter the
 * FMode and everything else accordingly.
 */

#define HIRES4X ((pinfo->ToViewX == 1) && (fmode == BANDWIDTH_4X))
#define LORES4X ((pinfo->ToViewX == 0) && (fmode == BANDWIDTH_4X))
#define LORES2X ((pinfo->ToViewX == 0) && ((fmode == BANDWIDTH_2XNML) || (fmode == BANDWIDTH_2XDBL)))

ULONG AAFudge(DRIVER_PARAMS)
{
    struct BuildData *bd = vpe->BuildData;
    struct ProgInfo *pinfo = bd->pinfo;
    struct RasInfo *ri;
    UWORD shift = pinfo->ToDIWResn;
    UWORD origscroll = bd->Scroll;
    UWORD fmode = vpe->FMode;
    BOOL lores4x = LORES4X;

    INITERR

    D(kprintf("In AAFudge()\n"); WACK;)

    /* We only need to fudge for Hires4x, Lores4x and Lores2x
     * when ddfstrt == FIRSTFETCH.
     */

    if ((bd->DDFStrt == FIRSTFETCH) && (bd->Offset))
    {
	D(kprintf("At FIRSTFETCH\n"); WACK;)

	if (((HIRES4X) && (bd->Scroll >= 0x70)) ||
	    ((lores4x) && ((bd->Scroll >= 0x80) && (bd->Scroll < 0xf0))))
	{
		/* only in this certain range */
		D(kprintf("Hires and Lores 4x cusp case. Scroll = 0x%lx\n", bd->Scroll); WACK;)
		fmode = BUS_32;	/* drop to 2x */
		bd->Scroll -= (32 << shift);
		bd->Scroll2 -= (32 << shift);
		bd->Offset -= 4;
		bd->Offset2 -= 4;
		bd->DDFStop += (4 << shift);
	}
	if (lores4x && (bd->Scroll >= 0xf0))
	{
		D(kprintf("Lores 4x -> 1x. Scroll = 0x%lx\n", bd->Scroll); WACK;)
		fmode = BANDWIDTH_1X;
		bd->Scroll -= 192;
		bd->Scroll2 -= 192;
		bd->Offset -= 6;
		bd->Offset2 -= 6;
		bd->DDFStop += 24;
	}
	if (lores4x && ((origscroll >= 0x70) && (origscroll < 0x80)))
	{
		D(kprintf("Lores 4x cusp case. Scroll = 0x%lx\n", bd->Scroll); WACK;)
		fmode = BANDWIDTH_1X;
		bd->Scroll -= 192;
		bd->Scroll2 -= 192;
		bd->Offset -= 2;
		bd->Offset2 -= 2;
		bd->DDFStop += 24;
	}
	if (LORES2X && (bd->Scroll >= 0x70))
	{
		D(kprintf("Lores 2x cusp case. Scroll = 0x%lx\n\n", bd->Scroll); WACK;)
		fmode = BANDWIDTH_1X;
		bd->Scroll -= 64;
		bd->Scroll2 -= 64;
		bd->Offset -= 2;
		bd->Offset2 -= 2;
		bd->DDFStop += 8;
	}
    }

    if (bd->Flags & BD_IS_SDBL)
    {
	fmode |= 0x4000;	/* bitplane scan double bit */
    }
    bd->FudgedFMode = fmode;	/* used later by BuildAAColors and ScrollVPort() */
    bd->Flags |= BD_FUDGEDFMODE;

    D(kprintf("Leaving AAFudge(). Flags = 0x%lx\n", bd->Flags); WACK;)

    INC_FNCOUNT;
    return(RETERR);
}
@


39.13
log
@killed typedef
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.12 91/10/16 17:22:56 spence Exp Locker: chrisg $
a118 1
		_vpe->pinfo = pinfo;
a194 1
    struct ProgInfo *pinfo = vpe->pinfo;
d196 1
d199 1
a199 1
    UWORD  ToViewY = pinfo->ToViewY;
d203 1
a203 1
    D(kprintf("In CalcDispWindow()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo); WACK;);
a315 1
    struct ProgInfo *pinfo = vpe->pinfo;
d317 1
d325 1
a325 1
    D(kprintf("In CalcDataFetch()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo); WACK;)
a379 1
    struct ProgInfo *pinfo = vpe->pinfo;
d381 1
d399 1
a399 1
    D(kprintf("In CalcScroll()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo);)
a479 1
    struct ProgInfo *pinfo = vpe->pinfo;
d481 1
d487 1
a487 1
    D(kprintf("In CalcModulos()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo); WACK;);
d517 1
a517 1
    if ((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_MODELACE)) == (PROGINFO_NATIVE | PROGINFO_MODELACE))
a520 1
	bd->Flags |= BD_IS_LACE;
a602 1
    struct ProgInfo *pinfo = vpe->pinfo;
d604 1
d612 1
a612 1
    D(kprintf("In MakeAABplcon()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo); WACK;);
d621 1
a621 1
    bd->bplcon0 = pinfo->bplcon0 | GB->system_bplcon0 | (v->Modes & LACE) | 
a640 1
    struct ProgInfo *pinfo = vpe->pinfo;
d642 1
d650 1
a650 1
    D(kprintf("In MakeECSBplcon()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo); WACK;);
d659 1
a659 1
    bd->bplcon0 = pinfo->bplcon0 | GB->system_bplcon0 | (v->Modes & LACE) | 
a699 1
    struct ProgInfo *pinfo = vpe->pinfo;
d701 1
d706 1
a706 1
    D(kprintf("In BuildColours()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo); WACK;);
d711 1
a711 1
	if ((cl = vp->DspIns = copinit(vp->DspIns, pinfo->DspInsCount)) && (cl->MaxCount))
a714 1
		UWORD  bpu = vpe->bpu;
a719 5
		if (bpu)
		{
			CMOVE(c, io->bplcon0, ((pinfo->bplcon0 | GBASE->system_bplcon0) |
						((bpu & 7) << 12))); CBUMP(&cl);
		}
a754 1
    struct ProgInfo *pinfo = vpe->pinfo;
d756 1
d764 1
a764 1
    D(kprintf("In BuildAAColours()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo); WACK;);
d768 1
a768 1
	if ((cl = vp->DspIns = copinit(vp->DspIns, (((cm->Count << 1) + cm->Count) << 1) + pinfo->DspInsCount)) && (cl->MaxCount))
a772 1
	    UWORD bpu = vpe->bpu;
a793 7
#ifdef UNDEF
	    if (bpu)
	    {
		CMOVE(c, io->bplcon0, ((pinfo->bplcon0 | GBASE->system_bplcon0) |
		 (((bpu & 7) << 12) | ((bpu & 8) << 1)))); CBUMP(&cl);
	    }
#endif
d838 2
a839 2
    bd->DiwStrtY >>= pinfo->ToViewY;
    bd->DiwStopY >>= pinfo->ToViewY;
a859 1
    struct ProgInfo *pinfo = vpe->pinfo;
d861 1
d873 1
a873 1
    D(kprintf("In BuildNmlAACopList()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo);)
d944 1
a944 1
    D(kprintf("In BuildNmlECSCopList()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo); WACK;);
a964 1
    struct ProgInfo *pinfo = vpe->pinfo;
d966 1
@


39.12
log
@Takes LUTs off GfxBase. Makes it easier to change the tables if we
need to.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.11 91/10/16 14:05:22 chrisg Exp Locker: spence $
d197 1
a197 1
    BuildData *bd = vpe->BuildData;
d318 1
a318 1
    BuildData *bd = vpe->BuildData;
d382 1
a382 1
    BuildData *bd = vpe->BuildData;
d482 1
a482 1
    BuildData *bd = vpe->BuildData;
d535 1
a535 1
    BuildData *bd = vpe->BuildData;
d606 1
a606 1
    BuildData *bd = vpe->BuildData;
d644 1
a644 1
    BuildData *bd = vpe->BuildData;
d703 1
a703 1
    BuildData *bd = vpe->BuildData;
d764 1
a764 1
    BuildData *bd = vpe->BuildData;
d844 1
a844 1
struct CopIns *BuildStdAACopList(struct CopList **cl, struct CopIns *c, BuildData *bd, struct ProgInfo *pinfo)
d877 1
a877 1
    BuildData *bd = vpe->BuildData;
d956 1
a956 1
    BuildData *bd = vpe->BuildData;
d982 1
a982 1
    BuildData *bd = vpe->BuildData;
@


39.11
log
@  removed setting of sprite scan double bit in fmode.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.10 91/10/15 16:01:23 spence Exp Locker: chrisg $
a20 1
extern UBYTE bwshifts[];
a219 1
	clip = 1;
d253 1
d321 3
a323 3
    UWORD  overrun = RealStops[ToViewX][vpe->FMode];
    UWORD  maskstrt = (pinfo->DDFSTRTMask & StrtFetchMasks[vpe->FMode]);
    UWORD  maskstop = StopFetchMasks[ToViewX][vpe->FMode];
d349 2
a350 2
//    ddfstop = ((DIWX_TO_CC(bd->DiwStopX) - Overrun[ToViewX][vpe->FMode]) & maskstop);
    ddfstop = ((((DIWX_TO_CC(bd->DiwStopX) - Overrun[ToViewX][vpe->FMode]) - FIRSTFETCH) & maskstop) + FIRSTFETCH);
d377 1
a377 1
#define SCROLLRESOLUTION (pinfo->ToViewX + (2 - bwshifts[vpe->FMode]))
d409 1
a409 1
    m =(pinfo->Offset + bwshifts[vpe->FMode]);
d445 1
a445 1
	bd->DDFStrt += RealStops[pinfo->ToViewX][vpe->FMode];
d452 1
a452 1
		offset += (2 << bwshifts[vpe->FMode]);
d455 1
a455 1
    offset += (((shift + 1) / resn) << (1 + bwshifts[vpe->FMode]));
d463 1
a463 1
    offset &= (0xfffffffe << bwshifts[vpe->FMode]);
d508 1
a508 1
    wpd = ((((bd->DDFStop + RealStops[pinfo->ToViewX][vpe->FMode]) - bd->DDFStrt) << (pinfo->ToViewX + 1)) >> 4);
d510 1
a510 1
    bd->Modulo &= (0xfffe << bwshifts[vpe->FMode]);
d567 1
a567 1
		offset = (2 << bwshifts[vpe->FMode]);
a1048 4
//    if ((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_VARBEAM)) == (PROGINFO_NATIVE | PROGINFO_VARBEAM))
//    {
//	fmode |= 0x8000;	/* sprites scan doubling */
//    }
@


39.10
log
@Better DPF support - always  recalculate FMode for dpf viewports.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.9 91/10/04 12:20:01 chrisg Exp Locker: spence $
d1050 4
a1053 4
    if ((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_VARBEAM)) == (PROGINFO_NATIVE | PROGINFO_VARBEAM))
    {
	fmode |= 0x8000;	/* sprites scan doubling */
    }
@


39.9
log
@made use a.protos.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.8 91/09/27 11:14:58 spence Exp Locker: chrisg $
d121 6
a126 1
		if ((_vpe->Flags & VPXF_HAVE_FMODE) == 0)
d466 1
a466 1
    bd->Offset += -offset;
d538 2
d545 6
d555 35
d591 1
d593 1
a593 3
	bd->Offset2 = bd->Offset;
	bd->Scroll2 = bd->Scroll;	
	bd->Modulo2 = bd->Modulo;
a594 2
    CalcScroll(v, vp, vpe);
    CalcModulos(v, vp, vpe);
d770 1
a770 1
    UWORD fmode = vpe->FMode;
a799 12
	    if (bd->Flags & BD_FUDGEDFMODE)
	    {
	    	fmode = bd->FudgedFMode;
	    }
	    if (bd->Flags & BD_IS_SDBL)
	    {
	    	fmode |= 0x4000;	/* bitplane scan double bit */
	    }
	    if ((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_VARBEAM)) == (PROGINFO_NATIVE | PROGINFO_VARBEAM))
	    {
	    	fmode |= 0x8000;	/* sprites scan doubling */
	    }
d882 1
a882 1
    struct BitMap *bm = ri->BitMap, *bm2;
d884 1
a884 1
    UWORD diff = ((bd->Flags & BD_IS_LACE) ? bm->BytesPerRow : 0);
d886 1
a886 1
    int depth, shift = 0;
d899 1
d902 2
a903 6
		UWORD diff2 = ((bd->Flags & BD_IS_LACE) ? bm2->BytesPerRow : 0);
		for (depth = 0; depth < bm2->Depth; depth++)
		{
			c = setplptr(c, &cl, (ULONG)(io->bplpt + ((depth << 1) + 1)), (ULONG)(bm2->Planes[depth] + bd->Offset2), diff2);
		}
		shift = 1;
d905 1
a905 1
	for (depth = 0; depth < bm->Depth; depth++)
d908 1
d912 19
a930 1
		c = setplptr(c, &cl, (ULONG)(io->bplpt + (depth << shift)), (ULONG)(bm->Planes[plane] + bd->Offset), diff);
d976 3
a978 3
#define HIRES4X ((pinfo->ToViewX == 1) && (vpe->FMode == BANDWIDTH_4X))
#define LORES4X ((pinfo->ToViewX == 0) && (vpe->FMode == BANDWIDTH_4X))
#define LORES2X ((pinfo->ToViewX == 0) && ((vpe->FMode == BANDWIDTH_2XNML) || (vpe->FMode == BANDWIDTH_2XDBL)))
d984 1
d987 3
a997 1
    bd->FudgedFMode = 0;
d1001 1
d1003 1
a1003 1
	    ((LORES4X) && ((bd->Scroll >= 0x80) && (bd->Scroll < 0xf0))))
d1007 1
a1007 2
		bd->FudgedFMode = BUS_32;	/* drop to 2x */
		bd->Flags |= BD_FUDGEDFMODE;
d1014 1
a1014 1
	if (LORES4X && (bd->Scroll >= 0xf0))
d1017 1
a1017 2
		bd->FudgedFMode = BANDWIDTH_1X;
		bd->Flags |= BD_FUDGEDFMODE;
d1024 1
a1024 1
	if (LORES4X && ((origscroll >= 0x70) && (origscroll < 0x80)))
d1026 2
a1027 3
		D(kprintf("Hires and Lores 4x cusp case. Scroll = 0x%lx\n", bd->Scroll); WACK;)
		bd->FudgedFMode = BANDWIDTH_1X;
		bd->Flags |= BD_FUDGEDFMODE;
d1037 1
a1037 2
		bd->FudgedFMode = BANDWIDTH_1X;
		bd->Flags |= BD_FUDGEDFMODE;
d1046 12
a1057 1
    D(kprintf("Leaving AAFudge()\n"); WACK;)
@


39.8
log
@New StartFetchMasks.
SpriteScanDouble bit sin VARBEAM screens
AAFudge code for oscan problem.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.7 91/09/23 10:55:30 spence Exp Locker: spence $
a68 3
UWORD __asm CalcIVG(register __a0 struct View *v, register __a1 struct ViewPort *vp);
WORD __asm CalcFMode(register __a0 struct ViewPort *vp);

a654 5
void __asm create_color_bits(register __a0 struct ViewPort * vp, register __a1 void * bit_mask);
int __asm testbit(register __a0 void * base, register __d0 bitnum);
int __asm color_ofs_bits(register __d1 number);
int __asm get_bplcon4(register __a0 struct ColorMap * cm );
int __asm get_bplcon3(register __a0 struct ColorMap * cm );
@


39.7
log
@clipping displaywindow bottom edge properly.
first implementation of support for scandbl.
better handling of MaxOscan at LHS
Set EXTBLNKEN in bplcon3 when needed in colour palette loading.
8 bitplane HAM swaps the bitplanes.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.6 91/09/01 16:53:50 spence Exp Locker: spence $
d285 1
a285 6
UWORD  StrtFetchMasks[][] = 
{
    {0xfff0, 0xffe8, 0xffe8, 0xffd0},
    {0xfff0, 0xffe0, 0xffe0, 0xffe8},
    {0xfff0, 0xfff0, 0xfff0, 0xffe0}
};
d289 1
a289 1
    {0xfff8, 0xfff8, 0xfff8, 0xfff0},
d296 3
a298 3
    {8, 16, 16, 32},
    {4, 8, 8, 16},
    {2, 4, 4, 8}
d321 2
a322 2
    UWORD  maskstrt = StrtFetchMasks[ToViewX][vpe->FMode];
    UWORD  maskstop = (pinfo->DDFSTOPMask & StopFetchMasks[ToViewX][vpe->FMode]);
d733 1
a733 1
    UWORD scandbl = 0;
d763 4
d769 5
a773 1
	    	scandbl |= 0x4000;	/* scan double bit */
d775 1
a775 1
	    CMOVE(c, FMODE, (vpe->FMode | scandbl)); CBUMP(&cl);
d777 1
a777 1
	    CMOVE(c, FMODE2, (vpe->FMode | scandbl)); CBUMP(&cl);
d925 81
@


39.6
log
@horizontal scrolling was accounting for ri->RxOffset twice.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.5 91/09/01 14:59:54 spence Exp Locker: spence $
d240 1
a240 1
    dxstrt = vp->DxOffset;	/* put into ViewPort resolution */
a260 1
    dystop = MIN(dystop, (bd->mspc->total_rows << ToViewY));
d262 6
d272 1
d287 3
a289 3
    {0xfff8, 0xfff0, 0xfff0, 0xffe0},
    {0xfff8, 0xfff8, 0xfff8, 0xfff0},
    {0xfff8, 0xfff8, 0xfff8, 0xfff8}
d359 1
a359 1
    	ddfstop = (bd->mspc->total_colorclocks - overrun); // & maskstop;
d363 1
a363 1
    if ((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_BEAMSYNC)) == (PROGINFO_NATIVE | PROGINFO_BEAMSYNC))
d515 6
a638 2
#define D(x)

d738 1
d754 1
a754 1
	    bplcon3_or=get_bplcon3(cm);
d767 6
a772 1
	    CMOVE(c, FMODE, vpe->FMode); CBUMP(&cl);
d774 1
a774 1
	    CMOVE(c, FMODE2, vpe->FMode); CBUMP(&cl);
a819 1

d840 1
a840 1
    CMOVE(c, io->bpl2mod, (bd->Flags & BD_IS_DPF) ? bd->Modulo2 : bd->Modulo); CBUMP(cl);
d851 2
d855 5
a859 2
    struct Custom *io = &custom;
    struct CopList *cl;
a860 1
    int depth, shift = 0;
a867 1
	UWORD diff = ((bd->Flags & BD_IS_LACE) ? bm->BytesPerRow : 0);
d873 1
d876 1
a876 1
			c = setplptr(c, &cl, (ULONG)(io->bplpt + ((depth << 1) + 1)), (ULONG)(bm2->Planes[depth] + bd->Offset2), diff);
d882 12
a893 4
		c = setplptr(c, &cl, (ULONG)(io->bplpt + (depth << shift)), (ULONG)(bm->Planes[depth] + bd->Offset), diff);
	}
	CMOVE(c, io->diwhigh, ((((bd->DiwStopX & 0x400) << 3) | (bd->DiwStopY & 0x700)) |
	                    (((bd->DiwStrtX & 0x400) >> 5) | ((bd->DiwStrtY & 0x700) >> 8)))); CBUMP(&cl);
d896 3
a898 2
        D(kprintf("CalcIVG = 0x%lx\n", CalcIVG(v,vp)); WACK)
        bd->firstwait->VWAITPOS = -((CalcIVG(v, vp)) << ((bd->Flags & BD_IS_LACE) ? 1 : 0));	/* leave enough space for loading the colours */
@


39.5
log
@No more scrolly jumps!
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.4 91/08/29 15:00:57 spence Exp Locker: spence $
d458 1
a458 1
    offset += (LONG)(((MIN(0,(vp->DyOffset - bd->cliposcan.MinY)) - ri->RyOffset) * bm->BytesPerRow) - (ri->RxOffset >> 3));
@


39.4
log
@no more BADFMODE
/
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.3 91/08/29 11:25:44 spence Exp Locker: spence $
a27 1
/*#define FIXJUMP*/
a444 3
#ifdef FIXJUMP
	offset -= (2 << bwshifts[vpe->FMode]);
#endif
d453 1
a453 11
#ifdef UNDEF
    test = shift + resn;
    if ((test >= 0) && (test < resn))
    {
	offset = 0;
    }
    else
#endif
    {
	offset += ((shift / resn) << (1 + bwshifts[vpe->FMode]));
    }
a454 6
#ifdef UNDEF
    if (m >= 3)
    {
	shift += (m == 3) ? (8 << 3) : (24 << 3);	/* extra scroll range for 16 and 32 cycle */
    }
#endif
a455 6
#ifdef FIXJUMP
    {
	if ((shift == 0) || (shift >= (resn - 4)))
		offset += (2 << bwshifts[vpe->FMode]);
    }
#endif
@


39.3
log
@CalcIVG() was multiplying result by 2 if View was LACED instead of
if ViewPort was LACED.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.2 91/08/27 17:56:08 spence Exp Locker: spence $
d26 1
a26 1
#define BADFMODE
@


39.2
log
@use new custom.h instead of newcustom.h
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.1 91/08/27 16:29:44 spence Exp Locker: spence $
d388 1
a388 1
    WORD   diff, shift, test;
d540 1
d618 1
d786 2
a787 1
//	    if (bpu)
d792 1
a792 1

a863 1
    struct ColorMap *cm = vp->ColorMap;
d875 1
a875 1
	UWORD diff = (((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_MODELACE)) == (PROGINFO_NATIVE | PROGINFO_MODELACE)) ? bm->BytesPerRow : 0);
d896 1
a896 1
        bd->firstwait->VWAITPOS = -((CalcIVG(v, vp)) << ((v->Modes & LACE) ? 1 : 0));	/* leave enough space for loading the colours */
@


39.1
log
@check for ri->Next as well as BD_IS_DPF
Use GfxFree() instead of FreeMem().
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 39.0 91/08/21 17:14:38 chrisg Exp Locker: spence $
d9 1
a9 1
	#include <hardware/newcustom.h>
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 38.10 91/08/21 16:45:17 spence Exp Locker: chrisg $
d172 1
a172 1
		FreeMem(vpe, sizeof(struct ViewPortExtra));
d393 1
a393 1
    if (bd->Flags & BD_IS_DPF)
d399 3
a401 2
    D(kprintf("In CalcScroll()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo); WACK;)
    D(kprintf("DxOffset = 0x%lx, RxOffset = 0x%lx, DyOffset = 0x%lx, RyOffset = 0x%lx\n", vp->DxOffset, ri->RxOffset, vp->DyOffset, ri->RyOffset); WACK;)
a576 1
#define D(x)
d650 2
@


38.10
log
@CalcIVG() called after all instructions are calculated
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 38.9 91/08/21 13:47:30 spence Exp Locker: spence $
@


38.9
log
@Better scrolling, and ddfstrt/stop calculating.
Productivity still buggy.
Still problems with max overscan and ddfstrt in high bws.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 38.8 91/07/27 16:49:52 spence Exp Locker: spence $
a696 1
		struct CopIns *firstwait = c;
d701 1
a723 1
		firstwait->VWAITPOS = -((CalcIVG(v, vp)) << ((v->Modes & LACE) ? 1 : 0));	/* leave enough space for loading the colours */
a759 1
	    struct CopIns *firstwait = c;
d764 1
a812 2
	    D(kprintf("CalcIVG = 0x%lx\n", CalcIVG(v,vp)); WACK)
	    firstwait->VWAITPOS = -((CalcIVG(v, vp)) << ((v->Modes & LACE) ? 1 : 0));	/* leave enough space for loading the colours */
d890 3
@


38.8
log
@Code to better handle the higher bandwidths (HIRES and SUPERHIRES 4x).
Also, DualPF support, and ECS style copperlists on an ECS machine.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 38.7 91/07/22 14:54:32 spence Exp Locker: spence $
d7 2
d27 2
a28 2
#define FMODE io->pad3b[0]	/* bad chips */
/*#define MAKEFMODE*/
d65 1
d101 3
a103 1
    D(kprintf("vp->DxOffset = 0x%lx vp->DyOffset = 0x%lx, v->DxOffset = 0x%lx, v->DyOffset = 0x%lx\n", vp->DxOffset, vp->DyOffset, v->DxOffset, v->DyOffset); WACK;)
d253 1
a253 1
	D(kprintf("dxstrt = 0x%lx, dxstop = 0x%lx, dystrt = 0x%lx, dystop = 0x%lx\n", dxstrt, dxstop, dystrt, dystop); WACK;)
d276 1
d282 2
a283 2
    {0xfff8, 0xfff8, 0xfff8, 0xfff8},
    {0xfff8, 0xfff8, 0xfff8, 0xffe8},
d296 10
a305 3
    {0, 16, 16, 32},
    {0, 8, 8, 16},
    {0, 8, 8, 8}
d318 1
a318 1
    UWORD  ddfstrt, ddfstop;
d320 2
a321 2
    UWORD  overrun = Overrun[ToViewX][vpe->FMode];
    UWORD  maskstrt = (pinfo->DDFSTRTMask & StrtFetchMasks[ToViewX][vpe->FMode]);
d339 3
a341 1
    ddfstrt = ((DIWX_TO_CC(bd->DiwStrtX) + pinfo->DDFExtra) & maskstrt);
d348 2
a349 1
    ddfstop = ((DIWX_TO_CC(bd->DiwStopX) - overrun) & maskstop);
d354 1
a354 1
    	ddfstop = (bd->mspc->total_colorclocks - overrun) & maskstop;
d357 9
d388 1
a388 1
    WORD   diff, shift;
d419 1
a419 1
    diff = diwstrt - datafetch - 4;	/* Why 4? Fudge factor */
d440 27
d468 1
a468 3
    if (shift >= 0)
	offset += (2 << bwshifts[vpe->FMode]);
    offset += ((shift / resn) << (1 + bwshifts[vpe->FMode]));
d473 1
d475 6
d488 1
a488 1
    bd->Offset = -offset;
a501 7
WORD RealStops[][] =
{
    {8, 16, 16, 32},
    {8, 8, 8, 16},
    {8, 8, 8, 8}
};

d570 1
a570 1

a575 1

d605 1
a605 1
    bd->bplcon3 = 0x0c00;
d642 1
a642 1
    bd->bplcon3 = 0x0;
d780 3
d811 1
a811 1
	    CMOVE(c,io->bplcon3,bplcon3_or); CBUMP(&cl);
d862 1
@


38.7
log
@Better Horizontal scrolling.
Also, no longer checks for legal RasInfo and BitMap. Will need to
provide default ColorMap.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 38.6 91/07/09 18:02:18 spence Exp Locker: spence $
d23 1
a23 1
#define DEBUG
a26 1
/*#define TEST*/
d102 1
a102 1
		if (_vpe = (struct ViewPortExtra *)AllocMem(sizeof(struct ViewPortExtra), MEMF_CLEAR|MEMF_PUBLIC))
a110 1
			_vpe->Blank = -1;
d274 21
a304 1
    UWORD  StrtFetchMasks[] = {0xfff8, 0xfff8, 0xfff8, 0xffe0};
a305 1
    UWORD  overrun = 0;
d307 3
a309 2
    UWORD  maskstrt = (pinfo->DDFSTRTMask & StrtFetchMasks[vpe->FMode]);
    UWORD  maskstop = (pinfo->DDFSTOPMask & StrtFetchMasks[vpe->FMode]);
a325 1
//    ddfstrt = ((DIWX_TO_CC(bd->DiwStrtX) + (((pinfo->DDFExtra + 1) << vpe->FMode) - 1)) & maskstrt);
d333 1
a333 5
    ddfstop = (DIWX_TO_CC(bd->DiwStopX) & maskstop);
    if (vpe->FMode)
    {
    	ddfstop -= (overrun = ((vpe->FMode == BANDWIDTH_4X) ? 32 : 16));
    }    /* clip ddfstop to max fetch value */
d338 1
a338 1
    	ddfstop = (bd->mspc->total_colorclocks - overrun);
d358 1
a358 1
    struct BitMap *bm = ri->BitMap;
d368 6
a374 1

d377 6
a382 12
    /* get the basic offset */
    m = pinfo->Offset;	/* first element (Mode) */
    if (((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_SHIFT3)) == (PROGINFO_NATIVE | PROGINFO_SHIFT3))
       && (bm->Depth >= 3)) 	/* what about dpf? */
    {
	m--;
    }
    if (((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_SHIFT5)) == (PROGINFO_NATIVE | PROGINFO_SHIFT5))
        && (bm->Depth >= 5))	/* what about dpf? */
    {
	m--;
    }
d389 2
d392 1
a392 1
    datafetch = ((bd->DDFStrt + (1 << (3 - m))) << 3);
d394 1
a394 1
    diff = diwstrt - datafetch - 4;
d398 1
a398 1
    shift = (MIN(0, (vp->DxOffset - bd->cliposcan.MinX)) + ri->RxOffset) << ToDIWResn;	/* to 35ns */
d400 1
a400 1
    /* the scroll range, governed by the fetch cycle (8, 4, or 2) and
d404 1
a404 1
    resn = (0x00ff >> chunksize) + 1;
d417 6
a422 4
	offset += 2;
    if (vpe->FMode)
	shift += (resn >> bwshifts[vpe->FMode]);
    offset += ((shift / resn) << 1);
a424 14
//    if ((shift == 0) && (offset == 0))
//		{
//			/* no scroll, so we can fetch later */
//			D(kprintf("<<< No early scroll needed.\n"); WACK;)
//			bd->DDFStrt += 8;
//		}

//		if (shift > diff)
//		{
//			/* need an earler fetch */
//			D(kprintf(">>> Earlier fetch needed\n"); WACK;)
//			bd->DDFStrt -= 8;
//		}

d426 1
a426 1
    offset += (LONG)(((ri->RyOffset + MIN(0,(vp->DyOffset - bd->cliposcan.MinY))) * bm->BytesPerRow) + (ri->RxOffset >> 3));
d445 6
d456 2
a457 1
    struct BitMap *bm = vp->RasInfo->BitMap;
d464 5
d481 1
a481 1
    wpd = ((((bd->DDFStop - (WORD)(pinfo->DDFSTOPMask << bwshifts[vpe->FMode])) - bd->DDFStrt) << (pinfo->ToViewX + 1)) >> 4);
d499 28
d539 1
a539 1
    UWORD  bpu = 0;
a553 1
//    bd->bplcon1 = SCROLL((bd->Scroll >> pinfo->ToDIWResn)) | (SCROLL((((bd->Flags & BD_IS_DPF) ? bd->Scroll2 : bd->Scroll) >> pinfo->ToDIWResn)) << 4);
d568 1
a568 1
#define SCROLL(x) ((((x) & 0x003c) >> 2) | (((x) & 0x0003) << 8) | (((x) & 0x00c0) << 4))
d570 1
d573 2
d576 1
a576 1
    UWORD  bpu = 0;
d581 14
d628 3
a635 2
    struct RasInfo *ri = vp->RasInfo;
    struct BitMap *bm = ri->BitMap;
a692 4
int __asm color_ofs_bits(register __d1 number);
int __asm get_bplcon4(register __a0 struct ColorMap * cm );
int __asm get_bplcon3(register __a0 struct ColorMap * cm );

a788 2
/*    CMOVE(c, io->diwstrt, (((bd->DiwStrtY & 0xff) << 8) |
                            (bd->DiwStrtX & 0xff))); CBUMP(cl);*/
a790 2
//    CMOVE(c, io->bplcon3, bd->bplcon3); CBUMP(cl);
//    CMOVE(c, io->bplcon4, bd->bplcon4); CBUMP(cl);
a792 6
/*    CMOVE(c, io->diwstop, (((bd->DiwStopY & 0xff) << 8) |
                            (bd->DiwStopX & 0xff))); CBUMP(cl);*/
    CMOVE(c, io->diwhigh, ((((bd->DiwStopX & 0x400) << 3) | /*((bd->DiwStopX & 0x3) << 11) |*/ (bd->DiwStopY & 0x700)) |
                            (((bd->DiwStrtX & 0x400) >> 5) | /*((bd->DiwStrtX & 0x3) << 3) |*/ ((bd->DiwStrtY & 0x700) >> 8)))); CBUMP(cl);
/*    CMOVE(c, io->diwhigh, ((((bd->DiwStopX & 0x100) << 5) | (bd->DiwStopY & 0x700)) |
                            (((bd->DiwStrtX & 0x100) >> 3) | ((bd->DiwStrtY & 0x700) >> 8)))); CBUMP(cl);*/
d797 1
a797 1
    CMOVE(c, io->bpl2mod, bd->Modulo); CBUMP(cl);
d837 2
d854 1
a855 6
    struct ProgInfo *pinfo = vpe->pinfo;
    BuildData *bd = vpe->BuildData;
    struct RasInfo *ri;
    struct BitMap *bm, *bm2;
    struct Custom *io = &custom;
    struct CopList *cl;
a856 1
    int depth, shift = 0;
a866 61

#ifdef TEST	/* before MakeVP() is altered */
void (*MakeList[])() = 
{
	CalcDispWindow,
	CalcDataFetch,
	CalcModulos,
	CalcBPLOffsets,
	CalcScroll,
	MakeAABplcon,
	BuildColours,
	BuildNmlAACopList,
	NULL,
};

struct ProgInfo pinfo =		/* for HIRES NON-LACE 1x */
{
	{0, 0, 0, 0},	/* QueryHeader */
	MakeList,
	HIRES,
	0x24,
	1,
	0,
	0,
	sizeof(struct BDNmlAA),
	0xfff8,
	0xfff8,
	128,
	1,
	0,
	0,
};

void TestMe(struct View *v, struct ViewPort *vp)
{
    struct ViewPortExtra *oldvpe, *vpe;

    D(kprintf("Testing\n"); WACK;)

    if ((vp->ColorMap) && (vp->ColorMap->Type) && (oldvpe = vp->ColorMap->cm_vpe) )
    {
	if (vpe = AllocMem(sizeof(struct ViewPortExtra), MEMF_CLEAR))
	{
		char **makeit = &MakeList[0];
		int (*nextone)();

		vpe->DisplayClip = oldvpe->DisplayClip;
		D(kprintf("oldvpe DClip = 0x%lx, vpe DClip = 0x%lx\n", &oldvpe->DisplayClip, &vpe->DisplayClip); WACK;)
		vpe->Blank = -1;
		InitMVP(v, vp, vpe, &pinfo);
		nextone = (int (*)())(*makeit);
		while (nextone = (int (*)())(*makeit))
		{
			(*nextone)(v, vp, vpe);
			makeit++;
		}
		FreeMem(vpe, sizeof(struct ViewPortExtra));
	}
    }
}
#endif
@


38.6
log
@DisplayClips now hunkydory.
Still problems with horizontal scrolling, esp LORES and SHIRES
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 38.5 91/07/08 13:46:48 spence Exp Locker: spence $
d22 2
a23 2
/*#define USEGBDEBUG*/
/*#define DEBUG*/
d48 2
a49 1
#define INITERR ULONG  err = (bd->FnCount << 16);
a93 2
    struct BDNml *data = NULL;
    struct ViewExtra *ve;
d97 1
a97 1
    D(kprintf("In InitMVP()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, *vpe, pinfo));
a100 2
    if (data = (struct BDNml *)AllocMem(pinfo->DataSize, MEMF_CLEAR))
    {
a120 3
		struct BDNml *bd = data;

		_vpe->BuildData = (APTR)bd;
d122 1
a122 2
		bd->mspc = GBASE->default_monitor;
		if (v->Modes & EXTEND_VSTRUCT)
d124 8
a131 1
			if((ve = (struct ViewExtra *) GfxLookUp(v)) && ve->Monitor)
d133 1
a133 1
				bd->mspc = ve->Monitor;
a134 6
		}
		if ((_vpe->Flags & VPXF_HAVE_FMODE) == 0)
		{
			D(kprintf("Calculating FMode\n"); WACK;)
			_vpe->FMode = (UWORD)CalcFMode(vp);
			_vpe->Flags |= VPXF_HAVE_FMODE;
a141 1
		INC_FNCOUNT;
a143 1
    }
d149 1
a149 1
    D(kprintf("Leaving InitMVP(), err = 0x%lx, BuildData at 0x%lx\n", err, data); WACK;);
a155 1

a160 3
	if (vpe->BuildData)
		FreeMem(vpe->BuildData, vpe->pinfo->DataSize);

d194 1
a194 1
    struct BDNml *bd = (struct BDNml *)(vpe->BuildData);
d238 1
a238 1
    dxstrt = vp->DxOffset << ToViewX;	/* put into ViewPort resolution */
d248 1
a248 1
	D(kprintf("Clipping! cliposcan at 0x%lx\n", &bd->cliposcan))
d252 1
a252 2
	dxstop = MIN((dxstrt + vp->DWidth), bd->cliposcan.MaxX);
/*	dystop = MAX((dystrt + vp->DHeight), bd->cliposcan.MaxY); */
d264 1
a264 1
    bd->DiwStopY = (v->DyOffset << ToViewY) + dystop + (clip << ToViewY);;
d285 2
a286 1
    struct BDNml *bd = (struct BDNml *)(vpe->BuildData);
d290 2
a291 2
    UWORD  maskstrt = pinfo->DDFSTRTMask;
    UWORD  maskstop = pinfo->DDFSTOPMask;
d301 1
a301 1
     * (((dwiwtrt >> ToViewX) - DENISE_OFFSET) >> 1) & granularity.
d308 1
d320 1
a320 1
    }
a321 2
    /* clip ddfstop to max fetch value */

d343 5
a347 7
    struct BDNml *bd = (struct BDNml *)(vpe->BuildData);
    struct RasInfo *ri;
    struct BitMap *bm;
    LONG   offset;
    UBYTE  bndry[] = {0, 8, 8, 0x18};
    UWORD  border;
    UWORD  diwstrt;
d349 1
d351 1
a351 27
    UBYTE  ToViewX = pinfo->ToViewX;
    UBYTE excess[][][] =
    { /* LORES */
      { /* 1x */
        {0, 0, 0, 0, 0},
        /* 2x */
        {0, 0, 0, 0, 0},
        /* 4x */
        {0, 0, 0, 0, 0},
      },
      /* HIRES */
      { /* 1x */
        {0, 0, 0, 0, 2},
        /* 2x */
        {0, 0, 6, 0, 8},
        /* 4x */
        {0, 0, 14, 0, 16},
      },
      /* SHIRES */
      { /* 1x */
        {0, 0, 2, 4, 6},
        /* 2x */
        {0, 14, 16, 18, 20},
        /* 4x */
        {0, 30, 32, 34, 36}
      }
    };
d357 76
a432 110
    /* Calculate the scroll value to go into bplcon1 (this will be in 35ns units),
     * and the offset (in bytes) from the bitplane pointers.
     *
     * The scroll range depends on the ViewPort mode and bandwidth (see AA spec
     * sheet, last page).
     *
     * The offset depends on the difference between the colourclock number the 
     * window will open and the colourclock number the datafetch starts, and
     * the extra scroll of vp->DxOffset and ri->RxOffset. Also, the offset value
     * must be such that the bitplane pointer is on a 2, 4 or 8 byte boundary when
     * the fetch starts for 1x, 2x and 4x bandwidths.
     *
     * When all that is done, also take into account vertical scrolling with
     * vp->DyOffset and ri->RyOffset.
     *
     * Fun, isn't it?
     *
     ****************************************************************************
     *
     * The basic offsets depend on display mode, FMode, and the difference
     * between the ClockCycle the DisplayWindow will start on and the
     * DDFSTRT value.
     *
     * These values were hand calculated, and (probably) form the following table:
     *
     *                     1x                   2x                   4x
     *           Diff 0  2  4  6  8        0  2  4  6  8        0  2  4  6  8
     *
     * LORES          x  x  x  x  0        x  x  x  x  0        x  x  x  x  0
     * HIRES5-8 -------------------------->
     * SHIRES5-8 ---------------------------------------------->
     *
     * HIRES1-4       x  x  0  x  2        x  x  6  x  8        x  x 14  x 16
     * SHIRES3-4 ------------------------->
     *
     * SHIRES1-2      x  0  2  4  6        x 14 16 18 20        x 30 32 34 36
     *
     * We also need to account for the horizontal offset vp->DxOffset and ri->RxOffset,
     * and the vertical offsets vp->DyOffset and ri->RyOffset.
     *
     */

    if (ri = vp->RasInfo)
    {
	if (bm = ri->BitMap)
	{
		D(kprintf("DxOffset = 0x%lx, RxOffset = 0x%lx, DyOffset = 0x%lx, RyOffset = 0x%lx\n", vp->DxOffset, ri->RxOffset, vp->DyOffset, ri->RyOffset); WACK;)
		shift = (MIN(0, (vp->DxOffset - bd->cliposcan.MinX)) + ri->RxOffset) << pinfo->ToDIWResn;	/* to 35ns */
		chunksize = SCROLLRESOLUTION;
		resn = 0x00ff >> chunksize;
		diwstrt = ((bd->DiwStrtX << pinfo->ToDIWResn) - (DENISE_OFFSET << 2)); /* to 35ns */
		diff = ((diwstrt - (bd->DDFStrt << 3)) & resn);
		diff += shift;

		/* get the basic offset from the LUT */
		{
			UWORD  m, b, d;
			m = pinfo->Offset;	/* first element (Mode) */
			if (((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_SHIFT3)) == (PROGINFO_NATIVE | PROGINFO_SHIFT3))
			   && (bm->Depth >= 3)) 	/* what about dpf? */
			{
				m--;
			}
			if (((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_SHIFT5)) == (PROGINFO_NATIVE | PROGINFO_SHIFT5))
			    && (bm->Depth >= 5))	/* what about dpf? */
			{
				m--;
			}
			b = (vpe->FMode & 1);	/* second element (FMode) 0->0, 1->1, 2->1, 3->2 */
			d = ((((bd->DiwStrtX >> (ToViewX + 1)) & (pinfo->DDFSTRTMask >> ToViewX)) - bd->DDFStrt) >> 1);
			if (d > 4)
			{
				D(kprintf("<<< d = 0x%lx\n", d); WACK;)
				d %= 4;
				bd->DDFStrt -= (~pinfo->DDFSTRTMask) + 1;
				bd->DDFStop -= (~pinfo->DDFSTOPMask) + 1;
			}
			offset = ((LONG)excess[m][b][d]);
			D(kprintf(">>> Basic Offset [%ld][%ld][%ld] = %ld\n", m, b, d, excess[m][b][d]); WACK;)
		}
		D(kprintf(">>> shift = 0x%lx, resn = 0x%lx\n", shift, resn);)
		D(kprintf(">>> chunksize = 0x%lx, diwstrt = 0x%lx\n", chunksize, diwstrt);)
		D(kprintf(">>> diff = 0x%lx\n", diff); WACK;)

		offset = (LONG)(((diff >> (7 - chunksize)) + offset) & 0xfffffffe);
		offset += (LONG)(((ri->RyOffset + MIN(0,(vp->DyOffset - bd->cliposcan.MinY))) * bm->BytesPerRow) + (ri->RxOffset >> 3));
		
		bd->Offset = -offset;
		shift = diff & resn;

		if (shift >= 0x20)
		{
			shift -= 0x20;
		}
		if (diff = ((border = (bd->DDFStrt & bndry[vpe->FMode])) - bndry[vpe->FMode]))
		{
			shift += (border - diff) << 3;
		}
		bd->Scroll = shift;
		GOODERR
	}
	else
	{
		ERR(MVP_NO_BM);
	}
    }
    else
    {
    	ERR(MVP_NO_RI);
    }
d447 2
a448 2
    struct BDNml *bd = (struct BDNml *)(vpe->BuildData);
    struct BitMap *bm;
d466 9
a474 24
    if (vp->RasInfo)
    {
	if (bm = vp->RasInfo->BitMap)
	{
		wpr = (bm->BytesPerRow + 1) >> 1;	/* to words */
		wpd = ((((bd->DDFStop - (WORD)pinfo->DDFSTOPMask) - bd->DDFStrt) << (pinfo->ToViewX + 1)) >> 4);
		bd->Modulo = ((wpr - wpd) << 1);	/* to bytes */
		bd->Modulo &= (0xfffe << bwshifts[vpe->FMode]);

		if ((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_MODELACE)) == (PROGINFO_NATIVE | PROGINFO_MODELACE))
		{
			D(kprintf("Lace. Was 0x%lx\n", bd->Modulo); WACK;)
			bd->Modulo += bm->BytesPerRow;
		}
		GOODERR
    	}
    	else
    	{
    		ERR(MVP_NO_BM);
    	}
    }
    else
    {
    	ERR(MVP_NO_RI);
d476 1
d492 1
a492 1
    struct BDNmlAA *bd = (struct BDNmlAA *)(vpe->BuildData);
d494 2
a495 2
    struct RasInfo *ri;
    struct BitMap *bm;
d502 2
a503 17
    if (ri = vp->RasInfo)
    {
	if (bm = ri->BitMap)
	{
		bpu = bm->Depth;
		if ((ri = ri->Next) && (bm = ri->BitMap))
		{
			bpu += bm->Depth;
			bd->Flags |= BD_IS_DPF;
		}
	}
	else
	{
		ERR(MVP_NO_BM);
	}
    }
    else
d505 2
a506 1
	ERR(MVP_NO_RI);
d512 2
a513 2
//    bd->bplcon1 = SCROLL((bd->Scroll >> pinfo->ToDIWResn)) | (SCROLL((((bd->Flags & BD_IS_DPF) ? ((struct BDDPFAA *)bd)->Scroll2 : bd->Scroll) >> pinfo->ToDIWResn)) << 4);
    bd->bplcon1 = SCROLL(bd->Scroll) | (SCROLL(((bd->Flags & BD_IS_DPF) ? ((struct BDDPFAA *)bd)->Scroll2 : bd->Scroll)) << 4);
d529 1
a529 1
    struct BDNmlAA *bd = (struct BDNmlAA *)(vpe->BuildData);
d574 3
a576 3
    struct BDNml *bd = (struct BDNmlAA *)(vpe->BuildData);
    struct RasInfo *ri;
    struct BitMap *bm;
d583 1
a583 1
    if (ri = vp->RasInfo)
d585 2
a586 1
	if (bm = ri->BitMap)
d588 19
a606 4
		if (cm = vp->ColorMap)
		{
			struct CopList *cl;
			if ((cl = vp->DspIns = copinit(vp->DspIns, pinfo->DspInsCount)) && (cl->MaxCount))
d608 1
a608 14
				struct CopIns *c = cl->CopIns;
				struct CopIns *firstwait = c;
				UWORD  *table = (UWORD *)cm->ColorTable;
				UWORD  bpu = vpe->bpu;
				int    pen;

				D(kprintf("Have CopList at 0x%lx, CopIns at 0x%lx\n", cl, c); WACK;)
				CWAIT(c, 0, 0); CBUMP(&cl); 
				if (bpu)
				{
					CMOVE(c, io->bplcon0, ((pinfo->bplcon0 | GBASE->system_bplcon0) |
								((bpu & 7) << 12))); CBUMP(&cl);
				}
				if (table)
d610 2
a611 11
					ULONG colormask[8];
					D(kprintf("modes=%ld\n",vp->Modes);)
					create_color_bits(vp,colormask);
					for (pen = 0; pen < 32; pen++)
					{
						if (testbit(colormask,pen))
						{
							D(kprintf("color=%ld\n",pen););
							CMOVE(c, io->color[pen], table[pen]); CBUMP(&cl);
						}
					}
a612 6
				bd->c = c;
				firstwait->VWAITPOS = -((CalcIVG(v, vp)) << ((v->Modes & LACE) ? 1 : 0));	/* leave enough space for loading the colours */
			}
			else
			{
				ERR(MVP_NO_DSPINS);
d615 2
a616 4
		else
		{
			ERR(MVP_NO_CM);
		}
d620 1
a620 1
		ERR(MVP_NO_BM);
d625 1
a625 1
	ERR(MVP_NO_RI);
d642 1
a642 1
    struct BDNml *bd = (struct BDNmlAA *)(vpe->BuildData);
d718 1
a718 1
struct CopIns *BuildStdAACopList(struct CopList **cl, struct CopIns *c, struct BDNmlAA *bd, struct ProgInfo *pinfo)
d762 3
a764 3
    struct BDNmlAA *bd = (struct BDNmlAA *)(vpe->BuildData);
    struct RasInfo *ri;
    struct BitMap *bm, *bm2;
d773 1
a773 1
    if (ri = vp->RasInfo)
d775 2
a776 6
	if (bm = ri->BitMap)
	{
		if (cl = vp->DspIns)		/* should have been set up in BuildAAColours() */
		{
			struct CopIns *c;
			UWORD diff = (((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_MODELACE)) == (PROGINFO_NATIVE | PROGINFO_MODELACE)) ? bm->BytesPerRow : 0);
d778 13
a790 20
			c = BuildStdAACopList(&cl, bd->c, bd, pinfo);

			if ((ri->Next) && (bm2 = ri->Next->BitMap))		/* DualPF */
			{
				for (depth = 0; depth < bm2->Depth; depth++)
				{
					c = setplptr(c, &cl, (ULONG)(io->bplpt + ((depth << 1) + 1)), (ULONG)(bm2->Planes[depth] + ((struct BDDPFAA *)bd)->Offset2), diff);
				}
				shift = 1;
			}
			for (depth = 0; depth < bm->Depth; depth++)
			{
				c = setplptr(c, &cl, (ULONG)(io->bplpt + (depth << shift)), (ULONG)(bm->Planes[depth] + bd->Offset), diff);
			}
			CEND(c); CBUMP(&cl);
		}
		else
		{
			ERR(MVP_NO_DSPINS);
		}
d792 1
a792 4
	else
	{
		ERR(MVP_NO_BM);
	}
d796 1
a796 1
	ERR(MVP_NO_RI);
a798 1

d809 1
a809 1
    struct BDNml *bd = (struct BDNmlAA *)(vpe->BuildData);
@


38.5
log
@Horizontal scrolling code.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 38.4 91/07/02 20:05:49 spence Exp Locker: spence $
d22 2
a23 2
#define USEGBDEBUG
#define DEBUG
d252 1
a252 2
    dxstop = (dxstrt + vp->DWidth);	/* vp->DWidth is in VP resolution */
    dystop = (dystrt + vp->DHeight);	/* vp->DHeight is in VP resolution */
d261 2
a262 1
	D(kprintf("(0x%lx, 0x%lx) - (0x%lx, 0x%lx)\n", bd->cliposcan.MinX, bd->cliposcan.MinY, bd->cliposcan.MaxX, bd->cliposcan.MaxY); WACK;)
d264 2
a266 3
	dxstop = MIN(dxstop, bd->cliposcan.MaxX);
	dystop = MAX((MIN(dystop, (bd->cliposcan.MaxY + dystrt)) + (v->DyOffset << ToViewY)), dystop);
	dystop = MIN(dystop, (bd->mspc->total_rows << ToViewY));
d268 5
d277 1
a277 1
    bd->DiwStopY = dystop + (clip << ToViewY);
a285 2
#define D(x)

d444 1
a444 1
		shift = (vp->DxOffset + ri->RxOffset) << pinfo->ToDIWResn;	/* to 35ns */
d467 7
a473 2
			d = MIN(d, 4);

d482 2
a483 1
		offset += (LONG)(((ri->RyOffset + MIN(0, vp->DyOffset)) * bm->BytesPerRow) + (ri->RxOffset >> 3));
d572 2
@


38.4
log
@better ddfstrt/stop, offset and bplcon1/scroll handling.
Still need to handle horizontal scrolling, and displayclips are buggy.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 38.3 91/06/24 14:43:13 spence Exp Locker: spence $
d22 2
a23 2
/*#define USEGBDEBUG*/
/*#define DEBUG*/
d282 2
d349 1
a349 1
#define SCROLLRESOLUTION (0xff >> (pinfo->ToViewX + (2 - bwshifts[vpe->FMode])))
d355 3
d359 1
a359 1
    UWORD  diff, border;
d361 2
a362 96
    INITERR

    D(kprintf("In CalcScroll()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo); WACK;);

    /* The Scroll is the difference between the display window horizontal start, and
     * the first data fetch.
     *
     * Remember - at this stage, the DisplayWindow values are still
     * in ViewPort resolution coordinates.
     *
     * Calculate the scroll in 35ns resolution.
     */

    diwstrt = ((bd->DiwStrtX << pinfo->ToDIWResn) - (DENISE_OFFSET << 2)); /* to 35ns */
    bd->Scroll = ((diwstrt - (bd->DDFStrt << 3)) & SCROLLRESOLUTION);
    if (bd->Scroll >= 0x20)
    {
	bd->Scroll -= 0x20;
    }
    if (diff = ((border = (bd->DDFStrt & bndry[vpe->FMode])) - bndry[vpe->FMode]))
    {
    	bd->Scroll += (border - diff) << 3;
    }

    GOODERR

    D(kprintf("Leaving CalcScroll()\n"); WACK;);
    D(kprintf("scroll = 0x%lx\n", bd->Scroll); WACK;);

    INC_FNCOUNT;
    return(RETERR);

}

ULONG CalcModulos(DRIVER_PARAMS)
{
    struct ProgInfo *pinfo = vpe->pinfo;
    struct BDNml *bd = (struct BDNml *)(vpe->BuildData);
    struct BitMap *bm;
    INITERR
    WORD  wpr, wpd;

    D(kprintf("In CalcModulos()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo); WACK;);
    D(kprintf("Flags = 0x%lx\n", pinfo->Flags);)

    /* The modulo is the number of words-per-row in the bitmap - number of
     * words fetched each scanline.
     *
     * The number of words fetched per scanline is the number of colourclocks
     * between ddfstop and ddfstrt, converted to pixels, /16, =
     * (((ddfstop + granularity) - ddfstrt) * 
     *  (LORES:2, HIRES:4, SHIRES:8) / 16)
     *
     * granularity = 8, 16 or 32, depending on FMode.
     */

    if (vp->RasInfo)
    {
	if (bm = vp->RasInfo->BitMap)
	{
		wpr = (bm->BytesPerRow + 1) >> 1;	/* to words */
		wpd = ((((bd->DDFStop - (WORD)pinfo->DDFSTOPMask) - bd->DDFStrt) << (pinfo->ToViewX + 1)) >> 4);
		bd->Modulo = ((wpr - wpd) << 1);	/* to bytes */
		bd->Modulo &= (0xfffe << bwshifts[vpe->FMode]);

		if ((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_MODELACE)) == (PROGINFO_NATIVE | PROGINFO_MODELACE))
		{
			D(kprintf("Lace. Was 0x%lx\n", bd->Modulo); WACK;)
			bd->Modulo += bm->BytesPerRow;
		}
		GOODERR
    	}
    	else
    	{
    		ERR(MVP_NO_BM);
    	}
    }
    else
    {
    	ERR(MVP_NO_RI);
    }

    D(kprintf("Leaving CalcModulos()\n"); WACK;)
    D(kprintf("Modulo = 0x%lx\n", bd->Modulo); WACK;)

    INC_FNCOUNT;
    return(RETERR);
}

ULONG CalcBPLOffsets(DRIVER_PARAMS)
{
    struct ProgInfo *pinfo = vpe->pinfo;
    struct BDNml *bd = (struct BDNml *)(vpe->BuildData);
    struct RasInfo *ri;
    struct BitMap *bm;
    LONG offset = 0;
d364 1
a364 1
    UBYTE excess[3][3][5] =
d390 1
d393 1
a393 1
    D(kprintf("In CalcBPLOffsets()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo); WACK;);
d395 20
a414 1
    /* The basic offsets depend on display mode, FMode, and the difference
d418 1
a418 1
     * These values were hand calculated, and form the following table:
a436 1

d441 19
a459 29
		UWORD m, b, d;

		m = pinfo->Offset;	/* first element (Mode) */
		if (((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_SHIFT3)) == (PROGINFO_NATIVE | PROGINFO_SHIFT3))
		   && (bm->Depth >= 3)) 	/* what about dpf? */
		{
			m--;
		}
		if (((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_SHIFT5)) == (PROGINFO_NATIVE | PROGINFO_SHIFT5))
		    && (bm->Depth >= 5))	/* what about dpf? */
		{
			m--;
		}
		b = (vpe->FMode & 1);	/* second element (FMode) 0->0, 1->1, 2->1, 3->2 */
		d = ((((bd->DiwStrtX >> (ToViewX + 1)) & (pinfo->DDFSTRTMask >> ToViewX)) - bd->DDFStrt) >> 1);
		d = MIN(d, 4);

		offset = -((LONG)excess[m][b][d]);
		D(kprintf(">>> Basic Offset [%ld][%ld][%ld] = %ld\n", m, b, d, excess[m][b][d]); WACK;)

		if (vp->DxOffset)
		{
			LONG off;
			/* The RxOffset will affect the scroll and offset values.
			 * For the scroll value, change up to 35ns resolution.
			 */

			off = (LONG)vp->DxOffset << pinfo->ToDIWResn;
			if (off <= -(SCROLLRESOLUTION))
d461 1
a461 1
				offset -= (pinfo->ToViewX << (bwshifts[vpe->FMode] + 1));
d463 23
a485 3
			bd->Scroll += off;
			bd->Scroll &= SCROLLRESOLUTION;
			D(kprintf("Changed scroll by 0x%lx\n", off); WACK;)
d487 1
a487 3

		offset -= (((ri->RyOffset + MIN(0, vp->DyOffset)) * bm->BytesPerRow) + (ri->RxOffset >> 3));
		bd->Offset = offset;
d500 2
a501 1
    D(kprintf("Leaving CalcBPLOffsets()\n"); WACK;);
d506 1
d509 55
a563 1
#define D(x)
@


38.3
log
@Attach ViewPortExtra if allocated on the fly,
Calculate the required fmode
better handling of display clips
better handling of LACE mode
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 38.2 91/06/19 13:13:53 spence Exp Locker: spence $
a7 1
	#include "/view.h"
d10 1
d19 1
d22 5
a26 2
#define USEGBDEBUG
#define DEBUG
d61 6
d92 1
d106 1
a106 1
		if (_vpe = AllocMem(sizeof(struct ViewPortExtra), MEMF_CLEAR|MEMF_PUBLIC))
d115 1
d141 4
d153 4
d282 3
a287 2
#define DENISE_OFFSET 17	/* really 8.5 in LORES, but *2 for ints */

d296 4
a299 1
    UBYTE  ToView = pinfo->ToViewX;
d302 13
a314 1
    D(kprintf("In CalcDataFetch()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo); WACK;);
d316 20
a335 65
    /* ddfstrt based on H/W Ref. Manual of:
     * LORES:  (HSTART / 2) - 8.5
     * HIRES:  (HSTART / 2) - 4.5
     * SHIRES: (HSTART / 2) - 2.5 (???)
     */

    ddfstrt = ((bd->DiwStrtX >> ToView) - (ToView ? ((DENISE_OFFSET >> ToView) + 1) : DENISE_OFFSET)) >> 1;

    /* ddfstop based on H/W Ref. Manual of:
     * LORES:  ddfstrt + (8 * (word count - 1))
     * HIRES:  ddfstrt + (4 * (word count - 1))
     * SHIRES: ddfstrt + (2 * (word count - 1)) (???)
     */

/*    ddfstop = ddfstrt + ((((MIN((MIN(bd->DiwStopX, vp->DWidth)), (bd->cliposcan.MaxX + 1))) >> 4) - 1) << (3 - ToView));*/
    ddfstop = ddfstrt + (((MIN((MIN(bd->DiwStopX, vp->DWidth)), (bd->cliposcan.MaxX + 1))) >> 4) - 1);
    D(kprintf("**** ddfstrt = 0x%lx, ddfstop = 0x%lx, diwstopx = %lx, dwidth = %lx\n", ddfstrt, ddfstop, bd->DiwStopX, vp->DWidth); WACK;)

    /* Now the fun starts!! Here's some code stolen from clipstuff.c. The HRM
     * description omits a lot of garb about how Denise really works (I guess
     * noone really knew), so Bart and Raible spent time going through the logic
     * together. This is Bart's story....
     */

    {
	#define COLORCLOCKS (bd->mspc->total_colorclocks)
	#define GRANULARITY 8
	#define MODE_OFFSET ( (vp->Modes & SUPERHIRES)? -2: ((vp->Modes & HIRES)? 0: 4) )
	#define AGNUS_TO_DENISE(x) { (x) += MODE_OFFSET; (x) <<= 1; (x) += ((DENISE_OFFSET >> 1) + 1); }

	WORD hmax, xmax;

	hmax =  COLORCLOCKS - GRANULARITY;
	hmax -= (((hmax-(ddfstrt+2))+1)%GRANULARITY);
	hmax &= ~1;
	xmax = hmax + GRANULARITY;
	AGNUS_TO_DENISE(xmax);

	bd->DiwStopX = MAX(bd->DiwStopX, xmax);

	/* bart - dfstop can be computed directly from dwstrt, dwstop and 
	 * dfstrt.  first, determine the number of lores pixels you to
	 * display and convert to the least number of color clocks which
	 * will display those pixels. next, add those colorclocks to the
	 * dfstrt position which must already have been aligned to a legal 
	 * position. next, make sure that granularity restrictions are
	 * respected. this gives an upper bound to fetches to display 
	 * all desired pixels. last, convert this upper bound to a lower
	 * bound final dfstop which reflects the value that will respect 
	 * such an upper bound 
	 */
	
	ddfstop = ddfstrt + (MAX(((bd->DiwStopX - bd->DiwStrtX) + 1),0) >> 1);
	ddfstop = (ddfstop + (GRANULARITY - 1)) & (~(GRANULARITY - 1));
	ddfstop -= ((ddfstrt) & (GRANULARITY - 1));

	if (ddfstop > hmax) 
	{
		D(kprintf("ddfstop (0x%lx) > hmax (0x%lx)\n", ddfstop, hmax); WACK;)
		ddfstop = hmax;
	}
	
    }

    /* I told you it was fun. Anyway, on with the show....*/
d337 2
a338 2
    bd->DDFStrt = (ddfstrt & pinfo->DDFSTRTMask);
    bd->DDFStop = (ddfstop & pinfo->DDFSTOPMask);
d346 41
a386 1
#define D(x)
d388 1
a388 3
#define DENISE_DELAY 5	/* delay of 5 clocks cycles between data read and ready
			 * (fig 6-9 HRM)
			 */
d396 1
a396 1
    UWORD  bpr, bpd;
d401 11
d416 11
a426 9
	    	bpr = (bm->BytesPerRow + 1) >> 1;	/* to words */
    		bpd = (bd->DDFStop - bd->DDFStrt + DENISE_DELAY) >> (3 - pinfo->ToViewX);	/* to words */
    		bd->Modulo = (((bpr - bpd) << 1) & 0xfffe) - 2;	/* why -2 ??? */
    		if ((pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_MODELACE)) == (PROGINFO_NATIVE | PROGINFO_MODELACE))
    		{
    			D(kprintf("Lace. Was 0x%lx\n", bd->Modulo); WACK;)
    			bd->Modulo += bm->BytesPerRow;
    		}
    		GOODERR
a444 2
extern UBYTE bwshifts[];

d451 28
d483 24
d511 39
a549 2
		bd->Offset = -((vp->DxOffset >> (4 - pinfo->ToViewX + bwshifts[vpe->FMode])) + 
		              (((ri->RyOffset + MIN(0, vp->DyOffset)) * bm->BytesPerRow) + (ri->RxOffset >> 3))) - 2;	/* -2 for early fetch */
d569 1
a569 24
ULONG CalcScroll(DRIVER_PARAMS)
{
    struct ProgInfo *pinfo = vpe->pinfo;
    struct BDNml *bd = (struct BDNml *)(vpe->BuildData);
    struct RasInfo *ri;
    struct BitMap *bm;
    INITERR

    D(kprintf("In CalcScroll()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo); WACK;);

    /* Remember - at this stage, the DisplayWindow values are still
     * in ViewPort resolution coordinates.
     */
     bd->Scroll = ((vp->DxOffset + bd->DiwStrtX - DENISE_DELAY) + 1) & ((0xf << bwshifts[vpe->FMode]) | 0x3);
/*     bd->Scroll = (bd->DiwStrtX - (bd->DDFStrt << pinfo->ToViewX) - (DENISE_DELAY << 1) + 1) & 0xf;*/
    GOODERR

    D(kprintf("Leaving CalcScroll()\n"); WACK;);
    D(kprintf("scroll = 0x%lx\n", bd->Scroll); WACK;);

    INC_FNCOUNT;
    return(RETERR);

}
d609 3
a611 1
    bd->bplcon1 = SCROLL((bd->Scroll << 1)) | (SCROLL((((bd->Flags & BD_IS_DPF) ? ((struct BDDPFAA *)bd)->Scroll2 : bd->Scroll) << 1)) << 4);
a626 1
    struct ProgInfo *pinfo = vpe->pinfo;
a628 2
    struct RasInfo *ri;
    struct BitMap *bm;
d787 2
a788 1
	    if (bpu)
a807 1
				    D(kprintf("color=%ld\n",pen+(bank<<5)););
d856 2
a857 2
    CMOVE(c, io->diwhigh, ((((bd->DiwStopX & 0x400) << 3) | ((bd->DiwStopX & 0x3) << 11) | (bd->DiwStopY & 0x700)) |
                            (((bd->DiwStrtX & 0x400) >> 5) | ((bd->DiwStrtX & 0x3) << 3) | ((bd->DiwStrtY & 0x700) >> 8)))); CBUMP(cl);
@


38.2
log
@better copinit() count.
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 38.1 91/06/14 11:49:38 spence Exp Locker: spence $
d8 1
a11 1
	#include "/view.h"
d20 3
a22 3
/*#define USEERR*/
/*#define USEGBDEBUG*/
/*#define DEBUG*/
d57 3
d100 4
d113 1
d124 8
d156 5
d245 3
a247 2
	dxstop = MIN((dxstrt + vp->DWidth),  bd->cliposcan.MaxX);
	dystop = MIN((dystrt + vp->DHeight), bd->cliposcan.MaxY);
d253 1
a253 1
    bd->DiwStopY = (v->DyOffset << ToViewY) + dystop + (clip << ToViewY);
d355 1
d420 1
a420 1
		              ((ri->RyOffset * bm->BytesPerRow) + (ri->RxOffset >> 3))) - 2;	/* -2 for early fetch */
d501 1
a501 1
    bd->bplcon0 = pinfo->bplcon0 | GB->system_bplcon0 |
a541 2
UWORD __asm CalcIVG(register __a0 struct View *v, register __a1 struct ViewPort *vp);

d613 1
a613 1
				firstwait->VWAITPOS = -(CalcIVG(v, vp));	/* leave enough space for loading the colours */
d677 1
a677 1
	    	    kprintf("cmask[%ld] = 0x%lx\n", i, colormask[i]);
d714 2
a715 1
	    firstwait->VWAITPOS = -(CalcIVG(v, vp));	/* leave enough space for loading the colours */
@


38.1
log
@Improvements
@
text
@d3 1
a3 1
*	$Id: buildvp.c,v 38.0 91/06/05 13:19:54 spence Exp Locker: spence $
d639 1
a639 1
	if ((cl = vp->DspIns = copinit(vp->DspIns, pinfo->DspInsCount)) && (cl->MaxCount))
d652 7
d671 1
@


38.0
log
@Just get it under RCS. Really rough!!
@
text
@d3 1
a3 1
*	$Id: Exp $
d20 4
a23 3
#define USEERR
#define DEBUG
#define TEST
d25 6
d32 1
a32 1
#define D(x) {x}
d45 1
a45 1
#define INC_FNCOUNT {bd->FnCount++;}
d54 1
a54 1
#define RETERR
d71 4
a74 1
 * that takes a ProgInfo structure, as this will be pointed to by the vpe
d77 1
a77 1
ULONG InitMVP(DRIVER_PARAMS, struct ProgInfo *pinfo)
d79 3
a81 1
    APTR   data = NULL;
d84 3
a86 1
    D(kprintf("In InitMVP()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, pinfo); WACK;);
d88 1
a88 1
    if (data = AllocMem(pinfo->DataSize, MEMF_CLEAR|MEMF_PUBLIC))
d90 14
a103 1
	if (vpe)
d105 11
a115 3
		struct BDNml *bd = (struct BDNml *)data;
		vpe->BuildData = data;
		vpe->pinfo = pinfo;
a118 2
	else
		err = MVP_NO_VPE;
d126 24
d157 4
d169 2
a170 2
    UWORD  dxstrt, dxstop, dystrt, dystop;
    struct Rectangle cliposcan;
d184 1
a184 1
            (DClip->MinX) | (DClip->MinY));	/* do we have a DClip? */
d186 1
a186 2
    if ((cm && cm->Type) &&
        ((record = cm->CoerceDisplayInfo) || (record = cm->NormalDisplayInfo)))
d188 16
a203 12
	cliposcan.MinX = 
		SHORTMAX(record->rec_ClipOScan.MinX,DClip->MinX);
	cliposcan.MinY = 
		SHORTMAX(record->rec_ClipOScan.MinY,DClip->MinY);
	cliposcan.MaxX = 
		SHORTMIN(record->rec_ClipOScan.MaxX,DClip->MaxX);
	cliposcan.MaxY = 
		SHORTMIN(record->rec_ClipOScan.MaxY,DClip->MaxY);
    }
    else
    {
    	cliposcan = vpe->DisplayClip;
d209 8
a216 6
    dxstrt = v->DxOffset + vp->DxOffset;	/* in View resolution ie LORES */
    dystrt = v->DyOffset + vp->DyOffset;	/* in View resolution ie LORES */
    dxstop = ((dxstrt << ToViewX) + vp->DWidth);
    						/* vp->DWidth is in VP resolution */
    dystop = ((dystrt << ToViewY) + vp->DHeight);
    						/* vp->DHeight is in VP resolution */
a217 1
    /* Do we need to clip it? */
d220 12
a231 10
	dxstrt = MAX(dxstrt, cliposcan.MinX);
	dystrt = MAX(dystrt, cliposcan.MinY);
	dxstop = MIN(dxstop, cliposcan.MaxX);
	dystop = MIN(dystop, cliposcan.MaxY);
    }

    bd->DiwStrtX = dxstrt;
    bd->DiwStrtY = dystrt;
    bd->DiwStopX = (dxstop >> ToViewX);
    bd->DiwStopY = (dystop >> ToViewY);
d237 1
a237 1
    return(MVP_OK);
d245 5
d254 1
d264 1
a264 1
    ddfstrt = (bd->DiwStrtX - (ToView ? ((DENISE_OFFSET >> ToView) + 1) : DENISE_OFFSET)) >> 1;
d272 51
a322 1
    ddfstop = ddfstrt + ((8 >> ToView) * ((vp->DWidth >> 4) - 1));
d325 1
a325 1
    bd->DDFStop = ((ddfstop + 7) & pinfo->DDFSTOPMask);
d331 1
a331 1
    return(MVP_OK);
d347 1
d354 7
a360 4
    		bpd = (bd->DDFStop - bd->DDFStrt + DENISE_DELAY) >> 2;	/* to words */
    		bd->Modulo = ((bpr - bpd) & 0xfffe) - 2;	/* why -2 ??? */
    		if (pinfo->Flags & (PROGINFO_NATIVE | PROGINFO_MODELACE))
    			bd->Modulo += bpr;
d373 2
a374 2
    D(kprintf("Leaving CalcModulos()\n"));  ; WACK;  
    D(kprintf("Modulo = 0x%lx\n", bd->Modulo); WACK;);
d380 2
d396 2
a397 2
		bd->Offset = (ri->RyOffset * bm->BytesPerRow) + 
		             (ri->RxOffset >> 4);
d427 6
a432 16
    if (ri = vp->RasInfo)
    {
	if (bm = ri->BitMap)
	{
		bd->Scroll = ((v->DxOffset + vp->DxOffset) - bd->DDFStrt - (DENISE_DELAY << 1) + 1) & 0xf;
		GOODERR
	}
	else
	{
		ERR(MVP_NO_BM);
	}
    }
    else
    {
    	ERR(MVP_NO_RI);
    }
d480 1
a480 1
    bd->bplcon1 = SCROLL(bd->Scroll) | (SCROLL(((bd->Flags & BD_IS_DPF) ? ((struct BDDPFAA *)bd)->Scroll2 : bd->Scroll)) << 4);
d483 1
a483 1
    bd->bplcon4 = 0;
d492 1
a492 1
struct CopIns * __regargs setplptr(struct CopIns *c, struct CopList **cl, ULONG reg, ULONG value)
d494 17
a510 1
    D(kprintf("setpltr(), address = 0x%lx, value = 0x%lx\n", reg, value); WACK;)
a511 3
    c->OpCode = COPPER_MOVE; c->DESTADDR = (WORD)reg; c->DESTDATA = (WORD)(value >> 16); CBUMP(cl);
    c->OpCode = COPPER_MOVE; c->DESTADDR = (WORD)(reg + 2); c->DESTDATA = (WORD)(value & 0xffff); CBUMP(cl);
    return(c);
d521 1
a521 1
ULONG BuildAAColours(DRIVER_PARAMS)
d523 19
d543 2
a548 1
    struct GfxBase *GB;
d553 1
a553 1
    D(kprintf("In BuildAAColours()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo); WACK;);
a554 1
    FETCHGBASE;
d567 2
a568 3
				UWORD bpu = vpe->bpu;
				int bank, loct, pen;
				UBYTE depth = bm->Depth;
d572 1
a572 7
				CMOVE(c, io->bplcon0, ((pinfo->bplcon0 | GB->system_bplcon0) |
							(((bpu & 7) << 12) | ((bpu & 8) << 1)))); CBUMP(&cl);
				/* Colour banks are each 32 colours long.
				 * If there are less than 5 bitplanes in the BitMap, treat
				 * this as a special case.
				 */
				if (depth < 5)
d574 2
a575 26
					for (loct = 0; loct < 2; loct++)	/* MSBs, then LSBs of colours */
					{
						if (table)	/* could be NULL if no LowColorBits */
						{
							CMOVE(c, io->bplcon3, (loct << 9)); CBUMP(&cl);
							for (pen = 0; pen < (1 << depth); pen++)
							{
								CMOVE(c, io->color[pen], table[pen]); CBUMP(&cl);
							}
							if ((depth < DPF_OFFSET_PLANE) && (ri->Next) && (ri->Next->BitMap))	/* uh-oh. Dualplayfield! */
							{
								for (pen = DPF_OFFSET_COLOUR; pen < (DPF_OFFSET_COLOUR + (1 << ri->Next->BitMap->Depth)); pen++)
								{
									CMOVE(c, io->color[pen], table[pen]); CBUMP(&cl);
								}
							}
							if ((depth < SPR_OFFSET_PLANE) && (vp->Modes & SPRITES))
							{
								for (pen = SPR_OFFSET_COLOUR; pen < (SPR_OFFSET_COLOUR + 16); pen++)
								{
									CMOVE(c, io->color[pen], table[pen]); CBUMP(&cl);
								}
							}
							table = (UWORD *)cm->LowColorBits;
						}
					}
d577 1
a577 1
				else
d579 4
a582 1
					for (bank = 0; bank < (1 << (depth - 5)); bank++)
d584 1
a584 1
						for (loct = 0; loct < 2; loct++)	/* MSBs, then LSBs of colours */
d586 2
a587 9
							if (table)
							{
								CMOVE(c, io->bplcon3, (((bank & 0x7) << 13) | (loct << 9))); CBUMP(&cl);
								for (pen = 0; pen < 32; pen++)
								{
									CMOVE(c, io->color[pen], table[pen]); CBUMP(&cl);
								}
							}
							table = (loct ? (UWORD *)cm->ColorTable : (UWORD *)cm->LowColorBits);
d614 75
d695 1
a695 1
struct CopIns * __regargs BuildStdAACopList(struct CopList **cl, struct CopIns *c, struct BDNmlAA *bd, struct ProgInfo *pinfo)
d699 12
d712 1
a712 3
                            ((bd->DiwStrtX >> 2) & 0xff))); CBUMP(cl);*/
    CMOVE(c, io->diwstrt, (((bd->DiwStrtY & 0xff) << 8) |
                            (bd->DiwStrtX & 0xff))); CBUMP(cl);
d715 4
a718 2
    CMOVE(c, io->bplcon3, bd->bplcon3); CBUMP(cl);
    CMOVE(c, io->bplcon4, bd->bplcon4); CBUMP(cl);
d720 5
a724 7
                            ((bd->DiwStopX >> 2) & 0xff))); CBUMP(cl);*/
    CMOVE(c, io->diwstop, (((bd->DiwStopY & 0xff) << 8) |
                            (bd->DiwStopX & 0xff))); CBUMP(cl);
/*    CMOVE(c, io->diwhigh, ((((bd->DiwStopX & 0x400) << 3) | ((bd->DiwStopX & 0x3) << 11) | (bd->DiwStopY & 0x700)) |
                            (((bd->DiwStrtX & 0x400) >> 5) | ((bd->DiwStrtX & 0x3) << 3) | ((bd->DiwStrtY & 0x700) >> 8)))); CBUMP(cl);*/
    CMOVE(c, io->diwhigh, ((((bd->DiwStopX & 0x100) << 5) | (bd->DiwStopY & 0x700)) |
                            (((bd->DiwStrtX & 0x100) >> 3) | ((bd->DiwStrtY & 0x700) >> 8)))); CBUMP(cl);
d730 2
d739 1
a739 1
    struct BDNml *bd = (struct BDNmlAA *)(vpe->BuildData);
d747 2
a748 1
    D(kprintf("In BuildNmlAACopList()\nView = 0x%lx, ViewPort = 0x%lx, VPExtra = 0x%lx\nProgInfo = 0x%lx\n", v, vp, vpe, vpe->pinfo); WACK;);
d757 2
d765 1
a765 1
					c = setplptr(c, &cl, (ULONG)(io->bplpt + ((depth << 1) + 1)), (ULONG)(bm2->Planes[depth] + ((struct BDDPFAA *)bd)->Offset2));
d771 1
a771 1
				c = setplptr(c, &cl, (ULONG)(io->bplpt + (depth << shift)), (ULONG)(bm->Planes[depth] + bd->Offset));
d797 21
d828 1
a828 1
	BuildAAColours,
d842 1
a842 1
	40,
d846 1
d865 1
@
