head     39.21;
branch   ;
access   ;
symbols  rel39_24:39.21 rel39_18:39.16 rel39_97:39.11 rel39_90:39.11 rel39_89:39.11 rel39_82:39.10 rel39_76:39.8 rel39_71:39.6 rel39_65:39.6 rel39_64:39.5 rel39_61:39.5 rel39_60:39.5 rel39_55:39.3 rel39_52:39.3 rel39_47:39.3 rel39_39:39.3 rel39_38:39.3 rel39_37:39.3 rel39_35:39.3 rel39_34:39.3 V37_30:37.1 V37_29:37.1 V37_28:37.1 V37_27:37.1 V37_25:37.1 V37_24:37.1 V37_23:37.1 V37_22:37.1 V37_21:37.1 V37_20:37.1 V37_19:37.1 V37_17:37.1 V37_15:37.1 V37_14:37.1 V37_13:37.1 V37_12:37.1 V37_11:37.1 V37_10:37.1 V37_9:37.1 V37_8:37.1 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.61 V36_208:36.61 V36_207:36.61 V36_205:36.61 V36_203:36.61 V36_202:36.61 V36_201:36.61 V36_200:36.61 V36_199:36.61 V36_198:36.61 V36_196:36.61 V36_195:36.61 V36_194:36.60 V36_193:36.60 V36_192:36.59 V36_191:36.59 V36_190:36.58 V36_189:36.58 V36_188:36.58 V36_186:36.57 V36_185:36.56 V36_184:36.56 V36_182:36.56 V36_181:36.55;
locks    ; strict;
comment  @ * @;


39.21
date     93.05.06.12.10.47;  author spence;  state Exp;
branches ;
next     39.20;

39.20
date     93.05.06.10.56.30;  author spence;  state Exp;
branches ;
next     39.19;

39.19
date     93.05.05.19.12.12;  author spence;  state Exp;
branches ;
next     39.18;

39.18
date     93.05.05.15.51.53;  author spence;  state Exp;
branches ;
next     39.17;

39.17
date     93.05.05.15.32.50;  author spence;  state Exp;
branches ;
next     39.16;

39.16
date     93.02.24.16.57.38;  author spence;  state Exp;
branches ;
next     39.15;

39.15
date     93.02.22.10.17.47;  author spence;  state Exp;
branches ;
next     39.14;

39.14
date     93.02.09.15.25.23;  author spence;  state Exp;
branches ;
next     39.13;

39.13
date     93.01.20.13.33.43;  author chrisg;  state Exp;
branches ;
next     39.12;

39.12
date     92.11.23.16.25.12;  author spence;  state Exp;
branches ;
next     39.11;

39.11
date     92.08.27.12.11.06;  author spence;  state Exp;
branches ;
next     39.10;

39.10
date     92.08.17.16.51.09;  author spence;  state Exp;
branches ;
next     39.9;

39.9
date     92.08.06.11.27.54;  author spence;  state Exp;
branches ;
next     39.8;

39.8
date     92.07.10.17.03.22;  author spence;  state Exp;
branches ;
next     39.7;

39.7
date     92.07.09.12.06.40;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     92.06.09.10.55.31;  author chrisg;  state Exp;
branches ;
next     39.5;

39.5
date     92.05.05.11.57.47;  author chrisg;  state Exp;
branches ;
next     39.4;

39.4
date     92.04.28.15.32.56;  author spence;  state Exp;
branches ;
next     39.3;

39.3
date     92.01.07.16.07.25;  author spence;  state Exp;
branches ;
next     39.2;

39.2
date     91.12.19.13.22.51;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     91.11.26.16.25.03;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.15.52;  author chrisg;  state Exp;
branches ;
next     37.6;

37.6
date     91.05.20.11.07.33;  author chrisg;  state Exp;
branches ;
next     37.5;

37.5
date     91.05.03.15.44.47;  author chrisg;  state Exp;
branches ;
next     37.4;

37.4
date     91.05.03.11.14.25;  author chrisg;  state Exp;
branches ;
next     37.3;

37.3
date     91.05.02.14.35.55;  author chrisg;  state Exp;
branches ;
next     37.2;

37.2
date     91.05.02.13.02.31;  author chrisg;  state Exp;
branches ;
next     37.1;

37.1
date     91.01.30.17.15.21;  author bart;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.18.42;  author spence;  state Exp;
branches ;
next     36.61;

36.61
date     90.11.02.17.35.56;  author spence;  state Exp;
branches ;
next     36.60;

36.60
date     90.10.25.16.28.12;  author spence;  state Exp;
branches ;
next     36.59;

36.59
date     90.10.11.12.21.48;  author spence;  state Exp;
branches ;
next     36.58;

36.58
date     90.10.08.13.14.26;  author bart;  state Exp;
branches ;
next     36.57;

36.57
date     90.09.28.12.13.02;  author bart;  state Exp;
branches ;
next     36.56;

36.56
date     90.09.12.15.28.36;  author bart;  state Exp;
branches ;
next     36.55;

36.55
date     90.09.11.16.30.57;  author bart;  state Exp;
branches ;
next     36.54;

36.54
date     90.09.11.16.04.33;  author bart;  state Exp;
branches ;
next     36.53;

36.53
date     90.09.07.14.35.30;  author bart;  state Exp;
branches ;
next     36.52;

36.52
date     90.08.03.11.47.20;  author bart;  state Exp;
branches ;
next     36.51;

36.51
date     90.08.02.11.37.33;  author bart;  state Exp;
branches ;
next     36.50;

36.50
date     90.07.27.16.55.39;  author bart;  state Exp;
branches ;
next     36.49;

36.49
date     90.07.21.00.04.08;  author bart;  state Exp;
branches ;
next     36.48;

36.48
date     90.07.20.23.01.30;  author bart;  state Exp;
branches ;
next     36.47;

36.47
date     90.07.20.22.52.46;  author bart;  state Exp;
branches ;
next     36.46;

36.46
date     90.07.20.18.11.28;  author bart;  state Exp;
branches ;
next     36.45;

36.45
date     90.07.20.17.03.47;  author bart;  state Exp;
branches ;
next     36.44;

36.44
date     90.07.20.14.21.28;  author bart;  state Exp;
branches ;
next     36.43;

36.43
date     90.07.18.22.39.22;  author bart;  state Exp;
branches ;
next     36.42;

36.42
date     90.07.18.21.32.16;  author bart;  state Exp;
branches ;
next     36.41;

36.41
date     90.07.18.20.48.47;  author bart;  state Exp;
branches ;
next     36.40;

36.40
date     90.07.18.20.46.26;  author bart;  state Exp;
branches ;
next     36.39;

36.39
date     90.07.18.20.27.45;  author bart;  state Exp;
branches ;
next     36.38;

36.38
date     90.03.28.09.09.55;  author bart;  state Exp;
branches ;
next     36.37;

36.37
date     90.03.01.13.53.00;  author bart;  state Exp;
branches ;
next     36.36;

36.36
date     90.02.22.13.36.54;  author bart;  state Exp;
branches ;
next     36.35;

36.35
date     89.04.29.15.41.41;  author bart;  state Exp;
branches ;
next     36.34;

36.34
date     89.03.17.18.20.16;  author bart;  state Exp;
branches ;
next     36.33;

36.33
date     89.03.06.22.08.36;  author bart;  state Exp;
branches ;
next     36.32;

36.32
date     89.02.28.14.42.19;  author bart;  state Exp;
branches ;
next     36.31;

36.31
date     89.02.24.09.43.08;  author bart;  state Exp;
branches ;
next     36.30;

36.30
date     89.02.17.22.03.21;  author bart;  state Exp;
branches ;
next     36.29;

36.29
date     89.02.15.16.07.10;  author bart;  state Exp;
branches ;
next     36.28;

36.28
date     89.02.14.18.22.07;  author bart;  state Exp;
branches ;
next     36.27;

36.27
date     89.02.14.10.11.49;  author bart;  state Exp;
branches ;
next     36.26;

36.26
date     89.02.01.17.52.07;  author bart;  state Exp;
branches ;
next     36.25;

36.25
date     89.02.01.17.40.34;  author bart;  state Exp;
branches ;
next     36.24;

36.24
date     89.02.01.11.22.51;  author bart;  state Exp;
branches ;
next     36.23;

36.23
date     89.01.31.15.38.32;  author bart;  state Exp;
branches ;
next     36.22;

36.22
date     89.01.24.15.37.41;  author bart;  state Exp;
branches ;
next     36.21;

36.21
date     89.01.19.17.27.54;  author bart;  state Exp;
branches ;
next     36.20;

36.20
date     89.01.18.13.53.57;  author bart;  state Exp;
branches ;
next     36.19;

36.19
date     89.01.16.15.50.10;  author bart;  state Exp;
branches ;
next     36.18;

36.18
date     88.10.17.15.08.21;  author bart;  state Exp;
branches ;
next     36.17;

36.17
date     88.10.06.19.02.00;  author bart;  state Exp;
branches ;
next     36.16;

36.16
date     88.10.06.13.53.02;  author bart;  state Exp;
branches ;
next     36.15;

36.15
date     88.10.03.10.53.05;  author bart;  state Exp;
branches ;
next     36.14;

36.14
date     88.10.01.13.24.23;  author bart;  state Exp;
branches ;
next     36.13;

36.13
date     88.09.30.19.49.12;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     88.09.30.19.37.37;  author bart;  state Exp;
branches ;
next     36.11;

36.11
date     88.09.30.19.21.38;  author bart;  state Exp;
branches ;
next     36.10;

36.10
date     88.09.30.19.16.00;  author bart;  state Exp;
branches ;
next     36.9;

36.9
date     88.09.30.18.05.47;  author bart;  state Exp;
branches ;
next     36.8;

36.8
date     88.07.28.20.37.38;  author bart;  state Exp;
branches ;
next     36.7;

36.7
date     88.07.28.20.01.52;  author bart;  state Exp;
branches ;
next     36.6;

36.6
date     88.07.28.13.02.42;  author bart;  state Exp;
branches ;
next     36.5;

36.5
date     88.07.23.17.07.52;  author bart;  state Exp;
branches ;
next     36.4;

36.4
date     88.05.26.16.33.50;  author bart;  state Exp;
branches ;
next     36.3;

36.3
date     88.05.24.17.09.25;  author bart;  state Exp;
branches ;
next     36.2;

36.2
date     88.05.17.22.49.00;  author dale;  state Exp;
branches ;
next     36.1;

36.1
date     88.03.10.16.11.17;  author dale;  state Exp;
branches ;
next     ;


desc
@@


39.21
log
@IsAUCopIns() was too large. Now downcoded in misc.asm
@
text
@/******************************************************************************
*
*	$Id: copper.c,v 39.20 93/05/06 10:56:30 spence Exp Locker: spence $
*
******************************************************************************/

#include <exec/types.h>
#include <exec/nodes.h>
#include <exec/lists.h>
#include <exec/memory.h>
#include <exec/alerts.h>
#include "/copper.h"
#include "/gfx.h"
#include "/monitor.h"
#include "tune.h"
#include "/view.h"
#include "/display.h"
#include "/gfxbase.h"
#include "/macros.h"
#include "/gfxpragmas.h"
#include "gfxprivate.h"
#include <hardware/custom.h>
#include <pragmas/exec_pragmas.h>
#include "c.protos"

/* copper driver */
/*#define DEBUG*/
#define USEGBDEBUG
 
#ifdef USEGBDEBUG
#define GBDEBUG if (GBASE->Debug)
#else
#define GBDEBUG
#endif

#ifdef DEBUG
#define D(x) {GBDEBUG {x};}
#else
#define D(x)
#endif

/* #define NO_CLIP_VP */

#define QWE

#ifdef QWE
#define HFIX(x) (((x)*(cs->ratioh))>>4)
#else
#define HFIX(x)	((x))
#endif

#define CLIP_VPOS(x)    (MAX((x),0))
/* #define CLIP_VPOS(x)    (MAX((x),min_ytop)) */ 
/* clip to absolute minimum of 0 to allow for "pre-screen" instructions */

#define MAKE_DY_POS(x)	(x)
/* #define MAKE_DY_POS(x)	(MAX((x),0)) */
/* tmp hack from Dale, Bart needs to check out */

/*#define HACKDEBUG*/

/*#define NAMEDEBUG*/

#define NEWDOWNCODE

extern struct Custom custom;

static struct copstuff
{
    struct CopList *first;
    SHORT   *copptr;
    SHORT   *copIptr;
    SHORT   maxins;	/* number of allocated slots */
    SHORT   beamx,beamy;
    SHORT   flags;
    SHORT   cnt;    /* number of instructions for LOF list left */
    SHORT   icnt;   /*      for SHORT FRAME LIST left*/
    SHORT   DyOffset;   /* from view */
    UWORD   moreflags;	/* misc */
    SHORT   *fcopptr;	/* first copptr location for hack_hwait stuff */
    SHORT   *cop2ptr;	/* hedley stuff */
    SHORT   *cop3ptr;	/* hedley stuff */
    SHORT   *cop4ptr;	/* hedley stuff */
    SHORT   *cop5ptr;	/* hedley stuff */
    SHORT   cnt2;
    SHORT   cnt3;
    SHORT   cnt4;
    SHORT   cnt5;
#ifdef QWE
    int ratioh;
    UWORD colorclocks;
#endif
    SHORT   ibeamx,ibeamy;
    ULONG   topline;
    UWORD   thisbeamy;
    UWORD   totalrows;
};
#define COPPERVPOS_OVERFLOW 1
#define COPPERIVPOS_OVERFLOW 8
#define STRADDLES_256 VPXF_STRADDLES_256
#define STRADDLES_512 VPXF_STRADDLES_512
#define WHOLE_LINE 64

#ifdef RAMDEBUG
extern	UBYTE	Debug;
#endif

#ifndef	NO_CLIP_VP

void __regargs mark_coplist(struct CopList *cl,UWORD mark)
{
    struct CopIns *c = cl->CopPtr;

    do
    {
	if((3&(c->OpCode)) == CPRNXTBUF)
	{
		cl = c->NXTLIST; 
		if(!cl) goto MARK_DONE;
		c = cl->CopPtr;
	}
	do
	{
	    if((3&(c->OpCode)) == COPPER_WAIT)
	    {
		if ((c->VWAITPOS == 10000) && (c->HWAITPOS == 255))
		{
		    goto MARK_DONE;
		}
		else
		{
		    c->OpCode |= mark;
		    c++;
		}
	    }

	    while ((3&(c->OpCode)) == COPPER_MOVE) 
	    {
		c->OpCode |= mark;
		c++;
	    }

	}   while ((3&(c->OpCode)) == COPPER_WAIT);

    }   while ((3&(c->OpCode)) == CPRNXTBUF);

MARK_DONE:	;

}

#endif

void __regargs append_clist(cstuff,element,vp,user)
struct copstuff *cstuff;
struct CopList *element;
struct ViewPort *vp;
BOOL user;
{
    struct CopList *cl;

#ifndef	NO_CLIP_VP
    struct ColorMap *cm = vp->ColorMap;
#endif

    D(kprintf("checking cstuff->first=%lx element=%lx\n",cstuff->first,element);)
    if (element != 0) 
	if (element->Count != 0)
	{
	    /* count instructions */
	    D(kprintf("now count instructions in this list\n");)
	    cl = cstuff->first;
	    cstuff->first = element;
	    for( ; element; element = element->Next)
	    {
		element->CopSStart = 0;
		element->CopLStart = 0;
		element->_CopList = cl; /* link to next */
		element->_ViewPort = vp;
		element->CopPtr = element->CopIns;  /* initialize */
		cstuff->maxins += element->Count;   /* count instructions */
	    }

#ifndef	NO_CLIP_VP

	    if( (user) && (cm) && (cm->Flags & USER_COPPER_CLIP)) 
	    {
		mark_coplist( cstuff->first, CPR_NT_SYS );
	    }

#endif
	    /* removing next line takes care of most */
	    /* out of memory cases for wait(260)->255,5 hack */
	    /*cstuff->maxins--;*/   /* try not to count multiple ends */
	}
}

BOOL __asm IsAUCopIns(register __a0 struct ViewPort *vp, register __a1 struct CopList *cl);

#define PROTOTYPE_DISPLAY
#ifdef  PROTOTYPE_DISPLAY

#include "/displayinfo_internal.h"

#define MrgCopAllocMem(numbytes,flags) (APTR)(AllocMem(numbytes,flags))

ULONG mrgcop(view)
register struct View *view;
{
    /* merge the different srcs of copper instructions into one stream */
    struct CopIns *c,*old_c;  /* ptr to copper bitplane instructions */
    struct CopList *cl,*nxtcl, *prevcl = NULL;
    struct UCopList *qwe;
    LONG nxtbeam;
    struct copstuff copstuff;
    struct cprlist *loflist,*shflist;
    struct ViewPort *vp, *firstvp;
    struct ViewExtra *ve = NULL;
    struct ViewPortExtra *vpe = NULL;
    struct MonitorSpec *mspc;
    UBYTE first_vp_type = NULL;
    UWORD allocated;

    mspc = GBASE->natural_monitor;

    if (view->Modes & EXTEND_VSTRUCT)
    {
	if((ve = (struct ViewExtra *) gfx_GfxLookUp(view)) && ve->Monitor)
	{
	    mspc = ve->Monitor;
	}
    }

    D(kprintf("MRGCOP(%lx)\n",view);)

    /* construct link list of all copper sources and count instructions */
    copstuff.moreflags = 0;
    copstuff.first = 0;
    copstuff.maxins = 0;
    copstuff.DyOffset = view->DyOffset;

    if( mspc->ms_Flags & MSF_REQUEST_A2024 ) 
    {
	first_vp_type = 2;
    }

    GBASE->hedley_flags = 0;
    for( vp = view->ViewPort; vp ; vp = vp->Next)
    {
	D(kprintf("loop vp = 0x%lx\n", vp);)

	/* Check that we want to use this ViewPort.
	 * a) if VP_HIDE is set, then ignore this ViewPort.
	 * b) if vp->DspIns is NULL, then ignore this ViewPort. We need to
	 * check for DspIns being NULL, because that is the case where the ViewPort
	 * is off the bottom of the display, but there may still be Spr/Clr/UCopIns
	 * copperlists which we do not want to merge.
	 */
	if (((vp->Modes & VP_HIDE) == 0) && (vp->DspIns))
	{
	    D(kprintf("not hidden\n");)	    	
	 /* make sure no hybrid system */
	    switch( first_vp_type )
	    {
		case( 0 ):
		{
		    if (vp->ExtendedModes & VPF_A2024) 
		    {
			first_vp_type = 3; /* compatibility mode */
		    }
		    else 
		    {
			first_vp_type = 1;
		    }
		}   break;

		case( 1 ):
		{
		    if (vp->ExtendedModes & VPF_A2024) 
		    {
			/*vp->Modes &= VP_HIDE;*/
			vp->Modes = 0;		/* VP_HIDE *must* be clear to be here - spence Oct 24 1990 */
		    }
		}   break;

		case( 2 ):
		{
		    ULONG hedley_mode = new_mode(vp);

		    copstuff.DyOffset = 0x2c;
		    if ((vp->ExtendedModes & VPF_A2024) ||
		        ((hedley_mode == A2024TENHERTZ_KEY) ||
			 (hedley_mode == A2024FIFTEENHERTZ_KEY)))
		    {
			first_vp_type = 3;
			GBASE->hedley_flags = VPF_A2024;
			if (vp == (struct ViewPort *)GBASE->hedley[5])
			{
				/* show this is the same ViewPort as last time */
				GBASE->hedley_flags |= 0x80;
			}
			else
			{
				/* show this is a new viewport */
				GBASE->hedley_flags &= 0xff7f;
				GBASE->hedley[5] = (ULONG)vp;
			}

		    	if (hedley_mode == A2024TENHERTZ_KEY)
		    	{
		    		GBASE->hedley_flags |= VPF_TENHZ;		    		
		    	}

			if ((vp->RasInfo) && (GBASE->hedley[6] = (ULONG)(vp->RasInfo->BitMap)))
			{
			    	GBASE->hedley_tmp = vp->RasInfo->BitMap->Depth;
			}
			else
			{
				GBASE->hedley_tmp = 0;
			}
		    }
		    else
		    {
			first_vp_type = 1;
		    }
		}   break;

		case( 3 ):
		{
		    /*vp->Modes &= VP_HIDE;*/
		    vp->Modes = 0;
		}   break;

		default:
		{
		    /* error */
		}   break;
	    }

	    /*if ((vp->Modes & VP_HIDE) == 0)*/
	    {
		if ((vp->ColorMap) && (vp->ColorMap->Type) && (vp->ColorMap->cm_vpe))
			vp->ColorMap->cm_vpe->cop1ptr=vp->ColorMap->cm_vpe->cop2ptr=0;
				/* clear cache pointers! */
		append_clist(&copstuff,vp->DspIns,vp,FALSE);
		append_clist(&copstuff,vp->SprIns,vp,FALSE);
		append_clist(&copstuff,vp->ClrIns,vp,FALSE);
		for ( qwe = vp->UCopIns; qwe ; qwe = qwe->Next)
		{
		    append_clist(&copstuff,qwe->FirstCopList,vp,TRUE);
		}

	    }
	}
    }
	/* 200 micro seconds to get to here */
    
    if (copstuff.first == 0)
    {
	/* This happens if MrgCop() is called with no ViewPorts in the list,
	 * or all the ViewPorts are marked as hidden. This shouldn't happen,
	 * and if it does, it's an intuition bug.
	 */
	return(MCOP_NOP);
    }
    D(kprintf("total number of instructions = %lx\n",copstuff.maxins);)
    D(kprintf("moreflags = %lx\n",copstuff.moreflags);)

    copstuff.maxins += 10;	/* add 2 for auto ping/pong, + extras for extra
    				 * WAIT 255 instructions. This should be plenty
    				 * (probably more than enough, even for Motivator).
    				 */

    copstuff.beamx = copstuff.beamy = 0;

    copstuff.ibeamx = copstuff.ibeamy = 0;

    copstuff.flags = view->Modes;

	allocated = 0;
    /* must always have a LOF buffer */
    if ((loflist = view->LOFCprList) == 0)
    {
		D(kprintf("User set up no hardware LOFcopper lists\n");)
		loflist = (struct cprlist *)MrgCopAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
		if (!loflist)
			goto bad_mrgcop ;
		D(kprintf("allocated loflist %lx\n", loflist);)
		allocated |= 1 ;
		view ->LOFCprList = loflist;
		loflist->Next = 0;
		loflist->start = (short *)MrgCopAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
		if (!loflist->start)
			goto bad_mrgcop ;
		D(kprintf("allocated loflist->start %lx\n", loflist->start);)
		allocated |= 2 ;
		loflist->MaxCount = copstuff.maxins;
    }
    else    /* try to get exaxt amount */
    {
		/* keep old header */
		if (loflist->MaxCount < copstuff.maxins)
		{
	    	FreeMem(loflist->start,loflist->MaxCount<<2);
	    	loflist->start = (short *)MrgCopAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
	    	if (!loflist->start)
				goto bad_mrgcop ;
			D(kprintf("allocated loflist->start %lx\n", loflist->start);)
			allocated |= 2 ;
	    	loflist->MaxCount = copstuff.maxins;
		}
    }
    copstuff.cnt = loflist->MaxCount;
    copstuff.fcopptr = copstuff.copptr = loflist->start;       /* use this buffer */
    /*copstuff.fcopptr = loflist->start;*/	/* for hack stuff */

	shflist = 0;
    if (copstuff.flags & INTERLACE)
    {
		if ((shflist = view->SHFCprList) == 0)
		{
	    	D(kprintf("User set up no hardware SOFcopper lists\n");)
	    	shflist = (struct cprlist *)MrgCopAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
	    	if (!shflist)
				goto bad_mrgcop ;
			D(kprintf("allocated shflist %lx\n", shflist);)
			allocated |= 4 ;
	    	view->SHFCprList =  shflist;
	    	shflist->Next = 0;
	    	shflist->start = (short *)MrgCopAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
	    	if (!shflist->start)
				goto bad_mrgcop ;
			D(kprintf("allocated shflist->start %lx\n", shflist->start);)
			allocated |= 8 ;
	    	shflist->MaxCount = copstuff.maxins;
		}
		copstuff.icnt = shflist->MaxCount;
		copstuff.copIptr = shflist->start;
    }
    else
    {
	 copstuff.copIptr = 0;
	/* free off any old copper lists if possible */
	freecprlist(view->SHFCprList);
	view->SHFCprList = 0;
    }
	/* do we have some leftover copper lists? */
	freecprlist(loflist->Next);
	loflist->Next = 0;
	if (shflist)
	{
		freecprlist(shflist->Next);
		shflist->Next = 0;
	}
#ifdef QWE
	copstuff.ratioh = 1<<4;
	copstuff.ratioh = mspc->ratioh;
	copstuff.colorclocks = mspc->total_colorclocks;
	D(kprintf("ccs = 0x%lx\n", copstuff.colorclocks);)
#endif

	D(kprintf("Start main loop\n");)
    copstuff.topline = -1;
    while(copstuff.beamx < 255)
    {
		struct CopList *oldcl;
		ULONG newmode;

		oldcl = (struct CopList *) (&copstuff.first);

		for(cl = copstuff.first; cl ; cl = cl->_CopList)
		{
		    do
		    {
			D(kprintf("calling coppermover()\n");)
#ifdef NEWDOWNCODE
			c = (struct CopIns *)coppermover(&copstuff, cl->CopPtr);
#endif
			if (c->OpCode == 2)
			{
			    /* jump to next buffer */
			    cl = c->u3.nxtlist;     /* get next buffer */
			    if (oldcl == (struct CopList *) (&copstuff.first))
			    {
				copstuff.first = cl;
			    }
			    else
			    {
				struct CopList *qwe;
				for ( qwe = oldcl ; qwe ; qwe = qwe->Next)
				{
				    qwe->_CopList = cl;
				}
			    }
			}
		    }   while (c->OpCode == 2);
		    cl->CopPtr = c;
		    oldcl = cl;
		}
		/* all sources are now at waits */
		/* find first to start up */
		nxtbeam = (30000)<<10;
		/*nxtbeam = (264+copstuff.DyOffset)<<10;*/
		/*nxti dsnt need to be initialized */
    	D(kprintf("at wait sync copstuff.first = %lx\n",copstuff.first);)
		old_c = 0;
		nxtcl = 0;
		for(cl = copstuff.first; cl ; cl = cl->_CopList)
		{
		    int v_waitpos;
		    int qwe;
		    c = cl->CopPtr;
		    /*v_waitpos = c->VWAITPOS+MAX((cl->_ViewPort->DyOffset),0);*/
		    v_waitpos= c->VWAITPOS+MAKE_DY_POS(cl->_ViewPort->DyOffset);
		    D(kprintf("v_waitpos = 0x%lx\n", v_waitpos);)
		    if ((newmode = new_mode(cl->_ViewPort)) & LACE)
		    {
			v_waitpos >>= 1;
		    }
		    D(kprintf("newmode = 0x%lx\n",newmode);)
		    if (newmode & DOUBLESCAN)
		    {
			D(kprintf("ScanDbl\n");)
			v_waitpos <<= 1;
			v_waitpos += ((cl->Flags & HALF_LINE) ? 1 : 0);
		    }

		    D(kprintf("v_waitpos = 0x%lx, nxtbeam = 0x%lx\n", v_waitpos, nxtbeam);)
		    if ((qwe = (v_waitpos<<10)+c->HWAITPOS) <= nxtbeam)
		    {
			if((old_c) && (qwe == nxtbeam)) 
			{
			    /* old denise odd height hack */
			    if( old_c->OpCode & (CPR_NT_LOF|CPR_NT_SHT) )
			    {
				    continue; /* give old_c priority */
			    }
			}

			old_c = c;
			nxtcl = cl;
			nxtbeam = qwe;
		    }
		}

		/*check_first(nxtcl,&copstuff);*/
/*	if (!nxtcl)
	{
		D(kprintf("panic: nxtcl uninitialized\n");)
	}
*/
	D(kprintf("nxtcl = 0x%lx, prevcl = 0x%lx\n", nxtcl, prevcl);)
    	if (nxtcl->CopLStart == 0)
    	{
			D(kprintf("setting back link of %lx to %lx\n",nxtcl,copstuff.copptr);)

			nxtcl->CopLStart = copstuff.copptr;
			nxtcl->CopSStart = copstuff.copIptr;
    	}

	/* See if the Inter-ViewPort Gap straddles line 255,
	 * and if it does, show it for the next time through.
	 *
	 * ie, show that the *previous* ViewPort straddled, or this ViewPort
	 * straddles but the next time through is for this ViewPort's extra
	 * copper instructions (SprIns, ClrIns or UCopIns).
	 *
	 * NB - don't do this if this is the last time through.
	 * (I *really* hate this code!!)
	 */
	copstuff.moreflags &= ~(STRADDLES_256 | STRADDLES_512 | WHOLE_LINE);
	if (prevcl == NULL)
	{
		firstvp = nxtcl->_ViewPort;
	}
	{
		struct ViewPort *vp = (prevcl ? prevcl->_ViewPort : firstvp);
		if (((prevcl) && ((nxtcl != prevcl) && (nxtcl->_ViewPort != firstvp))) ||
		    ((nxtcl == vp->SprIns) || (nxtcl == vp->ClrIns) || (vp->UCopIns && IsAUCopIns(vp, nxtcl))))
		{
			if ((vp->ColorMap) && (vp->ColorMap->Type) && (vpe = vp->ColorMap->cm_vpe))
			{
				D(kprintf("MrgCop() vp = 0x%lx, vpe->Flags = 0x%lx\n", vp, vpe->Flags);)
				copstuff.moreflags |= (vpe->Flags & (VPXF_STRADDLES_256 | VPXF_STRADDLES_512));
			}
			copstuff.moreflags |= ((prevcl && (prevcl->Flags & EXACT_LINE)) ? WHOLE_LINE : 0);
		}
	}
	do_wait(&copstuff,nxtcl->CopPtr,nxtcl,mspc);

#ifdef NO_CLIP_VP
	/* should bump all copper lists that wait for the same position */
	nxtcl->CopPtr++;
#else
	/* if clipped skip additional moves -- bart */

#define clip_wait(cs,c,cl,mspc) \
(cl->_ViewPort->ColorMap \
&& (cl->_ViewPort->ColorMap->Flags & USER_COPPER_CLIP))? \
MIN(0,(MAKE_DY_POS(cl->_ViewPort->DyOffset+cl->_ViewPort->DHeight-1) - \
(c->VWAITPOS + MAKE_DY_POS(cl->_ViewPort->DyOffset)))) : 0

	if (clip_wait(&copstuff,nxtcl->CopPtr,nxtcl,mspc))
	{
	    struct CopIns *c = nxtcl->CopPtr;

	    if ((c->VWAITPOS == 10000) && (c->HWAITPOS == 255))
	    {
		goto CLIP_DONE;
	    }
	    else
	    {
		++nxtcl->CopPtr;

		if( !(c->OpCode & CPR_NT_SYS) ) goto CLIP_DONE;
		c = nxtcl->CopPtr;
	    }

	    do
	    {
		if((3&(c->OpCode)) == CPRNXTBUF)
		{
			nxtcl = c->NXTLIST; 
			if(!nxtcl) goto CLIP_DONE;
			c = nxtcl->CopPtr;
		}
		do
		{
		    if((3&(c->OpCode)) == COPPER_WAIT)
		    {
			if ((c->VWAITPOS == 10000) && (c->HWAITPOS == 255))
			{
			    goto CLIP_DONE;
			}
			else
			{
			    if( !(c->OpCode & CPR_NT_SYS) ) goto CLIP_DONE;
			    c = ++nxtcl->CopPtr;
			}
		    }

		    while ((3&(c->OpCode)) == COPPER_MOVE) 
		    {
			if( !(c->OpCode & CPR_NT_SYS) ) goto CLIP_DONE;
			c = ++nxtcl->CopPtr;
		    }

		}   while ((3&(c->OpCode)) == COPPER_WAIT);

	    }   while ((3&(c->OpCode)) == CPRNXTBUF);

CLIP_DONE: ;

	}
	else
	{
	    /* should bump all copper lists that wait for same position */
	    nxtcl->CopPtr++;
	}
#endif
	prevcl = nxtcl;
    }

    if ((GBASE->ChipRevBits0 & GFXF_AA_LISA) && ve)
    {
    	ULONG t = copstuff.topline;
	t = MIN(t, TOPLINE);
	ve->TopLine = (UWORD)t;
    }

	D(kprintf("Special interlace test\n");)
	/* the last instruction should be a wait 255 now, we need to */
	/* move this down and add reloads for cop2ptr */
	/* set up for noninterlaced screen */
	if (view->Modes & LACE)
	{
		/* the following code required incase interrupts disappear */
		register UWORD *copptr,*copIptr;
		struct Custom *io = &custom;

		copIptr = copstuff.copIptr;
		copptr = copstuff.copptr;

		/* move wait instruction down */
		copIptr[2] = copptr[2] = copptr[-2];
		copIptr[3] = copptr[3] = copptr[-1];
		/* now set up move.l xxx,cop2ptr */
		copIptr[-2] = copptr[-2] = 0x1fe & (ULONG)(&io->cop2lc);
		copIptr[0] = copptr[0] = 0x1fe & ( (ULONG)(&io->cop2lc) + 2);

		/* set short frame to jump to long frame */
		copIptr[-1] = copptr[-1] = (int)(loflist->start)>>16;
		copIptr[1] = copptr[1] = (UWORD)loflist->start;

		/* set long frame to go to short frame */
		copptr[-1] = (ULONG)(shflist->start)>>16;
		copptr[1] = (UWORD)shflist->start;
	}
	D(kprintf("exiting mrgcop\n");)
	return(MCOP_OK);

/* Low memory condition - free the coplists we have allocated,
   and put NULL pointers in the lists. */

bad_mrgcop:
	if (allocated & 8)
	{
	D(kprintf("Freeing shflist->start %lx\n", shflist->start) ;)
		FreeMem(shflist->start, (copstuff.maxins<<2)) ;
		view->SHFCprList->start = NULL ;
	}
	if (allocated & 4)
	{
	D(kprintf("Freeing shflist %lx\n", shflist) ;)
		FreeMem(shflist, sizeof(struct cprlist)) ;
		view->SHFCprList = NULL ;
	}
	if (allocated & 2)
	{
	D(kprintf("Freeing loflist->start %lx\n", loflist->start) ;)
		FreeMem(loflist->start, (copstuff.maxins<<2)) ;
		view->LOFCprList->start = NULL ;
	}
	if (allocated & 1)
	{
	D(kprintf("Freeing loflist %lx\n", loflist) ;)
		FreeMem(loflist, sizeof(struct cprlist)) ;
		view->LOFCprList = NULL ;
	}

	D(kprintf("Leaving bad MrgCop\n") ;)

	return(MCOP_NO_MEM);
}

#endif
@


39.20
log
@IsAUCopIns() which checks if a CopList is a user copperlist.
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.19 93/05/05 19:12:12 spence Exp Locker: spence $
d197 1
a197 19
BOOL __regargs IsAUCopIns(struct ViewPort *vp, struct CopList *cl)
{
    struct UCopList *ucl = vp->UCopIns;
    BOOL result = FALSE;

    while ((ucl) && (!result))
    {
	if (ucl->FirstCopList == cl)
	{
		result = TRUE;
	}
	else
	{
		ucl = ucl->Next;
	}
    }

    return(result);
}
@


39.19
log
@Check if nxtcl == vp->SprIns, vp->ClrIns or vp->UCopIns before checking
the STRADDLES_256 flag.
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.18 93/05/05 15:51:53 spence Exp Locker: spence $
d197 20
d597 1
a597 1
		    ((nxtcl == vp->SprIns) || (nxtcl == vp->ClrIns) || (nxtcl == vp->UCopIns)))
@


39.18
log
@whoops! v_waitpos += ((cl->Flags & HALF_LINE) ? 1 : 0)
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.17 93/05/05 15:32:50 spence Exp Locker: spence $
d28 7
d37 1
a37 1
#define D(x) {x}
d550 1
a550 1
	D(kprintf("nxtcl = 0x%lx\n", nxtcl);)
d577 1
a577 1
		    ((vp->SprIns) || (vp->ClrIns) || (vp->UCopIns)))
@


39.17
log
@v_waitpos -= ((cl->Flags & HALF_LINE) ? 1 : 0)
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.16 93/02/24 16:57:38 spence Exp Locker: spence $
d516 1
a516 1
			v_waitpos -= ((cl->Flags & HALF_LINE) ? 1 : 0);
@


39.16
log
@Add 10 to copstuff.maxins, to allow more space for the extra WAITs that
may be needed.
Added copstuff.totalrows for do_wait().
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.15 93/02/22 10:17:47 spence Exp Locker: spence $
d516 1
@


39.15
log
@If prevcl->Flags & EXACT_LINE, then set a flag for get_hwait_hack()
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.14 93/02/09 15:25:23 spence Exp Locker: spence $
d89 1
a358 1
    copstuff.maxins++;
d360 4
a363 1
    copstuff.maxins += 2;	/* add 2 for auto ping/pong */
@


39.14
log
@Check for STRADDLES_256 for SprIns, ClrIns and UCopIns
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.13 93/01/20 13:33:43 chrisg Exp Locker: spence $
d12 1
a16 1
#include "/copper.h"
d94 1
d558 1
a558 1
	copstuff.moreflags &= ~(STRADDLES_256 | STRADDLES_512);
d573 1
@


39.13
log
@invalidate copper-list cache for scrollvp.
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.12 92/11/23 16:25:12 spence Exp Locker: chrisg $
d550 3
a552 1
	 * ie, show that the *previous* ViewPort straddled.
a561 1
	if ((prevcl) && (nxtcl != prevcl) && (nxtcl->_ViewPort != firstvp))
d563 3
a565 2
		struct ViewPort *vp = prevcl->_ViewPort;
		if ((vp->ColorMap) && (vp->ColorMap->Type) && (vpe = vp->ColorMap->cm_vpe))
d567 5
a571 2
			D(kprintf("MrgCop() vp = 0x%lx, vpe->Flags = 0x%lx\n", vp, vpe->Flags);)
			copstuff.moreflags |= (vpe->Flags & (VPXF_STRADDLES_256 | VPXF_STRADDLES_512));
@


39.12
log
@GfxLookUp() called through the LVO.
Checks that vp->DspIns is not NULL, so that viewports off the bottom
of the display will not have their Spr/Clr/UCopIns merged as well
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.11 92/08/27 12:11:06 spence Exp Locker: spence $
d331 3
@


39.11
log
@MrgCop() now uses publicly defined error return values.
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.10 92/08/17 16:51:09 spence Exp Locker: spence $
d20 1
d216 1
a216 1
	if((ve = (struct ViewExtra *) GfxLookUp(view)) && ve->Monitor)
d239 9
a247 1
	if ((vp->Modes & VP_HIDE) == 0)
@


39.10
log
@topline made a ULONG, in case the topline is >256/\
Don't set the STRADDLES flags if the viewport is the first one in the 
list. We send the first ViewPort back through do_wait() at the end to
terminate the copperlist.
>sigh<
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.9 92/08/06 11:27:54 spence Exp Locker: spence $
a193 3
#define GOOD_MRGCOP 0	/* MrgCop() return values */
#define BAD_MRGCOP 1

d341 1
a341 1
	return(BAD_MRGCOP);
d668 1
a668 1
	return(GOOD_MRGCOP);
d701 1
a701 1
	return(BAD_MRGCOP);
@


39.9
log
@Check if previous ViewPort STRADDLES_512
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.8 92/07/10 17:03:22 spence Exp Locker: spence $
d86 1
a86 1
    UWORD   topline;
d207 1
a207 1
    struct ViewPort *vp;
d338 8
a345 1
    if (copstuff.first == 0)    return(BAD_MRGCOP); /* THIS LINE IS A BUG!!! FIX IT!!! */
d441 1
a441 1
    copstuff.topline = 0xffff;
d493 1
a493 1

d498 1
d542 3
d546 6
a551 1
	if ((prevcl) && (nxtcl != prevcl))
a556 1
			copstuff.moreflags &= ~(STRADDLES_256 | STRADDLES_512);
d637 1
a637 1
    	UWORD t = copstuff.topline;
d639 1
a639 1
	ve->TopLine = t;
@


39.8
log
@Check for ViewExtra before setting ve->TopLine
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.7 92/07/09 12:06:40 spence Exp Locker: spence $
d91 2
a92 1
#define STRADDLES_255 VPXF_STRADDLES_255
d214 1
a214 1
    mspc = GBASE->default_monitor;
d541 2
a542 2
			copstuff.moreflags &= ~(STRADDLES_255);
			copstuff.moreflags |= (vpe->Flags & VPXF_STRADDLES_255);
@


39.7
log
@removed old downcoded code.
checks for STRADDLES_255
Sets the TopLine in the ViewExtra, not GfxBAse
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.6 92/06/09 10:55:31 chrisg Exp Locker: spence $
d619 1
a619 1
    if (GBASE->ChipRevBits0 & GFXF_AA_LISA)
@


39.6
log
@REQ -> MSF_REQ.
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.5 92/05/05 11:57:47 chrisg Exp Locker: chrisg $
d87 1
a89 2
#define HEDLEY_HACK	2
#define HEDLEY_HACK2	4
d91 1
a96 416
#define HWAIT 222
#define GRANULARITY 8
#define FETCH_MASK  0xFFFC

#ifndef NEWDOWNCODE

/* prevent dma contention */

short get_hwait_hack(cs,c)
struct copstuff *cs;
register struct CopIns *c;
{
	register short *hackptr;
	register short maxcount;
	register USHORT	target;
	register USHORT first,second;
	short state = 1;
	UWORD dafstrt = 0;
	UWORD dafstop = 0;
	UWORD diwhigh = 0;
	UWORD diwstop = 0;
	UWORD diwstrt = 0;
	UWORD bplcon0 = 0;
	UWORD bovp    = 0;
	UWORD tovp    = 0;
	UWORD hmax    = 0;
	UWORD old_bplcon0 = 0;

	/* since we do not chain hardware copper lists together */
	/* All I have to do is search backwards to see what these */
	/* critical hardware values are */
	/* bleeeeeeccccchhhh! aaaaaarrrgggghhhhh! */
	/* if HIRES, 4 bitplanes, dafstop = 0xd4 , then return */
	/* dafstart */
	/* if SUPERHIRES, 2 bitplanes, dafstop = "last available",  */
	/* then return dafstart */
	/* this next HWAIT constant was empirically determined */

	/* we must search for stop, start, and bplcon0 backwards */
	/* in that order!!! -- bart */

	/* the threshold value for last fetch on a line is now */
	/* algoritmically determined based on mode and cclocks */
	/* bart */

	hackptr = cs->copptr;	/* where next instruction goes */

	maxcount = (SHORT)(((long)hackptr - (long)cs->fcopptr))>>2;

	if(!(GBASE->ChipRevBits0 & GFXF_HR_DENISE))
	{
	    target = (USHORT)(&custom.bplcon0);
	    state = 6;
	}
	else
	{
	    target = (USHORT)(&custom.diwhigh);
	}

	target &= 0x1FE;

	D(kprintf("gethack hackptr = %lx maxcount= %ld\n",hackptr,maxcount);)
	D(kprintf("target = %lx\n",target);)

    while (maxcount--)
    {
	second = *--hackptr;
	first = *--hackptr;
	if (first == target)
	{
 	    D(kprintf("state = %ld found target %lx second %lx\n",state,first,second);)
	    switch (state)
	    {
		case 0: /* found diwstrt */
			diwstrt = second;
			/* check for HIRES, 4 bitplanes */
			/* or SUPERHIRES, 2 bitplanes */

			if (
			    ((bplcon0&0xf000) != (HIRES+0x4000))
			    && 	
			    ((bplcon0&0x7040) != (/* SUPERHIRES */0x40+0x2000))
			   )
			{
				return(HFIX(HWAIT));
			}

			if(dafstop >= hmax) 
			{
			    bovp =    (diwstop >> 8);
			    bovp +=   (GBASE->ChipRevBits0 & GFXF_HR_DENISE) ?
				      (diwhigh & 0x700) :
				      (((~diwstop) & 0x8000) >> 7) ;

			    tovp =    (diwstrt >> 8);
			    tovp +=   (GBASE->ChipRevBits0 & GFXF_HR_DENISE) ?
				      ((diwhigh & 0x7) << 8) :
				      (0) ;

			    {
				SHORT qwe = MAX(255,(((cs->beamy + 255)>>8)-1));

				if (( bovp > qwe) && (tovp <= qwe) )
				{
				    /* does straddles boundary */
				    return( dafstrt );
				} 
				else 
				{
				    return(dafstop + GRANULARITY);
				}
			    }
		        }
			return(hmax+GRANULARITY);
			break;
		case 1:	/* found diwhigh */
			diwhigh = second;
			/* now look for diwstop */
			target = (USHORT)(&custom.ddfstop);
			target &= 0x1FE;
			state = 2;
			break;
		case 2:	/* found dafstop */
			dafstop = second;
			/* now look for dafstart */
			target = (USHORT)(&custom.ddfstrt);
			target &= 0x1FE;
			state = 3;
			break;
		case 3:	/* found dafstart */
			dafstrt = second;
			/* calculate last fetch available */
			hmax = 
			((cs->colorclocks - GRANULARITY) & (~(GRANULARITY-1)));
			if(GBASE->ChipRevBits0 & GFXF_HR_DENISE) 
			{
			    hmax -= ((second) & (GRANULARITY - 1)) & FETCH_MASK;
			}
			/* now look for diwstop */
			target = (USHORT)(&custom.diwstop);
			target &= 0x1FE;
			state = 4;
			break;
		case 4:	/* found diwstop */
			diwstop = second;
			/* now look for bplcon0 */
			target = (USHORT)(&custom.bplcon0);
			target &= 0x1FE;
			state = 5;
			break;
		case 5:	/* found bplcon0 */
			if(!(GBASE->ChipRevBits0 & GFXF_HR_DENISE))
			{
			    bplcon0 = old_bplcon0;
			}
			else
			{
			    bplcon0 = second;
			}
			/* now look for diwstrt */
			target = (USHORT)(&custom.diwstrt);
			target &= 0x1FE;
			state = 0;
			break;
		case 6:	/* found "old denise" bplcon0 */
			old_bplcon0 = second;
			/* now look for dafstop */
			target = (USHORT)(&custom.ddfstop);
			target &= 0x1FE;
			state = 2;
			break;
		default: break;
	    }
	}
    }
    return(HFIX(HWAIT));
}

do_wait(cs,c,cl,mspc)
register struct copstuff *cs;
register struct CopIns *c;
struct CopList *cl;
struct MonitorSpec *mspc;
{
    short v_waitpos;
    short v_waitpos_abs;
    short v_waitpos_rel;
    short h_waitpos;
    int ov_flow = 0;
    short min_ytop;
    short tot_rows = mspc->total_rows;

    short *bmx = &cs->beamx;
    short *bmy = &cs->beamy;

    int	   skip = FALSE;

    if(c->OpCode & CPR_NT_LOF)
    {
	bmx = &cs->ibeamx;
        bmy = &cs->ibeamy;
    }

    min_ytop = mspc->min_row ;

    v_waitpos = c->VWAITPOS + MAKE_DY_POS(cl->_ViewPort->DyOffset);
	/* if (cl->_ViewPort->Modes & LACE)	v_waitpos >>= 1; */
	if (new_mode(cl->_ViewPort) & LACE)	v_waitpos >>= 1;
    v_waitpos += cs->DyOffset;
    v_waitpos = CLIP_VPOS(v_waitpos); /* clip to min display row -- bart */

    /* bart - 06.18.86 - genloc r5 bugfix */
    /* bart - 03.06.89 - genloc ECS  bugfix */

    if( GBASE->system_bplcon0 & (GENLOCK_AUDIO|GENLOCK_VIDEO) ) tot_rows -= 1;

    if (v_waitpos >= tot_rows) 
    {
	v_waitpos = (tot_rows - 1); /* force window closed by last line */
    }

    /* bart - 06.18.86 - waitpos was missing vblank for short-frame counts */

    h_waitpos = c->HWAITPOS;
    v_waitpos_abs = v_waitpos_rel = v_waitpos;

    /* bart - 01.21.91 - process interlace consistently with user coplists */

    if( (!(GBASE->ChipRevBits0 & GFXF_HR_DENISE))
    &&  (!(c->OpCode & CPR_NT_LOF))
    &&  (!(c->OpCode & CPR_NT_SHT)) )
    {
	if( (cs->ibeamy == v_waitpos_abs)
	&&  (cs->ibeamx == h_waitpos) )
	{
	    skip = TRUE;		
	}
	else
	{
	    if( (cs->moreflags & COPPERVPOS_OVERFLOW)
	    &&  (cs->ibeamy <= 255)
	    &&  (v_waitpos > 255) )
	    {
		/* must wait for short frame copper list */

		c->OpCode |= CPR_NT_LOF;
		do_wait(cs,c,cl,mspc);
		c->OpCode &= ~CPR_NT_LOF;

		/* now wait for long frame copper list */

		c->OpCode |= CPR_NT_SHT;
		do_wait(cs,c,cl,mspc);
		c->OpCode &= ~CPR_NT_SHT;

		return;
	    }
	}
    }

    D(kprintf("dowait(%lx %lx)",v_waitpos,h_waitpos);)
	if (v_waitpos > 255)
	{	
	    if( (*bmy != 255) || (!(GBASE->ChipRevBits0 & GFXF_HR_DENISE)) )
	    {
		/* the real maximum wait capability */
		v_waitpos = 255;
		if (h_waitpos != 255)	/* 255 = never start up */
		{
		     /* he really wants to wait between a valid line number */

			ov_flow = 1;

			/* already done this once? */
			if( cs->moreflags & 
			    ((c->OpCode & CPR_NT_LOF)?
			    COPPERIVPOS_OVERFLOW:
			    COPPERVPOS_OVERFLOW) )
			{
			    v_waitpos_rel -= (*bmy & 0xFF00);
			    goto vpos_overflow;
			}

			h_waitpos = get_hwait_hack(cs,c);
	D(kprintf("get_hwait returns h_waitpos = %lx\n",h_waitpos);)
			/* force a wait till the very end */
		}
	    }
	    else
	    {
			if ( h_waitpos != 255 )
			{
			    ov_flow = 1;
			}
			else
			{
			    v_waitpos = 255 ;
			}
	    }
	}

finish_wait:
	if ((*bmx != h_waitpos)||(*bmy != v_waitpos))
	{
	    USHORT	temp;
	    if ((!ov_flow ) || (*bmy != 255) || (*bmx < h_waitpos))
	    {
#ifdef COPPERDEBUG
		if 	(--cs->cnt < 0)
		{
			D(kprintf("coplist overload");)
			Alert(AN_LongFrame);
		}
#endif
		temp = COPPER_WAIT| ((v_waitpos)<<8)|(h_waitpos&0xFE);

		if(!(c->OpCode & CPR_NT_LOF))
		{
		    *cs->copptr++ = temp;
		    *cs->copptr++ = 0xFFFE; /* look at all bits */
		    *bmy = v_waitpos_abs;
		    *bmx = h_waitpos;

		    if(!(c->OpCode & CPR_NT_SHT))
		    {
			cs->ibeamy = v_waitpos_abs;
			cs->ibeamx = h_waitpos;
		    }
		}

		if (cs->flags&INTERLACE)
		{
#ifdef COPPERDEBUG
	   	 if (--cs->icnt < 0)
		{
			D(kprintf("coplist overload");)
			Alert(AN_ShortFrame);
		}
#endif
		    if(!(c->OpCode & CPR_NT_SHT))
		    {
			if(!skip)
			{
			     *cs->copIptr++ = temp;
			     *cs->copIptr++ = 0xFFFE;    /* look at all bits */
			}

			/* update vertical wait position */
			/* don't fall for the 255 problem */
			*bmy = v_waitpos_abs;
			*bmx = h_waitpos;
		    }
		}

	    }
	    else
	    {
		if((ov_flow == 1) && (*bmy == 255)) ov_flow = 2;

		/* update vertical wait position */
		/* don't fall for the 255 problem */

		*bmy = v_waitpos_abs;
	    }
	}
	if ( ov_flow )
	{
		v_waitpos_rel -= 256;
vpos_overflow:

		if(!(c->OpCode & CPR_NT_LOF))
		{
		    cs->moreflags |= COPPERVPOS_OVERFLOW;

		    if(!(c->OpCode & CPR_NT_SHT))
		    {
			cs->moreflags |= COPPERIVPOS_OVERFLOW;
		    }
		}
		else
		{
		    cs->moreflags |= COPPERIVPOS_OVERFLOW;
		}

		/* do again but with wrap around value */

		v_waitpos = v_waitpos_rel;

		if( v_waitpos >= 256 )
		{

		    h_waitpos = get_hwait_hack(cs,c);
		    v_waitpos = 255;
		}
		else
		{
		    if( (ov_flow == 2) && (*bmy == v_waitpos_abs) &&
			( (h_waitpos = get_hwait_hack(cs,c)) > c->HWAITPOS) )
		    {
			v_waitpos_rel += 256;
			v_waitpos = 255;
			ov_flow = 3;
		    }
		    else
		    {
			h_waitpos = c->HWAITPOS;
			ov_flow = 0;
		    }
		}

	    goto finish_wait;
	}
}

#endif

d201 1
a201 1
    struct CopList *cl,*nxtcl;
d203 1
a203 1
    int nxtbeam;
d207 2
a208 1
    struct ViewExtra *ve = 0;
d210 2
a211 2
    UBYTE	first_vp_type = 0;
	UWORD allocated;
d239 1
d242 1
a242 1
	    	
a427 1
	copstuff.colorclocks = STANDARD_COLORCLOCKS;
d429 1
d437 1
d472 1
a472 1
		nxtbeam = (20000)<<10;
d486 9
a494 2
		    /* if (cl->_ViewPort->Modes & LACE) v_waitpos >>= 1; */
		    if (new_mode(cl->_ViewPort) & LACE)	v_waitpos >>= 1;
d496 1
d520 1
d528 16
d616 1
d623 1
a623 5
	if (t != GBASE->TopLine)
	{
		GBASE->TopLine = t;
		GBASE->Flags |= TOPLINE_CHANGE;
	}
@


39.5
log
@regargs+ killed MrgCopAllocMem.
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.4 92/04/28 15:32:56 spence Exp Locker: chrisg $
d13 1
a18 1
#include "/monitor.h"
d646 1
a646 1
    if( mspc->ms_Flags & REQUEST_A2024 ) 
@


39.4
log
@Tidied up DEBUG messages
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.3 92/01/07 16:07:25 spence Exp Locker: spence $
d22 1
d515 1
a515 3
void mark_coplist(cl,mark)
struct CopList *cl;
UWORD mark;
d558 1
a558 1
void append_clist(cstuff,element,vp,user)
d607 1
a607 6
APTR MrgCopAllocMem(numbytes,flags)
ULONG numbytes;
ULONG flags;
{
	return((APTR)AllocMem(numbytes,flags));
}
@


39.3
log
@gfxlookup -> GfxLookUp
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.2 91/12/19 13:22:51 spence Exp Locker: spence $
a25 2
/*#define RAMDEBUG*/
/*#define COPPERDEBUG*/
d27 5
a31 2
/* #define BARTDEBUG */
/*#define SAS_DEBUG*/
d157 2
a158 4
#ifdef HACKDEBUG
	printf("gethack hackptr = %lx maxcount= %ld\n",hackptr,maxcount);IT\
	printf("target = %lx\n",target);
#endif
d166 1
a166 3
#ifdef HACKDEBUG
printf("state = %ld found target %lx second %lx\n",state,first,second);
#endif
d356 1
a356 3
#ifdef RAMDEBUG
    if (Debug)	printf("dowait(%lx %lx)",v_waitpos,h_waitpos);
#endif
d380 1
a380 3
#ifdef HACKDEBUG
	printf("get_hwait returns h_waitpos = %lx\n",h_waitpos);
#endif
d406 1
a406 3
#ifdef MEMDEBUG
			printf("coplist overload");
#else
a407 2
#endif
#else
d431 1
a431 3
#ifdef MEMDEBUG
			printf("coplist overload");
#else
a432 1
#endif
d571 1
a571 3
#ifdef DEBUG
    printf("checking cstuff->first=%lx element=%lx\n",cstuff->first,element);
#endif
d576 1
a576 3
#ifdef DEBUG
	    printf("now count instructions in this list\n");
#endif
d644 1
a644 3
#ifdef NAMEDEBUG
    printf("MRGCOP(%lx)\n",view);
#endif
d758 2
a759 5
#ifdef DEBUG
    printf("total number of instructions = %lx\n",copstuff.maxins);
    printf("moreflags = %lx\n",copstuff.moreflags);
	Debug();
#endif
d774 1
a774 3
#ifdef DEBUG
		printf("User set up no hardware LOFcopper lists\n");
#endif
d778 1
a778 3
#ifdef SAS_DEBUG
	kprintf("allocated loflist %lx\n", loflist);
#endif
d785 1
a785 3
#ifdef SAS_DEBUG
	kprintf("allocated loflist->start %lx\n", loflist->start);
#endif
d798 1
a798 3
#ifdef SAS_DEBUG
	kprintf("allocated loflist->start %lx\n", loflist->start);
#endif
d812 1
a812 3
#ifdef DEBUG
	    	printf("User set up no hardware SOFcopper lists\n");
#endif
d816 1
a816 3
#ifdef SAS_DEBUG
	kprintf("allocated shflist %lx\n", shflist);
#endif
d823 1
a823 3
#ifdef SAS_DEBUG
	kprintf("allocated shflist->start %lx\n", shflist->start);
#endif
d852 1
a852 4
#ifdef DEBUG
	kprintf("Start main loop\n");
	Debug();
#endif
d864 1
d894 1
a894 3
#ifdef RAMDEBUG
    if (Debug)	printf("at wait sync copstuff.first = %lx\n",copstuff.first);
#endif
d928 1
a928 4
#ifdef DEBUG
		printf("panic: nxtcl uninitialized\n");
		Debug();
#endif
d933 1
a933 2
#ifdef DEBUG
			printf("setting back link of %lx to %lx\n",nxtcl,copstuff.copptr);
a934 1
#endif
d1023 1
a1023 3
#ifdef DEBUG
	printf("Special interlace test\n");
#endif
d1051 1
a1051 4
#ifdef DEBUG
	printf("exiting mrgcop\n");
	Debug();
#endif
d1060 1
a1060 3
#ifdef SAS_DEBUG
	kprintf("Freeing shflist->start %lx\n", shflist->start) ;
#endif
d1066 1
a1066 3
#ifdef SAS_DEBUG
	kprintf("Freeing shflist %lx\n", shflist) ;
#endif
d1072 1
a1072 3
#ifdef SAS_DEBUG
	kprintf("Freeing loflist->start %lx\n", loflist->start) ;
#endif
d1078 1
a1078 3
#ifdef SAS_DEBUG
	kprintf("Freeing loflist %lx\n", loflist) ;
#endif
d1083 1
a1083 3
#ifdef SAS_DEBUG
	kprintf("Leaving bad MrgCop\n") ;
#endif
@


39.2
log
@A2024 reworked. No longer uses 4 or 6 linked copperlists, just one list
which will get poked in the vblank interrupt code (which is added from
disk). However, still uses some of the hedley fields in GfxBase for
flags.
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.1 91/11/26 16:25:03 spence Exp Locker: spence $
d656 1
a656 1
	if((ve = (struct ViewExtra *) gfxlookup(view)) && ve->Monitor)
@


39.1
log
@Sets GBASE->TopLine dynamically to best value for AA machines only.
/
@
text
@d3 1
a3 1
*	$Id: copper.c,v 39.0 91/08/21 17:15:52 chrisg Exp Locker: spence $
d437 1
a437 1
		if ((cs->flags&INTERLACE)||(cs->moreflags&HEDLEY_HACK))
a463 14
		if (cs->moreflags&HEDLEY_HACK)
		{
	   	 *cs->cop2ptr++ = temp;
	   	 *cs->cop2ptr++ = 0xFFFE;    /* look at all bits */
	   	 *cs->cop3ptr++ = temp;
	   	 *cs->cop3ptr++ = 0xFFFE;    /* look at all bits */
		}
		if (cs->moreflags&HEDLEY_HACK2)
		{
	   	 *cs->cop4ptr++ = temp;
	   	 *cs->cop4ptr++ = 0xFFFE;    /* look at all bits */
	   	 *cs->cop5ptr++ = temp;
	   	 *cs->cop5ptr++ = 0xFFFE;    /* look at all bits */
		}
d645 1
a645 1
    struct cprlist *loflist,*shflist,*list2,*list3,*list4,*list5;
a664 3
        /* Hedley copperlists are now done like interlace */
        /* just one intermediate list */

d672 4
a675 1
    if( mspc->ms_Flags & REQUEST_A2024 ) first_vp_type = 2;
d677 1
d682 1
a690 1
			copstuff.DyOffset = 0x2c;
d709 2
d712 3
a714 2

		    if (vp->ExtendedModes & VPF_A2024) 
d717 17
a733 4
		    }
		    else
		    {
			ULONG hedley_mode = new_mode(vp);
d735 1
a735 2
			if( (hedley_mode == A2024TENHERTZ_KEY) 
			||  (hedley_mode == A2024FIFTEENHERTZ_KEY) )
d737 1
a737 1
			    first_vp_type = 3;
d741 1
a741 1
			    first_vp_type = 1;
d744 4
a771 8
		if( first_vp_type == 3 )
		{
		    ULONG hedley_mode = new_mode(vp);

		    copstuff.moreflags |= HEDLEY_HACK;
		    if( hedley_mode == A2024TENHERTZ_KEY )
		    copstuff.moreflags |= HEDLEY_HACK2;
		}
d839 1
a839 1
    if ((copstuff.flags & INTERLACE)||(copstuff.moreflags&HEDLEY_HACK))
d874 4
a877 87
	/* 750 micro seconds to get to here */
	if (copstuff.moreflags & HEDLEY_HACK)
	{
		/* 2nd level lists are double indirected */
		if ((list2 = loflist->Next) == 0)
		{
#ifdef DEBUG
	printf("no list for list2\n");
#endif
	    	list2 = (struct cprlist *)MrgCopAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
	    	if (!list2)
	    		goto bad_mrgcop;
	    	allocated |= 0x10;
	    	loflist->Next = list2;
	    	list2->start = (short *)MrgCopAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
	    	if (!list2->start)
	    		goto bad_mrgcop;
	    	allocated |= 0x20;
		list2->Next = 0;
	    	list2->MaxCount = copstuff.maxins;
		}
		copstuff.cnt2 = list2->MaxCount;
		copstuff.cop2ptr = list2->start;

		if ((list3 = shflist->Next) == 0)
		{
#ifdef DEBUG
	printf("no list for list3\n");
#endif
	    	list3 = (struct cprlist *)MrgCopAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
	    	if (!list3)
	    		goto bad_mrgcop;
	    	allocated |= 0x40;
	    	shflist->Next = list3;
	    	list3->start = (short *)MrgCopAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
	    	if (!list3->start)
	    		goto bad_mrgcop;
	    	allocated |= 0x80;
		list3->Next = 0;
	    	list3->MaxCount = copstuff.maxins;
		}
		copstuff.cnt3 = list2->MaxCount;
		copstuff.cop3ptr = list3->start;
		/* now do third level copper lists, sheesh */
		if (copstuff.moreflags & HEDLEY_HACK2)
		{
			if ((list4 = loflist->Next->Next) == 0)
			{
#ifdef DEBUG
	printf("no list for list4\n");
#endif
	    			list4 = (struct cprlist *)MrgCopAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
	    			if (!list4)
	    				goto bad_mrgcop;
	    			allocated |= 0x100;
	    			list2->Next = list4;
	    			list4->start = (short *)MrgCopAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
	    			if (!list4->start)
	    				goto bad_mrgcop;
	    			allocated |= 0x200;
				list4->Next = 0;
	    			list4->MaxCount = copstuff.maxins;
			}
			copstuff.cnt4 = list4->MaxCount;
			copstuff.cop4ptr = list4->start;
			if ((list5 = shflist->Next->Next) == 0)
			{
#ifdef DEBUG
	printf("no list for list5\n");
#endif
	    			list5 = (struct cprlist *)MrgCopAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
	    			if (!list5)
	    				goto bad_mrgcop;
	    			allocated |= 0x400;
	    			list3->Next = list5;
	    			list5->start = (short *)MrgCopAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
	    			if (!list5->start)
	    				goto bad_mrgcop;
	    			allocated |= 0x800;
				list5->Next = 0;
	    			list5->MaxCount = copstuff.maxins;
			}
			copstuff.cnt5 = list5->MaxCount;
			copstuff.cop5ptr = list5->start;
		}
	}
	else
d879 2
a880 8
		/* do we have some leftover copper lists? */
		freecprlist(loflist->Next);
		loflist->Next = 0;
		if (shflist)
		{
			freecprlist(shflist->Next);
			shflist->Next = 0;
		}
a982 10
			if (copstuff.moreflags & HEDLEY_HACK)
			{
				nxtcl->Cop2Start = copstuff.cop2ptr;
				nxtcl->Cop3Start = copstuff.cop3ptr;
			}
			if (copstuff.moreflags & HEDLEY_HACK2)
			{
				nxtcl->Cop4Start = copstuff.cop4ptr;
				nxtcl->Cop5Start = copstuff.cop5ptr;
			}
a1108 40
	if (allocated & 0x800)
	{
		FreeMem(list5->start, copstuff.maxins<<2);
	}
	if (allocated & 0x400)
	{
		FreeMem(list5, sizeof(struct cprlist));
		if (shflist && shflist->Next)
			shflist->Next->Next = NULL;
	}
	if (allocated & 0x200)
	{
		FreeMem(list4->start, copstuff.maxins<<2);
	}
	if (allocated & 0x100)
	{
		FreeMem(list4, sizeof(struct cprlist));
		if (loflist && loflist->Next)
			loflist->Next->Next = NULL;
	}
	if (allocated & 0x80)
	{
		FreeMem(list3->start, copstuff.maxins<<2);
	}
	if (allocated & 0x40)
	{
		FreeMem(list3, sizeof(struct cprlist));
		if (shflist)
			shflist->Next = NULL;
	}
	if (allocated & 0x20)
	{
		FreeMem(list2->start, copstuff.maxins<<2);
	}
	if (allocated & 0x10)
	{
		FreeMem(list2, sizeof(struct cprlist));
		if (loflist)
			loflist->Next = NULL;
	}
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*	$Id: copper.c,v 37.6 91/05/20 11:07:33 chrisg Exp Locker: chrisg $
a7 1
#include <graphics/gfx.h>
d12 1
d14 5
a18 5
#include <graphics/view.h>
#include <graphics/copper.h>
#include <graphics/display.h>
#include <graphics/gfxbase.h>
#include <graphics/monitor.h>
d20 1
d84 1
a665 1

d984 1
d1056 1
d1157 11
@


37.6
log
@Added prototypes, improved warnings, and glue code. still needs work.
@
text
@d3 1
a3 1
*	$Id: copper.c,v 1.1 91/05/20 10:39:53 chrisg Exp $
@


37.5
log
@ fiex to use GBASE #define, + fixed bad return statement in mrgcop()
@
text
@d3 1
a3 1
*	$Id: copper.c,v 37.4 91/05/03 11:14:25 chrisg Exp Locker: chrisg $
d21 2
@


37.4
log
@ Added some 'voids' to kill compiler errors.
 line 784 is a bug that was revealed by the compiler. mrgcop() is supposed
to return an error flag, but this one return() statement returns nothing!!!!
@
text
@d3 1
a3 1
*	$Id: copper.c,v 37.3 91/05/02 14:35:55 chrisg Exp Locker: chrisg $
a116 1
	struct GfxBase *GB;
a118 2
	FETCHGBASE;

d140 1
a140 1
	if(!(GB->ChipRevBits0 & GFXF_HR_DENISE))
d185 1
a185 1
			    bovp +=   (GB->ChipRevBits0 & GFXF_HR_DENISE) ?
d190 1
a190 1
			    tovp +=   (GB->ChipRevBits0 & GFXF_HR_DENISE) ?
d229 1
a229 1
			if(GB->ChipRevBits0 & GFXF_HR_DENISE) 
d246 1
a246 1
			if(!(GB->ChipRevBits0 & GFXF_HR_DENISE))
a282 1
    struct GfxBase *GB;
a291 2
    FETCHGBASE;

d309 1
a309 1
    if( GB->system_bplcon0 & (GENLOCK_AUDIO|GENLOCK_VIDEO) ) tot_rows -= 1;
d323 1
a323 1
    if( (!(GB->ChipRevBits0 & GFXF_HR_DENISE))
d360 1
a360 1
	    if( (*bmy != 255) || (!(GB->ChipRevBits0 & GFXF_HR_DENISE)) )
a656 1
    struct GfxBase *GB;
a661 1
    FETCHGBASE;
d663 1
a663 1
    mspc = GB->default_monitor;
d776 1
a776 1
    if (copstuff.first == 0)    return; /* THIS LINE IS A BUG!!! FIX IT!!! */
@


37.3
log
@ changed to compile with lattice. had to add a cast at an if or the else
would compile with an error ?????
@
text
@d3 1
a3 1
*	$Id: copper.c,v 37.2 91/05/02 13:02:31 chrisg Exp Locker: chrisg $
d544 1
a544 1
mark_coplist(cl,mark)
d589 1
a589 1
append_clist(cstuff,element,vp,user)
d665 1
a665 1
    struct MonitorSpec *mspc = 0;
d784 1
a784 1
    if (copstuff.first == 0)    return; /* return if no lists */
d993 1
a993 1
		oldcl = &copstuff.first;
@


37.2
log
@ changed "../" to "/" for native build
@
text
@d3 1
a3 1
*	$Id: copper.c,v 37.1 91/01/30 17:15:21 bart Exp Locker: chrisg $
d419 1
a420 1
#endif
d583 1
a583 1
MARK_DONE:
d1006 1
a1006 1
			    if (oldcl == &copstuff.first)
d1151 1
a1151 1
CLIP_DONE:
@


37.1
log
@coplist fixes for compatibility
@
text
@d3 1
a3 1
*	$Id: copper.c,v 37.0 91/01/07 15:18:42 spence Exp Locker: bart $
d19 1
a19 1
#include "../macros.h"
d640 1
a640 1
#include "../displayinfo_internal.h"
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*	$Id: copper.c,v 36.61 90/11/02 17:35:56 spence Exp Locker: spence $
d150 1
a150 1
	    target = (USHORT)(&custom.ddfstop);
d213 8
a220 1
		case 1:	/* found dafstop */
d225 1
a225 1
			state = 2;
d227 1
a227 1
		case 2:	/* found dafstart */
a234 4
			    /* now look for diwhigh */
			    target = (USHORT)(&custom.diwhigh);
			    target &= 0x1FE;
			    state = 3;
a235 10
			else
			{
			    /* now look for diwstop */
			    target = (USHORT)(&custom.diwstop);
			    target &= 0x1FE;
			    state = 4;
			}
			break;
		case 3:	/* found diwhigh */
			diwhigh = second;
d267 1
a267 1
			state = 1;
d294 2
d327 34
d382 2
a383 2
				v_waitpos_rel -= (*bmy & 0xFF00);
				goto vpos_overflow;
d401 1
a401 1
				v_waitpos = 255 ;
d405 1
d453 10
a462 6
			 *cs->copIptr++ = temp;
			 *cs->copIptr++ = 0xFFFE;    /* look at all bits */
			 /* update vertical wait position */
			 /* don't fall for the 255 problem */
			 *bmy = v_waitpos_abs;
			 *bmx = h_waitpos;
d483 2
d487 1
d513 2
a514 3
		h_waitpos = c->HWAITPOS;
		
		if(v_waitpos < 256)
d516 3
a518 1
			ov_flow = 0;
d522 4
a525 1
			h_waitpos = get_hwait_hack(cs,c);
d527 8
d536 1
a536 2
		}
		goto finish_wait;
@


36.61
log
@reversed MrgCop() return value - 0 is good, 1 is error
@
text
@d3 1
a3 1
*	$Id: copper.c,v 36.60 90/10/25 16:28:12 spence Exp Locker: spence $
@


36.60
log
@MrgCop() now returns 0 if it cannot allocate enough memory for all the 
copperlists instead of guruing, and a 1 if all's OK.
@
text
@d3 1
a3 1
*	$Id: copper.c,v 36.59 90/10/11 12:21:48 spence Exp Locker: spence $
d598 1
a598 3
	APTR memoryptr;
	memoryptr = (APTR)AllocMem(numbytes,flags);
	return(memoryptr);
d601 3
d1148 1
a1148 1
	return(1);
d1231 1
a1231 1
	return(0);
@


36.59
log
@Fixed terminating problem with max overscan and 4 bit-plane workbench
@
text
@d3 1
a3 1
*	$Id: copper.c,v 36.58 90/10/08 13:14:26 bart Exp Locker: spence $
d27 1
d594 10
a603 1
mrgcop(view)
a608 1
    int copsrcs;
d610 1
a610 1
    int i,nxtbeam;
d618 1
d671 2
a672 1
			vp->Modes &= VP_HIDE;
d702 2
a703 1
		    vp->Modes &= VP_HIDE;
d712 1
a712 1
	    if ((vp->Modes & VP_HIDE) == 0)
d751 1
d758 7
a764 1
		loflist = (struct cprlist *)GfxAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
d767 7
a773 1
		loflist->start = (short *)GfxAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
d782 7
a788 1
	    	loflist->start = (short *)GfxAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
d793 2
a794 2
    copstuff.copptr = loflist->start;       /* use this buffer */
    copstuff.fcopptr = loflist->start;	/* for hack stuff */
d804 7
a810 1
	    	shflist = (struct cprlist *)GfxAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
d813 7
a819 1
	    	shflist->start = (short *)GfxAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
d841 4
a844 1
	    	list2 = (struct cprlist *)GfxAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
d846 4
a849 1
	    	list2->start = (short *)GfxAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
d861 4
a864 1
	    	list3 = (struct cprlist *)GfxAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
d866 4
a869 1
	    	list3->start = (short *)GfxAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
d883 4
a886 1
	    			list4 = (struct cprlist *)GfxAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
d888 4
a891 1
	    			list4->start = (short *)GfxAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
d902 4
a905 1
	    			list5 = (struct cprlist *)GfxAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
d907 4
a910 1
	    			list5->start = (short *)GfxAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
d1012 1
a1012 1
	if (!nxtcl)
d1019 1
d1147 84
@


36.58
log
@downcode of do_wait and get_hwait_hack by spence
@
text
@d3 1
a3 1
*	$Id: copper.c,v 36.57 90/09/28 12:13:02 bart Exp Locker: bart $
d365 8
a372 4
		if ( h_waitpos != 255 )
		{
		    ov_flow = 1;
		}
@


36.57
log
@fix do_wait for termination condition when previous wait was to line 255
@
text
@d3 1
a3 1
*	$Id: copper.c,v 36.56 90/09/12 15:28:36 bart Exp Locker: bart $
d94 2
d486 2
@


36.56
log
@user copper list clipping
@
text
@d3 1
a3 1
*	$Id: copper.c,v 36.55 90/09/11 16:30:57 bart Exp Locker: bart $
d363 4
a366 1
		ov_flow = 1;
@


36.55
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Id: copper.c,v 36.54 90/09/11 16:04:33 bart Exp Locker: bart $
d28 1
a28 1
#define NO_CLIP_VP
a483 3
#define VPF_UCLIP 0x80	  /* clip copper user instruction */
#define CPR_NT_SYS 0x2000 /* copper user instruction only */

d536 5
d565 1
a565 1
	    if( (user) && ( vp->ExtendedModes & VPF_UCLIP ) ) 
d969 2
a970 1
(cl->_ViewPort->ExtendedModes & VPF_UCLIP) ? \
a973 1
	/* if(GB->ChipRevBits0 & GFXF_HR_DENISE) */
@


36.54
log
@old denise interscreen gap
@
text
@d3 1
a3 1
*	$Id: copper.c,v 36.53 90/09/07 14:35:30 bart Exp Locker: bart $
d334 1
a334 1
	    if( (*bmy != 255) || (*bmx == 0) )
@


36.53
log
@extended user copper list clipping but defined it out for now
@
text
@d3 1
a3 1
*	$Id: copper.c,v 36.52 90/08/03 11:47:20 bart Exp Locker: bart $
d334 1
a334 1
	    if( *bmy != 255 )
@


36.52
log
@better hwait hack processing
@
text
@d3 1
a3 1
*	$Id: copper.c,v 36.51 90/08/02 11:37:33 bart Exp Locker: bart $
d28 2
d482 51
a532 1
append_clist(cstuff,element,vp)
d536 1
d560 11
a570 2
		/* removing next line takes care of most */
		/* out of memory cases for wait(260)->255,5 hack */
d689 3
a691 3
		append_clist(&copstuff,vp->DspIns,vp);
		append_clist(&copstuff,vp->SprIns,vp);
		append_clist(&copstuff,vp->ClrIns,vp);
d694 1
a694 1
		    append_clist(&copstuff,qwe->FirstCopList,vp);
a959 2
#define NO_CLIP_VP

d967 1
d969 1
a969 1
(c->VWAITPOS + MAKE_DY_POS(cl->_ViewPort->DyOffset))))
d971 2
a972 2
	if((GB->ChipRevBits0 & GFXF_HR_DENISE)
	&& (clip_wait(&copstuff,nxtcl->CopPtr,nxtcl,mspc)))
d982 4
a985 1
		c = ++nxtcl->CopPtr;
d1006 1
d1010 1
d1013 1
d1016 3
a1018 1
		} 	while ((3&(c->OpCode)) == COPPER_WAIT);
d1020 1
d1022 1
@


36.51
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Id: copper.c,v 36.50 90/07/27 16:55:39 bart Exp Locker: bart $
d198 1
a198 2
				    return( dafstrt+ (GRANULARITY-1) 
					    & ~GRANULARITY ); 
d331 4
a334 1
	{	/* the real maximum wait capability */
d358 5
@


36.50
log
@id
@
text
@d3 1
a3 1
*	$Id: $
d890 2
@


36.49
log
@final revision for old denise
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/copper.c,v 36.48 90/07/20 23:01:30 bart Exp Locker: bart $
@


36.48
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/copper.c,v 36.47 90/07/20 22:52:46 bart Exp Locker: bart $
d515 1
a515 1
    struct CopIns *c;  /* ptr to copper bitplane instructions */
d794 1
a794 4
#ifndef NEWDOWNCODE
		struct CopIns *old_c;
		register UWORD	*COPPTR,*COPIPTR,OPCODE,FUCK;
#endif
d796 1
d833 1
d848 12
a859 2
				nxtcl = cl;
				nxtbeam = qwe;
@


36.47
log
@ok old denise
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/copper.c,v 36.46 90/07/20 18:11:28 bart Exp Locker: bart $
d847 1
a847 1
		    if ((qwe = (v_waitpos<<10)+c->HWAITPOS) < nxtbeam)
@


36.46
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/copper.c,v 36.45 90/07/20 17:03:47 bart Exp Locker: bart $
a45 1
#define INLINE
a87 90
#ifndef INLINE
check_first(cl,cs)
struct CopList *cl;
struct copstuff *cs;
{
    /* construct backward links */
    if (cl->CopLStart == 0)
    {
#ifdef DEBUG
	printf("setting back link of %lx to %lx\n",cl,cs->copptr);
#endif
	cl->CopLStart = cs->copptr;
	cl->CopSStart = cs->copIptr;
#ifdef V1_3
	if (cs->moreflags & HEDLEY_HACK)
	{
		cl->Cop2Start = cs->cop2ptr;
		cl->Cop3Start = cs->cop3ptr;
	}
	if (cs->moreflags & HEDLEY_HACK2)
	{
		cl->Cop4Start = cs->cop4ptr;
		cl->Cop5Start = cs->cop5ptr;
	}
#endif
    }
}

static do_move(cs,c)
register struct copstuff *cs;
register struct CopIns *c;
{
#ifdef RAMDEBUG
    if (Debug)	printf("domove(%lx %lx)",cs,c);
#endif
    if ((c->OpCode&CPR_NT_SHT) == 0)
    {
	if (--cs->cnt < 0)
	{
#ifdef MEMDEBUG
		printf("coplist overload");
#endif
		return(FALSE);
	}
	
	*cs->copptr++ = COPPER_MOVE| (c->DESTADDR & 0x1FE);
	*cs->copptr++ = c->DESTDATA;
    }
    if ((cs->flags&INTERLACE) || (cs->moreflags & HEDLEY_HACK))
    {
	if ((c->OpCode&CPR_NT_LOF) == 0)
	{
	    if (--cs->icnt < 0)
		{
#ifdef MEMDEBUG
			printf("copilist overload");
#endif
			return(FALSE);
		}
	    *cs->copIptr++ = COPPER_MOVE| (c->DESTADDR & 0x1FE);
	    *cs->copIptr++ = c->DESTDATA;
	}
	if ((c->OpCode&0x2000) == 0)
	{
	    if (--cs->cnt2 < 0)
		{
#ifdef MEMDEBUG
			printf("copilist overload");
#endif
			return(FALSE);
		}
	    *cs->cop2ptr++ = COPPER_MOVE| (c->DESTADDR & 0x1FE);
	    *cs->cop2ptr++ = c->DESTDATA;
	}
	if ((c->OpCode&0x1000) == 0)
	{
	    if (--cs->cnt3 < 0)
		{
#ifdef MEMDEBUG
			printf("copilist overload");
#endif
			return(FALSE);
		}
	    *cs->cop3ptr++ = COPPER_MOVE| (c->DESTADDR & 0x1FE);
	    *cs->cop3ptr++ = c->DESTDATA;
	}
    }
}
#endif

d804 1
a804 11
				c = (struct CopIns *)coppermover(&copstuff, cl->CopPtr);
#else
				c = cl->CopPtr;
				old_c = c;
				COPPTR = copstuff.copptr;
				COPIPTR= copstuff.copIptr;
				if ((3&(c->OpCode)) == COPPER_MOVE)
    				if (cl->CopLStart == 0)
    				{
#ifdef DEBUG
    printf("setting back link of %lx to %lx\n",cl,copstuff.copptr);
d806 12
a817 5
    					cl->CopLStart = COPPTR;
    					cl->CopSStart = COPIPTR;
    				}
				FUCK = CPR_NT_SHT;
				while(((UWORD)3&(UWORD)(OPCODE = c->OpCode)) == (UWORD)COPPER_MOVE)
d819 1
a819 21
    				if (!(OPCODE & FUCK))
    				{
#ifdef COPPERDEBUG
    					if (--copstuff.cnt < 0)
    					{
#ifdef MEMDEBUG
        					printf("coplist overload");
#else
						Alert(AN_LongFrame);
#endif
       		 				return(FALSE);
    					}   
#endif
    
						/* COPPER_MOVE is just a 0 */
						/* stupid compiler does not optimize */
    					/**COPPTR++ = COPPER_MOVE| (c->DESTADDR & 0x1FE);*/
    					*COPPTR++ = (c->DESTADDR & 0x1FE);
    					*COPPTR++ = c->DESTDATA;
    				}
				    c++;
d821 2
a822 40
				if (COPIPTR)
				{
					c = old_c;
					while((3&(OPCODE = c->OpCode)) == COPPER_MOVE)
					{
    					if (!( OPCODE&(UWORD)CPR_NT_LOF ))
    					{
#ifdef COPPERDEBUG
        					if (--copstuff.icnt < 0)
        					{
#ifdef MEMDEBUG
            					printf("copilist overload");
#else
						Alert(AN_ShortFrame);
#endif
            					return(FALSE);
        					}
#endif
        					*COPIPTR++ = COPPER_MOVE| (c->DESTADDR & 0x1FE);
        					*COPIPTR++ = c->DESTDATA;
						}
						c++;
					}
				}
				copstuff.copptr = COPPTR;
				copstuff.copIptr = COPIPTR;
#endif	/* NEWDOWNCODE */
				if (c->OpCode == 2)
				{
			    	/* jump to next buffer */
			    	cl = c->u3.nxtlist;     /* get next buffer */
			    	if (oldcl == &copstuff.first)
				    	copstuff.first = cl;
			    	else
			    	{
						struct CopList *qwe;
						for ( qwe = oldcl ; qwe ; qwe = qwe->Next)
				    		qwe->_CopList = cl;
			    	}
				}
a893 498
	{
	    struct CopIns *c = nxtcl->CopPtr;

	    if ((c->VWAITPOS == 10000) && (c->HWAITPOS == 255))
	    {
		goto CLIP_DONE;
	    }
	    else
	    {
		c = ++nxtcl->CopPtr;
	    }

	    do
	    {
		if((3&(c->OpCode)) == CPRNXTBUF)
		{
			nxtcl = c->NXTLIST; 
			if(!nxtcl) goto CLIP_DONE;
			c = nxtcl->CopPtr;
		}
		do
		{
		    if((3&(c->OpCode)) == COPPER_WAIT)
		    {
			if ((c->VWAITPOS == 10000) && (c->HWAITPOS == 255))
			{
			    goto CLIP_DONE;
			}
			else
			{
			    c = ++nxtcl->CopPtr;
			}
		    }
		    while ((3&(c->OpCode)) == COPPER_MOVE) 
		    {
			c = ++nxtcl->CopPtr;
		    }
		} 	while ((3&(c->OpCode)) == COPPER_WAIT);
	    }   while ((3&(c->OpCode)) == CPRNXTBUF);
CLIP_DONE:
	}
	else
	{
	    /* should bump all copper lists that wait for same position */
	    nxtcl->CopPtr++;
	}
#endif
    }

#ifdef DEBUG
	printf("Special interlace test\n");
#endif
	/* the last instruction should be a wait 255 now, we need to */
	/* move this down and add reloads for cop2ptr */
	/* set up for noninterlaced screen */
	if (view->Modes & LACE)
	{
		/* the following code required incase interrupts disappear */
		register UWORD *copptr,*copIptr;
		struct Custom *io = &custom;

		copIptr = copstuff.copIptr;
		copptr = copstuff.copptr;

		/* move wait instruction down */
		copIptr[2] = copptr[2] = copptr[-2];
		copIptr[3] = copptr[3] = copptr[-1];
		/* now set up move.l xxx,cop2ptr */
		copIptr[-2] = copptr[-2] = 0x1fe & (ULONG)(&io->cop2lc);
		copIptr[0] = copptr[0] = 0x1fe & ( (ULONG)(&io->cop2lc) + 2);

		/* set short frame to jump to long frame */
		copIptr[-1] = copptr[-1] = (int)(loflist->start)>>16;
		copIptr[1] = copptr[1] = (UWORD)loflist->start;

		/* set long frame to go to short frame */
		copptr[-1] = (ULONG)(shflist->start)>>16;
		copptr[1] = (UWORD)shflist->start;
	}
#ifdef DEBUG
	printf("exiting mrgcop\n");
	Debug();
#endif
}

#else

mrgcop(view)
register struct View *view;
{
    /* merge the different srcs of copper instructions into one stream */
    struct CopIns *c;  /* ptr to copper bitplane instructions */
    struct CopList *cl,*nxtcl;
    int copsrcs;
    struct UCopList *qwe;
    int i,nxtbeam;
    struct copstuff copstuff;
    struct cprlist *loflist,*shflist,*list2,*list3,*list4,*list5;
    struct ViewPort *vp;
	struct GfxBase *GB;
	struct ViewExtra *ve = 0;
	struct MonitorSpec *mspc = 0;
	UBYTE	first_vp_type = 0;

	FETCHGBASE;
	if (view->Modes & EXTEND_VSTRUCT)
	{
	    ve = gfxlookup(view);
	    if(ve)
	    {
		mspc = ve->Monitor;
	    }
	}

	if(!mspc)
	{
	    mspc = GB->default_monitor;
	}

#ifdef NAMEDEBUG
    printf("MRGCOP(%lx)\n",view);
#endif
        /* Hedley copperlists are now done like interlace */
        /* just one intermediate list */


    /* construct link list of all copper sources and count instructions */
    copstuff.moreflags = 0;
    copstuff.first = 0;
    copstuff.maxins = 0;
    copstuff.DyOffset = view->DyOffset;
    for( vp = view->ViewPort; vp ; vp = vp->Next)
    {
	if ((vp->Modes & VP_HIDE) == 0)
	{
		/* make sure no hybird system */
		if (first_vp_type == 0)
		{
			if (vp->ExtendedModes & VPF_A2024) 
			{
				first_vp_type = 1;

				/* a2024 screens rely on control info being loaded properly */
				/* force copstuff.DyOffset to InitView default */
				copstuff.DyOffset = 0x2c;	/* bart 12.22.87 */
			}
			else 
			{
				first_vp_type = 2;
			}
		}
		else
		{
			/* check for consistency */
			if (vp->ExtendedModes & VPF_A2024)
			{
#ifdef DEBUG
				printf("error in vp list\n");
				Debug();
#endif
				break;
			}
			else	if (first_vp_type == 1)
			{
#ifdef DEBUG
				printf("error in vp list2\n");
				Debug();
#endif
			 break;
			}
		}
	    append_clist(&copstuff,vp->DspIns,vp);
	    append_clist(&copstuff,vp->SprIns,vp);
	    append_clist(&copstuff,vp->ClrIns,vp);
	    for ( qwe = vp->UCopIns; qwe ; qwe = qwe->Next)
	    {
		append_clist(&copstuff,qwe->FirstCopList,vp);
	    }
	    if (vp->ExtendedModes & VPF_A2024)
	    {
		copstuff.moreflags |= HEDLEY_HACK;
	    	if (vp->ExtendedModes & VPF_TENHZ)
	        copstuff.moreflags |= HEDLEY_HACK2;
	    }
	}
    }
	/* 200 micro seconds to get to here */
    
    if (copstuff.first == 0)    return; /* return if no lists */
#ifdef DEBUG
    printf("total number of instructions = %lx\n",copstuff.maxins);
    printf("moreflags = %lx\n",copstuff.moreflags);
	Debug();
#endif
    copstuff.maxins++;

    copstuff.maxins += 2;	/* add 2 for auto ping/pong */

    copstuff.beamx = copstuff.beamy = 0;
    copstuff.flags = view->Modes;

    /* must always have a LOF buffer */
    if ((loflist = view->LOFCprList) == 0)
    {
#ifdef DEBUG
		printf("User set up no hardware LOFcopper lists\n");
#endif
		loflist = (struct cprlist *)GfxAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
		view ->LOFCprList = loflist;
		loflist->Next = 0;
		loflist->start = (short *)GfxAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
		loflist->MaxCount = copstuff.maxins;
    }
    else    /* try to get exaxt amount */
    {
		/* keep old header */
		if (loflist->MaxCount < copstuff.maxins)
		{
	    	FreeMem(loflist->start,loflist->MaxCount<<2);
	    	loflist->start = (short *)GfxAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
	    	loflist->MaxCount = copstuff.maxins;
		}
    }
    copstuff.cnt = loflist->MaxCount;
    copstuff.copptr = loflist->start;       /* use this buffer */
    copstuff.fcopptr = loflist->start;	/* for hack stuff */

	shflist = 0;
    if ((copstuff.flags & INTERLACE)||(copstuff.moreflags&HEDLEY_HACK))
    {
		if ((shflist = view->SHFCprList) == 0)
		{
#ifdef DEBUG
	    	printf("User set up no hardware SOFcopper lists\n");
#endif
	    	shflist = (struct cprlist *)GfxAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
	    	view->SHFCprList =  shflist;
	    	shflist->Next = 0;
	    	shflist->start = (short *)GfxAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
	    	shflist->MaxCount = copstuff.maxins;
		}
		copstuff.icnt = shflist->MaxCount;
		copstuff.copIptr = shflist->start;
    }
    else
    {
	 copstuff.copIptr = 0;
	/* free off any old copper lists if possible */
	freecprlist(view->SHFCprList);
	view->SHFCprList = 0;
    }
	/* 750 micro seconds to get to here */
	if (copstuff.moreflags & HEDLEY_HACK)
	{
		/* 2nd level lists are double indirected */
		if ((list2 = loflist->Next) == 0)
		{
#ifdef DEBUG
	printf("no list for list2\n");
#endif
	    	list2 = (struct cprlist *)GfxAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
	    	loflist->Next = list2;
	    	list2->start = (short *)GfxAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
		list2->Next = 0;
	    	list2->MaxCount = copstuff.maxins;
		}
		copstuff.cnt2 = list2->MaxCount;
		copstuff.cop2ptr = list2->start;

		if ((list3 = shflist->Next) == 0)
		{
#ifdef DEBUG
	printf("no list for list3\n");
#endif
	    	list3 = (struct cprlist *)GfxAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
	    	shflist->Next = list3;
	    	list3->start = (short *)GfxAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
		list3->Next = 0;
	    	list3->MaxCount = copstuff.maxins;
		}
		copstuff.cnt3 = list2->MaxCount;
		copstuff.cop3ptr = list3->start;
		/* now do third level copper lists, sheesh */
		if (copstuff.moreflags & HEDLEY_HACK2)
		{
			if ((list4 = loflist->Next->Next) == 0)
			{
#ifdef DEBUG
	printf("no list for list4\n");
#endif
	    			list4 = (struct cprlist *)GfxAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
	    			list2->Next = list4;
	    			list4->start = (short *)GfxAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
				list4->Next = 0;
	    			list4->MaxCount = copstuff.maxins;
			}
			copstuff.cnt4 = list4->MaxCount;
			copstuff.cop4ptr = list4->start;
			if ((list5 = shflist->Next->Next) == 0)
			{
#ifdef DEBUG
	printf("no list for list5\n");
#endif
	    			list5 = (struct cprlist *)GfxAllocMem(sizeof(struct cprlist),MEMF_PUBLIC);
	    			list3->Next = list5;
	    			list5->start = (short *)GfxAllocMem(copstuff.maxins<<2,MEMF_PUBLIC|MEMF_CHIP);
				list5->Next = 0;
	    			list5->MaxCount = copstuff.maxins;
			}
			copstuff.cnt5 = list5->MaxCount;
			copstuff.cop5ptr = list5->start;
		}
	}
	else
	{
		/* do we have some leftover copper lists? */
		freecprlist(loflist->Next);
		loflist->Next = 0;
		if (shflist)
		{
			freecprlist(shflist->Next);
			shflist->Next = 0;
		}
	}
#ifdef QWE
	copstuff.ratioh = 1<<4;
	copstuff.ratioh = mspc->ratioh;
	copstuff.colorclocks = STANDARD_COLORCLOCKS;
	copstuff.colorclocks = mspc->total_colorclocks;
#endif

#ifdef DEBUG
	kprintf("Start main loop\n");
	Debug();
#endif
    while(copstuff.beamx < 255)
    {
		struct CopList *oldcl;
#ifndef NEWDOWNCODE
		struct CopIns *old_c;
		register UWORD	*COPPTR,*COPIPTR,OPCODE,FUCK;
#endif
		oldcl = &copstuff.first;
		for(cl = copstuff.first; cl ; cl = cl->_CopList)
		{
		    do
		    {
#ifdef NEWDOWNCODE
				c = (struct CopIns *)coppermover(&copstuff, cl->CopPtr);
#else
				c = cl->CopPtr;
				old_c = c;
				COPPTR = copstuff.copptr;
				COPIPTR= copstuff.copIptr;
				if ((3&(c->OpCode)) == COPPER_MOVE)
    				if (cl->CopLStart == 0)
    				{
#ifdef DEBUG
    printf("setting back link of %lx to %lx\n",cl,copstuff.copptr);
#endif
    					cl->CopLStart = COPPTR;
    					cl->CopSStart = COPIPTR;
    				}
				FUCK = CPR_NT_SHT;
				while(((UWORD)3&(UWORD)(OPCODE = c->OpCode)) == (UWORD)COPPER_MOVE)
				{
    				if (!(OPCODE & FUCK))
    				{
#ifdef COPPERDEBUG
    					if (--copstuff.cnt < 0)
    					{
#ifdef MEMDEBUG
        					printf("coplist overload");
#else
						Alert(AN_LongFrame);
#endif
       		 				return(FALSE);
    					}   
#endif
    
						/* COPPER_MOVE is just a 0 */
						/* stupid compiler does not optimize */
    					/**COPPTR++ = COPPER_MOVE| (c->DESTADDR & 0x1FE);*/
    					*COPPTR++ = (c->DESTADDR & 0x1FE);
    					*COPPTR++ = c->DESTDATA;
    				}
				    c++;
				}
				if (COPIPTR)
				{
					c = old_c;
					while((3&(OPCODE = c->OpCode)) == COPPER_MOVE)
					{
    					if (!( OPCODE&(UWORD)CPR_NT_LOF ))
    					{
#ifdef COPPERDEBUG
        					if (--copstuff.icnt < 0)
        					{
#ifdef MEMDEBUG
            					printf("copilist overload");
#else
						Alert(AN_ShortFrame);
#endif
            					return(FALSE);
        					}
#endif
        					*COPIPTR++ = COPPER_MOVE| (c->DESTADDR & 0x1FE);
        					*COPIPTR++ = c->DESTDATA;
						}
						c++;
					}
				}
				copstuff.copptr = COPPTR;
				copstuff.copIptr = COPIPTR;
#endif	/* NEWDOWNCODE */
				if (c->OpCode == 2)
				{
			    	/* jump to next buffer */
			    	cl = c->u3.nxtlist;     /* get next buffer */
			    	if (oldcl == &copstuff.first)
				    	copstuff.first = cl;
			    	else
			    	{
						struct CopList *qwe;
						for ( qwe = oldcl ; qwe ; qwe = qwe->Next)
				    		qwe->_CopList = cl;
			    	}
				}
		    }   while (c->OpCode == 2);
		    cl->CopPtr = c;
		    oldcl = cl;
		}
		/* all sources are now at waits */
		/* find first to start up */
		nxtbeam = (20000)<<10;
		/*nxtbeam = (264+copstuff.DyOffset)<<10;*/
		/*nxti dsnt need to be initialized */
#ifdef RAMDEBUG
    if (Debug)	printf("at wait sync copstuff.first = %lx\n",copstuff.first);
#endif
		nxtcl = 0;
		for(cl = copstuff.first; cl ; cl = cl->_CopList)
		{
		    int v_waitpos;
		    int qwe;
		    c = cl->CopPtr;
		    /*v_waitpos = c->VWAITPOS+MAX((cl->_ViewPort->DyOffset),0);*/
		    v_waitpos= c->VWAITPOS+MAKE_DY_POS(cl->_ViewPort->DyOffset);

		    /* if (cl->_ViewPort->Modes & LACE) v_waitpos >>= 1; */
		    if (new_mode(cl->_ViewPort) & LACE)	v_waitpos >>= 1;

		    if ((qwe = (v_waitpos<<10)+c->HWAITPOS) < nxtbeam)
		    {
				nxtcl = cl;
				nxtbeam = qwe;
		    }
		}
		/*check_first(nxtcl,&copstuff);*/
	if (!nxtcl)
	{
#ifdef DEBUG
		printf("panic: nxtcl uninitialized\n");
		Debug();
#endif
	}
    	if (nxtcl->CopLStart == 0)
    	{
#ifdef DEBUG
			printf("setting back link of %lx to %lx\n",nxtcl,copstuff.copptr);

#endif
			nxtcl->CopLStart = copstuff.copptr;
			nxtcl->CopSStart = copstuff.copIptr;
			if (copstuff.moreflags & HEDLEY_HACK)
			{
				nxtcl->Cop2Start = copstuff.cop2ptr;
				nxtcl->Cop3Start = copstuff.cop3ptr;
			}
			if (copstuff.moreflags & HEDLEY_HACK2)
			{
				nxtcl->Cop4Start = copstuff.cop4ptr;
				nxtcl->Cop5Start = copstuff.cop5ptr;
			}
    	}
	do_wait(&copstuff,nxtcl->CopPtr,nxtcl,mspc);

#ifdef NO_CLIP_VP
	/* should bump all copper lists that wait for the same position */
	nxtcl->CopPtr++;
#else
	/* if clipped skip additional moves -- bart */

#define clip_wait(cs,c,cl,mspc) \
MIN(0,(MAKE_DY_POS(cl->_ViewPort->DyOffset+cl->_ViewPort->DHeight-1) - \
(c->VWAITPOS + MAKE_DY_POS(cl->_ViewPort->DyOffset))))

	if(clip_wait(&copstuff,nxtcl->CopPtr,nxtcl,mspc))
@


36.45
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/copper.c,v 36.44 90/07/20 14:21:28 bart Exp Locker: bart $
@


36.44
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/copper.c,v 36.43 90/07/18 22:39:22 bart Exp Locker: bart $
d452 1
a452 1
	    if ((!ov_flow ) || (*bmy != 255))
d473 6
d530 14
a543 3
		cs->moreflags |= ((c->OpCode & CPR_NT_LOF)? 
				    COPPERIVPOS_OVERFLOW:
				    COPPERVPOS_OVERFLOW );
@


36.43
log
@checkpoint old denise hire 4 bitplanes
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/copper.c,v 36.42 90/07/18 21:32:16 bart Exp Locker: bart $
d202 1
a202 1
	UWORD hmax = HWAIT;
d204 1
a204 1
	UWORD local_bplcon0 = 0;
d229 10
a238 1
	target = (USHORT)(&custom.ddfstop);
d242 1
a242 1
	printf("gethack hackptr = %lx maxcount= %ld\n",hackptr,maxcount);
a261 8
			if(!(GB->ChipRevBits0 & GFXF_HR_DENISE))
			{
				/* if(c->OpCode & (CPR_NT_LOF | CPR_NT_SHT)) */
				{
				    return(dafstrt); /* hack for old denise */
				}
			}

a282 1
			    /*if((dafstop+GRANULARITY)>=(cs->colorlocks&(~1)))*/
d289 2
a290 1
				    return(dafstrt);
a311 2
			hmax -= 
			((second) & (GRANULARITY - 1)) & FETCH_MASK;
d314 1
d343 8
a350 1
			bplcon0 = second;
d356 7
d367 1
a367 1
    return (HFIX(HWAIT));	/* 55 * 4 +2*/
@


36.42
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/copper.c,v 36.41 90/07/18 20:48:47 bart Exp Locker: bart $
@


36.41
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/copper.c,v 36.40 90/07/18 20:46:26 bart Exp Locker: bart $
d255 1
a255 1
				if(c->OpCode & (CPR_NT_LOF | CPR_NT_SHT))
@


36.40
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/copper.c,v 36.39 90/07/18 20:27:45 bart Exp Locker: bart $
d255 1
a255 1
				if(c-OpCode & (CPR_NT_LOF | CPR_NT_SHF))
@


36.39
log
@graphics36.171 old denise clipping
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/copper.c,v 36.38 90/03/28 09:09:55 bart Exp Locker: bart $
d185 1
a185 1
short get_hwait_hack(cs)
d187 1
d255 4
a258 1
				return(dafstrt); /* hack for old denise */
d427 1
a427 1
			h_waitpos = get_hwait_hack(cs);
d525 1
a525 1
			h_waitpos = get_hwait_hack(cs);
@


36.38
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/graphics/c/RCS/copper.c,v 36.37 90/03/01 13:53:00 bart Exp Locker: bart $
d78 1
d83 1
d203 1
d207 1
a207 1
	/* since we do not chanin hardware copper lists together */
d251 6
d366 4
d372 6
d414 4
a417 1
			if (cs->moreflags & COPPERVPOS_OVERFLOW)
d419 1
a419 1
				v_waitpos_rel -= (cs->beamy & 0xFF00);
d431 1
a431 1
	if ((cs->beamx!=h_waitpos)||(cs->beamy != v_waitpos))
d434 1
a434 1
	    if ((!ov_flow ) || (cs->beamy != 255))
d448 9
a456 9
		*cs->copptr++ = temp;
		*cs->copptr++ = 0xFFFE; /* look at all bits */
		cs->beamx = h_waitpos;
		/* update vertical wait position */
		/* don't fall for the 255 problem */
		cs->beamy = v_waitpos_abs;
#ifdef RAMDEBUG
    	if (Debug)	printf("new beam value(%lx,%lx)\n",cs->beamy,cs->beamx);
#endif
d469 9
a477 2
	   	 *cs->copIptr++ = temp;
	   	 *cs->copIptr++ = 0xFFFE;    /* look at all bits */
d479 1
d499 1
a499 1
		cs->beamy = v_waitpos_abs;
d506 3
a508 1
		cs->moreflags |= COPPERVPOS_OVERFLOW;
d523 1
d708 3
@


36.37
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.36 90/02/22 13:36:54 bart Exp $
@


36.36
log
@fixed get_hwait_hack for 1.4 beta 3
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.35 89/04/29 15:41:41 bart Exp $
d100 1
a100 1
#ifdef V1.3
@


36.35
log
@cm->Type checking
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.34 89/03/17 18:20:16 bart Exp $
d268 2
a269 1
			    if((dafstop + GRANULARITY)>=(cs->colorclocks&(~1)))
d284 1
a284 1
			return(cs->colorclocks);
@


36.34
log
@old denise compatibility with bovp reset of bplcon0 -- no bovp clip on moves
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.33 89/03/06 22:08:36 bart Exp $
d545 4
a548 4
	struct GfxBase *GB;
	struct ViewExtra *ve = 0;
	struct MonitorSpec *mspc = 0;
	UBYTE	first_vp_type = 0;
d550 1
a550 9
	FETCHGBASE;
	if (view->Modes & EXTEND_VSTRUCT)
	{
	    ve = gfxlookup(view);
	    if(ve)
	    {
		mspc = ve->Monitor;
	    }
	}
d552 5
a556 1
	if(!mspc)
d558 1
a558 1
	    mspc = GB->default_monitor;
d560 1
@


36.33
log
@better genlock processing
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.32 89/02/28 14:42:19 bart Exp $
d975 2
a976 1
	if(clip_wait(&copstuff,nxtcl->CopPtr,nxtcl,mspc))
@


36.32
log
@ECS genlock
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.31 89/02/24 09:43:08 bart Exp $
d355 1
d367 5
a371 2
    /* bart - 06.18.86 - genloc ECS  bugfix */
    if (v_waitpos >= mspc->total_rows-1) 
d373 1
a373 1
	v_waitpos = (mspc->total_rows-2); /* force window closed by last line */
@


36.31
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.31 89/02/22 13:07:09 bart Exp $
d366 2
a367 1
    if (v_waitpos >= mspc->total_rows) 
d369 1
a369 1
	v_waitpos = (mspc->total_rows-1);
@


36.30
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.29 89/02/15 16:07:10 bart Exp $
d615 2
a616 2
			if( (hedley_mode == A2024_10HZ_KEY) 
			||  (hedley_mode == A2024_15HZ_KEY) )
d653 1
a653 1
		    if( hedley_mode == A2024_10HZ_KEY )
@


36.29
log
@displayinfo_internal
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.28 89/02/14 18:22:07 bart Exp $
@


36.28
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.27 89/02/14 10:11:49 bart Exp $
d526 1
a526 1
#include <display/defines.h>
@


36.27
log
@checkpoint 02.14.89
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.26 89/02/01 17:52:07 bart Exp $
d251 1
a251 1
			    ((bplcon0&0x7040) != (SUPERHIRES+0x2000))
d526 1
a526 1
#include <display/modes.h>
d615 2
a616 2
			if( (hedley_mode == STD_MODE_14) 
			||  (hedley_mode == STD_MODE_15) )
d653 1
a653 1
		    if( hedley_mode == STD_MODE_14 )
@


36.26
log
@checkpoint -- a2024 10hz and 15hz scan works from 32 bit id
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.25 89/02/01 17:40:34 bart Exp $
@


36.25
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.24 89/02/01 11:22:51 bart Exp $
@


36.24
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.23 89/01/31 15:38:32 bart Exp $
a617 1
			    kprintf("mrgcop: display normal as hedley...\n");
a621 1
			    kprintf("mrgcop: display normal on hedley ...\n");
d1153 1
a1153 1
			  copstuff.moreflags |= HEDLEY_HACK2;
@


36.23
log
@checkpoint 2024
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.22 89/01/24 15:37:41 bart Exp $
@


36.22
log
@checkpoint 01.24.89
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.21 89/01/19 17:27:54 bart Exp $
d523 5
d572 3
d579 529
d1555 2
@


36.21
log
@checkpoint 01.19.89 coercion down to default
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.20 89/01/18 13:53:57 bart Exp $
@


36.20
log
@checkpoint 01.18.89
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.19 89/01/16 15:50:10 bart Exp $
@


36.19
log
@map_mode checkpoint
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.18 88/10/17 15:08:21 bart Exp $
d360 2
a361 1
	if (map_mode(cl->_ViewPort->Modes) & LACE)	v_waitpos >>= 1;
d885 2
a886 1
		    if (map_mode(cl->_ViewPort->Modes) & LACE) v_waitpos >>= 1;
@


36.18
log
@default monitorspec guaranteed to exist ... optimise
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.17 88/10/06 19:02:00 bart Exp $
d360 1
a360 1
	if (cl->_ViewPort->Modes & LACE)	v_waitpos >>= 1;
d882 4
a885 2
		    v_waitpos = c->VWAITPOS+MAKE_DY_POS(cl->_ViewPort->DyOffset);
			if (cl->_ViewPort->Modes & LACE) v_waitpos >>= 1;
@


36.17
log
@hwait hack now checks cusp cases
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.16 88/10/06 13:53:02 bart Exp $
d357 1
a357 2
    min_ytop = mspc ? mspc->min_row :
	       ((GB->DisplayFlags & PAL) ? MIN_PAL_ROW : MIN_NTSC_ROW);
d365 1
a365 1
    if(mspc)
d367 1
a367 4
	if (v_waitpos >= mspc->total_rows) 
	{
	    v_waitpos = (mspc->total_rows-1);
	}
d369 1
a369 7
    else
    {
	if (v_waitpos >= GB->MaxDisplayRow) 
	{
	    v_waitpos = (GB->MaxDisplayRow-1);
	}
    }
d372 3
a374 2
	h_waitpos = c->HWAITPOS;
	v_waitpos_abs = v_waitpos_rel = v_waitpos;
d761 1
a761 1
	if (mspc) copstuff.ratioh = mspc->ratioh;
d763 1
a763 1
	if (mspc) copstuff.colorclocks = mspc->total_colorclocks;
@


36.16
log
@clip to absolute minimum of 0 to allow for "pre-screen" instructions
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.15 88/10/03 10:53:05 bart Exp $
d193 6
d200 1
d202 2
d244 2
a245 1
		case 0: /* found bplcon0 */
d249 1
a249 1
			    ((second&0xf000) != (HIRES+0x4000))
d251 1
a251 1
			    ((second&0x7040) != (SUPERHIRES+0x2000))
d256 1
d259 9
d270 11
a280 1
				return(dafstrt);
d299 24
d325 7
@


36.15
log
@clip to min display row
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.14 88/10/01 13:24:23 bart Exp $
d36 3
a38 1
#define CLIP_VPOS(x)    (MAX((x),min_ytop))
@


36.14
log
@ok found the clip_wait bug... check for termination on entry
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.13 88/09/30 19:49:12 bart Exp $
d36 4
a39 1
#define MAKE_DY_POS(x)	(MAX((x),0))
a40 1
/*#define MAKE_DY_POS(x)	(x)*/
d286 2
a287 2
	short v_waitpos_abs;
	short v_waitpos_rel;
d289 4
a292 3
	struct GfxBase *GB;
	int ov_flow = 0;
	FETCHGBASE;
d294 3
a296 1
    /*v_waitpos = c->VWAITPOS + MAX((cl->_ViewPort->DyOffset),0);*/
d300 1
@


36.13
log
@define NO_CLIP_VP
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.12 88/09/30 19:37:37 bart Exp $
a858 1
#define NO_CLIP_VP
d871 1
a871 1
	    struct CopIns *c = ++(nxtcl->CopPtr);
d873 9
d886 2
a887 2
			nxtcl = nxtcl->CopPtr->NXTLIST; 
			if(!nxtcl) break;
d896 1
a896 1
			    break;
d909 1
d913 1
a913 1
	    /* should bump all copper lists that waitt for the same position */
@


36.12
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.11 88/09/30 19:21:38 bart Exp $
d859 1
@


36.11
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.10 88/09/30 19:16:00 bart Exp $
d873 1
a873 1
	    if(*(LONG *)0)
d875 6
d883 1
a883 1
		    if((3&(c->OpCode)) == CPRNXTBUF)
d885 1
a885 8
			    kprintf("copper nxtbuf...\n");
			    nxtcl = nxtcl->CopPtr->NXTLIST; 
			    if(!nxtcl) break;
			    c = nxtcl->CopPtr;
		    }
		    do
		    {
			if((3&(c->OpCode)) == COPPER_WAIT)
d887 1
a887 11
			    kprintf("copper wait...\n");
			    if ((c->VWAITPOS == 10000) && (c->HWAITPOS == 255))
			    {
				kprintf("is last wait...\n");
				break;
			    }
			    else
			    {
				kprintf("not last wait...\n");
				c = ++nxtcl->CopPtr;
			    }
d889 1
a889 1
			while ((3&(c->OpCode)) == COPPER_MOVE) 
a890 1
			    kprintf("copper move...\n");
d893 7
a899 3
		    } 	while ((3&(c->OpCode)) == COPPER_WAIT);
		}   while ((3&(c->OpCode)) == CPRNXTBUF);
	    }
@


36.10
log
@debug clip_wait...
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.9 88/09/30 18:05:47 bart Exp $
a858 1
#define NO_CLIP_VP
@


36.9
log
@clip_wait -- bart
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.8 88/07/28 20:37:38 bart Exp $
a46 4
#define clip_wait(cs,c,cl,mspc) \
MIN(0,(MAKE_DY_POS(cl->_ViewPort->DyOffset+cl->_ViewPort->DHeight-1) - \
(c->VWAITPOS + MAKE_DY_POS(cl->_ViewPort->DyOffset))))

d859 1
d864 1
a864 1
	/* skip additional instructions past bovp -- bart */
d866 4
d872 3
a874 2
	    UWORD op = (++nxtcl->CopPtr)->OpCode & 3;
	    do
a875 6
		if(op == CPRNXTBUF)
		{
		    nxtcl = nxtcl->CopPtr->NXTLIST; 
		    if (!nxtcl) break;
		    op = (nxtcl->CopPtr)->OpCode & 3;
		}
d878 1
a878 1
		    if(op == COPPER_WAIT)
d880 4
a883 3
			ULONG vh_posr = *(ULONG *)&nxtcl->CopPtr->VWAITPOS;
			if(vh_posr == ((10000 << 16) + (255))) break;
			op = (++nxtcl->CopPtr)->OpCode & 3;
d885 1
a885 1
		    while (op == COPPER_MOVE) 
d887 22
a908 4
			op = (++nxtcl->CopPtr)->OpCode & 3;
		    }
		} 	while (op == COPPER_WAIT);
	    }   while (op == CPRNXTBUF);
@


36.8
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.7 88/07/28 20:01:52 bart Exp $
d47 4
d861 1
a861 1
		do_wait(&copstuff,nxtcl->CopPtr,nxtcl,mspc);
d863 38
a900 2
		/* should bump all copper lists that wiat for the same position */
		nxtcl->CopPtr++;
d902 1
@


36.7
log
@hwait progress
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.6 88/07/28 13:02:42 bart Exp $
d244 1
a244 1
			    if((dafstop + GRANULARITY) < (cs->colorclocks&(~1)))
d246 1
a246 1
				return(cs->colorclocks);
d249 1
a249 1
		        return(dafstrt);
@


36.6
log
@hwait_hack is now so ugly i dont ever want to look at it again... bart
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.5 88/07/23 17:07:52 bart Exp $
d26 2
d186 1
a186 1
	short state = 1; /* look for datafetch stop, initially  */
a205 1
	/* this algoritm is more fully described in clipstuff.c */
d242 8
a249 2
			if(dafstop >= hmax) return(dafstrt);
			else return(HFIX(HWAIT));
d260 1
a260 1
			/* calculate last fetch available -- bart */
d270 1
a270 1
		default: return (HFIX(HWAIT)); /* error */
d342 5
a346 3
    if ((cs->beamx!=h_waitpos)||(cs->beamy != v_waitpos))
    {
		USHORT	temp;
d397 8
a404 1
    }
@


36.5
log
@monitorspec -- bart 07.23.88 merge source
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.4 88/05/26 16:33:50 bart Exp $
d18 1
d58 1
a58 1
	UWORD	moreflags;	/* misc */
d69 2
a70 1
	int ratioh;
d171 6
d184 5
a188 1
	short state = 0;
d193 1
a193 1
	/* if HIRES, 4 bitplanes, dafstop= 0xd4 , then return */
d195 12
a206 1
	/* this next 222 constant was empirically determined */
d208 1
d210 2
a211 1
	target = (USHORT)(&custom.bplcon0);
d213 1
d218 6
a223 1
	while (maxcount--)
a224 4
		second = *--hackptr;
		first = *--hackptr;
		if (first == target)
		{
d226 1
a226 1
	printf("state = %ld found target %lx second %lx\n",state,first,second);
d228 10
a237 1
			switch (state)
d239 1
a239 22
			case 0: /* found bplcon0 */
				/* check for HIRES, 4 bitplanes */
				if ((second&0xf000) != (HIRES+0x4000))
				{
					if ((second&0xf040) != (0x40+0x2000))
					return(HFIX(222));
				}
				/* now look for dafstop */
				target = (USHORT)(&custom.ddfstop);
				target &= 0x1FE;
				state = 1;
				break;
			case 1:	/* found dafstop */
				if (second != HFIX(0xd4))
					return(HFIX(222));
				/* now look for dafstart */
				target = (USHORT)(&custom.ddfstrt);
				target &= 0x1FE;
				state = 2;
				break;
			case 2:	/* found dafstart */
				return(second);
d241 24
a264 2
	
		}
d266 2
a267 1
	return (HFIX(222));	/* 55 * 4 +2*/
d473 5
d686 2
d689 1
d733 1
a733 1
			Alert(AN_LongFrame);
d760 1
a760 1
			Alert(AN_ShortFrame);
@


36.4
log
@do_wait for positions greater than 511 now works correctly -- bart
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.3 88/05/24 17:09:25 bart Exp $
d232 1
a232 1
do_wait(cs,c,cl,ve)
d236 1
a236 1
struct ViewExtra *ve;
d252 1
a252 1
    if(ve)
d254 1
a254 1
	if (v_waitpos >= ve->total_rows) 
d256 1
a256 1
	    v_waitpos = (ve->total_rows-1);
d422 1
d426 8
a433 1
	if (view->Modes & EXTEND_VSTRUCT)	ve = gfxlookup(view);
d642 1
a642 1
	if (ve)	copstuff.ratioh = ve->ratioh;
d795 1
a795 1
		do_wait(&copstuff,nxtcl->CopPtr,nxtcl,ve);
@


36.3
log
@maxrow set from total_rows if ve, else from MaxDisplayRow
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.2 88/05/17 22:49:00 dale Exp $
d240 1
d269 1
a269 1
	v_waitpos_abs = v_waitpos;
d277 5
a281 1
		{	/* he really wants to wait between a valid line number */
d283 6
a288 2
			if (cs->moreflags & COPPERVPOS_OVERFLOW)	goto vpos_overflow;
			ov_flow = 1;
d353 1
a353 1
		ov_flow = 0;
d355 2
d358 2
a359 2
		v_waitpos = v_waitpos_abs;
    	v_waitpos -= 256;
d361 10
a370 1
		cs->moreflags |= COPPERVPOS_OVERFLOW;
@


36.2
log
@fixes for super hires.
@
text
@d3 1
a3 1
*	$Header: copper.c,v 36.1 88/03/10 16:11:17 dale Exp $
d232 1
a232 1
do_wait(cs,c,cl)
d236 1
d244 1
d251 14
a264 1
	if (v_waitpos >= GB->MaxDisplayRow) v_waitpos = (GB->MaxDisplayRow-1);
d767 2
a768 1
		do_wait(&copstuff,nxtcl->CopPtr,nxtcl);
@


36.1
log
@V36 initial check in
@
text
@d3 1
a3 1
*	$Header: $
d25 5
a29 1
/*#define HFIX(x) (((x)*(cs->ratioh))>>4)*/
d31 1
d33 4
d243 2
a244 1
    v_waitpos = c->VWAITPOS + MAX((cl->_ViewPort->DyOffset),0);
d716 2
a717 1
		    v_waitpos = c->VWAITPOS+MAX((cl->_ViewPort->DyOffset),0);
@
