head     39.14;
branch   ;
access   ;
symbols  rel39_24:39.14 rel39_18:39.14 rel39_97:39.14 rel39_90:39.14 rel39_89:39.14 rel39_82:39.14 rel39_76:39.14 rel39_71:39.14 rel39_65:39.13 rel39_64:39.13 rel39_61:39.13 rel39_60:39.13 rel39_55:39.11 rel39_52:39.11 rel39_47:39.11 rel39_39:39.11 rel39_38:39.11 rel39_37:39.11 rel39_35:39.10 rel39_34:39.10 V37_30:37.0 V37_29:37.0 V37_28:37.0 V37_27:37.0 V37_25:37.0 V37_24:37.0 V37_23:37.0 V37_22:37.0 V37_21:37.0 V37_20:37.0 V37_19:37.0 V37_17:37.0 V37_15:37.0 V37_14:37.0 V37_13:37.0 V37_12:37.0 V37_11:37.0 V37_10:37.0 V37_9:37.0 V37_8:37.0 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.24 V36_208:36.23 V36_207:36.22 V36_205:36.22 V36_203:36.22 V36_202:36.22 V36_201:36.22 V36_200:36.22 V36_199:36.22 V36_198:36.22 V36_196:36.22 V36_195:36.22 V36_194:36.22 V36_193:36.22 V36_192:36.22 V36_191:36.22 V36_190:36.22 V36_189:36.22 V36_188:36.22 V36_186:36.22 V36_185:36.22 V36_184:36.22 V36_182:36.22 V36_181:36.22;
locks    ; strict;
comment  @ * @;


39.14
date     92.07.01.13.36.55;  author chrisg;  state Exp;
branches ;
next     39.13;

39.13
date     92.05.06.16.42.23;  author chrisg;  state Exp;
branches ;
next     39.12;

39.12
date     92.05.05.12.17.54;  author chrisg;  state Exp;
branches ;
next     39.11;

39.11
date     92.02.25.14.27.38;  author spence;  state Exp;
branches ;
next     39.10;

39.10
date     92.01.07.16.06.13;  author spence;  state Exp;
branches ;
next     39.9;

39.9
date     92.01.03.16.04.37;  author spence;  state Exp;
branches ;
next     39.8;

39.8
date     91.12.20.15.49.22;  author spence;  state Exp;
branches ;
next     39.7;

39.7
date     91.11.15.18.57.59;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     91.10.28.17.17.43;  author spence;  state Exp;
branches ;
next     39.5;

39.5
date     91.10.18.19.16.55;  author spence;  state Exp;
branches ;
next     39.4;

39.4
date     91.10.17.14.00.33;  author chrisg;  state Exp;
branches ;
next     39.3;

39.3
date     91.10.11.17.40.44;  author spence;  state Exp;
branches ;
next     39.2;

39.2
date     91.08.27.17.55.11;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     91.08.27.16.50.41;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.21.59;  author chrisg;  state Exp;
branches ;
next     37.3;

37.3
date     91.06.06.14.08.52;  author chrisg;  state Exp;
branches ;
next     37.2;

37.2
date     91.05.20.11.20.15;  author chrisg;  state Exp;
branches ;
next     37.1;

37.1
date     91.05.02.13.10.03;  author chrisg;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.20.45;  author spence;  state Exp;
branches ;
next     36.24;

36.24
date     90.12.20.11.23.16;  author bart;  state Exp;
branches ;
next     36.23;

36.23
date     90.12.17.17.29.14;  author spence;  state Exp;
branches ;
next     36.22;

36.22
date     90.07.27.16.59.49;  author bart;  state Exp;
branches ;
next     36.21;

36.21
date     90.03.28.09.12.38;  author bart;  state Exp;
branches ;
next     36.20;

36.20
date     90.03.07.16.31.07;  author bart;  state Exp;
branches ;
next     36.19;

36.19
date     89.08.22.09.36.07;  author bart;  state Exp;
branches ;
next     36.18;

36.18
date     89.04.29.15.42.42;  author bart;  state Exp;
branches ;
next     36.17;

36.17
date     89.02.17.22.04.15;  author bart;  state Exp;
branches ;
next     36.16;

36.16
date     89.02.15.16.06.58;  author bart;  state Exp;
branches ;
next     36.15;

36.15
date     89.02.14.10.13.16;  author bart;  state Exp;
branches ;
next     36.14;

36.14
date     89.02.01.17.52.58;  author bart;  state Exp;
branches ;
next     36.13;

36.13
date     89.01.31.15.39.10;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     89.01.24.15.38.26;  author bart;  state Exp;
branches ;
next     36.11;

36.11
date     89.01.19.17.28.35;  author bart;  state Exp;
branches ;
next     36.10;

36.10
date     89.01.18.13.54.48;  author bart;  state Exp;
branches ;
next     36.9;

36.9
date     89.01.13.12.40.38;  author bart;  state Exp;
branches ;
next     36.8;

36.8
date     88.10.17.15.07.13;  author bart;  state Exp;
branches ;
next     36.7;

36.7
date     88.07.25.14.45.22;  author bart;  state Exp;
branches ;
next     36.6;

36.6
date     88.07.23.17.09.30;  author bart;  state Exp;
branches ;
next     36.5;

36.5
date     88.06.24.12.19.12;  author bart;  state Exp;
branches ;
next     36.4;

36.4
date     88.06.24.10.15.44;  author bart;  state Exp;
branches ;
next     36.3;

36.3
date     88.06.24.10.08.13;  author bart;  state Exp;
branches ;
next     36.2;

36.2
date     88.06.10.12.09.24;  author bart;  state Exp;
branches ;
next     36.1;

36.1
date     88.03.10.16.12.11;  author dale;  state Exp;
branches ;
next     ;


desc
@@


39.14
log
@now totally if-def'd out.
on its way to the ashbin of history.
@
text
@/******************************************************************************
*
*	$Id: scrollvp.c,v 39.13 92/05/06 16:42:23 chrisg Exp Locker: chrisg $
*
******************************************************************************/

#include <exec/types.h>
#include <exec/nodes.h>
#include <exec/lists.h>
#include <exec/interrupts.h> 
#include <exec/libraries.h>
#include <exec/memory.h>
#include "/gfx.h"
#include "/gfxbase.h"
#include "/display.h"
#include "/copper.h"
#include "/view.h"
#include "/vp_internal.h"
#include "/displayinfo_internal.h"
#include <hardware/intbits.h>
#include <hardware/custom.h>
#include "/macros.h"

#include "c.protos"

#define SCROLLVP_DOWNCODED 

#ifndef SCROLLVP_DOWNCODED

#define SAVE_CODESPACE
/* following done by Dale  10-3-86*/
/*#define WaitBOVP(x) waitbovp(x)*/
#define WaitBOVP(x) waittovp(x,1)


/* #define DEBUG */
#define SCREENS

#ifdef DEBUG
#define D(x) {{x};}
#else
#define D(x)
#endif

extern struct Custom custom;

/**************************************************************************/
/* pokeCprList():							  */
/* given a pointer to the start of a hardware cprlist, search for	  */ 
/* coppermove to field one, if found use field two to update destdata     */
/*									  */
/**************************************************************************/
/*   		supports COPPERMOVE intstruction pokes only!!!		  */
/**************************************************************************/

struct pbCprList_info
{
	UWORD flags;
	UWORD *cil,*cis;
};


/* find first target, jam, assume next target follows */
#ifndef MAKE_PROTOS
void __regargs npokeCprList(UWORD *ci,UWORD *target,UWORD *table,int num)
{
	ULONG targ=(ULONG) target;
	/* is there a list to search through? */
	if (!ci)	return;
    /* set up target mask for searching cplist */
    targ &= 0x1FE;

	/* look for first hit */
    	for ( ; ci ; ci += 2)
    	{
		if ( ((*ci)==0xFFFF) && ((*(ci+1)==0xFFFE)) ) return;
		if (*ci == targ) break;
	}
	/* found first target now go fast for rest */
	while (num--)
	{
		/* end of list? */
		if ( ((*ci)==0xFFFF) && ((*(ci+1)==0xFFFE)) ) return;

		/* check for valid target */
		if (*ci == targ)
		{
			ci++;	/* skip address */
			*ci++ = *table;	/* put in new data */
		}
		/* always to next member in table */
		table++;
		targ += 2;
	}
}

void __regargs pokeCprList(UWORD *ci,UWORD *field1,int field2)
{
	UWORD	qwe;
	qwe = field2;
	npokeCprList(ci,field1,&qwe,1);
}

void pokebothCprList(struct pbCprList_info *pb, UWORD *field1, int field2)
{
	UWORD	qwe = field2;
	npokeCprList(pb->cil,field1,&qwe,1);	/* long frame */
	if (pb->flags&LACE)
		npokeCprList(pb->cis,field1,&qwe,1);	/* short frame */
}

/**************************************************************************/
/* pokeCopIns():							  */
/* given a pointer to the start of a CopIns List, search for operation on */
/* field one, if found use field to to update instruction		  */
/* dale added: return pointer to CopIns affected                          */
/*									  */
/**************************************************************************/

struct CopIns * pokeCopIns(struct CopIns *ci,UWORD op,UWORD *field1,short field2)
{
    struct CopIns *c;

    D(kprintf("poking another CopIns\n"));
    D(kprintf("op=%lx field1=%lx field2=%lx\n",op,field1,field2));

    if ( (c = ci) != NULL )
    {
	switch (op & 3)
	{
	    case COPPER_MOVE : 
	    {
		short error = FALSE;

		while (!error)
		{
		    switch (c->OpCode & 3)
		    {
			case COPPER_MOVE :  
					    if (c->DESTADDR == (((UWORD)field1) & 0x1fe))
					    {
						short mask;

						D(kprintf("found an instruction with the right destination address\n"));

						/* test if interlace matters */
						if ((mask = op & 0xC000))
						{
						    /* interlace, poke only if proper frame's intruction */
						    D(kprintf("looking for an interlaced frame\n"));
						    if (c->OpCode & mask)
						    {
							/* correct frame, poke new datafetch start */
							D(kprintf("found the right interlace field, so poke it\n"));
							c->DESTDATA = field2;
							return(c);
						    }

						}
						else
						{
						    /* not interlace, poke regardless */
						    /* poke new datafetch start */
						    D(kprintf("...poke it\n"));
						    c->DESTDATA = field2;
						    return(c);
						}
					    }
					    c++;
					    break;

			case COPPER_WAIT :  if (c->HWAITPOS == 255)
					    {
						/* yes, found end of list */
						D(kprintf("returning from pokeCopIns()...\n"));
						return(0);
					    }
					    else
					    {
						c++;
					    }
					    break;
			
			case CPRNXTBUF :    if (c->NXTLIST == NULL)
					    {
						error = TRUE;
					    }
					    else
					    {
						if ((c = c->NXTLIST->CopIns)==NULL)
						{
						    error = TRUE;
						}
					    }
					    break;

			default :	    error = TRUE;
					    break;
		    }	
			
		}
		/* !!! error condition !!! */
		/* break out of switch(op){} after encountering error */
		D(kprintf("error exit from pokeCopIns()...\n"));
		break;
	    }

	    case COPPER_WAIT :	
#ifdef QWEQWE
	    {
		D(kprintf("pokeCopIns: poke copper wait unsupported\n"));
		break;
	    }
#endif

	    case CPRNXTBUF :	
#ifdef QWEQWE
	    {
		D(kprintf("pokeCopIns: poke copper nextbuf unsupported\n"));
		break;
	    }
#endif

	    default :
	    {
		D(kprintf("pokeCopIns: bad opcode\n"));
		break;
	    }
	}
    }					    
	return (0);
}

#endif /* if not MAKE_PROTOS */

/**************************************************************************/
/* scrollvport(): non-destructively scroll viewport in its rastport(s) */
/*									  */
/**************************************************************************/

#define MIN_YTOP        0x15

#define HFIX(x) (((x)*mspc->ratioh)>>4)
#define VFIX(y) (((y)*mspc->ratiov)>>4)

void scrollvport(struct ViewPort *vp)
{
    struct RasInfo *r1, *r2;
    struct CopList *cl;
    UWORD *lfstart, *sfstart;
    struct CopIns *c = 0;
    short i;
    short depth;
    struct Custom *io;
    struct View *view;
    struct pbCprList_info pbcprlist;
    struct ViewExtra *ve=0;
    UWORD modes = new_mode(vp);
    struct BuildData bd;
    BOOL usefmode;

    if (vp->Modes & VP_HIDE) return; /* bart - 08.13.85 */

    D(kprintf("&custom=%lx\n",&custom));

    /* single thread access to ActiView hardware copper list */

    ObtainSemaphore(GBASE->ActiViewCprSemaphore);

    if(view = GBASE->ActiView)
    {

	if (view->Modes & EXTEND_VSTRUCT)
	{
	    ve = (struct ViewExtra *) GfxLookUp(view);
	}

	io = &custom;
	D(kprintf("io=%lx\n",io));

	cl = vp->DspIns;
	if (cl)
	{
		c = cl->CopIns;
	}

	r1 = vp->RasInfo;
	r2 = NULL;
	if (modes & DUALPF) r2 = r1->Next;  /* get second playfield */

	/* OK so far, start scrollviewport routine proper */

	/* get pointers to the start of hardware copper lists for this viewport, if any */

	pbcprlist.cil = lfstart = cl->CopLStart;
	pbcprlist.cis = sfstart = cl->CopSStart;
	/* bart - 09.25.86 remember to check lace bit for view too */
	pbcprlist.flags = modes | view->Modes;

	depth = r1->BitMap->Depth;
	D(kprintf("depth=%lx\n",depth));

	/* do stuff for standard view */

	if (getclipstuff(view, vp, &bd) == GOOD_CLIPSTUFF)
	{
	    UWORD bpr = r1->BitMap->BytesPerRow;
	    UBYTE **pptr;
	    UBYTE *p;

	    /* poke new values for ddfstrt, ddfstop, and scroll into hardware copper list(s) */

	    /* minimize update clashes */
	    WaitBOVP(vp);

	    if (usefmode = (bd.Flags & BD_FUDGEDFMODE))
	    {
		pokebothCprList(&pbcprlist,&custom.fmode,bd.FudgedFMode);
	    }

	    D(kprintf("poke new hardware long frame value for dafstrt\n"));
	    D(kprintf("&custom.ddfstrt=%lx dafstrt=%lx\n",&custom.ddfstrt,bd.dafstrt));
	    pokebothCprList(&pbcprlist,&custom.ddfstrt,bd.DDFStrt);

	    D(kprintf("poke new hardware long frame value for bpl1mod\n"));
	    D(kprintf("&custom.bpl1mod=%lx bplmod=%lx\n",&custom.bpl1mod,bplmod));
	    pokebothCprList(&pbcprlist,&custom.bpl1mod,bd.Modulo);

	    if ((depth > 1) || (bd.Flags & (BD_IS_SDBL | BD_IS_DPF)))
	    {
		D(kprintf("poke new hardware long frame bit plane modulos for more bit planes\n"));
		D(kprintf("&custom.bpl2mod=%lx bplmod=%lx\n",&custom.bpl2mod,bplmod));
		pokebothCprList(&pbcprlist,&custom.bpl2mod,bd.Modulo2);
	    }

	    D(kprintf("poke new hardware long frame value for dafstop\n"));
	    D(kprintf("&custom.ddfstop=%lx dafstop=%lx\n",&custom.ddfstop,bd.0].dafstop));
	    pokebothCprList(&pbcprlist,&custom.ddfstop,bd.DDFStop);

	    D(kprintf("poke new hardware long frame value for scroll\n"));
	    D(kprintf("&custom.bplcon1=%lx ((scroll<<4)|scroll)=%lx\n",&custom.bplcon1,scrollword));
	    pokebothCprList(&pbcprlist,&custom.bplcon1,bd.bplcon1);

	    if (c)	/* if there is an intermediate copper list */
	    {
		/* poke new values for ddfstrt, ddfstop, and scroll */
		/* into intermediate copper list */
		if (usefmode)
		{
			pokeCopIns(c,COPPER_MOVE,&custom.fmode,bd.FudgedFMode);
		}

		D(kprintf("poke new intermediate copper list value for dafstrt\n"));
		D(kprintf("&custom.ddfstrt=%lx dafstrt=%lx\n",&custom.ddfstrt,dafstrt));
		pokeCopIns(c,COPPER_MOVE,&custom.ddfstrt,bd.DDFStrt);

		D(kprintf("poke new intermediate copper list value for dafstop\n"));
		D(kprintf("&custom.ddfstrt=%lx dafstop=%lx\n",&custom.ddfstrt,bd.0].dafstop));
		pokeCopIns(c,COPPER_MOVE,&custom.ddfstop,bd.DDFStop);

		D(kprintf("poke new intermediate copper list value for scroll\n"));
		D(kprintf("&custom.bplcon1=%lx ((scroll<<4)|scroll)=%lx\n",&custom.bplcon1,scrollword));
		pokeCopIns(c,COPPER_MOVE,&custom.bplcon1, bd.bplcon1);

		D(kprintf("poke intermediate copper list bit plane modulos for first bitplane\n"));
		D(kprintf("&custom.bpl1mod=%lx bplmod=%lx\n",&custom.bpl1mod,bplmod));
		pokeCopIns(c,COPPER_MOVE,&custom.bpl1mod, bd.Modulo);
		if ((depth > 1) || (bd.Flags & (BD_IS_SDBL | BD_IS_DPF)))
		{
		    D(kprintf("poke intermediate bit plane modulos for more bit planes\n"));
		    D(kprintf("&custom.bpl2mod=%lx bplmod=%lx\n",&custom.bpl2mod,bplmod));
		    pokeCopIns(c,COPPER_MOVE,&custom.bpl2mod, bd.Modulo);
		}
	    }

	    if (r2 == NULL)
	    {
		pptr = r1->BitMap->Planes;
		for (i=0;i<depth;i++)
		{

			/* grab em and jam em */
			p = (*pptr++) + bd.Offset;

			if (modes & INTERLACE)
			{
			    int tp = (int)p + bpr;

			    D(kprintf("poke hardware copper list short frame bit plane[%lx] pointer in interlace mode\n",i));
			    npokeCprList(sfstart,(UWORD *) &custom.bplpt[i],(UWORD *) &tp,2);
			}
			else
			{
			    D(kprintf("poke hardware long frame bit plane[%lx] pointer\n",i));
			    npokeCprList(lfstart,(UWORD *) &custom.bplpt[i],(UWORD *)&p,2);

			    if(view->Modes&INTERLACE)
			    {
				D(kprintf("poke hardware copper list short frame bit plane[%lx] pointer in view->Modes interlace mode\n",i));
				npokeCprList(sfstart,(UWORD *) &custom.bplpt[i],(UWORD *) &p,2);
			    }
			}

			if (view->Modes&INTERLACE&modes)
			{
			    D(kprintf("poke hardware long frame bit plane[%lx] pointer\n",i));
			    npokeCprList(lfstart,(UWORD *) &custom.bplpt[i],(UWORD *) &p,2);
			}
		}
		if (c)
		{
			pptr = r1->BitMap->Planes;
			for (i=0;i<depth;i++)
			{
    
			    /* grab em and jam em */
			    p = (*pptr++) + bd.Offset;
    
			    if (modes & INTERLACE)
			    {
				    D(kprintf("poke intermediate copper list short frame bit plane[%lx] pointer in interlace mode\n",i));
				    pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,(UWORD *) &custom.bplpt[i],(TOBB((long)p)+TOBB(bpr))>>16);
				    pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,(UWORD *)((short)(&custom.bplpt[i])+2),(TOBB((long)p)+TOBB(bpr)));
			    }
			    else
			    {
				    D(kprintf("poke intermediate copper list bit plane[%lx] pointer\n",i));
				    pokeCopIns(c,COPPER_MOVE,(UWORD *) &custom.bplpt[i],TOBB((long)p>>16));
				    pokeCopIns(c,COPPER_MOVE,(UWORD *)((short)(&custom.bplpt[i])+2),TOBB((long)p));
			    }
    
			    if (view->Modes&INTERLACE&modes)
			    {
				    D(kprintf("poke long frame bit plane[%lx] pointer in interlace mode\n",i));
				    pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,(UWORD *) &custom.bplpt[i],TOBB((long)p>>16));
				    pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,(UWORD *)((short)(&custom.bplpt[i])+2),TOBB((long)p));
			    }
			}
		}
	    }
	    else    /* do dual playfield mode */
	    {
		UWORD bpr[2];
		UBYTE **pptr1,**pptr2;
		UBYTE *p;

		bpr[0] = r1->BitMap->BytesPerRow;
		bpr[1] = r2->BitMap->BytesPerRow;
		depth += r2->BitMap->Depth;

		/* now send out bit plane pointers */
		pptr1 = r1->BitMap->Planes;
		pptr2 = r2->BitMap->Planes;
		for (i=0;i<depth;i++)
		{
		    if (i & 1)  p = *pptr2++ + bd.Offset2;
		    else        p = *pptr1++ + bd.Offset;

		    if (modes & INTERLACE)
		    {
			D(kprintf("poke hardware short frame bit plane[%lx] pointer in interlace mode\n",i));
			npokeCprList(sfstart,(UWORD *)&custom.bplpt[i],(UWORD *) &p,2);
		    }
		    else
		    {
			D(kprintf("poke hardware long frame bit plane[%lx] pointer in non-interlace mode\n",i));
			npokeCprList(lfstart,(UWORD *) &custom.bplpt[i],(UWORD *) &p,2);

			if(view->Modes&INTERLACE)
			{
			    D(kprintf("poke hardware short frame bit plane[%lx] pointer in view->Modes interlace mode\n",i));
			    npokeCprList(sfstart,(UWORD *) &custom.bplpt[i],(UWORD *) &p,2);
			}
		    }

		    if (view->Modes&INTERLACE&modes)
		    {
			D(kprintf("poke hardware long frame bit plane[%lx] pointer in interlace mode\n",i));
			npokeCprList(lfstart,(UWORD *) &custom.bplpt[i],(UWORD *) &p,2);
		    }
		}

		if (c)
		{
			/* poke new values for fstrt, fstop, and scroll into intermediate copper list */

			if (usefmode)
			{
				pokeCopIns(c,COPPER_MOVE,&custom.fmode, bd.FudgedFMode);
			}

			D(kprintf("poke new intermediate copper list value for fstrt\n"));
			pokeCopIns(c,COPPER_MOVE,&custom.ddfstrt, bd.DDFStrt);

			D(kprintf("poke new value for fstop\n"));
			pokeCopIns(c,COPPER_MOVE,&custom.ddfstop, bd.DDFStop);

			D(kprintf("poke new value for scroll\n"));
			pokeCopIns(c,COPPER_MOVE,&custom.bplcon1, bd.bplcon1);

			D(kprintf("poke new intermediate copper list modulo for first bitplane\n"));
			pokeCopIns(c,COPPER_MOVE,&custom.bpl1mod, bd.Modulo);

			if (depth > 1)
			{
			    D(kprintf("poke new intermediate copper list modulo for multiple bitplanes\n"));
			    pokeCopIns(c,COPPER_MOVE,&custom.bpl2mod, bd.Modulo2);
			}

			/* now send out bit plane pointers */
			pptr1 = r1->BitMap->Planes;
			pptr2 = r2->BitMap->Planes;
			for (i=0;i<depth;i++)
			{
			    if (i & 1)  p = *pptr2++ + bd.Offset2;
			    else        p = *pptr1++ + bd.Offset;

			    if (modes & INTERLACE)
			    {
				D(kprintf("poke intermediate copper list short frame bit plane[%lx] pointer in interlace mode\n",i));
				pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,(UWORD *) &custom.bplpt[i],(TOBB((long)p)+TOBB(bpr[i&1]))>>16);
				pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,(UWORD *)((short)(&custom.bplpt[i])+2),(TOBB((long)p)+TOBB(bpr[i&1])));
			    }
			    else
			    {
				D(kprintf("poke intermediate copper list bit plane[%lx] pointer in non-interlace mode\n",i));
				pokeCopIns(c,COPPER_MOVE,(UWORD *) &custom.bplpt[i],TOBB((long)p>>16));
				pokeCopIns(c,COPPER_MOVE,(UWORD *)((short)(&custom.bplpt[i])+2),TOBB((long)p));
			    }

			    if (view->Modes&INTERLACE&modes)
			    {
				D(kprintf("poke intermediate copper list long frame bit plane[%lx] pointer in interlace mode\n",i));
				pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,(UWORD *)&custom.bplpt[i],TOBB((long)p>>16));
				pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,(UWORD *)((short)(&custom.bplpt[i])+2),TOBB((long)p));
			    }
			}
		    }
	    }
	}	/* lines up with GOOD_CLIPSTUFF line */
    }

    ReleaseSemaphore(GBASE->ActiViewCprSemaphore);
}

#endif
@


39.13
log
@got rid of all warnings!!!
 now works with __regargs.
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 39.12 92/05/05 12:17:54 chrisg Exp Locker: chrisg $
d26 4
d546 1
@


39.12
log
@regargs.
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 39.11 92/02/25 14:27:38 spence Exp Locker: chrisg $
d55 1
a55 1
	long cil,cis;
d61 1
a61 4
__regargs npokeCprList(ci,target,table,num)
UWORD *ci;
int target;
UWORD *table;
d63 1
d67 1
a67 1
    target &= 0x1FE;
d73 1
a73 1
		if (*ci == target) break;
d82 1
a82 1
		if (*ci == target)
d89 1
a89 1
		target += 2;
a91 1
#endif
d93 1
a93 1
__regargs pokeCprList(ci,field1,field2)
d100 1
a100 1
int __regargs pokebothCprList(struct pbCprList_info *pb, int field1, int field2)
d116 1
a116 4
struct CopIns * __regargs pokeCopIns(ci,op,field1,field2)
struct CopIns *ci;
short op;
short field1,field2;
d136 1
a136 1
					    if (c->DESTADDR == field1)
d230 1
d242 1
a242 2
scrollvport(vp)
struct ViewPort *vp;
d246 1
a246 1
    struct CopList *lfstart, *sfstart;
d386 1
a386 1
			    npokeCprList(sfstart,&custom.bplpt[i],&tp,2);
d391 1
a391 1
			    npokeCprList(lfstart,&custom.bplpt[i],&p,2);
d396 1
a396 1
				npokeCprList(sfstart,&custom.bplpt[i],&p,2);
d403 1
a403 1
			    npokeCprList(lfstart,&custom.bplpt[i],&p,2);
d418 2
a419 2
				    pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,&custom.bplpt[i],(TOBB((long)p)+TOBB(bpr))>>16);
				    pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,(short)(&custom.bplpt[i])+2,(TOBB((long)p)+TOBB(bpr)));
d424 2
a425 2
				    pokeCopIns(c,COPPER_MOVE,&custom.bplpt[i],TOBB((long)p>>16));
				    pokeCopIns(c,COPPER_MOVE,(short)(&custom.bplpt[i])+2,TOBB((long)p));
d431 2
a432 2
				    pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,&custom.bplpt[i],TOBB((long)p>>16));
				    pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,(short)(&custom.bplpt[i])+2,TOBB((long)p));
a456 2
			int tp = (int)p + bpr[i & 1];

d458 1
a458 1
			npokeCprList(sfstart,&custom.bplpt[i],&p,2);
d463 1
a463 1
			npokeCprList(lfstart,&custom.bplpt[i],&p,2);
d468 1
a468 1
			    npokeCprList(sfstart,&custom.bplpt[i],&p,2);
d475 1
a475 1
			npokeCprList(lfstart,&custom.bplpt[i],&p,2);
d517 2
a518 2
				pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,&custom.bplpt[i],(TOBB((long)p)+TOBB(bpr[i&1]))>>16);
				pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,(short)(&custom.bplpt[i])+2,(TOBB((long)p)+TOBB(bpr[i&1])));
d523 2
a524 2
				pokeCopIns(c,COPPER_MOVE,&custom.bplpt[i],TOBB((long)p>>16));
				pokeCopIns(c,COPPER_MOVE,(short)(&custom.bplpt[i])+2,TOBB((long)p));
d530 2
a531 2
				pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,&custom.bplpt[i],TOBB((long)p>>16));
				pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,(short)(&custom.bplpt[i])+2,TOBB((long)p));
@


39.11
log
@Removed call to InitBuildData()
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 39.10 92/01/07 16:06:13 spence Exp Locker: spence $
a57 7
int pokebothCprList(struct pbCprList_info *pb, int field1, int field2)
{
	UWORD	qwe = field2;
	npokeCprList(pb->cil,field1,&qwe,1);	/* long frame */
	if (pb->flags&LACE)
		npokeCprList(pb->cis,field1,&qwe,1);	/* short frame */
}
d61 1
a61 1
npokeCprList(ci,target,table,num)
d96 1
a96 1
pokeCprList(ci,field1,field2)
d103 8
d119 1
a119 1
struct CopIns *pokeCopIns(ci,op,field1,field2)
@


39.10
log
@gfxlookup -> GfxLookUp
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 39.9 92/01/03 16:04:37 spence Exp Locker: spence $
a277 1
	InitBuildData(&bd, vp, ve);
@


39.9
log
@removed dualpf code duplication
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 39.8 91/12/20 15:49:22 spence Exp Locker: spence $
d276 1
a276 1
	    ve = (struct ViewExtra *) gfxlookup(view);
@


39.8
log
@check if depth > 1, or mode is scandoubled before poking modulo2
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 39.7 91/11/15 18:57:59 spence Exp Locker: spence $
a308 4
	usefmode = (bd.Flags & BD_FUDGEDFMODE);

	if ( r2 == 0)
	{
d318 1
a318 1
	    if (usefmode)
d331 1
a331 1
	    if ((depth > 1) || (bd.Flags & BD_IS_SDBL))
a345 33
	    pptr = r1->BitMap->Planes;
	    for (i=0;i<depth;i++)
	    {

		/* grab em and jam em */
		p = (*pptr++) + bd.Offset;

		if (modes & INTERLACE)
		{
		    int tp = (int)p + bpr;

		    D(kprintf("poke hardware copper list short frame bit plane[%lx] pointer in interlace mode\n",i));
		    npokeCprList(sfstart,&custom.bplpt[i],&tp,2);
		}
		else
		{
		    D(kprintf("poke hardware long frame bit plane[%lx] pointer\n",i));
		    npokeCprList(lfstart,&custom.bplpt[i],&p,2);

		    if(view->Modes&INTERLACE)
		    {
			D(kprintf("poke hardware copper list short frame bit plane[%lx] pointer in view->Modes interlace mode\n",i));
			npokeCprList(sfstart,&custom.bplpt[i],&p,2);
		    }
		}

		if (view->Modes&INTERLACE&modes)
		{
		    D(kprintf("poke hardware long frame bit plane[%lx] pointer\n",i));
		    npokeCprList(lfstart,&custom.bplpt[i],&p,2);
		}
	    }

d370 1
a370 1
		if ((depth > 1) || (bd.Flags & BD_IS_SDBL))
d376 1
d378 2
d383 34
d418 2
a419 2
		    /* grab em and jam em */
		    p = (*pptr++) + bd.Offset;
d421 12
a432 12
		    if (modes & INTERLACE)
		    {
			    D(kprintf("poke intermediate copper list short frame bit plane[%lx] pointer in interlace mode\n",i));
			    pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,&custom.bplpt[i],(TOBB((long)p)+TOBB(bpr))>>16);
			    pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,(short)(&custom.bplpt[i])+2,(TOBB((long)p)+TOBB(bpr)));
		    }
		    else
		    {
			    D(kprintf("poke intermediate copper list bit plane[%lx] pointer\n",i));
			    pokeCopIns(c,COPPER_MOVE,&custom.bplpt[i],TOBB((long)p>>16));
			    pokeCopIns(c,COPPER_MOVE,(short)(&custom.bplpt[i])+2,TOBB((long)p));
		    }
d434 7
a440 6
		    if (view->Modes&INTERLACE&modes)
		    {
			    D(kprintf("poke long frame bit plane[%lx] pointer in interlace mode\n",i));
			    pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,&custom.bplpt[i],TOBB((long)p>>16));
			    pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,(short)(&custom.bplpt[i])+2,TOBB((long)p));
		    }
d443 1
a443 14
	}
	else    /* do dual playfield mode */
	{
	    UWORD bpr[2];
	    UBYTE **pptr1,**pptr2;
	    UBYTE *p;

	    bpr[0] = r1->BitMap->BytesPerRow;
	    bpr[1] = r2->BitMap->BytesPerRow;
	    depth += r2->BitMap->Depth;

	    /* now get the information to poke into the current display list */

	    if (getclipstuff(view, vp, &bd) == GOOD_CLIPSTUFF)
d445 3
a447 8

		/* minimize update clashes */
		WaitBOVP(vp);

		if (usefmode)
		{
			pokebothCprList(&pbcprlist,&custom.fmode,bd.FudgedFMode);
		}
d449 3
a451 14
		D(kprintf("poke new hardware long frame value for fstrt\n"));
		pokebothCprList(&pbcprlist,&custom.ddfstrt,bd.DDFStrt);

		D(kprintf("poke new hardware long frame value for bpl1mod\n"));
		pokebothCprList(&pbcprlist,&custom.bpl1mod, bd.Modulo);

		if (depth > 1)
		{
		    D(kprintf("poke new hardware long frame modulo for multiple bitplanes\n"));
		    pokebothCprList(&pbcprlist,&custom.bpl2mod, bd.Modulo2);
		}

		D(kprintf("poke new hardware long frame value for fstop\n"));
		pokebothCprList(&pbcprlist,&custom.ddfstop, bd.DDFStop);
a452 3
		D(kprintf("poke new hardware long frame value for scroll\n"));
		pokebothCprList(&pbcprlist,&custom.bplcon1, bd.bplcon1);

d487 1
a487 5
	    if (c)
	    {
		/* poke new values for fstrt, fstop, and scroll into intermediate copper list */

		if (usefmode)
d489 1
a489 2
			pokeCopIns(c,COPPER_MOVE,&custom.fmode, bd.FudgedFMode);
		}
d491 4
a494 2
		D(kprintf("poke new intermediate copper list value for fstrt\n"));
		pokeCopIns(c,COPPER_MOVE,&custom.ddfstrt, bd.DDFStrt);
d496 2
a497 2
		D(kprintf("poke new value for fstop\n"));
		pokeCopIns(c,COPPER_MOVE,&custom.ddfstop, bd.DDFStop);
d499 5
a503 2
		D(kprintf("poke new value for scroll\n"));
		pokeCopIns(c,COPPER_MOVE,&custom.bplcon1, bd.bplcon1);
d505 2
a506 2
		D(kprintf("poke new intermediate copper list modulo for first bitplane\n"));
		pokeCopIns(c,COPPER_MOVE,&custom.bpl1mod, bd.Modulo);
d508 5
a512 5
		if (depth > 1)
		{
		    D(kprintf("poke new intermediate copper list modulo for multiple bitplanes\n"));
		    pokeCopIns(c,COPPER_MOVE,&custom.bpl2mod, bd.Modulo2);
		}
d514 7
a520 7
		/* now send out bit plane pointers */
		pptr1 = r1->BitMap->Planes;
		pptr2 = r2->BitMap->Planes;
		for (i=0;i<depth;i++)
		{
		    if (i & 1)  p = *pptr2++ + bd.Offset2;
		    else        p = *pptr1++ + bd.Offset;
d522 20
a541 18
		    if (modes & INTERLACE)
		    {
			D(kprintf("poke intermediate copper list short frame bit plane[%lx] pointer in interlace mode\n",i));
			pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,&custom.bplpt[i],(TOBB((long)p)+TOBB(bpr[i&1]))>>16);
			pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,(short)(&custom.bplpt[i])+2,(TOBB((long)p)+TOBB(bpr[i&1])));
		    }
		    else
		    {
			D(kprintf("poke intermediate copper list bit plane[%lx] pointer in non-interlace mode\n",i));
			pokeCopIns(c,COPPER_MOVE,&custom.bplpt[i],TOBB((long)p>>16));
			pokeCopIns(c,COPPER_MOVE,(short)(&custom.bplpt[i])+2,TOBB((long)p));
		    }

		    if (view->Modes&INTERLACE&modes)
		    {
			D(kprintf("poke intermediate copper list long frame bit plane[%lx] pointer in interlace mode\n",i));
			pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,&custom.bplpt[i],TOBB((long)p>>16));
			pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,(short)(&custom.bplpt[i])+2,TOBB((long)p));
a542 1
		}
a543 2
	    }	/* lines up with GOOD_CLIPSTUFF */
	}
@


39.7
log
@Checks if clipstuff() fails
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 39.6 91/10/28 17:17:43 spence Exp Locker: spence $
d335 1
a335 1
	    if (depth > 1)
d339 1
a339 1
		pokebothCprList(&pbcprlist,&custom.bpl2mod,bd.Modulo);
d407 1
a407 1
		if (depth > 1)
@


39.6
log
@usefmode BOOL was initialised too early.
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 39.5 91/10/18 19:16:55 spence Exp Locker: spence $
d307 2
a308 1
	getclipstuff(view, vp, &bd);
d455 2
a456 1
	    getclipstuff(view, vp, &bd);
d574 1
d576 1
@


39.5
log
@InitBuildData() also takes a *ViewPort now.
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 39.4 91/10/17 14:00:33 chrisg Exp Locker: spence $
d261 1
a261 1
    BOOL usefmode = (bd.Flags & BD_FUDGEDFMODE);
d308 1
@


39.4
log
@killed typedef
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 39.3 91/10/11 17:40:44 spence Exp Locker: chrisg $
d278 1
a278 1
	InitBuildData(&bd, ve);
@


39.3
log
@pokes the fmode value in the copperlists if there is one (checked by
looking for BuildData->Flags == BD_FUDGEDFMODE)
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 39.2 91/08/27 17:55:11 spence Exp Locker: spence $
d260 1
a260 1
    BuildData bd;
@


39.2
log
@use new custom.h instead of newcustom.h
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 39.1 91/08/27 16:50:41 spence Exp Locker: spence $
d261 2
d320 5
d326 1
a326 1
	    D(kprintf("&custom.ddfstrt=%lx dafstrt=%lx\n",&custom.ddfstrt,info[0].dafstrt));
d341 1
a341 1
	    D(kprintf("&custom.ddfstop=%lx dafstop=%lx\n",&custom.ddfstop,info[0].dafstop));
d385 5
d395 1
a395 1
		D(kprintf("&custom.ddfstrt=%lx dafstop=%lx\n",&custom.ddfstrt,info[0].dafstop));
d458 5
d464 1
a464 1
		pokeCprList(lfstart,&custom.ddfstrt,bd.DDFStrt);
d518 6
@


39.1
log
@Uses database via new getclipstuff().
Tidied up debug stuff
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 39.0 91/08/21 17:21:59 chrisg Exp Locker: spence $
d21 1
a21 1
#include <hardware/newcustom.h>
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 37.3 91/06/06 14:08:52 chrisg Exp Locker: chrisg $
d13 7
a19 5
#include <graphics/gfx.h>
#include <graphics/gfxbase.h>
#include <graphics/display.h>
#include <graphics/copper.h>
#include <graphics/view.h>
d21 1
a21 1
#include <hardware/custom.h>
a23 5
#define PROTOTYPE_DISPLAY
#ifdef  PROTOTYPE_DISPLAY
#include "/displayinfo_internal.h"
#endif

a30 1
#include "gs_info.h"
d32 2
a33 5
#ifndef SAVE_CODESPACE
scrollvport(vp)
struct ViewPort *vp;
{
	struct RasInfo *r1,*r2;
d35 4
a38 8
	r1 = vp->RasInfo;
	r2 = r1;
	if (vp->Modes & DUALPF) r2 = r1->Next;

	if (vp->Modes & VP_HIDE) return; /* bart - 08.13.85 */

	scrollviewport(vp,r1->RxOffset,r1->RyOffset,r2->RxOffset,r2->RyOffset);
}
a39 2
/* #define DEBUG */
#define SCREENS
d58 1
a58 2
pokebothCprList(pb,field1,field2)
struct pbCprList_info *pb;
d125 2
a126 8
#ifdef DEBUG
	printf("poking another CopIns\n");
#endif

#ifdef DEBUG
	printf("op=%lx field1=%lx field2=%lx\n",op,field1,field2);
	Debug();
#endif
d145 1
a145 3
#ifdef DEBUG
						printf("found an instruction with the right destination address\n");
#endif
d151 1
a151 3
#ifdef DEBUG
						    printf("looking for an interlaced frame\n");
#endif
d155 1
a155 3
#ifdef DEBUG
							printf("found the right interlace field, so poke it\n");
#endif
d165 1
a165 3
#ifdef DEBUG
						    printf("...poke it\n");
#endif
d176 1
a176 3
#ifdef DEBUG
						printf("returning from pokeCopIns()...\n");
#endif
d205 1
a205 3
#ifdef DEBUG
		printf("error exit from pokeCopIns()...\n");
#endif
d212 1
a212 3
#ifdef DEBUG
		printf("pokeCopIns: poke copper wait unsupported\n");
#endif
d220 1
a220 3
#ifdef DEBUG
		printf("pokeCopIns: poke copper nextbuf unsupported\n");
#endif
d227 1
a227 3
#ifdef DEBUG
		printf("pokeCopIns: bad opcode\n");
#endif
a256 1
    struct GfxBase *GB;
a257 1
    struct gs_info info[2];
a258 3
    struct MonitorSpec *mspc=0;
    short min_ytop = MIN_YTOP; /* default limit */
    short yclip;
d260 1
a260 1

d263 1
a263 5
    FETCHGBASE;

#ifdef DEBUG
    printf("&custom=%lx\n",&custom);
#endif
d267 1
a267 1
    ObtainSemaphore(GB->ActiViewCprSemaphore);
d269 1
a269 1
    if(view = GB->ActiView)
a271 2
	mspc = GB->default_monitor;

d274 1
a274 4
	    if((ve = (struct ViewExtra *) gfxlookup(view)) && ve->Monitor)
	    {
		mspc = ve->Monitor;
	    }
d276 1
a276 4

	min_ytop = mspc->min_row;

	/* yclip top of viewport (non-positive) -- bart */
a277 2
	yclip = HFIX(MIN((VFIX(view->DyOffset+(modes&LACE?(vp->DyOffset>>1):vp->DyOffset))-min_ytop),0));
	
d279 1
a280 4
#ifdef DEBUG
	printf("io=%lx\n",io);
#endif

d282 4
a285 2

	if (cl)	c = cl->CopIns;
a287 1

a288 1

d301 1
a301 4
#ifdef DEBUG
	printf("depth=%lx\n",depth);
	Debug();
#endif
d305 1
a305 6
#ifdef CLIPPING
	getclipstuff(view,vp,r1,&info[0],yclip);
#else
	getstuff(view,vp,r1,&info[0]);
#endif

d309 3
a311 13
	    short dbytes,bplmod,scrollword;
	    UBYTE **pptr,*p;
		    
#define NEWSTUFF_NOW
#ifdef NEWSTUFF_NOW
	dbytes = get_dbytes(vp,info[0].dafstrt,info[0].dafstop);
#else
	    /* now get the information to poke into the current display list */
	    dbytes = 2 + ( (info[0].dafstop - info[0].dafstrt)>>2 );
	    if (modes & HIRES)   dbytes <<= 1;
#endif

	    /* set up bit plane modulos */
d313 1
a313 1
	    bplmod = info[0].rbytes - dbytes;
a314 13
	    if (view->Modes & modes & INTERLACE)
	    {
		bplmod += info[0].rbytes;
	    }

	    scrollword = ((info[0].scroll<<4)|info[0].scroll);

	    /* poke new values for dafstrt, dafstop, and scroll into hardware copper list(s) */

#ifdef VP_IN_VIEW /* { */
		if( vp_in_view(GB->ActiView,vp) )
#endif /* } */
		{
d318 3
a320 6
#ifdef DEBUG
	    printf("poke new hardware long frame value for dafstrt\n");
	    printf("&custom.ddfstrt=%lx dafstrt=%lx\n",&custom.ddfstrt,info[0].dafstrt);
	    Debug();
#endif
	    pokebothCprList(&pbcprlist,&custom.ddfstrt,info[0].dafstrt);
d322 3
a324 6
#ifdef DEBUG
	    printf("poke new hardware long frame value for bpl1mod\n");
	    printf("&custom.bpl1mod=%lx bplmod=%lx\n",&custom.bpl1mod,bplmod);
	    Debug();
#endif
	    pokebothCprList(&pbcprlist,&custom.bpl1mod,bplmod);
d328 3
a330 8

#ifdef DEBUG
		printf("poke new hardware long frame bit plane modulos for more bit planes\n");
		printf("&custom.bpl2mod=%lx bplmod=%lx\n",&custom.bpl2mod,bplmod);
		Debug();
#endif
		pokebothCprList(&pbcprlist,&custom.bpl2mod,bplmod);

d333 3
a335 6
#ifdef DEBUG
	    printf("poke new hardware long frame value for dafstop\n");
	    printf("&custom.ddfstop=%lx dafstop=%lx\n",&custom.ddfstop,info[0].dafstop);
	    Debug();
#endif
	    pokebothCprList(&pbcprlist,&custom.ddfstop,info[0].dafstop);
d337 3
a339 6
#ifdef DEBUG
	    printf("poke new hardware long frame value for scroll\n");
	    printf("&custom.bplcon1=%lx ((scroll<<4)|scroll)=%lx\n",&custom.bplcon1,scrollword);
	    Debug();
#endif
	    pokebothCprList(&pbcprlist,&custom.bplcon1,scrollword);
d346 1
a346 1
		p = (*pptr++) + info[0].plnskip;
d350 1
a350 1
		    int tp;
d352 1
a352 5
		    tp = (int)p + (int)info[0].rbytes;
#ifdef DEBUG
	printf("poke hardware copper list short frame bit plane[%lx] pointer in interlace mode\n",i);
	Debug();
#endif
d357 1
a357 5

#ifdef DEBUG
	    printf("poke hardware long frame bit plane[%lx] pointer\n",i);
	    Debug();
#endif
d362 1
a362 5

#ifdef DEBUG
			printf("poke hardware copper list short frame bit plane[%lx] pointer in view->Modes interlace mode\n",i);
			Debug();
#endif
a363 1

a364 1

d369 1
a369 4
#ifdef DEBUG
	    printf("poke hardware long frame bit plane[%lx] pointer\n",i);
	    Debug();
#endif
a370 1

d373 1
a373 1
		}
d376 1
a376 1
		/* poke new values for dafstrt, dafstop, and scroll */
d378 15
a392 20
#ifdef DEBUG
		printf("poke new intermediate copper list value for dafstrt\n");
		printf("&custom.ddfstrt=%lx dafstrt=%lx\n",&custom.ddfstrt,dafstrt);
#endif
		pokeCopIns(c,COPPER_MOVE,&custom.ddfstrt,info[0].dafstrt);
#ifdef DEBUG
		printf("poke new intermediate copper list value for dafstop\n");
		printf("&custom.ddfstrt=%lx dafstop=%lx\n",&custom.ddfstrt,info[0].dafstop);
#endif
		pokeCopIns(c,COPPER_MOVE,&custom.ddfstop,info[0].dafstop);
#ifdef DEBUG
		printf("poke new intermediate copper list value for scroll\n");
		printf("&custom.bplcon1=%lx ((scroll<<4)|scroll)=%lx\n",&custom.bplcon1,scrollword);
#endif
		pokeCopIns(c,COPPER_MOVE,&custom.bplcon1,scrollword);
#ifdef DEBUG
		printf("poke intermediate copper list bit plane modulos for first bitplane\n");
		printf("&custom.bpl1mod=%lx bplmod=%lx\n",&custom.bpl1mod,bplmod);
#endif
		pokeCopIns(c,COPPER_MOVE,&custom.bpl1mod,bplmod);
d395 3
a397 5
#ifdef DEBUG
		    printf("poke intermediate bit plane modulos for more bit planes\n");
		    printf("&custom.bpl2mod=%lx bplmod=%lx\n",&custom.bpl2mod,bplmod);
#endif
		    pokeCopIns(c,COPPER_MOVE,&custom.bpl2mod,bplmod);
d399 1
d405 1
a405 1
		    p = (*pptr++) + info[0].plnskip;
d409 3
a411 7

#ifdef DEBUG
    printf("poke intermediate copper list short frame bit plane[%lx] pointer in interlace mode\n",i);
#endif
			    pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,&custom.bplpt[i],(TOBB((long)p)+TOBB(info[0].rbytes))>>16);
			    pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,(short)(&custom.bplpt[i])+2,(TOBB((long)p)+TOBB(info[0].rbytes)));

d415 1
a415 4

#ifdef DEBUG
		    printf("poke intermediate copper list bit plane[%lx] pointer\n",i);
#endif
a417 1

d422 1
a422 4

#ifdef DEBUG
    printf("poke long frame bit plane[%lx] pointer in interlace mode\n",i);
#endif
a424 1

d431 1
a431 2
	    short bplmod[2],scrollword;
	    short fstrt,fstop,dbytes;
d435 2
d441 1
a441 30
#ifdef CLIPPING
	    getclipstuff(view,vp,r2,&info[1],yclip);
#else
	    getstuff(view,vp,r2,&info[1]);
#endif

		fstrt = SHORTMIN(info[0].dafstrt,info[1].dafstrt);
		fstop = SHORTMAX(info[0].dafstop,info[1].dafstop);

		if (modes & HIRES)  i = 4;
		else                    i = 2;

		if (fstrt < info[0].dafstrt) info[0].plnskip -= i;
		if (fstrt < info[1].dafstrt) info[1].plnskip -= i;

		/*dbytes = 2 + ( (fstop - fstrt)>>2 );*/
		/*if (modes & HIRES)   dbytes <<= 1;*/

		dbytes = get_dbytes(vp,fstrt,fstop);

		/* set up bit plane modulos */

		bplmod[0] = info[0].rbytes - dbytes;
		if (view->Modes & modes & INTERLACE)    bplmod[0] += info[0].rbytes;
		bplmod[1] = info[1].rbytes - dbytes;
		if (view->Modes & modes & INTERLACE)    bplmod[1] += info[1].rbytes;

		scrollword = ((info[1].scroll<<4)|info[0].scroll);

		/* poke new values for fstrt, fstop, and scroll into display list */
a442 4
#ifdef VP_IN_VIEW /* { */
		if( vp_in_view(GB->ActiView,vp) )
#endif /* } */
		{
d446 2
a447 11
#ifdef DEBUG
		printf("poke new hardware long frame value for fstrt\n");
		Debug();
#endif

		pokeCprList(lfstart,&custom.ddfstrt,fstrt);

#ifdef DEBUG
		printf("poke new hardware long frame value for bpl1mod\n");
		Debug();
#endif
d449 2
a450 1
		pokebothCprList(&pbcprlist,&custom.bpl1mod,bplmod[0]);
d454 2
a455 8

#ifdef DEBUG
		    printf("poke new hardware long frame modulo for multiple bitplanes\n");
		    Debug();
#endif

		    pokebothCprList(&pbcprlist,&custom.bpl2mod,bplmod[1]);

d458 2
a459 6
#ifdef DEBUG
		printf("poke new hardware long frame value for fstop\n");
		Debug();
#endif

		pokebothCprList(&pbcprlist,&custom.ddfstop,fstop);
d461 2
a462 6
#ifdef DEBUG
		printf("poke new hardware long frame value for scroll\n");
		Debug();
#endif
		/* pfa is [0] pfb is [1] */
		pokebothCprList(&pbcprlist,&custom.bplcon1,scrollword);
d469 2
a470 2
		    if (i & 1)  p = *pptr2++ + info[1].plnskip;
		    else        p = *pptr1++ + info[0].plnskip;
d474 1
a474 1
			int tp;
d476 2
a477 8
			tp = (int)p + (int)info[i&1].rbytes;

#ifdef DEBUG
			printf("poke hardware short frame bit plane[%lx] pointer in interlace mode\n",i);
			Debug();
#endif
			npokeCprList(sfstart,&custom.bplpt[i],&tp,2);

d481 1
a481 5

#ifdef DEBUG
			printf("poke hardware long frame bit plane[%lx] pointer in non-interlace mode\n",i);
			Debug();
#endif
d486 1
a486 5

#ifdef DEBUG
			    printf("poke hardware short frame bit plane[%lx] pointer in view->Modes interlace mode\n",i);
			    Debug();
#endif
a487 1

a488 1

d493 1
a493 4
#ifdef DEBUG
			printf("poke hardware long frame bit plane[%lx] pointer in interlace mode\n",i);
			Debug();
#endif
a494 1

a495 1

a496 1
		}
d501 2
a502 11

#ifdef DEBUG
		printf("poke new intermediate copper list value for fstrt\n");
#endif

		pokeCopIns(c,COPPER_MOVE,&custom.ddfstrt,fstrt);


#ifdef DEBUG
		printf("poke new value for fstop\n");
#endif
d504 5
a508 1
		pokeCopIns(c,COPPER_MOVE,&custom.ddfstop,fstop);
d510 2
a512 13
#ifdef DEBUG
		printf("poke new value for scroll\n");
#endif
		/* pfa is [0] pfb is [1] */
		pokeCopIns(c,COPPER_MOVE,&custom.bplcon1,scrollword);


#ifdef DEBUG
		printf("poke new intermediate copper list modulo for first bitplane\n");
#endif
		pokeCopIns(c,COPPER_MOVE,&custom.bpl1mod,bplmod[0]);


d515 2
a516 6

#ifdef DEBUG
		    printf("poke new intermediate copper list modulo for multiple bitplanes\n");
#endif
		    pokeCopIns(c,COPPER_MOVE,&custom.bpl2mod,bplmod[1]);

a518 1

d524 2
a525 2
		    if (i & 1)  p = *pptr2++ + info[1].plnskip;
		    else        p = *pptr1++ + info[0].plnskip;
d529 3
a531 6
#ifdef DEBUG
			printf("poke intermediate copper list short frame bit plane[%lx] pointer in interlace mode\n",i);
#endif
			pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,&custom.bplpt[i],(TOBB((long)p)+TOBB(info[i&1].rbytes))>>16);
			pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,(short)(&custom.bplpt[i])+2,(TOBB((long)p)+TOBB(info[i&1].rbytes)));

d535 1
a535 3
#ifdef DEBUG
			printf("poke intermediate copper list bit plane[%lx] pointer in non-interlace mode\n",i);
#endif
a537 1

d542 1
a542 4

#ifdef DEBUG
			printf("poke intermediate copper list long frame bit plane[%lx] pointer in interlace mode\n",i);
#endif
a544 1

d551 1
a551 1
    ReleaseSemaphore(GB->ActiViewCprSemaphore);
@


37.3
log
@improved compiler warning status.
rlog copper.c
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 37.2 91/05/20 11:20:15 chrisg Exp Locker: chrisg $
@


37.2
log
@Added prototypes, improved warnings, and glue code. still needs work.
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 1.1 91/05/20 10:47:44 chrisg Exp $
d84 1
a84 1
UWORD target;
@


37.1
log
@ changed "../" to "/" for native build
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 37.0 91/01/07 15:20:45 spence Exp Locker: chrisg $
d27 2
d81 1
d115 1
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 36.24 90/12/20 11:23:16 bart Exp Locker: spence $
d20 1
a20 1
#include "../macros.h"
d24 1
a24 1
#include "../displayinfo_internal.h"
@


36.24
log
@now intermediate copper lists have correct plane pointers
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 36.23 90/12/17 17:29:14 spence Exp Locker: bart $
@


36.23
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Id: scrollvp.c,v 36.22 90/07/27 16:59:49 bart Exp Locker: spence $
d541 2
a542 2
			    pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,&custom.bplpt[i],(TOBB((long)p)+TOBB(info[0].rbytes))>>16);
			    pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,(short)(&custom.bplpt[i])+2,(TOBB((long)p)+TOBB(info[0].rbytes)));
d562 2
a563 2
			    pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,&custom.bplpt[i],TOBB((long)p>>16));
			    pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,(short)(&custom.bplpt[i])+2,TOBB((long)p));
d769 2
a770 2
			pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,&custom.bplpt[i],(TOBB((long)p)+TOBB(info[i&1].rbytes))>>16);
			pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,(short)(&custom.bplpt[i])+2,(TOBB((long)p)+TOBB(info[i&1].rbytes)));
d789 2
a790 2
			pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,&custom.bplpt[i],TOBB((long)p>>16));
			pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,(short)(&custom.bplpt[i])+2,TOBB((long)p));
@


36.22
log
@id
@
text
@d3 1
a3 1
*	$Id: $
d398 1
d400 1
d611 1
d613 1
@


36.21
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/graphics/c/RCS/scrollvp.c,v 36.20 90/03/07 16:31:07 bart Exp Locker: bart $
@


36.20
log
@check for vp_in_view 
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.19 89/08/22 09:36:07 bart Exp $
@


36.19
log
@single thread access to ActiView hardware copper list
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.18 89/04/29 15:42:42 bart Exp $
d398 2
d493 1
d609 2
d708 1
a708 1

@


36.18
log
@cm->Type checking
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.17 89/02/17 22:04:15 bart Exp $
d308 4
d788 2
@


36.17
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.16 89/02/15 16:06:58 bart Exp $
d290 9
a298 9
	struct View *view;
	struct GfxBase *GB;
	struct pbCprList_info pbcprlist;
	struct gs_info info[2];
	struct ViewExtra *ve=0;
	struct MonitorSpec *mspc=0;
	short min_ytop = MIN_YTOP; /* default limit */
	short yclip;
	UWORD modes = new_mode(vp);
d300 1
a300 1
	if (vp->Modes & VP_HIDE) return; /* bart - 08.13.85 */
d302 1
a302 1
	FETCHGBASE;
d308 2
a309 1
	view = GB->ActiView;
d311 2
d315 1
a315 2
	    ve = gfxlookup(view);
	    if(ve)
a320 5
	if(!mspc)
	{
	    mspc = GB->default_monitor;
	}

d327 1
a327 1
    io = &custom;
d330 1
a330 1
    printf("io=%lx\n",io);
d333 1
a333 1
    cl = vp->DspIns;
d335 1
a335 1
    if (cl)	c = cl->CopIns;
d337 1
a337 1
    r1 = vp->RasInfo;
a339 1
    if (modes & DUALPF) r2 = r1->Next;  /* get second playfield */
d341 1
a341 1
    /* OK so far, start scrollviewport routine proper */
d343 1
a343 1
    /* get pointers to the start of hardware copper lists for this viewport, if any */
d345 4
a348 2
    pbcprlist.cil = lfstart = cl->CopLStart;
    pbcprlist.cis = sfstart = cl->CopSStart;
d352 1
a352 1
    depth = r1->BitMap->Depth;
d354 2
a355 2
    printf("depth=%lx\n",depth);
    Debug();
d358 1
a358 1
    /* do stuff for standard view */
d367 5
a371 5
    if ( r2 == 0)
    {
	short dbytes,bplmod,scrollword;
	UBYTE **pptr,*p;
		
d376 3
a378 3
	/* now get the information to poke into the current display list */
	dbytes = 2 + ( (info[0].dafstop - info[0].dafstrt)>>2 );
	if (modes & HIRES)   dbytes <<= 1;
d381 1
a381 1
	/* set up bit plane modulos */
d383 1
a383 1
	bplmod = info[0].rbytes - dbytes;
d385 4
a388 4
	if (view->Modes & modes & INTERLACE)
	{
	    bplmod += info[0].rbytes;
	}
d390 1
a390 1
	scrollword = ((info[0].scroll<<4)|info[0].scroll);
d392 1
a392 1
	/* poke new values for dafstrt, dafstop, and scroll into hardware copper list(s) */
d394 2
a395 2
	/* minimize update clashes */
	WaitBOVP(vp);
d398 3
a400 3
	printf("poke new hardware long frame value for dafstrt\n");
	printf("&custom.ddfstrt=%lx dafstrt=%lx\n",&custom.ddfstrt,info[0].dafstrt);
	Debug();
d402 1
a402 1
	pokebothCprList(&pbcprlist,&custom.ddfstrt,info[0].dafstrt);
d405 3
a407 3
	printf("poke new hardware long frame value for bpl1mod\n");
	printf("&custom.bpl1mod=%lx bplmod=%lx\n",&custom.bpl1mod,bplmod);
	Debug();
d409 1
a409 1
	pokebothCprList(&pbcprlist,&custom.bpl1mod,bplmod);
d411 2
a412 2
	if (depth > 1)
	{
d415 3
a417 3
	    printf("poke new hardware long frame bit plane modulos for more bit planes\n");
	    printf("&custom.bpl2mod=%lx bplmod=%lx\n",&custom.bpl2mod,bplmod);
	    Debug();
d419 1
a419 1
	    pokebothCprList(&pbcprlist,&custom.bpl2mod,bplmod);
d421 1
a421 1
	}
d424 3
a426 3
	printf("poke new hardware long frame value for dafstop\n");
	printf("&custom.ddfstop=%lx dafstop=%lx\n",&custom.ddfstop,info[0].dafstop);
	Debug();
d428 1
a428 1
	pokebothCprList(&pbcprlist,&custom.ddfstop,info[0].dafstop);
d431 3
a433 3
	printf("poke new hardware long frame value for scroll\n");
	printf("&custom.bplcon1=%lx ((scroll<<4)|scroll)=%lx\n",&custom.bplcon1,scrollword);
	Debug();
d435 1
a435 1
	pokebothCprList(&pbcprlist,&custom.bplcon1,scrollword);
d437 3
a439 3
	pptr = r1->BitMap->Planes;
	for (i=0;i<depth;i++)
	{
d441 2
a442 2
	    /* grab em and jam em */
	    p = (*pptr++) + info[0].plnskip;
d444 3
a446 3
	    if (modes & INTERLACE)
	    {
		int tp;
d448 1
a448 1
		tp = (int)p + (int)info[0].rbytes;
d453 4
a456 4
		npokeCprList(sfstart,&custom.bplpt[i],&tp,2);
	    }
	    else
	    {
d459 2
a460 2
	printf("poke hardware long frame bit plane[%lx] pointer\n",i);
	Debug();
d462 1
a462 1
		npokeCprList(lfstart,&custom.bplpt[i],&p,2);
d464 2
a465 2
		if(view->Modes&INTERLACE)
		{
d468 2
a469 2
		    printf("poke hardware copper list short frame bit plane[%lx] pointer in view->Modes interlace mode\n",i);
		    Debug();
d471 1
a471 1
		    npokeCprList(sfstart,&custom.bplpt[i],&p,2);
d473 2
d477 2
a478 4
	    }

	    if (view->Modes&INTERLACE&modes)
	    {
d480 2
a481 2
	printf("poke hardware long frame bit plane[%lx] pointer\n",i);
	Debug();
d483 1
a483 1
		npokeCprList(lfstart,&custom.bplpt[i],&p,2);
d485 1
d487 2
a488 3
	}
	if (c)	/* if there is an intermediate copper list */
	{
d514 2
a515 2
	    		printf("poke intermediate bit plane modulos for more bit planes\n");
	    		printf("&custom.bpl2mod=%lx bplmod=%lx\n",&custom.bpl2mod,bplmod);
d517 1
a517 1
	    		pokeCopIns(c,COPPER_MOVE,&custom.bpl2mod,bplmod);
d522 6
a527 6
	
	    		/* grab em and jam em */
	    		p = (*pptr++) + info[0].plnskip;
	
	    		if (modes & INTERLACE)
	    		{
d530 1
a530 1
	printf("poke intermediate copper list short frame bit plane[%lx] pointer in interlace mode\n",i);
d532 2
a533 2
				pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,&custom.bplpt[i],(TOBB((long)p)+TOBB(info[0].rbytes))>>16);
				pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,(short)(&custom.bplpt[i])+2,(TOBB((long)p)+TOBB(info[0].rbytes)));
d535 3
a537 3
	    		}
	    		else
	    		{
d540 1
a540 1
			printf("poke intermediate copper list bit plane[%lx] pointer\n",i);
d542 2
a543 2
				pokeCopIns(c,COPPER_MOVE,&custom.bplpt[i],TOBB((long)p>>16));
				pokeCopIns(c,COPPER_MOVE,(short)(&custom.bplpt[i])+2,TOBB((long)p));
d545 4
a548 4
		    	}
	
		    	if (view->Modes&INTERLACE&modes)
		    	{
d551 1
a551 1
	printf("poke long frame bit plane[%lx] pointer in interlace mode\n",i);
d553 2
a554 2
				pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,&custom.bplpt[i],TOBB((long)p>>16));
				pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,(short)(&custom.bplpt[i])+2,TOBB((long)p));
d556 1
a556 1
		    	}
d558 1
d560 6
a565 7
    }
    else    /* do dual playfield mode */
    {
	short bplmod[2],scrollword;
	short fstrt,fstop,dbytes;
	UBYTE **pptr1,**pptr2;
	UBYTE *p;
d567 1
a567 1
    	depth += r2->BitMap->Depth;
d569 1
a569 1
	/* now get the information to poke into the current display list */
d572 1
a572 1
	getclipstuff(view,vp,r2,&info[1],yclip);
d574 1
a574 1
	getstuff(view,vp,r2,&info[1]);
d577 2
a578 2
	    fstrt = SHORTMIN(info[0].dafstrt,info[1].dafstrt);
	    fstop = SHORTMAX(info[0].dafstop,info[1].dafstop);
d580 2
a581 2
	    if (modes & HIRES)  i = 4;
	    else                    i = 2;
d583 2
a584 2
	    if (fstrt < info[0].dafstrt) info[0].plnskip -= i;
	    if (fstrt < info[1].dafstrt) info[1].plnskip -= i;
d586 2
a587 2
	    /*dbytes = 2 + ( (fstop - fstrt)>>2 );*/
	    /*if (modes & HIRES)   dbytes <<= 1;*/
d589 1
a589 1
	    dbytes = get_dbytes(vp,fstrt,fstop);
d591 1
a591 1
	    /* set up bit plane modulos */
d593 4
a596 4
	    bplmod[0] = info[0].rbytes - dbytes;
	    if (view->Modes & modes & INTERLACE)    bplmod[0] += info[0].rbytes;
	    bplmod[1] = info[1].rbytes - dbytes;
	    if (view->Modes & modes & INTERLACE)    bplmod[1] += info[1].rbytes;
d598 1
a598 1
	    scrollword = ((info[1].scroll<<4)|info[0].scroll);
d600 1
a600 1
	    /* poke new values for fstrt, fstop, and scroll into display list */
d602 2
a603 2
	    /* minimize update clashes */
	    WaitBOVP(vp);
d606 2
a607 2
	    printf("poke new hardware long frame value for fstrt\n");
	    Debug();
d610 1
a610 1
	    pokeCprList(lfstart,&custom.ddfstrt,fstrt);
d613 2
a614 2
	    printf("poke new hardware long frame value for bpl1mod\n");
	    Debug();
d617 1
a617 1
	    pokebothCprList(&pbcprlist,&custom.bpl1mod,bplmod[0]);
d619 2
a620 2
	    if (depth > 1)
	    {
d623 2
a624 2
		printf("poke new hardware long frame modulo for multiple bitplanes\n");
		Debug();
d627 1
a627 1
		pokebothCprList(&pbcprlist,&custom.bpl2mod,bplmod[1]);
d629 1
a629 1
	    }
d632 2
a633 2
	    printf("poke new hardware long frame value for fstop\n");
	    Debug();
d636 1
a636 1
	    pokebothCprList(&pbcprlist,&custom.ddfstop,fstop);
d639 2
a640 2
	    printf("poke new hardware long frame value for scroll\n");
	    Debug();
d642 2
a643 2
	    /* pfa is [0] pfb is [1] */
	    pokebothCprList(&pbcprlist,&custom.bplcon1,scrollword);
d645 4
a648 9
	    /* now send out bit plane pointers */
	    pptr1 = r1->BitMap->Planes;
	    pptr2 = r2->BitMap->Planes;
	    for (i=0;i<depth;i++)
	    {
		if (i & 1)  p = *pptr2++ + info[1].plnskip;
		else        p = *pptr1++ + info[0].plnskip;

		if (modes & INTERLACE)
d650 2
a651 1
		    int tp;
d653 3
a655 1
		    tp = (int)p + (int)info[i&1].rbytes;
d657 2
d660 2
a661 2
		    printf("poke hardware short frame bit plane[%lx] pointer in interlace mode\n",i);
		    Debug();
d663 1
a663 1
		    npokeCprList(sfstart,&custom.bplpt[i],&tp,2);
d665 3
a667 3
		}
		else
		{
d670 2
a671 2
		    printf("poke hardware long frame bit plane[%lx] pointer in non-interlace mode\n",i);
		    Debug();
d673 1
a673 1
		    npokeCprList(lfstart,&custom.bplpt[i],&p,2);
d675 2
a676 2
		    if(view->Modes&INTERLACE)
		    {
d679 2
a680 2
			printf("poke hardware short frame bit plane[%lx] pointer in view->Modes interlace mode\n",i);
			Debug();
d682 1
a682 1
			npokeCprList(sfstart,&custom.bplpt[i],&p,2);
d684 2
d688 2
a689 4
		}

		if (view->Modes&INTERLACE&modes)
		{
d691 2
a692 2
		    printf("poke hardware long frame bit plane[%lx] pointer in interlace mode\n",i);
		    Debug();
d694 1
a694 1
		    npokeCprList(lfstart,&custom.bplpt[i],&p,2);
d696 2
a699 1
	    }
d701 3
a704 4
	if (c)
	{
	    /* poke new values for fstrt, fstop, and scroll into intermediate copper list */

d706 1
a706 1
	    printf("poke new intermediate copper list value for fstrt\n");
d709 1
a709 1
	    pokeCopIns(c,COPPER_MOVE,&custom.ddfstrt,fstrt);
d713 1
a713 1
	    printf("poke new value for fstop\n");
d716 1
a716 1
	    pokeCopIns(c,COPPER_MOVE,&custom.ddfstop,fstop);
d720 1
a720 1
	    printf("poke new value for scroll\n");
d722 2
a723 2
	    /* pfa is [0] pfb is [1] */
	    pokeCopIns(c,COPPER_MOVE,&custom.bplcon1,scrollword);
d727 1
a727 1
	    printf("poke new intermediate copper list modulo for first bitplane\n");
d729 1
a729 1
	    pokeCopIns(c,COPPER_MOVE,&custom.bpl1mod,bplmod[0]);
d732 2
a733 2
	    if (depth > 1)
	    {
d736 1
a736 1
		printf("poke new intermediate copper list modulo for multiple bitplanes\n");
d738 1
a738 1
		pokeCopIns(c,COPPER_MOVE,&custom.bpl2mod,bplmod[1]);
d740 1
a740 1
	    }
d743 7
a749 7
	/* now send out bit plane pointers */
	pptr1 = r1->BitMap->Planes;
	pptr2 = r2->BitMap->Planes;
	for (i=0;i<depth;i++)
	{
	    if (i & 1)  p = *pptr2++ + info[1].plnskip;
	    else        p = *pptr1++ + info[0].plnskip;
d751 2
a752 2
	    if (modes & INTERLACE)
	    {
d754 1
a754 1
		printf("poke intermediate copper list short frame bit plane[%lx] pointer in interlace mode\n",i);
d756 2
a757 2
		pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,&custom.bplpt[i],(TOBB((long)p)+TOBB(info[i&1].rbytes))>>16);
		pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,(short)(&custom.bplpt[i])+2,(TOBB((long)p)+TOBB(info[i&1].rbytes)));
d759 3
a761 3
	    }
	    else
	    {
d763 1
a763 1
		printf("poke intermediate copper list bit plane[%lx] pointer in non-interlace mode\n",i);
d765 2
a766 2
		pokeCopIns(c,COPPER_MOVE,&custom.bplpt[i],TOBB((long)p>>16));
		pokeCopIns(c,COPPER_MOVE,(short)(&custom.bplpt[i])+2,TOBB((long)p));
d768 1
a768 1
	    }
d770 2
a771 2
	    if (view->Modes&INTERLACE&modes)
	    {
d774 1
a774 1
		printf("poke intermediate copper list long frame bit plane[%lx] pointer in interlace mode\n",i);
d776 2
a777 2
		pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,&custom.bplpt[i],TOBB((long)p>>16));
		pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,(short)(&custom.bplpt[i])+2,TOBB((long)p));
d779 2
a781 1
	}
@


36.16
log
@displayinfo_internal
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.15 89/02/14 10:13:16 bart Exp $
@


36.15
log
@checkpoint 02.14.89
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.14 89/02/01 17:52:58 bart Exp $
d24 1
a24 2
#include <display/record.h>
#include <display/defines.h>
@


36.14
log
@checkpoint -- a2024 10hz and 15hz scan works from 32 bit id
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.13 89/01/31 15:39:10 bart Exp $
@


36.13
log
@checkpoint 2024
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.12 89/01/24 15:38:26 bart Exp $
@


36.12
log
@checkpoint 01.24.89
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.11 89/01/19 17:28:35 bart Exp $
@


36.11
log
@checkpoint 01.19.89 coercion down to default
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.10 89/01/18 13:54:48 bart Exp $
@


36.10
log
@checkpoint 01.18.89
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.9 89/01/13 12:40:38 bart Exp $
@


36.9
log
@simultaneous hires/super bits set
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.8 88/10/17 15:07:13 bart Exp $
d22 6
d299 1
a299 1
	UWORD modes = (vp->Modes & SUPERHIRES) ? vp->Modes & ~HIRES : vp->Modes;
d301 1
a301 1
	if (modes & VP_HIDE) return; /* bart - 08.13.85 */
@


36.8
log
@default monitorspec guaranteed to exist ... optimise
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.7 88/07/25 14:45:22 bart Exp $
d293 1
d295 1
a295 1
	if (vp->Modes & VP_HIDE) return; /* bart - 08.13.85 */
d323 1
a323 1
	yclip = HFIX(MIN((VFIX(view->DyOffset+(vp->Modes&LACE?(vp->DyOffset>>1):vp->DyOffset))-min_ytop),0));
d338 1
a338 1
    if (vp->Modes & DUALPF) r2 = r1->Next;  /* get second playfield */
d347 1
a347 1
	pbcprlist.flags = vp->Modes | view->Modes;
d375 1
a375 1
	if (vp->Modes & HIRES)   dbytes <<= 1;
d382 1
a382 1
	if (view->Modes & vp->Modes & INTERLACE)
d441 1
a441 1
	    if (vp->Modes & INTERLACE)
d474 1
a474 1
	    if (view->Modes&INTERLACE&vp->Modes)
d523 1
a523 1
	    		if (vp->Modes & INTERLACE)
d544 1
a544 1
		    	if (view->Modes&INTERLACE&vp->Modes)
d577 1
a577 1
	    if (vp->Modes & HIRES)  i = 4;
d584 1
a584 1
	    /*if (vp->Modes & HIRES)   dbytes <<= 1;*/
d591 1
a591 1
	    if (view->Modes & vp->Modes & INTERLACE)    bplmod[0] += info[0].rbytes;
d593 1
a593 1
	    if (view->Modes & vp->Modes & INTERLACE)    bplmod[1] += info[1].rbytes;
d650 1
a650 1
		if (vp->Modes & INTERLACE)
d685 1
a685 1
		if (view->Modes&INTERLACE&vp->Modes)
d748 1
a748 1
	    if (vp->Modes & INTERLACE)
d767 1
a767 1
	    if (view->Modes&INTERLACE&vp->Modes)
@


36.7
log
@default_monitorspec
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.6 88/07/23 17:09:30 bart Exp $
d272 2
a273 2
#define HFIX(x) (mspc?(((x)*mspc->ratioh)>>4):x)
#define VFIX(y) (mspc?(((y)*mspc->ratiov)>>4):y)
d318 1
a318 5
	if(mspc)
	{
	    min_ytop = mspc->min_row;
	}

@


36.6
log
@monitorspec -- bart 07.23.88 merge source
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.5 88/06/24 12:19:12 bart Exp $
d307 1
d309 1
a309 4
		if(mspc = ve->Monitor)
		{
		    min_ytop = mspc->min_row;
		}
d312 11
@


36.5
log
@interlace scroll bitplane offsets corrected.
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.4 88/06/24 10:15:44 bart Exp $
d272 2
a273 2
#define HFIX(x) (ve?(((x)*ve->ratioh)>>4):x)
#define VFIX(y) (ve?(((y)*ve->ratiov)>>4):y)
d290 2
d304 10
a313 1
	if (view->Modes & EXTEND_VSTRUCT) ve = gfxlookup(view);
d317 1
a317 1
	yclip = HFIX(MIN((VFIX(view->DyOffset+(vp->Modes&LACE?(vp->DyOffset>>1):vp->DyOffset))-MIN_YTOP),0));
@


36.4
log
@HFIX,VFIX
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.3 88/06/24 10:08:13 bart Exp $
d426 1
d428 1
d433 1
a433 1
		npokeCprList(sfstart,&custom.bplpt[i],&p,2);
a458 1
			int tp;
d463 1
a463 2
			tp = (int)p + (int)info[0].rbytes;
		npokeCprList(lfstart,&custom.bplpt[i],&tp,2);
d512 2
a513 2
				pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,&custom.bplpt[i],TOBB((long)p>>16));
				pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,(short)(&custom.bplpt[i])+2,TOBB((long)p));
d533 2
a534 2
				pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,&custom.bplpt[i],(TOBB((long)p)+TOBB(info[0].rbytes))>>16);
				pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,(short)(&custom.bplpt[i])+2,(TOBB((long)p)+TOBB(info[0].rbytes)));
d560 2
a561 2
	    if (fstrt < info[0].dafstrt) info[0].plnskip -= 2;
	    if (fstrt < info[1].dafstrt) info[1].plnskip -= 2;
d563 3
a567 1
	dbytes = get_dbytes(vp,fstrt,fstop);
d569 2
d635 1
d637 2
d643 1
a643 1
		    npokeCprList(sfstart,&custom.bplpt[i],&p,2);
a669 1
			int tp;
d674 1
a674 2
			tp = (int)p + (int)info[i&1].rbytes;
		    npokeCprList(lfstart,&custom.bplpt[i],&tp,2);
d736 2
a737 2
		pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,&custom.bplpt[i],TOBB((long)p>>16));
		pokeCopIns(c,COPPER_MOVE|CPR_NT_LOF,(short)(&custom.bplpt[i])+2,TOBB((long)p));
d756 2
a757 2
		pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,&custom.bplpt[i],(TOBB((long)p)+TOBB(info[i&1].rbytes))>>16);
		pokeCopIns(c,COPPER_MOVE|CPR_NT_SHT,(short)(&custom.bplpt[i])+2,(TOBB((long)p)+TOBB(info[i&1].rbytes)));
@


36.3
log
@yclip
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.2 88/06/10 12:09:24 bart Exp $
d271 3
@


36.2
log
@clipstuff
@
text
@d3 1
a3 1
*	$Header: scrollvp.c,v 36.1 88/03/10 16:12:11 dale Exp $
d270 2
d286 2
d299 6
d338 1
a338 1
	getclipstuff(view,vp,r1,&info[0],0);
d549 1
a549 1
	getclipstuff(view,vp,r2,&info[1],0);
@


36.1
log
@
@
text
@d3 1
a3 1
*	$Header: $
d326 4
d331 1
d333 1
d535 1
d537 4
d542 1
@
