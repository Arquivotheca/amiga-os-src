head     39.12;
branch   ;
access   ;
symbols  rel39_24:39.12 rel39_18:39.12 rel39_97:39.11 rel39_90:39.11 rel39_89:39.11 rel39_82:39.11 rel39_76:39.9 rel39_71:39.9 rel39_65:39.9 rel39_64:39.7 rel39_61:39.7 rel39_60:39.7 rel39_55:39.5 rel39_47:39.4 rel39_39:39.4 rel39_38:39.4 rel39_37:39.3 rel39_35:39.3 rel39_34:39.3 V37_30:37.0 V37_29:37.0 V37_28:37.0 V37_27:37.0 V37_25:37.0 V37_24:37.0 V37_23:37.0 V37_22:37.0 V37_21:37.0 V37_20:37.0 V37_19:37.0 V37_17:37.0 V37_15:37.0 V37_14:37.0 V37_13:37.0 V37_12:37.0 V37_11:37.0 V37_10:37.0 V37_9:37.0 V37_8:37.0 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.35 V36_208:36.35 V36_207:36.35 V36_205:36.35 V36_203:36.35 V36_202:36.35 V36_201:36.35 V36_200:36.35 V36_199:36.35 V36_198:36.35 V36_196:36.35 V36_195:36.35 V36_194:36.35 V36_193:36.35 V36_192:36.35 V36_191:36.35 V36_190:36.35 V36_189:36.35 V36_188:36.35 V36_186:36.35 V36_185:36.35 V36_184:36.35 V36_182:36.35 V36_181:36.35;
locks    ; strict;
comment  @*   @;


39.12
date     93.02.10.19.41.37;  author spence;  state Exp;
branches ;
next     39.11;

39.11
date     92.08.08.11.12.18;  author spence;  state Exp;
branches ;
next     39.10;

39.10
date     92.08.06.11.32.45;  author spence;  state Exp;
branches ;
next     39.9;

39.9
date     92.06.09.10.56.36;  author chrisg;  state Exp;
branches ;
next     39.8;

39.8
date     92.06.08.14.05.17;  author spence;  state Exp;
branches ;
next     39.7;

39.7
date     92.05.13.11.50.20;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     92.05.13.11.30.21;  author spence;  state Exp;
branches ;
next     39.5;

39.5
date     92.04.10.12.15.44;  author spence;  state Exp;
branches ;
next     39.4;

39.4
date     92.03.03.10.36.52;  author spence;  state Exp;
branches ;
next     39.3;

39.3
date     92.01.21.13.28.36;  author chrisg;  state Exp;
branches ;
next     39.2;

39.2
date     92.01.07.15.56.00;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     92.01.07.13.45.16;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.20.41;  author chrisg;  state Exp;
branches ;
next     37.3;

37.3
date     91.05.20.11.18.03;  author chrisg;  state Exp;
branches ;
next     37.2;

37.2
date     91.05.14.12.42.00;  author spence;  state Exp;
branches ;
next     37.1;

37.1
date     91.05.02.13.04.48;  author chrisg;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.20.16;  author spence;  state Exp;
branches ;
next     36.35;

36.35
date     90.07.27.16.59.03;  author bart;  state Exp;
branches ;
next     36.34;

36.34
date     90.03.28.09.13.22;  author bart;  state Exp;
branches ;
next     36.33;

36.33
date     89.06.29.10.12.38;  author bart;  state Exp;
branches ;
next     36.32;

36.32
date     89.04.13.13.20.50;  author bart;  state Exp;
branches ;
next     36.31;

36.31
date     89.04.12.13.16.30;  author bart;  state Exp;
branches ;
next     36.30;

36.30
date     89.02.23.13.16.22;  author bart;  state Exp;
branches ;
next     36.29;

36.29
date     89.02.17.22.04.07;  author bart;  state Exp;
branches ;
next     36.28;

36.28
date     89.02.16.10.08.20;  author bart;  state Exp;
branches ;
next     36.27;

36.27
date     89.02.15.16.06.53;  author bart;  state Exp;
branches ;
next     36.26;

36.26
date     89.02.15.13.06.51;  author bart;  state Exp;
branches ;
next     36.25;

36.25
date     89.02.14.18.22.49;  author bart;  state Exp;
branches ;
next     36.24;

36.24
date     89.02.14.10.13.11;  author bart;  state Exp;
branches ;
next     36.23;

36.23
date     89.02.13.18.05.38;  author bart;  state Exp;
branches ;
next     36.22;

36.22
date     89.02.11.12.19.46;  author bart;  state Exp;
branches ;
next     36.21;

36.21
date     89.02.01.17.52.50;  author bart;  state Exp;
branches ;
next     36.20;

36.20
date     89.01.31.15.39.05;  author bart;  state Exp;
branches ;
next     36.19;

36.19
date     89.01.25.14.43.12;  author bart;  state Exp;
branches ;
next     36.18;

36.18
date     89.01.25.14.37.05;  author bart;  state Exp;
branches ;
next     36.17;

36.17
date     89.01.24.15.38.21;  author bart;  state Exp;
branches ;
next     36.16;

36.16
date     89.01.24.14.50.39;  author bart;  state Exp;
branches ;
next     36.15;

36.15
date     89.01.24.14.47.36;  author bart;  state Exp;
branches ;
next     36.14;

36.14
date     89.01.19.17.28.29;  author bart;  state Exp;
branches ;
next     36.13;

36.13
date     89.01.18.13.54.42;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     89.01.12.16.14.37;  author bart;  state Exp;
branches ;
next     36.11;

36.11
date     88.11.01.15.47.18;  author bart;  state Exp;
branches ;
next     36.10;

36.10
date     88.10.21.19.27.10;  author bart;  state Exp;
branches ;
next     36.9;

36.9
date     88.10.21.12.01.52;  author bart;  state Exp;
branches ;
next     36.8;

36.8
date     88.09.14.11.21.04;  author bart;  state Exp;
branches ;
next     36.7;

36.7
date     88.08.12.13.18.15;  author bart;  state Exp;
branches ;
next     36.6;

36.6
date     88.08.07.16.50.53;  author bart;  state Exp;
branches ;
next     36.5;

36.5
date     88.09.01.09.56.13;  author bart;  state Exp;
branches ;
next     36.4;

36.4
date     88.08.25.13.35.24;  author bart;  state Exp;
branches ;
next     36.3;

36.3
date     88.07.26.18.19.03;  author bart;  state Exp;
branches ;
next     36.2;

36.2
date     88.07.26.16.16.28;  author bart;  state Exp;
branches ;
next     36.1;

36.1
date     88.07.23.17.09.11;  author bart;  state Exp;
branches ;
next     36.0;

36.0
date     88.07.23.14.07.35;  author bart;  state Exp;
branches ;
next     ;


desc
@@


39.12
log
@Use MonitorListSemaphore to *safely* change the default monitor setting.
,
@
text
@/******************************************************************************
*
*	$Id: monitor.c,v 39.11 92/08/08 11:12:18 spence Exp Locker: spence $
*
******************************************************************************/

#include <exec/types.h>
#include <exec/nodes.h>
#include <exec/memory.h>
#include <exec/execbase.h>

#include "/macros.h"
#include "/gfxnodes.h"
#include "/monitor.h"
#include "/view.h"
#include "/gfxbase.h"
#include "/d/d.protos"
#include "/gfxpragmas.h"
#include "/displayinfo.h"
#include <clib/utility_protos.h>
#include <pragmas/utility_pragmas.h>

#define NULL_MSPC_FUNCTIONS
#define PROTOTYPE_DISPLAY

#ifdef PROTOTYPE_DISPLAY
#include "/displayinfo_internal.h"
#endif
#include "c.protos"

/*#define USEGBDEBUG*/
/*#define DEBUG*/

#ifdef USEGBDEBUG
#define GBDEBUG if (GBASE->Debug)
#else
#define GBDEBUG
#endif

#ifdef DEBUG
#define D(x) {GBDEBUG {x};}
#else
#define D(x)
#endif

#define STREQ(a,b) (!Stricmp((a),(b)))

/* graphics access routines for monitor specification */


struct MonitorSpec * __asm OpenMonitor(register __a1 char *name, register __d0 id)
{
	struct MonitorSpec *mspc= NULL;
	int open_default = ( ((!name) && (!id)) ||
			     (( name) && (STREQ(name,DEFAULT_MONITOR_NAME))) );

	ObtainSemaphore(GBASE->MonitorListSemaphore);

	if(open_default)
	{
	    mspc = GBASE->default_monitor;
	    D(kprintf("open_monitor: default == 0x%08lx\n", mspc );)
	}
	else
	{
	    if(name)
	    {
		D(kprintf("open_monitor: findname == \"%s\"\n", name );)
		mspc = (struct MonitorSpec *)FindName(&GBASE->MonitorList,name);
	    }
	    else
	    {
		struct RawMonitorInfo querymonitor;
		struct RawMonitorInfo *chunk = &querymonitor;

		if( ((ULONG)(gfx_GetDisplayInfoData(NULL,chunk,sizeof(*chunk),DTAG_MNTR,id)))
		>= ((ULONG)(&((struct RawMonitorInfo *)0)->Mspc)+sizeof(ULONG)))
		{
		    mspc = chunk->Mspc;
		}
	    }
	}

	if(mspc)
	{
	    mspc->ms_OpenCount += 1;
	}

	D(kprintf("open_monitor: mspc   == 0x%08lx\n", mspc  );)

	ReleaseSemaphore(GBASE->MonitorListSemaphore);


	return( mspc );
}


int __asm CloseMonitor(register __a0 struct MonitorSpec *mspc)
{
	int error = FALSE;

	ObtainSemaphore(GBASE->MonitorListSemaphore);

	if (mspc)
	{
	    mspc->ms_OpenCount -= 1;
	}
	else
	{
	    error = TRUE;
	}

	ReleaseSemaphore(GBASE->MonitorListSemaphore);
	
	return( error ); 
}

/* transformation routines for monitor specification */

#ifdef NULL_MSPC_FUNCTIONS

void transform_monitorspec(mspc,src,type,dst)
struct MonitorSpec *mspc;
UWORD type;
Point *src,*dst;
{
    nop_monitorspec(mspc,src,type,dst);
}

void translate_monitorspec(mspc,src,type,dst)
struct MonitorSpec *mspc;
UWORD type;
Point *src,*dst;
{
    nop_monitorspec(mspc,src,type,dst);
}

void nop_monitorspec(mspc,src,type,dst)
struct MonitorSpec *mspc;
UWORD type;
Point *src,*dst;
{
    dst->x = src->x;
    dst->y = src->y;
}

#else

void transform_monitorspec(mspc,src,type,dst)
struct MonitorSpec *mspc;
UWORD type;
Point *src,*dst;
{

    D(kprintf("-------------------------------\n");)
    D(kprintf("transform: mspc == %08lx\n",mspc); )
    D(kprintf("transform: src == %08lx \(%04lx,%04lx\)\n",src,src->x,src->y);)
    D(kprintf("transform: type == %04lx\n",type);)

    translate_monitorspec(mspc,src,TO_MONITOR,dst);
    scale_monitorspec(mspc,dst,type,dst);
    translate_monitorspec(mspc,dst,FROM_MONITOR,dst);

    D(kprintf("transform: dst == %08lx \(%04lx,%04lx\)\n",dst,dst->x,dst->y);)
    D(kprintf("-------------------------------\n");)
}

void translate_monitorspec(mspc,src,type,dst)
struct MonitorSpec *mspc;
UWORD type;
Point *src,*dst;
{
    Point tmp;

    tmp.x = src->x;
    tmp.y = src->y;
	
    if(mspc)
    {
	switch(type)
        {
	    case(TO_MONITOR):
	    {
		tmp.x = src->x - mspc->ms_xoffset;
		tmp.y = src->y - mspc->ms_yoffset;
	    }break;
	    case(FROM_MONITOR):
	    {
		tmp.x = src->x + mspc->ms_xoffset;
		tmp.y = src->y + mspc->ms_yoffset;
	    }break;
	    default: break;
        }
    }

    dst->x = tmp.x;
    dst->y = tmp.y;
}

#endif

void scale_monitorspec(mspc,src,type,dst)
struct MonitorSpec *mspc;
UWORD type;
Point *src,*dst;
{
    Point tmp;

    tmp.x = src->x;
    tmp.y = src->y;
	
    if(mspc)
    {
	switch(type)
        {
	    case(TO_MONITOR):
	    {
		tmp.x = ((src->x * mspc->ratioh) + (RATIO_UNITY >> 1))
			>> RATIO_FIXEDPART;
		tmp.y = ((src->y * mspc->ratiov) + (RATIO_UNITY >> 1))
			>> RATIO_FIXEDPART;
	    }break;
	    case(FROM_MONITOR):
	    {
		tmp.x = ((src->x * mspc->ratiov) + (RATIO_UNITY >> 1))
			>> RATIO_FIXEDPART;
		tmp.y = ((src->y * mspc->ratioh) + (RATIO_UNITY >> 1))
			>> RATIO_FIXEDPART;
	    }break;
	    default: break;
        }
    }

    dst->x = tmp.x;
    dst->y = tmp.y;
}

/* initalisation routine for default monitor specification */
/* assumes monitorspec cleared on entry */

#ifdef  PROTOTYPE_DISPLAY

UWORD init_monitorspec(mspc,type)
struct MonitorSpec *mspc;
UWORD type;
{
    /* set the flags passed in */
    mspc->ms_Flags = type;
    /* but clear existing flags until they are explicitly set */
    mspc->ms_Flags &= ~(MSF_REQUEST_PAL|MSF_REQUEST_NTSC|MSF_REQUEST_SPECIAL|MSF_REQUEST_A2024);

    /* reset use count */
    mspc->ms_OpenCount = -1;

    /* default values */
    mspc->ratioh = RATIO_UNITY;
    mspc->ratiov = RATIO_UNITY;
    mspc->total_rows = STANDARD_NTSC_ROWS;
    mspc->total_colorclocks = STANDARD_COLORCLOCKS;
    mspc->DeniseMaxDisplayColumn = STANDARD_DENISE_MAX;
    mspc->DeniseMinDisplayColumn = STANDARD_DENISE_MIN;
    mspc->BeamCon0 = STANDARD_NTSC_BEAMCON;
    mspc->min_row = MIN_NTSC_ROW;

    /* standard view position */
    mspc->ms_LegalView.MinX = STANDARD_VIEW_X;
    mspc->ms_LegalView.MinY = STANDARD_VIEW_Y;
    mspc->ms_LegalView.MaxX = STANDARD_VIEW_X;
    mspc->ms_LegalView.MaxY = STANDARD_VIEW_Y;

    /* allow default special_ntsc, special_pal requests */
    {
	if(type & MSF_REQUEST_SPECIAL) 
	{
	    struct SpecialMonitor *smp;

	    if(   smp = mspc->ms_Special? 
		  mspc->ms_Special:
	          (struct SpecialMonitor *) gfx_GfxNew(SPECIAL_MONITOR_TYPE) )
	    {

		/* special_broadcast defaults */

		smp->hblank.asi_Start = STANDARD_HBSTRT;
		smp->hblank.asi_Stop = STANDARD_HBSTOP;

		smp->hsync.asi_Start = STANDARD_HSSTRT;
		smp->hsync.asi_Stop = STANDARD_HSSTOP;

		smp->vblank.asi_Start = STANDARD_VBSTRT;
		smp->vblank.asi_Stop = STANDARD_VBSTOP;

		smp->vsync.asi_Start = STANDARD_VSSTRT;
		smp->vsync.asi_Stop = STANDARD_VSSTOP;

		smp->do_monitor = default_monitor;

		mspc->ms_Special = smp;
		mspc->ms_Flags |= MSF_REQUEST_SPECIAL;
		mspc->BeamCon0 |= SPECIAL_BEAMCON;

#ifdef DEBUG
		if(mspc->ms_Node.xln_Library) /* debugging */
		{
		    struct GfxBase *GB = mspc->ms_Node.xln_Library;
		    if(GB->Debug & 0x07)
		    {
			smp->hblank.asi_Start = BROADCAST_HBSTRT;
			smp->hblank.asi_Stop = BROADCAST_HBSTOP;

			smp->hsync.asi_Start = BROADCAST_HSSTRT;
			smp->hsync.asi_Stop = BROADCAST_HSSTOP;

			smp->vblank.asi_Start = BROADCAST_VBSTRT;
			smp->vblank.asi_Stop = BROADCAST_VBSTOP;

			smp->vsync.asi_Start = BROADCAST_VSSTRT;
			smp->vsync.asi_Stop = BROADCAST_VSSTOP;
			mspc->BeamCon0 &= ~SPECIAL_BEAMCON;
			mspc->BeamCon0 |= BROADCAST_BEAMCON;
		    }
		}
#endif
	    }
	    else
	    {
		mspc->ms_Flags &= ~MSF_REQUEST_SPECIAL;
	    }
	}
	else
	{
	    if(mspc->ms_Special)
	    {
	          gfx_GfxFree(mspc->ms_Special);
		  mspc->ms_Special = NULL;
	    }
	}

	if(type & MSF_REQUEST_NTSC)
	{
	    mspc->ms_Flags |= MSF_REQUEST_NTSC;
	}
	else /* can't have both pal and ntsc set */
	if(type & MSF_REQUEST_PAL)
	{
	    mspc->BeamCon0 |= 	STANDARD_PAL_BEAMCON;
	    mspc->total_rows = 	STANDARD_PAL_ROWS;
	    mspc->min_row = 	MIN_PAL_ROW;
	    mspc->ms_Flags |= MSF_REQUEST_PAL;
	} 

	if(type & MSF_REQUEST_A2024)
	{
	    mspc->ms_Flags |= MSF_REQUEST_A2024;
	}
    }

    NewList(&mspc->DisplayInfoDataBase);
    InitSemaphore(&mspc->DisplayInfoDataBaseSemaphore);

    return(mspc->ms_Flags);
}

#else

UWORD init_monitorspec(mspc,type)
struct MonitorSpec *mspc;
UWORD type;
{
    /* clear existing flags */
    mspc->ms_Flags &= ~(MSF_REQUEST_PAL|MSF_REQUEST_NTSC|MSF_REQUEST_SPECIAL);

    /* reset use count */
    mspc->ms_OpenCount = -1;

    /* default values */
    mspc->ratioh = RATIO_UNITY;
    mspc->ratiov = RATIO_UNITY;
    mspc->total_rows = STANDARD_NTSC_ROWS;
    mspc->total_colorclocks = STANDARD_COLORCLOCKS;
    mspc->DeniseMaxDisplayColumn = STANDARD_DENISE_MAX;
    mspc->DeniseMinDisplayColumn = STANDARD_DENISE_MIN;
    mspc->BeamCon0 = STANDARD_NTSC_BEAMCON;
    mspc->min_row = MIN_NTSC_ROW;

    /* standard view position */
    mspc->ms_LegalView.MinX = STANDARD_VIEW_X;
    mspc->ms_LegalView.MinY = STANDARD_VIEW_Y;
    mspc->ms_LegalView.MaxX = STANDARD_VIEW_X;
    mspc->ms_LegalView.MaxY = STANDARD_VIEW_Y;

    /* allow default special_ntsc, special_pal requests */
    {
	if(type & MSF_REQUEST_SPECIAL) 
	{
	    struct SpecialMonitor *smp;

	    if(   smp = mspc->ms_Special? 
		  mspc->ms_Special:
	          (struct SpecialMonitor *) gfx_GfxNew(SPECIAL_MONITOR_TYPE) )
	    {

		/* special_broadcast defaults */

		smp->hblank.asi_Start = STANDARD_HBSTRT;
		smp->hblank.asi_Stop = STANDARD_HBSTOP;

		smp->hsync.asi_Start = STANDARD_HSSTRT;
		smp->hsync.asi_Stop = STANDARD_HSSTOP;

		smp->vblank.asi_Start = STANDARD_VBSTRT;
		smp->vblank.asi_Stop = STANDARD_VBSTOP;

		smp->vsync.asi_Start = STANDARD_VSSTRT;
		smp->vsync.asi_Stop = STANDARD_VSSTOP;

		smp->do_monitor = (int (*()))default_monitor;

		mspc->ms_Special = smp;
		mspc->ms_Flags |= MSF_REQUEST_SPECIAL;
		mspc->BeamCon0 |= SPECIAL_BEAMCON;

#ifdef DEBUG
		if(mspc->ms_Node.xln_Library) /* debugging */
		{
		    struct GfxBase *GB = mspc->ms_Node.xln_Library;
		    if(GB->Debug & 0x07)
		    {
			smp->hblank.asi_Start = BROADCAST_HBSTRT;
			smp->hblank.asi_Stop = BROADCAST_HBSTOP;

			smp->hsync.asi_Start = BROADCAST_HSSTRT;
			smp->hsync.asi_Stop = BROADCAST_HSSTOP;

			smp->vblank.asi_Start = BROADCAST_VBSTRT;
			smp->vblank.asi_Stop = BROADCAST_VBSTOP;

			smp->vsync.asi_Start = BROADCAST_VSSTRT;
			smp->vsync.asi_Stop = BROADCAST_VSSTOP;
			mspc->BeamCon0 &= ~SPECIAL_BEAMCON;
			mspc->BeamCon0 |= BROADCAST_BEAMCON;
		    }
		}
#endif
	    }
	    else
	    {
		mspc->ms_Flags &= ~MSF_REQUEST_SPECIAL;
	    }
	}
	else
	{
	    if(mspc->ms_Special)
	    {
	          gfx_GfxFree(mspc->ms_Special);
		  mspc->ms_Special = NULL;
	    }
	}

	if(type & MSF_REQUEST_NTSC)
	{
	    mspc->ms_Flags |= MSF_REQUEST_NTSC;
	}
	else /* can't have both pal and ntsc set */
	if(type & MSF_REQUEST_PAL)
	{
	    mspc->BeamCon0 |= 	STANDARD_PAL_BEAMCON;
	    mspc->total_rows = 	STANDARD_PAL_ROWS;
	    mspc->min_row = 	MIN_PAL_ROW;
	    mspc->ms_Flags |= MSF_REQUEST_PAL;
	} 
    }

    NewList(&mspc->DisplayInfoDataBase);
    InitSemaphore(&mspc->DisplayInfoDataBaseSemaphore);

    return(mspc->ms_Flags);
}

#endif

/**i*** graphics.library/SetDefaultMonitor***********************************
*
*   NAME
*	SetDefaultMonitor -- to PAL or NTSC or the ScanDbl equivalent (V39)
*
*   SYNOPSIS
*	result = SetDefaultMonitor(MonitorNumber);
*	d0                         d0
*
*	BOOL SetDefaultMonitor(UWORD);
*
*   FUNCTION
*	To set the default monitor to be either PAL, NTSC, DOUBLEPAL or
*	DOUBLENTSC.
*
*   INPUT
*	MonitorNumber - (xxx_MONITOR_ID >> 16)
*
*   RESULT
*	result - TRUE if OK, else FALSE.
*
*   SEE ALSO
*	<graphics/modeid.h>
*
******************************************************************************/

BOOL __asm SetDefaultMonitor(register __d0 UWORD mon)
{
	struct MonitorSpec *mspc = NULL;
	struct MonitorSpec *oldmspc = NULL;
	BOOL waspal = (GBASE->DisplayFlags & PAL);
	BOOL ispal = FALSE;
	BOOL isdbl = FALSE;
	BOOL result = FALSE;
	BOOL change = FALSE;

	D(kprintf("SDM() mon = 0x%lx\n", mon);)

	ObtainSemaphore(GBASE->MonitorListSemaphore);

	/* For DBLNTSC and DBLPAL, the monitors must have already been added
	 * in the normal startup-sequence.
	 */
	switch (mon)
	{
		case (DBLNTSC_MONITOR_ID >> 16) :
		{
			isdbl = TRUE;
			mspc = gfx_OpenMonitor(NULL, DBLNTSCLORES_KEY);
		}
		break;
		case (DBLPAL_MONITOR_ID >> 16) :
		{
			isdbl = TRUE;
			ispal = TRUE;
			mspc = gfx_OpenMonitor(NULL, DBLPALLORES_KEY);
		}
		break;
		case (NTSC_MONITOR_ID >> 16) :
		{
			if ((oldmspc = mspc = gfx_OpenMonitor(NULL, (NTSC_MONITOR_ID | LORES_KEY))) == NULL)
			{
				D(kprintf("Could not open NTSC monitor\n");)
				mspc = new_monitorspec(GBASE, MSF_REQUEST_NTSC, NTSC_MONITOR_NAME);
			}
			GBASE->natural_monitor = mspc;
		}
		break;
		case (PAL_MONITOR_ID >> 16) :
		{
			if ((oldmspc = mspc = gfx_OpenMonitor(NULL, (PAL_MONITOR_ID | LORES_KEY))) == NULL)
			{
				D(kprintf("Could not open PAL monitor\n");)
				mspc = new_monitorspec(GBASE, MSF_REQUEST_PAL, PAL_MONITOR_NAME);
			}
			ispal = TRUE;
			GBASE->natural_monitor = mspc;
		}
		default : break;
	}

	if ((mspc) && (!(isdbl && (GBASE->system_bplcon0 & GENLOCK_VIDEO))))
	{
		int unity_scale();

		D(kprintf("have mspec = 0x%lx\n", mspc);)
		mspc->ms_scale = unity_scale; 	/* force unity */

		GBASE->default_monitor = mspc;

		/* Now set up the GBASE variables. */
		if (ispal)
		{
			GBASE->DisplayFlags &= ~NTSC;
			GBASE->DisplayFlags |= PAL;
//			GBASE->MaxDisplayRow = (STANDARD_PAL_ROWS - 1);
			GBASE->NormalDisplayRows = 256;
			GBASE->monitor_id = mon;
//			if (!(isdbl))
			{
				GBASE->NormalDPMX = 1226;	/* 320 X 1000/261mm */
				GBASE->NormalDPMY = 1299;	/* 200 X 1000/197mm */
			}
			((struct ExecBase *)SysBase)->VBlankFrequency = 50;
			if ((!waspal) || (isdbl))
			{
				change = TRUE;
			}
		}
		else
		{
			GBASE->DisplayFlags &= ~PAL;
			GBASE->DisplayFlags |= NTSC;
//			GBASE->MaxDisplayRow = (STANDARD_NTSC_ROWS - 1);
			GBASE->NormalDisplayRows = 200;
			GBASE->monitor_id = mon;
//			if (!(isdbl))
			{
				GBASE->NormalDPMX = 1280;	/* 320 X 1000/250mm */
				GBASE->NormalDPMY = 1098;	/* 200 X 1000/182mm */
			}
			((struct ExecBase *)GBASE->ExecBase)->VBlankFrequency = 60;
			if ((waspal) || (isdbl))
			{
				change = TRUE;
			}
		}

		if ((!(isdbl)) && (oldmspc == NULL))
		{
			/* initialize view range bound */
			vlimit(mspc,&mspc->ms_LegalView,NULL);
			AddHead(&GBASE->MonitorList, mspc);
			activate_mspc((ispal ? (PAL_MONITOR_ID) : (NTSC_MONITOR_ID)), mspc);
		}
		result = TRUE;
        }
	if (change)
	{
		if (!(isdbl))
		{
			/* Go through the database, marking the new default as available. */
			struct DisplayInfo disp;
			ULONG ID = INVALID_ID;

			/* Cause the monitor to be unpacked */
			gfx_FindDisplayInfo((mon << 16) | 0x1000);

			while ((ID = gfx_NextDisplayInfo(ID)) != INVALID_ID)
			{
				ULONG monid = (ID & MONITOR_ID_MASK);

				if ( (((monid == NTSC_MONITOR_ID) && (waspal)) ||
				      ((monid == PAL_MONITOR_ID) && (!(waspal)))) &&
				      (gfx_GetDisplayInfoData(NULL, &disp, sizeof(struct DisplayInfo), DTAG_DISP, ID)) )
				{
					disp.NotAvailable &= ~(DI_AVAIL_NOMONITOR);
					gfx_SetDisplayInfoData(NULL, &disp, sizeof(struct DisplayInfo), DTAG_DISP, ID);
				}
			}
		}
		GBASE->monitor_id = mon;
	}

	ReleaseSemaphore(GBASE->MonitorListSemaphore);

	return(result);
}
@


39.11
log
@SetDefaultMonitor() should not change GfxBase->MaxDisplayRows
@
text
@d3 1
a3 1
*	$Id: monitor.c,v 39.10 92/08/06 11:32:45 spence Exp Locker: spence $
d520 2
d645 2
@


39.10
log
@Cannot set DefaultMonitor to DBLPal/NTSC if there is a genlock attached.
Setting the DefaultMonitor back to PAL/NTSC would always cause a new
MonitorSpec to be allocated. Killed this!
@
text
@d3 1
a3 1
*	$Id: monitor.c,v 39.9 92/06/09 10:56:36 chrisg Exp Locker: spence $
d575 1
a575 1
			GBASE->MaxDisplayRow = (STANDARD_PAL_ROWS - 1);
d593 1
a593 1
			GBASE->MaxDisplayRow = (STANDARD_NTSC_ROWS - 1);
@


39.9
log
@REQ -> MSF_REQ.
@
text
@d3 1
a3 1
*	$Id: monitor.c,v 39.8 92/06/08 14:05:17 spence Exp Locker: chrisg $
d31 1
a31 1
#define USEGBDEBUG
d93 1
d511 1
d540 6
a545 1
			mspc = new_monitorspec(GBASE, MSF_REQUEST_NTSC, NTSC_MONITOR_NAME);
d550 5
a554 1
			mspc = new_monitorspec(GBASE, MSF_REQUEST_PAL, PAL_MONITOR_NAME);
d556 1
d561 1
a561 1
	if(mspc)
d608 1
a608 1
		if (!(isdbl))
@


39.8
log
@Sets the ms_Flags with the value passed in.
@
text
@d3 1
a3 1
*	$Id: monitor.c,v 39.7 92/05/13 11:50:20 spence Exp Locker: spence $
d14 1
d249 1
a249 1
    mspc->ms_Flags &= ~(REQUEST_PAL|REQUEST_NTSC|REQUEST_SPECIAL|REQUEST_A2024);
d272 1
a272 1
	if(type & REQUEST_SPECIAL) 
d298 1
a298 1
		mspc->ms_Flags |= REQUEST_SPECIAL;
d326 1
a326 1
		mspc->ms_Flags &= ~REQUEST_SPECIAL;
d338 1
a338 1
	if(type & REQUEST_NTSC)
d340 1
a340 1
	    mspc->ms_Flags |= REQUEST_NTSC;
d343 1
a343 1
	if(type & REQUEST_PAL)
d348 1
a348 1
	    mspc->ms_Flags |= REQUEST_PAL;
d351 1
a351 1
	if(type & REQUEST_A2024)
d353 1
a353 1
	    mspc->ms_Flags |= REQUEST_A2024;
d370 1
a370 1
    mspc->ms_Flags &= ~(REQUEST_PAL|REQUEST_NTSC|REQUEST_SPECIAL);
d393 1
a393 1
	if(type & REQUEST_SPECIAL) 
d419 1
a419 1
		mspc->ms_Flags |= REQUEST_SPECIAL;
d447 1
a447 1
		mspc->ms_Flags &= ~REQUEST_SPECIAL;
d459 1
a459 1
	if(type & REQUEST_NTSC)
d461 1
a461 1
	    mspc->ms_Flags |= REQUEST_NTSC;
d464 1
a464 1
	if(type & REQUEST_PAL)
d469 1
a469 1
	    mspc->ms_Flags |= REQUEST_PAL;
d538 1
a538 1
			mspc = new_monitorspec(GBASE, REQUEST_NTSC, NTSC_MONITOR_NAME);
d543 1
a543 1
			mspc = new_monitorspec(GBASE, REQUEST_PAL, PAL_MONITOR_NAME);
@


39.7
log
@no debug.
@
text
@d3 1
a3 1
*	$Id: monitor.c,v 39.6 92/05/13 11:30:21 spence Exp Locker: spence $
d245 3
a247 1
    /* clear existing flags */
@


39.6
log
@SetDefaultMonitor() knows about DblNTSC and DblPAL.
@
text
@d3 1
a3 1
*	$Id: monitor.c,v 39.5 92/04/10 12:15:44 spence Exp Locker: spence $
d31 1
a31 1
#define DEBUG
@


39.5
log
@Added private SetDefaultMonitor() LVO which initialises a new PAL or
NTSC monitorspec. Also modifies the database as necessary, and GfxBase
for NormalDisplayRows etc.
@
text
@d3 1
a3 1
*	$Id: monitor.c,v 39.4 92/03/03 10:36:52 spence Exp Locker: spence $
d30 2
a31 1
/* #define DEBUG */
d33 12
d61 1
a61 1
	    /* kprintf("open_monitor: default == 0x%08lx\n", mspc ); */
d67 1
a67 1
		/* kprintf("open_monitor: findname == \"%s\"\n", name ); */
d88 1
a88 1
	/* kprintf("open_monitor: mspc   == 0x%08lx\n", mspc  ); */
d153 4
a156 6
#ifdef DEBUG
    kprintf("-------------------------------\n");
    kprintf("transform: mspc == %08lx\n",mspc); 
    kprintf("transform: src == %08lx \(%04lx,%04lx\)\n",src,src->x,src->y); 
    kprintf("transform: type == %04lx\n",type); 
#endif
d162 2
a163 5
#ifdef DEBUG
    kprintf("transform: dst == %08lx \(%04lx,%04lx\)\n",dst,dst->x,dst->y); 
    kprintf("-------------------------------\n");
#endif

d481 1
a481 1
*	SetDefaultMonitor -- to either PAL or NTSC (V39)
d490 2
a491 2
*	To set the default monitor to be either PAL or NTSC (and maybe VGA
*	in the future too).
d499 3
d506 1
a506 1
	struct MonitorSpec *mspc;
d509 1
d513 31
a543 3
	if (mon == (NTSC_MONITOR_ID >> 16))
	{
		mspc = new_monitorspec(GBASE, REQUEST_NTSC, NTSC_MONITOR_NAME);
a544 5
	else
	{
		mspc = new_monitorspec(GBASE, REQUEST_PAL, PAL_MONITOR_NAME);
		ispal = TRUE;
	}
d550 1
d562 6
a567 3
			GBASE->monitor_id = (PAL_MONITOR_ID >> 16);
			GBASE->NormalDPMX = 1226;	/* 320 X 1000/261mm */
			GBASE->NormalDPMY = 1299;	/* 200 X 1000/197mm */
d569 1
a569 1
			if (!waspal)
d580 6
a585 3
			GBASE->monitor_id = (NTSC_MONITOR_ID >> 16);
			GBASE->NormalDPMX = 1280;	/* 320 X 1000/250mm */
			GBASE->NormalDPMY = 1098;	/* 200 X 1000/182mm */
d587 1
a587 1
			if (waspal)
d593 7
a599 6
		/* initialize view range bound */
		vlimit(mspc,&mspc->ms_LegalView,NULL);

		AddHead(&GBASE->MonitorList, mspc);
		activate_mspc((ispal ? (PAL_MONITOR_ID) : (NTSC_MONITOR_ID)), mspc);

d604 5
a608 12
		/* Go through the database, marking the previous default as
		 * NO_MONITOR, and marking the new default as available.
		 */
		struct DisplayInfo disp;
		ULONG ID = INVALID_ID;

		/* Cause the monitor to be unpacked */
		gfx_FindDisplayInfo((mon << 16) | 0x1000);

		while ((ID = gfx_NextDisplayInfo(ID)) != INVALID_ID)
		{
			ULONG monid = (ID & MONITOR_ID_MASK);
d610 4
a613 3
			if ( (((monid == NTSC_MONITOR_ID) && (waspal)) ||
			      ((monid == PAL_MONITOR_ID) && (!(waspal)))) &&
			      (gfx_GetDisplayInfoData(NULL, &disp, sizeof(struct DisplayInfo), DTAG_DISP, ID)) )
d615 9
a623 2
				disp.NotAvailable &= ~(DI_AVAIL_NOMONITOR);
				gfx_SetDisplayInfoData(NULL, &disp, sizeof(struct DisplayInfo), DTAG_DISP, ID);
a625 1

@


39.4
log
@gfx calls through the LVOs
@
text
@d3 1
a3 1
*	$Id: monitor.c,v 39.3 92/01/21 13:28:36 chrisg Exp Locker: spence $
d10 1
d18 1
d83 1
a83 1
__asm CloseMonitor(register __a0 struct MonitorSpec *mspc)
d107 1
a107 1
transform_monitorspec(mspc,src,type,dst)
d115 1
a115 1
translate_monitorspec(mspc,src,type,dst)
d123 1
a123 1
nop_monitorspec(mspc,src,type,dst)
d134 1
a134 1
transform_monitorspec(mspc,src,type,dst)
d158 1
a158 1
translate_monitorspec(mspc,src,type,dst)
d192 1
a192 1
scale_monitorspec(mspc,src,type,dst)
d405 1
a405 1
		smp->do_monitor = default_monitor;
d469 119
@


39.3
log
@killed fetchgbase
@
text
@d3 1
a3 1
*	$Id: monitor.c,v 39.2 92/01/07 15:56:00 spence Exp Locker: chrisg $
d12 3
a14 3
#include <graphics/gfxnodes.h>
#include <graphics/view.h>
#include <graphics/gfxbase.h>
d16 3
d30 1
a30 10
#ifndef CSTRINGS
__regargs strcmp(s,t)
char *s,*t;
{
	for( ; *s == *t; s++, t++) if(*s == '\0') return (0);
	return (*s - *t);
}
#endif

#define STREQ(a,b) (!strcmp((a),(b)))
a39 1
	int open = FALSE;
d60 1
a60 1
		if( ((ULONG)(GetDisplayInfoData(NULL,chunk,sizeof(*chunk),DTAG_MNTR,id)))
a69 1
	    open = !mspc->ms_OpenCount;	/* defer implementation of open */
a82 1
	int close = FALSE;
a89 1
	    close = !mspc->ms_OpenCount; /* defer implementation of close */
d265 1
a265 1
	          (struct SpecialMonitor *) GfxNew(SPECIAL_MONITOR_TYPE) )
d320 1
a320 1
	          GfxFree(mspc->ms_Special);
d386 1
a386 1
	          (struct SpecialMonitor *) GfxNew(SPECIAL_MONITOR_TYPE) )
d441 1
a441 1
	          GfxFree(mspc->ms_Special);
@


39.2
log
@cook_chunk -> GetDisplayInfoData etc.
@
text
@d3 1
a3 1
*	$Id: monitor.c,v 39.1 92/01/07 13:45:16 spence Exp Locker: spence $
a42 1
	struct GfxBase *GB;
d48 1
a48 1
	FETCHGBASE;
a49 2
	ObtainSemaphore(GB->MonitorListSemaphore);

d52 1
a52 1
	    mspc = GB->default_monitor;
d60 1
a60 1
		mspc = (struct MonitorSpec *)FindName(&GB->MonitorList,name);
d83 1
a83 1
	ReleaseSemaphore(GB->MonitorListSemaphore);
a90 1
	struct GfxBase *GB;
d94 1
a94 3
	FETCHGBASE;

	ObtainSemaphore(GB->MonitorListSemaphore);
d106 1
a106 1
	ReleaseSemaphore(GB->MonitorListSemaphore);
@


39.1
log
@gfxnew -> GfxNew. gfxfree -> gfxFree
@
text
@d3 1
a3 1
*	$Id: monitor.c,v 39.0 91/08/21 17:20:41 chrisg Exp Locker: spence $
d70 1
a70 1
		if( ((ULONG)(cook_chunk(NULL,chunk,sizeof(*chunk),DTAG_MNTR,id)))
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*	$Id: monitor.c,v 37.3 91/05/20 11:18:03 chrisg Exp Locker: chrisg $
d281 1
a281 1
	          (struct SpecialMonitor *) gfxnew(SPECIAL_MONITOR_TYPE) )
d336 1
a336 1
	          gfxfree(mspc->ms_Special);
d402 1
a402 1
	          (struct SpecialMonitor *) gfxnew(SPECIAL_MONITOR_TYPE) )
d457 1
a457 1
	          gfxfree(mspc->ms_Special);
@


37.3
log
@Added prototypes, improved warnings, and glue code. still needs work.
@
text
@d3 1
a3 1
*	$Id: monitor.c,v 1.1 91/05/20 10:42:29 chrisg Exp $
@


37.2
log
@uses d.protos
@
text
@d3 1
a3 1
*	$Id: monitor.c,v 37.1 91/05/02 13:04:48 chrisg Exp Locker: spence $
d23 1
d28 1
a28 1
strcmp(s,t)
a39 1
#ifdef PROTOTYPE_DISPLAY
d41 1
a41 3
struct MonitorSpec *open_monitor(name,id)
char *name;
ULONG id;
a90 35
#else

struct MonitorSpec *open_monitor(name)
char *name;
{
	struct GfxBase *GB;
	struct MonitorSpec *mspc= NULL;
	int open_default = ((!name) || STREQ(name,DEFAULT_MONITOR_NAME));
	int open = FALSE;

	FETCHGBASE;

	ObtainSemaphore(GB->MonitorListSemaphore);

	if(open_default)
	{
	    mspc = GB->default_monitor;
	}
	else
	{
	    mspc = (struct MonitorSpec *) FindName( &GB->MonitorList, name );
	}

	if(mspc)
	{
	    open = !mspc->ms_OpenCount;	/* defer implementation of open */
	    mspc->ms_OpenCount += 1;
	}

	ReleaseSemaphore(GB->MonitorListSemaphore);

	return( mspc );
}

#endif
d92 1
a92 2
close_monitor(mspc)
struct MonitorSpec *mspc;
a282 1
		int default_monitor();
a403 1
		int default_monitor();
@


37.1
log
@ changed "../" to "/" for native build
@
text
@d3 1
a3 1
*	$Id: monitor.c,v 37.0 91/01/07 15:20:16 spence Exp Locker: chrisg $
d15 1
d72 1
a72 1
		if( (cook_chunk(NULL,chunk,sizeof(*chunk),DTAG_MNTR,id))
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*	$Id: monitor.c,v 36.35 90/07/27 16:59:03 bart Exp Locker: spence $
d11 1
a11 1
#include "../macros.h"
d20 1
a20 1
#include "../displayinfo_internal.h"
@


36.35
log
@id
@
text
@d3 1
a3 1
*	$Id: $
@


36.34
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/graphics/c/RCS/monitor.c,v 36.33 89/06/29 10:12:38 bart Exp Locker: bart $
@


36.33
log
@don't read spuriously from location zero when checking name string
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.32 89/04/13 13:20:50 bart Exp $
@


36.32
log
@threw NULL_MSPC_FUNCTIONS switch for alpha 15
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.31 89/04/12 13:16:30 bart Exp $
d46 2
a47 1
	int open_default = (((!name)&&(!id))||STREQ(name,DEFAULT_MONITOR_NAME));
@


36.31
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.30 89/02/23 13:16:22 bart Exp $
d16 1
a16 1
/* #define NULL_MSPC_FUNCTIONS */
@


36.30
log
@DTAG_
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.29 89/02/17 22:04:07 bart Exp $
d16 1
d155 2
d162 2
d165 25
d239 2
@


36.29
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.28 89/02/16 10:08:20 bart Exp $
d69 1
a69 1
		if( (cook_chunk(NULL,chunk,sizeof(*chunk),TAG_MNTR,id))
@


36.28
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.27 89/02/15 16:06:53 bart Exp $
@


36.27
log
@displayinfo_internal
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.26 89/02/15 13:06:51 bart Exp $
d66 2
a67 2
		struct DisplayMonitor querymonitor;
		struct DisplayMonitor *chunk = &querymonitor;
d70 1
a70 1
		>= ((ULONG)(&((struct DisplayMonitor *)0)->Mspc)+sizeof(ULONG)))
@


36.26
log
@merge DisplayInfoDataBase with graphics
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.25 89/02/14 18:22:49 bart Exp $
d19 1
a19 4
#include <display/display_base.h>
#include <display/record.h>
#include <display/defines.h>
#include <graphics/displayinfo.h>
@


36.25
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.24 89/02/14 10:13:11 bart Exp $
d72 1
a72 1
		if((GetDisplayInfoData(NULL,chunk,sizeof(*chunk),TAG_MNTR,id))
@


36.24
log
@checkpoint 02.14.89
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.23 89/02/13 18:05:38 bart Exp $
d72 1
a72 1
		if((GetDisplayInfoData(NULL,chunk,sizeof(*chunk),TAG_MSPC,id))
@


36.23
log
@vanilla display library calls
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.22 89/02/11 12:19:46 bart Exp $
@


36.22
log
@coalesce all info into displayinfo record, multiple monitorinfo chunks
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.21 89/02/01 17:52:50 bart Exp $
d69 2
a70 1
		struct Record *record = FindDisplayInfo( id );
d72 2
a73 4
		/* kprintf("open_monitor: ID     == 0x%08lx\n", id    ); */
		/* kprintf("open_monitor: record == 0x%08lx\n", record); */

		if(record)
d75 1
a75 10
		    struct DisplayMonitor *monitor = 
			  (struct DisplayMonitor *)
			   FindTag( &record->rec_Tag, TAG_MSPC );

		    /* kprintf("open_monitor: monitor == 0x%08lx\n",monitor); */

		    if( monitor )
		    {
			mspc = monitor->Mspc;
		    }
@


36.21
log
@checkpoint -- a2024 10hz and 15hz scan works from 32 bit id
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.20 89/01/31 15:39:05 bart Exp $
d58 1
d64 1
d69 1
a69 1
		struct Record *record = FindDisplayMonitor( id );
d71 3
d80 2
d95 2
@


36.20
log
@checkpoint 2024
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.19 89/01/25 14:43:12 bart Exp $
@


36.19
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.18 89/01/25 14:37:05 bart Exp $
d253 2
d260 122
d491 2
@


36.18
log
@FindDisplayMonitor
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.17 89/01/24 15:38:21 bart Exp $
d67 1
a67 1
		struct Record *record = FindDisplayMonitor( ID );
@


36.17
log
@checkpoint 01.24.89
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.16 89/01/24 14:50:39 bart Exp $
d67 2
a68 2
		struct Record *record = FindID(GB->DisplayBase->Root,
				      ((GRAPHICS_MONITORS_ID<<16)|(id>>16)));
@


36.16
log
@include <graphics/displayinfo.h>
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.15 89/01/24 14:47:36 bart Exp $
@


36.15
log
@mspc = monitor->Mspc;
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.14 89/01/19 17:28:29 bart Exp $
d22 1
@


36.14
log
@checkpoint 01.19.89 coercion down to default
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.13 89/01/18 13:54:42 bart Exp $
d70 3
a72 1
		    struct TagItem *item = FindTag( &record->rec_Tag,TAG_MSPC );
d74 1
a74 1
		    if(item)
d76 1
a76 1
			mspc = (struct MonitorSpec *)item->ti_Data;
@


36.13
log
@checkpoint 01.18.89
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.12 89/01/12 16:14:37 bart Exp $
@


36.12
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.11 88/11/01 15:47:18 bart Exp $
@


36.11
log
@extended monitorspec structure
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.10 88/10/21 19:27:10 bart Exp $
d16 8
d39 54
d124 2
@


36.10
log
@MonitorListSemaphore
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.9 88/10/21 12:01:52 bart Exp $
d294 3
@


36.9
log
@OpenMonitor(), CloseMonitor()
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.8 88/09/14 11:21:04 bart Exp $
d36 2
a37 1
	int open_default = STREQ(name,DEFAULT_MONITOR_NAME);
d41 2
d54 2
a55 1
	    mspc->ms_OpenCount++;
d58 2
d66 2
d70 4
d76 2
a77 1
	    mspc->ms_OpenCount-- ;
d84 3
a86 1
	return(error);
@


36.8
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.7 88/08/12 13:18:15 bart Exp $
d18 8
a25 1
/* graphics direct access routines for monitor specification */
d27 1
a27 1
#ifdef DIRECT_ACCESS
d29 2
d34 1
d36 1
a36 1
	struct GfxBase *GB;
d40 1
a40 1
	if( mspc = (struct MonitorSpec *) FindName( &GB->MonitorList, name ) )
d42 9
a73 2
#endif

d205 1
a205 1
	          gfxnew(SPECIAL_MONITOR_TYPE) )
@


36.7
log
@mspc->DeniseMinDisplayColumn
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.6 88/08/07 16:50:53 bart Exp $
d18 39
d160 3
@


36.6
log
@checkpoint - assembly interface to monitorspec routines
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.5 88/09/01 09:56:13 bart Exp $
d128 1
@


36.5
log
@debugging
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.4 88/08/25 13:35:24 bart Exp $
@


36.4
log
@standard view position
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.3 88/07/26 18:19:03 bart Exp $
d16 1
a16 1
/* #define BARTDEBUG */
d26 1
a26 1
#ifdef BARTDEBUG
d37 1
a37 1
#ifdef BARTDEBUG
d169 2
a170 2
#ifdef UNDEFINED
		if(mspc->ms_reserved) /* temporary debugging */
d172 1
a172 1
		    struct GfxBase *GB = mspc->ms_reserved;
@


36.3
log
@rounding in scale routine
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.2 88/07/26 16:16:28 bart Exp $
d130 6
@


36.2
log
@stripped header
@
text
@d3 1
a3 1
*	$Header: monitor.c,v 36.1 88/07/23 17:09:11 bart Exp $
d92 4
a95 2
		tmp.x = (src->x * mspc->ratioh) >> RATIO_FIXEDPART;
		tmp.y = (src->y * mspc->ratiov) >> RATIO_FIXEDPART;
d99 4
a102 2
		tmp.x = (src->x * mspc->ratiov) >> RATIO_FIXEDPART;
		tmp.y = (src->y * mspc->ratioh) >> RATIO_FIXEDPART;
@


36.1
log
@monitorspec -- bart 07.23.88 merge source
@
text
@d3 1
a3 10
*	Source Control
*	--------------
*	$Header: monitor.c,v 36.0 88/07/23 14:07:35 bart Exp $
*
*	$Locker: bart $
*
*	$Log:	monitor.c,v $
*   Revision 36.0  88/07/23  14:07:35  bart
*   added to rcs for updating
*   
@


36.0
log
@added to rcs for updating
@
text
@d5 1
a5 1
*	$Header: $
d7 1
a7 1
*	$Locker: $
d9 4
a12 1
*	$Log: $
@
