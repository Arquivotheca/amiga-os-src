head     39.9;
branch   ;
access   ;
symbols  rel39_24:39.9 rel39_18:39.9 rel39_97:39.9 rel39_90:39.9 rel39_89:39.9 rel39_82:39.9 rel39_76:39.9 rel39_71:39.9 rel39_65:39.9 rel39_64:39.9 rel39_61:39.9 rel39_60:39.9 rel39_55:39.7 rel39_52:39.6 rel39_47:39.6 rel39_39:39.5 rel39_38:39.5 rel39_37:39.4 rel39_35:39.4 rel39_34:39.4 V37_30:37.0 V37_29:37.0 V37_28:37.0 V37_27:37.0 V37_25:37.0 V37_24:37.0 V37_23:37.0 V37_22:37.0 V37_21:37.0 V37_20:37.0 V37_19:37.0 V37_17:37.0 V37_15:37.0 V37_14:37.0 V37_13:37.0 V37_12:37.0 V37_11:37.0 V37_10:37.0 V37_9:37.0 V37_8:37.0 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.29 V36_208:36.29 V36_207:36.29 V36_205:36.29 V36_203:36.29 V36_202:36.29 V36_201:36.29 V36_200:36.29 V36_199:36.29 V36_198:36.29 V36_196:36.29 V36_195:36.29 V36_194:36.29 V36_193:36.29 V36_192:36.29 V36_191:36.29 V36_190:36.29 V36_189:36.29 V36_188:36.29 V36_186:36.25 V36_185:36.25 V36_184:36.25 V36_182:36.25 V36_181:36.25;
locks    ; strict;
comment  @ * @;


39.9
date     92.05.15.07.55.28;  author chrisg;  state Exp;
branches ;
next     39.8;

39.8
date     92.05.05.12.17.19;  author chrisg;  state Exp;
branches ;
next     39.7;

39.7
date     92.04.27.12.35.47;  author chrisg;  state Exp;
branches ;
next     39.6;

39.6
date     92.03.20.08.47.06;  author chrisg;  state Exp;
branches ;
next     39.5;

39.5
date     92.03.03.13.32.38;  author chrisg;  state Exp;
branches ;
next     39.4;

39.4
date     92.01.21.13.29.57;  author chrisg;  state Exp;
branches ;
next     39.3;

39.3
date     92.01.07.14.15.13;  author chrisg;  state Exp;
branches ;
next     39.2;

39.2
date     91.11.08.11.31.09;  author chrisg;  state Exp;
branches ;
next     39.1;

39.1
date     91.11.04.15.39.57;  author chrisg;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.21.47;  author chrisg;  state Exp;
branches ;
next     37.2;

37.2
date     91.05.20.11.19.49;  author chrisg;  state Exp;
branches ;
next     37.1;

37.1
date     91.05.02.13.09.14;  author chrisg;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.20.38;  author spence;  state Exp;
branches ;
next     36.29;

36.29
date     90.10.05.18.00.29;  author bart;  state Exp;
branches ;
next     36.28;

36.28
date     90.10.05.17.24.57;  author bart;  state Exp;
branches ;
next     36.27;

36.27
date     90.10.05.13.48.20;  author bart;  state Exp;
branches ;
next     36.26;

36.26
date     90.10.05.13.11.03;  author bart;  state Exp;
branches ;
next     36.25;

36.25
date     90.07.27.16.59.40;  author bart;  state Exp;
branches ;
next     36.24;

36.24
date     90.03.28.09.11.39;  author bart;  state Exp;
branches ;
next     36.23;

36.23
date     89.12.15.11.12.02;  author bart;  state Exp;
branches ;
next     36.22;

36.22
date     89.12.14.17.46.09;  author bart;  state Exp;
branches ;
next     36.21;

36.21
date     89.12.11.11.19.02;  author bart;  state Exp;
branches ;
next     36.20;

36.20
date     89.11.30.17.23.37;  author bart;  state Exp;
branches ;
next     36.19;

36.19
date     89.11.29.23.24.00;  author bart;  state Exp;
branches ;
next     36.18;

36.18
date     89.11.29.23.00.58;  author bart;  state Exp;
branches ;
next     36.17;

36.17
date     89.11.21.20.44.28;  author bart;  state Exp;
branches ;
next     36.16;

36.16
date     89.11.21.20.13.52;  author bart;  state Exp;
branches ;
next     36.15;

36.15
date     89.09.18.12.32.37;  author bart;  state Exp;
branches ;
next     36.14;

36.14
date     89.09.01.16.16.31;  author bart;  state Exp;
branches ;
next     36.13;

36.13
date     89.08.25.17.29.31;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     89.08.03.17.05.05;  author bart;  state Exp;
branches ;
next     36.11;

36.11
date     89.08.02.18.37.18;  author bart;  state Exp;
branches ;
next     36.10;

36.10
date     89.08.02.18.36.36;  author bart;  state Exp;
branches ;
next     36.9;

36.9
date     89.03.28.17.32.53;  author bart;  state Exp;
branches ;
next     36.8;

36.8
date     89.03.28.17.29.38;  author bart;  state Exp;
branches ;
next     36.7;

36.7
date     88.10.13.16.18.32;  author bart;  state Exp;
branches ;
next     36.6;

36.6
date     88.10.13.15.21.45;  author bart;  state Exp;
branches ;
next     36.5;

36.5
date     88.10.13.15.15.16;  author bart;  state Exp;
branches ;
next     36.4;

36.4
date     88.10.13.14.04.15;  author bart;  state Exp;
branches ;
next     36.3;

36.3
date     88.10.12.18.17.45;  author bart;  state Exp;
branches ;
next     36.2;

36.2
date     88.07.15.12.33.46;  author bart;  state Exp;
branches ;
next     36.1;

36.1
date     88.03.10.16.12.09;  author dale;  state Exp;
branches ;
next     ;


desc
@@


39.9
log
@ set all 3 damage bits.
@
text
@/******************************************************************************
*
*	$Id: scrollraster.c,v 39.8 92/05/05 12:17:19 chrisg Exp Locker: chrisg $
*
******************************************************************************/

#include <exec/types.h>
#include <exec/nodes.h>
#include <exec/lists.h>
#include <exec/ports.h>
#include <exec/memory.h>
#include <graphics/gfx.h>
#include <graphics/clip.h>
#include <graphics/rastport.h>
#include <hardware/blit.h>
#include <graphics/regions.h>
#include <graphics/layers.h>
#include <pragmas/layers_pragmas.h>
#include "/gfxbase.h"
#include "/macros.h"
#include "c.protos"
#include "/gfxpragmas.h"

#define COPY    NANBC|NABC|ABNC|ABC
#define REFRESHFLAGS (LAYERREFRESH | LAYERIREFRESH | LAYERIREFRESH2)

/*#define DEBUG*/

UWORD getmaxbytesperrow(rp,TempA)
struct RastPort *rp;
long *TempA;
{
#ifdef DEBUG
	printf("getmaxbytesperrow(%lx,%lx)\n",rp,TempA);
#endif
	if (*TempA = getTempA(rp)) return(TRUE);
	*TempA = getmustmem(MAXBYTESPERROW,MEMF_CHIP);
#ifdef DEBUG
	printf("getmaxbyteperrow returning false\n");
#endif
	return(FALSE);
}

#ifndef MAKE_PROTOS /* SAS doesn't handle proto generation for functions taking pointers to __asm functions */
void __regargs scroll_primitive(struct RastPort *rp,short dx,short dy,short MINX,short MINY,
				short MAXX,short MAXY,
				 void (* __asm fillptr)(register __a1 struct RastPort *rp, 
							register __d0 short xl, register __d1 short yl,
							register __d2 short xu, register __d3 short yu))
{
    struct Layer *cw;
    short direction;
    short absdx,absdy;
    short maxx,maxy;
    short height,width;
    short srcx,srcy;
    short dstx,dsty;
    char *TempA;
    struct BitMap *bm;
    UWORD using_tmpras = FALSE;

#ifdef DEBUG
    printf("rscroll(%lx,%ld,%ld,%ld,%ld,%ld,%ld)\n",rp,dx,dy,MINX,MINY,MAXX,MAXY);
#endif

#ifdef DEBUGE
    printf("[");
#endif

    TempA = 0;
    if (dy == 0) using_tmpras = getmaxbytesperrow(rp,&TempA);

    bm = rp->BitMap;
    absdx = dx;
    absdy = dy;
    direction = 0;
    if (dy < 0)
    {
		absdy = -dy;
		direction = 2;
    }
    if (dx < 0)
    {
		absdx = -dx;
		direction += 1;
    }
    switch(direction)
    {
		case 0 : /* upper left movement */
			srcx = absdx;   srcy = absdy;
			dstx = 0;       dsty = 0;
			break;
		case 1 : /* upper right movement */
			srcx = 0;       srcy = absdy;
			dstx = absdx;   dsty = 0;
			break;
		case 2 : /* lower left movement */
			srcx = absdx;   srcy = 0;
			dstx = 0;       dsty = absdy;
			break;
		case 3 : /* lower right movement */
			srcx = 0;       srcy = 0;
			dstx = absdx;   dsty = absdy;
			break;
    }


    if ( (cw = rp->Layer) == 0)
    {
		srcx += MINX;
		srcy += MINY;
		dstx += MINX;
		dsty += MINY;

		maxx = SHORTMIN(MAXX,(rp->BitMap->BytesPerRow<<3) - 1);
		maxy = SHORTMIN(MAXY,rp->BitMap->Rows - 1);
#ifdef DEBUG
    	printf("maxx=%ld maxy=%ld\n",maxx,maxy);
#endif

		height = maxy + 1 - absdy - MINY;
		width = maxx + 1 - absdx - MINX;
		if ( (height <= 0) || (width <= 0)) goto RETURN;
#ifdef DEBUG
		printf(
		"BLTBITMAP(%lx,%lx,%ld,%ld,%lx,%ld,%ld,%ld,%ld,%lx,%lx,%lx)\n",
		    	bm,srcx,srcy,
		    	bm,dstx,dsty,width,height,COPY,rp->Mask,TempA);
#endif
		gfx_BltBitMap(bm,srcx,srcy,
		    	bm,dstx,dsty,width,height,COPY,rp->Mask,TempA);
#ifdef DEBUG
		printf("return\n");
#endif
    }
    else
    {
#ifdef DEBUG
	printf("locklayerrom\n");
#endif
		LOCKLAYER(cw);

		if (cw->SuperBitMap)
		{
		    struct RastPort temp_rastport;

		    /*maxx = (bm->BytesPerRow<<3) - 1;
		    maxy = bm->Rows - 1;*/

		    SyncSBitMap(cw);

		    /* bm = rp->BitMap; */
		    /* rp->BitMap = cw->SuperBitMap; */
		    /* I'm a BAD BOY */
		    /* rp->Layer = 0; */
		    /* scrollraster(rp,dx,dy,MINX,MINY,MAXX,MAXY); */
		    /* rp->BitMap = bm; */
		    /* rp->Layer = cw; */

		    /* bart - 03.06.86 */

		    temp_rastport = *rp;
		    temp_rastport.BitMap = cw->SuperBitMap;
		    temp_rastport.Layer = NULL;
		    scroll_primitive(&temp_rastport,dx,dy,MINX,MINY,MAXX,MAXY,fillptr);

		    /* end bart - 03.06.86 */

		    CopySBitMap(cw);
		    UNLOCKLAYER(cw);
		    goto RETURN;
		}
		else
		{
		    struct ClipRect *cr,*crn;
		    struct Rectangle tmprect;
		    struct Rectangle boundsrect;
		    struct Rectangle clip; 

		    /* do tough scroll */
		    /* step 1: sort ClipRects into correct order */
		    /* step 2: for each ClipRect, move it bits internal */
		    /*         then look through rest of ClipRects for  */
		    /*         bits to move in */

		    /* scroll damage added to cw->DamageList -- bart */
		    /* dont add scroll damage added to smart -- bart */
		    /* the reason for this is that if the guy really */
		    /* wants to scroll things that dont exist he/she */
		    /* should be smart enough to refresh that region */
		    /* and not penalize everybody else 89.03.28 bart */

		    maxx = cw->bounds.MaxX - cw->bounds.MinX;
		    maxy = cw->bounds.MaxY - cw->bounds.MinY;

		    maxx = SHORTMIN(maxx,MAXX);
		    maxy = SHORTMIN(maxy,MAXY);

		    if(cw->Flags & LAYERSIMPLE) /* speedup damage calculation */
		    {
			struct Region *old;

			if(old = cw->DamageList)
			{
			    struct Region *new;

			    if(new = (struct Region *)NewRegion())
			    {
				struct Region *tmp;

				if(tmp = (struct Region *)NewRegion())
				{
				    clip.MinX = MINX;
				    clip.MinY = MINY;
				    clip.MaxX = maxx;
				    clip.MaxY = maxy;

				    for (cr = cw->ClipRect; 
					 cr; 
				         cr = cr->Next )
				    {
					if(!cr->lobs) /* onscreen only */
					{
					    tmprect = cr->bounds;

					    tmprect.MinX -= cw->bounds.MinX;
					    tmprect.MaxX -= cw->bounds.MinX;
					    tmprect.MinY -= cw->bounds.MinY;
					    tmprect.MaxY -= cw->bounds.MinY;

					    if(rectXrect(&tmprect,&clip))
					    {
						intersect(&tmprect,&clip,&tmprect);

						orrectregion(new,&tmprect.MinX);
						orrectregion(tmp,&tmprect.MinX);
					    }
					}
				    }

				    /* shift offset */
				    tmp->bounds.MinX += dx;
				    tmp->bounds.MaxX += dx;
				    tmp->bounds.MinY += dy;
				    tmp->bounds.MaxY += dy;

				    if(xorregionregion(new,tmp))
				    {
				    	if(old->RegionRectangle)
					{
					    /* only if existing damage */
					    orregionregion(old,tmp);
					}

					/* shift back */
					tmp->bounds.MinX -= dx;
					tmp->bounds.MaxX -= dx;
					tmp->bounds.MinY -= dy;
					tmp->bounds.MaxY -= dy;

					if(andregionregion(tmp,new))
					{
					    /* remove area of vacated damage */

					    if (dy > 0) 
					    {
						clip.MaxY = 
						SHORTMAX(MINY,maxy-dy);
					    }
					    else 
					    {
						if (dy < 0)
						{
						    clip.MinY = 
						    SHORTMIN(maxy,MINY+absdy);
						}
					    }
					    if (dx > 0) 
					    {
						clip.MaxX = 
						SHORTMAX(MINX,maxx-dx);
					    }
					    else 
					    {
						if (dx < 0)
						{
						    clip.MinX = 
						    SHORTMIN(maxx,MINX+absdx);
						}
					    }

					    andrectregion(new,&clip);

					    if(old->RegionRectangle)
					    {
						/* add damage to old */
						orregionregion(new,old);
					    }
					    else
					    {
						/* swap damage for old */
						cw->DamageList = new;
						new = old;
					    }

					    /* iff layer damaged - bart */
					    if(cw->DamageList->RegionRectangle)
					    {
						/* indicate damage to layer */
						cw->Flags |= REFRESHFLAGS;  
					    }
					}
				    }

				    disposeregion(tmp);
				}

				disposeregion(new);
			    }
			}
		    }

			SortLayerCR(cw,dx,dy);

		    /* initialize clipping for bit transfer */

		    clip.MinX = MINX + cw->bounds.MinX;
		    clip.MinY = MINY + cw->bounds.MinY;
		    clip.MaxX = MAXX + cw->bounds.MinX;
		    clip.MaxY = MAXY + cw->bounds.MinY;

		    for (cr = cw->ClipRect; cr ; cr = cr->Next)
		    {
				int DX,DY;
				/* skip over cliprects with no bitmaps */
#ifdef DEBUG
				printf("process cr = %lx lobs=%lx BitMap=%lx",
				cr,cr->lobs,cr->BitMap);
				Debug();
#endif

				if ( (cr->lobs == 0) || (cr->BitMap != 0))
				{

					/* do internal bit transfer */
				    
					boundsrect.MinX =  clip.MinX;
					boundsrect.MinY =  clip.MinY;
					boundsrect.MaxX =  clip.MaxX;
					boundsrect.MaxY =  clip.MaxY;

					/* if this cliprect is not involved then skip */
					if ( rectXrect(&boundsrect,&cr->bounds))
					{

						/* calculate intersection */
						intersect(&boundsrect,&cr->bounds,&boundsrect);

						DX = boundsrect.MinX - cr->bounds.MinX;
						DY = boundsrect.MinY - cr->bounds.MinY;

						width = boundsrect.MaxX - boundsrect.MinX + 1 - absdx;
						height = boundsrect.MaxY - boundsrect.MinY + 1 - absdy;
#ifdef DEBUG
    printf("do internal bit transfer w=%ld h=%ld\n",width,height);
#endif
						if ( (width > 0) && (height > 0))
						{
						    if (cr->lobs == 0)  /* screen blit */
							gfx_BltBitMap(bm,
								srcx+boundsrect.MinX,srcy+boundsrect.MinY,
								bm,dstx+boundsrect.MinX,dsty+boundsrect.MinY,
								width,height,COPY,rp->Mask,TempA);
						    else
						    {   /* obscured blit */
							gfx_BltBitMap(cr->BitMap,
							    srcx+(cr->bounds.MinX&15)+DX,srcy+DY,
							    cr->BitMap,
							    dstx+(cr->bounds.MinX&15)+DX,dsty+DY,
							    width,height,COPY,rp->Mask,TempA);
						    }
						}

					/* look at rest of cliprects and extract any needed bits */
					for (crn = cr->Next ; crn ; crn = crn->Next)
					{
#ifdef DEBUG
					    printf(" check crn=%lx ,",crn);
#endif
					    tmprect.MinX = crn->bounds.MinX;
					    tmprect.MinY = crn->bounds.MinY;
					    tmprect.MaxX = crn->bounds.MaxX;
					    tmprect.MaxY = crn->bounds.MaxY;

					    if(cw->DamageList) /* layers is special -- bart */
					    {
						if(!rectXrect(&tmprect,&clip))
						{ 
							continue;
						}
						else
						{
							intersect(&tmprect,&clip,&tmprect);
						}
					    }

					    tmprect.MinX -= dx;
					    tmprect.MinY -= dy;
					    tmprect.MaxX -= dx;
					    tmprect.MaxY -= dy;

					    /* look for bits to get */
					    if (rectXrect(&tmprect,&boundsrect))
					    {
							/* calculate intersection */
#ifdef DEBUG
    printf("now calculate intersection for (%lx,%lx)\n",cr,crn);
#endif
						intersect(&tmprect,&boundsrect,&tmprect);

						width = tmprect.MaxX-tmprect.MinX + 1;
						height = tmprect.MaxY-tmprect.MinY + 1;
						if (cr->lobs == 0)
						{
						    if (crn->lobs == 0)
							/* copy screen-> screen */
							gfx_BltBitMap(bm,tmprect.MinX + dx,
								tmprect.MinY + dy,
							bm,tmprect.MinX,tmprect.MinY,
							width,height,COPY,rp->Mask,TempA);
						    else
						    {   /* copy obscured->screen */
							
								if ( crn->BitMap )
								{
									gfx_BltBitMap(crn->BitMap,
									tmprect.MinX + dx-(crn->bounds.MinX&(~15)),
									tmprect.MinY + dy - crn->bounds.MinY,
									bm,tmprect.MinX,tmprect.MinY,
									width,
									height, 
									COPY,rp->Mask,TempA);
								}
								else    /* trigger refresh needed */
								if(cw->DamageList)
								{
#ifdef DEBUG
printf("trigger refresh\n");
#endif
									tmprect.MinX -= cw->bounds.MinX;
									tmprect.MinY -= cw->bounds.MinY;
									tmprect.MaxX = tmprect.MinX + width -1;
									tmprect.MaxY = tmprect.MinY + height -1;
									orrectregion(cw->DamageList,&tmprect);
									cw->Flags |= REFRESHFLAGS;  
								}
						    }
						}
						else
						{
						    /* cr is obscured */
						    if (crn->lobs == 0)
						    {
#ifdef DEBUG2
    printf("copy screen to obscured\n");
    printf("call BLTBITMAP(%lx,%ld,%ld,%lx,%ld,%ld,%ld,%ld,%lx\n",
				bm,tmprect.MinX + dx,
					tmprect.MinY + dy,
				cr->BitMap,tmprect.MinX - (cr->bounds.MinX&(~15)),
				tmprect.MinY - cr->bounds.MinY,
				width,height,COPY);
    Debug();
#endif
				/* copy screen-> obscured */
				gfx_BltBitMap(bm,tmprect.MinX + dx,
					tmprect.MinY + dy,
				cr->BitMap,tmprect.MinX - (cr->bounds.MinX&(~15)),
				tmprect.MinY - cr->bounds.MinY,
				width,height,COPY,rp->Mask,TempA);
			    }
			    else
			    {   /* copy obscured->obscured */
				gfx_BltBitMap(crn->BitMap,
				    tmprect.MinX + dx-(crn->bounds.MinX&(~15)),
				    tmprect.MinY + dy - crn->bounds.MinY,
				cr->BitMap,tmprect.MinX - (cr->bounds.MinX&(~15)),
				tmprect.MinY - cr->bounds.MinY,
				width,height,COPY,rp->Mask,TempA);
			    }
			}
		    }
		}
		}   /* rectXrect */
		}   /* obs,Bitmap */
	    }
	}
	UNLOCKLAYER(cw);
    }
#ifdef DEBUGE
    printf("]");
#endif
    /* now clear the area of vacated */
    {
	struct RastPort rpnew;
	gfx_InitRastPort(&rpnew);
	rpnew.BitMap = rp->BitMap;
	rpnew.Layer = rp->Layer;
	rpnew.Mask = rp->Mask;
	gfx_SetAPen(&rpnew,rp->BgPen);

	if (dy > 0) 
	    (*fillptr)(&rpnew,MINX,SHORTMAX(MINY,maxy + 1 - dy),maxx,maxy);
	else if (dy < 0)
	    (*fillptr)(&rpnew,MINX,MINY,maxx,MINY+absdy - 1);
	if (dx > 0) 
	    (*fillptr)(&rpnew,SHORTMAX(MINX,maxx + 1 - dx),MINY,maxx,maxy);
	else if (dx < 0)
	    (*fillptr)(&rpnew,MINX,MINY,MINX + absdx - 1,maxy);
    }

RETURN:

    if (dy == 0) if (!using_tmpras)	freemustmem(TempA,MAXBYTESPERROW);
#ifdef DEBUG
    printf("\nreturn rscroll\n");
#endif
}



#endif /* MAKE_PROTOS */

void __asm ScrollRaster(register __a1 struct RastPort *rp,register __d0 short dx,register __d1 short dy,
		  register __d2 short MINX,register __d3 short MINY,register __d4 short MAXX,
		  register __d5 short MAXY)

{
    scroll_primitive(rp,dx,dy,MINX,MINY,MAXX,MAXY,RectFill);
}

void __asm ScrollRasterBF(register __a1 struct RastPort *rp,register __d0 short dx,register __d1 short dy,
		  register __d2 short MINX,register __d3 short MINY,register __d4 short MAXX,
		  register __d5 short MAXY)

{
    scroll_primitive(rp,dx,dy,MINX,MINY,MAXX,MAXY,EraseRect);
}
@


39.8
log
@no stub for sortcr.
@
text
@d3 1
a3 1
*	$Id: scrollraster.c,v 39.7 92/04/27 12:35:47 chrisg Exp Locker: chrisg $
d25 1
d310 1
a310 1
						cw->Flags |= LAYERREFRESH;  
d455 1
a455 1
									cw->Flags |= LAYERREFRESH;  
@


39.7
log
@pragmas.
fixed recursion.
@
text
@d3 1
a3 1
*	$Id: scrollraster.c,v 39.6 92/03/20 08:47:06 chrisg Exp Locker: chrisg $
d18 1
d43 1
d322 1
a322 1
			sortcr(cw,dx,dy);
d530 1
@


39.6
log
@ added scrollrasterbf.
@
text
@d3 1
a3 1
*	$Id: scrollraster.c,v 39.5 92/03/03 13:32:38 chrisg Exp Locker: chrisg $
d127 1
a127 1
		BLTBITMAP(bm,srcx,srcy,
d162 1
a162 1
		    ScrollRaster(&temp_rastport,dx,dy,MINX,MINY,MAXX,MAXY);
d367 1
a367 1
							BLTBITMAP(bm,
d373 1
a373 1
							BLTBITMAP(cr->BitMap,
d424 1
a424 1
							BLTBITMAP(bm,tmprect.MinX + dx,
d433 1
a433 1
									BLTBITMAP(crn->BitMap,
d472 1
a472 1
				BLTBITMAP(bm,tmprect.MinX + dx,
d480 1
a480 1
				BLTBITMAP(crn->BitMap,
@


39.5
log
@ now works w/o stub.
@
text
@d3 1
a3 1
*	$Id: scrollraster.c,v 39.4 92/01/21 13:29:57 chrisg Exp Locker: chrisg $
d21 1
d42 5
a46 3
void __asm ScrollRaster(register __a1 struct RastPort *rp,register __d0 short dx,register __d1 short dy,
		  register __d2 short MINX,register __d3 short MINY,register __d4 short MAXX,
		  register __d5 short MAXY)
d502 1
a502 1
	shortinitrast(&rpnew);
d506 1
a506 1
	SETAPEN(&rpnew,rp->BgPen);
d509 1
a509 1
	    RECTFILL(&rpnew,MINX,SHORTMAX(MINY,maxy + 1 - dy),maxx,maxy);
d511 1
a511 1
	    RECTFILL(&rpnew,MINX,MINY,maxx,MINY+absdy - 1);
d513 1
a513 1
	    RECTFILL(&rpnew,SHORTMAX(MINX,maxx + 1 - dx),MINY,maxx,maxy);
d515 1
a515 1
		    RECTFILL(&rpnew,MINX,MINY,MINX + absdx - 1,maxy);
d524 19
@


39.4
log
@ made inc gfxbase
@
text
@d3 1
a3 1
*	$Id: scrollraster.c,v 39.3 92/01/07 14:15:13 chrisg Exp Locker: chrisg $
d41 3
a43 4
scrollraster(rp,dx,dy,MINX,MINY,MAXX,MAXY)
struct RastPort *rp;
short dx,dy;
short MINX,MINY,MAXX,MAXY;
d159 1
a159 1
		    scrollraster(&temp_rastport,dx,dy,MINX,MINY,MAXX,MAXY);
@


39.3
log
@ CopySBitMap() and SyncSBitmap() no longer have assembly glue.
the C functions now have the real names.
@
text
@d3 1
a3 1
*	$Id: scrollraster.c,v 39.2 91/11/08 11:31:09 chrisg Exp Locker: chrisg $
d18 1
a20 1
#include "/gfxbase.h"
@


39.2
log
@  made call new sortcr function in misc.asm
@
text
@d3 1
a3 1
*	$Id: scrollraster.c,v 39.1 91/11/04 15:39:57 chrisg Exp Locker: chrisg $
d145 1
a145 1
		    syncsbitmap(cw);
d164 1
a164 1
		    copysbitmap(cw);
@


39.1
log
@ made use the new layers cliprect sorting function
@
text
@d3 1
a3 1
*	$Id: scrollraster.c,v 39.0 91/08/21 17:21:47 chrisg Exp Locker: chrisg $
d318 1
a318 6
#pragma libcall GBASE->LayersBase SortLayerCR d2 10803

			if (! GBASE->LayersBase)
				GBASE->LayersBase=(ULONG *) OpenLibrary("layers.library",39);
			if (GBASE->LayersBase)
					SortLayerCR(cw,dx,dy);
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*	$Id: scrollraster.c,v 37.2 91/05/20 11:19:49 chrisg Exp Locker: chrisg $
d20 1
d318 6
a323 1
		    cr_sort(cw,dx,dy);
@


37.2
log
@Added prototypes, improved warnings, and glue code. still needs work.
@
text
@d3 1
a3 1
*	$Id: scrollraster.c,v 1.1 91/05/20 10:43:42 chrisg Exp $
@


37.1
log
@ changed "../" to "/" for native build
@
text
@d3 1
a3 1
*	$Id: scrollraster.c,v 37.0 91/01/07 15:20:38 spence Exp Locker: chrisg $
d19 1
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*	$Id: scrollraster.c,v 36.29 90/10/05 18:00:29 bart Exp Locker: spence $
d18 1
a18 1
#include "../macros.h"
@


36.29
log
@fix darrren's scrollraster bug thanks to spence
@
text
@d3 1
a3 1
*	$Id: scrollraster.c,v 36.28 90/10/05 17:24:57 bart Exp Locker: bart $
@


36.28
log
@fix adjunct to B9852
@
text
@d3 1
a3 1
*	$Id: scrollraster.c,v 36.27 90/10/05 13:48:20 bart Exp Locker: bart $
d212 1
a212 1
					 cr && !cr->lobs;  /* onscreen only */
d215 3
a217 1
					tmprect = cr->bounds;
d219 4
a222 4
					tmprect.MinX -= cw->bounds.MinX;
					tmprect.MaxX -= cw->bounds.MinX;
					tmprect.MinY -= cw->bounds.MinY;
					tmprect.MaxY -= cw->bounds.MinY;
d224 3
a226 3
					if(rectXrect(&tmprect,&clip))
					{
					    intersect(&tmprect,&clip,&tmprect);
d228 3
a230 2
					    orrectregion(new,&tmprect.MinX);
					    orrectregion(tmp,&tmprect.MinX);
@


36.27
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Id: scrollraster.c,v 36.26 90/10/05 13:11:03 bart Exp Locker: bart $
d171 1
a205 2
				    struct Rectangle clip; 

d315 7
d336 5
a340 4
					boundsrect.MinX = MINX + cw->bounds.MinX;
					boundsrect.MinY = MINY + cw->bounds.MinY;
					boundsrect.MaxX = MAXX + cw->bounds.MinX;
					boundsrect.MaxY = MAXY + cw->bounds.MinY;
d387 1
a387 1
						if(!rectXrect(&tmprect,&boundsrect))
d393 1
a393 1
							intersect(&tmprect,&boundsrect,&tmprect);
@


36.26
log
@fix bug B9852 (scrolling of unwanted stuff outside clipped region)
@
text
@d3 1
a3 1
*	$Id: scrollraster.c,v 36.25 90/07/27 16:59:40 bart Exp Locker: bart $
d171 1
d378 1
a378 5
					    if(!rectXrect(&tmprect,&boundsrect))
					    { 
						    continue;
					    }
					    else
d380 8
a387 1
						    intersect(&tmprect,&boundsrect,&tmprect);
@


36.25
log
@id
@
text
@d3 1
a3 1
*	$Id: $
d324 1
d333 1
a333 1
    
d372 19
a390 4
					    tmprect.MinX = crn->bounds.MinX - dx;
					    tmprect.MinY = crn->bounds.MinY - dy;
					    tmprect.MaxX = crn->bounds.MaxX - dx;
					    tmprect.MaxY = crn->bounds.MaxY - dy;
d399 1
@


36.24
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/graphics/c/RCS/scrollraster.c,v 36.23 89/12/15 11:12:02 bart Exp Locker: bart $
@


36.23
log
@simple layerrefresh iff damage
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.22 89/12/14 17:46:09 bart Exp $
@


36.22
log
@remove area of vacated damage
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.21 89/12/11 11:19:02 bart Exp $
d138 1
a138 1
            struct RastPort temp_rastport;
a189 99
#ifdef TORTOISE
		    if((cw->Flags & LAYERSIMPLE)/*||(cw->Flags & LAYERSMART)*/)
		    {
			struct Rectangle a,b;
			struct Region *tmp;
			struct Region *old = cw->DamageList;

			/* methinks that layers may play a trick here */
			if( old && (tmp = (struct Region *)NewRegion()) )
			{
			    struct Region *delta = (struct Region *)NewRegion();

			    /* limit scroll damage to scroll rectangle */

			    a.MinX = MAX(0,MINX);				
			    a.MinY = MAX(0,MINY);
			    a.MaxX = MIN(cw->bounds.MaxX-cw->bounds.MinX,MAXX);
			    a.MaxY = MIN(cw->bounds.MaxY-cw->bounds.MinY,MAXY);

			    if(delta)
			    {
				for (cr = cw->ClipRect; cr ; cr = cr->Next)
				{
				    tmprect = cr->bounds;

				    tmprect.MinX -= cw->bounds.MinX;
				    tmprect.MaxX -= cw->bounds.MinX;
				    tmprect.MinY -= cw->bounds.MinY;
				    tmprect.MaxY -= cw->bounds.MinY;

				    orrectregion(delta,&tmprect.MinX);
				}

				/* clip non obscured to region of interest */
				andrectregion(delta,&a);  

				/* copy non obscured to tmp */
				orregionregion(delta,tmp); 

				/* shift offset */
				tmp->bounds.MinX += dx;
				tmp->bounds.MaxX += dx;
				tmp->bounds.MinY += dy;
				tmp->bounds.MaxY += dy;

				/* offset change */
				xorregionregion(delta,tmp); 

				/* shift back */
				tmp->bounds.MinX -= dx;
				tmp->bounds.MaxX -= dx;
				tmp->bounds.MinY -= dy;
				tmp->bounds.MaxY -= dy;

				/* delta change */
				andregionregion(tmp,delta); 

				/* reinitialize temporary region */
				clearregion(tmp);
			    }

			    tmp->bounds.MinX += dx;
			    tmp->bounds.MaxX += dx;
			    tmp->bounds.MinY += dy;
			    tmp->bounds.MaxY += dy;

			    /* add old damage */
			    orregionregion(old,tmp); 

			    tmp->bounds.MinX -= dx;
			    tmp->bounds.MaxX -= dx;
			    tmp->bounds.MinY -= dy;
			    tmp->bounds.MaxY -= dy;

			    /* copy scrolled damage back to old region */
			    clearregion(old);
			    orregionregion(tmp,old); 

			    /* clip old scrolled damage to region of interest */
			    andrectregion(old,&a);  

			    /* add delta to final */
			    if(delta)
			    {
				orregionregion(delta,old); 
				disposeregion(delta); 
			    }

			    /* hygiene */
			    disposeregion(tmp);

			    /* clip final scroll damage to bounds */
			    andrectregion(old,&a);  

			    /* indicate damage to layer */
			    cw->Flags |= LAYERREFRESH;  
			}
		    }
#else HARE	
d296 6
a301 2
					    /* indicate damage to layer */
					    cw->Flags |= LAYERREFRESH;  
a311 1
#endif
@


36.21
log
@better damage for small scroll regions
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.20 89/11/30 17:23:37 bart Exp $
d183 7
d305 4
a308 6
				    clip.MinX = MAX(0,MINX);
				    clip.MinY = MAX(0,MINY);
				    clip.MaxX = MIN(cw->bounds.MaxX-
						    cw->bounds.MinX,MAXX);
				    clip.MaxY = MIN(cw->bounds.MaxY-
						    cw->bounds.MinY,MAXY);
d352 29
a410 6
		    maxx = cw->bounds.MaxX - cw->bounds.MinX;
		    maxy = cw->bounds.MaxY - cw->bounds.MinY;

		    maxx = SHORTMIN(maxx,MAXX);
		    maxy = SHORTMIN(maxy,MAXY);

d560 1
a560 1
    /* now clear the area vacated */
@


36.20
log
@even faster damage calculation sped up from 36.96 by 20 percent
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.19 89/11/29 23:24:00 bart Exp $
d296 9
d316 7
a322 2
					orrectregion(new,&tmprect.MinX);
					orrectregion(tmp,&tmprect.MinX);
a346 11
					    struct Rectangle clip; 

					    clip.MinX = MAX(0,MINX);
					    clip.MinY = MAX(0,MINY);
					    clip.MaxX = 
						 MIN(cw->bounds.MaxX-
						 cw->bounds.MinX,MAXX);
					    clip.MaxY = 
						 MIN(cw->bounds.MaxY-
						 cw->bounds.MinY,MAXY);

@


36.19
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.18 89/11/29 23:00:58 bart Exp $
d296 3
a298 1
				    for (cr = cw->ClipRect; cr ; cr = cr->Next)
d317 1
a317 2
				    if( xorregionregion(new,tmp)
				    &&	 orregionregion(old,tmp) )
d319 6
a344 1
					    orregionregion(new,old);
d346 12
d482 1
a482 1
								cw->Flags |= 0x80;
@


36.18
log
@faster scrollraster damage calculations
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.17 89/11/21 20:44:28 bart Exp $
a135 2
		cr_sort(cw,dx,dy);

d353 2
@


36.17
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.16 89/11/21 20:13:52 bart Exp $
d135 3
d185 1
d283 4
d288 67
a354 1
		    cr_sort(cw,dx,dy);
@


36.16
log
@layers scrollraster optimisation
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.15 89/09/18 12:32:37 bart Exp $
d380 1
@


36.15
log
@limit clear to scrolled region. bart
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.14 89/09/01 16:16:31 bart Exp $
d185 1
a186 1
			struct Region *tmp = (struct Region *)NewRegion();
d188 2
a189 1
			if(tmp)
@


36.14
log
@fixed cr_sort algorithm
removed circular dependancies
from lessthan test
and renamed it "prior"
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.13 89/08/25 17:29:31 bart Exp $
d444 2
a445 1
	if (dy > 0) RECTFILL(&rpnew,MINX,maxy + 1 - dy,maxx,maxy);
d447 3
a449 2
		    RECTFILL(&rpnew,MINX,MINY,maxx,MINY+absdy - 1);
	if (dx > 0) RECTFILL(&rpnew,maxx + 1 - dx,MINY,maxx,maxy);
@


36.13
log
@fix scrollraster damage off by one bug for obs cliprects
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.12 89/08/03 17:05:05 bart Exp $
@


36.12
log
@retract bugfix 4382 .. testing reveals incorrect
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.11 89/08/02 18:37:18 bart Exp $
d385 2
a386 2
									tmprect.MaxX = tmprect.MinX + width;
									tmprect.MaxY = tmprect.MinY + height;
@


36.11
log
@fix B4382
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.10 89/08/02 18:36:36 bart Exp $
a369 3
									short limit = maxy - (crn->bounds.MinY + height - 1); /* stay in scroll rect */
									if(( height += ((limit > 0) ? 0 : limit) ) > 0 )      /* bart -- fix B4382 */

@


36.10
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.9 89/03/28 17:32:53 bart Exp $
@


36.9
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.8 89/03/28 17:29:38 bart Exp $
d367 1
d369 4
d374 2
a375 2
							    tmprect.MinX + dx-(crn->bounds.MinX&(~15)),
							    	tmprect.MinY + dy - crn->bounds.MinY,
d377 4
a380 1
									width,height,COPY,rp->Mask,TempA);
d384 1
a384 1
    printf("trigger refresh\n");
d391 1
a391 1
							    	cw->Flags |= 0x80;
@


36.8
log
@dont add scroll damage added to smart -- bart
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.7 88/10/13 16:18:32 bart Exp $
d182 1
a182 1
		    if((cw->Flags & LAYERSIMPLE)||/* (cw->Flags & LAYERSMART)*/)
@


36.7
log
@limit scroll damage to scroll rectangle
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.6 88/10/13 15:21:45 bart Exp $
d177 6
a182 1
		    if((cw->Flags & LAYERSIMPLE) || (cw->Flags & LAYERSMART))
@


36.6
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.5 88/10/13 15:15:16 bart Exp $
d176 1
a176 1
		    /* refresh damage routine -- bart */
d179 1
a179 1
			struct Rectangle a;
d183 1
a183 1
			if(old && tmp)
d187 1
a187 5
			    /* convert bounds to region */
			    a.MinX = 0;				
			    a.MinY = 0;
			    a.MaxX = cw->bounds.MaxX - cw->bounds.MinX;
			    a.MaxY = cw->bounds.MaxY - cw->bounds.MinY;
d189 5
d208 3
a251 1
			    disposeregion(tmp);
d253 3
d262 3
@


36.5
log
@damage routine expanded to handle smart refresh layers too
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.4 88/10/13 14:04:15 bart Exp $
d264 1
a264 1
#endif
@


36.4
log
@delta damage now added to simple refresh layers when scrolling
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.3 88/10/12 18:17:45 bart Exp $
d176 2
a177 4
#define SIMPLE_SCROLL
#ifdef SIMPLE_SCROLL
		    /* simple refresh damage routine -- bart */
		    if (cw->Flags & LAYERSIMPLE)
a196 2
				    if(cr->lobs) continue;

@


36.3
log
@simple refresh windows create preliminary damage list
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.2 88/07/15 12:33:46 bart Exp $
d178 1
d183 1
a183 1
			struct Region *new = (struct Region *)NewRegion();
d185 1
a185 1
			if(old && new)
d187 2
d195 5
a199 2
			    /* initialize region to bounds */
			    orrectregion(new,&a);   
d201 1
a201 4
			    new->bounds.MinX += dx;
			    new->bounds.MaxX += dx;
			    new->bounds.MinY += dy;
			    new->bounds.MaxY += dy;
d203 4
a206 2
			    /* damage at layer boundaries */
			    xorrectregion(new,&a);  
d208 2
a209 2
			    /* add old scrolled damage */
			    orregionregion(old,new); 
d211 2
a212 4
			    new->bounds.MinX -= dx;
			    new->bounds.MaxX -= dx;
			    new->bounds.MinY -= dy;
			    new->bounds.MaxY -= dy;
d214 36
a249 1
			    /* copy back to old */
d251 2
a252 1
			    orregionregion(new,old); 
d254 8
a261 1
			    /* clip scroll damage to bounds */
d265 1
a265 1
			    cw->Flags |= LAYERREFRESH; 
@


36.2
log
@fix superbitmap bug #B3370 bart
@
text
@d3 1
a3 1
*	$Header: scrollraster.c,v 36.1 88/03/10 16:12:09 dale Exp $
d176 46
a221 21
#define AFTERB1	    /* bart - 05.08.86 - defined this back in after Beta1 */
#ifdef AFTERB1
		if (cw->Flags & LAYERSIMPLE)
		{
			/* must scroll the existing damage region */
			struct Region *r;
			struct Rectangle b;
			r = cw->DamageList;
			r->bounds.MinX += dx;
			r->bounds.MaxX += dx;
			r->bounds.MinY += dy;
			r->bounds.MaxY += dy;
			/* is the next AndRectRegion really needed?*/
/*
			b.MinX = 0;
			b.MinY = 0;
			b.MaxX = cw->bounds.MaxX - cw->Bounds.MinX;
			b.MaxY = cw->bounds.MaxY - cw->Bounds.MinY;
			AndRectRegion(r,&b);
*/
		}
@


36.1
log
@
@
text
@d3 1
a3 1
*	$Header: $
d53 1
a53 1
	UWORD	using_tmpras = FALSE;
d63 2
a64 2
	TempA = 0;
	if (dy == 0) using_tmpras = getmaxbytesperrow(rp,&TempA);
d116 1
a116 1
		if ( (height <= 0) || (width <= 0)) return;
d152 1
a152 1
            /* bart - 03.06.86 */
d154 3
a156 3
			temp_rastport = *rp;
            temp_rastport.BitMap = cw->SuperBitMap;
            temp_rastport.Layer = NULL;
d159 1
a159 1
            /* end bart - 03.06.86 */
d162 2
a163 2
			UNLOCKLAYER(cw);
			return;
d365 2
@
