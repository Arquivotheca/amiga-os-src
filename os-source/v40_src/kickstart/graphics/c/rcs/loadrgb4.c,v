head     39.3;
branch   ;
access   ;
symbols  rel39_24:39.3 rel39_18:39.3 rel39_97:39.3 rel39_90:39.3 rel39_89:39.2 rel39_82:39.2 rel39_76:39.2 rel39_71:39.2 rel39_65:39.2 rel39_64:39.2 rel39_61:39.2 rel39_60:39.2 rel39_55:39.2 rel39_52:39.2 rel39_47:39.2 rel39_39:39.2 rel39_38:39.2 rel39_37:39.2 rel39_35:39.2 rel39_34:39.2 V37_30:37.1 V37_29:37.1 V37_28:37.1 V37_27:37.1 V37_25:37.1 V37_24:37.1 V37_23:37.1 V37_22:37.1 V37_21:37.1 V37_20:37.1 V37_19:37.1 V37_17:37.1 V37_15:37.1 V37_14:37.1 V37_13:37.1 V37_12:37.1 V37_11:37.1 V37_10:37.1 V37_9:37.0 V37_8:37.0 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.27 V36_208:36.27 V36_207:36.26 V36_205:36.26 V36_203:36.26 V36_202:36.26 V36_201:36.26 V36_200:36.26 V36_199:36.26 V36_198:36.26 V36_196:36.25 V36_195:36.25 V36_194:36.25 V36_193:36.25 V36_192:36.24 V36_191:36.24 V36_190:36.24 V36_189:36.24 V36_188:36.24 V36_186:36.24 V36_185:36.24 V36_184:36.24 V36_182:36.24 V36_181:36.24;
locks    ; strict;
comment  @ * @;


39.3
date     92.09.11.15.50.05;  author chrisg;  state Exp;
branches ;
next     39.2;

39.2
date     92.01.21.13.27.45;  author chrisg;  state Exp;
branches ;
next     39.1;

39.1
date     91.10.30.15.51.02;  author chrisg;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.19.29;  author chrisg;  state Exp;
branches ;
next     37.4;

37.4
date     91.07.03.10.52.51;  author chrisg;  state Exp;
branches ;
next     37.3;

37.3
date     91.05.20.11.12.17;  author chrisg;  state Exp;
branches ;
next     37.2;

37.2
date     91.05.02.13.08.19;  author chrisg;  state Exp;
branches ;
next     37.1;

37.1
date     91.01.31.17.31.47;  author spence;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.19.46;  author spence;  state Exp;
branches ;
next     36.28;

36.28
date     91.01.07.14.27.07;  author spence;  state Exp;
branches ;
next     36.27;

36.27
date     90.12.17.17.28.58;  author spence;  state Exp;
branches ;
next     36.26;

36.26
date     90.11.09.17.14.12;  author spence;  state Exp;
branches ;
next     36.25;

36.25
date     90.10.25.10.33.53;  author spence;  state Exp;
branches ;
next     36.24;

36.24
date     90.07.31.12.33.19;  author bart;  state Exp;
branches ;
next     36.23;

36.23
date     90.07.31.10.51.58;  author bart;  state Exp;
branches ;
next     36.22;

36.22
date     90.07.27.16.58.04;  author bart;  state Exp;
branches ;
next     36.21;

36.21
date     90.06.08.09.14.55;  author bart;  state Exp;
branches ;
next     36.20;

36.20
date     90.03.28.09.11.05;  author bart;  state Exp;
branches ;
next     36.19;

36.19
date     90.03.07.16.31.50;  author bart;  state Exp;
branches ;
next     36.18;

36.18
date     89.08.22.09.35.41;  author bart;  state Exp;
branches ;
next     36.17;

36.17
date     89.04.29.15.42.01;  author bart;  state Exp;
branches ;
next     36.16;

36.16
date     89.03.20.10.09.14;  author bart;  state Exp;
branches ;
next     36.15;

36.15
date     89.02.24.19.07.53;  author bart;  state Exp;
branches ;
next     36.14;

36.14
date     89.02.24.09.43.18;  author bart;  state Exp;
branches ;
next     36.13;

36.13
date     89.02.17.22.03.48;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     89.02.15.16.32.38;  author bart;  state Exp;
branches ;
next     36.11;

36.11
date     89.02.15.16.07.19;  author bart;  state Exp;
branches ;
next     36.10;

36.10
date     89.02.14.18.22.30;  author bart;  state Exp;
branches ;
next     36.9;

36.9
date     89.02.14.10.12.44;  author bart;  state Exp;
branches ;
next     36.8;

36.8
date     89.02.01.17.52.24;  author bart;  state Exp;
branches ;
next     36.7;

36.7
date     89.02.01.11.32.14;  author bart;  state Exp;
branches ;
next     36.6;

36.6
date     89.02.01.11.23.05;  author bart;  state Exp;
branches ;
next     36.5;

36.5
date     88.09.11.14.00.15;  author bart;  state Exp;
branches ;
next     36.4;

36.4
date     88.05.02.19.02.07;  author dale;  state Exp;
branches ;
next     36.3;

36.3
date     88.05.01.23.18.47;  author dale;  state Exp;
branches ;
next     36.2;

36.2
date     88.05.18.18.31.01;  author dale;  state Exp;
branches ;
next     36.1;

36.1
date     88.03.10.16.11.50;  author dale;  state Exp;
branches ;
next     ;


desc
@@


39.3
log
@obsoleted
@
text
@/******************************************************************************
*
*	$Id: loadrgb4.c,v 39.2 92/01/21 13:27:45 chrisg Exp Locker: chrisg $
*
******************************************************************************/

OBSOLETE FILE
@


39.2
log
@ killed fetchgbase. does this file do anything anymore?
@
text
@d3 1
a3 1
*	$Id: loadrgb4.c,v 39.1 91/10/30 15:51:02 chrisg Exp Locker: chrisg $
a5 1
#define	NEWPIXELALIGN
d7 1
a7 168
#include <exec/types.h>
#include <graphics/gfx.h>
#include <graphics/view.h>
#include <graphics/copper.h>
#include <hardware/custom.h>
#include <graphics/gfxbase.h>
#include "/sane_names.h"
#include "/macros.h"
#include "c.protos"

extern struct Custom custom;

/* #define DEBUG */

#define FIRSTSPRITE 16

#define PROTOTYPE_DISPLAY
#ifdef PROTOTYPE_DISPLAY
#include "/displayinfo_internal.h"
#endif 

hedley_load(vp,p)
struct ViewPort *vp;
UWORD *p;
{
}

#ifdef VP_IN_VIEW /* { */
/* find the vp in the view, return TRUE if in view, false if not in view */

vp_in_view(view,vp)
struct View *view;
struct ViewPort *vp;
{
#ifndef VP_IN_VIEW /* { */
	return( TRUE ); /* compatibility with 1.3 !!! yuck -- bart */
#else /* }{ */
	int found = FALSE;

	if( view )
	{
		struct ViewPort *vport;
		
		for(vport = view->ViewPort; vport; vport = vport->Next)
		{
			if(vport == vp)
			{
				found = TRUE; break;
			}
		}

	}

	return(found);
#endif */ } */
}
#endif */ } */

#define DOWNLOADRGB4

#ifndef DOWNLOADRGB4
/*  load color registers, rgb values, 4 bits per gun */
/*  packed in consecutive right justified words */
loadrgb4(vp,p,cnt)
struct ViewPort *vp;
UWORD *p;
short cnt;
{
    int j;
    USHORT d;
    UWORD *c;
	struct CopList *cl;

#ifdef DEBUG
	kprintf("loadrgb4(%lx,%lx,%lx)\n",vp,p,cnt);
#endif
	if (cnt > 32)	cnt = 32;

	if (vp)
	{
		struct ColorMap *cm = vp->ColorMap;
		UWORD		 newtable[32];
		ULONG 		 modes = new_mode(vp);
		/* install in ColorMap */
		if ( cm )
		{
			if (cnt > cm->Count)	cnt = cm->Count;
			c = cm->ColorTable;
    		for (j = 0; j < cnt ; j++) *c++ = *p++;
			p -= cnt;
			/* check for special genlock modes */
			if (cm->Type && (cm->Flags & COLORMAP_TRANSPARENCY))
			{
				unsigned short *t = newtable;
				for (j = 0; j < cnt; j++)
				{
					*(t+j) = *(p+j) | check_genlock(cm,j);
				}
				p = newtable;
			}
		}
		if( (vp->ExtendedModes & VPF_A2024)
		||  (modes == A2024TENHERTZ_KEY) 
		||  (modes == A2024FIFTEENHERTZ_KEY)
		||  (modes &  SUPERHIRES) )
		{
			if(cm) hedley_load(vp,cm->ColorTable);
		}
		else
		{
			/* install in various copper lists */
			if ( (cl = vp->DspIns) != 0)
			{
				/* single thread access to ActiView hardware copper list */
				ObtainSemaphore(GBASE->ActiViewCprSemaphore);

				if ( (vp->Modes & VP_HIDE) == 0)
				{
#ifdef VP_IN_VIEW /* { */
					if( vp_in_view(GBASE->ActiView,vp) ) /* vp in active view? */
#endif /* } */
					{
					/* check if we should update the copper lists 
					 * - spence Nov  9 1990
					*/
						struct RasInfo *ri;
						struct BitMap *bm;
						int vpc = 0;

						if ((ri = vp->RasInfo) && (bm = ri->BitMap))
							vpc = (1 << (bm->Depth));

						if ((vpc == 0) || (cnt <= vpc) ||
							(vp->Modes & DUALPF))	/* if dualpf, do them all anyway */
						{
							/* hardware list */
							npokeCprList(cl->CopLStart,&custom.color[0],p,cnt);
							npokeCprList(cl->CopSStart,&custom.color[0],p,cnt);
						}
						else
						{
							npokeCprList(cl->CopLStart,&custom.color[0],p,vpc);
							npokeCprList(cl->CopSStart,&custom.color[0],p,vpc);
							if (cnt > FIRSTSPRITE)
							{
								int k;
								npokeCprList(cl->CopLStart,&custom.color[FIRSTSPRITE],(k = p + FIRSTSPRITE),(j = (cnt - FIRSTSPRITE)));
								npokeCprList(cl->CopSStart,&custom.color[FIRSTSPRITE],k,j);
							}
						}
					}
				}

				ReleaseSemaphore(GBASE->ActiViewCprSemaphore);

				/* intermediate list */
				for (j = 0; j < cnt ; j++)
			    pokeCopIns(cl->CopIns,COPPER_MOVE,&custom.color[j],*p++);
			}
		}
	}
	else for (j = 0; j < cnt ; j++)	custom.color[j] = *p++;
	update_top_color(GBASE->current_monitor);
#ifdef DEBUG
	kprintf("return from loadrgb\n");
#endif
}
#endif
@


39.1
log
@ killed a2024 stuff
@
text
@d3 1
a3 1
*	$Id: loadrgb4.c,v 39.0 91/08/21 17:19:29 chrisg Exp Locker: chrisg $
a79 2
	struct GfxBase *GB;
	FETCHGBASE;
d122 1
a122 1
				ObtainSemaphore(GB->ActiViewCprSemaphore);
d127 1
a127 1
					if( vp_in_view(GB->ActiView,vp) ) /* vp in active view? */
d161 1
a161 1
				ReleaseSemaphore(GB->ActiViewCprSemaphore);
d170 1
a170 1
	update_top_color(GB->current_monitor);
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*	$Id: loadrgb4.c,v 37.4 91/07/03 10:52:51 chrisg Exp Locker: chrisg $
a32 86
	struct CopList *cl;
	UWORD	translation[32];
	int cnt = 32;
	int j;
	int shit;
	struct GfxBase *GB;
	ULONG modes = new_mode(vp);

	FETCHGBASE;
	/* install in various copper lists */
	if( (vp->ExtendedModes & VPF_A2024)
	||  (modes == A2024TENHERTZ_KEY) 
	||  (modes == A2024FIFTEENHERTZ_KEY) )
	{
		convert_to_hedley(p,translation);
#ifdef NEWPIXELALIGN
/*		shit = 42;*/ /* bart -- fix offset into cprlist 02.24.89 */
		shit = ((GB->ChipRevBits0 & GFXF_HR_DENISE) ? 42 : 38); /* fixed again - spence Jan 31 1991 */
#else
		shit = 24;
#endif
	}
	else
	if (modes & SUPERHIRES) 
	{
		convert_to_superhires(p,translation,vp->ColorMap);
		shit = 0;
	}
#ifdef DEBUG
	kprintf("hedley_load vp =%lx input=%lx output=%lx\n",vp,
			p,translation);
	Debug();
#endif
	p = translation;
	if ( (cl = vp->DspIns) != 0)
	{
	    if ( (vp->Modes & VP_HIDE) == 0)
	    {
			/* single thread access to ActiView hardware copper list */

				ObtainSemaphore(GB->ActiViewCprSemaphore);

				/* hardware list */
				if (cl->CopLStart) npokeCprList(cl->CopLStart+shit,&custom.color[0],p,cnt);
				if (cl->CopSStart) npokeCprList(cl->CopSStart+shit,&custom.color[0],p,cnt);
				if (cl->Cop2Start) npokeCprList(cl->Cop2Start+shit,&custom.color[0],p,cnt);
				if (cl->Cop3Start) npokeCprList(cl->Cop3Start+shit,&custom.color[0],p,cnt);
				if ( (modes == A2024TENHERTZ_KEY) ||
				    ((vp->ExtendedModes & (VPF_A2024|VPF_TENHZ)) == 
			    	 (VPF_A2024|VPF_TENHZ)) )
				{
					if (cl->Cop4Start) npokeCprList(cl->Cop4Start+shit,&custom.color[0],p,cnt);
					if (cl->Cop5Start) npokeCprList(cl->Cop5Start+shit,&custom.color[0],p,cnt);
				}

				ReleaseSemaphore(GB->ActiViewCprSemaphore);
	    }
	    /* intermediate list */
	    /* skip first control color instructions */
	    /* look for color[2] info and back up 2 */
	    {
		    struct CopIns *ci;
		    ci = cl->CopIns;
		    while (1)
		    {
			    UWORD opcode;
			    UWORD target;
			    target = &custom.color[2];
			    opcode = ci->OpCode & 3;
			    if (opcode == COPPER_MOVE)
			    {
				    if (target == ci->DESTADDR)
					    break;
			    }
			    ci++;
		    }
		    ci--;
		    ci--;
		    for (j = 0; j < cnt ; j++)
			    pokeCopIns(ci,COPPER_MOVE,&custom.color[j],*p++);
	    }
	}
#ifdef DEBUG
	kprintf("after poking list\n");
	Debug();
#endif
@


37.4
log
@killed c component. now uses pokecolors stuff in asm.
@
text
@d3 1
a3 1
*	$Id: loadrgb4.c,v 37.3 91/05/20 11:12:17 chrisg Exp Locker: chrisg $
@


37.3
log
@Added prototypes, improved warnings, and glue code. still needs work.
@
text
@d3 1
a3 1
*	$Id: loadrgb4.c,v 1.1 91/05/20 10:41:47 chrisg Exp $
d152 3
d263 1
@


37.2
log
@ changed "../" to "/" for native build
@
text
@d3 1
a3 1
*	$Id: loadrgb4.c,v 37.1 91/01/31 17:31:47 spence Exp Locker: chrisg $
d16 1
@


37.1
log
@fixes hedley loadrgb4() bug with old denise (shit offset was wrong).
fixes wrong colours in dualpf mode.
@
text
@d3 1
a3 1
*	$Id: loadrgb4.c,v 37.0 91/01/07 15:19:46 spence Exp Locker: spence $
d14 2
a15 2
#include "../sane_names.h"
#include "../macros.h"
d25 1
a25 1
#include "../displayinfo_internal.h"
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*	$Id: loadrgb4.c,v 36.28 91/01/07 14:27:07 spence Exp Locker: spence $
d48 2
a49 1
		shit = 42; /* bart -- fix offset into cprlist 02.24.89 */
d224 2
a225 1
						if ((vpc == 0) || (cnt <= vpc))
@


36.28
log
@gives correct colours for cutsom vp with SPRITES
@
text
@d3 1
a3 1
*	$Id: loadrgb4.c,v 36.27 90/12/17 17:28:58 spence Exp Locker: spence $
@


36.27
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Id: loadrgb4.c,v 36.26 90/11/09 17:14:12 spence Exp Locker: spence $
d21 2
d233 1
a233 1
							if (cnt > 16)
d235 3
a237 2
								npokeCprList(cl->CopLStart,&custom.color[16],p,(j = (cnt-16)));
								npokeCprList(cl->CopSStart,&custom.color[16],p,(j));
@


36.26
log
@Fix for bug B10462 - checks the number of colours to be npokeCprList()'ed.
@
text
@d3 1
a3 1
*	$Id: loadrgb4.c,v 36.25 90/10/25 10:33:53 spence Exp Locker: spence $
d117 1
d124 1
a124 1
#ifndef VP_IN_VIEW
d126 1
a126 1
#else
d144 1
a144 1
#endif
d146 1
d155 1
a155 1
    int j, vpc;
d207 1
d209 1
d214 7
a220 1
						vpc = getvpcolours(cm);
a229 1
							npokeCprList(cl->CopLStart,&custom.color[15],p,(j = (cnt-15)));
d231 5
a235 1
							npokeCprList(cl->CopSStart,&custom.color[15],p,(j));
@


36.25
log
@checks to see if the copperlists are not NULL (after MrgCop returns an error
instead of ALERT in low memory conditions) in hedley_load().
@
text
@d3 1
a3 1
*	$Id: loadrgb4.c,v 36.24 90/07/31 12:33:19 bart Exp Locker: spence $
d153 1
a153 1
    int j;
d207 17
a223 3
						/* hardware list */
						npokeCprList(cl->CopLStart,&custom.color[0],p,cnt);
						npokeCprList(cl->CopSStart,&custom.color[0],p,cnt);
@


36.24
log
@check for special genlock modes fix
@
text
@d3 1
a3 1
*	$Id: loadrgb4.c,v 36.23 90/07/31 10:51:58 bart Exp Locker: bart $
d67 1
d69 1
a69 1
		/* single thread access to ActiView hardware copper list */
d71 12
a82 1
		ObtainSemaphore(GB->ActiViewCprSemaphore);
d84 1
a84 14
		/* hardware list */
		npokeCprList(cl->CopLStart+shit,&custom.color[0],p,cnt);
		npokeCprList(cl->CopSStart+shit,&custom.color[0],p,cnt);
		npokeCprList(cl->Cop2Start+shit,&custom.color[0],p,cnt);
		npokeCprList(cl->Cop3Start+shit,&custom.color[0],p,cnt);
		if ( (modes == A2024TENHERTZ_KEY) ||
		    ((vp->ExtendedModes & (VPF_A2024|VPF_TENHZ)) == 
		     (VPF_A2024|VPF_TENHZ)) )
		{
			npokeCprList(cl->Cop4Start+shit,&custom.color[0],p,cnt);
			npokeCprList(cl->Cop5Start+shit,&custom.color[0],p,cnt);
		}

		ReleaseSemaphore(GB->ActiViewCprSemaphore);
@


36.23
log
@fix hedley load to use cm->colortable
@
text
@d3 1
a3 1
*	$Id: loadrgb4.c,v 36.22 90/07/27 16:58:04 bart Exp Locker: bart $
d183 4
a186 1
					*t = *p | check_genlock(cm,j);
@


36.22
log
@id
@
text
@d3 1
a3 1
*	$Id: $
d191 1
a191 1
			hedley_load(vp,p);
@


36.21
log
@vp_in_view return( TRUE ); compatibility with 1.3 !!! yuck -- bart
@
text
@d3 1
a3 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/graphics/c/RCS/loadrgb4.c,v 36.20 90/03/28 09:11:05 bart Exp Locker: bart $
@


36.20
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/graphics/c/RCS/loadrgb4.c,v 36.19 90/03/07 16:31:50 bart Exp Locker: bart $
d124 3
d144 1
@


36.19
log
@check for vp_in_view 
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.18 89/08/22 09:35:41 bart Exp $
@


36.18
log
@single thread access to ActiView hardware copper list
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.17 89/04/29 15:42:01 bart Exp $
d118 25
d199 6
a204 3
					/* hardware list */
					npokeCprList(cl->CopLStart,&custom.color[0],p,cnt);
					npokeCprList(cl->CopSStart,&custom.color[0],p,cnt);
d209 3
a211 3
					/* intermediate list */
    				for (j = 0; j < cnt ; j++)
				  pokeCopIns(cl->CopIns,COPPER_MOVE,&custom.color[j],*p++);
@


36.17
log
@cm->Type checking
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.16 89/03/20 10:09:14 bart Exp $
d67 5
d84 2
d169 3
d178 3
@


36.16
log
@update_top_color(mspc)
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.15 89/02/24 19:07:53 bart Exp $
d36 2
d41 2
a42 2
	||  (new_mode(vp) == A2024TENHERTZ_KEY) 
	||  (new_mode(vp) == A2024FIFTEENHERTZ_KEY) )
d52 1
a52 1
	if (vp->Modes & SUPERHIRES) 
d72 1
a72 1
		if ( (new_mode(vp) == A2024TENHERTZ_KEY) ||
d132 3
a134 2
		struct ColorMap *cm;
		UWORD	newtable[32];
d136 1
a136 1
		if ( ( cm = vp->ColorMap) != 0)
d143 1
a143 1
			if (cm->Flags & COLORMAP_TRANSPARENCY)
d151 3
a153 3
		||  (new_mode(vp) == A2024TENHERTZ_KEY) 
		||  (new_mode(vp) == A2024FIFTEENHERTZ_KEY)
		||  (new_mode(vp) & SUPERHIRES) )
@


36.15
log
@newpixelalign fixed for hedley cprlist offset
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.14 89/02/24 09:43:18 bart Exp $
d172 1
a172 1
	update_top_color();
@


36.14
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.14 89/02/22 13:07:30 bart Exp $
d19 1
a19 1
/*#define DEBUG*/
d44 1
a44 1
		shit = 36;
d63 10
a72 1
		if ( (vp->Modes & VP_HIDE) == 0)
d74 2
a75 12
			/* hardware list */
			npokeCprList(cl->CopLStart+shit,&custom.color[0],p,cnt);
			npokeCprList(cl->CopSStart+shit,&custom.color[0],p,cnt);
			npokeCprList(cl->Cop2Start+shit,&custom.color[0],p,cnt);
			npokeCprList(cl->Cop3Start+shit,&custom.color[0],p,cnt);
			if ( (new_mode(vp) == A2024TENHERTZ_KEY) ||
			    ((vp->ExtendedModes & (VPF_A2024|VPF_TENHZ)) == 
			     (VPF_A2024|VPF_TENHZ)) )
			{
				npokeCprList(cl->Cop4Start+shit,&custom.color[0],p,cnt);
				npokeCprList(cl->Cop5Start+shit,&custom.color[0],p,cnt);
			}
d77 25
a101 24
			/* intermediate list */
		/* skip first control color instructions */
		/* look for color[2] info and back up 2 */
		{
			struct CopIns *ci;
			ci = cl->CopIns;
			while (1)
			{
				UWORD opcode;
				UWORD target;
				target = &custom.color[2];
				opcode = ci->OpCode & 3;
				if (opcode == COPPER_MOVE)
				{
					if (target == ci->DESTADDR)
						break;
				}
				ci++;
			}
			ci--;
			ci--;
    			for (j = 0; j < cnt ; j++)
				pokeCopIns(ci,COPPER_MOVE,&custom.color[j],*p++);
		}
@


36.13
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.12 89/02/15 16:32:38 bart Exp $
d39 2
a40 2
	||  (new_mode(vp) == A2024_10HZ_KEY) 
	||  (new_mode(vp) == A2024_15HZ_KEY) )
d70 1
a70 1
			if ( (new_mode(vp) == A2024_10HZ_KEY) ||
d148 2
a149 2
		||  (new_mode(vp) == A2024_10HZ_KEY) 
		||  (new_mode(vp) == A2024_15HZ_KEY)
@


36.12
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.11 89/02/15 16:07:19 bart Exp $
@


36.11
log
@displayinfo_internal
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.10 89/02/14 18:22:30 bart Exp $
d23 1
a23 1
#include "display/displayinfo_internal.h"
@


36.10
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.9 89/02/14 10:12:44 bart Exp $
d23 1
a23 1
#include <display/defines.h>
@


36.9
log
@checkpoint 02.14.89
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.8 89/02/01 17:52:24 bart Exp $
a13 1
#include <display/modes.h>
d21 5
d39 2
a40 1
	||  (new_mode(vp) == STD_MODE_14) )
d70 1
a70 1
			if ( (new_mode(vp) == STD_MODE_14) ||
d148 3
a150 2
		||  (new_mode(vp) == STD_MODE_14) ||
		    (vp->Modes & SUPERHIRES) )
@


36.8
log
@checkpoint -- a2024 10hz and 15hz scan works from 32 bit id
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.7 89/02/01 11:32:14 bart Exp $
@


36.7
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.6 89/02/01 11:23:05 bart Exp $
@


36.6
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.5 88/09/11 14:00:15 bart Exp $
d14 1
@


36.5
log
@vp->Modes & SUPERHIRES
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.4 88/05/02 19:02:07 dale Exp $
d33 2
a34 1
	if (vp->ExtendedModes & VPF_A2024)
d64 3
a66 2
			if ( (vp->ExtendedModes & (VPF_A2024|VPF_TENHZ)) ==
				(VPF_A2024|VPF_TENHZ) )
d141 3
a143 2
		if ( (vp->ExtendedModes & VPF_A2024) ||
		     (vp->Modes & SUPERHIRES) )
@


36.4
log
@More changes to support setrgb4,loadrgb4 for genlock control.
Also changed the interface to check_genlock to take a ColorMap
ptr instead of Flags and Bits. Makes it a little more general purpose
as well as all the callers a little more efficient.
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.3 88/05/01 23:18:47 dale Exp $
a20 2
#define VP_SUPER_HIRES	0x80

d43 1
a43 1
	if (vp->ExtendedModes & VP_SUPER_HIRES) 
d139 2
a140 1
		if (vp->ExtendedModes & (VPF_A2024|VPF_SUPER_HIRES))
@


36.3
log
@Additions for new amiga genlock modes.
Changes to superhires conversion routines to deal with genlock.
It should work in all modes.
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.2 88/05/18 18:31:01 dale Exp $
d44 1
a111 1
	struct ColorMap *cm;
d124 2
d133 7
@


36.2
log
@Fix for topcolor in super hires mode.
@
text
@d3 1
a3 1
*	$Header: loadrgb4.c,v 36.1 88/03/10 16:11:50 dale Exp $
d46 1
a46 1
		convert_to_superhires(p,translation);
@


36.1
log
@V36 initial check in
@
text
@d3 1
a3 1
*	$Header: $
a63 3
#ifdef QWEQWE
			if (GB->hedley_flags == 4)
#endif
a131 1
#ifdef NEW_HEDLEY
a132 3
#ifdef QWEQWE
		if (GB->hedley_flags)
#endif
a134 1
			return;
d136 1
a136 3
#endif
		/* install in various copper lists */
		if ( (cl = vp->DspIns) != 0)
d138 2
a139 1
			if ( (vp->Modes & VP_HIDE) == 0)
d141 9
a149 3
				/* hardware list */
				npokeCprList(cl->CopLStart,&custom.color[0],p,cnt);
				npokeCprList(cl->CopSStart,&custom.color[0],p,cnt);
a150 3
				/* intermediate list */
    		for (j = 0; j < cnt ; j++)
				pokeCopIns(cl->CopIns,COPPER_MOVE,&custom.color[j],*p++);
@
