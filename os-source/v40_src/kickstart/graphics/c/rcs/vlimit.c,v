head     39.2;
branch   ;
access   ;
symbols  rel39_24:39.2 rel39_18:39.1 rel39_97:39.1 rel39_90:39.1 rel39_89:39.1 rel39_82:39.1 rel39_76:39.1 rel39_71:39.1 rel39_65:39.1 rel39_64:39.1 rel39_61:39.1 rel39_60:39.1 rel39_55:39.1 rel39_47:39.1 rel39_39:39.1 rel39_38:39.1 rel39_37:39.1 rel39_35:39.1 rel39_34:39.1 V37_30:37.0 V37_29:37.0 V37_28:37.0 V37_27:37.0 V37_25:37.0 V37_24:37.0 V37_23:37.0 V37_22:37.0 V37_21:37.0 V37_20:37.0 V37_19:37.0 V37_17:37.0 V37_15:37.0 V37_14:37.0 V37_13:37.0 V37_12:37.0 V37_11:37.0 V37_10:37.0 V37_9:37.0 V37_8:37.0 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.13 V36_208:36.13 V36_207:36.13 V36_205:36.13 V36_203:36.13 V36_202:36.13 V36_201:36.13 V36_200:36.13 V36_199:36.13 V36_198:36.13 V36_196:36.13 V36_195:36.13 V36_194:36.13 V36_193:36.13 V36_192:36.13 V36_191:36.13 V36_190:36.13 V36_189:36.13 V36_188:36.13 V36_186:36.13 V36_185:36.13 V36_184:36.13 V36_182:36.13 V36_181:36.13;
locks    ; strict;
comment  @*   @;


39.2
date     93.05.06.12.12.17;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     91.10.04.16.09.04;  author chrisg;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.23.02;  author chrisg;  state Exp;
branches ;
next     37.3;

37.3
date     91.05.20.11.22.13;  author chrisg;  state Exp;
branches ;
next     37.2;

37.2
date     91.05.02.15.26.49;  author chrisg;  state Exp;
branches ;
next     37.1;

37.1
date     91.05.02.13.00.42;  author chrisg;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.21.08;  author spence;  state Exp;
branches ;
next     36.13;

36.13
date     90.07.27.17.00.30;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     90.03.28.09.13.28;  author bart;  state Exp;
branches ;
next     36.11;

36.11
date     89.03.01.13.28.26;  author bart;  state Exp;
branches ;
next     36.10;

36.10
date     88.09.13.17.01.12;  author bart;  state Exp;
branches ;
next     36.9;

36.9
date     88.09.13.11.22.02;  author bart;  state Exp;
branches ;
next     36.8;

36.8
date     88.09.13.10.26.03;  author bart;  state Exp;
branches ;
next     36.7;

36.7
date     88.09.12.12.19.18;  author bart;  state Exp;
branches ;
next     36.6;

36.6
date     88.09.11.18.13.56;  author bart;  state Exp;
branches ;
next     36.5;

36.5
date     88.09.11.17.34.48;  author bart;  state Exp;
branches ;
next     36.4;

36.4
date     88.08.12.13.17.58;  author bart;  state Exp;
branches ;
next     36.3;

36.3
date     88.08.07.16.51.02;  author bart;  state Exp;
branches ;
next     36.2;

36.2
date     88.09.01.09.36.12;  author bart;  state Exp;
branches ;
next     36.1;

36.1
date     88.08.29.10.00.30;  author bart;  state Exp;
branches ;
next     36.0;

36.0
date     88.08.26.17.08.04;  author bart;  state Exp;
branches ;
next     ;


desc
@@


39.2
log
@Replaced all references to mspc->ms_Node.xln_Library with GBASE.
@
text
@/******************************************************************************
*
*	Source Control
*	--------------
*	$Id: vlimit.c,v 39.1 91/10/04 16:09:04 chrisg Exp Locker: spence $
*
*	$Locker: spence $
*
*	$Log:	vlimit.c,v $
*   Revision 39.1  91/10/04  16:09:04  chrisg
*     used __regargs in 2 functions
*   
*   Revision 39.0  91/08/21  17:23:02  chrisg
*   Bumped
*   
*   Revision 37.3  91/05/20  11:22:13  chrisg
*   Added prototypes, improved warnings, and glue code. still needs work.
*   
 * Revision 1.1  91/05/20  10:48:40  chrisg
 * Initial revision
 * 
*   Revision 37.2  91/05/02  15:26:49  chrisg
*   had to change </macros.h> to "/macros.h"
*   
*   Revision 37.1  91/05/02  13:00:42  chrisg
*    changed "../" to "/" for native build
*   
*   Revision 37.0  91/01/07  15:21:08  spence
*   initial switchover from V36
*   
*   Revision 36.13  90/07/27  17:00:30  bart
*   id
*   
*   Revision 36.12  90/03/28  09:13:28  bart
*   *** empty log message ***
*   
*   Revision 36.11  89/03/01  13:28:26  bart
*   *** empty log message ***
*   
*   Revision 36.10  88/09/13  17:01:12  bart
*   videoscan() processing and denise backwards compatibility
*   
*   Revision 36.9  88/09/13  11:22:02  bart
*   back to maxoscan for jimm
*   
*   Revision 36.8  88/09/13  10:26:03  bart
*   normal_oscan
*   
*   Revision 36.7  88/09/12  12:19:18  bart
*   *** empty log message ***
*   
*   Revision 36.6  88/09/11  18:13:56  bart
*   undefine debug
*   
*   Revision 36.5  88/09/11  17:34:48  bart
*   better hmin, standard dimensions
*   
*   Revision 36.4  88/08/12  13:17:58  bart
*   mspc->DeniseMinDisplayColumn
*   
*   Revision 36.3  88/08/07  16:51:02  bart
*   checkpoint - assembly interface to monitorspec routines
*   
*   Revision 36.2  88/09/01  09:36:12  bart
*   now calls maxoscan subroutine
*   
*   Revision 36.1  88/08/29  10:00:30  bart
*   documentation change
*   
*   Revision 36.0  88/08/26  17:08:04  bart
*   added to rcs for updating
*   
*
******************************************************************************/

/* vlimit.c -- interrogate monitorspec and determine legalview limits */

#include <exec/types.h>
#include <exec/lists.h>
#include <graphics/gfx.h>
#include <graphics/gfxbase.h>
#include <graphics/gfxnodes.h>
#include <graphics/monitor.h>
#include <graphics/view.h>
#include "/macros.h"
#include "c.protos"

/* #define DEBUG */

#define COLORCLOCKS (mspc->total_colorclocks)

#define GRANULARITY 8
#define FETCH_MASK  (~(GRANULARITY-1))
#define DATAFETCH_MIN 0x18

/* voodoo -- for now */
#define DENISE_OFFSET 9

#define MODE_OFFSET \
( (mode & SUPERHIRES)? -2: ((mode & HIRES)? 0: 4) )

#define DENISE_TO_AGNUS(x) \
{ (x) -= DENISE_OFFSET; (x) >>= 1; (x) -= MODE_OFFSET; }

#define AGNUS_TO_DENISE(x) \
{ (x) += MODE_OFFSET; (x) <<= 1; (x) += DENISE_OFFSET; }

#define NORMALIZE_PIXELS(x) \
{ if ((mode & HIRES)||(mode & SUPERHIRES)) (x) >>= 1; \
  if (mode & SUPERHIRES) (x) >>= 1; }

#define SCALE_PIXELS(x) \
{ if ((mode & HIRES)||(mode & SUPERHIRES)) (x) <<= 1; \
  if (mode & SUPERHIRES) (x) <<= 1; }
    
/* utilities */

UWORD __regargs agnus_max( UWORD amin, UWORD clocks)
{
	UWORD amax;

	amax =  clocks - GRANULARITY;
	amax -= (((amax-(amin+2))+1)%GRANULARITY);
	amax &= ~1;
	amax += GRANULARITY;

	return(amax);
}

/* if no error, returns densise lores pixels in minX, maxX */
/* returns, rows in minY, maxY */ 

__regargs oscan( struct MonitorSpec *mspc, struct Rectangle *rect,
			UWORD mode, UWORD extra)
{ 
    LONG error = FALSE; 

    if(mspc && rect)
    {
	UWORD xmin; /* graphics minimum pixel */
	UWORD xmax; /* graphics maximum pixel */
	UWORD hmin; /* hardware minimum fetch */
	UWORD hmax; /* hardware maximum fetch */
	UWORD mask = FETCH_MASK; /* alignment */

	if (!(GBASE->ChipRevBits0 & GFXF_HR_DENISE))
	{
	    NORMALIZE_PIXELS(mask);
	}

	hmin = xmin = mspc->DeniseMinDisplayColumn;
	xmax = mspc->DeniseMaxDisplayColumn + extra;

	DENISE_TO_AGNUS(hmin);

	hmin &= mask;
	hmin =  MAX(hmin,DATAFETCH_MIN); 

	hmax =  agnus_max( hmin, COLORCLOCKS );

	AGNUS_TO_DENISE(hmin);
	AGNUS_TO_DENISE(hmax);

	rect->MinX = MAX(hmin,xmin);
	rect->MinY = mspc->min_row;
	rect->MaxX = MIN(hmax,xmax);
	rect->MaxY = mspc->total_rows;

#ifdef DEBUG
	kprintf("oscan: mspc == %lx,\n", mspc);
	kprintf("extra: %5ld,\n", extra);
	kprintf("rect minX: %5ld\n",rect->MinX);
	kprintf("rect minY: %5ld\n",rect->MinY);
	kprintf("rect maxX: %5ld\n",rect->MaxX);
	kprintf("rect maxY: %5ld\n",rect->MaxY);
#endif

    }
    else
    {
	error = TRUE;
    }

    return(error);
}

/* only the specific rectangle within the video rectangle is "legal" */
/* converted to a view relative displayclip it will display as many pixels */
/* as the hardware will allow, including any software tricks to do the job */

videoscan(struct MonitorSpec *mspc, struct Rectangle *rect, UWORD mode)
{ 
    LONG error = oscan( mspc, rect, mode, DENISE_OFFSET );

    return(error);
}

/* any noninverted display rectangle contained within maxoscan is "legal" */

maxoscan(struct MonitorSpec *mspc,struct Rectangle *rect,UWORD mode)
{ 
    LONG error = oscan( mspc, rect, mode, 0 );

    return(error);
}

/* accounts for maxoscan minus standard screen dimensions */

__regargs vlimit(struct MonitorSpec *mspc,struct Rectangle *rect,UWORD mode)
{ 
    LONG error = FALSE; 

    if(mspc && mspc->ms_maxoscan && rect )
    {
	Point size;

        size.x = GBASE->NormalDisplayColumns >> 1;
	size.y = GBASE->NormalDisplayRows;

	/* call indirect */
	error = mspc_oscan(GBASE,mspc,rect,NULL); 

	rect->MaxX = (rect->MaxX-rect->MinX)+1;
	rect->MaxY = (rect->MaxY-rect->MinY)+1;

	/* call indirect */
	mspc_scale
	(GBASE,mspc,&size.x,TO_MONITOR,&size.x);

	rect->MaxX -= size.x; /* subtract scaled standard screen dimension */
	rect->MaxY -= size.y; /* subtract scaled standard screen dimension */

	rect->MaxX = (rect->MaxX+rect->MinX)-1;
	rect->MaxY = (rect->MaxY+rect->MinY)-1;

#ifdef DEBUG
	kprintf("vlimit: mspc == %lx,\n", mspc);
	kprintf("rect minX: %5ld\n",rect->MinX);
	kprintf("rect minY: %5ld\n",rect->MinY);
	kprintf("rect maxX: %5ld\n",rect->MaxX);
	kprintf("rect maxY: %5ld\n",rect->MaxY);
#endif

    }
    else
    {
	error = TRUE;
    }

    return(error);
}

@


39.1
log
@  used __regargs in 2 functions
@
text
@d5 1
a5 1
*	$Id: vlimit.c,v 39.0 91/08/21 17:23:02 chrisg Exp Locker: chrisg $
d7 1
a7 1
*	$Locker: chrisg $
d10 3
d138 1
a138 1
    if(mspc && mspc->ms_Node.xln_Library && rect)
a139 2
	struct GfxBase *GB = mspc->ms_Node.xln_Library;

d146 1
a146 1
	if( (GB) && (!(GB->ChipRevBits0 & GFXF_HR_DENISE)) )
a214 1
	struct GfxBase *GB = mspc->ms_Node.xln_Library;
d217 2
a218 10
	if(GB)
	{
	    size.x = GB->NormalDisplayColumns >> 1;
	    size.y = GB->NormalDisplayRows;
	}
	else
	{
	    size.x = 320;
	    size.y = 200;
	}
d221 1
a221 1
	error = mspc_oscan(mspc->ms_Node.xln_Library,mspc,rect,NULL); 
d228 1
a228 1
	(mspc->ms_Node.xln_Library,mspc,&size.x,TO_MONITOR,&size.x);
@


39.0
log
@Bumped
@
text
@d5 1
a5 1
*	$Id: vlimit.c,v 37.3 91/05/20 11:22:13 chrisg Exp Locker: chrisg $
d10 3
d208 1
a208 1
vlimit(struct MonitorSpec *mspc,struct Rectangle *rect,UWORD mode)
@


37.3
log
@Added prototypes, improved warnings, and glue code. still needs work.
@
text
@d5 1
a5 1
*	$Id: vlimit.c,v 1.1 91/05/20 10:48:40 chrisg Exp $
d7 1
a7 1
*	$Locker:  $
d10 3
@


37.2
log
@had to change </macros.h> to "/macros.h"
@
text
@d5 1
a5 1
*	$Id: vlimit.c,v 37.1 91/05/02 13:00:42 chrisg Exp Locker: chrisg $
d7 1
a7 1
*	$Locker: chrisg $
d10 6
d77 1
d109 1
a109 3
UWORD agnus_max( amin, clocks )
UWORD amin;
UWORD clocks;
d124 2
a125 5
oscan( mspc, rect, mode, extra)
struct MonitorSpec *mspc;
struct Rectangle *rect;
UWORD mode;
UWORD extra;
d184 1
a184 4
videoscan(mspc,rect,mode)
struct MonitorSpec *mspc;
struct Rectangle *rect;
UWORD mode;
d193 1
a193 4
maxoscan(mspc,rect,mode)
struct MonitorSpec *mspc;
struct Rectangle *rect;
UWORD mode;
d202 1
a202 4
vlimit(mspc,rect,mode)
struct MonitorSpec *mspc;
struct Rectangle *rect;
UWORD mode;
@


37.1
log
@ changed "../" to "/" for native build
@
text
@d5 1
a5 1
*	$Id: vlimit.c,v 37.0 91/01/07 15:21:08 spence Exp Locker: chrisg $
d10 3
d70 1
a70 1
#include </macros.h>
@


37.0
log
@initial switchover from V36
@
text
@d5 1
a5 1
*	$Id: vlimit.c,v 36.13 90/07/27 17:00:30 bart Exp Locker: spence $
d7 1
a7 1
*	$Locker: spence $
d10 3
d67 1
a67 1
#include <../macros.h>
@


36.13
log
@id
@
text
@d5 1
a5 1
*	$Id: $
d7 1
a7 1
*	$Locker: bart $
d10 3
@


36.12
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/graphics/c/RCS/vlimit.c,v 36.11 89/03/01 13:28:26 bart Exp Locker: bart $
d10 3
@


36.11
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: vlimit.c,v 36.10 88/09/13 17:01:12 bart Exp $
d10 3
@


36.10
log
@videoscan() processing and denise backwards compatibility
@
text
@d5 1
a5 1
*	$Header: vlimit.c,v 36.9 88/09/13 11:22:02 bart Exp $
d10 3
@


36.9
log
@back to maxoscan for jimm
@
text
@d5 1
a5 1
*	$Header: vlimit.c,v 36.8 88/09/13 10:26:03 bart Exp $
d10 3
d82 17
a98 2
/* takes monitorspec pointer, rectangle pointer */
/* if no error, returns denise colorclocks in minX, maxX */
d101 1
a101 1
maxoscan(mspc,rect,mode)
d105 1
a107 5
    WORD mask = FETCH_MASK;      /* displaymode alignment mask */
    WORD hmin;	 		 /* hardware minimum datafetch */
    WORD hmax; 			 /* hardware maximum datafetch */
    WORD xmin;			 /* graphics minimum clock */
    WORD xmax;			 /* graphics maximum clock */
d111 1
d113 11
d125 1
a125 1
	xmax = mspc->DeniseMaxDisplayColumn;
d128 1
a128 1
	/* NORMALIZE_PIXELS(mask); */ 	/* aligned to best boundary */
d132 1
a132 4
	hmax =  COLORCLOCKS - GRANULARITY;
	hmax -= (((hmax-(hmin+2))+1)%GRANULARITY);
	hmax &= ~1;
	hmax += GRANULARITY;
d138 1
a138 1
	rect->MinY = mspc->min_row; 	/* ignore intersticial gap */ 
d143 2
a144 1
	kprintf("maxoscan: mspc == %lx,\n", mspc);
d160 26
a242 1

@


36.8
log
@normal_oscan
@
text
@d5 1
a5 1
*	$Header: vlimit.c,v 36.7 88/09/12 12:19:18 bart Exp $
d10 3
d83 1
a83 1
normal_oscan(mspc,rect,mode)
d120 1
a120 1
	kprintf("normal_oscan: mspc == %lx,\n", mspc);
d136 1
a136 1
/* accounts for normal_oscan minus standard screen dimensions */
d145 1
a145 1
    if(mspc && mspc->ms_normaloscan && rect )
@


36.7
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: vlimit.c,v 36.6 88/09/11 18:13:56 bart Exp $
d10 3
d80 1
a80 1
maxoscan(mspc,rect,mode)
d117 1
a117 1
	kprintf("maxoscan: mspc == %lx,\n", mspc);
d133 1
a133 1
/* accounts for maxoscan minus standard screen dimensions */
d142 1
a142 1
    if(mspc && mspc->ms_maxoscan && rect )
@


36.6
log
@undefine debug
@
text
@d5 1
a5 1
*	$Header: vlimit.c,v 36.5 88/09/11 17:34:48 bart Exp $
d10 3
d96 1
a96 1
	NORMALIZE_PIXELS(mask);
d139 1
a139 1
    if(mspc && mspc->ms_maxoscan && rect)
d144 10
a153 2
	size.x = GB->NormalDisplayColumns >> 1;
	size.y = GB->NormalDisplayRows;
@


36.5
log
@better hmin, standard dimensions
@
text
@d5 1
a5 1
*	$Header: vlimit.c,v 36.4 88/08/12 13:17:58 bart Exp $
d10 3
d42 1
a42 1
#define DEBUG
@


36.4
log
@mspc->DeniseMinDisplayColumn
@
text
@d5 1
a5 1
*	$Header: vlimit.c,v 36.3 88/08/07 16:51:02 bart Exp $
d10 3
d39 1
a39 1
/* #define DEBUG */
d78 1
a78 1
    WORD hmin = DATAFETCH_MIN;	 /* hardware minimum datafetch */
d86 1
a86 1
	xmin = mspc->DeniseMinDisplayColumn;
d88 2
a89 1
 
a90 1

d92 1
d97 1
d135 6
d148 2
a149 2
	mspc_transform
	(mspc->ms_Node.xln_Library,mspc,&rect->MaxX,FROM_MONITOR,&rect->MaxX);
d151 2
a152 2
	rect->MaxX -= 320; /* subtract standard screen dimension */
	rect->MaxY -= 200; /* subtract standard screen dimension */
d154 2
a155 6
	/* call indirect */
	mspc_transform
	(mspc->ms_Node.xln_Library,mspc,&rect->MaxX,TO_MONITOR,&rect->MaxX);

	rect->MaxX = (rect->MaxX+rect->MinX);
	rect->MaxY = (rect->MaxY+rect->MinY);
@


36.3
log
@checkpoint - assembly interface to monitorspec routines
@
text
@d5 1
a5 1
*	$Header: vlimit.c,v 36.2 88/09/01 09:36:12 bart Exp $
d10 3
d48 1
a48 1
( (mode & SUPERHIRES)? -4: ((mode & HIRES)? 0: 4) )
d57 2
a58 1
{ if ((mode & HIRES)||(mode & SUPERHIRES)) (x) >>= 1; };
d61 2
a62 1
{ if ((mode & HIRES)||(mode & SUPERHIRES)) (x) <<= 1; };
a81 1
	xmin = ((struct GfxBase *)mspc->ms_Node.xln_Library)->MinDisplayColumn;
d83 1
d90 3
a92 3
	hmax = ((COLORCLOCKS - GRANULARITY) & FETCH_MASK);
	hmax -= ((hmin) & ~FETCH_MASK) & mask;
	hmax += GRANULARITY;
d98 2
a99 2
	rect->MinY = mspc->min_row; /* ignore intersticial gap for now */ 
	rect->MaxX = xmax;
@


36.2
log
@now calls maxoscan subroutine
@
text
@d5 1
a5 1
*	$Header: vlimit.c,v 36.1 88/08/29 10:00:30 bart Exp $
d10 3
d125 2
a126 1
	error = (*mspc->ms_maxoscan)(mspc,rect,NULL); /* call indirect */
d131 3
a133 1
	(*mspc->ms_transform)(mspc,&rect->MaxX,FROM_MONITOR,&rect->MaxX);
d138 3
a140 1
	(*mspc->ms_transform)(mspc,&rect->MaxX,TO_MONITOR,&rect->MaxX);
@


36.1
log
@documentation change
@
text
@d5 1
a5 1
*	$Header: vlimit.c,v 36.0 88/08/26 17:08:04 bart Exp $
d10 3
a33 3
#define MAX_DENISE \
((mspc->BeamCon0&LOLDIS)?((COLORCLOCKS+1)<<1):((COLORCLOCKS+1)<<1)+1)

d60 1
a60 2
vlimit(GB,mspc,rect,mode)
struct GfxBase *GB;
d72 1
a72 1
    if(GB && mspc && rect)
d74 3
a76 3
	xmin = GB->MinDisplayColumn; 		
	xmax = GB->MaxDisplayColumn; 		
	xmax = MIN(xmax,MAX_DENISE);
d94 30
d129 2
a130 2
	rect->MaxX -= 320;
	rect->MaxY -= 200;
@


36.0
log
@added to rcs for updating
@
text
@d5 1
a5 1
*	$Header: $
d7 1
a7 1
*	$Locker: $
d9 4
a12 1
*	$Log: $
d57 1
a57 1
/* if no error, returns lores pixels in minX, maxX */
@
