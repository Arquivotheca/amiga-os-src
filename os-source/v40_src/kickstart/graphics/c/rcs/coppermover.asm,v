head     39.20;
branch   ;
access   ;
symbols  rel39_24:39.19 rel39_18:39.18 rel39_97:39.12 rel39_90:39.12 rel39_89:39.12 rel39_82:39.11 rel39_76:39.9 rel39_71:39.8 rel39_65:39.8 rel39_64:39.8 rel39_61:39.8 rel39_60:39.7 rel39_55:39.6 rel39_52:39.6 rel39_47:39.6 rel39_39:39.5 rel39_38:39.5 rel39_37:39.5 rel39_35:39.5 rel39_34:39.5 V37_33:37.1 V37_32:37.1 V37_31:37.1 V37_30:37.1 V37_29:37.1 V37_28:37.1 V37_27:37.1 V37_25:37.1 V37_24:37.1 V37_23:37.1 V37_22:37.1 V37_21:37.1 V37_20:37.1 V37_19:37.1 V37_17:37.1 V37_15:37.1 V37_14:37.1 V37_13:37.1 V37_12:37.1 V37_11:37.1 V37_10:37.1 V37_9:37.1 V37_8:37.1 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.6 V36_208:36.6 V36_207:36.6 V36_205:36.6 V36_203:36.6 V36_202:36.6 V36_201:36.6 V36_200:36.6 V36_199:36.6 V36_198:36.6 V36_196:36.6 V36_195:36.6 V36_194:36.6 V36_193:36.6 V36_192:36.6 V36_191:36.6 V36_190:36.5 V36_189:36.5 V36_188:36.5 V36_186:36.4 V36_185:36.4 V36_184:36.4 V36_182:36.4 V36_181:36.4;
locks    ; strict;
comment  @@;


39.20
date     93.08.11.15.29.18;  author spence;  state Exp;
branches ;
next     39.19;

39.19
date     93.05.05.15.34.34;  author spence;  state Exp;
branches ;
next     39.18;

39.18
date     93.03.31.16.42.11;  author spence;  state Exp;
branches ;
next     39.17;

39.17
date     93.03.29.11.25.23;  author spence;  state Exp;
branches ;
next     39.16;

39.16
date     93.02.24.17.00.36;  author spence;  state Exp;
branches ;
next     39.15;

39.15
date     93.02.22.10.19.23;  author spence;  state Exp;
branches ;
next     39.14;

39.14
date     93.02.09.15.27.27;  author spence;  state Exp;
branches ;
next     39.13;

39.13
date     92.12.05.17.11.33;  author spence;  state Exp;
branches ;
next     39.12;

39.12
date     92.08.27.12.13.17;  author spence;  state Exp;
branches ;
next     39.11;

39.11
date     92.08.17.17.05.59;  author spence;  state Exp;
branches ;
next     39.10;

39.10
date     92.08.06.11.28.40;  author spence;  state Exp;
branches ;
next     39.9;

39.9
date     92.07.09.12.08.26;  author spence;  state Exp;
branches ;
next     39.8;

39.8
date     92.06.03.16.33.02;  author chrisg;  state Exp;
branches ;
next     39.7;

39.7
date     92.04.28.15.34.42;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     92.03.13.15.44.25;  author spence;  state Exp;
branches ;
next     39.5;

39.5
date     92.02.04.17.22.34;  author spence;  state Exp;
branches ;
next     39.4;

39.4
date     92.01.29.16.46.03;  author spence;  state Exp;
branches ;
next     39.3;

39.3
date     91.11.26.16.32.06;  author spence;  state Exp;
branches ;
next     39.2;

39.2
date     91.11.25.15.58.12;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     91.11.14.16.44.27;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.16.09;  author chrisg;  state Exp;
branches ;
next     37.1;

37.1
date     91.01.30.17.15.07;  author bart;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.27.16;  author spence;  state Exp;
branches ;
next     36.6;

36.6
date     90.10.11.13.23.13;  author spence;  state Exp;
branches ;
next     36.5;

36.5
date     90.10.08.13.18.41;  author bart;  state Exp;
branches ;
next     36.4;

36.4
date     90.07.27.16.55.50;  author bart;  state Exp;
branches ;
next     36.3;

36.3
date     90.07.20.22.28.15;  author bart;  state Exp;
branches ;
next     36.2;

36.2
date     90.03.28.09.09.20;  author bart;  state Exp;
branches ;
next     36.1;

36.1
date     88.03.10.16.12.25;  author dale;  state Exp;
branches ;
next     ;


desc
@@


39.20
log
@cl_Flags -> cl_PrivateFlags
@
text
@*******************************************************************************
*
*	$Id: coppermover.asm,v 39.19 93/05/05 15:34:34 spence Exp Locker: spence $
*
*******************************************************************************

	section graphics

V1_3	EQU	1		; for copper.i

	include 'exec/types.i'
	include	'exec/alerts.i'
	include "/copper.i"
	include "/view.i"
	include "/gfxbase.i"
	include "/monitor.i"
	include "/display.i"
	include	"/macros.i"
	include	'hardware/custom.i'

	xdef _coppermover

	STRUCTURE copstuff,0
		APTR	cs_first
		APTR	cs_copptr
		APTR	cs_copIptr
		UWORD	cs_maxins
		UWORD	cs_beamx
		UWORD	cs_beamy
		UWORD	cs_flags
		UWORD	cs_cnt
		UWORD	cs_icnt
		UWORD	cs_DyOffset
		UWORD	cs_moreflags
		APTR	cs_fcopptr
		APTR	cs_cop2ptr
		APTR	cs_cop3ptr
		APTR	cs_cop4ptr
		APTR	cs_cop5ptr
	        UWORD	cs_cnt2
	        UWORD	cs_cnt3
	        UWORD	cs_cnt4
	        UWORD	cs_cnt5
		LONG cs_ratioh
		UWORD cs_colorclocks
		SHORT cs_ibeamx
		SHORT cs_ibeamy
		ULONG	cs_topline
		UWORD	cs_thisbeamy
		UWORD	cs_origbeamy
		UWORD	cs_totalrows
	LABEL	cs_SIZEOF

nCPR_NT_LOF	equ 15
nCPR_NT_SHT	equ 14

nCPR_NT_2	equ 13
nCPR_NT_3	equ 12
nCPR_NT_4	equ 11
nCPR_NT_5	equ 10

*	ensure that ci_Opcode is offset 0
	ifne	ci_OpCode
		fail
	endc

*DODEBUG	EQU	1

	IFD	DODEBUG
D	MACRO
	tst.b	gb_Debug(a6)
	beq.s	dbg\@@
	print	\1
dbg\@@
	ENDM
DR	MACRO
	tst.b	gb_Debug(a6)
	beq.s	dbg\@@
	dbug	\1
dbg\@@
	ENDM
DRW	MACRO
	tst.b	gb_Debug(a6)
	beq.s	dbg\@@
	dbugw	\1
dbg\@@
	ENDM

	ELSE

D	MACRO
	ENDM
DR	MACRO
	ENDM
DRW	MACRO
	ENDM

	ENDC

_coppermover:
* coppermover(copstuff,c)
*	needs copstuff (co
	movem.l	4(sp),a0/a1	* get copstuff,c

	move.w	(a1),d1		* ci_OpCode(a1)
	D	"coppermover, c = "
	DR	a1
	D	"instruction = "
	DRW	d1
	move.w	d1,d0
	and.w	#3,d0
*	assume COPPER_MOVE is a NULL
	if =
* some commonly used constants
		movem.l	d2/d3/d4/a2/a3,-(sp)
		move.l	#$1feffff,d2
		moveq	#3,d3
		moveq	#nCPR_NT_SHT,d4

		movem.l	cs_copptr(a0),a2/a3	* and copIptr
		addq.l	#2,a1			* preoffset
		if #0=a3.w
			repeat
*				get and convert move instruction
				move.l (a1)+,d0		* ci_DestAddr(a1)
				and.l	d2,d0

*				which list to put it in?
				btst	d4,d1
				if =
					move.l	d0,(a2)+
				endif

				move.w	(a1)+,d1	* ci_OpCode(a1)
				move.w	d1,d0
				and.w	d3,d0
			until <>
		else
			btst.b	#1,cs_moreflags+1(a0)
			if =
				repeat
*					get and convert move instruction
					move.l (a1)+,d0		* ci_DestAddr(a1)
					and.l	d2,d0
	
*					which list to put it in?
					btst	d4,d1
					if =
						move.l	d0,(a2)+
					endif
					btst	#nCPR_NT_LOF,d1
					if = 
						move.l	d0,(a3)+
					endif
	
					move.w	(a1)+,d1	* ci_OpCode(a1)
					move.w	d1,d0
					and.w	d3,d0
				until <>
			else
				repeat
*					get and convert move instruction
					move.l (a1)+,d0		* ci_DestAddr(a1)
					and.l	d2,d0
	
*					which list to put it in?
					btst	d4,d1
					if =
						move.l	d0,(a2)+
					endif
					btst	#nCPR_NT_LOF,d1
					if = 
						move.l	d0,(a3)+
					endif
	
					move.w	(a1)+,d1	* ci_OpCode(a1)
					move.w	d1,d0
					and.w	d3,d0
				until <>
			endif
		endif
		subq.l	#2,a1			* move back again
		movem.l	a2/a3,cs_copptr(a0)	* put updated values back
		movem.l	(sp)+,d2/d4/d3/a2/a3
	endif
	move.l	a1,d0			* return value
	rts

*----------------------------------------------------------------------------*
*
* The following is copied from do_wait.asm, so that only one copy of
* the assembler structure copstuff needs to be defined.
*
* spence Wed Oct  3 10:14:52 1990
*
*----------------------------------------------------------------------------*

*******************************************************************************
*
*   A downcoded version of the do_wait function in /c/copper.c
*
*   All variables are converted to registers wherever possible, rather than
*   use the stack.
*
*   a0 -> cs   CopStuff              d0:32 = scratch
*   a1 -> c    CopIns                d1:32 = scratch
*   a2 -> cl   CopList               d2:16 = ov_flow
*   a3 -> mspc MonitorSpec           d3:16 = v_waitpos_rel
*   a4 -> bmx                        d4:16 = tot_rows and v_waitpos_abs
*   a5 -> bmy                        d5:16 = min_ytop
*   a6 -> GfxBase                    d6:16 = h_waitpos
*   a7 -> stack                      d7:16 = v_waitpos
*
*******************************************************************************

COPPERVPOS_OVERFLOW equ 1
COPPERIVPOS_OVERFLOW equ	8
STRADDLES_256	equ	VPXB_STRADDLES_256
STRADDLES_512	equ	VPXB_STRADDLES_512
WHOLE_LINE equ	64

DC_HWAIT equ 1
*DONT_USE_DOWAIT equ	1

	IFND	DC_HWAIT
	xref	_get_hwait_hack
	ENDC
	xref	_new_mode
	xref	_custom

	IFD		DC_HWAIT
	xdef	_get_hwait_hack
	ENDC
	IFND	DONT_USE_DOWAIT
	xdef	_do_wait

MAKE_DY_POS	MACRO
	ENDM

CLIP_VPOS MACRO
	tst.w	\1
	bpl	\@@cvp
	moveq	#0,\1
\@@cvp:
	ENDM

_do_wait:
	movem.l	a2-a6/d2-d7,-(sp)
	movem.l	4+4*11(sp),a0-a3	; cs, c, cl, mspc
	moveq.l	#0,d2			; ov_flow  (upper word is skip value)
					; skip == FALSE, top word d2 is positive

	D	10
	D	"_do_wait() *** cs, c, cl, mspc, vp = "
	DR	a0
	DR	a1
	DR	a2
	DR	a3
	DR	cl__ViewPort(a2)
	move.w	cs_beamy(a0),cs_origbeamy(a0)
	move.w	ms_total_rows(a3),d4	; tot_rows
	subq.w	#1,d4
	move.w	d4,cs_totalrows(a0)
	addq.w	#1,d4

*		a3 can now be used as scratch.

	move.w	ci_VWaitPos(a1),d7	; v_waitpos
	move.l	cl__ViewPort(a2),a4
	move.w	vp_DyOffset(a4),d0
	MAKE_DY_POS	d0
	add.w	d0,d7

	movem.l	a0-a1,-(sp)
	move.l	a4,-(sp)
	jsr	_new_mode
	addq.l	#4,sp
	movem.l	(sp)+,a0-a1
	D	"modes in d0 = "
	DRW	d0
	btst.b	#2,d0		; LACE?
	if <>
		addq.w	#1,d7
		asr.w	#1,d7
	endif
	btst.b	#3,d0		; DOUBLESCAN
	if <>
		add.w	d7,d7
		btst.b	#1,cl_PrivateFlags+1(a2)	; HALF_LINE ?
		beq.s	100$
		addq.w	#1,d7
100$:
	endif
	add.w	cs_DyOffset(a0),d7
	D	"ci_VWaitVPos "
	DRW	ci_VWaitPos(a1)
	D	"cs_DyOffset = "
	DRW	cs_DyOffset(a0)
	D	"vp->DyOffset = "
	DRW	vp_DyOffset(a4)
	D	"clipping d7 = "
	DRW	d7
	CLIP_VPOS d7

	move.w	gb_system_bplcon0(a6),d0
	andi.w	#(GENLOCK_AUDIO+GENLOCK_VIDEO),d0
	if <>
		subq.w	#1,d4
	endif
	if	d7.w >= d4.w
		move.w	d4,d7
		subq.w	#1,d7
		cmp.w	#255,d7
		bge.s	fuckit
		D	"Whoops! d7 < 255. d7 == "
		DRW	d7
		move.w	#255,d7		; terminate the copperlist for
					; monitors with less than 255 total_rows
fuckit:
	endif

HIGHESTLINE equ	$500

	moveq	#0,d6
	move.l	cs_topline(a0),d6
	addq.l	#1,d6			; is it -1?
	bne.s	nottopline
	moveq	#0,d6
	move.w	d7,d6
	asl.l	#8,d6
	cmp.l	#HIGHESTLINE,d6
	bhi.s	use_d6
	move.l	#HIGHESTLINE,cs_topline(a0)
	move.w	#(HIGHESTLINE>>8),d7
	D	"use HIGHESTLINE "
	bra.s	nottopline
use_d6:
	move.l	d6,cs_topline(a0)
nottopline:

* d4:16 can now be used for v_waitpos_abs

	move.w	ci_HWaitPos(a1),d6	; h_waitpos
	move.w	d7,d4		; v_waitpos_abs
	move.w	d7,d3		; v_waitpos_rel

	move.b	gb_ChipRevBits0(a6),d0
	and.b	#GFXF_HR_DENISE,d0
	bne.s	cow
	btst.b	#nCPR_NT_LOF-8,ci_OpCode(a1)
	bne.s	cow
	btst.b	#nCPR_NT_SHT-8,ci_OpCode(a1)
	bne.s	cow
	cmp.w	cs_ibeamy(a0),d4
	bne.s	6$
	cmp.w	cs_ibeamx(a0),d6
	bne.s	6$
	swap 	d2
	move.w	#-1,d2 		; skip == TRUE, upper word of d2 is negative
	swap 	d2
	bra.s	cow
6$	move.w	cs_moreflags(a0),d1
	and.w	#COPPERVPOS_OVERFLOW,d1
	beq.s	cow
	cmpi.w	#255,cs_ibeamy(a0)
	bgt.s	cow
	cmpi.w	#255,d7
	ble.s	cow

	bset.b	#nCPR_NT_LOF-8,ci_OpCode(a1)
	movem.l	a0-a3,-(sp)
	D	"call self for short frame "
	jsr	_do_wait		; call self for short frame
	movem.l	(sp)+,a0-a3
	bclr.b	#nCPR_NT_LOF-8,ci_OpCode(a1)

	bset.b	#nCPR_NT_SHT-8,ci_OpCode(a1)
	movem.l	a0-a3,-(sp)
	D	"call self for long frame "
	jsr	_do_wait		; call self for long frame
	movem.l	(sp)+,a0-a3
	bclr.b	#nCPR_NT_SHT-8,ci_OpCode(a1)

	bra   	do_wait_bye

cow:
	D	"cow "
 	lea	cs_beamx(a0),a4	; bmx
	lea	cs_beamy(a0),a5	; bmy

	btst.b	#nCPR_NT_LOF-8,ci_OpCode(a1)
	if <>
		D	"ibeam "
		lea		cs_ibeamx(a0),a4	; bmx
		lea		cs_ibeamy(a0),a5	; bmy
	endif

	D	"Check line 255. d7 = "
	DRW	d7
	if #255 < d7.w	.extend
		* If the previous ViewPort's IVG straddled line 256, then
		* don't bother with the rest of this shit. Only do this for
		* AA machines though, as on ECS, the forced IVG of 3 lines is
		* more than needed, so the extra WAIT is necessary.
		btst.b	#STRADDLES_256,cs_moreflags+1(a0)
		beq.s	no_straddles
		D	"straddles "
		move.b	gb_ChipRevBits0(a6),d0
		and.b	#GFXF_AA_LISA,d0
		beq.s	no_straddles
		* save ourselves some grief later
		* Shit. I *really* hate this code.
		move.w	d7,d0
		sub.w	#256,d0
		cmp.w	(a5),d0
		bne.s	2$
		add.w	#256,(a5)
2$:
		* If d7 >512 and the previous ViewPort straddled line 512
		* we don't want an extra WAIT(255, xx)
		* This only applies to the DblPAL monitor, which is the only
		* one with >512 lines!
		cmp.w	#512,d7
		blt.s	1$
		btst.b	#STRADDLES_512,cs_moreflags+1(a0)	
		beq.s	1$
		move.w	#2,d2
		sub.w	#256,d3
		bra	dont_do_fw
1$:
		move.w	#1,d2
		bra	dont_do_fw
no_straddles:
		move.b	gb_ChipRevBits0(a6),d0
		and.b	#GFXF_HR_DENISE,d0
		beq.s	4$
		move.w	(a5),d0
		if #255 <> d0.w
4$:			move.w	#255,d7
			if d7.w <> d6.w
				D	"d7 <> d6 "
				DRW	d7
				DRW	d6
				move.w	#1,d2
				move.w	cs_moreflags(a0),d1
				btst.b	#nCPR_NT_LOF-8,ci_OpCode(a1)
				bne.s	1$
				and.w	#COPPERVPOS_OVERFLOW,d1
				bra.s	2$
1$:				and.w	#COPPERIVPOS_OVERFLOW,d1
2$:				beq.s	3$
				move.w	(a5),d0
				and.w	#$FF00,d0
				sub.w	d0,d3
				bra	vpos_overflow
3$:
				D	"wanker "
				move.w	d4,cs_thisbeamy(a0)
				IFND	DC_HWAIT
				move.l	a1,-(sp)
				move.l	a0,-(sp)
				jsr		_get_hwait_hack
				move.l	(sp)+,a0
				move.l	(sp)+,a1
				ENDC
				IFD	DC_HWAIT
				jsr		_get_hwait_hack
				ENDC
				move.w	d0,d6
			endif
		else
			if #255 <> d6.w
				D	"bollox "
				move.w	#1,d2
				bra	vpos_overflow
			else
				D	"tosspot "
				move.w	#255,d7
			endif
		endif
	endif

finish_wait:
	D	"finish_wait. (a4) (a5) d6 d7 d2.l "
	DRW	(a4)
	DRW	(a5)
	DRW	d6
	DRW	d7
	DR	d2
	cmp.w	#-1,d6		; error from get_hwait_hack()
	beq	dont_do_fw
	cmp.w	(a4),d6
	bne.s	do_fw
	cmp.w	(a5),d7
	beq	dont_do_fw
do_fw:
	D	"do_fw "
	tst.w	d2
	beq.s	do_fw1
	move.w	(a5),d0
	cmp.w	#255,d0
	bne.s	do_fw1
	cmp.w	(a4),d6
	ble.s	dont_do_fw1
do_fw1:
	D	"do_fw1"
	IFD		COPPERDEBUG
	subq.w	#1,cs_cnt(a0)
	bmi		AlertItL
	ENDC
	move.w	d6,d0
	and.w	#$FE,d0
	move.w	d7,d1
	asl.w	#8,d1
	or.w	d0,d1
	or.w	#COPPER_WAIT,d1
	swap	d1
	move.w	#$FFFE,d1	; d1.l = temp
	btst.b	#nCPR_NT_LOF-8,ci_OpCode(a1)
	if = .extend
		move.l	cs_copptr(a0),a3
		move.l	d1,(a3)+
		move.l	a3,cs_copptr(a0)
		D	"do_fw1 d4 d6 = "
		DRW	d4
		DRW	d6
		move.w	d4,(a5)
		move.w	d6,(a4)
		btst.b	#nCPR_NT_SHT-8,ci_OpCode(a1)
		if =
			D	"ibeam "
			move.w	d4,cs_ibeamy(a0)
			move.w	d6,cs_ibeamx(a0)
		endif
	endif
	
	move.w	cs_flags(a0),d0
	and.w	#INTERLACE,d0
	beq.s	dont_do_fw
do_fw2:
	D	"do_fw2 "
	IFD		COPPERDEBUG
	subq.w	#1,cs_icnt(a0)
	bmi		AlertItS
	ENDC
	btst.b	#nCPR_NT_SHT-8,ci_OpCode(a1)
	if =
		D	"d2 = "
		DR	d2
		tst.l	d2	; test UPPER word of d2 -- skip if negative
		blt.s	1$
		move.l	cs_copIptr(a0),a3
		move.l	d1,(a3)+
		move.l	a3,cs_copIptr(a0)
1$		move.w	d4,(a5)
		move.w	d6,(a4)
	endif
dont_do_fw1:
	D	"dont_do_fw1 "
	cmpi.w	#1,d2
	bne.s	1$
	cmpi.w	#255,(a5)
	bne.s	1$
	move.w	#2,d2
1$ 	move.w	d4,(a5)
dont_do_fw:
	D	"dont_do_fw. d2 d3 d4 = "
	DRW	d2
	DRW	d3
	DRW	d4
	tst.w	d2
	if <>
		sub.w	#256,d3
vpos_overflow:
		btst.b	#nCPR_NT_LOF-8,ci_OpCode(a1)
		if =
			D	"frog "
			or.w	#COPPERVPOS_OVERFLOW,cs_moreflags(a0)
			btst.b	#nCPR_NT_SHT-8,ci_OpCode(a1)
			if =
				D	"goat "
				or.w	#COPPERIVPOS_OVERFLOW,cs_moreflags(a0)
			endif
		else
			D	"donkey "
			or.w	#COPPERIVPOS_OVERFLOW,cs_moreflags(a0)
		endif
		move.w	d3,d7

		move.w	d4,cs_thisbeamy(a0)
		if #256 > d7.w
			D	"#256 > d7.w "
			cmpi.w 	#2,d2
			bne.s	1$
			cmp.w	(a5),d4
			bne.s	1$
			cmp.w	cs_totalrows(a0),d4
			beq.s	1$		; we have already clipped to total_rows
			IFND	DC_HWAIT
			move.l	a1,-(sp)
			move.l	a0,-(sp)
			jsr		_get_hwait_hack
			move.l	(sp)+,a0
			move.l	(sp)+,a1			
			ENDC
			IFD	DC_HWAIT
			jsr		_get_hwait_hack
			ENDC
			move.w	d0,d6
			cmp.w	ci_HWaitPos(a1),d6
			blt.s	1$
			add.w	#256,d3
			move.w	#255,d7
			move.w	#3,d2
			bra.s	2$
1$ 			move.w	ci_HWaitPos(a1),d6
			move.w	#0,d2
2$
		else
			IFND	DC_HWAIT
			move.l	a1,-(sp)
			move.l	a0,-(sp)
			jsr		_get_hwait_hack
			move.l	(sp)+,a0
			move.l	(sp)+,a1			
			ENDC
			IFD	DC_HWAIT
			jsr		_get_hwait_hack
			ENDC
			move.w	d0,d6
			move.w	#255,d7
		endif
		bra	finish_wait
	endif

do_wait_bye:
	movem.l	(sp)+,a2-a6/d2-d7
	rts

	IFD		COPPERDEBUG
_LVOAlert equ	-108

AlertItL:
	ALERT	AN_LongFrame
	bra	do_wait_bye

AlertItS:
	ALERT	AN_ShortFrame
	bra	do_wait_bye
	ENDC

	ENDC

*******************************************************************************
*
*   A downcoded version of the get_hwait_hack function in /c/copper.c
*
*   All variables are converted to registers wherever possible, rather than
*   use the stack.
*
*   a0 -> cs   CopStuff              d0:32 = scratch
*   a1 -> c    CopIns                d1:32 = scratch
*   a2 -> cl   CopList               d2:32 = scratch
*   a3 -> variables on stack         d3 = first
*   a4 -> state jump table           d4 = second
*   a5 -> hackptr                    d5 = maxcount
*   a6 -> GfxBase                    d6 = target
*   a7 -> stack                      d7 = state
*
*   Enters with a0/a1/a6 set up.
*   do_wait() also sets up d3.w and d4.w. d4 is the YWwaitPos of this ViewPort,
*   and d3 keeps track of the number of consecutive WAITs. The true Y position
*   of this wait is ((d4.w - d3.w) + 0xff).
*
*   Returns value in d0:16, == -1 if the WAIT on line 255 should be skipped.
*
*******************************************************************************


	IFD		DC_HWAIT
	STRUCTURE hwaitstuff,0
		UWORD	hw_dafstrt
		UWORD	hw_dafstop
		UWORD	hw_diwhigh
		UWORD	hw_diwstop
		UWORD	hw_diwstrt
		UWORD	hw_bplcon0
		UWORD	hw_bovp
		UWORD	hw_tovp
		UWORD	hw_hmax
		UWORD	hw_oldbplcon0
		UWORD	hw_granularity
		UWORD	hw_granularity1
		UWORD	hw_fmode
		UWORD	hw_YWait
	LABEL	hwait_sizeof

STATE0	equ	0
STATE1	equ	(STATE0+4)
STATE2	equ	(STATE1+4)
STATE3	equ	(STATE2+4)
STATE4	equ	(STATE3+4)
STATE5	equ	(STATE4+4)
STATE6	equ	(STATE5+4)
STATE7	equ	(STATE6+4)

HWAIT	equ	222
GRANULARITY equ	8
FETCH_MASK equ	$FFFC

	xref	lmult
	xref	_CalcFMode

HFIX	MACRO
	move.l	a0,-(sp)	; if HFIX is used more than once, save a0 elsewhere for speed
	move.l	cs_ratioh(a0),d1
	jsr	lmult		; d0.l = (d1.l * d0.l)
	asr.l	#4,d0
	move.l	(sp)+,a0
	ENDM

* {
_get_hwait_hack:
	IFD	DONT_USE_DOWAIT
	movem.l	4(sp),a0/a1		; from C source
	ENDC
	movem.l	a2-a6/d2-d7,-(sp)
	sub.l	#hwait_sizeof,sp
	move.l	sp,a3

	move.w	#GRANULARITY,hw_granularity(a3)
	move.w	#GRANULARITY-1,hw_granularity1(a3)
	moveq	#0,d0
	move.l	d0,(a3)		; dafstrt, dafstop
	move.l	d0,hw_diwhigh(a3)	; and diwstop
	move.l	d0,hw_diwstrt(a3)	; and bplcon0
	move.l	d0,hw_bovp(a3)		; and tovp
	move.l	d0,hw_hmax(a3)		; and oldbplcon0
	move.l	d0,hw_fmode(a3)		; and hw_VYPosFlag
	move.w	d0,hw_YWait(a3)

	move.w	#$ff00,d0
	and.w	d0,d3
	and.w	d0,d4
	sub.w	d3,d4			; which block number?
	add.w	#$ff,d4
	move.w	d4,hw_YWait(a3)		; the true y WAIT value 
	move.w	cs_thisbeamy(a0),d7
	move.w	cs_origbeamy(a0),d5
	and.w	d0,d7
	and.w	d0,d5
	sub.w	d5,d7
	cmp.w	#$200,d7
	bge.s	ret_hwait		; this WAIT should be max-X as another WAIT
					; is immediately following (eg line 512).

	moveq	#STATE1,d7		; starting state
	lea	state_table(pc),a4	; jump table
	move.l	cs_copptr(a0),d5
	move.l	d5,a5			; hackptr
	sub.l	cs_fcopptr(a0),d5
	asr.l	#2,d5			; d5:16 = maxcount

	move.b	gb_ChipRevBits0(a6),d0
	and.b	#(GFXF_HR_DENISE|GFXF_AA_LISA),d0
	if =			; Old A Chips.
		move.l	#_custom+bplcon0,d6
		moveq	#STATE6,d7
	else
		btst.b	#GFXB_AA_LISA,d0
		if = 		; ECS chips
			move.l	#_custom+diwhigh,d6
		else
			move.l	#_custom+fmode,d6
			moveq	#STATE7,d7
		endif
	endif
	and.l	#$1FE,d6		; d6:16 = target
	D	"First state = "
	DR	d7
	D	"First target = "
	DR	d6

while_loop:
	tst.w	d5
	beq.s		end_while
	subq.w	#1,d5
	move.w	-(a5),d4		; second
	move.w	-(a5),d3		; first
	if d3.w = d6.w
		jmp	0(a4,d7.w)	; jump into the appropriate switch
	endif
	bra		while_loop

end_while:
ret_hwait:
	moveq	#0,d0
	move.w	cs_colorclocks(a0),d0
	D	"ret_hwait d0 = "
	DRW	d0
	subq.w	#4,d0
	and.w	#$fffe,d0

hwait_rts:
	D	"hwait_rts, d0 = "
	DR	d0

	add.w	#hwait_sizeof,sp
	movem.l	(sp)+,a2-a6/d2-d7
	rts


state0:
*		found diwstrt
	D	"state0 hw_bplcon0 = "
	DRW	hw_bplcon0(a3)
	D	"hw_fmode = "
	DRW	hw_fmode(a3)
	D	"hw_dafstop "
	DRW	hw_dafstop(a3)

	move.w	d4,hw_diwstrt(a3)

* calculate the bottom line of the previous ViewPort
	move.w	hw_diwstop(a3),d1
	move.w	d1,d0
	lsr.w	#8,d0
*	move.b	gb_ChipRevBits0(a6),d2
*	and.b	#GFXF_HR_DENISE,d2
*	beq.s	20$
	move.w	hw_diwhigh(a3),d1
	and.w	#$700,d1
*	bra.s	30$
*20$:	not.w	d1
*	and.w	#$8000,d1
*	lsr.w	#7,d1
30$:	add.w	d1,d0
	move.w	d0,hw_bovp(a3)
	move.b	gb_ChipRevBits0(a6),d2
	and.b	#GFXF_HR_DENISE,d2
	bne.s	20$
	move.w	cs_thisbeamy(a0),hw_bovp(a3)	; 'A' bottom of viewport

* calculate the top of the previous ViewPort
20$:
	move.w	d4,d0
	lsr.w	#8,d0
	tst.b	d2
	beq.s	40$
	move.w	hw_diwhigh(a3),d1
	and.w	#7,d1
	lsl.w	#8,d1
	add.w	d1,d0
40$:	move.w	d0,hw_tovp(a3)

*******************************************************************************
*
* We need to find the penultimate colour clock that is available to the copper
* on the line.
*
* definitions:
*    UNSATURATED:    hwait = ((total_colorclocks - 1) & 0xfffe)
*    FULLYSATURATED: hwait = ddfstrt
*
* if ((cs_tovp is on a 256 line boundary and cs_tovp > YWait) ||
*     (cs_bovp <= YWait))
* {
*    if (previous CopList had WHOLE_LINES set (if all instructions fitted on a
*        whole number of lines)
*        return 0
*    else
*        UNSATURATED;
* }
* else
* {
*    // find the penultimate colour clock available to the copper
*    lastcc = UNSATURATED;
*    if (((lastcc & 0x7) >= 2) || //not an even multiple of 8 colour clocks
*        ((ddfstop + granularity) < lastcc)) // display does not go to the rhs
*    {
*        hwait = (lastcc - 2);
*    }
*    else
*    {
*        cycles = (2, 4, 8, 16 or 32 depending on mode);
*        if (bpu == cycles)
*        {
*            FULLYSATURATED
*        }
*        else
*        {
*            // the last fetch cycle is at most 8 cycles long.
*            cycles = (2, 4 or 8 depending on the mode of the last fetch)
* 
*            // (* = available for copper)
*            // 2  1                      2cycle
*            // *  
*            //
*            // 4  2  3  1                4 cycle
*            // *     *
*            //
*            // 8  4  6  2  7  3  5  1    8 cycle
*            // *     *     *     *
*
*            if (bpu <= ((cycles / 2) + 1))
*            {
*                hwait = (lastcc - 2);
*            }
*            else
*            {
*                if (cycles == 4)
*                {
*                    hwait = (lastcc - 4); // bpu == 3 in a 4 cycle mode.
*                }
*                else
*                {
*                    // cycles == 8
*                    if (bpu == 6)
*                    {
*                        hwait = (lastcc - 4)
*                    }
*                    else
*                    {
*                        // must be 7 cycles
*                        hwait = (lastcc - 8);
*                    }
*                }
*            }
*        }
*    }
* }
*
*******************************************************************************

	moveq	#0,d0
	move.w	cs_colorclocks(a0),d0
	subq.w	#1,d0
	and.w	#$fffe,d0		; UNSATURATED

	move.w	cs_origbeamy(a0),d1	; special case: a usercopperlist may
	cmp.b	#$ff,d1			; have started and ended on line 255.
	beq.s	4$
	move.w	hw_tovp(a3),d1
	tst.b	d1			; on a 256 line boundary?
	bne.s	3$
	btst.b	#6,cs_moreflags+1(a0)	; EXACT_LINE?
	beq.s	5$
	moveq	#0,d0
	bra.s	hwait_rts
5$:
	cmp.w	hw_YWait(a3),d1
	bgt.s	hwait_rts

3$:
	move.w	hw_bovp(a3),d1
	cmp.w	hw_YWait(a3),d1
	ble	hwait_rts

4$:
	move.w	d0,d1
	and.w	#$7,d1
	cmp.w	#2,d1
	bge.s	1$
	move.w	hw_dafstop(a3),d1
	add.w	hw_granularity(a3),d1
	cmp.w	d0,d1
	bge.s	2$
1$:
	subq.w	#2,d0
	bra	hwait_rts
2$:
	; calculate the cycle.
	moveq	#2,d1
	move.w	hw_bplcon0(a3),d2
	btst.b	#6,d2		; superhires?
	bne.s	mulfmode
	moveq	#4,d1
	tst.w	d2		; hires?
	bmi.s	mulfmode
	moveq	#8,d1		; lores!
mulfmode:
	move.w	hw_fmode(a3),d3
	beq.s	havecycles	; 1x
	cmp.w	#BANDWIDTH_4X,d3
	bne.s	cyc_2x
	add.w	d1,d1		; 4x
cyc_2x:
	add.w	d1,d1
havecycles:
	moveq	#8,d4		; bpu
	btst.b	#4,d2		; is it 8 bitplanes?
	bne.s	havebpu		; yep
	lsr.w	#8,d2
	lsr.w	#4,d2
	and.w	#$7,d2
	move.w	d2,d4
havebpu:
	cmp.b	#$ff,cs_origbeamy+1(a0)	; WAIT on line 255?
	bne.s	6$

	move.l	d0,-(sp)

	; d1 = cycle, d4 = bpu
	; At this point, we need to calculate the number of cycles available
	; to the copper in the middle of the line, in case there are more
	; copper instructions in the line than there are copper cycles.
	;
	; TotalCopperCycle = (Cycles outside displaywindow +
	;                     Cycles inside displaywindow).
	; CCOutside = (((ddfstrt - 2) / 2) + (((totclks & 0xfff8) - ddfstop) / 2))
	; offset = 0; Acycles = MIN(cycles, 8);
	; if (cycles == 16) offset = 4;
	; if (cycles == 32) offset = 12;
	; CCInside = (((bpu <= (Acycles / 2)) ? ((Acycles / 2) + offset)
	;                                   : ((Acycles - bpu) + offset))
	;             * (ddfstop - ddfstrt))
	; Therefore, copperinstructions per line = (TotalCopperCycles / 2)
	;
	; The copper instrutcions in this CopList is cl->cl_Count
	; SHIT!

	move.w	hw_dafstrt(a3),d7
	subq.w	#2,d7
	move.w	cs_colorclocks(a0),d6
	and.w	#$fff8,d6
	sub.w	hw_dafstop(a3),d6
	subq.w	#8,d6			; last fetch is an 8 cycle
	sub.w	d6,d7
	asr.w	#1,d7			; CCOutside = d7

	moveq	#0,d5			; offset = d5
	move.w	d1,d2
	cmp.w	#8,d2
	ble.s	7$
	moveq	#8,d2			; Acycles = d2
	moveq	#4,d5			; assume 16 cycle
	cmp.w	#16,d1
	beq.s	7$
	moveq	#12,d5			; nope, 32 cycles
7$:
	move.w	d2,d3
	asr.w	#1,d3			; (Acycles / 2) = d3
	cmp.w	d4,d3
	bgt.s	8$
	sub.w	d4,d2
	move.w	d2,d3
8$:
	add.w	d3,d5
	move.w	hw_dafstop(a3),d6
	sub.w	hw_dafstrt(a3),d6
	mulu	d6,d5			; d5 = CCInside
	divu	d1,d5			; CCInside per cycle
	add.w	d5,d7			; d7 = copper cycles for the line.
	asr.w	#1,d7			; d7 = copper instructions for the line.

	; count the instructions to the previous WAIT
	move.l	cs_copptr(a0),a4
	moveq	#-1,d2
	move.l	#$10001,d5
	move.l	#$10000,d3
9$:
	addq.w	#1,d2
	move.l	-(a4),d6
	and.l	d5,d6
	cmp.l	d3,d6
	bne.s	9$
	move.l	(sp)+,d0
	cmp.w	d2,d7
	bgt.s	6$			; if less copins on the line than cycles?
	moveq	#-1,d0			; signal an error, 
	bra	hwait_rts

6$:
	cmp.w	d4,d1		; bpu == cycles?
	bne.s	1$
	move.w	hw_dafstrt(a3),d0	; FULLYSATURATED
	bra	hwait_rts
1$:
	; how many cycles in the last fetch cycle?
	cmp.w	#8,d1
	ble.s	2$
	moveq	#8,d1
2$:
	move.w	d1,d2
	asr.w	#1,d2
	addq.w	#1,d2
	cmp.w	d2,d4		; bpu <= ((cycles / 2) + 1)?
	bgt.s	3$
	subq.w	#2,d0
	bra	hwait_rts
3$:
	cmp.w	#4,d1
	bne.s	4$
	sub.w	d1,d0
4$:
	cmp.w	#6,d4
	beq.s	5$
	subq.w	#4,d0		; must be 7 bitplanes
5$:
	subq.w	#4,d0
	bra	hwait_rts


state1:
*		found diwhigh
	D	"state1 "
	DRW	d4
	move.w	d4,hw_diwhigh(a3)
	move.l	#_custom+ddfstop,d6
	and.l	#$1FE,d6
	moveq	#STATE2,d7
	bra	while_loop

state2:
*		found dafstop
	D	"state2 "
	DRW	d4
	move.w	d4,hw_dafstop(a3)
	move.l	#_custom+ddfstrt,d6
	and.l	#$1FE,d6
	moveq	#STATE3,d7
	bra	while_loop

state3:
*		found dafstart
	D	"state3 "
	DRW	d4
	move.w	d4,hw_dafstrt(a3)
	move.l	#_custom+diwstop,d6
	and.l	#$1FE,d6
	moveq	#STATE4,d7
	bra	while_loop

state4:
*		found diwstop
	D	"state4 "
	DRW	d4
	move.w	d4,hw_diwstop(a3)
	move.l	#_custom+bplcon0,d6
	and.l	#$1FE,d6
	moveq	#STATE5,d7
	bra	while_loop

state5:
*		found bplcon0
	D	"state5 "
	DRW	d4
	move.b	gb_ChipRevBits0(a6),d0
	and.b	#GFXF_HR_DENISE,d0
	if =
		move.w	hw_oldbplcon0(a3),hw_bplcon0(a3)
	else
		move.w	d4,hw_bplcon0(a3)
	endif

	moveq	#GRANULARITY,d1			; assume this will be the Granularity.
	move.w	d1,hw_granularity(a3)
	subq.w	#1,d1
	move.w	d1,hw_granularity1(a3)

	move.l	#_custom+diwstrt,d6
	and.l	#$1FE,d6
	moveq	#STATE0,d7
	bra	while_loop

state6:
*		found 'old denise' bplcon0
	D	"state6 "
	DRW	d4
	move.w	d4,hw_oldbplcon0(a3)
	move.l	#_custom+ddfstop,d6
	and.l	#$1FE,d6
	moveq	#STATE2,d7
	bra	while_loop

state7:
*		found fmode
	D	"state7 "
	DRW	d4
	and.w	#$3,d4
	move.w	d4,hw_fmode(a3)
	move.l	#_custom+diwhigh,d6
	and.l	#$1FE,d6
	moveq	#STATE1,d7
	bra	while_loop

state_table:
	jmp	state0
	jmp	state1
	jmp	state2
	jmp	state3
	jmp	state4
	jmp	state5
	jmp	state6
	jmp	state7

	ENDC
* }

	end
@


39.19
log
@Add 1 to waitpos if this is scan doubled, and the cl_Flags has HALF_LINE
set (to WAIT for an odd-line number).
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.18 93/03/31 16:42:11 spence Exp Locker: spence $
d289 1
a289 1
		btst.b	#1,cl_Flags+1(a2)	; HALF_LINE ?
@


39.18
log
@Was possible to have two WAIT y,x instead of WAIT 255,x, WAIT y,x, if
a UCopList was on line 255.
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.17 93/03/29 11:25:23 spence Exp Locker: spence $
d289 4
@


39.17
log
@If there are multiple consecutive WAIT(255,x) instructions, then
get_hwait_hack() will return max-x.
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.16 93/02/24 17:00:36 spence Exp Locker: spence $
d471 1
d750 1
a750 1
	bge	ret_hwait		; this WAIT should be max-X as another WAIT
@


39.16
log
@If this beamy == previous beamy, and beamy == total_rows, then don't
add an extra WAIT 255. This was happening in UserCopperLists where all
MOVEs past total_rows in DblPAL were getting an extra WAIT if DiwStrtY
was a 256 multiple..
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.15 93/02/22 10:19:23 spence Exp Locker: spence $
d737 3
a739 2
	and.w	#$ff00,d3
	and.w	#$ff00,d4
d743 8
a750 2
*	lsr.w	#8,d4
*	move.b	d4,hw_YPosBlock(a3)
@


39.15
log
@If the previous ViewPort's copper instructions execute in a whole number
of lines, the get_hwait_hack() returns 0.
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.14 93/02/09 15:27:27 spence Exp Locker: spence $
d51 1
d253 1
d262 3
d592 2
@


39.14
log
@Code to handle UCopperLists which start on line 255. They may execute
all their instructions on line 255, or roll over to the next line. This
affects get_hwait_hack().
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.13 92/12/05 17:11:33 spence Exp Locker: spence $
d9 2
d13 1
a14 1
	include "/copper.i"
d219 1
d849 5
a853 1
*    UNSATURATED;
d927 5
d938 1
a938 1
	ble.s	hwait_rts
@


39.13
log
@Calculation of HWAIT in get_hwait_hack() reworked. Should handle all
cusp cases now, including waiting for line >= 512.
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.12 92/08/27 12:13:17 spence Exp Locker: spence $
d48 1
d110 1
a110 1
	if = .extend
d135 1
a135 1
		else .extend
d255 1
d477 2
d660 1
a660 1
*   Returns value in d0:16
d914 3
d928 1
d967 76
@


39.12
log
@add 1 to the vpos before halving if laced (reduces rounding error).
get_hwait_hack() checks for depth <= 5 instead of <= 4 for deciding
if a mode is saturated.
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.11 92/08/17 17:05:59 spence Exp Locker: spence $
d388 3
a390 1
		* don't bother with the rest of this shit.
d394 3
d652 3
a659 29
*******************************************************************************
*
* Q - When is a mode an unsaturated mode?
* A - Well, in all cases, the answer is obvious, until you need to look
* at get_hwait_hack(), because this piece of code is very interested in the 
* last cycle on a line. Now, Hires 4x, Lores 2x and Lores 4x modes are
* always unsaturated, but with R3 Alices, the last fetch cycles is always 8
* colour clocks long (because of BPLAST). So these modes still leave cycles
* for the copper to use if they are <= 5 bitplanes deep. This means that a
* mode can be saturated (as far as ghh() is concerned) even if the mode
* really isn't!
*
* So, ghh() returns 1 of three results.
*
* 1) ((total_colour_clocks - 4) & 0xfffe) if 
*   a) there are no ViewPorts above this one.
*   b) 1x unsaturated.
*   c) 2x <= 5 bitplanes.
*   d) 4x <= 5 bitplanes.
*   e) DDFSTOP is not the maximum possible fetch on the line.
*   f) The bottom of the previous ViewPort is higher than the top of this one
*      and it's before line 256
* 2) DDFSTOP if the mode is unsaturated but the last fetch is.
* 3) (total_color_clocks - 2) if 
*   a) the 2x or 4x mode has a DDFSTOP < max DDFSTOP
*   b) the top of the previous ViewPort is past line 255
* 4) DDFSTRT if the mode is really saturated.
*
*******************************************************************************
d676 1
d720 10
a729 1
	move.w	d0,hw_fmode(a3)
a797 17
	move.w	cs_colorclocks(a0),d1
	sub.w	hw_granularity(a3),d1
	move.w	hw_granularity1(a3),d0
	not.w	d0
	and.w	d0,d1	; temporarily hmax
	move.b	gb_ChipRevBits0(a6),d0
	and.b	#GFXF_HR_DENISE,d0
	if <>
		move.w	d4,d0
		and.w	hw_granularity1(a3),d0
		and.w	#FETCH_MASK,d0
		sub.w	d0,d1
	endif
	move.w	d1,hw_hmax(a3)
	D	"hw_max "
	DRW	hw_hmax(a3)

d802 3
a804 3
	move.b	gb_ChipRevBits0(a6),d2
	and.b	#GFXF_HR_DENISE,d2
	beq.s	20$
d807 4
a810 4
	bra.s	30$
20$:	not.w	d1
	and.w	#$8000,d1
	lsr.w	#7,d1
d813 4
d819 1
d830 85
a914 1
* check for saturated cases
d916 4
a919 53
	move.w	hw_bplcon0(a3),d0
	and.w	#$f050,d0
	move.w	hw_fmode(a3),d1
	beq.s	fs_1x
	cmp.w	#BANDWIDTH_4X,d1
	beq.s	fs_4x

fs_2x:
	cmp.w	#$8010,d0		; 8 bitplane hires
	beq	saturated
	cmp.w	#$4040,d0		; 4 bitplane shires
	beq	saturated
	cmp.w	#$0010,d0
	beq.s	chk_unsaturated		; 8 bitplane lores might be unsaturated
	bra.s	chk_5bitplanes		; hires or lores <= 5 bitplanes is
					; definitely unsaturated.

fs_4x:
	cmp.w	#$0050,d0		; 8 bitplane shires
	beq.s	saturated
	btst.b	#4,d0			; 8 bitplanes?
	bne.s	chk_unsaturated
chk_5bitplanes:
	and.w	#$7000,d0
	cmp.w	#$5000,d0
	ble	ret_hwait		; anything <= 5 bitplanes is definitely unsaturated
	bra.s	chk_unsaturated

fs_1x:
	cmp.w	#$0010,d0		; 8 bitplane lores
	beq.s	saturated
	cmp.w	#(V_HIRES+$4000),d0	; 4 bitplanes Hires
	beq.s	saturated
	cmp.w	#$2040,d0		; 2 bitplane shires
	beq.s	saturated
	bra	ret_hwait		; 1x unsaturated really is

chk_unsaturated:
* Now, we want to hwait at the last colour clock in the line, but if
* the ((ddfstop + granularity) == (last colourclock - k)), then we're as
* good as fully saturated!

	D	'chk unsaturated '

* If the top of the previous ViewPort is past line 255, then treat it as
* unsaturated.

	cmp.w	#255,hw_tovp(a3)
	bgt	goat

* If the bottom of the previous ViewPort is higher than the top of this one,
* then treat the previous ViewPort as unsaturated, unless the bottom of the
* previous ViewPort is over line 255.
d921 4
a924 11
	move.w	cs_thisbeamy(a0),d1
	move.w	hw_bovp(a3),d0
	D	'cs_thisbeamy, hw_bovp = '
	DRW	d1
	DRW	d0
	cmp.w	#256,d0
	bge.s	use_dafstop
	addq.w	#1,d0
	cmp.w	d1,d0
	blt	ret_hwait
	
d927 47
a973 1
	move.w	cs_colorclocks(a0),d0
d975 11
a985 11
	and.w	#$fffe,d0
	D	'dafstop+g, cc = '
	DR	d1
	DR	d0
	cmp.w	d1,d0
	bgt	ret_hwait
use_dafstop:
	move.w	hw_hmax(a3),d0
	cmp.w	hw_dafstop(a3),d0
	bgt.s	goat
	move.w	hw_dafstop(a3),d0
a987 29
saturated:
	D	"Is saturated "
	move.w	hw_hmax(a3),d0
	cmp.w	hw_dafstop(a3),d0
	bgt.s	goat

	move.w	cs_beamy(a0),d0
	add.w	#255,d0
	asr.w	#8,d0
	subq.w	#1,d0
	if	#255 > d0.w
		move.l	#255,d0
	endif
	if	hw_bovp(a3) <= d0.w
		bra.s	frog1
	else
		if hw_tovp(a3) <= d0.w
			move.w	hw_dafstrt(a3),d0
			bra	hwait_rts
		endif
	endif
frog1:	move.w	hw_dafstop(a3),d0
frog2:	add.w	hw_granularity(a3),d0
		bra	hwait_rts
goat:
	D	"goat "
	move.w	cs_colorclocks(a0),d0
	subq.w	#1,d0
	bra	hwait_rts
@


39.11
log
@topline is now LONG.
Check topline against HIGHESTLINE. This ensures that the copperlist
always starts with a WAIT.
Ensure the coppelist is always terminated properly. Wasn't being 
terminated if foing straddling fudges.
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.10 92/08/06 11:28:40 spence Exp Locker: spence $
d273 1
d660 1
a660 1
* for the copper to use if they are <= 4 bitplanes deep. This means that a
d669 2
a670 2
*   c) 2x <= 4 bitplanes.
*   d) 4x <= 4 bitplanes.
d869 1
a869 1
	bra.s	chk_4bitplanes		; hires or lores <= 4 bitplanes is
d877 1
a877 1
chk_4bitplanes:
d879 2
a880 2
	cmp.w	#$4000,d0
	ble	ret_hwait		; anything <= 4 bitplanes is definitely unsaturated
@


39.10
log
@Check for STRADDLES_512 (only for the DblPAL monitor).
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.9 92/07/09 12:08:26 spence Exp Locker: spence $
d46 1
a46 1
		UWORD	cs_topline
d68 1
a68 1
	beq	dbg\@@
d74 1
a74 1
	beq	dbg\@@
d80 1
a80 1
	beq	dbg\@@
a253 1
	move.w	ms_min_row(a3),d5	; min_ytop
d266 1
a266 1
	jsr		_new_mode
d309 3
a311 2
	move.w	cs_topline(a0),d6
	cmp.w	#$ffff,d6
d313 1
d315 2
a316 2
	asl.w	#8,d6
	cmp.w	#HIGHESTLINE,d6
d318 3
a320 1
	move.w	#HIGHESTLINE,cs_topline(a0)
d323 1
a323 1
	move.w	d6,cs_topline(a0)
d371 4
a374 2
cow 	lea		cs_beamx(a0),a4	; bmx
	lea		cs_beamy(a0),a5	; bmy
d378 1
d390 10
a399 1
		* However, if d7 >512 and the previous ViewPort straddled line 512
d421 3
d437 1
d453 1
d456 1
d474 1
d483 1
d508 1
d518 1
d525 2
d536 1
d554 1
d558 1
d562 1
d569 1
@


39.9
log
@STRADDLES_255 handling.
get_hwait_hack() fixed for testing unsaturated modes in 2x and 4x, where
the last fetch is really saturated.
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.8 92/06/03 16:33:02 chrisg Exp Locker: spence $
d214 2
a215 1
STRADDLES_255	equ	VPXB_STRADDLES_255
d331 1
a331 1
	bne	cow
d333 1
a333 1
	bne	cow
d335 1
a335 1
	bne	cow
d343 1
a343 1
	bra	cow
d346 1
a346 1
	beq	cow
d348 1
a348 1
	bgt	cow
d350 1
a350 1
	ble	cow
d379 2
a380 2
	if #255 < d7.w
		* If the previous ViewPort's IVG straddled line 255, then
d382 14
a395 2
		btst.b	#STRADDLES_255,cs_moreflags+1(a0)
		beq	no_straddles
d401 1
a401 1
		beq.s		4$
a404 1
*			if #255 <> d6.w
d451 1
a451 1
	beq		dont_do_fw
d459 1
a459 1
	ble		dont_do_fw1
d835 2
a836 2
	beq	chk_unsaturated		; 8 bitplane lores might be unsaturated
	bra	chk_4bitplanes		; hires or lores <= 4 bitplanes is
d841 1
a841 1
	beq	saturated
d843 1
a843 1
	bne	chk_unsaturated
d848 1
a848 1
	bra	chk_unsaturated
d852 1
a852 1
	beq	saturated
d854 1
a854 1
	beq	saturated
d856 1
a856 1
	beq	saturated
d882 1
a882 1
	bge	use_dafstop
d900 1
a900 1
	bgt	goat
d908 1
a908 1
	bgt	goat
@


39.8
log
@saved short branches.
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.7 92/04/28 15:34:42 spence Exp Locker: chrisg $
d11 1
a14 1
	include "/view.i"
d47 1
a212 2
HEDLEY_HACK	equ	2
HEDLEY_HACK2 equ	4
d214 1
d277 1
a277 1
		asl.w	#1,d7
d330 1
a330 1
	bne.s	cow
d332 1
a332 1
	bne.s	cow
d334 1
a334 1
	bne.s	cow
d342 1
a342 1
	bra.s	cow
d345 1
a345 1
	beq.s	cow
d347 1
a347 1
	bgt.s	cow
d349 1
a349 1
	ble.s	cow
d379 7
d407 1
d430 6
d480 1
a480 4
	bne.s		do_fw2
	move.w	cs_moreflags(a0),d0
	and.w	#HEDLEY_HACK,d0
	beq.s		dont_do_fw2
a495 23
dont_do_fw2:
	move.w	cs_moreflags(a0),d0
	move.w	d0,-(sp)
	and.w	#HEDLEY_HACK,d0
	if <>
		move.l	cs_cop2ptr(a0),a3
		move.l	d1,(a3)+
		move.l	a3,cs_cop2ptr(a0)
		move.l	cs_cop3ptr(a0),a3
		move.l	d1,(a3)+
		move.l	a3,cs_cop3ptr(a0)
	endif
	move.w	(sp)+,d0
	and.w	#HEDLEY_HACK2,d0
	if <>
		move.l	cs_cop4ptr(a0),a3
		move.l	d1,(a3)+
		move.l	a3,cs_cop4ptr(a0)
		move.l	cs_cop5ptr(a0),a3
		move.l	d1,(a3)+
		move.l	a3,cs_cop5ptr(a0)
	endif
	bra.s	dont_do_fw
d504 4
d524 1
d607 30
a736 2
*	moveq	#HWAIT,d0
*	HFIX	d0
a742 2
*	HFIX	d0
*	D	"HFIXed "
d759 2
d764 45
a808 1
* check for unsaturated cases (and just return (HFIX(HWAIT)))
d819 1
a819 1
	beq.s	saturated
d821 5
a825 2
	beq.s	saturated
	bra	ret_hwait
d829 8
a836 2
	beq.s	saturated
	bra	ret_hwait
a838 1
	and.w	#$f050,d0
d840 1
a840 1
	beq.s	saturated
d842 1
a842 1
	beq.s	saturated
d844 2
a845 2
	bne	ret_hwait
saturated:
d847 16
a862 5
	D	"Is saturated "
	D	"hw_max "
	DRW	hw_hmax(a3)
	D	"hw_dafstop "
	DRW	hw_dafstop(a3)
d864 22
a886 1
*	if hw_dafstop(a3) >= d0.w
d888 3
a890 16
		bgt	goat
*	else
		move.w	hw_diwstop(a3),d1
		move.w	d1,d0
		lsr.w	#8,d0
		move.b	gb_ChipRevBits0(a6),d2
		and.b	#GFXF_HR_DENISE,d2
		beq.s	20$
		move.w	hw_diwhigh(a3),d1
		and.w	#$700,d1
		bra.s	30$
20$:	not.w	d1
		and.w	#$8000,d1
		lsr.w	#7,d1
30$:	add.w	d1,d0
		move.w	d0,hw_bovp(a3)
d892 5
a896 9
		move.w	hw_diwstrt(a3),d0
		lsr.w	#8,d0
		tst.b	d2
		beq.s	40$
		move.w	hw_diwhigh(a3),d1
		and.w	#7,d1
		lsl.w	#8,d1
		add.w	d1,d0
40$:	move.w	d0,hw_tovp(a3)
d898 13
a910 6
		move.w	cs_beamy(a0),d0
		add.w	#255,d0
		asr.w	#8,d0
		subq.w	#1,d0
		if	#255 > d0.w
			move.l	#255,d0
d912 1
a912 8
		if	hw_bovp(a3) <= d0.w
			bra.s	frog1
		else
			if hw_tovp(a3) <= d0.w
				move.w	hw_dafstrt(a3),d0
				bra	hwait_rts
			endif
		endif
a915 1
*	endif
a917 2
*	move.w	hw_hmax(a3),d0
*	bra	frog2
d925 1
d935 1
d945 1
a946 13
	move.w	cs_colorclocks(a0),d1
	sub.w	hw_granularity(a3),d1
	move.w	hw_granularity1(a3),d0
	not.w	d0
	and.w	d0,d1	; temporarily hmax
	move.b	gb_ChipRevBits0(a6),d0
	and.b	#GFXF_HR_DENISE,d0
	if <>
		move.w	d4,d0
		and.w	hw_granularity1(a3),d0
		and.w	#FETCH_MASK,d0
		sub.w	d0,d1
	endif
a949 1
	move.w	d1,hw_hmax(a3)
d955 1
d965 1
d974 1
a974 24
* Calculate the Granularity of this ViewPort
*
* Granularity = 16 for Hires4x and Lores2x (16 cycle) and Lores4x (32 cycle),
*               8 in all other cases
*		(possibly 64 for Lores8x, 32 for Hires8x, 16 SuperHires8x)

	moveq	#8,d1			; assume this will be the Granularity.
	move.w	hw_fmode(a3),d0
	beq.s	have_gran		; 1x
	move.l	gb_bwshifts(a6),a2
	move.b	0(a2,d0.w),d0		; shift value for this bandwidth.
	btst.b	#5,d4			; Superhires?
	bne.s	1$
	and.w	#V_HIRES,d4
	beq.s	calcgran
	moveq	#4,d1
	bra.s	calcgran
1$:
	cmp.b	#2,d0			; Superhires - only calculate if bw > 4x
	ble.s	have_gran		; use d1 = 8.
	moveq	#2,d1
calcgran:
	asl.w	d0,d1
have_gran:
d976 1
a976 1
	sub.w	#1,d1
d987 1
d997 1
@


39.7
log
@Removed checks for old A2024 copperlists.
Properly terminates copperlists whose monitors have less than 256 lines
(last WAIT position was being set for MSpec->MaxRows).
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.6 92/03/13 15:44:25 spence Exp Locker: spence $
d299 1
a299 1
		bge	fuckit
d311 1
a311 1
	bne	nottopline
d315 1
a315 1
	bhi	use_d6
d317 1
a317 1
	bra	nottopline
d330 1
a330 1
	bne	cow
d332 1
a332 1
	bne	cow
d334 1
a334 1
	bne	cow
d336 1
a336 1
	bne	6$
d338 1
a338 1
	bne	6$
d342 1
a342 1
	bra	cow
d345 1
a345 1
	beq	cow
d347 1
a347 1
	bgt	cow
d349 1
a349 1
	ble	cow
d381 1
a381 1
		beq		4$
d390 1
a390 1
				bne	1$
d392 1
a392 1
				bra	2$
d394 1
a394 1
2$:				beq	3$
d423 1
a423 1
	bne	do_fw
d428 1
a428 1
	beq	do_fw1
d431 1
a431 1
	bne	do_fw1
d466 1
a466 1
	bne		do_fw2
d469 1
a469 1
	beq		dont_do_fw2
d478 1
a478 1
		blt	1$
d507 1
a507 1
	bra	dont_do_fw
d510 1
a510 1
	bne	1$
d512 1
a512 1
	bne	1$
d534 1
a534 1
			bne	1$
d536 1
a536 1
			bne	1$
d549 1
a549 1
			blt	1$
d553 1
a553 1
			bra	2$
d703 1
a703 1
	beq		end_while
d748 1
a748 1
	beq	fs_1x
d750 1
a750 1
	beq	fs_4x
d754 1
a754 1
	beq	saturated
d756 1
a756 1
	beq	saturated
d761 1
a761 1
	beq	saturated
d767 1
a767 1
	beq	saturated
d769 1
a769 1
	beq	saturated
d790 1
a790 1
		beq	20$
d793 1
a793 1
		bra	30$
d803 1
a803 1
		beq	40$
d818 1
a818 1
			bra	frog1
d906 1
a906 1
	beq	have_gran		; 1x
d910 1
a910 1
	bne	1$
d912 1
a912 1
	beq	calcgran
d914 1
a914 1
	bra	calcgran
d917 1
a917 1
	ble	have_gran		; use d1 = 8.
@


39.6
log
@get_hwait_hack() needed to sub 1 from total_colourclocks for modes
with an even number of colourclocks.
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.5 92/02/04 17:22:34 spence Exp Locker: spence $
d67 1
a67 1
	beq.s	dbg\@@
d73 1
a73 1
	beq.s	dbg\@@
d79 1
a79 1
	beq.s	dbg\@@
d101 4
a155 4
*				HEDLEY_HACK
*				tst.w	$123456
				movem.l	a5/a6,-(sp)
				movem.l	cs_cop2ptr(a0),a5/a6
a169 27
					btst	#nCPR_NT_2,d1
					if = 
						move.l	d0,(a5)+
					endif
					btst	#nCPR_NT_3,d1
					if = 
						move.l	d0,(a6)+
					endif
				btst.b	#2,cs_moreflags+1(a0)
				if <>
					btst	#nCPR_NT_4,d1
					if = 
						move.l	a6,-(sp)
						move.l	cs_cop4ptr(a0),a6
						move.l	d0,(a6)+
						move.l	a6,cs_cop4ptr(a0)
						move.l	(sp)+,a6
					endif
					btst	#nCPR_NT_5,d1
					if = 
						move.l	a6,-(sp)
						move.l	cs_cop5ptr(a0),a6
						move.l	d0,(a6)+
						move.l	a6,cs_cop5ptr(a0)
						move.l	(sp)+,a6
					endif
				endif
a174 2
				movem.l	a5/a6,cs_cop2ptr(a0)
				movem.l	(sp)+,a5/a6
d298 7
d311 1
a311 1
	bne.s	nottopline
d315 1
a315 1
	bhi.s	use_d6
d317 1
a317 1
	bra.s	nottopline
d330 1
a330 1
	bne.s	cow
d332 1
a332 1
	bne.s	cow
d334 1
a334 1
	bne.s	cow
d336 1
a336 1
	bne.s	6$
d338 1
a338 1
	bne.s	6$
d342 1
a342 1
	bra.s	cow
d345 1
a345 1
	beq.s	cow
d347 1
a347 1
	bgt.s	cow
d349 1
a349 1
	ble.s	cow
d390 1
a390 1
				bne.s	1$
d392 1
a392 1
				bra.s	2$
d394 1
a394 1
2$:				beq.s	3$
d423 1
a423 1
	bne.s	do_fw
d428 1
a428 1
	beq.s	do_fw1
d431 1
a431 1
	bne.s	do_fw1
d478 1
a478 1
		blt.s	1$
d507 1
a507 1
	bra.s	dont_do_fw
d510 1
a510 1
	bne.s	1$
d512 1
a512 1
	bne.s	1$
d534 1
a534 1
			bne.s	1$
d536 1
a536 1
			bne.s	1$
d549 1
a549 1
			blt.s	1$
d553 1
a553 1
			bra.s	2$
d583 1
a583 1
	bra.s	do_wait_bye
d587 1
a587 1
	bra.s	do_wait_bye
d710 1
a710 1
	bra.s		while_loop
d748 1
a748 1
	beq.s	fs_1x
d750 1
a750 1
	beq.s	fs_4x
d754 1
a754 1
	beq.s	saturated
d756 1
a756 1
	beq.s	saturated
d761 1
a761 1
	beq.s	saturated
d767 1
a767 1
	beq.s	saturated
d769 1
a769 1
	beq.s	saturated
d790 1
a790 1
		beq.s	20$
d793 1
a793 1
		bra.s	30$
d803 1
a803 1
		beq.s	40$
d818 1
a818 1
			bra.s	frog1
d832 1
a832 1
*	bra.s	frog2
d906 1
a906 1
	beq.s	have_gran		; 1x
d910 1
a910 1
	bne.s	1$
d912 1
a912 1
	beq.s	calcgran
d914 1
a914 1
	bra.s	calcgran
d917 1
a917 1
	ble.s	have_gran		; use d1 = 8.
@


39.5
log
@Mask found fmode in get_hwait_hack() with 3 to remove sprite fmode and
scan doubling bits.
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.4 92/01/29 16:46:03 spence Exp Locker: spence $
d856 1
@


39.4
log
@Added debug code.
Fixed type in get_hwait_hack() - was settting the FMODE state in the
wrong register. Fixes blank viewports past line 255.
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.3 91/11/26 16:32:06 spence Exp Locker: spence $
d276 6
d298 2
d309 8
a316 1

d352 1
a352 1
	bne	5$
d354 1
a354 1
	bne.s	5$
d356 1
a356 1
	bne.s	5$
d364 1
a364 1
	bra.s	5$
d367 1
a367 1
	beq.s	5$
d369 1
a369 1
	bgt.s	5$
d371 1
a371 1
	ble.s	5$
d375 1
d382 1
d389 1
a389 1
5$ 	lea		cs_beamx(a0),a4	; bmx
d398 2
d470 1
a470 1
	if =
d474 3
d964 1
@


39.3
log
@Stores first line WAITed at in the copperlist for dynamic
GBASE->TopLine storage.
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.2 91/11/25 15:58:12 spence Exp Locker: spence $
d62 33
d692 1
a692 1
			moveq	#STATE7,d0
d696 4
d718 2
d722 2
d726 3
d736 5
d757 1
a757 1
	bra.s	ret_hwait
d762 1
a762 1
	bra.s	ret_hwait
d771 1
a771 1
	bne.s	ret_hwait
d773 7
d830 5
a834 2
	move.w	hw_hmax(a3),d0
	bra.s	frog2
d838 1
d847 1
d856 1
d879 1
d888 1
d932 1
d941 1
@


39.2
log
@Double VWAITPOS for scandoubled modes.
Replace HFIX(HWAIT) in get_hwaithack() with
(colourclocks - 4) & 0xfffe.

HOW SAFE IS THIS??
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.1 91/11/14 16:44:27 spence Exp Locker: spence $
d16 1
d46 1
d281 14
@


39.1
log
@get_hwait_hack() now looks for fmode, and checks for saturation
depending on the fmode.
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 39.0 91/08/21 17:16:09 chrisg Exp Locker: spence $
d257 1
a257 1
	and.w	#V_LACE,d0
d261 4
d601 1
a601 1
	jsr		lmult		; d0.l = (d1.l * d0.l)
d661 6
a666 2
	move.l	#HWAIT,d0
	HFIX	d0
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 37.1 91/01/30 17:15:07 bart Exp Locker: chrisg $
d11 5
a15 5
	include 'graphics/copper.i'
	include 'graphics/gfxbase.i'
	include 'graphics/monitor.i'
	include 'graphics/view.i'
	include 'graphics/display.i'
d548 1
a548 1
*   a2 ->                            d2:32 = scratch
d573 3
d585 1
d592 1
d602 1
d610 3
d619 1
d622 1
a622 1
	lea		state_table(pc),a4	; jump table
d629 2
a630 2
	and.b	#GFXF_HR_DENISE,d0
	if =
d634 7
a640 1
		move.l	#_custom+diwhigh,d6
d651 1
a651 1
		jmp	0(a4,d7.w)		; jump into the appropriate switch
d669 3
d673 25
a697 6
	move.w	d0,d1
	and.w	#$F000,d0
	cmp.w	#(V_HIRES+$4000),d0
	beq.s	10$
	and.w	#$7040,d1
	cmp.w	#$2040,d1
d699 1
a699 1
10$:
d703 1
a703 1
		bgt.s	goat
d746 1
a746 1
frog2:	addq.w	#GRANULARITY,d0
d773 4
a776 2
	subq.w	#GRANULARITY,d1
	and.w	#(~(GRANULARITY-1)),d1	; temporarily hmax
d781 1
a781 1
		and.w	#(GRANULARITY-1),d0
d808 29
d850 8
d859 8
a866 7
	jmp		state0
	jmp		state1
	jmp		state2
	jmp		state3
	jmp		state4
	jmp		state5
	jmp		state6
d869 1
@


37.1
log
@coplist fixes for compatibility
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 37.0 91/01/07 15:27:16 spence Exp Locker: bart $
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 36.6 90/10/11 13:23:13 spence Exp Locker: spence $
d237 3
a239 4
	movem.l	4+4*11(sp),a0-a3		; cs, c, cl, mspc
	moveq	#0,d2			; ov_flow
	lea		cs_beamx(a0),a4	; bmx
	lea		cs_beamy(a0),a5	; bmy
a240 7
	move.w	ci_OpCode(a1),d0
	and.w	#CPR_NT_LOF,d0
	if <>
		lea		cs_ibeamx(a0),a4	; bmx
		lea		cs_ibeamy(a0),a5	; bmy
	endif

d247 2
a248 2
	move.l	cl__ViewPort(a2),a3
	move.w	vp_DyOffset(a3),d0
d253 1
a253 1
	move.l	a3,-(sp)
d275 1
d282 46
d337 1
a337 2
				moveq	#1,d2
				move.w	ci_OpCode(a1),d0
d339 1
a339 1
				and.w	#CPR_NT_LOF,d0
d348 1
a348 1
				bra		vpos_overflow
d364 1
a364 1
				moveq	#1,d2
d397 1
a397 2
	move.w	ci_OpCode(a1),d0
	and.w	#CPR_NT_LOF,d0
d404 1
a404 2
		move.w	ci_OpCode(a1),d0
		and.w	#CPR_NT_SHT,d0
d422 1
a422 2
	move.w	ci_OpCode(a1),d0
	and.w	#CPR_NT_SHT,d0
d424 2
d429 1
a429 1
		move.w	d4,(a5)
d454 1
a454 1
	bra	dont_do_fw
d456 6
a461 1
	move.w	d4,(a5)
d467 1
a467 3
		move.w	ci_OpCode(a1),d0
		move.w	d0,d1
		and.w	#CPR_NT_LOF,d0
d470 1
a470 1
			and.w	#CPR_NT_SHT,d1
d478 1
a478 1
		move.w	ci_HWaitPos(a1),d6
d480 24
a503 1
			moveq	#0,d2
d624 1
a624 1
		move.l	#_custom+ddfstop,d6
d637 1
a637 1
	bra		while_loop
d657 1
a657 1
	beq		10$
d665 1
a665 1
		bgt		goat
d672 1
a672 1
		beq		20$
d675 1
a675 1
		bra		30$
d685 1
a685 1
		beq		40$
d700 1
a700 1
			bra	frog1
d709 1
a709 1
		bra		hwait_rts
d713 1
a713 1
	bra	frog2
d716 8
d728 2
a729 2
	moveq	#STATE2,d7
	bra		while_loop
d731 1
a731 1
state2:
a743 7
		move.l	#_custom+diwhigh,d6
		and.l	#$1FE,d6
		moveq	#STATE3,d7
	else
		move.l	#_custom+diwstop,d6
		and.l	#$1FE,d6
		moveq	#STATE4,d7
a744 6
	move.w	d1,hw_hmax(a3)
	bra	while_loop

state3:
*		found diwhigh
	move.w	d4,hw_diwhigh(a3)
d748 2
a749 1
	bra		while_loop
d757 1
a757 1
	bra		while_loop
d771 1
a771 1
	bra		while_loop
d778 2
a779 2
	moveq	#STATE1,d7
	bra		while_loop
@


36.6
log
@Fixed bug with hires-overscan 16-colour workbench not terminating
copperlist properly
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 36.5 90/10/08 13:18:41 bart Exp Locker: spence $
@


36.5
log
@spence downcode of do_wait and get_hwack_hack
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 36.5 90/10/03 10:47:04 spence Exp $
d327 2
@


36.4
log
@id
@
text
@d3 1
a3 1
*	$Id: coppermover.asm,v 36.3 90/07/20 22:28:15 bart Exp Locker: bart $
d7 1
d10 1
d12 5
d41 4
d177 553
@


36.3
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Id: $
@


36.2
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/graphics/c/RCS/coppermover.asm,v 36.1 88/03/10 16:12:25 dale Exp Locker: bart $
@


36.1
log
@
@
text
@d3 1
a3 1
*	$Header: $
@
