head     39.23;
branch   ;
access   ;
symbols  rel39_24:39.23 rel39_18:39.23 rel39_97:39.22 rel39_90:39.22 rel39_89:39.22 rel39_82:39.22 rel39_76:39.21 rel39_71:39.20 rel39_65:39.20 rel39_64:39.20 rel39_61:39.20 rel39_60:39.20 rel39_55:39.17 rel39_52:39.17 rel39_47:39.17 rel39_39:39.17 rel39_38:39.17 rel39_37:39.17 rel39_35:39.15 rel39_34:39.15 V37_30:37.0 V37_29:37.0 V37_28:37.0 V37_27:37.0 V37_25:37.0 V37_24:37.0 V37_23:37.0 V37_22:37.0 V37_21:37.0 V37_20:37.0 V37_19:37.0 V37_17:37.0 V37_15:37.0 V37_14:37.0 V37_13:37.0 V37_12:37.0 V37_11:37.0 V37_10:37.0 V37_9:37.0 V37_8:37.0 V37_7:37.0 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.103 V36_208:36.103 V36_207:36.103 V36_205:36.103 V36_203:36.103 V36_202:36.103 V36_201:36.103 V36_200:36.102 V36_199:36.102 V36_198:36.101 V36_196:36.101 V36_195:36.101 V36_194:36.101 V36_193:36.101 V36_192:36.101 V36_191:36.101 V36_190:36.101 V36_189:36.101 V36_188:36.101 V36_186:36.101 V36_185:36.101 V36_184:36.101 V36_182:36.101 V36_181:36.101;
locks    ; strict;
comment  @ * @;


39.23
date     92.11.23.16.29.49;  author spence;  state Exp;
branches ;
next     39.22;

39.22
date     92.08.06.11.31.12;  author spence;  state Exp;
branches ;
next     39.21;

39.21
date     92.07.21.14.45.30;  author spence;  state Exp;
branches ;
next     39.20;

39.20
date     92.05.13.11.29.03;  author spence;  state Exp;
branches ;
next     39.19;

39.19
date     92.05.05.14.51.38;  author spence;  state Exp;
branches ;
next     39.18;

39.18
date     92.05.05.12.14.05;  author chrisg;  state Exp;
branches ;
next     39.17;

39.17
date     92.02.26.11.32.49;  author spence;  state Exp;
branches ;
next     39.16;

39.16
date     92.02.25.14.25.55;  author spence;  state Exp;
branches ;
next     39.15;

39.15
date     92.01.29.16.49.13;  author spence;  state Exp;
branches ;
next     39.14;

39.14
date     92.01.07.16.06.37;  author spence;  state Exp;
branches ;
next     39.13;

39.13
date     91.12.31.16.04.43;  author spence;  state Exp;
branches ;
next     39.12;

39.12
date     91.11.18.11.31.10;  author spence;  state Exp;
branches ;
next     39.11;

39.11
date     91.11.11.11.47.46;  author chrisg;  state Exp;
branches ;
next     39.10;

39.10
date     91.11.08.11.55.49;  author chrisg;  state Exp;
branches ;
next     39.9;

39.9
date     91.10.30.19.20.19;  author spence;  state Exp;
branches ;
next     39.8;

39.8
date     91.10.29.11.34.23;  author spence;  state Exp;
branches ;
next     39.7;

39.7
date     91.10.28.19.36.50;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     91.10.18.18.42.17;  author spence;  state Exp;
branches ;
next     39.5;

39.5
date     91.10.18.18.37.02;  author spence;  state Exp;
branches ;
next     39.4;

39.4
date     91.10.17.14.00.03;  author chrisg;  state Exp;
branches ;
next     39.3;

39.3
date     91.09.25.15.17.31;  author chrisg;  state Exp;
branches ;
next     39.2;

39.2
date     91.08.29.11.38.16;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     91.08.27.16.46.45;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.19.51;  author chrisg;  state Exp;
branches ;
next     38.2;

38.2
date     91.08.21.13.49.11;  author spence;  state Exp;
branches ;
next     38.1;

38.1
date     91.07.22.14.57.33;  author spence;  state Exp;
branches ;
next     38.0;

38.0
date     91.06.14.11.23.35;  author spence;  state Exp;
branches ;
next     37.3;

37.3
date     91.05.20.11.13.08;  author chrisg;  state Exp;
branches ;
next     37.2;

37.2
date     91.05.02.12.57.04;  author chrisg;  state Exp;
branches ;
next     37.1;

37.1
date     91.05.01.13.52.37;  author spence;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.19.57;  author spence;  state Exp;
branches ;
next     36.104;

36.104
date     91.01.07.14.28.25;  author spence;  state Exp;
branches ;
next     36.103;

36.103
date     90.12.06.13.49.23;  author bart;  state Exp;
branches ;
next     36.102;

36.102
date     90.11.16.16.32.43;  author spence;  state Exp;
branches ;
next     36.101;

36.101
date     90.09.11.16.04.12;  author bart;  state Exp;
branches ;
next     36.100;

36.100
date     90.08.23.14.04.42;  author bart;  state Exp;
branches ;
next     36.99;

36.99
date     90.07.27.16.58.18;  author bart;  state Exp;
branches ;
next     36.98;

36.98
date     90.07.20.22.53.17;  author bart;  state Exp;
branches ;
next     36.97;

36.97
date     90.07.20.18.11.06;  author bart;  state Exp;
branches ;
next     36.96;

36.96
date     90.07.20.17.53.22;  author bart;  state Exp;
branches ;
next     36.95;

36.95
date     90.07.20.14.21.49;  author bart;  state Exp;
branches ;
next     36.94;

36.94
date     90.07.19.00.13.05;  author bart;  state Exp;
branches ;
next     36.93;

36.93
date     90.07.18.22.31.11;  author bart;  state Exp;
branches ;
next     36.92;

36.92
date     90.07.18.22.17.38;  author bart;  state Exp;
branches ;
next     36.91;

36.91
date     90.07.18.20.26.36;  author bart;  state Exp;
branches ;
next     36.90;

36.90
date     90.07.17.18.29.18;  author bart;  state Exp;
branches ;
next     36.89;

36.89
date     90.05.02.11.04.31;  author bart;  state Exp;
branches ;
next     36.88;

36.88
date     90.04.19.14.37.51;  author bart;  state Exp;
branches ;
next     36.87;

36.87
date     90.03.28.09.10.52;  author bart;  state Exp;
branches ;
next     36.86;

36.86
date     89.11.21.10.56.19;  author bart;  state Exp;
branches ;
next     36.85;

36.85
date     89.05.09.15.20.03;  author bart;  state Exp;
branches ;
next     36.84;

36.84
date     89.05.09.13.14.58;  author bart;  state Exp;
branches ;
next     36.83;

36.83
date     89.04.29.15.42.13;  author bart;  state Exp;
branches ;
next     36.82;

36.82
date     89.04.28.19.32.01;  author bart;  state Exp;
branches ;
next     36.81;

36.81
date     89.04.13.12.29.02;  author bart;  state Exp;
branches ;
next     36.80;

36.80
date     89.03.17.18.20.52;  author bart;  state Exp;
branches ;
next     36.79;

36.79
date     89.03.16.14.04.54;  author bart;  state Exp;
branches ;
next     36.78;

36.78
date     89.03.09.11.14.37;  author bart;  state Exp;
branches ;
next     36.77;

36.77
date     89.03.06.22.09.12;  author bart;  state Exp;
branches ;
next     36.76;

36.76
date     89.03.03.11.01.30;  author bart;  state Exp;
branches ;
next     36.75;

36.75
date     89.03.02.18.30.19;  author bart;  state Exp;
branches ;
next     36.74;

36.74
date     89.03.01.12.53.21;  author bart;  state Exp;
branches ;
next     36.73;

36.73
date     89.02.28.14.40.51;  author bart;  state Exp;
branches ;
next     36.72;

36.72
date     89.02.24.16.11.34;  author bart;  state Exp;
branches ;
next     36.71;

36.71
date     89.02.24.09.43.24;  author bart;  state Exp;
branches ;
next     36.70;

36.70
date     89.02.17.22.03.54;  author bart;  state Exp;
branches ;
next     36.69;

36.69
date     89.02.17.11.54.35;  author bart;  state Exp;
branches ;
next     36.68;

36.68
date     89.02.16.10.08.11;  author bart;  state Exp;
branches ;
next     36.67;

36.67
date     89.02.15.16.06.25;  author bart;  state Exp;
branches ;
next     36.66;

36.66
date     89.02.15.13.06.41;  author bart;  state Exp;
branches ;
next     36.65;

36.65
date     89.02.14.18.22.36;  author bart;  state Exp;
branches ;
next     36.64;

36.64
date     89.02.14.10.12.53;  author bart;  state Exp;
branches ;
next     36.63;

36.63
date     89.02.13.18.05.27;  author bart;  state Exp;
branches ;
next     36.62;

36.62
date     89.02.01.17.52.34;  author bart;  state Exp;
branches ;
next     36.61;

36.61
date     89.02.01.17.37.44;  author bart;  state Exp;
branches ;
next     36.60;

36.60
date     89.02.01.11.23.14;  author bart;  state Exp;
branches ;
next     36.59;

36.59
date     89.02.01.11.14.13;  author bart;  state Exp;
branches ;
next     36.58;

36.58
date     89.01.31.18.24.02;  author bart;  state Exp;
branches ;
next     36.57;

36.57
date     89.01.31.17.13.41;  author bart;  state Exp;
branches ;
next     36.56;

36.56
date     89.01.31.15.38.54;  author bart;  state Exp;
branches ;
next     36.55;

36.55
date     89.01.26.11.10.57;  author bart;  state Exp;
branches ;
next     36.54;

36.54
date     89.01.24.15.37.59;  author bart;  state Exp;
branches ;
next     36.53;

36.53
date     89.01.23.13.22.28;  author bart;  state Exp;
branches ;
next     36.52;

36.52
date     89.01.23.13.18.44;  author bart;  state Exp;
branches ;
next     36.51;

36.51
date     89.01.23.11.52.58;  author bart;  state Exp;
branches ;
next     36.50;

36.50
date     89.01.23.11.48.54;  author bart;  state Exp;
branches ;
next     36.49;

36.49
date     89.01.19.17.28.19;  author bart;  state Exp;
branches ;
next     36.48;

36.48
date     89.01.19.10.25.43;  author bart;  state Exp;
branches ;
next     36.47;

36.47
date     89.01.18.13.54.28;  author bart;  state Exp;
branches ;
next     36.46;

36.46
date     89.01.17.16.08.08;  author bart;  state Exp;
branches ;
next     36.45;

36.45
date     89.01.17.15.55.09;  author bart;  state Exp;
branches ;
next     36.44;

36.44
date     89.01.16.15.49.58;  author bart;  state Exp;
branches ;
next     36.43;

36.43
date     89.01.13.12.40.26;  author bart;  state Exp;
branches ;
next     36.42;

36.42
date     88.10.17.15.07.46;  author bart;  state Exp;
branches ;
next     36.41;

36.41
date     88.10.06.14.12.31;  author bart;  state Exp;
branches ;
next     36.40;

36.40
date     88.10.05.15.24.14;  author bart;  state Exp;
branches ;
next     36.39;

36.39
date     88.10.05.13.20.50;  author bart;  state Exp;
branches ;
next     36.38;

36.38
date     88.10.04.14.54.04;  author bart;  state Exp;
branches ;
next     36.37;

36.37
date     88.10.03.15.16.02;  author bart;  state Exp;
branches ;
next     36.36;

36.36
date     88.10.03.10.52.45;  author bart;  state Exp;
branches ;
next     36.35;

36.35
date     88.09.21.17.05.08;  author bart;  state Exp;
branches ;
next     36.34;

36.34
date     88.09.16.01.05.37;  author bart;  state Exp;
branches ;
next     36.33;

36.33
date     88.09.16.00.03.54;  author bart;  state Exp;
branches ;
next     36.32;

36.32
date     88.09.13.17.01.47;  author bart;  state Exp;
branches ;
next     36.31;

36.31
date     88.09.12.12.36.11;  author bart;  state Exp;
branches ;
next     36.30;

36.30
date     88.09.12.12.29.24;  author bart;  state Exp;
branches ;
next     36.29;

36.29
date     88.09.11.14.00.23;  author bart;  state Exp;
branches ;
next     36.28;

36.28
date     88.08.12.13.18.20;  author bart;  state Exp;
branches ;
next     36.27;

36.27
date     88.08.09.14.30.17;  author bart;  state Exp;
branches ;
next     36.26;

36.26
date     88.08.19.10.27.36;  author bart;  state Exp;
branches ;
next     36.25;

36.25
date     88.07.25.14.45.14;  author bart;  state Exp;
branches ;
next     36.24;

36.24
date     88.07.25.14.39.22;  author bart;  state Exp;
branches ;
next     36.23;

36.23
date     88.07.23.17.08.55;  author bart;  state Exp;
branches ;
next     36.22;

36.22
date     88.07.23.13.57.31;  author dale;  state Exp;
branches ;
next     36.21;

36.21
date     88.07.13.22.23.45;  author dale;  state Exp;
branches ;
next     36.20;

36.20
date     88.06.30.21.51.42;  author bart;  state Exp;
branches ;
next     36.19;

36.19
date     88.06.28.17.00.49;  author bart;  state Exp;
branches ;
next     36.18;

36.18
date     88.06.28.16.00.13;  author bart;  state Exp;
branches ;
next     36.17;

36.17
date     88.06.28.15.54.47;  author bart;  state Exp;
branches ;
next     36.16;

36.16
date     88.06.23.18.03.36;  author bart;  state Exp;
branches ;
next     36.15;

36.15
date     88.06.16.12.02.52;  author bart;  state Exp;
branches ;
next     36.14;

36.14
date     88.06.13.16.36.26;  author bart;  state Exp;
branches ;
next     36.13;

36.13
date     88.06.10.11.53.21;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     88.05.02.19.02.16;  author dale;  state Exp;
branches ;
next     36.11;

36.11
date     88.05.02.17.37.17;  author dale;  state Exp;
branches ;
next     36.10;

36.10
date     88.06.02.15.17.43;  author bart;  state Exp;
branches ;
next     36.9;

36.9
date     88.05.01.23.18.52;  author dale;  state Exp;
branches ;
next     36.8;

36.8
date     88.04.25.13.44.56;  author bart;  state Exp;
branches ;
next     36.7;

36.7
date     88.04.25.13.40.38;  author bart;  state Exp;
branches ;
next     36.6;

36.6
date     88.05.24.17.52.37;  author bart;  state Exp;
branches ;
next     36.5;

36.5
date     88.05.24.17.08.22;  author bart;  state Exp;
branches ;
next     36.4;

36.4
date     88.04.12.10.27.37;  author dale;  state Exp;
branches ;
next     36.3;

36.3
date     88.03.14.14.24.55;  author dale;  state Exp;
branches ;
next     36.2;

36.2
date     88.03.10.20.42.10;  author dale;  state Exp;
branches ;
next     36.1;

36.1
date     88.03.10.16.11.54;  author dale;  state Exp;
branches ;
next     ;


desc
@@


39.23
log
@IF buildvp returned a MVP_OFF_BOTTOM, then free the vp->DspIns instructions
and set vp->DspIns to NULL.
@
text
@
/******************************************************************************
*
*	$Id: makevp.c,v 39.22 92/08/06 11:31:12 spence Exp Locker: spence $
*
******************************************************************************/


/* graphics  kernel routines */

    #include "/displayinfo.h"
    #include "/displayinfo_internal.h"
    #include "/vp_internal.h"
    #include "/gfx.h"
    #include "/gfxbase.h"
    #include "/display.h"
    #include "/copper.h"
    #include "/view.h"
    #include "/macros.h"
    #include "/gfxpragmas.h"
    #include "tune.h"
    #include "c.protos"
    #include "/d/d.protos"

#define USEGBDEBUG
/*#define DEBUG*/
/*#define WACKDEBUG*/

#ifdef USEGBDEBUG
#define GBDEBUG if (GBASE->Debug)
#else
#define GBDEBUG
#endif

#ifdef DEBUG
#define D(x) {GBDEBUG {x};}
#else
#define D(x)
#endif

#ifdef WACKDEBUG
#define WACK Debug()
#else
#define WACK
#endif

/* From the old makevp.c ..... */

ULONG new_mode(struct ViewPort *vp)
{
    ULONG  modes = vp->Modes;
    struct ColorMap *cm = vp->ColorMap;
    struct DisplayInfoRecord   *record;
	
    D(kprintf("new_mode() - modes = 0x%lx, cm = 0x%lx\n", modes, cm);)

    if ((cm && cm->Type) &&
        ((record = cm->CoerceDisplayInfo)|| (record = cm->NormalDisplayInfo)))
    {
	modes = record->rec_Control; /* v1.4 modes */
	D(kprintf("take record->Control, modes = 0x%lx, CDI = 0x%lx, NDI = 0x%lx\n",
	           modes, cm->CoerceDisplayInfo, cm->NormalDisplayInfo);)
    }
    else
    {
	D(kprintf("mask modes\n");)
	if(modes & EXTENDED_MODE)
	{            /* 8      8      4       4   = 8C0C */
	    modes &= (HIRES | HAM | DUALPF | LACE | DOUBLESCAN | ((vp->Modes & DUALPF) ? PF2PRI : 0));
	}
    }

    return(modes);
}

unsigned short check_genlock(struct ColorMap *cm,int i)
{
	if ( cm && cm->Type && (cm->Flags & COLORMAP_TRANSPARENCY))
		return(((UWORD *)cm->ColorTable)[i] & 0x8000);
	else
		return (0);
}

ULONG CleanMode(ULONG mode)
{
    if (!(mode & EXTENDED_MODE))
    {
	mode &= ~(SPRITES | VP_HIDE | GENLOCK_AUDIO | GENLOCK_VIDEO);
    }
    else
    {
	if ((mode & MONITOR_ID_MASK) == EXTENDED_MODE)
	{
		mode &= ~EXTENDED_MODE;
		D(kprintf("New mode = 0x%lx\n", mode); WACK;)
	}
    }
    return(mode);
}

ULONG __regargs RealVPModeID(struct ViewPort *vp, struct View *v)
{
    struct ColorMap *cm;
    ULONG mode = INVALID_ID;

    if ((cm = vp->ColorMap) && (cm->Type))
    {
	struct DisplayInfoRecord *record;
	if ((record = cm->CoerceDisplayInfo) || (record = cm->NormalDisplayInfo))
	{
		D(kprintf("Coerced ");)
		mode = (record->rec_MajorKey << 16) | record->rec_MinorKey;
	}
    }

    if (mode == INVALID_ID)
    {
	if ((mode = CleanMode(gfx_GetVPModeID(vp))) == INVALID_ID)
	{
		mode = CleanMode(new_mode(vp));

		/* If there is no ViewExtra, then we don't want to
		 * promote the ViewPort, so specifically use the
		 * PAL or NTSC monitors.
		 */
		if (!(v->Modes & EXTEND_VSTRUCT))
		{
			mode |= ((GBASE->Flags & PAL) ? PAL_MONITOR_ID : NTSC_MONITOR_ID);
		}
	}
    }

    return(mode);
}

void __regargs AttachVecTable(struct ViewPortExtra *vpe, struct VecInfo *vinfo, ULONG ID)
{
    struct VecInfo v;

    D(kprintf("AttachVecTable(0x%lx, 0x%lx, 0x%lx)\n", vpe, vinfo, ID);)
    if (vinfo == NULL)
    {
	if (gfx_GetDisplayInfoData(NULL, (APTR)&v, sizeof(struct VecInfo), DTAG_VEC, ID))
	{
		vinfo = &v;
	}
    }
    if (vinfo)
    {
    	if ((vpe->VecTable = vinfo->Vec) == NULL)
    	{
    		/* must have been a disk-based monitor. Do the best we can. */
		D(kprintf("find the best we can.\n");)
    		vpe->VecTable = GetVecTable(NULL, NULL);
    	}
	D(kprintf("VecTable = 0x%lx\n", vpe->VecTable);)
    }
}

/*******************************************************************************/

/* MakeVPort() is now data driven, using the data in the new (V39) ProgInfo
 * and VecInfo structures.
 */

ULONG __asm MakeVPort(register __a0 struct View *v, register __a1 struct ViewPort *vp)
{
    struct ViewPortExtra *vpe = NULL;
    ULONG err;
    ULONG mode;
    struct VecInfo vinfo;
    struct BuildData bd;		/* workspace */

	GBASE->SpecialCounter++;	/* invalidate copper list caches */

    D(kprintf("In MakeVP() - View = 0x%lx, ViewPort = 0x%lx ctr=%ld\n", v, vp,GBASE->SpecialCounter);)


    if (v && vp)	/* let's be reasonable */
    {
	/* If this ViewPort is being coerced to a different mode, get the
	 * modeid from the coercion, else use getvpmodeid().
	 */

	mode = RealVPModeID(vp, v);
	D(kprintf("Mode = 0x%lx\n", mode); WACK;)
	if ((vp->ColorMap) && (vp->ColorMap->Type))
	{
		vpe = vp->ColorMap->cm_vpe;
	}

	/* Find the VecInfo associated with this ViewPort's mode */

	if (gfx_GetDisplayInfoData(NULL, (UBYTE *)&vinfo, sizeof(struct VecInfo), DTAG_VEC, mode))
	{
		struct ProgInfo *pinfo = (struct ProgInfo *)vinfo.Data;
		char **makeit;
		int (*nextone)();
		BOOL go = TRUE;

		makeit = (GetVecTable(vp, &vinfo))->BuildVP;
		D(kprintf("VecTable = 0x%lx\n", GetVecTable(vp, &vinfo));)
		D(kprintf("makeit = 0x%lx\n", makeit);)

		/* first in the list is the Initialisation code, last one
		 * is the cleanup code.
		 */
		nextone = (int (*)())(*makeit++);
		if ((err = ((*nextone)(v, vp, &vpe, pinfo, &bd) & 0xFFFF)) == MVP_OK)
		{
			D(kprintf("vpe->Flags = 0x%lx=\n", vpe->Flags);)
			if (vpe->VecTable == NULL)
			{
				AttachVecTable(vpe, &vinfo, mode);
			}

			while (go && (nextone = (int (*)())(*makeit)))
			{
				if ((err = ((*nextone)(v, vp, vpe) & 0xFFFF)) == MVP_OK)
				{
					makeit++;
				}
				else
				{
					go = FALSE;
				}
			}
		}
		else
		{
			D(kprintf("Wot no InitMVP()???\n"); WACK;)
		}

		/* look for the cleanup routine */
		if (*makeit)
		{
			/* didn't go through to the end */
			while (*makeit)
			{
				nextone = (int (*)())(*makeit++);
			}
			(*nextone)(v, vp, vpe);
		}
	}
	else
	{
		D(kprintf("*** ARGHHH! SHIT! Where's the bleedin' VecInfo eh?\n"); WACK;)
	}
    }

    /* Check for our special case. This happens if the ViewPort is totally off the
     * bottom of the display, which can happen with attached screens, MoveScreen(),
     * or changing the DyOffset manually.
     *
     * We have to return MVP_OK in this case, but also free and NULL out the
     * ViewPort->DspIns. We cannot use the FreeVPortCopList() because that will
     * also free the UserCopperLists.
     */
    if (err == MVP_OFF_BOTTOM)
    {
    	err = MVP_OK;
	freecoplist(vp->DspIns);
	vp->DspIns = NULL;	/* ensure MrgCop() does not use any old copper lists */
    }

    return(err);

}
@


39.22
log
@RealVPModeID() specifically uses NTSC/PAL MONITOR_IDs if the View has
no ViewExtra. This prevents custom ViewPorts and Views from being promoted.
@
text
@d4 1
a4 1
*	$Id: makevp.c,v 39.21 92/07/21 14:45:30 spence Exp Locker: spence $
d249 15
@


39.21
log
@new_mode() no longer clears the Hires bit of a SuperHires screen. Was
causing MakeVPort() to fail with a ModeID of 0x20
@
text
@d4 1
a4 1
*	$Id: makevp.c,v 39.20 92/05/13 11:29:03 spence Exp Locker: spence $
d101 1
a101 1
ULONG __regargs RealVPModeID(struct ViewPort *vp)
d121 9
d185 1
a185 1
	mode = RealVPModeID(vp);
@


39.20
log
@AttachVecTable() uses GetVecTable() instead of correct_driver().
@
text
@d4 1
a4 1
*	$Id: makevp.c,v 39.19 92/05/05 14:51:38 spence Exp Locker: spence $
a69 4
	}
	else
	{
	    modes &= ((vp->Modes & SUPERHIRES)? ~HIRES : ~0);
@


39.19
log
@killed VP_LAST
@
text
@d4 1
a4 1
*	$Id: makevp.c,v 39.18 92/05/05 12:14:05 chrisg Exp Locker: spence $
d149 1
a149 2
    		correct_driver(vinfo);
    		vpe->VecTable = vinfo->Vec;
d197 2
@


39.18
log
@ regargs+specialctr + VP_LAST bit.
@
text
@d4 1
a4 1
*	$Id: makevp.c,v 39.17 92/02/26 11:32:49 spence Exp Locker: chrisg $
d92 1
a92 1
	mode &= ~(SPRITES | VP_HIDE | GENLOCK_AUDIO | GENLOCK_VIDEO | VP_LAST);
@


39.17
log
@All GFX calls go through LVO
@
text
@d4 1
a4 1
*	$Id: makevp.c,v 39.16 92/02/25 14:25:55 spence Exp Locker: spence $
d92 1
a92 1
	mode &= ~(SPRITES | VP_HIDE | GENLOCK_AUDIO | GENLOCK_VIDEO);
d105 1
a105 1
ULONG RealVPModeID(struct ViewPort *vp)
d131 1
a131 1
void AttachVecTable(struct ViewPortExtra *vpe, struct VecInfo *vinfo, ULONG ID)
d162 1
a162 1
ULONG makevport(struct View *v, struct ViewPort *vp)
d170 4
a173 1
    D(kprintf("In MakeVP() - View = 0x%lx, ViewPort = 0x%lx\n", v, vp); WACK;)
@


39.16
log
@removed InitBuildData() (now done in InitMVP())
Better error handling for the driver routines.

@
text
@d4 1
a4 1
*	$Id: makevp.c,v 39.15 92/01/29 16:49:13 spence Exp Locker: spence $
d20 1
d122 1
a122 1
	if ((mode = CleanMode(getvpmodeid(vp))) == INVALID_ID)
d138 1
a138 1
	if (GetDisplayInfoData(NULL, (APTR)&v, sizeof(struct VecInfo), DTAG_VEC, ID))
d187 1
a187 1
	if (GetDisplayInfoData(NULL, (UBYTE *)&vinfo, sizeof(struct VecInfo), DTAG_VEC, mode))
@


39.15
log
@Added RealVPModeID()
@
text
@d4 1
a4 1
*	$Id: makevp.c,v 39.14 92/01/07 16:06:37 spence Exp Locker: spence $
a86 27
void InitBuildData(struct BuildData *bd, struct ViewPort *vp, struct ViewExtra *ve)
{
    bd->bplcon0 = 0;
    bd->bplcon2 = 0;
    bd->bplcon3 = 0;
    bd->Flags = 0;
    bd->Offset = 0;
    bd->Offset2 = 0;
    bd->ToViewY = 0;

    if(ve && ve->Monitor)
    {
	bd->mspc = ve->Monitor;
    }
    else
    {
	bd->mspc = GBASE->default_monitor;
    }

    if ((new_mode(vp) & (DOUBLESCAN | LACE)) == LACE)
    {
	bd->ToViewY = 1;
	bd->bplcon0 |= LACE;
	bd->Flags |= BD_IS_LACE;
    }
}

a163 1
    struct ViewExtra *ve = NULL;
d199 1
a199 1
		if ((err = ((*nextone)(v, vp, &vpe, pinfo) & 0xFFFF)) == MVP_OK)
a201 4
			if (v->Modes & EXTEND_VSTRUCT)
			{
				ve = (struct ViewExtra *)GfxLookUp(v);
			}
a206 4
			vpe->DriverData[0] = (APTR)&bd;
			InitBuildData(&bd, vp, ve);
			bd.pinfo = pinfo;

d222 11
@


39.14
log
@gfxlookup -> GfxLookUp
@
text
@d4 1
a4 1
*	$Id: makevp.c,v 39.13 91/12/31 16:04:43 spence Exp Locker: spence $
d54 2
d60 2
d65 1
d131 26
a191 1
    struct ColorMap *cm;
d193 1
a193 1
    ULONG mode = INVALID_ID;
d205 3
a207 1
	if ((cm = vp->ColorMap) && (cm->Type))
d209 1
a209 15
		struct DisplayInfoRecord *record;
		vpe = cm->cm_vpe;
		if ((record = cm->CoerceDisplayInfo) || (record = cm->NormalDisplayInfo))
		{
			D(kprintf("Coerced ");)
			mode = (record->rec_MajorKey << 16) | record->rec_MinorKey;
		}
	}

	if (mode == INVALID_ID)
	{
		if ((mode = CleanMode(getvpmodeid(vp))) == INVALID_ID)
		{
			mode = CleanMode(new_mode(vp));
		}
a210 1
	D(kprintf("Mode = 0x%lx\n", mode); WACK;)
@


39.13
log
@MakeVP() was passing an unitialised *ViewExtra pointer to INitBuildData()
if v->Modes did not have the EXTENDED bit set.
@
text
@d4 1
a4 1
*	$Id: makevp.c,v 39.12 91/11/18 11:31:10 spence Exp Locker: spence $
d215 1
a215 1
				ve = (struct ViewExtra *)gfxlookup(v);
@


39.12
log
@Checks for (DOUBLESCAN | LACE) == LACE before setting up for lace mode.
@
text
@d4 1
a4 1
*	$Id: makevp.c,v 39.11 91/11/11 11:47:46 chrisg Exp Locker: spence $
d160 1
a160 2
    struct ViewExtra *ve;
    struct DisplayInfoRecord *record;
d177 1
@


39.11
log
@changed usage of transparencybits.
@
text
@d4 1
a4 1
*	$Id: makevp.c,v 39.10 91/11/08 11:55:49 chrisg Exp Locker: chrisg $
d62 1
a62 1
	{            /* 8      8      4       4   = 8C04 */
d101 1
a101 1
    if (new_mode(vp) & LACE)
@


39.10
log
@  removed get_dbytes (no longer used anywhere)
@
text
@d4 1
a4 1
*	$Id: makevp.c,v 39.9 91/10/30 19:20:19 spence Exp Locker: chrisg $
d77 3
a79 7
	{
		unsigned short *genlock_bits = cm->TransparencyBits;
		unsigned short mask = 0x8000;
		if (genlock_bits[i>>4] & (mask>>(i & 15)))
				return (mask);	/* mask happens to be 0x8000 */
	}
	return (0);
@


39.9
log
@Get makeit lists from GetVecTable().
@
text
@d1 1
d4 1
a4 1
*	$Id: makevp.c,v 39.8 91/10/29 11:34:23 spence Exp Locker: spence $
a71 24
}

short __regargs get_dbytes(struct ViewPort *vp, short fstart, short fstop)
{
    short dbytes;
    ULONG  modes = new_mode(vp);

    if (modes      & SUPERHIRES)
    {
	dbytes = (0xfffc & (6 + ((fstop-fstart)>>1)))<<1;
    }
    else
    {
	if (modes     & HIRES)
	{
		dbytes = 0xfffc & (6 + ((fstop-fstart)>>1));
	}
	else
	{
		dbytes = 2 + ( (fstop - fstart)>>2 );
	}
    }

    return(dbytes);
@


39.8
log
@replace vpe->BuildData with vpe->DriverData[0]
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 39.7 91/10/28 19:36:50 spence Exp Locker: spence $
d20 1
d215 4
a218 1
		mode = CleanMode(getvpmodeid(vp));
a225 1
		extern void *VecLists[];
d231 1
a231 9
		if (vinfo.Vec)
		{
			makeit = ((struct VecTable *)(vinfo.Vec))->BuildVP;
		}
		else
		{
			/* salvage the best from the ROM */
			makeit = (((struct VecTable *)(VecLists[pinfo->MakeItType]))->BuildVP);
		}
@


39.7
log
@AttachVecTable() - if vinfo->Vec == NULL (diskbased monitor), call
correct_driver() for best default.
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 39.6 91/10/18 18:42:17 spence Exp Locker: spence $
d254 1
a254 1
			vpe->BuildData = &bd;
@


39.6
log
@....check it in properly this time.....
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 39.4 91/10/17 14:00:03 chrisg Exp Locker: spence $
d156 1
d166 8
a173 1
    	vpe->VecTable = vinfo->Vec;
d222 1
d224 1
a224 1
		char **makeit = ((struct VecTable *)(vinfo.Vec))->BuildVP;
d227 10
@


39.5
log
@ProgInfo -> VecInfo
@
text
@d108 1
a108 1
void InitBuildData(struct BuildData *bd, struct ViewExtra *ve)
d126 7
d236 1
a236 7
			InitBuildData(&bd, ve);
			if (new_mode(vp) & LACE)
			{
				bd.ToViewY = 1;
				bd.bplcon0 |= LACE;
				bd.Flags |= BD_IS_LACE;
			}
@


39.4
log
@killed typedef
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 39.3 91/09/25 15:17:31 chrisg Exp Locker: chrisg $
d110 1
d116 1
d145 17
d165 1
a165 1
 * structure.
d176 1
a176 1
    struct ProgInfo pinfo;
d203 1
a203 1
	/* Find the ProgInfo associated with this ViewPort's mode */
d205 1
a205 1
	if (GetDisplayInfoData(NULL, (UBYTE *)&pinfo, sizeof(struct ProgInfo), DTAG_PROG, mode))
d207 2
a208 1
		char **makeit = pinfo.MakeIt;
d216 1
a216 1
		if ((err = ((*nextone)(v, vp, &vpe, &pinfo) & 0xFFFF)) == MVP_OK)
d218 1
d223 5
d230 8
d257 1
a257 1
		D(kprintf("*** ARGHHH! SHIT! Where's the bleedin' ProgInfo eh?\n"); WACK;)
@


39.3
log
@made new_mode pass scan-doubling bit through.
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 39.2 91/08/29 11:38:16 spence Exp Locker: chrisg $
d108 1
a108 1
void InitBuildData(BuildData *bd, struct ViewExtra *ve)
d158 1
a158 1
    BuildData bd;		/* workspace */
@


39.2
log
@Makevp() take the ViewPort mode from coerced info if available.
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 39.1 91/08/27 16:46:45 spence Exp Locker: spence $
d61 1
a61 1
	    modes &= (HIRES | HAM | DUALPF | LACE | ((vp->Modes & DUALPF) ? PF2PRI : 0));
@


39.1
log
@InitBuildData() and CleanMode() for ScrollVP()
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 39.0 91/08/21 17:19:51 chrisg Exp Locker: spence $
d140 1
d153 2
d156 1
a156 1
    ULONG mode = CleanMode(getvpmodeid(vp));
d160 1
a160 1
    D(kprintf("In MakeVP() - View = 0x%lx, ViewPort = 0x%lx, mode = 0x%lx\n", v, vp, mode); WACK;)
a161 3
    if ((vp->ColorMap) && (vp->ColorMap->Type))
	vpe = vp->ColorMap->cm_vpe;

d164 20
d200 1
a200 1
				ve = gfxlookup(v);
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 38.2 91/08/21 13:49:11 spence Exp Locker: chrisg $
d22 1
a22 1
/*#define USEGBDEBUG*/
d108 33
d144 1
a144 1
/* MakeVPort() is now data driven, using the data in the new (V38) ProgInfo
d153 1
a153 1
    ULONG mode = getvpmodeid(vp);
a161 13
    if (!(mode & EXTENDED_MODE))
    {
	mode &= ~(SPRITES | VP_HIDE | GENLOCK_AUDIO | GENLOCK_VIDEO);
    }
    else
    {
	if ((mode & MONITOR_ID_MASK) == EXTENDED_MODE)
	{
		mode &= ~EXTENDED_MODE;
		D(kprintf("New mode = 0x%lx\n", mode); WACK;)
	}
    }

d172 5
a176 1
		if (InitMVP(v, vp, &vpe, &pinfo) == MVP_OK)
a177 3
			vpe->BuildData = &bd;
			bd.bplcon2 = bd.bplcon3 = bd.Flags = bd.Offset = bd.Offset2 = 0;
			bd.mspc = GBASE->default_monitor;
d180 1
a180 4
				if((ve = (struct ViewExtra *) gfxlookup(v)) && ve->Monitor)
				{
					bd.mspc = ve->Monitor;
				}
d182 2
a194 1
			CleanUpMVP(v, vp, vpe);
@


38.2
log
@use gfxlookup instead of GfxLookUp.
Clear a few more BuildData entries on the stack.
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 38.1 91/07/22 14:57:33 spence Exp Locker: spence $
@


38.1
log
@returns a ULONG error for lowmemory situations.
Uses a buffer on the stack instead of allocating one.
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 38.0 91/06/14 11:23:35 spence Exp Locker: spence $
d155 1
a155 1
			bd.bplcon2 = bd.Flags = 0;
d159 1
a159 1
				if((ve = (struct ViewExtra *) GfxLookUp(v)) && ve->Monitor)
@


38.0
log
@New Look, data-driven MakeVP().
Old code is in oldmakevp.c on sleeponit, (and under RCS, of course).
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 37.3 91/05/20 11:13:08 chrisg Exp Locker: spence $
d115 1
a115 1
void makevport(struct View *v, struct ViewPort *vp)
a116 1
    struct ProgInfo pinfo;
d118 2
d121 2
d154 10
d166 1
a166 1
				if (((*nextone)(v, vp, vpe) & 0xFFFF) == MVP_OK)
d187 3
@


37.3
log
@Added prototypes, improved warnings, and glue code. still needs work.
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 1.1 91/05/20 10:42:03 chrisg Exp $
a6 1
#define BUGGY_HARDWARE
a8 18
#include <exec/types.h>
#include <exec/nodes.h>
#include <exec/lists.h>
#include <exec/interrupts.h> 
#include <exec/libraries.h>
#include <exec/memory.h>
#include <graphics/gfx.h>
#include <graphics/gfxbase.h>
#include <graphics/display.h>
#include <graphics/copper.h>
#include <graphics/view.h>
#include "tune.h"
#include <hardware/intbits.h>
#include <hardware/custom.h>
#include "/macros.h"
#include "/displayinfo_internal.h"

#define BATCH_MODE
d10 11
a20 7
#ifdef  BATCH_MODE
#ifndef  UTILITY_TAGITEM_H
#include <utility/tagitem.h>
#endif
#endif

#include "c.protos"
d22 1
a22 3
#define DENISE_OFFSET	9

/*#define SAS_DEBUG*/
d24 1
a24 3
/*#define DEBUGDEBUG*/
/*#define MEMDEBUG*/
#define MAX_COLORS	32
d26 5
a30 14
#define HFIX(x)	(((x)*mspc->ratioh)>>4)
#define VFIX(y)	(((y)*mspc->ratiov)>>4)

#define NEW_HFIX(x)	((HFIX(x-4))+4)
#define DENISE_HFIX(x) ((HFIX(x-DENISE_OFFSET))+DENISE_OFFSET)

/*static int bplseq[] = { 3,5,1,2,4,0 };*/
			/* the firing order of a 6 cylinder engine */
static USHORT field_pick[6] = { 0xbc00, 0x7c00, 0xdc00, 0xec00,
				0xf400, 0xf800 };

/* to zero the display, no scroll, all sprites */
#define LEFT_EDGE_MAGIC 0x81
struct CopIns *cbump();
d32 5
a36 18
struct CopIns * __regargs clongmove(struct CopList **cl,struct CopIns *c,
									long a,long p,USHORT frame)
/* a = bpl register, p = bitplane address */
{
	/* move 2 words into 2 consecutive locations */
	/* first take care of long frame */
	c->OpCode = COPPER_MOVE|frame;
	c->DESTADDR = a;
	c->DESTDATA = (long)p>>16;
        CBUMP(cl);

        /*CMOVE(c,io->bplpt[i],TOBB((long)p));*/
	c->OpCode = COPPER_MOVE|frame;
	c->DESTADDR = a+2;
	c->DESTDATA = p;
        CBUMP(cl);
	return(c);
}
d38 5
a42 14
struct CopIns * __regargs cshortmove(struct CopList **cl,struct CopIns *c,
					long a,short p,USHORT frame)
/* a = bpl register, p = short something */
{
	/* first take care of long frame */
	c->OpCode = COPPER_MOVE|frame;
	c->DESTADDR = a;
	c->DESTDATA = p;
        CBUMP(cl);

	return(c);
}

extern UWORD dflt_clrs[];
d44 1
a44 1
#include "gs_info.h"
a45 4
extern  struct Custom custom;

#define ALERTGFXNOMEMMAKEVP 0x82010030

d50 4
a53 4
    struct DisplayInfoRecord   *record = NULL;

    if( (cm && cm->Type)
    &&  ((record = cm->CoerceDisplayInfo)|| (record = cm->NormalDisplayInfo)) )
d60 2
a61 2
	{
	    modes &= (0x8C04 | ((vp->Modes & DUALPF)? PF2PRI : 0));
d74 2
a75 2
	short dbytes;
	ULONG  modes = new_mode(vp);
d77 8
a84 5
#ifndef ULTRA_RES
	if (modes      & SUPERHIRES)
	    dbytes = (0xfffc & (6 + ((fstop-fstart)>>1)))<<1;
	else
	    if (modes     & HIRES)
d86 1
d88 1
a88 1
#endif
d90 5
a94 6
#ifdef DEBUG
		kprintf("fstop=%lx fstart=%lx dbytes=%ld\n",
			fstop , fstart,dbytes);
#endif
	return(dbytes);
};
a107 3
UWORD __regargs display_stop(struct MonitorSpec *mspc,UWORD dwstop)
{
	struct GfxBase *GB;
d109 1
a109 1
	FETCHGBASE;
d111 11
a121 11
	if (dwstop > mspc->DeniseMaxDisplayColumn)
	{
	    dwstop = DENISE_OFFSET+1;

	    if (!(GB->ChipRevBits0 & GFXF_HR_DENISE))
	    {
		dwstop += (mspc->DeniseMaxDisplayColumn);
	    }
	}
	return( dwstop );
}
d123 2
a124 29
makevport(view,vp)
struct View *view;
struct ViewPort *vp;
/* generate a set op intermediate copper instructions given a pointer */
/* to a View structure and a ViewPort */
{
    struct ViewExtra *ve=0;
    struct MonitorSpec *mspc=0;
    struct CopList *cl;
    struct CopIns *c;
    short x,y;
    short i;
    short min_ytop;
    short ytop;	/* absolute top of this viewport */
    short ybot;	/* absolute bottom of this viewport */
    short yclip;	/* force clipping of top lines of viewport */
    short depth;
    short mybplcon0;
    unsigned short bplcon3 = 0;
    unsigned short realbplcon0;
    struct Custom *io;
    struct RasInfo *r1,*r2=0;
    struct GfxBase *GB;
    struct gs_info info[2];
    USHORT frame = 0;
    ULONG  modes = new_mode(vp);
    UWORD  lace = (modes & INTERLACE);
    short  lshift = lace?1:0;
	UWORD t1,t2;
d126 7
a132 15
#ifdef NEW_HEDLEY
    struct ViewPort *old_vp=0;
    struct ViewPort hvp;
    struct RasInfo hri;
    struct BitMap hbm;
    struct ColorMap *cm = vp->ColorMap;
#endif

    /*kprintf("MAKEVP(%lx,%lx)\n",view,vp);*/
    FETCHGBASE;

#ifdef BATCH_MODE
    if(cm && cm->Type)
    {
	if(cm->Flags & VIDEOCONTROL_BATCH) /* avoid unneccesary forbids */
d134 2
a135 13
	    struct TagItem *vc;
	    Forbid(); 
	    {
		if(vc = cm->cm_batch_items)
		{
		    if(cm->Flags & VIDEOCONTROL_BATCH)
		    {
			videocontrol(cm,vc); /* process batch */
		    }
		    /* cm->Flags &= ~VIDEOCONTROL_BATCH; */ /* do it again */
		}
	    }
	    Permit();
d137 1
a137 59
    } 
#endif 

	mspc = GB->default_monitor;

	if (view->Modes & EXTEND_VSTRUCT)
	{
	    if((ve = (struct ViewExtra *) gfxlookup(view)) && ve->Monitor)
	    {
		mspc = ve->Monitor;
	    }
	}

	if (mspc->ms_Flags & REQUEST_A2024)
	{
		int width;
		int bpr;	/*bytes per physical row */
		int phys_rows = 200;	/* assume NTSC */
		struct RasInfo *ri = vp->RasInfo;
		struct BitMap *obm = ri->BitMap;
		if (GB->DisplayFlags & PAL)	phys_rows = 256;
		bpr = obm->BytesPerRow;
		width = bpr << 3;
		hvp = *vp;	/* copy whole structure */
		old_vp = vp;
		vp = &hvp;	/* bait and switch */
		vp->ExtendedModes = old_vp->ExtendedModes;
		vp->DxOffset = 0;	/* these are most likely ok */
		vp->DyOffset = 0;
		/* maybe we can support scrolling?, just a thot */
		hri.Next = 0;
		hri.RxOffset = ri->RxOffset; /*old_vp->RasInfo->RxOffset;*/
		hri.RyOffset = ri->RyOffset; /*old_vp->RasInfo->RyOffset;*/
		vp->RasInfo = &hri;
		hri.BitMap = &hbm;
		/* tweek viewport around for degenerate hardware */
		/* user depth of 1 requires cheating with 2 */
		/* user depth of 2 requires cheating with 4 */
		INITBITMAP(&hbm,obm->Depth<<1,width*2,obm->Rows);
		hbm.Planes[0] = obm->Planes[0];
		hbm.Planes[1] = obm->Planes[0]+bpr;
		if (obm->Depth == 2)
		{
			hbm.Planes[2] = obm->Planes[1];
			hbm.Planes[3] = obm->Planes[1]+bpr;
		}
		vp->DHeight = phys_rows;
		if (modes == A2024TENHERTZ_KEY)
		{
			vp->Modes &= ~HIRES;
			vp->DWidth = 352;
			/* view->DxOffset = 0x81-16; */
		}
		else
		{
			vp->DWidth = 512;
			/* view->DxOffset = 0x81; */
		}
	}
d139 3
a141 17
        min_ytop = mspc->min_row ;

	/* hedley support is now done as a variant of interlace */
	/* this is where the hedley stuff used to be */

	/* both must be defined */

	/* define for first frame */
	if (lace)    frame = CPR_NT_LOF;

	if (mspc->ms_Flags & REQUEST_A2024)	frame = field_pick[0];

	/*printf("MAKEVP(%lx,%lx)\n",view,vp);*/
	/* backwards compatibility for a short time */
	r1 = vp->RasInfo;
	if (modes & DUALPF)	r2 = r1->Next;
	io = &custom;
d143 1
a143 9
#ifdef DEBUG
	kprintf("makevp(%lx,%lx) rasinfo=%lx\n",view,vp,r1);
#ifdef DEBUGDEBUG
	Debug();
#endif
#endif

	cl = vp->DspIns = (struct CopList *)copinit(vp->DspIns,DSPINS+32);
	if ( (!cl) || (!cl->MaxCount) )
d145 3
a147 208
		/* Alert(ALERTGFXNOMEMMAKEVP); */ /* does not return */
		return;  /* implement better error handling -- bart */
	}
	c = cl->CopIns;

	depth = r1->BitMap->Depth;
	if (r2) depth += r2->BitMap->Depth;
	else if ((modes & (HAM|EXTRA_HALFBRITE))== 0)
			depth = SHORTMIN(depth,5);

	/* protect the user from stupidity */
	if (modes & HIRES) depth = SHORTMIN(depth,4);
	if (modes & SUPERHIRES) depth = SHORTMIN(depth,2);

	/* wait for correct position on the display */
	/* y is relative to view.DyOffset */
	/* all waits are positioned relative to view.DyOffset during MrgCop */
	/* y if where the display is to begin */
	/* adjust y to leave enough space for copper maneuvers */
	/* if we have more than 4 bit planes then or sprite colors */

	ytop   =     vp->DyOffset;
	ytop  +=  (((mspc->ms_Flags & REQUEST_A2024)?0x2c:view->DyOffset) 
		   << lshift);
	ytop  += lshift;
	ytop >>= lshift;

#ifdef VARIABLE_COPPER_SPACE
	y = -1;	/* need some space for copper instructions */
	if ( (depth>4) && (r2 == 0) ) 
	{
		y--;
	}
	else 
	{
	    if( ( depth > 3 ) || 
	        ( modes & SUPERHIRES) || 
		(!(GB->ChipRevBits0 & GFXF_HR_DENISE)) )
	    {
		if (vp->Modes & SPRITES)    y--;
	    }
	}
#else
	y = -2;	/* need some space for copper instructions */
#endif

#ifdef UNDEFINED
	y += MAX(
		    MIN(lace?(vp->DyOffset>>1):vp->DyOffset,0),
		    (min_ytop- ((mspc->ms_Flags & REQUEST_A2024)?
				0x2c:
				view->DyOffset))
		);
#endif

	y <<= lshift;

	yclip = MIN( ytop - min_ytop, 0 );

	yclip <<= lshift;
	ytop  <<= lshift;

	ybot   = ytop;
	ybot  += vp->DHeight;
#ifdef SAS_DEBUG
	kprintf("in makevp(), ytop = %ld, ybot = %ld\n", ytop, ybot);
#endif
	ytop     -= yclip;

#ifdef NEW_HEDLEY
	/* need an absolute wait position */
	if (mspc->ms_Flags & REQUEST_A2024)
	{
		UWORD t;
		int real_depth;
#define H_OFFSET	0x20
/*#define OLDPIXELALIGN*/
#define NEWPIXELALIGN

#ifdef NEWPIXELALIGN
#define KEYCOLOR	1
#else
#define KEYCOLOR	0
#endif
/*#define H_OFFSET	0x0*/
		short tcolor;
		/*short ypos = 0x28-0x2c;*/
		short ypos = -0x1b+4;	/* 1c in docs */
		/*ypos = -4-3;*/	/* visible control region debug */

		/* to make the sprites work, the output depth */
		/* must always be two */
		/*ypos += 16;*/
		/*real_depth = old_vp->RasInfo->BitMap->Depth;*/
		real_depth = 2;
		/* position 0-127 */
		if (GB->DisplayFlags & PAL)
		{
			ypos += 8;
			ypos += GB->control_delta_pal;
		}
		else
		{
			ypos += GB->control_delta_ntsc;
		}
		CWAIT(c,ypos-9,0);	/* was a -1 */
		CBUMP(&cl);
		CMOVE(c,io->color[0],0xf00);	/* all colors 0 */
		CBUMP(&cl);
#ifdef OLDPIXELALIGN
		CWAIT(c,ypos,0x45);		/* also trigger pixel catcher */
		CBUMP(&cl);
		t = 1; /* F6-4=0,INTERLACE=0 */
		if (modes == A2024TENHERTZ_KEY) t |= 0x800;  /* F6_4 = 1*/
		CMOVE(c,io->color[0],t);
		CBUMP(&cl);
#endif
#ifdef NEWPIXELALIGN
		/* set up real raster */
		c = clongmove(&cl,c,&io->bplpt[0],GB->a2024_sync_raster,0);
		t = 0x15;
		if (GB->DisplayFlags & PAL)
		{
			t += 8;
			t += GB->control_delta_pal;
		}
		else
		{
			t += GB->control_delta_ntsc;
		}
		t <<= 8;		/* move y over to left byte */
		t += 0x61;		/* get x diwstart */
		CMOVE(c,io->diwstrt,t)	/* was 0x1561 for ntsc */
		CBUMP(&cl);
		t &= 0xff00;
		t += 0xd1;
		if (GB->ChipRevBits0 & GFXF_HR_DENISE) t += 0x100;
		CMOVE(c,io->diwstop,t);
		CBUMP(&cl);
		if (GB->ChipRevBits0 & GFXF_HR_DENISE)
		{
			CMOVE(c,io->diwhigh,0x2000); /* must close window */
			CBUMP(&cl);		     /* bart */
		}
		CMOVE(c,io->ddfstrt,0x40);
		CBUMP(&cl);
		CMOVE(c,io->ddfstop,0xd0);
		CBUMP(&cl);
		/* 1 bitplane hires */
		CMOVE(c,io->bplcon0,HIRES|0x1000|0x200);
		CBUMP(&cl);
		t = 1; /* F6-4=0,INTERLACE=0 */
		if (modes == A2024TENHERTZ_KEY) t |= 0x800;  /* F6_4 = 1*/
		CMOVE(c,io->color[1],t);
		CBUMP(&cl);
#endif

		/* position 128-256 0x67*/
		CWAIT(c,ypos,0x5f+H_OFFSET);
		CBUMP(&cl);
		{
			int i;
			t = 4;
			if (modes == A2024TENHERTZ_KEY) t = 6;
			for (i = 0; i<t ; i++)
			{
				tcolor = 0x1;
				if (i & 1)	tcolor |= 0xf00;
				if (i & 2)	tcolor |= 0x0f0;
				if (i & 4)	tcolor |= 0x008;
				c = cshortmove(&cl,c,&io->color[KEYCOLOR],
				tcolor,field_pick[i]); /* quadrant, expand */
			}
		}

		/* position 256-337? 0x87*/
		CWAIT(c,ypos,0x7f+H_OFFSET);
		CBUMP(&cl);
		t = 0x800;		/* for 1 bitplane */
		if (real_depth == 2)	t = 0x8f0;
		CMOVE(c,io->color[KEYCOLOR],t); /* enp1=enp0=1 wpb=0 */
		CBUMP(&cl);

		/* position 340-512 0xa3*/
		CWAIT(c,ypos,0x9f+H_OFFSET);
		CBUMP(&cl);
		t = 0xfff;		/* for two bitplanes */
		if (real_depth == 1)	t = 0xf0f;	/* one plane */
		t = 0xfff;
		/*real_depth = old_vp->RasInfo->BitMap->Depth;*/
		if (old_vp->RasInfo->BitMap->BytesPerRow > 128 - 2)
			t = 0xff1;
		CMOVE(c,io->color[KEYCOLOR],t); /* 0x889 dpl0=dpl1=1,less16=1*/
		CBUMP(&cl);
		CWAIT(c,ypos+1,0);
		CBUMP(&cl);
		CMOVE(c,io->color[0],0x000); /* turn off for rest of display */
		CBUMP(&cl);
#ifdef NEWPIXELALIGN
		CMOVE(c,io->bplcon0,0);
		CBUMP(&cl);
#endif

	}
#endif

	CWAIT(c,HFIX(VFIX(y)-(VFIX(1)>>1)),0); /* bart -- better spacing */
	CBUMP(&cl);
d149 1
a149 54
    /* load up copper list with color stuff */

    if (modes & (DUALPF|HAM))   x = 16;
    else                    x = 1<<(SHORTMIN(5,depth));
	{
    		UWORD   *colors,*colortable;
		unsigned short color;
		short blue_and_clear,colortablecount;
    		if ( cm == 0)
		{
			colortable = dflt_clrs;
			colortablecount = MAX_COLORS;
		}
		else
		{
			colortable = (UWORD *)cm->ColorTable;
			colortablecount = cm->Count;
			if (colortablecount > MAX_COLORS)
				colortablecount = MAX_COLORS;
		}
	if ( (mspc->ms_Flags & REQUEST_A2024) ||
	     (modes & SUPERHIRES) )
	{
		WORD	new_colors[32];
		/* convert colors from users colormap to hedley colors */
#ifdef DEBUg
		kprintf("colortable in = %lx\n",colortable);
#endif
		if (mspc->ms_Flags & REQUEST_A2024)
			convert_to_hedley(colortable,new_colors);
		else
		{
			convert_to_superhires(colortable,new_colors,cm);
		}
#ifdef DEBUg
		kprintf("colortable out= %lx\n",new_colors);
		Debug();
#endif
		colors = new_colors;
		for (i = 0; i<32 ; i++)
		{
			CMOVE(c,io->color[i],*colors++);
			CBUMP(&cl);
		}
	}
	else
	{
		/* let us speed this baby up a bit */
		/* using my intimate knowledge of cbump we can find out */
		/* how many instructions can go into this buffer */
		blue_and_clear = MIN(x,cl->MaxCount - cl->Count)-1;
		i = 0;
		colors = colortable;
		if (blue_and_clear > 0)
d151 1
a151 1
			for (; i < blue_and_clear ; i++)
d153 8
a160 4
				color = *colors++;
				color |= check_genlock(cm,i);
				CMOVE(c,io->color[i],color);
				c++;
d162 1
a162 181
			cl->Count += blue_and_clear;
		}
		
		/* finish the rest slowly */
    		for (;i < x; i++)
    		{
			color = *colors++;
			color |= check_genlock(cm,i);
			CMOVE(c,io->color[i],color);
			CBUMP(&cl);
    		}
    		if (vp->Modes & SPRITES)
			/* this guy needs sprite colors loaded */
			if( (depth < 5) /* already all load up? */
			    || 
			    (modes & (DUALPF|HAM)) /* special? */ )
			{
				/* skip raster colors */
				colortable += 16;
	    			/* have to load up sprite colors */
	    			for(i = 16;i < colortablecount; i++)
	    			{
					color = *colortable++;
					color |= check_genlock(cm,i);
		    			CMOVE(c,io->color[i],color);
		    			CBUMP(&cl);
	    			}
			}
		}
	}

	/* load up dw,dx and other stuff for primary rasinfo/playfield */

	getclipstuff(view,vp,r1,&info[0],yclip);

	ybot += HFIX((~info[0].yxtra) & lshift);
	ytop += info[0].yxtra;
	y    += info[0].yxtra;

#ifdef UNDEFINED
	/* display clip bottom */
	{
	    ybot -= vp->DyOffset+(view->DyOffset<<lshift);
	    ybot = MAXYCLIP( ybot );
	    ybot += vp->DyOffset+(view->DyOffset<<lshift);
	}
#endif

	ytop >>= lshift;
	ybot >>= lshift;


#ifdef DEBUG
    kprintf("diwxstrt = %lx ",info[0].dwxstrt);
#endif
	/* This next value is worng for final release */
	/* I think there is a chip problem */
	/*x = VFIX(0x2b)<<8;*/

	if ( (GB->ChipRevBits0 & GFXF_HR_DENISE) == 0)
	{
	    x = (min_ytop<<8) | (0xff&info[0].dwxstrt);
	}
	else
	{
	    x = (ytop<<8)|(0xff&info[0].dwxstrt);
	}

    	CMOVE(c,io->diwstrt,x);
	CBUMP(&cl);
	/* hopefully sprites are still see able */

	mybplcon0 = GB->system_bplcon0 | ( depth << PLNCNTSHFT ) |
	(view->Modes & INTERLACE) |
	((modes & SUPERHIRES)?0x40:0) |	/* new SUPERHIRES */
#ifdef ULTRA_RES
	(modes & (HOLDNMODIFY|DUALPF) );
#else
	(modes & (HOLDNMODIFY|DUALPF|HIRES) );
#endif

	if (GB->ChipRevBits0 & GFXF_HR_DENISE)
    		realbplcon0 = mybplcon0;
	else	realbplcon0 = (view->Modes&INTERLACE)|(GB->system_bplcon0);

    	x = vp->SpritePriorities;

	/* temp hack */
	if (modes & SUPERHIRES) x >>= 1;

	x |= (modes & PF2PRI);
	
	if (cm && cm->Type)
	{
		if (cm->Flags & COLORMAP_TRANSPARENCY)
			x |= BPLCON2_ZDCTEN;
		if (cm->Flags & COLORPLANE_TRANSPARENCY)
		{
			x |= BPLCON2_ZDBPEN;
			x |= cm->TransparencyPlane <<12;
		}
	}

	if (mspc->BeamCon0 & CSBLANK) /* for new chips */
	{
	    realbplcon0 |= USE_BPLCON3;
	    bplcon3 |= BPLCON3_EXTBLNKEN;   /* EXTBLKEN */
	}

	if(cm && cm->Type)
	{
		if(cm->Flags & BORDER_BLANKING)
		{
		    realbplcon0 |= USE_BPLCON3;
		    bplcon3 |= BPLCON3_BRDNBLNK;
		}
		if(cm->Flags & BORDER_NOTRANSPARENCY)
		{
		    realbplcon0 |= USE_BPLCON3;
		    bplcon3 |= BPLCON3_BRDNTRAN;
		}
	}

	CMOVE(c,io->bplcon0,realbplcon0); CBUMP(&cl);
	CMOVE(c,io->bplcon2,x); CBUMP(&cl);
	if (realbplcon0 & USE_BPLCON3)
	{
	    CMOVE(c,io->bplcon3,bplcon3); CBUMP(&cl);
	}

    /* do stuff for standard view */

    if ( r2 == 0)
    {
	short dbytes,bplmod;
	UWORD my_dwstop,my_dwhigh;
	UBYTE **pptr,*p;
	/* hack for new chips */
	my_dwstop = info[0].dwxstrt + info[0].dw;

	my_dwstop = display_stop( mspc, my_dwstop );

	if ( (GB->ChipRevBits0 & GFXF_HR_DENISE) == 0)
	{
    		CMOVE(c,io->diwstop,(0x7f<<8) | ( 0xff & my_dwstop));
		CBUMP(&cl);
	}
	else
	{
		short ymax = mspc->total_rows;

		/* ECS genlock */
		if(realbplcon0 & (GENLOCK_AUDIO|GENLOCK_VIDEO)) ymax -= 2;

		if (ybot > ymax) ybot = ymax; 

		/* compute diwhigh */
#ifdef SAS_DEBUG
	kprintf("compute diwstop for 1st pf with ybot = %ld\n",ybot);
#endif
		t1 = ((ytop & 0x700) >> 8) | (ybot & 0x700)
			|  ( (my_dwstop & 0x100)<< 5)
			|  ( (info[0].dwxstrt & 0x100) >> 3);

		if(lace)
		{
			c = cshortmove(&cl,c,&io->diwstop,(ybot<<8)|(0xff & my_dwstop),
				CPR_NT_LOF);
			/*c = cshortmove(&cl,c,&io->diwhigh,t,CPR_NT_LOF);*/

			ybot  -= (vp->DHeight&1);

			/* recompute diwhigh */

			t2 = ((ytop & 0x700) >> 8) | (ybot & 0x700)
				|  ( (my_dwstop & 0x100)<< 5)
				|  ( (info[0].dwxstrt & 0x100) >> 3);

			c = cshortmove(&cl,c,&io->diwstop,(ybot<<8)|(0xff & my_dwstop),
				CPR_NT_SHT);
			/*c = cshortmove(&cl,c,&io->diwhigh,t,CPR_NT_SHT);*/
d166 1
a166 3
			CMOVE(c,io->diwstop,(ybot<<8) | ( 0xff & my_dwstop));
			CBUMP(&cl);
			/*CMOVE(c,io->diwhigh,t);  CBUMP(&cl);*/
a168 125

	dbytes = get_dbytes(vp,info[0].dafstrt,info[0].dafstop);

	CMOVE(c,io->ddfstrt,info[0].dafstrt);       CBUMP(&cl);

	CMOVE(c,io->ddfstop,info[0].dafstop);       CBUMP(&cl);

	CMOVE(c,io->bplcon1,(info[0].scroll<<4)|info[0].scroll);        CBUMP(&cl);

	    /* set up bit plane modulos */
	bplmod = info[0].rbytes - dbytes;
	if (view->Modes & lace)
	{
	    bplmod += info[0].rbytes;
	}
	CMOVE(c,io->bpl1mod,bplmod);    CBUMP(&cl);

	if (depth > 1)
	{
	    CMOVE(c,io->bpl2mod,bplmod);    CBUMP(&cl);
	}
	pptr = r1->BitMap->Planes;
#ifdef DEBUG
	kprintf("plnskip=%lx ",info[0].plnskip);
#endif
	for (i=0;i<depth;i++)
	{

	    /* grab em and jam em */
	    p = (*pptr++) + info[0].plnskip;

	    c = clongmove(&cl,c,&io->bplpt[i],p,frame);

	    if (view->Modes&lace)
	    {
		p = (long)p + (long)info[0].rbytes;
		c = clongmove(&cl,c,&io->bplpt[i],p,CPR_NT_SHT);
	    }

	    if ( (mspc->ms_Flags & REQUEST_A2024) &&
		 (modes != A2024TENHERTZ_KEY) )
	    {
		long p1;

		/* kprintf("makevp: modes != A2024TENHERTZ_KEY\n"); */

		/* frame lower left */
		p1 = (long)p + vp->DHeight*(long)info[0].rbytes;
		c = clongmove(&cl,c,&io->bplpt[i],p1,field_pick[1]);
		/* frame upper right */
		p1 = (long)p + (512>>3);
		c = clongmove(&cl,c,&io->bplpt[i],p1,field_pick[2]);
		/* lower right */
		p1 = (long)p + vp->DHeight*(long)info[0].rbytes+(512>>3);
		c = clongmove(&cl,c,&io->bplpt[i],p1,field_pick[3]);
		
	    }
	    if ( (mspc->ms_Flags & REQUEST_A2024) &&
		 (modes == A2024TENHERTZ_KEY) )
	    {
		long p1;

		/* kprintf("makevp: modes == A2024TENHERTZ_KEY\n"); */

		/* frame lower left */
		p1 = (long)p + vp->DHeight*(long)info[0].rbytes;
		c = clongmove(&cl,c,&io->bplpt[i],p1,field_pick[1]);
		/* frame upper middle */
		p1 = (long)p + (336>>3);
		c = clongmove(&cl,c,&io->bplpt[i],p1,field_pick[2]);
		/* frame upper right */
		p1 = (long)p + ((336+336)>>3);
		c = clongmove(&cl,c,&io->bplpt[i],p1,field_pick[4]);
		/* lower middle */
		p1 = (long)p + vp->DHeight*(long)info[0].rbytes+(336>>3);
		c = clongmove(&cl,c,&io->bplpt[i],p1,field_pick[3]);
		/* lower right */
		p1 = (long)p + vp->DHeight*(long)info[0].rbytes+((336+336)>>3);
		c = clongmove(&cl,c,&io->bplpt[i],p1,field_pick[5]);
	    }
	}
    }
    else    /* do dual playfield mode */
    {
	short bplmod;
	short fstrt,fstop,dbytes;
	UBYTE **pptr1,**pptr2;
	UBYTE *p;
	UWORD my_dwstop,my_dwhigh;

	getclipstuff(view,vp,r2,&info[1],yclip);

#ifdef UNDEFINED
	ybot += HFIX((~info[0].yxtra) & lshift);
	ytop += info[0].yxtra;
	y    += info[0].yxtra;
#endif

#ifdef UNDEFINED
	/* display clip bottom */
	{
	    ybot -= vp->DyOffset+(view->DyOffset<<lshift);
	    ybot = MAXYCLIP( ybot );
	    ybot += vp->DyOffset+(view->DyOffset<<lshift);
	}
#endif

#ifdef UNDEFINED
	ytop >>= lshift;
	ybot >>= lshift;
#endif

	/* funny hardware fix, Dale */
	/* denise 8362R8 and above fixed the hardware problem -- bart */
	/* if (info[1].scroll != info[0].scroll) info[0].dw--;	*/ 

	my_dwstop = info[0].dwxstrt + info[0].dw;

	my_dwstop = display_stop( mspc, my_dwstop );

	if ( (GB->ChipRevBits0 & GFXF_HR_DENISE) == 0)
	{
		CMOVE(c,io->diwstop,(0x7f<<8) | ( 0xff & my_dwstop));
		CBUMP(&cl);
	}
d171 1
a171 40
		short ymax = mspc->total_rows;

		/* ECS genlock */
		if(realbplcon0 & (GENLOCK_AUDIO|GENLOCK_VIDEO)) ymax -= 2;

		if (ybot > ymax) ybot = ymax; 

		/* compute diwhigh */
#ifdef SAS_DEBUG
	kprintf("compute diwstop for 2nd pf with ybot = %ld\n",ybot);
#endif

		t1 = ((ytop & 0x700) >> 8) | (ybot & 0x700)
			|  ( (my_dwstop & 0x100)<< 5)
			|  ( (info[0].dwxstrt & 0x100) >> 3);

		if(lace)
		{
			c = cshortmove(&cl,c,&io->diwstop,(ybot<<8)|(0xff & my_dwstop),
				CPR_NT_LOF);
			/*c = cshortmove(&cl,c,&io->diwhigh,t,CPR_NT_LOF);*/

			ybot  -= (vp->DHeight&1);

			/* recompute diwhigh */

			t2 = ((ytop & 0x700) >> 8) | (ybot & 0x700)
				|  ( (my_dwstop & 0x100)<< 5)
				|  ( (info[0].dwxstrt & 0x100) >> 3);

			c = cshortmove(&cl,c,&io->diwstop,(ybot<<8)|(0xff & my_dwstop),
				CPR_NT_SHT);
			/*c = cshortmove(&cl,c,&io->diwhigh,t,CPR_NT_SHT);*/
		}
		else
		{
			CMOVE(c,io->diwstop,(ybot<<8) | ( 0xff & my_dwstop));
			CBUMP(&cl);
			/*CMOVE(c,io->diwhigh,t);  CBUMP(&cl);*/
		}
a172 63

	fstrt = SHORTMIN(info[0].dafstrt,info[1].dafstrt);
	fstop = SHORTMAX(info[0].dafstop,info[1].dafstop);

	if (modes & SUPERHIRES)	i = 8;
	else 			i = 2;

	    if (fstrt < info[0].dafstrt) info[0].plnskip -= i;
	    if (fstrt < info[1].dafstrt) info[1].plnskip -= i;

	    CMOVE(c,io->ddfstrt,fstrt); CBUMP(&cl);
	    CMOVE(c,io->ddfstop,fstop); CBUMP(&cl);

	    /* pfa is [0] pfb is [1] */
	    CMOVE(c,io->bplcon1,(info[1].scroll<<4)|info[0].scroll);
	  CBUMP(&cl);

	    /*dbytes = 2 + ( (fstop - fstrt)>>2 );*/
#ifndef ULTRA_RES
	    /*if (modes & HIRES)   dbytes <<= 1;*/
#endif
	dbytes = get_dbytes(vp,fstrt,fstop);

	    /* set up bit plane modulos */
	    bplmod = info[0].rbytes - dbytes;
	    if (view->Modes & lace)
		    bplmod += info[0].rbytes;
	    CMOVE(c,io->bpl1mod,bplmod);             CBUMP(&cl);

	    /* set up bit plane modulos */
	    if (depth > 1)
	    {
		bplmod = info[1].rbytes - dbytes;
		if (view->Modes & lace)
			    bplmod += info[1].rbytes;
		CMOVE(c,io->bpl2mod,bplmod);    CBUMP(&cl);
	    }
	/* now send out bit plane pointers */
	pptr1 = r1->BitMap->Planes;
	pptr2 = r2->BitMap->Planes;
	for (i=0;i<depth;i++)
	{
	    if (i & 1)  p = *pptr2++ + info[1].plnskip;
	    else
		{
#ifdef SAS_DEBUG
			p = *pptr1++;
			kprintf("*** p = %lx, diff = %lx, shift = %lx skip = %lx\n",p,(info[1].dafstrt - info[0].dafstrt),((modes & HIRES)?3:4),info[0].plnskip);
			p += (info[0].plnskip - (BYTE) ((info[0].dafstrt - info[1].dafstrt) >> ((modes & HIRES)?3:4)));
			kprintf("**** new p = %lx\n",p);
#else
			p = ( (*pptr1++ + info[0].plnskip) -
						(BYTE) ((info[0].dafstrt - info[1].dafstrt) >> ((modes & HIRES)?3:4)) );	/* spence - Nov 14 1990 */
#endif
		}
		c = clongmove(&cl,c,&io->bplpt[i],p,frame);

	    if (view->Modes & lace)
	    {
		p = (long)p + (long)info[i&1].rbytes;
		c = clongmove(&cl,c,&io->bplpt[i],p,CPR_NT_SHT);
	    }
	}
a173 97
	/* now put the new DIWHIGH at the end of the list */
	if (GB->ChipRevBits0 & GFXF_HR_DENISE)
	{
		if(lace)
		{
			c = cshortmove(&cl,c,&io->diwhigh,t1,CPR_NT_LOF);
			c = cshortmove(&cl,c,&io->diwhigh,t2,CPR_NT_SHT);
		}
		else
		{
			CMOVE(c,io->diwhigh,t1);  CBUMP(&cl);
		}
	}

	if ((GB->ChipRevBits0 & GFXF_HR_DENISE) == 0)
	{
	    short ystop;
	    short adjust = (vp->DyOffset<0) ? 
			  -(lshift & ~vp->DyOffset) :
			   (lshift &  vp->DyOffset) ;

	    short tot_rows = mspc->total_rows;
	    short viewoff = 
	    ((mspc->ms_Flags & REQUEST_A2024)? 0x2C: view->DyOffset);

	    if( GB->system_bplcon0 & (GENLOCK_AUDIO|GENLOCK_VIDEO) ) 
	    {
		    tot_rows -= 1;
	    }

	    if( ( ( vp->DyOffset >> lshift ) + viewoff ) < ( tot_rows - 1 ) )
	    {
		struct ViewPortExtra *vpe;

		WORD clpy = 0;

		if( (cm) && (cm->Type) && (vpe = cm->cm_vpe) )
		{
		    if( vpe->DisplayClip.MinY < 0 )
		    {
			struct DisplayInfoRecord *record;

			clpy = vpe->DisplayClip.MinY;

			if( ( record = cm->CoerceDisplayInfo )
			||  ( record = cm->NormalDisplayInfo ) )
			{
			    clpy = SHORTMAX( record->rec_ClipOScan.MinY, clpy );
			}
		    }
		}

		/* bart - display clipping */
		/* ystop = vp->DHeight;    */
		/* ystop = MAX(vp->DHeight+MIN(vp->DyOffset,0),0); */
		/* ystop =  ((ybot- ((mspc->ms_Flags & REQUEST_A2024)? 0x2C:
		view->DyOffset+((vp->DyOffset+lshift)>>lshift)))<<lshift); */

		ystop = ((ybot-viewoff)<<lshift)-(vp->DyOffset+adjust);

		CWAIT( c, ( (vp->DyOffset >= clpy) ?  0 : -vp->DyOffset ) , 0 );

		CBUMP(&cl); /* relative to top of vp */
		CMOVE(c,io->bplcon0,mybplcon0);    
		CBUMP(&cl);

		if( lshift && ( vp->DHeight & 1 ) )
		{
		    CWAIT(c,ystop-1-((adjust<0)?-adjust:adjust),0);
		    c->OpCode |= CPR_NT_LOF;
		    CBUMP(&cl);
		    c = cshortmove(&cl,c,&io->bplcon0,realbplcon0,CPR_NT_SHT);
		    CWAIT(c,ystop,0);   		    
		    c->OpCode |= CPR_NT_SHT;
		    CBUMP(&cl);
		    c = cshortmove(&cl,c,&io->bplcon0,realbplcon0,CPR_NT_LOF);
		}
		else
		{
		    CWAIT(c,ystop,0);   		    
		    CBUMP(&cl);
		    CMOVE(c,io->bplcon0,realbplcon0);
		    CBUMP(&cl);
		}
	    }
	}
#ifdef WAITBOV
	CMOVE(c,io->intreqw,BITSET|ICOPPER);    CBUMP(&cl);
#endif
	CEND(c);   CBUMP(&cl);
#ifdef NEW_HEDLEY
	/* unswizzle viewport stuff */
	if (old_vp)
	{
		old_vp->DspIns = vp->DspIns;
	}
#endif
a174 1

@


37.2
log
@ changed "../" to "/" for native build
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 37.1 91/05/01 13:52:37 spence Exp Locker: chrisg $
d35 2
d60 3
a62 5
struct CopIns *clongmove(cl,c,a,p,frame)
struct CopList **cl;
struct CopIns *c;
long a,p;	/* a = bpl register, p = bitplane address */
USHORT frame;
d78 4
a81 6
struct CopIns *cshortmove(cl,c,a,p,frame)
struct CopList **cl;
struct CopIns *c;
long a;	/* a = bpl register, p = short something */
short p;
USHORT frame;
d100 1
a100 2
ULONG  new_mode(vp)
struct ViewPort *vp;
d126 1
a126 3
short get_dbytes(vp,fstart,fstop)
struct ViewPort *vp;
short fstart,fstop;
d147 1
a147 3
unsigned short check_genlock(cm,i)
struct ColorMap *cm;
int i;
d159 1
a159 3
UWORD display_stop( mspc, dwstop )
struct MonitorSpec *mspc;
UWORD dwstop;
@


37.1
log
@Gap from top of DisplayWindow to WAIT to load colours was -1 orr -2, depending
on ViewMode. This caused problems with narrow DisplayWindows (a mystery).
The Gap  is now made -2 in all cases. Intuition always assumed a ISG of
6 LACE lines, so this should not affect it..
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 37.0 91/01/07 15:19:57 spence Exp Locker: spence $
d24 2
a25 2
#include "../macros.h"
#include "../displayinfo_internal.h"
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 36.104 91/01/07 14:28:25 spence Exp Locker: spence $
d361 1
d376 3
@


36.104
log
@DIWHIGH set up at end of copperlist, to keep order of copper instructions
the same as in 1.3 (some applications were making assumptions about
copperlist instruction ordering).
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 36.103 90/12/06 13:49:23 bart Exp Locker: spence $
@


36.103
log
@removed gfxallocmem.c and implemented better lo-mem error recovery -- bart
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 36.102 90/11/16 16:32:43 spence Exp Locker: bart $
d214 1
d394 3
a749 1
		UWORD t;
d758 4
a761 2

		t = ((ytop & 0x700) >> 8) | (ybot & 0x700)
d769 1
a769 1
			c = cshortmove(&cl,c,&io->diwhigh,t,CPR_NT_LOF);
d775 1
a775 1
			t = ((ytop & 0x700) >> 8) | (ybot & 0x700)
d781 1
a781 1
			c = cshortmove(&cl,c,&io->diwhigh,t,CPR_NT_SHT);
d787 1
a787 1
			CMOVE(c,io->diwhigh,t);  CBUMP(&cl);
a916 1
		UWORD t;
d925 3
d929 1
a929 1
		t = ((ytop & 0x700) >> 8) | (ybot & 0x700)
d937 1
a937 1
			c = cshortmove(&cl,c,&io->diwhigh,t,CPR_NT_LOF);
d943 1
a943 1
			t = ((ytop & 0x700) >> 8) | (ybot & 0x700)
d949 1
a949 1
			c = cshortmove(&cl,c,&io->diwhigh,t,CPR_NT_SHT);
d955 1
a955 1
			CMOVE(c,io->diwhigh,t);  CBUMP(&cl);
d1022 14
@


36.102
log
@With dualpf mode, the ddfstrts of the 2 playfields were not always 
identical. BitPlane pointers of the 1st playfield now adjusted as needed.
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 36.101 90/09/11 16:04:12 bart Exp Locker: spence $
d331 1
a331 1
	if (cl == 0)
d333 2
a334 1
		Alert(ALERTGFXNOMEMMAKEVP);	/* does not return */
@


36.101
log
@old denise interscreen gap
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 36.100 90/08/23 14:04:42 bart Exp Locker: bart $
d37 1
d993 12
a1004 2
	    else        p = *pptr1++ + info[0].plnskip;

@


36.100
log
@fix old denise negative clpy 
@
text
@d3 1
a3 1
*	$Id: makevp.c,v 36.99 90/07/27 16:58:18 bart Exp Locker: bart $
d359 1
a359 2
	if ( (depth>4) && (r2 == 0) ) y--;
	else if((depth > 3) || (modes & SUPERHIRES))
d361 10
a370 1
	    if (vp->Modes & SPRITES)    y--;
@


36.99
log
@id
@
text
@d3 1
a3 1
*	$Id: $
d1013 1
d1015 18
d1041 2
a1042 1
		CWAIT(c,((vp->DyOffset>0)?0:-vp->DyOffset),0);  
@


36.98
log
@ok old denise
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/makevp.c,v 36.97 90/07/20 18:11:06 bart Exp $
@


36.97
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/makevp.c,v 36.96 90/07/20 17:53:22 bart Exp Locker: bart $
d1032 1
d1036 1
d1042 2
a1044 3

		CMOVE(c,io->bplcon0,realbplcon0);   CBUMP(&cl);

@


36.96
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/makevp.c,v 36.95 90/07/20 14:21:49 bart Exp Locker: bart $
@


36.95
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/makevp.c,v 36.94 90/07/19 00:13:05 bart Exp Locker: bart $
a41 2
#define HWAIT 222

d1022 1
a1022 1
		CWAIT(c,((vp->DyOffset>0)?0:-vp->DyOffset),HFIX(HWAIT)-1);  
@


36.94
log
@clip old denise top of viewport to bottom of display
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/makevp.c,v 36.93 90/07/18 22:31:11 bart Exp Locker: bart $
d1031 1
a1031 1
		    CWAIT(c,ystop-1-((adjust<0)?-adjust:adjust),HFIX(HWAIT)-1);
d1034 1
a1034 1
		    CWAIT(c,ystop,HFIX(HWAIT)-1);   		    
d1040 1
a1040 1
		    CWAIT(c,ystop,HFIX(HWAIT-1));   		    
@


36.93
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/makevp.c,v 36.92 90/07/18 22:17:38 bart Exp Locker: bart $
d999 4
a1002 4
		short ystop;
		short adjust = (vp->DyOffset<0) ? 
			      -(lshift & ~vp->DyOffset) :
			       (lshift &  vp->DyOffset) ;
d1004 12
d1022 1
a1022 5
		ystop = 
		((ybot-
		((mspc->ms_Flags & REQUEST_A2024)? 0x2C: view->DyOffset)) 
		<< lshift ) - 
		( vp->DyOffset + adjust );
d1026 2
a1028 3
		CMOVE(c,io->bplcon0,mybplcon0);     CBUMP(&cl);


d1045 2
@


36.92
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/makevp.c,v 36.91 90/07/18 20:26:36 bart Exp Locker: bart $
d1016 1
a1016 1
		CWAIT(c,((vp->DyOffset>0)?0:-vp->DyOffset),HFIX(HWAIT));  
d1024 1
a1024 1
		    CWAIT(c,ystop-1-((adjust<0)?-adjust:adjust),HFIX(HWAIT));
d1027 1
a1027 1
		    CWAIT(c,ystop,HFIX(HWAIT));   		    
d1033 1
a1033 1
		    CWAIT(c,ystop,HFIX(HWAIT));   		    
@


36.91
log
@graphics36.171 old denise clipping
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/makevp.c,v 36.90 90/07/17 18:29:18 bart Exp Locker: bart $
d42 2
d1016 1
a1016 1
		CWAIT(c,((vp->DyOffset>0)?0:-vp->DyOffset),0);  
a1020 1
		CWAIT(c,ystop,0);   		    
d1024 4
a1029 2
		    CWAIT(c,ystop-1-((adjust<0)?-adjust:adjust),0);
		    c->OpCode |= CPR_NT_LOF;
d1031 5
a1035 2

		CBUMP(&cl);
@


36.90
log
@fix old denise clipping
@
text
@d3 1
a3 1
*	$Header: /usr/machines/ghostwheel/commodore/amiga/V36/src/kickstart/graphics/c/RCS/makevp.c,v 36.89 90/05/02 11:04:31 bart Exp Locker: bart $
d998 4
d1005 2
a1007 10
		/*
		ystop =  ((ybot-
			 ((mspc->ms_Flags & REQUEST_A2024)?
			   0x2C:
			   view->DyOffset +
			   ((vp->DyOffset + lshift) 
			   >> lshift)))
		      << lshift);
		  */

d1012 1
a1012 4
		( vp->DyOffset + 
		( (vp->DyOffset<0) ? 
		-(lshift & ~vp->DyOffset) : 
		(lshift & vp->DyOffset) ) );
d1019 12
a1030 1
		CWAIT(c,ystop,0);   		    CBUMP(&cl);
@


36.89
log
@fixes odd interlace screen height bug (no longer displays garbage line)
@
text
@d3 1
a3 1
*	$Header: /usr2/bart/v1.4/src/kickstart/working/graphics/c/RCS/makevp.c,v 36.88 90/04/19 14:37:51 bart Exp Locker: bart $
d1012 8
a1019 2
		ystop = ( (ybot-((mspc->ms_Flags & REQUEST_A2024)?0x2C:view->DyOffset))
			      << lshift ) - (vp->DyOffset + lshift) ;
d1021 3
a1023 1
		CWAIT(c,0,0);  CBUMP(&cl); /* relative to top of vp */
d1025 1
@


36.88
log
@fixed old denise lace multiscreen rounding problem in closing display window
@
text
@d3 1
a3 1
*	$Header: /usr2/bart/v1.4/src/kickstart/working/graphics/c/RCS/makevp.c,v 36.87 90/03/28 09:10:52 bart Exp Locker: bart $
a743 3
    		CMOVE(c,io->diwstop,(ybot<<8) | ( 0xff & my_dwstop));
		CBUMP(&cl);

d750 24
a773 1
		CMOVE(c,io->diwhigh,t);  CBUMP(&cl);
d897 1
a897 1
    		CMOVE(c,io->diwstop,(0x7f<<8) | ( 0xff & my_dwstop));
a909 3
    		CMOVE(c,io->diwstop,(ybot<<8) | ( 0xff & my_dwstop));
		CBUMP(&cl);

d916 24
a939 1
		CMOVE(c,io->diwhigh,t);  CBUMP(&cl);
@


36.87
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/graphics/c/RCS/makevp.c,v 36.86 89/11/21 10:56:19 bart Exp Locker: bart $
d199 1
a199 1
    short ybottom;	/* absolute bottom of this viewport */
d381 2
a382 2
	ybottom   = ytop;
	ybottom  += vp->DHeight;
d622 1
a622 1
	ybottom += HFIX((~info[0].yxtra) & lshift);
d629 3
a631 3
	    ybottom -= vp->DyOffset+(view->DyOffset<<lshift);
	    ybottom = MAXYCLIP( ybottom );
	    ybottom += vp->DyOffset+(view->DyOffset<<lshift);
d636 1
a636 1
	ybottom >>= lshift;
d742 1
a742 1
		if (ybottom > ymax) ybottom = ymax; 
d744 1
a744 1
    		CMOVE(c,io->diwstop,(ybottom<<8) | ( 0xff & my_dwstop));
d749 1
a749 1
		t = ((ytop & 0x700) >> 8) | (ybottom & 0x700)
d848 1
a848 1
	ybottom += HFIX((~info[0].yxtra) & lshift);
d856 3
a858 3
	    ybottom -= vp->DyOffset+(view->DyOffset<<lshift);
	    ybottom = MAXYCLIP( ybottom );
	    ybottom += vp->DyOffset+(view->DyOffset<<lshift);
d864 1
a864 1
	ybottom >>= lshift;
d888 1
a888 1
		if (ybottom > ymax) ybottom = ymax; 
d890 1
a890 1
    		CMOVE(c,io->diwstop,(ybottom<<8) | ( 0xff & my_dwstop));
d895 1
a895 1
		t = ((ytop & 0x700) >> 8) | (ybottom & 0x700)
d961 3
a963 1
		ystop =  ((ybottom-
d970 4
@


36.86
log
@utility/tagitem
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.85 89/05/09 15:20:03 bart Exp $
@


36.85
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.84 89/05/09 13:14:58 bart Exp $
d30 3
a32 1
#include <intuition/tagitem.h>
@


36.84
log
@
dualpf scroll width hack removed -- denise 8362R8 and above fixed
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.83 89/04/29 15:42:13 bart Exp $
d903 2
a904 2
	if (modes & HIRES)	i = 4;
	else			i = 2;
@


36.83
log
@cm->Type checking
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.82 89/04/28 19:32:01 bart Exp $
d865 3
a867 1
	if (info[1].scroll != info[0].scroll) info[0].dw--;	/* funny hardware fix, Dale */
@


36.82
log
@lace, lshift, and ystop modifications
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.81 89/04/13 12:29:02 bart Exp $
d106 1
a106 1
    if( (cm)
d153 1
a153 1
	if ( cm && (cm->Flags & COLORMAP_TRANSPARENCY))
d224 1
a224 1
    if(cm)
d245 2
d249 1
a249 2
	    ve = gfxlookup(view);
	    if(ve)
a254 5
	if(!mspc)
	{
	    mspc = GB->default_monitor;
	}

d677 1
a677 1
	if (cm)
d694 1
a694 1
	if(cm)
@


36.81
log
@range clipping for depth of hires/super viewports
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.80 89/03/17 18:20:52 bart Exp $
d209 2
d314 1
a314 1
	if (modes&INTERLACE)    frame = CPR_NT_LOF;
d356 3
a358 3
		   << ((modes & LACE) ? 1: 0));
	ytop  += ((modes & LACE) ? 1: 0);
	ytop >>= ((modes & LACE) ? 1: 0);
d369 1
a369 1
		    MIN(modes&LACE?(vp->DyOffset>>1):vp->DyOffset,0),
d376 1
a376 1
	y <<= ((modes & LACE) ? 1: 0);
d380 2
a381 2
	yclip <<= ((modes & LACE) ? 1: 0);
	ytop  <<= ((modes & LACE) ? 1: 0);
d624 1
a624 1
	ybottom += HFIX((~info[0].yxtra) & (modes&LACE?1:0));
d631 1
a631 1
	    ybottom -= vp->DyOffset+(view->DyOffset<<((modes & LACE)?1:0));
d633 1
a633 1
	    ybottom += vp->DyOffset+(view->DyOffset<<((modes & LACE)?1:0));
d637 2
a638 2
	ytop >>= ((modes & LACE) ? 1: 0);
	ybottom >>= ((modes & LACE) ? 1: 0);
d768 1
a768 1
	if (view->Modes & modes & INTERLACE)
d790 1
a790 1
	    if (view->Modes&INTERLACE&modes)
d850 1
a850 1
	ybottom += HFIX((~info[0].yxtra) & (modes&LACE?1:0));
d858 1
a858 1
	    ybottom -= vp->DyOffset+(view->DyOffset<<((modes & LACE)?1:0));
d860 1
a860 1
	    ybottom += vp->DyOffset+(view->DyOffset<<((modes & LACE)?1:0));
d865 2
a866 2
	ytop >>= ((modes & LACE) ? 1: 0);
	ybottom >>= ((modes & LACE) ? 1: 0);
d926 1
a926 1
	    if (view->Modes & modes & INTERLACE)
d934 1
a934 1
		if (view->Modes & modes & INTERLACE)
d948 1
a948 1
	    if (view->Modes & modes & INTERLACE)
d964 4
a967 2
			   view->DyOffset))
		      << ((modes&INTERLACE)?1:0));
@


36.80
log
@old denise compatibility with bovp reset of bplcon0 -- no bovp clip on moves
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.79 89/03/16 14:04:54 bart Exp $
d340 4
@


36.79
log
@fixed loadview scanrate change timing interaction bug!!! studley bart
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.78 89/03/09 11:14:37 bart Exp $
d953 1
a953 1
		/* ystop = vp->DHeight; */
d961 4
a964 5
		CWAIT(c,0,0);  CBUMP(&cl);	/* relative to top of vp */
		CMOVE(c,io->bplcon0,realbplcon0);     CBUMP(&cl);
		CWAIT(c,ystop,0);   CBUMP(&cl);
		CMOVE(c,io->bplcon0,(view->Modes&INTERLACE)|GB->system_bplcon0);
		CBUMP(&cl);
@


36.78
log
@clipping on dualpf interlaced screens
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.77 89/03/06 22:09:12 bart Exp $
d962 1
a962 1
		CMOVE(c,io->bplcon0,mybplcon0);     CBUMP(&cl);
@


36.77
log
@better genlock processing
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.76 89/03/03 11:01:30 bart Exp $
d843 1
d847 1
d858 1
d861 1
@


36.76
log
@dont reset batch mode flag
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.75 89/03/02 18:30:19 bart Exp $
a731 1
		short ymax;
d733 1
d735 2
a736 1
		ymax = mspc->total_rows-1;
d738 1
a738 1
		if (ybottom >= ymax) ybottom = ymax-1; /* ECS genlock */
a871 1
		short ymax;
d873 1
d875 2
a876 1
		ymax = mspc->total_rows-1;
d878 1
a878 1
		if (ybottom >= ymax) ybottom = ymax-1; /* ECS genlock */
@


36.75
log
@genlock
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.74 89/03/01 12:53:21 bart Exp $
d235 1
a235 1
		    cm->Flags &= ~VIDEOCONTROL_BATCH;
@


36.74
log
@videocontrol issues
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.73 89/02/28 14:40:51 bart Exp $
d27 6
d221 22
d699 1
a699 1
		if(cm->Flags & BORDER_TRANSPARENCY)
@


36.73
log
@ECS genlock
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.72 89/02/24 16:11:34 bart Exp $
d641 1
d643 2
a644 2
	if (modes & SUPERHIRES)
		x >>= 1;
d646 1
d658 1
a658 7
	/* EXTBLKNEN */	/* new chips */
	/* following is for old rev denise */
	if (mspc->total_colorclocks != 226) x |= 0x80;
#ifdef DEBUG
	if (GB->Debug & 0x08)	x |= 0x80;
#endif
	if (x & 0x80)   /* for new chips */
d660 2
a661 2
	    realbplcon0 |= 1;
	    bplcon3 |= 1;   /* EXTBLKEN */
d664 1
d666 1
a666 3
		struct ViewExtra *old_ve = ve;
		ve = gfxlookup(view);
		if (ve)
d668 2
a669 10
		    if (ve->ve_VideoFlags & ve_BRDRBLNK)
		    {
			realbplcon0 |= 1;
			bplcon3 |= 0x20;
		    }
		    if (ve->ve_VideoFlags & ve_BRDRNTRN)
		    {
			realbplcon0 |= 1;
			bplcon3 |= 0x10;
		    }
d671 5
a675 1
		ve = old_ve;
d677 1
d680 1
a680 1
	if (realbplcon0 & 1)
@


36.72
log
@fixed order of eval in cm->dinfo check in new_mode
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.71 89/02/24 09:43:24 bart Exp $
d715 1
a715 1
		ymax = mspc->total_rows;
d717 1
a717 1
		if (ybottom > ymax) ybottom = ymax;
d854 1
a854 1
		ymax = mspc->total_rows;
d856 1
a856 1
		if (ybottom > ymax) ybottom = ymax;
@


36.71
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.72 89/02/23 11:10:22 bart Exp $
a24 4

#define PROTOTYPE_DISPLAY

#ifdef PROTOTYPE_DISPLAY
a25 1
#endif
d101 1
a101 2
    &&  (record = cm->CoerceDisplayInfo)
    ||  (record = cm->NormalDisplayInfo) )
a176 2
#ifdef PROTOTYPE_DISPLAY

d635 1
a639 1

a952 754

#else

makevport(view,vp)
struct View *view;
struct ViewPort *vp;
/* generate a set op intermediate copper instructions given a pointer */
/* to a View structure and a ViewPort */
{
    struct ViewExtra *ve=0;
    struct MonitorSpec *mspc=0;
    struct CopList *cl;
    struct CopIns *c;
    short x,y;
    short i;
    short min_ytop;
    short ytop;	/* absolute top of this viewport */
    short ybottom;	/* absolute bottom of this viewport */
    short yclip;	/* force clipping of top lines of viewport */
    short depth;
    short mybplcon0;
    unsigned short bplcon3 = 0;
    unsigned short realbplcon0;
    struct Custom *io;
    struct RasInfo *r1,*r2=0;
    struct GfxBase *GB;
    struct gs_info info[2];
    USHORT frame = 0;
    ULONG  modes = new_mode(vp);

#ifdef NEW_HEDLEY
    struct ViewPort *old_vp=0;
    struct ViewPort hvp;
    struct RasInfo hri;
    struct BitMap hbm;
    struct ColorMap *cm = vp->ColorMap;
#endif

    /*kprintf("MAKEVP(%lx,%lx)\n",view,vp);*/
    FETCHGBASE;

#ifdef NEW_HEDLEY
    if (vp->ExtendedModes & VPF_A2024)
    {
	    int width;
	    int bpr;	/*bytes per physical row */
	    int phys_rows = 200;	/* assume NTSC */
	    struct RasInfo *ri = vp->RasInfo;
	    struct BitMap *obm = ri->BitMap;
	    if (GB->DisplayFlags & PAL)	phys_rows = 256;
	    bpr = obm->BytesPerRow;
	    width = bpr << 3;
	    hvp = *vp;	/* copy whole structure */
	    old_vp = vp;
	    vp = &hvp;	/* bait and switch */
	    vp->ExtendedModes = old_vp->ExtendedModes;
	    vp->DxOffset = 0;	/* these are most likely ok */
	    vp->DyOffset = 0;
	    /* maybe we can support scrolling?, just a thot */
	    hri.Next = 0;
	    hri.RxOffset = ri->RxOffset; /*old_vp->RasInfo->RxOffset;*/
	    hri.RyOffset = ri->RyOffset; /*old_vp->RasInfo->RyOffset;*/
	    vp->RasInfo = &hri;
	    hri.BitMap = &hbm;
	    /* tweek viewport around for degenerate hardware */
	    /* user depth of 1 requires cheating with 2 */
	    /* user depth of 2 requires cheating with 4 */
	    INITBITMAP(&hbm,obm->Depth<<1,width*2,obm->Rows);
	    hbm.Planes[0] = obm->Planes[0];
	    hbm.Planes[1] = obm->Planes[0]+bpr;
	    if (obm->Depth == 2)
	    {
		    hbm.Planes[2] = obm->Planes[1];
		    hbm.Planes[3] = obm->Planes[1]+bpr;
	    }
	    vp->DHeight = phys_rows;
	    if (vp->ExtendedModes & VPF_TENHZ)
	    {
		    vp->Modes &= ~HIRES; /* bad, bad, bad dale */
		    vp->DWidth = 352;
		    /* view->DxOffset = 0x81-16; */
	    }
	    else
	    {
		    vp->DWidth = 512;
		    /* view->DxOffset = 0x81; */
	    }
    }
#endif

	if (view->Modes & EXTEND_VSTRUCT)
	{
	    ve = gfxlookup(view);
	    if(ve)
	    {
		mspc = ve->Monitor;
	    }
	}

	if(!mspc)
	{
	    mspc = GB->default_monitor;
	}

        min_ytop = mspc->min_row ;

	/* hedley support is now done as a variant of interlace */
	/* this is where the hedley stuff used to be */

	/* both must be defined */

	/* define for first frame */
	if (modes&INTERLACE)    frame = CPR_NT_LOF;
	if (vp->ExtendedModes & VPF_A2024)	frame = field_pick[0];

	/*printf("MAKEVP(%lx,%lx)\n",view,vp);*/
	/* backwards compatibility for a short time */
	r1 = vp->RasInfo;
	if (modes & DUALPF)	r2 = r1->Next;
    io = &custom;
#ifdef DEBUG
	kprintf("makevp(%lx,%lx) rasinfo=%lx\n",view,vp,r1);
#ifdef DEBUGDEBUG
	Debug();
#endif
#endif

	cl = vp->DspIns = (struct CopList *)copinit(vp->DspIns,DSPINS+32);
	if (cl == 0)
	{
		Alert(ALERTGFXNOMEMMAKEVP);	/* does not return */
	}
	c = cl->CopIns;

	depth = r1->BitMap->Depth;
	if (r2) depth += r2->BitMap->Depth;
	else if ((modes & (HAM|EXTRA_HALFBRITE))== 0)
			depth = SHORTMIN(depth,5);

	/* wait for correct position on the display */
	/* y is relative to view.DyOffset */
	/* all waits are positioned relative to view.DyOffset during MrgCop */
	/* y if where the display is to begin */
	/* adjust y to leave enough space for copper maneuvers */
	/* if we have more than 4 bit planes then or sprite colors */

	ytop   =     vp->DyOffset;
	ytop  +=  (((vp->ExtendedModes & VPF_A2024)?0x2c:view->DyOffset) 
		   << ((modes & LACE) ? 1: 0));
	ytop  += ((modes & LACE) ? 1: 0);
	ytop >>= ((modes & LACE) ? 1: 0);

	y = -1;	/* need some space for copper instructions */
	if ( (depth>4) && (r2 == 0) ) y--;
	else if((depth > 3) || (modes & SUPERHIRES))
	{
	    if (vp->Modes & SPRITES)    y--;
	}

#ifdef UNDEFINED
	y += MAX(
		    MIN(modes&LACE?(vp->DyOffset>>1):vp->DyOffset,0),
		    (min_ytop- ((vp->ExtendedModes & VPF_A2024)?
				0x2c:
				view->DyOffset))
		);
#endif

	y <<= ((modes & LACE) ? 1: 0);

	yclip = MIN( ytop - min_ytop, 0 );

	yclip <<= ((modes & LACE) ? 1: 0);
	ytop  <<= ((modes & LACE) ? 1: 0);

	ybottom   = ytop;
	ybottom  += vp->DHeight;
	ytop     -= yclip;

#ifdef NEW_HEDLEY
	/* need an absolute wait position */
	if (vp->ExtendedModes & VPF_A2024)
	{
		UWORD t;
		int real_depth;
#define H_OFFSET	0x20
/*#define OLDPIXELALIGN*/
#define NEWPIXELALIGN

#ifdef NEWPIXELALIGN
#define KEYCOLOR	1
#else
#define KEYCOLOR	0
#endif
/*#define H_OFFSET	0x0*/
		short tcolor;
		/*short ypos = 0x28-0x2c;*/
		short ypos = -0x1b+4;	/* 1c in docs */
		/*ypos = -4-3;*/	/* visible control region debug */

		/* to make the sprites work, the output depth */
		/* must always be two */
		/*ypos += 16;*/
		/*real_depth = old_vp->RasInfo->BitMap->Depth;*/
		real_depth = 2;
		/* position 0-127 */
		if (GB->DisplayFlags & PAL)	ypos += 8;
		CWAIT(c,ypos-9,0);	/* was a -1 */
		CBUMP(&cl);
		CMOVE(c,io->color[0],0xf00);	/* all colors 0 */
		CBUMP(&cl);
#ifdef OLDPIXELALIGN
		CWAIT(c,ypos,0x45);		/* also trigger pixel catcher */
		CBUMP(&cl);
		t = 1; /* F6-4=0,INTERLACE=0 */
		if (vp->ExtendedModes & VPF_TENHZ) t |= 0x800;  /* F6_4 = 1*/
		CMOVE(c,io->color[0],t);
		CBUMP(&cl);
#endif
#ifdef NEWPIXELALIGN
		/* set up real raster */
		c = clongmove(&cl,c,&io->bplpt[0],GB->a2024_sync_raster,0);
		t = 0x15;
		if (GB->DisplayFlags & PAL) t += 8;
		t <<= 8;		/* move y over to left byte */
		t += 0x61;		/* get x diwstart */
		if (GB->ChipRevBits0 & GFXF_HR_DENISE)	t += 0x100;
		CMOVE(c,io->diwstrt,t)	/* was 0x1561 for ntsc */
		CBUMP(&cl);
		t &= 0xff00;
		t += 0xd1;
		CMOVE(c,io->diwstop,t);
		CBUMP(&cl);
		CMOVE(c,io->ddfstrt,0x40);
		CBUMP(&cl);
		CMOVE(c,io->ddfstop,0xd0);
		CBUMP(&cl);
		/* 1 bitplane hires */
		CMOVE(c,io->bplcon0,HIRES|0x1000|0x200);
		CBUMP(&cl);
		t = 1; /* F6-4=0,INTERLACE=0 */
		if (vp->ExtendedModes & VPF_TENHZ) t |= 0x800;  /* F6_4 = 1*/
		CMOVE(c,io->color[1],t);
		CBUMP(&cl);
#endif

		/* position 128-256 0x67*/
		CWAIT(c,ypos,0x5f+H_OFFSET);
		CBUMP(&cl);
		{
			int i;
			t = 4;
			if (vp->ExtendedModes & VPF_TENHZ) t = 6;
			for (i = 0; i<t ; i++)
			{
				tcolor = 0x1;
				if (i & 1)	tcolor |= 0xf00;
				if (i & 2)	tcolor |= 0x0f0;
				if (i & 4)	tcolor |= 0x008;
				c = cshortmove(&cl,c,&io->color[KEYCOLOR],
				tcolor,field_pick[i]); /* quadrant, expand */
			}
		}

		/* position 256-337? 0x87*/
		CWAIT(c,ypos,0x7f+H_OFFSET);
		CBUMP(&cl);
		t = 0x800;		/* for 1 bitplane */
		if (real_depth == 2)	t = 0x8f0;
		CMOVE(c,io->color[KEYCOLOR],t); /* enp1=enp0=1 wpb=0 */
		CBUMP(&cl);

		/* position 340-512 0xa3*/
		CWAIT(c,ypos,0x9f+H_OFFSET);
		CBUMP(&cl);
		t = 0xfff;		/* for two bitplanes */
		if (real_depth == 1)	t = 0xf0f;	/* one plane */
		t = 0xfff;
		/*real_depth = old_vp->RasInfo->BitMap->Depth;*/
		if (old_vp->RasInfo->BitMap->BytesPerRow > 128 - 2)
			t = 0xff1;
		CMOVE(c,io->color[KEYCOLOR],t); /* 0x889 dpl0=dpl1=1,less16=1*/
		CBUMP(&cl);
		CWAIT(c,ypos+1,0);
		CBUMP(&cl);
		CMOVE(c,io->color[0],0x000); /* turn off for rest of display */
		CBUMP(&cl);
#ifdef NEWPIXELALIGN
		CMOVE(c,io->bplcon0,0);
		CBUMP(&cl);
#endif

	}
#endif


	CWAIT(c,HFIX(VFIX(y)-(VFIX(1)>>1)),0); /* bart -- better spacing */
	CBUMP(&cl);

    /* load up copper list with color stuff */

    if (modes & (DUALPF|HAM))   x = 16;
    else                    x = 1<<(SHORTMIN(5,depth));
	{
    		UWORD   *colors,*colortable;
		unsigned short color;
		short blue_and_clear,colortablecount;
    		if ( cm == 0)
		{
			colortable = dflt_clrs;
			colortablecount = MAX_COLORS;
		}
		else
		{
			colortable = (UWORD *)cm->ColorTable;
			colortablecount = cm->Count;
			if (colortablecount > MAX_COLORS)
				colortablecount = MAX_COLORS;
		}
	if ( (vp->ExtendedModes & VPF_A2024) ||
	     (modes & SUPERHIRES) )
	{
		WORD	new_colors[32];
		/* convert colors from users colormap to hedley colors */
#ifdef DEBUg
		kprintf("colortable in = %lx\n",colortable);
#endif
		if (vp->ExtendedModes & VPF_A2024)
			convert_to_hedley(colortable,new_colors);
		else
		{
			convert_to_superhires(colortable,new_colors,cm);
		}
#ifdef DEBUg
		kprintf("colortable out= %lx\n",new_colors);
		Debug();
#endif
		colors = new_colors;
		for (i = 0; i<32 ; i++)
		{
			CMOVE(c,io->color[i],*colors++);
			CBUMP(&cl);
		}
	}
	else
	{
		/* let us speed this baby up a bit */
		/* using my intimate knowledge of cbump we can find out */
		/* how many instructions can go into this buffer */
		blue_and_clear = MIN(x,cl->MaxCount - cl->Count)-1;
		i = 0;
		colors = colortable;
		if (blue_and_clear > 0)
		{
			for (; i < blue_and_clear ; i++)
			{
				color = *colors++;
				color |= check_genlock(cm,i);
				CMOVE(c,io->color[i],color);
				c++;
			}
			cl->Count += blue_and_clear;
		}
		
		/* finish the rest slowly */
    		for (;i < x; i++)
    		{
			color = *colors++;
			color |= check_genlock(cm,i);
			CMOVE(c,io->color[i],color);
			CBUMP(&cl);
    		}
    		if (vp->Modes & SPRITES)
			/* this guy needs sprite colors loaded */
			if( (depth < 5) /* already all load up? */
			    || 
			    (modes & (DUALPF|HAM)) /* special? */ )
			{
				/* skip raster colors */
				colortable += 16;
	    			/* have to load up sprite colors */
	    			for(i = 16;i < colortablecount; i++)
	    			{
					color = *colortable++;
					color |= check_genlock(cm,i);
		    			CMOVE(c,io->color[i],color);
		    			CBUMP(&cl);
	    			}
			}
		}
	}

	/* load up dw,dx and other stuff for primary rasinfo/playfield */

	getclipstuff(view,vp,r1,&info[0],yclip);

	ybottom += HFIX((~info[0].yxtra) & (modes&LACE?1:0));
	ytop += info[0].yxtra;
	y    += info[0].yxtra;

#ifdef UNDEFINED
	/* display clip bottom */
	{
	    ybottom -= vp->DyOffset+(view->DyOffset<<((modes & LACE)?1:0));
	    ybottom = MAXYCLIP( ybottom );
	    ybottom += vp->DyOffset+(view->DyOffset<<((modes & LACE)?1:0));
	}
#endif

	ytop >>= ((modes & LACE) ? 1: 0);
	ybottom >>= ((modes & LACE) ? 1: 0);


#ifdef DEBUG
    kprintf("diwxstrt = %lx ",info[0].dwxstrt);
#endif
	/* This next value is worng for final release */
	/* I think there is a chip problem */
	/*x = VFIX(0x2b)<<8;*/

	if ( (GB->ChipRevBits0 & GFXF_HR_DENISE) == 0)
	{
	    x = (min_ytop<<8) | (0xff&info[0].dwxstrt);
	}
	else
	{
	    x = (ytop<<8)|(0xff&info[0].dwxstrt);
	}

    	CMOVE(c,io->diwstrt,x);
	CBUMP(&cl);
	/* hopefully sprites are still see able */

	mybplcon0 = GB->system_bplcon0 | ( depth << PLNCNTSHFT ) |
	(view->Modes & INTERLACE) |
	((modes & SUPERHIRES)?0x40:0) |	/* new SUPERHIRES */
#ifdef ULTRA_RES
	(modes & (HOLDNMODIFY|DUALPF) );
#else
	(modes & (HOLDNMODIFY|DUALPF|HIRES) );
#endif
	if (GB->ChipRevBits0 & GFXF_HR_DENISE)
    		realbplcon0 = mybplcon0;
	else	realbplcon0 = (view->Modes&INTERLACE)|(GB->system_bplcon0);


    	x = vp->SpritePriorities;
	/* temp hack */
	if (modes & SUPERHIRES)
		x >>= 1;
	x |= (modes & PF2PRI);
	if (cm)
	{
		if (cm->Flags & COLORMAP_TRANSPARENCY)
			x |= BPLCON2_ZDCTEN;
		if (cm->Flags & COLORPLANE_TRANSPARENCY)
		{
			x |= BPLCON2_ZDBPEN;
			x |= cm->TransparencyPlane <<12;
		}
	}

	/* EXTBLKNEN */	/* new chips */
	/* following is for old rev denise */
	if (mspc->total_colorclocks != 226) x |= 0x80;
#ifdef DEBUG
	if (GB->Debug & 0x08)	x |= 0x80;
#endif
	if (x & 0x80)   /* for new chips */
	{
	    realbplcon0 |= 1;
	    bplcon3 |= 1;   /* EXTBLKEN */
	}

	{
		struct ViewExtra *old_ve = ve;
		ve = gfxlookup(view);
		if (ve)
		{
		    if (ve->ve_VideoFlags & ve_BRDRBLNK)
		    {
			realbplcon0 |= 1;
			bplcon3 |= 0x20;
		    }
		    if (ve->ve_VideoFlags & ve_BRDRNTRN)
		    {
			realbplcon0 |= 1;
			bplcon3 |= 0x10;
		    }
		}
		ve = old_ve;
	}
	CMOVE(c,io->bplcon0,realbplcon0); CBUMP(&cl);
	CMOVE(c,io->bplcon2,x); CBUMP(&cl);
	if (realbplcon0 & 1)
	{
	    CMOVE(c,io->bplcon3,bplcon3); CBUMP(&cl);
	}

    /* do stuff for standard view */

    if ( r2 == 0)
    {
	short dbytes,bplmod;
	UWORD my_dwstop,my_dwhigh;
	UBYTE **pptr,*p;
	/* hack for new chips */
	my_dwstop = info[0].dwxstrt + info[0].dw;

	my_dwstop = display_stop( mspc, my_dwstop );

	if ( (GB->ChipRevBits0 & GFXF_HR_DENISE) == 0)
	{
    		CMOVE(c,io->diwstop,(0x7f<<8) | ( 0xff & my_dwstop));
		CBUMP(&cl);
	}
	else
	{
		short ymax;
		UWORD t;

		ymax = mspc->total_rows;

		if (ybottom > ymax) ybottom = ymax;

    		CMOVE(c,io->diwstop,(ybottom<<8) | ( 0xff & my_dwstop));
		CBUMP(&cl);

		/* compute diwhigh */

		t = ((ytop & 0x700) >> 8) | (ybottom & 0x700)
			|  ( (my_dwstop & 0x100)<< 5)
			|  ( (info[0].dwxstrt & 0x100) >> 3);

		CMOVE(c,io->diwhigh,t);  CBUMP(&cl);
	}

	dbytes = get_dbytes(vp,info[0].dafstrt,info[0].dafstop);

	CMOVE(c,io->ddfstrt,info[0].dafstrt);       CBUMP(&cl);

	CMOVE(c,io->ddfstop,info[0].dafstop);       CBUMP(&cl);

	CMOVE(c,io->bplcon1,(info[0].scroll<<4)|info[0].scroll);        CBUMP(&cl);

	    /* set up bit plane modulos */
	bplmod = info[0].rbytes - dbytes;
	if (view->Modes & modes & INTERLACE)
	{
	    bplmod += info[0].rbytes;
	}
	CMOVE(c,io->bpl1mod,bplmod);    CBUMP(&cl);

	if (depth > 1)
	{
	    CMOVE(c,io->bpl2mod,bplmod);    CBUMP(&cl);
	}
	pptr = r1->BitMap->Planes;
#ifdef DEBUG
	kprintf("plnskip=%lx ",info[0].plnskip);
#endif
	for (i=0;i<depth;i++)
	{

	    /* grab em and jam em */
	    p = (*pptr++) + info[0].plnskip;

		c = clongmove(&cl,c,&io->bplpt[i],p,frame);

	    if (view->Modes&INTERLACE&modes)
	    {
		p = (long)p + (long)info[0].rbytes;
		c = clongmove(&cl,c,&io->bplpt[i],p,CPR_NT_SHT);
	    }
	    if ( (vp->ExtendedModes & VPF_A2024) &&
		 !(vp->ExtendedModes & VPF_TENHZ) )
	    {
		long p1;
		/* frame lower left */
		p1 = (long)p + vp->DHeight*(long)info[0].rbytes;
		c = clongmove(&cl,c,&io->bplpt[i],p1,field_pick[1]);
		/* frame upper right */
		p1 = (long)p + (512>>3);
		c = clongmove(&cl,c,&io->bplpt[i],p1,field_pick[2]);
		/* lower right */
		p1 = (long)p + vp->DHeight*(long)info[0].rbytes+(512>>3);
		c = clongmove(&cl,c,&io->bplpt[i],p1,field_pick[3]);
		
	    }
	    if ( (vp->ExtendedModes & VPF_A2024) &&
	    		(vp->ExtendedModes & VPF_TENHZ) )
	    {
		long p1;
		/* frame lower left */
		p1 = (long)p + vp->DHeight*(long)info[0].rbytes;
		c = clongmove(&cl,c,&io->bplpt[i],p1,field_pick[1]);
		/* frame upper middle */
		p1 = (long)p + (336>>3);
		c = clongmove(&cl,c,&io->bplpt[i],p1,field_pick[2]);
		/* frame upper right */
		p1 = (long)p + ((336+336)>>3);
		c = clongmove(&cl,c,&io->bplpt[i],p1,field_pick[4]);
		/* lower middle */
		p1 = (long)p + vp->DHeight*(long)info[0].rbytes+(336>>3);
		c = clongmove(&cl,c,&io->bplpt[i],p1,field_pick[3]);
		/* lower right */
		p1 = (long)p + vp->DHeight*(long)info[0].rbytes+((336+336)>>3);
		c = clongmove(&cl,c,&io->bplpt[i],p1,field_pick[5]);
	    }
	}
    }
    else    /* do dual playfield mode */
    {
	short bplmod;
	short fstrt,fstop,dbytes;
	UBYTE **pptr1,**pptr2;
	UBYTE *p;
	UWORD my_dwstop,my_dwhigh;

	getclipstuff(view,vp,r2,&info[1],yclip);

	ybottom += HFIX((~info[0].yxtra) & (modes&LACE?1:0));
	ytop += info[0].yxtra;
	y    += info[0].yxtra;

#ifdef UNDEFINED
	/* display clip bottom */
	{
	    ybottom -= vp->DyOffset+(view->DyOffset<<((modes & LACE)?1:0));
	    ybottom = MAXYCLIP( ybottom );
	    ybottom += vp->DyOffset+(view->DyOffset<<((modes & LACE)?1:0));
	}
#endif

	ytop >>= ((modes & LACE) ? 1: 0);
	ybottom >>= ((modes & LACE) ? 1: 0);

	if (info[1].scroll != info[0].scroll) info[0].dw--;	/* funny hardware fix, Dale */

	my_dwstop = info[0].dwxstrt + info[0].dw;

	my_dwstop = display_stop( mspc, my_dwstop );

	if ( (GB->ChipRevBits0 & GFXF_HR_DENISE) == 0)
	{
    		CMOVE(c,io->diwstop,(0x7f<<8) | ( 0xff & my_dwstop));
		CBUMP(&cl);
	}
	else
	{
		short ymax;
		UWORD t;

		ymax = mspc->total_rows;

		if (ybottom > ymax) ybottom = ymax;

    		CMOVE(c,io->diwstop,(ybottom<<8) | ( 0xff & my_dwstop));
		CBUMP(&cl);

		/* compute diwhigh */

		t = ((ytop & 0x700) >> 8) | (ybottom & 0x700)
			|  ( (my_dwstop & 0x100)<< 5)
			|  ( (info[0].dwxstrt & 0x100) >> 3);

		CMOVE(c,io->diwhigh,t);  CBUMP(&cl);
	}

	fstrt = SHORTMIN(info[0].dafstrt,info[1].dafstrt);
	fstop = SHORTMAX(info[0].dafstop,info[1].dafstop);

	if (modes & HIRES)	i = 4;
	else			i = 2;

	    if (fstrt < info[0].dafstrt) info[0].plnskip -= i;
	    if (fstrt < info[1].dafstrt) info[1].plnskip -= i;

	    CMOVE(c,io->ddfstrt,fstrt); CBUMP(&cl);
	    CMOVE(c,io->ddfstop,fstop); CBUMP(&cl);

	    /* pfa is [0] pfb is [1] */
	    CMOVE(c,io->bplcon1,(info[1].scroll<<4)|info[0].scroll);
	  CBUMP(&cl);

	    /*dbytes = 2 + ( (fstop - fstrt)>>2 );*/
#ifndef ULTRA_RES
	    /*if (modes & HIRES)   dbytes <<= 1;*/
#endif
	dbytes = get_dbytes(vp,fstrt,fstop);

	    /* set up bit plane modulos */
	    bplmod = info[0].rbytes - dbytes;
	    if (view->Modes & modes & INTERLACE)
		    bplmod += info[0].rbytes;
	    CMOVE(c,io->bpl1mod,bplmod);             CBUMP(&cl);

	    /* set up bit plane modulos */
	    if (depth > 1)
	    {
		bplmod = info[1].rbytes - dbytes;
		if (view->Modes & modes & INTERLACE)
			    bplmod += info[1].rbytes;
		CMOVE(c,io->bpl2mod,bplmod);    CBUMP(&cl);
	    }
	/* now send out bit plane pointers */
	pptr1 = r1->BitMap->Planes;
	pptr2 = r2->BitMap->Planes;
	for (i=0;i<depth;i++)
	{
	    if (i & 1)  p = *pptr2++ + info[1].plnskip;
	    else        p = *pptr1++ + info[0].plnskip;

		c = clongmove(&cl,c,&io->bplpt[i],p,frame);

	    if (view->Modes & modes & INTERLACE)
	    {
		p = (long)p + (long)info[i&1].rbytes;
		c = clongmove(&cl,c,&io->bplpt[i],p,CPR_NT_SHT);
	    }
	}
    }
	if ((GB->ChipRevBits0 & GFXF_HR_DENISE) == 0)
	{
		short ystop;
		/* bart - display clipping */
		/* ystop = vp->DHeight; */
		/* ystop = MAX(vp->DHeight+MIN(vp->DyOffset,0),0); */
		ystop =  ((ybottom-
			 ((vp->ExtendedModes & VPF_A2024)?
			   0x2C:
			   view->DyOffset))
		      << ((modes&INTERLACE)?1:0));

		CWAIT(c,0,0);  CBUMP(&cl);	/* relative to top of vp */
		CMOVE(c,io->bplcon0,mybplcon0);     CBUMP(&cl);
		CWAIT(c,ystop,0);   CBUMP(&cl);
		CMOVE(c,io->bplcon0,(view->Modes&INTERLACE)|GB->system_bplcon0);
		CBUMP(&cl);
	}
#ifdef WAITBOV
	CMOVE(c,io->intreqw,BITSET|ICOPPER);    CBUMP(&cl);
#endif
	CEND(c);   CBUMP(&cl);
#ifdef NEW_HEDLEY
	/* unswizzle viewport stuff */
	if (old_vp)
	{
		old_vp->DspIns = vp->DspIns;
	}
#endif
}

#endif
@


36.70
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.69 89/02/17 11:54:35 bart Exp $
a101 2

#ifdef  PROTOTYPE_DISPLAY
a103 2
    struct RawDisplayInfo  queryinfo;
    struct RawDisplayInfo *info = NULL;
d109 1
a109 10

	/* be vanilla */
	/* info = (struct RawDisplayInfo *)
		   FindTag(&record->rec_Tag,TAG_DISP); */

	if((cook_chunk(record,&queryinfo,sizeof(queryinfo),TAG_DISP,INVALID_ID))
	>= ((ULONG)(&((struct RawDisplayInfo*)0)->ModeID)+sizeof(ULONG)) )
	{
	    info = &queryinfo;
	}
a110 5

    if(info)
    {
	modes = info->ModeID; /* v1.4 modes */
    }
a122 2
#endif

d271 1
a271 1
		if (modes == A2024_10HZ_KEY)
d405 1
a405 1
		if (modes == A2024_10HZ_KEY) t |= 0x800;  /* F6_4 = 1*/
d444 1
a444 1
		if (modes == A2024_10HZ_KEY) t |= 0x800;  /* F6_4 = 1*/
d455 1
a455 1
			if (modes == A2024_10HZ_KEY) t = 6;
d778 1
a778 1
		 (modes != A2024_10HZ_KEY) )
d782 1
a782 1
		/* kprintf("makevp: modes != A2024_10HZ_KEY\n"); */
d796 1
a796 1
		 (modes == A2024_10HZ_KEY) )
d800 1
a800 1
		/* kprintf("makevp: modes == A2024_10HZ_KEY\n"); */
@


36.69
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.68 89/02/16 10:08:11 bart Exp $
@


36.68
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.67 89/02/15 16:06:25 bart Exp $
d131 1
a131 1
	if(modes & EXTEND_VPSTRUCT)
@


36.67
log
@displayinfo_internal
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.66 89/02/15 13:06:41 bart Exp $
d106 2
a107 2
    struct DisplayInfo  queryinfo;
    struct DisplayInfo *info = NULL;
d114 3
a116 2
	/* be vanilla until display.library merges with graphics */
	/* info = (struct DisplayInfo *)FindTag(&record->rec_Tag,TAG_DISP); */
d119 1
a119 1
	>= ((ULONG)(&((struct DisplayInfo*)0)->ModeID)+sizeof(ULONG)) )
@


36.66
log
@merge DisplayInfoDataBase with graphics
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.65 89/02/14 18:22:36 bart Exp $
d29 1
a29 3
#include <display/record.h>
#include <display/defines.h>
#include <graphics/displayinfo.h>
d105 1
a105 1
    struct Record   *record = NULL;
@


36.65
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.64 89/02/14 10:12:53 bart Exp $
d119 2
a120 1
	if((GetDisplayInfoData(record,&queryinfo,sizeof(queryinfo),TAG_DISP,INVALID_ID)) >= ((ULONG)(&((struct DisplayInfo*)0)->ModeID)+sizeof(ULONG)))
@


36.64
log
@checkpoint 02.14.89
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.63 89/02/13 18:05:27 bart Exp $
a30 1
#include <display/modes.h>
d291 1
a291 1
		if (modes == STD_MODE_14)
d425 1
a425 1
		if (modes == STD_MODE_14) t |= 0x800;  /* F6_4 = 1*/
d464 1
a464 1
		if (modes == STD_MODE_14) t |= 0x800;  /* F6_4 = 1*/
d475 1
a475 1
			if (modes == STD_MODE_14) t = 6;
d657 1
a657 1
	(modes & SUPERHIRES ) |	/* new SUPERHIRES */
d798 1
a798 1
		 (modes != STD_MODE_14) )
d802 1
a802 1
		/* kprintf("makevp: modes != STD_MODE_14\n"); */
d816 1
a816 1
		 (modes == STD_MODE_14) )
d820 1
a820 1
		/* kprintf("makevp: modes == STD_MODE_14\n"); */
d1416 1
a1416 1
	(modes & SUPERHIRES ) |	/* new SUPERHIRES */
@


36.63
log
@vanilla display library calls
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.62 89/02/01 17:52:34 bart Exp $
@


36.62
log
@checkpoint -- a2024 10hz and 15hz scan works from 32 bit id
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.61 89/02/01 17:37:44 bart Exp $
d109 2
a110 1
    struct DisplayInfo *info =  NULL;
d116 8
a123 1
	info =  (struct DisplayInfo *)FindTag( &record->rec_Tag, TAG_DISP );
@


36.61
log
@must close window
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.60 89/02/01 11:23:14 bart Exp $
@


36.60
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.59 89/02/01 11:14:13 bart Exp $
d306 1
d446 2
a447 4
/*
			CMOVE(c,io->diwhigh,0);
			CBUMP(&cl);
*/
d782 1
a782 1
		c = clongmove(&cl,c,&io->bplpt[i],p,frame);
d789 1
d791 1
a791 1
		 !(modes == STD_MODE_14) )
d794 3
d809 1
a809 1
	    		(modes == STD_MODE_14) )
d812 3
@


36.59
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.58 89/01/31 18:24:02 bart Exp $
@


36.58
log
@control_deltas now included for prototyping and V35 compatibility
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.57 89/01/31 17:13:41 bart Exp $
d236 1
a236 4
    if (view->Modes & EXTEND_VSTRUCT)
    {
	ve = gfxlookup(view);
	if(ve)
d238 5
a242 1
	    mspc = ve->Monitor;
a243 1
    }
d245 4
a248 4
    if(!mspc)
    {
	mspc = GB->default_monitor;
    }
a249 4
#define V35TYPE

#ifdef V35TYPE

a296 53
#else /* V35TYPE */

#ifdef NEW_HEDLEY
    if (mspc->ms_Flags & REQUEST_A2024)
    {
	    int width;
	    int bpr;	/*bytes per physical row */
	    int phys_rows = 200;	/* assume NTSC */
	    struct RasInfo *ri = vp->RasInfo;
	    struct BitMap *obm = ri->BitMap;
	    if (GB->DisplayFlags & PAL)	phys_rows = 256;
	    bpr = obm->BytesPerRow;
	    width = bpr << 3;
	    hvp = *vp;	/* copy whole structure */
	    old_vp = vp;
	    vp = &hvp;	/* bait and switch */
	    vp->ExtendedModes = old_vp->ExtendedModes;
	    vp->DxOffset = 0;	/* these are most likely ok */
	    vp->DyOffset = 0;
	    /* maybe we can support scrolling?, just a thot */
	    hri.Next = 0;
	    hri.RxOffset = ri->RxOffset; /*old_vp->RasInfo->RxOffset;*/
	    hri.RyOffset = ri->RyOffset; /*old_vp->RasInfo->RyOffset;*/
	    vp->RasInfo = &hri;
	    hri.BitMap = &hbm;
	    /* tweek viewport around for degenerate hardware */
	    /* user depth of 1 requires cheating with 2 */
	    /* user depth of 2 requires cheating with 4 */
	    INITBITMAP(&hbm,obm->Depth<<1,width*2,obm->Rows);
	    hbm.Planes[0] = obm->Planes[0];
	    hbm.Planes[1] = obm->Planes[0]+bpr;
	    if (obm->Depth == 2)
	    {
		    hbm.Planes[2] = obm->Planes[1];
		    hbm.Planes[3] = obm->Planes[1]+bpr;
	    }
	    vp->DHeight = phys_rows;
	    if (modes == STD_MODE_14)
	    {
		    vp->Modes &= ~HIRES; /* bad, bad, bad dale */
		    vp->DWidth = 352;
		    /* view->DxOffset = 0x81-16; */
	    }
	    else
	    {
		    vp->DWidth = 512;
		    /* view->DxOffset = 0x81; */
	    }
    }
#endif

#endif /* V35TYPE */

d312 2
a313 1
    io = &custom;
a372 2
#ifdef V35TYPE

a510 121

#else /* V35TYPE */

#ifdef NEW_HEDLEY
	/* need an absolute wait position */
	if (mspc->ms_Flags & REQUEST_A2024)
	{
		UWORD t;
		int real_depth;
#define H_OFFSET	0x20
/*#define OLDPIXELALIGN*/
#define NEWPIXELALIGN

#ifdef NEWPIXELALIGN
#define KEYCOLOR	1
#else
#define KEYCOLOR	0
#endif
/*#define H_OFFSET	0x0*/
		short tcolor;
		/*short ypos = 0x28-0x2c;*/
		short ypos = -0x1b+4;	/* 1c in docs */
		/*ypos = -4-3;*/	/* visible control region debug */

		/* to make the sprites work, the output depth */
		/* must always be two */
		/*ypos += 16;*/
		/*real_depth = old_vp->RasInfo->BitMap->Depth;*/
		real_depth = 2;
		/* position 0-127 */
		if (GB->DisplayFlags & PAL)	ypos += 8;
		CWAIT(c,ypos-9,0);	/* was a -1 */
		CBUMP(&cl);
		CMOVE(c,io->color[0],0xf00);	/* all colors 0 */
		CBUMP(&cl);
#ifdef OLDPIXELALIGN
		CWAIT(c,ypos,0x45);		/* also trigger pixel catcher */
		CBUMP(&cl);
		t = 1; /* F6-4=0,INTERLACE=0 */
		if (modes == STD_MODE_14) t |= 0x800;  /* F6_4 = 1*/
		CMOVE(c,io->color[0],t);
		CBUMP(&cl);
#endif
#ifdef NEWPIXELALIGN
		/* set up real raster */
		c = clongmove(&cl,c,&io->bplpt[0],GB->a2024_sync_raster,0);
		t = 0x15;
		if (GB->DisplayFlags & PAL) t += 8;
		t <<= 8;		/* move y over to left byte */
		t += 0x61;		/* get x diwstart */
		if (GB->ChipRevBits0 & GFXF_HR_DENISE)	t += 0x100;
		CMOVE(c,io->diwstrt,t)	/* was 0x1561 for ntsc */
		CBUMP(&cl);
		t &= 0xff00;
		t += 0xd1;
		CMOVE(c,io->diwstop,t);
		CBUMP(&cl);
		CMOVE(c,io->ddfstrt,0x40);
		CBUMP(&cl);
		CMOVE(c,io->ddfstop,0xd0);
		CBUMP(&cl);
		/* 1 bitplane hires */
		CMOVE(c,io->bplcon0,HIRES|0x1000|0x200);
		CBUMP(&cl);
		t = 1; /* F6-4=0,INTERLACE=0 */
		if (modes == STD_MODE_14) t |= 0x800;  /* F6_4 = 1*/
		CMOVE(c,io->color[1],t);
		CBUMP(&cl);
#endif

		/* position 128-256 0x67*/
		CWAIT(c,ypos,0x5f+H_OFFSET);
		CBUMP(&cl);
		{
			int i;
			t = 4;
			if (modes == STD_MODE_14) t = 6;
			for (i = 0; i<t ; i++)
			{
				tcolor = 0x1;
				if (i & 1)	tcolor |= 0xf00;
				if (i & 2)	tcolor |= 0x0f0;
				if (i & 4)	tcolor |= 0x008;
				c = cshortmove(&cl,c,&io->color[KEYCOLOR],
				tcolor,field_pick[i]); /* quadrant, expand */
			}
		}

		/* position 256-337? 0x87*/
		CWAIT(c,ypos,0x7f+H_OFFSET);
		CBUMP(&cl);
		t = 0x800;		/* for 1 bitplane */
		if (real_depth == 2)	t = 0x8f0;
		CMOVE(c,io->color[KEYCOLOR],t); /* enp1=enp0=1 wpb=0 */
		CBUMP(&cl);

		/* position 340-512 0xa3*/
		CWAIT(c,ypos,0x9f+H_OFFSET);
		CBUMP(&cl);
		t = 0xfff;		/* for two bitplanes */
		if (real_depth == 1)	t = 0xf0f;	/* one plane */
		t = 0xfff;
		/*real_depth = old_vp->RasInfo->BitMap->Depth;*/
		if (old_vp->RasInfo->BitMap->BytesPerRow > 128 - 2)
			t = 0xff1;
		CMOVE(c,io->color[KEYCOLOR],t); /* 0x889 dpl0=dpl1=1,less16=1*/
		CBUMP(&cl);
		CWAIT(c,ypos+1,0);
		CBUMP(&cl);
		CMOVE(c,io->color[0],0x000); /* turn off for rest of display */
		CBUMP(&cl);
#ifdef NEWPIXELALIGN
		CMOVE(c,io->bplcon0,0);
		CBUMP(&cl);
#endif

	}
#endif

#endif /* V35 TYPE */

@


36.57
log
@v35 type hedley processing works for fast scan mode
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.56 89/01/31 15:38:54 bart Exp $
d461 1
a461 1
			/* ypos += GB->control_delta_pal; */
d465 1
a465 1
			/* ypos += GB->control_delta_ntsc; */
d486 1
a486 1
			/* t += GB->control_delta_pal; */
d490 1
a490 1
			/* t += GB->control_delta_ntsc; */
@


36.56
log
@checkpoint 2024
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.55 89/01/26 11:10:57 bart Exp $
d250 53
d352 2
d429 2
d458 141
d687 2
@


36.55
log
@removed vpe
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.54 89/01/24 15:37:59 bart Exp $
d31 1
d196 2
d236 14
d251 738
d1699 2
@


36.54
log
@checkpoint 01.24.89
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.53 89/01/23 13:22:28 bart Exp $
a46 5
#define MINXCLIP(x) (vpe?(MAX((x),(vpe->DisplayClip.MinX))):(x))
#define MINYCLIP(y) (vpe?(MAX((y),MAX(0,(vpe->DisplayClip.MinY-vp->DyOffset)))):(y))
#define MAXXCLIP(x) (vpe?(MIN((x),(vpe->DisplayClip.MaxX))):(x))
#define MAXYCLIP(y) (vpe?(MIN((y),MAX(0,((vpe->DisplayClip.MaxY+1)-vp->DyOffset)))):(y))

a202 1
    struct ViewPortExtra *vpe=0;
a295 2
	if (vp->Modes & EXTEND_VPSTRUCT) vpe = gfxlookup(vp);

d592 1
a593 1
#ifdef UNDEFINED
d817 1
a818 1
#ifdef UNDEFINED
@


36.53
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.52 89/01/23 13:18:44 bart Exp $
@


36.52
log
@TAG_DISP corrections
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.51 89/01/23 11:52:58 bart Exp $
d31 1
d124 1
a124 1
	modes = info->ModeID; /* 1.4 mode */
@


36.51
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.50 89/01/23 11:48:54 bart Exp $
d29 2
a30 1
#include <graphics/displayinfo.h>
d111 2
a112 1
    struct DisplayInfo *dinfo = NULL;
d115 2
a116 2
    &&  (dinfo = cm->CoerceDisplayInfo)
    ||  (dinfo = cm->NormalDisplayInfo) )
d118 6
a123 1
	modes = dinfo->ModeID;
@


36.50
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.49 89/01/19 17:28:19 bart Exp $
d29 1
a29 2
#include <display/record.h>
#include <display/defines.h>
a110 1
    struct TagItem  *item =  NULL;
@


36.49
log
@checkpoint 01.19.89 coercion down to default
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.48 89/01/19 10:25:43 bart Exp $
d111 1
a111 1
    struct Record   *dinfo = NULL;
d118 1
a118 6
	item =  FindTag( &dinfo->rec_Tag, TAG_MODES);
    }

    if(item)
    {
	modes = item->ti_Data; /* 1.4 mode */
@


36.48
log
@extend vpstruct
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.47 89/01/18 13:54:28 bart Exp $
@


36.47
log
@checkpoint 01.18.89
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.46 89/01/17 16:08:08 bart Exp $
d127 1
a127 1
	if(modes & 2)
@


36.46
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.45 89/01/17 15:55:09 bart Exp $
d26 7
d104 38
d147 2
d150 1
a150 1
	if (vp->Modes & SUPERHIRES)
d153 1
a153 1
	    if (vp->Modes & HIRES)
a198 21
#include <display/defines.h>

map_mode(old_mode)
ULONG old_mode;
{
    ULONG tmp_mode = old_mode & ~(SPRITES|VP_HIDE|EXTEND_VPSTRUCT);
    ULONG new_mode = old_mode;

    /* kprintf("map_modes: old_mode = 0x%08lx\n", old_mode); */

    if( tmp_mode == PROTO_MODE_ID) new_mode &= ~LACE;  
    if( tmp_mode == VLORES_MODE_ID) new_mode &= ~LACE;  
    if( tmp_mode == VXLORES_MODE_ID) new_mode &= ~LACE;  

    new_mode &= (old_mode & SUPERHIRES) ? ~HIRES : ~0;

    /* kprintf("map_modes: new_mode = 0x%08lx\n", new_mode); */

    return(new_mode);
}

d225 1
a225 1
    ULONG  modes = map_mode(vp->Modes);
a275 1
		    modes &= ~HIRES;
d301 1
a301 1
	if (modes & EXTEND_VPSTRUCT)	vpe = gfxlookup(vp);
d355 1
a355 1
	    if (modes & SPRITES)    y--;
d571 1
a571 1
    		if (modes & SPRITES)
@


36.45
log
@map_modes correction
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.44 89/01/16 15:49:58 bart Exp $
a26 2

#define UNDEFINED
@


36.44
log
@map_mode checkpoint
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.43 89/01/13 12:40:26 bart Exp $
d28 2
d159 1
d164 3
a166 3
    if( old_mode == PROTO_MODE_ID) new_mode &= ~LACE;  
    if( old_mode == VLORES_MODE_ID) new_mode &= ~LACE;  
    if( old_mode == VXLORES_MODE_ID) new_mode &= ~LACE;  
@


36.43
log
@simultaneous hires/super bits set
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.42 88/10/17 15:07:46 bart Exp $
d152 20
d198 1
a198 1
    UWORD modes = (vp->Modes & SUPERHIRES) ? vp->Modes & ~HIRES : vp->Modes;
d201 58
a258 56
	struct ViewPort *old_vp=0;
	struct ViewPort hvp;
	struct RasInfo hri;
	struct BitMap hbm;
	struct ColorMap *cm = vp->ColorMap;
	/*kprintf("MAKEVP(%lx,%lx)\n",view,vp);*/
	FETCHGBASE;
	if (vp->ExtendedModes & VPF_A2024)
	{
		int width;
		int bpr;	/*bytes per physical row */
		int phys_rows = 200;	/* assume NTSC */
		struct RasInfo *ri = vp->RasInfo;
		struct BitMap *obm = ri->BitMap;
		if (GB->DisplayFlags & PAL)	phys_rows = 256;
		bpr = obm->BytesPerRow;
		width = bpr << 3;
		hvp = *vp;	/* copy whole structure */
		old_vp = vp;
		vp = &hvp;	/* bait and switch */
		vp->ExtendedModes = old_vp->ExtendedModes;
		vp->DxOffset = 0;	/* these are most likely ok */
		vp->DyOffset = 0;
		/* maybe we can support scrolling?, just a thot */
		hri.Next = 0;
		hri.RxOffset = ri->RxOffset; /*old_vp->RasInfo->RxOffset;*/
		hri.RyOffset = ri->RyOffset; /*old_vp->RasInfo->RyOffset;*/
		vp->RasInfo = &hri;
		hri.BitMap = &hbm;
		/* tweek viewport around for degenerate hardware */
		/* user depth of 1 requires cheating with 2 */
		/* user depth of 2 requires cheating with 4 */
		INITBITMAP(&hbm,obm->Depth<<1,width*2,obm->Rows);
		hbm.Planes[0] = obm->Planes[0];
		hbm.Planes[1] = obm->Planes[0]+bpr;
		if (obm->Depth == 2)
		{
			hbm.Planes[2] = obm->Planes[1];
			hbm.Planes[3] = obm->Planes[1]+bpr;
		}
		vp->DHeight = phys_rows;
		if (vp->ExtendedModes & VPF_TENHZ)
		{
			vp->Modes &= ~HIRES; /* bad, bad, bad dale */
			modes &= ~HIRES;
			vp->DWidth = 352;
			/* view->DxOffset = 0x81-16; */
		}
		else
		{
			vp->DWidth = 512;
			/* view->DxOffset = 0x81; */
		}
	}
#else
	FETCHGBASE;
@


36.42
log
@default monitorspec guaranteed to exist ... optimise
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.41 88/10/06 14:12:31 bart Exp $
d103 4
a106 1
	if (vp->Modes & HIRES)
a108 3
		if (vp->Modes & SUPERHIRES)
			dbytes = (0xfffc & (6 + ((fstop-fstart)>>1)))<<1;
	else
d178 2
d224 2
a225 1
			vp->Modes &= ~HIRES;
d253 1
a253 1
	if (vp->Modes & EXTEND_VPSTRUCT)	vpe = gfxlookup(vp);
d263 1
a263 1
	if (vp->Modes&INTERLACE)    frame = CPR_NT_LOF;
d269 1
a269 1
	if (vp->Modes & DUALPF)	r2 = r1->Next;
d287 1
a287 1
	else if ((vp->Modes & (HAM|EXTRA_HALFBRITE))== 0)
d299 3
a301 3
		   << ((vp->Modes & LACE) ? 1: 0));
	ytop  += ((vp->Modes & LACE) ? 1: 0);
	ytop >>= ((vp->Modes & LACE) ? 1: 0);
d305 1
a305 1
	else if((depth > 3) || (vp->Modes & SUPERHIRES))
d307 1
a307 1
	    if (vp->Modes & SPRITES)    y--;
d312 1
a312 1
		    MIN(vp->Modes&LACE?(vp->DyOffset>>1):vp->DyOffset,0),
d319 1
a319 1
	y <<= ((vp->Modes & LACE) ? 1: 0);
d323 2
a324 2
	yclip <<= ((vp->Modes & LACE) ? 1: 0);
	ytop  <<= ((vp->Modes & LACE) ? 1: 0);
d452 1
a452 1
    if (vp->Modes & (DUALPF|HAM))   x = 16;
d471 1
a471 1
	     (vp->Modes & SUPERHIRES) )
d523 1
a523 1
    		if (vp->Modes & SPRITES)
d527 1
a527 1
			    (vp->Modes & (DUALPF|HAM)) /* special? */ )
d547 1
a547 1
	ybottom += HFIX((~info[0].yxtra) & (vp->Modes&LACE?1:0));
d554 1
a554 1
	    ybottom -= vp->DyOffset+(view->DyOffset<<((vp->Modes & LACE)?1:0));
d556 1
a556 1
	    ybottom += vp->DyOffset+(view->DyOffset<<((vp->Modes & LACE)?1:0));
d560 2
a561 2
	ytop >>= ((vp->Modes & LACE) ? 1: 0);
	ybottom >>= ((vp->Modes & LACE) ? 1: 0);
d586 1
a586 1
	(vp->Modes & SUPERHIRES ) |	/* new SUPERHIRES */
d588 1
a588 1
	(vp->Modes & (HOLDNMODIFY|DUALPF) );
d590 1
a590 1
	(vp->Modes & (HOLDNMODIFY|DUALPF|HIRES) );
d599 1
a599 1
	if (vp->Modes & SUPERHIRES)
d601 1
a601 1
	x |= (vp->Modes & PF2PRI);
d698 1
a698 1
	if (view->Modes & vp->Modes & INTERLACE)
d720 1
a720 1
	    if (view->Modes&INTERLACE&vp->Modes)
d772 1
a772 1
	ybottom += HFIX((~info[0].yxtra) & (vp->Modes&LACE?1:0));
d779 1
a779 1
	    ybottom -= vp->DyOffset+(view->DyOffset<<((vp->Modes & LACE)?1:0));
d781 1
a781 1
	    ybottom += vp->DyOffset+(view->DyOffset<<((vp->Modes & LACE)?1:0));
d785 2
a786 2
	ytop >>= ((vp->Modes & LACE) ? 1: 0);
	ybottom >>= ((vp->Modes & LACE) ? 1: 0);
d823 1
a823 1
	if (vp->Modes & HIRES)	i = 4;
d838 1
a838 1
	    /*if (vp->Modes & HIRES)   dbytes <<= 1;*/
d844 1
a844 1
	    if (view->Modes & vp->Modes & INTERLACE)
d852 1
a852 1
		if (view->Modes & vp->Modes & INTERLACE)
d866 1
a866 1
	    if (view->Modes & vp->Modes & INTERLACE)
d883 1
a883 1
		      << ((vp->Modes&INTERLACE)?1:0));
@


36.41
log
@undefined y += MAX( ... )
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.40 88/10/05 15:24:14 bart Exp $
d33 2
a34 2
#define HFIX(x)	(mspc?(((x)*mspc->ratioh)>>4):x)
#define VFIX(y)	(mspc?(((y)*mspc->ratiov)>>4):y)
d140 1
a140 1
	if(mspc)
d142 1
a142 3
	    if (dwstop > mspc->DeniseMaxDisplayColumn)
	    {
		dwstop = DENISE_OFFSET+1;
d144 1
a144 9
		if (!(GB->ChipRevBits0 & GFXF_HR_DENISE))
		{
		    dwstop += (mspc->DeniseMaxDisplayColumn);
		}
	    }
	}
	else
	{
	    if (dwstop > STANDARD_DENISE_MAX)
d146 1
a146 6
		dwstop = DENISE_OFFSET+1;

		if (!(GB->ChipRevBits0 & GFXF_HR_DENISE))
		{
		    dwstop += (STANDARD_DENISE_MAX);
		}
d252 1
a252 2
        min_ytop = mspc ? mspc->min_row :
       		   ((GB->DisplayFlags & PAL) ? MIN_PAL_ROW : MIN_NTSC_ROW);
d609 4
a612 5
	if (mspc)
	{
		/* EXTBLKNEN */	/* new chips */
		/* following is for old rev denise */
		if (mspc->total_colorclocks != 226) x |= 0x80;
d614 1
a614 1
		if (GB->Debug & 0x08)	x |= 0x80;
d616 4
a619 5
		if (x & 0x80)   /* for new chips */
		{
		    realbplcon0 |= 1;
		    bplcon3 |= 1;   /* EXTBLKEN */
		}
d621 1
a667 8
		if (mspc)
		{
			ymax = mspc->total_rows;
		}
		else
		{
			ymax = GB->MaxDisplayRow;
		}
d669 2
d800 2
a801 8
		if (mspc)
		{
			ymax = mspc->total_rows;
		}
		else
		{
			ymax = GB->MaxDisplayRow;
		}
@


36.40
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.39 88/10/05 13:20:50 bart Exp $
d323 1
d325 1
a325 1
		    MIN(vp->Modes&LACE?(vp->DyOffset>>1):vp->DyOffset,0), 
d330 1
@


36.39
log
@dont mess with view DxOffset
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.38 88/10/04 14:54:04 bart Exp $
d310 3
a312 2
	ytop   =   vp->DyOffset;
	ytop  +=  (view->DyOffset << ((vp->Modes & LACE) ? 1: 0));
d325 3
a327 1
		    min_ytop-view->DyOffset 
d795 1
d801 1
d903 5
a907 1
		ystop = ((ybottom-view->DyOffset)<<((vp->Modes&INTERLACE)?1:0));
@


36.38
log
@#ifdef UNDEFINED display clip bottom
removed at jimm and dale's request
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.37 88/10/03 15:16:02 bart Exp $
d239 1
a239 1
			view->DxOffset = 0x81-16;
d244 1
a244 1
			view->DxOffset = 0x81;
@


36.37
log
@removed ybottom += yclip... not likely :-) bart
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.36 88/10/03 10:52:45 bart Exp $
d560 1
d566 1
@


36.36
log
@clip to min display row
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.35 88/09/21 17:05:08 bart Exp $
a335 1
	ybottom  += yclip;
@


36.35
log
@display clip bottom
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.34 88/09/16 01:05:37 bart Exp $
a26 1
#define MIN_YTOP        0x15
d180 1
a180 1
    short min_ytop = MIN_YTOP; /* default limit */
d267 2
a268 4
	if(mspc)
	{
	    min_ytop  = mspc->min_row; 
	}
@


36.34
log
@checkpoint for alpha 14 release
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.33 88/09/16 00:03:54 bart Exp $
d43 1
a43 1
#define MAXYCLIP(y) (vpe?(MIN((y),MIN(0,(vpe->DisplayClip.MaxY-vp->DyOffset)))):(y))
d563 7
d792 7
@


36.33
log
@yxtra
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.32 88/09/13 17:01:47 bart Exp $
a39 1
#ifdef CLIPPING
a43 6
#else
#define MINXCLIP(x) (x)
#define MINYCLIP(y) (y)
#define MAXXCLIP(x) (x)
#define MAXYCLIP(y) (y)
#endif
d174 3
a176 3
	struct ViewExtra *ve=0;
	struct MonitorSpec *mspc=0;
	struct ViewPortExtra *vpe=0;
d181 4
a184 6
	short min_ytop = MIN_YTOP; /* default limit */
	short ytop;	/* absolute top of this viewport */
	short ybottom;	/* absolute bottom of this viewport */
#ifdef CLIPPING
	short yclip;	/* force clipping of top lines of viewport */
#endif
d266 2
d270 1
a270 1
	    min_ytop = mspc->min_row;
a272 2
	if (vp->Modes & EXTEND_VPSTRUCT)	vpe = gfxlookup(vp);

a312 1

a338 3

#ifdef CLIPPING
	/* yclip top of viewport (non-positive) -- bart */
a340 1
#endif
a341 4
#ifdef BUGGY_HARDWARE
		ybottom++;
#endif

a556 1
#ifdef CLIPPING
d558 1
a561 3
#else
	getstuff(view,vp,r1,&info[0]);
#endif
d566 1
a779 1
#ifdef CLIPPING
d781 1
a784 3
#else
	getstuff(view,vp,r2,&info[1]);
#endif
a905 199

#ifndef CLIPPING
getstuff(view,vp,r,ip)
register struct gs_info *ip;
struct ViewPort *vp;
struct View *view;
struct RasInfo *r;
{
	short rx,dfxstrt,mask;
	short rscroll;
	struct GfxBase *GB;
	short t = 0;
	short hack2;
	struct ViewExtra *ve = 0;
	struct ViewPortExtra *vpe = 0;
	short clip_extra;
#ifdef CLIPPING
	short vpy_neg = yclip;
#endif

	FETCHGBASE;

	if (view->Modes & EXTEND_VSTRUCT)	ve = gfxlookup(view);
	if (vp->Modes & EXTEND_VPSTRUCT)	vpe = gfxlookup(vp);

	/* ip->dw = vp->DWidth; */  
	/* display clipping -- bart */ 

	ip->dwxstrt = MINXCLIP(vp->DxOffset);
	clip_extra = MAX(0,((ip->dwxstrt)-(vp->DxOffset)));

	ip->dw = MAX(0,(MAXXCLIP(vp->DxOffset+vp->DWidth)-(ip->dwxstrt))); 

	rx = r->RxOffset;
	rx += clip_extra;

try_again:
#ifdef ULTRA_RES
	if (0)
#else
    if ( (vp->Modes & HIRES) || (vp->Modes & SUPERHIRES) )
#endif
	{
		ip->dwxstrt >>= 1;
		rx >>= 1;

		/* adjust rounding of display width for displayclip -- bart */
		ip->dw += (clip_extra&1);

		ip->dw >>= 1;
		mask = 7;
		dfxstrt = 0x3c;
		if (vp->Modes & SUPERHIRES)
		{
			ip->dwxstrt >>= 1;
			rx >>= 1;
			ip->dw >>= 1;
			mask = 3;
			/*dfxstrt = 0x40;*/
		}
	}
	else
	{
		mask = 15;
		dfxstrt = 0x38;
	}

		dfxstrt = NEW_HFIX(dfxstrt);
    	hack2 = rscroll = mask & (-rx);

	if (vp->Modes & DUALPF)
	{
		struct RasInfo *r2;
		short rx2;
		r2 = vp->RasInfo;
		if (r == r2)	r2 = r->Next;
		rx2 =  r2->RxOffset;	/* hope I don't have to worry about */

		/* display clipping -- bart */ 
		rx2 += clip_extra;

		/* try_again: */
		if (vp->Modes & HIRES)	rx2 >>= 1;
		hack2 |= mask & (-rx2);
	}

	/* clip on the right */
	t = GB->MaxDisplayColumn;
	if (hack2)	t -= 10;		/* more funny hardware */

	ip->dwxstrt += view->DxOffset;

	if (ip->dwxstrt + ip->dw > t)
	{
		ip->dw = t - ip->dwxstrt;
	}
    	ip->dwxstrt -= DENISE_HFIX(LEFT_EDGE_MAGIC);
    	ip->rbytes = r->BitMap->BytesPerRow;
#ifdef ULTRA_RES
    	ip->plnskip = smuls(ip->rbytes,r->RyOffset) + ((rx>>(0&HIRES?3:4))<<1);
#else
    	/* ip->plnskip = smuls(ip->rbytes,r->RyOffset)
			 + ((rx>>(vp->Modes&HIRES?3:4))<<1); */

		/* display clipping */
		ip->plnskip = smuls(ip->rbytes,MINYCLIP(r->RyOffset))
			 + ((rx>>(vp->Modes&HIRES?3:4))<<1);

		/* display clipping */
		if (vp->Modes & SUPERHIRES)
		{
    		ip->plnskip = smuls(ip->rbytes,MINYCLIP(r->RyOffset))
			 + ((rx>>(vp->Modes&HIRES?4:5))<<2);
		}

		/* allow negative DyOffsets ?  -- bart */
#ifdef CLIPPING
		if(vpy_neg)
		{
    		ip->plnskip+= smuls(ip->rbytes,(-(MIN((vpy_neg+(r->RyOffset)),0))));
		}
#endif

#endif

    	ip->scroll = (mask&ip->dwxstrt) + rscroll;

    	if (ip->scroll > mask)
    	{
		ip->scroll &= mask;
		rscroll = 0;
    	}
    	if (rscroll)
    	{   
		dfxstrt -= 8;
#ifndef ULTRA_RES
		if (vp->Modes & HIRES)   ip->plnskip -= 2;
		if (vp->Modes & SUPERHIRES) ip->plnskip -= 4;
#endif
    	}
#ifdef ULTRA_RES
    	ip->dafstrt = dfxstrt + ((ip->dwxstrt>>1) & 0xFFF8);
#else
	if (vp->Modes & HIRES)
		 ip->dafstrt = dfxstrt + ((ip->dwxstrt>>1) & 0xFFFC);
    	else ip->dafstrt = dfxstrt + ((ip->dwxstrt>>1) & 0xFFF8);
	if (vp->Modes & SUPERHIRES)
	{
		ip->dafstrt = dfxstrt + ((ip->dwxstrt>>1) & 0xFFFC);
		/* commented out next statement for beamcon */
#ifdef NEWTEST
		if (ve == 0) if (ip->dafstrt & 0x4 )	ip->plnskip -= 2;
#endif
		if (ip->dafstrt & 0x4 )	ip->plnskip -= 2;
	}
	t = (GB->MinDisplayColumn>>1) - ip->dafstrt;
#ifdef DEBUG
	kprintf("dafstrt = %lx t =%lx\n",ip->dafstrt,t);
#endif
	if (t > 0)
	{	/* too far to the left */
#ifdef DEBUG
		kprintf("to far left t=%lx\n",t);
#endif
		t <<= 1;
		if (vp->Modes & HIRES) t <<= 1;
		if (vp->Modes & SUPERHIRES) t <<= 1;
		rx = r->RxOffset + t;
    		ip->dwxstrt = vp->DxOffset + t;
    		ip->dw = vp->DWidth - t;
		goto try_again;
	}
#endif

#ifdef ULTRA_RES
    	ip->dafstop = ip->dafstrt + (((ip->dw+15)>>1)&0xFFF8) - 8;
#else
    	/*ip->dafstop = ip->dafstrt + (((ip->dw+15)>>1)&0xFFF8)
				 - (mask&(rx|ip->dwxstrt)?0:8);*/
    	ip->dafstop = ip->dafstrt + (((ip->dw+15)>>1)&0xFFF8)
				 - (mask&rx?0:8);


	/* impose ultimate max */
	if (ip->dafstop > HFIX(0xd8)) ip->dafstop = HFIX(0xd8);
	if ( (vp->Modes & HIRES) || (vp->Modes & SUPERHIRES) )
	{
		ip->dafstop -= 4;
		ip->dafstop = MIN(ip->dafstop,0xd4);
	}
#endif

	ip->dwxstrt += DENISE_HFIX(LEFT_EDGE_MAGIC);
#ifdef DEBUG
	    kprintf("dafstrt=%lx dafstop = %lx\n",ip->dafstrt,ip->dafstop);
	    kprintf("dwxstrt = %lx dw=%lx\n",ip->dwxstrt,ip->dw);
#endif
}
#endif
@


36.32
log
@videoscan() processing and denise backwards compatibility
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.31 88/09/12 12:36:11 bart Exp $
a321 2
	ytop = view->DyOffset+(vp->Modes&LACE?(vp->DyOffset>>1):vp->DyOffset);
	ybottom = ytop+(vp->Modes&LACE?(vp->DHeight>>1):vp->DHeight)-1;
d323 4
a326 3
#ifdef DEBUG
	kprintf("absolute ytop=%lx ybottom=%lx\n",ytop,ybottom);
#endif
a334 3
	/* may need more space for copper instructions -- bart */
	/* y += MIN(vp->DyOffset,0); */

d340 1
a340 1
	if (vp->Modes & INTERLACE)	y <<= 1;
d342 8
d352 2
a353 3
	yclip = HFIX(MIN((VFIX(ytop)-min_ytop),0));
	ytop -= yclip;
	if (vp->Modes & INTERLACE) ybottom -= (yclip >> 1);
d577 3
d584 3
d802 3
d808 3
@


36.31
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.30 88/09/12 12:29:24 bart Exp $
d144 4
d152 6
a157 1
		dwstop -= (mspc->DeniseMaxDisplayColumn-1);
d164 6
a169 1
		dwstop -= (STANDARD_DENISE_MAX-1);
@


36.30
log
@display_stop()
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.29 88/09/11 14:00:23 bart Exp $
d141 2
a142 1
UWORD stop;
d158 1
a158 1

@


36.29
log
@vp->Modes & SUPERHIRES
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.28 88/08/12 13:18:20 bart Exp $
d140 20
d659 3
d783 1
d785 2
@


36.28
log
@mspc->DeniseMinDisplayColumn
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.27 88/08/09 14:30:17 bart Exp $
a25 3
/* temporary define */
#define VP_SUPER_HIRES 0x80

d114 1
a114 1
		if (vp->ExtendedModes & VP_SUPER_HIRES)
d296 1
a296 1
	else if((depth > 3) || (vp->ExtendedModes & VP_SUPER_HIRES))
d462 2
a463 1
	if (vp->ExtendedModes & (VPF_A2024 | VP_SUPER_HIRES) )
d565 1
a565 1
	(vp->ExtendedModes & VP_SUPER_HIRES? 0x40 : 0) |	/* new VP_SUPER_HIRES */
d578 1
a578 1
	if (vp->ExtendedModes & VP_SUPER_HIRES)
d913 1
a913 1
    if ( (vp->Modes & HIRES) || (vp->ExtendedModes & VP_SUPER_HIRES) )
d925 1
a925 1
		if (vp->ExtendedModes & VP_SUPER_HIRES)
d982 1
a982 1
		if (vp->ExtendedModes & VP_SUPER_HIRES)
d1010 1
a1010 1
		if (vp->ExtendedModes & VP_SUPER_HIRES) ip->plnskip -= 4;
d1019 1
a1019 1
	if (vp->ExtendedModes & VP_SUPER_HIRES)
d1039 1
a1039 1
		if (vp->ExtendedModes & VP_SUPER_HIRES) t <<= 1;
d1058 1
a1058 1
	if ( (vp->Modes & HIRES) || (vp->ExtendedModes & VP_SUPER_HIRES) )
@


36.27
log
@CWAIT(c,HFIX(VFIX(y)-(VFIX(1)>>1)),0);
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.26 88/08/19 10:27:36 bart Exp $
@


36.26
log
@sprite colors in DUALPF|HAM
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.25 88/07/25 14:45:14 bart Exp $
d442 1
a442 1
	CWAIT(c,VFIX(y)-(VFIX(1)>>1),0);
@


36.25
log
@ifdef DEBUG: if (GB->Debug & 0x08)   x |= 0x80;
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.24 88/07/25 14:39:22 bart Exp $
d519 3
a521 1
			if (depth < 5)  /* already all load up? */
@


36.24
log
@default_monitorspec
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.23 88/07/23 17:08:55 bart Exp $
d596 1
d598 1
@


36.23
log
@monitorspec -- bart 07.23.88 merge source
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.22 88/07/23 13:57:31 dale Exp $
d234 1
a234 4
		if(mspc = ve->Monitor)
		{
		    min_ytop = mspc->min_row;
		}
d237 11
d551 7
a557 2
    		x = (min_ytop<<8) | (0xff&info[0].dwxstrt);
	else	x = (ytop<<8)|(0xff&info[0].dwxstrt);
d561 1
a561 1
    /* hopefully sprites are still see able */
d563 1
a563 1
    mybplcon0 = GB->system_bplcon0 | ( depth << PLNCNTSHFT ) |
@


36.22
log
@checkin before merging monitorspec
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.21 88/07/13 22:23:45 dale Exp $
d37 2
a38 2
#define HFIX(x)	(ve?(((x)*ve->ratioh)>>4):x)
#define VFIX(y)	(ve?(((y)*ve->ratiov)>>4):y)
d150 1
d156 1
d167 4
a170 4
	struct RasInfo *r1,*r2=0;
	struct GfxBase *GB;
	struct gs_info info[2];
	USHORT frame = 0;
d229 11
a239 1
	if (view->Modes & EXTEND_VSTRUCT)	ve = gfxlookup(view);
d291 1
a291 1
	else if(depth > 3)
d297 1
d301 1
a301 1
		    MIN_YTOP-view->DyOffset 
a306 1

d308 1
a308 1
	yclip = HFIX(MIN((VFIX(ytop)-MIN_YTOP),0));
d314 1
a314 1
	ybottom++;
d543 1
a543 1
    		x = (MIN_YTOP<<8) | (0xff&info[0].dwxstrt);
d578 1
a578 1
	if (ve)
d582 3
a584 3
		if (ve->total_colorclocks != 226) x |= 0x80;
		if (GB->Debug & 0x80)	x |= 0x80;
		if (x & 0x80)	/* for new chips */
d586 2
a587 2
			realbplcon0 |= 1;
			bplcon3 |= 1;	/* EXTBLKEN */
d595 10
a604 10
			if (ve->ve_VideoFlags & ve_BRDRBLNK)
			{
				realbplcon0 |= 1;
				bplcon3 |= 0x20;
			}
			if (ve->ve_VideoFlags & ve_BRDRNTRN)
			{
				realbplcon0 |= 1;
				bplcon3 |= 0x10;
			}
d608 1
a608 2
	
    	CMOVE(c,io->bplcon0,realbplcon0); CBUMP(&cl);
d612 1
a612 1
		CMOVE(c,io->bplcon3,bplcon3); CBUMP(&cl);
d633 1
a633 1
		if (ve)
d635 1
a635 1
			ymax = ve->total_rows;
d648 1
d756 1
a756 1
		if (ve)
d758 1
a758 1
			ymax = ve->total_rows;
d771 1
a1047 13

#ifdef BARTDEBUG
	/* force fetch width limits */
	if(ve)
	{
	    if (ve->total_colorclocks != 226)
	    {
		ip->dafstop =  ip->dafstrt+
		   (((ip->dafstop-ip->dafstrt)+(ip->dafstrt&2))&0xFFF8);
	    }
	}
#endif

@


36.21
log
@Changes for bitplane genlock control.
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.20 88/06/30 21:51:42 bart Exp $
d162 2
d547 2
a548 2
    		x = mybplcon0;
	else	x = (view->Modes&INTERLACE)|(GB->system_bplcon0);
a549 2
    	CMOVE(c,io->bplcon0,x);
	CBUMP(&cl);
d568 2
a569 1
			/* EXTBLKNEN */	/* new chips */
d572 5
d578 20
d599 4
@


36.20
log
@(ytop & 0x700)
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.19 88/06/28 17:00:49 bart Exp $
d560 5
@


36.19
log
@ystop
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.18 88/06/28 16:00:13 bart Exp $
d602 1
a602 1
		t = (ytop >> 8) | (ybottom & 0x700)
d724 1
a724 1
		t = (ytop >> 8) | (ybottom & 0x700)
@


36.18
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.17 88/06/28 15:54:47 bart Exp $
d790 1
a790 1
		ystop = ybottom - view->DyOffset;
@


36.17
log
@ystop for old chips
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.16 88/06/23 18:03:36 bart Exp $
d786 1
a786 1
		/* short ystop,maxystop; */
@


36.16
log
@top clip
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.15 88/06/16 12:02:52 bart Exp $
d299 4
d595 1
a595 3
#ifdef BUGGY_HARDWARE
		ybottom++;
#endif
d717 1
a717 3
#ifdef BUGGY_HARDWARE
		ybottom++;
#endif
d790 1
a790 1
		/* ystop = ybottom */
d794 1
a794 1
		CWAIT(c,ybottom,0);   CBUMP(&cl);
@


36.15
log
@ytop, ybottom depend on vp->Modes&LACE...
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.14 88/06/13 16:36:26 bart Exp $
d281 8
a291 2
	/* may need more space for copper instructions -- bart */
	y += MIN(vp->DyOffset,0);  
d295 2
a296 1
	ybottom += yclip;
@


36.14
log
@dualpf now set diwhigh if new denise
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.13 88/06/10 11:53:21 bart Exp $
d261 10
a270 8
    /* wait for correct position on the display */
    /* y is relative to view.DyOffset */
    /* all waits are positioned relative to view.DyOffset during MrgCop */
    /* y if where the display is to begin */
    /* adjust y to leave enough space for copper maneuvers */
    /* if we have more than 4 bit planes then or sprite colors */
	ytop = view->DyOffset + (view->Modes & LACE ? (vp->DyOffset>>1):vp->DyOffset);
	ybottom = ytop + (view->Modes & LACE ? (vp->DHeight>>1):vp->DHeight)  - 1;
d274 1
@


36.13
log
@getclipstuff -- bart 
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.12 88/05/02 19:02:16 dale Exp $
d677 1
a677 1
	int my_dwstop;
d687 2
a688 5
    	CMOVE(c,io->diwstop,(x<<8) | ( 0xff & my_dwstop));
			 CBUMP(&cl);
    
	/* for now hack for new chips */
	if (ve)
d690 6
d697 12
a708 2
		t = 0x100;	/* hack */
		t |= (my_dwstop & 0xff00) <<5;
d710 8
d721 2
a722 2
	    fstrt = SHORTMIN(info[0].dafstrt,info[1].dafstrt);
	    fstop = SHORTMAX(info[0].dafstop,info[1].dafstop);
d776 1
a776 1
		short ystop,maxystop;
d779 3
a781 1
		ystop = MAX(vp->DHeight+MIN(vp->DyOffset,0),0);
d784 1
a784 1
		CWAIT(c,ystop,0);   CBUMP(&cl);
@


36.12
log
@More changes to support setrgb4,loadrgb4 for genlock control.
Also changed the interface to check_genlock to take a ColorMap
ptr instead of Flags and Bits. Makes it a little more general purpose
as well as all the callers a little more efficient.
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.11 88/05/02 17:37:17 dale Exp $
d502 1
a502 1
	getstuff(view,vp,r1,&info[0],yclip);
d680 1
a680 1
	getstuff(view,vp,r2,&info[1],yclip);
d778 1
a778 4
#ifdef CLIPPING
getstuff(view,vp,r,ip,yclip)
short yclip;
#else
a779 1
#endif
d988 1
@


36.11
log
@Now sets appropriate bit in bplcon2 if ColorMap->Flags & COLORMAP_TRANSPARENCY
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.10 88/06/02 15:17:43 bart Exp $
a101 2
unsigned short dflt_genlock[] =  {0,0};	/* 32 bits of zero */

d129 2
a130 2
unsigned short check_genlock(Flags,i,genlock_bits)
unsigned char Flags;
a131 1
unsigned short *genlock_bits;
d133 1
a133 1
	if (Flags & COLORMAP_TRANSPARENCY)
d135 1
a413 1
		unsigned char Flags;
a416 1
		unsigned short *genlock_bits;
a420 2
			genlock_bits = dflt_genlock;
			Flags = 0;
a424 1
			genlock_bits = cm->TransparencyBits;
a425 1
			Flags = cm->Flags;
d466 1
a466 1
				color |= check_genlock(Flags,i,genlock_bits);
d477 1
a477 1
			color |= check_genlock(Flags,i,genlock_bits);
d491 1
a491 1
					color |= check_genlock(Flags,i,genlock_bits);
@


36.10
log
@BARTDEBUG (hack for hires screen in doublescan display)
conditionally compiled out till the hardware resolution
for the problem occurs.
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.9 88/05/01 23:18:52 dale Exp $
d174 1
a415 1
		struct ColorMap *cm;
d421 1
a421 1
    		if ( (cm = vp->ColorMap) == 0)
d550 5
@


36.9
log
@Additions for new amiga genlock modes.
Changes to superhires conversion routines to deal with genlock.
It should work in all modes.
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.8 88/04/25 13:44:56 bart Exp $
d965 2
d974 13
@


36.8
log
@write to diwhigh in dual playfield mode
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.7 88/04/25 13:40:38 bart Exp $
d102 2
d131 14
d268 2
a269 2
	ytop = view->DyOffset + vp->DyOffset;
	ybottom = ytop + vp->DHeight - 1;
d416 1
d418 1
d420 1
d425 2
d431 1
a431 3
/* removed 2/17/88
			if (vp->ExtendedModes & VP_SUPER_HIRES)	*colortable = 0;
*/
d433 1
d447 3
a449 1
			convert_to_superhires(colortable,new_colors);
a454 1
		i = 0;
d473 3
a475 1
				CMOVE(c,io->color[i],*colors++);
d484 3
a486 1
			CMOVE(c,io->color[i],*colors++);
d498 3
a500 1
		    			CMOVE(c,io->color[i],*colortable++);
@


36.7
log
@ok, so i was wrong, buggyhardware is still there
also redefined MINYCLIP, MAXYCLIP to adjust to viewport y offsets rel to view.
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.6 88/05/24 17:52:37 bart Exp $
d672 2
a673 4
		if ( (GB->Debug & 0x80) || (ve->total_colorclocks != 226))
		{
			CMOVE(c,io->diwhigh,t);  CBUMP(&cl);
		}
@


36.6
log
@undefine buggyhardware
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.5 88/05/24 17:08:22 bart Exp $
d7 1
a7 1
/*#define BUGGY_HARDWARE*/
d45 1
a45 1
#define MINYCLIP(y) (vpe?(MAX((y),MAX(0,(vpe->DisplayClip.MinY)))):(y))
d47 1
a47 1
#define MAXYCLIP(y) (vpe?(MIN((y),MIN(0,(vpe->DisplayClip.MaxY)))):(y))
@


36.5
log
@display clipping -- allow neg vp->dyoffsets
only yclip if less than scaled hard minimum
always set diwhigh if new denise
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.4 88/04/12 10:27:37 dale Exp $
d7 1
a7 1
#define BUGGY_HARDWARE
@


36.4
log
@Fixed broken graaphics, it no longer worked with old chips.
Now it does.
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.3 88/03/14 14:24:55 dale Exp $
d30 1
d143 3
a263 1
	if (ve) y = VFIX(y);
d265 9
d481 4
d486 1
d496 1
a496 1
    		x = 0x1500 | (0xff&info[0].dwxstrt);
d561 1
d564 1
d569 2
a570 4
		if ( (GB->Debug & 0x80) || (ve->total_colorclocks != 226))
		{
			CMOVE(c,io->diwhigh,t);  CBUMP(&cl);
		}
d655 3
d659 2
d756 4
d761 1
d775 3
a777 1
	short vpy_neg = MIN(vp->DyOffset,0);
d875 1
d880 1
@


36.3
log
@hedley/new chip changes
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.2 88/03/10 20:42:10 dale Exp $
d477 1
d479 4
a482 8
	{
    		CMOVE(c,io->diwstrt,0x1500&info[0].dwxstrt);    CBUMP(&cl);
	}
	else
    	{
		/* use working registers now, I have to */
		CMOVE(c,io->diwstrt,(ytop<<8)|0xff&info[0].dwxstrt);
	}
d495 5
a499 9
	{
    		CMOVE(c,io->bplcon0,mybplcon0);
		CBUMP(&cl);
	}
	else
	{
    		CMOVE(c,io->bplcon0,(view->Modes&INTERLACE)|GB->system_bplcon0);
		CBUMP(&cl);
	}
@


36.2
log
@hires chip changes.
@
text
@d3 1
a3 1
*	$Header: makevp.c,v 36.1 88/03/10 16:11:54 dale Exp $
d309 1
@


36.1
log
@V36 initial check in
@
text
@d3 1
a3 1
*	$Header: $
d7 1
d140 2
d224 1
a224 1
	printf("makevp(%lx,%lx) rasinfo=%lx\n",view,vp,r1);
d248 5
d260 1
d471 1
a471 1
    printf("diwxstrt = %lx ",info[0].dwxstrt);
d475 11
a485 4
	x = VFIX(0x2b)<<8;
	/*x = VFIX(21)<<8;*/	/* I believe 0x15 is proper value for ntsc*/
    CMOVE(c,io->diwstrt,x|0xff&info[0].dwxstrt);    CBUMP(&cl);
    CMOVE(c,io->bplcon0,(view->Modes&INTERLACE)|GB->system_bplcon0); CBUMP(&cl);
d496 10
d525 1
a525 1
	int my_dwstop;
a526 1
	x = VFIX(0x7f);
d529 1
a529 5
    	CMOVE(c,io->diwstop,(x<<8) | ( 0xff & my_dwstop));
			 CBUMP(&cl);
    
	/* for now hack for new chips */
	if (ve)
d531 6
d538 18
a555 2
		t = 0x100;	/* hack */
		t |= (my_dwstop & 0xff00) <<5;
a558 2
			/* until we get a new agnus */
			/*CMOVE(c,io->deniseid,t);  CBUMP(&cl);*/
d584 1
a584 1
	printf("plnskip=%lx ",info[0].plnskip);
d715 12
a726 12
    {
	short ystop,maxystop;

	/* bart - display clipping */
	/* ystop = vp->DHeight; */
	ystop = MAX(vp->DHeight+MIN(vp->DyOffset,0),0);

	CWAIT(c,0,0);  CBUMP(&cl);	/* relative to top of vp */
	CMOVE(c,io->bplcon0,mybplcon0);     CBUMP(&cl);
	CWAIT(c,ystop,0);   CBUMP(&cl);
	CMOVE(c,io->bplcon0,(view->Modes&INTERLACE)|GB->system_bplcon0);
	CBUMP(&cl);
a730 1
    }
d926 2
a927 2
	    printf("dafstrt=%lx dafstop = %lx\n",ip->dafstrt,ip->dafstop);
	    printf("dwxstrt = %lx dw=%lx\n",ip->dwxstrt,ip->dw);
d930 1
@
