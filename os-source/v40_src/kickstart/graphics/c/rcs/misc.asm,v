head     39.38;
branch   ;
access   ;
symbols  rel39_24:39.38 rel39_18:39.37 rel39_97:39.33 rel39_90:39.32 rel39_89:39.32 rel39_82:39.32 rel39_76:39.27 rel39_71:39.26 rel39_65:39.20 rel39_64:39.20 rel39_61:39.19 rel39_60:39.18 rel39_55:39.15 rel39_52:39.15 rel39_47:39.14 rel39_39:39.11 rel39_38:39.11 rel39_37:39.9 rel39_35:39.9 rel39_34:39.9 V37_30:37.5 V37_29:37.5 V37_28:37.5 V37_27:37.3 V37_25:37.3 V37_24:37.3 V37_23:37.3 V37_22:37.3 V37_21:37.3 V37_20:37.3 V37_19:37.3 V37_17:37.3 V37_15:37.3 V37_14:37.3 V37_13:37.2 V37_12:37.2 V37_11:37.1 V37_10:37.1 V37_9:37.1 V37_8:37.1 V37_7:37.1 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.19 V36_208:36.19 V36_207:36.19 V36_205:36.19 V36_203:36.19 V36_202:36.19 V36_201:36.19 V36_200:36.19 V36_199:36.19 V36_198:36.19 V36_196:36.19 V36_195:36.19 V36_194:36.19 V36_193:36.19 V36_192:36.19 V36_191:36.19 V36_190:36.19 V36_189:36.19 V36_188:36.19 V36_186:36.19 V36_185:36.19 V36_184:36.19 V36_182:36.19 V36_181:36.19;
locks    ; strict;
comment  @@;


39.38
date     93.05.06.12.11.31;  author spence;  state Exp;
branches ;
next     39.37;

39.37
date     93.03.31.16.43.50;  author spence;  state Exp;
branches ;
next     39.36;

39.36
date     93.03.19.12.27.17;  author chrisg;  state Exp;
branches ;
next     39.35;

39.35
date     93.03.19.10.55.14;  author spence;  state Exp;
branches ;
next     39.34;

39.34
date     93.02.15.17.38.10;  author spence;  state Exp;
branches ;
next     39.33;

39.33
date     92.11.09.14.23.07;  author chrisg;  state Exp;
branches ;
next     39.32;

39.32
date     92.08.18.01.46.02;  author spence;  state Exp;
branches ;
next     39.31;

39.31
date     92.08.18.01.12.28;  author spence;  state Exp;
branches ;
next     39.30;

39.30
date     92.08.17.17.07.45;  author spence;  state Exp;
branches ;
next     39.29;

39.29
date     92.08.11.14.12.55;  author chrisg;  state Exp;
branches ;
next     39.28;

39.28
date     92.08.10.10.31.30;  author chrisg;  state Exp;
branches ;
next     39.27;

39.27
date     92.07.21.14.46.56;  author spence;  state Exp;
branches ;
next     39.26;

39.26
date     92.06.23.14.12.57;  author spence;  state Exp;
branches ;
next     39.25;

39.25
date     92.06.19.12.15.51;  author spence;  state Exp;
branches ;
next     39.24;

39.24
date     92.06.18.15.41.30;  author spence;  state Exp;
branches ;
next     39.23;

39.23
date     92.06.16.16.43.35;  author spence;  state Exp;
branches ;
next     39.22;

39.22
date     92.06.16.13.21.52;  author chrisg;  state Exp;
branches ;
next     39.21;

39.21
date     92.06.11.12.11.45;  author spence;  state Exp;
branches ;
next     39.20;

39.20
date     92.06.04.16.13.26;  author chrisg;  state Exp;
branches ;
next     39.19;

39.19
date     92.06.03.16.36.02;  author chrisg;  state Exp;
branches ;
next     39.18;

39.18
date     92.05.21.07.53.14;  author chrisg;  state Exp;
branches ;
next     39.17;

39.17
date     92.05.19.13.18.55;  author chrisg;  state Exp;
branches ;
next     39.16;

39.16
date     92.05.05.12.16.28;  author chrisg;  state Exp;
branches ;
next     39.15;

39.15
date     92.04.08.16.18.34;  author chrisg;  state Exp;
branches ;
next     39.14;

39.14
date     92.03.27.11.28.04;  author chrisg;  state Exp;
branches ;
next     39.13;

39.13
date     92.03.25.07.54.16;  author chrisg;  state Exp;
branches ;
next     39.12;

39.12
date     92.03.24.15.30.41;  author chrisg;  state Exp;
branches ;
next     39.11;

39.11
date     92.03.03.10.27.44;  author spence;  state Exp;
branches ;
next     39.10;

39.10
date     92.02.28.14.05.13;  author chrisg;  state Exp;
branches ;
next     39.9;

39.9
date     91.12.20.15.48.52;  author chrisg;  state Exp;
branches ;
next     39.8;

39.8
date     91.11.18.11.45.20;  author chrisg;  state Exp;
branches ;
next     39.7;

39.7
date     91.11.08.11.35.57;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     91.11.08.11.17.29;  author chrisg;  state Exp;
branches ;
next     39.5;

39.5
date     91.11.04.15.42.44;  author chrisg;  state Exp;
branches ;
next     39.4;

39.4
date     91.10.28.19.38.31;  author spence;  state Exp;
branches ;
next     39.3;

39.3
date     91.10.15.15.57.49;  author chrisg;  state Exp;
branches ;
next     39.2;

39.2
date     91.10.10.09.49.03;  author chrisg;  state Exp;
branches ;
next     39.1;

39.1
date     91.08.27.16.48.30;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.20.24;  author chrisg;  state Exp;
branches ;
next     37.6;

37.6
date     91.05.02.12.55.36;  author chrisg;  state Exp;
branches ;
next     37.5;

37.5
date     91.04.19.16.34.48;  author spence;  state Exp;
branches ;
next     37.4;

37.4
date     91.04.19.16.34.03;  author chrisg;  state Exp;
branches ;
next     37.3;

37.3
date     91.02.11.18.15.18;  author spence;  state Exp;
branches ;
next     37.2;

37.2
date     91.02.07.16.24.57;  author spence;  state Exp;
branches ;
next     37.1;

37.1
date     91.01.30.13.08.59;  author spence;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.27.51;  author spence;  state Exp;
branches ;
next     36.19;

36.19
date     90.09.06.16.40.19;  author bart;  state Exp;
branches ;
next     36.18;

36.18
date     90.08.29.18.37.59;  author bart;  state Exp;
branches ;
next     36.17;

36.17
date     90.07.27.16.58.51;  author bart;  state Exp;
branches ;
next     36.16;

36.16
date     90.03.28.09.09.09;  author bart;  state Exp;
branches ;
next     36.15;

36.15
date     90.03.27.15.52.55;  author bart;  state Exp;
branches ;
next     36.14;

36.14
date     90.03.23.14.36.33;  author bart;  state Exp;
branches ;
next     36.13;

36.13
date     90.03.22.16.53.01;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     90.03.08.14.21.07;  author bart;  state Exp;
branches ;
next     36.11;

36.11
date     90.02.28.09.56.42;  author bart;  state Exp;
branches ;
next     36.10;

36.10
date     90.02.28.09.38.51;  author bart;  state Exp;
branches ;
next     36.9;

36.9
date     89.11.09.17.14.17;  author bart;  state Exp;
branches ;
next     36.8;

36.8
date     89.10.31.13.01.27;  author bart;  state Exp;
branches ;
next     36.7;

36.7
date     89.05.08.15.34.26;  author bart;  state Exp;
branches ;
next     36.6;

36.6
date     89.02.14.10.13.06;  author bart;  state Exp;
branches ;
next     36.5;

36.5
date     89.02.01.17.52.44;  author bart;  state Exp;
branches ;
next     36.4;

36.4
date     89.02.01.17.39.29;  author bart;  state Exp;
branches ;
next     36.3;

36.3
date     89.02.01.12.04.29;  author bart;  state Exp;
branches ;
next     36.2;

36.2
date     88.08.18.21.18.48;  author dale;  state Exp;
branches ;
next     36.1;

36.1
date     88.03.10.16.12.38;  author dale;  state Exp;
branches ;
next     ;


desc
@@


39.38
log
@_IsAUCopIns().
Removed unused Enable()/Disable() stubs
@
text
@*******************************************************************************
*
*	$Id: misc.asm,v 39.37 93/03/31 16:43:50 spence Exp Locker: spence $
*
*******************************************************************************

    include	'exec/types.i'
    include	'exec/nodes.i'
    include	'exec/lists.i'
    include	'exec/interrupts.i'
    include	'exec/libraries.i'
    include 	'exec/ables.i'
    include	'utility/tagitem.i'
    include	'/gfxbase.i'
    include	'/vp_internal.i'
    include	'/gfx.i'
    include	'/view.i'

    include	'hardware/blit.i'
    include	'hardware/intbits.i'
    include	'hardware/dmabits.i'
    include	'/cia8520.i'
    include	'hardware/custom.i'
    include	'/sane_names.i'
    include	'hardware/custom.i'
    include	'/macros.i'
    include	'/a/submacs.i'
    include	'/rastport.i'
    include	'/clip.i'
    include	'/display.i'

	xref	_LVOGfxSpare1,_LVOReplyMsg,_LVODisownBlitter
	xref	_LVODoHookClipRects
	xref	_LVOGetBitMapAttr

	section	graphics
DEFSTOP equ     0
SYSTRAP equ     $1e
SUPERVISOR equ  -60
IC_COLDRESET    equ 1

*MOLLYFIX	equ	1
ANUTHABADAGNUS	equ	1
DEBUGCOLOR  equ 0
PRINTF	equ 0
*HEDLEY	equ 0

    xref    _custom
    xref    _ciab,_ciaa
    xref    _intena
    xref    _intreq
    xref    _intreqr
    xref    _dmacon
    xref    _dmaconr
    xref    _vposr
    xref    _vhposr

    xref    _cpwrup
    xref    _dflt_clrs
    xref    _DisownBlitter
    xref    _disownnodec
	xref	waitblitdone

    xref    _LVOAbleICR
    xref    _LVOSetICR
    xref    _Debug

    xdef    _get_denise_id
    xdef    _OpenGfx
    xdef    _CloseGfx
    xdef    _ExpungeGfx
    xdef    _ExtFuncGfx,_AlwaysReturnsZero
    xdef    _FindMSBSet
    xdef    _GetTagDataUser
    xdef    _IsAUCopIns

	xref	_LVOOpenLibrary,_LVOInstallLayerHook
	xref	_LVOSortLayerCR,_LVOInitResident,_LVOFindResident

_OpenGfx:
	tst.l	gb_LayersBase(a6)
	bne.s	_ExtFuncGfx
	move.l	a6,-(a7)
	move.l	gb_ExecBase(a6),a6
	lea	lname(pc),a1
	jsr	_LVOFindResident(a6)	; this will init layers, which will poke its base into gb_lbase
	move.l	d0,a1
	moveq	#0,d1
	jsr	_LVOInitResident(a6)
	move.l	(a7)+,a6
_ExtFuncGfx:
	move.l  a6,d0
	rts

_CloseGfx:
_ExpungeGfx:
_AlwaysReturnsZero:
	moveq	#0,d0		* this library is currently never removed
	rts

*	xdef	_FetchGBase
*_FetchGBase:
*	move.l	a6,d0
*	rts

    xdef    _vbasm
_vbasm:
	lea.l	_custom,a0
	movem.l	d2/d4,-(sp)
	addq.l	#1,gb_VBCounter(a1)
	move.l	gb_current_monitor(a1),d2
	beq.s	no_moni
	move.l	d2,a6
	move.w	ms_total_rows(a6),vtotal(a0)

* Check if beamcon0 should be changed from a LoadView(). Some applications
* (and bootmenu) write directly to beamcon0, so we don't want to overwrite them.

	move.w	ms_BeamCon0(a6),d4
	btst.b	#3,gb_system_bplcon0+1(a1)	; lpen set?
	beq.s	no_lpen
	btst.b	#GFXB_HR_AGNUS,gb_ChipRevBits0(a1)
	beq.s	no_beamcon0			; can't set beamcon0 on <ECS
	or.w	#$2000,d4			; set LPENDIS so we can read vposr
	bra.s	do_beamcon0
no_lpen:
	btst.b	#BMB_CHANGE,gb_Bugs(a1)
	beq.s	no_beamcon0
do_beamcon0:
	move.w	d4,beamcon0(a0)
	bclr.b	#BMB_CHANGE,gb_Bugs(a1)
no_beamcon0:
	btst.b	#MSB_REQUEST_SPECIAL,ms_Flags+1(a6)
	lea	gb_MonitorVBlank(a1),a6
	move.l	asi_Start(a6),d2	; vbstrt and vbstop
no_moni:
	move.l	gb_ExecBase(a1),a6	; For DISABLE/ENABLE macros
	btst	#2,gb_Modes+1(a1)	; lace?
	if <>
		moveq	#0,d1
* if LPEN, and not HR_AGNUS, don't check vposr.
		move.b	gb_system_bplcon0+1(a1),d1
		or.b	gb_ChipRevBits0(a1),d1
		and.b	#($8|GFXF_HR_AGNUS),d1
		cmp.b	#$8,d1
		beq.s	just_doit
		move.w	gb_TopLine(a1),d1
		DISABLE					; blit ints fucking this up.
		move.l	vposr(a0),d0 	; too far?
		and.l	#$007FF00,d0
		cmp.l	d1,d0
		if <
*			long or short frame?
just_doit:
			tst.b	vposr(a0) 
			if >= 
				move.l	d2,vbstrt(a0)	; write VBSTRT, VBSTOP
				move.l gb_SHFlist(a1),cop2ptr(a0)
			else
				IFD	VBLANK_BUG
				btst.b	#BMB_BUG_VBLANK,gb_Bugs(a1)
				beq.s	1$
				add.l	#$10000,d2
1$:				ENDC
				move.l	d2,vbstrt(a0)	; write VBSTRT, VBSTOP
				move.l  gb_LOFlist(a1),cop2ptr(a0)
			endif
		endif
		ENABLE
	else
		IFD	VBLANK_BUG
		btst.b	#BMB_BUG_VBLANK,gb_Bugs(a1)
		beq.s	1$
		add.l	#$10000,d2
1$:		ENDC

* If the display mode just changed from Lace to non-laced, then the 
* mode may be stuck in the ShortFrame mode. So make sure it's Long.
* However, don't do this if the system_beamcon0 LACE bit is set.

		DISABLE
		btst.b	#2,gb_system_bplcon0+1(a1)
		bne.s	not_special	; we really want it LACEd
		move.w	vposr(a0),d0
		bmi.s	not_special	; already LOF
		move.w	vposr(a0),d0	; reduce errors by reading again
		or.w	#VPOSRLOF,d0
		move.w	d0,vposw(a0)
not_special:
		move.l	d2,vbstrt(a0)	; write VBSTRT, VBSTOP
		move.l  gb_LOFlist(a1),cop2ptr(a0)
		ENABLE
	endif

* If the lpen bit was set, rewrite beamcon0. We can't do the better test
* of bclr.l #13,d4, as d4 may be garbage. This happens during boot up, where
* there is no current_monitor.
	btst.b	#3,gb_system_bplcon0+1(a1)	; lpen set?
	beq.s	no_lpen_here
	btst.b	#GFXB_HR_AGNUS,gb_ChipRevBits0(a1)
	beq.s	no_lpen_here
	bclr.l	#13,d4
	move.w	d4,beamcon0(a0)
no_lpen_here:
	movem.l	(sp)+,d2/d4

	lea	_ciab,a6
	and.b	#$7f,ciacrb(a6)
	clr.l	d0
	move.b	d0,ciatodhi(a6)
	move.b	d0,ciatodmid(a6)
	move.b	vhposr(a0),ciatodlow(a6)	* start timer
	or.b	#$80,ciacrb(a6)			* back to alarm mode

***********************************************************************
* _bobvblank(gfxbase)
*              A1
*
* This function causes any pending beam synced blits to occur
* as soon as possible.  What happens is we add a beam synced
* blit, but sometime between the time it is added, and the time
* the blitnode is serviced, a VBLANK has occured.  Once true, we
* get caught up on all pending beam synced blits by marking that
* we should just ignore the request for beam syncing.
* 
* IF we don't get caught up, asyncronous beam synced blits can
* be added at a rate rapid enough that OwnBlitter() can hold
* off indefinitely.  Actually this is not a new problem, but we
* would make it worse.  Also its unlikely that someone asking for
* a beam synced blit means he wants it to happen many frames later.
* Infact historically the BOB code has done catch up code!
*
* NOTE -- VBLANK, and BLIT interrupts are equal CPU priority, so there is
* no race condition.  VBLANK can access the qblit list safely
* without causing any list processing problems in the BLIT interrupt.
*
***********************************************************************

	;-- check for empty qsbblit list; if so, bail

	move.l	gb_blthd(a1),d0
	beq.s	bobvb_emptylist

	;-- check if the current node is waiting for a timer
	;-- event.  Force one ASAP if so.  Also prevents
	;-- waiting forever if the monitor changed suddenly
	;-- such that the waiting position is invalid.

	move.l	d0,a0

	bclr	#GBFLAGSB_TIMER,gb_Flags+1(a1)	;atomic flag clear/test
	beq.s	bobvb_clearlist

	;-- Don't bother disabling.  If the timer goes off later
	;-- the flag bit above is clear, so the blitter interrupt
	;-- handler won't get a false ring.  Even if it did,
	;-- we are protected within the interrupt code.  Whenever
	;-- it does go off (and it really should have gone off
	;-- already), we will disable further ALRM interrupts.

	move.w  #BITSET+INTF_BLIT,_intena	;not needed, but doesn't hurt
	move.w  #BITSET+INTF_BLIT,_intreq

	;-- bitclear high bit of bn_beamsync value for any nodes
	;-- on qblit list; the BLIT interrupt will therefore not
	;-- bother sending off any timer waits for these nodes.

bobvb_clearlist:
	bclr	#7,bn_beamsync(a0)		;clear high bit of word
	move.l	(a0),d0				;bn_n(a0) (CC affected)
	move.l	d0,a0				;does not affect CC
	bne.s	bobvb_clearlist

bobvb_emptylist:

*	check for those Wait_TOF 
	clr.b	gb_VBlank(a1)
	move.l	gb_ExecBase(a1),a6		* get ExecBase
	move.l  d2,-(sp)
	lea	gb_DBList(a1),a0			; prev node
	move.l	(a0),d2
	beq.s	no_dbscan
	move.l	a1,-(a7)

scan_next:
	move.l	d2,a1
	sub.l	#1,dbi_Count1(a1)		; decrement frame counter
	bne.s	no_wakeup
	
	move.l	a0,-(a7)
	add.l	#dbi_SafeMessage,a1
	jsr	_LVOReplyMsg(a6)
	move.l	(a7)+,a0
	move.l	d2,a1
	move.l	(a1),d2				; prev->next=cur->next
	move.l	d2,(a0)
	bne.s	scan_next
	bra.s	done_dbscan
no_wakeup:
	move.l	d2,a0
	move.l	(a0),d2
	bne.s	scan_next
	
done_dbscan:
	move.l	(a7)+,a1

no_dbscan:
	move.l	gb_TOF_WaitQ(a1),a1
	move.l	(a1),d2					* get Succ
	if <>
		repeat
			moveq	#$0,d0			* now stores bit # in LN_PRI!
			move.b	LN_PRI(a1),d0
			bset	d0,d0
			move.l	LN_NAME(a1),a1
			JSRFAR	Signal
			move.l	d2,a1			* recall next ptr
			move.l	(a1),d2
		until =
	endif
; now, let's scan our db list, decrementing frame counters and deleting and singalling expired nodes.

	move.l	(sp)+,d2
	clr.l	d0
*	returns with ccr set to zero
	rts

	xdef	_BLTBYTES,bltbytes

; int __asm BLTBYTES(register __d0 UWORD xmin,register __d1 UWORD xmax);
_BLTBYTES:
bltbytes:
	add.w	#16,d1
	and.w	#$FFF0,d1
	and.w	#$FFF0,d0
	sub.w	d0,d1
	asr.w	#3,d1		* convert to bytes per row
	ext.l	d1
	move.l	d1,d0		* return in d0
	rts

    xdef    _timasm
    xref    _AbleICR
***********************************************************************
* _timasm(gfxbase)
*           A1
*
* Cause a blitter interrupt when beamsync timer expires; of note,
* this is a level 6 interrupt, so it is important to return ASAP
* to minimize impact on lower priority interrupts (in particular,
* serial interrupts).
*
* A6 - scratchable
***********************************************************************

_timasm:

	;-- disable CIAB ALARM interrupts

	move.l	gb_cia(a1),a6
	move.l	a1,-(sp)
	moveq	#CIAICRF_ALRM,d0
	jsr	_LVOAbleICR(a6)
	move.l	(sp)+,a1

	;-- if the timer bit is not set in in gb_Flags, then this
	;-- is a false alarm, or one that has already been handled
	;-- by the vertical blank server.

	bclr	#GBFLAGSB_TIMER,gb_Flags+1(a1)	;atomic flag clear/test
	beq.s	falsealarm

	;-- make a blitter interrupt

	move.w  #BITSET+INTF_BLIT,_intena	;not needed, but doesn't hurt
	move.w  #BITSET+INTF_BLIT,_intreq

falsealarm:
	rts


***********************************************************************
* _bltasm(gfxbase,_custom)
*           A1      A0
*
* Service next blit node on queue.  Special case handling for
* beamsync'ed nodes -- may start beam synced timer, and exit.
*
* D0/D1/A0/A1/A5/A6 - scratchable
*
* NOTE - VBLANK, and BLITTER interrupts run at the same priority, so
* there is no race condition regarding VBLANK clearing the high bit
* of bn_beamsync.
***********************************************************************


	;-- The LASTBLIT flag means the node is done, and has started
	;-- a blit.  Once this is done we can call their cleanup routine
	;-- and remove this node from the qblit list.  Waiting for the
	;-- interrupt is much beter than busy waiting in the interrupt

bltasm_lastblit:

	;-- If more to do, then just exit; will call back node again
	;-- next blitter interrupt.  If not more to do, wait for
	;-- next interrupt indicating last blit is done.

	bne.s	bltasm_busy

	bset	#GBFLAGSB_LASTBLIT,gb_Flags+1(a6)

	;-- This code is intended to fix anyone who does not start
	;-- a blit!! ... make sure we actually get a blitter interrupt!
	;-- If they started a really short blit which is already done,
	;-- thats ok too.  The important thing is we need to get back
	;-- to our blitter interrupt handler.

bltasm_busy:
	tst.b	_dmaconr			;bad agnus??

	btst	#DMAB_BLTDONE-8,_dmaconr
	bne.s	bltasm_continue

	move.w	#BITSET!INTF_BLIT,_intreq

bltasm_continue:
	rts

_bltasm::
	;-- DO NOT MODIFY A0 without making sure that it points to _custom
	;-- when calling the bltnode function!

	move.w	#INTF_BLIT,intreq(a0)	;clear blitter interrupt

	;-- screen interrupts when QBlit is not active

	move.l	gb_blthd(a1),d0
	beq.s	bltasm_continue

	btst	#QBOWNERn,gb_Flags+1(a1)
	beq.s	bltasm_continue

	move.l	a1,a6
	move.l	d0,a1

	;-- Make sure blitter is truly done.  If not, allow
	;-- any pending VBLANK to be serviced.  If no pending
	;-- VBLANK, wait for this blit to finish.  In actual
	;-- use this case is rarely going to be true.  An
	;-- example of when it might be true is someone calling
	;-- DisownBlitter after having done more than one blit.
	;-- DisownBlitter might not have set INTB_BLIT in intreq,
	;-- but would have set the flag in intena.

	tst.b	dmaconr(a0)			;bad agnus??

bltasm_waitblit:

	btst	#DMAB_BLTDONE-8,dmaconr(a0)
	beq.s	bltasm_nextblit

	;-- fake access to ciaa PRA gets CPU off the bus for a short while

	tst.b	_ciaa
	tst.b	_ciaa

	;-- check for VBLANK pending; blitter is in busy state

	move.w	intreqr(a0),d0
	and.w	#INTF_VERTB,d0
	beq.s	bltasm_waitblit
	bra.s	bltasm_busy

bltasm_nextblit:

	tst.b	dmaconr(a0)			;bad agnus??

	;-- Check if this node had previously indicated it is done.
	;-- If so, do cleanup routine (?) and remove it

	bclr	#GBFLAGSB_LASTBLIT,gb_Flags+1(a6)
	bne.s	bltasm_cleanup

	;-- determine if current node is waiting for a preferred beam pos

	move.w	bn_beamsync(a1),d0
	bpl.s	bltasm_immediate

	;-- if so, clear marker (first time through - will not be true
	;-- again for subsequent calls)

	bclr	#15,d0
	move.w	d0,bn_beamsync(a1)

	;-- check if we need to start timer, or blit immediately

	move.l	vposr(a0),d1
	lsr.l	#08,d1
	and.w	#$07FF,d1

	;-- if beam position is > waiting position, start beam timer
	;-- else just start blit now

	cmp.w	d0,d1
	bcs.s	start_timer		;beam < desired position?

	;-- call back current blitnode (_custom is already in A0)

bltasm_immediate:
	move.l	bn_function(a1),a5
	jsr	(a5)

	bra	bltasm_lastblit

	;-- **********************************************************

bltasm_cleanup:		

	;-- This node is done; cleanup routine specified??

	btst	#CLEANMEn,bn_stat(a1)
	beq.s	bltasm_nocleanup

	move.l	bn_cleanup(a1),a5
	jsr	(a5)

	move.l	gb_blthd(a6),a1		;refresh bltnode pointer

bltasm_nocleanup:

	;-- Remove blitnode, and DisownBlitter if this is the last
	;-- qblit node.  We are responsible for clearing the QBOWNER
	;-- flag, and disabling blitter interrupt.s

	
	move.l	(a1),gb_blthd(a6)	;Remove()

	bne.s	bltasm_qbactive

	and.w	#(~(QBOWNER)),gb_Flags(a6)
	move.w	#INTF_BLIT,_intena

	jmp	_LVODisownBlitter(a6)	;rts

bltasm_qbactive:
		
	;-- Give any waiters a break, but if no waiters, just cause another
	;-- blit interrupt.  If waiters, then DisownBlitter such that
	;-- the waiter is Signaled.  Once the waiter (if any) calls
	;-- DisownBlitter(), the QBLIT code is given ownership again.
	;
	;-- Because we are running from an interrupt, neither DISABLE or
	;-- FORBID is needed.

	tst.w	gb_BlitLock(a6)
	beq.s	bltasm_nextqblit	;if 0, QBLIT is only owner

	clr.l	gb_blthd(a6)

	and.w	#(~(QBOWNER)),gb_Flags(a6)
	move.w	#INTF_BLIT,_intena

	jsr	_LVODisownBlitter(a6)	;preserves all registers

	;-- restore gb_blthd() for next call to DisownBlitter

	move.l	(a1),gb_blthd(a6)
	addq.w	#1,gb_BlitLock(a6)	;restore my owner count
	rts

	;-- Cause a blitter interrupt.  
	;-- We could loop back, but we want to give any pending VBLANK
	;-- a chance to run.  This code is also smaller (though
	;-- slower than) loop back code.

bltasm_nextqblit:

	move.w	#BITSET!INTF_BLIT,_intreq
	rts
		

***********************************************************************
* start_timer(gfxbase,bltnode,beampos)
*                A6      A1     D0
*
* Start beam sync timer, and bail out; interrupt will wake us up
*
* NOTE - this function is only called from the blitter interrupt
* code now, so there is no race condition with VBLANK resetting the
* counters.  Blitter interrupts and VBLANK run at the same priority.
***********************************************************************
start_timer:

	;-- if genloc, then this counter is halfassed

	btst	#1,gb_system_bplcon0+1(a6)	;isn't there an EQUATE?
	beq.s	start_tnogenlock

	lsr.w	#1,d0				;divide by 2

start_tnogenlock:
	lea	_ciab,a0
	move.l	a6,a1

	movem.l	d0/a0/a1,-(sp)

	moveq	#-1,d0

	;-- We want to clear any pending CIA interrupt; presumably
	;-- the last CIA-B ALRM interrupt has triggered, and is
	;-- therefore also disabled.  But if not, thats ok too.
	;
	;-- The important thing to note is that even if the CIA
	;-- interrupt is disabled, it can still be pending.  So
	;-- what we need to do is clear pending in a state where
	;-- we do not get a false ring due to some previous value
	;-- in the ALRM.  To do this, we set the ALRM value to
	;-- something ridiculous.  We will also set the full
	;-- 24 bit ALRM value here, even though that it should
	;-- not be needed either (but it doesn't hurt to play it safe)

	move.b	#00,ciatodhi(a0)		;not really needed
	move.b	d0,ciatodmid(a0)
	move.b	d0,ciatodlow(a0)
		
	;-- clear pending CIA interrupt (if any?) 

	move.l	gb_cia(a6),a6
	moveq	#CIAICRF_ALRM,d0
	jsr	_LVOSetICR(a6)

	;-- mark that this node is waiting for a beam sync alarm

	movem.l	(sp)+,d0/a0/a1

	bset	#GBFLAGSB_TIMER,gb_Flags+1(a1)

	;-- ******************************************************
	;-- * What happens if the beam is already at, or passed us
	;-- * by the time we do the new counter load??  I know I'll
	;-- * take care of the problem by next VBLANK, but ideally
	;-- * would we check for this case in DISABLE, and try to
	;-- * compensate (e.g., beam postion +1, or +2??)
	;-- ******************************************************

	;-- load new beam counter value

	ror.w	#8,d0
	move.b	d0,ciatodmid(a0)		;hold
	rol.w	#8,d0
	move.b	d0,ciatodlow(a0)		;and latch value

	;-- enable CIAB TOD interrupts
		
	move.l	#(CIAICRF_SETCLR!CIAICRF_ALRM),d0
	jsr	_LVOAbleICR(a6)
	rts

    xdef    _IDivS_ceiling
*   if there is a residue bump up the quotient
*   this probably only works for positive quotients
; int __asm IDivS_ceiling(register __d0 int a,register __d1 int b);
_IDivS_ceiling:
    divs    d1,d0
    move.l  d0,d1
    ext.l   d0
    swap    d1
    if  d1.w
	addq    #1,d0
    endif
    rts

    xdef    _IDivS_round
*   rounded signed division
; int __asm IDivS_round(register __d0 int a, register __d1 int b);
_IDivS_round:
    add.l   d0,d0       * pre multiply by 2
    divs    d1,d0   * now divide it
    if  >
	add.w   #1,d0
    endif
    ext.l   d0
    asr.l   #1,d0           * now drop the round bit if unneeded
    rts



	xdef	_rotate
; UWORD __asm rotate(register __d0 UWORD data, register __d1 UWORD count);
*	rotates a UWORD right by n
*	rotate(data,n)
_rotate
	ror.w	d1,d0
	rts


	include	'exec/ables.i'
	xref	_intena

	INCLUDE "utility/hooks.i"
	xdef	_hookEntry

_hookEntry:
 	movem.l	a5/a6,-(sp)		; save library base
 	move.l	h_Data(a0),a6		; restore context
	move.l	h_SubEntry(a0),a5 ; fetch C entry point ...
	jsr	(a5)			; ... and call it
 	movem.l	(sp)+,a5/a6		; restore library base
	rts				; and get the hell outa here...!


my_name
*	dc.b    'The Amiga Wizards bring this power to you',10,0

    data
	xdef	gfx_end
gfx_end:    dc.b    0       * this will go somewhere at the end
	cnop	0,2

	section	graphics2
**************************************************************************

* this code added Oct 23 1991 for 2.05 A300 build - better detection of
* non-ECS denise (esp. on A1000).

_intenar	equ	$dff01c
_intenaw	equ	$dff09a
_deniseid equ	$dff07c

_get_denise_id:
	move.w	d2,-(sp)
	move.l	$4,a1
	DISABLE	a1,NOFETCH

	move.w	_intenar,-(sp)
	move.w	#$0009,_intenaw
	move.w	_deniseid,a0
	move.w	#16,d1
	moveq	#0,d0
1$:	tst.w	_intenar
	move.w	_deniseid,d0
	tst.w	d5
	tst.w	d5
	tst.w	d5
	tst.w	d5
	tst.w	d5
	tst.w	d5
	tst.w	d5
	tst.w	d5
	tst.w	d5
	tst.w	d5
	move.w	d0,d2
	and.w	#$000f,d2
	cmp.w	#$0009,d2
	beq.s	no_id
	cmp.w	a0,d0
	bne.s	no_id
	dbra	d1,1$
	and.w	#$ff,d0
bye:	move.w	(sp)+,d1
	bset	#15,d1
	move.w	d1,_intenaw
	not.w	d1
	move.w	d1,_intenaw
	ENABLE	a1,NOFETCH
	move.w	(sp)+,d2
	rts

no_id:	moveq	#-1,d0
	bra.s	bye

; int __asm rectXrect(register __a0 struct Rectangle *l,register __a1 struct Rectangle *cr);
	xdef	_rectXrect,_crectXrect
_crectXrect:
	movem.l	4(a7),a0/a1
_rectXrect:
;    if ( (cr->MaxX < l->MinX) ||
;	 (cr->MinX > l->MaxX) ||
;	 (cr->MaxY < l->MinY) ||
;	 (cr->MinY > l->MaxY) ) return(FALSE);
;   else return(TRUE);
	moveq	#0,d0
	move.w	(a0)+,d1	; d1=minx
	cmp.w	ra_MaxX(a1),d1
	bgt.s	no_int
	move.w	(a0)+,d1	; d1=miny
	cmp.w	ra_MaxY(a1),d1
	bgt.s	no_int
	move.w	(a0)+,d1	; d1=maxx
	cmp.w	ra_MinX(a1),d1
	blt.s	no_int
	move.w	(a0)+,d1	; d1=maxy
	cmp.w	ra_MinY(a1),d1
	blt.s	no_int
	moveq	#-1,d0
no_int:	rts



*
*  result = DelayAndRead(address,number)
*
*	UWORD = DelayAndRead(UWORD *,ULONG)
*					(only 16 bits are used in the number)
*
*	This function reads the address given the number of times given
*	and returns the value of the last read.  This is usefull for doing
*	delays with respect to the custom chips.
*
*	The value returned is the next read.  So if you pass in a 1, it will
*	read it once and then read it again and return that value...
*
		XDEF	_DelayAndRead
_DelayAndRead:	move.l	4(sp),a0	; Get address...
		move.l	8(sp),d1	; Get count...
		moveq.l	#0,d0		; Clear d0...
DAR_Loop:	move.w	(a0),d0		; Read...
		dbra	d1,DAR_Loop	; Do it for count...
		rts			; We be done.


; void __asm GetRPBounds(register __a1 struct RastPort *rp,register __a0 struct Rectangle *rect);
_GetRPBounds::
	movem.l	a4/a5/d2-d7,-(sp)
	move.l	rp_Layer(a1),d0
	bne.s	yeslayer
yes_bm:	move.l	a0,a5			; save rectangle ptr
	clr.l	(a0)			; minx=miny=0
	move.l	rp_BitMap(a1),a0
	move.l	a0,a4
	moveq	#BMA_WIDTH,d1
	jsr	_LVOGetBitMapAttr(a6)
	subq.l	#1,d0
	move.w	d0,ra_MaxX(a5)
	move.l	a4,a0
	moveq	#BMA_HEIGHT,d1
	jsr	_LVOGetBitMapAttr(a6)
	subq	#1,d0
	move.w	d0,ra_MaxY(a5)
	movem.l	(sp)+,a4/a5/d2-d7
	rts
yeslayer:
	move.l	d0,a5			; layer
	tst.l	lr_SuperBitMap(a5)
	beq.s	not_super
	move.l	d0,a1
	add.l	#lr_SuperBitMap-rp_BitMap,a1
	bra.s	yes_bm

not_super:
	LOCKLAYER
	move.w	#32767,d0		; d0=minx
	move.w	d0,d1			; d1=miny
	move.w	#-32767,d2		; d2=maxx
	move.w	d2,d3			; d3=maxy
	move.l	lr_ClipRect(a5),a4
cr_lp:	cmp.w	#0,a4
	beq.s	no_more_crs
	tst.l	cr_lobs(a4)		; lobs?
	beq.s	got_cr
	tst.l	cr_BitMap(a4)		; if lobs & (bm=0), obscured.
	beq.s	next_cr
got_cr:
	movem.w	cr_MinX(a4),d4/d5/d6/d7	; fetch minx/miny/maxx/maxy
	sub.w	lr_MinX(a5),d4
	sub.w	lr_MinX(a5),d6
	add.w	lr_Scroll_X(a5),d4
	add.w	lr_Scroll_X(a5),d6

	sub.w	lr_MinY(a5),d5
	sub.w	lr_MinY(a5),d7
	add.w	lr_Scroll_Y(a5),d5
	add.w	lr_Scroll_Y(a5),d7

	cmp.w	d4,d0			; if minx>cr_minx, minx=cr_minx
	ble.s	no_updminx
	move.w	d4,d0
no_updminx:
	cmp.w	d6,d2			; maxx < cr_maxx?
	bge.s	no_updmaxx
	move.w	d6,d2
no_updmaxx:
	cmp.w	d5,d1
	ble.s	no_updminy
	move.w	d5,d1
no_updminy:
	cmp.w	d7,d3
	bge.s	no_updmaxy
	move.w	d7,d3
no_updmaxy:
next_cr:
	move.l	cr_Next(a4),a4
	bra.s	cr_lp
no_more_crs
	movem.w	d0-d3,(a0)
	UNLOCKLAYER
	movem.l	(sp)+,a4/a5/d2-d7
	rts

; UWORD * __asm CopyWords(register __a0 UWORD *source, register __a1 UWORD *dest, register __d0 int nwords);
_CopyWords::
	subq.l	#1,d0
1$:	move.w	(a0)+,(a1)+
	dbra	d0,1$
	move.l	a1,d0
	rts

; UBYTE __asm FindMSBSet(register __d1 UBYTE thisbyte);
_FindMSBSet:
	move.b	d1,d0
	beq.s	2$
	moveq	#7,d0
1$:
	asl.b	#1,d1
	dbcs	d0,1$
2$:
	rts

; ULONG __asm GetTagDataUser(register __d0 ULONG tagValue, register __d1 ULONG def, register __a0 struct TagItem *tagList);
	xref	_LVOGetTagData

_GetTagDataUser:
	or.l	#TAG_USER,d0
	move.l	a6,-(sp)
	move.l	gb_UtilBase(a6),a6
	jsr	_LVOGetTagData(a6)
	move.l	(sp)+,a6
	rts

; BOOL __asm IsAUCopIns(register __a0 struct ViewPort *vp, register __a1 struct CopList *cl);

_IsAUCopIns:
	moveq	#-1,d0		; result = TRUE
	move.l	vp_UCopIns(a0),a0	; we know this in non-NULL, as it is checked
					; before calling in mrgcop().
1$:
	cmp.l	ucl_FirstCopList(a0),a1
	beq.s	IsAUCopIns.
	move.l	ucl_Next(a0),d0
	move.l	d0,a0
	bne.s	1$
	moveq	#0,d0		; FALSE

IsAUCopIns.:
	rts

lname	dc.b	'layers.library',0

    end     stupid metacomco assembler
@


39.37
log
@When non-laced, had a6 pointing to GfxBase instead of ExecBase with the
DISABLE/ENABLE macros. We were lucky in that the offset in GfxBase that
was changed is unused hedley info.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.36 93/03/19 12:27:17 chrisg Exp Locker: spence $
d75 1
a699 16
	xdef	_Disable
_Disable:
	move.l	a6,-(a7)
	move.l	gb_ExecBase(a6),a6						* don't know if gfxbase set.
	DISABLE
	move.l	(a7)+,a6
	rts

	xdef	_Enable
_Enable:
	move.l	a6,-(a7)
	move.l	gb_ExecBase(a6),a6						* don't know if gfxbase set.
	ENABLE
	move.l	(a7)+,a6
	rts

d928 17
@


39.36
log
@fix spences protos.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.35 93/03/19 10:55:14 spence Exp Locker: chrisg $
d136 1
a145 1
		move.l	gb_ExecBase(a1),a6
@


39.35
log
@The code that checked if non-laced screens were stuck in ShortFrame
always poked the LOF bit back in. However, this was breaking 'lacer',
and any other software that sets the lace bit in gb_system_bplcon0.
So, now I check for lace in system_bplcon0 before setting the LOF bit.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.34 93/02/15 17:38:10 spence Exp Locker: spence $
d934 1
a934 1
; ULONG __asm GetTagDataUser(register __d0 Tag tagValue, register __d1 ULONG def, register __a0 struct TagItem *tagList);
@


39.34
log
@GetTagDataUser() implemented.
When switching from LACE to Non-Lace, now check the LOF bit for ALL
monitors, but only change vposw if the LOF bit is not set.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.33 92/11/09 14:23:07 chrisg Exp Locker: spence $
d108 1
a108 1
	movem.l	d2-d4,-(sp)
a110 1
	move.l	d2,d3
a132 1
	sne	d3
d178 1
d181 2
a182 2
*		tst.b	d3
*		beq.s	not_special
d204 1
a204 1
	movem.l	(sp)+,d2-d4
@


39.33
log
@added VBCounter for intuition
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.32 92/08/18 01:46:02 spence Exp Locker: chrisg $
d13 1
d74 1
d182 2
a183 2
		tst.b	d3
		beq.s	not_special
d185 2
d933 11
@


39.32
log
@whooops. 'A' doesn't have beamcon0. In this case, just ignore the
vposr values.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.31 92/08/18 01:12:28 spence Exp Locker: spence $
d107 1
@


39.31
log
@better lpen handling. On ECS/AA machines, if the lpen bit is set, then
write beamcon0 with the LPENDIS bit set. This lets us read the real
vposr registers. We then have to write the real beamcon0 value bacj
out after. This nullifies our trick of only writing beamcon0 once, but we
only do this for lpens. I have to assume that noone is doing any dirty
beamcon0 writes behind my back when using a lpen.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.30 92/08/17 17:07:45 spence Exp Locker: spence $
d138 6
d152 1
@


39.30
log
@won't read the vpos registers if the lightpen bit is set, as the values
are bogus (they are latched by the lpen, and not freed until
*after* vblank
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.29 92/08/11 14:12:55 chrisg Exp Locker: spence $
d106 1
a106 1
	movem.l	d2/d3,-(sp)
d116 8
d126 2
a127 1
	move.w	ms_BeamCon0(a6),beamcon0(a0)
a140 2
		btst.b	#3,gb_system_bplcon0+1(a1)	; lpen bit set?
		bne.s	do_lace				; if so, we can't rely on vpos values
a144 1
do_lace:
d182 12
a193 1
	movem.l	(sp)+,d2/d3
@


39.29
log
@darren optimizations.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.28 92/08/10 10:31:30 chrisg Exp Locker: chrisg $
d132 2
d138 1
@


39.28
log
@interrupt changes for new qblit code.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.27 92/07/21 14:46:56 spence Exp Locker: chrisg $
a480 1
	bne	bltasm_busy
d574 2
@


39.27
log
@FindMSBSet()
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.26 92/06/23 14:12:57 spence Exp Locker: spence $
d31 1
a31 1
	xref	_LVOGfxSpare1,_LVOReplyMsg
d48 1
a48 1
    xref    _ciab
d182 62
d312 12
d325 242
a566 23
* assume this interrupt for me for now.
* a1 points to GfxBase
* a6 is saved by interrupt handler
* if 
*	test
*	move.l	_vposr,d0
    move.l  gb_cia(a1),a6   * get resource ptr
    move.l  a1,-(sp)        * save GfxBase
    moveq.l #4,d0
    jsr     _LVOAbleICR(a6)         * disable timer interrupt
    move.l  (sp)+,a1
*   and.w   #DMAF_BLTDONE,_dmaconr
*   if =
*       move    #$2300,sr   * go to blitter interrupt priority
	if gb_blthd(a1)=#0.l
	    ifne    DEBUGCOLOR
	    move.w  #$FFF,$dff180
	    endc
	    move.w  #BITSET+INTF_BLIT,_intena
	    move.w  #BITSET+INTF_BLIT,_intreq
	endif
*   endif
    rts
d568 56
a623 2
	ifnd MOLLYFIX
mgetout	macro
a624 269
	endm
	endc

	ifd	MOLLYFIX
mgetout	macro
	bra	getout
	endm
getout:
*
*		bart - 10.07.85
*		enable_interrupts
*		end bart
*
	rts
	endc

    xdef    _bltasm
_bltasm:
* assume a5-a6,d0-d1 have been saved by Carls routines
* Carl says a6 does not need to be preserved
	ifd	MOLLYFIX
*
*		bart - 10.07.85
*		disable_interrupts
*		end bart
*
	endc
donextblit:
    move.w  #INTF_BLIT,intreq(a0)   * turn off interrupt
doblitnow:
    move.l  gb_blthd(a1),d0 * get first thing on list
    if <> .ex
*       does QBlitter own the blitter?
	btst    #QBOWNERn,gb_Flags+1(a1)
	if =
	    mgetout
	endif
	move.l  a1,a6
	move.l  d0,a1
* a0 points to iochips
	ifne    DEBUGCOLOR
	move.w  #$FF0,$180(a0)
	endc
	ifeq	ANUTHABADAGNUS
	WAITBLITDONE
	endc
	ifne	ANUTHABADAGNUS
*	BAD Agnus setting blitter interrupt bit too early,
*   so need an extra check. Do here, instead of in WAITBLITDONE macro for more
*   local penalty. - spence Feb 11 1991
*	lea		_dmaconr,a5		* doesn't work this way :-( (???)
    tst.b	_dmaconr			* only needed if BAD Agnus
    btst 	#14-8,_dmaconr
    if =
	    tst.b	_dmaconr			* only needed if BAD Agnus
        bra.s	doblitnow1
    endif
    repeat
        nop     * waste some time
        nop
        btst #14-8,_dmaconr
    until =
*   must test again incase blitter has not actually stopped
    tst.b	_dmaconr			* only needed if BAD Agnus
    tst.b	_dmaconr			* only needed if BAD Agnus
	endc
doblitnow1:
	move.l  4(a1),a5    * get ptr to routine to call
	jsr     (a5)
	move.l  gb_blthd(a6),a1 * this does not affect ccr
	if = .ex
		ifeq	ANUTHABADAGNUS
	    WAITBLITDONE
		endc
		ifne	ANUTHABADAGNUS
*		lea		_dmaconr,a5
	    tst.b	_dmaconr			* only needed if BAD Agnus
    	btst 	#14-8,_dmaconr
	    if =
		    tst.b	_dmaconr			* only needed if BAD Agnus
        	bra.s	doblitnow2
	    endif
    	repeat
	        nop     * waste some time
    	    nop
        	btst #14-8,_dmaconr
	    until =
*   must test again incase blitter has not actually stopped
	    tst.b	_dmaconr			* only needed if BAD Agnus
    	tst.b	_dmaconr			* only needed if BAD Agnus
		endc
doblitnow2:
	    move.l  (a1),gb_blthd(a6)   /* remove from list */
	    bsr doclean
	    subq.w  #1,gb_BlitLock(a6)
	    move.w  gb_BeamSync(a6),d0
	    if =
		if  gb_blthd(a6)=#0.l
		    bclr    #QBOWNERn,gb_Flags+1(a6)
		    tst.w   gb_BlitLock(a6)
		    bsr _disownnodec
* kill blitter interrupts if the last blit
		    move.w  #INTF_BLIT,_intena
		    mgetout
		endif
	    else    .ex * check for beam position
* check for beam wrap to enter catch up mode
dobeam:
		ifne    DEBUGCOLOR
		move.w  #$F,$dff180
		endc
		move.l  _vposr,d1
		asr.l   #8,d1
		and.l	#$7FF,d1
*		the next statement could actual be 'if d1.w'
		if #1.w>d1	/* hit it on row 0?*/
			move.w	gb_MaxDisplayRow(a6),d1
			addq.w	#1,d1
		endif
		if d1<d0.w .extend
		    ifne    DEBUGCOLOR
		    move.w #$F0,$dff180
		    endc
		    if gb_VBlank(a6).b=#0
*                       catch up mode
*                       put all beam blits at front of standard blit q
*                       a1 points to first standard blit
*                       have to count number of blits that are being put
*                       on this q and add to BlitLock
do_cu:
*           count number of bsblits
			moveq   #0,d0
			move.l  gb_bsblthd(a6),d1
			repeat
			    addq.w  #1,d0
			    move.l  d1,a0
			    move.l  (a0),d1
			until   =
			if gb_blthd(a6)=#0.l
			    move.l  gb_bsblttl(a6),gb_blttl(a6)
			endif
			move.l  gb_bsblttl(a6),a0
			move.l  gb_blthd(a6),(a0)   * tail of bb pnts to head of b
			move.l  gb_bsblthd(a6),gb_blthd(a6) *new first blt
			clr.l   gb_bsblthd(a6)              * zero list
			clr.w   gb_BeamSync(a6)
			btst    #QBOWNERn,gb_Flags+1(a6)
			if =
			    ifne    DEBUGCOLOR
			    move.w  #$f00,$dff180
			    endc
			    addq.w  #1,gb_BlitLock(a6)
			    if <>
				subq.w  #1,gb_BlitLock(a6)
				add.w   d0,gb_BlitLock(a6)
				mgetout
			    endif
			    subq.w  #1,gb_BlitLock(a6)
			    bset    #QBOWNERn,gb_Flags+1(a6)
			endif
			add.w   d0,gb_BlitLock(a6)
		    else .ex
*   we may have stepped on vblank interrupt
*   check if there is vblank interrupt pending
			and.w   #INTF_VERTB,_intreqr
			if <>
* drop priority to 2
			    move.w  #INTF_BLIT,_intena
			    move    #$2200,sr   * let vblank occur
			    move    #$2300,sr
			    move.w  #BITSET+INTF_BLIT,_intena
			    bra     do_cu
			endif
			if gb_blthd(a6).l=#0
* must queue something up to make sure we get tickled as soon as beam
* approaches
			    bsr start_timer
			    if  gb_blthd(a6)=#0.l
				btst.b	#QBOWNERn,gb_Flags+1(a6)
				sne	d0
				tst.w   gb_BlitLock(a6)
				bsr _disownnodec
				tst.w   gb_BlitLock(a6)
				blt.s	relinquish_ownership
				tst.b	d0
				bne.s	remain_owner
relinquish_ownership: 		bclr    #QBOWNERn,gb_Flags+1(a6)
remain_owner:			
			    endif
			    mgetout
			endif
		    endif   start up this blit
		else
* remove bs blit from bs queue
		    move.l  gb_bsblthd(a6),a0
		    move.l  (a0),gb_bsblthd(a6) * remove from bs list
		    if =
			clr.w   gb_BeamSync(a6) * no more bs blits
		    else
			move.l  (a0),a1
			move.w  bn_beamsync(a1),d0
			move.w  d0,gb_BeamSync(a6)
		    endif
* insert the beam blit node in the front of the standard blit list
		    move.l  gb_blthd(a6),(a0)
		    if =
			move.l  a0,gb_blttl(a6)
		    endif
		    move.l  a0,gb_blthd(a6)
		    btst    #QBOWNERn,gb_Flags+1(a6)
		    if =
			ifne    DEBUGCOLOR
			move.w  #$f00,$dff180
			endc
			addq.w  #1,gb_BlitLock(a6)
			if <>
			    mgetout
			endif
			bset    #QBOWNERn,gb_Flags+1(a6)
		    else
			addq.w  #1,gb_BlitLock(a6)
		    endif
		endif
* restart interrupt routine
		lea _custom,a0
		ifne DEBUGCOLOR
		move.w  #$f0f,$180(a0)
		endc
		move.l  a6,a1
		bra doblitnow
	    endif
	endif
    else                    * check beam blit q
		move.w  gb_BeamSync(a1),d0
		if <>
	    	move.l  a1,a6
	    	bra     dobeam
		endif
		mgetout
    endif
    lea _custom,a0
    move.l  a6,a1
    tst.b	dmaconr(a0)  * bart - 03.08.90 - if bad agnus
    btst.b	#DMAB_BLTDONE-8,dmaconr(a0)
*   check for shorty blit
    beq donextblit
    mgetout


*    xdef    _jam
*_jam:
*    move.l  4(sp),a0    * get ptr
*    move.l  8(sp),d0    * get value
*    move.l  12(sp),d1   * get byte count
*    asr.l   #2,d1       * convert to long count
*    subq.l  #1,d1       * predecrement for dbra
*jamagin:
*	move.l  d0,(a0)+
*    dbf d1,jamagin
*    rts

doclean:
*   enter with a1 pointing to blit node
    btst    #CLEANMEn,bn_stat(a1)
    if <>
	move.l  bn_cleanup(a1),a5
	jsr (a5)
    endif
    rts
a652 27
	ifne	PRINTF
    xdef    _printf
    xref    _kprintf
_printf:
    jmp     _kprintf
	endc


    xdef    start_timer
start_timer:
    btst    #1,gb_system_bplcon0+1(a6)
    if <>
	asr.w   #1,d0   * if genloc then this counter is halfassed
    endif
    lea     _ciab,a0
    ror.w   #8,d0
    move.b  d0,ciatodmid(a0)
    rol.w   #8,d0
    move.b  d0,ciatodlow(a0)
    move.l  a6,-(sp)
	move.l	#$4,d0
    move.l  gb_cia(a6),a6
	jsr		_LVOSetICR(a6)	* clear interrupt first
    move.l  #$84,d0
    jsr     _LVOAbleICR(a6)	* now enable next one
    move.l  (sp)+,a6
    rts
@


39.26
log
@put back code to set LOF bit in vpos, but is only executed for programmed
beam-sync modes (so it doesn't confuse Amber when deinterlacing).
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.25 92/06/19 12:15:51 spence Exp Locker: spence $
d72 1
d840 10
@


39.25
log
@vblank only writes beamcon0 if GBASE->Bugs CHANGE bit is set. This is so
applications (eg bootmenu) can set PAL in beamcon0 and have it stay
set!
No longer needs to set the LOF bit in non-laced modes. This was confusing
the Amber chip.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.24 92/06/18 15:41:30 spence Exp Locker: spence $
d105 1
a105 1
	move.l	d2,-(sp)
d107 1
d120 2
d157 4
d162 6
d172 1
a172 1
	move.l	(sp)+,d2
@


39.24
log
@removed the IFD hedley stuff.
Writes vbstrt, vbstop, vtotal and beamcon0 in vblank.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.23 92/06/16 16:43:35 spence Exp Locker: spence $
d105 1
a105 1
	movem.l	d2,-(sp)
d110 6
d117 2
a153 4

* If the display mode just changed from Lace to non-laced, then the 
* mode may be stuck in the ShortFrame mode. So make sure it's Long.

a154 3
		move.w	vposr(a0),d0
		or.w	#VPOSRLOF,d0
		move.w	d0,vposw(a0)
d159 1
a159 1
	movem.l	(sp)+,d2
@


39.23
log
@No need to write vtotal in vblank
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.22 92/06/16 13:21:52 chrisg Exp Locker: spence $
d7 9
a15 9
    include 'exec/types.i'
    include 'exec/nodes.i'
    include 'exec/lists.i'
    include 'exec/interrupts.i'
    include 'exec/libraries.i'
    include	'exec/ables.i'
    include '/gfxbase.i'
    include '/vp_internal.i'
    include '/gfx.i'
d18 12
a29 11
    include 'hardware/blit.i'
    include 'hardware/intbits.i'
    include 'hardware/dmabits.i'
    include '/cia8520.i'
	include 'hardware/custom.i'
	include '/sane_names.i'
    include 'hardware/custom.i'
	include '/macros.i'
	include	'/a/submacs.i'
	include	'/rastport.i'
	include	'/clip.i'
d104 25
a128 80
	lea.l	_custom+cop2ptr,a0	        * a matter of some controversy
	    ifd	HEDLEY
		if gb_hedley_flags(a1).w .extend
			move.w	gb_hedley_count(a1),d1
			move.l	vposr-cop2ptr(a0),d0	        * too far?
			and.l	#$007FF00,d0
			cmp.l	#$0000C00,d0
			if <
			    move.w d1,d0 ; we know high byte of word is clear
			    if gb_hedley_hint2(a1).b
				    tst.b	gb_hedley_hint(a1)
				if >=
*					back this guy up
					move.b	gb_hedley_hint(a1),d0
					subq.w	#4,d1
				endif
			    endif


			    add.w	#gb_hedley,d0
			    move.l	0(a1,d0.w),(a0) * extract from table
			    move.l	gb_hedley_sprites-gb_hedley(a1,d0.w),sprpt-cop2ptr(a0)
			    if #1=gb_hedley_flags(a1).w
				    move.l	gb_hedley_sprites-gb_hedley(a1,d0.w),sprpt+4-cop2ptr(a0)
			    else
				    move.l	gb_hedley_sprites1-gb_hedley(a1,d0.w),sprpt+4-cop2ptr(a0)
			    endif
			endif
			addq.w	#4,d1	* to nexct long
			if #1=gb_hedley_flags(a1).w
*				4 screens
				and.w	#15,d1	* round robin
			else
*				6 screens
				if #20<d1.w
					clr.w	d1
				endif
			endif
			move.w	d1,gb_hedley_count(a1)
*			btst	#gbn_A2024,gb_DisplayMonitors2(a1)
			btst	#7,4+gb_crb_reserved(a1)
			if =
				move.b	#-1,gb_hedley_hint(a1)
				not.b	gb_hedley_hint2(a1)
			else
				st	gb_hedley_hint2(a1)
			endif
		else
	    endc
			move.l	d2,-(sp)
			moveq	#0,d2
			lea	gb_MonitorVBlank(a1),a6
			move.l	asi_Start(a6),d2	; vbstrt and vbstop
1$:
			btst	#2,gb_Modes+1(a1)	; lace?
			if <>
				moveq	#0,d1
				move.l	gb_ExecBase(a1),a6
				move.w	gb_TopLine(a1),d1
				DISABLE					; blit ints fucking this up.
				move.l	vposr-cop2ptr(a0),d0 * too far?
				and.l	#$007FF00,d0
				cmp.l	d1,d0
				if <
*					long or short frame?
					tst.b	vposr-cop2ptr(a0) 
					if >= 
						move.l	d2,vbstrt-cop2ptr(a0)	; write VBSTRT, VBSTOP
						move.l gb_SHFlist(a1),(a0)
					else
						IFD	VBLANK_BUG
						btst.b	#BMB_BUG_VBLANK,gb_Bugs(a1)
						beq.s	1$
						add.l	#$10000,d2
1$:						ENDC
						move.l	d2,vbstrt-cop2ptr(a0)	; write VBSTRT, VBSTOP
						move.l  gb_LOFlist(a1),(a0)
					endif
				endif
				ENABLE
d135 2
a136 2
				move.l	d2,vbstrt-cop2ptr(a0)	; write VBSTRT, VBSTOP
				move.l  gb_LOFlist(a1),(a0)
a137 2
			move.l	(sp)+,d2
	    ifd	HEDLEY
d139 21
a159 1
	    endc
d165 1
a165 1
	move.b	vhposr-cop2ptr(a0),ciatodlow(a6)	* start timer
d217 1
a217 1
    rts
@


39.22
log
@don't want ASR!!!
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.21 92/06/11 12:11:45 spence Exp Locker: chrisg $
a153 4
			move.l	gb_current_monitor(a1),d1
			beq.s	1$
			move.l	d1,a6
			move.w	ms_total_rows(a6),vtotal-cop2ptr(a0)
@


39.21
log
@vblank writes to vtotal (from GfxBase->current_monitor->total_rows),
and vbstrt and vbstop from GfxBase->MonitorVBlank (calculated at
LoadView() time).
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.20 92/06/04 16:13:26 chrisg Exp $
a168 1
				asr.l	#8,d0		; TopLine is in LSBs
@


39.20
log
@fixed branch in getbounds.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.19 92/06/03 16:36:02 chrisg Exp Locker: chrisg $
d12 3
a14 1
	include	'exec/ables.i'
d16 1
a16 2
    include '/gfxbase.i'
	include	'/view.i'
d152 9
d175 1
d178 6
d189 6
d197 1
@


39.19
log
@double buffering signalling changes.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.18 92/05/21 07:53:14 chrisg Exp Locker: chrisg $
d779 1
a779 1
	bne.s	not_super
@


39.18
log
@enable/disable in vb int
copywords.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.17 92/05/19 13:18:55 chrisg Exp Locker: chrisg $
d15 1
d29 1
a29 1
	xref	_LVOGfxSpare1
d187 29
a216 1
	move.l  d2,-(sp)
d229 2
@


39.17
log
@added GetRPBounds function.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.16 92/05/05 12:16:28 chrisg Exp Locker: chrisg $
d12 1
d153 1
d155 1
d169 1
d802 9
@


39.16
log
@killed sortcr stub.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.15 92/04/08 16:18:34 chrisg Exp Locker: chrisg $
d29 1
d719 79
@


39.15
log
@killed redundant line.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.14 92/03/27 11:28:04 chrisg Exp Locker: chrisg $
a68 1
	xdef	_sortcr
a697 11
_sortcr:
; void __asm sortcr(register __a2 struct Layer *l,register __d2 int dx,register __d3 int dy);
	move.l	a6,-(a7)
	move.l	gb_LayersBase(a6),a6
	move.l	a2,a0
	move.l	d2,d0
	move.l	d3,d1
	jsr	_LVOSortLayerCR(a6)
	move.l	(a7)+,a6
	rts
	
@


39.14
log
@ Major layers<->graphics dependency change!!
 layers needs graphics to init. graphics needs layers!!!
so:
  in it's open routine, if GfxBase->gb_LayersBase is not set,
graphics InitResident's layers. layers will then poke layersbase into
graphics base. layers can't openlibrary graphics, so it FindName's
it.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.13 92/03/25 07:54:16 chrisg Exp Locker: chrisg $
d27 3
a82 1
	lea	lname(pc),a1
@


39.13
log
@fixed rastrect trashing of a2.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.12 92/03/24 15:30:41 chrisg Exp Locker: chrisg $
d65 4
d70 11
d82 3
a84 2
    move.l  a6,d0
    rts
a695 3
	xref	_LVOOpenLibrary,_LVOInstallLayerHook
	xdef	_sortcr
	xref	_LVOSortLayerCR
d700 1
a700 11
	move.l	gb_LayersBase(a6),d0
	bne.s	got_lbase
	lea	lname(pc),a1
	moveq	#39,d0
	move.l	gb_ExecBase(a6),a6
	jsr	_LVOOpenLibrary(a6)
	move.l	(a7),a6
	move.l	d0,gb_LayersBase(a6)
	beq.s	no_sort
got_lbase:
	move.l	d0,a6
a704 1
no_sort:
a707 58
	xref	_LVODoHookClipRects,_LVOObtainSemaphore,_LVOReleaseSemaphore

_rastrect::
; void rastrect(struct RastPort  *rp, struct Rectangle rect,
;						struct Hook *hook)
OFS_hook	equ	16+12
OFS_rect	equ	8+12
OFS_rp		equ	4+12
	movem.l	a2/a5/a4,-(a7)
	move.l	OFS_rp(a7),a5
	move.l	rp_Layer(a5),d0
	beq.s	nolayer
	move.l	a6,a4
	move.l	gb_ExecBase(a6),a6
	move.l	d0,a0
	lea	lr_Lock(a0),a0
	jsr	_LVOObtainSemaphore(a6)
	move.l	gb_LayersBase(a4),d0
	bne.s	no_open
	lea	lname(pc),a1
	moveq	#39,d0
	jsr	_LVOOpenLibrary(a6)
	move.l	d0,gb_LayersBase(a4)
no_open:
	move.l	d0,a6
	lea	OFS_rect(a7),a2
	move.l	OFS_hook(a7),a0
	move.l	rp_Layer(a5),a1
	move.l	lr_rp(a1),-(a7)
	move.l	a5,lr_rp(a1)
	move.l	a1,a5
	jsr	_LVODoHookClipRects(a6)
	move.l	(a7)+,lr_rp(a5)
	lea	lr_Lock(a5),a0
	move.l	gb_ExecBase(a4),a6
	jsr	_LVOReleaseSemaphore(a6)
	move.l	a4,a6
	movem.l	(a7)+,a2/a4/a5
	rts
nolayer:
	move.l	OFS_hook(a7),a0
	move.l	a5,a2
	move.l	a7,a5
	move.w	OFS_rect+ra_MinY(a5),d0
	ext.l	d0
	move.l	d0,-(a7)
	move.w	OFS_rect+ra_MinX(a5),d0
	ext.l	d0
	move.l	d0,-(a7)
	move.l	OFS_rect+8(a5),-(a7)
	move.l	OFS_rect(a5),-(a7)
	pea	$0
	move.l	a7,a1
	move.l	h_Entry(a0),a5
	jsr	(a5)
	lea	5*4(a7),a7
	movem.l	(a7)+,a2/a5/a4
	rts
@


39.12
log
@ added downcoded rastrect call.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.11 92/03/03 10:27:44 spence Exp Locker: chrisg $
d711 4
a714 4
OFS_hook	equ	16+8
OFS_rect	equ	8+8
OFS_rp		equ	4+8
	movem.l	a5/a4,-(a7)
d743 1
a743 1
	movem.l	(a7)+,a4/a5
a745 1
	move.l	a2,a6
d762 1
a762 2
	move.l	a6,a2
	movem.l	(a7)+,a5/a4
@


39.11
log
@Added DelayAndRead()
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.10 92/02/28 14:05:13 chrisg Exp Locker: spence $
d24 2
d585 1
a585 1
 	move.l	a6,-(sp)		; save library base
d587 3
a589 7
 	move.l	a1,-(sp)		; push message packet pointer
 	move.l	a2,-(sp)		; push object pointer
 	move.l	a0,-(sp)		; push hook pointer
	move.l	h_SubEntry(a0),a0	; fetch C entry point ...
	jsr	(a0)			; ... and call it
	lea	12(sp),sp		; fix stack
 	move.l	(sp)+,a6		; restore library base
d592 1
d601 1
d682 1
d701 1
a701 2
;	jsr	_LVOSortLayerCR(a6)
	jsr	_LVOInstallLayerHook-12(a6)
d706 60
@


39.10
log
@ added alwaysreturnszero.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.9 91/12/20 15:48:52 chrisg Exp Locker: chrisg $
d706 21
@


39.9
log
@  change signaling sceme for WaitTOF to support changevpbitmap function.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.8 91/11/18 11:45:20 chrisg Exp Locker: chrisg $
d61 2
a62 1
    xdef    _ExtFuncGfx
d69 2
a70 1
	clr.l	d0		* this library is currently never removed
@


39.8
log
@changed stupid code fragments to use lc protots.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.7 91/11/08 11:35:57 spence Exp $
d165 3
a167 1
			moveq	#$10,d0			* TOF_SIGNAL
@


39.7
log
@Shifts vpos in d0 into LSBs for comparison with TopLine
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.6 91/11/08 11:17:29 chrisg Exp Locker: spence $
d177 3
a179 2
	xdef	_BLTBYTES
*	called like BLTBYTES(xmin,xmax)
a180 5
	move.w	6(sp),d0
	move.w	10(sp),d1
*	fall into next routine
	
	xdef	bltbytes
a545 7
	xdef    _genminterms
	xref    GenMinTerms

_genminterms:
	move.l  4(sp),a1                    * Set up *w
	bsr     GenMinTerms                 * Go to assembly language version
	rts                                 * Exit to C code
d548 1
a551 2
	move.w	6(sp),d0
	move.w	10(sp),d1
@


39.6
log
@ added _sortcr call to layers (with OpenLibrary stuff).
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.5 91/11/04 15:42:44 chrisg Exp Locker: chrisg $
d133 1
@


39.5
log
@downcoded rectXrect function
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.4 91/10/28 19:38:31 spence Exp Locker: chrisg $
d687 27
@


39.4
log
@get_denise_id() code for better detection of non-ECS denise on
A1000,
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.3 91/10/15 15:57:49 chrisg Exp Locker: spence $
d659 28
@


39.3
log
@turned off hedley flag
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.2 91/10/10 09:49:03 chrisg Exp Locker: chrisg $
a40 1
    xref    _intenar
d57 1
d607 52
@


39.2
log
@  made use register parameters on IDivS_xxx
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.1 91/08/27 16:48:30 spence Exp Locker: chrisg $
d35 1
a35 1
HEDLEY	equ 1
d127 1
a127 1
			btst	#2,gb_Modes+1(a1)
@


39.1
log
@use gb_TopLine instead of hardcode value of 0xC
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 39.0 91/08/21 17:20:24 chrisg Exp Locker: spence $
d497 1
d499 1
a499 2
    move.l  4(sp),d0
    divs    10(sp),d0
d510 1
a511 1
    move.l  4(sp),d0    * get dividend
d513 1
a513 1
    divs    10(sp),d0   * now divide it
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 37.6 91/05/02 12:55:36 chrisg Exp Locker: chrisg $
d12 2
a13 2
    include 'graphics/gfx.i'
    include 'graphics/gfxbase.i'
d129 2
d133 1
a133 1
				cmp.l	#$0000C00,d0
@


37.6
log
@ changed "../" to "/" for native build
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 37.5 91/04/19 16:34:48 spence Exp Locker: chrisg $
@


37.5
log
@fix start_timer to poke mid/low in proper order... bart
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 37.4 91/04/19 16:34:03 chrisg Exp Locker: spence $
d18 1
a18 1
    include '../cia8520.i'
d20 1
a20 1
	include '../sane_names.i'
d22 2
a23 2
	include '../macros.i'
	include	'../a/submacs.i'
@


37.4
log
@  Inserted ENABLE/DISABLE to override ones from amiga.lib
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 37.3 91/02/11 18:15:18 spence Exp Locker: chrisg $
d534 3
a537 2
    asr.w   #8,d0
    move.b  d0,ciatodmid(a0)
@


37.3
log
@Fixes problems with new Agnus (8372B) in blitter interrupt code.
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 37.2 91/02/07 16:24:57 spence Exp Locker: spence $
d563 20
a583 1

@


37.2
log
@back to 37.0
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 37.0 91/01/07 15:27:51 spence Exp $
d32 1
a32 1

a261 1
	move.l  4(a1),a5    * get ptr to routine to call
d265 1
d267 23
d293 1
d295 19
@


37.1
log
@vblank now updates sprite positions
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 37.0 91/01/07 15:27:51 spence Exp Locker: spence $
a23 1
	include '../gels/gelsinternal.i'
a153 17

* now handle the moved sprites - spence Jan 29 1991
	move.l  d2,-(sp)
	move.l	gb_SpriteCtlData(a1),a6
	moveq	#0,d2
	moveq	#7,d1
handle_sprites:
	move.l	(a6),d0				* pcd_Address
	beq.s	handle_s_loop
	move.l	d2,(a6)
	move.l	d0,a0
	move.l	pcd_Data(a6),(a0)
handle_s_loop:
	addq.l	#pcd_SizeOf,a6
	dbra	d1,handle_sprites

handle_TOF:
d158 1
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 36.19 90/09/06 16:40:19 bart Exp Locker: spence $
d24 1
d155 17
a175 1
	move.l  d2,-(sp)
@


36.19
log
@fix ownblitter relinquishing in interrupt routine for blitter
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 36.18 90/08/29 18:37:59 bart Exp Locker: bart $
@


36.18
log
@preserve QBOWNER status if starting timer
fixes ownblitter contention if not owned and dobeam is called for pendingblit
@
text
@d3 1
a3 1
*	$Id: misc.asm,v 36.17 90/07/27 16:58:51 bart Exp Locker: bart $
d361 2
d365 1
a365 1
				bclr    #QBOWNERn,gb_Flags+1(a6)
@


36.17
log
@id
@
text
@d3 1
a3 1
*	$Id: $
d357 2
a358 1
				bclr    #QBOWNERn,gb_Flags+1(a6)
d361 4
a364 2
* kill blitter interrupts if the last blit
*				move.w  #INTF_BLIT,_intena
@


36.16
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/graphics/c/RCS/misc.asm,v 36.15 90/03/27 15:52:55 bart Exp Locker: bart $
@


36.15
log
@oops 7FF instead of 3FF in vposr mask
@
text
@d3 1
a3 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/graphics/c/RCS/misc.asm,v 36.14 90/03/23 14:36:33 bart Exp Locker: bart $
@


36.14
log
@vbasm optimisations
@
text
@d3 1
a3 1
*	$Header: misc.asm,v 36.12 90/03/08 14:21:07 bart Exp $
d83 1
a83 1
			and.l	#$003FF00,d0
d130 1
a130 1
				and.l	#$003FF00,d0
@


36.13
log
@must load cop2ptr by line 0xc or copinit will have strobed it...
@
text
@d78 11
a88 23
	move.l	d2,-(sp)	* need a scratch register
	clr.b	gb_VBlank(a1)
	lea	_custom,a0	* a matter of some controversy
	move.l	vposr(a0),d1	* ...get vertical beam position
	and.l	#$0003FF00,d1	* mask ecs vertical beam position
	cmp.l	#$00000C00,d1	* need to assure load before line 0xc
	if <    .extend		* otherwise copinit already strobed copjmp2
	    btst	#2,gb_Modes+1(a1)
	    if <>
		btst #7,vposr(a0) * long or short frame?
		if <>
			move.l gb_LOFlist(a1),cop2ptr(a0)
		else
			move.l gb_SHFlist(a1),cop2ptr(a0)
		endif
	    else
		ifd	HEDLEY
		if gb_hedley_flags(a1).w
			move.w	gb_hedley_count(a1),d2
			move.w d2,d0 ; we know that high byte of word is clear

			if gb_hedley_hint2(a1).b
				tst.b	gb_hedley_hint(a1)
d92 1
a92 1
					subq.w	#4,d2
d94 1
a94 1
			endif
a95 3
			add.w	#gb_hedley,d0
			move.l	0(a1,d0.w),cop2ptr(a0) * extract from table
			move.l	gb_hedley_sprites-gb_hedley(a1,d0.w),sprpt(a0)
d97 10
a106 1
			addq.w	#4,d2	* to nexct long
d109 1
a109 2
				move.l	gb_hedley_sprites-gb_hedley(a1,d0.w),sprpt+4(a0)
				and.w	#15,d2	* round robin
a110 1
				move.l	gb_hedley_sprites1-gb_hedley(a1,d0.w),sprpt+4(a0)
d112 2
a113 2
				if #20<d2.w
					clr.w	d2
d116 1
a116 1
			move.w	d2,gb_hedley_count(a1)
d126 19
a144 1
			move.l  gb_LOFlist(a1),cop2ptr(a0)
d146 1
a146 3
		endc
	   endif
	endif
d152 1
a152 1
	move.b	vhposr(a0),ciatodlow(a6)	* start timer
d155 2
a156 1
	move.l	4,a6					* get ExecBase
d158 1
d292 1
a292 1
		and.w	#$3FF,d1   * beware 1.4/ecs lol bit
@


36.12
log
@minor optimisation on test of dmaconr
@
text
@d3 1
a3 1
*	$Header: misc.asm,v 36.11 90/02/28 09:56:42 bart Exp $
d81 7
a87 3
	btst	#2,gb_Modes+1(a1)
	if <>
		btst #7,vposr(a0)	* long or short frame?
d89 1
a89 1
		    move.l gb_LOFlist(a1),cop2ptr(a0)
d91 1
a91 1
		    move.l gb_SHFlist(a1),cop2ptr(a0)
d93 2
a94 2
	else
	  ifd	HEDLEY
d136 2
a137 1
	  endc
d282 1
@


36.11
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: misc.asm,v 36.10 90/02/28 09:38:51 bart Exp $
d400 2
a401 2
    btst    #DMAB_BLTDONE-8,dmaconr(a0)
    btst    #DMAB_BLTDONE-8,dmaconr(a0) * bart - 11.24.85 - if bad agnus
@


36.10
log
@no more displaymonitors field in gfxbase
@
text
@d3 1
a3 1
*	$Header: misc.asm,v 36.9 89/11/09 17:14:17 bart Exp $
d122 1
a122 1
			btst	#7,gb_4+crb_reserverd(a1)
@


36.9
log
@bltbitmask rastrect hook
@
text
@d3 1
a3 1
*	$Header: misc.asm,v 36.8 89/10/31 13:01:27 bart Exp $
d122 1
a122 1
			btst	#7,gb_DisplayMonitors2(a1)
@


36.8
log
@removed SysBase
@
text
@d3 1
a3 1
*	$Header: misc.asm,v 36.7 89/05/08 15:34:26 bart Exp $
d498 16
@


36.7
log
@load a0 == _custom at head of vbasm
@
text
@d3 1
a3 1
*	$Header: misc.asm,v 36.6 89/02/14 10:13:06 bart Exp $
a56 3

    xdef    _SysBase
_SysBase    equ 4
@


36.6
log
@checkpoint 02.14.89
@
text
@d3 1
a3 1
*	$Header: misc.asm,v 36.5 89/02/01 17:52:44 bart Exp $
d83 1
a83 1
*	lea	_custom,a0	* loaded by exec
d88 1
a88 1
            move.l gb_LOFlist(a1),cop2ptr(a0)
d90 1
a90 1
            move.l gb_SHFlist(a1),cop2ptr(a0)
@


36.5
log
@checkpoint -- a2024 10hz and 15hz scan works from 32 bit id
@
text
@d3 1
a3 1
*	$Header: misc.asm,v 36.4 89/02/01 17:39:29 bart Exp $
@


36.4
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: misc.asm,v 36.3 89/02/01 12:04:29 bart Exp $
@


36.3
log
@btst    #gbn_A2024,gb_DisplayMonitors2
@
text
@d3 1
a3 1
*	$Header: misc.asm,v 36.2 88/08/18 21:18:48 dale Exp $
d96 2
a97 1
			move.w d2,d0		; we know that high byte of word is clear
d124 2
a125 1
			btst	#gbn_A2024,gb_DisplayMonitors2(a1)
@


36.2
log
@Fixed 15hz hedley sprite black lines. Now use attached sprite in
10hz and 15hz 
and 15hz modes.
@
text
@d3 1
a3 1
*	$Header: misc.asm,v 36.1 88/03/10 16:12:38 dale Exp $
d123 7
a129 2
			move.b	#-1,gb_hedley_hint(a1)
			not.b	gb_hedley_hint2(a1)
@


36.1
log
@
@
text
@d3 1
a3 1
*	$Header: $
d113 1
@
