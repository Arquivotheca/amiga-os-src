head     39.75;
branch   ;
access   ;
symbols  rel39_24:39.75 rel39_18:39.74 rel39_97:39.67 rel39_82:39.65 rel39_76:39.62 rel39_71:39.60 rel39_65:39.55 rel39_64:39.54 rel39_61:39.53 rel39_60:39.53 rel39_55:39.46 rel39_52:39.44 rel39_47:39.38 rel39_39:39.31 rel39_37:39.27 rel39_35:39.26 rel39_34:39.25 V37_30:37.10 V37_29:37.10 V37_28:37.9 V37_27:37.6 V37_25:37.6 V37_24:37.5 V37_23:37.5 V37_22:37.5 V37_21:37.5 V37_20:37.4 V37_19:37.3 V37_17:37.3 V37_15:37.2 V37_14:37.2 V37_13:37.2 V37_12:37.2 V37_11:37.1 V37_10:37.1 V37_9:37.1 V37_8:37.1 V37_7:37.1 V37_6:37.0 V37_5:37.0 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:36.105 V36_208:36.105 V36_207:36.105 V36_205:36.105 V36_203:36.105 V36_202:36.103 V36_201:36.103 V36_200:36.103 V36_199:36.103 V36_198:36.103 V36_196:36.103 V36_195:36.103 V36_194:36.103 V36_193:36.103 V36_192:36.103 V36_191:36.103 V36_190:36.103 V36_189:36.103 V36_188:36.103 V36_186:36.103 V36_185:36.103 V36_184:36.103 V36_182:36.103 V36_181:36.103;
locks    ; strict;
comment  @ * @;


39.75
date     93.05.17.13.46.53;  author chrisg;  state Exp;
branches ;
next     39.74;

39.74
date     93.04.21.18.39.01;  author spence;  state Exp;
branches ;
next     39.73;

39.73
date     93.03.30.10.21.31;  author chrisg;  state Exp;
branches ;
next     39.72;

39.72
date     93.03.19.12.25.31;  author chrisg;  state Exp;
branches ;
next     39.71;

39.71
date     93.03.08.09.49.24;  author chrisg;  state Exp;
branches ;
next     39.70;

39.70
date     93.02.16.13.45.53;  author chrisg;  state Exp;
branches ;
next     39.69;

39.69
date     93.02.09.15.55.20;  author chrisg;  state Exp;
branches ;
next     39.68;

39.68
date     92.11.23.16.27.08;  author spence;  state Exp;
branches ;
next     39.67;

39.67
date     92.10.27.12.54.34;  author spence;  state Exp;
branches ;
next     39.66;

39.66
date     92.08.27.12.16.34;  author spence;  state Exp;
branches ;
next     39.65;

39.65
date     92.08.11.14.17.45;  author chrisg;  state Exp;
branches ;
next     39.64;

39.64
date     92.08.11.14.00.42;  author spence;  state Exp;
branches ;
next     39.63;

39.63
date     92.08.06.16.40.31;  author spence;  state Exp;
branches ;
next     39.62;

39.62
date     92.07.21.16.45.51;  author chrisg;  state Exp;
branches ;
next     39.61;

39.61
date     92.07.21.14.23.53;  author chrisg;  state Exp;
branches ;
next     39.60;

39.60
date     92.07.01.13.39.57;  author chrisg;  state Exp;
branches ;
next     39.59;

39.59
date     92.06.30.16.39.36;  author spence;  state Exp;
branches ;
next     39.58;

39.58
date     92.06.19.12.13.33;  author spence;  state Exp;
branches ;
next     39.57;

39.57
date     92.06.18.15.32.54;  author spence;  state Exp;
branches ;
next     39.56;

39.56
date     92.06.11.10.46.14;  author spence;  state Exp;
branches ;
next     39.55;

39.55
date     92.06.09.12.10.43;  author spence;  state Exp;
branches ;
next     39.54;

39.54
date     92.06.03.18.06.03;  author spence;  state Exp;
branches ;
next     39.53;

39.53
date     92.05.20.14.16.43;  author chrisg;  state Exp;
branches ;
next     39.52;

39.52
date     92.05.19.13.17.47;  author chrisg;  state Exp;
branches ;
next     39.51;

39.51
date     92.05.13.11.25.20;  author spence;  state Exp;
branches ;
next     39.50;

39.50
date     92.05.05.14.01.59;  author chrisg;  state Exp;
branches ;
next     39.49;

39.49
date     92.05.05.13.54.36;  author spence;  state Exp;
branches ;
next     39.48;

39.48
date     92.05.05.12.09.53;  author chrisg;  state Exp;
branches ;
next     39.47;

39.47
date     92.04.29.12.16.56;  author spence;  state Exp;
branches ;
next     39.46;

39.46
date     92.04.27.15.03.13;  author chrisg;  state Exp;
branches ;
next     39.45;

39.45
date     92.04.27.11.56.40;  author spence;  state Exp;
branches ;
next     39.44;

39.44
date     92.04.10.12.13.48;  author spence;  state Exp;
branches ;
next     39.43;

39.43
date     92.04.08.17.05.53;  author chrisg;  state Exp;
branches ;
next     39.42;

39.42
date     92.04.07.14.52.33;  author spence;  state Exp;
branches ;
next     39.41;

39.41
date     92.04.07.13.37.25;  author chrisg;  state Exp;
branches ;
next     39.40;

39.40
date     92.04.06.13.58.48;  author chrisg;  state Exp;
branches ;
next     39.39;

39.39
date     92.04.06.12.39.06;  author chrisg;  state Exp;
branches ;
next     39.38;

39.38
date     92.04.04.14.35.01;  author chrisg;  state Exp;
branches ;
next     39.37;

39.37
date     92.04.03.16.57.25;  author chrisg;  state Exp;
branches ;
next     39.36;

39.36
date     92.04.02.10.44.59;  author spence;  state Exp;
branches ;
next     39.35;

39.35
date     92.03.26.12.44.07;  author chrisg;  state Exp;
branches ;
next     39.34;

39.34
date     92.03.24.15.28.16;  author chrisg;  state Exp;
branches ;
next     39.33;

39.33
date     92.03.19.16.10.00;  author chrisg;  state Exp;
branches ;
next     39.32;

39.32
date     92.03.06.12.41.25;  author spence;  state Exp;
branches ;
next     39.31;

39.31
date     92.03.03.13.39.30;  author chrisg;  state Exp;
branches ;
next     39.30;

39.30
date     92.03.03.10.26.12;  author spence;  state Exp;
branches ;
next     39.29;

39.29
date     92.03.02.14.50.41;  author chrisg;  state Exp;
branches ;
next     39.28;

39.28
date     92.02.28.14.03.15;  author chrisg;  state Exp;
branches ;
next     39.27;

39.27
date     92.02.24.14.09.37;  author chrisg;  state Exp;
branches ;
next     39.26;

39.26
date     92.02.20.14.07.08;  author chrisg;  state Exp;
branches ;
next     39.25;

39.25
date     92.02.14.15.58.18;  author chrisg;  state Exp;
branches ;
next     39.24;

39.24
date     92.01.30.15.33.36;  author chrisg;  state Exp;
branches ;
next     39.23;

39.23
date     92.01.29.13.12.37;  author spence;  state Exp;
branches ;
next     39.22;

39.22
date     92.01.21.14.51.54;  author chrisg;  state Exp;
branches ;
next     39.21;

39.21
date     92.01.21.12.49.36;  author spence;  state Exp;
branches ;
next     39.20;

39.20
date     92.01.07.15.53.49;  author spence;  state Exp;
branches ;
next     39.19;

39.19
date     92.01.07.14.24.04;  author chrisg;  state Exp;
branches ;
next     39.18;

39.18
date     92.01.07.13.41.35;  author spence;  state Exp;
branches ;
next     39.17;

39.17
date     91.12.31.14.29.43;  author spence;  state Exp;
branches ;
next     39.16;

39.16
date     91.12.20.15.47.02;  author chrisg;  state Exp;
branches ;
next     39.15;

39.15
date     91.11.18.16.41.58;  author spence;  state Exp;
branches ;
next     39.14;

39.14
date     91.11.18.11.29.49;  author spence;  state Exp;
branches ;
next     39.13;

39.13
date     91.11.15.10.52.34;  author spence;  state Exp;
branches ;
next     39.12;

39.12
date     91.11.08.12.12.03;  author spence;  state Exp;
branches ;
next     39.11;

39.11
date     91.11.08.11.32.09;  author chrisg;  state Exp;
branches ;
next     39.10;

39.10
date     91.10.30.19.18.04;  author spence;  state Exp;
branches ;
next     39.9;

39.9
date     91.10.28.19.32.35;  author spence;  state Exp;
branches ;
next     39.8;

39.8
date     91.10.28.11.49.43;  author chrisg;  state Exp;
branches ;
next     39.7;

39.7
date     91.10.16.17.21.03;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     91.10.15.15.51.02;  author chrisg;  state Exp;
branches ;
next     39.5;

39.5
date     91.10.04.12.20.27;  author chrisg;  state Exp;
branches ;
next     39.4;

39.4
date     91.09.23.11.05.53;  author spence;  state Exp;
branches ;
next     39.3;

39.3
date     91.08.29.15.01.58;  author spence;  state Exp;
branches ;
next     39.2;

39.2
date     91.08.29.11.28.23;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     91.08.27.16.33.25;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.16.36;  author chrisg;  state Exp;
branches ;
next     38.8;

38.8
date     91.08.20.16.05.44;  author chrisg;  state Exp;
branches ;
next     38.7;

38.7
date     91.08.07.13.51.40;  author chrisg;  state Exp;
branches ;
next     38.6;

38.6
date     91.07.22.15.15.01;  author spence;  state Exp;
branches ;
next     38.5;

38.5
date     91.07.12.16.30.59;  author chrisg;  state Exp;
branches ;
next     38.4;

38.4
date     91.07.03.10.52.06;  author chrisg;  state Exp;
branches ;
next     38.3;

38.3
date     91.06.07.15.57.28;  author spence;  state Exp;
branches ;
next     38.2;

38.2
date     91.06.03.16.48.54;  author chrisg;  state Exp;
branches ;
next     38.1;

38.1
date     91.05.30.13.22.51;  author chrisg;  state Exp;
branches ;
next     38.0;

38.0
date     91.05.29.17.04.48;  author spence;  state Exp;
branches ;
next     37.14;

37.14
date     91.05.20.11.08.41;  author chrisg;  state Exp;
branches ;
next     37.13;

37.13
date     91.05.14.12.40.33;  author spence;  state Exp;
branches ;
next     37.12;

37.12
date     91.05.03.15.46.14;  author chrisg;  state Exp;
branches ;
next     37.11;

37.11
date     91.05.02.12.48.03;  author chrisg;  state Exp;
branches ;
next     37.10;

37.10
date     91.04.22.10.38.44;  author spence;  state Exp;
branches ;
next     37.9;

37.9
date     91.04.21.19.57.35;  author spence;  state Exp;
branches ;
next     37.8;

37.8
date     91.04.21.16.56.08;  author spence;  state Exp;
branches ;
next     37.7;

37.7
date     91.04.20.20.19.28;  author bryce;  state Exp;
branches ;
next     37.6;

37.6
date     91.04.15.16.25.13;  author chrisg;  state Exp;
branches ;
next     37.5;

37.5
date     91.03.28.20.30.06;  author spence;  state Exp;
branches ;
next     37.4;

37.4
date     91.03.14.18.48.01;  author spence;  state Exp;
branches ;
next     37.3;

37.3
date     91.02.28.13.57.16;  author spence;  state Exp;
branches ;
next     37.2;

37.2
date     91.02.07.16.33.58;  author spence;  state Exp;
branches ;
next     37.1;

37.1
date     91.01.30.13.07.49;  author spence;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.18.57;  author spence;  state Exp;
branches ;
next     36.105;

36.105
date     90.12.10.15.13.53;  author bart;  state Exp;
branches ;
next     36.104;

36.104
date     90.12.10.15.11.02;  author bart;  state Exp;
branches ;
next     36.103;

36.103
date     90.07.27.16.56.04;  author bart;  state Exp;
branches ;
next     36.102;

36.102
date     90.05.27.12.55.10;  author bart;  state Exp;
branches ;
next     36.101;

36.101
date     90.04.11.18.39.40;  author bart;  state Exp;
branches ;
next     36.100;

36.100
date     90.04.11.16.44.42;  author bart;  state Exp;
branches ;
next     36.99;

36.99
date     90.04.06.18.21.45;  author bart;  state Exp;
branches ;
next     36.98;

36.98
date     90.03.28.09.10.09;  author bart;  state Exp;
branches ;
next     36.97;

36.97
date     90.03.15.13.22.28;  author bart;  state Exp;
branches ;
next     36.96;

36.96
date     90.02.28.09.38.21;  author bart;  state Exp;
branches ;
next     36.95;

36.95
date     90.01.31.15.31.18;  author bart;  state Exp;
branches ;
next     36.94;

36.94
date     90.01.23.19.31.07;  author kodiak;  state Exp;
branches ;
next     36.93;

36.93
date     90.01.23.14.59.32;  author kodiak;  state Exp;
branches ;
next     36.92;

36.92
date     90.01.23.14.31.27;  author kodiak;  state Exp;
branches ;
next     36.91;

36.91
date     89.11.29.13.20.10;  author bart;  state Exp;
branches ;
next     36.90;

36.90
date     89.10.31.13.00.08;  author bart;  state Exp;
branches ;
next     36.89;

36.89
date     89.10.26.11.36.05;  author bart;  state Exp;
branches ;
next     36.88;

36.88
date     89.09.04.17.15.28;  author kodiak;  state Exp;
branches ;
next     36.87;

36.87
date     89.08.22.09.12.35;  author bart;  state Exp;
branches ;
next     36.86;

36.86
date     89.08.21.11.10.10;  author bart;  state Exp;
branches ;
next     36.85;

36.85
date     89.08.17.11.19.23;  author bart;  state Exp;
branches ;
next     36.84;

36.84
date     89.08.11.10.53.33;  author bart;  state Exp;
branches ;
next     36.83;

36.83
date     89.06.23.16.08.56;  author bart;  state Exp;
branches ;
next     36.82;

36.82
date     89.05.08.15.26.05;  author bart;  state Exp;
branches ;
next     36.81;

36.81
date     89.05.05.12.25.35;  author bart;  state Exp;
branches ;
next     36.80;

36.80
date     89.04.29.15.41.51;  author bart;  state Exp;
branches ;
next     36.79;

36.79
date     89.04.12.10.53.45;  author bart;  state Exp;
branches ;
next     36.78;

36.78
date     89.04.06.13.32.34;  author kodiak;  state Exp;
branches ;
next     36.77;

36.77
date     89.03.21.13.14.06;  author bart;  state Exp;
branches ;
next     36.76;

36.76
date     89.03.16.14.07.15;  author bart;  state Exp;
branches ;
next     36.75;

36.75
date     89.03.06.20.52.03;  author bart;  state Exp;
branches ;
next     36.74;

36.74
date     89.03.02.18.29.51;  author bart;  state Exp;
branches ;
next     36.73;

36.73
date     89.02.23.13.16.34;  author bart;  state Exp;
branches ;
next     36.72;

36.72
date     89.02.23.11.10.00;  author bart;  state Exp;
branches ;
next     36.71;

36.71
date     89.02.20.16.17.32;  author bart;  state Exp;
branches ;
next     36.70;

36.70
date     89.02.20.15.46.25;  author bart;  state Exp;
branches ;
next     36.69;

36.69
date     89.02.17.22.03.32;  author bart;  state Exp;
branches ;
next     36.68;

36.68
date     89.02.17.21.12.39;  author bart;  state Exp;
branches ;
next     36.67;

36.67
date     89.02.17.21.10.51;  author bart;  state Exp;
branches ;
next     36.66;

36.66
date     89.02.17.21.09.00;  author bart;  state Exp;
branches ;
next     36.65;

36.65
date     89.02.16.16.03.36;  author bart;  state Exp;
branches ;
next     36.64;

36.64
date     89.02.16.15.37.44;  author bart;  state Exp;
branches ;
next     36.63;

36.63
date     89.02.16.15.05.28;  author bart;  state Exp;
branches ;
next     36.62;

36.62
date     89.02.16.10.08.02;  author bart;  state Exp;
branches ;
next     36.61;

36.61
date     89.02.15.16.00.27;  author bart;  state Exp;
branches ;
next     36.60;

36.60
date     89.02.15.13.29.55;  author bart;  state Exp;
branches ;
next     36.59;

36.59
date     89.02.15.13.06.29;  author bart;  state Exp;
branches ;
next     36.58;

36.58
date     89.02.15.10.29.14;  author bart;  state Exp;
branches ;
next     36.57;

36.57
date     89.02.14.18.22.18;  author bart;  state Exp;
branches ;
next     36.56;

36.56
date     89.02.14.10.12.36;  author bart;  state Exp;
branches ;
next     36.55;

36.55
date     89.02.13.18.04.56;  author bart;  state Exp;
branches ;
next     36.54;

36.54
date     89.02.11.12.56.15;  author bart;  state Exp;
branches ;
next     36.53;

36.53
date     89.02.11.12.28.15;  author bart;  state Exp;
branches ;
next     36.52;

36.52
date     89.02.11.10.53.46;  author bart;  state Exp;
branches ;
next     36.51;

36.51
date     89.02.10.11.58.14;  author bart;  state Exp;
branches ;
next     36.50;

36.50
date     89.02.02.13.47.07;  author bart;  state Exp;
branches ;
next     36.49;

36.49
date     89.02.02.10.43.00;  author bart;  state Exp;
branches ;
next     36.48;

36.48
date     89.02.01.17.52.17;  author bart;  state Exp;
branches ;
next     36.47;

36.47
date     89.01.31.18.43.37;  author bart;  state Exp;
branches ;
next     36.46;

36.46
date     89.01.31.15.38.41;  author bart;  state Exp;
branches ;
next     36.45;

36.45
date     89.01.30.18.47.28;  author bart;  state Exp;
branches ;
next     36.44;

36.44
date     89.01.25.14.36.47;  author bart;  state Exp;
branches ;
next     36.43;

36.43
date     89.01.24.15.37.49;  author bart;  state Exp;
branches ;
next     36.42;

36.42
date     89.01.24.14.46.27;  author bart;  state Exp;
branches ;
next     36.41;

36.41
date     89.01.24.11.37.36;  author bart;  state Exp;
branches ;
next     36.40;

36.40
date     89.01.23.11.32.39;  author bart;  state Exp;
branches ;
next     36.39;

36.39
date     89.01.19.17.28.06;  author bart;  state Exp;
branches ;
next     36.38;

36.38
date     89.01.18.13.54.05;  author bart;  state Exp;
branches ;
next     36.37;

36.37
date     89.01.17.16.31.16;  author bart;  state Exp;
branches ;
next     36.36;

36.36
date     89.01.12.16.14.28;  author bart;  state Exp;
branches ;
next     36.35;

36.35
date     88.11.14.10.09.12;  author bart;  state Exp;
branches ;
next     36.34;

36.34
date     88.10.21.19.26.50;  author bart;  state Exp;
branches ;
next     36.33;

36.33
date     88.10.21.12.00.10;  author bart;  state Exp;
branches ;
next     36.32;

36.32
date     88.10.20.13.07.00;  author bart;  state Exp;
branches ;
next     36.31;

36.31
date     88.10.20.11.51.06;  author bart;  state Exp;
branches ;
next     36.30;

36.30
date     88.09.19.20.42.42;  author dale;  state Exp;
branches ;
next     36.29;

36.29
date     88.10.19.16.47.16;  author bart;  state Exp;
branches ;
next     36.28;

36.28
date     88.10.19.16.10.01;  author bart;  state Exp;
branches ;
next     36.27;

36.27
date     88.10.18.17.44.10;  author bart;  state Exp;
branches ;
next     36.26;

36.26
date     88.10.18.15.21.05;  author bart;  state Exp;
branches ;
next     36.25;

36.25
date     88.10.17.15.08.13;  author bart;  state Exp;
branches ;
next     36.24;

36.24
date     88.09.11.17.35.41;  author bart;  state Exp;
branches ;
next     36.23;

36.23
date     88.08.12.13.18.58;  author bart;  state Exp;
branches ;
next     36.22;

36.22
date     88.08.10.14.59.47;  author bart;  state Exp;
branches ;
next     36.21;

36.21
date     88.08.10.11.51.16;  author bart;  state Exp;
branches ;
next     36.20;

36.20
date     88.08.10.11.43.05;  author bart;  state Exp;
branches ;
next     36.19;

36.19
date     88.08.07.16.50.11;  author bart;  state Exp;
branches ;
next     36.18;

36.18
date     88.09.01.11.17.07;  author bart;  state Exp;
branches ;
next     36.17;

36.17
date     88.09.01.09.52.14;  author bart;  state Exp;
branches ;
next     36.16;

36.16
date     88.08.26.17.09.18;  author bart;  state Exp;
branches ;
next     36.15;

36.15
date     88.08.25.13.37.41;  author bart;  state Exp;
branches ;
next     36.14;

36.14
date     88.08.08.17.48.47;  author bart;  state Exp;
branches ;
next     36.13;

36.13
date     88.07.26.17.08.26;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     88.07.26.16.52.04;  author bart;  state Exp;
branches ;
next     36.11;

36.11
date     88.07.25.14.18.48;  author bart;  state Exp;
branches ;
next     36.10;

36.10
date     88.07.25.11.18.26;  author bart;  state Exp;
branches ;
next     36.9;

36.9
date     88.07.23.17.08.21;  author bart;  state Exp;
branches ;
next     36.8;

36.8
date     88.07.14.13.31.38;  author dale;  state Exp;
branches ;
next     36.7;

36.7
date     88.07.05.14.10.30;  author dale;  state Exp;
branches ;
next     36.6;

36.6
date     88.06.23.13.23.10;  author dale;  state Exp;
branches ;
next     36.5;

36.5
date     88.06.13.09.44.38;  author bart;  state Exp;
branches ;
next     36.4;

36.4
date     88.05.17.22.46.48;  author dale;  state Exp;
branches ;
next     36.3;

36.3
date     88.05.12.14.51.35;  author dale;  state Exp;
branches ;
next     36.2;

36.2
date     88.03.11.17.06.40;  author dale;  state Exp;
branches ;
next     36.1;

36.1
date     88.03.10.16.11.24;  author dale;  state Exp;
branches ;
next     ;


desc
@@


39.75
log
@removed failure check
@
text
@/******************************************************************************
*
*	$Id: cpwrup.c,v 39.74 93/04/21 18:39:01 spence Exp Locker: chrisg $
*
******************************************************************************/

/* graphics  kernel routines */
#include <exec/types.h>
#include <exec/nodes.h>
#include <exec/lists.h>
#include <exec/interrupts.h> 
#include <exec/memory.h>
#include <exec/libraries.h>
#include <exec/semaphores.h>
#include <exec/execbase.h>
#include <hardware/custom.h>
#include <hardware/blit.h>
#include <hardware/dmabits.h>
#include <hardware/intbits.h>
#include "/gfxbase.h"
#include "/macros.h"
#include "/copper.h"
#include "/displayinfo.h"
#include "/cia8520.h"
/*#include "/sane_names.h"*/
#include "/d/d.protos"
#include "/displayinfo_internal.h"
#include "/gfx.h"
#include "/view.h"
#include "/display.h"
#include "/gfxpragmas.h"
#include "/vp_internal.h"
#include "gfxprivate.h"
#include "c.protos"
#include <internal/librarytags.h>
#include <pragmas/utility_pragmas.h>
#include <pragmas/exec_pragmas.h>


/*#define GBDEBUG*/		/* sets GfxBase->Debug = 1 */
/*#define DEBUG*/
/*#define RAMDEBUG*/
/*#define BADFMODE*/

#ifdef DEBUG 
#define D(x) 	x
#else
#define D(x) 	;
#endif

#ifdef BADFMODE
#define FMODE io->pad3b[0]
#define FMODE2 io->fmode
#else
#define FMODE io->fmode
#endif

#define ALERTGFXNOMEMMSPC 0x82010001

extern struct Custom custom;
extern struct CIA8520 ciaa;
extern struct CIA8520 ciab;

extern USHORT   vhposr;

extern VERSION, REVISION;
extern char gfx_lib_name[];
#ifdef RAMDEBUG
UBYTE	Debug;
#endif


int BltBitMap(),BltTemplate(),ClearEOL(),ClearScreen();
int TextLength() , SetFont();

int Text();

int OpenFont(),CloseFont(),FontExtent(),WeighTAMatch();
int ExtendFont(),StripFont();
int AskSoftStyle(),SetSoftStyle();

int AddFont(),RemFont(),AskFont();

int AddBob(),AddVSprite(),DoCollision(),DrawGList();
int InitGels(),InitMasks(),RemIBob(),RemVSprite();
int SetCollision(),SortGList(),AddAnimOb(),Animate();
int GetGBuffers(),InitGMasks();
int DrawEllipse();

int LoadRGB4(),InitRastPort(),InitVPort(),MrgCop();
int LoadView(),WaitBlit(),SetRast();
int Move(),Draw();
int AreaMove(),AreaDraw(),AreaEnd(),AreaEllipse();
int WaitTOF(),QBlit();
int InitArea();
int SetRGB4(),QBSBlit();
int BltClear();
int BltPattern();
int ReadPixel(),WritePixel();
int Flood();
int PolyDraw();
int SetAPen(),SetBPen(),SetDrMd(),InitView();
int VBeamPos();
int InitBitMap();
int WaitBOVP();
int GetSprite(),FreeSprite(),ChangeSprite(),MoveSprite();

int LockLayerRom(),UnlockLayerRom();

int OwnBlitter(),DisownBlitter();

int InitTmpRas();

extern int (*vbasm)(),(*bltasm)(),(*timasm)();

int OpenGfx(),CloseGfx(),ExpungeGfx(),ExtFuncGfx();

int AllocRaster(),FreeRaster();
int AndRectRegion(),OrRectRegion(),XorRectRegion();
int NewRegion(),ClearRectRegion(),ClearRegion(),DisposeRegion();

int FreeVPortCopLists(),FreeCopList();
int FreeCprList();

int BltRastPort();
int GetColorMap(),FreeColorMap();
int	GetRGB4();
int ScrollVPort();
int FreeGBuffers();
int BltBitMapRastPort();

int BltMaskRastPort(); /* bart - 1.28.86 */

int OrRegionRegion(),XorRegionRegion(),AndRegionRegion();

int SetRGB4CM();
int GetOPen();

int AttemptLockLayerRom();

int BitMapScale(),ScalerDiv();
int TextExtent(),TextFit();

long VideoControl();

int ReadPixelLine8(),  WritePixelLine8();
int ReadPixelArray8(), WritePixelArray8();
int FindColor();

int ReleasePen();
int ObtainPen();
int AttachPalExtra();
int ObtainBestPenA();
int SetRGB32();
int GetAPen(), GetBPen(), GetDrMd();
int LoadRGB32();
int SetABPenDrMd();
int GetRGB32();
int AlwaysReturnsZero();
int AllocBitMap();
int FreeBitMap();
int GetExtSpriteA();
int ChangeVPBitMap();
int GetBitMapAttr();
int AllocDBufInfo();
int FreeDBufInfo();
int SetOutlinePen(), SetWriteMask(), SetMaxPen();
int SetRGB32CM();
int AllocSpriteDataA();
int ChangeExtSpriteA();
int FreeSpriteData();
int WriteChunkyPixels();

void defras();

struct Resident *FindResident();

/*struct DisplayInfoRecord *find_info();*/

void db_avail(struct DisplayInfoRecord *record)
{
    BOOL HRDenise, Lisa;

    HRDenise = (GBASE->ChipRevBits0 & GFXF_HR_DENISE);
    Lisa = (GBASE->ChipRevBits0 & GFXF_AA_LISA);

    {
		struct RawDisplayInfo *dinfo;

		/* not vanilla */

		if (dinfo  = FindTagItem(DTAG_DISP,&record->rec_Tag))
		{
			struct RawMonitorInfo *minfo;
			struct RawDimensionInfo *dims;

			record->rec_Control = dinfo->ModeID;

			/* We may be coming through here from SetChipRev(). So, if
			 * we are setting to 'A' mode, we may have been here initially
			 * when the machine thought it was ECS. Therefore, set the
			 * DI_AVAIL_NOCHIPS flag first, and only clear it
			 * in the appropriate place.
			 */
			if (dinfo->PropertyFlags & (DIPF_IS_ECS | DIPF_IS_AA))
			{
				dinfo->NotAvailable |= DI_AVAIL_NOCHIPS;
			}

			if (HRDenise && (dinfo->PropertyFlags & DIPF_IS_ECS))
			{
				dinfo->NotAvailable &= ~DI_AVAIL_NOCHIPS;
			}
			if (Lisa && (dinfo->PropertyFlags & DIPF_IS_AA))
			{
				/* Assume we can clear the NOCHIPS flag */
				dinfo->NotAvailable &= ~DI_AVAIL_NOCHIPS;

				/* but if we don't have the badwidth for the HAM or EHB... */
				if (dinfo->ModeID & (HAM | EXTRA_HALFBRITE))
				{
					if (! (((dinfo->ModeID & SUPERHIRES) && (GBASE->MemType == BANDWIDTH_4X))
					    ||
					   ((dinfo->ModeID & HIRES) && GBASE->MemType) 
					    ||
					    ((dinfo->ModeID & (HIRES | SUPERHIRES)) == NULL)))
					{
						dinfo->NotAvailable |= DI_AVAIL_NOCHIPS;
					}
				}
			}

			if((record) && (dims = FindTagItem(DTAG_DIMS,&record->rec_Tag)))
			{
				record->rec_ClipOScan.MinX = 
					dims->VideoOScan.MinX / dinfo->Resolution.x;
				record->rec_ClipOScan.MaxX = 
					dims->VideoOScan.MaxX / dinfo->Resolution.x;
				record->rec_ClipOScan.MinY = 
					dims->VideoOScan.MinY / dinfo->Resolution.y;
				record->rec_ClipOScan.MaxY = 
					dims->VideoOScan.MaxY / dinfo->Resolution.y;
			}

			if(GBASE->system_bplcon0 & GENLOCK_VIDEO)
			{
				if(!(dinfo->PropertyFlags & DIPF_IS_GENLOCK))
				{
					dinfo->NotAvailable |= DI_AVAIL_NOTWITHGENLOCK;
				}
			}

			if((record = (struct DisplayInfoRecord *) record->rec_Node.rcn_Parent)
			&& (minfo  = FindTagItem(DTAG_MNTR,&record->rec_Tag)))
			{
				if(minfo->Mspc) dinfo->NotAvailable &= ~DI_AVAIL_NOMONITOR;
			}
		}
    }
}

void all_db_avail(void)
{
    ULONG ID = INVALID_ID;
    struct DisplayInfoRecord *record = GBASE->DisplayInfoDataBase, *head;

    while ((ID = NextDisplayInfo(ID)) != INVALID_ID)
    {
	if (head = (struct DisplayInfoRecord *)FindDisplayInfo(ID))
	{
		db_avail(head);
	}
    }
}

void activate_mspc( monitor, mspc )
ULONG monitor;
struct MonitorSpec *mspc;
{
    ULONG ID = INVALID_ID;
    struct RawMonitorInfo querymonitor;

    while( ( ID = NextDisplayInfo( ID ) ) != INVALID_ID )
    {
	if( ( ID & ~0xFFFF ) == ( monitor & ~0xFFFF ) )
	{
	    struct DisplayInfoRecord *record = FindDisplayInfo( ID );
	
	    if(record)
	    {
		int numbytes = 0;
		struct RawMonitorInfo *chunk = &querymonitor;

		if(numbytes = 
		   (int)GetDisplayInfoData(record, (UBYTE *)chunk, sizeof(*chunk), DTAG_MNTR, ID))
		{
		    chunk->Mspc = mspc;
		    if(SetDisplayInfoData(record, (UBYTE *)chunk,numbytes,DTAG_MNTR,ID)) break;
		}
	    }
	}
    }
}

void *vectbl[] =
{
/*exec21*/  OpenGfx,    /* openlib */
	    CloseGfx,   /* close lib */
	    ExpungeGfx, /* initlib */
	    ExtFuncGfx, /* expunge lib */

    BltBitMap,BltTemplate,ClearEOL,ClearScreen,
    TextLength,Text,SetFont,
    OpenFont,CloseFont,AskSoftStyle,SetSoftStyle,

	/* 16 slots for gels */
    AddBob,AddVSprite,DoCollision,DrawGList,
    InitGels,InitMasks,RemIBob,RemVSprite,
    SetCollision,SortGList,AddAnimOb,Animate,
    GetGBuffers,InitGMasks,
    DrawEllipse,AreaEllipse,
	/* rest of graphics */
	LoadRGB4,InitRastPort,InitVPort,MrgCop,
	MakeVPort,LoadView,WaitBlit,SetRast,
	Move,Draw,
	AreaMove,AreaDraw,AreaEnd,
	WaitTOF,QBlit,
	InitArea,
	SetRGB4,QBSBlit,
	BltClear,
	RectFill,BltPattern,
	ReadPixel,WritePixel,
	Flood,PolyDraw,
	SetAPen,SetBPen,SetDrMd,InitView,
	CBump,CMove,CWait,VBeamPos,
	InitBitMap,
	ScrollRaster,
	WaitBOVP,
	GetSprite,FreeSprite,ChangeSprite,MoveSprite,
	LockLayerRom,UnlockLayerRom,
	SyncSBitMap,CopySBitMap,
	OwnBlitter,DisownBlitter,
	InitTmpRas,
	AskFont,AddFont,RemFont,
	AllocRaster,FreeRaster,
	AndRectRegion,OrRectRegion,
	NewRegion,ClearRectRegion,ClearRegion,DisposeRegion,
	FreeVPortCopLists,FreeCopList,
	BltRastPort,
	XorRectRegion,
	FreeCprList,
	GetColorMap,FreeColorMap,GetRGB4,
	ScrollVPort,
	UCopperListInit,
    	FreeGBuffers,
    	BltBitMapRastPort,
	OrRegionRegion,
	XorRegionRegion,
	AndRegionRegion,
	SetRGB4CM,
	BltMaskRastPort,
	ReleasePen,
	ObtainPen,
	AttemptLockLayerRom,
	GfxNew,GfxFree,GfxAssociate,
	BitMapScale,ScalerDiv,
	TextExtent,TextFit,
	GfxLookUp,
	VideoControl,
	OpenMonitor,
	CloseMonitor,
	FindDisplayInfo, 
	NextDisplayInfo, 
	AddDisplayInfo,     /* graphics private */
	AddDisplayInfoData, /* graphics private */
	SetDisplayInfoData, /* graphics private */
	GetDisplayInfoData, 
	FontExtent,
	ReadPixelLine8,
	WritePixelLine8,
	ReadPixelArray8,
	WritePixelArray8,
	GetVPModeID, 
	ModeNotAvailable,
	WeighTAMatch,
	EraseRect,
	ExtendFont,
	StripFont,
	CalcIVG,
	AttachPalExtra,
	ObtainBestPenA,
	AlwaysReturnsZero,
	SetRGB32,
	GetAPen,
	GetBPen,
	GetDrMd,
	GetOPen,
	LoadRGB32,
	SetChipRev,
	SetABPenDrMd,
	GetRGB32,
	AlwaysReturnsZero,
	SetDefaultMonitor,
	AllocBitMap,
	FreeBitMap,
	GetExtSpriteA,
	CoerceMode,
	ChangeVPBitMap,
	ReleasePen,
	ObtainPen,
	GetBitMapAttr,
	AllocDBufInfo,
	FreeDBufInfo,
	SetOutlinePen,
	SetWriteMask,
	SetMaxPen,
	SetRGB32CM,
	ScrollRasterBF,
	FindColor,
	AlwaysReturnsZero,
	AllocSpriteDataA,
	ChangeExtSpriteA,
	FreeSpriteData,
	SetRPAttrA,
	GetRPAttrA,
	BestModeIDA,
	WriteChunkyPixels,
	AlwaysReturnsZero,
	AlwaysReturnsZero,
	AlwaysReturnsZero,
	(int *)(-1)
};

UBYTE bwshifts[] = {0, 1, 1, 2};

extern UWORD StrtFetchMasks[][];
extern UWORD StopFetchMasks[][];
extern UWORD Overrun[][];
extern UWORD RealStops[][];
extern APTR  ProgData;

struct MonitorSpec *new_monitorspec(GB,flags,name)
struct GfxBase *GB;
UWORD flags;	
STRPTR name;
{
    struct MonitorSpec *mspc = (struct MonitorSpec *) GfxNew(MONITOR_SPEC_TYPE);
    /* initialize monitorspec and add to list */
    if(mspc)
    {
	mspc->ms_Node.xln_Library = (LONG)GB;
        mspc_init(GB, mspc, flags); /* assembly interface */
	mspc->ms_Node.xln_Name = name;

    }
    return(mspc);
}

extern STRPTR rev_name;

#define CCLKS(x) ((x)->total_colorclocks)

#define MAX_DENISE(x) (((CCLKS(x)+1)<<1)+1)

#define BPLPT 0xe0
#define BPLCON0 0x100
#define BPLCON3 0x106
#define COLOR 0x180
#define REG_FMODE 0x1fc
#define DIWSTRT 0x8e
#define DIWSTOP 0x90
#define DIWHIGH 0x1e4
#define DDFSTRT 0x92
#define DDFSTOP 0x94
#define BPLCON2 0x104
#define COPJMP2 0x8a
#define NOP	0x1fe

UWORD copinit_header[]= {
	/* first one just a place saver for new chips */
						 COPPER_MOVE|BPLPT,0,
	/* Now we need place for five more moves -- (in diagstrt) for colours */
						 COPPER_MOVE|BPLCON0,0x200,
						 COPPER_MOVE|BPLCON3,0xc00,
						 COPPER_MOVE|COLOR,
};

UWORD copinit_mid_ecs[]={
	COPPER_MOVE|NOP,0xc00,
	/* will become BPLCON3 in update_top_colour() after enlightenment */
	/* Now, set the default bandwidth to 1x */
	COPPER_MOVE|REG_FMODE,0,
	/* Open a display window of one line ... */
	COPPER_MOVE|DIWSTRT,0x0181,
	COPPER_MOVE|DIWSTOP,0x0281,
	COPPER_MOVE|DIWHIGH,0,
	/* And a single fetch to hide the Alice bug. This removes the blank
	   bar at the RHS for the 16 and 32 fetch cycles when I set DDFSTOP to
	   0xd8 */
	COPPER_MOVE|DDFSTRT,0x18,
	COPPER_MOVE|DDFSTOP,0x20,
	/* Now set bplcon2 */
	COPPER_MOVE|BPLCON2,0x24,
};

UWORD copinit_mid_a[]={
	COPPER_MOVE|NOP,0xc00,
	COPPER_MOVE|NOP,0x0,
	COPPER_MOVE|NOP,0x0,
	COPPER_MOVE|NOP,0x0,
	COPPER_MOVE|NOP,0x0,
	COPPER_MOVE|NOP,0x0,
	COPPER_MOVE|NOP,0x0,
	COPPER_MOVE|NOP,0x0,
};


UWORD copinit_end[]={
				COPPER_WAIT | TOPLINE,0xFFFE,  /* wait for first line */
				/* just a place saver here for real hbstop */
				COPPER_WAIT | TOPLINE,0xFFFE,  /* wait for first line */

	/* the above wait will allow the vertical blank routine time to set
	   up cop2ptr to continue the refresh of the display */

				COPPER_MOVE|COPJMP2,0,
				COPPER_MOVE|BPLCON3,0x0c00,
				0xffff,0xfffe /* wait forever */
};

void cpwrup()
{
    register int i;
    register short *a;
    register struct Custom *io = &custom;
	long WC_ZERO=0;
	UBYTE	agnus_chip_id;
	UBYTE	denise_chip_id;


    /* rectify the library node */

    ((struct Library *)GBASE)->lib_Node.ln_Type = NT_LIBRARY;
    ((struct Library *)GBASE)->lib_IdString = &rev_name;

	agnus_chip_id = (io->vposr>>8) & 0x7f;

/********************************************************************************
*
* This code was sometimes failing to recognise a non-ECS denise properly on
* an A1000. It has been replaced with an assembly function (in misc.asm)
* - For 2.05 A300 build, spence Wed Oct 23 10:33:35 1991
*
*	denise_chip_id= (io->deniseid) & 0xff;
*	for (i = 0; i < 16 ; i++)
*		if ( denise_chip_id != (io->deniseid & 0xff) )
*		{
*			denise_chip_id = -1;
*			break;
*		}
*********************************************************************************/

	denise_chip_id = get_denise_id();

#ifdef RAMDEBUG
	kprintf("Debug at %lx\n",&Debug);
	Debug = 0;
#endif

    /* initialize parallel port directions */
    /* set bit plane data registers to zero */
	for(i=0;i<6;i++)    io->bpldat[i] = 0;

    /*
    c = (struct GfxBase *)MakeLibrary(vectbl
				    ,0,0,sizeof(struct GfxBase),NULL);
    */

    /* initialize utility library for hooks and tags */

    GBASE->UtilBase=TaggedOpenLibrary(OLTAG_UTILITY);

/* What type of chips and memory do we have? 
 * This determines what FMode we use as the
 * system default, and the display modes that are available
 */

    if (agnus_chip_id & 0x20)	/* agnus hr bit set ? */
	GBASE->ChipRevBits0 |= GFXF_HR_AGNUS;
    else
	GBASE->DisplayFlags |= LPEN_SWAP_FRAMES;

    if (!(denise_chip_id & 0x02))
	GBASE->ChipRevBits0 |= GFXF_HR_DENISE;

    if (!(denise_chip_id & 0x04))
    {
    	/* we have a Lisa. Set it's 'mirror' bit to show we have one,
    	 * but it's features aren't enabled until GFXF_AA_LISA is set
    	 * (by SetChipRev()).
    	 * This is so that we can come up in ECS-Denise mode, but not
    	 * have to bit-swizzle the colours for SuperHires and VGA modes.
    	 */
    	GBASE->ChipRevBits0 |= GFXF_AA_MLISA;

	/* Set up bplcon3 and bplcon4, in case we are running as A or ECS */
	io->bplcon3 = 0x0c00;
	io->bplcon4 = 0x0011;

	/* Also, set the real MemType. AllocBitMap() uses this, as does
	 * Intuition when setting the default sprites.
	 */
    	GBASE->BoardMemType = (((~(io->deniseid)) & 0x0300) >> 8);

	/* Show which bugs are in the Chips. These bits may be cleared by
	 * a SetPatch that comes with a new chip set.
	 */
	 GBASE->Bugs = (BUG_ALICE_LHS | BUG_VBLANK | BUG_ALICE_LHS_PROG);
    }

    /* Hang some data off GfxBase (used by MakeVP() - V39) */
    GBASE->bwshifts = (UBYTE *)&bwshifts;
    GBASE->StrtFetchMasks = (UWORD *)&StrtFetchMasks;
    GBASE->StopFetchMasks = (UWORD *)&StopFetchMasks;
    GBASE->Overrun = (UWORD *)&Overrun;
    GBASE->RealStops = (WORD *)&RealStops;
    GBASE->arraywidth = 2;
    GBASE->ProgData = &ProgData;

    /* Set this up for SetChipRevs() and BootMenu */
    GBASE->WantChips = SETCHIPREV_BEST;

    GBASE->BlitLock = -1;       /* unlocked */
    GBASE->BlitNest = -1;
    NewList(&GBASE->BlitWaitQ);
    NewList(&GBASE->TOF_WaitQ);

    GBASE->LibNode.lib_Node.ln_Name = gfx_lib_name;
	GBASE->LibNode.lib_Version = &VERSION;
	GBASE->LibNode.lib_Revision = &REVISION;
	GBASE->LibNode.lib_Flags |= LIBF_SUMUSED|LIBF_CHANGED;
	GBASE->LibNode.lib_OpenCnt = 1;	/* never expunge */

#ifdef DEBUG
	kprintf("call add library\n");
#endif
	AddLibrary(GBASE);

	GBASE->ColorMask=0xf0000000;	/* will be reset by SetChipRevBits if AA */
	GBASE->SpriteWidth=1;	/* cg - initalize sprite width for AA */
	GBASE->DefaultSpriteWidth=1;
	GBASE->SpriteFMode=0;
	a=(short *)AllocMem(sizeof(struct copinit),MEMF_PUBLIC|MEMF_CHIP|MEMF_CLEAR);
	GBASE->SimpleSprites = (struct SimpleSprite **) AllocMem(sizeof(int *)*8,MEMF_CLEAR);
	/*GBASE->SimpleSpriteViewPorts = AllocMem(sizeof(int *)*8,MEMF_CLEAR);*/
	GBASE->copinit = (struct copinit *) a;

	a = GBASE->copinit->vsync_hblank;
	io->dmacon = BITCLR|DMAF_COPPER;  /* turn copper off */
	io->cop1lc = (UWORD *)a;

/* initial copper start up for sprites */
/* and set dwstart to end of display */
/* 1 move.w to dwstart */
/* 8 move.l to ptrs */
/* wait for vbsrvc */
/* jmp to next copper list  ( 1 moves )*/
/* dummy copper instruction */


/* each sprite is initially pointed to this sprite information */
/* it tells the sprite to wait till the end of the screen */
    /* initialize sprite machine */
    /* set up copper list to initialize all sprites to wait till end of */
    /* screen, then I can play with the control registers and ptrs */

	a = GBASE->copinit->vsync_hblank;

	a=CopyWords(copinit_header,a,7);
	*a++ = ((struct ExecBase *)(SysBase))->ex_Pad0;   /* lets show grey for default on ECS too! */
//	*a++=COPPER_MOVE|(0x1FE&(int)(&io->bplcon3)); *a++= 0xe00;
//	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->color[0]));

	/* Put two NOPs here for now. These will get changed to a BPLCON3 and COLOR0
	 *  the first time update_top_color() is called in AA mode.
	 */
	*a++ = COPPER_MOVE|0x1FE; *a++= 0xe00;
	*a++ = COPPER_MOVE|0x1FE;
	*a++ = ((struct ExecBase *)(SysBase))->ex_Pad0;		/* exec sets boot color now! */

	{
		UWORD *src = copinit_mid_a;
		if (GBASE->ChipRevBits0 & GFXF_HR_DENISE)
		{
			src = copinit_mid_ecs;
		}
		a=CopyWords(src, a, 16);
	}

/*	a = GBASE->copinit->sprstrtup;*/

	for(i=0;i<8;i++)
	{
		*a++=COPPER_MOVE|(REGNUM(spr)+(i<<3));
		*a++=0;
	}

	for(i=0;i<8;i++)
	{
	    /* initialize the comparators for the sprites */
	    io->spr[i].pos = 0xFE00;
	    io->spr[i].ctl = 0xFF00;
	    *a++ = COPPER_MOVE|(0x1FE&(int)(&io->sprpt[i]));    /* upper bits */
	    *a++ = TOBB((long)(GBASE->copinit->sprstop) >> 16);
	    *a++ = COPPER_MOVE|(0x1FE&(int)(&io->sprpt[i]))+2;  /* low bits */
	    *a++ = TOBB((long)(GBASE->copinit->sprstop));
	};

	GBASE->TopLine = TOPLINE;
	a=CopyWords(copinit_end,a,10);


	io->cop2lc =GBASE->copinit->wait_forever;		/* point at wait forever */


    /* the sprite processors begin to pick up the control information at
       line 20 (0x14) of the vertical beam ctr */
    /* after that time the ptrs and control registers may be modified to
       position sprites on the screen, by passing the normal control stuff
       in the hardware sprite data structure */


    /* power up blitter safely */
/*      abo_blit();*/
/*      abo_blit();*/
    io->bltcon0 = WC_ZERO;
    io->bltcon1 = WC_ZERO;
    io->bltsize = (1<<6)|1;
    io->dmacon = BITSET|DMAF_BLITTER;
    io->bltsize = (1<<6)|1;

    if(GBASE->ChipRevBits0 & GFXF_HR_AGNUS)
    {
	io->bltsizv = 0x0000; /* hygiene -- bart */
    }

    /* add task to kernel interrupt server */
    GBASE->vbsrv.is_Code = (void *) &vbasm;
    GBASE->vbsrv.is_Data = (APTR) GBASE;
    GBASE->vbsrv.is_Node.ln_Pri = 10;
    GBASE->vbsrv.is_Node.ln_Name = gfx_lib_name;

#ifdef DEBUG
	kprintf("call addintsrv\n");
	/*Debug();*/
#endif

    /* GBASE->LOFlist = GBASE->copinit->sprstrtup+2*(32+6) */;
    GBASE->SHFlist = GBASE->LOFlist = GBASE->copinit->wait_forever;
    AddIntServer(INTB_VERTB,&GBASE->vbsrv);

#ifdef DEBUG
	kprintf("return from addintsrv\n");
#endif

    GBASE->bltsrv.is_Code = (void *) &bltasm;
    GBASE->bltsrv.is_Data = (APTR)(GBASE);
    GBASE->bltsrv.is_Node.ln_Name = gfx_lib_name;
#ifdef DEBUG
	kprintf("call setintvector\n");
#endif
    SetIntVector(INTB_BLIT,&GBASE->bltsrv);
#ifdef DEBUG
	kprintf("return from setintvector\n");
#endif

    GBASE->timsrv.is_Code = (void *)&timasm;
    GBASE->timsrv.is_Data = (APTR) GBASE;
    GBASE->timsrv.is_Node.ln_Pri = 10;
    GBASE->timsrv.is_Node.ln_Name = gfx_lib_name;

    /* initialize ciaa for me */
	/* the Open Resource must NOT fail */

    GBASE->cia = (long *)OpenResource("ciab.resource");

#ifdef DEBUG
    kprintf("now call EnaICRB cia=%lx\n",GBASE->cia);
#endif
    ADDICRVECTOR(GBASE->cia,2,&GBASE->timsrv);
    ciab.crb |= CIA8520CRBF_ALARM;
    ciab.todhi = 0; /* set hi byte of alarm to 0 */

#ifdef DEBUG
    kprintf("enable interupts\n");
#endif

    Disable();
    GBASE->system_bplcon0 = get_genloc(io) | COLORON;
    GBASE->copinit->diagstrt[1] |= GBASE->system_bplcon0;	/* CG: Poke copinit. Genlock fix for V40. */

    /* initialize to standard defaults */
    GBASE->DisplayFlags |= ((GBASE->system_bplcon0 & GENLOC)|get_pal(agnus_chip_id));
    Enable();

    /* get some memory for association hash table */
    GBASE->hash_table = (void *) AllocMem((HASHTABLE_NUMENTRIES * 4),MEMF_CLEAR);
    /* Initialise the semaphore around GfxAsociate/GfxLookUp/GfxFree.
     * Why did this not happen until 3.01???
     */
    GBASE->HashTableSemaphore = (struct SignalSemaphore *)AllocMem(sizeof(struct SignalSemaphore),0);
    InitSemaphore(GBASE->HashTableSemaphore);


    {
	    struct ExecBase *eb;
	    eb = (struct ExecBase *) GBASE->ExecBase;

	    if (GBASE->DisplayFlags & PAL)	eb->VBlankFrequency = 50;
	    else			eb->VBlankFrequency = 60;
    }
    GBASE->MinDisplayColumn = STANDARD_DENISE_MIN; /* bart -- min left clip */
    GBASE->MaxDisplayColumn = STANDARD_DENISE_MAX; /* bart -- max right clip */

    GBASE->NormalDisplayColumns = 640;
    /* MicrosPerLine time 256 */
    GBASE->MicrosPerLine = 16285;		/* approximately */

	/* single thread access to ActiView hardware copper list */

	GBASE->ActiViewCprSemaphore = (struct SignalSemaphore *) 
				  AllocMem(sizeof(struct SignalSemaphore),0);

	InitSemaphore(GBASE->ActiViewCprSemaphore);

	/* display database initialization relys on last chance memory */
	/* to prevent memory fragmenation in early stages of boot      */

	GBASE->LCMptr = (void *) AllocMem(MAXBYTESPERROW,MEMF_CHIP);
	GBASE->LastChanceMemory = (struct SignalSemaphore *)
				AllocMem(sizeof(struct SignalSemaphore),0);
	InitSemaphore(GBASE->LastChanceMemory);

	/* ok. now open the display database */ 
	GBASE->DisplayInfoDataBase = db_startup();

	/* bart -- mspc */
	NewList(&GBASE->MonitorList);

	GBASE->MonitorListSemaphore = (struct SignalSemaphore *) 
				  AllocMem(sizeof(struct SignalSemaphore),0);

	InitSemaphore(GBASE->MonitorListSemaphore);

	/* initialize default monitorspec and add to list */

	gfx_SetDefaultMonitor(((GBASE->DisplayFlags & PAL) ? (PAL_MONITOR_ID >> 16) : (NTSC_MONITOR_ID >> 16)));

    defras();
#ifdef DEBUG
    kprintf("set dma on\n");
#endif

    defras();

    io->dmacon = BITSET|DMAF_COPPER|DMAF_RASTER|DMAF_SPRITE;

#ifdef DEBUG
    kprintf("call SFInit(%lx)\n",c);
#endif
    SFInit(GBASE);      /* initialize fonts */
#ifdef DEBUG
    kprintf("now return\n");
    Debug();
#endif

    /* open the default monitor */ 
    {
	struct MonitorSpec *mspc;

	mspc = OpenMonitor(NULL,NULL); /* new interface */
	
	activate_mspc( ( DEFAULT_MONITOR_ID ), mspc );

	/* guarantee that the default monitor is available before returning */ 
	all_db_avail(); 
    }
	TestForChunkyHardware();
    io->intena = INTF_BLIT;	/* turn this cycle-sucking bitch off */
#ifdef GBDEBUG
    GBASE->Debug = 1;
#endif
}

void MakeLongFrame(void)
{
	register struct Custom *io;
	WORD vpos;

	/* This code ensures that the frame is Long. When switching from
	 * Lace to non-laced modes, the signal to enable toggling of
	 * LongFrame/ShortFrame is turned off, but the current frame could be
	 * short, thus leaving the system in a permanent ShortFrame mode.
	 */

	io = (struct Custom *)&custom;
	Disable();
	vpos = io->vhposr;
	while ((vpos & 0xff) >= 0x30)	/* a fairly unsafe area */
	{
		vpos = io->vhposr; /* avoid critical region */
	}
	/* the Vertical counts should not change between reading them and
	 * writing them back.
	 */
	io->vposw = 0x8000|io->vposr;
	Enable();
};

unsigned short beamconpal()
{
	if (GBASE->DisplayFlags & PAL)	return (0x20);
	else				return (0);
}

void newdefras(c,hr,vr)
struct GfxBase *c;
int hr,vr;
{
	register struct Custom *io;
	int x;
	int y;

	io = (struct Custom *)&custom;

	io->bplcon0 = 0;
	io->bplcon1 = 0;
	io->bplcon2 = 0x24;
#ifdef BADFMODE
	io->copcon = 2;	/* turn on CDANG bit - what a fuck up */
	FMODE2 = 0;
#endif
	FMODE = 0;

	x =  (hr*0x81)>>4;
	y =  (vr*0x2c)>>4;
	io->diwstrt = (y<<8) | (x & 0xff);

	x = (hr * 0xc1)>>4;
	y = (vr * 0xf4)>>4;
	io->diwstop = (y<<8)||(x & 0xff);

	io->ddfstrt = (0x38*hr)>>4;
	io->ddfstop = (0xd0*hr)>>4;

	MakeLongFrame();
}

void defras()
{
	struct Custom *io;

#ifdef DEBUG
    kprintf("defras(%lx)\n",c);
#endif
	io = (struct Custom *)&custom;
#ifdef BADFMODE
	io->copcon = 2;	/* turn on CDANG bit - what a fuck up */
	FMODE2 = 0;
#endif
	FMODE = 0;
	io->bplcon0 = (GBASE->system_bplcon0 & ~LACE); /* changed to zero bitplanes */
	io->bplcon1 = 0;
	io->bplcon2 = 0x24;
	io->bpl2mod = 0;
	io->bpl1mod = 0;
	io->diwstrt = 0x2c81;
	io->diwstop = 0xf4c1;
	io->ddfstrt = 0x38;
	io->ddfstop = 0xd0;

	/* stuff for new chips */
	io->beamcon0 = beamconpal();	/* disable most all new stuff */

	MakeLongFrame();
}

get_genloc(io)
struct Custom *io;
{
    int count;
    int pos;
    long	WC_ZERO=0;
    /* must be run while disabled */

    /*
	Mike's Genloc test:
	It is important that the test for GenLock is done in the
	active display area.  We need to make sure that no matter
	how slow the machine, the tests below will work.
    */
    while ((vbeampos() > 160) || (vbeampos() < 20));

    /*
	MKS:  The following is my new test for GENLOCK
	What needs to be done is as follows:  We need to
	turn on GenLock mode, wait until it takes effect,
	then check the beam position register to see if
	we are still clocking the custom chips.  The trick
	here is that with a genlock connected, the chips
	will still be clocked from outside but without a
	genlock connected, there will not be any clocking
	and the beam will seem to stop.

	Note that we wait for the beam to be within the
	nominal display area before we try this.  If we
	do not, we will end up getting bad/wrong readings.
	This was already done by the code above...
    */

    /*	First:  We need to turn on GENLOCK modes... */
    io->bplcon0 = (GENLOCK_AUDIO | GENLOCK_VIDEO);

    /*	Ok, we need to wait at least 2 horizontal scan lines in order */
    /*	for the genlock to take effect or not.  Since in worst case, */
    /*	a colour clock is 283ns and there are 160 on a line, we come */
    /*	out to 45280ns for a line.  Add in 15% for genlock timing error */
    /*	and multiply by 2 and we get 104144ns required wait. */
    /*  So, at about 280ns (or so) per chip read, we need 372 chip reads */
    pos=0xFF & DelayAndRead(&(vhposr),372);

    /*	So, in the above, we read the vhposr register a few times */
    /*	We know that this will take 104144ns  In addition, since */
    /*	this is part of the same chip, we know it will remain the */
    /*	same timing. */

    /*	Next, we need to wait for a minimum of 283ns plus the maximum */
    /*	legal error time on the genlock timing.  This means that */
    /*	we must wait 326ns which comes out to 1 chip read. */
    /*	Note that this is an extra CHIP read just to make sure we */
    /*	don't come in too early.. */
    count = vhposr;
    count = vhposr;	/* we need an *extra* read - the 1st read might have
    			 * happened on an edge */

    /*	Now the test below can check if the old position is the same */
    /*	as the new position or not... */

    if (pos == (vhposr & 0xFF))
    {
	/* test to see whether ciaa tod counter is safe for ciaa.device */
	/* if a2000 and jumper j300 tied to power supply, should be running */
	/* if a2000 and jumper j300 tied to vsync, will no longer be running */

	ciaa.todlow = ciaa.todmid = ciaa.todhi = 0;

	ciaa.cra  = CIA8520CRAF_RUNMODE;
	ciaa.talo = 0xFF;
	ciaa.tahi = 0xFF;
	
	while( (BYTE)ciaa.tahi < 0 )
	{
	    if( ciaa.todlow ) GBASE->DisplayFlags |= TODA_SAFE;
	}

	ciaa.cra  = NULL;

	io->bplcon0 = WC_ZERO;

	return(0);
    }

    return(GENLOCK_AUDIO | GENLOCK_VIDEO);
}

get_pal(agnus_chip_id)
UBYTE agnus_chip_id;
{
	if(agnus_chip_id & 0x20) /* new hires agnus */
	{
	    /* an ntsc hires agnus has pin 41 grounded */
	    /* a pal hires agnus has pin 41 open */
	    if(!(agnus_chip_id & 0x10)) return(PAL | REALLY_PAL);
	}
	else
	{
	    /* an ntsc display has 262 lines, counts to 261 */
	    /* a pal display has 312 lines, counts to 311 */
	    /* must be run while disabled */
	    register int i;
	    if ((i = vbeampos()) > 270)  return(PAL);
	    else
	    {
		    /* wait till vbeampos >= 256 */
		    while ( (i = vbeampos()) < 256);
		    do
		    {
			    if (i > 270) return(PAL | REALLY_PAL);
			    i = vbeampos();
		    } while (i > 50);	/* if it falls back then no pal */
		    /* I use 50 figuring the genloc wont reset me higher than */
		    /* that every frame time */
	    }
	}
	return (NTSC);
}

@


39.74
log
@Changed BPLCON3 in copinit_mid_ecs[] and COLOR0 in copinit_mid_a[] to
NOPs. These are altered later in update_top_color() to the correct
instructions.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.73 93/03/30 10:21:31 chrisg Exp Locker: spence $
d857 1
a857 4
	if (!(gfx_SetDefaultMonitor(((GBASE->DisplayFlags & PAL) ? (PAL_MONITOR_ID >> 16) : (NTSC_MONITOR_ID >> 16)))))
	{
		Alert(ALERTGFXNOMEMMSPC);	/* does not return */
	}
@


39.73
log
@new lvo for writechunkypixels.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.72 93/03/19 12:25:31 chrisg Exp Locker: chrisg $
d489 2
a490 1
	COPPER_MOVE|BPLCON3,0xc00,
d507 1
a507 1
	COPPER_MOVE|BPLCON3,0xc00,
d681 2
a682 1
	*a++=COPPER_MOVE|(0x1FE&(int)(&io->bplcon3)); *a++= 0xe00;
d684 5
a688 2
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->color[0]));
	/* leave the LOCT bit low */
@


39.72
log
@fix spences protos.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.71 93/03/08 09:49:24 chrisg Exp Locker: chrisg $
d172 1
d427 1
a427 1
	AlwaysReturnsZero,
@


39.71
log
@added call to routine to check for chunkytoplanar.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.70 93/02/16 13:45:53 chrisg Exp Locker: chrisg $
a149 1
int GetVPModeID(), ModeNotAvailable();
@


39.70
log
@genlocl
lpen
nop()
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.69 93/02/09 15:55:20 chrisg Exp Locker: chrisg $
d886 1
@


39.69
log
@now using GBASE everywhere.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.68 92/11/23 16:27:08 spence Exp Locker: chrisg $
a304 7
void nop()
{
#ifdef DEBUG
    kprintf("graphics vector nop\n");
#endif
}

d526 1
d589 2
d715 1
a715 1
	a=CopyWords(copinit_end,a,8);
d718 1
a718 1
	io->cop2lc = a-2;		/* point at wait forever */
d795 2
@


39.68
log
@HashTableSemaphore
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.67 92/10/27 12:54:34 spence Exp Locker: spence $
d536 1
a536 2
void cpwrup(c)
register struct GfxBase *c;
d548 2
a549 2
    ((struct Library *)c)->lib_Node.ln_Type = NT_LIBRARY;
    ((struct Library *)c)->lib_IdString = &rev_name;
d586 1
a586 1
    c->UtilBase=TaggedOpenLibrary(OLTAG_UTILITY);
d594 1
a594 1
	c->ChipRevBits0 |= GFXF_HR_AGNUS;
d597 1
a597 1
	c->ChipRevBits0 |= GFXF_HR_DENISE;
d625 7
a631 7
    c->bwshifts = (UBYTE *)&bwshifts;
    c->StrtFetchMasks = (UWORD *)&StrtFetchMasks;
    c->StopFetchMasks = (UWORD *)&StopFetchMasks;
    c->Overrun = (UWORD *)&Overrun;
    c->RealStops = (WORD *)&RealStops;
    c->arraywidth = 2;
    c->ProgData = &ProgData;
d634 1
a634 1
    c->WantChips = SETCHIPREV_BEST;
d636 10
a645 10
    c->BlitLock = -1;       /* unlocked */
    c->BlitNest = -1;
    NewList(&c->BlitWaitQ);
    NewList(&c->TOF_WaitQ);

    c->LibNode.lib_Node.ln_Name = gfx_lib_name;
	c->LibNode.lib_Version = &VERSION;
	c->LibNode.lib_Revision = &REVISION;
	c->LibNode.lib_Flags |= LIBF_SUMUSED|LIBF_CHANGED;
	c->LibNode.lib_OpenCnt = 1;	/* never expunge */
d650 1
a650 1
	AddLibrary(c);
d652 4
a655 4
	c->ColorMask=0xf0000000;	/* will be reset by SetChipRevBits if AA */
	c->SpriteWidth=1;	/* cg - initalize sprite width for AA */
	c->DefaultSpriteWidth=1;
	c->SpriteFMode=0;
d657 3
a659 3
	c->SimpleSprites = (struct SimpleSprite **) AllocMem(sizeof(int *)*8,MEMF_CLEAR);
	/*c->SimpleSpriteViewPorts = AllocMem(sizeof(int *)*8,MEMF_CLEAR);*/
	c->copinit = (struct copinit *) a;
d661 1
a661 1
	a = c->copinit->vsync_hblank;
d680 1
a680 1
	a = c->copinit->vsync_hblank;
d692 1
a692 1
		if (c->ChipRevBits0 & GFXF_HR_DENISE)
d699 1
a699 1
/*	a = c->copinit->sprstrtup;*/
d713 1
a713 1
	    *a++ = TOBB((long)(c->copinit->sprstop) >> 16);
d715 1
a715 1
	    *a++ = TOBB((long)(c->copinit->sprstop));
d718 1
a718 1
	c->TopLine = TOPLINE;
d741 1
a741 1
    if(c->ChipRevBits0 & GFXF_HR_AGNUS)
d747 4
a750 4
    c->vbsrv.is_Code = (void *) &vbasm;
    c->vbsrv.is_Data = c;
    c->vbsrv.is_Node.ln_Pri = 10;
    c->vbsrv.is_Node.ln_Name = gfx_lib_name;
d757 3
a759 3
    /* c->LOFlist = c->copinit->sprstrtup+2*(32+6) */;
    c->SHFlist = c->LOFlist = c->copinit->wait_forever;
    AddIntServer(INTB_VERTB,&c->vbsrv);
d765 3
a767 3
    c->bltsrv.is_Code = (void *) &bltasm;
    c->bltsrv.is_Data = (APTR)(c);
    c->bltsrv.is_Node.ln_Name = gfx_lib_name;
d771 1
a771 1
    SetIntVector(INTB_BLIT,&c->bltsrv);
d776 4
a779 4
    c->timsrv.is_Code = (void *)&timasm;
    c->timsrv.is_Data = c;
    c->timsrv.is_Node.ln_Pri = 10;
    c->timsrv.is_Node.ln_Name = gfx_lib_name;
d784 1
a784 1
    c->cia = (long *)OpenResource("ciab.resource");
d787 1
a787 1
    kprintf("now call EnaICRB cia=%lx\n",c->cia);
d789 1
a789 1
    ADDICRVECTOR(c->cia,2,&c->timsrv);
d798 1
a798 1
    c->system_bplcon0 = get_genloc(io,c) | COLORON;
d800 1
a800 1
    c->DisplayFlags |= ((c->system_bplcon0 & GENLOC)|get_pal(agnus_chip_id));
d804 1
a804 1
    c->hash_table = (void *) AllocMem((HASHTABLE_NUMENTRIES * 4),MEMF_CLEAR);
d808 2
a809 2
    c->HashTableSemaphore = (struct SignalSemaphore *)AllocMem(sizeof(struct SignalSemaphore),0);
    InitSemaphore(c->HashTableSemaphore);
d814 1
a814 1
	    eb = (struct ExecBase *) c->ExecBase;
d816 1
a816 1
	    if (c->DisplayFlags & PAL)	eb->VBlankFrequency = 50;
d819 2
a820 2
    c->MinDisplayColumn = STANDARD_DENISE_MIN; /* bart -- min left clip */
    c->MaxDisplayColumn = STANDARD_DENISE_MAX; /* bart -- max right clip */
d822 1
a822 1
    c->NormalDisplayColumns = 640;
d824 1
a824 1
    c->MicrosPerLine = 16285;		/* approximately */
d828 1
a828 1
	c->ActiViewCprSemaphore = (struct SignalSemaphore *) 
d831 1
a831 1
	InitSemaphore(c->ActiViewCprSemaphore);
d836 2
a837 2
	c->LCMptr = (void *) AllocMem(MAXBYTESPERROW,MEMF_CHIP);
	c->LastChanceMemory = (struct SignalSemaphore *)
d839 1
a839 1
	InitSemaphore(c->LastChanceMemory);
d842 1
a842 1
	c->DisplayInfoDataBase = db_startup();
d845 1
a845 1
	NewList(&c->MonitorList);
d847 1
a847 1
	c->MonitorListSemaphore = (struct SignalSemaphore *) 
d850 1
a850 1
	InitSemaphore(c->MonitorListSemaphore);
d854 1
a854 1
	if (!(gfx_SetDefaultMonitor(((c->DisplayFlags & PAL) ? (PAL_MONITOR_ID >> 16) : (NTSC_MONITOR_ID >> 16)))))
d859 1
a859 1
    defras(c);
d864 1
a864 1
    defras(c);
d871 1
a871 1
    SFInit(c);      /* initialize fonts */
d890 1
a890 1
    c->Debug = 1;
d919 1
a919 2
unsigned short beamconpal(gb)
struct GfxBase *gb;
d921 1
a921 1
	if (gb->DisplayFlags & PAL)	return (0x20);
d958 1
a958 2
void defras(c)
struct GfxBase *c;
d971 1
a971 1
	io->bplcon0 = (c->system_bplcon0 & ~LACE); /* changed to zero bitplanes */
d982 1
a982 1
	io->beamcon0 = beamconpal(c);	/* disable most all new stuff */
d987 1
a987 1
get_genloc(io,gb)
a988 1
struct GfxBase *gb;
d1062 1
a1062 1
	    if( ciaa.todlow ) gb->DisplayFlags |= TODA_SAFE;
@


39.67
log
@Where db_avail() checks availablity of bandwidth for Hires and SuperHires
HAM, also needed to check that the mode was not Lores. This is for the
new VGA type modes that are 140ns pixels but scan doubled.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.66 92/08/27 12:16:34 spence Exp Locker: spence $
d20 1
a30 1
#include "/gfxbase.h"
d806 5
d812 1
a858 1

@


39.66
log
@in db_avail(), if the mode is DIPF_IS_ECS or DIPF_IS_AA, then set
DI_AVAIL_NOCHIPS before checking to clear it again. This stops SuperHires
being made available in 'A' emulation mode.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.65 92/08/11 14:17:45 chrisg Exp Locker: spence $
d224 3
a226 1
					   ((dinfo->ModeID & HIRES) && GBASE->MemType)) )
@


39.65
log
@added null vectors for future patching.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.64 92/08/11 14:00:42 spence Exp Locker: chrisg $
d199 11
d271 1
a271 1
    };
@


39.64
log
@VPOrigin() vector replaced with AlwaysReturnsZero().
Removed check for R2Alice for the GBASE->Bugs field
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.63 92/08/06 16:40:31 spence Exp Locker: spence $
d421 4
@


39.63
log
@Point GfxBase->ProgData to the ROM ProgData
,
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.62 92/07/21 16:45:51 chrisg Exp Locker: spence $
a169 1
int VPOrigin();
d414 1
a414 1
	VPOrigin,
d605 1
a605 7
	 GBASE->Bugs = (BUG_ALICE_RHS | BUG_ALICE_LHS | BUG_H0 | BUG_VBLANK | BUG_ALICE_LHS_PROG);

	/* for now, clear bits for Alice R3 here! - Jun 18 1992 */
	if ((agnus_chip_id & 0x23) == 0x23)
	{
		GBASE->Bugs &= ~(BUG_ALICE_RHS | BUG_H0);
	}
@


39.62
log
@really_pal
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.61 92/07/21 14:23:53 chrisg Exp Locker: chrisg $
d431 1
d622 1
@


39.61
log
@removed battmem stuff
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.60 92/07/01 13:39:57 chrisg Exp Locker: chrisg $
d1069 1
a1069 1
	    if(!(agnus_chip_id & 0x10)) return(PAL);
d1084 1
a1084 1
			    if (i > 270) return(PAL);
@


39.60
log
@added sprite scan doubling fix.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.59 92/06/30 16:39:36 spence Exp Locker: chrisg $
a15 2
#include <resources/battmem.h>
#include <resources/battmembitsamiga.h>
a38 1
#include <pragmas/battmem_pragmas.h>
a841 14
    /* If there was a ChipRev saved in BattMem, set that now. */
    {
	ULONG err;
	UBYTE battmem = 0;

	err = GetBattMem(&battmem, BATTMEM_CHIP_REV_ADDR, BATTMEM_CHIP_REV_LEN);
	if ((err == NULL) && battmem)
	{
		/* Calling SetChipRev(BEST) will force SCR() to look at
		 * BattMem and interpret the bits itself.
		 */
		SetChipRev(SETCHIPREV_BEST);
	}
    }
a1064 3
	ULONG err;
	UBYTE battmem = 0;

a1066 13
	    /* V39 - read the bits from Battmem if available,
	     * else read the id.
	     */
	    err = GetBattMem(&battmem, BATTMEM_MONITOR_MODE_ADDR, BATTMEM_MONITOR_MODE_LEN);

	    /* ensure that BattMem was read properly, and that we are not
	     * reading uninitialised battmem data (ie at least one bit is set)
	     */
	    if ((err == NULL) && battmem)
	    {
		return((battmem == BATTMEM_MONITOR_MODE_NTSC) ? NTSC : PAL);
	    }

a1093 24
char bname[]=BATTMEMNAME;

ULONG GetBattMem(UBYTE *battmem, ULONG offset, ULONG len)
{
	APTR BattMemBase;
	ULONG err;

	if (!(BattMemBase = (APTR)OpenResource(bname)))
	{
		if (BattMemBase = (APTR)FindResident(bname))
		{
			InitResident((struct Resident *)BattMemBase,0l);
			BattMemBase = (APTR)OpenResource(bname);
		}
	}
	if (BattMemBase)
	{
		ObtainBattSemaphore();
		err = ReadBattMem(battmem, offset, len);
		ReleaseBattSemaphore();
	}

	return(err);
}
@


39.59
log
@Set BUG_ALICE_LHS_PROG in GBASE->Bugs for the monitors to fudge colourclocks
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.58 92/06/19 12:13:33 spence Exp Locker: spence $
d692 6
@


39.58
log
@Alice R3 does not need the BUG_ALICE_RHS or BUG_H0 bits set in GBASE->Bugs
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.57 92/06/18 15:32:54 spence Exp Locker: spence $
d608 1
a608 1
	 GBASE->Bugs = (BUG_ALICE_RHS | BUG_ALICE_LHS | BUG_H0 | BUG_VBLANK);
@


39.57
log
@MakeLongFrame() - called by defras() and newdefras() to force the 
LongFrame/ShortFrame bit in vposr SAFELY
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.56 92/06/11 10:46:14 spence Exp Locker: spence $
d609 6
@


39.56
log
@copinit_mid_a[] needs to reset bplcon3 when running as 'A' on a AA machine
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.55 92/06/09 12:10:43 spence Exp Locker: spence $
d883 32
d927 1
a927 1
	io->bplcon2 = 0x80;
d944 2
a945 7
}
	
unsigned short beamconpal(gb)
struct GfxBase *gb;
{
	if (gb->DisplayFlags & PAL)	return (0x20);
	else				return (0);
a951 2
	long	WC_ZERO=0;
	WORD vpos;
d962 2
a963 2
	io->bplcon0 = c->system_bplcon0; /* changed to zero bitplanes */
	io->bplcon1 = WC_ZERO;
d965 2
a966 2
	io->bpl2mod = WC_ZERO;
	io->bpl1mod = WC_ZERO;
d975 1
a975 6
	vpos = io->vhposr;
	while ((vpos & 0xff00)== 0xff00)
	{
		vpos = io->vhposr; /* avoid critical region */
	}
	io->vposw = 0x8000|io->vposr;
@


39.55
log
@copinit is now loaded with NOPs in the middle on 'A' machines.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.54 92/06/03 18:06:03 spence Exp Locker: spence $
d499 1
a499 1
	COPPER_MOVE|NOP,0x0,
@


39.54
log
@Added BestModeIDA() to function list.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.53 92/05/20 14:16:43 chrisg Exp Locker: spence $
d470 1
d478 2
a479 1
						 COPPER_MOVE|COLOR};
d481 1
a481 1
UWORD copinit_mid[]={
d495 13
a507 1
	COPPER_MOVE|BPLCON2,0x24 };
d676 8
a683 3
	a=CopyWords(copinit_mid,a,16);


@


39.53
log
@copinit now creaetd by copying from an arry, rather than by code.
over 200 bytes saved.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.52 92/05/19 13:17:47 chrisg Exp Locker: chrisg $
d424 1
@


39.52
log
@taggedopenlibrary.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.51 92/05/13 11:25:20 spence Exp Locker: chrisg $
d457 50
d653 3
a655 3
	/* first one just a place saver for new chips */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplpt[0]));
	*a++ = 0;   /* lets show low memory for default */
a656 5
	/* Now we need place for five more moves -- (in diagstrt) for colours */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplcon0));
	*a++ = 0x200;
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplcon3));
	*a++ = 0xc00;
d658 1
d660 2
a661 7
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplcon3));
	*a++ = 0xe00;
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->color[0]));
	*a++ = ((struct ExecBase *)(SysBase))->ex_Pad0;   /* lets show grey for default on ECS too! */
	/* leave the LOCT bit low */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplcon3));
	*a++ = 0xc00;
a662 20
	/* Now, set the default bandwidth to 1x */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->fmode));
	*a++ = 0x0;
	/* Open a display window of one line ... */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->diwstrt));
	*a++ = 0x0181;
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->diwstop));
	*a++ = 0x0281;
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->diwhigh));
	*a++ = 0x0;
	/* And a single fetch to hide the Alice bug. This removes the blank
	   bar at the RHS for the 16 and 32 fetch cycles when I set DDFSTOP to
	   0xd8 */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->ddfstrt));
	*a++ = 0x18;
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->ddfstop));
	*a++ = 0x20;
	/* Now set bplcon2 */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplcon2));
	*a++ = 0x24;
d679 1
a679 8
	*a++ = (COPPER_WAIT | TOPLINE);
	*a++ = 0xFFFE;  /* wait for first line */
	/* just a place saver here for real hbstop */
	*a++ = (COPPER_WAIT | TOPLINE);
	*a++ = 0xFFFE;  /* wait for first line */

	/* the above wait will allow the vertical blank routine time to set
	   up cop2ptr to continue the refresh of the display */
a680 2
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->copjmp2));
	*a++ = 0;
d682 1
a682 1
	io->cop2lc = a;
a683 2
	*a++ = 0xffff;  /* wait forever */
	*a++ = 0xfffe;
@


39.51
log
@db_avail() check if NO_CHIPS should be set for EHB AA modes.
intialise GBASE->Bugs.
reworked copinit initialisation for new copinit structure
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.50 92/05/05 14:01:59 chrisg Exp Locker: spence $
d37 1
a465 1
	STRPTR UtilName = "utility.library";
d507 2
a508 6
    while (!(c->UtilBase = (ULONG *)OpenLibrary(UtilName,36)))
    {
	struct Resident *resi;
	if (resi = FindResident(UtilName))
		InitResident(resi, NULL);
    }
@


39.50
log
@fixed mismatcged arguments to residient and resource code. Needed to pass a seglist
to initresident!!!!!
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.49 92/05/05 13:54:36 spence Exp Locker: chrisg $
d34 1
d211 2
a212 2
				/* but if we don't have the badwidth for the HAM... */
				if (dinfo->ModeID & HAM)
d543 5
d629 1
a629 1
	/* Now we need place for three more moves -- diwstrt/stop and diwhigh */
d643 3
a667 8
	/* Now we need place for two more moves -- genloc */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplpt[0]));
	*a++ = 0;   /* lets show low memory for default */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplpt[0])+2);
	*a++ = 0;   /* lets show low memory for default */

	/* end of place save */

a672 2
	*a++ = 0xFFFE;  /* nop */
	*a++ = 0xffff;
@


39.49
log
@Hmm. Somehow 39.48 lost the 39.49 changes!
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.47 92/04/29 12:16:56 spence Exp Locker: spence $
d739 1
a739 1
    c->cia = (long *)OpenResource("ciab.resource",0);
d1081 1
a1081 1
			InitResident((struct Resident *)BattMemBase);
@


39.48
log
@killed stub for makevp.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.46 92/04/27 15:03:13 chrisg Exp $
a604 6
	/* Now we need place for two more moves -- diwstrt and diwhigh */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplpt[0]));
	*a++ = 0;   /* lets show low memory for default */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplpt[0])+2);
	*a++ = 0;   /* lets show low memory for default */

d623 15
@


39.47
log
@changed copinit. It now opens a one line high displaywindow, and does a
single data fetch. This hides the Alice bug with setting DDFSTOP too high
in 16 and 32 cycle modes.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.46 92/04/27 15:03:13 chrisg Exp Locker: spence $
d92 1
a92 1
int MakeVPort(),LoadView(),WaitBlit(),SetRast();
d605 6
a628 15
	/* Now we need place for three more moves -- diwstrt/stop and diwhigh */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->diwstrt));
	*a++ = 0x0181;
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->diwstop));
	*a++ = 0x0281;
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->diwhigh));
	*a++ = 0x0;
	/* And a single fetch to hide the Alice bug. This removes the blank
	   bar at the RHS for the 16 and 32 fetch cycles when I set DDFSTOP to
	   0xd8 */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->ddfstrt));
	*a++ = 0x18;
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->ddfstop));
	*a++ = 0x20;

@


39.46
log
@killed multiple BATTMEMNAMES.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.45 92/04/27 11:56:40 spence Exp Locker: chrisg $
a604 6
	/* Now we need place for two more moves -- diwstrt and diwhigh */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplpt[0]));
	*a++ = 0;   /* lets show low memory for default */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplpt[0])+2);
	*a++ = 0;   /* lets show low memory for default */

d623 15
@


39.45
log
@struct Copinit now allocated MEMF_CLEAR. The default NULL pointer is
now aligned properly for a 4x and 2x sprite, and is set to start on
line 0 with a height of 0 (ie the structure is all 0's)
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.44 92/04/10 12:13:48 spence Exp Locker: spence $
d460 1
a465 1
    struct Custom *io = &custom;
d853 1
a853 1
	struct Custom *io;
d1061 2
d1068 1
a1068 1
	if (!(BattMemBase = (APTR)OpenResource(BATTMEMNAME)))
d1070 1
a1070 1
		if (BattMemBase = (APTR)FindResident(BATTMEMNAME))
d1073 1
a1073 1
			BattMemBase = (APTR)OpenResource(BATTMEMNAME);
@


39.44
log
@Uses the new private SetDefaultMonitor() LVO to initialise the default
MonitorSpec, and GfxBase NTSC or PAL values.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.43 92/04/08 17:05:53 chrisg Exp Locker: spence $
d427 1
a427 1
extern UWORD StrtFetchMasks[];
d575 1
a575 1
	a=(short *)AllocMem(sizeof(struct copinit),MEMF_PUBLIC|MEMF_CHIP);
a578 5

	c->copinit->sprstop[0] = 0xff00; /* null height */
	c->copinit->sprstop[1] = 0xff66; /* new bits */
	c->copinit->sprstop[2] = 0x0000; /* stop safely */
	c->copinit->sprstop[3] = 0x0000; /* stop safely */
@


39.43
log
@killed searchcolormap, and pickbestcolor.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.42 92/04/07 14:52:33 spence Exp Locker: chrisg $
d33 1
d399 1
a399 1
	AlwaysReturnsZero,
a763 18
    if (c->DisplayFlags & NTSC)
    {
	    c->MaxDisplayRow = STANDARD_NTSC_ROWS - 1;
	    /* following is for 1080 monitor */
	    c->NormalDisplayRows = 200;
	    c->NormalDPMX = 1280;	/* 320 X 1000/250mm */
	    c->NormalDPMY = 1098;	/* 200 X 1000/182mm */
    }

    if (c->DisplayFlags & PAL)
    {
	    c->MaxDisplayRow = STANDARD_PAL_ROWS - 1;
	    c->NormalDisplayRows = 256;
	    /* for philips monitor */
	    c->NormalDPMX = 1226;	/* 320 X 1000/261mm */
	    c->NormalDPMY = 1299;	/* 256 X 1000/197mm */
    }

d799 1
a800 27
	    struct MonitorSpec *mspc = new_monitorspec(c,
				       (c->DisplayFlags&PAL)?
				       REQUEST_PAL:
				       REQUEST_NTSC,
				       (c->DisplayFlags&PAL)?
				       PAL_MONITOR_NAME:
				       NTSC_MONITOR_NAME);
	    if(mspc)
	    {
		int unity_scale();

		mspc->ms_scale = unity_scale; 	/* force unity */

		c->default_monitor = mspc;

		/* initialize view range bound */
		vlimit(mspc,&mspc->ms_LegalView,NULL);

		AddHead(&c->MonitorList, mspc);

		activate_mspc( ( c->DisplayFlags & PAL ) ?
			       (  PAL_MONITOR_ID ) :
			       ( NTSC_MONITOR_ID ), 
			         mspc );
	    }
	    else
	    {
a801 1
	    }
@


39.42
log
@Sets GBASE->BoardMemType on AA machines
.,
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.41 92/04/07 13:37:25 chrisg Exp Locker: spence $
d154 1
a154 2
int PickBestColor();
int SearchColorMap();
d386 2
a387 2
	PickBestColor,
	SearchColorMap,
@


39.41
log
@ made init battmem.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.40 92/04/06 13:58:48 chrisg Exp Locker: chrisg $
d537 5
d1117 2
a1118 2
    {
		if (BattMemBase = FindResident(BATTMEMNAME))
d1120 1
a1120 1
			InitResident(BattMemBase);
@


39.40
log
@ getrpattr->getrpattra.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.39 92/04/06 12:39:06 chrisg Exp Locker: chrisg $
d36 1
d1111 9
a1119 1
	if (BattMemBase = (APTR)OpenResource(BATTMEMNAME))
d1125 1
@


39.39
log
@ added set/get RPattr.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.38 92/04/04 14:35:01 chrisg Exp Locker: chrisg $
d419 2
a420 2
	SetRPAttr,
	GetRPAttr,
@


39.38
log
@init softsprites to zero again.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.37 92/04/03 16:57:25 chrisg Exp Locker: chrisg $
d419 2
@


39.37
log
@ added vectors for new sprite stuff.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.36 92/04/02 10:44:59 spence Exp Locker: chrisg $
a563 1
	c->SoftSprites=1;	/* should be 0 when intuition gets smart */
@


39.36
log
@Added VPOrigin() to the function list
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.35 92/03/26 12:44:07 chrisg Exp Locker: spence $
d163 1
a163 1
int GetSpriteTags();
d171 3
d401 1
a401 1
	GetSpriteTags,
d416 3
@


39.35
log
@ added FindColor()
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.34 92/03/24 15:28:16 chrisg Exp Locker: chrisg $
d170 1
d412 1
@


39.34
log
@ removed last color poke.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.33 92/03/19 16:10:00 chrisg Exp Locker: chrisg $
d147 1
d410 1
@


39.33
log
@added scrollrasterBF.
exec now stores the boot color in Pad0.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.32 92/03/06 12:41:25 spence Exp Locker: chrisg $
a851 2
    io->color[0] = 0xfff;
    io->color[1] = 0xfff;
@


39.32
log
@Handles ChipRev set in Battmem by Bootmenu
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.31 92/03/03 13:39:30 chrisg Exp Locker: spence $
d97 1
a97 1
int RectFill(),BltPattern();
a148 1
int EraseRect();
d408 1
d605 1
a605 1
	*a++ = 0xaaa;   /* lets show grey for default */
d609 1
a609 1
	*a++ = 0xaaa;   /* lets show grey for default on ECS too! */
@


39.31
log
@killed scrollraster decl..it's in c.protos
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.30 92/03/03 10:26:12 spence Exp Locker: chrisg $
d534 3
d832 15
a1050 1
	APTR BattMemBase;
d1052 1
d1059 6
a1064 1
	    if (BattMemBase = (APTR)OpenResource(BATTMEMNAME))
d1066 1
a1066 13
		UBYTE battmem = 0;

		ObtainBattSemaphore();
		err = ReadBattMem(&battmem, BATTMEM_MONITOR_MODE_ADDR, BATTMEM_MONITOR_MODE_LEN);
		ReleaseBattSemaphore();

		/* ensure that BattMem was read properly, and that we are not
		 * reading uninitialised battmem data (ie at least one bit is set)
		 */
		if ((err == NULL) && battmem)
		{
			return((battmem == BATTMEM_MONITOR_MODE_NTSC) ? NTSC : PAL);
		}
d1094 14
@


39.30
log
@genloc test uses DelayAndRead() for greater accuracy
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.29 92/03/02 14:50:41 chrisg Exp Locker: spence $
a103 1
int ScrollRaster();
@


39.29
log
@  added setrgb32cm
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.28 92/02/28 14:03:15 chrisg Exp Locker: chrisg $
d985 1
a985 1
    for (count=0;count<372;count++) pos=(vhposr & 0xFF);
@


39.28
log
@killed allocbitmapdata and freebitmap data
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.27 92/02/24 14:09:37 chrisg Exp Locker: chrisg $
d170 1
d409 1
@


39.27
log
@changed function names and intitialized colormask field.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.26 92/02/20 14:07:08 chrisg Exp Locker: chrisg $
d161 1
a161 2
int AllocBitMapData();
int FreeBitMapData();
d393 2
a394 2
	AllocBitMapData,
	FreeBitMapData,
@


39.26
log
@added allocdbufinfo, freedbufinfo, setopen, setwrmsk, setmaxpen.
added pragmas for utility and exec.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.25 92/02/14 15:58:18 chrisg Exp Locker: chrisg $
d170 1
a170 1
int SetOPen(), SetWrMsk(), SetMaxPen();
d406 2
a407 2
	SetOPen,
	SetWrMsk,
d550 1
@


39.25
log
@ added getbitmapattr.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.24 92/01/30 15:33:36 chrisg Exp Locker: chrisg $
d22 1
d35 1
d168 3
d404 5
@


39.24
log
@  moved releasepen and obtainpen to the end of the vector table. warning!
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.23 92/01/29 13:12:37 spence Exp Locker: chrisg $
d165 1
d398 1
@


39.23
log
@changed MakeGfxGreat() to SetChipRev().
Changed order of instructions in CopInit (bplcon0 before the bplcon3 writes)
to set the EXTBLNKEN bit.
No longer allocates A2024 sync_raster or the hedley_sprites.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.22 92/01/21 14:51:54 chrisg Exp Locker: spence $
d395 2
@


39.22
log
@changed name of utilbase field
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.21 92/01/21 12:49:36 spence Exp Locker: chrisg $
d385 1
a385 1
	MakeGfxGreat,
d501 1
a501 1
    	 * (by MakeGfxGreat()).
d582 2
a591 2
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplcon0));
	*a++ = 0x200;
a811 15
	}

	c->a2024_sync_raster = (void *) AllocMem(128,MEMF_CHIP|MEMF_CLEAR);
	for (i = 0;i < (128/4) ; i++)	c->a2024_sync_raster[i] = -1;
	c->a2024_sync_raster[0] = 0x3ffffff; /* bart -- 01.31.89 */
	/* allocate space for 4 pointer arrays */
	/* we will always have there*/
	/* last minute hack, remove! */
#define	MHH_BYTES	2+(4*MAX_HEDLEYSPRITE_HEIGHT)+2
	for (i = 0; i<6 ; i++)
	{
		/* allocate two at a time and hardcode attached one as middle*/
		/* of first one */
		c->hedley_sprites[i] = AllocMem((MHH_BYTES)*2*2,MEMF_CHIP|MEMF_CLEAR);
		c->hedley_sprites1[i] = c->hedley_sprites[i]+(MHH_BYTES);
@


39.21
log
@reads BattMem for PAL/NTSC
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.20 92/01/07 15:53:49 spence Exp Locker: spence $
a170 1
struct RawDisplayinfo *find_tag();
d184 1
a184 1
		if (dinfo  = find_tag(&record->rec_Tag,DTAG_DISP))
d212 1
a212 1
			if((record) && (dims = find_tag(&record->rec_Tag,DTAG_DIMS)))
d233 1
a233 1
			&& (minfo  = find_tag(&record->rec_Tag,DTAG_MNTR)))
d479 1
a479 1
    while (!(c->UtilityBase = (ULONG *)OpenLibrary(UtilName,36)))
@


39.20
log
@find_info -> FindDisplayInfo, and other such things..
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.19 92/01/07 14:24:04 chrisg Exp Locker: spence $
d16 2
d35 2
a165 2
void MakeGfxGreat();

d1034 3
d1039 20
a1084 1

@


39.19
log
@delete CopySBitMap/Sync declaration. now in c.protos.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.18 92/01/07 13:41:35 spence Exp Locker: chrisg $
d261 1
a261 1
    while( ( ID = next_info( ID ) ) != INVALID_ID )
d265 1
a265 1
	    struct DisplayInfoRecord *record = find_info( ID );
d273 1
a273 1
		   (int)cook_chunk(record, (UBYTE *)chunk, sizeof(*chunk), DTAG_MNTR, ID))
d276 1
a276 1
		    if(uncook_chunk(record, (UBYTE *)chunk,numbytes,DTAG_MNTR,ID)) break;
@


39.18
log
@gfxnew -> GfxNew.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.17 91/12/31 14:29:43 spence Exp Locker: spence $
a102 1
int SyncSBitMap(),CopySBitMap();
@


39.17
log
@sets up bplcon3 and bplcon4 if running on a AA machine as A or ECS.
Extra instruction in copinit to reset bplcon3 to LOCT = 0.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.16 91/12/20 15:47:02 chrisg Exp Locker: spence $
a135 2
int GfxAssociate(),GfxLookUp();

d410 1
a410 1
    struct MonitorSpec *mspc = (struct MonitorSpec *) gfxnew(MONITOR_SPEC_TYPE);
@


39.16
log
@ added ChangeVPBitMap to vector list
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.15 91/11/18 16:41:58 spence Exp Locker: chrisg $
d508 4
d594 3
@


39.15
log
@Sets low order bits of Colour0 to 0xaaa (same as high order bits). ECS
machines were booting up with a black screen.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.14 91/11/18 11:29:49 spence Exp Locker: spence $
d163 1
d396 1
@


39.14
log
@no longer set GfxBase->Debug = 1 at power up.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.13 91/11/15 10:52:34 spence Exp Locker: spence $
d585 1
a585 1
	*a++ = 0;   /* lets show black for default */
@


39.13
log
@CoerceMode() put in the list
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.12 91/11/08 12:12:03 spence Exp Locker: spence $
d33 1
a33 1
#define GBDEBUG		/* sets GfxBase->Debug = 1 */
@


39.12
log
@show grey for default colour in copinit instead of black
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.11 91/11/08 11:32:09 chrisg Exp Locker: spence $
d394 1
@


39.11
log
@ changed function names for p sharing
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.10 91/10/30 19:18:04 spence Exp Locker: chrisg $
d580 1
a580 1
	*a++ = 0;   /* lets show black for default */
@


39.10
log
@Moved default colour palette to a/getcolormap.asm
Sets GFXF_AA_MLISA flag in GB->ChipRevBits0 if this is a AA machine
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.9 91/10/28 19:32:35 spence Exp Locker: spence $
d148 2
a149 2
int FreePalette();
int AllocPalette();
d349 2
a350 2
	FreePalette,
	AllocPalette,
@


39.9
log
@db_avail() altered to fix SetDisplayInfoData() bug B14669. Now takes
struct DisplayInfoRecord * instead of GfxBase to only alter one
record.
New all_db_avail() calls db_avail() iteratively.
GetDeniseID() replaced with a call to get_denise_id() in misc.asm
for better detection of non-ECS on A1000.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.8 91/10/28 11:49:43 chrisg Exp Locker: spence $
d136 1
a136 1
int GfxNew(),GfxFree(),GfxAssociate(),GfxLookUp();
a396 8
short dflt_clrs[32] =
{
    0x000, 0xf00, 0x0f0, 0xff0, 0x00f, 0xf0f, 0x0ff, 0xfff,
    0x620, 0xe50, 0x9f1, 0xeb0, 0x55f, 0x92f, 0x0f8, 0xccc,
    0x000, 0x111, 0x222, 0x333, 0x444, 0x555, 0x666, 0x777,
    0x888, 0x999, 0xaaa, 0xbbb, 0xccc, 0xddd, 0xeee, 0xfff
};

d496 11
a507 1

@


39.8
log
@ added vectors and initizlaization fro sprite mode switching stuff
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.7 91/10/16 17:21:03 spence Exp Locker: chrisg $
d173 1
a173 2
void db_avail( GB )
struct GfxBase *GB;
a174 1
    ULONG ID = INVALID_ID;
d177 2
a178 2
    HRDenise = (GB->ChipRevBits0 & GFXF_HR_DENISE);
    Lisa = (GB->ChipRevBits0 & GFXF_AA_LISA);
a179 1
    while( ( ID = next_info( ID ) ) != INVALID_ID )
a180 1
		struct DisplayInfoRecord *record;
d185 1
a185 2
		if((record = find_info( ID ))
		&& (dinfo  = find_tag(&record->rec_Tag,DTAG_DISP)))
d204 1
a204 1
					if (! (((dinfo->ModeID & SUPERHIRES) && (GB->MemType == BANDWIDTH_4X))
d206 1
a206 1
					   ((dinfo->ModeID & HIRES) && GB->MemType)) )
d225 1
a225 1
			if(GB->system_bplcon0 & GENLOCK_VIDEO)
d242 14
a434 17
UBYTE GetDeniseID(struct Custom *io)
{
    int i;
    UBYTE Denise;
    UBYTE dummy;	/* fucking stupid compiler */

    Denise = (io->deniseid & (UBYTE)0xff);
    for (i = 0; i < 16 ; i++)
    if (Denise != ((dummy = io->deniseid) & (UBYTE)0xff) )
    {
	Denise = -1;	/* all bits set=no ext features */
	break;
    }

    return(Denise);
}

d453 17
a469 1
	denise_chip_id = GetDeniseID(io);
d848 1
a848 1
	db_avail( c ); 
@


39.7
log
@hang makevp() look up tables off GfxBase.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.6 91/10/15 15:51:02 chrisg Exp Locker: spence $
d162 1
d384 1
d521 1
d523 2
@


39.6
log
@  made initialize gfxbase->spritewidth
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.5 91/10/04 12:20:27 chrisg Exp Locker: chrisg $
d23 1
a23 1
#include "/sane_names.h"
d53 1
a393 1
UBYTE bwmults[] = {1, 2, 2, 4};	/* multipliers for bandwidth types */
d396 5
a417 1
extern struct AmigaRegs custom;
d424 1
a424 1
UBYTE GetDeniseID(struct AmigaRegs *io)
d451 1
a451 3
    struct AmigaRegs *io;

    io = &custom;
d494 1
d496 7
d531 2
a532 2
	io->dmaconw = BITCLR|DMAF_COPPER;  /* turn copper off */
	io->cop1ptr = (UWORD *)a;
d555 1
a555 1
	/* Now we need place for two more moves -- diwstrt */
d561 15
a575 5
	/* Now we need place for two more moves -- diagstrt */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplpt[0]));
	*a++ = 0;   /* lets show low memory for default */
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplpt[0])+2);
	*a++ = 0;   /* lets show low memory for default */
d577 1
a577 1
	a = c->copinit->sprstrtup;
d582 2
a583 2
	    io->hsprtdef[i].pos = 0xFE00;
	    io->hsprtdef[i].ctl = 0xFF00;
d608 1
a608 1
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->cop2jmp));
d613 1
a613 1
	io->cop2ptr = a;
d631 1
a631 1
    io->dmaconw = BITSET|DMAF_BLITTER;
d811 2
a812 2
    io->color00[0] = 0xfff;
    io->color00[1] = 0xfff;
d815 1
a815 1
    io->dmaconw = BITSET|DMAF_COPPER|DMAF_RASTER|DMAF_SPRITE;
d837 1
a837 1
    io->intenaw = INTF_BLIT;	/* turn this cycle-sucking bitch off */
d919 1
a919 1
struct AmigaRegs *io;
@


39.5
log
@ removed calcivg declaration (it's in a.protos).
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.4 91/09/23 11:05:53 spence Exp Locker: chrisg $
d509 1
@


39.4
log
@checks that SHIRES and HIRES HAM modes can be displayed with available
MemType before clearing DI_AVAIL_NOCHIPS flag in the database.
Removed another RGA looping problem when looking for Denise type.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.3 91/08/29 15:01:58 spence Exp Locker: spence $
a146 1
int CalcIVG();
@


39.3
log
@no more BADFMODE
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.2 91/08/29 11:28:23 spence Exp Locker: spence $
d201 6
a206 6
			{	/* check bandwidth */
				if ((((dinfo->ModeID & (SUPERHIRES | HAM)) == (SUPERHIRES | HAM))
				    && (GB->MemType == BANDWIDTH_4X))
				   ||
				    (((dinfo->ModeID & (HIRES | HAM)) == (HIRES | HAM))
				     && GB->MemType))
d208 6
a213 1
					dinfo->NotAvailable &= ~DI_AVAIL_NOCHIPS;
d425 1
d427 1
a427 1
    Denise = (io->deniseid & 0xff);
d429 1
a429 1
    if (Denise != (io->deniseid & 0xff) )
@


39.2
log
@newdefras() and defras() make fmode = 0.
Removed another busy-wait looping on an RGA register by reading the
RGA into a variable.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.1 91/08/27 16:33:25 spence Exp Locker: spence $
d36 1
a36 1
#define BADFMODE
@


39.1
log
@db_avail() checks for DIPF_IS_AA, and bandwidth before making AA-only
modes available.
Sets new Gfxbase->TopLine to 0xc.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 39.0 91/08/21 17:16:36 chrisg Exp Locker: spence $
d16 1
d36 1
d44 7
d821 1
a821 1
	struct AmigaRegs *io;
d825 1
a825 1
	io = &custom;
d830 5
d858 1
a858 1
	struct AmigaRegs *io;
d860 2
d865 6
a870 1
	io = &custom;
d884 5
a888 1
	while ((io->vhposr & 0xff00)== 0xff00); /* avoid critical region */
@


39.0
log
@Bumped
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 38.8 91/08/20 16:05:44 chrisg Exp Locker: chrisg $
d19 2
a28 1
#include "/copper.h"
d167 4
d187 1
a187 1
			if(GB->ChipRevBits0 & (GFXF_HR_DENISE | GFXF_AA_LISA)) 
d191 11
d555 3
a557 2
	*a++ = COPPER_WAIT|0x0C00;
	*a++ = 0xFFFE;  /* wait for line 10 */
d559 2
a560 2
	*a++ = COPPER_WAIT|0x0C00;
	*a++ = 0xFFFE;  /* wait for line 10 */
@


38.8
log
@ added allocbitmap-type calls
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 38.7 91/08/07 13:51:40 chrisg Exp Locker: chrisg $
@


38.7
log
@added SetRGB32 and SetABPenDrMd
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 38.6 91/07/22 15:15:01 spence Exp Locker: chrisg $
d148 4
d349 4
@


38.6
log
@No longer checks for AA chips at power up time.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 38.5 91/07/12 16:30:59 chrisg Exp Locker: spence $
d146 3
d343 2
@


38.5
log
@added loadrgb32 call to vector table.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 38.4 91/07/03 10:52:06 chrisg Exp Locker: chrisg $
d146 1
d339 1
d378 16
d414 1
a414 7
	denise_chip_id= (io->deniseid) & 0xff;
	for (i = 0; i < 16 ; i++)
		if ( denise_chip_id != (io->deniseid & 0xff) )
		{
			denise_chip_id = -1;	/* all bits set=no ext features */
			break;
		}
a444 2
    if (agnus_chip_id & 0x02)	/* alice bit set */
	c->ChipRevBits0 |= GFXF_AA_ALICE;
d446 2
a447 29
/* denise ID bits according to Raible:
 *	orig	XXXX XXXX
 *	ecs     1111 1100
 *	ecs2	1110 1100	ecs fixed for video toaster
 *	lisa    1111 1000
 *	AAA	???? 0100
 *
 *	B0=unused
 *	B1=does this chip support ECS screen modes?
 *	B2=does this chip support AA screen modes?
 *
 * memory type is defined in bits 8 and 9 of io->deniseid.
 *			Bit9 Bit8
 * NmlCAS, 16BitBus	 0    0		1x
 * NmlCAS, 32BitBus	 0    1		2x
 * DblCAS, 16BitBus	 1    0		2x
 * DblCAS, 32BitBus	 1    1		4x
 *
*/

    if (!(denise_chip_id & 0x04))
    {
    	/* we have a Lisa */
    	c->ChipRevBits0 |= (GFXF_AA_LISA | GFXF_HR_DENISE);
    	c->MemType = (((~(io->deniseid)) & 0x0300) >> 8);
    }
    else
	if (!(denise_chip_id & 0x02))
		c->ChipRevBits0 |= GFXF_HR_DENISE;
@


38.4
log
@  Added getOPen to function list.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 38.3 91/06/07 15:57:28 spence Exp Locker: chrisg $
d145 1
d337 1
@


38.3
log
@bwshifts[]. NB ALSO - sets GfxBase->Debug to 1. remember to remove this.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 38.2 91/06/03 16:48:54 chrisg Exp Locker: spence $
d121 1
d335 1
@


38.2
log
@  changed palette entry function names, and added GetSet functions to list.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 38.1 91/05/30 13:22:51 chrisg Exp Locker: chrisg $
d31 1
d346 1
d786 3
@


38.1
log
@  Added my palette functions to vectbl
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 38.0 91/05/29 17:04:48 spence Exp Locker: chrisg $
d136 2
a137 2
int FreePalEntry();
int AllocPalExclusive();
a138 1
int AllocAbsPalExclusive();
a140 1
int AllocAbsPalShared();
d142 1
d298 2
a299 2
	FreePalEntry,
	AllocPalExclusive,
a326 1
	AllocAbsPalExclusive,
a328 1
	AllocAbsPalShared,
d330 3
@


38.0
log
@Initial AA stuff.
Look for Alice and Lisa. Determine memory type.
Added CalcIVG() to list of functions.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 37.14 91/05/20 11:08:41 chrisg Exp Locker: spence $
d136 8
d299 2
a300 2
	ExtFuncGfx,	/* bart - 05.29.86 - do not remove,replace only! */
	ExtFuncGfx,	/* bart - 05.29.86 - do not remove,replace only! */
d327 6
@


37.14
log
@Added prototypes, improved warnings, and glue code. still needs work.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 1.1 91/05/20 10:40:16 chrisg Exp $
a15 4
#include <graphics/gfx.h>
#include <graphics/gfxbase.h>
#include <graphics/view.h>
#include <graphics/display.h>
a16 1
#include <graphics/copper.h>
d22 6
a27 1

d31 2
a32 5
#define PROTOTYPE_DISPLAY

#ifdef	PROTOTYPE_DISPLAY

#include "/displayinfo_internal.h"
a39 5
#endif

/*#define GENLOCKDEBUG*/
#define CHECK_GENLOCK

a45 2
/*#define RAMDEBUG*/
/*#define FUCKTHISJOB*/
a52 3
/*#define COPPER_SELFTEST*/

/*#define DEBUG*/
a56 6
#ifdef KILLTEXT
Text()
{
    kprintf("rom text routine called\n");
}
#else
a57 1
#endif
d135 1
a143 4
#ifdef	PROTOTYPE_DISPLAY

#define CLIPOSCAN

a159 1
#ifdef CLIPOSCAN
a160 1
#endif
d164 1
a164 1
			if(GB->ChipRevBits0 & GFXF_HR_DENISE) 
a168 1
#ifdef CLIPOSCAN
a179 1
#endif
a180 1
#ifdef CHECK_GENLOCK
a187 1
#endif
d217 1
a217 1
		   cook_chunk(record,chunk,sizeof(*chunk),DTAG_MNTR,ID))
d220 1
a220 1
		    if(uncook_chunk(record,chunk,numbytes,DTAG_MNTR,ID)) break;
a226 40
bind_all(tags, cn)
struct TagItem tags[];
struct RomCompressedNode *cn;
{
    int  count = 0;
    BYTE num = cn->cno;

    if(!(num < 0))
    {
	ULONG monitor_id = cn->cid;
	count++;

	while(!(--num < 0 ))
	{
		ULONG mode_id = (cn+count)->cid;
		struct DisplayInfoRecord *mode = 
		    find_info( monitor_id << 16 | mode_id );
		bind_record( mode, tags, cn+count );
		count++;
	}
    }

    return( count );
}

bind_db(data,tags)
struct RomCompressedNode data[];
struct TagItem tags[];
{
    int subtotal, total = 0;

    while(subtotal = bind_all(tags,data+total)) 
    {
	    total += subtotal;
    }
    return( total );
}

#endif

d318 1
a321 1
#define RGB
a323 1
#ifdef RGB
a327 6
#else
    0x000, 0xfd5, 0xf25, 0xbf5, 0xf75, 0xfb5, 0x845, 0x00f,
    0x8c5, 0x825, 0x8fb, 0x875, 0x8b6, 0x849, 0x809, 0x004,
    0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF,
    0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF
#endif
d330 2
a344 4
#ifdef BARTDEBUG
	kprintf("new_monitorspec: \"%s\" monitorspec @@0x%08lx\n",
		 mspc->ms_Node.xln_Name,mspc);
#endif
a383 6
#ifdef FUCKTHISJOB
	kprintf("The Wizards' 6526 graphicslib  version 26.1 May 27,1985\n");
	kprintf("address of deniseid=%lx\n",&io->deniseid);
	kprintf("agnus rev = %lx\n",agnus_chip_id);
	kprintf("denise rev = %lx\n",denise_chip_id);
#endif
a397 15
    /* MakeLibrary initialize the library data to zero */
#ifdef NOCLEARMAKE
    c->SpriteReserved = 0;
    c->Flags = 0;       /* used for own/disown of blitter */
    /* set up default bplcon0 */
    c->gfxbltfree = 0;
    c->ActiView = 0;
    c->Debug = 0;
    c->BeamSync = 0;
    c->blthd = 0;
    c->bsblthd = 0;
    c->Modes = 0;
	c->BlitOwner = 0;		/* not owned by anyone */
#endif

d401 9
a409 4
		struct Resident *resi;
		if (resi = FindResident(UtilName))
			InitResident(resi, NULL);
	}
d412 3
a414 1
	    c->ChipRevBits0 |= GFXF_HR_AGNUS;
d416 19
a434 2
    if (! (denise_chip_id & 0x02))
	    c->ChipRevBits0 |= GFXF_HR_DENISE;
d436 9
a444 6
/* denise ID bits according to raible:
	orig	XXXX XXXX
	ecs     1111 1100
	ecs2	1110 1100	ecs fixed for video toaster
	lisa    1111 1000
	AAA		???? 0100
a445 4
	B0=unused
	B1=does this chip support ECS screen modes?
	B2=does this chip support AA screen modes?
*/
d448 1
a448 1
	c->BlitNest = -1;
a475 25
#ifdef	COPPER_SELFTEST
/*      draincop(c);*/
	*a++ = COPPER_MOVE|(0x1FE&(long)(&io->dmaconw));
	*a++ = BITCLR|DMAF_COPPER;  /* shut the muther off */
	*a++ = 0xFFFF;
	*a++ = 0xFFFE;
	do
	{
	    io->cop1jmp = 1;    /* do explicit jump to cop1 */
	    io->dmaconw = BITSET|DMAF_COPPER;   /* turn on,poke it to drain it */
	    i = 0;
	    while (io->dmaconr&DMAF_COPPER)
	    {
		i++;
		if (i>5000)
		{
#ifdef DEBUG
		    kprintf("Copper not draining\n\r");
#endif
		    return;
		}
	    }
	}
	while (io->dmaconr&DMAF_COPPER);
#endif
d581 3
d585 1
d601 1
a601 1
    c->timsrv.is_Code = &timasm;
d630 1
a630 1
    io->intenaw = BITSET|INTF_VERTB;
a662 7
#ifdef ULTRA_RES
    c->NormalDisplayRows = 800;
    c->NormalDisplayColumns = 1024;
    c->NormalDPMX = 4096;
    c->NormalDPMY = 4096;
#endif

a677 2

#ifdef	PROTOTYPE_DISPLAY
a679 1
#endif
a711 1
#ifdef		PROTOTYPE_DISPLAY
a715 9
#endif

#ifdef		UNDEFINED
		/* experimental default id aliasing */
		c->monitor_id = (c->DisplayFlags&PAL)? 
						PAL_MONITOR_ID >> 16: 
						NTSC_MONITOR_ID >> 16;
#endif

a722 69
/* #define ADD_VGA */

#ifdef ADD_VGA
	/* initialize standard vga monitorspec and add to list */
	{
	    struct MonitorSpec *mspc = new_monitorspec(c,REQUEST_SPECIAL |
							((c->DisplayFlags&PAL)?
						        REQUEST_PAL:
						        REQUEST_NTSC),
				   			VGA_MONITOR_NAME);
	    if(mspc)
	    {
		struct SpecialMonitor *sm = mspc->ms_Special;
	
		/* initialize */
	    
		mspc->total_rows =  (c->DisplayFlags&PAL)? 
				    (STANDARD_PAL_ROWS*2):
				    (STANDARD_NTSC_ROWS*2);

		mspc->total_colorclocks = VGA_COLORCLOCKS;

		/* ratioh = 1/2 */
		mspc->ratioh = 
		(mspc->total_colorclocks<<RATIO_FIXEDPART)/STANDARD_COLORCLOCKS;

		/* ratiov = 2 */
		mspc->ratiov = 
		(STANDARD_COLORCLOCKS<<RATIO_FIXEDPART)/mspc->total_colorclocks;

		/* reset denise max displayable */
		mspc->DeniseMaxDisplayColumn = MAX_DENISE(mspc);
		mspc->DeniseMinDisplayColumn = VGA_DENISE_MIN;

		/* reset denise min displayable */
		mspc->min_row = MIN_VGA_ROW;

		/* set specific  hblank, hsync, beamcon0 for double-scan mode */

		if(sm)
		{
		    /* monitor specific voodoo */
		    sm->hblank.asi_Start 	= VGA_HBSTRT;
		    sm->hsync.asi_Start 	= VGA_HSSTRT;
		    sm->hsync.asi_Stop 		= VGA_HSSTOP;
		    sm->hblank.asi_Stop 	= VGA_HBSTOP;
		    sm->vblank.asi_Start 	= VGA_VBSTRT;
		    sm->vsync.asi_Start 	= VGA_VSSTRT;
		    sm->vsync.asi_Stop 		= VGA_VSSTOP;
		    sm->vblank.asi_Stop 	= VGA_VBSTOP;
		}
		
		/* initialize view range bound */
		/* vlimit(mspc,&mspc->ms_LegalView,NULL); */
		/* forced centering for 640 x 480 -- experimental */

		mspc->ms_LegalView.MinX = mspc->ms_LegalView.MaxX = 0x41;
		mspc->ms_LegalView.MinY = mspc->ms_LegalView.MaxY = 0x25;

		AddHead(&c->MonitorList, mspc);

#ifdef		PROTOTYPE_DISPLAY
		activate_mspc( ( VGA_MONITOR_ID ), mspc );
#endif
	    }
	}
#endif
	/* bart -- mspc */

a744 2
    /* c->LOFlist = c->copinit->sprstrtup+2*(32+6) */;
    c->LOFlist = c->copinit->wait_forever;
a763 1
#ifdef	PROTOTYPE_DISPLAY
a767 1
#endif
d769 1
a830 2
#define	MKS_GENLOCK_CHECK

a839 2
#ifdef	MKS_GENLOCK_CHECK

d841 1
a892 23
#else	/* not MKS_GENLOCK_CHECK */
    int shit;

    /* wait for vbeam position between 5 and 220  */
    while ( (vbeampos() > 220) || (vbeampos() < 5) );

    /* turn on genloc and see if the horizontal counter still turns around */
    io->bplcon0 = (GENLOCK_AUDIO | GENLOCK_VIDEO);

	/* yucch a software oneshot */
    /* now check to see if horizontal counter is going */
    /* should be atleast 2 more later */
    for(count = 0;count < 300; count ++)
		shit=io->serdatr;	/* Count delay in _chip cycles_ */

    pos = vhposr & 0xFF;

    /* wait abit */
    for (count = 0; count < 2 ; count++)
		shit=io->serdatr;	/* Count delay in _chip cycles_ */

#endif	/* MKS_GENLOCK_CHECK */

a916 4
#ifdef GENLOCKDEBUG
    kprintf("genloc found %lx\n",vhposr&0xFF);
#endif
#ifdef CHECK_GENLOCK
a917 3
#else
	return (0);
#endif
@


37.13
log
@uses d.protos
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 37.12 91/05/03 15:46:14 chrisg Exp Locker: spence $
d29 1
d104 1
a104 1
int CBump(),CMove(),CWait(),VBeamPos();
a133 1
int UCopperListInit();
a149 2
int OpenMonitor(),CloseMonitor();

d303 1
a303 1
int (*vectbl[])() =
d540 1
a540 1
	c->SimpleSprites = AllocMem(sizeof(int *)*8,MEMF_CLEAR);
d673 1
a673 1
    c->vbsrv.is_Code = &vbasm;
d687 1
a687 1
    c->bltsrv.is_Code = &bltasm;
d726 1
a726 1
    c->hash_table = AllocMem((HASHTABLE_NUMENTRIES * 4),MEMF_CLEAR);
d730 1
a730 1
	    eb = c->ExecBase;
d777 1
a777 1
	c->LCMptr = AllocMem(MAXBYTESPERROW,MEMF_CHIP);
d909 1
a909 1
	c->a2024_sync_raster = AllocMem(128,MEMF_CHIP|MEMF_CLEAR);
d950 1
a950 1
	mspc = open_monitor(NULL,NULL); /* new interface */
d961 1
a961 1
newdefras(c,hr,vr)
@


37.12
log
@ reduced # of compiler warnings. still too high.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 37.11 91/05/02 12:48:03 chrisg Exp Locker: chrisg $
d26 1
a151 3
int FindDisplayInfo(), NextDisplayInfo(), AddDisplayInfo();
int GetDisplayInfoData(), AddDisplayInfoData(), SetDisplayInfoData();

d162 1
a162 1
struct DisplayInfoRecord *find_info();
@


37.11
log
@ changed "../" to "/" for native build
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 37.10 91/04/22 10:38:44 spence Exp Locker: chrisg $
d142 1
a142 1
long GfxNew(),GfxFree(),GfxAssociate(),GfxLookUp();
d160 7
d171 1
a171 1
db_avail( GB )
d222 1
a222 1
			if((record = record->rec_Node.rcn_Parent)
d231 1
a231 1
activate_mspc( monitor, mspc )
d300 1
a300 1
nop()
d305 1
a305 1
};
d415 1
a415 1
    struct MonitorSpec *mspc = gfxnew(MONITOR_SPEC_TYPE);
d438 1
a438 1
struct GfxBase *cpwrup(c)
d546 1
a546 1
	c->copinit = a;
d998 1
a998 1
defras(c)
a1002 1
	long t;
@


37.10
log
@Changed limits of where in the active display we will check for
genlock for.  This is to make sure that all machines will work
with this, even if the machine is slower than the standard
7MHz 68000.  (down to about 2.5MHz...  But who would run such a
machine anyway? :-)
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 37.9 91/04/21 19:57:35 spence Exp Locker: spence $
d24 2
a25 2
#include "../cia8520.h"
#include "../sane_names.h"
d33 1
a33 1
#include "../displayinfo_internal.h"
@


37.9
log
@whoops - left in debug statements.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 37.8 91/04/21 16:56:08 spence Exp Locker: spence $
d1031 6
a1036 2
    /*	Wait until we are in the active part of the display */
    while ((vbeampos() > 220) || (vbeampos() < 10));
d1083 1
a1083 1
#else	/* not MKS_GENLOCK_CHECK
@


37.8
log
@New genloc checking code by MKS.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 37.7 91/04/20 20:19:28 bryce Exp Locker: spence $
d43 1
a43 1
#define GENLOCKDEBUG
@


37.7
log
@A @@#$%^&*! delay loop!  In our modern systems!  Fast 68030 and 68040
systems often crash at boot -- they seem to pop into genlock mode.
No wonder with code like this.  Take the delay in chip cycles instead
of CPU cycles.  !!!!!!!!!DO NO RELEASE THIS CODE AS-IS!!!!!!!!!!
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 37.7 91/04/20 20:06:33 bryce Exp Locker: bryce $
d912 1
a912 1
#define	MHH_BYTES	2+2*MAX_HEDLEYSPRITE_HEIGHT+2
d918 1
a918 1
		c->hedley_sprites1[i] = c->hedley_sprites[i]+(MHH_BYTES)*2;
d1018 2
a1025 1
    int shit;
d1028 54
d1085 1
a1085 1
    /* turn on genloc and see if the horizontal counter sill turns around */
d1099 2
@


37.6
log
@  changed deniseID code to handle second rev of ECS chip. Now checks
bit 1 of deniseID to determine whether or not to enable ECS modes.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 37.5 91/03/28 20:30:06 spence Exp Locker: chrisg $
d43 1
d1024 1
d1033 1
a1033 1
    for(count = 0;count < 300; count ++); /* yucch a software oneshot */
d1036 3
d1042 3
a1044 1
    for (count = 0; count < 2 ; count++) ;
@


37.5
log
@recognises LISA ID value, and sets GFXF_HR_DENISE if found.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 37.4 91/03/14 18:48:01 spence Exp Locker: spence $
d454 1
a454 1
			denise_chip_id = 0;
d503 15
a517 2
    if ((denise_chip_id == 0xf8) || (denise_chip_id == 0xfc))
	    c->ChipRevBits0 |= GFXF_HR_DENISE;	/* 0xf8 is for AA machine, which is ECS-compatible */
@


37.4
log
@InitResident(utility.library)
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 37.3 91/02/28 13:57:16 spence Exp Locker: spence $
d503 2
a504 4
    if (denise_chip_id == 0xfe)
	    c->ChipRevBits0 |= GFXF_HR_DENISE;
    if (denise_chip_id == 0xfc)
	    c->ChipRevBits0 |= GFXF_HR_DENISE;
@


37.3
log
@hash_table size now calculated from HASHTABLE_NUMENTRIES - was hardcoded.
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 37.2 91/02/07 16:33:58 spence Exp Locker: spence $
d438 1
d494 6
a499 1
    c->UtilityBase = (ULONG *)OpenLibrary("utility.library",36);
@


37.2
log
@back to 37.0
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 37.0 91/01/07 15:18:57 spence Exp $
d705 1
a705 1
    c->hash_table = AllocMem(1024,MEMF_CLEAR);
@


37.1
log
@Allocated space for new PosCtlData structure in GfxBase
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 37.0 91/01/07 15:18:57 spence Exp Locker: spence $
a25 1
#include "../gels/gelsinternal.h"
a517 1
	c->SpriteCtlData = (ULONG *)AllocMem((sizeof(struct PosCtlData) * 8), MEMF_CLEAR);
@


37.0
log
@initial switchover from V36
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 36.105 90/12/10 15:13:53 bart Exp Locker: spence $
d26 1
d519 1
@


36.105
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 36.104 90/12/10 15:11:02 bart Exp Locker: bart $
@


36.104
log
@changed defras to zero bitplanes.. bart
prevents screen flashing with garbage when lo-memory
@
text
@d3 1
a3 1
*	$Id: cpwrup.c,v 36.103 90/07/27 16:56:04 bart Exp Locker: bart $
d983 1
a983 1
	io->bplcon0 = 0x0000|c->system_bplcon0; /* changed to zero bitplanes */
@


36.103
log
@id
@
text
@d3 1
a3 1
*	$Id: $
d983 1
a983 2
    /*  dmaconw = DMA_RASTER|DMA_SPRITE;*/
	io->bplcon0 = 0x1000|c->system_bplcon0;
@


36.102
log
@initialize default monitorspec with pal/ntsc name string
@
text
@d3 1
a3 1
*	$Header: /usr2/bart/v1.4/src/kickstart/working/graphics/c/RCS/cpwrup.c,v 36.101 90/04/11 18:39:40 bart Exp Locker: bart $
@


36.101
log
@graphics36.139 -- cliposcan back in
@
text
@d3 1
a3 1
*	$Header: /usr2/bart/v1.4/src/kickstart/working/graphics/c/RCS/cpwrup.c,v 36.100 90/04/11 16:44:42 bart Exp Locker: bart $
d782 3
a784 1
				       DEFAULT_MONITOR_NAME);
d803 7
@


36.100
log
@undefined CLIPOSCAN for beta 5 -- broken, bart
@
text
@d3 1
a3 1
*	$Header: /usr2/bart/v1.4/src/kickstart/working/graphics/c/RCS/cpwrup.c,v 36.99 90/04/06 18:21:45 bart Exp Locker: bart $
d161 1
a161 1
/* #define CLIPOSCAN -- broken, bart */
@


36.99
log
@cliposcan
@
text
@d3 1
a3 1
*	$Header: /usr2/bart/v1.4/src/kickstart/working/graphics/c/RCS/cpwrup.c,v 36.98 90/03/28 09:10:09 bart Exp Locker: bart $
d161 2
d179 1
d181 1
d190 1
d202 1
@


36.98
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/graphics/c/RCS/cpwrup.c,v 36.97 90/03/15 13:22:28 bart Exp Locker: bart $
d168 2
a169 2
	struct DisplayInfoRecord *record;
	struct RawDisplayInfo *dinfo;
d171 1
a171 1
	/* not vanilla */
d173 5
a177 4
	if((record = find_info( ID ))
	&& (dinfo  = find_tag(&record->rec_Tag,DTAG_DISP)))
	{
	    struct RawMonitorInfo *minfo;
d179 1
a179 1
	    record->rec_Control = dinfo->ModeID;
d181 4
a184 4
	    if(GB->ChipRevBits0 & GFXF_HR_DENISE) 
	    {
		dinfo->NotAvailable &= ~DI_AVAIL_NOCHIPS;
	    }
d186 12
d199 7
a205 7
	    if(GB->system_bplcon0 & GENLOCK_VIDEO)
	    {
		if(!(dinfo->PropertyFlags & DIPF_IS_GENLOCK))
		{
		    dinfo->NotAvailable |= DI_AVAIL_NOTWITHGENLOCK;
		}
	    }
d208 6
a213 6
	    if((record = record->rec_Node.rcn_Parent)
	    && (minfo  = find_tag(&record->rec_Tag,DTAG_MNTR)))
	    {
		if(minfo->Mspc) dinfo->NotAvailable &= ~DI_AVAIL_NOMONITOR;
	    }
	}
@


36.97
log
@fix B6160 sprite dma 
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.96 90/02/28 09:38:21 bart Exp $
@


36.96
log
@no more displaymonitors field in gfxbase
@
text
@@


36.95
log
@check genlock in db_avail
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.94 90/01/23 19:31:07 kodiak Exp $
a681 1
    c->DisplayMonitors = NTSC_MONITOR|PAL_MONITOR;
@


36.94
log
@CompileFont -> ExtendFont & StripFont
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.93 90/01/23 14:59:32 kodiak Exp $
d184 10
@


36.93
log
@add CompileFont function
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.92 90/01/23 14:31:27 kodiak Exp $
d76 2
a77 1
int OpenFont(),CloseFont(),FontExtent(),WeighTAMatch(),CompileFont();
d352 2
a353 1
	CompileFont,
@


36.92
log
@rename WeighFontMatch to WeighTAMatch
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.91 89/11/29 13:20:10 bart Exp $
d76 1
a76 1
int OpenFont(),CloseFont(),FontExtent(),WeighTAMatch();
d351 1
@


36.91
log
@rectify library node
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.90 89/10/31 13:00:08 bart Exp $
d76 1
a76 1
int OpenFont(),CloseFont(),FontExtent(),WeighFontMatch();
d349 1
a349 1
	WeighFontMatch,
@


36.90
log
@lcm memory before db_startup
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.89 89/10/26 11:36:05 bart Exp $
d392 1
d410 5
@


36.89
log
@eraserect
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.88 89/09/04 17:15:28 kodiak Exp $
d716 2
d719 6
d726 1
a726 1
	/* open the display database */ 
a870 3
    c->LCMptr = AllocMem(MAXBYTESPERROW,MEMF_CHIP);
    c->LastChanceMemory = (struct SignalSemaphore *)AllocMem(sizeof(struct SignalSemaphore),0);
    InitSemaphore(c->LastChanceMemory);
@


36.88
log
@add WeighFontMatch function
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.87 89/08/22 09:12:35 bart Exp $
d156 1
a163 3
    struct ExecBase *eb,**peb;
    peb = (struct ExecBase **)(4);
    eb = *peb;
a164 2
    stuf_base( GB );

a190 2

    stuf_base( eb );
d193 1
a193 2
activate_mspc( GB, monitor, mspc )
struct GfxBase *GB;
a198 3
    struct ExecBase *eb,**peb;
    peb = (struct ExecBase **)(4);
    eb = *peb;
a199 2
    stuf_base( GB ); /* remove */

a219 2

    stuf_base( eb );
d350 1
d397 2
a398 1
struct GfxBase *cpwrup()
a401 1
    register struct GfxBase *c;
d434 1
d437 1
d454 2
a455 6
	if (agnus_chip_id & 0x20)	/* agnus hr bit set ? */
		c->ChipRevBits0 |= GFXF_HR_AGNUS;
	if (denise_chip_id == 0xfe)
		c->ChipRevBits0 |= GFXF_HR_DENISE;
	if (denise_chip_id == 0xfc)
		c->ChipRevBits0 |= GFXF_HR_DENISE;
d457 7
d671 3
a673 3
	    struct ExecBase *eb,**peb;
	    peb = (struct ExecBase **)(4);
	    eb = *peb;
d675 1
a675 1
	    else				eb->VBlankFrequency = 60;
a717 6
    {
	struct ExecBase *eb,**peb;
	peb = (struct ExecBase **)(4);
	eb = *peb;
	stuf_base(c); 

a718 1

a719 3

	stuf_base(eb);
    }
d752 4
a755 5
		activate_mspc( c, 
			     ( c->DisplayFlags & PAL ) ?
			     (  PAL_MONITOR_ID ) :
			     ( NTSC_MONITOR_ID ), 
			       mspc );
d827 1
a827 3
		activate_mspc( c, 
			     ( VGA_MONITOR_ID ),
			       mspc );
a873 4
	struct ExecBase *eb,**peb;
	peb = (struct ExecBase **)(4);
	eb = *peb;
	stuf_base(c); 
a876 2
	stuf_base(eb);

d878 1
a878 1
	activate_mspc( c, ( DEFAULT_MONITOR_ID ), mspc );
a883 1

@


36.87
log
@single thread access to ActiView hardware copper list
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.86 89/08/21 11:10:10 bart Exp $
d76 1
a76 1
int OpenFont(),CloseFont(),FontExtent();
d363 1
@


36.86
log
@GetVPModeID, ModeNotAvailable
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.85 89/08/17 11:19:23 bart Exp $
d716 8
d910 1
@


36.85
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.84 89/08/11 10:53:33 bart Exp $
d155 2
d361 2
@


36.84
log
@pixelline and pixelarray functions
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.83 89/06/23 16:08:56 bart Exp $
a232 64

#ifdef UNDEFINED

tag_copy(tag,buf)
struct TagItem *tag;
struct TagItem *buf;
{
	int count = 0;

	while( (++count) && (tag->ti_Tag != DTAG_DONE) )
	{
	    /* stupid compiler ! substiture for brain dead switch -- bart */

	    if( tag->ti_Tag == DTAG_IGNORE )
	    {
		ULONG ignore = tag->ti_Data + 1;

		--count; 
		do 
		{
		    count++;
		    if( buf ) *buf++ = *tag; 
		    tag++;
		}   while( --ignore );
		continue;
	    } 

	    if( tag->ti_Tag == DTAG_MORE )
	    {
		--count; tag = (struct TagIemt *)tag->ti_Data;
		continue;
	    } 	

	    /* default case */
	    {
		if( buf ) *buf++ = *tag; tag++;
		continue;
	    }
	}  

	if( buf ) *buf++ = *tag++; /* terminator */

	return( count );
}

struct DisplayInfoRecord *bind_record( record, tags, cn )
struct DisplayInfoRecord *record;
struct TagItem *tags;
struct RomCompressedNode *cn;
{
    int size = ( tag_copy( tags+cn->tag, NULL ) * sizeof( struct TagItem ) );
    struct TagItem *copytags = AllocMem( size, MEMF_PUBLIC | MEMF_CLEAR );

    if( copytags )
    {
	tag_copy( tags+cn->tag, copytags ); /* decompress data */

	add_chunk(record,copytags,size,copytags->ti_Tag,INVALID_ID);

	FreeMem( copytags, size );    /* delete temporary copy */
    }
}

#endif
@


36.83
log
@TODA_SAFE
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.82 89/05/08 15:26:05 bart Exp $
d152 3
d419 4
@


36.82
log
@pass NULL instead of sizeof(vectbl) to MakeLibrary
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.81 89/05/05 12:25:35 bart Exp $
d47 1
d49 1
d704 1
a704 1
    /* initialize timer for me */
d720 6
a725 6
	Disable();
	c->system_bplcon0 = get_genloc(io) | COLORON;
	/* initialize to standard defaults */
	c->DisplayMonitors = NTSC_MONITOR|PAL_MONITOR;
	c->DisplayFlags = (c->system_bplcon0 & GENLOC)|get_pal(agnus_chip_id);
	Enable();
d727 2
a728 2
	/* get some memory for association hash table */
	c->hash_table = AllocMem(1024,MEMF_CLEAR);
d730 15
a744 15
	{
		struct ExecBase *eb,**peb;
		peb = (struct ExecBase **)(4);
		eb = *peb;
		if (c->DisplayFlags & PAL)	eb->VBlankFrequency = 50;
		else				eb->VBlankFrequency = 60;
	}
	if (c->DisplayFlags & NTSC)
	{
		c->MaxDisplayRow = STANDARD_NTSC_ROWS - 1;
		/* following is for 1080 monitor */
		c->NormalDisplayRows = 200;
		c->NormalDPMX = 1280;	/* 320 X 1000/250mm */
		c->NormalDPMY = 1098;	/* 200 X 1000/182mm */
	}
d746 8
a753 8
	if (c->DisplayFlags & PAL)
	{
		c->MaxDisplayRow = STANDARD_PAL_ROWS - 1;
		c->NormalDisplayRows = 256;
		/* for philips monitor */
		c->NormalDPMX = 1226;	/* 320 X 1000/261mm */
		c->NormalDPMY = 1299;	/* 256 X 1000/197mm */
	}
d755 2
a756 2
	c->MinDisplayColumn = STANDARD_DENISE_MIN; /* bart -- min left clip */
	c->MaxDisplayColumn = STANDARD_DENISE_MAX; /* bart -- max right clip */
d758 3
a760 3
	c->NormalDisplayColumns = 640;
	/* MicrosPerLine time 256 */
	c->MicrosPerLine = 16285;		/* approximately */
d770 5
a774 5
	{
	    struct ExecBase *eb,**peb;
	    peb = (struct ExecBase **)(4);
	    eb = *peb;
	    stuf_base(c); 
d776 1
a776 1
	    /* open the display database */ 
d778 1
a778 1
	    c->DisplayInfoDataBase = db_startup();
d780 2
a781 2
	    stuf_base(eb);
	}
d1018 1
a1018 1
get_genloc(io)
d1020 1
d1024 2
a1025 2
	long	WC_ZERO=0;
	/* must be run whiel disabled */
d1028 1
d1031 1
d1036 1
d1041 17
d1059 1
d1062 1
@


36.81
log
@fixed pal powerup old agnus bug
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.80 89/04/29 15:41:51 bart Exp $
d498 1
a498 1
				    ,0,0,sizeof(struct GfxBase),sizeof(vectbl));
@


36.80
log
@cm->Type checking
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.79 89/04/12 10:53:45 bart Exp $
d1063 1
a1063 1
	    if ((i = vbeampos()) > 270) return(PAL);
d1066 2
a1067 2
		    /* wait till vbeampos 255 */
		    while ( (i = vbeampos()) < 100);
d1070 1
a1071 1
			    if (i > 270)	return(PAL);
d1079 1
@


36.79
log
@added gfx_lib_name to interrupt handler, servers
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.78 89/04/06 13:32:34 kodiak Exp $
@


36.78
log
@LibNode.lib_Node...., not .lh_Node
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.77 89/03/21 13:14:06 bart Exp $
d675 1
d688 1
d700 1
@


36.77
log
@added FontExtent() for kodiak -- bart
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.76 89/03/16 14:07:15 bart Exp $
d527 1
a527 1
    c->LibNode.lh_Node.ln_Name = gfx_lib_name;
@


36.76
log
@fixed loadview scanrate change timing interaction bug!!! studley bart
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.75 89/03/06 20:52:03 bart Exp $
d74 1
a74 1
int OpenFont(),CloseFont();
d413 1
@


36.75
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.74 89/03/02 18:29:51 bart Exp $
d590 1
d592 1
d597 1
a597 1
	/* Now we need place for two more moves */
d600 1
a600 1
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplpt[0]));
d603 1
d608 1
d610 1
d621 1
d627 2
a628 1
	/* these just a place saver here for genloc modes */
d631 1
a631 1
	*a++ = COPPER_MOVE|(0x1FE&(int)(&io->bplpt[0]));
d633 1
d635 1
d638 1
d643 1
d645 1
@


36.74
log
@genlock
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.73 89/02/23 13:16:34 bart Exp $
d1010 1
a1010 1
    io->bplcon0 = 0x102;
d1026 1
a1026 1
    return(0x102);
@


36.73
log
@DTAG_
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.72 89/02/23 11:10:00 bart Exp $
d621 5
@


36.72
log
@rec_Control and new_mode processing
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.71 89/02/20 16:17:32 bart Exp $
d170 1
a170 1
	&& (dinfo  = find_tag(&record->rec_Tag,TAG_DISP)))
d182 1
a182 1
	    && (minfo  = find_tag(&record->rec_Tag,TAG_MNTR)))
d217 1
a217 1
		   cook_chunk(record,chunk,sizeof(*chunk),TAG_MNTR,ID))
d220 1
a220 1
		    if(uncook_chunk(record,chunk,numbytes,TAG_MNTR,ID)) break;
d237 1
a237 1
	while( (++count) && (tag->ti_Tag != TAG_DONE) )
d241 1
a241 1
	    if( tag->ti_Tag == TAG_IGNORE )
d255 1
a255 1
	    if( tag->ti_Tag == TAG_MORE )
@


36.71
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.70 89/02/20 15:46:25 bart Exp $
d173 2
@


36.70
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.69 89/02/17 22:03:32 bart Exp $
@


36.69
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.68 89/02/17 21:12:39 bart Exp $
a33 1
#include "bind.h"
d753 2
a754 5
	    if( c->DisplayInfoDataBase = db_startup() )
	    {
		bind_db(Bindings, 	      /* choose the data dynamically */
		       (c->DisplayFlags&PAL)? PalDisplayTags: NtscDisplayTags);
	    }
@


36.68
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.67 89/02/17 21:10:51 bart Exp $
@


36.67
log
@NotAvailable
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.66 89/02/17 21:09:00 bart Exp $
d180 2
a181 2
	    if((record = dinfo->rec_Node.rcn_Parent)
	    && (minfo  = find_tag(&record->rec_Tag,TAG_DISP)))
@


36.66
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.65 89/02/16 16:03:36 bart Exp $
d177 1
a177 1
		dinfo->Available &= ~DI_AVAIL_NOCHIPS;
d183 1
a183 1
		if(minfo->Mspc) dinfo->Available &= ~DI_AVAIL_NOMONITOR;
@


36.65
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.64 89/02/16 15:37:44 bart Exp $
d153 38
d225 1
a225 1
    stuf_base( eb ); /* remove when graphics stops using DisplayBaseOffset */
d915 1
a915 1
    /* guarantee that the default monitor is open before returning */ 
d928 4
a931 3
	activate_mspc( c, 
		     ( DEFAULT_MONITOR_ID ),
		       mspc );
a932 1

@


36.64
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.63 89/02/16 15:05:28 bart Exp $
d263 1
a267 1
		ULONG monitor_id = cn->cid;
@


36.63
log
@monitorinfo shared among modes
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.62 89/02/16 10:08:02 bart Exp $
a262 3
	ULONG monitor_id = cn->cid;
	struct DisplayInfoRecord *monitor = find_info( monitor_id );
	bind_record( monitor, tags, cn+count );
d267 1
@


36.62
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.61 89/02/15 16:00:27 bart Exp $
d181 1
a181 1
		    uncook_chunk(record,chunk,numbytes,TAG_MNTR,ID);
d263 3
d270 4
a273 5
		ULONG monitor = cn->cid;
		ULONG mode = (cn+count)->cid;
		struct DisplayInfoRecord *record = 
		    find_info( monitor << 16 | mode );
		bind_record( record, tags, cn+count );
d759 2
a760 2
			     (  PAL_MONITOR_ID << 16 ) :
			     ( NTSC_MONITOR_ID << 16 ), 
d834 1
a834 1
			     ( VGA_MONITOR_ID << 16 ),
d893 1
a893 1
		     ( DEFAULT_MONITOR_ID << 16 ),
@


36.61
log
@DisplayInfoRecord
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.60 89/02/15 13:29:55 bart Exp $
d159 1
a159 1
    struct DisplayMonitor querymonitor;
d175 1
a175 1
		struct DisplayMonitor *chunk = &querymonitor;
d187 1
a187 1
    stuf_base( eb ); /* remove when graphics stops using DisplayInfoDataBaseOffset */
@


36.60
log
@displayinfo function interface
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.59 89/02/15 13:06:29 bart Exp $
d33 1
a33 2
#include <display/record.h>
#include <display/defines.h>
d170 1
a170 1
	    struct Record *record = find_info( ID );
d234 2
a235 2
struct Record *bind_record( record, tags, cn )
struct Record *record;
d269 2
a270 1
		struct Record *record = find_info( monitor << 16 | mode );
@


36.59
log
@merge DisplayInfoDataBase with graphics
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.58 89/02/15 10:29:14 bart Exp $
d149 3
d358 2
a359 2
	ExtFuncGfx,	/* bart - 05.29.86 - place holder,do not remove,replace only! */
	ExtFuncGfx,	/* bart - 05.29.86 - place holder,do not remove,replace only! */
d368 6
@


36.58
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.57 89/02/14 18:22:18 bart Exp $
a32 1
#include <display/display_base.h>
d164 1
a164 1
    while( ( ID = NextDisplayInfo( ID ) ) != INVALID_ID )
d168 1
a168 1
	    struct Record *record = FindDisplayInfo( ID );
d176 1
a176 1
		   GetDisplayInfoData(record,chunk,sizeof(*chunk),TAG_MNTR,ID))
d179 1
a179 1
		    SetDisplayInfoData(record,chunk,numbytes,TAG_MNTR,ID);
d185 1
a185 1
    stuf_base( eb ); /* remove when graphics stops using DisplayBaseOffset */
d188 2
d244 1
a244 1
	AddDisplayInfoData(record,copytags,size,copytags->ti_Tag,INVALID_ID);
d250 2
d267 1
a267 1
		struct Record *record = FindDisplayInfo( monitor << 16 | mode );
d706 2
a707 1
	    if( c->DisplayBase = OpenLibrary(DISPLAY_NAME,36) )
@


36.57
log
@checkpoint
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.56 89/02/14 10:12:36 bart Exp $
d231 2
a232 2
struct Record *bind_record( ID, tags, cn )
ULONG  ID;
d243 1
a243 1
	AddDisplayInfoData(NULL,copytags,size,copytags->ti_Tag,ID);
d264 2
a265 1
		bind_record( ( monitor << 16 | mode ), tags, cn+count );
@


36.56
log
@checkpoint 02.14.89
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.55 89/02/13 18:04:56 bart Exp $
d177 1
a177 1
		   GetDisplayInfoData(record,chunk,sizeof(*chunk),TAG_MSPC,ID))
d180 1
a180 1
		    SetDisplayInfoData(record,chunk,numbytes,TAG_MSPC,ID);
@


36.55
log
@vanilla display library calls
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.54 89/02/11 12:56:15 bart Exp $
@


36.54
log
@removed last vestiges of FindDisplayMonitor()
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.53 89/02/11 12:28:15 bart Exp $
d158 1
d163 1
a163 1
    stuf_base( GB ); /* remove when graphics stops using DisplayBaseOffset */
d165 1
a165 1
    if( GB->DisplayBase )
d167 1
a167 1
	while( ( ID = NextDisplayInfo( ID ) ) != INVALID_ID )
d169 3
a171 1
	    if( ( ID & ~0xFFFF ) == ( monitor & ~0xFFFF ) )
d173 5
a177 3
		struct Record *record = FindDisplayInfo( ID );
		
		if(record)
d179 2
a180 7
		    struct DisplayMonitor *datachunk = 
		    FindTag( &record->rec_Tag, TAG_MSPC );

		    if( datachunk )
		    {
			datachunk->Mspc = mspc;
		    }
d231 2
a232 2
struct Record *bind_record( record, tags, cn )
struct Record *record;
d236 2
a237 3
	int count = tag_copy( tags+cn->tag, NULL );
	struct TagItem *copytags = (struct TagItem *)
	AllocMem( (count * sizeof(struct TagItem)), MEMF_PUBLIC | MEMF_CLEAR );
d239 3
a241 3
	if( copytags )
	{
		tag_copy( tags+cn->tag, copytags );
d243 4
a246 6
		if( AddTag( &record->rec_Tag, copytags ) != copytags )
		{
			FreeMem(copytags, (count * sizeof(struct TagItem)));
		}
	}
	return( record );
d249 1
a249 2
bind_all(parent, tags, cn)
struct Record *parent;
d253 2
a254 2
	int  count = 0;
	BYTE num = cn->cno;
d256 5
a260 1
	if(parent)
d262 4
a265 13
		while(!(num-- < 0 ))
		{
			struct Record *child = FindKey(SubRecord(parent), cn->cid, ~0);
			if(child = bind_record( child, tags, cn ))
			{
				count++;

				while(!(num-- < 0 ))
				{
					count += bind_all(child,tags,cn+count);
				}
			}
		}
d267 1
d269 1
a269 1
	return( count );
d272 1
a272 2
bind_db(GB,data,tags)
struct GfxBase *GB;
d276 1
a276 1
	int subtotal, total = 0;
d278 5
a282 5
	while(subtotal = bind_all(GB->DisplayBase->Root,tags,data+total)) 
	{
		total += subtotal;
	}
	return( total );
d704 1
a704 1
		bind_db(c, Bindings,
@


36.53
log
@note stuf_base
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.52 89/02/11 10:53:46 bart Exp $
d655 1
a655 1
    c->system_bplcon0 = get_genloc(io) | COLORON;
a754 29

		/*
		{
		    struct ExecBase *eb,**peb;
		    peb = (struct ExecBase **)(4);
		    eb = *peb;
		    stuf_base(c); 

		    if(c->DisplayBase)
		    {
			struct Record *record = (struct Record *)
			FindDisplayMonitor((c->DisplayFlags & PAL)?
					   (PAL_MONITOR_ID  << 16):
					   (NTSC_MONITOR_ID << 16));
			if(record)
			{
			    struct DisplayMonitor *monitor = 
				  (struct DisplayMonitor *)
				   FindTag( &record->rec_Tag, TAG_MSPC );

			    if( monitor )
			    {
				monitor->Mspc = mspc;
			    }
			}
		    }
		    stuf_base(eb);
		}
		*/
a828 27
	        /*
		{
		    struct ExecBase *eb,**peb;
		    peb = (struct ExecBase **)(4);
		    eb = *peb;
		    stuf_base(c); 

		    if(c->DisplayBase)
		    {
			struct Record *record = (struct Record *)
			FindDisplayMonitor(VGA_MONITOR_ID << 16);

			if(record)
			{
			    struct DisplayMonitor *monitor = 
				  (struct DisplayMonitor *)
				   FindTag( &record->rec_Tag, TAG_MSPC );

			    if( monitor )
			    {
				monitor->Mspc = mspc;
			    }
			}
		    }
		    stuf_base(eb);
		}
		*/
a887 22
	/*
	if(c->DisplayBase)
	{
	    if(mspc)
	    {
		struct Record *record = (struct Record *)
		FindDisplayMonitor(DEFAULT_MONITOR_ID << 16);

		if(record)
		{
		    struct DisplayMonitor *monitor = 
			  (struct DisplayMonitor *)
			   FindTag( &record->rec_Tag, TAG_MSPC );

		    if( monitor )
		    {
			monitor->Mspc = mspc;
		    }
		}
	    }
	}
	*/
@


36.52
log
@coalesce all info into displayinfo record, multiple monitorinfo chunks
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.51 89/02/10 11:58:14 bart Exp $
d162 1
a162 1
    stuf_base( GB ); 
d186 1
a186 1
    stuf_base( eb );
@


36.51
log
@call add_tag
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.50 89/02/02 13:47:07 bart Exp $
d152 37
d750 7
d783 1
d855 4
d884 1
d937 2
d941 4
d965 1
a967 1
	stuf_base(eb);
@


36.50
log
@bind nominal values to default monitor
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.49 89/02/02 10:43:00 bart Exp $
d201 1
a201 1
		AllocMem( (count * sizeof(struct TagItem)), MEMF_PUBLIC | MEMF_CLEAR );
d206 5
a210 2
		record->rec_Tag.ti_Tag = TAG_MORE;
		record->rec_Tag.ti_Data = copytags;
@


36.49
log
@DEFAULT_MONITOR_NAME
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.48 89/02/01 17:52:17 bart Exp $
d673 2
a674 1
		bind_db(c,bindings,displaytags);
@


36.48
log
@checkpoint -- a2024 10hz and 15hz scan works from 32 bit id
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.47 89/01/31 18:43:37 bart Exp $
d694 1
a694 3
				       (c->DisplayFlags&PAL)?
				       PAL_MONITOR_NAME:
				       NTSC_MONITOR_NAME);
@


36.47
log
@c->a2024_sync_raster[0] = 0x3ffffff; 01.31.89
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.46 89/01/31 15:38:41 bart Exp $
@


36.46
log
@checkpoint 2024
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.45 89/01/30 18:47:28 bart Exp $
d841 1
a841 1
	c->a2024_sync_raster[0] = 0x1ffffff;
@


36.45
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.44 89/01/25 14:36:47 bart Exp $
d747 1
@


36.44
log
@FindDisplayMonitor
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.43 89/01/24 15:37:49 bart Exp $
d746 1
a746 1
#define ADD_VGA
@


36.43
log
@checkpoint 01.24.89
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.42 89/01/24 14:46:27 bart Exp $
d719 4
a722 6
			struct Record *record = FindID(c->DisplayBase->Root,
						((GRAPHICS_MONITORS_ID<<16)|
						 (c->DisplayFlags&PAL)?
						  PAL_MONITOR_ID:
						  NTSC_MONITOR_ID));

d815 2
a816 2
			struct Record *record = FindID(c->DisplayBase->Root,
			    ((GRAPHICS_MONITORS_ID<<16)|VGA_MONITOR_ID));
d890 2
a891 2
		struct Record *record = FindID(c->DisplayBase->Root,
			     ((GRAPHICS_MONITORS_ID<<16)|DEFAULT_MONITOR_ID));
@


36.42
log
@monitor->Mspc = mspc
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.41 89/01/24 11:37:36 bart Exp $
@


36.41
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.40 89/01/23 11:32:39 bart Exp $
d724 1
d727 3
a729 2
			    struct TagItem *item = 
			    FindTag( &record->rec_Tag,TAG_MSPC); 
d731 3
a733 3
			    if(item) 
			    { 
				item->ti_Data = mspc; 
d822 3
a824 2
			    struct TagItem *item = 
			    FindTag( &record->rec_Tag,TAG_MSPC); 
d826 1
a826 1
			    if(item)
d828 1
a828 1
				item->ti_Data = mspc;
d897 3
a899 1
		    struct TagItem *item = FindTag( &record->rec_Tag,TAG_MSPC); 
d901 1
a901 1
		    if(item)
d903 1
a903 1
			item->ti_Data = mspc;
@


36.40
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.39 89/01/19 17:28:06 bart Exp $
d55 1
a55 1
/* extern VERSION, REVISION; */
d444 2
a445 2
	c->LibNode.lib_Version = VERSION;
	c->LibNode.lib_Revision = REVISION;
@


36.39
log
@checkpoint 01.19.89 coercion down to default
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.38 89/01/18 13:54:05 bart Exp $
d55 1
a55 1
extern VERSION, REVISION;
d444 2
a445 2
	c->LibNode.lib_Version = &VERSION;
	c->LibNode.lib_Revision = &REVISION;
@


36.38
log
@checkpoint 01.18.89
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.37 89/01/17 16:31:16 bart Exp $
@


36.37
log
@bind vga.monitor
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.36 89/01/12 16:14:28 bart Exp $
@


36.36
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.35 88/11/14 10:09:12 bart Exp $
d663 16
d709 30
d746 1
a746 1
/* #define ADD_VGA */
d805 27
d885 1
a885 2
	/* open the display database */ 
	if(c->DisplayBase = (struct DisplayBase *)OpenLibrary(DISPLAY_NAME,36))
a886 2
	    bind_db(c,bindings,displaytags);

@


36.35
log
@big blit support
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.34 88/10/21 19:26:50 bart Exp $
d29 17
d150 106
d793 3
a795 3
	c->LCMptr = AllocMem(MAXBYTESPERROW,MEMF_CHIP);
	c->LastChanceMemory = (struct SignalSemaphore *)AllocMem(sizeof(struct SignalSemaphore),0);
	InitSemaphore(c->LastChanceMemory);
d798 1
a798 1
	Debug();
d800 14
a813 1
	/* guarantee that the default monitor is open before returning */ 
d815 17
a831 6
		struct ExecBase *eb,**peb;
		peb = (struct ExecBase **)(4);
		eb = *peb;
		stuf_base(c); 
		open_monitor(DEFAULT_MONITOR_NAME); 
		stuf_base(eb);
d833 4
@


36.34
log
@MonitorListSemaphore
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.33 88/10/21 12:00:10 bart Exp $
d442 4
d670 1
a670 1
	c->LCMptr = AllocMem(2048,MEMF_CHIP);
@


36.33
log
@OpenMonitor(), CloseMonitor()
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.32 88/10/20 13:07:00 bart Exp $
d539 5
d673 9
@


36.32
log
@conditionally define unity scale
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.31 88/10/20 11:51:06 bart Exp $
a30 2
#define UNITY

d131 2
d205 2
d540 1
d542 7
a548 4
	    struct MonitorSpec *mspc = new_monitorspec(c,(c->DisplayFlags&PAL)?
				   REQUEST_PAL:
				   REQUEST_NTSC,
				   DEFAULT_MONITOR_NAME);
a550 1
#ifdef UNITY
d552 1
a553 1
#endif
a556 1

a564 34
	    }
	}

	/* initialize standard ntsc monitorspec and add to list */
	{
	    struct MonitorSpec *mspc = new_monitorspec(c, REQUEST_NTSC,
				   			NTSC_MONITOR_NAME);
	    if(mspc)
	    {
#ifdef UNITY
		int unity_scale();
		mspc->ms_scale = unity_scale; 	/* force unity */
#endif
		/* initialize view range bound */
		vlimit(mspc,&mspc->ms_LegalView,NULL);

		AddHead(&c->MonitorList, mspc);
	    }
	}

	/* initialize standard pal monitorspec and add to list */
	{
	    struct MonitorSpec *mspc = new_monitorspec(c, REQUEST_PAL,
				   			PAL_MONITOR_NAME);
	    if(mspc)
	    {
#ifdef UNITY
		int unity_scale();
		mspc->ms_scale = unity_scale; 	/* force unity */
#endif
		/* initialize view range bound */
		vlimit(mspc,&mspc->ms_LegalView,NULL);

		AddHead(&c->MonitorList, mspc);
@


36.31
log
@force unity scale
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.30 88/09/19 20:42:42 dale Exp $
d31 2
d545 1
d547 2
a551 1
		mspc->ms_scale = unity_scale; 	/* force unity */
d570 1
a571 1

d573 1
a573 1

d587 1
a588 1

d590 1
a590 1

d598 1
@


36.30
log
@changes for VideoControl
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.29 88/10/19 16:47:16 bart Exp $
d543 2
d547 2
d566 4
d583 4
@


36.29
log
@c->ChipRevBits0 |= GFXF_HR_AGNUS
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.28 88/10/19 16:10:01 bart Exp $
d129 2
d202 1
@


36.28
log
@ifdef'd out vga.monitor at pwrup
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.27 88/10/18 17:44:10 bart Exp $
d302 1
a302 1
		c->ChipRevBits0 |= GFXF_BIG_BLITS;
@


36.27
log
@lock down vga.monitor legalview position in preparation for 640x480 default
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.26 88/10/18 15:21:05 bart Exp $
d579 1
d639 1
a639 1

@


36.26
log
@get_pal(agnus_chip_id)
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.25 88/10/17 15:08:13 bart Exp $
d629 5
a633 1
		vlimit(mspc,&mspc->ms_LegalView,NULL);
@


36.25
log
@default monitorspec guaranteed to exist ... optimise
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.24 88/09/11 17:35:41 bart Exp $
d301 1
a301 1
	if (agnus_chip_id == 0x30)
d484 1
a484 1
	c->DisplayFlags = (c->system_bplcon0 & GENLOC)|get_pal();
d581 4
a584 1
	    struct MonitorSpec *mspc = new_monitorspec(c, REQUEST_SPECIAL,
d591 5
a595 1
		mspc->total_rows = VGA_TOTAL_ROWS;
d768 2
a769 1
get_pal()
d771 6
a776 5
	/* a ntsc display has 262 lines, counts to 261 */
	/* a pal display has 312 lines, counts to 311 */
	/* must be run while disabled */
	register int i;
	if ((i = vbeampos()) > 270) return(PAL);
d779 17
a795 9
		/* wait till vbeampos 255 */
		while ( (i = vbeampos()) < 100);
		do
		{
			i = vbeampos();
			if (i > 270)	return(PAL);
		} while (i > 50);	/* if it falls back then no pal */
		/* I use 50 figuring the genloc wont reset me higher than */
		/* that every frame time */
@


36.24
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.23 88/08/12 13:18:58 bart Exp $
d31 2
d546 4
@


36.23
log
@mspc->DeniseMinDisplayColumn
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.22 88/08/10 14:59:47 bart Exp $
d595 1
@


36.22
log
@vga.constants and vga.minrow
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.21 88/08/10 11:51:16 bart Exp $
a511 3
	/* c->MinDisplayColumn = (0x38<<1) - 64; */ /* max left overscan */
	/* no data can actually appear until -48 though */
	/* c->MaxDisplayColumn = 0x81 + 320 + 16; */ /* max right overscan */
d513 1
a513 1
	c->MinDisplayColumn = 0x3c; 		   /* bart -- max left clip*/
@


36.21
log
@fix superhires sprstop values
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.20 88/08/10 11:43:05 bart Exp $
d585 2
a586 2
		mspc->total_rows = STANDARD_NTSC_ROWS*2;
		mspc->total_colorclocks = STANDARD_COLORCLOCKS/2;
d599 3
d606 9
a614 6
		    /* mode specific voodoo */

		    sm->hblank.asi_Start = 0x08;
		    sm->hsync.asi_Start = 0x0e;
		    sm->hsync.asi_Stop = 0x1c;
		    sm->hblank.asi_Stop = 0x1e;
@


36.20
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.19 88/08/07 16:50:11 bart Exp $
d327 2
a328 2
	c->copinit->sprstop[0] = 0x0000; /* could be fe00 */
	c->copinit->sprstop[1] = 0x0000; /* could be ff66 */
@


36.19
log
@checkpoint - assembly interface to monitorspec routines
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.18 88/09/01 11:17:07 bart Exp $
d327 4
a330 2
	c->copinit->sprstop[0] = 0x0000;	/* could be fe00 */
	c->copinit->sprstop[1] = 0x0000;	/* could be ff66 */
@


36.18
log
@define MAX_DENISE(x) (((CCLKS(x)+1)<<1)+1) 
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.17 88/09/01 09:52:14 bart Exp $
d227 1
a227 1
        (*mspc->ms_Node.xln_Init) (mspc,flags);
@


36.17
log
@vlimit and new_monnitorspec changes
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.16 88/08/26 17:09:18 bart Exp $
d242 1
a242 2
#define MAX_DENISE(x) \
(((x)->BeamCon0&LOLDIS)?((CCLKS(x)+1)<<1):((CCLKS(x)+1)<<1)+1)
@


36.16
log
@vlimit calls...
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.15 88/08/25 13:37:41 bart Exp $
d217 2
a218 1
struct MonitorSpec *new_monitorspec(flags,name)
d226 1
d240 5
d496 1
a496 1
		c->MaxDisplayRow = 261;
d505 1
a505 1
		c->MaxDisplayRow = 311;
d511 1
a511 1
	c->MinDisplayColumn = (0x38<<1) - 64; /* max left overscan */
d513 1
a513 1
	c->MaxDisplayColumn = 0x81 + 320 + 16; /* max right overscan */
d515 2
a516 2
	c->MinDisplayColumn = 0x3c; 	/* bart -- max left clip*/
	c->MaxDisplayColumn = 0x1c7; 	/* bart -- max right clip */
d534 1
a534 1
	    struct MonitorSpec *mspc = new_monitorspec((c->DisplayFlags&PAL)?
d543 1
a543 1
		vlimit(c,mspc,&mspc->ms_LegalView,NULL);
a544 3
#ifdef BARTDEBUG
		mspc->ms_reserved = c;  /* debugging */
#endif
d551 1
a551 1
	    struct MonitorSpec *mspc = new_monitorspec( REQUEST_NTSC,
d556 1
a556 1
		vlimit(c,mspc,&mspc->ms_LegalView,NULL);
a557 3
#ifdef BARTDEBUG
		mspc->ms_reserved = c;  /* debugging */
#endif
d564 1
a564 1
	    struct MonitorSpec *mspc = new_monitorspec( REQUEST_PAL,
d569 1
a569 1
		vlimit(c,mspc,&mspc->ms_LegalView,NULL);
a570 3
#ifdef BARTDEBUG
		mspc->ms_reserved = c;  /* debugging */
#endif
d577 1
a577 1
	    struct MonitorSpec *mspc = new_monitorspec( REQUEST_SPECIAL,
d595 3
d611 1
a611 1
		vlimit(c,mspc,&mspc->ms_LegalView,NULL);
a612 3
#ifdef BARTDEBUG
		mspc->ms_reserved = c;  /* debugging */
#endif
@


36.15
log
@transform view range bound
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.14 88/08/08 17:48:47 bart Exp $
d534 4
d551 3
d567 3
d609 2
a610 9
		/* transform lower view range bound */
		(*mspc->ms_transform) ( mspc, &mspc->ms_LegalView.MinX,
					TO_MONITOR, 
					&mspc->ms_LegalView.MinX);

		/* transform upper view range bound */
		(*mspc->ms_transform) ( mspc, &mspc->ms_LegalView.MaxX,
					TO_MONITOR, 
					&mspc->ms_LegalView.MaxX);
@


36.14
log
@mode specific voodoo -- compromise between sony and nec multisync II
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.13 88/07/26 17:08:26 bart Exp $
d598 10
@


36.13
log
@(*mspc->ms_Node.xln_Init) (mspc,flags);
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.12 88/07/26 16:52:04 bart Exp $
d593 1
a593 1
		    sm->hblank.asi_Start = 0x07;
d595 2
a596 2
		    sm->hsync.asi_Stop = 0x1e;
		    sm->hblank.asi_Stop = 0x1f;
@


36.12
log
@REQUEST_PAL,PAL_MONITOR_NAME
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.11 88/07/25 14:18:48 bart Exp $
d225 1
a225 3
	init_monitorspec(mspc,flags);

	mspc->ms_Node.xln_Init = init_monitorspec;
@


36.11
log
@default_monitorspec
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.10 88/07/25 11:18:26 bart Exp $
d558 1
a558 1
	    struct MonitorSpec *mspc = new_monitorspec( REQUEST_NTSC,
@


36.10
log
@c->default_monitorspec
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.9 88/07/23 17:08:21 bart Exp $
a534 2
		/* default monitorspec */

a569 1
	/* this will later be performed by "setmonitor" - bart */
@


36.9
log
@monitorspec -- bart 07.23.88 merge source
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.8 88/07/14 13:31:38 dale Exp $
d535 3
d572 1
@


36.8
log
@Added GfxLookUp as external routine.
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.7 88/07/05 14:10:30 dale Exp $
d217 21
d523 86
@


36.7
log
@Made hedley sprites up to 32 rows tall.
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.6 88/06/23 13:23:10 dale Exp $
d122 1
a122 1
int GfxNew(),GfxFree(),GfxAssociate();
d197 1
@


36.6
log
@Readded Genlock detection. This may cause some multisync problems.
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.5 88/06/13 09:44:38 bart Exp $
d27 2
d507 1
d512 2
a513 3
		c->hedley_sprites[i] = AllocMem((2+32+2)*2*2,MEMF_CHIP|MEMF_CLEAR);
		c->hedley_sprites1[i] = c->hedley_sprites[i]+(2+32+2)*2;
		/*c->hedley_sprites1[i] = AllocMem((2+32+2)*2,MEMF_CHIP|MEMF_CLEAR);*/
@


36.5
log
@*** empty log message ***
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.4 88/05/17 22:46:48 dale Exp $
d27 1
a27 1
/*#define CHECK_GENLOCK*/
@


36.4
log
@Needed more space in copinit structure for diwstart/diwhigh magic.
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.3 88/05/12 14:51:35 dale Exp $
d482 1
a482 1
	c->MinDisplayColumn = (0x38<<1) - 64;	/* max left overscan */
d484 5
a488 1
	c->MaxDisplayColumn = 0x81 + 320 + 16;	/* max right overscan */
@


36.3
log
@minor tweak for hedley magic from 3ffffff to 1ffffff
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.2 88/03/11 17:06:40 dale Exp $
d347 6
@


36.2
log
@new chip PAL changes.
@
text
@d3 1
a3 1
*	$Header: cpwrup.c,v 36.1 88/03/10 16:11:24 dale Exp $
d491 1
a491 1
	c->a2024_sync_raster[0] = 0x3ffffff;
@


36.1
log
@V36 initial check in
@
text
@d3 1
a3 1
*	$Header: $
d553 6
d582 1
a582 1
	io->beamcon0 = 0;	/* disable most all new stuff */
@
