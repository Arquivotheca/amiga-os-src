head     39.3;
branch   ;
access   ;
symbols  rel39_24:39.3 rel39_18:39.3 rel39_97:39.3 rel39_90:39.3 rel39_89:39.3 rel39_82:39.3 rel39_76:39.3 rel39_71:39.3 rel39_65:39.3 rel39_64:39.3 rel39_61:39.3 rel39_60:39.3 rel39_55:39.2 rel39_47:39.2 rel39_39:39.2 rel39_38:39.2 rel39_37:39.2 rel39_35:39.0 rel39_34:39.0 V37_30:37.3 V37_29:37.3 V37_28:37.3 V37_25:37.3 V37_22:37.3 V37_21:37.3 V37_20:37.3 V37_19:37.3 V37_17:37.3 V37_15:37.3 V37_14:37.2 V37_13:37.1 V37_12:37.1 V37_11:37.1 V37_10:37.1 V37_9:37.1 V37_8:37.1 V37_7:37.1 V37_6:37.1 V37_5:37.1 V37_4:37.0 V37_3:37.0 V37_2:37.0 V37_1:37.0 V36_209:33.11 V36_208:33.11 V36_207:33.11 V36_205:33.11 V36_203:33.11 V36_202:33.11 V36_201:33.11 V36_200:33.11 V36_199:33.11 V36_198:33.11 V36_196:33.11 V36_195:33.11 V36_194:33.11 V36_193:33.11 V36_192:33.11 V36_191:33.11 V36_190:33.11 V36_189:33.11 V36_188:33.11 V36_187:33.11 V36_186:33.11 V36_185:33.11 V36_184:33.11 V36_183:33.11 V36_182:33.11 V36_181:33.11;
locks    ; strict;
comment  @*   @;


39.3
date     92.05.05.12.20.33;  author chrisg;  state Exp;
branches ;
next     39.2;

39.2
date     92.02.21.13.08.22;  author bart;  state Exp;
branches ;
next     39.1;

39.1
date     92.02.21.12.57.26;  author bart;  state Exp;
branches ;
next     39.0;

39.0
date     91.08.21.17.34.00;  author chrisg;  state Exp;
branches ;
next     37.6;

37.6
date     91.05.14.16.10.58;  author chrisg;  state Exp;
branches ;
next     37.5;

37.5
date     91.05.13.14.36.16;  author chrisg;  state Exp;
branches ;
next     37.4;

37.4
date     91.05.02.16.45.53;  author chrisg;  state Exp;
branches ;
next     37.3;

37.3
date     91.02.15.11.00.47;  author spence;  state Exp;
branches ;
next     37.2;

37.2
date     91.02.12.15.49.01;  author spence;  state Exp;
branches ;
next     37.1;

37.1
date     91.01.23.13.11.59;  author bart;  state Exp;
branches ;
next     37.0;

37.0
date     91.01.07.15.22.10;  author spence;  state Exp;
branches ;
next     33.11;

33.11
date     90.07.27.16.37.14;  author bart;  state Exp;
branches ;
next     33.10;

33.10
date     90.03.28.09.26.40;  author bart;  state Exp;
branches ;
next     33.9;

33.9
date     90.03.19.13.20.43;  author bart;  state Exp;
branches ;
next     33.8;

33.8
date     89.12.04.14.09.14;  author bart;  state Exp;
branches ;
next     33.7;

33.7
date     89.12.04.14.03.01;  author bart;  state Exp;
branches ;
next     33.6;

33.6
date     89.12.04.13.32.01;  author bart;  state Exp;
branches ;
next     33.5;

33.5
date     88.11.16.09.59.52;  author bart;  state Exp;
branches ;
next     33.4;

33.4
date     88.11.16.09.57.58;  author bart;  state Exp;
branches ;
next     33.3;

33.3
date     88.11.16.09.54.20;  author bart;  state Exp;
branches ;
next     33.2;

33.2
date     86.07.01.11.30.02;  author bart;  state Exp;
branches ;
next     33.1;

33.1
date     86.06.17.10.17.15;  author bart;  state Exp;
branches ;
next     33.0;

33.0
date     86.05.17.15.22.58;  author bart;  state Exp;
branches ;
next     ;


desc
@@


39.3
log
@FETCHGBASE, regargs, etc.
@
text
@/******************************************************************************
*
*	Source Control
*	--------------
*	$Id: gel.c,v 39.2 92/02/21 13:08:22 bart Exp Locker: chrisg $
*
*	$Locker: chrisg $
*
*	$Log:	gel.c,v $
*   Revision 39.2  92/02/21  13:08:22  bart
*   moved collType to avoid forward reference
*   
*   Revision 39.1  92/02/21  12:57:26  bart
*   re-ordered functions for proto making from scracth
*   to avoid forward references
*   
*   Revision 39.0  91/08/21  17:34:00  chrisg
*   Bumped
*   
*   Revision 37.6  91/05/14  16:10:58  chrisg
*   made work without glue routines
*   
*   Revision 37.5  91/05/13  14:36:16  chrisg
*   removed compiler warnings for lattice
*   made use prototypes
*   got rid of interface code.. made routines take
*   arguments in registers.
*   
*   Revision 37.4  91/05/02  16:45:53  chrisg
*    killed "../" for lattice
*   
*   Revision 37.3  91/02/15  11:00:47  spence
*   Removed Bart's BORDERHIT fix (broke people :-( ).
*   
*   Revision 37.2  91/02/12  15:49:01  spence
*   autodoc
*   
*   Revision 37.1  91/01/23  13:11:59  bart
*   correct BORDERHIT processing (1 << BORDERHIT)
*   
*   Revision 37.0  91/01/07  15:22:10  spence
*   initial switchover from V36
*   
*   Revision 33.11  90/07/27  16:37:14  bart
*   id
*   
*   Revision 33.10  90/03/28  09:26:40  bart
*   *** empty log message ***
*   
*   Revision 33.9  90/03/19  13:20:43  bart
*   fix bug B6600
*   
*   Revision 33.8  89/12/04  14:09:14  bart
*   *** empty log message ***
*   
*   Revision 33.7  89/12/04  14:03:01  bart
*   *** empty log message ***
*   
*   Revision 33.6  89/12/04  13:32:01  bart
*   dont collide vsprite if bob and bobsaway
*   
*   Revision 33.5  88/11/16  09:59:52  bart
*   *** empty log message ***
*   
*   Revision 33.4  88/11/16  09:57:58  bart
*   *** empty log message ***
*   
*   Revision 33.3  88/11/16  09:54:20  bart
*   big blits
*   
*   Revision 33.2  86/07/01  11:30:02  bart
*   documentation update to DoCollision : removed BUGS comment
*   
*   Revision 33.1  86/06/17  10:17:15  bart
*   fixes collision bug #B2897
*   boffset now set correctly
*   
*   Revision 33.0  86/05/17  15:22:58  bart
*   added to rcs for updating
*   
*
******************************************************************************/


/*** gel.c *******************************************************************
 *
 *  File
 *
 *  Confidential Information: Amiga Computer, Inc.
 *  Copyright (c) Amiga Computer, Inc.
 *
 *                  Modification History
 *  date    :   author :    Comments
 *  -------     ------      ---------------------------------------
 *  9-28-84     -=RJ=-      added this header file
 *                          commented out all EXEC14 stuff
 * 08-02-85		-Dale-		removed V28 node stuff for V29
 *
 ****************************************************************************/

#include <exec/types.h>
#include <graphics/gfxbase.h>
#include <graphics/gels.h>
#include <graphics/rastport.h>
#include <graphics/clip.h>
#include <graphics/collide.h>
#include <graphics/gels.h>
#include "gelsinternal.h"
#include <hardware/custom.h>
#include <hardware/blit.h>
#include <hardware/dmabits.h>
#include "/sane_names.h"
#include "/macros.h"
#include "gels.protos"


#define BLITTERSIGNAL 4


/*#define DEBUG 1*/

/* #define SQUEEZE */

/* ************************************************************************ */

int __regargs bndryHit(struct VSprite *s,struct GelsInfo *gi)
/* returns 4 bit mask bit 0 = top (TOPHIT)
 *                    bit 1 = bottom (BOTTOMHIT)
 *                    bit 2 = left (LEFTHIT)
 *                    bit 3 = right (RIGHTHIT)
 */
{
    WORD offWidth, i;
    ULONG m;
    LONG *bptr;
    WORD hit_val = 0;
    int j,k;

#ifdef DEBUG
if (Debug & GELBUG) printf("bndryHit (%lx, %lx, %lx)\n", s, gi );
#endif

    /*  hit_val = 0; */

    /* test top collision */
    if (s->Y < gi->topmost)
    {
	UWORD *bptr;
	/* int j,k; */

	/* have to test if any bits in collision mask are set */
	i = gi->topmost - s->Y + 1;	/* how deep into collision mask */
	k = smuls(s->Width,i+1);	/* number of words to check */
	bptr = s->CollMask;

	for (j = 0; j < k ; j++)
	if ( *bptr++ )
	{
	    hit_val = TOPHIT;
	    break;
	}

	/*printf("s->Y=%lx topmost = %lx width=%lx collmask=%lx hitval=%lx\n",
	            s->Y,gi->topmost,s->Width,s->CollMask,hit_val);*/
	/*Debug();*/

#ifdef DEBUG
if (Debug & GELBUG)
printf("   TOP y=%ld h=%ld tm=%ld\n",s->Y,s->Height,gi->topmost);
#endif

    }

    /* test bottom collision */
    if (s->Y + s->Height - 1 > gi->bottommost)
    {
	UWORD *bptr;
	/* int j,k; */

	/* have to test if any bits in collision mask are set */
	i = gi->bottommost - s->Y + 1;

	/* how deep into collision mask */
	k = smuls(s->Width,i);	/* offset into CollMask */
	bptr = s->CollMask + k;

	/* how many words left to check ? */
	k = smuls(s->Width,s->Height - i);
	for (j = 0; j < k ; j++)
	if ( *bptr++ )
	{
	    hit_val |= BOTTOMHIT;
	    break;
	}

#ifdef DEBUG
if (Debug & GELBUG)
printf("   BOTTOM y=%ld h=%ld bm=%ld\n",s->Y,s->Height,gi->bottommost);
#endif

    }

    /* test left collision */
    if ((offWidth = gi->leftmost - s->X) > 0)
    {
	if (offWidth > (s->Width << 4)) offWidth = (s->Width << 4);

#ifdef DEBUG
if(Debug & GELBUG)
printf("   LEFT x=%ld w=%ld lm=%ld\n",s->X,s->Width,gi->leftmost);
#endif
        bptr = (LONG *) s->BorderLine;
        do
            {
	    /* m = *bptr; */ /* bart - see below */
	    m = *bptr++;
            if (offWidth < 32) m >>= (32 - offWidth);
#ifdef DEBUG
if (Debug & GELBUG)
printf("  m=%lx bptr=%lx offWidth=%ld\n",m,bptr,offWidth);
#endif
            if (m)
                {
                hit_val |= LEFTHIT;
                break;
                }
            /* bptr++;*/ /* bart - see above */
            offWidth -= 32;
            }
        while (offWidth > 0);
    }

    /* test right collision */
    if ((offWidth = (s->X + (s->Width << 4) - 1) - gi->rightmost) > 0)
    {
	UWORD *bptr,m;

	if (offWidth > (s->Width << 4)) offWidth = (s->Width << 4);

#ifdef DEBUG
if(Debug & GELBUG)
printf("  RIGHT x=%ld w=%ld rm=%ld\n",s->X,s->Width,gi->rightmost);
#endif

        bptr = s->BorderLine + s->Width - 1;	/* point to end of Line */
        do
	{
	    /* m = *bptr; */ /* bart - see below */
	    m = *bptr--;

#ifdef DEBUG
if (Debug & GELBUG)
printf("  m=%lx bptr=%lx offWidth=%ld\n",m,bptr,offWidth);
#endif

            if (offWidth < 16) m <<= (16 - offWidth);
            if (m)
	    {
                hit_val |= RIGHTHIT;
                break;
	    }
            /* bptr--; */ /* bart - see above */
            offWidth -= 16;
	}
        while (offWidth > 0);
    }

    return((int) hit_val);
}



#ifdef OLDCHECK

/* mag added ownblitter, disownblitter, gfxBase ptr, increased code size */

BOOL __regargs checkColl(struct VSprite *a,struct VSprite *b)
{
    struct AmigaRegs *io ={(BYTE *)0x0dff000};
    struct gelRect gRa;
    SHORT fwm, lwm; 
    SHORT aoffset,boffset,blitHeight,blitWidth,blitsize;
    SHORT amodulus, bmodulus, aymax, bymax, axmax, bxmax, wcls, wcrs;
    USHORT bzero;
    SHORT shifta,shiftb;
    SHORT OMaxX,OMaxY;

#ifdef DEBUG
if (Debug & GELBUG)
    printf("checkColl(a=%lx b=%lx )\n", a, b);
#endif


    OMaxY = aymax = (a->Y) + (a->Height) - 1;
    OMaxX = axmax = (a->X) + (a->Width<<4) - 1;

    bymax = (b->Y) + (b->Height) - 1;
    bxmax = (b->X) + (b->Width<<4) - 1;

    gRa.rRealWW = a->Width;

    gRa.rX = (a->X < b->X)? b->X : a->X; /* MAX(rX,left) */
    OMaxX = (OMaxX > bxmax) ? bxmax : OMaxX; /* MIN(OMaxX,right) */
    gRa.rW = OMaxX - (gRa.rX) + 1;

    gRa.rY = (a->Y < b->Y)? b->Y: a->Y; /* MAX(rY, top */
    OMaxY = (OMaxY > bymax)? bymax: OMaxY; /* MIN(OMaxY,bottom) */
    gRa.rH = OMaxY - (gRa.rY) + 1;

    shifta = ((b->X) - (a->X)) & 0x0f;

  /* word of 'a' containing left side of 'b' */
    wcls = ((gRa.rX) - (a->X))>>4;

    if (bxmax >= axmax) shiftb = 0;
    else shiftb = (axmax - bxmax) & 0x0f;

    wcrs = (((gRa.rX) + (gRa.rW) - 1) - (a->X))>>4;

  /* rightmost word of 'a' containing ANY of 'b' */
    blitWidth = wcrs - wcls + 1;

    fwm = ((USHORT)(~0))>>shifta;

    if (blitWidth == 1)
	{
	fwm = fwm & ((~0)<<shiftb);
	lwm = fwm;
	}
    else
	lwm = ((~0)<<shiftb);

    amodulus = ((a->Width) - blitWidth)<<1;
    bmodulus = ((b->Width) - blitWidth)<<1;

    aoffset =((umuls(((b->Y > a->Y)? (b->Y - a->Y): 0), a->Width)) + wcls)<<1;

	/* bart - 06.17.86 */
    /* boffset =(umuls(((a->Y > b->Y)? (a->Y - b->Y): 0), b->Width))<<1; */
    boffset =
		((umuls(( (a->Y > b->Y) ? (a->Y - b->Y) : 0), b->Width)) + 
		(((gRa.rX) - (b->X)) >>4) ) <<1;


    blitHeight = gRa.rH;

    blitsize = (blitHeight<<6) + blitWidth; /*???*/

/*???    WaitBlit();*/
    OwnBlitter();
    waitblitdone();

#ifdef DEBUG
if (Debug & GELBUG)
{
printf("io->bltcon0 = %lx\n", 0x0CC0);
printf("io->bltcon1 = %lx\n", shifta << 12);
printf("fwmask = %lx\n", fwm);
printf("lwmask = %lx\n",  lwm);
printf("io->bltpta = %lx\n",  (BYTE *)(&a->CollMask[0]) + aoffset);
printf("io->bltptb = %lx\n",  (BYTE *)(&b->CollMask[0]) + boffset);
printf("io->bltptc = %lx\n",  0);
printf("io->bltptd = %lx\n",  0);
printf("io->bltmda = %lx\n",  amodulus);
printf("io->bltmdb = %lx\n",  bmodulus);
printf("io->bltmdc = %lx\n",  0);
printf("io->bltmdd = %lx\n",  0);
printf("io->bltsize = %lx\n",  blitsize);
Debug();
}
#endif

    io->bltcon0 = SRCA|SRCB | ABC|ABNC;
    io->bltcon1 = shifta << 12;
    io->fwmask = fwm;
    io->lwmask = lwm;
    /* pointer into object a */
    io->bltpta = (BYTE *)(&a->CollMask[0]) + aoffset;
    /* pointer to object b */
    io->bltptb = (BYTE *)(&b->CollMask[0]) + boffset;
    io->bltptc = 0;
    io->bltptd = 0;
    io->bltmda = amodulus;
    io->bltmdb = bmodulus;
    io->bltmdc = 0;
    io->bltmdd = 0;
    /* big blits */
    {

	if (GBASE->ChipRevBits0 & GFXF_BIG_BLITS)
	{
	    io->bltsizv = (blitHeight & 0x7fff);
	    io->bltsizh = (blitWidth  & 0x07ff);
	}
	else
	{
	    io->bltsize = blitsize;
	}
    }

/*???    WaitBlit();*/

    waitblitdone();

    bzero = io->dmaconr & DMAF_BLTNZERO;

    DisownBlitter();

    if (bzero) return(FALSE);
    else return(TRUE);
}

#else

/* bart reduced variables and sped things up 03.14.86 */

BOOL __regargs checkColl(a, b )
struct VSprite *a,*b;
{
    extern struct AmigaRegs custom;
    struct gelRect gRa;
    SHORT fwm, lwm; 
    SHORT aoffset,boffset,blitWidth;
    SHORT bymax, bxmax, wcls;
    /* SHORT wcrs; */
    USHORT bzero;
    SHORT shifta,shiftb;
    SHORT OMaxX,OMaxY;

#ifdef DEBUG
if (Debug & GELBUG)
    printf("checkColl(a=%lx b=%lx )\n", a, b);
#endif


    OMaxY = (a->Y) + (a->Height) - 1;
    OMaxX = (a->X) + (a->Width<<4) - 1;

    bymax = (b->Y) + (b->Height) - 1;
    bxmax = (b->X) + (b->Width<<4) - 1;

    /* bart - speedup */
    /* if (bxmax >= OMaxX ) shiftb = 0; else shiftb = (OMaxX - bxmax) & 0x0f; */

    if ((shiftb = OMaxX - bxmax) < 0) shiftb = 0;
    else shiftb &= 0x0f;

    /* gRa.rRealWW = a->Width;*/
    /*shifta = ((b->X) - (a->X)) & 0x0f;*/
    /*gRa.rX = (a->X < b->X)? b->X : a->X;*/ /* MAX(rX,left) */

    if((shifta = (b->X) - (a->X)) > 0) gRa.rX = b->X; else gRa.rX = a->X;
    shifta &= 0x0f;

    /* end bart - speedup */

    OMaxX = (OMaxX > bxmax) ? bxmax : OMaxX; /* MIN(OMaxX,right) */
    gRa.rW = OMaxX - (gRa.rX) + 1;

    gRa.rY = (a->Y < b->Y)? b->Y: a->Y; /* MAX(rY, top */
    OMaxY = (OMaxY > bymax)? bymax: OMaxY; /* MIN(OMaxY,bottom) */
    gRa.rH = OMaxY - (gRa.rY) + 1;

  /* word of 'a' containing left side of 'b' */

    wcls = ((gRa.rX) - (a->X))>>4;

  /*  wcrs = (((gRa.rX) + (gRa.rW) - 1) - (a->X))>>4; */

  /* rightmost word of 'a' containing ANY of 'b' */

  /* blitWidth = wcrs - wcls + 1; */ /* wcrs not used enough, removed - bart */

     blitWidth = ((((gRa.rX) + (gRa.rW) - 1) - (a->X)) >> 4) - wcls + 1;

    fwm = ((USHORT)(~0))>>shifta;

    if (blitWidth == 1)
	{
	fwm = fwm & ((~0)<<shiftb);
	lwm = fwm;
	}
    else
	lwm = ((~0)<<shiftb);

    /* bart - see below */
    /* amodulus = (((a->Width) - blitWidth)<<1); */
    /* bmodulus = (((b->Width) - blitWidth)<<1); */
    /* blitsize = ((gRa.rH<<6) + blitWidth);*/

    aoffset =((umuls(((b->Y > a->Y)? (b->Y - a->Y): 0), a->Width)) + wcls)<<1;

	/* bart - 06.17.86 */
    /* boffset =(umuls(((a->Y > b->Y)? (a->Y - b->Y): 0), b->Width))<<1; */
    boffset =
		((umuls(( (a->Y > b->Y) ? (a->Y - b->Y) : 0), b->Width)) + 
		(((gRa.rX) - (b->X)) >>4) ) <<1;

    OwnBlitter();

    waitblitdone();

#ifdef DEBUG
if (Debug & GELBUG)
{
printf("custom.bltcon0 = %lx\n", 0x0CC0);
printf("custom.bltcon1 = %lx\n", shifta << 12);
printf("custom.fwmask = %lx\n", fwm);
printf("custom.lwmask = %lx\n",  lwm);
printf("custom.bltpta = %lx\n",  (BYTE *)(&a->CollMask[0]) + aoffset);
printf("custom.bltptb = %lx\n",  (BYTE *)(&b->CollMask[0]) + boffset);
printf("custom.bltptc = %lx\n",  0);
printf("custom.bltptd = %lx\n",  0);
/* printf("custom.bltmda = %lx\n",  amodulus); */
/* printf("custom.bltmdb = %lx\n",  bmodulus); */
printf("custom.bltmdc = %lx\n",  0);
printf("custom.bltmdd = %lx\n",  0);
/* printf("custom.bltsize = %lx\n",  blitsize); */
Debug();
}
#endif

    custom.bltcon0 = SRCA|SRCB | ABC|ABNC;
    custom.bltcon1 = shifta << 12;
    custom.fwmask = fwm;
    custom.lwmask = lwm;

    /* pointer into object a */

    custom.bltpta = (BYTE *)(&a->CollMask[0]) + aoffset;

    /* pointer to object b */

    custom.bltptb = (BYTE *)(&b->CollMask[0]) + boffset;
    custom.bltptc = 0;
    custom.bltptd = 0;

    /* amodulus = (((a->Width) - blitWidth)<<1); */ /* bart */
    /* bmodulus = (((b->Width) - blitWidth)<<1); */ /* bart */

    custom.bltmda = (((a->Width) - blitWidth)<<1);
    custom.bltmdb = (((b->Width) - blitWidth)<<1);

    custom.bltmdc = 0;
    custom.bltmdd = 0;

    /* blitsize = ((gRa.rH<<6) + blitWidth);*/ /* bart */

    /* big blits */
    {

	if (GBASE->ChipRevBits0 & GFXF_BIG_BLITS)
	{
	    custom.bltsizv = (gRa.rH    & 0x7fff);
	    custom.bltsizh = (blitWidth & 0x07ff);
	}
	else
	{
	    custom.bltsize = ((gRa.rH<<6) + blitWidth);
	}
    }

    waitblitdone();

    /* bzero = custom.dmaconr & DMAF_BLTNZERO; */

    bzero = custom.dmaconr & DMAF_BLTNZERO;

    DisownBlitter();

    if (bzero) return(FALSE);
    else return(TRUE);
}

#endif

__regargs collType(struct VSprite *s, struct VSprite *t)
/* if the hit masks coincide and there is a collision,
 *  return the bit position of the lowest-most set bit of the hit masks
 *  else return 0
 */
{
    WORD flag, pos;

#ifdef DEBUG
if (Debug & GELBUG) printf("CollType(%lx, %lx, %lx)\n", s, t );
#endif

/* assumes that s is to the left of and/or above t */
    if ( (flag = (t->HitMask & -2) & (s->MeMask & -2)) != 0 )
        if (checkColl(s, t ))
	{
            pos = 0;
            do
                pos++;
            while (((flag >>= 1) & 0x01) == 0);
            return((int) pos);
	}

    return(0);
}


void __regargs downCheck(struct VSprite *s,      /* look down in list for collisions */
					struct GelsInfo *gi,
					struct VSprite *real)   /* apply result to real vsprite */
{

    WORD stop, sx, sw;
    WORD type, diff;
    struct VSprite *t;

    /* look forward */
    stop = s->Y + s->Height;
    sx = s->X;
    sw = s->Width << 4;
    for(t = s->NextVSprite; t->Y < stop; t = t->NextVSprite)
    {
        /* diff gets [+ or -] number of overlap columns */
        if ((diff = t->X - sx) < 0) /* t's X is left of s's */
	{
            if (-diff >= (t->Width << 4)) continue; /* if >= then no overlap */
	}
        else /* s's X is left of or equal to t's */
	if (diff >= sw) continue; /* if >= then no overlap */

        /* else they overlap along both axes, so test masks for collision */
        if ((type = collType(s, t )) != 0)
	{
	    if((s->VSBob && ((s->VSBob)->Flags & BOBSAWAY))
	    || (t->VSBob && ((t->VSBob)->Flags & BOBSAWAY)));
            else (*gi->collHandler->collPtrs[type])(real, t);
	}
    }
}

BOOL __regargs setRects(WORD high, WORD wide, struct gelRect *src,
						struct gelRect *dest, WORD dispx, WORD dispy,
						int RHeight, int RWidth )
/* arguments:
 *  high, wide = Height and Width for rectangularization
 *  src, dest = gelRect types
 *  dispx, dispy = starting display location
 *
 * sets:
 *  src->rY = starting line of image
 *  src->rX = starting column of image
 *  src->rH = number of image lines onscreen
 *  src->rW = number of image columns onscreen
 *  dest->rY = true starting line of display
 *  dest->rX = true starting column of display
 *
 * returns:
 *  0 = VSprite completely offscreen
 *  1 = VSprite at least partially onscreen
 */
{
    WORD ssx, ssy, h, w;
    WORD scx, scy;

    wide <<= 4;

/* clip top of raster */
    if (dispy < 0) ssy = 0;
    else ssy = dispy;
    scy = ssy - dispy;  /* scy = number of lines clipped from top */
    h = high - scy; /* h = number of lines onscreen */
/* clip bottom of raster */
    if (h + ssy > RHeight) h = RHeight - ssy;

    dest->rY = ssy;
    src->rH = h;
    src->rY = scy;

/* clip left */
    if (dispx < 0) ssx = 0;
    else ssx = dispx;
    scx = ssx - dispx;
    w = wide - scx;
/* clip right */
    if (w + ssx > RWidth) w = RWidth - ssx;

    dest->rX = ssx;
    src->rW = w;
    src->rX = scx;
 
    if (h <= 0 || w <= 0)
        {
#ifdef DEBUG
if (Debug & GELBUG) printf("setRects VSprite totally clipped\n");
#endif
        return(0);
        }
    else
        {
        return(1);
        }
}

#ifndef SQUEEZE

void __regargs sortVSprite(struct VSprite *s)
{
    struct VSprite *t;
    LONG q;

    q = *(LONG*)(&s->Y);  /* Here's why the y,x ordering.  Combined sort  */
    if (q < ( *(LONG *)(&s->PrevVSprite->Y))) 
    {   
	/* VSprite moves up or left */
	/* go backwards through list to put VSprite in new place */

        t = s->PrevVSprite;
        do t = t->PrevVSprite; while (q < (*(LONG*)(&t->Y)));
        /* extract s from list */
        s->NextVSprite->PrevVSprite = s->PrevVSprite;
        s->PrevVSprite->NextVSprite = s->NextVSprite;
        /* reinsert into list */
        t->NextVSprite->PrevVSprite = s;
        s->PrevVSprite = t;
        s->NextVSprite = t->NextVSprite;
        t->NextVSprite = s;
    }
    else if (q > (*(LONG*)(&s->NextVSprite->Y)))
	{
	    /* VSprite moves down or right */
	    t = s->NextVSprite;
	    do t = t->NextVSprite; while (q > (*(LONG*)(&t->Y)));
	    /* extract s from list */
	    s->PrevVSprite->NextVSprite = s->NextVSprite;
	    s->NextVSprite->PrevVSprite = s->PrevVSprite;
	    /* reinsert into list */
	    t->PrevVSprite->NextVSprite = s;
	    s->NextVSprite = t;
	    s->PrevVSprite = t->PrevVSprite;
	    t->PrevVSprite = s;
	}

    /* else object didn't change position */
}

#endif

/* ************************************************************************ */

/****** graphics.library/AddVSprite *******************************************
*
*   NAME
*	AddVSprite -- Add a VSprite to the current gel list.
*
*   SYNOPSIS
*	AddVSprite(vs, rp)
*	           A0  A1
*
*	void AddVSprite(struct VSprite *, struct RastPort *);
*
*   FUNCTION
*	Sets up the system VSprite flags
*	Links this VSprite into the current gel list using its Y,X
*
*   INPUTS
*	vs = pointer to the VSprite structure to be added to the gel list
*	rp = pointer to a RastPort structure
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	InitGels()  graphics/rastport.h  graphics/gels.h
*
*****************************************************************************/

void __asm AddVSprite(register __a0 struct VSprite *VS,
		      register __a1 struct RastPort *RPort)
{
    struct VSprite *p, *q;
    LONG t;

    VS->Flags &= SUSERFLAGS;

#ifdef DEBUG
if (Debug & GELBUG) printf("_AddVSprite(%lx, %lx, %lx)\n", VS, RPort );
#endif

    t = *(LONG *)(&VS->Y);   /* hold (Y, X) position */
    q = RPort->GelsInfo->gelHead;
    p = q->NextVSprite;

#ifdef DEBUG
if (Debug & GELBUG) printf("  initial q=%lx p=%lx t=%lx\n", q, p, t);
#endif

/* insert the new VSprite into the list based on its
*   vertical position with (0, 0) being above (0, 1)
*/

    while (*(LONG*)(&p->Y) < t)
    {
        q = p;
        p = p->NextVSprite;

#ifdef DEBUG
if (Debug & GELBUG) printf("  q=%lx p=%lx\n", q, p);
#endif

    }
    VS->NextVSprite = q->NextVSprite;
    q->NextVSprite->PrevVSprite = VS;
    q->NextVSprite = VS;
    VS->PrevVSprite = q;
    *(LONG*)(&VS->OldY) = t;
}

/****** graphics.library/AddBob ***********************************************
*
*   NAME
*	AddBob -- Adds a Bob to current gel list.
*
*   SYNOPSIS
*	AddBob(Bob, rp)
*	       A0   A1
*
*	void AddBob(struct Bob *, struct RastPort *);
*
*   FUNCTION
*	Sets up the system Bob flags, then links this gel into the list
*	via AddVSprite.
*
*   INPUTS
*	Bob = pointer to the Bob structure to be added to the gel list
*	rp  = pointer to a RastPort structure
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	InitGels()  AddVSprite()  graphics/gels.h  graphics/rastport.h
*
*****************************************************************************/
void __asm AddBob(register __a0 struct Bob *b, register __a1 struct RastPort *RPort )
{

#ifdef DEBUG
if (Debug & GELBUG) printf("_AddBob(%lx, %lx, %lx)\n", b, RPort );
#endif

    b->Flags &= BUSERFLAGS;
    AddVSprite(b->BobVSprite, RPort );
}


/****** graphics.library/DoCollision ******************************************
*
*   NAME
*	DoCollision -- Test every gel in gel list for collisions.
*
*   SYNOPSIS
*	DoCollision(rp)
*	            A1
*
*	void DoCollision(struct RastPort *);
*
*   FUNCTION
*	Tests each gel in gel list for boundary and gel-to-gel collisions.
*	On detecting one of these collisions, the appropriate collision-
*	handling routine is called. See the documentation for a thorough
*	description of which collision routine is called. This routine
*	expects to find the gel list correctly sorted in Y,X order.
*	The system routine SortGList performs this function for the user.
*
*   INPUTS
*	rp = pointer to a RastPort
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	InitGels()  SortGList()  graphics/gels.h  graphics/gels.h
*
*****************************************************************************/
void __asm DoCollision(register __a1 struct RastPort *RPort )   /* check for all collisions in list */
{
    struct GelsInfo *gi;
    struct VSprite *s, *end;
    BOOL bflag;
    WORD b;
    struct Layer *layer = RPort->Layer;

    if( layer ) 
    {
	LOCKLAYER( layer );
    }

    gi = RPort->GelsInfo;
    s = gi->gelHead;
    end = gi->gelTail;
    bflag = (LONG)(gi->collHandler->collPtrs[BORDERHIT]) != 0;
    while ((s = s->NextVSprite) != end)
    {
	struct VSprite tmp_sprite, *t=s;

	if((layer) && (t->Flags & VSPRITE)) 
	{
	    tmp_sprite = *s;
	    t = &tmp_sprite;
	    t->X -= (layer->bounds.MinX - layer->Scroll_X);
	    t->Y -= (layer->bounds.MinY - layer->Scroll_Y);
	}

        if (bflag) if (t->HitMask | BORDERHIT) 
	{
	    if (b = bndryHit(t, gi ))
	    {
		if(s->VSBob && ((s->VSBob)->Flags & BOBSAWAY));
		else (*gi->collHandler->collPtrs[BORDERHIT])(s, b);
	    }
	}
        downCheck(t, gi, s );
    }

    if( layer ) 
    {
	UNLOCKLAYER( layer );
    }
}


/****** graphics.library/InitGels ***********************************************
*
*   NAME
*	InitGels -- initialize a gel list; must be called before using gels.
*
*   SYNOPSIS
*	InitGels(head, tail, GInfo)
*	         A0    A1    A2
*
*	void InitGels(struct VSprite *, struct VSprite *, struct GelsInfo *);
*
*   FUNCTION
*	Assigns the VSprites as the head and tail of the gel list in GfxBase.
*	Links these two gels together as the keystones of the list.
*	If the collHandler vector points to some memory array, sets
*	the BORDERHIT vector to NULL.
*
*   INPUTS
*	head  = pointer to the VSprite structure to be used as the gel list head
*	tail  = pointer to the VSprite structure to be used as the gel list tail
*	GInfo = pointer to the GelsInfo structure to be initialized
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	graphics/gels.h  graphics/rastport.h
*
*******************************************************************************/
void __asm InitGels(register __a0 struct VSprite *sHead,
					register __a1 struct VSprite *sTail,
					register __a2 struct GelsInfo *GInfo)

{   /* soft VSprite data structure init */

#ifdef DEBUG
if (Debug & GELBUG) printf("_InitGels(%lx, %lx, %lx, %lx)\n", sHead, sTail, GInfo );
#endif

    GInfo->gelHead = sHead;
    GInfo->gelTail = sTail;

    sHead->NextVSprite = sTail;
    sHead->ClearPath = sTail;
    sHead->PrevVSprite = sTail->NextVSprite = 0;
    sTail->PrevVSprite = sHead;

    sTail->Y = 32767;
    sTail->OldY = 32767;
    sHead->Y = -32767;
    sHead->OldY = -32767;
    sTail->X = 32767;
    sTail->OldX = 32767;
    sHead->X = -32767;
    sHead->OldX = -32767;

/* initialize border collision response vector to NULL */
    if (GInfo->collHandler)
        GInfo->collHandler->collPtrs[BORDERHIT] = 0;
}

/****** graphics.library/InitMasks *********************************************
*
*   NAME
*	InitMasks -- Initialize the BorderLine and CollMask masks of a VSprite.
*
*   SYNOPSIS
*	InitMasks(vs)
*	          A0
*
*	void InitMasks(struct VSprite *);
*
*   FUNCTION
*	Creates the appropriate BorderLine and CollMask masks of the VSprite.
*	Correctly detects if the VSprite is actually a Bob definition, handles
*	the image data accordingly.
*
*   INPUTS
*	vs = pointer to the VSprite structure
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	InitGels()  graphics/gels.h
*
*****************************************************************************/

void __asm InitMasks(register __a0 struct VSprite *s)
{
    WORD i, j;
    WORD *sptr, *sptr2;
    WORD size;

    /* get word count per Planes */
    size = umuls(s->Height, s->Width);

    /* create the one-dimensional boundry-collision mask */

	/* bart - 03.12.86 */
	/* combined clear op with loop below */

	/* sptr2 = s->BorderLine;*/	/* point to area reserved for mask */
	/*for (i=1; i <= s->Width; i++)  *sptr2++ = 0;*/ /* clear borderline */

	/* end bart - 03.12.86 */

	sptr2 = s->BorderLine;	/* point to area reserved for mask */
	for (i=1; i <= s->Width; i++)
	{
	    /* bart - 03.12.86 */
	    /* combined clear op with this loop right here */
	    *sptr2 = 0; 
	    /* end bart - 03.12.86 */

	    sptr = (WORD *) ((BYTE *)(s->ImageData) + ((i-1)<<1));
	    /* sptr = top of image plus appropriate word offset  */
	    for (j=1; j <= s->Height; j++)
	    {	
		*sptr2 |= *sptr;
		sptr += s->Width;  /* next word is 1 Width away */
	    }
	    sptr2++;  /* next word of mask  */
	}


    /* create the two-dimensional shadow mask */

    if (s->Flags & VSPRITE) /* is this a VSprite? */
    {
        sptr = s->ImageData;
        sptr2 = s->CollMask;
	for (j = size; j; j--) *sptr2++ = *sptr++ | *sptr++;
    }
    else /* it's a Bob */
    {
        sptr = s->ImageData;
        sptr2 = s->CollMask;
        for (j = size; j; j--) *sptr2++ = *sptr++;

        for (i = s->Depth - 1; i; i--)  /* for the subsequent Depths */
	{
            sptr2 = s->CollMask;
            for (j = size; j; j--) *sptr2++ |= *sptr++;
	}
    }
}

/****** graphics.library/RemVSprite ******************************************
*
*   NAME
*	RemVSprite -- Remove a VSprite from the current gel list.
*
*   SYNOPSIS
*	RemVSprite(vs)
*	           A0
*
*	void RemVSprite(struct VSprite *);
*
*   FUNCTION
*	Unlinks the VSprite from the current gel list.
*
*   INPUTS
*	vs = pointer to the VSprite structure to be removed from the gel list
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	InitGels()  RemIBob()  graphics/gels.h
*
*****************************************************************************/

void __asm RemVSprite(register __a0 struct VSprite *s)
{
    s->PrevVSprite->NextVSprite = s->NextVSprite;
    s->NextVSprite->PrevVSprite = s->PrevVSprite;
}

/****** graphics.library/RemBob **********************************************
*
*   NAME
*	RemBob -- Macro to remove a Bob from the gel list.
*
*   SYNOPSIS
*	RemBob(bob)
*
*	RemBob(struct Bob *);
*
*   FUNCTION
*	Marks a Bob as no-longer-required.  The gels internal code then
*	removes the Bob from the list of active gels the next time
*	DrawGList is executed. This is implemented as a macro.
*	If the user is double-buffering the Bob, it could take two
*	calls to DrawGList before the Bob actually disappears from
*	the RastPort.
*
*   INPUTS
*	Bob = pointer to the Bob to be removed
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	RemIBob()  DrawGList()  graphics/gels.h  graphics/gfxmacros.h
*
*****************************************************************************/

/****** graphics.library/RemIBob **********************************************
*
*   NAME
*	RemIBob -- Immediately remove a Bob from the gel list and the RastPort.
*
*   SYNOPSIS
*	RemIBob(bob, rp, vp)
*	        A0   A1  A2
*
*	void RemIBob(struct Bob *, struct RastPort *, struct ViewPort *);
*
*   FUNCTION
*	Removes a Bob immediately by uncoupling it from the gel list and
*	erases it from the RastPort.
*
*   INPUTS
*	bob = pointer to the Bob to be removed
*	rp  = pointer to the RastPort if the Bob is to be erased
*	vp  = pointer to the ViewPort for beam-synchronizing
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	InitGels()  RemVSprite()  graphics/gels.h
*
*****************************************************************************/
void __regargs _RemIBob(struct Bob *b, struct RastPort *RPort, struct ViewPort *VPort)
{
    struct VSprite *bs;

    bs = b->BobVSprite;
    if (bs->Flags & BACKSAVED) clrBob(bs, RPort, VPort );
    RemVSprite(bs);
    b->Flags |= BOBNIX;
}

/****** graphics.library/SetCollision *****************************************
*
*   NAME
*	SetCollision -- Set a pointer to a user collision routine.
*
*   SYNOPSIS
*	SetCollision(num, routine, GInfo)
*	             D0   A0       A1
*
*	void SetCollision(ULONG, VOID (*)(), struct GelsInfo *);
*
*   FUNCTION
*	Sets a specified entry (num) in the user's collision vectors table
*	equal to the address of the specified collision routine.
*
*   INPUTS
*	num     = collision vector number
*	routine = pointer to the user's collision routine
*	GInfo   = pointer to a GelsInfo structure
*
*   RESULT
*
*   BUGS
* 
*   SEE ALSO
*	InitGels()  graphics/gels.h  graphics/rastport.h
*
*****************************************************************************/

void __asm SetCollision(register __d0 int h,register __a0 int (*p)(),
						register __a1 struct GelsInfo *GInfo)
{
    GInfo->collHandler->collPtrs[h] = p;
}

/****** graphics.library/SortGList *********************************************
*
*   NAME
*	SortGList -- Sort the current gel list, ordering its y,x coordinates.
*
*   SYNOPSIS
*	SortGList(rp)
*	          A1
*
*	void SortGList(struct RastPort *);
*
*   FUNCTION
*	Sorts the current gel list according to the gels' y,x coordinates.
*	This sorting is essential before calls to DrawGList or DoCollision.
*
*   INPUTS
*	rp = pointer to the RastPort structure containing the GelsInfo
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	InitGels()  DoCollision()  DrawGList()  graphics/rastport.h
*
*****************************************************************************/
void __asm SortGList(register __a1 struct RastPort *RPort)
{
    struct VSprite *s, *q, *send;
    /* struct VSprite *t; */

#ifdef DEBUG
	printf("RPOrt=%lx\n",RPort);
#endif

    s = RPort->GelsInfo->gelHead;
    q = s->NextVSprite;
    send = RPort->GelsInfo->gelTail;
    /* skip the head VSprite */
    while (q != send)
    {
        s = q;
        q = q->NextVSprite;
        sortVSprite(s);
    }
}

/* bart - 09.24.85 user call to RemIBob() vectored through here 	   */
/* this routine calls _RemIBob and then cleans up blissObjs left on queue  */

void __asm RemIBob(register __a0 struct Bob *b,
				register __a1 struct RastPort *RPort,
				register __a2 struct ViewPort *VPort)
{
    /* struct VSprite *bs; */
    struct GelsInfo *gi;

    gi = RPort->GelsInfo;

    /* initialize list of allocated blissObj's to zero */
    gi->firstBlissObj = 0;
    gi->lastBlissObj = 0;

    /* call c routine to remove the bob immediately */
    _RemIBob(b, RPort, VPort );

    /* now clean up */
    byebyeblissobjs(gi);

    /* done, so return to userproc */

}

/* end bart - 09.24.85 							*/

@


39.2
log
@moved collType to avoid forward reference
@
text
@d5 1
a5 1
*	$Id: gel.c,v 39.1 92/02/21 12:57:26 bart Exp Locker: bart $
d7 1
a7 1
*	$Locker: bart $
d10 3
a388 3
	struct GfxBase *GB;

	FETCHGBASE;
d390 1
a390 1
	if (GB->ChipRevBits0 & GFXF_BIG_BLITS)
a550 3
	struct GfxBase *GB;

	FETCHGBASE;
d552 1
a552 1
	if (GB->ChipRevBits0 & GFXF_BIG_BLITS)
@


39.1
log
@re-ordered functions for proto making from scracth
to avoid forward references
@
text
@d5 1
a5 1
*	$Id: gel.c,v 39.0 91/08/21 17:34:00 chrisg Exp Locker: bart $
d10 4
d580 7
d588 19
a637 26
}

__regargs collType(struct VSprite *s, struct VSprite *t)
/* if the hit masks coincide and there is a collision,
 *  return the bit position of the lowest-most set bit of the hit masks
 *  else return 0
 */
{
    WORD flag, pos;

#ifdef DEBUG
if (Debug & GELBUG) printf("CollType(%lx, %lx, %lx)\n", s, t );
#endif

/* assumes that s is to the left of and/or above t */
    if ( (flag = (t->HitMask & -2) & (s->MeMask & -2)) != 0 )
        if (checkColl(s, t ))
	{
            pos = 0;
            do
                pos++;
            while (((flag >>= 1) & 0x01) == 0);
            return((int) pos);
	}

    return(0);
@


39.0
log
@Bumped
@
text
@d5 1
a5 1
*	$Id: gel.c,v 37.6 91/05/14 16:10:58 chrisg Exp Locker: chrisg $
d7 1
a7 1
*	$Locker: chrisg $
d10 3
a744 38
/****** graphics.library/AddBob ***********************************************
*
*   NAME
*	AddBob -- Adds a Bob to current gel list.
*
*   SYNOPSIS
*	AddBob(Bob, rp)
*	       A0   A1
*
*	void AddBob(struct Bob *, struct RastPort *);
*
*   FUNCTION
*	Sets up the system Bob flags, then links this gel into the list
*	via AddVSprite.
*
*   INPUTS
*	Bob = pointer to the Bob structure to be added to the gel list
*	rp  = pointer to a RastPort structure
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	InitGels()  AddVSprite()  graphics/gels.h  graphics/rastport.h
*
*****************************************************************************/
void __asm AddBob(register __a0 struct Bob *b, register __a1 struct RastPort *RPort )
{

#ifdef DEBUG
if (Debug & GELBUG) printf("_AddBob(%lx, %lx, %lx)\n", b, RPort );
#endif

    b->Flags &= BUSERFLAGS;
    AddVSprite(b->BobVSprite, RPort );
}

d772 1
d774 1
a774 1
						register __a1 struct RastPort *RPort)
d814 39
d1079 33
a1177 32
}

/****** graphics.library/RemVSprite ******************************************
*
*   NAME
*	RemVSprite -- Remove a VSprite from the current gel list.
*
*   SYNOPSIS
*	RemVSprite(vs)
*	           A0
*
*	void RemVSprite(struct VSprite *);
*
*   FUNCTION
*	Unlinks the VSprite from the current gel list.
*
*   INPUTS
*	vs = pointer to the VSprite structure to be removed from the gel list
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	InitGels()  RemIBob()  graphics/gels.h
*
*****************************************************************************/

void __asm RemVSprite(register __a0 struct VSprite *s)
{
    s->PrevVSprite->NextVSprite = s->NextVSprite;
    s->NextVSprite->PrevVSprite = s->PrevVSprite;
@


37.6
log
@made work without glue routines
@
text
@d5 1
a5 1
*	$Id: gel.c,v 37.5 91/05/13 14:36:16 chrisg Exp Locker: chrisg $
d10 3
@


37.5
log
@removed compiler warnings for lattice
made use prototypes
got rid of interface code.. made routines take
arguments in registers.
@
text
@d5 1
a5 1
*	$Id: gel.c,v 37.4 91/05/02 16:45:53 chrisg Exp Locker: chrisg $
d10 6
d1256 3
a1258 3
void __asm XRemIBob(register __a0 struct Bob *b,
					register __a1 struct RastPort *RPort,
					register __a2 struct ViewPort *VPort)
@


37.4
log
@ killed "../" for lattice
@
text
@d5 1
a5 1
*	$Id: gel.c,v 37.3 91/02/15 11:00:47 spence Exp Locker: chrisg $
d10 3
d95 1
d100 1
d107 1
a107 3
int bndryHit(s, gi )
struct VSprite *s;
struct GelsInfo *gi;
d193 1
a193 1
        bptr = s->BorderLine;
d249 1
a249 1
    return(hit_val);
d258 1
a258 2
BOOL checkColl(a, b )
struct VSprite *a,*b;
d401 1
a401 1
BOOL checkColl(a, b )
d565 3
a567 4
downCheck(s, gi, real)
struct VSprite *s;      /* look down in list for collisions */
struct GelsInfo *gi;
struct VSprite *real;   /* apply result to real vsprite */
d598 1
a598 1
collType(s, t )
a602 1
struct VSprite *s, *t;
d618 1
a618 1
            return(pos);
d624 3
a626 4
BOOL setRects(high, wide, src, dest, dispx, dispy, RHeight, RWidth )
WORD high, wide;
struct gelRect *src, *dest;
WORD dispx, dispy;
d689 1
a689 2
sortVSprite(s)
struct VSprite *s;
d760 1
a760 3
_AddBob(b, RPort )
struct Bob *b;
struct RastPort *RPort;
d768 1
a768 1
    _AddVSprite(b->BobVSprite, RPort );
d798 2
a799 3
_AddVSprite(VS, RPort )
struct VSprite *VS;
struct RastPort *RPort;
d869 1
a869 2
_DoCollision(RPort )   /* check for all collisions in list */
struct RastPort *RPort;
d915 1
d946 4
a949 3
_InitGels(sHead, sTail, GInfo )
struct VSprite *sHead, *sTail;
struct GelsInfo *GInfo;
a950 1
    struct copins *c;
d1006 1
a1006 2
_InitMasks(s)
struct VSprite *s;
d1033 1
a1033 1
	    sptr = (BYTE *)(s->ImageData) + ((i-1)<<1);
d1123 1
a1123 4
_RemIBob(b, RPort, VPort )
struct Bob *b;
struct RastPort *RPort;
struct ViewPort *VPort;
d1129 1
a1129 1
    _RemVSprite(bs);
d1159 1
a1159 2
_RemVSprite(s)
struct VSprite *s;
d1193 3
a1195 4
_SetCollision(h, p, GInfo )
int h;
int (*p)();
struct GelsInfo *GInfo;
d1226 1
a1226 2
_SortGList(RPort )
struct RastPort *RPort;
d1250 3
a1252 4
_XRemIBob(b, RPort, VPort )
struct Bob *b;
struct RastPort *RPort;
struct ViewPort *VPort;
@


37.3
log
@Removed Bart's BORDERHIT fix (broke people :-( ).
@
text
@d5 1
a5 1
*	$Id: gel.c,v 37.2 91/02/12 15:49:01 spence Exp Locker: spence $
d7 1
a7 1
*	$Locker: spence $
d10 3
d90 2
a91 2
#include <../sane_names.h>
#include <../macros.h>
@


37.2
log
@autodoc
@
text
@d5 1
a5 1
*	$Id: gel.c,v 37.1 91/01/23 13:11:59 bart Exp Locker: spence $
d10 3
d901 1
a901 1
        if (bflag) if (t->HitMask & (1 << BORDERHIT)) 
@


37.1
log
@correct BORDERHIT processing (1 << BORDERHIT)
@
text
@d5 1
a5 1
*	$Id: gel.c,v 37.0 91/01/07 15:22:10 spence Exp Locker: bart $
d7 1
a7 1
*	$Locker: bart $
d10 3
a729 7
*    
*    NAME
*       AddBob  --  Adds a Bob to current gel list.
*    
*    SYNOPSIS
*       AddBob(Bob, rp)
*              a0   a1
d731 24
a754 15
*	struct Bob *Bob;
*	struct RastPort *rp;
*     
*    FUNCTION
*       Sets up the system Bob flags, then links this gel into the list
*           via AddVSprite.
*    
*    INPUTS
*       Bob = pointer to the Bob structure to be added to the gel list
*       rp = pointer to a RastPort structure
*    
*    BUGS
*    
*    SEE ALSO
*       InitGels  AddVSprite  graphics/gels.h  graphics/rastport.h
d771 24
a794 22
*    NAME
*       AddVSprite -- Add a VSprite to the current gel list.
*    
*    SYNOPSIS
*       AddVSprite(vs, rp)
*                  a0  a1
*    
*	struct VSprite *vs;
*	struct RastPort *rp;
* 
*    FUNCTION
*       Sets up the system VSprite flags
*       Links this VSprite into the current gel list using its Y,X
*    
*    INPUTS
*       vs = pointer to the VSprite structure to be added to the gel list
*       rp = pointer to a RastPort structure
*    
*    BUGS
*    
*    SEE ALSO
*	InitGels  graphics/rastport.h  graphics/gels.h
d839 15
a853 15
*    
*    NAME
*       DoCollision -- Test every gel in gel list for collisions.
*    
*    SYNOPSIS
*       DoCollision(rp)
*                   a1
*    
*	struct RastPort *rp;
* 
*    FUNCTION
*       Tests each gel in gel list for boundary and gel-to-gel collisions.
*       On detecting one of these collisions, the appropriate collision-
*	handling routine is called.  See the documentation for a thorough 
*	description of which collision routine is called. This routine 
d855 12
a866 9
*       The system routine SortGList performs this function for the user
*    
*    INPUTS
*       rp = pointer to a RastPort
*    
*    BUGS
*    
*    SEE ALSO
*       InitGels  SortGList  graphics/gels.h  graphics/gels.h
d915 1
a915 8
/****** graphics.library/InitGels *********************************************
*    
*    NAME
*       InitGels -- initialize a gel list; must be called before using gels.
*    
*    SYNOPSIS
*       InitGels(head, tail, GInfo)
*                a0    a1    a2
d917 13
a929 7
*	struct VSprite *head, *tail;
*	struct GelsInfo *GInfo;
*     
*    FUNCTION
*       Assigns the VSprites as the head and tail of the gel list in GfxBase.
*       Links these two gels together as the keystones of the list.
*       If the collHandler vector points to some memory array, sets 
d931 14
a944 11
*    
*    INPUTS
*       head = pointer to the VSprite structure to be used as the gel list head
*       tail = pointer to the VSprite structure to be used as the gel list tail
*       GInfo = pointer to the GelsInfo structure to be initialized
*    
*    BUGS
*    
*    SEE ALSO
*	graphics/gels.h   graphics/rastport.h
*****************************************************************************/
d978 25
a1002 22
*    
*    NAME
*       InitMasks -- Initialize the BorderLine and CollMask masks of a VSprite.
*    
*    SYNOPSIS
*       InitMasks(vs)
*                 a0
*    
*	struct VSprite *vs;
* 
*    FUNCTION
*       Creates the appropriate BorderLine and CollMask masks of the VSprite.
*       Correctly detects if the VSprite is actually a Bob definition, handles
*       the image data accordingly.
*    
*    INPUTS
*       vs = pointer to the VSprite structure
*    
*    BUGS
*    
*    SEE ALSO
*       InitGels  graphics/gels.h 
a1065 8
*    
*    NAME
*       RemBob -- Remove a Bob from the gel list.
*    
*    SYNOPSIS
*       RemBob(bob)
*    
*	struct Bob *bob;
d1067 12
a1078 4
*    FUNCTION
*       Marks a Bob as no-longer-required.  The gels internal code then
*	removes the Bob from the list of active gels the next time 
*	DrawGList is executed.   This is implemented as a macro.
d1082 11
a1092 8
*    
*    INPUTS
*       Bob = pointer to the Bob to be removed
*    
*    BUGS
*    
*    SEE ALSO
*       RemIBob  DrawGList  graphics/gels.h  graphics/gfxmacros.h
a1095 11
*    
*    NAME
*       RemIBob -- Immediately remove a Bob from the gel list and the RastPort.
*    
*    SYNOPSIS
*       RemIBob(bob, rp, vp)
*               a0   a1  a2
*    
*	struct Bob *bob;
*	struct RastPort *rp;
*	struct ViewPort *vp;
d1097 11
a1107 2
*    FUNCTION
*       Removes a Bob immediately by uncoupling it from the gel list and 
d1109 13
a1121 10
*    
*    INPUTS
*       bob = pointer to the Bob to be removed
*       rp = pointer to the RastPort if the Bob is to be erased
*       vp = pointer to the ViewPort for beam-synchronizing
*    
*    BUGS
*    
*    SEE ALSO
*       InitGels  RemVSprite  graphics/gels.h
a1136 9
*    
*    NAME
*       RemVSprite -- Remove a VSprite from the current gel list.
*    
*    SYNOPSIS
*       RemVSprite(vs)
*                  a0
*     
*	struct VSprite *vs;
d1138 22
a1159 10
*    FUNCTION
*       Unlinks the VSprite from the current gel list.
*    
*    INPUTS
*       vs = pointer to the VSprite structure to be removed from the gel list
*    
*    BUGS
*    
*    SEE ALSO
*       InitGels  RemIBob  graphics/gels.h
a1169 11
*    
*    NAME
*       SetCollision -- Set a pointer to a user collision routine.
*    
*    SYNOPSIS
*       SetCollision(num, routine, GInfo)
*                    d0   a0       a1
*    
*	ULONG num;
*	VOID (*routine)();
*	struct GelsInfo *GInfo;
d1171 11
a1181 2
*    FUNCTION
*       Sets a specified entry (num) in the user's collision vectors table 
d1183 13
a1195 10
*    
*    INPUTS
*       num = collision vector number
*       routine = pointer to the user's collision routine
*       GInfo = pointer to a GelsInfo structure
*    
*    BUGS
*    
*    SEE ALSO
*       InitGels  graphics/gels.h  graphics/rastport.h
d1206 24
a1229 19
*    
*    NAME
*       SortGList -- Sort the current gel list, ordering its y,x coordinates.
*    
*    SYNOPSIS
*       SortGList(rp)
*                 a1
*     
*    FUNCTION
*       Sorts the current gel list according to the gels' y,x coordinates.
*       This sorting is essential before calls to DrawGList or DoCollision.
*    
*    INPUTS
*       rp = pointer to the RastPort structure containing the GelsInfo
*    
*    BUGS
*    
*    SEE ALSO
*       InitGels  DoCollision  DrawGList  graphics/rastport.h
@


37.0
log
@initial switchover from V36
@
text
@d5 1
a5 1
*	$Id: gel.c,v 33.11 90/07/27 16:37:14 bart Exp Locker: spence $
d7 1
a7 1
*	$Locker: spence $
d10 3
d888 1
a888 1
        if (bflag) if (t->HitMask | BORDERHIT) 
@


33.11
log
@id
@
text
@d5 1
a5 1
*	$Id: $
d7 1
a7 1
*	$Locker: bart $
d10 3
@


33.10
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/graphics/gels/RCS/gel.c,v 33.9 90/03/19 13:20:43 bart Exp Locker: bart $
d10 3
@


33.9
log
@fix bug B6600
@
text
@d5 1
a5 1
*	$Header: gel.c,v 33.8 89/12/04 14:09:14 bart Exp $
d10 3
@


33.8
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: gel.c,v 33.7 89/12/04 14:03:01 bart Exp $
d10 3
d62 1
d542 2
a543 2
downCheck(s, gi )
struct VSprite *s;   /* look down in list for collisions */
d545 1
d552 1
a552 1
/* look forward */
d571 1
a571 1
            else (*gi->collHandler->collPtrs[type])(s, t);
d853 1
d855 5
d866 3
a868 1
        if (bflag) if (s->HitMask | BORDERHIT) if (b = bndryHit(s, gi ))
d870 4
a873 2
	    if(s->VSBob && ((s->VSBob)->Flags & BOBSAWAY));
            else (*gi->collHandler->collPtrs[BORDERHIT])(s, b);
d875 15
a889 1
        downCheck(s, gi );
@


33.7
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: gel.c,v 33.6 89/12/04 13:32:01 bart Exp $
d10 3
d857 1
a857 1
	    if((s->VSBob && ((s->VSBob)->Flags & BOBSAWAY));
@


33.6
log
@dont collide vsprite if bob and bobsaway
@
text
@d5 1
a5 1
*	$Header: gel.c,v 33.5 88/11/16 09:59:52 bart Exp $
d10 3
d57 1
d561 2
a562 2
	    if((s->VSBob && (s->VSBob->Flags & BOBSAWAY))
	    || (t->VSBob && (t->VSBob->Flags & BOBSAWAY)));
d854 1
a854 2
	    if((s->VSBob && (s->VSBob->Flags & BOBSAWAY))
	    || (b->VSBob && (b->VSBob->Flags & BOBSAWAY)));
@


33.5
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: gel.c,v 33.4 88/11/16 09:57:58 bart Exp $
d10 3
d556 5
a560 1
            (*gi->collHandler->collPtrs[type])(s, t);
d849 5
a853 1
            (*gi->collHandler->collPtrs[BORDERHIT])(s, b);
@


33.4
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: gel.c,v 33.3 88/11/16 09:54:20 bart Exp $
d10 3
d47 1
@


33.3
log
@big blits
@
text
@d5 1
a5 1
*	$Header: gel.c,v 33.2 86/07/01 11:30:02 bart Exp $
d10 3
d52 1
@


33.2
log
@documentation update to DoCollision : removed BUGS comment
@
text
@d5 1
a5 1
*	$Header: gel.c,v 33.1 86/06/17 10:17:15 bart Exp $
d10 3
d323 3
a325 1
    io->bltsize = blitsize;
d327 13
d488 16
a503 1
    custom.bltsize = ((gRa.rH<<6) + blitWidth);
@


33.1
log
@fixes collision bug #B2897
boffset now set correctly
@
text
@d5 1
a5 1
*	$Header: gel.c,v 33.0 86/05/17 15:22:58 bart Exp $
d10 4
a781 1
*       Doesn't handle gel-to-gel collisions completely correctly.
@


33.0
log
@added to rcs for updating
@
text
@d5 1
a5 1
*	$Header: $
d7 1
a7 1
*	$Locker: $
d9 4
a12 1
*	$Log: $
a265 1
    boffset =(umuls(((a->Y > b->Y)? (a->Y - b->Y): 0), b->Width))<<1;
d267 7
d304 2
a305 2
    fwmask = fwm;
    lwmask = lwm;
d409 6
a414 1
    boffset =(umuls(((a->Y > b->Y)? (a->Y - b->Y): 0), b->Width))<<1;
@
