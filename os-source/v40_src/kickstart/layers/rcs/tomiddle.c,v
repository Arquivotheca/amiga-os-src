head     38.16;
branch   ;
access   ;
symbols  V40_1:38.16 V39_62:38.16 V39_61:38.16 V39_60:38.16 V39_58:38.16 V39_56:38.16 V39_55:38.15 V39_54:38.15 V39_53:38.15 V39_52:38.15 V39_51:38.15 V39_50:38.15 V39_49:38.13 V39_48:38.13 V39_46:38.13 V39_45:38.13 V39_44:38.13 V39_42:38.13 V39_41:38.13 V39_40:38.13 V39_39:38.13 V39_38:38.13 V39_37:38.13 V39_36:38.13 V39_35:38.13 V39_34:38.13 V39_33:38.13 V39_32:38.13 V39_30:38.13 V39_28:38.11 V39_27:38.11 V39_26:38.11 V39_25:38.11 V39_24:38.11 V39_23:38.11 V39_22:38.11 V39_21:38.11 V39_20:38.11 V39_18:38.10 V39_16:38.8 V39_15:38.7 V39_14:38.7 V39_12:38.7 V39_10:38.5 V38_7:38.3 V38_6:38.3 First_Native_Build:38.2;
locks    ; strict;
comment  @ * @;


38.16
date     92.04.14.16.39.30;  author mks;  state Exp;
branches ;
next     38.15;

38.15
date     92.03.26.08.43.18;  author mks;  state Exp;
branches ;
next     38.14;

38.14
date     92.03.26.08.36.20;  author mks;  state Exp;
branches ;
next     38.13;

38.13
date     91.11.18.13.28.04;  author mks;  state Exp;
branches ;
next     38.12;

38.12
date     91.11.15.20.14.02;  author mks;  state Exp;
branches ;
next     38.11;

38.11
date     91.11.01.09.28.58;  author mks;  state Exp;
branches ;
next     38.10;

38.10
date     91.10.28.09.20.27;  author mks;  state Exp;
branches ;
next     38.9;

38.9
date     91.10.25.17.08.03;  author mks;  state Exp;
branches ;
next     38.8;

38.8
date     91.10.25.00.37.24;  author mks;  state Exp;
branches ;
next     38.7;

38.7
date     91.10.23.16.50.03;  author mks;  state Exp;
branches ;
next     38.6;

38.6
date     91.10.23.09.49.51;  author mks;  state Exp;
branches ;
next     38.5;

38.5
date     91.10.03.14.31.44;  author bart;  state Exp;
branches ;
next     38.4;

38.4
date     91.10.03.12.52.58;  author bart;  state Exp;
branches ;
next     38.3;

38.3
date     91.08.21.16.16.41;  author mks;  state Exp;
branches ;
next     38.2;

38.2
date     91.08.02.10.22.40;  author mks;  state Exp;
branches ;
next     38.1;

38.1
date     91.07.25.09.56.23;  author bart;  state Exp;
branches ;
next     ;


desc
@@


38.16
log
@Added the setting of two more bits for damage work
@
text
@/******************************************************************************
*
*   $Id: tomiddle.c,v 38.15 92/03/26 08:43:18 mks Exp Locker: mks $
*
******************************************************************************/

#define	NEWCLIPRECTS_1_1

#include <exec/types.h>
#include <exec/nodes.h>
#include <exec/lists.h>
#include <exec/ports.h>
#include <graphics/gfx.h>
#include <graphics/clip.h>
#include <graphics/layers.h>

#include "layersbase.h"

/****** layers.library/MoveLayerInFrontOf **************************************
*
*    NAME
*	MoveLayerInFrontOf -- Put layer in front of another layer.
*
*    SYNOPSIS
*	result = MoveLayerInFrontOf( layertomove, targetlayer )
*                                    a0           a1
*
*	LONG MoveLayerInFrontOf( struct Layer *, struct Layer *);
*
*    FUNCTION
*	Move this layer in front of target layer, swapping bits
*	in and out of the display with other layers.
*	If this is a refresh layer then collect damage list and
*	set the LAYERREFRESH bit in layer->Flags if redraw required.
*
*	Note: this operation may generate refresh events in other layers
*	    associated with this layer's Layer_Info structure.
*
*    INPUTS
*	layertomove - pointer to layer which should be moved
*	targetlayer - pointer to target layer in front of which to move layer
*
*    RESULTS
*	result = TRUE    if operation successful
*	         FALSE   if operation unsuccessful (probably out of memory)
*
*    BUGS
*
*    SEE ALSO
*	graphics/layers.h
*
*******************************************************************************/

long __stdargs __asm extern_movelayerinfrontof(register __a0 struct Layer *l,register __a1 struct Layer *target)
{
struct Layer_Info *li = l->LayerInfo;
long status = FALSE;

	if (fatten_lock(li))
	{
		if (movelayerinfrontof(l,target,FALSE))
		{
			regen_display(li);
			status = TRUE;
		}
		unlock_thin(li);
	}
	return(status);
}

/*
 * MKS:
 *
 * This is the new method to do movelayerinfrontof()
 * What I did was to start all over with a clean slate.
 * Since I know that the cliprects are complete
 * vertical cuts, some tricks can be used.  I will
 * also use the fact that they are sorted to make
 * use of faster search routines (or at least try to)
 *
 * Method:
 * First, find where the layer needs to be inserted...
 * This is done by setting layer priorities to all of
 * the layers and matching the priorities to the target.
 *
 * Next,...
 */
BOOL movelayerinfrontof(struct Layer *l,struct Layer *target,long flag)
{
struct Layer_Info *li=l->LayerInfo;
struct Layer *layer;
struct Layer *layer2;
struct ClipRect *cr;
struct ClipRect *cr2;
struct ClipRect *prealloc_cr=NULL;
struct ClipRect *stack_list=NULL;
struct LayerInfo_extra *old_lie;
struct LayerInfo_extra new_lie;
struct Rectangle damage;
ULONG l_flag;
ULONG layer_flag;
UWORD priority;

	if ((l->back!=target) && (l!=target)) /* not already there? */
	{
		/*
		 * Pre-generate a flag that will be used in a few loops...
		 */
		l_flag=(l->Flags & LAYERSIMPLE);

		/*
		 * First, we must set the priority value for each layer
		 * unless the target layer is NULL.  In this case, we
		 * will not need any priority settings other than the
		 * two below to indicate that we are moving to the back.
		 */
		priority=1;
		l->priority=0;
		if (target)
		{
			for (layer=li->top_layer;layer;layer=layer->back) layer->priority=priority++;

			/*
			 * Now, priority is past the last layer
			 * however, if we have a target layer,
			 * we get the priority of that layer as
			 * our target.  Our target is to have
			 * l->back->priority==priority or, in the
			 * case of no target, have layer->back==NULL
			 */
			priority=target->priority;
		}

		/*
		 * Set up the memory failure abort system
		 * before we continue...
		 */
		old_lie = li->LayerInfo_extra;
		li->LayerInfo_extra = &new_lie;
		if (aborted(li))
		{
			li->LayerInfo_extra = old_lie;

			/* actually only have to do this to obscured cr's */
			for (l=li->top_layer;l;l = l->back) if (l->Flags & LAYERSIMPLE) for (cr=l->ClipRect;cr;cr=cr->Next)
			{
				cr->BitMap = NULL;
				cr->Flags &= ~(CR_NEEDS_NO_LAYERBLIT_DAMAGE);
			}

			/***********************************/
			/**  WARNING!!!  Early RETURN!!!  **/
			/***********************************/
			return(FALSE);
		}

		/*
		 * So, we "know" where we need to go, but
		 * we also need to know how much memory we
		 * will need.  In fact, what we will do is
		 * allocate the cliprects/bitmaps that are
		 * needed for this operation to work.
		 * While we are doing this, we will also
		 * link the cliprects as needed to make for
		 * a much faster operation when we complete
		 * the examination.  Since the _p1 and _p2
		 * fields of the cliprect structure are
		 * "unused" we will use these to link together
		 * the cliprects.  _p1 will be used to point
		 * to the next cliprect below this one
		 * and _p2 will be used to point to the
		 * cliprect's layer.  (So we can find it)
		 */
		if (l->priority > priority)
		{
			/*
			 * Ok, so we are moving up in the layers...
			 * This means that we only need to deal with
			 * cliprect stacks that have our cliprect in it
			 * and are obscured by a layer that is now going
			 * to be obscured...
			 */
			for (cr2=(struct ClipRect *)&(l->ClipRect);cr=cr2->Next;cr2=cr2->Next) if (layer=cr->lobs) if (layer->priority >= priority)
			{
				/*
				 * Ok, so this cliprect is a match...  Lets
				 * build the VLink chain...
				 */
				cr->reserved=(LONG)stack_list;
				stack_list=cr;
				cr->prev=cr2;

				cr->_p1=NULL;
				cr->_p2=(void *)layer;
				vlink_cr(layer,cr,l);

				/*
				 * Now, check to see if we need to allocate some
				 * bitmaps:  If we are SIMPLE and the old obscuring
				 * layer is SMART, we will need to...
				 */
				if ((l_flag) && (!(layer->Flags & LAYERSIMPLE)))
				{
					get_concealed_rasters(l,cr);

					/*
					 * If we are MOVESIZE flag, we will also need this
					 */
					if (flag)
					{
						/*
						 * Now, also get a cliprect put together for later work...
						 */
						cr=AllocCR(li);
						cr->Next=prealloc_cr;
						prealloc_cr=cr;
					}
				}
			}
		}
		else
		{
			/*
			 * Ok, so we are going to go down... Clear the link status
			 * of the cliprects I will be looking at...
			 */
			for (layer=l->back;layer!=target;layer=layer->back)
			{
				for (cr=layer->ClipRect;cr;cr=cr->Next) cr->_p2=NULL;
			}

			/*
			 * Ok, so we are going down in the layer stack.
			 * This means that we will need to look at all of the layers
			 * starting with the one behind me and going to the target...
			 */
			for (layer=l->back;layer!=target;layer=layer->back) if (rectXrect(&(l->bounds),&(layer->bounds)))
			{
				layer_flag=(layer->Flags & LAYERSIMPLE);	/* Pregenerate the SIMPLE flag */

				/*
				 * Now, for all of the cliprects that are obscured by me...
				 * (We can skip ones that are already linked...
				 */
				for (cr2=(struct ClipRect *)&(layer->ClipRect);cr=cr2->Next;cr2=cr2->Next) if ((l==cr->lobs) && (!(cr->_p2)))
				{
					/*
					 * Well, we don't have this one linked yet so
					 * build the link chain...
					 */
					cr->reserved=(LONG)stack_list;
					stack_list=cr;
					cr->prev=cr2;

					cr->_p1=NULL;
					cr->_p2=(void *)layer;
					vlink_cr(layer,cr,NULL);

					/*
					 * Ok, so do we need to get some backing store?
					 */
					if ((!l_flag) && (layer_flag)) get_concealed_rasters(layer,cr);
				}
			}
		}

		/*
		 * Well, all the memory is here, now
		 * continue with the work after we uninstall
		 * the memory failure system...
		 */
		cleanup(li);
		li->LayerInfo_extra = old_lie;

		/*
		 * Ok, so, we now have a list of cliprects
		 * that point to cliprect stack that will change due
		 * to this great new layer position.  So, lets move
		 * the sucker...
		 */
		while (cr=stack_list)
		{
			stack_list=(struct ClipRect *)(cr->reserved);

			/*
			 * Now, if the obscuring layer is me, then the one
			 * that belongs to this cliprect will become obscuring
			 * if it is not me, then I will become obscuring.  These
			 * are the only two options at this point...
			 */
			cr2=cr;
			layer=cr2->lobs;
			layer2=l;
			if (l==layer) layer2=(struct Layer *)cr2->_p2;

			/*
			 * First we should fix up all of the clip rects to have
			 * the new Obscuring layer pointer...
			 */
			for (;cr;cr=(struct ClipRect *)(cr->_p1)) cr->lobs=layer2;

			/*
			 * At this point we have:
			 *
			 * cr2    == the cliprect of the layer that is going to be top...
			 * layer  == the layer that is going to be obscured...
			 * layer2 == the layer that is going to be on top...
			 *
			 * Now, update the screen as needed...
			 *
			 * If the layer coming to top is SIMPLE...
			 */
			if (layer2->Flags & LAYERSIMPLE)
			{
				if (layer->Flags & LAYERSIMPLE)
				{
					/*
					 * Check if MOVESIZE and set the information as needed
					 */
					if ((target==layer) && (flag)) cr2->Flags |= CR_NEEDS_NO_LAYERBLIT_DAMAGE;
				}
				else
				{
					/*
					 * If the layer on top is smart, we need to
					 * grab what is on the screen...
					 */
					screentocr(layer2->rp,cr2);

					/*
					 * So, we are in MOVESIZE and the
					 * layer will be simple...  We need a cliprect...
					 */
					if (flag)
					{
						cr=prealloc_cr;
						prealloc_cr=cr->Next;

						cr->bounds=cr2->bounds;
						if (cr->Next=cr2->Next) cr->Next->prev=cr;	/* Make sure pointers are ok... */
						cr2->Next=cr;
					}
				}

				/*
				 * The new top layer is simple, so it will do
				 * its own refresh once I let it...
				 *
				 * I will not do this if we have the MOVESIZE flag set...
				 */
				if (!flag)
				{
					damage.MinX=cr2->bounds.MinX - layer2->bounds.MinX;
					damage.MinY=cr2->bounds.MinY - layer2->bounds.MinY;
					damage.MaxX=cr2->bounds.MaxX - layer2->bounds.MinX;
					damage.MaxY=cr2->bounds.MaxY - layer2->bounds.MinY;

					CallBackFillHook(layer2,cr2);

					OrRectRegion(layer2->DamageList,&damage);
					layer2->Flags|=(LAYERREFRESH|LAYERIREFRESH|LAYERIREFRESH2);
				}
			}
			else
			{
				if (layer->Flags & LAYERSIMPLE)
				{
					/*
					 * Layer on top is simple and
					 * layer on bottom is smart...
					 */
					crtoscreen(layer2->rp,cr2);

					/*
					 * Make sure we WaitBlit before we
					 * free the rasters...
					 */
					WaitBlit();
					free_concealed_rasters(cr2);
				}
				else
				{
					/*
					 * Just swap the screen with the
					 * layer's cliprect...
					 */
					screenswap(layer2->rp,cr2);
				}
			}

			/*
			 * Now move the cliprect to the new layer
			 */
			cr=cr2->prev; if (cr->Next=cr2->Next) cr->Next->prev=cr;	/* Unlink... */

			cr=(struct ClipRect *)&(layer->ClipRect);
			cr2->prev=cr; if (cr2->Next=cr->Next) cr2->Next->prev=cr2;	/* Link... */
			cr->Next=cr2;
		}

		/*
		 * Ok, now all the hard stuff is done, just remove
		 * the layer and insert in the right spot.
		 */
		unlinklayer(l);
		insertlayer(target,l);
	}
	return(TRUE);
}
@


38.15
log
@Now only passes the layer and the cliprect
@
text
@d3 1
a3 1
*   $Id: tomiddle.c,v 38.14 92/03/26 08:36:20 mks Exp Locker: mks $
d361 1
a361 1
					layer2->Flags|=LAYERREFRESH;
@


38.14
log
@Does not pass the RP anymore to CallBackFillHook()
@
text
@d3 1
a3 1
*   $Id: tomiddle.c,v 38.13 91/11/18 13:28:04 mks Exp Locker: mks $
d358 1
a358 1
					CallBackFillHook(layer2->BackFill,layer2,cr2);
@


38.13
log
@Cleaned up how the backfill hook is called for a layer
@
text
@d3 1
a3 1
*   $Id: tomiddle.c,v 38.12 91/11/15 20:14:02 mks Exp Locker: mks $
d358 1
a358 1
					CallBackFillHook(layer2->BackFill,layer2->rp,layer2,cr2);
@


38.12
log
@Removed reference to the CR_NEEDS_NO_CONCEALED_RASTERS flag
@
text
@d3 1
a3 1
*   $Id: tomiddle.c,v 38.11 91/11/01 09:28:58 mks Exp Locker: mks $
d358 1
a358 6
					CallBackFillHook(layer2->BackFill,
							layer2->rp,
							layer2,
							cr2->bounds,
							cr2->bounds.MinX,
							cr2->bounds.MinY);
@


38.11
log
@Special case for TARGET==NULL
@
text
@d3 1
a3 1
*   $Id: tomiddle.c,v 38.10 91/11/01 08:18:58 mks Exp $
d148 1
a148 1
				cr->Flags &= ~(CR_NEEDS_NO_CONCEALED_RASTERS|CR_NEEDS_NO_LAYERBLIT_DAMAGE);
@


38.10
log
@Now uses the fact that vlink_cr() can skip a layer and thus
prevent the linking of the needed CR at the wrong spot and
thus making the later work go faster due to the fact that the
cliprect is the one on our list at the top.
@
text
@d3 1
a3 1
*   $Id: tomiddle.c,v 38.9 91/10/25 17:08:03 mks Exp Locker: mks $
d113 3
d118 4
a121 1
		for (layer=li->top_layer;layer;layer=layer->back) layer->priority=priority++;
d123 10
a132 9
		/*
		 * Now, priority is past the last layer
		 * however, if we have a target layer,
		 * we get the priority of that layer as
		 * our target.  Our target is to have
		 * l->back->priority==priority or, in the
		 * case of no target, have layer->back==NULL
		 */
		if (target) priority=target->priority;
@


38.9
log
@Major rework to add in a few optimizations along with the
new methods...  I now use locally double-linked cliprects.
That is, the cliprects that are needed are linked such that they
are double-linked...
@
text
@d3 1
a3 1
*   $Id: tomiddle.c,v 38.8 91/10/25 00:37:24 mks Exp Locker: mks $
a96 1
struct ClipRect dummy;
d176 1
a176 1
			for (cr=l->ClipRect;cr;cr=cr->Next) if (layer=cr->lobs) if (layer->priority >= priority)
d180 1
a180 1
				 * build the VLink chain...  (vlink_cr also sets up cr->prev)
d182 3
a184 5
				dummy.bounds=cr->bounds;		/* Copy our bounds */
				vlink_cr(layer,&dummy);			/* Build the list starting from behind the obscuring layer */
				cr2=(struct ClipRect *)(dummy._p1);	/* Get the top of the cliprect list */
				cr2->reserved=(LONG)stack_list;		/* Link into the chain of stacks... */
				stack_list=cr2;
d186 4
d207 3
a209 3
						cr2=AllocCR(li);
						cr2->Next=prealloc_cr;
						prealloc_cr=cr2;
d250 1
a250 1
					vlink_cr(layer,cr);
a276 2
			cr2=cr;
			layer=cr2->lobs;
d284 3
a287 11
			else
			{
				/*
				 * Ok, we are not the obscuring layer so that
				 * means we will become the obscuring layer.
				 * It also means that we need to find the
				 * cliprect that belongs to us...
				 */
				while (((struct Layer *)(cr2->_p2)) != l) cr2=(struct ClipRect *)(cr2->_p1);
				layer2=l;
			}
d291 1
a291 1
			 * the right Obscuring layer pointer...
@


38.8
log
@Complete rewrite of the tomiddle routine
Not all optimizations are in yet, but I wanted to release this
for testing...
@
text
@d3 1
a3 1
*   $Id: tomiddle.c,v 38.8 91/10/25 00:29:12 mks Exp Locker: mks $
d97 1
a102 1
ULONG tmp_flag;
d115 2
a116 1
		priority=set_pri(li->top_layer);
d168 1
a168 1
		for (layer=li->top_layer;layer;layer=layer->back) if (rectXrect(&(l->bounds),&(layer->bounds)))
d170 18
a187 1
			layer_flag=(layer->Flags & LAYERSIMPLE);	/* Pregenerate the SIMPLE flag */
a188 2
			for (cr=layer->ClipRect;cr;cr=cr->Next) if (cr->lobs)
			{
d190 3
a192 4
				 * Check if we are already linked...  If not,
				 * build the link chain...
				 * Also, before we work too hard, check to see that
				 * it even lands in our layer area...
d194 1
a194 1
				if (!(cr->_p2)) if (rectXrect(&(l->bounds),&(cr->bounds)))
d196 1
a196 2
					layer2=cr->lobs;
					tmp_flag=FALSE;		/* Default no action...   */
d199 1
a199 1
					 * Check if we are the obscuring layer
d201 1
a201 1
					if (l == layer2)
d204 1
a204 3
						 * and if so, are we going to not be
						 * the obscuring layer any more?
						 * If not, that means this stack will change...
d206 3
a208 17
						if (priority > layer->priority)
						{
							/*
							 * Ok, so this stack of cliprects will change
							 */
							tmp_flag=TRUE;

							/*
							 * Ok, we are going to blow out as the
							 * obscuring layer...
							 * So, check if we will need a backing store
							 */
							if ((!l_flag) && (layer_flag))
							{
								get_concealed_rasters(layer,cr);
							}
						}
d210 13
a222 8
					else if (priority <= layer2->priority)
					{
						/*
						 * Ok, so we are going to obscure the obscuring layer
						 * So, this stack will change...
						 */
						tmp_flag=TRUE;
					}
d224 8
a231 9

					/*
					 * Do the vertical linking if this stack of
					 * cliprects is going to change...
					 */
					if (tmp_flag)
					{
						cr->reserved=(LONG)stack_list;
						stack_list=cr;
a232 6
						cr->_p1=NULL;
						cr->_p2=(void *)layer;
						vlink_cr(layer,cr);
					}
				}

d234 2
a235 1
				 * Now, if this is our layer, we need to do some special work
d237 1
a237 1
				if ((l==layer) && (layer_flag))
d240 13
a252 3
					 * If we are going to become the obscuring layer
					 * for one of our cliprects, we need to check if
					 * we need a backing store for it...
d254 1
a254 18
					layer2=cr->lobs;
					if (priority <= layer2->priority) if (!(layer2->Flags & LAYERSIMPLE))
					{
						get_concealed_rasters(layer,cr);

						/*
						 * If we are MOVESIZE flag, we will also need this
						 */
						if (flag)
						{
							/*
							 * Now, also get a cliprect put together for later work...
							 */
							cr2=AllocCR(li);
							cr2->Next=prealloc_cr;
							prealloc_cr=cr2;
						}
					}
d285 1
a285 4
			if (l==layer)
			{
				layer2=(struct Layer *)cr2->_p2;
			}
a314 2
			tmp_flag=FALSE;	/* Flag to tell me to WaitBlit() */

d332 4
a335 1
					/* Why?  I do not know why this is here... */
d342 1
a342 1
						cr->Next=cr2->Next;
d382 2
a383 5
					 * In order to get some overlap,
					 * we will do some housekeeping
					 * before we WaitBlit() and free
					 * the bitmaps.  This flag signals
					 * the code below to do this...
d385 2
a386 1
					tmp_flag=TRUE;
d399 1
a399 1
			 * Now move the cliprect from the old layer to the new one...
d401 1
a401 2
			unlinkcr(layer2,cr2);
			linkcr(layer,cr2);
d403 3
a405 5
			if (tmp_flag)
			{
				WaitBlit();
				free_concealed_rasters(cr2);
			}
a415 21
}

void insertlayer(struct Layer *inbackof,struct Layer *l)
{
struct Layer *q;

	if (inbackof == 0)
	{
		if (q = l->LayerInfo->top_layer) for ( ; q->back != 0; q = q->back);
	}
	else
	{
		q = inbackof->front;
		inbackof->front = l;
	}

	l->back = inbackof;
	l->front = q;

	if (q)  q->back = l;
	else    l->LayerInfo->top_layer = l;
@


38.7
log
@Checking in for a quick release
@
text
@d3 1
a3 1
*   $Id: tomiddle.c,v 38.6 91/10/23 09:49:51 mks Exp Locker: mks $
d71 18
a88 1
void clear_simplelayer_bitmap_ptrs(struct Layer_Info *li)
d90 3
a92 1
struct Layer *l;
d94 10
d105 1
a105 2
	/* actually only have to do this to obscured cr's */
	for (l = li->top_layer; l ; l = l->back) if (l->Flags & LAYERSIMPLE) for (cr = l->ClipRect ; cr ; cr = cr->Next)
d107 4
a110 4
		cr->BitMap = 0;
		cr->Flags &= ~(CR_NEEDS_NO_CONCEALED_RASTERS|CR_NEEDS_NO_LAYERBLIT_DAMAGE);
	}
}
d112 4
a115 4
void swap_these(struct Layer *l,struct Layer *fr,struct ClipRect ***crp,long flag,struct ClipRect **buffer)
{
struct ClipRect *cr = **crp;
BOOL fr_simple = (fr->Flags & LAYERSIMPLE);
d117 9
d127 4
a130 96
	if ( l->Flags & LAYERSIMPLE )
	{   /* new upfront layer does its own refresh */
		if(!fr_simple)
		{
			/* the layer going behind needs transparent refresh */
			/* must allocate buffers */
			/* Dale, no longer needed if correctly preallocated */
			/*get_concealed_rasters(l,cr);*/
			/* will probably have to initialize to something */
			/* this will junk up display */
			/* but thats ok he's now supposed to refresh himself */

			screentocr(l->rp,cr);

			if (flag)
			{
			struct ClipRect *ncr = *buffer;

				if (ncr)
				{
					*buffer = ncr->Next;
					ncr->bounds = cr->bounds;
					/* insert the new cr */
					ncr->Next = cr->Next;
					**crp = ncr;
					*crp = (struct ClipRect **)**crp;
				}
			}
		}
		/* else, the screen that is going behind can refresh itself */

		if (!flag)
		{
		struct Rectangle damage;

			damage.MinX = cr->bounds.MinX - l->bounds.MinX;
			damage.MinY = cr->bounds.MinY - l->bounds.MinY;
			damage.MaxX = cr->bounds.MaxX - l->bounds.MinX;
			damage.MaxY = cr->bounds.MaxY - l->bounds.MinY;

			CallBackFillHook(l->BackFill,
					l->rp,
					l,
					cr->bounds,
					cr->bounds.MinX,
					cr->bounds.MinY);

			OrRectRegion(l->DamageList,&damage);
			l->Flags |= LAYERREFRESH;   /* trigger refresh */
		}
	}
	else
	{   /* layer coming to top has obscured buffers */
		if(fr_simple)
		{
			crtoscreen(l->rp,cr);
			WaitBlit();
			free_concealed_rasters(cr);
		}
		else screenswap(l->rp,cr);
	}
	/* unlink the old cr */ **crp = cr->Next;
	linkcr(fr,cr);
}

BOOL movelayerinfrontof(struct Layer *l,struct Layer *target,long flag)
{
struct Layer_Info *li = l->LayerInfo;

	/* move layer either up or back to place in new position */
	/* is all this work really necessary? */
	if ((l->back != target) && ( l != target) ) /* not already there? */
	{
	struct ClipRect *prealloc_cr = NULL;
	struct LayerInfo_extra *old_lie,new_lie;
	struct Layer *p;
	struct ClipRect *cr;
	struct ClipRect **crp;
	UWORD i=20000;
	UWORD target_pri;

		/* wow a new concept, lets keep a number associated with */
		/* this guys position in the layer list */
		for (p=li->top_layer;p;p=p->back)
		{
			/* Sort all of the layer's cliprects... */
			/*sort_layer_cr(p);*/
			p->priority=i--;
		}

		if (target) target_pri = target->priority;
		else target_pri = 0;

		/* goal is to make p->back equal target */
		/* look through all layers find who is now in front */

d135 1
a135 6
		/*
		 * MKS:  A bug was here were the cliprects were being
		 * released when they should not have been since they
		 * were released by the abortion.  This cleans up the
		 * one low-memory bug in layers under 2.04 ROM
		 */
d137 6
a142 2
			li->LayerInfo_extra = old_lie;
			clear_simplelayer_bitmap_ptrs(li);
d144 3
a146 3
			/*********************************/
			/*  WARNING!!!  Early RETURN!!!  */
			/*********************************/
d150 18
a167 2
		/* preprocess request and allocate needed memory */
		if (l->priority<target_pri) /* bring this baby closer to top */
d169 3
a171 1
			if (l->Flags & LAYERSIMPLE) for (crp = &l->ClipRect; cr = *crp; crp = (struct ClipRect **)*crp) if (cr->lobs)
d173 7
a179 4
				/* look through all of l's obscured pieces */
				/* is this cr obscured by a layer that we */
				/* are now going to obscure? */
				if ((cr->lobs->priority <= target_pri) && (!(cr->lobs->Flags & LAYERSIMPLE)))
d181 46
a226 1
					if (flag)
d228 2
a229 1
					struct ClipRect *pcr = (struct ClipRect *) AllocCR(li);
d231 3
a233 3
						/* guarantee enough memory for swap_these */
						pcr->Next = prealloc_cr;
						prealloc_cr = pcr;
a234 1
					get_concealed_rasters(l,cr);  /* fatten up */
d236 5
a240 9
			}
		}
		else if (!(l->Flags & LAYERSIMPLE))
		{
			/* for all layers behind this one till just before the target */
			for (p = l->back ; p != target ; p = p->back) if (rectXrect(&l->bounds,&p->bounds))
			{
				/* for all cliprects obscured by l */
				for (crp = &p->ClipRect; cr = *crp; crp = (struct ClipRect **)*crp) if (cr->lobs==l)
d242 7
a248 1
					if (!(cr->Flags & CR_NEEDS_NO_CONCEALED_RASTERS))
d250 1
a250 1
						if (p->Flags & LAYERSIMPLE) get_concealed_rasters(p,cr);
d252 12
a263 1
						set_cr_lobs(p->back,cr,NULL,-1,CR_NEEDS_NO_CONCEALED_RASTERS);
d269 5
d277 7
a283 1
		if (l->priority<target_pri ) /* bring this baby closer to top */
d285 15
a299 3
			/* look through all of l's obscured pieces */
			crp=&l->ClipRect;
			while (cr=*crp) if ((p=cr->lobs) && (p->priority <= target_pri))
d301 28
a328 11
				if( (flag) &&
				    (target==p) &&
				    (l->Flags & p->Flags & LAYERSIMPLE) )
				{
					/* protect movesizelayer from selfdamage */
					cr->Flags |= CR_NEEDS_NO_LAYERBLIT_DAMAGE;
				}

				/* must go back and update all the others that */
				/* this guy used to obscure */
				set_cr_lobs(p,cr,l,-1,0);
d330 1
a330 9
				swap_these(l,cr->lobs,&crp,flag,&prealloc_cr);
				cr->lobs = l;
			}
			else crp = (struct ClipRect **)*crp;
		}
		else
		{   /* sink this one back */
			/* for all layers behind this one till just before thetarget */
			for (p = l->back ; p != target ; p = p->back) if (rectXrect(&l->bounds,&p->bounds))
d332 14
a345 6
				/* for all cliprects obscured by l */
				crp=&p->ClipRect;
				while (cr=*crp) if (cr->lobs==l)
				{
					/* for all identical cliprects behind layer p */
					set_cr_lobs(p,cr,p,~CR_NEEDS_NO_CONCEALED_RASTERS,0);
d347 2
a348 2
					swap_these(p,l,&crp,flag,&prealloc_cr);
					if ((!flag) || (cr->lobs))
d350 6
a355 2
						cr->lobs = p;
						cr->Flags &= ~CR_NEEDS_NO_CONCEALED_RASTERS;
d358 64
a421 1
				else crp = (struct ClipRect **)*crp;
d424 5
a428 1
		/* now have to reinsert into layer list */
a433 1

@


38.6
log
@Saved many bytes and used a new routine...
@
text
@d3 1
a3 1
*   $Id: tomiddle.c,v 38.5 91/10/03 14:31:44 bart Exp Locker: mks $
d86 2
a87 2
	struct ClipRect *cr = **crp;
	BOOL fr_simple = (fr->Flags & LAYERSIMPLE);
d94 13
a106 13
		    /* the layer going behind needs transparent refresh */
		    /* must allocate buffers */
		    /* Dale, no longer needed if correctly preallocated */
		    /*get_concealed_rasters(l,cr);*/
		    /* will probably have to initialize to something */
		    /* this will junk up display */
		    /* but thats ok he's now supposed to refresh himself */

		    screentocr(l->rp,cr);

		    if(flag)
		    {
				struct ClipRect *ncr = *buffer;
d108 1
a108 1
				if(ncr)
d110 2
a111 2
				    *buffer = ncr->Next;
				    ncr->bounds = cr->bounds;
d117 1
a117 1
		    }
d121 1
a121 1
		if(!flag)
d123 1
a123 1
			struct Rectangle damage;
d130 6
a135 6
	   	    CallBackFillHook(l->BackFill,
				    l->rp,
				    l,
				    cr->bounds,
				    cr->bounds.MinX,
				    cr->bounds.MinY);
d138 1
a138 1
		    l->Flags |= LAYERREFRESH;   /* trigger refresh */
d173 6
a178 1
		for (p = li->top_layer; p ; p = p->back ) p->priority = i--;
@


38.5
log
@saved 8 bytes
@
text
@d3 1
a3 1
*   $Id: tomiddle.c,v 38.4 91/10/03 12:52:58 bart Exp Locker: bart $
d59 10
a68 10
    if (fatten_lock(li))
    {
        if (movelayerinfrontof(l,target,FALSE))
        {
            regen_display(li);
            status = TRUE;
        }
        unlock_thin(li);
    }
    return(status);
d76 6
a81 9
    /* actually only have to do this to obscured cr's */
    for (l = li->top_layer; l ; l = l->back)
        if (l->Flags & LAYERSIMPLE)
            for (cr = l->ClipRect ; cr ; cr = cr->Next)
            {
                cr->BitMap = 0;
                cr->Flags &=
		~(CR_NEEDS_NO_CONCEALED_RASTERS|CR_NEEDS_NO_LAYERBLIT_DAMAGE);
            }
d84 71
d159 4
a162 4
    /* move layer either up or back to place in new position */
    /* is all this work really necessary? */
    if ((l->back != target) && ( l != target) ) /* not already there? */
    {
d164 50
a213 57
        struct LayerInfo_extra *old_lie,new_lie;
        struct Layer *p;
        struct ClipRect *cr,*cr2;
        struct ClipRect **crp;
        UWORD i=20000;

        UWORD target_pri;

        /* wow a new concept, lets keep a number associated with */
        /* this guys position in the layer list */
        for (p = li->top_layer; p ; p = p->back ) p->priority = i--;

        if (target) target_pri = target->priority;
        else target_pri = 0;

        /* goal is to make p->back equal target */
        /* look through all layers find who is now in front */

        old_lie = li->LayerInfo_extra;
        li->LayerInfo_extra = &new_lie;
        if (aborted(li))
        {
/*
	MKS:  This is not needed... Since the allocations that happen
	during the abortion control are all contained within the
	abortion cleanup, there should be nothing left to clean up.
	This fixes the one low-memory bug in layers under 2.04...

	struct ClipRect *pcr;

	    while(pcr = prealloc_cr)
	    {
		prealloc_cr = pcr->Next;
		Freecr(pcr);
	    }
*/
            li->LayerInfo_extra = old_lie;
            clear_simplelayer_bitmap_ptrs(li);
            return(FALSE);
        }

        /* preprocess request and allocate needed memory */
        if (l->priority < target_pri ) /* bring this baby closer to top */
        {
            if (l->Flags & LAYERSIMPLE)
            {
                /* look through all of l's obscured pieces */
				for (crp = &l->ClipRect; cr = *crp; )
                {
                    if (cr->lobs)
                    {
                        /* is this cr obscured by a layer that we */
                        /* are now going to obscure? */
                        if (cr->lobs->priority <= target_pri)
                        {

			    /* yup, you bet */
d215 15
a229 3
                            if ((cr->lobs->Flags & LAYERSIMPLE) == 0)
                            {
				if(flag)
d231 6
a236 4
				    /* guarantee enough memory for swap_these */
				    struct ClipRect *pcr = (struct ClipRect *) AllocCR(li);
				    pcr->Next = prealloc_cr;
				    prealloc_cr = pcr;
d238 15
a252 25
                                get_concealed_rasters(l,cr);    /* fatten up */
			    }
                        }
                    }
					crp = (struct ClipRect **)*crp;
                }
            }
        }
        else    /* push back */
        {
            struct Layer *q;
            if ((l->Flags & LAYERSIMPLE) == 0)
            {
                /* for all layers behind this one till just before the target */
                for (p = l->back ; p != target ; p = p->back)
                {
		    /* if these layers intersect at all -- bart */
		    if (rectXrect(&l->bounds,&p->bounds))
                    /* for all cliprects obscured by l */
                    for (crp = &p->ClipRect; cr = *crp; )
					{
                        if (cr->lobs == l)
                            if ((cr->Flags & CR_NEEDS_NO_CONCEALED_RASTERS)==0)
                            {
                                if (p->Flags & LAYERSIMPLE)
d254 2
a255 1
                                    get_concealed_rasters(p,cr);
d258 26
a283 9
                                /* now mark all identical ones as processed */
                                for (q = p->back; q ; q = q->back)
                                {
                                    if (q->Flags & LAYERSIMPLE)
                                        if (cr2 = search_obs_cr(q,&cr->bounds))
                                            cr2->Flags |= CR_NEEDS_NO_CONCEALED_RASTERS;
                                }
                            }
						crp = (struct ClipRect **)*crp;
d285 9
a293 93
                }
            }
        }
        cleanup(li);
        li->LayerInfo_extra = old_lie;

        if (l->priority < target_pri ) /* bring this baby closer to top */
        {
            /* look through all of l's obscured pieces */
            for (crp = &l->ClipRect ; cr = *crp; )
            {
                if (p = cr->lobs)
                {
                    /* is this cr obscured by a layer */
                    /* that we are now going to obscure? */

                    if (p->priority <= target_pri)
                    {
                        /* yup, you bet */

						if( (flag)
						&&  (target == p)
						&&  (l->Flags & p->Flags & LAYERSIMPLE) )
						{
						    /* protect movesizelayer from selfdamage */
						    cr->Flags |= CR_NEEDS_NO_LAYERBLIT_DAMAGE;
						}

                        /* must go back and update all the others that */
                        /* this guy used to obscure */
                        /* for all layers behind this one do */

                        /* for ( p = cr->lobs; p ; p = p->back) */ while( p )
                        {
                            if (p != l)
							/* if these layers intersect at all -- bart */
							if (rectXrect(&l->bounds,&p->bounds))
							if (cr2 = search_obs_cr(p,&cr->bounds))
							{
								cr2->lobs = l;
							}
							p = p->back;
                        }

                        swap_these(l,cr->lobs,&crp,flag,&prealloc_cr);
						cr->lobs = l;
						continue;
                    }
                }
				crp = (struct ClipRect **)*crp;
            }
        }
        else
        {   /* sink this one back */
            struct Layer *p1;
            /* for all layers behind this one till just before thetarget */
            for (p = l->back ; p != target ; p = p->back)
            {
				/* if these layers intersect at all -- bart */
				if (rectXrect(&l->bounds,&p->bounds))
                /* for all cliprects obscured by l */
	            for (crp = &p->ClipRect ; cr = *crp; )
                {
                    if (cr->lobs == l)
                    {
                        /* for all identical cliprects behind layer p */
                        for (p1 = p->back ; p1 ; p1 = p1->back)
                        {
						    /* if these layers intersect at all -- bart */
						    if (rectXrect(&p->bounds,&p1->bounds))
                            if (cr2 = search_obs_cr(p1,&cr->bounds))
                            {
                                cr2->lobs = p;
                                cr2->Flags &= ~CR_NEEDS_NO_CONCEALED_RASTERS;
                            }
                        }
						swap_these(p,l,&crp,flag,&prealloc_cr);
                        if( (!flag) || cr->lobs )
						{
						    cr->lobs = p;
						    cr->Flags &= ~CR_NEEDS_NO_CONCEALED_RASTERS;
						}
						continue;
                    }
					crp = (struct ClipRect **)*crp;
                }
            }
        }
        /* now have to reinsert into layer list */
        unlinklayer(l);
        insertlayer(target,l);
    }
    return (TRUE);
d301 15
a315 14
    if (inbackof == 0)
    {
        if (q = l->LayerInfo->top_layer)
            for ( ; q->back != 0; q = q->back);
    }
    else
    {
        q = inbackof->front;
        inbackof->front = l;
    }
    l->back = inbackof;
    l->front = q;
    if (q)  q->back = l;
    else    l->LayerInfo->top_layer = l;
@


38.4
log
@used pointer pointers for loops
and in call to swap_these
@
text
@d3 1
a3 1
*   $Id: tomiddle.c,v 38.3 91/08/21 16:16:41 mks Exp Locker: bart $
d213 1
a213 1
                if (cr->lobs)
d218 1
a218 1
                    if (cr->lobs->priority <= target_pri)
d223 2
a224 2
						&&  (target == cr->lobs)
						&&  (l->Flags & cr->lobs->Flags & LAYERSIMPLE) )
d234 1
a234 1
                        for (p = cr->lobs ; p ; p = p->back)
d243 1
@


38.3
log
@Fixed the one low-memory bug in layers under 2.04
This was rather tricky to find!
@
text
@d3 1
a3 1
*   $Id: tomiddle.c,v 38.2 91/08/02 10:22:40 mks Exp Locker: mks $
d99 1
d143 1
a143 1
                for (cr = l->ClipRect ; cr ; cr = cr->Next)
d167 1
a173 1
            struct ClipRect *cr2;
d182 2
a183 1
                    for (cr = p->ClipRect; cr ; cr = cr->Next)
d200 2
d211 1
a211 1
            for (cr = l->ClipRect ; cr ; cr = cr2)
a212 1
                cr2 = cr->Next;
d222 7
a228 7
			if( (flag)
			&&  (target == cr->lobs)
			&&  (l->Flags & cr->lobs->Flags & LAYERSIMPLE) )
			{
			    /* protect movesizelayer from selfdamage */
			    cr->Flags |= CR_NEEDS_NO_LAYERBLIT_DAMAGE;
			}
d237 6
a242 7
				/* if these layers intersect at all -- bart */
				if (rectXrect(&l->bounds,&p->bounds))
                                if (cr2 = search_obs_cr(p,&cr->bounds))
				{
					cr2->lobs = l;
				}
                            cr2 = cr->Next;
d245 3
a247 2
                        swap_these(l,cr->lobs,cr,flag,&prealloc_cr);
			cr->lobs = l;
d250 1
d259 2
a260 2
		/* if these layers intersect at all -- bart */
		if (rectXrect(&l->bounds,&p->bounds))
d262 1
a262 1
                for (cr = p->ClipRect; cr ; cr = cr2)
d269 2
a270 2
			    /* if these layers intersect at all -- bart */
			    if (rectXrect(&p->bounds,&p1->bounds))
d277 1
a277 2
                        cr2 = cr->Next;
			swap_these(p,l,cr,flag,&prealloc_cr);
d279 5
a283 4
			{
			    cr->lobs = p;
			    cr->Flags &= ~CR_NEEDS_NO_CONCEALED_RASTERS;
			}
d285 1
a285 1
                    else cr2 = cr->Next;
@


38.2
log
@Native build version checkin...
@
text
@d3 1
a3 1
*   $Id: tomiddle.c,v 38.1 91/07/25 09:56:23 bart Exp $
d117 5
a121 1
	    struct ClipRect *pcr;
d123 2
d130 1
a130 1

@


38.1
log
@begin_v38_development
@
text
@d3 1
a3 1
*   $Id: tomiddle.c,v 1.20 91/01/28 16:59:52 bart Exp $
d7 2
a18 4
/*#define DEBUG*/

struct ClipRect *search_obs_cr();

d35 1
a35 1
*   
d54 1
a54 2
extern_movelayerinfrontof(l,target)
struct Layer *l,*target;
d56 2
a57 2
    struct Layer_Info *li = l->LayerInfo;
    short status = FALSE;
d71 1
a71 2
clear_simplelayer_bitmap_ptrs(li)
struct Layer_Info *li;
d73 3
a75 2
    struct Layer *l;
    struct ClipRect *cr;
d82 1
a82 1
                cr->Flags &= 
d87 1
a87 3
movelayerinfrontof(l,target,flag) /* ignore BACKDROPS */
struct Layer *l,*target;
int flag; 	/* prealloc_cr case simple refresh windows */
d89 1
a89 5
    struct Layer_Info *li = l->LayerInfo;

#ifdef DEBUG
    printf("movelayerinfrontof(%lx,%lx)\n",l,target);
#endif
a111 3
#ifdef DEBUG
        printf("lpri=%ld tpri=%ld\n",l->priority,target_pri);
#endif
a134 3
#ifdef DEBUG
                printf("may have to preallocate buffers\n");
#endif
d149 2
a150 2
				if(flag) 
				{  
d153 1
a153 1
				    pcr->Next = prealloc_cr;			
a155 3
#ifdef DEBUG
                                printf(" ******************getting concealed rasters\n");
#endif
d158 1
a158 1
                        }    
d160 1
a160 1
                }    
a168 3
#ifdef DEBUG
                printf("preallocate push back buffers\n");
#endif
a194 3
#ifdef DEBUG
        printf("call cleanup\n");
#endif
a200 3
#ifdef DEBUG
            printf("push up\n");
#endif
a210 2
			struct ClipRect *newcr;

d213 2
a214 2
			if( (flag) 
			&&  (target == cr->lobs) 
a245 3
#ifdef DEBUG
            printf("sink back\n");
#endif
a248 3
#ifdef DEBUG
                printf("checking p = %lx\n",p);
#endif
a253 3
#ifdef DEBUG
                    printf("checking cr = %lx (%d,%d,%d,%d)\n",cr,cr->bounds);
#endif
d269 1
a269 1
                        if( (!flag) || cr->lobs ) 
a282 3
#ifdef DEBUG
    printf("exit movelayerinfrontof\n");
#endif
d287 1
a287 2
insertlayer(inbackof,l)
struct Layer *inbackof,*l;
d289 2
a290 4
    struct Layer *q;
#ifdef DEBUG
    printf("insertlayer(%lx,%lx)\n",inbackof,l);
#endif
@
