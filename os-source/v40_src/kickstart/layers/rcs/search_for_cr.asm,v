head     38.24;
branch   ;
access   ;
symbols  V40_1:38.24 V39_62:38.24 V39_61:38.24 V39_60:38.24 V39_58:38.24 V39_56:38.24 V39_55:38.24 V39_54:38.24 V39_53:38.24 V39_52:38.24 V39_51:38.24 V39_50:38.24 V39_49:38.24 V39_48:38.24 V39_46:38.24 V39_45:38.24 V39_44:38.24 V39_42:38.24 V39_41:38.24 V39_40:38.24 V39_39:38.24 V39_38:38.24 V39_37:38.24 V39_36:38.23 V39_35:38.22 V39_34:38.22 V39_33:38.22 V39_32:38.22 V39_30:38.22 V39_28:38.22 V39_27:38.22 V39_26:38.22 V39_25:38.22 V39_24:38.21 V39_23:38.21 V39_22:38.19 V39_21:38.19 V39_20:38.18 V39_18:38.17 V39_16:38.15 V39_15:38.14 V39_14:38.13 V39_12:38.12 V39_10:38.9 V38_7:38.5 V38_6:38.5 First_Native_Build:38.2;
locks    ; strict;
comment  @@;


38.24
date     92.01.09.11.52.08;  author mks;  state Exp;
branches ;
next     38.23;

38.23
date     91.12.31.19.48.26;  author mks;  state Exp;
branches ;
next     38.22;

38.22
date     91.11.08.16.49.19;  author mks;  state Exp;
branches ;
next     38.21;

38.21
date     91.11.07.14.57.26;  author mks;  state Exp;
branches ;
next     38.20;

38.20
date     91.11.04.18.44.41;  author mks;  state Exp;
branches ;
next     38.19;

38.19
date     91.11.01.19.55.21;  author mks;  state Exp;
branches ;
next     38.18;

38.18
date     91.10.29.13.05.03;  author mks;  state Exp;
branches ;
next     38.17;

38.17
date     91.10.28.09.19.31;  author mks;  state Exp;
branches ;
next     38.16;

38.16
date     91.10.25.17.09.43;  author mks;  state Exp;
branches ;
next     38.15;

38.15
date     91.10.25.00.28.33;  author mks;  state Exp;
branches ;
next     38.14;

38.14
date     91.10.24.13.49.42;  author mks;  state Exp;
branches ;
next     38.13;

38.13
date     91.10.24.10.24.49;  author mks;  state Exp;
branches ;
next     38.12;

38.12
date     91.10.23.16.52.34;  author mks;  state Exp;
branches ;
next     38.11;

38.11
date     91.10.23.09.52.25;  author mks;  state Exp;
branches ;
next     38.10;

38.10
date     91.10.22.17.06.02;  author mks;  state Exp;
branches ;
next     38.9;

38.9
date     91.09.27.15.30.20;  author mks;  state Exp;
branches ;
next     38.8;

38.8
date     91.08.30.12.03.13;  author mks;  state Exp;
branches ;
next     38.7;

38.7
date     91.08.30.11.50.04;  author mks;  state Exp;
branches ;
next     38.6;

38.6
date     91.08.30.11.30.35;  author mks;  state Exp;
branches ;
next     38.5;

38.5
date     91.08.27.14.12.24;  author mks;  state Exp;
branches ;
next     38.4;

38.4
date     91.08.20.10.37.31;  author mks;  state Exp;
branches ;
next     38.3;

38.3
date     91.08.16.08.32.29;  author mks;  state Exp;
branches ;
next     38.2;

38.2
date     91.08.02.10.18.19;  author mks;  state Exp;
branches ;
next     38.1;

38.1
date     91.07.25.09.56.18;  author bart;  state Exp;
branches ;
next     ;


desc
@@


38.24
log
@Now obsolete.  code moved to the dedicer.asm and crtools.asm files.
@
text
@*******************************************************************************
*
*	$Id: search_for_cr.asm,v 38.23 91/12/31 19:48:26 mks Exp Locker: mks $
*
*******************************************************************************
*
	Now obsolete!
@


38.23
log
@New: rebuild system is only called if cliprect count is too high
This made a major performance improvement since rebuilds do not
happen as often anymore.
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.22 91/11/08 16:49:19 mks Exp Locker: mks $
d7 1
a7 863
* This file seems to have grown from just cliprect search to a whole
* set of features...  The file name may need to be changed soon.
*
*******************************************************************************
*
	include 'exec/types.i'
	include 'exec/nodes.i'
	include 'exec/lists.i'
	include 'graphics/clip.i'
	include	'graphics/layers.i'
	include	'layersbase.i'
*
*******************************************************************************
*
		xref	_LVOWaitBlit
		xref	_LVOFreeMem
		xref	_rectXrect
		xref	_unslice
		xref	_free_concealed_rasters
		xref	_rebuildcliprects
*
*******************************************************************************
*
* fast routine to search for a cliprect in a list given pointer to
* layer.	a0=layer	a1=bounds
*
_search_for_cr:	xdef	_search_for_cr
search_for_cr:	movem.l	(a1),d1/a1	* get xmin,ymin,xmax,ymax
*		move.l	(a1),d1		* get xmin,ymin
*		move.l	4(a1),a1	* get xmax,ymax
*
		lea	lr_ClipRect(a0),a0	; Point at CR pointer
		bra.s	next			; Start the loop...
*
lp_cr:		move.l	d0,a0		; Move cliprect to A0
		cmp.l	cr_MinX(a0),d1	; Check if same...
		bne.s	next		; If not, do next...
		cmp.l	cr_MaxX(a0),a1	; Check if match
		beq.s	match_cr	; If match, return d0
next:		move.l	(a0),d0		; Get next CR
		bne.s	lp_cr		; Check some more...
match_cr:	rts
*
*******************************************************************************
*
* New search for cliprect given a pointer to the last cliprect.
* It does not search the cliprect given as a pointer.
* It returns a pointer to a cliprect.
* If nothing is found, it will return NULL
*
* To increase speed, it assumes that the list is sorted with the function
* below and thus will abort the search if it notices it went too far.
*
*	a0 = pointer to cliprect pointer
*	a1 = bounds (just like search_for_cr)
*
*	returns d0 = pointer to matching cliprect.  (ClipRect *)
*
_search_next_cr:	xdef	_search_next_cr
search_next_cr:	movem.l	(a1),d1/a1	* get xmin,ymin,xmax,ymax
*		move.l	(a1),d1		* get xmin,ymin
*		move.l	4(a1),a1	* get xmax,ymax
*
next_cr:	move.l	(a0),d0		; Get next cliprect...
		beq.s	end_cr		; If NULL, we are done...
		move.l	d0,a0		; Set up answer
		cmp.l	cr_MinX(a0),d1	; Check if same Min values
		blt.s	no_cr		; if we passed the cliprect...
		bne.s	next_cr		; If not, check the next one...
		cmp.l	cr_MaxX(a0),a1	; Check if same Max values
		bne.s	next_cr		; If not, check the next one...
end_cr:		rts			; Return with d0 result...
no_cr:		moveq.l	#0,d0		; We have no CR...
		rts			; and return...
*
*******************************************************************************
*
* This search function, you pass in a cliprect and it returns either
* a cliprect that "attaches" to it or NULL if one does not.
* It only looks at the right/bottom sides of the cliprect for a match...
* It also uses the fact that the cliprect list is sorted and thus
* will early terminate any search that it may run into.
* It also check to see that matching cliprects are obscured by the same layer.
* Then, if the cliprect still looks like it can be dediced, it will be
* verified (in verify_dedice).  All of these routines require that the
* cliprect list is sorted.
*
*	a0 = pointer to cliprect
*	a2 = pointer to layer  (for verify_dedice)
*	returns d0 = pointer to result cliprect  (or NULL)
*
_search_side_cr:	xdef	_search_side_cr
search_side_cr:	move.l	a0,a1		; a1 will be our cliprect thing...
*
* First search for a bottom match...  So look for a top left that
* matches this cliprect's bottom left.
*
		move.l	cr_MinX(a0),d1	; Get X/Y for top left
		move.w	cr_MaxY(a0),d1	; Get Y from bottom...
		addq.w	#1,d1		; Bump by 1...
b_l_look:	move.l	(a1),d0		; Get next cliprect...
		beq.s	end_cr		; If NULL, we did not find one...
		move.l	d0,a1		; Set up for next load...
		cmp.l	cr_MinX(a1),d1	; Check if this is good...
		blt.s	look_side	; If passed it, look at side now...
		bne.s	b_l_look	; If not match, look some more...
*
* Matches one corner, now check for the other...
*
		move.w	cr_MaxX(a0),d1	; Get MaxX from source cliprect
		cmp.w	cr_MaxX(a1),d1	; Check for a match
		bne.s	look_side	; If no match, we continue on the side
		move.l	cr_lobs(a0),d1	; Now, check for same obscure layer
		cmp.l	cr_lobs(a1),d1	; And do we have a winner?
		bne.s	look_side	; If not the same, we do next one...
		bsr.s	verify_dedice	; Verify that the dedice can work
		tst.l	d1		; Check result
		bne.s	end_cr		; It is good, so exit...
*
* Now, we need to ckeck for a side match....  So look for a top left that
* matches this cliprect's top right...
look_side:	move.w	cr_MaxX(a0),d1	; Get MaxX...
		addq.w	#1,d1		; Move over 1...
		swap	d1		; Put this into the high word
		move.w	cr_MinY(a0),d1	; Get Y from top...
		bra.s	side_skip	; Skip the next few bytes
t_r_look:	move.l	(a1),d0		; Get next cliprect...
		beq.s	end_cr		; Check if we found it...
		move.l	d0,a1		; Set up for next load...
side_skip:	cmp.l	cr_MinX(a1),d1	; Check for a top-left match
		blt.s	no_cr		; If we passed it, return NULL
		bne.s	t_r_look	; If no match, check next
*
* Matches one corner, now check for the other...
*
		move.w	cr_MaxY(a0),d1	; Get MaxY from source cliprect
		cmp.w	cr_MaxY(a1),d1	; Check if it is ok...
		bne.s	no_cr		; If no match, we are done...
		move.l	cr_lobs(a0),d1	; Now, check for same obscure layer
		cmp.l	cr_lobs(a1),d1	; And do we have a winner?
		bne.s	no_cr		; If not same, we exit...
		bsr.s	verify_dedice	; Verify that the dedice can work
		tst.l	d1		; Check result
		bne.s	end_cr		; It is good, so exit...
		bra.s	no_cr		; No match, so return NULL...
*
*******************************************************************************
*
* verify_dedice - This checks to see if the now matching cliprects can
* be dediced based on the cliprect stacks...  This routine will link
* all cliprects in the stacks together such that the real dedice will
* not need to...  Only the cr1 list will contain the layer pointer...
*
* We get cliprects in a0 and a1  (a0 is the first cliprect)
* We get the layer pointer in a2
* We return result in d1
* We *MUST* *NOT* trash anything other than d1!
*
verify_dedice:	movem.l	d0/a2/a3/a4/a5,-(sp)
*
* Now, build a rectangle structure that is the combination of
* the two cliprects that are going to be used...
*
* We use the fact that the first cliprect is always the top/left one
* and that the second cliprect is always the bottom/right one.
*
		move.l	cr_MaxX(a1),-(sp)	; Get Bottom/Right position
		move.l	cr_MinX(a0),-(sp)	; Get Top/Left position
*
		move.l	a0,a4			; Save in a4
		move.l	a1,a5			; Save in a5
*
* Clear the cr__p1 (link of cliprects) and set cr__p2 as layer pointer
* Only the cr1 list will have the layer pointers...
*
		move.l	a2,cr__p2(a4)		; Set up layer pointer
		moveq.l	#0,d0			; Get a NULL
		move.l	d0,cr__p1(a4)		; Clear next pointer
		move.l	d0,cr__p1(a5)
*
* Now get the layer that is obscuring us; that is our starting point.
*
		move.l	cr_lobs(a4),a3		; This is where we start...
v_d_loop:	move.l	lr_back(a3),d0		; the second layer: set flags
		move.l	d0,a3			; Does not set flags...
		beq.s	v_d_done		; If NULL, we are done...
		cmp.l	a2,a3			; Check if are at "this" layer
		beq.s	v_d_loop		; If so, loop again...
*
* First check to see if we even come close to overlapping...
* If not, we can skip the cliprect search!  (Yeah!)
*
		move.l	sp,a0			; Get our new bounds
		lea	lr_MinX(a3),a1		; Get other layer's bounds
		bsr	_rectXrect		; Check of overlap
		tst.l	d0			; If NULL, no overlap
		beq.s	v_d_loop		; If no overlap, next layer...
*
* Now, we need to check to see if both cliprects are in this layer...
*
* Since we know at least one of them is in the layer, if either one
* is not, we know that we have to fail this dedice...
*
		lea	lr_ClipRect(a3),a0	; Get pointer to *cr
		lea	cr_MinX(a4),a1		; Point at bounds for cr
		bsr	search_next_cr		; Look for it
		tst.l	d0			; If not found, we need
		beq.s	v_d_false		; make sure the other isn't
*
* In this case, the first cliprect was found, so the other must be found
* and it must be after it in the list.  (One of the reasons why we sorted it)
* Also, we will link this cliprect into the cr1 list...
*
		move.l	d0,a0			; Get first result...
		move.l	cr__p1(a4),cr__p1(a0)	; Set up link...
		move.l	a0,cr__p1(a4)		; ...to matching cliprect
		move.l	a3,cr__p2(a0)		; Set pointer to layer...
*
		lea	cr_MinX(a5),a1		; Bounds of cr2
		bsr	search_next_cr		; Look for it
		tst.l	d0			; Check if we got it...
		beq.s	v_d_false		; If not, we exit false...
*
* Ok, we need to link this into the cr2 list...
*
		move.l	d0,a0			; Get cliprect into pointer...
		move.l	cr__p1(a5),cr__p1(a0)	; Set up link...
		move.l	a0,cr__p1(a5)		; ...to matching cliprect
		bra.s	v_d_loop		; Next layer...
*
v_d_false:	moveq.l	#0,d1			; We did not work...
v_d_exit:	move.l	a5,a1			; Get back cr2
		move.l	a4,a0			; Get back cr
		addq.l	#8,sp			; Adjust for our rectangle...
		movem.l	(sp)+,d0/a2/a3/a4/a5
		rts
v_d_done:	moveq.l	#1,d1			; We worked...
		bra.s	v_d_exit
*
*******************************************************************************
*
* dedice - This routine tries to do simple layer dedice
*
* The layers *MUST* be locked when this routine is called.
* The caller *MUST* have stripped the onscreen cliprects!!!
*
* called with	a0 = struct Layer_Info *
*
* returns	d0 = BOOLEAN - TRUE if something changed, FALSE if not...
*
* Ok, so the old optimize cliprects will now always call this routine...
* Dedice may end up calling rebuild sometimes...
*
_optimizeClipRects:	xdef	_optimizeClipRects
*
dedice:		move.l	li_top_layer(a0),d0	; Get top layer
		beq.s	end_dedice		; No layer, so exit!
		movem.l	a0/a2-a4/d2/d5-d7,-(sp)	; Save these
*
* Registers:	a4=top layer
*		a3=cliprect loop
*		a2=layer loop
*		d2=changed flag - set to TRUE if something changes...
*
*		d6=The "theory" cliprect count max...
*		d7=The cliprect count that will be made in the sort...
*
		move.l	d0,a4			; Get top_layer set up...
		moveq.l	#-1,d2			; Layer count var (temp)
		moveq.l	#1,d5			; Square count...
		moveq.l	#0,d6			; Zero the theory accum...
		moveq.l	#0,d7			; Zero cliprect count...
*
* Ok, sort the cliprects in all layers
*
pre_sort:	move.l	d0,a0			; Get ready for loop...
		bsr.s	sort_layer_cr		; a0 does not get trashed
*
* Ok, now we count the layer and add that to the theory of what
* the best case max cliprect count is...
*
* Now, the best case maximum cliprect count is:
*
* This means:  2*Sum(i*i) - n*n
*		where i=1 to n
*		and n is the number of layers
*
* To do this with minimum effort and performance loss, we compute the i*i
* by keeping a running square.  That is 1 (+3)=4 (+5)=9 (+7)=16 etc.
* This means that these three add instructions do the sum of squares...
*
* Now, in addition, since our top-most layer does not have cliprects,
* we will throw those away and thus start the square sums from 0 and
* go to (n-1).  (Thus the -1 and 1 in the d2/d5 combination to start)
*
		add.l	d2,d5			; Make the next square...
		addq.l	#2,d2			; Make the next square step...
		add.l	d5,d6			; Add in the square...
*
* Now go back for more cliprects...
*
		move.l	lr_back(a0),d0		; Get next layer...
		bne.s	pre_sort		; Sort the next one...
*
* Ok, so we now have sum(i*i)...  We now need to double it and
* subtract n*n...
* Now, n*n is in d5 so this is simple...
*
		add.l	d6,d6			; 2*sum(i*i)
		sub.l	d5,d6			; 2*sum(i*i)-(n*n)
*
* The real question here is how much extra should we give the theory max?
* Now, set d7 to the difference between the theory and the real...
*
		sub.l	d6,d7
		subq.l	#2,d7			; And two more... (buffer)
*
* Ok, so we sorted the layers and at the same time found out what the
* count is and what the max is.  We now do the dedice.  The unslice
* function returns the number of cliprects removed.  We use that to
* modify our total...
*
* Now set up d2 for the real work...
*
		moveq.l	#0,d2			; Nothing changed yet...
*
* Ok, now, go through each layer and look for dedicing...
*
		move.l	a4,a2
dedice_loop:	move.l	lr_back(a2),d0		; Get next layer
		beq.s	exit_dedice		; If NULL, we are done...
		move.l	d0,a2			; Set up in pointer...
dedice_cr:	lea	lr_ClipRect(a2),a3	; Get cliprects pointer
dedice_cr_loop:	move.l	(a3),d0			; Get next cliprect...
		beq.s	dedice_loop		; If done, next layer...
		move.l	d0,a3			; Put it into a3...
		move.l	a3,a0			; Also set up for call to:
		bsr	search_side_cr		; and get the cliprect...
		tst.l	d0			; Check if we got one...
		beq.s	dedice_cr_loop		; Do next cliprect...
		move.l	d0,a1			; Put it where I need it...
*
* Produce the bounds that are a combination of the two cliprects
*
		move.l	cr_MaxX(a1),-(sp)	; Get Bottom/Right position
		move.l	cr_MinX(a3),-(sp)	; Get Top/Left position
		move.l	sp,a0			; Point at new rectangle...
		bsr	_unslice		; Call the unslice routine!
		addq.l	#8,sp			; Free the rectangle...
		sub.l	d0,d7			; Subtract from total...
		tst.l	d0			; Check if we changed any...
		beq.s	dedice_cr_loop		; If not, we continue
		moveq.l	#1,d2			; Set changed flag...
		bra.s	dedice_cr		; Start layer over again...
*
* Now exit...  Set up the return result...
*
exit_dedice:	move.l	d2,d0			; Set return result...
*
* Ok, now check if we have too many cliprects...
*
		tst.l	d7			; Check d7
		movem.l	(sp)+,a0/a2-a4/d2/d5-d7	; Restore (no flags changed)
		bpl	_rebuildcliprects	; Do the rebuild if needed...
		; The bmi above uses tail recursion to simplify the code...
end_dedice:	rts
*
*******************************************************************************
*
* This is a fast routine to sort the cliprect list stored in the layer.
* The list is sorted with the MinX/Y value as the key.  Thus they will
* be sorted from top left of the screen to bottom right.
*
*  *** NOTE *** This routine also counts the cliprects.
*               It does this in d7.  It does *NOT* clear d7
*               It just adds 1 to d7 for each cliprect...
*
* sort_layer_cr	- a0=layer	(does not trash a0!!!)
*
sort_layer_cr:	movem.l	a2/a3,-(sp)	; We will need to save these
		sub.l	a1,a1		; Clear new CR list...
		move.l	a1,-(sp)	; And make storage for it...
		move.l	lr_ClipRect(a0),d0	; Get first CR
		beq.s	sort_cr_done	; If NULL, we have none...
		move.l	sp,a2		; Get start of list...
		move.l	d0,a1		; Get pointer...
*
* The first element always goes in with no proble...
*
* We insert the cr (a1) after the this cr (a2) and loop for more...
*
insert_cr:	move.l	(a1),d0		; Get old next pointer...
		move.l	(a2),(a1)	; Set up new next pointer...
		move.l	a1,(a2)		; Add him to the list...
		addq.l	#1,d7		; Count the cliprect...
		tst.l	d0		; Check if we have more
		beq.s	sort_cr_done	; If not, end the sort...
*
* The sort loop...
*
sort_cr_loop:	move.l	d0,a1		; Get pointer ready...
		move.l	cr_MinX(a1),d1	; Get MinX/MinY values...
*
* Ok, a2 is pointing to the last place we inserted, so
* check there first...
*
		move.l	(a2),a2		; Get ClipRect... (We know it is here)
		cmp.l	cr_MinX(a2),d1	; Check if we are past the point...
		bgt.s	insert_cr_loop	; If not, we look from here...
*
* We were already past the normal spot so lets start looking from
* the top...
*
		move.l	sp,a2		; Point at new list header...
insert_cr_loop:	move.l	(a2),d0		; Get next pointer...
		beq.s	insert_cr	; Check for end of list...
		move.l	d0,a3		; Ok, we need to check this guy out...
		cmp.l	cr_MinX(a3),d1	; Check it out...
		blt.s	insert_cr	; If less than next, insert it...
		move.l	a3,a2		; Set up the pointer...
		bra.s	insert_cr_loop	; and go again...
*
* We are done so save the new list into the layer...
*
sort_cr_done:	move.l	(sp)+,lr_ClipRect(a0)	; Save the cliprect list
		movem.l	(sp)+,a2/a3	; Restore
		rts
*
*******************************************************************************
*
* This is a replacement for the obscured() function
*
*	a0,a1	rectangles...
*
_obscured:	xdef	_obscured
obscured:	moveq.l	#0,d0		; Set default return value...
		move.w	(a0)+,d1	; Get first value...
		cmp.w	(a1)+,d1	; Check it...
		bgt.s	obscured_done	; If > we fail...
		move.w	(a0)+,d1	; Get Y
		cmp.w	(a1)+,d1	; and check it
		bgt.s	obscured_done	; If > we fail...
		move.w	(a0)+,d1	; Get X (max)
		cmp.w	(a1)+,d1	; and check it
		blt.s	obscured_done	; If < we fail...
		move.w	(a0),d1		; Get Y (max)
		cmp.w	(a1),d1		; Check it...
		blt.s	obscured_done	; If < we fail...
*
		moveq.l	#1,d0		; We did not fail, return TRUE
obscured_done:	rts
*
*******************************************************************************
*
* This is a faster version of LinkCR since the compiler does such a
* bad job of it...
*
*	a0=layer
*	a1=cliprect
*
_linkcr:	xdef	_linkcr
linkcr:		lea	lr_ClipRect(a0),a0	; Point at cliprect list
		move.l	(a0),(a1)		; Set up next pointer
		move.l	a1,(a0)			; Link in new cliprect
		rts
*
*******************************************************************************
*
* This routine is a replacement for the C version...
* (Smaller/faster)
*
* One enhancement was to add a check for if we should do a waitblit()
* first.  This means that we will not waitblit until we get to a cliprect
* that needs it...  (This made layers about 12% faster!)
*
*	a0=cliprect
*
_Freecrlist:	xdef	_Freecrlist
Freecrlist:	movem.l	a2/d2,-(sp)	; Save this...
		moveq.l	#0,d2		; Clear WaitBlit() flag...
		move.l	a0,a2		; We need to do this...
freecr_loop:	move.l	a2,d0		; Get cr
		beq.s	freecr_done	; If NULL, we exit...
		move.l	d0,a0		; Get current one into a0...
		move.l	(a2),a2		; Get next one...
*
		tst.l	cr_lobs(a0)	; Check if we need to free some
		beq.s	freecr_nowait	; rasters before we go and do a
		tst.l	cr_BitMap(a0)	; waitblit()...
		beq.s	freecr_nowait
*
* We are about to free some rasters, check if we
* had done a waitblit yet...
*
		tst.l	d2		; Check if we did waitblit yet
		bne.s	freecr_skip	; If so, we skip...
		move.l	a6,d2		; We can save a6 in d2
		move.l	lb_GfxBase(a6),a6	; Get GfxBase
		jsr	_LVOWaitBlit(a6)	; Call it...
		move.l	d2,a6		; Restore a6...
freecr_skip:	move.l	a0,d2		; Save the cliprect (and set flag)
		bsr	_free_concealed_rasters
		move.l	d2,a0		; Get cliprect back
*
* Now use the code from below to free the cliprect itself
*
freecr_nowait:	bsr.s	freecr_nolobs	; Free the cliprect part
		bra.s	freecr_loop	; Do some more
freecr_done:	movem.l	(sp)+,a2/d2	; Restore
		rts
*
*******************************************************************************
*
* This routine frees the cliprect in a0...
*
_Freecr:	xdef	_Freecr
Freecr:		tst.l	cr_lobs(a0)	; Check for obscured bit...
		beq.s	freecr_nolobs	; If none, skip the free rasters
		tst.l	cr_BitMap(a0)	; Check for bitmap...
		beq.s	freecr_nolobs	; If none, skip the free rasters
		move.l	a0,-(sp)	; Save a0...
		bsr	_free_concealed_rasters
		move.l	(sp)+,a0	; Restore a0...
*
freecr_nolobs:	move.l	a0,a1		; Get a1 set up
		moveq.l	#cr_SIZEOF,d0	; Get size...
		move.l	a6,-(sp)	; Save a6
		move.l	lb_ExecBase(a6),a6	; Get ExecBase
		jsr	_LVOFreeMem(a6)	; Free the cliprect
		move.l	(sp)+,a6	; Restore...
		rts
*
*******************************************************************************
*
* This is the replacement UnLinkLayer routine...
*
*	a0=layer
*
_unlinklayer:	xdef	_unlinklayer
unlinklayer:	move.l	lr_LayerInfo(a0),a1	; Get the LayerInfo...
		move.l	li_top_layer(a1),d0	; Get TopLayer
		beq.s	unlink_rts		; If NULL, we exit...
		move.l	lr_back(a0),d1		; Get back layer...
		beq.s	unlink_noback		; If none, skip...
*
		exg	d1,a1			; Give me an address reg
		move.l	lr_front(a0),lr_front(a1)	; Store pointer...
		exg	d1,a1			; return a1 to normal...
*
unlink_noback:	cmp.l	d0,a0			; Check if we are top...
		bne.s	unlink_nottop		; If not top...
		move.l	lr_back(a0),li_top_layer(a1)	; Store new top...
		bra.s	unlink_rts		; and we are done...
*
unlink_nottop:	move.l	lr_front(a0),a1		; get front layer
		move.l	lr_back(a0),lr_back(a1)	; Store pointer...
unlink_rts:	rts
*
*******************************************************************************
*
* This routine will insert a layer into the list at the right spot...
*
*	a0=layer in back of...
*	a1=new layer to be in front of a0...
*
_insertlayer:	xdef	_insertlayer
insertlayer:	move.l	a0,d0		; Check if layer is NULL...
		bne.s	ilayer_real	; We have a real one...
*
* We need to find the layer that is above the back...
*
		move.l	lr_LayerInfo(a1),a0	; Get layerinfo
		move.l	li_top_layer(a0),a0	; Get top layer
		move.l	a0,d0			; Check if a real layer
		beq.s	ilayer_noreal		; Empty layer list...
ilayer_find:
		move.l	d0,a0			; Move next layer into a0
		move.l	lr_back(a0),d0		; Get next layer...
		bne.s	ilayer_find		; If last one, we found it
		exg	d0,a0			; Swap d0/a0
		bra.s	ilayer_noreal		; Here we go!!!
*
ilayer_real:	move.l	lr_front(a0),d0		; Get layer above
		move.l	a1,lr_front(a0)		; Store old layer back...
ilayer_noreal:	move.l	a0,lr_back(a1)		; store back pointer...
		move.l	d0,lr_front(a1)		; Now the front pointer...
		move.l	d0,a0			; Put "upper" layer into a0
		tst.l	d0			; Do we have one?
		beq.s	ilayer_top		; If not, we are topmost
		move.l	a1,lr_back(a0)		; Store the back pointer
		rts
ilayer_top:	move.l	lr_LayerInfo(a1),a0	; Get layerinfo
		move.l	a1,li_top_layer(a0)	; Store pointer...
		rts
*
*******************************************************************************
*
* This routine will search the layers starting at the given layer
* for cliprects that match the given one and links it to the list...
*
* a0=start layer
* a1=clip rect to match...
* a2=layer to skip...
*
_vlink_cr:	xdef	_vlink_cr
vlink_cr:	movem.l	a3/a4/a5,-(sp)	; We need some working room...
		move.l	a0,a4		; Move starting layer over...
		move.l	a1,a3		; Move cliprect over...
		lea	cr_MinX(a3),a5	; Point at bounds...
*
vlink_loop:	move.l	lr_back(a4),d0	; Get next layer
		beq.s	vlink_done	; If no more, we are done...
		move.l	d0,a4		; Put it into a4...
		cmp.l	a4,a2		; Check if skip layer...
		beq.s	vlink_loop	; If so, skip and do next one...
		move.l	a5,a1		; Get cliprect bounds
		lea	lr_MinX(a4),a0	; Get layer bounds
		bsr	_rectXrect	; Check if we hit...
		tst.l	d0		; If not, we skip
		beq.s	vlink_loop	; ... this layer
*
* We do our own search_for_cr here such that we can link the cliprects
* via prev and we *KNOW* we will find a matching one...
*
		lea	lr_ClipRect(a4),a0	; Get cliprect pointer...
		movem.l	(a1),d1/a1	; get xmin,ymin,xmax,ymax
vlink_look:	move.l	(a0),a0		; Get next cliprect...
		cmp.l	cr_MinX(a0),d1	; A match?
		bne.s	vlink_look	; check some more...
		cmp.l	cr_MaxX(a0),a1	; A match?
		bne.s	vlink_look	; Look some more...
*
* Ok, we found the cliprect in a0
*
		move.l	a0,cr__p1(a3)	; Store result... (We know it is good)
		move.l	a0,a3		; Get new cliprect into a3
		move.l	a4,cr__p2(a3)	; Flag cliprect as linked...
		moveq.l	#0,d0		; Get a NULL
		move.l	d0,cr__p1(a3)	; Clear the link...
		bra.s	vlink_loop	; Go and do more...
*
vlink_done:	movem.l	(sp)+,a3/a4/a5	; Restore
		rts
*
*****i* layers.library/SortLayerCR ********************************************
*
*   NAME
*	SortLayerCR - Sort the layer's cliprects for scroll raster (V39)
*
*   SYNOPSIS
*	SortLayerCR(layer,dx,dy)
*	            A0    D0 D1
*
*	VOID SortLayerCR(struct Layer *,WORD,WORD);
*
*   FUNCTION
*	This function will sort the give layer's cliprects such that a
*	scroll in the direction given will be optimal.
*
*   NOTE
*	This routine is for Layers/Graphics internal use only.
*	The layer must be locked before calling this routine.
*
*   INPUTS
*	layer	- The layer to be sorted...
*	dx	- x scroll offset
*	dy	- y scroll offset
*
*   SEE ALSO
*
*******************************************************************************
*
SortLayerCR:	xdef	SortLayerCR
		movem.l	a2/a3/a4,-(sp)	; Save these for later...
		clr.l	-(sp)		; Clear a list top on the stack...
*
* The routines are:	s_up		Sort for scroll up
*			s_down		Sort for scroll down
*			s_left		Sort for scroll left
*			s_right		Sort for scroll right
*			s_up_left	Sort for scroll up-left
*			s_up_right	Sort for scroll up-right
*			s_down_left	Sort for scroll down-left
*			s_down_right	Sort for scroll down-right
*
* Ok, for the simple cases, we just do the simple sort...
* (That means dy==0 or dx==0)
*
* Since these are most common, we check for them first...
*
		tst.w	d1		; Check for dy
		bne.s	dy_non_null	; If dy is not NULL...
		lea	s_left(pc),a4	; Get left sort...
		tst.w	d0		; Check dx...
		bpl.s	StartSort	; Ok, so we do a simple one
		lea	s_right(pc),a4	; Get the right sort...
		bra.s	StartSort	; Do the sort...
*
* Ok, so we have dy, lets check dx...
*
dy_non_null:	tst.w	d0		; Check the dx
		bne.s	hard_sort	; If dx & dy are not null, hard sort
dy_sort:	lea	s_up(pc),a4	; Get up sort...
		tst.w	d1		; Check the type of dy...
		bpl.s	StartSort	; Start the sort
		lea	s_down(pc),a4	; Sort down...
		bra.s	StartSort	; Do the sort...
*
*
* Ok, we have a hard one.  This will take a while anyway, so...
*
hard_sort:	rol.w	#1,d0		; Get negative bit into bit 1
		and.w	#1,d0		; Mask all but it...
		swap	d0		; Move d0 word into top word
		move.w	d1,d0		; Get other word...
		rol.l	#1,d0		; Move negative bit into high word
		swap 	d0		; Get high word back down...
		add.w	d0,d0		; *2
		add.w	d0,d0		; *4
		move.l	sortTab(pc,d0.w),a4	; Get function pointer
*
* We will need the cliprect sorted in dy first, so, we will make dx=0
* and call ourselves
*
		moveq.l	#0,d0		; Clear dx
		bsr.s	SortLayerCR	; Sort just in dy...
		bra.s	StartSort	; Do the sort
*
*****
*
* This is a little cheat:
* We take the sign bit from X and Y and produce an offset into this
* table to find the function needed...
*
sortTab:	dc.l	s_up_left	; (0,0) = Positive X, Positive Y
		dc.l	s_down_left	; (0,1) = Positive X, Negative Y
		dc.l	s_up_right	; (1,0) = Negative X, Positive Y
		dc.l	s_down_right	; (1,1) = Negative X, Negative Y
*
*****
*
* These are the simple sort test routines  They split up to keep
* the branches short...
*
* Inputs:	a1 = Cliprect to be inserted
*		a3 = Cliprect on list to be checked against
*		d0/d1 = Scrap - free for use in routine
*
* Result:	BGT if cliprect could be after this one...
*		BLT if cliprect MUST be before this one...
*
s_up:		; We are scrolling up, so top edge only...
		move.w	cr_MinY(a1),d1	; Get new CR top edget
		cmp.w	cr_MinY(a3),d1	; Check it...
		bra.s LayerIns_Cont	; Continue the search
*
s_down:		; We are scrolling down, so bottom edge only...
		move.w	cr_MaxY(a3),d1	; Get list CR
		cmp.w	cr_MaxY(a1),d1	; Check it...
		bra.s LayerIns_Cont	; Continue the search
*
s_left:		; We are scrolling left, so left edge only...
		move.w	cr_MinX(a1),d1	; Get new CR
		cmp.w	cr_MinX(a3),d1	; Check it...
		bra.s LayerIns_Cont	; Continue the search
*
s_right:	; We are scrolling right, so right edget only...
		move.w	cr_MaxX(a3),d1	; Get list CR
		cmp.w	cr_MaxX(a1),d1	; Check it...
		bra.s LayerIns_Cont	; Continue the search
*
****
*
* Here is the main sort routine.
* We enter here with:		a4 = Pointer to test routine
*				sp = Pointer to new list
*				a0 = layer (Do *NOT* trash!)
*				a1/a2/a3/d0/d1 = scrap
*
StartSort:	move.l	lr_ClipRect(a0),d0	; Get first CR
		beq.s	SortLayer_Done		; No cliprects? Exit...
*
* The first cliprect always goes into the list easy...
*
		move.l	sp,a2		; Get cliprect list
		move.l	d0,a1		; Get cliprect
*
* Insert the cliprect (a1) into the list after cliprect (a2)...
*
Insert_Clip:	move.l	(a1),d0		; Get old next pointer...
		move.l	(a2),(a1)	; Set up new next pointer...
		move.l	a1,(a2)		; Add new CR to list
		tst.l	d0		; Check for more cliprects
		beq.s	SortLayer_Done	; If none, cleanup and exit...
		move.l	d0,a1		; Get current cliprect
*
* Ok, this is the main sort loop.
*
		move.l	sp,a2		; Start at the top of the new list
*
* Ok, now find a good spot...
*
LayerIns_Loop:	move.l	(a2),d0		; Get next cliprect...
		beq.s	Insert_Clip	; If NULL, we insert at end...
		move.l	d0,a3		; Get pointer to next clip...
		jmp	(a4)		; Do the test...
*
LayerIns_Cont:	ble.s	Insert_Clip	; If right spot, insert it...
LayerIns_GT:	move.l	a3,a2		; Move to next cliprect
		bra.s	LayerIns_Loop	; And loop back for more...
*
* Clean up and exit
*
SortLayer_Done:	move.l	(sp)+,lr_ClipRect(a0)	; Set up new list
		movem.l	(sp)+,a2/a3/a4		; Restore
		rts
*
****
*
* Ok, here are the test routines for the hard sorts
*
* Inputs:	a1 = Cliprect to be inserted
*		a3 = Cliprect on list to be checked against
*		d0/d1 = Scrap - free for use in routine
*
* Result:	BGT if cliprect could be after this one...
*		BLT if cliprect MUST be before this one...
*
s_up_left:	; We are scrolling up and left, so a bit more complex...
		move.w	cr_MinY(a1),d1	; Get new CR minY
		cmp.w	cr_MaxY(a3),d1	; Are we below this one?
		bgt.s	LayerIns_GT	; If so, we are after him
		move.w	cr_MinX(a1),d1	; Get our MinX
		cmp.w	cr_MaxX(a3),d1	; Check against list MaxX
		bra.s LayerIns_Cont	; Continue the search
*
s_down_left:	; We are scrolling down and left, so a bit more complex...
		move.w	cr_MinY(a3),d1	; Get list CR minY
		cmp.w	cr_MaxY(a1),d1	; Check; are we above him?
		bgt.s	LayerIns_GT	; If so, we are after him
		move.w	cr_MinX(a1),d1	; Get our MinX
		cmp.w	cr_MaxX(a3),d1	; Check against list MaxX
		bra.s	LayerIns_Cont	; Continue the search
*
s_up_right:	; We are scrolling up and right, so a bit more complex...
		move.w	cr_MinY(a1),d1	; Get new CR minY
		cmp.w	cr_MaxY(a3),d1	; Are we below this one?
		bgt.s	LayerIns_GT	; If so, we are after him
		move.w	cr_MinX(a3),d1	; Get list CR minX
		cmp.w	cr_MaxX(a1),d1	; Check if we are past list CR
		bra.s	LayerIns_Cont	; Continue the search
*
s_down_right:	; We are scrolling down and right, so a bit more complex...
		move.w	cr_MinY(a3),d1	; Get list CR minY
		cmp.w	cr_MaxY(a1),d1	; Check; are we above him?
		bgt.s	LayerIns_GT	; If so, we are after him
		move.w	cr_MinX(a3),d1	; Get list CR minX
		cmp.w	cr_MaxX(a1),d1	; Check if we are past list CR
		bra.s	LayerIns_Cont	; Continue the search
*
*******************************************************************************
*
		end
@


38.22
log
@Fixed the UP-Left and Down-Left SortLayerCR tests.
They had a line that was for the RIGHT direction...
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.21 91/11/07 14:57:26 mks Exp Locker: mks $
d26 1
d257 5
a261 1
_dedice:	xdef	_dedice
d264 1
a264 1
		movem.l	a2/a3/a4/d2,-(sp)	; Save these
d271 3
d275 4
a278 1
		moveq.l	#0,d2			; Nothing changed yet...
d284 24
d311 22
d356 2
a357 1
		tst.l	d0			; Check if we changed...
d365 7
a371 1
		movem.l	(sp)+,a2/a3/a4/d2	; Restore...
d380 4
a385 1
_sort_layer_cr:	xdef	_sort_layer_cr
d401 1
@


38.21
log
@Updated to fix the old sort cliprect problem.  SortLayerCR
now does a special Y-sort before doing the diagonal sort
in order to prevent invalid conditions in diagonal sorts.
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.20 91/11/04 18:44:41 mks Exp Locker: mks $
d771 2
a772 2
		move.w	cr_MaxX(a3),d1	; Get list CR maxX
		cmp.w	cr_MinX(a1),d1	; Are we right of this one?
d779 2
a780 2
		move.w	cr_MaxX(a3),d1	; Get list CR maxX
		cmp.w	cr_MinX(a1),d1	; Are we right of this one?
@


38.20
log
@Changed some comments
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.19 91/11/01 19:55:21 mks Exp Locker: mks $
a366 201
*****i* layers.library/SortLayerCR ********************************************
*
*   NAME
*	SortLayerCR - Sort the layer's cliprects for scroll raster (V39)
*
*   SYNOPSIS
*	SortLayerCR(layer,dx,dy)
*	            A0    D0 D1
*
*	VOID SortLayerCR(struct Layer *,WORD,WORD);
*
*   FUNCTION
*	This function will sort the give layer's cliprects such that a
*	scroll in the direction given will be optimal.
*
*   NOTE
*	This routine is for Layers/Graphics internal use only.
*	The layer must be locked before calling this routine.
*
*   INPUTS
*	layer	- The layer to be sorted...
*	dx	- x scroll offset
*	dy	- y scroll offset
*
*   SEE ALSO
*
*******************************************************************************
*
SortLayerCR:	xdef	SortLayerCR
		movem.l	a2/a3/a4,-(sp)	; Save these for later...
		clr.l	-(sp)		; Clear a list top on the stack...
*
* Now pick the compare routine that is needed and put the address
* into a4...
*
* The routines are:	s_up		Sort for scroll up
*			s_down		Sort for scroll down
*			s_left		Sort for scroll left
*			s_right		Sort for scroll right
*			s_up_left	Sort for scroll up-left
*			s_up_right	Sort for scroll up-right
*			s_down_left	Sort for scroll down-left
*			s_down_right	Sort for scroll down-right
*
		tst.w	d0		; Check dx
		bne.s	dx_non_null	; Not null?
*
* Ok, no dx, so check dy...
*
		lea	s_up(pc),a4	; Point at up code...
		tst.w	d1		; Check what dy is...
		beq.s	SortLayer_None	; If NULL too, we exit...
		bpl.s	StartSort	; If plus, we go up...
		lea	s_down(pc),a4	; Point at down code
		bra.s	StartSort
*
* dx is not NULL, so check dy...
*
dx_non_null:	tst.w	d1		; Check what dy is...
		bne.s	dy_non_null	; Not null?
*
* Ok, so dy is NULL, we need to check dx again...
*
		lea	s_left(pc),a4	; Point at left code...
		tst.w	d0		; Check what dx is...
		bpl.s	StartSort	; If plus, we go left
		lea	s_right(pc),a4	; Point at right code
		bra.s	StartSort
*
* Ok, so dx and dy are non-null...
*
dy_non_null:	bpl.s	dy_plus		; dy is positive?
		lea	s_down_left(pc),a4
		tst.w	d0		; Check dx...
		bpl.s	StartSort	; plus? we go down-left
		lea	s_down_right(pc),a4
		bra.s	StartSort	; negative goes down-right
*
* dy is positive, so now check dx...
*
dy_plus:	lea	s_up_left(pc),a4
		tst.w	d0		; Check dx...
		bpl.s	StartSort	; plus? we go up-left
		lea	s_up_right(pc),a4
;		bra.s	StartSort	; negative goes up-right
*
* Here is the main sort routine.
* We enter here with:		a4 = Pointer to test routine
*				sp = Pointer to new list
*				a0 = layer (Do *NOT* trash!)
*				a1/a2/a3/d0/d1 = scrap
*
StartSort:	move.l	lr_ClipRect(a0),d0	; Get first CR
		beq.s	SortLayer_Done		; No cliprects? Exit...
*
* The first cliprect always goes into the list easy...
*
		move.l	sp,a2			; Get cliprect list
		move.l	d0,a1			; Get cliprect
*
* Insert the cliprect (a1) into the list after cliprect (a2)...
*
Insert_Clip:	move.l	(a1),d0		; Get old next pointer...
		move.l	(a2),(a1)	; Set up new next pointer...
		move.l	a1,(a2)		; Add new CR to list
		tst.l	d0		; Check for more cliprects
		beq.s	SortLayer_Done	; If none, cleanup and exit...
*
* Ok, this is the main sort loop.  We first check to see if the next
* ClipRect will fit where we are now...
*
SortLayer_Loop:	move.l	d0,a1		; Get current cliprect
		move.l	(a2),a3		; Get next CR (We know it is here)
		jsr	(a4)		; Do the compare function (a1/a3)
		bge.s	LayerIns_Loop	; We set the bits as needed...
*
* Well, we can not start at the current spot so start at the top...
*
		move.l	sp,a2		; Start at the top of the new list
*
* Ok, now find a good spot...
*
LayerIns_Loop:	move.l	(a2),d0		; Get next cliprect...
		beq.s	Insert_Clip	; If NULL, we insert at end...
		move.l	d0,a3		; Get pointer to next clip...
		jsr	(a4)		; Do the test...
		ble.s	Insert_Clip	; If right spot, insert it...
		move.l	a3,a2		; Move to next cliprect
		bra.s	LayerIns_Loop	; And loop back for more...
*
*
* Clean up and exit
*
SortLayer_None:	move.l	lr_ClipRect(a0),(sp)	; Put current list on stack
SortLayer_Done:	move.l	(sp)+,lr_ClipRect(a0)	; Set up new list
		movem.l	(sp)+,a2/a3/a4		; Restore
		rts
*
****
*
* Ok, here are the test routines for the sort above
*
* Inputs:	a1 = Cliprect to be inserted
*		a3 = Cliprect on list to be checked against
*		d0/d1 = Scrap - free for use in routine
*
* Result:	BGT if cliprect should be after this one...
*		BLT if cliprect should be before this one...
*
s_up:		; We are scrolling up, so top edges only matter
		move.w	cr_MinY(a1),d1	; Get new CR top edget
		sub.w	cr_MinY(a3),d1	; Check it...
		rts
*
s_down:		; We are scrolling down, so bottom edge only...
		move.w	cr_MaxY(a3),d1	; Get list CR
		sub.w	cr_MaxY(a1),d1	; Check it...
		rts
*
s_left:		; We are scrolling left, so left edge only...
		move.w	cr_MinX(a1),d1	; Get new CR
		sub.w	cr_MinX(a3),d1	; Check it...
		rts
*
s_right:	; We are scrolling right, so right edget only...
		move.w	cr_MaxX(a3),d1	; Get list CR
		sub.w	cr_MaxX(a1),d1	; Check it...
		rts
*
s_up_right:	; We are scrolling up and right, so a bit more complex...
		move.w	cr_MinY(a1),d1	; Get new CR minY
		sub.w	cr_MaxY(a3),d1	; Are we below this one?
		bgt.s	s_u_r_rts	; If so, we are after him
		move.w	cr_MinX(a3),d1	; Get list CR minX
		sub.w	cr_MaxX(a1),d1	; Check if we are past list CR
s_u_r_rts:	rts
*
s_up_left:	; We are scrolling up and left, so a bit more complex...
		move.w	cr_MinY(a1),d1	; Get new CR minY
		sub.w	cr_MaxY(a3),d1	; Are we below this one?
		bgt.s	s_u_l_rts	; If so, we are after him
		move.w	cr_MaxX(a3),d1	; Get list CR maxX
		sub.w	cr_MinX(a1),d1	; Are we right of this one?
s_u_l_rts:	rts
*
s_down_right:	; We are scrolling down and right, so a bit more complex...
		move.w	cr_MinY(a3),d1	; Get list CR minY
		cmp.w	cr_MaxY(a1),d1	; Check; are we above him?
		bgt.s	s_d_r_rts	; If so, we exit with BGT set
		move.w	cr_MinX(a3),d1	; Get list CR minX
		sub.w	cr_MaxX(a1),d1	; Check if we are past list CR
s_d_r_rts:	rts
*
s_down_left:	; We are scrolling down and left, so a bit more complex...
		move.w	cr_MinY(a3),d1	; Get list CR minY
		cmp.w	cr_MaxY(a1),d1	; Check; are we above him?
		bgt.s	s_d_l_rts	; If so, we exit with BGT set
		move.w	cr_MaxX(a3),d1	; Get list CR maxX
		sub.w	cr_MinX(a1),d1	; Are we right of this one?
s_d_l_rts:	rts
*
d582 216
@


38.19
log
@Added the code to do the SortLayerCR routine for graphics.
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.18 91/10/29 13:05:03 mks Exp Locker: mks $
d399 1
a399 1
* Now pick the compair routine that is needed and put the address
d480 1
a480 1
		jsr	(a4)		; Do the compair function (a1/a3)
@


38.18
log
@Reworked dedice to build a temp list of the cliprects that
will be dediced...  Much faster now.
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.17 91/10/28 09:19:31 mks Exp Locker: mks $
a8 1
* (If all of layersubs.c goes into here, then it will...)
d366 201
@


38.17
log
@Updated VLink to be able to skip a layer and to not deal with prev
pointers...
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.16 91/10/25 17:09:43 mks Exp Locker: mks $
d156 3
a158 1
* be dediced based on the cliprect stacks...
d179 8
d190 2
a191 2
v_d_loop:	move.l	lr_back(a3),d0		; the second layer.
		move.l	d0,a3			; Does not get flags...
d218 1
d221 4
d228 3
a230 1
		bne.s	v_d_loop		; If so, we check next layer
d232 5
d292 6
d299 1
a582 25
*
*******************************************************************************
*
* This routine is for outside use to insert a single cliprect into
* a layer in sorted order...
*
*	a0=layer
*	a1=cliprect
*
; Not used yet...
;_sortlinkcr:	xdef	_sortlinkcr
;sortlinkcr:	move.l	a2,-(sp)	; Save this one.  (we need it)
;		lea	lr_ClipRect(a0),a0	; Get pointer to list...
;		move.l	cr_MinX(a1),d1	; Get the cliprect X/Y pos...
;sortlink_loop:	move.l	(a0),d0		; Get next cliprect...
;		beq.s	sortlink_done	; If none, we are at end of list
;		move.l	d0,a2		; Well, we should check this one...
;		cmp.l	cr_MinX(a2),d1	; Check vs the next one...
;		blt.s	sortlink_done	; If time to insert...
;		move.l	a2,a0		; Get ready to loop...
;		bra.s	sortlink_loop	; And check the next one...
;sortlink_done:	move.l	(a0),(a1)	; Get up next pointer...
;		move.l	a1,(a0)		; Link it in...
;		move.l	(sp)+,a2	; Restore a2
;		rts
@


38.16
log
@Reworked many routines to better fit the new tomiddle code...
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.15 91/10/25 00:28:33 mks Exp Locker: mks $
d513 1
d516 1
a516 1
vlink_cr:	movem.l	a2/a3/a4,-(sp)	; We need some working room...
d519 1
a519 1
		lea	cr_MinX(a3),a2	; Point at bounds...
d524 3
a526 1
		move.l	a2,a1		; Get cliprect bounds
d537 1
a537 2
vlink_look:	move.l	(a0),d0		; Get next cliprect...
		exg	d0,a0		; and store it in a0 and old in d0...
d543 1
a543 1
* Ok, we found the cliprect in a0 and the previous cliprect pointer in d0
a544 1
		move.l	d0,cr_prev(a0)	; Store previous pointer...
d547 1
a547 1
		move.l	a4,cr__p2(a3)	; Store layer in cliprect...
d552 1
a552 1
vlink_done:	movem.l	(sp)+,a2/a3/a4	; Restore
@


38.15
log
@Major change for new tomiddle routine...
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.14 91/10/24 13:49:42 mks Exp Locker: mks $
a29 65
* This routine sets the layer priorities and clears the _p2 field
* of all of the cliprects...
*
*	a0=first layer
*
_set_pri:	xdef	_set_pri
set_pri:	movem.l	d2,-(sp)	; We will use d2 for NULL
		moveq.l	#0,d2		; To be used to clear cr__p2
		moveq.l	#1,d0		; The starting priority
		move.l	a0,d1		; Get first layer into d1
		beq.s	set_pri_done	; If none, exit
set_pri_loop:	move.l	d1,a0		; Get the layer into a0
		move.w	d0,lr_priority(a0)	; Store priority
		addq.w	#1,d0			; Count up one...
		move.l	lr_ClipRect(a0),d1	; Get first cliprect
		beq.s	set_pri_next		; If no cliprect, end...
*
set_pri_crloop:	move.l	d1,a1		; Get it back into a1...
		move.l	d2,cr__p2(a1)	; Clear p2
		move.l	(a1),d1		; Get next cliprect...
		bne.s	set_pri_crloop	; Go and do more if there is some...
*
set_pri_next:	move.l	lr_back(a0),d1	; Get next layer...
		bne.s	set_pri_loop	; Loop for more...
set_pri_done:	move.l	(sp)+,d2	; Restore
		rts
*
*******************************************************************************
*
* This routine will search the layers starting at the given layer
* for cliprects that match the given one and links it to the list...
*
* a0=start layer
* a1=clip rect to match...
*
_vlink_cr:	xdef	_vlink_cr
vlink_cr:	movem.l	a2/a3/a4,-(sp)	; We need some working room...
		move.l	a0,a4		; Move starting layer over...
		move.l	a1,a3		; Move cliprect over...
		lea	cr_MinX(a3),a2	; Point at bounds...
*
vlink_loop:	move.l	lr_back(a4),d0	; Get next layer
		beq.s	vlink_done	; If no more, we are done...
		move.l	d0,a4		; Put it into a4...
		move.l	a2,a1		; Get cliprect bounds
		lea	lr_MinX(a4),a0	; Get layer bounds
		bsr	_rectXrect	; Check if we hit...
		tst.l	d0		; If not, we skip
		beq.s	vlink_loop	; ... this layer
*
		move.l	a4,a0		; Get layer pointer...
		bsr.s	search_for_cr	; Look for the cliprect match
*
		move.l	d0,cr__p1(a3)	; Store result... (We know it is good)
		move.l	d0,a3		; Get new cliprect into a3
		move.l	a4,cr__p2(a3)	; Store layer in cliprect...
		moveq.l	#0,d0		; Get a NULL
		move.l	d0,cr__p1(a3)	; Clear the link...
		bra.s	vlink_loop	; Go and do more...
*
vlink_done:	movem.l	(sp)+,a2/a3/a4	; Restore
		rts
*
*******************************************************************************
*
a340 14
* This is a faster version of LinkCR since the compiler does such a
* bad job of it...
*
*	a0=layer
*	a1=cliprect
*
_linkcr:	xdef	_linkcr
linkcr:		lea	lr_ClipRect(a0),a0	; Point at cliprect list
		move.l	(a0),(a1)		; Set up next pointer
		move.l	a1,(a0)			; Link in new cliprect
		rts
*
*******************************************************************************
*
a341 1
* (Smaller/faster/etc)
d365 2
a366 1
* This is the replacement UnLinkLayer routine...
d369 1
d371 5
a375 19
_unlinklayer:	xdef	_unlinklayer
unlinklayer:	move.l	lr_LayerInfo(a0),a1	; Get the LayerInfo...
		move.l	li_top_layer(a1),d0	; Get TopLayer
		beq.s	unlink_rts		; If NULL, we exit...
		move.l	lr_back(a0),d1		; Get back layer...
		beq.s	unlink_noback		; If none, skip...
*
		exg	d1,a1			; Give me an address reg
		move.l	lr_front(a0),lr_front(a1)	; Store pointer...
		exg	d1,a1			; return a1 to normal...
*
unlink_noback:	cmp.l	d0,a0			; Check if we are top...
		bne.s	unlink_nottop		; If not top...
		move.l	lr_back(a0),li_top_layer(a1)	; Store new top...
		bra.s	unlink_rts		; and we are done...
*
unlink_nottop:	move.l	lr_front(a0),a1		; get front layer
		move.l	lr_back(a0),lr_back(a1)	; Store pointer...
unlink_rts:	rts
d445 86
a530 1
* This routine was gone, now it is back...
d532 20
a551 14
* This routine removes a cliprect from a layer...
* This routine will crash if the cliprect is not
* in the list!!!
*
*	a0=layer	a1=cliprect
*
_unlinkcr:	xdef	_unlinkcr
unlinkcr:	lea	lr_ClipRect(a0),a0	; Point at cliprect list
		move.l	a0,d0			; Set up for loop...
unlinkcr_loop:	move.l	d0,a0			; Get pointer into a0...
		move.l	(a0),d0			; Get next pointer...
		cmp.l	d0,a1			; is it ours?
		bne.s	unlinkcr_loop		; if not, loop...
		move.l	(a1),(a0)		; Unlink it...
d564 14
a577 14
sortlinkcr:	move.l	a2,-(sp)	; Save this one.  (we need it)
		lea	lr_ClipRect(a0),a0	; Get pointer to list...
		move.l	cr_MinX(a1),d1	; Get the cliprect X/Y pos...
sortlink_loop:	move.l	(a0),d0		; Get next cliprect...
		beq.s	sortlink_done	; If none, we are at end of list
		move.l	d0,a2		; Well, we should check this one...
		cmp.l	cr_MinX(a2),d1	; Check vs the next one...
		blt.s	sortlink_done	; If time to insert...
		move.l	a2,a0		; Get ready to loop...
		bra.s	sortlink_loop	; And check the next one...
sortlink_done:	move.l	(a0),(a1)	; Get up next pointer...
		move.l	a1,(a0)		; Link it in...
		move.l	(sp)+,a2	; Restore a2
		rts
@


38.14
log
@Made sort_layer_cr *MUCH* faster!!!  (See code for method)
This made layers quite a bit faster!
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.13 91/10/24 10:24:49 mks Exp Locker: mks $
d30 65
a116 56
* This routine will search the layers starting at the given layer
* and working down, skipping the other given layer, finding all of the
* clip rects that match the given one and change the layer pointer to
* be that of the given layer.  Also, mask of the flags field.
*
* a0=start layer
* a1=clip rect to match...
* a2=match layer (new layer pointer)
* d2=flags mask
* d3=new flags mask
*
_set_cr_lobs:	xdef	_set_cr_lobs
set_cr_lobs:	movem.l	a3/a4,-(sp)	; We need some working room...
		move.l	a0,a4		; Get starting layer...
		lea	cr_MinX(a1),a3	; Get cliprect bounds
		move.l	a4,d0		; Get layer
		beq.s	set_done	; If end of list, done...
set_loop:	move.l	d0,a4		; Save it again...
		cmp.l	d0,a2		; Check if match layer
		beq.s	set_notme	; If match, we skip...
*
* Now, we found a layer (in a4) and we need to play some games...
*
* First, check if it intersects with the cliprect...
*
		move.l	a3,a1		; Set up ClipRect bounds pointer
		lea	lr_MinX(a4),a0	; Set up layer bounds pointer
		bsr	_rectXrect	; Do they cross?
		tst.l	d0		; Check d0...
		beq.s	set_notme	; No collision, so skip...
*
* Next, look for the cliprect...
* Note that _rectXrect does not trash a1 so it is already set...
*
		move.l	a4,a0		; Point at layer...
		bsr.s	search_for_cr	; Look for it...
		tst.l	d0		; Did we find one?
		beq.s	set_notme	; If not, no work to do...
		move.l	d0,a1		; Get cliprect pointer...
		tst.l	cr_lobs(a1)	; Check if NULL...
		beq.s	set_notme	; We don't do NULL...
		move.l	a2,d0		; Check if NULL layer...
		beq.s	set_nolayer	; If none, skip...
		move.l	d0,cr_lobs(a1)	; Set new pointer...
set_nolayer:	move.l	cr_Flags(a1),d0	; Get flags...
		and.l	d2,d0		; Mask out old flags...
		or.l	d3,d0		; Put in new flags...
		move.l	d0,cr_Flags(a1)	; Store it back in flags...
*
set_notme:	move.l	lr_back(a4),d0	; Get next layer
		bne.s	set_loop	; We have some more work to do...
set_done:	movem.l	(sp)+,a3/a4	; Restore these...
		rts			; Return...
*
*******************************************************************************
*
d516 1
a516 1
* This routine frees the cliprect
d533 20
@


38.13
log
@Checkin for release...  (Minor code movement)
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.12 91/10/23 16:52:34 mks Exp Locker: mks $
d352 15
d369 11
a387 8
*
* We insert the cr (a1) after the this cr (a2) and loop for more...
*
insert_cr:	move.l	(a1),d0		; Get old next pointer...
		move.l	(a2),(a1)	; Set up new next pointer...
		move.l	a1,(a2)		; Add him to the list...
		tst.l	d0		; Check if we have more
		bne.s	sort_cr_loop	; Continue with the sort...
@


38.12
log
@Moved the last of the layersubs routines into here.
Also now has a better Freecrlist() which only does
Waitblit() when needed
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.11 91/10/23 09:52:25 mks Exp Locker: mks $
a378 25
* This routine is for outside use to insert a single cliprect into
* a layer in sorted order...
*
*	a0=layer
*	a1=cliprect
*
; Not used yet...
;_sortlinkcr:	xdef	_sortlinkcr
sortlinkcr:	move.l	a2,-(sp)	; Save this one.  (we need it)
		lea	lr_ClipRect(a0),a0	; Get pointer to list...
		move.l	cr_MinX(a1),d1	; Get the cliprect X/Y pos...
sortlink_loop:	move.l	(a0),d0		; Get next cliprect...
		beq.s	sortlink_done	; If none, we are at end of list
		move.l	d0,a2		; Well, we should check this one...
		cmp.l	cr_MinX(a2),d1	; Check vs the next one...
		blt.s	sortlink_done	; If time to insert...
		move.l	a2,a0		; Get ready to loop...
		bra.s	sortlink_loop	; And check the next one...
sortlink_done:	move.l	(a0),(a1)	; Get up next pointer...
		move.l	a1,(a0)		; Link it in...
		move.l	(sp)+,a2	; Restore a2
		rts
*
*******************************************************************************
*
d506 25
@


38.11
log
@Added new routine to handle setting the LOBS of a stack of
cliprects...  (This is to get ready for vertical linking)
@
text
@d3 1
a3 1
*	$Id$
d7 6
d18 1
d22 2
d26 1
d291 1
a291 1
_dedice		xdef	_dedice
d375 156
@


38.10
log
@Removed the search for obscured cliprect
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.9 91/09/27 15:30:20 mks Exp Locker: mks $
d39 56
@


38.9
log
@Added the external C langauge definition for sort_layer_cr()
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.8 91/08/30 12:03:13 mks Exp Locker: mks $
a16 15
*
*******************************************************************************
*
* search_obs_cr - A much faster version than the C version.
*		a0=layer	a1=bounds
*
_search_obs_cr:	xdef	_search_obs_cr
		bsr.s	search_for_cr	; Search for the cliprect
		move.l	d0,a0		; Put it into a0...
		move.l	a0,d0		; Put it back to test for null...
		beq.s	no_obcr		; if NULL we are done...
		move.l	cr_lobs(a0),d0	; Check if obscured
		beq.s	no_obcr		; If not, return NULL...
		move.l	a0,d0		; set return value...
no_obcr:	rts			; We are done.
@


38.8
log
@Now uses the fact that we only need to verify the dedice
starting at the cr_lobs layer (only those below)
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.7 91/08/30 11:50:04 mks Exp Locker: mks $
d295 1
@


38.7
log
@Oops, forgot to do the cr_lobs test on the layer...
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.6 91/08/30 11:30:35 mks Exp Locker: mks $
d181 4
a184 2
		move.l	lr_LayerInfo(a2),a3	; Now, get to the top layer
		move.l	li_top_layer(a3),a3	; and from the top get to
a189 5
*
* Check if this is the obscuring layer...  If so, we just skip this test...
*
		cmp.l	cr_lobs(a4),a3		; Check if obscuring layer
		beq.s	v_d_loop		; If so, we skip...
@


38.6
log
@Changed to use a slightly better method to Verify_dedice,
which should make a reasonable performance increase
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.5 91/08/27 14:12:24 mks Exp Locker: mks $
d188 5
@


38.5
log
@Major rework of the layers code for dedice.  Many parts of it are
now in this file.  (Maybe I should have this file become dedice.asm
at some point...)
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.4 91/08/20 10:37:31 mks Exp Locker: mks $
d169 10
d192 1
a192 1
		lea	lr_MinX(a2),a0		; Get my layer's bounds
d200 3
d207 1
a207 1
		bne.s	v_d_other		; make sure the other isn't
a208 10
* In this case, the first cliprect was not found, so the other must not
* be found too!
*
		lea	lr_ClipRect(a3),a0	; Get pointer to *cr
		lea	cr_MinX(a5),a1		; Point at bounds of cr2
		bsr	search_next_cr		; Do the work...
		tst.l	d0			; Check if we blew it
		beq.s	v_d_loop		; If not found, next layer
		bra.s	v_d_false		; If found, verify failed...
*
d210 1
a210 1
* after it.
d212 1
a212 1
v_d_other:	move.l	d0,a0			; Get first result...
d221 1
a272 8
*
* Now, set up the side variable...
*
		move.w	cr_MinX(a3),d0		; Get first MinX
		sub.w	cr_MinX(a1),d0		; Subtract other one...
		seq.b	d0			; Set d0 TRUE if equal...
		ext.w	d0			; Extend to word...
		ext.l	d0			; Make a long... (arg!)
@


38.4
log
@Minor change to the way the routine is handled...
(Just a label change needed during debugging)
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.3 91/08/16 08:32:29 mks Exp Locker: mks $
d11 1
d15 5
d50 1
a50 1
		beq.s	no_cr		; If match, return d0
d53 273
a325 1
no_cr:		rts
@


38.3
log
@Cleaned up a bit and added the search_obs_cr since it was just a
slight addition to the search_for_cr routine.
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.2 91/08/02 10:18:19 mks Exp Locker: mks $
d6 1
a6 2


a10 2


d18 1
a18 1
		bsr.s	_search_for_cr	; Search for the cliprect
d33 1
a33 1
		movem.l	(a1),d1/a1	* get xmin,ymin,xmax,ymax
@


38.2
log
@Native build version checkin...
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 38.1 91/07/25 09:56:18 bart Exp $
d13 19
d33 22
a54 20
* layer
	xdef	_search_for_cr
_search_for_cr:
*	a0=layer	a1=bounds
	movem.l	(a1),d1/a1	* get xmin,ymin,xmax,ymax
*	move.l	(a1),d1		* get xmin,ymin
*	move.l	4(a1),a1	* get xmax,ymax

	lea	lr_ClipRect(a0),a0	; Point at CR pointer
	bra.s	next			; Start the loop...
lp_cr:	move.l	d0,a0		; Move cliprect to A0
	cmp.l	cr_MinX(a0),d1	; Check if same...
	bne.s	next		; If not, do next...
	cmp.l	cr_MaxX(a0),a1	; Check if match
	beq.s	no_cr		; If match, return d0
next:	move.l	(a0),d0		; Get next CR
	bne.s	lp_cr		; Check some more...
no_cr:	rts

	end
@


38.1
log
@begin_v38_development
@
text
@d3 1
a3 1
*	$Id: search_for_cr.asm,v 1.3 90/10/11 15:17:08 rsbx Exp $
d13 1
a13 1
* fast routine to search for a cliprect in a list given pointer to 
d17 1
a17 3
	movem.l	4(sp),a0/a1	* get *layer, *bounds
*	move.l	4(sp),a0	* get pointer to layer
*	move.l	8(sp),a1	* get pointer to bounds
d19 1
a19 1
*	move.l	(a1),d1	* get xmin,ymin
d21 11
a31 13
	move.l	lr_ClipRect(a0),d0
	if <>
		repeat
			move.l	d0,a0
			if cr_MinX(a0)=d1.l
				if cr_MaxX(a0)=a1.l
					rts
				endif
			endif
			move.l	(a0),d0		* sorry I want to  be fast
		until =
	endif
	rts
@
