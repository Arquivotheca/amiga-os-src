head     1.24;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @* @;


1.24
date     94.01.20.18.08.13;  author jesup;  state Exp;
branches ;
next     1.23;

1.23
date     92.08.07.00.45.28;  author jesup;  state Exp;
branches ;
next     1.22;

1.22
date     92.08.05.16.48.03;  author jesup;  state Exp;
branches ;
next     1.21;

1.21
date     92.06.04.14.53.57;  author jesup;  state Exp;
branches ;
next     1.20;

1.20
date     92.04.21.14.48.06;  author jesup;  state Exp;
branches ;
next     1.19;

1.19
date     92.04.14.20.03.38;  author jesup;  state Exp;
branches ;
next     1.18;

1.18
date     92.03.12.19.08.55;  author jesup;  state Exp;
branches ;
next     1.17;

1.17
date     92.01.31.18.19.38;  author jesup;  state Exp;
branches ;
next     1.16;

1.16
date     92.01.21.14.56.26;  author jesup;  state Exp;
branches ;
next     1.15;

1.15
date     92.01.03.16.23.23;  author jesup;  state Exp;
branches ;
next     1.14;

1.14
date     91.11.04.16.31.24;  author jesup;  state KS_V37_300;
branches ;
next     1.13;

1.13
date     91.11.04.15.13.15;  author jesup;  state Exp;
branches ;
next     1.12;

1.12
date     91.10.25.12.08.17;  author jesup;  state Exp;
branches ;
next     1.11;

1.11
date     91.10.24.16.15.20;  author jesup;  state Exp;
branches ;
next     1.10;

1.10
date     91.10.24.11.55.29;  author jesup;  state Exp;
branches ;
next     1.9;

1.9
date     91.10.22.16.20.46;  author jesup;  state Exp;
branches ;
next     1.8;

1.8
date     91.10.18.19.35.25;  author jesup;  state Exp;
branches ;
next     1.7;

1.7
date     91.10.15.13.13.54;  author jesup;  state Exp;
branches ;
next     1.6;

1.6
date     91.10.14.16.43.35;  author jesup;  state Exp;
branches ;
next     1.5;

1.5
date     91.10.14.15.29.34;  author jesup;  state Exp;
branches ;
next     1.4;

1.4
date     91.10.13.23.08.35;  author jesup;  state Exp;
branches ;
next     1.3;

1.3
date     91.10.03.12.11.26;  author jesup;  state Exp;
branches ;
next     1.2;

1.2
date     91.10.03.11.22.12;  author jesup;  state Exp;
branches ;
next     1.1;

1.1
date     91.06.04.19.34.51;  author jesup;  state Exp;
branches ;
next     ;


desc
@at task code
@


1.24
log
@ATA timeout changes from scsidisk 3.0
Media change changes
@
text
@		SECTION	driver,CODE
;==============================================================================
; This code is for handling AT drives in the SCSITask environment.  It is not
; a separate task in its own right.  All AT drives are sent SCSI command blocks
; which are interpreted here and sent to the drive hardware as AT commands.
;==============================================================================
	IFD IS_IDE

		NOLIST
		INCLUDE	"exec/types.i"
		INCLUDE	"exec/interrupts.i"
		INCLUDE	"exec/lists.i"
		INCLUDE	"exec/ports.i"
		INCLUDE	"exec/tasks.i"
		INCLUDE "exec/ables.i"
		INCLUDE "hardware/custom.i"
		INCLUDE	"devices/scsidisk.i"
		INCLUDE	"resources/battmembitsshared.i"
		INCLUDE	"resources/battmembitsamiga.i"
		INCLUDE "resources/battmem.i"
		INCLUDE "cdtv/bookmark.i"

		INCLUDE	"modifiers.i"
		INCLUDE	"device.i"
		INCLUDE	"scsitask.i"
		INCLUDE	"board.i"
		INCLUDE	"printf.mac"
		LIST

;		DEBUGENABLE

		XDEF	XTSelect,XTSendCommand,XTCommandDone,ATFindHardware

		XREF	FakeSelect,FakeDisconnect,FakeTimeout,WaitASecond
		XREF	_LVOWait,_LVOSetSignal
		XREF	_intena,_intenar,_custom
		XREF	_LVOWriteBattMem,BattName,_LVOOpenResource
		XREF	_LVOOpenDevice,_LVOCloseDevice,_LVODoIO

; enable 30 second timeout for drive one

OLD_ATA_TIMEOUT	EQU	1

;==============================================================================
; 020 variant macros, since 68000's can't handle unaligned accesses
;==============================================================================

GETLONG_A1	MACRO	; get at address a1, return in d0.  a0/d1 preserved
			; A1 is incremented by 4!
		IFD	FOR_68000_ONLY
		bsr	getlong_a1
		ENDC
		IFND	FOR_68000_ONLY
		move.l	(a1),d0
		ENDC
		ENDM

PUTLONG_A1	MACRO	; put long at address a1, from d0
			; NOTE: d0/d1 are destroyed, a1 incremented by 4!
		IFD	FOR_68000_ONLY
		bsr	putlong_a1
		ENDC
		IFND	FOR_68000_ONLY
		move.l	d0,(a1)+
		ENDC
		ENDM

;==============================================================================
; Although this is called XTSelect, it is actually responsible for starting
; the given command (in the SCSIDirect command attached to the command block)
;
; All fields of the scsi_Command are used and maintained as if we were talking
; to a SCSI device.  That is, scsi_Actual is updated accordingly and the
; target status is set to check condition ($02) if we get some kind of error.
; scsi_CmdActual will always be set equal to scsi_CmdLength.  AT units will
; only return non-extended sense data for now (won't comply with SCSI-2) but
; fortunately for me, I can use the 4 bytes returned by an AT drive.  The
; important error codes all map directly to SCSI non-extended sense.
;
; When a command completes, the 4 error bytes are read into hu_NextError for
; use by the request sense command which just copies them to the sense data
; area and then clears the error condition in hu_NextError.
;
; FakeSelect call will set up SCSI working pointers which we can use here.
;==============================================================================
ATSelect
		bsr	FakeSelect		put this unit in running slot
		movea.l cb_WCommand(a3),a1      fetch the scsi command
      		move.b	(a1),d0			and the command byte
		cmp.b	#REQUEST_SENSE,d0	is this a request sense?
		beq.s	is_sense		yes, don't clear error values
		clr.l	hu_NextError(a2)	assume no errors
is_sense:
		clr.b	cb_ErrorCode(a3)	assume we will get no errors

;	IFD DEBUG_CODE
;	and.l	#$ff,d0
;	printf <'In ATSelect, command = %lx, a4 = $%lx\n'>,d0,a4
;	ENDC
		lea.l	XTD(pc),a0		scan table for the code
10$		move.l	(a0)+,d1		get offset and command
		beq.s	ATBadCmd		sorry, we don't handle it
		cmp.b	d1,d0			is it this command
		bne.s	10$			nope, keep looking

; puts the translated command value in d0 for the routine to use (mainly for
; read, write, seek which use common routines).  We can't modify the WCommand
; data since scsidirect commands are put directly in there.

		lsr.w	#8,d1			move AT cmd into low byte
		move.b	d1,d0			move it into d0 for command
		swap	d1			code offset to lower word
; d0 is command byte, a1 is scsi command
		jmp	XTD(pc,d1.w)		and call the routine

; we don't support the SCSI command that we were given.  Fake up an error
; condition and set the error codes on this unit for an unimplemented cmd.
ATBadCmd:

	IFD DEBUG_CODE
	printf <'AT: unknown command\n'>
	moveq	#0,d1
	move.b	d0,d1
	printf <'Cmd = 0x%lx, st_RunningUnit = $%lx'>,d1,st_RunningUnit(a5)
	ENDC

		clr.b	cb_ErrorCode(a3)	*** must change this FIX ***
		movea.l	cb_SCSICmd(a3),a1	fetch scsi command
		clr.l	scsi_Actual(a1)		no data transferred
		; set ABRT bit in error code
		moveq	#ERRF_ABRT,d0
		move.l	d0,hu_NextError(a2)	error, illegal command
		moveq	#CHECK_CONDITION,d0	check condition
		bra	ATCommandDone		and disconnect this unit

;==============================================================================
; Dispatch table used to convert scsi commands to the appropriate XT calls
; I'm really only interested in the SCSI commands initiated by this driver
; All routines dispatched to get a pointer to the command block in a0.
; READ_EXTENDED and WRITE_EXTENDED are not supported by XT drives.
;==============================================================================
XTD		DC.W	XT_READ-XTD
		DC.B	AT_READ_SECTORS,READ

		DC.W	XT_WRITE-XTD
		DC.B	AT_WRITE_SECTORS,WRITE

		DC.W	XT_READ_EXT-XTD
		DC.B	AT_READ_SECTORS,READ_EXTENDED

		DC.W	XT_WRITE_EXT-XTD
		DC.B	AT_WRITE_SECTORS,WRITE_EXTENDED

		DC.W	XT_RQS-XTD
		DC.B	0,REQUEST_SENSE

		DC.W	XT_TUR-XTD
		DC.B	0,TEST_UNIT_READY

		DC.W	XT_FMT-XTD
		DC.B	AT_FORMAT,FORMAT_UNIT

		DC.W	XT_SEEK-XTD
		DC.B	AT_SEEK,SEEK

		DC.W	XT_RDC-XTD
		DC.B	0,READ_CAPACITY

		DC.W	XT_MODE_SENSE-XTD
		DC.B	0,MODE_SENSE

		DC.W	XT_SEEK_EXT-XTD
		DC.B	AT_SEEK,SEEK_EXTENDED

		DC.W	XT_INQUIRY-XTD
		DC.B	0,INQUIRY

		DC.W	XT_RECAL-XTD
		DC.B	AT_RECALIBRATE,REZERO_UNIT

		DC.W	XT_READ_VERIFY-XTD
		DC.B	AT_READ_VERIFY_SECTORS,VERIFY

		DC.W	XT_RESERVE-XTD
		DC.B	0,RESERVE

		DC.W	XT_RELEASE-XTD
		DC.B	0,RELEASE

		DC.W	XT_DIAGNOSTIC-XTD
		DC.B	AT_DIAGNOSTICS,SEND_DIAGNOSTIC

		DC.W	0,0

;==============================================================================
; LongXfer (d0.b: command, d1.w: len (sectors))  Transfers a bunch of sectors
;==============================================================================
LongXfer:	; loop, xferring 256 sectors at a time until we have less than
		; 256 left, then do them and finish up.
		movem.l	d2/d3,-(sp)
		move.w	d1,d2			length in sectors
		move.b	d0,d3			command
;	printf <'longxfer of $%lx blocks\n'>,d2

xfer_loop:	move.w	d2,d0
		and.w	#$ff00,d0		is high byte 0?
		beq.s	1$
		; low byte must be 0 here - 0 is 256 blocks
		sub.w	#$0100,d2		count -= 256
		bra.s	2$
1$:		move.b	d2,d0			do remainder (< 256 blocks)
		beq.s	xfer_done		d0 = 0 (success)
		moveq	#0,d2			nothing left after this

2$:		move.b	d0,AT_SectorCnt(a4)	number of sectors to r/w/s
;	printf <'xfering $%lx blocks, $%lx left, cmd = $%lx\n'>,d0,d2,d3

		move.b	d3,AT_Command(a4)	start cmd
		move.b	d0,cb_ATLength(a3)	remember length requested
		move.b	d3,d0			command for findinitstate
		bsr	FindInitState (d0)	get init state for HandleInts
		bsr	HandleInts (d0)		returns 0/2
		tst.b	d0
		bne.s	xfer_err

		; Read/Write and ReadMultiple/WriteMultiple and ReadVerify
		; ALL are guaranteed to leave the last sector read/written/
		; verified in the registers.  We need to bump it.
		move.b	AT_SectorNum(a4),d0
		addq.b	#1,d0
		cmp.b	hu_TotalBlocks+1(a2),d0	careful, sectors are 1-N!
		bls.s	secs_done		branch on d0 <= sectors

		; bump head, maybe cyl
		move.b	AT_DriveHead(a4),d0
		and.b	#$0f,d0			mask off drive bit/etc
		addq.b	#1,d0
		cmp.b	hu_TotalHeads(a2),d0
		bcs.s	heads_done

		; bump cyl
		addq.b	#1,AT_CylLow(a4)
		bcc.s	cyl_done		if carry set, bump high byte
		addq.b	#1,AT_CylHigh(a4)	assume this won't overflow!

cyl_done:	moveq	#0,d0			reset head number
heads_done:	or.b	hu_ATDriveBit(a2),d0	don't forget drive bit!
		move.b	d0,AT_DriveHead(a4)
		moveq	#1,d0			reset sector num (1-N)
secs_done:	move.b	d0,AT_SectorNum(a4)
		bra.s	xfer_loop

xfer_err:	bsr	GetErrorAddr		save address of error
		; returns CHECK_CONDITION in d0

xfer_done:	movem.l	(sp)+,d2/d3
		rts

;==============================================================================
; we've been issued an extended read/write/seek command.  Before issueing the
; command, we convert the block offset to cylinder, head and sector values.
; a3 is	hu_CurrentCmd here, d0 is command byte, a1 is scsi command
; extended r/w/s commands have 4-byte offset, 2 byte xfer length
;
; NOTE: scsi commands are guaranteed to be word-aligned (user commands are
; copied to internally allocated command buffers).
;==============================================================================
XT_READ_EXT:
XT_WRITE_EXT:
XT_SEEK_EXT:
		move.w	d0,-(sp)		save translated command
		move.l	2(a1),d0		get length, offset 2
;	printf <'AT: extended r/w offset = %ld\n'>,d0

		; ATSetAddress may not return!!! be careful of stack!
		bsr.s	ATSetAddress (d0)	set drive/cyl/head/sector
						; a0/a1 are preserved!

;==============================================================================
; Address has been translated, and AT registers poked with the values.
; we need to maintain cb_DidReadDMA to know if we should push the cache
; after an xfer (for copyback caches; right).
;==============================================================================

		move.w	(sp)+,d1		get command back
		move.l	d1,d0			in case multi isn't supported
		cmpi.b	#AT_SEEK,d1
		beq.s	NoExtTransfer		it is, so no transfer needed

		tst.b	hu_MaxRWSize(a2)	can we use read/write multiple?
		beq.s	1$			nope

;	printf <'using r/w multiple\n'>
		moveq.b	#AT_READ_MULTIPLE,d0	assume read
		cmp.b	#AT_READ_SECTORS,d1
		beq.s	1$
		moveq.b	#AT_WRITE_MULTIPLE,d0
1$
		; used to set cb_DidReadDMA here
		move.b	7(a1),d1		get block count
		lsl.w	#8,d1
		move.b	8(a1),d1
;	IFD DEBUG_CODE
;	andi.l	#$ffff,d1
;	printf <'ext length %ld, cmd = $%lx\n'>,d1,d0
;	ENDC
		bsr	LongXfer (d0,d1)	transfer sectors

		bra	ATCommandDone  (d0)

NoExtTransfer:  ; on seek, just send the command and be done with it.
		move.w	d1,d0
		bra	ATSendCommand

;==============================================================================
; convert LBA in d0 to Drive/Cyl/Head/Sector in AT registers.  Destroys
; d0/d1, PRESERVES a0/a1.
;==============================================================================
ATSetAddress:
		move.l	d0,d1			save for SetAddrFail
		divu.w	hu_CylSize(a2),d0	find cylinder number
		bvs.s	SetAddrFail		cylinder > 65535
		cmp.w	hu_TotalCyls+2(a2),d0	is it out of range?
		bcc.s	SetAddrFail		no. (unsigned!)
		move.b	d0,AT_CylLow(a4)	set the cylinder number reg
		lsr.w	#8,d0
		move.b	d0,AT_CylHigh(a4)
		clr.w	d0			clear bottom word
		swap	d0			get remainder (now longword)
		moveq	#0,d1
		move.b	hu_TotalBlocks+1(a2),d1	get number of sectors/head
		divu.w	d1,d0			find out head number 
		or.b	hu_ATDriveBit(a2),d0	combined head/drive register
		move.b	d0,AT_DriveHead(a4)	set the head number
		swap	d0
		addq.b	#1,d0			sectors are 1-N, not 0-(N-1)
		move.b	d0,AT_SectorNum(a4)	set the sector number
;	IFD DEBUG_CODE
;	moveq	#0,d0
;	moveq	#0,d1
;	move.b	AT_CylHigh(a4),d0
;	lsl.l	#8,d0
;	move.b	AT_CylLow(a4),d0
;	move.b	AT_DriveHead(a4),d1
;	printf <'rws: Cyl = %ld, drive/Head = $%lx\n'>,d0,d1
;	move.b	AT_SectorNum(a4),d0
;	printf <'     Sector = %ld\n'>,d0
;	ENDC
		rts
SetAddrFail:
		; VERY tricky!!!
		; called with return addr and translated cmd (word) on stack
		addq.w	#6,sp			drop return address and cmd!
		; fall through

;==============================================================================
; Comes here if the block offset
; we were translating exceeded the disk boundaries.  We just fake up the error
; codes for an illegal address and quit this command now.
;==============================================================================
AT_OutOfRange	move.l	#ERRF_ADDR,d0		bit 8 - address out of range
		move.l	d0,hu_NextError(a2)	stash for request sense
		move.l	d1,hu_ErrorLBA(a2)	d1 has the bad address
		moveq	#CHECK_CONDITION,d0	check condition
		bra	ATCommandDone		clean up and return command

;==============================================================================
; we've been issued a normal read or write command.  Before issueing the
; command, we convert the block offset to cylinder, head and sector values.
; A max sector offset of $00ffffff gives us 4 gig at 256 bytes/sector.
; a3 is	hu_CurrentCmd here, d0 is command byte, a1 is scsi command
;
; NOTE: scsi commands are guaranteed to be word-aligned (user commands are
; copied to internally allocated command buffers).
;==============================================================================
XT_READ:
XT_WRITE:
XT_SEEK:
		move.w	d0,-(sp)		save AT command
		move.l	(a1),d0			get command/lun/length(aligned)
		and.l	#$001fffff,d0		mask off command/lun
;	printf <'AT: r/w/s offset = %ld\n'>,d0

		; ATSetAddress may not return!!! be careful of stack!
		bsr	ATSetAddress (d0)	set drive/cyl/head/sector
						; a0/a1 are preserved!

;==============================================================================
; Address has been translated, and AT registers poked with the values.
; we need to maintain cb_DidReadDMA to know if we should push the cache
; after an xfer (for copyback caches; right).
;==============================================================================

		cmpi.b	#AT_SEEK,1(sp)		counts on stack!
		beq.s	NoTransfer		it is, so no transfer needed

		; used to set cb_DidReadDMA here
		move.b	4(a1),d0		get block count (0 = 256)
		move.b	d0,AT_SectorCnt(a4)
		move.b	d0,cb_ATLength(a3)

;	IFD DEBUG_CODE
;	moveq	#0,d1
;	move.b	d0,d1
;	printf <'rw length = %ld blocks\n'>,d1
;	ENDC
		; start checking for r/w multiple use
		cmp.b	#1,d0
		beq.s	NoTransfer		no need to use r/w multiple
		tst.b	hu_MaxRWSize(a2)	can we use read/write multiple?
		beq.s	NoTransfer		nope

		; we can (and will) use r/w multiple!
;	printf <'using r/w multiple\n'>
		moveq.b	#AT_READ_MULTIPLE,d0	assume read
		cmp.b	#AT_READ_SECTORS,1(sp)
		beq.s	1$
		moveq.b	#AT_WRITE_MULTIPLE,d0
1$:		move.b	d0,1(sp)		change command value

; All registers set up, hit the command register to start the operation
; Make sure the destination, etc has been set up also.
NoTransfer:
		move.w	(sp)+,d0
		bra	ATSendCommand

;==============================================================================
; Does the equivalent of SCSI's test unit ready, sets sense codes accordingly.
; a3 is	hu_CurrentCmd here, d0 is command byte, a1 is scsi command
;==============================================================================
XT_TUR
	printf <'AT: TestUnitReady command\n'>
		; the interface returns 0xff if the drive isn't attached
		; however, we'll check for disk attachment at boot time
		; (recalibrate/diagnostics?) and set a bit we can check here.

		moveq	#0,d0
		bra	ATCommandDone
		
not_ready:	move.l	#ERRF_NOT_READY,hu_NextError(a2)
;						Not Ready, LUN doesn't respond
		clr.l	hu_ErrorLBA(a2)		no location
		moveq	#CHECK_CONDITION,d0	Check Condition
		bra	ATCommandDone

;==============================================================================
; Reserve and Release: merely return success.  We have only one initiator.
;==============================================================================
XT_RESERVE
XT_RELEASE
	printf <'AT: Reserve/Release command\n'>
		moveq	#0,d0
		bra	ATCommandDone
		
;==============================================================================
; Diagnostic: do a self-test if requested, reject otherwise.
; SCSI-2 only requires self-test with param length 0.
; a3 is	hu_CurrentCmd here, d0 is command byte, a1 is scsi command
;==============================================================================
XT_DIAGNOSTIC:
	printf <'AT: Diagnostic command\n'>
		move.b	1(a1),d1		control bits
		btst.b	#2,d1			is selftest set?
		beq.s	badcmd			no

		tst.b	3(a1)			check both param length bytes
		bne.s	badcmd			must be 0
		tst.b	4(a1)
		bne.s	badcmd

		; ok, do selftest
		move.b	d0,AT_Command(a4)	start command
		moveq	#0*2,d0			non-data command
		bsr	HandleInts (d0)		handle interrupts
		; ignore result - it's in the error register

		moveq	#0,d0			paranoia - set result

		cmp.b	#1,AT_Error(a4)
		beq.s	success

		; hardware error, report it
		move.l	#ERRF_SELFTEST,hu_NextError(a2)	    Self-test failure
failure:	moveq	#CHECK_CONDITION,d0		    failure
success:	bra	ATCommandDone

badcmd:		move.l	#ERRF_ABRT,hu_NextError(a2)
		bra.s	failure

;==============================================================================
; Does the equivalent of SCSI's Mode Sense command.  Supported pages:
; 3,4.
; a3 is	hu_CurrentCmd here, d0 is command byte, a1 is scsi command
;==============================================================================
XT_MODE_SENSE:
; FIX!! add mode_sense(10), and page $3f!  (Also caching pages!)
	printf <'AT: ModeSense command\n'>
		; ignore DBD in byte 1
		; for PC == 01, return all 0's
		; for all others, return the same

		bsr	AT_IdentifyDrive	fills hu_ATBuffer
		tst.l	d0			d0=0 for success, d0=2 failure
		bne	ATCommandDone		failed, return with error

		; build response on the stack
		move.l	cb_WCommand(a3),a1	SCSI command
		lea	hu_ATBuffer(a2),a0

		move.b	2(a1),d1		Page Control field
		bmi.s	not_changeable		1 is ok
		btst.b	#6,d1			0 is ok
		beq.s	not_changeable

		; we don't have any changeable data
;	printf <'changeable data requested\n'>
		lea	-24(sp),sp		random size
		move.l	sp,a1
		moveq	#24,d0
		bsr	bzero (a1,d0)		zero out buffer
		and.b	#$3f,d1
		lsl.w	#8,d1
		move.b	#$16,d1
		move.w	d1,(a1)			set page and length
		moveq	#24,d0			nothing changeable
		bra	page_done

not_changeable:
		and.b	#$3f,d1			drop PC, leave page code
		cmp.b	#3,d1
		bne.s	not_page_3

		; page 3: Format Device page
		lea	-24(sp),sp		scsi-2 length
		move.l	sp,a1
		moveq	#24,d0
		bsr	bzero (a1,d0)		zero out buffer-no regs changed

		move.w	#$0316,(a1)		page 3, length $16

		; get number of tracks (for tracks/zone)
		; make zones = the number of heads, for the hell of it
		moveq	#1*2,d0			(no regs changed \/  )
		bsr	getATword (a0,d0)	gets word (byte-swapped) in d0
		move.w	d0,2(a1)		tracks/zone
		moveq	#6*2,d0
		bsr.s	getATword (a0,d0)
		move.w	d0,10(a1)		sectors/track
		move.w	#512,12(a1)		bytes/sector
		move.w	#1,14(a1)		interleave
		moveq	#0*2,d0
		bsr.s	getATword (a0,d0)	config info
		move.b	d0,d1
		lsl.b	#5,d1			bit 7 = soft, bit 6 = hard
		and.b	#$c0,d1			drop other bits
		btst.b	#6,d0
		bne.s	2$
		bset.b	#5,d1			RMB (not fixed, so removable)

2$:		move.b	d1,20(a1)		SSEC/HSEC/RMB/SURF/etc
;	IFD DEBUG_CODE
;	moveq	#0,d0
;	move.w	20(a1),d0
;	printf <'page 3: config bits: $%lx\n'>,d0
;	move.w	2(a1),d0
;	printf <'cylinders: $%lx\n'>,d0
;	move.w	10(a1),d0
;	printf <'sectors/track: $%lx\n'>,d0
;	ENDC
		moveq	#24,d0
		bra.s	page_done

not_page_3:	cmp.b	#4,d1
		bne.s	not_page_4

		; page 4: Rigid Disk Drive Geometry page
		lea	-24(sp),sp		scsi-2 length
		move.l	sp,a1
		moveq	#24,d0
		bsr.s	bzero (a1,d0)		zero out buffer-no regs changed

		move.w	#$0416,(a1)		page 3, length $16

		; get number of tracks
		move.b	1*2(a0),4(a1)		cylinders (low byte)
		move.b	1*2+1(a0),3(a1)		cylinders (high byte)
		move.b	3*2(a0),5(a1)		heads (low byte)
;	IFD DEBUG_CODE
;	move.b	5(a1),d0
;	printf <'page 4: heads: $%lx\n'>,d0
;	ENDC
		; ignore write-precomp/reduced write

		moveq	#24,d0

		; set up the Mode Parameter Header (6)
		; Default Medium Type (0), no Block Descriptors, not WP.
page_done:	clr.l	-(sp)			it's 4 bytes long
		addq.b	#3,d0			mode length is non-inclusive
		move.l	sp,a1
		move.b	d0,(a1)			Mode Data Length
		addq.b	#1,d0			back to real value
		move.l	d0,-(sp)		save length
		bsr	copy_buffer (a1,d0)	copy to dest, set actual
		move.l	(sp)+,d0
		lea	0(sp,d0.w),sp		drop buffer off stack
		moveq	#0,d0
		bra	ATCommandDone

not_page_4:	; illegal request
;	IFD DEBUG_CODE
;	and.l	#$ff,d1
;	printf <'Request for unimplemented page $%lx\n'>,d1
;	ENDC
		asl.w	#8,d1			page #, 0 bytes following
		move.w	d1,-(sp)
		move.l	sp,a1
		moveq	#2,d0			length of result
		bra.s	page_done

;==============================================================================
; Fetch word at (a0,d0), swapping high/low bytes - preserve all regs but d0
;==============================================================================
getATword:
		move.w	0(a0,d0.w),d0
		rol.w	#8,d0
		rts

;==============================================================================
; zero d0 bytes at a1, leave a0/a1/d1 alone
;==============================================================================
bzero:
		move.l	a1,-(sp)
		bra.s	2$
1$:		clr.b	(a1)+			don't care if it's slow
2$:		dbra	d0,1$
		move.l	(sp)+,a1
		rts

	IFD IS_A300
;==============================================================================
; ATFindHardware - Check to see if the hardware is there at all.  Actually,
; we don't care if GAYLE is there if there's no hard drive.
; d0 - drive bit to check
; leaves AT_DriveHead register set
;==============================================================================
get_gid_bit:	; get a bit of the gayle ID register
		move.b	(a1),d0
		lsl.b	#1,d0			high bit into carry and x bits
		roxl.b	#1,d1			rotates x bit into low bit
		rts
	ENDC IS_A300

ATFindHardware
;	printf <'AT: check drive\n'>
		move.l	d0,-(sp)		save drive #

	IFD IS_A300
		; make sure this isn't a mirrored chip register (i.e. that we
		; have an IDE interface here).
		; hardware registers mirror every 512, starting at $dff000.
		; warning - different on different machines!
		; a500/a2000/a3000 - undecoded (random values or 0)
		; a1000 - mirrored chip regs
		; GAYLE id is at $de1000 (write anything, read back 8 times,
		; high bit has the data - pattern is $xx for current rev)

		; check by disable, play with possible intena, see if it
		; appears in the real intenar, then enable.
		move.l	a6,-(sp)
		lea	_custom,a0
		lea	GAYLE_ID_ADDR,a1	GAYLE id address
		DISABLE	a6			; leaves a6 = execbase
		move.w	intenar(a0),-(sp)	save old value
		move.w	#$bfff,intena(a1)	set all ables
		move.w	#$3fff,d1		also flag for no mirror
		cmp.w	intenar(a0),d1
		bne.s	no_mirror
		move.w	d1,intena(a1)		clear all ables
		tst.w	intenar(a0)
		bne.s	no_mirror
		moveq	#0,d1			mirrored
no_mirror:					; leave d1 non-0
		; reset the saved values
		move.w	#$3fff,intena(a0)	clear bits
		ori.w	#$8000,(sp)		add set bit
		move.w	(sp)+,intena(a0)	reset values
		ENABLE	a6,NOFETCH
		move.l	(sp)+,a6

		tst.w	d1			did we find mirroring?
		beq	no_hw			yes, exit

		; no mirroring, can now check GAYLE id register safely
		moveq	#0,d1
		move.b	d1,(a1)			value doesn't matter
		bsr	get_gid_bit		get 4 bits
		bsr	get_gid_bit
		bsr	get_gid_bit
		bsr	get_gid_bit

		cmp.b	#GAYLE_VERSION,d1
		bne.s	no_hw

		; WE HAVE A GAYLE!!!!!!
	ENDC IS_A300

	IFD IS_CDTVCR
; FIX!!! 
IDE_BOOKMARK_ID	EQU	(($1234<<16)!($4321))
IDE_PRI		EQU	127
;	printf <'checking for drive...(cdtv)'>
		; check the bookmark memory to see if we have a drive
		; attached.  If yes, fall through and look for it.  If
		; no, return failure immediately.  If unset, fall through,
		; and update bookmark on finding it.
		lea	-IOSTD_SIZE(sp),sp
		lea	bookmark(pc),a0
		move.l	sp,a1
		move.l	#IDE_BOOKMARK_ID,d0
		moveq	#0,d1
		jsr	_LVOOpenDevice(a6)	("bookmark.device",id,ior,0)
		tst.l	d0
		bne.s	bookmark_open_fail

;	printf <'opened bookmark'>
		move.w	#CMD_READ,IO_COMMAND(sp)
		clr.l	IO_OFFSET(sp)
		move.l	#2,IO_LENGTH(sp)
		move.l	sp,a1			ior
		clr.w	-(sp)			data space for read
		move.l	sp,IO_DATA+2(sp)	we have one more LW on stack
		jsr	_LVODoIO(a6)
		tst.b	IO_ERROR+2(sp)
		bne.s	no_bookmark		couldn't read bookmark

	IFD DEBUG_CODE
	moveq	#0,d0
	move.w	(sp),d0
	printf <'read bookmark, result $%ld'>,d0
	ENDC
; ok, we got the bookmark.  Close device and handle the result.
		lea	2(sp),a1
		jsr	_LVOCloseDevice(a6)

		tst.b	(sp)			test the byte we read
		lea	IOSTD_SIZE+2(sp),sp	drop ior+LW (cc's left alone)
		; 0 = unknown, 1 = no drive, -1 = drive
		ble.s	look_for_drive		unknown or drive exists
		bra	no_hw			we know no drive is out there

no_bookmark:	; bookmark doesn't exist.  Create it, and write it later.
		; create a new bookmark
	printf <'creating bookmark'>
		addq.w	#2,sp			drop longword of storage
		move.w	#BD_CREATE,IO_COMMAND(sp)
		move.l	#IDE_BOOKMARK_ID,IO_OFFSET(sp)
		move.l	#2,IO_LENGTH(sp)	we only need 1 byte (should've
		move.b	#IDE_PRI,LN_PRI(sp)	   already been set!)
		move.l	sp,a1
		jsr	_LVODoIO(a6)

		move.l	sp,a1
		jsr	_LVOCloseDevice(a6)
bookmark_open_fail:
		lea	IOSTD_SIZE(sp),sp
	ENDC

look_for_drive:	; the number of seconds to look for a "possible" drive
		; some drives show 0 status for up to 9 seconds (seacrate).
		; drives can take up to 30 seconds to appear.
		; Seagate says some of their drives might take 15! seconds
		; Now they say 20 seconds or more!!!!!!
		moveq	#30,d0			worst drive is seagate ????

		; if seltimeout is set, we're REAL sure there are 2 drives out
		; there, so wait a fairly long time for them.
		; The spec says that drive 0 will NOT show ready until drive
		; 1 is ready.  So, if we're looking for drive 1, we must have
		; already found drive 0, so drive 1 MUST be ready.
		btst.b	#DHB_SLAVE,3(sp)	check if this is drive 1
		beq.s	5$
	IFD IS_A1000
	  IFD OLD_ATA_TIMEOUT
		moveq	#30,d0
	  ENDC
	  IFND OLD_ATA_TIMEOUT
		moveq	#1,d0
	  ENDC
	ENDC
	IFND IS_A1000
		; don't wait any extra time on A1200/A600 - almost never has
		; extra drive.
		moveq	#0,d0
	ENDC
5$		move.b	d0,(sp)			value on stack is byte in LW.

hw_check_stat:	; Select the drive we wish to play with
		move.b	3(sp),AT_DriveHead(a4)	head irrelevant

		; first, see if the drive is ready to accept commands
		; try to eliminate non-existant drives that return impossible
		; values.
		move.b	AT_CylLow(a4),d1	get a register/status value
		move.b	AT_Status(a4),d0
		move.l	d0,a0			temp storage
		and.b	#$C0,d0			leave BSY and RDY
		beq.s	no_bsy_no_rdy		neither - _may_ be a drive
		cmp.b	#$c0,d0
		beq	no_hw			both - not possible
		tst.b	d0			is it busy?
		bpl	hw_not_busy ^

	printf <'not ready, busy\n'>
		; check that the other register read back as status since it's
		; busy.  When busy, the drive must return status for all
		; registers.
		move.l	a0,d0			get back orig value
		eor.b	d1,d0			funky!  == 0 or ATF_IDX if good
		and.b	#~(ATF_IDX),d0		drop off index bit
		bne.s	no_hw			didn't read status!!!!

		; person who called usually waits N seconds for non-busy
		moveq	#2,d0			busy...
		bra	hw_exit ^			need to drop value off stack

no_bsy_no_rdy:	; not busy, not ready.  There _might_ be a drive out there.
		; only do this check for drive 0!
	printf <'not ready, not busy, unit = $%lx'>,(sp)

	IFD OLD_ATA_TIMEOUT
		; we set timeout for drive 1 to 1 second max, so there's no
		; need to test for it
	IFD IS_A1000
		; only wait longer for the second drive if the battmem bit
		; is set.
		tst.b	st_SelTimeout(a5)	used as flag for second drive..
		bne.s	5$			we're pretty sure there's a
	ENDC
		btst.b	#DHB_SLAVE,3(sp)			second drive...
		bne.s	no_hw
	ENDC

		; Wait a few seconds to see if we get busy or rdy
5$		subq.b	#1,(sp)
		bmi.s	no_hw			it didn't show up
		bsr	WaitASecond
		bra.s	hw_check_stat		try again
	
hw_found: printf <'found hardware'>
	IFD IS_CDTVCR
;	printf <'updating bookmark'>
		; update bookmark to indicate we found the drive.  Do it
		; everytime; who care about the overhead.
		lea	-IOSTD_SIZE(sp),sp
		move.w	#-1,-(sp)		data space for write (!0)
		lea	bookmark(pc),a0
		lea.l	2(sp),a1
		move.l	#IDE_BOOKMARK_ID,d0
		moveq	#0,d1
		jsr	_LVOOpenDevice(a6)	("bookmark.device",id,ior,0)
		tst.l	d0
		bne.s	10$

;	printf <'writing bookmark'>
		; 2(sp) is the ior, (sp).w is the data (-1)
		move.w	#CMD_WRITE,IO_COMMAND+2(sp)
		clr.l	IO_OFFSET+2(sp)
		move.l	#2,IO_LENGTH+2(sp)
		move.l	sp,IO_DATA+2(sp)
		lea	2(sp),a1		ior
		jsr	_LVODoIO(a6)
		; ignore error
	IFD DEBUG_CODE
	moveq	#0,d0
	move.b	IO_ERROR+2(sp),d0
	printf <'wrote bookmark, io_error = %ld'>,d0
	ENDC

; ok, wrote the bookmark.  Close device and handle the result.
		lea	2(sp),a1
		jsr	_LVOCloseDevice(a6)

10$		lea	IOSTD_SIZE+2(sp),sp	drop word and ior
	ENDC ; IS_CDTVCR

	IFD OLD_ATA_TIMEOUT
	IFD IS_A1000
		; if this is slave and the seltimeout was not set, change
		; battmem to set it.
		btst.b	#DHB_SLAVE,3(sp)
		beq.s	20$
		tst.b	st_SelTimeout(a5)
		bne.s	20$
		moveq	#1,d0			mark we have a drive...
		bsr	SetBattmem
	ENDC
	ENDC
20$		moveq	#1,d0			looks like a drive....
		bra.s	hw_exit			need to drop value off stack
		
		; first, check if the drive registers are there
hw_not_busy:
	printf <'ready, not busy\n'>
		moveq	#$12,d0			a random value
		move.b	d0,AT_CylLow(a4)
		cmp.b	AT_CylLow(a4),d0
		bne.s	no_hw
		moveq	#$34,d0			a different random value
		move.b	d0,AT_CylLow(a4)
		cmp.b	AT_CylLow(a4),d0
		beq	hw_found ^		writable - probably real

no_hw: printf <'no hardware'>

	IFD IS_CDTVCR
		; if slave, don't update bookmark!
		btst.b	#DHB_SLAVE,3(sp)
		bne.s	20$

;	printf <'updating bookmark'>
		; update bookmark to indicate we didn't find the drive.  Do it
		; everytime; who care about the overhead.
		lea	-IOSTD_SIZE(sp),sp
		move.w	#$0101,-(sp)		data space for write ($01)
		lea	bookmark(pc),a0
		lea.l	2(sp),a1
		move.l	#IDE_BOOKMARK_ID,d0
		moveq	#0,d1
		jsr	_LVOOpenDevice(a6)	("bookmark.device",id,ior,0)
		tst.l	d0
		bne.s	10$

;	printf <'writing bookmark'>
		; 2(sp) is the ior, (sp).w is the data ($0101)
		move.w	#CMD_WRITE,IO_COMMAND+2(sp)
		clr.l	IO_OFFSET+2(sp)
		move.l	#2,IO_LENGTH+2(sp)
		move.l	sp,IO_DATA+2(sp)
		lea	2(sp),a1		ior
		jsr	_LVODoIO(a6)
		; ignore error
	IFD DEBUG_CODE
	moveq	#0,d0
	move.b	IO_ERROR+2(sp),d0
	printf <'wrote bookmark, io_error = %ld'>,d0
	ENDC

; ok, wrote the bookmark.  Close device and handle the result.
		lea	2(sp),a1
		jsr	_LVOCloseDevice(a6)

10$		lea	IOSTD_SIZE+2(sp),sp	drop word and ior
20$
	ENDC ; IS_CDTVCR

	IFD OLD_ATA_TIMEOUT
	IFD IS_A1000
		; if this is slave and the seltimeout was set, change
		; battmem to clear it since we couldn't find the drive.
		btst.b	#DHB_SLAVE,3(sp)
		beq.s	30$
		tst.b	st_SelTimeout(a5)
		beq.s	30$
		moveq	#0,d0			mark we have no drive...
		bsr	SetBattmem
30$
	ENDC
	ENDC
		moveq	#0,d0			no hardware out there
hw_exit:	addq.w	#4,sp			drop drive value
		rts

	IFD IS_A1000
; set the battmem BATTMEM_SCSI_TIMEOUT bit to 0 or 1
; takes d0 as new value for battmem
SetBattmem:
	printf <'setting battmem slowboot bit'>
		; no need to check for version >= 36, if it's there, use it
		movem.l	d0/a6,-(sp)		TRICKY - d0 is on top of stack
		lea.l	BattName(pc),a1
		jsr	_LVOOpenResource(a6)	get battmem resource
		tst.l	d0			did we get it ?
		beq.s	BattMemDone		nope, so not using 2.0
		movea.l	d0,a6

		lea	3(sp),a0		addr of bits of d0 (low byte)
		moveq.l	#BATTMEM_SCSI_TIMEOUT_ADDR,d0
		moveq.l	#BATTMEM_SCSI_TIMEOUT_LEN,d1
		jsr	_LVOWriteBattMem(a6)
	printf <'set'>
BattMemDone	movem.l	(sp)+,d0/a6
		rts
	ENDC

	IFD IS_CDTVCR
bookmark:	dc.b	'bookmark.device',0
		CNOP 0,2
	ENDC

;==============================================================================
; ATCheckDrive - check if an AT drive exists.  Timeout after a while if it
; doesn't respond.  Sets hu_Found to non-zero for success.  Returns 0 for
; success, 2 or 8 for failure or busy.
;==============================================================================
ATCheckDrive:
	printf <'AT: check drive\n'>
		; make sure this isn't a mirrored chip register (i.e. that we
		; have an IDE interface here).
		; hardware registers mirror every $xxx, starting at $dff000.
		; warning - different on different machines!
; FIX!!!!!!!!

		; Select the drive we wish to play with
		move.b	hu_ATDriveBit(a2),d0
		bsr	ATFindHardware		Make sure this drive is there
		; leaves AT_DriveHead bit set
		tst.l	d0
		beq.s	check_failed		no hardware
		cmp.b	#2,d0			was it busy?
		bne.s	1$

		; busy - return.  lib.asm will keep trying
		moveq	#BUSY,d0
		rts
1$:
		; at this point the drive MUST be READY since it's not BUSY.
		; It's almost certainly there.  Do a recalibrate with timeout
		moveq	#0,d0

	IFD USE_ENABLE_INTS
		; Randy Hilton says we must do an enable interrupt, though
		; it seems most drives come up with them enabled (except the
		; PrairieTek 342).
		; DCF_INT_ENABLE == 0!!  d0 is 0 here
		move.b	d0,AT_DeviceCtrl(a4)
	ENDC
		; clear signal (d0 is 0)
		move.l	st_IntPendMask(a5),d1	which signal to clear
		jsr	_LVOSetSignal(a6)	clear int signal

		move.b	#AT_RECALIBRATE,AT_Command(a4)
		moveq	#15,d1			15 seconds max
wait_loop:	move.w	d1,-(sp)		save count
		moveq	#0,d0
		moveq	#0,d1
		jsr	_LVOSetSignal(a6)	get current signals
		and.l	st_IntPendMask(a5),d0	did we get the signal?
		bne.s	found_it
	printf <'waiting\n'>
		bsr	WaitASecond		delay a second
		move.w	(sp)+,d1
		dbra	d1,wait_loop
		; fall through

check_failed:
	printf <'no drive!\n'>
		move.l	#ERRF_NOT_READY,hu_NextError(a2)
		moveq	#CHECK_CONDITION,d0	failure - no drive!
		rts				can't set hu_Found

found_it:	; d0 is IntPendMask
	printf <'found drive\n'>
		; wait for drive to be not busy (paranoia!)
		; Reading status can clear int- is this safe???? FIX???
1$		btst.b	#ATB_BSY,AT_Status(a4)
		bne.s	1$

		addq.w	#2,sp			drop wait count
		jsr	_LVOWait(a6)		won't wait - fast clear
		moveq	#0,d0			found a drive!!!!
		subq.b	#1,hu_Found(a2)		make hu_Found non-zero
	IFD DEBUG_CODE
	move.b	hu_Found(a2),d0
	printf <'hu_Found set to $%lx, a2 = $%lx\n'>,d0,a2
	move.b	hu_ATDriveBit(a2),d0
	printf <'hu_ATDriveBit = $%lx\n'>,d0
	moveq	#0,d0
	ENDC
		rts

;==============================================================================
; Does the equivalent of SCSI's Inquiry command
; NOTE: Inquiry is always the first command called when searching for a drive
; a0 is	hu_CurrentCmd here, d0 is command byte, a1 is scsi command
;==============================================================================
XT_INQUIRY
	printf <'AT: Inquiry command\n'>
		moveq	#0,d1			not boottime

		; check if the drive exists if we haven't already
		tst.b	hu_Found(a2)		is this boot-time?
		bne.s	not_boottime		no
		bsr	ATCheckDrive		see if drive is there
		tst.b	d0
		bne	ATCommandDone		failed - punt

		; now, to handle somewhat confused drives, we send a
		; Initialize Drive Parameters command to tell it what it told
		;  me it was.  Really stupid, but the Conner 2024 needs this.
		moveq	#1,d1			boottime

	; FIX!!!! copy fixed buffer, then modify!
not_boottime:	move.w	d1,-(sp)		save boottime flag
		bsr	AT_IdentifyDrive	fills hu_ATBuffer
		move.w	(sp)+,d1
		tst.l	d0			d0=0 for success, d0=2 failure
		bne	ATCommandDone		failed, return with error

		; build inquiry response on the stack
		lea	hu_ATBuffer(a2),a0

	IFD USE_INIT_PARAM
		; set features to tell it what it's own geometry is (wierd)
		tst.w	d1			only do at boottime
		beq.s	no_init_param

		; Some drives (eg. Conner CP2024 2.5" 20MB) require this.
		; I believe this should NOT be needed according to the CAM-ATA
		; spec!  The Identify values should be for the "default
		; translation mode", so I say that means you shouldn't have to
		; do an inititialize drive parameters.  - REJ
		move.b	6*2(a0),AT_SectorCnt(a4) set sectors/track
		move.b	3*2(a0),d0		heads
		subq.b	#1,d0			it wants heads-1
		or.b	hu_ATDriveBit(a2),d0	add drive bit in
		move.b	d0,AT_DriveHead(a4)	set it
		move.b	#AT_INIT_PARAMETERS,AT_Command(a4)
		moveq	#0*2,d0			no data xfer
		move.l	a0,-(sp)		save ATBuffer ptr
		bsr	HandleInts (d0)		0 for success, 2 for failure
	printf <'InitParameters returned %ld\n'>,d0
		move.l	(sp)+,a0
		; ignore failure or success - what would we do anyways?
	ENDC

no_init_param:
		; set parameters on a Inquiry command, which is always done
		; before any access.  Might(?) hurt to do it more than once.
		tst.b	hu_MaxRWSize(a2)
		bne.s	no_set_multiple		already set it once
		move.b	47*2(a0),d0		low byte(0-7), word 47

		; limit max read/write multiple to give controllers a better
		; chance to make good use of their buffers (and overlap
		; bus transfers with disk transfers).  Tuning with a Seagate
		; ST1480A and a WD 2120 seem to indicate this is the best
		; compromise.

		; was 16, now 8.  Schilling insists that it's
		; important and that "lots" of drives will fail with 16.
		; 8 _does_ cause a noticable CPU use increase.  The strong
		; argument is that OS2 and NT use 128 and 8.

		; OS/2 and NT apparently DON'T use RW Multiple.  Also the drive
		; vendors more-or-less disagree with him on the 8 vs. 16 thing.
		cmp.b #16,d0
		bls.s 1$
;	printf <'restricting max R/W to 16 from $%lx\n'>,d0
		moveq #16,d0
1$:
		move.b	d0,hu_MaxRWSize(a2)	max number of blocks for mult.
		beq.s	no_set_multiple		if not supported, skip set mult

		; send Set Multiple Mode to drive
		; can't do r/w multiple without it
		move.b	d0,AT_SectorCnt(a4)	use whatever it told me to
		move.b	hu_ATDriveBit(a2),AT_DriveHead(a4)	head irrelevant
		move.b	#AT_SET_MULTIPLE_MODE,AT_Command(a4)	start cmd
		moveq	#0*2,d0			non-data command
		move.l	a0,-(sp)		save reg (buffer ptr)
		bsr	HandleInts (d0)		returns 0 for success, 2 failure
		move.l	(sp)+,a0		restore reg
		tst.b	d0			did we fail?
		beq.s	no_set_multiple
		clr.b	hu_MaxRWSize(a2)	failed - nuke r/w multiple
	printf <'set multiple failed\n'>

no_set_multiple:
		moveq	#1*2,d0
		bsr	getATword (d0,a0)
		move.w	d0,hu_TotalCyls+2(a2)
		moveq	#0,d0
		moveq	#0,d1
		move.b	3*2(a0),d0		low byte first!
		move.b	d0,hu_TotalHeads(a2)
		move.b	6*2(a0),d1
		move.b	d1,hu_TotalBlocks+1(a2)	sectors, low byte first
		mulu	d0,d1
		move.w	d1,hu_CylSize(a2)	sectors * heads
		
	IFD DEBUG_CODE
	move.w	(a0),d0
	printf <'config bits: $%lx\n'>,d0
	move.w	hu_TotalCyls+2(a2),d0
	printf <'cylinders: $%lx\n'>,d0
	moveq	#0,d0
	move.b	hu_TotalHeads(a2),d0
	printf <'heads: $%lx\n'>,d0
	move.b	hu_TotalBlocks+1(a2),d0
	printf <'sectors/track: $%lx\n'>,d0
	move.b	hu_MaxRWSize(a2),d0
	printf <'max r/w multiple is %ld blocks\n'>,d0
	ENDC

		move.l	a2,-(sp)		free a register
		lea	-36(sp),sp		up to product revision level
		move.l	sp,a1
		moveq	#0,d1			keep a 0 around
		moveq	#0,d0			assume disk device

	IFD IDE_TAPES_SUPPORTED
		; check device type
		btst.b	#6,(a0)			low word first!!!
		bne.s	10$
		moveq	#1,d0			tape device?? removeable disk??
;						; FIX!!!
10$
	ENDC
		btst.b	#7,1(a0)		high word second
		beq.s	20$
		moveq	#7,d0			optical device???

20$		move.b	d0,(a1)+		0: peripheral qualifier/type
		move.b	(a0),d0			bits 0-7, word 0
		and.b	#$80,d0			leave bit 7 only - rmb
		move.b	d0,(a1)+		1: rmb/modifier
		moveq	#2,d0
		move.b	d0,(a1)+		2: ISO/ECMA/ANSI - scsi-2
		move.b	d0,(a1)+		3: scsi-2 response format
		move.b	#35-4,(a1)+		4: additional length
		move.b	d1,(a1)+		5: reserved
		move.b	d1,(a1)+		6: reserved
		move.b	#$20,(a1)+		7: WBus16 (16-bit xfers)

		; copy bytes from product up to first space or 8 chars max
		; the bytes end up swapped!!!!
		moveq	#7,d0
		lea	27*2(a0),a2		ptr to model number
30$		bsr.s	getswapbyte		returns byte in d1
		move.b	d1,(a1)+		8-15: Vendor
		subq.w	#1,d0
		bmi.s	40$
		cmp.b	#' ',d1			up to first space or 8 chars
		bne.s	30$
40$
		tst.w	d0
		bmi.s	60$			used 8 chars
		moveq	#' ',d1
50$		move.b	d1,(a1)+		pad with spaces
		dbra	d0,50$
60$
		; ok, vendor handled, now do product.
		moveq	#15,d0
70$		bsr.s	getswapbyte		returns byte in d1
		move.b	d1,(a1)+		16-31: product
		dbra	d0,70$

		; finally, revision
		moveq	#3,d0
		lea	23*2(a0),a2		firmware revision
80$		bsr.s	getswapbyte		returns byte in d1
		move.b	d1,(a1)+		32-35: revision
		dbra	d0,80$

;	IFD DEBUG_CODE
;	lea	8(sp),a0
;	moveq	#0,d0
;	move.w	(sp),d0
;	printf <' type/qual $%lx, ---%s--- \n'>,d0,a0
;	ENDC
		; ok, all done.  Copy it to destination and clean up
		moveq	#36,d0
		move.l	sp,a1			get ptr to block again
		bsr	copy_buffer (a1,d0)	copy to dest, set actual

		lea	36(sp),sp		drop block
		move.l	(sp)+,a2		restore reg
		moveq	#0,d0			success
		bra	ATCommandDone		scsi_actual set

getswapbyte:	; get next byte of byte-swapped string (a2), return in d1
		; bump a2, leave a1/d0 untouched
		move.w	a2,d1
		addq.w	#1,a2
		lsr.w	#1,d1
		bcs.s	was_odd
		move.b	(a2),d1			already bumped 1
		rts
was_odd:	move.b	-2(a2),d1		already bumped 1
		rts

;==============================================================================
; Does the equivalent of a SCSI request sense.  We don't have to go to the
; drive for this because the sense info was already fetched when the command
; completed.  It is held in hu_NextError ready for copying into the data area
; a3 is	hu_CurrentCmd here, d0 is command byte, a1 is scsi command
;==============================================================================
XT_RQS:		move.b	#UNIT_WAITING,hu_WhatNext(a2)  where to go next
		move.l	hu_NextError(a2),d0
	printf <'AT: error = 0x%lx\n'>,d0

		lea	ErrorTable(pc),a1
1$:		move.w	(a1),d1
		beq.s	found			0,0 is end of table
		and.w	d0,d1			and has a generic error (5,0)
		bne.s	found
		addq.w	#4,a1
		bra.s	1$
found:
		move.w	2(a1),d1		get key/code for error

; byte:   data:
;  0	   $70
;  1	    0
;  2	  <key>		Sense Key
;  3-6	    0		Information field, (address for error)
;  7	   $0a		additional length (18 bytes total, 0-17)
;  8-11	    0		Command-specific information (not given)
;  12	  <code>	Additional sense code
;  13	  <qual>	Additional sense qualifier
;  14-17    0		sense-key specific information (not given???? FIX!)
;
; Bytes: 2  12 13  (hex)
;
; BBK:   3? 11? 0	bad block mark detected??  FIX!
; UNC:   3  11 0	(Unrecovered read error)
; MC	 6  28 0	(Ready/NotReady transition)
; IDNF:  3  12 0	(ID address mark not found)
; AMNF:  3  13 0	(Data address mark not found)
; TK0NF: 4   6 0	(reference position not found)
; ABRT:  5  20 0	(invalid command)
; bit 8: 5  21 0	(LBA address out of range)
; bit 9: 2   5 0	(Not Ready, LUN doesn't respond)
; bit10: 4  42 0	(Power On or Self-Test failure)
; other: 5   0 0	(Illegal request, no more info)
;
		; build sense data on stack
		lea	-18(sp),sp		get space on stack
		move.l	sp,a1			dest for template
		moveq	#18,d0			# of chars
		bsr	bzero (a1,d0)		all 0's (doesn't 

		; fix up the two bytes we modify, and two fixed bytes
		move.b	d1,2(a1)
		lsr.w	#8,d1
		move.b	d1,12(a1)
		move.b	#$70,(a1)
		move.b	#$0a,7(a1)

		; add information field (block of error if any)
		lea	3(a1),a0
		exg	a0,a1			a0 will be preserved
		move.l	hu_ErrorLBA(a2),d0	block of last error, if any
		PUTLONG_A1			; preserves a0 (only)

		move.l	a0,a1
		moveq	#18,d0			length of data
		bsr	copy_buffer (a1,d0)	copy and set up scsi fields
;						also sets actual

		lea	18(sp),sp		drop data buffer
		moveq	#0,d0			success
		bra	ATCommandDone		assumes we set scsi_Actual

;
; layout: (word) mask for error register, followed by code, and key for
; the sense data.  Qualifier is always 0 thus far.
ErrorTable:
	DC.B	$00,$01,$13,$03	; AMNF - Data Address Mark not found
	DC.B	$00,$02,$06,$04	; TK0NF - reference position not found
	DC.B	$00,$04,$20,$05	; ABRT - invalid command
;	DC.B	$00,$08,??,??	; MCR - media change requested
	DC.B	$00,$10,$12,$03	; IDNF - ID address mark not found
	DC.B	$00,$20,$28,$06	; MC - media change
	DC.B	$00,$40,$11,$03	; UNC - unrecovered read error
	DC.B	$00,$80,$11,$03	; BBK - bad block mark detected??? FIX!!!!
	DC.B	$01,$00,$21,$05	; bit 8 - LBA address out of range
	DC.B	$02,$00,$05,$02	; bit 9 - Not Ready, LUN doesn't respond
	DC.B	$04,$00,$42,$04	; bit 10 - Power On or Self-Test failure
	DC.B	$00,$00,$00,$05	; unknown - Illegal request, no more info

	CNOP	0,2
	
;==============================================================================
; Does a format unit with no special flags or bad block lists sent to the drive
; a3 is	hu_CurrentCmd here, d0 is command byte, a1 is scsi command
;==============================================================================
XT_FMT
	printf <'AT: Format_Unit called\n'>

	IFND IDE_FORMAT_OK
		moveq	#0,d0			success
		bra	ATCommandDone
	ENDC
	IFD IDE_FORMAT_OK
		; send a format command for each track(!), with a data
		; field of mapped sectors (or 0's).  If we're ambitious, 
		; translate scsi format error lists.

		movem.l	d2-d7,-(sp)		save reg

		; save some fields, make a scsi control block
		move.l	cb_WData(a3),-(sp)	save old data ptr
		move.l	cb_LinkedCmd(a3),-(sp)	save old scsiblk ptr
		lea	-scsi_SIZEOF(sp),sp	allocate a SCSICmd struct
		move.l	sp,cb_LinkedCmd(a3)	new scsicmd
		move.l	#512,d0
		move.l	d0,scsi_Length(sp)	format data is 512 long

		move.w	hu_TotalCyls+2(a2),d4	number of cyls
		move.b	hu_TotalHeads(a2),d5	number of heads
		move.b	hu_ATDriveBit(a2),d6	starting head
		move.b	hu_TotalBlocks+1(a2),d7	number of sectors

		lea	hu_ATBuffer(a2),a1
		move.w	#512,d0
		bsr	bzero  (d0,a1)		clear buffer

		; don't mark any sectors as bad.  Must put each sector in the
		; data buffer, followed by a 0 (sectors 1-N).  Order is
		; important (1-N). It better not have more than 128 sectors!
		lea	hu_ATBuffer(a2),a1
		moveq	#0,d0
sec_loop:	addq.b	#1,d0			bump it first (1-N)
		move.b	d0,(a1)+
		clr.b	(a1)+			good sector
		cmp.b	d0,d7
		bne.s	sec_loop		only 1 to N, not 0 to N-1

		moveq	#0,d2			starting cylinder
		move.l	d6,d3			start at head 0 (set drive bit)
	printf <'Format: %ld cyls, %ld heads, %ld sectors\n'>,d4,d5,d7
cyl_loop:
	printf <'formatting cyl $%lx, head $%lx\n'>,d2,d3
		move.b	#1,cb_ATLength(a3)	1 sector of data to xfer
		lea	hu_ATBuffer(a2),a1	get the data pointer
		move.l	a1,cb_WData(a3)		use our fixed buffer
		clr.l	scsi_Actual(sp)		reset to nothing xfered yet
		move.w	d2,d0
		move.b	d0,AT_CylLow(a4)
		lsr.w	#8,d0
		move.b	d0,AT_CylHigh(a4)
		move.b	d3,AT_DriveHead(a4)
		move.b	d7,AT_SectorCnt(a4)
		move.b	#AT_FORMAT,AT_Command(a4)	- start format
		moveq	#2*2,d0			initial state - write
		bsr	HandleInts (d0)		transfer the data, wait for int
		tst.b	d0			failure?
		bne.s	format_done
		and.b	#$0f,d3
		addq.b	#1,d3
		cmp.b	d3,d5			do we need to change cyls?
		bgt.s	1$
		addq.w	#1,d2			yes, bump cyl, clear head
		cmp.w	d2,d4			are we done? (unsigned)
		bls.s	format_done		d0 == 0 here
		moveq	#0,d3
1$:		or.w	d6,d3			or in the drive select bit
		bra.s	cyl_loop

format_done:	; d0 has success/failure
	printf <' format done, result %ld\n'>,d0
		lea	scsi_SIZEOF(sp),sp	drop scsi block
		move.l	(sp)+,cb_LinkedCmd(a3)	restore scsiblk ptr
		move.l	(sp)+,cb_WData(a3)	restore data ptr
		movem.l	(sp)+,d2-d7		restore regs
		
		bra	ATCommandDone
	ENDC

;==============================================================================
; Does the equivalent of a read capacity command.  This one just grabs the
; unit fields and returns them.  We must make sure they're initialized at
; startup time, either via rdsk or via Identify Drive.
; a3 is	hu_CurrentCmd here, d0 is command byte, a1 is scsi command
;==============================================================================
XT_RDC:
	printf <'Read Capacity called\n'>
		moveq	#0,d0
		moveq	#0,d1
		btst.b	#0,8(a1)		test RELADR bit of command
		bne.s	rdc_relative
		move.b	hu_TotalBlocks+1(a2),d0	actually sectors/track
		move.b	hu_TotalHeads(a2),d1	heads
		mulu	d1,d0			sectors*heads (16 bits max)
		move.w	hu_TotalCyls+2(a2),d1	cyls
		mulu	d1,d0			sectors*heads*cyls
		subq.l	#1,d0			LBA of last sector
		bra.s	rdc_store_result
rdc_relative:
;	printf <'relative read_capacity\n'>
		; find next cylinder boundary - a1 has scsi cmd block
		; new LBA = (((LBA)/CylSize) + 1)*CylSize - 1

		move.l	2(a1),d0		get LBA from aligned cmd block
		move.w	hu_CylSize(a2),d1	get cylinder size
		divu.w	d1,d0			LBA/cylsize = cyls
		addq.w	#1,d0			next cylinder
		mulu	hu_CylSize(a2),d0	get LBA of 1st sec of next cyl
		subq.l	#1,d0			LBA of last sec of curr cyl
;						(d0 is now longword)

rdc_store_result:
	printf <'rdc size: %ld blocks\n'>,d0
		move.l	#512,-(sp)		always 512 byte blocks
		move.l	d0,-(sp)		LBA
		moveq	#8,d0			# of bytes of data
		move.l	sp,a1			pointer to source buffer
		bsr	copy_buffer (a1,d0)	a1->cb_WData(a3), sets actual
		addq.w	#8,sp			drop them

		moveq	#0,d0			success
		bra	ATCommandDone		assumes we set scsi_Actual

;==============================================================================
; this does an AT recalibrate command.
; a3 is	hu_CurrentCmd here, d0 is command byte, a1 is scsi command
;==============================================================================
XT_RECAL:
	printf <'Recalibrate called\n'>
		move.b	hu_ATDriveBit(a2),AT_DriveHead(a4)	head irrelevant

		; d0 is AT_RECALIBRATE
		bra	ATSendCommand

;==============================================================================
; this does an AT recalibrate command.
; a3 is	hu_CurrentCmd here, d0 is command byte, a1 is scsi command
;==============================================================================
XT_READ_VERIFY:
	printf <'Verify called\n'>
; FIX! handle BytChk!!
		; note: ATSetAddress can exit to AT_OutOfRange, must have LW
		; on stack plus return addr.
		move.w	#AT_READ_VERIFY_SECTORS,-(sp)  IMPORTANT! (don't move)
		move.l	2(a1),d0		get LBA of start from cmd
		bsr	ATSetAddress		may exit to OutOfRange
						; a0 is preserved

		move.l	cb_WCommand(a3),a1	get scsi cmd back
		move.b	7(a1),d1		d2 is saved
		lsl.w	#8,d1
		move.b	8(a1),d1		got length in blocks
		move.w	(sp)+,d0		command
		bsr	LongXfer		do long io

		bra	ATCommandDone  (d0)

;==============================================================================
; this does an AT identify drive command, which is needed for things like
; initializing the hu_TotalXxxx fields, Inquiry, etc.  The data is stored
; in hu_Buffer.  We must save and restore several ptrs.
;==============================================================================
AT_IdentifyDrive:
	printf <'Identify Drive called\n'>
		; Also, identify is an optional command.  An idea: we can
		; try reading higher sectors until failure, then higher heads,
		; then higher cylinders.  Icky-poo.

		move.b	hu_ATDriveBit(a2),AT_DriveHead(a4)	head irrelevant

		; save some fields, make a scsi control block
		move.l	cb_WData(a3),-(sp)	save old data ptr
		move.l	cb_LinkedCmd(a3),-(sp)	save old scsiblk ptr
		lea	-scsi_SIZEOF(sp),sp	allocate a SCSICmd struct
		move.l	sp,cb_LinkedCmd(a3)	new scsicmd
		move.l	#512,d0
		move.l	d0,scsi_Length(sp)	identify data is 512 long
		clr.l	scsi_Actual(sp)		nothing xfered yet

		lea	hu_ATBuffer(a2),a0
		move.l	a0,cb_WData(a3)		use our fixed buffer
		move.b	#1,cb_ATLength(a3)	1 sector to xfer

		move.b	#AT_IDENTIFY_DRIVE,AT_Command(a4)	kick it off
		moveq	#1*2,d0			initial state (read data)
		bsr	HandleInts (d0)

		; restore stuff
		lea	scsi_SIZEOF(sp),sp	drop scsi command block
		move.l	(sp)+,cb_LinkedCmd(a3)	restore scsiblk ptr
		move.l	(sp)+,cb_WData(a3)	restore data ptr

	IFD CP2024_KLUDGE
		; we must recognize the CP2024 explictly.  It ignores the
		; InitializeDriveParams command, and comes up in translate
		; mode (not what it returns from identify!)
		movem.l	d0/a2/a3,-(sp)
		lea	hu_ATBuffer(a2),a0
		move.l	a2,a3			save hu ptr
		lea	27*2(a0),a2		ptr to model number
		lea	ConnerName(pc),a1
		moveq	#31,d0			strlen(ConnerName)
1$:		bsr	getswapbyte		d1:byte from (a2)+ (sort of)
		cmp.b	(a1)+,d1
		dbne	d0,1$			loop until not eq or done
		addq.w	#1,d0
		bne.s	not_cp2024

		; ick, it's a cp2024
		; force it to 615/4/17 by modifying the returned structure
		; the V2.08 CP2024 can't handle more than 16 sectors/io!!!
		move.w	#((615<<8)&$ff00)!(615>>8),1*2(a0)	byte-swapped
		move.b	#4,3*2(a0)		4 heads (high byte is 0)
		move.b	#17,6*2(a0)		17 sectors/track
; this was needed to attempt to fix (unsuccessfully) the 2.08 conner
;		move.l	#16,hu_MaxBlocks(a3)	we saved hu ptr in a3!

 printf <'Evil Conner CP2024!\n'>
not_cp2024:
		movem.l	(sp)+,d0/a2/a3
	ENDC

		; d0 = 0 for success, d0 = 2 for failure
		rts

ConnerName:	dc.b	'Conner Peripherals 20MB - CP2024'
		ds.w	0

;==============================================================================
; copy_buffer: (a1,d0) copy up to d0 bytes from a1 to cb_WData(a3)
; update scsi_Actual in scsi block, set scsi_CmdActual = scsi_CmdLength,
; clears scsi_Status.
;==============================================================================
copy_buffer:
		move.l	a1,d1			save source ptr
		move.l	cb_SCSICmd(a3),a1
		cmp.l	scsi_Length(a1),d0
		bls.s	length_bigger
		move.l	scsi_Length(a1),d0	min(18,length)
length_bigger:
		move.l	d0,scsi_Actual(a1)

		move.l	d1,a1			get ptr to ssource again
		move.l	cb_WData(a3),a0		store in data area
		bra.s 2$
1$:		move.b	(a1)+,(a0)+		copy up to d0 bytes from a1->a0
2$:		dbra	d0,1$

		rts
 

	IFD FOR_68000_ONLY
 IFD UNUSED
;==============================================================================
; gets a possibly misaligned longword from (a1), returns it in d0.  No
; other regs touched.  A1 incremented by 4!
; NOT NEEDED ON '020 up!
;==============================================================================
getlong_a1:
		move.l	a1,d0			test for misalignment
		btst.b	#0,d0			is it an odd byte?
		bne.s	1$
		move.l	(a1)+,d0		already aligned (word or lw)
		rts

1$:		move.b	(a1)+,d0		mis-aligned (byte aligned)
		swap	d0			into top half
		move.w	(a1)+,d0		therefor this must be aligned
		lsl.l	#8,d0			make room for last byte
		move.b	(a1)+,d0
		rts
 ENDC UNUSED

;==============================================================================
; puts a possibly misaligned longword from d0 into (a1)+.  Other regs
; are touched (a1 is incremented by 4, d0/d1 are destroyed, a0 untouched).
; NOT NEEDED ON '020 up!
;==============================================================================
putlong_a1:
; commented out, since we only call this for request sense, and we know it's
; non-aligned there - fix?
;		move.l	a1,d1
;		btst.b	#0,d1
;		bne.s	1$
;		move.l	d0,(a1)+		word or lw aligned
;		rts

1$:		move.b	d0,3(a1)		(low byte) byte-misaligned
		lsr.l	#8,d0
		move.w	d0,1(a1)		must be word or lw aligned
		swap	d0			get last byte into low end
		move.b	d0,(a1)
		addq.w	#4,a1			auto extends to long
		rts

	ENDC FOR_68000_ONLY

;==============================================================================
; ATSendCommand (d0.b: command)
;
; This routine starts the command and handles any interrupts that occur, and
; on completion or error cleans up the command and goes back to waiting.
;
;==============================================================================
ATSendCommand
		; send the command
	IFD DEBUG_CODE
2$:	move.b	AT_Status(A4),d1
	btst.b	#ATB_BSY,d1
	bne.s	1$
	btst.b	#ATB_RDY,d1
	bne.s	3$
1$:	and.l	#$ff,d0
	and.l	#$ff,d1
	printf <'DANGER: status $%lx before cmd $%lx\n'>,d1,d0
	bra.s	2$
3$:
	ENDC
		move.b	d0,AT_Command(a4)	start command
		bsr.s	FindInitState (d0)
		bsr.s	HandleInts (d0)		handle interrupts
;						returns d0 = 0, or d0 = 2
		bra	ATCommandDone

;==============================================================================
; FindInitState (d0.b: command)
;
; returns the initial state for HandleInts for the command in d0
;==============================================================================
FindInitState:
		; get initial state*2 from table
		lea.l	AT_InitialState(pc),a1	scan table for the command
10$		move.w	(a1)+,d1		get command and state
; never can happen: beq	ATBadCmd		sorry, we don't handle it!!!!
	IFD DEBUG_CODE
	    bne.s 1$
	    printf <'IMPOSSIBLE - couldnt find state for $%lx\n'>,d0
1$:
	ENDC
		cmp.b	d1,d0			is it this command
		bne.s	10$			nope, keep looking
		lsr.w	#8,d1			initial state (times 2)!
		move.l	d1,d0
		rts

; This is a table of initial states for different AT commands  They're
; multiplied by 2 so they can be used as an offset into the dispatch tables.

AT_InitialState:
		DC.B	1*2,AT_READ_SECTORS		read
		DC.B	1*2,AT_READ_MULTIPLE		read
		DC.B	2*2,AT_WRITE_SECTORS		write
		DC.B	2*2,AT_WRITE_MULTIPLE		write
		DC.B	1*2,AT_IDENTIFY_DRIVE		read
		DC.B	2*2,AT_FORMAT			write
		DC.B	0*2,AT_SEEK			non-data
		DC.B	0*2,AT_RECALIBRATE		non-data
		DC.B	0*2,AT_INIT_PARAMETERS		non-data
		DC.B	0*2,AT_SET_MULTIPLE_MODE	non-data
		DC.B	0*2,AT_READ_VERIFY_SECTORS	non-data
		DC.B	0*2,AT_DIAGNOSTICS		non-data
; more?
		DC.B	0,0				end
		
;==============================================================================
; HandleInts (d0: 2*state)
;
; This handles any interrupts that occur, and on completion or error returns
; to the caller.  Result is in d0, 0 for success or 2 for failure.  
;
; When an interrupt occurs from the AT drive, control is passed back to here.
; We read the status register, and use it with the current state to figure
; out what to do.  We have 4 possibilities:
; 0 - non-data command completed successfully
; 1 - a block of data is ready to be read
; 2 - the drive is ready to accept another block of data for a write
; 3 - the drive has accepted the final sector of a write.
;
; In cases 1 and 2, we go to a routine to dump or get a sector of data, then
; wait for another interrupt.  If there was an error, we read the error reg,
; set up hu_NextError for the next request sense call, and return control
; to the routine that started the transfer.
;
; In cases 1 and 3, if this is the final sector of a transfer, we then return
; control to the routine that was specified by the routine that started the
; transfer (usually a "clean up and return" routine).
;
; We have a separate table of routines if there was an error.  The error
; register is put in hu_ATError.
;==============================================================================
HandleInts:	movem.l	d2-d3,-(sp)
		move.l	d0,d2			initial state
		clr.b	d3			count of sectors since int

; IFD DEBUG_CODE
; cmp.b #2*2,d2
; bne.s 1$
; moveq #0,d0
; move.b cb_ATLength(a3),d0
; printf <'writing %ld blocks\n'>,d0
;1$
; ENDC
		; on a write, transfer a sector first before waiting!
		cmp.b	#2*2,d2			was initial state write?
		beq.s	after_wait

TransferLoop:
		tst.b	d3			should we wait for an int now?
		bne.s	after_wait		no, we're in a multiple xfer
		move.l	st_IntPendMask(a5),d0
		jsr	_LVOWait(a6)

after_wait:
		move.b	AT_Status(a4),d0
;    IFD DEBUG_CODE
;    and.l #$ff,d0
;    printf <'AT: handle int, state = %ld, status = $%lx\n'>,d2,d0
;    ENDC

	IFD WD_AT_KLUDGE
; FIX!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
; EVIL, ugly kludge for WD drives!  They return an INT immediately!
; However, the spec may require this for all drives (sec 10.2, CAM-ATA R23)

	cmp.b	#1*2,d2
	beq.s	10$
	cmp.b	#2*2,d2			don't wait if not read, or write-not-
	bne.s	20$			last-sector.
10$:
	IFD DEBUG_CODE
	and.l	#$ff,d0
	btst.b	#ATB_BSY,d0
	bne.s	1$
	btst.b	#ATB_DRQ,d0
	bne.s	2$
1$:
	; busy or ready but no drq
	printf <'Int: status $%lx, state %ld\n'>,d0,d2
2$:
	ENDC

	btst.b	#ATB_BSY,d0
	bne.s	after_wait
	ENDC

		; check _after_ wait for not BSY!
		btst.b	#ATB_ERR,d0		was there an error?
		bne.s	cmd_err			handle error on command

	IFD WD_AT_KLUDGE
	btst.b	#ATB_DRQ,d0			wait for data ready!
	beq.s	after_wait
20$:
	ENDC
		move.w	AT_Int(pc,d2.w),d0
		jmp	AT_Int(pc,d0.w)		no error

; the drive reported an error on the last operation, save sense info
; no need to save hu_ATStatus, since it just has the ERR bit.
cmd_err:
		move.b	AT_Error(a4),hu_NextError+3(a2)
	printf <'AT: error was 0x%lx, state %ld\n'>,hu_NextError(a2),d2

		move.w	AT_ErrTab(pc,d2.w),d0
		jmp	AT_ErrTab(pc,d0.w)	error

; Dispatch tables
AT_Int:		DC.W	AT_Int_NoData-AT_Int	non-data command
		DC.W	AT_Int_Read-AT_Int	read next block of data
		DC.W	AT_Int_Write-AT_Int	write next block of data
		DC.W	AT_Int_FinalWrite-AT_Int final int after write

AT_ErrTab:	DC.W	AT_Err_NoData-AT_ErrTab	    non-data command
		DC.W	AT_Err_Read-AT_ErrTab	    read next block of data
		DC.W	AT_Err_Write-AT_ErrTab	    write next block of data
		DC.W	AT_Err_FinalWrite-AT_ErrTab final int after write

;==============================================================================
; command without data completed successfully, return
;==============================================================================
AT_Int_NoData:
		; fall through...
;==============================================================================
; Final sector of a write succeeded
;==============================================================================
AT_Int_FinalWrite:
	IFD WD_AT_KLUDGE
		; wait for WD drive to finish writing for real
1$:		move.b	AT_Status(a4),d0
	   IFD DEBUG_CODE
		btst.b  #ATB_BSY,d0
		beq.s	2$
		and.l	#$ff,d0
		printf <'FinalWrite: status $%lx\n'>,d0
2$:
	   ENDC
		btst.b	#ATB_BSY,d0
		bne.s	1$
	ENDC
		moveq	#0,d0
		movem.l	(sp)+,d2-d3
		rts

;==============================================================================
; Read a sector from the AT interface, store in destination
;==============================================================================
AT_Int_Read:
		move.l	cb_WData(a3),a1		get working data ptr
		lea	AT_Data(a4),a0		source
	IFD FOR_68000_ONLY
		move.l	a1,d1			is this byte-aligned?
		btst.b	#0,d1
		bne.s	byte_read
	ENDC
		moveq	#(256/16)-1,d0		16 words at a time

; FIX!!!! for A1000+, use move.w (a0),dn, swap dn, move.w (a0),dn, ... movem...
; OR, use move.w (a0),dn, swap dn, move.w (a0),dn, move.l dn,(a1)+...
1$:		move.w	(a0),(a1)+
		move.w	(a0),(a1)+
		move.w	(a0),(a1)+
		move.w	(a0),(a1)+
		move.w	(a0),(a1)+
		move.w	(a0),(a1)+
		move.w	(a0),(a1)+
		move.w	(a0),(a1)+
		move.w	(a0),(a1)+
		move.w	(a0),(a1)+
		move.w	(a0),(a1)+
		move.w	(a0),(a1)+
		move.w	(a0),(a1)+
		move.w	(a0),(a1)+
		move.w	(a0),(a1)+
		move.w	(a0),(a1)+
		dbra	d0,1$

read_cleanup
		move.l	a1,cb_WData(a3)		put working data ptr back
		movea.l	cb_LinkedCmd(a3),a0	and corresponding SCSICmd
		add.l	#512,scsi_Actual(a0)	update count of bytes xfered

		; used to compare scsi_Length and Actual - doesn't work for
		; extended r/w.  FIX! what about scsi_Length < # of blocks in
		; scsi command?
		addq.b	#1,d3			# of sectors since int
		cmp.b	hu_MaxRWSize(a2),d3
		bcs.s	1$			branch on d3 < MaxRWSize
		moveq	#0,d3			time to wait...
1$		subq.b	#1,cb_ATLength(a3)	careful - works right for 0/256
		bne	TransferLoop		wait for next sector

;	printf <'read $%lx of $%lx bytes\n'>,scsi_Actual(a0),scsi_Length(a0)
		; done with read, return to caller with success
		moveq	#0,d0
		movem.l	(sp)+,d2-d3
		rts

	IFD FOR_68000_ONLY
byte_read:
		moveq	#(256/2)-1,d0		2 words at a time
		
1$:		move.w	(a0),d1
		swap	d1
		move.w	(a0),d1			get longword
		move.b	d1,3(a1)		low byte
		lsr.l	#8,d1
		move.w	d1,1(a1)		middle word
		swap	d1
		move.b	d1,(a1)			high byte
		addq.w	#4,a1
		dbra	d0,1$

		bra.s	read_cleanup
	ENDC

;==============================================================================
; Write a sector to the AT interface, from source.  If last sector, change
; to state 3 (final interrupt pending).
;==============================================================================
AT_Int_Write:
		move.l	cb_WData(a3),a1		get working data ptr
		lea	AT_Data(a4),a0		destination
	IFD FOR_68000_ONLY
		move.l	a1,d1			is this byte-aligned?
		btst.b	#0,d1
		bne.s	byte_write
	ENDC
		moveq	#(256/16)-1,d0		16 words at a time

; FIX!!!! for A1000+, use movem... move.w dn,(a0), swap dn, move.w dn,(a0)...
; OR, use move.l (a1)+,dn, move.w (a0),dn, swap dn, move.w (a0),dn...
1$:		move.w	(a1)+,(a0)
		move.w	(a1)+,(a0)
		move.w	(a1)+,(a0)
		move.w	(a1)+,(a0)
		move.w	(a1)+,(a0)
		move.w	(a1)+,(a0)
		move.w	(a1)+,(a0)
		move.w	(a1)+,(a0)
		move.w	(a1)+,(a0)
		move.w	(a1)+,(a0)
		move.w	(a1)+,(a0)
		move.w	(a1)+,(a0)
		move.w	(a1)+,(a0)
		move.w	(a1)+,(a0)
		move.w	(a1)+,(a0)
		move.w	(a1)+,(a0)
		dbra	d0,1$

write_cleanup:
		move.l	a1,cb_WData(a3)		put working data ptr back
		movea.l	cb_LinkedCmd(a3),a0	and corresponding SCSICmd
		add.l	#512,scsi_Actual(a0)	update count of bytes xfered

		; used to compare scsi_Length and Actual - doesn't work for
		; extended r/w.  FIX! what about scsi_Length < # of blocks in
		; scsi command?  Screw 'em.
		addq.b	#1,d3			# of sectors since int
		cmp.b	hu_MaxRWSize(a2),d3
		bcs.s	1$			branch on d3 < MaxRWSize
		moveq	#0,d3			time to wait...
1$:		subq.b	#1,cb_ATLength(a3)	careful - works right for 0/256
		bne	TransferLoop		wait for drive to be ready

;	printf <'wrote $%lx of $%lx bytes, cb_WData $%lx\n'>,scsi_Actual(a0),scsi_Length(a0),cb_WData(a3)
		; done with write, change state and wait for confirming int
		moveq	#0,d3			force it to wait for int
		moveq	#3*2,d2			state 3 - wait for final int
		bra	TransferLoop

 
	IFD FOR_68000_ONLY
byte_write:
		moveq	#(256/2)-1,d0		2 words at a time
		
1$:		move.b	(a1),d1
		swap	d1
		move.w	1(a1),d1
		lsl.l	#8,d1
		move.b	3(a1),d1
		swap	d1
		move.w	d1,(a0)			may be faster to use all bytes
		swap	d1
		move.w	d1,(a0)
		addq.w	#4,a1
		dbra	d0,1$

		bra.s	write_cleanup
	ENDC

;==============================================================================
; Write of a sector failed.  Adjust count and return an error
;==============================================================================
AT_Err_Write:
		; fall through!

;==============================================================================
; Final sector of a write failed.  Adjust count to not include it and return.
;==============================================================================
AT_Err_FinalWrite:
		move.l	cb_LinkedCmd(a3),a0	get scsi command block
		sub.l	#512,scsi_Actual(a0)	last block had an error
		; fall through!

;==============================================================================
; command without data failed, return
;==============================================================================
AT_Err_NoData:
		; fall through!

;==============================================================================
; Read of a sector failed.  return an error
;==============================================================================
AT_Err_Read:
		bsr.s	GetErrorAddr		returns check_condition
		movem.l	(sp)+,d2-d3
		rts

;==============================================================================
; get the address currently in the AT regs, and store in hu_ErrorLBA
; returns CHECK_CONDITION in d0
;==============================================================================
GetErrorAddr:
	IFD DEBUG
		moveq	#0,d0
	ENDC
		; save where error occurred
		move.b	AT_CylHigh(a4),d0
		lsl.w	#8,d0
		move.b	AT_CylLow(a4),d0
	printf <'err cyl %ld\n'>,d0
		move.w	hu_CylSize(a2),d1
		mulu	d0,d1			cyls * cylsize
		move.l	d1,-(sp)		save it
		move.b	AT_DriveHead(a4),d0
		and.w	#$000f,d0		only want the head
	printf <'err head %ld\n'>,d0
		moveq	#0,d1
		move.b	hu_TotalBlocks+1(a2),d1	sectors/track
		mulu	d0,d1			heads * sectors/head
		add.l	(sp)+,d1		+ cyls * sectors/cyl
		move.b	AT_SectorNum(a4),d0	sector number (1-N)
	printf <'err secnum %ld\n'>,d0
		subq.b	#1,d0
		add.l	d0,d1			+ sector number

	printf <'error was at block %ld\n'>,d1
		; d1 has sector of error (if any)
		move.l	d1,hu_ErrorLBA(a2)	save where the error happened
		moveq	#CHECK_CONDITION,d0	return bad status
		rts

;==============================================================================
; When a command is completed (success or error), control comes here.
; D0 has the status code (normally 0 for success, or 2 for failure).  We
; always terminate the command at this point because there should be nothing
; else to do, it either failed or it worked.  The error handling in IOTask is
; responsible for figuring out which.
;==============================================================================
ATCommandDone
;	printf <'AT: command complete, status = %ld\n'>,d0
		movea.l	cb_WStatus(a3),a1	and the status area
		move.b	d0,(a1)			save error code (0 or 2)

; used to set actual == length here.  We maintain actual during the xfer,
; so there's no need to kludge it here
		movea.l	cb_SCSICmd(a3),a1
		move.w	scsi_CmdLength(a1),scsi_CmdActual(a1)
		move.b	#UNIT_WAITING,hu_WhatNext(a2)    which queue next
		bra	FakeDisconnect		disconnect and reply IORequest


; make external entry points have the same names as the A590/XT driver
XTSelect	EQU	ATSelect
XTSendCommand	EQU	ATSendCommand
XTCommandDone	EQU	ATCommandDone


	ENDC IS_IDE
		END
@


1.23
log
@Cleaned up IDE code for second drive handling.  Clear battmem bit
if we can't find the disk in 30 seconds.
@
text
@d40 4
d88 2
a89 2
		movea.l	cb_WCommand(a3),a1	fetch the scsi command
		move.b	(a1),d0			and the command byte
d655 1
a655 1
	printf <'AT: check drive\n'>
d692 1
a692 1
		beq.s	no_hw			yes, exit
d772 4
a775 2
		moveq	#9,d0			worst drive is seagate 9051
	IFD IS_A1000
d778 4
a781 1
		tst.b	st_SelTimeout(a5)	do we know there's a 2nd drive?
d783 12
a794 1
		moveq	#30,d0			IDE spec says 30 seconds MAX.
d829 5
d842 1
d887 1
d898 1
d956 2
d969 1
a969 1

d1149 8
d1328 1
d1373 1
d1375 1
@


1.22
log
@Added code for CDTV and A1000 to set bookmark and battmem to indicate
whether drives or drive 1 are attached (respectively).
Bookmark is EVIL and broken.
@
text
@d378 1
a378 1
	printf <'AT: r/w/s offset = %ld\n'>,d0
d769 3
a771 2
	IFND IS_A300
	IFND IS_CDTVCR
a775 1
	ENDC
d809 3
a811 2
	IFND IS_A300
	IFND IS_CDTVCR
d814 1
d817 1
a817 2
	ENDC
	ENDC
d868 1
d928 11
d945 2
a946 1
; set the battmem BATTMEM_SCSI_TIMEOUT bit
d948 1
d950 1
a950 1
		move.l	a6,-(sp)
d957 1
a957 2
		move.l	#-1,-(sp)		put -1.L on stack
		move.l	sp,a0			addr of bits (top byte)
d961 2
a962 3

		addq.w	#4,sp			drop -1
BattMemDone	move.l	(sp)+,a6
@


1.21
log
@made removable ide drives instead of tapes by default
@
text
@d18 4
d37 2
d92 4
a95 4
	IFD DEBUG_CODE
	and.l	#$ff,d0
	printf <'In ATSelect, command = %lx, a4 = $%lx\n'>,d0,a4
	ENDC
d607 4
a610 4
	IFD DEBUG_CODE
	and.l	#$ff,d1
	printf <'Request for unimplemented page $%lx\n'>,d1
	ENDC
d704 73
a776 2
		; the number of seconds to look for a "possible" drive
		move.b	#9,(sp)		value on stack is byte in LW.
d790 1
a790 1
		beq.s	no_hw			both - not possible
d792 1
a792 1
		bpl.s	hw_not_busy
d803 1
a803 1
		; FIX???  should wait until busy goes away (or X seconds?)
d805 1
a805 1
		bra.s	hw_exit			need to drop value off stack
d809 5
a813 1
		btst.b	#DHB_SLAVE,3(sp)
d815 2
a816 1

d818 1
a818 1
		subq.b	#1,(sp)
d824 46
a869 1
		moveq	#1,d0			looks like a drive....
d882 1
a882 1
		beq.s	hw_found		writable - probably real
d885 42
d930 27
@


1.20
log
@Turned off low-level format, saved 220 bytes.
We hadn't been using it anyways.  Fixed a bug so it should work if we
ever decide to turn it on.
@
text
@d965 1
d971 3
a973 1
10$		btst.b	#7,1(a0)		high word second
@


1.19
log
@On a status of 0 at reset, wait up to 10 seconds until we get something
other than 0.  Only do this for drive 0.
@
text
@d1138 6
d1161 1
a1161 1
		move.b	hu_TotalBlocks+1(a2),d7	number of heads
d1169 1
a1169 2
		; irrelevant, but we'll put it in reverse order.
		; it had better not have more than 128 sectors!
d1171 3
a1173 2
		move.b	d7,d0			number of sectors/track
sec_loop:	move.b	d0,(a1)+
d1175 1
a1175 1
		subq.b	#1,d0
d1217 1
@


1.18
log
@Changed the sizes of hu_TotalXxxx fields for future use with GetDriveGeom.
Modified a few debugs
@
text
@d646 2
a684 1
		move.l	d0,-(sp)		save drive #
a691 1
		move.l	(sp)+,d0		restore drive #
d698 5
a702 2
		; Select the drive we wish to play with
		move.b	d0,AT_DriveHead(a4)	head irrelevant
d711 1
a711 1
		beq.s	no_hw			neither - not possible
d728 6
a733 1
		rts
d735 6
d743 1
a743 1
		rts
d759 1
d788 1
@


1.17
log
@CDTV changes (don't look for gayle)
@
text
@d86 4
a89 4
;	IFD DEBUG_CODE
;	and.l	#$ff,d0
;	printf <'In ATSelect, command = %lx, a4 = $%lx\n'>,d0,a4
;	ENDC
d221 1
a221 1
		cmp.b	hu_TotalBlocks(a2),d0	careful, sectors are 1-N!
d313 1
a313 1
		cmp.w	hu_TotalCyls(a2),d0	is it out of range?
d321 1
a321 1
		move.b	hu_TotalBlocks(a2),d1	get number of sectors/head
d372 1
a372 1
;	printf <'AT: r/w/s offset = %ld\n'>,d0
d601 4
a604 4
;	IFD DEBUG_CODE
;	and.l	#$ff,d1
;	printf <'Request for unimplemented page $%lx\n'>,d1
;	ENDC
d896 1
a896 1
	printf <'restricting max R/W to 16 from $%lx\n'>,d0
d919 1
a919 1
		move.w	d0,hu_TotalCyls(a2)
d925 1
a925 1
		move.b	d1,hu_TotalBlocks(a2)	sectors, low byte first
d932 1
a932 1
	move.w	hu_TotalCyls(a2),d0
d937 1
a937 1
	move.b	hu_TotalBlocks(a2),d0
d1136 1
a1136 1
		move.w	hu_TotalCyls(a2),d4	number of cyls
d1139 1
a1139 1
		move.b	hu_TotalBlocks(a2),d7	number of heads
d1208 1
a1208 1
		move.b	hu_TotalBlocks(a2),d0	actually sectors/track
d1211 1
a1211 1
		move.w	hu_TotalCyls(a2),d1	cyls
d1815 1
a1815 1
		move.b	hu_TotalBlocks(a2),d1	sectors/track
@


1.16
log
@Added A300 conditionals so we can build other IDE controllers
@
text
@d645 1
a646 1
	printf <'AT: check drive\n'>
d714 1
a714 1
;	printf <'not ready, busy\n'>
d727 2
a728 1
hw_found:	moveq	#1,d0			looks like a drive....
d733 1
a733 1
;	printf <'ready, not busy\n'>
d743 2
a744 1
no_hw:		moveq	#0,d0			no hardware out there
@


1.15
log
@Fix bug in format.  I misread the spec, and didn't think I had to
pass entries for good sectors.

@
text
@d630 1
d642 1
d645 1
d696 1
d705 1
a705 1
		move.b	AT_AltStatus(a4),d0
d808 2
a809 1
1$		btst.b	#ATB_BSY,AT_AltStatus(a4)
@


1.14
log
@Removed conner 2.08 kludge (doesn't fix all the 2.08 problems)
@
text
@d1137 11
@


1.13
log
@debug modifications
@
text
@d1313 3
a1315 1
		move.l	#16,hu_MaxBlocks(a3)	we saved hu ptr in a3!
@


1.12
log
@Darn.  Missed reg pop
@
text
@d193 1
a193 1
	printf <'longxfer of $%lx blocks\n'>,d2
d263 1
a263 1
	printf <'AT: extended r/w offset = %ld\n'>,d0
d293 4
a296 4
	IFD DEBUG_CODE
	andi.l	#$ffff,d1
	printf <'ext length %ld, cmd = $%lx\n'>,d1,d0
	ENDC
d372 1
a372 1
	printf <'AT: r/w/s offset = %ld\n'>,d0
d392 5
a396 5
	IFD DEBUG_CODE
	moveq	#0,d1
	move.b	d0,d1
	printf <'rw length = %ld blocks\n'>,d1
	ENDC
d1314 1
d1721 1
a1721 1
	printf <'wrote $%lx of $%lx bytes, cb_WData $%lx\n'>,scsi_Actual(a0),scsi_Length(a0),cb_WData(a3)
@


1.11
log
@Added another conner kludge(!!!) for version 2.08 of the CP2024.
@
text
@d1315 1
a1315 1
		movem.l	(sp)+,d0/a2
@


1.10
log
@Oops.  I trashed my custom ptr.
@
text
@d372 1
a372 1
;	printf <'AT: r/w/s offset = %ld\n'>,d0
d392 5
a396 5
;	IFD DEBUG_CODE
;	moveq	#0,d1
;	move.b	d0,d1
;	printf <'length = %ld blocks\n'>,d1
;	ENDC
d1295 1
a1295 1
		movem.l	d0/a2,-(sp)
d1297 1
d1309 1
d1313 1
@


1.9
log
@Added mirroring test and GAYLE id test.
@
text
@d655 1
d658 1
a658 1
		DISABLE	a0			; leaves a0 = execbase
d673 2
a674 1
		ENABLE	a0,NOFETCH
@


1.8
log
@Fixed >256 block r/w (LongXfer).  The ide drives leave the address pointing
at the _last_ sector read, not the one following it, so I have to bump
the sector by one before issuing the next command.  Ick.

@
text
@d15 2
d32 1
d206 1
a206 1
	printf <'xfering $%lx blocks, $%lx left, cmd = $%lx\n'>,d0,d2,d3
d636 6
d652 37
a688 1
; FIX!!!! ????
d690 2
d708 1
a708 1
	printf <'not ready, busy\n'>
d726 1
a726 1
	printf <'ready, not busy\n'>
a849 7
		; Sending an Init Param to a WD 2120 causes it to reject ALL
		; transfers of more than one block!!!  So we removed this
		; entirely.  It didn't help the CP2024 anyways.

		; Then Randy Hilton said we _must_ use it no matter what, so
		; I put it back in, even though no drive seems to need it.

d1297 1
a1297 1
		moveq	#22,d0			strlen(ConnerName)
a1303 4
		; I _think_ that only version 2.25 has the problem??  FIX!!!!
; FIX!!		cmp.l	#'.252',23*2(a0)	check the rev against 2.25
;		bne.s	not_cp2024

d1307 2
a1308 4
		moveq	#4,d0
		move.b	d0,3*2(a0)		4 heads (high byte is 0)
		moveq	#17,d0
		move.b	d0,6*2(a0)		17 sectors/track
d1316 1
a1316 1
ConnerName:	dc.b	'Conner Peripherals 20MB'
d1370 7
a1376 5
		move.l	a1,d1
		btst.b	#0,d1
		bne.s	1$
		move.l	d0,(a1)+		word or lw aligned
		rts
@


1.7
log
@Got branch backwards when doing performance tuning.  Hope the tuning
was really valid - it was, the bgt was allowing the code to execute
because of the second error - using a signed branch instead of unsigned.
@
text
@d183 1
a183 1
; LongXfer (d0: command, d1: length (sectors))  Transfers a bunch of sectors
d187 1
a187 1
		movem.l	d0/d2,-(sp)		save command and save reg
d189 2
d198 3
a200 3
1$:		move.b	d2,d0			remainder (< 256)
		beq.s	xfer_done
		moveq	#0,d2			nothing left now
d203 1
a203 6
		move.b	d0,cb_ATLength(a3)
		move.b	3(sp),d0		command was saved on stack!!
;	IFD DEBUG_CODE
;	andi.l #$ff,d0
;	printf <'reading $%lx blocks, $%lx left, cmd = $%lx\n'>,cb_ATLength(a3),d2,d0
;	ENDC
d205 3
a207 1
		move.b	d0,AT_Command(a4)	start cmd
d211 16
a226 1
		beq.s	xfer_loop
d228 14
a241 3
		; error if we fall through (d0 = 2), d0 = 0 if we jump here
		bsr	GetErrorAddr		save address of error
		moveq	#CHECK_CONDITION,d0	restore error value
d243 1
a243 1
xfer_done:	movem.l	(sp)+,d1/d2		TRICKY! don't nuke d0!
d260 1
a260 1
;	printf <'AT: extended r/w offset = %ld\n'>,d0
d290 4
a293 6
;	IFD DEBUG_CODE
;	swap d1
;	clr.w d1
;	swap d1
;	printf <'ext length %ld, cmd = $%lx\n'>,d1,d0
;	ENDC
d338 1
d460 1
a460 1
		moveq	#0,d0			non-data command
d548 9
a556 9
	IFD DEBUG_CODE
	moveq	#0,d0
	move.w	20(a1),d0
	printf <'page 3: config bits: $%lx\n'>,d0
	move.w	2(a1),d0
	printf <'cylinders: $%lx\n'>,d0
	move.w	10(a1),d0
	printf <'sectors/track: $%lx\n'>,d0
	ENDC
d575 4
a578 4
	IFD DEBUG_CODE
	move.b	5(a1),d0
	printf <'page 4: heads: $%lx\n'>,d0
	ENDC
d598 4
a601 4
	IFD DEBUG_CODE
	and.l	#$ff,d1
	printf <'Request for unimplemented page $%lx\n'>,d1
	ENDC
d1389 5
d1415 3
a1417 2
; fix		...
		DC.B	0,0
d1636 1
a1636 1
		lea	AT_Data(a4),a0		destionation
d1679 1
a1679 1
;	printf <'wrote $%lx of $%lx bytes\n'>,scsi_Actual(a0),scsi_Length(a0)
d1729 1
a1729 3
		bsr.s	GetErrorAddr

		moveq	#CHECK_CONDITION,d0	return bad status
d1735 1
d1764 1
d1775 1
a1775 1
	printf <'AT: command complete, status = %ld\n'>,d0
@


1.6
log
@Oops, masked off all but the bits I wanted in FindHardware
@
text
@d822 1
a822 1
		bgt.s 1$
@


1.5
log
@Fixed hardware-detection test (handles BUSY right now).
bra -> bra.s
@
text
@d630 1
a630 1
		and.b	#$3f,d0			leave BSY and RDY
@


1.4
log
@Removed TimedOut - never called
Added CP2024 kludge
Re-added the InitializeDriveParams stuff - kills WD 2120
Added the enable-interrupts register store for the PrairieTek
Split off a bunch of ATCheckDrive for use from init.asm to see if it should
start up the tasks.
modified some debug code
@
text
@d238 1
a238 1
		bsr	ATSetAddress (d0)	set drive/cyl/head/sector
d250 1
a250 1
		beq	NoExtTransfer		it is, so no transfer needed
d494 1
a494 1
		bne	not_page_3
d510 1
a510 1
		bsr	getATword (a0,d0)
d515 1
a515 1
		bsr	getATword (a0,d0)	config info
d543 1
a543 1
		bsr	bzero (a1,d0)		zero out buffer-no regs changed
d613 1
a613 1
		; hardware registers mirror every $xxx, starting at $dff000.
d617 2
d631 1
a631 1
		beq	no_hw			neither - not possible
d633 1
a633 1
		beq	no_hw			both - not possible
d644 1
a644 1
		bne	no_hw			didn't read status!!!!
d647 2
d683 1
a683 1
		bsr.s	ATFindHardware		Make sure this drive is there
d685 4
d690 4
@


1.3
log
@Fixed include file issues (use include: files instead of private ones)
@
text
@d26 1
a26 1
		XDEF	XTSelect,XTSendCommand,XTCommandDone
d604 4
a607 3
; ATCheckDrive - check if an AT drive exists.  Timeout after a while if it
; doesn't respond.  Sets hu_Found to non-zero for success.  Returns 0 for
; success, 2 or 8 for failure or busy.
d609 1
a609 1
ATCheckDrive:
d615 3
a617 1
; FIX!!!!!!!!
d620 1
a620 1
		move.b	hu_ATDriveBit(a2),AT_DriveHead(a4)	head irrelevant
d629 1
a629 1
		beq	check_failed		neither - not possible
d631 1
a631 1
		beq	check_failed		both - not possible
d633 1
a633 1
		bpl.s	not_busy
d642 3
a644 1
		bne	check_failed		didn't read status!!!!
d646 1
a646 3
	printf <'returning busy\n'>
		; busy - return BUSY status ($08) - lib.asm will keep trying
		moveq	#BUSY,d0		leave hu_Found alone
d650 1
a650 1
not_busy:
d655 1
a655 1
		bne.s	check_failed
d659 17
a675 1
		bne.s	check_failed
d677 4
a680 3
	printf <'writable\n'>
		; ok, it's writable.  It's almost certainly there.
		; do a recalibrate with timeout
d682 11
a692 2
		; clear signal
		moveq	#0,d0
d766 8
d795 1
d803 11
d1213 30
d1246 3
d1448 2
a1449 2
1$: ;	move.w	#10,d1
5$
a1450 10
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
;	dbra	d1,5$
d1502 7
d1733 1
a1733 1
;	printf <'AT: command complete, status = %ld\n'>,d0
a1742 11

;==============================================================================
; TimedOut()
;
; There must be a unit in the RunningUnit slot for this to work.  If a command
; times out (no response to the command accept) then control can be passed to
; here which will mark the unit as timed out and will call FakeDisconnect.
;==============================================================================
TimedOut	printf <'AT: Timed out on cmd\n'>
		move.b	#UNIT_TIMED_OUT,hu_WhatNext(a2)
		bra	FakeDisconnect
@


1.2
log
@First major checkin.
It works (at least very close to done).
It bears little resemblance to the XT task code.
It has a compliant (or very close to) scsi-2 implementation.
@
text
@a9 1
		INCLUDE	"modifiers.i"
d15 3
a20 1
		INCLUDE	"scsidirect.i"
@


1.1
log
@Initial revision
@
text
@d3 3
a5 3
; This code is for handling XT drives in the SCSITask environment.  It is not
; a separate task in its own right.  All XT drives are sent SCSI command blocks
; which are interpreted here and sent to the drive hardware as XT commands.
d7 1
a7 1
	IFD XT_SUPPORTED
d25 1
a25 1
		XDEF	XTSelect,XTSendCommand,XTAddressBad,XTCommandDone
d27 2
a28 1
		XREF	FakeSelect,FakeDisconnect,FakeTimeout
d31 24
a56 3
; Read, write and seek commands use the address translation feature of the WDC
; since we have one on the board anyway.  These will re-enter in this module
; at XTSendCommand when the WDC interrupts us to say it has done translation.
d61 1
a61 1
; scsi_CmdActual will always be set equal to scsi_CmdLength.  XT units will
d63 1
a63 1
; fortunately for me, I can use the 4 bytes returned by an XT drive.  The
d72 1
a72 7
XTSelect	move.b	XTPORT0(a4),d0		all $ff means nothing connected
		and.b	XTPORT1(a4),d0
		and.b	XTPORT2(a4),d0
		and.b	XTPORT3(a4),d0
		cmpi.b	#$ff,d0
		beq	FakeTimeout		yup, fake a timout condition

d74 1
a74 4
		movea.l	st_RunningUnit(a5),a0	fetch unit pointer
		movea.l	hu_CurrentCmd(a0),a0	command block to a0
		clr.b	cb_ErrorCode(a0)	assume we will get no errors
		movea.l	cb_WCommand(a0),a1	fetch the scsi command
d76 13
a88 3
		lea.l	XTD(pc),a1		scan table for the code
10$		move.l	(a1)+,d1		get offset and command
		beq.s	XTBadCmd		sorry, we don't handle it
d91 7
d99 1
d104 1
a104 1
XTBadCmd:
d107 4
a110 5
	printf <'XT: unknown command\n'>
	movea.l	cb_WCommand(a0),a1
	printf <'Cmd = 0x%lx'>,(a1)+
	move.w	(a1)+,d0
	printf <'%x\n'>,d0
d113 2
a114 1
		movea.l	cb_SCSICmd(a0),a1	fetch scsi command
d116 5
a120 9
		move.w	scsi_CmdLength(a1),scsi_CmdActual(a1)
		move.b	#$02,scsi_Status(a1)	Check Condition
		clr.b	cb_ErrorCode(a0)	*** must change this ***

		movea.l	st_RunningUnit(a5),a0	get unit pointer back
		move.b	#UNIT_WAITING,hu_WhatNext(a0)   back on waiting queue
		move.l	#$20000000,hu_NextError(a0) error, illegal command
;	printf <'XT: calling FakeDisconnect\n'>
		bra	FakeDisconnect		and disconnect this unit
d128 51
a178 7
XTD		DC.W	XT_READ-XTD,READ
		DC.W	XT_WRITE-XTD,WRITE
		DC.W	XT_TUR-XTD,TEST_UNIT_READY
		DC.W	XT_RQS-XTD,REQUEST_SENSE
		DC.W	XT_FMT-XTD,FORMAT_UNIT
		DC.W	XT_SEEK-XTD,SEEK
		DC.W	XT_RDC-XTD,READ_CAPACITY
d182 148
d332 5
a336 3
; We'll be called again later when the WDC interrupt comes in (good or bad)
; There is no need to use the PUTREG and GETREG macros (used in scsitask)
; because there is no SCSI interrupt activity occuring at this time.
d340 261
a600 104
XT_SEEK		movea.l	st_RunningUnit(a5),a1	fetch the active unit
		move.b	#TOTAL_SECTORS,SASR(a4)	fill in geometry info
		move.b	hu_TotalBlocks(a1),SCMD(a4)  sectors per track
		move.b	hu_TotalHeads(a1),SCMD(a4)   tracks per cylinder
		move.b	hu_TotalCyls(a1),SCMD(a4)    total cylinders
		move.b	hu_TotalCyls+1(a1),SCMD(a4)
		movea.l	cb_WCommand(a0),a1	fetch the logical offset
;	IFD DEBUG_CODE
;	move.l	(a1),d0
;	andi.l	#$00ffffff,d0
;	printf <'XT: r/w offset = %ld\n'>,d0
;	ENDC
		move.b	#0,SCMD(a4)		msb of offset is always 0
		move.b	1(a1),SCMD(a4)		stash block offset
		move.b	2(a1),SCMD(a4)
		move.b	3(a1),SCMD(a4)
		move.b	#0,SCMD(a4)		don't care about sector number
		move.b	#0,SCMD(a4)		don't need to allow for spares
		move.b	#COMMAND,SASR(a4)	select command register
		move.b	#wd_TRANSLATE_ADDRESS,SCMD(a4)  issue translate cmd
		rts				will come back later

; this is called when we used the address translation feature of the WDC to
; convert a block offset to cylinder, head, sector values.  Only used for
; read, write and seek operations.
;******************************************************************************
; SMALL BUG HERE, DMA CRASHES HORRIBLY IF XT IS NOT SET TO DMA MODE BEFORE
; ACTUALLY STARTING THE DMA PROCESS.  ALSO A BIG BUG HERE!  IF TERMINAL COUNT
; IS NOT ENABLED, THE DMA CHIP KEEPS GOING (AND SPLATTERS MEMORY) WHEN THE XT
; HAS ACTUALLY FINISHED TRANSFERRING DATA.  DONT KNOW ABOUT WRITE DIRECTION!
; THIS HAPPENS EVEN IF THE XTEOP BIT HAS BEEN ENABLED IN THE CONTROL REGISTER
;******************************************************************************
XTSendCommand	movea.l	st_RunningUnit(a5),a0
		movea.l	hu_CurrentCmd(a0),a0

		move.b	#2,XTPORT3(a4)		only interrupts enabled
		movea.l	cb_WCommand(a0),a1	see if this was a seek
		cmpi.b	#SEEK,(a1)
		beq	NoDMAHere		it is, so no DMA needed

		move.b	#3,XTPORT3(a4)		interrupt enable + dma reqests
		move.b	#DMAF_INTENA!DMAF_TCE!DMAF_XTEOP,d0	assume we're reading
		move.b	#1,cb_DidReadDMA(a0)
		movea.l	cb_WCommand(a0),a1	was this a read or write ?
		cmpi.b	#READ,(a1)
		beq.s	10$			correct, it was a read
		move.b	#DMAF_INTENA!DMAF_DDIR!DMAF_TCE!DMAF_XTEOP,d0  nope, was write
		clr.b	cb_DidReadDMA(a0)	didn't do a read
10$		move.b	d0,CNTR(a4)		set up DMA data direction

		moveq.l	#0,d0			need to make word xfer count
		move.b	4(a1),d0		get block count
		bne.s	20$			0 = 256 blocks for XT drives
		move.w	#256,d0			so fudge it here
20$		lsl.l	#8,d0			this make word count (not byte)
		move.l	d0,WTCH(a4)

		move.l	cb_WData(a0),SACH(a4)	set data source/dest address
		move.b	#1,st_DMAGoing(a5)	flag that DMA is running
		move.w	#0,SDMA(a4)		and start DMA

; the DMA chip is now waiting for something to happen, send command to drive
NoDMAHere	subq.l	#6,sp			command block on stack
		move.b	(a1),(sp)		the read/write command code
		move.b	#SECTOR_NUM,SASR(a4)	get results from translation
		move.b	SCMD(a4),d0		save sector # for a while
		move.b	SCMD(a4),1(sp)		save the head number
		move.b	SCMD(a4),d1		msb of cylinder number...
		lsl.b	#6,d1			...goes to upper 2 bits...
		or.b	d1,d0			...and is merged with sector
		move.b	d0,2(sp)
		move.b	SCMD(a4),3(sp)		cylinder # lsb
		move.b	4(a1),4(sp)		number of blocks to transfer
		clr.b	5(sp)			no special flags

	IFD DEBUG_CODE
	moveq.l	#0,d0
	move.b	2(sp),d0
	andi.b	#$3f,d0
	printf <'Sector   %d\n'>,d0

	moveq.l	#0,d0
	move.b	1(sp),d0
	andi.b	#$1f,d0
	printf <'Head     %d\n'>,d0

	moveq.l	#0,d0
	move.b	2(sp),d0
	andi.b	#$c0,d0
	lsl.l	#2,d0
	move.b	3(sp),d0
	printf <'Cylinder %d\n'>,d0

	moveq.l	#0,d0
	move.b	4(sp),d0
	printf <'Count    %d\n'>,d0
	ENDC

		movea.l	sp,a0
		bsr	SendXTCmd		send this command
		addq.l	#6,sp			reclaim stack space
		tst.l	d0			did this work
		beq	TimedOut		nope, make like a timeout
		rts				yes, XTCommandDone handles it
d603 3
a605 3
; Comes here if we get an interrupt from the WDC to say that the block offset
; we were translating exceeded the disk boundaries.  We just fake up the error
; codes for an illegal address and quit this command now.
d607 84
a690 12
XTAddressBad	movea.l	st_RunningUnit(a5),a0	fetch the unit pointer
		move.b	#UNIT_WAITING,hu_WhatNext(a0) maybe put back on waiting
		movea.l	hu_CurrentCmd(a0),a1	fetch the command block
		movea.l	cb_WStatus(a1),a1	and the status area pointer
		move.b	#$02,(a1)		set up a check condition code
		movea.l	hu_CurrentCmd(a0),a1	fetch command block again
		movea.l	cb_WCommand(a1),a1	fetch block offset from cmd
		move.l	(a1),d0
		andi.l	#$ffffff,d0		only 3 bytes significant
		ori.l	#$a1000000,d0		address valid + illegal address
		move.l	d0,hu_NextError(a0)	stash error for later
		bra	FakeDisconnect		disconnect and reply
d692 12
d706 3
a708 1
; Does the equivalent of SCSI's test unit ready, sets sense codes accordingly.
d710 180
a889 8
XT_TUR		move.b	#2,XTPORT3(a4)		only interrupts enabled
		clr.l	-(sp)
		clr.w	-(sp)			test drive ready command
		movea.l	sp,a0
		bsr	SendXTCmd		send command to the drive
		addq.l	#6,sp
		tst.l	d0
		beq	TimedOut
d896 1
d898 80
a977 11
XT_RQS		movea.l	st_RunningUnit(a5),a1	fetch the sense data from unit
		move.b	#UNIT_WAITING,hu_WhatNext(a1)  where to go next
		move.l	hu_NextError(a1),d0
	printf <'XT: error = 0x%lx\n'>,d0
		movea.l	cb_WData(a0),a1		store in data area
		move.l	d0,(a1)
		movea.l	cb_SCSICmd(a0),a1	set up actual
		move.l	#$04,scsi_Actual(a1)	we only supply 4 bytes of sense
		move.w	scsi_CmdLength(a1),scsi_CmdActual(a1)
		clr.b	scsi_Status(a1)		no error
		bra	FakeDisconnect		disconnect and reply
d979 2
d983 72
d1056 219
a1274 10
XT_FMT		move.b	#2,XTPORT3(a4)		only interrupts enabled
	printf <'XT: sending a format command\n'>
		move.l	#$00000400,-(sp)		4:1 interleave
		move.w	#$0400,-(sp)		format drive command
		movea.l	sp,a0
		bsr	SendXTCmd		send command to the drive
		addq.l	#6,sp
		tst.l	d0
		beq	TimedOut
		rts
d1276 2
d1279 15
d1295 24
a1318 1
; Does the equivalent of a read capacity command (only support 20 and 40 megs)
d1320 115
a1434 13
XT_RDC:
	printf <'Read capacity called\n'>
		movea.l	cb_WData(a0),a1		get data area
		move.l	#512,4(a1)		always 512 byte blocks
		move.l	#41615,d0		total blocks on 20 meg drive
		btst.b	#1,XTPORT2(a4)		test the 40/20 flag
		bne.s	10$			it was 20Meg
		lsl.l	#1,d0			it's 40Meg
10$		move.l	d0,(a1)
		movea.l	cb_SCSICmd(a0),a1	fill in fields in scsiCmd
		move.l	#8,scsi_Actual(a1)
		move.w	scsi_CmdLength(a1),scsi_CmdActual(a1)
		clr.b	scsi_Status(a1)
a1435 30
; This is a horrible kluge I had to add for Western Digital XT drives.  It
; appears that these drives will not function correctly if the parameters
; for drive geometry have not been set yet.  We'll do this whenever we get
; a read capacity command.  (Everything will be hard coded here).
		move.b	#0,XTPORT3(a4)		nothing enabled
		clr.l	-(sp)
		move.w	#$0c00,-(sp)		construct the command
		movea.l	sp,a0
		bsr	SendXTCmd		and send it
		addq.l	#6,sp
		tst.l	d0			did it work
		beq	TimedOut		nope
	printf <'Sending drive parameters\n'>

; I'm just going to wait for a data request now and send it immediately
		clr.l	-(sp)
		clr.l	-(sp)
		movea.l	st_RunningUnit(a5),a0	need unit parameters
		move.w	hu_TotalCyls(a0),(sp)	number of cylinders
		move.b	hu_TotalHeads(a0),2(sp)	number of heads
		moveq.l	#7,d0			sending 8 bytes of data
		movea.l	sp,a0
30$		btst.b	#0,XTPORT1(a4)		wait for data request
		beq.s	30$
		move.b	(a0)+,XTPORT0(a4)	and send a byte
		dbra	d0,30$
	printf <'Sent %lx %lx\n'>
		addq.l	#8,sp			free up stack space
; drop through to complete the command

d1437 1
a1437 7
; When an interrupt occurs from the XT drive, control is passed back to here.
; We must always read the status byte to clear the current command.  If there
; was an error (2) then we'll also issue a "read status" command and stash the
; results into hu_NextError ready to be picked up by a request sense call.  We
; always terminate the command at this point because there should be nothing
; else to do, it either failed or it worked.  The error handling in IOTask is
; responsible for figuring out which.
d1439 44
a1482 30
XTCommandDone	movea.l	st_RunningUnit(a5),a0
	printf <'XT: command complete\n'>
		clr.l	hu_NextError(a0)	assume no errors
		movea.l	hu_CurrentCmd(a0),a1	fetch the command block ptr
		movea.l	cb_WStatus(a1),a1	and the status area
10$		btst.b	#0,XTPORT1(a4)		wait for status byte ready
		beq.s	10$
		move.b	XTPORT0(a4),(a1)	save error code (0 or 2)
		beq	XTNoErrors		no error occured

; the drive reported an error on the last operation, read sense data from drive
	printf <'XT: got an error on last cmd\n'>
		clr.l	-(sp)			read status command on stack
		move.w	#$0300,-(sp)
		movea.l	sp,a0
		bsr	SendXTCmd		issue command to drive
		addq.l	#6,sp
******************
		tst.l	d0			did it work
		beq	TimedOut		no, timed out

; we've issued the command, now read back 4 bytes of sense info from the drive
		movea.l	st_RunningUnit(a5),a0	refetch the unit pointer
		lea.l	hu_NextError(a0),a1	point to sense data area
		moveq.l	#3,d0			fetching 4 bytes of info
20$		btst.b	#0,XTPORT1(a4)		wait for data ready
		beq.s	20$
		move.b	XTPORT0(a4),(a1)+	stash data byte
		dbra	d0,20$			and go for the next
	printf <'XT: error was 0x%lx\n'>,hu_NextError(a0)
d1484 3
a1486 32
; we have to read a status byte after this command too, but we'll junk it
30$		btst.b	#0,XTPORT1(a4)		wait for data ready
		beq.s	30$
		move.b	XTPORT0(a4),d0		just waste this byte

; if the error code is negative then the address in the sense data is valid
; but needs conversion from heads/cyls etc. to a block offset.  I have to do
; this with the CPU because the WDC doesn't provide translation this way.
		tst.b	hu_NextError(a0)	is address valid ?
		bpl.s	XTNoErrors		nope, so don't translate

		movem.l	d2-d3,-(sp)
		moveq.l	#0,d0
		moveq.l	#0,d1
		moveq.l	#0,d3
		move.b	hu_NextError+1(a0),d0	get head number
		move.b	hu_NextError+2(a0),d1	get sector number
		move.l	d1,d2			d2 holds msb of cylinder
		andi.b	#$3f,d1			mask off cyl msb's
		lsl.l	#2,d2
		move.b	hu_NextError+3(a0),d2	fetch rest of cyl number
		move.b	hu_TotalHeads(a0),d3
		mulu.w	d3,d2
		move.b	hu_TotalBlocks(a0),d3
		mulu.w	d3,d2			d2 = cylinder to block offset
		mulu.w	d3,d0			convert head to block offset
		add.l	d0,d2			add to total so far
		add.l	d1,d2			and add sector number
		move.l	hu_NextError(a0),d0	get back the error code
		andi.l	#$ff000000,d0		mask off track sector head stuff
		or.l	d2,d0			merge in block offset
		move.l	d0,hu_NextError(a0)	and store it back
d1488 120
d1609 3
a1611 7
; either there were no errors or there was an error and we handled it.
XTNoErrors	movea.l	hu_CurrentCmd(a0),a1	fetch the command block
		movea.l	cb_SCSICmd(a1),a1
		move.l	scsi_Length(a1),scsi_Actual(a1)  make like it all worked
		move.w	scsi_CmdLength(a1),scsi_CmdActual(a1)
		move.b	#UNIT_WAITING,hu_WhatNext(a0)    which queue next
		bra	FakeDisconnect		disconnect and reply IORequest
d1614 29
a1642 33
; success = SendXTCmd( command )
;   d0			  a0
;
; Sends 6 bytes of command block to XT unit 0.  DMA and IRQ bits must have been
; set up appropriately before calling this routine (includes starting DMA chip)
; A return of TRUE means everything worked.  A FALSE return should be taken to
; mean that a timeout occured and the unit probably isn't even connected.
;==============================================================================
SendXTCmd:
	IFD DEBUG_CODE
	move.w	4(a0),d0
	printf <'XT: sending cmd %lx%x\n'>,(a0),d0
	ENDC

; Epson drives don't respond to command accept after an error occurs.  They
; seem to need some arbitrarily long time to recover.  Constant banging on
; the command accept register fixed the problem but stopped Western Digital
; drives from working at all.  I've had to do this compromise timeout code!
		moveq.l	#20,d1			fix for Epson drives
EpsonTO		move.b	#0,XTPORT2(a4)		start command accept
		moveq.l	#-1,d0			timeout value
Timeout		btst.b	#0,XTPORT1(a4)		wait for data request
		bne.s	SendCmd			got one
		dbra	d0,Timeout		not yet, keep looking
		dbra	d1,EpsonTO
		moveq.l	#0,d0			return false
		rts				unit timed out

SendCmd		moveq.l	#5,d0			sending 6 bytes
10$		btst.b	#0,XTPORT1(a4)		wait for data request
		beq.s	10$
		move.b	(a0)+,XTPORT0(a4)	send next byte of command
		dbra	d0,10$			d0 will be TRUE on exit
d1645 18
d1671 2
a1672 3
TimedOut	printf <'XT: Timed out on cmd\n'>
		movea.l	st_RunningUnit(a5),a0	fetch unit
		move.b	#UNIT_TIMED_OUT,hu_WhatNext(a0)
d1675 8
a1682 1
	ENDC XT_SUPPORTED
@
