head     40.30;
branch   ;
access   ;
symbols  V40_35:40.28 V40_34:40.27 rel40_10:40.9 rel40_9:40.8 rel40_8:40.4 rel40_7:40.4 rel40_6:40.3 rel40_5:40.2 rel40_4:40.2 rel40_3:40.1 rel40_2:40.0 rel40_1:40.0 rel39_1:39.0;
locks    ; strict;
comment  @* @;


40.30
date     93.09.14.10.57.03;  author darren;  state Exp;
branches ;
next     40.29;

40.29
date     93.09.08.14.36.13;  author vertex;  state Exp;
branches ;
next     40.28;

40.28
date     93.08.03.11.04.29;  author vertex;  state Exp;
branches ;
next     40.27;

40.27
date     93.07.30.17.09.49;  author vertex;  state Exp;
branches ;
next     40.26;

40.26
date     93.05.21.13.29.35;  author vertex;  state Exp;
branches ;
next     40.25;

40.25
date     93.05.06.14.08.08;  author brummer;  state Exp;
branches ;
next     40.24;

40.24
date     93.05.04.10.04.10;  author brummer;  state Exp;
branches ;
next     40.23;

40.23
date     93.05.03.16.49.55;  author brummer;  state Exp;
branches ;
next     40.22;

40.22
date     93.04.21.12.30.16;  author brummer;  state Exp;
branches ;
next     40.21;

40.21
date     93.04.07.16.47.34;  author brummer;  state Exp;
branches ;
next     40.20;

40.20
date     93.04.07.13.26.18;  author brummer;  state Exp;
branches ;
next     40.19;

40.19
date     93.04.07.10.16.16;  author brummer;  state Exp;
branches ;
next     40.18;

40.18
date     93.03.31.11.51.22;  author brummer;  state Exp;
branches ;
next     40.17;

40.17
date     93.03.26.10.20.18;  author brummer;  state Exp;
branches ;
next     40.16;

40.16
date     93.03.18.10.55.49;  author brummer;  state Exp;
branches ;
next     40.15;

40.15
date     93.03.16.11.25.03;  author brummer;  state Exp;
branches ;
next     40.14;

40.14
date     93.03.11.14.25.46;  author brummer;  state Exp;
branches ;
next     40.13;

40.13
date     93.03.09.14.02.46;  author brummer;  state Exp;
branches ;
next     40.12;

40.12
date     93.03.05.15.02.24;  author brummer;  state Exp;
branches ;
next     40.11;

40.11
date     93.03.05.12.58.36;  author brummer;  state Exp;
branches ;
next     40.10;

40.10
date     93.03.04.15.17.39;  author brummer;  state Exp;
branches ;
next     40.9;

40.9
date     93.03.02.11.16.34;  author brummer;  state Exp;
branches ;
next     40.8;

40.8
date     93.02.26.17.15.45;  author brummer;  state Exp;
branches ;
next     40.7;

40.7
date     93.02.26.12.20.17;  author Jim2;  state Exp;
branches ;
next     40.6;

40.6
date     93.02.25.19.29.25;  author brummer;  state Exp;
branches ;
next     40.5;

40.5
date     93.02.25.18.53.07;  author brummer;  state Exp;
branches ;
next     40.4;

40.4
date     93.02.25.08.55.54;  author Jim2;  state Exp;
branches ;
next     40.3;

40.3
date     93.02.23.13.17.28;  author Jim2;  state Exp;
branches ;
next     40.2;

40.2
date     93.02.18.11.03.58;  author Jim2;  state Exp;
branches ;
next     40.1;

40.1
date     93.02.16.13.47.59;  author Jim2;  state Exp;
branches ;
next     40.0;

40.0
date     93.02.09.10.23.35;  author Jim2;  state Exp;
branches ;
next     39.0;

39.0
date     93.02.03.11.07.48;  author Jim2;  state Exp;
branches ;
next     ;


desc
@Assembler top level functions for the nonvolatile.library.
@


40.30
log
@Update autodocs to indicate a DOS process is required for
use (except as we know in the case of the nvram editor)
@
text
@******************************************************************************
*
*	$Id: main.asm,v 40.29 93/09/08 14:36:13 vertex Exp Locker: darren $
*
******************************************************************************
*
*	$Log:	main.asm,v $
* Revision 40.29  93/09/08  14:36:13  vertex
* Fixed background autodoc sample script
* 
* Revision 40.28  93/08/03  11:04:29  vertex
* Autodoc cleanup
*
* Revision 40.27  93/07/30  17:09:49  vertex
* Autodoc and include cleanup
*
* Revision 40.26  93/05/21  13:29:35  vertex
* Added check for name length in StoreNV
*
* Revision 40.25  93/05/06  14:08:08  brummer
* Add call to NVRAM function SetNVRAMMultiCommand in GetNVList().
*
* Revision 40.24  93/05/04  10:04:10  brummer
* Reformat GetNVInfo() AUTODOC.
*
* Revision 40.23  93/05/03  16:49:55  brummer
* Fix again the description of nvi_availstorage in GetNVInfo().
*
* Revision 40.22  93/04/21  12:30:16  brummer
* Fix documentation for CI176, nvi_freeStorage definition
*
* Revision 40.22  13/.1/.0  .2:.0:.2  brummer
* Add documentation for CI176, nvi_FreeStorage definition.
*
* Revision 40.21  93/04/07  16:47:34  brummer
* Fix to remove forced crash if user attempts to set nonused bits in DeleteNV() function.
*
* Revision 40.20  93/04/07  13:26:18  brummer
* Add comment to AUTODOC about rescan on GetNVInfo() or close/open.
*
* Revision 40.19  93/04/07  10:16:16  brummer
* Fix the getnvlist routine - the code was origonally checking for more Apps
* to do on a single App call.  The single App call does not have the App
* name in the allocated buffer, so the code was doing an invalid test for end
* Added a check for single App before checking the termination condition.
* Also, fixed some comments.
*
* Revision 40.18  93/03/31  11:51:22  brummer
* Fix to prevent writing NVRAM entry when disk is write protected.
* (related to disk/fileio.asm 40.7)
* Added AUTODOC background
*
* Revision 40.17  93/03/26  10:20:18  brummer
* Fix AUTODOCs per CATS request.
* Fix GetNVInfo() error that had MAX > AVAIL.
*
* Revision 40.16  93/03/18  10:55:49  brummer
* Replace 68020 instructions with generic 68000 code.
*
* Revision 40.15  93/03/16  11:25:03  brummer
* Fix register push/pop mismatch in setprotection.
*
* Revision 40.14  93/03/11  14:25:46  brummer
* Remove LLName definition.  This is fix related to nonvolatilebase.i
* 40.5
*
* Revision 40.13  93/03/09  14:02:46  brummer
* Fix autodocs to add invalid chars description.
* Fix GetNVList autodoc to not suggest it returns an array
* Make misc fixes suggested by Martit.
*
* Revision 40.12  93/03/05  15:02:24  brummer
* Update AUTODOCs.
*
* Revision 40.11  93/03/05  12:58:36  brummer
* Remove origonal method of disabling requesters and use the parameterized method instead.
* If the parameter is TRUE, a open of lowlevel.library will be done
* and a call will be made to KillReq() and RestoreReq()
*
* Revision 40.10  93/03/04  15:17:39  brummer
* Fix code to allow two NULL strings for App/Item access to
* reserved data.  Prevent access if either but not both are NULL.
*
* Revision 40.9  93/03/02  11:16:34  brummer
* Modified code to use already opened utility.library from nv.lib base.
* All changes are marked with an ## in the comment fields.
*
* Revision 40.8  93/02/26  17:15:45  brummer
* fix incorrect branch after writing NV disk
*
* Revision 40.7  93/02/26  12:20:17  Jim2
* Corrected error in parsing total NVRAM size in GetNVInfo.
* If there are no ItemNames for an AppName in GetNVList, do not
* list the AppName.
*
* Revision 40.6  93/02/25  19:29:25  brummer
* fix out of range branch because of previous fix
*
* Revision 40.5  93/02/25  18:53:07  brummer
* test d0 on return from WriteNVRAM calls
*
* Revision 40.4  93/02/25  08:55:54  Jim2
* Added StoreNV.
*
* Revision 40.3  93/02/23  13:17:28  Jim2
* GetNVList also talks in quantities of ten bits.  GetNVList
* builds an ExecList rather than returning an array of NVEntry(s).
*
* Revision 40.2  93/02/18  11:03:58  Jim2
* Added SetNVProtection.  The values returned by GetNVInfoare in
* tens of bytes, not single bytes.  The structure returned
* by GetNVList includes the protection which needs to be set
* to no protection for AppNames.
*
* Revision 40.1  93/02/16  13:47:59  Jim2
* Altered GetNVList to return the new data structure.
*
* Revision 40.0  93/02/09  10:23:35  Jim2
* GetNVList now sorts and combines the lists rather than depending
* on the NVRAM routines.
*
* Revision 39.0  93/02/03  11:07:48  Jim2
* Initial Release - Tested Disk functions.
*
*
*	(C) Copyright 1992,1993 Commodore-Amiga, Inc.
*	    All Rights Reserved
*
******************************************************************************

		INCLUDE	'exec/macros.i'
		INCLUDE	'exec/memory.i'

		INCLUDE	'dos/dosextens.i'

		INCLUDE	'nonvolatilebase.i'
		INCLUDE	'nonvolatile.i'
		INCLUDE 'NVRAM/nvramtree.i'

				;NVRAM/
		XREF	GetNVRAMInfo
		XREF	SizeNVRAMList
		XREF	GetNamesFromNVRAM
		XREF	SizeItemNVRAM
		XREF	SetNVRAMProtection
		XREF	WriteNVRAM
		XREF	SetNVRAMMultiCommand
		XREF	ClrNVRAMMultiCommand
				;Disk/GetDiskInfo.asm
		XREF	GetDiskInfo
				;Disk/SizeDiskList.asm
		XREF	SizeDiskList
				;Disk/MakeList.asm
		XREF	GetNamesFromDisk
		XREF	SizeItemDisk
				;Disk/SetNVRAMProtection.asm
		XREF	SetDiskProtection
				;Disk/FileIO.asm
		XREF	WriteDisk


		XDEF	GetNVInfo
		XDEF	GetNVList
		XDEF	SetNVProtection
		XDEF	StoreNV

******* nonvolatile.library/--background-- ****************************************
*
*   PURPOSE
*	The nonvolatile library provides a simple means for an application
*	developer to manage nonvolatile storage.
*
*   OVERVIEW
*	The nonvolatile library is meant to be used transparently across all
*	configurations. Currently, nonvolatile storage may consist of NVRAM
*	and/or disk devices. nonvolatile.library will automatically
*	access the best nonvolatile storage available in the system. Disk
*	based storage will be selected first and if not available, NVRAM
*	storage will be accessed.
*
*	* NVRAM
*
*	On low-end diskless Amiga platforms, NVRAM may be available. This
*	RAM will maintain its data contents when the system is powered down.
*	This is regardless of whether batteries or battery-backed clock are
*	present. The data stored in NVRAM is accessible only through the
*	ROM-based nonvolatile library funtion calls. The size of NVRAM
*	storage	is dependant on the system platform and is attainable through
*	the GetNVInfo() function.
*
*	* Disk
*
*	In keeping with the general configurability of the Amiga, the actual
*	disk location used by nonvolatile library when storing to disk may be
*	changed by the user.
*
*	The prefs directory is used on the Amiga for storing many user
*	configurable options. The location for nonvolatile disk storage
*	is contained in the file prefs/env-archive/sys/nv_location. This
*	file should contain a data string that specifies a lockable location.
*	If the string does not specify a lockable location, the file will
*	be ignored.
*
*	When opened, the nonvolatile library will search all drives within
*	the system until it finds this file and successfully accomplishes
*	a Lock on the location specified in the file. To force a rescan of
*	all drives, the library may be closed and reopened or execute the
*	GetNVInfo() function.
*
*	A simple method for creating a floppy disk for saving nonvolatile
*	data is the following:
*
*	Format a disk with the volume name NV
*	Create a file prefs/env-archive/sys/nv_location on this disk with
*	  the following contents:  NV:nonvolatile
*	Create a directory nonvolatile
*
*	The following is a script file that can be used to make a floppy
*	for use with nonvolatile library:
*
*	.KEY DRIVE/A,DISK
*	.BRA {
*	.KET }
*	format Drive {DRIVE} Name {DISK$NV} noicons ffs
*	makedir {DRIVE}prefs
*	makedir {DRIVE}nonvolatile
*	makedir {DRIVE}prefs/env-archive
*	makedir {DRIVE}prefs/env-archive/sys
*	echo {DISK$NV}:nonvolatile >{DRIVE}prefs/env-archive/sys/nv_location
*
*	!!!NOTE!!!
*
*	Because NVRAM performs disk access, you must open and use its
*	functionality from a DOS process, not an EXEC task.  Normally
*	your CDGS application is invoked as a DOS process so this
*	requirement generally should cause you no concern.  You just
*	need to be aware of this requirement should you create an
*	EXEC task and try to invoke nonvolatile.library from that task.
*
*******************************************************************************



******* nonvolatile.library/GetNVInfo ****************************************
*
*   NAME
*	GetNVInfo -- report information on the current nonvolatile storage.
*		     (V40)
*
*   SYNOPSIS
*	information = GetNVInfo(killRequesters);
*	D0			D1
*
*	struct NVInfo *GetNVInfo(BOOL);
*
*   FUNCTION
*	Finds the user's preferred nonvolatile device and reports information
*	about it.
*
*   INPUTS
*	killRequesters - suppress system requesters flag. TRUE if all system
*			 requesters are to be suppressed during this function.
*			 FALSE if system requesters are allowed.
*
*   RESULT
*	information - pointer to an NVInfo structure. This structure contains
*		      information on the NV storage media with the largest
*		      storage. The structure contains 2 longword fields:
*		      nvi_MaxStorage and nvi_FreeStorage. Both values are
*		      rounded down to the nearest ten. The nvi_MaxStorage
*		      field is defined as the total amount of nonvolatile
*		      storage available on this device. The nvi_FreeStorage is
*		      defined as the amount of available space for NVDISK or
*		      the amount of non-locked storage for NVRAM. For NVDISK,
*		      the nvi_FreeStorage takes into account the amount of
*		      overhead room required to store a new App/Item. This
*		      amount is 3 blocks to allow room for storing a new Item
*		      file and possibly a new App directory. For NVRAM, the
*		      amount of overhead is 5 bytes. However, the amount of
*		      room required to store a new NVRAM item depends on the
*		      length of the App and Item names. Refer to StoreNV()
*		      function for storage details.
*
*		      This function may return NULL in the case of failure.
*
*   SEE ALSO
*	FreeNVData(), StoreNV(), <libraries/nonvolatile.h>
*
******************************************************************************
GetNVInfo
		movem.l	a5/a6,-(sp)
		move.l	a6,a5
		move.l	nv_ExecBase(a5),a6

		ChkKillRequesters		; ###

		move.l	#NVINFO_SIZE+4,d0
		move.l	#MEMF_PUBLIC|MEMF_CLEAR,d1
		JSRLIB	AllocMem		;Allocate space for the struct NVInfo.
		tst.l	d0			;If we can't get the space exit.
		beq.s	gnvi_Exit
				;Got the memory.
		move.l	a4,-(sp)
		move.l	d0,a4
		move.l	#NVINFO_SIZE+4,(a4)+	;Store the size of the allocated memory in the first long word.
		addq.l	#4,d0
		move.l	a5,a6			;Get base in a6 for GetDiskInfo.
		bsr	GetDiskInfo		;Get information for the disk.
		sub.l	#NVINFO_SIZE,sp		;Get another struct NVInfo off the stack.
		move.l	sp,d0
		bsr	GetNVRAMInfo		;Get information for the NVRAM chip.
		move.l	(sp),d0
		cmp.l	(a4),d0			;Is there more space on disk, or NVRAM.
		bmi.s	MoreOnDisk
				;More space in NVRAM.
		move.l	a4,a6			;Reset the pointers to the start of the data.
		move.w	#(NVINFO_SIZE/4)-1,d0	;This many long words to copy.
gnvi_CopyLoop:	move.l	(sp)+,(a6)+
		dbf	d0,gnvi_CopyLoop
		bra.s	Leave			;We are ready to leave.
				;More space on disk.
MoreOnDisk:	add.l	#NVINFO_SIZE,sp		;Clear away NVInfo structure from the stack.

Leave:
		move.l	a4,-(sp)
		move.l	nv_UTILBase(a5),a6	; a6 gets utility.library base
		move.l	(a4),d0
		moveq.l	#10,d1
		JSRLIB	UDivMod32
		move.l	d0,(a4)+

		move.l	(a4),d0
		moveq.l	#10,d1
		JSRLIB	UDivMod32
		move.l	d0,(a4)+
		move.l	(sp)+,d0

		move.l	(sp)+,a4
gnvi_Exit:
		ChkRestoreRequesters		; ###

		movem.l	(sp)+,a5/a6
		rts

******* nonvolatile.library/GetNVList ****************************************
*
*   NAME
*	GetNVList -- return a list of the items stored in nonvolatile
*		     storage. (V40)
*
*   SYNOPSIS
*	list = GetNVList(appName, killRequesters);
*	D0		 A0	  D1
*
*	struct MinList *GetNVList(STRPTR, BOOL);
*
*   FUNCTION
*	Returns a pointer to an Exec list of nonvolatile Items associated
*	with the appName requested.
*
*	The string appName may not contain the '/' or ':' characters.
*	It is recommended that these characters be blocked from user input
*	when requesting an appName string.
*
*   INPUTS
*	appName - NULL terminated string indicating the application name
*		  to be matched. Maximum length is 31.
*	killRequesters - Suppress system requesters flag. TRUE if all system
*			 requesters are to be suppressed during this function.
*			 FALSE if system requesters are allowed.
*
*   RESULT
*	list - a pointer to an Exec MinList of NVEntries. A NULL will be
*	       returned if there is insufficient memory. If there are no
*	       entries in the nonvolatile storage for the AppName, an
*	       empty list will be returned.
*
*   NOTE
*	The protection field contains more bits than are required for
*	storing the delete protection status. These bits are reserved
*	for other system usage and may not be zero. When checking for
*	the delete status use either the field mask NVIF_DELETE, or the
*	bit definition NVIB_DELETE.
*
*   SEE ALSO
*	FreeNVData(), SetNVProtection()
*
******************************************************************************
*
*	Memory space is allocated for all of the elements and all of the
*	strings. The node are located at the start of allocated memory.
*	The strings are therefore located at the end of allocated memory.
*
*	However, the strings can be found on either NVRAM, or disk, or both.
*	First the disk then the NVRAM is queried for the strings. Then the
*	two lists are combined, droping any duplicates. This is done without
*	requiring any scratch memory.  None is requried since the memory
*	allocation is enough to hold every string without need to drop any.
*	So, the two lists are placed in memory following the last utilized
*	array entry.  The list is searched from last to first, and placed
*	in front of all pevious lists.  Then the nodes are created
*	for each of these strings.
*
*	It sounds more confusing than it is.
GetNVList
		movem.l	d1-d7/a1-a6,-(sp)	; Place the AppName pointer on the stack.
		move.l	a6,a5			; a5 gets NVBase
		move.l	a0,a4			; a4 gets AppName pointer
		move.l	a0,d6			; d6 gets AppName pointer for single App test
		move.l	nv_ExecBase(a5),a6	; a6 gets ExecBase
;
; Kill requester based on parameter in d1 :
;
		ChkKillRequesters		;
;
; Set NVRAM multi-command option :
;
		bsr	SetNVRAMMultiCommand	; ##
;
; Determine size of requested data and attempt to allocated memory :
;
		bsr	SizeNVRAMList		; d0 gets NVRAM size requirement
		move.l	d0,-(sp)		; save on stack
		bsr	SizeDiskList		; d0 gets NVDISK size requirements
		add.l	(sp)+,d0		; d0 gets sum of size required from NVRAM and disk
		add.l	#4+MLH_SIZE,d0		;Add a long word to remember the size.  Plus the MinList
		move.l	d0,-(sp)		;Remember this size temporarily
		move.l	#MEMF_PUBLIC|MEMF_CLEAR,d1
		JSRLIB	AllocMem
		move.l	(sp)+,d1		;Remove the size from the stack.
		move.l	d0,-(sp)
		beq	gnvl_Close
;
; Memory allocated, build list head node :
;
		movem.l	d2-d4/a2-a3,-(sp)	; save registers
		move.l	d0,a3
		move.l	d1,(a3)+		;Store the size of memory allocated
		move.l	a3,4*5(sp)		;Remember our return parameter.
		NEWLIST	a3
		add.l	#MLH_SIZE,a3
		move.l	a3,a2
		add.l	-(4+MLH_SIZE)(a3),a3
		sub.l	#(5+MLH_SIZE),a3	;Get pointer to the last byte of the allocation.
		move.l	a3,d3			;Set up termination in the case of a single application.
		cmp.l	a2,a3
		blt	gnvl_Cleanup		;Was there any space allocated for data?
;
; Determine if list is for all Apps or just one :
;
		cmp.l	#0,a4			; is AppName pointer = NULL ?
		bne.s	GetItems
;
; Request is for all Apps :
;
GetApps:	move.l	a2,d2			;Remember the start of memory used.
		move.l	a3,d3			;Remember the end of allocated memory.
		addq.l	#1,a2			;Place a NULL at the start of the list of applications.
		bsr	GetNamesFromDisk
		bsr	GetNamesFromNVRAM
		bsr	Merge
		move.l	a3,a4			;Point a4 to the first AppName to be processed.
		move.l	d2,a2			;Reset a2 to start of memory.
;
;Reset the end of available scratch memory.  a3
;currently points to the first character of useful
;stringns at the end of the allocated memory block.
;
AddAppNode:	move.l	a4,nve_Name(a2)
		move.l	#0,nve_Size(a2)
		move.l	#NVEF_APPNAME,nve_Protection(a2)
		move.l	a2,a1
		add.l	#NVENTRY_SIZE,a2
		move.l	4*5(sp),a0
		ADDTAIL
		subq.l	#1,a3			;Leave a NULL between the lists of ItemNames.
;
; Get Items associated to AppName :
;
GetItems:	move.l	a2,d2			;Remember where the list of ItemNames is to start.
		move.b	#0,(a2)+		;For Merge to work, there must be a NULL at the start of the list.
		bsr	GetNamesFromDisk
		bsr	GetNamesFromNVRAM
		lea	-1(a2),a0
		cmp.l	a0,d2
		bne.s	ItemsExist
;
; No items exist for the current App, remove the AppName node from the list :
;
		sub.l	#NVENTRY_SIZE+1,a2
		move.l	a2,a1
		move.l	4*5(sp),a0
		REMTAIL
		bra.s	SkipToNext
;
; Items exist for the current App :
;	- call merge to get rid of duplicates
;	- for each item in merged list, create an Item list node
;
ItemsExist:	move.l	a3,d4			;Remember the end of memory for the termination of creating elements.
		bsr	Merge
		move.l	a3,-(sp)		;Remember the top of memory used for the ItemName strings.
AddItem:	cmp.l	d4,a3
		bge.s	DoneItems		;A top testing loop, in case of the pathalogical case of no Items.
				;Create a node for this Items.
		move.l	a2,a1
		move.l	4*6(sp),a0
		ADDTAIL
		move.l	a3,nve_Name(a2)
		move.l	#0,nve_Size(a2)		;Initialize the size to zero.
		move.l	#0,nve_Protection(a2)
		add.l	#nve_Size,a2
		bsr	SizeItemDisk
		bsr	SizeItemNVRAM
		move.l	(a2),d1
		add.l	#9,d1			;Ceiling the size to ten byte units.
		divu.w	#10,d1
		andi.l	#$0FFFF,d1		; d1 gets word size operand
		move.l	d1,(a2)
		add.l	#NVENTRY_SIZE-nve_Size,a2	;Advance the to the next array element.
NextItem:	tst.b	(a3)+			;Skip along the string to the NULL.
		bne.s	NextItem
				;Got to the NULL.  a3 actually points to the next non-NULL.
		bra.s	AddItem
				;Processed all of the items for this application.
DoneItems	move.l	(sp)+,a3		;Restore the pointer to the end of 'scratch' memory.
;
; Determine if more there are more Apps to do :
;
SkipToNext:	tst.l	d6			; was this a single App request ?
		bne.s	gnvl_Cleanup		; if yes, j to exit
		tst.b	(a4)+			; find end of this App (actually begining of next App)
		bne.s	SkipToNext		;
		cmp.l	a4,d3			; is this the last App (end of allocated memory) ?
		bgt	AddAppNode		; if no, j to do next App
;
; Cleanup and exit :
;
gnvl_Cleanup:	movem.l	(sp)+,d2-d4/a2-a3	;Restore the scratch registers.
gnvl_Close:	move.l	(sp)+,d0		;Get the return value.
gnvl_Exit:
;
; Clear NVRAM multi-command option :
;
		bsr	ClrNVRAMMultiCommand	; ##

		ChkRestoreRequesters		; restore requesters if necessary
		movem.l	(sp)+,d1-d7/a1-a6	;Clear stack and restore last two scratch registers.
		rts




*****l* main.asm/Merge *******************************************************
*
*   NAME
*	Merge - Merges a lists of string with possible duplicates.
*
*   SYNOPSIS
*	start = Merge (Start, End, EndOfMergeBlock, NVBase)
*	A3	       D2     A2   A3		    a5
*
*   FUNCTION
*	Takes a list of strings and removes duplicates.
*
*	This function assumes the input list and output list occupy
*	overlapping areas of memory.  Also, this routine allows for
*	several copies of the data.
*
*   INPUTS
*	Start - Pointer the NULL that is located at the start of the list.
*	End - Pointer beyond the NULL that terminates the last string.
*	EndOfMergeBlock - Pointer beyond the last byte in the memory block
*			  to contain the merged list.
*
*   RESULT
*	start - Pointer to the first non-NULL in the merged list.
*
*   NOTE
*	The value in a2 is lost.
*
*
******************************************************************************
Merge
		movem.l	d2-d3/a4/a6,-(sp)	; ##
		move.l	nv_UTILBase(a5),a6	; ## get utility.library base
		move.b	#0,d3			;Need a NULL.
		move.b	d3,(a3)			;Make sure the merged list ends with a NULL.
GetNext:	cmp.l	d2,a2			;Have we searched the whole list?
		beq.s	AllDone
				;Still looking.  Skip NULLs
		tst.b	-(a2)
		beq.s	GetNext			;The current byte is NULL, check is it the last?
				;Ok got a new string.
		move.b	(a2),-(a3)
Coping:		move.b	-(a2),-(a3)
		bne.s	Coping			;Copy through the terminating NULL.
				;Copied the string.
		move.l	d2,a4			;Walk looking for duplicates from here.
CheckingForDup:	cmp.l	a2,a4
		beq.s	GetNext			;The complete list has been checked.

		tst.b	(a4)+
		beq.s	CheckingForDup		;Skip over NULLs.
				;At the start of a new string
		subq	#1,a4
		move.l	a4,a0
		lea	1(a3),a1
		JSRLIB	Stricmp
		beq.s	ClearWord
				;Not a duplicate skip to the end.
NULLLoop:	tst.b	(a4)+
		bne.s	NULLLoop

		subq.l	#1,a4
		bra.s	CheckingForDup
				;Found a duplicate word.  Clear it from the original list.
ClearWord:	move.b	d3,(a4)+
		tst.b	(a4)
		bne.s	ClearWord

		bra.s	CheckingForDup

AllDone:	addq.l	#1,a3			;Point a3 at the first non-NULL.
		movem.l	(sp)+,d2-d3/a4/a6	; ##
		rts



******* nonvolatile.library/SetNVProtection **********************************
*
*   NAME
*	SetNVProtection -- set the protection flags. (V40)
*
*   SYNOPSIS
*	success = SetNVProtection(appName, itemName, mask, killRequesters);
*	D0			  A0	   A1	     D2    D1
*
*	BOOL SetNVProtection(STRPTR, STRPTR, LONG, BOOL);
*
*   FUNCTION
*	Sets the protection attributes for an item currently in the
*	nonvolatile storage.
*
*	Although 'mask' is LONG only the delete bit, NVEF_DELETE/NVEB_DELETE,
*	may be set. If any other bits are set this function will return
*	FALSE.
*
*	The strings appName and itemName may not contain the '/' or ':'
*	characters. It is recommended that these characters be blocked
*	from user input when requesting AppName and ItemName strings.
*
*   INPUTS
*	appName - NULL terminated string indicating the application name
*		  to be matched. Maximum length is 31.
*	itemName - NULL terminated string indicated the item within the
*		   application to be found. Maximum length is 31.
*	mask - the new protection mask. Only set the delete bit otherwise
*	       this function WILL CRASH.
*	killRequesters - suppress system requesters flag. TRUE if all system
*			 requesters are to be suppressed during this function.
*			 FALSE if system requesters are allowed.
*
*   RESULT
*	success - FALSE if the protection could not be change (ie the data
*		  does not exist).
*
*   SEE ALSO
*	GetNVList(), <libraries/nonvolatile.h>
*
******************************************************************************
SetNVProtection
		move.l	d2,d0			; d0 gets mask
		and.l	#~NVEF_DELETE,d0	; any other bits set ?
		beq.s	Ok			; if no, j to continue
		moveq.l	#0,d0			; d0 gets FALSE
		rts				; return
;
; User is changing only delete bit, save and init registers :
;
Ok		movem.l	d3/a3-a6,-(sp)		;Place the AppName pointer on the stack.
		move.l	a6,a5			; a5 gets nonvolatile.library base
		move.l	a0,a3			; a3 gets ptr to App
		move.l	a1,a4			; a4 gets ptr to Item
;
; Kill requesters based on parameter :
;
		ChkKillRequesters		; ###

		CLEAR	d3
		bsr	SetDiskProtection
		bsr	SetNVRAMProtection
		move.l	d3,d0

		ChkRestoreRequesters		; ###

		movem.l	(sp)+,d3/a3-a6		;Clear stack and restore last two scratch registers.
		rts




******* nonvolatile.library/StoreNV ******************************************
*
*   NAME
*	StoreNV -- store data in nonvolatile storage. (V40)
*
*   SYNOPSIS
*	error = StoreNV(appName, itemName, data, length, killRequesters);
*	D0		A0	 A1	   A2    D0	 D1
*
*	UWORD StoreNV(STRPTR, STRPTR, APTR, ULONG, BOOL);
*
*   FUNCTION
*	Saves some data in nonvolatile storage. The data is tagged with
*	AppName and ItemName so it can be retrieved later. No single
*	item should be larger than one fourth of the maximum storage as
*	returned by GetNVInfo().
*
*	There is no data compression associated with this function.
*
*	The strings, AppName and ItemName, should be short, but descriptive.
*	They need to be short since the string is stored with the data and
*	the nonvolatile storage for a stand alone game system is limited.
*	The game system allows the user to selectively remove entries from
*	storage, so the string should be desriptive.
*
*	The strings AppName and ItemName may not contain the '/' or ':'
*	characters. It is recommended that these characters be blocked
*	from user input when requesting AppName and ItemName strings.
*
*   INPUTS
*	appName - NULL terminated string identifying the application
*		  creating the data. Maximum length is 31.
*	itemName - NULL terminated string uniquely identifying the data
*		   within the application. Maximum length is 31.
*	data - pointer to the memory block to be stored.
*	length - number of bytes to be stored in the units of tens of
*		 bytes. For example, if you have 23 bytes to store length = 3;
*		 147 byte then length = 15.
*	killRequesters - suppress system requesters flag. TRUE if all system
*			 requesters are to be suppressed during this function.
*			 FALSE if system requesters are allowed.
*
*   RESULT
*	error - 0                means no error,
*	        NVERR_BADNAME    error in AppName, or ItemName.
*	        NVERR_WRITEPROT  Nonvolatile storage is read only.
*	        NVERR_FAIL       Failure in writing data (nonvolatile storage
*				 full, or write protected).
*	        NVERR_FATAL      Fatal error when accessing nonvolatile
*				 storage, possible loss of previously saved
*				 nonvolatile data.
*
*   SEE ALSO
*	GetCopyNV(), GetNVInfo()
*
******************************************************************************
StoreNV
		movem.l	d2/a3-a6,-(sp)
		move.l	a6,a5			;Save NVBase.
		move.l	a0,a3			;Save AppName.
		move.l	a1,a4			;Save ItemName

		andi.l	#$0FFFF,d0		; d0 gets word operand length
		move.l	d0,d2			;
		mulu.w	#10,d2			; Length is in units of tens of bytes.
;
; Kill all task based requesters based on parameter :
;
		ChkKillRequesters		; ###
;
; Check for NULL App/Item name pointers :
;
		move.l	#NVERR_BADNAME,d0
		move.l	a3,d1
;		tst.l	a3
		beq	sn_Exit			;Null AppName is wrong.
		move.l	a4,d1
;		tst.l	a4
		beq	sn_Exit			;Null ItemName is wrong.
;
; Check for NULL App/Item name strings (allow both NULL for RSVD data) :
;
		tst.b	(a3)			; is App string NULL ?
		bne.s	4$			; if no, j to continue
		tst.b	(a4)			; is Item string also NULL ?
		beq.s	NamesOK			; if yes, j to OK
		bra	sn_Exit			; j to error return
4$:		tst.b	(a4)			; is Item string nonNULL ?
		beq	sn_Exit			; if no, j to error return
;
; Parse APP name for a few invalid chars :
;
		move.l	a3,a0
		moveq	#0,d1		; to count the length

				;Neither :'s nor /'s are allowed in the AppName
CheckAppName:	cmp.b	#'/',(a0)
		beq	sn_Exit

		cmp.b	#':',(a0)+
		beq	sn_Exit

		addq.l	#1,d1		; length counter

		tst.b	(a0)
		bne.s	CheckAppName

		cmp.l	#NVRT_Max_String_Length,d1
		bgt.s	sn_Exit

;
; Parse Item name for a few invalid chars :
;
		move.l	a4,a0
		moveq	#0,d1		; length counter
				;Neither :'s nor /'s are allowed in the AppName
CheckItemName:	cmp.b	#'/',(a0)
		beq.s	sn_Exit

		cmp.b	#':',(a0)+
		beq.s	sn_Exit

		addq.l	#1,d1		; length counter

		tst.b	(a0)
		bne.s	CheckItemName

		cmp.l	#NVRT_Max_String_Length,d1
		bgt.s	sn_Exit
;
; Names OK, do store command :
;
NamesOK:	move.l	a5,a6			;The subroutines all expect NVBase in a6.
		move.l	a4,a1			;ItemName
		move.l	a3,a0			;AppName
		move.l	#MODE_OLDFILE,d1
		move.l	d2,d0			;Length
		bsr	WriteDisk
		tst.l	d0
				;
				;Zero means success so we can exit.  If the high
				;order bit is set it means the files was found,
				;but write protected.  There is no fall back
				;to NVRAM on this occurrance, only if the disk
				;or file is write protected.
				;
		ble.s	sn_Exit

		cmp.l	#NVERR_BADNAME,d0
		beq.s	sn_Exit			;If DOS did not like the name, don't give the NVRAM a chance.

		move.l	a4,a1
		move.l	a3,a0
		move.l	#MODE_OLDFILE,d1
		move.l	d2,d0
		bsr	WriteNVRAM
		tst.l	d0
		beq.s	sn_Exit
				;Updating the file was not possible, try creating it.
		move.l	a4,a1
		move.l	a3,a0
		move.l	#MODE_NEWFILE,d1
		move.l	d2,d0
		bsr	WriteDisk
		tst.l	d0
		ble.s	sn_Exit			; if write is OK, j to return

		move.l	a4,a1
		move.l	a3,a0
		move.l	#MODE_NEWFILE,d1
		exg.l	d2,d0			;Remember the disk failure if NVRAM fails it probably is not present.
		bsr	WriteNVRAM
		tst.l	d0
		beq.s	sn_Exit
;
; NVRAM failed restore disk failure.
;
		exg.l	d2,d0
sn_Exit:	bclr.l	#31,d0				; Clear the high bit.
		ChkRestoreRequesters			; restore requesters

		movem.l	(sp)+,d2/a3-a6
		rts



		end
@


40.29
log
@Fixed background autodoc sample script
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.28 93/08/03 11:04:29 vertex Exp Locker: vertex $
d8 3
d230 9
@


40.28
log
@Autodoc cleanup
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.27 93/07/30 17:09:49 vertex Exp Locker: vertex $
d8 3
d218 1
a218 1
*	.KEY Drive/A DiskName
d221 6
a226 7
*	format Drive {Drive} Name {DiskName$NV} noicons
*	md {Drive}prefs
*	md {Drive}nonvolatile
*	md {Drive}prefs/env-archive
*	md {Drive}prefs/env-archive/sys
*	echo {DiskName$NV}:nonvolatile > {Drive}prefs/env-archive/sys
*	 /nv_location
@


40.27
log
@Autodoc and include cleanup
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.26 93/05/21 13:29:35 vertex Exp Locker: vertex $
d8 3
d169 3
a171 3
*	configurations.  Currently, nonvolatile storage may consist of NVRAM
*	and/or disk devices.  The nonvolatile library will automatically
*	access the best nonvolatile storage available in the system.  Disk
d177 1
a177 1
*	On low-end diskless Amiga platforms, NVRAM may be available.  This
d180 2
a181 2
*	present.  The data stored in NVRAM is accessible only through the
*	ROM-based nonvolatile library funtion calls.  The size of NVRAM
d192 2
a193 2
*	configurable options.  The location for nonvolatile disk storage
*	is contained in the file prefs/env-archive/sys/nv_location.  This
d200 1
a200 1
*	a Lock on the location specified in the file.  To force a rescan of
d247 1
a247 1
*	killRequesters - suppress system requesters flag.  TRUE if all system
d252 1
a252 1
*	information - pointer to an NVInfo structure.  This structure contains
d264 1
a264 1
*		      file and possibly a new App directory.  For NVRAM, the
d345 1
a345 1
*	with the AppName requested.
d347 1
a347 1
*	The string AppName may not contain the '/' or ':' characters.
d349 1
a349 1
*	when requesting an AppName string.
d353 1
a353 1
*		  to be matched.  Maximum length is 31.
d377 1
a377 1
*	strings.  The node are located at the start of allocated memory.
d381 2
a382 2
*	First the disk then the NVRAM is queried for the strings.  Then the
*	two lists are combined, droping any duplicates.  This is done without
d546 2
a547 2
*	Start = Merge (Start, End, EndOfMergeBlock, NVBase)
*	a3	       d2     a2   a3		    a5
d563 1
a563 1
*	Start - Pointer to the first non-NULL in the merged list.
d628 2
a629 2
*	Sets the protection attributes for a Item currently stored on the
*	nonvolatile device.
d635 1
a635 1
*	The strings AppName and ItemName may not contain the '/' or ':'
d644 1
a644 1
*	mask - the new protection mask.  Only set the delete bit otherwise
d655 1
a655 1
*	GetNVList()
d696 1
a696 1
*	D0		a0	 A1	   a2    D0	 D1
d701 2
a702 2
*	Saves some data in nonvolatile storage.  The data is tagged with
*	AppName and ItemName so it can be retrieved later.  No single
d720 1
a720 1
*		  creating the data.  Maximum length is 31.
d727 1
a727 1
*	killRequesters - suppress system requesters flag.  TRUE if all system
@


40.26
log
@Added check for name length in StoreNV
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.25 93/05/06 14:08:08 brummer Exp $
d8 3
d230 2
a231 1
*	GetNVInfo - Reports information on the current nonvolatile storage
d234 2
a235 2
*	Information = GetNVInfo (KillRequesters)
*	d0			 d1
d237 1
a237 1
*	struct NVInfo * GetNVInfo (BOOL)
d244 1
a244 1
*	KillRequesters - Suppress system requesters flag.  TRUE if all system
d249 19
a267 14
*	Information - Pointer to an NVInfo structure.  This structure contains
*	information on the NV storage media with the largest storage.  The
*	structure contains 2 long word fields: nvi_MaxStorage and
*	nvi_FreeStorage.  Both values are rounded down to the nearest ten.
*	The nvi_MaxStorage field is defined as the total amount of nonvolatile
*	storage available on this device.  The nvi_FreeStorage is
*	defined as the amount of available space for NVDISK or the amount of
*	non-locked storage for NVRAM.  For NVDISK, the nvi_FreeStorage takes
*	into account the amount of overhead room required to store a new
*	App/Item. This amount is 3 blocks to allow room for storing a new
*	Item file and possibly a new App directory.  For NVRAM, the amount of
*	overhead is 5 bytes.  However, the amount of room required to store a
*	new NVRAM item depends on the length of the App and Item names.  Refer
*	to StoreNV function for storage details.
d270 1
a270 1
*	FreeNVData(), StoreNV()
d331 2
a332 2
*	GetNVList - Returns a list of the items stored in nonvolatile
*		    storage.
d335 2
a336 2
*	List = GetNVList (AppName, KillRequesters)
*	d0		  a0	   d1
d338 1
a338 1
*	struct MinList * GetNVList (STRPTR, BOOL)
d341 1
a341 1
*	Returns a pointer to an exec list of nonvolatile Items associated
d349 3
a351 3
*	AppName - NULL terminated string indicating the application name
*		  to be matched.  Maximum characters is 31.
*	KillRequesters - S system requesters flag.  TRUE if all system
d356 2
a357 2
*	List - A pointer to a Exec MinList of NVEntrys.  A NULL will be
*	       returned if there is insufficient memory.  If there are no
d363 2
a364 2
*	storing the delete protection status.  These bits are reserved
*	for other system usage and may not be zero.  When checking for
d616 1
a616 1
*	SetNVProtection - Sets the protection flags.
d619 2
a620 2
*	Success = SetNVProtection (AppName, ItemName, Mask, KillRequesters)
*	d0			   a0	    a1	      d2    d1
d622 1
a622 1
*	BOOL SetNVProtection (STRPTR, STRPTR, LONG, BOOL)
d628 2
a629 2
*	Although Mask is LONG only the delete bit, NVEF_DELETE/NVEB_DELETE,
*	may be set.  If any other bits are set this function will return
d633 1
a633 1
*	characters.  It is recommended that these characters be blocked
d637 5
a641 7
*	AppName - NULL terminated string indicating the application name
*		  to be matched.  Maximum characters is 31.
*		  A NULL string is not valid
*	ItemName - NULL terminated string indicated the item within the
*		   application to be found.  Maximum character length is 31.
*		   A NULL string is not valid.
*	Mask - The new protection mask.  Only set the delete bit otherwise
d643 1
a643 1
*	KillRequesters - Suppress system requesters flag.  TRUE if all system
d648 1
a648 1
*	Success - FALSE if the protection could not be change (ie the data
d689 1
a689 1
*	StoreNV - Store data in nonvolatile storage.
d692 2
a693 2
*	Error = StoreNV (AppName, ItemName, Data, Length, KillRequesters)
*	d0		 a0	  a1	    a2    d0	  d1
d695 1
a695 1
*	UWORD StoreNV (STRPTR, STRPTR, APTR, ULONG, BOOL)
d703 1
a703 1
*	There is no data compression associated with the StoreNV function.
d712 1
a712 1
*	characters.  It is recommended that these characters be blocked
d716 7
a722 9
*	AppName - NULL terminated string identifying the application
*		  creating the data.  Maximum character length is 31.
*		  A NULL string is not valid.
*	ItemName - NULL terminated string uniquely identifying the data
*		   within the application. Maximum character length is 31.
*		   A NULL string is not valid.
*	Data - Pointer to the memory block to be stored.
*	Length - Number of bytes to be stored in the units of tens of
*		 bytes.  ie If you have 23 bytes to store length = 3;
d724 1
a724 1
*	KillRequesters - Suppress system requesters flag.  TRUE if all system
d729 8
a736 8
*	Error:
*	0 - Data stored, no error.
*	NVERR_BADNAME - Error in AppName, or ItemName.
*	NVERR_WRITEPROT - Nonvolatile storage is read only.
*	NVERR_FAIL - Failure in writing data (nonvolatile storage full, or
*	   write protected).
*	NVERR_FATAL - Fatal error when accessing nonvolatile storage,
*	   possible loss of previously saved nonvolatile data.
@


40.25
log
@Add call to NVRAM function SetNVRAMMultiCommand in GetNVList().
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.24 93/05/04 10:04:10 brummer Exp Locker: brummer $
d8 3
d126 1
d774 2
d778 1
a778 1
		beq.s	sn_Exit
d781 3
a783 1
		beq.s	sn_Exit
d787 4
d795 1
d803 2
d807 3
@


40.24
log
@Reformat GetNVInfo() AUTODOC.
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.23 93/05/03 16:49:55 brummer Exp Locker: brummer $
d8 3
d131 2
d386 4
d511 7
a517 1
gnvl_Exit:	ChkRestoreRequesters		; restore requesters if necessary
@


40.23
log
@Fix again the description of nvi_availstorage in GetNVInfo().
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.22 93/04/21 12:30:16 brummer Exp Locker: brummer $
d8 3
d236 6
a241 6
*	Information - Pointer to an NVInfo structure.  This structure will
*	contain information on the NV storage media with the largest
*	storage.  The values returned are rounded up to the nearest ten.  The
*	structure contains two long word fields: nvi_MaxStorage and
*	nvi_FreeStorage.  The nvi_MaxStorage field is defined as the total
*	amount of NV storage available on this device.  The nvi_FreeStorage is
d245 1
a245 1
*	App/Item. This amount is 3 blocks to allow room for storing the new
d248 2
a249 1
*	new NVRAM item depends on the length of the App and Item name.
d252 1
a252 1
*	FreeNVData()
@


40.22
log
@Fix documentation for CI176, nvi_freeStorage definition
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.22 13/.1/.0 .2:.0:.2 brummer Exp Locker: brummer $
d8 3
d235 3
a237 2
*	storage.  This structure contains two long word fields: nvi_MaxStorage
*	and nvi_FreeStorage.  The nvi_MaxStorage field is defined as the total
d240 6
a245 2
*	non-locked storage for NVRAM.  Also, the nvi_FreeStorage takes into
*	account the amount of overhead room required to store a new App/Item.
@


40.21
log
@Fix to remove forced crash if user attempts to set nonused bits in DeleteNV() function.
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.20 93/04/07 13:26:18 brummer Exp Locker: brummer $
d8 6
d230 8
a237 1
*	Information - Pointer to an NVInfo structure.
@


40.20
log
@Add comment to AUTODOC about rescan on GetNVInfo() or close/open.
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.19 93/04/07 10:16:16 brummer Exp Locker: brummer $
d8 3
d481 3
d557 3
d576 2
a577 1
*	may be set.  If any other bits are set this function WILL CRASH.
d605 5
a609 4
		move.l	d2,d0
		and.l	#~NVEF_DELETE,d0
		beq.s	Ok
		divu.w	#0,d0			; invalid instr. !!!!!!!
d618 1
a618 1
; Temporarily kill all task based requester.
d631 3
@


40.19
log
@Fix the getnvlist routine - the code was origonally checking for more Apps
to do on a single App call.  The single App call does not have the App 
name in the allocated buffer, so the code was doing an invalid test for end
Added a check for single App before checking the termination condition.
Also, fixed some comments.
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.18 93/03/31 11:51:22 brummer Exp Locker: brummer $
d8 7
d163 10
a172 8
*	is no exception.  In fact, the file prefs/env-archive/sys/nv_location
*	contains the data string that specifies the disk location to be
*	used to store nonvolatile data.  This string must specify a location
*	that can be found (Locked in AmigaDOS parlence).  If the string
*	does not specify a lockable location, the file will be ignored.
*	The nonvolatile library will search all drives within the system
*	until it finds this file and successfully accomplishes a Lock on
*	the location specified in the file.
@


40.18
log
@Fix to prevent writing NVRAM entry when disk is write protected.
(related to disk/fileio.asm 40.7)
Added AUTODOC background
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.17 93/03/26 10:20:18 brummer Exp Locker: brummer $
d8 5
d334 16
a349 26
		movem.l	d7/a4-a6,-(sp)		;Place the AppName pointer on the stack.
		move.l	a6,a5
		move.l	a0,a4
				;Temporarily kill all task based requester.
; ###		CLEARA	a1
		move.l	nv_ExecBase(a5),a6
; ###		JSRLIB	FindTask
; ###		move.l	d0,a0
; ###		move.l	pr_WindowPtr(a0),-(sp)
; ###		move.l	#-1,pr_WindowPtr(a0)
; ###		move.l	a0,-(sp)
; ##
; ## utility.library opened at nv.lib open
; ##				;The subroutine Merge needs version 37 of utility.library to function.
; ##		move.l	#37,d0
; ##		lea	UTILITY_LIB(pc),a1
; ##		JSRLIB	OpenLibrary
; ##		move.l	d0,d7
; ##		beq	gnvl_Exit
		ChkKillRequesters		; ###

		move.l	a4,a0			;Get the AppName pointer.
		bsr	SizeNVRAMList
		move.l	d0,-(sp)
		bsr	SizeDiskList
		add.l	(sp)+,d0		;Sum the size required from NVRAM and disk.
d357 4
a360 2
				;Got the memory.
		movem.l	d2-d4/a2-a3,-(sp)
a363 1

a365 1

d372 4
a375 2
				;No there was not.
		cmp.l	#0,a4
d377 4
a380 2
				;Search for a list of all applications.
		move.l	a2,d2			;Remember the start of memory used.
a384 1
; ##		exg	a6,d7			;Set up Utility base for the string compare.
a385 1
; ##		exg	d7,a6			;Restore Exec base.
d388 5
a392 4

				;Reset the end of available scratch memory.  a3
				;currently points to the first character of useful
				;stringns at the end of the allocated memory block.
d401 3
d411 3
a413 4
				;
				;There were no items for the current App.  So remove
				;the AppName node from the list.
				;
d419 5
a423 1

a424 1
; ##		exg	a6,d7			;Set up Utility base for the string compare.
a425 1
; ##		exg	d7,a6			;Restore Exec base.
d451 12
a462 6
SkipToNext:	tst.b	(a4)+
		bne.s	SkipToNext		;Skip the AppName string to the NULL.
				;Got to the NULL, actually points to the next non-NULL.
		cmp.l	a4,d3			;Have we processed all Apps?
		bgt	AddAppNode
				;All done now exit.
d464 3
a466 13
gnvl_Close:
; ##		exg	a1,d7

				;Warning:  This assumes noone changes a6.

; ##		JSRLIB	CloseLibrary
		move.l	(sp)+,d0		;Get the return value.
gnvl_Exit:
; ###		move.l	(sp)+,a0
; ###		move.l	(sp)+,pr_WindowPtr(a0)	;Reenable requesters.
		ChkRestoreRequesters		; ###

		movem.l	(sp)+,d7/a4-a6		;Clear stack and restore last two scratch registers.
@


40.17
log
@Fix AUTODOCs per CATS request.
Fix GetNVInfo() error that had MAX > AVAIL.
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.16 93/03/18 10:55:49 brummer Exp Locker: brummer $
d8 4
d119 66
d767 1
a767 1
		beq.s	sn_Exit			; if write is OK, j to return
@


40.16
log
@Replace 68020 instructions with generic 68000 code.
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.15 93/03/16 11:25:03 brummer Exp Locker: brummer $
d8 3
d132 1
a132 1
*	KillRequesters - Supress system requesters flag.  TRUE if all system
a147 7
; ###		moveq.l	#0,d0
; ###		move.l	d0,a1
; ###		JSRLIB	FindTask
; ###		move.l	d0,a0
; ###		move.l	pr_WindowPtr(a0),-(sp)
; ###		move.l	#-1,pr_WindowPtr(a0)
; ###		move.l	a0,-(sp)
d177 14
a190 9
Leave:		move.l	a4,d0			;Set up return parameter.
		move.l	(a4),d1
		divu.w	#10,d1
		andi.l	#$0FFFF,d1		; d1 gets word size operand
		move.l	d1,(a4)+		;Divide the sizes by 10.
		move.l	(a4),d1
		divu.w	#10,d1
		andi.l	#$0FFFF,d1		; d1 gets word size operand
		move.l	d1,(a4)+		;Both sizes.
a192 2
; ###		move.l	(sp)+,a0
; ###		move.l	(sp)+,pr_WindowPtr(a0)
d212 1
a212 1
*	to the AppName requested.
d214 1
a214 1
*	The string, AppName may not contain the '/' or ':' characters.
d216 1
a216 1
*	when requesting AppName string.
d221 1
a221 1
*	KillRequesters - Supress system requesters flag.  TRUE if all system
d228 1
a228 1
*	       entries in the nonvolatile storage for the AppName an
d414 1
a414 1
*	overlapping areas of memory.  Also this routine allows for
d492 1
a492 1
*	The strings, AppName and ItemName may not contain the '/' or ':'
d505 1
a505 1
*	KillRequesters - Supress system requesters flag.  TRUE if all system
d569 1
a569 1
*	The strings, AppName and ItemName may not contain the '/' or ':'
d584 1
a584 1
*	KillRequesters - Supress system requesters flag.  TRUE if all system
@


40.15
log
@Fix register push/pop mismatch in setprotection.
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.14 93/03/11 14:25:46 brummer Exp Locker: brummer $
d8 3
a140 1
		OPT P=68020
d183 2
a184 1
		divu.l	#10,d1
d187 2
a188 1
		divu.l	#10,d1
d370 2
a371 1
		divu.l	#10,d1
d554 1
a554 1
*	UWORD StoreNV (STRPTR, STRPTR, APTR, ULONG)
d608 4
a611 2
		move.l	d0,d2
		mulu.l	#10,d2			;Length is in units of tens of bytes.
d620 2
a621 1
		tst.l	a3
d623 2
a624 1
		tst.l	a4
@


40.14
log
@Remove LLName definition.  This is fix related to nonvolatilebase.i
40.5
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.13 93/03/09 14:02:46 brummer Exp Locker: brummer $
d8 4
d517 4
a520 2

		divu.w	#0,d0
d522 3
a524 3
		move.l	a6,a5
		move.l	a0,a3
		move.l	a1,a4
d537 1
a537 1
		movem.l	(sp)+,d7/a3-a6		;Clear stack and restore last two scratch registers.
@


40.13
log
@Fix autodocs to add invalid chars description.
Fix GetNVList autodoc to not suggest it returns an array
Make misc fixes suggested by Martit.
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.12 93/03/05 15:02:24 brummer Exp Locker: brummer $
d8 5
d519 3
a521 8
				;Temporarily kill all task based requester.
; ###		CLEARA	a1
; ###		move.l	nv_ExecBase(a5),a6
; ###		JSRLIB	FindTask
; ###		move.l	d0,a0
; ###		move.l	pr_WindowPtr(a0),-(sp)
; ###		move.l	#-1,pr_WindowPtr(a0)
; ###		move.l	a0,-(sp)
a528 2
; ###		move.l	(sp)+,a0
; ###		move.l	(sp)+,pr_WindowPtr(a0)
d696 2
a697 4
sn_Exit:	bclr.l	#31,d0				;Clear the high bit.
; ###		move.l	(sp)+,a0
; ###		move.l	(sp)+,pr_WindowPtr(a0)		;Restore requesters.
		ChkRestoreRequesters			; ###
d702 1
a702 2
; ## UTILITY_LIB	dc.b	'utility.library',0
LLName		dc.b	'lowlevel.library',0
@


40.12
log
@Update AUTODOCs.
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.11 93/03/05 12:58:36 brummer Exp Locker: brummer $
d8 3
d199 2
a200 4
*	Returns an array of structures about the items stored in the
*	nonvolatile storage.  Each element in the array consists of a
*	pointer to a NULL terminated string, a LONG indicating the size
*	of the item and a LONG indicated the protection of the item.
d202 3
a204 3
*	The array will be terminated by a element that with an indicated
*	size of zero.  The pointer of this element will point to the
*	AppName.
d214 1
a214 1
*	List - A pointer to a Exec MinLiat of NVEntrys.  A NULL will be
d479 4
d555 1
a555 1
*	The string, AppName and ItemName, should be short, but descriptive.
d561 4
d601 3
a603 9

				;Temporarily kill all task based requester.
; ###		CLEARA	a1
; ###		move.l	nv_ExecBase(a5),a6
; ###		JSRLIB	FindTask
; ###		move.l	d0,a0
; ###		move.l	pr_WindowPtr(a0),-(sp)
; ###		move.l	#-1,pr_WindowPtr(a0)
; ###		move.l	a0,-(sp)
d619 1
a619 1
		beq.s	8$			; if yes, j to OK
a622 1
8$:
d652 1
a652 1
		move.l	a5,a6			;The subroutines all expect NVBase in a6.
d694 3
a696 1
				;NVRAM failed restore disk failure.
d698 1
a698 1
sn_Exit:	and.l	#$7FFFFFFF,d0		;Clear the high bit.
d700 2
a701 2
; ###		move.l	(sp)+,pr_WindowPtr(a0)	;Restore requesters.
		ChkRestoreRequesters		; ###
@


40.11
log
@Remove origonal method of disabling requesters and use the parameterized method instead.
If the parameter is TRUE, a open of lowlevel.library will be done
and a call will be made to KillReq() and RestoreReq()
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.10 93/03/04 15:17:39 brummer Exp Locker: brummer $
d8 5
d114 1
a114 1
*	KillRequesters - Allow system requesters flag.  TRUE if all system
d207 2
a208 2
*		  to be matched.
*	KillRequesters - Allow system requesters flag.  TRUE if all system
d479 6
a484 3
*	AppName - Pointer to a NULL terminated string.
*	ItemName - Pointer to a NULL terminated string.  AppName and ItemName
*		   together uniquely identify the data.
d487 1
a487 1
*	KillRequesters - Allow system requesters flag.  TRUE if all system
d548 2
d551 4
a554 4
*	They need to be short since nonvolatile storage for a stand alone
*	game system is limited.  The game system allows the user to
*	selectively remove entries from storage, so the string should be
*	desriptive.
d558 2
a559 1
*		  creating the data.
d561 2
a562 1
*		   within the application.
d567 1
a567 1
*	KillRequesters - Allow system requesters flag.  TRUE if all system
@


40.10
log
@Fix code to allow two NULL strings for App/Item access to 
reserved data.  Prevent access if either but not both are NULL.
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.9 93/03/02 11:16:34 brummer Exp Locker: brummer $
d8 4
d99 2
a100 2
*	Information = GetNVInfo ()
*	d0
d102 1
a102 1
*	struct NVInfo * GetNVInfo (VOID)
d109 3
a111 1
*	NONE
d126 8
a133 7
		moveq.l	#0,d0
		move.l	d0,a1
		JSRLIB	FindTask
		move.l	d0,a0
		move.l	pr_WindowPtr(a0),-(sp)
		move.l	#-1,pr_WindowPtr(a0)
		move.l	a0,-(sp)
d170 5
a174 2
gnvi_Exit:	move.l	(sp)+,a0
		move.l	(sp)+,pr_WindowPtr(a0)
d185 2
a186 2
*	List = GetNVList (AppName)
*	d0		  a0
d188 1
a188 1
*	struct MinList * GetNVList (STRPTR)
d203 3
d245 1
a245 1
		CLEARA	a1
d247 7
a253 5
		JSRLIB	FindTask
		move.l	d0,a0
		move.l	pr_WindowPtr(a0),-(sp)
		move.l	#-1,pr_WindowPtr(a0)
		move.l	a0,-(sp)
d260 1
d334 1
a334 1
		bsr.s	Merge
d374 5
a378 2
gnvl_Exit:	move.l	(sp)+,a0
		move.l	(sp)+,pr_WindowPtr(a0)	;Reenable requesters.
d461 2
a462 2
*	Success = SetNVProtection (AppName, ItemName, Mask)
*	d0			   a0	    a1	      d2
d464 1
a464 1
*	BOOL SetNVProtection (STRPTR, STRPTR, LONG)
d479 3
d502 9
a510 7
		CLEARA	a1
		move.l	nv_ExecBase(a5),a6
		JSRLIB	FindTask
		move.l	d0,a0
		move.l	pr_WindowPtr(a0),-(sp)
		move.l	#-1,pr_WindowPtr(a0)
		move.l	a0,-(sp)
d515 5
a519 2
		move.l	(sp)+,a0
		move.l	(sp)+,pr_WindowPtr(a0)
d529 2
a530 2
*	Error = StoreNV (AppName, ItemName, Data, Length)
*	d0		 a0	  a1	    a2    d0
d555 3
d582 8
a589 7
		CLEARA	a1
		move.l	nv_ExecBase(a5),a6
		JSRLIB	FindTask
		move.l	d0,a0
		move.l	pr_WindowPtr(a0),-(sp)
		move.l	#-1,pr_WindowPtr(a0)
		move.l	a0,-(sp)
d683 4
a686 2
		move.l	(sp)+,a0
		move.l	(sp)+,pr_WindowPtr(a0)	;Restore requesters.
d690 2
a691 1
UTILITY_LIB	dc.b	'utility.library',0
@


40.9
log
@Modified code to use already opened utility.library from nv.lib base.
All changes are marked with an ## in the comment fields.
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.8 93/02/26 17:15:45 brummer Exp Locker: brummer $
d8 4
d559 3
a564 1

d567 14
a580 1

d591 3
a593 1

d604 3
a606 1

@


40.8
log
@fix incorrect branch after writing NV disk
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.7 93/02/26 12:20:17 Jim2 Exp Locker: brummer $
d8 3
d235 6
a240 6
				;The subroutine Merge needs version 37 of utility.library to function.
		move.l	#37,d0
		lea	UTILITY_LIB(pc),a1
		JSRLIB	OpenLibrary
		move.l	d0,d7
		beq	gnvl_Exit
d278 1
a278 1
		exg	a6,d7			;Set up Utility base for the string compare.
d280 1
a280 1
		exg	d7,a6			;Restore Exec base.
d313 1
a313 1
		exg	a6,d7			;Set up Utility base for the string compare.
d315 1
a315 1
		exg	d7,a6			;Restore Exec base.
d347 2
a348 1
gnvl_Close:	exg	a1,d7
d352 1
a352 1
		JSRLIB	CloseLibrary
d365 2
a366 2
*	Start = Merge (Start, End, EndOfMergeBlock, UtilBase)
*	a3	       d2     a2   a3		    a6
d390 2
a391 1
		movem.l	d2-d3/a4,-(sp)
d430 1
a430 1
		movem.l	(sp)+,d2-d3/a4
@


40.7
log
@Corrected error in parsing total NVRAM size in GetNVInfo.
If there are no ItemNames for an AppName in GetNVList, do not
list the AppName.
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.6 93/02/25 19:29:25 brummer Exp Locker: Jim2 $
d8 5
d612 1
a612 1
		bne.s	sn_Exit
@


40.6
log
@fix out of range branch because of previous fix
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.5 93/02/25 18:53:07 brummer Exp Locker: brummer $
d8 3
d131 3
a133 3
		move.l	a4,a5			;We need to duplcate the pointer for a test later.
		cmp.l	(sp)+,(a5)+		;Is there more space on disk, or NVRAM.
		bpl.s	MoreOnDisk
a134 1
		subq.l	#4,sp
d141 1
a141 1
MoreOnDisk:	add.l	#NVINFO_SIZE-4,sp		;Clear away NVInfo structure from the stack.
d291 14
a304 1
		move.l	a3,d4			;Remember the end of memory for the termination of creating elements.
@


40.5
log
@test d0 on return from WriteNVRAM calls
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.4 93/02/25 08:55:54 Jim2 Exp Locker: brummer $
d8 3
d535 1
a535 1
		beq.s	sn_Exit			;Null ItemName is wrong.
@


40.4
log
@Added StoreNV.
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.3 93/02/23 13:17:28 Jim2 Exp Locker: Jim2 $
d8 3
d580 1
d596 1
@


40.3
log
@GetNVList also talks in quantities of ten bits.  GetNVList
builds an ExecList rather than returning an array of NVEntry(s).
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.2 93/02/18 11:03:58 Jim2 Exp Locker: Jim2 $
d8 4
d48 1
d58 2
d65 1
d77 1
a77 1
*	struct NVInfo * GetNVList (VOID)
a82 9
*	When a progrm first begins it should use this function to check if
*	there is enough free space to store whatever may be stored (ie a
*	saved game, or a high score table).  If there is not, the user
*	should be notified so they are not left in a lurch when they want to
*	save something.
*
*	The check and possible user notification should be redone after
*	every save.
*
d278 2
a279 2
GetItems:	subq.l	#1,a3
		move.l	a2,d2			;Remember where the list of ItemNames is to start.
d417 1
a417 3
*	will be respected.  If this bit is set the item will not be deleted,
*	either by the DeleteNV, or by automatic purging.  If this bit is
*	clear the item can be deleted.
d423 2
a424 1
*	Mask - The new protection mask.
d435 6
a440 1
		movem.l	d3/a3-a6,-(sp)		;Place the AppName pointer on the stack.
d459 140
@


40.2
log
@Added SetNVProtection.  The values returned by GetNVInfoare in
tens of bytes, not single bytes.  The structure returned
by GetNVList includes the protection which needs to be set 
to no protection for AppNames.
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.1 93/02/16 13:47:59 Jim2 Exp Locker: Jim2 $
d8 6
d159 1
a159 1
*	struct NVItem * GetNVList (char *)
d176 4
a179 4
*	List - An array of NVItems.  The array is terminated by an element
*	       that identifies an Item of size zero.  A NULL will be
*	       returned if there is insufficient memory, or there are no
*	       entries in the nonvolatile storage for the AppName.
d193 2
a194 2
*	Memory space is allocated for all of the array elements and all of the
*	strings.  The array must be located at the start of allocated memory.
d204 1
a204 1
*	in front of all pevious lists.  Then the array elements are created
d232 1
a232 11
		beq	gnvl_Exit
				;There is at least something saved.
		cmp.l	#0,a4
		beq.s	IncludeAppName
				;Need to include the space for a copy of the AppName.
		move.l	a4,a0
NextChar:	addq.l	#1,d0
		tst.b	(a0)+
		bne.s	NextChar

IncludeAppName:	add.l	#4+NVITEM_SIZE,d0	;Add a long word to remember the size.  Plus the termination elements.
d237 1
a237 1
		tst.l	d0
d240 1
a240 1
		movem.l	d2-d4/a2-a3/a6,-(sp)	;a6 is pushed as a place holder
d244 4
d249 2
a250 2
		add.l	-4(a3),a3
		subq.l	#5,a3			;Get pointer to the last byte of the allocation.
d252 3
d256 1
a256 14
		beq.s	MultipleApps
				;Copy the AppName to the memory block.
		move.l	a3,d2
		move.l	a4,a0
		moveq.w	#0,d0
SearchForEnd:	addq.w	#1,d0
		tst.b	0(a0,d0.w)
		bne.s	SearchForEnd
				;Got to the NULL
		subq.l	#1,d0			;Move back to the last non-NULL.
CopyName:	move.b	0(a0,d0),-(a3)		;Walk back throught the string coping.
		dbf.s	d0,CopyName
		move.l	a3,a4			;Set the AppName pointer to this copy.
		bra.s	GetItems
d258 1
a258 1
MultipleApps:	move.l	a2,d2			;Remember the start of memory used.
d272 7
a278 1

d291 8
a298 4
				;Create an array element for this Items.
		move.l	a3,(a2)+
		move.l	#0,(a2)			;Initialize the size to zero.
		move.l	#0,4(a2)
d301 5
a305 1
		add.l	#NVITEM_SIZE-4,a2	;Advance the to the next array element.
a311 3
		move.l	a4,(a2)+		;Create an array element for the AppName node.
		move.l	#0,(a2)+		;AppNames are identified by a size of zero.
		move.l	#0,(a2)+		;And are not locked.
d316 3
a318 6
		bgt.s	GetItems
				;All done.  Now cleanup.
		move.l	#0,(a2)+		;Generate the extra NULL - Name
		move.l	#0,(a2)+		;Generate the extra NULL - Size
		move.l	#0,(a2)+		;Generate the extra NULL - Protect
		movem.l	(sp)+,d2-d4/a2-a3	;Set up the return value/Restore the 3 scratch registers.
d324 1
a324 1
		move.l	(sp)+,d0
d326 1
a326 1
		move.l	(sp)+,pr_WindowPtr(a0)
d411 1
a411 1
*	BOOL SetNVProtection (char *, char *, LONG)
d417 1
a417 1
*	Although Mask is LONG only the delete bit, NVIF_DELETE/NVIB_DELETE,
@


40.1
log
@Altered GetNVList to return the new data structure.
@
text
@d3 1
a3 1
*	$Id: main.asm,v 40.0 93/02/09 10:23:35 Jim2 Exp Locker: Jim2 $
d8 3
d37 1
d45 2
d51 1
d89 1
d131 6
d158 2
a159 2
*	pointer to a NULL terminated string and a LONG indicating the
*	size of the item.
d175 7
d183 1
a183 1
*	FreeNVData()
d186 16
d203 1
a203 1
		movem.l	a4-a6,-(sp)		;Place the AppName pointer on the stack.
d206 1
a206 1

d214 6
d227 1
a227 1

d230 1
a230 1

d236 1
a236 1
IncludeAppName:	add.l	#4+8,d0			;Add a long word to remember the size.  Plus the termination elements.
d242 1
a242 1
		beq	gnvl_Exit
d244 1
a244 1
		movem.l	d2-d4/a2-a3,-(sp)
d247 1
a247 1
		move.l	a3,-(sp)		;Remember our return parameter.
d250 2
a251 2
		subq.l	#5,a3			;Add the number of bytes for string stuff.
		move.l	a3,d3			;Set up of the case of a single application.
d254 1
a254 2


d261 3
a263 3
		subq.l	#1,d0

CopyName:	move.b	0(a0,d0),-(a3)
d265 1
a265 1
		move.l	a3,a4
a266 2


d268 2
a269 2
MultipleApps:	move.l	a2,d2
		move.l	a3,d3
d273 4
a276 2
		bsr.s	Merge
		move.l	a3,a4
d278 5
d284 2
a285 3
				;Add all of the Items for a given application.
		move.l	a2,d2
		move.b	#0,(a2)+
d288 2
a289 1
		move.l	a3,d4
d291 2
a292 1
		move.l	a3,-(sp)
d294 2
a295 2
		bge.s	DoneItems

d297 2
a298 1
		move.l	#0,(a2)
d301 2
a302 2
		addq.l	#4,a2
NextItem:	tst.b	(a3)+
d304 1
a304 1

d306 5
a310 4

DoneItems	move.l	(sp)+,a3
		move.l	a4,(a2)+
		move.l	#0,(a2)+
d312 2
a313 1
		bne.s	SkipToNext
d317 7
a323 3
		move.l	#0,(a2)+		;Generate the extra NULL
		move.l	#0,(a2)+		;Generate the extra NULL
		movem.l	(sp)+,d0/d2-d4/a2-a3	;Set up the return value/Restore the 3 scratch registers.
d325 2
d329 1
a329 1
		movem.l	(sp)+,a4-a6		;Clear stack and restore last two scratch registers.
d338 2
a339 2
*	Start = Merge (Start, End, EndOfMergeBlock)
*	a3	       d2     a2   a3
d363 3
a365 3
		movem.l	d2/a4,-(sp)
		move.b	#0,d1			;Need a NULL.
		move.b	d1,(a3)			;Make sure the list ends with a NULL.
a371 1
		move.l	a3,d0			;Remember where the copy 'starts'.
d376 2
a377 2
		move.l	d2,a0			;Walk looking for duplicates from here.
CheckingForDup:	cmp.l	a2,a0
d380 1
a380 1
		tst.b	(a0)+
d383 7
a389 9
		subq.l	#1,a0
		move.l	a0,a1			;Remember start of the string, incase we need to clear it.
		move.l	a3,a4			;Get start of the comparison string.
		addq.l	#1,a4			;Get to first character.
Matching:	cmp.b	(a0)+,(a4)+
		beq.s	TestSize

		subq.l	#1,a0			;Could already be past the NULL.
NULLLoop:	tst.b	(a0)+
d392 1
a392 1
		subq.l	#1,a0
a393 3

TestSize:	cmp.l	a4,d0
		bne.s	Matching		;Stay as long as they match and are non NULL.
d395 2
a396 2
ClearWord:	move.b	d1,(a1)+
		cmp.l	a0,a1
a399 1
				;The word was not a duplicate, skip to the end of the word.
d401 57
a457 2
AllDone:	addq.l	#1,a3
		movem.l	(sp)+,d2/a4
d460 1
@


40.0
log
@GetNVList now sorts and combines the lists rather than depending
on the NVRAM routines.
@
text
@d3 1
a3 1
*	$Id: main.asm,v 39.0 93/02/03 11:07:48 Jim2 Exp Locker: Jim2 $
d8 4
d32 3
a34 3
		XREF	GetNVRAMApps
		XREF	GetNVRAMItems
				;Disk/
d36 1
d38 3
a40 2
		XREF	GetDiskApps
		XREF	GetDiskItems
d78 1
a78 1
*	FreeNVData(), SizeNVData()
d108 1
a108 1
		move.l	nv_NVRAMCopy(a5),a1
a109 1
		bsr	GetNVRAMInfo		;Get information for the NVRAM chip.
d139 1
a139 1
*	char * GetNVList (char *)
d142 8
a149 4
*	Returns a list of NULL terminated strings.  This list is all of the
*	ItemNames that have been stored in nonvolatile storage for the given
*	AppName.  The end of the list is a NULL string (ie the list ends
*	with two consecutive NULLs).
d156 3
a158 2
*	List - NULL terminated list of NULL terminated string.  A NULL will
*	       be returned if there is insufficient memory, or there are no
d162 1
a162 1
*	FreeNVData(), SizeNVData()
d166 1
a166 1
		movem.l	a0/a5-a6,-(sp)		;Place the AppName pointer on the stack.
d168 1
d170 1
a170 2
		moveq.l	#0,d0
		move.l	d0,a1
d178 1
a178 2
		move.l	nv_NVRAMCopy(a5),a1	;Give the NVRAM routines its data.
		move.l	4*2(sp),a0		;Get the AppName pointer.
d184 10
a193 1
		addq.l	#4,d0			;Add a long word to remember the size.
d199 1
a199 1
		beq.s	gnvl_Exit
d201 1
a201 1
		movem.l	d2/a2-a3,-(sp)
d208 19
a226 3
		move.l	a3,d2			;Set up of the case of a single application.
		tst.l	4*6(sp)
		bne.s	DoApp
d228 2
a229 1
		movem.l	a2/a3,-(sp)
d231 4
a234 5
		bsr	GetDiskApps
		move.l	nv_NVRAMCopy(a5),a1	;Give the NVRAM routine its data.
		bsr	GetNVRAMApps
		move.l	(sp)+,d2
		bsr.s	MergeApps
d236 1
a236 6
		move.l	(sp)+,d2		;Get d2 pointing to the end of memory.

MultipleApp:	move.l	a2,4*6(sp)		;Set the App pointer to the new App name.
				;Copy the App name to the next free spot in the list.
Loop:		move.b	(a3)+,(a2)+
		bne.s	Loop
d238 27
a264 14
DoApp:		move.l	a2,-(sp)
		move.l	a3,a2
		move.l	4*7(sp),a0		;Get the pointer to the App for the Item selection.
		bsr	GetDiskItems
		move.l	4*7(sp),a0		;Get the pointer to the App for the Item selection.
		move.l	nv_NVRAMCopy(a5),a1	;Give the NVRAM routine its data.
		bsr	GetNVRAMItems
		move.b	#0,-(a2)		;Need leading NULL for MergeItems
		move.l	a2,a0
		move.l	(sp)+,a2		;Set up registers for call
		bsr.s	MergeItems
		move.b	#0,(a2)+		;Generate the extra NULL
		cmp.l	a3,d2			;Have we processed all Apps?
		bgt.s	MultipleApp
d266 3
a268 2
		move.b	#0,(a2)+		;Generate the extra NULL
		movem.l	(sp)+,d0/d2/a2-a3	;Set up the return value/Restore the 3 scratch registers.
d272 1
a272 1
		movem.l	(sp)+,a0/a5-a6		;Clear stack and restore last two scratch registers.
d275 1
a275 1
*****l* main.asm/MergeApps ***************************************************
d278 1
a278 1
*	MergeApps - Merges the lists of applications.
d281 2
a282 2
*	Start = MergeApps (StartOfApps, EndOfApps, EndOfMergeBlock)
*	a3		   d2		a2	   a3
d292 2
a293 3
*	StartOfApps - Pointer the NULL that is located at the start of the
*		      string.
*	EndOfApps - Pointer beyond the NULL that terminates the last string.
a302 2
*   SEE ALSO
*	MergeItems()
d305 1
a305 1
MergeApps
d317 2
a318 2
CopingAppName:	move.b	-(a2),-(a3)
		bne.s	CopingAppName		;Copy through the terminating NULL.
d331 2
a332 2
MatchingApp:	cmp.b	(a0)+,(a4)+
		beq.s	TestAppSize
d341 2
a342 2
TestAppSize:	cmp.l	a4,d0
		bne.s	MatchingApp		;Stay as long as they match and are non NULL.
a352 76
		rts

*****l* main.asm/MergeItems **************************************************
*
*   NAME
*	MergeItems - Merges the lists of Items.
*
*   SYNOPSIS
*	End = MergeItems (EndOfItems, StartOfItems, StartOfMergeBlock)
*	a2		  a3	      a0	    a2
*
*   FUNCTION
*	Takes a list of strings and removes duplicates.
*
*	This function assumes the input list and output list occupy
*	overlapping areas of memory.  Also this routine allows for
*	several copies of the data.
*
*   INPUTS
*	StartOfItems - Pointer to a NULL that is located before the first
*		       string.
*	EndOfItems - Pointer beyond NULL that terminates the last string.
*	StartOfMergeBlock - Pointer to the first byte in the memory block
*			    to contain the merged list.
*
*   RESULT
*	End - Pointer past the last NULL in the merged list.
*
*
*   SEE ALSO
*	MergeApps()
*
******************************************************************************
MergeItems
		movem.l	a4/a6,-(sp)
		move.b	#0,d1			;Need a NULL.
NextItem:	cmp.l	a3,a0			;Have we searched the whole list?
		beq.s	DoneItem
				;Still looking.  Skip NULLs
		tst.b	(a0)+
		beq.s	NextItem		;The current byte is NULL, check is it the last?
				;Ok got a new string.
		move.l	a2,d0			;Remember where the copy 'starts'.
		move.b	-1(a0),(a2)+
CopingItem:	move.b	(a0)+,(a2)+
		bne.s	CopingItem		;Copy including the terminating NULL.
				;Copied the string.
		move.l	a0,a1			;Walk looking for duplicates from here.
DupItem:	cmp.l	a3,a1
		beq.s	NextItem		;The complete list has been checked.

		tst.b	(a1)+
		beq.s	DupItem			;Skip over NULLs.
				;At the start of a new string
		subq.l	#1,a1			;Since everything is postincrement need to move back to the NULL.
		move.l	a1,a6			;Remember start of the string, incase we need to clear it.
		move.l	d0,a4			;Get start of the comparison string.
MatchingItem:	cmp.b	(a1)+,(a4)+
		beq.s	TestItemSize
		subq.l	#1,a1			;Could already be at the NULL.
ItemLoop:	tst.b	(a1)+
		bne.s	ItemLoop

		bra.s	DupItem

TestItemSize:	cmp.l	a2,a4
		bne.s	MatchingItem		;Stay as long as they match and are non NULL.
				;Found a duplicate word.  Clear it from the original list.
ClearItem:	move.b	d1,(a6)+
		cmp.l	a1,a6
		bne.s	ClearItem

		bra.s	DupItem
				;The word was not a duplicate, skip to the end of the word.

DoneItem:	movem.l	(sp)+,a4/a6
@


39.0
log
@Initial Release - Tested Disk functions.
@
text
@d3 1
a3 1
*	$Id: $
d7 3
a9 1
*	$Log: $
d11 1
d28 2
a29 2
		XREF	PrependNVRAMApps
		XREF	AddNVRAMItems
d33 1
a33 1
		XREF	ReverseAddDiskApps
d169 1
a170 1
		move.l	(sp),a0			;Get the AppName pointer.
d174 1
a174 1
		beq.s	gnvl_Exit
d183 1
a183 4
		movem.l	a2-a4,-(sp)		;Need three registers.
				;a2 = End of last Item added.
				;a3 = Next App to be added
				;a4 = End of list of Apps
d186 2
a187 2
		move.l	a3,a2			;Fill the Items from the start.
		move.l	a3,-(sp)		;Need to remember the start of the List for a return value.
d189 3
a191 3
		subq.l	#4,a3			;Add the number of bytes for string stuff.
		move.l	a3,a4			;Fill the Apps from the rear.
		tst.l	16(sp)
d194 3
a196 1
		bsr	ReverseAddDiskApps
d198 5
a202 2
		bsr	PrependNVRAMApps
		addq.l	#1,a3			;Get back to the first character.
d204 1
a204 1
MultipleApp:	move.l	a2,16(sp)		;Set the App pointer to the new App name.
d209 3
a211 1
DoApp:		move.l	16(sp),a0		;Get the pointer to the App for the Item selection.
d213 1
a213 1
		move.l	16(sp),a0		;Get the pointer to the App for the Item selection.
d215 5
a219 1
		bsr	AddNVRAMItems
d221 1
a221 1
		cmp.l	a3,a4			;Have we processed all Apps?
d225 1
a225 1
		movem.l	(sp)+,d0/a2-a4		;Set up the return value/Restore the 3 scratch registers.
d231 160
@
