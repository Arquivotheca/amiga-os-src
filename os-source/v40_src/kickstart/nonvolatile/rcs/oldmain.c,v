head     40.17;
branch   ;
access   ;
symbols  V40_35:40.17 V40_34:40.16 rel40_10:40.4 rel40_9:40.4 rel40_8:40.4 rel40_7:40.4 rel40_6:40.3 rel40_5:40.3 rel40_4:40.2 rel40_3:40.2 rel40_2:40.1 rel40_1:40.0 rel39_1:39.1;
locks    ; strict;
comment  @ * @;


40.17
date     93.08.03.11.03.43;  author vertex;  state Exp;
branches ;
next     40.16;

40.16
date     93.08.03.09.46.00;  author vertex;  state Exp;
branches ;
next     40.15;

40.15
date     93.07.30.17.08.50;  author vertex;  state Exp;
branches ;
next     40.14;

40.14
date     93.04.07.13.53.20;  author brummer;  state Exp;
branches ;
next     40.13;

40.13
date     93.03.26.16.22.09;  author brummer;  state Exp;
branches ;
next     40.12;

40.12
date     93.03.26.10.19.39;  author brummer;  state Exp;
branches ;
next     40.11;

40.11
date     93.03.18.14.38.41;  author brummer;  state Exp;
branches ;
next     40.10;

40.10
date     93.03.18.14.32.24;  author brummer;  state Exp;
branches ;
next     40.9;

40.9
date     93.03.12.14.59.50;  author brummer;  state Exp;
branches ;
next     40.8;

40.8
date     93.03.11.10.35.18;  author brummer;  state Exp;
branches ;
next     40.7;

40.7
date     93.03.09.13.53.58;  author brummer;  state Exp;
branches ;
next     40.6;

40.6
date     93.03.05.15.02.52;  author brummer;  state Exp;
branches ;
next     40.5;

40.5
date     93.03.05.14.36.09;  author brummer;  state Exp;
branches ;
next     40.4;

40.4
date     93.02.25.09.03.33;  author Jim2;  state Exp;
branches ;
next     40.3;

40.3
date     93.02.19.15.24.30;  author Jim2;  state Exp;
branches ;
next     40.2;

40.2
date     93.02.16.13.49.36;  author Jim2;  state Exp;
branches ;
next     40.1;

40.1
date     93.02.10.17.28.06;  author Jim2;  state Exp;
branches ;
next     40.0;

40.0
date     93.02.09.10.22.36;  author Jim2;  state Exp;
branches ;
next     39.1;

39.1
date     93.02.03.13.49.48;  author Jim2;  state Exp;
branches ;
next     39.0;

39.0
date     93.02.03.11.19.09;  author Jim2;  state Exp;
branches ;
next     1.6;

1.6
date     93.01.19.12.17.32;  author jerryh;  state Exp;
branches ;
next     1.5;

1.5
date     93.01.08.15.26.23;  author jerryh;  state Exp;
branches ;
next     1.4;

1.4
date     92.10.12.10.42.11;  author jerryh;  state Exp;
branches ;
next     1.3;

1.3
date     92.10.08.15.54.26;  author jerryh;  state Exp;
branches ;
next     1.2;

1.2
date     92.10.08.13.22.21;  author jerryh;  state Exp;
branches ;
next     1.1;

1.1
date     92.10.02.11.34.02;  author jerryh;  state Exp;
branches ;
next     ;


desc
@library entry routines and library initialization.
@


40.17
log
@Autodoc cleanup
@
text
@
#include <exec/types.h>
#include <exec/execbase.h>
#include <exec/memory.h>
#include <exec/io.h>
#include <exec/resident.h>

#include <dos/dosextens.h>

#include <pragmas/exec_pragmas.h>
#include <clib/exec_protos.h>

#define LOWLEVEL_PRIVATE_PRAGMAS
#include <pragmas/lowlevel_pragmas.h>
#include <clib/lowlevel_protos.h>

#include "nonvolatile.h"
#include "nonvolatilebase.h"

#define SysBase NVBase->nv_ExecBase
#define LowLevelBase  NVBase->nv_LowLevelBase

/* NVRAM/ */
extern APTR __asm ReadNVRAM (register __a0 STRPTR AppName, register __a1 STRPTR ItemName, register __a6 struct NVBase *NVBase);
extern BOOL __asm DeleteNVRAM (register __a0 STRPTR AppName, register __a1 STRPTR ItemName, register __a6 struct NVBase *NVBase);

/* Disk/ */
extern APTR __asm ReadDisk (register __a0 STRPTR AppName, register __a1 STRPTR ItemName, register __a6 struct NVBase *NVBase);
extern BOOL __asm DeleteDisk (register __a0 STRPTR AppName, register __a1 STRPTR ItemName, register __a6 struct NVBase *NVBase);

/* Lowlevel.library */
extern void KillReq (void);
extern void RestoreReq (void);


/****** nonvolatile.library/GetCopyNV ****************************************
*
*   NAME
*	GetCopyNV -- return a copy of an item stored in nonvolatile storage.
*		     (V40)
*
*   SYNOPSIS
*	data = GetCopyNV(appName, itemName, killRequesters);
*	D0		 A0	  A1	    D1
*
*	APTR GetCopyNV(STRPTR, STRPTR, BOOL);
*
*   FUNCTION
*	Searches the nonvolatile storage for the indicated appName and
*	itemName. A pointer to a copy of this data will be returned.
*
*	The strings appName and itemName may not contain the '/' or ':'
*	characters. It is recommended that these characters be blocked
*	from user input when requesting appName and itemName strings.
*
*   INPUTS
*	appName - NULL terminated string indicating the application name
*		  to be found. Maximum length is 31.
*	itemName - NULL terminated string indicated the item within the
*		   application to be found. Maximum length is 31.
*	killRequesters - Suppress system requesters flag. TRUE if all system
*			 requesters are to be suppressed during this function.
*			 FALSE if system requesters are allowed.
*
*   RESULT
*	data - pointer to a copy of the data found in the nonvolatile storage
*	       assocated with appName and itemName. NULL will be returned
*	       if there is insufficient memory or the appName/itemName does
*	       not exist.
*
*   SEE ALSO
*	FreeNVData(), <libraries/nonvolatile.h>
*
******************************************************************************/

APTR __asm GetCopyNV(register __a0 STRPTR AppName, register __a1 STRPTR ItemName,
                       register __d1 BOOL KillRequesters, register __a6 struct NVBase *NVBase)
{
	APTR result;

	if ( (AppName != NULL) && (ItemName !=NULL) )
	{
		if (KillRequesters) KillReq();
		if ((result = ReadDisk(AppName, ItemName, NVBase)) == NULL) result = ReadNVRAM(AppName,ItemName,NVBase);
		if (KillRequesters) RestoreReq();
	}
	else
	{
		result = NULL;
	};
	return(result);

} /* GetCopyNV */




/****** nonvolatile.library/FreeNVData ***************************************
*
*   NAME
*	FreeNVData -- release the memory allocated by a function of this
*		      library. (V40)
*
*   SYNOPSIS
*	FreeNVData(data);
*		   A0
*
*	VOID FreeNVData(APTR);
*
*   FUNCTION
*	Frees a block of memory that was allocated by any of the following:
*	GetCopyNV(), GetNVInfo(), GetNVList().
*
*   INPUTS
*	data - pointer to the memory block to be freed. If passed NULL,
*	       this function does nothing.
*
*   SEE ALSO
*	GetCopyNV(), GetNVInfo(), GetNVList()
*
******************************************************************************/
void __asm FreeNVData(register __a0 void *Data, register __a6 struct NVBase *NVBase)
{

	if (Data != NULL) FreeMem(&((ULONG *)Data)[-1], ((ULONG *)Data)[-1]);

} /* FreeNVData */




/****** nonvolatile.library/DeleteNV *****************************************
*
*   NAME
*	DeleteNV -- remove an entry from nonvoltatile storage. (V40)
*
*   SYNOPSIS
*	success = DeleteNV(appName, itemName, killRequesters);
*	D0		   A0	    A1	      D1
*
*	BOOL DeleteNV(STRPTR, STRPTR, BOOL);
*
*   FUNCTION
*	Searches the nonvolatile storage for the indicated entry and removes
*	it.
*
*	The strings appName and itemName may not contain the '/' or ':'
*	characters. It is recommended that these characters be blocked
*	from user input when requesting AppName and ItemName strings.
*
*   INPUTS
*	appName - NULL terminated string identifing the application that
*		  created the data. Maximum length is 31.
*	ItemName - NULL terminated string uniquely identifing the data
*		   within the application. Maximum length is 31.
*	killRequesters - suppress system requesters flag. TRUE if all system
*			 requesters are to be suppressed during this function.
*			 FALSE if system requesters are allowed.
*
*   RESULT
*	success - TRUE will be returned if the entry is found and deleted.
*		  If the entry is not found, FALSE will be returned.
*
******************************************************************************/


BOOL __asm DeleteNV(register __a0 STRPTR AppName, register __a1 STRPTR ItemName,
                      register __d1 BOOL KillRequesters, register __a6 struct NVBase *NVBase)
{
	BOOL	result;
	if ( (AppName != NULL) && (ItemName !=NULL) )
	{
		if (KillRequesters) KillReq();
		result = DeleteNVRAM(AppName, ItemName, NVBase) | DeleteDisk(AppName, ItemName, NVBase);
		if (KillRequesters) RestoreReq();
	}
	else
	{
		result = NULL;
	};
	return(result);
}




@


40.16
log
@Typo fix in autodocs
@
text
@d39 2
a40 1
*	GetCopyNV - Returns an items stored in nonvolatile storage.
d43 2
a44 2
*	Data = GetCopyNV (AppName, ItemName, KillRequesters)
*	d0		  a0	   a1	     d1
d46 1
a46 1
*	APTR GetCopyNV (STRPTR, STRPTR, BOOL)
d49 2
a50 2
*	Searches the nonvolatile storage for the indicated AppName and
*	ItemName.  A pointer to a copy of this data will be returned.
d52 3
a54 3
*	The strings AppName and ItemName may not contain the '/' or ':'
*	characters.  It is recommended that these characters be blocked
*	from user input when requesting AppName and ItemName strings.
d57 5
a61 7
*	AppName - NULL terminated string indicating the application name
*		  to be found.  Maximum character length is 31.
*		  A NULL string is not valid
*	ItemName - NULL terminated string indicated the item within the
*		   application to be found.  Maximum character length is 31.
*		   A NULL string is not valid.
*	KillRequesters - Suppress system requesters flag.  TRUE if all system
d66 3
a68 3
*	Data - Pointer to a copy of data found in the nonvolatile storage
*	       assocated with AppName and ItemName.  NULL will be returned
*	       if there is insufficient memory or the AppName/ItemName does
d72 1
a72 1
*	FreeNVData()
d101 2
a102 2
*	FreeNVData - Release the memory allocated by a function of this
*		     library.
d105 2
a106 2
*	FreeNVData (Data)
*		   a0
d108 1
a108 1
*	VOID FreeNVData (APTR)
d115 2
a116 4
*	Data - Pointer to the memory block to be freed.
*
*   RESULT
*	NONE
d135 1
a135 1
*	DeleteNV - Remove an entry from nonvoltatile storage
d138 2
a139 2
*	Success = DeleteNV (AppName, ItemName, KillRequesters)
*	d0		    a0	     a1	       d1
d141 1
a141 1
*	BOOL DeleteNV (STRPTR, STRPTR, BOOL)
d147 2
a148 2
*	The strings AppName and ItemName may not contain the '/' or ':'
*	characters.  It is recommended that these characters be blocked
d152 2
a153 3
*	AppName - NULL terminated string identifing the application that
*		  created the data.  Maximum character length is 31.
*		  A NULL string is not valid.
d155 2
a156 3
*		   within the application.  Maximum character length is 31.
*		   A NULL string is not valid.
*	KillRequesters - Suppress system requesters flag.  TRUE if all system
d161 1
a161 1
*	Success - TRUE will be returned if the entry is found and deleted.
@


40.15
log
@*** empty log message ***
@
text
@d48 1
a48 1
*	Seaches the nonvolatile storage for the indicated AppName and
@


40.14
log
@Add check for 0 AppName and Item names in GetCopyNV() and DeleteNV() functions.
@
text
@a0 70
/*****************************************************************************
*
*	$Id: oldmain.c,v 40.13 93/03/26 16:22:09 brummer Exp Locker: brummer $
*
******************************************************************************
*
*	$Log:	oldmain.c,v $
 * Revision 40.13  93/03/26  16:22:09  brummer
 * Remove open and close of lowlevel.library.  This is not needed
 * because ll is opened at nv.lib open time.
 *
 * Revision 40.12  93/03/26  10:19:39  brummer
 * Fix AUTODOCs per CATS request
 *
 * Revision 40.11  93/03/18  14:38:41  brummer
 * Another minor fix to AUTODOCS.
 *
 * Revision 40.10  93/03/18  14:32:24  brummer
 * Fix DeleteNVRAM AUTODOC to show KillRequesters in Synopsis prototype.
 *
 * Revision 40.9  93/03/12  14:59:50  brummer
 * Fix AUTODOC for FreeNVData to show correct register.
 *
 * Revision 40.8  93/03/11  10:35:18  brummer
 * Fix close/expunge code to get rid of C code and use code duped from
 * locale.library.
 *
 * Revision 40.7  93/03/09  13:53:58  brummer
 * Remove comments from around KillReq/RestoreReq lowlevel.library calls.
 * Remove check for NULL before calling CloseLibrary.
 * Adjust extern definition for KillReq and RestoreReq.
 *
 * Revision 40.6  93/03/05  15:02:52  brummer
 * Update AUTODOCs.
 *
 * Revision 40.5  93/03/05  14:36:09  brummer
 * remove old way of killing requesters and replaced it with the parametized version.
 * If the parameter is TRUE, the lowlevel library will be opened and a
 * call to KillReq and RestoreReq will be made.
 *
 * Revision 40.4  93/02/25  09:03:33  Jim2
 * Removed StoreNV.
 *
 * Revision 40.3  93/02/19  15:24:30  Jim2
 * The size for writing is in the units of tens of bytes.
 *
 * Revision 40.2  93/02/16  13:49:36  Jim2
 * Removed autodoc references to SizeNV(), which is a macro.
 *
 * Revision 40.1  93/02/10  17:28:06  Jim2
 * Revised StoreNV so it attempts first to update existing
 * files.
 *
 * Revision 40.0  93/02/09  10:22:36  Jim2
 * Changed the order to correspond with the current design document.
 *
 * Revision 39.1  93/02/03  13:49:48  Jim2
 * Cleaned up some compile time errors introduced when adding
 * the supression of the requestors.
 *
 * Revision 39.0  93/02/03  11:19:09  Jim2
 * Remove the functions that needed large rewrites and down coded them.
 * Instead of using a semaphore and storing the pr_WindowPtr in the
 * library base just store it on the stack.
 *
*
*	(C) Copyright 1992,1993 Commodore-Amiga, Inc.
*	    All Rights Reserved
*
******************************************************************************/
d12 2
@


40.13
log
@Remove open and close of lowlevel.library.  This is not needed
because ll is opened at nv.lib open time.
@
text
@d3 1
a3 1
*	$Id: oldmain.c,v 40.12 93/03/26 10:19:39 brummer Exp Locker: brummer $
d8 4
d90 2
a91 3
						/* Startup.asm */
extern APTR __asm LibExpunge (register __a6 struct NVBase *NVBase);
						/* NVRAM/ */
d94 2
a95 1
						/* Disk/ */
d98 2
a99 1
						/* Lowlevel.library */
a103 1

a148 4
	if (KillRequesters) KillReq();

	if ((result = ReadDisk(AppName, ItemName, NVBase)) == NULL)
		result = ReadNVRAM(AppName,ItemName,NVBase);
d150 10
a159 2
	if (KillRequesters) RestoreReq();

d196 1
a196 2
	if (Data != NULL)
		FreeMem(&((ULONG *)Data)[-1], ((ULONG *)Data)[-1]);
d244 12
a255 1
	if (KillRequesters) KillReq();
a256 1
	result = DeleteNVRAM(AppName, ItemName, NVBase) | DeleteDisk(AppName, ItemName, NVBase);
a257 4
	if (KillRequesters) RestoreReq();

	return(result);
}
@


40.12
log
@Fix AUTODOCs per CATS request
@
text
@d3 1
a3 1
*	$Id: oldmain.c,v 40.11 93/03/18 14:38:41 brummer Exp Locker: brummer $
d8 3
d145 1
a145 3
	if (KillRequesters)
		if ((LowLevelBase = OpenLibrary("lowlevel.library",0)) != NULL)
			KillReq();
d150 1
a150 5
	if (KillRequesters)
	{
		RestoreReq();
		CloseLibrary(LowLevelBase);
	};
d237 1
a237 3
	if (KillRequesters)
		if ((LowLevelBase = OpenLibrary("lowlevel.library",0)) != NULL)
			KillReq();
d241 1
a241 5
	if (KillRequesters)
	{
		RestoreReq();
		CloseLibrary(LowLevelBase);
	};
@


40.11
log
@Another minor fix to AUTODOCS.
@
text
@d3 1
a3 1
*	$Id: oldmain.c,v 40.10 93/03/18 14:32:24 brummer Exp Locker: brummer $
d8 3
d112 1
a112 1
*	The strings, AppName and ItemName may not contain the '/' or ':'
d123 1
a123 1
*	KillRequesters - Supress system requesters flag.  TRUE if all system
d130 1
a130 1
*	       if there is insufficient memory, or the AppName/ItemName does
d214 1
a214 1
*	The strings, AppName and ItemName may not contain the '/' or ':'
d225 1
a225 1
*	KillRequesters - Supress system requesters flag.  TRUE if all system
@


40.10
log
@Fix DeleteNVRAM AUTODOC to show KillRequesters in Synopsis prototype.
@
text
@d3 1
a3 1
*	$Id: oldmain.c,v 40.9 93/03/12 14:59:50 brummer Exp Locker: brummer $
d8 3
d109 4
d120 3
a123 4
*	The strings, AppName and ItemName may not contain the '/' or ':'
*	characters.  It is recommended that these characters be blocked
*	from user input when requesting AppName and ItemName strings.
*
a128 3
*	KillRequesters - Supress system requesters flag.  TRUE if all system
*			 requesters are to be suppressed during this function.
*			 FALSE if system requesters are allowed.
d228 1
a228 1
*		  If the entry is not found FALSE will be returned
@


40.9
log
@Fix AUTODOC for FreeNVData to show correct register.
@
text
@d3 1
a3 1
*	$Id: oldmain.c,v 40.8 93/03/11 10:35:18 brummer Exp Locker: brummer $
d8 3
d202 1
a202 1
*	BOOL DeleteNV (STRPTR, STRPTR)
@


40.8
log
@Fix close/expunge code to get rid of C code and use code duped from
locale.library.
@
text
@d3 1
a3 1
*	$Id: oldmain.c,v 40.7 93/03/09 13:53:58 brummer Exp Locker: brummer $
d8 4
d161 1
a161 1
*		   a1
@


40.7
log
@Remove comments from around KillReq/RestoreReq lowlevel.library calls.
Remove check for NULL before calling CloseLibrary.
Adjust extern definition for KillReq and RestoreReq.
@
text
@d3 1
a3 1
*	$Id: oldmain.c,v 40.6 93/03/05 15:02:52 brummer Exp Locker: brummer $
d8 5
a83 17
/*******************************************************************************************************
 *                                                                                                     *
 * LibClose - Close nonvolatile library                                                                *
 *                                                                                                     *
 *******************************************************************************************************/

APTR __asm LibClose(register __a6 struct NVBase *NVBase)
{

	if (NVBase->NVLibrary.lib_OpenCnt) --NVBase->NVLibrary.lib_OpenCnt;                                 /* Decrement open count */

	return(LibExpunge(NVBase));                                                                         /* Expunge if it's time */
}




d142 1
a142 1
	return(result);                                                                                     /* Return result */
d179 1
a179 1
		FreeMem(&((ULONG *)Data)[-1], ((ULONG *)Data)[-1]);                                 /* Free the NV copy */
d239 1
a239 1
	return(result);                                                                     /* Return success/failure */
@


40.6
log
@Update AUTODOCs.
@
text
@d3 1
a3 1
*	$Id: oldmain.c,v 40.5 93/03/05 14:36:09 brummer Exp Locker: brummer $
d8 3
d57 1
d64 1
a64 1
#define LLBase  NVBase->nv_LowLevelBase
d74 2
a75 2
extern void __asm KillReq (void);
extern void __asm RestoreReq(void);
d119 4
d142 2
a143 2
		if ((LLBase = OpenLibrary("lowlevel.library",0)) != NULL)
			/* KillReq() */;
d150 2
a151 3
		/* RestoreReq() */;
		if (LLBase != NULL)
			CloseLibrary(LLBase);
d213 4
d240 2
a241 2
		if ((LLBase = OpenLibrary("lowlevel.library",0)) != NULL)
			/* KillReq() */;
d247 2
a248 3
		/* RestoreReq() */;
		if (LLBase != NULL)
			CloseLibrary(LLBase);
@


40.5
log
@remove old way of killing requesters and replaced it with the parametized version.
If the parameter is TRUE, the lowlevel library will be opened and a
call to KillReq and RestoreReq will be made.
@
text
@d3 1
a3 1
*	$Id: oldmain.c,v 40.4 93/02/25 09:03:33 Jim2 Exp Locker: brummer $
d8 5
d109 2
a110 1
*		  to be found.
d112 2
a113 1
*		   application to be found.
d120 1
a120 1
*	KillRequesters - Allow system requesters flag.  TRUE if all system
d208 2
a209 1
*		  created the data.
d211 3
a213 2
*		   within the application.
*	KillRequesters - Allow system requesters flag.  TRUE if all system
@


40.4
log
@Removed StoreNV.
@
text
@d3 1
a3 1
*	$Id: oldmain.c,v 40.3 93/02/19 15:24:30 Jim2 Exp Locker: Jim2 $
d8 3
d49 1
d55 1
d64 3
a66 1

a69 1

d76 2
a77 7
APTR __asm LibClose(register __a6 struct NVBase *NVBase) {

    if (NVBase->NVLibrary.lib_OpenCnt) --NVBase->NVLibrary.lib_OpenCnt;                                 /* Decrement open count */

    return(LibExpunge(NVBase));                                                                         /* Expunge if it's time */
    }

d79 1
d81 2
a86 3



d93 2
a94 2
*	Data = GetCopyNV (AppName, ItemName)
*	d0		  a0	   a1
d96 1
a96 1
*	APTR GetCopyNV (STRPTR, STRPTR)
d113 3
d123 1
a123 1
                                                    register __a6 struct NVBase *NVBase)
d125 4
a128 3
APTR result;
APTR OldWP;
struct Process *Me;
d130 13
a142 10
    Me = (struct Process *)FindTask(NULL);
    OldWP = Me->pr_WindowPtr;
    Me->pr_WindowPtr = (void *) -1;

    if ((result = ReadDisk(AppName, ItemName, NVBase)) == NULL)
	result = ReadNVRAM(AppName,ItemName,NVBase);
    Me->pr_WindowPtr = OldWP;

    return(result);                                                                                     /* Return result */
    } /* GetCopyNV */
d174 1
a174 3
    {
    FreeMem(&((ULONG *)Data)[-1], ((ULONG *)Data)[-1]);                                 /* Free the NV copy */
    } /* FreeNVData */
d176 2
d179 1
d182 2
d190 2
a191 2
*	Success = DeleteNV (AppName, ItemName)
*	d0		    a0	     a1
d204 3
d216 1
a216 1
                    register __a6 struct NVBase *NVBase)
d218 4
a221 4

BOOL               result;
APTR OldWP;
struct Process *Me;
d223 8
a230 3
    Me = (struct Process *)FindTask(NULL);
    OldWP = Me->pr_WindowPtr;
    Me->pr_WindowPtr = (void *)-1;
d232 1
a232 3
    result = DeleteNVRAM(AppName, ItemName, NVBase) | DeleteDisk(AppName, ItemName, NVBase);
    Me->pr_WindowPtr =OldWP;
    return(result);                                                                     /* Return success/failure */
@


40.3
log
@The size for writing is in the units of tens of bytes.
@
text
@d3 1
a3 1
*	$Id: oldmain.c,v 40.2 93/02/16 13:49:36 Jim2 Exp Locker: Jim2 $
d8 3
d54 2
a55 3
extern APTR __asm ReadNVRAM (register __a0 char *AppName, register __a1 char *ItemName, register __a6 struct NVBase *NVBase);
extern UWORD __asm WriteNVRAM (register __a0 char *AppName, register __a1 char *ItemName, register __a2 APTR Data, register __d0 ULONG Length, register __d1 LONG Mode, register __a6 struct NVBase *NVBase);
extern BOOL __asm DeleteNVRAM (register __a0 char *AppName, register __a1 char *ItemName, register __a6 struct NVBase *NVBase);
d57 2
a58 3
extern APTR __asm ReadDisk (register __a0 char *AppName, register __a1 char *ItemName, register __a6 struct NVBase *NVBase);
extern UWORD __asm WriteDisk (register __a0 char *AppName, register __a1 char *ItemName, register __a2 APTR Data, register __d0 ULONG Length, register __d1 LONG Mode, register __a6 struct NVBase *NVBase);
extern BOOL __asm DeleteDisk (register __a0 char *AppName, register __a1 char *ItemName, register __a6 struct NVBase *NVBase);
d95 1
a95 1
*	APTR GetCopyNV (char *, char *)
d118 1
a118 1
APTR __asm GetCopyNV(register __a0 char *AppName, register __a1 char *ItemName,
a170 77
/****** nonvolatile.library/StoreNV ******************************************
*
*   NAME
*	StoreNV - Store data in nonvolatile storage.
*
*   SYNOPSIS
*	Error = StoreNV (AppName, ItemName, Data, Length)
*	d0		 a0	  a1	    a2    d0
*
*	UWORD StoreNV (char *, char *, APTR, ULONG)
*
*   FUNCTION
*	Saves some data in nonvolatile storage.  The data is tagged with
*	AppName and ItemName so it can be retrieved later.  No single
*	item should be larger than one fourth of the maximum storage as
*	returned by GetNVInfo().
*
*	The string, AppName and ItemName, should be short, but descriptive.
*	They need to be short since nonvolatile storage for a stand alone
*	game system is limited.  The game system allows the user to
*	selectively remove entries from storage, so the string should be
*	desriptive.
*
*   INPUTS
*	AppName - NULL terminated string identifying the application
*		  creating the data.
*	ItemName - NULL terminated string uniquely identifying the data
*		   within the application.
*	Data - Pointer to the memory block to be stored.
*	Length - Number of bytes to be stored in the units of tens of
*		 bytes.  ie If you have 23 bytes to store length = 3;
*		 147 byte then length = 15.
*
*   RESULT
*	Error:
*	0 - Data stored, no error.
*	NVERR_BADNAME - Error in AppName, or ItemName.
*	NVERR_WRITEPROT - Nonvolatile storage is read only.
*	NVERR_FAIL - Failure in writing data (nonvolatile storage full, or
*	   write protected).
*	NVERR_FATAL - Fatal error when accessing nonvolatile storage,
*	   possible loss of previously saved nonvolatile data.
*
*   SEE ALSO
*	GetCopyNV(), GetNVInfo()
*
******************************************************************************/
UWORD __asm StoreNV(register __a0 char *AppName, register __a1 char *ItemName,
                    register __a2 APTR Data,    register __d0 ULONG Length,
                    register __a6 struct NVBase *NVBase) {

UWORD result;
APTR OldWP;
struct Process *Me;

    Me = (struct Process *)FindTask(NULL);
    OldWP = Me->pr_WindowPtr;
    Me->pr_WindowPtr = (void *)-1;

    result = 0;
    Length *= 10;
    if ((result = WriteDisk (AppName, ItemName, Data, Length, MODE_OLDFILE, NVBase)) != 0)
	if ((result & 0x80000000) == 0)
	{
	    result = 0;
	    if (WriteNVRAM (AppName, ItemName, Data, Length, MODE_OLDFILE, NVBase) != 0)
	    	if ((result = WriteDisk (AppName, ItemName, Data, Length, MODE_NEWFILE, NVBase)) != 0)
		    if (WriteNVRAM(AppName, ItemName, Data, Length, MODE_NEWFILE, NVBase) != 0)
		    	result= ((result == NVERR_WRITEPROT) ? NVERR_WRITEPROT : NVERR_FAIL);
		    else
		    	result = 0;
	}
	else
	   result &= 0x7FFFFFFF;
    Me->pr_WindowPtr = OldWP;
    return (result);
    }
d182 1
a182 1
*	BOOL DeleteNV (char *, char *)
d201 1
a201 1
BOOL __asm DeleteNV(register __a0 char *AppName, register __a1 char *ItemName,
@


40.2
log
@Removed autodoc references to SizeNV(), which is a macro.
@
text
@d3 1
a3 1
*	$Id: oldmain.c,v 40.1 93/02/10 17:28:06 Jim2 Exp Locker: Jim2 $
d8 3
d199 3
a201 1
*	Length - Number of bytes to be stored.
d230 1
d278 2
a279 1
                    register __a6 struct NVBase *NVBase) {
d292 1
a292 1
    }
@


40.1
log
@Revised StoreNV so it attempts first to update existing
files.
@
text
@d3 1
a3 1
*	$Id: oldmain.c,v 40.0 93/02/09 10:22:36 Jim2 Exp Locker: Jim2 $
d8 4
d110 1
a110 1
*	FreeNVData(), SizeNVData()
d158 1
a158 1
*	GetCopyNV(), GetNVInfo(), GetNVList(), SizeNVData()
@


40.0
log
@Changed the order to correspond with the current design document.
@
text
@d3 1
a3 1
*	$Id: oldmain.c,v 39.1 93/02/03 13:49:48 Jim2 Exp Locker: Jim2 $
d8 3
d45 1
a45 1
extern UWORD __asm WriteNVRAM (register __a0 char *AppName, register __a1 char *ItemName, register __a2 APTR Data, register __d0 ULONG Length, register __a6 struct NVBase *NVBase);
d49 1
a49 1
extern UWORD __asm WriteDisk (register __a0 char *AppName, register __a1 char *ItemName, register __a2 APTR Data, register __d0 ULONG Length, register __a6 struct NVBase *NVBase);
a74 30
/****** nonvolatile.library/SizeNVData ***************************************
*
*   NAME
*	SizeNVData - Determine the size of data returned by this library.
*
*   SYNOPSIS
*	Size = SizeNVData (Data)
*	d0		   a0
*
*	ULONG SizeNVData (APTR)
*
*   FUNCTION
*	Determines the size of data returned by this library.
*
*	This call will return incorrect information if called with data not
*	created by this library.
*
*	This function is actually implemented by a macro.
*
*   INPUTS
*	Data - Pointer to data created/allocated by this library.
*
*   RESULT
*	Size - Size of data.
*
*   SEE ALSO
*	GetNVInfo(), GetNVList(), GetCopyNV()
*
******************************************************************************/

d198 1
d212 1
a212 1
UWORD result,result2;
d220 14
a233 2
    result = WriteNVRAM(AppName, ItemName, Data, Length, NVBase);
    result2= WriteDisk(AppName, ItemName, Data, Length, NVBase);
a234 2
    if ((result2 == 0) || (result == 0))
	return (0);
@


39.1
log
@Cleaned up some compile time errors introduced when adding
the supression of the requestors.
@
text
@d3 1
a3 1
*	$Id: oldmain.c,v 39.0 93/02/03 11:19:09 Jim2 Exp Locker: Jim2 $
d8 4
d148 2
a149 2
    if ((result = ReadNVRAM(AppName, ItemName, NVBase)) == NULL)
	result = ReadDisk(AppName,ItemName,NVBase);
@


39.0
log
@Remove the functions that needed large rewrites and down coded them.
Instead of using a semaphore and storing the pr_WindowPtr in the 
library base just store it on the stack.
@
text
@d3 1
a3 1
*	$Id: $
d7 6
a12 1
*	$Log: $
d137 1
a137 1
APTR OldWP
d142 1
a142 1
    Me->pr_WindowPtr = -1;
d235 1
a235 2
APTR result;
APTR OldWP
d240 1
a240 1
    Me->pr_WindowPtr = -1;
d283 1
a283 2
APTR result;
APTR OldWP
d288 1
a288 1
    Me->pr_WindowPtr = -1;
@


1.6
log
@no effective change.
@
text
@d1 12
d20 2
a23 5
#include <pragmas/graphics_pragmas.h>
#include <clib/graphics_protos.h>
#include <pragmas/dos_pragmas.h>
#include <clib/dos_protos.h>
#include <clib/alib_protos.h>
d25 1
a25 3
#include <libraries/expansionbase.h>
#include <dos/filehandler.h>

a26 134
#include "nonvolatile.h"
#include "main_funcs.h"
#include "file_funcs.h"
#include "nvram_funcs.h"

#define SysBase (*((struct ExecBase **)0x00000004L))

extern LONG __far initFunc;
extern LONG __far initStruct;



/*******************************************************************************
 *                                                                             *
 * LibExpunge - remove library from system to free up the memory               *
 *                                                                             *
 *******************************************************************************/

APTR __asm LibExpunge(register __a6 struct NVBase *NVBase) {

APTR SegList = NVBase->SegList;

    if (!NVBase->NVLibrary.lib_OpenCnt) {                                       /* OpenCnt must be nonzero or we wouldn't be here */

        if (NVBase->DOSBase)       CloseLibrary(NVBase->DOSBase);               /* Close any openned libraries */
        if (NVBase->ExpansionBase) CloseLibrary(NVBase->ExpansionBase);

        if (SegList) {                                                          /* If we are in ROM, this won't be necessary */

            Remove(NVBase);                                                     /* Free the data structure */
            FreeMem((UBYTE *)NVBase - NVBase->NVLibrary.lib_NegSize,
                NVBase->NVLibrary.lib_NegSize + NVBase->NVLibrary.lib_PosSize);

            return(SegList);                                                    /* Return SegList to free code */
            }
        }

    return(0);                                                                  /* Cannot expunge */
    }    



/***************************************************************************************
 *                                                                                     *
 * Main - Initialization routine.  Starts up library.                                  *
 *                                                                                     *
 ***************************************************************************************/

APTR __asm Main(register __a0 APTR SegList) {

struct NVBase      *NVBase;
struct NVResident  *NVEntry;
APTR                sum;

    if (NVBase = (struct NVBase *)MakeLibrary(&initFunc, &initStruct, 0,                /* Make library structure */
                                              sizeof(struct NVBase), 0)) {

        NVBase->SegList = SegList;                                                      /* Save code SegList */

        AddLibrary(NVBase);                                                             /* Add library to system */

        if (!SegList) {                                                                 /* If we are running from ROM... */

            if (!(NVEntry = (struct NVResident *)FindResident("NV RAM"))) {             /* Try and locate NV RAM */
    
                if (!(NVEntry = AllocMem(sizeof(struct NVResident),                     /* Try and create NV RAM */
                                         MEMF_KICK|MEMF_REVERSE|MEMF_CLEAR))) {

                    return(LibExpunge(NVBase));                                         /* Could not allocate NV RAM */
                    }

                else {

                    NVEntry->RomTag.rt_MatchWord = RTC_MATCHWORD;                       /* Create ROMTag */
                    NVEntry->RomTag.rt_MatchTag  = &NVEntry->RomTag;
                    NVEntry->RomTag.rt_EndSkip   = NVEntry + sizeof(struct NVResident);
                    NVEntry->RomTag.rt_Pri       = 0;                
                    NVEntry->RomTag.rt_Name      = (APTR)&NVEntry->ResName;

                    CopyMem("NV RAM\0\0", &NVEntry->ResName, 8);                        /* ROMTag name is "NV RAM" */

                    NVEntry->KickMem.ml_Node.ln_Type    = NT_KICKMEM;                   /* Create KickMem tag */
                    NVEntry->KickMem.ml_NumEntries      = 1;
                    NVEntry->KickMem.ml_ME[0].me_Addr   = NVEntry;
                    NVEntry->KickMem.ml_ME[0].me_Length = sizeof(struct NVResident);

                    Forbid();                                                           /* Critical section */

                    NVEntry->KickMem.ml_Node.ln_Succ = SysBase->KickMemPtr;             /* Add to KickMem list */
                    SysBase->KickMemPtr              = &NVEntry->KickMem;

                    NVEntry->KickTag.kt_TagAddr       = &NVEntry->RomTag;               /* Add to KickTag list */
                    if (NVEntry->KickTag.kt_NextArray = SysBase->KickTagPtr)
                        NVEntry->KickTag.kt_NextArray = 
                        (APTR)((ULONG)NVEntry->KickTag.kt_NextArray | 0x80000000);
                    SysBase->KickTagPtr               = (APTR)&NVEntry->KickTag;

                    NVEntry->ResTag.kt_TagAddr       = &NVEntry->RomTag;                /* Add to Resident list */
                    if (NVEntry->ResTag.kt_NextArray = SysBase->ResModules)
                        NVEntry->ResTag.kt_NextArray =
                        (APTR)((ULONG)NVEntry->ResTag.kt_NextArray | 0x80000000);
                    SysBase->ResModules              = (APTR)&NVEntry->ResTag;

                    sum = (APTR)SumKickData();                                          /* Recalculate checksum */
                    SysBase->KickCheckSum = sum;

                    Permit();                                                           /* End of critical section */
                    }
                }

            NVBase->NVRAM = NVEntry;                                                    /* Remember location of NV RAM */
            }
        }

    else return(SegList);                                                               /* Could not create library */

    InitSemaphore(&NVBase->Semaphore);                                                  /* Initialize semaphore */

    return(NULL);
    }





/*******************************************************************************************************
 *                                                                                                     *
 * LibOpen - Open nonvolatile library                                                                  *
 *                                                                                                     *
 *******************************************************************************************************/

struct NVBase * __asm LibOpen(register __a6 struct NVBase *NVBase) {

    if (!NVBase->NVLibrary.lib_OpenCnt) {                                                               /* First open? */
d28 11
a38 8
        if (!(NVBase->DOSBase = (struct DOSBase *)OpenLibrary("dos.library", 0))) return(NULL);         /* Get DOSBase */

        if (!(NVBase->ExpansionBase = (struct ExpansionBase *)OpenLibrary("expansion.library", 0))) {   /* Get ExpansionBase */

            CloseLibrary(NVBase->DOSBase);                                                              /* Could not open */
            return(NULL);
            }
        }
a39 1
    NVBase->NVLibrary.lib_OpenCnt++;                                                                    /* Openned one more time */
a40 2
    return(NVBase);                                                                                     /* Return NVBase */
    }
d61 1
a61 2

#define DOSBase NVBase->DOSBase
d63 1
a63 2
#if 0
******* nonvolatile.library/GetCopyNV() ****************************************************************
d66 1
a66 1
*       GetCopyNV - Make a copy of an item in nonvolatile RAM
d69 2
a70 2
*       Entry = GetCopyNV(AppName, ItemName)
*       D0                A0       A1
d72 1
a72 1
*       void *GetCopyNV(char *, char *)
d75 9
a83 3
*       This function will search all nonvolatile devices for the
*       specified nonvolatile entry.  A copy of the entry will be
*       created in MEMF_PUBLIC memory.
d85 3
a87 4
*   RESULTS
*       Pointer to a copy of an NV entry, or NULL if the entry was
*       not found.
*   
d89 1
a89 1
*       FreeCopyNV()
d91 1
a91 56
********************************************************************************************************
#endif

void * __asm GetCopyNV(register __a0 char *AppName, register __a1 char *ItemName,
                                                    register __a6 struct NVBase *NVBase) {

struct List       *DeviceList;
struct Node       *BNode;
struct DeviceNode *DNode;
char              *DName, DeviceName[80];
struct NVMemEntry *NVMemEntry;
ULONG             *NVItem;
int                i;
void              *result;

    if (!TurnOffRequesters(NVBase)) return(NULL);                                                       /* Turn off requesters */

    ObtainSemaphore(&NVBase->Semaphore);                                                                /* Obtain code control */

    if (!(result = OpenReadNVItem(NULL, AppName, ItemName, NVBase))) {                                  /* Check boot partition */

        DeviceList = &NVBase->ExpansionBase->MountList;                                                 /* Scan boot list */
        for (BNode = (struct Node *)DeviceList->lh_Head;
             BNode->ln_Succ != DeviceList->lh_Tail;
             BNode = BNode->ln_Succ) {

            DNode = (struct DeviceNode *)((struct BootNode *)BNode)->bn_DeviceNode;                     /* Device node */

            DName = (char *)(DNode->dn_Name << 2);                                                      /* BSTR device name */

            for (i=0; i!=DName[0]; i++) DeviceName[i] = DName[i+1];                                     /* Convert to STR */
            DeviceName[i++] = ':';
            DeviceName[i]   = 0;

            if (result = (void *)OpenReadNVItem(DeviceName, AppName, ItemName, NVBase)) break;          /* Try and read device */
            }
        }

    if (!result) {                                                                                      /* Could item be located? */

        if (NVMemEntry = FindNVEntry(AppName, ItemName, NVBase)) {                                      /* Check NV RAM */

            if (NVItem = (ULONG *)AllocMem(NVMemEntry->Size + 4, MEMF_PUBLIC)) {                        /* Found it, allocate copy */

                NVItem[0] = NVMemEntry->Size;                                                           /* Remember size of Alloc */

                CopyMem((char *)NVMemEntry + sizeof(struct NVMemEntry), &NVItem[1], NVMemEntry->Size);  /* Copy item to RAM */

                result = (void *)&NVItem[1];                                                            /* Return pointer to item */
                }
            }
        }

    ReleaseSemaphore(&NVBase->Semaphore);                                                               /* Release semaphore */

    TurnOnRequesters(NVBase);                                                                           /* Reenable requesters */
a92 2
    return(result);                                                                                     /* Return result */
    }
d96 1
a96 3

#if 0
******* nonvolatile.library/FreeCopyNV() ***************************************************
d99 1
a99 1
*       FreeCopyNV - Free a copy of a nonvolatile entry
d102 2
a103 2
*       FreeCopyNV(Entry)
*                  A0
d105 1
a105 1
*       void FreeCopyNV(void *)
d108 2
a109 2
*       This function will free a copy of a nonvolatile entry
*       previously created with GetCopyNV()
d111 12
a122 2
*   RESULTS
*   
d124 1
a124 1
*       GetCopyNV()
d126 12
a137 2
********************************************************************************************
#endif
d139 3
a141 1
void __asm FreeCopyNV(register __a0 void *Data, register __a6 struct NVBase *NVBase) {
d143 4
a146 2
    FreeMem(&((ULONG *)Data)[-1], ((ULONG *)Data)[-1] + 4);                                 /* Free the NV copy */
    }
d149 1
a149 3

#if 0
******* nonvolatile.library/StoreNV() ******************************************************
d152 2
a153 1
*       StoreNV - Store data in nonvolatile memory
d156 2
a157 2
*       Error = StoreNV(AppName, ItemName, Data, Length, Options)
*       D0              A0       A1        A2    D1      D2
d159 1
a159 1
*       UWORD StoreNV(char *, char *, void *, ULONG, UWORD)
d162 5
a166 3
*       Duplicates data into nonvolatile memory.  Because only small
*       amounts of nonvolatile memory may exist, only small amounts
*       of data should ever be stored in nonvolatile memory.
d168 3
a170 3
*   RESULTS
*       0 = success, otherwise error.
*   
d172 1
a172 1
*       GetCopyNV(), DeleteNV()
d174 5
a178 8
********************************************************************************************
#endif

UWORD __asm StoreNV(register __a0 char *AppName, register __a1 char *ItemName,
                    register __a2 void *Data,    register __d0 ULONG Length,
                    register __d1 UWORD Options, register __a6 struct NVBase *NVBase) {

UWORD result = 0;
a179 28
    if (!TurnOffRequesters(NVBase)) return(NVERR_NOTAPROCESS);                              /* Do not allow requesters to appear */

    ObtainSemaphore(&NVBase->Semaphore);                                                    /* Obtain control of code */

    if (Options == SNV_FORMATFLOPPY) result = FormatBestFloppy(NVBase);                     /* Force a floppy format? */

    if (!result) {                                                                          /* If a format attempted, did it fail? */

        if ((result = FindWriteNVItem(AppName, ItemName, Data, Length, Options, NVBase))    /* Try and write the NVItem */
            == NVERR_NOTAVAILABLE) {

            if (!(result = MakeNV(Options, NVBase)))                                        /* Create NonVolatile directory */

                result = FindWriteNVItem(AppName, ItemName, Data, Length, Options, NVBase); /* Retry write of NVItem */
            }
        }

    if (result == NVERR_NOTAVAILABLE && Options) {                                          /* If SNV_BESTCHOICE and save failed.. */

        result = FindBestFloppyError(NVBase);                                               /* Return best floppy error */
        }

    if (result == NVERR_NOTAVAILABLE || (result && !Options)) {                             /* If no disk device is present... */

        result = WriteNVEntry(AppName, ItemName, Data, Length, NVBase);                     /* Try true NV RAM */
        }

    ReleaseSemaphore(&NVBase->Semaphore);                                                   /* Release semaphore */
d181 1
a181 9
    TurnOnRequesters(NVBase);                                                               /* Turn requesters back on */

    return(result);
    }



#if 0
******* nonvolatile.library/DeleteNV() *************************************************
d184 1
a184 1
*       DeleteNV - Delete a nonvolatile entry
d187 2
a188 2
*       Error = DeleteNV(AppName, ItemName)
*       D0               A0       A1
d190 1
a190 1
*       UWORD DeleteNV(char *, char *)
d193 4
a196 2
*       Deletes an entry in nonvolatile RAM.  This will free up memory
*       to help make room for other nonvolatile entries.
d198 23
a220 3
*   RESULTS
*       0 = success, otherwise error.
*   
d222 1
d224 3
a226 4
****************************************************************************************
#endif

BOOL __asm DeleteNV(register __a0 char *AppName, register __a1 char *ItemName,
d229 4
a232 31
struct List       *DeviceList;
struct Node       *BNode;
struct DeviceNode *DNode;
char              *DName, DeviceName[80];
int                i;
BOOL               result;

    if (!TurnOffRequesters(NVBase)) return(NVERR_NOTAPROCESS);                          /* Turn off requesters */

    ObtainSemaphore(&NVBase->Semaphore);                                                /* Obtain code control */

    if (!(result = DeleteNVItem(NULL, AppName, ItemName, NVBase))) {                    /* Check boot partition */

        DeviceList = &NVBase->ExpansionBase->MountList;                                 /* Scan boot list */
        for (BNode = (struct Node *)DeviceList->lh_Head;
             BNode->ln_Succ != DeviceList->lh_Tail;
             BNode = BNode->ln_Succ) {

            DNode = (struct DeviceNode *)((struct BootNode *)BNode)->bn_DeviceNode;     /* Device Node */

            DName = (char *)(DNode->dn_Name << 2);                                      /* BSTR device name */

            for (i=0; i!=DName[0]; i++) DeviceName[i] = DName[i+1];                     /* Convert to STR */
            DeviceName[i++] = ':';
            DeviceName[i]   = 0;

            if (result = DeleteNVItem(DeviceName, AppName, ItemName, NVBase)) break;    /* Try and delete from this device */
            }
        }

    if (DeleteNVEntry(AppName, ItemName, NVBase) == TRUE) result = TRUE;                /* Try and delete from NV RAM */
d234 10
a243 5
    ReleaseSemaphore(&NVBase->Semaphore);                                               /* Release semaphore */

    TurnOnRequesters(NVBase);                                                           /* Turn requesters back on */

    return(result);                                                                     /* Return success/failure */
d247 1
a247 4


#if 0
******* nonvolatile.library/GetTypeNV() ****************************************
d250 1
a250 1
*       GetTypeNV - Report best available type of nonvolatile device
d253 2
a254 2
*       result = GetTypeNV()
*       D0
d256 1
a256 1
*       UWORD GetTypeNV(void)
d259 2
a260 2
*       Reports the best type of nonvolatile device available.
*       Does not determine if the media is present in the device.
d262 9
a270 5
*   RESULTS
*       0 = no nonvolatile device available, nonzero = device type
*           (NVT_NVRAM, or NVT_DISK).
*   
*   SEE ALSO
d272 5
a276 2
********************************************************************************
#endif
d278 4
a281 1
UWORD __asm GetTypeNV(register __a6 struct NVBase *NVBase) {
d283 3
a285 43
char    FloppyName[6];
int     i;
BPTR    NVLock;
UWORD   result = 0, Error;

    if (!TurnOffRequesters(NVBase)) return(NVERR_NOTAPROCESS);                  /* Turn off requesters */

    ObtainSemaphore(&NVBase->Semaphore);                                        /* Obtain code control */

    CopyMem("DF0:", FloppyName, 5);                                             /* We are going to check all floppy devices */

    for (i=0; i!=4; i++) {                                                      /* Try all 4 units */

        FloppyName[2] = '0' + i;                                                /* Create device name */

        if (NVLock = Lock(FloppyName, ACCESS_READ)) {                           /* Try and lock main directory */

            UnLock(NVLock);                                                     /* We definately have a disk available */
            result = NVT_DISK;
            break;
            }

        else {                                                                  /* Could not read disk */

            Error = IoErr();                                                    /* Find out why */

            if (Error == ERROR_NO_DISK || Error == ERROR_NOT_A_DOS_DISK) {      /* If no disk or not valid disk... */

                result = NVT_DISK;                                              /* ... a drive must be present */
                break;
                }
            }
        }

    ReleaseSemaphore(&NVBase->Semaphore);                                       /* Release semaphore */

    TurnOnRequesters(NVBase);                                                   /* Turn requesters back on */

    if (!result) {                                                              /* If no drive is present, check NV RAM */

        if (!NVBase->NVRAM) return(0);                                          /* No NV RAM, then no nonvolatile device present */
        else                return(NVT_NVRAM);                                  /* We have NV RAM */
        }
d287 3
a289 1
    return(result);                                                             /* Return findings */
a290 1

@


1.5
log
@no effective change.
@
text
@@


1.4
log
@Added GetTypeNV function and added comments.
@
text
@d462 2
a463 1
*       0 = no nonvolatile device available, nonzero = device type.
@


1.3
log
@Added GetTypeNV function.
@
text
@d31 5
d41 1
a41 1
    if (!NVBase->NVLibrary.lib_OpenCnt) {
d43 2
a44 1
        if (SegList) {
d46 3
a48 1
            Remove(NVBase);
d52 1
a52 1
            return(SegList);
d56 1
a56 1
    return(0);
d60 6
d73 6
a78 1
    if (NVBase = (struct NVBase *)MakeLibrary(&initFunc, &initStruct, 0, sizeof(struct NVBase), 0)) {
d80 3
a82 6
        NVBase->SegList = SegList;
        AddLibrary(NVBase);
/*
        if (!SegList) {
*/
            if (!(NVEntry = (struct NVResident *)FindResident("NV RAM"))) {
d84 2
a85 1
                if (!(NVEntry = AllocMem(sizeof(struct NVResident), MEMF_KICK|MEMF_REVERSE|MEMF_CLEAR))) {
d87 1
a87 1
                    return(LibExpunge(NVBase));
d92 1
a92 3
                    kprintf("Making NVRAM\n");

                    NVEntry->RomTag.rt_MatchWord = RTC_MATCHWORD;      
d98 1
a98 1
                    CopyMem("NV RAM\0\0", &NVEntry->ResName, 8);
d100 1
a100 1
                    NVEntry->KickMem.ml_Node.ln_Type    = NT_KICKMEM;
d105 1
a105 1
                    Forbid();
d107 1
a107 1
                    NVEntry->KickMem.ml_Node.ln_Succ = SysBase->KickMemPtr;
d110 1
a110 1
                    NVEntry->KickTag.kt_TagAddr       = &NVEntry->RomTag;
d112 2
a113 1
                        NVEntry->KickTag.kt_NextArray = (APTR)((ULONG)NVEntry->KickTag.kt_NextArray | 0x80000000);
d116 1
a116 1
                    NVEntry->ResTag.kt_TagAddr       = &NVEntry->RomTag;
d118 2
a119 1
                        NVEntry->ResTag.kt_NextArray = (APTR)((ULONG)NVEntry->ResTag.kt_NextArray | 0x80000000);
d122 1
a122 1
                    sum = (APTR)SumKickData();
d125 1
a125 1
                    Permit();
d129 1
a129 4
            else kprintf("Found NVRAM\n");

            NVBase->NVRAM = NVEntry;
/*
d131 1
a131 4
*/
        }

    else return(SegList);
d133 1
a133 1
    InitSemaphore(&NVBase->Semaphore);
d135 1
a135 1
    kprintf("NVRAM = %08lx\n", &NVEntry->NVMemory[0]);
d143 6
d152 1
a152 1
    if (!NVBase->NVLibrary.lib_OpenCnt) {
d154 1
a154 1
        if (!(NVBase->DOSBase = (struct DOSBase *)OpenLibrary("dos.library", 0))) return(NULL);
d156 1
a156 1
        if (!(NVBase->ExpansionBase = (struct ExpansionBase *)OpenLibrary("expansion.library", 0))) {
d158 1
a158 1
            CloseLibrary(NVBase->DOSBase);
d163 1
a163 1
    NVBase->NVLibrary.lib_OpenCnt++;
d165 1
a165 1
    return(NVBase);
d169 7
a175 1

d178 1
a178 1
    if (NVBase->NVLibrary.lib_OpenCnt) --NVBase->NVLibrary.lib_OpenCnt;
d180 1
a180 1
    return(LibExpunge(NVBase));
d187 1
a187 1

d191 1
a191 1
******* nonvolatile.library/GetCopyNV() *******************************
d214 1
a214 1
***********************************************************************
d217 2
a218 1
void * __asm GetCopyNV(register __a0 char *AppName, register __a1 char *ItemName, register __a6 struct NVBase *NVBase) {
d223 1
a223 2
char              *DName;
char               DeviceName[80];
a226 1

d229 1
a229 1
    ObtainSemaphore(&NVBase->Semaphore);
d231 1
a231 1
    if (!TurnOffRequesters(NVBase)) return(NULL);
d233 1
a233 3
    DeviceList = &NVBase->ExpansionBase->MountList;
    
    if (!(result = OpenReadNVItem(NULL, AppName, ItemName, NVBase))) {
d235 1
d240 1
a240 1
            DNode = (struct DeviceNode *)((struct BootNode *)BNode)->bn_DeviceNode;
d242 1
a242 1
            DName = (char *)(DNode->dn_Name << 2);
d244 1
a244 1
            for (i=0; i!=DName[0]; i++) DeviceName[i] = DName[i+1];
d248 1
a248 1
            if (result = (void *)OpenReadNVItem(DeviceName, AppName, ItemName, NVBase)) break;
d252 1
a252 1
    TurnOnRequesters(NVBase);
d254 1
a254 1
    if (!result) {
d256 1
a256 1
        if (NVMemEntry = FindNVEntry(AppName, ItemName, NVBase)) {
d258 1
a258 1
            if (NVItem = (ULONG *)AllocMem(NVMemEntry->Size + 4, MEMF_PUBLIC)) {
d260 1
a260 1
                NVItem[0] = NVMemEntry->Size;
d262 1
a262 3
                CopyMem((char *)NVMemEntry + sizeof(struct NVMemEntry), &NVItem[1], NVMemEntry->Size);

                result = (void *)&NVItem[1];
d267 3
a269 1
    ReleaseSemaphore(&NVBase->Semaphore);
d271 1
a271 1
    return(result);
d276 1
a276 1

d278 1
a278 1
******* nonvolatile.library/FreeCopyNV() ******************************
d298 1
a298 1
***********************************************************************
d303 1
a303 1
    FreeMem(&((ULONG *)Data)[-1], ((ULONG *)Data)[-1] + 4);
d307 1
a307 1

d309 1
a309 1
******* nonvolatile.library/StoreNV() **************************************************
d331 1
a331 1
****************************************************************************************
d334 3
a336 6
UWORD __asm StoreNV(register __a0 char *AppName,
                    register __a1 char *ItemName,
                    register __a2 void *Data,
                    register __d0 ULONG Length,
                    register __d1 UWORD Options,
                    register __a6 struct NVBase *NVBase) {
d340 1
a340 1
    ObtainSemaphore(&NVBase->Semaphore);
d342 1
a342 1
    if (!TurnOffRequesters(NVBase)) return(NVERR_NOTAPROCESS);                              /* Do not allow requesters to appear */
d351 1
a351 1
            if (!(result = MakeNV(Options, NVBase))) {                                      /* Create NV dir and retry */
d353 1
a353 2
                result = FindWriteNVItem(AppName, ItemName, Data, Length, Options, NVBase);
                }
d367 2
a370 2
    ReleaseSemaphore(&NVBase->Semaphore);

d375 1
a375 1

d377 1
a377 1
******* nonvolatile.library/DeleteNV() ********************************
d397 1
a397 1
***********************************************************************
d400 2
a401 1
BOOL __asm DeleteNV(register __a0 char *AppName, register __a1 char *ItemName, register __a6 struct NVBase *NVBase) {
d406 1
a406 2
char              *DName;
char               DeviceName[80];
a407 1

d410 1
a410 1
    ObtainSemaphore(&NVBase->Semaphore);
d412 1
a412 1
    if (!TurnOffRequesters(NVBase)) return(NVERR_NOTAPROCESS);
d414 1
a414 3
    DeviceList = &NVBase->ExpansionBase->MountList;
    
    if (!(result = DeleteNVItem(NULL, AppName, ItemName, NVBase))) {
d416 1
d421 1
a421 1
            DNode = (struct DeviceNode *)((struct BootNode *)BNode)->bn_DeviceNode;
d423 1
a423 1
            DName = (char *)(DNode->dn_Name << 2);
d425 1
a425 1
            for (i=0; i!=DName[0]; i++) DeviceName[i] = DName[i+1];
d429 1
a429 1
            if (result = DeleteNVItem(DeviceName, AppName, ItemName, NVBase)) break;
d433 1
a433 1
    TurnOnRequesters(NVBase);
d435 1
a435 1
    if (DeleteNVEntry(AppName, ItemName, NVBase) == TRUE) result = TRUE;
d437 3
a439 2
    ReleaseSemaphore(&NVBase->Semaphore);
    return(result);
d443 1
d446 1
a446 1
******* nonvolatile.library/GetTypeNV() ********************************
d466 1
a466 1
***********************************************************************
d469 27
d497 7
a503 1
UWORD __asm GetTypeNV(register __a6 struct NVBase *NVBase) {
d505 1
a505 2
struct List       *DeviceList;
UWORD              result = 0;
d507 1
a507 1
    DeviceList = &NVBase->ExpansionBase->MountList;
d509 1
a509 3
    if (((struct Node *)DeviceList->lh_Head)->ln_Succ != DeviceList->lh_Tail) result = NVT_DISK;

    if (!result) {
d511 2
a512 2
        if (!NVBase->NVRAM) return(0);
        else                return(NVT_NVRAM);
d515 1
a515 1
    return(result);
d517 3
@


1.2
log
@init routines and library entry points.
@
text
@d19 1
a24 2
#include "defs.h"

d428 35
d464 3
d468 2
@


1.1
log
@Initial revision
@
text
@d2 5
a6 3
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
d8 5
a12 2
#include <workbench/startup.h>

a13 7
#include <pragmas/dos_pragmas.h>

#include <exec/io.h>
#include <exec/memory.h>
#include <clib/exec_protos.h>
#include <pragmas/exec_pragmas.h>

d20 1
d22 115
d138 1
a138 3
extern struct SysBase       *SysBase;
extern struct DOSBase       *DOSBase;
struct ExpansionBase        *ExpansionBase;
d140 1
a140 1
int main (int, char **);
d142 26
d195 1
a195 1
void *GetCopyNV(char *AppName, char *ItemName) {
d197 1
a197 1
struct List       *MountList;
d202 2
d206 1
a206 1
void              *result = NULL;
d208 1
a208 1
    if (!TurnOffRequesters()) return(NULL);
d210 3
a212 1
    MountList = &ExpansionBase->MountList;
d214 1
a214 1
    if (!(result = OpenReadNVItem(NULL, AppName, ItemName))) {
d216 2
a217 2
        for (BNode = (struct Node *)MountList->lh_Head;
             BNode->ln_Succ != MountList->lh_Tail;
d228 18
a245 1
            if (result = (void *)OpenReadNVItem(DeviceName, AppName, ItemName)) break;
d249 1
a249 1
    TurnOnRequesters();
d281 1
a281 1
void FreeCopyNV(void *Data) {
d314 6
a319 1
UWORD StoreNV(char *AppName, char *ItemName, void *Data, ULONG Length, UWORD Options) {
d323 3
a325 1
    if (!TurnOffRequesters()) return(NVERR_NOTPROCESS);                                 /* Do not allow requesters to appear */
d327 1
a327 1
    if (Options == SNV_FORMATFLOPPY) result = FormatBestFloppy();                       /* Force a floppy format? */
d329 1
a329 1
    if (!result) {                                                                      /* If a format took place, did it fail? */
d331 1
a331 1
        if ((result = FindWriteNVItem(AppName, ItemName, Data, Length, Options))        /* Try and write the NVItem */
d334 4
a337 2
            if (!(result = MakeNV()))                                                   /* Create NV dir and retry */
                result = FindWriteNVItem(AppName, ItemName, Data, Length, Options);
d341 1
d343 2
a344 3
    if (result == NVERR_NOTAVAILABLE && Options == SNV_BESTCHOICE) {                    /* If SNV_BESTCHOICE and save failed... */

        printf("Searching for a Floppy Drive\n");
d346 4
a349 2
        result = FindBestFloppyError();                                                 /* Return best floppy error */
        }
d351 1
d353 1
a353 1
    TurnOnRequesters();                                                                 /* Turn requesters back on */
d384 1
a384 1
UWORD DeleteNV(char *AppName, char *ItemName) {
d386 1
a386 1
struct List       *MountList;
d393 3
a395 1
UWORD              result = FALSE;
d397 1
a397 1
    if (!TurnOffRequesters()) return(NVERR_NOTPROCESS);
d399 1
a399 1
    MountList = &ExpansionBase->MountList;
d401 1
a401 1
    if (!(result = DeleteNVItem(NULL, AppName, ItemName))) {
d403 2
a404 2
        for (BNode = (struct Node *)MountList->lh_Head;
             BNode->ln_Succ != MountList->lh_Tail;
d415 1
a415 1
            if (result = DeleteNVItem(DeviceName, AppName, ItemName)) break;
d419 3
a421 1
    TurnOnRequesters();
d423 1
a429 41

int main(int argv, char **argc) {

char *Data;
UWORD Error;


    if (!(ExpansionBase = (struct ExpansionBase *)OpenLibrary("expansion.library", 0L))) return(0);

    if (Data = GetCopyNV("Lemmings", "HighScores")) {

        printf("Found HighScores\n");
        FreeCopyNV(Data);
        }

    if (!(Error = StoreNV("Lemmings", "HighScores", "This is a Test", 14, SNV_BESTCHOICE))) {

        printf("Saved HighScores\n");
        }

    else printf("Save error %ld\n", Error);

    if (Data = GetCopyNV("Lemmings", "HighScores")) {

        printf("Found HighScores\n");
        FreeCopyNV(Data);
        }

    DeleteNV("Lemmings", "HighScores");

    printf("FORCEFORMAT\n");

    if (!(Error = StoreNV("Lemmings", "HighScores", "This is a Test", 14, SNV_FORMATFLOPPY))) {

        printf("Saved HighScores\n");
        }

    DeleteNV("Lemmings", "HighScores");

    CloseLibrary((struct Library *)ExpansionBase);
    }
@
