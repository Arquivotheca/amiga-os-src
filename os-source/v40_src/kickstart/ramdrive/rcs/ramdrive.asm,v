head     36.27;
branch   ;
access   ;
symbols  V39_35:36.26 V37_23:36.23 V37_21:36.22 V37_6:36.21 V37_3:36.20 V37_2:36.19 V36_51:36.19 V36_46:36.18 V36_42:36.17 V36_31:36.15 V36_30:36.14 V36_29:36.13 V36_14:36.10 V36_12:36.9 V36_9:34.26;
locks    ; strict;
comment  @*   @;


36.27
date     92.08.27.10.32.00;  author darren;  state Exp;
branches ;
next     36.26;

36.26
date     92.05.21.11.27.02;  author darren;  state Exp;
branches ;
next     36.25;

36.25
date     92.05.21.11.20.23;  author darren;  state Exp;
branches ;
next     36.24;

36.24
date     92.05.21.10.36.47;  author darren;  state Exp;
branches ;
next     36.23;

36.23
date     91.05.01.18.04.28;  author darren;  state Exp;
branches ;
next     36.22;

36.22
date     91.04.15.19.21.24;  author darren;  state Exp;
branches ;
next     36.21;

36.21
date     91.03.20.15.30.36;  author darren;  state Exp;
branches ;
next     36.20;

36.20
date     91.01.09.19.46.15;  author darren;  state Exp;
branches ;
next     36.19;

36.19
date     91.01.03.18.56.40;  author darren;  state Exp;
branches ;
next     36.18;

36.18
date     90.06.04.11.11.06;  author kodiak;  state Exp;
branches ;
next     36.17;

36.17
date     90.06.01.17.35.45;  author kodiak;  state Exp;
branches ;
next     36.16;

36.16
date     90.06.01.15.04.39;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     90.04.13.11.29.28;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     90.04.02.11.10.21;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     89.12.19.14.41.43;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     89.12.19.13.45.05;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     89.12.12.14.35.48;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     89.05.25.13.25.32;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     89.05.25.12.57.48;  author kodiak;  state Exp;
branches ;
next     34.26;

34.26
date     89.05.25.12.27.06;  author kodiak;  state Exp;
branches ;
next     34.25;

34.25
date     89.05.16.16.12.50;  author kodiak;  state Exp;
branches ;
next     34.24;

34.24
date     88.11.16.17.19.03;  author kodiak;  state Exp;
branches ;
next     34.23;

34.23
date     88.11.16.11.40.10;  author kodiak;  state Exp;
branches ;
next     34.22;

34.22
date     88.04.11.10.39.17;  author kodiak;  state Exp;
branches ;
next     34.21;

34.21
date     88.03.11.09.10.36;  author bart;  state Exp;
branches ;
next     34.20;

34.20
date     88.03.10.19.16.46;  author bart;  state Exp;
branches ;
next     34.19;

34.19
date     88.03.10.17.19.49;  author bart;  state Exp;
branches ;
next     34.18;

34.18
date     88.03.08.18.53.48;  author bart;  state Exp;
branches ;
next     34.17;

34.17
date     87.12.01.12.57.59;  author bart;  state Exp;
branches ;
next     34.16;

34.16
date     87.12.01.12.49.30;  author bart;  state Exp;
branches ;
next     34.15;

34.15
date     87.12.01.12.44.21;  author bart;  state Exp;
branches ;
next     34.14;

34.14
date     87.12.01.12.06.17;  author bart;  state Exp;
branches ;
next     34.13;

34.13
date     87.11.21.15.16.26;  author bart;  state Exp;
branches ;
next     34.12;

34.12
date     87.11.21.15.15.26;  author bart;  state Exp;
branches ;
next     34.11;

34.11
date     87.11.21.11.18.14;  author bart;  state Exp;
branches ;
next     34.10;

34.10
date     87.11.20.17.19.41;  author bart;  state Exp;
branches ;
next     34.9;

34.9
date     87.11.20.16.55.52;  author bart;  state Exp;
branches ;
next     34.8;

34.8
date     87.11.20.16.31.49;  author bart;  state Exp;
branches ;
next     34.7;

34.7
date     87.11.20.14.51.36;  author bart;  state Exp;
branches ;
next     34.6;

34.6
date     87.11.20.14.01.09;  author bart;  state Exp;
branches ;
next     34.5;

34.5
date     87.11.20.12.58.29;  author bart;  state Exp;
branches ;
next     34.4;

34.4
date     87.11.20.12.09.30;  author bart;  state Exp;
branches ;
next     34.3;

34.3
date     87.11.20.11.58.59;  author bart;  state Exp;
branches ;
next     34.2;

34.2
date     87.11.20.11.52.17;  author bart;  state Exp;
branches ;
next     34.1;

34.1
date     87.11.18.16.56.53;  author bart;  state Exp;
branches ;
next     34.0;

34.0
date     87.10.09.12.49.26;  author bart;  state Exp;
branches ;
next     ;


desc
@@


36.27
log
@Add commented out code to set pr_Result2 if failed due to lack
of memory.  Saves some ROM space without it, but ideally would
be enabled.
@
text
@**
**	$Id: ramdrive.asm,v 36.26 92/05/21 11:27:02 darren Exp Locker: darren $
**
**	ramdrive device module
**
**	(C) Copyright 1988,1989 Commodore-Amiga, Inc.
**	    All Rights Reserved
**
**	based on code (C) Copyright 1988 Robert R. Burns
**	used with permission
**

	SECTION ramdrive,code

BUILD_BITMAP	EQU	0

**	Included Files

	NOLIST
	INCLUDE "exec/types.i"
	INCLUDE "exec/nodes.i"
	INCLUDE "exec/lists.i"
	INCLUDE "exec/resident.i"
	INCLUDE "exec/libraries.i"
	INCLUDE "exec/io.i"
	INCLUDE "exec/semaphores.i"
	INCLUDE "exec/tasks.i"
	INCLUDE "exec/memory.i"
	INCLUDE "exec/execbase.i"
	INCLUDE "exec/errors.i"
	INCLUDE	"exec/initializers.i"
	INCLUDE	"exec/ables.i"

	INCLUDE "libraries/configregs.i"
	INCLUDE "libraries/expansionbase.i"
	INCLUDE "libraries/dos.i"
	INCLUDE "libraries/dosextens.i"
	INCLUDE "libraries/filehandler.i"

	INCLUDE "devices/trackdisk.i"

	INCLUDE	"internal/librarytags.i"

	LIST

	INCLUDE "ramdrive_rev.i"

**	Imported Names

CALLLVO MACRO
		CALLLIB _LVO\1
	ENDM

XLVO	MACRO
	XREF	_LVO\1
	ENDM


	TASK_ABLES			;for PERMIT macro

	XLVO	AddHead			; Exec
	XLVO	AllocAbs		;
	XLVO	CloseLibrary		;
	XLVO	Enqueue			;
	XLVO	FindName		;
	XLVO	FindResident		;
	XLVO	FreeMem			;
	XLVO	InitSemaphore		;
	XLVO	InitStruct		;
	XLVO	ObtainSemaphore		;
	XLVO	OpenLibrary		;
	XLVO	AllocMem		;
	XLVO	CopyMem			;
	XLVO	TaggedOpenLibrary	;
	XLVO	ReleaseSemaphore	;
	XLVO	ReplyMsg		;
	XLVO	SumKickData		;
	XLVO	CacheClearU		;

	XLVO	MakeDosNode		; Expansion

	XLVO	UMult32			; Utility

	XLVO	DateStamp		; Dos
	XLVO	LockDosList		;
	XLVO	NextDosEntry		;
	XLVO	UnLockDosList		;


**	Local Structures

RDB_PROTECT	EQU	0
RDB_NOBOOT	EQU	1

MAXUNITS	EQU	100	; don't make more than 0-99

DEVICEMODPRI	EQU	25	; before unit module initialization
UNITMODPRI	EQU	20	; same as trackdisk device

DVN_RESERVED	EQU	64	; <=64 reserved for dn_Startup

KICKMEMTYPE	EQU	(MEMF_NO_EXPUNGE!MEMF_REVERSE!MEMF_KICK)

 STRUCTURE	RamdriveDevice,LIB_SIZE
    APTR    rd_ExecLib
    STRUCT  rd_SSemaphore,SS_SIZE
    STRUCT  rd_UnitList,MLH_SIZE
    LABEL   RamdriveDevice_SIZEOF

 STRUCTURE	RamdriveUnit,MLN_SIZE	; also for allocation corruption
    APTR    ru_Data			; pointer to start of disk data
    STRUCT  ru_ResidentTag,RT_SIZE
    STRUCT  ru_ResidentName,20		; "ramdrive.unit ##\r\n\0"
    STRUCT  ru_ResidentInitCode,6	; JSR UnitInit
    STRUCT  ru_KickMemEntry,ML_SIZE+(2*ME_SIZE)
    STRUCT  ru_KickResArray,8		; (two longword entries)
    STRUCT  ru_BootNode,BootNode_SIZEOF
    LABEL   ru_MakeDosData		; thru ru_DosEnvec
    APTR    ru_DrivePtr			; pointer to ru_DriveName
    APTR    ru_DevicePtr		; pointer to "ramdrive.device"
    ULONG   ru_UnitNum
    ULONG   ru_FirstFlags		; flags associated w/ first open
    STRUCT  ru_DosEnvec,DosEnvec_SIZEOF
    STRUCT  ru_DriveName,32		; e.g. RAD: (from mount entry)
    ULONG   ru_LastFlags		; flags associated w/ last open
    ULONG   ru_MaxBytes			; maximum size in bytes
    UBYTE   ru_BootPri			; cache boot pri
    LABEL   RamdriveUnit_SIZEOF

**********************************************************************
**	Device Initialization
**********************************************************************

**	Resident Tag

DeviceResidentTag:
		dc.w	RTC_MATCHWORD
		dc.l	DeviceResidentTag
		dc.l	DeviceResidentEnd
		dc.b	RTF_AUTOINIT!RTF_COLDSTART
		dc.b	VERSION
		dc.b	NT_DEVICE
		dc.b	DEVICEMODPRI
		dc.l	DeviceName
		dc.l	DeviceID
		dc.l	DeviceAutoInit

**	AUTOINIT Table

DeviceAutoInit:
		dc.l	RamdriveDevice_SIZEOF
		dc.l	FuncInitTable
		dc.l	0		; no InitStruct data
		dc.l	DeviceInitFunction

**	Device Function Initialization Table

FuncInitTable:
		dc.w	-1
		dc.w	DeviceOpen-FuncInitTable
		dc.w	DeviceClose-FuncInitTable
		dc.w	DeviceExpunge-FuncInitTable
		dc.w	DeviceNil-FuncInitTable
		dc.w	DeviceBeginIO-FuncInitTable
		dc.w	DeviceAbortIO-FuncInitTable
		dc.w	DeviceKillRAD0-FuncInitTable
		dc.w	DeviceKillRAD-FuncInitTable
		dc.w	-1

**	Device Initialization Code

DeviceInitFunction:
		move.l	a5,-(a7)
		move.l	d0,a5
		;--	too few to justify InitStruct table
		move.w	#REVISION,LIB_REVISION(a5)
		move.w	#1,LIB_OPENCNT(a5)

		move.l	a6,rd_ExecLib(a5)

		lea	rd_UnitList(a5),a1
		NEWLIST	a1

		lea	rd_SSemaphore(a5),a0
		CALLLVO InitSemaphore

		move.l	a5,d0
		move.l	(a7)+,a5
		rts


**********************************************************************
**	Unit Initialization
**********************************************************************

UnitInit:
		move.l	(a7)+,a0	; get @@ ru_ResidentInitCode+6
		movem.l	d7/a4-a5,-(a7)
		lea	-ru_ResidentInitCode-6(a0),a4

		;-- find ramdrive.device
		lea	DeviceList(a6),a0
		lea	DeviceName(pc),a1
		CALLLVO	FindName
		tst.l	d0
		beq.s	uiFail1
		move.l	d0,a5

		;-- mount the unit
		;--	get the expansion library that know how to mount things
		moveq	#OLTAG_EXPANSION,d0
		CALLLVO TaggedOpenLibrary
		move.l	d0,d7
		beq.s	uiFail1

		;--	set up Mount node
		exg	d7,a6
		lea	ru_MakeDosData(a4),a0
		CALLLVO MakeDosNode
		lea	eb_MountList(a6),a0	; get eb_MountList for Enqueue
		exg	d7,a6
		move.l	d0,ru_BootNode+bn_DeviceNode(a4)
		beq.s	uiFail2

		;-- restore boot priority

		move.b	ru_BootPri(a4),ru_BootNode+LN_PRI(a4)
		
		;--	add ru_BootNode (containing Mount node) to system list
		lea	ru_BootNode(a4),a1
		CALLLVO Enqueue

		;-- add unit to device
		lea	rd_UnitList(a5),a0
		move.l	a4,a1
		CALLLVO	AddHead

uiFail2:
		move.l	d7,a1		; ExpansionBase
		CALLLVO CloseLibrary

uiFail1:
		movem.l	(a7)+,d7/a4-a5
		rts


**********************************************************************
**	Drive Boot Code
**********************************************************************

**	Overlapped Fake Expansion Structures

	; -- ConfigDev		; -- BootDiagArea
	; Type	; (Prod)
	; (Flag	; Res03)	; Config; (Flags)
	; (Manufacturer)	; (Size)
	; (Serial ...		; (DiagPoint) 
	;   ... Number)		; Autoboot
	; (InitDiagVec)		; DeviceName
	; BootDiagArea
	;   ...

FakeConfigDev	equ	*-cd_Rom
		dc.b	ERTF_DIAGVALID			; er_Type
		dc.b	0				; er_Product
BootDiag	dc.b	DAC_CONFIGTIME	; da_Config	; er_Flags
		dc.b	0		; da_Flags	; er_Reserved03
		dc.w	0		; da_Size	; er_Manufacturer
		dc.w	0		; da_DiagPoint	; er_SerialNumber
		dc.w	AutoBoot-BootDiag ; da_BootPoint ;  ...
		dc.w	DeviceName-BootDiag ; da_Name	; er_InitDiagVec
rrPatch10	dc.l	BootDiag			; er_Reserved0c...0f

		;--	AutoBoot code
AutoBoot:

		moveq	#OLTAG_DOS,d0
		CALLLVO	TaggedOpenLibrary		;does InitResident()!
							;should not return
**		lea	DosName(pc),a1
**		CALLLVO FindResident
**		tst.l	d0
**		beq.s	abRts
**
**		move.l	d0,a0
**		move.l	RT_INIT(a0),a0
**		jsr	(a0)
abRts:
		rts

**********************************************************************
**	Byte-aligned Constants
**********************************************************************

DeviceName	dc.b	'ramdrive.device',0
RDNAMELEN	EQU	*-DeviceName-1
**DosName		dc.b	'dos.library',0
DeviceID	VSTRING
		ds.w	0


**********************************************************************
**	Device Commands
**********************************************************************

*****i* ramdrive.device/Open *****************************************
*
*   error = OpenDevice(name, unit, ioReq, flags);
*   d0			     d0	   a1	  d1
*
*   a6 contains device node
*   Invoked while Forbid
*
*   0x01 flag write-protects the disk
*   0x02 flag inhibits booting
*
**********************************************************************
DeviceOpen:
		cmp.l	#MAXUNITS,d0
		bcc.s	doFail		; bge unsigned

		move.l	rd_UnitList(a6),a0
doUnitLoop:
		tst.l	(a0)
		beq.s	doBuildUnit
		cmp.l	ru_UnitNum(a0),d0
		beq.s	doFoundUnit
		move.l	(a0),a0
		bra.s	doUnitLoop

doFoundUnit:
		move.l	d1,ru_LastFlags(a0)
		move.l	a0,IO_UNIT(a1)
		moveq	#0,d0
		rts

doFail:
		moveq	#IOERR_OPENFAIL,d0
		move.b	d0,IO_ERROR(a1)
		rts

doBuildUnit:
		movem.l	d2-d7/a1-a6,-(a7)
		move.l	d0,d4		; cache unit
		move.l	d1,d5		;   and flags
		move.l	a6,a5		;   and device
		move.l	rd_ExecLib(a5),a6

		moveq	#IOERR_OPENFAIL,d2

		;-- acquire needed libraries
		;--	dos.library
		moveq	#OLTAG_DOS,d0	; need XxxxDosList() functions
		CALLLVO TaggedOpenLibrary
		move.l	d0,d6		; cache & test DosBase
		beq	doDone1		; fail w/ IOERR_OPENFAIL

		;--	utility.library
		moveq	#OLTAG_UTILITY,d0
		CALLLVO TaggedOpenLibrary
		move.l	d0,d7		; cache & test UtilityBase
		beq	doDone2		; fail w/ IOERR_OPENFAIL

		;-- find out how big to make the ram disk
		;--	find the device in the DOS DevInfo list
		exg.l	d6,a6		; cache SysBase & use DosBase
		moveq	#LDF_DEVICES!LDF_READ,d1
		CALLLVO	LockDosList
		move.l	d0,d1

doDosEntryLoop:
		moveq	#LDF_DEVICES!LDF_READ,d2
		CALLLVO	NextDosEntry
		move.l	d0,a2

		;--	    end of list?
		tst.l	d0
		beq	doGotDevNode

		;--	    compare the startup structures
		move.l	dn_Startup(a2),d0 ; get startup BPTR
		cmpi.l	#DVN_RESERVED,d0
		bls.s	doNextDosEntry	; not there, not this device

		lsl.l	#2,d0		; must be > than 256 per check
		move.l	d0,a3		; above against DVN_RESERVED

		;--	    compare unit
		cmp.l	fssm_Unit(a3),d4
		bne.s	doNextDosEntry

		;--	    compare the device names
		move.l	fssm_Device(a3),d0
		lsl.l	#2,d0
		move.l	d0,a0
		moveq	#0,d1

		;-- coded such that BSTR length may, or may not include
		;-- trailing 0 (lets not read 1 past end of string
		;-- if it doesn't!)


		move.b	(a0)+,d1	; BSTR length
		lea	DeviceName(pc),a1

1$:
		move.b	(a1)+,d0	; 'ramdrive.device',0 
		beq.s	ifGotDevNode

		sub.b	#1,d1		; BSTR length -1
		bmi.s	doNextDosEntry

		cmp.b	(a0)+,d0	; string,[0]
		beq.s	1$

doNextDosEntry:
		move.l	a2,d1
		bra.s	doDosEntryLoop

		;-- found NULL in 'ramdrive.device', see if we are
		;-- already at end of BSTR, or if we found ending NULL
		;-- in BSTR

ifGotDevNode:	

		tst.b	d1
		beq.s	doGotDevNode

		tst.b	(a0)		; found NULL @@ end of BSTR?
		bne.s	doNextDosEntry

doGotDevNode:
		moveq	#LDF_DEVICES!LDF_READ,d1
		CALLLVO	UnLockDosList
		exg	d6,a6		; cache DosBase & use SysBase 

		move.l	a2,d0		; check for failure to find entry
		beq	doFail3

		;-- allocate the RamdriveUnit
		move.l	#RamdriveUnit_SIZEOF,d0
		move.l	#KICKMEMTYPE,d1
		CALLLVO	AllocMem
		tst.l	d0
		beq	doFail3
		move.l	d0,a4

		;-- fill the RamdriveUnit
		;--	initialize the constants
		lea	UnitInitTable(pc),a1
		exg	a2,a4
		move.l	#RamdriveUnit_SIZEOF,d0
		CALLLVO	InitStruct
		exg	a2,a4

		;--	initialize the self-pointers
		move.l	a4,ru_KickMemEntry+ML_ME+ME_ADDR(a4)
		lea	ru_ResidentTag(a4),a0
		move.l	a0,ru_ResidentTag+RT_MATCHTAG(a4)
		move.l	a0,ru_KickResArray(a4)
		lea	ru_ResidentName(a4),a0
		move.l	a0,ru_ResidentTag+RT_NAME(a4)
		move.l	a0,ru_ResidentTag+RT_IDSTRING(a4)
		move.l	a0,ru_KickMemEntry+LN_NAME(a4)
		lea	ru_ResidentInitCode(a4),a0
		move.l	a0,ru_ResidentTag+RT_INIT(a4)
		lea	ru_DriveName(a4),a0
		move.l	a0,ru_DrivePtr(a4)
		lea	RamdriveUnit_SIZEOF(a4),a0
		move.l	a0,ru_ResidentTag+RT_ENDSKIP(a4)

		;--	initialize the rest
		;--	    set the numeric digits in the unit name
		move.l	d4,d0
		divu	#10,d0
		add.b	d0,ru_ResidentName+14(a4)
		swap	d0
		add.b	d0,ru_ResidentName+15(a4)

		;--	    set the unit & flags
		move.l	d4,ru_UnitNum(a4)
		move.l	d5,ru_FirstFlags(a4)
		move.l	d5,ru_LastFlags(a4)

		;--	    copy environment vector
		move.l	fssm_Environ(a3),d0
		lsl.l	#2,d0
		move.l	d0,a0
		lea	ru_DosEnvec(a4),a1
		move.l	(a0)+,d0		; de_TableSize
		cmp.l	#DE_UPPERCYL,d0
		blt	doFail4		; not enough information to calc size

		moveq	#(DosEnvec_SIZEOF/4)-1,d1
		cmp.l	d0,d1
		bls.s	doCopyEnvironment	; ble unsigned
		move.l	d0,d1
doCopyEnvironment:
		move.l	d1,d0
		bra.s	doCopyEnvironmentEntry
doCopyEnvironmentLoop:
		move.l	(a0)+,d0
doCopyEnvironmentEntry:
		move.l	d0,(a1)+
		dbf	d1,doCopyEnvironmentLoop

		;--	    copy the dos drive name
		move.l	dn_Name(a2),d0
		lsl.l	#2,d0
		move.l	d0,a0
		lea	ru_DriveName(a4),a1
		moveq	#0,d0
		move.b	(a0)+,d0
		subq	#1,d0
doCopyDriveName:
		move.b	(a0)+,(a1)+
		dbf	d0,doCopyDriveName
		clr.b	(a1)

		;--	check if booting is enabled

		btst	#RDB_NOBOOT,d5
		bne.s	doGetDiskData	; explicitly disabled
		move.l	ru_DosEnvec+de_BootPri(a4),d0
		cmp.l	#-128,d0	; disabled because priority < -128
		blt.s	doGetDiskData
		cmp.l	#127,d0
		ble.s	doSetBootable
		moveq	#127,d0		; clip high priority to highest byte val
doSetBootable:
		move.b	#NT_BOOTNODE,ru_BootNode+LN_TYPE(a4)
		move.b	d0,ru_BootNode+LN_PRI(a4)

doGetDiskData:
		;-- cache priority
		move.b	ru_BootNode+LN_PRI(a4),ru_BootPri(a4)

		;-- get disk data size
		cmp.l	#128,ru_DosEnvec+de_SizeBlock(a4)
		bne	doFail4		; not a known disk format

		move.l	ru_DosEnvec+de_HighCyl(a4),d0
		sub.l	ru_DosEnvec+de_LowCyl(a4),d0
		addq.w	#1,d0
		;--	perform 32x32 multiplies w/ utility.library
		exg	d7,a6
		move.l	ru_DosEnvec+de_Surfaces(a4),d1
		CALLLVO	UMult32
		move.l	ru_DosEnvec+de_BlocksPerTrack(a4),d1
		CALLLVO	UMult32
		exg	d7,a6
		move.l	d0,d3		; save for root block calculation
		moveq	#9,d1		; 2^9 == 512
		lsl.l	d1,d0		; multiply by 512 to get byte size
		beq	doFail4

		;-- cache max size for safety check at r/w time

		move.l	d0,ru_MaxBytes(a4)

		;-- allocate the disk data
		addq.l	#8,d0		; for allocation corruption
		move.l	d0,d2		; save allocation size
		move.l	#KICKMEMTYPE,d1
		CALLLVO	AllocMem
		move.l	d0,ru_KickMemEntry+ML_ME+ME_SIZE+ME_ADDR(a4)
		beq	doFail4

		move.l	d2,ru_KickMemEntry+ML_ME+ME_SIZE+ME_LENGTH(a4)

		addq.l	#8,d0		; skip over corruption pad
		move.l	d0,ru_Data(a4)


		;-- format the drive
		;--	initialize boot block
		move.l	ru_DosEnvec+de_DosType(a4),d1
		bne.s	doDosTypeSet
		move.l	#ID_DOS_DISK,d1		; default dos type
doDosTypeSet:
		move.l	d0,a0
		moveq	#127,d0
doBootBlockLoop:
		move.l	d1,(a0)+
		dbf	d0,doBootBlockLoop

		;--	calculate the root key offset
		move.l	d3,d0
		subq.l	#1,d0
		add.l	ru_DosEnvec+de_Reserved(a4),d0
		lsr.l	#1,d0
	IFNE	BUILD_BITMAP
		move.l	d0,d5		; cache root block number
	ENDC
		moveq	#9,d1		; 2^9 == 512
		lsl.l	d1,d0		; multiply by 512 to get byte offset

		add.l	ru_Data(a4),d0
		move.l	d0,a2

		;--	clear the root block
		move.l	a2,a1
		moveq	#127,d0
		moveq	#0,d1
doClearRootLoop:
		move.l	d1,(a1)+
		dbf	d0,doClearRootLoop

		;--	fill in root key
		;--	    constants
		moveq	#2,d0		; Type = T.SHORT
		move.l	d0,(a2)		;
		moveq	#1,d0		; Secondary Type = ST.ROOT
		move.l	d0,508(a2)	;
		moveq	#(128-56),d0	; Hash Table Size
		move.l	d0,12(a2)	;

		;--	    dates
		exg	d6,a6
		lea	484(a2),a0	; Create Date
		move.l	a0,d1
		CALLLVO DateStamp
		lea	420(a2),a0	; Last Altered Date
		move.l	a0,d1
		CALLLVO DateStamp
		exg	d6,a6

		;--	    default volume name
		move.l	#$0552414D,432(a2)	; 5,'RAM'
		move.b	#'_',436(a2)		;      '_'
		cmp.w	#10,d4
		blt.s	doVolNameN
		move.b	#$06,432(a2)		; 6,
		move.b	ru_ResidentName+14(a4),437(a2) ;'#'
		move.b	ru_ResidentName+15(a4),438(a2) ; '#'
		bra.s	doBitmap
doVolNameN:
		move.b	ru_ResidentName+15(a4),437(a2) ;'#'

doBitmap:
	IFNE	BUILD_BITMAP
		;--	Check if bitmap can fit in one block.
		;	Compare the amount of memory reserved for disk data
		;	with that required by 127 longwords of 32 block
		;	descriptors (i.e. one bitmap block).
		;	If the disk is greater than that (~2M), it's not
		;	really an error -- the Validator will build the
		;	bitmap, but with an annoying requestor.
		sub.l	ru_DevEnvec+de_Reserved(a4),d3
		cmpi.l	#(127*32),d3
		bgt.s	doRootCheckSum
		;--	    point to the bitmap from the root
		move.l	d5,d0
		addq.l	#1,d0
		move.l	d0,316(a2)	; first bitmap page
		moveq	#-1,d0		; $FFFFFFFF
		move.l	d0,312(a2)	; BMFLAG true
		;--	    indicate the allocated blocks
		;		beyond the end of the bit map can be trash
		;		so make them ones (easy to set & sum)
		lea	516(a2),a1	; first bits
		move.l	a1,a0
		moveq	#(127-1),d1	; dbf counter for 127 longs
doBitMapSetLoop:
		move.l	d0,(a0)+
		dbf	d1,doBitMapSetLoop

		;--	    root block and this block are not free
		;		clear those bits and adjust the checksum
		;		(checksum of 127 $FFFFFFFFs is $0000007F)
		;--		root block
		move.l	d3,d1
		move.l	d3,d2
		and.w	#$1f,d1		; get bit number
		bclr	d1,d0		; clear the bit in the longword
		lsr.l	#5,d2		; get long offset
		lsl.l	#2,d2		;
		and.l	d0,0(a1,d2.l)	; clear this block's bit
		not.l	d0		; get the bit not set
		moveq	#$7F,d1
		add.l	d0,d1		; add it back to checksum
		;--		bitmap block
		addq.l	#1,d3
		move.l	d3,d2
		and.w	#$1f,d3		; get bit number
		moveq	#-1,d0
		bclr	d3,d0		; clear the bit in the longword
		lsr.l	#5,d2		; get long offset
		lsl.l	#2,d2		;
		and.l	d0,0(a1,d2.l)	; clear this block's bit
		not.l	d0		; get the bit not set
		add.l	d0,d1		; add it back to checksum
		;--	    store bitmap checksum
		move.l	d1,512(a2)

	ENDC
		;--	    checksum root key
doRootCheckSum:
		move.l	a2,a0
		moveq	#127,d0
		moveq	#0,d1
doRootCheckSumLoop:
		add.l	(a0)+,d1
		dbf	d0,doRootCheckSumLoop
		neg.l	d1
		move.l	d1,20(a2)

		;-- We built a JSR in high memory; clear cache

		CALLLVO	CacheClearU

		;-- add disk unit to KickMem
		;-- (under Forbid of this exec's invocation of this Open)
		;--	add KickMem to head of exec list
		lea	ru_KickMemEntry(a4),a0
		move.l	KickMemPtr(a6),(a0)
		move.l	a0,KickMemPtr(a6)
		;--	add KickTag to head of exec list
		lea	ru_KickResArray(a4),a0
		move.l	KickTagPtr(a6),4(a0)
		beq.s	tagListOK
		bset	#7,4(a0)	; link to previous head tag
tagListOK:
		move.l	a0,KickTagPtr(a6)
		CALLLVO SumKickData
		move.l	d0,KickCheckSum(a6)

		;-- add disk unit to library
		lea	rd_UnitList(a5),a0
		move.l	a4,a1
		CALLLVO	AddHead

		moveq	#0,d2		; no error
doDone3:
		move.l	d7,a1
		CALLLVO	CloseLibrary
doDone2:
		move.l	d6,a1
		CALLLVO	CloseLibrary
doDone1:
		move.l	d2,d0
		move.l	a4,d1
		movem.l	(a7)+,d2-d7/a1-a6
		move.l	d1,IO_UNIT(a1)
		move.b	d0,IO_ERROR(a1)
		rts

doFail4:
		move.l	a4,a1
		move.l	#RamdriveUnit_SIZEOF,d0
		CALLLVO	FreeMem
		suba.l	a4,a4

doFail3:
		moveq	#IOERR_OPENFAIL,d2
;; Enable this code?   Saves ROM without
;;		move.l	ThisTask(a6),a0
;;		cmp.b	#NT_PROCESS,LN_TYPE(a0)
;;		bne.s	doDone3
;;
;;		moveq	#ERROR_NO_FREE_STORE,d1
;;		move.l	d1,pr_Result2(a0)
		bra.s	doDone3


UnitInitTable:
	    INITWORD	ru_ResidentTag+RT_MATCHWORD,RTC_MATCHWORD
	    INITBYTE	ru_ResidentTag+RT_FLAGS,RTF_COLDSTART
	    INITBYTE	ru_ResidentTag+RT_PRI,UNITMODPRI
	    INITSTRUCT	1,ru_ResidentName,,8
		dc.b	'ramdrive.unit 00',13,10
	    INITWORD	ru_ResidentInitCode,$4eb9	; JSR ...
	    INITLONG	ru_ResidentInitCode+2,UnitInit	;   UnitUnit
	    INITWORD	ru_KickMemEntry+ML_NUMENTRIES,2
	    INITLONG	ru_KickMemEntry+ML_ME+ME_LENGTH,RamdriveUnit_SIZEOF
	    INITLONG	ru_BootNode+LN_NAME,FakeConfigDev
	    INITLONG	ru_DevicePtr,DeviceName
		dc.w	0


*****i*	ramdrive.device/Close ****************************************
DeviceClose:
DeviceExpunge:
DeviceNil:
DeviceAbortIO:
		moveq	#0,d0
		rts


*****i* ramdrive.device/BeginIO***************************************
DeviceBeginIO:
		movem.l a2-a6,-(a7)

		move.l	a1,a3		; cache IO request
		move.l	IO_UNIT(a3),a4	; get unit address
		move.l	a6,a5		; cache device address
		move.l	rd_ExecLib(a5),a6

		;--	protect access to disk data
		lea	rd_SSemaphore(a5),a0
		CALLLVO ObtainSemaphore

		;--	check bounds of command
		move.w	IO_COMMAND(a3),d0
		andi.w	#$7fff,d0	;mask out extended commands
		cmpi.w	#DISKCOMMANDCNT,d0
		bcs.s	dbKnownCommand	; blt unsigned
		clr.w	d0
dbKnownCommand:
		;--	find command entry point
		add.w	d0,d0
		jsr	DiskCommands(pc,d0.w)

		move.b	d0,IO_ERROR(a3)

		;--	allow access to disk data
		lea	rd_SSemaphore(a5),a0
		CALLLVO ReleaseSemaphore

		btst	#IOB_QUICK,IO_FLAGS(a3)
		bne.s	dbQuickOut

		;--	reply the command
		move.l	a3,a1
		CALLLVO ReplyMsg

dbQuickOut:
		movem.l (a7)+,a2-a6
		rts

DiskCommands:
		bra.s	DiskInvalid
		bra.s	DiskReset
		bra.s	DiskRead
		bra.s	DiskWrite

		bra.s	DiskUpdate
		bra.s	DiskClear
		bra.s	DiskStop
		bra.s	DiskStart

		bra.s	DiskFlush
		bra.s	DiskMotor
		bra.s	DiskSeek
		bra.s	DiskFormat

		bra.s	DiskRemove
		bra.s	DiskChangeNum
		bra.s	DiskChangeState
		bra.s	DiskProtStatus

DISKCOMMANDCNT	EQU (*-DiskCommands)/2


**********************************************************************
**********************************************************************
*
*   Disk Commands
*
**********************************************************************
**********************************************************************
DiskInvalid:
DiskReset:
DiskStop:
DiskStart:
DiskFlush:
DiskSeek:
		moveq	#IOERR_NOCMD,d0
		rts


*****i* Motor ********************************************************
*
*   The motor is always on.
*
*****i* ChangeNum ****************************************************
*
*   The disk change count is always 1
*
**********************************************************************
DiskMotor:
DiskChangeNum:
oneActual:
		moveq	#1,d0
		move.l	d0,IO_ACTUAL(a3)
		;------ fall through to report no error

*****i* Update *******************************************************
*
*   This driver always immediately writes
*
*****i* Clear ********************************************************
*
*   This driver always reads fresh data
*
*****i* Remove *******************************************************
*
*   Since the disk is always in the drive, the associated software
*   interrupt is never invoked, but this command is accepted without
*   error.
*
**********************************************************************
DiskUpdate:
DiskClear:
DiskRemove:
		moveq	#0,d0
		rts


*****i* ProtStatus ***************************************************
*
*   The disk protection is forever, as DiskChange is not implemented.
*
**********************************************************************
DiskProtStatus:
		btst	#RDB_PROTECT,ru_LastFlags+3(a4)
		bne.s	oneActual

	;------ fall thru to zero actual

*****i* ChangeState **************************************************
*
*   The disk is always in the drive
*
**********************************************************************
DiskChangeState:
		moveq	#0,d0
		move.l	d0,IO_ACTUAL(a3)
		rts


*****i* Read *********************************************************
*
*   Read data from the ram disk.
*
**********************************************************************
DiskRead:
		move.l	ru_Data(a4),d0
		beq.s	killedData
		move.l	IO_OFFSET(a3),d1
		add.l	d1,d0
		move.l	d0,a0
		move.l	IO_DATA(a3),a1

		bra.s	transfer

**********************************************************************
killedData:
		moveq	#TDERR_DiskChanged,d0
		rts

*****i* Write ********************************************************
*
*   Write data to the ram disk.
*
**********************************************************************
*****i* Format *******************************************************
*
*   Format data to the ram disk -- same as a write.
*
**********************************************************************
DiskWrite:
DiskFormat:
		btst	#RDB_PROTECT,ru_LastFlags+3(a4)
		bne.s	protectedDisk

		move.l	IO_DATA(a3),a0
		move.l	ru_Data(a4),d0
		beq.s	killedData
		move.l	IO_OFFSET(a3),d1
		add.l	d1,d0
		move.l	d0,a1

transfer:
		move.l	IO_LENGTH(a3),d0
		add.l	d0,d1		;length + offset
		cmp.l	ru_MaxBytes(a4),d1
		bhi.s	maxexceeded

		CALLLVO	CopyMem		; A6 is ready to go

emptyTransfer:
		move.l	IO_LENGTH(a3),IO_ACTUAL(a3)
		moveq	#0,d0
		rts

protectedDisk:
		moveq	#TDERR_WriteProt,d0
		rts

maxexceeded:
		moveq	#IOERR_BADLENGTH,d0
		rts

******* ramdrive.device/KillRAD0 *************************************
*
*   NAME
*	KillRAD0 -- kill ramdrive.device unit 0
*
*   SYNOPSIS
*	devName = KillRAD(unit)
*
*	char *KillRAD( ULONG );
*
*   FUNCTION
*	Perform a KillRAD(0).  This function is retained for
*	historical reasons.
*
*   SEE ALSO
*	ramdrive.device/KillRAD
*
**********************************************************************
DeviceKillRAD0:
		moveq	#0,d0

******* ramdrive.device/KillRAD **************************************
*
*   NAME
*	KillRAD -- kill ramdrive.device unit
*
*   SYNOPSIS
*	devName = KillRAD(unit)
*
*	char *KillRAD( ULONG );
*
*   FUNCTION
*	Kill a RAD: disk and return its memory.  First, remove the
*	system hooks that recover the disk memory after reset, then
*	free the disk memory, and return the dos device name.
*
*   INPUTS
*	unit - the unit of the ramdrive.device to kill.
*
*   RESULTS
*	devName - a pointer to the colon terminated device name that
*		was associated with this unit.  This is a null
*		terminated C string.
*
**********************************************************************
DeviceKillRAD:
		movem.l a4-a6,-(a7)
		move.l	a6,a5
		move.l	rd_ExecLib(a5),a6

		;-- find the specified unit
		move.l	rd_UnitList(a5),a4
dkuFindUnit:
		move.l	(a4),d1
		beq	dkuNoUnit
		cmp.l	ru_UnitNum(a4),d0
		beq.s	dkuFoundUnit
		move.l	d1,a4
		bra.s	dkuFindUnit

dkuFoundUnit:
		;-- protect access to disk data
		lea	rd_SSemaphore(a5),a0
		CALLLVO ObtainSemaphore

		;-- protect exec's Kick lists

		FORBID

		;-- inhibit reset recovery of the device
		;--	remove KickTag from exec list
		lea	ru_KickResArray(a4),a0
		move.l	KickTagPtr(a6),a1
		cmp.l	a1,a0		; check if this is our tag list
		beq.s	dkuKickTagSlot

dkuNextTagSlot:
		move.l	(a1)+,d0
		bgt.s	dkuNextTagSlot
		beq.s	dkuKillMemList	; (huh? This shouldn't happen!)

		bclr	#31,d0		; get link to next
		cmp.l	d0,a0		; check if this is our tag list
		beq.s	dkuFoundTagSlot
		move.l	d0,a1
		bra.s	dkuNextTagSlot

dkuFoundTagSlot:
		;--	    their next will be what my next was
		move.l	4(a0),-(a1)
		bra.s	dkuKillMemList

dkuKickTagSlot:
		;--	    KickTagPtr will be what my next was
		move.l	4(a0),d0
		bclr	#31,d0
		move.l	d0,KickTagPtr(a6)

dkuKillMemList:
		;	remove KickMem from exec list
		lea	ru_KickMemEntry(a4),a0
		lea	KickMemPtr(a6),a1
dkuCheckMemSlot:
		move.l	(a1),d0
		beq.s	dkuSumKickData	; (huh? This shouldn't happen!)
		cmp.l	d0,a0
		beq.s	dkuFoundMemSlot
		move.l	d0,a1
		bra.s	dkuCheckMemSlot

dkuFoundMemSlot:
		;--	    their next is my next
		move.l	(a0),(a1)

dkuSumKickData:
		CALLLVO SumKickData
		move.l	d0,KickCheckSum(a6)

		PERMIT

		;-- free the disk data
		move.l	ru_KickMemEntry+ML_ME+ME_SIZE+ME_ADDR(a4),a1
		move.l	ru_KickMemEntry+ML_ME+ME_SIZE+ME_LENGTH(a4),d0
		CALLLVO	FreeMem

		clr.l	ru_Data(a4)	; show it's gone

		;-- allow access to (empty) disk data
		lea	rd_SSemaphore(a5),a0
		CALLLVO ReleaseSemaphore

		;-- return drive name terminated with a colon
		lea	ru_DriveName(a4),a0
		move.l	a0,d0
dkuColonedName:
		tst.b	(a0)+
		bne.s	dkuColonedName
		move.b	#':',-(a0)

dkuDone:
		movem.l (a7)+,a4-a6
		rts

dkuNoUnit:
		moveq	#0,d0
		bra.s	dkuDone


**********************************************************************
*
*   end of ram driver
*
**********************************************************************

DeviceResidentEnd:

	END
@


36.26
log
@Set MEMF_NO_EXPUNGE - to be consistent with previous RAD behavior which
did not cause an expunge on mem alloc (usually of a big block!)
@
text
@d2 1
a2 1
**	$Id: ramdrive.asm,v 36.24 91/10/11 16:47:06 darren Exp $
d756 7
@


36.25
log
@Use CopyMem() for size/speed; also protect KillRad with Forbid/Permit
@
text
@d102 1
a102 1
KICKMEMTYPE	EQU	(MEMF_REVERSE!MEMF_KICK)
@


36.24
log
@Use AllocMem MEMF_REVERSE!MEMF_KICK instead of private AllocHigh code -
saves ROM space, and new flag lets us get memory which is available at
kickmem search time.  Use of TaggedOpenLibrary further decreases code size
@
text
@d32 1
d59 2
d72 2
a73 1
	XLVO	AllocMem
d936 1
a936 1
		move.l	IO_DATA(a3),a2
d958 1
a958 1
		bne	protectedDisk
d965 1
a965 1
		move.l	d0,a2
d973 1
a973 3
		lsr.l	#7,d0		; convert length to groups of 128 bytes
		beq.s	emptyTransfer
		subq.l	#1,d0		; adjust for dbf count
a974 35
transferLoop:
		move.l	(a0)+,(a2)+	; copy data 0..3
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	; copy data 124..127
		dbf	d0,transferLoop ; decrement transfer count

d1053 4
d1105 2
@


36.23
log
@CacheClearU called before SumKickData() - ramdrive builds a JSR
instruction in high memory (likely to cause problems on an 040
machine with a large cache)
@
text
@d2 1
a2 1
**	$Id: ramdrive.asm,v 36.22 91/04/15 19:21:24 darren Exp Locker: darren $
d40 3
d69 2
d98 2
d207 2
a208 3
		lea	ExpansionName(pc),a1
		moveq	#34,d0		; 1.3 kickstart
		CALLLVO OpenLibrary
a271 4
		lea	DosName(pc),a1
		CALLLVO FindResident
		tst.l	d0
		beq.s	abRts
d273 11
a283 3
		move.l	d0,a0
		move.l	RT_INIT(a0),a0
		jsr	(a0)
d293 1
a293 3
DosName		dc.b	'dos.library',0
ExpansionName	dc.b	'expansion.library',0
UtilityName	dc.b	'utility.library',0
d349 2
a350 3
		lea	DosName(pc),a1
		moveq	#36,d0		; need XxxxDosList() functions
		CALLLVO OpenLibrary
d355 2
a356 3
		lea	UtilityName(pc),a1
		moveq	#0,d0
		CALLLVO OpenLibrary
d438 2
a439 2
		moveq	#0,d1
		bsr	AllocHigh
d560 2
a561 2
		moveq	#0,d1
		bsr	AllocHigh
a767 75


*****i* AllocHigh ****************************************************
*
*   memory = AllocHigh(size, requirements)
*   d0		       d0    d1
*
*   Fast memory is preferred when requirements are zero.  It is
*   assumed the memory list is sorted so fast memory is first.
*
*   Invoked while Forbid
*
**********************************************************************
AllocHigh:
		movem.l d2-d3/a2-a3,-(a7)

		;------ get first memory header
		move.l	MemList(a6),a0
		moveq	#0,d3		; guess noone big enough

		;------ cycle through memory headers
nextMemHeader:
		move.l	a0,a1
		move.l	(a1),d2		; check for end of list
		beq.s	noMemory
		move.l	d2,a0

		;---------- check this header's attributes
		move.w	d1,d2		; copy desired attributes
		and.w	MH_ATTRIBUTES(a1),d2 ; keep those set in this header
		cmp.w	d1,d2		; check if they're all there
		bne.s	nextMemHeader	; if not, try next header

		;---------- search this memory for a big enough piece at the end
		move.l	MH_FIRST(a1),d2
		beq.s	nextMemHeader	;this one is totally empty
		movea.l	d2,a2
checkMemChunk:
		cmp.l	MC_BYTES(a2),d0
		bhi.s	memTooSmall
		move.l	a2,a3		; this is a candidate
		move.l	MC_BYTES(a2),d3 ;
memTooSmall:
		;-------------- get the next chunk
		move.l	MC_NEXT(a2),d2
		beq.s	noMoreChunks
		move.l	d2,a2
		bra.s	checkMemChunk

noMoreChunks:
		tst.l	d3		; check for candidates
		beq.s	nextMemHeader

		sub.l	d0,d3		; determine excess capacity
		and.w	#(~MEM_BLOCKMASK),d3 ; rounded down to even block
		add.l	d3,a3		; and adjust desired address

		move.l	a3,a1
		CALLLVO AllocAbs
		tst.l	d0
		beq.s	noMemory

allocEnd:
		movem.l (a7)+,d2-d3/a2-a3
		rts

noMemory:
		moveq	#0,d0
		move.l	ThisTask(a6),a0
		cmp.b	#NT_PROCESS,LN_TYPE(a0)
		bne.s	allocEnd

		moveq	#ERROR_NO_FREE_STORE,d1
		move.l	d1,pr_Result2(a0)
		bra.s	allocEnd
@


36.22
log
@New code to handle Andy's new Mount command which "includes"
the NULL terminator in the length of the bstr.  The new code
is meant to work with either the old, or the new Mount (
checks for NULL termination match, and BSTR length)
@
text
@d2 1
a2 1
**	$Id: ramdrive.asm,v 36.21 91/03/20 15:30:36 darren Exp Locker: darren $
d69 1
d697 4
@


36.21
log
@Fix for crash if opened, but not mounted (check for <= 64 dn_Startup
in DeviceInfo list instead of just checking for 0), and now does
validity checking on IO_OFFSET+IO_LENGTH on CMD_READ/CMD_WRITE.
@
text
@d2 1
a2 1
**	$Id: ramdrive.asm,v 36.20 91/01/09 19:46:15 darren Exp Locker: darren $
d381 1
a381 1
		;--	    compare the tail of the device names
d385 8
a392 5
		moveq	#0,d0
		move.b	(a0)+,d0
		sub.w	#RDNAMELEN,d0
		bmi.s	doNextDosEntry	; too short to match
		add.w	d0,a0
d394 1
d396 7
a402 3
		move.b	(a1)+,d0
		beq.s	doGotDevNode	; found a matching tail
		cmp.b	(a0)+,d0
d409 12
d619 1
a619 1
		move.b	#'B',436(a2)		;      'B'
@


36.20
log
@Fix - if MH_FIRST is NULL because the MemHeader is totally
in use, AllocHigh now skips this header, and tries the
next.
@
text
@d2 1
a2 1
**	$Id: ramdrive.asm,v 36.19 91/01/03 18:56:40 darren Exp Locker: darren $
d90 2
d114 1
d371 2
a372 1
		beq.s	doNextDosEntry	; not there, not this device
d374 2
a375 2
		lsl.l	#2,d0
		move.l	d0,a3
d526 4
d973 2
a974 1
		add.l	IO_OFFSET(a3),d0
d1003 2
a1004 1
		add.l	IO_OFFSET(a3),d0
d1009 4
d1061 3
@


36.19
log
@Cache, and restore boot priority unit init time for the case
where BootMenu ups a RAD unit to priority 127.  In this case
you'd have to come up clean, or use BootMenu to boot off of
any other bootable device.  Also, emulation of trackdisk
extended commands now implemented.
@
text
@d2 1
a2 1
**	$Id: ramdrive.asm,v 36.18 90/06/04 11:11:06 kodiak Exp Locker: darren $
d763 3
a765 1
		move.l	MH_FIRST(a1),a2
@


36.18
log
@fix RemUnit
@
text
@d2 1
a2 1
**	$Id: ramdrive.asm,v 36.17 90/06/01 17:35:45 kodiak Exp Locker: kodiak $
d77 1
a77 1
	XLVO	UnlockDosList		;
d112 1
d211 4
d399 1
a399 1
		CALLLVO	UnlockDosList
d486 1
d499 3
a502 1
doGetDiskData:
d828 1
@


36.17
log
@back out use of format packet -- back to custom code
@
text
@d2 1
a2 1
**	$Id: ramdrive.asm,v 36.16 90/06/01 15:04:39 kodiak Exp Locker: kodiak $
d1091 1
a1091 1
		beq.s	dkuNoUnit
d1105 3
a1107 4
		lea	KickTagPtr(a6),a1
dkuCheckTagSlot:
		cmp.l	(a1),a0		; check if this is our tag list
		beq.s	dkuFoundTagSlot
a1108 1
		move.l	(a1),a1		; find the end of this tag list
d1115 2
d1118 1
a1118 1
		bra.s	dkuCheckTagSlot
d1121 3
a1123 2
		;--	    their next is my next
		move.l	4(a0),(a1)
d1125 6
a1135 2
		cmp.l	(a1),a0
		beq.s	dkuFoundMemSlot
d1138 2
d1171 1
a1171 1
		movem.l (a7)+,a4-a5
@


36.16
log
@use format packet instead of local code
@
text
@d2 1
a2 1
**	$Id: ramdrive.asm,v 36.15 90/04/13 11:29:28 kodiak Exp Locker: kodiak $
d15 2
d74 1
a74 1
	XLVO	DoPkt			; Dos
d85 1
a85 1
MAXUNITS	EQU	100
d333 1
a333 1
		moveq	#36,d0		; need Format() function
d348 1
a348 1
		moveq	#LDF_DEVICES,d1
d353 1
a353 1
		moveq	#LDF_DEVICES,d2
d393 1
a393 1
		moveq	#LDF_DEVICES,d1
d509 1
d529 10
a538 31
		exg	d6,a6
		;--	format only while inhibited
		;--	inhibit using packet to use dos_Task directly
		move.l	dol_Task(a2),d1
		moveq	#ACTION_INHIBIT,d2
		moveq	#DOSTRUE,d3
		CALLLVO	DoPkt
		;--	format using packet to use dos_Task directly
		move.l	dol_Task(a2),d1
		move.l	#ACTION_FORMAT,d2
		;--	dp_Arg1: volume name
		link	a3,#-6
		move.l	a3,d3
		subq.l	#6,d3
		tst.l	d4
		beq.s	doVolName0
		move.l	#$52414400,(a3)+	; "RAD##"
		move.b	ru_ResidentName+14(a4),-1(a3)
		move.b	ru_ResidentName+15(a4),(a3)+
		clr.b	(a3)
		bra.s	doGetDosType
doVolName0:
		move.l	#$52414400,(a3)		; "RAD"
		;--	dp_Arg2: dos type
doGetDosType:
		move.l	ru_DosEnvec+de_DosType(a4),d4
		bne.s	doDosFormat
		move.l	#ID_DOS_DISK,d4		; default dos type
doDosFormat:
		CALLLVO DoPkt
		unlk	a3
d540 32
a571 5
		;--	uninhibit using packet to use dos_Task directly
		move.l	dol_Task(a2),d1
		moveq	#ACTION_INHIBIT,d2
		moveq	#DOSFALSE,d3
		CALLLVO	DoPkt
d573 7
d581 80
d714 1
a714 1
	    INITWORD	ru_ResidentInitCode,$4ef9	; JSR ...
d735 1
a735 1
		movem.l d2/d3/a2/a3,-(a7)
d782 1
a782 1
		movem.l (a7)+,d2/d3/a2/a3
@


36.15
log
@use Id instead of Header for 4.x rcs
@
text
@d2 1
a2 1
**	$Id$
d53 14
a66 14
	XLVO	AddHead
	XLVO	AllocAbs
	XLVO	CloseLibrary
	XLVO	Enqueue
	XLVO	FindName
	XLVO	FindResident
	XLVO	FreeMem
	XLVO	InitSemaphore
	XLVO	InitStruct
	XLVO	ObtainSemaphore
	XLVO	OpenLibrary
	XLVO	ReleaseSemaphore
	XLVO	ReplyMsg
	XLVO	SumKickData
d68 1
a68 1
	XLVO	MakeDosNode
d70 1
a70 1
	XLVO	UMult32
d72 4
a75 1
	XLVO	DateStamp
d203 1
a208 2
		move.l	d7,a0
		lea	eb_MountList(a0),a0
d230 1
a230 1
**	Fake Expansion Structures
d232 10
a241 1
		;--	Fake ConfigDev
d243 9
a251 8
		dc.b	ERTF_DIAGVALID	; cd_Rom.er_Type
		dc.b	0		; cd_Rom.er_Product
		dc.b	0		; cd_Rom.er_Flags
		dc.b	0		; cd_Rom.er_Reserved03
		dc.w	0		; cd_Rom.er_Manufacturer
		dc.l	0		; cd_Rom.er_SerialNumber
		dc.w	0		; cd_Rom.er_InitDiagVec
rrPatch10	dc.l	BootDiagArea	; cd_Rom.er_Reserved0c...0f
a252 11
		;--	Fake DiagArea
BootDiagArea:
		dc.b	DAC_CONFIGTIME	; da_Config
		dc.b	0		; da_Flags
		dc.w	0		; da_Size not used
		dc.w	0		; da_DiagPoint
		dc.w	AutoBoot-BootDiagArea ; da_BootPoint
		dc.w	DeviceName-BootDiagArea ; da_Name
		dc.w	0		; da_Reserved01
		dc.w	0		; da_Reserved02

a295 2
		tst.l	d0
		bmi.s	doFail
d297 1
a297 1
		bge.s	doFail
d326 2
d331 1
a331 1
		moveq	#33,d0		; need at least 1.2 kickstart
d334 1
a334 1
		beq	doFail1
d341 1
a341 1
		beq	doFail2
d345 4
a348 7
		;--	(under Forbid of this exec's invocation of this Open)
		move.l	d6,a2		; look in DosBase
		move.l	dl_Root(a2),a2	;   in root
		move.l	rn_Info(a2),a0	;   for Info block
		adda.l	a0,a0		;   (which is a BPTR)
		adda.l	a0,a0		;
		move.l	di_DevInfo(a0),d0 ; get DevInfo BPTR
d350 3
a352 3
doDevNodeLoop:
		beq	doFail3		; end of list, couldn't find it
		lsl.l	#2,d0		;   (adjust BPTR)
a353 2
		tst.l	dn_Type(a2)
		bne.s	doNextDevNode	; not DT_DEVICE
d355 4
d361 1
a361 1
		beq.s	doNextDevNode	; not there, not this device
d368 1
a368 1
		bne.s	doNextDevNode
d377 1
a377 1
		bmi.s	doNextDevNode	; too short to match
d386 3
a388 3
doNextDevNode:
		move.l	(a2),d0		; get next entry in list
		bra.s	doDevNodeLoop
d391 7
a418 2
		lea	RamdriveUnit_SIZEOF(a4),a0
		move.l	a0,ru_ResidentTag+RT_ENDSKIP(a4)
d427 2
d452 6
a457 5
		move.w	d0,d1
		cmp.l	#(DosEnvec_SIZEOF/4)-1,d0
		ble.s	doCopyEnvironmentEntry
		moveq	#(DosEnvec_SIZEOF/4)-1,d0
		move.w	d0,d1
a506 1
		move.l	d0,d3		; save for root block calculation
a525 41
		;--	initialize boot block
		move.l	ru_DosEnvec+de_DosType(a4),d1
		bne.s	doDosTypeSet
		move.l	#ID_DOS_DISK,d1		; default dos type
doDosTypeSet:
		move.l	d0,a0
		moveq	#127,d0
doBootBlockLoop:
		move.l	d1,(a0)+
		dbf	d0,doBootBlockLoop

		;--	calculate the root key offset
		move.l	d3,d0
		subq.l	#1,d0
		add.l	ru_DosEnvec+de_Reserved(a4),d0
		lsr.l	#1,d0
		move.l	d0,d5		; cache root block number
		moveq	#9,d1		; 2^9 == 512
		lsl.l	d1,d0		; multiply by 512 to get byte offset

		add.l	ru_Data(a4),d0
		move.l	d0,a2

		;--	clear the root block
		move.l	a2,a1
		moveq	#127,d0
		moveq	#0,d1
doClearRootLoop:
		move.l	d1,(a1)+
		dbf	d0,doClearRootLoop

		;--	fill in root key
		;--	    constants
		moveq	#2,d0		; Type = T.SHORT
		move.l	d0,(a2)		;
		moveq	#1,d0		; Secondary Type = ST.ROOT
		move.l	d0,508(a2)	;
		moveq	#(128-56),d0	; Hash Table Size
		move.l	d0,12(a2)	;

		;--	    dates
d527 13
a539 9
		lea	484(a2),a0	; Create Date
		move.l	a0,d1
		CALLLVO DateStamp
		lea	420(a2),a0	; Last Altered Date
		move.l	a0,d1
		CALLLVO DateStamp
		exg	d6,a6

		;--	    default volume name
d542 5
a546 3
		move.l	#$05524144,432(a2)	; 5,'RAD##'
		move.w	ru_ResidentName+14(a4),436(a1)
		bra.s	doBitmap
d548 9
a556 1
		move.l	#$03524144,432(a2)	; 3,'RAD'
d558 6
a563 27
doBitmap:
	IFNE	0
		;--	Check if bitmap can fit in one block.
		;	Compare the amount of memory reserved for disk data
		;	with that required by 127 longwords of 32 block
		;	descriptors (i.e. one bitmap block).
		;	If the disk is greater than that (~2M), it's not
		;	really an error -- the Validator will build the
		;	bitmap, but with an annoying requestor.
		sub.l	ru_DevEnvec+de_Reserved(a4),d3
		cmpi.l	#(127*32),d3
		bgt.s	doRootCheckSum
		;--	    point to the bitmap from the root
		move.l	d5,d0
		addq.l	#1,d0
		move.l	d0,316(a2)	; first bitmap page
		moveq	#-1,d0		; $FFFFFFFF
		move.l	d0,312(a2)	; BMFLAG true
		;--	    indicate the allocated blocks
		;		beyond the end of the bit map can be trash
		;		so make them ones (easy to set & sum)
		lea	516(a2),a1	; first bits
		move.l	a1,a0
		moveq	#(127-1),d1	; dbf counter for 127 longs
doBitMapSetLoop:
		move.l	d0,(a0)+
		dbf	d1,doBitMapSetLoop
a564 41
		;--	    root block and this block are not free
		;		clear those bits and adjust the checksum
		;		(checksum of 127 $FFFFFFFFs is $0000007F)
		;--		root block
		move.l	d3,d1
		move.l	d3,d2
		and.w	#$1f,d1		; get bit number
		bclr	d1,d0		; clear the bit in the longword
		lsr.l	#5,d2		; get long offset
		lsl.l	#2,d2		;
		and.l	d0,0(a1,d2.l)	; clear this block's bit
		not.l	d0		; get the bit not set
		moveq	#$7F,d1
		add.l	d0,d1		; add it back to checksum
		;--		bitmap block
		addq.l	#1,d3
		move.l	d3,d2
		and.w	#$1f,d3		; get bit number
		moveq	#-1,d0
		bclr	d3,d0		; clear the bit in the longword
		lsr.l	#5,d2		; get long offset
		lsl.l	#2,d2		;
		and.l	d0,0(a1,d2.l)	; clear this block's bit
		not.l	d0		; get the bit not set
		add.l	d0,d1		; add it back to checksum
		;--	    store bitmap checksum
		move.l	d1,512(a2)

	ENDC
		;--	    checksum root key
doRootCheckSum:
		move.l	a2,a0
		moveq	#127,d0
		moveq	#0,d1
doRootCheckSumLoop:
		add.l	(a0)+,d1
		dbf	d0,doRootCheckSumLoop
		neg.l	d1
		move.l	d1,20(a2)


a610 3
doFail2:
		moveq	#IOERR_OPENFAIL,d2
		bra.s	doDone2
a611 5
doFail1:
		moveq	#IOERR_OPENFAIL,d2
		bra.s	doDone1


d725 1
a725 1
		blt.s	dbKnownCommand
d892 1
a893 1
		lsr.l	#7,d0		; convert length to groups of 128 bytes
d992 1
a992 1
		move.l	rd_UnitList(a6),a4
@


36.14
log
@for rcs 4.x header change
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/ramdrive/RCS/ramdrive.asm,v 36.13 89/12/19 14:41:43 kodiak Exp Locker: kodiak $
@


36.13
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Header: ramdrive.asm,v 36.11 89/12/12 14:35:48 kodiak Exp $
@


36.12
log
@autodoc update
@
text
@@


36.11
log
@rom version, with units
@
text
@d2 1
a2 1
**	$Header$
d145 2
a146 2
		dc.w	DeviceKillUnit0-FuncInitTable
		dc.w	DeviceKillUnit-FuncInitTable
d717 1
a717 1
******* AllocHigh ****************************************************
d880 1
a880 1
******* Motor ********************************************************
d884 1
a884 1
******* ChangeNum ****************************************************
d896 1
a896 1
******* Update *******************************************************
d900 1
a900 1
******* Clear ********************************************************
d904 1
a904 1
******* Remove *******************************************************
d918 1
a918 1
******* ProtStatus ***************************************************
d929 1
a929 1
******* ChangeState **************************************************
d940 1
a940 1
******* Read *********************************************************
d959 1
a959 1
******* Write ********************************************************
d964 1
a964 1
******* Format *******************************************************
d1031 19
a1049 2
*****i* ramdrive.device/KillUnit *************************************
DeviceKillUnit0:
d1051 26
a1076 2
*****i* ramdrive.device/KillUnit0 ************************************
DeviceKillUnit:
a1095 7
		;-- free the disk data
		move.l	ru_KickMemEntry+ML_ME+ME_SIZE+ME_ADDR(a4),a1
		move.l	ru_KickMemEntry+ML_ME+ME_SIZE+ME_LENGTH(a4),d0
		CALLLVO	FreeMem

		clr.l	ru_Data(a4)	; show it's gone

d1137 7
@


36.10
log
@fix kill semaphore usage
@
text
@d1 11
a11 65
*******************************************************************************
*
*   Source Control
*   --------------
*   $Header: ramdrive.asm,v 36.9 89/05/25 12:57:48 kodiak Exp $
*
*   $Locker:  $
*
*   $Log:	ramdrive.asm,v $
*   Revision 36.9  89/05/25  12:57:48  kodiak
*   use semaphore in Kill function, too.
*   
*   Revision 34.26  89/05/25  12:27:06  kodiak
*   fix SignalSemaphore usage
*   
*   Revision 34.25  89/05/16  16:12:50  kodiak
*   use semaphore instead of forbid for single threading
*   
*   Revision 34.24  88/11/16  17:19:03  kodiak
*   look for "ramdrive.device" to match end of names on device list
*   
*   Revision 34.23  88/11/16  11:40:10  kodiak
*   clear NT_BOOTNODE type when not bootable
*   
*   Revision 34.22  88/04/11  10:39:17  kodiak
*   kodiak's major changes:
*   retabbed to 8 spaces...
*   added "no boot" capability
*   added "kill" capability
*   optimized some initialization code
*   
*   pad before open... stupid allocabs
*   
*   Revision 34.10  87/11/20  17:19:41  bart
*   move.l  #(ResidentEnd-Template),d0
*   
*   Revision 34.9  87/11/20  16:55:52  bart
*   move.l  (a7),a0             ; fetch MountList pointer
*   
*   Revision 34.8  87/11/20  16:31:49  bart
*   Template
*   
*   Revision 34.7  87/11/20  14:51:36  bart
*   move.l  4(a7),a0            ; fetch MountList pointer
*   
*   Revision 34.6  87/11/20  14:01:09  bart
*   globvec == -1
*   
*   Revision 34.5  87/11/20  12:58:29  bart
*   obey c linkage rules
*   
*   Revision 34.4  87/11/20  12:09:30  bart
*   VolName     dc.b    5,'RAMB0'
*   
*   Revision 34.2  87/11/20  11:52:17  bart
*   open ffs.resource if available
*   
*   Revision 34.1  87/11/18  16:56:53  bart
*   modifications beginning 11/18/87 Barry A. Whitebook
*   
*   Revision 34.0  87/10/09  12:49:26  bart
*   added to rcs for updating
*   
*
*******************************************************************************
d13 1
a13 6
**********************************************************************
*
*   ramdrive.asm
*
**********************************************************************
	SECTION ramdrive
d15 3
d24 1
a24 1
	INCLUDE	"exec/semaphores.i"
a25 1
	INCLUDE "exec/ables.i"
d29 1
d38 1
a38 1
	INCLUDE	"ramdrive_rev.i"
d40 5
a44 1
CALLLVO	MACRO
d48 3
a50 3
XLVO    MACRO
        XREF    _LVO\1
        ENDM
d53 7
a59 9
	XREF    _intena

ABSEXECBASE	EQU	4
	XLVO    AddDevice
	XLVO    AllocAbs
	XLVO    CloseLibrary
	XLVO    Enqueue
	XLVO    FindResident
	XLVO    FreeMem
d61 1
d63 1
a63 1
	XLVO    OpenLibrary
d65 2
a66 2
	XLVO    ReplyMsg
	XLVO    SumKickData
d68 1
a68 1
	XLVO    DateStamp
d70 1
a70 1
	XLVO    MakeDosNode
d72 1
a72 3
;------ this code is here in case this device is executed
		moveq   #-1,d0      ; show error
		rts
a73 5
**********************************************************************
*
*   Template for data to be made part of resident kickstart list
*
**********************************************************************
d75 1
a75 1
	CNOP    0,4
d77 2
a78 13
ResidentStart	equ	*-8
;------ the ResidentTag is used now, and also patched for use at coldstart
ResidentTag:
		dc.w    RTC_MATCHWORD
rrPatch1	dc.l    ResidentTag
rrPatch2	dc.l    ResidentEnd
pColdstart	dc.b    0
		dc.b    VERSION
		dc.b    NT_DEVICE
		dc.b    20      ; same priority as trackdisk.device
rrPatch3	dc.l    RDName
rrPatch4	dc.l    DeviceID
pInitialize	dc.l    Initialize
d80 1
a80 10
;------ cold boot code structures
;---------- MemList for KickMemPtr
KickMem:
		dc.l    0
		dc.l    0
		dc.b    0,0
rrPatch5	dc.l    RDName
		dc.w    1           ; only 1 entry
rrPatch6	dc.l    ResidentStart    
		dc.l    ResidentEnd-ResidentStart
d82 2
a83 4
;---------- ResArray for KickTagPtr
KickTag:
rrPatch7	dc.l    ResidentTag
		dc.l    0
d85 5
a89 34
;------ Library functions and node for device
DiskFuncs:
pKillDisk	EQU	*+2
		jmp	KillDisk
		rts         		; AbortIO (never queued, not abortable)
		dc.w    0,0
pBeginIO   	EQU	*+2
		jmp	BeginIO		; BeginIO
		rts     		; Null
		dc.w    0,0
		moveq   #0,d0   	; Expunge (never expunged)
		rts
		dc.w    0
		moveq   #0,d0       	; Close (LIB_OPENCNT not kept)
		rts
		dc.w    0
pOpen		EQU	*+2
		jmp 	Open        	; Open
DiskNode:
		dc.l    0           	; ln_Succ
		dc.l    0           	; ln_Pred
		dc.b    NT_DEVICE       ; ln_Type
		dc.b    0           	; ln_Pri
rrPatch8	dc.l    RDName          ; ln_Name
		dc.b    LIBF_SUMUSED!LIBF_CHANGED ; lib_Flags
		dc.b    0
		dc.w    DiskNode-DiskFuncs ; lib_NegSize
		dc.w    DiskNodeEnd-DiskNode ; lib_PosSize
		dc.w    VERSION         ; lib_Version
		dc.w    REVISION        ; lib_Revision
rrPatch9	dc.l    DeviceID        ; lib_IdString
        	dc.l    0           	; lib_Sum
        	dc.w    1           	; lib_OpenCnt
DiskNodeEnd:
d91 17
a107 5
;---------- locations of driver and data in high memory
RDCAddr		dc.l    0           	; driver code (including 8 byte pad)
RDDAddr		dc.l    0           	; disk data (including 8 byte pad)
RDDSize		dc.l    0           	; disk size (including 8 byte pad)
RDData		dc.l	0		; disk data
d109 3
a111 1
RDSSemaphore	dcb.b	SS_SIZE,0	; command signal semaphore
d113 1
a113 10
;------ expansion boot data
FakeConfigDev	equ	*-cd_Rom
		dc.b    ERTF_DIAGVALID  ; cd_Rom.er_Type
		dc.b    0           	; cd_Rom.er_Product
		dc.b    0           	; cd_Rom.er_Flags
		dc.b    0           	; cd_Rom.er_Reserved03
		dc.w    0           	; cd_Rom.er_Manufacturer
		dc.l    0           	; cd_Rom.er_SerialNumber
		dc.w    0           	; cd_Rom.er_InitDiagVec
rrPatch10   	dc.l    BootDiagArea    ; cd_Rom.er_Reserved0c...0f
d115 11
a125 9
BootDiagArea:
		dc.b    DAC_CONFIGTIME  ; da_Config
		dc.b    0           	; da_Flags
		dc.w    0           	; da_Size not used
		dc.w    0           	; da_DiagPoint
		dc.w    AutoBoot-BootDiagArea ; da_BootPoint
		dc.w    RDName-BootDiagArea ; da_Name
		dc.w    0           	; da_Reserved01
		dc.w    0           	; da_Reserved02
d127 1
a127 8
RDBootNode:
		dc.l    0           	; bn_Node.ln_Succ
		dc.l    0           	; bn_Node.ln_Pred
		dc.b    NT_BOOTNODE     ; bn_Node.ln_Type
		dc.b    0           	; bn_Node.ln_Pri
rrPatch11   	dc.l    FakeConfigDev   ; bn_Node.ln_Name
		dc.w    0           	; bn_Flags
bnDeviceNode    dc.l    0           	; bn_DeviceNode
d129 5
a133 22
MakeDosData:
rrPatch12	dc.l    RDDriveName     ; Dos Drive Name
rrPatch13	dc.l    RDName          ; Exec Device Name
RDUnit    	dc.l    0           	; Unit
RDFlags  	dc.l    0           	; Flags
RDCount  	dc.l    12          	; DE_TABLESIZE
       		dc.l    128         	; DE_SIZEBLOCK
		dc.l    0           	; DE_SECORG
RDNumHeads  	dc.l    0           	; DE_NUMHEADS
		dc.l    1           	; DE_SECSPERBLK
RDBlksPerTrack  dc.l    0           	; DE_BLKSPERTRACK
RDReserved  	dc.l    0           	; DE_RESERVEDBLKS
		dc.l    0           	; DE_PREFAC
		dc.l    0           	; DE_INTERLEAVE
RDLowCyl    	dc.l    0           	; DE_LOWCYL
RDUpperCyl  	dc.l    0           	; DE_UPPERCYL
		dc.l    5           	; DE_NUMBUFFERS
		dc.l    0           	; DE_MEMBUFTYPE
		dc.l    0           	; DE_TRANSFER
		dc.l    0           	; DE_ADDMASK
RDBootPri  	dc.l    0           	; DE_BOOTPRI
RDDosType	dc.l    ID_DOS_DISK   	; DE_DOSTYPE
d135 1
a135 1
RDDriveName	dcb.l   8,0		; null terminated, 30 char max
d137 11
a147 7
;---------- names
RDName      	dc.b    'ramdrive.device',0
RDNAMELEN	EQU	*-RDName-1
DosName     	dc.b    'dos.library',0
ExpansionName   dc.b    'expansion.library',0
DeviceID    	VSTRING
		ds.w    0
d149 1
d151 6
a156 4
;------ Kickstart code
KickInitialize:
		movem.l d2/a2/a6,-(a7)
		move.l  ABSEXECBASE,a6
d158 1
a158 6
		;------ allocate driver memory
		move.l  RDCAddr(pc),a1
		move.l  #(RDDriverEnd-RDDriverStart),d0
		CALLLVO AllocAbs
		tst.l   d0
		beq	kickDone
d160 2
a161 6
		;------ allocate data memory
		move.l  RDDAddr(pc),a1
		move.l  RDDSize(pc),d0
		CALLLVO AllocAbs
		tst.l   d0
		beq	kickErr
d163 2
a164 3
		;------ initialize command signal semaphore
		lea	RDSSemaphore(pc),a0
		CALLLVO	InitSemaphore
d166 3
a168 3
		;------ add device
		lea	DiskNode(pc),a1
		CALLLVO AddDevice
a169 3
		;------ check if booting is disabled w/ RDFlags & 0x02
		btst	#1,RDFlags+3(pc)
		bne.s	kickDone
d171 3
a173 17
		;------ check if booting is disabled w/ BOOTPRI < -128
		moveq	#0,d2
		lea	RDCount(pc),a0
		cmp.l	#DE_BOOTPRI,(a0) ; bootpri set in environment?
		blt.s 	noBootPri
		move.l	(DE_BOOTPRI*4)(a0),d2
		cmp.l	#-128,d2
		blt.s	kickDone
		bne.s	bootable
		;	mount, but do not make bootable
		lea	RDBootNode+LN_TYPE(pc),a1
		clr.b	(a1)		; not NT_BOOTNODE
		;	bound positive values
bootable:
		cmp.l	#127,d2
		ble.s	noBootPri
		moveq	#127,d2
d175 15
a189 2
noBootPri:
		;------ get the expansion library that know how to mount things
d191 1
a191 1
		moveq   #34,d0        	; 1.3 kickstart
d193 2
a194 2
		tst.l   d0
		beq.s   kickDone     	; but only failed to mount disk
d196 3
a198 3
		;------ set up Mount node
		move.l  d0,a6
		lea	MakeDosData(pc),a0
d200 3
d204 4
a207 12
		;------ add RDBootNode (containing Mount node) to system list
		lea	eb_MountList(a6),a0
		movem.l a0/a6,-(a7)     ; save MountList, ExpansionBase
		move.l  ABSEXECBASE,a6	; restore ExecBase
		lea	bnDeviceNode(pc),a1
		move.l  d0,(a1)
		beq.s   kickDone2	; if bnDeviceNode is null

priNotSet:
		move.l  (a7),a0         ; fetch MountList pointer
		lea	RDBootNode(pc),a1
		move.b	d2,LN_PRI(a1)	; priority for enqueue
d210 7
a216 2
kickDone2:
		movem.l (a7)+,a0/a1
d219 2
a220 2
kickDone:
		movem.l (a7)+,d2/a2/a6
a222 5
kickErr:
		move.l  RDCAddr(pc),a1
		move.l  #(RDDriverEnd-RDDriverStart),d0
		CALLLVO FreeMem
		bra.s	kickDone
d224 29
a252 1
;------ AutoBoot code
d256 2
a257 2
		tst.l   d0
		beq.s   abRts
d259 2
a260 2
		move.l  d0,a0
		move.l  RT_INIT(a0),a0
d265 3
a267 2
	CNOP    0,4
ResidentEnd:
d269 7
d277 1
d279 4
d284 2
a285 1
*   Initialization code for ram disk, executed only once
d287 6
d294 5
a298 3
Initialize:
		movem.l d2-d3/a2-a6,-(a7)
		move.l  ABSEXECBASE,a6
d300 29
a328 2
		;------ find out how big to make the ram disk
		;---------- find the device in the DOS DevInfo list
d330 1
a330 1
		moveq   #33,d0		; need at least 1.2 kickstart
d332 2
a333 3
		lea	DosBase(pc),a0
		move.l  d0,(a0)
		beq	initErr         ; this is not at least 1.2
d335 6
a340 7
		move.l  d0,a1           ; look in DosBase
		move.l  dl_Root(a1),a2  ;   in root
		CALLLVO CloseLibrary    ;   (DosBase never changes)
		move.l  rn_Info(a2),a0  ;   for Info block
		adda.l  a0,a0           ;   (which is a BPTR)
		adda.l  a0,a0           ;
		move.l  di_DevInfo(a0),d0 ; get DevInfo BPTR
d342 9
a350 6
devNodeLoop:
		beq	initErr         ; end of list, couldn't find it
		lsl.l   #2,d0           ;   (adjust BPTR)
		move.l  d0,a2
		tst.l   dn_Type(a2)
		bne.s   nextDevNode     ; not DT_DEVICE
d352 6
a357 3
		;-------------- compare the startup structures
		move.l  dn_Startup(a2),d0   ; get startup BPTR
		beq.s   nextDevNode     ; not there, not this device
d359 3
a361 2
		lsl.l   #2,d0
		move.l  d0,a3
d363 11
a373 4
		;-------------- compare the tail of the device names
		move.l  fssm_Device(a3),d0
		lsl.l   #2,d0
		move.l  d0,a0
d375 1
a375 1
		move.b  (a0)+,d0
d377 1
a377 1
		bmi.s	nextDevNode	; too short to match
d379 1
a379 1
		lea	RDName(pc),a1
d382 2
a383 2
		beq.s	gotDevNode	; found a matching tail
		cmp.b   (a0)+,d0
d386 3
a388 3
nextDevNode:
		move.l  (a2),d0         ; get next entry in list
		bra.s   devNodeLoop
d390 8
a397 12
gotDevNode:
		;---------- copy the dos drive name to null terminated form
		move.l  dn_Name(a2),d0
		lsl.l   #2,d0
		move.l  d0,a0
		lea	RDDriveName(pc),a1
		moveq   #0,d0
		move.b  (a0)+,d0
		subq    #1,d0
copyDriveName:
		move.b  (a0)+,(a1)+
		dbf	d0,copyDriveName
d399 7
a405 2
		;---------- cache the unit & flag
		lea	RDCount(pc),a1
d407 15
a421 2
		move.l  fssm_Unit(a3),RDUnit-RDCount(a1)
		move.l  fssm_Flags(a3),RDFlags-RDCount(a1)
d423 22
a444 5
		;---------- copy environment vector
		move.l  fssm_Environ(a3),d0
		lsl.l   #2,d0
		move.l  d0,a0
		move.l  (a0)+,d0	; DE_TABLESIZE
d446 3
a448 3
		cmp.l	#DE_DOSTYPE,d0
		ble.s	copyEnvironmentEntry
		moveq	#DE_DOSTYPE,d0
d450 2
a451 2
		bra.s	copyEnvironmentEntry
copyEnvironmentLoop:
d453 1
a453 1
copyEnvironmentEntry:
d455 1
a455 1
		dbf	d1,copyEnvironmentLoop
d457 12
a468 7
		;---------- calculate the disk size
		move.l  RDUpperCyl(pc),d0
		sub.l	RDLowCyl(pc),d0
		addq.w  #1,d0
		mulu    RDNumHeads+2(pc),d0
		mulu	RDBlksPerTrack+2(pc),d0
		beq	initErr
d470 12
a481 7
		;-------------- paranthetically calculate root block
		move.l  d0,d2
		subq.l  #1,d2
		add.l   RDReserved(pc),d2
		lsr.l   #1,d2
		lea	RDRoot(pc),a0
		move.l  d2,(a0)
a482 1
		mulu	#512,d0		; DE_SIZEBLOCK in bytes
d484 4
a487 14
		;------ Now allocate the required memory.
		;---------- for the ram disk
		addq.l	#8,d0		; to protect from free block trashing
		lea	RDDSize(pc),a0
		move.l  d0,(a0)
		moveq	#0,d1
		bsr	AllocHigh
		lea	RDDAddr(pc),a0
		move.l	d0,(a0)
		beq	initErr
		addq.l	#8,d0
		lea	RDData(pc),a0
		move.l	d0,(a0)
		move.l	d0,a3
d489 14
a502 7
		;---------- for the resident tag to be added to kickstart
		move.l  #(ResidentEnd-ResidentStart),d0
		moveq   #MEMF_CHIP,d1
		bsr	AllocHigh
		tst.l   d0
		beq	initErr2
		move.l  d0,a4
d504 4
a507 3
		;---------- for the driver code
		move.l  #(RDDriverEnd-RDDriverStart),d0
		moveq   #0,d1
d509 2
a510 4
		lea	RDCAddr(pc),a0
		move.l  d0,(a0)
		beq	initErr3
		move.l  d0,a5
d512 1
d514 2
a515 7
		;------ Copy the driver code out to high memory
		lea	RDDriverStart(pc),a0
		move.l  a5,a1
		move.w  #((RDDriverEnd-RDDriverStart)/4)-1,d0
copyDrvCode:
		move.l  (a0)+,(a1)+
		dbf	d0,copyDrvCode
a516 7
		;------ Copy the resident tag out to kick memory
		lea	ResidentTag(pc),a0
		lea	ResidentTag-ResidentStart(a4),a1
		move.w  #((ResidentEnd-ResidentTag)/4)-1,d0
copyResCode:
		move.l  (a0)+,(a1)+
		dbf	d0,copyResCode
d518 11
a528 11
		;------ patch the pointers
		;---------- from resident tag to resident tag
		move.l  a4,d1
		lea	ResidentStart(pc),a0
		sub.l   a0,d1
		lea	rrPatches(pc),a0
rrPatch:
		move.w  (a0)+,d0
		bmi.s   handPatch
		add.l   d1,0(a4,d0.w)
		bra.s   rrPatch
d530 8
a537 12
handPatch:
		;---------- for library functions
		lea	KillDisk-RDDriverStart(a5),a0
		move.l  a0,pKillDisk-ResidentStart(a4)
		lea	BeginIO-RDDriverStart(a5),a0
		move.l  a0,pBeginIO-ResidentStart(a4)
		lea	Open-RDDriverStart(a5),a0
		move.l  a0,pOpen-ResidentStart(a4)
		;---------- for new KickInitialize
		lea	KickInitialize-ResidentStart(a4),a0
		move.l  a0,pInitialize-ResidentStart(a4)
        	move.b	#RTF_COLDSTART,pColdstart-ResidentStart(a4)
d539 2
a540 16
		;------ modify the kickstart structures
		DISABLE
		;---------- add KickMem to head of exec list
		lea	KickMem-ResidentStart(a4),a0
		move.l  KickMemPtr(a6),(a0)
		move.l  a0,KickMemPtr(a6)
		;---------- add KickTag to head of exec list
		lea	KickTag-ResidentStart(a4),a0
		move.l  KickTagPtr(a6),4(a0)
		beq.s   tagListOK
		bset    #7,4(a0)        ; link to previous head tag
tagListOK:
		move.l  a0,KickTagPtr(a6)
		CALLLVO SumKickData
		move.l  d0,KickCheckSum(a6)
		ENABLE
d542 2
a543 8
		;------ initialize the disk memory
		move.l	RDDosType-ResidentStart(a4),d1
		bne.s	dosTypeSet

		move.l  #ID_DOS_DISK,d1		; default dos type

dosTypeSet:
		move.l	a3,a1
d545 4
a548 4
validDiskLoop:
		move.l  d1,(a1)+
		addq.l  #1,d1
		dbf	d0,validDiskLoop
d550 8
a557 12
		;---------- initialize the root key
initRootKey:
		move.l  RDRoot(pc),d0
		mulu	#512,d0
		lea	0(a3,d0.l),a2
		;-------------- clear the root key
		move.l  a2,a1
		moveq   #127,d0
		moveq   #0,d1
clearRootLoop:
		move.l  d1,(a1)+
		dbf	d0,clearRootLoop
d559 4
a562 8
		;-------------- fill in root key constants
		move.l  #2,(a2)         ; Type = T.SHORT
		move.l  #1,508(a2)      ; Secondary Type = ST.ROOT
		move.l  #(128-56),12(a2) ; Hash Table Size
		;-------------- fill in root key dates
		move.l  DosBase(pc),a6
		lea	484(a2),a0      ; Create Date
		move.l  a0,d1
d564 2
a565 2
		lea	420(a2),a0      ; Last Altered Date
		move.l  a0,d1
d567 1
a567 8
		;-------------- fill in volume name
		lea	VolName(pc),a0  ; initial disk name
		lea	432(a2),a1
		moveq   #0,d0
		move.b  (a0),d0
volNameLoop:
		move.b  (a0)+,(a1)+
		dbf	d0,volNameLoop
d569 8
a576 26
		;---------- Check if bitmap can fit in one block.
		;       Compare the amount of memory reserved for disk data
		;       with that required by 127 longwords of 32 block
		;       descriptors (i.e. one bitmap block).
		;       If the disk is greater than that (~2M), it's not
		;       really an error -- the Validator will build the
		;       bitmap, but with an annoying requestor.
		move.l  RDDSize(pc),d0
		cmpi.l  #((127*32*512)+8),d0
		bgt.s   rootCheckSum
		;-------------- point to the bitmap from the root
		move.l  RDRoot(pc),d0
		addq.l  #1,d0
		move.l  d0,316(a2)      ; first bitmap page
		moveq   #-1,d0
		move.l  d0,312(a2)      ; BMFLAG true
		;-------------- indicate the allocated blocks
		;------------------ beyond the end of the bit map can be trash
		;                   so make them ones (easy to set & sum)
		lea	516(a2),a1      ; first bits
		move.l  a1,a0
		moveq   #-1,d0          ; $FFFFFFFF
		moveq   #(127-1),d1     ; dbf counter for 127 longs
bitMapSetLoop:
		move.l  d0,(a0)+
		dbf	d1,bitMapSetLoop
d578 27
a604 28
		;------------------ root block and this block are not free
		;                   clear those bits and adjust the checksum
		;                   (checksum of 127 $FFFFFFFFs is $0000007F)
		;---------------------- root block
		move.l  RDRoot(pc),d1
		sub.l   RDReserved(pc),d1
		move.l  d1,d2
		move.l  d1,d3           ; (save for bitmap location)
		and.w   #$1f,d1         ; get bit number
		bclr    d1,d0           ; clear the bit in the longword
		lsr.l   #5,d2           ; get long offset
		lsl.l   #2,d2           ;
		and.l   d0,0(a1,d2.l)       ; clear this block's bit
		not.l   d0          ; get the bit not set
		add.l   #$0000007F,d0       ; add it back to checksum
		;---------------------- bitmap block
		addq.l  #1,d3
		move.l  d3,d2
		and.w   #$1f,d3         ; get bit number
		moveq   #-1,d1
		bclr    d3,d1           ; clear the bit in the longword
		lsr.l   #5,d2           ; get long offset
		lsl.l   #2,d2           ;
		and.l   d1,0(a1,d2.l)       ; clear this block's bit
		not.l   d1          ; get the bit not set
		add.l   d1,d0           ; add it back to checksum
		;-------------- store bitmap checksum
		move.l  d0,512(a2)
d606 27
a632 10
		;-------------- checksum root key
rootCheckSum:
		move.l  a2,a0
		moveq   #127,d0
		moveq   #0,d1
rootCheckSumLoop:
		add.l   (a0)+,d1
		dbf	d0,rootCheckSumLoop
		neg.l   d1
		move.l  d1,20(a2)
d634 11
a644 4
		;------ initialize command signal semaphore
		lea	RDSSemaphore-ResidentStart(a4),a0
		move.l  ABSEXECBASE,a6
		CALLLVO	InitSemaphore
a645 3
		;------ add the device
		lea	DiskNode-ResidentStart(a4),a1
		CALLLVO AddDevice
d647 15
a661 3
initErr:
		moveq   #0,d0   ; device has been moved, get rid of this copy
		movem.l (a7)+,d2-d3/a2-a6
d663 18
a680 1
initRts:
d683 5
a687 9
initErr3:
		move.l  a4,a1
		move.l  #(ResidentEnd-ResidentStart),d0
		CALLLVO FreeMem
initErr2:
		move.l  a3,a1
		move.l  RDDSize(pc),d0
		CALLLVO FreeMem
		bra.s   initErr
d689 3
a691 15
rrPatches:
		dc.w    rrPatch1-ResidentStart
		dc.w    rrPatch2-ResidentStart
		dc.w    rrPatch3-ResidentStart
		dc.w    rrPatch4-ResidentStart
		dc.w    rrPatch5-ResidentStart
		dc.w    rrPatch6-ResidentStart
		dc.w    rrPatch7-ResidentStart
		dc.w    rrPatch8-ResidentStart
		dc.w    rrPatch9-ResidentStart
		dc.w    rrPatch10-ResidentStart
		dc.w    rrPatch11-ResidentStart
		dc.w    rrPatch12-ResidentStart
		dc.w    rrPatch13-ResidentStart
		dc.w    -1
d693 3
a695 5
RDRoot      	dc.l    0
RDTotalBlocks   dc.l    0
DosBase     	dc.l    0
VolName     	dc.b    5,'RAMB0'
		ds.w	0
d697 3
d701 16
d720 1
a720 1
*   d0                 d0    d1
d725 2
a729 1
		DISABLE
d732 2
a733 2
		move.l  MemList(a6),a0
		moveq   #0,d3		; guess noone big enough
d737 4
a740 4
		move.l  a0,a1
		move.l  (a1),d2         ; check for end of list
		beq.s   noMemory
		move.l  d2,a0
d743 4
a746 4
		move.w  d1,d2           ; copy desired attributes
		and.w   MH_ATTRIBUTES(a1),d2 ; keep those set in this header
		cmp.w   d1,d2           ; check if they're all there
		bne.s   nextMemHeader   ; if not, try next header
d749 1
a749 1
		move.l  MH_FIRST(a1),a2
d751 4
a754 4
		cmp.l   MC_BYTES(a2),d0
		bhi.s   memTooSmall
		move.l  a2,a3           ; this is a candidate
		move.l  MC_BYTES(a2),d3 ;
d757 4
a760 4
		move.l  MC_NEXT(a2),d2
		beq.s   noMoreChunks
		move.l  d2,a2
		bra.s   checkMemChunk
d763 2
a764 2
		tst.l   d3              ; check for candidates
		beq.s   nextMemHeader
d766 3
a768 3
		sub.l   d0,d3           ; determine excess capacity
		and.w   #(~MEM_BLOCKMASK),d3 ; rounded down to even block
		add.l   d3,a3           ; and adjust desired address
d770 1
a770 1
		move.l  a3,a1
a775 1
		ENABLE
d780 1
a780 1
		moveq   #0,d0
d787 1
a787 1
		bra.s   allocEnd
d790 6
a795 23
**********************************************************************
*
*   beginning of ram driver
*
**********************************************************************

	CNOP    0,4
RDDriverStart	equ	*-8

******* Open *********************************************************
*
*   error = OpenDevice(name, unit, ioReq, flags);
*   d0                       d0    a1     d1
*
*   a6 contains device node
*
*   non-zero flags write-protect the disk
*
**********************************************************************
Open:
		move.l  d1,IO_UNIT(a1)      ; save flags

		moveq   #0,d0
d799 3
a801 4
**********************************************************************
**********************************************************************
BeginIO:
		movem.l a2-a3/a5-a6,-(a7)
d804 1
d806 1
a806 1
		move.l  ABSEXECBASE,a6
d808 2
a809 2
		;------ protect access to disk data
		lea	RDSSemaphore-DiskNode(a5),a0
d812 8
a819 8
		;------ check bounds of command
		move.w  IO_COMMAND(a3),d0
		cmpi.w  #DISKCOMMANDCNT,d0
		blt.s   knownCommand
		clr.w   d0
knownCommand:
		;------ find command entry point
		add.w   d0,d0
d822 1
a822 1
		move.b  d0,IO_ERROR(a3)
d824 3
a826 3
		;------ allow access to disk data
		lea	RDSSemaphore-DiskNode(a5),a0
		CALLLVO	ReleaseSemaphore
d828 2
a829 2
		btst    #IOB_QUICK,IO_FLAGS(a3)
		bne.s   quickOut
d831 2
a832 1
		;------ reply the command
d835 2
a836 2
quickOut:
		movem.l (a7)+,a2-a3/a5-a6
d840 4
a843 4
		bra.s   DiskInvalid
		bra.s   DiskReset
		bra.s   DiskRead
		bra.s   DiskWrite
d845 4
a848 4
		bra.s   DiskUpdate
		bra.s   DiskClear
		bra.s   DiskStop
		bra.s   DiskStart
d850 4
a853 4
		bra.s   DiskFlush
		bra.s   DiskMotor
		bra.s   DiskSeek
		bra.s   DiskFormat
d855 4
a858 4
		bra.s   DiskRemove
		bra.s   DiskChangeNum
		bra.s   DiskChangeState
		bra.s   DiskProtStatus
d860 1
a860 1
DISKCOMMANDCNT  EQU (*-DiskCommands)/2
d876 1
a876 1
		moveq   #IOERR_NOCMD,d0
d892 2
a893 2
		moveq   #1,d0
		move.l  d0,IO_ACTUAL(a3)
d914 1
a914 1
		moveq   #0,d0
d924 2
a925 2
		btst	#0,IO_UNIT+3(a3)
		bne.s   oneActual
d927 1
a927 1
        ;------ fall thru to zero actual
d935 2
a936 2
		moveq   #0,d0
		move.l  d0,IO_ACTUAL(a3)
d946 1
a946 1
		move.l	RDData-DiskNode(a5),d0
d948 1
a948 1
		add.l   IO_OFFSET(a3),d0
d950 1
a950 1
		move.l  IO_DATA(a3),a2
d952 1
a952 1
		bra.s   transfer
d956 1
a956 1
		moveq   #TDERR_DiskChanged,d0
d971 1
a971 1
		btst	#0,IO_UNIT+3(a3)
d974 2
a975 2
		move.l  IO_DATA(a3),a0
		move.l	RDData-DiskNode(a5),d0
d977 1
a977 1
		add.l   IO_OFFSET(a3),d0
d981 4
a984 4
		move.l  IO_LENGTH(a3),d0
		beq.s   emptyTransfer
		lsr.l   #7,d0       	; convert length to groups of 128 bytes
		subq.l  #1,d0       	; adjust for dbf count
d987 33
a1019 33
		move.l  (a0)+,(a2)+ 	; copy data 0..3
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	;
		move.l  (a0)+,(a2)+ 	; copy data 124..127
                dbf	d0,transferLoop ; decrement transfer count
d1022 2
a1023 2
		move.l  IO_LENGTH(a3),IO_ACTUAL(a3)
		moveq   #0,d0
d1027 1
a1027 2
		moveq   #TDERR_WriteProt,d0
justRts:
d1031 8
a1038 5
**********************************************************************
**********************************************************************
KillDisk:
		move.l	RDData-DiskNode(a6),d0
		beq.s	justRts		; already killed
d1040 9
a1048 6
		;------ cache device kick addresses
		movem.l	a2-a5,-(a7)
		lea	KickTag-DiskNode(a6),a2
		lea	KickMem-DiskNode(a6),a3
		lea	RDDriveName-DiskNode(a6),a4
		lea	RDSSemaphore-DiskNode(a6),a5
d1050 4
a1053 3
		;------ remove the device from the device list
		move.l	a6,a1
		REMOVE
d1055 4
a1058 1
		move.l	ABSEXECBASE,a6
d1060 1
a1060 3
		;------ protect access to disk data
		move.l	a5,a0
		CALLLVO	ObtainSemaphore
d1062 7
a1068 5
		;------ clear and free the disk data
		clr.l	RDData-DiskNode(a6)
		move.l	RDDAddr-DiskNode(a6),a1
		move.l	RDDSize-DiskNode(a6),d0
		CALLLVO	FreeMem
a1069 7
		;------ inhibit reset recovery of the device
		;---------- remove KickTag from exec list
		lea     KickTagPtr(a6),a1
checkTagSlot:
		cmp.l	(a1),a2		; check if this is our tag list
		beq.s	foundTagSlot

d1071 1
a1071 1
nextTagSlot:
d1073 2
a1074 2
		bgt.s	nextTagSlot
		beq.s	killMemList	; (huh? This shouldn't happen!)
d1078 1
a1078 1
		bra.s	checkTagSlot
d1080 3
a1082 3
foundTagSlot:
		;-------------- their next is my next
		move.l	4(a2),(a1)
d1084 3
a1086 2
killMemList:
		;---------- remove KickMem from exec list
d1088 3
a1090 3
checkMemSlot:
		cmp.l	(a1),a3
		beq.s	foundMemSlot
d1092 1
a1092 1
		beq.s	sumKickData	; (huh? This shouldn't happen!)
d1094 1
a1094 1
		bra.s	checkMemSlot
d1096 3
a1098 3
foundMemSlot:
		;-------------- their next is my next
		move.l	(a3),(a1)
d1100 1
a1100 1
sumKickData:
d1102 1
a1102 1
		move.l  d0,KickCheckSum(a6)
d1104 8
a1111 3
		;------ terminate drive name with a colon
		move.l	a4,a0
colonedName:
d1113 1
a1113 1
		bne.s	colonedName
d1116 3
a1118 3
		;------ allow access to (empty) disk data
		move.l	a5,a0
		CALLLVO	ReleaseSemaphore
d1120 3
a1122 2
		move.l	a4,d0
		movem.l	(a7)+,a2-a5
a1123 1
		rts
a1124 1

d1130 2
a1131 2
	CNOP    0,4
RDDriverEnd:
@


36.9
log
@use semaphore in Kill function, too.
@
text
@d5 1
a5 1
*   $Header: ramdrive.asm,v 34.26 89/05/25 12:27:06 kodiak Exp $
d10 3
d1092 1
a1092 1
		move.l	RDSSemaphore-DiskNode(a6),a5
@


34.26
log
@fix SignalSemaphore usage
@
text
@d5 1
a5 1
*   $Header: ramdrive.asm,v 34.25 89/05/16 16:12:50 kodiak Exp $
d10 3
d1074 1
d1082 1
a1082 1
		beq.s	kdDone		; already killed
d1085 1
a1085 1
		movem.l	a2-a4,-(a7)
d1089 1
d1095 6
a1104 1
		move.l	ABSEXECBASE,a6
d1154 4
d1159 1
a1159 1
		movem.l	(a7)+,a2-a4
a1160 1
kdDone:
@


34.25
log
@use semaphore instead of forbid for single threading
@
text
@d5 1
a5 1
*   $Header: ramdrive.asm,v 34.24 88/11/16 17:19:03 kodiak Exp $
d7 1
a7 1
*   $Locker: kodiak $
d10 3
d68 12
a79 12
	INCLUDE 'exec/types.i'
	INCLUDE 'exec/nodes.i'
	INCLUDE 'exec/lists.i'
	INCLUDE 'exec/resident.i'
	INCLUDE 'exec/libraries.i'
	INCLUDE 'exec/io.i'
	INCLUDE	'exec/semaphores.i'
	INCLUDE 'exec/tasks.i'
	INCLUDE 'exec/ables.i'
	INCLUDE 'exec/memory.i'
	INCLUDE 'exec/execbase.i'
	INCLUDE 'exec/errors.i'
d81 5
a85 5
	INCLUDE 'libraries/configregs.i'
	INCLUDE 'libraries/expansionbase.i'
	INCLUDE 'libraries/dos.i'
	INCLUDE 'libraries/dosextens.i'
	INCLUDE 'libraries/filehandler.i'
d87 2
a88 1
	INCLUDE 'devices/trackdisk.i'
a113 3
	IFD	FFS
	XLVO    OpenResource
	ENDC
a130 4
;------ identification information
VERSION     EQU 1
REVISION    EQU 1

d137 1
a137 1
        	dc.b    RTF_COLDSTART
a258 7
	IFD	FFS
FFSR_StackSize	dc.l    0
FFSR_Priority	dc.l    0
FFSR_GlobVec    dc.l    0
FFSR_Name       dc.b    'ffs.resource',0
	ENDC

a261 3
DeviceID    	dc.b    'Commodore-Amiga Ram Drive '
		dc.b    48+VERSION,'.',48+REVISION
		dc.b    ' (6 Apr 88)',13,10,0
d264 1
a337 25
	IFD	FFS
		;------ install fast file-system seglist if available

	move.l  d0,a2           ; protect DeviceNode pointer

	lea	FFSR_Name(pc),a1
	CALLLVO OpenResource
	tst.l   d0
	beq.s   no_ffs

FFSR_SEGLIST    EQU LIB_SIZE

        move.l  d0,a1
        move.l  FFSR_SEGLIST(a1),d0 ; bcpl pointer immediately follows lib_node
        tst.l   d0
        beq.s   no_ffs
        move.l  d0,dn_SegList(a2)   ; seglist must represent filesystem task
        move.l  FFSR_GlobVec(pc),dn_GlobalVec(a2) ; obey correct linkage rules
        move.l  FFSR_StackSize(pc),dn_StackSize(a2) ;  default stack
        move.l  FFSR_Priority(pc),dn_Priority(a2) ; default priority

no_ffs:
	ENDC


a435 41

	IFD	FFS
	;---------- remember the type of globvec for future reference

	tst.l   dn_GlobalVec(a2)
	beq.s   bcpl_type

remember_type:

        lea FFSR_GlobVec(pc),a1
        move.l   dn_GlobalVec(a2),(a1)  ; remember type that we mounted from

bcpl_type:

        ;---------- remember the priority for future reference

        tst.l   dn_Priority(a2)
        beq.s   default_priority

remember_priority:

        lea FFSR_Priority(pc),a1
        move.l   dn_Priority(a2),(a1)  ; remember priority we mounted with

default_priority:

        ;---------- remember the stacksize for future reference

        tst.l   dn_StackSize(a2)
        beq.s   default_stacksize

remember_stacksize:

        lea FFSR_StackSize(pc),a1
        move.l   dn_StackSize(a2),(a1)  ; remember stacksize we mounted with
        and.l    #$FFFFFFFC,(a1)  	; long word align stack 010

default_stacksize:

	ENDC

d561 1
a579 4
		;------ add the device
		lea	DiskNode-ResidentStart(a4),a1
		CALLLVO AddDevice

d695 9
d846 1
a846 1
		movem.l a2/a6,-(a7) ; change below if not 2 regs
d848 2
d851 3
a853 1
		lea	RDSSemaphore(pc),a0
d857 1
a857 1
		move.w  IO_COMMAND(a1),d0
d866 1
a866 1
		move.b  d0,IO_ERROR(a1)
d868 3
a870 1
		move.l  ABSEXECBASE,a6
d872 1
a872 1
		btst    #IOB_QUICK,IO_FLAGS(a1)
d879 1
a879 3
		CALLLVO	ReleaseSemaphore

		movem.l (a7)+,a2/a6
d936 1
a936 1
		move.l  d0,IO_ACTUAL(a1)
d967 1
a967 1
		move.l  IO_UNIT(a1),d0
d979 1
a979 1
		move.l  d0,IO_ACTUAL(a1)
d989 1
a989 2
		move.l	IO_DEVICE(a1),a6
		move.l	RDData-DiskNode(a6),d0
d991 1
a991 1
		add.l   IO_OFFSET(a1),d0
d993 1
a993 1
		move.l  IO_DATA(a1),a2
d1014 1
a1014 1
		btst	#0,IO_UNIT+3(a1)
d1017 2
a1018 3
		move.l  IO_DATA(a1),a0
		move.l	IO_DEVICE(a1),a6
		move.l	RDData-DiskNode(a6),d0
d1020 1
a1020 1
		add.l   IO_OFFSET(a1),d0
d1024 1
a1024 1
		move.l  IO_LENGTH(a1),d0
d1065 1
a1065 1
		move.l  IO_LENGTH(a1),IO_ACTUAL(a1)
@


34.24
log
@look for "ramdrive.device" to match end of names on device list
@
text
@d5 1
a5 1
*   $Header: ramdrive.asm,v 34.23 88/11/16 11:40:10 kodiak Exp $
d10 3
d71 1
a102 1
	XLVO    Forbid
d104 2
d107 1
a107 1
	XLVO    Permit
a198 2
RDAccessCnt	dc.w	0		; tasks accessing data

d205 2
d228 1
a228 1
BootNode:
d299 4
d321 1
a321 1
		lea	BootNode+LN_TYPE(pc),a1
d342 1
a342 1
		;------ add BootNode (containing Mount node) to system list
d377 1
a377 1
		lea	BootNode(pc),a1
d870 3
d880 6
d921 2
a922 1
		CALLLVO Forbid
d945 1
a945 1
		CALLLVO Permit
a1057 1
		addq.w	#1,RDAccessCnt-DiskNode(a6)
a1067 1
		subq.w	#1,RDAccessCnt-DiskNode(a6)
a1087 1
		addq.w	#1,RDAccessCnt-DiskNode(a6)
a1135 2
		subq.w	#1,RDAccessCnt-DiskNode(a6)
		bmi.s	killData
a1145 4
killData:
		FORBID	a0
		bra.s	kdKillNow

d1147 1
a1147 8
		FORBID	a0
		moveq	#0,d0		; guess error
		subq.w	#1,RDAccessCnt-DiskNode(a6)
		bpl	kdDone		; someone else will get it

kdKillNow:
		moveq	#0,d0		; guess error
		tst.l	RDData-DiskNode(a6)
a1217 1
		PERMIT	a0
@


34.23
log
@clear NT_BOOTNODE type when not bootable
@
text
@d5 1
a5 1
*   $Header: ramdrive.asm,v 34.22 88/04/11 10:39:17 kodiak Exp $
d10 3
a79 4
; locally define till added to libraries/filehandler.i
DE_BOOTPRI	EQU	15
DE_DOSTYPE	EQU	16

d127 1
a127 1
REVISION    EQU 0
d266 1
d443 1
a443 1
		;-------------- compare the device names
d447 5
a452 4
		clr	d0
		move.b  (a0)+,d0
		beq.s   nextDevNode
		subq    #1,d0
d454 4
a457 5
		cmp.b   (a0)+,(a1)+
		dbne    d0,1$
		bne.s   nextDevNode     ; not the same, not this device
		tst.b   (a1)            ; done with RDName?
		beq.s   gotDevNode      ; yes, found the device entry
@


34.22
log
@kodiak's major changes:
retabbed to 8 spaces...
added "no boot" capability
added "kill" capability
optimized some initialization code
@
text
@d5 1
a5 1
*   $Header: ramdrive.asm,v 34.21 88/03/11 09:10:36 bart Exp $
d10 7
d310 4
d315 1
d336 1
a336 1
		move.l  ABSEXECBASE,a6 ; restore ExecBase
@


34.21
log
@long word align stack
@
text
@d5 1
a5 1
*   $Header: ramdrive.asm,v 34.20 88/03/10 19:16:46 bart Exp $
d7 1
a7 1
*   $Locker: bart $
a9 20
*   Revision 34.20  88/03/10  19:16:46  bart
*   word align stack
*   
*   Revision 34.19  88/03/10  17:19:49  bart
*   support for boot from fast-filesystem resource
*   release 03.10.88 bart
*   
*   Revision 34.18  88/03/08  18:53:48  bart
*   BootPri and DosType support
*   
*   Revision 34.17  87/12/01  12:57:59  bart
*   *** empty log message ***
*   
*   Revision 34.16  87/12/01  12:49:30  bart
*   *** empty log message ***
*   
*   Revision 34.15  87/12/01  12:44:21  bart
*   FFSR_GlobVec
*   
*   Revision 34.14  87/12/01  12:06:17  bart
a11 9
*   Revision 34.13  87/11/21  15:16:26  bart
*   *** empty log message ***
*   
*   Revision 34.12  87/11/21  15:15:26  bart
*   *** empty log message ***
*   
*   Revision 34.11  87/11/21  11:18:14  bart
*   *** empty log message ***
*   
a32 3
*   Revision 34.3  87/11/20  11:58:59  bart
*   *** empty log message ***
*   
d50 1
a50 1
    SECTION ramdrive
d52 11
a62 10
    INCLUDE 'exec/types.i'
    INCLUDE 'exec/nodes.i'
    INCLUDE 'exec/resident.i'
    INCLUDE 'exec/libraries.i'
    INCLUDE 'exec/io.i'
    INCLUDE 'exec/tasks.i'
    INCLUDE 'exec/ables.i'
    INCLUDE 'exec/memory.i'
    INCLUDE 'exec/execbase.i'
    INCLUDE 'exec/errors.i'
d64 5
a68 5
    INCLUDE 'libraries/configregs.i'
    INCLUDE 'libraries/expansionbase.i'
    INCLUDE 'libraries/dos.i'
    INCLUDE 'libraries/dosextens.i'
    INCLUDE 'libraries/filehandler.i'
d70 3
a72 1
    INCLUDE 'devices/trackdisk.i'
d74 1
a74 3
CALLLVO     MACRO
        CALLLIB _LVO\1
        ENDM
d76 5
a80 1
XLVO        MACRO
d85 1
a85 1
    XREF    _intena
d87 15
a101 13
    XREF    _AbsExecBase
    XLVO    AddDevice
    XLVO    AllocAbs
    XLVO    CloseLibrary
    XLVO    Enqueue
    XLVO    FindResident
    XLVO    Forbid
    XLVO    FreeMem
    XLVO    OpenLibrary
    XLVO    Permit
    XLVO    ReplyMsg
    XLVO    SumKickData
    XLVO    OpenResource
d103 1
a103 1
    XLVO    DateStamp
d105 1
a105 1
    XLVO    MakeDosNode
d108 2
a109 2
        moveq   #-1,d0      ; show error
        rts
d117 1
a117 1
    CNOP    0,4
d123 1
a123 8
Template:
 
        dc.l    (ResidentEnd-Template)
      
fake_seglist:   
       
        dc.l    0

d126 10
a135 10
        dc.w    RTC_MATCHWORD
rrPatch1    dc.l    ResidentTag
rrPatch2    dc.l    ResidentEnd
        dc.b    RTF_COLDSTART
        dc.b    VERSION
        dc.b    NT_DEVICE
        dc.b    20      ; same priority as trackdisk.device
rrPatch3    dc.l    RDName
rrPatch4    dc.l    DeviceID
pInitialize dc.l    Initialize
d139 8
a146 8
kickMem:
        dc.l    0
        dc.l    0
        dc.b    0,0
rrPatch5    dc.l    RDName
        dc.w    1           ; only 1 entry
rrPatch6    dc.l    Template    
        dc.l    ResidentEnd-Template
d149 3
a151 3
kickTag:
rrPatch7    dc.l    ResidentTag
        dc.l    0
d155 16
a170 14
        rts         ; AbortIO (never queued, not abortable)
        dc.w    0,0
pBeginIO    EQU *+2
        jmp BeginIO     ; BeginIO
        rts         ; Null
        dc.w    0,0
        moveq   #0,d0       ; Expunge (never expunged)
        rts
        dc.w    0
        moveq   #0,d0       ; Close (LIB_OPENCNT not kept)
        rts
        dc.w    0
pOpen       EQU *+2
        jmp Open        ; Open
d172 14
a185 14
        dc.l    0           ; ln_Succ
        dc.l    0           ; ln_Pred
        dc.b    NT_DEVICE       ; ln_Type
        dc.b    0           ; ln_Pri
rrPatch8    dc.l    RDName          ; ln_Name
        dc.b    LIBF_SUMUSED!LIBF_CHANGED ; lib_Flags
        dc.b    0
        dc.w    DiskNode-DiskFuncs  ; lib_NegSize
        dc.w    DiskNodeEnd-DiskNode    ; lib_PosSize
        dc.w    VERSION         ; lib_Version
        dc.w    REVISION        ; lib_Revision
rrPatch9    dc.l    DeviceID        ; lib_IdString
        dc.l    0           ; lib_Sum
        dc.w    1           ; lib_OpenCnt
d188 2
d191 4
a194 3
RDData      dc.l    0           ; disk data
RDAddr      dc.l    0           ; disk driver and data
RDSize      dc.l    0           ; size at RDAddr
d197 9
a205 8
FakeConfigDev:
        dc.l    0           ; cd_Node.ln_Succ
        dc.l    0           ; cd_Node.ln_Pred
        dc.b    NT_DEVICE       ; cd_Node.ln_Type
        dc.b    0           ; cd_Node.ln_Pri
rrPatch10   dc.l    RDName          ; cd_Node.ln_Name
        dc.b    0           ; cd_Flags
        dc.b    0           ; cd_Pad
a206 9
        dc.b    ERTF_DIAGVALID      ; cd_Rom.er_Type
        dc.b    0           ; cd_Rom.er_Product
        dc.b    0           ; cd_Rom.er_Flags
        dc.b    0           ; cd_Rom.er_Reserved03
        dc.w    0           ; cd_Rom.er_Manufacturer
        dc.l    0           ; cd_Rom.er_SerialNumber
        dc.w    0           ; cd_Rom.er_InitDiagVec
rrPatch11   dc.l    BootDiagArea        ; cd_Rom.er_Reserved0c...0f

d208 8
a215 8
        dc.b    DAC_CONFIGTIME      ; da_Config
        dc.b    0           ; da_Flags
        dc.w    0           ; da_Size not used
        dc.w    0           ; da_DiagPoint
        dc.w    AutoBoot-BootDiagArea   ; da_BootPoint
        dc.w    RDName-BootDiagArea ; da_Name
        dc.w    0           ; da_Reserved01
        dc.w    0           ; da_Reserved02
d218 7
a224 7
        dc.l    0           ; bn_Node.ln_Succ
        dc.l    0           ; bn_Node.ln_Pred
        dc.b    NT_BOOTNODE     ; bn_Node.ln_Type
        dc.b    0           ; bn_Node.ln_Pri
rrPatch12   dc.l    FakeConfigDev       ; bn_Node.ln_Name
        dc.w    0           ; bn_Flags
bnDeviceNode    dc.l    0           ; bn_DeviceNode
a225 5
DE_TRANSFER	EQU	13	; locally define till added to dos/filehandler.i
DE_ADDMASK	EQU	14	; locally define till added to dos/filehandler.i
DE_BOOTPRI	EQU	15	; locally define till added to dos/filehandler.i
DE_DOSTYPE	EQU	16	; locally define till added to dos/filehandler.i

d227 21
a247 23
rrPatch13   dc.l    RDDriveName     ; Dos Drive Name *
rrPatch14   dc.l    RDName          ; Exec Device Name
RDUnit      dc.l    0           ; Unit *
RDFlags     dc.l    0           ; Flags *
RDCount     dc.l    12          ; DE_TABLESIZE **
        dc.l    128         ; DE_SIZEBLOCK
        dc.l    0           ; DE_SECORG
RDNumHeads  dc.l    0           ; DE_NUMHEADS *
        dc.l    1           ; DE_SECSPERBLK
RDBlksPerTrack  dc.l    0           ; DE_BLKSPERTRACK *
RDReserved  dc.l    0           ; DE_RESERVEDBLKS *
        dc.l    0           ; DE_PREFAC
        dc.l    0           ; DE_INTERLEAVE
RDLowCyl    dc.l    0           ; DE_LOWCYL *
RDUpperCyl  dc.l    0           ; DE_UPPERCYL *
        dc.l    5           ; DE_NUMBUFFERS
        dc.l    0           ; DE_MEMBUFTYPE
        dc.l    0           ; DE_TRANSFER
        dc.l    0           ; DE_ADDMASK
RDBootPri   dc.l    0           ; DE_BOOTPRI **
RDDosType   dc.l    0           ; DE_DOSTYPE **
                        ; * = set in Initialize
                        ; ** = conditionally set
d249 1
a249 9
;------ shared data
RDDriveName dc.l    0,0,0,0,0,0,0,0     ; null terminated, 30 char max
RDName      dc.b    'ramdrive.device',0
DeviceID    dc.b    'Commodore-Amiga Ram Drive '
        dc.b    48+VERSION,'.',48+REVISION
        dc.b    ' (10 Mar 88)',13,10,0
DosName     dc.b    'dos.library',0
ExpansionName   dc.b    'expansion.library',0
FFSR_Name       dc.b    'ffs.resource',0
d251 1
a251 2
        ds.w    0

d255 2
a256 1
FFSR_DosType	dc.l    0
d258 10
d270 2
a271 2
        movem.l a2/a6,-(a7)
        move.l  _AbsExecBase,a6
d273 6
a278 6
        ;------ allocate driver memory
        move.l  RDAddr(pc),a1
        move.l  RDSize(pc),d0
        CALLLVO AllocAbs
        tst.l   d0
        beq	kickFail
d280 6
a285 3
        ;------ add device
        lea DiskNode(pc),a1
        CALLLVO AddDevice
d287 3
a289 6
        ;------ get the expansion library that know how to mount things
        lea ExpansionName(pc),a1
        moveq   #34,d0          ; 1.2.1 kickstart
        CALLLVO OpenLibrary
        tst.l   d0
        beq.s   kickFail        ; but only failed to mount disk
d291 3
a293 4
        ;------ set up Mount node
        move.l  d0,a6
        lea MakeDosData(pc),a0
        CALLLVO MakeDosNode
d295 12
a306 7
        ;------ add BootNode (containing Mount node) to system list
        lea eb_MountList(a6),a0
        movem.l a0/a6,-(a7)         ; save MountList, ExpansionBase
        move.l  _AbsExecBase,a6     ; restore ExecBase
        lea bnDeviceNode(pc),a1
        move.l  d0,(a1)
        beq.s   kickFail2           ; if bnDeviceNode is null
d308 7
a314 1
        ;------ install fast file-system seglist if available
d316 4
a319 1
        move.l  d0,a2               ; protect DeviceNode pointer
d321 7
a327 4
        lea FFSR_Name(pc),a1
        CALLLVO OpenResource
        tst.l   d0
        beq.s   no_ffs
d329 10
d351 1
a351 3
        lea RDCount(pc),a0
	cmp.l	#DE_BOOTPRI,(DE_TABLESIZE*4)(a0) ; bootpri set in environment ?
	blt.s 	pri_not_set
a352 3
	move.l	(DE_BOOTPRI*4)(a0),d0		; priority requested by user
        lea BootNode(pc),a1			; is passed to bootnode
	move.b	d0,LN_PRI(a1)			; priority for enqueue
d354 5
a358 4
pri_not_set:
        move.l  (a7),a0             ; fetch MountList pointer
        lea BootNode(pc),a1
        CALLLVO Enqueue
d360 3
a362 3
kickFail2:
        movem.l (a7)+,a0/a1
        CALLLVO CloseLibrary
d364 3
a366 3
kickFail:
        movem.l (a7)+,a2/a6
        rts
d368 6
d376 4
a379 4
        lea DosName(pc),a1
        CALLLVO FindResident
        tst.l   d0
        beq.s   abRts
d381 3
a383 3
        move.l  d0,a0
        move.l  RT_INIT(a0),a0
        jsr (a0)
d385 1
a385 1
        rts
d387 1
a387 1
    CNOP    0,4
d390 1
d397 2
a398 2
        movem.l d2-d3/a2-a4/a6,-(a7)
        move.l  _AbsExecBase,a6
d400 8
a407 8
        ;------ find out how big to make the ram disk
        ;---------- find the device in the DOS DevInfo list
        lea DosName(pc),a1
        moveq   #33,d0          ; need at least 1.2 kickstart
        CALLLVO OpenLibrary
        lea DosBase(pc),a0
        move.l  d0,(a0)
        beq initErr         ; this is not at least 1.2
d409 7
a415 7
        move.l  d0,a1           ; look in DosBase
        move.l  dl_Root(a1),a2      ;   in root
        CALLLVO CloseLibrary        ;   (DosBase never changes)
        move.l  rn_Info(a2),a0      ;   for Info block
        adda.l  a0,a0           ;   (which is a BPTR)
        adda.l  a0,a0           ;
        move.l  di_DevInfo(a0),d0   ; get DevInfo BPTR
d418 5
a422 5
        beq initErr         ; end of list, couldn't find it
        lsl.l   #2,d0           ;   (adjust BPTR)
        move.l  d0,a2
        tst.l   dn_Type(a2)
        bne.s   nextDevNode     ; not DT_DEVICE
d424 3
a426 3
        ;-------------- compare the startup structures
        move.l  dn_Startup(a2),d0   ; get startup BPTR
        beq.s   nextDevNode     ; not there, not this device
d428 2
a429 2
        lsl.l   #2,d0
        move.l  d0,a3
d431 9
a439 9
        ;-------------- compare the device names
        move.l  fssm_Device(a3),d0
        lsl.l   #2,d0
        move.l  d0,a0
        lea RDName(pc),a1
        clr d0
        move.b  (a0)+,d0
        beq.s   nextDevNode
        subq    #1,d0
d441 5
a445 5
        cmp.b   (a0)+,(a1)+
        dbne    d0,1$
        bne.s   nextDevNode     ; not the same, not this device
        tst.b   (a1)            ; done with RDName?
        beq.s   gotDevNode      ; yes, found the device entry
d448 2
a449 2
        move.l  (a2),d0         ; get next entry in list
        bra.s   devNodeLoop
d453 2
a454 1
        ;---------- remember the type of globvec for future reference
d456 2
a457 2
        tst.l   dn_GlobalVec(a2)
        beq.s   bcpl_type
d491 10
a500 8
        ;---------- copy the dos drive name to null terminated form
        move.l  dn_Name(a2),d0
        lsl.l   #2,d0
        move.l  d0,a0
        lea RDDriveName(pc),a1
        moveq   #0,d0
        move.b  (a0)+,d0
        subq    #1,d0
d502 2
a503 2
        move.b  (a0)+,(a1)+
        dbf d0,copyDriveName
d505 2
a506 5
        ;---------- cache the unit & flag
        lea RDUnit(pc),a0
        move.l  fssm_Unit(a3),(a0)
        lea RDFlags(pc),a0
        move.l  fssm_Flags(a3),(a0)
d508 2
a509 4
        ;---------- calculate the disk size
        move.l  fssm_Environ(a3),d0
        lsl.l   #2,d0
        move.l  d0,a1
d511 16
a526 4
        lea RDCount(pc),a0
        move.l  (DE_TABLESIZE*4)(a1),d0
        sub.l   #DE_BOOTPRI,d0
        blt.s   no_bootpri
d528 7
a534 2
	move.l	#DE_BOOTPRI,(DE_TABLESIZE*4)(a0) ; set bootpri in environment
	move.l	(DE_BOOTPRI*4)(a1),(DE_BOOTPRI*4)(a0)
d536 7
a542 1
no_bootpri:
d544 1
a544 4
        lea RDCount(pc),a0
        move.l  (DE_TABLESIZE*4)(a1),d0
        sub.l   #DE_DOSTYPE,d0
        blt.s   no_dostype
d546 14
a559 2
	move.l	#DE_DOSTYPE,(DE_TABLESIZE*4)(a0) ; set dostype in environment
	move.l	(DE_DOSTYPE*4)(a1),(DE_DOSTYPE*4)(a0)
d561 7
a567 1
no_dostype:
d569 8
a576 16
        move.l  (DE_UPPERCYL*4)(a1),d0
        lea RDUpperCyl(pc),a0
        move.l  d0,(a0)
        move.l  (DE_LOWCYL*4)(a1),d1
        lea RDLowCyl(pc),a0
        move.l  d1,(a0)
        sub.l   d1,d0
        addq.w  #1,d0
        move.l  (DE_NUMHEADS*4)(a1),d1
        lea RDNumHeads(pc),a0
        move.l  d1,(a0)
        mulu    d1,d0
        move.l  (DE_BLKSPERTRACK*4)(a1),d1
        lea RDBlksPerTrack(pc),a0
        move.l  d1,(a0)
        mulu    d1,d0
a577 10
        ;-------------- paranthetically calculate root block
        move.l  d0,d2
        subq.l  #1,d2
        move.l  (DE_RESERVEDBLKS*4)(a1),d1
        lea RDReserved(pc),a0
        move.l  d1,(a0)
        add.l   d1,d2
        lsr.l   #1,d2
        lea RDRoot(pc),a0
        move.l  d2,(a0)
d579 7
a585 1
        mulu    #512,d0     ; DE_SIZEBLOCK in bytes
d587 4
a590 36
        ;------ Now allocate the required memory.
        ;---------- for the driver and the ram disk
        add.l   #(RDCodeDataBound-RDDriverStart),d0
        lea RDSize(pc),a0
        move.l  d0,(a0)
        moveq   #0,d1
        bsr AllocHigh
        lea RDAddr(pc),a0
        move.l  d0,(a0)
        beq initErr
        move.l  d0,a3
        add.l   #(RDCodeDataBound-RDDriverStart),d0
        lea RDData(pc),a0
        move.l  d0,(a0)
        ;---------- for the resident tag to be added to kickstart
        move.l  #(ResidentEnd-Template),d0
        moveq   #MEMF_CHIP,d1
        bsr AllocHigh
        tst.l   d0
        beq initErr2
        addq.l  #8,d0
        move.l  d0,a4


        ;------ Copy the device code out to high memory
        lea RDDriverStart(pc),a0
        move.l  a3,a1
        move.w  #((RDCodeDataBound-RDDriverStart)/4)-1,d0
copyDevCode:
        move.l  (a0)+,(a1)+
        dbf d0,copyDevCode

        ;------ Copy the resident tag out to kick memory
        lea ResidentTag(pc),a0
        move.l  a4,a1
        move.w  #((ResidentEnd-ResidentTag)/4)-1,d0
d592 2
a593 2
        move.l  (a0)+,(a1)+
        dbf d0,copyResCode
d595 6
a600 7
        ;------ patch the pointers
        ;---------- from resident tag to resident tag
        move.l  a4,a1
        move.l  a4,a2
        lea ResidentTag(pc),a0
        sub.l   a0,a2
        lea rrPatches(pc),a0
d602 4
a605 6
        move.w  (a0)+,d0
        bmi.s   handPatch
        move.l  0(a1,d0.w),d1
        add.l   a2,d1
        move.l  d1,0(a1,d0.w)
        bra.s   rrPatch
d608 22
a629 20
        ;---------- for library functions
        lea BeginIO-RDDriverStart(a3),a0
        move.l  a0,pBeginIO-ResidentTag(a4)
        lea Open-RDDriverStart(a3),a0
        move.l  a0,pOpen-ResidentTag(a4)
        ;---------- for new KickInitialize
        lea KickInitialize-ResidentTag(a4),a0
        move.l  a0,pInitialize-ResidentTag(a4)

        ;------ modify the kickstart structures
        DISABLE a0
        ;---------- add kickMem to head of exec list
        lea kickMem-ResidentTag(a4),a0
        move.l  KickMemPtr(a6),(a0)
        move.l  a0,KickMemPtr(a6)
        ;---------- add kickTag to head of exec list
        lea kickTag-ResidentTag(a4),a0
        move.l  KickTagPtr(a6),4(a0)
        beq.s   tagListOK
        bset    #7,4(a0)        ; link to previous head tag
d631 4
a634 4
        move.l  a0,KickTagPtr(a6)
        CALLLVO SumKickData
        move.l  d0,KickCheckSum(a6)
        ENABLE  a0
d636 3
a638 3
        ;------ add the device
        lea DiskNode-ResidentTag(a4),a1
        CALLLVO AddDevice
d640 9
a648 13
        ;------ initialize the disk memory
        move.l  RDData-ResidentTag(a4),a2
        move.l  #ID_DOS_DISK,d1		; default dos type
        lea RDCount(pc),a1
        move.l  (DE_TABLESIZE*4)(a1),d0
        sub.l   #DE_DOSTYPE,d0
        blt.s   default_type
	tst.l	(DE_DOSTYPE*4)(a1)
	beq.s   default_type
	move.l	(DE_DOSTYPE*4)(a1),d1	 ; use supplied dos type
default_type:
        move.l  a2,a1
        moveq   #127,d0
d650 3
a652 3
        move.l  d1,(a1)+
        addq.l  #1,d1
        dbf d0,validDiskLoop
d654 1
a654 1
        ;---------- initialize the root key
d656 7
a662 7
        move.l  RDRoot(pc),d0
        mulu    #512,d0
        add.l   d0,a2
        ;-------------- clear the root key
        move.l  a2,a1
        moveq   #127,d0
        moveq   #0,d1
d664 2
a665 2
        move.l  d1,(a1)+
        dbf d0,clearRootLoop
d667 17
a683 17
        ;-------------- fill in root key constants
        move.l  #2,(a2)         ; Type = T.SHORT
        move.l  #1,508(a2)      ; Secondary Type = ST.ROOT
        move.l  #(128-56),12(a2)    ; Hash Table Size
        ;-------------- fill in root key dates
        move.l  DosBase(pc),a6
        lea 484(a2),a0      ; Create Date
        move.l  a0,d1
        CALLLVO DateStamp
        lea 420(a2),a0      ; Last Altered Date
        move.l  a0,d1
        CALLLVO DateStamp
        ;-------------- fill in volume name
        lea VolName(pc),a0      ; initial disk name
        lea 432(a2),a1
        moveq   #0,d0
        move.b  (a0),d0
d685 2
a686 2
        move.b  (a0)+,(a1)+
        dbf d0,volNameLoop
d688 23
a710 23
        ;---------- Check if bitmap can fit in one block.
        ;       Compare the amount of memory reserved for disk data
        ;       with that required by 127 longwords of 32 block
        ;       descriptors (i.e. one bitmap block).
        ;       If the disk is greater than that (~2M), it's not
        ;       really an error -- the Validator will build the
        ;       bitmap, but with an annoying requestor.
        move.l  RDSize(pc),d0
        cmpi.l  #((127*32*512)+(RDCodeDataBound-RDDriverStart)),d0
        bgt.s   rootCheckSum
        ;-------------- point to the bitmap from the root
        move.l  RDRoot(pc),d0
        addq.l  #1,d0
        move.l  d0,316(a2)      ; first bitmap page
        moveq   #-1,d0
        move.l  d0,312(a2)      ; BMFLAG true
        ;-------------- indicate the allocated blocks
        ;------------------ beyond the end of the bit map can be trash
        ;                   so make them ones (easy to set & sum)
        lea 516(a2),a1      ; first bits
        move.l  a1,a0
        moveq   #-1,d0          ; $FFFFFFFF
        moveq   #(127-1),d1     ; dbf counter for 127 longs
d712 2
a713 2
        move.l  d0,(a0)+
        dbf d1,bitMapSetLoop
d715 28
a742 28
        ;------------------ root block and this block are not free
        ;                   clear those bits and adjust the checksum
        ;                   (checksum of 127 $FFFFFFFFs is $0000007F)
        ;---------------------- root block
        move.l  RDRoot(pc),d1
        sub.l   RDReserved(pc),d1
        move.l  d1,d2
        move.l  d1,d3           ; (save for bitmap location)
        and.w   #$1f,d1         ; get bit number
        bclr    d1,d0           ; clear the bit in the longword
        lsr.l   #5,d2           ; get long offset
        lsl.l   #2,d2           ;
        and.l   d0,0(a1,d2.l)       ; clear this block's bit
        not.l   d0          ; get the bit not set
        add.l   #$0000007F,d0       ; add it back to checksum
        ;---------------------- bitmap block
        addq.l  #1,d3
        move.l  d3,d2
        and.w   #$1f,d3         ; get bit number
        moveq   #-1,d1
        bclr    d3,d1           ; clear the bit in the longword
        lsr.l   #5,d2           ; get long offset
        lsl.l   #2,d2           ;
        and.l   d1,0(a1,d2.l)       ; clear this block's bit
        not.l   d1          ; get the bit not set
        add.l   d1,d0           ; add it back to checksum
        ;-------------- store bitmap checksum
        move.l  d0,512(a2)
d744 1
a744 1
        ;-------------- checksum root key
d746 3
a748 3
        move.l  a2,a0
        moveq   #127,d0
        moveq   #0,d1
d750 4
a753 4
        add.l   (a0)+,d1
        dbf d0,rootCheckSumLoop
        neg.l   d1
        move.l  d1,20(a2)
a754 3
        ;------ if bootable, build the expansion mount information


d756 2
a757 2
        moveq   #0,d0   ; device has been moved, get rid of this copy
        movem.l (a7)+,d2-d3/a2-a4/a6
d760 1
a760 1
        rts
d762 4
d767 4
a770 4
        move.l  a3,a1
        move.l  RDSize(pc),d0
        CALLLVO FreeMem
        bra.s   initErr
d773 14
a786 15
        dc.w    rrPatch1-ResidentTag
        dc.w    rrPatch2-ResidentTag
        dc.w    rrPatch3-ResidentTag
        dc.w    rrPatch4-ResidentTag
        dc.w    rrPatch5-ResidentTag
        dc.w    rrPatch6-ResidentTag
        dc.w    rrPatch7-ResidentTag
        dc.w    rrPatch8-ResidentTag
        dc.w    rrPatch9-ResidentTag
        dc.w    rrPatch10-ResidentTag
        dc.w    rrPatch11-ResidentTag
        dc.w    rrPatch12-ResidentTag
        dc.w    rrPatch13-ResidentTag
        dc.w    rrPatch14-ResidentTag
        dc.w    -1
d788 1
a788 1
RDRoot      dc.l    0
d790 3
a792 2
DosBase     dc.l    0
VolName     dc.b    5,'RAMB0'
d805 2
a806 2
        movem.l d2/d3/a2/a3,-(a7)
        DISABLE a0
d808 3
a810 3
        ;------ get first memory header
        move.l  MemList(a6),a0
        moveq   #0,d3           ; guess noone big enough
d812 1
a812 1
        ;------ cycle through memory headers
d814 4
a817 4
        move.l  a0,a1
        move.l  (a1),d2         ; check for end of list
        beq noMemory
        move.l  d2,a0
d819 5
a823 5
        ;---------- check this header's attributes
        move.w  d1,d2           ; copy desired attributes
        and.w   MH_ATTRIBUTES(a1),d2    ; keep those set in this header
        cmp.w   d1,d2           ; check if they're all there
        bne.s   nextMemHeader       ; if not, try next header
d825 2
a826 2
        ;---------- search this memory for a big enough piece at the end
        move.l  MH_FIRST(a1),a2
d828 4
a831 4
        cmp.l   MC_BYTES(a2),d0
        bhi.s   memTooSmall
        move.l  a2,a3           ; this is a candidate
        move.l  MC_BYTES(a2),d3     ;
d833 5
a837 5
        ;-------------- get the next chunk
        move.l  MC_NEXT(a2),d2
        beq.s   noMoreChunks
        move.l  d2,a2
        bra.s   checkMemChunk
d840 2
a841 2
        tst.l   d3          ; check for candidates
        beq nextMemHeader
d843 3
a845 3
        sub.l   d0,d3           ; determine excess capacity
        and #(~MEM_BLOCKMASK),d3    ; rounded down to even block
        add.l   d3,a3           ; and adjust desired address
d847 2
a848 2
        move.l  a3,a1
        CALLLVO AllocAbs
d850 3
a852 3
        ENABLE  a0
        movem.l (a7)+,d2/d3/a2/a3
        rts
d855 2
a856 2
        moveq   #0,d0
        bra.s   allocEnd
d858 1
d865 2
a866 2
    CNOP    0,4
RDDriverStart:
a867 3
    DC.L    0           ; stupid allocabs !
    DC.L    0           ; stupid allocabs !

d879 1
a879 1
        move.l  d1,IO_UNIT(a1)      ; save flags
d881 2
a882 2
        moveq   #0,d0
        rts
d888 1
a888 1
        movem.l a2/a6,-(a7) ; change below if not 2 regs
d890 2
a891 2
        move.l  _AbsExecBase,a6
        CALLLVO Forbid
d893 5
a897 7
        move.l  4(a7),a6    ; (see note at movem) restore a6

        ;------ check bounds of command
        move.w  IO_COMMAND(a1),d0
        cmpi.w  #DISKCOMMANDCNT,d0
        blt.s   knownCommand
        clr.w   d0
d899 3
a901 3
        ;------ find command entry point
        add.w   d0,d0
        jsr DiskCommands(pc,d0.w)
d903 1
a903 1
        move.b  d0,IO_ERROR(a1)
d905 1
a905 1
        move.l  _AbsExecBase,a6
d907 2
a908 2
        btst    #IOB_QUICK,IO_FLAGS(a1)
        bne.s   quickOut
d910 2
a911 2
        ;------ reply the command
        CALLLVO ReplyMsg
d914 1
a914 1
        CALLLVO Permit
d916 2
a917 2
        movem.l (a7)+,a2/a6
        rts
d920 4
a923 4
        bra.s   DiskInvalid
        bra.s   DiskReset
        bra.s   DiskRead
        bra.s   DiskWrite
d925 4
a928 4
        bra.s   DiskUpdate
        bra.s   DiskClear
        bra.s   DiskStop
        bra.s   DiskStart
d930 4
a933 4
        bra.s   DiskFlush
        bra.s   DiskMotor
        bra.s   DiskSeek
        bra.s   DiskFormat
d935 4
a938 4
        bra.s   DiskRemove
        bra.s   DiskChangeNum
        bra.s   DiskChangeState
        bra.s   DiskProtStatus
d956 2
a957 2
        moveq   #IOERR_NOCMD,d0
        rts
d972 3
a974 3
        moveq   #1,d0
        move.l  d0,IO_ACTUAL(a1)
        ;------ fall through to report no error
d994 2
a995 2
        moveq   #0,d0
        rts
d1004 2
a1005 2
        move.l  IO_UNIT(a1),d0
        bne.s   oneActual
d1015 3
a1017 3
        moveq   #0,d0
        move.l  d0,IO_ACTUAL(a1)
        rts
d1026 7
a1032 4
        lea RDCodeDataBound(pc),a0
        move.l  IO_OFFSET(a1),d0
        add.l   d0,a0
        move.l  IO_DATA(a1),a2
d1034 1
a1034 1
        bra.s   transfer
d1036 5
d1054 2
a1055 2
        move.l  IO_UNIT(a1),d0
        bne protectedDisk
d1057 7
a1063 4
        move.l  IO_DATA(a1),a0
        lea RDCodeDataBound(pc),a2
        move.l  IO_OFFSET(a1),d0
        add.l   d0,a2
d1066 4
a1069 4
        move.l  IO_LENGTH(a1),d0
        beq.s   emptyTransfer
        lsr.l   #7,d0       ; convert length to groups of 128 bytes
        subq.l  #1,d0       ; adjust for dbf count
d1072 33
a1104 33
        move.l  (a0)+,(a2)+ ; copy data 0..3
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ;
        move.l  (a0)+,(a2)+ ; copy data 124..127
                dbf d0,transferLoop ; decrement transfer count
d1107 5
a1111 3
        move.l  IO_LENGTH(a1),IO_ACTUAL(a1)
        moveq   #0,d0
        rts
d1114 2
a1115 2
        moveq   #TDERR_WriteProt,d0
        rts
a1118 3
*
*   end of ram driver
*
d1120 3
a1122 2
    CNOP    0,4
RDCodeDataBound:
d1124 83
d1209 1
a1209 1
*   data for ram disk will go here after the driver is moved
d1212 2
d1215 1
a1215 2
        
    END
@


34.20
log
@word align stack
@
text
@d5 1
a5 1
*   $Header: ramdrive.asm,v 34.19 88/03/10 17:19:49 bart Exp $
d10 3
d497 1
a497 1
        and.l    #$FFFFFFFE,(a1)  	; word align stack for 68000/010
@


34.19
log
@support for boot from fast-filesystem resource
release 03.10.88 bart
@
text
@d5 1
a5 1
*   $Header: ramdrive.asm,v 34.18 88/03/08 18:53:48 bart Exp $
d10 4
d300 2
d358 2
a359 2
        move.l  #$400,dn_StackSize(a2)  ; be generous
        move.l  #15,dn_Priority(a2)     ; priority
d472 25
@


34.18
log
@BootPri and DosType support
@
text
@d5 1
a5 1
*   $Header: ramdrive.asm,v 34.17 87/12/01 12:57:59 bart Exp $
d9 4
a12 1
*   $Log:   ramdrive.asm,v $
a73 4
*   Copyright (c) 1987 Kodiak Software, Campbell, California
*
*   created 8/28/87 Robert R. Burns
*
d287 1
a287 1
DeviceID    dc.b    'Kodiak',39,'s Recoverable Boot Ram Drive '
d289 1
a289 1
        dc.b    ' (7 Sept 87)',13,10,0
d352 1
a352 1
        move.l  #$d2,dn_StackSize(a2)  ; default filesytem stacksize
@


34.17
log
@*** empty log message ***
@
text
@d3 3
a5 3
*	Source Control
*	--------------
*	$Header: ramdrive.asm,v 34.16 87/12/01 12:49:30 bart Exp $
d7 1
a7 1
*	$Locker: bart $
d9 4
a12 1
*	$Log:	ramdrive.asm,v $
d73 1
a73 1
*   created	8/28/87	Robert R. Burns
d76 1
a76 1
	SECTION	ramdrive
d78 10
a87 10
	INCLUDE	'exec/types.i'
	INCLUDE	'exec/nodes.i'
	INCLUDE	'exec/resident.i'
	INCLUDE	'exec/libraries.i'
	INCLUDE	'exec/io.i'
	INCLUDE	'exec/tasks.i'
	INCLUDE	'exec/ables.i'
	INCLUDE	'exec/memory.i'
	INCLUDE	'exec/execbase.i'
	INCLUDE	'exec/errors.i'
d89 5
a93 5
	INCLUDE	'libraries/configregs.i'
	INCLUDE	'libraries/expansionbase.i'
	INCLUDE	'libraries/dos.i'
	INCLUDE	'libraries/dosextens.i'
	INCLUDE	'libraries/filehandler.i'
d95 1
a95 1
	INCLUDE	'devices/trackdisk.i'
d97 3
a99 3
CALLLVO		MACRO
		CALLLIB _LVO\1
		ENDM
d101 3
a103 3
XLVO		MACRO
		XREF	_LVO\1
		ENDM
d106 1
a106 1
	XREF	_intena
d108 13
a120 13
	XREF	_AbsExecBase
	XLVO	AddDevice
	XLVO	AllocAbs
	XLVO	CloseLibrary
	XLVO	Enqueue
	XLVO	FindResident
	XLVO	Forbid
	XLVO	FreeMem
	XLVO	OpenLibrary
	XLVO	Permit
	XLVO	ReplyMsg
	XLVO	SumKickData
	XLVO	OpenResource
d122 1
a122 1
	XLVO	DateStamp
d124 1
a124 1
	XLVO	MakeDosNode
d127 2
a128 2
		moveq	#-1,d0		; show error
		rts
d136 1
a136 1
	CNOP	0,4
d139 2
a140 2
VERSION		EQU	1
REVISION	EQU	0
d144 2
a145 2
		dc.l	(ResidentEnd-Template)
	  
d147 2
a148 2
	   
		dc.l    0
d152 10
a161 10
		dc.w	RTC_MATCHWORD
rrPatch1	dc.l	ResidentTag
rrPatch2	dc.l	ResidentEnd
		dc.b	RTF_COLDSTART
		dc.b	VERSION
		dc.b	NT_DEVICE
		dc.b	20		; same priority as trackdisk.device
rrPatch3	dc.l	RDName
rrPatch4	dc.l	DeviceID
pInitialize	dc.l	Initialize
d166 7
a172 7
		dc.l	0
		dc.l	0
		dc.b	0,0
rrPatch5	dc.l	RDName
		dc.w	1			; only 1 entry
rrPatch6	dc.l	Template	
		dc.l	ResidentEnd-Template
d176 2
a177 2
rrPatch7	dc.l	ResidentTag
		dc.l	0
d181 14
a194 14
		rts			; AbortIO (never queued, not abortable)
		dc.w	0,0
pBeginIO	EQU	*+2
		jmp	BeginIO		; BeginIO
		rts			; Null
		dc.w	0,0
		moveq	#0,d0		; Expunge (never expunged)
		rts
		dc.w	0
		moveq	#0,d0		; Close (LIB_OPENCNT not kept)
		rts
		dc.w	0
pOpen		EQU	*+2
		jmp	Open		; Open
d196 14
a209 14
		dc.l	0			; ln_Succ
		dc.l	0			; ln_Pred
		dc.b	NT_DEVICE		; ln_Type
		dc.b	0			; ln_Pri
rrPatch8	dc.l	RDName			; ln_Name
		dc.b	LIBF_SUMUSED!LIBF_CHANGED ; lib_Flags
		dc.b	0
		dc.w	DiskNode-DiskFuncs	; lib_NegSize
		dc.w	DiskNodeEnd-DiskNode	; lib_PosSize
		dc.w	VERSION			; lib_Version
		dc.w	REVISION		; lib_Revision
rrPatch9	dc.l	DeviceID		; lib_IdString
		dc.l	0			; lib_Sum
		dc.w	1			; lib_OpenCnt
d213 3
a215 3
RDData		dc.l	0			; disk data
RDAddr		dc.l	0			; disk driver and data
RDSize		dc.l	0			; size at RDAddr
d219 7
a225 7
		dc.l	0			; cd_Node.ln_Succ
		dc.l	0			; cd_Node.ln_Pred
		dc.b	NT_DEVICE		; cd_Node.ln_Type
		dc.b	0			; cd_Node.ln_Pri
rrPatch10	dc.l	RDName			; cd_Node.ln_Name
		dc.b	0			; cd_Flags
		dc.b	0			; cd_Pad
d227 8
a234 8
		dc.b	ERTF_DIAGVALID		; cd_Rom.er_Type
		dc.b	0			; cd_Rom.er_Product
		dc.b	0			; cd_Rom.er_Flags
		dc.b	0			; cd_Rom.er_Reserved03
		dc.w	0			; cd_Rom.er_Manufacturer
		dc.l	0			; cd_Rom.er_SerialNumber
		dc.w	0			; cd_Rom.er_InitDiagVec
rrPatch11	dc.l	BootDiagArea		; cd_Rom.er_Reserved0c...0f
d237 8
a244 8
		dc.b	DAC_CONFIGTIME		; da_Config
		dc.b	0			; da_Flags
		dc.w	0			; da_Size not used
		dc.w	0			; da_DiagPoint
		dc.w	AutoBoot-BootDiagArea	; da_BootPoint
		dc.w	RDName-BootDiagArea	; da_Name
		dc.w	0			; da_Reserved01
		dc.w	0			; da_Reserved02
d247 7
a253 7
		dc.l	0			; bn_Node.ln_Succ
		dc.l	0			; bn_Node.ln_Pred
		dc.b	NT_BOOTNODE		; bn_Node.ln_Type
		dc.b	0			; bn_Node.ln_Pri
rrPatch12	dc.l	FakeConfigDev		; bn_Node.ln_Name
		dc.w	0			; bn_Flags
bnDeviceNode	dc.l	0			; bn_DeviceNode
d255 5
d261 23
a283 18
rrPatch13	dc.l	RDDriveName		; Dos Drive Name *
rrPatch14	dc.l	RDName			; Exec Device Name
RDUnit		dc.l	0			; Unit *
RDFlags		dc.l	0			; Flags *
		dc.l	12			; DE_TABLESIZE
		dc.l	128			; DE_SIZEBLOCK
		dc.l	0			; DE_SECORG
RDNumHeads	dc.l	0			; DE_NUMHEADS *
		dc.l	1			; DE_SECSPERBLK
RDBlksPerTrack	dc.l	0			; DE_BLKSPERTRACK *
RDReserved	dc.l	0			; DE_RESERVEDBLKS *
		dc.l	0			; DE_PREFAC
		dc.l	0			; DE_INTERLEAVE
RDLowCyl	dc.l	0			; DE_LOWCYL *
RDUpperCyl	dc.l	0			; DE_UPPERCYL *
		dc.l	5			; DE_NUMBUFFERS
		dc.l	0			; DE_MEMBUFTYPE
						; * = set in Initialize
d286 8
a293 8
RDDriveName	dc.l	0,0,0,0,0,0,0,0		; null terminated, 30 char max
RDName		dc.b	'ramdrive.device',0
DeviceID	dc.b	'Kodiak',39,'s Recoverable Boot Ram Drive '
		dc.b	48+VERSION,'.',48+REVISION
		dc.b	' (7 Sept 87)',13,10,0
DosName		dc.b	'dos.library',0
ExpansionName	dc.b	'expansion.library',0
FFSR_Name		dc.b	'ffs.resource',0
d295 1
a295 1
		ds.w	0
d297 2
a298 1
FFSR_GlobVec	dc.l	0
d302 2
a303 2
		movem.l	a2/a6,-(a7)
		move.l	_AbsExecBase,a6
d305 6
a310 6
		;------ allocate driver memory
		move.l	RDAddr(pc),a1
		move.l	RDSize(pc),d0
		CALLLVO	AllocAbs
		tst.l	d0
		beq.s	kickFail
d312 3
a314 3
		;------ add device
		lea	DiskNode(pc),a1
		CALLLVO	AddDevice
d316 6
a321 6
		;------ get the expansion library that know how to mount things
		lea	ExpansionName(pc),a1
		moveq	#34,d0			; 1.2.1 kickstart
		CALLLVO	OpenLibrary
		tst.l	d0
		beq.s	kickFail		; but only failed to mount disk
d323 4
a326 4
		;------ set up Mount node
		move.l	d0,a6
		lea	MakeDosData(pc),a0
		CALLLVO	MakeDosNode
d328 7
a334 7
		;------ add BootNode (containing Mount node) to system list
		lea	eb_MountList(a6),a0
		movem.l	a0/a6,-(a7)			; save MountList, ExpansionBase
		move.l	_AbsExecBase,a6		; restore ExecBase
		lea	bnDeviceNode(pc),a1
		move.l	d0,(a1)
		beq.s	kickFail2			; if bnDeviceNode is null
d336 1
a336 1
		;------ install fast file-system seglist if available
d338 1
a338 1
		move.l	d0,a2				; protect DeviceNode pointer
d340 4
a343 4
		lea	FFSR_Name(pc),a1
		CALLLVO	OpenResource
		tst.l	d0
		beq.s	no_ffs
d345 1
a345 1
FFSR_SEGLIST	EQU	LIB_SIZE
d347 8
a354 8
		move.l	d0,a1
		move.l	FFSR_SEGLIST(a1),d0	; bcpl pointer immediately follows lib_node
		tst.l	d0
		beq.s	no_ffs
		move.l	d0,dn_SegList(a2) 	; seglist must represent filesystem task
		move.l	FFSR_GlobVec(pc),dn_GlobalVec(a2) ; obey correct linkage rules
		move.l	#$d2,dn_StackSize(a2)  ; default filesytem stacksize
		move.l	#15,dn_Priority(a2) 	; priority
d357 3
a359 3
		move.l	(a7),a0				; fetch MountList pointer
		lea	BootNode(pc),a1
		CALLLVO	Enqueue
d361 9
d371 2
a372 2
		movem.l	(a7)+,a0/a1
		CALLLVO	CloseLibrary
d375 2
a376 2
		movem.l	(a7)+,a2/a6
		rts
d380 4
a383 4
		lea	DosName(pc),a1
		CALLLVO	FindResident
		tst.l	d0
		beq.s	abRts
d385 3
a387 3
		move.l	d0,a0
		move.l	RT_INIT(a0),a0
		jsr	(a0)
d389 1
a389 1
		rts
d391 1
a391 1
	CNOP	0,4
d400 2
a401 2
		movem.l	d2-d3/a2-a4/a6,-(a7)
		move.l	_AbsExecBase,a6
d403 8
a410 8
		;------ find out how big to make the ram disk
		;---------- find the device in the DOS DevInfo list
		lea	DosName(pc),a1
		moveq	#33,d0			; need at least 1.2 kickstart
		CALLLVO	OpenLibrary
		lea	DosBase(pc),a0
		move.l	d0,(a0)
		beq	initErr			; this is not at least 1.2
d412 7
a418 7
		move.l	d0,a1			; look in DosBase
		move.l	dl_Root(a1),a2		;   in root
		CALLLVO	CloseLibrary		;   (DosBase never changes)
		move.l	rn_Info(a2),a0		;   for Info block
		adda.l	a0,a0			;   (which is a BPTR)
		adda.l	a0,a0			;
		move.l	di_DevInfo(a0),d0	; get DevInfo BPTR
d421 5
a425 5
		beq	initErr			; end of list, couldn't find it
		lsl.l	#2,d0			;   (adjust BPTR)
		move.l	d0,a2
		tst.l	dn_Type(a2)
		bne.s	nextDevNode		; not DT_DEVICE
d427 3
a429 3
		;-------------- compare the startup structures
		move.l	dn_Startup(a2),d0	; get startup BPTR
		beq.s	nextDevNode		; not there, not this device
d431 2
a432 2
		lsl.l	#2,d0
		move.l	d0,a3
d434 9
a442 9
		;-------------- compare the device names
		move.l	fssm_Device(a3),d0
		lsl.l	#2,d0
		move.l	d0,a0
		lea	RDName(pc),a1
		clr	d0
		move.b	(a0)+,d0
		beq.s	nextDevNode
		subq	#1,d0
d444 5
a448 5
		cmp.b	(a0)+,(a1)+
		dbne	d0,1$
		bne.s	nextDevNode		; not the same, not this device
		tst.b	(a1)			; done with RDName?
		beq.s	gotDevNode		; yes, found the device entry
d451 2
a452 2
		move.l	(a2),d0			; get next entry in list
		bra.s	devNodeLoop
d456 1
a456 3
		;---------- remember the type of globvec for future reference
		tst.l	dn_GlobalVec(a2)
		beq.s	bcpl_type
d458 2
a459 2
		lea	FFSR_GlobVec(pc),a1
		move.l	#-1,(a1)		; assume c type if not bcpl type
d461 5
d468 8
a475 8
		;---------- copy the dos drive name to null terminated form
		move.l	dn_Name(a2),d0
		lsl.l	#2,d0
		move.l	d0,a0
		lea	RDDriveName(pc),a1
		moveq	#0,d0
		move.b	(a0)+,d0
		subq	#1,d0
d477 2
a478 2
		move.b	(a0)+,(a1)+
		dbf	d0,copyDriveName
d480 5
a484 5
		;---------- cache the unit & flag
		lea	RDUnit(pc),a0
		move.l	fssm_Unit(a3),(a0)
		lea	RDFlags(pc),a0
		move.l	fssm_Flags(a3),(a0)
d486 4
a489 20
		;---------- calculate the disk size
		move.l	fssm_Environ(a3),d0
		lsl.l	#2,d0
		move.l	d0,a1
		move.l	(DE_UPPERCYL*4)(a1),d0
		lea	RDUpperCyl(pc),a0
		move.l	d0,(a0)
		move.l	(DE_LOWCYL*4)(a1),d1
		lea	RDLowCyl(pc),a0
		move.l	d1,(a0)
		sub.l	d1,d0
		addq.w	#1,d0
		move.l	(DE_NUMHEADS*4)(a1),d1
		lea	RDNumHeads(pc),a0
		move.l	d1,(a0)
		mulu	d1,d0
		move.l	(DE_BLKSPERTRACK*4)(a1),d1
		lea	RDBlksPerTrack(pc),a0
		move.l	d1,(a0)
		mulu	d1,d0
d491 4
a494 10
		;-------------- paranthetically calculate root block
		move.l	d0,d2
		subq.l	#1,d2
		move.l	(DE_RESERVEDBLKS*4)(a1),d1
		lea	RDReserved(pc),a0
		move.l	d1,(a0)
		add.l	d1,d2
		lsr.l	#1,d2
		lea	RDRoot(pc),a0
		move.l	d2,(a0)
d496 2
a497 1
		mulu	#512,d0		; DE_SIZEBLOCK in bytes
d499 1
a499 22
		;------	Now allocate the required memory.
		;---------- for the driver and the ram disk
		add.l	#(RDCodeDataBound-RDDriverStart),d0
		lea	RDSize(pc),a0
		move.l	d0,(a0)
		moveq	#0,d1
		bsr	AllocHigh
		lea	RDAddr(pc),a0
		move.l	d0,(a0)
		beq	initErr
		move.l	d0,a3
		add.l	#(RDCodeDataBound-RDDriverStart),d0
		lea	RDData(pc),a0
		move.l	d0,(a0)
		;---------- for the resident tag to be added to kickstart
		move.l	#(ResidentEnd-Template),d0
		moveq	#MEMF_CHIP,d1
		bsr	AllocHigh
		tst.l	d0
		beq	initErr2
		addq.l	#8,d0
		move.l	d0,a4
d501 4
d506 63
a568 4
		;------ Copy the device code out to high memory
		lea	RDDriverStart(pc),a0
		move.l	a3,a1
		move.w	#((RDCodeDataBound-RDDriverStart)/4)-1,d0
d570 2
a571 2
		move.l	(a0)+,(a1)+
		dbf	d0,copyDevCode
d573 4
a576 4
		;------ Copy the resident tag out to kick memory
		lea	ResidentTag(pc),a0
		move.l	a4,a1
		move.w	#((ResidentEnd-ResidentTag)/4)-1,d0
d578 2
a579 2
		move.l	(a0)+,(a1)+
		dbf	d0,copyResCode
d581 7
a587 7
		;------ patch the pointers
		;---------- from resident tag to resident tag
		move.l	a4,a1
		move.l	a4,a2
		lea	ResidentTag(pc),a0
		sub.l	a0,a2
		lea	rrPatches(pc),a0
d589 6
a594 6
		move.w	(a0)+,d0
		bmi.s	handPatch
		move.l	0(a1,d0.w),d1
		add.l	a2,d1
		move.l	d1,0(a1,d0.w)
		bra.s	rrPatch
d597 8
a604 8
		;---------- for library functions
		lea	BeginIO-RDDriverStart(a3),a0
		move.l	a0,pBeginIO-ResidentTag(a4)
		lea	Open-RDDriverStart(a3),a0
		move.l	a0,pOpen-ResidentTag(a4)
		;---------- for new KickInitialize
		lea	KickInitialize-ResidentTag(a4),a0
		move.l	a0,pInitialize-ResidentTag(a4)
d606 11
a616 11
		;------ modify the kickstart structures
		DISABLE	a0
		;---------- add kickMem to head of exec list
		lea	kickMem-ResidentTag(a4),a0
		move.l	KickMemPtr(a6),(a0)
		move.l	a0,KickMemPtr(a6)
		;---------- add kickTag to head of exec list
		lea	kickTag-ResidentTag(a4),a0
		move.l	KickTagPtr(a6),4(a0)
		beq.s	tagListOK
		bset	#7,4(a0)		; link to previous head tag
d618 4
a621 4
		move.l	a0,KickTagPtr(a6)
		CALLLVO	SumKickData
		move.l	d0,KickCheckSum(a6)
		ENABLE	a0
d623 3
a625 3
		;------ add the device
		lea	DiskNode-ResidentTag(a4),a1
		CALLLVO	AddDevice
d627 13
a639 5
		;------ initialize the disk memory
		move.l	RDData-ResidentTag(a4),a2
		move.l	a2,a1
		moveq	#127,d0
		move.l	#ID_DOS_DISK,d1
d641 3
a643 3
		move.l	d1,(a1)+
		addq.l	#1,d1
		dbf	d0,validDiskLoop
d645 1
a645 1
		;---------- initialize the root key
d647 7
a653 7
		move.l	RDRoot(pc),d0
		mulu	#512,d0
		add.l	d0,a2
		;-------------- clear the root key
		move.l	a2,a1
		moveq	#127,d0
		moveq	#0,d1
d655 2
a656 2
		move.l	d1,(a1)+
		dbf	d0,clearRootLoop
d658 17
a674 17
		;-------------- fill in root key constants
		move.l	#2,(a2)			; Type = T.SHORT
		move.l	#1,508(a2)		; Secondary Type = ST.ROOT
		move.l	#(128-56),12(a2)	; Hash Table Size
		;-------------- fill in root key dates
		move.l	DosBase(pc),a6
		lea	484(a2),a0		; Create Date
		move.l	a0,d1
		CALLLVO	DateStamp
		lea	420(a2),a0		; Last Altered Date
		move.l	a0,d1
		CALLLVO	DateStamp
		;-------------- fill in volume name
		lea	VolName(pc),a0		; initial disk name
		lea	432(a2),a1
		moveq	#0,d0
		move.b	(a0),d0
d676 2
a677 2
		move.b	(a0)+,(a1)+
		dbf	d0,volNameLoop
d679 23
a701 23
		;---------- Check if bitmap can fit in one block.
		;	    Compare the amount of memory reserved for disk data
		;	    with that required by 127 longwords of 32 block
		;	    descriptors (i.e. one bitmap block).
		;	    If the disk is greater than that (~2M), it's not
		;	    really an error -- the Validator will build the
		;	    bitmap, but with an annoying requestor.
		move.l	RDSize(pc),d0
		cmpi.l	#((127*32*512)+(RDCodeDataBound-RDDriverStart)),d0
		bgt.s	rootCheckSum
		;-------------- point to the bitmap from the root
		move.l	RDRoot(pc),d0
		addq.l	#1,d0
		move.l	d0,316(a2)		; first bitmap page
		moveq	#-1,d0
		move.l	d0,312(a2)		; BMFLAG true
		;-------------- indicate the allocated blocks
		;------------------ beyond the end of the bit map can be trash
		;                   so make them ones (easy to set & sum)
		lea	516(a2),a1		; first bits
		move.l	a1,a0
		moveq	#-1,d0			; $FFFFFFFF
		moveq	#(127-1),d1		; dbf counter for 127 longs
d703 2
a704 2
		move.l	d0,(a0)+
		dbf	d1,bitMapSetLoop
d706 28
a733 28
		;------------------ root block and this block are not free
		;                   clear those bits and adjust the checksum
		;                   (checksum of 127 $FFFFFFFFs is $0000007F)
		;---------------------- root block
		move.l	RDRoot(pc),d1
		sub.l	RDReserved(pc),d1
		move.l	d1,d2
		move.l	d1,d3			; (save for bitmap location)
		and.w	#$1f,d1			; get bit number
		bclr	d1,d0			; clear the bit in the longword
		lsr.l	#5,d2			; get long offset
		lsl.l	#2,d2			;
		and.l	d0,0(a1,d2.l)		; clear this block's bit
		not.l	d0			; get the bit not set
		add.l	#$0000007F,d0		; add it back to checksum
		;---------------------- bitmap block
		addq.l	#1,d3
		move.l	d3,d2
		and.w	#$1f,d3			; get bit number
		moveq	#-1,d1
		bclr	d3,d1			; clear the bit in the longword
		lsr.l	#5,d2			; get long offset
		lsl.l	#2,d2			;
		and.l	d1,0(a1,d2.l)		; clear this block's bit
		not.l	d1			; get the bit not set
		add.l	d1,d0			; add it back to checksum
		;-------------- store bitmap checksum
		move.l	d0,512(a2)
d735 1
a735 1
		;-------------- checksum root key
d737 3
a739 3
		move.l	a2,a0
		moveq	#127,d0
		moveq	#0,d1
d741 4
a744 4
		add.l	(a0)+,d1
		dbf	d0,rootCheckSumLoop
		neg.l	d1
		move.l	d1,20(a2)
d746 1
a746 1
		;------ if bootable, build the expansion mount information
d750 2
a751 2
		moveq	#0,d0	; device has been moved, get rid of this copy
		movem.l	(a7)+,d2-d3/a2-a4/a6
d754 1
a754 1
		rts
d757 4
a760 4
		move.l	a3,a1
		move.l	RDSize(pc),d0
		CALLLVO	FreeMem
		bra.s	initErr
d763 15
a777 15
		dc.w	rrPatch1-ResidentTag
		dc.w	rrPatch2-ResidentTag
		dc.w	rrPatch3-ResidentTag
		dc.w	rrPatch4-ResidentTag
		dc.w	rrPatch5-ResidentTag
		dc.w	rrPatch6-ResidentTag
		dc.w	rrPatch7-ResidentTag
		dc.w	rrPatch8-ResidentTag
		dc.w	rrPatch9-ResidentTag
		dc.w	rrPatch10-ResidentTag
		dc.w	rrPatch11-ResidentTag
		dc.w	rrPatch12-ResidentTag
		dc.w	rrPatch13-ResidentTag
		dc.w	rrPatch14-ResidentTag
		dc.w	-1
d779 4
a782 4
RDRoot		dc.l	0
RDTotalBlocks	dc.l	0
DosBase		dc.l	0
VolName		dc.b	5,'RAMB0'
d785 1
a785 1
*******	AllocHigh ****************************************************
d787 2
a788 2
*	memory = AllocHigh(size, requirements)
*	d0                 d0    d1
d790 2
a791 2
*	Fast memory is preferred when requirements are zero.  It is
*	assumed the memory list is sorted so fast memory is first.
d795 2
a796 2
		movem.l	d2/d3/a2/a3,-(a7)
		DISABLE	a0
d798 3
a800 3
		;------ get first memory header
		move.l	MemList(a6),a0
		moveq	#0,d3			; guess noone big enough
d802 1
a802 1
		;------ cycle through memory headers
d804 4
a807 4
		move.l	a0,a1
		move.l	(a1),d2			; check for end of list
		beq	noMemory
		move.l	d2,a0
d809 5
a813 5
		;---------- check this header's attributes
		move.w	d1,d2			; copy desired attributes
		and.w	MH_ATTRIBUTES(a1),d2	; keep those set in this header
		cmp.w	d1,d2			; check if they're all there
		bne.s	nextMemHeader		; if not, try next header
d815 2
a816 2
		;---------- search this memory for a big enough piece at the end
		move.l	MH_FIRST(a1),a2
d818 4
a821 4
		cmp.l	MC_BYTES(a2),d0
		bhi.s	memTooSmall
		move.l	a2,a3			; this is a candidate
		move.l	MC_BYTES(a2),d3		;
d823 5
a827 5
		;-------------- get the next chunk
		move.l	MC_NEXT(a2),d2
		beq.s	noMoreChunks
		move.l	d2,a2
		bra.s	checkMemChunk
d830 2
a831 2
		tst.l	d3			; check for candidates
		beq	nextMemHeader
d833 3
a835 3
		sub.l	d0,d3			; determine excess capacity
		and	#(~MEM_BLOCKMASK),d3	; rounded down to even block
		add.l	d3,a3			; and adjust desired address
d837 2
a838 2
		move.l	a3,a1
		CALLLVO	AllocAbs
d840 3
a842 3
		ENABLE	a0
		movem.l	(a7)+,d2/d3/a2/a3
		rts
d845 2
a846 2
		moveq	#0,d0
		bra.s	allocEnd
d854 1
a854 1
	CNOP	0,4
d857 2
a858 2
	DC.L	0			; stupid allocabs !
	DC.L	0			; stupid allocabs !
d860 1
a860 1
*******	Open *********************************************************
d862 2
a863 2
*	error = OpenDevice(name, unit, ioReq, flags);
*	d0                       d0    a1     d1
d865 1
a865 1
*	a6 contains device node
d867 1
a867 1
*	non-zero flags write-protect the disk
d871 1
a871 1
		move.l	d1,IO_UNIT(a1)		; save flags
d873 2
a874 2
		moveq	#0,d0
		rts
d880 1
a880 1
		movem.l	a2/a6,-(a7)	; change below if not 2 regs
d882 2
a883 2
		move.l	_AbsExecBase,a6
		CALLLVO	Forbid
d885 1
a885 1
		move.l	4(a7),a6	; (see note at movem) restore a6
d887 5
a891 5
		;------ check bounds of command
		move.w	IO_COMMAND(a1),d0
		cmpi.w	#DISKCOMMANDCNT,d0
		blt.s	knownCommand
		clr.w	d0
d893 3
a895 3
		;------ find command entry point
		add.w	d0,d0
		jsr	DiskCommands(pc,d0.w)
d897 1
a897 1
		move.b	d0,IO_ERROR(a1)
d899 1
a899 1
		move.l	_AbsExecBase,a6
d901 2
a902 2
		btst	#IOB_QUICK,IO_FLAGS(a1)
		bne.s	quickOut
d904 2
a905 2
		;------ reply the command
		CALLLVO	ReplyMsg
d908 1
a908 1
		CALLLVO	Permit
d910 2
a911 2
		movem.l	(a7)+,a2/a6
		rts
d914 4
a917 4
		bra.s	DiskInvalid
		bra.s	DiskReset
		bra.s	DiskRead
		bra.s	DiskWrite
d919 4
a922 4
		bra.s	DiskUpdate
		bra.s	DiskClear
		bra.s	DiskStop
		bra.s	DiskStart
d924 4
a927 4
		bra.s	DiskFlush
		bra.s	DiskMotor
		bra.s	DiskSeek
		bra.s	DiskFormat
d929 4
a932 4
		bra.s	DiskRemove
		bra.s	DiskChangeNum
		bra.s	DiskChangeState
		bra.s	DiskProtStatus
d934 1
a934 1
DISKCOMMANDCNT	EQU	(*-DiskCommands)/2
d940 1
a940 1
*	Disk Commands
d950 2
a951 2
		moveq	#IOERR_NOCMD,d0
		rts
d954 1
a954 1
*******	Motor ********************************************************
d958 1
a958 1
*******	ChangeNum ****************************************************
d966 3
a968 3
		moveq	#1,d0
		move.l	d0,IO_ACTUAL(a1)
		;------ fall through to report no error
d970 1
a970 1
*******	Update *******************************************************
d974 1
a974 1
*******	Clear ********************************************************
d978 1
a978 1
*******	Remove *******************************************************
d988 2
a989 2
		moveq	#0,d0
		rts
d992 1
a992 1
*******	ProtStatus ***************************************************
d998 2
a999 2
		move.l	IO_UNIT(a1),d0
		bne.s	oneActual
d1001 1
a1001 1
		;------ fall thru to zero actual
d1003 1
a1003 1
*******	ChangeState **************************************************
d1009 3
a1011 3
		moveq	#0,d0
		move.l	d0,IO_ACTUAL(a1)
		rts
d1014 1
a1014 1
*******	Read *********************************************************
d1016 1
a1016 1
*	Read data from the ram disk.
d1020 4
a1023 4
		lea	RDCodeDataBound(pc),a0
		move.l	IO_OFFSET(a1),d0
		add.l	d0,a0
		move.l	IO_DATA(a1),a2
d1025 1
a1025 1
		bra.s	transfer
d1028 1
a1028 1
*******	Write ********************************************************
d1030 1
a1030 1
*	Write data to the ram disk.
d1033 1
a1033 1
*******	Format *******************************************************
d1035 1
a1035 1
*	Format data to the ram disk -- same as a write.
d1040 2
a1041 2
		move.l	IO_UNIT(a1),d0
		bne	protectedDisk
d1043 4
a1046 4
		move.l	IO_DATA(a1),a0
		lea	RDCodeDataBound(pc),a2
		move.l	IO_OFFSET(a1),d0
		add.l	d0,a2
d1049 4
a1052 4
		move.l	IO_LENGTH(a1),d0
		beq.s	emptyTransfer
		lsr.l	#7,d0		; convert length to groups of 128 bytes
		subq.l  #1,d0		; adjust for dbf count
d1055 33
a1087 33
		move.l	(a0)+,(a2)+	; copy data 0..3
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	;
		move.l	(a0)+,(a2)+	; copy data 124..127
                dbf	d0,transferLoop	; decrement transfer count
d1090 3
a1092 3
		move.l	IO_LENGTH(a1),IO_ACTUAL(a1)
		moveq	#0,d0
		rts
d1095 2
a1096 2
		moveq	#TDERR_WriteProt,d0
		rts
d1104 1
a1104 1
	CNOP	0,4
d1113 2
a1114 2
		
	END
@


34.16
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: ramdrive.asm,v 34.15 87/12/01 12:44:21 bart Exp $
d10 3
d436 3
a438 1
		moveq.l	#-1,FFSR_GlobVec	; assume c type if not bcpl type
@


34.15
log
@FFSR_GlobVec
@
text
@d5 1
a5 1
*	$Header: ramdrive.asm,v 34.14 87/12/01 12:06:17 bart Exp $
d10 3
d281 1
a281 1
FFSR_GlobVec		dc.l	0
d433 1
a433 1
		not.l	FFSR_GlobVec
@


34.14
log
@pad before open... stupid allocabs
@
text
@d5 1
a5 1
*	$Header: ramdrive.asm,v 34.13 87/11/21 15:16:26 bart Exp $
d10 3
d275 1
d278 2
d332 1
a332 1
		move.l	#0,dn_GlobalVec(a2) ; obey bcpl linkage rules
d426 8
@


34.13
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: ramdrive.asm,v 34.12 87/11/21 15:15:26 bart Exp $
d10 3
d327 1
a327 1
		move.l	#$1000,dn_StackSize(a2) ; default stacksize
d780 2
@


34.12
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: ramdrive.asm,v 34.11 87/11/21 11:18:14 bart Exp $
d10 3
d257 1
a257 1
		dc.l	3			; DE_MEMBUFTYPE
@


34.11
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: ramdrive.asm,v 34.10 87/11/20 17:19:41 bart Exp $
d10 3
d321 2
@


34.10
log
@move.l  #(ResidentEnd-Template),d0
@
text
@d5 1
a5 1
*	$Header: ramdrive.asm,v 34.9 87/11/20 16:55:52 bart Exp $
d10 3
d251 1
a251 1
		dc.l	0			; DE_MEMBUFTYPE
@


34.9
log
@move.l  (a7),a0             ; fetch MountList pointer
@
text
@d5 1
a5 1
*	$Header: ramdrive.asm,v 34.8 87/11/20 16:31:49 bart Exp $
d10 3
d473 1
a473 1
		move.l	#(ResidentEnd-ResidentTag),d0
d478 1
@


34.8
log
@Template
@
text
@d5 1
a5 1
*	$Header: ramdrive.asm,v 34.7 87/11/20 14:51:36 bart Exp $
d10 3
d314 1
a314 1
		move.l	4(a7),a0			; fetch MountList pointer
@


34.7
log
@move.l  4(a7),a0            ; fetch MountList pointer
@
text
@d5 1
a5 1
*	$Header: ramdrive.asm,v 34.6 87/11/20 14:01:09 bart Exp $
d10 3
d112 8
d141 2
a142 2
rrPatch6	dc.l	ResidentTag
		dc.l	ResidentEnd-ResidentTag
@


34.6
log
@globvec == -1
@
text
@d5 1
a5 1
*	$Header: ramdrive.asm,v 34.5 87/11/20 12:58:29 bart Exp $
d10 3
a273 1
		move.l	a6,-(a7)			; save ExpansionBase
d275 1
a280 1

d297 1
a297 1
		move.l	#-1,dn_GlobalVec(a2) ; obey c linkage rules
d300 1
d305 1
a305 1
		move.l	(a7)+,a1
@


34.5
log
@obey c linkage rules
@
text
@d5 1
a5 1
*	$Header: ramdrive.asm,v 34.4 87/11/20 12:09:30 bart Exp $
d10 3
d292 2
d295 1
a295 1
		move.l	#1,dn_GlobalVec(a2) ; obey c linkage rules
@


34.4
log
@VolName     dc.b    5,'RAMB0'
@
text
@d5 1
a5 1
*	$Header: ramdrive.asm,v 34.3 87/11/20 11:58:59 bart Exp $
d10 3
d290 1
a290 1
		move.l	#0,dn_GlobalVec(a2) ; obey bcpl linkage rules
@


34.3
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: ramdrive.asm,v 34.2 87/11/20 11:52:17 bart Exp $
d10 3
d662 1
a662 1
VolName		dc.b	11,'RAMB0'
@


34.2
log
@open ffs.resource if available
@
text
@d5 1
a5 1
*	$Header: ramdrive.asm,v 34.1 87/11/18 16:56:53 bart Exp $
d10 3
d235 1
a235 1
		move.l	a2/a6,-(a7)
d291 1
a291 1
		move.l	(a7)+,a2/a1
d295 1
a295 1
		move.l	(a7)+,a2/a6
@


34.1
log
@modifications beginning 11/18/87 Barry A. Whitebook
@
text
@d5 1
a5 1
*	$Header: ramdrive.asm,v 34.0 87/10/09 12:49:26 bart Exp $
d10 3
d72 1
d227 1
d232 1
a232 1
		move.l	a6,-(a7)
d259 1
a259 1
		move.l	a6,-(a7)		; save ExpansionBase
d264 1
a264 1
		beq.s	kickFail2		; if bnDeviceNode is null
d267 11
a277 1
		;------ install fast file-system seglist if specfied
d279 3
a281 2
		move.l	#0,dn_GlobalVec(a1) ; obey bcpl linkage rules
		move.l	#0,dn_SegList(a1) 	; test -- no seglist yet
d283 1
d288 1
a288 1
		move.l	(a7)+,a1
d292 1
a292 1
		move.l	(a7)+,a6
@


34.0
log
@added to rcs for updating
@
text
@d5 1
a5 1
*	$Header: $
d7 1
a7 1
*	$Locker: $
d9 4
a12 1
*	$Log: $
d217 1
a217 1
RDName		dc.b	'RBRD.device',0
d261 6
d639 1
a639 1
VolName		dc.b	11,'Kodiak-RBRD'
@
