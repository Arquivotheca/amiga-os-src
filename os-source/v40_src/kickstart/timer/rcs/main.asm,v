head     39.2;
branch   ;
access   ;
symbols  V39_3:39.1 V39_2:39.1 V39_1:39.0 V37_128:36.32 V37_120:36.31 V37_72:36.30 V37_57:36.29 V37_1:36.28 V36_51:36.27 V36_50:36.27 V36_48:36.26 V36_47:36.25 V36_46:36.25 V36_45:36.25 V36_43:36.24 V36_42:36.24 V36_40:36.24 V36_31:36.23 V36_30:36.23 V36_28:36.22 V36_26:36.21 V36_25:36.20 V36_22:36.20 V36_21:36.19 V36_20:36.18 V36_19:36.17 V36_18:36.16 V36_15:36.15 V36_14:36.15 V36_12:36.12 V36_11:36.11 V36_9:36.11 V36_8:36.10 V36_7:36.9 V36_6:36.9 V36_5:36.8 V36_4:36.7 V36_2:36.6 V36_1:36.3 L36_1:36.1;
locks    ; strict;
comment  @* @;


39.2
date     92.07.29.10.08.10;  author darren;  state Exp;
branches ;
next     39.1;

39.1
date     92.04.20.09.37.14;  author mks;  state Exp;
branches ;
next     39.0;

39.0
date     92.01.20.13.09.08;  author mks;  state Exp;
branches ;
next     36.32;

36.32
date     91.04.22.13.49.34;  author darren;  state Exp;
branches ;
next     36.31;

36.31
date     91.03.25.11.04.10;  author darren;  state Exp;
branches ;
next     36.30;

36.30
date     91.03.21.13.46.25;  author darren;  state Exp;
branches ;
next     36.29;

36.29
date     91.03.14.17.23.52;  author darren;  state Exp;
branches ;
next     36.28;

36.28
date     91.01.25.15.46.24;  author rsbx;  state Exp;
branches ;
next     36.27;

36.27
date     90.06.13.14.42.32;  author rsbx;  state Exp;
branches ;
next     36.26;

36.26
date     90.05.30.14.04.20;  author rsbx;  state Exp;
branches ;
next     36.25;

36.25
date     90.04.01.19.13.05;  author rsbx;  state Exp;
branches ;
next     36.24;

36.24
date     90.02.19.18.04.05;  author rsbx;  state Exp;
branches ;
next     36.23;

36.23
date     89.12.01.12.57.26;  author rsbx;  state Exp;
branches ;
next     36.22;

36.22
date     89.11.23.16.49.13;  author rsbx;  state Exp;
branches ;
next     36.21;

36.21
date     89.09.18.18.04.49;  author rsbx;  state Exp;
branches ;
next     36.20;

36.20
date     89.09.15.18.55.22;  author rsbx;  state Exp;
branches ;
next     36.19;

36.19
date     89.09.13.15.17.11;  author rsbx;  state Exp;
branches ;
next     36.18;

36.18
date     89.08.29.14.00.29;  author rsbx;  state Exp;
branches ;
next     36.17;

36.17
date     89.08.28.16.33.55;  author rsbx;  state Exp;
branches ;
next     36.16;

36.16
date     89.08.24.15.56.33;  author rsbx;  state Exp;
branches ;
next     36.15;

36.15
date     89.08.19.17.01.48;  author rsbx;  state Exp;
branches ;
next     36.14;

36.14
date     89.08.19.16.20.14;  author rsbx;  state Exp;
branches ;
next     36.13;

36.13
date     89.08.19.01.21.40;  author rsbx;  state Exp;
branches ;
next     36.12;

36.12
date     89.08.17.19.28.24;  author rsbx;  state Exp;
branches ;
next     36.11;

36.11
date     89.08.16.13.30.05;  author rsbx;  state Exp;
branches ;
next     36.10;

36.10
date     89.08.14.18.24.30;  author rsbx;  state Exp;
branches ;
next     36.9;

36.9
date     89.08.09.19.14.35;  author rsbx;  state Exp;
branches ;
next     36.8;

36.8
date     89.08.09.18.42.38;  author rsbx;  state Exp;
branches ;
next     36.7;

36.7
date     89.08.09.18.09.48;  author rsbx;  state Exp;
branches ;
next     36.6;

36.6
date     89.08.09.17.46.31;  author rsbx;  state Exp;
branches ;
next     36.5;

36.5
date     89.08.09.14.08.54;  author rsbx;  state Exp;
branches ;
next     36.4;

36.4
date     89.04.13.13.44.06;  author eric;  state Exp;
branches ;
next     36.3;

36.3
date     89.04.06.16.20.23;  author eric;  state Exp;
branches ;
next     36.2;

36.2
date     89.03.23.14.21.48;  author eric;  state Exp;
branches ;
next     36.1;

36.1
date     88.05.01.20.57.27;  author neil;  state Exp;
branches ;
next     ;


desc
@@


39.2
log
@Use REALLY_PALn bit to test for PAL/NTSC machine -- new for
V39 such that the PALn bit is set if selected via BootMenu, but
the REALLY_PALn bit tells me the truth for eclock speed, even
though it may also be incorrect if the machine is jumpered funny.
Nothing we can do about that
@
text
@*************************************************************************
*									*
*	Copyright (C) 1985, Commodore Amiga Inc.  All rights reserved.	*
*									*
*************************************************************************


*************************************************************************
*
* $Id: main.asm,v 39.1 92/04/20 09:37:14 mks Exp Locker: darren $
*
* $Log:	main.asm,v $
* Revision 39.1  92/04/20  09:37:14  mks
* Changed to use TaggedOpenLibrary()
* 
* Revision 39.0  92/01/20  13:09:08  mks
* Timer device now calls battclock to read the base system time.
* Also made some branches short...
*
*************************************************************************

	SECTION	timer

*------ Included Files ***********************************************

	INCLUDE	'hardware/intbits.i'
	INCLUDE	'hardware/cia.i'
	INCLUDE	'resources/cia.i'

	INCLUDE	'exec/types.i'
	INCLUDE	'exec/ables.i'
	INCLUDE	'exec/initializers.i'
	INCLUDE	'exec/errors.i'
	INCLUDE	'exec/alerts.i'
	INCLUDE	'graphics/gfxbase.i'

	INCLUDE	'internal/librarytags.i'

	INCLUDE	'asmsupp.i'
	INCLUDE	'timer.i'
	INCLUDE 'macros.i'
	INCLUDE 'constants.i'
	INCLUDE 'internal.i'
	INCLUDE	'V:src/kickstart/cia/internal.i'

	INCLUDE 'debug.i'

*------ Imported Names ***********************************************

*------ Tables -------------------------------------------------------

*------ Defines ------------------------------------------------------

	XREF	VERNUM
	XREF	REVNUM
	XREF	VERSTRING
	XREF	timerName
	XREF	ciaName
	XREF	BattClockName

	XREF	AddReqUnit0
	XREF	AddReqUnit1
	XREF	AddReqUnit2
	XREF	AddReqUnit3
	XREF	AddReqUnit4
	XREF	RemReqUnit0
	XREF	RemReqUnit1
	XREF	RemReqUnit2
	XREF	RemReqUnit3
	XREF	RemReqUnit4
	XREF	Tick0
	XREF	Tick1
	XREF	Tick2
	XREF	NewTimer
	XREF	RemTimer
	XREF	SetSysTimeIO
	XREF	GetSysTimeIO
	XREF	TimAdd
	XREF	TimSub
	XREF	TimCmp
	XREF	TOD_Int
	XREF	EClock_Int
	XREF	ReadETime
	XREF	GetSysTime

	XREF	Req2STTOD
	XREF	STTOD2Req
	XREF	GetSTTOD
	XREF	EIncSTTOD
	XREF	TODIncSTTOD
	XREF	AdjSTTOD

	XREF	Req2STEClock
	XREF	STEClock2Req
	XREF	GetSTEClock
	XREF	EIncSTEClock
	XREF	TODIncSTEClock
	XREF	AdjSTEClock

	XREF	_ciaa
	XREF	_ciab
	XREF	_intena

	XREF	SwapCIA

	XREF	KPutStr

	INT_ABLES

*------ Functions ----------------------------------------------------

	XDEF	Init
	XDEF	initStruct
	XDEF	Null
	XDEF	NoIO
	XDEF	BeginIO
	XDEF	TermIO
	XDEF	TermIOC
	XDEF	Open
	XDEF	Close

*------ System Library Functions -------------------------------------

	XSYS	TaggedOpenLibrary
	XSYS	CloseLibrary
	XSYS	CacheClearU
	XSYS	OpenResource
	XSYS	MakeLibrary
	XSYS	AddIntServer
	XSYS	ReplyMsg
	XSYS	OpenDevice
	XSYS	SendIO
	XSYS	AddDevice
	XSYS	Alert
	XSYS	Debug

	XSYS	AddICRVector
	XSYS	RemICRVector
	XSYS	SetICR

	XSYS	ReadBattClock

***#*** Exported Names ***********************************************

*------ Functions ----------------------------------------------------

*------ Data ---------------------------------------------------------

***#*** Local Definitions ********************************************

	DS.W	0

V_DEF	MACRO
	dc.W	\1+(*-devFuncInit)
	ENDM

devFuncInit:
	dc.w	-1
	V_DEF	Open		; - 6	Open
	V_DEF	Close		; - C	Close
	V_DEF	Null		; -12	Expunge
	V_DEF	Null		; -18	reserved
	V_DEF	BeginIO		; -1E	begin
	V_DEF	RemTimer	; -24   abort
	V_DEF	TimAdd		; -2A
	V_DEF	TimSub		; -30
	V_DEF	TimCmp		; -36
	V_DEF	ReadETime	; -3C
	V_DEF	GetSysTime	; -42
	dc.w	-1		; end of table

******* timer.device/--background-- **********************************
*
*   TIMER REQUEST
*	A time request is a non standard IO Request.  It has an IORequest
*	followed by a timeval structure or an eclockval structure.
*
*   TIMEVAL
*	A timeval structure consists of two longwords.  The first is
*	the number of seconds, the latter is the fractional number
*	of microseconds.  The microseconds must always be "normalized"
*	e.g. the longword must be between 0 and one million.
*
*   ECLOCKVAL
*	A eclockval structure consists of two longwords.  The first is
*	the high order 32 bits of a 64 bit number and the second is the
*	the low order 32 bits.  The 64 bit number is a count of "E" clock
*	ticks.  The "E" clock frequency is related to the master clock
*	frequency of the machine and can be determined by calling the
*	ReadEClock() library like call.
*
*   UNITS
*	The timer contains five units -- two designed to accuratly measure
*	short intervals, one that has little system overhead and is very
*	stable over time, and two that work like an alarm clock.
*
*   UNIT_MICROHZ
*	This unit uses the programmable timers in the 8520s to keep track
*	of its time.  It has precision down to about 2 microseconds, but
*	will drift as system load increases.  The accuracy of this unit
*	is the same as that of the master clock of the machine.  This unit
*	uses a timeval in its timerequest.
*
*   UNIT_VBLANK
*	This unit uses a strobe from the power supply to keep track of its
*	time or the "E" clock on machines without power supply strobes.
*	It is very stable over time, but only has a resolution of that of
*	the vertical blank interrupt.  This unit is very cheap to use, and
*	should be used by those who are waiting for long periods of time
*	(typically 1/2 second or more).  This unit uses a timeval in its
*	timerequest.
*
*   UNIT_ECLOCK
*	This unit is exacly the same as UNIT_MICROHZ except that it uses
*	an eclockval instead of a timeval in its timerequest.
*
*   UNIT_WAITUNTIL
*	This unit waits until the systime is greater than or equal to the
*	time in the timeval in the timerequest.  This unit has the same
*	resolution and accuracy as that of UNIT_VBLANK.
*
*   UNIT_WAITECLOCK
*	This unit waits until the E-Clock value as returned by ReadEClock()
*	is greater than or equal to the eclockval in the timerequest. This
*	unit has the same resolution and accuracy as that of UNIT_ECLOCK.
*
*   LIBRARY
*	In addition to the normal device calls, the timer also supports
*	several direct, library like calls.
*
*   BUGS
*	In the V1.2/V1.3 release, the timer device has problems with
*	very short time requests.  When one of these is made, other
*	timer requests may be finished inaccurately.  A side effect
*	is that AmigaDOS requests such as "Delay(0);" or
*	"WaitForChar(x,0);" are unreliable.
*
**********************************************************************



*****i* timer.device/internal/Init ***********************************
*
*   NAME
*	Init -- Initialize the timer from nothing.
*
*   SYNOPSIS
*	Init()
*
*	void Init( );
*
*   FUNCTION
*	This routine initializes the timer from nothing.
*
*   INPUTS
*
*   RESULTS
*
*   NOTES
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*	OpenResource() must not fail for either ciaa or ciab
*
*   REGISTER USAGE
*
*	A2 -- timer device pointer
*

Init:
*$* debug
*		movem.l	d0-d7/a0-a6,-(sp)
*		CALLSYS	Debug
*		movem.l	(sp)+,d0-d7/a0-a6
*$* debug
		MOVEM.L	A2/A3/D2,-(SP)

		LEA	devFuncInit,A0
		LEA	initStruct,A1
		SUBA.L	A2,A2
		MOVE.L	#TD_SIZE,D0
		CALLSYS	MakeLibrary		; make us a playpen

		TST.L	D0
		BNE.S	Init_MakeLibOK

		move.l	#(AN_TimerDev!AG_MakeLib),d0
		bsr	T_Alert
		BRA	Init_End

Init_MakeLibOK:
		;------ nothing can go wrong from here on...
		MOVE.L	D0,A2
		MOVE.L	A6,TD_SYSLIB(A2)

; OpenResource will NOT fail at boot time

		LEA	ciaName,A1
		CALLSYS	OpenResource

		move.l	d0,TD_COUNTERRESOURCE(a2)
		move.l	d0,TD_TODRESOURCE(a2)

***********************************************************************
*
* Install call back hook for CIA Alloc/Rem interrupt vector.  Note that
* cia.resource has to be init before the timer.device anyway, and that
* the call back hook is FASTER, and SMALLER than OpenDevice() of the
* the timer.device.  Plus it completely hides the call-back routine.
*
* We also have a call-back hook which is a ptr to timer.device's
* microhz interrupt code.
*
		movea.l	d0,a3			;cache in A3
		move.l	CR_SharedData(a3),a0

		lea	SwapCIA(pc),a1
		move.l	a1,cs_TimerCall(a0)	;cache ptr to hook
		move.l	a2,cs_TimerBase(a0)	;and timerbase

		lea	Tick0(pc),a1
		move.l	a1,cs_TimerCode(a0)	; ptr to interrupt code

		;------ initialize units 0,2 & 4 delay lists
		LEA	TD_ECLOCKLIST(A2),A0
		move.l	a0,TD_UNIT0+TU_UNITLIST(a2)
		move.l	a0,TD_UNIT2+TU_UNITLIST(a2)
		move.l	a0,TD_UNIT4+TU_UNITLIST(a2)
		NEWLIST	A0

		;------ initialize unit 1 delay list
		LEA	TD_VBLANKLIST(A2),A0
		move.l	a0,TD_UNIT1+TU_UNITLIST(a2)
		NEWLIST	A0

		;------ initialize unit 3 wait list
		LEA	TD_SYSTIMELIST(A2),A0
		move.l	a0,TD_UNIT3+TU_UNITLIST(a2)
		NEWLIST	A0

		;------ initializer the TermIO queue
		LEA	TD_TERMIOQ(A2),A0
		NEWLIST	A0

		DISABLE

		;------ set up VBlank interrupt
		LEA	TD_VBLANKINT(A2),A1
		MOVE.L	A2,IS_DATA(A1)
		MOVEQ	#INTB_VERTB,D0
		CALLSYS	AddIntServer

; AddICRVector can NOT fail at boot time

		LEA	TD_TODINT(A2),A1
		MOVE.L	A2,IS_DATA(A1)
		MOVE.B	#CIAICRB_ALRM,D0

		LINKLIB	_LVOAddICRVector,a3	;faster via A3
**		LINKLIB	_LVOAddICRVector,TD_TODRESOURCE(A2)

		LEA	TD_CIATJUMP(A2),A1
		MOVE.L	A2,IS_DATA(A1)
		MOVE.B	#CIAICRB_TA,D0

		LINKLIB	_LVOAddICRVector,a3	;faster via A3
**		LINKLIB	_LVOAddICRVector,TD_COUNTERRESOURCE(A2)

		LEA	TD_CIATBINT(A2),A1
		MOVE.L	A2,IS_DATA(A1)
		MOVE.B	#CIAICRB_TB,D0

		LINKLIB	_LVOAddICRVector,a3	;faster via A3
**		LINKLIB	_LVOAddICRVector,TD_COUNTERRESOURCE(A2)

		bsr	SetTODFrequency

; need to check for graphics magic before proceeding
		moveq.l	#OLTAG_GRAPHICS,d0	; Tag for graphics.library
		CALLSYS	TaggedOpenLibrary

*$* not needed in production
*$*		tst.l	d0
*$*		beq	ERROR
*$* not needed in production

		move.l	d0,a1
		moveq.l	#0,d2
		move.w	gb_DisplayFlags(a1),d2
		CALLSYS	CloseLibrary

	;; test prior to define in V39 gfxbase.i

	IFND	REALLY_PALn
REALLY_PALn	EQU	4
	ENDC

		btst.l	#REALLY_PALn,d2
		beq.s	NTSCxtal	; NTSC xtal constants default
		move.l	#709379,TD_ECLOCKHERTZ(a2)
		move.l	#46490,TD_ECLOCKCONST1(a2)
		move.l	#92385,TD_ECLOCKCONST2(a2)
NTSCxtal:

		; initialize mode specific systime vectors
		moveq.l	#5,d0			; do body 6 times
		lea	Req2STfmt(a2),a0	; dest

		btst.l	#TODA_SAFEn,d2
		bne.s	SetTOD

SetEClock:
		lea	AReq2STEClock(a2),a1
		bra.s	STfmtLoop

SetTOD:
		lea	AReq2STTOD(a2),a1

STfmtLoop:
		addq.l	#2,a0
		move.l	(a1)+,(a0)+
		dbf	d0,STfmtLoop


Init_Finished:

		move.l	TD_ECLOCKHERTZ(a2),ex_EClockFrequency(a6)
		move.b	1+TD_TODHERTZ(A2),PowerSupplyFrequency(A6)

; start the counters

;	TOD
		lea	_ciaa,a0

		bset.b	#CIACRBB_ALARM,ciacrb(a0)
		move.b	#0,ciatodhi(a0)
		move.b	#$10,ciatodmid(a0)
		move.b	#0,ciatodlow(a0)
		bclr.b	#CIACRBB_ALARM,ciacrb(a0)
		move.b	#0,ciatodhi(a0)
		move.b	#0,ciatodmid(a0)
		move.b	#0,ciatodlow(a0)

;	EClock

***		lea	_ciaa,a0 	;redundant code

		andi.b	#CIACRBF_PBON+CIACRBF_OUTMODE,ciacrb(a0)
		move.b	#$ff,ciatblo(a0)
		move.b	#$ff,ciatbhi(a0)
		ori.b	#CIACRBF_LOAD+CIACRBF_START,ciacrb(a0)

; ------ Clear the cache (we just made a jump table)
; ------ clear before enabling interrupts

		CALLSYS	CacheClearU


; ------ Now, read the current time from BattClock (if it is there)
		lea	BattClockName,a1	; find the the clock
		CALLSYS	OpenResource
		tst.l	d0
		beq.s	Init_NoTime	; No battclock...
		move.l	d0,a3		; battclockLib base
		exg	a3,a6		; Get it into a6 (a3 is now exec)
		CALLSYS	ReadBattClock	; Get the time
*
* Build fake timeval...
*
		clr.l	-(sp)		; Put a 0 micros onto the stack...
		move.l	d0,-(sp)	; Put the seconds onto the stack...
		move.l	sp,a0		; Pointer to the timeval...
*
		move.l	a2,a6		; Get my device base...
		jsr	Req2STfmt(a6)	; convert format	(no trash a0)
		jsr	AdjSTfmt(a6)	; adjust for type of clock
		move.l	a3,a6		; Get back original execbase...
*
* Take results and set the time in our timerbase structure...
*
		move.l	(sp)+,TD_SYSTIME+TV_SECS(a2)
		move.l	(sp)+,TD_SYSTIME+TV_MICRO(a2)
*
Init_NoTime:

; ------  Now, finally, enable...

		ENABLE

; ------ tell the world we are here
		MOVE.L	A2,A1
		CALLSYS	AddDevice

Init_End:
		MOVEM.L	(SP)+,A2/A3/D2
		RTS


T_Alert:
*$* debug
*		ERRMSG	"T_Alert"
*$* debug
		movem.l	d7/a5/a6,-(sp)
		move.l	d0,d7
		move.l	4,a6
		jsr	_LVOAlert(a6)
		movem.l	(sp)+,d7/a5/a6
		rts


SetTODFrequency:
*$* debug
*		ERRMSG	"SetTODFrequency"
*$* debug
		lea	_ciaa,a0
		lea	_ciaa,a1

		bclr.b	#CIACRBB_ALARM,ciacrb(a1)
		move.b	#0,ciatodhi(a1)
		move.b	#0,ciatodmid(a1)
		move.b	#0,ciatodlow(a1)

		;------ now check for the power supply frequency
		MOVE.B	#CIACRBF_RUNMODE,ciacrb(A0)
		MOVE.B	#$FF,ciatblo(A0)
		MOVE.B	#$FF,ciatbhi(A0)

		;------ here is how we are going to tell the time in
		;------ a processor independent fashion: we will count
		;------ the time between two ticks of the tod register


		move.b	ciatodlow(a1),d0
waitTODl1:
		tst.b	ciatbhi(a0)
		beq.s	NoTOD
		cmp.b	ciatodlow(a1),d0
		beq.s	waitTODl1
waitTODe1:

		MOVE.B	#CIACRBF_RUNMODE!CIACRBF_START!CIACRBF_LOAD,ciacrb(A0)

		move.b	ciatodlow(a1),d0
waitTODl2:
		tst.b	ciatbhi(a0)
		beq.s	NoTOD
		cmp.b	ciatodlow(a1),d0
		beq.s	waitTODl2
waitTODe2:

		MOVE.B	#CIACRBF_RUNMODE,ciacrb(A0)

		;------ look at the count value and make a guess
		;------ at the power supply value
		CLEAR	D0
		MOVE.B	ciatbhi(A0),D0
		LSL.L	#8,D0
		MOVE.B	ciatblo(A0),D0

		;------	Hertz	NTSC	PAL	count	test
		;------ 60	11932	11923	13060	$ccfc
		;------ 50	14318	14188	18982	$b5da
		;------ 30	23864	23646	26120	$99f8
		;------ 25	28636	28375


Try60Hz:
		cmp.w	#$ccfc,d0
		bcs.s	Try50Hz
		move.w	#60,d0
		move.w	#16667,d1
		bra.s	StuffTOD
Try50Hz:
		cmp.w	#$b5da,d0
		bcs.s	Try30Hz
		move.w	#50,d0
		move.w	#20000,d1
		bra.s	StuffTOD
Try30Hz:
		cmp.w	#$99f8,d0
		bcs.s	Try25Hz
		move.w	#30,d0
		move.w	#33333,d1
		bra.s	StuffTOD
Try25Hz:
		move.w	#25,d0
		move.w	#40000,d1

StuffTOD:
		move.w	d0,TD_TODHERTZ(a2)
		move.w	d1,TD_TIMEPERTOD(a2)
		rts


NoTOD:		bra	T_Alert	; Tail recursion


initStruct:
		INITBYTE	LN_TYPE,NT_DEVICE
		INITLONG	LN_NAME,timerName
		INITBYTE	LIB_FLAGS,LIBF_SUMUSED!LIBF_CHANGED
		INITWORD	LIB_VERSION,VERNUM
		INITWORD	LIB_REVISION,REVNUM
		INITLONG	LIB_IDSTRING,VERSTRING


		INITLONG	TD_UNIT0+TU_ADDREQ,AddReqUnit0
		INITLONG	TD_UNIT0+TU_REMREQ,RemReqUnit0

		INITLONG	TD_UNIT1+TU_ADDREQ,AddReqUnit1
		INITLONG	TD_UNIT1+TU_REMREQ,RemReqUnit1

		INITLONG	TD_UNIT2+TU_ADDREQ,AddReqUnit2
		INITLONG	TD_UNIT2+TU_REMREQ,RemReqUnit2

		INITLONG	TD_UNIT3+TU_ADDREQ,AddReqUnit3
		INITLONG	TD_UNIT3+TU_REMREQ,RemReqUnit3

		INITLONG	TD_UNIT4+TU_ADDREQ,AddReqUnit4
		INITLONG	TD_UNIT4+TU_REMREQ,RemReqUnit4


		INITWORD	Req2STfmt+TJ_OPCODE,$4ef9
		INITWORD	STfmt2Req+TJ_OPCODE,$4ef9
		INITWORD	GetSTfmt+TJ_OPCODE,$4ef9
		INITWORD	EIncSTfmt+TJ_OPCODE,$4ef9
		INITWORD	TODIncSTfmt+TJ_OPCODE,$4ef9
		INITWORD	AdjSTfmt+TJ_OPCODE,$4ef9

		INITLONG	AReq2STTOD,Req2STTOD
		INITLONG	ASTTOD2Req,STTOD2Req
		INITLONG	AGetSTTOD,GetSTTOD
		INITLONG	AEIncSTTOD,EIncSTTOD
		INITLONG	ATODIncSTTOD,TODIncSTTOD
		INITLONG	AAdjSTTOD,AdjSTTOD

		INITLONG	AReq2STEClock,Req2STEClock
		INITLONG	ASTEClock2Req,STEClock2Req
		INITLONG	AGetSTEClock,GetSTEClock
		INITLONG	AEIncSTEClock,EIncSTEClock
		INITLONG	ATODIncSTEClock,TODIncSTEClock
		INITLONG	AAdjSTEClock,AdjSTEClock


* constants for NTSC systems
		INITLONG	TD_ECLOCKHERTZ,715909
		INITLONG	TD_ECLOCKCONST1,46918	; (Ehz*64K)/10^6
		INITLONG	TD_ECLOCKCONST2,91542	; (64K*10^6)/Ehz


* constants for PAL systems
*		INITLONG	TD_ECLOCKHERTZ,709379
*		INITLONG	TD_ECLOCKCONST1,46490	; (Ehz*64K)/10^6
*		INITLONG	TD_ECLOCKCONST2,92385	; (64K*10^6)/Ehz

* constants for 60Hz systems
*		INITWORD	TD_TODHERTZ,60
*		INITWORD	TD_TIMEPERTOD,16667

* constants for 50Hz systems
*		INITWORD	TD_TODHERTZ,50
*		INITWORD	TD_TIMEPERTOD,20000

* constants for 30Hz systems
*		INITWORD	TD_TODHERTZ,30
*		INITWORD	TD_TIMEPERTOD,33333

* constants for 25Hz systems
*		INITWORD	TD_TODHERTZ,25
*		INITWORD	TD_TIMEPERTOD,40000


		INITBYTE	TD_TODINT+LN_TYPE,NT_INTERRUPT
		INITLONG	TD_TODINT+LN_NAME,timerName
		INITLONG	TD_TODINT+IS_CODE,TOD_Int

		INITBYTE	TD_VBLANKINT+LN_TYPE,NT_INTERRUPT
		INITLONG	TD_VBLANKINT+LN_NAME,timerName
		INITLONG	TD_VBLANKINT+IS_CODE,Tick1

		INITBYTE	TD_CIATBINT+LN_TYPE,NT_INTERRUPT
		INITLONG	TD_CIATBINT+LN_NAME,timerName
		INITLONG	TD_CIATBINT+IS_CODE,EClock_Int

		INITBYTE	TD_CIATJUMP+LN_TYPE,NT_INTERRUPT
		INITLONG	TD_CIATJUMP+LN_NAME,timerName
		INITLONG	TD_CIATJUMP+IS_CODE,Tick0

		INITLONG	TD_JUMPYCIACRX,(_ciaa+ciacra)
		INITLONG	TD_JUMPYCIATXLO,(_ciaa+ciatalo)

		DC.L		0

*****i* timer.device/function/BeginIO ********************************
*
*   NAME
*	BeginIO -- Perform a device command.
*
*   SYNOPSIS
*	BeginIO( IORequest )
*	         A1
*
*	void BeginIO( struct timerequest * );
*
*   FUNCTION
*	This routine is the external entry point for device commands.
*
*   INPUTS
*	IORequest -- the timer request block.
*
*   RESULTS
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*

BeginIO:
*$* debug
*		ERRMSG	"BeginIO"
*$* debug
		move.b	#0,IO_ERROR(a1)		; clear error

		cmp.b	#NT_MESSAGE,LN_TYPE(a1)
		bne.s	NotAgain
		move.l	a1,-(sp)
		bsr	RemTimer
		move.l	(sp)+,a1
		tst.l	d0
		bne.s	NotAgain
		rts

NotAgain
		move.w	IO_COMMAND(a1),d0

		subi.w	#TR_ADDREQUEST,d0	; validate command
		bmi.s	NoIO
		cmp.w	#(TR_SETSYSTIME-TR_ADDREQUEST),d0
		bhi.s	NoIO

		;------ the following line is needed for WaitIO
		move.b	#NT_MESSAGE,LN_TYPE(a1)

		;------ get the function address
		add.w	d0,d0
		add.w	d0,d0	; d0*4
		jmp	cmdTable(pc,d0.w)

cmdTable:
	bra.w	NewTimer	; TR_ADDTIMER
	bra.w	GetSysTimeIO	; TR_GETSYSTIME
	bra.w	SetSysTimeIO	; TR_SETSYSTIME
cmdTableEnd:


*****i* timer.device/function/Open ***********************************
*
*   NAME
*	Open -- Open the timer for use.
*
*   SYNOPSIS
*	Open( Unit, Flags, IORequest )
*	      D0    D1     A1
*
*	void Open( LONG, LONG, struct timerequest * );
*
*   FUNCTION
*	This routine opens the timer up for use and initializes the
*	IORequest with the correct unit information.
*
*   INPUTS
*	Unit -- the unit number -- either UNIT_VBLANK or UNIT_MICROHZ
*	Flags -- ignored
*	IORequest -- a pointer to the users timerequest block.
*
*   RESULTS
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*

Open:
		TST.L	D0
		BNE.S	Open_Not0
*$* debug
*		ERRMSG	"Open0"
*$* debug
		LEA	TD_UNIT0(A6),A0
		BRA.S	Open_OK

Open_Not0:
		SUBQ.L	#1,D0
		BNE.S	Open_Not1
*$* debug
*		ERRMSG	"Open1"
*$* debug
		LEA	TD_UNIT1(A6),A0
		BRA.S	Open_OK

Open_Not1:
		SUBQ.L	#1,D0
		BNE.S	Open_Not2
*$* debug
*		ERRMSG	"Open2"
*$* debug
		LEA	TD_UNIT2(A6),A0
		BRA.S	Open_OK

Open_Not2:
		SUBQ.L	#1,D0
		BNE.S	Open_Not3
*$* debug
*		ERRMSG	"Open3"
*$* debug
		LEA	TD_UNIT3(A6),A0
		BRA.S	Open_OK

Open_Not3:
		SUBQ.L	#1,D0
		BNE.S	Open_Err
*$* debug
*		ERRMSG	"Open4"
*$* debug
		LEA	TD_UNIT4(A6),A0

Open_OK:
		MOVE.L	A0,IO_UNIT(A1)
		ADDQ.W	#1,LIB_OPENCNT(A6)
		RTS

Open_Err:
		MOVE.B	#IOERR_OPENFAIL,IO_ERROR(A1)
		bra.s	CloseOut
		; RFT

*****i* timer.device/function/Close **********************************
*
*   NAME
*	Close - Close the device.
*
*   SYNOPSIS
*	Close( IORequest )
*	       A1
*
*	void Close( struct timerequest * );
*
*   FUNCTION
*	This routine closes the device.
*
*   INPUTS
*	IORequest -- an timerequest block for this unit.
*
*   RESULTS
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*

Close:
*$* debug
*		ERRMSG	"Close"
*$* debug
		SUBQ.W	#1,LIB_OPENCNT(A6)
CloseOut:
*$* debug
*		ERRMSG	"CloseOut"
*$* debug
		MOVEQ	#-1,D0		; invalidate the request
		MOVE.L	D0,IO_DEVICE(A1)
		MOVE.L	D0,IO_UNIT(A1)

		; fall into Null
		; RFT


*****i* timer.device/function/Null ***********************************
*
*   NAME
*	Null -- Do nothing
*
*   SYNOPSIS
*	null = Null()
*	D0
*
*	LONG Null( );
*
*   FUNCTION
*	This routine returns null.
*
*   INPUTS
*
*   RESULTS
*	null -- always zero.
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*

Null:
*$* debug
*		ERRMSG	"Null"
*$* debug
		CLEAR	D0
		RTS


*****i* timer.device/internal/NoIO ***********************************
*
*   NAME
*	NoIO -- Return an IO request error.
*
*   SYNOPSIS
*	NoIO( IORequest )
*	      A1
*
*	void NoIO( struct timerequest * );
*
*   FUNCTION
*	This routine is a dummy entry for IO request blocks.  It always
*	returns an error.
*
*   INPUTS
*
*   RESULTS
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*

NoIO:
*$* debug
*		ERRMSG	"NoIO"
*$* debug
		MOVE.B	#IOERR_NOCMD,IO_ERROR(A1)

		; fall through
		; RFT


*****i* timer.device/internal/TermIO *********************************
*
*   NAME
*	TermIO - Reply an IO Request block
*
*   SYNOPSIS
*	TermIO( IORequest )
*	        A1
*
*	void TermIO( struct timerequest * );
*	void TermIOC( struct timerequest * );
*
*   FUNCTION
*
*   INPUTS
*
*   RESULTS
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*

TermIOC:
*$* debug
*		ERRMSG	"TermIOC"
*$* debug
		moveq.l	#0,d0
		move.l	d0,IOTV_TIME+TV_SECS(a1)	; don't leave
		move.l	d0,IOTV_TIME+TV_MICRO(a1)	; anything

TermIO:
*$* debug
*		ERRMSG	"TermIO"
*$* debug
		BTST	#IOB_QUICK,IO_FLAGS(A1)
		BNE.S	TermIO_End

		LINKSYS	ReplyMsg
TermIO_End:
		RTS



	END
@


39.1
log
@Changed to use TaggedOpenLibrary()
@
text
@d10 1
a10 1
* $Id: main.asm,v 39.0 92/01/20 13:09:08 mks Exp Locker: mks $
d13 3
d397 7
a403 1
		btst.l	#PALn,d2
@


39.0
log
@Timer device now calls battclock to read the base system time.
Also made some branches short...
@
text
@d10 1
a10 1
* $Id$
d12 5
a16 1
* $Log$
d34 2
a57 1
	XREF	graphicsName
d121 1
a121 1
	XSYS	OpenLibrary
d381 2
a382 3
		lea	graphicsName,a1
		moveq.l	#0,d0
		CALLSYS	OpenLibrary
@


36.32
log
@Remove code needed to support SetICR() in RethinkMicroTimer().
@
text
@d10 1
a10 1
* main.asm
d12 1
a12 64
* Source Control
* ------ -------
* 
* $Id: main.asm,v 36.31 91/03/25 11:04:10 darren Exp Locker: darren $
*
* $Locker: darren $
*
* $Log:	main.asm,v $
* Revision 36.31  91/03/25  11:04:10  darren
* Some new comments.
* 
* Revision 36.30  91/03/21  13:46:25  darren
* ClearCacheU before adding device (timer builds a JMP table).  Couple
* of optimizations (remove redundant calls to OpenResource() of 
* ciaa.resource), and redundant loading of A0 with EA of _ciaa.
* 
* Revision 36.29  91/03/14  17:23:52  darren
* Major changes to support our new jumpy timer.device - can use any one
* of three interval timers - works with the new cia.resource.
* 
* Revision 36.28  91/01/25  15:46:24  rsbx
* Change to V37
* 
* Revision 36.27  90/06/13  14:42:32  rsbx
* I don't want to talk about it!
* 
* Revision 36.26  90/05/30  14:04:20  rsbx
* Added kludge to zero the timeval of the timerequest before returning it,
* since most of the developers that used the timer.device can't read.
* 
* Revision 36.25  90/04/01  19:13:05  rsbx
* RCS version change.
* 
* Revision 36.24  90/02/19  18:04:05  rsbx
* Changes to improve MIDI performance.
* 
* Revision 36.23  89/12/01  12:57:26  rsbx
* Added backgound section for autodocs.
* 
* Revision 36.22  89/11/23  16:49:13  rsbx
* Cleaned up some graphics kludges. Removed references to TR_WAITUNTIL and
* WaitUnitl() from to docs.
* 
* Revision 36.21  89/09/18  18:04:49  rsbx
* 
* 
* Revision 36.10  89/08/14  18:24:30  rsbx
* Removed dead code. Commented out zeroing of timeval when replying a
* request.
* 
* Revision 36.9  89/08/09  19:14:35  rsbx
* changed some comments for autodoc
* 
* Revision 36.8  89/08/09  18:42:38  rsbx
* exec now sets up quantum fields in execbase
* 
* Revision 36.7  89/08/09  18:09:48  rsbx
* *** empty log message ***
* 
* Revision 36.5  89/08/09  14:08:54  rsbx
* Major changes for the rewritten timer.device. Consists mostly
* of init code.
* 
* 
d35 1
a35 1
	INCLUDE	'../cia/internal.i'
d50 2
a51 1
 
d133 2
a140 3
	XDEF	devFuncInit
	XDEF	cmdTable

d144 5
d150 13
a162 12
	DC.L	Open		; - 6	Open
	DC.L	Close		; - C	Close
	DC.L	Null		; -12	Expunge
	DC.L	Null		; -18	reserved
	DC.L	BeginIO		; -1E	begin
	DC.L	RemTimer	; -24   abort
	DC.L	TimAdd		; -2A
	DC.L	TimSub		; -30
	DC.L	TimCmp		; -36
	DC.L	ReadETime	; -3C
	DC.L	GetSysTime	; -42
	DC.L	-1		; end of table
d228 1
a228 1
*	"WaitForChar(x,0);" are unreliable. 
d402 1
a402 1
		bne	SetTOD
d450 30
d587 1
a587 3
NoTOD:
		bsr	T_Alert
		rts
d738 1
a738 1
		bmi	NoIO
d740 1
a740 1
		bhi	NoIO
d746 2
a747 1
		lsl.w	#2,d0
d751 3
a753 3
	bra	NewTimer	; TR_ADDTIMER
	bra	GetSysTimeIO	; TR_GETSYSTIME
	bra	SetSysTimeIO	; TR_SETSYSTIME
@


36.31
log
@Some new comments.
@
text
@d15 1
a15 1
* $Id: main.asm,v 36.30 91/03/21 13:46:25 darren Exp Locker: darren $
d20 3
a356 1
		move.l	d0,TD_JUMPYRESOURCE(a2)
d421 1
a421 1
**		LINKLIB	_LVOAddICRVector,TD_JUMPYRESOURCE(A2)
a711 2
		INITWORD	TD_JUMPYTDSET,(CIAICRF_SETCLR!CIAICRF_TA)

@


36.30
log
@ClearCacheU before adding device (timer builds a JMP table).  Couple
of optimizations (remove redundant calls to OpenResource() of 
ciaa.resource), and redundant loading of A0 with EA of _ciaa.
@
text
@d15 1
a15 1
* $Id: main.asm,v 36.29 91/03/14 17:23:52 darren Exp Locker: darren $
d20 5
a499 3

		ENABLE

d501 1
d504 2
@


36.29
log
@Major changes to support our new jumpy timer.device - can use any one
of three interval timers - works with the new cia.resource.
@
text
@d15 1
a15 1
* $Id: main.asm,v 36.28 91/01/25 15:46:24 rsbx Exp Locker: darren $
d20 4
d172 1
a341 2
		LEA	ciaName,A1
		CALLSYS	OpenResource
a343 2
		move.l	d0,TD_COUNTERRESOURCE(a2)
		
d347 1
a347 2
; OpenResource will NOT fail at boot time

d361 3
a363 2
		movea.l	d0,a0
		move.l	CR_SharedData(a0),a0
d400 2
a404 1
		LINKLIB	_LVOAddICRVector,TD_TODRESOURCE(A2)
d406 2
a407 1
**		MOVE.L	a2,TD_CIATJINT+IS_DATA(a2)
a411 1
		LINKLIB	_LVOAddICRVector,TD_JUMPYRESOURCE(A2)
d413 2
a414 1
; AddICRVector can NOT fail at boot time
a418 2
		LINKLIB	_LVOAddICRVector,TD_COUNTERRESOURCE(A2)
; AddICRVector can NOT fail at boot time
d420 3
d468 1
d487 3
a489 1
		lea	_ciaa,a0
d497 4
@


36.28
log
@Change to V37
@
text
@d15 1
a15 1
* $Id$
d17 1
a17 1
* $Locker: rsbx $
d20 3
d86 2
d101 1
d115 1
d146 2
d342 1
a342 1

d345 1
d349 1
d351 15
d367 3
a402 1
; AddICRVector can NOT fail at boot time
d404 3
a406 1
		LEA	TD_CIATAINT(A2),A1
d409 2
a410 1
		LINKLIB	_LVOAddICRVector,TD_COUNTERRESOURCE(A2)
a680 1
		INITBYTE	TD_VBLANKINT+LN_PRI,0
a683 4
		INITBYTE	TD_CIATAINT+LN_TYPE,NT_INTERRUPT
		INITLONG	TD_CIATAINT+LN_NAME,timerName
		INITLONG	TD_CIATAINT+IS_CODE,Tick0

d687 8
@


36.27
log
@I don't want to talk about it!
@
text
@d15 1
a15 1
* $Header: /usr/professor/rsbx/timer.device/RCS/main.asm,v 36.26 90/05/30 14:04:20 rsbx Exp Locker: rsbx $
d20 3
@


36.26
log
@Added kludge to zero the timeval of the timerequest before returning it,
since most of the developers that used the timer.device can't read.
@
text
@d15 1
a15 1
* $Header: /usr/professor/rsbx/timer.device/RCS/main.asm,v 36.25 90/04/01 19:13:05 rsbx Exp Locker: rsbx $
d20 4
d699 1
a699 1
		MOVE.B	#0,IO_ERROR(A1)		; clear error
d701 8
a708 1
		MOVE.W	IO_COMMAND(A1),D0
d710 3
d719 1
a719 1
		MOVE.B	#NT_MESSAGE,LN_TYPE(A1)
d722 2
a723 2
		LSL.W	#2,D0
		JMP	cmdTable(pc,d0.w)
d726 3
a728 3
	BRA	NewTimer	; TR_ADDTIMER
	BRA	GetSysTimeIO	; TR_GETSYSTIME
	BRA	SetSysTimeIO	; TR_SETSYSTIME
@


36.25
log
@RCS version change.
@
text
@d15 1
a15 1
* $Header: /usr/professor/rsbx/timer.device/RCS/main.asm,v 36.24 90/02/19 18:04:05 rsbx Exp Locker: rsbx $
d20 3
d975 6
a980 3
*		moveq.l	#0,d0
*		move.l	d0,IOTV_TIME+TV_SECS(a1)	; don't leave
*		move.l	d0,IOTV_TIME+TV_MICRO(a1)	; anything
@


36.24
log
@Changes to improve MIDI performance.
@
text
@d15 1
a15 1
* $Header: main.asm,v 36.23 89/12/01 12:57:26 rsbx Exp $
d20 3
@


36.23
log
@Added backgound section for autodocs.
@
text
@d15 1
a15 1
* $Header: main.asm,v 36.22 89/11/23 16:49:13 rsbx Exp $
d20 3
d420 1
@


36.22
log
@Cleaned up some graphics kludges. Removed references to TR_WAITUNTIL and
WaitUnitl() from to docs.
@
text
@d15 1
a15 1
* $Header: main.asm,v 36.21 89/09/18 18:04:49 rsbx Exp $
d20 4
d182 69
@


36.21
log
@
@
text
@d15 1
a15 1
* $Header: main.asm,v 36.10 89/08/14 18:24:30 rsbx Exp $
d17 1
a17 1
* $Locker:  $
d20 3
d316 1
a316 2
*$* kludge
		btst.l	#2,d2	;btst.l	#PAL,d2
d327 1
a327 2
*$* kludge
		btst	#3,d2	;btst.l	#TODA_SAFE,d2
@


36.20
log
@
@
text
@d78 1
d83 1
d249 1
a249 1
		;------ initialize units 0 & 2 delay lists
d253 1
d500 2
d503 1
d699 1
a699 1
		BNE.S	Open_Err
d704 9
@


36.19
log
@
@
text
@d73 1
a173 2
graphicsname:
	dc.b	'graphics.library',0
a174 3
	ds.w	0


d220 1
a220 1
		CALLSYS	MakeLibrary
d296 1
a296 1
		lea	graphicsname,a1
d318 1
d605 1
a605 1
		MOVE.B	#0,IO_ERROR(A1)
d609 1
a609 1
		subi.w	#TR_ADDREQUEST,d0
d751 1
a751 1
		MOVEQ	#-1,D0
d877 2
a878 4
*		move.l	d0,(a1)
*		move.l	d0,4(a1)
*		move.l	d0,IOTV_TIME+TV_SECS(a1)
*		move.l	d0,IOTV_TIME+TV_MICRO(a1)
@


36.18
log
@TR_WAITUNTIL became UNIT_WAITUNTIL.
@
text
@d53 1
d95 14
d131 2
a157 1

a158 1

d173 2
d176 3
d297 1
a297 1
*$* need to check for graphics magic before proceeding
d299 4
d304 38
d343 1
a343 1
*		move.b	TD_TODHERTZ(A2),PowerSupplyFrequency(A6)
d347 12
d390 89
d500 24
a523 1
* constants for 60Hz NTSC systems
d529 1
a529 1
* constants for 50Hz PAL systems
d533 16
@


36.17
log
@TR_WAITUNTIL command removed.
@
text
@d75 1
d79 1
a91 1
	XREF	WaitUntilIO
d242 1
a242 1
		;------ initializer the WaitUntil list
d244 1
a298 7
*$* debug
*		ERRMSG	"rsbx timer (core only, CIA A, vblank mapped to microhz) added"
*		movem.l	d0-d7/a0-a6,-(sp)
*		CALLSYS	Debug
*		movem.l	(sp)+,d0-d7/a0-a6
*$* debug

d334 3
a425 1
	bra	WaitUntilIO	; TR_WAITUNTIL
d485 1
a485 1
		BNE.S	Open_Err
d490 9
@


36.16
log
@TimeDelay() and WaitUntil() removed.
@
text
@d414 1
a414 1
		cmp.w	#(TR_WAITUNTIL-TR_ADDREQUEST),d0
@


36.15
log
@Changed Delay to TimeDelay.
@
text
@a90 2
	XREF	TimeDelay
	XREF	WaitUntil
a154 2
	DC.L	TimeDelay		; -48
	DC.L	WaitUntil	; -4E
@


36.14
log
@Making Autodoc comments conform to Autodoc sytle guide.
@
text
@d91 1
a91 1
	XREF	Delay
d157 1
a157 1
	DC.L	Delay		; -48
@


36.13
log
@Added GetSysTime, Delay, and WaitUntil to the device function entrypoints.
@
text
@d162 1
a162 1
***#*** System/Drivers/Timer/Init ************************************
d165 1
a165 1
*	Init - Initialize the timer from nothing
d168 1
a168 2
*	Init() SysLib
*	       A6
d170 2
d173 1
a173 1
*	This routine initializes the timer from nothing
d179 1
a179 1
*   EXCEPTIONS
d375 1
a375 1
***#*** System/Drivers/Timer/BeginIO *********************************
d378 1
a378 1
*	BeginIO - start the io off and running
d381 2
a382 2
*	BeginIO( IORequest ), TimerLib
*	         A1	      A6
d384 2
d387 1
a387 1
*	This routine is the external entry point for IO
d390 1
a390 1
*	IORequest -- the timer request block
d436 1
a436 1
***#*** System/Drivers/Timer/Open ************************************
d439 1
a439 1
*	Open - Open the timer for use
d442 2
a443 2
*	Open( Unit, Flags, IORequest ), timerDevice
*	      D0    D1     A1           A6
d445 2
d454 1
a454 1
*	IORequest -- a pointer to the users request block
d508 1
a508 1
***#*** System/Drivers/Timer/Close ***********************************
d511 1
a511 1
*	Close - Close the device
d514 2
a515 2
*	Close( IORequest ), timerDevice
*	       A1	    A6
d517 2
d520 1
a520 1
*	This routine closes the device
d523 1
a523 1
*	IORequest -- an iorequest block for this unit
d558 1
a558 1
***#*** System/Drivers/Timer/Null ************************************
d561 1
a561 1
*	Null - Do nothing
d567 2
d570 1
a570 1
*	This routine return null.
d575 1
a575 1
*	null - always zero
d598 2
a599 1
***#*** System/Drivers/Timer/NoIO ************************************
d602 1
a602 1
*	NoIO - dummy entry for IO Request
d608 2
d642 1
a642 1
***#*** System/Drivers/Timer/TermIO **********************************
d645 1
a645 1
*	TermIO - Satisfy an IO Request block
d650 3
@


36.12
log
@Added WaitUntil command.
@
text
@d91 3
a154 1
*$* remove this
d156 3
@


36.11
log
@Cleanup. Added unit 2 setup and open code.
@
text
@d90 1
d152 1
d410 1
a410 1
		cmp.w	#(TR_SETSYSTIME-TR_ADDREQUEST),d0
d424 1
@


36.10
log
@Removed dead code. Commented out zeroing of timeval when replying a
request.
@
text
@d15 1
a15 1
* $Header: main.asm,v 36.9 89/08/09 19:14:35 rsbx Exp $
d17 1
a17 1
* $Locker: rsbx $
d20 4
d42 1
a42 1
***#*** Included Files ***********************************************
d61 1
a61 1
***#*** Imported Names ***********************************************
d74 1
d77 1
d82 2
a83 2
	XREF	SetSysTime
	XREF	GetSysTime
a87 1
	XREF	ClearTOD
d226 4
a229 2
		;------ initialize the two lists
		LEA	TD_UNIT0(A2),A0
d231 4
a234 1
		LEA	TD_UNIT1(A2),A0
d237 4
a244 4
		;------ initializer the WaitUntil list
		LEA	TD_UNTILLIST(A2),A0
		NEWLIST	A0

d332 3
d420 2
a421 2
	BRA	GetSysTime	; TR_GETSYSTIME
	BRA	SetSysTime	; TR_SETSYSTIME
a461 1

d470 1
a470 2
		BNE.S	Open_Err

d475 9
@


36.9
log
@changed some comments for autodoc
@
text
@d15 1
a15 1
* $Header: main.asm,v 36.8 89/08/09 18:42:38 rsbx Exp $
d20 3
a262 41
*$* check TOD frequency section start
*		lea	_ciaa,a0
*		lea	_ciaa,a1
*
*		bclr.b	#CIACRBB_ALARM,ciacrb(a1)
*		move.b	#0,ciatodhi(a1)
*		move.b	#0,ciatodmid(a1)
*		move.b	#0,ciatodlow(a1)
*
*		;------ now check for the power supply frequency
*		MOVE.B	#CIACRBF_RUNMODE,ciacrb(A0)
*		MOVE.B	#$FF,ciatblo(A0)
*		MOVE.B	#$FF,ciatbhi(A0)
*
*		;------ here is how we are going to tell the time in
*		;------ a processor independent fashion: we will count
*		;------ the time between two ticks of the tod register
*
*		BSR	Init_waittick
*		MOVE.B	#CIACRBF_RUNMODE!CIACRBF_START!CIACRBF_LOAD,ciacrb(A0)
*		BSR	Init_waittick
*		MOVE.B	#CIACRBF_RUNMODE,ciacrb(A0)
*
*		;------ look at the count value and make a guess
*		;------ at the power supply value
*		CLEAR	D0
*		MOVE.B	ciatbhi(A0),D0
*		LSL.L	#8,D0
*		MOVE.B	ciatblo(A0),D0
*
*		;------ the way it works out, 60 hz will read as
*		;------ $d164.  50 hz SHOULD (I never had a 50hz
*		;------ system to test it on...) read as $c894.
*		;------ Mid way between is $ccfc.
*
*		cmp.w	#$ccfc,d0
*		bhi.s	Init_Finished	; assume 60Hz
*
*		move.w	#50,TD_TODHERTZ(A2)
*		move.w	#20000,TD_TIMEPERTOD(A2)
*$* check TOD frequency section end
d267 1
a267 1
; start all of the counters
a268 13
;	TOD
		lea	_ciaa,a0

		bset.b	#CIACRBB_ALARM,ciacrb(a0)
		move.b	#0,ciatodhi(a0)
		move.b	#$10,ciatodmid(a0)
		move.b	#0,ciatodlow(a0)
		bclr.b	#CIACRBB_ALARM,ciacrb(a0)
		move.b	#0,ciatodhi(a0)
		move.b	#0,ciatodmid(a0)
		move.b	#0,ciatodlow(a0)


a293 6
;
; wait for a cia time of day tick.  This routine is used to calibrate
; the power supply tick to 50 or 60 hertz
;
Init_waittick:	; (8520 in a0)
		move.b	ciatodlow(a1),d0
a294 15
waittick_loop:
		cmp.b	ciatodlow(a1),d0
		bne.s	waittick_end

		tst.b	ciatbhi(a0)
		bmi.s	waittick_loop

		;------ the watchdog timer went positive -- give it up
		move.l	#(AN_TMBadSupply+$8000000),d0
		bsr	T_Alert
		MOVE.L	(SP)+,D0	; pop return addr
		bra	Init_Finished
waittick_end:
		rts

a322 2
*		INITWORD	TD_TODHERTZ,60
*		INITWORD	TD_TIMEPERTOD,16667
a328 2
*		INITWORD	TD_TODHERTZ,50
*		INITWORD	TD_TIMEPERTOD,20000
d632 5
a636 5
		moveq.l	#0,d0
		move.l	d0,(a1)
		move.l	d0,4(a1)
		move.l	d0,IOTV_TIME+TV_SECS(a1)
		move.l	d0,IOTV_TIME+TV_MICRO(a1)
@


36.8
log
@exec now sets up quantum fields in execbase
@
text
@d15 1
a15 1
* $Header: main.asm,v 36.7 89/08/09 18:09:48 rsbx Exp $
d17 1
a17 1
* $Locker:  $
d20 3
d35 1
a35 1
******* Included Files ***********************************************
d54 1
a54 1
******* Imported Names ***********************************************
d119 1
a119 1
******* Exported Names ***********************************************
d128 1
a128 1
******* Local Definitions ********************************************
d147 1
a147 1
******* System/Drivers/Timer/Init ************************************
d430 1
a430 1
******* System/Drivers/Timer/BeginIO *********************************
d488 1
a488 1
******* System/Drivers/Timer/Open ************************************
d551 1
a551 1
******* System/Drivers/Timer/Close ***********************************
d599 1
a599 1
******* System/Drivers/Timer/Null ************************************
d637 1
a637 1
******* System/Drivers/Timer/NoIO ************************************
d678 1
a678 1
******* System/Drivers/Timer/TermIO **********************************
@


36.7
log
@*** empty log message ***
@
text
@d15 1
a15 1
* $Header: /usr.MC68010/machines/professor/professor/rsbx/timer.device/RCS/main.asm,v 36.5 89/08/09 14:08:54 rsbx Exp $
d20 3
a227 5

		;------ set up the scheduling quantum
*$* this constant should be moved to exec
		MOVE.W	#DEFAULTQUANTUM,Quantum(A6)
		MOVE.W	Quantum(a6),Elapsed(A6)
@


36.6
log
@*** empty log message ***
@
text
@d15 1
a15 1
* $Header: /usr.MC68010/ghostwheel/commodore/amiga/V36/src/kickstart/timer/RCS/main.asm,v 36.5 89/08/09 14:08:54 rsbx Exp $
@


36.5
log
@Major changes for the rewritten timer.device. Consists mostly
of init code.
@
text
@d15 1
a15 1
* $Header$
d17 1
a17 1
* $Locker$
d19 5
a23 1
* $Log$
@


36.4
log
@Changed termination of initStruct from DC.L 0 to DC.W 0
@
text
@a0 1

d15 1
a15 1
* $Header: main.asm,v 36.3 89/04/06 16:20:23 eric Exp $
d17 1
a17 1
* $Locker: eric $
d19 1
a19 3
* $Log:	main.asm,v $
* Revision 36.3  89/04/06  16:20:23  eric
* Changed INFOLEVEL to 0
a20 45
* Revision 36.3  89/04/06  15:37:52  eric
* Disabled debugging
* 
* Revision 36.2  89/03/23  14:21:48  eric
* Changed DEFAULTQUANTUM from 16 to 4 (for V1.4)
* 
* 
* Revision 36.1  88/05/01  20:57:27  neil
* *** empty log message ***
* 
* Revision 33.1  86/03/31  01:12:12  neil
* major changes in the interest of speed.
* 
* Revision 32.1  86/01/15  22:26:17  neil
* PAL and 50hz power supply integration
* 
* Revision 31.3  85/11/11  08:23:28  neil
* added id string to library node
* 
* Revision 31.2  85/11/04  10:06:56  neil
* new system time (via 8520) scheme
* 
* Revision 31.1  85/10/13  11:26:52  neil
* retrieved fixes from V28.  They got lost in the shuffle.
* 
* 	Neil
* 
* Revision 27.3  85/08/10  15:25:52  carl
* Decreased time spent while disabled during timer interrupt
* processing by queuing completed requests and handling them
* when not disabled.
* 
* Revision 27.2  85/07/19  08:09:31  neil
* exported TimAdd, TimSub, and TimCmp to the outside world
* 
* Revision 27.1  85/06/24  13:32:13  neil
* Upgrade to V27
* 
* Revision 26.2  85/06/17  15:40:38  neil
* added library checksum bits
* 
* Revision 26.1  85/06/17  14:56:09  neil
* *** empty log message ***
* 
* 
d25 1
a25 1
****** Included Files *************************************************
d29 1
a31 9
	INCLUDE	'exec/lists.i'
	INCLUDE	'exec/nodes.i'
	INCLUDE	'exec/ports.i'
	INCLUDE	'exec/libraries.i'
	INCLUDE	'exec/devices.i'
	INCLUDE	'exec/io.i'
	INCLUDE	'exec/strings.i'
	INCLUDE	'exec/interrupts.i'
	INCLUDE	'exec/tasks.i'
a33 1
	INCLUDE	'exec/execbase.i'
d39 2
d42 1
a42 1
	INCLUDE 'messages.i'
d44 1
a44 1
****** Imported Names **********************************************
d54 5
a58 4
	XREF	StartUnit0
	XREF	StartUnit1
	XREF	StopUnit0
	XREF	StopUnit1
d63 2
d68 4
d74 1
d77 2
d89 1
a91 4
	XDEF	GetSysTime
	XDEF	ReadSysTime
	XDEF	SetSysTime
	XDEF	ClearTOD
a94 4
XSYS	MACRO
	XREF	_LVO\1
	ENDM

d103 1
d105 3
a107 2
	XREF	_LVOAddICRVector
	XREF	_LVORemICRVector
d109 1
a109 1
****** Exported Names ************************************************
d118 1
a118 1
****** Local Definitions *********************************************
a119 3
LINKSYS		MACRO	* &func
		LINKLIB _LVO\1,TD_SYSLIB(A6)
		ENDM
a120 21
*		;------ copy timvec Ax into Ay
TIMCPY		MACRO	Ax,Ay,Xoffset,Yoffset
		IFGE	NARG-3
XOFFSET		SET	\3
YOFFSET		SET	\4
		ENDC
		IFLT	NARG-3
XOFFSET		SET	0
YOFFSET		SET	0
		ENDC
		MOVE.L	XOFFSET+TV_SECS(\1),YOFFSET+TV_SECS(\2)
		MOVE.L	XOFFSET+TV_MICRO(\1),YOFFSET+TV_MICRO(\2)
		ENDM

INFOLEVEL	EQU	0	; was 50
DEFAULTQUANTUM	EQU	4	; Changed from 16	3/23/89 for V1.4


ciaName:	DC.B	'ciaa.resource',0
timername:	TIMERNAME

d130 4
a133 3
	DC.L	TimAdd
	DC.L	TimSub
	DC.L	TimCmp
d137 1
a137 1
******p timer.device/Init ********************************************
d162 1
d170 5
a176 14
		LEA	ciaName,A1
		CALLSYS	OpenResource
		TST.L	D0
		BNE.S	Init_CiaOK

*****		PEA	ciaName
*****		PUTMSG	1,<'%s/Init: Can not open %s'>
*****		ADDQ.L	#4,SP
		ALERT	(AN_TimerDev!AG_OpenRes!AO_CIARsrc)
		BRA	Init_End

Init_CiaOK:
		MOVE.L	D0,A3

d179 1
a179 1
		CLRA.L	A2
d186 2
a187 3
*****		PUTMSG	1,<'%s/Init:  MakeLibrary failed'>
		ALERT	(AN_TimerDev!AG_MakeLib),,A0

d191 1
d193 1
d195 3
a197 1
*		;------ nothing can go wrong from here on...
d199 1
a199 5
		IFGE	INFOLEVEL-100
		move.l	A2,-(SP)
		PUTMSG	100,<'%s/Init: after Makelibrary (dev is at 0x%lx)'>
		ADDQ.L	#4,SP
		ENDC
d201 3
a203 4
		MOVE.L	A3,TDU0+TU_RESOURCE(A2)
		MOVE.L	A6,TD_SYSLIB(A2)
		MOVE.L	A2,TDU0+TU_DEVICE(A2)
		MOVE.L	A2,TDU1+TU_DEVICE(A2)
d205 3
d209 1
a209 1
		LEA	TDU0(A2),A0
d211 1
a211 1
		LEA	TDU1(A2),A0
d214 2
a215 2
		;------ initializer the TermIO queues for both units:
		LEA	TDU0+TU_TERMIOQ(A2),A0
d217 3
a219 1
		LEA	TDU1+TU_TERMIOQ(A2),A0
d223 1
d225 1
a225 1
		MOVE.W	#DEFAULTQUANTUM,Elapsed(A6)
d227 5
a231 4
*		;------ set up unit 1 interrupt
		LEA	TDU1+TU_INT(A2),A1
		LEA	TDU1(A2),A0
		MOVE.L	A0,IS_DATA(A1)
d235 5
a239 3
		;---!!! Kludge to enable vertical blank int -- graphics should
		;---!!! do this, but it doesn't exist yet.
		MOVE.W	#INTF_SETCLR!INTF_VERTB,_intena
d241 8
a248 5
*		;------ set up unit 0 interrupt
*		;------ talk to the resource
		LEA	TDU0+TU_INT(A2),A1
		LEA	TDU0(A2),A0
		MOVE.L	A0,IS_DATA(A1)
d250 2
a251 1
		LINKLIB	_LVOAddICRVector,TDU0+TU_RESOURCE(A2)
d253 1
a253 2
		;------ figure out what the time between vertical
		;------ blanks is.
d255 41
a295 10
Init_ComputeVBlank:
		;------ assume for the moment no pal (60 hz vblank)
		CLEAR	D0
		move.b	VBlankFrequency(A6),D0
		bne.s	10$
		moveq	#60,D0		; if unset, assume USA defaults
10$:
		move.l	#1000000,D1
		move.l	d0,d2
		divu	d2,d1
d297 2
a298 13
		;------ d1 now has 1 000 000/(vblankfrequency)
		;------ which is the number of microseconds per vertical
		;------ blank.  Figure out if we need to round up.
		CLEAR	d2
		move.w	d1,d2		; save vblank period
		swap	d1		; get remainder
		lsr.l	#1,d0		; get 1/2 of dividend
		cmp.w	d0,d1		; is remainder > 1/2 dividend?
		blt.s	20$
		addq.l	#1,d2		; we must round up
20$:
		move.l	d2,TD_TIMEPERVBLANK(A2)
		move.l	d2,TU_TICKVAL+TV_MICRO+TDU1(A2)
d300 1
a300 2
		;------ now check for the power supply frequency
		BSR	ClearTODonly	; ( returns _ciaa in A0 )
d302 2
a303 3
		MOVE.B	#CIACRBF_RUNMODE,ciacrb(A0)
		MOVE.B	#$FF,ciatblo(A0)
		MOVE.B	#$FF,ciatbhi(A0)
d305 8
a312 3
		;------ here is how we are going to tell the time in
		;------ a processor independent fashion: we will count
		;------ the time between two ticks of the tod register
a313 1
		DISABLE
d315 6
a320 4
		BSR	Init_waittick
		MOVE.B	#CIACRBF_RUNMODE!CIACRBF_START!CIACRBF_LOAD,ciacrb(A0)
		BSR	Init_waittick
		MOVE.B	#CIACRBF_RUNMODE,ciacrb(A0)
a321 6
		;------ look at the count value and make a guess
		;------ at the power supply value
		CLEAR	D0
		MOVE.B	ciatbhi(A0),D0
		LSL.L	#8,D0
		MOVE.B	ciatblo(A0),D0
d325 1
a325 31

		;------ the way it works out, 60 hz will read as
		;------ $d164.  50 hz SHOULD (I never had a 50hz
		;------ system to test it on...) read as $c812.
		;------ Mid way between is $ccdd.

		cmp.w	#$ccdd,d0
		bhi.s	Init_Assume60HZ

		moveq	#50,D0
		move.w	#20000,D1
		bra.s	Init_setTODfreq

Init_Assume60HZ:
		moveq	#60,D0
		move.w	#16667,D1

Init_setTODfreq:
		move.w	d0,TD_TODHERTZ(A2)
		move.w	d1,TD_TIMEPERTOD(A2)
		move.b	d0,PowerSupplyFrequency(A6)

	IFGE	INFOLEVEL-60
	move.l	TD_TIMEPERVBLANK(A2),-(SP)
	and.l	#$ffff,d1
	movem.l	D0/D1,-(SP)
	PUTMSG	60,<'%s/Init: tod hz %ld/%ld, micros per vb %ld'>
	lea	12(sp),sp
	ENDC

*		;------ tell the world we are here
d329 7
d345 1
a345 1
		move.b	ciatodlow(a0),d0
d348 1
a348 1
		cmp.b	ciatodlow(a0),d0
d355 4
a358 2
		ALERT	AN_TMBadSupply
		bra	Init_Assume60HZ
d362 10
d373 1
a381 3
		INITWORD	TDU0+TU_UNITNUM,0
		INITLONG	TDU0+TU_START,StartUnit0
		INITLONG	TDU0+TU_STOP,StopUnit0
d383 2
a384 4
		INITBYTE	TDU0+TU_INT+LN_TYPE,NT_INTERRUPT
		INITBYTE	TDU0+TU_INT+LN_PRI,30
		INITLONG	TDU0+TU_INT+LN_NAME,timerName
		INITLONG	TDU0+TU_INT+IS_CODE,Tick0
d386 2
a387 3
		INITWORD	TDU1+TU_UNITNUM,1
		INITLONG	TDU1+TU_START,StartUnit1
		INITLONG	TDU1+TU_STOP,StopUnit1
d389 6
a394 3
		INITBYTE	TDU1+TU_INT+LN_TYPE,NT_INTERRUPT
		INITLONG	TDU1+TU_INT+LN_NAME,timerName
		INITLONG	TDU1+TU_INT+IS_CODE,Tick1
a395 1
		DC.W		0	;was dc.l 0 - emc 04/13/89
d397 6
a402 30
******p timer.device/Null ********************************************
*
*   NAME
*	Null - Do nothing
*
*   SYNOPSIS
*	null = Null()
*	D0
*
*   FUNCTION
*	This routine return null.
*
*   INPUTS
*
*   RESULTS
*	null - always zero
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*
a403 3
Null:
		CLEAR	D0
		RTS
d405 21
a425 1
******p timer.device/BeginIO *****************************************
d457 3
a459 2
		ERRMSG	60,<'%s/BeginIO: called'>

a462 2
		CMP.W	#TR_SETSYSTIME,D0
		BHI.S	Begin_BadCom
d464 5
a475 11
******		BRA.S	Begin_End


Begin_BadCom:
		MOVE.B	#IOERR_NOCMD,IO_ERROR(A1)

		BSR	TermIO

Begin_End:
		RTS

a476 9
	BRA	NoIO		; CMD_INVALID
	BRA	NoIO		; CMD_RESET
	BRA	NoIO		; CMD_READ
	BRA	NoIO		; CMD_WRITE
	BRA	NoIO		; CMD_UPDATE
	BRA	NoIO		; CMD_CLEAR
	BRA	NoIO		; CMD_STOP
	BRA	NoIO		; CMD_START
	BRA	NoIO		; CMD_FLUSH
d483 1
a483 1
******p timer.device/NoIO ********************************************
d486 1
a486 1
*	NoIO - dummy entry for IO Request
d489 2
a490 2
*	NoIO( IORequest )
*	      A1
d493 2
a494 2
*	This routine is a dummy entry for IO request blocks.  It always
*	returns an error.
d497 3
d517 3
a519 2
NoIO:
		MOVE.B	#IOERR_NOCMD,IO_ERROR(A1)
d521 5
a525 1
		BSR	TermIO
d527 12
d541 4
d546 1
a546 2

******p timer.device/TermIO ******************************************
d549 1
a549 1
*	TermIO - Satisfy an IO Request block
d552 2
a553 2
*	TermIO( IORequest )
*	        A1
d556 1
d559 1
d577 12
a588 3
TermIO:
		BTST	#IOB_QUICK,IO_FLAGS(A1)
		BNE.S	TermIO_End
d590 2
a591 3
		LINKSYS	ReplyMsg
TermIO_End:
		RTS
d594 1
a594 1
******p timer.device/Open ********************************************
d597 1
a597 1
*	Open - Open the timer for use
d600 2
a601 2
*	Open( Unit, Flags, IORequest ), timerDevice
*	      D0    D1     A1           A6
d604 1
a604 2
*	This routine opens the timer up for use and initializes the
*	IORequest with the correct unit information.
a606 3
*	Unit -- the unit number -- either UNIT_VBLANK or UNIT_MICROHZ
*	Flags -- ignored
*	IORequest -- a pointer to the users request block
d609 1
d625 5
a629 29
Open:
		MOVEM.L	D2/A3,-(SP)

		CLEAR	D2
		MOVE.L	D0,A3

		ERRMSG	100,<'%s/Open: called'>

		CMP.L	D2,A3
		BNE.S	Open_Not0

		LEA	TDU0(A6),A3
		BRA.S	Open_OK

Open_Not0:
		ADDQ.L	#1,D2
		CMP.L	D2,A3
		BNE.S	Open_Err

		LEA	TDU1(A6),A3

Open_OK:

		MOVE.L	A3,IO_UNIT(A1)

		ADDQ.W	#1,LIB_OPENCNT(A6)

Open_End:
		MOVEM.L	(SP)+,D2/A3
d632 1
a632 6
Open_Err:
		MOVE.B	#IOERR_OPENFAIL,IO_ERROR(A1)
		BRA.S	Open_End


******p timer.device/Close *******************************************
d635 1
a635 1
*	Close - Close the device
d638 2
a639 2
*	Close( IORequest ), timerDevice
*	       A1	    A6
d642 2
a643 1
*	This routine closes the device
a645 1
*	IORequest -- an iorequest block for this unit
d663 5
a667 2
Close:
		MOVEQ	#-1,D0
d669 2
a670 2
		MOVE.L	D0,IO_DEVICE(A1)
		MOVE.L	D0,IO_UNIT(A1)
a671 1
		SUBQ.W	#1,LIB_OPENCNT(A6)
d673 1
a673 7
		;---!!! We should return our segment list here
		CLEAR	D0

		RTS


******* timer.device/TR_GETSYSTIME ***********************************
d676 1
a676 1
*	TR_GETSYSTIME - Get the current system time
d678 4
a682 3
*	Ask the timer what time it is.  The system time starts
*	off at zero at power on, but may be initialized via
*	the TR_SETSYSTIME call.
d684 1
a684 6
*	System time is monotonically increasing, and guaranteed
*	to be unique (except if someone sets the time backwards).
*	The time is incremented every vertical blank by the
*	vertical blanking interval;  in addition it is changed
*	every time someone asks what time it is.  This way the
*	return value of the system time is unique and unrepeating
a685 4
*   TIMER REQUEST
*	io_Command	TR_GETSYSTIME
*	io_Flags	IOF_QUICK allowable
*
a686 2
*	tr_time		the timeval structure will be filled in with
*			    the current system time
d688 1
a688 1
**********************************************************************
d690 1
a690 1
*   IMPLEMENTATION NOTES
d692 1
a693 82
*   REGISTER USAGE
*

GetSysTime:
		MOVE.L	A1,-(SP)
		LEA	IOTV_TIME(A1),A0

		;------ get the current time
		BSR	ReadSysTime

		;------ and send it back to him
		MOVE.L	(SP)+,A1
		BSR	TermIO
		RTS


ReadSysTime:	; ( dest_timeval: a0 )

		DISABLE	A1

		;------ copy in base time
		MOVE.L	TD_SYSTIME+TV_SECS(A6),(A0)	; TV_SECS == 0
		MOVE.L	TD_SYSTIME+TV_MICRO(A6),TV_MICRO(A0)
	
		;------ get the time of day register
		CLEAR	D0
		LEA	_ciaa,A1
		MOVE.B	ciatodhi(A1),D0
		LSL.L	#8,D0
		MOVE.B	ciatodmid(A1),D0
		LSL.L	#8,D0
		MOVE.B	ciatodlow(A1),D0

		ENABLE	A1

		;------ divide it by HERTZ (number of ticks a second)
		;------ we administratively prevent the tod register from
		;------ getting over 0x10000.  This guarantees that the
		;------ divide by HERTZ (either 50 or 60) will not overflow.
		DIVU	TD_TODHERTZ(A6),D0	; convert to seconds
		SWAP	D0		; make remainder available
		MOVE.W	D0,D1
		MULU	TD_TIMEPERTOD(A6),D1 ; convert remainder to microsecs
		ADD.L	TD_NUMREQS(A6),D1 ; add number of times we asked
		MOVE.L	D1,-(SP)	; push microseconds

		SWAP	D0		; get seconds back
		MOVE.W	D0,A1		; sign extend will clear upper word
		MOVE.L	A1,-(SP)	; push seconds

		;------ add this value to the user's request
		MOVE.L	SP,A1
		BSR	TimAdd
		ADDQ.L	#8,SP

		MOVEQ	#1,D0
		ADD.L	D0,TD_NUMREQS(A6) ; bump number of time requests

		RTS


******* timer.device/TR_SETSYSTIME ***********************************
*
*   NAME
*	TR_SETSYSTIME - set the system time
*
*   FUNCTION
*	Set the systems idea of what time it is.  The system
*	starts out at time "zero" so it is safe to set it
*	forward to the "real" time.  However care should be taken
*	when setting the time backwards.  System time is
*	speced as being monotonically increasing.
*
*   TIMER REQUEST
*	io_Command	TR_SETSYSTIME
*	io_Flags	IOF_QUICK allowable
*	tr_time		a timeval structure with the current system
*			    time
*
*   RESULTS
*	none
*
d702 6
a707 1
SetSysTime:
d709 6
a714 1
		DISABLE	A0
d716 2
a717 13
		;------ set the saved time
		TIMCPY	A1,A6,IOTV_TIME,TD_SYSTIME

		;------ clear the timer counter
		BSR.S	ClearTOD

*****	MOVE.L	IOTV_TIME+TV_MICRO(A1),-(SP)
*****	MOVE.L	IOTV_TIME+TV_SECS(A1),-(SP)
*****	PUTMSG	1,<'%s/SetSysTime: %ld.%06ld'>
*****	ADDQ.L	#8,SP

		ENABLE	A0
		BSR	TermIO
a719 2
ClearTOD:
		CLR.L	TD_NUMREQS(A6)
a720 7
ClearTODonly:	; ( must return _ciaa in A0 )
		LEA	_ciaa,A0
		CLEAR	D0
		MOVE.B	D0,ciatodhi(A0)
		MOVE.B	D0,ciatodmid(A0)
		MOVE.B	D0,ciatodlow(A0)
		RTS
@


36.3
log
@Changed INFOLEVEL to 0
@
text
@d16 1
a16 1
* $Header: main.asm,v 36.3 89/04/06 15:37:52 eric Exp $
d18 1
a18 1
* $Locker:  $
d21 3
d462 1
a462 1
		DC.L		0
@


36.2
log
@Changed DEFAULTQUANTUM from 16 to 4 (for V1.4)

@
text
@d16 1
a16 1
* $Header: main.asm,v 36.1 88/05/01 20:57:27 neil Exp $
d18 1
a18 1
* $Locker: eric $
d21 7
d185 1
a185 1
INFOLEVEL	EQU	50
@


36.1
log
@*** empty log message ***
@
text
@d16 1
a16 1
* $Header: main.asm,v 33.1 86/03/31 01:12:12 neil Exp $
d18 1
a18 1
* $Locker:  $
d21 3
d63 1
a63 1
******* Included Files ***********************************************
d89 1
a89 1
******* Imported Names ***********************************************
d149 1
a149 1
******* Exported Names ***********************************************
d158 1
a158 1
******* Local Definitions ********************************************
d179 1
a179 1
DEFAULTQUANTUM	EQU	16
d200 1
a200 1
******* System/Drivers/Timer/Init ************************************
d454 1
a454 1
******* System/Drivers/Timer/Null ************************************
d489 1
a489 1
******* System/Drivers/Timer/BeginIO *********************************
d563 1
a563 1
******* System/Drivers/Timer/NoIO ************************************
d603 1
a603 1
******* System/Drivers/Timer/TermIO **********************************
d641 1
a641 1
******* System/Drivers/Timer/Open ************************************
d711 1
a711 1
******* System/Drivers/Timer/Close ***********************************
d756 1
a756 1
******* System/Drivers/Timer/GetSysTime ******************************
d759 1
a759 1
*	GetSysTime - Get the current system time
a760 4
*   SYNOPSIS
*	GetSysTime( IOTimeRequest ), timerDevice
*	            A1	         A6
*
d762 3
a764 6
*	This routine puts the current system time into the timeval
*	structure of the request.  This time is guaranteed to be
*	larger than the last time GetSysTime was called (e.g. it
*	is monotonically increasing).  In addition, the time is
*	updated every vertical blank, so time is discontinuous --
*	it will take large jumps every vertical blank.
d766 6
a771 2
*   INPUTS
*	IOTimeRequest -- an IOTV request block for the timer
d773 4
d778 2
a780 6
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
d847 1
a847 1
******* System/Drivers/Timer/SetSysTime ******************************
d850 1
a850 1
*	SetSysTime - set the system time
a851 4
*   SYNOPSIS
*	SetSysTime( IORequest ), timerDevice
*	            A1	         A6
*
d853 5
a857 2
*	This routine sets the system time.  Be careful of setting the
*	time backwards!
d859 5
a863 2
*   INPUTS
*	IOTimeRequest -- an IOTV request block for the timer
d866 1
a866 6
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
@
