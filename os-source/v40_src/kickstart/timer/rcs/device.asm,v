head     36.24;
branch   ;
access   ;
symbols  V39_3:36.24 V39_2:36.24 V39_1:36.24 V37_128:36.23 V37_120:36.23 V37_72:36.23 V37_57:36.23 V37_1:36.22 V36_51:36.21 V36_50:36.21 V36_48:36.21 V36_47:36.20 V36_46:36.20 V36_45:36.20 V36_43:36.19 V36_42:36.19 V36_40:36.19 V36_31:36.18 V36_30:36.18 V36_28:36.18 V36_26:36.17 V36_25:36.17 V36_22:36.17 V36_21:36.16 V36_20:36.15 V36_19:36.14 V36_18:36.14 V36_15:36.14 V36_14:36.13 V36_12:36.11 V36_11:36.10 V36_9:36.10 V36_8:36.9 V36_7:36.9 V36_6:36.8 V36_5:36.7 V36_4:36.7 V36_2:36.6 V36_1:36.4 L36_1:36.3;
locks    ; strict;
comment  @* @;


36.24
date     91.11.05.18.40.41;  author darren;  state Exp;
branches ;
next     36.23;

36.23
date     91.03.14.17.24.47;  author darren;  state Exp;
branches ;
next     36.22;

36.22
date     91.01.25.15.45.56;  author rsbx;  state Exp;
branches ;
next     36.21;

36.21
date     90.05.30.14.02.55;  author rsbx;  state Exp;
branches ;
next     36.20;

36.20
date     90.04.01.19.12.34;  author rsbx;  state Exp;
branches ;
next     36.19;

36.19
date     90.02.16.11.55.51;  author rsbx;  state Exp;
branches ;
next     36.18;

36.18
date     89.11.23.16.49.43;  author rsbx;  state Exp;
branches ;
next     36.17;

36.17
date     89.09.15.18.55.01;  author rsbx;  state Exp;
branches ;
next     36.16;

36.16
date     89.09.13.15.17.51;  author rsbx;  state Exp;
branches ;
next     36.15;

36.15
date     89.08.29.13.59.34;  author rsbx;  state Exp;
branches ;
next     36.14;

36.14
date     89.08.20.18.06.03;  author rsbx;  state Exp;
branches ;
next     36.13;

36.13
date     89.08.19.17.13.03;  author rsbx;  state Exp;
branches ;
next     36.12;

36.12
date     89.08.19.16.57.42;  author rsbx;  state Exp;
branches ;
next     36.11;

36.11
date     89.08.17.19.26.05;  author rsbx;  state Exp;
branches ;
next     36.10;

36.10
date     89.08.16.13.24.32;  author rsbx;  state Exp;
branches ;
next     36.9;

36.9
date     89.08.13.18.37.26;  author rsbx;  state Exp;
branches ;
next     36.8;

36.8
date     89.08.09.19.13.08;  author rsbx;  state Exp;
branches ;
next     36.7;

36.7
date     89.08.09.18.09.24;  author rsbx;  state Exp;
branches ;
next     36.6;

36.6
date     89.08.09.17.47.36;  author rsbx;  state Exp;
branches ;
next     36.5;

36.5
date     89.08.09.14.05.50;  author rsbx;  state Exp;
branches ;
next     36.4;

36.4
date     89.04.05.16.07.07;  author eric;  state Exp;
branches ;
next     36.3;

36.3
date     88.09.19.09.44.01;  author neil;  state Exp;
branches ;
next     36.2;

36.2
date     88.09.19.09.37.17;  author neil;  state Exp;
branches ;
next     36.1;

36.1
date     88.05.01.20.57.24;  author neil;  state Exp;
branches ;
next     ;


desc
@@


36.24
log
@Autodoc changes
@
text
@*************************************************************************
*									*
*	Copyright (C) 1985, Commodore Amiga Inc.  All rights reserved.	*
*									*
*************************************************************************


*************************************************************************
*
* device.asm
*
* Source Control
* ------ -------
* 
* $Id: device.asm,v 36.24 91/11/05 18:00:08 darren Exp $
*
* $Locker:  $
*
* $Log:	device.asm,v $
* Revision 36.24  91/11/05  18:00:08  darren
* Remove spurious "()" from autodoc lines.
* 
* Revision 36.23  91/03/14  17:24:47  darren
* *** empty log message ***
* 
* Revision 36.22  91/01/25  15:45:56  rsbx
* Change to V37
* 
* Revision 36.21  90/05/30  14:02:55  rsbx
* Added kludge to zero the timeval of the timerequest before returning it,
* since most of the developers that used the timer.device can't read.
* 
* Revision 36.20  90/04/01  19:12:34  rsbx
* RCS version change.
* 
* Revision 36.19  90/02/16  11:55:51  rsbx
* Changes to improve MIDI performance.
* 
* Revision 36.18  89/11/23  16:49:43  rsbx
* Cleaned up some graphics kludges. Removed references to TR_WAITUNTIL and
* WaitUnitl() from to docs.
* 
* Revision 36.17  89/09/15  18:55:01  rsbx
* 
* 
* Revision 36.9  89/08/13  18:37:26  rsbx
* Fixed up comment blocks for autodoc.
* 
* Revision 36.8  89/08/09  19:13:08  rsbx
* changedsome comments for the benefit of autodoc
* 
* Revision 36.7  89/08/09  18:09:24  rsbx
* *** empty log message ***
* 
* Revision 36.5  89/08/09  14:05:50  rsbx
* Rewritten for the new timer.device
* 
*
*************************************************************************

	SECTION	timer

*------ Included Files -----------------------------------------------

	INCLUDE	'hardware/intbits.i'
	INCLUDE	'hardware/cia.i'
	INCLUDE	'resources/cia.i'

	INCLUDE	'exec/types.i'
	INCLUDE	'exec/ables.i'
	INCLUDE	'exec/errors.i'

	INCLUDE	'asmsupp.i'
	INCLUDE	'timer.i'
	INCLUDE 'macros.i'
	INCLUDE 'constants.i'
	INCLUDE 'internal.i'
	INCLUDE 'debug.i'

*------ Imported Names -----------------------------------------------

*------ Tables -------------------------------------------------------

*------ Defines ------------------------------------------------------

	XREF	_ciaa
	XREF	_ciab
	XREF	_AbsExecBase
*$* graphics kludge
	XREF	_custom

	INT_ABLES

*------ Functions ----------------------------------------------------

	XREF	TermIO
	XREF	TermIOC
	XREF	Mult64
	XREF	ReadEClockTime
	XREF	GetSysTime
	XREF	TOD_Int

*------ System Library Functions -------------------------------------

	XSYS	Insert
	XSYS	Alert
	XSYS	ReplyMsg
	XSYS	SetICR
	XSYS	AbleICR
	XSYS	AddHead

*------ Exported Names -----------------------------------------------

*------ Functions ----------------------------------------------------

	XDEF	NewTimer
	XDEF	RemTimer
	XDEF	GetSysTimeIO
	XDEF	SetSysTimeIO
	XDEF	InsertReq
	XDEF	IntEnd
	XDEF	IntCommon
	XDEF	AdjSTTOD
	XDEF	AdjSTEClock
	XDEF	Req2STTOD
	XDEF	Req2STEClock

*------ Data ---------------------------------------------------------

*------ Local Definitions --------------------------------------------



******* timer.device/TR_ADDREQUEST ***********************************
*
*   NAME
*	TR_ADDREQUEST -- Submit a request to wait a period of time.
*
*   FUNCTION
*	Ask the timer to wait a specified amount of time before
*	replying the timerequest.
*
*	The message may be forced to finish early with an
*	AbortIO()/WaitIO() pair.
*
*   TIMER REQUEST
*	io_Message      mn_ReplyPort initialized
*	io_Device       preset by timer in OpenDevice
*	io_Unit         preset by timer in OpenDevice
*	io_Command      TR_ADDREQUEST
*	io_Flags        IOF_QUICK permitted (but ignored)
*	tr_time         a timeval structure specifying how long the 
*	                    device will wait before replying
*
*   RESULTS
*	tr_time         will be zeroed
*
*   NOTES
*	This function may be called from interrupts.
*
*	Previous to 2.0, the tr_time field was documented as containing
*	junk when the timerequest was returned.
*
*   SEE ALSO
*	timer.device/AbortIO(),
*	timer.device/TimeDelay(),
*
*   BUGS
*
**********************************************************************
*****i* timer.device/internal/NewTimer *******************************
*
*   NAME
*	NewTimer -- Add a new timer request.
*
*   SYNOPSIS
*	NewTimer( IOBlock )
*	          A1
*
*	void NewTimer( struct timerequest * );
*
*   FUNCTION
*	This routine adds an IO request to the timer.  It runs in
*	the context of the requester.
*
*   INPUTS
*	IOBlock - the command block for this IO operation.
*
*   RESULTS
*
*   NOTES
*	This function may be called from interrupts.
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*	A6 -- TDDev (given)
*	A3 -- unit list (found/restored)
*	A2 -- munged (restored)
*	A1 -- request (given)
*	A0 -- munged

NewTimer:
*$* debug
*		ERRMSG	"NewTimer"
*$* debug
		bclr	#IOB_QUICK,IO_FLAGS(a1)

		movem.l	a2-a3,-(sp)

		move.l	IO_UNIT(a1),a3		; do unit specific addreqest
		move.l	TU_ADDREQ(a3),a0	; processing
		move.l	TU_UNITLIST(a3),a3	; get list
		jsr	(a0)

		movem.l	(sp)+,a2-a3
		rts


**********************************************************************
*
*   REGISTER USAGE
*	A6 -- TDDev (given)
*	A3 -- list (given)
*	A2 -- munged
*	A1 -- request (given)
*	A0 -- munged
*


InsertReq:
*$* debug
*		ERRMSG	"InsertReq"
*$* debug
		TD_DISABLE	a0,TD_SYSLIB(a6)

		move.l	a3,a0		; setup previous for loop
		move.l	(a3),d0		; setup current for loop
ILoop:
		move.l	a0,a2		; set previous
		move.l	d0,a0		; set current
		move.l	LN_SUCC(a0),d0	; get next
		beq.s	DoInsert	; end of list, insert it
		LTIMCMP	a1,a0,d1,IOTV_TIME,IOTV_TIME	; (a0)-(a1)
		bls.s	ILoop		; keep goin' 'till current > req
DoInsert:
		move.l	a3,a0
		move.l	a1,-(sp)
		LINKSYS	Insert		; list=a0, node=a1, previous=a2
		move.l	(sp)+,a1

		TD_ENABLE	a0,TD_SYSLIB(a6)

		rts



******* timer.device/AbortIO *****************************************
*
*   NAME
*	AbortIO -- Remove an existing timer request.
*
*   SYNOPSIS
*	error = AbortIO( timerequest )
*	D0               A1
*
*	LONG AbortIO( struct timerequest * );
*
*   FUNCTION
*	This is an exec.library call.
*
*	This routine removes a timerquest from the timer.  It runs in
*	the context of the caller.
*
*   INPUTS
*	timerequest - the timer request to be aborted
*
*   RETURNS
*	0  if the request was aborted, io_Error will also be set to
*	    IOERR_ABORTED.
*	-1 otherwise
*
*   NOTES
*	This function may be called from interrupts.
*
*   SEE ALSO
*	exec.library/AbortIO()
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*	A6 -- TDDev (given)
*	A3 -- unit list
*	A2 -- munged (restored)
*	A1 -- request (given)
*	A0 -- munged

RemTimer:
*$* debug
*		ERRMSG	"RemTimer"
*$* debug
		TD_DISABLE	A0,TD_SYSLIB(a6)

		;------ initialization step
		move.l	IO_UNIT(a1),a0
		move.l	TU_UNITLIST(a0),a0	; get unit list
		move.l	(a0),d0			; get first entry

RemTimer_Loop:
		move.l	d0,a0			; new current
		move.l	(a0),d0			; get next
		beq.s	RemTimer_NotFound	; list end
		cmpa.l	a0,a1			; same?
		bne.s	RemTimer_Loop		; nope, look again

RemTimer_Found:
*$* debug
*		ERRMSG	"RemTimer found"
*$* debug
		movem.l	a2/a3,-(sp)

		move.l	IO_UNIT(a1),a3		; do unit specific remreqest
		move.l	TU_REMREQ(a3),a0	; processing
		move.l	TU_UNITLIST(a3),a3	; get unit list (again)
		move.l	a1,-(sp)		; save request
		jsr	(a0)		; returns ENABLED
		move.l	(sp)+,a1

; reply aborted request
		move.b	#IOERR_ABORTED,IO_ERROR(A1)
		movem.l	(sp)+,a2/a3
		bsr	TermIOC			; reply the request

		clr.l	d0			; set abort result
		rts

RemTimer_NotFound:
*$* debug
*		ERRMSG	"RemTimer not found"
*$* debug
		TD_ENABLE	A0,TD_SYSLIB(a6)
		moveq.l	#-1,D0			; set abort result

		rts


**********************************************************************
*
*   REGISTER USAGE
*	A6 -- TDDev (given)
*	A3 -- list (given)
*	A1 -- munged
*	A0 -- unit specific version of current time (munged)
*

IntCommon:
		movem.l	a2,-(sp)
		move.l	a0,a2		; save time value

		TD_DISABLE	a0,TD_SYSLIB(a6)
ICLoop:
		cmpa.l	LH_TAIL+LN_PRED(a3),a3	; are we done?
		beq.s	ICDone

		move.l	(a3),a1		; get first list entry
		LTIMCMP	a1,a2,d1,IOTV_TIME,0	; (a2)-(a1)
		bcs.s	ICDone		; not expired, bye

		move.l	a3,a0
		REMHEAD			; a0=list, a1=node
		move.l	d0,a1		; get request (again)
		lea	TD_TERMIOQ(a6),a0
		ADDTAIL			; add request to reply Q
		bra.s	ICLoop		; check for more

ICDone:
		TD_ENABLE	A0,TD_SYSLIB(a6)

		movem.l	(sp)+,a2
		rts


**********************************************************************
*
*   REGISTER USAGE
*	A6 -- TDDev (given)
*	A1 -- munged
*	A0 -- munged
*

IntEnd:
		movem.l	(sp)+,a3

;  Process the TermIO queue created IntCommon
PIOLoop:
		lea	TD_TERMIOQ(a6),a0	; find reply Q
		TD_DISABLE	a1,TD_SYSLIB(a6)
		REMHEAD			; get first entry off Q
		TD_ENABLE	a1,TD_SYSLIB(a6)
		tst.l	d0		; test enpty Q
		beq.s	PIODone		; empty, we're done
		move.l	d0,a1
		bsr	TermIOC		; reply the request
		bra.s	PIOLoop		; look for more

PIODone:

*$* graphics kludge
		lea	_custom,a0


		;------ leave the condition codes set correctly
*		moveq.l	#0,d0

		rts


**********************************************************************


******* timer.device/TR_SETSYSTIME ***************************
*
*   NAME
*	TR_SETSYSTIME -- Set the system time.
*
*   FUNCTION
*	Set the system idea of what time it is.  The system starts out
*	at time "zero" so it is safe to set it forward to the real
*	time.  However, care should be taken when setting the time
*	backwards.  System time is generally expected to monotonically
*	increasing.
*
*   TIMER REQUEST
*	io_Message      mn_ReplyPort initialized
*	io_Device       preset by timer in OpenDevice
*	io_Unit         preset by timer in OpenDevice
*	io_Command      TR_GETSYSTIME
*	io_Flags        IOF_QUICK permitted
*	tr_time         a timeval structure with the current system
*	                    time
*
*   RESULTS
*	tr_time         will contain junk
*
*   NOTES
*	This function may be called from interrupts.
*
*   SEE ALSO
*	timer.device/TR_GETSYSTIME,
*	timer.device/GetSysTime(),
*
*   BUGS
*
**********************************************************************
*****i* timer.device/internal/SetSysTimeIO ***************************
*
*   NAME
*	SetSysTimeIO -- Set the system time.
*
*   SYNOPSIS
*	SetSysTimeIO( IORequest )
*	              A1
*
*	void SetSysTimeIO( struct timerequest * );
*
*   FUNCTION
*	This routine sets the system time.  Be careful of setting the
*	time backwards!
*
*   INPUTS
*	IOTimeRequest -- an IOTV request block for the timer
*
*   RESULTS
*
*   NOTES
*	This function may be called from interrupts.
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*	A6 -- TDDev (given)
*	A1 -- request (given)
*	A0 -- time field of request
*

SetSysTimeIO:
*$* debug
*		ERRMSG	"SetSysTimeIO"
*$* debug
		movem.l	a1-a2,-(sp)
		lea	IOTV_TIME(a1),a0	; find time field
		jsr	Req2STfmt(a6)		; convert
		jsr	AdjSTfmt(a6)		; adjust

		TD_DISABLE	a2,TD_SYSLIB(a6)
		move.l	TV_SECS(a0),TD_SYSTIME+TV_SECS(a6)
		move.l	TV_MICRO(a0),TD_SYSTIME+TV_MICRO(a6)
		TD_ENABLE	a2,TD_SYSLIB(a6)

		movem.l	(sp)+,a1-a2

		bra	TermIOC			; reply
		; RFT


**********************************************************************
*
* mode specific systime field adjust
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*	A6 -- TDDev (given)
*	A0 -- time field of request (given)
*

AdjSTEClock:
		movem.l	a0,-(sp)
		subq.l	#EV_SIZE,sp
		move.l	sp,a0
		bsr	ReadEClockTime		; get E time
		move.l	EV_LO(a0),d0		; lo nibble
		addq.l	#EV_SIZE,sp
		movem.l	(sp)+,a0

		swap	d0			; zero hi nibble
		move.w	#0,d0
		swap	d0

		move.l	TV_MICRO(a0),d1		; adjust systime base
		move.l	#0,TV_MICRO(a0)		;  against E time
		sub.l	d0,d1
		bcc.s	NoAdj

		move.l	TV_SECS(a0),d0
		subq.l	#1,d0
		bcs.s	Unset			; setting time to 0

		move.l	d0,TV_SECS(a0)
		add.l	TD_ECLOCKHERTZ(a6),d1
NoAdj:
		move.l	d1,TV_MICRO(a0)
Unset:
		rts

		
**********************************************************************
*
* mode specific systime field adjust
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*	A6 -- TDDev (given)
*	A0 -- time field of request (given)
*

AdjSTTOD:
		movem.l	a0/a6,-(sp)
		move.l	a6,a1
		bsr	TOD_Int			; clears TOD int and counter
		movem.l	(sp)+,a0/a6
		rts


**********************************************************************
*
* timerequest to mode specific systime conversion
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*	A6 -- TDDev (given)
*	A0 -- time field of request (given)
*

Req2STEClock:
		; this one returns secs/etics
		move.l	TV_MICRO(a0),d0		
		move.l	TD_ECLOCKCONST1(a6),d1
		bsr	Mult64			; convert usecs to etics
		move.w	d0,d1
		swap	d1			; Etics
		move.l	d1,TV_MICRO(a0)
		rts


**********************************************************************
*
* timerequest to mode specific systime conversion
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*	A6 -- TDDev (given)
*	A0 -- time field of request (given)
*

Req2STTOD:
		; this on returns secs/TOD-tics
		move.l	TV_MICRO(a0),d1
		divu.w	TD_TIMEPERTOD(a6),d1	; usecs to TOD-tics
		move.l	d1,d0
		ext.l	d1		; whole tics in d1

		swap	d0		; this block is the ceiling function
		neg.w	d0
		neg.w	d0		; X set if non-zero
		clr.l	d0		; X not affected
		addx.l	d0,d1		; add X to tics
		move.l	d1,TV_MICRO(a0)
		rts


******* timer.device/TR_GETSYSTIME ***********************************
*
*   NAME
*	TR_GETSYSTIME -- get the system time.
*
*   FUNCTION
*	Ask the system what time it is.  The system time starts off at
*	zero at power on, but may be initialized via the TR_SETSYSTIME
*	call.
*
*	System time is monotonically increasing, and guaranteed to be
*	unique (except when the system time is set backwards).
*
*   TIMER REQUEST
*	io_Message      mn_ReplyPort initialized
*	io_Device       preset by timer in OpenDevice
*	io_Unit         preset by timer in OpenDevice
*	io_Command      TR_GETSYSTIME
*	io_Flags        IOF_QUICK permitted
*
*   RESULTS
*	tr_time         a timeval structure with the current system
*	                    time
*
*   NOTES
*	This function may be called from interrupts.
*
*   SEE ALSO
*	timer.device/TR_SETSYSTIME,
*	timer.device/GetSysTime(),
*
*   BUGS
*
**********************************************************************
*****i* timer.device/internal/GetSysTimeIO ***************************
*
*   NAME
*	GetSysTimeIO -- Get the current system time.
*
*   SYNOPSIS
*	GetSysTimeIO( IOTimeRequest )
*	              A1
*
*	void GetSysTimeIO( struct timerequest * );
*
*   FUNCTION
*	This routine puts the current system time into the timeval
*	structure of the request.  This time is guaranteed to be
*	larger than the last time GetSysTime was called (e.g. it
*	is monotonically increasing).  In addition, the time is
*	updated every vertical blank, so time is discontinuous --
*	it will take large jumps every vertical blank.
*
*   INPUTS
*	IOTimeRequest -- an IOTV request block for the timer
*
*   RESULTS
*
*   NOTES
*	This function may be called from interrupts.
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*

GetSysTimeIO:
*$* debug
*		ERRMSG	"GetSysTimeIO"
*$* debug
		move.l	a1,-(sp)
		lea	IOTV_TIME(a1),a0	; find time field
		bsr	GetSysTime		; do it
		move.l	(sp)+,a1

		;------ and send it back to him
		bra	TermIO			; reply the request
		; RFT


	END
@


36.23
log
@*** empty log message ***
@
text
@d15 1
a15 1
* $Id: device.asm,v 36.22 91/01/25 15:45:56 rsbx Exp Locker: darren $
d17 1
a17 1
* $Locker: darren $
d20 6
d265 1
a265 1
******* timer.device/AbortIO() ***************************************
@


36.22
log
@Change to V37
@
text
@d15 1
a15 1
* $Id$
d17 1
a17 1
* $Locker: rsbx $
d20 3
@


36.21
log
@Added kludge to zero the timeval of the timerequest before returning it,
since most of the developers that used the timer.device can't read.
@
text
@d15 1
a15 1
* $Header: /usr/professor/rsbx/timer.device/RCS/device.asm,v 36.20 90/04/01 19:12:34 rsbx Exp Locker: rsbx $
d20 4
@


36.20
log
@RCS version change.
@
text
@d15 1
a15 1
* $Header: /usr/professor/rsbx/timer.device/RCS/device.asm,v 36.19 90/02/16 11:55:51 rsbx Exp Locker: rsbx $
d20 3
d143 1
a143 1
*	tr_time         will contain junk
d147 3
@


36.19
log
@Changes to improve MIDI performance.
@
text
@d15 1
a15 1
* $Header: device.asm,v 36.18 89/11/23 16:49:43 rsbx Exp $
d20 3
@


36.18
log
@Cleaned up some graphics kludges. Removed references to TR_WAITUNTIL and
WaitUnitl() from to docs.
@
text
@d15 1
a15 1
* $Header: device.asm,v 36.17 89/09/15 18:55:01 rsbx Exp $
d20 4
d487 1
a487 3
		movem.l	a1,-(sp)
		TD_DISABLE	a0,TD_SYSLIB(a6)

d491 2
d495 1
d497 1
a497 2
		TD_ENABLE	A0,TD_SYSLIB(a6)
		movem.l	(sp)+,a1
@


36.17
log
@
@
text
@d15 1
a15 1
* $Header: device.asm,v 36.9 89/08/13 18:37:26 rsbx Exp $
d17 1
a17 1
* $Locker:  $
d20 3
a138 1
*	timer.device/TR_WAITUNTIL,
a140 1
*	timer.device/WaitUntil()
a435 1
*	timer.device/TR_WAITUNTIL,
a436 1
*	timer.device/WaitUntil()
a640 1
*	timer.device/TR_WAITUNTIL,
a641 1
*	timer.device/WaitUntil()
@


36.16
log
@
@
text
@d178 1
a178 1
*	A3 -- unit list
d193 1
a193 1
		move.l	(a3),a3			; get list
d217 2
a218 2
		move.l	a3,a0
		move.l	(a3),d0
d220 4
a223 4
		move.l	a0,a2
		move.l	d0,a0
		move.l	LN_SUCC(a0),d0
		beq.s	DoInsert
d225 1
a225 2
		bcs.s	ILoop
		beq.s	ILoop
d253 1
a253 1
*	the context of the requester.
d291 2
a292 2
		move.l	(a0),a0			; get unit list
		move.l	(a0),d0
d295 5
a299 5
		move.l	d0,a0
		move.l	(a0),d0
		beq.s	RemTimer_NotFound
		cmpa.l	a0,a1
		bne.s	RemTimer_Loop
d309 1
a309 1
		move.l	(a3),a3			; get unit list
d317 1
a317 1
		bsr	TermIOC
d319 1
a319 1
		clr.l	d0
d327 1
a327 1
		moveq.l	#-1,D0
d335 1
a335 1
*	A6 -- Device Data
d343 1
a343 1
		move.l	a0,a2
d347 1
a347 1
		cmpa.l	LH_TAIL+LN_PRED(a3),a3
d350 1
a350 1
		move.l	(a3),a1
d352 1
a352 1
		bcs.s	ICDone
d355 2
a356 2
		REMHEAD
		move.l	d0,a1
d358 2
a359 2
		ADDTAIL
		bra.s	ICLoop
d371 1
a371 1
*	A6 -- Device Data
d381 1
a381 1
		lea	TD_TERMIOQ(a6),a0
d383 1
a383 1
		REMHEAD
d385 2
d388 2
a389 4
		tst.l	d0
		beq.s	PIODone
		bsr	TermIOC
		bra.s	PIOLoop
d398 1
a398 1
		moveq.l	#0,d0
d475 3
d484 1
d487 3
a489 3
		lea	IOTV_TIME(a1),a0
		jsr	Req2STfmt(a6)
		jsr	AdjSTfmt(a6)
d494 1
d496 1
a496 1
		bra	TermIOC
d500 12
d513 1
a513 1
		movem.l	a0/a1,-(sp)
d516 2
a517 2
		bsr	ReadEClockTime
		move.l	EV_LO(a0),d0
d519 1
a519 1
		movem.l	(sp)+,a0/a1
d521 1
a521 1
		swap	d0
d525 2
a526 2
		move.l	TV_MICRO(a0),d1
		move.l	#0,TV_MICRO(a0)
d532 1
a532 1
		bcs.s	Unset
d542 12
d555 1
a555 1
		movem.l	a0/a1/a6,-(sp)
d557 2
a558 2
		bsr	TOD_Int
		movem.l	(sp)+,a0/a1/a6
d562 12
d576 1
a576 1
		move.l	TV_MICRO(a0),d0
d578 1
a578 1
		bsr	Mult64
d585 12
d598 1
d600 1
a600 1
		divu.w	TD_TIMEPERTOD(a6),d1
d693 2
a694 2
		lea	IOTV_TIME(a1),a0
		bsr	GetSysTime
d698 1
a698 1
		bra	TermIO
@


36.15
log
@TR_WAITUNTIL became UNIT_WAITUNTIL.
@
text
@d75 1
d97 4
a481 6
		move.l	IOTV_TIME+TV_MICRO(a1),d0
		move.l	TD_ECLOCKCONST1(a6),d1
		bsr	Mult64
		move.w	d0,d1
		swap	d1			; Etics

d484 14
a499 1
		movem.l	d1/a1,-(sp)
a500 4
		movem.l	(sp)+,d1/a1

		move.l	IOTV_TIME+TV_SECS(a1),TD_SYSTIME+TV_SECS(a6)
		move.l	#0,TD_SYSTIME+TV_MICRO(a6)
d503 1
d506 1
a506 1
		moveq.l	#0,d0
d509 2
d512 3
a514 2
		bcc.s	NoFix
		move.l	TD_SYSTIME+TV_SECS(a6),d0
d518 1
a518 1
		move.l	d0,TD_SYSTIME+TV_SECS(a6)
d520 2
a521 2
NoFix:
		move.l	d1,TD_SYSTIME+TV_MICRO(a6)
d523 1
a523 1
		TD_ENABLE	A0,TD_SYSLIB(a6)
d525 33
a557 2
		bra	TermIOC
		; RFT
@


36.14
log
@More Autodoc changes.
@
text
@a95 1
	XDEF	WaitUntilIO
a603 98



******* timer.device/TR_WAITUNTIL ************************************
*
*   NAME
*	TR_WAITUNTIL -- Wait until a specified system time. (V36)
*
*   FUNCTION
*	Requests that the timer reply the request when the system
*	time is greater than or equal the time in the tr_time field
*	of the IORequest.
*
*	The request may be forced to finish early with an
*	AbortIO()/WaitIO() pair.
*
*   TIMER REQUEST
*	io_Message      mn_ReplyPort initialized
*	io_Device       preset by timer in OpenDevice
*	io_Unit         preset by timer in OpenDevice
*	io_Command      TR_WAITUNTIL
*	io_Flags        IOF_QUICK permitted
*	tr_time         a timeval structure with the system time
*	                    when the timerequest should be replyed.
*
*   RESULTS
*	tr_time         will contain junk. (I mean this! Don't
*	                    depend on anything useful being
*	                    returned here or your code will
*	                    break! YOU HAVE BEEN WARNED!)
*
*   NOTES
*	This function may be called from interrupts.
*
*   SEE ALSO
*	timer.device/TR_ADDREQUEST,
*	timer.device/TR_GETSYSTIME,
*	timer.device/TR_SETSYSTIME,
*	timer.device/AbortIO(),
*	timer.device/GetSysTime(),
*	timer.device/TimeDelay(),
*	timer.device/WaitUntil()
*
*   BUGS
*
**********************************************************************
*****i* timer.device/internal/WaitUntilIO ****************************
*
*   NAME
*	WaitUntilIO -- Wait until a specified system time.
*
*   SYNOPSIS
*	WaitUntilIO( IORequest )
*	             A1
*
*	void WaitUntilIO( struct timerequest * );
*
*   FUNCTION
*	Requests that the timer reply the request when the system
*	time is greater than or equal the time in the tr_time field
*	of the IORequest.
*
*   INPUTS
*	IOTimeRequest -- an IOTV request block for the timer
*
*   RESULTS
*
*   NOTES
*	This function may be called from interrupts.
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*

WaitUntilIO:
*$* debug
*		ERRMSG	"WaitUntilIO"
*$* debug
		move.l	IOTV_TIME+TV_MICRO(a1),d0
		move.l	TD_ECLOCKCONST1(a6),d1
		bsr	Mult64
		move.w	d0,d1
		swap	d1			; Etics

		move.l	d1,IOTV_TIME+TV_MICRO(a1)

		lea	TD_SYSTIMELIST(a6),a3
		bra	InsertReq
		; rft

@


36.13
log
@Added (V36) to TR_WAITUNTIL.
@
text
@d104 1
a104 1
******* timer.device/command/TR_ADDREQUEST ***************************
d132 4
a135 4
*	timer.device/command/TR_WAITUNTIL,
*	timer.device/function/AbortIO,
*	timer.device/function/TimeDelay,
*	timer.device/function/WaitUntil
d235 1
a235 1
******* timer.device/function/AbortIO ********************************
d264 1
d403 1
a403 1
******* timer.device/command/TR_SETSYSTIME ***************************
d431 4
a434 2
*	timer.device/command/TR_GETSYSTIME,
*	timer.device/function/GetSysTime
d518 1
a518 1
******* timer.device/command/TR_GETSYSTIME ***************************
d546 4
a549 2
*	timer.device/command/TR_SETSYSTIME,
*	timer.device/function/GetSysTime
d608 1
a608 1
******* timer.device/command/TR_WAITUNTIL ****************************
d640 7
a646 7
*	timer.device/command/TR_ADDREQUEST,
*	timer.device/command/TR_GETSYSTIME,
*	timer.device/command/TR_SETSYSTIME,
*	timer.device/function/AbortIO,
*	timer.device/function/TimeDelay,
*	timer.device/function/GetSysTime,
*	timer.device/function/WaitUntil
@


36.12
log
@Made Autodoc comments conform to Autodoc style guide.
@
text
@d606 1
a606 1
*	TR_WAITUNTIL -- Wait until a specified system time.
@


36.11
log
@Added WaitUntil command.
@
text
@d37 1
a37 1
*------ Included Files ***********************************************
d54 1
a54 1
*------ Imported Names ***********************************************
d85 1
a85 1
*------ Exported Names ***********************************************
d100 1
a100 1
*------ Local Definitions ********************************************
d104 1
a104 1
******* timer.device/TR_ADDREQUEST ***********************************
d107 1
a107 1
*	TR_ADDREQUEST -- submit a request to wait a period of time
d117 7
a123 7
*	io_Message	mn_ReplyPort initialized
*	io_Device	preset by timer in OpenDevice
*	io_Unit		preset by timer in OpenDevice
*	io_Command	TR_ADDREQUEST
*	io_Flags	IOF_QUICK permitted (but ignored)
*	tr_time		a timeval structure specifying how long the 
*				device will wait before replying
d126 1
a126 1
*	tr_time		will contain junk
d128 11
d140 1
a140 1
***i*** timer.device/TR_ADDREQUEST ***********************************
d143 1
a143 1
*	TR_ADDREQUEST - add a new timer request
d146 2
a147 2
*	NewTimer( IOBlock ), TDLib
*	          A1	     A6
d149 2
d158 1
a158 1
*   EXCEPTIONS
d160 3
d235 1
a235 1
******* timer.device/AbortIO *****************************************
d238 1
a238 1
*	AbortIO -- remove an existing timer request
d244 2
d257 1
a257 1
*		IOERR_ABORTED.
d260 2
a261 1
*   EXCEPTIONS
a267 1
***i*** timer.device/AbortIO *****************************************
a268 26
*   NAME
*	AbortIO - remove an existing timer request
*
*   SYNOPSIS
*	error = AbortIO( IOBlock ), TDLib
*	D0               A1         A6
*
*   FUNCTION
*	This routine removes an IO request from the timer.  It runs in
*	the context of the requester.
*
*   INPUTS
*	IOBlock - the command block for this IO operation.
*
*   RETURNS
*	0  if the request was found on the timer's queue
*	-1 otherwise
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
d402 1
a402 1
******* timer.device/TR_SETSYSTIME ***********************************
d405 1
a405 1
*	TR_SETSYSTIME -- set the system time
d415 7
a421 7
*	io_Message	mn_ReplyPort initialized
*	io_Device	preset by timer in OpenDevice
*	io_Unit		preset by timer in OpenDevice
*	io_Command	TR_GETSYSTIME
*	io_Flags	IOF_QUICK permitted
*	tr_time		a timeval structure with the current system
*				time
d424 1
a424 1
*	tr_time		will contain junk
d426 9
d436 1
a436 1
***i*** System/Drivers/Timer/SetSysTime ******************************
d439 1
a439 1
*	SetSysTime - set the system time
d442 2
a443 2
*	SetSysTime( IORequest ), timerDevice
*	            A1	         A6
d445 2
d456 2
a457 1
*   EXCEPTIONS
d515 1
a515 1
******* timer.device/TR_GETSYSTIME ***********************************
d518 1
a518 1
*	TR_GETSYSTIME -- get the system time
d529 5
a533 5
*	io_Message	mn_ReplyPort initialized
*	io_Device	preset by timer in OpenDevice
*	io_Unit		preset by timer in OpenDevice
*	io_Command	TR_GETSYSTIME
*	io_Flags	IOF_QUICK permitted
d536 2
a537 2
*	tr_time		a timeval structure with the current system
*				time
d539 9
d549 1
a549 1
***i*** System/Drivers/Timer/GetSysTime ******************************
d552 1
a552 1
*	GetSysTimeIO -- Get the current system time
d555 2
a556 2
*	GetSysTimeIO( IOTimeRequest ), timerDevice
*	              A1	       A6
d558 2
d573 2
a574 1
*   EXCEPTIONS
d603 1
a603 1
******* timer.device/TR_WAITUNTIL ************************************
d606 1
a606 1
*	TR_WAITUNTIL -- wait until a specified system time
d617 7
a623 8
*	io_Message	mn_ReplyPort initialized
*	io_Device	preset by timer in OpenDevice
*	io_Unit		preset by timer in OpenDevice
*	io_Command	TR_WAITUNTIL
*	io_Flags	IOF_QUICK permitted
*	tr_time		a timeval structure with the system time
*				when the timerequest should be
*				replyed.
d626 4
a629 4
*	tr_time		will contain junk. (I mean this! Don't
*				depend on anything useful being
*				returned here or your code will
*				break! YOU HAVE BEEN WARNED!)
d631 14
d646 1
a646 1
***i*** System/Drivers/Timer/WaitUntil *******************************
d649 1
a649 1
*	WaitUntil -- wait until a specified system time
d652 2
a653 2
*	WaitUntil( IORequest ), timerDevice
*	           A1	        A6
d655 2
d667 2
a668 1
*   EXCEPTIONS
@


36.10
log
@Broke up GetSysTime to support library entry point for it. rearranged
unit structure. Cleanup.
@
text
@d96 1
d110 2
a111 5
*	Set the system idea of what time it is.  The system starts out
*	at time "zero" so it is safe to set it forward to the real
*	time.  However, care should be taken when setting the time
*	backwards.  System time is generally expected to monotonically
*	increasing.
d113 3
d432 1
a432 1
*	none
d585 80
@


36.9
log
@Fixed up comment blocks for autodoc.
@
text
@d15 1
a15 1
* $Header: device.asm,v 36.8 89/08/09 19:13:08 rsbx Exp $
d17 1
a17 1
* $Locker: rsbx $
d20 3
d37 1
a37 1
***#*** Included Files ***********************************************
d54 1
a54 1
***#*** Imported Names ***********************************************
a71 6
	XREF	ReadTOD
	XREF	Tics2Time
	XREF	Micro2Tics
	XREF	AbortMicroTimer
	XREF	RethinkMicroTimer
	XREF	TOD_Int
d74 1
d85 1
a85 1
***#*** Exported Names ***********************************************
d91 2
a92 2
	XDEF	GetSysTime
	XDEF	SetSysTime
d99 1
a99 1
***#*** Local Definitions ********************************************
d128 1
a128 1
**i**** timer.device/TR_ADDREQUEST ***********************************
d157 1
a157 1
*	A3 -- unit data pointer
d172 1
d183 1
a183 1
*	A3 -- list head (given)
d248 1
a248 1
**i**** timer.device/AbortIO *****************************************
d281 1
a281 1
*	A3 -- unit data pointer
d294 1
d312 1
d339 1
a339 1
*	A3 -- request list head (given)
a374 1
*	A3 -- unit data
d434 1
a434 1
**i**** System/Drivers/Timer/SetSysTime ******************************
d466 1
a466 1
SetSysTime:
d468 1
a468 1
*		ERRMSG	"SetSysTime"
d535 1
a535 1
**i**** System/Drivers/Timer/GetSysTime ******************************
d538 1
a538 1
*	GetSysTime - Get the current system time
d541 2
a542 2
*	GetSysTime( IOTimeRequest ), timerDevice
*	            A1	         A6
d571 1
a571 1
GetSysTime:
d573 1
a573 1
*		ERRMSG	"GetSysTime"
a574 4
		TD_DISABLE	a0,TD_SYSLIB(a6)

		subq.l	#EV_SIZE,sp
		move.l	sp,a0
d576 2
a577 1
		bsr	ReadEClockTime
a579 25
		move.l	TD_SYSTIME+TV_SECS(a6),IOTV_TIME+TV_SECS(a1)
		move.l	TD_SYSTIME+TV_MICRO(a6),d0
		move.l	EV_LO(a0),d1

		TD_ENABLE	A0,TD_SYSLIB(a6)

		addq.l	#EV_SIZE,sp
		swap	d1
		moveq.l	#0,d1
		swap	d1
		add.l	d1,d0

		cmp.l	TD_ECLOCKHERTZ(a6),d0
		bcs.s	NoAdjust
		addq.l	#1,IOTV_TIME+TV_SECS(a1)
		sub.l	TD_ECLOCKHERTZ(a6),d0

NoAdjust:
		move.l	TD_ECLOCKCONST2(a6),d1
		bsr	Mult64
		move.w	d0,d1
		swap	d1			; micros

		move.l	d1,IOTV_TIME+TV_MICRO(a1)

a580 1

@


36.8
log
@changedsome comments for the benefit of autodoc
@
text
@d15 1
a15 1
* $Header: device.asm,v 36.7 89/08/09 18:09:24 rsbx Exp $
d20 3
d108 25
d219 1
a219 1
******* timer.device/AbortIO ********************************
d222 30
d409 1
a409 1
******* System/Drivers/Timer/SetSysTime ******************************
d412 25
d510 26
a535 1
******* System/Drivers/Timer/GetSysTime ******************************
@


36.7
log
@*** empty log message ***
@
text
@d15 1
a15 1
* $Header: /usr.MC68010/machines/professor/professor/rsbx/timer.device/RCS/device.asm,v 36.5 89/08/09 14:05:50 rsbx Exp $
d17 1
a17 1
* $Locker:  $
d20 3
d31 1
a31 1
******* Included Files ***********************************************
d48 1
a48 1
******* Imported Names ***********************************************
d84 1
a84 1
******* Exported Names ***********************************************
d98 1
a98 1
******* Local Definitions ********************************************
d102 1
a102 1
;****** timer.device/TR_ADDREQUEST ***********************************
@


36.6
log
@*** empty log message ***
@
text
@d15 1
a15 1
* $Header: /usr.MC68010/ghostwheel/commodore/amiga/V36/src/kickstart/timer/RCS/device.asm,v 36.5 89/08/09 14:05:50 rsbx Exp $
@


36.5
log
@Rewritten for the new timer.device
@
text
@d15 1
a15 1
* $Header$
d17 1
a17 1
* $Locker$
d19 4
a22 1
* $Log$
@


36.4
log
@Fixed up autodocs
@
text
@a0 1

d15 1
a15 1
* $Header: device.asm,v 36.3 88/09/19 09:44:01 neil Exp $
d17 1
a17 1
* $Locker: eric $
d19 1
a19 7
* $Log:	device.asm,v $
* Revision 36.3  88/09/19  09:44:01  neil
* fixed some autodoc stuff.  The autodocs still need LOTS of work.
* 
* Revision 36.2  88/09/19  09:37:17  neil
* fixed Delay(0) bug
* 
a20 32
* Revision 33.2  86/03/31  01:12:53  neil
* major changes in the interest of speed.
* 
* Revision 33.1  86/03/29  20:23:04  neil
* now compute waiting time exactly (no more 5% variation)
* 
* Revision 32.1  86/01/15  22:25:49  neil
* PAL and 50hz power supply integration
* 
* Revision 31.2  85/11/04  10:06:27  neil
* new system time (via 8520) scheme
* 
* Revision 31.1  85/10/13  11:26:02  neil
* retrieved fixes from V28.  They got lost in the shuffle.
* 
* 	Neil
* 
* Revision 27.3  85/08/10  15:24:07  carl
* Decreased time spent while disabled during timer interrupt
* processing by queuing completed requests and handling them
* when not disabled.
* 
* Revision 27.2  85/07/19  08:08:24  neil
* Added TimCmp routine
* 
* Revision 27.1  85/06/24  13:31:57  neil
* Upgrade to V27
* 
* Revision 26.1  85/06/17  14:56:01  neil
* *** empty log message ***
* 
* 
d25 1
a25 1
****** Included Files ************************************************
d29 1
a31 8
	INCLUDE	'exec/lists.i'
	INCLUDE	'exec/nodes.i'
	INCLUDE	'exec/ports.i'
	INCLUDE	'exec/libraries.i'
	INCLUDE	'exec/devices.i'
	INCLUDE	'exec/io.i'
	INCLUDE	'exec/strings.i'
	INCLUDE	'exec/tasks.i'
a32 3
	INCLUDE	'exec/initializers.i'
	INCLUDE	'exec/interrupts.i'
	INCLUDE	'exec/execbase.i'
a33 1
	INCLUDE	'exec/alerts.i'
d37 2
d40 1
a40 1
	INCLUDE 'messages.i'
d42 1
a42 1
****** Imported Names ************************************************
d49 1
d51 2
a52 1
	XREF	timerName
d59 9
a67 2
	XREF	ClearTOD
	XREF	ReadSysTime
a70 4
XSYS	MACRO
	XREF	_LVO\1
	ENDM

d75 2
d78 1
a78 1
****** Exported Names ************************************************
a81 2
*------ Data ---------------------------------------------------------

d84 5
a88 11
	XDEF	Tick0
	XDEF	Tick1
	XDEF	TickCommon
	XDEF	SubList
	XDEF	StartUnit0
	XDEF	StartUnit1
	XDEF	StopUnit0
	XDEF	StopUnit1
	XDEF	TimSub
	XDEF	TimAdd
	XDEF	TimCmp
d90 1
a90 1
****** Local Definitions *********************************************
d92 1
a92 4
*
* set Chips_6526 to non-zero if you want a timer for the 6526 chips
*
Chips_6526	EQU	0
d96 1
a96 62
LINKSYS		MACRO	* &func
		LINKLIB _LVO\1,TD_SYSLIB(A6)
		ENDM

*		;------ compare two timevec structures.  End result
*		;------ should set condition codes like Ay-Ax
TIMCMP		MACRO	Ax,Ay,Dscratch
		MOVE.L	(\2),\3		; implicit TV_SECS
		CMP.L	(\1),\3		; implicit TV_SECS
		BNE.S	\@@end
		MOVE.L	TV_MICRO(\2),\3
		CMP.L	TV_MICRO(\1),\3
\@@end
		ENDM

LTIMCMP		MACRO	Ax,Ay,Dscratch,Xoffset,Yoffset
XOFFSET		SET	\4
YOFFSET		SET	\5
		MOVE.L	YOFFSET+TV_SECS(\2),\3
		CMP.L	XOFFSET+TV_SECS(\1),\3
		BNE.S	\@@end
		MOVE.L	YOFFSET+TV_MICRO(\2),\3
		CMP.L	XOFFSET+TV_MICRO(\1),\3
\@@end
		ENDM

*		;------ copy timvec Ax into Ay
TIMCPY		MACRO	Ax,Ay,Xoffset,Yoffset
		IFGE	NARG-3
XOFFSET		SET	\3
YOFFSET		SET	\4
		ENDC
		IFLT	NARG-3
XOFFSET		SET	0
YOFFSET		SET	0
		ENDC
		MOVE.L	XOFFSET+TV_SECS(\1),YOFFSET+TV_SECS(\2)
		MOVE.L	XOFFSET+TV_MICRO(\1),YOFFSET+TV_MICRO(\2)
		ENDM

DOUNIT		MACRO	func,scratch
		MOVE.L	TU_\1(A3),\2
		JSR	(\2)
		ENDM

LOCK		MACRO	scratch
		DISABLE	\1
		ENDM

UNLOCK		MACRO	scratch
		ENABLE	\1
		ENDM


INFOLEVEL	EQU	50

MAXMICRO	EQU	1000000
MIN6526		EQU	60
MAX6526		EQU	$FFFF


******* timer.device/TR_ADDREQUEST ********************************
d99 1
a99 1
*	TR_ADDREQUEST - submit a new request to the timer
d101 4
d106 2
a107 3
*	Ask the timer to count off a specified amount of time.  The timer
*	will chain this request with its other requests, and will reply the
*	message back to the user when the timer counts down to zero.
d109 2
a110 2
*	The message may be forced to finish early with an AbortIO()/WaitIO()
*	pair.
d112 1
a112 5
*   TIMER REQUEST
*	io_Command	TR_ADDREQUEST
*	io_Flags	IOF_QUICK allowable
*	tr_time		a timeval structure specifying how long
*			    until the driver will reply
a113 3
*    RESULTS
*	tr_time		will contain junk
*
a114 2
*	exec/AbortIO
*	exec/WaitIO
d116 2
a120 8
*	The timer has been moderately optimized.  It has several
*	"fast paths" through it -- specifically if you are inserting
*	before the first element in the list.  Things get a little
*	complicated because of the micro-hertz timer.  The "current"
*	time indicated on the first element may be much larger than
*	the actual time (because we only update it during a tick).
*	It this element is less than the first, we first stop the
*	timer to get a current picture of the time remaining.
a122 1
*
d124 5
a128 6
*	A6 -- TDDev
*	A5 -- user's io request (new)
*	A4 -- current timer request (current)
*	A3 -- unit data
*	A2 -- previous timer request (previous)
*
a129 2
MINTIME	EQU	10		; requests for less than this will be ignored

d131 4
d136 1
a136 1
		BCLR	#IOB_QUICK,IO_FLAGS(A1)
d138 3
a140 6
		;------ Horrible kludge alert: tiny time requests break
		;------ the microhertz timer for reasons (as yet) unknown.
		TST.L	IOTV_TIME+TV_SECS(A1)
		BNE.S	NewTimer_Lock
		CMP.L	#MINTIME,IOTV_TIME+TV_MICRO(A1)
		BHS.S	NewTimer_Lock
d142 2
a143 4
		;------ we are sleeping for less than MINTIME microsecs
		MOVE.L	TD_SYSLIB(A6),A6
		CALLSYS	ReplyMsg
		RTS
a144 2
NewTimer_Lock:
		MOVE.L	A3,-(SP)
d146 9
a154 1
		LOCK	A0
a155 1
		MOVE.L	IO_UNIT(A1),A3
d157 5
a161 3
		;------ quicker IFNOTEMPTY A3,NewTimer_First
		CMPA.L	LH_TAILPRED(A3),A3
		BNE.S	NewTimer_First
d163 15
a177 2
*		;------ insert at beginning -- special case for fastest path
NewTimer_QuickInsert:
d179 1
a179 6
		;------ quicker ADDHEAD	A3,A1
		MOVE.L	(A3),D0
		MOVE.L	A1,(A3)
		MOVEM.L	D0/A3,(A1)
		MOVE.L	D0,A0
		MOVE.L	A1,4(A0)
d181 1
a181 1
		DOUNIT	START,A0
a182 1
		BRA	NewTimer_End
a183 2
NewTimer_First:
		MOVEM.L	A2/A4/A5,-(SP)
d185 1
a185 84
		CLRA.L	A2			; set previous = 0
		MOVE.L	A1,A5

		MOVE.L	(A3),A4			; get current (LH_HEAD)

*		;------ see if user request has less time than current request
		LTIMCMP	A5,A4,D0,IOTV_TIME,IOTV_TIME
		BLS	NewTimer_SubFirst

		;------ this is the first one.  stop the timer and retry.
		DOUNIT	STOP,A0

		LTIMCMP	A5,A4,D0,IOTV_TIME,IOTV_TIME
		BLS	NewTimer_Restart

		LEA	IOTV_TIME(A4),A0	; current's time
		LEA	IOTV_TIME(A5),A1	; new's time
		BSR	TimSub

		;------ quicker ADDHEAD	A3,A5
		MOVE.L	(A3),D0
		MOVE.L	A5,(A3)
		MOVEM.L	D0/A3,(A5)
		MOVE.L	D0,A0
		MOVE.L	A5,4(A0)

		DOUNIT	START,A0

		BRA.S	NewTimer_RestoreRegs

NewTimer_Restart:
		;------ the new one was not less than current.  Restart.
		DOUNIT	START,A0

NewTimer_SubFirst:
		LEA	IOTV_TIME(A4),A1	; current's time
		LEA	IOTV_TIME(A5),A0	; new's time
		BSR	TimSub

NewTimer_Advance:
		MOVE.L	A4,A2			; previous = current
		MOVE.L	(A2),A4			; current = previous->next
		TST.L	(A4)			; end of list?
		BEQ.S	NewTimer_Insert

		;------ see if the new's remaining time is less than current's
		LEA	IOTV_TIME(A4),A1	; current's time
		LEA	IOTV_TIME(A5),A0	; new's time
		TIMCMP	A0,A1,D0
		BLS	NewTimer_NotYet

		;------ finally time.  Subtract new's time from current
		EXG	A0,A1
		BSR	TimSub
		BRA.S	NewTimer_Insert



NewTimer_NotYet:
*		;------ new has MORE time than current.  Subtract current's
*		;------ time from new's, then advance to the next time link

		BSR	TimSub			; tr.time -= newtr.time
		BRA.S	NewTimer_Advance

NewTimer_Insert:
		MOVE.L	A3,A0
		MOVE.L	A5,A1
		LINKSYS	Insert (list, node, previous)



NewTimer_RestoreRegs:
		MOVEM.L	(SP)+,A2/A4/A5

NewTimer_End:
		UNLOCK	A0

		MOVE.L	(SP)+,A3

		RTS


******p timer.device/AbortIO ********************************
d191 2
a192 2
*	AbortIO( IOBlock ), TDLib
*	         A1	    A6
d217 5
a221 4
*	A6 -- TDDev
*	A3 -- unit data
*	A2 -- timer request (tr)
*
d224 4
a227 1
		MOVEM.L	A2/A3,-(SP)
a228 4
		LOCK	A0

		MOVE.L	A1,A2

d230 2
a231 2
		MOVE.L	IO_UNIT(A2),A3
		MOVE.L	(A3),A0
d233 6
a238 4
		;------ search the list, looking for the request
RemTimer_Search:
		MOVE.L	(A0),D0
		BEQ.S	RemTimer_NotFound
a239 6
		CMP.L	A0,A2
		BEQ.S	RemTimer_Found

		MOVE.L	D0,A0
		BRA.S	RemTimer_Search

d241 4
a244 3
		;------ see if the match is at the head of the list
		CMP.L	(A3),A2
		BNE.S	RemTimer_NotHead
d246 5
a250 5
		;------ This is the first request.  stop and restart the timer
		DOUNIT	STOP,A0
		BSR.S	RemTimer_RemSub
		DOUNIT	START,A0
		BRA.S	RemTimer_Term
d252 4
a255 2
RemTimer_NotHead:
		BSR.S	RemTimer_RemSub
d257 2
a258 6
RemTimer_Term:
		MOVE.L	A2,A1
		MOVE.B	#IOERR_ABORTED,IO_ERROR(A1)
		BSR	TermIO
		CLEAR	D0
		BRA.S	RemTimer_End
a259 1

d261 5
a265 1
		MOVEQ	#-1,D0
d267 1
a267 2
RemTimer_End:
		UNLOCK	A0
a268 2
		MOVEM.L	(SP)+,A2/A3
		RTS
a269 43
RemTimer_RemSub:
		MOVE.L	(A2),A0
		MOVE.L	LN_PRED(A2),A1
		MOVE.L	A0,(A1)
		MOVE.L	A1,LN_PRED(A0)

		;------ see if there is a successor to A2
		TST.L	(A0)
		BEQ.S	RemTimer_RemEnd

		;------ transfer the time
		LEA	IOTV_TIME(A0),A0
		LEA	IOTV_TIME(A2),A1
		BSR	TimAdd

RemTimer_RemEnd:
		RTS
		


;****** System/Drivers/Timer/TickInt **********************************
*
*   NAME
*	TickInt - Handle and interrupt tick
*
*   SYNOPSIS
*	TickInt( Unit )
*	         A1
*
*   FUNCTION
*	This routine gets the tick for both the vertical blank interrupt
*	and the 6522 interrupt.  Its job is to figure out who is process
*	the interrupt
*
*   INPUTS
*	IOBlock - the command block for this IO operation.
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
a271 2
*   IMPLEMENTATION NOTES
*
d273 4
a277 4
*	A6 -- Device Pointer
*	A3 -- unit pointer
*	A2 -- new request pointer (newtr)
*
d279 3
a281 6
*
* process exec scheduling quantum stuff
*
Tick1:
		MOVEM.L	A3/A6,-(SP)
		MOVE.L	A1,A3
d283 4
a286 1
		MOVE.L	TU_DEVICE(A3),A6
d288 3
a290 1
		LOCK	A0
d292 6
a297 3
		;------ check the scheduling flags
		SUBQ.W	#1,Elapsed(A0)
		BNE.S	CheckTOD
d299 2
a300 3
		;------ kick the scheduler
		MOVE.W	Quantum(A0),Elapsed(A0)
		OR.W	#SF_TQE,SysFlags(A0)
d302 2
a303 6
CheckTOD:
		;------ see if we overflowed our tick
		LEA	_ciaa,A1
		MOVE.B	ciatodhi(A1),D0
		MOVE.B	ciatodlow(A1),D1
		TST.B	D0
a304 1
		BEQ.S	TickCommon
a305 116
		;------ we need to drain the timer
		LEA	TD_SYSTIME(A6),A0

		BSR	ReadSysTime
		BSR	ClearTOD

		BRA.S	TickCommon


Tick0:

		;------ assumption: a6 has execbase...
		LOCK	A0

		MOVEM.L	A3/A6,-(SP)
		MOVE.L	A1,A3

		MOVE.L	TU_DEVICE(A3),A6

		;------ stop timer
		BCLR	#CIACRBB_START,ciacrb+_ciaa

TickCommon:
		;------ initialize the singly linked list of term iob's
		MOVEQ	#0,D0
		MOVE.L	D0,TU_TERMIOQ(A3)

		;------ faster IFNOTEMPTY A3,Tick_NotEmpty
		CMP.L	LH_TAILPRED(A3),A3
		BNE.S	Tick_NotEmpty

		;------ special fast path for stopping
		;***DOUNIT	STOP,A0

Tick_QuickEnd:
		;------ unlock so interrupts are turned back on
		UNLOCK	A0

		;------ and wake up the waiters
		BSR	ProcessTermIO	; a3/a6 stepped on
		MOVEM.L	(SP)+,A3/A6

*		;------ leave the condition codes set correctly
		MOVEQ	#0,D0
		RTS

Tick_NotEmpty:
		LEA	TU_TICKVAL(A3),A0
		BSR	SubList

		DOUNIT	START,A0

		BRA.S	Tick_QuickEnd


QueueTermIO:
;  This function is passed as an argument to SubList.  Its purpose is to
;  queue the IORequest passed in A1 to the pending IO termination list.
;
; Neil -- changed to singly linked list

		MOVE.L	TU_TERMIOQ(A3),(A1)
		MOVE.L	A1,TU_TERMIOQ(A3)
		RTS


;  Process the TermIO queue created with the above function.
;  destroys A3 and A6

ProcessTermIO:
		MOVE.L	TU_TERMIOQ(A3),A3
		MOVE.L	TD_SYSLIB(A6),A6
ptio_Next:
		;------ is this the end of the list?
		MOVE.L	A3,D0
		BEQ.S   ptio_Exit

		;------ advance list
		MOVE.L	(A3),A3

		;------ notify the owner of this request
		MOVE.L  D0,A1
		CALLSYS	ReplyMsg

		BRA.S	ptio_Next

ptio_Exit:
		RTS


;****** System/Drivers/Timer/SubList **********************************
*
*   NAME
*	SubList - subract a value from the whole list
*
*   SYNOPSIS
*	SubList( timeVal, list )
*	         A0       A3
*
*   FUNCTION
*	This routine subtracts a timeval from the remaining time of
*	a list until the timeval is exhausted (or the end of the list
*	is found).  If the remaining time on an element of the list
*	is decremented to zero, the routine action is called with
*	the list element in A1.
*
*   INPUTS
*	timeVal - a timeval structure with the amount of time to remove
*	list - a pointer to the list to apply the timeVal to
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
a307 2
*   IMPLEMENTATION NOTES
*
d309 4
a313 1
*
d315 2
a316 4
SubList:
		;------ copy the timeval onto the stack
		MOVE.L	4(A0),-(SP)
		MOVE.L	(A0),-(SP)
d318 11
a328 4
SubList_Loop:
		MOVE.L	(A3),A0			; advance list
		TST.L	(A0)			; check for end of list
		BEQ.S	SubList_End		; nothing left in the list
d330 1
a330 4
		LEA	IOTV_TIME(A0),A0
		MOVE.L	SP,A1
		TIMCMP	A0,A1,D0
		BHS.S	SubList_Action
d332 2
a333 4
		;------ there is less time in the timeVal than in this
		;------ element in the list.  just decrement the element
		BSR	TimSub
		BRA.S	SubList_End
a334 7
SubList_Action:
		;------ this element is exhausted
		EXG	A0,A1
		BSR	TimSub
		REMHEADQ A3,A1,A0		; a1 preserved
		BSR	QueueTermIO
		BRA.S	SubList_Loop
d336 2
a337 3
SubList_End:
		ADDQ.L	#8,SP
		RTS
d339 1
a341 22
;****** System/Drivers/Timer/StartTimer ******************************
*
*   NAME
*	StartTimer - Start the timer up and running
*
*   SYNOPSIS
*	StartTimer(), UnitPtr, DevPtr
*		      A3       A6
*
*   FUNCTION
*	This routine starts a timer off and running.
*
*   INPUTS
*
*   RESULTS
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
a342 9
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*	A6 -- Device Pointer
*	A3 -- unit pointer
*	A2 -- request pointer (tr)
*
a343 1
UNIT0MAX:	EQU	91541
d345 2
a346 89
StartUnit0_Empty:
		BCLR	#CIACRBB_START,_ciaa+ciacrb
		RTS
StartUnit0:

		;------ get the head of the list
		MOVE.L	(A3),A1

		;------ protect against empty list
		TST.L	(A1)
		BEQ.S	StartUnit0_Empty


		ERRMSG	90,<'%s/StartUnit0: called'>

		;------ the max allowable # of microseconds
		MOVE.L	#UNIT0MAX,D0

		;------ get the requested time
		TST.L	IOTV_TIME+TV_SECS(A1)
		BNE.S	StartUnit0_Max
		MOVE.L	IOTV_TIME+TV_MICRO(A1),D1

		;------ Figure out if he wants more than we can give
		;---!!!	Max must be less than one second
		CMP.L	D0,D1
		BLO.S	StartUnit0_Partial

		;------ this nop is for the state analyzer, so we
		;------ can detect a full start
		NOP


StartUnit0_Max:
		MOVE.L	D0,D1

StartUnit0_Partial:

		;------ update the timeval structure
		MOVE.L	D1,TU_TICKVAL+TV_MICRO(A3)

		;------ Compute the number of phi 2 pulses needed to
		;------	represent the requested number of microseconds.
		;------	The actual constant is:
		;------	    .715909 (microsecs) = # phi 2 pulses
		;------ We use fixed point arithmetic to do this
		;------ (64K * .715909 = 46918).  The correct answer
		;------ is in the high word of the mul result.


		;------ max d1 could be is $16596.  Do lower word
		MOVE.W	D1,D0
		MULU	#46918,D0
		SWAP	D0		; get true result in low word

		;------ now compensate for upper word
		SWAP	D1
		TST.W	D1
		BEQ.S	1$

		;------ oops, we missed the most significant bit
		ADD.W	#46918,D0

1$:

	IFGE	INFOLEVEL-90
	MOVE.W	D0,-(SP)
	ERRMSG	90,<'%s/StartUnit0: loading count with 0x%x'>
	ADDQ.L	#2,SP
	ENDC

		MOVE.W	D0,TU_COUNT(A3)

		MOVE.B	D0,_ciaa+ciatblo
		LSR.L	#8,D0
		MOVE.B	D0,_ciaa+ciatbhi

StartUnit0_End:
		RTS



StartUnit1:
		;------ nothing to do...
		RTS


;****** System/Drivers/Timer/StopTimer *******************************
*
d348 1
a348 1
*	StopTimer - Stop the timer from running
d351 2
a352 2
*	StopTimer(), UnitPtr, DevPtr
*		      A3       A6
d355 2
a356 1
*	This routine stops the timer from running.
d359 1
d373 1
a375 4
*	A6 -- Device Pointer
*	A3 -- unit pointer
*	A2 -- request pointer (tr)
*
d377 9
a385 2
StopUnit0:
		LEA	_ciaa,A1
d387 1
a387 2
		;------ stop timer; see if it was already stopped
		BCLR	#CIACRBB_START,ciacrb(A1)
d389 5
a393 1
		BEQ.S	StopUnit0_End
d395 4
a398 6
		;------ look to see if any new interrupts have come in
		MOVE.W	#CIAICRF_TB,D0
		MOVE.L	A6,-(SP)
		MOVE.L	TU_RESOURCE(A3),A6
		CALLSYS	SetICR
		MOVE.L	(SP)+,A6
d400 3
a402 3
		;------ used to be: IFEMPTY	A3,StopUnit0_End
		MOVE.L	(A3),A0
		TST.L	(A0)
d404 5
a408 1
		BEQ.S	StopUnit0_End
d410 6
a415 3
		;------ see if the timer was expired
		BTST	#CIAICRB_TB,D0
		BEQ.S	StopUnit0_Partial
d417 2
a418 5
		;------ the time was all gone.  Clear the timeval
		MOVEQ	#0,D0
		MOVE.L	D0,IOTV_TIME+TV_SECS(A0)
		MOVE.L	D0,IOTV_TIME+TV_MICRO(A0)
		BRA.S	StopUnit0_End
a419 6
StopUnit0_Partial:
		;------ get the remaining time
		LEA	_ciaa,A1
		MOVE.B	ciatbhi(A1),D0
		LSL.W	#8,D0
		MOVE.B	ciatblo(A1),D0
d421 1
a421 35
		;------ D0 is less than TU_COUNT
		SUB.W	TU_COUNT(A3),D0
		NEG.W	D0
		BEQ.S	StopUnit0_End

		;------	multiply count by 1.3968256 ( == 1/.715909).
		;------ Convert to fixed point that will not overflow
		;------ 32 bits.  This comes out to 32K * 45771.
		MULU	#45771,D0

			; how about:
			;	and.w	#$8000,d0	; clear bottom 15 bits
			;	swap	d0		; get most of result
			;	rol.l	#1,d0		; get last bit of result
		LSR.L	#8,D0
		LSR.L	#7,D0

*		;------ make a temporary timeval structure
		MOVE.L	D0,-(SP)
		CLR.L	-(SP)
		MOVE.L	SP,A1

		ERRMSG	90,<'%s/StopUnit0: subtracting %ld.%06ld'>
		LEA	IOTV_TIME(A0),A0

		BSR	TimSub
		ADDQ.L	#8,SP

StopUnit0_End:
StopUnit1:

		RTS


******* timer.device/SubTime **********************************
d424 1
a424 1
*	SubTime - subtract one time request from another
d427 2
a428 2
*	SubTime( Dest, Source ), timer.device
*	         A0    A1 	 A6
a429 2
*	void SubTime(struct *timeval, struct *timeval);
*
d431 6
a436 2
*	This routine subtracts one timeval structure from another.  The
*	results are stored in the destination (Dest - Source -> Dest)
a437 2
*	A0 and A1 will be left unchanged
*
d439 1
a439 1
*	Dest, Source -- pointers to timeval structures.
d441 1
a441 1
*   EXCEPTIONS
a442 74
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*

TimSub:
	IFGE	INFOLEVEL-80
	;------ check for three errors: either micro neg, or A1 > A0
	CMP.L	#MAXMICRO,TV_MICRO(A0)
	BCC.S	timsub_err

	CMP.L	#MAXMICRO,TV_MICRO(A1)
	BCC.S	timsub_err

	TIMCMP	A0,A1,D0
	BLS.S	timsub_ok

timsub_err:
	MOVE.L	TV_MICRO(A0),-(SP)
	MOVE.L	TV_SECS(A0),-(SP)
	MOVE.L	TV_MICRO(A1),-(SP)
	MOVE.L	TV_SECS(A1),-(SP)
	MOVE.L	16(SP),-(SP)
	ERRMSG	80,<'%s/TimSub: (0x%lx) subtracting %ld.%06ld from %ld.%06ld'>
	LEA	20(SP),SP
timsub_ok:
	ENDC

		MOVEM.L	(A0),D0/D1		; TV_SECS == 0

		SUB.L	(A1),D0			; TV_SECS == 0
		SUB.L	TV_MICRO(A1),D1


TimSub_Overflow:
		BGE.S	TimSub_Assign

		SUBQ.L	#1,D0
		ADD.L	#MAXMICRO,D1
		BRA.S	TimSub_Overflow

TimSub_Assign:
		MOVEM.L	D0/D1,(A0)		; TV_SECS == 0

		RTS


******* timer.device/AddTime *****************************************
*
*   NAME
*	AddTime - add one time request to another
*
*   SYNOPSIS
*	AddTime( Dest, Source ), timer.device
*	         A0    A1	 A6
*
*	void AddTime(struct *timeval, struct *timeval);
*
*   FUNCTION
*	This routine adds one timeval structure to another.  The
*	results are stored in the destination (Dest + Source -> Dest)
*
*	A0 and A1 will be left unchanged
*
*   INPUTS
*	Dest, Source -- pointers to timeval structures.
*
d457 5
a461 1
TimAdd:
d463 5
a467 3
		MOVE.L	D2,-(SP)
    
		MOVE.L	#MAXMICRO,D2
d469 3
a471 1
		MOVEM.L	(A0),D0/D1		; TV_SECS == 0
d473 1
a473 2
		ADD.L	(A1),D0			; TV_SECS == 0
		ADD.L	TV_MICRO(A1),D1
d475 5
a479 3
TimAdd_OverFlow:
		CMP.L	D1,D2
		BGT.S	TimAdd_Assign
d481 4
a484 3
		ADDQ.L	#1,D0
		SUB.L	D2,D1
		BRA.S	TimAdd_OverFlow
d486 5
a490 2
TimAdd_Assign:
		MOVEM.L	D0/D1,(A0)		; TV_SECS == 0
d492 1
a492 2
		MOVE.L	(SP)+,D2
		RTS
d494 1
a494 38
******* timer.device/CmpTime **********************************
*
*   NAME
*	CmpTime - compare two timeval structures
*
*   SYNOPSIS
*	result = CmpTime( Dest, Source ), timer.device
*	D0                A0    A1	  A6
*
*	BYTE CmpTime(struct *timeval, struct *timeval);
*
*   FUNCTION
*	This routine compares timeval structures.
*
*	A0 and A1 will be left unchanged.
*
*   INPUTS
*	Dest, Source -- pointers to timeval structures.
*
*   RESULTS
*	result = -1	if Dest has more time than source
*	result =  0	if Dest has the same time as source
*	result = +1	if Dest has less time than source
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*	Former versions of this AutoDoc had the sense of the result wrong
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*
d496 2
a497 1
TimCmp:
a498 1
		CLEAR	D0
a499 2
		TIMCMP	A0,A1,D1
		BEQ.S	TimCmp_End
a500 9
		BHI.S	TimCmp_hi

		MOVEQ	#-1,D0

TimCmp_End:
		RTS
TimCmp_hi:
		MOVEQ	#1,D0
		BRA.S	TimCmp_End
@


36.3
log
@fixed some autodoc stuff.  The autodocs still need LOTS of work.
@
text
@d16 1
a16 1
* $Header: device.asm,v 36.2 88/09/19 09:37:17 neil Exp $
d18 1
a18 1
* $Locker: neil $
d21 3
d64 1
a64 1
******* Included Files ***********************************************
d90 1
a90 1
******* Imported Names ***********************************************
d119 1
a119 1
******* Exported Names ***********************************************
d139 1
a139 1
******* Local Definitions ********************************************
d209 1
a209 1
;****** timer.device/TR_ADDREQUEST ********************************
d212 1
a212 1
*	TR_ADDREQUEST - add a new timer request
a213 4
*   SYNOPSIS
*	NewTimer( IOBlock ), TDLib
*	          A1	     A6
*
d215 3
a217 2
*	This routine adds an IO request to the timer.  It runs in
*	the context of the requester.
d219 2
a220 2
*   INPUTS
*	IOBlock - the command block for this IO operation.
d222 5
a226 1
*   EXCEPTIONS
d228 3
d232 2
a234 2
*   BUGS
*
d386 1
a386 1
******* timer.device/AbortIO ********************************
d949 1
a949 1
*	SubTime( Dest, Source ), TDLib
d952 2
d1025 1
a1025 1
*	AddTime( Dest, Source ), TDLib
d1028 2
d1078 1
a1078 1
******* timer.device/CmdTime **********************************
d1084 1
a1084 1
*	result = CmdTime( Dest, Source ), TDLib
d1087 2
d1090 1
a1090 1
*	This routine compares timeval structures
d1092 1
a1092 1
*	A0 and A1 will be left unchanged
d1098 4
a1101 3
*	result will be	 0 if Dest has same time as source
*			-1 if Dest has more time than source
*			+1 if Dest has less time than source
d1107 1
a1107 2
*	Older version of this document had the sense of the return
*	codes wrong; the code hasn't changed but the document has.
@


36.2
log
@fixed Delay(0) bug
@
text
@d16 1
a16 1
* $Header: device.asm,v 36.1 88/05/01 20:57:24 neil Exp $
d21 3
d206 1
a206 1
******* System/Drivers/Timer/NewTimer ********************************
d209 1
a209 1
*	NewTimer - add a new timer request
d379 1
a379 1
******* System/Drivers/Timer/RemTimer ********************************
d382 1
a382 1
*	RemTimer - remove an existing timer request
d385 2
a386 2
*	RemTimer( IOBlock ), TDLib
*	          A1	     A6
d389 1
a389 1
*	This routine adds an IO request to the timer.  It runs in
d395 4
d489 1
a489 1
******* System/Drivers/Timer/TickInt **********************************
d641 1
a641 1
******* System/Drivers/Timer/SubList **********************************
d709 1
a709 1
******* System/Drivers/Timer/StartTimer ******************************
d831 1
a831 1
******* System/Drivers/Timer/StopTimer *******************************
d936 1
a936 1
******* System/Drivers/Timer/TimSub **********************************
d939 1
a939 1
*	TimSub - subtract one time request from another
d942 2
a943 2
*	TimSub( Dest, Source ), TDLib
*	        A0    A1	A6
d1010 1
a1010 1
******* System/Drivers/Timer/TimAdd **********************************
d1013 1
a1013 1
*	TimAdd - add one time request to another
d1016 2
a1017 2
*	TimAdd( Dest, Source ), TDLib
*	        A0    A1	A6
d1067 1
a1067 1
******* System/Drivers/Timer/TimCmp **********************************
d1070 1
a1070 1
*	TimCmp - compare two timeval structures
d1073 2
a1074 2
*	result = TimCmp( Dest, Source ), TDLib
*	D0               A0    A1	 A6
d1086 2
a1087 2
*			-1 if Dest has less time than source
*			+1 if Dest has more time than source
d1093 2
@


36.1
log
@*** empty log message ***
@
text
@d16 1
a16 1
* $Header: device.asm,v 33.2 86/03/31 01:12:53 neil Exp $
d18 1
a18 1
* $Locker:  $
d21 1
d111 1
d247 2
a249 1
		MOVE.L	A3,-(SP)
d253 15
d563 3
d576 1
a576 1
		DOUNIT	STOP,A0
d752 1
a752 1
*		;------ the max allowable # of microseconds
d755 1
a755 1
*		;------ get the requested time
d760 2
a761 2
*		;------ Figure out if he wants more than we can give
*		;---!!!	Max must be less than one second
d765 3
a767 1
	NOP
d775 1
a775 1
*		;------ update the timeval structure
d778 7
a784 7
*		;------ Compute the number of phi 2 pulses needed to
*		;------	represent the requested number of microseconds.
*		;------	The actual constant is:
*		;------	    .715909 (microsecs) = # phi 2 pulses
*		;------ We use fixed point arithmetic to do this
*		;------ (64K * .715909 = 46918).  The correct answer
*		;------ is in the high word of the mul result.
d803 3
a805 3
	MOVE.L	D0,-(SP)
	ERRMSG	90,<'%s/StartUnit0: loading count with 0x%lx'>
	ADDQ.L	#4,SP
a807 1

a809 2
*****		BCLR	#CIACRBB_START,_ciaa+ciacrb

a813 5
	IFNE	Chips_6526
	;------ deleted for 8520 upgrade
	BSET	#CIACRBB_START,_ciaa+ciacrb
	ENDC

a857 1

d862 1
d865 7
a875 2
	BRA	StopUnit0_End

d878 13
a890 1
*		;------ get the remaining time
d904 5
d917 1
d1066 1
a1066 1
*	result = TimAdd( Dest, Source ), TDLib
@
