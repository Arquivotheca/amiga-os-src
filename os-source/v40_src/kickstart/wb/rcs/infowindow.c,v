head     39.7;
branch   ;
access   ;
symbols  V40_5:39.7 V40_4:39.7 V40_3:39.7 V40_2:39.7 V40_1:39.6 V39_56:39.5 V39_54:39.4 V39_52:39.4 V39_51:39.4 V39_50:39.3 V39_48:39.3 V39_46:39.3 V39_45:39.3 V39_44:39.3 V39_43:39.3 V39_42:39.3 V39_41:39.3 V39_40:39.3 V39_39:39.3 V39_38:39.3 V39_37:39.3 V39_36:39.3 V39_35:39.3 V39_34:39.3 V39_33:39.3 V39_32:39.3 V39_30:39.3 V39_29:39.2 V39_27:38.7 V39_26:38.7 V39_25:38.7 V39_23:38.7 V39_22:38.7 V39_21:38.2 V39_20:38.2 V39_18:38.2 V39_17:38.2 V39_16:38.2 V39_15:38.1 V39_14:38.1 V39_12:38.1 V39_10:38.1 V39_9:38.1 V39_8:38.1 V39_7:38.1 V39_6:38.1 V39_5:38.1 V39_4:38.1 V39_3:38.1;
locks    ; strict;
comment  @ * @;


39.7
date     93.02.15.14.46.04;  author mks;  state Exp;
branches ;
next     39.6;

39.6
date     93.02.10.12.08.42;  author mks;  state Exp;
branches ;
next     39.5;

39.5
date     93.02.04.11.59.07;  author mks;  state Exp;
branches ;
next     39.4;

39.4
date     92.11.12.08.03.06;  author mks;  state Exp;
branches ;
next     39.3;

39.3
date     92.05.31.16.31.51;  author mks;  state Exp;
branches ;
next     39.2;

39.2
date     92.05.31.02.09.39;  author mks;  state Exp;
branches ;
next     39.1;

39.1
date     92.05.31.01.52.16;  author mks;  state Exp;
branches ;
next     38.7;

38.7
date     92.04.24.18.32.39;  author mks;  state Exp;
branches ;
next     38.6;

38.6
date     92.04.24.16.14.26;  author mks;  state Exp;
branches ;
next     38.5;

38.5
date     92.04.24.16.14.00;  author mks;  state Exp;
branches ;
next     38.4;

38.4
date     92.04.24.12.45.25;  author mks;  state Exp;
branches ;
next     38.3;

38.3
date     92.04.24.10.51.25;  author mks;  state Exp;
branches ;
next     38.2;

38.2
date     92.03.10.11.34.05;  author mks;  state Exp;
branches ;
next     38.1;

38.1
date     91.06.24.11.36.36;  author mks;  state Exp;
branches ;
next     ;


desc
@Initial V38 tree checkin
@


39.7
log
@Just changed a bit to use the global strings
@
text
@/*
 * $Id: infowindow.c,v 39.6 93/02/10 12:08:42 mks Exp Locker: mks $
 *
 * $Log:	infowindow.c,v $
 * Revision 39.6  93/02/10  12:08:42  mks
 * Added two more fallbacks and made the number displays localized
 *
 * Revision 39.5  93/02/04  11:59:07  mks
 * Completely rewrote and redesigned the creation of the
 * information window.  It is now completely font sensitive and
 * has full fall-back capability in the case where the screen font
 * is too large to use.  In addition, a more complex text length
 * control now gives localization strings more ability to change.
 * Also included is a faster/simpler refresh mechanism.
 * All of this and yet the code is smaller.
 *
 * Revision 39.4  92/11/12  08:03:06  mks
 * Removed constant that is the SAVE/CANCEL size from this file
 * and moved it to the gadget create function
 *
 * Revision 39.3  92/05/31  16:31:51  mks
 * Now locks the screen as needed and does a few ROM Space tricks...
 *
 * Revision 39.2  92/05/31  02:09:39  mks
 * Had to move the allocation of the FIB back out of the getting
 * of the LOCK routine...
 *
 * Revision 39.1  92/05/31  01:52:16  mks
 * Now is the ASYNC, LVO based INFO...
 *
 * Revision 38.7  92/04/24  18:32:39  mks
 * Some more minor changes
 *
 * Revision 38.6  92/04/24  16:14:26  mks
 * One more minor adjustment
 *
 * Revision 38.5  92/04/24  16:14:00  mks
 * Final adjustment of the list gadget size values
 *
 * Revision 38.4  92/04/24  12:45:25  mks
 * Now does 3/5/7 line tooltypes based on available screen space
 *
 * Revision 38.3  92/04/24  10:51:25  mks
 * Changed to use only tags and no NewWindow structure
 * Changed to use -1,-1 as top-left for ZoomBox
 *
 * Revision 38.2  92/03/10  11:34:05  mks
 * Added the generation of the path name for the file
 *
 * Revision 38.1  91/06/24  11:36:36  mks
 * Initial V38 tree checkin - Log file stripped
 *
 */

/*------------------------------------------------------------------------*/

#include <exec/memory.h>
#include <intuition/intuition.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <libraries/dos.h>
#include <graphics/regions.h>

#include "info.h"
#include "support.h"
#include "quotes.h"

#include "global.h"
#include "macros.h"
#include "sysproto.h"
#include "proto.h"

extern	char	NumbersString[];
extern	char	MM_String[];
extern	char	M_String[];

/*------------------------------------------------------------------------*/

void RenderAll(struct InfoTag *itag,BOOL firsttime)
{
	LONG		left;
	LONG		top;
	LONG		width;
	LONG		height;
struct	Region		*myregion;
struct	Rectangle	rect;

	LockLayerInfo(&itag->it_Window->WScreen->LayerInfo);

	rect=itag->it_IconRect;
	rect.MaxX-=4;
	rect.MaxY-=2;

	DrawBevelBox(itag->it_Window->RPort,
			itag->it_IconRect.MinX,
			 itag->it_IconRect.MinY,
			width=itag->it_IconRect.MaxX-itag->it_IconRect.MinX,
			 height=itag->it_IconRect.MaxY-itag->it_IconRect.MinY,
			GTBB_Recessed, TRUE,
        		GT_VisualInfo, itag->it_VisualInfo,
			TAG_DONE);

	left=(width - itag->it_Obj->do_Gadget.Width) >> 1;
	if (left<4) left=4;
	left+=rect.MinX;

	top=(height - itag->it_Obj->do_Gadget.Height) >> 1;
	if (top<2) top=2;
	top+=rect.MinY;

	if (myregion=NewRegion())
	{
		if (OrRectRegion(myregion, &rect))
		{
			myregion=InstallClipRegion(itag->it_Window->RPort->Layer,myregion);

			if (!firsttime) BeginRefresh(itag->it_Window);

			DrawImage(itag->it_Window->RPort,(struct Image *)itag->it_Obj->do_Gadget.GadgetRender,left,top);

			if (!firsttime) EndRefresh(itag->it_Window,FALSE);

			myregion=InstallClipRegion(itag->it_Window->RPort->Layer,myregion);
		}
		DisposeRegion(myregion);
	}

	if (!firsttime)	/* Do the gadtools refresh work... */
	{
		GT_BeginRefresh(itag->it_Window);
		GT_EndRefresh(itag->it_Window, TRUE);
	}

	UnlockLayerInfo(&itag->it_Window->WScreen->LayerInfo);
}

/*------------------------------------------------------------------------*/

long PixelWidth(char *text,struct TextAttr *myFont)
{
struct	IntuiText	myText;

	myText.LeftEdge=0;
	myText.TopEdge=0;
	myText.ITextFont=myFont;
	myText.IText=text;
	myText.NextText=NULL;
	return(IntuiTextLength(&myText));
}

long MaxPixelWidth(long Low,long High,struct TextAttr *myFont)
{
LONG	result=0;
LONG	temp;

	while (Low<=High)
	{
		temp=PixelWidth(Quote(Low),myFont);
		if (temp>result) result=temp;

		Low++;
	}
	return(result+PixelWidth(M_String,myFont));
}

/*
 * Close up whatever may have allocated...
 */
void CloseInfoWindow(struct InfoTag *itag)
{
void	*node;

	if (itag)
	{
        	if (itag->it_Window) CloseWindow(itag->it_Window);

		/*  FreeGadgets() checks for the NULL case */
		FreeGadgets(itag->it_FirstGadget);

		if (itag->it_InfoFont) CloseFont(itag->it_InfoFont);

		FREEVEC(itag->it_FIB);
		FREEVEC(itag->it_InfoData);
		FREEVEC(itag->it_NameInfo);

		while (node=RemHead(&itag->it_ToolTypeList)) FREEVEC(node);

		FreeVisualInfo(itag->it_VisualInfo);

		if (itag->it_Obj) FreeDiskObject(itag->it_Obj);

		FREEVEC(itag);
	}
}

struct Gadget *CreateNum(struct Gadget *gad,struct NewGadget *ng,BOOL condition,LONG number,LONG q_id)
{
	ng->ng_GadgetText=Quote(q_id);
	ng->ng_TopEdge+=ng->ng_Height+2;

	if (condition) gad=CreateGadget(NUMBER_KIND,gad,ng,GTNM_Number,number,GTNM_Format,"%lU",TAG_DONE);
	else gad=CreateGadget(TEXT_KIND,gad,ng,GTTX_Text,"---",TAG_DONE);

	return(gad);
}

struct Gadget *Do_Next_Pro(struct InfoTag *itag,struct Gadget *gad, struct NewGadget *ng, ULONG bit, ULONG q_id)
{
	ng->ng_GadgetID++;
	ng->ng_TopEdge += ng->ng_Height;
	ng->ng_GadgetText = Quote(q_id);
	ng->ng_UserData = (APTR) bit;
	return(CreateGadget(CHECKBOX_KIND,gad,ng,
				GTCB_Checked,(BOOL)((itag->it_Protection ^ 15) & bit),
				GTCB_Scaled,TRUE,
				TAG_DONE) );
}

/* Routine to get various icon information/data */
long GetIconInfo(struct InfoTag *itag)
{
struct	DiskObject	*dobj;
	BPTR		parentlock;

	if (!(dobj=itag->it_Obj)) return(FALSE);

	itag->it_MaskType = 1L << (dobj->do_Type);

	CURRENTDIR(parentlock=CURRENTDIR(NULL));
	if (!NAMEFROMLOCK(parentlock,itag->it_Path,255)) strcpy(itag->it_Path,Quote(Q_INFO_TITLE));

	/* Get tooltypes... */
	if (dobj->do_ToolTypes)
	{
	LONG	i;

		for (i = 0; dobj->do_ToolTypes[i]; i++)
		{
		struct	Node	*node;

			if (!(node = AllocNode(dobj->do_ToolTypes[i]))) return(FALSE);
			ADDTAIL(&itag->it_ToolTypeList, node);
		}
		itag->it_AfterNode = TailNode(&itag->it_ToolTypeList);
	}

	/* Get FIB if needed... */
	if (itag->it_MaskType & MASK_FIB)
	{
	BPTR	lock;

		if (!(itag->it_FIB = ALLOCVEC(sizeof(struct FileInfoBlock), MEMF_PUBLIC))) return(FALSE);

		if (lock=LOCK(itag->it_Name,ACCESS_READ))
		{
			if (EXAMINE(lock, itag->it_FIB))
			{
				itag->it_Flags |= IT_GOT_FIB;
				itag->it_Protection=itag->it_FIB->fib_Protection;
			}
			UNLOCK(lock);
		}
	}

	/* If info is needed... */
	if (itag->it_MaskType & MASK_INFODATA)
	{
		if (!(itag->it_InfoData = ALLOCVEC(sizeof(struct InfoData), MEMF_CLEAR|MEMF_PUBLIC))) return(FALSE);

		if (Info(parentlock, itag->it_InfoData))
		{
			itag->it_Flags |= IT_GOT_INFODATA;
			if (itag->it_InfoData->id_VolumeNode)
			{
			/*  Copy datestamp from VolumeNode to itag: */
				memcpy(	(APTR)&itag->it_CreateDate,
				(APTR) &(((struct DeviceList *)(BADDR(itag->it_InfoData->id_VolumeNode)))->dl_VolumeDate),
				sizeof(struct DateStamp));

				itag->it_Flags |= IT_GOT_VOLNODE;
			}
		}
	}

	/* If we get here, all is well... */
	return(TRUE);
}

/*
 * Note:  For ROM Space reasons, the Screen->WBorXXX variables are
 * commented out and the constants are used...  For example,
 * if Screen->WBorTop were to be used it would look like this:
 */	//	/*Screen->WBorTop*/2

/* Maximum fallback try...  Currently 4 different fonts are tried */
#define	MAX_FALLBACK	4

struct Window *OpenInfoWindow(char *Name,struct Screen *Screen)
{
struct	WorkbenchBase	*wb=getWbBase();
struct	Window		*infoWindow=NULL;
struct	InfoTag		*itag;
	LONG		TryCount=0;

	while ((MAX_FALLBACK>TryCount++) && (infoWindow==NULL)) if (itag=ALLOCVEC(sizeof(struct InfoTag),MEMF_CLEAR|MEMF_PUBLIC))
	{
	struct	DiskObject	*dobj;
	struct	TextAttr	*myText;

		/*
		 * Pick the font to use, first time through, use the
		 * screen font, next time fall back to the icon font,
		 * then to the system font, finally to topaz-8
		 */
		myText=&defaultAttr;	/* If no others */
		switch(TryCount)
		{
			case 1:	myText=Screen->Font;	break;
			case 2:	myText=wb->wb_IconAttr;	break;
			case 3:	myText=wb->wb_TextAttr;	break;

		// ****	case MAX_FALLBACK: myText=&defaultAttr;	break;
		}

		NewList(&itag->it_ToolTypeList);

		itag->it_VisualInfo=GetVisualInfo(Screen,TAG_DONE);
		itag->it_InfoFont=OpenFont(myText);
		itag->it_Name=Name;
		itag->it_NameInfo=ALLOCVEC(strlen(Name)+6,MEMF_PUBLIC);
		strcpy(itag->it_NameInfo,Name);
		strcat(itag->it_NameInfo,InfoSuf);

		/* Try to get the icon... */
		if (!(dobj=GetDiskObject(Name)))
		{
			dobj=GetDiskObjectNew(Name);
			itag->it_ObjFake=TRUE;
		}
		itag->it_Obj=dobj;

		/* Now check if all is well... */
		if (itag->it_NameInfo	&&
		    itag->it_VisualInfo	&&
		    itag->it_InfoFont	&&
		    itag->it_Obj	&&
		    GetIconInfo(itag))
		{
		struct	Gadget		*gad;
			LONG		LeftEdge;
			LONG		TopEdge;
			LONG		numGad;
			LONG		numSpc;
			LONG		protGad;
			LONG		protBox;
			LONG		lowGad;
			LONG		winWidth;
			LONG		winHeight;
			LONG		iconBox;
			LONG		tmp;
			char		*dsText;
		struct	DateStamp	*ds=NULL;
			WORD		ZoomSize[4]={-1,-1,240,11};
		struct	NewGadget	ng;
			char		dsBuffer[64];

			stccpy(itag->it_Title,((itag->it_MaskType & MASK_HASNAME) ? itag->it_Name : itag->it_Path),32);
			strcat(itag->it_Title," (");
			strcat(itag->it_Title,Quote((UWORD)(itag->it_Obj->do_Type + Q_I_ICONTYPE_BASE - 1)));
			strcat(itag->it_Title,")");

			if (itag->it_MaskType & MASK_LASTCHANGED)
			{
				dsText=Quote(Q_LAST_CHANGED);
				if (itag->it_Flags & IT_GOT_FIB) ds=&itag->it_FIB->fib_Date;
			}
			else
			{
				dsText=Quote(Q_CREATED);
				if (itag->it_Flags & IT_GOT_VOLNODE) ds=&itag->it_CreateDate;
			}
			datetostring(dsBuffer,ds);

			TopEdge=/*Screen->WBorTop*/2 + Screen->BarHeight - Screen->BarVBorder;
			ZoomSize[3]=TopEdge;	/* Set ZOOM size */
			TopEdge+=1+/*Screen->WBorTop*/2;
			LeftEdge=(/*Screen->WBorLeft*/4) << 1;

			numGad=MaxPixelWidth(Q_STACK,Q_BYTES,myText);
			numSpc=PixelWidth(NumbersString,myText);
			protBox=PixelWidth(MM_String,myText)+10;

			protGad=MaxPixelWidth(Q_SCRIPT_BIT,Q_EXECUTE_BIT,myText)+4;
			tmp=MaxPixelWidth(Q_VOLUME_TEXT,Q_VOL_IS_UNKNOWN,myText);
			if (tmp>protGad) protGad=tmp;

			lowGad=MaxPixelWidth(Q_LAST_CHANGED,Q_TOOL_TYPES,myText);
			tmp=((MaxPixelWidth(Q_NEW,Q_DELETE,myText)+4)<<1)+6;
			if (tmp>lowGad) lowGad=tmp;

			/*
			 * Adjust Icon box if date string ends up
			 * being too wide...
			 */
			iconBox=127;	/* Default size */
			itag->it_IconRect.MinX=LeftEdge+numGad+numSpc+2;
			tmp=(lowGad+PixelWidth(dsBuffer,myText))-(iconBox+itag->it_IconRect.MinX);
			if (tmp>0) iconBox+=tmp;
			itag->it_IconRect.MaxX=iconBox+itag->it_IconRect.MinX;
			itag->it_IconRect.MaxY=13+(myText->ta_YSize<<2)+(itag->it_IconRect.MinY=TopEdge+myText->ta_YSize+3);

			/* Inner width of window without right_edge*2 */
			winWidth=itag->it_IconRect.MaxX+protGad+protBox;

			gad=CreateContext(&itag->it_FirstGadget);
			ng.ng_TextAttr=myText;

			/*
			 * Build the title gadget
			 * Remember to adjust for the possible
			 * longer-than-iconBox title...
			 */
			tmp=PixelWidth(itag->it_Title,myText)-iconBox;
			if (tmp>0) iconBox-=tmp;
			ng.ng_LeftEdge=itag->it_IconRect.MinX+(iconBox>>1);
			ng.ng_TopEdge=TopEdge+myText->ta_YSize+4;
			ng.ng_Width=0;
			ng.ng_Height=myText->ta_YSize;
			ng.ng_VisualInfo=itag->it_VisualInfo;
			ng.ng_Flags=PLACETEXT_ABOVE;
			ng.ng_GadgetText = itag->it_Title;
			gad=CreateGadget(TEXT_KIND,gad,&ng,TAG_DONE);

			/*
			 * File protection bits...
			 */
			if (itag->it_Flags & IT_GOT_FIB)
			{
				ng.ng_GadgetID = G_SCRIPT-1;
				ng.ng_LeftEdge=itag->it_IconRect.MaxX+protGad;
				ng.ng_Height+=3;	/* Check box size */
				ng.ng_Width=protBox;
				ng.ng_TopEdge=TopEdge-ng.ng_Height+2;
				ng.ng_Flags=NG_HIGHLABEL;

				gad=Do_Next_Pro(itag,gad,&ng,FIBF_SCRIPT,Q_SCRIPT_BIT);
				gad=Do_Next_Pro(itag,gad,&ng,FIBF_ARCHIVE,Q_ARCHIVED_BIT);
				gad=Do_Next_Pro(itag,gad,&ng,FIBF_READ,Q_READ_BIT);
				gad=Do_Next_Pro(itag,gad,&ng,FIBF_WRITE,Q_WRITE_BIT);
				gad=Do_Next_Pro(itag,gad,&ng,FIBF_EXECUTE,Q_EXECUTE_BIT);
				gad=Do_Next_Pro(itag,gad,&ng,FIBF_DELETE,Q_DELETE_BIT);

				ng.ng_Height-=3;	/* Undo it... */
			}
			else if (itag->it_MaskType & MASK_DISKSTATUS)
			{
				ng.ng_LeftEdge=itag->it_IconRect.MaxX+((protGad+protBox)>>1);
				ng.ng_TopEdge=itag->it_IconRect.MinY+ng.ng_Height+ng.ng_Height;
				ng.ng_GadgetText=Quote(Q_VOLUME_TEXT);
				gad=CreateGadget(TEXT_KIND,gad,&ng,TAG_DONE);
				ng.ng_TopEdge+=ng.ng_Height+2;

				tmp=Q_VOL_IS_UNKNOWN;
				if (itag->it_Flags & IT_GOT_INFODATA)
				{
					switch (itag->it_InfoData->id_DiskState)
					{
					case ID_WRITE_PROTECTED:
						tmp=Q_VOL_IS_READ_ONLY;
						break;
					case ID_VALIDATING:
						tmp=Q_VOL_IS_VALIDATING;
						break;
					case ID_VALIDATED:
						tmp=Q_VOL_IS_READ_WRITE;
						break;
					}
				}
				ng.ng_GadgetText=Quote(tmp);
				gad=CreateGadget(TEXT_KIND,gad,&ng,TAG_DONE);
			}

			/*
			 * General setup for the info gadgets...
			 */
			ng.ng_LeftEdge=numGad+LeftEdge;
			ng.ng_TopEdge=TopEdge+4;
			ng.ng_Flags=NG_HIGHLABEL;

			/*
			 * Disk information display
			 */
			if (itag->it_MaskType & MASK_DISK)
			{
				gad=CreateNum(gad,&ng, (BOOL)(itag->it_Flags & IT_GOT_INFODATA), itag->it_InfoData->id_NumBlocks,Q_BLOCKS);
				gad=CreateNum(gad,&ng, (BOOL)(itag->it_Flags & IT_GOT_INFODATA), itag->it_InfoData->id_NumBlocksUsed,Q_USED);
				gad=CreateNum(gad,&ng, (BOOL)(itag->it_Flags & IT_GOT_INFODATA), itag->it_InfoData->id_NumBlocks - itag->it_InfoData->id_NumBlocksUsed,Q_FREE);
				gad=CreateNum(gad,&ng, (BOOL)(itag->it_Flags & IT_GOT_INFODATA), itag->it_InfoData->id_BytesPerBlock,Q_BLOCK_SIZE);
			}

			/*
			 * File size (and stack) display
			 */
			if (itag->it_MaskType & MASK_SIZESTACK)
			{
			LONG	stacksize;

				gad=CreateNum(gad,&ng,(BOOL)(itag->it_Flags & IT_GOT_FIB),itag->it_FIB->fib_NumBlocks,Q_BLOCKS);
				gad=CreateNum(gad,&ng,(BOOL)(itag->it_Flags & IT_GOT_FIB),itag->it_FIB->fib_Size,Q_BYTES);

				ng.ng_GadgetID=G_STACK;
				ng.ng_TopEdge+=(ng.ng_Height=myText->ta_YSize+6);
				ng.ng_Width=numSpc-8;
				ng.ng_GadgetText=Quote(Q_STACK);

				if (!(stacksize=itag->it_Obj->do_StackSize)) stacksize=DEFAULT_STACKSIZE;

				if (!(itag->it_ObjFake)) itag->it_Stack=gad=CreateGadget(INTEGER_KIND,gad,&ng,GTIN_Number,stacksize,GTIN_MaxChars,NUMSTRINGLENGTH,TAG_DONE);
			}

			/*
			 * Set new top edge... Work down from here...
			 * Set the left edge (we use it for a while)
			 */
			ng.ng_TopEdge=itag->it_IconRect.MaxY+3;
			ng.ng_LeftEdge=lowGad+LeftEdge;

			/*
			 * If we have a date to display
			 */
			if (itag->it_MaskType & (MASK_LASTCHANGED | MASK_CREATEDDATE))
			{
				/*  Create a display-only "gadget" with the date: */
				ng.ng_Width=itag->it_IconRect.MaxX-ng.ng_LeftEdge;

				ng.ng_Height=myText->ta_YSize;
				ng.ng_Flags=NG_HIGHLABEL;
				ng.ng_GadgetText=dsText;
				gad = CreateGadget(TEXT_KIND,gad,&ng,
							GTTX_Text,dsBuffer,
							GTTX_CopyText,TRUE,
							TAG_DONE);

				ng.ng_TopEdge+=ng.ng_Height+4;
			}

			/*
			 * Set the general string gadget width/height here...
			 * We use it for a while below...
			 */
			ng.ng_Width=winWidth-ng.ng_LeftEdge;
			ng.ng_Height=6+myText->ta_YSize;

			/* Common code...  Fold out to here... */
			ng.ng_Flags=NG_HIGHLABEL;

			/*
			 * If there is a valid file/comment we will
			 * build the comment field
			 */
			if ((itag->it_MaskType & MASK_COMMENT) && (itag->it_Flags & IT_GOT_FIB))
			{
				ng.ng_GadgetID=G_COMMENT;
				ng.ng_GadgetText=Quote(Q_COMMENT);
				gad=CreateGadget(STRING_KIND, gad, &ng,
					GTST_String,itag->it_FIB->fib_Comment,
					GTST_MaxChars,COMMENTLENGTH-1,
					TAG_DONE);
				ng.ng_TopEdge+=ng.ng_Height+2;
				itag->it_Comment=gad;
			}

			/*
			 * Only show these gadgets if the icon is real...
			 */
			if (!(itag->it_ObjFake))
			{

				/*
				 * Default tool if needed...
				 */
				if (itag->it_MaskType & MASK_DEFAULTTOOL)
				{
					ng.ng_GadgetID=G_DEFAULTTOOL;
					ng.ng_GadgetText=Quote(Q_DEFAULT_TOOL);
					gad=CreateGadget(STRING_KIND, gad, &ng,
						GTST_String, itag->it_Obj->do_DefaultTool,
						GTST_MaxChars, DEFAULTTOOLLENGTH,
						TAG_DONE);
					ng.ng_TopEdge+=ng.ng_Height+2;
					itag->it_DefaultTool = gad;
				}


				/*
				 * Tooltypes as needed...
				 */
				if (itag->it_MaskType & MASK_TOOLTYPES)
				{
				LONG	tmp1;

					/*
					 * Some fancy footwork to figure
					 * out how much text will fit into
					 * a listview on the display and
					 * still look good.
					 */
					tmp1=myText->ta_YSize+1;
					ng.ng_Height=4+3*tmp1;
					tmp1+=tmp1;

					tmp=Screen->Height-/*Screen->WBorBottom*/2-TopEdge-tmp1-tmp1-ng.ng_TopEdge;
			/* 5 lines */	if (tmp>ng.ng_Height) ng.ng_Height+=tmp1;
			/* 7 lines */	if (tmp>ng.ng_Height) ng.ng_Height+=tmp1;

					/* Build the listview */
					ng.ng_GadgetText=Quote(Q_TOOL_TYPES);
					ng.ng_GadgetID=G_TTLIST;
					ng.ng_Flags=NG_HIGHLABEL | PLACETEXT_LEFT;

					gad=CreateGadget(LISTVIEW_KIND, gad, &ng,
						GTLV_Labels, &itag->it_ToolTypeList,
						GTLV_ScrollWidth, 18,
						LAYOUTA_SPACING, 1,
						TAG_DONE);
					itag->it_TTList=gad;
					ng.ng_TopEdge += ng.ng_Height;

					/* Build the string gadget */
					ng.ng_Height=6+myText->ta_YSize;
					ng.ng_GadgetID=G_TTSTRING;
					ng.ng_GadgetText=NULL;

					gad=CreateGadget(STRING_KIND,gad,&ng,
						GTST_MaxChars,TOOLTYPESLENGTH,
						GA_Disabled,TRUE,
						TAG_DONE);
					itag->it_TTString=gad;

					/*
					 * Now build the NEW/DEL buttons
					 */
					ng.ng_GadgetID=G_TTNEW;
					ng.ng_LeftEdge=LeftEdge;
					ng.ng_Width=(lowGad-6)/2;
					ng.ng_GadgetText=Quote(Q_NEW);
					ng.ng_Flags=0;
					gad=CreateGadget(BUTTON_KIND,gad,&ng,
						TAG_DONE);

					ng.ng_GadgetID=G_TTDEL;
					ng.ng_LeftEdge+=ng.ng_Width+2;
					ng.ng_GadgetText=Quote(Q_DELETE);
					gad=CreateGadget(BUTTON_KIND,gad,&ng,
						GA_Disabled, TRUE,
						TAG_DONE);
					itag->it_TTDel=gad;
					ng.ng_TopEdge+=ng.ng_Height+2;
				}
			}

			/*
			 * Now build the Save/Cancel gadgets
			 */
			lowGad=PixelWidth(Quote(Q_CANCEL_TEXT),myText);
			tmp=PixelWidth(Quote(Q_SAVE_TEXT),myText);
			if (tmp>lowGad) lowGad=tmp;

			lowGad+=12;

			ng.ng_GadgetID=G_SAVE;
			ng.ng_GadgetText=Quote(Q_SAVE_TEXT);
			ng.ng_LeftEdge=LeftEdge;
			ng.ng_TopEdge+=2;	/* Extra space at bottom */
			ng.ng_Width=lowGad;
			ng.ng_Flags=0;
			gad=CreateGadget(BUTTON_KIND, gad, &ng, TAG_DONE);

			ng.ng_GadgetID=G_QUIT;
			ng.ng_GadgetText=Quote(Q_CANCEL_TEXT);
			ng.ng_LeftEdge=winWidth-ng.ng_Width;
			gad=CreateGadget(BUTTON_KIND,gad,&ng,TAG_DONE);

			winHeight=ng.ng_TopEdge+ng.ng_Height+2+((/*Screen->WBorBottom*/2)<<1);
			winWidth+=/*Screen->WBorRight*/4<<1;

			if ((Screen->Height >= winHeight) &&
			    (Screen->Width  >= winWidth) &&
			    (gad))
			{
				infoWindow=OpenWindowTags(NULL,
							WA_Width,winWidth,
							WA_Height,winHeight,
							WA_PubScreen,Screen,
							WA_Title,itag->it_Path,
							WA_Zoom,ZoomSize,
							WA_IDCMP,INFOW_IDCMPFLAGS,
							WA_AutoAdjust,TRUE,
							WA_Flags,INFOW_FLAGS,
							WA_Gadgets,itag->it_FirstGadget,
							TAG_DONE);
			}
		}

		if (itag->it_Window=infoWindow)
		{
			infoWindow->UserData=(BYTE *)itag;
			RenderAll(itag,TRUE);
			GT_RefreshWindow(infoWindow,NULL);
		}
		else CloseInfoWindow(itag);
	}
	return(infoWindow);
}

/******************************************************************************/
/******************************************************************************/
/******************************************************************************/

/*
******* workbench.library/WBInfo **********************************************
*
*   NAME
*	WBInfo - Bring up the Information requrester                     (V39)
*
*   SYNOPSIS
*	worked = WBInfo(lock, name, screen)
*	d0              a0    a1    a2
*
*	ULONG WBInfo(BPTR, STRPTR, struct Screen *);
*
*   FUNCTION
*	This is the LVO that Workbench calls to bring up the Icon Information
*	requester.  External applications may also call this requester.
*	In addition, if someone were to wish to replace this requester
*	with another one, they could do so via a SetFunction.
*
*   INPUTS
*	lock   - A lock on the parent directory
*	name   - The name of the icon contained within above directory
*	screen - A screen pointer on which the requester is to show up
*
*   RESULTS
*	worked - Returns TRUE if the requester came up, FALSE if it did not.
*
*   NOTE
*	Note that this LVO may be called many times by different tasks
*	before other calls return.  Thus, the code must be 100% re-entrant.
*
*   SEE ALSO
*	icon.library
*
*   BUGS
*
******************************************************************************
*/
int WBInformation(BPTR DirLock, char *Name, struct Screen *Screen)
{
struct	WorkbenchBase	*wb=getWbBase();
struct	Window		*infowindow;
struct	IntuiMessage	*imsg;
struct	InfoTag		*itag;
struct	Process		*proc;
	APTR		oldWindow;
	int		terminated=FALSE;

	if ((wb->wb_WorkbenchStarted) && !(wb->wb_Quit) && (Name) && (Screen))
	{
		proc=(struct Process *)ThisTask();
		DirLock=CURRENTDIR(DirLock);

		if (infowindow = OpenInfoWindow(Name,Screen))
		{
			oldWindow=proc->pr_WindowPtr;
			proc->pr_WindowPtr=infowindow;

			itag = (struct InfoTag *) infowindow->UserData;

			while (!terminated)
			{
				imsg=GT_GetIMsg(infowindow->UserPort);
				if (imsg)
				{
					switch (imsg->Class)
					{
					case REFRESHWINDOW:
						RenderAll(itag, FALSE);
						break;
					case CLOSEWINDOW:
						terminated=TRUE;
						break;
					case GADGETUP:
						terminated = HandleGadgetUp(infowindow,(struct Gadget *) imsg->IAddress,imsg->Code);
						break;
					}

					GT_ReplyIMsg(imsg);
				}
				else WAITPORT(infowindow->UserPort);
			}

			proc->pr_WindowPtr=oldWindow;
			CloseInfoWindow(itag);
		}
		CURRENTDIR(DirLock);
	}
	return(terminated);
}

/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/

/*
 ******************************************************************************
 *
 * The fancy way to do ASync Info...
 *
 * Info is started in Sync mode but it becomes ASync
 *
 ******************************************************************************
 */
struct StartMSG
{
struct	Message	msg;
	BPTR	DirLock;
	char	*Name;
};

extern	void	*InfoSegment;

/*
 * This is where Workbench calls to startup Information...
 * This call will now start a new process which will do all of
 * the work...
 * (That is, Information runs on its own process...)
 */
int SyncInfo(struct WBObject *wbobj)
{
struct	MsgPort		*port=&(((struct Process *)ThisTask())->pr_MsgPort);
struct	MsgPort		*dest;
struct	StartMSG	Start;
	BPTR		Lock;
	char		*Name=DiskIconName;
	int		Failed=TRUE;

	if (CheckForType(wbobj,WBF_DISK|WBF_DRAWER|WBF_TOOL|WBF_PROJECT|WBF_GARBAGE))
	{
		if (wbobj->wo_Type != WBDISK) Name=wbobj->wo_Name;
		Lock=GetParentsLock(wbobj);

		if (Lock)
		{
			Start.DirLock=DUPLOCK(Lock);
			Start.Name=scopy(Name);
			Start.msg.mn_ReplyPort=port;

			if ((Start.DirLock) && (Start.Name))
			{
				if (dest=CREATEPROC(InformationString,2,MKBADDR(&InfoSegment),4096))
				{
					PUTMSG(dest,&(Start.msg));
					WAITPORT(port);
					GETMSG(port);
					Failed=FALSE;
				}
			}

			UNLOCK(Start.DirLock);
			FREEVEC(Start.Name);
		}
	}

	if (Failed) ErrorTitle(Quote(Q_INFO_FAILED));
	return(Failed);
}

/* The LVO jumper... */
void WB_Info(BPTR,char *,struct Screen *);

void StartInformation(void)
{
struct	MsgPort		*port=&(((struct Process *)ThisTask())->pr_MsgPort);
struct	StartMSG	*Start;
struct	Screen		*Screen;
	BPTR		Lock;
	char		*Name;


	/* Wait for the startup message */
	WAITPORT(port);
	Start=(struct StartMSG *)GETMSG(port);

	/* Get the lock and name from the startup message */
	/* We will free this memory when done... */
	Lock=Start->DirLock;	Start->DirLock=NULL;
	Name=Start->Name;	Start->Name=NULL;

	/* Lock the screen */
	Screen=LockPubScreen(SystemWorkbenchName);

	/* Reply startup message to let workbench continue... */
	REPLYMSG((struct Message *)Start);

	/* Now call Information for real... */
	WB_Info(Lock,Name,Screen);

	/* Release screen */
	UnlockPubScreen(NULL,Screen);

	/* Exit:  Cleanup and done... */
	FREEVEC(Name);
	UNLOCK(Lock);
}
@


39.6
log
@Added two more fallbacks and made the number displays localized
@
text
@d2 1
a2 1
 * $Id: infowindow.c,v 39.5 93/02/04 11:59:07 mks Exp Locker: mks $
d5 3
d73 4
d163 1
a163 1
	return(result+PixelWidth("m",myFont));
a358 1
			LONG		mSpace;
a388 2
			mSpace=PixelWidth("m",myText);

d390 2
a391 1
			numSpc=PixelWidth("123,456,789m",myText);
a395 1
			protBox=mSpace+mSpace+10;
@


39.5
log
@Completely rewrote and redesigned the creation of the
information window.  It is now completely font sensitive and
has full fall-back capability in the case where the screen font
is too large to use.  In addition, a more complex text length
control now gives localization strings more ability to change.
Also included is a faster/simpler refresh mechanism.
All of this and yet the code is smaller.
@
text
@d2 1
a2 1
 * $Id: infowindow.c,v 39.4 92/11/12 08:03:06 mks Exp Locker: mks $
d5 9
d194 1
a194 1
	if (condition) gad=CreateGadget(NUMBER_KIND,gad,ng,GTNM_Number,number,TAG_DONE);
d288 3
d293 4
a296 3
struct	Window	*infoWindow=NULL;
struct	InfoTag	*itag;
	LONG	TryCount=0;
d298 1
a298 1
	while ((2>TryCount++) && (infoWindow==NULL)) if (itag=ALLOCVEC(sizeof(struct InfoTag),MEMF_CLEAR|MEMF_PUBLIC))
d305 2
a306 1
		 * screen font, next time fall back to topaz-8
d308 9
a316 1
		myText=((TryCount==1) ? (Screen->Font) : (&defaultAttr));
d386 1
a386 1
			numSpc=PixelWidth("1234567890",myText);
@


39.4
log
@Removed constant that is the SAVE/CANCEL size from this file
and moved it to the gadget create function
@
text
@d2 1
a2 1
 * $Id: infowindow.c,v 39.3 92/05/31 16:31:51 mks Exp Locker: mks $
d5 4
d47 2
d50 1
d63 48
a110 10
/*/ CloseInfoTag()
 *
 * Function to close down the specified Info window based on its tag.
 *
 * Created:  30-May-89, Peter Cherna
 * Modified: 16-Nov-89, Peter Cherna
 *
 * Bugs:
 *
 */
d112 5
a116 4
struct Window *CloseInfoTag(struct InfoTag *itag)
{
struct Window *infowindow = itag->it_Window;
void *node;
d118 1
a118 22
    if (itag)
    {
        if (infowindow) CloseWindow(infowindow);

        /*  FreeGadgets() checks for the NULL case */
        FreeGadgets(itag->it_FirstGadget);

        if (itag->it_InfoFont) CloseFont(itag->it_InfoFont);

        FREEVEC(itag->it_FIB);
        FREEVEC(itag->it_InfoData);
	FREEVEC(itag->it_NameInfo);

	while (node=RemHead(&itag->it_ToolTypeList)) FREEVEC(node);

        FreeVisualInfo(itag->it_VisualInfo);

	if (itag->it_Obj) FreeDiskObject(itag->it_Obj);

        FREEVEC(itag);
    }
    return(NULL);
d123 13
a135 1
short DeltaSize(short low,short hi,short orig)
d137 2
a138 2
short len=0;
short x;
d140 4
a143 6
	while (low<=hi)
	{
		x=strlen(Quote(low))-orig;
		if (x>len) len=x;
		low++;
	}
d145 3
a147 2
	/* We are hard-coded to Topaz 8...  In the future it will be better */
	return(len << 3);
d150 4
a153 1
struct Window *OpenInfoWindow(char *Name,struct Screen *Screen)
d155 20
a174 152
struct Window *infowindow;
struct InfoTag *itag;
struct Gadget *gad;
BPTR parentlock, lock;
LONG i,j;
struct Node *node;
struct DiskObject *dobj;

    WORD ZoomSize[4] = {-1, -1, ZOOMWIDTH, 0};

    ULONG wtags[] =
    {
        WA_InnerHeight, 0,
        WA_InnerWidth, 0,
        WA_PubScreen, NULL,
        WA_Title, NULL,
        WA_Zoom, 0,
	WA_IDCMP, INFOW_IDCMPFLAGS,
        WA_AutoAdjust, TRUE,
	WA_Flags, INFOW_FLAGS,
        TAG_DONE
    };

    if (!(itag = ALLOCVEC(sizeof(struct InfoTag), MEMF_CLEAR|MEMF_PUBLIC))) return(NULL);

    NewList(&itag->it_ToolTypeList);

    itag->it_Name=Name;

    itag->it_NameInfo=ALLOCVEC(strlen(Name)+6,MEMF_PUBLIC);
    itag->it_VisualInfo = GetVisualInfo(Screen,TAG_DONE);
    itag->it_InfoFont = OpenFont(&defaultAttr);

    if (!(dobj=GetDiskObject(Name)))
    {
    	dobj=GetDiskObjectNew(Name);
	itag->it_ObjFake=TRUE;
    }
    itag->it_Obj=dobj;

    if (!(itag->it_NameInfo
    	&& itag->it_VisualInfo
    	&& itag->it_InfoFont
    	&& itag->it_Obj)) return(CloseInfoTag(itag));

    itag->it_MaskType = 1L << (dobj->do_Type);

    strcpy(itag->it_NameInfo,Name);
    strcat(itag->it_NameInfo,InfoSuf);

    itag->it_TopBorder = Screen->WBorTop + Screen->BarHeight - Screen->BarVBorder;

    /*
     * New:  For internationalization, we need to be able to handle
     * larger strings in some places.  Here is were the extra position
     * information is determined.
     */
    /* First, for the protection column */
    itag->it_X=DeltaSize(Q_SCRIPT_BIT,Q_EXECUTE_BIT,10);
    {
    short tmp=DeltaSize(Q_VOLUME_TEXT,Q_VOL_IS_UNKNOWN,15);

	if (tmp>itag->it_X) itag->it_X=tmp;
    }

    /* Now for the left (center) part */
    itag->it_CenterX=DeltaSize(Q_STACK,Q_BYTES,11);

    /* Now for the left (bottom) part */
    itag->it_BottomX=DeltaSize(Q_LAST_CHANGED,Q_TOOL_TYPES,13);

    /* Adjust the X size to the Center X size */
    itag->it_X += itag->it_CenterX;

    /* If it looks like we have the space, add some more tool types */
    i=(Screen->Height - itag->it_TopBorder)-208;
    j=0;		/* 3 Lines of text */
    if (i>j) j+=18;	/* 5 Lines of text */
    if (i>j) j+=18;	/* 7 Lines of text */
    itag->it_ToolsY=j+31;

    if (dobj->do_ToolTypes)
    {
        for (i = 0; dobj->do_ToolTypes[i]; i++)
        {
            if (!(node = AllocNode(dobj->do_ToolTypes[i]))) return(CloseInfoTag(itag));
            ADDTAIL(&itag->it_ToolTypeList, node);
        }
        itag->it_AfterNode = TailNode(&itag->it_ToolTypeList);
    }

    /*  Get a lock on the parent directory: */
    CURRENTDIR(parentlock=CURRENTDIR(NULL));
    if (!NAMEFROMLOCK(parentlock,itag->it_Path,255)) strcpy(itag->it_Path,Quote(Q_INFO_TITLE));

    if (itag->it_MaskType & MASK_FIB)
    {
	DP(("OIW:  Attempting to allocate FIB memory...\n"));
	if (!(itag->it_FIB = ALLOCVEC(sizeof(struct FileInfoBlock), MEMF_PUBLIC))) return(CloseInfoTag(itag));

        if (lock=LOCK(Name,ACCESS_READ))
        {
            if (EXAMINE(lock, itag->it_FIB))
            {
                itag->it_Flags |= IT_GOT_FIB;
                itag->it_Protection=itag->it_FIB->fib_Protection;
            }
	    UNLOCK(lock);
        }
    }

    if (itag->it_MaskType & MASK_INFODATA)
    {
        if (!(itag->it_InfoData = ALLOCVEC(sizeof(struct InfoData), MEMF_CLEAR|MEMF_PUBLIC))) return(CloseInfoTag(itag));
        if (Info(parentlock, itag->it_InfoData))
        {
            itag->it_Flags |= IT_GOT_INFODATA;
            if (itag->it_InfoData->id_VolumeNode)
            {
                /*  Copy datestamp from VolumeNode to itag: */
                memcpy(	(APTR)&itag->it_CreateDate,
			(APTR) &(((struct DeviceList *)(BADDR(itag->it_InfoData->id_VolumeNode)))->dl_VolumeDate),
			sizeof(struct DateStamp));

                itag->it_Flags |= IT_GOT_VOLNODE;
            }
        }
    }

    DP(("OIW:  Initializing all gadgets...\n"));
    gad = InitAll(itag);

    wtags[0*2+1] = itag->it_Y - itag->it_TopBorder;
    wtags[1*2+1] = itag->it_X + INFOW_WIDTH;
    wtags[2*2+1] = (ULONG) Screen;
    wtags[3*2+1] = (ULONG) (itag->it_Path);
    wtags[4*2+1] = (ULONG) ZoomSize;

    ZoomSize[3] = itag->it_TopBorder;

    DP(("OIW:  Opening window...\n"));
    if ((!gad) || (!(infowindow = OpenWindowTagList(NULL,(struct TagItem *)wtags)))) return(CloseInfoTag(itag));

    infowindow->UserData = (BYTE *) itag;
    itag->it_Window = infowindow;

    SetFont(infowindow->RPort, itag->it_InfoFont);

    RenderAll(itag, TRUE);
    AddGList(infowindow, itag->it_FirstGadget, ((USHORT) -1), ((USHORT) -1), NULL);
    RefreshGList(itag->it_FirstGadget, infowindow, NULL, ((USHORT) -1));
    GT_RefreshWindow(infowindow, NULL);
d176 2
a177 1
    return(infowindow);
d180 73
d254 9
a262 1
/*------------------------------------------------------------------------*/
d264 4
a267 6
struct StartMSG
{
struct	Message	msg;
	BPTR	DirLock;
	char	*Name;
};
d269 3
a271 1
extern	void	*InfoSegment;
d274 6
a279 5
 * This is where Workbench calls to startup Information...
 * This call will now start a new process which will do all of
 * the work...
 */
int SyncInfo(struct WBObject *wbobj)
d281 3
a283 6
struct	MsgPort		*port=&(((struct Process *)ThisTask())->pr_MsgPort);
struct	MsgPort		*dest;
struct	StartMSG	Start;
	BPTR		Lock;
	char		*Name=DiskIconName;
	int		Failed=TRUE;
d285 1
a285 1
	if (CheckForType(wbobj,WBF_DISK|WBF_DRAWER|WBF_TOOL|WBF_PROJECT|WBF_GARBAGE))
d287 25
a311 2
		if (wbobj->wo_Type != WBDISK) Name=wbobj->wo_Name;
		Lock=GetParentsLock(wbobj);
d313 6
a318 1
		if (Lock)
d320 106
a425 3
			Start.DirLock=DUPLOCK(Lock);
			Start.Name=scopy(Name);
			Start.msg.mn_ReplyPort=port;
d427 3
a429 1
			if ((Start.DirLock) && (Start.Name))
d431 8
a438 1
				if (dest=CREATEPROC(InformationString,2,MKBADDR(&InfoSegment),4096))
d440 12
a451 4
					PUTMSG(dest,&(Start.msg));
					WAITPORT(port);
					GETMSG(port);
					Failed=FALSE;
d453 40
d495 14
a508 4
			UNLOCK(Start.DirLock);
			FREEVEC(Start.Name);
		}
	}
d510 7
a516 3
	if (Failed) ErrorTitle(Quote(Q_INFO_FAILED));
	return(Failed);
}
d518 2
a519 2
/* The LVO jumper... */
void WB_Info(BPTR,char *,struct Screen *);
d521 25
a545 7
void StartInformation(void)
{
struct	MsgPort		*port=&(((struct Process *)ThisTask())->pr_MsgPort);
struct	StartMSG	*Start;
struct	Screen		*Screen;
	BPTR		Lock;
	char		*Name;
d547 5
d553 14
a566 3
	/* Wait for the startup message */
	WAITPORT(port);
	Start=(struct StartMSG *)GETMSG(port);
a567 4
	/* Get the lock and name from the startup message */
	/* We will free this memory when done... */
	Lock=Start->DirLock;	Start->DirLock=NULL;
	Name=Start->Name;	Start->Name=NULL;
d569 6
a574 2
	/* Lock the screen */
	Screen=LockPubScreen(SystemWorkbenchName);
d576 59
a634 2
	/* Reply startup message to let workbench continue... */
	REPLYMSG((struct Message *)Start);
d636 24
a659 2
	/* Now call Information for real... */
	WB_Info(Lock,Name,Screen);
d661 17
a677 2
	/* Release screen */
	UnlockPubScreen(NULL,Screen);
d679 9
a687 3
	/* Exit:  Cleanup and done... */
	FREEVEC(Name);
	UNLOCK(Lock);
d690 4
d777 1
a777 2

			CloseInfoTag(itag);
d784 106
a889 1
/*------------------------------------------------------------------------*/
@


39.3
log
@Now locks the screen as needed and does a few ROM Space tricks...
@
text
@d2 1
a2 1
 * $Id: infowindow.c,v 39.2 92/05/31 02:09:39 mks Exp Locker: mks $
d5 3
d248 1
a248 3
    /*  Leave room for save/cancel gadgets, that didn't figure
        in the vert. space calculation: */
    wtags[0*2+1] = itag->it_Y + 16 - itag->it_TopBorder;
@


39.2
log
@Had to move the allocation of the FIB back out of the getting
of the LOCK routine...
@
text
@d2 1
a2 1
 * $Id: infowindow.c,v 39.1 92/05/31 01:52:16 mks Exp Locker: mks $
d5 4
d64 1
a64 1
void CloseInfoTag(struct InfoTag *itag)
d90 1
d136 1
a136 4
    if (!(itag = ALLOCVEC(sizeof(struct InfoTag), MEMF_CLEAR|MEMF_PUBLIC)))
    {
        return(NULL);
    }
a152 1

d156 1
a156 5
    	&& itag->it_Obj))
    {
        CloseInfoTag(itag);
        return(NULL);
    }
d158 1
a158 2
    itag->it_MaskType = 1 << (dobj->do_Type);
    if (itag->it_MaskType == MASK_DISK) itag->it_ObjFake=FALSE;
d198 1
a198 5
            if (!(node = AllocNode(dobj->do_ToolTypes[i])))
            {
                CloseInfoTag(itag);
                return(NULL);
            }
d211 1
a211 5
	if (!(itag->it_FIB = ALLOCVEC(sizeof(struct FileInfoBlock), MEMF_PUBLIC)))
	{
	    CloseInfoTag(itag);
	    return(NULL);
	}
d226 1
a226 7
        DP(("OIW:  Attempting to allocate InfoData memory...\n"));
        if (!(itag->it_InfoData = ALLOCVEC(sizeof(struct InfoData), MEMF_CLEAR|MEMF_PUBLIC)))
        {
            CloseInfoTag(itag);
            return(NULL);
        }
        DP(("OIW:  Infoing parentlock...\n"));
d256 1
a256 5
    if (!(infowindow = OpenWindowTagList(NULL,(struct TagItem *)wtags)))
    {
        CloseInfoTag(itag);
        return(NULL);
    }
a262 8
    if (!gad)
    {
        DP(("OIW:  Aborting due to gadget creation error...\n"));
        CloseInfoTag(itag);
        return(NULL);
    }

    DP(("OIW:  Rendering all stuff...\n"));
a263 1
    DP(("OIW:  Adding and refreshing gadgets...\n"));
d267 1
a267 1
    DP(("OIW:  Done.\n"));
d290 1
a290 1
struct	MsgPort		*port;
a298 2
		port=&(((struct Process *)ThisTask())->pr_MsgPort);

a332 1
struct	WorkbenchBase	*wb=getWbBase();
d335 1
d349 3
d356 1
a356 1
	WB_Info(Lock,Name,wb->wb_Screen);
d358 3
d367 1
a367 1
*****i* workbench.library/WBInfo **********************************************
a382 2
*	Note that this LVO may be called many times by different tasks
*	before other calls return.  Thus, the code must be 100% re-entrant.
d393 2
a394 6
*	This is the prototype and pragma for SAS/C such that
*	the function can be used in our private work.
*
*		ULONG WBInfo( unsigned long tag, unsigned byte *name,
*				 struct Screen *screen );
*		#pragma libcall WorkbenchBase WBInfo 5a a9803
d397 1
@


39.1
log
@Now is the ASYNC, LVO based INFO...
@
text
@d2 1
a2 1
 * $Id: infowindow.c,v 38.7 92/04/24 18:32:39 mks Exp Locker: mks $
d5 3
d218 7
a226 6
	    DP(("OIW:  Attempting to allocate FIB memory...\n"));
	    if (!(itag->it_FIB = ALLOCVEC(sizeof(struct FileInfoBlock), MEMF_PUBLIC)))
	    {
	        CloseInfoTag(itag);
	        return(NULL);
	    }
@


38.7
log
@Some more minor changes
@
text
@d2 1
a2 1
 * $Id: infowindow.c,v 38.6 92/04/24 16:14:26 mks Exp Locker: mks $
d5 3
d39 1
d46 15
a60 2
/*  New intuition functions: */
struct Window *OpenWindowTagList(struct NewWindow *, struct TagItem *);
d62 3
a64 1
/*------------------------------------------------------------------------*/
d66 2
a67 1
/*  Function Prototypes: */
d69 1
a69 4
BOOL SyncInfo(struct WBObject *wbobj, struct MsgPort *intuiport);
struct Window *OpenInfoWindow(struct WBObject *wbobj,
    struct MsgPort *intuiport);
void CloseInfoTag(struct InfoTag *itag);
d71 3
a73 1
/*------------------------------------------------------------------------*/
d75 1
a75 9
/*/ SyncInfo()
 *
 * Function to open, process, and close an Info window synchronously to
 * Workbench.
 *
 * Created:  20-Jul-89, Peter Cherna
 * Modified: 13-Sep-89, David Berezowski / Peter Cherna
 *
 */
d77 1
a77 1
BOOL SyncInfo(wbobj, intuiport)
d79 1
a79 2
    struct WBObject *wbobj;
    struct MsgPort *intuiport;
d81 1
a81 29
{
    struct Window *infowindow;
    BOOL terminated;
    struct IntuiMessage *imsg;

    DP(("SI:  Enter\n"));
    if (!(infowindow = OpenInfoWindow(wbobj, intuiport)))
    {
        return(FALSE);
    }

        BeginDiskIO();
    terminated = FALSE;
    while (!terminated)
    {
        Wait (1 << intuiport->mp_SigBit);
        while ((!terminated) && (imsg = (struct IntuiMessage *) GetMsg(intuiport)))
        {
            if (imsg->IDCMPWindow == infowindow)
            {
                DP(("SI:  Got a message for InfoWindow (class %lx)\n",imsg->Class));
                terminated = HandleInfoEvent(infowindow, imsg);
                REPLYMSG((struct Message *)imsg);
            }
            else
            {
                StripMessage(imsg);
            }
        }
a82 5

    CloseInfoTag((struct InfoTag *) infowindow->UserData);

        EndDiskIO();
        return(TRUE);
a84 1

d103 9
a111 15
/*/ OpenInfoWindow()
 *
 * Function to open an Info window for the supplied icon, using the supplied
 * IDCMP message port.
 *
 * Created:  30-May-89, Peter Cherna
 * Modified: 17-Apr-90, Peter Cherna
 *
 * Note:  Currently it fails when you try to Info an AppIcon.  I presume
 * that the call to GetParentsLock() is failing.  I haven't decided
 * the correct behaviour, but not even opening the window would be nice.
 *
 */

struct Window *OpenInfoWindow(wbobj, intuiport)
a112 11
    struct WBObject *wbobj;
    struct MsgPort *intuiport;

{
    struct WorkbenchBase *wb = getWbBase();
    struct Window *infowindow;
    struct InfoTag *itag;
    struct Gadget *gad;
    BPTR parentlock, lock;
    LONG i,j;
    struct Node *node;
d122 1
a122 1
	WA_IDCMP, 0,	/* Will be set later */
a127 1
    DP(("OIW:  Allocating InfoTag...\n"));
d133 20
a152 2
    if (!(itag->it_VisualInfo = GetVisualInfo(wb->wb_Screen,
        TAG_DONE)))
d158 5
a162 1
    itag->it_TopBorder = wb->wb_Screen->WBorTop + wb->wb_Screen->BarHeight - wb->wb_Screen->BarVBorder;
d164 1
a164 6
    /*  Open display font: */
    if (!(itag->it_InfoFont = OpenFont(&defaultAttr)))
    {
        CloseInfoTag(itag);
        return(NULL);
    }
d189 1
a189 1
    i=(wb->wb_Screen->Height - itag->it_TopBorder)-208;
d195 1
a195 5
    itag->it_WBObj = wbobj;
    itag->it_MaskType = 1 << wbobj->wo_Type;
    NewList(&itag->it_ToolTypeList);
    DP(("OIW:  ToolTypes list cleared\n"));
    if (wbobj->wo_ToolTypes)
d197 1
a197 1
        for (i = 0; wbobj->wo_ToolTypes[i]; i++)
d199 1
a199 2
            DP(("OIW:  i: %ld ToolTypes[i]: %lx\n",i, wbobj->wo_ToolTypes[i]));
            if (!(node = AllocNode(wbobj->wo_ToolTypes[i])))
a204 1
            DP(("OIW:  Added ToolTypes node %s\n", node->ln_Name));
d210 1
a210 6
    if (!(parentlock = GetParentsLock(itag->it_WBObj)))
    {
        CloseInfoTag(itag);
        return(NULL);
    }

a212 2
    itag->it_Protection=itag->it_WBObj->wo_Protection;

d215 1
a215 13

        DP(("OIW:  Attempting to allocate FIB memory...\n"));
        if (!(itag->it_FIB = ALLOCVEC(sizeof(struct FileInfoBlock), MEMF_CLEAR|MEMF_PUBLIC)))
        {
            CloseInfoTag(itag);
            return(NULL);
        }
        DP(("OIW:  Attempting to lock file %s...\n", itag->it_WBObj->wo_Name));
        /*  Make the parent directory my current directory: */
        CURRENTDIR(parentlock);

        lock = LOCK(itag->it_WBObj->wo_Name, ACCESS_READ);
        if (lock)
d217 6
a222 1
            DP(("OIW:  Lock succeeded.  Examining lock...\n"));
d224 1
a224 1
        {
d227 2
a229 3
            DP(("OIW:  FIB is at %lx\n", itag->it_FIB));
            UNLOCK(lock);
        }
d263 1
a263 1
    wtags[2*2+1] = (ULONG) wb->wb_Screen;
d281 1
a281 3
    infowindow->UserPort = intuiport;

    if ((!gad) || (!ModifyIDCMP(infowindow, INFOW_IDCMPFLAGS)))
d301 13
a313 9
/*/ CloseInfoTag()
 *
 * Function to close down the specified Info window based on its tag.
 *
 * Created:  30-May-89, Peter Cherna
 * Modified: 16-Nov-89, Peter Cherna
 *
 * Bugs:
 *
d315 15
d331 16
a346 1
void CloseInfoTag(itag)
d348 4
a351 1
    struct InfoTag *itag;
d353 3
a355 2
{
    struct Window *infowindow = itag->it_Window;
d357 2
a358 7
    if (itag)
    {
        if (infowindow)
        {
            infowindow->Title = NULL;
            ClosePWindow(infowindow, NULL);
        }
d360 23
a382 2
        /*  FreeGadgets() checks for the NULL case */
        FreeGadgets(itag->it_FirstGadget);
d384 4
a387 2
        if (itag->it_InfoFont)
            CloseFont(itag->it_InfoFont);
d389 51
a439 2
        FREEVEC(itag->it_FIB);
        FREEVEC(itag->it_InfoData);
d441 4
a444 1
        while (!Empty(&itag->it_ToolTypeList)) FREEVEC(RemHead(&itag->it_ToolTypeList));
d446 31
a476 1
        FreeVisualInfo(itag->it_VisualInfo);
d478 5
a482 2
        FREEVEC(itag);
    }
a483 1

@


38.6
log
@One more minor adjustment
@
text
@d2 1
a2 1
 * $Id: infowindow.c,v 38.5 92/04/24 16:14:00 mks Exp Locker: mks $
d5 3
d156 1
a156 1
    struct TagItem wtags[] =
d163 1
a164 1
	WA_IDCMP, 0,	/* Will be set later */
d166 1
a166 1
        TAG_DONE, 0
a213 1
    j=31;		/* 3 Lines of text */
d215 4
a218 3
    if (i>0) j+=18;	/* 5 Lines of text */
    if (i>18) j+=18;	/* 7 Lines of text */
    itag->it_ToolsY=j;
d307 5
a311 5
    wtags[0].ti_Data = itag->it_Y + 16 - itag->it_TopBorder;
    wtags[1].ti_Data = itag->it_X + INFOW_WIDTH;
    wtags[2].ti_Data = (ULONG) wb->wb_Screen;
    wtags[3].ti_Data = (ULONG) (itag->it_Path);
    wtags[4].ti_Data = (ULONG) ZoomSize;
d316 1
a316 1
    if (!(infowindow = OpenWindowTagList(NULL, wtags)))
@


38.5
log
@Final adjustment of the list gadget size values
@
text
@d2 1
a2 1
 * $Id: infowindow.c,v 38.4 92/04/24 12:45:25 mks Exp Locker: mks $
d5 3
d214 1
a214 1
    if (i>20) j+=18;	/* 7 Lines of text */
@


38.4
log
@Now does 3/5/7 line tooltypes based on available screen space
@
text
@d2 1
a2 1
 * $Id: infowindow.c,v 38.3 92/04/24 10:51:25 mks Exp Locker: mks $
d5 3
d208 4
a211 4
    j=34;		/* 3 Lines of text */
    i=(wb->wb_Screen->Height - itag->it_TopBorder)-203;
    if (i>0) j+=20;	/* 5 Lines of text */
    if (i>20) j+=20;	/* 7 Lines of text */
@


38.3
log
@Changed to use only tags and no NewWindow structure
Changed to use -1,-1 as top-left for ZoomBox
@
text
@d2 1
a2 1
 * $Id: infowindow.c,v 38.2 92/03/10 11:34:05 mks Exp Locker: mks $
d5 4
d143 1
a143 1
    LONG i;
d205 5
a209 1
    itag->it_ToolsY=(((wb->wb_Screen->Height - itag->it_TopBorder) > 203) ? 54 : 34);
@


38.2
log
@Added the generation of the path name for the file
@
text
@d2 1
a2 1
 * $Id: infowindow.c,v 38.1 91/06/24 11:36:36 mks Exp Locker: mks $
d5 3
a133 18
    static struct NewWindow newinfowindow =
    {
        INFOW_LEFTEDGE, INFOW_TOPEDGE,
        /*  Height of zero gets set later: */
        0, 0,
        -1, -1,                 /*  DetailPen, BlockPen */
        NULL,                   /*  IDCMP Flags will be set later */
        INFOW_FLAGS,
        NULL,                   /*  FirstGadget */
        NULL,                   /*  CheckMark */
        NULL,                   /*  Title */
        NULL,                   /*  Screen */
        NULL,                   /*  BitMap */
        INFOW_MINWIDTH, INFOW_MINHEIGHT,
        INFOW_MAXWIDTH, INFOW_MAXHEIGHT,
        WBENCHSCREEN,
    };

d141 1
a141 5
    WORD ZoomSize[4] =
        {
            ZOOMLEFT, ZOOMTOP,
            ZOOMWIDTH, 0,
        };
a142 1
    /*  the height gets set later: */
d148 2
d151 3
a153 3
        WA_Title, NULL,
        WA_Zoom, NULL,
        TAG_DONE, 0,
d293 2
a294 2
    wtags[4].ti_Data = (ULONG) (itag->it_Path);
    wtags[5].ti_Data = (ULONG) ZoomSize;
d299 1
a299 1
    if (!(infowindow = OpenWindowTagList(&newinfowindow, wtags)))
@


38.1
log
@Initial V38 tree checkin - Log file stripped
@
text
@d2 1
a2 1
 * $Id$
d4 4
a7 1
 * $Log$
d248 2
d311 1
a311 1
    wtags[4].ti_Data = (ULONG) Quote(Q_INFO_TITLE);
@
