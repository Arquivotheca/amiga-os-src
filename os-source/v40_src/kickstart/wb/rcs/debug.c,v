head     38.4;
branch   ;
access   ;
symbols  V40_5:38.4 V40_4:38.4 V40_3:38.4 V40_2:38.4 V40_1:38.4 V39_56:38.4 V39_54:38.4 V39_52:38.4 V39_51:38.4 V39_50:38.4 V39_48:38.4 V39_46:38.4 V39_45:38.4 V39_44:38.4 V39_43:38.4 V39_42:38.4 V39_41:38.4 V39_40:38.4 V39_39:38.4 V39_38:38.4 V39_37:38.4 V39_36:38.4 V39_35:38.4 V39_34:38.4 V39_33:38.4 V39_32:38.4 V39_30:38.4 V39_29:38.4 V39_27:38.4 V39_26:38.4 V39_25:38.4 V39_23:38.4 V39_22:38.4 V39_21:38.4 V39_20:38.4 V39_18:38.2 V39_17:38.2 V39_16:38.2 V39_15:38.2 V39_14:38.2 V39_12:38.2 V39_10:38.2 V39_9:38.2 V39_8:38.2 V39_7:38.2 V39_6:38.2 V39_5:38.1 V39_4:38.1 V39_3:38.1;
locks    ; strict;
comment  @ * @;


38.4
date     92.04.14.12.05.36;  author mks;  state Exp;
branches ;
next     38.3;

38.3
date     92.04.14.11.37.18;  author mks;  state Exp;
branches ;
next     38.2;

38.2
date     92.01.07.13.55.57;  author mks;  state Exp;
branches ;
next     38.1;

38.1
date     91.06.24.11.34.20;  author mks;  state Exp;
branches ;
next     ;


desc
@Initial V38 tree checkin
@


38.4
log
@Now is nothing!
@
text
@/*
 * $Id: debug.c,v 38.3 92/04/14 11:37:18 mks Exp Locker: mks $
 *
 * $Log:	debug.c,v $
 * Revision 38.3  92/04/14  11:37:18  mks
 * Deleted lots-o-stuff
 *
 * Revision 38.2  92/01/07  13:55:57  mks
 * Removed debugging info for now-obsolete workbenchbase structures
 *
 * Revision 38.1  91/06/24  11:34:20  mks
 * Initial V38 tree checkin - Log file stripped
 *
 */
@


38.3
log
@Deleted lots-o-stuff
@
text
@d2 1
a2 1
 * $Id: debug.c,v 38.2 92/01/07 13:55:57 mks Exp Locker: mks $
d5 3
a14 376

#include "proto.h"
#include "string.h"
#include "exec/types.h"
#include "string.h"
#include "exec/memory.h"
#include "libraries/dos.h"
#include "workbench.h"
#include "workbenchbase.h"
#include "global.h"
#include "support.h"
#include "graphics/regions.h"

void tabin(num)
{
}

void dumpRegion(s, r)
UBYTE *s;
struct Region *r;
{
}

dumpRect(s, r)
UBYTE *s;
struct Rectangle *r;
{
    return(0);
}

PrintIDCMPFlags(IDCMPFlags)
ULONG IDCMPFlags;
{
    return(0);
}

PrintNewDD(dd)
struct NewDD *dd;
{
	return(0);
}

PrintImage(image)
struct Image *image;
{
    return(0);
}

PrintGadget(gad)
struct Gadget *gad;
{
    return(0);
}

PrintWBObject(obj)
struct WBObject *obj;
{
    return(0);
}

PrintNode(ln)
struct Node *ln;
{
	return(0);
}

PrintObj( obj )
struct WBObject *obj;
{
    return( 0 );
}

void PrintBString(bstr)
BSTR bstr;
{
}

void PrintCLI(cli, s)
struct CommandLineInterface *cli;
char *s;
{
}

PrintVol(dl)
struct DeviceList *dl;
{
    return(0);
}

PrintAppWindow(aw)
struct WorkbenchAppInfo *aw;
{
	return(0);
}

PrintAppIcon(ai)
struct WorkbenchAppInfo *ai;
{
	return(0);
}

PrintAppMenuItem(ami)
struct WorkbenchAppInfo *ami;
{
	return(0);
}

PrintIntuiText(it)
struct IntuiText *it;
{
	return(0);
}

PrintMenuItem(mi, s)
struct MenuItem *mi;
char *s;
{
	return(0);
}

PrintMenuStrip(menu)
struct Menu *menu;
{
	return(0);
}

void DisplayLock(lock, s)
long lock;
char *s;
{
}

OnLockList(lock)
long lock;
{
	return(0);
}

void AddToLockList(lock, s)
long lock;
char *s;
{
}

void RemoveFromLockList(lock, s)
long lock;
char *s;
{
}

void DisplayLockList()
{
}

void AddToAllocList(mem, size, type)
APTR mem;
LONG size, type;
{
}

void RemoveFromAllocList(mem, size)
APTR mem;
LONG size;
{
}

void DisplayAllocList()
{
}

OnAllocList(mem, size, free, position)
APTR mem;
LONG size;
LONG free; /* TRUE - looking for a free slot, else not */
LONG *position;
{
	result(0);
}

void FreeAllocList()
{
}


void PrintFileopsAddresses()
{
}

void PrintNewDDOffsets()
{
}

void PrintWBObjectOffsets()
{
}

void PrintWorkbenchBase()
{
}

void PrintAvailMem(msg, type)
char *msg;
ULONG type;
{
}

/*
	These routines are to be used in place of their EXEC
	counterparts.  They provide a level of safety and allow
	me to debug the Quit function by tracking all allocated
	and deallocated memory.
*/

void *myallocmem(size, type)
LONG size, type;
{
	void * mem;

	mem = (void *)AllocMem(size, type);
	if (mem) {
		DP(("ATAL(mam): mem=$%lx, size=%ld, type=$%lx\n",
			mem, size, type));
		AddToAllocList(mem, size, type);
	}
	return(mem);
}

void myfreemem(mem, size)
void *mem;
LONG size;
{
	DP(("RFAL(mfm): mem=$%lx, size=%ld\n",
		mem, size));
	RemoveFromAllocList(mem, size);
	FreeMem(mem, size);
}

void myfreeentry(ml)
struct MemList *ml;
{
    struct MemEntry *me = ml->ml_ME;
    int numentries = ml->ml_NumEntries;

    do {
	if (me->me_Length) {
	    DP(("RFAL(mfe): mem=$%lx, size=%ld\n",
		me->me_Un.meu_Addr, me->me_Length));
	    RemoveFromAllocList(me->me_Un.meu_Addr, me->me_Length);
	}
	me++;
    } while (--numentries);
    /*
	The first MemEntry structure is included in a 'sizeof(struct MemList)',
	that is why we need to subtract one from NumEntries.
    */
    RemoveFromAllocList((APTR)ml, (ml->ml_NumEntries - 1) * sizeof(struct MemEntry) +
	sizeof(struct MemList));
    FreeEntry(ml);
}


/*
	Workbench tends to CurrentDir all over the place without
	saving the oldlock (returned by CurrentDir).  This can
	give Workbench no current dir when a lock is freeed.
	These routines are to be used in place of their DOS
	counterparts.  They provide a level of safety and allow
	me to debug for any stray locks.
*/

myparentdir(oldlock)
long oldlock;
{
	long newlock;

	newlock = ParentDir(oldlock);
	if (newlock) {
		DisplayLock(oldlock, "ParentDir");
		AddToLockList(newlock, "ParentDir");
	}
	return(newlock);
}

myduplock(oldlock)
long oldlock;
{
	long newlock;

	newlock = DupLock(oldlock);
	if (newlock) {
		DisplayLock(oldlock, "DupLock");
		AddToLockList(newlock, "DupLock");
	}
	return(newlock);
}

mycreatedir(name)
char *name;
{
	long lock;

	if (lock = CreateDir(name)) {
		AddToLockList(lock, "CreateDir");
	}
	return(lock);
}

BPTR mylock(name, accessmode)
char *name;
long accessmode;
{
	long lock;

	lock = Lock(name, accessmode);
	DP(("[Lock]: name='%s', lock=%lx", name, lock));
	if (lock) {
		AddToLockList(lock, "Lock");
	}
	return(lock);
}

void myunlock(lock)
BPTR lock;
{
	RemoveFromLockList(lock, "UnLock");
	UnLock(lock);
}

mycurrentdir(lock)
long lock;
{
	long oldlock;

	oldlock = CurrentDir(lock);
	DP(("[CurrentDir]: oldlock=%lx, lock=%lx\n", oldlock,  lock));
	DisplayLock(lock, "CurrentDir(lock)");
	if (!OnLockList(lock)) {
		DP(("mycurrentdir: to an unknown lock\n"));
		DisplayLockList();
		Debug(0L);
	}
	return(oldlock);
}

BOOL myassignlock(name, lock)
char *name;
BPTR lock;
{
	if (lock) {
	    RemoveFromLockList(lock, "AssignLock");
	}
	return(AssignLock(name,lock));
}

LockErrReport(lock)
LONG lock;
{
    struct FileLock *fl = (struct FileLock *)BADDR(lock);
	long result;

	DP(("LockErrReport: calling ErrorReport(REPORT_LOCK)..."));
	result = ErrorReport(IOERR(), REPORT_LOCK, lock, fl->fl_Task);
	DP(("ok, result = %ld\n", result));
	return(result);
}

VolumeErrReport(ad)
struct ActiveDisk *ad;
{
	long result;
	DP(("VolumeReport: calling ErrorReport(REPORT_VOLUME)..."));
	result = ErrorReport(IOERR(), REPORT_VOLUME, ad->ad_Volume, NULL);
	DP(("ok, result = %ld\n", result));
	return(result);
}

@


38.2
log
@Removed debugging info for now-obsolete workbenchbase structures
@
text
@d2 1
a2 1
 * $Id: debug.c,v 38.1 91/06/24 11:34:20 mks Exp Locker: mks $
d5 3
a26 1
    while (num--) DP(("\t"));
a32 9
    struct RegionRectangle *rr;

    DP(("||%s||\n", s));
    dumpRect("\tbounds", &r->bounds);
    for (rr = r->RegionRectangle; rr != NULL; rr = rr->Next)
    {
	dumpRect(" -", &rr->bounds);
    }
    DP(("\n"));
a38 6
    int numtabs;

    numtabs = (strlen(s))/8;
    DP(("%s", s));
    if ((numtabs = (4 - numtabs)) > 0) tabin( numtabs );
    DP(("X:[%ld,%ld]\tY:[%ld,%ld]\n",r->MinX,r->MaxX,r->MinY,r->MaxY));
a44 20
    static char *IDCMPStrings[32] = {
    "SIZEVERIFY", "NEWSIZE", "REFRESHWINDOW", "MOUSEBUTTONS", /* 1 - 4 */
    "MOUSEMOVE", "GADGETDOWN", "GADGETUP", "REQSET", /* 5 - 8 */
    "MENUPICK", "CLOSEWINDOW", "RAWKEY", "REQVERIFY", /* 9 - 12 */
    "REQCLEAR", "MENUVERIFY", "NEWPREFS", "DISKINSERTED", /* 13 - 16 */
    "DISKREMOVED", "WBENCHMESSAGE", "ACTIVEWINDOW", "INACTIVEWINDOW",
    "DELTAMOVE", "VANILLAKEY", "INTUITICKS", "800000", /* 21 - 24 */
    "1000000", "2000000", "4000000", "8000000", /* 25 - 28 */
    "10000000", "20000000", "40000000", "LONELYMESSAGE" /* 29 - 32 */
    };
    ULONG j;
    int i;

    DP(("PrintIDCMPFlags: IDCMPFlags = %lx\n", IDCMPFlags));
    for (i=0, j=1; i<32; i++, j <<= 1) {
	if (IDCMPFlags & j) {
	    DP(("%s ", IDCMPStrings[i]));
	}
    }
    DP(("\n"));
a50 26
	DP(("\tPrintNewDD: dd=%lx\n", dd));
	DP(("\t\tNewWindow=%lx\n", &dd->dd_NewWindow));
	DP(("\t\tCurrentX=%lx\n", dd->dd_CurrentX));
	DP(("\t\tCurrentY=%lx\n", dd->dd_CurrentY));
	DP(("\t\tFlags=%lx\n", dd->dd_Flags));
	DP(("\t\tViewModes=%lx\n", dd->dd_ViewModes));
	DP(("\t\tMinX=%lx\n", dd->dd_MinX));
	DP(("\t\tMinY=%lx\n", dd->dd_MinY));
	DP(("\t\tMaxX=%lx\n", dd->dd_MaxX));
	DP(("\t\tMaxY=%lx\n", dd->dd_MaxY));
/*
	DP(("\t\tHorizScroll=%lx\n", &dd->dd_HorizScroll));
	DP(("\t\tVertScroll=%lx\n", &dd->dd_VertScroll));
	DP(("\t\tUpMove=%lx\n", &dd->dd_UpMove));
	DP(("\t\tDownMove=%lx\n", &dd->dd_DownMove));
	DP(("\t\tLeftMove=%lx\n", &dd->dd_LeftMove));
	DP(("\t\tRightMove=%lx\n", &dd->dd_RightMove));
	DP(("\t\tHorizImage=%lx\n", &dd->dd_HorizImage));
	DP(("\t\tVertImage=%lx\n", &dd->dd_VertImage));
	DP(("\t\tHorizProp=%lx\n", &dd->dd_HorizProp));
	DP(("\t\tVertProp=%lx\n", &dd->dd_VertProp));
*/
	DP(("\t\tDrawerWin=%lx\n", dd->dd_DrawerWin));
	DP(("\t\tObject=%lx (%s)\n", dd->dd_Object, dd->dd_Object->wo_Name));
	DP(("\t\tChildren=%lx\n", &dd->dd_Children));
	DP(("\t\tLock=%lx\n", dd->dd_Lock));
a56 10
    DP(("\t\tPrintImage: image=$%lx\n", image));
    DP(("\t\t\tLeftEdge=%ld\n", image->LeftEdge));
    DP(("\t\t\tTopEdge=%ld\n", image->TopEdge));
    DP(("\t\t\tWidth=%ld\n", image->Width));
    DP(("\t\t\tHeight=%ld\n", image->Height));
    DP(("\t\t\tDepth=%ld\n", image->Depth));
    DP(("\t\t\tImageData=$%lx\n", image->ImageData));
    DP(("\t\t\tPlanePick=$%lx\n", image->PlanePick));
    DP(("\t\t\tPlaneOnOff=$%lx\n", image->PlaneOnOff));
    DP(("\t\t\tNextImage=$%lx\n", image->NextImage));
a62 20
    DP(("\tPrintGadget: gad=$%lx\n", gad));
    DP(("\t\tNextGadget=$%lx\n", gad->NextGadget));
    DP(("\t\tLeftEdge=%ld\n", gad->LeftEdge));
    DP(("\t\tTopEdge=%ld\n", gad->TopEdge));
    DP(("\t\tWidth=%ld\n", gad->Width));
    DP(("\t\tHeight=%ld\n", gad->Height));
    DP(("\t\tFlags=$%lx\n", gad->Flags));
    DP(("\t\tActivation=$%lx\n", gad->Activation));
    DP(("\t\tGadgetType=$%lx\n", gad->GadgetType));
    DP(("\t\tGadgetRender=$%lx\n", gad->GadgetRender));
    PrintImage(gad->GadgetRender);
    DP(("\t\tSelectRender=$%lx\n", gad->SelectRender));
    if (gad->SelectRender) {
	PrintImage(gad->SelectRender);
    }
    DP(("\t\tGadgetText=$%lx\n", gad->GadgetText));
    DP(("\t\tMutualExclude=$%lx\n", gad->MutualExclude));
    DP(("\t\tSpecialInfo=$%lx\n", gad->SpecialInfo));
    DP(("\t\tGadgetID=%ld\n", gad->GadgetID));
    DP(("\t\tUserData=$%lx\n", gad->UserData));
a68 50
    DP(("PrintWBObject: obj=$%lx (%s)\n", obj, obj->wo_Name));
    DP(("\tMasterNode=$%lx\n", obj->wo_MasterNode));
    DP(("\tSiblings=$%lx\n", obj->wo_Siblings));
    DP(("\tSelectNode=$%lx\n", obj->wo_SelectNode));
    DP(("\tUtilityNode=$%lx\n", obj->wo_UtilityNode));
    DP(("\tParent=$%lx\n", obj->wo_Parent));
    DP(("\tDefaultTool=$%lx\n", obj->wo_DefaultTool));
    DP(("\tToolWindow=$%lx\n", obj->wo_ToolWindow));
    DP(("\tToolTypes=$%lx\n", obj->wo_ToolTypes));
    DP(("\tDrawerData=$%lx\n", obj->wo_DrawerData));
    if (obj->wo_DrawerData) {
    	PrintNewDD(obj->wo_DrawerData);
    }
    DP(("\tCurrentX=$%lx\n", obj->wo_CurrentX));
    DP(("\tCurrentY=$%lx\n", obj->wo_CurrentY));
    DP(("\tStackSize=$%lx\n", obj->wo_StackSize));
    DP(("\tIOGadget=$%lx\n", &obj->wo_IOGadget));
    PrintGadget(&obj->wo_IOGadget);
    DP(("\tFlags=$%lx\n",
	obj->wo_DrawerSilent | obj->wo_DrawerOpen | obj->wo_Selected | obj->wo_Background |
	obj->wo_Invisible | obj->wo_AppIcon | obj->wo_Startup | obj->wo_FakeIcon));
    DP(("\t( "));
    if (obj->wo_DrawerSilent) DP(("DrawerSilent "));
    if (obj->wo_DrawerOpen) DP(("DrawerOpen "));
    if (obj->wo_Selected) DP(("Selected "));
    if (obj->wo_Background) DP(("Background "));
    if (obj->wo_Invisible) DP(("Invisible "));
    if (obj->wo_AppIcon) DP(("AppIcon "));
    if (obj->wo_Startup) DP(("Startup "));
    if (obj->wo_FakeIcon) DP(("FakeIcon "));
    DP((")"));
    DP(("\tType=$%lx\n", obj->wo_Type));
    DP(("\tUseCount=$%lx\n", obj->wo_UseCount));
    DP(("\tName=$%lx\n", obj->wo_Name));
    DP(("\tIconWin=$%lx\n", obj->wo_IconWin));
    DP(("\tLock=$%lx\n", obj->wo_Lock));
    DP(("\tNameXOffset=$%lx\n", obj->wo_NameXOffset));
    DP(("\tNameYOffset=$%lx\n", obj->wo_NameYOffset));
    DP(("\tFreeList=$%lx\n", &obj->wo_FreeList));
    DP(("\tNameBuffer='%s'\n", obj->wo_NameBuffer));
    DP(("\tSaveX=$%lx\n", obj->wo_SaveX));
    DP(("\tSaveY=$%lx\n", obj->wo_SaveY));
    DP(("\tFileSize=$%lx\n", obj->wo_FileSize));
    DP(("\tProtection=$%lx\n", obj->wo_Protection));
    DP(("\tGadget=$%lx\n", &obj->wo_Gadget));
    PrintGadget(&obj->wo_Gadget);
    DP(("\tDateStamp=$%lx\n", &obj->wo_DateStamp));
    DP(("\tNameImage=$%lx\n", &obj->wo_NameImage));
    PrintImage(&obj->wo_NameImage);
    DP(("\tImageSize=$%lx\n", obj->wo_ImageSize));
a74 2
	DP(("\tln=%lx, Type=%ld, Pri=%ld, Name='%s'\n",
		ln, ln->ln_Type, ln->ln_Pri, ln->ln_Name));
a80 15
    static char *Types[] = { "ROOT",
	"DISK", "DRAWER", "TOOL", "PROJECT",
	"GARBAGE", "DEVICE", "KICK", "APPICON"
    };
    int flags;

    flags = obj->wo_DrawerSilent | obj->wo_DrawerOpen | obj->wo_Selected |
	obj->wo_Background | obj->wo_Invisible | obj->wo_AppIcon |
	obj->wo_Startup | obj->wo_FakeIcon;
    DP(("obj=%lx (%s),\tpar=%lx, dd=%lx, lock=%lx, use=%ld, flags=%lx, %s\n",
	obj, obj->wo_Name, obj->wo_Parent, obj->wo_DrawerData,
	obj->wo_Lock, obj->wo_UseCount, flags, Types[obj->wo_Type]));
/*
    DP(("\tCurX=%ld ($%lx), CurY=%ld ($%lx), SaveX=%ld ($%lx), SaveY=%ld ($%lx)\n", obj->wo_CurrentX, obj->wo_CurrentX, obj->wo_CurrentY, obj->wo_CurrentY, obj->wo_SaveX, obj->wo_SaveX, obj->wo_SaveY, obj->wo_SaveY));
*/
a86 16
    char *bp, *fp, buf[256];
    int i;

    if (!bstr) {
	DP(("<NULL>\n"));
	return;
    }
    /* convert bcpl string to C */
    fp = (char *)BADDR(bstr);
    bp = buf;
    for (i = *fp++; i > 0; i--) {
	*bp++ = *fp++;
    }
    *bp = '\0';

    DP(("%s\n", buf));
a92 29
    DP(("PrintCLI: (%s) cli = $%lx\n", s, cli));
    if (cli) {
    DP(("\tcli_Result2 = $%lx\n", cli->cli_Result2));
    DP(("\tcli_SetName = $%lx ", cli->cli_SetName));
    PrintBString(cli->cli_SetName);
    DP(("\tcli_CommandDir = $%lx ($%lx)\n",
	cli->cli_CommandDir, cli->cli_CommandDir << 2));
    DP(("\tcli_ReturnCode = $%lx\n", cli->cli_ReturnCode));
    DP(("\tcli_CommandName = $%lx ", cli->cli_CommandName));
    PrintBString(cli->cli_CommandName);
    DP(("\tcli_FailLevel = $%lx\n", cli->cli_FailLevel));
    DP(("\tcli_Prompt = $%lx ", cli->cli_Prompt));
    PrintBString(cli->cli_Prompt);
    DP(("\tcli_StandardInput = $%lx ($%lx)\n",
	cli->cli_StandardInput, cli->cli_StandardInput << 2));
    DP(("\tcli_CurrentInput = $%lx ($%lx)\n",
	cli->cli_CurrentInput, cli->cli_CurrentInput << 2));
    DP(("\tcli_CommandFile = $%lx ", cli->cli_CommandFile));
    PrintBString(cli->cli_CommandFile);
    DP(("\tcli_Interactive = $%lx\n", cli->cli_Interactive));
    DP(("\tcli_Background = $%lx\n", cli->cli_Background));
    DP(("\tcli_CurrentOutput = $%lx ($%lx)\n",
	cli->cli_CurrentOutput, cli->cli_CurrentOutput << 2));
    DP(("\tcli_DefaultStack = $%lx\n", cli->cli_DefaultStack));
    DP(("\tcli_StandardOutput = $%lx ($%lx)\n",
	cli->cli_StandardOutput, cli->cli_StandardOutput << 2));
    DP(("\tcli_Module = $%lx ($%lx)\n",
	cli->cli_Module, cli->cli_Module << 2));
    }
a97 14
    char *bp, *fp, buf[256];
    int i;

    /* convert bcpl string to C */
    fp = (char *)BADDR(dl->dl_Name);
    bp = buf;
    for (i = *fp++; i > 0; i--) {
	*bp++ = *fp++;
    }
    *bp = '\0';

    DP(("\tdl 0x%lx/%s type %ld task 0x%lx disk 0x%lx, locklist 0x%lx\n",
    dl, buf, dl->dl_Type, dl->dl_Task, dl->dl_DiskType, dl->dl_LockList));

a103 1
	DP(("\taw=%lx, Ptr=%lx\n", aw, aw->wai_Ptr));
a109 1
	DP(("\tai=%lx, Ptr=%lx\n", ai, ai->wai_Ptr));
a115 6
	struct MenuItem *mi;
	struct IntuiText *it;

	mi = (struct MenuItem *)ami->wai_Ptr;
	it = (struct IntuiText *)mi->ItemFill;
	DP(("\tami=%lx, MenuItem=%lx, text='%s'\n", ami, mi, it->IText));
a121 3
	DP(("FP=%ld, BP=%ld, DM=%ld, Left=%ld, Top=%ld, IText='%s'\n",
		it->FrontPen, it->BackPen, it->DrawMode, it->LeftEdge,
		it->TopEdge, it->IText));
a128 5
	DP(("%s: NextItem=%lx, Left=%ld, Top=%ld, Width=%ld, Height=%ld\n",
		s, mi->NextItem, mi->LeftEdge, mi->TopEdge, mi->Width,
		mi->Height));
	DP(("Flags=%ld, ItemFIll=%lx\n", mi->Flags, mi->ItemFill));
	PrintIntuiText( (struct IntuiText *)mi->ItemFill );
a134 12
	struct MenuItem *mi;

	while (menu) {
	    mi = menu->FirstItem;

	    DP(("PrintMenuStrip: strip = '%s'\n", menu->MenuName));
	    do {
		    PrintMenuItem(mi, "");
	    } while (mi = mi->NextItem);
	    DP(("\n"));
	menu = menu->NextMenu;
	}
d142 1
a142 1
	struct FileInfoBlock *fib;
a143 30
	if (fib = (struct FileInfoBlock *)myallocmem(sizeof(struct FileInfoBlock), NULL)) {
		if (EXAMINE(lock, fib)) {
			DP(("[%s] lock=%lx '%s'\n", s, lock, fib->fib_FileName));
		}
		else {
			DP(("DisplayLock: Error could not Examine lock %lx\n",
				lock));
		}
		myfreemem(fib, sizeof(struct FileInfoBlock));
	}
	else {
		DP(("DisplayLock: Error, no mem for fib\n"));
	}
}

struct LockNode {
    /* copy of a node structure */
    struct LockNode *ln_Succ;	/* linkage */
    struct LockNode *ln_Pred;	/* linkage */
    UBYTE ln_Type;		/* not used */
    BYTE ln_Pri;		/* length of string (including the null) */
    char *ln_Name;		/* ptr to name associated with lock */
    /* end of copy of a node structure */
    long ln_Lock;		/* the lock itself */
    char ln_NameStorage;	/* storage for name associated with lock */
};

#define LOCKNODESIZE (sizeof(struct LockNode))

struct LockNode *
d147 1
a147 14
	struct FileInfoBlock *fib = NULL;
	struct LockNode *ln = NULL; /* assume not on list */

	if (!(fib = (struct FileInfoBlock *)myallocmem(sizeof(struct FileInfoBlock), NULL))) {
		DP(("OnLockList: Error, no mem for fib\n"));
	}
	else if (!EXAMINE(lock, fib)) {
		DP(("OnLockList: Error, could not Examine lock %lx\n", lock));
	}

	if (fib) {
		myfreemem(fib, sizeof(struct FileInfoBlock));
	}
	return(ln);
a153 26
	struct FileInfoBlock *fib = NULL;
	struct LockNode *ln;
	int len;

	if (ln = OnLockList(lock)) {
		DP(("[%s]: lock=%lx (%s) ALREADY ON LIST!\n",
			s, lock, ln->ln_Name));
		DisplayLockList();
		Debug(0L);
		goto end;
	}
	if (!(fib = (struct FileInfoBlock *)myallocmem(sizeof(struct FileInfoBlock), NULL))) {
		DP(("AddToLockList: Error, no mem for fib\n"));
		goto end;
	}
	if (!EXAMINE(lock, fib)) {
		DP(("AddToLockList: Error, could not Examine lock %lx\n",
			lock));
		goto end;
	}
	DisplayLock(lock, s);
	len = strlen(fib->fib_FileName) + 1;
end:
	if (fib) {
		myfreemem(fib, sizeof(struct FileInfoBlock));
	}
a159 12
	struct LockNode *ln;

	DisplayLock(lock, s);
	if (ln = OnLockList(lock)) { /* if on lock list... */
		Remove( (struct Node *)ln ); /* remove it */
		myfreemem(ln, LOCKNODESIZE + ln->ln_Pri);
	}
	else { /* lock was not on list */
		DP(("RemoveFromLockList: Error, tried to UnLock a bad lock\n"));
		DisplayLockList();
		Debug(0L);
	}
a163 2
	DP(("DisplayLockList:"));
	DP(("\tEND\n"));
a165 10
struct AllocEntry {
	APTR mem;
	LONG size;
	LONG type;
};

#define MAXALLOC	500
struct AllocEntry *AllocList = NULL;
static LONG TotalAlloc = 0, TotalBytes = 0;

a169 31
	struct AllocEntry *ptr;
	LONG position;

	if (!AllocList) {
		if (!(AllocList = AllocMem(sizeof(struct AllocEntry) * MAXALLOC, MEMF_CLEAR))) {
			DP(("ATAL: Fatal!  No mem for alloc list\n"));
			Debug(0L);
		}
		MP(("ATAL: allocated %ld bytes (@@$%lx) for alloc list\n",
			sizeof(struct AllocEntry) * MAXALLOC, AllocList));
	}

	if (OnAllocList(mem, size, TRUE, &position)) {
		DP(("ATAL: $%lx (%ld bytes) already allocated at position %ld\n", mem, size, position))
		DisplayAllocList();
		Debug(0L);
	}
	else if (TotalAlloc == MAXALLOC) {
		DP(("ATAL: AllocList full!  Increase MAXALLOC\n"));
		Debug(0L);
	}
	else {
		ptr = &AllocList[position];
		MP(("ATAL: adding $%lx (%ld bytes), pos=%ld (%lx)\n",
			mem, size, position, ptr));
		ptr->mem = mem;
		ptr->size = size;
		ptr->type = type;
		TotalAlloc++;
		TotalBytes += size;
	}
a175 35
	struct AllocEntry *ptr;
	LONG position;

	/* if on alloc list... */
	if (OnAllocList(mem, size, FALSE, &position)) {
		ptr = &AllocList[position];
		if (ptr->size != size) {
		    DP(("RFAL: Error, tried to remove wrong size mem\n"));
		    DP(("\tposition=%ld, mem=%lx, size=%ld\n",
			position, mem, size));
		    DisplayAllocList();
		    Debug(0L);
		}
		MP(("RFAL: removing $%lx (%ld bytes), pos=%ld (%lx)\n",
			mem, size, position, ptr));
		ptr->mem = NULL; /* no longer in use */
		ptr->size = 0;
		ptr->type = 0;
		TotalAlloc--;
		TotalBytes -= size;
	}
	/* mem was not on list, probably came from icon.library */
	else if (position < 0) {
		DP(("RFAL: Warning, mem=%lx, size=%ld not on list\n",
			mem, size));
/*		Debug(0L);
*/	}
	/* mem was not on list */
	else {
		MP(("RFAL: Error, tried to remove bad mem\n"));
		MP(("\tposition=%ld, mem=%lx, size=%ld\n",
			position, mem, size));
		DisplayAllocList();
		Debug(0L);
	}
a179 30
	struct AllocEntry *ptr;
	LONG i, j, alloc = 0, bytes = 0;

	DP(("DisplayAllocList: TotalAlloc=%ld, TotalBytes=%ld\n",
		TotalAlloc, TotalBytes));
	ptr = AllocList;
	for (i=MAXALLOC, j=0; i--, j<TotalAlloc;) {
		DP(("\t%ld: Mem=%lx, Size=%ld, Type=%lx ",
			MAXALLOC - i, ptr->mem, ptr->size, ptr->type));
		if (!ptr->type) {
		    DP(("NULL\n"));
		}
		else {
		    if (ptr->type & MEMF_CHIP) DP(("CHIP "));
		    if (ptr->type & MEMF_CLEAR) DP(("CLEAR"));
		    DP(("\n"));
		}
		if (ptr->mem) {
		    j++;
		    bytes += ptr->size;
		    alloc++;
		}
		ptr++;
	}
	DP(("\tEND: TotalAlloc=%ld, alloc=%ld, TotalBytes=%ld, bytes=%ld\n",
		TotalAlloc, alloc, TotalBytes, bytes));
	if (TotalAlloc != alloc || TotalBytes != bytes) {
	    DP(("DAL: ERROR: TotalAlloc (diff=%ld) or TotalBytes (diff=%ld) not correct!\n",
		alloc - TotalAlloc, bytes - TotalBytes));
	}
d188 1
a188 20
	struct AllocEntry *ptr;
	LONG i, result = FALSE; /* assume not on list */

	*position = -1; /* saftey net */
	ptr = AllocList;
	i = 0;
	do {
		if ((!ptr->mem) && free) {
			*position = i; /* return free position */
			break; /* not on list */
		}
		else if (ptr->mem == mem) {
			*position = i; /* mark position */
			result = TRUE; /* on list */
			break;
		}
		ptr++;
	} while (++i < MAXALLOC);
end:
	return(result);
a192 19
    struct AllocEntry *ptr;
    LONG i;

    DP(("FreeAllocList: enter\n"));
    if (ptr = AllocList) {
	i = MAXALLOC;
	do {
	    if (ptr->mem) {
		DP(("\tWARNING: freeing %ld bytes @@$%lx\n",
		    ptr->size, ptr->mem));
		FreeMem(ptr->mem, ptr->size);
	    }
	    ptr++;
	} while (--i);
	DP(("\tfreeing %ld bytes @@$%lx for AllocList\n",
	    sizeof(struct AllocEntry) * MAXALLOC, AllocList));
	FreeMem(AllocList, sizeof(struct AllocEntry) * MAXALLOC);
    }
    DP(("FreeAllocList: exit\n"));
a197 6
DP(("WBRename=%lx, WBRenameDisk=%lx, DosMove=%lx, BtoC=%lx\n",WBRename, WBRenameDisk, DosMove, BtoC));
DP(("GetWBIcon=%lx, WBGetWBObject=%lx, growNameImage=%lx, WBPutWBObject=%lx\n",GetWBIcon, WBGetWBObject, growNameImage, WBPutWBObject));
DP(("WBFreeWBObject=%lx, WBAllocWBObject=%lx\n",WBFreeWBObject, WBAllocWBObject));
PrintWorkbenchBase();
PrintWBObjectOffsets();
PrintNewDDOffsets();
a201 28
struct NewDD *dd = NULL;
ULONG ddx = 0;

DP(("\nPrintNewDDOffsets: sizeof(struct NewDD) = $%04lx  %04ld\n",
    sizeof(struct NewDD), sizeof(struct NewDD)));
DP(("$%04lx  %04ld  dd_NewWindow\n", (ULONG)&dd->dd_NewWindow - ddx, (ULONG)&dd->dd_NewWindow - ddx));
DP(("$%04lx  %04ld  dd_CurrentX\n", (ULONG)&dd->dd_CurrentX - ddx, (ULONG)&dd->dd_CurrentX - ddx));
DP(("$%04lx  %04ld  dd_CurrentY\n", (ULONG)&dd->dd_CurrentY - ddx, (ULONG)&dd->dd_CurrentY - ddx));
DP(("$%04lx  %04ld  dd_Flags\n", (ULONG)&dd->dd_Flags - ddx, (ULONG)&dd->dd_Flags - ddx));
DP(("$%04lx  %04ld  dd_ViewModes\n", (ULONG)&dd->dd_ViewModes - ddx, (ULONG)&dd->dd_ViewModes - ddx));
DP(("$%04lx  %04ld  dd_MinX\n", (ULONG)&dd->dd_MinX - ddx, (ULONG)&dd->dd_MinX - ddx));
DP(("$%04lx  %04ld  dd_MinY\n", (ULONG)&dd->dd_MinY - ddx, (ULONG)&dd->dd_MinY - ddx));
DP(("$%04lx  %04ld  dd_MaxX\n", (ULONG)&dd->dd_MaxX - ddx, (ULONG)&dd->dd_MaxX - ddx));
DP(("$%04lx  %04ld  dd_MaxY\n", (ULONG)&dd->dd_MaxY - ddx, (ULONG)&dd->dd_MaxY - ddx));
DP(("$%04lx  %04ld  dd_HorizScroll\n", (ULONG)&dd->dd_HorizScroll - ddx, (ULONG)&dd->dd_HorizScroll - ddx));
DP(("$%04lx  %04ld  dd_VertScroll\n", (ULONG)&dd->dd_VertScroll - ddx, (ULONG)&dd->dd_VertScroll - ddx));
DP(("$%04lx  %04ld  dd_UpMove\n", (ULONG)&dd->dd_UpMove - ddx, (ULONG)&dd->dd_UpMove - ddx));
DP(("$%04lx  %04ld  dd_DownMove\n", (ULONG)&dd->dd_DownMove - ddx, (ULONG)&dd->dd_DownMove - ddx));
DP(("$%04lx  %04ld  dd_LeftMove\n", (ULONG)&dd->dd_LeftMove - ddx, (ULONG)&dd->dd_LeftMove - ddx));
DP(("$%04lx  %04ld  dd_RightMove\n", (ULONG)&dd->dd_RightMove - ddx, (ULONG)&dd->dd_RightMove - ddx));
DP(("$%04lx  %04ld  dd_HorizImage\n", (ULONG)&dd->dd_HorizImage - ddx, (ULONG)&dd->dd_HorizImage - ddx));
DP(("$%04lx  %04ld  dd_VertImage\n", (ULONG)&dd->dd_VertImage - ddx, (ULONG)&dd->dd_VertImage - ddx));
DP(("$%04lx  %04ld  dd_HorizProp\n", (ULONG)&dd->dd_HorizProp - ddx, (ULONG)&dd->dd_HorizProp - ddx));
DP(("$%04lx  %04ld  dd_VertProp\n", (ULONG)&dd->dd_VertProp - ddx, (ULONG)&dd->dd_VertProp - ddx));
DP(("$%04lx  %04ld  dd_DrawerWin\n", (ULONG)&dd->dd_DrawerWin - ddx, (ULONG)&dd->dd_DrawerWin - ddx));
DP(("$%04lx  %04ld  dd_Object\n", (ULONG)&dd->dd_Object - ddx, (ULONG)&dd->dd_Object - ddx));
DP(("$%04lx  %04ld  dd_Children\n", (ULONG)&dd->dd_Children - ddx, (ULONG)&dd->dd_Children - ddx));
DP(("$%04lx  %04ld  dd_Lock\n", (ULONG)&dd->dd_Lock - ddx, (ULONG)&dd->dd_Lock - ddx));
a205 36
struct WBObject *obj = NULL;
ULONG objx = 0;

DP(("\nPrintWBObjectOffsets: sizeof(struct WBObject) = $%04lx  %04ld\n",
    sizeof(struct WBObject), sizeof(struct WBObject)));
DP(("$%04lx  %04ld  wo_MasterNode\n", (ULONG)&obj->wo_MasterNode - objx, (ULONG)&obj->wo_MasterNode - objx));
DP(("$%04lx  %04ld  wo_Siblings\n", (ULONG)&obj->wo_Siblings - objx, (ULONG)&obj->wo_Siblings - objx));
DP(("$%04lx  %04ld  wo_SelectNode\n", (ULONG)&obj->wo_SelectNode - objx, (ULONG)&obj->wo_SelectNode - objx));
DP(("$%04lx  %04ld  wo_UtilityNode\n", (ULONG)&obj->wo_UtilityNode - objx, (ULONG)&obj->wo_UtilityNode - objx));
DP(("$%04lx  %04ld  wo_Parent\n", (ULONG)&obj->wo_Parent - objx, (ULONG)&obj->wo_Parent - objx));
DP(("$%04lx  %04ld  wo_DefaultTool\n", (ULONG)&obj->wo_DefaultTool - objx, (ULONG)&obj->wo_DefaultTool - objx));
DP(("$%04lx  %04ld  wo_ToolWindow\n", (ULONG)&obj->wo_ToolWindow - objx, (ULONG)&obj->wo_ToolWindow - objx));
DP(("$%04lx  %04ld  wo_ToolTypes\n", (ULONG)&obj->wo_ToolTypes - objx, (ULONG)&obj->wo_ToolTypes - objx));
DP(("$%04lx  %04ld  wo_DrawerData\n", (ULONG)&obj->wo_DrawerData - objx, (ULONG)&obj->wo_DrawerData - objx));
DP(("$%04lx  %04ld  wo_CurrentX\n", (ULONG)&obj->wo_CurrentX - objx, (ULONG)&obj->wo_CurrentX - objx));
DP(("$%04lx  %04ld  wo_CurrentY\n", (ULONG)&obj->wo_CurrentY - objx, (ULONG)&obj->wo_CurrentY - objx));
DP(("$%04lx  %04ld  wo_StackSize\n", (ULONG)&obj->wo_StackSize - objx, (ULONG)&obj->wo_StackSize - objx));
DP(("$%04lx  %04ld  wo_IOGadget\n", (ULONG)&obj->wo_IOGadget - objx, (ULONG)&obj->wo_IOGadget - objx));
DP(("$%04lx  %04ld  wo_Type\n", (ULONG)&obj->wo_Type - objx, (ULONG)&obj->wo_Type - objx));
DP(("$%04lx  %04ld  wo_UseCount\n", (ULONG)&obj->wo_UseCount - objx, (ULONG)&obj->wo_UseCount - objx));
DP(("$%04lx  %04ld  wo_Name\n", (ULONG)&obj->wo_Name - objx, (ULONG)&obj->wo_Name - objx));
DP(("$%04lx  %04ld  wo_IconWin\n", (ULONG)&obj->wo_IconWin - objx, (ULONG)&obj->wo_IconWin - objx));
DP(("$%04lx  %04ld  wo_Lock\n", (ULONG)&obj->wo_Lock - objx, (ULONG)&obj->wo_Lock - objx));
DP(("$%04lx  %04ld  wo_NameXOffset\n", (ULONG)&obj->wo_NameXOffset - objx, (ULONG)&obj->wo_NameXOffset - objx));
DP(("$%04lx  %04ld  wo_NameYOffset\n", (ULONG)&obj->wo_NameYOffset - objx, (ULONG)&obj->wo_NameYOffset - objx));
DP(("$%04lx  %04ld  wo_FreeList\n", (ULONG)&obj->wo_FreeList - objx, (ULONG)&obj->wo_FreeList - objx));
DP(("$%04lx  %04ld  wo_NameBuffer\n", (ULONG)&obj->wo_NameBuffer - objx, (ULONG)&obj->wo_NameBuffer - objx));
DP(("$%04lx  %04ld  wo_DiskObject\n", (ULONG)&obj->wo_DiskObject - objx, (ULONG)&obj->wo_DiskObject - objx));
DP(("$%04lx  %04ld  wo_SaveX\n", (ULONG)&obj->wo_SaveX - objx, (ULONG)&obj->wo_SaveX - objx));
DP(("$%04lx  %04ld  wo_SaveY\n", (ULONG)&obj->wo_SaveY - objx, (ULONG)&obj->wo_SaveY - objx));
DP(("$%04lx  %04ld  wo_FileSize\n", (ULONG)&obj->wo_FileSize - objx, (ULONG)&obj->wo_FileSize - objx));
DP(("$%04lx  %04ld  wo_Protection\n", (ULONG)&obj->wo_Protection - objx, (ULONG)&obj->wo_Protection - objx));
DP(("$%04lx  %04ld  wo_Gadget\n", (ULONG)&obj->wo_Gadget - objx, (ULONG)&obj->wo_Gadget - objx));
DP(("$%04lx  %04ld  wo_DateStamp\n", (ULONG)&obj->wo_DateStamp - objx, (ULONG)&obj->wo_DateStamp - objx));
DP(("$%04lx  %04ld  wo_NameImage\n", (ULONG)&obj->wo_NameImage - objx, (ULONG)&obj->wo_NameImage - objx));
DP(("$%04lx  %04ld  wo_ImageSize\n", (ULONG)&obj->wo_ImageSize - objx, (ULONG)&obj->wo_ImageSize - objx));
a209 86
struct WorkbenchBase *wb = getWbBase();
ULONG wx = (ULONG)wb;

DP(("\nPrintWorkbenchBase: sizeof(struct WorkbenchBase) = $%04lx  %04ld\n",
    sizeof(struct WorkbenchBase), sizeof(struct WorkbenchBase)));
DP(("$%04lx  %04ld  wb_Library\n", (ULONG)&wb->wb_Library - wx, (ULONG)&wb->wb_Library - wx));
DP(("$%04lx  %04ld  wb_UpdateNestCnt\n", (ULONG)&wb->wb_UpdateNestCnt - wx, (ULONG)&wb->wb_UpdateNestCnt - wx));
DP(("$%04lx  %04ld  wb_DiskIONestCnt\n", (ULONG)&wb->wb_DiskIONestCnt - wx, (ULONG)&wb->wb_DiskIONestCnt - wx));
DP(("$%04lx  %04ld  wb_SegList\n", (ULONG)&wb->wb_SegList - wx, (ULONG)&wb->wb_SegList - wx));
DP(("$%04lx  %04ld  wb_MasterList\n", (ULONG)&wb->wb_MasterList - wx, (ULONG)&wb->wb_MasterList - wx));
DP(("$%04lx  %04ld  wb_SelectList\n", (ULONG)&wb->wb_SelectList - wx, (ULONG)&wb->wb_SelectList - wx));
DP(("$%04lx  %04ld  wb_ActiveDisks\n", (ULONG)&wb->wb_ActiveDisks - wx, (ULONG)&wb->wb_ActiveDisks - wx));
DP(("$%04lx  %04ld  wb_UtilityList\n", (ULONG)&wb->wb_UtilityList - wx, (ULONG)&wb->wb_UtilityList - wx));
DP(("$%04lx  %04ld  wb_Buf0\n", (ULONG)&wb->wb_Buf0[0] - wx, (ULONG)&wb->wb_Buf0[0] - wx));
DP(("$%04lx  %04ld  wb_Buf1\n", (ULONG)&wb->wb_Buf1[0] - wx, (ULONG)&wb->wb_Buf1[0] - wx));
DP(("$%04lx  %04ld  wb_SysBase\n", (ULONG)&wb->wb_SysBase - wx, (ULONG)&wb->wb_SysBase - wx));
DP(("$%04lx  %04ld  wb_GfxBase\n", (ULONG)&wb->wb_GfxBase - wx, (ULONG)&wb->wb_GfxBase - wx));
DP(("$%04lx  %04ld  wb_IntuitionBase\n", (ULONG)&wb->wb_IntuitionBase - wx, (ULONG)&wb->wb_IntuitionBase - wx));
DP(("$%04lx  %04ld  wb_IconBase\n", (ULONG)&wb->wb_IconBase - wx, (ULONG)&wb->wb_IconBase - wx));
DP(("$%04lx  %04ld  wb_DOSBase\n", (ULONG)&wb->wb_DOSBase - wx, (ULONG)&wb->wb_DOSBase - wx));
DP(("$%04lx  %04ld  wb_LayersBase\n", (ULONG)&wb->wb_LayersBase - wx, (ULONG)&wb->wb_LayersBase - wx));
DP(("$%04lx  %04ld  wb_TimerBase\n", (ULONG)&wb->wb_TimerBase - wx, (ULONG)&wb->wb_TimerBase - wx));
DP(("$%04lx  %04ld  wb_GadToolsBase\n", (ULONG)&wb->wb_GadToolsBase - wx, (ULONG)&wb->wb_GadToolsBase - wx));
DP(("$%04lx  %04ld  wb_DosInfo\n", (ULONG)&wb->wb_DosInfo - wx, (ULONG)&wb->wb_DosInfo - wx));
DP(("$%04lx  %04ld  wb_TimerRequest\n", (ULONG)&wb->wb_TimerRequest - wx, (ULONG)&wb->wb_TimerRequest - wx));
DP(("$%04lx  %04ld  wb_XOffset\n", (ULONG)&wb->wb_XOffset - wx, (ULONG)&wb->wb_XOffset - wx));
DP(("$%04lx  %04ld  wb_YOffset\n", (ULONG)&wb->wb_YOffset - wx, (ULONG)&wb->wb_YOffset - wx));
DP(("$%04lx  %04ld  wb_RootObject\n", (ULONG)&wb->wb_RootObject - wx, (ULONG)&wb->wb_RootObject - wx));
DP(("$%04lx  %04ld  wb_CurrentGadget\n", (ULONG)&wb->wb_CurrentGadget - wx, (ULONG)&wb->wb_CurrentGadget - wx));
DP(("$%04lx  %04ld  wb_CurrentWindow\n", (ULONG)&wb->wb_CurrentWindow - wx, (ULONG)&wb->wb_CurrentWindow - wx));
DP(("$%04lx  %04ld  wb_CurrentObject\n", (ULONG)&wb->wb_CurrentObject - wx, (ULONG)&wb->wb_CurrentObject - wx));
DP(("$%04lx  %04ld  wb_WaitPointer\n", (ULONG)&wb->wb_WaitPointer - wx, (ULONG)&wb->wb_WaitPointer - wx));
DP(("$%04lx  %04ld  wb_CurrentError\n", (ULONG)&wb->wb_CurrentError - wx, (ULONG)&wb->wb_CurrentError - wx));
DP(("$%04lx  %04ld  wb_LastFreeMem\n", (ULONG)&wb->wb_LastFreeMem - wx, (ULONG)&wb->wb_LastFreeMem - wx));
DP(("$%04lx  %04ld  wb_IconFont\n", (ULONG)&wb->wb_IconFont - wx, (ULONG)&wb->wb_IconFont - wx));
DP(("$%04lx  %04ld  wb_IconAttr\n", (ULONG)&wb->wb_IconAttr - wx, (ULONG)&wb->wb_IconAttr - wx));
DP(("$%04lx  %04ld  wb_TextFont\n", (ULONG)&wb->wb_TextFont - wx, (ULONG)&wb->wb_TextFont - wx));
DP(("$%04lx  %04ld  wb_TextAttr\n", (ULONG)&wb->wb_TextAttr - wx, (ULONG)&wb->wb_TextAttr - wx));
DP(("$%04lx  %04ld  wb_LeftImage\n", (ULONG)&wb->wb_LeftImage - wx, (ULONG)&wb->wb_LeftImage - wx));
DP(("$%04lx  %04ld  wb_RightImage\n", (ULONG)&wb->wb_RightImage - wx, (ULONG)&wb->wb_RightImage - wx));
DP(("$%04lx  %04ld  wb_UpImage\n", (ULONG)&wb->wb_UpImage - wx, (ULONG)&wb->wb_UpImage - wx));
DP(("$%04lx  %04ld  wb_DownImage\n", (ULONG)&wb->wb_DownImage - wx, (ULONG)&wb->wb_DownImage - wx));
DP(("$%04lx  %04ld  wb_WorkbenchPort\n", (ULONG)&wb->wb_WorkbenchPort - wx, (ULONG)&wb->wb_WorkbenchPort - wx));
DP(("$%04lx  %04ld  wb_IntuiPort\n", (ULONG)&wb->wb_IntuiPort - wx, (ULONG)&wb->wb_IntuiPort - wx));
DP(("$%04lx  %04ld  wb_SeenPort\n", (ULONG)&wb->wb_SeenPort - wx, (ULONG)&wb->wb_SeenPort - wx));
DP(("$%04lx  %04ld  wb_NotifyPort\n", (ULONG)&wb->wb_NotifyPort - wx, (ULONG)&wb->wb_NotifyPort - wx));
DP(("$%04lx  %04ld  wb_Tick\n", (ULONG)&wb->wb_Tick - wx, (ULONG)&wb->wb_Tick - wx));
DP(("$%04lx  %04ld  wb_ScreenTitle\n", (ULONG)&wb->wb_ScreenTitle[0] - wx, (ULONG)&wb->wb_ScreenTitle[0] - wx));
DP(("$%04lx  %04ld  wb_IconRast\n", (ULONG)&wb->wb_IconRast - wx, (ULONG)&wb->wb_IconRast - wx));
DP(("$%04lx  %04ld  wb_TextRast\n", (ULONG)&wb->wb_TextRast - wx, (ULONG)&wb->wb_TextRast - wx));
DP(("$%04lx  %04ld  wb_Argument\n", (ULONG)&wb->wb_Argument - wx, (ULONG)&wb->wb_Argument - wx));
DP(("$%04lx  %04ld  wb_Task\n", (ULONG)&wb->wb_Task - wx, (ULONG)&wb->wb_Task - wx));
DP(("$%04lx  %04ld  wb_BobList\n", (ULONG)&wb->wb_BobList - wx, (ULONG)&wb->wb_BobList - wx));
DP(("$%04lx  %04ld  wb_BobMem\n", (ULONG)&wb->wb_BobMem - wx, (ULONG)&wb->wb_BobMem - wx));
DP(("$%04lx  %04ld  wb_LastX\n", (ULONG)&wb->wb_LastX - wx, (ULONG)&wb->wb_LastX - wx));
DP(("$%04lx  %04ld  wb_LastY\n", (ULONG)&wb->wb_LastY - wx, (ULONG)&wb->wb_LastY - wx));
DP(("$%04lx  %04ld  wb_Screen\n", (ULONG)&wb->wb_Screen - wx, (ULONG)&wb->wb_Screen - wx));
DP(("$%04lx  %04ld  wb_BackWindow\n", (ULONG)&wb->wb_BackWindow - wx, (ULONG)&wb->wb_BackWindow - wx));
DP(("$%04lx  %04ld  wb_GelsInfo\n", (ULONG)&wb->wb_GelsInfo - wx, (ULONG)&wb->wb_GelsInfo - wx));
DP(("$%04lx  %04ld  wb_IconFontHeight\n", (ULONG)&wb->wb_IconFontHeight - wx, (ULONG)&wb->wb_IconFontHeight - wx));
DP(("$%04lx  %04ld  wb_APen\n", (ULONG)&wb->wb_APen - wx, (ULONG)&wb->wb_APen - wx));
DP(("$%04lx  %04ld  wb_BPen\n", (ULONG)&wb->wb_BPen - wx, (ULONG)&wb->wb_BPen - wx));
DP(("$%04lx  %04ld  wb_DrawMode\n", (ULONG)&wb->wb_DrawMode - wx, (ULONG)&wb->wb_DrawMode - wx));
DP(("$%04lx  %04ld  wb_AppWindowList\n", (ULONG)&wb->wb_AppWindowList - wx, (ULONG)&wb->wb_AppWindowList - wx));
DP(("$%04lx  %04ld  wb_AppIconList\n", (ULONG)&wb->wb_AppIconList - wx, (ULONG)&wb->wb_AppIconList - wx));
DP(("$%04lx  %04ld  wb_AppMenuItemList\n", (ULONG)&wb->wb_AppMenuItemList - wx, (ULONG)&wb->wb_AppMenuItemList - wx));
DP(("$%04lx  %04ld  wb_InfoList\n", (ULONG)&wb->wb_InfoList - wx, (ULONG)&wb->wb_InfoList - wx));
DP(("$%04lx  %04ld  wb_NonInfoList\n", (ULONG)&wb->wb_NonInfoList - wx, (ULONG)&wb->wb_NonInfoList - wx));
DP(("$%04lx  %04ld  wb_MaxTextWidth\n", (ULONG)&wb->wb_MaxTextWidth - wx, (ULONG)&wb->wb_MaxTextWidth - wx));
DP(("$%04lx  %04ld  wb_ToolExitCnt\n", (ULONG)&wb->wb_ToolExitCnt - wx, (ULONG)&wb->wb_ToolExitCnt - wx));
DP(("$%04lx  %04ld  wb->wb_AppMenuItemCnt\n", (ULONG)&wb->wb_AppMenuItemCnt - wx, (ULONG)&wb->wb_AppMenuItemCnt - wx));
DP(("$%04lx  %04ld  wb->wb_shinePen\n", (ULONG)&wb->wb_shinePen - wx, (ULONG)&wb->wb_shinePen - wx));
DP(("$%04lx  %04ld  wb->wb_shadowPen\n", (ULONG)&wb->wb_shadowPen - wx, (ULONG)&wb->wb_shadowPen - wx));
DP(("$%04lx  %04ld  wb->wb_EmboseBorderTop\n", (ULONG)&wb->wb_EmboseBorderTop - wx, (ULONG)&wb->wb_EmboseBorderTop - wx));
DP(("$%04lx  %04ld  wb->wb_EmboseBorderBottom\n", (ULONG)&wb->wb_EmboseBorderBottom - wx, (ULONG)&wb->wb_EmboseBorderBottom - wx));
DP(("$%04lx  %04ld  wb->wb_EmboseBorderLeft\n", (ULONG)&wb->wb_EmboseBorderLeft - wx, (ULONG)&wb->wb_EmboseBorderLeft - wx));
DP(("$%04lx  %04ld  wb->wb_EmboseBorderRight\n", (ULONG)&wb->wb_EmboseBorderRight - wx, (ULONG)&wb->wb_EmboseBorderRight - wx));
DP(("$%04lx  %04ld  wb->wb_MenuStrip\n", (ULONG)&wb->wb_MenuStrip - wx, (ULONG)&wb->wb_MenuStrip - wx));
DP(("$%04lx  %04ld  wb->wb_ToolMenu\n", (ULONG)&wb->wb_ToolMenu - wx, (ULONG)&wb->wb_ToolMenu - wx));
DP(("$%04lx  %04ld  wb->wb_HiddenMenu\n", (ULONG)&wb->wb_HiddenMenu - wx, (ULONG)&wb->wb_HiddenMenu - wx));
DP(("$%04lx  %04ld  wb->wb_LayerDemonRequest\n", (ULONG)&wb->wb_LayerDemonRequest - wx, (ULONG)&wb->wb_LayerDemonRequest - wx));
DP(("$%04lx  %04ld  wb->wb_LayerPort\n", (ULONG)&wb->wb_LayerPort - wx, (ULONG)&wb->wb_LayerPort - wx));
DP(("$%04lx  %04ld  wb->wb_VisualInfo\n", (ULONG)&wb->wb_VisualInfo - wx, (ULONG)&wb->wb_VisualInfo - wx));
DP(("$%04lx  %04ld  wb->wb_ExecuteBuf\n", (ULONG)&wb->wb_ExecuteBuf - wx, (ULONG)&wb->wb_ExecuteBuf - wx));
DP(("$%04lx  %04ld  wb->wb_AsyncCopyCnt\n", (ULONG)&wb->wb_AsyncCopyCnt - wx, (ULONG)&wb->wb_AsyncCopyCnt - wx));
DP(("$%04lx  %04ld  wb->wb_Word2\n", (ULONG)&wb->wb_Word2 - wx, (ULONG)&wb->wb_Word2 - wx));
a215 5
    ULONG mem;

    DP(("PrintAvailMem: [%s] type=$%lx, ", msg, type));
    mem = AvailMem(type | MEMF_LARGEST);
    DP(("largest=$%lx (%ld)\n", mem, mem));
@


38.1
log
@Initial V38 tree checkin - Log file stripped
@
text
@d2 1
a2 1
 * $Id$
d4 4
a7 1
 * $Log$
a419 1
	struct WorkbenchBase *wb = getWbBase();
a424 1
		goto end;
d426 1
a426 1
	if (!EXAMINE(lock, fib)) {
a427 1
		goto end;
d429 1
a429 10
	for (ln = (struct LockNode *)wb->wb_LockList.lh_Head; ln->ln_Succ; ln = ln->ln_Succ) {
		/* if lock is on Lock list, flag it and exit */
		if (ln->ln_Lock == lock) {
/*			if (!(stricmp(ln->ln_Name, fib->fib_FileName))) {
*/				goto end; /* on list */
/*			}
*/		}
	}
	ln = NULL; /* not on list */
end:
a439 1
	struct WorkbenchBase *wb = getWbBase();
a461 10
	if (ln = (struct LockNode *)myallocmem(LOCKNODESIZE + len, NULL)) {
		ln->ln_Pri = len;
		ln->ln_Lock = lock;
		ln->ln_Name = &ln->ln_NameStorage;
		strcpy(ln->ln_Name, fib->fib_FileName);
		AddHead( &wb->wb_LockList, (struct Node *)ln );
	}
	else {
		DP(("AddToLockList: Error, no mem for node\n"));
	}
d488 1
a488 7
	struct WorkbenchBase *wb = getWbBase();
	struct LockNode *ln;

	DP(("DisplayLockList:\n"));
	for (ln = (struct LockNode *)wb->wb_LockList.lh_Head; ln->ln_Succ; ln = ln->ln_Succ) {
		DP(("\tLock=%lx, Name='%s'\n", ln->ln_Lock, ln->ln_Name));
	}
a771 1
DP(("$%04lx  %04ld  wb_DiskfontBase\n", (ULONG)&wb->wb_DiskfontBase - wx, (ULONG)&wb->wb_DiskfontBase - wx));
a815 4
DP(("$%04lx  %04ld  wb_WBPat\n", (ULONG)&wb->wb_WBPat - wx, (ULONG)&wb->wb_WBPat - wx));
DP(("$%04lx  %04ld  wb_WinPat\n", (ULONG)&wb->wb_WinPat - wx, (ULONG)&wb->wb_WinPat - wx));
DP(("$%04lx  %04ld  wb_IconFontName\n", (ULONG)&wb->wb_IconFontName - wx, (ULONG)&wb->wb_IconFontName - wx));
DP(("$%04lx  %04ld  wb_TextFontName\n", (ULONG)&wb->wb_TextFontName - wx, (ULONG)&wb->wb_TextFontName - wx));
a817 2
DP(("$%04lx  %04ld  wb_NotifyList\n", (ULONG)&wb->wb_NotifyList - wx, (ULONG)&wb->wb_NotifyList - wx));
DP(("$%04lx  %04ld  wb_LockList\n", (ULONG)&wb->wb_LockList - wx, (ULONG)&wb->wb_LockList - wx));
@
