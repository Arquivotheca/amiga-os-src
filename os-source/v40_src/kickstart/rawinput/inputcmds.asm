	TTL	'$Id: inputcmds.asm,v 36.4 90/05/22 12:10:45 kodiak Exp $'
**********************************************************************
*								     *
*   Copyright 1985, Commodore-Amiga Inc.   All rights reserved.	     *
*   No part of this program may be reproduced, transmitted,	     *
*   transcribed, stored in retrieval system, or translated into	     *
*   any language or computer language, in any form or by any	     *
*   means, electronic, mechanical, magnetic, optical, chemical,	     *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030				     *
*								     *
**********************************************************************
*
*	input device commands
*
*   Source Control
*   --------------
*   $Id: inputcmds.asm,v 36.4 90/05/22 12:10:45 kodiak Exp $
*
*   $Locker:  $
*
*   $Log:	inputcmds.asm,v $
*   Revision 36.4  90/05/22  12:10:45  kodiak
*   corrects documentation to reflect that IND_WRITEEVENT events cannot
*   be chained
*   
*   Revision 36.3  90/04/13  12:44:33  kodiak
*   use Id instead of Header for 4.x rcs
*   
*   Revision 36.2  90/04/02  12:58:01  kodiak
*   for rcs 4.x header change
*   
*   Revision 36.1  90/01/19  18:06:13  kodiak
*   make SetMXxxx commands synchronous
*   
*   Revision 35.2  90/01/04  13:27:37  kodiak
*   polish autodoc headers
*   
*   Revision 35.1  89/07/31  17:13:31  kodiak
*   autodoc change
*   
*   Revision 35.0  87/10/26  11:31:15  kodiak
*   initial from V34, but w/ stripped log
*   
*   
**********************************************************************

	SECTION		rawinput

*------ Included Files -----------------------------------------------

	INCLUDE		"exec/types.i"
	INCLUDE		"exec/nodes.i"
	INCLUDE		"exec/lists.i"
	INCLUDE		"exec/memory.i"
	INCLUDE		"exec/ports.i"
	INCLUDE		"exec/libraries.i"
	INCLUDE		"exec/devices.i"
	INCLUDE		"exec/tasks.i"
	INCLUDE		"exec/io.i"
	INCLUDE		"exec/strings.i"
	INCLUDE		"exec/interrupts.i"
	INCLUDE		"exec/errors.i"

	INCLUDE		"devices/timer.i"
	INCLUDE		"inputevent.i"
	INCLUDE		"gameport.i"

	INCLUDE		"macros.i"
	INCLUDE		"stddevice.i"
	INCLUDE		"iddata.i"


*------ Imported Names -----------------------------------------------


*------ Imported Functions -------------------------------------------

	XREF_EXE	Enqueue
	XREF_EXE	Signal

	XREF		DispatchEvents

	XREF		EndCommand

	XREF		ReopenMouse
	XREF		AbortMouse
	XREF		TypeMouse
	XREF		TrigMouse
	XREF		ReadMouse


*------ Exported Names -----------------------------------------------

	XDEF		IDClear
	XDEF		IDStart
	XDEF		IDAddHandler
	XDEF		IDRemHandler
	XDEF		IDWriteEvent
	XDEF		IDSetThresh
	XDEF		IDSetPeriod
	XDEF		IDSetMPort
	XDEF		IDSetMType
	XDEF		IDSetMTrig

	XDEF		IDCBClear
	XDEF		IDCBStart
	XDEF		IDCBSetThresh
	XDEF		IDCBSetPeriod

	IFNE	gpt_SIZEOF-8
	FAIL	"gpt_SIZEOF not 8, recode"
	ENDC

*------ input.device/command/Clear ********************************
*
*   NAME
*	Clear - clear input buffer
*
*   FUNCTION
*	Remove from input buffers any input reports waiting to
*	satisfy read requests.
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set if quick I/O is not possible
*	io_Device	preset by the call to OpenDevice
*	io_Unit		preset by the call to OpenDevice
*	io_Command	CMD_CLEAR
*	io_Flags	IOB_QUICK set if quick I/O is possible
*
**********************************************************************
IDCBClear	EQU	-1

IDClear:
		RTS

*****i* input.device/CMD_START ***************************************
*
*   NAME
*	Start - restart after stop
*
*   FUNCTION
*	Start restarts the unit after a stop command.
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set if quick I/O is not possible
*	io_Device	preset by the call to OpenDevice
*	io_Unit		preset by the call to OpenDevice
*	io_Command	CMD_START
*	io_Flags	IOB_QUICK set if quick I/O is possible
*
**********************************************************************
IDCBStart	EQU	-1

IDStart:
		MOVE.L	A1,-(A7)
		MOVE.L	IO_UNIT(A1),A0
		BCLR	#DUB_STOPPED,du_Flags(A0)
		BEQ.S	sRts

		LEA	id_TC(A6),A1
		MOVE.B	MP_SIGBIT(A0),D1
		MOVEQ	#0,D0
		BSET	D1,D0
		LINKEXE	Signal

sRts:
		MOVE.L	(A7)+,A1
		BRA.S	endOKCommand


******* input.device/IND_ADDHANDLER **********************************
*
*   NAME
*	IND_ADDHANDLER -- Add an input handler to the device
*
*   FUNCTION
*	Add a function to the list of functions called to handle
*	input events generated by this device.  The function is called
*	as
*	    newInputEvents = Handler(inputEvents, handlerData);
*	    D0			     A0		  A1
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set
*	io_Device	preset by OpenDevice
*	io_Unit		preset by OpenDevice
*	io_Command	IND_ADDHANDLER
*	io_Data		a pointer to an interrupt structure.
*	    is_Data 	the handlerData pointer described above
*	    is_Code	the Handler function address
*
*   NOTES
*	The interrupt structure is kept by the input device until a
*	RemHandler command is satisfied for it.
*
**********************************************************************
IDAddHandler:
		MOVE.L	A1,-(A7)
		MOVE.L	IO_DATA(A1),A1
		LEA	id_HandlerList(A5),A0
		CALLEXE	Enqueue
		MOVE.L	(A7)+,A1
		MOVE.L	A6,-(A7)
		MOVE.L	A5,A6
		BSR.S	endOKCommand
		MOVE.L	(A7)+,A6
		RTS


******* input.device/IND_REMHANDLER **********************************
*
*   NAME
*	IND_REMHANDLER -- Remove an input handler from the device
*
*   FUNCTION
*	Remove a function previously added to the list of handler
*	functions.
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set
*	io_Device	preset by OpenDevice
*	io_Unit		preset by OpenDevice
*	io_Command	IND_REMHANDLER
*	io_Data		a pointer to the interrupt structure.
*
*   NOTES
*	This command is not immediate
*
**********************************************************************
IDRemHandler:
		MOVE.L	A1,-(A7)
		MOVE.L	IO_DATA(A1),A1
		REMOVE
		MOVE.L	(A7)+,A1
		MOVE.L	A6,-(A7)
		MOVE.L	A5,A6
		BSR.S	endOKCommand
		MOVE.L	(A7)+,A6
		RTS


******* input.device/IND_WRITEEVENT **********************************
*
*   NAME
*	IND_WRITEEVENT -- Propagate an input event to all handlers
*
*   FUNCTION
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set if quick I/O is not possible
*	io_Device	preset by the call to OpenDevice
*	io_Unit		preset by the call to OpenDevice
*	io_Command	IND_WRITEEVENT
*	io_Flags	IOB_QUICK set if quick I/O is possible
*	io_Length	should be sizeof(struct InputEvent)
*	io_Data		a pointer to the struct InputEvent:
*	    ie_NextEvent
*			will be ignored.
*	    ie_Class
*	    ie_SubClass
*	    ie_Code 
*	    ie_Qualifier 
*	    ie_X, ie_Y
*			as desired
*	    ie_TimeStamp 
*			will be set by this call (V36)
*
*   NOTES
*	The contents of the input event are destroyed.
*
*	This function was documented in V34 and earlier to allow
*	chaining of events via ie_NextEvent.  The implementation
*	never allowed that.  The documentation now reflects this.
*
*	ie_TimeStamp is set only in V36 and later.  Software written
*	to run on earlier versions should set this field to the
*	current time.
*
**********************************************************************
IDWriteEvent:
		MOVE.L	A1,-(A7)
		MOVE.L	IO_DATA(A1),A3
		BSR	DispatchEvents
		MOVE.L	(A7)+,A1
		MOVE.L	A6,-(A7)
		MOVE.L	A5,A6
		BSR.S	endOKCommand
		MOVE.L	(A7)+,A6
		RTS


******* input.device/IND_SETTHRESH ***********************************
*
*   NAME
*	IND_SETTHRESH -- Set the key repeat threshold
*
*   FUNCTION
*	This command sets the time that a key must be held down before
*	it can repeat.  The repeatability of a key may be restricted
*	(as, for example, are the shift keys).
*
*	This command always executes immediately.
*
*   IO REQUEST - a timerequest
*	tr_node.io_Message	mn_ReplyPort set if quick I/O is not possible
*	tr_node.io_Device	preset by the call to OpenDevice
*	tr_node.io_Unit		preset by the call to OpenDevice
*	tr_node.io_Command	IND_SETTHRESH
*	tr_node.io_Flags	IOB_QUICK set if quick I/O is possible
*	tr_time.tv_secs		the threshold seconds
*	tr_time.tv_micro	the threshold microseconds
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*	This quite simply saves the contents of the repeat threshold
*
*---------------------------------------------------------------------
IDCBSetThresh	EQU	-1

IDSetThresh:
		MOVE.L	IOTV_TIME+TV_SECS(A1),id_Thresh+TV_SECS(A6)
		MOVE.L	IOTV_TIME+TV_MICRO(A1),id_Thresh+TV_MICRO(A6)
endOKCommand:
		MOVEQ	#0,D0
		BRA	EndCommand


******* input.device/IND_SETPERIOD ***********************************
*
*   NAME
*	IND_SETPERIOD -- Set the key repeat period
*
*   FUNCTION
*	This command sets the period at which a repeating key repeats.
*
*	This command always executes immediately.
*
*   IO REQUEST - a timerequest
*	tr_node.io_Message	mn_ReplyPort set if quick I/O is not possible
*	tr_node.io_Device	preset by the call to OpenDevice
*	tr_node.io_Unit		preset by the call to OpenDevice
*	tr_node.io_Command	IND_SETPERIOD
*	tr_node.io_Flags	IOB_QUICK set if quick I/O is possible
*	tr_time.tv_secs		the repeat period seconds
*	tr_time.tv_micro	the repeat period microseconds
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*	This quite simply saves the contents of the repeat period
*
*---------------------------------------------------------------------
IDCBSetPeriod	EQU	-1

IDSetPeriod:
		MOVE.L	IOTV_TIME+TV_SECS(A1),id_Period+TV_SECS(A6)
		MOVE.L	IOTV_TIME+TV_MICRO(A1),id_Period+TV_MICRO(A6)
		BRA.S	endOKCommand


******* input.device/IND_SETMPORT ************************************
*
*   NAME
*	IND_SETMPORT -- Set the current mouse port
*
*   FUNCTION
*	This command sets the gameport port at which the mouse is
*	connected.
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set if quick I/O is not possible
*	io_Device	preset by the call to OpenDevice
*	io_Unit		preset by the call to OpenDevice
*	io_Command	IND_SETMPORT
*	io_Flags	IOB_QUICK set if quick I/O is possible
*	io_Length	1
*	io_Data		a pointer to a byte that is either 0 or 1,
*			indicating that mouse input should be obtained
*			from either the left or right controller port,
*			respectively.
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*	This stores the IO_DATA into the correct mouse port variable.
*
*---------------------------------------------------------------------
IDSetMPort:
		move.l	IO_LENGTH(a1),d0
		subq.w	#1,d0
		bcs.s	mLenErr
		move.l	IO_DATA(a1),a0
		move.b	(a0),id_MPort(a5)
		move.l	a1,-(a7)
		bsr	ReopenMouse
		bra.s	mEndOKCommand


******* input.device/IND_SETMTYPE ************************************
*
*   NAME
*	IND_SETMTYPE -- Set the current mouse port controller type
*
*   FUNCTION
*	This command sets the type of device at the mouse port, so
*	the signals at the port may be properly interpreted.
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set if quick I/O is not possible
*	io_Device	preset by the call to OpenDevice
*	io_Unit		preset by the call to OpenDevice
*	io_Command	IND_SETMTYPE
*	io_Flags	IOB_QUICK set if quick I/O is possible
*	io_Length	1
*	io_Data		the address of the byte variable describing
*			the controller type, as per the equates in
*			the gameport include file
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*	This stores the IO_DATA into the correct mouse port variable.
*
*---------------------------------------------------------------------
IDSetMType:
		move.l	IO_LENGTH(a1),d0
		subq.w	#1,d0
		bcs.s	mLenErr
		move.l	IO_DATA(a1),a0
		move.b	(a0),id_MType(a5)
		move.l	a1,-(a7)
		bsr	AbortMouse
		bsr	TypeMouse
		bsr	ReadMouse

mEndOKCommand:
		move.l	(a7)+,a1
		moveq	#0,d0
mEndCommand:
		move.l	a6,-(a7)
		move.l	a5,a6
		bsr	EndCommand
		move.l	(a7)+,a6
		rts

mLenErr:
		moveq	#IOERR_BADLENGTH,d0
		bra.s	mEndCommand

******* input.device/IND_SETMTRIG ************************************
*
*   NAME
*	IND_SETMTRIG -- Set the conditions for a mouse port report
*
*   FUNCTION
*	This command sets what conditions must be met by a mouse
*	before a pending Read request will be satisfied.  The trigger
*	specification is that used by the gameport device.
*
*   IO REQUEST
*	io_Message	mn_ReplyPort set if quick I/O is not possible
*	io_Device	preset by the call to OpenDevice
*	io_Unit		preset by the call to OpenDevice
*	io_Command	IND_SETMTRIG
*	io_Flags	IOB_QUICK set if quick I/O is possible
*	io_Length	sizeof(gameportTrigger)
*	io_Data		a structure of type GameportTrigger, which
*			has the following elements
*	    gpt_Keys -
*		    GPTB_DOWNKEYS set if button down transitions
*		    trigger a report, and GPTB_UPKEYS set if button up
*		    transitions trigger a report
*	    gpt_Timeout	-
*		    a time which, if exceeded, triggers a report;
*		    measured in vertical blank units (60/sec)
*	    gpt_XDelta	-
*		    a distance in x which, if exceeded, triggers a
*		    report
*	    gpt_YDelta	-
*		    a distance in x which, if exceeded, triggers a
*		    report
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*	This quite simply stores the correct mouse port trigger info
*	from the buffer pointed to by IO_DATA.
*
*---------------------------------------------------------------------
IDSetMTrig:
		move.l	IO_LENGTH(a1),d0
		subq.w	#gpt_SIZEOF,d0
		bcs.s	mLenErr
		move.l	IO_DATA(a1),a0
		move.l	(a0)+,id_MTrig(a5)
		move.l	(a0),id_MTrig+4(a5)
		moveq	#gpt_SIZEOF,d0
		move.l	d0,IO_ACTUAL(a1)
		move.l	a1,-(a7)
		bsr	AbortMouse
		bsr	TrigMouse
		bsr	ReadMouse
		bra.s	mEndOKCommand

	END
