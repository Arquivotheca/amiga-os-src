head     36.67;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @* @;


36.67
date     93.03.05.17.41.33;  author jesup;  state Exp;
branches ;
next     36.66;

36.66
date     92.08.25.16.19.34;  author jesup;  state Exp;
branches ;
next     36.65;

36.65
date     92.08.09.16.52.07;  author jesup;  state Exp;
branches ;
next     36.64;

36.64
date     92.05.12.22.08.50;  author jesup;  state Exp;
branches ;
next     36.63;

36.63
date     91.05.22.21.18.16;  author jesup;  state Exp;
branches ;
next     36.62;

36.62
date     91.05.17.22.10.12;  author jesup;  state Exp;
branches ;
next     36.61;

36.61
date     91.04.25.02.50.49;  author jesup;  state Exp;
branches ;
next     36.60;

36.60
date     91.04.12.22.00.11;  author jesup;  state Exp;
branches ;
next     36.59;

36.59
date     91.04.10.18.59.10;  author jesup;  state Exp;
branches ;
next     36.58;

36.58
date     91.03.14.21.33.17;  author jesup;  state Exp;
branches ;
next     36.57;

36.57
date     91.02.22.23.06.26;  author jesup;  state Exp;
branches ;
next     36.56;

36.56
date     91.02.22.20.28.51;  author jesup;  state Exp;
branches ;
next     36.55;

36.55
date     91.02.19.22.51.10;  author jesup;  state Exp;
branches ;
next     36.54;

36.54
date     91.02.19.02.15.16;  author jesup;  state Exp;
branches ;
next     36.53;

36.53
date     91.02.18.18.58.42;  author jesup;  state Exp;
branches ;
next     36.52;

36.52
date     91.02.13.19.06.09;  author jesup;  state Exp;
branches ;
next     36.51;

36.51
date     91.01.30.16.25.43;  author jesup;  state Exp;
branches ;
next     36.50;

36.50
date     91.01.24.16.03.42;  author jesup;  state Exp;
branches ;
next     36.49;

36.49
date     91.01.17.15.03.31;  author jesup;  state Exp;
branches ;
next     36.48;

36.48
date     91.01.10.18.57.54;  author jesup;  state Exp;
branches ;
next     36.47;

36.47
date     90.12.21.16.55.17;  author jesup;  state Exp;
branches ;
next     36.46;

36.46
date     90.12.18.19.34.15;  author jesup;  state Exp;
branches ;
next     36.45;

36.45
date     90.12.17.22.53.17;  author jesup;  state Exp;
branches ;
next     36.44;

36.44
date     90.12.16.02.27.58;  author jesup;  state Exp;
branches ;
next     36.43;

36.43
date     90.12.10.20.37.03;  author jesup;  state Exp;
branches ;
next     36.42;

36.42
date     90.12.06.00.46.17;  author jesup;  state Exp;
branches ;
next     36.41;

36.41
date     90.12.03.07.09.10;  author jesup;  state Exp;
branches ;
next     36.40;

36.40
date     90.12.02.07.01.36;  author jesup;  state Exp;
branches ;
next     36.39;

36.39
date     90.12.01.04.05.38;  author jesup;  state Exp;
branches ;
next     36.38;

36.38
date     90.11.21.02.25.56;  author jesup;  state Exp;
branches ;
next     36.37;

36.37
date     90.09.06.18.38.25;  author jesup;  state Exp;
branches ;
next     36.36;

36.36
date     90.08.31.15.57.23;  author jesup;  state Exp;
branches ;
next     36.35;

36.35
date     90.08.30.23.47.54;  author jesup;  state Exp;
branches ;
next     36.34;

36.34
date     90.08.01.19.40.21;  author jesup;  state Exp;
branches ;
next     36.33;

36.33
date     90.07.30.00.03.49;  author jesup;  state Exp;
branches ;
next     36.32;

36.32
date     90.06.07.03.02.53;  author jesup;  state Exp;
branches ;
next     36.31;

36.31
date     90.05.31.07.00.15;  author jesup;  state Exp;
branches ;
next     36.30;

36.30
date     90.05.24.15.54.35;  author jesup;  state Exp;
branches ;
next     36.29;

36.29
date     90.05.09.02.15.51;  author jesup;  state Exp;
branches ;
next     36.28;

36.28
date     90.04.07.04.05.03;  author jesup;  state Exp;
branches ;
next     36.27;

36.27
date     90.04.06.11.59.51;  author jesup;  state Exp;
branches ;
next     36.26;

36.26
date     90.04.03.05.07.16;  author jesup;  state Exp;
branches ;
next     36.25;

36.25
date     90.04.03.04.43.14;  author jesup;  state Exp;
branches ;
next     36.24;

36.24
date     90.03.17.23.59.40;  author jesup;  state Exp;
branches ;
next     36.23;

36.23
date     90.03.03.02.20.58;  author jesup;  state Exp;
branches ;
next     36.22;

36.22
date     90.02.16.22.23.31;  author jesup;  state Exp;
branches ;
next     36.21;

36.21
date     90.02.02.17.26.12;  author jesup;  state Exp;
branches ;
next     36.20;

36.20
date     90.02.01.04.28.14;  author jesup;  state Exp;
branches ;
next     36.19;

36.19
date     90.01.29.01.58.13;  author jesup;  state Exp;
branches ;
next     36.18;

36.18
date     89.12.16.19.48.24;  author jesup;  state Exp;
branches ;
next     36.17;

36.17
date     89.12.15.00.07.41;  author jesup;  state Exp;
branches ;
next     36.16;

36.16
date     89.12.13.00.47.54;  author jesup;  state Exp;
branches ;
next     36.15;

36.15
date     89.12.10.22.35.50;  author jesup;  state Exp;
branches ;
next     36.14;

36.14
date     89.12.09.11.02.12;  author jesup;  state Exp;
branches ;
next     36.13;

36.13
date     89.12.09.01.54.18;  author jesup;  state Exp;
branches ;
next     36.12;

36.12
date     89.12.08.17.12.31;  author jesup;  state Exp;
branches ;
next     36.11;

36.11
date     89.12.08.07.16.19;  author jesup;  state Exp;
branches ;
next     36.10;

36.10
date     89.12.05.21.37.46;  author jesup;  state Exp;
branches ;
next     36.9;

36.9
date     89.12.03.14.43.43;  author jesup;  state Exp;
branches ;
next     36.8;

36.8
date     89.12.01.08.17.09;  author jesup;  state Exp;
branches ;
next     36.7;

36.7
date     89.11.22.03.20.05;  author jesup;  state Exp;
branches ;
next     36.6;

36.6
date     89.11.14.01.27.32;  author jesup;  state Exp;
branches ;
next     36.5;

36.5
date     89.10.24.18.26.56;  author jesup;  state Exp;
branches ;
next     36.4;

36.4
date     89.10.18.04.26.32;  author jesup;  state Exp;
branches ;
next     36.3;

36.3
date     89.10.03.18.09.18;  author jesup;  state Exp;
branches ;
next     36.2;

36.2
date     89.09.21.22.01.41;  author jesup;  state Exp;
branches ;
next     36.1;

36.1
date     89.09.16.22.06.53;  author jesup;  state Exp;
branches ;
next     ;


desc
@@


36.67
log
@timer.device is now not needed for OpenDevice (exec V40.5).  Use 0 instead.
@
text
@	PLEN 55
	TTL    "*** TRIPOS Kernel for the CAPC ***"
******************************************************************
*                                                                *
* This version a major rewrite for the CAPC by TJK Jan 85        *
* (C) Copyright 1985 Metacomco, 26 Portland Square, BRISTOL, UK  *
* All rights reserved                                            *
*                                                                *
* This is based to a small extent on the original TRIPOS kernel  *
* for the 68000 written by Martin Richards at the University of  *
* Cambridge                                                      *
*                                                                *
******************************************************************
	SPC 4
******************************************************************
******************************************************************
*****        **       *****  ****       ****      ****     *******
********  *****  ***   ****  ****  ***   **   **   **   **  ******
********  *****  ****  ****  ****  ****  **  ****  **   **********
********  *****  ***   ****  ****  ***   **  ****  ***   *********
********  *****       *****  ****       ***  ****  ****   ********
********  *****  **  ******  ****  ********  ****  *****   *******
********  *****  ***  *****  ****  ********  ****  ******   ******
********  *****  ****  ****  ****  ********   **   **  **   ******
********  *****  *****  ***  ****  *********      ****     *******
******************************************************************
******************************************************************
	SPC 4
******************************************************************
*                                                                *
*        A 32 bit kernel for TRIPOS for the MC68000 system       *
*                                                                *
*                                                                *
******************************************************************
	PAGE
	SPC 4
* Register usage when in BCPL compiled code.
*
*      D0       work reg - used to hold the stack increment
*                          in a procedure call
*      D1       the first argument and result register
*      D2-D4    the second to fourth argument registers
*      D5-D7    general work registers
*      Z (=A0)  hold the constant 0 (to allow n(Z,Di.L) addresses)
*      P (=A1)  BCPL P pointer (MC address of first arg)
*      G (=A2)  BCPL G pointer (MC address of global 0)
*      L (=A3)  work reg - (hold the return address in the
*                           entry and return sequences)
*      B (=A4)  base reg - (hold the MC address of entry to the
*                           current procedure. It is necessary
*                           for position independent addressing
*                           of data in program code.  Note that
*                           instruction and data space MUST be
*                           the same)
*      S (=A5)  MC address of the save S/R:        Timings Totals
*                  MOVE.L	(SP)+,L                  6
*                  MOVEM.L   P/L/B,-12(P,D0.L)       19
*                  ADDA.L    D0,P                     7
*                  MOVEM.L   D1-D4,(P)               20
*                  JMP       (B)                      4      32
*      R (=A6)  MC address of the return code:
*                  MOVEM.L   -12(P),P/L              16
*                  MOVE.L	-4(P),B                  8
*                  JMP       (L)                      4      28
*      SP(=A7)the system stack pointer
*
* The (typical) calling sequence is:
*
*         MMOVEQ    #36,D0     Stack increment         2
*         MOVE.L   n(G),B     (calling a global)      8
*         JSR      (S)        Call the save routine   4      14
*
* To return from a procedure:
*
*         JMP      (R)                                4       4
*
*
	PAGE
	INCLUDE "exec/types.i"
	INCLUDE "exec/nodes.i"
	INCLUDE "exec/lists.i"
	INCLUDE "exec/memory.i"
	INCLUDE "exec/ports.i"
	INCLUDE "exec/libraries.i"
	INCLUDE "exec/devices.i"
	INCLUDE "exec/io.i"
	INCLUDE "exec/tasks.i"
	INCLUDE "exec/resident.i"
	INCLUDE "exec/execbase.i"
	INCLUDE "exec/alerts.i"
	INCLUDE "exec/ables.i"
	INCLUDE "exec/errors.i"
	INCLUDE "exec/initializers.i"

	INCLUDE "libraries/expansion.i"
	INCLUDE "libraries/expansionbase.i"

	INCLUDE "intuition/preferences.i"

	INCLUDE "internal/librarytags.i"

	INCLUDE "dos/dos.i"
	INCLUDE "dos/dosextens.i"
	INCLUDE "dos/filehandler.i"

	INCLUDE "libhdr.i"
	INCLUDE "fault.i"
	INCLUDE "calldos.i"

	INCLUDE "dos_rev.i"

	INT_ABLES

FUNCDEF MACRO
	XREF _LVO\1
	ENDM

	INCLUDE "exec/exec_lib.i"

	XREF	_LVOSetPrefs
	XREF	_LVOSDivMod32
	XREF	_LVOUDivMod32
	XREF	_LVOSMult32  
	XREF	_LVOCacheClearE
	XREF	_LVOTaggedOpenLibrary

*
* blib, etc routines
*
BLIB	MACRO	;\1 - symbolname
	XREF	_\1
@@\1	EQU	_\1
	ENDM

*
* external defs
*
	XDEF	_doslibname
	XDEF	_consolename
	XDEF	_ramname
	XDEF	_shellname
	XDEF	_SEGLIST
	XDEF	@@ClearICache
	XDEF	get_ubase	; hits a6!
	XDEF	@@multiply
	XDEF	@@udiv32
	XDEF	_udiv32
	XDEF	@@divrem32
	XDEF	_divrem32
	XDEF	@@div32
	XDEF	_div32
	XDEF	@@rem32
	XDEF	_rem32
*	XDEF	@@createtask
*	XDEF	_createtask
*	XDEF	@@createproc
*	XDEF	_createproc
	XDEF	_activecode
	XDEF	@@activecode
	XDEF	_deactcode
	XDEF	@@deactcode
	XDEF	_CNP_ActiveCode
	XDEF	@@CNP_ActiveCode
	XDEF	@@MakeProc
	XDEF	@@AddSegArray
	XDEF	@@AllocVecPub
	XDEF	_AllocVecPub
	XDEF	@@AllocVecPubClear
	XDEF	_AllocVecPubClear
	XDEF	_freeVec
	XDEF	@@bcpl_qpkt
	XDEF	_bcpl_qpkt
	XDEF	@@qpkt
	XDEF	_qpkt
	XDEF	@@qpkt_task
	XDEF	_qpkt_task
	XDEF	@@returnpkt
	XDEF	_returnpkt
	XDEF	@@taskwait
	XDEF	@@taskid
	XDEF	@@myproc
	XDEF	@@GetProgramDir
	XDEF	@@ArgStr
	XDEF	_CurrentDir
	XDEF	@@SetProgramDir
	XDEF	@@SetArgStr
	XDEF	@@seglist
	XDEF	@@consoletask
	XDEF	@@setconsole
	XDEF	_setconsole
	XDEF	@@getresult2
	XDEF	@@input
	XDEF	@@output
	XDEF	@@cli
	XDEF	@@filesystemtask
	XDEF	@@setfilesys
	XDEF	_setfilesys
	XDEF	@@setresult2
	XDEF	@@SetIoErr
	XDEF	@@result2
	XDEF	@@currentdir
	XDEF	_currentdir
	XDEF	@@selectinput
	XDEF	_selectinput
	XDEF	@@selectoutput
	XDEF	_selectoutput
	XDEF	@@rootstruct
	XDEF	@@abort
	XDEF	_abort
	XDEF	@@InternalRunCommand
	XDEF	_InternalRunCommand
	XDEF	@@exit
	XDEF	@@opendosbase
	XDEF	@@dosbase
	XDEF	@@store_IBase
	XDEF	@@MySetPrefs
	XDEF	doslib_createproc
	XDEF	_deletetask

	XDEF	CALLDOS
	XDEF	SAVE
	XDEF	RET

	XDEF	J_OPEN
	XDEF	J_CLOSE
	XDEF	J_NOP
*
* requester handler routine
*
	XREF	@@requester
	XREF	@@requester2
	XREF	@@strlen

	XREF	@@getstring
	BLIB	createtask
	BLIB	createproc
	BLIB	freeobj
	BLIB	endstream
	XREF	@@freevars
	BLIB	UnLoadSeg
	XREF	@@CleanupProc
	BLIB	RunCommand
*
* dos errors
*
	XREF	_dos_errors

*
* BCPL stuff
*
	XREF	MLIB_SEG
	XREF	FAKEBLIB_SEG
	XREF	FAKECLI_SEG
	XREF	CONHANDLER
	XREF	FILEHANDLER

	XREF	JTAB		; dos jump table init
	XREF	_end		; end of dos module

*
* debug stuff
*

	XREF	_kprintf

*DEBUG	EQU	1

DBUG	macro
	ifd	DEBUG

	; save all regs
	movem.l	d0/d1/a0/a1,-(a7)

; first stack up to eight arguments for the printf routine
	IFGE	NARG-9
		move.l	\9,-(sp)		; stack arg8
	ENDC
	IFGE	NARG-8
		move.l	\8,-(sp)		; stack arg7
	ENDC
	IFGE	NARG-7
		move.l	\7,-(sp)		; stack arg6
	ENDC
	IFGE	NARG-6
		move.l	\6,-(sp)		; stack arg5
	ENDC
	IFGE	NARG-5
		move.l	\5,-(sp)		; stack arg4
	ENDC
	IFGE	NARG-4
		move.l	\4,-(sp)		; stack arg3
	ENDC
	IFGE	NARG-3
		move.l	\3,-(sp)		; stack arg2
	ENDC
*	IFGE	NARG-2
*		move.l	\2,-(sp)		; stack arg1
*	ENDC

STKOFF	SET	(NARG-1)<<2			; actual stack space used
	pea.l	n1\@@
	jsr	_kprintf
	lea.l	STKOFF(sp),sp			; scrap stuff on stack
	movem.l	(a7)+,d0/d1/a0/a1
	bra.s	n2\@@

n1\@@	dc.b	\1,10,0
	cnop	0,2
n2\@@
	endc
	endm

* KLUDGE is because of a bug in CAPE
KLUDGE	 EQU	1

* to allow InitResident for testing
*NOT_REAL EQU	1

	IFND	KLUDGE
	XREF	BCPLCtoB
	XREF	BCPLBtoC
	XREF	CLEARVEC
	XREF	COPYSTRING
	XREF	COPYVEC
	XREF	UNPACKSTRING
	XREF	PACKSTRING
	ENDC

	PAGE
	TTL "** TRIPOS Kernel  -   Equates **"
*
*
* Symbol definitions and data structures
*
*
LIBWORD   EQU    23456               Marks library routines
SECWORD   EQU    12345               Marks a BCPL section
*NOTINUSE  EQU       -1               Link word for dequeued packets
NEGSIZE   EQU	NEGATIVE_GLOBAL_SIZE Number of negative globals
GLOBSIZE  EQU	UG                   NUmber of positive globals
ROOTSIZE  EQU	rn_SIZEOF	     size of rootnode
SEGSIZE   EQU	3 		     Size of SegVec for CreateProc
GVSIZE    EQU	(NEGSIZE+GLOBSIZE+1)*4
*CLI_UPB   EQU       15               Upper bound of CLI structure
CLISTK    EQU   800		     Stack used for initial CLI (was 400)
				     ; Changed to match Execute/Run/System.
				     ; note - in longwords

*DOSSTK    EQU     1500		     Stack used by DOS when called

*
* Absolute areas
*
SysBase	    EQU	    4
*

SIGMASK   EQU     $100               Signal bit 8 mask
MSGSIG    EQU        8               Signal 8 used for message handling
FLGSIG    EQU       12               Signals 12-15 used for testflag/setflag

*
* Register definition
*

Z         EQUR    A0                 Constant Zero
P         EQUR    A1                 BCPL P ptr
G         EQUR    A2                 BCPL G ptr
L         EQUR    A3                 Work reg
B         EQUR    A4                 Addr of current procedure
S         EQUR    A5                 Save routine addr
R         EQUR    A6                 Return addr

*
*
* Coroutine symbols
*

C_LINK    EQU        0               Link to next co-routine
C_CLLR    EQU        4               Caller coroutine
C_SEND    EQU        8               Stack end - 32
C_RESP    EQU       12               Resumption ptr
C_FUNC    EQU       16               Function
*                   20               PC dump - dummy
C_RTRN    EQU       24               Return link for stop

*
* Global vector symbols
*
* Not used here, but the BCPL c: commands (via bcplstartup.asm) set all unused
* globals to this.  This is worse than silly on amigados, they should point to
* a guru/alert with a specific number.  - REJ
*
*UNGLOB    EQU $474C0001              (Unset global n is UNGLOB + 2*n)
*
*
* Nucleus primitives
*
	; moved to libhdr.i


	PAGE
	TTL      "** TRIPOS Kernel - Macro definitions"
*
* Macro definitions
*
* Module header
*
SECT    MACRO
**        CNOP   0,4
**        DC.L   LIBWORD
**        DC.B   7,\1
	ENDM
*
* Call EXEC with A6 already set
*
CALL    MACRO
	JSR          _LVO\1(A6)
	ENDM
*
* Call EXEC with A6 not set
*
CALLS   MACRO
	MOVE.L	SysBase,A6
	CALL	\1
	ENDM

	PAGE
******************************************************************
*                                                                *
*         Kernel initialisation                                  *
*                                                                *
******************************************************************
	SECTION doslib,CODE

KLIB_SEG  DC.L	     0			; no next section
KLIB      DC.L       (KEND-KLIB)/4	; The size of the module for segment
*
* We are entered at KSTART from bootstrap.
* This Tripos derivative does not have any
* fixed locations within it, and most primitive calls are handled by EXEC.
*
* Where TRIPOS uses task numbers we use here EXEC ports so that we can use
* the EXEC message passing mechanism.
*
	BRA.S	KINIT	; Jump past segment list (keep lword aligned)
*
* Initialisation consists of starting up the initial CLI task. We create
* a new task and set it up so that when it starts executing it will initialise
* registers in a suitable fashion. We also need to build an initial segment
* list for this task. The Tripos image loaded into memory is built by SYSL
* so that the code segment table is patched to contain the correct values.
*
* We can now link with external symbols, however BPTRs are a pain - REJ
* This is (effectively) a segarray structure, is used in pr_SegList
* This will have to be copied into real memory and turned into BPTRs.
*

	CNOP	0,4
_SEGLIST
	DC.L	4<<2            ; Size of segment list*4: init will undo *4
	DC.L	KLIB_SEG        ; segment - CPTR! KLIB
	DC.L	FAKEBLIB_SEG    ; segment - CPTR! blib stubs
	DC.L	0		; MLIB_SEG	     segment - CPTR! mlib
	DC.L	FAKECLI_SEG     ; segment - CPTR! cli stubs
	DC.L	0		; CONHANDLER  syssegl[5]
	DC.L	0		; FILEHANDLER syssegl[6]
	DC.L	0		; restart     syssegl[7] (not used)
	DC.L	0		; cli c entrypoint syssegl[8]
	DC.L	0		; ram seglist syssegl[9]
SEGLISTEND

INITSEGSIZE	  EQU	     (SEGLISTEND-_SEGLIST)/4	; for initialization

*
* Create initial task after setting up suitable registers
*

* put in a rom tag, so we can find it later.
* not coldstart, we're started by the boot code of a device

romtag:
	DC.W	RTC_MATCHWORD		;(50) UWORD RT_MATCHWORD
	DC.L	romtag			;(52) APTR  RT_MATCHTAG
	DC.L	_end			;(56) APTR  RT_ENDSKIP
	DC.B	0; RTW_COLDSTART	;(5A) UBYTE RT_FLAGS
	DC.B	VERSION			;(5B) UBYTE RT_VERSION
	DC.B	NT_LIBRARY		;(5C) UBYTE RT_TYPE
	DC.B	-120			;(5D) BYTE  RT_PRI
	DC.L	LIBNAME			;(5E) APTR  RT_NAME
	DC.L	idtag			;(62) APTR  RT_IDSTRING
	DC.L	KINIT			;(66) APTR  RT_INIT
						;(6A) LABEL RT_SIZE

idtag:	VSTRING
	ds.w	0


KINIT:
	DBUG <"in dos init code">

    IFD NOT_REAL
	MOVEM.L	d2-d7/a2-a6,-(sp)
    ENDC
* sysbase in a6 is NOT guaranteed because we're NOT inited by InitResident
*
	MOVE.L	SysBase,A6		; Library base register
*
* Initialise DOS library. This involves copying the node to real RAM
* and allocating space for rootnode and shared GV
*
* Allocate everything with DOSBase, to save code/frags.
* We get the base, a timerreq, the RootNode, and the shared global vector.
* Also space for a seglist for the console-handler (and the filesystem)
*
CONSEGSIZE	EQU	3*4
RAMSEGSIZE	EQU	3*4
BASESIZE	EQU	dl_SIZEOF+2+ROOTSIZE+GVSIZE+CONSEGSIZE+IOTV_SIZE+RAMSEGSIZE

	MOVE.L	#BASESIZE,D0		; size of data area everything
	LEA	JTAB,A0			; vector table
	SUB.L	A1,A1			; no initstruct table
	MOVE.L	A1,A2			; no init routine (return to me)
					; with no init routine, d1 is spurious
	CALL	MakeLibrary
	TST.L	D0
	BEQ	DISASTER
	MOVE.L	D0,A5			; A5 points to library base
	OR.B	#LIBF_SUMUSED!LIBF_CHANGED,LIB_FLAGS(a5)
*
* Turn on the data cache if it exists
*
*USE_CACHE_CALLS	EQU	1
*
* &$#%^$%*(*#&$ Hurricane boards crash if data cache is turned on without
* MMU tables to disable caching for chip mem and IO registers.
* #$#(*&%*&^%^@@(*&$
*
	IFD	USE_CACHE_CALLS
DBITS	EQU   CACRF_WriteAllocate!CACRF_ClearD!CACRF_EnableD
CBITS	EQU   CACRF_IBE!CACRF_ClearI!CACRF_EnableI

	MOVE.L	#DBITS!CBITS,D0
	MOVEQ	#-1,D1			; affect all bits
	CALL	CacheControl
	ENDC
*
* Setup the dl_Errors pointer.
*
	LEA	_dos_errors,A0
	MOVE.L	A0,dl_Errors(A5)
*
* Open utility.library
*
	MOVEQ	#OLTAG_UTILITY,d0	; utility library, any version
	CALL	TaggedOpenLibrary
	MOVE.L	D0,dl_UtilityBase(A5)
	BEQ	DISASTER
*
* Now build the rootnode (MUST be cleared - Makelibrary guarantees this!)
* Used as an exec message later!!!!!
* +2 is because a library structure is odd-sized, and the root must be on
* a longword boundary!
*
	LEA	dl_SIZEOF+2(a5),A0
	MOVE.L	A0,dl_Root(A5)
*
* and now the global vector (pointer into middle of GV - see negsize)
* we want it in A2 for later
*
	LEA	dl_SIZEOF+2+ROOTSIZE+(NEGSIZE*4)(a5),A2
	MOVE.L	A2,dl_GV(A5)
*
* Set up the timer request pointer in dosbase
* Note you don't need a port for OpenDevice!
* I put it last because I'm not certain it will always be a longword size
*
	LEA	dl_SIZEOF+2+ROOTSIZE+GVSIZE+CONSEGSIZE(a5),A1
	MOVE.L	A1,dl_TimeReq(a5)
	sub.l	a0,A0			; name of NULL (0) is timer.device-V40
	MOVEQ	#UNIT_VBLANK,D0
	MOVEQ	#0,D1
	CALL	OpenDevice

*
* Other doslib base stuff
*
	LEA.L	SAVE(PC),A3	Save routine address
	LEA.L	RET(PC),A4	Return routine address
	MOVEM.L	A2-A4,dl_A2(A5)	Save registers

*
* Set up things MakeLibrary doesn't do for us
*
	MOVE.B	#NT_LIBRARY,LN_TYPE(A5)
	LEA.L	LIBNAME(PC),A1
	MOVE.L	A1,LN_NAME(A5)
	MOVEQ	#0,d0
	MOVE.B	D0,LN_PRI(A5)
	MOVE.W	#VERSION,LIB_VERSION(A5)
	MOVE.W	#REVISION,LIB_REVISION(A5)

	MOVE.L	A5,A1	

	CALL	AddLibrary		; add the library to the exec list
*
* Removed ramlib init from here, and moved it to cli_init.  REJ
*
* Create initial CLI (A2 contains globvec)
*
* Must build a seglist (segarray) in alloced memory
* Note size in segarray is in bytes, and is converted into longwords
*
	LEA.L	_SEGLIST(PC),A3		; Segment list ptr
	MOVEQ	#(INITSEGSIZE*4)+4,D0	; # of bytes
	BSR	@@AllocVecPub		; Since Deact undoes this
	TST.L	D0
	BEQ	DISASTER

	MOVE.L	D0,A0
	MOVE.L	D0,D1			; this is arg1 for lower down!
	MOVEQ	#INITSEGSIZE,D0		; # of entries + size
	BRA.S	2$			; make count correct
1$
	MOVE.L	(A3)+,D2	; copy entries while converting to BPTRs!
	LSR.L	#2,D2
	MOVE.L	D2,(A0)+
2$	DBRA	D0,1$
*
* Now find the console-handler and add it to the seglist
*
	MOVE.L	D1,A3		; Save segarray ptr

*
* find the shell
*
	LEA	SHELLNAME(pc),a1
	CALL	FindResident
	MOVE.L	D0,A1
	TST.L	D0
	BEQ	DISASTER		; very bad, no shell/cli
	MOVE.L	RT_INIT(A1),a0		; table of entries, BCPL entry first

	MOVE.L	(a0),d0			; bcpl entrypoint (for createtask)
	LSR.L	#2,d0
	MOVE.L	D0,4*4(a3)		; replace syssegl[4]

	MOVE.L	4(a0),d0		; c entrypoint (for create(new)proc)
	LSR.L	#2,d0
	MOVE.L	D0,8*4(a3)		; replace syssegl[8]

* now console-handler
	LEA	CONSOLENAME(PC),A1
	MOVE.W	#dl_SIZEOF+2+ROOTSIZE+GVSIZE,d3
	MOVEQ	#5*4,d2			; offset in segarray - syssegl[5]
	BSR	FindResSeg

* now ram-handler...
	LEA	RAMNAME(PC),A1
	MOVE.W	#dl_SIZEOF+2+ROOTSIZE+GVSIZE+CONSEGSIZE+IOTV_SIZE,d3
	MOVEQ	#9*4,d2			; offset in segarray - syssegl[9]
	BSR	FindResSeg
*
* Now the fs - it's funny, and has to look like BCPL (ARGH).
*
	LEA	FILESYSNAME(PC),A1
	CALL	FindResident
	MOVE.L	D0,A1
	TST.L   D0
	BEQ     DISASTER

	;-- fs has rt_init point to the actual seglist
	MOVE.L	RT_INIT(A1),D0
	LSR.L   #2,D0			; we want a BPTR
	MOVE.L	D0,6*4(a3)		; syssegl[6] = fs
	
*
* Create the initial process
*
 DBUG <"creating initial process">
	MOVE.L	A3,D1		; get segarray ptr back
	LSR.L	#2,D1		; SegArray as BCPL ptr (arg1)
	MOVE.L	#CLISTK,D2	; Stack size
	MOVEQ   #0,D3		; Priority zero
	LEA.L	CLINAME(PC),A3	; Name
	MOVE.L	A3,D0		; master segarray as arg4 - in d0
	ASR.L	#2,D0		; BCPL address
	MOVE.L	#GLOBSIZE,(A2)	; Insert size of GV at (G)
	MOVE.L	A2,D5		; Globvec(bptr)
	ASR.L	#2,D5
	MOVE.L	D5,A0		; createtask wants 5th param in A0
	BSR	@@createtask	; Causes most of the globvec to be built
 DBUG <"created initial process">
	MOVE.L	D0,D7
	BEQ.S	DISASTER        ; Failed

* Extract the mount list node from the expansion base slot

	MOVEQ	#OLTAG_EXPANSION,D0	; expansion library, any version
	CALL	TaggedOpenLibrary	; NOTE: not a process yet!!!!!
	MOVE.L	D0,A2			; Pointer to expbase
	LEA.L	eb_MountList(A2),A0

*	  ; BootNode struct now declared in /libraries/romboot_base.i
*
* STRUCTURE BootNode,LN_SIZE
*    UWORD	bn_Flags
*    CPTR	bn_DeviceNode
*    LABEL	BootNode_SIZEOF
*
* Link the remaining eb_MountList entries to the boot devicenode for AmigaDos
*
* Save d0! (holds expansionbase!)
	MOVEM.L	D0/A0/A1,-(SP)
	MOVE.L	LH_HEAD(A0),A0
	TST.L	LN_SUCC(A0)		; list empty ?
	BEQ.S	BootLink_Done
	TST.L	bn_DeviceNode(A0)	; this bootnode has current devnode ?
	BEQ.S	BootLink_Done

Boot_Link:
	MOVE.L	LN_SUCC(A0),A1		
	TST.L	LN_SUCC(A1)		; nothing more to link ?
	BEQ.S	BootLink_Done

	MOVE.L	bn_DeviceNode(A0),A0

	TST.L	dn_Next(A0)		; current node already linked ?
	BNE.S	BootLink_Done		; won't mess with circularities for now.

	TST.L	bn_DeviceNode(A1)	; next bootnode has subsequent
					; devnode ?
	BEQ.S	BootLink_Done
	MOVE.L	bn_DeviceNode(A1),D0	; cptr to next node
	LSR.L	#2,D0			; convert to bptr
	MOVE.L	D0,dn_Next(A0) 		; link to next of current node

	MOVE.L	A1,A0			; next becomes current node
	BRA.S	Boot_Link

BootLink_Done:
	MOVEM.L	(SP)+,D0/A0/A1

	CALL	RemHead			; (a0) - a6 still has execbase
*
* D7 contains the message port for that task which is waiting for a message
* Use rootnode space as initial message area, and send message to
* start it up. D0 contains the device node pointer for the boot device.
*
* EVIL!!!!!!! FIX!!!!!!!!!
* The 4 bytes corresponding to days+2 to minutes+1 in the rootnode MUST
* be 0 (they correspond to ln_Name of a node).
*
	BSR	GETDATA		; Get library ptr into L (A3)
	MOVE.L	D7,A0		; Port
	CLR.L	pr_WindowPtr-pr_MsgPort(A0) ; Zero window ptr (use workbench)
	MOVE.L	dl_Root(A3),A1	; Message area

* Pass the boot device pointer in the startup packet, and release
* the node space used for it.

	TST.L	D0
	BEQ.S	EndL
	MOVE.L	D0,A3
	MOVE.L	bn_DeviceNode(A3),rn_FileHandlerSegment(A1)
EndL

 DBUG <"Sending initial message...">
	CALL	PutMsg		; A6 still has execbase

*
* Close expansion library
*
	MOVE.L	A2,A1		; expbase (a6 == execbase)
	CALL	CloseLibrary

* Free the boot node memory
*	  MOVE.L 	 L,A1
*	  MOVEQ		 #BootNode_SIZEOF,D0
*	  CALLS		 FreeMem
*
* We have nothing else to do now, so delete myself.
*
 DBUG <"bye bye">
	SUBA.L	A1,A1		; Myself
	CALL	RemTask		; Bye bye (a6 = execbase)
*
* Here if a disaster whilst booting
*
DISASTER
	MOVE.L	#AT_DeadEnd!AN_DOSLib,D7
	CALLS	Alert

*
* Subroutine used by above code to set up console/fs
* a1 = name of module, a3 = ptr to segarray, a5 = library ptr,
* d2 = offset in segarray to store seglist, d3 = offset from library for seglist
* (d2 and d3 are words) a6 = execbase
*
FindResSeg:
	CALL	FindResident
	MOVE.L	D0,A1		; Save and test
	TST.L	D0
	BEQ.S	DISASTER	; very, very bad
*
* build handler seglist in dosbase
*
	LEA	0(a5,d3.w),A0	; address of built seglist
	MOVE.L	A0,D0		; save
	CLR.L	(A0)+		; no next segment
	MOVE.W	#$4ef9,(A0)+	; JMP abs.l
	MOVE.L	RT_INIT(A1),(A0) ; Address to jump to

	MOVE.L	D0,A0		; for clearicache
	
	LSR.L	#2,D0		;BPTR to seglist
	MOVE.L	D0,0(A3,d2.w)	;syssegl[d2] = seglist

	MOVEQ	#10,d0		; length of modified code
	bsr.s	@@ClearICache

	RTS
*
* Stuff to clear cache after modifying code
* void __regargs ClearICache(UBYTE *addr, LONG len)
*
@@ClearICache:
	move.l	a6,-(sp)
	move.l	SysBase,a6
	moveq	#CACRF_ClearI,d1	; clear ICache only
	jsr	_LVOCacheClearE(a6)
	move.l	(sp)+,a6
	rts

*
* Strings for above and below
*
	CNOP    0,4

CLINAME   DC.B       11,'Initial CLI',0		; BSTR!
_doslibname:
LIBNAME   DC.B       'dos.library',$00		; CSTR
*EXPNAME   DC.B       'expansion.library',$00	; CSTR
*UTILITY   DC.B       'utility.library',$00	; CSTR
*TIMER     DC.B	     'timer.device',$00		; CSTR
_consolename:
CONSOLENAME
	DC.B	     'con-handler',$0		; CSTR
FILESYSNAME
	DC.B	     'filesystem',$0		; CSTR
_shellname:
SHELLNAME DC.B	     'shell',$0			; CSTR
_ramname:
RAMNAME	  DC.B	     'ram-handler',$0		; CSTR
	CNOP	0,2

	PAGE
	TTL        "Library support"
*
*
* The dos jump table init used to be here.
*
* Initialisation code
*
J_OPEN  
	ADDQ.W	#1,LIB_OPENCNT(A6)	; Increment use count
	MOVE.L	A6,D0			; And return A6
	RTS

J_CLOSE
	SUBQ.W	#1,LIB_OPENCNT(A6)	; Optimized REJ
J_NOP   MOVEQ	#0,D0			; Return with zero (no segment)
	RTS

*
* Now the standard call for calling the DOS, using BCPL globals.
*
* Entered with D0        Global number
*              D1-D4     Args
*
* Note A6 does not have to point to library entry.
*
* We may trash D0/D1/A0/A1 and nothing else.
*
*CALLGLOB
*        MOVEM.L D2-D7/A2-A6,-(SP)       Save all registers we must
*        SUBA.L	A0,A0                   Zero A0
*	MOVE.L	SP,D5                   Get SP
*	SUBI.L	#DOSSTK,D5              Make BCPL stack ptr
*	BCLR    #1,D5                   Ensure long word aligned
*	MOVE.L	D5,A1                   And into BCPL stack ptr reg
*        MOVEM.L BCPLregs,A2/A5/A6       Set up other BCPL regs
*        ASL.L	#2,D0                   Make global number byte offset
*        MOVE.L	0(A2,D0.L),A4           Get entry point required
*        MOVEQ   #12,D0                  Mimimal stack frame
*        JSR     (A5)                    Call BCPL routine
*        MOVE.L	D1,D0                   Result to D0
*        MOVEM.L (SP)+,D2-D7/A2-A6       Restore registers
*        RTS
*
* Routine for BCPL to call C routines via global vector.
* Entered with normal BCPL environment (see above).
* Takes mask for converting params in B (A4) (pushed by stub rtn)
* Has address of C-style routine in L (A3) (pushed by stub rtn)
* Called from the Save Rtn (A5) after pushing/saving regs.
* P (A1) has ptr to the contents of D1-D4, B has calldos, L has temp.
* Must exit by calling return code (A6).  Can modify D0/1,A3,A4 (and maybe
* D5-D7).
*
* Using semi-custom routines works better in some cases.
*

	; this version stuffs bstr's on the stack
CALLDOS
	MOVEM.L	D2-D4/A0-A2/A6,-(A7)
	LINK	A5,#0			; saves a5, and allows us to play
					; stack games without unbalancing it.
	; handle argument conversion
	; arguments are at (p) and args 1-4 are in regs D1-D4 as well
	; codes in mask are:
	;		00 - no change/unused,
	;		01 - BPTR -> CPTR
	;		10 - BSTR -> CSTR
	;		11 - end of args
	;
	; mask is laid out as follows: bits 0-1 -> 1st arg, 2-3 -> 2nd arg, etc
	; top bit of mask == 0 for no shift of result, 1 for cptr->bptr
	;
	; BSTR->CSTR conversion is by copying it onto the stack, because of
	; the resident command.
	;
	MOVE.L	A4,D0			; get mask
	MOVE.L	A1,A0			; pointer to args

loop:	MOVE.L	D0,D6			; get current mask bits
	LSR.W	#2,D0			; shift mask bits for next loop
	ANDI.W	#3,D6			; get code (0-3)
	SUBQ.W	#1,D6			; start switch code
	BMI.S	code00			; code 00 - ignore (d6 = -1 to 2)
	BNE.S	code10			; not code 01 - try 10

	; we know it's 01 - BPTR->CPTR
	MOVE.L	(A0),D7			; convert to cptr
	ASL.L	#2,D7
	MOVE.L	D7,(A0)			; store cptr back in arg
	; fall thru into code00

code00: ADDQ.L	#4,A0			; code 00 - do nothing -
	BRA.S	loop			;                  increment arg ptr

code10:	SUBQ.W	#1,D6			; d6 now 0 to 1
	BNE.S	loadargs		; code 11 - done

	; must be code 10 - BSTR to CSTR - copy onto stack!
	; FIX!!!! we should check stack limits here!!!!!!
	;
	MOVE.L	A5,D7			; SAVE A5!

	MOVE.L	(A0),A5			; get BSTR
	ADD.L	A5,A5
	ADD.L	A5,A5			; change to CPTR

	; get space from stack - make sure it's word-alligned!
	MOVEQ	#0,d6
	MOVE.B	(a5)+,d6		; get string length
	MOVE.L	d6,d1			; save
	ADDQ.W	#2,d1			; space for null and 1 for word allign
	ANDI.B	#$FE,d1			; force word allignment-faster than BCLR
	SUB.W	d1,a7			; get length bytes from stack
	MOVE.L	a7,(a0)+		; store cstr pointer and increment arg

	; now copy the string onto the stack
	MOVE.L	a7,a6			; pointer to new string
	BRA.S	2$
1$	MOVE.B	(a5)+,(a6)+
2$	DBRA	d6,1$
	CLR.B	(a6)			; null-terminate

	MOVE.L	D7,A5			; RESTORE A5!
	BRA.S	loop

	; load the args into the registers they'll be expected in
	; openwindow counts on D5 being loaded, etc.
loadargs:
	MOVEM.L	(A1),D1-D7		; read args 1-7 into regs

	; MUST leave a1 intact for use by called routines!!!!

	MOVE.L	G_DOSBASE(A2),A6	; get DOSBase from global vector
	JSR	(A3)			; call the actual routine
	; returns value in D0

	; d2-d4 regs assumed trashed by interface routines that need
	; to play with args in funny ways - see fakeblib.asm (in addition to
	; the normal d0/d1/a0/a1).

done:   ; now check return for shift needed (cptr->bptr)
	MOVE.L	A4,D1
	BTST.L	#RETURN_BPTR_BIT,D1
	BEQ.S	not_bptr
	LSR.L	#2,D0

not_bptr:				; finally!
	UNLK	A5			; restore stack pointer and a5
	MOVEM.L	(SP)+,D2-D4/A0-A2/A6	; restore BCPL environ
	MOVE.L	D0,D1			; return code in D1 for bcpl
	JMP	(R)			; BCPL return

*
*
* Various return sequences used by the kernel
*
CERROR
	MOVE.L	D1,-(SP)
	MOVE.L	SysBase,A0
	MOVE.L	ThisTask(A0),A0
	MOVE.L	(SP)+,pr_Result2(A0)	; TRICKY!!!!!
	MOVEQ	#0,D0
	RTS
*
* BCPL error rtns
*
BCPLERROR
	BSR	GETID
	MOVE.L	D1,pr_Result2-pr_MsgPort(L)
ER_RET  CLR.L	D1			; Set zero result
	JMP	(R)			; Return

	PAGE
	TTL         "Subroutines at fixed offset from S register"
*
* Subroutines which are called relative to the S register
*
******************************************************************
* The standard return sequence                                   *
******************************************************************

RET       MOVEM.L	-12(P),P/L			[-0C]
	  MOVE.L	-4(P),B				[-06]
	  JMP		(L)				[-02]
*
******************************************************************
*  The standard SAVE routine which is used to call a routine     *
*         Entered with B pointing to routine address             *
******************************************************************

SAVE
	MOVE.L	(SP)+,L		 Standard save sequence [00]
	MOVEM.L	P/L/B,-12(P,D0.L)			[02]
	ADDA.L	D0,P					[08]
	MOVEM.L	D1-D4,(P)				[0A]
	JMP	(B)					[0E]

********************************************************************************
*  Branches to arithmetic routines                                             *
********************************************************************************
MULT      BRA.S     MULT32                                    [10]
DIV       BRA.S     DIV32                                     [12]
DIVX      BRA.S     DIV32                                     [14]
********************************************************************************
*       Stack Check                                                            *
*                 Entered with D0 = Stack frame size of this routine           *
* Can't totally remove, due to fixed offsets from above
********************************************************************************
STACKCHECK
*            ADD.L	P,D0                New top of stack      [16]
*            MOVE.L	G_STACKBASE(G),D5       Current stackbase as BCPL address
*            LSL.L	#2,D5               MC address
*            CMP.L	C_SEND(Z,D5.L),D0   Compare stack limit with stack top
*            BGE.S   STACKOVER           J if top > limit
	  RTS                         OK
*STACKOVER   MOVEQ   #84,D0              Stack overflow error
*            TRAP    #0
*            RTS
********************************************************************************
*       Multiply                32 bit multiply routine                        *
*                 Performs D1 := D1 * D2                                       *
********************************************************************************
@@multiply:
	movem.l	a0-a2/a6,-(sp)
	bsr.s   get_ubase
	bra.s	mult_common
MULT32
	movem.l	a0-a2/a6,-(sp)
	move.l	G_UTILITYBASE(a2),a6
mult_common:
	move.l	d1,d0
	move.l	d2,d1
	jsr	_LVOSMult32(a6)
	move.l	d0,d1
	movem.l	(sp)+,a0-a2/a6
	rts

	; returns a6=utilitybase, not touching any other regs
get_ubase:				; shared with divide - hits a6 only!
	move.l	SysBase,a6
	move.l	ThisTask(a6),a6
	cmp.b	#NT_TASK,LN_TYPE(a6)	; is this a process
	beq.s	open_dos		; got to util with a6 = globvec,
	move.l	pr_GlobVec(a6),a6	; no other regs are touched
util:	move.l	G_UTILITYBASE(a6),a6
	rts

open_dos:	;-- we're a task.  Open dos and find the shared globvec
	movem.l	d0-d1/a0-a1,-(sp)	; preserve regs!
	bsr	@@opendosbase		; uses openlibrary
	move.l	d0,a6			; dosbase
	move.l	dl_GV(a6),a6		; shared global vector
	movem.l	(sp)+,d0-d1/a0-a1
	bra.s	util


	PAGE
********************************************************************************
*       Divide                  32 bit division routine                        *
*           Performs D1 := D1/D2; D2 := D1 REM D2                              *
*									       *
********************************************************************************
*
*     Note that both D1 and D2 can be as big as one greater than the
*     largest ordinary positive integer held in a 32-bit (signed) word.
* If D2=0 the 68000 will take a 'divide by zero' trap.
* The only case that can lead to an answer that is out of the range
* of normal (signed) numbers is #X80000000/1 which can arise when
* Divide1 was called on #X80000000/(-1)

@@rem32:
_rem32:
	bsr.s	@@div32
	move.l	d1,d0
	rts

DIV32:
	move.l	d1,d0
	move.l	d2,d1
	bsr.s	@@div32
	move.l	d1,d2
	move.l	d0,d1
	rts

@@udiv32:
_udiv32:
	move.l	a6,-(sp)
	bsr.s	get_ubase
	JSR	_LVOUDivMod32(a6)
	move.l	(sp)+,a6
	rts

*
* return remainder in a variable passed in a0
*
@@divrem32:
_divrem32:
	bsr.s	@@div32		; preserves a0!
	move.l	d1,(a0)
	rts
@@div32:
_div32:
	; save a0-a1 for BCPL and divrem32!
	movem.l	a0-a1/a6,-(sp)
	bsr.s	get_ubase
	JSR	_LVOSDivMod32(a6)
	movem.l	(sp)+,a0-a1/a6
	rts
	
	PAGE
	TTL     "*** Tripos Kernel - Primitive Routines ***"
******************************************************************
*                                                                *
* CREATETASK( SEGLIST, STACK, PRIORITY, NAME, GVEC )             *
*                                                                *
* This creates a new task with code specified by seglist. The    *
* stack and priority also passed. The task structure is          *
* initialised and the task added to the queue.                   *
* This is a BCPL task and a global vector (shared or             *
* private) is passed as GVEC. In this case the task is started   *
* so that suitable BCPL initialisation is performed (the global  *
* vector is initialised and registers set up). The initialisation*
* will then call TASKWait to wait for the first message.         *
*                                                                *
* struct MsgPort *createtask (BPTR segl,LONG stacksize,LONG pri, *
*			      BSTR name,BPTR globvec);           *
* called with C conventions!					 *
* Does not modify BSTR name, ok to be in ROM			 *
******************************************************************
	SECT       <'Createt'>

CRTASK
	MOVEM.L	A0/A1/A6,-(SP)
	MOVE.L	D4,D0		; Lattice can't pass args in D4 or D5
	MOVE.L	16(A1),A0	; get globvec off BCPL stack (BPTR)
	BSR	@@createtask
	bra	restore_bcpl_exit

*          CNOP       0,4
****************************************************************
*                                                              *
* ProcID := CreateProc( Name, Pri, Seg, Stacksize )            *
*                                                              *
* Creates a new process with specified (C format) name, pri    *
* and stacksize (in bytes). The segment list is one returned   *
* from LoadSeg, and other entries in the Segment vector are    *
* copied from the current environment.                         * 
*                                                              *
* struct MsgPort *createproc (char *name,LONG pri,BPTR seg,    *
* 			      LONG stacksize);		       *
****************************************************************
*

CRPROC
	movem.l	a0/a1/a6,-(sp)
	bsr.s	doslib_createproc
	bra	restore_bcpl_exit

doslib_createproc:
	move.l	d4,d0
	jmp	@@createproc

*
* Get memory via AllocEntry.  Entered with D0 = size.  Returns Entry or high
* bit set.  Requires a6=sysbase!
*
AllocEntry:
	MOVE.L	D0,-(SP)			; Size onto stack
	MOVE.L	#MEMF_PUBLIC+MEMF_CLEAR,-(SP)	; Requirements
	MOVE.W	#1,-(SP)			; Number of entries
	LEA.L	-LN_SIZE(SP),SP			; Leave space for node
	MOVE.L	SP,A0				; Arg into A0
	CALL	AllocEntry			; Get Memory
	LEA.L	LN_SIZE+10(SP),SP		; Adjust stack
	RTS

*
* Get memory for task structure and stack. Place it into
* the task field so that it gets deleted properly on exit.
* Entered with D0 = size
*
AllocProc:
	MOVEM.L	a2/a6,-(SP)
	MOVE.L	SysBase,A6			; Get library pointer
	BSR	AllocEntry			; Get Memory
	TST.L	D0
	BMI.S   AllPErr				; AllocEntry sets bit 31 on err
	MOVE.L	D0,A2				; A2 is mem block
	MOVE.L	ME_ADDR+ML_ME(A2),A1		; A1 is task space
	LEA	TC_MEMENTRY(A1),A0
	NEWLIST	A0
	EXG.L	A2,A1	
	CALL	AddHead
	MOVE.L	A2,D0				; Return memory
AllocPr2
	MOVEM.L	(SP)+,a2/a6
	RTS
AllPErr
	MOVEQ      #0,D0			; Error
	BRA.S      AllocPr2

*
* Create process and initialize
* a0 - pointer to longword stacksize
* a1 - pointer to name - NOT TERMINATED (maybe)
* d0 - length of name
*
@@MakeProc:
 DBUG <"In MakeProc, stack = %ld, 0x%lx, %ld">,(a0),a1,d0
	MOVEM.L	D2-D5/A2-A3,-(SP)
	MOVE.L	(a0),d4			; get stacksize
	ADDQ.L	#3,D4			; We want to round stack size up to
	AND.W	#$FFFC,D4		; the next multiple of 4 bytes
	MOVE.L	D4,(a0)			; put stacksize back

* Find length of Task name and allocate everything using AllocEntry
	MOVE.L	D0,D5			; save original length
	ADDQ.L	#4,D0			; space for null + 3 for alignment
	AND.W	#$FFFC,D0		; make length an even number of LWs
	MOVE.L	D0,D3			; save length
	ADD.L	D4,D0			; form length of block (add length)
					; BCPL dos merely made it even
* Get space for Task struct and process base to stacksize (in bytes)
	ADD.L	#pr_SIZEOF,D0
	MOVE.L	D0,D2			; save it
	MOVE.L	A1,A2			; save
	BSR.s	AllocProc
*					; also adds all memory to tc_mementry
	TST.L	D0
	BEQ	CRPERR			; no memory!
	MOVE.L	D0,A0			; process ptr
	MOVE.L	D0,A1

	;-- now copy name above stack
	ADD.L	d2,a1			; ptr past last word block
	SUB.L	d3,a1			; subtract length of name (inc null)
	MOVE.L	a1,LN_NAME(a0)
	BRA.S	2$			; d5 still has original length
1$	MOVE.B	(a2)+,(a1)+
2$	DBRA	d5,1$			; may not be null-terminated
	CLR.B	(a1)			; null-terminate

*
* Initialise task structure slots.
* a0 Space for task
* d4 Stacksize in bytes

	MOVE.B	#NT_PROCESS,LN_TYPE(A0)		; Set type of new task
	MOVE.L	#SIGMASK,TC_SIGWAIT(A0)		; Wait for this signal
	LEA	AbortHandler(PC),A1
	MOVE.L	A1,TC_TRAPCODE(A0)		; Install trap handler
	LEA	pr_SIZEOF(A0),A1		; A1 is low stack
	MOVE.L	A1,TC_SPLOWER(A0)		; Fill in SPLower
	MOVE.L	A1,D1
	LSR.L	#2,D1				; Stack as BCPL ptr
	MOVE.L	D1,pr_StackBase(A0)		; Stored in process base
	MOVE.L	D4,pr_StackSize(A0)		; Stack size
	ADD.L	D4,A1				; Make SPUpper
	MOVE.L	A1,TC_SPUPPER(A0)		; also a return value!
	MOVE.L	D4,-(A1)			; push stacksize onto stack
	MOVE.L	A1,TC_SPREG(A0)			; initial stack value
	MOVE.L	A1,pr_ReturnAddr(A0)		; ..and also returnaddr

	MOVE.L	A0,MP_SIGTASK+TC_SIZE(A0)	; Initialise message port slot
	LEA	MP_MSGLIST+TC_SIZE(A0),A1	; Point to msg list
	NEWLIST	a1				; Initialise this
	MOVE.B	#MSGSIG,MP_SIGBIT+TC_SIZE(A0)	; ..and signal to be issued

* Initialise process structure
* Can't call @@dosbase here - may be from a task!
	BSR	GETDATA				; returns dosbase in A3
						; leaves all other regs
	MOVE.L	dl_GV(a3),pr_GlobVec(A0)	; shared global vector ptr

* Initialize the local env variable list
	LEA     pr_LocalVars(a0),a1		; list ptr
	NEWLIST	a1

	MOVE.L	A0,D0				; return value
CRPERR:
	MOVEM.L	(SP)+,D2-D5/A2-A3
	RTS

*
* Make segment ptr (segarray), and add to process.  Allocate and build
* fake seglist if needed.  Must be callable from a Task.  Puts the memory
* on the tc_MemEntry so it can be freed by RemTask().
*
* a0 - new process
* d0 - seglist (BPTR) or NULL
* d1 - entry (CPTR) or NULL - mutually exclusive with seglist!
*
@@AddSegArray:
	movem.l	d2-d4/a2-a3/a6,-(sp)
	move.l	a0,a2				; new proc
	move.l	d0,d2				; seglist
	moveq	#5*4,d0				; size of segarray
	move.l	d1,d3				; entry
	beq.s	1$

	;-- need to build fake seglist
	moveq	#5*4+10,d0			; $00000000 JMP xxxx.L
1$:
	;-- allocate with AllocEntry so we can add it to the tc_MemEntry list
	;-- This means it will be freed by RemTask...
	move.l	SysBase,a6			; Get library pointer
	bsr	AllocEntry			; so we can add it to tc_MemEntry
	tst.l	d0
	bmi.s	adderr				; AE() returns bit 31 for error
	move.l	d0,a1
	move.l	ME_ADDR+ML_ME(a1),a3		; the actual memory
	lea	TC_MEMENTRY(a2),a0
	CALL	AddHead				; add it to the tc_MemEntry

	move.l	a3,d0				; segarray (list of seglists)
	lsr.l	#2,d0				; make into bptr

	move.l	d0,d4
	tst.l	d3				; did we need a seglist?
	beq.s	got_seglist
						; first longword already is 0
	move.w	#$4ef9,5*4+4(a3)		; JMP xxx.L
	move.l	d3,5*4+6(a3)			; address to call
	move.l	d4,d2				; save seglist ptr
	addq.l	#(5*4)>>2,d2			; this is our seglist (BPTR!!)

	;-- Flush Icache - a bit more flushed than we have to
	move.l	a3,a0				; flush for the whole alloc
	moveq	#5*4+10,d0			; size of allocation
	bsr	@@ClearICache

got_seglist:
	;-- d2 has seglist (BPTR) a2 - new process
	;-- a3 has segarray, d4 has segarray BPTR
	move.l	d4,pr_SegList(a2)	; put in new proc
	lea	_SEGLIST+4(pc),a1	; addr of default segarray

	moveq	#2,d0			; C code we assume, not BCPL
	move.l	d0,(a3)+		; C procs don't use globin
	move.l	(a1)+,d0
	lsr.l	#2,d0
	move.l	d0,(a3)+		; BPTR to klib segment
	move.l	(a1)+,d0
	lsr.l	#2,d0
	move.l	d0,(a3)+		; BPTR to blib segment
	move.l	d2,(a3)+		; our seglist
					; cli entry already NULL due to alloc

	;-- d0 is TOBPTR(blib addr), which means success (!0)
addexit:
	movem.l	(sp)+,d2-d4/a2-a3/a6
	rts
adderr: moveq	#0,d0
	bra.s	addexit

*          CNOP       0,4
****************************************************************
*                                                              *
*  This code is called when a task is activated or deactivated *
*                                                              *
****************************************************************
*
* D0-D7, L, S and R may be used during activation, and P and G are
* used until they are set to the stack and global vector.
*
*
* First find the required global vector size after locating my own
* task structure
*
* Only referenced for starting BCPL tasks from CreateTask - REJ
*
_activecode:
@@activecode:
ACTIV
 DBUG <"in new task">
	MOVE.L	SysBase,A6
	MOVE.L	ThisTask(A6),A4
	ADDA.L	#TC_SIZE,A4		; B (A4) is now process ID
					; This means it is the MsgPort - REJ
*
* Set up BCPL registers
*
	SUBA.L	Z,Z
	MOVE.L	TC_SPLOWER-pr_MsgPort(A4),P	; Set up BCPL stack (A1)
	MOVE.L	pr_GlobVec-pr_MsgPort(A4),G	; And global vector (A2)
*
* Now clear BCPL stack
*
	MOVE.L	P,A3			; L (A3) = starting address
	MOVE.L	#$ABABABAB,D3		; Stack pattern
	MOVE.L	SP,D2			; Top of stack
	SUBQ.L	#2,D2			; Less two bytes for safety
ACT10
	MOVE.L	D3,(A3)+		; Clear the BCPL stack
	CMPA.L	D2,A3			; Works for any size stack
	BLT.S	ACT10
*
	MOVE.L	#-1,C_CLLR(P)		; -1 -> root coroutine
	MOVE.L	D2,C_SEND(P)		; Stack end
	MOVE.L	P,D2			; Stack base
	ASR.L	#2,D2			; BCPL address
	MOVE.L	D2,G_STACKBASE(G)	; Patch local GV
*
	MOVE.L	pr_SegList-pr_MsgPort(B),D7	; D7 = BCPL ptr to SEGL
	MOVE.L	D7,D6
	ASL.L	#2,D6			; D6 = MC addr to SEGL
	ADD.L	0(Z,D6.L),D7
	ASL.L	#2,D7			; D7 = MC addr of last entry
	LEA.L	ACT11(PC),R		; Return addr for GLOBIN (A6)
*
ACT11   ADDQ.L	#4,D6			; D6 = MC addr of next entry
	CMP.L	D6,D7
	BLT.S	ACT12			; J if all entries processed
*
* At this point:
*
*      D6 = MC addr of the current entry of SEGL
*      D7 = MC address of the last entry of SEGL
*      Z  = 0 (A0)
*      R  = MC addr of ACT11 (the return addr for GLOBIN) (A6)
*      G  = Globvec pointer (CPTR) in A2
*
* GLOBIN only changes D0, D1, D2, D3, B and L (A3 and A4)
*
*
	MOVE.L	0(Z,D6.L),D1           D1 = BCPL ptr to segment
	BRA	GLOBIN                 GLOBIN(seg) rtn to ACT11
*
*
* We are now ready to call START(TASKWait())
*
ACT12	LEA.L	SAVE,S			; Addr of save routine
	LEA.L	RET,R			; Addr of return routine
*
	; wait for packet, used to call global vec
	; packet MUST be LW aligned!
	MOVEM.L	A0/A1,-(SP)		; save BCPL regs
	BSR	@@taskwait		; wait for packet
	MOVEM.L	(SP)+,A0/A1		; restore BCPL regs
	MOVE.L	D0,D1			; BCPL want it in D1
	LSR.L	#2,D1			; BPTR not CPTR!
*
	; we will use BCPL routine to actually start the BCPL task
	MOVE.L	G_START(G),B	   	; call BCPL start code
	MOVEQ	#32,D0			; Stack increment
	JSR	(S)			; Now call START(pkt)
*
* Task has finished normally - free its seglist and globvec if new
* FinalPC code for both CreateTask and CreateProc - REJ
*
_deactcode:
@@deactcode:
DEACT
	;-- returncode is in d0, all others assumed trashed
	MOVE.L	SysBase,A6
	MOVE.L	ThisTask(A6),A0		; faster than findtask()
	BSR	@@CleanupProc		; do all the cleanup in C
					; returns returncode
	SUB.L	A1,A1
	CALL	RemTask			; kill self

*	RTS				; impossible

*
* CNP_ActiveCode: CreateNewProc startup code.  Sets up a0/d0 from
* pr_Arguments, and then calls the code we want to execute.
*
* No need to restore regs.
*
_CNP_ActiveCode:
@@CNP_ActiveCode:
	MOVE.L	SysBase,A6
	MOVE.L	ThisTask(A6),A6
	MOVE.L	pr_Arguments(A6),A0	; argument parameter (NULL if no args)
	MOVE.L	A0,d0			; registers other than a0/d0 are free
	BEQ.S	noargs			; if a0 is NULL d0 is 0

	;-- warning! this uses 2x stack!!!!
	move.l	a0,d3			; save in d3
	BSR	@@strlen			; (a0) - length returned in d0
	move.l	d0,d4			; length
					; d3 is already pr_Arguments
	move.l	pr_StackSize(A6),D2	; in bytes
	move.l	pr_SegList(A6),D1	; segarray (BPTR)
	asl.l	#2,d1
	move.l	d1,a0
	move.l	3*4(a0),d1		; seglist (bptr)
	bra	_RunCommand		; returns to DEACT

noargs:	MOVE.L	pr_SegList(A6),D1	; segarray BPTR
	ASL.L	#2,D1			; APTR
	MOVE.L	D1,A1
	MOVE.L	3*4(A1),D1		; Segarray[3], the seglist we should use
	ASL.L	#2,D1			; APTR to first segment
	ADDQ.L	#4,D1			; point to first instruction
	MOVE.L	D1,A1
	JMP	(A1)			; RTS will go to exec returncode (deact)
	
	PAGE
******************************************************************
* 								 *
*        DELETETASK( )                                           *
*                                                                *
* This deletes the current task                                  *
*                                                                *
******************************************************************
	SECT       <'Deletet'>
_deletetask	EQU	DEACT
DELTASK		EQU	DEACT

	PAGE
******************************************************************
*                                                                *
*        OPENDEVICE( IOB, NAME, UNIT, FLAGS )                    *
*                                                                *
* This opens the specified device and returns nonzero if OK      *
* NAME is a BCPL string but terminated with a null a la C        *
*                                                                *
* This will be maintained as a BCPL rtn since C/ASM routines call*
* exec directly.						 *
******************************************************************
	SECT       <'OpenDev'>
OPEND	ASL.L	#2,D2                  Move name to mc ptr
	ADDQ.L	#1,D2                  Avoid length field
	ASL.L	#2,D1                  Move IOB to mc ptr
	MOVE.L	D1,D5                  And save
	MOVEM.L	A0/A1/A6,-(SP)         Save regs
	MOVE.L	SysBase,A6
	MOVE.L	ThisTask(A6),D6
	ADD.L	#TC_SIZE,D6            Now process id
	MOVE.L	D2,A0                  Name to A0
	MOVE.L	D5,A1                  IOB to A1
	MOVE.L	D3,D0                  Unit to D0
	MOVE.L	D4,D1                  Flags to D1
	MOVE.L	D6,MN_REPLYPORT(A1)    Reply port
	MOVE.W	#IO_SIZE-MN_SIZE,MN_LENGTH(A1)  Message length

	CALLS	OpenDevice

	MOVEM.L	(SP)+,A0/A1/A6         Restore regs
	MOVEQ	#-1,D1		    ; assume ok
	TST.L	D0
	BEQ.S	OPEND1		    ; OK
	MOVEQ	#0,D1		    ; error
OPEND1  JMP	(R)		    ; BCPL routine!

	PAGE
******************************************************************
*                                                                *
*        SETIO( IOB, COMMAND, DATA, LENGTH, OFFSET )             *
*                                                                *
* This sets fields as specified in the IOB                       *
*                                                                *
* BCPL routine, not needed by C/asm language programmers	 *
******************************************************************
	SECT       <'SetIo  '>
SETIO	ASL.L	#2,D1                  Move IOB to mc ptr
	MOVE.L	D1,A3                  IOB to A3
	MOVE.W	D2,IO_COMMAND(A3)
	ASL.L	#2,D3                  Convert data ptr to mc
	MOVE.L	D3,IO_DATA(A3)
	MOVE.L	D4,IO_LENGTH(A3)
	MOVE.L	16(P),IO_OFFSET(A3)
	JMP	(R)		    ; BCPL routine!

	PAGE
******************************************************************
*                                                                *
*        error = DoIo( IOB )               			 *
*                                                                *
* This performs the specified IO and waits for it.       	 *
*                                                                *
* BCPL routine, not needed by C/asm language programmers	 *
******************************************************************
	SECT       <'DoIo '>
DOIO	move.l	#_LVODoIO,d0
	; fall through

*
* Takes a function offset in d0, and an argument in d1, and calls the exec
* library entry with the BADDR(d1) in a1.  Moves d0 to d1 on return.
*
bcpl_call_exec:
	movem.l	a0/a1/a6,-(sp)		; Save BCPL regs
	asl.l	#2,d1
	move.l	d1,a1			; turn param into APTR
	move.l	SysBase,A6
	jsr	0(a6,d0.l)		; call exec rtn at offset in d0

	;-- shared cleanup code
restore_bcpl_exit:
	move.l	d0,d1			; BCPL wants returns in d1

restore_bcpl_done:			; for routines that have set rtn or
					; have no return
	movem.l	(sp)+,a0/a1/a6		; Restore regs
	jmp	(R)

	PAGE
******************************************************************
*                                                                *
*        SendIO( IOB, pkt )                                      *
*                                                                *
* This performs the specified IO but does not wait for it.       *
* The pkt will be returned later with the ID field pointing to   *
* the IOB.                                                       *
*                                                                *
* BCPL routine, not needed by C/asm language programmers	 *
* Bizarre stuff occurs with pkt and IOB!			 *
******************************************************************
	SECT       <'SendIo '>
SEND_IO	MOVEM.L	A0/A1/A6,-(SP)         Save regs
	ASL.L	#2,D1                  IOB to mc ptr
	MOVE.L	D1,A1                  IOB to A1
	ASL.L	#2,D2                  Pkt to mc ptr
	MOVE.L	D2,LN_NAME(A1)         pkt address saved in name
	MOVE.L	D1,0(Z,D2.L)           ID field has IOB ptr
	CALLS	SendIO
	BRA.S	restore_bcpl_done

	PAGE
******************************************************************
*                                                                *
*        CLOSEDEVICE( IOB )                                      *
*                                                                *
* This closes the device associated with the IOB                 *
*                                                                *
* BCPL routine, not needed by C/asm language programmers	 *
******************************************************************
CLOSED	move.l	#_LVOCloseDevice,d0
	bra.s	bcpl_call_exec

	PAGE
******************************************************************
*                                                                *
*                 RES := GETMEM(UPPERBOUND,FLAGS)                *
*                 RES := GETVEC(UPPERBOUND)                      *
*                                                                *
* This function is BCPL callable.                                *
* Returns the BCPL pointer to a vector with at least the given   *
* upper bound. The word at offset -1 of the vector contains      *
* the length of the store block and should not be touched by the *
* user. It may be called                                         *
* from machine code using R a the return address.  If no global  *
* vector has been set up then G must be zero.                    *
*                                                                *
* GETVEC used to change: D0, D1, D2, D3, D4 and L                *
* It now changes D0/D1/A0/D1 for @@getvec, D0/D1/D2 for GETVEC	 *
*                                                                *
* On return:                                                     *
*      RES ~= 0    OK                                            *
*      RES  = 0    Error                                         *
*                  RESULT2 = 103    Insufficient store           *
*                                                                *
* NOTE: seems to add _2_ longs to all allocations!!!!! REJ 	 *
******************************************************************

	SECT       <'getvec '>
*
GETVEC
	MOVEQ	#MEMF_PUBLIC,D2
GETM	MOVEM.L	A0/A1/A6,-(SP)	; not the same as GETMEM!!!
	MOVE.L	d1,d0
	MOVE.L	d2,d1		; args in d0/d1!
	ADDQ.L	#1,d0
	ASL.L	#2,d0		; add 1 longword and make into bytes
	CALLS	AllocVec	; allocate memory
	MOVE.L	D0,D1		; BCPL return reg
	LSR.L	#2,D1		; return a BPTR!
	BRA.S	restore_bcpl_done

@@AllocVecPubClear:
_AllocVecPubClear:
	MOVE.L	#MEMF_PUBLIC+MEMF_CLEAR,d1
	BRA.S	alloc_common

@@AllocVecPub:
_AllocVecPub:
	moveq	#MEMF_PUBLIC,d1

alloc_common
	MOVE.L	a6,-(sp)
	CALLS	AllocVec		; d0/d1
restore_a6:
	MOVE.L	(sp)+,a6
	rts

	PAGE
******************************************************************
*                                                                *
*                           FREEVEC(V)                           *
*                                                                *
* This BCPL callable routine frees the vector V, which should    *
* have been obtained from GETVEC. It aborts the task if an error *
* is detected. If the vector is zero the call has no effect      *
* No BCPL stack or Global vector are required.                   *
*                                                                *
* Called with C/asm calling conventions (CPTR)			 *
* Cannot handle vectors of more than 16M-4! FIX			 *
******************************************************************
*
*
	SECT       <'freevec'>
*
FREEVEC:
	move.l	#_LVOFreeVec,d0
	bra.s	bcpl_call_exec

*
* stub for calling freevec to save a few bytes
* takes param in a1
*
_freeVec:
	move.l	a6,-(sp)
	CALLS	FreeVec
	bra.s	restore_a6

	PAGE
******************************************************************
*                                                                *
*                         GLOBIN(SEG)                            *
*                                                                *
* This function initialises the globals defined in the given     *
* segment. It returns -1, or 0 if an error is detected - an      *
* attempt to initialise a global beyond the upperbound given in  *
* GLOBSIZE. GLOBIN is defined in KLIB since it is called from    *
* the scheduler in ACTIV.                                        *
*                                                                *
* GLOBIN must return via register R since this is assumed in     *
* ACTIV.                                                         *
*                                                                *
* GLOBIN changes:  D0, D1, D2, D3, B and L (A3 and A4)           *
*                                                                *
* BCPL routine not called by C/asm language programmers		 *
******************************************************************

	SECT       <'globin '>
*
GLOBIN
	MOVEQ.L	#-1,D0           Success flag initialized to TRUE
*
GLOBIN0	ASL.L	#2,D1
	BEQ.S	GLOBIN3          J if end of section list
	MOVE.L	D1,A4            B  = MC addr of the section
	MOVE.L	(A4)+,D1         D1 = BCPL ptr to next sect (or 0)
	MOVE.L	(A4),D2          D2 = the section length in words
	ASL.L	#2,D2            Now in bytes
	LEA.L	-4(A4,D2.L),A3   L(A3) = MC addr of MAXGLOB word
*
GLOBIN1	MOVE.L	-(A3),D2         D2 = entry relative ptr
	BEQ.S	GLOBIN0          J if end of Gn/Ln pairs
	MOVE.L	-(A3),D3         D3 = the global number (n say)
	CMP.L	(G),D3
	BGT.S	GLOBIN2          Error if n too big
	ADD.L	A4,D2            D2 = MC addr of entry
	ASL.L	#2,D3            D3 = Gvec subscript in bytes
	MOVE.L	D2,0(G,D3.L)     Put entry address in global n
	BRA.S	GLOBIN1          Deal with next Gn/Ln pair
*
GLOBIN2	CLR.L	D0               Indicate error in flag
	MOVE.L	#111,D1	      ; FIX! what error is this?!
	BRA	BCPLERROR
*
GLOBIN3	BSR	     GETDATA	      ; get dosbase into A3
	MOVE.L	A3,G_DOSBASE(A2) ; put dosbase in all global vectors!
	MOVE.L	dl_UtilityBase(A3),G_UTILITYBASE(A2)
	MOVE.L	dl_IntuitionBase(A3),G_INTUITION(A2)
	MOVE.L	D0,D1            ; Return flag as result
	JMP	(R)	      ; BCPL routine!


	PAGE
******************************************************************
*                                                                *
*               Qpkt( pkt )                                      *
*                      d1                                        *
* This BCPL callable routine sends a packet by means of a        *
* message structure pointed at by machine ptr in pkt!pkt.link.   *
* The message is sent to the port identified by pkt!pkt.id, and  *
* this field is swapped to indicate the senders port.            *
*								 *
* In C terms, the packet is sent to the current value of dp_Port,*
* and the dp_Port is replaced with the current process's port.	 *
*                                                                *
* Called with C/asm conventions, pkt = CPTR			 *
* NOTE: packet can't be above $7fffffff!!			 *
* Evil: uses dp_Port, and does a swap with your own port.  Now   *
* also sets mn_ReplyPort.  No new programs should rely on the	 *
* swapping.							 *
******************************************************************
*
*
	SECT       <'qpkt   '>
*
@@bcpl_qpkt:
_bcpl_qpkt:
QPKT
	LEA	@@qpkt,A3	; a3 is scratch in BCPL
	BRA.S	pktcommon

RETURNPKT
	LEA	@@returnpkt,A3

pktcommon:
	MOVEM.L A0/A1/A6,-(SP)
	ASL.L	#2,D1		; convert packet BPTR->cptr
	JSR	(A3)
	bra	restore_bcpl_exit	; qpkt sort of returns a value

;==============================================================================
; success = ReturnPkt( pkt, res1, res2 )
;    d0		       d1   d2    d3
;
; modified by REJ
; Send a packet back to the caller
;==============================================================================
@@returnpkt:
_returnpkt:
	MOVE.L	D1,A0
	TST.L	D1		; make sure there is a packet
	BNE.S	10$		; nope, not there
	RTS
10$	MOVEM.L	D2/D3,dp_Res1(a0)	; stash return codes
	;--  fall through!

@@qpkt:
_qpkt:
	MOVE.L	D1,A0		; Pkt into address register - MC ptr
	MOVE.L	dp_Link(A0),D0	; Extract message mc address
	BEQ.S	QPKT1		; Invalid message ptr
	MOVE.L	D0,A1		; msg pointer into A1 for putmsg
	MOVE.L	D1,LN_NAME(A1)	; Ptr to pkt in message name field
	MOVE.L	A6,-(SP)	; Save
	MOVE.L	SysBase,A6
	MOVEQ	#pr_MsgPort,D0
	ADD.L	ThisTask(A6),D0	; addr of pr_MsgPort
	MOVE.L	dp_Port(A0),D1	; Port ID into d1
	MOVE.L	D0,dp_Port(A0)	; Replace my port ID in pkt
*	MOVE.L	D0,MN_REPLYPORT(A1) ; Set up so ReplyMsg() works
	MOVE.L	D1,A0		; Move port into a0 for putmsg
	CALL	PutMsg		;  a6 == execbase, a0 = port, a1 = msg
	MOVEQ	#1,D0		; No error occurred
	MOVE.L	(SP)+,A6
	RTS

*
* a2 = pointer to port to return it to, a6 = sysbase
*
@@qpkt_task:
_qpkt_task:
	MOVE.L	D1,A0		; Pkt into address register - MC ptr
	MOVE.L	dp_Link(A0),D0	; Extract message mc address
	BEQ.S	QPKT1		; Invalid message ptr
	MOVE.L	D0,A1		; msg pointer into A1 for putmsg
	MOVE.L	D1,LN_NAME(A1)	; Ptr to pkt in message name field
	MOVE.L	dp_Port(A0),D1	; Port ID into d1
	MOVE.L	A2,dp_Port(A0)	; Replace my port ID in pkt
*	MOVE.L	A2,MN_REPLYPORT(A1)	; Set up so ReplyMsg() works
	MOVE.L	D1,A0		; Move port into a0 for putmsg
	CALL	PutMsg		; a6 == execbase, a0 = port, a1 = msg
	MOVEQ	#1,D0		; No error occurred
	RTS

* Invalid port. Set error.
QPKT1	MOVEQ	#101,D1		; FIX! use equate!
	BRA	CERROR

	PAGE
******************************************************************
*                                                                *
*                   Packet := Taskwait()                         *
*                                                                *
* This BCPL callable routine waits for a message to arrive.      *
* It then dequeues the message and returns the packet pointed    *
* at by the node name field. The message can be retrieved if     *
* required by following the link field of the packet.            *
*                                                                *
* Converted to C/asm conventions				 *
* NOTE: funny use of ln_Name!					 *
*								 *
* If called from a task, assume that a1 is port address		 *
* should only happen from DoPkt() (sendpkt)			 *
******************************************************************
*
*
	SECT       <'taskwai'>
*
TASKWAI
	MOVE.L	R,-(sp)			; return addr
	; fall thru
@@taskwait:
	MOVEM.L	D7/a0/a1/A6,-(SP)	; Save regs (incl BCPL regs)
	MOVE.L	SysBase,A6
	MOVE.L	ThisTask(A6),A0
	CMP.B	#NT_PROCESS,LN_TYPE(a0)
	BNE.S	is_task			; if not process skip PktWait
	ADD.W	#TC_SIZE,A0		; get pr_MsgPort addr

* See if pktwait function to be called instead
	MOVE.L	pr_PktWait-pr_MsgPort(A0),D1
	BEQ.S	TWait0			; Zero so no special action
	MOVE.L	D1,A0			; Address to call
	JSR	(A0)			; Call it, returns msg in D0
	BRA.S	TWait3

is_task:
	MOVE.L	a1,a0			; for call from task, a1 = port!
TWait0:
	MOVE.L	A0,D7			; Save port address

* Signal can be set from any point now. See if message waiting already.
TWait1:	MOVE.L	D7,A0			; Retrieve port address
	CALL	GetMsg			; a6 = execbase
	TST.L	D0 
	BEQ.S	TWait2			; No message this time

* Message received. Return packet ptr held in name field.
TWait3:	MOVE.L	D0,A0
	MOVE.L	LN_NAME(A0),D0		; Extract packet mc address
	MOVE.L	D0,D1			; For BCPL
	ASR.L	#2,D1			; Convert to BCPL address
	MOVEM.L	(SP)+,D7/a0/a1/A6	; Restore regs
	RTS

* Wait for message to arrive.
TWait2:	MOVE.L	#SIGMASK,D0		; Wait for signal
	CALL	Wait			; a6 = execbase
	BRA.S	TWait1			; Now go get message

	PAGE
*****************************************************************
*                                                               *
*                 RES := SETFLAGS(TASKID,FLAGS)                 *
*                                                               *
* Sets flags of the specified task. We use signal numbers       *
* 12, 13, 14, 15 for this purpose.                              *
*                                                               *
* BCPL routine, not for C/asm programmers                       *
*****************************************************************

	SECT       <'setflag'>
*
SETFLG	MOVEM.L	a0/A1/A6,-(SP)		; Save regs
	MOVE.L	MP_SIGTASK(Z,D1.L),A1	; Get Task Struct
	MOVEQ	#$0F,D0			; Ensure only 4 set
	AND.L	D2,D0			; Mask to D0
	MOVEQ	#12,D3			; Shift required
	LSL.L	D3,D0			; Shift flags up
	CALLS	Signal
SETFLG1
	bra	restore_bcpl_done	; restore regs, jmp (r)

	PAGE
*****************************************************************
*                                                               *
*               RES := TESTFLAGS(FLAGS)                         *
*                                                               *
* Tests and clears the flags of the current task.               *
* On return:                                                    *
*    RES  = FALSE (=0)  None of the specified flags were set    *
*    RES  = TRUE (-1)   At least one specified flag was set     *
*                                                               *
* BCPL routine, not for C/asm programmers			*
*****************************************************************

	SECT       <'testfla'>
*
TSTFLG	MOVEM.L	a0/A1/A6,-(SP)
	MOVEQ	#0,D0		; Signals are to be cleared
	MOVEQ	#12,D2		; Shift required
	MOVEQ	#$F,D3		; Ensure only 4 signals used
	AND.L	D3,D1
	MOVE.L	D1,D3		; Save mask
	LSL.L	D2,D1		; Move mask up
	CALLS	SetSignal	; Clear specified flags, return setting
	MOVEQ	#0,D1		; Anticipate answer FALSE
	LSR.L	D2,D0		; Shift old signals down
	AND.L	D3,D0		; Mask with request
	BEQ.S	TSTFLG1		; None set
	MOVEQ	#-1,D1		; Return TRUE if some set
TSTFLG1
	BRA.S	SETFLG1		; Restore & return

	PAGE
******************************************************************
*                                                                *
*           Res := EXEC( CODE, D0, D1, A0, A1, A2 )              *
*                                                                *
* This BCPL callable routine provides a general interface to the *
* ROM routines provided by EXEC.                                 *
*                                                                *
* BCPL routine, unneeded by C/asm programmers			 *
******************************************************************
*
*
	SECT       <'Exec   '>
*
EXEC    MOVEM.L	A0-A2/A6,-(SP)	; Save regs
	MOVE.L	D1,D7		; Save request code
	MOVE.L	D2,D0		; Arg2 is D0
	MOVE.L	D3,D1		; Arg3 is D1
	MOVE.L	D4,A0		; Arg4 is A0
	MOVE.L	20(P),A2	; Arg6 is A2
	MOVE.L	16(P),A1	; Arg5 is A1
	MOVE.L	SysBase,A6	; Library pointer
	JSR	0(A6,D7.W)	; Call routine
	MOVEM.L	(SP)+,A0-A2/A6	; Restore regs
	MOVE.L	D0,D1		; Result in D1
	JMP	(R)		; And return

	PAGE
******************************************************************
*                                                                *
*           Res := CALLRES( LIB, CODE, D0, D1, A0, A1 )          *
*                                                                *
* This BCPL callable routine provides a general interface to the *
* ROM routines provided by other libraries.                      *
*                                                                *
* BCPL only routine, unneeded by C/asm programmers		 *
******************************************************************
*
*
	SECT       <'Callres'>
*
CALLRES	MOVEM.L	A0/A1/A6,-(SP)		; Save regs
	MOVE.L	D1,A6			; Library pointer to A6
	MOVE.L	D2,D7			; Save request code
	MOVE.L	D3,D0			; Arg3 is D0
	MOVE.L	D4,D1			; Arg4 is D1
	MOVE.L	16(P),A0		; Arg5 is A0
	MOVE.L	20(P),A1		; Arg6 is A1
	JSR	0(A6,D7.W)		; Call it
	bra	restore_bcpl_exit

	PAGE
******************************************************************
*                                                                *
*         Res := GETLONG(Base, Byteoffset)                       *
*                PUTLONG(Base, Byteoffset,Val)                   *
*                                                                *
* These BCPL callable routines are used to access long sized     *
* values which are not long word aligned                         *
*                                                                *
* BCPL only routines, unneeded by C/asm programmers		 *
******************************************************************
*
*
	SECT       <'Getlong'>
*
GETLONG	ASL.L	#2,D1		; mc ptr
	ADD.L	D2,D1		; add byte offset
	MOVE.L	0(Z,D1.L),D1	; get lword
	JMP	(R)
*
	SECT       <'Putlong'>
*
PUTLONG	ASL.L	#2,D1		; mc ptr
	ADD.L	D2,D1		; add byte offset
	MOVE.L	D3,0(Z,D1.L)	; put lword
	JMP	(R)		; And return

	PAGE
*
* These routines provide BCPL io support with read only globals
* C/BCPL routines
*
_CurrentDir:
	MOVE.W	#pr_CurrentDir-pr_MsgPort,D0
	BRA.S	selcommon
*
@@SetProgramDir:
_SetProgramDir:
	MOVE.W	#pr_HomeDir-pr_MsgPort,D0
	BRA.S	selcommon
*
@@SetArgStr:
_SetArgStr:
	MOVE.W	#pr_Arguments-pr_MsgPort,D0
	BRA.S	selcommon
*
@@setfilesys:
_setfilesys:
	MOVEQ	#pr_FileSystemTask-pr_MsgPort,D0
	BRA.S	selcommon
*
@@setconsole:
_setconsole:
	MOVEQ	#pr_ConsoleTask-pr_MsgPort,D0
	BRA.S	selcommon
*
SELIN	MOVE.L	R,-(SP)
@@selectinput:
_selectinput:
	MOVEQ	#pr_CIS-pr_MsgPort,D0
	BRA.S	selcommon
*
SELOUT	MOVE.L	R,-(SP)			; return addr
@@selectoutput:
_selectoutput:
	MOVEQ	#pr_COS-pr_MsgPort,D0
selcommon
	BSR.S	@@getid
	MOVE.L	0(a0,d0.w),-(sp)	; get old value
	MOVE.L	D1,0(a0,d0.w)		; set with new value
	MOVE.L	(sp)+,D0		; return old value
	MOVE.L	D0,D1			; BCPL return in D1
	SUB.L	A0,A0			; BCPL needs A0 == 0
	RTS

******************************************************************
*                                                                *
* Routines to provide information from the process structure     *
* Returns task id (msgport) in L (A3)				 *
*                                                                *
* BCPL routine, C/asm use FindTask()				 *
******************************************************************
*
* id := taskid()
*
* Return process id
* BCPL routine
*
@@taskid:
	BSR.S	@@getid
	MOVE.L	A0,D0
	RTS

TASKID	BSR.S	GETID
	MOVE.L	A3,D1		; L
	JMP	(R)

*
* Service routine to locate my process id, and return it in L
* No other regs affected
*
GETID	MOVE.L	SysBase,A3
	MOVE.L	ThisTask(A3),A3
	ADD.W	#TC_SIZE,A3	; pointer to messageport
	RTS
*
* Faster than FindTask(0), smaller than define
*
@@myproc	MOVE.L	SysBase,A0
	MOVE.L	ThisTask(A0),d0
	RTS
*
* C version: returns msgport in A0!
* Musn't modify d0/d1/a1!
*
@@getid	MOVE.L	SysBase,A0
	MOVE.L	ThisTask(A0),A0
	ADD.W	#TC_SIZE,A0	; pointer to messageport
	RTS

*
* lock = GetProgramDir()
*
* Return lock on home directory of program - do NOT unlock!
*
@@GetProgramDir
	MOVE.W	#pr_HomeDir-pr_MsgPort,D0
	BRA.S	ProcCommon
*
* string = ArgStr()
*
* Return pointer to initial argument string for process
*
@@ArgStr
	MOVE.W	#pr_Arguments-pr_MsgPort,D0
	BRA.S	ProcCommon
*
* list := seglist()
*
* Return segment list
*
SEGL   	  MOVE.L	R,-(SP)		; return addr
@@seglist:
	MOVE.W	#pr_SegList-pr_MsgPort,D0
	BRA.S	ProcCommon
*
* task := consoletask()
*
* Return console task id
*
CTASK	MOVE.L	R,-(SP)		; return addr
@@consoletask:
	MOVE.W	#pr_ConsoleTask-pr_MsgPort,D0
	BRA.S	ProcCommon
*
* result2 = getresult2()
*
* Return result2 for a task
*
GETR2	MOVE.L	R,-(SP)		; return addr
@@getresult2:
	MOVE.W	#pr_Result2-pr_MsgPort,D0
	BRA.S	ProcCommon
*
* input fh = input()
*
* Return pr_CIS for a task
*
INPUT	MOVE.L	R,-(SP)		; return addr
@@input:
	MOVE.W	#pr_CIS-pr_MsgPort,D0
	BRA.S	ProcCommon
*
* output fh = output()
*
* Return pr_COS for a task
*
OUTPUT	MOVE.L	R,-(SP)		; return addr
@@output:
	MOVE.W	#pr_COS-pr_MsgPort,D0
	BRA.S	ProcCommon
*
* cli pointer = cli()
*
* Return pr_CLI for a task (CPTR for C, BPTR for bcpl)
*
CLI	MOVE.L	R,-(SP)		; return addr
@@cli:
	MOVE.W	#pr_CLI-pr_MsgPort,D0
	BSR.S	ProcCommon		; returns in both D0/D1
	LSL.L	#2,D0			; so C/asm get CPTR, BCPL get BPTR!
	RTS
*
* task := filesystemtask()
*
* Return filing system task id
*
FTASK	MOVE.L	R,-(SP)		; return addr
@@filesystemtask:
	MOVE.W	#pr_FileSystemTask-pr_MsgPort,D0

*
* must preserve a0/a1 for BCPL
*
ProcCommon:
	BSR.S	@@getid		; returns msgport addr in a0
	MOVE.L	0(A0,D0.W),D1	; get value out of process structure
	MOVE.L	D1,D0		; for C/asm
	SUB.L	A0,A0		; restore Z reg for BCPL
	RTS
*
* rc := RESULT2(alter,val)
*
* Returns value of RESULT2, and sets it if ALTER is true
* C/BCPL routine(s)
* MUST NOT TOUCH A1! 
*
@@SetIoErr:				; for dos.library
	MOVE.L	D1,D0
@@setresult2:				; param in D0!!!!!
	MOVE.L	D2,-(SP)
	MOVE.L	D0,D2
	MOVEQ	#-1,D1			; force set of result2
	BSR.S	@@result2
	MOVE.L	(SP)+,D2
	RTS

RES2	BSR.S	@@result2		; destroys A0

*
* common restore a0 and exit routine for bcpl
*
bcplcommon
	SUB.L	a0,a0
	JMP	(R)
	
@@result2:
	BSR.S	@@getid				; Get ID into a0
	LEA.L	pr_Result2-pr_MsgPort(a0),a0	; Point to val
	BRA.S	UPDTE
*
* rc := currentdir(alter,val)
*
* Returns value of currentdir, and alters it
* C/BCPL routine
* MUST NOT TOUCH A1! 
*
CDIR	BSR.S	@@currentdir
	BRA.S	bcplcommon
@@currentdir:
_currentdir:
	BSR	@@getid
	LEA.L	pr_CurrentDir-pr_MsgPort(a0),a0

UPDTE	TST.L	D1		; Update?
	BNE.S	UPDTE1		; No, return value
	MOVE.L	(a0),D1
	MOVE.L	D1,D0
	RTS

UPDTE1	MOVE.L	(a0),D1
	MOVE.L	D2,(a0)		; return old value!
	MOVE.L	D1,D0		; for BCPL and C
	RTS

*
*
* This service routine returns with the address of the DOS
* data area in L (A3). All registers are saved.
*
* opendosbase can be called from tasks!
*
@@opendosbase:
	move.l	a3,d0		; save a3 (GETDATA hits it, saves all others)
	bsr.s	GETDATA
	exg.l	a3,d0		; swap a3 and d0, restoring a3, setting return
	rts

GETDATA
	MOVEM.L	D0/D1/A0/A1/A6,-(SP)
	LEA	LIBNAME(PC),A1	; dos.library
	MOVEQ	#0,D0		; Version
	CALLS	OpenLibrary
	MOVE.L	D0,A3		; L
	MOVE.L	A3,A1
	CALL	CloseLibrary	; Keep use count correct
	MOVEM.L	(SP)+,D0/D1/A0/A1/A6
	RTS

*
* Uses the pr_Globvec from your process
* only touches a0/d0!!!!
*
@@dosbase:
	MOVE.L	SysBase,A0
	MOVE.L	ThisTask(A0),A0
	MOVE.L	pr_GlobVec(A0),A0
	MOVE.L	G_DOSBASE(A0),D0
	RTS

*
* This routine stores a value in Intuitionbase in the globvec
* Needed by BCPL routines.  Takes parameter in A0!
*
@@store_IBase:
	MOVE.L	SysBase,A1
	MOVE.L	ThisTask(A1),A1
	MOVE.L	pr_GlobVec(A1),A1
	MOVE.L	A0,G_INTUITION(A1) ; store it
	MOVE.L	G_DOSBASE(a1),a1
	MOVE.L	a0,dl_IntuitionBase(a1)
	RTS
*
* Call setprefs for me (gets ibase from globvec) (a0 = prefs, d0 = size)
*
@@MySetPrefs:
	MOVE.L	A6,-(A7)
	MOVE.L	SysBase,A6
	MOVE.L	ThisTask(A6),A6
	MOVE.L	pr_GlobVec(A6),A6
	MOVE.L	G_INTUITION(A6),A6		; GET IBASE IN a6
	MOVEQ	#1,D1				; notify
	JSR	_LVOSetPrefs(A6)
	MOVE.L	(A7)+,A6
	RTS
*
* Routine to return pointer to root structure
* BCPL and C versions
*
ROOTN	BSR.S	@@rootstruct
	LSR.L	#2,D0
	MOVE.L	D0,D1
	SUB.L	A0,A0
	JMP	(R)

@@rootstruct:
	BSR.S	@@dosbase
	MOVE.L	D0,A0
	MOVE.L	dl_Root(A0),D0   Pointer to rootnode
	RTS

	PAGE
	TTL        "Error Handler"
*************************************************************************
*
* This section of code gets called when an exception is encountered.
* It saves all the registers and then calls the routine Abort.
*
AbortHandler
	MOVE.L	a6,-(sp)		; save a reg so we can play
	MOVE.L	USP,a6
	MOVEM.L	D0-D7/A0-A6,-(a6)	; note: a6 we pushed is wrong
	MOVE.L	(sp)+,(8+6)*4(a6)	; skip 8 data regs, 6 addr regs
	MOVE.L	(SP)+,d1		; Code into arg

* update USP
	MOVE.L	a6,USP			; update the USP so we can switch

* we now are pointing the exception frame (@@sp)  We want to drop it.
* Punt, it's too hard for the gain.  Punch the upper SSP bound into SSP
	move.l	$4,a6
	move.l	SysStkUpper(a6),SP

* switch back to user mode
	ANDI.W	#(~$2000),SR

* Get Exec's handler, and patch it in to stop runaway
	MOVE.L	TaskTrapCode(A6),A2
	MOVE.L	ThisTask(A6),A0
	MOVE.L	A2,TC_TRAPCODE(A0)

* Now call Abort( Code )
	BSET.L	#31,D1			; Add AT_DeadEnd bit
	BSR.S	@@abort			; Call Abort
* abort should never come back!


******************************************************************
*                                                                *
*           ABORT( Code )                                        *
*                                                                *
* This BCPL callable routine displays a requestor, then when the *
* user presses Continue it calls an Alert if it was called with  *
* a DOS code, and returns to caller otherwise. The message is    *
* slightly different depending on whether it was a disk error.   *
*                                                                *
* We want it to look like this:					 *
*	Software Failure					 *
*								 *
*	            Professional Page				 *
*	     has failed (error code #00000000)			 *
*	       Wait for disk activity to end			 *
*								 *
******************************************************************
*
*
ABORT
	MOVE.L	R,-(SP)
@@abort
_abort
	;-- movem transfers a6 first, moving down.  leaves sp->d1
	MOVEM.L	D1-D7/A0/A1/A6,-(SP)	; save regs for below and BCPL
	move.l	d1,d5

	CMPI.L	#AN_KeyRange!AT_DeadEnd,D1	; Disk error?
	BNE.S	get_name			; No..

	MOVEQ	#STR_DISK_CORRUPT,d1
	BSR	@@getstring
	move.l	d0,a1
	bra.s	gotname

	;-- get the program name (or process name)
get_name:
	move.l	$4,a6
	move.l	ThisTask(a6),a0
	move.l	LN_NAME(a0),a1
	move.l	a1,d0
	bne.s	goodname
	lea.l	corrupt_name(pc),a1
goodname:
	cmp.b	#NT_PROCESS,LN_TYPE(a0)
	bne.s	gotname

	;-- process
	move.l	pr_CLI(a0),d0
	asl.l	#2,d0
	beq.s	gotname			; no cli, use task name
	move.l	d0,a0
	move.l	cli_CommandName(a0),d0
	asl.l	#2,d0
	beq.s	gotname			; sanity check
	move.l	d0,a1
	moveq	#0,d0
	move.b	(a1)+,d0		; get length of BSTR
	clr.b	0(a1,d0)		; terminate it

gotname:	;-- name is in a1
	move.l	a1,d6			; will go in d1 later

	MOVEQ	#STR_TASK_FAILED,d1
	BSR	@@getstring
	MOVE.L	D0,D2

	MOVEQ	#STR_WAIT_DISK,d1
	BSR	@@getstring
	MOVE.L	D0,D3

	MOVE.L	D6,D1			; put it back

	MOVE.L	#1<<14,D4	  ; NEWPREFS - really means use Suspend|Reboot
	BSR	@@requester2	  ; d5 is also a parameter - the error

* If the user presses Suspend, do Wait(0)

	TST.L	D0
	Beq.S	reboot
	MOVEQ	#0,d0
	CALLS	Wait		; never returns

* If the user presses Cancel, we call an Alert if DOS errors or
* return otherwise.
reboot:
	MOVE.L	d5,D7		; Code passed. If top bit set then Alert
	BPL.S	ABORT2

* non-recoverable: call alert
* setup of a5 unneeded in 2.0, but lets do it anyways (4 bytes)

	MOVE.L	SysBase,a6
	LEA	ThisTask(a6),a5		; pointer to task that errored
	CALL	Alert

ABORT2  MOVEM.L	(SP)+,D1-D7/A0/A1/A6
	RTS

corrupt_name:
	dc.b	0			; FIX! put something here
	ds.w	0

	PAGE
	SECT       <'RunComm'>
**************************************************************************
*
* rc := runcommand( seg, stacksize, paramptr, paramlen )
* BCPL:		    BPTR   LONGS      BPTR      LONG
* C:		    BPTR   BYTES      CPTR      LONG
*
* This code runs a command under TRIPOS in a language independent
* fashion. A stack of specified size is constructed, and the entry point
* of the code is assumed to be the first executable word of the first
* hunk in the segment list (which is a list of code blocks linked by BCPL
* pointers). All TRIPOS registers are saved, and the code is entered with
* the SP at the base of the new stack, having pushed a suitable return
* address, the size of the stack and the caller's stack onto it first of all.
* In addition the previous return address for STOP is saved, and a new
* one installed.
*
* Thus a program running under Tripos will find a stack as follows
*
* ReturnAddress    StackSize   CallerStack
*
* The registers are set up as follows (any register may be corrupted
* except SP).
* 
* D0  Size of parameter string in bytes
* A0  Pointer to parameter string area
*
* pr_Arguments is set to the arguments and restored afterwards
* NOTE: arguments are a CSTR!
* 
* The routine returns
* -1  if the program could not be loaded (result2() has more info)
* 0   if the program ran and did not set a return code
* >0  if the program set a return code (result2() normally has more info)
*

RUNC
	MOVE.L	R,-(SP)			; return addr
	ASL.L	#2,D2			; stacksize to bytes
	ASL.L	#2,D3			; BPTR to CSTR -> CPTR to CSTR
					; fall thru

_InternalRunCommand:
@@InternalRunCommand:
	MOVEM.L	D2-D7/A0-A6,-(SP)	; save tripos regs too
*
* set up BCPL environment!!!!!!!!!!!!
* Actually, that would be hard.  People like Manx fexec WILL break, I'm afraid,
* just like they did for 1.2.
* I'll try though....
*
* Note that I put the BCPL a1 (P) on the NEW stack, not the old one,
* because I can't get a hold of the calling BCPL processes a1 to use here.
* Possible solution: seperate runcommands (and fault!) for BCPL and C.
* ARGH!!!!!!! (FIX)
*
*Manx code:
*	ret_val = _doexec(len, stksiz, stksiz+8, len, arg, (seg+1)<<2, stk.ll);
*...
*	link	a5,#0
*	movem.l	d1/a6,-(sp)
*	movem.l	d3-d7/a2-a5,-(sp)		;save registers
*	move.l	sp,__mysp				;save our sp
*	movem.l	8(a5),d0/d2/d3/d4/a0/a4/a7	;load params
*	move.l	4(sp),a3				;get old sp from CLI
*	movem.l	4(a3),a1/a2/a5/a6		;get BCPL environment
*	move.l	d0,12(a1)				;set length
*	move.l	a0,d1					;copy to dreg
*	lsr.l	#2,d1					;convert to BPTR
*	move.l	d1,8(a1)				;set ptr
*	move.l	a0,d1					;copy to d1 as well
*	jsr	(a4)
*
	BSR	GETDATA			; Get dosbase in a3
	MOVEM.L	dl_A2(a3),a2/a5/a6
	BSR	GETID			; Get process ID (MsgPort) in L (A3)

*
* Save pr_Arguments for restoration later, set new value
*
	MOVE.L	pr_Arguments-pr_MsgPort(a3),-(SP)
	MOVE.L	D3,pr_Arguments-pr_MsgPort(a3)

* NOTE that getvec allocated 2 LWs more than asked - 1 for len, 1 extra!
* VERY important: BCPL-startup.asm relies on this!!!

	MOVE.L	D1,D7		; save for later
	MOVE.L	D2,D0		; Stacksize in D2 (bytes)
	ADDQ.L	#4,D0		; since we now use Exec AllocVec
	BSR	@@AllocVecPub	; get memory
	TST.L	D0		; Check worked
	BEQ.S	RUNERRL		; Error

* Save old stack boundaries on old stack
	move.l	TC_SPLOWER-pr_MsgPort(a3),-(sp)
	move.l	TC_SPUPPER-pr_MsgPort(a3),-(sp)
	move.l	a3,-(sp)		; so we can grab it later

* now finish setting up BCPL/Manx fexec environment...
* fixing fexec probably won't work, but worth a try.
*
	MOVE.L	d0,a1			; this must be maintained until jsr
	ADDQ.W	#4,a1			; For safety, I think it can be munged
					; otherwise.
	MOVEM.L	a1/a2/a5/a6,-(sp)	; Only for compatibility

* now finish setting up the new stack

	ADD.L	D2,D0		; D0 is now high stack address
	ADDQ.L	#4,D0		; Now top stack ptr (bytes) (extra LW)
	MOVE.L	D0,A4		; Into B (A4)

	MOVE.L	d7,d1
	MOVEM.L	d1-d4,(a1)	; Store params for EVIL programs!!!!
		
	MOVE.L	pr_ReturnAddr-pr_MsgPort(A3),-(SP) ; Save old return address
	MOVE.L	SP,-(A4)		; Push my old stack ptr onto new stack
	MOVE.L	D2,-(A4)		; Push stacksize onto new stack (bytes)
*
* Remember the base stack in the process base for STOP.
*
	MOVE.L	A4,pr_ReturnAddr-pr_MsgPort(A3)	; Store new returnaddr stack
; FIX! protection from here to sp_xxx swap!!!
	MOVE.L	A4,SP		; New stack ptr
	move.l	a1,TC_SPLOWER-pr_MsgPort(a3)
	lea	8(sp),a0	; old stack pointer and stack size
	move.l	a0,TC_SPUPPER-pr_MsgPort(a3)
	ASL.L	#2,D7		; Segment as mc ptr
	MOVE.L	D7,A3		; Save seglist in A3
	MOVE.L	D3,A0		; CPTR to params into A0
	MOVE.L	D4,D0		; Args size
	JSR	4(A3)		; Hold tight - may whomp registers
*
* The loaded command should return here. Convention indicates that D0
* contains the return code. SP should be set to point to the stacksize.
*
RETADD	MOVEM.L	(SP)+,D2/D3	; Extract stack size and my stack
	MOVE.L	SP,D1		; Save old stack ptr
; FIX! protection from here to sp_xxx swap!
	MOVE.L	D3,SP		; New stack now
	MOVE.L	(SP)+,D7	; Remember previous returnaddr
	ADD.W	#16,SP		; Dump 4 regs pushed on for compatibility
	move.l	(sp)+,a3	; get process msgport addr back
	move.l	(sp)+,TC_SPUPPER-pr_MsgPort(a3)
	move.l	(sp)+,TC_SPLOWER-pr_MsgPort(a3)
	MOVE.L	D7,pr_ReturnAddr-pr_MsgPort(A3)	; Restore saved return address
	MOVE.L	D0,-(SP)	; Save return code - TRICKY!
	SUB.L	D2,D1		; D1 = Low stack + 1 LW
	SUBQ.L	#4,D1		; Now Stack Base
	MOVE.L	D1,A1		; FreeVec is in exec
	CALLS	FreeVec		; free stack (a6 is scratch here)
	MOVE.L	(SP)+,D0	; return code
restore_exit:
*
* restore pr_Arguments
*
	MOVE.L	(SP)+,pr_Arguments-pr_MsgPort(a3)

	MOVEM.L	(SP)+,D2-D7/A0-A6	; restore all C/asm regs
	MOVE.L	D0,D1			; for BCPL
	RTS
*
* Here if out of memory
*
RUNERRL MOVEQ	#-1,D0
	BRA.S	restore_exit

	PAGE
**********************************************************************
*                                                                    *
*       STOP(RC)                                                     *
*                                                                    *
*    Returns from either a command called through RUNCOMMAND         *
*    or deactivates a process. It simply returns to the return       *
*    address saved on the stack pointed to by pr_ReturnAddr-pr_MsgPort-4 *
*                                                                    *
* Always has been a C/asm routine interface			     *
**********************************************************************
@@exit:
NSTOP   BSR	@@getid		; Get my ID
	MOVE.L	pr_ReturnAddr-pr_MsgPort(A0),D0	; New stack ptr
	SUBQ.L	#4,D0		; Point to return address
	MOVE.L	D0,SP
	MOVE.L	D1,D0		; Return code into D0
	SUB.L	A0,A0		; restore the Z reg for BCPL
	RTS			; Return to saved address (usually DEACT)

	PAGE
**********************************************************************
*		Globals to be initialised                            *
*                                                                    *
**********************************************************************

	IFD KLUDGE
	INCLUDE	"downc.asm"
	INCLUDE	"mlib.asm"
	ENDC

	CNOP	0,4		; Align
GLOBEND	DC.L	0		; End of the global list

; globals from downc.asm:

	dc.l	G_CTOB/4,(BCPLCtoB-KLIB)
	dc.l	G_BTOC/4,(BCPLBtoC-KLIB)
	dc.l	G_CLEARVEC/4,(CLEARVEC-KLIB)
	dc.l	G_COPYSTRING/4,(COPYSTRING-KLIB)
	dc.l	G_COPYVEC/4,(COPYVEC-KLIB)
	dc.l	G_UNPACKSTRING/4,(UNPACKSTRING-KLIB)
	dc.l	G_PACKSTRING/4,(PACKSTRING-KLIB)
	dc.l	G_CAPITALCH/4,(CAPITALCH-KLIB)
	dc.l	G_COMPCH/4,(COMPCH-KLIB)
	dc.l	G_COMPSTRING/4,(COMPSTR-KLIB)

; globals from mlib.asm:

	dc.l	G_MULTIPLY/4,(MULTIPLY-KLIB)
	dc.l	G_DIVIDE/4,(DIVIDE-KLIB)
	dc.l	G_REMAINDER/4,(REMAINDER-KLIB)
	dc.l	G_GBYTES/4,(GBYTES-KLIB)
	dc.l	G_PBYTES/4,(PBYTES-KLIB)
	dc.l	G_GETBYTE/4,(GETBYTE-KLIB)
	dc.l	G_PUTBYTE/4,(PUTBYTE-KLIB)
	dc.l	G_GET2BYTES/4,(GET2BYTES-KLIB)
	dc.l	G_PUT2BYTES/4,(PUT2BYTES-KLIB)
	dc.l	G_LEVEL/4,(LEVEL-KLIB)
	dc.l	G_LONGJUMP/4,(LONGJUMP-KLIB)
	dc.l	G_APTOVEC/4,(APTOVEC-KLIB)
	dc.l	G_CREATECO/4,(CREATECO-KLIB)
	dc.l	G_DELETECO/4,(DELETECO-KLIB)
	dc.l	G_COWAIT/4,(COWAIT-KLIB)
	dc.l	G_RESUMECO/4,(RESUMECO-KLIB)
	dc.l	G_CALLCO/4,(CALLCO-KLIB)

; globals from klib(doslib):

	dc.l	G_GLOBIN/4,(GLOBIN-KLIB)	; pure BCPL
	dc.l	G_GETMEM/4,(GETM-KLIB)		; BCPL
	dc.l	G_GETVEC/4,(GETVEC-KLIB)	; BCPL
	dc.l	G_FREEVEC/4,(FREEVEC-KLIB)	; BCPL
	dc.l	G_OPENDEVICE/4,(OPEND-KLIB)	; pure BCPL
	dc.l	G_SETIO/4,(SETIO-KLIB)		; pure BCPL
	dc.l	G_DOIO/4,(DOIO-KLIB)		; pure BCPL
	dc.l	G_SENDIO/4,(SEND_IO-KLIB)	; pure BCPL
	dc.l	G_CLOSEDEVICE/4,(CLOSED-KLIB)	; pure BCPL
	dc.l	G_CREATETASK/4,(CRTASK-KLIB)	; interface
	dc.l	G_ICREATEPROC/4,(CRPROC-KLIB)	; interface
	dc.l	G_DELETETASK/4,(DELTASK-KLIB)	; pure BCPL/C
	dc.l	G_SETFLAGS/4,(SETFLG-KLIB)	; pure BCPL
	dc.l	G_TESTFLAGS/4,(TSTFLG-KLIB)	; pure BCPL
	dc.l	G_ABORT/4,(ABORT-KLIB)		; BCPL
	dc.l	G_ROOTSTRUCT/4,(ROOTN-KLIB)	; BCPL
	dc.l	G_TASKWAIT/4,(TASKWAI-KLIB)	; BCPL
	dc.l	G_PKTWAIT/4,(TASKWAI-KLIB)	; BCPL (dup of taskwait)
	dc.l	G_QPKT/4,(QPKT-KLIB)		; BCPL
	dc.l	G_RETURNPKT/4,(RETURNPKT-KLIB)	; BCPL
	dc.l	G_EXEC/4,(EXEC-KLIB)		; pure BCPL
	dc.l	G_CALLRES/4,(CALLRES-KLIB)	; pure BCPL
	dc.l	G_RESULT2/4,(RES2-KLIB)		; BCPL
	dc.l	G_CURRENTDIR/4,(CDIR-KLIB)	; BCPL
	dc.l	G_TASKID/4,(TASKID-KLIB)	; BCPL
	dc.l	G_SEGLIST/4,(SEGL-KLIB)		; BCPL
	dc.l	G_SELECTINPUT/4,(SELIN-KLIB)	; BCPL
	dc.l	G_SELECTOUTPUT/4,(SELOUT-KLIB)	; BCPL
	dc.l	G_INPUT/4,(INPUT-KLIB)		; BCPL
	dc.l	G_OUTPUT/4,(OUTPUT-KLIB)	; BCPL
	dc.l	G_CONSOLETASK/4,(CTASK-KLIB)	; BCPL
	dc.l	G_FILESYSTEMTASK/4,(FTASK-KLIB)	; BCPL
	dc.l	G_GETLONG/4,(GETLONG-KLIB)	; pure BCPL
	dc.l	G_PUTLONG/4,(PUTLONG-KLIB)	; pure BCPL
	dc.l	G_RUNCOMMAND/4,(RUNC-KLIB)	; BCPL
	dc.l	G_STOP/4,(NSTOP-KLIB)		; pure
	dc.l	G_CLI/4,(CLI-KLIB)		; BCPL

	DC.L	G_GLOBMAX/4		; Highest referenced global

KEND      END
@


36.66
log
@Modify AddSegArray to add the memory to the tc_MemEntry list, so a RemTask
will free it (as we promised developers).
@
text
@d579 1
a579 1
	LEA	TIMER(pc),A0
d844 1
a844 1
TIMER     DC.B	     'timer.device',$00		; CSTR
@


36.65
log
@Use TaggedOpenLibrary
@
text
@d1219 14
d1240 1
a1240 6
	MOVE.L	D0,-(SP)			; Size onto stack
	MOVE.L	#MEMF_PUBLIC+MEMF_CLEAR,-(SP)	; Requirements
	MOVE.W	#1,-(SP)			; Number of entries
	LEA.L	-LN_SIZE(SP),SP			; Leave space for node
	MOVE.L	SP,A0				; Arg into A0
	CALL	AllocEntry			; Get Memory
a1250 1
	LEA.L	LN_SIZE+10(SP),SP		; Adjust stack
d1341 2
a1342 1
* fake seglist if needed.  Must be callable from a Task.
d1349 1
a1349 1
	movem.l	d2-d4/a2-a3,-(sp)
d1359 12
a1370 2
	bsr	@@AllocVecPubClear
	move.l	d0,a3				; segarray (list of seglists)
a1371 1
	beq.s	adderr				; no mem!
d1405 2
a1406 2
adderr:
	movem.l	(sp)+,d2-d4/a2-a3
d1408 2
@


36.64
log
@Made @@xxx versions of some routines (so sas 6.0 will like dos)
@
text
@d100 2
d125 1
d554 2
a555 3
	MOVEQ	#0,d0			; any version will do for now
	LEA	UTILITY(pc),A1
	CALL	OpenLibrary
d698 2
a699 3
	LEA.L	EXPNAME(pc),A1
	MOVEQ	#0,D0			; Any version
	CALL	OpenLibrary		; NOTE: not a process yet!!!!!
d842 2
a843 2
EXPNAME   DC.B       'expansion.library',$00	; CSTR
UTILITY   DC.B       'utility.library',$00	; CSTR
@


36.63
log
@DAMN hurricane crashes if Data cache is turned on without page tables
that disable it for chip registers!!!!!
Setpatch will turn data cache on
@
text
@d156 1
d158 1
d160 1
d1407 1
d1486 1
d1505 1
@


36.62
log
@qpkt no longer sets MN_REPLYPORT (apparently the init_stdpkt.c code example
in the Bantam manual said you coul duse it for your own.
Safe change
@
text
@d526 6
a531 2
USE_CACHE_CALLS	EQU	1

@


36.61
log
@COmment changes concerning NP_Arguments and CNP()
/
@
text
@d1863 1
a1863 1
	MOVE.L	D0,MN_REPLYPORT(A1) ; Set up so ReplyMsg() works
d1882 1
a1882 1
	MOVE.L	A2,MN_REPLYPORT(A1)	; Set up so ReplyMsg() works
@


36.60
log
@made all globvecs include G_INTUITIONBASE
@
text
@d236 1
d1479 1
a1479 1
	;-- returncode is in d0
d1498 15
a1512 5
	MOVE.L	pr_Arguments(A6),A0	; argument parameter
	MOVE.L	A0,d0
	BEQ.S	noargs
	BSR	@@strlen			; length returned in d0
	MOVE.L	pr_Arguments(A6),A0	; get str ptr back
@


36.59
log
@moved bcpl interface to fakeblib.asm
(saves space)
@
text
@d1780 1
a1780 1
				      ; All should have utility.library also!
d2357 2
@


36.58
log
@changed parameters to request2 - d4, not d0
@
text
@a2759 1
	dc.l	G_COMPAREDATE/4,(CDATE-KLIB)
@


36.57
log
@Back to cachecleare...
@
text
@d2447 1
a2447 1
	MOVEM.L	D1-D5/D7/A0/A1/A6,-(SP)	; save regs for below and BCPL
d2484 1
a2484 1
	move.l	a1,d4			; will go in d1 later
d2494 1
a2494 1
	MOVE.L	D4,D1			; put it back
d2496 1
a2496 1
	MOVE.L	#1<<14,D0	  ; NEWPREFS - really means use Suspend|Reboot
d2519 1
a2519 1
ABORT2  MOVEM.L	(SP)+,D1-D5/D7/A0/A1/A6
@


36.56
log
@Use CacheClearU, CacheClearE not ready
@
text
@d122 1
a122 1
	XREF	_LVOCacheClearU
d821 1
a821 2
 moveq #-1,d0 ; FIX!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	jsr	_LVOCacheClearU(a6)
@


36.55
log
@use CacheCLearE instead of CacheClearU
@
text
@d122 1
a122 1
	XREF	_LVOCacheClearE
d821 2
a822 1
	jsr	_LVOCacheClearE(a6)
@


36.54
log
@added CurrentDir from blib
@
text
@d122 1
a122 1
	XREF	_LVOCacheClearU
a817 1
	;-- ignore params until exec has new function
d820 2
a821 2
	moveq	#CACRF_ClearI,d0
	jsr	_LVOCacheClearU(a6)
@


36.53
log
@Fixed cache clear calls
@
text
@d178 1
d2080 4
@


36.52
log
@There's a C wrapper around RunCommand now
@
text
@d122 2
d140 1
a665 4
* FIX! should flush icache here!!!!! (FindResSeg builds code!)
*
	
*
d802 22
a823 1
* FIX! clear i-cache!
a824 3
	LSR.L	#2,D0		BPTR to seglist
	MOVE.L	D0,0(A3,d2.w)	syssegl[d2] = seglist
	RTS
d1331 1
a1331 1
	movem.l	d2-d3/a2,-(sp)
d1342 1
a1342 1
	move.l	d0,a0				; segarray (list of seglists)
d1346 1
d1350 3
a1352 3
	move.w	#$4ef9,5*4+4(a0)		; JMP xxx.L
	move.l	d3,5*4+6(a0)			; address to call
	move.l	d0,d2
d1354 5
a1358 1
* FIX!!! clear i-cache!!
d1361 3
a1363 3
	;-- d2 has seglist (BPTR) a2 - new process 
	;-- a0 has segarray, d0 has segarray BPTR
	move.l	d0,pr_SegList(a2)	; put in new proc
d1367 1
a1367 1
	move.l	d0,(a0)+		; C procs don't use globin
d1370 1
a1370 1
	move.l	d0,(a0)+		; BPTR to klib segment
d1373 2
a1374 2
	move.l	d0,(a0)+		; BPTR to blib segment
	move.l	d2,(a0)+		; our seglist
d1379 1
a1379 1
	movem.l	(sp)+,d2-d3/a2
@


36.51
log
@saved 2 bytes
@
text
@d200 2
a201 2
	XDEF	@@runcommand
	XDEF	_runcommand
a207 1
	XDEF	doslib_runcommand
d2543 2
a2544 5
doslib_runcommand:			; entry for dos.library
	MOVE.L	D4,D0			; C version wants it in D0

@@runcommand:
_runcommand:
a2545 1
	MOVE.L	D0,D4			; save paramlen
@


36.50
log
@Added LIBF_CHANGED, made end of romtab right
@
text
@d1317 1
a1317 2
	move.l	d0,d2				; save params
	move.l	d1,d3
d1319 1
a1319 1
	tst.l	d3				; entry?
@


36.49
log
@Added LIBF_SUMUSED
@
text
@d248 1
d474 1
a474 1
	DC.L	KEND			;(56) APTR  RT_ENDSKIP
d518 1
a518 1
	BSET.B	#LIBB_SUMUSED,LIB_FLAGS(a5)
@


36.48
log
@changes since the proto for getstring changed
@
text
@d517 1
a517 1

@


36.47
log
@Moved stack for initial size to 800 longs.  This is the same as
the stacksize used in Execute/Run/System.  was 500, then 1000.
@
text
@d2428 1
a2428 1
	MOVEQ	#STR_DISK_CORRUPT,d0
d2461 1
a2461 1
	MOVEQ	#STR_TASK_FAILED,d0
d2465 1
a2465 1
	MOVEQ	#STR_WAIT_DISK,d0
@


36.46
log
@Temp bump of initial stack size again
@
text
@d334 2
a335 3
CLISTK    EQU   1000		     Stack used for initial CLI (was 400!!FIX!!)
				     ; bumped for testing to avoid any possible
				     ; stack problems - REJ
d337 1
a337 1
				     ; FIX!!!!!!!!!!!!!
@


36.45
log
@Added freeVec and myproc - freeVec saves space, myproc replaces a
define, saves space.
@
text
@d334 1
a334 1
CLISTK    EQU   500		     Stack used for initial CLI (was 400!!FIX!!)
@


36.44
log
@Modified AddSegArray to make one allocation, so the fake seglist will
be freed on exit.
@
text
@d161 1
d172 1
d1677 1
d1702 9
d2128 6
@


36.43
log
@added divrem32, make allocentry test make more sense
@
text
@d112 4
a115 1
	INCLUDE "exec/funcdef.i"
d1313 7
a1319 4
	movem.l	d2/a2,-(sp)
	move.l	a0,a2				; new
	tst.l	d1				; entry?
	beq.s	got_seglist
d1322 2
a1323 2
	move.l	d1,d2				; save entrypoint
	moveq	#10,d0				; $00000000 JMP xxxx.L
d1325 1
a1325 1
	move.l	d0,a0
d1329 2
d1332 4
a1335 2
	move.w	#$4ef9,4(a0)			; JMP xxx.L
	move.l	d2,6(a0)			; address to call
d1339 2
a1340 10
	;-- d0 has seglist (BPTR) a2 - new process 
	;-- now allocate segarray - always 3 seglists + number (ala BCPL)

	move.l	d0,d2			; save seglist
	moveq	#5*4,d0			; 4 + 1 LWs
	bsr	@@AllocVecPubClear	; get mem
	move.l	d0,a0
	lsr.l	#2,d0			; bptr
	beq.s	adderr			; FIX! loses fake seglist!!!!

d1355 1
a1355 1
	;-- d0 is 2, which means success (!0)
d1357 1
a1357 1
	movem.l	(sp)+,d2/a2
@


36.42
log
@added manx asm comments, moved stack ptr saves
to keep manx working
@
text
@d139 2
d1117 9
d1128 1
a1128 1
	; save a0-a1 for BCPL
d1203 1
a1203 1
	BLE.S   AllPErr
@


36.41
log
@More comments
@
text
@d2532 17
d2569 5
a2590 5
* Save old stack boundaries on old stack
	move.l	TC_SPLOWER-pr_MsgPort(a3),-(sp)
	move.l	TC_SPUPPER-pr_MsgPort(a3),-(sp)
	move.l	a3,-(sp)		; so we can grab it later

d2617 1
a2621 1
	ADD.W	#16,SP		; Dump 4 regs pushed on for compatibility
@


36.40
log
@ubase added (forgot to check in before)
Changed the aborthandler - stuffs system stack ptr back to upper bound
chanegd requesters to look much nicer, give more info.
@
text
@d1061 1
d1066 2
a1067 2
	beq.s	open_dos
	move.l	pr_GlobVec(a6),a6
d2273 1
a2273 1
	LEA	LIBNAME(PC),A1	; make sure it uses NDOS.lib if not real
@


36.39
log
@save/restore tc_spxxxxx on RunCommand
@
text
@d135 1
d1048 1
a1048 1
	bsr.s   get_globvec
d1061 4
a1064 4
get_globvec:				; shared with divide
	move.l	SysBase,a0
	move.l	ThisTask(a0),a0
	cmp.b	#NT_TASK,LN_TYPE(a0)	; is this a process
d1066 2
a1067 2
	move.l	pr_GlobVec(a0),a0
util:	move.l	G_UTILITYBASE(a0),a6
d1071 1
d1073 3
a1075 2
	move.l	d0,a0			; dosbase
	move.l	dl_GV(a0),a0		; shared global vector
d1110 1
a1110 1
	bsr.s	get_globvec
d1118 1
a1118 1
	bsr.s	get_globvec
d2333 1
d2339 17
a2355 3
	MOVEM.L	D0-D7/A0-A6,-(SP)	; Save regs on super stack
	MOVE.L	60(SP),D7		; Code into arg
	ANDI.W	#(~$2000),SR		; Into user mode
a2356 1
	MOVE.L	$4,A6
d2362 1
a2362 1
	MOVE.L	D7,D1			; Move arg to D1
d2364 1
a2365 13
* We return and now call the default handler.
	LEA.L	AbortNext(PC),A5	; Where to go..
	JMP	_LVOSupervisor(A6)	; Into supervisor mode
AbortNext
	ADDQ.L	#6,SP			; Ignore the SR,PC saved by that
	BTST.B	#AFB_68010,AttnFlags+1(A6)	; Set on 68010 or greater
	BEQ.S	1$
	ADDQ.L	#2,SP			; Remove format word
1$:	MOVE.L	56(SP),A6		; Restore A6
	MOVE.L	A2,56(SP)		; Plant address
	MOVEM.L	(SP)+,D0-D7/A0-A5	; Restore other regs
	RTS				; Call Exec handler
*
d2376 7
d2391 2
a2392 1
	MOVEM.L	D1-D4/D7/A0/A1/A6,-(SP)	; save regs for below and BCPL
a2393 1
show_error:
d2395 1
a2395 1
	BNE.S	ABORT0				; No..
d2398 3
a2400 1
	BRA.S	ABORT1
d2402 11
a2412 3
ABORT0	MOVEQ	#STR_TASK_HELD,d0
ABORT1	JSR	@@getstring		; out of range for BSR
	MOVE.L	d0,d4			; eventually will go to d1
d2414 17
a2430 1
	MOVEQ	#STR_FINISH_DISK,d0
d2434 1
a2434 1
	MOVEQ	#STR_SELECT_CANCEL,d0
d2441 1
a2441 1
	BSR	    @@requester2
d2453 1
a2453 1
	MOVE.L	D1,D7		; Code passed. If top bit set then Alert
d2457 1
a2457 1
* setup of a5 unneeded in 1.4, but lets do it anyways (4 bytes)
d2463 1
a2463 1
ABORT2  MOVEM.L	(SP)+,D1-D4/D7/A0/A1/A6
d2465 4
@


36.38
log
@Fixed formatting (made source file smaller, more regular)
Added support for NPArguments (CNP() activate code).
Optimizations (share bcpl cleanup code)
@
text
@d2512 1
a2512 1
	MOVE.L	d0,a1
d2526 5
d2538 5
a2546 2
; FIX!!! Add stuff of tc_spxxx!!
	MOVE.L	A4,SP		; New stack ptr
d2554 1
a2554 1
; FIX!!! Restore tc_spxxx!!
d2557 3
a2559 1
	BSR	GETID		; Get my ID
@


36.37
log
@Comment changes
@
text
@d1 2
a2 2
          PLEN 55
          TTL    "*** TRIPOS Kernel for the CAPC ***"
d14 1
a14 1
          SPC 4
d28 1
a28 1
          SPC 4
d35 2
a36 2
          PAGE
          SPC 4
d56 1
a56 1
*                  MOVE.L    (SP)+,L                  6
d63 1
a63 1
*                  MOVE.L    -4(P),B                  8
d78 16
a93 16
	  PAGE
	  INCLUDE "exec/types.i"
	  INCLUDE "exec/nodes.i"
	  INCLUDE "exec/lists.i"
	  INCLUDE "exec/memory.i"
	  INCLUDE "exec/ports.i"
	  INCLUDE "exec/libraries.i"
	  INCLUDE "exec/devices.i"
	  INCLUDE "exec/io.i"
	  INCLUDE "exec/tasks.i"
	  INCLUDE "exec/resident.i"
	  INCLUDE "exec/execbase.i"
	  INCLUDE "exec/alerts.i"
	  INCLUDE "exec/ables.i"
	  INCLUDE "exec/errors.i"
	  INCLUDE "exec/initializers.i"
d95 2
a96 2
	  INCLUDE "libraries/expansion.i"
	  INCLUDE "libraries/expansionbase.i"
d98 1
a98 1
	  INCLUDE "intuition/preferences.i"
d100 3
a102 3
	  INCLUDE "dos/dos.i"
	  INCLUDE "dos/dosextens.i"
	  INCLUDE "dos/filehandler.i"
d104 3
a106 3
	  INCLUDE "libhdr.i"
	  INCLUDE "fault.i"
	  INCLUDE "calldos.i"
d108 1
a108 1
	  INCLUDE "dos_rev.i"
d110 1
a110 1
	  INT_ABLES
d112 2
a113 2
	  INCLUDE "exec/funcdef.i"
	  INCLUDE "exec/exec_lib.i"
d131 3
d148 1
d215 1
d310 2
a311 2
	  PAGE
          TTL "** TRIPOS Kernel  -   Equates **"
d323 1
a323 1
SEGSIZE   EQU	3 	             Size of SegVec for CreateProc
d326 1
a326 1
CLISTK    EQU   1000		     Stack used for initial CLI (was 400!!FIX!!)
d383 2
a384 2
          PAGE
          TTL      "** TRIPOS Kernel - Macro definitions"
d394 1
a394 1
        ENDM
d399 2
a400 2
        JSR          _LVO\1(A6)
        ENDM
d405 3
a407 3
        MOVE.L       SysBase,A6
        CALL         \1
        ENDM
d409 1
a409 1
        PAGE
d417 2
a418 2
KLIB_SEG  DC.L	     0		     no next section
KLIB      DC.L       (KEND-KLIB)/4   The size of the module for segment
d427 1
a427 1
          BRA.S      KINIT           Jump past segment list (keep lword aligned)
d440 12
a451 11
	  CNOP	0,4
_SEGLIST  DC.L       4<<2            ; Size of segment list*4: init will undo *4
	  DC.L	     KLIB_SEG        ; segment - CPTR! KLIB
	  DC.L	     FAKEBLIB_SEG    ; segment - CPTR! blib stubs
	  DC.L	     0		     ; MLIB_SEG	     segment - CPTR! mlib
	  DC.L	     FAKECLI_SEG     ; segment - CPTR! cli stubs
	  DC.L	     0		    ; CONHANDLER  syssegl[5]
	  DC.L	     0	            ; FILEHANDLER syssegl[6]
	  DC.L	     0		    ; restart     syssegl[7] (not used)
	  DC.L	     0		    ; cli c entrypoint syssegl[8]
	  DC.L	     0		    ; ram seglist syssegl[9]
d464 10
a473 10
		DC.W	RTC_MATCHWORD		;(50) UWORD RT_MATCHWORD
		DC.L	romtag			;(52) APTR  RT_MATCHTAG
		DC.L	KEND			;(56) APTR  RT_ENDSKIP
		DC.B	0; RTW_COLDSTART	;(5A) UBYTE RT_FLAGS
		DC.B	VERSION			;(5B) UBYTE RT_VERSION
		DC.B	NT_LIBRARY		;(5C) UBYTE RT_TYPE
		DC.B	-120			;(5D) BYTE  RT_PRI
		DC.L	LIBNAME			;(5E) APTR  RT_NAME
		DC.L	idtag			;(62) APTR  RT_IDSTRING
		DC.L	KINIT			;(66) APTR  RT_INIT
d476 2
a477 2
idtag:		VSTRING
		ds.w	0
d488 1
a488 1
	MOVE.L     SysBase,A6		; Library base register
d573 7
a579 7
	  MOVE.B     #NT_LIBRARY,LN_TYPE(A5)
	  LEA.L	     LIBNAME(PC),A1
	  MOVE.L     A1,LN_NAME(A5)
	  MOVEQ      #0,d0
	  MOVE.B     D0,LN_PRI(A5)
	  MOVE.W     #VERSION,LIB_VERSION(A5)
	  MOVE.W     #REVISION,LIB_REVISION(A5)
d581 1
a581 1
	  MOVE.L     A5,A1	
d583 1
a583 1
	  CALL	     AddLibrary		; add the library to the exec list
d592 5
a596 5
          LEA.L      _SEGLIST(PC),A3	     Segment list ptr
	  MOVEQ      #(INITSEGSIZE*4)+4,D0   # of bytes
	  BSR	     @@AllocVecPub	     Since Deact undoes this
	  TST.L	     D0
	  BEQ	     DISASTER
d598 4
a601 4
	  MOVE.L     D0,A0
	  MOVE.L     D0,D1	     	this is arg1 for lower down!
	  MOVEQ	     #INITSEGSIZE,D0	# of entries + size
	  BRA.S	     2$		     	make count correct
d603 4
a606 4
	  MOVE.L     (A3)+,D2	     	copy entries while converting to BPTRs!
	  LSR.L	     #2,D2
	  MOVE.L     D2,(A0)+
2$	  DBRA	     D0,1$
d610 1
a610 1
	  MOVE.L     D1,A3	     Save segarray ptr
d613 1
a613 1
* look for shell to replace CLI (fix)
d615 6
a620 6
	  LEA	     SHELLNAME(pc),a1
	  CALL	     FindResident
	  MOVE.L     D0,A1
	  TST.L	     D0
	  BEQ	     DISASTER		; very bad, no shell/cli
	  MOVE.L     RT_INIT(A1),a0	; table of entries, BCPL entry first
d622 3
a624 5
NEW_SHELL EQU 1
   IFD NEW_SHELL
	  MOVE.L     (a0),d0		; bcpl entrypoint (for createtask)
	  LSR.L	     #2,d0
	  MOVE.L     D0,4*4(a3)		; replace syssegl[4]
d626 3
a628 10
	  MOVE.L     4(a0),d0		; c entrypoint (for create(new)proc)
	  LSR.L	     #2,d0
	  MOVE.L     D0,8*4(a3)		; replace syssegl[8]
   ENDC
   IFND NEW_SHELL
	  move.l     a0,d0
	  lsr.l	     #2,d0
	  move.l     d0,4*4(a3)
	  move.l     d0,8*4(a3)
   ENDC
a629 1

d631 4
a634 4
	  LEA	     CONSOLENAME(PC),A1
	  MOVE.W     #dl_SIZEOF+2+ROOTSIZE+GVSIZE,d3
	  MOVEQ	     #5*4,d2		; offset in segarray - syssegl[5]
	  BSR	     FindResSeg
d637 4
a640 4
	  LEA	     RAMNAME(PC),A1
	  MOVE.W     #dl_SIZEOF+2+ROOTSIZE+GVSIZE+CONSEGSIZE+IOTV_SIZE,d3
	  MOVEQ	     #9*4,d2		; offset in segarray - syssegl[9]
	  BSR	     FindResSeg
d644 5
a648 5
	  LEA	     FILESYSNAME(PC),A1
	  CALL	     FindResident
	  MOVE.L     D0,A1
	  TST.L      D0
	  BEQ        DISASTER
d650 4
a653 4
	  ;-- fs has rt_init point to the actual seglist
	  MOVE.L     RT_INIT(A1),D0
	  LSR.L      #2,D0		; we want a BPTR
	  MOVE.L     D0,6*4(a3)		; syssegl[6] = fs
d656 1
a656 1
* FIX! should kill icache here!!!!!
d658 1
a658 1
	  
d663 12
a674 12
	  MOVE.L     A3,D1	     get segarray ptr back
          LSR.L      #2,D1           SegArray as BCPL ptr (arg1)
          MOVE.L     #CLISTK,D2      Stack size
          MOVEQ      #0,D3           Priority zero
          LEA.L      CLINAME(PC),A3  Name
          MOVE.L     A3,D0           master segarray as arg4 - in d0
          ASR.L      #2,D0           BCPL address
          MOVE.L     #GLOBSIZE,(A2)  Insert size of GV at (G)
	  MOVE.L     A2,D5	     Globvec(bptr)
	  ASR.L	     #2,D5
	  MOVE.L     D5,A0	     createtask wants 5th param in A0
          BSR        @@createtask     Causes most of the globvec to be built
d676 2
a677 2
          MOVE.L     D0,D7
          BEQ.S      DISASTER        Failed
d681 5
a685 5
	  LEA.L      EXPNAME(pc),A1
	  MOVEQ      #0,D0			 Any version
	  CALL	     OpenLibrary		 NOTE: not a process yet!!!!!
	  MOVE.L     D0,A2			 Pointer to expbase
	  LEA.L	     eb_MountList(A2),A0
d697 6
a702 6
	  MOVEM.L	D0/A0/A1,-(SP)
	  MOVE.L	LH_HEAD(A0),A0
	  TST.L		LN_SUCC(A0)		; list empty ?
	  BEQ.S		BootLink_Done
	  TST.L		bn_DeviceNode(A0)	; this bootnode has current devnode ?
	  BEQ.S		BootLink_Done
d705 3
a707 3
	  MOVE.L	LN_SUCC(A0),A1		
	  TST.L		LN_SUCC(A1)		; nothing more to link ?
	  BEQ.S		BootLink_Done
d709 1
a709 1
	  MOVE.L	bn_DeviceNode(A0),A0
d711 2
a712 2
	  TST.L		dn_Next(A0)		; current node already linked ?
	  BNE.S		BootLink_Done		; won't mess with circularities for now.
d714 6
a719 6
	  TST.L		bn_DeviceNode(A1)	; next bootnode has subsequent
						; devnode ?
	  BEQ.S		BootLink_Done
	  MOVE.L	bn_DeviceNode(A1),D0	; cptr to next node
	  LSR.L		#2,D0			; convert to bptr
	  MOVE.L	D0,dn_Next(A0) 		; link to next of current node
d721 2
a722 2
	  MOVE.L	A1,A0			; next becomes current node
	  BRA.S		Boot_Link
d725 1
a725 1
	  MOVEM.L	(SP)+,D0/A0/A1
d727 1
a727 1
	  CALL          RemHead			; (a0) - a6 still has execbase
d737 4
a740 4
  	  BSR        GETDATA         ; Get library ptr into L (A3)
          MOVE.L     D7,A0           ; Port
	  CLR.L      pr_WindowPtr-pr_MsgPort(A0) Zero window ptr (use workbench)
	  MOVE.L     dl_Root(A3),A1  ; Message area
d745 4
a748 4
	  TST.L		 D0
	  BEQ.S		 EndL
	  MOVE.L 	 D0,A3
	  MOVE.L	 bn_DeviceNode(A3),rn_FileHandlerSegment(A1)
d752 1
a752 1
          CALL           PutMsg		; A6 still has execbase
d757 2
a758 2
	  MOVE.L	 A2,A1		; expbase (a6 == execbase)
	  CALL		 CloseLibrary
d768 2
a769 2
          SUBA.L     A1,A1           Myself
          CALL       RemTask         Bye bye (a6 = execbase)
d773 3
a775 2
DISASTER  MOVE.L     #AT_DeadEnd!AN_DOSLib,D7
          CALLS      Alert
d784 4
a787 4
	  CALL	     FindResident
	  MOVE.L     D0,A1	     Save and test
	  TST.L	     D0
	  BEQ.S	     DISASTER	     very, very bad
d791 5
a795 5
	  LEA	     0(a5,d3.w),A0	address of built seglist
	  MOVE.L     A0,D0		save
	  CLR.L	     (A0)+		no next segment
	  MOVE.W     #$4ef9,(A0)+	JMP abs.l
	  MOVE.L     RT_INIT(A1),(A0)	Address to jump to
d798 3
a800 3
	  LSR.L	     #2,D0		BPTR to seglist
	  MOVE.L     D0,0(A3,d2.w)	syssegl[d2] = seglist
	  RTS
d804 1
a804 1
	  CNOP       0,4
d812 1
d814 1
a814 1
	  DC.B	     'con-handler',$0		; CSTR
d816 2
a817 1
	  DC.B	     'filesystem',$0		; CSTR
d819 1
d821 1
a821 1
	  CNOP	0,2
d823 2
a824 2
          PAGE
          TTL        "Library support"
d832 2
a833 2
        ADDQ.W  #1,LIB_OPENCNT(A6)      Increment use count
        MOVE.L  A6,D0                   And return A6
d837 3
a839 3
	SUBQ.W  #1,LIB_OPENCNT(A6)      Optimized REJ
J_NOP   MOVEQ	#0,D0			Return with zero (no segment)
        RTS
d853 3
a855 3
*        SUBA.L  A0,A0                   Zero A0
*	MOVE.L  SP,D5                   Get SP
*	SUBI.L  #DOSSTK,D5              Make BCPL stack ptr
d857 1
a857 1
*	MOVE.L  D5,A1                   And into BCPL stack ptr reg
d859 2
a860 2
*        ASL.L   #2,D0                   Make global number byte offset
*        MOVE.L  0(A2,D0.L),A4           Get entry point required
d863 1
a863 1
*        MOVE.L  D1,D0                   Result to D0
d980 6
a985 6
	  MOVE.L     D1,-(SP)
	  MOVE.L     SysBase,A0
	  MOVE.L     ThisTask(A0),A0
	  MOVE.L     (SP)+,pr_Result2(A0)	; TRICKY!!!!!
	  MOVEQ	     #0,D0
	  RTS
d990 4
a993 4
          BSR        GETID
          MOVE.L     D1,pr_Result2-pr_MsgPort(L)
ER_RET    CLR.L      D1             Set zero result
          JMP        (R)            Return
d995 2
a996 2
         PAGE
         TTL         "Subroutines at fixed offset from S register"
d1004 3
a1006 3
RET         MOVEM.L    -12(P),P/L                           [-0C]
            MOVE.L     -4(P),B                              [-06]
            JMP        (L)                                  [-02]
d1013 6
a1018 5
SAVE      MOVE.L     (SP)+,L           Standard save sequence [00]
          MOVEM.L    P/L/B,-12(P,D0.L)                        [02]
          ADDA.L     D0,P                                     [08]
          MOVEM.L    D1-D4,(P)                                [0A]
          JMP        (B)                                      [0E]
d1032 4
a1035 4
*            ADD.L   P,D0                New top of stack      [16]
*            MOVE.L  G_STACKBASE(G),D5       Current stackbase as BCPL address
*            LSL.L   #2,D5               MC address
*            CMP.L   C_SEND(Z,D5.L),D0   Compare stack limit with stack top
d1037 1
a1037 1
            RTS                         OK
d1076 1
a1076 1
            PAGE
d1120 2
a1121 2
            PAGE
            TTL     "*** Tripos Kernel - Primitive Routines ***"
d1140 1
a1140 1
          SECT       <'Createt'>
d1143 5
a1147 7
	  MOVEM.L    A0/A1,-(SP)
	  MOVE.L     D4,D0		Lattice can't pass args in D4 or D5
	  MOVE.L     16(A1),A0		get globvec off BCPL stack (BPTR)
	  BSR	     @@createtask
	  MOVE.L     D0,D1
	  MOVEM.L    (sp)+,A0/A1
	  JMP	     (R)
d1165 1
a1165 1
	movem.l	a0/a1,-(sp)
d1167 1
a1167 3
	move.l	d0,d1
	movem.l	(sp)+,a0/a1
	jmp	(R)
d1179 25
a1203 22
	  MOVEM.L    a2/a6,-(SP)
	  MOVE.L     SysBase,A6			; Get library pointer
	  MOVE.L     D0,-(SP)			; Size onto stack
	  MOVE.L     #MEMF_PUBLIC+MEMF_CLEAR,-(SP)	; Requirements
	  MOVE.W     #1,-(SP)			; Number of entries
	  LEA.L      -LN_SIZE(SP),SP		; Leave space for node
	  MOVE.L     SP,A0			; Arg into A0
	  CALL       AllocEntry			; Get Memory
	  TST.L      D0
	  BLE.S      AllPErr
	  MOVE.L     D0,A2			; A2 is mem block
	  MOVE.L     ME_ADDR+ML_ME(A2),A1	; A1 is task space
	  LEA        TC_MEMENTRY(A1),A0
	  NEWLIST    A0
	  EXG.L      A2,A1	
	  CALL       AddHead 
          MOVE.L     A2,D0			; Return memory
AllocPr2  LEA.L      LN_SIZE+10(SP),SP		; Adjust stack
	  MOVEM.L    (SP)+,a2/a6
	  RTS
AllPErr   MOVEQ      #0,D0			; Error
          BRA.S      AllocPr2
d1224 1
a1224 1
				        ; BCPL dos merely made it even
d1303 1
a1303 1
	bsr	@@AllocVecPub
d1308 1
a1308 1
	clr.l	(a0)				; no next segment
d1319 1
a1319 1
	bsr	@@AllocVecPub		; get mem
d1327 1
a1327 1
	moveq	#2,d0
d1331 1
a1331 1
	move.l	d0,(a0)+		; klib
d1334 1
a1334 1
	move.l	d0,(a0)+		; blib
d1336 1
a1336 1
	clr.l	(a0)			; null out cli entry
d1362 4
a1365 4
	  MOVE.L     SysBase,A6
          MOVE.L     ThisTask(A6),A4
          ADDA.L     #TC_SIZE,A4            B (A4) is now process ID
					    ; This means it is the MsgPort - REJ
d1369 3
a1371 3
          SUBA.L     Z,Z
          MOVE.L     TC_SPLOWER-pr_MsgPort(A4),P   Set up BCPL stack (A1)
          MOVE.L     pr_GlobVec-pr_MsgPort(A4),G   And global vector (A2)
d1375 8
a1382 7
          MOVE.L     P,A3                   L (A3) = starting address
	  MOVE.L     #$ABABABAB,D3          Stack pattern
          MOVE.L     SP,D2                  Top of stack
          SUBQ.L     #2,D2                  Less two bytes for safety
ACT10     MOVE.L     D3,(A3)+               Clear the BCPL stack
          CMPA.L     D2,A3		    ; Works for any size stack
          BLT.S      ACT10
d1384 5
a1388 5
          MOVE.L     #-1,C_CLLR(P)          -1 -> root coroutine
          MOVE.L     D2,C_SEND(P)           Stack end
          MOVE.L     P,D2                   Stack base
          ASR.L      #2,D2                  BCPL address
          MOVE.L     D2,G_STACKBASE(G)      Patch local GV
d1390 6
a1395 6
          MOVE.L     pr_SegList-pr_MsgPort(B),D7       D7 = BCPL ptr to SEGL
          MOVE.L     D7,D6
          ASL.L      #2,D6                  D6 = MC addr to SEGL
          ADD.L      0(Z,D6.L),D7
          ASL.L      #2,D7                  D7 = MC addr of last entry
	  LEA.L	     ACT11(PC),R	    Return addr for GLOBIN (A6)
d1397 3
a1399 3
ACT11     ADDQ.L     #4,D6                  D6 = MC addr of next entry
          CMP.L      D6,D7
          BLT.S      ACT12                  J if all entries processed
d1412 2
a1413 2
          MOVE.L     0(Z,D6.L),D1           D1 = BCPL ptr to segment
          BRA        GLOBIN                 GLOBIN(seg) rtn to ACT11
d1418 2
a1419 2
ACT12     LEA.L      SAVE,S                 Addr of save routine
          LEA.L      RET,R                  Addr of return routine
d1421 7
a1427 7
	  ; wait for packet, used to call global vec
	  ; packet MUST be LW aligned!
	  MOVEM.L    A0/A1,-(SP)	   ; save BCPL regs
	  BSR	     @@taskwait		   ; wait for packet
	  MOVEM.L    (SP)+,A0/A1	   ; restore BCPL regs
	  MOVE.L     D0,D1		   ; BCPL want it in D1
	  LSR.L	     #2,D1		   ; BPTR not CPTR!
d1429 4
a1432 4
	  ; we will use BCPL routine to actually start the BCPL task
          MOVE.L     G_START(G),B	   ; call BCPL start code
          MOVEQ      #32,D0                 Stack increment
          JSR        (S)                    Now call START(pkt)
d1439 1
d1441 1
a1441 12
	MOVE.L	ThisTask(A6),A2		; faster than findtask()

	;-- call pr_ExitCode from here, since lattice 5.04 doesn't handle
	;-- pointers to __asm functions.
	MOVE.L	pr_ExitCode(a2),a0
	MOVE.L	a0,d3
	BEQ.S	cleanup
	MOVE.L	pr_ExitData(a2),d1
	JSR	(a0)			; returns new code in d0

cleanup:
	MOVE.L	a2,a0			; returncode already in d0
d1445 1
a1445 1
	CALL	RemTask
d1447 1
a1447 1
	RTS				; impossible
d1449 27
a1475 3
	  PAGE
*************************************************A*****************
* 
d1481 1
a1481 1
          SECT       <'Deletet'>
d1485 1
a1485 1
          PAGE
d1496 15
a1510 15
          SECT       <'OpenDev'>
OPEND     ASL.L      #2,D2                  Move name to mc ptr
          ADDQ.L     #1,D2                  Avoid length field
          ASL.L      #2,D1                  Move IOB to mc ptr
          MOVE.L     D1,D5                  And save
          MOVEM.L    A0/A1/A6,-(SP)         Save regs
	  MOVE.L     SysBase,A6
          MOVE.L     ThisTask(A6),D6
          ADD.L      #TC_SIZE,D6            Now process id
          MOVE.L     D2,A0                  Name to A0
          MOVE.L     D5,A1                  IOB to A1
          MOVE.L     D3,D0                  Unit to D0
          MOVE.L     D4,D1                  Flags to D1
          MOVE.L     D6,MN_REPLYPORT(A1)    Reply port
          MOVE.W     #IO_SIZE-MN_SIZE,MN_LENGTH(A1)  Message length
d1512 1
a1512 1
          CALLS      OpenDevice
d1514 6
a1519 6
          MOVEM.L    (SP)+,A0/A1/A6         Restore regs
	  MOVEQ	     #-1,D1		    ; assume ok
          TST.L      D0
          BEQ.S      OPEND1		    ; OK
          MOVEQ      #0,D1		    ; error
OPEND1    JMP        (R)		    ; BCPL routine!
d1521 1
a1521 1
          PAGE
d1530 9
a1538 9
          SECT       <'SetIo  '>
SETIO     ASL.L      #2,D1                  Move IOB to mc ptr
          MOVE.L     D1,A3                  IOB to A3
          MOVE.W     D2,IO_COMMAND(A3)
          ASL.L      #2,D3                  Convert data ptr to mc
          MOVE.L     D3,IO_DATA(A3)
          MOVE.L     D4,IO_LENGTH(A3)
          MOVE.L     16(P),IO_OFFSET(A3)
          JMP        (R)		    ; BCPL routine!
d1540 1
a1540 1
	  PAGE
d1549 3
a1551 8
          SECT       <'DoIo '>
DOIO      MOVEM.L    A0/A1/A6,-(SP)         Save regs
	  ASL.L      #2,D1                  IOB to mc ptr
          MOVE.L     D1,A1                  IOB to A1
          CALLS      DoIO
	  MOVE.L     D0,D1		    return value (error)
          MOVEM.L    (SP)+,A0/A1/A6         Restore regs
          JMP        (R)
d1553 21
a1573 1
          PAGE
d1585 9
a1593 10
          SECT       <'SendIo '>
SEND_IO   MOVEM.L    A0/A1/A6,-(SP)         Save regs
	  ASL.L      #2,D1                  IOB to mc ptr
          MOVE.L     D1,A1                  IOB to A1
          ASL.L      #2,D2                  Pkt to mc ptr
          MOVE.L     D2,LN_NAME(A1)         pkt address saved in name
          MOVE.L     D1,0(Z,D2.L)           ID field has IOB ptr
          CALLS      SendIO
          MOVEM.L    (SP)+,A0/A1/A6         Restore regs
          JMP        (R)
d1595 1
a1595 1
          PAGE
d1604 2
a1605 6
CLOSED    ASL.L      #2,D1                  Move IOB to mc ptr
          MOVEM.L    A0/A1/A6,-(SP)         Save regs
          MOVE.L     D1,A1                  IOB to A1
          CALLS      CloseDevice
          MOVEM.L    (SP)+,A0/A1/A6         Restore regs
          JMP        (R)		    ; BCPL routine!
d1607 1
a1607 1
          PAGE
a1609 67
*                         GLOBIN(SEG)                            *
*                                                                *
* This function initialises the globals defined in the given     *
* segment. It returns -1, or 0 if an error is detected - an      *
* attempt to initialise a global beyond the upperbound given in  *
* GLOBSIZE. GLOBIN is defined in KLIB since it is called from    *
* the scheduler in ACTIV.                                        *
*                                                                *
* GLOBIN must return via register R since this is assumed in     *
* ACTIV.                                                         *
*                                                                *
* GLOBIN changes:  D0, D1, D2, D3, B and L (A3 and A4)           *
*                                                                *
* BCPL routine not called by C/asm language programmers		 *
******************************************************************

          SECT       <'globin '>
*
GLOBIN

* move.l	#$ff67ec,78*4(a2)	rdargs
* move.l	#$ff6b38,79*4(a2)	rditem
* move.l	#$ff6c98,80*4(a2)	findarg

	  MOVEQ.L    #-1,D0           Success flag initialized to TRUE
*
GLOBIN0   ASL.L      #2,D1
          BEQ.S      GLOBIN3          J if end of section list
          MOVE.L     D1,A4            B  = MC addr of the section
          MOVE.L     (A4)+,D1         D1 = BCPL ptr to next sect (or 0)
          MOVE.L     (A4),D2          D2 = the section length in words
          ASL.L      #2,D2            Now in bytes
          LEA.L      -4(A4,D2.L),A3   L(A3) = MC addr of MAXGLOB word
*
GLOBIN1   MOVE.L     -(A3),D2         D2 = entry relative ptr
          BEQ.S      GLOBIN0          J if end of Gn/Ln pairs
          MOVE.L     -(A3),D3         D3 = the global number (n say)

*
* FIX! kludge around cape 62 bug with dc.l -number/4!!!!!!!!!
*
* seems fixed in cape V64
*          ASL.L      #2,D3
*          ASR.L      #2,D3	      extend sign bit

          CMP.L      (G),D3
          BGT.S      GLOBIN2          Error if n too big
          ADD.L      A4,D2            D2 = MC addr of entry
          ASL.L      #2,D3            D3 = Gvec subscript in bytes
          MOVE.L     D2,0(G,D3.L)     Put entry address in global n
          BRA.S      GLOBIN1          Deal with next Gn/Ln pair
*
GLOBIN2   CLR.L      D0               Indicate error in flag
          MOVE.L     #111,D1	      ; FIX! what error is this?!
          BRA        BCPLERROR
*
GLOBIN3   BSR	     GETDATA	      ; get dosbase into A3
          MOVE.L     A3,G_DOSBASE(A2) ; put dosbase in all global vectors!
	  MOVE.L     dl_UtilityBase(A3),G_UTILITYBASE(A2)
				      ; All should have utility.library also!
	  MOVE.L     D0,D1            ; Return flag as result
          JMP        (R)	      ; BCPL routine!


          PAGE
******************************************************************
*                                                                *
d1632 1
a1632 1
          SECT       <'getvec '>
d1635 10
a1644 11
	  MOVEQ      #MEMF_PUBLIC,D2
GETM	  MOVEM.L    A0/A1/A6,-(SP)	; not the same as GETMEM!!!
	  MOVE.L     d1,d0
	  MOVE.L     d2,d1		; args in d0/d1!
	  ADDQ.L     #1,d0
	  ASL.L	     #2,d0		; add 1 longword and make into bytes
	  CALLS	     AllocVec		; allocate memory
	  MOVE.L     D0,D1		; BCPL return reg
	  LSR.L	     #2,D1		; return a BPTR!
	  MOVEM.L    (SP)+,A0/A1/A6
	  JMP	     (R)
d1648 2
a1649 2
	  move.l     #MEMF_PUBLIC+MEMF_CLEAR,d1
	  bra.s      alloc_common
d1653 1
a1653 1
	  moveq	     #MEMF_PUBLIC,d1
d1656 4
a1659 4
	  move.l     a6,-(sp)
	  CALLS	     AllocVec		; d0/d1
	  move.l     (sp)+,a6
	  rts
d1661 1
a1661 1
          PAGE
d1676 1
a1676 1
          SECT       <'freevec'>
d1678 3
a1680 7
FREEVEC
	  ASL.L	     #2,D1		; cptr
	  MOVEM.L    A0-A1/A6,-(SP)
	  MOVE.L     D1,A1
	  CALLS	     FreeVec		; a1
	  MOVEM.L    (SP)+,A0-A1/A6
	  JMP	     (R)
d1682 1
a1682 1
          PAGE
d1685 54
d1757 1
a1757 1
          SECT       <'qpkt   '>
d1762 2
a1763 2
	  LEA	     @@qpkt,A3		; a3 is scratch in BCPL
	  BRA.S	     pktcommon
d1766 1
a1766 1
	  LEA	     @@returnpkt,A3
d1769 4
a1772 6
	  MOVEM.L    A0/A1,-(SP)
	  ASL.L	     #2,D1		; convert packet BPTR->cptr
	  JSR	     (A3)
	  MOVE.L     d0,d1		; BCPL return reg
	  MOVEM.L    (SP)+,A0/A1	; restore BCPL regs
	  JMP	     (R)
d1783 6
a1788 6
	  MOVE.L     D1,A0
	  TST.L	     D1			make sure there is a packet
	  BNE.S	     10$		nope, not there
	  RTS
10$	  MOVEM.L    D2/D3,dp_Res1(a0)	stash return codes
	  ;--  fall through!
d1792 17
a1808 17
          MOVE.L     D1,A0               Pkt into address register - MC ptr
          MOVE.L     dp_Link(A0),D0      Extract message mc address
          BEQ.S      QPKT1               Invalid message ptr
          MOVE.L     D0,A1               msg pointer into A1 for putmsg
          MOVE.L     D1,LN_NAME(A1)      Ptr to pkt in message name field
	  MOVE.L     A6,-(SP)		 Save
	  MOVE.L     SysBase,A6
	  MOVEQ	     #pr_MsgPort,D0
          ADD.L      ThisTask(A6),D0	 addr of pr_MsgPort
          MOVE.L     dp_Port(A0),D1      Port ID into d1
          MOVE.L     D0,dp_Port(A0)      Replace my port ID in pkt
	  MOVE.L     D0,MN_REPLYPORT(A1) Set up so ReplyMsg() works
	  MOVE.L     D1,A0		 Move port into a0 for putmsg
          CALL       PutMsg		 a6 == execbase, a0 = port, a1 = msg
          MOVEQ      #1,D0               No error occurred
	  MOVE.L     (SP)+,A6
	  RTS
d1815 12
a1826 12
          MOVE.L     D1,A0               Pkt into address register - MC ptr
          MOVE.L     dp_Link(A0),D0      Extract message mc address
          BEQ.S      QPKT1               Invalid message ptr
          MOVE.L     D0,A1               msg pointer into A1 for putmsg
          MOVE.L     D1,LN_NAME(A1)      Ptr to pkt in message name field
          MOVE.L     dp_Port(A0),D1      Port ID into d1
          MOVE.L     A2,dp_Port(A0)      Replace my port ID in pkt
	  MOVE.L     A2,MN_REPLYPORT(A1) Set up so ReplyMsg() works
	  MOVE.L     D1,A0		 Move port into a0 for putmsg
          CALL       PutMsg		 a6 == execbase, a0 = port, a1 = msg
          MOVEQ      #1,D0               No error occurred
	  RTS
d1829 2
a1830 2
QPKT1     MOVEQ      #101,D1		; FIX! use equate!
          BRA        CERROR
d1832 1
a1832 1
          PAGE
d1850 1
a1850 1
          SECT       <'taskwai'>
d1853 2
a1854 2
	  MOVE.L     R,-(sp)		return addr
	  ; fall thru
d1856 7
a1862 6
          MOVEM.L    D7/a0/a1/A6,-(SP)	Save regs (incl BCPL regs)
	  MOVE.L     SysBase,A6
          MOVE.L     ThisTask(A6),A0
	  CMP.B	     #NT_PROCESS,LN_TYPE(a0)
	  BNE.S	     is_task		; if not process skip PktWait
          ADD.W      #TC_SIZE,A0	; get pr_MsgPort addr
d1864 5
a1868 5
          MOVE.L     pr_PktWait-pr_MsgPort(A0),D1
	  BEQ.S      TWait0             Zero so no special action
          MOVE.L     D1,A0		Address to call
          JSR        (A0)               Call it, returns msg in D0
          BRA.S      TWait3
d1870 4
a1873 2
is_task:  move.l     a1,a0		; for call from task, a1 = port!
TWait0    MOVE.L     A0,D7              Save port address
d1876 5
a1880 4
TWait1    MOVE.L     D7,A0              Retrieve port address
          CALL       GetMsg		a6 = execbase
          TST.L      D0 
          BEQ.S      TWait2             No message this time
d1882 7
a1888 6
TWait3    MOVE.L     D0,A0
	  MOVE.L     LN_NAME(A0),D0     Extract packet mc address
	  MOVE.L     D0,D1		For BCPL
	  ASR.L      #2,D1              Convert to BCPL address
          MOVEM.L    (SP)+,D7/a0/a1/A6        Restore regs
	  RTS
d1890 3
a1892 3
TWait2    MOVE.L     #SIGMASK,D0        Wait for signal
          CALL       Wait		a6 = execbase
          BRA.S      TWait1             Now go get message
d1894 1
a1894 1
          PAGE
d1905 1
a1905 1
          SECT       <'setflag'>
d1907 7
a1913 7
SETFLG    MOVEM.L    a0/A1/A6,-(SP)   Save regs
          MOVE.L     MP_SIGTASK(Z,D1.L),A1      Get Task Struct
	  MOVEQ	     #$0F,D0          Ensure only 4 set
          AND.L      D2,D0            Mask to D0
          MOVEQ      #12,D3           Shift required
          LSL.L      D3,D0            Shift flags up
          CALLS      Signal
d1915 1
a1915 2
          MOVEM.L    (SP)+,a0/A1/A6
          JMP        (R)
d1917 1
a1917 1
          PAGE
d1930 1
a1930 1
          SECT       <'testfla'>
d1932 13
a1944 13
TSTFLG    MOVEM.L    a0/A1/A6,-(SP)
          MOVEQ      #0,D0            Signals are to be cleared
          MOVEQ      #12,D2           Shift required
          MOVEQ      #$F,D3           Ensure only 4 signals used
          AND.L      D3,D1
	  MOVE.L     D1,D3            Save mask
          LSL.L      D2,D1            Move mask up
          CALLS      SetSignal        Clear specified flags, return setting
          MOVEQ      #0,D1            Anticipate answer FALSE
          LSR.L      D2,D0            Shift old signals down
          AND.L      D3,D0            Mask with request
          BEQ.S      TSTFLG1          None set
          MOVEQ      #-1,D1           Return TRUE if some set
d1946 1
a1946 1
          BRA.S      SETFLG1          Restore & return
d1948 1
a1948 1
          PAGE
d1960 1
a1960 1
          SECT       <'Exec   '>
d1962 12
a1973 12
EXEC      MOVEM.L    A0-A2/A6,-(SP)      Save regs
          MOVE.L     D1,D7               Save request code
          MOVE.L     D2,D0               Arg2 is D0
          MOVE.L     D3,D1               Arg3 is D1
          MOVE.L     D4,A0               Arg4 is A0
          MOVE.L     20(P),A2            Arg6 is A2
          MOVE.L     16(P),A1            Arg5 is A1
          MOVE.L     SysBase,A6          Library pointer
          JSR        0(A6,D7.W)          Call routine
          MOVEM.L    (SP)+,A0-A2/A6      Restore regs
          MOVE.L     D0,D1               Result in D1
          JMP        (R)                 And return
d1975 1
a1975 1
          PAGE
d1987 1
a1987 1
          SECT       <'Callres'>
d1989 9
a1997 11
CALLRES   MOVEM.L    A0/A1/A6,-(SP)      Save regs
          MOVE.L     D1,A6               Library pointer to A6
          MOVE.L     D2,D7               Save request code
          MOVE.L     D3,D0               Arg3 is D0
          MOVE.L     D4,D1               Arg4 is D1
          MOVE.L     16(P),A0            Arg5 is A0
          MOVE.L     20(P),A1            Arg6 is A1
          JSR        0(A6,D7.W)          Call it
          MOVEM.L    (SP)+,A0/A1/A6      Restore regs
          MOVE.L     D0,D1               Result in D1
          JMP        (R)                 And return
d1999 1
a1999 1
          PAGE
d2012 1
a2012 1
          SECT       <'Getlong'>
d2014 4
a2017 4
GETLONG   ASL.L      #2,D1               mc ptr
          ADD.L      D2,D1               add byte offset
          MOVE.L     0(Z,D1.L),D1        get lword
          JMP        (R)
d2019 1
a2019 1
          SECT       <'Putlong'>
d2021 4
a2024 4
PUTLONG   ASL.L      #2,D1               mc ptr
          ADD.L      D2,D1               add byte offset
          MOVE.L     D3,0(Z,D1.L)        put lword
          JMP        (R)                 And return
d2026 1
a2026 1
          PAGE
d2033 2
a2034 2
          MOVE.W     #pr_HomeDir-pr_MsgPort,D0
	  BRA.S	     selcommon
d2038 2
a2039 2
          MOVE.W     #pr_Arguments-pr_MsgPort,D0
	  BRA.S	     selcommon
d2043 2
a2044 2
	  MOVEQ      #pr_FileSystemTask-pr_MsgPort,D0
	  BRA.S	     selcommon
d2048 2
a2049 2
	  MOVEQ      #pr_ConsoleTask-pr_MsgPort,D0
	  BRA.S	     selcommon
d2051 1
a2051 1
SELIN     MOVE.L     R,-(SP)
d2054 2
a2055 2
	  MOVEQ      #pr_CIS-pr_MsgPort,D0
	  BRA.S	     selcommon
d2057 1
a2057 1
SELOUT    MOVE.L     R,-(SP)		; return addr
d2060 1
a2060 1
	  MOVEQ      #pr_COS-pr_MsgPort,D0
d2062 7
a2068 7
	  BSR.S      @@getid
	  MOVE.L     0(a0,d0.w),-(sp)	; get old value
	  MOVE.L     D1,0(a0,d0.w)	; set with new value
          MOVE.L     (sp)+,D0		; return old value
	  MOVE.L     D0,D1		; BCPL return in D1
	  SUB.L	     A0,A0		; BCPL needs A0 == 0
          RTS
d2084 3
a2086 3
	  BSR.S	     @@getid
	  MOVE.L     A0,D0
	  RTS
d2088 3
a2090 3
TASKID    BSR.S      GETID
          MOVE.L     A3,D1		; L
          JMP	     (R)
d2096 4
a2099 4
GETID	  MOVE.L     SysBase,A3
          MOVE.L     ThisTask(A3),A3
          ADD.W      #TC_SIZE,A3	; pointer to messageport
          RTS
d2104 4
a2107 4
@@getid	  MOVE.L     SysBase,A0
          MOVE.L     ThisTask(A0),A0
          ADD.W      #TC_SIZE,A0	; pointer to messageport
          RTS
d2115 2
a2116 2
          MOVE.W     #pr_HomeDir-pr_MsgPort,D0
	  BRA.S	     ProcCommon
d2123 2
a2124 2
          MOVE.W     #pr_Arguments-pr_MsgPort,D0
	  BRA.S	     ProcCommon
d2130 1
a2130 1
SEGL   	  MOVE.L     R,-(SP)		; return addr
d2132 2
a2133 2
          MOVE.W     #pr_SegList-pr_MsgPort,D0
	  BRA.S	     ProcCommon
d2139 1
a2139 1
CTASK     MOVE.L     R,-(SP)		; return addr
d2141 2
a2142 2
          MOVE.W     #pr_ConsoleTask-pr_MsgPort,D0
	  BRA.S	     ProcCommon
d2148 1
a2148 1
GETR2     MOVE.L     R,-(SP)		; return addr
d2150 2
a2151 2
          MOVE.W     #pr_Result2-pr_MsgPort,D0
	  BRA.S	     ProcCommon
d2157 1
a2157 1
INPUT     MOVE.L     R,-(SP)		; return addr
d2159 2
a2160 2
          MOVE.W     #pr_CIS-pr_MsgPort,D0
	  BRA.S	     ProcCommon
d2166 1
a2166 1
OUTPUT    MOVE.L     R,-(SP)		; return addr
d2168 2
a2169 2
          MOVE.W     #pr_COS-pr_MsgPort,D0
	  BRA.S	     ProcCommon
d2175 1
a2175 1
CLI       MOVE.L     R,-(SP)		; return addr
d2177 4
a2180 4
          MOVE.W     #pr_CLI-pr_MsgPort,D0
	  BSR.S	     ProcCommon		; returns in both D0/D1
	  LSL.L	     #2,D0		; so C/asm get CPTR, BCPL get BPTR!
	  RTS
d2186 1
a2186 1
FTASK     MOVE.L     R,-(SP)		; return addr
d2188 1
a2188 1
          MOVE.W     #pr_FileSystemTask-pr_MsgPort,D0
d2194 5
a2198 5
	  BSR.S	     @@getid		; returns msgport addr in a0
	  MOVE.L     0(A0,D0.W),D1	; get value out of process structure
	  MOVE.L     D1,D0		; for C/asm
	  SUB.L	     A0,A0		; restore Z reg for BCPL
          RTS
d2207 1
a2207 1
	  MOVE.L     D1,D0
d2209 6
a2214 6
	  MOVE.L     D2,-(SP)
	  MOVE.L     D0,D2
	  MOVEQ	     #-1,D1		; force set of result2
	  BSR.S      @@result2
	  MOVE.L     (SP)+,D2
	  RTS
d2216 1
a2216 1
RES2	  BSR.S	     @@result2		; destroys A0
d2222 7
a2228 6
	  SUB.L	     a0,a0
	  JMP	     (R)
	  
@@result2: BSR.S      @@getid             ; Get ID into a0
          LEA.L      pr_Result2-pr_MsgPort(a0),a0     Point to val
          BRA.S      UPDTE
d2236 2
a2237 2
CDIR	  BSR.S	     @@currentdir
	  BRA.S	     bcplcommon
d2240 2
a2241 2
	  BSR        @@getid
          LEA.L      pr_CurrentDir-pr_MsgPort(a0),a0
d2243 5
a2247 5
UPDTE     TST.L      D1                  Update?
          BNE.S      UPDTE1              No, return value
          MOVE.L     (a0),D1
          MOVE.L     D1,D0
          RTS
d2249 4
a2252 4
UPDTE1    MOVE.L     (a0),D1
          MOVE.L     D2,(a0)		; return old value!
	  MOVE.L     D1,D0		; for BCPL and C
          RTS
d2268 9
a2276 9
	  MOVEM.L    D0/D1/A0/A1/A6,-(SP)
	  LEA	     LIBNAME(PC),A1	; make sure it uses NDOS.lib if not real
	  MOVEQ      #0,D0		; Version
	  CALLS      OpenLibrary
	  MOVE.L     D0,A3		; L
	  MOVE.L     A3,A1
	  CALL	     CloseLibrary	; Keep use count correct
	  MOVEM.L    (SP)+,D0/D1/A0/A1/A6
	  RTS
d2283 5
a2287 5
	  MOVE.L     SysBase,A0
	  MOVE.L     ThisTask(A0),A0
	  MOVE.L     pr_GlobVec(A0),A0
	  MOVE.L     G_DOSBASE(A0),D0
	  RTS
d2294 5
a2298 5
	  MOVE.L     SysBase,A1
	  MOVE.L     ThisTask(A1),A1
	  MOVE.L     pr_GlobVec(A1),A1
	  MOVE.L     A0,G_INTUITION(A1) ; store it
	  RTS
d2303 9
a2311 9
	  MOVE.L     A6,-(A7)
	  MOVE.L     SysBase,A6
	  MOVE.L     ThisTask(A6),A6
	  MOVE.L     pr_GlobVec(A6),A6
	  MOVE.L     G_INTUITION(A6),A6		; GET IBASE IN a6
	  MOVEQ	     #1,D1			; notify
	  JSR	     _LVOSetPrefs(A6)
	  MOVE.L     (A7)+,A6
	  RTS
d2316 5
a2320 5
ROOTN	  BSR.S	     @@rootstruct
	  LSR.L	     #2,D0
	  MOVE.L     D0,D1
	  SUB.L	     A0,A0
	  JMP	     (R)
d2323 4
a2326 4
	  BSR.S	     @@dosbase
	  MOVE.L     D0,A0
	  MOVE.L     dl_Root(A0),D0   Pointer to rootnode
	  RTS
d2328 2
a2329 2
          PAGE
	  TTL        "Error Handler"
d2335 3
a2337 3
	  MOVEM.L    D0-D7/A0-A6,-(SP)	Save regs on super stack
	  MOVE.L     60(SP),D7          Code into arg
	  ANDI.W     #(~$2000),SR       Into user mode
d2339 4
a2342 4
	  MOVE.L     $4,A6
	  MOVE.L     TaskTrapCode(A6),A2
	  MOVE.L     ThisTask(A6),A0
	  MOVE.L     A2,TC_TRAPCODE(A0)
d2345 2
a2346 2
	  MOVE.L     D7,D1              Move arg to D1
	  BSR.S      @@abort             Call Abort
d2349 11
a2359 10
	  LEA.L      AbortNext(PC),A5   Where to go..
	  JMP        _LVOSupervisor(A6) Into supervisor mode
AbortNext ADDQ.L     #6,SP              Ignore the SR,PC saved by that
	  BTST.B     #AFB_68010,AttnFlags+1(A6)  Set on 68010 or greater
	  BEQ.S      1$
	  ADDQ.L     #2,SP		Remove format word
1$:	  MOVE.L     56(SP),A6          Restore A6
	  MOVE.L     A2,56(SP)          Plant address
	  MOVEM.L    (SP)+,D0-D7/A0-A5  Restore other regs
	  RTS                           Call Exec handler
a2373 2
          SECT       <'Abort  '>
*
d2375 1
a2375 1
	  MOVE.L     R,-(SP)
d2378 2
a2379 2
	  ;-- movem transfers a6 first, moving down.  leaves sp->d1
	  MOVEM.L    D1-D4/D7/A0/A1/A6,-(SP)	; save regs for below and BCPL
d2382 2
a2383 2
	  CMPI.L     #AN_KeyRange!AT_DeadEnd,D1	Disk error?
	  BNE.S      ABORT0             No..
d2385 2
a2386 2
	  MOVEQ	     #STR_DISK_CORRUPT,d0
	  BRA.S	     ABORT1
d2388 3
a2390 3
ABORT0	  MOVEQ	     #STR_TASK_HELD,d0
ABORT1	  JSR	     @@getstring		; out of range for BSR
	  MOVE.L     d0,d4		; eventually will go to d1
d2392 3
a2394 3
	  MOVEQ	     #STR_FINISH_DISK,d0
	  BSR	     @@getstring
	  MOVE.L     D0,D2
d2396 3
a2398 3
	  MOVEQ	     #STR_SELECT_CANCEL,d0
	  BSR	     @@getstring
	  MOVE.L     D0,D3
d2400 1
a2400 1
	  MOVE.L     D4,D1		; put it back
d2402 2
a2403 2
	  MOVE.L     #1<<14,D0	  ; NEWPREFS - really means use Suspend|Reboot
	  BSR        @@requester2
d2407 4
a2410 4
	  TST.L      D0
	  Beq.S      reboot
	  moveq	     #0,d0
	  CALLS	     Wait	; never returns
d2415 2
a2416 2
          MOVE.L     D1,D7        Code passed. If top bit set then Alert
	  BPL.S      ABORT2
d2421 3
a2423 3
	  MOVE.L     SysBase,a6
	  LEA        ThisTask(a6),a5	; pointer to task that errored
          CALL       Alert
d2425 2
a2426 2
ABORT2    MOVEM.L     (SP)+,D1-D4/D7/A0/A1/A6
	  RTS
d2428 2
a2429 9
* The messages we need
*
*LINE0	  DC.B       'Disk corrupt - task stopped',0
*LINE1	  DC.B       'Software error - task stopped',0
*LINE2	  DC.B       ' Finish ALL disk activity',0
*LINE3	  DC.B       'Select CANCEL to reboot',0

          PAGE
          SECT       <'RunComm'>
d2468 1
a2468 1
	ASL.L   #2,D3			; BPTR to CSTR -> CPTR to CSTR
d2477 1
a2477 1
	MOVE.L	D0,D4			save paramlen
d2489 1
a2489 1
	BSR	GETDATA			Get dosbase in a3
d2491 1
a2491 1
        BSR     GETID                   Get process ID (MsgPort) in L (A3)
d2502 6
a2507 6
	MOVE.L	D1,D7			save for later
	MOVE.L  D2,D0                   Stacksize in D2 (bytes)
	ADDQ.L	#4,D0			since we now use Exec AllocVec
        BSR     @@AllocVecPub            get memory
        TST.L   D0                      Check worked
        BEQ.S   RUNERRL                 Error
d2512 1
a2512 1
	MOVE.L  d0,a1
d2515 1
a2515 1
	MOVEM.L	a1/a2/a5/a6,-(sp)	Only for compatibility
d2519 3
a2521 3
        ADD.L   D2,D0                   D0 is now high stack address
        ADDQ.L  #4,D0                   Now top stack ptr (bytes) (extra LW)
        MOVE.L  D0,A4                   Into B (A4)
d2524 1
a2524 1
	MOVEM.L	d1-d4,(a1)		Store params for EVIL programs!!!!
d2526 3
a2528 3
        MOVE.L  pr_ReturnAddr-pr_MsgPort(A3),-(SP)    Save old return address
        MOVE.L  SP,-(A4)                Push my old stack ptr onto new stack
        MOVE.L  D2,-(A4)                Push stacksize onto new stack (bytes)
d2532 5
a2536 5
        MOVE.L  A4,pr_ReturnAddr-pr_MsgPort(A3)    Store new returnaddr stack
        ASL.L   #2,D7                   Segment as mc ptr
        MOVE.L  D7,A3                   Save seglist in A3
        MOVE.L  D3,A0                   CPTR to params into A0
        MOVE.L  D4,D0                   Args size
d2538 2
a2539 2
        MOVE.L  A4,SP                   New stack ptr
        JSR     4(A3)                   Hold tight - may whomp registers
d2544 2
a2545 2
RETADD  MOVEM.L (SP)+,D2/D3             Extract stack size and my stack
        MOVE.L  SP,D1                   Save old stack ptr
d2547 11
a2557 11
        MOVE.L  D3,SP                   New stack now
        MOVE.L  (SP)+,D7                Remember previous returnaddr
        BSR     GETID                   Get my ID
        MOVE.L  D7,pr_ReturnAddr-pr_MsgPort(A3)    Restore saved return address
	ADD.W	#16,SP			Dump 4 regs pushed on for compatibility
        MOVE.L  D0,-(SP)                Save return code - TRICKY!
        SUB.L   D2,D1                   D1 = Low stack + 1 LW
        SUBQ.L  #4,D1                   Now Stack Base
	MOVE.L	D1,A1			FreeVec is in exec
	CALLS	FreeVec			free stack (a6 is scratch here)
	MOVE.L	(SP)+,D0		return code
d2565 1
a2565 1
	MOVE.L  D0,D1			; for BCPL
d2570 1
a2570 1
RUNERRL MOVEQ   #-1,D0
d2573 1
a2573 1
        PAGE
d2585 3
a2587 3
NSTOP   BSR     @@getid                  Get my ID
        MOVE.L  pr_ReturnAddr-pr_MsgPort(A0),D0     New stack ptr
	SUBQ.L  #4,D0                   Point to return address
d2589 3
a2591 3
        MOVE.L  D1,D0                   Return code into D0
	SUB.L	A0,A0			restore the Z reg for BCPL
        RTS                             Return to saved address (usually DEACT)
d2593 1
a2593 1
        PAGE
d2595 1
a2596 2
*                       Globals to be initialised                    *
*                                                                    *
d2604 2
a2605 2
          CNOP       0,4                    Align
GLOBEND   DC.L       0                      End of the global list
d2681 1
a2681 1
        DC.L    G_GLOBMAX/4             Highest referenced global
@


36.36
log
@Handle getting dosbase from tasks
handle getting utilitybase from tasks
@
text
@d1070 1
a1070 1
	move.l	d0,a0
d2254 1
a2254 1
	move.l	a3,d0
d2256 1
a2256 1
	exg.l	a3,d0
@


36.35
log
@KLUDGE for broken intuition!
@
text
@d191 1
d1062 2
d1065 1
a1065 1
	move.l	G_UTILITYBASE(a0),a6
d1068 7
d2251 8
@


36.34
log
@Make AddSegArray use default for segl[1] and segl[2] from SEGLIST
This makes CreateProc/CreateTask from a Task work right
@
text
@d320 1
a320 1
CLISTK    EQU   500		     Stack used for initial CLI (was 400!!FIX!!)
@


36.33
log
@Added code to allow qpkt_task
@
text
@d131 1
d435 1
a435 1
SEGLIST   DC.L       4<<2            ; Size of segment list*4: init will undo *4
d447 1
a447 1
INITSEGSIZE	  EQU	     (SEGLISTEND-SEGLIST)/4	; for initialization
d585 1
a585 1
          LEA.L      SEGLIST(PC),A3	     Segment list ptr
d1278 1
a1278 1
* fake seglist if needed.
a1280 1
* a1 - old process
d1285 1
a1285 1
	movem.l	d2/a2-a3,-(sp)
a1286 1
	move.l	a1,a3				; old
d1304 1
a1304 1
	;-- d0 has seglist (BPTR) a2 - new process a3 - old process
d1315 1
a1315 3
	move.l	pr_SegList(a3),d0	; old segarray
	lsl.l	#2,d0
	move.l	d0,a1			; now cptr
a1316 1
	addq.w	#4,a1
d1319 6
a1324 2
	move.l	(a1)+,(a0)+		; klib
	move.l	(a1)+,(a0)+		; blib
d1330 1
a1330 1
	movem.l	(sp)+,d2/a2-a3
@


36.32
log
@Upped initial cli stack to 500 longwords from 400 to fix stack overrun
in SetPrefs().
@
text
@d154 2
d1776 1
a1776 1
_qpkt:	  MOVE.L     A6,-(SP)		 Save
d1782 1
d1795 18
d1829 3
d1844 2
d1853 2
@


36.31
log
@chnage to args for setprefs
@
text
@d317 1
a317 1
CLISTK    EQU   400		     Stack used for initial CLI (was 400!!FIX!!)
d320 1
@


36.30
log
@Turn on data cache like I said I would
@
text
@d2245 1
a2245 1
* Call setprefs for me (gets ibase from globvec)
a2252 2
	  MOVEQ      #232/2,D0			; everything
	  ASL.W	     #1,D0			; moveq has a smaller range
@


36.29
log
@Better DBUG macro, get execbase at entrypoint, better math rtns, PubClear, etc.
@
text
@d503 1
a503 1
*USE_CACHE_CALLS	EQU	1
@


36.28
log
@removed temp hack to runcommand (now really bytes of stack)
@
text
@d116 1
d130 1
d132 6
a137 2
*	XDEF	@@divide
*	XDEF	@@rem
d148 2
d242 32
a273 2
	movem.l	d0/d1/a0/a1,n2\@@
	pea	n1\@@
d275 4
a278 2
	addq.w	#4,a7
	bra.s	n3\@@
d281 1
a281 3
n2\@@	ds.l	4
n3\@@
	movem.l	n2\@@,d0/d1/a0/a1
d405 1
d450 1
d460 1
a460 1
		DC.L	RESNAME			;(5E) APTR  RT_NAME
d475 1
a475 1
* sysbase in a6 is guaranteed by exec InitResident
d477 1
a477 1
*	  MOVE.L     SysBase,A6      Library base register
d503 2
d563 1
a563 1
	  LEA.L	     RESNAME,A1
d581 2
a582 2
          LEA.L      SEGLIST(PC),A3  Segment list ptr
	  MOVEQ      #(INITSEGSIZE*4)+4,D1     # of bytes
d588 3
a590 3
	  MOVE.L     D0,D1	     this is arg1 for lower down!
	  MOVEQ	     #INITSEGSIZE,D0     # of entries + size
	  BRA.S	     2$		     make count correct
d592 1
a592 1
	  MOVE.L     (A3)+,D2	     copy entries while converting to BPTRs!
a627 2
* also must be changed in cli_init.c!
NEW_CONSOLE	EQU	1
d629 1
a629 1
     IFD NEW_CONSOLE
a633 1
     ENDC
a642 5

NEW_FS	EQU	1

     IFD NEW_FS

a653 2
     ENDC

d676 1
a676 1
          BEQ.s      DISASTER        Failed
a679 1
     IFND NOT_REAL
a768 6
    ENDC

    IFD NOT_REAL
	  MOVEM.L    (sp)+,d2-d7/a2-a6
	  RTS
    ENDC
d794 1
d805 1
a805 4
RESNAME
    IFD  NOT_REAL
	  DC.B       'ndos.library',$00		; CSTR
    ENDC
d831 2
a832 1
J_CLOSE SUBQ.W  #1,LIB_OPENCNT(A6)      Optimized REJ
d1019 1
a1019 1
DIVX      BRA.S     DIV01                                     [14]
d1041 1
a1041 3
	move.l	SysBase,a0
	move.l	ThisTask(a0),a0
	move.l	pr_GlobVec(a0),a2
d1045 1
a1048 1
	move.l	G_UTILITYBASE(a2),a6
d1054 7
d1065 1
a1065 1
*           Corrupts all data registers                                        *
a1067 26
* FIX! I think we can just use SDivMod32!!!!
DIV32
            TST.L   D2                  Denominator < 0 ?
            BPL.S   DIV01
            NEG.L   D2
            BSR.S   DIV01
            NEG.L   D1
            RTS

DIV01       TST.L   D1                  Numerator < 0 ?
            BPL.S   DIV02
            NEG.L   D1
            BSR.S   DIV02               Divide abs(d1) by d2
            NEG.L   D1
            NEG.L   D2                  Correct for sign
            RTS

* DIV02 performs division on unsigned numbers. It first sees if the
* denominator is small enough for straight-line code using DIVU to
* be applicable

* set D1, D2 := D1/D2, D1 Rem D2.

* D1 and D2 are treated as unsigned numbers, and 0<=D1<=#X80000000
* and 0<D2<=#X80000000.

d1075 3
a1077 2
DIV02
	movem.l	a0/a1/a6,-(sp)
d1079 4
d1084 1
a1084 2
	move.l	G_UTILITYBASE(a2),a6
	JSR	_LVOUDivMod32(a6)
a1086 1
	movem.l	(sp)+,a0/a1/a6
d1088 16
d1197 1
d1215 1
a1215 1
	BSR.S	AllocProc
d1290 1
a1290 1
	moveq	#10,d1				; $00000000 JMP xxxx.L
d1299 2
a1300 1
	
d1306 1
a1306 2
	moveq	#5,d1			; 4 + 1 LWs
	asl.l	#2,d1			; bytes
d1613 3
a1615 2
          ASL.L      #2,D3
          ASR.L      #2,D3	      extend sign bit
a1625 3
* FIX!
* bsr.s showdebug

d1635 1
a1635 9
*FIX!
*showdebug:
* move.l a3,-(a7)
* move.l D2,-(a7)
* move.l d3,-(a7)
* move.l (G),-(a7)
* DBUG <"Bad Globin!!! max=%ld, value=%ld, offset=%ld, addr=%ld\n">
* lea	16(a7),a7
* rts
d1676 5
d1683 3
a1686 2
	  move.l     d1,d0		; in bytes
	  moveq	     #MEMF_PUBLIC,d1
d1813 2
a1814 7
	  MOVEM.L    A0/A1,-(SP)
	  BSR.S	     @@taskwait
	  MOVE.L     D0,D1
	  ASR.L      #2,D1              Convert to BCPL address
	  MOVEM.L    (SP)+,A0/A1
	  JMP	     (R)

d1816 1
a1816 1
          MOVEM.L    D7/A6,-(SP)     Save regs
d1836 3
a1838 1
          MOVEM.L    (SP)+,D7/A6        Restore regs
d1858 1
a1858 1
SETFLG    MOVEM.L    A1/A6,-(SP)   Save regs
d1860 2
a1861 2
          MOVE.L     D2,D0            Mask to D0
          ANDI.L     #$F,D0           Ensure only 4 set
d1865 2
a1866 2
SETFLG1   SUBA.L     Z,Z
          MOVEM.L    (SP)+,A1/A6
d1884 1
a1884 1
TSTFLG    MOVEM.L    A1/A6,-(SP)
d1887 3
a1889 2
          ANDI.L     #$F,D1           Ensure only 4 signals used
          MOVE.L     D1,D3            Save mask
a1980 1
          PAGE
d2212 3
a2214 2
GETDATA   MOVEM.L    D0/D1/A0/A1/A6,-(SP)
	  LEA	     RESNAME,A1		; make sure it uses NDOS.lib if not real
d2337 1
a2337 1
ABORT1	  BSR	     @@getstring
d2458 2
a2459 2
	MOVE.L  D2,D1                   Stacksize in D2 (bytes)
	ADDQ.L	#4,D1			since we now use Exec AllocVec
@


36.27
log
@LVO_ -> _LVO
Added Suspend code
@
text
@d2405 1
a2405 1
*FIX!	ASL.L	#2,D2			; stacksize to bytes
a2414 1
 ASL.L #2,D2  ; FIX!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
@


36.26
log
@Changed to Bytes for RunCommand, temporarily disabled until I can coordinate with andy
@
text
@a110 1
	  TASK_ABLES
d112 1
a112 8
FUNCDEF     MACRO   * function
LVO_\1	    EQU	    FUNC_CNT
FUNC_CNT    SET     FUNC_CNT-6
            ENDM

FUNC_CNT    SET     LIB_NONSTD


d351 1
a351 1
        JSR          LVO_\1(A6)
d378 1
a378 1
          BRA        KINIT           Jump past segment list (keep lword aligned)
d644 1
a644 1
          BEQ        DISASTER        Failed
d747 1
a747 1
DISASTER  MOVE.L     #AN_DOSLib,D7
a748 1
          BRA.S      DISASTER
d2280 1
a2280 1
	  JMP        LVO_Supervisor(A6) Into supervisor mode
d2333 1
a2333 1
	  MOVEQ	     #0,D0		;no IDCMP retrys
d2336 1
a2336 2
* If the user presses Retry, we give the message again
* TRICKY!!!!!
a2337 1
	  MOVE.L     (a7),d1		; retrieve error code
d2339 3
a2341 1
	  BNE.S      show_error		; show error again
d2345 1
a2345 1

@


36.25
log
@for rcs 4.x header change
@
text
@d2381 1
a2381 1
* C:		    BPTR   LONGS      CPTR      LONG
d2414 1
d2424 1
d2451 1
a2451 2
	MOVE.L  D2,D1                   Stacksize in D2 (longwords)
	ASL.L	#2,D1			bytes
a2466 1
	ASL.L	#2,D2			stacksize in bytes
d2476 1
a2476 1
        MOVE.L  D2,-(A4)                Push stacksize onto new stack
@


36.24
log
@Support for C-ram handler
@
text
@@


36.23
log
@New shell support (C entry)
One missed getvec->allocvec mod
@
text
@d409 1
d455 2
a456 1
BASESIZE	EQU	dl_SIZEOF+2+ROOTSIZE+GVSIZE+CONSEGSIZE+IOTV_SIZE
d603 6
d801 1
@


36.22
log
@getvec->AllocVec, etc
@
text
@d408 1
a408 1
	  DC.L	     0
d573 5
a577 1
	  MOVE.L     RT_INIT(A1),d0
d581 11
d1300 1
d1414 1
a1414 2
	MOVE.L	d0,d2			; save return code(?)
	MOVE.L	a2,a0
d1416 1
a1416 1

d1418 1
a1418 1
	CALL	RemTask			; FIX! return code?
a2210 7
    IFD  NOT_REAL
	  MOVE.L     A3,D1
	  BSR.S	     GETDATA
	  MOVE.L     A3,D0
	  MOVE.L     D1,A3
    ENDC
    IFND NOT_REAL
a2214 1
    ENDC
d2436 1
a2436 1
* NOTE that getvec allocs 2 LWs more than asked - 1 for len, 1 extra!
d2442 1
a2453 2
	MOVE.L	d7,d1
	MOVEM.L	d1-d4,(a1)		Store params for EVIL programs!!!!
d2462 2
@


36.21
log
@Fix null termination of task names
@
text
@a147 4
	XDEF	@@getvec
	XDEF	_getvec
	XDEF	@@getmem
	XDEF	_getmem
a149 4
	XDEF	@@AllocVecType
	XDEF	_AllocVecType
	XDEF	@@freevec
	XDEF	_freevec
d547 1
a547 1
	  BSR	     @@getvec	     Since Deact undoes this
d1267 3
a1269 2
	moveq	#4,d1			; 4 + 1 LWs
	bsr	@@getvec			; get mem
d1637 6
a1642 2
GETM	  MOVEM.L    A0/A1,-(SP)        ; not the same as GETMEM!!!
	  BSR.S      @@getmem
d1645 1
a1645 1
	  MOVEM.L    (SP)+,A0/A1
d1650 6
a1655 17
	  SUBQ.L     #1,d1	      ; this rounds up to longword,
	  LSR.L	     #2,d1	      ; then subtracts 1 longword
@@getvec:
_getvec:
	  MOVE.L     D2,-(A7)		; don't tromp d2
          MOVEQ      #MEMF_PUBLIC,D2	; always use public mem for now
	  BSR.S	     @@getmem
	  MOVE.L     (a7)+,D2
	  RTS
*
* Dos.library version - takes bytes, no extra padding at end!
*
@@AllocVecType:
_AllocVecType:
	  SUBQ.L     #1,d1	      ; this rounds up to longword,
	  LSR.L      #2,d1	      ; then subtracts 1 longword
	  ; fall through
a1656 24
	  ; getmem/getvec add 1 longword for size, plus one extra!!!
@@getmem:
_getmem:
				      ; note: not the same as GETMEM!!!
          ASL.L      #2,D1            Block size in Bytes
          BLT.S      GVC1             Error if negative or 0
	  ADDQ.L     #8,D1            True vector size + 1 overhead!!!!!!
*
          MOVE.L     D1,D0            Size into D0
          MOVE.L     D2,D1            Type required
	  MOVEM.L    D0/A6,-(SP)      save size and a6
          CALLS      AllocMem
          MOVE.L     D0,A0
	  MOVEM.L    (SP)+,D1/A6      not same regs!!!!!
	  MOVE.L     A0,D0
          BEQ.S      GVC1             Error - no store
          MOVE.L     D1,(A0)+         Store size in bytes
          MOVE.L     A0,D0            .. and avoid size
	  RTS

* Also used for GETMEM failure above - REJ
GVC1	  MOVE.L     #103,D1	     ; ERROR_NO_FREE_STORE
	  BRA	     CERROR

d1675 6
a1680 16
	  ASL.L	     #2,D1
	  MOVE.L     R,-(SP)	      Return address
	  ; fall thru
@@freevec:
_freevec:
          MOVEM.L    A0-A1/A6,-(SP)   Save a0/a1 for BCPL
          TST.L      D1
          BEQ.S      FVC1             Return if V = 0
          MOVE.L     D1,A1
          MOVE.L     -(A1),D0         D0 = size, A1 = vec
          MOVE.L     D0,D1            Take copy
          ANDI.L     #$FF000003,D1    Top byte and bottom 2 bits.. (FIX!?)
          BNE.S      FVC2             .. must be clear to be valid length
          CALLS      FreeMem
FVC1      MOVEM.L    (SP)+,A0-A1/A6
          RTS
a1681 4
FVC2      MOVE.L      #AN_FreeVec!AT_DeadEnd,D1	 ; Abort "Illegal Freevec"
	  BRA	      @@abort
	  ; dead end - should be no return!!!

d2434 2
a2435 1
        BSR     @@getvec                 Call GETVEC
d2486 2
a2487 1
	BSR	@@freevec		free stack
@


36.20
log
@Dropped stack back to 1600 bytes for the initial cli
@
text
@d1168 1
a1168 1
	MOVEM.L	D2-D4/A2-A3,-(SP)
d1175 1
d1196 1
a1196 2
	SUBQ.L	#1,d3			; adjust for null
	BRA.S	2$
d1198 1
a1198 1
2$	DBRA	d3,1$			; may not be null-terminated
d1239 1
a1239 1
	MOVEM.L	(SP)+,D2-D4/A2-A3
@


36.19
log
@Guru on no shell available.
@
text
@d295 1
a295 1
CLISTK    EQU   1600		     Stack used for initial CLI (was 400!!FIX!!)
@


36.18
log
@SetPgromDir/SetArgStr added .
@
text
@d580 1
a580 1
	  BEQ.S	     no_shell		; should pull alert?
a583 1
no_shell:
@


36.17
log
@Close expansion library
@
text
@d168 2
d2006 10
@


36.16
log
@AllocVec->AllocVecPub
@
text
@d644 2
a645 2
	  MOVE.L     D0,A0			 Pointer
	  LEA.L	     eb_MountList(A0),A0
d656 1
d687 1
a687 1
	  CALL          RemHead			; a6 still has execbase
d689 1
a689 1
* D1 contains the message port for that task which is waiting for a message
d714 6
a720 1

@


36.15
log
@removed refs to 1.3 roms, put dos.library back at pri 0
@
text
@d152 2
a153 2
	XDEF	@@AllocVec
	XDEF	_AllocVec
d1254 1
a1254 1
	bsr	@@AllocVec
d1644 2
a1645 2
@@AllocVec:
_AllocVec:
@


36.14
log
@Upped initial CLI stack for andy
@
text
@d411 3
a413 8

* FIX!!!!! 1.3 rom addresses
	  DC.L	     $FF9C1C	    ; CONHANDLER  syssegl[5] FIX!!!!!!!
	  DC.L	     $FFA788        ; FILEHANDLER syssegl[6] FIX!!!!!!!
	  DC.L	     $FFF1B0	    ; restart     syssegl[7] FIX!!! (not needed)
*	  DC.L	     0		    ; CONHANDLER  syssegl[5]
*	  DC.L	     0	            ; FILEHANDLER syssegl[6]
*	  DC.L	     0		    ; restart     syssegl[7] (not used)
a442 2

* FIX!
d535 1
a535 1
	  MOVEQ      #10,d0			; fix! we may not need this!
@


36.13
log
@Added support for finding shell from rom
@
text
@d293 1
a293 1
CLISTK    EQU   400		     Stack used for initial CLI (was 400!!FIX!!)
@


36.12
log
@*** empty log message ***
@
text
@d100 3
a102 3
	  INCLUDE "libraries/dos.i"
	  INCLUDE "libraries/dosextens.i"
	  INCLUDE "libraries/filehandler.i"
d578 13
d616 2
a617 2
	  LSR.L      #2,D0		we want a BPTR
	  MOVE.L     D0,6*4(a3)		syssegl[6] = fs
d785 1
@


36.11
log
@ifdefed out cache control call at boot.
@
text
@d2495 1
d2504 1
@


36.10
log
@Fixed multiply, added ArgStr
@
text
@d480 11
d834 2
a835 2
	; handle arguement conversion
	; arguements are at (p) and args 1-4 are in regs D1-D4 as well
@


36.9
log
@Added GetProgramDir, SetFileSysTask, SetConsoleTask
Changed bit used for CALLDOS
@
text
@d167 1
d984 5
d990 2
a991 1
	movem.l	a0/a1/a6,-(sp)
d997 1
a997 1
	movem.l	(sp)+,a0/a1/a6
d2058 8
d2179 1
a2179 1
	  BSR.S      @@getid
@


36.8
log
@Removed immense amounts of code
using utility.libary for mul/div
moved strings to fault
redid DEACT code - now mostly in c
fixes to RunCommand
@
text
@d106 1
d166 1
d169 2
d176 2
d903 2
a904 1
	BPL.S	not_bptr
d1974 10
d2042 8
@


36.7
log
@Made some more things visible (aren't really needed)
@
text
@d105 1
d122 3
a124 1
	  XREF	_LVOSetPrefs
d137 10
a146 6
	XDEF	@@divide
	XDEF	@@rem
	XDEF	@@createtask
	XDEF	_createtask
	XDEF	@@createproc
	XDEF	_createproc
d207 8
d478 8
d488 2
d748 1
d976 9
a984 15
MULT32      MOVEM.L D2-D4,-(SP)         Save registers used
            MOVE.W  D1,D3               Low word into D3
            MOVE.W  D2,D4               Low word into D4
            SWAP    D1                  High word into D1
            SWAP    D2                  High word into D2
            MULU    D3,D2               D2H * D1L
            MULU    D4,D1               D1H * D2L
            MULU    D4,D3               D1L * D2L
            ADD.W   D2,D1               D2H*D1L + D1H*D2L
            SWAP    D1                  Get into high word
            CLR.W   D1                  Clear bottom word
            ADD.L   D3,D1               (D2H*D1L + D1H*D2L) << 16  +  D1L*D2L
	    MOVE.L  D1,D0		For dos.library callers
            MOVEM.L (SP)+,D2-D4         Restore registers
            RTS
d993 1
a993 11
@@divide
	    MOVEM.L D2-D7,-(SP)
	    BSR.S   DIV32
	    MOVE.L  D1,D0	; result
	    MOVE.L  D2,D1	; give them rem too.
	    MOVEM.L (SP)+,D2-D7
	    RTS
@@rem
	    BSR.S   @@divide
	    EXG     D0,D1
	    RTS
d1015 1
d1018 1
a1024 67
DIV02       CMPI.L  #$0000FFFF,D2
            BHI.S   DIV04               Denominator is larger than 16 bits
* DIV03 is used as a subroutine called from the general case code.
* It returns with D1,D2 := D1/D2, D1 rem D2, and D3 and D6 corrupted
DIV03       MOVE.L  D1,D6
            CLR.W   D1
            SWAP    D1                  High part of numerator
            DIVU    D2,D1
            MOVE.L  D1,D3               Save partial result away
            MOVE.W  D6,D1
            DIVU    D2,D1               Other part of the division
            SWAP    D1
            CLR.L   D2
            MOVE.W  D1,D2
            MOVE.W  D3,D1
            SWAP    D1
            RTS
* DIV04 is reached if the denominator does not fit in 16 bits. It takes
* a quick exit if the numerator is less than the denominator
DIV04       CMP.L   D1,D2
            BLS.S   DIV05               Branch in general case
            MOVE.L  D1,D2
            MOVEQ.L #0,D1               Result IS zero
            RTS
* At DIV05, since the denominator is >= 2^16 and the numerator is
* < 2^32, the quotient will be < 2^16. An approximation to the
* required quotient is produced by dividing both numerator & denominator
* by a scale factor computed as 1+(D2/#X10000), and then doing a
* short division by the (now) 16-bit denominator. The scale factor fits in
* 16 bits even after the '+1' because the original D2 had #X80000000 as its
* largest possible value, so the largest scale factor is #X00008001.
DIV05       MOVE.L  D2,D7
            CLR.W   D7
            SWAP    D7                  Top half of D2 = D2/#X10000
            ADDQ.L  #1,D7               Increment it to get safe scale factor
            MOVE.L  D1,D4
            MOVE.L  D2,D5               Grab a safe copy of the input
            MOVE.L  D7,D2
            BSR.S   DIV03               D1 := D1 / Scalefactor
            MOVE.L  D5,D2
            DIVU    D7,D2               now D2 (word) = scaled denominator
* the choice of scalefactor here was intended to ensure that the
* scaled denominator now in D2 was less than 16 bits long, and entry
* conditions imply that the quotient I compute will be small enough that
* a single DIVU order can be used to get it
            DIVU    D2,D1
* D1 (word) now holds an estimate for the quotient that I want.
* Check it, and produce a remainder, by multiplying by original
* denominator & comparing with original numerator.
            ANDI.L  #$0000FFFF,D1       Get rid of top half, since not wanted
DIV06       MOVE.L  D5,D2
            MOVE.L  D5,D3
            SWAP    D3
            MULU    D1,D2
            MULU    D1,D3
            SWAP    D3                  Top half of D3 should have been zero
            ADD.L   D3,D2               and this ADD can not cause a carry
            SUB.L   D4,D2
            BHI.S   DIV08               overshot, since remainder seems negative
            NEG.L   D2
            CMP.L   D2,D5
            BHI.S   DIV07               OK, remainder is in range
            ADDQ.L  #1,D1               Crank up the quotient
            BRA.S   DIV06
DIV07       RTS
DIV08       SUBQ.L  #1,D1
            BRA.S   DIV06               Adjust quotient & try again
d1026 11
d1063 1
a1063 1
	  BSR.S      @@createtask
d1068 14
a1081 23
@@createtask:
_createtask:
          MOVEM.L    D2-D5/A2-A6,-(SP)
	  MOVE.L     A0,D5		    Lattice can't pass in D4/D5
	  ASL.L	     #2,D5		    Globvec to CPTR
          ASL.L      #2,D0                  Name ptr to mc
          MOVE.L     D0,A3                  Into address reg
          MOVE.L     SysBase,A6             Get library pointer

* Get space for Task struct and process base
          MOVE.L     #pr_SIZEOF,D0
* Add space needed for stack
          ASL.L      #2,D2                  Bytes required
          ADD.L      D2,D0
	  MOVE.L     D1,A5		    Save Seglist
          BSR        GETMEM

          MOVE.L     A5,D1                  Get back seglist
          TST.L      D0
          BNE.S      CRT1                   OK
* Error
          MOVEM.L    (SP)+,D2-D5/A2-A6
          BRA        GVC1		    return no free store error
d1083 6
a1088 3
* Call shared routine to initialise task structure slots
* INITTS returns top of stack in a4, process pointer in a1, process ID in a5!!
* it also corrupts D4 and A0!!!
d1090 3
a1092 1
CRT1      BSR        INITTS
a1093 26
* Copy BCPL name in A3 onto stack as C name
          MOVE.L     A5,-(SP)               Save process ID - TRICKY! EVIL!
	  MOVEQ      #0,D4
          MOVE.B     (A3),D4                Get length
          ADDQ.B     #2,D4                  Add 1 for null, 1 to round
          BCLR       #0,D4                  Round to word boundary
          SUBA.L     D4,A4                  Allocate space off stack
          MOVE.L     A4,LN_NAME(A1)         Name pointer
          MOVE.L     A4,TC_SPREG(A1)        And save as SPReg
          MOVE.L     A4,pr_ReturnAddr-pr_MsgPort(A5)   Also for STOP 
          MOVE.B     (A3)+,D4               Real length
CRT2      DBRA       D4,CRT3
          BRA.S      CRT4
CRT3      MOVE.B     (A3)+,(A4)+
          BRA.S      CRT2
CRT4      MOVE.B     #0,(A4)                Final nul

	    ;;;; MAKETS moved to before AddTask -- 14 nov 85
          BSR        MAKETS		    preserves A1!
          LEA.L      ACTIV(PC),A2           Initial PC
          LEA.L      DEACT(PC),A3           Final PC
	  CALL       AddTask

	  ; TRICKY! EVIL!
          MOVEM.L    (SP)+,D0/D2-D5/A2-A6     Restore regs, return procid
	  RTS				    C routine
d1097 1
a1097 2
* Entered with D0 = size, a6 = Execbase
* destroys D0/D1/A0/A1/A2, seriously funky!
d1099 9
a1107 7
GETMEM
	  MOVE.L     D0,-(SP)		    Size onto stack
	  MOVE.L     #MEMF_PUBLIC+MEMF_CLEAR,-(SP) Requirements
	  MOVE.W     #1,-(SP)		    Number of entries
	  LEA.L      -LN_SIZE(SP),SP        Leave space for node
	  MOVE.L     SP,A0		    Arg into A0
	  CALL       AllocEntry		    Get Memory
d1109 3
a1111 3
	  BLE.S      GetErr 
	  MOVE.L     D0,A2		    A2 is mem block
	  MOVE.L     ME_ADDR+ML_ME(A2),A1   A1 is task space
d1116 3
a1118 3
          MOVE.L     A2,D0		    Return memory
GetMem2   LEA.L      LN_SIZE+10(SP),SP      Adjust stack
	  MOVE.L     D0,D1                  BCPL return value
d1120 2
a1121 2
GetErr    MOVEQ      #0,D0                  Error
          BRA.S      GetMem2
d1123 4
a1126 10
* Initialise task structure slots. Called as follows:
* D0 Space for task - CPTR
* D1 Segment list - BPTR
* D2 Stacksize in bytes
* D3 Priority
* D5 Global vector ptr - APTR
* A6 Exec library base
* Corrupts D4 and A0!!
*	This is all still true - REJ
* Returns top of stack in a4, process pointer in a1, process id in a5!!!
d1128 6
a1133 22
INITTS    MOVE.L     D0,A1                  Task ptr
          MOVE.B     D3,LN_PRI(A1)          Priority
	  MOVE.B     #NT_PROCESS,LN_TYPE(A1)   Set type of new task
          MOVE.L     #SIGMASK,TC_SIGWAIT(A1)   Wait for this signal
	  LEA.L      AbortHandler(PC),A5
	  MOVE.L     A5,TC_TRAPCODE(A1)     Install trap handler
          LEA.L      TC_SIZE(A1),A5         A5 is now "process id" aka msgport
          LEA.L      pr_SIZEOF(A1),A4       A4 is low stack
          MOVE.L     A4,TC_SPLOWER(A1)      Fill in SPLower
          MOVE.L     A4,D4
          ASR.L      #2,D4                  Stack as BCPL ptr
          MOVE.L     D4,pr_StackBase-pr_MsgPort(A5)    Stored in process base
          ADDA.L     D2,A4                  Make SPUpper
          MOVE.L     A4,TC_SPUPPER(A1)	    also a return value!
          MOVE.L     A1,MP_SIGTASK(A5)      Initialise message port slot
	  LEA.L      MP_MSGLIST(A5),A2      Point to msg list
	  NEWLIST    A2                     Initialise this
          MOVE.B     #MSGSIG,MP_SIGBIT(A5)  ..and signal to be issued
* Initialise process structure
          MOVE.L     D1,pr_SegList-pr_MsgPort(A5)      Seglist (BPTR)
          MOVE.L     D2,pr_StackSize-pr_MsgPort(A5)    Stack size
          MOVE.L     D5,pr_GlobVec-pr_MsgPort(A5)      Global vector ptr (BPTR)
d1135 16
a1150 3
* Initialize the local env variable list
	  LEA	     pr_LocalVars-pr_MsgPort(a5),a0    list ptr
	  NEWLIST    a0
d1152 9
a1160 17
          RTS
*
* Subroutine to construct a new task
* Called with 
*  A5 pointer to new process base (msgport)
*  A6 execbase
* destroys A4
* returns pr_Seglist of current task in d0 as CPTR!
*
;;; makets now preserves a1 -- 14 nov 85, Neil
MAKETS
          MOVE.L     ThisTask(A6),A4
          MOVE.L     pr_SegList(A4),D0       Extract this seglist
	  ASL.L	     #2,D0
          MOVE.L     pr_ConsoleTask(A4),pr_ConsoleTask-pr_MsgPort(A5)
          MOVE.L     pr_FileSystemTask(A4),pr_FileSystemTask-pr_MsgPort(A5)
	  MOVE.L     pr_WindowPtr(A4),pr_WindowPtr-pr_MsgPort(A5)
a1161 17
* FIX!!!  Should copy local vars of parent!!!!

          RTS

*          CNOP       0,4
****************************************************************
*                                                              *
* ProcID := CreateProc( Name, Pri, Seg, Stacksize )            *
*                                                              *
* Creates a new process with specified (C format) name, pri    *
* and stacksize (in bytes). The segment list is one returned   *
* from LoadSeg, and other entries in the Segment vector are    *
* copied from the current environment.                         * 
*                                                              *
* struct MsgPort *createproc (char *name,LONG pri,BPTR seg,    *
* 			      LONG stacksize);		       *
****************************************************************
d1163 3
d1167 15
a1181 4
CRPROC
	  MOVE.L     R,-(SP)		return address
	  MOVE.L     D4,D0		faster than bra.s doslib_createproc!
	  ; fall through - CAREFUL!
d1183 4
a1186 5
@@createproc:				; called from inside DOS
_createproc:
	  MOVE.L     D0,D4		Lattice can't pass args in D4 via REG()
	  ; fall through
	  ; dos.library entry point
d1188 5
a1192 10
doslib_createproc:
          MOVEM.L    D2-D7/A0-A6,-(SP)	    MUST preserve A0/A1 for BCPL!
          MOVE.L     SysBase,A6             Get library pointer
	  ADDQ.L     #3,D4		    We want to round stack size up to
	  AND.W	     #$FFFC,D4		     the next multiple of 4 bytes
	  MOVE.L     D4,D0		    working stack size (bytes)
          MOVE.L     D1,D7                  Save name ptr
          MOVE.L     D3,D6                  Save Seg ptr
* Get space for Task struct and process base to stacksize (in bytes)
          ADD.L      #pr_SIZEOF,D0
d1194 3
a1196 17
* Find length of Task name and allocate everything using AllocEntry
	  MOVE.L     D7,A3		    point to name
CRP1	  TST.B	     (A3)+	            is byte zero ?
	  BNE.S	     CRP1		    at end, a3 points 1 past NULL
  	  SUB.L      A3,D7		    D7 = -(length including NULL)
	  ADD.L	     D7,A3		    A3 = pointer to start of name again
	  AND.W	     #$FFFC,D7		    make length an even number of LWs
	  SUB.L	     D7,D0		    form length of block (add length)
					  ; BCPL dos merely made it even
					  ; d0 and d7 were both multiples of 4
	  MOVE.L     D0,-(SP)		    save it
	  BSR        GETMEM		    a6=execbase, destroys d0-d1/a0-a2!!
*					    also adds all memory to tc_mementry
          MOVE.L     D0,D5                  Save task space ptr
          BNE.S      CRP3
	  ADDQ.L     #4,SP                  pop saved D0
	  BRA.S      CRPERR                 Now error
d1198 4
a1201 6
CRP3	  ADD.L	     (SP)+,D0		    address of stack end
	  MOVE.L     D0,A4		    d7 is multiple of 4 already
	  ADD.L	     D7,A4		    subtract str len from top of stack
	  MOVE.L     A4,D7		    into D7 for later-initial stack ptr
CRP2	  MOVE.B     (A3)+,(A4)+	    copy name
	  BNE.S	     CRP2	  
d1203 15
a1217 1
* Make segment ptr (segarray)
d1219 7
a1225 11
          MOVEQ      #(SEGSIZE+2)*4,D0      Segment space (FIX)
	  MOVE.L     #MEMF_PUBLIC!MEMF_CLEAR,D1  Requirements
	  CALL       AllocMem
          MOVE.L     D0,D1                  Segment space to D1
          BEQ.S      CRPERR
          MOVE.L     D1,A3
	  MOVEQ	     #(SEGSIZE+2)*4,D0
          MOVE.L     D0,(A3)		    Slot in size for FREEVEC
          ADDQ.L     #4,D1                  D1 points to seglist
          MOVE.L     D1,-(SP)               Save segment ptr
	  LSR.L	     #2,D1		    to bptr for initts
d1227 7
a1233 1
* Initialise process.  D1 has segarray BPTR already, a6 = execbase
d1235 6
a1240 2
          MOVE.L     D2,D3                  Pri to D3
          MOVE.L     D4,D2                  Stacksize to D2
d1242 4
a1245 1
* because of this, NOT_REAL no longer works (use BSR GETDATA to make it work)
d1247 6
a1252 5
	  BSR        @@dosbase		    returns dosbase in d0 - doesn't
*					    modify any other regs!
	  MOVE.L     D0,A3		    dosbase->a3
	  MOVE.L     D5,D0		    task space ptr->d0
          MOVE.L     dl_GV(A3),D5           Address of shared global
d1254 4
a1257 6
* INITTS returns top of stack in a4, process pointer in a1, process ID in a5!!
* it also corrupts D4 and A0!!!
* inputs: d0-task d1-segarray(bptr) d2-stacksize(bytes) d3-pri d5-gv a6-execbase
*
* Since stacksize in d2 is before adding task name to it, INITTS will set
* the stack top to the name, longword aligned (a4 == d7).
a1258 39
          BSR        INITTS                 Initialise task
          MOVE.L     D2,-(A4)               Place size onto stack
          MOVE.L     A4,TC_SPREG(A1)        And slot in as SPReg
          MOVE.L     A4,pr_ReturnAddr-pr_MsgPort(A5)   Fill in return address
          MOVE.L     D7,LN_NAME(A1)         Fill in name provided

* Fill in the segment list, and copy values from caller
* Makets now returns CPTR - takes msgport addr in a5 as input, kills a4

	  BSR        MAKETS		    Return with D0= SegVec ptr (CPTR)
          MOVE.L     D0,A4		      and preserves A1
	  MOVE.L     (SP)+,A2               A1 is task ptr/A2 is segarray cptr

* At this point we have A1 pointing to task control block.
* Register A4 points to the segment vector for the caller process.
* In A2 we must build the segment vector.
* We allow four slots: size (2) / Klib chain / Blib chain / This segment
* The size is set to 2 because only the first two segment lists are BCPL
* tasks and hence require BCPL initialisation via GLOBIN.
*
* In reality, since we don't use ACTIV as the initial code, GLOBIN never
* gets called anyway.
*
	  MOVEQ	     #(SEGSIZE-1),d0	    FIX!!!
	  MOVE.L     d0,(A2)+		    Size
	  MOVE.L     4(A4),(A2)+	    Klib segment
	  MOVE.L     8(A4),(A2)+	    Blib segment
	  MOVE.L     D6,(A2)+		    This segment
* Set up entry code and make process
          LSL.L      #2,D6                   mc ptr to list
	  ADDQ.L     #4,D6		     entry point
          MOVE.L     D6,A2
          LEA.L      DEACT(PC),A3            exit point
	  CALL       AddTask
          MOVE.L     A5,D0                   return process id
	  MOVE.L     D0,D1		     for BCPL
CRPERR    MOVEM.L    (SP)+,D2-D7/A0-A6
	  RTS

d1275 1
d1352 4
a1355 2
DEACT     MOVE.L     SysBase,A6
          MOVE.L     ThisTask(A6),A1	    ; faster than findtask()
d1357 7
a1363 4
* Free SegArray
          MOVE.L     pr_SegList(A1),D1	    ; BPTR
	  ASL.L	     #2,D1		    ; CPTR
          BSR        @@freevec               ; Call freevec(seglist)
d1365 4
a1368 1
* Free private global vector, if any
d1370 2
a1371 6
          MOVE.L     pr_GlobVec(A1),D1	    ; get process's global vector
	  BSR        GETDATA		    ; dosbase into a3
          CMP.L      dl_GV(A3),D1	    ; See if the same as shared gv
          BEQ.S      DEACT2                 Don't deallocate if so
          SUB.L      #NEGSIZE<<2,D1         Allow for negative globals
          BSR        @@freevec                Call freevec(gbase)
d1373 1
a1373 5
* Deallocate task structure and stack - A6 has execbase from above
DEACT2
	  SUBA.L     A1,A1		    Request self removal
	  CALL       RemTask		    Bye bye
	  RTS				    Should never happen
d1376 1
a1376 1
******************************************************************
d1562 3
a1564 2

	  MOVE.L     D0,D1            Return flag as result
d2280 1
a2280 1
	  MOVEM.L    D1-D3/D7/A0/A1/A6,-(SP)	; save regs for below and BCPL
d2286 1
a2286 1
	  LEA.L      LINE0(PC),A0
d2289 3
a2291 2
ABORT0	  LEA.L      LINE1(PC),A0
ABORT1	  MOVE.L     A0,D1
d2293 3
a2295 2
	  LEA.L      LINE2(PC),A0
	  MOVE.L     A0,D2
d2297 3
a2299 2
	  LEA.L      LINE3(PC),A0
	  MOVE.L     A0,D3
d2301 2
d2326 1
a2326 1
ABORT2    MOVEM.L     (SP)+,D1-D3/D7/A0/A1/A6
d2330 5
a2335 5
LINE0	  DC.B       'Disk corrupt - task stopped',0
LINE1	  DC.B       'Software error - task stopped',0
LINE2	  DC.B       ' Finish ALL disk activity',0
LINE3	  DC.B       'Select CANCEL to reboot',0

d2363 3
d2400 5
d2461 1
d2463 6
a2468 2
	MOVEM.L	(SP)+,D0/D2-D7/A0-A6	; return returncode &
				        ; restore all C/asm regs (TRICKY!!!)
d2474 1
a2474 2
RUNERRL MOVEQ   #-1,D1
        MOVE.L	D1,-(SP)
@


36.6
log
@Added dos error strings to dosbase, support in process for local vars.
Minor opt to AllocVec.
@
text
@d150 2
d153 1
d185 1
d1515 2
a1516 1
DELTASK   EQU        DEACT
d1848 2
d1881 2
a1882 1
@@qpkt:	  MOVE.L     A6,-(SP)		 Save
@


36.5
log
@Fixed AllocVecType for 1..3 bytes
0 bytes returns null.
@
text
@d196 8
d454 5
d1134 1
a1134 1
* it also corrupts D4!!!
d1199 1
a1199 1
* Corrupts D4
d1225 5
d1247 3
d1342 1
a1342 1
* it also corrupts D4!!!
d1773 2
a1774 2
          MOVE.L     D1,(A0)          Store size in bytes
          ADDQ.L     #4,D0            .. and avoid size
d1810 1
a1810 1
          ANDI.L     #$FF000003,D1    Top byte and bottom 2 bits..
@


36.4
log
@Moved initial stack back to 400, added AllocVec/AllocVecType.
@
text
@d1741 1
a1741 1
          BLE.S      GVC1             Error if negative or 0
@


36.3
log
@Some commented-out debugs added, lsl->asl.
@
text
@d144 4
d259 1
a259 1
CLISTK    EQU   1000		     Stack used for initial CLI (was 400!!FIX!!)
d531 1
a531 1
NEWER_FS	EQU	1
d533 1
a533 1
     IFD NEWER_FS
d547 1
d1716 4
d1727 11
a1737 1
@@getmem:			      ; note: not the same as GETMEM!!!
d1739 1
a1739 1
	  ADDQ.L     #2,D1            True vector size + 1 overhead!!!!!!
d1741 2
a1742 1
          BLE.S      GVC1             Error if negative
@


36.2
log
@Fixed Runcommand (dos.library entry point)
@
text
@d1655 3
d1666 9
d2160 1
a2160 1
	  ASL.L	     #2,D0		; so C/asm get CPTR!
@


36.1
log
@*** empty log message ***
@
text
@d177 1
a2435 1
	MOVE.L	D4,D0			; C version wants it in D0
d2438 4
@
