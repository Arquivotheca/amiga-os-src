head     36.54;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


36.54
date     93.01.01.21.16.04;  author jesup;  state Exp;
branches ;
next     36.53;

36.53
date     92.12.14.15.00.41;  author jesup;  state Exp;
branches ;
next     36.52;

36.52
date     92.12.14.00.14.12;  author jesup;  state Exp;
branches ;
next     36.51;

36.51
date     92.12.14.00.08.31;  author jesup;  state Exp;
branches ;
next     36.50;

36.50
date     92.06.02.00.07.08;  author jesup;  state Exp;
branches ;
next     36.49;

36.49
date     92.04.29.16.59.31;  author jesup;  state Exp;
branches ;
next     36.48;

36.48
date     92.04.29.15.52.15;  author jesup;  state Exp;
branches ;
next     36.47;

36.47
date     92.04.07.00.58.00;  author jesup;  state Exp;
branches ;
next     36.46;

36.46
date     92.04.05.23.51.58;  author jesup;  state Exp;
branches ;
next     36.45;

36.45
date     92.02.25.14.49.37;  author jesup;  state Exp;
branches ;
next     36.44;

36.44
date     91.05.08.23.29.56;  author jesup;  state Exp;
branches ;
next     36.43;

36.43
date     91.03.12.22.27.02;  author jesup;  state Exp;
branches ;
next     36.42;

36.42
date     91.03.11.22.16.14;  author jesup;  state Exp;
branches ;
next     36.41;

36.41
date     91.02.19.02.06.16;  author jesup;  state Exp;
branches ;
next     36.40;

36.40
date     91.02.13.19.01.25;  author jesup;  state Exp;
branches ;
next     36.39;

36.39
date     91.02.01.16.13.11;  author jesup;  state Exp;
branches ;
next     36.38;

36.38
date     90.12.21.16.54.19;  author jesup;  state Exp;
branches ;
next     36.37;

36.37
date     90.12.17.22.26.07;  author jesup;  state Exp;
branches ;
next     36.36;

36.36
date     90.12.16.03.42.12;  author jesup;  state Exp;
branches ;
next     36.35;

36.35
date     90.12.10.20.35.30;  author jesup;  state Exp;
branches ;
next     36.34;

36.34
date     90.11.30.03.27.38;  author jesup;  state Exp;
branches ;
next     36.33;

36.33
date     90.11.21.02.07.12;  author jesup;  state Exp;
branches ;
next     36.32;

36.32
date     90.09.25.16.07.47;  author jesup;  state Exp;
branches ;
next     36.31;

36.31
date     90.09.11.21.56.38;  author jesup;  state Exp;
branches ;
next     36.30;

36.30
date     90.07.29.23.57.53;  author jesup;  state Exp;
branches ;
next     36.29;

36.29
date     90.05.23.19.46.37;  author jesup;  state Exp;
branches ;
next     36.28;

36.28
date     90.05.22.16.30.12;  author jesup;  state Exp;
branches ;
next     36.27;

36.27
date     90.05.09.01.54.42;  author jesup;  state Exp;
branches ;
next     36.26;

36.26
date     90.04.07.04.00.08;  author jesup;  state Exp;
branches ;
next     36.25;

36.25
date     90.04.07.00.15.04;  author jesup;  state Exp;
branches ;
next     36.24;

36.24
date     90.04.06.11.52.25;  author jesup;  state Exp;
branches ;
next     36.23;

36.23
date     90.04.03.04.59.33;  author jesup;  state Exp;
branches ;
next     36.22;

36.22
date     90.04.03.04.41.19;  author jesup;  state Exp;
branches ;
next     36.21;

36.21
date     90.03.19.17.06.15;  author jesup;  state Exp;
branches ;
next     36.20;

36.20
date     90.03.17.23.44.39;  author jesup;  state Exp;
branches ;
next     36.19;

36.19
date     90.03.03.02.12.02;  author jesup;  state Exp;
branches ;
next     36.18;

36.18
date     90.02.16.22.08.35;  author jesup;  state Exp;
branches ;
next     36.17;

36.17
date     90.02.02.17.20.04;  author jesup;  state Exp;
branches ;
next     36.16;

36.16
date     90.02.02.02.49.51;  author jesup;  state Exp;
branches ;
next     36.15;

36.15
date     90.01.31.02.30.28;  author jesup;  state Exp;
branches ;
next     36.14;

36.14
date     90.01.17.21.21.13;  author jesup;  state Exp;
branches ;
next     36.13;

36.13
date     89.12.15.05.07.36;  author jesup;  state Exp;
branches ;
next     36.12;

36.12
date     89.12.15.00.02.51;  author jesup;  state Exp;
branches ;
next     36.11;

36.11
date     89.12.11.23.48.43;  author jesup;  state Exp;
branches ;
next     36.10;

36.10
date     89.12.10.21.28.26;  author jesup;  state Exp;
branches ;
next     36.9;

36.9
date     89.12.09.10.58.13;  author jesup;  state Exp;
branches ;
next     36.8;

36.8
date     89.12.09.01.42.45;  author jesup;  state Exp;
branches ;
next     36.7;

36.7
date     89.12.08.07.09.18;  author jesup;  state Exp;
branches ;
next     36.6;

36.6
date     89.12.01.08.04.35;  author jesup;  state Exp;
branches ;
next     36.5;

36.5
date     89.11.22.03.08.47;  author jesup;  state Exp;
branches ;
next     36.4;

36.4
date     89.10.24.18.17.29;  author jesup;  state Exp;
branches ;
next     36.3;

36.3
date     89.10.18.04.13.42;  author jesup;  state Exp;
branches ;
next     36.2;

36.2
date     89.09.21.22.02.59;  author jesup;  state Exp;
branches ;
next     36.1;

36.1
date     89.09.16.22.06.17;  author jesup;  state Exp;
branches ;
next     ;


desc
@@


36.54
log
@Don't free user buffer on Close
@
text
@/* bcplio.c */

#include <exec/types.h>
#include <exec/io.h>
#include <exec/alerts.h>
#include <exec/memory.h>
#include <exec/execbase.h>
#include <devices/timer.h>
#include "dos/dos.h"
#include "dos/dosextens.h"

#include <string.h>

#include "libhdr.h"
#include "dos_private.h"

#include <clib/exec_protos.h>
#include <pragmas/exec_old_pragmas.h>
#include "blib_protos.h"
#include "klib_protos.h"

#define SAME		0			/* for string compares */
#define TOBPTR(x)	(((LONG) (x)) >> 2)	/* convert to bptr */

/* for doing __asm stuff */
#define ASM __asm
#define REG(x)	register __ ## x	/* ANSI concatenation */


/* BCPL dos used BPTR to the buffers in the filehandles.  I want to use CPTRs
 * for speed reasons, but am leaving them a BPTRs until I can boot the new
 * dos to reduce possible problems using handles created by the old dos.
 * NOTE: must also change setting of the buffer!!!
 * ALSO NOTE: must change cli.c also!!!!
 * Can't do it: Execute/Run/NewCLI(?) use it also.  ARGH
 */

#ifdef NEWDOS
#define BUFFER(fh)	((UBYTE *) (fh)->fh_Buf)
#define TOBUFFER(buf)	(buf)
#else
#define BUFFER(fh)	((UBYTE *) BADDR((fh)->fh_Buf))
#define TOBUFFER(buf)	(TOBPTR(buf))
#endif

static void __regargs common_getc (struct FileHandle *cis);

LONG ASM
FGetC (REG(d1) BPTR fh)
{
	struct FileHandle *cis;
	LONG pos,end;

	cis = BADDR(fh);
	if (!cis)
		return ENDSTREAMCH;

	/* handle all type-of-buffer issues */
	common_getc(cis);

	/* stupid old bcpl endcli just sets fh_End to 0, ignoring fh_Pos */
	/* this caused them not to be equal, and it would read -1(null)  */
	/* on EOF, replenish returns EOF, but does NOT set it to always  */
	/* return EOF - it will retry the read on the next attempt.      */
	/* this also improves handling of read errors.			 */
	pos = cis->fh_Pos;
	end = cis->fh_End;

	/* handle EOF; UnGetC(fh,-1); FGetC(fh) - should return EOF! */
	/* pos == -3, means we unread an EOF */
	/* pos == -2, means we read an EOF last */
	if (pos == -3)
	{
		cis->fh_Pos = -2;	/* only return the EOF once */
		return ENDSTREAMCH;
	}

	/* if we read an EOF last, keep trying */
	if (pos < 0 || pos >= end)
		return replenish(end,cis);

	/* first call, buffer exhausted or stream exhausted */
	/* Note: pos changed! */
	return (LONG) BUFFER(cis)[(cis->fh_Pos)++];
}

static void __regargs
common_getc (struct FileHandle *cis)
{
	/* we use fh_Func3 as a "buffer may be dirty" flag */
	/* if it might be dirty, flush it.  replenish will then be called */

	/* NIL: leaves funcs == 0 */
	if (cis->fh_Func3 && cis->fh_Func3 != (LONG) actendread)
	{

/*if (cis->fh_Func3 == (LONG) actendread)
kprintf("fgetc: switching from write to read, fh = 0x%lx!\n",cis);
else
kprintf("fgetc: initial read from 0x%lx\n",cis);
*/
		/* If func3 = actend, then this was NOT a write buffer   */
		/* Either it hasn't been touched, and pos/end are -1, or */
		/* it has had a buffer transplant from a shell, in which */
		/* case we do NOT want to call replenish (yet)! 	 */
		if (cis->fh_Func3 != (LONG) actend)
		{
			/* this writes the dirty buffer, if any */
			Flush(TOBPTR(cis));

			/* set pos/end for read (forces replenish) */
			cis->fh_Pos = cis->fh_End = -1;
		}

		/* mark the buffer as a read buffer */
		cis->fh_Func3 = (LONG) actendread;
	}
}

/* if ch == -1 (EOF), then don't change the char (kludge) */
/* we'll assume they just read a character - no checks of buffer type here */

LONG ASM
UnGetC (REG(d1) BPTR fh, REG(d2) LONG ch)
{
	struct FileHandle *cis;
	LONG pos,end;
	UBYTE *p;

	cis = BADDR(fh);
	if (!cis)
		return FALSE;

	/* handle all type-of-buffer issues */
	common_getc(cis);

	pos = cis->fh_Pos;
	end = cis->fh_End;

	/* this handles UnGetC(fh,-1) after an EOF - it should return EOF */
	/* see FGetC - pos can be -2 or -3, handle the same */
	if (ch == -1 && pos < -1)
	{
		cis->fh_Pos = -3;	/* flag to fgetc to EOF read */
		return FALSE;		/* couldn't unread */
	}

/* FIX!?? */
	/* End==0 is a flag for continual EOF from EndCli */
	/* -1 means it was never buffered before, 0 means at start of buf */
	if (pos == -1 || pos == 0)
		return (end == 0 ? DOSTRUE : FALSE);

	/* real ungetc of a character - do it, ignore EOF flag */
	if (pos < 0)		/* must be -2 or -3 */
		pos = end;	/* turn off EOF flag */

	cis->fh_Pos = --pos;	/* update ptr */

	p = &(BUFFER(cis)[pos]);
	if (ch != -1)
		return (LONG) (*p = ch);

	/* ch == -1, means unread last char read.  for compatibility, we'll  */
	/* return -1 (which the old unrdch would have done). */
	return DOSTRUE;
}

/* returns ch or EOF for error */

LONG ASM
FPutC (REG(d1) BPTR fh, REG(d2) LONG ch)
{
	struct FileHandle *cos;

	cos = BADDR(fh);
	if (!cos)
		return ENDSTREAMCH;

	/* we use fh_Func3 as a "buffer may be dirty" flag */
	/* if it's a read buffer, flush it.  We can then start filling it. */
	/* NIL: leaves funcs == 0 */
	if (cos->fh_Func3 && cos->fh_Func3 != (LONG) actendwrite)
	{
/*
if (cos->fh_Func3 == (LONG) actendread)
kprintf("switching from read to write, fh = 0x%lx!\n",cos); 
else
kprintf("initial buffered write to 0x%lx\n",cos);
*/
		/* this resets us to the correct position (pos/end == -1) */
		Flush(fh);

		/* If func3 = actend, then this was NOT a read buffer    */
		/* Either it hasn't been touched, and pos/end are -1, or */
		/* it has had a buffer transplant from a shell, in which */
		/* case we want to make fh_Pos and fh_End -1.		 */
		if (cos->fh_Func3 != (LONG) actend)
		{
			/* set the fh_End to the buffer size (FIX!!!!!) */
			cos->fh_Pos = 0;
			cos->fh_End = BufferSize((struct NewFileHandle *) cos);
		} else {
			/* force it to allocate a new buffer */
			/* just in case a shell stuffed an input buffer here */
			/* but no one ever used a buffered read on it. */
			cos->fh_Pos = cos->fh_End = -1;
		}

		/* mark the buffer as a write buffer */
		cos->fh_Func3 = (LONG) actendwrite;
	}
	/* see above comments re: endcli.  Fixed here too for safety */
	/* note that on the initial write, pos == end == -1          */

	/* flushes on full buffer */
	if (cos->fh_Pos < 0 || cos->fh_Pos >= cos->fh_End)
	{
		/* NIL: works here! */
		/* failed on error or func == 0 - return success for NIL:*/
		if (!deplete(cos))
		{
			if (cos->fh_Func2 == NULL)
				return ch;
			else
				return ENDSTREAMCH;
		}
	}

	BUFFER(cos)[cos->fh_Pos++] = ch;

	/* flush if interactive on certain control chars */
	if (((LONG) cos->fh_Flags) & FHF_NONE)
	{
		/* no buffering, flush on each character */
		goto flush_it;

	} else if (!(((LONG) cos->fh_Flags) & FHF_FULL)) {

		/* normal line buffering - the default */
		if (ch < ' ' && cos->fh_Interactive &&
		    (ch == '\n' || ch == 0 || ch == '\r' || ch == '\12'))
		{
flush_it:		if (!deplete(cos))
				return ENDSTREAMCH;
		}
	}
	/* FHF_FULL means it's all handled above in the buffer-full case */

	return ch;
}

LONG ASM
Flush (REG(d1) BPTR fh)
{
	struct FileHandle *cos;
	LONG func3;

	cos = (struct FileHandle *) BADDR(fh);
	if (!cos)
		return DOSTRUE;
	func3 = cos->fh_Func3;

	/* the first test keeps us from doing anything if it isn't buffered */
	/* we use fh_Func3 as a "buffer may be dirty" flag */
	/* not the best, but it ought to work unless people start mucking */

	if (func3 == (LONG) actend)	/* never read from */
		goto reset_fh;		/* people can put data in the buffer */

	if (cos->fh_Pos < 0)
	{
		if (cos->fh_Pos == -1)	/* nothing in the buffer */
			return DOSTRUE;
		else
			goto reset_fh;	/* fgetc or ungetc an eof */
	}

	if (func3 == (LONG) actendwrite) {
		/* leaves file positioned correctly if we switch to either */
		/* non-buffered writes/reads or to buffered reads. */
		deplete((struct FileHandle *) cos);

		/* FIX!!! should return result of deplete for writes */

	} else if (func3 == (LONG) actendread) {
		/* flushing read filehandle, buffered */
		/* try to seek to current buffered read position first */
		/* (gulp) */

		noflushseek(fh,cos->fh_Pos - cos->fh_End,OFFSET_CURRENT);
reset_fh:
		/* as if it was never buffered */
		cos->fh_Pos = cos->fh_End = -1;
	}

	return DOSTRUE;
}

LONG __regargs
replenish (end,cis)
	LONG end;
	struct FileHandle *cis;
{
	LONG __regargs (*func)(struct FileHandle *);

/*kprintf("replenish of 0x%lx, fh_Type = 0X%lx...",cis,cis->fh_Type);*/
	/* this is how EndCli forces termination of the stream!!!! */
	/* if it formerly was a write buffer, end is buffer size */
	if (end == 0)
		return ENDSTREAMCH;	/* EOF */

	func = (LONG __regargs (*)()) cis->fh_Func1;
	if (func == 0 || !((*func)(cis)))
	{
		/* read error or eof or NIL: */
		/* cis->fh_Pos = cis->fh_End = 0; */
		/* used to set fh_Pos=fh_End=0 here to force continual EOF */
		/* I fixed readitem to not unread on EOF, so it's not needed */

		/* now we set pos = -2 to flag to ungetc that we hit eof */
		cis->fh_Pos = -2;
		return ENDSTREAMCH;		/* EOF */
	}

	cis->fh_Pos = 1;

/*kprintf("done with replenish\n");*/
	return (LONG) BUFFER(cis)[0];
}

LONG __regargs
deplete (cos)
	struct FileHandle *cos;
{
	LONG res2,rc;
	LONG __regargs (*func)(struct FileHandle *);

/*kprintf("deplete of 0x%lx\n",cos);*/
	res2 = getresult2();

	func = (LONG __regargs (*)()) cos->fh_Func2;
	if (func == NULL)
	{
		/* DON'T set fh_Pos = 0 for NIL:! */
		return FALSE;
	}
	/* it sets fh_Pos to 0 on success */
	/* on initial call it also sets fh_End to SCB_BUFFERSIZE */
	/* returns number of chars written */
	rc = (*func)(cos);

	setresult2(res2);
	return (rc > 0 ? DOSTRUE : FALSE);
}

/* general.interface unneeded */
/* i.open == findstream */

void ASM
init_scb (REG(d1) struct FileHandle *fhb, REG(d2) ULONG type)
{
	struct NewFileHandle *scb = (void *) fhb;

	scb->fh_Flags = FHF_EXTEND; 	/* FHF_LINE is the default mode */
	scb->fh_Interactive = scb->fh_Type = 0;
	scb->fh_Pos = -1;
	scb->fh_End = -1;
	scb->fh_Buf = NULL;			/* paranoia */
	scb->fh_Func1 = (LONG) actreadinit;
	scb->fh_Func2 = (LONG) actwriteinit;
	scb->fh_Func3 = (LONG) actend;
	scb->fh_BufSize = SCB_BUFFERSIZE;
	scb->fh_DupBufPtr = 0xfedcba98;

/* we use fh_Func3 as a "buffer may be dirty" flag - actendwrite == dirty */
/* replenish and deplete change it as needed, FGetC/FPutC check it. */
/* actend is a "neutral" setting, to fix Bill whawes */
}

BPTR ASM
findinput (REG(d1) char *string)
{
	return findstream(string,ACTION_FINDINPUT);
}

BPTR ASM
findoutput (REG(d1) char *string)
{
	return findstream(string,ACTION_FINDOUTPUT);
}

/* aka Open() */
/* NOT in GV directly */
/* MUST be safe to call findstream("NIL:"...) from a TASK for createnewproc!! */

BPTR ASM
findstream (REG(d1) char *string,	/* aka Open() */
	    REG(d2) LONG act)
{
	UBYTE *name,*newname;
	struct FileHandle *scb;
	struct MsgPort *task;
	struct DevProc *dp = NULL;
	BPTR lock;
	LONG rc, links = MAX_LINKS;

/*kprintf("Open(\"%s\",%ld) ",string,act);*/

	/* allocate scb and name once, not each time */
	scb = AllocDosObject(DOS_FILEHANDLE,NULL);
	if (!scb)
		return NULL;	/* no space */
/*kprintf("scb = 0x%lx\n",scb);*/

	/* extra +1 for null-termination! */
	name = AllocVecPub(strlen(string)+1+1);
	if (!name)
	{
		freeVec(scb);
		return NULL;
	}
	CtoB(string,(CPTR) name);	/* open wants BSTR! */
	name[*name+1] = '\0';

	while (1) {
		/* init the scb for safety in case handler played with it */
		init_scb((struct FileHandle *) scb,act);

		task = (struct MsgPort *) (lock = NULL);

		/* check for * meaning current window */
		if (strcmp("*",(char *) name+1) == SAME ||
		    mystricmp("CONSOLE:",(char *) name+1) == SAME)
		{
			/* if we have no consoletask, silently send it	*/
			/* to the great bit-bucket in the sky.		*/
			task = consoletask();	/* lock is NULL */
			if (!task)
				goto open_nil;
		} else {
			/* check for resident or built in device */
			if (mystricmp("NIL:",(char *) name+1) == SAME)
			{
open_nil:			/* NIL: works here */
				/* leave fh_Type == 0 */
				scb->fh_Func1=scb->fh_Func2=scb->fh_Func3 = 0;
				goto ret_ok;

			}
			/* we need to really open it */
			/* dp may or may not be NULL here */
			dp = getdevproc((char *) name+1,dp);
			if (dp)
			{
				task = dp->dvp_Port;
				lock = dp->dvp_Lock;
			}
		}

		if (task == NULL)	/* device doesn't exist */
			goto ret_error;

		scb->fh_Type = task;

/*kprintf("sending pkt to handler 0x%lx, lock = 0x%lx, fh = 0x%lx\n",task,lock,
scb);*/
		rc = sendpkt3(task,act,TOBPTR(scb),lock,TOBPTR(name));

/*kprintf("packet returned, rc = %ld, ioerr = %ld\n",rc,getresult2());*/
		if (rc)
			goto ret_ok;

		/* was it a multiple assign? */
		/* FIX!!!!!! support new open modes!!!!!!!! */
		switch (getresult2()) {
		case ERROR_OBJECT_NOT_FOUND:
			if (dp && act != ACTION_FINDOUTPUT &&
			    (dp->dvp_Flags & DVPF_ASSIGN))
			{
				/* it's a multiple assign - try again */
				continue;
			}
			break;
		case ERROR_IS_SOFT_LINK:
			if (--links >= 0)
			{
			  /* for the time being, max 255 chars */
			  /* Bstr is allocated in 256 bytes */
			  newname = AllocVecPub(256);
			  if (!newname)
			    break;

			  BtoCstr((CPTR) name);

			  if (ReadLink(task,lock,name,newname,256) >= 0)
			  {
			    freeVec(name);
			    name = newname;
			    CtoBstr(name);
			    name[*name+1] = '\0';
			    goto loop;
			  } else {
			    /* we can't deal with >255 chars */
			    /* should still be null-terminated ok */
			    CtoBstr(name);
			    freeVec(newname);
			    setresult2(ERROR_INVALID_COMPONENT_NAME);
			  }
			} else {
			  setresult2(ERROR_TOO_MANY_LEVELS);
			}
default:		break;
		}

		/* open really failed */
		if (err_report(REPORT_LOCK,lock,task))
			goto ret_error;

loop:
		/* make sure we free before going around again */
		freedevproc(dp);	/* NULL is ok */
		dp = NULL;		/* so we don't free it twice */

	} /* while (1) */


ret_error:
	freeVec(scb);
	scb = NULL;		/* causes NULL return */
ret_ok:
	freeVec(name);
	freedevproc(dp);	/* NULL is ok */

	return TOBPTR(scb);	/* may be null */
}

/*
// Standard support functions for BCPL rdch and wrch

// Any buffers required are obtained here and released here.

// Initial read. Obtain buffer for rdch

EVIL!!!!! FIX!!!! if used for reading and writing, buffers are lost!!!!!
*/

char * __regargs
actinitcommon (scb)
	struct NewFileHandle *scb;
{
	char *nbuf;

	/* deal with buffer already allocated */
	if (scb->fh_Buf == 0)
	{
		/* BCPL used getvec.  This allocated 4 extra bytes, plus 4
		 * more because of granularity.  WShell counted on all these
		 * bytes being available to use, so the minimum size acceptable
		 * is 204 bytes (SCB_BUFFERSIZE+8).  This is a KLUDGE and may
		 * be removed at some time in the future. - REJ
		 */
		nbuf = AllocVecPub(SCB_BUFFERSIZE+8);
		if (!nbuf)
		{
			setresult2(ERROR_NO_FREE_STORE);
			return FALSE;
		}
		/* fh_BufSize is already set to SCB_BUFFERSIZE */

		/* only need to call init once! */
		scb->fh_Func1 = (LONG) actread;
		scb->fh_Func2 = (LONG) actwrite;

	} else
		return BADDR(scb->fh_Buf);

	/* goddamn cli and shell mess with the buffer! */
	scb->fh_Buf   = TOBUFFER(nbuf);

	/* check magic number to be doubly sure we allocated it! */
	if ((scb->fh_Flags & FHF_EXTEND) &&
	    (scb->fh_DupBufPtr = 0xfedcba98))
	{
		scb->fh_DupBufPtr = scb->fh_Buf;
	}

	return nbuf;
}

LONG __regargs
actreadinit (scb)
	struct NewFileHandle *scb;
{
	if (!actinitcommon(scb))
		return FALSE;

	/* actread sets fh_Pos and fh_End */
	return (actread((struct FileHandle *) scb));
}

/* Subsequent reads.  Refill existing buffer */
/* doesn't modify pos/end if Read() returns EOF */
LONG __regargs
actread (scb)
	struct FileHandle *scb;
{
	LONG len = BufferSize((struct NewFileHandle *) scb);

	/* FIX! use variable buffer size! */
	if (((LONG) scb->fh_Flags) & FHF_NONE)
	{
		/* no buffering, read 1 char at a time */
		len = 1;
	}
	len = read(TOBPTR(scb),BUFFER(scb),len);

	/* this may be redundant */
	if (!len)	/* BCPL used to do this always, I dunno why - FIX */
		setresult2(0);
	else {
		scb->fh_Pos = 0;
		scb->fh_End = len;
	}
	return len > 0;		/* len == 0 means EOF, <0 means error */
}

LONG __regargs
actend (scb)
	struct FileHandle *scb;
{
	struct NewFileHandle *fh = (void *) scb;
	LONG r;
	void *buf = BUFFER(fh);

/*kprintf("closing 0x%lx...",fh);*/
	// make sure we should free the buffer... (SetVBuf)
	// note: if we didn't allocate the fh, or if someone punched fh_Buf,
	// just free fh_buf as we always have.  If we allocated it AND we
	// installed the buffer, AND it's a user buffer, don't free it.
	if (!(fh->fh_Flags & FHF_EXTEND) ||
	    fh->fh_Buf != fh->fh_DupBufPtr ||
	    (buf && !(fh->fh_Flags & FHF_USERBUF)))
	{
		freeVec(buf);	// NULL is ok
	}
	while (1)
	{
		r = sendpkt1(fh->fh_Type,ACTION_END,fh->fh_Arg1);
		if (r || err_report(REPORT_STREAM,TOBPTR(fh),NULL))
			return r;
	}
	/*NOTREACHED*/
}

/* Termination.  Free the buffer and inform handler task */
LONG __regargs
actendread (scb)
	struct FileHandle *scb;
{
	return actend(scb);	/* because we use actendread as a flag! */
}

/* // Initial write. Obtain buffer for wrch */

LONG __regargs
actwriteinit (scb)
	struct NewFileHandle *scb;
{
	if (!actinitcommon(scb))
		return -1;	/* error, ala Write() */

	scb->fh_Pos   = 0;
	scb->fh_End   = BufferSize((struct NewFileHandle *) scb);

	return 1;	/* no bytes written, but 0 means an error! */
}

/* subsequent writes */
LONG __regargs
actwrite (scb)
	struct FileHandle *scb;
{
	LONG rc = 1;

	/* don't do a 0-length write if it can be avoided */
	if (scb->fh_Pos > 0)
	{
		rc = write(TOBPTR(scb),BUFFER(scb),scb->fh_Pos);
		if (rc > 0)
			scb->fh_Pos = 0;	/* FIX! handle partial flush!*/
	}
	return rc;
}

/* Termination.  Write final buffer then act as actendread  */
LONG __regargs
actendwrite(scb)
	struct FileHandle *scb;
{
	if (scb->fh_Pos > 0)	/* is it empty? */
		(void) actwrite(scb);	/* flush output */
	/* used to check if actwrite returned < 0 and not actend it */
	/* we now close it regardless of flush errors */

	return actend(scb);
}

LONG ASM
endread ()
{
	return endstream(input());
}

LONG ASM
endwrite ()
{
	return endstream(output());
}

/* aka Close() */
/* note: preserves result2 if it succeeds! */

LONG ASM
endstream (REG(d1) BPTR scb)
{
	LONG __regargs (*func)(struct FileHandle *);
	LONG res2,rc = DOSTRUE;	/* important! so if func3==0 we free fh */
	struct FileHandle *fh;

	if (!scb)
		return FALSE;
	fh = BADDR(scb);

	res2 = getresult2();
	func = (LONG __regargs (*)()) fh->fh_Func3;

	/* kill those poor people who close twice */
	/* assuming the memory hasn't been re-allocated yet, of course */
	if (((LONG) func) == -1)
		abort(AN_FileReclosed|AT_DeadEnd);

	/* usually (read always) ends up in actendread, which does close */
/*kprintf("closing 0x%lx\n",fh);*/
	if (func)
		rc = (*func)(fh);
/*kprintf("end function returned %ld\n",rc);*/

	fh->fh_Func3 = -1;

	freeVec(fh);
	if (rc)
		setresult2(res2);	/* keep IoErr on failure */

/*else kprintf("Close failed!!!!!!\n");*/

/*kprintf("close done\n");*/
	return rc;
}

LONG ASM
readn ()
{
	LONG sum = 0;
	LONG ch;
	LONG neg = FALSE;

l:	ch = rdch();
	if (!('0' <= ch && ch <= '9'))
	{
		switch (ch) {
		case ' ':
		case '\t':
		case '\n':
			goto l;
		case '-':
			neg = TRUE;
			/* fallthru */
		case '+':
			ch = rdch();
			break;
		default:
			UnGetC(input(),-1);	/* equiv to old unrdch */
			setresult2(-1);
			return 0;
		}
	}
	while ('0' <= ch && ch <= '9')
	{
		sum = 10*sum + (ch - '0');
		ch = rdch();
	}

	if (neg)
		sum = -sum;
	UnGetC(input(),-1);			/* equiv to old unrdch */

	setresult2(0);
	return sum;
}

void ASM
newline ()
{
	wrch('\n');
}

void ASM
writed (REG(d1) LONG n,		/* number */
	REG(d2) LONG d)		/* field? */
{
	char t[40];	/* way too big, but what BCPL uses */
	LONG i = 0;
	LONG k = -n;
	LONG j;

	if (n < 0)			/* make sure k is negative */
	{
		d--;
		k = n;
	}

	do {				/* do-while makes sure a 0 prints */
		k      = divrem32(k,10,&j);	/* j is unused in this loop */
		t[i++] = -(j);
	} while (k != 0);

	for (j = i+1; j <= d; j++)
		wrch(' ');
	if (n < 0)
		wrch('-');
	for (j = i-1; j >= 0; j--)
		wrch(t[j]+'0');
}

void ASM
writen (REG(d1) LONG n)
{
	writed(n,0);
}

void ASM
writehex (REG(d1) LONG n,
	  REG(d2) LONG d)
{
	if (d > 1)
		writehex(n >> 4,d-1);
	n &= 0x0f;
	if (n > 9)
		wrch(n + 'A' - 10);
	else
		wrch(n + '0');
}

void ASM
writeoct (REG(d1) LONG n,
	  REG(d2) LONG d)
{
	if (d > 1)
		writeoct(n >> 3,d-1);
	wrch((n & 0x07) + '0');
}

static void __regargs
writesnum (char *s, LONG num)
{
	short i;

	for (i = 0; i < num; i++)
		wrch(s[i]);
}

void ASM
bwrites (REG(d1) BSTR s)
{
	UBYTE *t;

	t = (UBYTE *) BADDR(s);
	writesnum(t+1,*t);
}

void ASM
writes (REG(d1) UBYTE *s)
{
	writesnum(s,strlen(s));
}

/* this is the externally visible one */
/* RETURNS 0 for ok, -1 for error! */

LONG ASM
FPuts (REG(d1) BPTR fh, REG(d2) UBYTE *str)
{
	while (*str)
		if (FPutC(fh,*str++) == ENDSTREAMCH)
			return -1;

	return 0;	/* no error */
}

/* RETURNS 0 for ok, -1 for error! */

LONG ASM
PutStr (REG(d1) UBYTE *str)
{
	return FPuts(output(),str);
}

void ASM
bwritet (REG(d1) BSTR s,
	 REG(d2) LONG n)
{
	LONG i;
	char *str;

	bwrites(s);

	str = (char *) BADDR(s);
	for (i = 1; i <= n - *str; i++)
		wrch(' ');
}

void ASM
writet (REG(d1) LONG s,		/* really char * */
	REG(d2) LONG n)
{
	char *str = (char *) s;
	LONG i,len;

	len = strlen(str);
	writesnum(str,len);

	for (i = 0; i < n - len; i++)
		wrch(' ');
}

void ASM
writeu (REG(d1) ULONG n,
	REG(d2) LONG d)
{
	ULONG m = udiv32(n,10);

	if (m != 0)
	{
		writed(m,d-1);
		d = 1;
	}
	writed ((LONG) (n-(m * (ULONG)10)),d);
}

void ASM
VFWritef (REG(d1) BPTR fh, REG(d2) UBYTE *format, REG(d3) LONG *argv)
{
	BPTR oldfh = output();

	selectoutput(fh);
	bwritef(format,argv,0);
	selectoutput(oldfh);
}

/* WARNING: VARARGS routine! No registerized params! */

void ASM
bwritef (REG(d1) char *format,
	 REG(d2) LONG *t,
	 REG(d3) LONG isbcpl)
{
	LONG k,len;
	char type;

	/* evil: damn BCPL passes '\0's to force output in strings!  */
	/* the global vector stub merely converts the BPTR to a CPTR */

	if (isbcpl)
	{
		len = *format++;
	} else
		len = strlen(format);

	while (len-- > 0)
	{
		k = *format;
		if (k == '%')
		{
			void (* ASM f)(REG(d1) LONG, REG(d2) LONG);
			LONG n,arg;

			n = 0;
			arg = *t;

			format++;
			len--;
			/* toupper */
			type = (*format >= 'a' && *format <= 'z' ?
				*format + ('A' - 'a') : *format);
			switch (type) {
			default:
				wrch(type);
				break;
			case 'S':
				f = (void (* ASM)(REG(d1) LONG,REG(d2) LONG))
				    (isbcpl ? bwrites : writes);
				goto l;
			case 'T':
				f = isbcpl ? bwritet : writet; goto m;
			case 'C':
				f = (void (* ASM)(REG(d1) LONG,REG(d2) LONG))
				    wrch; goto l;
			case 'O':
				f = writeoct; goto m;
			case 'X':
				f = writehex; goto m;
			case 'I':
				f = writed; goto m;
			case 'N':
				f = (void (* ASM)(REG(d1) LONG,REG(d2) LONG))
				    writen; goto l;
			case 'U':
				f = (void (* ASM)(REG(d1) LONG,REG(d2) LONG))
				    writeu; goto m;
m:
				format++;
				len--;
				n = *format;
				n = ('0' <= n && n <= '9' ? n - '0' :
							    n - 'A' + 10);
l:
				(*f)(arg,n);
				/* fall thru */

			case '$':
				t++;	/* next longword */
				/* assumes reasonable stack setup! */
			} /* switch */
		} else 		/* if k == '%' */
			wrch(k);

		format++;	/* len-- is at top */
	} /* while len-- > 0 */
}

/* C version of writef - cstr for format, cstrs for writes and writet */

void __stdargs
writef (format,a)
	char *format;
	LONG a;		/* assumes b,c,d,... are on stack at &a+(N-1) */
{
	bwritef(format,&a,0);
}

/*
// This is a version of i.read for BCPL programmers
// be used by BCPL programs from the CLI
// These must remain UNBUFFERED for BCPL compatibility (argh) REJ
*/

LONG ASM
readbytes (REG(d1) char *v,
	   REG(d2) LONG n)
{
	return read(input(),v,n);
}

LONG ASM
readwords (REG(d1) BPTR v,
	   REG(d2) LONG n)
{
	LONG len;

	len = readbytes((char *) BADDR(v),n << 2);
	return (len > 0 ? len >> 2 : len);
}

/* Buffered external routine */
LONG ASM
FRead (REG(d1) BPTR fh, REG(d2) UBYTE *block, REG(d3) LONG blocklen,
       REG(d4) LONG number)
{
	LONG c,len,num;

	/* FIX!!! should not use single-character buffered reads! */
	num = number;
	while (num > 0)
	{
		len = blocklen;
		while (len-- > 0)
		{
			c = FGetC(fh);
			if (c == ENDSTREAMCH)
				goto eof;
			*block++ = c;
		}
		num--;
	}
eof:
	return number-num;	/* returns actual number of blocks */
}

/*
// This is a version of i.write for BCPL programs
// always be used by BCPL programs from the CLI
*/

LONG ASM
writebytes (REG(d1) char *v,
	    REG(d2) LONG n)
{
	return write(output(),v,n);
}

LONG ASM
writewords (REG(d1) BPTR v,
	    REG(d2) LONG n)
{
	return writebytes((char *) BADDR(v),n << 2);
}

LONG ASM
WriteChars (REG(d1) UBYTE *buffer, REG(d2) LONG buflen)
{
	/* Fix! inefficient (but small) */
	return FWrite(output(),buffer,1,buflen);
}

/* Buffered external routine */
LONG ASM
FWrite (REG(d1) BPTR fh, REG(d2) UBYTE *block, REG(d3) LONG blocklen,
	REG(d4) LONG number)
{
	LONG len,num;

	/* FIX!!! should not use single-character buffered writes! */
	num = number;
	while (num > 0)
	{
		len = blocklen;
		while (len-- > 0)
		{
			if (FPutC(fh,*block++) == ENDSTREAMCH)
				goto write_err;
		}
		num--;
	}
write_err:
	return number-num;	/* returns actual number of blocks written */
}

UBYTE * ASM
FGets (REG(d1) BPTR fh, REG(d2) UBYTE *buf, REG(d3) ULONG len)
{
	UBYTE *save = buf;
	LONG ch;

	/* FIX! set IoErr to 0 */
	/* must be careful to leave space for the null! */
	while (--len)
	{
		ch = FGetC(fh);
		if (ch == ENDSTREAMCH)
		{
			if (buf == save)
				return NULL;
			break;
		}

		*buf++ = ch;

		/* do \n check AFTER adding to buffer */
		if (ch == '\n')
			break;
	}
	*buf = '\0';

	return save;	/* returns buffer or NULL (eof/error) */
}

LONG ASM
VPrintf (REG(d1) UBYTE *fmt, REG(d2) LONG *argv)
{
	return VFPrintf(output(),fmt,argv);
}

LONG ASM
VFPrintf (REG(d1) BPTR fh, REG(d2) UBYTE *fmt, REG(d3) LONG *argv)
{
	LONG args[4];

	args[0] = fh;
	args[1] = 0;	/* number of bytes written */
	args[2] = 0;	/* last character I was asked to write */
	args[3] = 0;	/* error indicator */
	RawDoFmt(fmt,(APTR) argv,(void (*)()) myputch,(APTR) args);

	if (args[3])
		return args[3];	/* return EOF on failure (negative) */

	return args[1]-1;	/* don't count trailing '\0' */
}

LONG ASM
SetVBuf (REG(d1) BPTR fh, REG(d2) UBYTE *buff, REG(d3) LONG type,
	 REG(d4) LONG size)
{
	struct NewFileHandle *scb = BADDR(fh);
	char *old_buff;

/*kprintf("SetVBuf(0x%lx, 0x%lx, %ld, %ld)\n",scb,buff,type,size);*/

	/* for explanation of +8, see kludge info above re: wshell */

	if (type < BUF_LINE || type > BUF_NONE)
	{
		return 1;		/* icky */
	}

	/* set the buffer to a known state */
	Flush(fh);

	/* clear out old mode flags */
	scb->fh_Flags &= ~((1L << BUF_FULL) |
			   (1L << BUF_NONE));

	/* set new mode - default is LINE buffering */
	if (type)
		scb->fh_Flags |= (1L << type);

	/* if size is -1 and buff is NULL only change mode */
	if (size != -1)
	{
		/* make sure it's an extended filehandle!! */
		if (scb->fh_Flags & FHF_EXTEND)
		{
			/* must check for magic value in DupBufPtr */
			if ((scb->fh_Buf == scb->fh_DupBufPtr) ||
			    (scb->fh_Buf == NULL &&
			     scb->fh_DupBufPtr == 0xfedcba98))
			{
				void *foo;

				/* kludge for WShell, etc */
				if (size < SCB_BUFFERSIZE+8)
					size = SCB_BUFFERSIZE+8;

				/* ignore setting to same size */
				if (size == scb->fh_BufSize)
					return 0;

				foo = buff ? buff : AllocVecPub(size);
				if (!foo)
					return buff ? 0 : 1; /* ick */

				/* replace buffer ptr */
				old_buff = BADDR(scb->fh_Buf);
				scb->fh_Buf=scb->fh_DupBufPtr = TOBUFFER(foo);

				/* free the old one if we allocated it */
				if (!(scb->fh_Flags & FHF_USERBUF) && old_buff)
					freeVec(old_buff);

				/* reset the userbuffer flags */
				scb->fh_Flags &= ~FHF_USERBUF;
				if (buff)
					scb->fh_Flags |= FHF_USERBUF;

				/* kludge for WShell, etc */
				scb->fh_BufSize = (size == SCB_BUFFERSIZE+8 ?
						   SCB_BUFFERSIZE : size);

				/* must set functions as buffer is alloced */
				scb->fh_Pos   = 0;
				scb->fh_End   = scb->fh_BufSize;
				scb->fh_Func1 = (LONG) actread;
				scb->fh_Func2 = (LONG) actwrite;
				scb->fh_Func3 = (LONG) actendwrite;

			} else {
				/* Someone yanked it from under me!!! */
				/* he'll probably restore the old ptr */
				/* too bad */
				/* FIX! should I return 0 here? */
				return 1; /* ick */
			}
		} else {
			/* can't change size of non-extended FH's */
			return 1;
		}
	} /* else we only wanted to change mode */

	return 0;	/* ick */
}

/* return the buffer size to use for this filehandle */

LONG __regargs
BufferSize (struct NewFileHandle *scb)
{
	LONG size = SCB_BUFFERSIZE;		/* the default */

	/* make sure it's extended, AND that we set it */
	/* unless all of those are true, use "standard" size */
	if ((scb->fh_Flags & FHF_EXTEND) &&
	    scb->fh_Buf == scb->fh_DupBufPtr)
	{
		size = scb->fh_BufSize;
	}
/*
else kprintf("Buffersize: flags $%lx, buffer $%lx, dupbuffer $%lx, size %ld\n",
scb->fh_Flags,BADDR(scb->fh_Buf),BADDR(scb->fh_DupBufPtr),scb->fh_BufSize);
*/
	return size;
}
@


36.53
log
@SetVBuf needed another fix.
@
text
@d632 1
d634 1
d636 11
a646 2
/*kprintf("closing 0x%lx...",scb);*/
	freeVec(BUFFER(scb));		/* NULL is safe */
d649 2
a650 2
		r = sendpkt1(scb->fh_Type,ACTION_END,scb->fh_Arg1);
		if (r || err_report(REPORT_STREAM,TOBPTR(scb),NULL))
@


36.52
log
@FIxed prototype (innocuous)
@
text
@d1260 2
d1264 1
@


36.51
log
@Make SetVBuf work when called before any buffered IO.  Also don't do
anything if the size is the same as before.
@
text
@d87 1
a87 1
void __regargs
@


36.50
log
@Fixed FGets fencepost error
@
text
@d1234 4
d1244 1
a1244 1
				scb->fh_Buf = scb->fh_DupBufPtr = TOBPTR(foo);
d1258 5
@


36.49
log
@Added some extra ()'s (paranoia about bit-ops)
@
text
@d1145 2
a1146 1
	while (len--)
@


36.48
log
@Fixed bug in SetVBuf with fh's which haven't had buffers added yet
@
text
@d1278 1
a1278 1
	if (scb->fh_Flags & FHF_EXTEND &&
@


36.47
log
@Fixed flush for real (the patch broke an internal call that shouldn't
have been made, but had no effect before).
Made the DupBufPtr work, and made it fairly resistant to junk in
fh_Flags.
@
text
@d1222 4
a1225 1
			if (scb->fh_Buf == scb->fh_DupBufPtr)
@


36.46
log
@Added SetVBuf (and fixed bugs).  Tried to fix flush (doesn't work yet).
Added BufferSize()
@
text
@d96 2
a97 2
/*
if (cis->fh_Func3 == (LONG) actendread)
a101 3
		/* this writes the dirty buffer, if any */
		Flush(TOBPTR(cis));

d108 3
d257 1
d262 1
d268 3
d279 1
a279 1
	if (cos->fh_Func3 == (LONG) actendwrite) {
d286 1
a286 1
	} else if (cos->fh_Func3 == (LONG) actendread) {
a291 5
		goto reset_fh;

// FIX!!!!!!!!!!!!!!!!!!!!!!!!!
// for some reason, this causes shells to wait for <return> on start
//	} else if (cos->fh_Func3 == (LONG) actend) {
d374 1
a374 1
	scb->fh_DupBufPtr = NULL;
d550 1
a550 1
	struct FileHandle *scb;
d580 8
d593 1
a593 1
	struct FileHandle *scb;
d599 1
a599 1
	return (actread(scb));
d657 1
a657 1
	struct FileHandle *scb;
d1196 2
d1280 4
a1283 1

@


36.45
log
@Fixed nasty sign-extension bug with Open (findstream).
Was trashing byte to 0 on Open with path > 128 chars long.
@
text
@d202 1
a202 1
			cos->fh_End = SCB_BUFFERSIZE;
d274 1
a274 2
	if (cos->fh_Func3 == (LONG) actendwrite)
	{
d279 1
a279 1
		 /* FIX!!! should return result of deplete for writes */
a281 1

d287 5
d295 1
a295 2

	} /* else it's something else */
d361 1
a361 1
init_scb (REG(d1) struct FileHandle *scb, REG(d2) ULONG type)
d363 4
a366 1
	scb->fh_Flags = scb->fh_Interactive = scb->fh_Type = 0;
d373 2
a374 2
/*	scb->fh_BufSize = SCB_BUFFERSIZE;*/
/*	scb->fh_DupBufPtr = NULL;*/
d569 1
d600 1
a600 1
	LONG len = SCB_BUFFERSIZE;
d655 1
a655 1
	scb->fh_End   = SCB_BUFFERSIZE;		/* FIX! */
a1180 2
#ifdef SETVBUF

d1183 1
a1183 1
	 REG(d4) ULONG size)
d1185 2
a1186 1
	struct FileHandle *scb = BADDR(fh);
a1189 3
	if (size < SCB_BUFFERSIZE+8)
		return 1;		/* icky backwards error code */

d1206 2
a1207 2
	/* make sure it's an extended filehandle!! */
	if (scb->fh_Flags & FHF_EXTEND)
d1209 2
a1210 1
		if (!buff)
d1214 1
a1214 1
				void *foo = AllocVecPub(size);
d1216 5
d1222 1
a1222 1
					return 1; /* ick */
d1225 1
d1227 13
a1239 1
				freeVec(BADDR(scb->fh_Buf));
d1242 2
d1248 2
a1249 1
			/* FIX!!!!!!!!!!!! ???? */
d1251 1
a1251 1
	}
d1256 17
a1272 1
#endif
@


36.44
log
@Updated FLush to always return true
@
text
@d396 1
a396 1
	char *name,*newname;
d428 2
a429 2
		if (strcmp("*",name+1) == SAME ||
		    mystricmp("CONSOLE:",name+1) == SAME)
d438 1
a438 1
			if (mystricmp("NIL:",name+1) == SAME)
d448 1
a448 1
			dp = getdevproc(name+1,dp);
@


36.43
log
@Added missing ';'
@
text
@d253 1
a253 1
void ASM
d260 1
a260 1
		return;
d269 1
a269 1
			return;
d280 2
d294 2
@


36.42
log
@Fixed close of buffered write fh's - it wasn't closing if the flush
returned an error.
@
text
@d673 1
a673 1
		(void) actwrite(scb)	/* flush output */
@


36.41
log
@WriteChars uses FWrite now (slightly inefficient in time, good in space)
@
text
@d673 3
a675 2
		if (actwrite(scb) < 0)	/* flush output */
			return FALSE;	/* error */
@


36.40
log
@Mjor change to FGetC and UnGetC (and replenish)
Don't return continual EOF after reading an EOF
reading an EOF, ungetc(fh,-1), FGetC will return EOF (once)
Free filehandles on close error
@
text
@d1092 2
a1093 7
	LONG len = buflen;
	BPTR fh = output();

	while (len-- > 0)
		if (FPutC(fh,*buffer++) == ENDSTREAMCH)
			break;
	return buflen;
@


36.39
log
@Added comment
@
text
@d46 1
d52 1
d58 32
d103 1
a103 1
		Flush(fh);
a117 11
	/* stupid old bcpl endcli just sets fh_End to 0, ignoring fh_Pos */
	/* this caused them not to be equal, and it would read -1(null)  */
	/* on EOF, replenish returns EOF, but does NOT set it to always  */
	/* return EOF - it will retry the read on the next attempt.      */
	/* this also improves handling of read errors.			 */

	if (cis->fh_Pos < 0 || cis->fh_Pos >= cis->fh_End)
		return replenish(cis->fh_End,cis);

	/* first call, buffer exhausted or stream exhausted */
	return (LONG) BUFFER(cis)[(cis->fh_Pos)++];
d127 1
d134 2
a135 2
	/* we use fh_Func3 as a "buffer may be dirty" flag */
	/* if it might be dirty, flush it. */
d137 6
a142 2
	/* NIL: leaves funcs == 0 */
	if (cis->fh_Func3 && cis->fh_Func3 != (LONG) actendread)
d144 3
a146 3
/*kprintf("ungetc: switching from write to read, fh = 0x%lx!\n",cis);*/
		/* this writes the dirty buffer, if any */
		Flush(fh);
d148 5
a152 9
		/* If func3 = actend, then this was NOT a write buffer   */
		/* Either it hasn't been touched, and pos/end are -1, or */
		/* it has had a buffer transplant from a shell, in which */
		/* case we do NOT want to call replenish (yet)! 	 */
		if (cis->fh_Func3 != (LONG) actend)
		{
			/* set pos/end for read (forces replenish) */
			cis->fh_Pos = cis->fh_End = -1;
		}
d154 3
a156 3
		/* mark the buffer as a read buffer */
		cis->fh_Func3 = (LONG) actendread;
	}
d158 1
a158 3
/* FIX!?? */
	if (cis->fh_Pos <= 0)
		return (cis->fh_End == 0 ? DOSTRUE : FALSE);
d160 1
a160 1
	p = &(BUFFER(cis)[--(cis->fh_Pos)]);
d266 7
a272 2
	if (cos->fh_Pos < 0)	/* nothing buffered, regardless of type */
		return;
d287 1
a287 1

d311 1
a311 1
		cis->fh_Pos = cis->fh_End = 0;
d313 4
d585 1
d601 1
a601 1
	if (!len)	/* BCPL used to do this always, I dunno why */
d658 1
a658 1
	if (scb->fh_Pos)
d719 5
a723 3
	if (rc)		/* DANGEROUS! FIX! is this safe? */
	{
		fh->fh_Func3 = -1;
a724 3
		freeVec(fh);
		setresult2(res2);
	}
@


36.38
log
@Force more fields to 0 in init_scb just for safety
@
text
@d666 1
a666 1
	LONG res2,rc = DOSTRUE;
@


36.37
log
@FreeVec->freeVec (space saving)
@
text
@d326 1
a326 1
	scb->fh_Flags = 0;
@


36.36
log
@exec_old_pragmas.h
comment change
@
text
@d380 1
a380 1
		FreeVec(scb);
d458 1
a458 1
			    FreeVec(name);
d467 1
a467 1
			    FreeVec(newname);
d489 1
a489 1
	FreeVec(scb);
d492 1
a492 1
	FreeVec(name);
d585 1
a585 1
	FreeVec(BUFFER(scb));		/* NULL is safe */
d691 1
a691 1
		FreeVec(fh);
d1187 1
a1187 1
				FreeVec(BADDR(scb->fh_Buf));
@


36.35
log
@use divrem32
@
text
@d18 1
a18 1
#include <pragmas/exec_pragmas.h>
d660 1
@


36.34
log
@Send Open("*",...) to NIL: if consoletask is NULL, instead of failure.
lattice can now handle d4 as a parameter
@
text
@d762 2
a763 2
		t[i++] = -(rem32(k,10));
		k      = div32(k,10);
@


36.33
log
@Added buffer mode code (mostly turned off), made some other minor changes.
.\
@
text
@d396 2
d399 2
d405 1
a405 1
				/* NIL: works here */
d1016 1
a1016 1
       REG(d0) LONG number)
d1072 1
a1072 1
	REG(d0) LONG number)
d1147 1
a1147 1
	 REG(d0) ULONG size)
@


36.32
log
@Fixed problems with 0-length results from write, buffered IO w/o fh's
@
text
@d15 1
d52 1
a52 1
	cis = (struct FileHandle *) BADDR(fh);
d86 3
d106 1
a106 1
	cis = (struct FileHandle *) BADDR(fh);
d154 1
a154 1
	cos = (struct FileHandle *) BADDR(fh);
d194 1
d211 1
a211 3
/* FIX!!! Buffering! */
	if (ch < ' ' && cos->fh_Port &&		/* scb.id == fh_Port */
	    (ch == '\n' || ch == 0 || ch == '\r' || ch == '\12'))
d213 12
a224 2
		if (!deplete(cos))
			return ENDSTREAMCH;
d226 1
d251 1
a251 1
		deplete(cos);
d284 2
a285 1
		cis->fh_Pos = cis->fh_End = 0;	/* empty buffer */
d326 1
d329 1
a329 1
	scb->fh_Buf = 0;			/* paranoia */
d333 2
d371 1
a371 2
	scb = (struct FileHandle *)
	      AllocVecPubClear(sizeof(struct FileHandle));
d388 1
a388 1
		init_scb(scb,act);
d554 1
a554 1
	LONG len;
d557 6
a562 1
	len = read(TOBPTR(scb),BUFFER(scb),SCB_BUFFERSIZE);
d567 4
a570 4

	scb->fh_Pos = 0;
	scb->fh_End = len;

d666 1
a666 1
	fh = (struct FileHandle *) BADDR(scb);
d1139 58
@


36.31
log
@KLUDGE to fix WShell.  Make sure the buffer has extra bytes on the end. See comments.
@
text
@d52 2
d103 2
d151 2
d223 2
d302 1
a302 1
	return (rc >= 0 ? DOSTRUE : FALSE);
d589 1
a589 1
	return 0;	/* zero bytes written, no error */
d597 1
a597 1
	LONG rc;
d599 7
a605 4
	rc = write(TOBPTR(scb),BUFFER(scb),scb->fh_Pos);
	if (rc > 0)
		scb->fh_Pos = 0;

@


36.30
log
@comment change
@
text
@d488 7
a494 1
		nbuf = AllocVecPub(SCB_BUFFERSIZE);
@


36.29
log
@Make returncode from actwriteinit match those of actwrite, to make errors
work right on first character written (used to eat it).
@
text
@d1055 1
@


36.28
log
@Fixed Arexx problem with buffered input and opening modes (it was opening
input fh's as MODE_NEWFILE).  In the process, made it more robust, especially
with NIL filehandles and UnGetC.
FPutC now returns errors, and the other output routines now check for errors.
@
text
@d289 1
d570 1
a570 1
		return FALSE;
d575 1
a575 1
	return DOSTRUE;
@


36.27
log
@Pubclear, %/ -> rem32 div32 udiv32
@
text
@d55 3
a57 4
	/* assumes buffer is read buffer if not a write buffer! important! */
	/* FIX! Seek to right position? Actually Flush should leave us at */
	/* right spot. */
	if (cis->fh_Func3 == (LONG) actendwrite)
d59 6
a64 1
/*kprintf("switching from write to read, fh = 0x%lx!\n",cis);*/
d68 10
a79 3

		/* set pos/end for read (forces replenish) */
		cis->fh_Pos = cis->fh_End = -1;
d102 24
d139 3
a141 2
/* FIX! return error! */
void ASM
d150 2
a151 2
	/* FIX! seek to right position! */
	if (cos->fh_Func3 == (LONG) actendread)
d153 6
a158 1
/*kprintf("switching from read to write, fh = 0x%lx!\n",cos); */
d162 16
a179 4

		/* set the fh_End to the buffer size (FIX!!!!!) */
		cos->fh_Pos = 0;
		cos->fh_End = SCB_BUFFERSIZE;
d182 1
d186 2
d189 6
a194 1
			return;
d204 2
a205 1
		deplete(cos);
d207 2
d222 1
a222 1
	if (cos->fh_Pos < 0)
d230 3
a232 1
	} else {
d241 2
a242 1
	}
d252 1
d261 1
a261 1
		/* read error or eof */
d268 1
d276 1
a276 1
	LONG res2;
d279 1
d284 2
d287 1
a287 1

d289 2
a290 1
	(*func)(cos);
d293 1
a293 1
	return DOSTRUE;
d307 2
a308 2
	scb->fh_Func3 = (LONG) 
		(type == ACTION_FINDINPUT ? actendread : actendwrite);
d311 1
d341 1
a341 1
/*kprintf("Open(\"%s\"(0x%lx),%ld)\n",string,string,act);*/
d348 1
a486 4
		/* only need to call init once! */
		scb->fh_Func1 = (LONG) actread;
		scb->fh_Func2 = (LONG) actwrite;

d493 5
a536 1
/* Termination.  Free the buffer and inform handler task */
d538 1
a538 1
actendread (scb)
d543 2
a544 1
	FreeVec(BUFFER(scb));
d554 8
d600 1
a600 1
	return actendread(scb);
d633 1
a633 1
	if ((LONG) func == -1)
d651 1
d789 2
a790 1
		FPutC(fh,*str++);	/* FIX! check for error */
d1020 2
a1021 2
		FPutC(fh,*buffer++);

d1039 2
a1040 2
			FPutC(fh,*block++);
			/* FIX! add result to FPutC, check error! */
d1044 2
a1045 1
	return number-num;	/* returns actual number of blocks */
d1084 1
a1084 1
	LONG args[3];
d1089 1
d1092 3
a1097 12
/* called by rawdofmt - which always writes a \0 on the end! */

void ASM
myputch (REG(d0) LONG ch, REG(a3) LONG *args)
{
	/* use a 1-character output buffer so we can avoid writing the null */
	if (args[1]++)
	{
		FPutC(args[0],args[2]);
	}
	args[2] = ch & 0xff;		/* passed in low byte */
}
@


36.26
log
@Fixed buffered read/write switching, flush
@
text
@d7 2
a10 1
#include <devices/timer.h>
d271 1
a271 1
	      AllocVec(sizeof(struct FileHandle),MEMF_PUBLIC|MEMF_CLEAR);
d633 2
a634 2
		t[i++] = -(k%10);
		k      = k/10;
d749 1
a749 1
	ULONG m = n/(ULONG) 10;
@


36.25
log
@Fgets/Fputs are now compatible.  Flush fixes, one backed off (wierd!!!)
@
text
@d60 1
d65 3
d117 1
d122 4
d162 2
a163 1
		/* leaves file positioned correctly */
d169 3
a171 4
/*kprintf("seeking %ld bytes (%ld,%ld)\n",cos->fh_Pos - cos->fh_End,
cos->fh_Pos,cos->fh_End);*/
/*		noflushseek(fh,cos->fh_Pos - cos->fh_End,OFFSET_CURRENT);*/
/*kprintf("back\n");*/
d411 4
a435 2
	scb->fh_Func1 = (LONG) actread;

a487 1
	scb->fh_Func2 = (LONG) actwrite;
@


36.24
log
@minor change to actread
@
text
@d148 1
a148 1
	if (cos->fh_Pos <= 0)
d152 2
d155 11
a165 2
	else
		cos->fh_Pos = 0;
d687 1
d692 2
a693 1
	UBYTE *s = str;
d695 1
a695 4
	while (*s)
		FPutC(fh,*s++);

	return (LONG) (s-str);
d698 2
d894 1
a894 1
	return number-num;
d947 1
a947 1
	return number-num;
d950 1
a950 1
LONG ASM
d960 3
d964 1
d972 1
d974 1
a974 1
	return (LONG) (buf-save);
@


36.23
log
@downcoded rdch/wrch, changed all the regargs I/O rtns to ASM
@
text
@d172 1
d427 4
a430 1
	setresult2(0);
@


36.22
log
@for rcs 4.x header change
@
text
@a43 6
/* FIX! downcode to ASM! */
LONG ASM
rdch ()
{
	return FGetC(input());
}
a98 7
/* FIX! downcode to ASM! */
void ASM
wrch (REG(d1) LONG ch)
{
	FPutC(output(),ch);
}

d591 3
a593 6
/* next few routines are regargs because of lattice.  This is handled for now */
/* in fakeblib.asm.   FIX!!! */

void __regargs			/* needs BCPL wrapper */
writed (LONG n,		/* number */
	LONG d)		/* field? */
d619 2
a620 2
void __regargs			/* needs BCPL wrapper */
writen (LONG n)
d625 3
a627 3
void __regargs			/* needs BCPL wrapper */
writehex (LONG n,
	  LONG d)
d638 3
a640 3
void __regargs			/* needs BCPL wrapper */
writeoct (LONG n,
	  LONG d)
d656 2
a657 2
void __regargs			/* needs BCPL wrapper */
bwrites (BSTR s)
d665 2
a666 2
void __regargs
writes (LONG s)		/* really char * */
d668 1
a668 1
	writesnum((UBYTE *) s,strlen((char *) s));
d690 3
a692 3
void __regargs
bwritet (BSTR s,
	LONG n)
d704 3
a706 3
void __regargs
writet (LONG s,		/* really char * */
	LONG n)
d718 3
a720 3
void __regargs
writeu (ULONG n,
	LONG d)
a731 8
/* FIX! remove this!!! */

void __regargs
bwrch (LONG c)
{
	wrch(c);
}

a765 2
#ifdef WORKINGPROTOS
/* lc 5.02 doesn't allow this to work right - FIX!!!!*/
a766 3
#else
			void __regargs (*f)(LONG, LONG);
#endif
d782 1
a782 1
				f = (void __regargs (*)(LONG,LONG))
d788 2
a789 2
				f = (void __regargs (*)(LONG,LONG))
				    bwrch; goto l;	/* FIX! */
d797 1
a797 1
				f = (void __regargs (*)(LONG,LONG))
d800 1
a800 1
				f = (void __regargs (*)(LONG,LONG))
@


36.21
log
@A bunch of fixes to make "funny" filehandles (from Run, etc) work right.
Moved where fh_Pos is set to 0 to actwrite
@
text
@@


36.20
log
@Deal with the problem of read buffers vs write buffers
Only freevec on close if close succeeds
@
text
@d61 2
d64 2
d68 3
d122 1
d124 2
d128 3
a136 1
		cos->fh_Pos = 0;
a146 1
		cos->fh_Pos = 0;
d161 1
a161 2
	if (cos->fh_Pos <= 0 ||
	    (cos->fh_Func3 == (LONG) actendwrite && !deplete(cos)))
d164 4
a167 1
	cos->fh_Pos = 0;
d178 1
a181 3
	/* mark the buffer as a read buffer (usually redundant) */
	cis->fh_Func3 = (LONG) actendread;

a202 3
	/* mark the buffer as a write buffer (usually redundant) */
	cos->fh_Func3 = (LONG) actendwrite;

d207 1
d222 1
d400 2
a401 2
	nbuf = AllocVecPub(SCB_BUFFERSIZE);
	if (!nbuf)
d403 8
a410 3
		setresult2(ERROR_NO_FREE_STORE);
		return FALSE;
	}
d426 1
d474 1
a474 1
	scb->fh_End   = SCB_BUFFERSIZE;
d485 7
a491 1
	return write(TOBPTR(scb),BUFFER(scb),scb->fh_Pos);
d500 2
a501 1
		actwrite(scb);	/* flush output */
d524 1
a524 1
	LONG /* res2, */ rc = 0;
d531 1
a531 1
	/* res2 = getresult2(); */
d540 1
d543 1
d550 1
a550 1
		/* setresult2(res2); */
d552 2
@


36.19
log
@commented out debugs added
@
text
@d58 6
d75 1
d113 5
d147 5
a151 1
	if (cos->fh_Pos <= 0 || !deplete(cos))
d153 1
d168 3
d174 1
a174 1
		cis->fh_Pos = cis->fh_End = 0;
d192 3
d217 2
d421 1
d428 1
a428 1
	return len > 0;
d477 1
a477 1
	if (scb->fh_Pos > 0)
d501 1
a501 1
	LONG res2,rc = 0;
d508 1
a508 1
	res2 = getresult2();
d512 1
d516 1
d520 3
a522 1
	fh->fh_Func3 = -1;
d524 3
a526 3
	FreeVec(fh);
	setresult2(res2);

@


36.18
log
@getvec->AllocVec, etc
@
text
@d210 2
d223 2
d277 2
d281 1
@


36.17
log
@CON: for * to CONSOLE: for *
@
text
@d15 2
a16 2
#ifdef LATTICE
#include "proto/exec.h"
a18 1
#endif
a22 3
/* sizeof, but returns longs */
#define longsize(x)	((sizeof(x)+3) >> 2)

d223 1
a223 1
	      getmem(longsize(struct FileHandle),MEMF_PUBLIC|MEMF_CLEAR);
d228 1
a228 1
	name = AllocVec(strlen(string)+1+1);
d231 1
a231 1
		freevec(scb);
d294 1
a294 1
			  newname = AllocVec(256);
d302 1
a302 1
			    freevec(name);
d311 1
a311 1
			    freevec(newname);
d333 1
a333 1
	freevec(scb);
d336 1
a336 1
	freevec(name);
d358 1
a358 1
	nbuf = getvec(SCB_BUFFERSIZE/4);	/* longs */
d405 1
a405 1
	freevec(BUFFER(scb));
d487 1
a487 1
	freevec(fh);
@


36.16
log
@Added CON: and a shortcut for "*"
@
text
@d249 1
a249 1
		    mystricmp("CON:",name+1) == SAME)
@


36.15
log
@Fix the stupid problem with EndCli causing FGetC to access address -1.
@
text
@d248 2
a249 1
		if (strcmp("*",name+1) == SAME)
@


36.14
log
@RawDoFmt changes (to eliminate trailing \0's.)
@
text
@d62 4
a65 1
	if (cis->fh_Pos >= cis->fh_End)
d110 3
a112 1
	if (cos->fh_Pos >= cos->fh_End)
a481 1
	/* FIX! should we leave this in for 1.4?  */
@


36.13
log
@Puts->PutStr
@
text
@d929 1
a929 1
	LONG args[2];
d933 1
d936 1
a936 1
	return args[1];
d939 1
a939 1
/* called by rawdofmt */
d944 6
a949 3
	ch &= 0xff;	/* passed in low byte */
	FPutC(args[0],ch);
	args[1]++;
@


36.12
log
@Use AN_FileReclosed instead of hardcode
@
text
@d636 1
a636 1
Puts (REG(d1) UBYTE *str)
@


36.11
log
@Cleanup, use AllocVec, add close-twice alert
@
text
@d479 1
a479 1
		abort(/*AN_CloseTwice*/0x0700000E|AT_DeadEnd);	/* FIX!!! */
@


36.10
log
@Fixed VPrintf, actread
@
text
@d227 1
a227 1
	name = getvec((strlen(string)+1+1+3) >> 2);
d476 5
d484 2
d627 1
a627 1
	LONG len = 0;
d629 2
a630 2
	while (*str)
		FPutC(fh,*str++), len++;
d632 1
a632 1
	return len;
@


36.9
log
@Added Puts, WriteChars, and VPrintf back for John. argh
@
text
@d387 1
a387 1
	len = readbytes(BUFFER(scb),SCB_BUFFERSIZE);
d916 1
a916 1
	return VFPrintf(Output(),fmt,argv);
@


36.8
log
@*** empty log message ***
@
text
@d628 6
d857 12
d911 6
@


36.7
log
@Changed all the visible buffered io calls
to take an FH in their args.  Renamed said routines to Fxxxx, ala
C stdio.
@
text
@d7 2
a8 2
#include "libraries/dos.h"
#include "libraries/dosextens.h"
@


36.6
log
@cleanuo
@
text
@d48 1
a48 1

d52 6
d60 1
a60 1
	cis = (struct FileHandle *) BADDR(input());
d69 2
d72 1
a72 1
unrdch ()
d75 1
d77 1
a77 1
	cis = (struct FileHandle *) BADDR(input());
d79 1
d83 6
a88 1
	cis->fh_Pos--;
d92 1
d96 7
d105 1
a105 1
	cos = (struct FileHandle *) BADDR(output());
d117 1
d127 1
a127 1
flush (REG(d1) BPTR fh)
d507 1
a507 1
			unrdch();
d520 1
a520 1
	unrdch();
d618 1
a618 1
WriteStr (REG(d1) UBYTE *str)
d620 1
a620 1
	LONG len = strlen(str);
d622 2
a623 1
	writesnum(str,len);
d678 10
d714 1
a714 1
			void ASM (*f)(REG(d1) LONG, REG(d2) LONG);
a783 8
/* external version */

void __regargs
Writef (UBYTE *format,LONG *argv)	/* pointer to array of args */
{
	bwritef(format,argv,0);
}

d787 1
d807 25
d851 1
d853 2
a854 1
ReadLn (REG(d1) UBYTE *buf, REG(d2) ULONG len)
d856 20
d881 1
a881 1
		ch = rdch();
d895 2
a896 2
LONG __regargs
BPrintf (UBYTE *fmt, LONG *argv)
d898 1
a898 1
	LONG numwritten = 0;
d900 3
a902 1
	RawDoFmt(fmt,(APTR) argv,(void (*)()) myputch,(APTR) &numwritten);
d904 1
a904 1
	return numwritten;
d910 1
a910 1
myputch (REG(d0) LONG ch, REG(a3) LONG *numwritten)
d913 2
a914 2
	wrch(ch);
	(*numwritten)++;
a915 2


@


36.5
log
@Seperated out init_scb
@
text
@d183 1
d198 1
a198 1
	      getmem(longsize(*scb),MEMF_PUBLIC|MEMF_CLEAR);
d216 1
a216 1
		task = lock = NULL;
d230 1
a231 1

d301 1
a301 1
		dp = NULL;
d699 1
a699 1
				    isbcpl ? bwrites : writes;
@


36.4
log
@Added return code to Close/endstream
@
text
@d160 11
d213 1
a213 6
		scb->fh_Pos = -1;
		scb->fh_End = -1;
		scb->fh_Func1 = (LONG) actreadinit;
		scb->fh_Func2 = (LONG) actwriteinit;
		scb->fh_Func3 = (LONG) 
			(act == ACTION_FINDINPUT ? actendread : actendwrite);
@


36.3
log
@Added soft link support to findstream
@
text
@d435 1
a435 1
	LONG res2;
d446 1
a446 1
		(*func)(fh);
d450 2
@


36.2
log
@Added Writef()
@
text
@d177 1
a177 1
	char *name;
d182 1
a182 1
	LONG rc;
d190 2
a191 1
	name = getvec(((strlen(string)+1)+3) >> 2);
d198 1
d212 1
a212 1
		if (strcmp("*",string) == SAME)
d217 1
a217 1
			if (mystricmp("NIL:",string) == SAME)
d227 1
a227 1
			dp = getdevproc(string,dp);
d247 38
a284 6
		if (getresult2() == ERROR_OBJECT_NOT_FOUND && dp &&
		    act != ACTION_FINDOUTPUT &&
		    (dp->dvp_Flags & DVPF_ASSIGN))
		{
			/* it's a multiple assign - try again */
			continue;
d291 1
@


36.1
log
@*** empty log message ***
@
text
@d705 8
@
