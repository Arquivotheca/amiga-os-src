head     36.33;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @@;


36.33
date     92.12.04.17.34.44;  author jesup;  state Exp;
branches ;
next     36.32;

36.32
date     92.06.02.23.25.18;  author jesup;  state Exp;
branches ;
next     36.31;

36.31
date     91.03.14.22.42.42;  author jesup;  state Exp;
branches ;
next     36.30;

36.30
date     91.03.14.21.37.07;  author jesup;  state Exp;
branches ;
next     36.29;

36.29
date     91.03.11.14.03.04;  author jesup;  state Exp;
branches ;
next     36.28;

36.28
date     91.02.14.21.45.37;  author jesup;  state Exp;
branches ;
next     36.27;

36.27
date     91.02.13.19.08.52;  author jesup;  state Exp;
branches ;
next     36.26;

36.26
date     90.12.03.08.56.05;  author jesup;  state Exp;
branches ;
next     36.25;

36.25
date     90.12.01.19.22.21;  author jesup;  state Exp;
branches ;
next     36.24;

36.24
date     90.12.01.04.07.41;  author jesup;  state Exp;
branches ;
next     36.23;

36.23
date     90.11.21.02.37.29;  author jesup;  state Exp;
branches ;
next     36.22;

36.22
date     90.09.30.20.39.39;  author jesup;  state Exp;
branches ;
next     36.21;

36.21
date     90.09.30.16.04.05;  author jesup;  state Exp;
branches ;
next     36.20;

36.20
date     90.09.25.16.15.05;  author jesup;  state Exp;
branches ;
next     36.19;

36.19
date     90.09.11.21.54.08;  author jesup;  state Exp;
branches ;
next     36.18;

36.18
date     90.07.30.00.09.26;  author jesup;  state Exp;
branches ;
next     36.17;

36.17
date     90.06.13.02.29.02;  author jesup;  state Exp;
branches ;
next     36.16;

36.16
date     90.04.03.05.12.41;  author jesup;  state Exp;
branches ;
next     36.15;

36.15
date     90.04.03.04.45.23;  author jesup;  state Exp;
branches ;
next     36.14;

36.14
date     90.03.20.18.27.20;  author jesup;  state Exp;
branches ;
next     36.13;

36.13
date     90.03.18.00.04.04;  author jesup;  state Exp;
branches ;
next     36.12;

36.12
date     90.03.05.01.13.39;  author jesup;  state Exp;
branches ;
next     36.11;

36.11
date     90.03.03.02.23.58;  author jesup;  state Exp;
branches ;
next     36.10;

36.10
date     90.02.16.22.28.08;  author jesup;  state Exp;
branches ;
next     36.9;

36.9
date     90.02.01.04.31.14;  author jesup;  state Exp;
branches ;
next     36.8;

36.8
date     89.12.16.20.26.21;  author jesup;  state Exp;
branches ;
next     36.7;

36.7
date     89.12.09.02.00.13;  author jesup;  state Exp;
branches ;
next     36.6;

36.6
date     89.12.08.07.27.08;  author jesup;  state Exp;
branches ;
next     36.5;

36.5
date     89.12.05.04.01.31;  author jesup;  state Exp;
branches ;
next     36.4;

36.4
date     89.11.14.01.34.19;  author jesup;  state Exp;
branches ;
next     36.3;

36.3
date     89.10.24.18.35.21;  author jesup;  state Exp;
branches ;
next     36.2;

36.2
date     89.10.18.04.34.08;  author jesup;  state Exp;
branches ;
next     36.1;

36.1
date     89.10.03.18.18.54;  author jesup;  state Exp;
branches ;
next     ;


desc
@Charlie Heath's rdargs code.
@


36.33
log
@Removed broken fix for rda_Buffer.  All must set it on each call now.  Oh well
@
text
@*******************************************************************************
*
* Rdargs.s
*
*	This file contains assembly sources for the functions
* _ReadArgs(),_FreeArgs,_FindArg(), and _ReadItem().
*
*	Also included are BLIB callouts for the BCPL library interface, with
* callouts _blib_rdargs,_blib_rditem,_blib_findarg
*
* Copyright (c) 1989, Microsmiths Inc, Commodore Inc.
* All Rights Reserved.
*
*	History:
*		9/2/89	cdh Initial version based on C version by RJesup
*		9/4/89	cdh Send initial version + test files to rjesup
*		9/15/89 cdh reworked blib versions, etc.  Source to rjesup.
*		9/19/89	cdh Add "ReadArgs()" callout.  Uses blib_rdargs plus...
*		9/22	cdh Use new DOS LVO's.  Fix a couple bugs.
*		9/25	rej modify to link with dos (no LVO usage)
*		10/5	cdh Several intermediate rewrites based on
*			    shifting specs.  Now "complete".
*		10/9	cdh Added multiargs and reallocating buffers.
*		12/3	cdh Fix /N buffer problem.  Add flag bit options,
*			    also switch to full size buffers.
*
*******************************************************************************

	INCLUDE	"exec/types.i"
	INCLUDE	"exec/memory.i"
FUNCDEF     MACRO   * function
_LVO\1	    EQU	    FUNC_CNT
FUNC_CNT    SET     FUNC_CNT-6
            ENDM

FUNC_CNT    SET     LIB_NONSTD
	INCLUDE	"exec/exec_lib.i"
	INCLUDE	"exec/libraries.i"
*	INCLUDE	"dos/dos_lib.i"
	INCLUDE	"dos/dos.i"
	INCLUDE	"dos/rdargs.i"

AbsExecBase	EQU	4

EXECCALL macro
	move.l	AbsExecBase,a6
	jsr	_LVO\1(a6)
	ENDM

EXTR	MACRO
	XREF	\2
_\1	EQU	\2
	ENDM

	EXTR	SetIoErr,@@SetIoErr
	EXTR	Output,@@output
	EXTR	Input,@@input
	XREF	@@mystricmp
	XREF	@@toUpper
	XREF	_Flush
	XREF	_FGetC
	XREF	_UnGetC
	XREF	_VFPrintf
	EXTR	StrToLong,@@Atol

*****************************************************************************
*
* cdh 9/7/89
*	This macro allows use of the new dos.library function calls which
* are not yet available as LVO callouts.
*	The macro will call the ROM functions if they have been defined,
* in libraries/dos_lib.i, or if the functions have not yet been defined
* the macro will call them as xref'ed functions by the name of the function
* preceeded by an underscore.
*
*****************************************************************************
SYSCALL	macro
	IFD	_LVO\1
	ERROR!
*	jsr	_LVO\1(A6)
	ENDC
	IFND	_LVO\1
*	ERROR!!! You must supply _LVO\1
*	xref	_\1
	jsr	_\1
	ENDC
	ENDM

SYSJMP	macro
	IFD	_LVO\1
	ERROR!
*	jmp	_LVO\1(A6)
	ENDC
	IFND	_LVO\1
*	ERROR!!! You must supply _LVO\1
*	xref	_\1
	jmp	_\1
	ENDC
	ENDM

* Equated values used for ASCII ReadChar() comparisons
	IFND	TAB
TAB	set	9		; ASCII Tab character
	ENDIF
	IFND	LF
LF	set	10		; ASCII Linefeed
	ENDIF
	IFND	ENDSTREAMCH
ENDSTREAMCH	set	-1
	ENDIF

	xdef	_blib_rdargs,_ReadArgs,_FreeArgs
	xdef	_blib_rditem,_ReadItem
	xdef	_blib_findarg,_FindArg
	xdef	Toupper

**********************************************************************
* Internal representation of the template is an initialized
* BYTE array with the folowing bit definitions
*
* Aaray is a table of / keys used for parsing the template
*
* Note the usage with /F including ARG_TYPEF_KEYWORD as well
* as ARG_TYPEF_REST
**********************************************************************

	BITDEF	ARG_TYPE,REQUIRED,0	; /A
	BITDEF	ARG_TYPE,KEYWORD,1	; /K
	BITDEF	ARG_TYPE,SWITCH,2	; /S
	BITDEF	ARG_TYPE,NUMBER,3	; /N(umber)
	BITDEF	ARG_TYPE,REST,4		; /F(est of line)
	BITDEF	ARG_TYPE,TOGGLE,5	; /T(oggle On/Off)
	BITDEF	ARG_TYPE,MULTI,6	; /M (was /...)
	BITDEF	ARG_TYPE,DONE,7		; Already specified (internal)

Aaray:	dc.b	ARG_TYPEF_REQUIRED,'A'
	dc.b	ARG_TYPEF_KEYWORD,'K'
	dc.b	ARG_TYPEF_SWITCH,'S'
	dc.b	ARG_TYPEF_NUMBER,'N'
	dc.b	ARG_TYPEF_REST,'F'	; +ARG_TYPEF_KEYWORD
	dc.b	ARG_TYPEF_TOGGLE,'T'
	dc.b	ARG_TYPEF_MULTI,'.'
	dc.b	ARG_TYPEF_MULTI,'M'
	dc.b	0,0

* internal-only flags for RDA_Flags - note: avoid collisions with ARP
	BITDEF	RDA,PROMPT_SHOWN,30
* flag to know if we allocated the RDA_Buffer pointer
	BITDEF	RDA,OURBUFFER,29
* mask of internal flags
RDA_INTERNAL_FLAGS	EQU	RDAF_PROMPT_SHOWN!RDAF_OURBUFFER

* Ammount of stack space needed by ReadArgs for temp processing
RA_STACK	equ	MAX_TEMPLATE_ITEMS+4*MAX_MULTIARGS+4

* Buffer size used for allocating string buffer space
VECSIZE		equ	128


**********************************************************************
* Shared register equates for ReadArgs() and blib_rdargs
**********************************************************************

A_Keys		equr	A2	; Pointer to template
A_W		equr	A3	; Pointer to buffer for parsed results
A_Argv		equr	A4	; User's Argv array 

; D2 is a general-purpose "scratch" register, used for calling args etc.
D_IsBCPL	equr	D3

D_Multi		equr	D4	; Multiarg index
D_Size		equr	D5	; Highest_address+1 for A_W buffer.
D_Numbargs	equr	D6	; word sized variable
D_Argno		equr	D7	; word sized variable

; This is a special register equate for the template byte image array
; It could be switched to another address register, if stack usage
; in ReadArgs() changes.  BEWARE THAT SP IS CURRENTLY USED AS
; THIS BASE ADDRESS THROUGHOUT READARGS!!!!
AA_Argimage	equr	SP

**********************************************************************
* FreeArgs( RDA_struct )
*
*	Frees all allocations associated with this RDA struct.
* Currently this is just a linked list of AllocVec allocations
* in the RDA_DAList slot of the struct, but the function call is
* the documented interface, not the data structure.
**********************************************************************
_FreeArgs:
	movem.l	A2/A6,-(sp)
	tst.l	D1
	 beq.s	2$		; Nothing to free.
	move.l	D1,A0

	; used to try to clear only for our buffer.  Broke that and got it
	; backwards.  Now we say you must reset rda_buffer for each and
	; every call.  Argh.
	clr.l	RDA_Buffer(A0)	; we set RDA_Buffer internally

	;-- in case it gets reused, unset our flag bits
	and.l	#RDA_INTERNAL_FLAGS,RDA_Flags(a0)	; careful of address

	move.l	RDA_DAList(A0),A2
	clr.l	RDA_DAList(A0)	; so you can call FreeArgs again safely...

1$:	move.l	A2,A1		; arg for freevec
	move.l	A2,d0		; check for done
	 beq.s	2$
	move.l	(A2),A2		; Get next link
	EXECCALL FreeVec	; a1
	bra.s	1$

2$:	movem.l	(sp)+,A2/A6
	rts


**********************************************************************
* Internal callouts used for allocating buffer space for ReadArgs()
**********************************************************************
GetVec:
	move.l	A6,-(sp)
	move.l	d1,d0
	move.l	#MEMF_PUBLIC+MEMF_CLEAR,D1
	EXECCALL AllocVec	; d0,d1
	move.l	(sp)+,A6
	rts

*
* Note: DAList requires the first longword to be the ptr to the next entry!
*
GimmeAVec:
	move.l	D_IsBCPL,A0		; struct RDArg
	moveq.l	#RDAF_NOALLOC,D0	; if NOALLOC, never allocate more space
	and.l	RDA_Flags(A0),D0
	 bne.s	2$
	addq.l	#4,D1			; add a pointer for linking
	bsr.s	GetVec
	tst.l	D0			; did the alloc succeed?
	 beq.s	2$
	move.l	D0,A0
	move.l	D_IsBCPL,A1		; RDArg
	move.l	RDA_DAList(A1),(A0)	; add to head of list
	move.l	A0,RDA_DAList(A1)
	addq.l	#4,D0			; return ptr to rest of memory
	rts

2$:	moveq.l	#0,D0
	rts

**********************************************************************
* ReadArgs()
*
* See functional spec for documentation.
*
* This entry point sets up the registers and allocations used by
* the shared ReadArgs/blib_rdargs code, and transfers control to
* the shared code.
*
**********************************************************************
_ReadArgs:
	movem.l	D2-D7/A2-A5,-(sp)
	sub.w	#RA_STACK+4,sp		; word gets bumped to long on addrs
					; +4 is for result of RdItem!
	move.l	D1,A_Keys		; template
	move.l	D2,A_Argv		; buffer for destination

	moveq.l	#0,D_Multi		; Initialize "multiarg" index.
					; FIX! + 4 for random safety!
	moveq	#(VECSIZE+4)/2,d1	; for use later
	asl.l	#1,d1			; smaller than move.l

* Check to see if application has provided an optional input
* data structure.  If not, allocate one and initialize it.
	tst.l	D_IsBCPL		; input parameter - struct RDArgs (D3)
	 beq.s	AllocRDArg		; Use specified optional struct.

	move.l	D_IsBCPL,A0		; struct RDArg
	clr.l	RDA_DAList(A0)		; For safety, initialize to NULL.
	tst.l	RDA_Buffer(A0)		; did user supply the buffer?
	 bne.s	have_buffer

	; we must allocate the buffer - d1 has VECSIZE in it
	; Note: GimmeAVec allocates and links into RDA_DAList
	bsr.s	GimmeAVec		; be careful NOT to deallocate the RDArg
	move.l	D_IsBCPL,a0		; get ptr back
	move.l	d0,RDA_Buffer(a0)	; did we succeed?
	 beq	ra_errmem
	bra.s	set_buffer		; common code - set buffer size
	
* Allocate the RDA struct, plus some initial buffer space.
* The allocation is made such that allocations will be
* multiples of VECSIZE bytes for minimal fragmentation.
AllocRDArg:
	moveq	#RDA_SIZEOF+4,d0	; + 4 for the DAList.Next ptr
	add.l	d0,d1			; d1 = RDA_SIZEOF + VECSIZE + 4
	bsr.s	GetVec			; can't use GimmeAVec
	move.l	D0,D_IsBCPL
	 beq	ra_errmem		; Bomb out error

* This moves the ptr past the DAList next ptr
	addq.l	#4,D_IsBCPL		; Advance past hook
	move.l	D_IsBCPL,A0
	lea	RDA_SIZEOF(A0),A1	; Initialize the buffer.
	move.l	A1,RDA_Buffer(A0)
	move.l	D0,RDA_DAList(A0)	; Must track this allocation.

set_buffer:				; common code, see above - careful
					; note: smaller than amount actually
					; allocated! FIX!
; no longer needed - see freeargs
;	bset.b	#RDAB_OURBUFFER-24,RDA_Flags(a0) ; remember we allocated it
	move.l	#VECSIZE,RDA_BufSiz(A0)	; (was wierd)

have_buffer:				; comes here if buffer exists or after
	move.l	RDA_Buffer(A0),A_W	; it's allocated
	move.l	A_W,D_Size
	add.l	RDA_BufSiz(A0),D_Size

	move.l	A_Keys,A0
	bsr	strlen
	bsr.s	ra_initkeys		; Initialize the ARGV image array
	 bne	ra_error		; Bad template! Oh shazbad!

	bra	RA_Merge

***********************************************************************
*
* error = ra_initkeys( A_Keys, D0=strlen(A_Keys) )
*
* This internal subroutine is called by both the blib and the DOS
* versions of ReadArgs() to initialize the byte array of key specifiers
* corresponding to the ARGV template items.
*
* The initialized array is on the stack, starting at 4(sp).
*
* Byte values are initialized to the ARG_TYPE specifiers defined above.
*
* Register "D_Numbargs" is initialized to the number of args present.
*
* The return value, if positive, is an IoErr() return code.
*
***********************************************************************
ra_initkeys:
	movem.l	D3/A_Keys/A3,-(sp)
	lea	16(sp),A3		; Byte array to initialize
	move.l	D0,D2			; Calling arg, template length
	moveq	#0,D_Numbargs
	move.l	#0,D3			; Multi flag.

* Loop here on key values
1$:	addq.w	#1,D_Numbargs

	clr.b	(A3)+
	cmp.w	#MAX_TEMPLATE_ITEMS,D_Numbargs	; FIX? should be long?
	 ble.s	2$
	moveq.l	#ERROR_LINE_TOO_LONG,D2		; not real descriptive
	bra.s	ra_rts				; Overflow!!!!!!!!!

2$:	subq.l	#1,D2
	 blt.s	ra_ki_end

	move.b	(A_Keys)+,D0
	cmp.b	#'/',D0
	 bne.s	10$		; Scan for any slash at end of keyword

	move.b	(A_Keys)+,D0
	subq.l	#1,D2
	bsr	Toupper

	lea	Aaray,A0	; a 2 byte/entry table - flag and character
3$:	move.w	(A0)+,D1	; get both
	 beq.s	10$
	cmp.b	D0,D1		; compare character
	 bne.s	3$
	lsr.w	#8,D1		; get flags from upper byte
	or.b	D1,-1(A3)
	btst.b	#ARG_TYPEB_MULTI,D1
	 beq.s	10$
	bset.b	#0,D3
	 beq.s	10$

	move.l	#ERROR_BAD_TEMPLATE,d2	; we don't allow more than 1 /m!
	bra.s	ra_rts

10$:	cmp.b	#',',D0		; Check for end of keyword ","
	 bne.s	2$		; if not, normal loop point
	bra.s	1$		; End of this keyword, initialize for next

ra_ki_end:
	moveq.l	#0,D2
ra_rts:	movem.l	(sp)+,D3/A_Keys/A3
	rts

**********************************************************************
* status = blib_rdargs( UBYTE *keys, LONG *argv, LONG size )
*   D0   = 			D1          D2        D3
*
* Parses the input command line, which is in the buffered BCPL input
* stream, with the ADOS keyword template "keys", putting the resulting
* parsed keyword values into buffer "argv".  argv buffer is also used
* as the destination for parsed strings, with total length of the
* buffer specified by "size", in BYTES.  This buffer should be long
* enough to allow a longword for each template item, plus string
* storage space for the entire input command string parsed into
* arguments.
*
* The return value of blib_rdargs is ZERO on failure, or a pointer
* to the first free space in "argv" which was not allocated.
*
* This code is shared with the dos.library "ReadArgs()" callout.
*
* Must clear argv array, since BCPL expects it! - REJ
**********************************************************************
_blib_rdargs:
	movem.l	D2-D7/A2-A5,-(sp)
	sub.w	#RA_STACK+4,sp		; .w gets extended to .l

	move.l	D1,A_Keys		; note: BSTR!
	move.l	D2,A_Argv
	move.l	D3,D_Size

	add.l	A_Argv,D_Size		; Needs highest addr, not 
					; length, of the buffer
	moveq.l	#0,D_IsBCPL
	moveq.l	#0,D_Multi		; Initialize "multiarg" index.

	moveq.l	#0,D0			; Initialize the shared Argv
	move.b	(A_Keys)+,D0
	bsr	ra_initkeys		; doesn't assume cstr
	subq.l	#1,A_Keys		; Need to restore for findarg

	move.l	A_Argv,A_W		; Clear ARGV for blib
	move.w	D_Numbargs,D0
3$:	clr.l	(A_W)+
	 dbra	D0,3$

**********************************************************************
* ReadArgs merge point
*
* Here, the argv array is initialized and D_Numbargs is set to the
* number of arguments present in the template.  Loop on input items,
* with a case switch based on RdItem case return values.
*
**********************************************************************
RA_Merge:
ra_Loop:
*
* Semantics of /F: it MUST be the last argument in the template.
* /F is filled when either all previous arguments are filled (..._DONE),
* OR when the first unrecognized item is read.  NOTE that if it has been
* read using rditem, the quotes must be restored, unless they used
* Foo="sdkjfkdjf", where Foo is the /F argument.  Argh.
*
* This also means ? will work right.
*

ra_NormalLoop:
	moveq.l	#-1,D_Argno

* NOTE - SPACE AVAILABLE IN A_W ARRAY IS NOW CALCULATED AS NEEDED.
* This is to allow working with re-allocatable buffers.
* A_W is the working address of the current buffer, D_Size is the
* upper bound.  The function "MyRdItem" sets up the value of "MaxBytes"
* for use in the shared code of the "ReadItem" call.

	bsr	MyRditem	; Sets up needed parameters
	move.l	d0,RA_STACK(sp)	; save result of rditem on stack
				; NOTE! MyRditem modifies d2!!!!!!
	 bne	ra_NotDone

* Case 0, end of input stream
* Scan through the Argv byte-image array to make sure there were no
* unspecified "/A" keywords.
*
* NOTE - clearing unused Arvv items is not needed here now since
* ReadArgs() is speced to need an initialized array.  For BCPL,
* the array has been cleared in the setup code.

* Note use of A_Argv and A_Keys registers here!  (D2 is scratch)

	move.l	AA_Argimage,A_Keys
1$:	subq.w	#1,D_Numbargs
	 blt.s	5$

	moveq	#0,D2			; use D2 as flag for /M/N
	btst.b	#ARG_TYPEB_MULTI,(A_Keys)
	 beq.s	2$

**********************************************************************
* Process the MULTIARG array for return.
* The array must be cloned into allocated buffer space from the
* stack; the buffer is either allocated in existing string
* buffer space after longword allignment, if there is enough room,
* or a new vector is allocated.
**********************************************************************
	move.l	D_Multi,(A_Argv)
	 beq.s	2$		; No args to copy, done!

* See if there is space in the buffer for the array
	addq.l	#3,A_W		; Long allign A_W, first
	move.l	A_W,D0
	lsr.l	#2,D0
	asl.l	#2,D0
	move.l	D0,A_W		; rounds up to next longword
				; leave in d0 for 4$ if we go there

	move.l	D_Multi,D1	; 4x the number of multi-items
	addq.l	#4,D1		; Here's how much space we need (1LW for NULL)

; Note that we're zapping D_Size permanently here, since this is the
; last time it will be used.
	sub.l	A_W,D_Size	; Here's how much space we've got.
	sub.l	D1,D_Size	; Is there enough space for 
	 bhs.s	4$		; Have enough space

	bsr	GimmeAVec	; Need to allocate. Size is in D1
				; gets memory, links into dalist.
				; doesn't touch d2

; d0 either has A_W or the result of GimmeAVec
4$:	move.l	D0,(A_Argv)	; Store the multiarg pointer in the current slot
	 beq.s	ra_errmem	; No memory, punt error!

; Copy over the temporary MultiArg array from the stack into
; the buffered allocation space
	move.l	D0,A1
	move.l	D_Multi,D0	; don't kill D_Multi, so I can test it (REJ)
	lea	MAX_TEMPLATE_ITEMS(AA_Argimage),A0 ; array on stack
3$:	move.l	A1,D_Size	; save the last argument of a multi (REJ)
				; should REALLY use another register! FIX! REJ
	move.l	(A0)+,(A1)+
	subq.l	#4,D0		; was D_Multi (REJ)
	 bgt.s	3$
	clr.l	(A1)		; Array needs null terminator

	;-- handle /M/N, make sure D2 is right
	btst.b	#ARG_TYPEB_NUMBER,(A_Keys)	; check for /M/N
	sne	D2		; set D2 != 0 if this is a /M/N

**********************************************************************
* Finish up processing for this returned slot, check for missing
* /A arguments, and loop on Argv slots.
**********************************************************************
2$:	addq.l	#4,A_Argv
	move.b	(A_Keys)+,D0	; here this is AA_Argimage, current entry
	 bmi.s	1$
	btst.b	#ARG_TYPEB_REQUIRED,D0
	 beq.s	1$

; Unspecified key value ... if bit zero
; is set, it was a "/A" key, thus error

; If there was a multi-arg, AND there are at least two items in the multiarg,
; THEN move the last item from the multiarg to this one.  Ugly, has some holes.
; (mainly when the person specifies the Multi arg explicitely)  -REJ
; (also only works if /M is before /A) - REJ
;
; Don't do this if arg is /K/A, since keyword is required
; Don't do it if the multiarg was  /M/N (?FIX?)

	btst.b	#ARG_TYPEB_KEYWORD,d0	; begin REJ code
	 bne.s	6$

	moveq	#8,D0
	cmp.l	D0,D_Multi		; enough items in /M?
	 blt.s	6$

	tst.l	D2			; was it a /M/N?
	 bne.s	6$			; yes, don't steal

; now steal the last one - D_Size holds a pointer to the last multiarg entry
	move.l	D_Size,A0		; pointer to last non-null multi
	subq.l	#4,D_Size		; move back one, in case of 2+ /A's
	subq.l	#4,D_Multi		; one less multiarg available
	move.l	(A0),-4(A_Argv)		; we already incremented dest-register
	clr.l	(A0)			; remove from multi-arg array
	bra.s	1$			; end REJ code

6$:
	; a real error
	moveq.l	#ERROR_REQUIRED_ARG_MISSING,D2
	bra.s	ra_error

**********************************************************************
* Done processing the output Argv array.  Get outa here, closing
* the door on the way out.
**********************************************************************
5$:	bsr	CS_ReadChar	; we don't care if we're at EOF here
	move.l	D_IsBCPL,D0
	 bne.s	rdargs_rts
	move.l	A_W,D0		; Finish up - clear the EOL character,
	bra.s	rdargs_rts	; and return the Argv buffer pointer

**********************************************************************
* Check for other ReadItem() case values here.
* Good values here are QUOTED or UNQUOTED returns from ReadItem().
**********************************************************************
ra_NotDone:
	subq.l	#1,D0
	 beq.s	ra_case1	; Case 1 is an UNQuoted argument
	subq.l	#1,D0
	 beq	ra_case2	; Case 2 is a Unquoted argument

**********************************************************************
* ReadArgs() error returns
*
* ra_error is ReadArgs error exit.  D2 is value for IoErr()
* Here handle all errors in rdargs.
*
**********************************************************************
ra_err1:
	moveq.l	#ERROR_LINE_TOO_LONG,D2	; For IoErr()
	bra.s	ra_error
ra_err_noarg:
	moveq.l	#ERROR_KEY_NEEDS_ARG,D2
	bra.s	ra_error
ra_errmem:
	moveq.l	#ERROR_NO_FREE_STORE,D2
ra_error:
	bsr	CS_ReadChar	; First, scan to end of line
	cmp.b	#LF,D0		; discarding unused input.
	 beq.s	1$
	cmp.b	#';',D0
	 beq.s	1$
	tst.l	d0		; eof is (LONG) -1
	 bpl.s	ra_error

* Next, if there is anything allocated, it must be freed.
1$:	move.l	D_IsBCPL,D1
	 beq.s	2$
	bsr	_FreeArgs

2$:	move.l	D2,D1		; Set error condition code
	SYSCALL	SetIoErr	; (Error_Line_Too_Long)
	moveq.l	#0,D0		; Return NULL for error
rdargs_rts:
	add	#RA_STACK+4,sp
	movem.l	(sp)+,D2-D7/A2-A5
	rts

**********************************************************************
* Case 1, normal item with no quotes.  These items are handled like
* quoted arguments, except first they are checked to see if they
* are KEYWORD values.
**********************************************************************
ra_case1:
	move.l	A_Keys,D1
	move.l	A_W,D2
	bsr	MyFindArg
	move.w	D0,D_Argno	; Save the Argv #
	 blt	check_qmark	; No match

; It _is_ a keyword (D_Argno has index).
; Get argument type to for any special handling
; Note - numbers are just strings, at this point, no special handling.
; LEAVE D0 ALONE NOW - it is used as Argno << 2 for SWITCH case.

	move.b	0(AA_Argimage,D_Argno.w),D1
	btst.b	#ARG_TYPEB_SWITCH,D1
	 bne.s	arg_is_switch	; Switch, Go For It.

	btst.b	#ARG_TYPEB_REST,D1
	 beq.s	string_follows	; Check for "Rest Of Line Whooser!!!"

*
* Someone specified a /F keyword (foo="bar xyzzy").  Note that any quotes
* remain! FIX!
*
*** HERE, READ IN A /F ARGUMENT, reading everything to end-of-line.

ra_DoRestOfLine:
	moveq	#0,D2

ra_SlashF_loop:
	;-- Loop reading all chars until EOF or newline, and put into
	;-- a single string for /F argument.
	;-- D2 has current size of string read in, A_W has ptr to string storage

	;-- check if the buffer is full
	move.l	D_Size,D0		; end of buffer + 1
	sub.l	A_W,D0			; minus current buffer ptr
	sub.l	D2,D0			; minus number of chars added so far
	 bgt.s	ra_SlashF_DoChar	; ok to add a character

	;-- out of mem in string buffer, expand it
	bsr	NewBuffer		; returns cc's!!
	 beq	ra_errmem

	moveq.l	#0,D0			; NOTE! Newbuffer returns old A_W in A0!
33$:	move.b	(A0)+,0(A_W,D0.l)	; copy over old string buffer into new
	addq.l	#1,D0
	cmp.l	D0,D2
	 bgt.s	33$

ra_SlashF_DoChar:
	;-- Read a char and process it

	bsr	CS_ReadChar
	tst.l	D0
	 bmi.s	ra_SlashF_done		; really an EOF test - REJ
	cmp.b	#LF,D0
	 beq.s	ra_SlashF_done
	move.b	D0,0(A_W,d2.l)		; store char in buffer
	addq.l	#1,D2			; bump # of characters added to buffer
	bra.s	ra_SlashF_loop		; and get another one.

ra_SlashF_done:
	;-- don't strip spaces if it was quoted
	;-- note that if the keyword was specified, it NEVER looks quoted
	;-- so it always strips
	moveq	#ITEM_QUOTED,d0
	cmp.l	RA_STACK(sp),d0
	beq.s	no_space

	;-- we may need to remove a final ' ' from the string, if we got
	;-- here via ra_DoSlashF and there are no other arguments.
strip_loop:
	move.b	-1(A_W,D2.l),d0
	cmp.b	#' ',d0
	beq.s	is_space
	cmp.b	#$09,d0			; tab
	bne.s	no_space
is_space:
	subq.l	#1,d2
	bgt.s	strip_loop		; if d2 <= 0, no space left(????)

no_space:
	clr.b	0(A_W,D2.l)		; null-terminate
	bra	not_qmark		; unreads the LF/EOF for us
					; then goes to ra_storearg
					; then back to ra_Loop, and next time
					; rditem should return 0.
*
* Comes here from ra_case2.  We found an item (not keyword), and a slash-f
* item is the next to be filled.  grab item, put in buffer, then grab the
* rest of the line.
*
* D_Argno is set correctly.
*
* requote  it if there were quotes, add space otherwise
* There's no simple solution to the *N, **, etc problems.
*
ra_DoSlashF:
	move.l	A_W,a0		; A_W points to first char of argument
	bsr	strlen		; get length of argument
	move.l	d0,d2		; used as offset to current end of string
				; can't be empty
	moveq	#ITEM_QUOTED,d0
	cmp.l	RA_STACK(sp),d0
	beq.s	ra_SlashF_loop	; don't add space, don't strip spaces

	moveq	#' ',d0		; safe because it overwrites the \0.
	move.b	d0,0(A_W,d2.l)	; follow first arg by a space (oh well) FIX!
	addq.l	#1,d2		; count the space
	bra.s	ra_SlashF_loop	; go grab rest of line, starting by checking
				; if the space requires us to expand the
				; buffer.

***** "/S" keyword comes through to arg_is_switch
arg_is_switch:
	;-- can't use ra_SetFlag, since it skips the next string
	asl.w	#2,D_Argno	; Switch value, no arg required.
	moveq.l	#-1,D1
	move.l	D1,0(A_Argv,D_Argno.w)
	bra	ra_Loop

**********************************************************************
* Keyword expecting a following string parameter.
**********************************************************************
string_follows:
	bsr	MyRditem	; NOTE!!! Modifies D2!!!!!!!
	cmp	#-2,D0		; Word check is sufficient here.
	 bne.s	2$		; Check for "=" parameter,
	bsr	MyRditem	; if so read another parameter
				; NOTE!!! Modifies D2!!!!!!!
2$:	tst.l	D0		; Make sure the parameter is valid
	 beq	ra_err_noarg	; keyword needs =
	 blt	ra_err1		; line too long
	bra.s	ra_case2	; Continue with CASE 2 code


**********************************************************************
* Argument was not a template keyword.  Check to see if it was
* "?", and the last thing on the command line... if so, reprompt and
* continue parsing with new line of input.
*
* Note that arguments already parsed remain!
**********************************************************************
check_qmark:
	bsr	CS_ReadChar
	tst.l	d0
	 bmi.s	ra_case2	; EOF (don't unread the char)
	cmp.b	#LF,D0
	 bne.s	not_qmark	; Wasn't end of line, no reprompt

	tst.l	D_IsBCPL
	 bne.s	10$
	cmp.w	#$013f,(A_W)	; 01, '?'
	 bne.s	not_qmark		; Parameter not "?"

	lea	bcolonstr,A0	; Need to re-prompt.  Here is the 
	move.l	A_Keys,D1	; BCPL prompt string, for displaying
	lsr.l	#2,D1		; template
	bra.s	30$

10$:	cmp.b	#'?',(A_W)	; Check C string for "?"
	 bne.s	not_qmark
	tst.b	1(A_W)
	 bne.s	not_qmark

	;-- check "should we prompt" flag in structure
	move.l	D_IsBCPL,A1	; rdargs struct
	btst.b	#RDAB_NOPROMPT,RDA_Flags+3(a1)	; careful! btst of mem!
	 bne.s	not_qmark

	lea	colonstr,A0	; C string for displaying template

	move.l	A_Keys,D1	; first time, use template

	;-- careful of bit numbers and offsets!!!
	bset.b	#RDAB_PROMPT_SHOWN-24,RDA_Flags(a1)
	beq.s	30$

	move.l	RDA_ExtHelp(A1),D1
	 bne.s	30$		; Use extended help string instead!
	move.l	A_Keys,D1	; no extended string, re-show template

30$:	movem.l	d1-d3,-(sp)	; a0 has format, d1 has template
	move.l	sp,d3		; pointer to args (D1 is the only arg)
	move.l	a0,d2		; format string
	SYSCALL	Output		; get output filehandle (careful of regs)
	move.l	d0,d1
	SYSCALL	VFPrintf	; Display the template
	movem.l	(sp)+,d1-d3	; restore regs/cleanup stack

	SYSCALL	Output
	move.l	D0,D1
	SYSCALL	Flush		; Flush output (buffered).
	bra	ra_Loop

not_qmark:	bsr	CS_UnReadChar	; Restore the last-read character!

**********************************************************************
* CASE 2 - this is the case for quoted strings, which don't get
* checked for keywords etc as with CASE 1.
* Note that values checked in CASE 1 will fall through to the
* code for CASE 2 after checking for keywords, etc.
*
* The CASE 2 code handles bookeeping for the argv[] array
* and string allocation space.
*
**********************************************************************
ra_case2:
	tst.w	D_Argno
	 bge.s	ra_storearg	; See if the keyword slot is known.

	;-- D_Argno must be -1.w here
	move.l	sp,A0		; Was not a keyword - put it in next free.
1$:	addq.w	#1,D_Argno	; Loop through all Argv key slots.
	moveq.l	#ERROR_TOO_MANY_ARGS,D2
	cmp.w	D_Numbargs,D_Argno
	 bge	ra_error	; All slots are filled.  Error!

	btst.b	#ARG_TYPEB_MULTI,(A0)
	 bne.s	ra_storearg	; Continue to fill the MultiArg?

	move.b	(A0)+,D1
	 bmi.s	1$		; Already filled slot

	btst.b	#ARG_TYPEB_REST,D1
	 bne	ra_DoSlashF	; is there a /F argument out there?
				; if so, read rest of line and store

	btst.b	#ARG_TYPEB_KEYWORD,D1
	 bne.s	1$		; no keyword speced, ignore it

	and.b	#ARG_TYPEF_TOGGLE+ARG_TYPEF_SWITCH,D1	;+ARG_TYPEF_REST REJ
	 bne.s	1$		; No autofill here.

* Auto-fill all other slot types.

**********************************************************************
* Here, D_Argno is set to the desired slot to fill with current arg.
**********************************************************************
ra_storearg:
	;-- d0 must get the value BEFORE the bset of typeb_done!
	move.b	0(AA_Argimage,D_Argno.w),D0
	bset.b	#ARG_TYPEB_DONE,0(AA_Argimage,D_Argno.w)
	asl.w	#2,D_Argno

	tst.l	D_IsBCPL
	 bne.s	ra_StoreNotBcpl

* Handle blib_rdargs storage here.
	move.l	A_W,D1
	lsr.l	#2,D1		; Set D1 to BPTR to string
	move.l	D1,0(A_Argv,D_Argno.w)

	move.b	(A_W),D0	; get value to add to A_W in D0
	and.w	#$00fc,D0
	addq.w	#4,D0
	add.w	D0,A_W		; Common code to store arg and bump A_W
	bra	ra_Loop		; Loop to next keyword.

**********************************************************************
* DOS ReadArgs() storage here.
*
* First check for "/N", "/T", or "/..." slot types for special
* handling.
**********************************************************************

* Subroutine for errors
ra_BadNum:
	moveq.l	#ERROR_BAD_NUMBER,D2	; common bad number code
	bra	ra_error

* Entrypoint....
ra_StoreNotBcpl:
	btst	#ARG_TYPEB_MULTI,D0	; /M and /N depend on d0 being set
	 bne.s	ra_StoreMulti

	;-- see if someone has already specified this argument
	;-- multiargs gets hit N times
	btst	#ARG_TYPEB_DONE,D0
	 beq.s	ra_NotSpeced

	;-- if it's a switch, allow it to be specified multiple times
	btst	#ARG_TYPEB_SWITCH,D0
	 bne.s	ra_NotSpeced

	;-- it was specified already - error out
	move.l	#ERROR_TOO_MANY_ARGS,d2
	bra	ra_error

ra_NotSpeced:
	btst	#ARG_TYPEB_TOGGLE,D0
	 bne	ra_Toggle
	btst	#ARG_TYPEB_NUMBER,D0
	 beq	ra_Vanilla		; No special type, just store.

***** Process a "/N" argument ... 
ra_Number:
	move.l	d0,-(sp)		; save flags for this template entry
	clr.l	-(sp)			; space for number on stack
	move.l	sp,D2
	move.l	A_W,D1
	SYSCALL	StrToLong
	move.l	(sp)+,D1		; number
	move.l	(sp)+,D2		; flags for template (only free reg)
	tst.l	D0
	 ble.s	ra_BadNum		; no chars or error

	;-- make sure all characters were used to by StrToLong...
	move.l	d0,a1			; strlen doesn't touch d1 OR a1!!!!!
	move.l	A_W,a0
	bsr	strlen			; returns len in d0
	cmp.l	a1,d0
	 bne.s	ra_BadNum		; not all chars were digits!

	move.l	A_W,D0			; Longword-align the A_W buffer ptr
	addq.l	#3,D0
	and.l	#$fffffffc,D0
	move.l	D0,A_W
	move.l	D_Size,D0
	sub.l	A_W,D0			; We now have the # of bytes available.
	subq.l	#4,D0			; Is there space for a longword in the
	 bge.s	5$			; buffer?

	bsr	NewBuffer		; returns cc's!!
	  beq	ra_errmem

5$:	;-- have number, now store it, update stuff, and loop
	move.l	D1,(A_W)		; store number in buffer space
	btst	#ARG_TYPEB_MULTI,d2	; is this a /M/N template entry?
	beq.s	10$			; no

	;-- /M/N add to array, then loop 
	lea	MAX_TEMPLATE_ITEMS(AA_Argimage),A0
	move.l	A_W,0(A0,D_Multi.w)	; set /m array entry to point to it
	addq.l	#4,D_Multi
	bra.s	20$			; goto common number_done code

10$:	;-- regular /n
	move.l	A_W,0(A_Argv,D_Argno.w)	; set template entry to point to it
	;-- fall thru
20$:
	addq.l	#4,A_W
	bra.s	ra_Next			; loop

***** Store current string in MULTIARG array.
***** it's on the stack, after the template array of chars
ra_StoreMulti:
	cmp.l	#4*(MAX_MULTIARGS-1),D_Multi
	 bge	ra_err1			; Too many multiargs. Generic.
	btst	#ARG_TYPEB_NUMBER,d0	; still set from above!  Handle /M/N
	 bne.s	ra_Number		; it has code for handling multiargs

	;-- string multiarg - add ptr to array, then skip string and loop
	lea	MAX_TEMPLATE_ITEMS(AA_Argimage),A0
	move.l	A_W,0(A0,D_Multi.w)
	addq.l	#4,D_Multi
	bra.s	ra_SkipString

***** Process a TOGGLE key
***** "/T" keyword comes through to arg_is_toggle
ra_Toggle:				; Handle "Toggle" key
	;-- I decided 0/1 was silly for it to accept
*	lea	one(pc),a0		; Accepts "1/0/Y/N/ON/OFf"
*	bsr.s	ra_compstr		; compare string!
*	 beq.s	ra_SetFlag		; must make sure that's all!
*	lea	zero(pc),a0
*	bsr.s	ra_compstr		; returns with cc's set!
*	 beq.s	ra_ClearFlag

	;-- d2 is offset in array to string...
	moveq	#(yes-Toggle_Table),d2	; Yes
	bsr.s	ra_compstr
	 beq.s	ra_SetFlag
	addq.l	#(no-yes),d2		; No
	bsr.s	ra_compstr
	 beq.s	ra_ClearFlag
	addq.l	#(on-no),d2		; on
	bsr.s	ra_compstr
	 beq.s	ra_SetFlag
	addq.l	#(off-on),d2		; off
	bsr.s	ra_compstr
	 bne	ra_err_noarg		; no argument or bad one: error
	;-- fall through

ra_ClearFlag:
	moveq	#0,d0
	;-- fall through
store_result:
	move.l	d0,0(A_Argv,D_Argno.w)

* Continue here when storing string-type arguments, advancing the
* buffer space pointer to the next free space.

ra_SkipString:
	move.l	A_W,A0
	bsr	strlen
	add.l	D0,A_W
	addq.l	#1,A_W		; Add this len to A_W for next free
ra_Next:
	bra	ra_Loop		; Loop to next keyword.

ra_compstr:
	move.l	A_W,a1			; compare word against A_W
	lea	Toggle_Table(pc,d2.w),a0	; 8 bit displacement
	bsr	@@mystricmp
	tst.l	d0			; return cc's set!
	rts

***** Vanilla keyword.
ra_Vanilla:
	move.l	A_W,d0
	bra.s	store_result
ra_SetFlag:
	moveq.l	#-1,D0
	bra.s	store_result


Toggle_Table:
*one:	dc.b	'1',0
*zero:	dc.b	'0',0
yes:	dc.b	'yes',0
no:	dc.b	'no',0
on:	dc.b	'on',0
off:	dc.b	'off',0
	ds.w	0		; align

*****************************************************************************
*
* status = FindArg( char *template, char *kwrd )
*   D0			     D1		   D2
*
* Searches *template to see if keyword *kwrd is in the template.
* If it is, the argument # is returned, otherwise -1 is returned.
*
*****************************************************************************

A_kwrd		equr	A2
A_template	equr	A3

D_klen		equr	D2
D_wp		equr	D3
D_wlen		equr	D4
D_fargno	equr	D5


* MyFindArg is internal entry point for ReadArgs/rdargs
MyFindArg:
	tst.l	D_IsBCPL
	 bne.s	_FindArg

* _blib_FindArg is the BCPL entry point for "findarg".
* Enter here with APTR to BSTR "keys" in D1,
*		  APTR to BSTR "w" in D2

_blib_findarg:
	movem.l	D2-D5/A2/A3,-(sp)

	move.l	D1,A_template
	move.l	D2,A_kwrd

	moveq.l	#0,D_wlen
	move.b	(A_kwrd)+,D_wlen
	moveq.l	#0,D_klen
	move.b	(A_template)+,D_klen	; D_klen is only used for BCPL
	addq	#1,D_klen
	bra.s	findarg_common

* _FindArg is the dos.library entry point, as defined above
_FindArg:
	movem.l	D2-D5/A2/A3,-(sp)

	move.l	D1,A_template
	move.l	D2,A_kwrd

	move.l	A_kwrd,A0
	bsr	strlen
	move.l	D0,D_wlen		; Need length of keyword

	moveq	#-1,D_klen		; This length is ignored for Cstr

findarg_common:
	moveq.l	#0,D_fargno

* Reset to start of keyword string
findarg_reset:
	moveq.l	#0,D_wp

* Loop here through the template string, looking for a match against
* the keyword string.
* FIX! might be more efficient to keep lengths around, and use strnicmp!
findarg_loop:
	move.b	(A_template)+,D0	; Get next template character
	 beq.s	findarg_tempend		; end of template, go check for match
	subq	#1,D_klen		; Check for BCPL end of template string
	 beq.s	findarg_tempend		; May be a match, go see

	cmp.b	#',',D0
	 beq.s	findarg_check
	cmp.b	#'=',D0			; Check for separators in the
	 beq.s	findarg_check		; template string.
	cmp.b	#'/',D0
	 beq.s	findarg_check

	bsr	Toupper		; Check for match of template char
	move.b	D0,-(sp)
	move.b	0(A_kwrd,D_wp),D0
	bsr	Toupper
	addq.l	#1,D_wp
	cmp.b	(sp)+,D0
	 beq.s	findarg_loop		; Loop while matching

* No match on this template item.
* Loop here skipping in template string until the next template
* keyword begins.  This is different than the BCPL implementation
* which used a "MATCHING/SKIPPING" state variable.
findarg_skip:
	move.b	(A_template)+,D0	; Get next template char, loop
	 beq.s	findarg_notfound	; End of C-template
	subq	#1,D_klen
	 beq.s	findarg_notfound	; Got to end of template, no match.

* Entry point for findarg_skip with char already in D0
findarg_skip_char:
	cmp.b	#'=',D0
	 beq.s	1$
	cmp.b	#',',D0
	 bne.s	findarg_skip

	addq.l	#1,D_fargno		; Bump to next "ArgNo"
1$:	bra.s	findarg_reset		; and reset loop for next try

*
* Reached separator character in key.
* If at end of keyword, match, else enter skip loop.
*
* NOTE: usage of D_wp does NOT guarantee a BCPL key won't scan past
*	the end of keyword "w", but DOES guarantee correct return value.
*	With C strings, the character comparison will ensure termination
*	at end of "w".
*
findarg_check:
	cmp	D_wp,D_wlen
	 beq.s	findarg_argno
	bra.s	findarg_skip_char

* Reached end of template.
* If at end of keyword, match, else return "no match".
* See note above on D_wp
findarg_tempend:
	cmp	D_wp,D_wlen
	 beq.s	findarg_argno

findarg_notfound:
	moveq.l	#-1,D_fargno
findarg_argno:
	move.l	D_fargno,D0
	movem.l	(sp)+,D2-D5/A2/A3
	rts

*****************************************************************************
* status =  ReadItem(UBYTE *commandname, LONG maxchars, struct CSource *CSource)
*   D0		                D1		D2	      D3
*
*	Reads the next item from the input stream, into the buffer
* commandname which is limited to maxchars bytes in length.  The
* resulting string is saved as a BSTR if isbcpl, else is a CSTR.  If the
* string is in quotes, it is parsed for escape sequences.
*
*	Return values are as follows:
*		-2	"=" Symbol was the first character!
*		-1	error
*		0	*N, ;, endstreamch before anything else
*		1    unquoted item
*		2    quoted item
*
* NOTE - the BLIB calling spec is for "maxlongs" instead of "maxchars"
* bytes allowed.  The interface code which massages parameters is
* specified to shift "maxlongs" such that it represents "maxchars".
*
* MyRditem is used by rdargs(), to set up A_W in D1.
*	D3 is already in place (CSource == isbcpl).  MODIFIES D2!!!!
*
*****************************************************************************

A_CommandName	equr	A2

; A_W (A3) is used internally!

D_Maxchars	equr	D2	; Calling arg position
D_CSource	equr	D3	; Calling arg position
D_Inquote	equr	D4

; D_Size (D5) is used internally!

D_Flag		equr	D6	; Internal flag for call from ReadArgs.
D_Currpos	equr	D7

; D_Flag values -1 for BCPL, 0 for ReadItem(), 1 for internal ReadArgs()
; MyRditem modifies D2!!!

MyRditem:
	move.l	D_Size,D_Maxchars
	sub.l	A_W,D_Maxchars	; Calculate space available.
	subq.l	#1,D_Maxchars	; allocate space for null
	 bge.s	not_full	; make sure we have space for the null!

	;-- No space for null byte, allocate bigger buffer
	tst.l	D_IsBCPL	; if BCPL, don't allocate new buffer
	 beq.s	rditem_buf_fail
	bsr	NewBuffer
	 bne.s	MyRditem	; will recalc D_Maxchars, and continue

	;-- failure, return -1 (no regs to restore)
rditem_buf_fail:
	moveq.l	#-1,d0
	rts
	
not_full:
	move.l	A_W,D1

	tst.l	D_IsBCPL
	 beq.s	_blib_rditem

	movem.l	D2-D4/D6/D7/A2,-(sp)
	moveq.l	#1,D_Flag
	bra.s	rditem_merge

_blib_rditem:
	movem.l	D2-D4/D6/D7/A2,-(sp)

	subq.l	#1,D_Maxchars	; Lopp off a char for null termination
	moveq.l	#-1,D_CSource	; Special BCPL entry condition
	moveq.l	#-1,D_Flag
	bra.s	rditem_merge

_ReadItem:
	movem.l	D2-D4/D6/D7/A2,-(sp)
	moveq.l	#0,D_Flag

rditem_merge:
	;-- code above guarantees space for the null byte in blib_rditem and
	;-- in MyRditem.  _ReadItem MUST have a buffersize of 1 or more!

	move.l	D1,A_CommandName
	clr.b	(A_CommandName)	; Null string for starters.

	moveq.l	#0,D_Currpos

1$:	bsr	CS_ReadChar	; Skip leading spaces and tabs
	cmp.b	#' ',D0
	 beq.s	1$
	cmp.b	#TAB,D0
	 beq.s	1$		; EOF and LF fall through to rditem_enter

	moveq	#0,D_Inquote	; Initialize "inquote" status
	cmp.b	#'"',D0
	 bne.s	rditem_enter	; Skip ReadChar (already in d0)
	move.b	D0,D_Inquote	; Set value of Inquote to '"'

* Loop here on input characters
rditem_loop:
	bsr	CS_ReadChar

rditem_enter:
	cmp.b	#LF,D0
	 beq	rditem_endloop
	tst.l	D0		; EOF
	 bmi	rditem_endloop

	tst.w	D_Inquote	; Switch on quotes
	 beq.s	10$		; if in quotes, ignore *e, *n

	cmp.b	D_Inquote,D0	; A quote - is this the end?
	 beq	rditem_quoted

	cmp.b	#'*',D0		; Check for escape string processing
	 bne.s	20$

	bsr	CS_ReadChar	; Process escapes based on next char
	tst.l	d0		; EOF inside a quote
	 bmi	rditem_endloop
	cmp.b	#LF,d0		; end-of-line inside quote
	 beq.s	rditem_endloop	; was bmi for no apparent reason, fixed it.
	cmp.b	#'e',D0		
	 beq.s	2$
	cmp.b	#'E',D0		; (E)scape
	 beq.s	2$

	cmp.b	#'n',D0
	 beq.s	3$
	cmp.b	#'N',D0		; (N)ewline
	 bne.s	20$		

3$:	moveq	#LF,D0
	bra.s	20$
2$:	moveq	#$1B,D0
;	bra.s	20$		; Branch not needed

* Not quoted - check for terminator characters
10$:	cmp.b	#';',D0
	 beq.s	rditem_endloop
	cmp.b	#' ',D0
	 beq.s	rdil1
	cmp.b	#TAB,D0
	 beq.s	rdil1
	cmp.b	#'=',D0
	 bne.s	20$

*** Do all of '=' character handling here, special case moved
*** from terminal processing
	tst.l	D_Currpos
	 bne.s	rdil1			; = was not first char in loop

	moveq.l	#-2,D0			; Special exit value
	bra.s	rditem_rts		; WITH NO UnReadChar!

* Save this character in the commandname buffer, if there is room
20$:	addq.l	#1,D_Currpos

	cmp.l	D_Maxchars,D_Currpos
	 blt.s	21$
	tst.w	D_Flag			; fail if BCPL or ReadItem()
	 ble.s	rditem_fail

**** INTERNAL CODE FOR USE WITH READARGS BUFFER REALLOCATIONS
* Note that register D0 has the next character to insert!

	bsr	NewBuffer
	 beq.s	rditem_fail

	move.l	A_W,A_CommandName
	move.l	D_Currpos,D1
24$:	subq.l	#1,D1
	 ble.s	25$
	move.b	(A0)+,(A_CommandName)+	; NOTE! NewBuffer returns old A_W in A0!
	bra.s	24$
25$:	move.l	D_Size,D_Maxchars
	sub.l	A_W,D_Maxchars

***** END INTERNAL CODE

21$:	tst.w	D_Flag			; Check for "BCPL"
	 blt.s	22$
	move.b	D0,(A_CommandName)+	; Store C-string
	clr.b	(A_CommandName)
23$:	bra	rditem_loop

22$:	move.b	D0,0(A_CommandName,D_Currpos)	; Store BSTR
	clr.b	1(A_CommandName,D_Currpos)
	move.b	D_Currpos,(A_CommandName)
	bra.s	23$

rdil1:	tst.w	D_Flag			; Don't unread TAB or SPACE
	 bpl.s	rdil2			; UNLESS bcpl.

; End of while loop
; NOTE: d0 has character returned from ReadChar!!!
rditem_endloop:
	;-- These are commented out, so it will unread EOF, and thus force
	;-- the shell when it calls FGetC after ReadItem to get the actual
	;-- reason ReadItem returned (aka EOF).
*	tst.l	d0
*	 bmi.s	rdil2		; don't unread on EOF!
	bsr.s	CS_UnReadChar	; Put back char.  Might make conditional.

rdil2:	tst.w	D_Inquote
	 bne.s	rditem_fail		; Unterminated quote

	move.l	D_Currpos,D0
	 beq.s	rditem_rts		; Return zero if no chars read
	moveq.l	#1,D0
	bra.s	rditem_rts		; Read something

rditem_quoted:
	moveq.l	#2,D0
	bra.s	rditem_rts
rditem_fail:
	moveq.l	#-1,D0
rditem_rts:
	movem.l	(sp)+,D2-D4/D6/D7/A2
	rts

**************************************************************************
*
* CS_ReadChar, CS_UnReadChar functions are internal functions
* which read either from the CSource, or from ReadChar/UnReadChar.
*
CS_ReadChar:
	move.l	D_CSource,D0
	 beq.s	1$
	addq.l	#1,D0
	 beq.s	1$

	move.l	D_CSource,A0
	move.l	CS_Buffer(A0),D0
	 beq.s	1$

	move.l	D0,A1
	move.l	CS_CurChr(A0),D1
	cmp.l	CS_Length(A0),D1
	 bge.s	2$
	addq.l	#1,CS_CurChr(A0)
	moveq.l	#0,D0
	move.b	0(A1,D1.l),D0
	rts

2$:	moveq.l	#ENDSTREAMCH,D0
	rts

1$:	SYSCALL	Input			; get input filehandle REJ
	move.l	d0,d1
	SYSCALL	FGetC
	rts

CS_UnReadChar:
	move.l	D_CSource,D0
	 beq.s	1$
	addq.l	#1,D0
	 beq.s	1$

	move.l	D_CSource,A0
	move.l	CS_Buffer(A0),D0
	 beq.s	1$

	tst.l	CS_CurChr(A0)
	 ble.s	2$
	subq.l	#1,CS_CurChr(A0)
*	moveq.l	#-1,D0
2$:	rts

*2$:	moveq.l	#0,D0		; Return status not used internally
*	rts

1$:	SYSCALL	Input			; get input filehandle REJ
	move.l	d0,d1			; fh
	move.l	d2,-(a7)		; save reg, might be live REJ
	moveq	#-1,d2			; restore last character read
	SYSCALL	UnGetC
	move.l	(a7)+,d2		; restore - returns character unread
	rts

*****************************************************************************
* NewBuffer()
*
* Internal subroutine allocates a new A_W buffer which is a rounded
* multiple of 256 bytes larger than the current A_W/D_Size buffer.
*
* Register D0 is preserved (normally it is a character to store)
*
* Registers A_W and D_Size are set to newly allocated values. Note
* that this is done internal to ReadItem(), which is a different
* register context than ReadArgs(), but the internal callout does not
* use these two registers.
*
* Returns with Z flag set indicating status - Z means FAILED TO ALLOCATE.
*
* Returns with original A_W in A0, for copying over old contents.
*
*****************************************************************************

NewBuffer:
	movem.l	D0/D1,-(sp)

	move.l	D_Size,D1
	sub.l	A_W,D1

	add	#VECSIZE+16,D1
	and.l	#-VECSIZE,D1
	subq.l	#8,D1
	move.l	D1,D_Size
	addq.l	#4,d1		; KLUDGE!! Force buffer to have extra bytes!
				; FIX!!!!!
	bsr	GimmeAVec
	tst.l	D0
	 beq.s	1$

	move.l	A_W,A0			; Original start address
	move.l	D0,A_W
	add.l	A_W,D_Size

1$:	movem.l	(sp)+,D0/D1
	rts


*****************************************************************************
********	Following function(s) might be LVO calls	*************
*****************************************************************************

* Don't touch d1/a1!

strlen:	moveq.l	#-1,D0
1$:	addq.l	#1,D0
	tst.b	(A0)+
	 bne.s	1$
	rts


***************************************
* convert character in d0 to upper case.
* do not change any other registers
* Not base register dependant
***************************************
Toupper:
	movem.l	d1/a0-a1,-(sp)
	bsr	@@toUpper
	movem.l (sp)+,d1/a0-a1
	rts

*****************************************************************************

bcolonstr:
	dc.b	'%b: ',0

colonstr:
	dc.b	'%s: ',0

@


36.32
log
@Fixed the RDA_Buffer thing (we clear it on FreeArgs if we allocate it)
@
text
@d196 3
a198 2
	btst.b	#RDAB_OURBUFFER-24,RDA_Flags(a0)
	 bne.s	10$
d200 1
a200 1
10$
d311 2
a312 1
	bset.b	#RDAB_OURBUFFER-24,RDA_Flags(a0) ; remember we allocated it
@


36.31
log
@Added space stripping only for non-quoted args
Accept tabs
@
text
@d148 4
d159 1
d196 4
d201 1
a201 1
	bclr.b	#RDAB_PROMPT_SHOWN-24,RDA_Flags(a0)	; careful of address
d310 1
@


36.30
log
@Strip all trailing space from a /F
@
text
@d253 2
a254 1
	sub.w	#RA_STACK,sp		; word gets bumped to long on addrs
d405 1
a405 1
	sub.w	#RA_STACK,sp		; .w gets extended to .l
d456 2
a457 1
	tst.l	D0		; NOTE! MyRditem modifies d2!!!!!!
d626 1
a626 1
	add	#RA_STACK,sp
d679 1
a679 1
33$:	move.b	(A0)+,0(A_W,D0.w)	; copy over old string buffer into new
d697 7
d706 5
a710 1
	cmp.b	#' ',-1(A_W,D2)
d712 1
d714 1
a714 1
	bgt.s	ra_SlashF_done		; if d2 <= 0, no space left(????)
d717 1
a717 1
	clr.b	0(A_W,D2)		; null-terminate
d729 2
a730 2
* FIX!  check return from myrditem to find if we should re-quote it(?!!!)
* There's no solution to the *N, **, etc problems.
d736 5
d1206 1
a1206 1
*		0	*N, ;, endstreamch
@


36.29
log
@Fixed /k problems
@
text
@d700 2
@


36.28
log
@Various minor changes, plus fixes to toggle
@
text
@d843 1
a843 1
	 bne	ra_err1
@


36.27
log
@added comments
@
text
@d601 3
d744 3
a746 4
2$:	moveq.l	#ERROR_KEY_NEEDS_ARG,D2
	tst.l	D0		; Make sure the parameter is valid
	 beq	ra_error
	 blt	ra_err1
d846 1
a846 1
	 bne	1$		; No autofill here.
d854 1
d879 7
d888 1
a888 1
	 bne	ra_StoreMulti
a957 4
ra_BadNum:
	moveq.l	#ERROR_BAD_NUMBER,D2	; common bad number code
	bra	ra_error

d973 1
d975 10
a984 7
	lea	one(pc),a0		; Accepts "1/0/Y/N/ON/OFf"
	bsr.s	ra_compstr		; compare string!
	 beq.s	ra_SetFlag		; must make sure that's all!
	lea	zero(pc),a0
	bsr.s	ra_compstr		; returns with cc's set!
	 beq.s	ra_ClearFlag
	lea	yes(pc),a0
d987 1
a987 1
	lea	no(pc),a0
d990 1
a990 1
	lea	on(pc),a0
d993 1
a993 1
	lea	off(pc),a0
d995 1
a995 4
	 beq.s	ra_ClearFlag
	;-- none of the above: toggle value
	tst.l	0(A_Argv,D_Argno.w)
	 beq.s	ra_SetFlag
d999 4
a1002 13
	clr.l	0(A_Argv,D_Argno.w)
	bra.s	ra_SkipString		; ignore rest of argument

ra_compstr:
	move.l	A_W,a1			; compare word against A_W
	bsr	@@mystricmp
	tst.l	d0			; return cc's set!
	rts

ra_SetFlag:
	moveq.l	#-1,D1
	move.l	D1,0(A_Argv,D_Argno.w)
	bra.s	ra_SkipString		; ignore rest of argument
a1003 4
***** Vanilla keyword.
ra_Vanilla:
	move.l	A_W,0(A_Argv,D_Argno.w)

d1015 19
a1033 2
one:	dc.b	'1',0
zero:	dc.b	'0',0
d1183 1
a1183 1
*		-2	"=" Symbol
@


36.26
log
@Fixed /T
@
text
@d1359 1
d1361 6
a1366 1
	bsr.s	CS_UnReadChar	       ; Put back char.  Might make conditional.
@


36.25
log
@disallow multiple /M's again, move clear of d2 into loop
use utility.lib Toupper
@
text
@d58 1
d726 5
a730 2
	asl.w	#2,D_Argno
	bra	ra_SetFlag	; Switch value, no arg required.
d967 9
a975 4
ra_Toggle:
	move.b	(A_W),D0		; Handle "Toggle" key
	bsr	Toupper
	cmp.b	#'1',D0			; Accepts "1/0/Y/N/ON/OFf"
d977 2
a978 1
	cmp.b	#'0',D0
d980 2
a981 1
	cmp.b	#'Y',D0
d983 2
a984 1
	cmp.b	#'N',D0
d986 2
a987 5
	cmp.b	#'O',D0
	 bne	ra_err1
	move.b	1(A_W),D0
	bsr	Toupper
	cmp.b	#'N',D0
d989 1
a989 2
	cmp.b	#'F',D0
	 bne	ra_err1
d993 1
a993 1
	bra.s	ra_Next
d995 6
d1004 1
a1004 1
	bra.s	ra_Next
d1021 7
a1028 4




d1092 1
@


36.24
log
@Made /m/n work (it didn't even try to before)
Regularized D_Argno and D_Numbargs size usage to .w
added a few more .w's that were missing
added comments
Added check for double-specification of args, EXCEPT for switches.
Fixed FreeArgs, badly broken
No longer diallows multiple /M's  (maybe it should!)
@
text
@d58 1
d114 1
d311 1
a311 1
	bra.s	RA_Merge
d331 1
a331 1
	movem.l	A_Keys/A3,-(sp)
d335 1
d364 4
d369 2
a370 1
	;-- used to disallow multiple /M's here
d378 1
a378 1
ra_rts:	movem.l	(sp)+,A_Keys/A3
a466 1
	moveq	#0,D2			; use D2 as flag for /M/N
d471 1
d504 1
d1482 3
a1484 6
	and.l	#$0ff,D0
	cmp.b	#'a'-1,d0
	bls.s	2$
	cmp.b	#'z',d0
	bhi.s	1$
	sub.b	#'a'-'A',d0
a1485 4
1$:	cmp.b	#$df,D0
	bls.s	2$
	sub.b	#$40,D0
2$:	rts
@


36.23
log
@Change so FreeArgs can be called safely after an error
@
text
@d143 3
d165 2
a166 2
D_Numbargs	equr	D6
D_Argno		equr	D7
d186 1
a186 3
	move.l	D1,A2
	move.l	RDA_DAList(A2),A2
	clr.l	RDA_DAList(A2)	; so you can call FreeArgs again safely...
d188 6
d309 1
a309 1
	bra	RA_Merge
d329 1
a329 1
	movem.l	D3/A_Keys/A3,-(sp)
d332 1
a332 2
	moveq.l	#0,D_Numbargs
	move.l	#0,D3			; Multi flag.
d335 1
a335 1
1$:	addq.l	#1,D_Numbargs
d339 3
a341 1
	 bgt.s	9$		; Overflow!!!!!!!!!
a360 4
	btst.b	#ARG_TYPEB_MULTI,D1
	 beq.s	10$
	bset.b	#0,D3
	 beq.s	10$
d362 1
a362 2
9$:	moveq.l	#ERROR_LINE_TOO_LONG,D2
	bra.s	ra_rts
d370 1
a370 1
ra_rts:	movem.l	(sp)+,D3/A_Keys/A3
d397 1
a397 1
	move.l	D1,A_Keys
d408 1
a408 1
	bsr	ra_initkeys
d412 1
a412 1
	move.l	D_Numbargs,D0
d447 1
a447 1
	 bne.s	ra_NotDone
d457 3
a459 1
* Note use of A_Argv and A_Keys registers here!
d461 1
a461 1
1$:	subq.l	#1,D_Numbargs
d513 4
d522 1
a522 1
	move.b	(A2)+,D0
d536 2
d545 3
d624 1
a624 1
	move.l	D0,D_Argno	; Save the Argv #
d632 1
a632 1
	move.b	0(AA_Argimage,D_Argno),D1
d716 1
a716 1
	asl.l	#2,D_Argno
d750 1
a750 1
	 bne.s	21$
d757 1
a757 1
	bra.s	22$
d759 1
a759 1
21$:	cmp.b	#'?',(A_W)	; Check C string for "?"
d765 1
a765 1
	move.l	D_IsBCPL,A1
d771 6
d778 2
a779 2
	 bne.s	22$		; Use extended help string instead!
	move.l	A_Keys,D1
d781 1
a781 1
22$:	movem.l	d1-d3,-(sp)	; a0 has format, d1 has template
d810 1
a810 1
	;-- D_Argno must be -1 here
d812 1
a812 1
1$:	addq.l	#1,D_Argno	; Loop through all Argv key slots.
d814 1
a814 1
	cmp.l	D_Numbargs,D_Argno
d841 1
a841 1
	asl.l	#2,D_Argno
d849 1
a849 1
	move.l	D1,0(A_Argv,D_Argno.l)
d852 3
a854 3
	and	#$00fc,D0
	addq.l	#4,D0
	add	D0,A_W		; Common code to store arg and bump A_W
d864 17
a880 2
	btst	#ARG_TYPEB_MULTI,D0
	 bne.s	ra_StoreMulti
d882 1
a882 1
	 bne.s	ra_Toggle
d887 3
a889 1
	clr.l	-(sp)
d894 1
a894 1
	moveq.l	#ERROR_BAD_NUMBER,D2
d896 1
a896 1
	 ble	ra_error		; no chars or error
d903 1
a903 1
	 bne	ra_error		; not all chars were digits!
d917 15
a931 2
5$:	move.l	D1,(A_W)
	move.l	A_W,0(A_Argv,D_Argno.l)
d935 4
d944 4
d985 1
a985 1
	move.l	A_W,0(A_Argv,D_Argno.l)
d1258 1
a1258 1
	 bmi.s	rditem_endloop
@


36.22
log
@Added some comments, added 4 bytes to all allocations of buffers for safety
@
text
@d185 1
@


36.21
log
@Added many comments, fixed MyRditem call when the buffer is already full
@
text
@d247 2
a248 1
	moveq	#VECSIZE/2,d1		; for use later
d287 2
d471 1
a471 1
* See if there is space on stackframe.
d476 2
a477 1
	move.l	D0,A_W
d479 2
a480 2
	move.l	D_Multi,D1
	addq.l	#4,D1		; Here's how much space we need.
d489 1
d491 2
a492 1
4$:	move.l	D0,(A_Argv)	; Store the multiarg pontter
d499 1
a499 1
	lea	MAX_TEMPLATE_ITEMS(AA_Argimage),A0
d648 1
a648 1
	moveq.l	#0,D0
d885 1
d1251 1
a1251 1
	move.b	(A0)+,(A_CommandName)+
d1381 2
@


36.20
log
@Fix join <nil: ?, run join ?  (added eof check)
Fix RDA_Buffer = NULL and DAList.
@
text
@d439 1
a439 1
	tst.l	D0
d633 4
a636 4
	move.l	D_Size,D0		; size of buffer
	sub.l	A_W,D0
	sub.l	D2,D0
	 bgt.s	ra_SlashF_DoChar
d639 1
a639 1
	bsr	NewBuffer
d641 1
d643 1
a643 1
33$:	move.b	(A0)+,0(A_W,D0.w)	; copy over old string buffer
d657 2
a658 2
	addq.l	#1,D2
	bra.s	ra_SlashF_loop
d683 3
a685 3
	move.l	A_W,a0
	bsr	strlen
	move.l	d0,d2		; ptr to current byte of string
d687 2
a688 2
	move.b	d0,0(A_W,d2.l)	; follow first arg by a space (oh well)
	addq.l	#1,d2
d702 1
a702 1
	bsr	MyRditem
d706 1
a706 1

d861 1
a861 1
	move.l	A_W,D0
d866 3
a868 3
	sub.l	A_W,D0
	subq.l	#4,D0
	 bge.s	5$
d870 1
a870 1
	bsr	NewBuffer
d1090 1
a1090 1
*	D3 is already in place (CSource == isbcpl)
d1108 1
d1111 4
a1114 2
	move.l	D_Size,D2
	sub.l	A_W,D2		; Calculate space available.
d1116 12
d1140 1
a1140 1
	subq.l	#1,D_Maxchars	; Lopp off a char for null termino.
d1148 1
d1150 3
d1231 1
a1231 1
	tst.w	D_Flag
@


36.19
log
@Many comments added
Fixed some operations without sizes specified
Fixed it so it allocates the buffer if NULL is passed in, as specified in
the docs.  Saved space.
Made the initial buffer VECSIZE, not VECSIZE-RDA_SIZEOF-4-4.
@
text
@d208 3
d212 2
a213 2
	move.l	D_IsBCPL,A0
	moveq.l	#RDAF_NOALLOC,D0
d216 1
a216 1
	addq.l	#4,D1
d218 1
a218 1
	tst.l	D0
d221 2
a222 2
	move.l	D_IsBCPL,A1
	move.l	RDA_DAList(A1),(A0)
d224 1
a224 1
	addq.l	#4,D0
d247 2
a248 1
	move.l	#VECSIZE,d1		; for use later
d255 1
a255 1
	move.l	D_IsBCPL,A0
d261 2
a262 1
	bsr.s	GetVec			; be careful NOT to deallocate the RDArg
d266 1
a266 1
	bra.s	set_buffer		; common code
d272 3
a274 3
	moveq	#RDA_SIZEOF,d0
	add.l	d0,d1			; d1 = RDA_SIZEOF + VECSIZE
	bsr.s	GetVec
d278 2
a279 3
* WHAT THE F***!!!!??????  FIX!!!!!!!!!!! (damn charlie)
* I'll comment it out, since I don't think it does anything - REJ
*	addq.l	#4,D_IsBCPL		; Advance past hook
d283 1
a285 1
	move.l	D0,RDA_DAList(A0)	; Must track this allocation.
d544 1
a544 1
5$:	bsr	CS_ReadChar
d578 2
a579 2
	subq.l	#-ENDSTREAMCH,D0
	 bne.s	ra_error
d1142 1
a1142 1
	 beq.s	1$
d1169 4
d1247 1
a1247 1
	bsr.s	CS_UnReadChar		; Put back char.  Might make conditional.
@


36.18
log
@comment changes
@
text
@d239 3
a241 3
	sub	#RA_STACK,sp
	move.l	D1,A_Keys
	move.l	D2,A_Argv
d244 1
d248 2
a249 2
	tst.l	D_IsBCPL
	 bne.s	DoOptional		; Use specified optional struct.
d251 12
d266 3
a268 2

	move.l	#VECSIZE-4,D1
d273 3
a275 1
	addq.l	#4,D_IsBCPL		; Advance past hook
a276 3

	move.l	D0,RDA_DAList(A0)	; Must track this allocation.

a278 3
	move.l	#VECSIZE-RDA_SIZEOF-4-4,RDA_BufSiz(A0)
*	move.l	#8,RDA_BufSiz(A0)
	bra.s	RAm1
d280 3
a282 3
DoOptional:
	move.l	D_IsBCPL,A0
	clr.l	RDA_DAList(A0)		; For safety, initialize to NULL.
d284 2
a285 1
RAm1:	move.l	RDA_Buffer(A0),A_W
d324 1
a324 1
	cmp	#MAX_TEMPLATE_ITEMS,D_Numbargs
d338 2
a339 2
	lea	Aaray,A0
3$:	move	(A0)+,D1
d341 1
a341 1
	cmp.b	D0,D1
d343 1
a343 1
	lsr	#8,D1
d384 1
a384 1
	sub	#RA_STACK,sp
d740 1
a740 2
	moveq.l	#RDAF_NOPROMPT,D0
	and.l	RDA_Flags(A1),D0
@


36.17
log
@bcc to bcc.s, bsr to bsr.s opts
@
text
@d130 1
a130 1
	BITDEF	ARG_TYPE,MULTI,6	; /...
a562 1
*	cmp.l	#ENDSTREAMCH,D0
d1248 2
d1252 1
@


36.16
log
@Made /N checks far better
@
text
@d248 1
a248 1
	 bne	DoOptional		; Use specified optional struct.
d280 1
a280 1
	bsr	ra_initkeys		; Initialize the ARGV image array
d472 1
a472 1
	 beq	ra_errmem	; No memory, punt error!
@


36.15
log
@for rcs 4.x header change
@
text
@a412 11
* Check all arg types for /F...(?)
*
*	moveq.l	#-1,D_Argno
*	move.l	sp,A0
*1$:	addq.l	#1,D_Argno
*	cmp.l	D_Numbargs,D_Argno
*	 bge.s	ra_NormalLoop
*	move.b	(A0)+,D0
*	 bmi.s	1$
*	btst.b	#ARG_TYPEB_REST,D0
*	bne	ra_DoRestOfLine
d503 4
d508 1
a508 1
	moveq	#8,D0			; begin REJ code
d510 1
a510 1
	blt.s	6$
d835 1
a835 1
	move.l	(sp)+,D1
d838 1
a838 1
	 blt	ra_error
d840 7
d1349 2
@


36.14
log
@Fixed trailing space on slash-f items with only one item
@
text
@@


36.13
log
@Fixed /F!!!!!!!!!
ALso HEAVILY commented it
@
text
@d597 1
a597 1
	 blt.s	check_qmark	; No match
d653 6
@


36.12
log
@Fixed /M /A (inited D_Multi), added comments
@
text
@d405 8
d415 9
a423 9
	moveq.l	#-1,D_Argno
	move.l	sp,A0
1$:	addq.l	#1,D_Argno
	cmp.l	D_Numbargs,D_Argno
	 bge.s	ra_NormalLoop
	move.b	(A0)+,D0
	 bmi.s	1$
	btst.b	#ARG_TYPEB_REST,D0
	bne	ra_DoRestOfLine
d436 1
a436 1
	 bne.s	10$
d546 2
a547 1
10$:	subq.l	#1,D0
d599 1
d611 4
d619 8
a626 1
30$:	move.l	D_Size,D0
d629 1
a629 1
	 bgt.s	32$
d631 1
d635 1
a635 1
33$:	move.b	(A0)+,0(A_W,D0.w)
d640 4
a643 1
32$:	bsr	CS_ReadChar
d645 1
a645 3
	 ble.s	31$
*	cmp.l	#ENDSTREAMCHAR,D0
*	 beq.s	31$
d647 2
a648 2
	 beq.s	31$
	move.b	D0,0(A_W,d2.l)
d650 1
a650 1
	bra.s	30$
d652 26
a677 2
31$:	clr.b	0(A_W,D2)
	bra	not_qmark
d704 2
d709 2
d729 1
d770 1
d783 4
d790 1
a790 1
	and.b	#ARG_TYPEF_TOGGLE+ARG_TYPEF_SWITCH+ARG_TYPEF_REST,D1
d804 1
a804 1
	 bne.s	1$
d823 3
a825 2
1$:	btst	#ARG_TYPEB_MULTI,D0
	 bne.s	2$
d827 1
a827 1
	 bne.s	3$
d829 1
a829 1
	 beq	10$			; No special type, just store.
d856 1
a856 1
	bra.s	30$
d859 2
a860 1
2$:	cmp.l	#4*(MAX_MULTIARGS-1),D_Multi
d865 1
a865 1
	bra.s	20$
d868 2
a869 1
3$:	move.b	(A_W),D0		; Handle "Toggle" key
d888 1
a888 1
ra_ClearFlag	equ	*
d890 1
a890 1
	bra.s	30$
d892 1
a892 1
ra_SetFlag	equ	*
d895 1
a895 1
	bra.s	30$
d898 2
a899 1
10$:	move.l	A_W,0(A_Argv,D_Argno.l)
d904 2
a905 1
20$:	move.l	A_W,A0
d907 1
a907 1
	add	D0,A_W
d909 2
a910 1
30$:	bra	ra_Loop		; Loop to next keyword.
d1119 1
a1119 1
1$:	bsr	CS_ReadChar	; Skip spaces and tabs
d1127 1
a1127 1
	 bne.s	rditem_enter	; Skip ReadChar
d1137 2
a1138 2
	cmp.l	#ENDSTREAMCH,D0	; Can this be "any negative value?"
	 beq	rditem_endloop
d1141 1
a1141 1
	 beq.s	10$
d1143 1
a1143 1
	cmp.b	D_Inquote,D0
@


36.11
log
@/F fixes
@
text
@d369 1
d378 1
d382 1
d391 2
a392 2
1$:	clr.l	(A_W)+
	 dbra	D0,1$
d508 1
a508 1
	cmp.l	D0,D_Multi
d511 1
a511 1
; now steal the last one - D_Size hold a pointer to the last multiarg entry
d515 1
a515 1
	move.l	(A0),-4(A_Argv)		; we already incremented to register
@


36.10
log
@getvec->AllocVec, etc
@
text
@d137 1
a137 1
	dc.b	ARG_TYPEF_REST+ARG_TYPEF_KEYWORD,'F'
d401 3
d405 8
d414 3
d585 1
a585 1
	 blt.s	20$		; No match
d593 1
a593 1
	 bne.s	3$		; Switch, Go For It.
d596 1
a596 1
	 beq.s	1$		; Check for "Rest Of Line Whooser!!!"
d600 1
d627 1
a627 1
	bra	25$
d629 3
a631 2
***** "/S" keyword comes through to 3$
3$:	asl.l	#2,D_Argno
d637 2
a638 1
1$:	bsr	MyRditem
d655 2
a656 1
20$:	bsr	CS_ReadChar
d658 1
a658 1
	 bne.s	25$		; Wasn't end of line, no reprompt
d663 1
a663 1
	 bne.s	25$		; Parameter not "?"
d671 1
a671 1
	 bne.s	25$
d673 1
a673 1
	 bne.s	25$
d678 1
a678 1
	 bne.s	25$
d699 1
a699 1
25$:	bsr	CS_UnReadChar	; Restore the last-read character!
@


36.9
log
@Hah! I made /M, ... /A WORK!  Even multiple /A's!

@
text
@d31 7
d43 7
a62 2
	EXTR	AllocVec,@@getmem
	EXTR	FreeVec,@@freevec
d180 1
a180 1
	move.l	A2,-(sp)
d186 2
a187 1
1$:	move.l	A2,D1
d190 1
a190 1
	SYSCALL	FreeVec
d193 1
a193 1
2$:	move.l	(sp)+,A2
d201 5
a205 4
	move.l	D2,-(sp)
	move.l	#MEMF_PUBLIC+MEMF_CLEAR,D2
	SYSCALL	AllocVec
	move.l	(sp)+,D2
@


36.8
log
@Fixed /M array termination
@
text
@d449 1
d451 4
a454 2
3$:	move.l	(A0)+,(A1)+
	subq.l	#4,D_Multi
d470 20
@


36.7
log
@*** empty log message ***
@
text
@d453 1
a453 1
	clr.l	(A0)		; Array needs null terminator
@


36.6
log
@COnvert to use the new buffered IO calls.
Fix STUPID macro problems
@
text
@d32 3
a34 3
*	INCLUDE	"libraries/dos_lib.i"
	INCLUDE	"libraries/dos.i"
	INCLUDE	"libraries/rdargs.i"
@


36.5
log
@New version from charlie
@
text
@d32 1
a32 1
	INCLUDE	"libraries/dos_lib.i"
d43 5
a47 4
	EXTR	Flush,_flush
	EXTR	ReadChar,_rdch
	EXTR	UnReadChar,_unrdch
	EXTR	BPrintf,@@BPrintf
d65 2
a66 1
	jsr	_LVO\1(A6)
d77 2
a78 1
	jmp	_LVO\1(A6)
d575 1
a575 1
	bra.s	25$
d631 7
a637 4
22$:	move.l	D1,-(sp)
	move.l	sp,A1
	SYSCALL	BPrintf		; Display the template
	addq.l	#4,sp
d1146 3
a1148 1
1$:	SYSCALL	ReadChar
d1170 6
a1175 1
1$:	SYSCALL	UnReadChar
@


36.4
log
@new release from charlie
@
text
@d24 2
d80 1
a80 1
	bra	_\1
d131 3
d184 6
a189 2
GetVec:	move.l	#MEMF_PUBLIC+MEMF_CLEAR,D2
	SYSJMP	AllocVec
d192 4
a195 1
	move.l	D2,-(sp)
a197 1
	move.l	(sp)+,D2
d199 1
a199 1
	 beq.s	1$
d205 1
a205 1
1$:	rts
d207 3
d235 1
a235 1
* multiples of 256 bytes for minimal fragmentation.
d237 1
a237 1
	move.l	#256-4,D1
d249 2
a250 2
	move.l	#256-RDA_SIZEOF-4-4,RDA_BufSiz(A0)
	move.l	#8,RDA_BufSiz(A0)
d617 5
a623 1
	move.l	D_IsBCPL,A1
d1185 1
a1185 1
	move.l	D0,-(sp)
d1190 2
a1191 2
	add	#24,D1
	and.l	#$fffffff8,D1
d1202 1
a1202 1
1$:	movem.l	(sp)+,D0
@


36.3
log
@fixes from charlie.
@
text
@d29 1
d39 1
a39 1
	EXTR	SetIoErr,@@setresult2
d66 1
d77 1
d103 1
a103 1
* Note the usage with /F including ARG_TYPEF_REQUIRED as well
d483 1
a483 1
	move.l	#ERROR_NO_FREE_STORE,D2
d633 1
a633 1
	tst	D_Argno
d648 6
a653 2
	and.b	#ARG_TYPEF_KEYWORD+ARG_TYPEF_SWITCH,D1
	 bne	ra_err1		; Invalid slot type
d995 1
a995 1
	tst	D_Inquote	; Switch on quotes
d1032 1
a1032 1
	tst	D_Currpos
d1043 1
a1043 1
	tst	D_Flag
d1063 1
a1063 1
21$:	tst	D_Flag			; Check for "BCPL"
d1074 2
a1075 2
rdil1:	tst	D_Flag			; Don't unread TAB or SPACE
	 bmi.s	rdil2			; UNLESS bcpl.
d1081 1
a1081 1
rdil2:	tst	D_Inquote
a1216 3



a1217 3
* This must be long-word alligned for BCPL
*****************************************************************************
	cnop	0,4
a1223 2

	cnop	0,4
@


36.2
log
@The next version of rdargs.  Includes Freeargs.  From charlie.
@
text
@d44 2
a45 2
	EXTR	Atol,@@Atol
	EXTR	AllocVecType,@@getmem
d120 1
d158 2
d177 1
a177 1
	SYSJMP	AllocVecType
d682 1
a682 1
	 beq.s	10$			; No special type, just store.
d685 2
a686 2
	lea	0(A_Argv,D_Argno.w),A0
	move.l	A0,D2
d688 2
a689 1
	SYSCALL	Atol
d693 16
d1045 1
d1051 1
a1051 2
25$:	move.l	A_W,A_CommandName
	move.l	D_Size,D_Maxchars
d1219 1
a1219 1
	dc.b	'%B: ',0
@


36.1
log
@Replaced rdargs.c with charlie's rdargs.asm
@
text
@d6 1
a6 1
* _ReadArgs(),_FindArg(), and _ReadItem().
d21 3
d27 4
a30 2
	INCLUDE "exec/types.i"
*	INCLUDE	"doslvo.i"
d45 2
d59 1
a59 1
DOSYSCALL	macro
d69 10
d90 1
a90 1
	xdef	_blib_rdargs,_ReadArgs
d94 3
a96 3
*******************************************************************************
* status = blib_rdargs( UBYTE *keys, LONG *argv, LONG size )
*   D0   = 			D1          D2        D3
d98 1
a98 7
*	Parses the input command line, which is in the buffered BCPL
* input stream, with the ADOS keyword template "keys", putting the resulting
* parsed keyword values into buffer "argv".  argv buffer is also used
* as the destination for parsed strings, with total length of the buffer
* specified by "size", in BYTES.  This buffer should be long enough
* to allow a longword for each template item, plus string storage space
* for the entire input command string parsed into arguments.
d100 3
a102 6
*	The return value of blib_rdargs is ZERO on failure, or a pointer to
* the first free space in "argv" which was not allocated.
*
*	This code is shared with the dos.library "ReadArgs()" callout.
*
*******************************************************************************
a103 14
A_Keys	equr	A2
A_W	equr	A3	; Pointer to buffer for parsed results
A_Argv	equr	A4
A_Temp	equr	A5
A_MaxW	equr	A5	; Highest address + 1 for A_W buffer.

D_Wsize	equr	D2	; Located here for use by Rditem().
D_IsBCPL equr	D3

D_Len	equr	D4
D_Size	equr	D5
D_Numbargs equr	D6
D_Argno	equr	D7

d108 4
a111 1
	BITDEF	ARG_TYPE,REST,4		; /R(est of line)
d113 8
a120 1
MAX_ARGBITS	equ	63		; Highest template bitvalue
d122 2
a123 3
_ReadArgs:
	movem.l	D2-D7/A2-A5,-(sp)
	move.l	D1,D_IsBCPL		; CHSource is initial arg.  Never move!
d125 3
a127 3
	move.l	D_IsBCPL,A0
	move.l	RDA_Template(A0),A_Keys
	lea	RDA_Argv(a0),A_Argv
d129 3
a131 5
	move.l	A_Keys,A_Temp
	move.l	A_Temp,A0
	bsr	strlen
	move.l	D0,D_Len
	bra.s	RA_Merge
d133 68
a200 1
_blib_rdargs:
d202 1
a204 1
	move.l	D3,D_Size
d206 1
a206 2
	moveq.l	#0,D_IsBCPL
	move.l	A_Keys,A_Temp
d208 4
a211 2
	moveq.l	#0,D_Len
	move.b	(A_Temp)+,D_Len
d213 3
a215 2
* ReadArgs merge point
RA_Merge:
d217 4
a220 9
* Initialize the Argv array for Keys switch options.  The values desired are:
* initialised to  0    -
*		  1   /A
*		  2   /K
*	          3   /A/K
*	          4   /S
*		  5   /S/A
*		  6   /S/K
*		  7   /S/A/K
d222 47
a268 1
	move.l	A_Argv,A_W
d270 1
d272 2
a273 4
* Loop here on key values, initializing the ARGV array
ra_keyinit:
	clr.l	(A_W)+
	addq.l	#1,D_Numbargs
d275 5
a279 1
1$:	subq.l	#1,D_Len
d282 1
a282 1
	move.b	(A_Temp)+,D0
d286 2
a287 2
	move.b	(A_Temp)+,D0
	subq.l	#1,D_Len
d290 11
a300 15
	moveq.l	#ARG_TYPEF_REQUIRED,D1	; Check for /A, /K, /S, /N
	cmp.b	#'A',D0			; and set appropriate bit in Argv
	 beq.s	2$
	moveq.l	#ARG_TYPEF_KEYWORD,D1
	cmp.b	#'K',D0
	 beq.s	2$
	moveq.l	#ARG_TYPEF_SWITCH,D1
	cmp.b	#'S',D0
	 beq.s	2$
	moveq.l	#ARG_TYPEF_NUMBER,D1
	cmp.b	#'N',D0
	 beq.s	2$
	moveq.l	#ARG_TYPEF_REST,D1
	cmp.b	#'F',D0
	 bne.s	10$
d302 2
a303 1
2$:	or.l	D1,-4(A_W)
d306 2
a307 1
	 bne.s	1$		; if not, normal loop point
a308 2
	bra.s	ra_keyinit	; End of this keyword, initialize for next

d310 3
a312 2
	move.l	A_Argv,A_MaxW
	add.l	D_Size,A_MaxW
d314 22
a335 2
	tst.l	D_IsBCPL
	 beq.s	ra_Loop
d337 6
a342 4
	move.l	D_IsBCPL,A0
	move.l	RDA_Buffer(A0),A_W
	move.l	A_W,A_MaxW
	add.l	RDA_BufSiz(A0),A_MaxW
d344 4
a347 3
* Here, the argv array is initialized and D_Numbargs is set to the number of
* arguments present in the template.  Loop on input items, with a 
* case switch based on RdItem case return values.
d349 14
d368 1
a368 1
* A_W is the working address of the current buffer, A_MaxW is the
d377 9
a385 3
* Scan through the Argv array, clearing out any unused keywords, and
* making sure there were no unspecified "/A" keywords
	move.l	A_Argv,A0
d389 2
a390 4
	move.l	(A0)+,D1	; Values less than zero are /S keys which
	 bmi.s	1$		; evaluated to "true".
	cmp.l	#MAX_ARGBITS+1,D1 ; Values between 0 and 7 are keyword
	 bhs.s	1$		; values which were not specified
d392 9
a400 4
	btst	#ARG_TYPEB_REQUIRED,D1	; Unspecified key value ... if bit zero
	 bne.s	ra_err		; is set, it was a "/A" key, thus error
	clr.l	-4(A0)		; No error, just clear the unused key
	bra.s	1$
d402 52
a453 1
5$:	bsr	CH_ReadChar
d457 4
a460 1
*** Check for other case values here
d466 15
a480 6
* Here handle all errors in rdargs
* First, scan to end of line discarding unused input
ra_err:
	moveq.l	#120,D2		; For IoErr()
	bsr	CH_ReadChar
	cmp.b	#LF,D0
d485 2
a486 2
	subq.l	#-(ENDSTREAMCH),D0
	 bne.s	ra_err
d488 7
a494 2
1$:	move.l	D2,D1		; Set error condition code
	DOSYSCALL	SetIoErr	; (Error_Line_Too_Long)
d496 2
a497 1
rdargs_rts
d501 1
d505 1
d507 3
a509 12
	move.l	D2,-(sp)
	move.l	A_W,D1
	move.l	A_Keys,D2
	tst.l	D_IsBCPL
	 bne.s	5$

	exg	D1,D2
	bsr	_blib_findarg
	bra.s	6$
5$:	jsr	_FindArg	; Check for argument match against
6$:	move.l	(sp)+,D2

d513 3
a515 5
	asl.l	#2,D0		; Match on keyword
	move.l	0(A_Argv,D0.w),D1 ; See what sort of keyword it is
	 bmi.s	3$		; It was a "/S" and has already been spec'd!
	cmp.l	#MAX_ARGBITS,D1
	 bhs.s	1$		; Already specified, but let it through.
d517 1
d524 1
a524 1
*** HERE, READ IN A /R ARGUMENT
d526 2
a527 2
	moveq	#0,D_Wsize
30$:	move.l	A_MaxW,D0
d529 2
a530 2
	sub.l	D_Wsize,D0
	 ble	ra_err
d532 9
a540 1
	bsr	CH_ReadChar
d547 2
a548 2
	move.b	D0,0(A_W,D_Wsize.l)
	addq.l	#1,D_Wsize
d551 1
a551 1
31$:	clr.b	0(A_W,D_Wsize)
d554 3
a556 1
; "/S" keyword comes through to 3$
d558 1
a558 4
3$:	moveq.l	#-1,D1
	move.l	D1,0(A_Argv,D0.w)
	bra	ra_Loop		; Switch value, no arg required.

d560 1
d566 5
a570 3
2$:	tst.l	D0		; Make sure the parameter is valid
	 ble	ra_err
	bra.s	ra_case2
d572 2
d577 2
a578 1
20$:	bsr	CH_ReadChar
d598 4
d606 1
a606 1
	DOSYSCALL	BPrintf	; Display the template
d609 1
a609 1
	DOSYSCALL	Output
d611 1
a611 1
	DOSYSCALL	Flush	; Flush output (buffered).
d614 1
a614 1
25$:	bsr	CH_UnReadChar	; Restore the last-read character!
d616 1
d625 1
d630 3
a632 2
	move.l	A_Argv,A0	; Was not a keyword - put it in next free.
1$:	addq.l	#1,D_Argno		; Loop through all Argv key slots.
d634 1
a634 1
	 bge	ra_err
d636 2
a637 2
	move.l	(A0)+,D1
	 beq.s	ra_storearg	; An empty slot
d639 2
a640 2
	cmp.l	#MAX_ARGBITS,D1
	 bhs.s	1$		; Slot already full.  Go back!
d642 3
a644 4
	btst	#ARG_TYPEB_KEYWORD,D1
	 bne	ra_err		; /K keyword has not been filled - error!!!
				; NOTE - this error check should probably be
				; in the exit routine rather than here???
d646 3
a648 4
	and	#~(ARG_TYPEF_REQUIRED+ARG_TYPEF_NUMBER),D1
	 bne.s	1$		; Autofill slots type ALWAYS or NUMBER.

* Here, D_Argno is set to the desired slot
d650 2
d656 2
d660 1
d665 2
a666 1
	bra.s	2$
d668 10
a677 6
* C String doodah
1$:
* Check for a "/N" template
	move.l	0(A_Argv,D_Argno.w),D0
	cmp.l	#MAX_ARGBITS+1,D0
	 bhs.s	13$
d679 1
a679 6
	 beq.s	13$		; Have a NUMBER.  Go for it.
* Have a "/N" argument ... 
	move.l	A_MaxW,D0
	sub.l	A_W,D0
	subq.l	#5,D0
	 ble	ra_err
d681 3
d685 2
a686 4
	subq.l	#4,sp
	move.l	sp,D2
	DOSYSCALL	Atol
	move.l	(sp)+,D1
d688 2
a689 1
	 blt	ra_err
d691 7
a697 5
	move.l	A_W,D0
	addq.l	#1,D0
	lsr.l	#1,D0
	lsl.l	#1,D0
	move.l	D0,A_W
d699 19
a717 3
	move.l	D1,(A_W)
	moveq.l	#4,D1
	bra.s	14$
d719 16
a734 2
* Vanilla keyword.
13$:	move.l	A_W,A0
d736 3
a738 2
	addq.l	#1,D0		; Add this len to A_W for next free
14$:	move.l	A_W,D1		; Save this
a739 3
2$:	add	D0,A_W		; Common code to store arg and bump A_W
	move.l	D1,0(A_Argv,D_Argno.l)	; (Argno already has been shifted)
	bra	ra_Loop		; Loop to next keyword.
d743 2
d747 2
a748 2
* status = FindArg( char *kwrd, char *template )
*   D0			   D1		D2
d763 6
d790 2
a791 2
	move.l	D1,A_kwrd
	move.l	D2,A_template
d878 1
a878 1
* status =  ReadItem(UBYTE *commandname, LONG maxchars, struct CHSource *CHSource)
d893 7
d904 2
d907 1
a907 1
D_CHSource	equr	D3	; Calling arg position
a908 1
D_Currpos	equr	D5
d910 1
d912 2
a913 3
* NOTE - the BLIB calling spec is for "maxlongs" instead of "maxchars"
* bytes allowed.  The interface code which massages parameters is
* specified to shift "maxlongs" such that it represents "maxchars".
d915 2
a916 2
* MyRditem is used by rdargs(), to set up A_W in D1.
*	D2 and D3 args are already in place (size, CHSource == isbcpl)
d918 2
a919 2
	move.l	A_MaxW,D_Wsize
	sub.l	A_W,D_Wsize	; Calculate space available.
d922 1
d924 1
a924 1
	 bne.s	_ReadItem
d926 4
d931 1
a931 1
	movem.l	D2-D5/A2,-(sp)
d933 3
a935 1
	moveq.l	#-1,D_CHSource	; Special BCPL entry condition
d939 2
a940 2
	movem.l	D2-D5/A2,-(sp)

d947 1
a947 1
1$:	bsr	CH_ReadChar	; Skip spaces and tabs
d960 1
a960 1
	bsr	CH_ReadChar
d964 1
a964 1
	 beq.s	rditem_endloop
d966 1
a966 1
	 beq.s	rditem_endloop
d972 1
a972 3
	 bne.s	1$
	moveq.l	#2,D0		; End of quote - return(2)
	bra.s	rditem_rts
d974 1
a974 1
1$:	cmp.b	#'*',D0		; Check for escape string processing
d977 1
a977 1
	bsr.s	CH_ReadChar	; Process escapes based on next char
d997 1
a997 1
	 beq.s	rditem_endloop
d999 1
a999 1
	 beq.s	rditem_endloop
d1006 1
a1006 1
	 bne.s	rditem_endloop		; = was not first char in loop
d1015 3
a1017 1
	 bge.s	rditem_fail		; Buffer full - punt.
d1019 19
a1037 3
	move.l	D_CHSource,D1		; Check for "BCPL"
	addq.l	#1,D1
	 beq.s	22$
d1040 2
a1041 1
	bra.s	rditem_loop
d1043 1
d1045 1
a1045 1
	bra	rditem_loop
d1047 3
d1052 1
a1052 1
	bsr.s	CH_UnReadChar		; Put back char.  Might make conditional.
d1054 1
a1054 1
	tst	D_Inquote
d1062 3
d1068 1
a1068 1
	movem.l	(sp)+,D2-D5/A2
d1071 4
a1074 4
* CH_ReadChar, CH_UnReadChar functions are internal functions
* which read either from the CHSource, or from ReadChar/UnReadChar.
CH_ReadChar:
	move.l	D_CHSource,D0
d1079 2
a1080 2
	move.l	D_CHSource,A0
	move.l	CH_Buffer(A0),D0
d1084 2
a1085 2
	move.l	CH_CurChr(A0),D1
	cmp.l	CH_Length(A0),D1
d1087 1
a1087 1
	addq.l	#1,CH_CurChr(A0)
d1095 1
a1095 1
1$:	DOSYSCALL	ReadChar
d1098 2
a1099 2
CH_UnReadChar:
	move.l	D_CHSource,D0
d1104 2
a1105 2
	move.l	D_CHSource,A0
	move.l	CH_Buffer(A0),D0
d1108 1
a1108 1
	tst.l	CH_CurChr(A0)
d1110 1
a1110 1
	subq.l	#1,CH_CurChr(A0)
d1117 1
a1117 1
1$:	DOSYSCALL	UnReadChar
d1121 41
d1165 1
a1165 2
strlen:
	moveq.l	#-1,D0
d1204 1
a1204 1
	END
@
