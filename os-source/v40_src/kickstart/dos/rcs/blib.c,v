head     36.66;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


36.66
date     92.12.14.00.06.43;  author jesup;  state Exp;
branches ;
next     36.65;

36.65
date     92.07.31.22.11.46;  author jesup;  state Exp;
branches ;
next     36.64;

36.64
date     92.06.02.23.04.28;  author jesup;  state Exp;
branches ;
next     36.63;

36.63
date     92.05.18.14.15.43;  author jesup;  state Exp;
branches ;
next     36.62;

36.62
date     92.04.05.23.51.08;  author jesup;  state Exp;
branches ;
next     36.61;

36.61
date     91.05.16.15.58.45;  author jesup;  state Exp;
branches ;
next     36.60;

36.60
date     91.04.22.17.35.20;  author jesup;  state Exp;
branches ;
next     36.59;

36.59
date     91.04.10.18.48.33;  author jesup;  state Exp;
branches ;
next     36.58;

36.58
date     91.03.20.14.13.12;  author jesup;  state Exp;
branches ;
next     36.57;

36.57
date     91.03.12.22.25.39;  author jesup;  state Exp;
branches ;
next     36.56;

36.56
date     91.02.25.17.02.18;  author jesup;  state Exp;
branches ;
next     36.55;

36.55
date     91.02.25.14.50.12;  author jesup;  state Exp;
branches ;
next     36.54;

36.54
date     91.02.21.15.41.33;  author jesup;  state Exp;
branches ;
next     36.53;

36.53
date     91.02.19.02.11.29;  author jesup;  state Exp;
branches ;
next     36.52;

36.52
date     91.02.13.18.59.51;  author jesup;  state Exp;
branches ;
next     36.51;

36.51
date     91.02.01.00.07.25;  author jesup;  state Exp;
branches ;
next     36.50;

36.50
date     91.01.10.18.53.42;  author jesup;  state Exp;
branches ;
next     36.49;

36.49
date     90.12.17.22.26.56;  author jesup;  state Exp;
branches ;
next     36.48;

36.48
date     90.12.16.03.18.39;  author jesup;  state Exp;
branches ;
next     36.47;

36.47
date     90.12.10.20.33.59;  author jesup;  state Exp;
branches ;
next     36.46;

36.46
date     90.12.07.03.51.15;  author jesup;  state Exp;
branches ;
next     36.45;

36.45
date     90.12.03.05.57.30;  author jesup;  state Exp;
branches ;
next     36.44;

36.44
date     90.12.01.20.01.37;  author jesup;  state Exp;
branches ;
next     36.43;

36.43
date     90.11.30.03.34.53;  author jesup;  state Exp;
branches ;
next     36.42;

36.42
date     90.11.27.16.44.33;  author jesup;  state Exp;
branches ;
next     36.41;

36.41
date     90.11.21.02.10.02;  author jesup;  state Exp;
branches ;
next     36.40;

36.40
date     90.09.25.16.09.16;  author jesup;  state Exp;
branches ;
next     36.39;

36.39
date     90.09.06.18.35.25;  author jesup;  state Exp;
branches ;
next     36.38;

36.38
date     90.08.31.15.58.59;  author jesup;  state Exp;
branches ;
next     36.37;

36.37
date     90.08.28.01.50.48;  author jesup;  state Exp;
branches ;
next     36.36;

36.36
date     90.06.18.21.19.26;  author jesup;  state Exp;
branches ;
next     36.35;

36.35
date     90.06.14.03.16.23;  author jesup;  state Exp;
branches ;
next     36.34;

36.34
date     90.06.12.05.30.15;  author jesup;  state Exp;
branches ;
next     36.33;

36.33
date     90.05.24.15.13.19;  author jesup;  state Exp;
branches ;
next     36.32;

36.32
date     90.05.22.16.33.06;  author jesup;  state Exp;
branches ;
next     36.31;

36.31
date     90.05.09.01.58.11;  author jesup;  state Exp;
branches ;
next     36.30;

36.30
date     90.04.19.05.22.55;  author jesup;  state Exp;
branches ;
next     36.29;

36.29
date     90.04.09.18.06.18;  author jesup;  state Exp;
branches ;
next     36.28;

36.28
date     90.04.06.11.53.11;  author jesup;  state Exp;
branches ;
next     36.27;

36.27
date     90.04.05.05.01.15;  author jesup;  state Exp;
branches ;
next     36.26;

36.26
date     90.04.03.05.01.09;  author jesup;  state Exp;
branches ;
next     36.25;

36.25
date     90.04.03.04.41.28;  author jesup;  state Exp;
branches ;
next     36.24;

36.24
date     90.03.17.23.46.44;  author jesup;  state Exp;
branches ;
next     36.23;

36.23
date     90.03.05.01.32.57;  author jesup;  state Exp;
branches ;
next     36.22;

36.22
date     90.03.05.01.06.58;  author jesup;  state Exp;
branches ;
next     36.21;

36.21
date     90.02.20.19.56.46;  author jesup;  state Exp;
branches ;
next     36.20;

36.20
date     90.02.16.22.10.20;  author jesup;  state Exp;
branches ;
next     36.19;

36.19
date     90.01.31.15.12.45;  author jesup;  state Exp;
branches ;
next     36.18;

36.18
date     90.01.17.21.43.30;  author jesup;  state Exp;
branches ;
next     36.17;

36.17
date     89.12.16.19.41.44;  author jesup;  state Exp;
branches ;
next     36.16;

36.16
date     89.12.15.05.08.23;  author jesup;  state Exp;
branches ;
next     36.15;

36.15
date     89.12.13.20.46.53;  author jesup;  state Exp;
branches ;
next     36.14;

36.14
date     89.12.12.11.19.48;  author jesup;  state Exp;
branches ;
next     36.13;

36.13
date     89.12.11.23.49.57;  author jesup;  state Exp;
branches ;
next     36.12;

36.12
date     89.12.10.21.29.23;  author jesup;  state Exp;
branches ;
next     36.11;

36.11
date     89.12.09.01.44.04;  author jesup;  state Exp;
branches ;
next     36.10;

36.10
date     89.12.08.07.10.55;  author jesup;  state Exp;
branches ;
next     36.9;

36.9
date     89.12.05.21.31.51;  author jesup;  state Exp;
branches ;
next     36.8;

36.8
date     89.12.03.14.35.36;  author jesup;  state Exp;
branches ;
next     36.7;

36.7
date     89.12.01.08.06.18;  author jesup;  state Exp;
branches ;
next     36.6;

36.6
date     89.11.22.03.10.20;  author jesup;  state Exp;
branches ;
next     36.5;

36.5
date     89.11.14.01.19.10;  author jesup;  state Exp;
branches ;
next     36.4;

36.4
date     89.10.24.18.16.23;  author jesup;  state Exp;
branches ;
next     36.3;

36.3
date     89.10.18.04.11.22;  author jesup;  state Exp;
branches ;
next     36.2;

36.2
date     89.10.03.17.45.23;  author jesup;  state Exp;
branches ;
next     36.1;

36.1
date     89.09.16.22.06.19;  author jesup;  state Exp;
branches ;
next     ;


desc
@@


36.66
log
@Preserve IoErr on failure in GetDeviceProc...
@
text
@/* blib.c */

#include <exec/types.h>
#include <exec/io.h>
#include <exec/alerts.h>
#include <exec/memory.h>
#include <exec/execbase.h>
#include <utility/tagitem.h>
#include "dos/dos.h"
#include "dos/dosextens.h"
#include "dos/exall.h"
#include "dos/dostags.h"
#include "dos/rdargs.h"
#include <intuition/intuition.h>
#include <devices/timer.h>

#include <string.h>

#include "libhdr.h"
#include "fault.h"
#include "dos_private.h"

#include <clib/utility_protos.h>
#include <pragmas/utility_pragmas.h>
#include <clib/exec_protos.h>
#include <pragmas/exec_old_pragmas.h>
#include "device_protos.h"
#include "blib_protos.h"
#include "klib_protos.h"
#include "crp_protos.h"

#define SAME		0			/* for string compares */
#define TOBPTR(x)	(((LONG) (x)) >> 2)	/* convert to bptr */

/* for doing __asm stuff */
#define ASM __asm
#define REG(x)	register __ ## x	/* ANSI concatenation */


/* include code for dealing with not being booted for testing */
/*#define NOT_REAL*/


/* // Print standard fault message */
/* aka PrintFault */

LONG ASM
fault (REG(d1) LONG code, REG(d2) UBYTE *header)
{
	char *string;
	LONG rc = DOSTRUE;

	if (code)
	{
		if (header)
			writef("%s: ",(LONG) header);

		string = getstring(code);
		if (string)
			writes(string);
		else {
			writes(getstring(STR_ERROR));  /* "Error " */
			writen(code);
			rc = FALSE;
		}
		newline();

		/* restore result, probably not needed */
		setresult2(code);
	}
	return rc;
}

LONG ASM
Fault (REG(d1) LONG code, REG(d2) UBYTE *header, REG(d3) UBYTE *buffer,
       REG(d4) LONG len)
{
	char *string;
	UBYTE *buf = buffer;	/* local copies - we take it's address */
	LONG l = len;
	char number[10];

	if (code)
	{
		if (header)
		{
			cpymax(&buf,header,&l);
			cpymax(&buf,": ",&l);
		}

		string = getstring(code);
		if (string)
			cpymax(&buf,string,&l);
		else {
			mysprintf(number,"%ld",code);
			cpymax(&buf,getstring(STR_ERROR),&l);  /* "Error " */
			cpymax(&buf,number,&l);
		}
	}

	return len-l;
}

/* // A version of LOADSEG which does not put up requestors */

BPTR ASM
noreqloadseg (REG(d1) char *name)
{
	BPTR seg;
	struct Process *tid;
	APTR wp;

	tid = MYPROC;
	wp  = tid->pr_WindowPtr;
	tid->pr_WindowPtr = (APTR) -1L;

	seg = loadseg(name);

	tid->pr_WindowPtr = wp;

	return seg;
}

/*
// Return TRUE if real error; FALSE if we must retry
// Passed a type code and then either a stream, a task or a lock
// depending on the value of type.

// We construct a message of the following form:

//          Disk volume
//          XXX
//          is full
*/

/*
 * dev should be found for Device Not Mounted (if type is report stream),
 * for Not A Dos Disk, for No Disk Present, for No Disk, and for Abort Busy.
 * if it is not found, <unknown> will be displayed. (?)
 *
 * Note that pr_Result2 has the error code to be handled!
 */

LONG ASM
err_report (REG(d1) LONG type, REG(d2) BPTR arg,
	    REG(d3) struct MsgPort *arg2)
{
	/* ErrorReport resets result2 */
	return ErrorReport(getresult2(),type,arg,arg2);
}

/* FIX! need to add "more info" */

LONG ASM
ErrorReport (REG(d1) LONG code,
	     REG(d2) LONG type,
	     REG(d3) BPTR arg,	    /* arg can be fh or lock or volumenode */
	     REG(d4) struct MsgPort *arg2) /* arg2 is always port if passed */
{
	struct DosList *dev;	  /* ptr to device - see above */
	char *s1;
	char *s2;
	char *s3;
	LONG s1code = STR_VOLUME, s3code = 0;	/* "Volume" */
	char unitname[32];
	char *exclam = "";
	char *string;
	LONG fh_arg1 = NULL;		/* was called "cobase" */
	struct DosList *vol = NULL;	/* to volumenode */
	struct MsgPort *task = NULL;
	LONG unit = 0;
	LONG rc,ptr;
	LONG shutdisk = TRUE;

/* s3code must ALWAYS be set unless you make sure unit < 0! (errx) */

	switch (code) {
	case ERROR_DISK_NOT_VALIDATED:
		s3code = STR_IS_NOT_VALIDATED;		/* "is not validated" */
		break;
	case ERROR_DISK_WRITE_PROTECTED:
		s3code = STR_IS_WRITE_PROTECTED;        /*"is write protected"*/
		break;
	case ERROR_DISK_FULL:
		s3code = STR_IS_FULL;			/* "is full" */
		break;
	case ERROR_DEVICE_NOT_MOUNTED:
		if (type == REPORT_INSERT)
			s1code = STR_PLEASE_INSERT;
		else
			s1code = STR_PLEASE_REPLACE;
		s3code = STR_IN_ANY_DRIVE;		/* "in any drive" */
		if (type == REPORT_STREAM)
errx:			unit = -1;
		break;
	case ERROR_NOT_A_DOS_DISK:
		s1code = STR_NOT_A_DOS_DISK;		/* "Not a DOS disk" */
		goto errx;
	case ERROR_NO_DISK:
		s1code = STR_NO_DISK_PRESENT;		/* "No disk present" */
		goto errx;
	case ABORT_DISK_ERROR:
		s3code = STR_HAS_RW_ERROR;	 /* "has a read/write error" */
		goto erry;
	case ABORT_BUSY:
		s1code = STR_MUST_REPLACE;	 /* "You MUST replace volume"*/
		unit = -1;
		exclam = "!!!";
erry:		shutdisk = FALSE;	/* don't do a flush!! */
		break;
	default:
		return DOSTRUE;
	}

	s1 = getstring(s1code);
	s2 = NULL;
	if (s3code)
		s3 = getstring(s3code);

	if (type != REPORT_INSERT)
		arg <<= 2;	/* real ptr - lock or fh or volumenode */

	switch (type) {
	case REPORT_STREAM:
		/* volume from handler */
		task    = ((struct FileHandle *) arg)->fh_Type;
		fh_arg1 = ((struct FileHandle *) arg)->fh_Arg1;

/*??????? FIX!!!!!!!! ??????? */
/*
		((struct FileHandle *) arg)->fh_End   = NULL;
		((struct FileHandle *) arg)->fh_Pos   = NULL;
		((struct FileHandle *) arg)->fh_Func2 = NULL;
*/
		break;

	case REPORT_LOCK:
		if (arg == NULL || unit < 0)	/* Root dir, or unit needed */
			task = arg2;
		else {
			vol = (struct DosList *)
			      BADDR(((struct FileLock *) arg)->fl_Volume);
			task = ((struct FileLock *) arg)->fl_Task;
		}
		break;

	case REPORT_VOLUME:
		vol = (struct DosList *) arg;	/* already CPTR */
		break;

	case REPORT_INSERT:
		/* split off the volume name */
		if (!arg)
			return DOSTRUE;

		/* 30 character name plus NULL   - FIX! MAXFILENAME+1 */
		ptr = splitname((char *) arg,':',unitname,0,31);
		if (ptr == -1)
			s2 = (char *) arg;	/* no ':' */
		else
			s2 = unitname;

	} /* switch */

	/* Find out more about the volume we are worried about */
	if (vol == NULL && task != NULL)
	{
		vol = (struct DosList *)
		      BADDR(sendpkt1(task,ACTION_CURRENT_VOLUME,fh_arg1));
	}

	if (vol)
		s2 = ((char *) BADDR(vol->dol_Name)) + 1;
	/* all device/volume names are null-terminated BSTRs! */

	if (unit < 0)
	{
/*    // when the type is report.volume we are being called
      // from the file handler. So pick up volume number
      // from the FH global.
      // DEVICE NAMES MUST BE NULL-TERMINATED!

	 used to be:	GLOBAL $( unit_no = ug + 1 *)
*/

		string = getstring(STR_IN_UNIT);	/* "in unit %ld%s" */

		/* try to get real name for device */
		if (type == REPORT_VOLUME || task != NULL)
		{
			/* get the device node for the item */
			dev = FindDosEntryByTask(task ? task : vol->dol_Task);
			/* leaves the list locked!! */

			/* get the devname */
			if (dev)
			{
				string = getstring(STR_IN_DEVICE);
							/* "in device %s%s" */
				unit = ((LONG) BADDR(dev->dol_Name)) + 1;
			} else {
				if (task)
					unit = getresult2();
				else
					/* stupid BCPL handler! */
					/* get global #151 from private gvec */
					unit = ((LONG *) 
						MYPROC->pr_GlobVec)[UG+1];
			}

			UnLockDosList(LDF_ALL|LDF_READ);
		} else {
			unit = getresult2();
		}

		mysprintf(unitname,string,unit,exclam);
		s3 = unitname;
	}

	/* Issue the requester */
	if (shutdisk)
		closedisk(task);

	rc = requester2(s1,s2,s3,type == REPORT_VOLUME ? 0 : DISKINSERTED);

	/* Make _certain_ that error code is restored! */
	setresult2(code);

	/* very important this be false or -1 */
	return (rc ? FALSE : DOSTRUE);
}

/* used to flush a drive - usually before asking the user to remove a disk */

void __regargs
closedisk (task)
	struct MsgPort *task;
{
	/* Close down the drive (or at least attempt to) */
	if (task == NULL)
		task = filesystemtask();
	sendpkt0(task,ACTION_FLUSH);
}

/* for BCPL */

void ASM
endtask (REG(d1) BPTR seg)
{
	Forbid();
	unloadseg(seg);
	RemTask(0L);
/* 	abort(AN_EndTask|AT_DeadEnd); */
}

/* MUST be callable from a task!!! */

void ASM
dotimer (REG(d1) LONG request,
	 REG(d2) struct timerequest *iob,
	 REG(d3) LONG secs,
	 REG(d4) LONG micro)
{
	/* copy the request */
	*iob = *(opendosbase()->dl_TimeReq);

	/* set replyport to my process reply port */
	iob->tr_node.io_Message.mn_ReplyPort = 
				&(((struct Process *) FindTask(0))->pr_MsgPort);

	iob->tr_node.io_Command = request;
	iob->tr_time.tv_micro   = micro;
	iob->tr_time.tv_secs    = secs;

	DoIO((struct IORequest *) iob);
}

/* is callable from a task!!! */

void ASM
delay (REG(d1) ULONG ticks)
{
	struct timerequest iob;
	LONG quot,rem;

	if (ticks) {
		quot = divrem32(ticks,TICKS_PER_SECOND,&rem);
		dotimer(TR_ADDREQUEST,&iob,quot,
			rem * (1000000/TICKS_PER_SECOND));
	}
}

/*
    // Takes a device name string and returns the task number of the
    // corresponding device handler. The device name may be a filing
    // system directory, in which case a pointer to a shared directory
    // lock is returned in result2.
*/

/* C/BCPL interface */
struct MsgPort * ASM
deviceproc (REG(d1) char *name)
{
	struct DevProc *dp;
	struct MsgPort *port;

	dp = getdevproc(name,NULL);
	if (!dp)
		return NULL;

	/* old-style deviceproc doesn't work with non-binding assigns! */
	if (dp->dvp_Flags & DVPF_UNLOCK)
	{
		freedevproc(dp);
		setresult2(ERROR_DEVICE_NOT_MOUNTED);
		return NULL;
	}

	/* they want the lock in pr_result2 */
	setresult2(dp->dvp_Lock);
	port = dp->dvp_Port;

	/* FIX! force handler to remain! */
	freedevproc(dp);

	return port;
}

/*
 * Call initially with dp == NULL.  It will return a struct DevProc or NULL.
 * After using the DevProc, if (dp->dvp_Flags & DVPF_ASSIGN) is true and
 * if the object is not found (ERROR_OBJECT_NOT_FOUND), you should call
 * GetDeviceProc again, passing back dp.  It will return you either a modified
 * DevProc to use again, or NULL (with ERROR_NO_MORE_ENTRIES in IoErr()).  If
 * it returns NULL, it has freed the DevProc structure.  Otherwise, you are
 * responsible for calling FreeDeviceProc() when you are done with the entry.
 *
 * It is safe to call FreeDeviceProc(NULL).  It is also safe to call
 * GetDeviceProc(name,dp) even if DVPF_ASSIGN is not set (though it adds
 * overhead, and isn't preferred).
 *
 * This call is complex, evil, and to hard to understand.  It should be broken
 * up at some point, if possible.
 *
 * Device List locking:
 *	For user accesses, we have three cases.  (1) node has task ptr,
 * (2) node has NULL task, has segment, and (3) node has NULL task and
 * segment ptrs.
 *
 * Following assumes two semaphores: doslist semaphore, and entry semaphore
 *
 * Pseudo-code:
 *   
 *   obtain list read lock
 *   find node
 *   determine type
 *   switch (type):
 *	(1): release list read lock
 *	     return devproc
 *	(2):
 *	(3): obtain entry write lock
 *	     release list read lock
 *	     if seglist is NULL
 *		load segment	Note! will call this routine!
 *				Luckily, semaphores nest!
 * 	     if dl_Task is NULL (in case someone else was just starting it)
 *		start task
 * 
 *	     release entry write locks.
 *           return devproc
 *
 *  Possible problem: what if handler on startup wants to add something to
 *  the device list, like a volume????  Solution: release devlist semaphore
 *  after getting entry write semaphore.  require BOTH to remove a node!
 */

struct DevProc * ASM
getdevproc (REG(d1) char *name, REG(d2) struct DevProc *olddp)
{
	char v[32];	/* FIX! MAX_FILENAME+1+1 */
	LONG ptr;
	struct MsgPort *task = NULL;
	struct DosList *volnode = NULL;
	struct DosList *dl = NULL;
	struct AssignList *al;
	struct DevProc *dp;
	char *volname = NULL;
	char *cname;
	BPTR dir;
	LONG flags = 0;
	LONG type;

	dp = olddp;

	/* free existing non-binding assign lock if passed in */
	/* (so we can ignore later).  Unset flag also. */
	if (dp)
	{
		/* unlock non-binding assign lock */
		if (dp->dvp_Flags & DVPF_UNLOCK)
		{
			freeobj(dp->dvp_Lock);
			dp->dvp_Flags &= ~DVPF_UNLOCK;
		}

		/* if dp is passed in, and there are no more entries, exit */
		if (!(dp->dvp_Flags & DVPF_ASSIGN))
			goto null_return;
	} else {
		/* we're going to have to allocate one, do it first in case */
		/* of low mem (we don't want to leave a hanging proc)	    */
		dp = AllocVecPubClear(sizeof(*dp));
		if (!dp)
			goto null_return;
	}

	/* splitname is now 0-based! */
	/* Leaves volume name in v   */
	/* 30 character name plus NULL   - FIX! MAXFILENAME+1 */
	ptr = splitname(name,':',v,0,31);

	while (1)
	{
		dir = currentdir(FALSE,NULL);		/* NULL isn't needed! */
		setresult2(ERROR_DEVICE_NOT_MOUNTED);

		if (ptr > 0)	/* was there a ':'? */
		{
			/* v holds volume name (no ':') */

			if (mystricmp(v,"NIL") == SAME)
				goto null_return;

			if (mystricmp(v,"CONSOLE") == SAME)
			{
				dir = NULL;
				task = consoletask();
			}

			/* FIX! change name */
			if (mystricmp(v,"PROGDIR") == SAME)
			{
				BPTR lock;

				/* ProgDir: works here */
				lock = MYPROC->pr_HomeDir;

				/* FIX! should we use SYS: if no home? */
				if (lock)
				{
				    dir  = lock;
				    task = ((struct FileLock *)
					    BADDR(lock))->fl_Task;
/*kprintf("  lock = 0x%lx, task = 0x%lx\n",lock,task);*/
				}
/*else kprintf("  NULL HOME:!\n");*/
			}
		}

		/* if it isn't relative to home: */
		if (task == NULL)
		{
		    if (ptr == -1 || ptr == 1)	/* no ':' or starts with ':' */
		    {
			if (dir == NULL)
			{
			/* no current directory - take root of default fs */
				task = filesystemtask();
			} else {
				volnode = (struct DosList *)
					BADDR(((struct FileLock *) BADDR(dir))->
					 fl_Volume);
				task    = volnode->dol_Task;
				volname = (char *) BADDR(volnode->dol_Name) + 1;
				if (ptr == 1)
					dir = NULL; /* root of this fs ':' */
			}

		    } else {	/* has ':' */

			/* look in assignment list */
			/* see algorithm above in psuedo-code */

			/* lock list for read, to keep things from changing */
			dl = LockDosList(LDF_ALL|LDF_READ);

			volnode = finddev(v,FALSE);
			if (volnode == NULL) /* volume not known */
			{
cant_find:
				volname = v;	/* v is cstr */
			} else {

			    /* volume/device/assign is known */
			    /* is this a continuation of a multi-assign? */
			    /* Careful! check initial value of dp! */
			    if (olddp)
			    {
				/* if olddp is set, dp == olddp */

				setresult2(ERROR_NO_MORE_ENTRIES);
				if (volnode != dp->dvp_DevNode)
				{
/*requester("Bad node!",((char *)BADDR(volnode->dol_Name))+1,
((char *)BADDR(dp->dvp_DevNode->dol_Name))+1);*/
				    /* got a different node - punt */
				    /* should this put up a requester? FIX! */
				    goto null_return;
				}

				/* find next entry in assign, if any */
				if (volnode->dol_Type != DLT_DIRECTORY)
{
/*requester("Bad type?!","","");*/
				    goto null_return;
}

				al = volnode->dol_misc.dol_assign.dol_List;
				/* is this the first call? */
				if (al && dp->dvp_Lock == volnode->dol_Lock)
					goto got_multi;

				while (al) {
				    /* find the current lock in the list */
				    if (al->al_Lock == dp->dvp_Lock)
				    {
					/* got it! */
					al = al->al_Next;
					if (al)
					{
got_multi:
					    /* NULL lock would be silly, but */
					    dp->dvp_Port = al->al_Lock ?
						((struct FileLock *)
						 BADDR(al->al_Lock))->fl_Task :
						filesystemtask();
					    dp->dvp_Lock = al->al_Lock;

					    /* turn off flag if no more after */
					    if (!al->al_Next)
						dp->dvp_Flags &= ~DVPF_ASSIGN;

					    goto return_success;

					} else
					    goto null_return;
				    }
				    al = al->al_Next;
				}
				/* didn't find it (bizarre) must have changed */
				goto null_return;

			    } /* if (olddp) */

			    type = volnode->dol_Type;

			    /* handle late-binding assigns */
			    if (type == DLT_LATE ||
				type == DLT_NONBINDING)
			    {
/*
if (type == DLT_LATE)
 requester("Handling late-binding assign!",name,
 volnode->dol_misc.dol_assign.dol_AssignName);
else
 requester("Handling non-binding assign!",name,
 volnode->dol_misc.dol_assign.dol_AssignName);
*/
				/* this will call getdevproc!!! */
				/* remove circularity by changing type! */
				/* ok, since list should be locked here FIX */
				/* FIX! recursive! at least check stack!!!! */
				/* leaves a slight hole, may cause object not
				   found */
				if (type == DLT_LATE)
					volnode->dol_Type = DLT_PRIVATE;

				/* CSTR */
				dir = locateobj(volnode->
					dol_misc.dol_assign.dol_AssignName);
				if (!dir)
				{
/* FIX! handle assigns to drives with nothing in them (please insert...) */
/*requester("Failed to find",volnode->dol_misc.dol_assign.dol_AssignName,"");*/
					/* locateobj already did requester */
					volnode->dol_Type = type;
					goto null_return;
				}

				if (type == DLT_LATE)
				{
				    /* got it! convert to regular assign */
				    freeVec(volnode->
					    dol_misc.dol_assign.dol_AssignName);
				    volnode->dol_Type = DLT_DIRECTORY;
				    volnode->dol_Lock = dir;
		/* apparently some people rely on dol_Task, try to help them */
				    volnode->dol_Task = ((struct FileLock *)
							 BADDR(dir))->fl_Task;
				} else {
				    /* type == DLT_NONBINDING */
				    flags |= DVPF_UNLOCK;
				}

			    } /* if late or non-binding */

			    if (type != DLT_NONBINDING)
				dir = volnode->dol_Lock;
			    task = (struct MsgPort *)
			           (dir == NULL ? volnode->dol_Task :
				    ((struct FileLock *) BADDR(dir))->fl_Task);

			    /* set flag to tell caller there are more */
			    if (type == DLT_DIRECTORY &&
				volnode->dol_misc.dol_assign.dol_List)
			    {
				flags |= DVPF_ASSIGN;
			    }

			    if (task == NULL)
			    {
				if (volnode->dol_Type == DLT_DEVICE)
				{
/* grab the Entry semaphore (the "I'm mucking with an entry" lock)	 */
/* we support new-style handlers (-2), which means that they will not do */
/* any dangerous synch IO before replying their packet, or old-style     */
/* handlers, which are protected using Forbid() and dol_Task.		 */
/* -2 is C-style, -3 is bcpl-style					 */
/* RemDosEntry grabs write-locks on BOTH delete and entry!		 */

				    ULONG mode = ((LONG) volnode->
				       dol_misc.dol_handler.dol_GlobVec) < -1 ?
				       LDF_DELETE | LDF_READ /* new */:
				       LDF_ENTRY | LDF_WRITE /* old */;

				    LockDosList(mode);

/* release list semaphore so handler can add volume nodes */
				    UnLockDosList(LDF_ALL | LDF_READ);
				    /* don't unlock later */
				    dl = NULL;

/* since we weren't locked until now, someone else may have started it	    */
/* however, loaddevice checks the task field before trying */
				    	/* loaddevice wants a BSTR! */
				    cname = AllocVecPub(strlen(name)+1);
				    if (cname)
				    {
				    	  CtoB(name,(CPTR) cname);
				    	  task = loaddevice(volnode,
							    TOBPTR(cname));
				    	  freeVec(cname);
				    	  dir = NULL;
				     }

				     UnLockDosList(mode);
				} else {
				    /* not a device - volume probably */
				    volname = (char *)
					     BADDR(volnode->dol_Name)+1;
				}
			    } /* if task == NULL */

			} /* if volnode == NULL... else */

		    } /* if ptr == -1 || ptr == 1.... else */ 

		    /* did we find anything? */
		    if (task == NULL)
		    {
			/* free doslist before looping */
			if (dl)
			{
				dl = NULL;
				UnLockDosList(LDF_ALL | LDF_READ);
			}

			if (volname != NULL)
			{
				/* flush to reduce chances of munged disk */
				/* useless - this is merely the boot volume */
				/* closedisk(task); */

				/* put up "insert disk" requester */
				/* leaves result2 set */
				setresult2(ERROR_DEVICE_NOT_MOUNTED);
				if (!err_report(REPORT_INSERT,(BPTR) volname,
						NULL))
					continue;	/* while loop */
				/* goto null_return was here */
			}
			/* either fell out of above, or loaddevice failed */
			goto null_return;
		    }

		} /* if task == NULL */

		/* FIX! add to count in handler task! */
		dp->dvp_Port    = task;
		dp->dvp_Lock    = dir;
		dp->dvp_Flags   = flags;
		dp->dvp_DevNode = volnode;	/* may be NULL */

return_success:
		/* unlock doslist if locked */
		if (dl)
			UnLockDosList(LDF_READ | LDF_ALL);

		return dp;

	} /* while 1 */

null_return:
	/* save error code... */
	ptr = getresult2();

	/* free dp if passed in, return NULL. */
	if (dp)
		freedevproc(dp);

	/* unlock doslist if locked */
	if (dl)
		UnLockDosList(LDF_READ | LDF_ALL);

	/* restore error and exit */
	setresult2(ptr);
	return NULL;
}

/* MUST be safe for dp == NULL! */

void ASM
freedevproc (REG(d1) struct DevProc *dp)
{
	if (dp) {
		if (dp->dvp_Flags & DVPF_UNLOCK)
			freeobj(dp->dvp_Lock);

		/* FIX! decrement count in handler! */
		freeVec((char *) dp);
	}
}

/* splitname has been downcoded - uses Cstrings */
/* findstream moved to bcplio.c */

/* device management support */
/* finddevice is a define */

struct DosList * ASM
finddev (REG(d1) char *name,
	 REG(d2) LONG devonly)
{
	struct DosList *p;
	LONG flags;

	flags = devonly ? LDF_DEVICES : LDF_ALL;

	/* usually called under read lock from getdeviceproc */

	p = LockDosList(flags|LDF_READ);
	p = FindDosEntry(p,name,flags);
	UnLockDosList(flags|LDF_READ);

	return p;
}

/* adddevice already written for ram-handler */

struct MsgPort * ASM
loaddevice (REG(d1) struct DosList *node,
	    REG(d2) BPTR string)	/* actually we don't care */
{
	struct MsgPort *task;
	struct DosPacket *pkt = NULL;
	LONG *mseg;
	LONG *segl = NULL;
	BSTR name = node->dol_Name;
	BPTR gv   = node->dol_misc.dol_handler.dol_GlobVec;
	BPTR seg  = node->dol_misc.dol_handler.dol_SegList;
	LONG pri  = node->dol_misc.dol_handler.dol_Priority;
	LONG ss   = node->dol_misc.dol_handler.dol_StackSize;

/*kprintf("starting handler %s\n",((char *)BADDR(name))+1);*/

	/* see psuedo-code above for GetDeviceProc */
	/* we have the Entry locked for write, the list itself is unlocked! */
	/* (or we have delete locked for read, see RemDosEntry)		    */

	/* check first */
	if (node->dol_Task)
		return node->dol_Task;

	if (!seg)			/* no segment, load it from disk */
	{
	  /* may end up calling loaddevice!!! */
	  /* potential deadlock if this requires starting a handler?      */
	  /* no deadlock, since this task owns the semaphores, all is OK. */
	  /* deadlock still possible if loading the other handler requires*/
	  /* loading a third handler.  Oh well.				  */

		seg = loadsegbstr(node->dol_misc.dol_handler.dol_Handler);
							/* BPTR to BSTR */

		if (!seg)
			return NULL;			/* exit if error */
		Forbid();
		if (node->dol_misc.dol_handler.dol_SegList)
			unloadseg(seg);
		else 
			node->dol_misc.dol_handler.dol_SegList = seg;
					/* loaded now */
		Permit();

		/* make sure we have the current segment for the handler */
		seg = node->dol_misc.dol_handler.dol_SegList;
	}

/*
   // Now create new task invocation. If GV = -1 then we must create a
   // C task; otherwise we assume a BCPL task, which uses the shared
   // global vector as GV or a private one if GV = 0.
*/
/* assumes device names are null-terminated as well!!!!! */

	/* someone may have started the task already!!! */
	/* probably redundant, but may be useful and doesn't hurt */

	task = node->dol_Task;
	if (task == NULL)
	{
	    pkt = AllocDosObject(DOS_STDPKT,NULL);
	    if (!pkt)
		goto cleanup;

	    /* -1 is cstyle, semaphore locking.  -2 same w/ Forbid locking */
	    if ((LONG) gv == -1 || (LONG) gv == -2)
	    {
		/* name must be null-terminated BSTR! */
		task = createproc((char *) BADDR(name)+1,pri,seg,ss);

	    } else {
		segl = AllocVecPub(4*4);
		if (!segl)
			goto cleanup;

		mseg = (LONG *) BADDR(seglist());	/* my segarray */

		segl[0] = 3;
		segl[1] = mseg[1];	/* must be klib */
		segl[2] = mseg[2];	/* must be blib */
		segl[3] = seg;		/* BCPL program */

		/* make private GV if required */
		/* (isn't for con,raw,par,ser,prt) */
		/* (is for ofs, old ram) */

		/* -3 is forbid() locking, BCPL handler */
		if (gv == NULL || gv == -3)
			gv = TOBPTR(makeglob(segl));

		if (gv)
			task = createtask(TOBPTR(segl),ss,pri,name,gv);
			/* createtask is bcpl-style */
	    }

	    if (!task)
		goto cleanup;
	    segl = NULL;		/* so cleanup won't free it! */

	    /* start it up */
	    /* For DeviceProc? */
	    setresult2(node->dol_Lock);

	    pkt->dp_Action = ACTION_STARTUP;
	    pkt->dp_Arg1   = string;
	    pkt->dp_Arg2   = node->dol_misc.dol_handler.dol_Startup;
	    pkt->dp_Arg3   = TOBPTR(node);
	    pkt->dp_Arg4   = NULL;		/* port to override task ptr */

	    pkt->dp_Port   = task;		/* task to send to */

	    qpkt(pkt);
	    taskwait();	/* assume I got the right one back */
	    /* note: taskwait() doesn't set result2! */

	    if (pkt->dp_Res1)
	    {
		setresult2(node->dol_Lock);

		/* use either port passed back in arg4 or dol_Task (if set) */
		/* This allows handlers to keep their process port for sync */
		/* Dos I/O.						    */

		if (pkt->dp_Arg4)
			task = (struct MsgPort *) pkt->dp_Arg4;
		else if (node->dol_Task)
			task = node->dol_Task;

	    } else {
		task = NULL;
		setresult2(pkt->dp_Res2);
	    }
	} /* if task == NULL */

cleanup:
	FreeDosObject(DOS_STDPKT,pkt);		/* may be null */
	freeVec(segl);				/* may be null */

	return task;
}

/* build a global vector (not filled in).  Walks each seglist in the serarray */
/* to find the highest global used, then allocates space for them. */

LONG * ASM
makeglob (REG(d1) LONG *segl)
{
	LONG max = 15;
	LONG nseg = segl[0];
	LONG *gv,*p;
	LONG i,hrg;

	for (i = 1; i <= nseg; i++)
	{
		p = (LONG *) BADDR(segl[i]);
		while (p != 0) {
			/* seglist points to next segment ptr */
			/* p[1] is the first lw of segment, which has the */
			/* number of longs until the end of the segment */
			hrg = p[p[1]];
			if (hrg > max)
				max = hrg;
			p = (LONG *) BADDR(*p);
		}
	}

	gv = (LONG *) AllocVecPub((max + 1 + NEGATIVE_GLOBAL_SIZE) * 4);
	if (gv)
	{
		gv = gv + NEGATIVE_GLOBAL_SIZE;		/* remember, LONG *!! */
		gv[0] = max;
	}
	return gv;
}

LONG ASM
isinteractive (REG(d1) BPTR s)
{
	/* scb.id == fh_Port */
	return (LONG) ((struct FileHandle *) BADDR(s))->fh_Port;
}

/* MUST be callable from a task!!! */

struct DateStamp * ASM
datstamp (REG(d1) struct DateStamp *v)
{
	struct timeval tv;
	struct DosLibrary *doslib = opendosbase();
	LONG quot,rem;

	/* get the current time (callable from a task)	*/
	/* asm stub to call GetSysTime()		*/
	getSysTime(&tv,doslib->dl_TimeReq->tr_node.io_Device);

	/* write the current time out to the users buffer */
	quot = divrem32(tv.tv_secs,60,&rem);	/* sets rem to remainder */

	v->ds_Tick   = div32(tv.tv_micro,
			     1000000/TICKS_PER_SECOND) +
		       rem * TICKS_PER_SECOND;
	v->ds_Minute = rem32(quot,(60*24));
	v->ds_Days   = div32(tv.tv_secs,(60*60*24));

	/* update the root node to have the current time */
	Forbid();
	doslib->dl_Root->rn_Time = *v;
	Permit();

	return v;
}

void ASM
setdosdate (REG(d1) struct DateStamp *v)
{
	struct timerequest iob;
	LONG secs,micro;
	LONG rem;

	secs  = v->ds_Days * (60*60*24) +
		v->ds_Minute * (60) +
		divrem32(v->ds_Tick,TICKS_PER_SECOND,&rem);
	micro = rem * (1000000/TICKS_PER_SECOND);

	Forbid();

	/* set the timer devices idea of the time */
	dotimer(TR_SETSYSTIME,&iob,secs,micro);

	/* update dos's internal idea of time */
	rootstruct()->rn_Time = *v;

	Permit();
}

/* most calls to this are in support.asm */

LONG ASM
do_lock (REG(d1) BPTR lock,	/* may actually be FH! (for ExamineFH)! */
	 REG(a0) LONG *args,
	 REG(d0) LONG action)
{
	LONG rc;
	struct MsgPort *task;
	struct FileInfoBlock *fib = (void *) BADDR(args[0]);
	struct FileLock *rlock = BADDR(lock);
	LONG arg1 = lock;

#ifndef DONT_CONVERT_EXNEXT
	/* if exnext convert C filename back to BCPL */
	/* FIX I want to ignore this so exnext goes faster! */
	if (action == ACTION_EXAMINE_NEXT)
		CtoBstr((char *) &(fib->fib_FileName[0]));
#endif

	do {
		/* NULL lock handling code here */
		/* bizarre condition code, careful */
		if (action == ACTION_EXAMINE_FH)
		{
			task = ((struct FileHandle *) rlock)->fh_Type;
			arg1 = ((struct FileHandle *) rlock)->fh_Arg1;
		} else {
			task = (rlock ? rlock->fl_Task : filesystemtask());
		}

		rc = sendpkt4(task,action,arg1,args[0],args[1],args[2]);
		if (rc == 0)
		{
			if (action != ACTION_EXAMINE_FH)
			{
				if (err_report(REPORT_LOCK,lock,task))
					return 0;
			} else {
				if (err_report(REPORT_STREAM,lock,0))
					return 0;
			}
		}
	} while (rc == 0);

	/* convert string to C format if required (painful!) */
	if (action == ACTION_EXAMINE_NEXT || action == ACTION_EXAMINE_OBJECT ||
	    action == ACTION_EXAMINE_FH)
	{
		BtoCstr((CPTR) &(fib->fib_FileName[0]));
		BtoCstr((CPTR) &(fib->fib_Comment[0]));
	}

	return rc;
}

/* exall,examine,exnext,info,parent,copydir(duplock) are in support.asm */

/* takes fh or lock for arg2!!! */

LONG ASM
changemode (REG(d1) LONG type, REG(d2) BPTR fh, REG(d3) LONG newmode)
{
	struct MsgPort *port;

	if (!fh)
	{
		setresult2(ERROR_INVALID_LOCK);
		return FALSE;
	}

/* FIX!!! should use a do_lock type interface!!!! */
	if (type == CHANGE_LOCK)
		port = (void *) ((struct FileLock *) BADDR(fh))->fl_Task;
	else /* FIX! should check for error! */
		port = (void *) ((struct FileHandle *) BADDR(fh))->fh_Type;

	return sendpkt3(port,ACTION_CHANGE_MODE,type,fh,newmode);
}


LONG ASM
setcomment (REG(d1) char *name,
	    REG(d2) char *comment)
{
	char *v;
	BPTR myv;
	LONG rc = FALSE;

	v = AllocVecPub(strlen(comment)+1);
	if (v)
	{
		myv = TOBPTR(v);
		CtoB(comment,(CPTR) v);
		rc = objact(name,ACTION_SET_COMMENT,&myv);
		freeVec(v);
	}
	return rc;
}

/* most of the objact routines moved to support.asm */

#ifndef NEW_RENAME
LONG ASM
renameobj (REG(d1) char *fromname,
	   REG(d2) char *toname)
{
	/* rename a file or directory (to the same device) */
	/* does not follow path assigns! FIX!?  */
	/* does not handle soft links!! FIX! */
	struct DevProc *fromdp,*todp;
	char *fname,*tname;
	LONG rc = 0,len;

	while (1) {
		todp = NULL;
		if (!(fromdp = getdevproc(fromname,NULL)))
			break;
		if (!(todp = getdevproc(toname,NULL)))
			break;

		if (fromdp->dvp_Port != todp->dvp_Port)
		{
			setresult2(ERROR_RENAME_ACROSS_DEVICES);
			break;
		}

		/* get space for BSTR versions - do only one alloc */
		/* round len up to next multiple of 4! */
		len = (strlen(fromname)+1+3) & ~0x03;
		fname = AllocVecPub(len + strlen(toname)+1);
		tname = fname + len;
		if (!fname)
			break;

		CtoB(fromname,(CPTR) fname);
		CtoB(toname,(CPTR) tname);

		rc = sendpkt4(fromdp->dvp_Port,ACTION_RENAME_OBJECT,
			      fromdp->dvp_Lock,TOBPTR(fname),
			      todp->dvp_Lock,  TOBPTR(tname));
		freeVec(fname);

		if (rc || err_report(REPORT_LOCK,todp->dvp_Lock,todp->dvp_Port))
			break;

		/* make sure they get freed before looping! */
		freedevproc(fromdp);
		freedevproc(todp);
	} /* while 1 */

cleanup:
	if (fromdp)
		freedevproc(fromdp);
	if (todp)
		freedevproc(todp);
	return rc;
}
#else
LONG ASM
renameobj (REG(d1) char *fromname,
	   REG(d2) char *toname)
{
	/* rename a file or directory (to the same device) */
	/* does not follow path assigns for destination! (of course) */
	/* has to find a source that is on the same volume as the destination */

	struct DevProc *fromdp = NULL,*todp = NULL;
	char *fname,*tname,*newname;
	LONG rc = FALSE;
	LONG fromlinks = MAX_LINKS, tolinks = MAX_LINKS;

	tname = AllocVecPub(strlen(toname)+1+1);
	if (!tname)
		return FALSE;
	CtoB(toname,(CPTR) tname);
	tname[*tname+1] = '\0';

	fname = AllocVecPub(strlen(fromname)+1+1);
	if (!fname)
		goto exit_rename;
	CtoB(fromname,(CPTR) fname);
	fname[*fname+1] = '\0';

	while (1) {
		/* no following of multi-directories on to! */
		todp = getdevproc(tname+1,NULL);
		if (todp == NULL)
			goto exit_rename;

		fromdp = getdevproc(fname+1,fromdp);
		if (fromdp == NULL)
			goto exit_rename;

/*
soft links make this code useless - we must count on the handlers to reject!
		if (fromdp->dvp_Port != todp->dvp_Port)
		{
			setresult2(ERROR_RENAME_ACROSS_DEVICES);
			return 0;
		}
*/
		rc = sendpkt4(fromdp->dvp_Port,ACTION_RENAME_OBJECT,
			      fromdp->dvp_Lock,TOBPTR(fname),
			      todp->dvp_Lock,  TOBPTR(tname));

/*
 * There may be soft links in EITHER the source or destination path.  Try to
 * do a ReadLink on from, then on to.  Keep separate link counts.  Fail only
 * if BOTH fail the readlink.  Evil.
 */

		if (!rc)
		{
			switch (getresult2()) {
			case ERROR_OBJECT_NOT_FOUND:
			  /* multi-dirs only for source */
			  if (fromdp->dvp_Flags & DVPF_ASSIGN)
				goto multi_dir_loop;
			  break;
			case ERROR_IS_SOFT_LINK:
			  /* for the time being, max 255 chars */
			  /* Bstr is allocated in 256 bytes */
			  newname = AllocVecPub(256);
			  if (!newname)
			    break;

			  /* first try the source */
			  if (--fromlinks >= 0)
			  {
			    BtoCstr((CPTR) fname);
			    if (ReadLink(fromdp->dvp_Port,fromdp->dvp_Lock,
					 fname,newname,256) >= 0)
			    {
			      freeVec(fname);
			      fname = newname;
			      CtoBstr(fname);
			      fname[*fname+1] = '\0';
			      /* we read a link for 'from', loop and try again*/
			      goto link_loop;

			    } else {

			      CtoBstr(fname);		/* restore it */

			      /* now try the destination */
			      if (--tolinks >= 0)
			      {
				/* for the time being, max 255 chars */
				/* Bstr is allocated in 256 bytes */
				/* newname already alloced */

				BtoCstr((CPTR) tname);
				if (ReadLink(todp->dvp_Port,todp->dvp_Lock,
					     tname,newname,256) >= 0)
				{
				  freeVec(tname);
				  tname = newname;
				  CtoBstr(tname);
				  tname[*tname+1] = '\0';
				  /* we read a link for 'to', loop and try*/
				  /* again */
				  goto link_loop;

				} else {
				  CtoBstr(tname);	/* probably not needed*/
				  /* we can't deal with >255 chars anyway */
				  freeVec(newname);
				  setresult2(ERROR_INVALID_COMPONENT_NAME);
				}
			      } else {
			        goto counterr;
			      }
			    }
			  } else {
counterr:		    freeVec(newname);
			    setresult2(ERROR_TOO_MANY_LEVELS);
			  } /* fall thru */

default:		  break;
			} /* switch getresult2() */
		} /* if !rc */

		if (rc || err_report(REPORT_LOCK,todp->dvp_Lock,todp->dvp_Port))
		{
exit_rename:
			freeVec(fname);
			freeVec(tname);
			freedevproc(fromdp);
			freedevproc(todp);
			return rc;
		}

		/* make sure they get freed before looping! */
link_loop:
		freedevproc(fromdp);
		fromdp = NULL;
multi_dir_loop:
		freedevproc(todp);

	} /* while 1 */
	/*NOTREACHED*/
}
#endif

void ASM
freeobj (REG(d1) BPTR lock)
{
	LONG res2;
	struct FileLock *l;

	l = BADDR(lock);
	/* don't send UnLocks for locks with NULL tasks */
	if (l && l->fl_Task)
	{
		res2 = getresult2();
		sendpkt1(l->fl_Task,ACTION_FREE_LOCK,lock);
		setresult2(res2);
	}
}

BPTR ASM
OpenFromLock (REG(d1) BPTR lock)
{
	struct FileHandle *scb;
	struct MsgPort *task;
	LONG rc;

	if (!lock)
	{
		setresult2(ERROR_OBJECT_WRONG_TYPE);
		return NULL;
	}

	scb = AllocDosObject(DOS_FILEHANDLE,NULL);
	if (!scb)
		return NULL;	/* no space */

	while (1) {
		task = ((struct FileLock *) BADDR(lock))->fl_Task;
		scb->fh_Type = task;	/* this needs to be set! */

		rc = sendpkt2(task,ACTION_FH_FROM_LOCK,TOBPTR(scb),lock);

		/* open really failed */
		if (rc || err_report(REPORT_LOCK,lock,task))
		{
			if (!rc)
			{
				FreeDosObject(DOS_FILEHANDLE,scb);
				return 0;
			}
			return TOBPTR(scb);
		}
	}
}

LONG ASM
isfilesystem (REG(d1) char *name)
{
	LONG rc;
	char pat[32];	/* FIX! max handler name len + 1 */
	LONG ptr;
	BPTR lock;

	/* FIX! only keep one copy of strings! */
	if (mystricmp("*",name) == SAME ||
	    mystricmp("CONSOLE:",name) == SAME ||
	    mystricmp("NIL:",name) == SAME)
	{
		setresult2(ERROR_ACTION_NOT_KNOWN);
		return FALSE;
	}

	/* first try asking the handler directly */
	rc = devact(name,0,0,ACTION_IS_FILESYSTEM);
	if (rc == 0 && getresult2() == ERROR_ACTION_NOT_KNOWN)
	{
		/* doesn't understand 2.0 packets - Try Lock on root */
		/* 30 char name + NULL -  FIX! MAXFILENAME+1 */
		ptr = splitname((char *) name,':',pat,0,31);
		if (ptr >= 0)
		{
			mystrcat(pat,":");
			lock = locateobj(pat);
			if (!lock)
			{
				/* doesn't support locks - not an FS */
				/* IoErr will be ERROR_ACTION_NOT_KNOWN */
				return FALSE;
			}
			/* supports Lock() on root - assume an FS */
			freeobj(lock);
		}
		return DOSTRUE;	/* either relative path or it supports lock */
	}

	return rc;	/* isfilesystem succeeded */
}

/* most calls to devact moved to support.asm */

LONG ASM
devact (REG(d1) char *name, REG(d2) LONG arg1, REG(d3) LONG arg2,
	REG(d0) LONG action)
{
	struct DevProc *dp = NULL;
	LONG temparg2 = arg2;
	LONG rc;

	while (1) {
		dp = getdevproc(name,dp);
		if (!dp)
			/* getdevproc freed dp for us */
			return FALSE;

		rc = sendpkt2(dp->dvp_Port,action,arg1,temparg2);

		/* should I try subsequent directories? */
		if (!rc && getresult2() == ERROR_OBJECT_NOT_FOUND)
		{
			continue;	/* makes it get the next assign */
		}

		if (rc || err_report(REPORT_LOCK,dp->dvp_Lock,dp->dvp_Port))
		{
			freedevproc(dp);
			return rc;
		}

		/* there was an error and he selected retry - start over */
		freedevproc(dp);
		dp = NULL;
	}
}

/* returns LOCK_SAME for same, LOCK_SAME_HANDLER for same handler, */
/* LOCK_DIFFERENT for different handlers. */

LONG ASM
SameLock (REG(d1) BPTR l1, REG(d2) BPTR l2)
{
	struct FileLock *lock1,*lock2;

	/* simplest check */
	if (l1 == l2)
		return LOCK_SAME;

	/* check for NULL locks! */
	/* not _fully_ correct - could be NULL lock and lock on boot vol */
	/* Fix? */
	if (!(lock1 = (struct FileLock *) BADDR(l1)) ||
	    !(lock2 = (struct FileLock *) BADDR(l2)))
		return LOCK_DIFFERENT;

	/* first check they belong to the same handler */
	/* FIX!!! remove task test - unneeded, but left in due to paranoia */
	if ((lock1->fl_Volume != lock2->fl_Volume) ||
	    (lock1->fl_Task != lock2->fl_Task))
		return LOCK_DIFFERENT;		/* different volumes */

	/* now try the ACTION_SAME_LOCK packet */
	/* returns FALSE (failure) or non-false (success) */

	/* FIX!! should use error checking or do_lock! */
	if (sendpkt2(lock1->fl_Task,ACTION_SAME_LOCK,l1,l2))
		return LOCK_SAME;			/* same */

	/* didn't succeed - check if result2 == ERROR_ACTION_NOT_KNOWN */
	/* for any other error assume they're different */

	if (getresult2() == ERROR_ACTION_NOT_KNOWN)
	{
		/* doesn't support SAME_LOCK - check the fl_Key field */
		if (lock1->fl_Key == lock2->fl_Key)
			return LOCK_SAME;		/* same */
	}

	return LOCK_SAME_VOLUME;	/* same volume, not the same object */
}

/* needs stub rtn because of the number of parameters */
/* NOTE: path is a CSTR, buffer (on success) is a CSTR! */

LONG ASM
ReadLink (REG(d1) struct MsgPort *port, REG(d2) BPTR lock,REG(d3) UBYTE *path,
	  REG(d0) UBYTE *buffer,REG(a0) ULONG size)
{
	return sendpkt4(port,ACTION_READ_LINK,lock,(LONG) path,
			(LONG) buffer,size);
}

/* return last portion of a path */

UBYTE * ASM
FilePart (REG(d1) UBYTE *path)
{
	UBYTE *p;

	p = PathPart(path);
	if (*p == '/')
		p++;

	return p;
}

/* Returns a pointer to the end of the next-to-last component of a path. */
/* i.e. it points past the :, or to the last slash (if preceded by chars), */
/* or past the last slash, if preceded by a null or another slash.  */

UBYTE * ASM
PathPart (REG(d1) UBYTE *path)
{
	UBYTE *p;

	if ((p = strrchr(path,'/')) == NULL)
	{
		if ((p = strchr(path,':')) == NULL)
			return path;
		else
			return p+1;
	}
	if ((p == path)	|| 	/* single leading slash */
	    (*(p-1) == '/') ||
	    (*(p-1) == ':'))	/* multiple slashes (...//foo) or ...:/foo  */
		p++;		/* point past slash - include going up dirs */

	return p;
}

/* Appends a file/dir to the end of a path */

LONG ASM
AddPart (REG(d1) UBYTE *dirname, REG(d2) UBYTE *filename, REG(d3) ULONG size)
{
	UBYTE *p;
	LONG slash = FALSE;

	/* must handle :'s in filename! */

	if (strchr(filename,':'))
	{
		/* filename has a : - if first, tack onto any colon in	*/
		/* dirname, else replace entire string with filename.	*/
		if (*filename == ':')
		{
			p = strchr(dirname,':');
			if (!p)
			{
				p = dirname;	/* overwrite entire path */

			} /* else p points to :, right spot for copy */
		} else
			p = dirname;	/* overwrite entire path */
	} else {
		p = dirname + strlen(dirname);	/* ptr to end of path */
		/* Don't go back past the beginning of the string.	*/
		/* With trailing slashes, you just add the path to it,	*/
		/* because for historical reasons foo/ means foo, while	*/
		/* / means one directory up.				*/
		if (*dirname)
			if (*(p-1) != ':' && *(p-1) != '/')
			{
				slash = TRUE;
				*p++ = '/';  /* we can safely overwrite null */
			}
	}

	/* p points to point to copy filename to */
	/* do length check after finding out about '/' versus ':' */
	if ((p-dirname) + strlen(filename) + 1 > size)	/* 1 for NULL */
	{
		if (slash)
			*--p = '\0';		/* fix string back */
		setresult2(ERROR_LINE_TOO_LONG);
		return FALSE;
	}

	strcpy(p,filename);

	return DOSTRUE;
}

WORD sizes[] = {
	sizeof(struct NewFileHandle),	/* the extended version */
	sizeof(struct ExAllControl),
	sizeof(struct FileInfoBlock),
	sizeof(struct StandardPacket),
	sizeof(struct CommandLineInterface),  /* not used */
	sizeof(struct RDArgs),
};

void * ASM
AllocDosObject (REG(d1) ULONG type, REG(d2) struct TagItem *tags)
{
	void *ptr;

	if (type >= sizeof(sizes)/sizeof(sizes[0]))
		return NULL;

	/* handle DOS_CLI differently */
	if (type == DOS_CLI)
		ptr = (void *) AllocCli(tags);
	else
		ptr = AllocVecPubClear(sizes[type]);
	if (!ptr)
		return NULL;
 
	/* initialize, if needed */
	switch (type) {

	case DOS_FILEHANDLE:
		/* careful!!! execute.c allocates fh's!! */
		init_scb((struct FileHandle *) ptr,
			 getTagData(ADO_FH_Mode,ACTION_FINDINPUT,tags));
		break;

	case DOS_EXALLCONTROL:
	case DOS_FIB:
		break;

	case DOS_STDPKT:
		/* void * can be a pain at times */

		((struct StandardPacket *) ptr)->sp_Msg.mn_Node.ln_Name =
			(UBYTE *) (&(((struct StandardPacket *) ptr)->sp_Pkt));
		((struct StandardPacket *) ptr)->sp_Pkt.dp_Link = ptr;

		/* return ptr to dospacket */
		ptr = &(((struct StandardPacket *) ptr)->sp_Pkt);
		break;

	case DOS_CLI:
	case DOS_RDARGS:
		break;
	}

	return ptr;
}

void ASM
FreeDosObject (REG(d1) ULONG type, REG(d2) void *ptr)
{
	if (!ptr || type >= sizeof(sizes)/sizeof(sizes[0]))
		return;

	/* fix up ptr if needed */
	switch (type) {
	case DOS_STDPKT:
		ptr = ((char *) ptr) - sizeof(struct Message);
		// fall through
	default:
		freeVec(ptr);
		break;
	case DOS_CLI:
		freecli((struct CommandLineInterface *) ptr,0);
	}
}
@


36.65
log
@Fixed console: bug (getdeviceproc now understands it)
@
text
@d814 3
d825 2
@


36.64
log
@Fixed FreeDosObject(xx,DOS_CLI).
@
text
@d533 6
@


36.63
log
@Make splitname calls for device names use 31 instead of 32.
@
text
@d1743 2
a1744 1
	if (type == DOS_STDPKT)
d1746 7
a1752 2

	freeVec(ptr);
@


36.62
log
@FileHandle->NewFileHandle, to support SetVBuf
@
text
@d256 2
a257 1
		ptr = splitname((char *) arg,':',unitname,0,sizeof(unitname));
d519 2
a520 1
	ptr = splitname(name,':',v,0,sizeof(v));
d1475 2
a1476 1
		ptr = splitname((char *) name,':',pat,0,sizeof(pat));
@


36.61
log
@SameLock really wanted to have LOCK_SAME_VOLUME instead of
LOCK_SAME_HANDLER.
Rename needs fixing re volumes on same handler, but to tricky for now.
@
text
@d1677 1
a1677 1
	sizeof(struct FileHandle),	/* the non-extended version */
@


36.60
log
@Set result2 on initial packet error (taskwait doesn't do it).
@
text
@d1549 4
a1552 2
	if (lock1->fl_Task != lock2->fl_Task)
		return LOCK_DIFFERENT;		/* different handlers */
d1567 1
a1567 3
		/* Must check volume first!!! */
		if ((lock1->fl_Volume == lock2->fl_Volume) &&
		    (lock1->fl_Key == lock2->fl_Key))
d1571 1
a1571 1
	return LOCK_SAME_HANDLER;	/* same handler, not the same object */
@


36.59
log
@Added result2 for isfilesystem on name match
@
text
@d972 1
d987 1
a987 1
	    } else
d989 2
a990 1

@


36.58
log
@Made the addpart length correct again.
@
text
@d1461 2
d1464 1
@


36.57
log
@Check for null port in lock before unlocking
@
text
@d1624 1
a1624 1
	ULONG mysize = size;
d1651 1
a1652 1
				mysize--;
d1658 1
a1658 1
	if ((p-dirname) + strlen(filename) + 1 > mysize)	/* 1 for NULL */
d1660 1
a1660 1
		if (mysize != size)
@


36.56
log
@Had conditional for handler startup backwards
@
text
@d1401 1
d1403 3
a1405 1
	if (lock)
d1408 1
a1408 2
		sendpkt1(((struct FileLock *) BADDR(lock))->fl_Task,
			 ACTION_FREE_LOCK,lock);
@


36.55
log
@make release

@
text
@d721 2
d725 2
a726 2
				       LDF_ENTRY | LDF_WRITE :
				       LDF_ENTRY | LDF_READ;
d875 1
@


36.54
log
@Fixed GV==-3 for bcpl handlers
@
text
@d721 2
a722 2
				    ULONG mode = volnode->
				       dol_misc.dol_handler.dol_GlobVec < -1 ?
d953 1
d965 1
a965 1
	    pkt->dp_Port   = task;
@


36.53
log
@Use MYPROC instead of a FIndTask(0)
Downcoded the (almost identical) setmode and waitforchar (in support.asm)
Removed lc5.05 volatile kludge
Removed CurrentDir (uses common code in doslib now).
@
text
@d888 1
d942 2
a943 1
		if (gv == NULL)
@


36.52
log
@Allocate return struct for GetDevProc before starting handlers
New scheme for locking of handler startup/loading
Allow handlers to use something other than pr_MsgPort
@
text
@d113 1
a113 1
	tid = (struct Process *) FindTask(0L);
a1404 29
/* DOESN'T pass fh_Arg1! - no error reporting! */

LONG ASM
setmode (REG(d1) BPTR scb, REG(d2) LONG mode)
{
	struct MsgPort *port;

	port = ((struct FileHandle *) BADDR(scb))->fh_Type;

	if (!port)		/* NIL: works here */
		return FALSE;

	return sendpkt1(port,ACTION_SCREEN_MODE,mode);
}

LONG ASM
waitforchar (REG(d1) BPTR scb,
	     REG(d2) LONG timeout)
{
	struct MsgPort *port;

	port = ((struct FileHandle *) BADDR(scb))->fh_Type;

	if (!port)		/* NIL: works here */
		return FALSE;

	return sendpkt1(port,ACTION_WAIT_CHAR,timeout);
}

d1457 1
a1457 1
	if (!rc && getresult2() == ERROR_ACTION_NOT_KNOWN)
d1487 1
a1487 1
	volatile LONG temparg2 = arg2;	/* FIX! kludge for lc 5.05! */
a1513 6
}

LONG ASM
CurrentDir (REG(d1) BPTR dir)
{
	return currentdir(TRUE,dir);
@


36.51
log
@Relabel is now in support (so I can factor the common code from relabel
and Format()).
@
text
@d13 1
d477 1
a477 1
getdevproc (REG(d1) char *name, REG(d2) struct DevProc *dp)
d483 1
d485 1
a485 1
	struct DosList *dl = NULL;
d492 2
d508 6
d588 2
a589 1
			    if (dp)
d591 2
d645 1
a645 1
			    } /* if (dp) */
d716 11
a726 2
/* grab the Entry semaphore (the "I'm mucking with an entry" lock)	    */
				    LockDosList(LDF_ENTRY | LDF_WRITE);
d746 1
a746 1
				     UnLockDosList(LDF_ENTRY | LDF_WRITE);
a787 13
		/* now build the return structure if needed */
		/* any non-binding assign lock is already freed */
		if (!dp)
		{
			dp = AllocVecPub(sizeof(*dp));
			if (!dp)
			{
				/* free non-binding assign lock we just got */
				if (flags & DVPF_UNLOCK)
					freeobj(dir);
				goto null_return;
			}
		}
d860 1
d883 2
d890 10
a899 1
		node->dol_misc.dol_handler.dol_SegList = seg;	/* loaded now */
d915 6
a920 1
	    if ((LONG) gv == -1)
d928 1
a928 1
			return NULL;
d950 1
a950 4
	    {
		freeVec(segl);	/* may be NULL for gv == -1 */
		return NULL;
	    }
d956 10
a965 4
	    if (sendpkt3(task,ACTION_STARTUP,
			 string,
			 node->dol_misc.dol_handler.dol_Startup,
			 TOBPTR(node)))
d967 2
d970 11
a980 1
	    else
d985 4
d1057 1
a1057 1
	((struct RootNode *) doslib->dl_Root)->rn_Time = *v;
d1479 3
a1481 1
	if (mystricmp("*",name) == SAME || mystricmp("CONSOLE:",name) == SAME)
d1704 1
d1748 1
d1758 1
a1758 1
	if (type >= sizeof(sizes)/sizeof(sizes[0]))
@


36.50
log
@Annoying change since foo/ is the same as foo, but / goes up one dir
@
text
@a1425 18
relabel (REG(d1) char *drive, REG(d2) char *newname)
{
	UBYTE *name;
	LONG rc;

	/* FIX! use string on stack? */
	name = AllocVecPub(strlen(newname)+1);
	if (!name)
		return FALSE;

	CtoB(newname,(CPTR) name);
	rc = devact(drive,TOBPTR(name),0,ACTION_RENAME_DISK);
	freeVec(name);

	return rc;
}

LONG ASM
@


36.49
log
@FreeVec->freeVec (space saving)
@
text
@d1642 4
d1647 1
a1647 1
			if (*(p-1) != ':')
@


36.48
log
@exec_old_pragmas.h
@
text
@d672 1
a672 1
				    FreeVec(volnode->
d720 1
a720 1
				    	  FreeVec(cname);
d816 1
a816 1
		FreeVec((char *) dp);
d925 1
a925 1
		FreeVec(segl);	/* may be NULL for gv == -1 */
d1136 1
a1136 1
		FreeVec(v);
d1182 1
a1182 1
		FreeVec(fname);
d1275 1
a1275 1
			      FreeVec(fname);
d1297 1
a1297 1
				  FreeVec(tname);
d1308 1
a1308 1
				  FreeVec(newname);
d1316 1
a1316 1
counterr:		    FreeVec(newname);
d1327 2
a1328 2
			FreeVec(fname);
			FreeVec(tname);
d1438 1
a1438 1
	FreeVec(name);
d1730 1
a1730 1
	FreeVec(ptr);
@


36.47
log
@Fixed loaddevice - wasn't setting segl to null, so it freed stack garbage
use GetSysTime(), use divrem32 whereever possible
@
text
@d25 1
a25 1
#include <pragmas/exec_pragmas.h>
@


36.46
log
@Handle aaa:/foo in PathPart
@
text
@d382 1
d384 5
a388 4
	if (ticks)
		dotimer(TR_ADDREQUEST,&iob,div32(ticks,TICKS_PER_SECOND),
		     (rem32(ticks,TICKS_PER_SECOND)) *
		     (1000000/TICKS_PER_SECOND));
d852 1
a852 1
	LONG *segl;
d925 1
a925 1
		FreeVec(segl);
d993 3
a995 2
	struct timerequest iob;
	LONG temp;
d997 3
a999 2
	/* get the current time (callable from a task) */
	dotimer(TR_GETSYSTIME,&iob,0,0);
d1002 1
a1002 1
	temp = rem32(iob.tr_time.tv_secs,60);
d1004 1
a1004 1
	v->ds_Tick   = div32(iob.tr_time.tv_micro,
d1006 3
a1008 3
		       temp * TICKS_PER_SECOND;
	v->ds_Minute = rem32(div32(iob.tr_time.tv_secs,60),(60*24));
	v->ds_Days   = div32(iob.tr_time.tv_secs,(60*60*24));
d1012 1
a1012 1
	((struct RootNode *) (opendosbase()->dl_Root))->rn_Time = *v;
d1023 1
d1027 2
a1028 3
		div32(v->ds_Tick,TICKS_PER_SECOND);
	micro = rem32(v->ds_Tick,TICKS_PER_SECOND) *
		(1000000/TICKS_PER_SECOND);
@


36.45
log
@Removed ubase stuff, call utility lib stubs
@
text
@d1605 2
a1606 1
	    (*(p-1) == '/'))	/* multiple slashes */
@


36.44
log
@Fix to AllocDosObject
@
text
@a22 1
#define UtilityBase myubase
a1671 1
	LONG myubase = (((LONG *) MYPROC->pr_GlobVec)[G_UTILITYBASE]);
d1678 1
a1678 1
		ptr = (void *) AllocCli(tags,myubase);
d1688 1
d1690 1
a1690 1
			 GetTagData(ADO_FH_Mode,ACTION_FINDINPUT,tags));
@


36.43
log
@lattice now handles d4 as a parameter
Fixed OpenFromLock - it forgot to set fh_Type
AddPart is now smarter - handles :'s in the filename part.
@
text
@d1683 2
@


36.42
log
@Test for CONSOLE: was backwards
@
text
@d76 1
a76 1
       REG(d0) LONG len)
d158 1
a158 1
	     REG(a0) struct MsgPort *arg2) /* arg2 is always port if passed */
d361 1
a361 1
	 REG(d0) LONG micro)	/* LC 5.0 doesn't allow above a3/d3 with ASM */
d1405 1
d1407 1
a1407 1
		rc =  sendpkt2(task,ACTION_FH_FROM_LOCK,TOBPTR(scb),lock);
a1617 1
	LONG len = strlen(dirname);
d1620 7
a1626 3
	p = dirname + len;	/* ptr to end of path */
	if (*dirname)
		if (*(p-1) != ':')
d1628 4
a1631 3
			*p++ = '/';	/* we can safely overwrite null */
			mysize--;
		}
d1633 14
d1648 1
a1648 1
	if (len + strlen(filename) + 1 > mysize)	/* 1 for NULL */
@


36.41
log
@Fixed GetDeviceProc(...,dp) where dp is non-NULL and there are no more to get
Fixed SameLock (volume comparison)
Added ChangeMode back
lots of comment, etc changes
@
text
@d1449 1
a1449 1
		return DOSTRUE;
@


36.40
log
@stub out ChangeMode(), 
@
text
@d20 1
d230 1
d234 1
d491 1
a491 1
	if (dp && dp->dvp_Flags & DVPF_UNLOCK)
d493 10
a502 2
		freeobj(dp->dvp_Lock);
		dp->dvp_Flags &= ~DVPF_UNLOCK;
d522 1
a522 1
			if (mystricmp(v,"ProgDir") == SAME)
a629 1
			    }
d631 2
d675 3
d682 3
a684 1
			    }
d729 2
a730 1
			    }
d849 1
a849 1
	struct MsgPort *task = NULL;
d869 4
a872 2
		/* may end up calling loaddevice!!! */
	  /* potential deadlock if this requires starting a handler!? FIX!? */
a1100 2

#ifdef CHANGEMODE
a1115 4
#else
	setresult2(ERROR_NOT_IMPLEMENTED);
	return FALSE;
#endif
d1147 1
d1150 1
a1150 1
	LONG rc,len;
d1153 5
a1157 2
		fromdp = getdevproc(fromname,NULL);
		todp   = getdevproc(toname,NULL);
a1158 2
		if (fromdp == NULL || todp == NULL)
			return 0;
d1162 1
a1162 1
			return 0;
d1171 2
a1172 4
		{
			setresult2(ERROR_NO_FREE_STORE);
			return 0;
		}
d1182 1
a1182 5
		{
			freedevproc(fromdp);
			freedevproc(todp);
			return rc;
		}
d1188 7
a1194 1
	/*NOTREACHED*/
d1362 1
a1362 1
	struct MsgPort *type;	
d1364 1
a1364 1
	type = ((struct FileHandle *) BADDR(scb))->fh_Type;
d1366 1
a1366 1
	if (!type)		/* NIL: works here */
d1369 1
a1369 1
	return sendpkt1(type,ACTION_SCREEN_MODE,mode);
d1376 1
a1376 1
	struct MsgPort *type;	
d1378 1
a1378 1
	type = ((struct FileHandle *) BADDR(scb))->fh_Type;
d1380 1
a1380 1
	if (!type)		/* NIL: works here */
d1383 1
a1383 1
	return sendpkt1(type,ACTION_WAIT_CHAR,timeout);
d1399 1
a1399 2
	scb = (struct FileHandle *)
	      AllocVecPubClear(sizeof(struct FileHandle));
a1403 3
		/* FIX! is using this action here safe?? */
		init_scb(scb,ACTION_FINDINPUT);

d1412 5
a1416 2
				FreeVec(scb);
			return rc;
d1424 1
a1424 1
	UBYTE *v;
d1427 3
a1429 2
	v = AllocVecPub(strlen(newname)+1);
	if (!v)
d1432 3
a1434 3
	CtoB(newname,(CPTR) v);
	rc = devact(drive,TOBPTR(v),0,ACTION_RENAME_DISK);
	FreeVec(v);
d1447 5
d1455 1
a1455 1
		/* doesn't understand 1.4 packets - Try Lock on root */
d1459 1
a1459 1
			strcat(pat,":");
a1468 1
			return TRUE;
d1470 1
a1470 1
		return FALSE;	/* not possible */
a1482 2
/*	LONG tempaction = action;/* FIX! kludge for lc 5.05! */
/*	LONG temparg1 = arg1;	/* FIX! kludge for lc 5.05! */
d1495 1
a1495 2
		if (!rc && getresult2() == ERROR_OBJECT_NOT_FOUND &&
		    (dp->dvp_Flags & DVPF_ASSIGN))
d1505 2
a1511 2
/* was called i.currentdir */

a1517 2
/* ioerr is defined as getresult2 */

d1554 3
a1556 1
		if (lock1->fl_Key == lock2->fl_Key)
d1643 1
a1643 1
	sizeof(struct FileHandle),
@


36.39
log
@Fixed datestamp, fixed PathPart.
@
text
@a146 2
	LONG rc,r2;

d148 1
a148 3
	rc = ErrorReport(r2 = getresult2(),type,arg,arg2);

	return rc;
a1080 1
	LONG args[3];
d1082 2
a1083 3
	args[0] = type;
	args[1] = fh;
	args[2] = newmode;
d1085 7
d1093 9
a1101 5
		return do_lock(fh,args,ACTION_CHANGE_MODE);
	else
/* FIX!!! */
		return sendpkt3(((struct FileHandle *) BADDR(fh))->fh_Type,
				ACTION_CHANGE_MODE,type,fh,newmode);
@


36.38
log
@Make DateStamp/dotimer usable from tasks
@
text
@d356 2
d378 2
d971 2
d979 1
a979 1
	/* get the current time */
d993 1
a993 1
	((struct RootNode *) BADDR(opendosbase()->dl_Root))->rn_Time = *v;
d1567 2
d1576 1
d1581 5
@


36.37
log
@Fixed comment (wrong)
@
text
@d363 1
a363 1
	*iob = *(dosbase()->dl_TimeReq);
d987 1
a987 1
	rootstruct()->rn_Time = *v;
@


36.36
log
@removed redundant task test, made sure loaddevice tests for task first thing.
@
text
@d1536 1
a1536 1
/* NOTE: path is a CSTR, buffer (on success) is a NULL-terminated BSTR! */
@


36.35
log
@Make ErrorReport set result2 right (like err_report did)
@
text
@d694 4
a697 1
				    if (task == NULL)
a698 4
				    	/* loaddevice wants a BSTR! */
				    	cname = AllocVecPub(strlen(name)+1);
				    	if (cname)
				    	{
a703 1
				    	}
d845 4
d852 1
d868 1
@


36.34
log
@Fixes to save space (and make AddPart more robust as well)
@
text
@d149 1
a150 1
	setresult2(r2);					/* reset result2 */
d325 3
@


36.33
log
@Fixed multi-dir assigns (no longer leaves a hanging shared-sem lock)
@
text
@d1575 1
d1581 2
a1582 2
			*p++ = '/';
			size--;
d1586 1
a1586 1
	if (len + strlen(filename) + 1 > size)
d1588 3
a1590 3
		if (dirname)
			if (*--p == '/')
				*p = '\0';
@


36.32
log
@cpymax downcoded to asm.
remove constant div32 calls
optimize to remove redundant BADDRs (local var instead)
@
text
@d607 2
a608 1
					    return dp;
d687 1
d765 1
d771 1
@


36.31
log
@PubClear, div32/rem32, fixed do_lock() if...if...else, DOS_CLI in ADObject.
@
text
@a72 12
/* modifies destination ptr and len */
void ASM
cpymax (REG(a0) UBYTE **dest, REG(a1) UBYTE *src, REG(a2) ULONG *len)
{
	while (*len && *src)
	{
		*((*dest)++) = *src++;
		(*len)--;
	}
	**dest = '\0';
}

d381 1
a381 1
		     (div32(1000000,TICKS_PER_SECOND)));
d969 1
a969 1
			     div32(1000000,TICKS_PER_SECOND)) +
d992 1
a992 1
		div32(1000000,TICKS_PER_SECOND);
d1015 1
d1030 2
a1031 2
			task = ((struct FileHandle *) BADDR(lock))->fh_Type;
			arg1 = ((struct FileHandle *) BADDR(lock))->fh_Arg1;
d1033 1
a1033 3
			task = (lock ? 
				 ((struct FileLock *) BADDR(lock))->fl_Task :
			         filesystemtask());
@


36.30
log
@kludge for lattice 5.05
Make SameLock not access low mem on NULL locks
@
text
@d391 3
a393 2
		dotimer(TR_ADDREQUEST,&iob,ticks/TICKS_PER_SECOND,
		     (ticks % TICKS_PER_SECOND) * (1000000/TICKS_PER_SECOND));
d978 1
a978 1
	temp = iob.tr_time.tv_secs % 60;
d980 2
a981 1
	v->ds_Tick   = iob.tr_time.tv_micro / (1000000/TICKS_PER_SECOND) +
d983 2
a984 2
	v->ds_Minute = (iob.tr_time.tv_secs/60) % (60*24);
	v->ds_Days   = iob.tr_time.tv_secs / (60*60*24);
d1002 3
a1004 2
		v->ds_Tick / TICKS_PER_SECOND;
	micro = (v->ds_Tick % TICKS_PER_SECOND) * (1000000/TICKS_PER_SECOND);
d1053 1
d1056 1
a1056 1
			else
d1059 1
d1375 1
a1375 1
	      AllocVec(sizeof(struct FileHandle),MEMF_PUBLIC|MEMF_CLEAR);
d1612 1
d1624 5
a1628 1
	ptr = AllocVec(sizes[type],MEMF_PUBLIC|MEMF_CLEAR);
d1632 1
d1637 5
d1652 2
a1653 2
	case DOS_EXALLCONTROL:
	case DOS_FIB:
@


36.29
log
@Changes to Devact() to support Format
@
text
@d1449 3
d1460 1
a1460 1
		rc = sendpkt2(dp->dvp_Port,action,arg1,arg2);
d1501 6
a1506 2
	lock1 = (struct FileLock *) BADDR(l1);
	lock2 = (struct FileLock *) BADDR(l2);
@


36.28
log
@added comment
@
text
@d1403 1
a1403 1
	rc = devact(drive,TOBPTR(v),ACTION_RENAME_DISK);
d1417 1
a1417 1
	rc = devact(name,0,ACTION_IS_FILESYSTEM);
d1445 2
a1446 1
devact (REG(d1) char *name, REG(d2) LONG arg1, REG(d0) LONG action)
d1457 1
a1457 1
		rc = sendpkt1(dp->dvp_Port,action,arg1);
@


36.27
log
@addec comment
@
text
@d1429 1
@


36.26
log
@Finally added the locking around handler startup
Moved a return case in getdevproc to deal with failed startup correctly
@
text
@d338 1
@


36.25
log
@for rcs 4.x header change
@
text
@d59 1
a59 1
			writes((LONG) string);
d61 1
a61 1
			writes((LONG) getstring(STR_ERROR));  /* "Error " */
d451 2
d454 1
d456 1
d458 2
a459 2
 *   switch:
 *	(1): Obtain entry read lock
d461 7
a467 2
 *	(2): Obtain entry write lock.
 * x:	     if dl_Task is NULL (in case someone else was just starting it)
d469 2
d472 4
a475 4
 *	(3): obtain entry write lock
 *	     if seglist is NULL
 *		load segment
 *	     goto x;
d486 1
d559 1
d561 3
d571 1
d691 9
a699 3
				    /* loaddevice wants a BSTR! */
				    cname = AllocVecPub(strlen(name)+1);
				    if (cname)
d701 15
a715 7
				      CtoB(name,(CPTR) cname);
				      task = loaddevice(volnode,
						        TOBPTR(cname));
				      FreeVec(cname);
				      dir = NULL;
				    }
				} else
d718 1
d727 7
d736 3
a738 2
				/* FIX! why flush here??? */
				closedisk(task);
d746 1
a746 2

				goto null_return;
d748 2
d773 4
d785 4
d821 1
a821 2
	/* FIX! should leave list locked or some such!!! */
	/* Actually, we should add a semaphore to EACH entry */
d845 5
d852 1
a852 1
/* FIX!!!!! locking on node or list!!!!! */
d856 1
a856 1
			return 0;			/* exit if error */
d867 1
a867 1
/* needs protection from here to return of the startup packet!!!!!! FIX!!! */
d869 2
a870 1
	if ((LONG) gv == -1)
d872 2
d877 1
a877 1
	} else {
d880 1
a880 1
			return 0;
d899 1
a899 1
	}
d901 2
a902 2
	if (!task)
	{
d905 1
a905 1
	}
d907 3
a909 3
	/* start it up */
	/* For DeviceProc? */
	setresult2(node->dol_Lock);
d911 4
a914 4
	if (sendpkt3(task,ACTION_STARTUP,
		    string,
		    node->dol_misc.dol_handler.dol_Startup,
		    TOBPTR(node)))
d917 1
a917 1
	else
d919 2
@


36.24
log
@requester changes, made isfilesystem use fall-back of Lock(xxx:)
@
text
@@


36.23
log
@Oops, make it work (AllocDosObject tags, that is)
@
text
@d167 1
a167 1
/* FIX! need to add "more info" and use easyrequest */
d224 1
a224 1
erry:		shutdisk = FALSE;
d231 1
a231 1
	s2 = "";
d341 2
d353 2
d1348 32
@


36.22
log
@Added tag for AllocDosObject
@
text
@d12 1
d1509 1
d1520 1
a1520 1
			 GetTagData(ADO_FH_Mode,ACTION_FINDINPUT,tags);
@


36.21
log
@Fixed ProgDir:
@
text
@d1517 2
a1518 2
		/* FIX! use tag */
		init_scb((struct FileHandle *) ptr,ACTION_FINDINPUT);
@


36.20
log
@getvec->AllocVec, etc
@
text
@d485 1
d493 1
a493 5
		if (mystricmp(name,"NIL:") == SAME)
			goto null_return;

		/* FIX! change name */
		if (mystricmp(name,"progdir:") == SAME)
d495 1
a495 1
			BPTR lock;
d497 2
a498 2
			/* HOME: works here */
			lock = ((struct Process *) FindTask(0))->pr_HomeDir;
d500 2
a501 2
			/* FIX! should we use SYS:? */
			if (lock)
d503 11
a513 2
			    dir  = lock;
			    task = ((struct FileLock *) BADDR(lock))->fl_Task;
d515 2
a517 1
/*else kprintf("  NULL HOME:!\n");*/
d521 1
a521 2
		if (task == NULL &&
		    (ptr == -1 || ptr == 1))	/* no ':' or starts with ':' */
d523 2
d538 3
a540 1
		} else {
d683 7
a689 4
			}
		}
		if (task == NULL)
		{
d704 3
a706 1
		}
@


36.19
log
@Changed HOME: to PROGDIR:
@
text
@a19 1
#ifdef LATTICE
d23 2
a24 1
#include "proto/exec.h"
a28 1
#endif
a32 3
/* sizeof, but returns longs */
#define longsize(x)	((sizeof(x)+3) >> 2)

d633 1
a633 1
				    freevec(volnode->
d660 1
a660 1
				    cname = getvec((strlen(name)+1+3)>>2);
d666 1
a666 1
				      freevec(cname);
d697 1
a697 1
			dp = getvec(sizeof(*dp) >> 2);	/* must be x*4 long */
d733 1
a733 1
		freevec((char *) dp);
d802 1
a802 1
		segl = AllocVec(4*4);
d827 1
a827 1
		freevec(segl);
d872 1
a872 1
	gv = (LONG *) AllocVec((max + 1 + NEGATIVE_GLOBAL_SIZE) * 4);
d1020 1
a1020 1
	v = AllocVec(strlen(comment)+1);
d1026 1
a1026 1
		freevec(v);
d1057 4
a1060 3
		len = (strlen(fromname)+1+3) >> 2;
		fname = getvec(len + ((strlen(toname)+1+3) >> 2));
		tname = fname + len*4;
d1072 1
a1072 1
		freevec(fname);
d1101 1
a1101 1
	tname = AllocVec(strlen(toname)+1+1);
d1107 1
a1107 1
	fname = AllocVec(strlen(fromname)+1+1);
d1152 1
a1152 1
			  newname = getvec(256/4);
d1163 1
a1163 1
			      freevec(fname);
d1185 1
a1185 1
				  freevec(tname);
d1196 1
a1196 1
				  freevec(newname);
d1204 1
a1204 1
counterr:		    freevec(newname);
d1215 2
a1216 2
			freevec(fname);
			freevec(tname);
d1291 1
a1291 1
	      getmem(longsize(struct FileHandle),MEMF_PUBLIC|MEMF_CLEAR);
d1307 1
a1307 1
				freevec(scb);
d1319 1
a1319 1
	v = AllocVec(strlen(newname)+1);
d1325 1
a1325 1
	freevec(v);
d1497 1
a1497 1
	ptr = AllocVecType(sizes[type],MEMF_PUBLIC|MEMF_CLEAR);
d1533 1
a1533 1
	freevec(ptr);
@


36.18
log
@Added to documentation on locking of device list.
@
text
@d357 1
a357 1
	Forbid(); 		/* FIX! */
d500 1
a500 1
		if (mystricmp(name,"HOME:") == SAME)
@


36.17
log
@Fixed ExamineFH (do_lock), added AllocDosObject/FreeDosObject.
@
text
@d444 20
@


36.16
log
@FileName, etc to FilePart, etc
@
text
@d11 1
d929 1
d941 9
a949 4
		task = (lock ? (action == ACTION_EXAMINE_FH ?
				((struct FileHandle *) BADDR(lock))->fh_Type :
				((struct FileLock *) BADDR(lock))->fl_Task) :
			       filesystemtask());
d951 1
a951 1
		rc = sendpkt4(task,action,lock,args[0],args[1],args[2]);
d1463 54
@


36.15
log
@Fixed Fault()
@
text
@d987 2
d1402 1
a1402 1
FileName (REG(d1) UBYTE *path)
d1406 1
a1406 1
	p = PathName(path);
d1416 1
a1416 1
PathName (REG(d1) UBYTE *path)
d1431 1
a1431 1
AddName (REG(d1) UBYTE *dirname, REG(d2) UBYTE *filename, REG(d3) ULONG size)
@


36.14
log
@Fixed Relabel
@
text
@d81 2
a82 2
		*(*dest++) = *src++;
		len--;
@


36.13
log
@Better smarts for ErrorReport, defines for SameLock, AllocVec cleanup
@
text
@d1298 1
a1298 1
	rc = devact(drive,ACTION_RENAME_DISK,TOBPTR(v));
@


36.12
log
@Fault now returns a code
@
text
@d7 1
d302 2
a303 1
		if (type == REPORT_VOLUME)
d306 2
a307 1
			dev = FindDosEntryByTask(vol->dol_Task);
d316 7
a322 5
				/* stupid BCPL handler! */
				/* get global #151 from private globvec */
				unit = ((LONG *) 
					((struct Process *) FindTask(0))->
					 pr_GlobVec)[UG+1];
d387 3
a389 2
	dotimer(TR_ADDREQUEST,&iob,ticks/TICKS_PER_SECOND,
		(ticks % TICKS_PER_SECOND) * (1000000/TICKS_PER_SECOND));
d785 1
a785 4
		/* getvec always adds an extra long to all allocations!!!! */
		/* BEWARE! */
		/* no longer a problem, I changed it from 3 to 4 longs - REJ */
		segl = getvec(4);	/* longs */
d789 1
a789 1
		mseg = (LONG *) BADDR(seglist());
d798 1
a798 1
		/* (is for ofs, ram) */
d811 1
a811 1
		return 0;
d815 1
a815 1
	/* Why do this? */
d855 1
a855 1
	gv = (LONG *) getvec(max + NEGATIVE_GLOBAL_SIZE);	/* longs! */
d1293 1
a1293 1
	v = getvec((strlen(newname)+1+3) >> 2);
d1347 2
a1348 1
/* returns 0 for same, 1 for same handler, -1 for different handlers. */
d1357 1
a1357 1
		return 0;
d1364 1
a1364 1
		return -1;			/* different handlers */
d1371 1
a1371 1
		return 0;			/* same */
d1380 1
a1380 1
			return 0;		/* same */
d1383 1
a1383 1
	return 1;	/* same handler, not the same object */
@


36.11
log
@*** empty log message ***
@
text
@d45 1
d47 1
a47 1
void ASM
d51 1
d64 1
d71 1
@


36.10
log
@Added support for ExamineFH to do_lock.
@
text
@d8 2
a9 2
#include "libraries/dos.h"
#include "libraries/dosextens.h"
@


36.9
log
@Removed readwrite (to support.asm), added path functions
@
text
@d914 1
a914 1
do_lock (REG(d1) BPTR lock,
d931 4
a934 1
		task = (lock ? ((struct FileLock *) BADDR(lock))->fl_Task :
d938 9
a946 3
		if (rc == 0 && err_report(REPORT_LOCK,lock,task)) /* error */
			return 0;

d950 2
a951 1
	if (action == ACTION_EXAMINE_NEXT || action == ACTION_EXAMINE_OBJECT)
@


36.8
log
@Major rework.  CHanged Fault (no fake filehandles),
Moved a bunch of small routines to support.asm (saved mucho bytes)
Made a bunch of routines that deal with locks produce error requesters
(going through do_lock, formerly examineobj).
Fixed ChangeMode.
@
text
@a1204 23
LONG ASM
readwrite (REG(d1) BPTR scb,
	   REG(d2) char *v,
	   REG(d3) LONG n,
	   REG(d0) LONG code)
{
	struct MsgPort *task;
	struct FileHandle *fh;
	LONG res;

	fh = (struct FileHandle *) BADDR(scb);

	while (1) {
		task = fh->fh_Type;
		if (!task)			/* this is where nil: works */
			return (code == 'W' ? n : 0);

		res = sendpkt3(task,code,fh->fh_Arg1,(LONG) v,n);
		if (res >= 0 || err_report(REPORT_STREAM,scb,NULL))
			return res;
	}
}

d1377 59
@


36.7
log
@moved all strings to fault
added home:
@
text
@d7 1
d19 3
d59 4
a62 3
		else
			writef(getstring(STR_ERROR),code);  /* "Error %N" */

d70 12
d86 4
a89 2
	BPTR savefh;
	struct FileHandle *scb;
d91 7
a97 3
	scb = AllocVecType(sizeof(struct FileHandle), MEMF_PUBLIC|MEMF_CLEAR);
	if (!scb)
		return 0;
d99 8
a106 19
	scb->fh_End = len;
	scb->fh_Buf = TOBPTR(buffer);	/* fix! check alignment or something! */
	/* Func1 is NULL */
	/* Func2 is NULL */
	/* Func3 is NULL */

	/* deplete will return FALSE if func2 is null - good */

	savefh = output();
	selectoutput(TOBPTR(scb));
	fault(code,header);		/* writes to fake filehandle */	
	selectoutput(savefh);

	len = scb->fh_Pos;
	if (len)
	{
		/* return string without \n */
		len--;
		buffer[len] = '\0';	/* since it's always \n... */
a107 1
	freevec(scb);
d109 1
a109 1
	return len;
d173 2
a174 2
	char *s1 = getstring(STR_VOLUME);	/* "Volume" */
	char *s2 = "";
d176 1
d187 2
d191 1
a191 1
		s3 = getstring(STR_IS_NOT_VALIDATED);	/* "is not validated" */
d194 1
a194 1
		s3 = getstring(STR_IS_WRITE_PROTECTED); /*"is write protected"*/
d197 1
a197 1
		s3 = getstring(STR_IS_FULL);		/* "is full" */
d201 1
a201 1
			s1 = getstring(STR_PLEASE_INSERT);
d203 2
a204 2
			s1 = getstring(STR_PLEASE_REPLACE);
		s3 = getstring(STR_IN_ANY_DRIVE);	/* "in any drive" */
d209 1
a209 1
		s1 = getstring(STR_NOT_A_DOS_DISK);	/* "Not a DOS disk" */
d212 1
a212 1
		s1 = getstring(STR_NO_DISK_PRESENT);	/* "No disk present" */
d215 1
a215 1
		s3 = getstring(STR_HAS_RW_ERROR); /* "has a read/write error" */
d218 1
a218 1
		s1 = getstring(STR_MUST_REPLACE); /* "You MUST replace volume"*/
d227 5
d468 1
d726 1
a728 1

a729 1

a822 8
/* capitalch in asm */

/* compch in asm */

/* compstring in asm */

/* rdargs, rditem, findarg replaced by ARP code */

a856 3
/* loadseg and unloadseg rewritten in asm by REJ */
/* execute now in execute.c */

d875 1
d911 2
d914 3
a916 3
examineobj (REG(d1) BPTR lock,
	    REG(d2) struct FileInfoBlock *fib,
	    REG(d3) LONG action)
a918 1
	char *name;
d920 1
d922 1
a922 2
	name = &(fib->fib_FileName[0]);

a924 1
#ifndef DONT_CONVERT_EXNEXT
d926 1
a926 1
		CtoBstr(name);
a928 1
	/* note that action_diskinfo takes first arg as info block */
d934 1
a934 1
		rc = sendpkt2(task,action,lock,TOBPTR(fib));
d943 1
a943 1
		BtoCstr((CPTR) name);
d950 1
a950 6
LONG ASM
examine (REG(d1) BPTR lock,
	 REG(d2) struct FileInfoBlock *fib)
{
	return examineobj(lock,fib,ACTION_EXAMINE_OBJECT);
}
d952 1
a952 6
LONG ASM
exnext (REG(d1) BPTR lock,
	REG(d2) struct FileInfoBlock *fib)
{
	return examineobj(lock,fib,ACTION_EXAMINE_NEXT);
}
a953 2
/* next two really take struct Info's */

d955 1
a955 2
info (REG(d1) BPTR lock,
      REG(d2) struct FileInfoBlock *fib)
d957 1
a957 2
	return examineobj(lock,fib,ACTION_INFO);
}
d959 10
a968 4
LONG ASM
parent (REG(d1) BPTR lock)
{
	return examineobj(lock,NULL,ACTION_PARENT);
a969 1

d989 1
a989 5
LONG ASM
setprotection (REG(d1) char *name,
	       REG(d2) LONG mask)
{
	LONG temp = mask;
a990 52
	return objact(name,ACTION_SET_PROTECT,&temp);
}

LONG ASM
setdate (REG(d1) char *name,
	 REG(d2) struct DateStamp *date)
{
	LONG temp = (LONG) date;

	return objact(name,ACTION_SET_DATE,&temp);
}

LONG ASM
deletefile (REG(d1) char *name)
{
	return objact_noarg(name,ACTION_DELETE_OBJECT);
}

LONG ASM
createdir (REG(d1) char *name)
{
	return objact_noarg(name,ACTION_CREATE_DIR);
}

LONG ASM
lock (REG(d1) char *name,
      REG(d2) LONG mode)
{
	LONG temp = mode;

	return objact(name,ACTION_LOCATE_OBJECT,&temp);
}

/* locatedir is a define */

LONG ASM
locateobj (REG(d1) char *name)
{
	LONG temp = SHARED_LOCK;

	return objact(name,ACTION_LOCATE_OBJECT,&temp);
}

LONG ASM
objact_noarg(REG(d1) char *name,
	     REG(d2) LONG action)
{
	LONG temp = 0;

	return objact(name,action,&temp);
}

a1205 8
read (REG(d1) BPTR scb,
      REG(d2) char *v,
      REG(d3) LONG n)
{
	return readwrite(scb,v,n,'R');
}

LONG ASM
d1209 1
a1209 1
	   REG(a0) LONG code)	/* BCPL wrapper needed */
d1228 1
a1228 7
LONG ASM
write (REG(d1) BPTR scb,
       REG(d2) char *v,
       REG(d3) LONG n)
{
	return readwrite(scb,v,n,'W');
}
d1231 1
a1231 3
seek (REG(d1) BPTR scb,
      REG(d2) LONG pos,
      REG(d3) LONG mode)
d1233 1
a1233 2
	/* allow Seek() on buffered filehandles */
	flush(scb);
d1235 1
a1235 2
	return readwrite(scb,(char *) pos,mode,ACTION_SEEK);
}
d1237 2
a1238 7
LONG ASM
truncate (REG(d1) BPTR scb,
	  REG(d2) LONG pos,
	  REG(d3) LONG mode)
{
	return readwrite(scb,(char *) pos,mode,ACTION_SET_FILE_SIZE);
}
d1240 1
a1240 10
/* copydir is otherwise known as DupLock */

LONG ASM
copydir (REG(d1) BPTR dir)
{
	if (dir == 0)
		return 0;

	return sendpkt1(((struct FileLock *) BADDR(dir))->fl_Task,
		        ACTION_COPY_DIR,dir);
d1244 2
a1245 1
setmode (REG(d1) BPTR fh, REG(d2) LONG mode)
d1247 1
a1247 3
	return sendpkt1(((struct FileHandle *) BADDR(fh))->fh_Type,
			ACTION_SCREEN_MODE,mode);
}
d1249 1
a1249 1
/* takes fh or lock for arg2 */
d1251 2
a1252 6
LONG ASM
changemode (REG(d1) LONG type, REG(d2) BPTR fh, REG(d3) LONG newmode)
{
	return sendpkt3(((struct FileHandle *) BADDR(fh))->fh_Type,
			ACTION_CHANGE_MODE,type,fh,newmode);
}
d1254 1
a1254 6
BPTR ASM
DupLockFromFH (REG(d1) BPTR fh)
{
	struct FileHandle *file = (struct FileHandle *) BADDR(fh);

	return sendpkt1(file->fh_Type,ACTION_LOCK_FROM_FH,file->fh_Arg1);
d1264 6
d1271 1
a1271 1
	      getmem(longsize(*scb),MEMF_PUBLIC|MEMF_CLEAR);
a1293 20
inhibit (REG(d1) char *name, REG(d2) LONG onoff)
{
	return devact(name,ACTION_INHIBIT,onoff);
}

/* pr_result2 has number off buffers if this succeeds */

LONG ASM
addbuffers (REG(d1) char *name, REG(d2) LONG number)
{
	return devact(name,ACTION_MORE_CACHE,number);	/* may be negative */
}

LONG ASM
isfilesystem (REG(d1) char *name)
{
	return devact(name,ACTION_IS_FILESYSTEM,0);
}

LONG ASM
d1310 2
d1313 1
a1313 1
devact (REG(d1) char *name, REG(d2) LONG action, REG(d3) LONG arg1)
a1342 14
LONG ASM
waitforchar (REG(d1) BPTR scb,
	     REG(d2) LONG timeout)
{
	struct MsgPort *type;	

	type = ((struct FileHandle *) BADDR(scb))->fh_Type;

	if (!type)		/* NIL: works here */
		return FALSE;

	return sendpkt1(type,ACTION_WAIT_CHAR,timeout);
}

d1374 1
a1400 17

/* dest can be (BPTR) lock (for hard links) or a string (for soft links) */

LONG ASM
MakeLink (REG(d1) char *name,REG(d2) LONG dest,REG(d3) LONG soft)
{
	LONG args[2];
	LONG rc;

	args[0] = dest;		/* args[0] is string or lock */
	args[1] = soft;

	rc = objact(name,ACTION_MAKE_LINK,&args[0]);

	return rc;
}

@


36.6
log
@Changed es_ to estr_, moved "Please insert..." to error_report, moved
Execute() to execute.c, fixed fhfromlock, added changemode, isfilesystem.
@
text
@d15 1
d22 1
d45 1
a45 1
	struct ErrorString *es;
d52 6
a57 10
		for (es = dosbase()->dl_Errors; es && es->estr_Error != 0; es++)
		{
			if (es->estr_Error == code)
			{
				writes((LONG) es->estr_String);
				break;
			}
		}
		if (!es || es->estr_Error == 0)
			writef("Error %N",code);
d162 1
a162 1
	char *s1 = "Volume";
d177 1
a177 1
		s3 = "is not validated";
d180 1
a180 1
		s3 = "is write protected";
d183 1
a183 1
		s3 = "is full";
d187 1
a187 1
			s1 = "Please insert volume";
d189 2
a190 2
			s1 = "Please replace volume";
		s3 = "in any drive";
d195 1
a195 1
		s1 = "Not a DOS disk";
d198 1
a198 1
		s1 = "No disk present";
d201 1
a201 1
		s3 = "has a read/write error";
d204 1
a204 1
		s1 = "You MUST replace volume";
d276 1
a276 1
		string = "in unit %ld%s";
d286 2
a287 1
				string = "in device %s%s";
d449 1
a449 1
		if (ptr == -1 || ptr == 1)	/* no ':' or starts with ':' */
d451 19
d726 4
a729 4
	BPTR gv  = node->dol_misc.dol_handler.dol_GlobVec;
	BPTR seg = node->dol_misc.dol_handler.dol_SegList;
	LONG pri = node->dol_misc.dol_handler.dol_Priority;
	LONG ss  = node->dol_misc.dol_handler.dol_StackSize;
@


36.5
log
@Fault changes, fixed setdate(), truncate->setfilesize, added duplockfromfh
and openfromlock.
@
text
@d50 1
a50 1
		for (es = dosbase()->dl_Errors; es && es->es_Error != 0; es++)
d52 1
a52 1
			if (es->es_Error == code)
d54 1
a54 1
				writes((LONG) es->es_String);
d58 1
a58 1
		if (!es || es->es_Error == 0)
d167 1
a167 1
	char unitname[16];
d174 1
a174 1
	LONG rc;
d188 4
a191 1
		s1 = "Please replace volume";
d215 2
a216 1
	arg <<= 2;	/* real ptr - lock or fh or volumenode */
d244 11
d614 1
d616 6
a621 3
				if (requester("Please insert volume",
					      volname,
					      "in any drive"))
a623 1
				setresult2(ERROR_DEVICE_NOT_MOUNTED);
d829 1
a831 42
execute (REG(d1) char *comm,
	 REG(d2) BPTR instr,
	 REG(d3) BPTR outstr)
{
	char *bstr;
	LONG rc;
	BPTR ins,outs;
	BPTR seg;

	bstr = getvec((strlen(comm)+1+3) >> 2);
	if (!bstr)
		return FALSE;

	CtoB(comm,(CPTR) bstr);		/* goddamn run wants it in result2 */

	seg = loadseg("C:RUN");
	if (!seg)
		return 0;

	ins  = input();
	outs = output();
	selectinput(instr);
	selectoutput(outstr);

	/* must be BPTR to BSTR - goddamn softloaded run/execute */
	setresult2(TOBPTR(bstr));

	/* we probably can't fix this behavior of run, since 1.3 and before */
	/* had runs that look for a BSTR in result2 pointing to the command */
	/* string.  ARGH - REJ */

	rc = runcommand(seg,600,NULL,0);	/* 600 LWords CHECK! FIX! */

	selectinput(ins);
	selectoutput(outs);

	unloadseg(seg);

	return (rc == 0 ? DOSTRUE : FALSE);
}

LONG ASM
d938 2
d1321 9
d1341 25
a1365 2
	return sendpkt1(((struct FileLock *) BADDR(lock))->fl_Task,
			ACTION_FH_FROM_LOCK,lock);
d1380 6
@


36.4
log
@Fault changes.
@
text
@d43 1
a43 2
	BPTR seg;
	LONG rc = -1;
d49 2
a50 2
		seg = noreqloadseg("C:Fault");
		if (seg)
d52 5
a56 3
			setresult2(code);
			rc = runcommand(seg,400,NULL,0);
			unloadseg(seg);
d58 3
a60 2
		if (rc == -1)
			writef("Error code %N\n",code);
d62 1
d92 6
a1001 2
/* goddamn bcpl bptrs! */

d1006 1
a1006 3
	struct DateStamp *d;		/* MUST BE LW ALIGNED!!!! */
	BPTR myd;
	LONG rc = FALSE;
d1008 1
a1008 9
	d = getvec(sizeof(*d)/sizeof(LONG));
	if (d)
	{
		*d = *date;
		myd = TOBPTR(d);
		rc = objact(name,ACTION_SET_DATE,&myd);
		freevec(d);
	}
	return rc;
d1320 1
a1320 1
	return readwrite(scb,(char *) pos,mode,ACTION_TRUNCATE);
d1342 15
d1506 1
@


36.3
log
@Fixed som wrong allocation lengths (strings)
added MakeLink/ReadLink
modified params to objact
@
text
@d41 1
a41 1
fault (REG(d1) LONG code)
d48 2
d59 2
d62 30
@


36.2
log
@Fixed unit numbers in ErrorReport.
Commented out some assign debug requesters.
Added use of dos list locking (1st phase)
@
text
@d537 1
a537 1
				    cname = getvec((strlen(name)+3)>>2);
d597 2
d779 1
a779 1
	bstr = getvec((strlen(comm)+3) >> 2);
d936 1
d939 1
a939 1
	v = getvec((strlen(comment)+1+3) >> 2);
d942 1
d944 1
a944 1
		rc = objact(name,ACTION_SET_COMMENT,TOBPTR(v));
d954 3
a956 1
	return objact(name,ACTION_SET_PROTECT,mask);
d966 1
d973 2
a974 1
		rc = objact(name,ACTION_SET_DATE,TOBPTR(d));
d996 3
a998 1
	return objact(name,ACTION_LOCATE_OBJECT,mode);
d1006 3
a1008 1
	return objact(name,ACTION_LOCATE_OBJECT,SHARED_LOCK);
d1015 3
a1017 1
	return objact(name,action,0);
d1020 1
d1073 8
d1082 138
d1331 1
a1331 1
	v = getvec(((strlen(newname)+1) >> 2) + 1);
d1434 26
@


36.1
log
@*** empty log message ***
@
text
@d120 1
a120 1
/*	struct DosList *dev;	  /* ptr to device - see above FIX */
a175 1
		/* dev = FindDeviceNode(task); FIX */
a190 1
		/* dev = FindDeviceNode(task); FIX */
a194 1
		/* dev = FindDeviceNode(vol->dl_Task); FIX */
d216 2
a218 1
/* used to be:	GLOBAL $( unit_no = ug + 1 *) */
d224 3
a227 1
/* FIX!
d231 1
a231 1
				unit = ((char *) BADDR(dev->dol_Name)) + 1;
a232 6
*/
/*
kprintf("getting unit global, globvec at 0x%lx, global at 0x%lx\n",
((LONG *) ((struct Process *) FindTask(0))->pr_GlobVec),
((LONG *) ((struct Process *) FindTask(0))->pr_GlobVec)[UG+1]);
*/
d238 3
a240 1
/*		FIX	} */
d355 2
d423 2
a424 2
requester("Bad node!",((char *)BADDR(volnode->dol_Name))+1,
((char *)BADDR(dp->dvp_DevNode->dol_Name))+1);
d433 1
a433 1
requester("Bad type?!","","");
d620 1
a620 2
	char *bname;
	LONG len;
d622 1
a622 1
	len = strlen(name);
d624 1
a624 18
	Forbid();		/* FIX! use LockDeviceList */
	p = (struct DosList *)			/* UGH! */
	    BADDR(((LONG) ((struct DosInfo *) 
	           ((LONG) BADDR(rootstruct()->rn_Info)))->di_DevInfo));
	while (p)
	{
		/* check devonly flag before compare */
		if (!devonly || p->dol_Type == DLT_DEVICE)
		{
			/* relies on null-terminated BSTR's! */
			bname = (char *) BADDR(p->dol_Name);
			if (*bname == len &&
			    mystricmp(bname+1,name) == SAME)
				break;
		}
		p = (struct DosList *) BADDR(p->dol_Next);
	}
	Permit();		/* FIX! use UnlockDeviceList */
d626 6
d652 1
a652 1
/* FIX!!!!! locking!!!!! */
a691 6

#ifdef NOT_REAL
/* for testing, use my global vector, not the old dos GV */
if (gv)
	gv = TOBPTR(dosbase()->dl_GV);
#endif
@
