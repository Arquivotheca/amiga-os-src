head     36.72;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


36.72
date     92.08.09.16.52.44;  author jesup;  state Exp;
branches ;
next     36.71;

36.71
date     92.07.31.19.39.44;  author jesup;  state Exp;
branches ;
next     36.70;

36.70
date     92.06.23.16.35.12;  author jesup;  state Exp;
branches ;
next     36.69;

36.69
date     92.06.02.23.10.45;  author jesup;  state Exp;
branches ;
next     36.68;

36.68
date     92.05.19.17.16.54;  author jesup;  state Exp;
branches ;
next     36.67;

36.67
date     91.04.23.21.17.43;  author jesup;  state Exp;
branches ;
next     36.66;

36.66
date     91.04.22.17.36.45;  author jesup;  state Exp;
branches ;
next     36.65;

36.65
date     91.03.14.21.30.25;  author jesup;  state Exp;
branches ;
next     36.64;

36.64
date     91.03.12.22.36.14;  author jesup;  state Exp;
branches ;
next     36.63;

36.63
date     91.03.12.22.30.30;  author jesup;  state Exp;
branches ;
next     36.62;

36.62
date     91.03.12.22.27.46;  author jesup;  state Exp;
branches ;
next     36.61;

36.61
date     91.02.28.22.32.53;  author jesup;  state Exp;
branches ;
next     36.60;

36.60
date     91.02.25.17.44.12;  author jesup;  state Exp;
branches ;
next     36.59;

36.59
date     91.02.25.17.36.43;  author jesup;  state Exp;
branches ;
next     36.58;

36.58
date     91.02.19.02.07.52;  author jesup;  state Exp;
branches ;
next     36.57;

36.57
date     91.02.13.19.03.22;  author jesup;  state Exp;
branches ;
next     36.56;

36.56
date     91.01.30.16.30.47;  author jesup;  state Exp;
branches ;
next     36.55;

36.55
date     91.01.22.19.10.14;  author jesup;  state Exp;
branches ;
next     36.54;

36.54
date     91.01.17.14.12.26;  author jesup;  state Exp;
branches ;
next     36.53;

36.53
date     91.01.10.18.55.15;  author jesup;  state Exp;
branches ;
next     36.52;

36.52
date     90.12.21.16.53.09;  author jesup;  state Exp;
branches ;
next     36.51;

36.51
date     90.12.17.22.27.42;  author jesup;  state Exp;
branches ;
next     36.50;

36.50
date     90.12.16.04.33.52;  author jesup;  state Exp;
branches ;
next     36.49;

36.49
date     90.12.06.00.44.28;  author jesup;  state Exp;
branches ;
next     36.48;

36.48
date     90.12.04.06.42.11;  author jesup;  state Exp;
branches ;
next     36.47;

36.47
date     90.12.03.06.20.38;  author jesup;  state Exp;
branches ;
next     36.46;

36.46
date     90.12.02.06.58.35;  author jesup;  state Exp;
branches ;
next     36.45;

36.45
date     90.12.01.19.56.50;  author jesup;  state Exp;
branches ;
next     36.44;

36.44
date     90.12.01.04.02.21;  author jesup;  state Exp;
branches ;
next     36.43;

36.43
date     90.11.27.16.45.59;  author jesup;  state Exp;
branches ;
next     36.42;

36.42
date     90.11.27.01.51.03;  author jesup;  state Exp;
branches ;
next     36.41;

36.41
date     90.11.26.19.46.35;  author jesup;  state Exp;
branches ;
next     36.40;

36.40
date     90.11.21.02.14.43;  author jesup;  state Exp;
branches ;
next     36.39;

36.39
date     90.09.25.16.10.19;  author jesup;  state Exp;
branches ;
next     36.38;

36.38
date     90.09.20.21.31.35;  author jesup;  state Exp;
branches ;
next     36.37;

36.37
date     90.09.20.21.26.15;  author jesup;  state Exp;
branches ;
next     36.36;

36.36
date     90.08.28.01.51.45;  author jesup;  state Exp;
branches ;
next     36.35;

36.35
date     90.07.29.23.59.14;  author jesup;  state Exp;
branches ;
next     36.34;

36.34
date     90.06.12.05.31.35;  author jesup;  state Exp;
branches ;
next     36.33;

36.33
date     90.06.01.01.34.45;  author jesup;  state Exp;
branches ;
next     36.32;

36.32
date     90.06.01.01.23.20;  author jesup;  state Exp;
branches ;
next     36.31;

36.31
date     90.05.31.06.57.56;  author jesup;  state Exp;
branches ;
next     36.30;

36.30
date     90.05.22.16.34.57;  author jesup;  state Exp;
branches ;
next     36.29;

36.29
date     90.05.09.02.01.51;  author jesup;  state Exp;
branches ;
next     36.28;

36.28
date     90.04.18.17.15.56;  author jesup;  state Exp;
branches ;
next     36.27;

36.27
date     90.04.07.04.02.09;  author jesup;  state Exp;
branches ;
next     36.26;

36.26
date     90.04.03.05.03.56;  author jesup;  state Exp;
branches ;
next     36.25;

36.25
date     90.04.03.04.42.05;  author jesup;  state Exp;
branches ;
next     36.24;

36.24
date     90.03.19.17.53.17;  author jesup;  state Exp;
branches ;
next     36.23;

36.23
date     90.03.17.23.50.48;  author jesup;  state Exp;
branches ;
next     36.22;

36.22
date     90.03.05.01.08.32;  author jesup;  state Exp;
branches ;
next     36.21;

36.21
date     90.03.03.02.14.01;  author jesup;  state Exp;
branches ;
next     36.20;

36.20
date     90.02.16.22.12.57;  author jesup;  state Exp;
branches ;
next     36.19;

36.19
date     90.02.02.17.22.46;  author jesup;  state Exp;
branches ;
next     36.18;

36.18
date     90.02.01.04.25.15;  author jesup;  state Exp;
branches ;
next     36.17;

36.17
date     90.01.31.15.14.49;  author jesup;  state Exp;
branches ;
next     36.16;

36.16
date     90.01.29.01.51.32;  author jesup;  state Exp;
branches ;
next     36.15;

36.15
date     90.01.17.21.46.45;  author jesup;  state Exp;
branches ;
next     36.14;

36.14
date     89.12.13.00.44.48;  author jesup;  state Exp;
branches ;
next     36.13;

36.13
date     89.12.11.01.44.57;  author jesup;  state Exp;
branches ;
next     36.12;

36.12
date     89.12.09.11.12.13;  author jesup;  state Exp;
branches ;
next     36.11;

36.11
date     89.12.09.01.45.57;  author jesup;  state Exp;
branches ;
next     36.10;

36.10
date     89.12.08.07.13.36;  author jesup;  state Exp;
branches ;
next     36.9;

36.9
date     89.12.03.14.39.52;  author jesup;  state Exp;
branches ;
next     36.8;

36.8
date     89.12.01.08.10.31;  author jesup;  state Exp;
branches ;
next     36.7;

36.7
date     89.11.22.03.16.02;  author jesup;  state Exp;
branches ;
next     36.6;

36.6
date     89.11.14.01.22.21;  author jesup;  state Exp;
branches ;
next     36.5;

36.5
date     89.10.25.00.00.11;  author jesup;  state Exp;
branches ;
next     36.4;

36.4
date     89.10.24.18.22.19;  author jesup;  state Exp;
branches ;
next     36.3;

36.3
date     89.10.18.04.14.58;  author jesup;  state Exp;
branches ;
next     36.2;

36.2
date     89.10.03.17.53.14;  author jesup;  state Exp;
branches ;
next     36.1;

36.1
date     89.09.16.22.06.32;  author jesup;  state Exp;
branches ;
next     ;


desc
@@


36.72
log
@Use TaggedOpenLibrary
@
text
@/* cli_init.c */

#include <exec/types.h>
#include <exec/io.h>
#include <exec/alerts.h>
#include <exec/memory.h>
#include <exec/execbase.h>
#include <exec/resident.h>
#include "dos/dos.h"
#include "dos/dosextens.h"
#include "dos/filehandler.h"
#include "dos/dostags.h"
#include <utility/tagitem.h>
#include <intuition/preferences.h>
#include <devices/timer.h>
#include <libraries/expansionbase.h>

#include <internal/librarytags.h>

/* Private ROM routine... */
struct Library *TaggedOpenLibrary(LONG);
#pragma syscall TaggedOpenLibrary 32a 001

#include <string.h>
#include <stddef.h>

#include "libhdr.h"
#include "cli_init.h"

/*#include <clib/alib_protos.h>*/
#include <clib/utility_protos.h>
#include <pragmas/utility_pragmas.h>
#include <clib/exec_protos.h>
#include <pragmas/exec_old_pragmas.h>
#include <clib/intuition_protos.h>
#include <pragmas/intuition_pragmas.h>
#include "device_protos.h"
#include "klib_protos.h"
#include "blib_protos.h"
#include "cli_protos.h"
#include "path_protos.h"
#include "env_protos.h"
#include "crp_protos.h"
#include "fault.h"

#define SAME		0		/* for string compares */

#define TOBPTR(x)	(((LONG) (x)) >> 2)


/* external strings that need to be long-aligned */

extern char b_trackname[];	/* contains "\x11trackdisk.device\0" */
extern char b_prompt[];		/* "\4%N> " */
extern char b_filesysname[];	/* "File System" */
extern char b_porthandler[];	/* "l:port-handler */

extern char ramname[];
extern char shellname[];
extern char consolename[];

       char bootshell[] = "BootShell";

#ifdef STRAP_DOESNT
extern struct DosEnvec disk_envvec;	/* must be LW alligned */
#endif

extern LONG run_seglist;
extern LONG newcli_seglist;


/*
void pm(char *string);
void pm(char *string)
{
kprintf("%s\n",string);
}
*/

#define pm(x)

LONG __regargs
cli_init (pkt)
	struct DosPacket *pkt;
{
	LONG *syssegl;
	struct Process *tid;
	struct CommandLineInterface *clip;
	struct MsgPort *task;
	struct RootNode *rootnode;
	struct DosInfo *info;
	struct DosList *bootnode;
	struct CliProcList *cl;
	struct ExpansionBase *eb;
	char *prompt    = &b_prompt[0];
#ifdef STRAP_DOESNT
	char *trackname = &b_trackname[0];
	LONG unit;
#endif

pm("in cli_init");
	eb	= (void *) TaggedOpenLibrary(OLTAG_EXPANSION);
	syssegl = (LONG *) BADDR(seglist());
	tid     = MYPROC;
	clip    = cli();
/*
    // bootnode has been stashed in rootnode at startup
    // The boot node comes over in the fhseg slot
*/
	info = AllocVecPubClear(sizeof(struct DosInfo));

	/* initialize the dos device list semaphore */
	InitSemaphore(&(info->di_DevLock));
	InitSemaphore(&(info->di_EntryLock));
	InitSemaphore(&(info->di_DeleteLock));

	/* used to count of getmem allocating a extra longword!! */
	cl = AllocVecPubClear(TASKTABLESIZE*4 + 4 + sizeof(struct CliProcList));
	if (!cl)
no_mem:		Alert(AN_StartMem|AT_DeadEnd);

	/* Setup my taskid and global task table entry */
	cl->cpl_Array = (struct MsgPort **) (((LONG) cl) + sizeof(*cl));
	cl->cpl_Array[0] = (struct MsgPort *) TASKTABLESIZE;
	cl->cpl_Array[1] = &(tid->pr_MsgPort);
	cl->cpl_First = 1;
	tid->pr_TaskNum = 1;

	/* Wake up intuition - leaves it open forever - no checking */
	/* need to put it into global vector! */
	store_IBase(TaggedOpenLibrary(OLTAG_INTUITION));

	rootnode = rootstruct();

	/* get current time if it was set by BattClock */
	datstamp(&(rootnode->rn_Time));
	if (rootnode->rn_Time.ds_Days <= 1)
	{
		/* not set, make sure it's 0 so the FS will set it */
		rootnode->rn_Time.ds_Days	= 0;
		rootnode->rn_Time.ds_Minute	= 0;
		rootnode->rn_Time.ds_Tick	= 0;
	}
	rootnode->rn_TaskArray		= TOBPTR(cl->cpl_Array);
	rootnode->rn_Info		= TOBPTR(info);
	rootnode->rn_ConsoleSegment	= syssegl[4];	/* aka CLI */
	rootnode->rn_RestartSeg		= syssegl[7];
	rootnode->rn_ShellSegment	= syssegl[8];	/* aka Shell */


	/* set up new unlimited CLI stuff */
	NewList((struct List *) &(rootnode->rn_CliList));
	AddHead((struct List *) &(rootnode->rn_CliList),(struct Node *) cl);

	/* If the boot device is not specified, use DF0   */
	/* If it is specified, add it to the device chain */
	/* can't write over rn_FileHandlerSegment until we read it */

	bootnode = (struct DosList *) rootnode->rn_FileHandlerSegment;
	rootnode->rn_FileHandlerSegment = syssegl[6];
pm("have bootnode");
#ifdef STRAP_DOESNT
	if (bootnode == NULL)
		bootnode = createnode(0,trackname);
#endif
	/* Put bootnode on the devicelist, even if we created it above -- bart*/
	/* carries all the other bootnodes onto the list as well (!) */
	info->di_DevInfo = TOBPTR(bootnode);

	/* Make inactive device node entries */
pm("making node entries");
	make_node_entries(syssegl);

	/* Start up the filesystem tasks. */
	/* Start the boot device - FIX! check for failure */
pm("starting up bootnode");
	task = startup( bootnode, syssegl, 1, eb );

	/* Must be set before doing assigns! */
	tid->pr_FileSystemTask = (APTR) task;
	rootnode->rn_BootProc  = task;

	make_assign_entry("L");
	make_assign_entry("FONTS");
	make_assign_entry("DEVS");
	make_assign_entry("LIBS");
	make_assign_entry("S");
	make_assign_entry("C");
	make_task_assignment( "SYS", ":" );

	/* latebinding to avoid having it stuck on the boot: of a2090 users */
	assignlate( "ENVARC", "sys:prefs/env-archive" );
pm("assigns done");

	/* set the current directory of the boot shell - used to be left 0 */
	/* ignore failure of locateobj - worst that happens is we get 0 */
	CurrentDir(locateobj(":"));

	/* At this point the rest of the boot list should be startup'ed */
	{	struct DosList *nextnode;

		nextnode = (struct DosList *) BADDR(bootnode->dol_Next);
		while (nextnode)
		{
			(void) startup(nextnode, syssegl, 0, eb);
			nextnode = (struct DosList *)BADDR(nextnode->dol_Next);
		}
	}
pm("startups done");

#ifdef STRAP_DOESNT
	/* Start up the standard floppy handlers. */
	for (unit = 0; unit <= MAXUNITS; unit++)
	{
		struct MsgPort *task;
		struct DosList *node;
		struct FileSysStartupMsg *bootstartup;

		/* don't restart the floppy if it was the boot unit */
		bootstartup = (struct FileSysStartupMsg *)
			      BADDR(bootnode->dol_misc.dol_handler.dol_Startup);

		/* null terminated BSTR's! */
		/* checks unit and trackdisk.device */
		if (unit == bootstartup->fssm_Unit &&
		    strcmp(trackname+1,
			   (char *) BADDR(bootstartup->fssm_Device)+1) == SAME)
			continue;

		node = createnode( unit, trackname );
		if (!node)
			continue;

		task = startup( node, syssegl, 0 );
		if (task)
			continue;

		/* No disk unit ... remove structure */
		if (node)
		{ 
/* FIX! use RemDosEntry,etc! */
			   info->di_DevInfo = node->dol_Next;
			   freeVec((char *) BADDR(node->dol_misc.dol_handler.
							dol_Startup));
			   freeVec(node);
		}
	}
#endif

	/* build the segment list */
	{
		LONG ok = TRUE;	/* this avoids lots of tst/bra pairs */

		ok &= makeseg( "CLI",     rootnode->rn_ConsoleSegment, -1);
/* fix! string also used in execute.c */
		ok &= makeseg( bootshell, rootnode->rn_ShellSegment, -1);
		ok &= makeseg( shellname, rootnode->rn_ShellSegment, -1);
/*		ok &= makeseg( "Restart", rootnode->rn_RestartSeg, -1);	*/
		ok &= makeseg( "FileHandler", 	syssegl[6], -1);
		ok &= makeseg( consolename,	syssegl[5], -1);
		ok &= makeseg( ramname,		syssegl[9], -1);

		if (!ok)
			goto no_mem;
	}

	/* do some cli init (all we can before AFTERDOS) */
	/* ROM shell always clears cli_Commandname */
	clip->cli_FailLevel      = CLI_INITIAL_FAIL_LEVEL;
	clip->cli_DefaultStack   = CLI_INITIAL_STACK;
	copyMem(prompt,BADDR(clip->cli_Prompt),*prompt+1);

	/* Initialize ramlib 					     */
	/* Patches vectors in exec to search for modules on disk.    */
	/* We do this before we start spawning off handler processes */
	/* but after the dos library data structures are all set up. */
	/* This also inits all other AFTERDOS items. */
	InitCode(RTF_AFTERDOS, 0);

	/* Read the preferences - don't put up requester for devs: */
	/* should we leave them on?  we REALLY want to have devs:! FIX! */
	tid->pr_WindowPtr = (APTR) -1;
	readprefs();
	tid->pr_WindowPtr = 0;

	/* Sign on message */
	{
		BPTR outs;

		outs = findoutput("CON:///-1/AmigaDOS/Auto/NoClose/Smart");
		if (!outs)
			goto no_mem;
		tid->pr_ConsoleTask = (APTR) (((struct FileHandle *)
				              BADDR(outs))->fh_Type);
		selectoutput(outs);
		selectinput(findinput("*"));
	}
	clip->cli_StandardInput = input();
	clip->cli_CurrentInput  = NULL;

	/* did the bootscreen turn off the startup-sequence? */
	if (!eb || !(eb->Flags & EBF_DOSFLAG))
		clip->cli_CurrentInput   = findinput(":S/startup-sequence");
	if (eb)
	{
		/* hack to force screen to open for 1.3 WB disks */
		/* keeps bitplane stealers from breaking	 */
		/* \r forces a flush				 */
		if (!(eb->Flags & EBF_SILENTSTART))
		{
			/* stupid sierra games are broken by cdir != NULL */
			freeobj(CurrentDir(NULL));
			wrch('\r');
		}
		/* CloseLibrary((struct Library *) eb); don't need to close! */
	}

	if (clip->cli_CurrentInput == NULL)
		clip->cli_CurrentInput = clip->cli_StandardInput;

	clip->cli_StandardOutput = output();
	clip->cli_CurrentOutput  = clip->cli_CurrentOutput;

pm("exiting cli_init");
	/* ROM shell always clears cli_SetName */
	return 0;
}

#ifdef STRAP_DOESNT
/* Create a file system node for unit DFn */

struct DosList * __regargs
createnode (unit,devname)
	LONG unit;
	char *devname;	/* CPTR to NULL terminated BSTR - xxx.device */
{
	struct FileSysStartupMsg *arg;
	struct DosList *node = NULL;
	char name[4];

	arg = AllocVecPubClear(sizeof(struct FileSysStartupMsg));
	if (arg)
	{
		arg->fssm_Unit    = unit;
		arg->fssm_Device  = TOBPTR(devname);	/* xxxx.device */
		arg->fssm_Environ = TOBPTR(&disk_envvec);
		/* flags = 0 */

		strcpy(name,"DF0");
		name[2] += unit;	/* unit = 0..3 */

		/* safe - no locking - no apps up yet */
		node = adddevice(name);
		if (node)
			node->dol_misc.dol_handler.dol_Startup = TOBPTR(arg);
		/* loses arg if adddevice fails! FIX! */
	}
	return node;
}
#endif

/* Create a new file system task instance, or return zero */
/* used to take the current proc's seglist as a parm to get klib/blib - REJ */

struct MsgPort * __regargs
startup (node,syssegl,boottime,eb)
	struct DosList *node;
	LONG *syssegl;
	LONG boottime;
	struct ExpansionBase *eb;
{
	char buf[32];				 /* FIX! maxfilename + 2 */
	char *name = (char *) BADDR(node->dol_Name);
	struct FileSysStartupMsg *start = (void *)
				BADDR(node->dol_misc.dol_handler.dol_Startup);
	struct DosEnvec *env = NULL;
	struct MsgPort *rc;

	if ((LONG) start > 64*4)   /* can't be in the exception table.... */
		env = (void *) BADDR(start->fssm_Environ);

	/* if not specified, use default FS IF (and only if) it's DOS\0 or 1 */
	if (node->dol_misc.dol_handler.dol_SegList == NULL)
	{
		/* make sure the entry exists!!!! */
		if (env && (env->de_TableSize < 16 ||
			    (((env->de_DosType & 0xffffff00) == ID_DOS_DISK) &&
			     ((env->de_DosType & 0xff) <= 127))))
		{
/*
if (env->de_TableSize < 16)
kprintf("Small Table! (%ld, %s)\n",env->de_TableSize,name+1);
*/
			node->dol_misc.dol_handler.dol_SegList = syssegl[6];
		} else {
			/* we have no handler for this partition/drive! */
			/* should we search somewhere? FIX! */
			return NULL;
		}
	}

	/* if not specified, use default FH stack */
	if (node->dol_misc.dol_handler.dol_StackSize <= 0)
		node->dol_misc.dol_handler.dol_StackSize = FH_STACK;

	/* dol_Name MUST be null-terminated BSTR! */
	/* add : to end to make into a legal device name */
	mysprintf(buf,"%s:",(LONG) name+1);

	/* forbid to provide locking for the CC0: test */
	Forbid();
	if (boottime || mystricmp(buf,"CC0:") != SAME ||
	    (eb->Flags & EBF_START_CC0 ? 1 : (eb->Flags |= EBF_START_CC0,0)))
		rc = deviceproc(buf);
	else
		rc = NULL;
	Permit();

	return rc;
}

/* make initial device list entry */
/* if it fails, assign it to the root of the disk (?) */

LONG __regargs
make_task_assignment (name,dir)
	char *name;
	char *dir;
{
	BPTR lock;

	if (!(lock = locateobj(dir)))
		lock = locateobj(":");

	return assign(name,lock);
}

LONG __regargs
make_assign_entry (name)
	char *name;
{
	return make_task_assignment(name,name);
}

/* make node entry for inactive devices */

void __regargs
make_node_entry (name,startup,seglist,handler,stksize,pri,gv)
	char *name;
	LONG startup;
	BPTR seglist;
	char *handler;	/* cptr to BSTR */
	LONG stksize;
	LONG pri;
	LONG gv;
{
	struct DosList *node;

/*kprintf("making node %s\n",name);*/
	/* no locking needed - no apps running yet */
	node = adddevice(name);
	if (node)
	{
		node->dol_misc.dol_handler.dol_Handler   = TOBPTR(handler);
		node->dol_misc.dol_handler.dol_StackSize = stksize;
		node->dol_misc.dol_handler.dol_Priority  = pri;
		node->dol_misc.dol_handler.dol_SegList   = seglist;
		node->dol_misc.dol_handler.dol_Startup   = startup;
		node->dol_misc.dol_handler.dol_GlobVec   = gv;
	}
}

/* make all the node entries */
#define make1(name,startup,hname,stacksize,gv) \
	make_node_entry(name,startup,0,hname,stacksize,0,gv);

/* also needs to be changed in doslib.asm! */
/* C handlers specify stack in BYTES!!!!! (bcpl uses longs) */
#define makec(name,startup,segl) \
	make_node_entry(name,startup,segl,0,CON_STACK<<2,5,-1);

/* gv was TOBPTR(dosbase()->dl_GV) */

void __regargs
makes(name,startup,stacksize)
	char *name;
	LONG startup;
	LONG stacksize;
{
	make1(name,startup,b_porthandler,stacksize,TOBPTR(dosbase()->dl_GV));
}

void __regargs
make_node_entries (syssegl)
	LONG *syssegl;
{
	/* Note that for BCPL tasks stacksize is in LONGs instead of bytes! */
	/* in reverse order of importance */
	makes("PRT", 2, PRT_STACK );
	makes("PAR", 1, PAR_STACK );
	makes("SER", 0, SER_STACK );
	makec("RAW", 1, syssegl[5]);
	makec("CON", 0, syssegl[5]);
	/* RAM is now a C module, since it's in ROM */
	make_node_entry("RAM",0,syssegl[9],0,RAM_STACK*4,10,-1);
}

/* -1: system, 0: loaded cmd */

LONG ASM
makeseg (REG(d1) char *name,REG(d2) BPTR seg,REG(d3) LONG system)
{
	/* struct segment has 4 chars of seg_name at end */
	LONG upb = sizeof(struct Segment)-4 + strlen(name)+1;
	struct Segment *segment;
	BPTR *lv_list;			/* note: BPTR *!!! */

	segment = AllocVecPubClear(upb);
	if (!segment)
		return FALSE;

	segment->seg_UC  = system;	/* -1 is not a command */
	segment->seg_Seg = seg;

	/* copy name to a bstr */
/*	CtoB(name,(((LONG) segment) + (offsetof(struct Segment,seg_Name))));*/

/* lattice offsetof() sucks rocks - I'll cheat - FIX! */
	CtoB(name,(CPTR) (((LONG) segment) +
		   (sizeof(*segment) - sizeof(segment->seg_Name))));

	lv_list = (BPTR *)
	     &(((struct DosInfo *) BADDR(rootstruct()->rn_Info))->di_NetHand);

	Forbid();
	segment->seg_Next = *lv_list;
	*lv_list = TOBPTR(segment);
	Permit();

	return DOSTRUE;
}


/* evil routine - ignore errors */

void __regargs
readprefs ()
{
	struct Preferences prefs;
	BPTR fh;

	fh = findinput("devs:system-configuration");
	if (fh)
	{
		if (read(fh,(char *) &prefs, sizeof(prefs)) == sizeof(prefs))
		{
			MySetPrefs(&prefs,sizeof(prefs));
		}
		endstream(fh);
	} else
		MySetPrefs(&prefs,0);	/* intuition ALWAYS wants this called */
}

/* DOWNCODE! */

ULONG __regargs
MaxCli ()
{
	struct CliProcList *cli;
	ULONG max = 0,curr;

	for (cli = (struct CliProcList *) rootstruct()->rn_CliList.mlh_Head;
	     cli->cpl_Node.mln_Succ;
	     cli = (struct CliProcList *) cli->cpl_Node.mln_Succ)
	{
		for (curr = 0;
		     curr < (LONG) cli->cpl_Array[0];
		     curr++)
		{
			if (cli->cpl_Array[curr])
				max = cli->cpl_First + curr;
		}
	}

	return max;
}

/* DOWNCODE! */

struct Process * ASM
FindCli (REG(d1) ULONG num)
{
	struct CliProcList *cli;
	
	if (num)
	{
	  for (cli = (struct CliProcList *) rootstruct()->rn_CliList.mlh_Head;
	       cli->cpl_Node.mln_Succ;
	       cli = (struct CliProcList *) cli->cpl_Node.mln_Succ)
	  {
		if (num < cli->cpl_First + (LONG) cli->cpl_Array[0])
		{
			if (cli->cpl_Array[num+1 - cli->cpl_First])
				 return (struct Process *)
			          (((LONG) cli->cpl_Array[num+1-cli->cpl_First])
			           - sizeof(struct Task));
			else
				return NULL;
		}
	  }
	}

	return NULL;
}

/* stuff from the old run.b, used in cli.c */
/* the names have been changed to protect the innocent */

/*
// This function is called as initialization for new process
// It returns a value as follows:
// >0         The function QPKT, to be called by the CLI
// <0         Flags used as follows (odd values for compatibility)
// Bit 31     Set to indicate flags
// Bit  3     Set to indicate asynch system call - return pkt early - Added REJ
// Bit  2     Set to indicate the System call (stop cli at EOF from
//	      cli_CurrentInput).  Added REJ.
// Bit  1     Set if user provided input stream
// Bit  0     Set if RUN provided output stream
*/

/* This is really part of the standard C= CLI/Shell. */
/* Because of l:shell-seg, we MUST return valid pointers to BCPL routines!!! */
/* cli_init_run and cli_init_newcli MAY be called from BCPL!! See run.c.     */

LONG __regargs
cli_init_run (struct DosPacket *pkt)
{
	struct Process *tid = MYPROC;
	struct CommandLineInterface *clip  = cli();
	struct CommandLineInterface *oclip = (void *) BADDR(pkt->dp_Arg1);
	BPTR scb = pkt->dp_Arg4;		/* command stream */
	LONG is_run = (pkt->dp_Arg6 == NULL);
	LONG type = pkt->dp_Type;
	BPTR outs = NULL;
	LONG interactive = FALSE;
	LONG rc = 0x80000000;				/* Set flag word */

/*
    // Two cases here. If this is RUN then use new
    // io streams to *. If this is execute then the
    // user must have provided two io streams already;
    // input in arg2 and output in arg3. If input is
    // zero then we run non-interactively.
    // If arg3 is zero we use *, possibly derived from arg2

    // There is now a third case: System.  For system, arg4 has the command
    // stream, and arg2/3 have the input/output filehandles.  We will stuff
    // arg4 into standardinput, arg2/3 into currentinput/output, and set the
    // new bit in flags to indicate system().
    //
    // We tell System() from Execute() by the dp_Type field - RUN_EXECUTE (-1)
    // for Execute(), and RUN_SYSTEM (-2) for System().  BCPL run will
    // pass in a positive ptr.
    // 
    // Asynchronous System() calls will have RUN_SYSTEM_ASYNCH (-3).  They
    // will return the packet immediately, but otherwise work like normal
    // RUN_SYSTEM processes.
    //
    // dp_Arg7 contains tags (if any) used to create this process in CNP.
*/

/*kprintf("in cli_init_run(), type = %ld, is_run = %ld\n", pkt->dp_Type,is_run);*/

	/* make evil assumptions about where the startup packet goes to! */
	/* TRICKY! EVIL casting! */
#ifdef WRONG
	if (!copyvars(tid,(struct Process *)
		(((LONG) ((struct Message *) (pkt->dp_Link))->mn_ReplyPort) -
		 sizeof(struct Task))))
	{
		/* ran out of mem */
		goto error;
	}
#endif
	clip->cli_CurrentInput  = scb;
	clip->cli_StandardInput = scb;		/* Default for both */

	/* What if someone has a NULL pr_ConsoleTask that we inherited? */
	/* We should set it to something safe before opening "*", so we */
	/* don't end up with pr_COS == NULL */

	if (!is_run)
	{
		BPTR instream = pkt->dp_Arg2;
		struct FileHandle *fh = BADDR(instream);

		/* system() or execute() */
		/* pr_ConsoleTask is inherited from parent by default */
		/* what if the file is non-interactive??? FIX! */
		/* ignore instream if it's NULL (ends up as a nil: fh) */
		if (instream != NULL)
		{
			clip->cli_StandardInput = instream;

			/* See if we might possibly have an interactive stream*/
			interactive = isinteractive(instream);

			/* Make the instream the current console task */
/*
 * Lattice/SAS lmk does Execute("",fakefh,NULL).  They then expect it to open
 * "*" on the fakefh's msgport even if the FH isn't interactive.  They guarantee
 * that the fh is right after the msgport, which does not normally happen, so
 * we can key off it.  This is safe since it always used to do this in all
 * cases.
 */
/*
 * Runback and many WB programs use Execute("command",NILfh,NILfh).  We must
 * make that clear ConsoleTask like it used to.
 */

/*
kprintf("setting consoletask for execute/system, %s inter, fh%s=msgport+1\n",
interactive ? "" : "not", 
(void *)
(((LONG) ((struct MsgPort *) ((struct FileHandle *) BADDR(instream))->fh_Type))
+ sizeof(struct MsgPort))
==
BADDR(instream) ? "=" : "!");
kprintf(" (msgport = 0x%lx, fh = 0x%lx, ConsoleTask was 0x%lx)\n",
((struct FileHandle *) BADDR(instream))->fh_Type, BADDR(instream),
tid->pr_ConsoleTask);
*/
			if (interactive || !fh->fh_Type ||
			    (((LONG) fh) ==
			     (((LONG) fh->fh_Type) + sizeof(struct MsgPort))))
			{
				tid->pr_ConsoleTask = (APTR) fh->fh_Type;
				if (fh->fh_Type) {
				    sendpkt3(fh->fh_Type,ACTION_CHANGE_SIGNAL,
					     fh->fh_Arg1,
					     (LONG) &(tid->pr_MsgPort),0);
				}
			}

			/* means the shell will NOT close StandardInput */
			rc |= 2;		/* Set bit 1 */
		} else {
			/* System/Execute called with NULL input stream */
			/* provide one to make it look like a batch.	*/

			instream = findstream("NIL:",MODE_OLDFILE);
			if (instream)
				clip->cli_StandardInput = instream;

			/* we DON'T set the flag, which means the shell */
			/* will close it in cleanup.			*/
		}
		outs = pkt->dp_Arg3;
	}

	/* note: for Run, outs == NULL here */
	if (outs == NULL)
	{
		/* causes the shell to close StandardOutput on cleanup */
		rc |= 1;	/* Set bit 0 (we're providing output stream) */

		/* if he redirected output of run to somewhere that's */
		/* interactive, open * on it for run output.  If he   */
		/* redirected to NIL:, redirect to NIL: and clear     */
		/* pr_ConsoleTask.				      */
		if (is_run)
		{
			/* arg3 is the output stream for the Run command */

			if (oclip->cli_StandardOutput == pkt->dp_Arg3) {
				/* output not redirected */
				goto open_star;

			} else if (isinteractive(pkt->dp_Arg3)) {
				/* output redirected to interactive fs */
				tid->pr_ConsoleTask = (APTR)
					((struct FileHandle *)
						BADDR(pkt->dp_Arg3))->fh_Type;
				goto open_star;

			} else if (((struct FileHandle *)
				    BADDR(pkt->dp_Arg3))->fh_Type) {
			    /* output was redirected to a non-interactive fs */
			    /* open * on normal ConsoleTask output */
				goto open_star;

			} else {
				/* output was redirected to NIL: */
				/* else we fall out, and end up opening NIL: */
				tid->pr_ConsoleTask = NULL;
			}
		} else {
open_star:		/* not run - system or execute */
/*if (!is_run)
kprintf("opening * for execute/system, consoletask = 0x%lx\n",
tid->pr_ConsoleTask);*/
			outs = findoutput("*");
/*kprintf("opened *, result = 0x%lx %s\n",outs,
((struct FileHandle *) BADDR(outs))->fh_Type ? "" : "(actually nil:)");*/
		}
	}
	if (outs == NULL)
		outs = findoutput("NIL:");
	if (outs == NULL)
	{
error:		/* boy is memory tight! */
		returnpkt(pkt,0,getresult2());
		setresult2((LONG) tid);
		return (LONG) deletetask;   /* might get called by shell-seg */
	}

	/* set background for System() Asynch, Run, and Execute(), but not */
	/* for System() Synch! */
	/* this is the first cut - modified by RUN_SYSTEM below */
	clip->cli_Background = (interactive && isinteractive(outs) ?
				FALSE : DOSTRUE);

	/* set flag to tell shell not to read commands from StandardInput */
	if (type == RUN_SYSTEM)
	{
		clip->cli_Background = FALSE;
		rc |= 4;
	} else if (type == RUN_SYSTEM_ASYNCH)
	{
		clip->cli_Background = DOSTRUE;	/* probably redundant */
		rc &= ~2;
		rc |= (1 | 4 | 8);	/* return pkt early, close files */
	}

	/* Initialise CD to SYS: unless spawned from another CLI */
	/* old currentdir was NULL (started by createtask) */
	/* must do AFTER all possible failures (see execute.c for reason) */
	/* (shell unlocks currentdir on failure, and we want system() to) */
	CurrentDir(pkt->dp_Arg5);
	pkt->dp_Arg5 = NULL;		/* so it can't be unlocked by System */
	pkt->dp_Arg4 = NULL;		/* ditto, for command scb */

	run_init_clip(clip, outs, oclip, pkt);

	/* null out the "current program" entry */
	((LONG *) BADDR(seglist()))[3] = NULL; 

	setresult2((LONG) pkt);	/* to be passed to qpkt */

/*kprintf("Setting background to %ld\n",clip->cli_Background);
kprintf("CurrentInput = 0x%lx, StandardInput = 0x%lx\n",
clip->cli_CurrentInput,clip->cli_StandardInput);*/

	/* might get called by shell-seg */
/*
kprintf("returning 0x%lx\n",is_run ? (LONG) bcpl_qpkt : rc);
{ int i; for (i  = 0; i < sizeof(*clip)/4; i++) {
kprintf("0x%lx ",((long *) clip)[i]);
if ((i+1)%4 == 0) kprintf("\n");}
if ((i+2)%4 != 0) kprintf("\n");
}
*/
	return (is_run ? (LONG) bcpl_qpkt : rc);
}

/*
// Initialise the CLI globals. We copy what we can from an existing
// CLI if possible, otherwise we create new versions as required.
// We pass the CLI structure pointer clip, the output stream, and
// the parents CLI structure (or zero).
*/

void __regargs
run_init_clip (struct CommandLineInterface *clip, BPTR outs,
	       struct CommandLineInterface *oclip,
	       struct DosPacket *pkt)
{
	UBYTE temp[256];
	UBYTE *prompt, *setname;
	LONG defstk = 0;
	BPTR cmddir = NULL;
	struct TagItem *tags = (void *) pkt->dp_Arg7;
	struct TagItem *tag  = NULL;

	/* RUN_xxxx are all less than 0 */
	if (pkt->dp_Type < 0)		/* fix! addresses >2gig! */
	{
		defstk = getTagData(NP_StackSize,0,tags) >> 2;
		tag = findTagItem(NP_Path,tags);
		if (tag)
			cmddir = tag->ti_Data;
	}

	if (oclip == NULL)
	{
		prompt = "\4%N> ";
		setname= "\4SYS:";
		if (defstk == 0)
			defstk = CLI_INITIAL_STACK;
	} else {
		prompt = (char *) BADDR(oclip->cli_Prompt);
		setname= (char *) BADDR(oclip->cli_SetName);
		if (defstk == 0)
			defstk = oclip->cli_DefaultStack;

		/* don't copy if he speced it - CNP set it up */
		if (!tag)
			cmddir = copylist(oclip->cli_CommandDir);
	}

	/* if NFL fails, use default current dir name */
	/* probably overkill - doesn't cause requesters */
	if (!myNameFromLock(currentdir(FALSE,NULL),temp,sizeof(temp)))
		BtoC(setname,temp);		/* put C version in temp */
	SetCurrentDirName(temp);

	clip->cli_StandardOutput = outs;
	clip->cli_CurrentOutput  = outs;
	
	clip->cli_FailLevel      = CLI_INITIAL_FAIL_LEVEL;
	((char *) BADDR(clip->cli_CommandFile))[0] = '\0';
	clip->cli_DefaultStack   = defstk;
	clip->cli_CommandDir     = cmddir;
	clip->cli_Module	 = 0;
	BtoC(prompt,temp);
	SetPrompt(temp);
}

/* copy a path list */

/* DOWNCODE! */

BPTR __regargs
copylist (BPTR p)
{
	BPTR list = NULL;		/* fake terminating node */
	BPTR *liste = &list;		/* ptr to link of previous node */
	LONG *node;

	/* funky bptr-list following! */
	while (p = (BPTR) BADDR(p))
	{
		node = AllocVecPubClear(2*4);	/* used to be getvec(1)! */
		if (node == NULL)
			break;		/* No more memory */
		/* node[0] == 0   */
		node[1] = copydir(((LONG *)p)[1]);
		*liste  = TOBPTR(node);
		liste	= node;
		p       = ((LONG *)p)[0];
	}

	return list;
}


/* stuff from the old newcli.b, used in cli.c */
/* the names have been changed to protect the innocent */

LONG __regargs
cli_init_newcli (struct DosPacket *pkt)
{
	struct Process *tid = MYPROC;
	struct CommandLineInterface *clip = cli();
	struct CommandLineInterface *clio = (void *) BADDR(pkt->dp_Arg4);
	BPTR scb;
	char *prompt  = (char *) BADDR(clio->cli_Prompt);
/*	char *setname = (char *) BADDR(clio->cli_SetName); */
	char *filename;
	char temp[256];

	/* Set up currentdir and standard tasks */
	currentdir(TRUE,pkt->dp_Arg1);
	tid->pr_FileSystemTask = (APTR) pkt->dp_Arg5;
	tid->pr_WindowPtr = NULL;		/* Always use WB window */

	/* Set up new CLI io streams. The first is to the new window. */
	/* it must be passed in as a BSTR, I'm afraid */
	filename = (char *) BADDR(((LONG *) BADDR(pkt->dp_Arg2))[0]);

	/* don't overwrite cli_CommandDir, free duplicate path if it exists */
	/* careful!  2.0-2.02 shell duplicates value into dp_Arg3! */
	/* MUST do this before any possible exit */
	if (!clip->cli_CommandDir)
		clip->cli_CommandDir = pkt->dp_Arg3;
	else if (pkt->dp_Arg3 && pkt->dp_Arg3 != clip->cli_CommandDir)
		freepath(pkt->dp_Arg3);

	/* can't convert in place */
	BtoC(filename,temp);
/*kprintf("opening %s\n",temp);*/
	scb = findinput(temp);

	if (scb && !(isinteractive(scb))) /* FIX! remove isinter... test!? */
	{				  /* see pr_ConsoleTask below!! */
/*kprintf("not interactive\n");*/
		endstream(scb);
		setresult2(ERROR_BAD_STREAM_NAME);
		scb = NULL;
	}

	if (!scb)			/* Panic - no window */
	{
/*kprintf("no scb\n");*/
error:
/*kprintf("can't make newcli\n");*/
		/* unset currentdir so it doesn't get unlocked */
		currentdir(TRUE,NULL);
		returnpkt(pkt,0,getresult2());
		setresult2((LONG) tid);
		return (LONG) deletetask;   /* might get called by shell-seg */
	}

	clip->cli_StandardInput = scb;
	selectinput(clip->cli_StandardInput);

	/* Set the default current input */
	clip->cli_CurrentInput = clip->cli_StandardInput;

	/* Patch consoletask so that subsequent references */
	/* to * refer to the new window. */
	/* NOTE: scb must be interactive (test is above) */
	tid->pr_ConsoleTask = (APTR) 
			      ((struct FileHandle *) BADDR(scb))->fh_Type;

	/* Now use it */
	/* Pipes?  where whould output go?  Parent's output! */
	clip->cli_StandardOutput = findoutput("*");
	if (clip->cli_StandardOutput == NULL)
	{
/*kprintf("can't open \"*\"\n");*/
		/* very wierd */
		endread();
		goto error;
	}

	selectoutput(clip->cli_StandardOutput);
	clip->cli_CurrentOutput = clip->cli_StandardOutput;
	clip->cli_CurrentInput  = clip->cli_StandardInput;

	/* Set up a possible initial command file */
	/* FIX! should we allow FH's to be passed?? */
	filename = (char *) BADDR(((LONG *) BADDR(pkt->dp_Arg2))[1]);
	if (filename)
	{
		/* must be passed in as BSTR, I'm afraid */

		/* can't convert in place */
		BtoC(filename,temp);
		scb = findinput(temp);

		if (!scb)
		{
			filename = &temp[0];	/* need ptr to array of args */
			VPrintf(getstring(STR_CANT_OPEN_FROM),
				(LONG *) &filename);
		} else
			clip->cli_CurrentInput = scb;
	} else {
		/* test default file */
		scb = finddefault("s:shell-startup");
		if (scb != NULL)
			clip->cli_CurrentInput = scb;
	}

	/* Set up other CLI values */
	clip->cli_Background = FALSE;
	clip->cli_ReturnCode = 0;
	clip->cli_Result2    = 0;
	clip->cli_Module     = NULL;
	clip->cli_FailLevel  = clio->cli_FailLevel;
	((char *) BADDR(clip->cli_CommandFile))[0] = '\0';
	clip->cli_DefaultStack = clio->cli_DefaultStack;

	/* if NFL fails, use the parent's current dir name */
	/* probably overkill */
	if (myNameFromLock(currentdir(FALSE,NULL),temp,sizeof(temp)))
		SetCurrentDirName(temp);
	else {
		char *setname = (char *) BADDR(clio->cli_SetName);
		copyMem(setname,BADDR(clip->cli_SetName),*setname+1);
	}

	copyMem(prompt,BADDR(clip->cli_Prompt),*prompt+1);

	VPrintf(getstring(STR_NEW_CLI_PROCESS), &(tid->pr_TaskNum));

	/* null out the "current program" entry */
	((LONG *) BADDR(seglist()))[3] = NULL;

	setresult2((LONG) pkt);

	return (LONG) bcpl_qpkt;	/* might get called by shell-seg! */
}

@


36.71
log
@Made the initial window as tall as display clip (needs new con-handler!)
@
text
@d18 6
d102 1
a102 1
	eb	= (void *) OpenLibrary("expansion.library",0);
d131 1
a131 1
	store_IBase(OpenLibrary("intuition.library",0L));
@


36.70
log
@Make initial window as wide and tall as the screen
@
text
@d284 1
a284 1
		outs = findoutput("CON:///9999/AmigaDOS/Auto/NoClose/Smart");
@


36.69
log
@FindCliProc(0) should return NULL, even though it's silly input
@
text
@d284 1
a284 1
		outs = findoutput("CON:0/0/640/200/AmigaDOS/Auto/NoClose/Smart");
@


36.68
log
@DOS\* versions less than 127 are assumed to be in rom (if seglist is NULL)
@
text
@d589 1
a589 3
	for (cli = (struct CliProcList *) rootstruct()->rn_CliList.mlh_Head;
	     cli->cpl_Node.mln_Succ;
	     cli = (struct CliProcList *) cli->cpl_Node.mln_Succ)
d591 4
d604 1
@


36.67
log
@Changed return codes back, don't leave currentdir set on failure of
cli_init_newcli.
@
text
@d96 4
a99 3
	syssegl  = (LONG *) BADDR(seglist());
	tid      = MYPROC;
	clip     = cli();
d171 1
a171 1
	task = startup( bootnode, syssegl );
d199 2
a200 2
			 startup(nextnode, syssegl );
			 nextnode = (struct DosList *)BADDR(nextnode->dol_Next);
d228 1
a228 1
		task = startup( node, syssegl );
a295 1
	eb = (void *) OpenLibrary("expansion.library",0);
d309 1
a309 1
		CloseLibrary((struct Library *) eb);
d360 1
a360 1
startup (node,syssegl)
d363 2
d371 1
d382 1
a382 1
			     ((env->de_DosType & 0xff) <= 3))))
d404 10
a413 1
	return deviceproc(buf);
@


36.66
log
@FIx return codes for cli_init_xxx errors (-1 instead of 0)
@
text
@d792 1
a792 1
		returnpkt(pkt,-1,getresult2());
d987 3
a989 1
		returnpkt(pkt,-1,getresult2());
@


36.65
log
@Clear arg4/arg5 in cli_init_run if we succeed.
Use namefromlock that doesn't pop requesters
downcoded finddefault
@
text
@d792 1
a792 1
		returnpkt(pkt,0,getresult2());
d987 1
a987 1
		returnpkt(pkt,0,getresult2());
@


36.64
log
@Fixed casts
@
text
@d817 2
d820 2
d892 2
a893 2
	/* probably overkill */
	if (!NameFromLock(currentdir(FALSE,NULL),temp,sizeof(temp)))
d1016 2
a1044 1
	clip->cli_CurrentOutput = clip->cli_StandardOutput;
d1047 2
a1049 1
	clip->cli_Result2    = 0;
a1051 1
	clip->cli_Module     = NULL;
d1055 1
a1055 1
	if (NameFromLock(currentdir(FALSE,NULL),temp,sizeof(temp)))
a1073 13
BPTR __regargs
finddefault (char *file)
{
	struct Process *tid = MYPROC;
	APTR wp  = tid->pr_WindowPtr;
	BPTR scb;

	tid->pr_WindowPtr = (APTR) -1;		/* don't put up requesters! */
	scb = findinput( file );
	tid->pr_WindowPtr = wp;

	return scb;
}
@


36.63
log
@Make sure FileSysStartupMsg is real, not a random integer <= 64
@
text
@d370 1
a370 1
	if (start > 64*4)	/* can't be in the exception table.... */
d399 1
a399 1
	mysprintf(buf,"%s:",name+1);
@


36.62
log
@Added checks for dos2/dos3
@
text
@d370 1
a370 1
	if (start)
@


36.61
log
@Open a NIL: stream if the user passed NULL to Execute() or System()
Makes it consistent with non-NULL regarding Batch state
@
text
@d378 2
a379 2
			    env->de_DosType == ID_DOS_DISK ||
			    env->de_DosType == ID_FFS_DISK))
@


36.60
log
@Minor code movement, use mysprintf instead of in-line
@
text
@d724 2
d727 10
d744 1
@


36.59
log
@Added initsemaphore for new delete sem
@
text
@a98 1
	rootnode = rootstruct();
d126 2
d399 1
a399 3
	strcpy(buf,name+1);
	buf[*name]     = ':';
	buf[*name + 1] = '\0';
@


36.58
log
@Use copyMem instead of memcpy
Free initial currentdir is non-silent boot (sierra fix)
@
text
@d109 1
@


36.57
log
@Added Silent start bt
@
text
@d262 1
a262 1
	memcpy((char *) BADDR(clip->cli_Prompt),prompt,*prompt+1);
d302 3
d306 1
a306 1

d1041 1
a1041 1
		memcpy((char *) BADDR(clip->cli_SetName),setname,*setname+1);
d1044 1
a1044 1
	memcpy((char *) BADDR(clip->cli_Prompt),prompt,*prompt+1);
@


36.56
log
@Removed a type warning
@
text
@d297 7
d305 1
@


36.55
log
@smart refresh initial window, remove commented-out copyright msg
@
text
@d709 2
a710 1
					     fh->fh_Arg1,&(tid->pr_MsgPort),0);
@


36.54
log
@removed NP_CurrentInput/Output
@
text
@d281 1
a281 1
		outs = findoutput("CON:0/0/640/200/AmigaDOS/Auto/NoClose");
a287 5

/*
		writes((LONG) "Copyright \xA9" "1990 Commodore-Amiga, Inc.\n"
		              "All rights reserved.\nExperimental 1.4 C-Dos\n");
*/
@


36.53
log
@We don't use proto files!  use clib/pragma
@
text
@d642 2
d659 1
a659 2
	clip->cli_CurrentInput  = getTagData(NP_CurrentInput,scb,
					     (struct TagItem *) pkt->dp_Arg7);
d712 4
d874 1
a874 1
	clip->cli_CurrentOutput  = getTagData(NP_CurrentOutput,outs,tags);
@


36.52
log
@Added some comments, extra braces
sets pr_ConsoleTask to NULL for run >nil: again (breaks run >nil lmk)
@
text
@d29 2
a30 1
#include "proto/intuition.h"
@


36.51
log
@FreeVec->freeVec (space saving)
@
text
@d708 1
d710 1
a710 1

d715 2
d727 2
d749 1
a749 1
/*				tid->pr_ConsoleTask = NULL;*/
d970 1
@


36.50
log
@exec_old_pragmas.h
Added NP_CurrentInput (will probably change to NP_StandardInput)
@
text
@d55 2
d233 1
a233 1
			   FreeVec((char *) BADDR(node->dol_misc.dol_handler.
d235 1
a235 1
			   FreeVec(node);
d246 1
a246 1
		ok &= makeseg( "BootShell", rootnode->rn_ShellSegment, -1);
@


36.49
log
@Pass tags into init_clip, let them override normal values
@
text
@d28 1
a28 1
#include <pragmas/exec_pragmas.h>
d654 2
a655 1
	clip->cli_CurrentInput  = scb;
d861 1
a861 1
	clip->cli_CurrentOutput  = outs;
@


36.48
log
@added some debugs (commented out)
@
text
@d12 2
d25 2
d614 1
d770 1
a770 1
	if (pkt->dp_Type == RUN_SYSTEM)
d774 1
a774 1
	} else if (pkt->dp_Type == RUN_SYSTEM_ASYNCH)
d785 1
a785 1
	run_init_clip(clip, outs, oclip);
d817 2
a818 1
	       struct CommandLineInterface *oclip)
d822 4
a825 2
	LONG defstk;
	BPTR cmddir;
d827 9
d840 2
a841 2
		defstk = CLI_INITIAL_STACK;
		cmddir = NULL;
d845 6
a850 2
		defstk = oclip->cli_DefaultStack;
		cmddir = copylist(oclip->cli_CommandDir);
d861 1
@


36.47
log
@Get datestamp from battclock, add bootshell entry, and
more hacks to consoletask.
Set cli_module to 0 for cli_init_run
@
text
@d636 2
d792 8
@


36.46
log
@Add check for NIL: input FH and change consoletask for it
fixes WB programs, and runback, etc
@
text
@d119 9
a127 2
	/* assume rn_Time.Mins and Ticks == 0 REJ */
	rootnode->rn_Time.ds_Days	= 0;
d134 1
d239 2
d682 1
d695 3
a697 1
			if (interactive || !fh->fh_Type)
d785 4
d834 1
@


36.45
log
@added turned-off debugging code, removed uneeded test of consoletask
@
text
@d647 1
d669 4
d684 2
a685 4
			if (interactive)
				tid->pr_ConsoleTask = (APTR)
						((struct FileHandle *)
						      BADDR(instream))->fh_Type;
@


36.44
log
@Better handling of consoletask and whether to open NIL:.
Can't (yet) set consoletak to NULL on run >NIL: because of lmk(yuck)
@
text
@d660 19
d722 6
a727 2
			if (tid->pr_ConsoleTask != NULL)
				outs = findoutput("*");
@


36.43
log
@Bumped ram priority again (10 this time, same as filesystems)
@
text
@a654 3
			/* Make the instream the current console task */
			tid->pr_ConsoleTask = (APTR) ((struct FileHandle *)
						BADDR(instream))->fh_Type;
d658 7
d671 35
a705 5
		rc |= 1;	/* Set bit 0 */
		/* if he used ANY output redirection for Run, use NIL: */
		if (tid->pr_ConsoleTask != NULL &&
		    (!is_run || (oclip->cli_StandardOutput == pkt->dp_Arg3)))
			outs = findoutput("*");
@


36.42
log
@Bryce here.  Remove change made durin g frost.
@
text
@d464 1
a464 1
	make_node_entry("RAM",0,syssegl[9],0,RAM_STACK*4,0,-1);
@


36.41
log
@Changed ram priority to 5
@
text
@d464 1
a464 1
	make_node_entry("RAM",0,syssegl[9],0,RAM_STACK*4,5,-1);
@


36.40
log
@Added the rest of the handlers to the resident list
Fixed MaxCLI
Changed prototype for FindCLI
Made sure Commanddir gets freed on errors, and no duplicates are left
Made strings localized
use NameFromLock to get initial directory names
@
text
@d464 1
a464 1
	make_node_entry("RAM",0,syssegl[9],0,RAM_STACK*4,0,-1);
@


36.39
log
@Fix path handling on newcli - don't overwrite, free redundant
@
text
@d22 1
a22 1
#include <clib/alib_protos.h>
d33 1
d47 4
d105 2
a106 1
/* FIX! check allocations! */
d119 2
a120 1
	/* assume rootnode->rn_Time == 0 REJ */
d227 2
a228 4
	makeseg( "CLI", rootnode->rn_ConsoleSegment, -1);
	makeseg( "Shell", rootnode->rn_ShellSegment, -1);
	makeseg( "Restart", rootnode->rn_RestartSeg, -1);	/* FIX! */
	makeseg( "FileHandler", syssegl[6], -1);
d230 11
d265 2
d535 2
a536 2
		for (curr = cli->cpl_First;
		     curr < cli->cpl_First + (LONG) cli->cpl_Array[0];
d540 1
a540 1
				max = curr;
d550 1
a550 1
FindCli (REG(d1) LONG num)
d727 1
a727 1
	UBYTE temp[256];	/* FIX! */
d735 1
a735 1
		setname= "\4SYS:";	/* FIX! should use NameFromLock! */
d745 6
a758 2
	BtoC(setname,temp);
	SetCurrentDirName(temp);
d788 1
d800 1
a800 1
	char *setname = (char *) BADDR(clio->cli_SetName);
d802 1
a802 1
	char *newname;
d813 7
a819 3
	newname = AllocVecPub(*filename + 1);
	if (!newname)
		goto error;
d822 3
a824 4
	BtoC(filename,newname);
/*kprintf("opening %s\n",newname);*/
	scb = findinput(newname);
	FreeVec(newname);
a873 3
		newname = AllocVecPub(*filename + 1);
		if (!newname)
			goto error;	/* FIX!!!!!!! close fh's!!!! */
d876 2
a877 2
		BtoC(filename,newname);
		scb = findinput(newname);
a878 1
		/* FIX! language! */
d880 5
a884 2
			writef("Cannot open From file %S\n",(LONG)newname);
		else
a885 2

		FreeVec(newname);
d903 8
a910 6
	/* don't overwrite cli_CommandDir, free duplicate path if it exists */
	/* careful!  2.0-2.02 shell duplicates value into dp_Arg3! */
	if (!clip->cli_CommandDir)
		clip->cli_CommandDir = pkt->dp_Arg3;
	else if (pkt->dp_Arg3 && pkt->dp_Arg3 != clip->cli_CommandDir)
		freepath(pkt->dp_Arg3);
a911 2
	/* FIX!!We should NameFromLock() on currentdir here! */
	memcpy((char *) BADDR(clip->cli_SetName),setname,*setname+1);
d914 1
a914 1
	writef("New CLI process %N\n", tid->pr_TaskNum);
@


36.38
log
@Move FreeVec to after the last use of it.
Remove obsolete conversion back to BSTR (it's no longer converted in place).
@
text
@d32 1
d850 1
a850 1
			goto error;
a872 1
	clip->cli_CommandDir = pkt->dp_Arg3;
d879 7
@


36.37
log
@use cstring version, not bcpl
@
text
@a853 1
		FreeVec(newname);
d861 1
a861 1
		CtoBstr(filename);
@


36.36
log
@Set the current dir of the initial CLI to SYS:
@
text
@d858 1
a858 1
			writef("Cannot open From file %S\n",(LONG)filename);
@


36.35
log
@comment change
@
text
@d163 4
@


36.34
log
@Commented out code that may have lead to memory leak
It was a second spurious variable copy in cli_init_run (you ended
up with two of each variable.)
@
text
@d591 1
a591 1
    // arg4 into currentinput, arg2/3 into standardinput/output, and set the
@


36.33
log
@uncommented SetPrefs
@
text
@d605 1
d613 1
@


36.32
log
@Made the envarc late-binding assign go to sys:... instead of :...
commented out setprefs (will be back soon...)
@
text
@d497 1
a497 1
;/*		MySetPrefs(&prefs,0);	/* intuition ALWAYS wants this called */
@


36.31
log
@Make envarc deferred, allways call SetPrefs.
@
text
@d160 1
a160 1
	assignlate( "ENVARC", ":prefs/env-archive" );
d497 1
a497 1
		MySetPrefs(&prefs,0);	/* intuition ALWAYS wants this called */
@


36.30
log
@Use MYPROC macro
@
text
@d158 3
a160 1
	make_task_assignment( "ENVARC", ":prefs/env-archive" );
d489 1
a489 4
	if (!fh)
		return;

	if (read(fh,(char *) &prefs, sizeof(prefs)) == sizeof(prefs))
d491 7
a497 3
		MySetPrefs(&prefs);
	}
	endstream(fh);
@


36.29
log
@PubClear, MYPROC, remove DFn: code, since strap does it for us (ifdef)
@
text
@d84 1
a84 1
	tid      = (struct Process *) (*((struct ExecBase **) 4))->ThisTask;
@


36.28
log
@removed some debugs, don't modify names for opens in place
allocate space instead and convert
@
text
@d22 1
d45 1
d47 1
d52 1
d57 1
a57 2
kprintf("%s: Available fast mem %ld bytes, chip %ld bytes\n",
string,AvailMem(MEMF_FAST), AvailMem(MEMF_CHIP));
a66 2
	char *trackname = &b_trackname[0];
	char *prompt    = &b_prompt[0];
d76 3
d80 1
d82 1
d91 1
a91 1
	info = AllocVec(sizeof(struct DosInfo),MEMF_PUBLIC|MEMF_CLEAR);
d98 1
a98 2
	cl = AllocVec(TASKTABLESIZE*4 + 4 + sizeof(struct CliProcList),
		      MEMF_PUBLIC|MEMF_CLEAR);
d129 2
d133 1
a133 1

d139 1
d144 1
d159 1
d171 1
d173 1
d210 1
d215 1
a215 1
	makeseg( "Restart", rootnode->rn_RestartSeg, -1);
d268 1
d273 1
d285 1
a285 1
	arg = AllocVec(sizeof(struct FileSysStartupMsg),MEMF_PUBLIC|MEMF_CLEAR);
d304 1
d393 1
d452 1
a452 1
	segment = AllocVec(upb,MEMF_PUBLIC|MEMF_CLEAR);
a454 1
		/* abort(AN_StartMem|AT_DeadEnd);	/* hah - FIX! */
d478 1
a478 1
/* evil routine */
d497 2
d521 2
d731 2
d743 1
a743 1
		node = AllocVecPub(2*4);	/* used to be getvec(1)! */
d746 1
a746 1
		node[0] = NULL;		/* BPTR to next node */
d762 1
a762 1
	struct Process *tid = (struct Process *) FindTask(0);
d889 1
a889 1
	struct Process *tid = (struct Process *) FindTask(0);
@


36.27
log
@added ENVARC: assign
@
text
@a84 1
pm("start");
d86 1
a86 1
pm("info");
a93 1
pm("tasktab");
d106 1
a106 1
pm("intuition");
d133 1
a133 1
pm("make nodes");
a136 1
pm("startup");
a149 1
pm("assigns");
d161 1
a161 1
pm("other startups");
a197 1
pm("floppies");
a203 1
pm("segs");
a216 1
pm("afterdos");
a222 1
pm("prefs");
a238 1
pm("console");
a255 1
pm("exit");
a424 1
/* LOCKING??!!! FIX! - use forbid locking */
d453 1
a453 1
	/* no locking needed, as this is only called from cli_init */
d456 1
d603 1
d635 6
d643 2
d646 1
a646 1
	else if (pkt->dp_Type == RUN_SYSTEM_ASYNCH)
d648 1
a652 5
	/* MUST set background for System()! (stupid shell!) */
	clip->cli_Background = (interactive && isinteractive(outs) &&
				!(rc & 4)) ?
			       FALSE : DOSTRUE;

d747 1
d758 3
a760 3
	BtoCstr((CPTR) filename);
	scb = findinput(filename);
	CtoBstr(filename);
d762 6
d770 1
d778 4
a781 1
error:		returnpkt(pkt,0,getresult2());
d802 1
d816 3
a818 1
		BtoCstr((CPTR) filename);
d820 6
a825 1
		scb = findinput(filename);
@


36.26
log
@Init Entry semaphore, make warning go away, check if table is big enough
to contain a DOSType before using it.
@
text
@d152 1
@


36.25
log
@for rcs 4.x header change
@
text
@d90 1
d194 1
d224 3
a226 1
	/* Read the preferences */
d228 1
d230 1
d319 3
a321 1
		if (env && (env->de_DosType == ID_DOS_DISK ||
d324 4
@


36.24
log
@Fixed off-by-one in MaxCLI
@
text
@@


36.23
log
@Many fixes and rearngements.
Fixed FindCli, MaxCli, moved InitResident, fixed >20 cli stuff, etc
Changed startup() so I don't use OFS for non-DOS\0 or \1 partitions.
@
text
@d493 1
a493 1
				max = curr - 1;
@


36.22
log
@*** empty log message ***
@
text
@d29 2
a71 1
	struct MsgPort **tasktab;
d92 2
a93 2
	tasktab = AllocVec(TASKTABLESIZE*4 + 4 + sizeof(struct CliProcList),
			   MEMF_PUBLIC|MEMF_CLEAR);
d98 4
a101 2
	tasktab[0] = (struct MsgPort *) TASKTABLESIZE;
	tasktab[1] = &(tid->pr_MsgPort);
d109 1
a109 1
	rootnode->rn_TaskArray		= TOBPTR(tasktab);
a115 3
	cl = (struct CliList *) &tasktab[TASKTABLESIZE+1];	/* TRICKY! */
	cl->cpl_Array = (struct MsgPort **) tasktab;
	cl->cpl_First = 1;
d201 13
a224 6
	/* build the segment list */
	makeseg( "CLI", rootnode->rn_ConsoleSegment, -1);
	makeseg( "Shell", rootnode->rn_ShellSegment, -1);
	makeseg( "Restart", rootnode->rn_RestartSeg, -1);
	makeseg( "FileHandler", syssegl[6], -1);
pm("segs");
d236 1
a236 1
		writes((LONG) "Copyright \xA9" "1989 Commodore-Amiga, Inc.\n"
d248 2
a256 8
	clip->cli_FailLevel      = CLI_INITIAL_FAIL_LEVEL;

	/* ROM shell always clears cli_Commandname */

	clip->cli_DefaultStack   = CLI_INITIAL_STACK;

	memcpy((char *) BADDR(clip->cli_Prompt),prompt,*prompt+1);

d303 3
d307 4
a310 1
	/* if not specified, use default FS */
d312 11
a322 1
		node->dol_misc.dol_handler.dol_SegList = syssegl[6];
d418 2
a419 10

/* FIX! do this for console and FS also */
	{	struct Resident *res = FindResident("ram-handler");

		/* RAM: remains a BCPL-style module  */
		/* it should not count on it, though - FIX! */
		if (res)
			make_node_entry("RAM",0,TOBPTR(res->rt_Init),0,
					RAM_STACK,0,TOBPTR(dosbase()->dl_GV));
	}
d489 1
a489 1
		     curr <= cli->cpl_First + (LONG) cli->cpl_Array[0];
d509 1
a509 1
		if (num <= cli->cpl_First + (LONG) cli->cpl_Array[0])
d511 1
a511 1
			if (cli->cpl_Array[num-cli->cpl_First+1])
d513 1
a513 1
			          (((LONG) cli->cpl_Array[num-cli->cpl_First+1])
d546 1
a546 1
	struct Process *tid = (struct Process *) FindTask(0);
d568 1
a568 1
    // We tell System() from Execute() by the fh_Type field - RUN_EXECUTE (-1)
d577 9
d599 1
d617 2
a618 4
		if (tid->pr_ConsoleTask == NULL ||
		    (is_run && oclip->cli_StandardOutput != pkt->dp_Arg3))
			outs = findoutput("NIL:");
		else
d621 9
d671 1
d679 1
a679 1
		setname= "\4SYS:";
d695 4
a698 2
	memcpy((char *) BADDR(clip->cli_Prompt),prompt,*prompt+1);
	memcpy((char *) BADDR(clip->cli_SetName),setname,*setname+1);
d753 2
a754 2
	if (scb && !(isinteractive(scb)))
	{
d762 1
a762 1
		returnpkt(pkt,0,getresult2());
d779 1
d785 1
a785 3
		returnpkt(pkt,0,getresult2());
		setresult2((LONG) tid);
		return (LONG) deletetask;   /* might get called by shell-seg */
d791 1
d822 3
a825 1
	memcpy((char *) BADDR(clip->cli_SetName),setname,*setname+1);
@


36.21
log
@Added rn_ShellSegment
Moved RTF_AFTERDOS init
Added support for system asynch
@
text
@d753 1
@


36.20
log
@getvec->AllocVec, etc
@
text
@d109 2
a110 1
	rootnode->rn_RestartSeg		= syssegl[7]; 
a138 5
	/* Initialize ramlib (NOTE: this may need to be moved! FIX)  */
	/* Patches vectors in exec to search for modules on disk.    */
	/* We do this before we start spawning off handler processes */
	/* but after the dos library data structures are all set up. */
	/* This also inits all other AFTERDOS items. */
a139 2
	InitCode(RTF_AFTERDOS, 0);
pm("afterdos");
d142 1
d152 1
d201 8
d214 1
a214 1
	makeseg( "Shell", rootnode->rn_ConsoleSegment, -1);
d523 1
d562 4
d608 5
d620 1
a620 1
	/* old currentdir was NULL(?) */
@


36.19
log
@Fixed System
@
text
@d22 2
a23 2
#ifdef LATTICE
#include "proto/exec.h"
a28 1
#endif
a29 3
/* sizeof, but returns longs */
#define longsize(x)	((sizeof(x)+3) >> 2)

d85 1
a85 1
	info = getmem(longsize(struct DosInfo),MEMF_PUBLIC|MEMF_CLEAR);
d91 2
a92 2
	tasktab = getmem(TASKTABLESIZE + 1 + longsize(struct CliProcList),
			 MEMF_PUBLIC|MEMF_CLEAR);
d198 1
a198 1
			   freevec((char *) BADDR(node->dol_misc.dol_handler.
d200 1
a200 1
			   freevec(node);
d268 1
a268 1
	arg = getmem(longsize(struct FileSysStartupMsg),MEMF_PUBLIC|MEMF_CLEAR);
d416 1
a416 1
	LONG upb = longsize(struct Segment) + ((strlen(name)+3) >> 2) - 1;
d420 1
a420 1
	segment = getmem(upb,MEMF_PUBLIC|MEMF_CLEAR);
d670 1
a670 1
		node = AllocVec(2*4);	/* used to be getvec(1)! */
@


36.18
log
@Random memory debugs, commented out
@
text
@d604 3
a606 1
	clip->cli_Background = (interactive && isinteractive(outs)) ?
@


36.17
log
@cleanup
@
text
@d51 11
d88 1
d90 1
a90 1

d97 1
a97 1

d108 1
a108 1

d137 1
a137 1

d141 1
a141 1

d149 1
a149 1

d160 1
a160 1

d171 1
a171 1

d207 1
d211 1
a211 1

d217 1
a217 1

d233 1
a233 1

d257 1
a257 1

@


36.16
log
@Check bit in expansionbase for startup-sequence
assign things to root if the subdirs don't exist.
Fix cli_Background calcultion
@
text
@a44 1
extern char b_ramhandler[];	/* "L:RAM-HANDLER" */	/* FIX! remove */
a134 1
#define USE_AFTERDOS
a135 1
#ifdef USE_AFTERDOS
a136 2
#else
	{ struct Resident *res;
a137 5
	  res = FindResident("ramlib.library");
	  if (res)
		InitResident(res,NULL);
	}
#endif
d362 1
a362 3
#define NEW_CONSOLE
#ifdef NEW_CONSOLE
/* C handlers specify stack in BYTES!!!!! */
a364 5
#else
#define makec(name,startup,segl) \
	make_node_entry(name,startup,segl,0,CON_STACK,5,\
			TOBPTR(dosbase()->dl_GV));
#endif
a389 3
#define ROM_RAM

#ifdef ROM_RAM
a397 3
#else
	make1("RAM", 0, b_ramhandler, RAM_STACK, 0);
#endif
a590 1
	/* This seems silly - REJ - FIX? */
@


36.15
log
@Removed abort from AddSegment
@
text
@d14 1
d67 1
d231 9
a239 3
	clip->cli_StandardInput  = input();
	clip->cli_CurrentInput   = findinput(":S/startup-sequence");
	if (clip->cli_CurrentInput == 0)
d317 2
a318 1
/* make device list entry */
d327 2
a328 2
	if (lock = locateobj(dir))
		return assign(name,lock);
d330 1
a330 1
	return FALSE;
d615 2
a616 1
	clip->cli_Background = ~(interactive && isinteractive(outs));
@


36.14
log
@Fixed FindCliProc
@
text
@d417 1
a417 1
void ASM
d427 2
a428 1
		abort(AN_StartMem|AT_DeadEnd);	/* hah - FIX! */
d446 2
@


36.13
log
@Use auto-open console, move signon message to console, use shell-startup
@
text
@d499 8
a506 3
			return (struct Process *)
			       (((LONG) cli->cpl_Array[num-cli->cpl_First+1])
			        - sizeof(struct Task));
@


36.12
log
@Added Shell resident
@
text
@d217 1
a217 1
		outs = findoutput("CON:0/0/640/200/AmigaDOS"); /* FIX! PAL,etc*/
d223 1
d226 1
d758 1
a758 1
		scb = finddefault("s:cli-startup");
@


36.11
log
@*** empty log message ***
@
text
@d209 1
@


36.10
log
@Added romable ram-handler, fix to MaxCLI, cleanup.
@
text
@d9 3
a11 3
#include "libraries/dos.h"
#include "libraries/dosextens.h"
#include <libraries/filehandler.h>
@


36.9
log
@Changed parameters fro cli_init_xxx
@
text
@d44 1
a44 1
extern char b_ramhandler[];	/* "L:RAM-HANDLER" */
d393 14
d408 1
d411 2
a412 1
/* LOCKING??!!! FIX! */
d414 2
a415 5
void __regargs
makeseg (name,seg,system)
	char *name;
	BPTR seg;
	LONG system;		/* -2: rom command, -1: system, 0: loaded cmd */
d433 1
a433 1
	CtoB(name,(((LONG) segment) +
d444 1
d479 1
a479 1
				max = curr;
@


36.8
log
@Fixes to deal with people with NULL consoletasks calling Execute/Run.
@
text
@d509 2
a510 2
LONG ASM
cli_init_run (REG(d1) struct DosPacket *pkt)
d664 2
a665 2
LONG ASM
cli_init_newcli (REG(d1) struct DosPacket *pkt)
@


36.7
log
@Mucho changes.  Added all the run, newcli, etc init functions.
@
text
@d542 3
a544 9
	if (is_run)
	{
		/* if he used ANY output redirection, use NIL: */
		if (oclip->cli_StandardOutput != pkt->dp_Arg3)
			outs = findoutput("NIL:");
		else
			outs = findoutput("*");
		rc |= 1;
	}
d551 1
d568 6
a573 1
		outs = findoutput("*");
@


36.6
log
@Make RTF_AFTERDOS optional for the moment.
@
text
@d35 1
a35 1
#define TO_BPTR(x)	(((LONG) (x)) >> 2)
d48 3
d97 2
a98 2
	rootnode->rn_TaskArray		= TO_BPTR(tasktab);
	rootnode->rn_Info		= TO_BPTR(info);
d104 1
a104 1
	cl->cpl_Array = (struct Process **) tasktab;
d120 1
a120 1
	info->di_DevInfo = TO_BPTR(bootnode);
d134 2
d208 3
a210 3
	makeseg( "CLI", rootnode->rn_ConsoleSegment, TRUE);
	makeseg( "Restart", rootnode->rn_RestartSeg, TRUE);
	makeseg( "FileHandler", syssegl[6], TRUE);
d262 2
a263 2
		arg->fssm_Device  = TO_BPTR(devname);	/* xxxx.device */
		arg->fssm_Environ = TO_BPTR(&disk_envvec);
d272 1
a272 1
			node->dol_misc.dol_handler.dol_Startup = TO_BPTR(arg);
d346 1
a346 1
		node->dol_misc.dol_handler.dol_Handler   = TO_BPTR(handler);
d368 1
a368 1
			TO_BPTR(dosbase()->dl_GV));
d371 1
a371 1
/* gv was TO_BPTR(dosbase()->dl_GV) */
d379 1
a379 1
	make1(name,startup,b_porthandler,stacksize,TO_BPTR(dosbase()->dl_GV));
d396 2
d402 1
a402 1
	LONG system;		/* true/false */
d411 1
a411 1
		abort(AN_StartMem|AT_DeadEnd);	/* hah */
d413 1
a413 1
	segment->seg_UC  = system ? -1 : 0;  /* -1 is not a command */
d428 1
a428 1
	*lv_list = TO_BPTR(segment);
d482 3
a484 1
			return cli->cpl_Array[num - cli->cpl_First + 1];
d488 293
@


36.5
log
@Changed to RTF_AFTERDOS for initing ramlib
@
text
@d131 1
d133 2
d136 5
@


36.4
log
@Added MaxCli/FindCliProc
@
text
@a61 1
	struct Resident *res;
d130 2
a131 4

	res = FindResident("ramlib.library");
	if (res)
		InitResident(res,NULL);
@


36.3
log
@Fixed task table setup, changed order of assigns.
@
text
@d437 38
@


36.2
log
@Added support for the new device list locking.
Added support for more than 20 cli's.  Reorganized some code.
Reversed order handlers are started in to optimize ordering on the
dos device list.
@
text
@d101 1
a101 1
	cl = (struct CliList *) &tasktab[TASKTABLESIZE];	/* TRICKY! */
d139 3
a141 1
	make_task_assignment( "SYS", ":" );
d143 1
a143 2
	make_assign_entry("DEVS");
	make_assign_entry("FONTS");
d145 1
a145 2
	make_assign_entry("L");
	make_assign_entry("S");
@


36.1
log
@*** empty log message ***
@
text
@d63 1
d76 2
a77 2
/* FIX! */
	tasktab = getmem(TASKTABLESIZE,MEMF_PUBLIC|MEMF_CLEAR);
d79 3
a81 1
	bootnode = (struct DosList *) rootnode->rn_FileHandlerSegment;
d83 2
d90 4
d95 1
a96 1
	rootnode->rn_TaskArray		= TO_BPTR(tasktab);
d98 1
a98 1
	rootnode->rn_FileHandlerSegment = syssegl[6];
d100 6
a105 4
	/* Initialize ramlib (NOTE: this may need to be moved! FIX)  */
	/* Patches vectors in exec to search for modules on disk.    */
	/* We do this before we start spawning off handler processes */
	/* but after the dos library data structures are all set up. */
a106 4
	res = FindResident("ramlib.library");
	if (res)
		InitResident(res,NULL);

d109 1
d111 2
d117 1
a117 1
	/* carries all the other bootnodes onto the list as well */
a122 4
	/* Wake up intuition - leaves it open forever - no checking */
	/* need to put into global vector! */
	store_IBase(OpenLibrary("intuition.library",0L));

a123 2
	rootnode->rn_RestartSeg = syssegl[7]; 

d127 9
d259 1
a259 1
		Forbid();	/* FIX! (actually not really dangerous) */
a263 1
		Permit();
d332 1
a332 1
	Forbid();	/* FIX! */
a342 1
	Permit();
d352 1
a359 1
/* FIX!!!! upped CON_STACK to to *4 for testing!!!!! FIX!!!!
d376 7
a383 5
	makec("CON", 0, syssegl[5]);
	makec("RAW", 1, syssegl[5]);
	makes("SER", 0, SER_STACK );
	makes("PAR", 1, PAR_STACK );
	makes("PRT", 2, PRT_STACK );
@
