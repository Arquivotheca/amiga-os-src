head     36.50;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @@;


36.50
date     92.06.02.20.05.01;  author jesup;  state Exp;
branches ;
next     36.49;

36.49
date     91.05.22.01.07.59;  author jesup;  state Exp;
branches ;
next     36.48;

36.48
date     91.05.17.15.11.09;  author jesup;  state Exp;
branches ;
next     36.47;

36.47
date     91.05.16.15.01.55;  author jesup;  state Exp;
branches ;
next     36.46;

36.46
date     91.05.04.18.41.36;  author jesup;  state Exp;
branches ;
next     36.45;

36.45
date     91.04.18.22.49.33;  author jesup;  state Exp;
branches ;
next     36.44;

36.44
date     91.04.12.15.41.41;  author jesup;  state Exp;
branches ;
next     36.43;

36.43
date     91.04.11.02.33.56;  author jesup;  state Exp;
branches ;
next     36.42;

36.42
date     91.04.10.19.30.27;  author jesup;  state Exp;
branches ;
next     36.41;

36.41
date     91.03.20.14.13.57;  author jesup;  state Exp;
branches ;
next     36.40;

36.40
date     91.03.12.22.22.26;  author jesup;  state Exp;
branches ;
next     36.39;

36.39
date     91.03.11.14.03.45;  author jesup;  state Exp;
branches ;
next     36.38;

36.38
date     91.02.19.02.14.10;  author jesup;  state Exp;
branches ;
next     36.37;

36.37
date     91.02.13.19.04.35;  author jesup;  state Exp;
branches ;
next     36.36;

36.36
date     91.01.24.16.02.50;  author jesup;  state Exp;
branches ;
next     36.35;

36.35
date     91.01.17.14.17.29;  author jesup;  state Exp;
branches ;
next     36.34;

36.34
date     90.12.21.17.03.53;  author jesup;  state Exp;
branches ;
next     36.33;

36.33
date     90.12.16.21.35.59;  author jesup;  state Exp;
branches ;
next     36.32;

36.32
date     90.12.16.04.12.26;  author jesup;  state Exp;
branches ;
next     36.31;

36.31
date     90.12.03.09.32.54;  author jesup;  state Exp;
branches ;
next     36.30;

36.30
date     90.12.03.08.55.11;  author jesup;  state Exp;
branches ;
next     36.29;

36.29
date     90.12.01.20.00.04;  author jesup;  state Exp;
branches ;
next     36.28;

36.28
date     90.11.30.03.48.18;  author jesup;  state Exp;
branches ;
next     36.27;

36.27
date     90.11.30.03.40.53;  author jesup;  state Exp;
branches ;
next     36.26;

36.26
date     90.11.21.02.36.28;  author jesup;  state Exp;
branches ;
next     36.25;

36.25
date     90.09.06.18.36.41;  author jesup;  state Exp;
branches ;
next     36.24;

36.24
date     90.08.31.00.05.14;  author jesup;  state Exp;
branches ;
next     36.23;

36.23
date     90.08.28.01.56.52;  author jesup;  state Exp;
branches ;
next     36.22;

36.22
date     90.08.02.19.00.06;  author jesup;  state Exp;
branches ;
next     36.21;

36.21
date     90.07.30.00.07.27;  author jesup;  state Exp;
branches ;
next     36.20;

36.20
date     90.06.18.21.17.46;  author jesup;  state Exp;
branches ;
next     36.19;

36.19
date     90.06.13.02.28.17;  author jesup;  state Exp;
branches ;
next     36.18;

36.18
date     90.06.12.05.41.29;  author jesup;  state Exp;
branches ;
next     36.17;

36.17
date     90.06.07.03.04.15;  author jesup;  state Exp;
branches ;
next     36.16;

36.16
date     90.06.01.01.27.29;  author jesup;  state Exp;
branches ;
next     36.15;

36.15
date     90.05.31.07.04.50;  author jesup;  state Exp;
branches ;
next     36.14;

36.14
date     90.04.03.04.45.10;  author jesup;  state Exp;
branches ;
next     36.13;

36.13
date     90.02.16.22.26.50;  author jesup;  state Exp;
branches ;
next     36.12;

36.12
date     90.02.02.17.29.07;  author jesup;  state Exp;
branches ;
next     36.11;

36.11
date     90.01.31.15.22.07;  author jesup;  state Exp;
branches ;
next     36.10;

36.10
date     90.01.29.02.02.05;  author jesup;  state Exp;
branches ;
next     36.9;

36.9
date     90.01.17.21.51.30;  author jesup;  state Exp;
branches ;
next     36.8;

36.8
date     89.12.15.05.13.23;  author jesup;  state Exp;
branches ;
next     36.7;

36.7
date     89.12.13.00.51.13;  author jesup;  state Exp;
branches ;
next     36.6;

36.6
date     89.12.12.11.24.37;  author jesup;  state Exp;
branches ;
next     36.5;

36.5
date     89.12.09.01.59.32;  author jesup;  state Exp;
branches ;
next     36.4;

36.4
date     89.12.01.08.21.13;  author jesup;  state Exp;
branches ;
next     36.3;

36.3
date     89.11.22.03.23.48;  author jesup;  state Exp;
branches ;
next     36.2;

36.2
date     89.11.14.01.32.57;  author jesup;  state Exp;
branches ;
next     36.1;

36.1
date     89.10.19.00.02.08;  author jesup;  state Exp;
branches ;
next     ;


desc
@Initial check in
@


36.50
log
@Fixed handling of character classes with nocase.
@
text
@*****************************************************************************
*
* Patterns.s
*
*	Copyright (c) 1987-89 by ARP Authors.
*	Copyright (c) 1989 by Commodore-Amiga, Inc.
*	All Rights Reserved.
*
* This source file includes the pattern matching functions for AmigaDOS,
* PreParse(), PatternMatch(), FindFirst(), FindNext(), FreeAnchorChain().
*
* This file was created from the file "wildcard.s" from arp.library V1.3.0
* (V39.0 of arp.library)
*
* Functions here assume A6 as DOSBASE.
*
*	Created 7/5/89 by cdh
*	History:
*		11/20/89 cdh	Modify FindNext to insure an_Lock is valid
*		12/6/89  cdh	Args for DOS D1/D2. Error codes SetIoErr.
*				ParsePattern has buf length, fix NOT.
*		
*
*****************************************************************************

AbsExecBase	EQU	4


	include	"exec/types.i"
	include "exec/memory.i"

FUNCDEF     MACRO   * function
_LVO\1	    EQU	    FUNC_CNT
FUNC_CNT    SET     FUNC_CNT-6
            ENDM

FUNC_CNT    SET     LIB_NONSTD

	include	"exec/exec_lib.i"
	include	"exec/libraries.i"
	include	"dos/dosasl.i"
	include "dos/dosextens.i"

	xdef	FindFirst,FindNext,FreeAnchorChain
	xdef	PreParse,PreParseNoCase
	xdef	_FindFirst,_MatchPattern,_MatchPatternNoCase

DOS	macro
	XREF	\2
_\1	EQU	\2
	ENDM

	DOS	Examine,_examine
	DOS	UnLock,_freeobj
	DOS	ExNext,_exnext
	DOS	IoErr,@@getresult2
	DOS	SetIoErr,@@SetIoErr
	DOS	ParentDir,_parent
	DOS	Lock,_lock
	XREF	@@toUpper
	XREF	Toupper
	XREF	@@rootstruct
	XREF	_PathPart
	XREF	_FilePart
	XREF	_CurrentDir

*****************************************************************************
*
* cdh 9/7/89
*	This macro allows use of the new dos.library function calls which
* are not yet available as LVO callouts.
*	The macro will call the ROM functions if they have been defined,
* in libraries/dos_lib.i, or if the functions have not yet been defined
* the macro will call them as xref'ed functions by the name of the function
* preceeded by an underscore.
*
*****************************************************************************

*
*	If these are changed, check state of a6 - some SYSCALLS don't have it
*

SYSCALL	macro
	IFD	_LVO\1
	ERROR! using lvo!
	jsr	_LVO\1(A6)
	ENDC
	IFND	_LVO\1
*	ERROR!!! You must supply _LVO\1
*	xref	_\1
	jsr	_\1
	ENDC
	ENDM

SYSJMP	macro
	IFD	_LVO\1
	ERROR! using lvo!
	jmp	_LVO\1(A6)
	ENDC
	IFND	_LVO\1
*	ERROR!!! You must supply _LVO\1
*	xref	_\1
	jmp	_\1
	ENDC
	ENDM

LINKEXE MACRO
	move.l	a6,-(sp)
	move.l	AbsExecBase,a6
	jsr	_LVO\1(a6)
	move.l	(sp)+,A6
	ENDM


**********************************************************************
*
*	NAME
*	   PreParse -- Creat a tokenized string for `MatchPattern'
*
*	SYNOPSIS
*	   Status = PreParse(Source,Dest,DestLength)
*	     d0                D1    D2     D3
*
*	FUNCTION
*
*	INPUTS
*	  char *source - unparsed wildcard string to search for.
*         char *dest - output string, gets tokenized version of input.
*
*	RESULT
*	  LONG IsWild - whether there were any wildcards in the string
*	  returns -1 if there is a buffer overflow
*	
*	BUGS
*	  None known.
*
*	SEE ALSO
*	   MatchPattern, FindFirst/FindNext
*
*	Author:	CDH based on FindFirst by JAT
*	  edited 1/13/88 cdh add ' escape char
*	  total rewrite 11/2/88 cdh, changed everything from scratch
*
***********************************************************************

Ptr	equr	A2
Dest	equr	A1
WPending equr	D2
Buflen	equr	D3
TYpe	equr	D4
Curchr	equr	D1
NotPending equr D5

*****
*
*	Here's the ParsePattern entrypoint.....
*
PreParseNoCase:
	movem.l	D2-D6/Ptr/A3/a4,-(sp)
	moveq	#1,d6
	bra.s	preparse_common

**
*
* IsWild: determine if Curchr is a wildcard character, and return the offset
*	  in the wildcard array.  NOTE: returns cc as equal for a wildcard,
*	  cc as not equal for no match!!!!!  Wierd!
*

*** NOTE - WildZ IS REFERENCED FOR FindAll !!!!
*** Careful: tables must match, as well as jumptable!
*** Note: FindNext counts on P_ANY being first here!

WildZ:	dc.b	P_ANY,P_NOT,P_CLASS,']',P_REPBEG
	dc.b	P_SINGLE,P_ORSTART,P_OREND,P_ORNEXT,0,0
**
WildChars:
	dc.b	"*~[]#?()|%'"
Wildstuff:	ds.w	0

NUM_WILDCARDS	EQU	(Wildstuff-WildChars)

IsWild:	lea	Wildstuff,A0 
	moveq	#NUM_WILDCARDS-1,D0	; dbra loop...
1$:	cmp.b	-(A0),Curchr
	 dbeq	D0,1$		; doesn't affect cc's!
	rts

*** Handle #?
ppAny:
	addq	#1,Ptr
	move.b	#P_ANY,Curchr
	bra	ppstore

PreParse:
	movem.l	D2-D6/Ptr/A3/a4,-(sp)
	moveq	#0,d6
*
* Maintain a stack of P_ORSTART, P_REPBEG, and P_NOT's.  This allows us to
* match them, and allows us to put the P_REPEND's and P_NOTEND's in the
* right places.
*
* Get size of pattern, and allocate that much off stack
*
preparse_common:
	move.l	d1,a0
1$:	tst.b	(a0)+
	bne.s	1$
	sub.l	d1,a0		; 1 too big
	move.l	a0,d0
	addq.l	#1,d0		; 2 too big
	bclr.b	#0,d0		; make even - we're 1 or 2 too big - need
				; space for a 0 entry on top of stack!
				; each token can only push 1 value max
	move.l	a7,a3		; save stack ptr (in case a4 gets unbalanced)
	move.l	a7,a4		; token stack ptr
	clr.b	-(a4)		; make top item 0 (things examine top)
	sub.l	d0,a7

* init stuff
	move.l	D1,Ptr		; source

	moveq	#ERROR_BAD_TEMPLATE,d1
	SYSCALL	SetIoErr	; call before we dest dest from d2

	move.l	D2,A1		; dest

	moveq	#0,TYpe		; Return value
	moveq	#0,WPending
	moveq	#0,NotPending
*
* main looping point
*
ppLoop:	move.b	(Ptr)+,Curchr	; NULL HANDLED BY PPSTORE!!!
	bsr.s	IsWild		; returns offset into array of wildcard found
	 bne.s	ppRegular	; not a wildcard - store and loop

*
* We want optional use of "*" as a wildcard.  Use a flag in the rootnode.
*
	move.w	d0,-(sp)	; only a word
	bsr	@@rootstruct	; FIX! use dosbase!  FIX! must not destroy a1!
	move.l	d0,a0		; rootnode
	move.w	(sp)+,d0

	;-- careful - it's bit 24 of a longword!
	btst.b	#RNB_WILDSTAR-24,rn_Flags(a0)
	 bne.s	1$		; if set, allow "*"
*
** REJ - turned off '*' for Beta 1 - was commented out (cmp #3,d0, ble.s...)
*
	cmp.w	#0,D0			; is wildcard char is *, ignore
	 ble.s	ppRegular		; * is entry 0, and WildStar isn't
					; active

1$:	move.b	WildZ(pc,d0.w),Curchr	; May be a direct substitute char
	add.w	D0,D0			; word offset - bra.s == 2 bytes
	jmp	ppJump(pc,D0.w)

* Leave a trailing NOT alone ...
ppStartNot:
	tst.b	(Ptr)		; KLUDGE to help mg (micro-gnu-emacs)
	 bne.s	ppPushToken
	moveq	#'~',Curchr	; replace token with '~'
	bra.s	ppRegular	; store it as a normal character

ppJump:
	;-- Must match WildZ table above!!!
	bra.s	ppstore		; *
	bra.s	ppStartNot	; ~
	bra.s	ppStartClass	; [
	bra.s	ppRegular	; ]  ( Ignore here )
	bra.s	ppStartRep	; #
	bra.s	ppstore		; ?
	bra.s	ppStartOr	; (
	bra.s	ppEndOr		; )
	bra.s	ppNextOr	; |
	bra.s	ppLoop		; % Ignore
* Tick ' comes here ...

	move.b	(Ptr)+,Curchr	; ' - Escape a wildcard character
	bsr	IsWild		; cc eq means it got a match
	 beq.s	ppstore		; Next char wild - it was Escaped...
	subq.l	#1,Ptr		; not wild - back up and reinsert '
	move.b	#$27,Curchr
	bra.s	ppRegular	; handle as normal character
*
ppEndOr:
	cmp.b	#P_ORSTART,(a4)+
	 bne	ppFail		; ) without (!!!
	bra.s	ppstore		; stores P_OREND, then checks for # and ~
*
ppNextOr:
	cmp.b	#P_ORSTART,(a4)
	 bne	ppFail		; Not in ()!  FIX!!! Handle x|y|z! ((a4) == 0)
	; fall through....
*
* Here's where we generally store items in the destination...
*
ppstore:			; store a token (set return value for wildcards)
	moveq	#1,TYpe
ppRegular:			; store a character
	subq.l	#1,Buflen
	 ble.s	ppFail
	move.b	Curchr,d0
	tst.w	d6		; is this ParsePatternNoCase?
	 beq.s	ppnocase
	bsr	Toupper		; convert d0 to UC, no other regs touched
ppnocase:
	move.b	d0,(Dest)+
	 beq.s	ppDone

ppCleanup:
* These tokens need end markers after the next token (with () doing grouping)
* Check if there is a pending P_REPEND
	cmp.b	#P_REPBEG,(a4)
	 bne.s	10$			; not #, check ~
	moveq.b	#P_REPEND,d0
	bra.s	pop_token		; goes back to pp_Cleanup

* Check if there is a pending P_NOTEND
10$:	cmp.b	#P_NOT,(a4)		; top entry always 0, so it's safe
	 bne.s	pp_braloop		; both failed, loop

	moveq.b	#P_NOTEND,d0	
	;-- fall through

pop_token:
	;-- common 'add token and pop token stack' rtn
	addq.l	#1,a4			; drop token
	subq.l	#1,Buflen
	 ble.s	ppFail
	move.b	D0,(Dest)+		; add end token
	bra.s	ppCleanup		; check again - we may need more ends!

*** Handle #(pat)
ppStartRep:
	cmp.b	#'?',(Ptr)	; handle #? as a single token for speed
	 beq	ppAny
	; fall thru

ppStartOr:
ppPushToken:
	moveq	#1,TYpe
	subq.l	#1,Buflen
	 ble.s	ppFail
	move.b	Curchr,(Dest)+
	move.b	Curchr,-(a4)		; push token onto token stack

pp_braloop:
	bra	ppLoop			; done adding a token, loop

***** Handle P_CLASS stuff here->  ( [<char class>] )
ppStartClass:
	cmp.b	#'~',(Ptr)	; check for [~a-z]
	 bne.s	1$
	move.b	#P_NOTCLASS,Curchr
	addq.l	#1,Ptr		; drop ~

1$:	subq.l	#1,Buflen	; store up the characters in the class
	 ble.s	ppFail
	move.l	Curchr,d0	; for toupper
	tst.w	d6		; is this ParsePatternNoCase?
	 beq.s	5$		; no
	bsr	Toupper		; convert d0 to UC, no other regs touched
5$	move.b	d0,(Dest)+	; P_CLASS (or NOTCLASS) first time...
	move.b	(Ptr)+,Curchr
	 beq.s	ppFail		; EOS premature ick.
	cmp.b	#$27,Curchr	; '-'
	 bne.s	10$
	move.b	(Ptr)+,Curchr
	 beq.s	ppFail		; EOS
	bra.s	1$		; don't compare against ]

10$:	cmp.b	#']',Curchr	; FIX!!!!! doesn't handle ']!!!!!!
	 bne.s	1$
	move.b	#P_CLASS,Curchr	; we're done
	bra.s	ppstore

* hit end of pattern.  check for unbalanced token stack
ppDone:
	tst.b	(a4)
	 beq.s	ppend

* Come here on buffer overflow or other error
ppFail:
	tst.l	Buflen		; did we run out of space?
	 bgt.s	1$
	moveq	#ERROR_LINE_TOO_LONG,d1
	SYSCALL	SetIoErr

1$:	moveq	#-1,TYpe

ppend:	move.l	TYpe,D0
	move.l	a3,a7			; restore stack ptr (drop token stack)
	movem.l	(sp)+,D2-D6/Ptr/A3/a4
	rts

*************************************************************************
*
*	NAME
*	   Matchpattern - perform a wildcard string match
*
*	SYNOPSIS
*	   result = MatchPattern(pat,str)
*	     D0 + Z-Flag	 A0  A1
*
*	FUNCTION
*	   This function implements BCPL-compatible string pattern matching.
*
*	   The input "pat" is the PreParsed pattern string.
*	   The input "str" is a NULL-terminated string to match against.
*
*	   The result in D0 is a boolean TRUE or FALSE value, FALSE = 0,
*	   TRUE = 1.  The zero flag is also set according to the result.
*
*	   The input pattern is identical to the BCPL pattern strings described
*	   in the AmigaDOS Users Manual for the LIST command, with the addition
*	   of the "*" symbol (see PreParse) if enabled by environment variable,
*	   BCPL.  Also controlled by the BCPL environment variable are
*	   character classes as defined below:
*
*	    [  Starts character class,   ]  Terminates character class
*	    If the first character following [ is ~, the class is negated.
*	    A range of characters may be specified with -
*	    Any other characters are compared with the tested char.
*	    To match against -, it must be the FIRST character in a range.
*	    To match against ], it must be escaped with '.
*
*	BUGS
*	  None known.
*
*	SEE ALSO
*
*	Author: Rewritten for ARP V1.3 by CDH
*		1-2-88 cdh  Rework OR code for recursion
*
*************************************************************************

* Register D0 holds current character, and temp values
*	   A0 is pattern string
*	   A1 is string to match

_MatchPatternNoCase:
	movem.l	D3/d4/a2,-(sp)
	moveq	#1,d3
	bra.s	match_common

_MatchPattern:
	movem.l	D3/d4/a2,-(sp)
	moveq	#0,d3
match_common:
	move.l	D1,A2			; Get args internal froboz thanks.
	moveq	#0,d1
	SYSCALL	SetIoErr		; default is no error
	move.l	a2,a0			; get first arg back
	move.l	D2,A1
	move.w	#(1500-256)/12,d4	; # of time we can recurse
					; 12 bytes per resursion, 256 bytes
					; kept free for task switch safety.
	move.l	a7,a2			; keep stack ptr for error out!
	bsr.s	Internal_PatternMatch
match_exit:
	movem.l	(sp)+,d3/d4/a2
	rts

* End of pattern; if str is also at end, TRUE else FALSE
chekmatch:
	tst.b	(A1)
	 bne.s	MatchFail		; Failed return...

* P_STOP is a "special" case, returning TRUE, with A1 guaranteed
* to be at current position of STR, and A0 updated to next unused token...
* This is because it matches REPBEG to REPEND, and then tries to match the
* pattern at REPEND, until REPBEG to REPEND match fails.
do_P_STOP:
MatchOK:
	;-- increment nesting counter
	addq.w	#1,d4

	moveq	#1,D0			; Everybody happy return
	rts
*
* Main looping point for PatternMatch - MUST return cc's!!!!!
*
Internal_PatternMatch:

	;-- decrement recursion counter, return on error
	subq.w	#1,d4
	 bne.s	pm_Loop			; we're fine

	move.l	a2,a7			; restore stack ptr
	move.l	#ERROR_TOO_MANY_LEVELS,d1
	SYSCALL	SetIoErr
	moveq	#0,d0			; return failure
	bra.s	match_exit

* Case of ?, looking for a single character
do_P_SINGLE:
	tst.b	(A1)+
	 beq.s	MatchFail		; No char to match...
	;-- fall through to pm_Loop!!!
**
* Matched up to NOTEND.  This is success, but NOT if the rest of the pattern
* wouldn't match!  So try to match the rest of the pattern, and if it still
* matches, we return success, aka failure.  If it fails, we return failure,
* which is success.  So effectively, we ignore NOTEND, it's only used if
* we fail to know where the rest of the pattern is.
*
do_P_NOTEND:
do_P_REPEND:
do_P_OREND:				; used to go to pm_Loop
	;-- fall through
pm_Loop:
	move.b	(A0)+,D0		; leaves a0 pointing past current token
	 beq.s	chekmatch		; End of pattern string
	cmp.b	#P_STOP,D0		; the 'highest' entry!!  CAREFUL!
	 ble.s	DoComplex		; Not a simple pattern, process...
	move.b	(a1)+,d1
	tst.w	d3
	 beq.s	nocase
	;-- assumes they called ParsePatternNoCase
	exg	d0,d1			; convert d0 to upper, no other regs
	bsr	Toupper			; are touched
					; we don't care which is in which reg
nocase:	cmp.b	d1,D0			; a literal character
	 beq.s	pm_Loop			; Loop till end of string

MatchFail:
	;-- increment nesting counter
	addq.w	#1,d4

	moveq	#0,D0
	rts

**
* This is either #? or *
do_P_ANY:
	tst.b	(A0)			; nothing after #?/*
	 beq	MatchOK			; End of pattern - good match

*
* To handle */#?, try pattern matching after each character of the remaining
* input characters.  If starting at each of them all fail, then we have no
* match.
*
* Loop here for remainder of pending str matching continuation of pat
1$:	movem.l	A0/A1,-(sp)		; Need to save current context
	bsr	Internal_PatternMatch
	movem.l	(sp)+,A0/A1		; doesn't affect cc's...
	 bne.s	MatchOK			; Found a match.  Proceed.
	tst.b	(A1)+			; eat another character and repeat
	 bne.s	1$			; Loop on remaining chars...
	bra.s	MatchFail

**
* This is actually P_NOT... - NOTE: negates only the next token!
* I_P returns on P_NOTEND, with cc's set!!
*
* If the pattern matches, we fail immediately.  If the pattern doesn't match,
* consider this pattern to be P_ANY (#?), so we match all strings that do not
* match the pattern.  This is more intuitive in general.
*
* We must search for the NOTEND, because we don't know where it failed
*
do_P_NOT:
	movem.l	a0/a1,-(sp)		; save current position in string
	bsr	Internal_PatternMatch	; returns with cc's set!
	movem.l	(sp)+,a0/a1		; doesn't touch cc's!!!!
	 bne.s	MatchFail		; Match.  Don't look further.
	moveq	#0,D1

* find end of NOT.  Be careful to handle nesting.
	moveq	#0,d1
1$:	tst.b	(A0)			; a0 points past first P_NOT
	 beq.s	MatchOK			; Real Bad Condition. Barfola
	cmp.b	#P_NOT,(A0)
	 bne.s	2$
	addq	#1,D1			; handle ~(...~(...)...)
2$:	cmp.b	#P_NOTEND,(A0)+
	 bne.s	1$
	subq	#1,D1
	 bge.s	1$			; also handles ~(...)~(...)
	bra.s	do_P_ANY		; No match, consider same as #?.

***********************************************************************
*
* Complex pattern, use jump table processing...
*
***********************************************************************
DoComplex:
	add.w	D0,D0
	and.w	#$fe,D0			; Mask out extra bits
	jmp	JumpTab(pc,D0.w)

JumpTab:
	bra.s	do_P_ANY		; MUST match order of token values!
	bra.s	do_P_SINGLE
	bra.s	do_P_ORSTART
	bra.s	do_P_ORNEXT
	bra.s	do_P_OREND
	bra.s	do_P_NOT		; Confiscated for P_NOT P_NOTEND
	bra.s	do_P_NOTEND
	bra.s	do_P_NOTCLASS
	bra.s	do_P_CLASS
	bra.s	do_P_REPBEG
	bra.s	do_P_REPEND
	bra	do_P_STOP		; can be bra.l since it's last!
**
* Found a matched OR - but it may not be the match we want, so skip to end
*	of OR code and try it out.
do_P_ORNEXT:
	moveq	#0,D1

* Loop to end of OR condition, and return (do exactly the same as OREND)
* FIX! this doesn't try others after one match!!!!

1$:	tst.b	(A0)
	 beq	do_P_OREND		; Real Bad Condition. Barfola
	cmp.b	#P_ORSTART,(A0)		; FIX!! Handle a|b|c!!!
	 bne.s	2$
	addq.w	#1,D1			; handle (...|...(...|...))...
2$:	cmp.b	#P_OREND,(A0)+
	 bne.s	1$
	subq.w	#1,D1
	 bge.s	1$			; also handles (...|...)(...)
	bra	pm_Loop			; out of (...), match against rest

**
*	This is the beginning of a (...|...) sequence
*	It's a bit wierd.  I would have handled (...) by having Internal_P...
*	return on P_OREND, and continue matching here.  Instead, P_OREND
*	loops and tries to match the rest at it's level, possibly using
*	a bit more stack (luckily, Internal_PatternMatch uses little stack).
*	Also, having it return might make handling of ~ more predictable and
*	expected.  However, it seems to work reasonably well.
*
*	Late news flash: in order to make ~ work right, OREND _must_ return
*	immediately.  Therefore, ORSTART must go back to the loop on success.
*	In the case of ~(...) or #(...), the next token will be NOTEND or
*	REPEND, and we'll pop out another level to do_P_NOT or do_P_REPBEG.
*
*	Later flash: There is no need for OREND to pop out, now that we
*	understand ~.
*
do_P_ORSTART:
	movem.l	A0/A1,-(sp)
	bsr	Internal_PatternMatch	; pops out on fail or full success
	 beq.s	orFail
	addq.l	#8,sp			; drop old pointers!
	bra	MatchOK

	;-- I_P failed - find the next alternation of the pattern and
	;-- try again.  (i.e. search for next ORNEXT)
	;-- NOTE: if we go to MatchFail, a0 MUST be pointing past OREND!
orFail:
	movem.l	(sp)+,A0/A1		; restore pointers
	moveq	#0,D1			; Nesting
1$:	move.b	(A0)+,D0		; points to next symbol
	 beq	MatchFail		; shouldn't happen!!!!!!
	cmp.b	#P_ORSTART,D0		; handle (...(...|...)...|...)
	 bne.s	2$			; we need to find the next | at this
	 addq.w	#1,D1			; level.
2$:	cmp.b	#P_OREND,D0
	 bne.s	3$
	 subq.w	#1,D1
	  bmi	MatchFail		; we popped out.  Handles (...)(...|...)
3$:	tst.w	D1
	 bne.s	1$
	cmp.b	#P_ORNEXT,D0
	 bne.s	1$
	bra.s	do_P_ORSTART		; we found a OR_NEXT, try again

**
* put here so we're in bra.s range of switch
*
do_P_REPBEG:
	bra.s	real_REPBEG

**
*	Handle character classes - they start AND end with P_CLASS, since they
*	don't nest.
*
do_P_NOTCLASS:
	moveq	#1,d1
	bra.s	class_common
do_P_CLASS:
	moveq	#0,d1
class_common:
	move.b	(A1)+,D0		; Character to match against
	 beq	MatchFail		; No character to match! (Fail either
					; class or not-class!)
					; (not-class matchs 1 character not in
					; the class.)

	;-- must convert to upper case if case-insensitive!
	tst.w	d3
	 beq.s	class_nocase
	;-- assumes they called ParsePatternNoCase
					; convert d0 to upper, no other regs
	bsr	Toupper			; are touched
					; we don't care which is in which reg
class_nocase:

1$:	tst.b	(A0)
	 beq.s	class_nomatch		; Bad format pattern string!!!

	cmp.b	#P_CLASS,(A0)
	 beq.s	class_nomatch		; End of class, not found - skip, return

	cmp.b	(A0)+,D0
	 beq.s	class_match		; Good match, go skip to P_CLASS

	cmp.b	#'-',(A0)
	 bne.s	1$			; Continue to loop unless RANGE

	addq	#1,A0			; Point to end of RANGE

	cmp.b	-2(A0),D0		; TRICKY!
	 bcs.s	2$			; bra if -2(a0) > d0, unsigned
	cmp.b	(A0),D0
	 bls.s	class_match		; Good range matched get out!!!
					; was bcs 20$; beq 20$.  (i.e. bra if
					; (a0) >= d0, unsigned.)  Turns out
					; that bls does that (see moto books).
* No match
2$:	tst.b	(A0)
	 beq.s	class_nomatch
	cmp.b	#P_CLASS,(A0)+
	 bne.s	1$

* MatchClass returns..
*	Bad return to MatchFail, doesn't need to skip to P_CLASS...
*	If d1 != 0, then this is success
class_nomatch:
	tst.b	d1
	 beq	MatchFail
	bra.s	class_done

* Good match, skip to end of class
* if d1 != 0, this is failure
class_match:
	tst.b	d1
	 bne	MatchFail
class_done:				; eat the class, then continue
	tst.b	(A0)
	 beq.s	21$
	cmp.b	#P_CLASS,(A0)+
	 bne.s	class_done
21$:	bra	pm_Loop


**
* This handles # not followed by ?.  Any number of the following character,
* class or alternation.
*
real_REPBEG:
	movem.l	A0/A1/A2,-(sp)		; CAREFUL! it uses these values!

* Skip until _matching_ P_REPEND.  Handles #(#a|b), etc

	moveq	#0,d1
1$:	move.b	(A0)+,D0
	 beq.s	BadRep			; no P_REPEND.  Ick. Ick.
	cmp.b	#P_REPBEG,D0
	 bne.s	2$
	addq.w	#1,d1			; hit another REPBEG
	bra.s	1$

2$:	cmp.b	#P_REPEND,D0
	 bne.s	1$
	subq.w	#1,d1			; d1.w = -1 after correct REPEND
	 bge.s	1$

	lea	-1(A0),A2		; Save positon of REPEND

	;-- Match against pat @@P_REPEND, current str (0 instances)
	bsr	Internal_PatternMatch
	 bne.s	RepOK			; If yes, yippie go home

	;-- do we match the rest of the pattern yet??
	;-- (this makes 0 instances work also)
repLoop:
	;-- match against pattern including the repeat
	movem.l	(sp),A0/A1		; match against P_REPBEG to the end
	bsr	Internal_PatternMatch
	 bne.s	RepOK			; matches 1 instance plus the rest

	;-- skip one instance of the pattern
	;-- P_STOP makes it stop without checking the # of characters
	;-- matched, and return here with a1 updated.

	movem.l	(sp),A0/A1		; get ptrs back
	move.b	#P_STOP,(a2)		; nuke REPEND to stop evaluation
	bsr	Internal_PatternMatch
	move.b	#P_REPEND,(a2)		; restore pattern!
	tst.l	d0
	 beq.s	BadRep			; doesn't match the repeat pattern

	cmp.l	4(sp),A1		; Hit REPEND without matching anything
	 beq.s	BadRep			; Match was NULL, Futz.

	;-- update string ptr past an instance of the pattern
	move.l	a1,4(sp)		; Match was OK, loop
	bra.s	repLoop			; we now try the rest of the pattern
					; again, or loop until we get no more
					; matches of the repeated pattern.
RepOK:	movem.l	(sp)+,A0/A1/A2
	bra	MatchOK

BadRep:	movem.l	(sp)+,A0/A1/A2
	bra	MatchFail

***********************************************************************
*
* New FindFirst/FindNext support follows here.
*
***********************************************************************

AnchorBase	equr	A3		; struct AnchorPath root
BasePath	equr	A5		; Start of current substring
LastPath	equr	A4		; End of current clean string (no P_)
CurPath		equr	A2		; Current substring point
Wild		equr	D3

* These are used by FindNext
Node		equr	A2
LockReg		equr	D3
* AnchorBase is A3

***********************************************************************
*
*  Bool = FindFirst( Pattern,AnchorBase )
*   D0  =		D1 ,    d2
*
*
***********************************************************************
FindFirst:
_FindFirst:
	movem.l	D2-D5/A2-A6,-(sp)

	move.l	D1,CurPath

	move.l	D2,AnchorBase
	clr.l	ap_Base(AnchorBase)	;*** Clear potent garbage

* Turn OFF memory error and simple bits!!!
	and.b	#~((1<<APB_NOMEMERR)+(1<<APB_ITSWILD)),ap_Flags(AnchorBase)

* allocate space for the pattern string
	move.l	CurPath,a0
1$:	tst.b	(a0)+
	bne.s	1$
	sub.l	CurPath,a0		; gives len+1, which is what we want
	move.l	a0,d0			; size
	asl.l	#1,d0			; we need at least twice that space
					; since 1 token can become 2
	move.l	d0,d5			; remember how much we allocated!
					; (d5 is used as space free in buffer)
	bsr	DosAllocMem
	move.l	d0,d4			; save pointer for free
	 beq	ff_error		; we count on AllocVec setting IoErr!

* Copy filename over to buffer, skipping to end of ":" before starting parsing
	move.l	d4,BasePath		; Set START of path substring 1'st time
	move.l	BasePath,A1		; destination
	move.l	CurPath,A0		; Save position to start PreParse...
	move.l	A1,LastPath		; Save position to resume parsing later
	move.l	d5,d1			; temp space counter

3$:	move.b	(CurPath)+,D0
	subq.l	#1,d1			; remember how much buf space is used
	move.b	D0,(A1)+
	 beq.s	5$			; end of string, no ':'
	cmp.b	#':',D0
	 bne.s	3$

	;-- hit a :, remember where!
	move.l	CurPath,A0		; Save position to start PreParse...
	move.l	A1,LastPath		; Save position to resume parsing later
	clr.b	(LastPath)		; make sure string is terminated
	move.l	d1,d5			; we really used the space

* PreParse the string, create tokenized wierdness
*	Here,	A0 = start of string beyond ":" (if any)
*		LastPath = start of buffer beyond ":"
*		BasePath = Buffer start
*
*	If there are wildcards, we need to know where they are.
*	If none, we can just lock the damn thing.
*
5$:	move.l	A0,D1			; src (passed in, past ':' if any)
	move.l	LastPath,D2		; dest (after ':' if any)
	move.l	d5,D3			; sizeof(dest) minus volume, if any
***	SYSCALL	ParsePattern
	bsr	PreParse		; can't fail.  we alloced enough mem
					; above to be safe. 
	addq.l	#1,d0			; error return is -1 (not enough buf)
	 beq	ff_error		; check for error anyways

	;-- start parsing after last : in string
	;-- if there was a ':', LastPath != Basepath (as if we hit a /)
	moveq	#0,Wild
	move.l	LastPath,CurPath

* Scan through the buffer to find any wildcards.
*	BasePath is the start of the current string
*	LastPath is the start or the character after last / seen
*	CurPath is the current position
*	Note: this operates on the parsed result!!!!!

ff_loop:
	move.b	(CurPath),D0
	 beq.s	ff_endloop		; Exit loop
	cmp.b	#'/',(CurPath)+
	 beq.s	20$
	cmp.b	#P_STOP,D0		; it's the 'largest' wildcard token
	 bgt.s	ff_loop			; since it's a SIGNED comparison, and
					; the values are $80-$8b, the most
					; negative values in a byte.
*
* A wildcard - split perhaps
	tst.b	Wild			; is the current node wild already?
	 bne.s	ff_loop			; yes, ITSWILD set already, continue

	;-- current node wasn't wild, now it will be.
	;-- if we have a / in the current accumulated node, make it an anchor
	;-- and start a new one for the pattern.
	move.l	LastPath,D0		; have we accumulated any directories?
	sub.l	BasePath,D0
	 beq.s	12$			* Nothing to add...
	bsr	AddAnchor		; add a node for the directories
	 bne.s	ff_error		* some sort of error locking it
	move.l	LastPath,BasePath	; reset accumulation point

	; we found a wildcard...
12$:
	moveq	#DDF_PatternBit,Wild
	bset.b	#APB_ITSWILD,ap_Flags(AnchorBase)	; Set "ItsWild" bit.
	bra.s	ff_loop

*
* Handle a subdir / (or parent!)
20$:	tst.b	(CurPath)		; is this a final trailing /?
	 bne.s	ff_not_final
	move.l	CurPath,d0		; compare against last / position
	sub.l	LastPath,d0
	 beq.s	ff_not_final		; on foo:/, curpath==lastpath
	subq.l	#1,d0			; if CurPath == LastPath+1
	 beq.s	ff_not_final		; leave slashes

ff_kill_slash:
	clr.b	-(CurPath)		; remove single trailing '/'
	bra.s	ff_endloop

ff_not_final:
	move.l	CurPath,LastPath	* Set the "Last path" for next wild
	tst.b	Wild			* sets LastPath to char after '/'
	 beq.s	ff_loop			; if we hit a wildcard, basepath to
					; lastpath gets added as a node

	; hit a slash at end of wildcarded directory spec
	move.l	CurPath,D0
	sub.l	BasePath,D0
	subq.l	#1,D0			; Wild is already set
	bsr.s	AddAnchor
	 bne.s	ff_error		* error locking it
	move.l	LastPath,BasePath	* Set Start to current
	moveq	#0,Wild			* Wild no more
	bra.s	ff_loop

*
* end of path, make final node
*
ff_endloop:
	;-- Make sure that if there were no wildcards that the initial
	;-- node is the PathPart of string and the final node is the FilePart.
	;-- This means that it won't leave nodes like "df0:foo" as a single
	;-- entry, which causes it to relock the whole string on a DODIR (and
	;-- may get the wrong volume).  It also means that ap_Current->
	;-- an_Lock will be on the parent, and ap_Current->an_Info.fib_FileName
	;-- will be the name of the file in that directory.
	;--
	;-- Actually, the only way to make certain ap_Current->an_Lock is
	;-- right for cases like df0:foo#?/bar/foobar (currently an_Lock
	;-- would be df0:foo, with fib_Filename of foobar) is to make sure
	;-- ANY last file or directory name is separate, regardless of whether
	;-- there were wildcards anywhere or not.  This actually simplifies
	;-- the code slightly.
	;--
	;-- LastPath is set up pointing at last / or initial :.

	move.l	LastPath,d0		; last / or :
	sub.l	BasePath,d0		; d0 is a parameter to AddAnchor
	 beq.s	ff_no_dir_to_add	; actually it was a single filename
					; or filename following wildcard dir.
	bsr.s	AddAnchor		; make a node of it (up to last : or /)
	 bne.s	ff_error		; couldn't lock it or some such
	move.l	LastPath,BasePath	; reset accumulation point

ff_no_dir_to_add:
	;-- add final node for the last portion of the path (past last : or /)
	move.l	CurPath,D0		; Last position examined (== \0)
	sub.l	BasePath,D0		; Either original, or after last
*	 beq.s	ff_all_added		; pattern ended with / - ignore it.
	bsr.s	AddAnchor		; addanchor (due to wildcards in dirs)
	 bne.s	ff_error		* can't lock it!

ff_all_added:
	move.l	ap_First(AnchorBase),ap_Current(AnchorBase)

	move.l	d4,a1			; free temporary buffer
	move.l	AbsExecBase,a6
	jsr	_LVOFreeVec(a6)
	
	;-- call MatchNext.  Force dir changed bit on FindFirst (it did)
	move.l  AnchorBase,D1
	bsr	FindNext		; call FindNext (d1)
	bset.b	#APB_DirChanged,ap_Flags(AnchorBase)
	bra.s	ff_exit

	;-- come here on error from AddAnchor.  Error code is in IoErr
	;-- already (normally OBJECT NOT FOUND, NO FREE STORE, etc).
	;-- equivalent to code in FindFirst, except we can get the right
	;-- error code.
ff_error:
	;-- CAREFUL! (No FIX needed) - a6 == Execbase!
	;-- CAREFUL! make sure we don't tromp it before getting here!
	SYSCALL	IoErr			; get IoErr for return code in D0
	move.l	d0,d2			; save it

	move.l	AnchorBase,D1		; FreeAnchorChain will call UnLock()!
	bsr	FreeAnchorChain		; free up alloced memory for AnchorBase

	move.l	d4,a1
	move.l	AbsExecBase,a6
	jsr	_LVOFreeVec(a6)		; free temporary buffer

	move.l	d2,d1			; get error back
	SYSCALL	SetIoErr		; put it in IoErr() as well...
	move.l	d2,d0			; get it back again for return code
ff_exit:
	movem.l	(SP)+,D2-D5/A2-A6
	rts

***********************************************************************
*
* AddAnchor(length(d0), AnchorBase, BasePath, Wild)
*	Dedicated function works with FindFirst
* 	Uses AnchorBase, BasePath, Wild, register definitions...
*	String starts at BasePath, length in d0
*	Length of string is in D0 on entry
*
*	Note: depends on "foo/" and "foo" being the same directory/file
*
*	NOTE: Wild must be 0 or DDF_PatternBit!
*
*	Added secondary return to make error checking of AddAnchor calls
*	easier.  D1 = 0 is ok, D1 != 0 is failure (error in IoErr)
*	Returns cc's set from a test of D1 for easy error checking.
*
***********************************************************************
AddAnchor:
	movem.l	A2/D2/D3,-(sp)
	move.l	D0,D2			; Save "length"

	add.l	#an_SIZEOF+1,D0
	bsr	DosAllocMem		; cleared
	move.l	D0,A2
	tst.l	D0
	 beq.s	aa_nomem

* Copy over string, in Upper Case thanks.
	move.l	BasePath,A0
	lea.l	an_String(A2),A1

1$:	move.b	(A0)+,D0
	 beq.s	4$			; string is cleared, no term needed
	move.b	Wild,an_Flags(A2)	; Set the wildcard flag
	 beq.s	5$			; don't copy/UC if not wild!!!!
	bsr	Toupper
5$:	move.b	D0,(A1)+
	subq	#1,D2
	 bgt.s	1$
4$:

* Insert the node in the list
	tst.l	ap_Base(AnchorBase)	; is this the first?
	 beq.s	2$

	;-- not the first node, merely add to list
	move.l	ap_Current(AnchorBase),A0
	move.l	A2,an_Child(A0)
	move.l	A0,an_Parent(A2)
	bra.s	98$			; set ap_Current, return

* First entry, it is a bit different
* There is no ap_Base, we need to build one for the current directory
2$:
	move.l	A2,A0			; Points to "" (current dir)
	tst.b	Wild			; was there a wildcard?
	 bne.s	10$

	; first, is this the first part of a wildcard list or is it the
	; final AddAnchor for the entire string.
	; no wildcard - We need to lock the pathpart of the string, and
	; use that for an_lock.  Eventually it will be examined, and it
	; will copy the name part of the string over the fib_FileName.
	; 'BasePath' has the pointer to the beginning of the string.
	; 'LastPath' points character past last / or past :.
	; an_String(a2) has the entire path.
	lea	an_String(a2),a0	; lock this instead of ""
	move.l	a0,d1
	SYSCALL	PathPart		; returns to end of path string (may be
					; past :, at last slash, or after last
					; slash if going up dirs
	move.l	d0,a0
	move.b	(a0),d3			; save '/' or char after ':'
					; (note d3 (Wild) is free here)
	clr.b	(a0)			; terminate string (temp)
	move.l	a0,d2			; save ptr

	; set bit to make matchnext return no_more_entries
	bset.b	#DDB_SINGLE,an_Flags(A2)

	lea	an_String(a2),a0	; ptr to beginning of path (again)
	bsr	LockThisForMePlease
	move.l	d2,a0			; string we locked
	move.b	d3,(a0)			; restore byte in string
	bra.s	20$			; check return from lock call
10$:
	bsr	LockThisForMePlease	; on ""
20$:
	move.l	A2,ap_First(AnchorBase) ; MUST be set before checking error!
	move.l	D0,an_Lock(A2)		;  so it can be freed by FreeAnchorChain
	 beq.s	aa_nomem		; Any error from Lock or an allocation
					; error earlier.

98$:	move.l	A2,ap_Current(AnchorBase)
	moveq	#0,d1			; secondary return - success (ugly)
aa_return:
	move.l	A2,D0
	movem.l	(sp)+,D2/D3/A2
	tst.l	d1			; sets cc's for error
	rts

aa_nomem:
	;-- may also be some other sort of error - code is in IoErr().
	bset.b	#APB_NOMEMERR,ap_Flags(AnchorBase)
	moveq	#1,d1			; secondary return - fail (ugly, sorry)
	bra.s	aa_return


* Shared examine code...
* returns 1 if it's been examined before, or if it's a dir, or if it doesn't
* have any children nodes.  ?????  Return 0 if examine fails, or if
* it has children and isn't a directory.  IMPORTANT: MatchNext relies on
* this (and IoErr being 0 in that case) in order to avoid going into
* files as if they were directories.

DoExamine:
	btst.b	#DDB_ExaminedBit,an_Flags(Node)
	 bne.s	10$
	moveq.l	#an_Info,D2
	add.l	Node,D2
	SYSCALL	Examine
	tst.l	D0
	 beq.s	1$
	bset.b	#DDB_ExaminedBit,an_Flags(Node)
	tst.l	an_Child(Node)
	 beq.s	10$
	tst.l	an_Info+fib_DirEntryType(Node)
	 bge.s	10$

	;-- either an error, OR (it's not a leaf AND it's a file)
	;-- FIX! should we force IoErr to 0?
1$:	moveq	#0,D0
	rts
10$:	moveq	#1,D0
	rts


**************************************
*
* MatchNext main entry point - also called from MatchFirst
*
FindNext:
	movem.l	D2/D3/A2/A3/A5,-(sp)
	move.l	D1,AnchorBase
	move.l	ap_Current(AnchorBase),Node

	;-- reset dir changed bit
	bclr.b	#APB_DirChanged,ap_Flags(AnchorBase)

	moveq	#ERROR_NO_FREE_STORE,D0
	btst.b	#APB_NOMEMERR,ap_Flags(AnchorBase)
	 bne	fn_error		; A memory error, prollably in FF

	tst.l	ap_Base(AnchorBase)
	 beq	fn_done			; Anchor has been freed. Scoot.

	bclr.b	#APB_DODIR,ap_Flags(AnchorBase)
	 beq.s	fn_loop

	;-- don't check for hardlinks if we're following them
	btst.b	#APB_FollowHLinks,ap_Flags(AnchorBase)
	 bne.s	fn_enter_dir_all

	;-- normally don't enter a hardlinked dir on ALL.
	moveq	#ST_LINKDIR,d0
	cmp.l	fib_DirEntryType+ap_Info(AnchorBase),d0
	 beq.s	All_done_with_dir	; stay where we are, return DIDDIR

fn_enter_dir_all:
	lea	WildZ(pc),BasePath		; P_ANY
	moveq	#1,D0				; Length
	moveq	#DDF_PatternBit,Wild
	bsr	AddAnchor		; wild, not base: can't fail a lock
	 beq.s	1$			; however, it can fail an alloc
					; returns cc's set for error
	SYSCALL	IoErr			; get error code (ERROR_NO_FREE_STORE)
	bra	fn_error		; return secondary result

1$:	move.l	D0,BasePath			; BasePath is now a temp...
	bset.b	#DDB_AllBit,an_Flags(BasePath)
	bra	fn_newnode

***
* FindNext Loop Point
***
fn_loop:
	;-- SINGLE means no wildcards in this node.
	;-- SINGLE is either the only node, or the top-level node.
	btst.b	#DDB_SINGLE,an_Flags(Node)
	 bne.s	fn_enter		; Initial node is different...
	move.l	an_Lock(Node),D1
	 beq.s	fn_enter			; Skip null initial nodish
	bsr	DoExamine		; Examine this node, if needed.
	 bne.s	fn_enter		; node examined, process/continue

* UpLevel is dedicated to FindNext.  It goes up a level, until
*	the TOP is reached, or until a pattern is found
UpLevel:
	move.l	an_Lock(Node),D1
	SYSCALL	UnLock
	clr.l	an_Lock(Node)
***
	move.l	Node,A1
	move.l	an_Parent(Node),Node
	move.l	Node,ap_Current(AnchorBase)
	 beq.s	fn_done			; Jump to safety, OK for below.

	;-- set flag to indicate dir change
	bset.b	#APB_DirChanged,ap_Flags(AnchorBase)

	btst.b	#DDB_AllBit,an_Flags(A1)
	 beq.s	fn_NotAll
	bsr	FreeDAList
	clr.l	an_Child(Node)

All_done_with_dir:
	;-- done with an DODIR directory

	bset.b	#APB_DIDDIR,ap_Flags(AnchorBase)
	bra	fn_havematch
	
fn_NotAll:
***
	;-- if this level has no pattern, keep going up...
	btst.b	#DDB_PatternBit,an_Flags(Node)
	 beq.s	UpLevel
	;-- fall though - will go to fn_wildloop

* Check if we need to match a pattern in this node
* on main path of loop
fn_enter:
	btst.b	#DDB_PatternBit,an_Flags(Node)
	 bne.s	fn_wildloop
	;-- Fib entry no longer valid
	bclr.b	#DDB_ExaminedBit,an_Flags(Node)
	btst.b	#DDB_Completed,an_Flags(Node)
	 beq.s	fn_continue

	;-- pop up and check there, until I pop out or find something
	bclr.b	#DDB_Completed,an_Flags(Node)
	bra.s	UpLevel

* Out of entries return
fn_done:
	move	#ERROR_NO_MORE_ENTRIES,D0
	bra	fn_error

***
* Search for the next match for the pattern at this level.
****
fn_wildloop:
	move.l	an_Lock(Node),D1
	moveq.l	#an_Info,D2
	add.l	Node,D2
	SYSCALL	ExNext
	tst.l	D0
	 beq.s	UpLevel

***
	moveq.l	#0,D0
	move.l	ap_BreakBits(AnchorBase),D1
	LINKEXE	SetSignal
	and.l	ap_BreakBits(AnchorBase),D0
	 bne	fn_broke
***
	;-- no need to copy to upper case anymore...

	lea	an_String(Node),A0
	move.l	A0,D1
	lea	an_Info+fib_FileName(Node),A0
	move.l	a0,D2
**	SYSCALL	MatchPattern		; Keep this EXTERNAL REFERENCE
	bsr	_MatchPatternNoCase
	tst.l	D0
	 beq.s	fn_wildloop		; No match, loop some more...

	;-- if this is the end of the chain, we have a match, return.
	tst.l	an_Child(Node)
	 beq	fn_havematch		; Finished()

	;-- if it's a file, we can't enter it - loop
	tst.l	an_Info+fib_DirEntryType(Node)
	 blt.s	fn_wildloop		; files are < 0!

* Continue processing a newly entered node, which has a non-wildcard
* string that needs to be locked/examined, and then perhaps further
* directory traversal

fn_newnode:
	bset.b	#DDB_ExaminedBit,an_Flags(Node)
fn_continue:
	bsr.s	fn_getstring		; Get this node's string
	bsr	DoRelLock
	move.l	D0,LockReg
	 beq.s	40$			; No Lock. Fluff.
					; something's wrong here, this goes
					; to uplevel...(?)
	; it goes to uplevel to handle #?/foo, etc.

	move.l	LockReg,D1
	bsr	DoExamine
	 bne.s	fn_checkmatch		; successfully examined it

	;-- Examine failed? (or it's not a leaf and the node is a file)
	move.l	LockReg,D1
	SYSCALL	UnLock			; DAMN CHARLIE!  Unlock preserves
					; ioerr value (from examine).
40$:	;-- lock failure comes here
	SYSCALL	IoErr
	tst.l	d0			; was this a non-leaf-node file?
	 beq.s	fn_ul			; no error - must be
	move.l	#ERROR_OBJECT_NOT_FOUND,D1
	cmp.l	D0,D1			; was it object not found?
	 bne	fn_error		; no, some other error.  Stop searching

	;-- object not found, continue on (d0.l is OBJECT_NOT_FOUND!)
	;-- check if this is a non-wildcard pattern.
	;-- If it is return OBJECT_NOT_FOUND.
	btst.b	#APB_ITSWILD,ap_Flags(AnchorBase)
	 beq	fn_error		; no wildcards and failed a lock
	; has wildcards somewhere

	;-- Uplevel will return no more entries if it pops out
fn_ul:	bra	UpLevel			; Hope this works ...

* Here, a valid Examined node for a non-wildcarded string.
* If it is the last node, return it after freeing the lock on the item.
* If this is a non-wildcard node, make sure the name is the same we used to
* lockthe entry, NOT the value returned by Examine()!  This is to make this
* work better with links (especially soft links), and with foo/bar/// type
* stuff.
fn_checkmatch:
	;-- we don't need to check if it's a file, as DoExamine returns an
	;-- error if it's a file AND it's not a leaf node!
	btst.b	#DDB_PatternBit,an_Flags(Node)
	 bne.s	fn_no_copy

	;-- a node that has no wildcards - return same name used to lock
	;-- it!
	lea	an_String(Node),a0	; start of path
	move.l	a0,d1
	SYSCALL	FilePart		; returns d0 = ptr to start of fname
	move.l	d0,a0			; pointer to name
	lea	an_Info+fib_FileName(Node),a1
1$	move.b	(a0)+,(a1)+		; copy an_string over examined string!
	bne.s	1$

fn_no_copy:
	;-- is this the end of the chain (do we have a complete match?)
	move.l	an_Child(Node),D0
	 beq.s	fn_match1

	;-- no, need to match child node
	move.l	D0,Node
	move.l	LockReg,an_Lock(Node)
	move.l	Node,ap_Current(AnchorBase)
	bclr.b	#DDB_ExaminedBit,an_Flags(Node)

	;-- set flag to indicate dir change
	bset.b	#APB_DirChanged,ap_Flags(AnchorBase)

	bra	fn_loop

***
* Subroutine to get a string to form a path to the object.  Get an_String
* if not wild, fib_FileName if we found it by ExNext.
*
fn_getstring:
	lea	an_String(Node),A0
	btst.b	#DDB_PatternBit,an_Flags(Node)
	 beq.s	61$
	lea	an_Info+fib_FileName(Node),A0
61$:	rts

**
* we have a non-wildcard match on the final node.
*
fn_match1:
	;-- we have a match, unlock lock on final item
	bset.b	#DDB_Completed,an_Flags(Node)
	move.l	LockReg,D1
	SYSCALL UnLock

* Great stuff.  We have a match (wildcard or not).  Do Something!!!!!
fn_havematch:
	move.l	ap_Current(AnchorBase),Node

	lea	ap_Info(AnchorBase),A0		; Copy over FIB...
	lea	an_Info(Node),A1
	moveq	#(fib_SIZEOF/4)-1,D0
71$:	move.l	(A1)+,(A0)+
	 dbra	D0,71$

** Now use ap_StrLen instead of LONG ap_Length
	move.w	ap_Strlen(AnchorBase),D2	; Max length
	 beq.s	fn_valid				; Nothing to copy!!!

	move.l	ap_First(AnchorBase),Node
	lea	ap_Buf(AnchorBase),BasePath
	move.l	BasePath,A1			; BasePath is for compare

** Build ap_Buf from the AnchorChains.  Tells us how we got there from
** here.
72$:	bsr.s	fn_getstring			; Get this node's string

73$:	subq.w	#1,D2
	 ble.s	fn_overflow			; Out of room in buf...
	move.b	(A0)+,(a1)+
	 bne.s	73$

	move.l	an_Child(Node),Node		; is the the final node?
	move.l	Node,D0
	 beq.s	fn_valid			; All clear tank yew

	subq.l	#1,A1				; handle "" nodes.
	cmpa.l	BasePath,A1
	 beq.s	72$				; Do Nothing  - still strstart

* See if a / is needed here.
	cmp.b	#':',-1(A1)		; did node end in :?
	 beq.s	72$			; yes, nothing needed
	moveq	#'/',D0
	cmp.b	-1(A1),D0		; did it end in '/'?
	 beq.s	72$
	move.b	D0,(A1)+		;No, put a slash on the end
	subq.w	#1,D2			;and decrement our space in buffer
	bra.s	72$

* CheckBreak comes here, offset stack.
fn_broke:
	move.l	D0,ap_FoundBreak(AnchorBase)
	move	#ERROR_BREAK,D0

*	Fall through
***	bra.s	fn_error

* Here, a valid return.  Check to see if the anchor should be freed.
*fn_valid:
*	moveq	#0,D0
*	moveq	#(1<<APB_ITSWILD)+(1<<APB_DOWILD),D1
*	and.b	ap_Flags(AnchorBase),D1
*	 bne.s	fn_rts

fn_error:
	move.l	D0,D2
	move.l	AnchorBase,D1
	bsr.s	FreeAnchorChain
	move.l	D2,D0
	bra.s	fn_rts

fn_valid:
	moveq	#0,d0
	bra.s	fn_rts

fn_overflow:
	move	#ERROR_BUFFER_OVERFLOW,D0
fn_rts:	ext.l	D0			; MUST BE FIXED!!!!!!!!!!!!!!!!
	move.l	D0,D1
	move.l	D0,D2
	SYSCALL	SetIoErr
	move.l	D2,D0
	movem.l	(sp)+,D2/D3/A2/A3/A5
	rts



***********************************************************************
*
* FreeAnchorChain( D1 )
*
*	Frees all stuff associated with D1.  It's an anchorchain,
* which is a semi-private structure used by FindFirst/FindNext.
*
***********************************************************************
FreeAnchorChain:
	move.l	A2,-(sp)
	move.l	D1,A2
1$:	move.l	ap_First(A2),d0
	 beq.s	10$
	move.l	D0,A0
	move.l	an_Lock(A0),D1
	 beq.s	2$
	SYSCALL	UnLock
2$:	move.l	ap_First(A2),A1
	move.l	an_Child(A1),ap_First(A2)
	LINKEXE FreeVec				; A1
	bra.s	1$

10$:	move.l	(sp)+,A2
	rts

***********************************************************************
* 
* lock = RelLock(lock,name)
*  D0  =	  D1,  A0
*
*	Input is a lock in D1, and a name in A0.
*	Return value in D0 is the lock for name, relative to base dir lock.
*
*	NOTE - Register D2 is clobbered!
*
***********************************************************************
DoRelLock:
	btst.b	#DDB_SINGLE,an_Flags(Node)
	 bne.s	LockThisForMePlease
	move.l	an_Lock(Node),D1
	 beq.s	LockThisForMePlease
RelLock:
 	move.l	A0,-(sp)
	SYSCALL	CurrentDir
	move.l	(sp),D1
	move.l	d0,(sp)
	bsr.s	LTFM
	move.l	(sp),D1
	move.l	d0,(sp)
	SYSCALL	CurrentDir
	move.l	(sp)+,D0
	rts

LockThisForMePlease:
	move.l	A0,D1
LTFM:	move.l	d2,-(sp)		; charlie made this trash d2!!!!
	moveq.l	#ACCESS_READ,D2		; this is a pain so I fixed it
	SYSCALL	Lock
	move.l	(sp)+,d2
	rts

***********************************************************************



******************* U S E R  R O U T I N E S *************************
*
*   NAME
*       DosAllocMem -- AmigaDOS compatible memory allocator
*
*   SYNOPSIS
*       memBlock = DosAllocMem( size_in_bytes )
*           d0                      d0
*
*   FUNCTION
*       This function returns a memory block of the size requested, or
*       NULL if the allocation failed.  The memory will satisfy the
*       requirements of MEMF_PUBLIC | MEMF_CLEAR.
*
*       As expected by AmigaDOS, the total size of the memory block is
*       stored at (memblock - 4), so the actual memory allocated will
*       always be four bytes larger than size_in_bytes.
*
*   INPUTS
*       size_in_bytes - the size of the desired block in bytes.
*
*   RESULT
*       memBlock - a pointer to the allocated free block.  This block
*                  will be longword aligned, and the total size of the
*                  block is stored at (memblock - 4).  If the allocation
*                  failed, memBlock will return zero.
*
*   ADDITIONAL CONSIDERATIONS
*       The value returned by DosAllocMem is a real pointer.  If you
*       need a BPTR, you must convert this value yourself.
*
*   BUGS
*       None known.
*
*   SEE ALSO
*       DosFreeMem()
*
*   AUTHOR: SDB
*   REVISED:
***********************************************************************

DosAllocMem:
	move.l	#MEMF_PUBLIC!MEMF_CLEAR,d1
	LINKEXE	AllocVec			; d0,d1
	rts

* FreeDAList
*	Call with A1 = dlist
FreeDAList:
	move.l	a6,-(sp)
	move.l  AbsExecBase,a6
	bra.s	fdentry

fdloop:	move.l	(A1),-(sp)
	jsr	_LVOFreeVec(a6)			; A1
	move.l	(sp)+,A1
fdentry:
	move.l	A1,D0
	 bne.s	fdloop
	move.l	(sp)+,a6
	rts


@


36.49
log
@Fixed return code for non-wildcard patterns when the file/dir isn't found.
@
text
@d295 1
a295 1
	 bne.s	ppFail		; Not in ()!  FIX!!! Handle x|y|z! ((a4) == 0)
d359 1
d362 5
a366 1
	move.b	Curchr,(Dest)+	; P_CLASS (or NOTCLASS) first time...
d369 1
a369 1
	cmp.b	#$27,Curchr	; '
@


36.48
log
@argh.  instead of splitting off the xxx:, split off the last part of
the path from the rest always.  still fixes anything with xxx:yyy,
also fixes a nasty bug with foo#?/bar/asdf - you'd get a lock of
foo, and a filename of asdf.  very bad.  Also handles trailing slashes
better to make for more readable results - a single traling slash
gets nuked - however, not if it follows a : or / (of course).
@
text
@d1356 6
a1361 7
	;-- object not found, continue on (d0 is OBJECT_NOT_FOUND!)
	;-- check if this is the first node in the list - if it is, AND
	;-- this is the one and only node, return OBJECT_NOT_FOUND.
	tst.l	an_Child(Node)
	 bne.s	fn_ul			; not the last node
	cmp.l	ap_First(AnchorBase),Node
	 beq	fn_error		; one and only node - error
@


36.47
log
@Added code to split off anything up to a : in a separate node
@
text
@d894 1
a894 1
	 beq.s	ff_error		; check for error anyways
a900 11
	;-- make sure anything up to a : is broken into a separate node
	;-- in the list.  This means that it won't leave nodes like
	;-- "df0:foo" as a single entry, which causes it to relock the whole
	;-- string on a DODIR (and may get the wrong volume).
	move.l	LastPath,d0
	sub.l	BasePath,d0		; d0 is a parameter to AddAnchor
	 beq.s	ff_loop			; no ':' in string
	bsr	AddAnchor		; make a node of it
	 bne.s	ff_error		; couldn't lock it or some such
	move.l	LastPath,BasePath	; reset accumulation point

d927 1
a927 1
	bsr.s	AddAnchor		; add a node for the directories
d939 14
a952 1
20$:	move.l	CurPath,LastPath	* Set the "Last path" for next wild
d971 27
d1000 1
d1004 1
d1369 4
a1372 3
* If this is a single node, make sure the name is the same we used to lock
* the entry, NOT the value returned by Examine()!  This is to make this work
* better with links (especially soft links).
d1376 5
a1380 3
	btst.b	#DDB_SINGLE,an_Flags(Node)
	 beq.s	fn_no_copy
	
@


36.46
log
@Added APF_FollowHLinks, made MN() not follow hard links on DODIR
unless the new bit is set.
@
text
@d900 11
@


36.45
log
@Fixed memoration problem with DODIR.  The AddAnchor call was making it
think the secondary error was 0 (which is success), so the caller would
use a freed lock.

@
text
@d1158 10
d1210 1
a1210 1
	 beq.s	15$
d1214 3
d1220 1
a1220 1
15$:
@


36.44
log
@Added back test for failure to examine on root node, plus added test to
make sure it's the one and only node (i.e. no wildcards)
@
text
@d1162 4
a1165 1
	 bne	fn_error		; returns cc's set for error
d1167 1
a1167 1
	move.l	D0,BasePath			; BasePath is now a temp...
d1440 1
a1440 1
fn_rts:	ext.l	D0
@


36.43
log
@Fixed goddamn charlie code - DoExamine is where the test was hiding,
and it was returning 0 instead of an error (really should go to uplevel,
and know it does).
@
text
@d1297 9
a1305 2
	
	;-- object not found, continue on
@


36.42
log
@Added comments
Fixed file/#? - it wasn't checking to see if a non-wildcard non-
leaf node was a directory before entering it.
Fixed a file/dir check - was <= 0 for file, now is < 0.
@
text
@d1110 3
a1112 1
* it has children and isn't a directory.
d1127 3
d1286 1
a1286 1
	;-- Examine failed?
d1292 2
d1298 2
a1299 3
	;-- object not found, continue on (d0 is object not found!)
	cmp.l	ap_First(AnchorBase),Node
	 beq	fn_error		; oops, hit the root
d1308 2
a1309 11
	;-- if it's not a child node, and it's a file, this is no match.
	tst.l	an_Child(Node)
	 beq.s	fn_is_dir		; it's a leaf, no problem
	tst.l	an_Info+fib_DirEntryType(Node)
	 bge.s	fn_is_dir		; it's not a leaf, but is a dir - ok

	;-- non-leaf node, object is a file (no match)
	;-- act as if the object was not found (like it does on patterns)
	bra.s	fn_ul			; goto UpLevel, no match here

fn_is_dir:
d1355 1
a1355 1
	SYSCALL	UnLock
@


36.41
log
@Fixed character classes (weren't case-insensitive when it needed to be).
@
text
@d903 1
a903 1
*	LastPath is the start or the last / seen
d1007 2
d1254 1
d1257 2
d1260 1
a1260 1
	 ble.s	fn_wildloop
d1294 1
a1294 1
	bra	UpLevel			; Hope this works ...
d1302 11
@


36.40
log
@Return reasonable result2 values from parsePattern errors
Return error for unbalanced []
@
text
@d686 4
a689 1
	 beq.s	10$			; No character to match!
d691 9
d701 1
a701 1
	 beq.s	10$			; Bad format pattern string!!!
d704 1
a704 1
	 beq.s	10$			; End of class, not found - skip, return
d707 1
a707 1
	 beq.s	20$			; Good match, go skip to P_CLASS
d717 1
a717 1
	 bls.s	20$			; Good range matched get out!!!
d723 1
a723 1
	 beq.s	10$
d730 2
a731 1
10$:	tst.b	d1
d733 1
a733 1
	bra.s	25$
d737 2
a738 1
20$:	tst.b	d1
d740 2
a741 1
25$:	tst.b	(A0)
d744 1
a744 1
	 bne.s	25$
@


36.39
log
@Use a symbol instead of a constant
removed unneeded test
redid error condition on Examine/Lock error
@
text
@d154 9
a194 9
*****
*
*	Here's the ParsePattern entrypoint.....
*
PreParseNoCase:
	movem.l	D2-D6/Ptr/A3/a4,-(sp)
	moveq	#1,d6
	bra.s	preparse_common

d222 4
a230 1

d242 1
a242 1
	bsr	@@rootstruct	; FIX! use dosbase!
d363 1
a363 1
	 beq.s	ppstore		; EOS premature ick.
d367 1
a367 1
	 beq.s	ppstore		; EOS
d378 1
a378 1
	beq.s	ppend
d382 6
a387 1
	moveq.l	#-1,TYpe
@


36.38
log
@Use symbolic computed values instead of hardcoded constant
@
text
@d163 1
d1130 1
a1130 1
	moveq	#1,Wild
d1132 1
a1132 2
	tst.l	d0				; I don't guarantee the CC
	 beq.s	fn_loop
d1247 2
d1251 1
a1251 1
	 bne.s	fn_checkmatch
d1257 9
a1265 6
40$:	SYSCALL	IoErr
	tst.l	D0
	 bne.s	41$
	move.w	#ERROR_OBJECT_NOT_FOUND,D0	;evil opt - d0 must have been 0
41$:	cmp.l	ap_First(AnchorBase),Node
	 beq	fn_error
@


36.37
log
@Major changes: fixes #?/.info, use NoCase stuff
MUCH added commenting, some optimizations
@
text
@a160 2
NUM_WILDCARDS	EQU	10

d167 1
d171 2
d174 1
a174 1
	moveq	#NUM_WILDCARDS,D0
@


36.36
log
@Added APF_DirChanged
@
text
@a29 1

d40 1
a40 4

	INCLUDE	"exec/libraries.i"
*	include	"dos/dos_lib.i"

a41 8

*	include "exec/nodes.i"
*	include "exec/alerts.i"
*	include "exec/initializers.i"
*	include "exec/resident.i"
*	include "exec/ports.i"
*	include "exec/execbase.i"
*	include	"exec/ables.i"
d131 2
a132 1
*	  BOOL IsWild - whether there were any wildcards in the string
d212 1
a212 1

d255 7
d290 2
a291 9
	 bne	ppFail		; Not in ()!  FIX!!! Handle x|y|z! ((a4) == 0)
	bra.s	ppstore		; stores P_ORNEXT

* Leave a trailing NOT alone ...
ppStartNot:
	tst.b	(Ptr)		; KLUDGE to help mg (micro-gnu-emacs)
	 beq.s	ppRegular
	bra.s	ppPushToken

d430 1
a430 1
	move.l	D3,-(sp)
d435 1
a435 1
	move.l	D3,-(sp)
d438 4
a441 1
	move.l	D1,A0			; Get args internal froboz thanks.
d443 4
d448 2
a449 1
	move.l	(sp)+,d3
d463 3
d468 8
d477 5
a487 5
*
* Main looping point for PatternMatch - MUST return cc's!!!!!
*
Internal_PatternMatch:

d515 3
d829 1
d831 1
a831 1
	move.l	d0,d4			; save for free
d836 2
a837 2
	move.l	BasePath,A1
2$:	move.l	CurPath,A0		; Save position to start PreParse...
d839 2
d842 1
a842 1
	subq.l	#1,d5			; remember how much buf space is used
d844 1
a844 1
	 beq.s	5$
d847 6
a852 1
	bra.s	2$
d855 1
a855 1
*	Here,	A0 = start of string beyond ":"
d862 3
a864 3
5$:	move.l	A0,D1
	move.l	LastPath,D2
	move.l	d5,D3
d866 4
a869 1
	bsr	PreParse
d871 2
d877 8
a884 4
*	BasePath is the initial anchor
*	CurPath = LastPath is either BasePath, or follows ":"
10$:	move.b	(CurPath),D0
	 beq.s	90$			; Exit loop
d888 1
a888 1
	 bgt.s	10$			; since it's a SIGNED comparison, and
d891 1
d893 6
a898 3
* FIX!!! handle '
	tst.b	Wild
	 bne.s	12$			* If already building a wildcard
a902 1
	tst.l	d1
d908 1
a908 1
	moveq	#1,Wild
d910 1
a910 1
	bra.s	10$
d912 1
d916 1
a916 1
	 beq.s	10$			; if we hit a wildcard, basepath to
d922 1
a922 1
	subq.l	#1,D0			* Wild must be 1 here
a923 1
	tst.l	d1
d927 1
a927 1
	bra.s	10$
d929 6
a934 3
	; end of path, make final node
90$:	move.l	CurPath,D0		; last position examined (== \0)
	sub.l	BasePath,D0		; either original, or after last
a935 1
	tst.l	d1
d938 1
a938 1
91$:	move.l	ap_First(AnchorBase),ap_Current(AnchorBase)
d979 1
d982 2
d986 1
d1006 1
a1006 1
	 beq.s	5$
d1017 1
d1021 1
a1021 1
	bra.s	98$
d1068 1
a1068 1
	move.l	A2,D0			; no longer uses cc's for returns
d1070 1
d1081 4
d1141 2
d1148 1
a1148 1
	 bne.s	fn_enter
d1175 1
d1178 1
d1181 1
d1185 1
d1190 4
d1200 1
a1200 1
* Get patterns
d1217 1
a1217 9
	;-- stack must be word-aligned!
	sub.w	#108+2,sp		; sizeof(fib_FileName)+1

	lea	an_Info+fib_FileName(Node),A0
	move.l	sp,A1
14$:	move.b	(A0)+,D0
	bsr	Toupper
	move.b	D0,(A1)+
	 bne.s	14$
d1221 2
a1222 1
	move.l	sp,D2
d1224 1
a1224 2
	bsr	_MatchPattern
	add.w	#108+2,sp		; sizeof(fib_FileName)+1
d1244 2
a1245 1

d1249 2
d1252 2
a1253 2
	SYSCALL	UnLock

d1263 1
a1263 1
* If it is the last node, return it after freeing the node's lock.
d1280 1
d1283 2
d1296 3
d1306 3
d1310 1
d1315 1
a1315 1
* Great stuff.  We have a match.  Do Something!!!!!
d1326 1
a1326 1
	move	ap_Strlen(AnchorBase),D2	; Max length
d1333 2
a1334 1
** Do more stuff.
d1337 1
a1337 1
73$:	subq	#1,D2
d1342 1
a1342 1
	move.l	an_Child(Node),Node
d1346 1
a1346 1
	subq	#1,A1
d1348 1
a1348 1
	 beq.s	72$				; Do Noting  - still strstart
d1351 2
a1352 2
	cmp.b	#':',-1(A1)
	 beq.s	72$
d1354 1
a1354 1
	cmp.b	-1(A1),D0
d1357 1
a1357 1
	subq	#1,D2			;and decrement our space in buffer
@


36.35
log
@ParsepatternNoCase fell through instead of going to the common code
@
text
@d911 1
d913 3
a915 2
	movem.l	(SP)+,D2-D5/A2-A6
	bra	FindNext		; call FindNext (d1)
d937 1
a937 1

d1070 3
d1102 1
a1102 1
	bsr.s	DoExamine		; Examine this node, if needed.
d1117 3
d1238 4
@


36.34
log
@Moved P_SINGLE to the right place.
@
text
@d202 1
d214 1
@


36.33
log
@68000 machines require even-word stacks, of course.
@
text
@a452 5
* Case of ?, looking for a single character
do_P_SINGLE:
	tst.b	(A1)+
	 beq.s	MatchFail		; No char to match...

d467 6
@


36.32
log
@Added case-insentive entry points
Fixed charlie's evil buffering problems.  Now it knows how large the
is.
@
text
@d1153 2
a1154 1
	sub.w	#108+1,sp		; sizeof(fib_FileName)+1
d1168 1
a1168 1
	add.w	#108+1,sp		; sizeof(fib_FileName)+1
@


36.31
log
@Major fix to pattern code.  Repend/Orend no longer return (in fact, only stop
forces immediate exit.)
Added [~chars].
@
text
@a46 2
MaxInputBuf	EQU	256		; used to be in dosasl.i  -- FIX!

d57 2
a58 2
	xdef	PreParse
	xdef	_FindFirst,_MatchPattern
d189 6
d199 4
d204 2
a205 2
	movem.l	D2-D5/Ptr/A3/a4,-(sp)

d279 1
a279 1
	bsr.s	IsWild		; cc eq means it got a match
d292 1
a292 1
	 bne.s	ppFail		; Not in ()!  FIX!!! Handle x|y|z! ((a4) == 0)
d309 6
a314 1
	move.b	Curchr,(Dest)+
a339 6
*** Handle #?
ppAny:
	addq	#1,Ptr
	move.b	#P_ANY,Curchr
	bra.s	ppstore

d343 1
a343 1
	 beq.s	ppAny
d390 1
a390 1
	movem.l	(sp)+,D2-D5/Ptr/A3/a4
d438 5
d444 3
d449 3
a451 1
	bra.s	Internal_PatternMatch
d458 14
d493 8
a500 1
	cmp.b	(A1)+,D0		; a literal character
a506 14
* End of pattern; if str is also at end, TRUE else FALSE
chekmatch:
	tst.b	(A1)
	 bne.s	MatchFail		; Failed return...

* P_STOP is a "special" case, returning TRUE, with A1 guaranteed
* to be at current position of STR, and A0 updated to next unused token...
* This is because it matches REPBEG to REPEND, and then tries to match the
* pattern at REPEND, until REPBEG to REPEND match fails.
do_P_STOP:
MatchOK:
	moveq	#1,D0			; Everybody happy return
	rts

d579 1
a579 2
	bra.s	do_P_STOP

d590 1
a590 1
	 beq.s	do_P_OREND		; Real Bad Condition. Barfola
d796 1
a796 1
	movem.l	D2-D4/A2-A6,-(sp)
d812 3
d825 1
d842 1
a842 1
	move.l	#MaxInputBuf-2,D3
d909 1
a909 1
	movem.l	(SP)+,D2-D4/A2-A6
d933 1
a933 1
	movem.l	(SP)+,D2-D4/A2-A6
d1153 1
a1153 1
	sub	#MaxInputBuf,sp
d1167 1
a1167 1
	add	#MaxInputBuf,sp
@


36.30
log
@Vector SetIoErr to right routine
@
text
@a275 13

***** Handle P_CLASS stuff here->  ( [<char class>] )
ppStartClass:
1$:	subq.l	#1,Buflen	; store up the characters in the class
	 ble.s	ppFail
	move.b	Curchr,(Dest)+	; P_CLASS first time...
	move.b	(Ptr)+,Curchr
	 beq.s	ppstore		; EOS premature ick.
	cmp.b	#']',Curchr	; FIX!!!!! doesn't handle ']!!!!!!
	 bne.s	1$
	move.b	#P_CLASS,Curchr	; we're done
	bra.s	ppstore

d279 1
a279 1
	 bne.s	ppFail		; ) without (!!!
d350 22
d411 1
a411 2
*	    If the first character following [ is !, the class is negated.
*	FIX!!!! '!' doesn't work
d415 1
a415 1
*	    To match against ], ??????FIX!!!!!
a440 2
do_P_NOTCLASS:				; NOTCLASS is a NOP

d454 2
d460 1
a460 1
	cmp.b	#P_REPEND,D0		; the 'highest' entry!!  CAREFUL!
d474 1
a474 1
* P_REPEND and P_OREND are "special" cases, returning TRUE, with A1 guaranteed
d476 3
a478 3

do_P_REPEND:
do_P_OREND:				; used to go to pm_Loop
a510 4
* We need to save the current position in the string, but NOT the position in
* the pattern (we want to start further matching after the next token of the
* pattern, including (...)).
*
d555 1
d567 2
a568 2
	 beq.s	do_P_OREND			; Real Bad Condition. Barfola
	cmp.b	#P_ORSTART,(A0)			; FIX!! Handle a|b|c!!!
d570 1
a570 1
	addq	#1,D1				; handle (...|...(...|...))...
d573 3
a575 3
	subq	#1,D1
	 bge.s	1$				; also handles (...|...)(...)
	bra	pm_Loop
d591 3
d596 1
a596 1
	bsr	Internal_PatternMatch	; pops out on fail or OREND
d599 1
a599 3
	bra	pm_Loop			; popped out on OREND
					; MUST NOT put pointers back for
					; REPEND to work right!
d632 3
d636 2
d670 4
a673 1
10$:	bra	MatchFail
d676 4
a679 1
20$:	tst.b	(A0)
d682 1
a682 1
	 bne.s	20$
d708 1
a708 1
	move.l	A0,A2			; Save this position of PAT
d710 4
d717 2
a718 2
	move.l	A2,A0			; Match against pat @@P_REPEND, current
					; str
d720 1
a720 1
	 bne.s	RepOK			; If yes, yippie go home
d722 6
a727 2
	;-- When it hits P_REPEND, it returns immediately.
	movem.l	(sp),A0/A1		; No, match against P_REP
d729 3
a731 1
	 beq.s	BadRep			; No match for Rep...
d736 1
d829 1
a829 1
	cmp.b	#P_REPEND,D0		; ']', it's the 'largest' wildcard token
d831 1
a831 1
					; the values are $80-$8a, the most
@


36.29
log
@Use toupper from rdargs.asm (which uses utility)
@
text
@d71 1
a71 1
	DOS	SetIoErr,@@setresult2
d806 1
@


36.28
log
@removes debug code, comment changes
@
text
@d74 2
a1330 19

***************************************
* convert character in d0 to upper case.
* do not change any other registers
* do not use arp base
***************************************

Toupper:
	and.l	#$0ff,D0
	cmp.b	#'a'-1,d0
	bls.s	2$
	cmp.b	#'z',d0
	bhi.s	1$
	sub.b	#'a'-'A',d0
	rts
1$:	cmp.b	#$df,D0
	bls.s	2$
	sub.b	#$40,D0
2$:	rts
@


36.27
log
@Fixed ~!!!!!  it works _right_ now.  Left in some debug code,
will remove momentarily.
@
text
@a420 17
 XREF _kprintf
dbug1:
 move.l	a1,-(sp)
 move.l a0,-(sp)
 moveq  #0,d0
 move.b (a0),d0
 move.l d0,-(sp)
 pea	mystr(pc)
 jsr	_kprintf
 addq.w #8,sp
 move.l (sp)+,a0
 move.l (sp)+,a1
 rts

mystr dc.b "first char: 0x%lx; pat: %s  str: %s",$0a,0
      ds.w 0

d586 1
a586 1
	bsr	Internal_PatternMatch	; pops out on fail or OREND or ORNEXT?
d589 1
a589 1
	bra	pm_Loop			; popped out on OREND or ORNEXT?
d591 1
a591 1
					; NOTEND and REPEND to work right!
@


36.26
log
@comment changes
@
text
@a245 1
* FIX?  I think this is dead code!
d247 2
a248 1
	 ble.s	ppRegular   ; WRONG! -> ; One of *~[] which are ignored here...
a316 5
* Check if there is a pending P_NOTEND
	moveq.b	#P_NOTEND,d0
	cmp.b	#P_NOT,(a4)		; top entry always 0, so it's safe
	beq.s	2$

d318 2
a319 2
1$:	cmp.b	#P_REPBEG,(a4)
	bne.s	pp_braloop		; nope, loop
d321 1
d323 9
a331 1
2$:	;-- common 'add token and pop token stack' rtn
a335 1

d421 17
d455 9
d465 1
a465 1
	move.b	(A0)+,D0
d482 1
a482 2
*	to be at current position of STR...
* Ditto for P_NOTEND.  Return whether we matched up to the NOTEND.
a483 1
do_P_NOTEND:				; And ... so for this time is TAGEND...
d485 1
d512 12
a523 1
* I_P returns on P_NOTEND, with a0/a1 updated, and cc's set!!
d525 3
a527 1
	bsr	Internal_PatternMatch
a528 7
	bra.s	pm_Loop			; Try to match the rest of the pattern.
					; It used to negate the entire rest of
					; the pattern.
**
* Found a matched OR - but it may not be the match we want, so skip to end
*	of OR code and try it out.
do_P_ORNEXT:
d530 6
a535 4
* Loop to end of OR condition, and go search for PAT at ORPEND
1$:	tst.b	(A0)
	 beq.s	do_P_OREND			; Real Bad Condition. Barfola
	cmp.b	#P_ORSTART,(A0)			; FIX!! Handle a|b|c!!!
d537 2
a538 2
	addq	#1,D1
2$:	cmp.b	#P_OREND,(A0)+
d541 2
a542 1
	 bge.s	1$
a543 5
* P_OREND and P_ORNEXT common code.  Found a match up to end of OR code,
*	now see if the rest of the string matches.
do_P_OREND:
	bra	pm_Loop

d550 2
a551 2
	add	D0,D0
	and	#$fe,D0			; Mask out extra bits
d568 20
d596 5
d603 1
a603 1
	bsr	Internal_PatternMatch
d605 2
a606 2
	addq.l	#8,a7			; drop old pointers!
	bra	MatchOK			; popped out on end, NOTEND, or REPEND
d612 1
d616 2
a617 2
1$:	move.b	(A0)+,D0
	 beq	MatchFail
d629 1
a629 1
	bra.s	do_P_ORSTART		; we found a OR_NEXT, repeat
d632 6
d688 2
a689 2
do_P_REPBEG:
	movem.l	A0/A1/A2,-(sp)
@


36.25
log
@Mostly comment changes.  Moved a IoErr call just in case UnLock starts touching it.
@
text
@d925 1
d1185 1
@


36.24
log
@comment changes
@
text
@d773 1
a773 1
* Handle a subdir /
d812 6
a817 1
	move.l	AnchorBase,D1
d824 4
a827 2
	;-- CAREFUL! (No FIX needed) - a6 == Execbase!
	SYSCALL	IoErr			; get IoErr for return code in D0
d833 1
a833 1
* AddAnchor(AnchorBase, BasePath, Wild)
d892 3
a894 1
	SYSCALL	PathPart		; returns ptr 1 past last in path
d906 2
a907 2
	move.l	d2,a0
	move.b	d3,(a0)			; restore entire string
d914 2
a915 1
	 beq.s	aa_nomem		; allocation error
a916 1

d1091 1
a1091 1
	move	#ERROR_OBJECT_NOT_FOUND,D0	;evil opt - d0 must have been 0
@


36.23
log
@Fixed a SHITLOAD of old bugs in the patternmatch and parsing code.
~ now applies to the next token, not the rest of the pattern.
#(...) now works
# works better in general (since #(...) was broken, other bugs were hidden)
a bunch of "depth" bugs were fixed (OR finding |'s in other or expressions,
for example.)
etc, etc, etc, etc ,etc ,etc, etc, etc etc
@
text
@a71 1
	DOS	currentdir,_CurrentDir
d77 1
d1240 1
a1240 1
*	NOTE - Register D2 is clobbered.
@


36.22
log
@Added comments mainly, clarified some things (sizes for tst Wild, etc)
@
text
@d163 1
d165 28
d194 1
a194 3
	movem.l	D2-D5/Ptr,-(sp)
	move.l	D1,Ptr
	move.l	D2,A1
d196 25
d223 1
d225 3
d230 1
a230 1
	 bne	ppRegular
d242 1
a242 1
	 bne.s	0$		; if set, allow "*"
d246 1
d248 1
a248 1
	 ble	ppRegular   ; WRONG! -> ; One of *~[] which are ignored here...
d250 2
a251 2
0$:	move.b	WildZ(pc,d0.w),Curchr	; May be a direct substitute char
	add	D0,D0			; word offset - bra.s == 2 bytes
a253 12
IsWild:	lea	Wildstuff,A0
	moveq	#10,D0
2$:	cmp.b	-(A0),Curchr
	 dbeq	D0,2$
1$:	rts

*** NOTE - WildZ IS REFERENCED FOR FindAll !!!!
WildZ:	dc.b	P_ANY,P_TAG,P_CLASS,']',P_REPBEG
	dc.b	P_SINGLE,P_ORSTART,P_OREND,P_ORNEXT,0,0
	dc.b	"*~[]#?()|%'"
Wildstuff:	ds.w	0

d255 1
a262 1
	bra.s	ppstore		; |
d264 1
d266 1
d268 2
a269 3
* Tick ' comes here ...
	move.b	(Ptr)+,Curchr
	bsr.s	IsWild
d271 1
a271 1
	subq	#1,Ptr
d273 1
a273 1
	bra.s	ppRegular
d275 1
a275 1
***** Handle P_CLASS stuff here->
d277 1
a277 1
11$:	subq.l	#1,Buflen
d282 3
a284 3
	cmp.b	#']',Curchr
	 bne.s	11$
	move.b	#P_CLASS,Curchr
d287 1
a287 18
*** Handle #(pat)
ppStartRep:
	cmp.b	#'?',(Ptr)
	 beq.s	21$
	subq.l	#1,Buflen
	 ble.s	ppFail
	move.b	Curchr,(Dest)+	; P_REPBEG
	moveq	#1,WPending
	moveq	#1,TYpe
	bra	ppLoop
21$:	addq	#1,Ptr
	move.b	#P_ANY,Curchr
	bra.s	ppstore

***
ppStartOr:
	addq	#2,WPending	; P_ORSTART
	bra.s	ppstore
d289 8
a296 2
	subq	#2,WPending	; P_OREND
	bra.s	ppstore
d300 3
a302 3
	tst.b	(Ptr)
	 bne.s	ppstore
	move.b	#'~',D0
d304 4
a307 1
ppstore:
d309 1
a309 1
ppRegular:
d313 1
a313 1
	 beq.s	ppend
d315 7
d323 3
a325 3
	cmp	#1,WPending
	 bne.s	1$
	moveq	#0,WPending
d327 2
d331 1
a331 2
	move.b	#P_REPEND,(Dest)+
1$:	bra	ppLoop
d333 31
a363 1
* Come here on buffer overflow
d368 2
a369 1
	movem.l	(sp)+,D2-D5/Ptr
d398 1
d402 1
a428 1
do_P_TAGEND:				; And ... so for this time is TAGEND...
d430 3
a432 2
* Main looping point for PatternMatch

d438 1
a438 1
	cmp.b	#P_REPEND,D0
d440 1
a440 1
	cmp.b	(A1)+,D0
d454 3
d462 2
d465 1
a465 1
	tst.b	(A0)
d468 5
d476 1
a476 1
	movem.l	(sp)+,A0/A1
d478 1
a478 1
	tst.b	(A1)+
d482 4
a485 2
* This is actually P_NOT...
do_P_TAG:
d487 5
a491 3
	 bne	MatchFail		; Bad match.  Don't look further
	bra.s	MatchOK

d499 1
a499 1
	cmp.b	#P_ORSTART,(A0)
d523 1
a523 1
	bra.s	do_P_ANY
d528 2
a529 2
	bra.s	do_P_TAG		; Confiscated for P_NOT P_NOTEND
	bra.s	do_P_TAGEND
d535 9
a543 3



d547 5
a551 2
	movem.l	(sp)+,A0/A1
	 bne	MatchOK
d553 4
d560 3
a562 3
	cmp.b	#P_ORSTART,D0
	 bne.s	2$
	  addq	#1,D1
d565 3
a567 2
	  subq	#1,D1
3$:	tst	D1
a569 10
	 bne	1$
	bra.s	do_P_ORSTART

do_P_REPBEG:
	movem.l	A0/A1/A2,-(sp)

* Skip until P_REPEND
1$:	move.b	(A0)+,D0
	 beq.s	BadRep			; no P_REPEND.  Ick. Ick.
	cmp.b	#P_REPEND,D0
d571 1
a571 1
	move.l	A0,A2			; Save this position of PAT
d573 4
a576 19
2$:	move.l	A2,A0			; Match against pat @@P_REPEND, current str
	bsr	Internal_PatternMatch
	 bne.s	RepOK			; If yes, yippie go home

	movem.l	(sp),A0/A1		; No, match against P_REP
	bsr	Internal_PatternMatch
	 beq.s	BadRep			; No match for Rep...
	cmp.l	4(sp),A1
	 beq.s	BadRep			; Match was NULL, Futz.
	move.l	a1,4(sp)		; Match was OK, loop
	bra.s	2$

RepOK:	movem.l	(sp)+,A0/A1/A2
	bra	MatchOK

BadRep:	movem.l	(sp)+,A0/A1/A2
	bra	MatchFail


d595 2
a596 2
	cmp.b	-2(A0),D0
	 bcs.s	2$
d598 5
a602 4
	 bcs.s	20$			; Good range matched get out!!!
	 beq.s	20$

* Not match
d612 1
d620 6
d627 43
d940 5
@


36.21
log
@Fixed WILDSTAR, and moved MaxInputBug inside (was in dosasl.i)
@
text
@d543 1
a543 1
AnchorBase	equr	A3
d568 1
a568 1
	clr.l	(AnchorBase)		;*** Clear potent garbage
d599 4
d619 4
a622 3
	cmp.b	#P_REPEND,D0
	 bgt.s	10$

d624 1
a624 1
	tst	Wild
d626 1
a626 1
	move.l	LastPath,D0
d629 1
a629 1
	bsr.s	AddAnchor
d632 3
a634 1
	move.l	LastPath,BasePath
d642 3
a644 2
	tst	Wild			* sets LastPath to char after '/'
	 beq.s	10$
d646 1
d657 4
a660 3
90$:	move.l	CurPath,D0
	sub.l	BasePath,D0
	bsr.s	AddAnchor
@


36.20
log
@Moved the ap_First setting to BEFORE checking for lock error
This keeps us from losing 288 bytes on an error.
@
text
@d47 2
d184 2
a185 1
	btst.b	#RNB_WILDSTAR,rn_Flags(a0)
@


36.19
log
@bcc to bcc.s opts
@
text
@d667 1
a667 1
	bsr	FreeAnchorChain		; free up alloced memory
d756 3
a758 1
20$:	move.l	D0,an_Lock(A2)
a760 1
	move.l	A2,ap_First(AnchorBase)
@


36.18
log
@Pattern fixes to allocate buffer for pattern string
@
text
@d229 1
a229 1
	 ble	ppFail
d243 1
a243 1
	 ble	ppFail
d270 1
a270 1
	 ble	ppFail
d280 1
a280 1
	 ble	ppFail
d861 1
a861 1
	 beq	fn_continue
@


36.17
log
@Fixed not returning the right errors if a directory didn't exist
(not all errors are out-of-mem!)
Added comments
@
text
@d88 5
d560 1
a560 2
	movem.l	D2/D3/A2-A5,-(sp)
	sub.w	#MaxInputBuf,sp
d570 10
d581 1
a581 1
	move.l	sp,BasePath		; Set START of path substring 1'st time
d583 1
a583 1
0$:	move.l	CurPath,A0		; Save position to start PreParse...
d585 1
a585 1
1$:	move.b	(CurPath)+,D0
d587 1
a587 1
	 beq.s	2$
d589 2
a590 2
	 bne.s	1$
	bra.s	0$
d596 1
a596 1
2$:	move.l	A0,D1
d602 1
a602 1
3$:	moveq	#0,Wild
d653 4
d658 1
a658 2
	add.w	#MaxInputBuf,sp		; Restore the stackframe,
	movem.l	(SP)+,D2/D3/A2-A5
d668 6
d675 1
a675 2
	add.w	#MaxInputBuf,sp
	movem.l	(SP)+,D2/D3/A2-A5
@


36.16
log
@Many fixes.  It turns out I have to use PathPart, lock that, then do the
Lock/Examine/unlock/(maybe copy over fib_filename).  Works good, takes
extra space.  In the process I made LockThisForMePleaseWithSugarCoating
not trash d2 anymore (argh), and added many comments.  Of course, I
needed to call FilePart as well before copying over fib_filename.
@
text
@d608 2
d625 2
d634 2
d642 1
a642 1
	bra	FindNext
d644 12
d658 1
a658 1
* AddAnchor(AnchorBase, BasePath, Wild, is_last_addanchor)
d663 3
d692 1
a692 1
	tst.l	ap_Base(AnchorBase)
d708 1
a708 4
	; final AddAnchor for the entire string.  D4 tells us this (1 =
	; Last AddAnchor).
;	tst.b	D4
;	 beq.s
d733 1
a733 1
	bsr	LockThisForMePlease
d740 1
d742 1
a742 1
	move.l	A2,D0
d748 1
d780 1
a780 1
	tst.l	(AnchorBase)
d789 2
a790 1
	bsr	AddAnchor
@


36.15
log
@Fixed MatchFirst on non-wildcard links.  It now does not Lock/ParentDir, and it
copies the name of the thing I locked over the fib_FileName of the fib.
Added flag for * as wildcard
added comments
@
text
@d74 2
d609 2
a610 1
12$:	moveq	#1,Wild
d616 1
a616 1
	tst	Wild
d621 1
a621 1
	subq.l	#1,D0
d640 1
a640 1
* AddAnchor(AnchorBase, BasePath, Wild)
d647 1
a647 1
	movem.l	A2/D2,-(sp)
d651 1
a651 1
	bsr	DosAllocMem
d654 1
a654 1
	 beq.s	97$
d661 1
a661 1
	 beq.s	4$
d681 2
a682 4
2$:	move.l	A2,A0			; Points to "" (current dir)
	bsr	LockThisForMePlease
	move.l	D0,an_Lock(A2)
	 beq.s	97$			; allocation error
d686 20
a705 1
	; no wildcard - just return node with currentdir and name
d709 9
a717 1
10$:	move.l	A2,ap_First(AnchorBase)
d719 2
d722 3
a724 2
99$:	move.l	A2,D0
	movem.l	(sp)+,D2/A2
d727 3
a729 2
97$:	bset.b	#APB_NOMEMERR,ap_Flags(AnchorBase)
	bra.s	99$
d901 4
a904 1
	lea	an_String(Node),a0
d1067 5
a1071 4
LTFM:	moveq.l	#ACCESS_READ,D2
	SYSJMP	Lock


@


36.14
log
@for rcs 4.x header change
@
text
@d54 1
a54 1
*	include "dos/dosextens.i"
d56 1
a56 1
	xdef	PatternMatch,FindFirst,FindNext,FreeAnchorChain
d58 1
a58 1
	xdef	_FindFirst
d73 1
d121 1
a121 1
*	   PreParse -- Creat a tokenized string for `PatternMatch'
d140 1
a140 1
*	   PatternMatch, FindFirst/FindNext
d164 1
a164 1
	bsr.s	IsWild
a166 2
**	btst.b	#ARPB_WILD_BCPL,Flags(A6)
**	 beq.s	0$
d168 10
d180 2
a181 2
	cmp	#0,D0
	 ble	ppRegular		; One of *~[] which are ignored here...
d184 1
a184 1
	add	D0,D0
d288 1
a288 1
*	   PatternMatch - perform a wildcard string match
d291 1
a291 1
*	   result = PatterMatch(pat,str)
d329 1
a329 1
PatternMatch:
d668 1
a668 1
	tst.l	(AnchorBase)
d677 2
a678 3
2$:	tst	Wild
	 beq.s	3$
	move.l	A2,A0			; Points to ""
d681 3
a683 1
	 bne.s	10$			; Failing modish
d685 2
a686 10
97$:	bset.b	#APB_NOMEMERR,ap_Flags(AnchorBase)
	bra.s	99$

3$:	lea.l	an_String(A2),A0
	bsr	LockThisForMePlease
	move.l	D0,-(sp)
	 beq.s	9$
	move.l	D0,D1
	SYSCALL	ParentDir
	move.l	D0,an_Lock(A2)
a687 2
9$:	move.l	(sp)+,D1
	SYSCALL	UnLock
d696 2
d699 1
d824 1
a824 1
	bsr	PatternMatch
d855 1
a855 1
	move	#ERROR_OBJECT_NOT_FOUND,D0
d862 3
d866 9
@


36.13
log
@Fixes to make patternmatch work with AllocVec instead of getvec
@
text
@@


36.12
log
@*** empty log message ***
@
text
@d26 3
a71 2
	DOS	FreeVecT,@@freevec
	DOS	AllocVecT,@@AllocVecType
d111 1
a111 1
	move.l	4,a6
d981 1
a981 1
	bsr	DosFreeMem
d1087 2
a1088 5
	move.l	D2,-(sp)
	move.l	D0,D1
	move.l	#MEMF_PUBLIC!MEMF_CLEAR,d2
	SYSCALL	AllocVecT		; * FIX!
	move.l	(sp)+,D2
a1090 40
**********************************************************************
*
*   NAME
*       DosFreeMem -- AmigaDOS compatible memory freer.
*
*   SYNOPSIS
*       DosFreeMem( memBlock )
*                       A1
*
*   FUNCTION
*       This function frees a memory block which was allocated using
*       DosAllocMem or was allocated by AmigaDOS.
*
*   INPUTS
*       memBlock -- the pointer to the memblock returned by DosAllocMem.
*                   This pointer may also be NULL, in which case no
*                   memory will be freed.
*
*   ADDITIONAL CONSIDERATIONS
*       memBlock is not a BPTR - if you are passing a value obtained
*       from AmigaDOS, make sure you convert it from a BPTR to a real
*       pointer first!
*
*   RESULT
*       None.
*
*   BUGS
*       None known.
*
*   SEE ALSO
*       DosAllocMem()
*
*       AUTHOR: SDB
*       REVISED:
**********************************************************************

DosFreeMem:
	move.l	A1,D1
	SYSJMP	FreeVecT		; * FIX!!!

d1093 5
d1099 1
a1099 1
	bsr.s	DosFreeMem
d1101 1
a1101 1
FreeDAList:
d1104 1
@


36.11
log
@Uncommented the pattern stuff
@
text
@d55 1
d542 1
@


36.10
log
@COmmented out code that deals with fields we no longer support
@
text
@d882 5
a886 11
* commented out by REJ
*	lea	ap_Info(AnchorBase),A0		; Copy over FIB...
*	lea	an_Info(Node),A1
*	moveq	#(fib_SIZEOF/4)-1,D0
*71$:	move.l	(A1)+,(A0)+
*	 dbra	D0,71$
*
*** Now use ap_StrLen instead of LONG ap_Length
*	move	ap_Strlen(AnchorBase),D2	; Max length
*	 beq.s	fn_valid				; Nothing to copy!!!
 bra.s fn_valid
d888 33
a920 29
*	move.l	ap_First(AnchorBase),Node
*	lea	ap_Buf(AnchorBase),BasePath
*	move.l	BasePath,A1			; BasePath is for compare
*
*** Do more stuff.
*72$:	bsr.s	fn_getstring			; Get this node's string
*
*73$:	subq	#1,D2
*	 ble.s	fn_overflow			; Out of room in buf...
*	move.b	(A0)+,(a1)+
*	 bne.s	73$
*
*	move.l	an_Child(Node),Node
*	move.l	Node,D0
*	 beq.s	fn_valid			; All clear tank yew
*
*	subq	#1,A1
*	cmpa.l	BasePath,A1
*	 beq.s	72$				; Do Noting  - still strstart
*
** See if a / is needed here.
*	cmp.b	#':',-1(A1)
*	 beq.s	72$
*	moveq	#'/',D0
*	cmp.b	-1(A1),D0
*	 beq.s	72$
*	move.b	D0,(A1)+		;No, put a slash on the end
*	subq	#1,D2			;and decrement our space in buffer
*	bra.s	72$
@


36.9
log
@Fix for return code from charlie
@
text
@d882 7
a888 6
	lea	ap_Info(AnchorBase),A0		; Copy over FIB...
	lea	an_Info(Node),A1
	moveq	#(fib_SIZEOF/4)-1,D0
71$:	move.l	(A1)+,(A0)+
	 dbra	D0,71$

d890 3
a892 2
	move	ap_Strlen(AnchorBase),D2	; Max length
	 beq.s	fn_valid				; Nothing to copy!!!
d894 4
a897 4
	move.l	ap_First(AnchorBase),Node
	lea	ap_Buf(AnchorBase),BasePath
	move.l	BasePath,A1			; BasePath is for compare

d899 24
a922 24
72$:	bsr.s	fn_getstring			; Get this node's string

73$:	subq	#1,D2
	 ble.s	fn_overflow			; Out of room in buf...
	move.b	(A0)+,(a1)+
	 bne.s	73$

	move.l	an_Child(Node),Node
	move.l	Node,D0
	 beq.s	fn_valid			; All clear tank yew

	subq	#1,A1
	cmpa.l	BasePath,A1
	 beq.s	72$				; Do Noting  - still strstart

* See if a / is needed here.
	cmp.b	#':',-1(A1)
	 beq.s	72$
	moveq	#'/',D0
	cmp.b	-1(A1),D0
	 beq.s	72$
	move.b	D0,(A1)+		;No, put a slash on the end
	subq	#1,D2			;and decrement our space in buffer
	bra.s	72$
@


36.8
log
@Turn off '*' for andy
@
text
@d943 4
a948 1
fn_valid:
@


36.7
log
@Charlie's latest pattern.asm, plus fixes for JSR xx(A6) vs BSR
@
text
@d166 6
a171 2
**	cmp	#3,D0
**	 ble.s	ppRegular		; One of *~[] which are ignored here...
@


36.6
log
@Fixed charlie's brain damaged macros
@
text
@d18 5
d39 3
a52 1

d65 1
d68 2
a69 2
	DOS	FreeVec,@@freevec
	DOS	AllocVec,@@AllocVecType
d85 1
a85 1
	ERROR! FIX!
d91 1
a91 1
	bsr	_\1
d97 1
a97 1
	ERROR! FIx!
d103 1
a103 1
	bra	_\1
d121 2
a122 2
*	   IsWild = PreParse(Source,Dest)
*	     d0                A0    A1
d148 2
a149 1
TYpe	equr	D3
d153 3
a155 2
	movem.l	WPending/TYpe/Ptr,-(sp)
	move.l	A0,Ptr
d186 2
a187 2
	bra.s	ppstore		; ~
	bra.s	10$		; [
d189 1
a189 1
	bra.s	20$		; #
d191 1
a191 1
	bra.s	30$		; (
d193 1
a193 1
	bra.s	40$		; )
d205 4
a208 2
10$:
11$:	move.b	Curchr,(Dest)+	; P_CLASS first time...
d217 2
a218 1
20$:	cmp.b	#'?',(Ptr)
d220 2
d225 1
a225 1
	bra.s	ppLoop
d231 2
a232 1
30$:	addq	#2,WPending	; P_ORSTART
d234 3
a236 1
40$:	subq	#2,WPending	; P_OREND
d238 6
d247 2
d250 1
a250 1
	 beq.s	1$
d254 1
a254 1
	 bne.s	2$
d256 3
d260 1
a260 1
2$:	bra	ppLoop
d262 6
a267 2
1$:	move.l	TYpe,D0
	movem.l	(sp)+,WPending/TYpe/Ptr
d314 5
d328 3
a330 1
PatternMatch:
d361 1
a361 1
	bsr	PatternMatch
d370 1
a370 1
	bsr	PatternMatch
d422 1
a422 1
	bsr	PatternMatch
d452 1
a452 1
	bsr	PatternMatch
d456 1
a456 1
	bsr	PatternMatch
d532 1
a532 1
*   D0  =		D0 ,    A0
d537 1
a537 1
	movem.l	D3/A2-A5,-(sp)
d540 3
a542 1
	move.l	A0,AnchorBase
a548 2
	move.l	D0,CurPath

d564 4
a567 2
2$:	move.l	LastPath,A1
*	SYSCALL	ParsePattern
d614 1
a614 1
	move.l  AnchorBase,A0
d616 1
a616 1
	movem.l	(SP)+,D3/A2-A5
d711 1
a711 1
	move.l	A0,AnchorBase
d811 3
a813 2
	move.l	sp,A1
*	SYSCALL	MatchPattern
a921 1
	bra.s	fn_error
d923 2
d926 5
a930 5
fn_valid:
	moveq	#0,D0
	moveq	#(1<<APB_ITSWILD)+(1<<APB_DOWILD),D1
	and.b	ap_Flags(AnchorBase),D1
	 bne.s	fn_rts
d934 1
a934 1
	move.l	AnchorBase,A0
d941 1
d943 4
d954 1
a954 1
* FreeAnchorChain( A0 )
d956 1
a956 1
*	Frees all stuff associated with A0.  It's an anchorchain,
d962 1
a962 1
	move.l	A0,A2
d1080 1
a1080 1
	SYSCALL	AllocVec
d1122 1
a1122 1
	SYSJMP	FreeVec
@


36.5
log
@*** empty log message ***
@
text
@d58 2
a59 1
	XREF	_CurrentDir
d77 1
d83 1
a83 1
	jsr	_\1
d89 1
d95 1
a95 1
	jmp	_\1
@


36.4
log
@Changes by charlie
Supposedly works now
@
text
@d34 1
a34 1
	include	"libraries/dosasl.i"
d43 1
a43 1
*	include "libraries/dosextens.i"
@


36.3
log
@Some changes by charlie, mainly making local symbols real ones.
@
text
@d616 1
a616 2
2$:
	tst	Wild
d621 1
a621 1
	 bne.s	3$			; Failing modish
d626 10
a635 1
3$:	move.l	A2,ap_First(AnchorBase)
d637 2
d692 3
a694 1
fn_loop	equ	*
d696 1
a696 1
	 beq.s	10$			; Skip null initial nodish
d698 1
a698 1
	 bne.s	10$
d702 1
a702 1
UpLevel	equ	*
d726 2
a727 1
10$:	btst.b	#DDB_PatternBit,an_Flags(Node)
d729 1
d734 1
a734 1
fn_done	equ	*
d748 1
a748 1
	
d774 1
a774 1
	 beq.s	fn_havematch		; Finished()
d937 2
@


36.2
log
@New release from charlie
@
text
@d24 1
d31 1
d81 1
a81 1
	bsr	_\1
d92 1
a92 1
	bra	_\1
d96 2
a97 1
CALLEXE MACRO
d100 1
d661 1
a661 1
	 bne	95$				; A memory error, prollably in FF
d664 1
a664 1
	 beq	9$				; Anchor has been freed. Scoot.
d667 1
a667 1
	 beq.s	0$
d673 1
a673 1
	 beq.s	0$
d677 1
a677 1
	bra	29$
d682 2
a683 1
0$:	move.l	an_Lock(Node),D1
a686 2
12$:
*	bsr	UpLevel
d698 1
a698 1
	 beq.s	9$				; Jump to safety, OK for below.
d706 1
a706 2
***	addq	#4,sp
	bra	70$
a712 3
*** 1$:	move.l	Node,D0
***	rts

d715 1
a715 1
	 bne.s	11$
d717 1
a717 1
	 beq	30$
d719 4
a722 1
***	subq	#4,sp
a723 5
* Out of entries returnaroo
***	addq	#4,sp
9$:	move	#ERROR_NO_MORE_ENTRIES,D0
	bra	95$

d727 2
a728 1
11$:	move.l	an_Lock(Node),D1
d733 1
a733 1
	 beq.s	12$
d735 2
d738 4
a741 3
	lea	96$(pc),A1
	bsr	CheckBreak

d757 1
a757 1
	 beq.s	11$			; No match, loop some more...
d760 1
a760 1
	 beq.s	70$			; Finished()
d762 1
a762 1
	 ble.s	11$
d764 3
a766 1
29$:	bset.b	#DDB_ExaminedBit,an_Flags(Node)
d768 4
a771 1
30$:	bsr.s	60$			; Get this node's string
d778 1
a778 1
	 bne.s	32$
d787 2
a788 2
	 beq	95$
	bra	12$			; Hope this works ...
d790 5
a794 2
32$:	move.l	an_Child(Node),D0
	 beq.s	35$
d799 1
a799 1
	bra	0$
d802 2
a803 1
60$:	lea	an_String(Node),A0
d809 2
a810 1
35$:	bset.b	#DDB_Completed,an_Flags(Node)
d815 2
a816 1
70$:	move.l	ap_Current(AnchorBase),Node
d826 1
a826 1
	 beq.s	98$				; Nothing to copy!!!
d833 1
a833 1
72$:	bsr.s	60$				; Get this node's string
d836 1
a836 1
	 ble.s	97$				; Out of room in buf...
d842 1
a842 1
	 beq.s	98$				; All clear tank yew
d859 1
a859 1
96$:	addq	#4,sp
d862 1
a862 1
	bra.s	95$
d864 3
a866 1
98$:	moveq	#0,D0
d869 1
a869 1
	 bne.s	99$
d871 2
a872 1
95$:	move.l	D0,D2
d876 1
a876 1
	bra.s	99$
d878 3
a880 2
97$:	move	#ERROR_BUFFER_OVERFLOW,D0
99$:	ext.l	D0
a1065 66

********************************************************************
*
*   NAME
*       CheckBreak -- Check for control C/D/E/F
*
*   SYNOPSIS
*       BOOL = CheckAbort( Mask(s), *Func() )
*        d0                  D1        A1
*
*   FUNCTION
*       This function will check to see if the user issued a
*       CNTRL-C/E/D/F abort (from keyboard or Break program), and will
*       take one of three possible actions.
*
*       If the BREAK occurred:
*
*           If *Func() is null, then the Actual Mask will be returned.
*
*           If *Func() is NOT null, it will be called, and you will
*           see the return code from that function.
*
*           If a BREAK did not occur, you will get a ZERO (false)
*           return, and	*Func() will not be called, even if non-null.
*
*   INPUTS
*       Mask(s) -- One (or more) of SIGBREAKF_CTRL_C/D/E/F masks.
*       *Func() -- an (optional) function to call if the BREAK occured.
*
*   RESULT
*       Zero if no Break
*
*       If *Func() is null, you will get the masks that caused
*       this break.
*
*       If *Func() is not null, you will see your return value.
*
*   ADDITIONAL:
*       For this function, we guarantee all registers preserved,
*       except for D0, which will hold the masks.
*
*       For CheckAbort, all registers will be preserved, except
*       for D0/D1.
*
*   BUGS
*       None known.
*
*   Author: SDB
*   Revised: cdh V25 return ***BREAK string in A1, return is same level
*			as call (return address overwritten)
*	     cdh V26 (poof) A1 function is called with (sp) = calling
*		function.  Careful!
*		
***********************************************************************

CheckBreak:
	movem.l	d1/a0-a1/a6,-(sp)		; we guarantee registers on this one.
	moveq.l	#0,d0
	CALLEXE	SetSignal			; get the signals
	movem.l	(sp)+,d1/a0-a1/a6
	and.l	d1,d0
	beq.s	1$
	cmpa.l	#0,a1
	beq.s	1$
	move.l	A1,-(sp)
1$:	rts
@


36.1
log
@*** empty log message ***
@
text
@d21 2
a22 1
	include "exec/types.i"
a23 5
	include "exec/execbase.i"
	include "exec/initializers.i"

	include	"libraries/dosasl.i"

a29 1

d32 2
d45 1
a45 1
	xdef	PreParse,CheckBreak
d49 1
a49 1
\1	EQU	\2
d56 1
a56 1
	DOS	CurrentDir,_CurrentDir
d58 1
a58 1
	DOS	AllocVec,@@AllocVec
d61 20
a80 2
CALLDOS	macro
	bsr	\1
d82 10
a91 2
JMPDOS	macro
	bra	\1
d94 3
a96 8
*****************************************************************************
* cdh 7/5/89
* This is a temporary macro which is used to vector library calls to
* temporary stub routines, for use until full integration of these functions
* into dos.library
*****************************************************************************
DOSYSCALL	macro
	bsr	\1
d518 2
a519 1
	DOSYSCALL	PreParse
d583 1
a583 1
	DOSYSCALL	DosAllocMem
d596 1
a596 1
	DOSYSCALL	Toupper
d637 1
a637 1
	CALLDOS	Examine
d689 1
a689 1
	CALLDOS	UnLock
d699 1
a699 1
	DOSYSCALL	FreeDAList
d733 1
a733 1
	CALLDOS	ExNext
d739 1
a739 1
	DOSYSCALL	CheckBreak
d746 1
a746 1
	DOSYSCALL	Toupper
d752 2
a753 1
	DOSYSCALL	PatternMatch
d774 1
a774 1
	CALLDOS	UnLock
d776 1
a776 1
40$:	CALLDOS	IoErr
d801 1
a801 1
	CALLDOS	UnLock
d886 1
a886 1
	CALLDOS	UnLock
d889 1
a889 1
	DOSYSCALL	DosFreeMem
d911 1
a911 1
	CALLDOS	CurrentDir
d917 1
a917 1
	CALLDOS	CurrentDir
d924 1
a924 1
	JMPDOS	Lock
d993 6
a998 2
	move.l	d0,d1
	JMPDOS	AllocVec
d1038 1
a1038 1
	JMPDOS	FreeVec
d1043 1
a1043 1
	DOSYSCALL	DosFreeMem
d1115 1
a1115 7
1$:	lea	Broke(pc),A1
	rts

Broke:	dc.b	'***BREAK',0		; Here for alignment
	ds.w	0

	END
@
