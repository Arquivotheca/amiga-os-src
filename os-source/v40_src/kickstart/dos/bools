*	BOOL AllocUnit(LONG);
*	BOOL CheckIO(struct IORequest *);
*	BOOL AddBootNode( BYTE,ULONG,struct DeviceNode *,struct ConfigDev * );
*	BOOL AddDosNode( BYTE,ULONG,struct DeviceNode *);
*	BOOL status;
*	BOOL db;
BOOL _GetGBuffers(anOb, RPort, dbuf)
BOOL dbuf;
BOOL queueSprite(s, sprcl, clrcl, RPort, VPort  )
    BOOL found, first, second;
    BOOL onscreen;
BOOL checkColl(a, b )
BOOL checkColl(a, b )
BOOL setRects(high, wide, src, dest, dispx, dispy, RHeight, RWidth )
    BOOL bflag;
*	BOOL db;
BOOL dbuf;
BOOL user;
*	BOOLEAN gotit;
*	BOOLEAN error;
*	BOOL status
*	BOOL status;
*	BOOL status;
*	BOOL error;
*	BOOL status;
*	BOOL status;
*	  BOOL IsWild - whether there were any wildcards in the string
* The following commands are BOOLEAN - NULL == failure
    BOOL		refresh = 0;
BOOL ReadLeft();
BOOL ReadRight();
*	BOOL DisplayAlert( ULONG, UBYTE *, WORD );
*	BOOL value is returned by this routine to specify whether or not 
*	A BOOL value of TRUE or FALSE.  If this is a DEADEND_ALERT, FALSE
BOOL DisplayAlert(alertnum, string, height)
    /* BOOL   a2024_mode = 0; */
*	[BOOL] ModifyIDCMP( struct Window *, ULONG );
*	\* returns BOOL in V37 and greater *\
*	BOOL AutoRequest( struct Window *, struct IntuiText *,
*	pointers) instead, and these BOOL values will be returned to 
BOOL
*	LONG SysReqHandler( struct Window *, ULONG *, BOOL );
*          - GTYP_BOOLGADGET
BOOL		layout_body;
    BOOL		use_pubscreen = FALSE;
    BOOL li_locked = FALSE;
    case BOOLGADGET:
	hook = &IBase->IIHooks[ IHOOK_BOOLG ];
BOOL	/* returns FALSE if requester offscreen, or couldn't be found */
    BOOL   retval = TRUE;
*	VOID FreeRemember( struct Remember **, BOOL );
*	ReallyForget = a BOOL FALSE or TRUE describing, respectively, 
BOOL reallyforget;
*	VOID ReportMouse( BOOL, struct Window * );
BOOL bool;
*	BOOL DoubleClick( ULONG, ULONG, ULONG, ULONG );
BOOL
    BOOL			doit = FALSE;
    BOOL			doit = FALSE;
    BOOL			doit = FALSE;
    BOOL			doit = TRUE;
    BOOL		add_a_button;
BOOL disabled;
BOOL		sub;
BOOL subsearch;
BOOL subsearch;
    BOOL retval = TRUE;
	retval = (BOOL)
*	BOOL ResetMenuStrip( struct Window *, struct Menu * );
BOOL
*	BOOL SetMenuStrip( struct Window *, struct Menu * );
BOOL
BOOL IOnOffMenu(window, menuNum, onOrOff)
BOOL onOrOff;
BOOL OnMenu(window, menuNum)
BOOL OffMenu(window, menuNum)
    BOOL  thereyet = FALSE;
*	BOOL FreeClass( struct IClass * );
BOOL change;
BOOL knownScreen(s)
BOOL knownWindow(w)
    BOOL  do_my_refresh;	/* is there something to do?	*/
    BOOL  send_him_refresh;	/* does he get a refresh event?	*/
    BOOL  i_end_refresh;  	/* do I dispose damage list?	*/
*	VOID EndRefresh( struct Window *, BOOL );
BOOL complete;
BOOL draw;
    BOOL CrudeRedraw;
BOOL
BOOL
    ENABLECLI,		/* BOOL EnableCLI; */
*	struct Preferences *SetPrefs( struct Preferences *, LONG, BOOL );
BOOL RealThing;
BOOL vanilla;
BOOL
BOOL inrect(x, y, j)
BOOL collide(x, y, boxx, boxy, xsize, ysize)
*	[BOOL] CloseScreen( struct Screen * );
*	\* returns BOOL in V36 and greater *\
BOOL CloseWorkBench() 
BOOL WindowLimits();
BOOL gimme;
    BOOL gimme;
 * If this only works for stripes, make it an option, like BOOL snoop_gads
BOOL clearout;
BOOL gadgets_too;	/* if true, worry about gadgets in top border */
    BOOL overdrawn = FALSE;	/* text runs into depth gadgets */
*	BOOL WindowLimits( struct Window *, WORD, WORD, UWORD, UWORD );
BOOL WindowLimits(window, minwidth, minheight, maxwidth, maxheight)
    BOOL goodsizes;
BOOL
    BOOL reqnotdrawn = TRUE;
BOOL newDMRequest(w, req)
*	BOOL ClearDMRequest( struct Window * );
BOOL
*	BOOL SetDMRequest( struct Window *, struct Requester * );
*	BOOL Request( struct Requester *, struct Window * );
BOOL
BOOL
    BOOL 	reqdrawn = FALSE;
BOOL
    BOOL		do_patrol = FALSE;
    BOOL	is_pnd = FALSE;
BOOL	/* returns false if knob doesn't move */
BOOL	fallback;
BOOL IsDraggable( s )
BOOL IsCompatible( s )
BOOL IsHires(s)
    BOOL	valid_cop_lists;
BOOL
    BOOL	retval;
*	BOOL ActivateGadget( struct Gadget *, struct Window *,
BOOL
BOOL
    BOOL	success = FALSE;
BOOL LONGTest();
BOOL LONGInRange();
BOOL			*redisplay;
BOOL		*redisplay;
    BOOL		handle_char = FALSE;	/* treat as normal char */
BOOL		del_to_end;
BOOL			*redisplay;
BOOL			*redisplay;
BOOL LONGTest(buffer, longvar)
    BOOL inrange;
*	BOOL WBenchToFront( VOID );
BOOL WBenchToFront() 
*	BOOL WBenchToBack( VOID );
BOOL WBenchToBack() 
*	BOOL OpenWorkBench( VOID );
*	value as a BOOL indication that the routine has succeeded, if
*	BOOL GetScreenData( APTR, UWORD, UWORD, struct Screen * );
BOOL GetScreenData(buffer, size, type, screen )
    BOOL	locked_pubscreen = TRUE;
BOOL CloseWorkBench() 
BOOL			do_layout;	/* if FALSE, just measure extent*/
    BOOL  ip_MagicMenu;			/* DoMagicMenu (pop screen to 0, 0) */
BOOL	backsync;	/* Should we backsync?	*/
    BOOL		topcheck = FALSE;	/* special for scroll down */
    BOOL		refresh = 0; /* I don't really need it */
BOOL			interactive;	/* TRUE if user-initiated.  Then we
BOOL	countnulllayers;
    BOOL		success = FALSE;
    BOOL		sizechanged;
    BOOL		poschanged;
    BOOL	retval = TRUE;	/* signifies that couldn't do LayerOp	*/
*	BOOL PointInImage( struct Point, struct Image * );
*	it belongs (superceding things like BOOLMASK).  After all,
    BOOL		need_override = FALSE;
BOOL gimme;
    BOOL setVectorIAttrs();
BOOL setVectorIAttrs( cl,  o,  msg )
    BOOL RefreshImageData();
    BOOL	success = TRUE;
BOOL
BOOL
BOOL
BOOL
    BOOL retval = FALSE;
BOOL		needbm;
BOOL RefreshImageData( cl, o, msg )
    BOOL success = TRUE;
    BOOL mono = TRUE;		/* doing a monochrome screen? */
    BOOL moved = FALSE;
*	VOID ShowTitle( struct Screen *, BOOL );
BOOL showit;
BOOL showit;
    if ( TESTFLAG( g->Activation, BOOLEXTEND)
	&& TESTFLAG( bi->Flags, BOOLMASK ) )
	if ((g->Activation & BOOLEXTEND) && (bi->Flags & BOOLMASK))
    BOOL	redisplay;
    BOOL		redisplay;
    BOOL	redisplay;
BOOL
*	BOOL		Apply;
*	BOOL		IncludeMiss;
*	BOOL	TagInArray( Tag, TagArray )
BOOL __asm
BOOL myassignlock(name, lock)
void RenderAll(struct InfoTag *itag, BOOL firsttime);
void InfoRenderIcon(struct InfoTag *itag, BOOL inrefresh);
    BOOL firsttime;
    InfoRenderIcon(itag, (BOOL) !firsttime);
    BOOL inrefresh;
    BOOL ok;
BOOL SyncInfo(struct WBObject *wbobj, struct MsgPort *intuiport);
BOOL SyncInfo(wbobj, intuiport)
    BOOL terminated;
* FindDupObj now returns an 'int' instead of a 'BOOL'.
BOOL AddChildCommon(BPTR lock,char *name,struct WBObject *parent,struct WBObject *child,struct FileInfoBlock *fib)
	BOOL		result=TRUE;	/* Assume it works... */
BOOL AddChild(BPTR lock,char *name,struct WBObject *parent,struct FileInfoBlock *fib)
	BOOL		result=TRUE;
BOOL AddAllChildren(BPTR lock,struct FileInfoBlock *fib,struct WBObject *parent,BOOL *alldone)
BOOL	result=FALSE;
BOOL rescan;
BOOL writeobj=FALSE;
BOOL showall;
    BOOL keep_going = TRUE;
BOOL HandleSave(struct Window *infowindow);
BOOL HandleGadgetUp(struct Window *infowindow, struct Gadget *gad,
BOOL HandleInfoEvent(struct Window *infowindow, struct IntuiMessage *imsg);
    BOOL activatestring;
    BOOL refreshlist;
 * Returns:  (BOOL) TRUE if the Info window should close (currently
BOOL HandleSave(infowindow)
 * Returns:  (BOOL) TRUE if Info window should close.
BOOL HandleGadgetUp(infowindow, gad, code)
    BOOL terminate = FALSE;
BOOL HandleInfoEvent(infowindow, imsg)
    BOOL terminate = FALSE;
	dobj->do_Gadget.GadgetType = BOOLGADGET;
*	BOOL RemoveAppIcon(struct AppIcon *);
BOOL
*	BOOL RemoveAppMenuItem(struct AppMenuItem *);
BOOL
*	BOOL RemoveAppWindow(struct AppWindow *);
BOOL
    BOOL doitagain = FALSE, keep_going;
struct Hook *PrepareBackFill(BOOL diskwin)
BOOL Flash;
BOOL BuildToolTypes(struct InfoTag *itag, struct WBObject *wbobj);
BOOL InfoSave(struct InfoTag *itag);
 * Returns: (BOOL) TRUE if successful.
BOOL BuildToolTypes(itag, wbobj)
    BOOL done;
 * Returns: (BOOL) TRUE if successful.
BOOL InfoSave(itag)
void RenderExecute(struct ExecuteTag *etag, BOOL firsttime);
    BOOL firsttime;
BOOL
    BOOL result = FALSE;
BOOL ReadPattern(char *name,UWORD *ptr)
	BOOL		result = FALSE;
BOOL FontsDifferent(fp, oldta)
    BOOL result = TRUE; /* assume fonts are different */
    BOOL newicon = FALSE; /* assume we are not creating a new icon */
BOOL DiskIcon = FALSE; /* assume not trying to update a disk icon */
 * int PutAway(struct WBObject *,BOOL)	- PutAway this object
BOOL BuildBackdropPath(struct WBObject *obj,char *buf)
BOOL	result=FALSE;
BOOL cleanupoverride; /* no longer used */
BOOL SameVolume(struct WBObject *obj1, struct WBObject *obj2)
    BOOL condition;
	gad = ConditionalCreateNum(gad, &ng, (BOOL)(itag->it_Flags & IT_GOT_INFODATA),
	gad = ConditionalCreateNum(gad, &ng, (BOOL)(itag->it_Flags & IT_GOT_INFODATA),
	gad = ConditionalCreateNum(gad, &ng, (BOOL)(itag->it_Flags & IT_GOT_INFODATA),
	gad = ConditionalCreateNum(gad, &ng, (BOOL)(itag->it_Flags & IT_GOT_INFODATA),
	gad = ConditionalCreateNum(gad, &ng, (BOOL)(itag->it_Flags & IT_GOT_FIB),
	gad = ConditionalCreateNum(gad, &ng, (BOOL)(itag->it_Flags & IT_GOT_FIB),
	    GTCB_Checked, (BOOL) (itag->it_Protection & FIBF_SCRIPT),
	    GTCB_Checked, (BOOL) (itag->it_Protection & FIBF_ARCHIVE),
	    GTCB_Checked, (BOOL) (!(itag->it_Protection & FIBF_READ)),
	    GTCB_Checked, (BOOL) (!(itag->it_Protection & FIBF_WRITE)),
	    GTCB_Checked, (BOOL) (!(itag->it_Protection & FIBF_EXECUTE)),
	    GTCB_Checked, (BOOL) (!(itag->it_Protection & FIBF_DELETE)),
BOOL CheckSortRect(struct Rectangle *);
BOOL diskwin;
    BOOLGADGET,						/* type */
    BOOLGADGET,						/* type */
    BOOLGADGET,						/* type */
    BOOLGADGET,						/* type */
					 (BOOL)(drawerobj==wb->wb_RootObject),
void AbleMenu(struct Window *win,UWORD menunumber,BOOL able)
BOOL flag;
	AbleMenu(win, MENU_LASTERROR, (BOOL)wb->wb_CurrentError);
	AbleMenu(win, MENU_ICONS, (BOOL)!Empty(&wb->wb_SelectList));
BOOL RescanAllFlag;
     BOOL freeCLI;
     BOOL pipe_expand;
BOOL status;
   BOOL dirfound=FALSE;
BOOL pipe_expand;
   BOOL past_begin=pipe_expand; /* flag to indicate whether the line */
BOOL status;
   BOOL loop=0;
*	BOOL SetConSnip( char * );
; IsFileSystem - simply returns a BOOLEAN TRUE since we are a filing system
;	    BOOL = MatchFunc( DataVal, BufferData, MatchString )
; IsFileSystem - simply returns a BOOLEAN TRUE since we are a filing system
; Sets the bit corresponding to keynum in the visitmap.  Returns a BOOLEAN to
; Sets the bit corresponding to keynum in the visitmap.  Returns a BOOLEAN to
BOOL ReadFloppy(ULONG unit,ULONG offset,ULONG count,APTR address);
BOOL DiskInDrive(ULONG unit);
BOOL ReadFloppy(ULONG unit,ULONG offset,ULONG count,APTR address)
   BOOL           retval    = FALSE;
BOOL DiskInDrive(ULONG unit)
   BOOL           retval    = FALSE;
BOOL   isfloppy(BSTR);
BOOL   isUnix(struct DosEnvec *ev);
BOOL   MatchPart(BSTR bp,char *s);
BOOL   isRAD(struct FileSysStartupMsg *fssm);
BOOL   MatchBSTR(BSTR bp,char *s);
BOOL isfloppy(bp)
BOOL isUnix(struct DosEnvec *ev)
BOOL MatchPart(BSTR bp,char *s)
BOOL isRAD(struct FileSysStartupMsg *fssm)
BOOL MatchBSTR(BSTR bp,char *s)
BOOL   isfloppy(BSTR);
BOOL   MatchPart(BSTR bp,char *s);
BOOL   isRAD(struct FileSysStartupMsg *fssm);
BOOL   MatchBSTR(BSTR bp,char *s);
BOOL isfloppy(bp)
BOOL MatchPart(BSTR bp,char *s)
BOOL isRAD(struct FileSysStartupMsg *fssm)
BOOL MatchBSTR(BSTR bp,char *s)
BOOL WriteFloppy(ULONG unit,ULONG offset,ULONG count,APTR address);
BOOL DiskInDrive(ULONG unit);
BOOL WriteFloppy(ULONG unit,ULONG offset,ULONG count,APTR address)
   BOOL           retval    = FALSE;
   BOOL err=TRUE;
BOOL DiskInDrive(ULONG unit)
   BOOL           retval    = FALSE;
BOOL WriteFloppy(ULONG unit,ULONG offset,ULONG count,APTR address);
BOOL DiskInDrive(ULONG unit);
BOOL WriteFloppy(ULONG unit,ULONG offset,ULONG count,APTR address)
   BOOL           retval    = FALSE;
BOOL DiskInDrive(ULONG unit)
   BOOL           retval    = FALSE;
   BOOL   Success;
BOOL   DisplayOn(struct World *);
BOOL   isfloppy(BSTR);
BOOL   ReadFile(struct World *world,char *name,ULONG offset,ULONG count,char *address);
BOOL DisplayOn(world)
BOOL isfloppy(bp)
BOOL ReadFile(struct World *world,char *name,ULONG offset,ULONG count,char *address)
   BOOL        retval=FALSE;
   BOOL   Success;
   BOOL  Highlited;
   BOOL  Enabled;
   BOOL  NoEnable;
   BOOL  Bootable;
   BOOL                 Cancel;
   BOOL                 Exists13;
   BOOL                 Exists14;
   BOOL                 TDOpen;
BOOL   Activated(void);
BOOL   DisplayOn(struct World *);
BOOL   OpenIH(struct World *);
BOOL   DrawEntry(struct World *world,SHORT x);
BOOL   ReadFloppy(struct World *world,ULONG offset,ULONG count,APTR address);
BOOL   DiskInDrive(struct World *world);
BOOL   MagicFloppy(struct World *world);
BOOL   SuperDisk(struct World *world);
BOOL   MatchPart(BSTR bp,char *s);
BOOL   isfloppy(BSTR bp);
BOOL   PartExists(struct World *world,char *s);
BOOL   MatchBSTR(BSTR bp,char *s);
BOOL Activated()
BOOL DisplayOn(world)
BOOL OpenIH(world)
BOOL ReadFloppy(struct World *world,ULONG offset,ULONG count,APTR address)
   BOOL           retval    = FALSE;
BOOL DiskInDrive(struct World *world)
   BOOL           retval    = FALSE;
BOOL MagicFloppy(struct World *world)
   BOOL           retval    = FALSE;
BOOL MagicFloppy(struct World *world)
   BOOL           retval    = FALSE;
BOOL SuperDisk(struct World *world)
   BOOL           retval    = FALSE;
BOOL MatchPart(BSTR bp,char *s)
   /* BOOL                     NoPart=TRUE; */
BOOL isfloppy(BSTR bp)
BOOL PartExists(struct World *world,char *s)
BOOL MatchBSTR(BSTR bp,char *s)
ULONG TallyMenuMemory (struct NewMenu *nm, BOOL fullmenu );
*	GTMN_FullMenu (BOOL) - (GadTools V37 and higher only)
    BOOL fullmenu;
*	BOOL LayoutMenusA(struct Menu *, APTR, struct TagItem *);
*	BOOL LayoutMenus(struct Menu *, APTR, Tag, ...);
    as a BOOL.  This way we guarantee that the high-word of d0 is clear. */
*	BOOL LayoutMenuItemsA(struct MenuItem *, APTR, struct TagItem *);
*	BOOL LayoutMenuItemsA(struct MenuItem *, APTR, Tag, ...);
    as a BOOL.  This way we guarantee that the high-word of d0 is clear. */
    BOOL havechecked = FALSE;
BOOL __asm __saveds __stdargs
    gad->GadgetType |= BOOLGADGET;
	AbleGadget(gad, win, req, 1, (BOOL)ti->ti_Data);
BOOL HandleGadgetEvent(struct Window *, struct Gadget *, UWORD);
BOOL terminated = FALSE;
BOOL HandleGadgetEvent(win, gad, code)
    BOOL terminated = FALSE;
BOOL check1 = TRUE;
BOOL check2 = FALSE;
BOOL HandleEvent(struct Window *);
    BOOL ok;
BOOL HandleEvent(win)
    BOOL terminated = FALSE;
BOOL HandleMenuEvent(UWORD);
BOOL OpenFunc(UWORD);
BOOL SaveFunc(UWORD);
BOOL PrintFunc(UWORD);
BOOL QuitFunc(UWORD);
BOOL terminated;
BOOL HandleMenuEvent(code)
    BOOL terminated = FALSE;
    BOOL (*fptr)(UWORD);
BOOL OpenFunc(code)
BOOL SaveFunc(code)
BOOL PrintFunc(code)
BOOL QuitFunc(code)
BOOL HandleMenuEvent(UWORD code);
BOOL OpenFunc(UWORD code);
BOOL SaveFunc(UWORD code);
BOOL SaveAsFunc(UWORD code);
BOOL PrintFunc(UWORD code);
BOOL QuitFunc(UWORD code);
BOOL HandleMouseMove(struct Gadget *gad, UWORD code);
BOOL HandleGadgetEvent(struct Gadget *gad, UWORD code);
BOOL terminated;
BOOL foochecked = TRUE;
BOOL connected = FALSE;
BOOL HandleMenuEvent(code)
    BOOL terminated = FALSE;
	    BOOL (*fptr)(UWORD) = MENU_USERDATA(item);
BOOL OpenFunc(code)
BOOL SaveFunc(code)
BOOL SaveAsFunc(code)
BOOL PrintFunc(code)
BOOL QuitFunc(code)
BOOL HandleMouseMove(gad, code)
    BOOL terminated = FALSE;
BOOL HandleGadgetEvent(gad, code)
    BOOL terminated = FALSE;
void RefreshSlider (struct Window *win, struct Gadget *gad, BOOL refresh);
BOOL HandleSlider (struct Gadget *gad, struct IntuiMessage *imsg);
    UWORD *body, UWORD *pot, BOOL invert);
UWORD FindSliderLevel (UWORD numlevels, UWORD pot, BOOL invert);
*	GA_IMMEDIATE (BOOL) - Hear every GADGETDOWN event (default FALSE).
*	GA_RELVERIFY (BOOL) - Hear every GADGETUP even (default FALSE).
    BOOL displaylevel;
	    sl->sl_Body, sl->sl_Pot, (BOOL)(sl->sl_Flags & SL_VERTICAL));
    BOOL refresh;
BOOL HandleSlider(gad, imsg)
    BOOL hearupdown = FALSE;
	*sl->sl_Pot, (BOOL)(sl->sl_Flags & SL_VERTICAL)) + sl->sl_Min;
	    sl->sl_Body, sl->sl_Pot, (BOOL)(sl->sl_Flags & SL_VERTICAL));
	sl->sl_Body, sl->sl_Pot, (BOOL)(sl->sl_Flags & SL_VERTICAL));
	AbleGadget(gad, win, req, 1, (BOOL)ti->ti_Data);
    BOOL invert;
    BOOL invert;
    WORD left, WORD top, WORD width, WORD height, BOOL shadow,
*	    WORD, WORD, BOOL);
    WORD left, WORD top, WORD width, WORD height, BOOL shadow,
*	GTBB_Recessed (BOOL):  Set to anything for a recessed-looking box.
	   (BOOL) !findTagItem(GTBB_Recessed, taglist), vi),
    BOOL selected;
void RefreshPalette (struct Window *win, struct Gadget *pal, BOOL refresh);
BOOL HandlePalette (struct Gadget *gad, struct IntuiMessage *imsg);
    BOOL FullRefresh);
	gad->GadgetType |= BOOLGADGET;
	RefreshIndicator(win, gad, (BOOL)FALSE);
	AbleGadget(paid->paid_FirstGadget, win, req, paid->paid_Count, (BOOL)ti->ti_Data);
    BOOL FullRefresh;
    BOOL refresh;
    RefreshIndicator(win, pal, (BOOL) TRUE);
BOOL HandlePalette(gad, imsg)
	RefreshIndicator(imsg->IDCMPWindow, pal, (BOOL)FALSE);
*	STRINGA_ReplaceMode (BOOL) - Set to TRUE for a string gadget
	AbleGadget(gad, win, req, 1, (BOOL)ti->ti_Data);
*	STRINGA_ReplaceMode (BOOL) - Set to TRUE for an integer gadget
	AbleGadget(gad, win, req, 1, (BOOL)ti->ti_Data);
BOOL __asm __saveds
		  register __d0 BOOL complete);
void WalkRefreshGadgets (struct Window *win, BOOL refresh);
*	VOID GT_EndRefresh(struct Window *, BOOL complete);
		  register __d0 BOOL complete)
    BOOL msgforclient = FALSE;
    BOOL refresh;
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	GTCB_Checked (BOOL) - Initial state of checkbox, defaults to FALSE.
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	GA_Disabled (BOOL) - (GadTools V37 and higher only)
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
void RefreshSketch (struct Window *win, struct Gadget *sk, BOOL refresh);
BOOL HandleSketch (struct Gadget *gad, struct IntuiMessage *imsg);
    gad->GadgetType |= BOOLGADGET;
    BOOL movespot = FALSE;
    BOOL refresh;
    BOOL refresh;
BOOL HandleSketch(gad, imsg)
void RefreshText (struct Window *win, struct Gadget *gad, BOOL refresh);
*	GTTX_CopyText (BOOL) -	This flag instructs this gadget to copy the
*	GTTX_Border (BOOL) - If TRUE, this flag asks for a recessed
    BOOL copytext = getTagData(GTTX_CopyText, FALSE, taglist);
    BOOL border = getTagData(GTTX_Border, FALSE, taglist);
    BOOL refresh;
*	GTNM_Border (BOOL) - If TRUE, this flag asks for a recessed
    BOOL border = getTagData(GTNM_Border, FALSE, taglist);
BOOL HandleNWay (struct Gadget *gad, struct IntuiMessage *imsg);
    gad->GadgetType |= BOOLGADGET;
BOOL HandleNWay(gad, imsg)
	AbleGadget(gad, win, req, 1, (BOOL)ti->ti_Data);
    struct Requester *req, UWORD count, BOOL disable);
    BOOL disable;
void RefreshScroller (struct Window *win, struct Gadget *gad, BOOL refresh);
BOOL HandleScroller (struct Gadget *gad, struct IntuiMessage *imsg);
*	GA_IMMEDIATE (BOOL) - Hear every GADGETDOWN event (defaults to FALSE).
*	GA_RELVERIFY (BOOL) - Hear every GADGETUP event (defaults to FALSE).
    BOOL refresh;
BOOL HandleScroller(gad, imsg)
    BOOL hearupdown = FALSE;
	AbleGadget(scid->sc_Prop, win, req, 1, (BOOL)ti->ti_Data);
BOOL HandleMX (struct Gadget *gad, struct IntuiMessage *imsg);
BOOL NewActiveMX (struct Window *win, struct SpecialGadget *sg);
	gad->GadgetType |= BOOLGADGET;
BOOL HandleMX(gad, imsg)
BOOL NewActiveMX(win, sg)
*	GTCB_Checked (BOOL) - Initial state of checkbox, defaults to FALSE.
*	GTCB_Checked (BOOL) - State of checkbox.
    gad->GadgetType |= BOOLGADGET;
*	GTCB_Checked (BOOL) - The desired new state of the checkbox.
	AbleGadget(gad, win, req, 1, (BOOL)ti->ti_Data);
void RefreshListView (struct Window *win, struct Gadget *lv, BOOL refresh);
void UpdateListView (struct Window *win, struct Gadget *lv, BOOL refresh);
BOOL HandleListView (struct Gadget *gad, struct IntuiMessage *imsg);
    struct Requester *req, BOOL nosetscroller, struct TagItem *taglist);
*	GTLV_ReadOnly (BOOL) - If TRUE, then listview is read-only.
	    gad->GadgetType |= BOOLGADGET;
    BOOL nosetscroller;
    BOOL updateselected = FALSE;
    BOOL refresh;
    BOOL refresh;
BOOL HandleListView(gad, imsg)
    struct Requester *req, BOOL nosetscroller, ULONG firsttag, ...)
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	GTCB_Checked (BOOL) - Initial state of checkbox, defaults to FALSE.
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	GA_Disabled (BOOL) - (GadTools V37 and higher only)
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	STRINGA_ExitHelp (BOOL) - (New for V37) Set to TRUE to have the
*	GA_TabCycle (BOOL) - (New for V37) Set to TRUE so that pressing
*	GTLV_ReadOnly (BOOL) - If TRUE, then listview is read-only.
*	GTNM_Border (BOOL) - If TRUE, this flag asks for a recessed
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	GA_Immediate (BOOL) - Hear every IDCMP_GADGETDOWN event from scroller
*	GA_RelVerify (BOOL) - Hear every IDCMP_GADGETUP event from scroller
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	GA_Immediate (BOOL) - If you want to hear each slider IDCMP_GADGETDOWN
*	GA_RelVerify (BOOL) - If you want to hear each slider IDCMP_GADGETUP
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	STRINGA_ExitHelp (BOOL) - (New for V37) Set to TRUE to have the
*	GA_TabCycle (BOOL) - (New for V37) Set to TRUE so that pressing
*	GTTX_CopyText (BOOL) -	This flag instructs the text-display gadget
*	GTTX_Border (BOOL) - If TRUE, this flag asks for a recessed
   BOOL iflag = 0;
   BOOL ignoring = FALSE;
   BOOL kb_return=FALSE;
   BOOL space = FALSE;
  	                         BOOL flag = FALSE;
                                 BOOL flag = FALSE;
    BOOL flag=0;
   BOOL   Success;
   BOOL  Highlited;
   BOOL  Enabled;
   BOOL  NoEnable;
   BOOL  Bootable;
   BOOL                 Cancel;
BOOL   Activated(void);
BOOL   DisplayOn(struct World *);
BOOL   OpenIH(struct World *);
BOOL   DrawEntry(struct World *world,SHORT x);
VOID   DrawNWay(struct World *world,SHORT x,SHORT y,BOOL enabled,BOOL sunken);
BOOL Activated()
   DrawNWay(world,DAGX,DAGY,(BOOL)(! world->SS_Disable),FALSE);
BOOL DisplayOn(world)
BOOL OpenIH(world)
BOOL DrawEntry(world,x)
VOID DrawNWay(struct World *world,SHORT x,SHORT y,BOOL enabled,BOOL sunken)
   DrawBox(world,x,y,DAGW,DAGH,(BOOL)(! sunken));
   BOOL   Success;
   BOOL  HighLighted;
   BOOL  RolledOff;
   BOOL  Enabled;
BOOL   Activated(struct World *);
BOOL   DisplayOn(struct World *);
BOOL   OpenIH(struct World *);
void   DrawStatus(struct World *,SHORT,SHORT,BOOL);
BOOL Activated(world)
BOOL DisplayOn(world)
BOOL OpenIH(world)
      DrawStatus(world,C0TX,(SHORT)(((world->nodes-1)*GYSP)+TYS),(BOOL)(cd->cd_Flags&CDF_BADMEMORY));
BOOL state;
   BOOL  Highlited;
   BOOL  Enabled;
   BOOL  NoEnable;
   BOOL  Bootable;
   BOOL                 Cancel;
   BOOL					AdvancedMode; /* TRUE if advanvced options */
BOOL   DrawEntry(struct World *world,SHORT x);
BOOL   DrawFPEntry(struct World *world,SHORT x);
VOID   DrawNWay(struct World *world,SHORT x,SHORT y,BOOL enabled,BOOL sunken);
      DrawNWay(world,DAGX,DAGY,(BOOL)(! world->SS_Disable),FALSE);
            DrawNWay(world,DAGX,DAGY,(BOOL)(! world->SS_Disable),FALSE);
BOOL DrawEntry(world,x)
BOOL DrawFPEntry(world,x)
VOID DrawNWay(struct World *world,SHORT x,SHORT y,BOOL enabled,BOOL sunken)
   DrawBox(world,x,y,DAGW,DAGH,(BOOL)(! sunken));
BOOL DisplayOn(struct World *world, USHORT c0, USHORT c1, USHORT c2, USHORT c3)
BOOL OpenIH(struct World *world,APTR mycode)
   BOOL  Highlited;
   BOOL  Enabled;
   BOOL  NoEnable;
   BOOL  Bootable;
   BOOL                 Cancel;
   BOOL					AdvancedMode; /* TRUE if advanvced options */
BOOL   DrawEntry(struct World *world,SHORT x);
BOOL   DrawFPEntry(struct World *world,SHORT x);
VOID   DrawNWay(struct World *world,SHORT x,SHORT y,BOOL enabled,BOOL sunken);
      DrawNWay(world,DAGX,DAGY,(BOOL)(! world->SS_Disable),FALSE);
            DrawNWay(world,DAGX,DAGY,(BOOL)(! world->SS_Disable),FALSE);
BOOL DrawEntry(world,x)
BOOL DrawFPEntry(world,x)
VOID DrawNWay(struct World *world,SHORT x,SHORT y,BOOL enabled,BOOL sunken)
   DrawBox(world,x,y,DAGW,DAGH,(BOOL)(! sunken));
BOOL DisplayOn(struct World *world, USHORT c0, USHORT c1, USHORT c2, USHORT c3)
BOOL OpenIH(struct World *world,APTR mycode)
*	BOOL PutDefDiskObject(struct DiskObject *);
BOOL IPutDefDiskObject(struct DiskObject *dob)
    BOOL ret_val = FALSE;
*	BOOL = char *, struct OldWBObject *;
BOOL IPutWBObject( char *name, struct OldWBObject *object )
BOOL result;
*	BOOL PutIcon(char *, struct DiskObject *);
BOOL IPutIcon(char *name, struct DiskObject *romicon)
BOOL result=FALSE;
*	BOOL AddFreeList(struct FreeList *, APTR, ULONG);
BOOL IAddFreeList( struct FreeList *free, APTR mem, ULONG len )
BOOL result=TRUE;
*	BOOL PutDiskObject(char *, struct DiskObject *);
BOOL IPutDiskObject( char *name, struct DiskObject *diskobj )
    BOOL result;
*	BOOL MatchToolValue(char *, char *);
BOOL IMatchToolValue(char *type, char *value)
BOOL result=FALSE;
	  BOOLGADGET,			/* Gadget Type */
	  BOOLGADGET,			/* Gadget Type */
	  BOOLGADGET,			/* Gadget Type */
	  BOOLGADGET,			/* Gadget Type */
;	    BOOL = MatchFunc( DataVal, BufferData, MatchString )
; IsFileSystem - simply returns a BOOLEAN TRUE since we are a filing system
; IsFileSystem - simply returns a BOOLEAN TRUE since we are a filing system
; Sets the bit corresponding to keynum in the visitmap.  Returns a BOOLEAN to
; IsFileSystem - simply returns a BOOLEAN TRUE since we are a filing system
;	    BOOL = MatchFunc( DataVal, BufferData, MatchString )
; IsFileSystem - simply returns a BOOLEAN TRUE since we are a filing system
; Sets the bit corresponding to keynum in the visitmap.  Returns a BOOLEAN to
*	BOOL IsXXXX(struct Locale *,ULONG);
*	BOOL = char *, struct OldWBObject *;
    BOOL IPutIcon();
*	BOOL PutIcon(char *, struct DiskObject *);
BOOL
    BOOL result = FALSE;
    BOOL IAddFreeList();
*	BOOL AddFreeList(struct FreeList *, APTR, ULONG);
BOOL
*	BOOL PutDiskObject(char *, struct DiskObject *);
*	BOOL MatchToolValue(char *, char *);
BOOL
BOOL IPutDefDiskObject (struct DiskObject *);
*	BOOL PutDefDiskObject(struct DiskObject *);
BOOL
    BOOL ret_val = FALSE;
	  BOOLGADGET,			/* Gadget Type */
	  BOOLGADGET,			/* Gadget Type */
	  BOOLGADGET,			/* Gadget Type */
	  BOOLGADGET,			/* Gadget Type */
	  BOOLGADGET,			/* Gadget Type */
	  BOOLGADGET,			/* Gadget Type */
BOOL FillBuffer( struct DiskfontLibrary *,
BOOL FillBuffer( struct DiskfontLibrary *dfl,
	BOOL tfcTFlag,
	BOOL scaleOKFlag,
	BOOL tfcTFlag,
    BOOL scaleFlag;
		    (BOOL) (fch.fch_FileID != FCH_ID), fch.fch_NumEntries,
BOOL	FontSelectToggle = TRUE;		/* 
BOOL	ReadFile(char *);
BOOL ReadFile( filname )
BOOL	FontSelectToggle = TRUE;		/* 
         bset     #BOOLEAN,d7          ; all options are boolean
BOOLEAN  EQU      17                   ; booelan return?
         btst     #BOOLEAN,d7          ; a boolean value?
BFBool   bset     #BOOLEAN,d7          ; boolean return
BOOLEAN  SET      17
         ; Check for a BOOLEAN return
         btst     #BOOLEAN,d7          ; a boolean value?
SFBool   bset     #BOOLEAN,d7
5$:      bset     #BOOLEAN,d7          ; set flag
         bset     #BOOLEAN,d7          ; all options are boolean
BOOLEAN  EQU      17                   ; booelan return?
         btst     #BOOLEAN,d7          ; a boolean value?
BFBool   bset     #BOOLEAN,d7          ; boolean return
BOOL	dont_read_again = FALSE;
BOOL __asm IsUpper(register __d1 UBYTE character,
BOOL __asm IsLower(register __d1 UBYTE character,
BOOL __asm IsDigit(register __d1 UBYTE character,
BOOL __asm IsSpace(register __d1 UBYTE character,
BOOL __asm IsPunct(register __d1 UBYTE character,
BOOL __asm IsCntrl(register __d1 UBYTE character,
BOOL __asm IsBlank(register __d1 UBYTE character,
BOOL __asm IsXDigit(register __d1 UBYTE character,
	BOOL flag=FALSE;
    BOOL	rc;
    BOOL rc;
    BOOL	rc;
BOOL __asm IsUpper(register __d1 UBYTE character,
	return((BOOL)(language->is_upper[character]&IS_UPPER));
	return((*(BOOL (*)())language->is_upper) (character,language));
BOOL __asm IsLower(register __d1 UBYTE character,
	return((BOOL)(language->is_upper[character]&IS_LOWER));
	return((*(BOOL (*)())language->is_lower) (character,language));
BOOL __asm IsDigit(register __d1 UBYTE character,
	return((BOOL)(language->is_upper[character]&IS_DIGIT));
	return((*(BOOL (*)())language->is_digit) (character,language));
BOOL __asm IsSpace(register __d1 UBYTE character,
	return((BOOL)(language->is_upper[character]&IS_SPACE));
	return((*(BOOL (*)())language->is_space) (character,language));
BOOL __asm IsPunct(register __d1 UBYTE character,
	return((BOOL)(language->is_upper[character]&IS_PUNCT));
	return((*(BOOL (*)())language->is_punct) (character,language));
BOOL __asm IsCntrl(register __d1 UBYTE character,
	return((BOOL)(language->is_upper[character]&IS_CNTRL));
	return((*(BOOL (*)())language->is_cntrl) (character,language));
BOOL __asm IsBlank(register __d1 UBYTE character,
	return((BOOL)(language->is_upper[character]&IS_BLANK));
	return((*(BOOL (*)())language->is_blank) (character,language));
BOOL __asm IsXDigit(register __d1 UBYTE character,
	return((BOOL)(language->is_upper[character]&IS_XDIGIT));
	return((*(BOOL (*)())language->is_xdigit) (character,language));
BOOL __asm IsUpper(register __d1 UBYTE character,
BOOL __asm IsLower(register __d1 UBYTE character,
BOOL __asm IsDigit(register __d1 UBYTE character,
BOOL __asm IsSpace(register __d1 UBYTE character,
BOOL __asm IsPunct(register __d1 UBYTE character,
BOOL __asm IsCntrl(register __d1 UBYTE character,
BOOL __asm IsBlank(register __d1 UBYTE character,
BOOL __asm IsXDigit(register __d1 UBYTE character,
BOOL FillBuffer( struct DiskfontLibrary *,
BOOL FillBuffer( struct DiskfontLibrary *dfl,
	BOOL tfcTFlag,
	BOOL scaleOKFlag,
	BOOL tfcTFlag,
    BOOL scaleFlag;
		    (BOOL) (fch.fch_FileID != FCH_ID), fch.fch_NumEntries,
    BOOL engineFlag;
BOOL FillBuffer( struct DiskfontLibrary *,
BOOL FillBuffer( struct DiskfontLibrary *dfl,
	BOOL tfcTFlag,
	BOOL scaleOKFlag,
	BOOL tfcTFlag,
    BOOL scaleFlag;
		    (BOOL) (fch.fch_FileID != FCH_ID), fch.fch_NumEntries,
BOOL next_line()
BOOL prev_line()
BOOL window_event(ch)
BOOL room_for(n)
BOOL wait;
BOOL readfile(stream,base,startup)
BOOL startup;
   BOOL truncated, tabsexpanded;
BOOL wait;
BOOL cursor_left()
            do_exchange((BOOL)(ch==X_EQ));
   BOOL need_redisplay = FALSE;
BOOL checkomitted()
   return((BOOL)((c == ';') || (c == ENDSTREAMCH) || (c=='(')||(c==')')));
BOOL do_writebuf(line,endl,name,oldfile)
BOOL forwards;
   BOOL forwards;
BOOL query;
BOOL width;
BOOL extracted;          /* TRUE if current line extracted from store    */
BOOL extend_margin;      /* TRUE if margin extended              */
BOOL data_changed;       /* Flag to indicate file has changed    */
BOOL forcecase;          /* Flag to make search case insensitive */
 *	BOOLEAN hcheck (blkp)
BOOLEAN hcheck (blkp)
    BOOLEAN result;		/* Result of test */
BOOLEAN namesfit (fip)
    BOOLEAN result = TRUE;
BOOLEAN interrupt = FALSE;	/* Interrupt received */
 *	static BOOLEAN nextname (bufp, bufsize)
BOOLEAN nextname (bufp, bufsize)
    BOOLEAN result = FALSE;
static BOOLEAN checkulimit PROTO((struct finfo *fip));
static BOOLEAN makeparent PROTO((struct bstat *bstatp, struct finfo *fip));
static BOOLEAN makedir PROTO((struct finfo *fip));
    BOOLEAN is_directory;
 *	static BOOLEAN checkulimit (fip)
static BOOLEAN checkulimit (fip)
    BOOLEAN truncated = FALSE;
    BOOLEAN doextract = TRUE;
    BOOLEAN got_parent;
 *	static BOOLEAN makeparent (bstatp, fip)
static BOOLEAN makeparent (bstatp, fip)
    BOOLEAN got_dir;
 *	static BOOLEAN makedir (fip)
static BOOLEAN makedir (fip)
    BOOLEAN result;
    BOOLEAN linked;
static BOOLEAN bdiff PROTO((char *cp1, char *cp2, int count));
 *	static BOOLEAN bdiff (cp1, cp2, count)
static BOOLEAN bdiff (cp1, cp2, count)
    BOOLEAN result;
 *	BOOLEAN possible_end (iobytes, ioerr, read)
 *	BOOLEAN read;
BOOLEAN possible_end (iobytes, ioerr, read)
BOOLEAN read;
    BOOLEAN end;
 *	BOOLEAN known_end (iobytes, ioerr)
BOOLEAN known_end (iobytes, ioerr)
    BOOLEAN end = FALSE;
 *	BOOLEAN unformatted (iobytes, ioerr, read)
 *	BOOLEAN read;
BOOLEAN unformatted (iobytes, ioerr, read)
BOOLEAN read;
    BOOLEAN nofmt;
 *	BOOLEAN write_protect (iobytes, ioerr, read)
 *	BOOLEAN read;
BOOLEAN write_protect (iobytes, ioerr, read)
BOOLEAN read;
    BOOLEAN wprot;
 *	BOOLEAN seekable (fname, increment)
BOOLEAN seekable (fname, increment)
    BOOLEAN seekok;
 *	BOOLEAN raw_tape ()
BOOLEAN raw_tape ()
    BOOLEAN raw;
BOOLEAN ejectable ()
    BOOLEAN result = FALSE;
BOOLEAN needshmcopy ()
    BOOLEAN result = FALSE;
static BOOLEAN time_sane PROTO((struct tm *tp));
static BOOLEAN match PROTO((char *cp1, char *cp2));
 *	static BOOLEAN time_sane (tp)
static BOOLEAN time_sane (tp)
    BOOLEAN sanity;
 *	static BOOLEAN match (cp1, cp2)
static BOOLEAN match (cp1, cp2)
    BOOLEAN result;
static BOOLEAN changed PROTO((struct finfo *fip));
    BOOLEAN fileok = FALSE;
    BOOLEAN truncated;
static BOOLEAN changed (fip)
    BOOLEAN result;
static BOOLEAN initdone = FALSE;	/* Flag for initialization done */
static BOOLEAN inittried = FALSE;	/* Flag for initialization tried */
static BOOLEAN alloctables PROTO((void));
static BOOLEAN alloctables ()
    BOOLEAN result = TRUE;
    BOOLEAN tryseek = FALSE;
static BOOLEAN uadds = FALSE;	/* If set, checksums computed unsigned */
 *	BOOLEAN chksum_ok (blkp)
BOOLEAN chksum_ok (blkp)
    BOOLEAN result;		/* Result of checksum test */
static BOOLEAN FindEntry PROTO((char *devname, char *bp));
static BOOLEAN NamedEntry PROTO((char *name, char *bp));
static BOOLEAN FirstEntry PROTO((char *bp));
static BOOLEAN NameMatch PROTO((char *name, char *bp));
static BOOLEAN dgetflag PROTO((char *id, char *bp));
 *	static BOOLEAN FindEntry (devname, buf)
static BOOLEAN FindEntry (devn, bp)
    BOOLEAN status;
 *	static BOOLEAN NamedEntry (name, bp)
static BOOLEAN NamedEntry (name, bp)
    BOOLEAN status;
 *	static BOOLEAN FirstEntry (bp)
static BOOLEAN FirstEntry (bp)
    BOOLEAN status;
 *	static BOOLEAN NameMatch (name, bp)
static BOOLEAN NameMatch (name, bp)
    BOOLEAN status;
 *	static BOOLEAN dgetflag (id, bp)
static BOOLEAN dgetflag (id, bp)
    BOOLEAN result;
static BOOLEAN recover PROTO((int iobytes, int ioerr, BOOLEAN readflag));
static BOOLEAN do_open PROTO((void));
static VOID harderror PROTO((LBA errorpba, BOOLEAN readflag, int iobytes));
static BOOLEAN reading;			/* Reading from archive */
static BOOLEAN bswap = FALSE;		/* Swap bytes in buffer */
static BOOLEAN sswap = FALSE;		/* Swap shorts in buffer */
static BOOLEAN seekflag = FALSE;	/* Use seeks instead of reads */
static BOOLEAN data = FALSE;		/* Flag for buffer has data */
static BOOLEAN dirty = FALSE;		/* Buffer has been changed */
static BOOLEAN first = TRUE;		/* First read/write of media */
static BOOLEAN checkswap = TRUE;	/* Only swap check once per media */
static BOOLEAN pipe_io = FALSE;		/* Doing I/O to/from a pipe */
    BOOLEAN new;
    BOOLEAN reopen = FALSE;
 *	static BOOLEAN recover (iobytes, ioerr, readflag)
 *	BOOLEAN readflag;
static BOOLEAN recover (iobytes, ioerr, readflag)
BOOLEAN readflag;
    BOOLEAN unfmt;
    BOOLEAN wprot;
    BOOLEAN poed;		/* Possible end of device */
    BOOLEAN koed;		/* Known end of device */
    BOOLEAN rawtape;
    BOOLEAN recoverable;
    BOOLEAN advanced;
static BOOLEAN do_open ()
    BOOLEAN rtnval;
    BOOLEAN accessible;
    BOOLEAN exists;
BOOLEAN need_swap (blkp)
BOOLEAN ar_ispipe ()
 *	BOOLEAN new_arfile (vol)
BOOLEAN new_arfile (vol)
    BOOLEAN rtnval;
 *	BOOLEAN readflag;
BOOLEAN readflag;
 *	BOOLEAN file_access (name, amode, flag)
 *	BOOLEAN flag;
BOOLEAN file_access (name, amode, flag)
BOOLEAN flag;
 *	BOOLEAN dir_access (name, amode, flag)
 *	BOOLEAN flag;
BOOLEAN dir_access (name, amode, flag)
BOOLEAN flag;
    BOOLEAN result;
static BOOLEAN iswild PROTO((char *string, char *pattern));
static BOOLEAN do_list PROTO((char *string, char *pattern));
 *	BOOLEAN wild (string, pattern)
BOOLEAN wild (string, pattern)
    BOOLEAN match;
 *	static BOOLEAN iswild (string, pattern)
static BOOLEAN iswild (string, pattern)
    BOOLEAN match;
 *	static BOOLEAN do_list (string, pattern)
static BOOLEAN do_list (string, pattern)
    BOOLEAN match;
    BOOLEAN if_found;
    BOOLEAN if_not_found;
 *	BOOLEAN eoablk (blkp)
BOOLEAN eoablk (blkp)
    BOOLEAN result;		/* Result of test */
 *	BOOLEAN allnulls (data, nbytes)
BOOLEAN allnulls (data, nbytes)
    BOOLEAN result;
 *	BOOLEAN mklink (exists, new)
BOOLEAN mklink (exists, new)
 *	BOOLEAN mksymlink (exists, new)
BOOLEAN mksymlink (exists, new)
    BOOLEAN linked;
 *	BOOLEAN out_of_date (fip)
BOOLEAN out_of_date (fip)
    BOOLEAN result;
 *	BOOLEAN selected (fip)
BOOLEAN selected (fip)
    BOOLEAN select;
BOOLEAN copy (out, in, outsize)
 *	BOOLEAN unconditional (fip)
BOOLEAN unconditional (fip)
    BOOLEAN rtnval;
 *	BOOLEAN quit;
BOOLEAN quit;
 *	BOOLEAN newdir (fip)
BOOLEAN newdir (fip)
    BOOLEAN filemade;
 *	BOOLEAN magic_ok (blkp)
BOOLEAN magic_ok (blkp)
    BOOLEAN rtnval;
BOOLEAN openzfile (fip)
BOOLEAN compressfip (fip)
BOOLEAN decompfip (fip)
    BOOLEAN accessible;
    BOOLEAN exists;
 *	BOOLEAN namesane (devname)
BOOLEAN namesane (devname)
    BOOLEAN result = TRUE;
BOOLEAN nameconfirm (dname)
    BOOLEAN result = TRUE;
 *	BOOLEAN confirmed (action, fip)
BOOLEAN confirmed (action, fip)
    BOOLEAN result;
static BOOLEAN wildcards = FALSE;	/* Filename patterns encountered */
static BOOLEAN do_it PROTO((VOID (*funcp )(), BOOLEAN expanding, BOOLEAN explicit));
static BOOLEAN add_leaf PROTO((char *name, char *cp));
static BOOLEAN checkmisc PROTO((struct finfo *fip, BOOLEAN expanding));
 *	static BOOLEAN do_it (funcp, expanding, explicit)
 *	BOOLEAN expanding;
 *	BOOLEAN explicit;
static BOOLEAN do_it (funcp, expanding, explicit)
BOOLEAN expanding;
BOOLEAN explicit;
    BOOLEAN rtnval;
    BOOLEAN deof = FALSE;
    BOOLEAN deof = FALSE;
 *	static BOOLEAN add_leaf (name, cp)
static BOOLEAN add_leaf (name, cp)
    BOOLEAN rtnval;
    static BOOLEAN buffull = FALSE;
 *	static BOOLEAN checkmisc (fip, expanding)
 *	BOOLEAN expanding;
static BOOLEAN checkmisc (fip, expanding)
BOOLEAN expanding;
    BOOLEAN rtnval;
typedef int BOOLEAN;
EXPORT BOOLEAN _db_on_ = FALSE;		/* TRUE if debugging currently on */
EXPORT BOOLEAN _db_pon_ = FALSE;	/* TRUE if debugging currently on */
LOCAL BOOLEAN init_done = FALSE;/* Set to TRUE when initialization done */
LOCAL BOOLEAN InList PROTO((struct link *linkp, char *cp));
LOCAL BOOLEAN DoProfile PROTO((void));
LOCAL BOOLEAN DoTrace PROTO((void));
LOCAL BOOLEAN Writable PROTO((char *pathname));
 *	LOCAL BOOLEAN InList (linkp, cp)
LOCAL BOOLEAN InList (linkp, cp)
    BOOLEAN accept;
 *	LOCAL BOOLEAN DoTrace ()
LOCAL BOOLEAN DoTrace ()
    BOOLEAN trace;
 *	LOCAL BOOLEAN DoProfile ()
LOCAL BOOLEAN DoProfile ()
    BOOLEAN profile;
 *	BOOLEAN _db_keyword_ (keyword)
BOOLEAN _db_keyword_ (keyword)
    BOOLEAN accept;
    BOOLEAN newfile;
    BOOLEAN newfile;
 *	LOCAL BOOLEAN Writable (pathname)
LOCAL BOOLEAN Writable (pathname)
    BOOLEAN granted;
static BOOLEAN pwentopen = FALSE;
static BOOLEAN grentopen = FALSE;
static BOOLEAN iscondlink PROTO((char *name));
 *	static BOOLEAN iscondlink (name)
static BOOLEAN iscondlink (name)
    BOOLEAN rtnval = FALSE;
    BOOLEAN attfirst = TRUE;
BOOLEAN ignore;
    BOOLEAN done;		/* Finished scanning archive */
    BOOLEAN linked;		/* Linked to previous entry */
static BOOLEAN is_junk PROTO((union blk *blkp));
    static BOOLEAN info_done = FALSE;
BOOLEAN forcebuffer ()
    static BOOLEAN been_here = FALSE;
static BOOLEAN is_junk (blkp)
    BOOLEAN result;
    static BOOLEAN warned = FALSE;
	flags.uaflag = (BOOLEAN) (s_strchr (u_arg, 'a') != NULL);
	flags.ubflag = (BOOLEAN) (s_strchr (u_arg, 'b') != NULL);
	flags.ucflag = (BOOLEAN) (s_strchr (u_arg, 'c') != NULL);
	flags.udflag = (BOOLEAN) (s_strchr (u_arg, 'd') != NULL);
	flags.ulflag = (BOOLEAN) (s_strchr (u_arg, 'l') != NULL);
	flags.upflag = (BOOLEAN) (s_strchr (u_arg, 'p') != NULL);
	flags.urflag = (BOOLEAN) (s_strchr (u_arg, 'r') != NULL);
	    flags.urflag = (BOOLEAN) (s_strchr (u_arg, 'f') != NULL);
	flags.Acflag = (BOOLEAN) (s_strchr (A_arg, 'c') != NULL);
	flags.Afflag = (BOOLEAN) (s_strchr (A_arg, 'f') != NULL);
	flags.Aiflag = (BOOLEAN) (s_strchr (A_arg, 'i') != NULL);
	flags.Arflag = (BOOLEAN) (s_strchr (A_arg, 'r') != NULL);
	flags.Asflag = (BOOLEAN) (s_strchr (A_arg, 's') != NULL);
static BOOLEAN secure PROTO((void));
 *	BOOLEAN execute (dir, file, vector)
BOOLEAN execute (dir, file, vector)
    BOOLEAN rtnval;
static BOOLEAN secure ()
static BOOL is_bru_message PROTO((struct BruMessage *brumsg));
static BOOL is_bru_message (struct BruMessage *brumsg)
    BOOL result;
 *	BOOLEAN fipstat (fip, report)
BOOLEAN fipstat (fip, report)
static BOOLEAN setupcopy ();
    BOOLEAN trywait;
 *	static BOOLEAN setupcopy ();
static BOOLEAN setupcopy ()
    BOOLEAN result = TRUE;
 *	static BOOLEAN attachvars ();
static BOOLEAN attachvars ()
    BOOLEAN result = FALSE;
    static BOOLEAN msgprinted = FALSE;
    static BOOLEAN gotbrk = FALSE;
 *	BOOLEAN fipstat (fip, report)
BOOLEAN fipstat (fip, report)
  BOOL skip1,printflag=TRUE;
static BOOL CreateFastROM(void);
static BOOL CreateTrap(void);
BOOL CreateFastROM()
BOOL CreateTrap()
struct checker { char *item; BOOL tag; };
static BOOL striequ(s1,s2)
   BOOL aok;
   return (BOOL) (!*s1 && aok);
static BOOL CreateFastROM(wrapbits)
   BOOL worked, dommutest = TRUE, fastrom = FR_NO_ACTION;
struct checker { char *item; BOOL tag; };
static BOOL striequ(s1,s2)
   BOOL aok;
   return (BOOL) (!*s1 && aok);
static BOOL CreateFastROM(wrapbits)
   BOOL worked, dommutest = TRUE, fastrom = FR_NO_ACTION;
BOOL CreateKickChipRAM(int argc, char *argv[]);
BOOL CreateKickRAM(int argc, char *argv[]);
BOOL CreateTable(long);
BOOL CreateKickChipRAM(int argc, char *argv[])
BOOL CreateKickRAM(int argc, char *argv[])
BOOL CreateTable(long RamROM)
BOOL truncate(p)
   BOOL f;
BOOL incrementp()
   BOOL upcase;
   BOOL backscan;
   BOOL counting;
BOOL expanded;   /* Line has had all tabs expanded               */
BOOL condensed;  /* Line has had all deleted chars removed       */
BOOL exhausted;  /* We have reached end of file for current file */
BOOL quiet;      /* QUIET mode, don't display output lines       */
BOOL deleting;   /* Delete mode when walking through lines       */
BOOL repeating;  /* Repeat mode - Repeat previous A/B/E command  */
BOOL unchanged;  /* No changes have been made on the line        */
BOOL nosubs;     /* No substitutions have been done on this line */
BOOL verifying;
BOOL trailing;
BOOL opened;
BOOL readplusminus()
BOOL qsw;
BOOL flag;
   BOOL ufound;
   BOOL subssave;
void PrintInfo(struct DosLibrary *, struct InfoData *, struct DosList *, BOOL);
BOOL volume;
BOOL substwrites(struct Global *gv,UBYTE *s, LONG pmax, UBYTE *v, LONG *lvp);
   BOOL comline = (ch != ';');
BOOL substwrites(gv, s , pmax, v, lvp)
   BOOL MyOldLock = FALSE;
BOOL		externresetwb;
BOOL		externsetprefs;
    BOOL			Quit = FALSE;
extern BOOL externresetwb;
extern BOOL externsetprefs;
BOOL wbdefaultdim = TRUE;
    BOOL		initial = TRUE;
BOOL initial;
extern BOOL wbdefaultdim;
    BOOL succeeded = FALSE;
BOOL ReadILBM(struct FileHandle *);
BOOL GetILBM(struct IFFHandle *);
BOOL GetBMHD(struct IFFHandle *, struct BitMapHeader *);
BOOL GetColors(struct IFFHandle *, struct ColorRegister *);
BOOL GetBody(struct IFFHandle *, struct BitMapHeader *, struct BitMap *);
BOOL GetLine(struct IFFHandle *, UBYTE *, WORD, WORD, UBYTE);
BOOL SetIColors(WORD, WORD, WORD, struct ColorRegister *);
 * ==	BOOL ReadILBM(struct FileHandle *)				 == *
BOOL ReadILBM(fp)
    BOOL status = FALSE;
    BOOL BodyFlag = FALSE;
    return ((BOOL)status);
 * ==	BOOL GetILBM(struct IFFHandle *)				 == *
BOOL GetILBM(iff)
 * ==	BOOL GetBMHD(struct IFFHandle *, struct BitMapHeader *)		 == *
BOOL GetBMHD(iff, bmhd)
 * ==	BOOL GetColors(struct IFFHandle *, struct ColorRegister *)	 == *
BOOL GetColors(iff, cmap)
 * ==	BOOL GetBody(struct IFFHandle *, struct BitMapHeader *,		 == *
BOOL GetBody(iff, bmhd, bm)
    BOOL status = TRUE;
BOOL GetLine(iff, buf, wide, deep, cmptype)
    BOOL status = FALSE;
    return ((BOOL)status);
 * ==	BOOL SetIColors(WORD, WORD, WORD, struct ColorRegister *)	 == *
BOOL SetIColors(cmstart, csstart, numcolors, cmap)
BOOL ud=0;
BOOL ud;
BOOL mode;
    BOOL libfail = FALSE, loop;
    BOOL out = FALSE, in = FALSE; // IO status of this process. out is ACTION_FINDOUTPUT, in is ACTION_FINDINPUT.
BOOL ParseName(char *name, char *dev, long *pbsize, long *plimit) // Returns TRUE if successful
    BOOL ret = TRUE;
BOOL DeleteQueue (Queue *q)     // Delete Queue from list, ONLY IF there are no QueBufs left... (later we may modify this)
    BOOL did_we;  // Did we delete it?
    BOOL PAR_shared;		/* Is the device opened in shared mode? */
    BOOL PAR_stopped;		/* Is the device stopped with CMD_STOP? */
    BOOL ACKwasON;		/* Was the ACK enabled previously? */
    BOOL TimerUsed;		/* Has the timer.device been used yet?  */
	BOOL dont_reply = FALSE;	/* shall we reply in the DoIO? */
    BOOL    cu_CutValid;		/* false if clip contents not valid */
BOOL
    BOOL workToDo;
BOOL EscFlag; /* EscFlag is a flag to indicate there is */
	BOOL Alias, Floyd;
	BOOL Alias, Floyd;
	BOOL Alias, Floyd;
	BOOL Floyd;
BOOL  short_f1;
BOOL	MannerSwap;
BOOL syllstart,termassign;		/* Flags for F0			    */
	BOOL			nasal_f;
	BOOL			sylnasal_f;
	BOOL			voiced_plosive_f;
	BOOL			use_left_fricid;
	BOOL			wordfinal;
	BOOL			mouthflag;
extern BOOL  syllstart;
extern BOOL  termassign;
BOOL phrasefinal, lastvoiced;
BOOL GetILBM(struct IFFHandle *, PREF *);
BOOL GetBMHD(struct IFFHandle *, struct BitMapHeader *);
BOOL PutBMHD(struct IFFHandle *, struct BitMapHeader *, struct BitMap *);
BOOL GetColors(struct IFFHandle *, struct ColorRegister *);
BOOL PutColors(struct IFFHandle *, struct BitMapHeader *,
BOOL PutHotSpot(struct IFFHandle *, struct Point2D *);
BOOL GetBody(struct IFFHandle *, struct BitMapHeader *, struct BitMap *);
BOOL GetLine(struct IFFHandle *, UBYTE *, WORD, WORD, UBYTE);
BOOL PutBody(struct IFFHandle *, struct BitMapHeader *, struct BitMap *);
BOOL InitSketchBM(UBYTE);
BOOL AllocBMRasters(struct BitMap *, BYTE, WORD, WORD);
 * ==	BOOL GetILBM(struct IFFHandle *, PREF *)			 == *
BOOL GetILBM(iff, MP)
 * ==	BOOL PutILBM(struct IFFHandle *, PREF *)			 == *
BOOL PutILBM(iff, MP)
    BOOL status = FALSE;
 * ==	BOOL GetBMHD(struct IFFHandle *, struct BitMapHeader *)		 == *
BOOL GetBMHD(iff, bmhd)
 * ==	BOOL PutBMHD(struct IFFHandle *, struct BitMapHeader *,		 == *
BOOL PutBMHD(iff, bmhd, bm)
 * ==	BOOL GetColors(struct IFFHandle *, struct ColorRegister *)	 == *
BOOL GetColors(iff, cmap)
 * ==	BOOL PutColors(struct IFFHandle *, struct BitMapHeader *,	 == *
BOOL PutColors(iff, bmhd, cmap)
 * ==	BOOL PutHotSpot(struct IFFHandle *, struct Point2D *)		 == *
BOOL PutHotSpot(iff, grab)
 * ==	BOOL GetBody(struct IFFHandle *, struct BitMapHeader *,		 == *
BOOL GetBody(iff, bmhd, bm)
    BOOL status = TRUE;
BOOL GetLine(iff, buf, wide, deep, cmptype)
 * ==	BOOL PutBody(struct IFFHandle *, struct BitMapHeader *,		 == *
BOOL PutBody(iff, bmhd, bitmap)
 * ==	BOOL InitSketchBM(UBYTE)					 == *
BOOL InitSketchBM(depth)
 * ==	BOOL AllocBMRasters(struct BitMap *, BYTE, WORD, WORD)		 == *
BOOL AllocBMRasters(bm, depth, width, height)
WORD ReadData(char *, PREF *, BOOL);
BOOL Quiet;
    BOOL status = ST_BAD_READ;
    BOOL BodyFlag = FALSE;
extern BOOL PModified;
BOOL InitGadgets(window)
BOOL GadgetPick(imsg)
    BOOLGADGET,		/* Type */
extern BOOL InitGadgets();
extern BOOL InitSpecial();
extern BOOL InitMenus();
BOOL PModified = FALSE;
BOOL SaveIcon = TRUE;
extern BOOL FileRequest();
extern BOOL SaveIcon;
BOOL menuattached = FALSE;
BOOL InitMenus(win)
 * ==	BOOL InitSpecial()						 == *
BOOL InitSpecial()
BOOL FileRequest(BOOL);
BOOL FileRequest(mode)
BOOL mode;
    BOOL success;
	success = (BOOL)AslRequestTags(fr,
	success = (BOOL)AslRequestTags(fr,
    BOOLGADGET,		/* Type */
extern BOOL FileRequest();
extern BOOL SaveIcon;
BOOL menuattached = FALSE;
BOOL InitMenus(win)
extern BOOL InitGadgets();
extern BOOL InitSpecial();
extern BOOL InitMenus();
extern	BOOL ReadData();
extern	BOOL ReadDataE();
BOOL PModified = FALSE;
BOOL SaveIcon = TRUE;
    BOOL success;
BOOL ReadData(EnvFile, EnvBuf)
    BOOL status = FALSE;
    BOOL HeaderFlag = FALSE;
    BOOL DataFlag = FALSE;
    return ((BOOL)status);
BOOL WriteData(EnvFile, EnvBuf)
    BOOL status = FALSE;
BOOL ReadDataE(EnvBuf)
    return((BOOL)ReadData(ENV_NAME, EnvBuf));
BOOL WriteDataE(EnvBuf)
    return((BOOL)WriteData(ENV_NAME, EnvBuf));
BOOL ReadDataA(EnvBuf)
    return((BOOL)ReadData(ARC_NAME, EnvBuf));
BOOL WriteDataA(EnvBuf)
    return((BOOL)WriteData(ARC_NAME, EnvBuf));
extern BOOL PModified;
BOOL InitGadgets(window)
BOOL GadgetPick(imsg)
BOOL FileRequest(win, mode)
BOOL mode;
BOOL AllocBMRasters(struct BitMap *, BYTE, WORD, WORD);
void SetOldPrefs(PREF *, BOOL);
BOOL InitSpecial()
BOOL AllocBMRasters(bm, depth, width, height)
BOOL Save;
BOOL InitGadgets(window)
BOOL GadgetPick(imsg)
void FileError(BOOL, UBYTE *);
WORD ReadData(char *, char *, BOOL);
 * ==	WORD ReadData(char *, char *, BOOL)				 == *
BOOL Quiet;
    BOOL HeaderFlag = FALSE;
    BOOL DataFlag = FALSE;
BOOL FileRequest(BOOL);
BOOL FileRequest(mode)
BOOL mode;
    BOOL success;
	success = (BOOL)AslRequestTags(fr,
	success = (BOOL)AslRequestTags(fr,
extern BOOL InitGadgets();
extern BOOL InitSpecial();
extern BOOL InitMenus();
BOOL PModified = FALSE;
BOOL SaveIcon = TRUE;
    BOOLGADGET,		/* Type */
extern BOOL FileRequest();
extern BOOL SaveIcon;
BOOL menuattached = FALSE;
BOOL InitMenus(win)
BOOL AddPrinterName();
BOOL InitSpecial()
    BOOL MadeChange;
	FreeRemember(rk, (BOOL)TRUE);
void FileError(BOOL, UBYTE *);
WORD ReadData(char *, char *, BOOL);
 * ==	WORD ReadData(char *, char *, BOOL)				 == *
BOOL Quiet;
    BOOL HeaderFlag = FALSE;
    BOOL DataFlag = FALSE;
BOOL UpdateBuffer(BYTE *, ULONG, ULONG, UWORD, BYTE);
BOOL InitGadgets(window)
      (BOOL)(EnvWrk.pp_ColorCorrect & CORRECT_RED), TAG_DONE);
      (BOOL)(EnvWrk.pp_ColorCorrect & CORRECT_GREEN), TAG_DONE);
      (BOOL)(EnvWrk.pp_ColorCorrect & CORRECT_BLUE), TAG_DONE);
      (BOOL)(EnvWrk.pp_GraphicFlags & ANTI_ALIAS), TAG_DONE);
      (BOOL)(EnvWrk.pp_GraphicFlags & CENTER_IMAGE), TAG_DONE);
      GA_DISABLED, (BOOL)(EnvWrk.pp_GraphicFlags & CENTER_IMAGE),
      GA_DISABLED, (BOOL)(EnvWrk.pp_Dimensions == IGNORE_DIMENSIONS),
      GA_DISABLED, (BOOL)(EnvWrk.pp_Dimensions == IGNORE_DIMENSIONS),
      (BOOL)(EnvWrk.pp_ColorCorrect & CORRECT_RED), TAG_DONE);
      (BOOL)(EnvWrk.pp_ColorCorrect & CORRECT_GREEN), TAG_DONE);
      (BOOL)(EnvWrk.pp_ColorCorrect & CORRECT_BLUE), TAG_DONE);
      (BOOL)(EnvWrk.pp_GraphicFlags & ANTI_ALIAS), TAG_DONE);
      (BOOL)(EnvWrk.pp_GraphicFlags & CENTER_IMAGE), TAG_DONE);
      GA_DISABLED, (BOOL)(EnvWrk.pp_GraphicFlags & CENTER_IMAGE),
BOOL GadgetPick(imsg)
	      (BOOL)(EnvWrk.pp_ColorCorrect & CORRECT_RED), TAG_DONE);
	      (BOOL)(EnvWrk.pp_ColorCorrect & CORRECT_GREEN), TAG_DONE);
	      (BOOL)(EnvWrk.pp_ColorCorrect & CORRECT_BLUE), TAG_DONE);
	      (BOOL)(EnvWrk.pp_GraphicFlags & ANTI_ALIAS), TAG_DONE);
	      (BOOL)(EnvWrk.pp_GraphicFlags & CENTER_IMAGE), TAG_DONE);
	      GA_DISABLED, (BOOL)(EnvWrk.pp_GraphicFlags & CENTER_IMAGE),
      GA_DISABLED, (BOOL)(EnvWrk.pp_Dimensions == IGNORE_DIMENSIONS),
      GA_DISABLED, (BOOL)(EnvWrk.pp_Dimensions == IGNORE_DIMENSIONS),
BOOL UpdateBuffer(BYTE *, ULONG, ULONG, UWORD, BYTE);
BOOL InitSpecial()
    BOOL point = FALSE;
BOOL UpdateBuffer(buf, WidthHeight, limit, numchars, Point)
    BOOLGADGET,		/* Type */
extern BOOL InitGadgets();
extern BOOL InitSpecial();
extern BOOL InitMenus();
BOOL PModified = FALSE;
BOOL SaveIcon = TRUE;
extern BOOL FileRequest();
extern BOOL SaveIcon;
BOOL menuattached = FALSE;
BOOL InitMenus(win)
BOOL FileRequest(BOOL);
BOOL FileRequest(mode)
BOOL mode;
    BOOL success;
	success = (BOOL)AslRequestTags(fr,
	success = (BOOL)AslRequestTags(fr,
BOOL InitGadgets(struct Window *);
BOOL CreateCalGadgets();
void HiLiteDay(UWORD, BOOL);
BOOL InitGadgets(window)
BOOL CreateCalGadgets()
	g->GadgetType = BOOLGADGET;
BOOL state;
extern BOOL InitGadgets();
extern BOOL InitSpecial();
BOOL PModified = FALSE;
void HiLiteDay(UWORD, BOOL);
BOOL InitSpecial()
BOOL GetTime(cdata)
    BOOL error = FALSE;
BOOL SetTime(cdata, batclock)
BOOL batclock;
    BOOLGADGET,		/* Type */
BOOL ScanGadgets(WORD which);
WORD ReadScreenModePrefs(STRPTR name, BOOL Quiet);
WORD ReadData(STRPTR name, struct diskScreenModePref *buffer, BOOL Quiet);
BOOL Quiet;
BOOL Quiet;
    BOOL HeaderFlag = FALSE;
    BOOL DataFlag = FALSE;
WORD ReadScreenModePrefs(STRPTR name, BOOL Quiet);
BOOL ScanGadgets(WORD which);
BOOL get_modedata(ULONG ID);
BOOL AcceptableMode(ULONG id, struct DisplayInfo *qdisp,
BOOL terminated;
BOOL get_modedata( ID )
    return((BOOL) ((info && mntr && dims)? success : FALSE ));
BOOL AcceptableMode(id, qdisp, qdims, qmntr)
    BOOL ok;
BOOL get_modedata(ULONG ID);
WORD ReadScreenModePrefs(STRPTR name, BOOL Quiet);
BOOL CreatePrefsGadgets(struct Window *win, void *vi, UWORD topborder);
BOOL ScanGadgets(WORD which);
BOOL SaveIcon = TRUE;
 * Returns:  (BOOL) success = TRUE
BOOL CreatePrefsGadgets(win, vi, topborder)
	GTCB_Checked, (BOOL)((current.control & 1)),
    return((BOOL)(gad != NULL));
 * Returns:  (BOOL) TRUE if the action was a terminating action.
    BOOL reset;
		    if (current.defwidth = ((BOOL) (defwidthgad->Flags & SELECTED)))
		    if (current.defheight = ((BOOL) (defheightgad->Flags & SELECTED)))
	GTCB_Checked, (BOOL)((current.control & 1)),
BOOL ScanGadgets(which)
    BOOL rangecheck = FALSE;
    BOOLGADGET,		/* Type */
WORD ReadInputPrefs(STRPTR name, BOOL Quiet);
BOOL WriteInputPrefs(STRPTR name);
BOOL terminated;
WORD ReadInputPrefs(STRPTR name, BOOL Quiet);
BOOL writeSysConfig(void);
WORD ReadData(STRPTR name, struct InputPref *buffer, BOOL Quiet);
BOOL Quiet;
BOOL writeSysConfig()
BOOL Quiet;
    BOOL HeaderFlag = FALSE;
    BOOL DataFlag = FALSE;
WORD ReadInputPrefs(STRPTR name, BOOL Quiet);
BOOL writeSysConfig(void);
BOOL CreatePrefsGadgets(void *vi, UWORD topborder);
void SetInputPrefs(struct InputPref *pref, BOOL notify);
BOOL myDoubleClick(LONG startsecs, LONG startmicros, LONG nowsecs,
BOOL clicktest = FALSE;
BOOL changedprefs = FALSE;
BOOL SaveIcon = TRUE;
 * Returns:  (BOOL) success = TRUE
BOOL CreatePrefsGadgets(vi, topborder)
	GTCB_Checked, (BOOL) (current.MouseAccel),
    return((BOOL)(gad != NULL));
 * Returns:  (BOOL) TRUE if the action was a terminating action.
	GTCB_Checked, (BOOL) (current.MouseAccel),
    BOOL notify;
BOOL myDoubleClick(startsecs, startmicros, nowsecs, nowmicros)
    BOOL answer;
BOOL EditOScans(WORD oscantype, struct Window *wbwin);
BOOL TestSizing(WORD x, WORD y);
    struct IntuiMessage *imsg, BOOL inedit);
BOOL EditOScans(oscantype, wbwin)
    BOOL retval = FALSE;
    BOOL sizing;
BOOL TestSizing(x, y)
    return( (BOOL)((horiz != 0) && (vert != 0)) );
BOOL get_modedata(ULONG ID, BOOL nocareavail);
BOOL ReadOScanPrefs(STRPTR name);
BOOL WriteOScanPrefs(STRPTR name);
BOOL AddPrefsEntry(struct MinList *list, ULONG ID,
BOOL BuildCurrentList(struct MinList *list);
BOOL ReadData(STRPTR name, struct MinList *list);
BOOL WriteData(STRPTR name, struct MinList *list);
BOOL ReadOScanPrefs(name)
    BOOL retval = TRUE;
BOOL WriteOScanPrefs(name)
    BOOL retval = TRUE;
BOOL ReadData(name, list)
    BOOL status = FALSE;
    BOOL HeaderFlag = FALSE;
    BOOL DataFlag = FALSE;
    return((BOOL)status);
BOOL WriteData(name, list)
    BOOL status = FALSE;
    BOOL found;
BOOL AddPrefsEntry(struct MinList *list, ULONG ID,
BOOL BuildCurrentList(struct MinList *list)
    BOOL ok = TRUE;
BOOL EditOScans(WORD oscantype, struct Window *wbwin);
    struct IntuiMessage *imsg, BOOL inedit);
BOOL CreatePrefsGadgets(struct Window *win, void *vi, UBYTE topborder);
BOOL noadjust;
    BOOL found;
	found = (BOOL) (((currentgroup->EditMode->dm_ID) & MONITOR_ID_MASK) == myscreenID);
 * Returns:  (BOOL) success = TRUE
BOOL CreatePrefsGadgets(win, vi, topborder)
    return((BOOL)(gad != NULL));
 * Returns:  (BOOL) TRUE if the action was a terminating action.
    BOOL inedit;
BOOL EditOScans(WORD oscantype, struct Window *wbwin);
BOOL TestSizing(WORD x, WORD y);
    struct IntuiMessage *imsg, BOOL inedit);
BOOL EditOScans(oscantype, wbwin)
    BOOL retval = FALSE;
    BOOL sizing;
BOOL TestSizing(x, y)
    return( (BOOL)((horiz != 0) && (vert != 0)) );
    struct IntuiMessage *imsg, BOOL inedit);
BOOL BuildCurrentList(struct MinList *list);
BOOL get_modedata(ULONG ID, BOOL nocareavail);
BOOL AcceptableMode(ULONG id, struct DisplayInfo *qdisp,
BOOL terminated;
BOOL machineispal = FALSE;
BOOL get_modedata( ID, nocareavail )
    BOOL nocareavail;
    return((BOOL) ((info && mntr && dims)? success : FALSE ));
BOOL AcceptableMode(id, qdisp, qdims, qmntr)
    BOOL ok;
    struct IntuiMessage *imsg, BOOL inedit);
BOOL BuildCurrentList(struct MinList *list);
WORD ReadOScanPrefs(char *name, BOOL Quiet);
BOOL get_modedata(ULONG ID, BOOL nocareavail);
BOOL AcceptableMode(ULONG id, struct DisplayInfo *qdisp,
BOOL terminated;
BOOL machineispal = FALSE;
BOOL get_modedata( ID, nocareavail )
BOOL nocareavail;
    return((BOOL) ((info && mntr && dims)? success : FALSE ));
BOOL AcceptableMode(id, qdisp, qdims, qmntr)
    BOOL ok;
    BOOLGADGET,		/* Type */
BOOL EditOScans(WORD oscantype, struct Window *wbwin);
WORD ReadOScanPrefs(char *name, BOOL Quiet);
    struct IntuiMessage *imsg, BOOL inedit);
BOOL CreatePrefsGadgets(struct Window *win, void *vi, UBYTE topborder);
BOOL noadjust;
BOOL SaveIcon = TRUE;
    BOOL found;
	found = (BOOL) (((currentgroup->EditMode->dm_ID) & MONITOR_ID_MASK) == myscreenID);
 * Returns:  (BOOL) success = TRUE
BOOL CreatePrefsGadgets(win, vi, topborder)
    return((BOOL)(gad != NULL));
 * Returns:  (BOOL) TRUE if the action was a terminating action.
    BOOL inedit;
BOOL get_modedata(ULONG ID, BOOL nocareavail);
WORD ReadOScanPrefs(STRPTR name, BOOL Quiet);
BOOL AddPrefsEntry(struct MinList *list, ULONG ID,
BOOL BuildCurrentList(struct MinList *list);
WORD ReadData(STRPTR name, struct MinList *list, BOOL Quiet);
extern BOOL machineispal;
BOOL Quiet;
BOOL Quiet;
    BOOL status = ST_BAD_READ;
    BOOL HeaderFlag = FALSE;
    BOOL DataFlag = FALSE;
    BOOL status = ST_BAD_WRITE;
    BOOL found;
BOOL AddPrefsEntry(struct MinList *list, ULONG ID,
BOOL BuildCurrentList(struct MinList *list)
    BOOL ok = TRUE;
void FileError(BOOL, UBYTE *);
WORD ReadData(char *, char *, BOOL);
 * ==	WORD ReadData(char *, char *, BOOL)				 == *
BOOL Quiet;
    BOOL HeaderFlag = FALSE;
    BOOL DataFlag = FALSE;
 * ==	void FileError(BOOL, UBYTE *)					 == *
extern BOOL InitGadgets();
extern BOOL InitSpecial();
extern BOOL InitMenus();
BOOL mod[3] = { FALSE, FALSE, FALSE };	/* font-is-modified flag */
BOOL SaveIcon = TRUE;
extern BOOL mod[3];		/* font-is-modified flag */
BOOL InitFontList();
BOOL InitGadgets(window)
BOOL GadgetPick(imsg)
    BOOLGADGET,		/* Type */
extern BOOL FileRequest();
extern BOOL SaveIcon;
BOOL menuattached = FALSE;
BOOL InitMenus(win)
BOOL InitFontList();
BOOL InitFontList()
    return ((BOOL)(i == numentries));
    BOOL MadeChange;
BOOL InitSpecial()
    BOOL status = TRUE;
BOOL FileRequest(BOOL);
BOOL FileRequest(mode)
BOOL mode;
    BOOL success;
	success = (BOOL)AslRequestTags(fr,
	success = (BOOL)AslRequestTags(fr,
    BOOLGADGET,		/* Type */
    BOOL status = FALSE;
    return ((BOOL)status);
 * ==	BOOL WritePalettePrefs(char *, struct ColorRegister *, LONG)	 == *
BOOL WriteFile(file, cmap, colors)
    BOOL status = FALSE;
    return ((BOOL)status);
 * ==	BOOL PutBMHD(struct IFFHandle *, struct BitMapHeader *,		 == *
BOOL PutBMHD(iff)
 * ==	BOOL PutColors(struct IFFHandle *, struct ColorRegister *, LONG) == *
BOOL PutColors(iff, cmap, colors)
extern BOOL changedprefs;
WORD ReadPalettePrefs(STRPTR name, BOOL Quiet);
BOOL WritePalettePrefs(STRPTR name);
BOOL terminated;
BOOL CreatePrefsGadgets(UWORD topborder, void *vi, UBYTE depth);
    BOOL setrgb);
WORD ReadPalettePrefs(STRPTR name, BOOL Quiet);
BOOL WritePalettePrefs(STRPTR name);
BOOL changedprefs = FALSE;
BOOL SaveIcon = TRUE;
    BOOL modified;
 * Returns:  (BOOL) success = TRUE
BOOL CreatePrefsGadgets(topborder, vi, depth)
    return((BOOL)(gad != NULL));
 * Returns:  (BOOL) TRUE if the action was a terminating action.
    BOOL setcolors;
    BOOL updategadgetry = FALSE;
    BOOL setrgb;
WORD ReadPalettePrefs(STRPTR name, BOOL Quiet);
BOOL WritePalettePrefs(STRPTR name);
WORD ReadData(STRPTR name, struct ColorRegister *cmap, BOOL Quiet);
BOOL WriteData(STRPTR name, struct ColorRegister *cmap);
BOOL PutBMHD(struct IFFHandle *iff);
BOOL PutColors(struct IFFHandle *iff, struct ColorRegister *cmap,
BOOL PutBody(struct IFFHandle *iff);
BOOL Quiet;
BOOL WritePalettePrefs(name)
BOOL Quiet;
BOOL WriteData(name, cmap)
 * ==	BOOL PutBMHD(struct IFFHandle *, struct BitMapHeader *,		 == *
BOOL PutBMHD(iff)
 * ==	BOOL PutColors(struct IFFHandle *, struct ColorRegister *, LONG) == *
BOOL PutColors(iff, cmap, colors)
BOOL PutBody(iff)
void FileError(BOOL, UBYTE *);
WORD ReadData(char *, char *, BOOL);
 * ==	WORD ReadData(char *, char *, BOOL)				 == *
BOOL Quiet;
    BOOL HeaderFlag = FALSE;
    BOOL DataFlag = FALSE;
BOOL InitGadgets(window)
BOOL GadgetPick(imsg)
extern BOOL InitGadgets();
extern BOOL InitSpecial();
extern BOOL InitMenus();
BOOL PModified = FALSE;
BOOL SaveIcon = TRUE;
BOOL InitSpecial()
    BOOLGADGET,		/* Type */
extern BOOL FileRequest();
extern BOOL SaveIcon;
BOOL menuattached = FALSE;
BOOL InitMenus(win)
BOOL FileRequest(BOOL);
BOOL FileRequest(mode)
BOOL mode;
    BOOL success;
	success = (BOOL)AslRequestTags(fr,
	success = (BOOL)AslRequestTags(fr,
BOOL Plane1Better[] =
    BOOLGADGET,		/* Type */
BOOL ReadWBPat(struct BitMap *bm, UBYTE *name);
BOOL Plane1Better[NUMPRESETS] =
    printf("BOOL Plane1Better[] =\n");
BOOL ReadWBPat(bm, name)
    BOOL ok;
BOOL Plane1Better[] =
WORD ReadWBPatternPrefs(STRPTR place, ULONG whichpattern, BOOL Quiet);
BOOL WriteWBPatternPrefs(STRPTR place, ULONG whichpattern);
BOOL CreatePrefsGadgets(struct Window *win, void *vi, UWORD topborder);
BOOL forgetundo = TRUE;
BOOL forgetundo_win = TRUE;
BOOL forgetundo_bdrop = TRUE;
BOOL SaveIcon = TRUE;
 * Returns:  (BOOL) success = TRUE
BOOL CreatePrefsGadgets(win, vi, topborder)
	    gad->GadgetType |= BOOLGADGET;
    return((BOOL)(gad != NULL));
    BOOL terminated = FALSE;
    BOOL patternchanged = FALSE;
WORD ReadWBPatternPrefs(STRPTR place, ULONG whichpattern, BOOL Quiet);
BOOL WriteWBPatternPrefs(STRPTR place, ULONG whichpattern);
WORD ReadPattern(STRPTR place, ULONG whichpattern, BOOL Quiet);
BOOL WritePattern(STRPTR place, ULONG whichpattern);
BOOL DiskWritePattern(struct BitMap *bm, UBYTE *name);
BOOL Quiet;
BOOL Quiet;
    BOOL window = (whichpattern == WIN_PATTERN);
    BOOL ok;
BOOL WriteWBPatternPrefs(place, whichpattern)
    BOOL success = TRUE;
BOOL WritePattern(place, whichpattern)
    BOOL window = (whichpattern == WIN_PATTERN);
    BOOL ok;
WORD ReadWBPatternPrefs(STRPTR place, ULONG whichpattern, BOOL Quiet);
BOOL WriteWBPatternPrefs(STRPTR place, ULONG whichpattern);
extern BOOL Plane1Better[];
BOOL terminated;
    BOOL preset_bak = FALSE, preset_win = FALSE;
void FileError(BOOL, UBYTE *);
WORD ReadData(char *, char *, BOOL);
 * ==	WORD ReadData(char *, char *, BOOL)				 == *
BOOL Quiet;
    BOOL HeaderFlag = FALSE;
    BOOL DataFlag = FALSE;
BOOL InitGadgets(window)
      GTCB_Checked, (BOOL)(EnvWrk.ip_MetaDrag & IEQUALIFIER_LSHIFT),
      GTCB_Checked, (BOOL)(EnvWrk.ip_MetaDrag & IEQUALIFIER_CONTROL),
      GTCB_Checked, (BOOL)(EnvWrk.ip_MetaDrag & IEQUALIFIER_LALT),
      GTCB_Checked, (BOOL)(EnvWrk.ip_MetaDrag & IEQUALIFIER_LCOMMAND),
      GTCB_Checked, (BOOL)(EnvWrk.ip_ICFlags & IC_COERCE_LACE),
      GTCB_Checked, (BOOL)(EnvWrk.ip_ICFlags & IC_COERCE_COLORS),
      GTCB_Checked, (BOOL)(EnvWrk.ip_ICFlags & IC_DOMAGICMENU),
      GTCB_Checked, (BOOL)(EnvWrk.ip_ICFlags & IC_STRINGG_CTRL),
      (BOOL)(EnvWrk.ip_MetaDrag & IEQUALIFIER_LSHIFT), TAG_DONE);
      (BOOL)(EnvWrk.ip_MetaDrag & IEQUALIFIER_CONTROL), TAG_DONE);
      (BOOL)(EnvWrk.ip_MetaDrag & IEQUALIFIER_LALT), TAG_DONE);
      (BOOL)(EnvWrk.ip_MetaDrag & IEQUALIFIER_LCOMMAND), TAG_DONE);
      GTCB_Checked, (BOOL)(EnvWrk.ip_ICFlags & IC_COERCE_LACE),
      GTCB_Checked, (BOOL)(EnvWrk.ip_ICFlags & IC_COERCE_COLORS),
      GTCB_Checked, (BOOL)(EnvWrk.ip_ICFlags & IC_DOMAGICMENU),
      GTCB_Checked, (BOOL)(EnvWrk.ip_ICFlags & IC_STRINGG_CTRL),
BOOL GadgetPick(imsg)
	      (BOOL)(EnvWrk.ip_MetaDrag & IEQUALIFIER_LSHIFT), TAG_DONE);
	      (BOOL)(EnvWrk.ip_MetaDrag & IEQUALIFIER_CONTROL), TAG_DONE);
	      (BOOL)(EnvWrk.ip_MetaDrag & IEQUALIFIER_LALT), TAG_DONE);
	      (BOOL)(EnvWrk.ip_MetaDrag & IEQUALIFIER_LCOMMAND), TAG_DONE);
    BOOLGADGET,		/* Type */
extern BOOL InitGadgets();
extern BOOL InitSpecial();
extern BOOL InitMenus();
BOOL PModified = FALSE;
BOOL SaveIcon = TRUE;
extern BOOL FileRequest();
extern BOOL SaveIcon;
BOOL menuattached = FALSE;
BOOL InitMenus(win)
BOOL FileRequest(BOOL);
BOOL FileRequest(mode)
BOOL mode;
    BOOL success;
	success = (BOOL)AslRequestTags(fr,
	success = (BOOL)AslRequestTags(fr,
BOOL InitSpecial()
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,			/* Change Serial		*/
	BOOLGADGET,                     /* Graphics Mode 0              */
	BOOLGADGET,                     /* Graphics Mode 1              */
	BOOLGADGET,                     /* Graphics Mode 2              */
	BOOLGADGET,                     /* Graphics Mode 3              */
	BOOLGADGET,                     /* Graphics Mode 4              */
	BOOLGADGET,                     /* Graphics Mode 5              */
	BOOLGADGET,                     /* Graphics Mode 6              */
	BOOLGADGET,                     /* Graphics Mode 7              */
	BOOLGADGET,			/* Change Serial		*/
	BOOLGADGET,			/* WB_LACE_ON			*/
	BOOLGADGET,			/* WB_LACE_OFF			*/
	BOOLGADGET,			/* Change Serial		*/
	BOOLGADGET,			/* Mouse acelerate		*/
	BOOLGADGET,			/* A2024 Off			*/
	BOOLGADGET,			/* A2024 10Hz			*/
	BOOLGADGET,			/* A2024 15Hz			*/
	BOOLGADGET,			/* Screen Drag Free		*/
	BOOLGADGET,			/* Screen Drag Normal		*/
	BOOLGADGET,			/* WB Depth 1			*/
	BOOLGADGET,			/* WB Depth 2			*/
	BOOLGADGET,			/* WB Interlace On		*/
	BOOLGADGET,			/* WB Interlace Off		*/
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,			/* Graphic 1			*/
	BOOLGADGET,			/* Arrow up			*/
	BOOLGADGET,			/* Arrow dowm			*/
	BOOLGADGET,			/* P_SERIAL			*/
	BOOLGADGET,			/* P_PARALLEL			*/
	BOOLGADGET,			/* Graphic 2			*/
	BOOLGADGET,			/* P2_CANCEL			*/
	BOOLGADGET,			/* P2_OK			*/
	BOOLGADGET,			/* P2_POSATIVE			*/
	BOOLGADGET,			/* P2_NEGATIVE			*/
	BOOLGADGET,			/* P2_HORIZONTAL		*/
	BOOLGADGET,			/* P2_VERTICAL			*/
	BOOLGADGET,			/* P2_BW			*/
	BOOLGADGET,			/* P2_GRAY_SCALE		*/
	BOOLGADGET,			/* COLOR			*/
	BOOLGADGET,			/* P2_GRAY_SCALE2		*/
        BOOLGADGET,                      /* E_CANCEL                     */  
        BOOLGADGET,                   /* e_ok                         */  
        BOOLGADGET,                   /* e_colour17                   */
        BOOLGADGET,                   /* e_colour18                   */  
        BOOLGADGET,                   /* e_colour19                   */  
        BOOLGADGET,                   /* e_edit                       */  
        BOOLGADGET,                   /* e_hotspot                    */  
        BOOLGADGET,                   /* e_delete                     */  
        BOOLGADGET,                   /* e_clear                      */
	BOOLGADGET,		      /* e_trans		      */
	BOOLGADGET,		      /* e_r_colour		      */
	BOOLGADGET,			/* S_baud_up			*/
	BOOLGADGET,			/* S_baud_down			*/
	BOOLGADGET,			/* S_buf_up			*/
	BOOLGADGET,			/* S_buf_down			*/
	BOOLGADGET,			/* S_Rb7			*/
	BOOLGADGET,			/* S_Rb8			*/
	BOOLGADGET,			/* S_Wb7			*/
	BOOLGADGET,			/* S_Wb8			*/
	BOOLGADGET,			/* S_Sb1			*/
	BOOLGADGET,			/* S_Sb2			*/
	BOOLGADGET,			/* S-Pnone			*/
	BOOLGADGET,			/* S_Peven			*/
	BOOLGADGET,			/* S_Podd			*/
	BOOLGADGET,			/* S_Hxon			*/
	BOOLGADGET,			/* S_Hrts			*/
	BOOLGADGET,			/* S_Hnone			*/
	BOOLGADGET,			/* S_OK 			*/
	BOOLGADGET,			/* S_Cancel 			*/
	BOOLGADGET,			/* P3_OK: OK			*/
	BOOLGADGET,			/* P3_CANCEL: Cancel		*/
	BOOLGADGET,			/* P3_ANTI_ON: Antialias ON	*/
	BOOLGADGET,			/* P3_ANTI_OFF: Antialias OFF	*/
	BOOLGADGET,			/* P3_CENTER_ON: Center ON	*/
	BOOLGADGET,			/* P3_CENTER_OFF: Center OFF	*/
	BOOLGADGET,			/* P3_DENSITY_1: Density 1	*/
	BOOLGADGET,			/* P3_DENSITY_2: Density 2	*/
	BOOLGADGET,			/* P3_DENSITY_3: Density 3	*/
	BOOLGADGET,			/* P3_DENSITY_4: Density 4	*/
	BOOLGADGET,			/* P3_DENSITY_5: Density 5	*/
	BOOLGADGET,			/* P3_DENSITY_6: Density 6	*/
	BOOLGADGET,			/* P3_DENSITY_7: Density 7	*/
	BOOLGADGET,			/* P3_COLOR_R: Color Red	*/
	BOOLGADGET,			/* P3_COLOR_G: Color Green	*/
	BOOLGADGET,			/* P3_COLOR_B: Color Blue	*/
	BOOLGADGET,			/* P3_ORDERED: Ordered Dither	*/
	BOOLGADGET,			/* P3_HALFTONE: Halftone Dither	*/
	BOOLGADGET,			/* P3_FS: Floyed Steinburg Dith */
	BOOLGADGET,			/* P3_FRACTION: Fraction Scaling*/
	BOOLGADGET,			/* P3_INTEGER: Integer Scaling	*/
	BOOLGADGET,			/* P3_IGNORE: Ignore Limit	*/
	BOOLGADGET,			/* P3_BOUNDED: Bounded Limit	*/
	BOOLGADGET,			/* P3_ABSOLUTE: Absolute Limit	*/
	BOOLGADGET,			/* P3_PIXELS: Pixels Limit	*/
	BOOLGADGET,			/* P3_MULTIPLY: Multiply Limit  */
extern	UWORD	Types[];		/* gadget types (BOOLGADGET etc.)*/
    BOOL TellIntuition = TRUE;
    BOOL freshen = FALSE;
    BOOL MadeChange;
    BOOL FinishedFreeing;
    BOOL point = FALSE;
BOOL RTC;
BOOL RealTimeClock;	/* Set RTC? */
BOOL file_request_used = FALSE;
void HandleEvent(ULONG Class,USHORT Code,APTR IAddress,BOOL Callback)
BOOL WBConfigSemaphoreOwn=FALSE;  /* If TRUE, current instance of WBConfig owns
BOOL NewPath=FALSE;     /* TRUE if "Add" function activated */
BOOL NotSaved=FALSE;
BOOL SaveIcons=DEFAULT_SAVE_ICONS;
BOOL DoEasyRequest(struct Window *w,struct EasyStruct *es,ULONG *ip,APTR arg1)
	return((BOOL) (EasyRequestArgs(w,es,ip,&arg1)));
BOOL WBConfigParseCLI(int argc,char *argv[])
BOOL WBConfigParseWB(struct WBStartup *WBStartup)
BOOL WBConfigNotSavedError()
BOOL WBConfigSemaphoreOwn=FALSE;  /* If TRUE, current instance of WBConfig owns
BOOL NewPath=FALSE;     /* TRUE if "Add" function activated */
BOOL NotSaved=FALSE;
BOOL SaveIcons=DEFAULT_SAVE_ICONS;
BOOL WBConfigIsOpen()
BOOL WBConfigSemObtain()
BOOL WBConfigSemRelease()
BOOL WBConfigGetDefault()
BOOL WBConfigLoadIFF(UBYTE *name)
    BOOL status = FALSE;
    BOOL HeaderFlag = FALSE;
    BOOL DataFlag = FALSE;
    return((BOOL)status);
BOOL WBConfigLoadFile(UBYTE *Filename)
    BOOL Status;
BOOL WBConfigSaveIFF(UBYTE *Filename)
    BOOL status = FALSE;
BOOL WBConfigSaveFile(UBYTE *Filename)
    BOOL Status;
        DiskObject.do_Gadget.GadgetType=BOOLGADGET;
BOOL DoEasyRequest(struct Window *w,struct EasyStruct *es,ULONG *ip,APTR arg1)
	return((BOOL) (EasyRequestArgs(w,es,ip,&arg1)));
BOOL WBConfigParseCLI(int argc,char *argv[])
    BOOL ActionSet=FALSE;
BOOL WBConfigParseWB(struct WBStartup *WBStartup)
BOOL WBConfigNotSavedError()
BOOL WBConfigIsOpen()
BOOL WBConfigSemObtain()
BOOL WBConfigSemRelease()
BOOL WBConfigGetDefault()
BOOL WBConfigLoadIFF(UBYTE *name)
    BOOL status = FALSE;
    BOOL HeaderFlag = FALSE;
    BOOL DataFlag = FALSE;
    return((BOOL)status);
BOOL WBConfigSaveIFF(UBYTE *Filename)
    BOOL status = FALSE;
BOOL WBConfigSaveIcon(UBYTE *Filename)
            BOOLGADGET, /* GadgetType */
    BOOL Status;
    BOOL intuition = FALSE;
BOOL AllocBMRasters (struct BitMap * bm, UBYTE depth)
BOOL CreateIconGadgets (struct Window * win)
	    w->img1->GadgetType |= BOOLGADGET;
	    w->img2->GadgetType |= BOOLGADGET;
    {BOOLMASK, ArrowUp, 0},
    {BOOLMASK, ArrowRight, 0},
    {BOOLMASK, ArrowDown, 0},
    {BOOLMASK, ArrowLeft, 0}
    {NULL, 19, 0, 27, 13, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    {&MGad[0], 42, 12, 23, 11, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    {&MGad[1], 19, 22, 27, 13, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    {&MGad[2], 0, 12, 23, 11, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL}
	MGad[i].Activation = GADGIMMEDIATE | RELVERIFY | BOOLEXTEND;
static BOOL SPOpenBitMap (struct SketchPad * sp);
	    sp->Gad.GadgetType = BOOLGADGET;
static BOOL SPOpenBitMap (struct SketchPad * sp)
    BOOL going = TRUE, mouse = FALSE, abort = FALSE;
		     struct RastPort *, BOOL);
    BOOL makeShadow;		/* create new shadow? */
LoadIFFBrush (UBYTE * iffname, struct DynamicImage * di, BOOL show_errs)
BOOL
    BOOL ret = FALSE;
	  BOOLGADGET,			/* Gadget Type */
BOOL IconToC (STRPTR name, STRPTR oname, struct DiskObject * dob, BOOL icon);
struct DiskObject *LoadIcon (UBYTE * name, BOOL real)
BOOL
    BOOL retval = FALSE;
	BOOL chop;
    REQGADGET | BOOLGADGET,		/* Type */
    REQGADGET | BOOLGADGET,		/* Type */
BOOL myFileRequester(struct Window * win, BOOL mode, UBYTE * filename)
    BOOL end;
BOOL SaveAsCFunc (struct Window * win);
BOOL TemplateFunc (struct Window * win);
BOOL RemapFunc (struct Window * win);
BOOL TopLeftFunc (struct Window * win);
BOOL PaletteFunc (struct Window * win);
BOOL CreateIconMenus (struct Window * win)
    BOOL wipe = TRUE;
BOOL HandleMenuEvent (struct Window * win, UWORD code)
    BOOL terminated = FALSE;
	    BOOL (*fptr) (struct Window *) = MENU_USERDATA (item);
	    BOOL (*fptr) (struct Window *) = MENU_USERDATA (item);
	    BOOL (*fptr) (struct Window *) = MENU_USERDATA (item);
	    BOOL (*fptr) (struct Window *) = MENU_USERDATA (item);
BOOL NewFunc (struct Window * win)
    BOOL cancel = FALSE;
VOID OpenNamedIcon (struct Window * win, UBYTE * name, BOOL real)
BOOL OpenFunc (struct Window * win)
    BOOL cancel = FALSE;
BOOL SaveFunc (struct Window * win)
BOOL SaveAsFunc (struct Window * win)
BOOL SaveDefFunc (struct Window * win)
BOOL QuitFunc (struct Window * win)
BOOL ExchangeFunc (struct Window * win)
BOOL CopyFunc (struct Window * win)
BOOL LStdFunc (struct Window * win)
BOOL LAltFunc (struct Window * win)
BOOL LBthFunc (struct Window * win)
BOOL LoadIFFImage (struct Window * win, UBYTE * name, USHORT cur, BOOL errs)
BOOL LIFFFunc (struct Window * win)
BOOL SStdFunc (struct Window * win)
BOOL SIFFFunc (struct Window * win)
BOOL RestoreFunc (struct Window * win)
BOOL CheckForChanges (struct Window * win, UBYTE * opt)
    BOOL cancel = FALSE;
BOOL ScaleImage (ILBM * ir, struct BitMap * bm)
BOOL LoadIFFBrush (UBYTE * iffname, struct DynamicImage * di, BOOL show_errs)
    BOOL retval = FALSE;
BOOL
    BOOL retval = FALSE;
BOOL SaveAsCFunc (struct Window * win)
BOOL TemplateFunc (struct Window * win)
BOOL RemapFunc (struct Window * win)
BOOL TopLeftFunc (struct Window * win)
BOOL PaletteFunc (struct Window * win)
BOOL IPutDefDiskObject (struct DiskObject *);
*	BOOL PutDefDiskObject(struct DiskObject *);
BOOL
    BOOL ret_val = FALSE;
    {NULL, 0, 0, 0, 0, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    {&TBox[0], 0, 0, 0, 0, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    {&TBox[1], 0, 0, 0, 0, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    {&TBox[2], 0, 0, 0, 0, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    {&TBox[3], 0, 0, 0, 0, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    {&TBox[4], 0, 0, 0, 0, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    {&TBox[5], 0, 0, 0, 0, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    {&TBox[6], 0, 0, 0, 0, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL}
    {NULL,     0, 0, 0, 0, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    {&TBox[0], 0, 0, 0, 0, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    {&TBox[1], 0, 0, 0, 0, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    {&TBox[2], 0, 0, 0, 0, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    {&TBox[3], 0, 0, 0, 0, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    {&TBox[4], 0, 0, 0, 0, NULL, NULL, BOOLGADGET, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
static VOID RedoBevelBox (struct Image * im, VOID * vi, BOOL dir)
BOOL PutDefDiskObject (struct DiskObject *);
BOOL PutDefDiskObject (struct DiskObject * dob)
    BOOL ret_val = FALSE;
	  BOOLGADGET,			/* Gadget Type */
	  BOOLGADGET,			/* Gadget Type */
	  BOOLGADGET,			/* Gadget Type */
	  BOOLGADGET,			/* Gadget Type */
	  BOOLGADGET,			/* Gadget Type */
	BOOLGADGET,		/* Gadget Type */
	BOOLGADGET,		/* Gadget Type */
	BOOLGADGET,		/* Gadget Type */
	BOOLGADGET,		/* Gadget Type */
	BOOLGADGET,		/* Gadget Type */
BOOL IconToC (STRPTR name, STRPTR oname, struct DiskObject * dob, BOOL icon);
BOOL IconToC (STRPTR iname, STRPTR oname, struct DiskObject * dob, BOOL icon)
    BOOL retval = FALSE;
	BOOLGADGET,		/* Gadget Type */
    {0x00002000, "BOOLEXTEND"},
	fprint (fh, "	BOOLGADGET,		/* Gadget Type */\n", (LONG) g->GadgetType);
BOOL WriteILBM (BPTR drawer, STRPTR name, ILBM *ir, BOOL);
BOOL GetBMHD (struct IFFHandle * iff, struct BitMapHeader * bmhd);
BOOL PutBMHD (struct IFFHandle * iff, struct BitMapHeader * bmhd, ILBM *ir);
BOOL PutILBM (struct IFFHandle * iff, ILBM * ilbm);
BOOL PutColors (struct IFFHandle * iff, struct BitMapHeader * bmhd, struct ColorRegister * cmap);
BOOL PutHotSpot (struct IFFHandle * iff, struct Point2D * grab);
BOOL GetBody (struct IFFHandle * iff, struct BitMapHeader * bmhd, struct BitMap * bm);
BOOL GetLine (struct IFFHandle * iff, UBYTE * buf, WORD wide, WORD deep, UBYTE cmptype);
BOOL PutBody (struct IFFHandle * iff, struct BitMapHeader * bmhd, struct BitMap * bitmap);
BOOL AllocBMRast (struct BitMap * bm, BYTE depth, WORD width, WORD height);
BOOL WriteILBM (BPTR drawer, STRPTR name, ILBM *ir, BOOL icon)
    BOOL retval = FALSE;
BOOL PutILBM (struct IFFHandle * iff, ILBM * ilbm)
    BOOL status = FALSE;
BOOL GetBMHD (struct IFFHandle *iff, struct BitMapHeader *bmhd)
BOOL PutBMHD (struct IFFHandle *iff, struct BitMapHeader *bmhd, ILBM *ir)
BOOL
BOOL PutHotSpot (struct IFFHandle *iff, struct Point2D *grab)
BOOL
    BOOL status = FALSE;
BOOL GetLine (iff, buf, wide, deep, cmptype)
BOOL PutBody (iff, bmhd, bitmap)
BOOL AllocBMRast (struct BitMap *bm, BYTE depth, WORD width, WORD height)
	BOOLGADGET,		/* Gadget Type */
BOOL AllocDynamicImage (struct DynamicImage *);
static BOOL DIAllocFill (struct DynamicImages *, USHORT, USHORT);
static BOOL DIAllocLayer (struct DynamicImage *, USHORT, USHORT);
BOOL AllocDynamicImage (struct DynamicImage * di)
static BOOL
static BOOL
    BOOL terminated = FALSE;
BOOL HandleIMessage (struct IntuiMessage * rmsg)
    BOOL terminated = FALSE;
    BOOL iconchanged = FALSE;
BOOL CopyClipFunc (struct Window * win)
BOOL CutClipFunc (struct Window * win)
BOOL PasteClipFunc (struct Window * win)
BOOL OpenClipFunc (struct Window * win)
BOOL SaveClipFunc (struct Window * win)
BOOL ShowClipFunc (struct Window * win)
BOOL InitSpecial();
extern BOOL AlWinExists;
BOOL DeepFlag;
 * ==	BOOL InitSpecial()						 == *
BOOL InitSpecial()
BOOL AlarmSet();
BOOL InitAlarmGads(struct Window *);
BOOL AlWinExists = FALSE;
BOOL AlarmSet()
BOOL InitAlarmGads(window)
extern BOOL DeepFlag;
void DrawAnalog(BOOL);
 * ==	void DrawAnalog(BOOL)						 == *
BOOL clear;
BOOL InitWindow();
BOOL ReOpenWindow(UBYTE);
 * ==	BOOL InitWindow()						 == *
BOOL InitWindow()
BOOL ReOpenWindow(type)
    return ((BOOL)InitMenus(window));
BOOL menuattached = FALSE;
 * ==	BOOL InitMenus(struct Window *)					 == *
BOOL InitMenus(win)
BOOL strEqu(TEXT *p, TEXT *q);
BOOL  Error1 = TRUE, Skip = FALSE, Multiple = FALSE, Notify = FALSE;
BOOL  Done = FALSE, FromWb = FALSE, MainBusy = FALSE;
   BOOL   Forbidden;
BOOL strEqu(TEXT *p, TEXT *q) 
   BOOL NeedFilename;
   BOOL   FromWb, FormFeed, Found, Sensitive, UnSeekable, CanEdit, SearchBreak;
BOOL search(struct More *);
BOOL  AslRequestTags( APTR request, ULONG tags, ...);
BOOL search(struct More *mo) 
BOOL AslRequestTags(request, tags)
BOOL UseMyWbCon = FALSE;
BOOL  FromWb;
BOOL  Print=FALSE, Timer=FALSE, Back=FALSE, Mouse = FALSE, Loop=FALSE;
BOOL  EHB=FALSE, Cycle=FALSE, Autoscroll=FALSE, Video=FALSE, Notransb=FALSE; 
BOOL  TimerOn = FALSE, CycleOn = FALSE, PrepareToDie = FALSE;
BOOL  FileList = FALSE;
    BOOL	active, Force=FALSE;
BOOL ttTrue(char **toolarray, UBYTE *keyword)
    BOOL   Cycled;
BOOL HaveText=FALSE, InQuotes=FALSE;
BOOL unpackrow(pSource, pDest, srcBytes0, dstBytes0)
    BOOL error = TRUE;	/* assume error until we make it through the loop */
	BOOL	cboard;
BOOL   VideoControlTags(struct ColorMap *,ULONG tags, ...);
    BOOL   vctl;
BOOL VideoControlTags(cm, tags)
extern BOOL  UseMyWbCon;
extern BOOL  far UseMyWbCon;
extern BOOL wgetscdata(struct Screen *);
   BOOL terminated=FALSE;
BOOL setupCustomCX()
BOOL setupMBA(void);
BOOL setupMBA()
   BOOL terminated=FALSE;
BOOL setupCustomCX()
BOOL setupAutopoint(VOID)
   BOOL terminated=FALSE;
BOOL setupCustomCX()
BOOL MakeIcon(char **newtooltypes);
BOOL AddToolNode(struct List *list,char *string,ULONG flags);
BOOL  Shifted;
BOOL  allocs = 0L;
BOOL MySetupCX()
BOOL MakeIcon(char **newtooltypes)
   BOOL success = FALSE;
         BOOLGADGET,
BOOL AddToolNode(struct List *list,char *string,ULONG flags)
   BOOL success=FALSE;
   BOOL terminated=FALSE;
BOOL setupCustomCX()
BOOL setupIHelp()
   BOOL terminated=FALSE;
BOOL setupCustomCX()
   BOOL terminated=FALSE;
BOOL setupCustomCX()
BOOL setupLeftyMouse(void);
BOOL setupLeftyMouse()
   BOOL terminated=FALSE;
BOOL setupCustomCX()
BOOL setupNoCapsLock(void);
BOOL setupNoCapsLock()
   BOOL terminated=FALSE;
BOOL setupCustomCX()
BOOL setupBlanker(void);
BOOL setupBlanker(VOID)
*        BOOL setupCX(char **ttypes);
BOOL setupCX(char **ttypes )
BOOL            menuattached = NULL;
BOOL            IDCMPRefresh = NULL;
   BOOL terminated=FALSE;
BOOL setupCustomCX()
BOOL MySetupCX()
BOOL setupDoubleClick(VOID)
BOOL setupCustomCX()
BOOL setupDoubleClick(VOID)
BOOL setupCustomCX()
   BOOL   FromWb, FormFeed;
BOOL oflag;
BOOL Init() /* initialization */
    BOOLGADGET, (APTR) & bRect, NULL, NULL, NULL, NULL, 0, NULL};
    GADGIMMEDIATE | RELVERIFY, BOOLGADGET, &db2, NULL, NULL, NULL,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
    BOOLGADGET,
static BOOL backit ( struct TreeNode *tn );
static BOOL interface( void );
static BOOL _trim_files ( struct TreeNode *tn );
static BOOL restore_it ( struct TreeNode *tn );
static BOOL diff_it ( struct TreeNode *tn );
static BOOL inspect_it ( struct TreeNode *tn );
BOOL filename_sent;
BOOL finished_flag;
BOOL tree_end_flag;
BOOL user_cancel_flag = FALSE;
BOOL need_to_embed_logfile = FALSE;
    BOOL rc;
static BOOL backit ( struct TreeNode *tn )
    BOOL flag = TRUE;
static BOOL interface( void )
static BOOL _trim_files ( struct TreeNode *tn )
    BOOL rc;
static BOOL restore_it ( struct TreeNode *tn )
    BOOL flag = TRUE;
	BOOL done = FALSE;
    BOOL rc;
static BOOL diff_it ( struct TreeNode *tn )
    BOOL flag = TRUE;
    BOOL rc;
static BOOL inspect_it ( struct TreeNode *tn )
    BOOL flag = TRUE;
typedef int BOOLEAN;
EXPORT BOOLEAN _db_on_ = FALSE;		/* TRUE if debugging currently on */
EXPORT BOOLEAN _db_pon_ = FALSE;	/* TRUE if debugging currently on */
LOCAL BOOLEAN init_done = FALSE;/* Set to TRUE when initialization done */
LOCAL BOOLEAN InList PROTO((struct link *, char *));
LOCAL BOOLEAN DoProfile PROTO((void));
LOCAL BOOLEAN DoTrace PROTO((void));
LOCAL BOOLEAN Writable PROTO((char *));
 *	LOCAL BOOLEAN InList (linkp, cp)
LOCAL BOOLEAN InList (linkp, cp)
    REGISTER BOOLEAN accept;
 *	LOCAL BOOLEAN DoTrace ()
LOCAL BOOLEAN DoTrace ()
    REGISTER BOOLEAN trace;
 *	LOCAL BOOLEAN DoProfile ()
LOCAL BOOLEAN DoProfile ()
    REGISTER BOOLEAN profile;
 *	BOOLEAN _db_keyword_ (keyword)
BOOLEAN _db_keyword_ (keyword)
    REGISTER BOOLEAN accept;
    REGISTER BOOLEAN newfile;
    REGISTER BOOLEAN newfile;
 *	LOCAL BOOLEAN Writable (pathname)
LOCAL BOOLEAN Writable (pathname)
    REGISTER BOOLEAN granted;
static BOOL screen_flag = TRUE;	/* default to custom screen */
BOOL auto_backup = FALSE;
BOOL auto_restore = FALSE;
BOOL auto_start = FALSE;
BOOL makeicon_flag = TRUE;
BOOL show_test_menu = FALSE;
BOOL embed_logfile = TRUE;
BOOL backup_the_dirs = TRUE;
	BOOL rv;
static BOOL _walk_files PROTO((struct TreeNode *));
static BOOL _walk_nodes PROTO((struct TreeNode *));
static BOOL _walk_entrys PROTO((struct TreeNode *));
static BOOL _find_filename PROTO((struct TreeEntry *));
static BOOL (*wf_func) PROTO((struct TreeEntry *));
static BOOL (*we_func) PROTO((struct TreeEntry *));
static BOOL (*wn_func) PROTO((struct TreeNode *));
			RemAlloc ((ULONG) (most_entrys * sizeof (BOOL)),
    BOOL finished = FALSE;
 *		BOOL myfunc (tn)
BOOL walk_files (tn, func)
BOOL (*func) ();
    BOOL rtnval;
static BOOL _walk_files (tn)
 *		BOOL myfunc (tn)
BOOL walk_entrys (tn, func, buffer)
BOOL (*func) ();
    BOOL rtnval;
static BOOL _walk_entrys (tn)
 *		BOOL myfunc (tn)
BOOL walk_nodes (tn, func, buffer)
BOOL (*func) ();
    BOOL rtnval;
static BOOL _walk_nodes (tn)
static BOOL _find_filename (te)
static BOOL finished = FALSE;
    REQGADGET | BOOLGADGET,	/* GadgetType */
    REQGADGET | BOOLGADGET,	/* GadgetType */
	REQGADGET | BOOLGADGET,		/* GadgetType */
	REQGADGET | BOOLGADGET,		/* GadgetType */
	REQGADGET | BOOLGADGET,		/* GadgetType */
	REQGADGET | BOOLGADGET,		/* GadgetType */
	REQGADGET | BOOLGADGET,		/* GadgetType */
	REQGADGET | BOOLGADGET,		/* GadgetType */
	REQGADGET | BOOLGADGET,		/* GadgetType */
	REQGADGET | BOOLGADGET,		/* GadgetType */
	REQGADGET | BOOLGADGET,		/* GadgetType */
	REQGADGET | BOOLGADGET,		/* GadgetType */
	REQGADGET | BOOLGADGET,		/* GadgetType */
	REQGADGET | BOOLGADGET,		/* GadgetType */
	REQGADGET | BOOLGADGET,		/* GadgetType */
	REQGADGET | BOOLGADGET,		/* GadgetType */
	REQGADGET | BOOLGADGET,		/* GadgetType */
	REQGADGET | BOOLGADGET,		/* GadgetType */
BOOL do_vol_req ( char *title, char *string )
    BOOL finished = FALSE;
    BOOL rc;
BOOL do_file_req ( char *title, char *string )
	BOOLGADGET,					/* GadgetType */
	BOOLGADGET,					/* GadgetType */
	BOOLGADGET,					/* GadgetType */
	BOOLGADGET,					/* GadgetType */
	BOOLGADGET,					/* GadgetType */
	BOOLGADGET,					/* GadgetType */
	BOOLGADGET,					/* GadgetType */
	BOOLGADGET,					/* GadgetType */
	BOOLGADGET,					/* GadgetType */
	BOOLGADGET,					/* GadgetType */
	BOOLGADGET,					/* GadgetType */
	BOOLGADGET,					/* GadgetType */
	BOOLGADGET,					/* GadgetType */
static BOOL is_leap ( int year );
static BOOL rangepointer = FALSE;
static BOOL is_leap ( int year )
BOOL MyMatchToolValue ( char *string, char *substring )
BOOL strequal ( char *s1, char *s2 )
    BOOL inparen = FALSE;
    BOOL inarg = FALSE;
BOOL kmstring_to_long( LONG *lp, char *string )
static void build_logname( BOOL forsave );
static BOOL icon_exists( char *fname );
static BOOL save_node ( struct TreeNode *tn );
static BOOL do_save ( struct TreeNode *tn );
ULONG logfile_size( BOOL scanflag )
	BOOL save_iconflag;
static void build_logname( BOOL forsave )
	BOOL exists;
static BOOL icon_exists( char *fname )
static BOOL do_save ( struct TreeNode *tn )
	BOOL rc;
static BOOL save_node ( struct TreeNode *tn )
    if ((entry_color = RemAlloc ((ULONG) (most_entrys * sizeof (BOOL)),
    REQGADGET | BOOLGADGET,	/* GadgetType */
    REQGADGET | BOOLGADGET,	/* GadgetType */
BOOL do_string_req (title, string)
    BOOL finished = FALSE;
    BOOL rc;
    BOOL finished = FALSE;
    REQGADGET | BOOLGADGET,	/* GadgetType */
BOOL check_cancel ()
    REQGADGET | BOOLGADGET,	/* GadgetType */
BOOL do_fdata_req (string)
    BOOL finished = FALSE;
extern BOOL IsRexxMsg PROTO((struct RexxMsg *));
static BOOL talk_to_bru( void );
static BOOL from_arexx;
static BOOL talk_to_bru( void )
static BOOL _do_include PROTO((struct TreeEntry *));
static BOOL _do_exclude PROTO((struct TreeEntry *));
static BOOL do_the_sort PROTO((struct TreeNode *));
static BOOL totalize_files PROTO((struct TreeEntry *));
static BOOL totalize_nodes PROTO((struct TreeNode *));
static BOOL by_size PROTO((struct TreeEntry *));
static BOOL by_date PROTO((struct TreeEntry *));
static BOOL by_pattern PROTO((struct TreeEntry *));
static BOOL by_arc PROTO((struct TreeEntry *));
static BOOL _shadow PROTO((struct TreeEntry *));
static BOOL _un_shadow PROTO((struct TreeEntry *));
static BOOL _clear_backed PROTO((struct TreeEntry *));
static BOOL _select_all PROTO((struct TreeEntry *));
static BOOL _select_none PROTO((struct TreeEntry *));
static BOOL do_the_sort (tn)
static BOOL totalize_nodes (tn)
static BOOL totalize_files (te)
static BOOL _select_all (te)
static BOOL _select_none (te)
static BOOL _do_include (te)
static BOOL _do_exclude (te)
BOOL want_file (te)
    BOOL rtnval;
static BOOL by_size (te)
static BOOL by_date (te)
static BOOL by_pattern (te)
static BOOL by_arc (te)
static BOOL _shadow (te)
static BOOL _un_shadow (te)
static BOOL _clear_backed (te)
static BOOL slist_flag = FALSE;
    BOOLGADGET,			/* GadgetType */
    BOOL finished = FALSE;
BOOL mode;
	BOOLGADGET,		/* GadgetType */
	                        BOOLGADGET,/* GadgetType */
BOOL is_rexxmsg();
static BOOL is_rexxmsg( rexxmsg )
static BOOL do_list PROTO((char *, char *));
static BOOL iswild PROTO((char *, char *));
 *	BOOL wild (string, pattern)
BOOL wild (string, pattern)
    register BOOL match;
 *	static BOOL iswild (string, pattern)
static BOOL iswild (string, pattern)
    register BOOL match;
 *	static BOOL do_list (string, pattern)
static BOOL do_list (string, pattern)
    register BOOL match;
    register BOOL if_found;
    register BOOL if_not_found;
BOOL is_bru_message( struct BruMessage *brumsg )
static BOOL finished = FALSE;
    BOOLGADGET,		/* GadgetType */
    BOOLGADGET,		/* GadgetType */
	BOOL done = FALSE;
	BOOL pushflag = TRUE;
BOOL mult = FALSE;
    BOOLGADGET,		/* GadgetType */
    BOOLGADGET,		/* GadgetType */
    BOOLGADGET,		/* GadgetType */
    BOOLGADGET,		/* GadgetType */
    BOOLGADGET,		/* GadgetType */
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
      BOOLGADGET,
BOOL   FromWb = FALSE;
   BOOL StartUp = TRUE;
BOOL CBCheckSatisfy(long *);
    BOOL odd = (slen & 1); /* pad byte flag */
BOOL CBCheckSatisfy(idVar)
	REQGADGET|BOOLGADGET,	/* gadget type */
	REQGADGET|BOOLGADGET,	/* gadget type */
        REQGADGET|BOOLGADGET,   /* gadget type */
        REQGADGET|BOOLGADGET,   /* gadget type */
        REQGADGET|BOOLGADGET,   /* gadget type */
        BOOLGADGET,     /* GadgetType */
        BOOLGADGET,     /* GadgetType */
        BOOLGADGET,     /* GadgetType */
        BOOLGADGET,     /* GadgetType */
	BOOLGADGET,	/* gadget type */
BOOL  FromWb;
   RELVERIFY, BOOLGADGET, (APTR)&txtBor, 0,
   RELVERIFY, BOOLGADGET, (APTR)&txtBor, 0,
   RELVERIFY, BOOLGADGET, (APTR)&txtBor, 0,
BOOL Done;
      gad->GadgetType = BOOLGADGET;
BOOL UseMyWbCon = FALSE;
    BOOL   Done = FALSE, HaveSome = FALSE, Insert;
extern BOOL  UseMyWbCon;
extern BOOL  far UseMyWbCon;
extern BOOL wgetscdata(struct Screen *);
BOOL scanDeviceList(name,task)
BOOL flag=FALSE;
extern BOOL NoIcons,QuickFlag;
BOOL CLIflag;
    BOOL read;
    BOOL inhibitOk = FALSE;
    BOOL openOk = FALSE;
BOOL CreateTrashCan()
   BOOL success = FALSE;
    trashObj.do_Gadget.GadgetType = BOOLGADGET;
extern BOOL scanDeviceList();
BOOL NoIcons;		/* don''t write any files to disk */
BOOL QuickFlag;		/* format every cylinder */
BOOL CLIflag;
extern BOOL Break();
extern BOOL WaitUser();
extern BOOL CompareTrack();
BOOL fromInhibit = FALSE;
BOOL toInhibit = FALSE;
BOOL OneDisk = FALSE;
BOOL DiskFinished = FALSE;
BOOL VerifyFlag = TRUE; /* assume they will be reasonable */
    BOOL wflag;
    BOOL flag=TRUE;
BOOL Break()
BOOL WaitUser(clitext,reqtext)
	return((BOOL)!Break());
    BOOL dflag=FALSE;
BOOL CompareTrack(index)
BOOL disk,dflag;
BOOL flag=FALSE;
extern BOOL bMValid;
BOOL ConvToNum(STRPTR hexString, ULONG *value, APTR UtilityBase);
BOOL		   error;
BOOL InitMonitor(MonitorSpecPtr mspc, LONG num, STRPTR name, ULONG *opts, LONG *optsX, GfxBasePtr GfxBase)
BOOL ConvToNum(STRPTR hexString, ULONG *value, APTR UtilityBase)
BOOL ConvToNum(STRPTR hexString, ULONG *value, APTR UtilityBase);
BOOL ConvToNum(STRPTR hexString, ULONG *value, APTR UtilityBase)
BOOL ModifyActive;
    BOOLGADGET, &DrawerImage,	/* GadgetType, GadgetRender */
    BOOLGADGET, &DrawerImage,	/* GadgetType, GadgetRender */
    GADGIMMEDIATE, BOOLGADGET,	/* Activation, GadgetType */
BOOL gtFlag;
BOOL MValidateSize(required, actionIndex)
BOOL required;
extern BOOL ModifyActive;
BOOL ValidateOnly = FALSE;
extern BOOL ValidateOnly;
AddFontsEntry(BPTR lock, BOOL fontsFlag)
BOOL CreateDiskFont(se)
BOOL LIBInfo(libDir, libList, huntLimit)
    return((BOOL) foundLibFlag);
BOOL FAISInfo(faisDir)
    return((BOOL) foundFAISFlag);
extern BOOL ModifyActive;
BOOL FontMatch(char *path1, char *name1, char *path2, char *name2)
BOOL faisRead(struct FaisLocals *fl, void *data, int length, BOOL equ, FILE *f)
BOOL faisWrite(struct FaisLocals *fl, void *data, int length)
         DC.W  BOOLGADGET
         DC.W  BOOLGADGET
         DC.W  BOOLGADGET
         DC.W  BOOLGADGET
         DC.W  BOOLGADGET
         DC.W  BOOLGADGET
         DC.W  BOOLGADGET
         DC.W  BOOLGADGET
         DC.W  BOOLGADGET
         DC.W  BOOLGADGET
		DC.W	BOOLGADGET		* gadget type
		DC.W	BOOLGADGET
		DC.W	BOOLGADGET		* gadget type
		DC.W	BOOLGADGET
		DC.W	BOOLGADGET		* gadget type
		DC.W	BOOLGADGET
		DC.W	BOOLGADGET		* gadget type
		DC.W	BOOLGADGET
		DC.W	BOOLGADGET		* gadget type
		DC.W	BOOLGADGET
		DC.W	BOOLGADGET		* gadget type
		DC.W	BOOLGADGET
		DC.W  BOOLGADGET
		DC.W  BOOLGADGET
		DC.W  BOOLGADGET
		DC.W  BOOLGADGET
		DC.W  BOOLGADGET
		DC.W  BOOLGADGET
		DC.W  BOOLGADGET
		DC.W	REQGADGET!BOOLGADGET	type
		DC.W	REQGADGET!BOOLGADGET	type
		DC.W	REQGADGET!BOOLGADGET	type
		DC.W	REQGADGET!BOOLGADGET	type
		DC.W	REQGADGET!BOOLGADGET	type
                DC.W    REQGADGET!BOOLGADGET    type
                DC.W    REQGADGET!BOOLGADGET    type
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET+REQGADGET,
	BOOLGADGET+REQGADGET,
	BOOLGADGET+REQGADGET,
	BOOLGADGET+REQGADGET,
	BOOLGADGET+REQGADGET,
	BOOLGADGET+REQGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET+REQGADGET,
	BOOLGADGET+REQGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET+REQGADGET,
	BOOLGADGET+REQGADGET,
	BOOLGADGET+REQGADGET,
	BOOLGADGET,	/* gadget type flags */
	BOOLGADGET,
	BOOLGADGET,
	BOOLGADGET+REQGADGET,
	BOOLGADGET+REQGADGET,
BOOL   isfloppy(BSTR);
BOOL   isRAD(struct FileSysStartupMsg *fssm);
BOOL   MatchBSTR(BSTR bp,char *s);
BOOL isRAD(struct FileSysStartupMsg *fssm)
BOOL isfloppy(bp)
BOOL MatchBSTR(BSTR bp,char *s)
extern BOOL ToAmiga;
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    BOOLGADGET,				/* gadget type */
    GZZGADGET | BOOLGADGET,		/* gadget type */
    GZZGADGET | BOOLGADGET,		/* gadget type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
BOOL ToAmiga = TRUE;
    BOOL selecting, running, copying;
    BOOL lastBlock;
    BOOL crlfFlag;
    BOOL response;
extern BOOL ToAmiga;
BOOL GadgetsOn = FALSE;
BOOL Mounted = FALSE;
BOOL FATDirty = FALSE;
    BOOL root, startSuffix;
BOOL onOff;
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    GADGIMMEDIATE, BOOLGADGET,		/* gadget activation & type */
    BOOL selecting, running, doneOK;
BOOL Mounted = TRUE;
BOOL prevLow;
extern BOOL Mounted;
    BOOL dirtyTrack;
