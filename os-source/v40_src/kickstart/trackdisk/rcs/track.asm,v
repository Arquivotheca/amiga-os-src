head     32.13;
branch   ;
access   ;
symbols  V36_21:32.10 V36_20:32.10 V36_19:32.8 V36_18:32.7 V36_16:32.6 V36_15:32.6 V36_14:32.6 V36_13:32.6 V36_10:32.5 V36_9:32.4 V36_6:32.4 V36_5:32.4 V36_4:32.4 L36_2:32.1 L33_127:32.1 L33_126:32.1 L33_124:32.1 L33_120:32.1 L33_119:32.1 L33_116:32.1 L33_113:32.1 L33_106:32.1 L32_98:32.1 L31_87:32.1 L31_57:30.2 L31_56:30.2 L1_55:30.2 L1_54:30.2 L1_51:30.1 L1_47:27.1 L1_45:27.1 L1_44:27.1 L29_44:27.1 L29_42:27.1 L28_37:27.1 L28_35:27.1 L28_27:27.1 L28_26:27.1 L27_5:27.1 L27_2:27.1 L26_3:26.1 L26_0:26.1;
locks    ; strict;
comment  @* @;


32.13
date     91.03.27.21.30.45;  author jesup;  state Exp;
branches ;
next     32.12;

32.12
date     91.03.25.20.49.37;  author jesup;  state Exp;
branches ;
next     32.11;

32.11
date     91.03.13.20.39.20;  author jesup;  state Exp;
branches ;
next     32.10;

32.10
date     90.11.28.23.44.26;  author jesup;  state Exp;
branches ;
next     32.9;

32.9
date     90.11.28.23.40.27;  author jesup;  state Exp;
branches ;
next     32.8;

32.8
date     90.11.26.20.58.11;  author Unknown;  state Exp;
branches ;
next     32.7;

32.7
date     90.11.21.04.20.06;  author jesup;  state Exp;
branches ;
next     32.6;

32.6
date     90.06.01.23.18.15;  author jesup;  state Exp;
branches ;
next     32.5;

32.5
date     90.03.16.01.08.18;  author jesup;  state Exp;
branches ;
next     32.4;

32.4
date     89.05.08.16.21.18;  author jesup;  state Exp;
branches ;
next     32.3;

32.3
date     89.04.13.17.12.10;  author bryce;  state Exp;
branches ;
next     32.2;

32.2
date     89.02.17.20.21.44;  author jesup;  state Exp;
branches ;
next     32.1;

32.1
date     85.12.23.17.20.07;  author neil;  state Exp;
branches ;
next     30.2;

30.2
date     85.10.09.00.37.10;  author neil;  state Exp;
branches ;
next     30.1;

30.1
date     85.10.08.16.55.33;  author neil;  state Exp;
branches ;
next     27.1;

27.1
date     85.06.24.13.38.26;  author neil;  state Exp;
branches ;
next     26.1;

26.1
date     85.06.17.15.13.40;  author neil;  state Exp;
branches ;
next     ;


desc
@@


32.13
log
@Really fixed NULLs, etc (forgot 4(a0) instead of (a0) for FUNNYA1)
@
text
@
*************************************************************************
*									*
*  Copyright (C) 1985,1989 Commodore Amiga Inc.  All rights reserved.	*
*									*
*************************************************************************

*************************************************************************
*
* track.asm
*
* Source Control
* ------ -------
* 
* $Id: track.asm,v 32.12 91/03/25 20:49:37 jesup Exp Locker: jesup $
*
* $Locker: jesup $
*
* $Log:	track.asm,v $
* Revision 32.12  91/03/25  20:49:37  jesup
* Fix up NULLs between sectors
* 
* Revision 32.11  91/03/13  20:39:20  jesup
* Added the SetErrors routine to initialize the TDB_SECERRS array
* 
* Revision 32.10  90/11/28  23:44:26  jesup
* no changes
* 
* Revision 32.9  90/11/28  23:40:27  jesup
* TDB_DATA now a variable
* 
* Revision 32.8  90/11/26  20:58:11  Unknown
* Fixed register usage around IncSector call (d1 is now trashed)
* 
* Revision 32.7  90/11/21  04:20:06  jesup
* Changes for multi-density floppies.
* 
* Revision 32.6  90/06/01  23:18:15  jesup
* Conform to include standard du jour
* 
* Revision 32.5  90/03/16  01:08:18  jesup
* Fixed several MFM problems I introduced.  First, the SEC_NULL fields were
* always $2aaaaaaa.  Under 1.3 they were wrong also, always $aaaaaaaa.  I also
* made the 2aa8/aaa8 go after the last sector, instead of 8 bytes farther on.
* I now deal with both SYNC words being eaten on the first sector, using
* OFFSET_2 to avoid moving the buffer, or adding 1K to each unit's allocation.
* Added a bunch of comments.
* 
* Revision 32.4  89/05/08  16:21:18  jesup
* no change (mark)
* 
* Revision 32.3  89/04/13  17:12:10  bryce
* Conform internal autodocs to the autodoc style guide.  Add history
* notes on the massive DSKSYNC rework.
* 
* Revision 32.2  89/02/17  20:21:44  jesup
* Totally rewritten for sync reads and new write scheme.
* Much improved performance, less system overhead.
* 
* Revision 32.1  85/12/23  17:20:07  neil
* Added rawread/rawwrite
* 
* Revision 30.2  85/10/09  00:37:10  neil
* Another internal (for 1.01)
* 
* Revision 30.1  85/10/08  16:55:33  neil
* changed "trailing data word" from a AAAA to an AAA8 (this is the
* word that is written just after a track.
* 
* Revision 27.1  85/06/24  13:38:26  neil
* Upgrade to V27
* 
* Revision 26.1  85/06/17  15:13:40  neil
* *** empty log message ***
* 
* 
*************************************************************************

;****** Included Files ***********************************************

	NOLIST
	INCLUDE 'exec/types.i'
	INCLUDE 'exec/nodes.i'
	INCLUDE 'exec/lists.i'
	INCLUDE 'exec/ports.i'
	INCLUDE 'exec/libraries.i'
	INCLUDE 'exec/io.i'
	INCLUDE 'exec/devices.i'
	INCLUDE 'exec/tasks.i'
	INCLUDE 'exec/interrupts.i'

	INCLUDE 'resources/disk.i'

	INCLUDE 'hardware/custom.i'

	INCLUDE 'devices/timer.i'

	INCLUDE 'trackdisk.i'
	INCLUDE 'asmsupp.i'
	INCLUDE 'internal.i'
	INCLUDE 'messages.i'
	LIST

	SECTION section

;****** Imported Names ***********************************************

*------ Tables -------------------------------------------------------

*------ Defines ------------------------------------------------------

	XREF	tdName

*------ Functions ----------------------------------------------------

	XREF	TDMfmLongEncode
	XREF	TDMfmLongDecode
	XREF	TDMfmSumBuffer
	XREF	TDMfmSumBufferDecode
	XREF	TDMfmFixBit
	XREF	_LVOCopyMem

*------ System Library Functions -------------------------------------

;****** Exported Names ***********************************************

*------ Functions ----------------------------------------------------

	XDEF	TDMfmFindSector
	XDEF	TDSetErrors
	XDEF	TDMfmAllignTrack
	XDEF	TDMfmSumCheck
	XDEF	TDMfmSumCheckXfer
	XDEF	TDMfmCheckAllData
	XDEF	TDMfmAllignWrite

*------ Data ---------------------------------------------------------

;****** Local Definitions ********************************************

NULLS	EQU	$AAAAAAAA		; two bytes of MFM coded NULLS
FUNNYA1	EQU	$44894489		; a magic illegal pattern
DSYNC	EQU	$4489			; a single sync
MFMNULL	EQU	$AAAA			; an MFM 0 byte


*****i* trackdisk.device/internal/TDMfmFindSector ********************
*
*   NAME
*	TDMfmFindSector - Find the beginning of a sector in a track
*
*   SYNOPSIS
*	Ptr = TDMfmFindSector( BufferPtr, EndPtr ), TDLib
*	A0			A0	    A1	      A6
*
*   FUNCTION
*	This routine finds the beginning of a sector in a raw track
*	buffer.	 Every sector begins with a "00 00 A1* A1*".  This
*	routine looks for this pattern (which may be on an arbitrary
*	bit boundary).  Actually, it only looks for the A1*'s.
*
*   INPUTS
*	BufferPtr - a word alligned pointer into the track buffer.
*
*	Endptr    - addr of word past end of buffer
*
*   OUTPUTS
*	Ptr - a word alligned pointer to the start of the sector. Will
*		be -1 if no match is found
*	    - note that ptr is to the word AFTER the $4489(s).  It will
*	      advance ptr past the second $4489 IF it is there.
*
*   EXCEPTIONS
*
*   SEE ALSO
*	TDMfmSecDecode, TDMfmDecode
*
*   BUGS
*
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*	A0 -- pointer to buffer area
*	D0 -- number of WORDS to examine
*	D1 -- constant (word) DSYNC
*
**********************************************************************

TDMfmFindSector
		MOVE.L	A1,D0
		SUB.L	A0,D0
		ASR.W	#1,D0		; size < 32767
		BMI.S	findfail	; a0 past a1

		MOVE.W	#DSYNC,D1

findloop	CMP.W	(A0)+,D1
		DBEQ	D0,findloop	; exit loop on equal

		;-- exited - is d0 == -1?
		TST.W	D0
		BPL.S	foundit		; if d0 >= 0, then we found it

		;-- failed
findfail	MOVE.W	#-1,A0
		RTS

		;-- handle second $4489, if it exists
foundit		CMP.W	(A0)+,D1
		BEQ.S	findexit
		SUBQ.L	#2,A0		; back up to word after $4489
findexit:	RTS
		

*****i* trackdisk.device/internal/TDSetErrors ********************
*
*   NAME
*	TDSetErrors - set all the error values to Too Few Sectors
*
*   SYNOPSIS
*	TDSetErrors( BufferPtr )
*			A2
*
*   FUNCTION
*	Sets all the sector error values to Too Few Sectors.  Used to
*	clear out the array on the beginning of TDMfmAllignTrack and if
*	TrkRead returns an error.	
*
*   INPUTS
*	BufferPtr - pointer to the TDBuffer structure.
*
*   OUTPUTS
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
*
*   IMPLEMENTATION NOTES
*
**********************************************************************
TDSetErrors:
		LEA	TDB_SECERRS(A2),A0
		MOVE.L	#$1a1a1a1a,D1	; 4 TDERR_TooFewSecs (26 decimal)

		MOVE.L	D1,(A0)+
		MOVE.L	D1,(A0)+
		MOVE.L	D1,(A0)+
		MOVE.L	D1,(A0)+
		MOVE.L	D1,(A0)+
		MOVE.L	D1,(A0)+	; fills thru sec 24
		RTS

*****i* trackdisk.device/internal/TDMfmAllignTrack ********************
*
*   NAME
*	TDMfmAllignTrack - Allign the track after a read
*
*   SYNOPSIS
*	Sectors = TDMfmAllignTrack( ), UnitPtr, TDLib
*	D0,			         A3,      A6
*	15-0
*
*   FUNCTION
*	This routine will word allign a track after a read.  It will
*	also make all the sectors contiguous in the track, and will
*	renumber the sector identifiers.
*	Also clears the TDBF_HASERRS flag, and sets the TDB_SECPTRS
*	and TDB_SECERRS arrays.
*
*   OUTPUTS
*	Sectors - returns the number of sector successfully read.  Should
*		  normally equal NUMSECS.
*
*   EXCEPTIONS
*
*   SEE ALSO
*	TDMfmSecDecode, TDMfmDecode, TDMfmFindSector
*
*   BUGS
*
*   HISTORY NOTES
*
*	History: When the "Portia" chip was upgraded to "Paula" Glenn
*	Keller added a "disk synchronization" register (DSKSYNC).
*	This was never used by trackdisk.  DSKSYNC will find an arbitary
*	16 bit MFM pattern on the disk, so we no longer need to bit search
*	memory.  This also buys significant gains for recovering bad
*	disks.  DSKSYNC will resync for the duration of a read.
*
*	If the sync word is found at an arbitary point in the input
*	stream, Paula resyncs immediatly.   The sync word is NOT included
*	in the output.  If the sync word is found aligned, no resync is
*	needed and the sync word IS included inthe output.
*
*	From checking the schematics, DSKSYNC will also work to start
*	*WRITE* DMA.  (this feature probably has no good use).
*
*			-Bryce
*
*   IMPLEMENTATION NOTES
*
*	Major changes for use of disksync.  Assumes read started at
*	with the _second_ $4489 sync mark of a sector.  All following
*	sectors up to the gap will have both $4489's.  The first sector
*	following the gap will not, unless the offset was 0 bits.
*
*	Sets up the TDB_SECPTRS array with pointers to each of the
*	sectors.  Doesn't move the sectors around, a write will call
*	TDMfmReallign to set it up for write.  Also, errors are on a
*	sector by sector basis stored in the TDB_SECERRS array.
*
*	Because of where DMA starts, the transfer should begin at TDB_DATA
*	+ 6, so the $aaaaaaaa $4489 can be added to the front.  Paula ALWAYS
*	eats the first 4489 after (at) DMA start.  We cannot get two at the
*	beginning, but can get two later.
*
*	Also NOTE! We may have 0 $4489's at the beginning of the track!  This
*	is a rare occurance, the DMA must start in the middle of the first
*	one (sees the second, throws it away (non-aligned), then starts xfer
*	on the sector ID).  Chance of this is very small (15/(544*2*16) ~=
*	.08%, or about 1 in a thousand reads.
*
*   REGISTER USAGE
*	A6 -- TDLib
*	A2 -- Track buffer
*	A3 -- Unit pointer
*	A0 -- current position in buffer
*	A1 -- scratch
*	D0,D1,D4 -- scratch
*	D2 -- number of sectors found
*	D3 -- address of end of buffer
*	D5 -- stores address of buffer during BSR's
*	D6 -- Current sector number
*
**********************************************************************


TDMfmAllignTrack

		MOVEM.L A2/D2/D3/D5/D6,-(SP)
		MOVE.L	TDU_BUFFER(A3),A2

*		;-- clear HASERRS, ALIGNED, and OFFSET_2 bits.
		MOVEQ	#~(TDBF_HASERRS!TDBF_ALIGNED!TDBF_OFFSET_2),D1
		AND.B	D1,TDB_FLAGS(A2)

*		;-- Set all TDB_SECERRS to TDERR_TooFewSecs
		BSR.S	TDSetErrors	; (a2)

*		;-- find the beginning of where we want the data to go
*		;-- also get pointer to sector array
		MOVE.L	TDB_DATA(A2),A0
		ADDQ.L	#4,a0			; start searching here
		LEA	TDB_BUF(A2),A1		; beginning of buffer
		ADD.W	TDU_MFM_TRKBUF(a3),a1	; only works up to 32K!!!!
					; size of current tracks (handles
					; variable number of sectors!)
		
		MOVE.L	A1,D3		; end of buffer (search)
		MOVEQ	#0,D2		; no sectors found yet

		;-- handle the first sector differently.  It may have either
		;-- 0 or 1 $4489 preceeding it.  To make the code simpler, I'll
		;-- stuff a $4489 into the preceeding word (since we know we
		;-- synced on one).  Before writing, AlignWrite will fix it.
		MOVE.W	#DSYNC,(a0)	; now have 1 or two $4489's
Allign_loop
		;-- find the next sector
		MOVE.W	D3,A1		; max addr to look at
		BSR.S	TDMfmFindSector
		CMP.W	#-1,A0
		BEQ.S	Allign_No_More

Allign_10
*		;------ We found a sector header.  The address is in A0.
*		;------ FindSector returns address of word after last 4489
*		;------ It also handles either 1 or 2 $4489's.

*		;------ Do some common setup stuff
		MOVE.L	A0,D5			; save address of header
		MOVEQ	#(MFMFMT_HDRSUM>>2)-1,D1
		CLEAR	D6

*		;------ we are properly alligned.
*		;------ now checksum the sector header
*		;------ Stupid motorola non-orthagonalities in EOR!
Allign_12:
		MOVE.L  (A0)+,D0
		EOR.L   D0,D6
		DBRA	D1,Allign_12
		AND.L	#$55555555,D6

*		;------ common code to see if the sector checksum is OK
		BSR	TDMfmLongDecode	(A0)
		MOVE.L	D5,A0		; restore A0
		CMP.L	D0,D6
		BEQ.S	GoodCheck

		;-- start right after the last $4489 found
		BRA.S	Allign_loop	; if bad, ignore and look for another
					; this will give a TooFewSecs error
					; unless of course it finds them all

*		;-- get the TrackID word of this sector
GoodCheck:	BSR	TDMfmLongDecode	(A0)	; a0 -> format words

*		;------ We already have a good checksum.
*		;------ Do a rudimentary check on D6 to make sure it
*		;------ makes sense.  This will be two things:
*		;------ That its highest 8 bits are FMT_SECTYPE
*		;------ and that it has the correct track #.

		MOVE.L	D5,A0		; restore A0
		MOVE.L	D0,-(SP)
		CLEAR	D6
		MOVE.B	FMT_SECTOR(SP),D6	; long sector number
		CMP.B	#FMT_SECTYPE,FMT_TYPE(SP)
		BEQ.S	GoodFormat

		;-- bad format - mark in TDB_SECERRS
ErrBadSecHdr	MOVEQ	#TDERR_BadSecID,D0
		MOVE.B	D0,TDB_SECERRS(A2,D6.W)
		ADDQ.W	#4,SP		; drop format longword on stack

		;-- skip the sector area (we know one exists)
		BRA.S	SkipSec

		;-- make sure we're on the right track
GoodFormat	MOVE.B	FMT_TRACK(SP),D0
		CMP.B	TDU_TRACK+1(A3),D0	; note TDU_TRACK is a word
		BNE.S	ErrBadSecHdr

		ADDQ.W	#4,SP		; drop word on stack

		;-- We won't update the number of sectors until gap here.
		;-- That will be done right before writing the track out.
		;-- We also won't check the data checksum until we 
		;-- actually read the sector.  We we do check it, we
		;-- will set TDB_SECERRS[sector] to 0.

		;-- make sure I haven't found the sector before!
		LEA	TDB_SECERRS(A2,D6.W),A1
		CMP.B	#TDERR_TooFewSecs,(A1)
		BNE.S	SkipSec

		;-- no errors, clear error entry (was set on entry)
		MOVE.B	#-1,(A1)

		;-- set TDB_SECPTRS[d6] = start of header
		ASL.W	#2,D6
		MOVE.L	A0,TDB_SECPTRS(A2,D6.W)

		;-- increment # of sectors found
		ADDQ.W	#1,D2

		;-- loop and find next sector
		;-- note A0 points to the word after syncs.
SkipSec		LEA	MFM_RAWSECTOR-8(A0),A0		; 8 for 00 00 A1* A1*
		BRA	Allign_loop

Allign_No_More

*		;-- return the number of sectors read (word value)
	IFGE	INFO_LEVEL-40
	move.w	d2,-(sp)
	clr.w	-(sp)
	PUTMSG	40,<'%s/TDAllignTrack: found %ld sectors'>
	addq.w	#4,sp
	ENDC
		MOVE.W	D2,D0
		MOVEM.L	(SP)+,D2/D3/D5/D6/A2
		RTS

*****i* trackdisk.device/internal/TDMfmSumCheckXfer *****************************
*
*   NAME
*	TDMfmSumCheckXfer - checksum a sectors data block and transfers it
*
*   SYNOPSIS
*	Result = TDMfmSumCheckXfer( Dest, Source )
*	  D0			     A1,    A4
*
*   FUNCTION
*	Compute the checksum of the sector passed, and compare it to the
*	stored checksum.  (Data portion only)
*	Also, transfer the data to the destination after decoding it.
*
*   INPUTS
*	Dest - a pointer to the destination area
*
*	Source - a pointer to the starting word of the sector (MFMSEC_FMT)
*
*   OUTPUTS
*	Result - Old checksum - New checksum
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*	A4 - pointer to MFMSEC_FMT of the sector
*
*
**************************************************************************

TDMfmSumCheckXfer:
		MOVE.L	D2,-(SP)

		LEA	MFMSEC_DATA-MFMSEC_FMT(A4),A0
		MOVE.W	#MFM_SECTOR,D1
		BSR	TDMfmSumBufferDecode (D1,A0,A1)
		BRA.S	SumCheckCommon

*****i* trackdisk.device/internal/TDMfmSumCheck *****************************
*
*   NAME
*	TDMfmSumCheck - checksum a sectors data block and check
*
*   SYNOPSIS
*	Result = TDMfmSumCheck( Source )
*	  D0			  A4
*
*   FUNCTION
*	Compute the checksum of the sector passed, and compare it to the
*	stored checksum.  (Data portion only)
*
*   INPUTS
*	Source - a pointer to the starting word of the sector (MFMSEC_FMT)
*
*   OUTPUTS
*	Result - Old checksum - New checksum
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*	A4 - pointer to MFMSEC_FMT of the sector
*
**************************************************************************

TDMfmSumCheck:
		MOVE.L	D2,-(SP)

		LEA	MFMSEC_DATA-MFMSEC_FMT(A4),A0
		MOVE.W	#MFM_SECTOR,D1
		BSR	TDMfmSumBuffer (D1,A0)
SumCheckCommon
		MOVE.L	D0,D2

		LEA	MFMSEC_DATASUM-MFMSEC_FMT(A4),A0
		BSR	TDMfmLongDecode
		SUB.L	D2,D0

		MOVE.L	(SP)+,D2
		RTS

*****i* trackdisk.device/internal/TDMfmCheckAllData *****************************
*
*   NAME
*	TDMfmCheckAllData - checksum the data of all the sectors of a track
*
*   SYNOPSIS
*	Track Buffer = TDMfmCheckAllData( Track Buffer )
*	     A0				   A0
*
*   FUNCTION
*	Compute the checksums for all sectors, and set TDBB_HASERRS, etc if
*	any of them checksum wrong.
*
*   INPUTS
*	Track Buffer - a pointer to a TDB_xxx structure
*
*   OUTPUTS
*	Track Buffer - same as input parameter
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*	PRESERVES A0!!!
*
**************************************************************************

TDMfmCheckAllData:
		BTST.B	#TDBB_HASERRS,TDB_FLAGS(A0)
		BNE.S	CheckDone

		MOVEM.L	D2/A2/A4,-(SP)
		MOVE.W	TDU_NUMSECS(A3),D2
		SUBQ.W	#1,D2			; entering dbra from top
		MOVE.L	A0,A2
Checkall_loop
		TST.B	TDB_SECERRS(A2,D2.W)
		BGT.S	SetErr			; should have been set already
		BEQ.S	Checkall_end		; already checksummed

		;-- negative error means not checksummed
		MOVE.W	D2,D0
		ASL.W	#2,D0
		MOVE.L	TDB_SECPTRS(A2,D0.W),A4
		BSR.S	TDMfmSumCheck (A4)
		TST.L	D0			; new minus old checksums
		BEQ.S	GoodSum

		;-- bad checksum - mark
BadSum		MOVEQ	#TDERR_BadSecSum,D0
		MOVE.B	D0,TDB_SECERRS(A2,D2.W)
SetErr		BSET.B	#TDBB_HASERRS,TDB_FLAGS(A2)
		BRA.S	Checkall_end		; keep on checking sectors

		;-- sector is ok, mark as checked
GoodSum:	CLR.B	TDB_SECERRS(A2,D2.W)

Checkall_end:	DBRA	D2,Checkall_loop

		MOVE.L	A2,A0			; preserve A0!!!
		MOVEM.L	(SP)+,D2/A2/A4
CheckDone	RTS


*****i* trackdisk.device/internal/TDMfmAllignWrite *****************************
*
*   NAME
*	TDMfmAllignWrite - Take a track buffer and massage it for writing
*
*   SYNOPSIS
*	TDMfmAllignWrite( Buffer ), TDLib
*			    A2	      A6
*
*   FUNCTION
*	Does all needed massaging of the sector so it can be directly
*	written.  In particular, it copies the sectors so they are
*	contiguous, and start at the beginning of the buffer.
*	With disksync, the first sector will always begin at the beginning
*	of the buffer.  Also modifies the sectors to gap and recalculates
*	the checksums of the headers.  All $2aaaaaaa $44894489's will be
*	inserted.
*
*	We might have NO SYNCs from the read (but just one stuffed by the
*	read alignment code).  Check if we got a sync mark as the first
*	DMAed word.
*
*   INPUTS
*	Buffer - a pointer to the track buffer
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*	A6 -- TDLib
*
***********************************************************************

TDMfmAllignWrite:
		MOVEM.L	A4/D2/D3/D4/D5/D6,-(SP)

		;-- First check whether we got 0 or 1 $4489's, and move buffer
		;-- ptr down one word if we got 0 (instead of moving data up)
		;-- Also set flag to say we aligned it already
		MOVE.L	TDB_DATA(A2),A4
		BSET.B	#TDBB_ALIGNED,TDB_FLAGS(A2)  ; it will be
		BCLR.B	#TDBB_OFFSET_2,TDB_FLAGS(A2) ; paranoia
		MOVE.L	#FUNNYA1,D2
		MOVE.L	#NULLS,D0
		CMP.W	6(A4),D2		; we start DMA at +6
		BEQ.S	one_a1

		;-- No $4489's.  Dec buffer ptr by 2, set flag in structure
		SUBQ.L	#2,A4
		BSET.B	#TDBB_OFFSET_2,TDB_FLAGS(A2)

		;-- now make sure the first sector has the nulls, etc
		;-- we started reading with the second DSYNC at TDB_DATA+6
		;-- no need to fixbit the NULLS, since they follow the gap
one_a1:		MOVE.L	D0,(A4)+		; MUST be preceded by $aaaa!!
		MOVE.L	D2,(A4)+		; #FUNNYA1

		;-- find out how many sectors till gap
		MOVE.L	A4,A0
		MOVE.L	A4,D5			; in case we started in gap
		BSR	TDMfmLongDecode		; get the format word
		CLEAR	D2
		MOVE.B	D0,D2			; sectors till gap (inc current)
		SUBQ.W	#1,D2			; not inc current
		MOVE.W	TDU_NUMSECS(A3),D3	; new sectors till gap

		;-- enter with a4 -> format word of a sector
		;-- d3 new sectors till gap including current
		;-- d2 old sectors till gap (or till end) not including current
AllignWLoop
		MOVE.L	A4,A0
		BSR	TDMfmLongDecode		; get old format
		MOVE.L	D0,D4			; save format word
		MOVE.B	D3,D0			; FMT_SECOFF is 4th byte
		MOVE.L	A4,A0
		BSR	TDMfmLongEncode		; put new format

		;-- now recompute the header checksum
		MOVE.L	A4,A0
		MOVEQ	#MFMFMT_HDRSUM,D1
		BSR	TDMfmSumBuffer (D1,A0)	; sum returned in d0
		LEA	MFMFMT_HDRSUM(A4),A0
		BSR	TDMfmLongEncode (D0,A0)	; put encoded checksum

		;-- bit used to be fixed below - a4 points to fmt byte
		LEA	MFMSEC_ZEROS-MFMSEC_FMT(A4),a0	; ptr to SEC_ZEROS
		MOVE.L	#NULLS,(a0)		; set up header
		BSR	TDMfmFixBit  (a0)	; May need to be $2aaaaaaa!!!
						; doesn't modify a0!
		MOVE.L	#FUNNYA1,4(a0)		; add $4489's - paranoia

		;-- loop
		LEA	MFM_RAWSECTOR(A4),A4	; to next format word
		SUBQ.W	#1,D3
AllignWLoopEnd:	DBRA	D2,AllignWLoop

*		;-- we have done up to the gap
*		;-- move the sectors after the gap down, then
*		;-- do their headers too.
		TST.W	D3
		BEQ.S	AllignWDone	; all sectors before gap done

		;-- d3 > 0
		;-- first allign the sectors after the gap
		;-- note that the first sector after the gap may have
		;-- one or two $4489's preceeding it.
		SUBQ.L	#8,A4		; point to first word of gap

		;-- A4 has the destination, D4 has last format word
		;-- use D4 to find the right entry in TDB_SECPTRS for
		;-- the sector after the gap.
		MOVE.L	D4,D0
		LSR.W	#8,D0
		AND.W	#$00ff,D0	; IncSector doesn't affect regs
		ASL.L	#2,D0		; longword array
		BSR.S	IncSector	; we want the next one (hits d0/d1 only)
					; IncSector deals with 4*sector
					; d0.w = new sec times 4, d1 trash

		;-- this points D2 to the format word of the source
		MOVE.L	TDB_SECPTRS(A2,D0.W),D2	  ; sector after gap
		MOVE.L	A4,D5			  ; save addr of former gap

		;-- bit used to be fixed below
		MOVE.L	A4,A0			; where sector after gap goes
		MOVE.L	D0,D4			  ; save sector number
		MOVE.L	#NULLS,(A4)+		  ; set up header
		BSR	TDMfmFixBit		; May need to be $2aaaaaaa!!!
		MOVE.L	#FUNNYA1,(A4)+		; add $4489's

		;-- Fix the secptrs for the sectors after the gap
		;-- a4 has ptr to fmt word of destination
		;-- d2 has ptr to first sector after gap (fmt word)
		;-- D3 has number of sectors (must be at least 1)
		;-- D4 has first sector number * 4 after gap (dead)
		;-- a0-A1/d0-D1 are free
		MOVE.L	D2,D6
		MOVE.L	D2,A0
		MOVE.L	D4,D0		; restore regs
		SUB.L	A4,D6		; offset for secptrs
		MOVE.W	D3,D2		; sectors to do

Fix_Ptrs	SUB.L	D6,TDB_SECPTRS(A2,D0.W)
		BSR.S	IncSector	; deals with 4*sector (hits d0/d1 only)
		SUBQ.W	#1,D2			; done yet?
		BNE.S	Fix_Ptrs		; includes first sector

		;-- Now we need to move some sectors from A0 to A4
		;-- D3 has new sectors to gap for first sector after gap
		;-- (including current sector, no need to add 1)
		MOVE.W	D3,D0

		;-- D0 has sectors to move
		MULU	#MFM_RAWSECTOR,D0
		SUBQ.W	#8,D0			; already have 0000A1A1
		MOVE.L	A4,A1

		;-- copy using CopyMem (can't use quick, not LONG alligned)
		MOVE.L	A6,-(SP)
		MOVE.L	TD_SYSLIB(A6),A6
		JSR	_LVOCopyMem(A6) (a0,a1,d0)
		MOVE.L	(SP)+,A6

		;-- Ok, now set things up to jump back into the
		;-- sectors to gap fixing loop
		;-- D3 is still correct, A4 is correct, D5 is set
		MOVE.W	D3,D2
		BRA.S	AllignWLoopEnd	; will decrement d2 for us

		;-- all copied, now do other chores
		;-- D5 has addr of sector (fmt) that used to be after gap
		;-- A4 points to the word 8 bytes after the last sector
AllignWDone:
* now done above (see FixBit)
*		;-- Fix up the SEC_NULL field of the old first sector
*		;-- of the track
*		MOVE.L	D5,A0
*		SUBQ.L	#8,A0		; point at SEC_NULL
*		BSR	TDMfmFixBit

*		;------ Force the buffer to end on AAA8 (or 2AA8)
		;------ The reason it is not AAAA is because paula
		;------ drops write gate three bits before the serial
		;------ shift out actually stops.  The software must 
		;------ ensure that the last three bits are nulls.
		SUBQ.L	#8,a4		; point to word after last sector
		MOVE.W	#$AAA8,D0
		BTST.B	#0,-1(A4)
		BEQ.S	AllignOK12

*		;------ unset the clock bit
		BCLR	#15,D0
AllignOK12:
		MOVE.W	D0,(A4)

		MOVEM.L	(SP)+,A4/D2/D3/D4/D5/D6
		RTS

		;-- increment sector number in D0 (times 4!)
		;-- affects D1 only!
IncSector:
		ADDQ.W	#4,D0			; next sector number
		MOVE.W	TDU_NUMSECS(a3),D1
		LSL.W	#2,D1			; *4
		CMP.W	D1,D0			; check for overflow
		BMI.S	1$			; bra if d0 < NUMSECS * 4
		CLEAR	D0			; else sector 0
1$		RTS

	END

@


32.12
log
@Fix up NULLs between sectors
@
text
@d15 1
a15 1
* $Id: track.asm,v 32.11 91/03/13 20:39:20 jesup Exp $
d17 1
a17 1
* $Locker:  $
d20 3
d727 1
a727 1
		BSR	TDMfmSumBuffer (D1,A0)
d731 2
a732 2
		;-- bit used to be fixed below
		LEA	-8(A4),a0		; ptr to SEC_ZEROS
d735 2
a736 1
		MOVE.L	#FUNNYA1,(a0)		; add $4489's - paranoia
@


32.11
log
@Added the SetErrors routine to initialize the TDB_SECERRS array
@
text
@d15 1
a15 1
* $Id: track.asm,v 32.10 90/11/28 23:44:26 jesup Exp $
d20 3
d727 6
@


32.10
log
@no changes
@
text
@d15 1
a15 1
* $Id: track.asm,v 32.9 90/11/28 23:40:27 jesup Exp $
d20 3
d124 1
d211 41
d347 1
a347 9
		LEA	TDB_SECERRS(A2),A0
		MOVE.L	#$1a1a1a1a,D1	; 4 TDERR_TooFewSecs (26 decimal)

		MOVE.L	D1,(A0)+
		MOVE.L	D1,(A0)+
		MOVE.L	D1,(A0)+
		MOVE.L	D1,(A0)+
		MOVE.L	D1,(A0)+
		MOVE.L	D1,(A0)+	; fills thru sec 24
@


32.9
log
@TDB_DATA now a variable
@
text
@d15 1
a15 1
* $Id: track.asm,v 32.8 90/11/26 20:58:11 Unknown Exp $
d20 3
@


32.8
log
@Fixed register usage around IncSector call (d1 is now trashed)
@
text
@d15 1
a15 1
* $Id: track.asm,v 32.7 90/11/21 04:20:06 jesup Exp Locker: Unknown $
d17 1
a17 1
* $Locker: Unknown $
d20 3
d311 2
a312 1
		LEA	TDB_DATA+4(A2),A0	; start searching here
d640 1
a640 1
		LEA	TDB_DATA(A2),A4
@


32.7
log
@Changes for multi-density floppies.
@
text
@d15 1
a15 1
* $Id: track.asm,v 32.6 90/06/01 23:18:15 jesup Exp $
d17 1
a17 1
* $Locker:  $
d20 3
d308 2
a309 2
		LEA	TDB_DATA+4(A2),A0
		LEA	TDB_BUF(A2),A1	; beginning of buffer
d314 1
a314 1
		MOVE.L	A1,D3		; end of buffer
d631 1
a631 1
		MOVEM.L	A4/D2/D3/D4/D5,-(SP)
d690 1
a690 1
		BEQ.S	AllignWDone	; all sectors before gap
d707 1
d714 2
a715 2
		MOVE.L	A4,A0
		MOVE.L	D0,D4			  ; save
d718 1
a718 1
		MOVE.L	#FUNNYA1,(A4)+
d726 1
a726 1
		MOVE.L	D2,D1
d729 1
a729 1
		SUB.L	A4,D1		; offset for secptrs
d732 1
a732 1
Fix_Ptrs	SUB.L	D1,TDB_SECPTRS(A2,D0.W)
d750 1
a750 1
		JSR	_LVOCopyMem(A6)
d785 1
a785 1
		MOVEM.L	(SP)+,A4/D2/D3/D4/D5
@


32.6
log
@Conform to include standard du jour
@
text
@d15 1
a15 1
* $Id: /usr/rebma/jesup/trackdisk/RCS/track.asm,v 32.5 90/03/16 01:08:18 jesup Exp Locker: jesup $
d17 1
a17 1
* $Locker: jesup $
d20 3
a295 2
		;-- note that this is dependant on NUMSECS, and tromps the
		;-- TDB_PAD field.
d299 3
d306 7
a312 3
		LEA	TDB_SIZE(A2),A1
		MOVE.L	A1,D3	; size of buffer
		MOVEQ	#0,D2		; no sectors found
d324 1
a324 1
		BEQ	Allign_No_More
d416 6
d557 2
a558 1
		MOVEQ	#NUMSECS-1,D2		; entering dbra from top
d566 1
a566 1
		MOVE.L	D2,D0
d658 1
a658 1
		MOVEQ	#NUMSECS,D3		; new sectors till gap
d702 1
a702 1
		BSR.S	IncSector	; we want the next one
d726 1
a726 1
		MOVE.L	D3,D2		; sectors to do
d729 1
a729 1
		BSR.S	IncSector	; deals with 4*sector
d752 1
a752 1
		MOVE.L	D3,D2
d784 2
a785 2
		;-- increment sector number in D0 (time 4!)
		;-- affect no other registers
d788 3
a790 1
		CMP.W	#(NUMSECS*4),D0		; check for overflow
@


32.5
log
@Fixed several MFM problems I introduced.  First, the SEC_NULL fields were
always $2aaaaaaa.  Under 1.3 they were wrong also, always $aaaaaaaa.  I also
made the 2aa8/aaa8 go after the last sector, instead of 8 bytes farther on.
I now deal with both SYNC words being eaten on the first sector, using
OFFSET_2 to avoid moving the buffer, or adding 1K to each unit's allocation.
Added a bunch of comments.
@
text
@d15 1
a15 1
* $Header: track.asm,v 32.4 89/05/08 16:21:18 jesup Exp $
d17 1
a17 1
* $Locker:  $
d20 8
@


32.4
log
@no change (mark)
@
text
@d15 1
a15 1
* $Header: track.asm,v 32.3 89/04/13 17:12:10 bryce Exp $
d17 1
a17 1
* $Locker: jesup $
d20 3
d111 2
a112 2
NULLS	EQU	$02AAAAAAA		; two bytes of MFM coded NULLS
FUNNYA1	EQU	$044894489		; a magic illegal pattern
d247 3
a249 1
*	+ 6, so the $2aaaaaaa $4489 can be added to the front
d251 6
d277 3
a279 2
*		;-- clear the HASERRS bit.
		BCLR	#TDBB_HASERRS,TDB_FLAGS(A2)
d293 1
a293 1
		LEA	TDB_DATA+6(A2),A0
d298 5
d313 1
d584 4
d607 3
a609 2
		;-- first make sure the first sector has the nulls, etc
		;-- we started reading with the second DSYNC at TDB_DATA+6
d611 6
a616 2
		MOVE.L	#NULLS,(A4)+
		MOVE.L	#FUNNYA1,(A4)+
d618 10
d682 2
a683 2
		;-- this points a0 to the format word of the source
		MOVE.L	TDB_SECPTRS(A2,D0.W),A0	  ; sector after gap
d686 3
d690 1
d695 1
a695 1
		;-- a0 has ptr to first sector after gap (fmt word)
d697 5
a701 3
		;-- D0 has first sector number * 4 after gap (dead)
		;-- A1/D1/D2/D4 are free
		MOVE.L	A0,D1
d734 1
a734 1
		;-- A4 points to the word after the last sector
d736 6
a741 5
		;-- Fix up the SEC_NULL field of the old first sector
		;-- of the track
		MOVE.L	D5,A0
		SUBQ.L	#8,A0		; point at SEC_NULL
		BSR	TDMfmFixBit
d748 1
@


32.3
log
@Conform internal autodocs to the autodoc style guide.  Add history
notes on the massive DSKSYNC rework.
@
text
@d15 1
a15 1
* $Header: track.asm,v 32.2 89/02/17 20:21:44 jesup Exp $
d17 1
a17 1
* $Locker: bryce $
d20 4
@


32.2
log
@Totally rewritten for sync reads and new write scheme.
Much improved performance, less system overhead.
@
text
@d4 1
a4 1
*	Copyright (C) 1985, Commodore Amiga Inc.  All rights reserved.	*
d15 1
a15 1
* $Header: track.asm,v 32.1 85/12/23 17:20:07 neil Exp $
d17 1
a17 1
* $Locker: jesup $
d20 4
d43 1
a43 1
******* Included Files ***********************************************
d70 1
a70 1
******* Imported Names ***********************************************
d89 1
a89 1
******* Exported Names ***********************************************
d102 1
a102 1
******* Local Definitions ********************************************
d110 1
a110 1
******* System/Drivers/TD/TDMfmFindSector ****************************
a142 1
**********************************************************************
d152 1
d180 1
a180 1
******* System/Drivers/TD/TDMfmAllignTrack ***************************
d208 1
a208 1
*---------------------------------------------------------------------
d210 17
d254 1
a254 1
*---------------------------------------------------------------------
d382 1
a382 1
******* System/Drivers/TD/TDMfmSumCheckXfer *****************************
a409 2
*---------------------------------------------------------------------
*
d417 1
a417 1
*---------------------------------------------------------------------
d427 1
a427 1
******* System/Drivers/TD/TDMfmSumCheck *****************************
a451 2
*---------------------------------------------------------------------
*
d458 1
a458 2
*
*---------------------------------------------------------------------
d476 1
a476 1
******* System/Drivers/TD/TDMfmCheckAllData *****************************
a500 2
*---------------------------------------------------------------------
*
a502 1
*
d506 1
a506 2
*
*---------------------------------------------------------------------
d544 1
a544 1
******* System/Drivers/TD/TDMfmAllignWrite *****************************
a570 2
*---------------------------------------------------------------------
*
a572 1
*
d576 1
a576 2
*
*---------------------------------------------------------------------
d722 1
@


32.1
log
@Added rawread/rawwrite
@
text
@d15 1
a15 1
* $Header: track.asm,v 30.2 85/10/09 00:37:10 neil Exp $
d17 1
a17 1
* $Locker: neil $
d20 3
d79 1
d81 1
a81 3
	XREF	WaitDskBlk
	XREF	TDDskBlk
	XREF    TDDoBlit
a84 2
	EXTERN_LIB QBlit

d91 4
a94 1
	XDEF	TDMfmAllignSec
d102 2
a105 16
*-- used to talk with the blitter queue
 STRUCTURE BL,0
	APTR	BL_NEXT
	APTR	BL_FUNC		;-- function that will be called
	ULONG	BL_LENGTH	;-- number of bytes to write
	APTR	BL_DATA		;-- pointer to user data
	APTR	BL_BUFFER	;-- pointer to mfm encoded area
	UWORD	BL_BLTSIZE	;-- parameter for bltsize register
	UBYTE	BL_SHIFT	;-- bit offset of data in BUFFER
	UBYTE	BL_JUNK		;-- padding for word allignment
	UWORD	BL_SAVE		;-- a place to save a word
	APTR	BL_UNIT
	LABEL	BL_SIZE



d112 2
a113 2
*	BitOffset, Ptr = TDMfmFindSector( BufferPtr, MaxLen ), TDLib
*	D0	   A0			  A0	     D0	       A6
d119 1
a119 1
*	bit boundary).
d124 1
a124 1
*	MaxLen - the maximum number of bytes to look for the buffer.
a126 2
*	BitOffset - the starting bit number of the sector
*
d129 2
a144 3
*	A6 -- TDLib
*	A2 -- address of end of search
*	A1 -- pointer to match table entry
d146 2
a147 6
*	D4 -- contains "odd bits" allignment data word to CMP against
*	D3 -- contains "even bits" allignment data word to CMP against
*	D2 -- contains either contents of D3 or D4, whichever we are
*		matching against
*	D1 -- contains the long word after a match against D2
*	D0 -- contains the bit shift number that we are matching against
a148 1
*
a149 1

d151 4
a154 1
		MOVEM.L D2-D4/A2,-(SP)
d156 1
a156 2
		MOVE.W	#$0AAAA,D3
		MOVE.W	#$05555,D4
d158 2
a159 3
*		; compute termination address
		MOVE.L	A0,A2
		ADD.L	D0,A2
d161 3
a163 6
FindSec_top:
		MOVE.W	(A0)+,D2
		CMP.W	D3,D2
		BEQ.S	FindZero
		CMP.W	D4,D2
		BEQ.S	FindOne
d165 2
a166 41
*		;-- have we fallen out of the loop?
		CMP.L	A0,A2
		BHI.S	FindSec_top

FindErr:
*		;-- didn't find a match within MaxLen bytes
		MOVEQ	#-1,D0
		MOVE.L	D0,A0
		BRA.S	FindEnd

FindOne:
		MOVEQ	#15,D0
		LEA	FindOne_table,A1

FindCheck
		CMP.L	A0,A2
		BLS.S	FindErr

		MOVE.W	(A0)+,D1
		CMP.W	D2,D1
		BEQ.S	FindCheck		; another word of the same

FindLoop:
		SUBQ.L	#2,A0			; back up the pointer
		MOVE.L	(A0),D1

FindLoop_10:
		CMP.L	(A1)+,D1
		BEQ.S	FindMatch
		SUBQ.L	#2,D0
		BGE.S	FindLoop_10

*		;-- we did not match.  Go back to the main loop
		BRA.S	FindSec_top

FindMatch:
*		;-- we found a sector.	Note the correct position
		SUBQ.L	#4,A0

FindEnd:
		MOVEM.L (SP)+,D2-D4/A2
d169 6
a174 4
FindZero:
		MOVEQ	#14,D0
		LEA	FindZero_table,A1
		BRA.S	FindCheck
a175 22
FindOne_table:
*					; data starts at bit
		DC.L	$02244A244		; 15
		DC.L	$048912891		; 13
		DC.L	$052244A24		; 11
		DC.L	$054891289		; 9
		DC.L	$0552244A2		; 7
		DC.L	$055489128		; 5
		DC.L	$05552244A		; 3
		DC.L	$055548912		; 1

FindZero_table:
		DC.L	$091225122		; 14
		DC.L	$0A4489448		; 12
		DC.L	$0A9122512		; 10
		DC.L	$0AA448944		; 8
		DC.L	$0AA912251		; 6
		DC.L	$0AAA44894		; 4
		DC.L	$0AAA91225		; 2
		DC.L	$044894489		; 0 (e.g. correctly alligned)


d182 3
a184 2
*	Error = TDMfmAllignTrack( ), UnitPtr, TDLib
*	D0,			     A3,      A6
d190 2
a192 1
*
d194 2
a195 3
*	Error - a -1 if an error occurred; a null (0) if the track
*		was decoded.  A typical error would be no beginning
*		of sector mark found.
d208 4
d213 8
d223 9
a232 1
*
d238 2
a239 2
		MOVEM.L A2/D2/D3/D4/D5/D6,-(SP)
		LINK	A4,#-16
d241 13
d255 5
a259 2
		MOVE.L	TDU_BUFFER(A3),A2
		LEA	TDB_DATA(A2),A2
d261 6
a266 4
		MOVE.L	A2,A0
		ADDQ.L	#2,A0
		MOVE.L	#MFM_RAWSECTOR+MFM_SLOP,D0
		BSR	TDMfmFindSector
a267 3
		CMP.L	#-1,A0
		BEQ	ErrNoSecHdr

d269 2
a270 5
*		;------ We found a sector header.  The address is in A0 and
*		;------ the bit offset is in D0.  We will move these to D5 and
*		;------ D2 respectively
		MOVE.L	A0,D5
		MOVE.L	D0,D2
a271 2
		ADDQ.L	#8,A0		; advance past nulls and A1's

d273 2
a274 1
		MOVEQ	#(MFMFMT_HDRSUM>>2)-1,D4
d277 1
a277 8
*		;------ Divide into two cases -- alligned or not alligned
		TST.L	D2
		BNE.S	Allign_20

*		;------ we are properly alligned.  Store format longwords
		MOVE.L	(A0),-8(A4)
		MOVE.L	4(A0),-4(A4)

d279 1
a279 1
		MOVE.L	#$55555555,D1
a281 1
		AND.L	D1,D0
d283 2
a284 1
		DBF	D4,Allign_12
a285 31
*		;------ Store checksum
		MOVE.L	(A0)+,-16(A4)
		MOVE.L	(A0),-12(A4)

*		;------ Rejoin the common code

		BRA.S	Allign_30

Allign_20:
*		;------ store format longwords on the stack
		BSR	AllignLong (A0,D2)
		MOVE.L	D0,-8(A4)
		BSR	AllignLong (A0,D2)
		MOVE.L	D0,-4(A4)

*		;------ Now checksum the sector header
		MOVE.L	D5,A0
		ADDQ.L	#8,A0
Allign_22:
		BSR	AllignLong (A0,D2)
		AND.L	#$55555555,D0
		EOR.L	D0,D6
		DBF	D4,Allign_22

*		;------ store checksum longwords
		BSR	AllignLong
		MOVE.L	D0,-16(A4)
		BSR	AllignLong
		MOVE.L	D0,-12(A4)

Allign_30:
d287 2
a288 2
		LEA	-16(A4),A0
		BSR	TDMfmLongDecode
d290 1
a290 1
		BNE	ErrBadSecHdr
d292 5
d298 1
a298 2
		LEA	-8(A4),A0
		BSR	TDMfmLongDecode
d300 2
a301 14
		MOVE.L	D0,D3

	IFGE	INFO_LEVEL-40
	MOVE.L	D0,-(SP)
	MOVE.L	D2,-(SP)
	MOVE.L	D5,-(SP)
	PEA	0
	MOVE.W  TDU_TRACK(A3),2(SP)
	INFOMSG	40,<'%s/AllignTrack: track %3ld @@ 0x%lx << %2ld is 0x%lx'>
	LEA	16(SP),SP
	MOVE.L	D3,D0
	ENDC

*		;------ Do a rudimentary check on D3 to make sure it
a304 3
		MOVE.L	D3,-(SP)
		CMP.B	#FMT_SECTYPE,FMT_TYPE(SP)
		BNE	ErrBadSecHdr
d306 1
a306 123
		MOVE.B	FMT_TRACK(SP),D0
		CMP.B	TDU_TRACK+1(A3),D0
		BNE	ErrBadSecHdr

		MOVE.L	(SP)+,D3
		CLEAR	D0
		MOVE.B	D3,D0


*		; put the allign byte into its proper place
		MULU.W	#MFM_RAWSECTOR,D0

*		;-- allign the first part of the track
		MOVE.L	D5,A0			; source
		MOVE.L	A2,A1			; destination
		MOVE.L	D2,D1			; bit position in sector

		MOVE.L	D0,D4			; save first allign size

		BSR	TDMfmAllignSec

*		;-- See if there is any more to allign
		CLEAR	D2
		MOVE.B	D3,D2
		SUB.L	#NUMSECS,D2
		NEG.L	D2

*		;-- D3 now has the format word of the first sector in the
*		;-- buffer.  D2 holds the number of sectors left to be decoded
		BEQ.S	AllignUpdate		; already did all the sectors

*		;-- find the start of the second region
		ADD.L	D4,D5			; last used location

		MOVE.L	#MFM_SLOP,D0
		MOVE.L	D5,A0
		ADDQ.L	#2,A0
		BSR	TDMfmFindSector

		CMP.L	#-1,A0
		BEQ	ErrTooFewSecs		; didn't find sector

*		;-- now allign the second part
		MOVE.L	D0,D1			; bit allignment
		MOVE.L	A2,A1
		ADD.L	D4,A1			; destination
		MOVE.L	D2,D0
		MULU.W	#MFM_RAWSECTOR,D0	; number of bytes to allign
		BSR	TDMfmAllignSec	(D0,D1,A0,A1)

AllignUpdate:
*		;------ fixup the SEC_NULL field of the old first sector
*		;------ of the track
		MOVE.L	A2,A0
		ADD.L	D4,A0
		BSR	TDMfmFixBit

*		;------ Force the buffer to end on AAA8 (or 2AA8)
		;------ The reason it is not AAAA is because paula
		;------ drops write gate three bits before the serial
		;------ shift out actually stops.  The software must 
		;------ ensure that the last three bits are nulls.
		LEA	NUMSECS*MFM_RAWSECTOR(A2),A0
		MOVE.W	#$AAA8,D0
		BTST	#0,-1(A0)
		BEQ	AllignOK12

*		;------ unset the clock bit
		BCLR	#15,D0
AllignOK12:
		MOVE.W	D0,(A0)


*		;-- As an artifact of the way we alligned tracks, the first
*		;-- word in the buffer may be wrong.  We will force it to
*		;-- be correct
		MOVE.W	#$0AAAA,(A2)

*		;-- We now have read in and alligned the entire track.
*		;-- Check the headers for validity and update the sector
*		;-- offset field.

*		;-- In this loop D4 is the offset from the beginning of the
*		;--	data in the buffer (e.g. from A2)
*		;-- D2 is the number of sectors from the end (for the sector
*		;--	offset field)
*		;-- D5 is the expected sector number of this sector
		CLEAR	D4
		MOVEQ	#NUMSECS,D2

		MOVE.W	D3,D5
		LSR.W	#8,D5

AllignUp_00:
*		;-- this word may be either $02AAAAAAA or $0AAAAAAAA
		CMP.L	#NULLS,MFMSEC_ZEROS(A2,D4.W)
		BEQ.S	AllignUp_10

		CMP.L	#$0AAAAAAAA,MFMSEC_ZEROS(A2,D4.W)
		BNE	ErrBadSecPreamble

AllignUp_10:
		CMP.L	#FUNNYA1,MFMSEC_A1(A2,D4.W)
		BNE	ErrBadSecPreamble

*		;------ compute the header checksum
		LEA	MFMSEC_FMT(A2,D4.W),A0
		MOVEQ	#MFMFMT_HDRSUM,D1
		BSR	TDMfmSumBuffer (D1,A0)

		MOVE.L	D0,D6

*		;------ now check it against the sector
		LEA	MFMSEC_FMT+MFMFMT_HDRSUM(A2,D4.W),A0
		BSR	TDMfmLongDecode

		CMP.L	D6,D0
		BNE	ErrBadHdrSum

		LEA	MFMSEC_FMT(A2,D4.W),A0
		BSR	TDMfmLongDecode

*		;-- D0 now holds the format longword.  Check it
d308 2
a309 2

*		;-- check the type byte
d311 1
a311 1
		BNE	ErrBadSecID
d313 4
a316 4
*		;-- check the track number
		MOVE.B	FMT_TRACK(SP),D1
		CMP.B	TDU_TRACK+1(A3),D1
		BNE	ErrBadSecID
d318 2
d321 4
a324 4
*		;-- check the sector number against what it should be
		MOVE.B	FMT_SECTOR(SP),D1
		CMP.B	D5,D1
		BNE	ErrBadSecID
d326 1
a326 2
*		;-- the format word check OK.  Update the sector offset
		MOVE.B	D2,FMT_SECOFF(SP)
d328 5
d334 4
a337 4
*		;-- put the format word back
		MOVE.L	(SP)+,D0
		LEA	MFMSEC_FMT(A2,D4.W),A0
		BSR	TDMfmLongEncode
d339 2
a340 4
*		;-- recompute the header checksum, and put it back
		LEA	MFMSEC_FMT(A2,D4.W),A0
		MOVEQ	#MFMFMT_HDRSUM,D1
		BSR	TDMfmSumBuffer (D1,A0)
d342 3
a344 2
		LEA	MFMSEC_FMT+MFMFMT_HDRSUM(A2,D4.W),A0
		BSR	TDMfmLongEncode (D0,A0)
d346 2
a347 5
*		;-- compute the data checksum and compare it
		LEA	MFMSEC_DATA(A2,D4.W),A0
		MOVE.W	#MFM_SECTOR,D1
		BSR	TDMfmSumBuffer (D1,A0)
		MOVE.L	D0,D6			; save the result
d349 4
a352 2
		LEA	MFMSEC_DATASUM(A2,D4.W),A0
		BSR	TDMfmLongDecode
d354 1
a354 2
		CMP.L	D6,D0			; compare against actual sum
		BNE	ErrBadSecSum
d356 3
a358 46


*		;-- update the loop variables
		SUBQ.L	#1,D2

		ADDQ.B	#1,D5
		CMP.B	#NUMSECS,D5
		BLT.S	AllignUp_20
		CLEAR	D5
AllignUp_20
		ADD.W	#MFM_RAWSECTOR,D4

		CMP.W	#MFM_USEDTRACK,D4
		BNE	AllignUp_00


	IFGE	INFO_LEVEL-80
	;-- debugging loop to print out all the sector headers
	MOVE.L	#NUMSECS*MFM_RAWSECTOR,D4

AllignDe_00:
	SUB.L	#MFM_RAWSECTOR,D4
	LEA	8(A2,D4),A0

	BSR	TDMfmLongDecode

	MOVE.L	D0,-(SP)
	PEA	8(A2,D4)
	INFOMSG	80,<'%s/AllignTrack: Sector @@ 0x%lx is 0x%lx'>
	ADDQ.L	#8,SP

	TST.L	D4
	BNE.S	AllignDe_00
	ENDC


*		;-- return the sector number for the first sector in the
*		;-- buffer
		MOVE.L	D3,D1
		LSR.L	#8,D1
		CLEAR	D0
		MOVE.B	D1,D0

AllignEnd:
		UNLK	A4
		MOVEM.L	(SP)+,D2/D3/D4/D5/D6/A2
d361 1
a361 5
	XDEF	AllignErrEnd
AllignErrEnd:
		NOP
		BRA	AllignEnd

d363 2
a364 1
*		;------ all the errors are grouped here
d366 33
a398 6
	XDEF	AllignErr1
	XDEF	ErrNoSecHdr
ErrNoSecHdr:
AllignErr1:
		MOVEQ	#TDERR_NoSecHdr,D0
		BRA.S	AllignErrEnd
d400 2
a401 7
	XDEF	AllignErr7
	XDEF	ErrBadSecHdr
ErrBadSecHdr:
AllignErr7:
*		;------ Clean up the stack in a way that shows in a trace
		MOVEQ	#TDERR_BadSecHdr,D0
		BRA.S	AllignErrEnd
d403 4
d408 35
a442 6
	XDEF	AllignErr2
	XDEF	ErrBadSecPreamble
ErrBadSecPreamble:
AllignErr2:
		MOVEQ	#TDERR_BadSecPreamble,D0
		BRA.S	AllignErrEnd
d444 2
a445 6
	XDEF	AllignErr3
	XDEF	ErrBadSecID
ErrBadSecID:
AllignErr3:
		MOVEQ	#TDERR_BadSecID,D0
		BRA.S	AllignErrEnd
d447 5
a451 6
	XDEF	AllignErr4
	XDEF	ErrBadHdrSum
ErrBadHdrSum:
AllignErr4:
		MOVEQ	#TDERR_BadHdrSum,D0
		BRA.S	AllignErrEnd
d453 3
a455 4
	XDEF	AllignErr5
	XDEF	ErrBadSecSum
ErrBadSecSum:
AllignErr5:
d457 1
a457 52
	IFGE	INFO_LEVEL-80
	MOVE.L	A2,-(SP)	; track beginning
	MOVE.L	A2,-(SP)
	ADD.L	D4,(SP)		; sector beginning
	MOVE.L	D6,-(SP)	; computed result
	MOVE.L	D0,-(SP)	; expected result
	MOVE.L	D5,-(SP)	; sector number
	PEA	0
	MOVE.W	TDU_TRACK(A3),2(SP)	; track number
	INFOMSG	80,<'%s/sum err sec %ld/%ld: expected 0x%08lx got 0x%08lx @@ offset 0x%lx (track @@ 0x%lx)'>

	LEA	6*4(SP),SP

	EXTERN_LIB Debug
	LINKSYS	Debug
	ENDC

		MOVEQ	#TDERR_BadSecSum,D0
		BRA	AllignErrEnd

	XDEF	AllignErr6
	XDEF	ErrTooFewSecs
ErrTooFewSecs:
AllignErr6:
		MOVEQ	#TDERR_TooFewSecs,D0
		BRA	AllignErrEnd


*-- subsidiary routine to allign a long word
*--
*-- Called with:
*--	A0: data pointer (left incremented)
*--	D2: starting bit number
*--
*-- Returns
*--	D0: alligned word
*--
*-- steps on:
*--	D1,D3
AllignLong:

		MOVE.L	(A0)+,D0
		MOVE.W	(A0),D1

		MOVEQ	#16,D3
		SUB.L	D2,D3

		LSL.L	D3,D0
		LSR.W	D2,D1

		OR.W	D1,D0

d460 1
a460 1
******* System/Drivers/TD/TDMfmAllignSec *****************************
d463 1
a463 1
*	TDMfmAllignSec - copy a series of sectors to a word allignment
d466 2
a467 2
*	TDMfmSecAllign( Source, Dest, NumBytes, BitPos ), TDLib
*			A0,	A1,   D0,	D1,	  A6
d470 2
a471 3
*	This routine alligns a block of sectors to the beginning of
*	the buffer.  Currently the Source must be greater than the
*	Dest.
d474 1
a474 1
*	Source - a pointer to the starting word of the buffer
d476 2
a477 1
*	Dest - a pointer to the place to write the alligned buffer
a478 4
*	NumBytes - the number of bytes to allign
*
*	BitPos - the starting bit number of true data in the buffer
*
d491 1
a491 1
*	A6 -- TDLib
d496 3
a498 1
TDMfmAllignSec:
d500 7
a506 2
*		;-- get storage for the blitter buffer
		LINK	A2,#-BL_SIZE
d508 7
a514 2
*		;-- this routine is completely blitter based.  prepare the
*		;--	buffer that we will pass to the bltter.
d516 5
a520 2
*		;-- save BitPos in buffer
		MOVE.B	D1,BL_SHIFT-BL_SIZE(A2)
d522 2
a523 4
*		;-- if we are on an odd bit boundary, we must do 1 or 2
*		;-- extra words
		TST.L	D1
		BEQ.S	MfmAllignSec_10
d525 1
a525 1
		ADDQ.L	#2,D0
d527 3
a529 7
MfmAllignSec_10
*		;-- compute the first bltsize
		MOVE.L	D0,D1
		ADD.L	#$03F,D1		; round up
		AND.W	#$0FFC0,D1
		OR.W	#$20,D1			; horizontal size = 32
		MOVE.W	D1,BL_BLTSIZE-BL_SIZE(A2)
a530 2
*		;-- save the arguments
		MOVEM.L D0/A0-A1,BL_LENGTH-BL_SIZE(A2)
d532 1
a532 24
*		;-- intialize the blitter function pointer
		MOVE.L	#AllignBlit_00,BL_FUNC-BL_SIZE(A2)

		;-- show the device where the unit is
		MOVE.L	A3,BL_UNIT-BL_SIZE(A2)

*		;-- call the blit enqueue routine
		LEA	-BL_SIZE(A2),A1
		DOGFX	QBlit

*		;-- Wait on the blitter signal
		BSR	WaitDskBlk
MfmAllignSec_30
*****		TST.L	BL_FUNC-BL_SIZE(A2)
*****		BNE.S	MfmAllignSec_30


*		;-- we are all done.  now we can clean up

		UNLK	A2

		RTS

*--------------------------------------------------------------------
d534 2
a535 1
*	All these blit routines are called with the following args:
d537 3
a539 3
*   A0: the routine address
*   A1: a pointer to _custom (A$00000)
*   A2: a pointer to a BL data structure
d541 8
a548 2
*	The BL structure will not be dequeued until it returns with
*   the Z function code set (e.g. it does a BEQ)
d550 2
a551 6
*   REGISTER ALLOCATION
*   A0 -- ptr to _custom
*   A1 -- ptr to BUFFER
*   A5 -- ptr to BL structure
*   D0 -- LENGTH of transfer
*   D1 -- ptr to DATA
d553 16
a568 1
*--------------------------------------------------------------------
d570 2
a571 2
	XDEF	AllignBlit_00
AllignBlit_00:
d573 5
a577 3
*		;-- We do the copy in one pass by rounding up to the next
*		;-- 64 byte boundary.  The only tricky part is that we
*		;-- will save initial word to avoid stepping on it.
d579 8
a586 1
		MOVE.L	A5,-(SP)
d588 10
a597 2
		MOVE.L	A1,A5
		BSR	TDDoBlit
d599 6
a604 3
		MOVE.B	BL_SHIFT(A5),D0
		MOVEQ	#12,D1
		LSL.W	D1,D0			; offset is now in D0:15-12
d606 4
a609 4
*		;-- set the control registers
*		;-- bltcon0 =	USEB | USED | B
*		;--		0400   0100   CC
		MOVE.W	#$05CC,bltcon0(A0)
d611 5
a615 2
*		;-- do other control registers
		MOVE.W	D0,bltcon1(A0)
d617 5
a621 2
*		;-- get out the magic registers
		MOVEM.L BL_LENGTH(A5),D0-D1/A1
d623 9
a631 2
*		;-- load up the B source
		MOVE.L	D1,bltbpt(A0)		; A src = DATA
d633 3
a635 2
*		;-- set the next blit address
		MOVE.L	#AllignBlit_End,BL_FUNC(A5)
d637 2
a638 3
*		;-- load up the D source
*		;-- start blit from one word before true destination
*		;-- iff we are shifting
d640 9
a648 2
		TST.B	BL_SHIFT(A5)
		BEQ.S	AllignBlit_03
d650 4
a653 1
		SUBQ.L	#2,A1
d655 4
a658 2
*		;-- reset the next blit address
		MOVE.L	#AllignBlit_10,BL_FUNC(A5)
d660 4
a663 1
AllignBlit_03:
d665 5
a669 1
		MOVE.L	A1,bltdpt(A0)
d671 5
a675 2
*		;-- save the first word of the Dest (it will be trashed)
		MOVE.W	(A1),BL_SAVE(A5)
d677 9
a685 3
*		;-- and start the blit!
		MOVE.W	BL_BLTSIZE(A5),bltsize(A0)
		MOVE.L	(SP)+,A5
d687 8
a694 1
		RTS
d696 4
d701 2
d704 8
a711 17

	XDEF	AllignBlit_10

AllignBlit_10:
*		;-- restore the trashed word
		MOVE.L	BL_BUFFER(A1),A0
		MOVE.W	BL_SAVE(A1),-2(A0)

AllignBlit_End:
		MOVEQ	#0,D0
		MOVE.L	D0,BL_FUNC(A1)

		MOVE.L	BL_UNIT(A1),A1
		BSR	TDDskBlk
		MOVEQ	#0,D0

		RTS
@


30.2
log
@Another internal (for 1.01)
@
text
@d15 1
a15 1
* $Header: track.asm,v 30.1 85/10/08 16:55:33 neil Exp $
d20 3
d38 1
d59 1
d684 2
a685 4
	XREF	_Debug
	XDEF	_SysBase
_SysBase EQU 4
	JSR	_Debug
@


30.1
log
@changed "trailing data word" from a AAAA to an AAA8 (this is the
word that is written just after a track.
@
text
@d15 1
a15 1
* $Header: track.asm,v 27.1 85/06/24 13:38:26 neil Exp $
d17 1
a17 1
* $Locker:  $
d20 4
d302 1
a302 1
		MOVE.L	#MFM_RAWSECTOR+2*MFM_SLOP,D0
d433 1
a433 1
		MOVE.L	#2*MFM_SLOP,D0
a454 8

*****		;-- now clear the area after the valid track
*****		;-- !!! check to see if we need to unset the first bit
*****		LEA	NUMSECS*MFM_RAWSECTOR(A2),A0
*****		MOVE.L	#((MFM_TRKBUF-NUMSECS*MFM_RAWSECTOR-MFM_SLOP)>>2)-1,D0
AllignOK10
*****		MOVE.L	#$0AAAAAAAA,(A0)+
*****		DBF	D0,AllignOK10
@


27.1
log
@Upgrade to V27
@
text
@d15 1
a15 1
* $Header: track.asm,v 26.1 85/06/17 15:13:40 neil Exp $
d20 3
d460 5
a464 1
*		;---- Force the buffer to end on AAAA (or 2AAA)
d466 1
a466 1
		MOVE.W	#$AAAA,D0
@


26.1
log
@*** empty log message ***
@
text
@d15 1
a15 1
* $Header: track.asm,v 25.6 85/06/07 22:23:19 neil Exp $
d20 3
@
