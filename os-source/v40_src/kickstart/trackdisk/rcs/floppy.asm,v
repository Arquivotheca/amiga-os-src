head     33.18;
branch   ;
access   ;
symbols  V36_21:33.16 V36_20:33.16 V36_19:33.16 V36_18:33.15 V36_16:33.14 V36_15:33.14 V36_14:33.14 V36_13:33.14 V36_10:33.13 V36_9:33.12 V36_6:33.12 V36_5:33.12 V36_4:33.10 L36_2:33.4 L33_127:33.4 L33_126:33.4 L33_124:33.4 L33_120:33.4 L33_119:33.3 L33_116:33.3 L33_113:33.2 L33_106:33.1 L32_98:32.2 L31_87:32.1 L31_57:30.1 L31_56:30.1 L1_55:30.1 L1_54:30.1 L1_51:30.1 L1_47:30.1 L1_45:30.1 L1_44:30.1 L29_44:30.1 L29_42:27.2 L28_37:27.2 L28_35:27.2 L28_27:27.1 L28_26:27.1 L27_5:27.1 L27_2:27.1 L26_3:26.1 L26_0:26.1;
locks    ; strict;
comment  @* @;


33.18
date     92.04.05.19.48.15;  author jesup;  state Exp;
branches ;
next     33.17;

33.17
date     91.03.13.20.40.34;  author jesup;  state Exp;
branches ;
next     33.16;

33.16
date     90.11.26.17.38.29;  author jesup;  state Exp;
branches ;
next     33.15;

33.15
date     90.11.21.04.11.24;  author jesup;  state Exp;
branches ;
next     33.14;

33.14
date     90.06.01.23.15.20;  author jesup;  state Exp;
branches ;
next     33.13;

33.13
date     90.03.16.00.56.37;  author jesup;  state Exp;
branches ;
next     33.12;

33.12
date     89.09.06.18.51.12;  author jesup;  state Exp;
branches ;
next     33.11;

33.11
date     89.05.15.21.15.52;  author jesup;  state Exp;
branches ;
next     33.10;

33.10
date     89.04.27.23.36.22;  author jesup;  state Exp;
branches ;
next     33.9;

33.9
date     89.04.12.14.37.19;  author jesup;  state Exp;
branches ;
next     33.8;

33.8
date     89.03.22.20.18.22;  author jesup;  state Exp;
branches ;
next     33.7;

33.7
date     89.03.22.17.33.25;  author jesup;  state Exp;
branches ;
next     33.6;

33.6
date     89.03.18.01.45.46;  author jesup;  state Exp;
branches ;
next     33.5;

33.5
date     89.02.17.19.07.37;  author jesup;  state Exp;
branches ;
next     33.4;

33.4
date     86.04.09.16.07.25;  author neil;  state Exp;
branches ;
next     33.3;

33.3
date     86.04.04.09.56.31;  author neil;  state Exp;
branches ;
next     33.2;

33.2
date     86.03.31.01.42.29;  author neil;  state Exp;
branches ;
next     33.1;

33.1
date     86.03.29.14.13.36;  author neil;  state Exp;
branches ;
next     32.2;

32.2
date     86.01.03.19.51.42;  author neil;  state Exp;
branches ;
next     32.1;

32.1
date     85.12.23.17.18.58;  author neil;  state Exp;
branches ;
next     30.1;

30.1
date     85.08.29.12.29.31;  author neil;  state Exp;
branches ;
next     27.2;

27.2
date     85.07.11.06.23.05;  author neil;  state Exp;
branches ;
next     27.1;

27.1
date     85.06.24.13.36.48;  author neil;  state Exp;
branches ;
next     26.1;

26.1
date     85.06.17.15.13.08;  author neil;  state Exp;
branches ;
next     ;


desc
@@


33.18
log
@PostWrite and SideSel are now variable
@
text
@
*************************************************************************
*									*
*	Copyright (C) 1985, Commodore Amiga Inc.  All rights reserved.	*
*									*
*************************************************************************

*************************************************************************
*
* floppy.asm
*
* Source Control
* ------ -------
* 
* $Id: floppy.asm,v 33.17 91/03/13 20:40:34 jesup Exp Locker: jesup $
*
* $Locker: jesup $
*
* $Log:	floppy.asm,v $
* Revision 33.17  91/03/13  20:40:34  jesup
* Removed unneeded selects, bsr->bsr.s
* 
* Revision 33.16  90/11/26  17:38:29  jesup
* Added some debugging code (ifdefed out)
* 
* Revision 33.14  90/06/01  23:15:20  jesup
* Conform to include standard du jour
* 
* Revision 33.13  90/03/16  00:56:37  jesup
* Added store of direction before seek, to make sure drive has a few micros
* to notice the direction, instead of driving them at the same time (at request
* of grr).
* 
* Revision 33.12  89/09/06  18:51:12  jesup
* Changed comments, changed _AbsExecBase to ABSEXECBASE
* 
* Revision 33.11  89/05/15  21:15:52  jesup
* fixed usage of Getunit in TDMotor and Calibrate, added comments
* fixed error return for timeout on read.
* fixed bug in signal clearing in TDStartDma
* 
* Revision 33.10  89/04/27  23:36:22  jesup
* fixed autodocs, BSR/RTS->BRA
* 
* Revision 33.9  89/04/12  14:37:19  jesup
* fix to TDMotor
* 
* Revision 33.8  89/03/22  20:18:22  jesup
* Fixed TDDelay for small delays on 68030 w/ data cache
* wait settledelay when reversing head direction on calibrate
* 
* Revision 33.7  89/03/22  17:33:25  jesup
* Made TDMotor release unit while waiting, small optimizations.
* 
* Revision 33.6  89/03/18  01:45:46  jesup
* Added xdef
* 
* Revision 33.5  89/02/17  19:07:37  jesup
* TDMotor now waits .1 secs up to 5 times, and check ready after each
* removed NOPs
* TrkRead now uses the WORDSYNC ability
* WaitDskBlk now uses signals instead of PutMsg, added routine to support
* sync reads, WaitDskTime.  Can now use timer and dma at the same time.
* minor code optimizations
* 
* Revision 33.4  86/04/09  16:07:25  neil
* 68020 changes for real
* 
* Revision 33.3  86/04/04  09:56:31  neil
* Some trial changes for 68020 slowdowns
* 
* Revision 33.2  86/03/31  01:42:29  neil
* removed a debugging statement in TDDelay.
* 
* Revision 33.1  86/03/29  14:13:36  neil
* made seek and settle time programmable.  Isolated unit specific
* initializers to the beginning of the unit structure
* 
* Revision 32.2  86/01/03  19:51:42  neil
* Added reset catching code
* 
* Revision 32.1  85/12/23  17:18:58  neil
* Added rawread/rawwrite
* 
* Revision 30.1  85/08/29  12:29:31  neil
* fixed bug in calibrate -- track 0 was not detected properly
* 
* Revision 27.2  85/07/11  06:23:05  neil
* Made seek report an error
* 
* Revision 27.1  85/06/24  13:36:48  neil
* Upgrade to V27
* 
* Revision 26.1  85/06/17  15:13:08  neil
* *** empty log message ***
* 
* 
*************************************************************************

	SECTION section

;****** Included Files ***********************************************

	NOLIST
	INCLUDE 'exec/types.i'
	INCLUDE 'exec/nodes.i'
	INCLUDE 'exec/lists.i'
	INCLUDE 'exec/ports.i'
	INCLUDE 'exec/libraries.i'
	INCLUDE 'exec/io.i'
	INCLUDE 'exec/devices.i'
	INCLUDE 'exec/tasks.i'
	INCLUDE 'exec/interrupts.i'
	INCLUDE 'exec/alerts.i'
	INCLUDE 'exec/ables.i'

	INCLUDE 'hardware/intbits.i'
	INCLUDE 'hardware/adkbits.i'
	INCLUDE 'hardware/cia.i'
	INCLUDE 'hardware/custom.i'

	INCLUDE 'resources/disk.i'

	INCLUDE 'devices/timer.i'

	INCLUDE 'trackdisk.i'
	INCLUDE 'asmsupp.i'
	INCLUDE 'internal.i'
	INCLUDE 'messages.i'
	LIST

	INT_ABLES


;****** Imported Names ***********************************************

	XREF		tdName

*------ Tables -------------------------------------------------------

*------ Defines ------------------------------------------------------

	XREF		_ciaa			;------ most of the disk regs
	XREF		_ciab			;------ track00 select

	XREF		_custom

ABSEXECBASE	EQU	4

*------ Functions ----------------------------------------------------

	XREF		TDGetUnit
	XREF		TDGiveUnit

*------ System Library Functions -------------------------------------

	EXTERN_LIB	Alert
	EXTERN_LIB	DoIO
	EXTERN_LIB	Debug
	EXTERN_LIB	GetMsg
	EXTERN_LIB	Wait
	EXTERN_LIB	PutMsg
	EXTERN_LIB	WaitIO
	EXTERN_LIB	Signal
	EXTERN_LIB	SetSignal

;****** Exported Names ***********************************************

*------ Functions ----------------------------------------------------

	XDEF		TDCalibrate
	XDEF		TDSeek
	XDEF		TDMotor
	XDEF		TDDelay
	XDEF		TDStep
	XDEF		TDTrkRead
	XDEF		TDNewTrkRead
	XDEF		TDTrkWrite
	XDEF		TDNewTrkWrite
	XDEF		TDStartDma
	XDEF		TDStartDmaSync
	XDEF		TDDskBlk
	XDEF		WaitDskTime
	XDEF		WaitDskBlk

*------ Data ---------------------------------------------------------

;****** Local Definitions ********************************************

DSYNC	EQU	$4489

*****i* trackdisk.device/internal/TDCalibrate ***********************
*
*   NAME
*	TDCalibrate -- initialize and calibrate the drive.
*
*   SYNOPSIS
*	Error = TDCalibrate( ), UnitPtr, TDLib
*	D0			A3,	 A6
*
*   FUNCTION
*	This routine does a seek to track zero.	 If the drive cannot
*	find track zero within MAXTRACKS steps an error is returned.
*
*
*   OUTPUTS
*	Error - non-zero if an error occurred
*
*
*   EXCEPTIONS
*
*   SEE ALSO
*	TDSeek
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*	A6 -- TDLib
*
*


TDCalibrate
		MOVE.L D2,-(SP)

		INFOMSG	50,<'%s/TDCalibrate: called'>
		BSR	TDGetUnit

*		;------ get the 6526 value
		MOVE.B	TDU_6522(A3),D0

*		;------ set ourselves to side 0
		BSET	#CIAB_DSKSIDE,D0

*		;------ step in until track0 goes away
		BCLR	#CIAB_DSKDIREC,D0
		MOVE.B	D0,ciaprb+_ciab		; make sure drive is selected
		MOVE.B	D0,TDU_6522(A3)
		CLEAR	D2
		MOVE.W	TDU_NUMTRACKS(A3),D2
		LSR.L	#2,D2			; max 40 tracks

Calib_in:
		BTST	#CIAB_DSKTRACK0,ciapra+_ciaa
		BNE.S	Calib_out

		BSR.S	TDStep
		DBF	D2,Calib_in

Calib_out:
		;------ wait for head to settle - we're changing directions
		;------ allow other units to get at hardware in meantime
		BSR	TDGiveUnit
		MOVE.L	TDU_SETTLEDELAY(A3),D0
		BSR	TDDelay
		BSR	TDGetUnit
*		MOVE.B	TDU_6522(A3),_ciab+ciaprb	; select drive!

		BSET	#CIAB_DSKDIREC,TDU_6522(A3) ; seek outwards
		CLR.W	TDU_SEEKTRK(A3)		; mark us at cylinder 0

		;------ change TDU_STEPDELAY to TDU_CALIBRATEDELAY (temp)
		;------ this is because we need an extra ms for trk0 valid.
		MOVE.L	TDU_STEPDELAY(A3),-(SP)	; save
		MOVE.L	TDU_CALIBRATEDELAY(A3),TDU_STEPDELAY(A3)

		;------	20 more than the number of cylinders
		MOVE.W	TDU_NUMTRACKS(A3),D2		; loop count
		LSR.W	#1,D2
		ADD.W	#20,D2
		BRA.S	Calib_20

Calib_10
		BSR.S	TDStep

*		;------ check for track00
Calib_20
		BTST	#CIAB_DSKTRACK0,ciapra+_ciaa
		DBEQ	D2,Calib_10

*		;------ we now might be on track00
		MOVE.B	ciapra+_ciaa,D2

*		;------ restore step delay
		MOVE.L	(SP)+,TDU_STEPDELAY(A3)

*		;------ unselect the drive
		BSR	TDGiveUnit

		BTST	#CIAB_DSKTRACK0,D2
		BEQ.S	Calib_30		; we ARE on track00

		INFOMSG	50,<'%s/TDCalibrate: Seek Error'>
		MOVEQ	#TDERR_SeekError,D0
		BRA.S	Calib_End

Calib_30:
*		;------ wait for settling time
		MOVE.L	TDU_SETTLEDELAY(A3),D0
		BSR	TDDelay
		MOVEQ	#0,D0			; mark us as successful

Calib_End:
		MOVE.L (SP)+,D2
		RTS

*****i* trackdisk.device/internal/TDStep ****************************
*
*   NAME
*	TDStep -- step the drive one track
*
*   SYNOPSIS
*	TDStep( ) UnitPtr, TDLib
*		  A3,	   A6
*
*   FUNCTION
*	This routine turns steps the drive one track in.  For the
*	moment it has built into it a 3ms delay.  Futures for this
*	routine is to suspend the task for the 3ms (instead of busy
*	waiting) and/or to fask-seek (e.g. do long seeks w/ faster
*	steps).
*
*   INPUTS
*	UnitPtr - A pointer to the unit structure for this unit.  Before
*		calling TDStep, the unit must have been allocated.
*
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*	A6 -- TDLib
*	A3 -- Ptr to Unit structure
*	A1 -- Ptr to PRB of _ciab
*

TDStep:
		INFOMSG	80,<'TDStep: called'>

		MOVE.B	TDU_6522(A3),D0
		LEA	ciaprb+_ciab,A1

		MOVE.B	D0,D1
		BCLR	#CIAB_DSKSTEP,D0
		MOVE.B	D0,(A1)			; step goes active

		; delay for 1 microsec
		; CIA is connected to E clk - can't hit it too fast

		MOVE.B	D1,(A1)			; step goes inactive

		BSR	TDGiveUnit

		;------ wait for correct step delay
		MOVE.L	TDU_STEPDELAY(A3),D0
		BSR	TDDelay

		BSR	TDGetUnit

		;------ This make sure the drive is selected - GetUnit doesn't
*		MOVE.B	TDU_6522(A3),ciaprb+_ciab

		RTS



*****i* trackdisk.device/internal/TDSeek ****************************
*
*   NAME
*	TDSeek -- Seek to a particular track.
*
*   SYNOPSIS
*	error = TDSeek( TrackNum ), UnitPtr, TDLib
*	         	D0,	    A3,	     A6
*
*   FUNCTION
*	This routine does a seek to the specified track.
*
*   INPUTS
*	TrackNum - the number of the track to seek to.
*
*   OUTPUTS
*	error - error number if there was an error, else zero
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
*---------------------------------------------------------------------
*
*   IMPLEMENTATION NOTES
*
*	    It is useful to keep the distinction between tracks
*	and cylinders in mind.	There are two tracks per cylinder
*	(one for each head of the disc).  We will first select the
*	correct head, and then we will seek the arm to the correct
*	spot over the disc.
*
*
*   REGISTER USAGE
*	A6 -- TDLib
*	A3 -- UnitPtr
*	D2 -- number of cylinders left to seek
*
*
*---------------------------------------------------------------------


TDSeek
		MOVEM.L D2/D3,-(SP)

		IFGE	INFO_LEVEL-80
		MOVE.L	D0,-(SP)
		PEA	0
		MOVE.W	TDU_SEEKTRK(A3),2(SP)
		INFOMSG	80,<'%s/TDSeek: from %ld to %ld'>
		ADDQ.L	#8,SP
		ENDC

*		;------ get current track number
		MOVE.W	TDU_SEEKTRK(A3),D2
		BPL.S	Seek_05

*		;------ negative numbers means we need to calibrate
		MOVE.L	D0,D2
		BSR	TDCalibrate
		TST.L	D0
		BNE.S	Seek_Err		; the calibrate failed

		EXG.L	D2,D0			; D2 is now null

Seek_05:

*		;------ see if we have moved
		CMP.W	D0,D2
		BEQ.S	Seek_End

*		;------ select the correct head, make sure disk is selected
		MOVE.L	D0,D3
		BSR	TDGetUnit
		MOVE.B	TDU_6522(A3),D1
		BSET	#CIAB_DSKSIDE,D1		; assume side 0

		BTST	#0,D3			; check the least bit

		BEQ.S	Seek_10

*		;------ it is really side 1
		BCLR	#CIAB_DSKSIDE,D1
Seek_10
		MOVE.B	D1,TDU_6522(A3)		; restore 6522 byte
		MOVE.B	D1,ciaprb+_ciab

*****		MOVE.W	D1,-(SP)
*****		MOVE.L	TDU_SIDESELECTDELAY(A3),D0
*****		BSR	TDDelay
*****		MOVE.W	(SP)+,D1

*		;------ now seek the arm

		MOVE.W	D3,TDU_SEEKTRK(A3)	; update track #

*		;------ turn into cylinder numbers
		LSR.W	#1,D2
		LSR.W	#1,D3

		LEA	ciaprb+_ciab,A1		; for stuffing later...

		SUB.W	D3,D2
		BCS.S	Seek_20

		BHI.S	Seek_30

		BSR	TDGiveUnit

*		;------ we didn't need to seek at all.	Wait for side sel settle
*****		MOVE.L	TDU_SIDESELECTDELAY(a3),D0
*****		BSR	TDDelay
		BRA.S	Seek_End

*		;------ we need to seek outwards (towards lower tracks)
Seek_20
		BCLR	#CIAB_DSKDIREC,D1
		MOVE.B	D1,TDU_6522(A3)
		MOVE.B	D1,(A1)			; give drive a few micros to
						; learn about direction...
		NEG.W	D2			; make the # of tracks > 0
		BRA.S	Seek_50

Seek_30
		BSET	#CIAB_DSKDIREC,D1
		MOVE.B	D1,TDU_6522(A3)
		MOVE.B	D1,(A1)			; see above comment re: direction
		BRA.S	Seek_50

Seek_40
		BSR	TDStep
Seek_50
		DBF	D2,Seek_40

		BSR	TDGiveUnit

		MOVE.L	TDU_SETTLEDELAY(A3),D0	; settling time
		BSR.S	TDDelay

Seek_End:
		CLEAR	D0

Seek_Err:

		MOVEM.L (SP)+,D2/D3
		RTS



*****i* trackdisk.device/internal/TDMotor ***************************
*
*   NAME
*	TDMotor -- turn the motor on or off
*
*   SYNOPSIS
*	OldState = TDMotor( OnOff ), UnitPtr, TDLib
*	D0,		    D0,	     A3,      A6
*
*   FUNCTION
*	This routine turns the motor on or off.	 If OnOff is non-zero
*	then the motor is turned on.  If it is zero then the motor is
*	turned off.
*
*   INPUTS
*	OnOff - A flag to tell which state the motor should be in.
*		zero	 ==> turn motor off
*		non-zero ==> turn motor on
*
*   OUTPUTS
*	OldState - a flag to tell the old state of the motor
*		zero	 ==> motor was off
*		non-zero ==> motor was on
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*	A6 -- TDLib
*


TDMotor:
		MOVEM.L	D2/D3/D4,-(SP)

		;------ put the user's request into "normal" form
		TST.L	D0
		SEQ	D1			; active low
		AND.B	#CIAF_DSKMOTOR,D1

*		;------ only get the unit if the motor is changing
		MOVE.B	TDU_6522(A3),D2
		AND.B	#CIAF_DSKMOTOR,D2
		CMP.B	D1,D2
		BEQ.S	TDMotor_Status

	IFGE	INFO_LEVEL-100
	PEA	0
	MOVE.B	D1,3(SP)
	PEA	0
	MOVE.B	TDU_6522(A3),3(SP)
	INFOMSG	100,<'%s/TDMotor: current state is %02lx.  New state is %02lx'>
	ADDQ.L	#8,SP
	ENDC

		;------ update the motor pointer
		BCLR.B	#CIAB_DSKMOTOR,TDU_6522(A3)
		OR.B	D1,TDU_6522(A3)

*		;------ get unit 8520 word
		BSR	TDGetUnit

		;------ we must first set up the motor before selecting
		MOVEQ	#-1,D1			; unselect all drives
		EOR.B	D2,D1			; d2 = DSKMOTOR or 0
		MOVE.B	D1,_ciab+ciaprb		; motor latches on selN->low
		MOVE.B	TDU_6522(A3),_ciab+ciaprb ; selects unit

		;------ allow others to use hardware
		BSR	TDGiveUnit

		;------ see if we turned it on or off
		BTST	#CIAB_DSKMOTOR,TDU_6522(A3)
		BNE.S	TDMotor_Status		; active low

		IFGE	INFO_LEVEL-60
		MOVE.L	A3,-(SP)
		INFOMSG	60,<'%s/TDMotor: turning on unit 0x%lx'>
		ADDQ.L	#4,SP
		ENDC

		;-- Instead of one big wait, wait 1/5 and check ready
		;-- until full time or READY.  Max 5 times.  REJ
		;-- spec says 500ms till up to speed, DSKRDY may not
		;-- be valid until 700ms.  We will wait no longer than 500ms.
MOTORCHECK	EQU	5

		MOVEQ	#MOTORCHECK-1,D3
TDMotor_loop:
		MOVE.L	#(TDT_MOTORON/MOTORCHECK),D0
		BSR.S	TDDelay

		; must select unit after getting it to read DSKRDY line!
		BSR	TDGetUnit		; get unit before using hw
*		MOVE.B	TDU_6522(A3),_ciab+ciaprb
		MOVE.B	ciapra+_ciaa,D4
		BSR	TDGiveUnit

		BTST	#CIAB_DSKRDY,D4
		DBEQ	D3,TDMotor_loop		; low means ready

TDMotor_Status:
		CLEAR	D0
		BTST	#CIAB_DSKMOTOR,D2
		SEQ	D0

TDMotor_End:
		MOVEM.L	(SP)+,D2/D3/D4
		RTS



*****i* trackdisk.device/internal/TDDelay ***************************
*
*   NAME
*	TDDelay -- delay for a given # of microseconds
*
*   SYNOPSIS
*	TDDelay( MicroSec ), TDLib
*		 D0,	     A6
*
*   FUNCTION
*	This routine wastes time in a busy wait loop.
*
*   INPUTS
*	MicroSec - The number of microseconds to waste
*
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*	    It takes about 1.5 micro seconds to one dbra instruction.
*	We will therefore multiply the argument by .75 before entering
*	the loop.  Also remember that .75 = .50 + .25
*
*
*   REGISTER USAGE
*	A6 -- TDLib
*
**********************************************************************
*

TDDelay:
		CMP.L	#300,D0
		BLT.S	Delay_BusyWait

		MOVEM.L	A0/A1,-(SP)

		LEA	TDU_WAITTIMER(A3),A1
		CLR.L	IOTV_TIME+TV_SECS(A1)
		MOVE.L	D0,IOTV_TIME+TV_MICRO(A1)

		LINKSYS	DoIO

	IFGE	INFO_LEVEL-30

	;------ check for an error from the timer
	LEA	TDU_WAITTIMER(A3),A1
	MOVE.B	IO_ERROR(A1),D0
	BEQ.S	Delay_NoErr

	EXT.W	D0
	EXT.L	D0
	MOVEM.L	D0/A0,-(SP)
*****	INFOMSG	30,<'%s/TDDelay: error %ld on timer wait'>
	ALERT	(AN_TrackDiskDev!AG_IOError!AO_TimerDev),,A0
	MOVEM.L	(SP)+,D0/A0

Delay_NoErr:
	ENDC

		MOVEM.L	(SP)+,A0/A1
		BRA.S	Delay_End

Delay_BusyWait:

	IFD	REALBUSYWAIT
	;------	commented out so 68020 might work
		LSR	#1,D0
		MOVE.L	D0,D1
		LSR	#1,D1
		ADD.L	D1,D0
		LSR	#2,D1
		SUB.L	D1,D0

		MOVE.W	D0,D1
		SWAP	D0

Delay_20:
		DBF	D1,Delay_20

		MOVE.W	#$0FFFF,D1
		SUBQ.W	#1,D0
		BPL.S	Delay_20
	ENDC

	IFND	REALBUSYWAIT
		MOVE.L	(A3),D1
Delay_30:
		MOVE.L	D1,(A3)		; can't be cached, even on '030 REJ
		DBRA	D0,Delay_30

	ENDC

Delay_End:

		RTS




*****i* trackdisk.device/internal/TDTrkRead ***************************
*
*   NAME
*	TDTrkRead -- read a raw track in from disc
*
*   SYNOPSIS
*	Error = TDTrkRead( Buffer, Length ), UnitPtr, TDLib
*	D0		   A0,	   D0:15-0,  A3,      A6
*
*	Error = TDNewTrkRead( Buffer, Func, Length ), UnitPtr, TDLib
*	D0		      A0,     A1    D0:15-0,  A3,      A6
*
*   FUNCTION
*	This routine reads a raw track in from disc in high
*	density format.  It will need to be mfm decoded by
*	software.
*
*	If TDNewTrkRead is called, the func routine will be called
*	just before the disk dma is started.  This function may do
*	things like wait for the index pulse.  It will be called with
*	the word to move into DSKLEN in D0, and a pointer to the
*	special chips in A1.  When this routine returns the
*	disk driver will wait for the disk completed interrupt.
*
*   INPUTS
*	Buffer - a pointer to be beginning of the area to read the
*	    track into.
*
*	Func - a function to call instead of turning on disk dma.
*
*	Length - the size (in bytes) of the data area.	Length must
*	    be an integer number of WORDS -- e.g. it must be evenly
*	    divisible by two.  The maximum transfer length is 32K bytes.
*
*   RESULTS
*	Error - error number (if there was an error) else zero
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*	TDTrkRead:
*	This routine now uses DiskSync to read tracks in.  The transfer
*	will start with the SECOND $4489 of the sync.
*	Note that it will re-sync at EVERY sync mark, even after the gap.
*	TDMfmAllignTrack counts on this.
*	Also note that when using disksync, one must set a timer to keep
*	from waiting forever for a sync that never comes (unformatted disk).
*
*	The timer must be 200ms + 1.5%*200ms + 5%*200ms + 1 sector time
*	(.09*200ms=18ms) + gap time (830/6812 * 200ms = 25ms) + some leeway
*	= 200ms + 3ms + 10ms + 18ms + 25ms + 44ms(leeway) = 300ms.
*	I picked leeway out of thin air. REJ
*
*   REGISTER USAGE
*	A6 -- TDLib
*	A3 -- UnitPtr
*	A1 -- ptr to _custom area
*
**********************************************************************
*

TDTrkRead:
		LEA	TDStartDmaSync(pc),A1
TDNewTrkRead:
	IFGE	INFO_LEVEL-40
	move.l	a0,-(sp)
	move.w	d0,-(sp)
	clr.w	-(sp)
	PUTMSG	40,<'%s/TDTrkRead: reading 0x%lx bytes to 0x%lx'>
	addq.l	#8,sp
	ENDC

		MOVEM.L	D2/A2/A4,-(SP)
		MOVE.L	A0,A2
		MOVE.L	D0,D2
		MOVE.L	A1,A4

*		;------ select the drive
		;------ this is needed because GetUnit doesn't select it!
		BSR	TDGetUnit
*		MOVE.B	TDU_6522(A3),ciaprb+_ciab

		;------ make sure disk write mode is set up at least 64
		;------ microsecs before turning on dma
		MOVE.W	#DSKDMAOFF,_custom+dsklen

		;---!!! wait for drive to relearn about side select
		MOVE.L	TDU_SIDESELECTDELAY(a3),D0
		BSR	TDDelay

*		;------ load the buffer pointer register
		LEA	_custom,A1
		MOVE.L	A2,dskpt(A1)

*		;------ clear the interrupt request register
		MOVE.W	#INTF_DSKBLK!INTF_DSKSYNC,intreq(A1)

*		;------ enable the disk block interrupt
		MOVE.W	#INTF_SETCLR!INTF_DSKBLK,intena(A1)

*		;------ check to see if there is a disc in the drive
		BTST	#CIAB_DSKCHANGE,ciapra+_ciaa
		BNE.S	TrkRead_LoadLength

TrkRead_Err:
		MOVEQ	#TDERR_DiskChanged,D2
		BRA.S	TrkRead_End

TrkRead_LoadLength:
*		;------ load the length register
		LSR.W	#1,D2			; turn bytes into words
		OR.W	#DSKLENF_DMAEN,D2
		MOVE.L	D2,D0
		JSR	(A4)

*		;------ wait until done	(returns D0)
		BSR	WaitDskTime

*		;------ clear the interrupt enable register
		LEA	_custom,A1
		MOVE.W	#INTF_DSKBLK,intena(A1)

*		;------ Turn off DMA
		MOVE.W	#DSKDMAOFF,dsklen(A1)

*		;------ Did the DiskDmaComplete interrupt occur?
		TST.L	D0
		BEQ.S	TrkRead_StopTimer

*		;------ Timer went off, pulled by WaitDskTime
		MOVEQ	#TDERR_NoSecHdr,D2	; can't find a sector!
		BRA.S	TrkRead_End

*		;------ dma completed - abort timer (may have gone off)
TrkRead_StopTimer:
		LEA	TDU_WAITTIMER(A3),A1
		MOVE.L	A1,D2			; save iob ptr
		ABORTIO
		MOVE.L	D2,A1
		LINKSYS	WaitIO			; removes it from the port

*		;------ check to see if there is a disc in the drive
		BTST	#CIAB_DSKCHANGE,ciapra+_ciaa
		BEQ.S	TrkRead_Err

		CLEAR	D2		; no errors
TrkRead_End:
		BSR	TDGiveUnit

		MOVE.L	D2,D0
		MOVEM.L	(SP)+,D2/A2/A4
		RTS


*****i* trackdisk.device/internal/TDTrkWrite **************************
*
*   NAME
*	TDTrkWrite -- write a raw track out to disc
*	TDNewTrkWrite -- write a raw track out to disc
*
*   SYNOPSIS
*	Error = TDTrkWrite( Buffer, Length ), UnitPtr, TDLib
*	D0		    A0,	    D0:15-0,  A3,      A6
*
*	Error = TDNewTrkWrite( Buffer, Func, Length ), UnitPtr, TDLib
*	D0		       A0,     A1    D0:15-0,  A3,      A6
*
*   FUNCTION
*	This routine writes a raw track out to disc in high
*	density format.  It will need to be mfm encoded by
*	software.
*
*	If TDNewTrkWrite is called, the func routine will be called
*	just before the disk dma is started.  This function may do
*	things like wait for the index pulse.  It will be called with
*	the word to move into DSKLEN in D0, and a pointer to the
*	special chips in A1.  When this routine returns the
*	disk driver will wait for the disk completed interrupt.
*
*   INPUTS
*	Buffer - a pointer to be beginning of the area to read the
*	    track into.
*
*	Func - a function to call instead of turning on disk dma.
*
*	Length - the size (in bytes) of the data area.	Length must
*	    be an integer number of WORDS -- e.g. it must be evenly
*	    divisible by two.  The maximum transfer length is 32K bytes.
*
*   RESULTS
*	Error - zero if sucessful; error number if there was an error.
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*	A6 -- TDLib
*	A3 -- UnitPtr
*
**********************************************************************
*

TDStartDmaSync:
*		;------ set up disksync
		MOVE.W	#DSYNC,dsksync(A1)
		MOVE.W	#ADKF_SETCLR!ADKF_WORDSYNC,adkcon(A1)

		BSR.S	TDStartDma

*		;------ Set up timer for 1 track + a bit (worst case)
*		;------ 200 ms + 1.5% (disk) + 5% (clock) + 18.5% (safety)
*		;------ equals around 250 ms
		LEA	TDU_WAITTIMER(A3),A1
		CLR.L	IOTV_TIME+TV_SECS(A1)
		MOVE.L	TDU_TDT_DISKSYNC(A3),IOTV_TIME+TV_MICRO(A1)
		BEGINIO
		RTS

TDStartDma:
*		;------ clear the disk dma signal bit and timer signal bit
		MOVEM.L	D0/A1,-(SP)
		CLEAR	D0
		MOVE.L	#TDSF_DSKBLK!TDSF_WAITTIMER,D1
		LINKSYS	SetSignal
		MOVEM.L	(SP)+,D0/A1

		MOVE.W	D0,dsklen(A1)
		MOVE.W	D0,dsklen(A1)
		RTS

TDTrkWrite:
		;------ for compatibility
		LEA.L	TDStartDma(pc),A1

TDNewTrkWrite:
	IFGE	INFO_LEVEL-40
	move.l	a0,-(sp)
	move.w	d0,-(sp)
	clr.w	-(sp)
	PUTMSG	40,<'%s/TDTrkWrite: writing 0x%lx bytes at 0x%lx'>
	addq.l	#8,sp
	ENDC

		MOVEM.L	D2/A2/A4,-(SP)
		MOVE.L	A0,A2
		MOVE.L	D0,D2
		MOVE.L	A1,A4

	IFGE	INFO_LEVEL-120
* copy root track to space buffer space when written
	cmp.w	#$50,TDU_SEEKTRK(a3)
	bne.s	3$
	move.l	TDU_BUFFER(a3),a0
	move.l	a0,a1
	move.l	#TDB_SIZE,d0
	add.l	d0,a1		; after buffer
	lsr.w	#2,d0		; longwords
	bra.s	2$
1$:	move.l	(a0)+,(a1)+
2$:	dbra	d0,1$
	move.l	TDU_BUFFER(a3),a0
	lea	TDB_SECPTRS+TDB_SIZE(a0),a0
	move	TDU_NUMSECS(a3),d0
	bra.s	5$
4$:	add.l	#TDB_SIZE,(a0)+
5$:	dbra	d0,4$

	move.l	a2,a0
	move.l	d2,d0
	move.l	a4,a1
3$:
	ENDC
*		;------ select the drive
		;------ this is needed because GetUnit doesn't select it!
		BSR	TDGetUnit
*		MOVE.B	TDU_6522(A3),ciaprb+_ciab

		;------ make sure disk write mode is set up at least 64
		;------ microsecs before turning on dma
		MOVE.W	#DSKDMAOFF,_custom+dsklen

		;---!!! wait for drive to relearn about side select
		MOVE.L	TDU_SIDESELECTDELAY(a3),D0
		BSR	TDDelay

*		;------ load the buffer pointer register
		LEA	_custom,A1
		MOVE.L	A2,dskpt(A1)

*		;------ clear the interrupt request register
		MOVE.W	#INTF_DSKBLK!INTF_DSKSYNC,intreq(A1)

*		;------ enable the disk block interrupt
		MOVE.W	#INTF_SETCLR!INTF_DSKBLK,intena(A1)

*		;------ check to see if there is a disc in the drive
		BTST	#CIAB_DSKCHANGE,ciapra+_ciaa
		BEQ	TrkWrite_ChangeErr

*		;------ check for write protect -- protected if bit is zero
TrkWrite_CheckProtect:
		BTST	#CIAB_DSKPROT,ciapra+_ciaa
		BEQ	TrkWrite_ProtErr

		;------ make sure we are still allowed to write
		;------ removed DISABLE locking from this test REJ
		BTST	#TDB_RESET,TD_FLAGS(A6)
		BEQ.S	TrkWrite_NotReset

		;------ return an error
		PUTMSG	40,<'%s/TDTrkWrite: we are reset'>
		MOVEQ	#TDERR_PostReset,D2
		BRA	TrkWrite_End

TrkWrite_NotReset:
		BSET	#TDB_WRITING,TD_FLAGS(A6)

		;------ Clear out the old precompensation
		;------ Also clear out disksync left by read routine
		MOVE.W	#ADKF_PRECOMP0!ADKF_PRECOMP1!ADKF_WORDSYNC,adkcon(A1)

		;------ get the current track number
		MOVE.W	TDU_SEEKTRK(A3),D0

		;------ check to see if 0 ns of precomp will do
		MOVE.W	#ADKF_SETCLR!ADKF_PRE000NS,D1
		CMP.W	TDU_COMP01TRACK(A3),D0
		BLS.S	TrkWrite_DoComp

		;------ check to see if 140 ns of precomp will do
		MOVE.W	#ADKF_SETCLR!ADKF_PRE140NS,D1
		CMP.W	TDU_COMP10TRACK(A3),D0
		BLS.S	TrkWrite_DoComp

		;------ check to see if 280 ns of precomp will do
		MOVE.W	#ADKF_SETCLR!ADKF_PRE280NS,D1
		CMP.W	TDU_COMP11TRACK(A3),D0
		BLS.S	TrkWrite_DoComp

		;------ well, 560 ns better do it!
		MOVE.W	#ADKF_SETCLR!ADKF_PRE560NS,D1

TrkWrite_DoComp:
		MOVE.W	D1,adkcon(A1)

*		;------ load the length register
		LSR.W	#1,D2			; turn bytes into words
		OR.W	#DSKLENF_DMAEN!DSKLENF_WRITE,D2
		MOVE.L	D2,D0

		;------ call the start dma routine
		JSR	(A4)

*		;------ wait for the message from the interrupt routine
		BSR.S	WaitDskBlk

*		;------ clear the interrupt enable register
		LEA	_custom,A1
		MOVE.W	#INTF_DSKBLK,intena(A1)

*		;------ wait for erase head to turn off
		MOVE.L	TDU_POSTWRITEDELAY(a3),D0
		BSR	TDDelay

*		;------ Turn off disc dma
		MOVE.W	#DSKDMAOFF,dsklen(A1)

		MOVE.B	TD_FLAGS(A6),D0
		BCLR	#TDB_WRITING,TD_FLAGS(A6)

		BTST	#TDB_RESET,D0
		BEQ.S	TrkWrite_SecondNotReset

		PUTMSG	40,<'%s/TDTrkWrite: after a reset'>
		LEA	TD_RESETIOB(A6),A1
		BEGINIO

TrkWrite_SecondNotReset:

*		;------ check to see if there is a disc in the drive
		BTST	#CIAB_DSKCHANGE,ciapra+_ciaa
		BEQ.S	TrkWrite_ChangeErr

		MOVEQ	#0,D2

TrkWrite_End:
*		;------ unselect the drive
		BSR	TDGiveUnit

		MOVE.L	D2,D0
		MOVEM.L	(SP)+,D2/A2/A4

		RTS

TrkWrite_ProtErr:
		MOVEQ	#TDERR_WriteProt,D2
		BRA.S	TrkWrite_End

TrkWrite_ChangeErr:
		MOVEQ	#TDERR_DiskChanged,D2
		BRA.S	TrkWrite_End


*****i* trackdisk.device/internal/TDDskBlk ****************************
*
*   NAME
*	TDDskBlk -- handle the disk block interrupt
*
*   SYNOPSIS
*	TDDskBlk( UnitPtr )
*	   	  A1
*
*   FUNCTION
*	This routine gets called by the resource to process a disk block
*	interrupt.
*	Note: also used in mfm.asm to indicate blitter done!
*
*   INPUTS
*
*   RESULTS
*	Error - zero if sucessful; error number if there was an error.
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*	Switched from send the timer request to the WaitPort to sending
*	a signal to the task.  This way I can safely have both timer
*	requests and disk dma signals active.
*
*   REGISTER USAGE
*	A6 -- TDLib
*	A3 -- UnitPtr
*
**********************************************************************
*


TDDskBlk:
*		LEA	TDU_WAITPORT(A1),A0
*		LEA	TDU_WAITTIMER(A1),A1
*		LINKLIB	_LVOPutMsg,ABSEXECBASE

		LEA	TDU_TCB(A1),A1
		MOVE.L	#TDSF_DSKBLK,D0
		LINKLIB	_LVOSignal,ABSEXECBASE
		RTS

*****i* trackdisk.device/internal/WaitDskTime ************************
*
*   NAME
*	WaitDskTime -- handle the disk block interrupt
*
*   SYNOPSIS
*	which = WaitDskTime(), UnitPtr
*	 D0  	  	         A3
*	0     = WaitDskBlk(), UnitPtr
*	D0   	  	        A3
*
*   FUNCTION
*	Called to wait for a dskblk interrupt or a timer request complete.
*	WaitDskBlk only wats for the DSKBLK.
*
*   INPUTS
*
*   RESULTS
*	which - zero if DSKBLK int; 1 if timer request complete
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*	Switched from send the timer request to the WaitPort to sending
*	a signal to the task.  This way I can safely have both timer
*	requests and disk dma signals active.
*
*   REGISTER USAGE
*	A6 -- TDLib
*	A3 -- UnitPtr
*
**********************************************************************
*
*
*	Wait for either disk dma done or timer
*
WaitDskTime:
		MOVE.L	D2,-(SP)
		MOVE.L	#TDSF_WAITTIMER!TDSF_DSKBLK,D2
		BRA.S	DoWaitDskBlk
*
*	Wait for disk done
*
WaitDskBlk:
		MOVE.L	D2,-(SP)
		MOVE.L	#TDSF_DSKBLK,D2

DoWaitDskBlk:
		MOVE.L	D2,D0
		LINKSYS	Wait

		; was it disk dma done?
		; always check dma complete first to avoid spuriosly
		; indicating failure
		BTST	#TDSB_DSKBLK,D0
		BEQ.S	CheckTime
		MOVEQ	#0,D0			; flag to TrkRead
		BRA.S	WaitExit

		; was it a timer signal?
CheckTime:	BTST	#TDSB_WAITTIMER,D0
		BEQ.S	DoWaitDskBlk

		; make sure we really got it and remove
		LEA	TDU_WAITPORT(A3),A0
		LINKSYS	GetMsg
		TST.L	D0
		BEQ.S	DoWaitDskBlk
		MOVEQ	#1,D0			; flag to TrkRead
WaitExit:
		MOVE.L	(SP)+,D2
		RTS

	END
@


33.17
log
@Removed unneeded selects, bsr->bsr.s
@
text
@d15 1
a15 1
* $Id: floppy.asm,v 33.16 90/11/26 17:38:29 jesup Exp Locker: jesup $
d20 3
d470 1
a470 1
*****		MOVE.L	#TDT_SIDESEL,D0
d492 1
a492 1
*****		MOVE.L	#TDT_SIDESEL,D0
d851 1
a851 1
		MOVE.L	#TDT_SIDESEL,D0
d1054 1
a1054 1
		MOVE.L	#TDT_SIDESEL,D0
d1133 1
a1133 1
		MOVE.L	#TDT_POSTWRITE,D0
@


33.16
log
@Added some debugging code (ifdefed out)
@
text
@d15 1
a15 1
* $Id: floppy.asm,v 33.14 90/06/01 23:15:20 jesup Exp $
d17 1
a17 1
* $Locker:  $
d20 3
d259 1
a259 1
		MOVE.B	TDU_6522(A3),_ciab+ciaprb	; select drive!
d371 1
a371 1
		MOVE.B	TDU_6522(A3),ciaprb+_ciab
d516 1
a516 1
		BSR	TDDelay
d630 1
a630 1
		MOVE.B	TDU_6522(A3),_ciab+ciaprb
d841 1
a841 1
		MOVE.B	TDU_6522(A3),ciaprb+_ciab
d1044 1
a1044 1
		MOVE.B	TDU_6522(A3),ciaprb+_ciab
@


33.15
log
@chnages for variable density
@
text
@d1008 1
d1014 24
@


33.14
log
@Conform to include standard du jour
@
text
@d15 1
a15 1
* $Id: /usr/rebma/jesup/trackdisk/RCS/floppy.asm,v 33.13 90/03/16 00:56:37 jesup Exp Locker: jesup $
d17 1
a17 1
* $Locker: jesup $
d20 3
d822 7
d980 1
a980 1
		MOVE.L	#TDT_DISKSYNC,IOTV_TIME+TV_MICRO(A1)
d1001 7
a1007 1

d1095 1
a1095 1
		BSR	WaitDskBlk
@


33.13
log
@Added store of direction before seek, to make sure drive has a few micros
to notice the direction, instead of driving them at the same time (at request
of grr).
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 33.12 89/09/06 18:51:12 jesup Exp $
d17 1
a17 1
* $Locker:  $
d20 5
@


33.12
log
@Changed comments, changed _AbsExecBase to ABSEXECBASE
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 33.11 89/05/15 21:15:52 jesup Exp $
d20 3
d468 2
d486 2
d494 1
@


33.11
log
@fixed usage of Getunit in TDMotor and Calibrate, added comments
fixed error return for timeout on read.
fixed bug in signal clearing in TDStartDma
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 33.10 89/04/27 23:36:22 jesup Exp $
d17 1
a17 1
* $Locker: jesup $
d20 5
a129 1
	XREF		_AbsExecBase
d131 2
a788 3
*	The timer must be 200ms + 1.5%*200ms + 5%*200ms + a little leeway
*	= 200ms + 3ms + 10ms + 37ms(leeway) = 250ms.  I picked leeway out
*	of thin air. REJ
d790 5
d860 1
a860 1
*		;------ is the timer request still active?
d1159 1
a1159 1
*		LINKLIB	_LVOPutMsg,_AbsExecBase
d1163 1
a1163 1
		LINKLIB	_LVOSignal,_AbsExecBase
d1225 2
@


33.10
log
@fixed autodocs, BSR/RTS->BRA
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 33.9 89/04/12 14:37:19 jesup Exp $
d20 3
d142 1
d239 1
d350 1
d430 1
a430 1
*		;------ select the correct head
d574 4
a577 4
		MOVEQ	#-1,D1
		EOR.B	D2,D1
		MOVE.B	D1,_ciab+ciaprb
		MOVE.B	TDU_6522(A3),_ciab+ciaprb
d603 1
d605 1
d608 1
d805 1
d854 1
a854 1
		BNE.S	TrkRead_Err
d856 6
a861 1
*		;------ timer didn't go off - abort timer
d863 1
d865 2
a866 2
		LEA	TDU_WAITTIMER(A3),A1
		LINKSYS	WaitIO		
a867 1

d872 1
a872 2
		CLEAR	D2

a873 1

a876 1

a877 1

d954 6
a959 2
*		;------ clear the disk dma signal bit
		BCLR	#TDSB_DSKBLK,TDU_TCB(A3)
d977 1
d1219 1
a1219 1
		MOVEQ	#0,D0
d1231 1
a1231 1
		MOVEQ	#1,D0
@


33.9
log
@fix to TDMotor
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 33.8 89/03/22 20:18:22 jesup Exp $
d20 3
d77 1
a77 1
******* Included Files ***********************************************
d110 1
a110 1
******* Imported Names ***********************************************
d140 1
a140 1
******* Exported Names ***********************************************
d161 1
a161 1
******* Local Definitions ********************************************
d165 1
a165 1
******* System/Drivers/TD/TDCalibrate ********************************
d284 1
a284 1
******* System/Drivers/TD/TDStep *************************************
d351 1
a351 1
******* System/Drivers/TD/TDSeek *************************************
d497 1
a497 1
******* System/Drivers/TD/TDMotor ************************************
d614 1
a614 1
******* System/Drivers/TD/TDDelay ************************************
d720 1
a720 1
******* System/Drivers/TD/TDTrkRead **********************************
d870 1
a870 1
******* System/Drivers/TD/TDTrkWrite *********************************
d1091 1
a1091 1
******* System/Drivers/TD/TDDskBlk ***********************************
d1142 1
a1142 1
******* System/Drivers/TD/WaitDskTime ***********************************
@


33.8
log
@Fixed TDDelay for small delays on 68030 w/ data cache
wait settledelay when reversing head direction on calibrate
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 33.7 89/03/22 17:33:25 jesup Exp $
d20 4
d535 1
a535 1
		MOVEM.L	D2/D3,-(SP)
d595 1
a595 1
		MOVE.B	ciapra+_ciaa,D0
d597 1
a597 1
		BTST	#CIAB_DSKRDY,D0
d606 1
a606 1
		MOVEM.L	(SP)+,D2/D3
@


33.7
log
@Made TDMotor release unit while waiting, small optimizations.
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 33.6 89/03/18 01:45:46 jesup Exp $
d20 3
d542 1
a542 1
		BEQ.S	TDMotor_Status_Only
d699 1
d701 1
a701 1
		TST.L	(A3)		; can't be cached
@


33.6
log
@Added xdef
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 33.5 89/02/17 19:07:37 jesup Exp $
d20 3
d209 1
a209 1
		LSR.L	#2,D2
d219 7
d229 5
d251 3
d563 3
a565 1
		;------ GiveUnit was here REJ
a569 2


d578 2
a585 2
		BTST	#CIAB_DSKRDY,ciapra+_ciaa
		DBEQ	D3,TDMotor_loop			; low means ready
d587 2
a588 1
TDMotor_Status:
d590 2
d593 1
a593 1
TDMotor_Status_Only:
d765 1
a765 1
*	of thin air.
d974 1
a974 1
		BNE.S	TrkWrite_CheckProtect
a975 4
TrkWrite_ChangeErr:
		MOVEQ	#TDERR_DiskChanged,D2
		BRA	TrkWrite_End

d982 1
a982 1
		DISABLE	A0
a988 1
		ENABLE	A0
a992 1
		ENABLE	A0
a1000 1

d1058 1
a1058 1
		BEQ	TrkWrite_ChangeErr
d1073 4
@


33.5
log
@TDMotor now waits .1 secs up to 5 times, and check ready after each
removed NOPs
TrkRead now uses the WORDSYNC ability
WaitDskBlk now uses signals instead of PutMsg, added routine to support
sync reads, WaitDskTime.  Can now use timer and dma at the same time.
minor code optimizations
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 33.4 86/04/09 16:07:25 neil Exp $
d20 8
d141 1
@


33.4
log
@68020 changes for real
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 33.3 86/04/04 09:56:31 neil Exp $
d17 1
a17 1
* $Locker: neil $
d20 3
d116 2
d134 1
d141 1
a142 1

d180 1
a180 1
		MOVEM.L D2,-(SP)
d203 1
a203 1
		BSR	TDStep
d217 1
a217 1
		BSR	TDStep
d244 1
a244 1
		MOVEM.L (SP)+,D2
d247 37
d285 29
d371 1
a371 1
		BPL	Seek_05
d377 1
a377 1
		BNE	Seek_Err		; the calibrate failed
d385 1
a385 1
		BEQ	Seek_End
d501 1
a501 1
		MOVE.L	D2,-(SP)
d512 1
a512 1
		BEQ	TDMotor_Status
d536 1
a536 2
		BSR	TDGiveUnit

d539 1
a539 1
		BNE	TDMotor_Status		; active low
d549 3
a551 2
		MOVE.L	#TDT_MOTORON,D0
		BSR	TDDelay
d553 7
d561 3
d569 1
a569 1
		MOVE.L	(SP)+,D2
a573 70


******* System/Drivers/TD/TDStep *************************************
*
*   NAME
*	TDStep -- step the drive one track
*
*   SYNOPSIS
*	TDStep( ) UnitPtr, TDLib
*		  A3,	   A6
*
*   FUNCTION
*	This routine turns steps the drive one track in.  For the
*	moment it has built into it a 3ms delay.  Futures for this
*	routine is to suspend the task for the 3ms (instead of busy
*	waiting) and/or to fask-seek (e.g. do long seeks w/ faster
*	steps).
*
*   INPUTS
*	UnitPtr - A pointer to the unit structure for this unit.  Before
*		calling TDStep, the unit must have been allocated.
*
*
*   EXCEPTIONS
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*
*   REGISTER USAGE
*	A6 -- TDLib
*	A3 -- Ptr to Unit structure
*	A1 -- Ptr to PRB of _ciab
*

TDStep:
		INFOMSG	80,<'TDStep: called'>

		MOVE.B	TDU_6522(A3),D0
		LEA	ciaprb+_ciab,A1

		MOVE.B	D0,D1
		BCLR	#CIAB_DSKSTEP,D0
		MOVE.B	D0,(A1)			; step goes active

		NOP				; delay for 1 microsec
		NOP

		MOVE.B	D1,(A1)			; step goes inactive

		BSR	TDGiveUnit

		;------ wait for correct step delay
		MOVE.L	TDU_STEPDELAY(A3),D0
		BSR	TDDelay

		BSR	TDGetUnit

		MOVE.B	TDU_6522(A3),ciaprb+_ciab

		RTS




d613 1
a613 1
		BLT	Delay_BusyWait
d726 10
d746 1
a746 1
		LEA	TDStartDma(pc),A1
d791 2
a792 2
*		;------ wait until done
		BSR	WaitDskBlk
d801 11
d885 16
d902 3
d971 2
a972 1
		MOVE.W	#ADKF_PRECOMP0!ADKF_PRECOMP1,adkcon(A1)
d1065 1
a1067 2
*	Buffer - a pointer to be beginning of the area to read the
*	    track into.
a1068 4
*	Length - the size (in bytes) of the data area.	Length must
*	    be an integer number of WORDS -- e.g. it must be evenly
*	    divisible by two.  The maximum transfer length is 32K bytes.
*
d1082 3
d1095 7
a1101 3
		LEA	TDU_WAITPORT(A1),A0
		LEA	TDU_WAITTIMER(A1),A1
		LINKLIB	_LVOPutMsg,_AbsExecBase
d1104 50
d1155 5
a1159 1
		MOVE.L	#TDSF_WAITTIMER,D0
d1162 11
d1176 4
a1179 2
		BEQ.S	WaitDskBlk

@


33.3
log
@Some trial changes for 68020 slowdowns
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 33.2 86/03/31 01:42:29 neil Exp $
d20 3
a540 3

		NOP				; delay for 1 microsec
		NOP
@


33.2
log
@removed a debugging statement in TDDelay.
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 33.1 86/03/29 14:13:36 neil Exp $
d17 1
a17 1
* $Locker:  $
d20 3
d542 3
d632 3
d651 8
@


33.1
log
@made seek and settle time programmable.  Isolated unit specific
initializers to the beginning of the unit structure
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 32.2 86/01/03 19:51:42 neil Exp $
d17 1
a17 1
* $Locker: neil $
d20 4
d605 1
a605 1
		IFGE	INFO_LEVEL-10
d607 4
a610 4
*		;------ check for an error from the timer
		LEA	TDU_WAITTIMER(A3),A1
		MOVE.B	IO_ERROR(A1),D0
		BEQ.S	Delay_NoErr
d612 6
a617 6
		EXT.W	D0
		EXT.L	D0
		MOVEM.L	D0/A0,-(SP)
*****		INFOMSG	1,<'%s/TDDelay: error %ld on timer wait'>
		ALERT	(AN_TrackDiskDev!AG_IOError!AO_TimerDev),,A0
		MOVEM.L	(SP)+,D0/A0
d620 1
a620 1
		ENDC
@


32.2
log
@Added reset catching code
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 32.1 85/12/23 17:18:58 neil Exp $
d20 3
d223 1
a223 1
		MOVE.L	#TDT_SETTLE,D0		; delay for 15 ms
d365 1
a365 1
		MOVE.L	#TDT_SETTLE,D0	; settling time
d539 2
a540 1
		MOVE.L	#TDT_STEP,D0		; delay for 3000 microsec (3 ms)
@


32.1
log
@Added rawread/rawwrite
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 30.1 85/08/29 12:29:31 neil Exp $
d17 1
a17 1
* $Locker:  $
d20 3
d53 1
d70 1
d72 1
d878 15
d942 12
@


30.1
log
@fixed bug in calibrate -- track 0 was not detected properly
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 27.2 85/07/11 06:23:05 neil Exp $
d20 3
d35 2
d39 1
d64 1
a65 1
	SECTION section
a66 1

d105 1
d107 2
d170 3
a172 1
		MOVEQ	#NUMCYLS/2,D2
d185 4
a188 1
		MOVE.W	#MAXCYLS,D2		; loop count
d645 3
d650 2
a651 2
*	    density format.  It will need to be mfm decoded by
*	    software.
d653 7
d664 2
d693 2
d696 1
a696 1
		MOVEM.L	D2/A2,-(SP)
d699 1
d735 2
a736 2
		MOVE.W	D2,dsklen(A1)
		MOVE.W	D2,dsklen(A1)
d760 1
a760 1
		MOVEM.L	(SP)+,D2/A2
d769 1
d775 3
d780 2
a781 2
*	    density format.  It will need to be mfm encoded by
*	    software.
d783 7
d794 2
d821 4
d827 6
a832 1
		MOVEM.L	D2/A2,-(SP)
d835 1
d872 1
a872 1
*		;------ Clear out the old precompensation
d875 2
a876 4
*		;------ Set up precompensation correctly
		MOVE.W	TDU_SEEKTRK(A3),D1
		CMP.W	#81,D1
		BLT.S	TrkWrite_0to80
a877 2
		MOVE.W	#ADKF_SETCLR!ADKF_PRE140NS,D1
		BRA.S	TrkWrite_DoComp
d879 1
a879 1
TrkWrite_0to80:
d881 2
d884 13
d903 1
a903 2
		MOVE.W	D2,dsklen(A1)
		MOVE.W	D2,dsklen(A1)
d905 3
d933 1
a933 1
		MOVEM.L	(SP)+,D2/A2
@


27.2
log
@Made seek report an error
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 27.1 85/06/24 13:36:48 neil Exp $
d17 1
a17 1
* $Locker: neil $
d20 3
d187 1
a187 1
		MOVE.B	ciapra+_ciaa,D0
d192 1
a192 1
		BTST	#CIAB_DSKTRACK0,D0
a514 1
		BSET	#CIAB_DSKSTEP,D0
@


27.1
log
@Upgrade to V27
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 26.1 85/06/17 15:13:08 neil Exp $
d17 1
a17 1
* $Locker:  $
d20 3
d213 2
a214 2
*	TDSeek( TrackNum ), UnitPtr, TDLib
*		D0,	    A3,	     A6
d222 2
d270 1
a270 1
		BNE	Seek_End		; the calibrate failed
d344 4
d437 1
a437 1
		IFGE	INFO_LEVEL-30
d439 1
a439 1
		INFOMSG	30,<'%s/TDMotor: turning on unit 0x%lx'>
@


26.1
log
@*** empty log message ***
@
text
@d15 1
a15 1
* $Header: floppy.asm,v 25.11 85/06/13 03:36:40 neil Exp $
d20 3
@
